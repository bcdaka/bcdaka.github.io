<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db085dbd731d8340c25c6c60d20644e6/" rel="bookmark">
			Qt加载海康威视库文件出错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编译时一直报错
解决：
编译器的问题，海康库用的是32位，Qt测试项目选了64位，改成32位后问题解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2acf5e1bd8213d539ee9dde01e6e625/" rel="bookmark">
			MySQL 9.0创新版发布！功能又进化了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：IT邦德
中国DBA联盟(ACDU)成员，10余年DBA工作经验，
Oracle、PostgreSQL ACE
CSDN博客专家及B站知名UP主，全网粉丝10万+
擅长主流Oracle、MySQL、PG、高斯及Greenplum备份恢复，
安装迁移，性能优化、故障应急处理
微信:jem_db
QQ交流群:587159446
公众号：IT邦德
文章目录 前言1.MySQL版本变更2.MySQL9.0功能进化2.1 添加或更改的功能2.2 弃用的功能2.3 删除的功能 3.MySQL9.0新版本体验3.1 安装依赖3.2 添加用户及组3.3 安装包上传解压3.4 正式安装3.5 初始化3.4 启动MySQL服务3.5 登陆新增用户 4.向量及JSON体验5.总结 前言 MySQL9.0创新版本已经正式发布，这次功能确实进化了不少！
1.MySQL版本变更 Oracle每季度发布一次MySQL更新，我平时也一直留意的官网的动态,2024年7月1推出了最新的 MySQL9.0创新版本.
MySQL发布模型分为两个主要轨道：LTS（长期支持）和创新。所有LTS和Innovation版本都包含错误和安全修复，并被视为生产级质量。
2.MySQL9.0功能进化 2.1 添加或更改的功能 1.从MySQL 9.0.0开始支持将 EXPLAIN ANALYZE的JSON输出保存到用户变量中 EXPLAIN ANALYZE FORMAT=JSON INTO @variable select_stmt mysql&gt; EXPLAIN FORMAT=JSON INTO @myupdate -&gt; UPDATE a SET name2 = "garcia" WHERE id = 3; mysql&gt; SELECT @myupdate, @mydelete\G *************************** 1. row *************************** @myupdate: { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2acf5e1bd8213d539ee9dde01e6e625/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98ade9383d70e1273264d2885b1d67d6/" rel="bookmark">
			【MySQL】数据库的增删查改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. 新增1.1 全插入1.2 指定某些列名插入1.3 多行插入1.4 边查询边插入 2. 约束2.1 非空约束2.2 唯一性约束2.3 默认值约束2.4 主键约束2.5 外键约束2.6 check 约束2.7 外键的逻辑删除 3. 查询 - 初阶3.1 全列查询3.2 指定列查询3.3 指定表达式查询3.4 别名查询3.5 去重查询3.6 排序查询3.7 条件查询3.8 分页查询 4. 查询 - 进阶4.1 聚合查询4.2 联合查询4.3 自连接查询4.4 嵌套查询4.5 合并查询 5. 修改6. 删除结语 前言 MySQL 最重要的部分就是在增删查改这四个操作上，我们在实际的开发中也会频繁运用到这些操作，尤其是查找，这部分有很多门道在里面，需要好好理解，多敲几遍代码熟悉熟悉
（由于博主本人在写博客的时候觉得 sql 关键字大写太累眼，故后续的 sql 语句将全部使用小写，因为它不区分大小写）
1. 新增 插入关键词：insert
1.1 全插入 insert [into] 表名 values (值，值 ......); 这里演示的是全插入，及插入的值要和表对应列的数量，数据类型以及顺序相匹配into 在此可以省略，但博主并不建议 在插入前我们要先选定数据库，然后可以用 desc 表名 先查看表的结构
接下来我们就可以向 student 插入一条数据，并查询表里的内容
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98ade9383d70e1273264d2885b1d67d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d85118751631dfd2b273f4be93fe360/" rel="bookmark">
			【JavaSE】图书管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 最终效果book包Book类BookList类 user包User类AdmiUser类（管理员类）NormalUser类（普通用户类） opeeration包IOperation接口FindOpertion类（查找操作）AddOpertion类（增加操作）DeletOpertion类（删除操作）BorrowOpertion类（借阅操作）ReturnOpertion 类（归还操作）ShowOpertion类（展示操作）ExitOpertion类（退出操作） Main类最终的关系图 最终效果 图书管理系统
book包 该包中有两个类，用来对书进行管理。
Book类 从开头视频可以看见，每本书有书名，作者，类型，价格，是否借出。我们将它们定义出来，并有快捷键获得get和set方法。
在生成一个构造方法，含书名，作者，类型，价格。
然后再快捷键重写Object的equals方法，重写toString方法。
注意：
因为直接重写的equals方法是对所有成员变量都进行对比，但是我们不需要对比借出状态（如果对比了那还怎么进行借阅和归还操作）。
还有toString方法我们要将借出的boolean类型转换为是否借出输出，就需要改为3目操作符( (this.isBorrowed)?", 已借出":", 未借出")
最终该类代码就是：
package book; import java.util.Objects; public class Book { private String name; private String author; private String type; private int price; private boolean isBorrowed; public Book(String name, String author, String type, int price) { this.name = name; this.author = author; this.type = type; this.price = price; } public boolean isBorrowed() { return isBorrowed; } public void setBorrowed(boolean borrowed) { isBorrowed = borrowed; } public String getName() { return name; } public void setName(String name) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d85118751631dfd2b273f4be93fe360/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd1915b9b121adaf8a4d191f0b3ca45a/" rel="bookmark">
			【JavaSE】String常用操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 String常用方法构造字符串字符串比较==比较equals方法比较equalsIngnoreCase方法compareTo方法compareToIngnoreCase方法 字符查找charAt方法indexof方法lastIndexOf方法 转化valueOf方法Integer.parseInt方法toUpperCase和toLowerCasetoCharArray方法format方法 替换replace方法replaceAll和replaceFirst 拆分split方法 截取substring 删除左右空格split 注意事项StringBuilder和StringBuﬀer String常用方法 构造字符串 常用的构造字符串有3种：
1.直接赋值String s = "abcd";
2.实例化调用构造方法String s = new String("abcd");
3.实例化传字符数组
char[] ch = {'a','b','c','d'}; String s = new String(ch); 字符串比较 ==比较 ==比较的是两个字符串引用对象的地址是否一致
equals方法比较 boolean equals(Object anObject); equals方法相同返回true，不同返回false；
equalsIngnoreCase方法 boolean equalsIgnoreCase(String anotherString); 该方法与equals方法使用一样，只是不会考虑大小写。
compareTo方法 int compareTo(String s); 3.compareTo方法比较的是两个字符串内容，使用形式字符串1.compareTo(字符串2);
按照字符的ASCII码值一个一个字符比较，字符串1大于字符串2返回正值，小于返回负值，相等返回0。和c语言中的strcmp方法比较规则一样。
compareToIngnoreCase方法 int compareToIgnoreCase(String str); 该方法与 compareTo方法使用一样，只是不会考虑大小写。
字符查找 charAt方法 char charAt(int index); 返回index下标的字符，注意越界。使用方法字符串名.charAt(数字);
indexof方法 int indexOf(int ch); 该方法返回第一次出现字符ch的值，用int是使用字符ASCII码值表示，没找到返回-1。
使用方法字符串名.indexof(字符);
该方法还有重载方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd1915b9b121adaf8a4d191f0b3ca45a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6e1d9513bd09e71fc10ce97f2872ab8/" rel="bookmark">
			【JavaSE】异常（Exception）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 异常是什么异常的分类异常的处理方法throw抛出异常异常的声明异常的捕获和处理finally 自定义异常类 异常是什么 异常就是程序在进行时的不正常行为，就像之前数组时会遇到空指针异常（NullPointerException），数组越界异常（ArrayIndexOutOfBoundsException）等等。
在java中异常由类来表示。
异常的分类 异常有一个顶层类Throwable；
Throwable派生出两个子类Error，Exception；
Error指的是Java虚拟机无法解决的严重问题，例如递归时一直开辟栈，导致栈溢出的错误。
Exception也分为两种异常：编译时异常和运行时异常。
编译时异常，这种异常顾名思义是在编译时候就会发生，这种异常要在程序中捕获声明才能让程序通过。
例如在比较器文章这篇中要实现clone方法时要通过throws关键字声明CloneNotSupportedException异常才能正常使用。
运行时异常，这种异常全在（RunTimeException）这个类和其子类之下，编译通过，运行报错，这种异常可以交给JVM处理。
异常的处理方法 异常的处理一般使用throw、try、catch、ﬁnally、throws这五个关键字。
throw抛出异常 在程序执行时，该语句引发异常，此时就可以通过throw抛出异常来告诉程序员原因。
一般格式为throw new 异常类名("异常产生的原因"); 例如我们进行方法传参为数组时参数是null抛出空指针异常：
public void printArray(int[] array){ if(null == array){ throw new NullPointException("数组传参为空null"); }else{ // } } 注意事项：
1.异常的抛出必须是在方法的内部
2.一旦异常抛出成功之后，在该语句之后的代码就不会执行了。就像上面写的else里面的语句不会执行了。
3.抛出的异常必须是Exception的或其子类，编译时异常必须在后续代码中处理，运行时异常可以交给JVM处理。
异常的声明 异常的声明就是告诉这个方法会报哪些异常，然后在这个方法内部不用对异常处理，让后面使用这个方法时对异常进行处理。
一般格式：
修饰符 返回值类型 方法名(参数表列) throws 异常类型1，异常类型2...{ } 注意事项：
1.格式不能变，一定是将声明放在参数表列后面，可以多个异常同时声明
2.声明的异常必须是Exception的或其子类。如果声明的异常是具有父子类关系，只声明父类也可以
异常的捕获和处理 使用try-catch语句来对异常进行捕获和处理。
使用格式：
try{ //会产生异常的代码 }catch(异常类型1 e){ //对异常的处理代码 }catch(异常类型2 e){ //对异常的处理代码 } 注意事项：
1.像前面一样如果try中抛出异常后还有代码就不会执行，
2.catch语句之间就像if-else语句一样，只会执行其中一个异常，
3.如果try中抛出异常被catch捕获并处理了那就会执行try-catch之后的语句，如果没有捕获到就不会执行
4.如果两个异常是父子类，一定要把子类异常catch放在前面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6e1d9513bd09e71fc10ce97f2872ab8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8422950a66b25780df32c8e630d80749/" rel="bookmark">
			【JavaSE】SE语法总结博文（附思维导图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 Java中的规范注释命名规范 数据类型与变量八大基本数据类型引用数据类型变量 运算符算数运算符增量运算符自增/减运算符关系运算符逻辑运算符位运算符移位运算符条件运算符（3目运算符） 程序逻辑控制顺序结构分支结构循环结构 方法方法定义格式方法重载递归 数组定义格式二维数组定义格式遍历 类和对象类定义格式，类实例化this引用构造方法封装访问修饰限定符static关键字 继承super 多态向上转型和向下转型重写 抽象类abstract关键字抽象方法 接口interface关键字接口特性 内部类比较器Comparable接口Comparator接口 深拷贝与浅拷贝String常用操作异常思维导图 Java中的规范 注释 //单行注释 /* 多行注释 */ /** 文档注释 */ 命名规范 命名时可以包含：字母、数字以及 下划线和 $ 符号等等。
但是不能以数字开头，也不能是关键字，且严格区分大小写。
类名：每个单词的首字母大写(大驼峰)；
方法名：首字母小写，后面每个单词的首字母大写(小驼峰)；
变量名：也用小驼峰；
包名：也用小驼峰；
接口名：大驼峰，一般加上首个字母写大写I；
异常名：大驼峰，一般最后以单词Exception结尾。
数据类型与变量 具体介绍在这篇文章：数据类型与变量详解
八大基本数据类型 整数：byte short int long；
浮点数：float double;
字符：char；
布尔类型：boolean；
除了int和char的包装类是Integer和character，其它都是将首字母大写，如long对应Long。
引用数据类型 类class；接口interface；数组[ ]；字符串变量String。
变量 简单说一下规则：
访问修饰限定符 数据类型 变量名 = ； 如果是引用数据类型在等号后面就跟相应的实例化
是基本数据类型直接赋值就行
运算符 运算符的详细解析在这篇文章：运算符详解
算数运算符 加： +
减 ：-
乘：*
除：/
取余：%
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8422950a66b25780df32c8e630d80749/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90acda46427170b4827559589421c34e/" rel="bookmark">
			【C语言】五子棋（c语言实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 最终效果菜单打印函数棋盘的初始化和打印人人对战落子判空函数悔棋函数判胜负函数人人对战 人机对战一是将直接调用rand生成随机值，这就不可控二是根据棋子赢面来判断哪里落子最好 如果选择退出程序直接exit就行主函数调用逻辑源代码 最终效果 五子棋c语言实现
菜单打印函数 使用这个函数来接收用户选择的模式，并通过返回值返回。
逻辑是使用一个死循环来打印，根据玩家输入的数来判断进入什么模式，输入错误数字就不出循环，正确就出循环。
int menu() { int choice = -1; while (1) { printf("----------------欢迎使用五子棋------------------------\n"); printf("- 请选择模式 -\n"); printf("- 1.人-人对战游戏 -\n"); printf("- 2.人-机对战游戏 -\n"); printf("- 0.退出游戏 -\n"); printf("------------------------------------------------------\n"); printf("------------------------------------------------------\n"); scanf("%d", &amp;choice); if (choice &gt; 4 || choice &lt; 0) printf("错误输入"); else break; } return choice; } 棋盘的初始化和打印 在这个函数中将表示棋盘的二维数组初始化为空状态，并通过棋盘数组的只来打印棋盘。打印棋盘时用到的符号：┏ ┳ ┓┣ ╋ ┫┗ ┻ ┛。要注意有些地方添加━和空格来控制打印的棋盘是正确的。
里面每一次打印都调用draw_chessman这个函数，在这个函数中将根据数组值来判断如何打印。
//绘制棋子 void draw_chessman(int type, char* tableline) { if (type == WHITE) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90acda46427170b4827559589421c34e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eb41bddbe553dd256de22b3f479fb0f/" rel="bookmark">
			Eureka介绍与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Eureka 是 Netflix 开发的一个开源服务注册与发现组件，它是 Spring Cloud 体系中的核心组件之一，主要用于微服务架构中的服务治理。Eureka 包含两个主要的组件：Eureka Server 和 Eureka Client。
Eureka Server 角色：充当服务注册中心，提供服务注册和发现的功能。工作原理：服务实例在启动时会向 Eureka Server 注册自己的信息（如IP地址、端口号等），并定期发送心跳以续约。Eureka Server 维护着一个服务注册表，记录了所有可用的服务实例。自我保护机制：Eureka Server 有一个自我保护机制，当网络分区或其他异常情况下，它不会盲目地从服务注册表中移除服务实例，以保证系统的稳定性2。 Eureka Client 角色：作为微服务系统中的服务实例，用于与 Eureka Server 进行交互。工作原理：Eureka Client 向 Eureka Server 发送心跳（默认周期为30秒），如果 Eureka Server 在多个心跳周期内没有接收到某个 Eureka Client 的心跳，它会将该实例从服务注册表中移除2。 使用 Eureka 搭建 Eureka Server：首先需要搭建一个 Eureka Server，作为服务注册中心。配置 Eureka Client：在微服务应用中添加 Eureka Client 依赖，配置 Eureka Server 的地址。服务注册与发现： 服务提供者（Provider）在启动时会向 Eureka Server 注册自己的服务信息。服务消费者（Consumer）在启动时也会向 Eureka Server 注册，并获取一份可用服务列表，然后可以通过 HTTP 或消息中间件远程调用服务提供者提供的服务​ Eureka 的配置示例 以下是 Eureka Server 和 Eureka Client 的配置示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5eb41bddbe553dd256de22b3f479fb0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/269476bc519adb567f92bdda6b8cead0/" rel="bookmark">
			【C语言】控制台扫雷（C语言实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 博文目的实现思路项目创建文件解释 具体实现判断玩家进行游戏还是退出扫雷棋盘的确定地图初始化埋雷玩家扫雷的实现雷判断函数 源码game.cgame.h扫雷.c 博文目的 相信不少人都学习了c语言的函数，循环，分支那我们就可以写一个控制台的扫雷小游戏来检验自己学得如何。
在做一件事之前我们都要先考虑我们学要做哪些。同样要实现一个扫雷小游戏，我们首先要思考学要做什么。
实现思路 实现思路可以参考以下步骤：
判断玩家进行游戏还是退出。
将扫雷的棋盘确定。
地图初始化。
埋雷 。
玩家扫雷的实现。
对玩家扫的是不是雷判断，周围几颗雷判断
项目创建 在所有开始之前我们先建项目。
​​​​
文件解释 对文件的解释如下：
创一个头文件game.h里面放都要用到的头文件和参数。
在game.c中实现我们的游戏逻辑。
在扫雷.c中把游戏串起来。
具体实现 具体实现可以参考如下思路：
判断玩家进行游戏还是退出 使用一个menu函数将作为菜单打印。
在主函数中使用do-while循环来判断用户是玩还是退出。
void menu() { printf("------------------------------\n"); printf("----------1.play--------------\n"); printf("----------0.exit--------------\n"); printf("------------------------------\n"); } int main() { int a; do { menu(); scanf("%d",&amp;a); } while(a); return 0; } 扫雷棋盘的确定 首先会先想到创建一个9 * 9的数组来表示棋盘。
但是我们就要考虑到判断周围雷个数时的判断，只创建9*9的棋盘，那在边界上的雷就不好判断周围有几颗雷，要判断就需要在写其他的判断方法不能与中间的判断方法统一了。
所以扩大一圈创建11 * 11的地图。
在头文件中使用宏定义出地图的长度和能访问的长度。
#define ROW 9 #define COL 9 #define ROWS ROW+2 #define COLS COL+2 地图初始化 我们将代表地图的数组有雷的设为1，无雷的设为0。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/269476bc519adb567f92bdda6b8cead0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a42a986bb082ccf80a38a0cf3c1d0fd1/" rel="bookmark">
			【数据结构】数据结构前置知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 基本概念与术语数据数据元素数据项数据对象数据结构 逻辑结构和物理结构物理结构顺序存储结构链式存储结构 逻辑结构集合结构线性结构树形结构图形结构 算法时间复杂度和空间复杂度大O的渐进表示法时间复杂度常数阶线性阶对数阶平方阶常见时间复杂度 空间复杂度 最好情况与平均情况于最坏情况 基本概念与术语 概念皆来自于《大话数据结构》。
数据 数据的概念：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别并输入给计算机处理的符号集合。
其实就是可以输入到计算机中，可以被计算机处理的字符。像文件，图像，声音，数字等等都是可以通过编码转换为字符来处理。
数据元素 数据元素的概念：是组成数据的，有一定意义的基本单位，在计算机中通常作为整体处理，也称为记录。
就像数学中由多个集合（子集合）构成的集合。子集就像数据元素一样
数据项 数据项概念：一个数据元素可以由若干个数据项组成。
数据项就像集合中的元素。
数据对象 数据对象：是性质相同的数据元素的集合，是数据的子集。
关系：
用∈代替一下‘包含于’关系
数据项∈数据元素∈数据对象∈数据
数据结构 数据结构概念:是互相之间存在一种或多种特定关系的数据元素的集合。
逻辑结构和物理结构 这是根据视点来区分的数据结构。
物理结构 物理结构：是指数据的逻辑结构在计算机中的存储形式。
顺序存储结构 是把数据元素存放在地址连续的存储单元里，其数据间的逻辑结构关系和物理结构关系是一致的。
链式存储结构 是把数据元素存放在任意位置的存储单元里，这组存储单元可以是连续的，也可以是不连续的。
逻辑结构 是指数据对象中数据元素之间的相互关系。
集合结构 集合结构中的数据元素除了同属于一个集合外，他们之间没有其他关系。
线性结构 线性结构中的数据元素之间是一对一的关系。
树形结构 树形结构中的数据元素之间存在一种一对多的层次关系。
图形结构 图形结构中的数据元素是多对多的关系。
算法 算法的定义：算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列。并且每条指令表示一个或多个操作。
算法五大特性：输入，输出，有穷性，确定性，可行性。
当多个算法都可以解决问题（在保证了正确性、可读性、健壮性），我们一般要考虑算法的时间效率，空间效率。我们就要用时间复杂度和空间复杂度来衡量。
时间复杂度和空间复杂度 其实我们要求时间复杂度就把语句执行次数给加起来表示为一个函数，空间复杂度开辟空间次数加起来表示为一个函数。然后将函数由大O的渐进表示法来表示。求得的就是复杂度。
我们通常使用大O的渐进表示法来表示时间复杂度和空间复杂度。
大O的渐进表示法 规则：
1.用常数1来取代运行时间中的所有加法常数；
2.在修改后的运行次数函数中，只保留最高阶项；
3.如果最高阶项存在且系数不为1，则将系数修改为1。
时间复杂度 常数阶 int n = 100; int sum = (n+1)*n/2; 这个高斯公式求和就是函数为3，常数都表示为1，大O渐进法（时间复杂度）表示就是O(1)。
线性阶 int n = 100; int sum = 0; for(int i = 0; i &lt; n; i++){ sum += i; } 这个求和就是函数为n+2，保留最高阶，大O渐进法（时间复杂度）表示就是O(n)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a42a986bb082ccf80a38a0cf3c1d0fd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4bab9cde1b468cad9f90823fdb66e6a/" rel="bookmark">
			【微服务】微服务之Feign 与 Ribbon
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 强烈推荐引言优点Feign示例什么是Ribbon？Ribbon 的优点Netflix Feign 和 Ribbon整合Feign 与 Ribbon 的关系Feign 与 Ribbon 结合使用的示例配置文件（application.yml）说明： Feign 与 Ribbon 结合使用的应用场景1. 动态服务发现与调用2. 负载均衡3. 服务熔断与重试4. 服务降级 总结强烈推荐专栏集锦写在最后 强烈推荐 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站:人工智能
引言 Netflix Feign 是一个声明式的 HTTP 客户端，用于简化微服务之间的 HTTP 请求。
Feign 通过注解来定义服务接口，并自动生成实现代码，从而减少了手工编写 HTTP 客户端的代码量。
它是 Netflix 开源软件套件的一部分，通常与 Spring Cloud 一起使用，以简化微服务架构中的服务调用。
优点 简化代码：
Feign 使用注解来声明 HTTP 请求，简化了代码编写和维护。开发人员只需定义接口和方法，Feign 会自动生成请求代码。
集成性好：
Feign 可以与其他 Netflix 开源组件（如 Eureka 和 Ribbon）无缝集成，从而实现服务发现和负载均衡。
可扩展性强：
Feign 提供了许多自定义功能，可以方便地扩展和定制，如日志记录、错误处理、编码和解码等。
支持多种编解码器：
Feign 支持多种编解码器（如 JSON、XML），并且可以通过自定义编解码器来支持其他格式。
支持 Spring Cloud：
Feign 与 Spring Cloud 紧密集成，可以轻松地在 Spring Boot 应用中使用。Spring Cloud Feign 提供了与 Spring Boot 环境的完美结合，使开发人员可以更方便地实现微服务调用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4bab9cde1b468cad9f90823fdb66e6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/589ada1cbb4485fb42871e8c54e4ecd4/" rel="bookmark">
			基于星火大模型的群聊对话分角色要素提取挑战赛|#AI夏令营#Datawhale#夏令营-Lora微调与prompt构造
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		赛题连接 https://challenge.xfyun.cn/topic/info?type=role-element-extraction&amp;option=phb
Datawhale Al夏令营 零基础入门大模型技术竞赛 数据集预处理 由于赛题官方限定使用了星火大模型，所以只能调用星火大模型的API或者使用零代码微调
首先训练数据很少是有129条，其中只有chat_text和infos两个属性，chat_text是聊天文本，infos就是提取的信息也是训练集标签，他的平均长度有6000左右对于星火对于信息提取任务已经很长了，而且最长的将近30000，如果使用星火大模型进行询问肯定是要被截断的，而且微调上传的数据也是有最大长度的，我门需要对数据进行处理。
数据简单清洗 简单的导包
from dataclasses import dataclass from sparkai.llm.llm import ChatSparkLLM, ChunkPrintHandler from sparkai.core.messages import ChatMessage import pandas as pd import os import json import re import matplotlib.pyplot as plt from tqdm import tqdm from math import ceil import numpy as np from copy import deepcopy import random tqdm.pandas() plt.rcParams['font.family'] = ['STFangsong'] plt.rcParams['axes.unicode_minus'] = False 加载数据
data_dir = "./data" train_file = "train.json" test_file = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/589ada1cbb4485fb42871e8c54e4ecd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d3d9a9352ad8761548f36312b1e67a8/" rel="bookmark">
			vue项目访问 域名/index.html 空页面问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很大可能是vue前端没做404页面，在路由不匹配时会跳转到空路由页面。
也可以把所有路由不匹配的网址全部跳转到域名首页。防止出现404或者页面错误。
如果使用docker nginx部署项目，配置文件上会有
try_files $uri $uri/ /index.html; 这段配置会尝试匹配请求的URI，如果找不到对应的文件或目录，则重定向到/index.html，让Vue路由接管路由的处理。 那么问题来了/index.html在vue里面是我们的静态文件，如果跳转过去会是空白页面（即app.vue页面）。所以可以直接去修改
location / { root /usr/share/nginx/html; try_files $uri $uri/ @test; index index.html index.htm; } location @test{ rewrite ^/(.*)$ 你的域名; # 跳转到首页 } 或者去找到默认的nginx.conf文件或者要映射的配置文件加上（这样只能避免/index.html跳转到域名首页，其他页面例如/index.html----xxx还会是空白页面）
if ($request_uri = /index.html) { return 301 你的域名; } 完整的映射配置文件
upstream my_server{ server 你的域名:8080; # 后端server 地址 keepalive 2000; } server { listen 80; #填写绑定证书的域名 server_name 你的域名, localhost; #把http的域名请求转成https，相当于用户访问http也可以自动跳转到https，避免出现网页提示不安全 return 301 https://$host$request_uri; } server { listen 443 ssl; server_name 你的域名.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d3d9a9352ad8761548f36312b1e67a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50d6d5da618794be0a5bffb468782dfd/" rel="bookmark">
			【项目日记（三）】搜索引擎-搜索模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		❣博主主页: 33的博客❣
▶️文章专栏分类:项目日记◀️
🚚我的代码仓库: 33的代码仓库🚚
🫵🫵🫵关注我带你了解更多项目内容
目录 1.前言2.项目回顾3.搜索流程3.1分词3.2触发3.3去重3.4排序3.5包装 4.总结 1.前言 在前面的文章中，我们已经完成了索引的制作，既然已经制作好了索引，我们该如何更具输入内容，匹配对应的结果呢?接下来我们就一起完成搜索模块。
2.项目回顾 到目前为止，我们已经实现了2个类，Parser和Index。
实现Parser类：
1.通过递归枚举出所有的HTML文件。
2.针对每一个HTML进行解析操作。
a)标题：直接使用文件名称
b)URL:基于文件路径进行简单的字符串拼接
c)正文：去掉script和html标签
3.把解析内容通过addDoc放入Index类中
实现Index类：
正排索引：ArrayList
倒排索引：HashMap&lt;String,ArrayList&gt;
1.查正排：直接按照下标来取ArrayList中的元素
2.查倒排：直接按照Key，来区HashMap中的元素
3.添加文档，供Parser类调用
a)构建正排索引，构造DocInfo对象，添加到索引末尾
b)构建倒排索引，先对标题，正文进行分词操作，统计词频，添加到Map中去
4.保存索引：基于json格式把索引数据保存到指定文件中。
5.加载索引：基于json格式对数据进行解析，存入内存。
3.搜索流程 1.【分词】根据输入内容进行分词操作2.【触发】针对分词结果来查倒排3.【去重】针对相同的文档进行去重4.【排序】针对去重结果按照权重排序5.【包装】针对排序结果查正牌，包装为Result进行返回数据 3.1分词 在使用Ansj技术进行分词操作的时候，会把空格，以及一些高频词例如a，an，is 等词语都分出来，但这些词语和我们的查询内容关联性并不大，我们就单独罗列出来，进行排除。网上有许多暂停词表可以自行下载，例如：
private static String STOP_WORD_PATH="D:/doc_searcher_index/stop_word.txt"; private HashSet&lt;String&gt; stopWords=new HashSet&lt;&gt;(); public DocSearcher(){ index.load(); loadStopWords(); } public void loadStopWords(){ try (BufferedReader bufferedReader=new BufferedReader(new FileReader(STOP_WORD_PATH))){ while (true){ String line=bufferedReader.readLine(); if (line==null){ break; } stopWords.add(line); } } catch (IOException e) { throw new RuntimeException(e); } } List&lt;Term&gt; oldTerms=ToAnalysis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50d6d5da618794be0a5bffb468782dfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31e8f3ac4c5851af96dc2cc56169906f/" rel="bookmark">
			微信小程序留言板1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		wxml：
&lt;view class="view2"&gt; &lt;text class="test1"&gt;留言：&lt;/text&gt;&lt;input type="text" class="input1" bindinput="ipt"/&gt;&lt;button class="btn" bindtap="btn"&gt;点击留言&lt;/button&gt; &lt;/view&gt; &lt;!-- 打印出来的值 --&gt; &lt;!-- {{num}} --&gt; &lt;view class="view1" wx:for="{{arr}}" wx:key="*this"&gt; {{item}} &lt;!-- &lt;text class="test3" bindtap="del" data-index="{{index}}"&gt;X&lt;/text&gt; --&gt; &lt;text class="test3" bindtap='del' data-index="{{index}}"&gt;删除&lt;/text&gt; &lt;/view&gt; wxjs：
// pages/stext/stext.js Page({ /** * 页面的初始数据 */ data: { arr:[11,22,33], num:'', index:'' }, ipt(e){ this.setData({ num:e.detail.value }) }, // 点击留言 btn(){ let newarr = this.data.arr; newarr.push(this.data.num) this.setData({ arr:newarr }) }, // 删除 // del(e){ // console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31e8f3ac4c5851af96dc2cc56169906f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6acefca7a7be9a5bf3c56e16c2bb60bb/" rel="bookmark">
			Python酷库之旅-第三方库openpyxl(20)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、 openpyxl库的由来
1、背景
2、起源
3、发展
4、特点
4-1、支持.xlsx格式
4-2、读写Excel文件
4-3、操作单元格
4-4、创建和修改工作表
4-5、样式设置
4-6、图表和公式
4-7、支持数字和日期格式
二、openpyxl库的优缺点
1、优点
1-1、支持现代Excel格式
1-2、功能丰富
1-3、易于使用
1-4、与Excel兼容性
1-5、性能良好
1-6、社区支持
1-7、跨平台
2、缺点
2-1、不支持旧版格式
2-2、某些特性支持有限
2-3、内存占用
2-4、文档和示例可能不足
2-5、依赖关系
2-6、学习曲线
三、openpyxl库的用途
1、读取Excel文件
2、写入Excel文件
3、修改Excel文件
4、自动化
5、与Excel交互
6、数据迁移和转换
7、创建模板化的报告
四、如何学好openpyxl库？
1、获取openpyxl库的属性和方法
2、获取openpyxl库的帮助信息
3、实战案例
3-241、设置单元格区域的除对角框线以外的全部边框
3-242、删除单元格区域的全部边框
3-243、设置单元格的颜色和背景
3-244、设置单元格的格式
3-245、设置单元格的对齐方式
3-246、缩小单元格内容以全部显示
3-247、设定/删除单元格的输入规则和信息提示(有效性设置)
3-248、为单元格设置条件格式/删除条件格式
3-249、为单元格插入指向工作簿内部的超链接/删除超链接
3-250、为单元格插入指向工作簿外部的超链接/删除超链接
3-251、为单元格添加批注/删除批注
3-252、修改单元格的批注
3-253、为单元格区域定义名称/删除名称(Name属性)
3-254、为单元格区域定义名称/删除名称(Add方法)
3-255、自动调整单元格大小
3-256、自动调整工作表全部单元格的大小
3-257、设置单元格的大小(以磅为单位)
3-258、设置单元格的大小(以cm为单位)
3-259、设置单元格的大小(以in为单位)
3-260、锁定单元格/解除单元格锁定
五、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、 openpyxl库的由来 openpyxl库的由来可以总结为以下几点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6acefca7a7be9a5bf3c56e16c2bb60bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a482b8e492d6fdead17029d3ff491cd/" rel="bookmark">
			摸鱼大数据——Spark基础——Spark On Yarn环境配置和部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Spark On Yarn的本质 Spark专注于分布式计算；Yarn专注于资源管理。
Spark将资源管理的工作交给了Yarn来负责!
2、环境搭建和启动 环境搭建 1.修改spark-env.sh
cd /export/server/spark/conf
cp spark-env.sh.template spark-env.sh
vim /export/server/spark/conf/spark-env.sh
在最后面添加以下内容:
HADOOP_CONF_DIR=/export/server/hadoop/etc/hadoop
YARN_CONF_DIR=/export/server/hadoop/etc/hadoop
SPARK_HISTORY_OPTS="-Dspark.history.fs.logDirectory=hdfs://node1:8020/sparklog/ -Dspark.history.fs.cleaner.enabled=true"
2.修改hadoop的yarn-site.xml
node1修改
cd /export/server/hadoop-3.3.0/etc/hadoop/
vim /export/server/hadoop-3.3.0/etc/hadoop/yarn-site.xml
在&lt;configuration&gt;下面添加以下内容:
&lt;!-- 设置yarn集群的内存分配方案 --&gt;
&lt;property&gt;
&lt;name&gt;yarn.nodemanager.resource.memory-mb&lt;/name&gt;
&lt;value&gt;20480&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
&lt;name&gt;yarn.scheduler.minimum-allocation-mb&lt;/name&gt;
&lt;value&gt;2048&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
&lt;name&gt;yarn.nodemanager.vmem-pmem-ratio&lt;/name&gt;
&lt;value&gt;2.1&lt;/value&gt;
&lt;/property&gt;
将其同步到其他两台
cd /export/server/hadoop/etc/hadoop
scp -r yarn-site.xml node2:$PWD
scp -r yarn-site.xml node3:$PWD
3.Spark设置历史服务地址
cd /export/server/spark/conf
cp spark-defaults.conf.template spark-defaults.conf
vim spark-defaults.conf
添加以下内容:
spark.eventLog.enabled true
spark.eventLog.dir hdfs://node1:8020/sparklog/
spark.eventLog.compress true
spark.yarn.historyServer.address node1:18080
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a482b8e492d6fdead17029d3ff491cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ada618c82c11640ab42b3b3a9fe4b490/" rel="bookmark">
			（超详细）数据结构——“队列”的深度解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：
1.队列的概念 2.队列的实现 3.代码实现队列 3.1 队列的初始化 3.2 插入 3.3 删除 3.4 队列的队头，队尾和大小
3.5 判空 3.6 销毁 3.7 测试 前言： 队列与栈都是线性表，它们的结构也非常类似，都是一头进一头出，那么它们有什么区别吗？答案是有的，虽然它们同为线性表，但是栈的出栈入栈方式为后进先出，而队列的出栈入栈方式为先进先出，具体我们在正文讲解。
1.队列的概念 队列：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有先进先出 FIFO(First In First Out) 入队列：进行插入操作的一端称为 队尾 出队列：进行删除操作的一端称为 队头。 2.队列的实现 队列与栈的结构类似，所以它和栈一样，使用链表和顺序表都可以实现队列，但是由于队列遵循先进先出的顺序，如果使用顺序表进行头删实现出队列的话，整个队列的数据需要频繁向前移动，代码效率相对较低，而使用链表的头删实现出队列的话，只需要将头节点删除即可，所以综上所述，我们将使用链表来实现队列。
3.代码实现队列 为了方便管理，我们还是将队列分为三个文件实现，分别是Queue.h （queue中译是队列的意思），Queue.c和test.c，由于我们选择使用链表实现队列，所以我们要先使用结构体实现一个单链表的节点，这个节点包含数据和下一个节点的地址，存储数据变量的类型由我们将来要存储的数据决定，所以我们使用typedef队对数据类型进行改名，在这里我们将int作为测试类型，所以我们要对int重命名：
typedef int QDataType; typedef struct QueueNode { QDataType val; struct QueueNode* next; }QNode; 基于队列先进先出的原则，我们需要得到队列的头和尾，必要时还需要知道队列的大小，所以我们额外创建一个结构体来存储队列的首地址，尾地址和队列的大小：
typedef struct Queue { QNode* Qtail; QNode* Qhead; int size; }Queue; 3.1 队列的初始化 我们现在有两个结构体，我们该如何初始化呢？是对两个结构体都初始化，还是对其中某一个初始化呢。答案是对存储有队列首地址和尾地址的结构体初始化，因为代表链表节点的QNode结构体的初始化是在我们在堆上开辟新的空间时初始化，所以我们这个时候的初始化是对Queue初始化：
void QInit(Queue* pq) { assert(pq); pq-&gt;Qhead = pq-&gt;Qtail = NULL; pq-&gt;size = 0; }//初始化 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ada618c82c11640ab42b3b3a9fe4b490/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d924bd757ac75a7bf4c5ba3dba13f28/" rel="bookmark">
			【AI 大模型】提示工程 ③ ( 提示词用法 | 提示词 Prompt 构成 | 提示词位置对权重的影响 | 提示词 Prompt 调优 | OpenAI 的 API 类型 | 提示词重要参数说明 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、提示词用法二、提示词 Prompt 构成1、提示词构成2、提示词位置对权重的影响3、定义角色的好处 三、提示词 Prompt 调优1、结合 训练数据 写提示词2、不知道训练数据的情况 - 不断尝试3、高质量提示词特征 - 小作文 四、OpenAI 的 API 类型1、续写文本 API 示例2、对话 API 示例 五、OpenAI API 中的重要参数说明 一、提示词用法 提示词 Prompt 的 两种用法 :
直接提问 : 直接向 GPT 大模型提问 , 得到一个具体问题的答案 , 如 : XXX 错误如何处理 ;集成应用 : 将 提示词 Prompt 集成到自己开发的应用程序中 , 结合自己公司的实际业务状况 , 生成与自己业务相关的一系列提示词 , 如 : 基于公司的一套知识库 + GPT 大模型 进行使用 ; 二、提示词 Prompt 构成 1、提示词构成 提示词 Prompt 构成 :
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d924bd757ac75a7bf4c5ba3dba13f28/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/204/">«</a>
	<span class="pagination__item pagination__item--current">205/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/206/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>