<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ea6f7d44734e7c2d6535e02b9cc91ef/" rel="bookmark">
			基于人体姿势估计的舞蹈检测（AI Dance based on Human Pose Estimation）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人体姿势骨架以图形格式表示人的方向。本质上，它是一组坐标，可以连接起来描述人的姿势。骨架中的每个坐标都被称为一个部分(或一个关节，或一个关键点)。两个部分之间的有效连接称为一对(或分支)。下面是一个人体姿势骨架样本。
因此，在本文中，我们将研究如何使用深度神经网络模型在OpenCV中执行人体姿态估计。
AI Dance based on Human Pose Estimation 1、数据集2、模型架构3、实验和结果加载网络结构读取图像和准备输入到网络做出预测并分析关键点画出骨架 1、数据集 由于缺乏高质量的数据集，人体姿态估计一直是一个具有挑战性的问题。如今，每一个AI挑战都是需要一个好的数据集来完成的。在过去的几年里，有挑战性的数据集已经发布，这使得研究人员更容易有效地解决这个问题。
以下是常用的数据集：
COCO Key-points 数据集MPII 人体姿态估计数据集VGG姿态数据集SURREAL（实际任务下的人体姿态数据集）UP-3D数据集
本文中我们采用的是COCO数据集进行人体姿态估计任务。 2、模型架构 OpenPose首先检测属于图像中每个人的部分(关键点)，然后将部分分配给不同的个体。下图是OpenPose模型的架构。
该模型将尺寸为w × h的彩色图像作为输入，并生成图像中每个人关键点的二维位置作为输出。检测分三个阶段进行:
阶段一：VGGNet的前10层用于为输入图像创建特征映射。阶段二：使用2分支多级CNN，其中第一个分支预测身体部位位置(例如肘部，膝盖等)的一组2D置信度图(S)。下面给出了关键点的置信度图和亲和度图。第二个分支预测部分亲和度的一组二维向量场(L)，它编码了部分之间的关联程度。阶段三：通过贪婪推理对置信度图和亲和度图进行解析，生成图像中所有人的二维关键点。
3、实验和结果 在本节中，为了简单起见，我们将加载用于理解单个人的人体姿态估计的训练模型。步骤如下:
下载模型的权重： 权重下载
加载网络结构 我们正在使用在Caffe深度学习框架上训练的模型。Caffe模型有2个文件：
Prototxt文件，它指定了神经网络的体系结构Caffemodel文件，存储训练模型的权重 读取图像和准备输入到网络 我们使用OpenCV读取的输入帧应该转换为输入blob(如Caffe)，以便它可以馈送到网络。这是使用blobFromImage函数完成的，该函数将图像从OpenCV格式转换为Caffe blob格式。首先，我们将像素值归一化为(0,1)。然后我们指定图像的尺寸。接下来，要减去的平均值，即(0,0,0)。
做出预测并分析关键点 一旦将图像传递给模型，就可以进行预测。输出为4D矩阵:
第一个维度是图像ID(如果向网络传递多个图像)。第二个维度表示关键点的索引。该模型生成的置信度图和部件关联图都是连接在一起的。对于COCO模型，它由57部分组成- 18关键点置信度图+ 1背景+ 19*2部分亲和图。第三个维度是输出映射的高度。第四个维度是输出映射的宽度。 画出骨架 当我们有关键点的时候我们就可以画骨架了只要把它们对连接起来。
# 2.Load the network # Specify the paths for the 2 files protoFile = "pose/mpi/pose_deploy_linevec_faster_4_stages.prototxt" weightsFile = "pose/mpi/pose_iter_160000.caffemodel" # Read the network into Memory net = cv2.dnn.readNetFromCaffe(protoFile, weightsFile) #3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ea6f7d44734e7c2d6535e02b9cc91ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e20b50ea299c9a003e30ff18603057e5/" rel="bookmark">
			python--连接oracle数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python--连接oracle数据库 前言一、安装cx_Oracle二、导入库三、数据库操作实例3.1 连接3.2数据库查询3.3数据库插入3.4 实例从某网站上面爬取彩票号码 四、异常4.1、运行时，出现连接数据库失败:DatabaseError:DPI-1047解决连接失败问题1、查看Oracle的版本号2、进入官网，下载对应Oracle版本3.下载cx_Oracle包:https://www.lfd.uci.edu/~gohlke/pythonlibs/#pyhook4.在使用python连接时，需要注意以下点： 前言 在进行数据库连接之前，一般都需要导入依赖的库，通过专门的库去处理对应的数据库连接，所以没安装对应的处理库的话，需要先进行安装、再导入，导入后即可正常使用。
一、安装cx_Oracle cx_Oracle:python链接oracle的驱动包，这个需要自己安装，https://pypi.python.org/pypi/cx_Oracle/5.3在这个网址中下载对应的驱动，下载驱动的时候一定要选好对应的版本，我的python是3.6的32位版本，所以在下载驱动的时候也要选择对应的版本，我选择的版本是cx_Oracle-5.3-11g.win32-py3.6.exe (md5)，下载后直接安装运行就行了，他会有一个自检，如果没有通过就说明你的驱动版本没有下载对。
在刚才下载好的oracle客户端版本中找到下面三个文件：oci.dll、oraocci11.dll、oraociei11.dll，将这几个dll文件复制到
Python\Python36-32\Lib\site-packages文件夹中。
二、导入库 代码如下（示例）：
import cx_Oracle 三、数据库操作实例 3.1 连接 import cx_Oracle conn = cx_Oracle.connect('xzt/xzt@localhost/testdb')#这里的顺序是用户名/密码@oracleserver的ip地址/数据库名字 cursor = conn.cursor() print('连接数据库成功！') sql = "select * from student" all = cursor.execute(sql) print(all.fetchall()) 3.2数据库查询 import cx_Oracle conn = cx_Oracle.connect('xzt/xzt@localhost/testdb') cursor = conn.cursor () cursor.execute ("SELECT * FROM STUDENT_TB") rows = cursor.fetchall() #得到所有数据集 for row in rows: print("%d, %s, %s, %s" % (row[0], row[1], row[2], row[3]))#python3以上版本中print()要加括号用了 print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e20b50ea299c9a003e30ff18603057e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4252d9787064982903e85343bbc1f724/" rel="bookmark">
			详细解决linux安装mysql后登录报错:Can‘t connect to local MySQL server through socket ‘/tmp/mysql.sock‘ (2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 详细解决linux安装mysql后登录报错:Can’t connect to local MySQL server through socket ‘/tmp/mysql.sock’ (2) 连接localhost通常通过一个Unix域套接字文件进行，一般会自动生成在/tmp/mysql.sock，所以我们登录mysql时是需要mysql.sock套接字的。但装完后发现/tmp下并没有mysql.sock文件也不要慌，要蛋定~
解决方式1 首先可以通过“ find / -name ‘mysql.sock’ ”找下当前环境中是否存在mysql.sock，
如果找到msyql.sock，并且不在/tmp下，直接建个软连接就可以了。不要想着把mysql.sock拷贝到/tmp下哦，这个文件是不能操作的，否则会报错cp: 无法打开"mysql.sock" 读取数据: 没有那个设备或地址。
如果本地环境下压根就没有mysql.sock这个文件，那就参考解决方式2。
ln -s /tmp/mysql.sock 路径/找到的mysql.sock 解决方式2 如果没有找到mysql.sock，那就找my.cnf文件，一般会在/etc/my.cnf，然后修改里面生成mysql.sock路径的信息，保存，重新登录就搞定了。然而~有些大哥可能连my.cnf这个文件也没有，就很神奇，很崩溃，那就跳过这个方式，看解决方式3
socket = /tmp/mysql.sock 解决方式3 如果没有my.cnf文件，其实也不一定要非得通过本地套接字的方式登录mysql，通过指定IP地址的方式也是可以登录mysql的，使用tcp方式连接mysql，而不使用本地sock方式
mysql -h127.0.0.1 -u root -p 如果通过指定ip还不能登录，或者报以下错误
那就修改my.cnf文件，注释掉下面这行，保存再重新登录就可以了。
#bind-address = 127.0.0.1 恶心的又回来了，有些大哥人家本来就没有my.cnf这个文件，改个毛线啊！哈哈哈，所以通过指定ip的方式还是行不通，最后最后，上面都解决不了你的问题，那就只能使用下面的最后一招必杀技了
最后一招必杀技 systemctl status mysqld #查看mysql的服务状态 systemctl restart mysqld #重启mysql服务 mysql -u root -p #重新登录 神功大成，搞定！厉害吧？越厉害的杀技往往越简单，哈哈哈… …嗝~ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98030e4b1a8daf8525d533999ba20274/" rel="bookmark">
			5、DataX（DataX简介、DataX架构原理、DataX部署、使用、同步MySQL数据到HDFS、同步HDFS数据到MySQL）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、DataX简介 1.1 DataX概述 DataX 是阿里巴巴开源的一个异构数据源离线同步工具，致力于实现包括关系型数据库(MySQL、Oracle等)、HDFS、Hive、ODPS、HBase、FTP等各种异构数据源之间稳定高效的数据同步功能。 源码地址：https://github.com/alibaba/DataX
1.2 DataX支持的数据源 DataX目前已经有了比较全面的插件体系，主流的RDBMS数据库、NOSQL、大数据计算系统都已经接入，目前支持数据如下图。
2、DataX架构原理 2.1 DataX设计理念 为了解决异构数据源同步问题，DataX将复杂的网状的同步链路变成了星型数据链路，DataX作为中间传输载体负责连接各种数据源。当需要接入一个新的数据源的时候，只需要将此数据源对接到DataX，便能跟已有的数据源做到无缝数据同步。
2.2 DataX框架设计 DataX本身作为离线数据同步框架，采用Framework + plugin架构构建。将数据源读取和写入抽象成为Reader/Writer插件，纳入到整个同步框架中。
Reader：数据采集模块，负责采集数据源的数据，将数据发送给Framework。
Writer：数据写入模块，负责不断向Framework取数据，并将数据写入到目的端。
Framework：用于连接Reader和Writer，作为两者的数据传输通道，并处理缓存，流控，并发，数据转换等核心技术问题。
2.3 DataX运行流程 下面用一个DataX作业生命周期的时序图说明DataX的运行流程、核心概念以及每个概念之间的关系。
2.4 DataX调度决策思路 举例来说，用户提交了一个DataX作业，并且配置了总的并发度为20，目的是对一个有100张分表的mysql数据源进行同步。DataX的调度决策思路是：
1）DataX Job根据分库分表切分策略，将同步工作分成100个Task。
2）根据配置的总的并发度20，以及每个Task Group的并发度5，DataX计算共需要分配4个TaskGroup。
3）4个TaskGroup平分100个Task，每一个TaskGroup负责运行25个Task。
2.5 DataX和Sqoop对比 3、DataX部署 1、下载DataX安装包并上传到hadoop102的/opt/software
下载地址：http://datax-opensource.oss-cn-hangzhou.aliyuncs.com/datax.tar.gz
2、解压datax.tar.gz到/opt/module
tar -zxvf datax.tar.gz -C /opt/module/ 3、自检，执行如下命令
python /opt/module/datax/bin/datax.py /opt/module/datax/job/job.json 4、出现如下内容，则表明安装成功
4、DataX使用 4.1 DataX使用概述 4.1.1 DataX任务提交命令 Datax的使用十分简单，用户只需要根据自己同步数据的数据源和目的地选择相应的Reader和Writer，并将Reader和Writer的信息配置在一个json文件中，然后执行如下命令提交数据同步任务即可。
python bin/datax.py path/to/your/job.json 4.1.2 DataX配置文件格式 可以使用如下命名查看DataX配置文件模板。
python bin/datax.py -r mysqlreader -w hdfswriter 配置文件模板如下，json最外层是一个job，job包含setting和content两部分，其中setting用于对整个job进行配置，content用户配置数据源和目的地。
4.2 同步MySQL数据到HDFS案例 案例要求：同步gmall数据库中base_province表数据到HDFS的/base_province目录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98030e4b1a8daf8525d533999ba20274/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/847a3144eb6e10f060c1957407a61794/" rel="bookmark">
			Google Colab免费GPU大揭晓：超详细使用攻略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、Google Colab介绍二、Colab限额、提供的GPU类型三、Colab的使用步骤3-1、添加Colab3-2、新建Colab、连接GPU、挂载Google Driver、上传文件3-3、查看显卡驱动3-4、导入自定义模块3-5、路径问题（注意）3-6、管理会话3-7、界面按钮详解3-8、交互指令3-9、安装需求包 结尾彩蛋总结 前言 Google Colab是一个基于云端的免费Jupyter笔记本环境，可供用户创建、分享、运行Python代码和机器学习模型。
一、Google Colab介绍 Google Colab是一个免费的基于云端的Jupyter笔记本环境，由Google提供。它提供了一个方便的平台，使用户可以创建、分享和协作编写Python代码和机器学习模型。以下是Google Colab的主要特点和功能：
免费：Google Colab是免费的，无需购买任何硬件或软件。云端运算：Google Colab使用Google的云端计算机，使用户能够在云端上运行代码，而不必担心自己的电脑性能和存储空间。Jupyter笔记本：Google Colab基于Jupyter笔记本，使用户可以创建和运行Python代码，以及撰写说明文档、添加图表等。GPU支持：Google Colab提供GPU加速，可加速深度学习和机器学习任务的运行。与Google Drive集成：Google Colab与Google Drive集成，可以直接在Google Drive中创建和保存笔记本，并与其他用户共享。代码协作：Google Colab支持多人协作，多个用户可以同时编辑同一个笔记本，使得团队合作更加高效。代码分享：Google Colab可以将笔记本转换为可分享的HTML或PDF格式，方便与他人分享代码和结果。 总之，Google Colab是一个方便、免费、强大的云端Jupyter笔记本环境，非常适合Python编程和机器学习任务。
二、Colab限额、提供的GPU类型 Colab限额：Colab能够免费提供资源的原因之一是它采用了动态限额，随时变化以满足用户需求，但无法保证资源的供应或无限供应（单次最长12小时，自动断开连接）。因此，总体使用量限额、空闲超时时长、虚拟机最长生命周期、可用GPU类型等都可能不时变化，Colab也不会公布这些限额，因为它们会快速变化。如果用户希望获得更高、更稳定的使用量限额，可以订阅Colab Pro。
提供的GPU类型： Colab 中的可用 GPU 类型是动态变化的，通常包括 Nvidia K80、T4、P4 和 P100。
三、Colab的使用步骤 Google Colab 支持挂载 Google Drive，方便存储文件。因此，我建议您直接使用 Google Drive 登录，以便更轻松地进行文件存储。 Google Driver官网
3-1、添加Colab 左上角新建，选择关联更多应用并且安装Colaboratory。
3-2、新建Colab、连接GPU、挂载Google Driver、上传文件 如图所示新建Jupyter笔记本
连接到GPU
1、先确定右侧显示RAM和磁盘，我的是已经连接，如果未连接，点击会出现连接到托管的运行时
2、之后点击左侧修改-&gt;笔记本设置-&gt;选择GPU。
挂载Google Driver：
1、为什么要挂载Google Driver：如果没有挂载Google Driver（Google 云端硬盘），则下载的文件只会暂时存在（即下次打开时，下载在Jupyter NoteBook的文件就不见了），初始阶段，左侧只有sample_data一个文件夹，当使用代码挂载Google Driver后，左侧出现driver文件夹，只要我们的文件放在driver后，文件就不会消失了（下次打开的时候需要再次使用代码挂载Google Driver）
2、代码： from google.colab import drive drive.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/847a3144eb6e10f060c1957407a61794/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36785041a0d8dcbcf0f8fb98b05e182a/" rel="bookmark">
			【C&#43;&#43;】多线程(thread)使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、前言1. 多线程的含义2. 进程与线程的区别 二、创建线程1. thread2. join() 和 detach()3. this_thread 三、std::mutex1. lock() 与 unlock()2. lock_guard3. unique_lock 四、condition_variable五、std::atomic如果这篇文章对你有所帮助，渴望获得你的一个点赞！ 一、前言 1. 多线程的含义 多线程（multithreading），是指在软件或者硬件上实现多个线程并发执行的技术。具有多核CPU的支持的计算机能够真正在同一时间执行多个程序片段，进而提升程序的处理性能。在一个程序中，这些独立运行的程序片段被称为“线程”（Thread），利用其编程的概念就叫作“多线程处理”。
2. 进程与线程的区别 进程是指一个程序的运行实例，而线程是指进程中独立的执行流程。一个进程可以有多个线程，多个线程之间可以并发执行。
一个程序有且只有一个进程，但可以拥有至少一个的线程。不同进程拥有不同的地址空间，互不相关，而不同线程共同拥有相同进程的地址空间。 二、创建线程 1. thread C++支持多线程编程，主要使用的是线程库&lt;thread&gt;。
示例1： 创建线程使用std::thread类
#include &lt;iostream&gt; #include &lt;thread&gt; //必须包含&lt;thread&gt;头文件 void threadFunctionA() { std::cout &lt;&lt; "Run New thread: 1" &lt;&lt; std::endl; } void threadFunctionB(int n) { std::cout &lt;&lt; "Run New thread: "&lt;&lt; n &lt;&lt; std::endl; } int main() { std::cout &lt;&lt; "Run Main Thread"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36785041a0d8dcbcf0f8fb98b05e182a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20d6bf062b7ea1d87da371b6a52ba7c7/" rel="bookmark">
			图书信息管理系统（python，sqlite）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sqlite数据库具体的结构设计和数据的截图放最后，因为图片有点多，但是能更好的帮助大家理解和实现该系统 目录
一、任务描述
二、功能实现
三、数据库设计​编辑
四、程序流程图（某些新加功能没有）
五、python代码（带注释）
六、具体数据库结构设计截图
1.Book表
2.Bookstate表​编辑​编辑
3.Login表​编辑​编辑
4.manager表​编辑​编辑
一、任务描述 基于python语言，实现图书馆图书管理的一般功能，要有管理员和用户两个角色。用户角色功能包括借书、还书、查询某本图书信息和图书状态、查询自己已借图书信息与状态等。管理员角色的功能包括录入图书、删除图书、修改图书信息、查询某本图书信息和状态、查询任意用户借书状态、总览图书馆图书信息和状态。
所设计的系统以菜单方式工作，为用户提供清晰的使用提示，依据用户的选择来进行各种处理。图书信息包括编号、书名、作者、出版社、出版日期、价格。录入的图书信息使用SQLite数据库保存，图书数量不少于20本。用户数量不少于10个。每个图书都有三个副本可供读者借阅。每个读者一次最多借两本书。
管理系统功能解释（包括但不局限于）：
录入：即增加一本书的记录到系统中。存储：即将图书信息保存在数据库中。查询：可根据书名、编号查找相关图书信息，若找到显示该书全部信息。用户可以查询已借的所有图书。管理员可以查询任一本书的信息和状态。管理员还可以总览所有书的信息和状态。修改：可修改一本书的除书名外其它信息。图书状态：提供该书在库、不在库的状态，该图书还有几个副本可借，归还期限、已超期时间等。借书：用户借书，有超期图书未还不能借新书。 还书：用户还书。能实现多用户的注册和登录，实现管理员登录 二、功能实现 用户功能:
（1）借书
（2）还书
（3）查询某本图书信息和图书状态
（4）查询自己已借图书信息与状态
（5）用户注册和登录
管理功能：
（1）管理员登录
（2）录入图书
（3）删除图书
（4）修改图书信息
（5）查询某本图书信息和状态
（6）查询任意用户借书状态
（7）总览图书馆图书信息和状态。
三、数据库设计
Book (图书信息表)：包括编号（number）、书名（name）、作者（author）、出版社（press）、出版日期（pubdate）、价格（price）
Bookstate（图书状态表）：包括副本编号（id）、用户编号（username）、图书编号（number）、是否在库（status），借书日期（borrowtime）、归还日期（returntime）、是否借出标志（flag）。
Login（用户表信息表）：账号（username）、密码（password）。
manager(管理员表格)：账号（username）、密码（password）。（后面新加的功能，所以图里里面没有）
四、程序流程图（某些新加功能没有） 五、python代码（带注释） import sqlite3 import datetime from datetime import datetime overtime_flag = 2 #超期标志 def getconn(): # 连接数据库 dbstr = "D:\学习\科目学习\专业综合训练2\PCT.db" conn = sqlite3.connect(dbstr) cur = conn.cursor() sqlstr = "create table if not exists Book(number nchar(10) primary key,name nchar(50),"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20d6bf062b7ea1d87da371b6a52ba7c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0883a745e3d0663db5dbebf3a2192d74/" rel="bookmark">
			MySQL：聚合函数（全面详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		聚合函数 前言一、聚合函数介绍1、AVG和SUM函数2、 MIN和MAX函数3、COUNT函数 二、GROUP BY1、基本使用2、使用多个列分组3、 GROUP BY中使用WITH ROLLUP 三、HAVING1、基本使用2、WHERE和HAVING的对比 四、 SELECT的执行过程1、查询的结构2、SELECT执行顺序3、SQL 的执行原理 前言 欢迎 免费报名 由CSDN主办的【Java基础及数据库Mysql的新星计划】(点击跳转) 我们特别为 Java基础 和 MySQL 这两个赛道开设了培训课程。
通过参与这个赛道，你将有机会与其他志同道合的学习者进行交流和互动，我们提供一系列精心设计的课程内容，旨在帮助你建立扎实的Java基础知识和MySQL数据库应用能力，分享学习心得和经验。我们的导师团队也将全程陪伴你，解答疑惑，提供指导和反馈，确保你的学习过程顺利和有效。
一、聚合函数介绍 什么是聚合函数
聚合函数作用于一组数据，并对一组数据返回一个值。 聚合函数类型 AVG()SUM()MAX()MIN()COUNT() 聚合函数语法 聚合函数不能嵌套调用。比如不能出现类似“AVG(SUM(字段名称))”形式的调用。
1、AVG和SUM函数 可以对数值型数据使用AVG 和 SUM 函数。
SELECT AVG(salary), MAX(salary),MIN(salary), SUM(salary) FROM employees WHERE job_id LIKE '%REP%'; 2、 MIN和MAX函数 可以对任意数据类型的数据使用 MIN 和 MAX 函数。
SELECT MIN(hire_date), MAX(hire_date) FROM	employees; 3、COUNT函数 COUNT(*)返回表中记录总数，适用于任意数据类型。 SELECT COUNT(*) FROM	employees WHERE department_id = 50; COUNT(expr) 返回expr不为空的记录总数。 SELECT COUNT(commission_pct) FROM employees WHERE department_id = 50; 问题：用count(*)，count(1)，count(列名)谁好呢?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0883a745e3d0663db5dbebf3a2192d74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9a858e28de61e5f9201cd175b1f1e24/" rel="bookmark">
			VMware 安装安卓虚拟机 一步一步的手把手教学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VMware 安装 安卓虚拟机 一、下载安卓镜像二、创建新的虚拟机三、勾选3D加速的情况新建安卓分区，配置系统重要重点来了！！！！！ 四、不勾选3D加速的情况五、安装完成六.网络设置七. 可以安装软件了 平台：PC
CPU：R7 3700X
显卡：3060
软件：VMware16
系统：Win10 1909
镜像：android-x86_64-9.0-r2-k49.iso 一、下载安卓镜像 网址：https://osdn.net/projects/android-x86/releases/71931
我用的迅雷下载，很快
度盘链接： pwd 2022
链接：https://pan.baidu.com/s/1HaSEB_CkyE_UmJwHlvzbrw?pwd=2022
包含Android7-9三个镜像
二、创建新的虚拟机 三、勾选3D加速的情况 到这里虚拟机就算创建完成了
新建安卓分区，配置系统 按下2，按上下箭头移动
重要 这里选择no！！！！！！！！！‘
否则下一步没办法出现bootable
新建一个分区
直接回车
选中bootable
回车
然后注意Flags这里
从上一步到这里后Flags会出现boot
移动箭头到Write这里
这里要输入 yes
但是显示不完整，问题不大
然后选择quit 退出
默认选择sda1，然后ok
选择ext4
确定格式化
安装GRUB
安装系统到刚刚的sda1
重点来了！！！！！ 出现下面这个页面的时候，千万不要着急
首先要断开CD的连接！！！
勾勾去掉！！！！
然后选择 Reboot
选择第一个
四、不勾选3D加速的情况 注意：此时镜像是Android 8.1 了
如果勾选3D加速已经可以正常进入的情况下，可以跳过这里，直接去第五
这里选择Reboot
这个时候其实已经安装完成了
但是显示不了图形界面
这时候关掉虚拟机重新开机，选择第二个Debug Mode，回车
进入另一个界面后按下回车，然后mount -o remount,rw /mnt
出现这个界面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9a858e28de61e5f9201cd175b1f1e24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1678d5e5c1048850b455700411d77d80/" rel="bookmark">
			浅谈【AI、算力赋能】“大算力”时代的到来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔻一、【💣 话题引入：“AI+算力=最强龙头”，你怎么看？】 🙈 AI人工智能是否可以取代人类？ 🙈 应不应该限制人工智能的发展？ 🙈 AI研究及龙头行业迎来哪些时代机遇与挑战？
🙈 AI人工智能可能会怎样危害人类？
面对科技的高速发展，虽说为人类社会带来了前所未有的机遇和挑战，但同时也产生了众多值得深思的问题。
AI人工智能正以“有益”和“有害”的方式影响着人类，AI的发展是否会迎来觉醒时刻。
🔻二、【🔉 AI、算力赋能为何能成为时代前沿❓】 🌋 数据爆炸： 随着互联网、物联网、社交媒体等技术的发展，数据量呈爆炸式增长。AI、算力可以帮助人们更好地处理和分析这些数据，从而提高数据的价值和利用率。
🎉 自动化需求： 随着人工智能技术的发展，越来越多的工作可以被自动化完成。AI、算力可以帮助人们更好地实现自动化，提高工作效率和质量。
👀 个性化需求： 随着人们对个性化服务的需求不断增加，AI、算力可以帮助企业更好地了解客户需求，提供更加个性化的服务。
💭 人工智能的发展： 人工智能技术的发展已经进入了一个快速发展的阶段，AI、算力是人工智能技术发展的重要支撑。
🎊 产业升级： AI、算力可以帮助企业实现数字化、智能化升级，提高企业的竞争力和创新能力。
综上——AI、算力赋能是时代前沿的原因主要是因为它们可以帮助人们更好地处理和分析数据，实现自动化，提供个性化服务，支撑人工智能技术发展，促进产业升级。
🔻三、【🔉 未来的科技趋势❓】 🔔 人工智能： 人工智能将继续发展，包括机器学习、深度学习、自然语言处理、计算机视觉等领域。人工智能将应用于各个领域，包括医疗、金融、制造业、交通、教育等。
📱 5G技术： 5G技术将成为未来通信技术的主流，它将带来更快的网速、更低的延迟和更大的带宽，为人们提供更加高效的通信服务。
🌐 物联网： 物联网将继续发展，将连接更多的设备和物品，实现更加智能化的生活和工作。
☁ 区块链： 区块链技术将继续发展，将应用于金融、物流、医疗等领域，实现更加安全、透明和高效的数据交换和管理。
💊 生物技术： 生物技术将成为未来的重要领域，包括基因编辑、人工合成生物、生物传感器等技术，将为医疗、环保、食品等领域带来重大的变革。
🌀 虚拟现实和增强现实： 虚拟现实和增强现实技术将继续发展，将应用于游戏、教育、医疗等领域，为人们提供更加沉浸式的体验。
这些技术将为人们的生活和工作带来更加智能化、高效化和便利化的体验。
🔻四、【🔉 AI人工智能是否可以取代人类，应不应该限制其发展❓】 🌳 案例1： AI智能主持人24小时无休、零工资、零失误。
🍀 案例2： AI发展带来安全和隐私问题，不法分子恶意利用，制作违法和不良信息，诋毁贬损他人名誉，仿冒他人身份等现象也随之产生。
🌲 案例3： 使用ChatGPT做作业，AI作弊写出全班最佳论文。
🌴 案例4： 在各大领域代替部分人力资源，这可能会导致部分人员失去工作机会。
🔻五、【🔉关于人工智能是否会“消灭”人类:❓】 ⚡ 1、违背意愿的消灭： 人工智能从肉体上消灭人类或统治世界，从目前技术发展趋势和水平来看，可能性不是很大。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1678d5e5c1048850b455700411d77d80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2282f133522bcabe2875b86d798ea83/" rel="bookmark">
			【Java 基础篇】Java 迭代器详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 导言一、迭代器的概念二、使用迭代器三、迭代器的优势四、迭代器的常见技巧1. 使用增强的 for 循环2. 遍历过程中的修改3. 避免重复创建迭代器4. 使用迭代器的限制功能 五、示例代码总结 导言 在 Java 中，迭代器是一种常用的设计模式，用于遍历集合中的元素。它提供了一种统一的方式来访问集合中的元素，而不必暴露集合的内部实现细节。本文将介绍 Java 迭代器的概念、使用方法和常见技巧，并提供一些示例代码。
一、迭代器的概念 迭代器是一种对象，它允许按顺序访问集合中的元素，而不需要知道集合的底层结构。通过使用迭代器，我们可以遍历集合并访问其中的元素，而无需关心集合的具体实现方式。
Java 提供了 Iterator 接口作为迭代器的基础接口。该接口定义了一组用于访问集合元素的方法，包括 hasNext、next 和 remove 等。
二、使用迭代器 要使用迭代器遍历集合，我们需要进行以下步骤：
获取集合的迭代器对象：通过调用集合的 iterator 方法获取迭代器对象。例如，对于 ArrayList 集合，可以使用 iterator() 方法获取迭代器对象。 List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 添加元素到集合中 Iterator&lt;String&gt; iterator = list.iterator(); 遍历集合元素：通过使用迭代器的 hasNext 和 next 方法来遍历集合中的元素。hasNext 方法用于检查是否还有下一个元素，next 方法用于获取下一个元素的值。 while (iterator.hasNext()) { String element = iterator.next(); // 处理元素 } 可选操作：迭代器还提供了 remove 方法，用于从集合中删除当前迭代的元素。需要注意的是，该方法只能在调用 next 方法后才能调用，且每次只能调用一次。 iterator.remove(); 三、迭代器的优势 使用迭代器遍历集合具有以下优势：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2282f133522bcabe2875b86d798ea83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71dd495e7e9e6de930a0ae07f222fc0a/" rel="bookmark">
			Android Studio简易计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
第一步，创建新项目
第二步，设计UI
第三步，实现计算逻辑
第四步，测试应用程序
随着移动互联网的普及，手机应用程序已经成为人们生活中不可或缺的一部分。计算器是一类被广泛使用的应用程序之一，因此学习如何开发一款简易的计算器应用程序是学习Android Studio开发的一个很好的开始。
Android Studio是一款Google开发的用于创建安卓应用的集成开发环境(IDE), 它可以帮助开发者快速设计、开发和测试应用程序。接下来我将为大家介绍如何使用Android Studio创建一个简易的计算器应用程序。
第一步，创建新项目 打开Android Studio并创建一个新项目。
选择"Empty Activity"模板，然后为项目命名，选择存储项目的位置。
第二步，设计UI 我们需要设计一个简单的计算器界面。添加两个EditText元素用于显示计算器输入和输出结果。接着，在XML文件中依次添加多个Button元素，这些元素将作为计算器中需要用到的各种计算操作进行排列。这些Button元素使用GridLayout布局将它们排列在一起。
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;GridLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity" android:orientation="vertical"&gt; &lt;GridLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical"&gt; &lt;EditText android:id="@+id/ed_srk" android:layout_width="match_parent" android:layout_height="100dp" android:hint="输入框"/&gt; &lt;EditText android:id="@+id/ed_sck" android:layout_width="match_parent" android:layout_height="100dp" android:hint="输出框"/&gt; &lt;/GridLayout&gt; &lt;GridLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_gravity="center|top" android:orientation="horizontal" android:rowCount="5" android:columnCount="4"&gt; &lt;Button android:id="@+id/btn_c" android:layout_width="160dp" android:layout_height="60dp" android:layout_columnSpan="2" android:text="c"/&gt; &lt;Button android:id="@+id/btn_del" android:layout_width="80dp" android:layout_height="60dp" android:text="DEL"/&gt; &lt;Button android:id="@+id/btn_chu" android:layout_width="80dp" android:layout_height="60dp" android:text="/"/&gt; &lt;Button android:id="@+id/btn7" android:layout_width="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71dd495e7e9e6de930a0ae07f222fc0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6584d8ce727e1bcc854094ed0491ce25/" rel="bookmark">
			基于Python的海量豆瓣电影、数据获取、数据预处理、数据分析、可视化、大屏设计项目（含数据库）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 项目介绍研究背景国内外研究现状分析研究目的研究意义研究总体设计网络爬虫介绍豆瓣电影数据的采集数据预处理大数据分析及可视化豆瓣影评结构化分析 大屏可视化文本可视化总结每文一语 项目介绍 有需要本项目的代码或文档以及全部资源，或者部署调试可以私信博主！！！！！！！！！！
本文基于Python的网络爬虫手段对豆瓣电影网站进行数据的抓取，通过合理的分析豆瓣网站的网页结构，并设计出规则来获取电影数据的JSON数据包，采用正态分布的延时措施对数据进行大量的获取。并利用Python的Pandas数据分析库，对获取的数据进行预处理，将非结构化的数据清洗为干净的数据，便于后续的大数据分析，分别对数据进行空值检测与处理，字符串的约束，字段值的扩充，以及数据的清洗。
然后将清洗好的数据，存储到MySQL结构化的数据库中，进行大数据分析，结合多维度的字段，对电影数据进行结构化分析，和喜爱程度分析，以及趋势分析等，最终将分析结果通过Pyecharts网页可视化展现出来，并设计大屏可视化，达到一体化的效果。
本研究利用自动化爬虫程序，获取了大量的豆瓣电影数据，并通过数据清洗和预处理，将清洗好的数据存入MySQL数据库中。通过调用数据库中的结构化数据，对电影评分指标分布、用户喜爱程度、影评文本、地域等多维度数据进行分析，并采用pyecharts前端可视化库进行展示。
最后，利用pyecharts的Page模块，对同一个分析维度的可视化展示进行统一展示，构建基于豆瓣电影分析的大屏可视化。本研究通过数据分析和可视化技术，为电影产业提供了有价值的参考和支持。
研究背景 豆瓣电影是目前国内最受欢迎的电影评价网站之一，用户可以在该网站上进行电影评分、评论、收藏等操作。由于豆瓣电影上的数据非常丰富，因此对这些数据进行分析和可视化研究有助于我们深入了解电影市场的发展趋势和用户评价偏好，为电影制作和营销提供有益的参考。
随着社会的不断发展，电影产业也在不断壮大，越来越多的人开始重视电影的文化价值和商业价值。豆瓣电影上的评分和评论成为了衡量电影品质和受欢迎程度的重要标准之一。通过对豆瓣电影上的数据进行分析和可视化研究，我们可以深入了解用户对电影的评价和偏好，挖掘电影市场的发展趋势和商业机会，为电影制作和营销提供更有针对性的建议和策略。
本次研究的主要目的是分析豆瓣电影上的电影数据，探究不同类型电影的评分和用户评价，同时还将利用Python中的数据分析和可视化工具，如Pandas、Matplotlib和Seaborn等，对这些数据进行处理和可视化呈现，以期能够更加直观地展示分析结果。
此处省略…
国内外研究现状分析 豆瓣电影是中国最大的电影社区之一，该平台拥有海量的电影信息，因此成为了众多电影爱好者最受欢迎的平台之一。同时，豆瓣电影也是一个重要的电影评价平台，用户可以在该平台上对电影进行评分和评论。因此，豆瓣电影的数据分析和可视化研究成为了热门的研究方向之一。
此处省略…
研究目的 本研究旨在通过Python对豆瓣电影数据进行分析和可视化研究，以探究豆瓣电影的观影人群、影片评价、影片时长、电影类型等方面的特征，并基于此提出一些有益的结论和建议。
研究内容：
1.数据采集和清洗
本研究将采用Python爬虫对豆瓣电影网站上的电影信息进行数据采集，并通过数据清洗和处理，确保数据的准确性和完整性。数据采集的主要内容包括电影名称、导演、演员、评分、评论数、电影类型、制片国家/地区、上映日期、时长等。
2.观影人群特征分析
通过对豆瓣电影网站上的用户信息进行数据采集和处理，本研究将探究豆瓣电影的观影人群的性别、年龄、地域、职业等方面的特征，以了解不同人群的观影偏好和评价。
3.电影评价分析
此处省略…
研究意义 随着互联网技术和智能手机的普及，电影已经成为了现代人娱乐生活不可或缺的一部分。而豆瓣电影作为一个非常有名的电影评价平台，拥有海量的用户评价数据和电影信息，能够为电影爱好者提供重要的参考和决策支持。因此，对豆瓣电影数据进行分析和可视化研究具有很高的研究价值和现实意义。
本研究旨在通过对豆瓣电影数据的分析和可视化研究，深入了解电影市场的变化趋势、受欢迎程度、用户评价等方面，为电影从业人员、电影爱好者以及电影研究者提供有益的参考和建议。
研究总体设计 本课题Python的豆瓣电影的数据分析以及可视化研究，通过利用Python设计爬虫程序，其中包括自动化爬虫程序，编写智能延时功能，保证有效的获取豆瓣电影的大量的数据。
将豆瓣电影数据页面中的自动获取之后，采用Python的pandas和numpy库对数据进行清洗和预处理，其中包括多维度数据字段清洗和扩充，并将清洗好的数据存入到MySQL数据库中，采用数据分析思维，调用数据库中的结构化数据，对不同维度的数据进行分析，例如电影评分指标分布，用户喜爱程度分析，影评文本分析，地域分析等等，然后利用pyecharts前端可视化库，进行展示，绘制多维度的可视化图表，并结合实际的分析结果进行论述，提供数据分析结论。
最后将同一个分析维度的可视化展示，通过pyecharts的Page模块，对可视化进行统一展示，构建基于豆瓣电影分析的大屏可视化。
具体步骤和规划如下：
1.设计豆瓣电影自动化爬虫程序，自动获取电影数据
其中需要设计一个自动化的爬虫程序，对于豆瓣网站，因为它的反爬措施比较严格，电影页面的数据是采用动态加载的原理进行展示的，初步分析需要采用JSON数据获取豆瓣电影的URL，然后通过请求到具体的电影页面在进行解析和定位具体的电影字段数据。
获取数据的时候，需要模拟浏览器对网站进行请求，需要加入请求头，然后分析不同JSON数据包中的参数，发现具体的规律之后可以设置对应的程序进行获取数据集。如果IP频繁的访问网站不仅会给目标网站带来负载压力，还会被网站识别为恶意爬虫，所以设计爬虫程序的时候需要加入延时函数，采用正态分布的思想模拟人的速度点击和访问网站的频率，可以增强爬虫的稳定性。
其次由于有时候获取数据的时候，会有有一些字段在某些电影中不存在，所以为了保障程序的稳定健壮的持续运行，需要设置智能化爬虫。初步的分析需要对字段的数据值进行一个判断，如果没有获取到数据，那么就自动赋值为空值，这样就可以避免程序中断。
2.对爬取到的数据进行清洗和预处理，包括多维度数据字段清洗和扩充
由于我们获取的大量的数据中，存在一些不规则的字段，比如演员、上映时间、电影时长等这些字段中包含其他的中文字符，我们需要对其进行结构化清洗，保证数据的有效性，便于后续的分析，其次数据中存在一些空值，需要进行处理，然后将其保存为一个新的数据。
其次，在处理时间字段的时候，将中文字段去除之后，然后对数据字段进行扩充，比如年、月、日、周数等，可以方便后续的数据分析，增加分析的维度，保障数据的有效进行。
3.将清洗好的数据存储到MySQL数据库中
将预处理好的数据存入在MySQL中，便于后续的管理和调用数据，MySQL作为一个结构化的数据库，可以存储大量的数据，并且可以帮助我们采用SQL语句进行查询和数据分析，具有非常高效的特点。
4.豆瓣电影数据字段多维度数据分析
采用数据分析思维，调用数据库中的结构化数据，从多个维度对豆瓣电影数据进行深入分析，比如电影评分分析，地域分析，时间维度分析，电影类型分析等。
5.利用pyecharts可视化库，绘制各种多维度的图表
利用Python的pyecharts这个第三方可视化库，调用数据库中的数据，采用前端可视化分析的方法，将可视化展示在网页中，实现炫酷的交互式的图形展示，便于我们进行发现规律，给用户或者其他人员提供决策性的支持依据。
6.对分析结果进行论述，提供数据分析结论
对分析数据进行分析，提出相关性的结论，以及出现的规律性的结论，为豆瓣电影的行业提供一些描述性的分析结论，凸出数据分析在这个中主要地位。
7.大屏可视化
将同一个分析维度的可视化展示，通过pyecharts的Page模块，对可视化进行统一展示，构建基于豆瓣电影分析的大屏可视化。
总之，本研究采用Python的网络爬虫技术和大数据分析技术，通过合理的数据获取、数据清洗和预处理、数据存储和数据分析等多个环节，最终实现了对豆瓣电影从数据的获取到数据清洗，数据加载到hive仓库中，对其进行大数据分析以及可视化展示。
网络爬虫介绍 网络爬虫是一种自动化工具，可以在互联网上自动搜索和抓取信息。它可以自动化地浏览网页、提取数据并将其保存到本地计算机上，以便后续的数据分析、挖掘和处理。在当今信息爆炸的时代，网络爬虫已经成为了人们获取和处理信息的重要手段之一。
网络爬虫的原理是通过HTTP或HTTPS协议向网站发送请求，并获取网站返回的HTML源代码。然后，通过解析HTML源代码，网络爬虫可以提取出网页中的各种信息，包括文本、图片、链接、音频、视频等等。网络爬虫可以根据自己的需求和设定的规则自动爬取整个网站或特定的网页，从而实现自动化的数据获取。
网络爬虫有着广泛的应用场景。例如，搜索引擎需要通过网络爬虫自动抓取互联网上的各种网页并建立索引，以便用户能够更方便地搜索到所需的信息；电商网站需要通过网络爬虫自动获取竞争对手的产品信息和价格信息，以便做出更合理的价格策略；新闻媒体需要通过网络爬虫自动抓取新闻信息并进行整理和分类，以便更好地提供新闻服务等等。
此处省略…
豆瓣电影数据的采集 对进行网页结构分析后，能够通过爬取每一部电影的数据获取到以下详细信息，该信息如下图所示。需要注意的是，由于豆瓣电影的数据是动态的，因此需要不断地进行点击操作才能获取完整的信息。经过解析发现，在传输数据时，网站会包含一个JSON数据包，其中包含了数据字段，即页面信息。
下一步是使用Python编写网络爬虫程序，并实现反爬措施，包括请求头和参数设置。程序会清洗JSON数据，获取我们需要的网址，并遍历该数据下的字。在程序设计过程中，有如下创新点：
智能化爬取模块：为了避免过于频繁的访问，程序会进行自动化延时，模拟人类点击网站行为。如果某个数据字段为空，程序会自动赋值为空并提示出现空值。实时写入数据：程序会实时将数据源写入到CSV文件中，以避免在某一时刻程序无法正常进行爬虫，导致之前的数据无法写入。可借鉴的程序结构：该程序的结构化清晰，逻辑思维较强，具有很强的可借鉴性。智能化反爬措施：程序加入了智能化反爬措施，结合网站的反爬措施，保证程序不会被封禁IP。 数据预处理 基于爬虫获取的数据基本符合大数据分析的条件，但对于某些字段需要进一步处理。例如，电影名称中的逗号需要去除，因为在后续的导入到hive仓库时，我们使用csv格式进行分割。若在数据预处理时未进行处理，导致导入数据出现错位，影响了分析结果。另外，需要对某些字段进行值的扩展和约束。例如，电影时长中包含中文，演员信息中存在大量的人员，因此可以通过以下几个方法进行数据
预处理和结构化处理：
首先，针对movie_name字段，需去除其中包含的逗号字符，避免后续的数据加载出现错位的情况。
其次，针对yanyuanData字段，其虽然疑似列表，但本质上不是列表，因此需要使用Replace方法，将其中的括号去除。然后，利用Python的Split函数按照特定序列进行分割。由于该字段为演员信息，因此可采用统计演员个数的方法，代替原来的字段值，以方便后续的探索分析。接着，将演员信息存储为文本文件，便于进行文本分析可视化，并使用词云展示其中的姓名。
大数据分析及可视化 豆瓣影评结构化分析 使用SQL语句对豆瓣电影数据进行查询并通过Pyecharts进行可视化展示后，发现8-9分的评分数量最多，呈正态分布。相反地，低分电影数量较少，而高于9分的电影数量也相对较少，但仍有一定数量的高分电影存在。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6584d8ce727e1bcc854094ed0491ce25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4163d44ccd6263c6ae66dae8682b51b/" rel="bookmark">
			注意力机制SE、CBAM、ECA、CA的优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言🎈SE（Squeeze-and-Excitation）CBAM（Convolutional Block Attention Module）ECA（Efficient Channel Attention）CA（Channel Attention） 总结👍 前言🎈 注意力机制是一种机器学习技术，通常用于处理序列数据（如文本或音频）或图像数据中的信息筛选和集成。注意力机制模块可以帮助神经网络更好地处理序列数据和图像数据，从而提高模型的性能和精度。 SE（Squeeze-and-Excitation） 优点：
可以通过学习自适应的通道权重，使得模型更加关注有用的通道信息。
缺点：
SE注意力机制只考虑了通道维度上的注意力，无法捕捉空间维度上的注意力，适用于通道数较多的场景，但对于通道数较少的情况可能不如其他注意力机制。
CBAM（Convolutional Block Attention Module） 优点：
结合了卷积和注意力机制，可以从空间和通道两个方面上对图像进行关注。
缺点：
需要更多的计算资源，计算复杂度更高。
ECA（Efficient Channel Attention） 优点：
高效的通道注意力机制，只增加了少量的参数，却能获得明显的性能增益。
缺点：
在处理全局上下文依赖性和通道空间关系方面存在一定的限制。
CA（Channel Attention） 优点：
可以同时考虑通道维度和空间维度上的注意力，并且可以通过学习自适应的通道权重，使得模型更加关注有用的通道信息。
缺点：
需要额外的计算，计算开销较大。另外，由于需要对整个特征图进行注意力权重的计算，因此无法捕捉长距离的依赖关系。
总结👍 🏆SE注意力机制适用于通道数较多的场景，CA注意力机制则适用于需要考虑空间维度上的注意力的场景。但在计算开销和捕捉长距离依赖关系等方面存在一些限制。CBAM适用于需要对特征图的空间和通道维度进行有效整合的场景，可以提高模型的泛化能力和性能。具体选择哪种注意力机制，需要根据具体的应用场景来进行综合考虑。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58918f0d0703d8552ace92e9010256e8/" rel="bookmark">
			数据结构与算法基础-学习-24-图的遍历之DFS（深度优先搜索）和BFS（广度优先搜索）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、遍历定义
二、遍历实质
三、DFS
四、BFS
五、宏定义
六、自定义类型
七、函数实现
1、DFS（邻接矩阵实现）
2、DFS（邻接表实现）
3、BFS（邻接矩阵实现）
4、BFS（邻接表实现）
5、打印邻接矩阵遍历顺序
6、打印邻接表遍历顺序
八、遍历算法效率分析
1、DFS
2、BFS
九、Linux编译测试
一、遍历定义 从已给的连通图中某一顶点出发，沿着一些边访问遍图中所有顶点，且使每个顶点仅被访问一次，就叫做的图的遍历，它是图的基本运算。
二、遍历实质 找每个顶点的邻接点的过程。
三、DFS 深度优先搜索，英文全称Depth First Search。如下图进行举例说明。
这里以邻接矩阵表示无向图进行举例，生成内容如下：
[2023-5]--[ Debug ]--Printf AMGraph : VertexArray : [A ,B ,C ,D ,E ] ArcArray : [32767 ,20 ,30 ,10 ,32767 ] [20 ,32767 ,32767 ,32767 ,50 ] [30 ,32767 ,32767 ,40 ,32767 ] [10 ,32767 ,40 ,32767 ,60 ] [32767 ,50 ,32767 ,60 ,32767 ] CurVertexNum : 5 CurArcNum : 12 我们还需要维护一个Visit数组，用于确认访问过的节点有哪些，0表示没有访问过，1表示访问过。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58918f0d0703d8552ace92e9010256e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53de60d524e02b64d4c1c50443f4bbe8/" rel="bookmark">
			完整且详细的Yolov8复现&#43;训练自己的数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Yolov8 的源代码下载：ultralytics/ultralytics: NEW - YOLOv8 🚀 in PyTorch &gt; ONNX &gt; CoreML &gt; TFLite (github.com)https://github.com/ultralytics/ultralytics
Yolov8的权重下载：Releases · ultralytics/assets · GitHubUltralytics assets. Contribute to ultralytics/assets development by creating an account on GitHub.https://github.com/ultralytics/assets/releases
yolov8做了更简单的部署，可以用于检测，分类，分割等，速度更快，精度更高。具体yolov8的复现可以参考：
一、代码，权重的下载 1. 打开上面的源代码地址，下载源代码压缩包。
2.下载后解压。
3.权重的下载 ：建议点击上面的链接直接下载，后面的predict.py虽然设置了自动下载，但是往往因为网络或者环境配置的问题cut掉。因为作者复现的是检测任务，权重放在detect文件下。
二、配置环境 1.建议每次做新项目都重建一个新环境，避免了各种包的版本的冲突，同时也为了避免在新项目跑通后旧项目又要重新配置环境的麻烦，所以重建环境是不错的选择。
1.打开Anaconda Prompt（如果没有Anaconda，建议下载一个，在配置环境的方面还是很方便的，具体的下载方式参考：(54条消息) 史上最全最详细的Anaconda安装教程_OSurer的博客-CSDN博客https://blog.csdn.net/wq_ocean_/article/details/103889237?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168653306416782427441050%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168653306416782427441050&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-103889237-null-null.142%5Ev88%5Econtrol,239%5Ev2%5Einsert_chatgpt&amp;utm_term=anaconda%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B&amp;spm=1018.2226.3001.4187）
2.具体操作：
(1) 创建环境
conda create -n yolov8 python==3.7 (官方要求&gt;=3.7,所以python3.8也完全可以)
（2）激活环境
conda activate yolov8 (3)下载Pytorch，这个步骤也十分重要！根据自己电脑配置下载。官方要求Pytorch&gt;=1.7。
首先查看自己的显卡配置：win+R ，输入nvidia-smi
去官网下载对应或者不大于箭头指出的版本，官网地址：PyTorchhttps://pytorch.org/
pip下载会比conda下载略快。
（4）配置好环境后，使用pycharm打开源代码工程文件
（5）选择下载的yolov8环境。
选择python.exe文件。 （6）配置yolov8要求的包，点击Temina，输入代码：
pip install -r requirements.txt -i https://pypi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53de60d524e02b64d4c1c50443f4bbe8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c363bf947bf2c25ec4ae7fac5e631d5a/" rel="bookmark">
			基于Java&#43;SpringBoot&#43;Vue前后端分离校园闲置物品交易网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌全网粉丝20W+,csdn特邀作者、博客专家、CSDN新星计划导师、java领域优质创作者,博客之星、掘金/华为云/阿里云/InfoQ等平台优质作者、专注于Java技术领域和毕业项目实战✌
🍅文末获取源码联系🍅
👇🏻 精彩专栏推荐订阅👇🏻 不然下次找不到哟
2022-2024年最全的计算机软件毕业设计选题大全：1000个热门选题推荐✅
java项目精品实战案例《100套》
Java微信小程序项目实战《100套》
​
目录
一、摘要介绍：
二、研究内容： 三、系统设计：
3.1 系统研究方案
3.2 功能结构设计：​
3.3 登录时序图设计：
四、系统功能实现截图： 4.1 登录注册功能：
4.2 前台首页模块：
4.3 前台闲置物品：
4.4 闲置物品详情：
4.5 购物车模块：
4.6 订单信息模块
4.7 前台留言反馈：
4.8 前台公告信息：
4.9 前台客服中心：
4.10 前台个人中心：
4.11 后台闲置物品管理：
4.12 后台订单信息管理：
4.13 后台用户信息管理：
4.14 后台公告信息管理：
五、库表设计 ​
六、项目总结：
七、源码获取：
一、摘要介绍： 在Internet高速发展的今天，计算机的应用几乎完全覆盖我们生活的各个领域，互联网在经济，生活等方面有着举足轻重的地位，成为人们资源共享，信息快速传递的重要渠道。在中国，网上管理的兴起也同时飞速发展着。为了适应现代人类强烈的时间观念，对于校园闲置物品交易网站传统管理方式的缺点，互联网的出现打破了这种局限性，给了广大用户更大的选择空间，促进了校园闲置物品交易网站管理系统，有效的避免了校园闲置物品交易网站管理缭乱的局面，方便用户。本系统中，管理员以最方便的形式，在最短的时间内查找最多的二手书交易信息。因此，系统无疑给人们的生活带来了极大的方便，网络的应用让时间和距离不再是局限。
通过校园闲置物品交易网站管理系统的研究可以更好地理解系统开发的意义，而且也有利于发展更多的智能系统，解决了人才的供给和需求的平衡问题，校园闲置物品交易网站管理系统的开发建设，由于其开发周期短，维护方便，所以它可以适应校园闲置物品交易网站体系基本要求。
二、研究设计内容： 基于springboot框架，MySQL数据库进行开发，实现了首页、个人中心、用户管理、卖家用户管理、闲置分类管理、闲置物品管理、求购闲置管理、求购回复管理、留言反馈、系统管理、订单管理等内容进行管理。
校园闲置物品交易选用B/S架构模式，即网页页面和网站架构设计的开发方式。这类系统构造可以理解为对 C/S 系统构造的改变与推广能够进行信息分布式处理，减少资源成本，提升订制系统的性能。在这种设计下，极少有事务处理在前进行，绝大多数重要事务管理的思路需要在服务端完成、如图所示。
图4-1 B/S模式三层结构图
三、系统设计： 3.1 系统研究方案 软件系统结构计划方案：因为系统务必在不同设备上运行，计算机服务器配置要求越小越好。要实现这一要求，B/S结构已经成为最好的选择。运用B/S结构的系统基本可以在大多数计算机中运行。只需计算机电脑浏览器可以正常运行，系统就能正常的运行，维护费用和二次修改比较容易符合要求。操作过程系统方案:Windows10操作过程系统是微软发布最新发布的系统。目前市面上绝大部分计算机都使用这种系统，功能齐全，兼容模式好。开发工具:挑选IDEA。Java语言研发设计。
3.2 功能结构设计：​ ​ 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c363bf947bf2c25ec4ae7fac5e631d5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/130c81686626a93ced4faaa1d6b5cd2e/" rel="bookmark">
			多个消费者订阅一个Kafka的Topic(使用@KafkaListener和KafkaTemplate)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录：465
场景：一个Producer在一个Topic发布消息，多个消费者Consumer订阅Kafka的Topic。每个Consumer指定一个特定的ConsumerGroup，达到一条消息被多个不同的ConsumerGroup消费。
版本：JDK 1.8,Spring Boot 2.6.3,kafka_2.12-2.8.0,spring-kafka-2.8.2。
Kafka集群安装：https://blog.csdn.net/zhangbeizhen18/article/details/131156084
1.基础概念
Topic：Kafka根据Topic对消息进行归类，发布到Kafka的每条消息都需要指定一个Topic。
Producer：消息生产者，向Broker发送消息的客户端。
Consumer：消息消费者，从Broker读取消息的客户端。
ConsumerGroup：每个Consumer属于一个特定的ConsumerGroup，一条消息可以被多个不同的ConsumerGroup消费；但是一个ConsumerGroup中只能有一个Consumer能够消费该消息。
publish：发布，使用Producer向Kafka写入数据。
subscribe：订阅，使用Consumer从Kafka读取数据。
2.微服务中配置Kafka信息
(1)在pom.xml添加依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt; &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/dependency&gt; 请知悉：spring-kafka框架底层使用了原生的kafka-clients。本例对应版本：3.0.0。
(2)在application.yml中配置Kafka信息
配置参考官网的configuration：https://kafka.apache.org/documentation/
(1)application.yml配置内容
spring: kafka: #kafka集群的IP和端口,格式:(ip:port) bootstrap-servers: - 192.168.19.161:29092 - 192.168.19.162:29092 - 192.168.19.163:29092 #生产者 producer: #客户端发送服务端失败的重试次数 retries: 2 #多个记录被发送到同一个分区时,生产者将尝试将记录一起批处理成更少的请求. #此设置有助于提高客户端和服务器的性能,配置控制默认批量大小(以字节为单位) batch-size: 16384 #生产者可用于缓冲等待发送到服务器的记录的总内存字节数(以字节为单位) buffer-memory: 33554432 #指定key使用的序列化类 key-serializer: org.apache.kafka.common.serialization.StringSerializer #指定value使用的序列化类 value-serializer: org.apache.kafka.common.serialization.StringSerializer #生产者producer要求leader节点在考虑完成请求之前收到的确认数,用于控制发送记录在服务端的持久化 #acks=0,设置为0,则生产者producer将不会等待来自服务器的任何确认.该记录将立即添加到套接字(socket)缓冲区并视为已发送.在这种情况下,无法保证服务器已收到记录,并且重试配置(retries)将不会生效(因为客户端通常不会知道任何故障),每条记录返回的偏移量始终设置为-1. #acks=1,设置为1,leader节点会把记录写入本地日志,不需要等待所有follower节点完全确认就会立即应答producer.在这种情况下,在follower节点复制前,leader节点确认记录后立即失败的话,记录将会丢失. #acks=all,acks=-1,leader节点将等待所有同步复制副本完成再确认记录,这保证了只要至少有一个同步复制副本存活,记录就不会丢失. acks: -1 consumer: #开启consumer的偏移量(offset)自动提交到Kafka enable-auto-commit: true #consumer的偏移量(offset)自动提交的时间间隔,单位毫秒 auto-commit-interval: 1000 #在Kafka中没有初始化偏移量或者当前偏移量不存在情况 #earliest,在偏移量无效的情况下,自动重置为最早的偏移量 #latest,在偏移量无效的情况下,自动重置为最新的偏移量 #none,在偏移量无效的情况下,抛出异常.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/130c81686626a93ced4faaa1d6b5cd2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20ae6f041abc33be1f56a04f4e32f5f5/" rel="bookmark">
			java.lang.IllegalStateException: Failed to load ApplicationContext报错怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期在进行项目开发时，我遇到了一个报错：java.lang.IllegalStateException: Failed to load ApplicationContext 。这个报错的原因可能有很多种，但是通过排查，我成功解决了它。在这里分享一下，希望能对遇到同样报错的开发者有所帮助。
首先，我们先来了解一下这个报错的大致意思。 在Spring框架中，当加载ApplicationContext时，可能会抛出当前这个异常。它的意思是要么配置文件有误，要么依赖注入失败。如果有很多Bean没有加载成功，那么当前上下文就被认为是无效的，就会抛出Failed to load ApplicationContext的异常。
对于以上这个问题，我们可以通过以下方法来解决：
1.查看debug信息
在使用Spring框架时，推荐大家使用debug模式，这样可以方便我们查看每个Bean的加载情况，以及可能的错误信息。同时，我们也可以在控制台上看到相关的debug信息，可以通过这些信息来快速定位错误。
2.检查配置文件
如果您在使用Spring Boot时遇到了这个问题，则可以检查application.yml或application.properties文件是否存在误删/误配置问题。检查配置文件是否存在格式问题，如语法错误、符号未结束等。还请确保各个组件之间的版本兼容性。
3.排查依赖注入
若以上两种方法都无效那么就需要进一步排查依赖注入。现在大多数的开发者都喜欢使用注解来处理依赖问题，因此大家可以检查注解是否处理正确、使用了正确的注解。
下面就是一些可能的原因：
表示当前类的注解没有使用@Component/@Service/@Repository/@Controller/@Configuration这几个注解。自定义了注解和注解Handler用于注入Bean但未被正确加载。Bean的名字在重复或未指定。扫描包时出现错误。 4.查看日志文件
如果你无法在控制台或IDE中查找错误原因，那么请使用日志工具记录错误信息。查看日志文件是排查错误的最好方法之一。在logging配置文件中，Level为DEBUG或TRACE可以更好地记录日志。
附上相应的程序代码，方便读者更好地理解。
1.首先，我们在控制台中看到了相关的异常信息：
2.我们可以使用日志工具记录日志信息。在此，我们使用logback进行日志记录及输出 Windows Event Viewer：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;configuration&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder&gt; &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt; &lt;file&gt;application.log&lt;/file&gt; &lt;append&gt;true&lt;/append&gt; &lt;encoder&gt; &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;logger name="com.example.demo" level="DEBUG" /&gt; &lt;logger name="org.springframework" level="INFO"/&gt; &lt;logger name="org.springframework.core" level="INFO" /&gt; &lt;logger name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20ae6f041abc33be1f56a04f4e32f5f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bda357bc8db3d3a250f48c41700b7a0/" rel="bookmark">
			oracle ORA-01704: string literal too long字符串文字太长报错解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此类问题基本是在需要处理大文本内容时出现，例如将大文本插入到某个字段内，或者导入存在clob类型字段的内容且文本内容超过4000字符长度时，执行则弹出ORA-01704: string literal too long的报错信息，可以尝试以下方案。
报错图示：
一、当使用 insert into 语句插入大文本数据
1.变量赋值法;
declare V_clobdata CLOB := '大文本内容'; BEGIN INSERT INTO test123 (id, marks) values (1, V_clobdata); END; 2.通过 up date 语句手工填入大文本数据内容，适用于少量数据需要修改的情况
select * from test_table for update; 二、数据迁移时，通过文件形式导入数据库（例如.csv 或 .sql等文件）
这类文件在plsql中导入时，实质上也是通过执行insert into语句插入，所以也同样会导致报错。
此时推荐选用导出dmp文件，dmp使用二进制存储，避免了上述的报错问题。
dmp文件导出步骤
1.菜单栏点击tools
2.下滑选择如图所示
3.进入页面 ①选择具体用户 ②选着导出的表（可以单个，多个或全选） ③ 选择导出文件存放路径及文件名 ④点击导出即可
如导出失败可以参考此文解决：​​​​​​​​​​​​​​https://blog.csdn.net/fzy999999/article/details/131208529
dmp文件导入步骤
1.导入表格
选择需要导入的文件
完成数据的导入，无报错。
欢迎一起交流学习更多方法。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/599/">«</a>
	<span class="pagination__item pagination__item--current">600/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/601/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>