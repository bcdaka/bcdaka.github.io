<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50f66de772f713ea5346af21eced13f9/" rel="bookmark">
			Navicat Premium 16最新版激活 mac/win
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Navicat Premium 16 for Mac是一款专业的多连接数据库管理工具。它支持连接多种类型的数据库，包括MySQL、MongoDB、Oracle、SQLite、SQL Server、PostgreSQL等，可以同时连接多种数据库，帮助用户轻松地管理和迁移数据。
Navicat Premium 16 for Mac v16.3.7中文激活版下载
win版Navicat Premium 16中文版下载
Navicat Premium 16 for Mac具有高效的数据管理和操作功能，它支持多种数据导入和导出格式，如CSV、Excel、Access等，可以方便地将数据导入导出，实现高效的数据管理和操作。
除此之外，Navicat Premium 16 for Mac还具有远程管理和维护数据库的功能，可以通过网络连接到远程数据库，进行管理维护等操作。同时，它提供了方便易用的图形用户界面和强大的功能，让用户可以更加方便快捷地管理数据库。
总的来说，Navicat Premium 16 for Mac是一款功能强大的数据库管理软件，适用于开发人员、数据库管理员和分析师等多种用户，可以帮助用户轻松地管理和维护数据库，提高工作效率。
本文由 mdnice 多平台发布
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19803989d8a4c6d5911e1d88e61da4dd/" rel="bookmark">
			我放弃了双系统，只为在VMWare上完美运行macOS 14！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前几天，我分享了如何在Windows上系统上安装虚拟机，以及VMware虚拟机装Windows10，那么，今天我出个保姆级教程，手把手教大家怎样下虚拟机里安装macOS 14 系统，如果有帮助，一键三连！
安装python环境 python.org
下载
安装
安装 VMWare 此步骤相对简单，我安装的是VMware Workstation Pro 发布了最新版 v17.5.1，如果你没有这个安装包与激活密钥，可以插件这个视频，介绍里有安装吧
难道还有人不会这Windows上装虚拟机，一个视频教会你！_哔哩哔哩_bilibili
下载VMWare Unlocker https://github.com/paolo-projects/unlocker 下载后解压出来，管理员身份运行 win-install
下载macOS 14 镜像文件 https://www.mediafire.com/file/lzlounvkwazy948/macOS+Sonoma+ISO.iso/file# 创建虚拟机 下面位置可以自定义，C盘空间不大就放其他盘
这步很重要，点击自定义硬件，CD/DVD (SATA)-用 ISO 映像文件(M)，然后选择你下载的镜像文件
看到如下界面，先关掉虚拟机
打开你的文档-Virtual Machines\macOS 14，找到macOS 14.vmx这个文件，使用记事本打开，末尾添加如下代码，然后保存。
smc.version = "0" 启动虚拟机
点击最上方
点击磨掉
然后点击完成，关闭掉，回到主页
选择第2个选项
创建账号与密码
安装 VMware Tools 由于安装的默认分辨率非常低，可以通过安装 VMware Tools解决。
1，先把虚拟机关机，点击设置
2，然后开机，选择macOs 14，右键选择VMware Tools 安装
安装完后重启虚拟机，在此打开，就会可以看到
攻略：VMware虚拟机装Windows10系统 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dea1df8dd462c08960d7dcbe10ce8ab/" rel="bookmark">
			【C&#43;&#43;类和对象】日期类的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💞💞 前言 hello hello~ ，这里是大耳朵土土垚~💖💖 ，欢迎大家点赞🥳🥳关注💥💥收藏🌹🌹🌹
💥个人主页：大耳朵土土垚的博客
💥 所属专栏：C++入门至进阶
这里将会不定期更新有关C++的内容，希望大家多多点赞关注收藏💖💖
目录 💞💞 前言1.日期类Date的构造2.日期类Date的实现2.1获取某年某月的天数2.2默认成员函数的实现2.2.1全缺省的构造函数2.2.2拷贝构造函数2.2.3赋值运算符重载2.2.4析构函数 2.3日期计算类函数2.3.1日期+=天数2.3.2日期+天数2.3.3日期-=天数2.3.4日期-天数2.3.5日期-日期 返回天数 2.4运算符重载类函数2.4.1 &gt;运算符重载2.4.2 ==运算符重载2.4.3 &gt;=运算符重载2.4.4 &lt;运算符重载2.4.5 &lt;=运算符重载2.4.6 !=运算符重载2.4.7 前置++与后置++2.4.8 前置--与后置-- 3.完整代码+运行结果4.结语 通过下面的学习我们将构建简单日期计算器的各种功能实现： 1.日期类Date的构造 这里的函数大多在日期类中声明，定义在类外部实现
#include&lt;iostream&gt; using namespace std; class Date { public: // 获取某年某月的天数 inline int GetMonthDay(int year, int month) { int montharray[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 }; //如果是二月就需要判断是不是闰年 if (month == 2 &amp;&amp;(((year % 4 == 0) &amp;&amp; (year % 100 != 0)) || (year % 400 == 0))) { return 29; } return montharray[month];//月份天数数组设置为13，方便直接按月份返回 } // 全缺省的构造函数 Date(int year = 1900, int month = 1, int day = 1); // 拷贝构造函数 // d2(d1) Date(const Date&amp; d); // 赋值运算符重载 // d2 = d3 -&gt; d2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dea1df8dd462c08960d7dcbe10ce8ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5b8d676734555c6d0f8ba7799ea7007/" rel="bookmark">
			大数据课堂笔记——lianxi数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建数据库
create database 库名；
create database lianxi;
打开
use 库名；
use lianxi;
use table 表名；
创建表（主键：primary key ）
create table 表名 (列名1 数据类型1，……);
create table course
(couid char(4),
couname char(10),
teachername char(3)
);
删除表
drop database 数据表名;
显示命令运行结果
show tables;
add 列名 类型 [];
修改表
alter database 数据库名 character set 字符集名;
数据类型：
int
tinyint
smallint
mediumint
bigint
float(m,d)
char
varchar
date
time
datetime
blob
约束表达式：
primary key 主键
auto_increment 从1开始自增
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5b8d676734555c6d0f8ba7799ea7007/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b784e7f2f264a00e1a4490860cf51c4a/" rel="bookmark">
			【Javascript】encodeURI、encodeURIComponent、decodeURI、decodeURIComponent
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、encodeURI()介绍语法描述示例 二、encodeURIComponent()介绍语法描述encodeURIComponent() 和 encodeURI 不同点 三、decodeURI()四、decodeURIComponent() 一、encodeURI() 介绍 encodeURI() 函数通过将特定字符的每个实例替换为一个、两个、三或四转义序列来对统一资源标识符 (URI) 进行编码
使用场景：当你需要对整个URL进行编码时方便使用，因为它不会编码URL组成部分中需要存在的特殊字符
语法 encodeURI(URI) 参数：
URI： 一个完整的 URI
返回值：
一个新字符串，表示提供的字符串编码为统一资源标识符 (URI)
描述 假定一个 URI 是完整的 URI，那么无需对那些保留的并且在 URI 中有特殊意思的字符进行编码。
encodeURI 会替换所有的字符，但不包括以下字符，即使它们具有适当的 UTF-8 转义序列：
类型包含保留字符; , / ? : @ &amp; = + $非转义的字符字母 数字 - _ . ! ~ * ' ( )数字符号# 示例 var uri = 'https://www.example.com/测试?query=测试&amp;another=值'; var encodedUri = encodeURI(uri); console.log(encodedUri); // https://www.example.com/%E6%B5%8B%E8%AF%95?query=%E6%B5%8B%E8%AF%95&amp;another=%E5%80%BC 二、encodeURIComponent() 介绍 encodeURIComponent() 函数通过将特定字符的每个实例替换成代表字符的 UTF-8 编码的一个、两个、三个或四个转义序列来编码 URI
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b784e7f2f264a00e1a4490860cf51c4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/848aa49cdfcc6400db2fb21b44de7245/" rel="bookmark">
			【Python数分实战】预测肥胖风险数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📣 前言 👓 可视化主要使用 plotly🔎 数据处理主要使用 pandas🕷️ 数据爬取主要使用 requests👉 本文是我自己在和鲸社区的原创 今天这篇文章将给大家介绍【关于肥胖风险数据集】案例。
Step 1. 导入模块 import pandas as pd import plotly.graph_objects as go from sklearn.model_selection import train_test_split from sklearn.preprocessing import LabelEncoder from sklearn.ensemble import RandomForestClassifier from sklearn.metrics import classification_report, accuracy_score import numpy as np Step 2. 数据概览 数据下载：关注公众号，回复关键字【肥胖风险数据集】免费获取。
file_path = '/home/mw/input/shein9661/shein_mens_fashion.csv' df = pd.read_csv(file_path) df.head() 输出结果：
missing_values = data.isnull().sum() duplicate_rows = data.duplicated().sum() missing_values, duplicate_rows 输出结果:
(id 0 Gender 0 Age 0 Height 0 Weight 0 family_history_with_overweight 0 FAVC 0 FCVC 0 NCP 0 CAEC 0 SMOKE 0 CH2O 0 SCC 0 FAF 0 TUE 0 CALC 0 MTRANS 0 0be1dad 0 dtype: int64, 0) Step 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/848aa49cdfcc6400db2fb21b44de7245/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ea3b0526fe48a5dc3b44fb0dab462c4/" rel="bookmark">
			SpringBoot 集成 WebSocket
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近在做一个 WebSocket 通信服务的软件，所以必须跟着学一学。
1、WebSocket 概述 一般情况下，我们的服务器和服务器之间可以发送请求，但是服务器是不能向浏览器去发送请求的。因为设计之初并没有想到以后会出现服务端频繁向客户端发送请求的情况。
全双工的通信协议（WebSocket 最大的特点是浏览器也可以往服务器发请求，服务器也可以向浏览器发请求）。
1.1、浏览器和服务器使用WebSocket通信流程 1. 浏览器发起http请求，请求建立 WebSocket 连接 这里的协议升级就是说，我想通过这个 http 连接去升级为 WebSocket 连接
2. 服务器响应统一协议更改 3. 相互发送数据 升级了协议之后浏览器就可以和服务器相互通信了： 1.2、总结 WebSocket 协议是建立在 tcp 协议基础上的，所以不同语言也都支持 tcp 协议是全双工协议，http 协议基于它是单向的WebSocket 没有同源限制，所以前后端端口不一致也不影响信息的发送 2、Java 实现 WebSocket 的两种方式 2.1、基于注解实现WebSocket服务器端 服务终端类：
@ServerEndpoint：监听连接（需要传递一个地址参数）@OnOpen：连接成功@OnClose：连接关闭@OnMessage：收到消息 配置类
把 Spring 中的 ServerEndpointExporter 对象注入进来 2.2.1、编写服务终端类 // 监听哪些客户端来连接了WebSocket服务端 // 监听websocket地址 /myWs @ServerEndpoint("/myWs") @Component @Slf4j public class WebServerEndpoint { // 因为可能有多个客户端所以这里需要保证线程安全 static Map&lt;String,Session&gt; sessionMap = new ConcurrentHashMap&lt;&gt;(); // 建立连接时执行的操作 @OnOpen public void onOpen(Session session){ // 每个websocket连接对于服务端来说都是一个Session sessionMap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ea3b0526fe48a5dc3b44fb0dab462c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/924936930254a36a45db9cd3ac9c074e/" rel="bookmark">
			手把手教你Windows下搭建Filebeat&#43;Logstash&#43;ElasticSearch&#43;Kibana系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、安装包准备
1、下载Filebeat
2、下载Logstash
3、下载ElasticSearch
4、下载Kibana
二、Filebeat安装
1、解压
2、配置filebeat.yml文件
3、运行filebeat
4、查看输出
5、设置Filebeat作为Windows服务运行（可选）
三、Logstash安装
1、解压 2、配置logstash.conf文件
3、运行Logstash
四、Elasticsearch安装
1、解压
2、配置elasticsearch.yml文件
3、运行elasticsearch
4、验证Elasticsearch是否运行
5、Elasticsearch安装分词插件
五、Kibana安装
1、解压
2、配置kibana.yml文件
3、运行Kibana
4、访问Kibana
六、启动应用服务
1、启动服务
2、打开kibana
前言 因为我的项目的springboot的版本是2.6.13，根据官网对应的版本，如图所示，所以Filebeat、Logstash、ElasticSearch、Kibana选择的版本都是7.15.2，总的来说，原来搭建一个日志搜索平台这么简单~~
一、安装包准备 1、下载Filebeat 官方下载地址：https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-7.15.2-windows-x86_64.zip
2、下载Logstash 官方下载地址：
https://artifacts.elastic.co/downloads/logstash/logstash-7.15.2-windows-x86_64.zip
3、下载ElasticSearch 官方下载地址：
https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.15.2-windows-x86_64.zip
4、下载Kibana 官方下载地址：
https://artifacts.elastic.co/downloads/kibana/kibana-7.15.2-windows-x86_64.zip
这边我统一安装在D盘的tools目录西下，方便管理~~
二、Filebeat安装 1、解压 解压前面下载好的filebeat压缩包，修改一下解压后的文件名，路径：D:\tools\filebeat-7.15.2，如图所示：
​
2、配置filebeat.yml文件 打开路径下 D:\tools\filebeat-7.15.2的filebeat.yml文件，修改如下配置：
filebeat.inputs: - type: log enabled: true paths: - D:\IdeaProject\study\timed-task-management-system\logs\* fields: level: info filebeat.config.modules: path: ${path.config}/modules.d/*.yml reload.enabled: true output.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/924936930254a36a45db9cd3ac9c074e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28c829c6887112cc06ccd3c2dcf3bb8a/" rel="bookmark">
			Python学习之PySpark案例实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		""" 演示获取PySpark的执行环境入库对象: SparkContext 并通过SparkContext对象获取当前PySpark的版本 """ # 导包 from pyspark import SparkConf,SparkContext # 创建SparkConf类对象中 conf = SparkConf().setSparkHome("local[*]").setAppName("test_spqrk_app") #基FSparkConf类对象创LSparkContext对象 sc = SparkContext(conf = conf) #打印PySpark的运行版本 print(sc.version) #停止SparkContext对象的运行(停止PySpark程序) sc.stop() PySpark的编程模型 SparkContext类对象，是PySpark编程中一切功能的入口。PySpark的编程，主要分为如下三大步骤
通过SparkContext对象，完成数据输入
输入数据后得到RDD对象，对RDD对象进行选代计算
最终通过RDD对象的成员方法，完成数据输出工作
数据输入 只要数据输入到spark就一定是rdd
RDD对象 如图可见,PySpark支持多种数据的输入,在输入完成后,都会得到一个:RDD类的对象
RDD全称为:弹性分布式数据集(Resilient Distributed Datasets)PySpark针对数据的处理，都是以RDD对象作为载体，即:
数据存储在RDD内
各类数据的计算方法，也都是RDD的成员方法
RDD的数据计算方法，返回值依旧是RDD对象
Python数据容器转RDD对象 PySpark支持通过SparkContext对象的parallelize成员方法将
List
Tuple
Set
Dic
tstr
转换为PySpark的RDD对象
注意:
字符串会被拆分出1个个的字符，存入RDD对象
字典仅有key会被存入RDD对象
""" 演示通过PySpark代码加载数据，即数据输入 """ from pyspark import SparkContext,SparkConf #构建接口对象 conf = SparkConf().setSparkHome("local[*]").setAppName("test_rdd") sc = SparkContext(conf=conf) #构建接口对象 #构建实验数据 list_1 = [1,2,3,4,5] turple_1 = (1,2,3,4) str_1 = ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28c829c6887112cc06ccd3c2dcf3bb8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49276f5337e5686d98a876b1f41ab875/" rel="bookmark">
			基于Python的A*算法解决八数码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、问题描述
二、涉及算法
三、实现步骤
1.定义状态结点的类
2.定义曼哈顿距离计算函数
3.预留占位函数
4.生成子结点函数
5.定义输出路径函数
6.定义A*算法
7.读取数据作为原始状态
8.定义主函数查看结果
四、运行结果
五、完整代码
一、问题描述 八数码问题是人工智能领域一个经典的问题。也是我们所熟悉的最简单的3×3数字华容道游戏：在一个3×3的九宫格棋盘上，摆有8个正方形方块，每一个方块都标有1~8中的某一个数字。棋盘中留有一个空格，要求按照每次只能将与空格相邻的方块与空格交换的原则，将任意摆放的数码盘（初始状态）逐步摆成某种给定的数码盘的排列方式（目标状态）。
二、涉及算法 启发式搜索又称为有信息搜索，是利用问题拥有启发信息引导搜索，以达到减小搜索范围、降低问题复杂度的目的。在启发式搜索过程中，要对Open表进行排序，这就要有一种方法来计算待扩展结点有希望通向目标结点的不同程度，人们总是希望找到最有可能通向目标结点的待扩展结点优先扩展。一种最常用的方法是定义一个评价函数对各个结点进行计算，其目的就是用来估算出“有希望”的结点。用f来标记评价函数，用f(n)表示结点n的评价函数值，并用f来排列等待扩展的结点，然后选择具有最小f值的结点作为下一个要扩展的结点。
A*算法是一种有序搜索算法，其特点在于对评价函数的定义上。这个评估函数f使得在任意结点上其函数值f(n)能估算出结点S到结点n的最小代价路径的代价与从节点n到某一目标节点的最小代价路径的代价的总和，也就是说f(n)是约束通过结点n的一条最小代价路径的代价的估计。
算法具体内容见文献：
https://wenku.baidu.com/view/4a80a40fa2161479171128de?_wkts_=1713600420821
三、实现步骤 在运行前，需要提前准备好infile.txt文件，第一行规定N的大小，即棋盘的大小，第二行则放置起始状态棋盘中的数字排列，从上往下，从左往右一次排成一列，空格置为0。
1.定义状态结点的类 定义一个State类，主要用于表示搜索过程中的状态结点，包括结点的代价和状态信息，以及结点之间的关系。
属性：
gn：从起始结点到当前结点的实际代价。
hn：从当前结点到目标结点的估计代价（启发式函数）。
fn：综合代价，即gn+hn。
child：子结点列表，存储从当前结点可以到达的所有子结点。
par：父结点，指向生成当前结点的父结点。
state：当前结点的状态矩阵。
hash_value：当前结点状态矩阵的哈希值，用于在查找表中快速查找。
方法：
__lt__：小于运算符重载，用于结点比较。
__eq__：等于运算符重载，用于结点比较。
__ne__：不等于运算符重载，用于结点比较。
class State(object): def __init__(self, gn=0, hn=0, state=None, hash_value=None, par=None): self.gn = gn self.hn = hn self.fn = self.gn + self.hn self.child = [] self.par = par self.state = state self.hash_value = hash_value def __lt__(self, other): return self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49276f5337e5686d98a876b1f41ab875/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46b1d6bbfb3aa74a6a0b499106a18418/" rel="bookmark">
			在Java中使用XxlCrawler时防止被反爬的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、常见的反爬措施
1、User-Agent识别
2、Referer识别
3、频率限制
4、IP限制
二、XxlCrawer的应对之道
1、User-Agent应对
2、频率限制
3、IP限制
三、XxlCrawler执行解析
1、XxlCrawler对象
2、启动对象
3、信息爬取线程
总结
前言 众所周知，在抓取别人的信息，会面临一些常见的屏蔽原则。当然，我们不建议持续不间断的获取信息，也同样呼吁正确利用获取的数据，仅做学习之用。相信大家在使用爬虫技术的同时，一定会遇到以下的场景，比如目标地址会进行IP限制，即将爬取的客户端IP限制掉。这里的限制可能是临时的，比如1天甚至半天就解封，而有一些是永久封禁。则该IP无法再次获取信息。而正常情况下我们又还需要持续的获取信息，这种情况下应该怎么去获取我们想要的数据呢。
本文以Java开发语言为例，主要讲解在采用XxlCrawler组件进行网络信息获取时，几种常见的反爬策略的应对方式。博文首先介绍了了几种常见的防止爬取技术，然后以XxlCrawer为例，针对这几种策略，在XxlCrawler中是如何进行实现，并进行应对的。
温馨提示：反爬虫技术是网站保护安全和稳定的重要手段，但也给数据采集带来了一定的挑战。在应对反爬虫技术时，需要遵循原则，选择合适的应对方法，提高技术水平和应对能力。同时，也需要注意法律法规和道德规范，遵循网站的规则和协议，保护网站的知识产权和合法权益。
一、常见的反爬措施 通常，在数据提供方为了保证数据的唯一性。随着互联网和移动互联网的发展，无论是信息爬取还是防止信息爬取，各方面的技术都在随着时间的推移而进步。本小节将介绍几种常见的反爬措施。关于反爬措施，更多的知识和策略可以到专业网站上学习。这里仅列出几种常见的。
1、User-Agent识别 User-Agent是HTTP请求头中的一个字段，用于标识客户端的类型和版本信息。很多网站通过User-Agent识别来判断访问请求是否来自于爬虫。用户代理（User Agent，简称 UA），是一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等。这个特殊字段包含了很丰富的信息，当然，也是可以通过这个agent来初步判断当前的请求是否是来源于爬虫。如果是爬虫，则可以进行限流。
在正常的网络请求，可以看到每个网络请求中肯定会携带一些User-Agent的信息。在Chrome浏览器中，可以使用检查选项，打开网络监视器。
可以在Request的heads中可以看到上面的信息：
Accept: application/x-clarity-gzip Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9 Connection: keep-alive Content-Length: 178 Cookie: MUID=2F05612551EE6C861BC173C555EE6A59 Host: d.clarity.ms Origin: https://blog.csdn.net Referer: https://blog.csdn.net/yelangkingwuzuhu sec-ch-ua: " Not A;Brand";v="99", "Chromium";v="102", "Google Chrome";v="102" sec-ch-ua-mobile: ?0 sec-ch-ua-platform: "Windows" Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: cross-site User-Agent: Mozilla/5.0 (Windows NT 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46b1d6bbfb3aa74a6a0b499106a18418/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/346839c48d115d63b363acdf287bebd6/" rel="bookmark">
			【Android 腾讯地图】腾讯地图开发记录 ① ( 地图基础显示 | 创建应用和申请key | 配置远程依赖库 | 配置腾讯地图 Key | 同意隐私协议 | 布局设置 | 覆盖自定义地图图片 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、创建应用和申请key1、创建应用2、申请 key 二、配置应用1、配置远程依赖库基础配置完整配置 2、配置腾讯地图 Key 三、地图开发1、同意隐私协议2、布局文件3、地图显示 Activity 类设置4、覆盖自定义地图图片 参考 腾讯官方文档 【腾讯位置服务 - Android地图SDK】 进行开发 ;
一、创建应用和申请key 1、创建应用 进入 腾讯位置服务 控制台页面 : https://lbs.qq.com/dev/console/home ,
点击左侧的 " 应用管理 / 我的应用 " 面板 , 进入后 , 点击右上角的 " 创建应用 " 按钮 ,
设置 创建应用 的 名称 和 类型 ,
2、申请 key 创建应用后 , 还需要申请 Key , 点击下图中 红色矩形框 中的 " 添加 Key " 按钮即可 ,
在 下图的页面中 , 输入 key 名称 , 选择 SDK 选项 , 在下面的输入框中 , 输入 Android 包名 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/346839c48d115d63b363acdf287bebd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8143f955884e02d9c8411ad9d7d6a602/" rel="bookmark">
			ai玩游戏(马里奥)项目(机器强化学习)详解 （二）设置游戏、预处理和环境矢量化 DummyVecEnv&amp;VecFrameStack 人工智能项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 上文讲解了强化学习模型ai训练玩马里奥游戏的环境，本文正式开始详细讲述训练过程。请在以下训练环境中运行本文的代码：
##环境## #pip install gym==0.23 #pip install nes-py==8.1.8 #pip install gym-super-mario-bros==7.3.0 #pip install stable_baselines3==2.0.0 #pip install Optuna 一、库导入与游戏环境设置 1）import库 import gym_super_mario_bros from nes_py.wrappers import JoypadSpace from gym_super_mario_bros.actions import SIMPLE_MOVEMENT 其中SIMPLE_MOVEMENT用于加入简化的操作方法，可以方便我们的AI操作马里奥。我们print以下SIMPLE_MOVEMENT查看：
[['NOOP'], ['right'], ['right', 'A'], ['right', 'B'], ['right', 'A', 'B'], ['A'], ['left']] 是一个操作的列表。
2）设置游戏环境对象 environment = gym_super_mario_bros.make('SuperMarioBros-v0') environment = JoypadSpace(environment, SIMPLE_MOVEMENT) 我们设置一个游戏环境的对象，其中使用的马里奥版本是标准版本（v0）
当然，你也可以使用别的版本，各个版本的差异请访问gymmario官网
第二行限定了ai的动作空间。即简单操作中包含的7个不同的按键组合。
我们这里涉及到了动作空间和观察空间，简单来说动作空间就是我们能干嘛，观察空间是我们的ai能看到啥，具体解释请看解释网址。
3）打开游戏窗口 done = True for step in range(10000): if done: environment.reset() state, reward, done, info = environment.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8143f955884e02d9c8411ad9d7d6a602/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0983437d40f06a1101bec6670bb9f1b5/" rel="bookmark">
			Docker部署node.js并运行项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【这里你的项目地址要写成0.0.0.0，方便端口检测】
要在 Docker 中部署 Node.js 并运行项目，你可以遵循以下步骤：
编写 Dockerfile： 创建一个名为 Dockerfile的文件，在其中编写 Docker 镜像的配置。以下是一个简单的示例：
docker pull node:14-buster【如果源不好用了话就先执行这个指令，版本自选】
# 使用官方 Node.js 14 镜像作为基础镜像 FROM FROM pull node:14.18.3 COPY package*.json ./ # 设置工作目录 WORKDIR /home/lawaidev/guliSchool/school前端 # 安装项目依赖 RUN npm install # 复制 package.json 和 package-lock.json 到工作目录 复制 static 文件夹到工作目录 COPY . . COPY nuxt.config.js ./ COPY static ./static COPY .nuxt ./.nuxt # 暴露容器端口 EXPOSE 3000 # 启动应用程序 CMD ["npm", "run", "start"] 在这个 Dockerfile 中，我们使用了 Node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0983437d40f06a1101bec6670bb9f1b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9af9119ae3aef9a2f1ae83d8e4ef81ae/" rel="bookmark">
			数据结构-双链表(图解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
双链表（Double-Linked List）的概念与基本特性
一、双链表的基本组成
二、双链表的主要特性
三、双链表的操作 代码展示
malloc开辟函数
解析
初始化
解析
头插
解析
尾插
解析
头删
解析
尾删
解析
pos之后插入
解析
pos删除
解析
打印
解析
全部代码展示
main.c
text.c
text.h
双链表（Double-Linked List）的概念与基本特性 双链表是一种常用且重要的线性数据结构，它在计算机科学和软件工程中扮演着不可或缺的角色。相较于单链表，双链表的每个节点包含两个指针，分别指向其前驱节点（previous node）和后继节点（next node），这一特性使得双链表在数据操作上具有更高的灵活性。
一、双链表的基本组成 双链表中的每一个元素称为节点（Node），每个节点通常包含三个部分：
数据域（Data Field）：用于存储实际数据，可以是任何类型的数据。前驱指针（Previous Pointer/Backward Pointer）：指向当前节点的前一个节点。后继指针（Next Pointer/Forward Pointer）：指向当前节点的下一个节点。 二、双链表的主要特性 双向遍历：由于每个节点都有前后两个指针，因此可以在列表中双向遍历，无需像单链表那样只能从头节点开始向前遍历。插入与删除的便捷性：在双链表中插入或删除一个节点时，只需改变相应节点的前后节点的指针指向即可，操作相对简单高效。 三、双链表的操作 常见的双链表操作包括创建、插入（包括头部插入、尾部插入和指定位置插入）、删除（包括头部删除、尾部删除和指定节点删除）、查找以及遍历等。
代码展示 malloc开辟函数 //内存开辟 listcode* inaugurate(LTDataType x) { listcode* list = (listcode*)malloc(sizeof(listcode)); if (list == NULL) { perror("malloc"); exit(1); } //初始值 list-&gt;val = x; list-&gt;next = list-&gt;prev = NULL; return list; } 解析 listcode* inaugurate(LTDataType x)` 函数定义：`inaugurate`是一个函数，接收一个参数`x`，类型为`LTDataType`。这个函数返回一个指向`listcode`结构体类型的指针。 `listcode* list = (listcode*)malloc(sizeof(listcode));` - 动态内存分配：使用`malloc`函数动态地在堆内存中分配一块大小等于`listcode`结构体所占用空间的连续区域，并将其地址赋值给`listcode`类型的指针变量`list`。如果内存分配失败，`malloc`将返回NULL。 if (list == NULL) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9af9119ae3aef9a2f1ae83d8e4ef81ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2fda4944aa67c600ec049893be4289d/" rel="bookmark">
			【JavaSE】Java中5种换行方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中5种换行符 print中，1种换行方式 System.out.print("1不换行"); System.out.print("2第一种换行方式\n"); System.out.print("3第二种换行方法\n" + "22"); System.out.print("4第三种换行方式" +"~~" + "333\n"); System.out.print("5第四种换行\n方式"); 所有出现字符\n的位置换行且print中字符串连接只用+可用+连接多个字符串 printf中，3种换行方式 System.out.printf("%s\n" , "字符串1" + "字符串2" + "字符串3"); 结尾换行 注意"%s\n"和输出字符用逗号隔开，后续加字符串用+，","不可以连接字符 System.out.printf("%s\n" , "7第五种末尾换行" + "jffdha" + "74583");//结尾换行 System.out.printf("%s%n" , "字符串1" + " 字符串2"); 结尾换行 同样，",“隔开字符”%s%n"和后续要输出的字符，后续加字符只能用+不能用, System.out.printf("%s%n" , "9第六种末尾换行" + " fhjdi"); //System.out.printf("嗯嗯\n" , "hfdjkj" ," jfkds");嗯嗯//后两段字符串不显示 "\n"出现的位置换行，+ 连接字符串 System.out.printf("嗯嗯\n" + "344" + "fdjhs9"); //System.out.printf("13第九种" + "\n", "34231");13第九种//后一段不显示 System.out.printf("13第九种" + "\n"); //System.out.printf("14","\n");14//不能换行 println中，1种换行方式 结尾换行
System.out.println("16最后一种"); 试错写法 System.out.print("1不换行"); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2fda4944aa67c600ec049893be4289d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d24ae6ea0219280bc75bd0da1f9d4185/" rel="bookmark">
			IPSec VPN 原理与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VPN (Virtual Private Network，虚拟专用网)技术起初是为了解决明文数据在网络上传输所带来 的安全隐患而产生的。TCP/IP (Transmission Control Protocol/lnternet Protocol，传输控制协议/网际协 议)协议族中的很多协议都采用明文传输，如 Telnet.FTP (File Transfer Protocol，文件传输协议). TFTP (Trivial File Transfer Protocol、普通文件传输协议)等。一些黑客可能为了获取非法利益，通过 诸如窃听、伪装等攻击方式截获明文数据，使企业或个人蒙受损失。 VPN技术可以从某种程度上解决该问题。例如，它可以对公网上传输的数据进行加密，即使黑 客通过某种窃听工具截获到数据，也无法了解数据信息的含义，也可以实现数据传输双方的身份验 证，避免黑客伪装成网络中的合法用户攻击网络资源。
VPN的定义 VPN就是在两个网络实体之间建立的一种受保护的连接，这两个实体可以通过点到点的链路直 接相连，但通常情况下它们会相隔较远的距离。
对于定义的“受保护”一词，可以从以下几个方面理解。
实际工作环境中的VPN解决方案不一定包含上述所有功能，这要由具体的环境需求和实现方式 决定。而且很多企业可能采用不止一种的VPN解决方案。
VPN的模式与类型 1.VPN的连接模式 VPN技术有两种基本的连接模式;传输模式和隧道模式。这两种模式实际上定义了两台实体设 备之间传输数据时所采用的不同的封装过程。
（1）传输模式 如图1.1所示，传输模式一个最显著的特点就是，在整个VPN的传输过程中，P包头并没有被 封装进去，这就意味着从源端到目的端数据始终使用原有的IP地址进行通信。而传输的实际数据载 荷被封装在VPN报文中。对于大多数VPN传输而言，VPN的报文封装过程就是数据的加密过程，因 此，攻击者截获数据后将无法破解数据内容，但却可以清晰地知道通信双方的地址信息。
由于传输模式封装结构相对简单(每个数据报文较隧道模式封装结构节省20字节)，因此传输 效率较高，多用于通信双方在同一个局城网内的情况。例如，网络管理员通过网管主机登录公司内 网的服务器进行维护管理，就可以选用传输模式VPN对其管理流量进行加密。 （2）隧道模式 如图1.2所示，隧道模式与传输模式的区别显而易见,VPN设备将整个三层数据报文封装在VPN 数据内，再为封装后的数据报文添加新的IP包头。由于在新P包头中封装的是VPN设备的IP地址信 息，所以当攻击者截获数据后，不但无法了解实际载荷数据的内容，同时也无法知道实际通信双方 的地址信息。
由于隧道模式的VPN在安全性和灵活性方面具有很大的优势，在企业环境中应用十分广泛，总 公司和分公司跨广城网的通信，移动用户在公网访问公司内部资源等很多情况，都会应用隧道模式的VPN对数据传输进行加密。
2.VPN的类型 通常情况下，VPN的类型分为站点到站点VPN和远程访问VPN。
（1）站点到站点 VPN 站点到站点VPN就是通过隧道模式在VPN网关之间保护两个或更多的站点之间的流量，站点间 的流量通常是指局城网之间(L2L)的通信流量。L2L VPN多用于总公司与分公司、分公司之间在公 网上传输重要业务数据。
如图1.3所示，对于两个局域网的终端用户来说，在VPN网关中间的网络是透明的，就好像通 过一台路由器连接的两个局域网。总公司的终端设备通过VPN连接访问分公司的网络资源，数据包 封装的IP地址都是公司内网地址(一般为私有地址)，而VPN网关对数据包进行的再次封装过程 客户端是全然不知的。
（2）远程访问 VPN 远程访问VPN通常用于单用户设备与 VPN网关之间的通信连接，单用户设备一般为一台PC或 小型办公网络等。VPN连接的一端为PC，可能会让很多人误解远程访问VPN使用传输模式，但因为 该种VPN往往也是从公网传输关键数据，而且单一用户更容易成为黑客的攻击对象，所以远程访 问VPN对于安全性的要求较高，更适用于隧道模式。
要想实现隧道模式的通信，就需要给远程客户端分配两个P地址:一个是它自己的NIC地址 另一个是内网地址。也就是说远程客户端在VPN建立过程中同时充当VPN网关(使用NIC地址)和 终端用户(使用内网地址)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d24ae6ea0219280bc75bd0da1f9d4185/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84ca1991bf48322eb2ea47d87e5c0dc5/" rel="bookmark">
			Docker容器搭建Hadoop集群(hadoop-3.1.3)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker容器环境下搭建Hadoop集群（完全分布式）
hadoop版本为hadoop-3.1.3
（1）安装额外的速度较快的镜像库
yum install -y epel-release （2）安装同步工具，方便在多台服务器上进行文件的传输
yum install -y rsync （3）安装网络工具
yum install -y net-tools （4）安装具有代码高亮显示的编辑器
yum install -y vim 一、docker安装 安装所需要的资源包
yum install -y yum-utils 设置仓库（阿里云）
yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 安装docker
yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin 查看安装列表
yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin 启动docker
systemctl start docker 关闭防火墙
sudo systemctl stop firewalld ​ sudo systemctl disable firewalld 关闭 iptables
sudo systemctl stop iptables ​ sudo systemctl disable iptables 查看状态
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84ca1991bf48322eb2ea47d87e5c0dc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a082cf092fd38b334c81516716d66a6/" rel="bookmark">
			即插即用的涨点模块之注意力机制（SKAttention）详解及代码，可应用于检测、分割、分类等各种算法领域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、SKNet结构
二、SKNet计算流程
三、SKNet参数
四、代码详解
前言 Selective Kernel Networks（SKNet）
来源：CVPR2019
官方代码：https://github.com/implus/SKNet
什么是感受野？感受野（receptive field）是指在网络的前向传播过程中，每个神经元对输入数据的区域大小。换句话说，它表示了神经元在输入空间中接收信息的范围。在图像处理任务中，神经元的感受野大小通常与输入图像的像素大小有关。较小的感受野可以捕获局部细节，而较大的感受野则可以捕获更大范围的整体结构和语境信息。因此，设计合适大小的感受野对于不同的任务和网络架构至关重要。SKAttention能够根据输入动态选择不同大小的卷积核。这种设计使得网络可以根据输入自适应地调整其感受野，从而更有效地捕获不同尺度的特征。这在处理诸如图像分类和对象检测等任务中特别有用，这些任务中输入特征的尺度和大小可能有很大的变化。
一、SKNet结构 SKNet结构如图一所示。SK卷积由Split，Select和Split三个操作来实现。Split操作：使用多个不同大小的卷积核对输入特征进行卷积操作（每次卷积操作即一组CBR），得到多个尺度的特征表示，再将这些特征表示拼接起来；Fuse操作：由两个全连接层、一个全局平均池化及Relu激活函数组成，首先对多个分支元素求和，即相同形状的张量中的对应元素进行相加。然后进行全局平均池化，压缩为具有相同通道数的特征向量，捕捉全局信息。接着先降维再升维，得到 K 个尺度对应的通道描述符，并将升维后的特征向量重塑为与输入的大小相同，重塑后的特征向量按照第 0 维度（K 维度）进行堆叠，形成一个新的张量，通过 softmax 函数将每个尺度对应的权重进行归一化处理，使得它们的总和为 1。Selecte操作：将每个尺度的权重与对应的之前卷积之后的结果加权求和，得到不同的分支权重组合，影响融合后的层级V的有效感受野大小。
精读：Split操作：目的：为了捕获多尺度的特征信息，Split操作首先将输入特征通过不同大小的卷积核处理。常见的配置可能包括使用3x3、5x5等不同尺寸的卷积核。
实现：每个卷积后接批归一化（Batch Normalization）和ReLU激活函数，形成一组卷积-批归一化-激活（CBR）单元。这些不同尺度的特征图接着被拼接在一起，形成一个更丰富的特征表示。
Fuse 操作：目的：为了综合多尺度的信息并生成每个尺度的重要性权重，Fuse操作处理拼接后的特征，通过全局信息来指导选择操作。
实现：求和：首先将所有分支的特征图进行逐元素相加。全局平均池化：接着对求和后的结果进行全局平均池化，从而压缩特征至一个全局描述符。降维与升维：通过两个全连接层（通常先降维后升维），处理池化后的特征，生成每个尺度的通道描述符。重塑与归一化：将通道描述符重塑成原始输入的尺寸，并通过softmax进行归一化，生成每个尺度的权重。
Select 操作：目的：根据Fuse操作生成的尺度权重，动态选择并融合不同尺度的特征。
实现：将每个尺度的权重应用于对应的卷积输出（从Split操作得到），通过加权求和的方式，结合这些特征。这样，网络可以侧重于当前最有效的特征尺度，从而优化处理结果。
二、SKNet计算流程 对于任意给定的特征映射，默认情况下我们首先进行两个变换：X→∈和：X→∈，核大小分别为3×3和5×5，将其分为和，并将和按元素求和，得到U:
然后通过全局平均池化将（B,C,H,W）压缩到（B,C），单个特征向量:
然后经过全连接层进行降维和升维:
接下来通过Softmax得到各个特征尺度的权重，并在Select中将其与卷积后的结果加权求和。
三、SKNet参数 利用thop库的profile函数计算FLOPs和Param。Input:(512,7,7)。
Module
FLOPs
Param
SKAttention
1079555584
22192192
四、代码详解 import torch from torch import nn from collections import OrderedDict class SKAttention(nn.Module): #通道数channel, 卷积核尺度kernels, 降维系数reduction, 分组数group, 降维后的通道数L def __init__(self, channel=512, kernels=[1, 3, 5, 7], reduction=16, group=1, L=32): super().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a082cf092fd38b334c81516716d66a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3e2a20c2b9179add987582be2cc82e4/" rel="bookmark">
			在本地跑一个AI模型(5) - Stable Diffusion
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在之前的文章中，我们使用ollama在本地运行了大语言模型，它可以与你聊天，帮助你理解和生成文本内容。使用coqui-tts在本地运行了文本转语音模型，它可以将大语言模型生成的文字转换成语音，让你的应用更有趣。今天我们将要介绍Stable Diffusion，一种扩散神经网络的深度学习模型，使用它可以生成各种不可思议的图片。
我们使用的工具是huggingface提供的diffusers，一个在纯python环境下运行的库。废话不多说，我们进入今天的教程。
安装 diffusers目前不支持python 3.12，因此我们使用虚拟环境来安装。
# 使用3.10版本的python创建venv /opt/homebrew/opt/python@3.10/libexec/bin/python3 -m venv .venv # 激活venv source .venv/bin/activate 安装diffusers及其依赖：
pip install diffusers accelerate transformers 下载模型 和之前文章里介绍的一样，模型我们还是选择自己下载。你可以到huggingface网站下载已经训练好的模型，比如runwayml/stable-diffusion-v1-5。
Tips：你可以使用如下命令下载huggingface上的模型：
git lfs install git clone git@hf.co:&lt;MODEL ID&gt; # example: git clone git@hf.co:bigscience/bloom 此外，diffusers支持AUTOMATIC1111的模型，因此你可以去Civitai下载各种CheckPoint和LoRA。本文使用的模型就是Civitai的dreamshaper。选择模型时要注意以下几点：
根据自己的喜好选择模型的风格，比如“写实”、“动漫”或者“魔幻”模型有一个属性是“基础模型”，如下图。对应的诸如SD 1.5、SDXL 1.0、SDXL Turbo等等。SD系列只能生成512x512的图片，SDXL系列可以生成1024x1024及以上的图片。而Turbo系列可以将生成所需的时间缩短。根据自己的电脑配置选择合适的模型吧。 选择好模型后，就点击Download下载吧。
加载模型 如果你的模型是单个safetensors格式的，使用from_single_file加载，如果是从huggingface下载的预训练模型，使用from_pretrained加载。此外如果你的模型是SDXL，使用StableDiffusionXLPipeline，因此dreamshaperXL模型加载的代码如下：
from diffusers import StableDiffusionXLPipeline pipe = StableDiffusionXLPipeline.from_single_file("your/path/dreamshaperXL_v21TurboDPMSDE.safetensors") 使用GPU运行 windows用户可以根据如下代码判断自己的电脑能否进行GPU推理：
device = "cuda" if torch.cuda.is_available() else "cpu" MAC的M1和M2芯片可以使用如下代码：
device = 'mps' 然后：
pipe = pipe.to(device) 调度器 diffusers的调度器对应的是AUTOMATIC1111中的Sampling method，它对获得高质量的图像至关重要。Sampling method和diffusers的调度器的对应关系可以参照此处。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3e2a20c2b9179add987582be2cc82e4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/405/">«</a>
	<span class="pagination__item pagination__item--current">406/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/407/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>