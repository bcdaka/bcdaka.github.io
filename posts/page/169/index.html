<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e5601933f21ab3002b72df91482cc60/" rel="bookmark">
			小程序接入腾讯地图并使用（完整版带api示例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、开通腾讯位置服务 登录进入小程序后台，选择 “开发 - 开发工具 - 腾讯位置服务”
点击腾讯位置服务
点击 “开通”，进入授权扫码界面，使用微信扫码进行授权
如果已经有账号了，可以绑定现有账号
二、插件申请接入 点击服务，进入微信服务市场
点击开发者资源
点击插件，然后在搜索框中搜索“腾讯位置服务”
点击“腾讯地图服务地图选点”
点击“添加插件”
打开微信扫码，然后再次点击“添加插件”
选择小程序后点击确定。
此时，在微信公众平台中点击 设置----第三方设置----插件管理，就可以看到腾讯服务地图选点
同理，我们可以在微信服务市场中一次性添加多个插件，如腾讯位置服务地铁图，腾讯位置服务路线规划，最终如下所示：
点击“腾讯位置服务地图选点”右侧的详情
地图选点appId
点击”开发文档“
第一步插件申请接入已经完成
三、申请开发者密钥和开通webserviceAPI服务 访问https://lbs.qq.com/dev/console/application/mine，进入如下页面
点击“个人中心”----我的信息，在这里注册成个人开放者或进行企业认证
点击“应用管理”----我的应用，
点击“添加Key”，进入如下界面
小程序插件需要使用WebService API的部分服务，所以需要给使用该功能的KEY配置相应权限。
勾选WebServiceAPI和微信小程序，输入微信小程序的APPID，勾选同意协议，点击添加，进入如下页面，此时会生成密钥。
四、使用插件"地图选点" 1、引入插件包
在app.json中添加
// app.json { "plugins": { "chooseLocation": { "version": "1.0.10", "provider": "wx76a9a06e5b4e693e" } } } 其中，provider填写你自己的appId，如下所示
{ "pages": [ "pages/home/home", "pages/index/index", "pages/logs/logs", "pages/login/index", "pages/location/location" ], "window": { "backgroundTextStyle": "light", "navigationBarBackgroundColor": "#fff", "navigationBarTitleText": "Weixin", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e5601933f21ab3002b72df91482cc60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/846dd91a71eef77979260c5cb4a7ed0b/" rel="bookmark">
			【数值模拟】参数化基本概念和参数化建模
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参数化基本概念 参数化（Parameterization）是是个统计学概念，本身意味着“用参数来表达”。 参数化是一个数学过程，包括将系统、过程或模型的状态表示为一些称为参数的独立量的函数。 系统的状态通常由一组有限的坐标确定，因此参数化由每个坐标的几个实变量的一个函数组成。 参数的数量是系统的自由度的数量。简单地说，是指将某些特性或行为通过引入参数来表示或定义的过程。
参数化一般可以分为以下几种类型：
模型参数化：用于描述数学模型或统计模型中的参数。比如在线性回归中，斜率和截距就是模型参数。
函数参数化：在编程中，函数通过参数来接受不同的输入，从而实现不同的功能。例如，函数 f(x, y) 中的 x 和 y 就是参数。
设计参数化：在工程设计和CAD建模中，通过修改参数来生成不同的设计方案。例如，改变汽车零件的尺寸参数以设计不同型号的零件。
物理过程参数化：在物理和气象学中，通过引入参数来简化和描述复杂的自然过程。例如，通过参数化描述云的形成和发展过程。
算法参数化：在计算机科学中，通过参数化控制算法的行为和输出。例如，排序算法中的比较函数可以作为参数来定义排序规则。
数值模拟中的参数化 在数值模拟模型中，参数化方法是将复杂的物理过程简化为一组参数，以便在计算模型中有效地表示和模拟这些过程。具体到物理现象的数值模拟，参数化技术的要点和技术细节如下：
技术要点和技术细节 物理现象的识别与分析：
识别需要参数化的物理现象，例如大气/海洋中的湍流、辐射传输、形成等。
分析这些现象的基本特性和行为，确定哪些方面可以用参数化的方法来简化。
参数选择与定义：
确定关键参数，这些参数应能有效描述物理现象的主要特征。例如，云参数化中可能包括云的覆盖率、液态水含量等。
定义参数的物理意义和范围，确保参数具有明确的物理解释。
建立参数化公式：
通过理论分析和实验数据，建立描述物理过程的参数化公式。例如，湍流的参数化公式可能涉及湍流动能和耗散率。
确保公式的准确性和适用范围，避免过度简化导致模型不准确。
模型验证与校准：
通过观测数据和实验结果对参数化模型进行验证和校准，调整参数使模型输出与实际观测一致。
使用多种验证方法（如敏感性分析和不确定性分析）评估模型的鲁棒性和稳定性。
模型集成与应用：
将参数化模型集成到更大的数值模拟框架中，如气象模型或海洋模型。
进行数值模拟实验，评估参数化方法对整体模型性能的影响。
图件来源：https://www.slideserve.com/pelham/lhllasg-iap-ac-200710
机器学习方法在参数化中的作用 机器学习方法在数值模拟模型的参数化中可以发挥重要作用，主要包括以下几个方面：
数据驱动的参数发现：
通过机器学习算法，从大量观测数据和模拟数据中提取参数关系。例如，使用回归算法找到输入变量与参数之间的关系。
自动化地发现和优化参数，减少对人工经验的依赖。
非线性关系建模：
传统的参数化方法有时难以捕捉复杂的非线性关系，而机器学习，特别是深度学习（如神经网络），可以有效建模非线性关系。
提高参数化模型的精度和适用范围。
快速替代模型：
使用机器学习构建快速的替代模型（surrogate models），在保持高精度的同时显著降低计算成本。
例如，使用深度神经网络模拟湍流等复杂物理过程，替代高计算成本的直接模拟。
参数优化与调优：
使用机器学习的优化算法（如遗传算法、粒子群优化等）自动调整参数，提高模型性能。
提高模型的自适应性，使其在不同条件下表现良好。
不确定性量化：
使用机器学习方法对参数的不确定性进行量化，提供更可靠的模拟结果。
例如，通过贝叶斯方法估计参数的不确定性和置信区间。
总之，机器学习在数值模拟模型的参数化中不仅能提高参数化的准确性和效率，还能处理复杂的非线性关系和大规模数据，使得模拟结果更加可靠和精确。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65309c1b976ccee4d9a80768263e7f22/" rel="bookmark">
			Elasticsearch 开放推理 API 增加了对 Amazon Bedrock 的支持
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：来自 Elastic Mark Hoy, Hemant Malik
Elasticsearch 开放推理 API 增加了对托管在 Amazon Bedrock 上的模型生成嵌入的支持。
Elasticsearch 开放 infereence API 使开发人员能够创建推理端点并使用来自领先提供商的机器学习模型。从今天开始，托管在 Amazon Bedrock 上的模型将通过 Elasticsearch 开放 inference API 提供。现在，使用 Elasticsearch 向量数据库构建 RAG 应用程序的开发人员可以存储和使用托管在 Amazon Bedrock 上的模型（例如 Amazon Titan、Anthropic Claude、Cohere Command R 等）生成的嵌入。Bedrock 与开放推理 API 的集成提供了一种与不同 AI 模型（例如文本嵌入和聊天完成）交互的一致方式，从而简化了使用 Elasticsearch 的开发过程。
从 Amazon Bedrock 中选择一个模型在 Elasticsearch 中创建并使用推理端点将模型用作推理管道的一部分 在 Amazon Bedrock 中使用基础模型 本演练假设你已经拥有一个可以访问 Amazon Bedrock 的 AWS 账户 - 这是一项完全托管的托管模型服务，可通过统一 API 提供基础模型。
在 AWS 控制台中的 Amazon Bedrock 中，确保你确实有权访问 Amazon Titan Embeddings G1 - Text 模型。你可以通过转到 AWS 控制台中的 Amazon Bedrock 服务并检查 _Model access.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65309c1b976ccee4d9a80768263e7f22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c81655840d89b560ededc1416f087b01/" rel="bookmark">
			【ACM 独立出版，高录用EI稳检索】2024年大数据与数字化管理国际学术会议 (ICBDDM 2024，8月16-18)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 2024年大数据与数字化管理国际学术会议 (ICBDDM 2024)，将于2024年8月16-18日在中国上海召开。 “大数据与数字化管理”作为会议主题，旨在聚焦这一跨学科领域中最新的理论研究、技术进展、实践案例和未来趋势。本主题探讨的研究方向涵盖了大数据的收集、处理、分析和应用，数字化技术在组织管理和运营中的实践，以及数字化转型过程中组织、人力和文化的适应性变革等多个层面。此外，会议还关注大数据和数字化带来的伦理、隐私、安全和治理问题，旨在为学术界、产业界和政策制定者提供一个交流和探索如何在数字化时代成功利用大数据的平台。
1. 会议官方 会议官网：www.icbddm.com 时间地点：2024年8月16-18日 | 中国-上海
二轮截稿时间：2024年7月31日（多轮截稿，官网为准）
接受/拒稿通知：投稿后1周内
收录检索：EI核心、Scopus
2. 组织单位 广东工业大学（Guangdong University of Technology）简称“广工”，是广东省重点建设的省属重点大学、广东省“211工程”、首批广东省高水平大学、首批广东省高水平理工科大学、国家“111计划”“2011计划”高校；入选教育部“卓越工程师教育培养计划”、国家大学生文化素质教育基地、国家知识产权示范高校、教育部深化创新创业教育改革示范高校，是粤港澳高校联盟、全国大学生创新创业实践联盟、金砖国家智库合作中方理事会、国际设计艺术院校联盟、国家集成电路产教融合发展联盟、大学通识教育联盟主要单位。
3. 主席嘉宾 3.1 大会主席： 张引 教授（h值45）电子科技大学，中国，IEEE SM、ACM SMHamed Taherdoost 教授（h值40）韦斯特克利夫大学，美国IEEE Senior Member朱鉴 教授，广东工业大学，中国计算机学院副院长Jianhua Zhang 教授（h值25）奥斯陆城市大学，挪威，IEEE CIS 挪威分会副主席 3.2 主讲嘉宾： 前往[【会议官网】]了解更多会议主席嘉宾…
4. 征稿主题 5. 出版检索 ICBDDM 2024已经通过ACM出版申请，本届会议论文集ISBN号已确定：979-8-4007-1027-8，投稿经过2-3位组委会专家严格审核之后，最终所录用的论文将被ACM出版社出版，并提交至EI Compendex（EI）, Scopus检索。
6. 参会投稿 6.1 投稿须知： 论文根据模板排版不得少于4页，会议论文模板请前往【会议官网】→【会议资料】处下载
英文投稿：请将排版好的论文全文投稿至【会议官网】→【论文投稿】
论文应具有学术或实用价值，未在国内外学术期刊或会议发表过。
6.2 参会方式： 作者参会：一篇录用文章允许一名作者免费参会；
主讲嘉宾：申请主题演讲，由组委会审核；
口头演讲：申请口头报告，时间为15分钟；
海报展示：申请海报展示，A1尺寸，彩色打印；
听众参会：不投稿仅参会，也可申请演讲及展示。
报名参会：请前往【会议官网】→【参会报名】
前往[【会议官网】]报名参会
学术会议 想要了解更多国内主办的覆盖学科最全最广的学术会议，请前往[【所有会议官网】]如有意愿参会或投稿，可以获取邀请码，享受参会、投稿优惠，优先审核 创作不易，麻烦点点赞和关注咯！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a33151bb33f3d545989e53529bb5c6d3/" rel="bookmark">
			请结合一个问题bug，帮忙梳理一下DecorView和Window之间的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Android开发中，DecorView 和 Window 是两个核心概念，它们在用户界面显示和布局管理中扮演着重要角色。为了更好地理解它们之间的关系，并通过一个假设的bug场景来梳理它们，我们可以从以下几个方面进行阐述。
1. Window 的概念 在Android中，Window 是一个抽象的概念，代表了一个顶层窗口，可以包含视图（Views）和布局。但是，Window 本身不是一个类，而是由WindowManager服务管理的一系列接口和概念的集合。每个Activity都持有一个Window，这个Window是Activity与用户交互的媒介。
2. DecorView 的角色 DecorView 是Window的根视图（Root View），它是一个特殊的FrameLayout，用于承载Activity的内容视图（Content View）和其他系统级视图（如标题栏、状态栏等）。当你通过setContentView()方法设置Activity的布局时，这个布局实际上是被添加到DecorView中的。
3. 假设的Bug场景 假设我们遇到了一个bug，表现为Activity的布局没有正确显示，或者布局的一部分（如标题栏）显示异常。这个bug可能与DecorView和Window的关系处理不当有关。
分析和排查步骤： 检查布局文件： 确认setContentView()方法中指定的布局文件是否正确无误。检查是否有XML语法错误或布局属性设置不当。审查Activity的onCreate()方法： 确认在调用setContentView()之前或之后，没有代码错误地修改了DecorView或其子视图。检查是否有其他代码（如自定义的Theme）影响了DecorView的默认布局或属性。检查Theme设置： Activity的Theme会影响DecorView的默认布局和样式。检查AndroidManifest.xml中Activity的android:theme属性或程序中动态设置的Theme，确保它们没有导致问题。特别注意与标题栏（ActionBar/Toolbar）、状态栏和导航栏相关的Theme属性。调试和日志： 使用Android Studio的Layout Inspector工具查看Activity运行时的UI层次结构，检查DecorView及其子视图的布局和属性。在关键代码处添加日志输出，以跟踪DecorView和Window的创建和修改过程。考虑系统级因素： 如果问题出现在特定设备或Android版本上，考虑系统级差异可能导致的兼容性问题。检查是否有第三方库或系统服务影响了Window和DecorView的行为。 4. 修复策略 根据分析结果，可能需要：
修改布局文件以纠正显示问题。调整Theme设置以匹配预期的用户界面样式。在Activity代码中修正对DecorView或其子视图的错误操作。如果问题与系统级差异有关，可能需要编写条件性代码或寻找替代方案。 通过上述步骤，我们可以更清晰地理解DecorView和Window之间的关系，并有效地排查和解决与它们相关的bug。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbae6a867b9a64148999f4401bed2dd1/" rel="bookmark">
			unordered_map和set
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：本篇文章继续分享新的容器unordered_map和set。前边我们分享过map和set，其底层为红黑树，而unordered_map和set的底层则为哈希表，因此在unordered_map和set的实现中，我们可以效仿许多在map和set的中就分享过的一些知识，所以在本篇文章中，就不对分享过的知识进行重复讲解。
而unordered_map和set与map和set的区别，即为红黑树和哈希表的区别。
目录
一.修改hash
二.迭代器
三.完整代码
1.unordered_map
2.unordered_set
四.总结
一.修改hash 我们所实现的普通哈希表肯定是无法直接拿来作为unordered_map和set的底层代码的，所以我们需要对其进行优化修改，完整代码如下：
template&lt;class K&gt; struct HashFunc { size_t operator()(const K&amp; key) { return (size_t)key; } }; struct HashStringFunc { size_t operator()(const string&amp; s) { size_t hash = 0; for (auto e : s) { hash += e; } return hash; } }; namespace hash_bucket { template&lt;class T&gt; struct HashNode { T _data; HashNode&lt;T&gt;* _next; HashNode(const T&amp; data) :_data(data) , _next(nullptr) {} }; //前置声明 template&lt;class K, class T, class KeyOfT, class Hash&gt; class HashTable; template&lt;class K, class T, class KeyOfT, class Hash&gt; struct __Iterator { typedef HashNode&lt;T&gt; Node; typedef __Iterator&lt;K, T, KeyOfT, Hash&gt; Self; Node* _node; HashTable&lt;K, T, KeyOfT, Hash&gt;* _pht; __Iterator(Node* node, HashTable&lt;K, T, KeyOfT, Hash&gt;* pht) :_node(node) ,_pht(pht) {} T&amp; operator*() { return _node-&gt;_data; } T* operator-&gt;() { return &amp;_node-&gt;_data; } Self&amp; operator++() { if (_node-&gt;_next) //当前桶没走完，找到下一个节点 _node = _node-&gt;_next; else { //当前桶走完了，找下一个不为空的桶的第一个节点 KeyOfT kot; Hash hs; size_t i = hs(kot(_node-&gt;_data)) % _pht-&gt;_tables.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbae6a867b9a64148999f4401bed2dd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcdf4cf52af8645fbd47dc2e7cb60ea7/" rel="bookmark">
			【鸿蒙学习笔记】通过用户首选项实现数据持久化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方文档：通过用户首选项实现数据持久化
目录标题 使用场景第1步：源码第2步：启动模拟器第3步：启动entry第6步：操作样例2 使用场景 Preferences会将该数据缓存在内存中，当用户读取的时候，能够快速从内存中获取数据，当需要持久化时可以使用flush接口将内存中的数据写入持久化文件中。Preferences会随着存放的数据量越多而导致应用占用的内存越大，因此，Preferences不适合存放过多的数据，也不支持通过配置加密，适用的场景一般为应用保存用户的个性化设置（字体大小，是否开启夜间模式）等。 第1步：源码 import { common } from '@kit.AbilityKit'; import dataPreferences from '@ohos.data.preferences'; @Entry @Component struct Index { @State changeFontSize: number = 16; // 上下文 private context: common.UIAbilityContext = getContext(this) as common.UIAbilityContext //1. 获取preference private preferencesInstance: dataPreferences.Preferences = dataPreferences.getPreferencesSync(this.context, { name: 'myStore' }); aboutToAppear(): void { //4. 页面打开后，直接从preference中获取上一次的数据 let result = this.preferencesInstance.getSync("fontSizeKey", 16) this.changeFontSize = Number(result) } build() { Column() { Row({ space: 10 }) { Text('当前进度一览').
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcdf4cf52af8645fbd47dc2e7cb60ea7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d0c6f67a46214ab54c1e4594c27a327/" rel="bookmark">
			C&#43;&#43; ：内联函数inline|nullptr
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到Harper·Lee的学习笔记！
博主主页传送门：Harper·Lee博客主页！
欢迎交流学习！
一、inline关键字 1.1 什么是内联函数？ 内联函数：用** inline 修饰的函数叫做内联函数，编译时C++编译器会在调用的地方展开内联函数**，这样调用内联函数就需要创建栈桢，就提高效率了。
1.2 为什么会有内联函数？ 1.2.1 回顾宏 主要目的就是为了替代C语言中的宏。先回顾一下什么是宏：
宏就是一种替换，右边的替换掉左边的； #include&lt;iostream&gt; using namespace std; //right #define ADD(x,y) ((x)+(y))//括起来 int main() { int ret = ADD(1,2);//替换后：int ret = ((1)+(2)); cout &lt;&lt; ADD(1,2) &lt;&lt; endl; return 0; } 宏的末尾不能加分号，否则 ; 对语句造成干扰，出现语法错误。 #include&lt;iostream&gt; using namespace std; //如果加了分号 #define ADD(x,y) ((x)+(y)); int main() { int ret = ADD(1,2);//替换后：int ret = ((1)+(2)); cout &lt;&lt; ADD(1,2); &lt;&lt; endl;//error return 0; } 宏用于替换的表达式一定加整体括号。 C语言中宏的缺点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d0c6f67a46214ab54c1e4594c27a327/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/107372fbbb9b3709d82a58494356cdf3/" rel="bookmark">
			Flask和Django两个Web框架的特点和适用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flask与Django是两个非常流行的Python Web框架，它们各有独特的特点和适用场景。下面将从不同方面对这两个框架进行比较。
一、特点比较 1. 轻量级与全功能 Flask： 轻量级：Flask是一个微框架，代码量少，灵活性高，适合快速开发小型应用程序。它提供了构建Web应用所需的基本功能，但保持了简单性和灵活性。灵活性：Flask不限制开发者的开发方式，开发者可以根据自己的需求自由选择开发方式，并通过扩展库来添加额外功能。易学易用：Flask的文档清晰简洁，易于学习和使用，尤其适合初学者。Django： 全功能：Django是一个功能齐全的框架，提供了许多内置功能，如ORM（对象关系映射）、表单验证、管理界面等，这些功能使得开发复杂的Web应用更加高效。约定优于配置：Django通过提供许多约定来简化开发过程，但这也可能在一定程度上限制开发者的灵活性。 2. 可扩展性与性能 Flask： 可扩展性强：Flask提供了丰富的扩展库，开发者可以根据需求选择合适的扩展来扩展功能。这使得Flask能够适应不同规模和复杂度的Web应用开发。性能：Flask本身性能良好，但在处理大规模并发请求时可能需要借助其他工具（如Nginx、uWSGI等）进行优化。Django： 可扩展性：Django框架的设计非常灵活，可以方便地进行功能扩展和定制。虽然Django自带了许多功能，但开发者仍然可以通过第三方库和插件来进一步扩展功能。性能：Django在性能方面也有很好的表现，特别是当结合使用高效的数据库和缓存策略时。 3. 社区与生态系统 Flask： 社区支持良好：Flask有一个庞大的社区，提供了丰富的资源和支持。虽然其生态系统相对较小，但仍然有大量的扩展和库可用。Django： 庞大且活跃的社区：Django拥有一个庞大且活跃的社区和生态系统，有大量的第三方应用、插件和库可用。这使得Django在功能丰富性和开发便利性方面具有显著优势。 二、适用场景比较 Flask： 适用于快速原型开发和小型Web应用程序的开发。由于Flask的灵活性和简洁性，它非常适合需要快速迭代和验证想法的场景。适用于需要高度定制化的项目。Flask允许开发者根据自己的需求选择适合的开发方式和扩展库，从而满足特定的项目需求。Django： 适用于构建大型的Web应用，特别是那些需要快速开发和可扩展性的项目。Django的内置功能和约定使得开发者可以更加高效地开发复杂的Web应用。适用于需要丰富功能的项目，如内容管理系统（CMS）、电子商务网站、社交网络网站等。Django提供了许多现成的功能和组件，可以大大节省开发时间和成本。 综上所述，Flask和Django在特点和适用场景上各有千秋。选择哪个框架取决于项目需求、团队的技能水平以及个人偏好。如果项目规模较小且需要快速迭代和验证想法，Flask可能是一个更好的选择；而如果项目规模较大且需要丰富功能和高效开发，Django则可能更加适合。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75af3d73275c633cc7121a344df21587/" rel="bookmark">
			【机器学习】朴素贝叶斯算法详解与实战扩展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到 破晓的历程的 博客 ⛺️不负时光，不负己✈️ 引言 朴素贝叶斯算法是一种基于概率统计的分类方法，它利用贝叶斯定理和特征条件独立假设来预测样本的类别。尽管其假设特征之间相互独立在现实中往往不成立，但朴素贝叶斯分类器因其计算简单、效率高、对缺失数据不敏感等优点，在文本分类、垃圾邮件过滤、情感分析等领域有着广泛的应用。
朴素贝叶斯算法原理深度剖析 贝叶斯定理 贝叶斯定理是朴素贝叶斯分类器的基础，它描述了条件概率之间的关系。在分类问题中，我们关心的是给定特征 X X X下，样本属于某个类别 Y Y Y的概率，即后验概率 P ( Y ∣ X ) P(Y|X) P(Y∣X)。贝叶斯定理允许我们通过先验概率 P ( Y ) P(Y) P(Y)、条件概率 P ( X ∣ Y ) P(X|Y) P(X∣Y)以及证据概率 P ( X ) P(X) P(X)来计算后验概率。
特征条件独立假设 朴素贝叶斯算法的核心假设是特征之间相互独立，即一个特征的出现与其他特征无关。这个假设极大地简化了计算过程，因为我们可以将联合概率分布分解为多个边缘概率分布的乘积。然而，这个假设在现实中往往不成立，但实验表明，朴素贝叶斯分类器在许多情况下仍然能够取得很好的分类效果。
参数估计 在朴素贝叶斯算法中，我们需要估计先验概率 P ( Y ) P(Y) P(Y)和条件概率 P ( X ∣ Y ) P(X|Y) P(X∣Y)。对于先验概率，通常可以直接从训练数据中计算得出。对于条件概率，不同的朴素贝叶斯实现方法有不同的处理方式，比如多项式朴素贝叶斯（适用于离散特征）、高斯朴素贝叶斯（适用于连续特征）等。
算法优缺点分析 优点 计算效率高：
朴素贝叶斯算法的核心优势在于其高效的计算性能。由于假设特征之间相互独立，因此可以将联合概率分布分解为多个边缘概率分布的乘积，极大地简化了计算过程。这使得朴素贝叶斯算法在处理大规模数据集时仍然能够保持较快的处理速度。另外，朴素贝叶斯算法在训练和预测阶段通常只需要简单的数学运算，如乘法、加法和指数运算，这些运算在计算机上实现起来非常高效。 对缺失数据不敏感：
在实际应用中，数据集往往存在缺失值或不完整的情况。朴素贝叶斯算法在处理这类问题时表现出良好的鲁棒性。即使某些特征值缺失，算法仍然能够利用其他特征进行预测，而不需要对缺失值进行复杂的预处理或填充。这是因为朴素贝叶斯算法在计算条件概率时，每个特征都是独立考虑的，所以某个特征的缺失不会影响到其他特征的条件概率计算。 模型简单，易于实现：
朴素贝叶斯算法的模型结构相对简单，易于理解和实现。它不需要复杂的迭代过程或优化算法，只需要简单的数学运算即可完成训练和预测。这使得非专家用户也能够轻松地使用朴素贝叶斯算法来解决实际问题。另外，由于模型简单，朴素贝叶斯算法也更容易进行解释和可视化，有助于用户理解模型的决策过程和结果。 分类效果通常较好：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75af3d73275c633cc7121a344df21587/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11a312ece68849508614c214cc865075/" rel="bookmark">
			【初阶数据结构】算法效率大揭秘 | 时间与空间复杂度的深度剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初阶数据结构相关知识点可以通过点击以下链接进行学习一起加油！时间与空间复杂度的深度剖析深入解析顺序表:探索底层逻辑深入解析单链表:探索底层逻辑深入解析带头双向循环链表:探索底层逻辑深入解析栈:探索底层逻辑深入解析队列:探索底层逻辑深入解析循环队列:探索底层逻辑 本篇将介绍影响算法效率的两个因素时间复杂度与空间复杂度，随着计算机的发展，空间复杂度的问题得到解决，本篇主要讲述时间复杂度与大O渐进表示法。
🌈个人主页：是店小二呀
🌈C语言笔记专栏：C语言笔记
🌈C++笔记专栏： C++笔记
🌈初阶数据结构笔记专栏： 初阶数据结构笔记
🌈喜欢的诗句:无人扶我青云志 我自踏雪至山巅
文章目录 一、算法效率1.1 算法的复杂度 二、时间复杂度与空间复杂度2.1 时间复杂度2.1.1 时间复杂度的概念 2.2 大O的渐进表示法 2.3 空间复杂度 三、常见复杂度对比 一、算法效率 如下斐波那契数列的递归实现方式非常简洁，但是简洁一定好的吗？单纯通过代码的长度去衡量算法效率是不准确的。
long long Fib(int N) { if(N &lt; 3) return 1; return Fib(N-1) + Fib(N-2); } 1.1 算法的复杂度 算法是编写成可执行程序后，运行时需要消耗时间资源和空间资源。因此衡量一个算法的好坏，一般是从时间和空间两个维度去考量，也是我们常说的时间复杂度和空间复杂度。
时间复杂度:衡量算法的运行快慢空间复杂度:衡量算法运行所需要的额外空间 二、时间复杂度与空间复杂度 在计算机发展的早期，计算机的存储容量很小，所以对空间复杂度是很在乎，但是经过计算机行业的迅速发展，计算机的存储容量已经达到了很高的程度，所以如今不需要再特别关注一个算法的空间复杂度
2.1 时间复杂度 2.1.1 时间复杂度的概念 在计算机科学中，算法的时间复杂度是一个函数，他定量描述了该算法的运行时间。一个算法执行所消耗的时间，从理论上说，是不能算出来的，只有你把你的程序放在机器上跑起来，才能知道。但是我们需要每个算法都上机测试吗？是可以都上机测试，但是这很麻烦，所以才有了时间复杂度这个分析方式。一个算法所花费的时间与其中语句的执行次数成正比算法中的基本操作的执行次数，为算法的时间复杂度
即:找到某条基本语句与问题规模N之间的数学表达式，就是算出了算法的时间复杂度。通过例子更好地说明。
void Func1(int N) { int count = 0; for (int i = 0; i &lt; N; ++i) { for (int j = 0; j &lt; N; ++j) { ++count; } } for (int k = 0; k &lt; 2 * N; ++k) { ++count; } int M = 10; while (M--) { ++count; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11a312ece68849508614c214cc865075/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5258acf3d18712cf01a73d57aed5801f/" rel="bookmark">
			GPT带我学-设计模式14-工厂模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 工厂模式（Factory Pattern）是一种常用的创建型设计模式，也叫做工厂方法模式（Factory Method Pattern），它提供了一种创建对象的最佳方式。在工厂模式中，我们不再直接通过 new 来创建对象，而是通过一个工厂类来间接地创建对象。主要包含以下几个角色：
抽象产品（Product）：定义产品的接口或抽象类，具体产品由其子类实现。
具体产品（Concrete Product）：实现抽象产品接口的具体类，是被创建的对象。
抽象工厂（Factory）：提供创建产品对象的接口或抽象类，具体工厂由其子类实现。
具体工厂（Concrete Factory）：实现抽象工厂接口的具体类，具有生产不同具体产品的能力。
使用工厂模式能够将对象的创建和使用分离，可以降低系统的耦合度，提高系统的可扩展性和可维护性。常见的应用场景包括日志记录器、数据库访问、窗口创建等。
类型 工厂模式通常分为三种类型：
简单工厂模式（Simple Factory Pattern）：又称静态工厂方法模式，它由一个工厂类根据传入的参数决定创建出哪一种产品类的实例。简单工厂模式适用于产品种类较少且不经常变化的情况。
工厂方法模式（Factory Method Pattern）：是针对简单工厂模式缺点而产生的。在工厂方法模式中，每个具体产品都对应一个具体工厂，每个具体工厂只能创建一个具体产品对象，但是可以通过添加新的具体工厂来创建新的具体产品。
抽象工厂模式（Abstract Factory Pattern）：又称工具箱模式，提供一个创建一系列相关或相互依赖对象的接口，无需指定它们具体的类。抽象工厂模式适用于产品族和产品等级结构比较复杂的情况。
示例 场景，根据组织orgId，生成不同的文件夹路径。
简单工厂模式 好的，我可以为您提供一个基于简单工厂模式的实现，具体如下：
首先，我们需要定义抽象产品类 AbstractFolder ，用于描述文件夹的基本属性和功能。本例中，我们只需要使用其中的 getFolderPath() 方法即可。
public abstract class AbstractFolder { public abstract String getFolderPath(String orgId); } 接下来，我们需要创建两个具体产品类 DepartmentFolder 和 EmployeeFolder ，它们分别代表组织机构的部门文件夹和员工文件夹，两个类都要实现 getFolderPath() 方法。
public class DepartmentFolder extends AbstractFolder { @Override public String getFolderPath(String orgId) { return "organizations/" + orgId + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5258acf3d18712cf01a73d57aed5801f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/738f7573da923c8e7922ea2a314c2aad/" rel="bookmark">
			【区块链 &#43; 智慧政务】广州市黄埔区企业链上服务平台 | FISCO BCOS应用案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		黄浦区企业办事人在办理政企相关事务时，经常面临以下问题：需重复核验身份、填写信息重复提交材料；对黄 埔区推行的“告知承诺制审批服务”等信用办事模式不了解、不清晰，以及“告知承诺制审批服务”流程不方便、 后续监管不完善。
在广州市黄埔区政务服务数据管理局指导下，广州智投链码科技有限公司采用国产开源联盟链底层平台 FISCO BCOS，推出黄埔区企业链上服务平台，利用区块链技术，为企业提供可靠可信的“电子档案袋”，补齐当前信用 办事模式的短板，并实现对信用办事服务的推广。
该平台的总体框架设计分为四个层级：用户层、应用层、基础支撑层和相关外部系统。
用户层：依托穗好办“企业链上服务”相关应用为入口，可访问黄埔特色专区区块链应用服务。
应用层：为企业用户提供可信认证、电子印章、电子合同、电子档案等区块链特色服务。
基础支撑层：搭建黄埔公共联盟链，建设区块链 BaaS 平台、区块链管理平台和区块链浏览器，提供区块链基 础支撑。
相关外部系统：主要包括对接公共信用信息系统、统一受理审批系统等。
平台围绕广州市国家区块链创新应用综合性试点工作的部署要求，集区块链 + 可信认证、数字证书、数字建档和 全链数据存证为一体，创建“区块链可信 +”的企业链上服务体系，提供企业专属链上空间，提供亮码办事、信用 共享、智能秒批，承诺审批、政策兑现等 5 种办事能力，服务企业全生命周期的数据上链存证和建档管理，实现 数据可追溯。
平台基于区块链可信认证，结合广州“办事码”，开发建设区块链的亮码办事功能，纳入黄埔区政务服务中心的 实际业务办事场景中，为企业提供便捷的“最多跑一次”政务服务；结合符合告知承诺审批的涉企经营许可事项， 实现链上承诺和“即报即批”；基于区块链数据共享，优化政府服务办事流程，实现政务数据上链管理，取得了 良好的成效：
一是建立可信体系，降低取信成本。基于区块链信用管理技术，开发建设企业链上服务平台的信用共享功能，实 现涉企信用数据“一次归集、多方共享、高效可信”，赋予企业区块链可信身份标识码，对亮码办事、信用共享、 承诺审批、不见面线上审批等相关办事数据进行上链存证，实现数据可追溯，关联企业信用档案，有效降低政府 与企业、企业与企业之间的信任风险及取信成本。
二是再造政务服务流程，实现“链上通办”。依托可靠、可信、可用的“企业链上保险箱”功能，赋能跨机构、跨 部门、跨层级的数据互通与业务协作，实现 200 多项政务事项精简办理。通过即时调取申办材料，免去行政审批 窗口人员的身份核验、纸质材料扫描上传等步骤，有效提高办事效率。基于区块链数字签名技术，在线随时、随地、 随手快速签章办事材料，为区内企业切实提供更好的“指尖办”政务服务体验。
三是构建企业画像，促进供需对接。基于区块链可存证可追溯特点，综合可信身份、数字资产流转、企业信用及档案、 贸易往来等信息，精准绘制企业信用画像，增强企业互信力度，优化企业商业决策及合作方向，有效促成企业之 间供需精准对接。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbe372801115dd8bc34f601ebb6b0fc8/" rel="bookmark">
			【完结】LeetCode 热题 HOT 100分类&#43;题解&#43;代码详尽指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
LeetCode 热题 100
前言
Leetcode Top100题目和答案-哈希
Leetcode Top100题目和答案-双指针篇
Leetcode Top100题目和答案-滑动窗口篇
Leetcode Top100题目和答案-子串篇
Leetcode Top100题目和答案-普通数组篇
Leetcode Top100题目和答案-矩阵篇
Leetcode Top100题目和答案-链表篇
Leetcode Top100题目和答案-二叉树篇
Leetcode Top100题目和答案-图论
Leetcode Top100题目和答案-回溯篇
Leetcode Top100题目和答案-二分查找篇
Leetcode Top100题目和答案--栈篇
Leetcode Top100题目和答案--堆篇
Leetcode Top100题目和答案-贪心算法篇
Leetcode Top100题目和答案-动态规划篇
Leetcode Top100题目和答案-多维动态规划篇
Leetcode Top100题目和答案--技巧篇
LeetCode 热题 100 前言 算法，被誉为程序员的内功心法，其重要性不言而喻。不仅是技术面试中的关键考察点，帮助无数开发者赢得心仪的工作机会，更是提升逻辑思考与核心编程技能的磨刀石。
作为一名长期活跃于LeetCode平台的用户，我在此分享一些心得与体会，为正在算法修炼道路上探索的你提供指引，避免不必要的弯路，加速成长的步伐。
以下是【完结】LeetCode 热题 HOT 100分类+题解+代码详尽指南 链接，只需关注这一篇即可享受完结版 LeetCode 热题 100，每个主题均有详尽的代码注释及解题思路~
主题题目难度链接哈希两数之和简单 Leetcode Top100题目和答案-哈希 字母异位词分组中等最长连续序列中等双指针移动零简单 Leetcode Top100题目和答案-双指针篇 盛最多水的容器中等三数之和中等接雨水困难滑动窗口无重复字符的最长子串中等 Leetcode Top100题目和答案-滑动窗口篇 找到字符串中所有字母异位词中等 子串
和为 K 的子数组中等 Leetcode Top100题目和答案-子串篇 滑动窗口最大值困难最小覆盖子串困难普通数组最大子数组和中等 Leetcode Top100题目和答案-普通数组篇 合并区间中等轮转数组中等除自身以外数组的乘积中等缺失的第一个正数困难矩阵矩阵置零中等 Leetcode Top100题目和答案-矩阵篇 螺旋矩阵中等旋转图像中等搜索二维矩阵 II中等链表相交链表简单 Leetcode Top100题目和答案-链表篇 反转链表简单回文链表简单环形链表简单环形链表 II中等合并两个有序链表简单两数相加中等删除链表的倒数第 N 个结点中等两两交换链表中的节点中等K 个一组翻转链表困难随机链表的复制中等排序链表中等合并 K 个升序链表困难LRU 缓存中等二叉树二叉树的中序遍历简单 Leetcode Top100题目和答案-二叉树篇 二叉树的最大深度简单翻转二叉树简单对称二叉树简单二叉树的直径简单二叉树的层序遍历中等将有序数组转换为二叉搜索树简单验证二叉搜索树中等二叉搜索树中第K小的元素中等二叉树的右视图中等二叉树展开为链表中等从前序与中序遍历序列构造二叉树中等路径总和 III中等二叉树的最近公共祖先中等二叉树中的最大路径和困难图论岛屿数量中等 Leetcode Top100题目和答案-图论 腐烂的橘子中等课程表中等实现 Trie (前缀树)中等回溯全排列中等 Leetcode Top100题目和答案-回溯篇 子集中等电话号码的字母组合中等组合总和中等括号生成中等单词搜索中等分割回文串中等N 皇后困难二分查找搜索插入位置简单 Leetcode Top100题目和答案-二分查找篇 搜索二维矩阵中等在排序数组中查找元素的第一个和最后一个位置中等搜索旋转排序数组中等寻找旋转排序数组中的最小值中等寻找两个正序数组的中位数困难栈有效的括号简单 Leetcode Top100题目和答案--栈篇 最小栈中等字符串解码中等每日温度中等柱状图中最大的矩形困难堆数组中的第K个最大元素中等 Leetcode Top100题目和答案--堆篇 前 K 个高频元素中等数据流的中位数困难贪心算法买卖股票的最佳时机简单 Leetcode Top100题目和答案-贪心算法篇 跳跃游戏中等跳跃游戏 II中等划分字母区间中等动态规划爬楼梯简单 Leetcode Top100题目和答案-动态规划篇 杨辉三角简单打家劫舍中等完全平方数中等零钱兑换中等单词拆分中等最长递增子序列中等乘积最大子数组中等分割等和子集中等最长有效括号困难多维动态规划不同路径中等 Leetcode Top100题目和答案-多维动态规划篇 最小路径和中等最长回文子串中等最长公共子序列中等编辑距离中等技巧只出现一次的数字简单 Leetcode Top100题目和答案--技巧篇 多数元素简单颜色分类中等下一个排列中等寻找重复数中等 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16fdb8858e5049cfb923d6d1f1ad5921/" rel="bookmark">
			攻防世界(PHP过滤器过滤)file_include
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转换过滤器官方文档：https://www.php.net/manual/zh/filters.convert.php#filters.convert.iconv
这道题因为convert.base64-encode被过滤掉了，所以使用convert.iconv.*过滤器
在激活 iconv 的前提下可以使用 convert.iconv.* 压缩过滤器， 等同于用 iconv() 处理所有的流数据。 该过滤器不支持参数，但可使用输入/输出的编码名称，组成过滤器名称，比如 convert.iconv.&lt;input-encoding&gt;.&lt;output-encoding&gt; 或 convert.iconv.&lt;input-encoding&gt;/&lt;output-encoding&gt; （两种写法的语义都相同）。
直接上脚本爆破出合适的编码：
import requests in_encodings = ['UCS-4*', 'UCS-4BE', 'UCS-4LE*', 'UCS-2', 'UCS-2BE', 'UCS-2LE', 'UTF-32*', 'UTF-32BE*', 'UTF-32LE*', 'UTF-16*', 'UTF-16BE*', 'UTF-16LE*', 'UTF-7', 'UTF7-IMAP', 'UTF-8*', 'ASCII*', 'EUC-JP*', 'SJIS*', 'eucJP-win*', 'SJIS-win*', 'ISO-2022-JP', 'ISO-2022-JP-MS', 'CP932', 'CP51932', 'SJIS-mac', 'SJIS-Mobile#DOCOMO', 'SJIS-Mobile#KDDI', 'SJIS-Mobile#SOFTBANK', 'UTF-8-Mobile#DOCOMO', 'UTF-8-Mobile#KDDI-A', 'UTF-8-Mobile#KDDI-B', 'UTF-8-Mobile#SOFTBANK', 'ISO-2022-JP-MOBILE#KDDI', 'JIS', 'JIS-ms', 'CP50220', 'CP50220raw', 'CP50221', 'CP50222', 'ISO-8859-1*', 'ISO-8859-2*', 'ISO-8859-3*', 'ISO-8859-4*', 'ISO-8859-5*', 'ISO-8859-6*', 'ISO-8859-7*', 'ISO-8859-8*', 'ISO-8859-9*', 'ISO-8859-10*', 'ISO-8859-13*', 'ISO-8859-14*', 'ISO-8859-15*', 'ISO-8859-16*', 'byte2be', 'byte2le', 'byte4be', 'byte4le', 'BASE64', 'HTML-ENTITIES', '7bit', '8bit', 'EUC-CN*', 'CP936', 'GB18030', 'HZ', 'EUC-TW*', 'CP950', 'BIG-5*', "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16fdb8858e5049cfb923d6d1f1ad5921/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/872599b8de08fd6373adabffb147d133/" rel="bookmark">
			大数据基础：Hadoop之Yarn重点架构原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
Hadoop之Yarn重点架构原理
一、Yarn介绍
二、Yarn架构
三、Yarn任务运行流程
四、Yarn三种资源调度器特点及使用场景
Hadoop之Yarn重点架构原理 一、Yarn介绍 Apache Hadoop Yarn(Yet Another Reasource Negotiator，另一种资源协调者)是Hadoop2.x版本后使用的资源管理器，可以为上层应用提供统一的资源管理平台。
二、Yarn架构 Yarn主要由ResourceManager、NodeManager、ApplicationMaster、Container组成。
ResourceManager
ResourceManager是Yarn集群中的中央管理器，负责整个集群的资源分配与调度。ResourceManager负责监控NodeManager节点状态、汇集集群资源，处理Client提交任务的资源请求，为每个Application启动AppliationMaster并监控。
NodeManager
NodeManager负责管理每个节点上的资源（如：内存、CPU等）并向ResourceManager报告。当ResourceManager向NodeManager分配一个容器（Container）时，NodeManager负责启动该容器并监控容器运行，此外，NodeManager还会接收AplicationMaster命令为每个Application启动容器（Container）。
ApplicationMaster
每个运行在Yarn中的应用程序都会启动一个对应的ApplicationMaster，其负责与ResourceManager申请资源及管理应用程序任务。ApplicationMaster本质上也是一个容器，由ResourceManager进行资源调度并由NodeManager启动，ApplicationMaster启动后会向ResourceManager申请资源运行应用程序，ResourceManager分配容器资源后，ApplicationMaster会连接对应NodeManager通知启动Container并管理运行在Container上的任务。
Container
Container 容器是Yarn中的基本执行单元，用于运行应用程序的任务，它是一个虚拟环境，包含应用程序代码、依赖项及运行所需资源（内存、CPU、磁盘、网络）。每个容器都由ResourceManager分配给ApplicationMaster，并由NodeManager在相应的节点上启动和管理。容器的资源使用情况由NodeManager监控，并在必要时向ResourceManager报告。
Yarn核心就是将MR1中JobTracker的资源管理和任务调度两个功能分开，分别由ResourceManager和ApplicationMaster进程实现，ResourceManager负责整个集群的资源管理和调度;ApplicationMaster负责应用程序任务调度、任务监控和容错等。
三、Yarn任务运行流程 在客户端向Yarn中提交MR 任务，首先会将MR任务资源（Split、资源配置、Jar包信息）上传到HDFS中。
客户端向ResourceManager申请启动ApplicationMaster。
ResourceManager会选择一台相对不忙的NodeManager节点，通知该节点启动ApplicationMaster(Container)。
ApplicationMaster启动之后，会从HDFS中下载MR任务资源信息到本地，然后向ResourceManager申请资源用于启动MR Task。
ResourceManager返回给ApplicationMaster资源清单。
ApplicationMaster进而通知对应的NodeManager启动Container
Container启动之后会反向注册到ApplicationMaster中。
ApplicationMaster 将Task任务发送到Container 运行，Task任务执行的就是我们写的代码业务逻辑。
四、Yarn三种资源调度器特点及使用场景 FIFO调度器（First-In-Fist-Out Scheduler），Yarn中最简单的调度器。FIFO Scheduler 会将提交的应用程序按提交顺序放入一个先进先出的队列中，进行资源分配时，先给队列中最头上的应用分配资源，待头上的应用资源需求满足后再给下一个应用分配资源，以此类推。这种调度器调度资源时，有可能某个资源需求大的应用占用所有集群资源，从而导致其他的应用被阻塞。
Capacity调度器（Capacity Schduler）是Yarn中默认配置的资源调度器，允许多租户安全地共享一个大型集群。Capacity调度器中，支持配置多个资源队列，可以为每个资源队列指定最低、最高可使用的资源比例，在进行资源分配时，优先将空闲资源分配给“实际资源/预算资源”比值最低的队列，每个资源队列内部采用FIFO调度策略。
Fair调度器（Fair Scheduler）是一个将Yarn资源公平的分配给各个Application的资源调度方式，这种调度方式可以使所有Application随着时间的流逝可以获取相等的资源份额，其设计目标就是根据定义的参数为所有的Application分配公平的资源。
Yarn中FIFO、Capacity、Fair三种资源调度器区别对比如下：
Yarn资源调度器特点适用场景FIFO调度器 1、简单易懂，无需额外配置。
2、应用按照提交的先后顺序（先进先出）运行。
3、不适合共享集群，每个应用必须等待直到轮到自己运行。
非共享集群，对任务执行顺序要求不高的场景。生产环境一般不用。 Capacity调度器
（开源Yarn默认使用）
1、允许多个组织共享集群资源，每个组织拥有专门的队列。
2、支持队列的层次划分，以及队列资源的灵活配置。
3、可以限制队列的最大容量，缓解资源竞争。
共享集群的场景，多个组织或团队共享同一集群资源的情况。 Fair调度器
（CDH默认使用）
1、公平地为所有运行的应用分配资源，支持多个队列间的资源公平共享。
2、支持动态创建队列，并通过一套规则系统确定应用的放置位置。
3、支持资源的抢占功能，确保资源的公平分配。
1、 多个用户或组织在共享集群中需要公平地获得资源的场景。
2、 对队列级别的资源控制和细粒度调度策略要求较高的环境。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/872599b8de08fd6373adabffb147d133/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57daad0355fa6c8f682a5c76f29956ed/" rel="bookmark">
			linux命令更新-iostat 和 iotop
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iostat 和 iotop 是 Linux 系统中用于监控磁盘 I/O 活动的两个非常有用的工具。下面分别介绍它们的使用方法和一些运维场景案例。
iostat iostat 是一个系统监控工具，主要用于监控 CPU 使用率和磁盘 I/O 活动。它是 sysstat 包的一部分，因此在某些发行版中可能需要先安装 sysstat。
基本语法 iostat [options] [delay [count]] 参数 options：可选参数，用于指定要显示的信息。
delay：采样间隔（以秒为单位）。
count：采样次数。
常用选项 -c：显示 CPU 使用情况。
-d：显示磁盘设备的统计信息。
-k：以 KB/s 显示 I/O 速率。
-m：以 MB/s 显示 I/O 速率。
-x：显示额外的磁盘统计信息，如 %util（设备利用率）和 await（平均等待时间）。
-t：显示时间戳。
-N：显示设备名称。
示例 显示磁盘设备的统计信息，每 5 秒刷新一次，共显示 10 次：
iostat -d -k 5 10 显示 CPU 和磁盘的统计信息：
iostat -cd iotop iotop 类似于 top 命令，但专门用于监控进程级别的磁盘 I/O 活动。它显示了正在使用磁盘 I/O 的进程列表，按 I/O 使用情况排序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57daad0355fa6c8f682a5c76f29956ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e430d174f0213fdc9af39ee24fe2165a/" rel="bookmark">
			硅纪元视角 | OpenAI封锁了个寂寞，微软表态其Azure OpenAI服务不受影响
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数字化浪潮的推动下，人工智能（AI）正成为塑造未来的关键力量。硅纪元视角栏目紧跟AI科技的最新发展，捕捉行业动态；提供深入的新闻解读，助您洞悉技术背后的逻辑；汇聚行业专家的见解，分享独到的视角和思考；精选对您有价值的信息，帮助您在AI时代中把握机遇。
1 分钟速览新闻 AMD豪掷6.65亿美元收购Silo AI，强势挑战英伟达AI霸主地位
AI驱动金属创新，「创材深造」赢得新能源车企订单
风靡全美！反AI产品9天用户突破80万，强势跻身社交APP前五
OpenAI封锁了个寂寞，微软表态其Azure OpenAI服务不受影响
人人可做提示工程师，Claude一键搞定Prompt生成与评估
全球AI新闻
一、AMD豪掷6.65亿美元收购Silo AI，强势挑战英伟达AI霸主地位
资讯概要
AMD 宣布将以 6.65 亿美元收购芬兰 AI 初创公司 Silo AI，旨在提升其 AI 芯片能力，与英伟达竞争。此次收购将改进 AMD 驱动的 AI 模型开发和部署，并增强其软件开发能力。Silo AI 位于芬兰赫尔辛基，专注于 AI 解决方案，客户包括飞利浦、劳斯莱斯等知名企业。Silo AI 的 CEO Peter Sarlin 将继续领导该部门，成为 AMD AI 集团的一部分。交易预计于 2024 年下半年完成。这是 AMD 在 AI 领域一系列扩张举措中的最新一步，去年 AMD 也收购了 Mipsology 和 Nod.ai，并向多家 AI 公司投资了超过 1.25 亿美元。
硅纪元视角
AMD以6.65亿美元收购芬兰AI初创公司Silo AI，旨在增强其AI芯片能力并与英伟达竞争。这一举措显著提升了AMD在AI模型开发和部署方面的能力，特别是结合Silo AI在AI解决方案领域的专长，可以为企业提供更高效、精准的AI应用。从实际应用角度看，医疗公司如飞利浦可以借助改进的AI技术优化诊断和治疗流程，提升医疗服务质量；而劳斯莱斯等制造业巨头则能通过先进的AI系统优化生产线，提高产品质量和生产效率。此次收购不仅加强了AMD的技术能力，还为其在多个行业的AI应用扩展提供了坚实的基础，进一步推动AI技术的普及和深化应用。
二、AI驱动金属创新，「创材深造」赢得新能源车企订单
资讯概要
创材深造通过利用人工智能技术，大大缩短了金属材料的研发周期，并成功获得了国内头部新能源车企的订单。这一突破不仅展示了创材深造在技术创新上的领先地位，也为新能源车企提供了更优质的金属材料，助力其在激烈的市场竞争中占据优势。
硅纪元视角
通过引入人工智能技术，创材深造大大缩短了金属材料的研发周期，并获得了国内顶尖新能源车企的订单。这一应用显著提高了研发效率和材料性能，使企业能更快速地响应市场需求。例如，AI技术在材料成分优化和性能预测方面的应用，帮助研发人员更快找到最佳配方和工艺，大幅降低试验成本和时间。同时，这些高性能材料提高了新能源车的整体质量和安全性，增强了车企的市场竞争力。这一突破不仅展示了创材深造在技术创新方面的领先地位，也为新能源车企提供了更优质的金属材料，助力其在激烈的市场竞争中占据优势。
三、风靡全美！反AI产品9天用户突破80万，强势跻身社交APP前五
资讯概要
近日，一款名为Gas的社交应用在美国爆火，短短9天用户暴增80万，一举跻身美国社交应用Top 5。这款应用的独特之处在于其反AI设计，主打用户匿名交流，避免了大量使用AI算法和数据追踪。这种创新的方式吸引了大量年轻用户，尤其是那些对隐私和真实互动有较高需求的人群。Gas的成功显示了市场对保护隐私的强烈需求，反映了用户对传统社交媒体过度依赖AI技术的不满。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e430d174f0213fdc9af39ee24fe2165a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/060b3a6321563292bb6d386ed7d96ce6/" rel="bookmark">
			老照片修复转视频彻底火了，通过AI绘画&#43;视频技术，只需三步超简单出片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 大家好，我是程序员晓晓
最近网上突然爆火的老照片转成视频不知道大家有没有刷到。
这些都是通过AI绘画技术+AI视频图生视频技术完成的，先来看一下网上的成片吧。
这一内容为什么会突然火起来呢？大概率是抓住了大家心里的一份情怀吧。
大家可以将家里面以前的黑白老照片，或者已故亲人的照片找出来制作成视频，重温一下与家人重聚的效果。
其实在今年2月份就有相关的消息了，知名音乐人包小柏通过用AI“复活”了女儿给自己的妻子唱了生日歌，当时各大媒体平台播放量就已经火了。
现在随着AI技术的不断更新，现在这一技术越来越成熟，简单几步就可以轻松完成。
这类的玩法非常多，很多小伙伴已经在这一周通过这项爆款小产品做成了商品进行的售卖，收益也很客观。
接下来就给大家介绍下具体的操作步骤。
如果对于SD绘画工具操作不是熟悉的小伙伴可以参考我之前发布的教程2024最新超强AI绘画Stable Diffusion整合包安装教程，零基础入门必备！
一、高清修复
对于清晰度不高的老照片来说，可以通过SD的高清修复功能先将照片的清晰度提升。（当然对于清晰度较高的图片来说可以忽略这一步）
根据下图的选项对应选择即可。
在指定分辨率缩放中宽高比例最好根据原始图片的宽高来设置。
可以通过图片属性中的详细信息获取到对应的宽高值。
最后点击生成就可以了。
二、黑白上色
在有了清晰的黑白照片之后，可以通过SD对照片进行上色。
①模型可以随机选择一个真实场景的模型就行
②正向提示词
③反向提示词
④采样方法：DPM++2M
⑤Karras
⑥迭代步数：30
⑦宽高同样填写与原图相同
接着需要配置ControlNet插件内容
①上传需要上色的原图
②预处理器：recolor_luminance
③模型：ioclab_sd15_recolor
以上配置完成之后，点击生成就可以了。
三、视频制作
这里是通过国产视频产品可灵AI完成，操作更加简单，只需要下列5步就可以了。（不过目前可灵AI的账号申请需要等待审核，快速通过方式在后面也有说明）
tips：生成视频时可以同时多执行几个任务，毕竟有时候生成的效果就是抽卡，不一定一次就能得到理想的效果。
注：可灵内测账号快速注册方法
①下载快影APP。快影APP-&gt;AI创作-&gt;AI生视频（申请体验）-填写信息（粉丝量不是主要问题，可以多手机号进行注册）
②问卷申请，地址：https://ppg.viviv.com/s/Xku4zYHe
每日根据以上填写信息优先开放申请权限
这样视频就生成好啦，目前每个视频免费的额度只有5秒。
感兴趣的小伙伴，赠送全套AIGC学习资料，包含AI绘画、AI人工智能等前沿科技教程和软件工具，具体看这里。
AIGC技术的未来发展前景广阔，随着人工智能技术的不断发展，AIGC技术也将不断提高。未来，AIGC技术将在游戏和计算领域得到更广泛的应用，使游戏和计算系统具有更高效、更智能、更灵活的特性。同时，AIGC技术也将与人工智能技术紧密结合，在更多的领域得到广泛应用，对程序员来说影响至关重要。未来，AIGC技术将继续得到提高，同时也将与人工智能技术紧密结合，在更多的领域得到广泛应用。
一、AIGC所有方向的学习路线
AIGC所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照下面的知识点去找对应的学习资源，保证自己学得较为全面。
二、AIGC必备工具
工具都帮大家整理好了，安装就可直接上手！
三、最新AIGC学习笔记
当我学到一定基础，有自己的理解能力的时候，会去阅读一些前辈整理的书籍或者手写的笔记资料，这些笔记详细记载了他们对一些技术点的理解，这些理解是比较独到，可以学到不一样的思路。
四、AIGC视频教程合集
观看全面零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
五、实战案例
纸上得来终觉浅，要学会跟着视频一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
若有侵权，请联系删除 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01b23856e896dcb2125e56ac285568d4/" rel="bookmark">
			【区块链 &#43; 智慧政务】一体化政务数据底座平台 | FISCO BCOS应用案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为进一步贯彻落实《全国一体化政务大数据体系建设方案》、《中共中央国务院关于构建数据基础制度更好发挥 数据要素作用的意见》精神，一体化政务数据底座平台结合相应城市的数字经济现状基础、当前任务及未来发展 战略，规划建设数据底座，持续完善数字基础设施，形成一体化政务数据基础设施。
数据底座平台旨在建设一体化政务大数据系统，实施数据治理服务，主要包含数据开发平台与数据交易平台。
数据交易平台通过公共数据登记授权存证模块、数据产品运营交易管理模块、数据流通交易监管模块、数据要 素流通可视化模块，满足数据资源登记确权、数据产品登记确权、数据交易服务、交易运营管理、流通交易监管 等需求，以交易运营业务为核心，基于本期服务内容提供运营管理工作平台和需方工作平台，实现以交易运营方 为主导的数据产品上架、交易、交付等管理服务工作，其余角色工作平台可在开展运营工作后按需进行增资扩建， 同时在主管单位层面建立起相关数据监管机制，实现全流程监管。公共数据登记授权存证平台在业务上对数据及 数据产品的权属关系进行确认和授予，在技术上基于区块链对公共数据进行登记、授权记录进行存储存证，确保 数据的来源权属方和内容的可信度。
数据开发平台支持多计算引擎混合编排，实现 " 数 + 智 " 融合的调度开发，致力于解决数据处理流程中错综复杂的依赖关系，提供实时计算、离线分析、模型训练管理等能力，实现统一开发、测试、发布、运维全流程的管理， 包括数据开发工具系统、隐私计算、区块链系统、数据沙箱等功能。通过数据开发平台的数据开发工具、区块链、 隐私计算、数据沙箱，项目提供数据可用而不可见的分析计算环境，消除数据安全和隐私泄漏的顾虑，解决数据 流通安全问题，同时通过区块链实现数据确权、验证、授权和管理，保障数据的真实性、完整性和不可篡改性， 实现数据的融合。
数据开发平台中的区块链系统由区块链底层节点和区块链 BaaS 平台组成，为各个业务单元提供环境快速部署、 数据便捷上链、平台安心运维的区块链服务，助力建设区块链 + 业务应用生态。借助区块链去中心化、不可篡改 等特性，结合分布式计算、智能合约开发、区块链监控运维、联盟链管理、区块链浏览等一系列服务，降低区块 链应用研发技术门槛，构建区块链应用基础底座，加速区块链业务落地。
该平台一期以医疗数据先行先试，探索项目完备性以及运营管理体系建设。平台对医疗行业数据进行了汇聚、治理、 融合及共享，聚焦数字产业化、产业数字化、数据价值化、治理数字化协同发展，通过引进域外企业、培育本地企业、 壮大现有企业，在盘活医疗数据产业生态的基础上，进一步激活城市数据要素潜能，推动数据要素市场化配置改革， 增强经济发展新动能，并产生两个深层次的效益：
1. 统一规划建设，实现集聚集约。数据底座项目通过统筹规划、开发利用共享信息资源，将有效节约建设投入， 降低建设成本。项目建设统一规划、共同开发，协同服务，充分依托区域现有资源和能力，既可以盘活区域数据 资源，提高信息利用率和时效性，又可以通过支撑应用服务，为企业业务系统的建设提供宏观指导；同时，为后 续各类系统扩展提供开放接口，有助于降低项目后续投入，达到降低整体资金投入的目的。
2. 推动信息资源共享，强化部门业务协同。该平台的建设，有助于明确数据共享推进的方向和内容，根据应用需 求确定共享数据的共享频度、采集范围和抽取粒度，促使各部门持续共享，实现信息的互联互通，还将提升各部 门协作效率，促进资源的有效分配，进而提供全面、便捷的系统数据资源共享交换服务功能；同时，各级决策者 能够立足全市信息资源，及时、准确获取数据，多角度、全方位地做决策，有助于制定更科学、更有效的方针政策。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/168/">«</a>
	<span class="pagination__item pagination__item--current">169/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/170/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>