<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa83349768f12ef8fda3a71b07aeba52/" rel="bookmark">
			Echart图表 之 X轴（xAxis）与 Y轴（yAxis）配置项大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原博主链接
xAxis与yAxis中的配置项
xAxis: { id: '', show: true, //是否显示x轴 gridIndex: 0, //轴所在grid索引，默认位于第一个grid alignTicks: false, //在多个轴为数值轴的时候，可以开启该配置项自动对齐刻度。只对'value'和'log'类型的轴有效 position: 'top', //轴的位置（top/bottom） offset: 0, //轴相对于默认位置的偏移，在相同的position上有多个轴时有用 type: 'category', //坐标轴类型，值category/value，与y轴呼应，若x轴配置category则y轴配置value name: '', //坐标轴名称 nameLocation: 'end', //坐标轴名称显示位置，可选值start/middle[或者center]/end nameTextStyle: {}, //一般样式也很少直接修改且内容过多待更新... ... nameGap: 15, //坐标轴名称与轴线间距离 nameRotate: 10, //坐标轴名字旋转，角度值 inverse: false, //是否是反向坐标轴 boundaryGap: ['20%', '20%'], // 坐标轴两边留白策略，也可以使用布尔值，true居中 min: '', //刻度最小值 max: '', //刻度最大值 scale: false, //只在数值轴中type: 'value'有效, 设置min和max后无效。是否是脱离 0 值比例。设置成true后坐标刻度不会强制包含零刻度。在双数值轴的散点图中较有用 splitNumber: 5, //坐标轴的分割段数（预估值） minInterval: 0, //自动计算坐标轴最小间隔，例：设置成1，刻度没有小数 maxInterval: '', //自动计算坐标轴最大间隔 axisLine: { show: true, // 是否显示坐标轴轴线 symbol: ['none', 'arrow'], // 轴线两端箭头，两个值，none表示没有箭头，arrow表示有箭头 symbolSize: [10, 15], // 轴线两端箭头大小，数值一表示宽度，数值二表示高度 lineStyle: { color: '#333', // 坐标轴线线的颜色 width: '5', // 坐标轴线线宽 type: 'solid', // 坐标轴线线的类型（solid实线类型；dashed虚线类型；dotted点状类型） }, }, axisTick: { show: true, // 是否显示坐标轴刻度 inside: true, // 坐标轴刻度是否朝内，默认朝外 length: 5, //坐标轴刻度的长度 lineStyle: { color: '#FFF', //刻度线的颜色 width: 10, //坐标轴刻度线宽 type: 'solid', //坐标轴线线的类型（solid实线类型；dashed虚线类型；dotted点状类型） }, }, axisLabel: { show: true, //是否显示刻度标签 interval: '0', //坐标轴刻度标签的显示间隔，在类目轴中有效.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa83349768f12ef8fda3a71b07aeba52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/893280c0bb538dc72915630988ab285d/" rel="bookmark">
			20分钟，使用Amazon SageMaker快速搭建属于自己的AIGC应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		真火！
作为最近一段时间人工智能领域内的顶流之一，AIGC（AI-Generated Content）早已火爆出圈，频登各大互联网平台热搜。
cite: 微软亚洲研究院官方微博
这段时间以来，基于深度学习的内容生成在图像、视频、语音、音乐、文本等生成领域都取得了令人瞩目的成果，也越来越多的身边人在讨论AIGC。但你知道AIGC背后的有哪些技术支持吗？
实际上，最早引爆AIGC话题的是AI作图，它是以Stable Diffusion技术为基础实现的。以前，AI 作图还只是简单的风格迁移、头像生成、磨皮、P图等功能应用，直到Stable Diffusion模型的降临，AI 作图发生了质的变化，人们第一次见识到了生产力AI的力量：画家、设计师不用再绞尽脑汁思考色彩、构图，只要告诉 Stable Diffusion 模型自己想要什么，就能言出法随般地生成高质量图片。
那么我能不能自己实现一个以Stable Diffusion模型为基础的AIGC作画应用呢？
答案是可以的！最近我恰好受邀参与了亚马逊云科技【云上探索实验室】活动，利用Amazon的SageMaker平台搭建了自己的 AIGC 应用，整个过程只用了不到20分钟。
使用 Amazon SageMaker 基于Stable Diffusion模型搭建的AIGC应用
总体而言，在Amazon SageMaker上搭建AIGC应用的体验十分出色，不仅仅是流程清晰，简单易实现。使用者可以直接从Hugging Face上提取预训练的模型，参考Amazon提供的简明教程，使得SageMaker可以很容易地将模型转化为Web应用。
下面是一些图像生成的结果：
感觉还不错，现在我们就来复盘一些怎么利用亚马逊云服务使用Amazon SageMaker在20分钟内搭建一个属于自己的AIGC应用。
我将首先简单说明AIGC是什么以及讲解Stable Diffusion的技术原理。然后介绍Amazon SageMaker是做什么的。之后将基于Amazon SageMaker搭建AIGC应用的整体流程复盘一遍。最后对该应用进行测试和功能评价。
文章目录 1. 什么是Stable Diffusion？1.1. 人工智能自动生成内容：AIGC介绍1.2. Stable Diffusion原理解析 2. 什么是Amazon SageMaker？3. 通过Amazon SageMaker搭建基于Stable Diffusion模型的AIGC应用3.1. 创建Notebook3.2. 利用Hugging Face克隆模型3.3. 了解模型的超参数3.4. 配置和微调Stable Diffusion模型3.5. 部署和使用训练好的模型3.6. 清理资源3.7. 整体流程的视频介绍 4. 对Stable Diffusion模型的评估4.1. CPU和GPU对生成速度的影响4.2. 超参数对模型性能的影响 5. 总结5.1. 基于Amazon SageMaker搭建的AIGC应用的功能评价5.2. 对开发过程有帮助的产品文档汇总 1. 什么是Stable Diffusion？ 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/893280c0bb538dc72915630988ab285d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0476ae6765e99dd9653b8592c632f44/" rel="bookmark">
			宝塔面板安装配置MySQL，轻松管理数据库【公网远程访问】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1.Mysql服务安装2.创建数据库3.安装cpolar内网穿透4. 创建HTTP隧道映射mysql端口5.远程连接6.固定TCP地址6.1 保留一个固定的公网TCP端口地址6.2 配置固定公网TCP端口地址 前言 宝塔面板的简易操作性,使得运维难度降低,简化了Linux命令行进行繁琐的配置,下面简单几步,通过宝塔面板+cpolar即可快速搭建一个mysql数据库服务并且实现公网远程访问。
1.Mysql服务安装 我们打开宝塔面板,点击数据库,然后点击安装mysql服务,
选择极速安装即可,版本默认
然后等待安装完成
2.创建数据库 安装好后,修改一下root密码,这个root密码也是登陆mysql时候时输入的密码
修改后,我们测试添加数据库,宝塔面板提供可以直接在页面就可以创建一个mysql数据库,设置用户名和密码,访问权限设置为所有人,然后提交即可
提交成功我们可以看到列表中出现了一个数据库
然后我们在宝塔面板安全页面开放一个3306的端口
3.安装cpolar内网穿透 cpolar官网：https://www.cpolar.com/
打开宝塔终端命令窗口,使用cpolar一件安装脚本: curl -L https://www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash token认证 登录cpolar官网后台,点击左侧的验证，查看自己的认证token，之后将token贴在命令行里
cpolar authtoken xxxxxxx 向系统添加服务 sudo systemctl enable cpolar 启动cpolar服务 sudo systemctl start cpolar 在宝塔面板中选择安全.然后开放9200端口
然后局域网ip+:9200端口即可出现cpolar管理界面,然后使用官网注册的账号进行登陆,如没有注册可以点击下面账号免费注册
4. 创建HTTP隧道映射mysql端口 点击左侧仪表盘的隧道管理——创建隧道,由于mysql中默认的是3306端口，因此我们要来创建一条tcp隧道，指向3306端口：
隧道名称：可自定义，注意不要重复协议：tcp本地地址：3306域名类型：选择随机域名地区：选择China VIP 点击创建
创建成功后,打开在线隧道列表,查看公网tcp地址
5.远程连接 接下来我们使用数据库连接工具navicat进行测试连接,地址使用上面的公网地址,点击测试连接后表示成功.
6.固定TCP地址 由于以上创建的隧道是随机地址隧道,地址会在24小时内变化,为了使连接更加稳定,需要固tcp地址
需要注意，配置固定TCP端口地址需要将cpolar升级到专业版套餐或以上。
6.1 保留一个固定的公网TCP端口地址 登录cpolar官网后台，点击左侧的预留，选择保留的TCP地址。
地区：选择China VIP描述：即备注，可自定义填写 点击保留
地址保留成功后，系统会生成相应的固定公网地址，将其复制下来
6.2 配置固定公网TCP端口地址 再次登录cpolar web ui管理界面，点击左侧仪表盘的隧道管理&gt;&gt;隧道列表，找到上面创建的mysql隧道，点击右侧的编辑,
修改隧道信息，将保留成功的固定tcp地址配置到隧道中
端口类型：修改为固定tcp端口预留的tcp地址：填写保留成功的地址 点击更新
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0476ae6765e99dd9653b8592c632f44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbc9df1206dde9b0f769a48c353ca595/" rel="bookmark">
			Ubuntu 20.04 RTX 4090显卡 深度学习环境配置（Nvidia显卡驱动、CUDA11.6.0、cuDNN8.5）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu 20.04 RTX 4090显卡 深度学习环境配置（Nvidia显卡驱动、CUDA11.6.0、cuDNN8.5） 一、安装Nvidia显卡1.1 输入显卡型号查看支持显卡驱动的版本1.1.1 英伟达中国驱动官网1.1.2 输入显卡型号查询1.1.3 查看搜索结果 1.2 下载安装Nvidia1.2.1 方法一1.2.1 方法二 二、安装CUDA11.6.02.1 检测自己电脑GPU是否兼容CUDA（N卡支持）2.2 进入CUDA官网2.3 下载安装CUDA11.6.02.4 安装CUDA11.6.0后的配置2.5 利用测试CUDA的samples来测试cuda安装是否成功 三、安装cuDNN v8.5.0 (August 8th, 2022), for CUDA 11.x3.1 打开官网使用邮箱注册（我用的qq邮箱）3.2 下载 cuDNN v8.5.0 (August 8th, 2022), for CUDA 11.x3.3 安装 cuDNN v8.5.0 (August 8th, 2022), for CUDA 11.x3.4 验证安装 一、安装Nvidia显卡 参考文献：从零到一保姆级Ubuntu深度学习服务器环境配置教程
看文献中“三、 NVIDIA驱动安装”
安装NVIDIA驱动，这也是安装CUDA10.0及其对应版本的CuDNN和tensorflow的重要步骤。
1.1 输入显卡型号查看支持显卡驱动的版本 1.1.1 英伟达中国驱动官网 进入英伟达中国驱动官网
1.1.2 输入显卡型号查询 1.1.3 查看搜索结果 1.2 下载安装Nvidia 1.2.1 方法一 直接在Ubuntu系统中的soft updates中安装525-server（专有）版本
注意：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbc9df1206dde9b0f769a48c353ca595/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/314170057dd28849c3c26b3b5162406a/" rel="bookmark">
			Android Studio初学者实例：Fragment学习--仿美团外卖界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本次课程为Fragment为主题，课程的示例仿美团外卖界面，不同于底部导航栏的Fragment案例，此界面分为左侧切换与顶部切换。本文先是发布代码与效果，后续讲解将会在后续补充。先看看效果：
首先是布局文件代码：Activity布局：activity_main.xml：
首先父布局用的LinearLayout布局，并通过代码:android:orientation="vertical"来设置布局方向为垂直布局。界面分为顶部导航栏、左侧菜单栏、右侧菜单栏，由此分为三大部分子布局
分别用到了RelativeLayout、LinearLayout（左右布局放在一个LinearLayout，设置布局方向为水平即可）
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity" android:orientation="vertical"&gt; &lt;RelativeLayout android:layout_width="match_parent" android:layout_height="50dp" android:layout_marginBottom="4dp" android:gravity="center_vertical"&gt; &lt;TextView android:id="@+id/tv_order" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="25dp" android:layout_marginTop="4dp" android:textSize="16sp" android:text="点菜" /&gt; &lt;TextView android:id="@+id/tv_discuss" android:layout_toRightOf="@id/tv_order" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="25dp" android:layout_marginTop="4dp" android:textSize="16sp" android:text="评价" /&gt; &lt;TextView android:id="@+id/tv_business" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="25dp" android:layout_marginTop="4dp" android:layout_toRightOf="@id/tv_discuss" android:textSize="16sp" android:text="商家" /&gt; &lt;TextView android:layout_width="70dp" android:layout_height="30dp" android:layout_marginLeft="25dp" android:layout_marginTop="4dp" android:textSize="12sp" android:layout_alignParentRight="true" android:layout_marginRight="15dp" android:background="@drawable/friend_list" android:gravity="center" android:textColor="#ef842c" android:text="好友拼单" /&gt; &lt;/RelativeLayout&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="horizontal" &gt; &lt;fragment android:id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/314170057dd28849c3c26b3b5162406a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8fb0865b1f2c962e3080d280e8407d6/" rel="bookmark">
			4.2 图书借阅系统数据库设计 --MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文目录 前言一、背景和需求分析1.1 背景1.2 信息需求1.3 功能需求管理员学生 1.4 数据流图 二、概念结构设计1. 抽象出系统实体2. 局部E-R图2.1 学生 E-R图2.2 借阅证 E-R图2.3 图书 E-R图2.4 管理员 E-R图2.5 公告 E-R图2.6 申请 E-R图2.7 借阅 E-R图2.8 评论 E-R图2.9 收藏 E-R图 3. 全局E-R图 三、逻辑结构设计3.1 转换规则3.2 关系模式3.2.1 按转换规则分析3.2.2 实际转换结果 3.3 表结构 四、物理结构设计与实施4.1 创建数据库4.2 创建数据表4.3 初始化数据 五、具体业务分析5.1 录入图书5.2 学生注册 + 申请借阅证5.2.1 注册5.2.2 填写学生信息，申请借阅证 5.3 管理员审核借阅证通过5.4 搜索图书5.5 查看图书详情5.6 图书收藏 和 取消收藏5.6.1 收藏5.6.2 取消收藏 5.7 图书评论 和 审核评论5.7.1 评论5.7.2 审核评论 5.8 借阅 和 借阅审核5.8.1 借阅5.8.2 借阅审核5.8.3 归还 参考最后 前言 大家好，我是天罡gg，一个有十多年丰富经验的高级架构师，参与过很多系统的数据库设计，在数据库设计方面有相当丰富的经验。正赶上这篇实战专栏的数据库设计，所以今天让我们来一起做一下《图书借阅系统的数据库设计》，一篇既有理论知识，又能实战落地的数据库设计！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8fb0865b1f2c962e3080d280e8407d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bad5efe9e26af706f424f4921d5a372c/" rel="bookmark">
			Stable Diffusion Lora模型训练详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 介绍 通过Lora小模型可以控制很多特定场景的内容生成。
但是那些模型是别人训练好的，你肯定很好奇，我也想训练一个自己的专属模型（也叫炼丹～_～）。
甚至可以训练一个专属家庭版的模型（family model），非常有意思。
将自己的训练好的Lora模型放到stableDiffusion lora 目录中，同时配上美丽的封面图。
2. 模型训练步骤 2.1 训练环境搭建 WebUI或者Diffuser
https://github.com/AUTOMATIC1111/stable-diffusion-webui
Lora训练环境
https://github.com/kohya-ss/sd-scripts
2.2 数据准备 从网上爬取一些想要的角色图片，或者直接去截图。
这次我做的初春，找一些图片就行了，不需要很多，20张就可以，各个角度，全身，大头尽量都有些。
角色是这样子的，头上一定得有花，这个是角色属性。
这些是我找的图：
2.3 数据清洗打标 得到数据后，第一步就是清洗，所谓清洗主要是把爬的垃圾数据删了，并且该抠图的抠图（角色的Lora其实不扣也不太影响，真人是尽力抠图，功能性的lora基本上是要手动p图的）。
这里我给大家一个抠图脚本，用的阿里云API，非常方便：
链接：https://pan.baidu.com/s/1PdF2ocgqOBtRmQqtmij6RA?pwd=bjf4 提取码：bjf4 总之清晰后数据就是干净的，最好是扣过的图，只有人物主体。
然后我们就要打标了，如果是真人或者风格类lora，可以学youtube里那些人做法，直接用BLIP做image caption，然后手动修改一些。但是二次元强烈建议直接上deepbooru，这是因为二次元SD的base model源头是NovelAI泄露的，而当时的模型就是这个风格的标签，所以二次元特别适合用booru风格的描述。具体操作如下：
首先打开SD webui，找到如下地方：
至于说分辨率，其实512就可以了，可以调大一些，如果你显存够大，我用3090发现基本上拉到1024分辨率后就没有收益了，而低于512明显效果不好。理论上图片分辨率高一些好，此外图片质量解析力也应该高。
打完勾后，就可以process了。
当程序自动走完流程我们就在目标文件夹里得到一组由image和text文件组成的对：
其中txt文件里就是对一幅图的描述，如下：
1girl, blurry, solo, depth_of_field, hairband, blurry_background, building, torii 然后就进行最重要的步骤，打标。
所谓打标就是监督学习，告诉SD我们要它学什么。这里我们就是想学一个角色，这个角色有很多特征，比如她头上有花花，短发，眼睛样子等。
因此我们要把这些角色特征的描述词，从txt文件中的描述中删除。
。。。。。。
然后我们再加入一个特定的角色名，用来表示这个角色。让这个角色名学到刚才我们删除的特征。
换句话说，如果我们不删除那些特征，模型是不会把这些特征学给这个角色名的，而是专门学给具体的描述词。比如如果我们留下来头上的花，那么头上有花这个概念就不会学给初春这个角色名。当我们生成图像时候，初春这个词是不会生成头上有花的女孩，但是初春必须头上有花！所以我们要干掉这个词，这样模型就认为初春头上必然有花。
其实就很简单，控制变量法，我们留下来的标签就是我们想让模型学习的。
但是编辑这玩意如果一个一个文件走会很烦，我这里有个简单的步骤：
首先下载一个webui的插件“
stable-diffusion-webui-dataset-tag-editor-main
（请去Github搜，然后放进Webui的Extensions目录下），然后我们可以进行批量编辑了：
这就是可以批量编辑的地方，我们进行批量remove，即批量删除我们不想要的特征词：
这些词我认为都是初春特征，所以我都打勾删除，记得删除后保存下。
等到这些删除完了后，我们在每句描述前面都加上uiharu_kazari，这个是初春的触发词。一旦我们在prompts写上这个词，初春就会出现！我认为很重要，当然有人说可以不加，其实我训练几十个lora很多方案都试过，现在我感觉也是可加可不加的，但是我喜欢加上，里面原因很难直接说，就是加上后出图效果会好一些。但是不一定，有时候会变差，我说的这个方案其实是有些晋级的了，新人建议全都不删除tags，标签出来直接都拿去train，最简单稳定。
为什么放在第一位，实际上tags是有顺序的，一般最开始的tags的权重最大，越靠后越小，所以我们要把我们最想学的这个人放在第一位，像是没有意义的概念，比如透明背景我们尽量往后放。
此外我们需要看每张图的描述，有一些描述是含有明显错误的，因为毕竟是打标器，很多都是错的。我们一定要删除错误的标签，这些错误是会明显影响我们训练结果的（当然图多时候其实不影响了，但是话又说回来，图片质量&gt;图片数量，风格、功能性Lora&gt;真人&gt;二次元，二次元是最简单的lora）。
2.4 训练 我们开始写一个训练脚本参数。
首先是Base Model概念，这个应该是最重要概念之一，就是我们是在什么模型基础上训练的。
比如我们训练真人，女性，社区目前首选Chilloutmix系列。如果是汽车之类的物体，首选可以是SD1.5 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bad5efe9e26af706f424f4921d5a372c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/467866c4aa62d676da5596770a076164/" rel="bookmark">
			Java基础——学生成绩信息管理系统（简单实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求 1、 定义一个学生类 Student，包含姓名、成绩信息； 2、使用 ArrayList集合存储学生对象； 3、 对集合中的元素进行增删查改的操作。 一、定义学生类 学生类可以包含姓名、成绩、学号、年龄等等，这里只包含了前两项学生类属性。
public class Student { //封装学生类型： private String name; //姓名 private int score; //成绩 public Student() { } public Student(String name, int score) { this.name = name; this.score = score; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getScore() { return score; } public void setScore(int score) { this.score = score; } //重写toString方法： @Override public String toString() { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/467866c4aa62d676da5596770a076164/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/888eeae93dc005a4fc95e4085994f2b9/" rel="bookmark">
			用Eclipse创建一个JavaWeb项目，把资源添加到Tomcat服务器，并运行jsp文件详细过程（附图片）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、Eclipse下载安装
二、创建
1.创建web项目
2.创建jsp文件
三.设置Tomcat
四.解决问题
五、添加资源到tomcat服务器
六.运行
总结
前言 使用Eclipse创建web项目时，务必先下载安装好JDK和Tomcat。
一、Eclipse下载安装 1、Eclipse J2EE：https://www.eclipse.org/downloads/
2、选择Eclipse IDE for Enterprise Java and Web Developers，并下载对应版本
3、下载压缩包后，直接解压，然后打开.exe程序
二、创建 1.创建web项目 1、点击左上角File---New---Dynamic Web Project
2、这里只创建Project name，其他默认选项，直接next
​​​
3、继续next
4、直接finish
5、创建好的项目如下，但是是有错误的，接下来一步步解决
2.创建jsp文件 1、选择自己项目(TestPro)下的webapp文件夹，右键New--JSP File
2、输入File name，然后点next
3、直接finish
4、接下来会出现这样的错误
三.设置Tomcat 1、在解决上述问题时先添加tomcat服务器，点击Window---Preferences
2、左侧下滑找到Server--Runtime environments ,点击Add添加Tomcat(我这里添加过的)
3、下拉Apache文件夹，找到你下载的tomcat版本，点next
4、设置tomcat路径，就是你安装tomcat的路径，\bin的上一级，再设置JRE
5、添加JDK,没有就添加Add，有就修改路径Edit（我之前添加过）
6、Add--Standard VM---Next
7、找到你的JDK的安装位置，然后finish，JRE name可以自定义
8、设置好了点击Apply and close
9、返回到上一级后，JRE选择刚刚设置的jdk,然后finish
10、这是我新添加的tomcat,然后Apply and close
到这里tomcat服务器基本配置好了，有错误的话我们再解决。
四.解决问题 1、刚刚我们出现的问题，可以用下列方法解决，右键项目(TestPro)--Properties
2、左侧下滑找到Java Build Path----Libraries，我们点击Modulepath，然后添加两项
JRE System Library[jdk]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/888eeae93dc005a4fc95e4085994f2b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33302b896df184292e60091ebb837d97/" rel="bookmark">
			npm安装-详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		npm安装教程 第一章 Vue学习入门之 Node.js 的使用
文章目录 npm安装教程@[TOC] 前言一、npm是什么？二、安装、配置环境变量1.下载并安装NodeJS2.npm配置 前言 随着时代的不断发展，前端学习这门技术也越来越重要，很多人都开启了学习前端学习，本文就介绍了前端学习的基础内容——npm安装。
一、npm是什么？ npm 是 NodeJS 下的包管理器，vue-cli脚手架模板就是基于 node 下的 npm 来完成安装的。
相关介绍~
webpack: 它的主要用途是通过CommonJS的语法把所有浏览器端需要发布的静态资源做相应的准备，比如资源的合并和打包。
vue-cli：官方提供的一个脚手架，用于快速生成一个 vue 的项目模板。
二、安装、配置环境变量 1.下载并安装NodeJS windows下的NodeJS安装是比较方便的（v0.6.0版本之后，支持windows native），只需要直接访问官网（https://nodejs.cn/download/），这里我们可以选择 Windows 安装包 (.msi)-64位 进行安装。
或者直接登陆官网 http://nodejs.org/
安装过程基本一路直接“NEXT”就可以了，直到Finished。
windows下，安装msi文件在过程中会直接添加path的系统变量，变量值是你的安装路径，例如“D:\RunSoftware\nodejs” 确认 nodejs 安装成功：
快捷键 win+R —&gt; 输入 cmd命令行，进入 dos 窗口：输入 node -v， 查看是否能够正确打印出版本号即可！
node自带 npm，输入 npm -v，查看是否能够正确打印出版本号即可！
2.npm配置 npm作为一个NodeJS的模块管理，我们可以先配置npm的全局模块的存放路径以及cache的路径。
（1）建立2个目录 node_cache 和 node_global 。
如果想将这两个文件夹放在NodeJS的主目录下，便在NodeJs下建立"node_global"及"node_cache"两个文件夹。如下：
（2）进行配置
npm config set prefix "D:\RunSoftware\nodejs\node_global" npm config set cache "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33302b896df184292e60091ebb837d97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e95054c2461535fa070f3204f7202cd8/" rel="bookmark">
			【前端】从零开始读懂Web3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序言 用心生活，用力向上，微笑前行，就是对生活最好的回馈。
本专栏说明：
主要是记录在分享知识的同时，不定时给大家送书的活动。
参与方式：
赠书数量：本次送书 3 本，评论区抽3位小伙伴送书
活动时间：截止到 2023-04-20 20:00:00
抽奖方式：利用程序进行抽奖。
参与方式：关注博主、点赞、收藏，评论区评论 "人生苦短，我爱web！"
web发展史 Web的发展史可以大致分为以下几个阶段：
Web 1.0时代 （1990年代中期）
Web 2.0时代（2000年代初期）
Web 3.0时代（当前）
1 web1.0 Web的初期阶段，主要是以静态网页为主，内容以文本和图片为主，用户只能通过超链接进行简单的页面跳转和浏览。Web 1.0时代的网站大多由个人或企业自己搭建和维护，缺乏标准化的技术和工具支持。
Web 1.0是指互联网的早期阶段，大约从1991年至2004年左右。在这个阶段，Web主要是以静态网页为主，网页内容主要是由HTML、CSS、JavaScript等技术组成，网页的内容呈现形式以文本和图片为主，用户主要是通过超链接进行简单的页面跳转和浏览。
Web 1.0时代的技术基础主要是HTML、CSS和JavaScript等前端技术，后端技术主要是CGI、ASP、PHP等脚本语言。网站的部署和维护主要是通过FTP等传统的文件传输协议进行，缺乏现代化的开发、测试和部署工具。
总的来说，Web 1.0时代是互联网的初期阶段，虽然网站的功能和交互性较低，但它为后续的Web发展和演化奠定了基础。
Web 1.0时代的经验和教训也启示我们，在Web的发展和演化中，需要不断地引入新的技术和概念，不断地改进用户体验和互动性，才能更好地满足用户的需求和期望。
2 web2.0 时间，大约从2004年至2010年左右。在这个阶段，Web主要是以动态网页和社交媒体为主，内容更加丰富多样化，用户可以通过Web应用程序进行更加复杂的交互和操作。
Web的第二个阶段，主要是以动态网页和社交媒体为主，内容更加丰富多样化，用户可以通过Web应用程序进行更加复杂的交互和操作。
Web 2.0时代的网站大多采用开放标准和技术，如Ajax、XML、RSS等，用户可以通过浏览器和Web应用程序进行更加灵活的操作和交互。
此外，Web 2.0时代的网站开发和管理也得到了极大的改进和提升，出现了许多新的工具和框架，如jQuery、Bootstrap、React等，使得网站的开发和维护更加高效、便捷。
同时，Web 2.0也促进了开放数据、开放知识等概念的发展，使得互联网变得更加开放、透明和共享。
Web 2.0时代的网站主要以社交媒体、博客和在线办公应用为主，如Facebook、Twitter、WordPress、Google Docs等。
这些网站的特点是用户生成的内容多，个性化程度高，交互性强，用户可以通过分享、评论、点赞等方式与其他用户进行互动。
Web 2.0时代是互联网的一个重要阶段，它为互联网的发展和演化带来了重大的影响和变革。
4 web3.0 Web 3.0是指互联网的第三个阶段，也被称为“智能互联网”或“语义互联网”，其主要特点是实现了数据的智能化、语义化和分布式存储，使得互联网可以更加智能、开放、安全和去中心化。
Web 3.0的相关技术包括：
人工智能（AI）：Web 3.0时代的互联网需要具备智能化的能力，可以通过机器学习、自然语言处理等技术对数据进行分析和处理，提高数据的质量和价值。
区块链（Blockchain）：Web 3.0的互联网需要具备去中心化的能力，可以通过区块链技术实现分布式存储和去中心化的管理，保护数据的安全和隐私。
语义Web（Semantic Web）：Web 3.0的互联网需要具备语义化的能力，可以通过RDF、OWL等技术对数据进行描述和表示，使得数据能够被机器理解和利用。
Web服务（Web Services）：Web 3.0的互联网需要具备开放性的能力，可以通过Web服务实现跨平台、跨语言的数据交互和共享。
物联网（Internet of Things，IoT）：Web 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e95054c2461535fa070f3204f7202cd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5853e9d0ae9bf4c044e0d267e0c8811d/" rel="bookmark">
			Elasticsearch集群搭建与相关知识点整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：大家好，我是小威，24届毕业生，在一家满意的公司实习。本篇文章参考网上的课程，介绍Elasticsearch集群的搭建，以及Elasticsearch集群相关知识点整理。
如果文章有什么需要改进的地方还请大佬不吝赐教👏👏。
小威在此先感谢各位大佬啦~~🤞🤞
🏠个人主页：小威要向诸佬学习呀
🧑个人简介：大家好，我是小威，一个想要与大家共同进步的男人😉😉
目前状况🎉：24届毕业生，在一家满意的公司实习👏👏
💕欢迎大家：这里是CSDN，我总结知识的地方，欢迎来到我的博客，我亲爱的大佬😘
以下正文开始
文章目录 Elasticsearch部署集群Elasticsearch集群职责Elasticsearch集群健康状态Elasticsearch集群分片Elasticsearch故障转移书籍推荐 Elasticsearch部署集群 单机部署的Elasticsearch在做数据存储时会遇到存储数据上线和机器故障问题，因此对于Elasticsearch集群的部署是有必要的。搭建Elasticsearch集群，可以将创建的索引库拆分成多个分片（索引可以被拆分为不同的部分进行存储，称为分片。在集群环境下，一个索引的不同分片可以拆分到不同的节点中），存储到不同的节点上，以此来解决海量数据存储问题；将分片上的数据分布在不同的节点上可以解决单点故障问题。
一个节点(node)就是一个Elasticsearch实例，一个Elasticsearch集群(cluster)由一个或多个节点组成，它们具有相同的集群名称（cluster.name），它们协同工作，分享数据和负载。
当加入新的节点或者删除一个节点时，集群就会感知到并平衡数据（同步）。
编写内容如下的docker-compose文件，将其上传到Linux的/root目录下：
version: '2.2' services: es01: image: elasticsearch:7.12.1 container_name: es01 environment: - node.name=es01 - cluster.name=es-docker-cluster # 集群名称相同 - discovery.seed_hosts=es02,es03 # 可以发现的其他节点 - cluster.initial_master_nodes=es01,es02,es03 # 可以选举为主节点 - "ES_JAVA_OPTS=-Xms512m -Xmx512m" volumes: - data01:/usr/share/elasticsearch/data # 数据卷 ports: - 9200:9200 # 容器内外端口映射 networks: - elastic es02: image: elasticsearch:7.12.1 container_name: es02 environment: - node.name=es02 - cluster.name=es-docker-cluster - discovery.seed_hosts=es01,es03 - cluster.initial_master_nodes=es01,es02,es03 - "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5853e9d0ae9bf4c044e0d267e0c8811d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a90ced7d758cfcf40eab4e5458269ed/" rel="bookmark">
			Python123选择题练习&#43;解析（1~150）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		答案解析：递归函数是指函数内部包含对本函数的再次调用。
答案解析：每个递归函数至少存在一个基例
答案解析：函数的作用是复用代码、增强代码可读性、降低编程复杂度，而并不能提高代码的执行速度。
答案解析：python里有可变对象和不可变对象之分。只有传入的是不可变对象时，值才不发生改变，若是可变对象，值的传入需要注意。不可变对象：Number ,String ,Tuple，bool。可变对象： List , Set , Dictionary是可以改变内部的元素 。
答案解析：函数可以不使用return语句或多条return语句，因此A，B不正确；Python函数定义中没有对参数指定类型，函数中应根据实参的类型使用，C不正确。
答案解析：执行该函数后，变量c的值为210
答案解析：全局变量可以和局部变量重名，全局变量指的是在函数之外定义的变量，在程序执行全过程有效。全局变量在函数内部使用时，需要提前使用保留字global声明。局部变量指在函数内部定义的变量，仅在函数内部有效，当函数退出时，变量将不再存在。
答案解析：面向对象编程能实现的功能均可以采用面向过程同样能完成
答案解析：递归程序的执行效率比较低
答案解析：lambda表达式相当于：
def fun(x,y): return x+y print(fun(10,10)) 答案解析：函数定义中参数列表里面的参数是形参，参数列表中给出要传入函数内部的参数，这类参数称为实参；程序在调用时，将实参复制给函数的形参
答案解析：lambda是Python的保留字
Python保留字列表 序号保留字含义1and用于表达式运算，逻辑与操作2as用于类型转换3assert断言，用于判断变量或条件表达式的值是否为真4break中断循环语句的执行5class用于定义类6continue继续执行下一次循环7def用于定义函数或方法8del删除变量或序列的值9elif条件语句，与if,else结合使用10else条件语句，与if,elif结合使用，也可用于异常和循环语句11exceptexcept包含捕获异常后的操作代码块，与try,finally结合使用12NoneNone是python中特殊的数据类型’NoneType’, None与其他非None数据相比，永远返回False13forfor循环语句14finally用于异常语句，出现异常后，始终要执行finally，包含的代码块，与try，except结合使用15from用于导入模块，与import结合使用16global定义全局变量17if条件语句，与else，elif结合使用18import用于导入模块，与from结合使用19in判断变量是否在序列中20is判断变量是否为某个类的实例21lambda定义匿名变量22not用于表达式运算，逻辑非操作23or用于表达式运算，逻辑或操作24pass空的类，方法，函数的占位符25Truepython中的布尔类型，与False相对。26raise异常抛出操作27return用于从函数返回计算结果28trytry包含可能会出现异常的语句，与except，finally结合使用29whilewhile的循环语句30with简化python的语句31yield用于从函数依此返回值32nonlocalnonlocal是在Python3.2之后引入的一个关键字，它是用在封装函数中的，且一般使用于嵌套函数的场景中33Falsepython中的布尔类型，与True相对。 答案解析：def vfunc(* a, b):中的*(可选参数)应该放在后面，因此D错误
def 函数名(q,w=10,*e,r=None):
固定参数q，默认参数w，可选参数元组e，有默认值的可选参数r
参考博客：【Python】一篇文章学会def定义函数的可选参数，默认参数，有默认值的可选参数（保姆级注释）_def 参数默认_发现你走远了的博客-CSDN博客
答案解析：可选参数不可以定义在非可选参数的前面
答案解析：函数return的个数没有限制，可以没有return语句
答案解析：Python使用def保留字定义一个函数，del：删除变量或序列的值。
答案解析：局部变量指在函数内部定义的变量，仅在函数内部有效，当函数退出时，变量将不再存在。
答案解析：A选项中，f的类型依参数来确定
答案解析：这是典型的递归函数，在return语句中调用函数本身。功能为输出N的阶乘值
答案解析：代码中n不是可选参数，可选参数有*或**
*args是可变参数，args接收的是一个tuple；
**kw是关键字参数，kw接收的是一个dict。
答案解析：参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。
位置参数不是一个出现在函数定义时的概念，而是一个出现在函数调用时的概念。 调用函数时传入的实际参数数量和位置都必须和定义函数时保持一致。
实参和形参数量必须一致，参数多或者少都会报错TypeError。
实参和形参位置必须一致，否则会产生不同的结果。
关键字参数不是一个出现在函数定义时的概念，而是一个出现在函数调用时的概念。 关键字参数是指使用键值对的形式key=values来确定输入的参数值。
关键字参数允许你以任何顺序传递参数，不再需要与形参的位置完全一致，只要将参数名写正确即可。
混合传参时关键字参数必须位于位置参数之后。
使用关键字参数，可以让参数传递更加明确，让调用方清楚的知道每个参数的传值情况。
答案解析：python中^表示按位异或，在本题中a ^= 3也就是将a转换为二进制 并与3异或，4的二进制为100，3的二进制为011，因此异或后的结果为111，也就是数字7，b = a^2也就是111与2进行异或，2的二进制为010，因此111与010异或的结果为101，也就是数字5，所以结果为7，5。
4（0000 0100）;3（0000 0011）;2（0000 0010）;a=4 -&gt; 7（0000 0111）;b=5（0000 0101）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a90ced7d758cfcf40eab4e5458269ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35f6ce69541a08e19126fbbd56e20d36/" rel="bookmark">
			Stable Diffusion-webUI ckpt模型、lora模型的区别和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、常用的两种模型：ckpt和Lora分别是什么？有什么区别？ 1、CKPT（CheckPoint） 经过训练的图片合集，被称作模型，也就是chekpoint，体积较大，一般真人版的单个模型的大小在7GB左右，动漫版的在2-5个G之间
早期的CKPT后缀名是ckpt，如今新的CKPT后缀名都是safetensors
2、Lora 是一种体积较小的绘画模型，是对大模型的微调。与每次作画只能选择一个大模型不同，lora模型可以在已选择大模型的基础上添加一个甚至多个。一般体积在几十到几百兆左右。后缀也是safetensors
二、如何区分？ 1、CKPT偏大普遍1G以上，Lora相对而言偏小几十到几百昭
2、C站下载时会有Type标识
三、如何使用/切换模型 1、ckpt模型 c站下载相应模型后将文件放入 stable-diffusion-webui\models\Stable-diffusion文件夹中
在SD-webUi左上角可以直接切换使用（如果下拉没显示就点下旁边的刷新）
2、Lora模型（两种方法） （Lora模型是对ckpt模型的一个微调,所以应该是先使用一个ckpt后再选择Lora）
方法a： c站下载相应模型后将文件放入 stable-diffusion-webui\models\Lora文件夹中
选择好ckpt模型后点击1处再点击2处（若未显示模型则点击刷新）
方法b 1、安装扩展 Kohya-ss Additional Networks script
2、重启webUI
3、安装目录会出现 extensions\sd-webui-additional-networks\models\lora文件夹
4、 c站下载的lora放入该文件夹
5、webUI会多出下图的操作栏（我使用的第一种，所以下面是网上找的图不清晰）
该方法比上一种方法要复杂，但好在可更自由控制Lora模型特点相比ckpt模型特点生成图片的权重
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98f611ef7b4901142e921586cc29929a/" rel="bookmark">
			SQL函数 - 开窗(窗口)函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是开窗函数？ 开窗函数对一组值进行操作，它不像普通聚合函数那样需要使用GROUP BY子句对数据进行分组，能够在同一行中同时返回基础行的列和聚合列
开窗函数的语法形式为：函数 + over(partition by &lt;分组用列&gt; order by &lt;排序用列&gt;)，表示对数据集按照分组用列进行分区，并且并且对每个分区按照函数聚合计算，最终将计算结果按照排序用列排序后返回到该行。括号中的两个关键词partition by 和order by 可以只出现一个。
注意：开窗函数不会互相干扰，因此在同一个查询语句中可以同时使用多个开窗函数
开窗函数适用于 mysql 8.0以上版本， sql sever 、hive、oracle 等
开窗函数分类 窗口函数大致分为以下几类：
一、排序开窗函数 ① row_number() -- 相同值排名顺延，返回结果1、2、3、4
② rank() -- 相同结果排名相同，后续排名不连续，返回结果为 1、2、2、4
③ dense_rank() -- 相同结果排名相同，后续排名顺延，返回结果为 1、2、2、3
④ ntile(n) -- 分组排名，将数据分为n组并返回对应组号1、2......n
具体例子如下：
select grades ,subjects ,results ,row_number() over(partition by grades,subjects order by results desc) as row_numbers ,rank() over(partition by grades,subjects order by results desc) as ranks ,dense_rank() over(partition by grades,subjects order by results desc) as dense_ranks ,ntile(3) over(partition by grades,subjects order by results desc) as ntiles from test11 表示将数据集按照grades、subjects字段进行分组后，根据对应排序函数并按照results字段降序返回排名，具体结果如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98f611ef7b4901142e921586cc29929a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/380f4364a260c3f368b75499dafedbd2/" rel="bookmark">
			书城管理系统（前端）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OK，兄弟们！
测试上传图片的后端接口
测试分页条件查询后端接口
测试根据id查询后端接口
测试新增一本书的后端接口
测试修改一本书的后端接口
之前写好的后端接口，用postman测试一下，没有问题的话我们就试试开发前端。
准备工作： 用vue创建一个文件，安装VUE步骤我这里引用一下其他人的csdn
(3条消息) Vue脚手架搭建及vue项目创建【详细教程】_星河梦~的博客-CSDN博客https://blog.csdn.net/weixin_53186633/article/details/122461313现在桌面创建一个空的文件夹，然后选择用vscode打开，然后打开终端。
然后在终端输入vue命令新建一个vue项目
vue create book-fornt 然后选择Manually select features，这里我们选下面这5个。按空格和上下箭头选择，选好回车就行
然后这里我们选3.x
下面按这个选择配置就行，选好最后回车就开始创建了
创建好就是这个样子
我们在终端上切到book-fornt项目
cd book-fornt 我们还需要安装axios和element-plus(3.x的饿了么组件交plus)
axios
npm install axios --save element-plus
npm install element-plus --save 然后在main.js中引入一下
import { createApp } from 'vue' import App from './App.vue' import router from './router' import store from './store' import ElementPlus from 'element-plus' import 'element-plus/dist/index.css' createApp(App).use(store).use(router).use(ElementPlus).mount('#app') 修改一下vue.config.js文件里的内容
const { defineConfig } = require('@vue/cli-service') module.exports = { devServer:{ port:8020, // 启动端口号 open:true // 启动后是否自动打开网页 } } npm run serve跑一下试试，看看项目能不能运行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/380f4364a260c3f368b75499dafedbd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb0490be6cc2106077016bb76dcd1087/" rel="bookmark">
			动手学深度学习(李沐)的pytorch版本（包含代码和PDF版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
网址（特别适合自学）
说明:
代码与PDF版
网址（特别适合自学） 传送门
界面一览：
说明: github上一个项目将《动手学深度学习》从mxnet改为了pytorch实现。感谢大佬们的工作。
特别说明该电子版网页是通过docsify部署生成的，详细了解点击here，自己有很多文章或者想做电子版本文档的强推docsify 代码与PDF版 需要详细代码的朋友可以在下面这篇文章中自取（有详细的中文PDF内容和全部代码）
http://t.csdn.cn/Nb4mx
(30条消息) 《动手学深度学习》PyTorch版本TendorFlow版本（内有所有代码和PDF版下载地址）_M_Q_T的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14cf7cf53e4cc2d9e0f360d206cfec69/" rel="bookmark">
			【Pytorch】利用PyTorch实现图像识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是目录 使用torchvision库的datasets类加载常用的数据集或自定义数据集使用torchvision库进行数据增强和变换，自定义自己的图像分类数据集并使用torchvision库加载它们使用torchvision库的models类加载预训练模型或自定义模型forward方法进行模型训练和测试，使用matplotlib.pyplot库可视化结果 使用torchvision库的datasets类加载常用的数据集或自定义数据集 图像识别是计算机视觉中的一个基础任务，它的目标是让计算机能够识别图像中的物体、场景或者概念，并将它们分配到预定义的类别中。例如，给定一张猫的图片，图像识别系统应该能够输出“猫”这个类别。
为了训练和评估图像识别系统，我们需要有大量的带有标注的图像数据集。常用的图像分类数据集有：
ImageNet：一个包含超过1400万张图片和2万多个类别的大型数据库，是目前最流行和最具挑战性的图像分类基准之一。CIFAR-10/CIFAR-100：一个包含6万张32×32大小的彩色图片和10或100个类别的小型数据库，适合入门级和快速实验。MNIST：一个包含7万张28×28大小的灰度手写数字图片和10个类别的经典数据库，是深度学习中最常用的测试集之一。Fashion-MNIST：一个包含7万张28×28大小的灰度服装图片和10个类别的数据库，是MNIST数据库在时尚领域上更加复杂和现代化版本。 使用torchvision库可以方便地加载这些常用数据集或者自定义数据集。torchvision.datasets提供了一些加载数据集或者下载数据集到本地缓存文件夹（默认为./data）并返回Dataset对象（torch.utils.data.Dataset） 的函数。Dataset对象可以存储样本及其对应标签，并提供索引方式（dataset[i]）来获取第i个样本。例如，要加载CIFAR-10训练集并进行随机打乱，可以使用以下代码：
import torchvision import torchvision.transforms as transforms transform = transforms.Compose([transforms.ToTensor()]) # 定义转换函数，将PIL.Image转换为torch.Tensor trainset = torchvision.datasets.CIFAR10(root='./data', train=True, download=True, transform=transform) # 加载CIFAR-10训练集 trainloader = torch.utils.data.DataLoader(trainset, batch_size=4, shuffle=True) # 定义DataLoader对象，用于批量加载数据 使用torchvision库进行数据增强和变换，自定义自己的图像分类数据集并使用torchvision库加载它们 数据增强和变换：为了提高模型的泛化能力和数据利用率，我们通常会对图像数据进行一些随机的变换，例如裁剪、旋转、翻转、缩放、亮度调整等。这些变换可以在一定程度上模拟真实场景中的图像变化，增加模型对不同视角和光照条件下的物体识别能力。torchvision.transforms提供了一些常用的图像变换函数，可以组合成一个transform对象，并传入datasets类中作为参数。例如，要对CIFAR-10训练集进行随机水平翻转和随机裁剪，并将图像归一化到[-1, 1]范围内，可以使用以下代码： import torchvision import torchvision.transforms as transforms transform = transforms.Compose([ transforms.RandomHorizontalFlip(), # 随机水平翻转 transforms.RandomCrop(32, padding=4), # 随机裁剪到32×32大小，并在边缘填充4个像素 transforms.ToTensor(), # 将PIL.Image转换为torch.Tensor transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5)) # 将RGB三个通道的值归一化到[-1, 1]范围内 ]) trainset = torchvision.datasets.CIFAR10(root='./data', train=True, download=True, transform=transform) # 加载CIFAR-10训练集，并应用上述变换 trainloader = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14cf7cf53e4cc2d9e0f360d206cfec69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d037c3e37f8a38d217cbfc641be8057c/" rel="bookmark">
			【Web】WebHook详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 webhook简介什么是 webhook?webhook 有什么用?webhook请求过程使用 webhookWebhook POST 或 GETWebhook 与轮询何时使用 webhookAsp .Net接受与处理接口处理 发送 WebHook和消息队列区别与联系来源 webhook简介 在当今高度连接的网络世界中,没有什么可以孤立地发挥最佳作用。完成一项任务(几乎)总是需要多个实体的参与。电子商务应用程序需要与支付系统通信,支付系统需要与银行系统通信,银行系统需要与客户账户通信…你看到模式了吗?
独立在线系统相互通信和共享数据的能力是当今在线服务有价值的核心。在这篇文章中,将介绍 webhook。 Webhook 是促进在线服务之间通信的众多方法之一,在本文结束时,您将完全了解 Webhook 是什么、它们如何工作以及何时使用它们。
什么是 webhook? Webhook 是一个 HTTP 请求,由源系统中的事件触发并发送到目标系统,通常带有数据负载。 Webhook 是自动化的,换句话说,当它们的事件在源系统中被触发时,它们会自动发送出去。
这为一个系统(源)在事件发生时与另一个系统(目标)“对话”(HTTP 请求)提供了一种方式,并共享有关已发生事件的信息(请求有效负载)。
webhook 有什么用? 根据上面的定义,我相信您已经了解了 webhook 的用途。简而言之,webhook 用于将一个系统中事件的发生传达给另一个系统,并且它们经常共享有关该事件的数据。然而,一个例子总是更容易说明,所以让我们看一个 webhook 的例子。
假设您订阅了流媒体服务。每个月初,您的信用卡都会被扣款,您的银行需要通过短信或电子邮件与您沟通。银行系统(源)可以使用 webhook 调用邮件或 SMS 服务(目标),以便在每次从您的卡中扣款时立即向您发送借记通知。
银行系统还发送有关费用的信息,邮件或 SMS 服务使用这些信息为您的客户构建合适的消息。
webhook请求过程 对于发送 webhook 的系统,系统必须能够支持该过程。您可以通过触发针对不同类型的事件的HTTP请求来构建系统来发送Webhooks和松弛。
这些平台根据其中发生的活动支持不同类型的事件。
要接收 webhook 请求,您必须注册平台为其提供 webhook 的一个或多个事件(也称为主题)。 Webhook 请求将被发送到应用程序的目标端点,因此您需要为其构建一个并将 URL 注册为该事件的 Webhook URL。
一旦事件的 webhook 注册完成并添加了端点,您将在每次事件发生时提供的目标 URL 处收到 webhook 请求。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d037c3e37f8a38d217cbfc641be8057c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/135b31e2f7784a10f3e11049c3594f40/" rel="bookmark">
			【AI前沿】chatgpt还有哪些不足？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博客昵称：吴NDIR
个人座右铭：得之淡然，失之坦然
作者简介：喜欢轻音乐、象棋，爱好算法、刷题
其他推荐内容：计算机导论速记思维导图
其他内容推荐：五种排序算法
在这个愉快的周末让我们聊一下ChatGPT吧！ChatGPT 4时代来临，ChatGPT的缺陷在于它不能处理特定领域的知识，而且在生成响应时可能会出现语法错误和逻辑矛盾等问题。
1.速度问题2.实时性3.知识局限性4.文本处理问题5.逻辑处理6.越界问题 1.速度问题 ChatGPT起初响应速度慢，原因主要是因为其预测模型较为复杂，需要大量的计算资源和时间来完成响应的生成，导致响应速度较慢。但随着版本的更新和技术的不断创新，ChatGPT响应速度得到了不断的提升和优化。
OPEN AI在之后针对这个问题进行了以下的优化
硬件优化：使用更高效的GPU或TPU等硬件设备，加速模型的计算和推理过程，从而提高模型的响应速度。算法优化：使用更加高效的算法和模型结构，如预训练模型和增量学习等，优化模型的参数和参数更新方式，提高模型的响应速度和准确性。数据优化：使用更加优质和多样化的数据集，加入更多的标注和清洗工作，减少数据偏差和噪声，提高模型的训练效果和响应速度。 现在ChatGPT已经是非常快了，如让它写一篇论文
2.实时性 我们知道使用chatgpt可以查询概念，查询知识，查询菜谱等等，但是它不能获得当前最新消息，即使它能阶段性学习和更新，但至少来说目前它还不能代替搜索引擎。下面是一个例子，当向ChatGPT问道：“江西明天的天气？”
【提问】
【回答】
3.AI语言模型没有直接获取实时天气预报数据的能力。ChatGPT只是一个程序，根据输入的文本信息和相关的规则和算法来生成响应，它并没有接入实时数据的API或其他接口。 3.知识局限性 尽管ChatGPT具有强大的对话生成能力，但它仍然存在一些知识局限性，这些局限性可能导致ChatGPT在某些情况下无法有效地应用。 缺乏常识性知识ChatGPT的模型是基于大规模语料库训练的，它的知识主要来自于网络上的文本数据。因此，ChatGPT缺乏一些基本的常识性知识。例如，当被问到“鲸鱼是鱼类还是哺乳动物？”时，ChatGPT可能会回答“鱼类”，而不是正确的答案“哺乳动物”。容易受到输入数据的影响ChatGPT是一种生成式模型，它可以自动生成对话内容。然而，它的输出很容易受到输入数据的影响，因此需要对输入数据进行精心的筛选和处理。例如，如果输入的文本数据中存在歧义或错误，ChatGPT可能会生成不准确的对话内容。对特定领域的知识缺乏理解ChatGPT的模型是通用性的，它可以应用于各种领域的对话生成。然而，由于缺乏特定领域的知识，ChatGPT可能无法理解某些特定领域的术语或语言。例如，在医学领域，ChatGPT可能无法理解某些医学术语或药品名称，从而无法生成准确的对话内容。 4.文本处理问题 一个常见的问题就是不能处理长文本，很难向ChatGPT投喂大量数据。否则将提示：
因为GPT模型需要在每个时间步骤都生成一个预测，所以生成的时间会随着文本长度的增加而线性增加，这导致处理长文本时需要更长的时间。同时，长文本中可能涉及到多个话题，这可能导致模型在生成回复时出现逻辑不连贯或者没有重点的情况。因此，ChatGPT在处理长文本时可能会遇到一些限制，而这些限制可能会影响到对话的质量和效率。其次，当我们问题或者要求ChatGPT长文本输出时，它不能做到一次全部输出。如让ChatGPT写一篇不少于10000字关于CSDN
但这个问题还是容易解决，只需要要求它“继续”即可。但遇到代码块回复时，之后的一段将不再使用Markdown语法回复。 5.逻辑处理 在使用ChatGPT的过程，它很难处理与数学有关的问题（事实上与知识局限性有关）。下面是一个简单的排列组合问题：将4个不同的球放到4个不同的盒子中，有几种方法？ 2. 可以看到ChatGPT成功处理了这个问题，但我们将这个问题进行修改：若其中两个球是一样的，两者不作区分，有几种方法？
3. 看到这别着急，现在如果继续问：在此基础上，若其中有两个盒子完全相同不作区分呢？
实际上7种方式，而ChatGPT只是简单的除以2。ChatGPT只能处理简单的数学逻辑，而实际上在编程中，有些逻辑远远比这复杂，从而让它生成问题的代码往往不能帮助解决。
6.越界问题 ChatGPT是一个基于GPT模型的对话生成器，它可以用来生成有意义的对话。但是，由于它是一个预先训练好的神经网络，它所生成的回复是基于大规模数据集的统计模型。因此，ChatGPT生成的回复可能会包含一些不合适或有违背伦理道德的内容。
1.为了避免ChatGPT生成违背伦理道德的内容，开发者通常会在训练模型时使用专门的数据集，这些数据集包含了经过筛选和审查的高质量数据，以确保生成的回复是合适的并符合伦理道德的标准。此外，Open ai通过训练模型使用更加严格的限制条件来控制生成的回复，以确保其质量和合适性。
2. 但针对这个问题，有很多指令可以去诱导ChatGPT越界，如下面的指令
诱导越界
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/607/">«</a>
	<span class="pagination__item pagination__item--current">608/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/609/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>