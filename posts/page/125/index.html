<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/061c20e0837f2058205a69eb2e9e22d4/" rel="bookmark">
			【用java在控制台实现简单的图书管理系统】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用java在控制台实现简单的图书管理系统 book包Book类BookList类 user包User 类AdmiUser类（管理员）NormalUser类（管理员） opertion包IOperation接口FindOpertion（查找图书）AddOpertion（增加图书）DeletOpertion（删除图书）BorrowOpertion（借阅图书）ReturnOpertion （归还图书）ShowOpertion（展示图书）ExitOpertion（退出程序） Main（执行程序） &gt; 这个简易的图书管理系统，适合javaSE基础学完，所能做的项目，让学到的知识合理运用起来！检验自己的不二选择！也希望本博客对你有所帮助。（能帮助一点点我就心满意足了）
book包 Book类 这个类是用对图书的这些属性（书名，作者，类型，价格）进行了封装。为了允许外部代码访问和修改这些属性，你提供了公共的 getter 和 setter 方法。并且此处重写了toString()方法。
package book; import java.util.Objects; public class Book { private String name; private String author; private String type; private int price; private boolean isBorrowed; public Book(String name, String author, String type, int price) { this.name = name; this.author = author; this.type = type; this.price = price; } public String getName() { return name; } public void setName(String name) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/061c20e0837f2058205a69eb2e9e22d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6540733093a09149ad32f5c2e7b55078/" rel="bookmark">
			ES数据聚合 DSL实现Bucket聚合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ES数据聚合 聚合的分类 聚合（aggregations）可以实现对文档数据的统计、分析、运算。聚合常见的有三类：
桶（Bucket）聚合：对文档做分组 （类似数据库的group by） TermAggregation:按照文档字段值分组 （该字段就不能分词了 不能是text）Date Histogram:按照日期阶梯分组，比如一周为一组，或者一个月为一组 （这个功能用mysql实现就复杂多了） 度量（Metric）聚合：用于计算一些值 AvgMaxMinStats：同时求max min avg sum 管道（pipeline）聚合：其它聚合的结果为基础做的聚合 桶和度量用的比较多
DSL实现Bucket聚合 设置size为0 结果中不包含文档，只包含聚合结果
记住三个：聚合名称 聚合类型 聚合对应的字段
实例： 可以理解为命中数符合条件的文档数据 相当于数据库中的一条条数据。可以修改排序规则 ，默认是按照_count 降序排序
品牌一样的会放在一个桶里面 可以比作垃圾分类
Bucket 聚合-限定聚合搜索范围 默认情况下，bucket聚合是对索引库的所有文档做聚合，我们可以限定聚合的文档范围，添加 query条件即可
总结： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7cfa4438c4ce577207196ffe10171c3/" rel="bookmark">
			1.Spring Boot 简介(Spring MVC&#43;Mybatis-plus)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一，`Spring Boot` 简介二，搭建springboot项目并整合mybatis-plus框架1.pom导依赖2.添加启动项3.配置文件`.yml` 三，springboot集成` Spring MVC`1.springmvc定义2.应用注解 一，Spring Boot 简介 SpringBoot是Spring的子工程(或是spring的脚手架),快速搭建spring项目,自动配置了Spring 应用程序和第三方库
（spring+mybaties+web（servlet）+ reids+ 消息中间件）,而且使用很少xml配文件，提高开发效率。
二，搭建springboot项目并整合mybatis-plus框架 1.pom导依赖 &lt;!-- springboot项目依赖的父工程--&gt; &lt;!--springboot项目依赖的父工程 父工程主要有市面上流行技术很多jar包， 自已项目使用的话，只需引入，不需要写版本号，好处解决了很多jar依赖版本问题 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;!-- 不能版本3.0后,之后需要jdk17版本--&gt; &lt;version&gt;2.5.4&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;!--是springmvc依赖，也是springboot启动依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--连接数据库--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mybatis-plus依赖,对应yml文件的配置--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- druid: 数据库连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--测试依赖,集成多个测试库,例如: JUnit：Java的单元测试框架.......--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.34&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.添加启动项 /** * 启动类 * * @SpringBootApplication:标识该类是启动类 */ @SpringBootApplication //让Mybatis扫描接口路径 || 或者每个mapper接口加注解@Mapper @MapperScan("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7cfa4438c4ce577207196ffe10171c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/087b847fd4d5dc39208e8f1896b4726e/" rel="bookmark">
			理解 Objective-C 中 `&#43;load` 方法的执行顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		理解 Objective-C 中 +load 方法的执行顺序 在 Objective-C 中，+load 方法是在类或分类被加载到内存时调用的。它在程序启动过程中非常早的阶段执行，用于在类或分类被加载时进行一些初始化工作。理解 +load 方法的执行顺序对于编写可靠的 Objective-C 代码非常重要。本文将详细探讨 +load 方法在类、子类和分类中的执行顺序。
+load 方法的基本介绍 +load 方法是一个类方法，在类或分类被加载时自动调用。与 +initialize 方法不同，+load 方法只会被调用一次，并且在加载类和分类时立即执行，而不等待任何实例的创建。
类和子类中的执行顺序 当一个类和它的子类都实现了 +load 方法时，执行顺序如下：
父类的 +load 方法 先于 子类的 +load 方法 执行。在同一个继承层次结构中，类的 +load 方法按照编译顺序执行。 例如，考虑以下代码：
#import &lt;Foundation/Foundation.h&gt; @interface SuperClass : NSObject @end @implementation SuperClass + (void)load { NSLog(@"SuperClass +load"); } @end @interface SubClass : SuperClass @end @implementation SubClass + (void)load { NSLog(@"SubClass +load"); } @end int main(int argc, const char * argv[]) { @autoreleasepool { // 程序启动时自动调用 `+load` 方法 } return 0; } 输出结果将是：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/087b847fd4d5dc39208e8f1896b4726e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57cb6d85f9d950472a074bc0f2d00f83/" rel="bookmark">
			tpcc压力测试mysql和 ab压力测试云服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql性能测试工具——tpcc-mysql 在centos7.9上安装的
下载源码包，解压安装
# tar xf tpcc-mysql-src.tar
# cd tpcc-mysql/src
# yum install gcc mysql-devel -y
# make
会生成两个二进制工具tpcc_load（提供初始化数据的功能）和tpcc_start(进行压力测试)
[root@nfs-server src]# cd ..
[root@nfs-server tpcc-mysql]# ls
add_fkey_idx.sql drop_cons.sql schema2 tpcc_load
count.sql load.sh scripts tpcc_start
create_table.sql README src
3、tpcc测试前准备，初始化数据库
在其他的服务器上连接到mysql服务器上创建tpcc库
需要在测试的服务器上创建tpcc的库
docker exec -it cs bash
mysql -uroot -p’sc@123456’
create database tpcc;
exit exit [root@docker tpcc-mysql]# pwd
/root/tpcc-mysql 当前所在的文件夹
[root@docker tpcc-mysql]# ls
add_fkey_idx.sql create_table.sql load.sh schema2 src tpcc_start
count.sql drop_cons.sql README scripts tpcc_load
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57cb6d85f9d950472a074bc0f2d00f83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04ea7b9c42085d9264150fe3dacf163e/" rel="bookmark">
			08、Tomcat 部署及优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		8.1 Tomcat概述 8.1.1 Tomcat介绍 自从 JSP 发布之后,推出了各式各样的 JSP 引擎。Apache Group 在完成 GNUJSP1.0的开发以后，开始考虑在 SUN 的 JSWDK 基础上开发一个可以直接提供 Web 服务的 JSP服务器，当然同时也支持 Servlet, 这样 Tomcat 就诞生了。
Tomcat是 Apache 软件基金会(Apache Software Foundation)Jakarta 项目中的一个核心项目，由 Apache、Sun 和其他一些公司及个人共同开发而成。其被 JavaWorld 杂志的编辑选为 2001 年度最具创新的 Java 产品，同时它又是 Sun 公司官方推荐的 Servlet和 JSP 容器，因此 Tomcat越来越多的受到软件公司和开发人员的喜爱。由于有了 Sun 的参与和支持，最新的 Servet 和 JSP 规范总是能在 Tomcat 中得到体现，Tomcat5 支持最新的 Servlet 2.4 和 JSP 2.0 规范。因为 Tomcat 技术先进、性能稳定、免费,因而深受 Java爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。
Tomcat 服务器是一个免费的开放源代码的 Web 应用服务器,属于轻量级应用服务器,在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试 JSP 程序的首选。对于一个初学者来说，可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应 HTML(标准通用标记语言下的一个应用)页面的访问请求。实际上，Tomcat是Apache 服务器的扩展，但运行时它是独立运行的，所以当运行 Tomcat 时，它实际上作为一个与 Apache 独立的进程单独运行的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04ea7b9c42085d9264150fe3dacf163e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/045f34148f746005604a77b686da0dff/" rel="bookmark">
			FL Studio 24.1.1.4239中文破解版安装激活问题教程365天永久免费白嫖哦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FL Studio 24.1.1.4239中文破解版是一款功能强大的数字音频工作站（DAW），广泛应用于音乐制作、编曲、混音和录音等领域。以下是对FL Studio 24.1.1.4239中文破解版的详细介绍：
一、功能与特点
音频编辑：FL Studio 24提供了波形编辑器，允许用户直接对音频进行切割、拼接、淡入淡出等操作。同时，它还支持时间伸缩和音高调整，这些操作都不会损失音质。混音功能：该软件支持创建无限数量的音频、乐器和效果器轨道，具有灵活的音频路由选项和侧链压缩功能，可以实现动态的音乐处理和混音效果。此外，它还提供了多种混响算法，以模拟不同的空间和环境效果。录制功能：FL Studio 24支持多轨录制，可以同时录制多个轨道的音频信号。在录制过程中，用户可以利用实时输入监视功能进行监听和调整，确保录制的准确性。同时，内置的节拍器和预录功能也有助于提高录制的精准度。插件支持：该软件支持VST、VST3、AU等多种格式的插件，并提供了大量内置的合成器、采样器、效果器等插件。这些插件可以丰富音乐制作的效果和可能性。此外，插件沙盒功能可以确保插件的稳定性，避免因插件崩溃而影响整个项目。自动化控制：在FL Studio 24中，几乎所有参数都支持自动化控制。用户可以通过绘制自动化曲线或录制自动化数据来实现对参数的精确控制。同时，直观的包络编辑器也使得创建和编辑自动化数据变得更加容易。效果处理：该软件包含了均衡器、压缩器、限制器、失真效果器、延迟、混响等丰富的效果器库。用户可以创建复杂的效果器链，以实现高级的音频处理效果。在调整效果器参数时，还支持实时预览处理效果，以便用户及时做出调整。虚拟乐器：FL Studio 24内置了多种合成器、采样器、打击乐器等虚拟乐器，并提供了专门的乐器轨用于加载和演奏这些虚拟乐器。同时，它还支持详细的MIDI编辑功能，包括音符编辑、速度调整等。 主题换肤：FL Studio 24新增了多样主题随心换的功能，用户可以通过调整色调、饱和度、亮度以及文本、仪表等的颜色来改变DAW的外观，使其更符合个人喜好。智能文件管理：该软件采用了智能的文件处理技术，可以自动整理项目文件，减少用户在管理文件上的时间和精力消耗。这一功能对于提高工作效率和保持工作环境的整洁非常有帮助。Mac原生支持：对于Mac用户来说，FL Studio 24新增了对苹果M1/M2芯片的原生支持。这意味着Mac用户在使用该软件时将获得更加流畅和稳定的性能体验。这一优化措施进一步提升了FL Studio在Mac平台上的可用性。多语言支持：除了简体中文外，FL Studio 24还支持英语等多种语言。这一功能使得不同国家和地区的用户都能更方便地使用该软件，无需担心语言障碍问题。 FL Studio 24适合各类音乐创作者和音频制作人员使用。具体来说，以下几类人群可能会发现FL Studio 247特别有用：
音乐制作人：对于专业的音乐制作人来说，FL Studio 24提供了一个全面的音乐制作环境。他们可以利用这个软件创建、编排、混音和制作完整的音乐作品。
作曲家：作曲家可以利用FL Studio 24中的虚拟乐器和丰富的音效库来创作旋律和和声，实现音乐创作的想法。
DJ和混音师：对于DJ和混音师来说，FL Studio 24提供了强大的混音和打碟功能，使得他们能够轻松地准备和进行现场表演。
声音设计师和音效师：声音设计师可以利用软件内置的多种音效处理器和合成器来设计和制作独特的声音和音效。
初学者和爱好者：尽管FL Studio 24功能强大，但它也适合初学者使用。软件界面直观，易于上手，而且社区支持广泛，有大量教程和资源可供学习。
音乐教育者：音乐教育者可以使用FL Studio 24来教授学生音乐制作和编曲的基础知识，因为软件的直观性和丰富的功能使其成为理想的教学工具。
音乐疗愈师：对于使用音乐进行疗愈的专业人士，FL Studio 24可以帮助他们创作和编辑具有特定频率和节奏的音乐，以适应不同的疗愈场景。
电子音乐家：电子音乐家会发现FL Studio 24特别适合制作电子音乐，因为它提供了广泛的合成器、采样器和效果器，能够创造出丰富的电子音乐声音。
FL Studio 24.1.1.4239中文版中文破解完整版百度网盘下载安装激活
本次小编带来的是FL Studio 21最新免费激活破解版，含激活文件和详细的安装破解图文教程，亲测可完美激活软件，需要的朋友赶紧来下载吧！
FL Studio 24.1.1.4239中文版最新版本（2024年7月8日）
FL Studio-FL 24 直装版中文版链接: https://pan.baidu.com/s/14UDt8YIi93LwwdqpEyUK7A 提取码: sm7i​
FL Studio Win版：https://souurl.cn/ZIwzHs
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/045f34148f746005604a77b686da0dff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d133c53544c62d6fb3f8b1b0645c46f7/" rel="bookmark">
			[算法题]平方数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目链接: 平方数
假如给出的数是 10, 那么 10 开平方约等于 3.16, 那么小于 3.16 且离其最近的整数为 3, 大于 3.16 且离其最近的整数为 4, 题意要求离 x 最近的完全平方数 y, 那么 3^2 和 4^2 与 10 的差值最小者即为解, 题解代码如下:
#include &lt;iostream&gt; #include &lt;cmath&gt; using namespace std; int main() { long n; cin &gt;&gt; n; long square_root = sqrt(n); long prev = pow(square_root, 2); long next = pow(square_root + 1, 2); cout &lt;&lt; ((n - prev &lt; next - n) ? prev : next) &lt;&lt; endl; return 0; } ps: sqrt() 为开平方函数, pow() 为求一个数的幂次方函数, 均为库函数.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d133c53544c62d6fb3f8b1b0645c46f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42dc8f90f5c29a352a2476c1a5dabf0a/" rel="bookmark">
			指针！！C语言(第二篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. 数组名的理解
二. 一维数组传参的本质
三. 冒泡排序法
四. 二级指针与指针数组
五. 字符指针变量与数组指针
一. 数组名的理解 在我们对指针有了初步的理解之外，今天我们来掌握一些新的知识就是数组与指针，第一个对数组名的了解，我们先来看一段代码：
int main() { int arr[5] = { 1,2,3,4,5 }; int* p = &amp;arr[0];//取出arr数组中第一个元素的地址 printf("&amp;arr[0]=%p\n", &amp;arr[0]); return 0; } 在上面的代码中我们可以看到我们取出了arr数组中的第一个元素的地址，并将其打印出来，而在在之前的知识中我们也提到过，其实数组名就是数组首元素的地址，为了验证这个结论的正确性，我们看下面一张图片：
从图我们可以看出来，&amp;arr[0]和arr的地址是一样的，所以说明数组名的地址就是数组首元素的地址，但是还是有两个例外的，比如说sizeof（arr），计算的并不是首元素的字节，而是整个数组的字节，再比如&amp;数组名，取出的是也整个数组。我们插入一段代码来看看具体的情况：
int main() { int arr[5] = { 1,2,3,4,5 }; int* p1 = &amp;arr[0]; int* p2 = arr; int* p3 = &amp;arr; printf("&amp;arr[0] =%p\n", &amp;arr[0]); printf("&amp;arr[0]+1 =%p\n", &amp;arr[0]+1); printf("arr =%p\n", arr); printf("arr+1 =%p\n", arr+1); printf("&amp;arr =%p\n", &amp;arr); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42dc8f90f5c29a352a2476c1a5dabf0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d8f9e81afc85efd8af0ebc4682ef92c/" rel="bookmark">
			ResNeSt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		paper：ResNeSt: Split-Attention Networks
official implementation：https://github.com/zhanghang1989/ResNeSt
third-party implementation：https://github.com/huggingface/pytorch-image-models/blob/main/timm/models/resnest.py
ResNeXt（具体介绍见https://blog.csdn.net/ooooocj/article/details/122394742）引入了"cardinality"超参，将特征图沿通道分为多个cardinal group，具体实现时对应组卷积的group数。本文又引入了一个"radix"超参，即在每个cardinal group内又将特征图进一步split成多个radix group，下图是ResNeSt block和SE-Net block以及SK-Net block的对比，关于这两篇文章的介绍见https://blog.csdn.net/ooooocj/article/details/122485342、https://blog.csdn.net/ooooocj/article/details/122683493。其中各个网络的split attention的具体实现方式不同。
下图是一个cardinal group内的split attention，首先通过卷积将特征图沿通道划分为多个splits，然后相加并进行全局平均池化，经过两个dense linear层并取softmax后每个radix split得到一个对应的权重，然后加权相加后得到最终输出。这样看起来其实和SENet比较像，区别在于SENet对整个输入特征图进行操作，然后特征图的每个通道得到一个对应的权重。而ResNeSt将特征图先分成多个cardinal group然后又将每个cardinal group划分成多个radix group，然后split attention是在每个cardinal group内进行的，最后每个cardinal group得到一个对应的权重。 ResNeXt有三种等价的实现方式，其中组卷积的实现最简洁。这里为了实现简便，作者也将原始的先cardinal group后radix group的方式等价转换成了下图的方式，其中将不同cardinal group中同一radix索引的group放到一起，变成了先radix后cardinal的分组形式，这样就可以通过组卷积来实现。
这里以timm中的实现为例，对照代码和图4讲解下具体实现。模型选择"resnest50d_4s2x40d"，即cardinality=2，radix=4。输入大小为(1, 3, 224, 224)。 首先看ResNestBottleneck类的forward函数，这里经过前面的stem处理后输入shape=(1, 64, 56, 56)。其中self.conv1为Conv2d(64, 80, kernel_size=(1, 1), stride=(1, 1), bias=False)，对应的就是图4每个radix group里第一个1x1卷积，按照图4实际应该有2x4=8列，即8个输出通道数为80/2/4=10的1x1卷积，这里将8个卷积合并到一起了。
接下来self.conv2就是split attention，代码如下。forward函数中self.conv对应的是图4中第二行蓝框的3x3卷积，这里每个卷积的输出通道数为c'/k=80/2=40，这里也是通过组卷积将8个卷积合并到一起了。然后当radix&gt;1时先reshape将radix维度分离出来，然后沿radix维度相加，对应图4中间那个+。然后x_gap.mean就是global pooling。self.fc1和self.fc2对应两个dense层，具体通过groups=k=2的1x1组卷积实现。然后通过radixsoftmax沿radix维度取softmax，这样每个radix group都得到一个对应的权重，最后x * x_attn加权求和得到split attention的最终输出。
class RadixSoftmax(nn.Module): def __init__(self, radix, cardinality): super(RadixSoftmax, self).__init__() self.radix = radix # 2 self.cardinality = cardinality # 1 def forward(self, x): # (1,320,1,1) batch = x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d8f9e81afc85efd8af0ebc4682ef92c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bf58206da2a5e927859f1b90333e15f/" rel="bookmark">
			AV1技术学习：Transform Coding
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对预测残差进行变换编码，去除潜在的空间相关性。VP9 采用统一的变换块大小设计，编码块中的所有的块共享相同的变换大小。VP9 支持 4 × 4、8 × 8、16 × 16、32 × 32 四种正方形变换大小。根据预测模式选择由一维离散余弦变换 (DCT) 和非对称离散正弦变换 (ADST) 核组合构成的一组可分离的二维变换类型。AV1继承了VP9中的变换编码方案，并在变换块大小和变换核方面扩展了其灵活性。
一、Transform Block Size AV1 将最大变换块大小扩展到 64 × 64。最小变换块大小仍然是 4×4。此外，还支持 N × N/2、N/2 × N、N × N/4、N/4 × N 的矩形变换块大小。
AV1 对所有的帧间编码块采用递归变换块划分方法，捕获局部固定区域，提高变换编码效率。
初始变换块大小与编码块大小匹配，除非编码块大小大于64 × 64，在这种情况下，使用 64 × 64 变换块大小。对于亮度分量，最多允许划分两次。N × N、N × N/2、N × N/4编码块的递归划分规则如下图所示。
帧内编码块继承了统一的变换块大小方法，即所有变换块具有相同的大小。与帧间编码的情况类似，最大变换块大小与编码块大小相匹配，并且对于亮度可以向下划分两次。方形和矩形编码块大小的可用选项如下图所示。
色度分量在统计上的变化要小得多。因此，变换块尺寸设置为使用可用最大变换块尺寸。
二、Transform Kernels 和 VP9 中每个编码块只有一个变换核类型不同，AV1允许每个变换块可以独立选择自己的变换核。将二维可分离变换核扩展为四个一维变换核的组合:DCT、ADST、flipped ADST (FLIPADST)和 identity transform (IDTX)，得到16个二维变换核。FLIPADST 是 ADST 变换核的反转。变换核的选择是基于统计和适应各种边界条件。DCT核被广泛应用于信号压缩，并且近似于一致相关数据的最优线性变换 Karhunen-Loeve 变换(KLT)。另一方面，ADST 近似于假设单侧平滑的 KLT，因此适合编码一些帧内预测残差。类似地，FLIPADST 从另一端捕获单侧平滑。此外 IDTX 可以适应在块中包含尖锐变换并且DCT和ADST都无效的情况。此外，IDTX与其他一维变换相结合，提供了一维变换本身，因此可以更好地压缩残差中的水平和垂直模式。下图给出了维度 N = 8 时四个一维变换核对应的波形。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bf58206da2a5e927859f1b90333e15f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74aa52fcb0971f49108024e747f95aee/" rel="bookmark">
			text-generation-webui在linux服务器上的部署和运行（保姆教程/踩坑记录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
text-generation-webui部署（Linux服务器）：
项目下载：
Conda环境配置：
text-generation-webui运行：
本地运行：
服务器转发：
模型载入（CodeLLama-7b为例）：
最近在学习LLMs（大语言模型）相关的论文和代码实践，想要借助text-generation-webui作为部署和微调的界面工具。由于本地的算力和资源有限，我想要将项目都部署在linux命令行式服务器上，由于在CSDN上没有完整的教程，故个人摸索了很久，最终成功部署并运行。其中遇到的主要问题有：
如何将服务器上的内容转发至本地网页打开；环境配置问题：模型加载过程中出现报错：ImportError:.../flash_attn_2_cuda.cpython-311-x86_64-linux-gnu.so: undefined symbol:_ZN3c104cuda9SetDeviceEi。 本篇将以部署CodeLLama-7b模型为例，手把手记录该webui的部署实践过程。
text-generation-webui部署（Linux服务器）： text-generation-webui简介：一款帮助LLMs实现本地化部署和微调的GUI界面式工具。
项目下载： github：https://github.com/oobabooga/text-generation-webui
首先需要从github上下载text-generation-webui项目至服务器，可以先本地下载再通过Xftp等工具传输（git下载因网络原因失败的话，可以尝试先从本地下载），也可以直接从服务器上进行下载，git指令如下：
git clone https://github.com/oobabooga/text-generation-webui.git 下载至服务器后，得到该项目的zip压缩包，通过unzip指令解压至所需目录即可得到项目文件。
unzip text-generation-webui-main Conda环境配置： 项目下载至服务器后，需要对项目所需环境进行配置（需要首先下载配置Anaconda，相关教程很多），该项目需要依赖python版本为3.10或3.11，其中[env_name]为环境名，自己命名一个即可。
conda create --name [env_name] python=3.11 进入到text-generation-webui目录中，激活该环境，下载该项目所需的依赖包。
conda activate [env_name] pip install -r requirements.txt 安装时间较长，安装好之后，同时需要安装该项目所需的启动文件，这里我们在linux服务器上运行，所以需要的文件是start_linux.sh，不同操作系统选择不同的安装文件。
bash start_linux.sh 至此，所需安装部分完成。
text-generation-webui运行： 本地运行： 通过运行server.py文件或start_linux.sh文件均可运行该项目：
python server.py ./start_linux.sh 可以看到，项目ui被转发至127.0.0.1:7860，倘若是图形化界面可以直接本地打开网页进入URL地址为127.0.0.1:7860即可在本地打开该webui界面。
服务器转发： 但这里我是在命令行服务器上运行，需要转发至本地PC网页中打开，所以这里需要添加--listen参数，转发并进行监听。
python server.py --listen 接下来就可以通过 [服务器地址：端口号] 进行访问了，但在这边我用的是学校内网的服务器，因此还需要服务器管理员帮我做一次转发，转发后即可通过[地址:端口号]在网页成功访问webui的网页界面了。
模型载入（CodeLLama-7b为例）： 可以看到，文件中有文件名为models的目录，我们需要把我们想运行的模型下载至models目录的文件夹下：
下载方式有很多，例如从huggingface中进行下载，具体可以参考这篇博客：【已解决】如何在服务器中下载huggingface模型，解决huggingface无法连接
下载完成后，打开webui中的models选项，然后选择该模型，点击load按钮：
顺利的话可以看到如下界面，模型被成功加载：
但不幸的是，我报错了（这里我用的别人的报错内容，但报错信息基本一致）：
Traceback (most recent call last): File "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74aa52fcb0971f49108024e747f95aee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b74dd3073abb56a2e888b544137c93d8/" rel="bookmark">
			QtQuick-QML类型系统-对象类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据类型可以是QML语言原生的，可以通过C++注册，可以由独立的QML文档作为模块进行加载，也可以由开发者通过C++类型或者定义QML组件来提供自定义的类型。
不过，无论如何，QML引擎都会保证这些类型的属性和实例的类型安全。
一、 基本类型 1. 基本类型 基本类型不能用来声明一个QML对象，例如int{}是不被允许的。
基本类型一般用于以下两种值：
单值（例如， int是单个数字，var可以是单个项目列表）；一个包含了一组简单的“属性-值”对的值（例如，size指定的值包含了width和height属性） 部分基本类型是引擎默认支持的，不需要导入语句即可使用；另外的基本类型则在模块中提供，需要导入才能使用。
另外，Qt全局对象提供了一些非常有用的函数操作基本类型的值，如darker()、fromatDate、hals()、md5()、qsTr()、quit()等，可以在帮助文档中索引QML Global Object关键字查看更多内容。
QML语言原生支持的基本类型
类型描述类型描述int整型url资源定位符bool布尔值，true/falselistQML对象列表real单精度浮点数var通用属性类型double双精度浮点数enumeration枚举值string字符串———————— QML其他基本类型由某些模块提供，如QtQuick模块提供的基本类型如下：
QtQuick模块提供的基本类型表
类型描述colorARGB颜色值，可以用多种方法表示fontQFont的QML类型，包含了QFont的属性值matrix4x4一个4X4的矩阵quaternion一个四元数，包含一个标量以及x、y和z属性vector2d二维向量，包含x和y两个属性vector3d三维向量，包含x、y和z共3个属性vector4d四维向量，包含x、y、z和w个属性date日期值point点值，包含x和y两个属性size大小值，包含width和height两个属性rect矩形值，包含x、y、width和height4个属性 2.基本类型的属性改变行为 一些一本类型也包含属性，如font类包含pixelSize、familt和bold。这里所说的属性与QML类型（如Rectangle）的属性不同：基本类型的属性没有自己的属性改变信号，只能为基本类型自身创建一个属性改变信号处理器。
例如：
Text{ //不可用 onFont.pixelSizeChanged: doSomething() //不可用 font{ onPixelSizeChanged: doSomething } //可用 onFontChanged: doSomething() } 另外，每当基本类型的一个特性改变时，该基本类型都会发射自身的属性改变信号，例如：
Text { onFontChanged: console.log("font changed") text: "hello Qt!" Text {id: otherText} focus: true //按下键盘数字键1,2,3都会调用onFontChanged信号处理器 Keys.onDigit1Pressed: font.pixelSize += 1 Keys.onDigit2Pressed: font.italic = !font.italic Keys.onDigit3Pressed: font = otherText.font } 二、JavaScript类型 QML引擎直接支持JavaScript对象和数组，任何标注JavaScript类型都可以在QML中使用var类型进行创建和存储。
例如下面的Date和Array类型：
Item { property var theArray: [] property var theDate: new Date() Component.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b74dd3073abb56a2e888b544137c93d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8953b161de94209429b15d92267ecd18/" rel="bookmark">
			非对称加密算法RSA的OpenSSL代码实现Demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 RSA简介
1.1 RSA算法介绍
1.2 RSA算法的速度与安全性
1.3 RSA存储格式
1.3.1 PKCS#1 标准主要用于 RSA密钥，其RSA公钥和RSA私钥PEM格式 1.3.2 PKCS#8 标准定义了一个密钥格式的通用方案，其公钥和私钥PEM格式
2 OpenSSL代码实现
2.1 生成密钥对
2.2 公钥加密-私钥解密
2.3 私钥加密-公钥解密
3 演示Demo
3.1 开发环境
3.2 功能介绍
3.3 下载地址
1 RSA简介 1.1 RSA算法介绍 RSA是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。
RSA加密算法是一种可逆的非对称加密算法，即RSA加密时候用的密钥（公钥）和RSA解密时用的密钥（私钥）不是同一把。基本原理是将两个很大的质数相乘很容易得到乘积，但是该乘积分解质因数却很困难。RSA算法被广泛的用于加密解密和RSA签名/验证等领域。
1.2 RSA算法的速度与安全性 比起AES等其它对称算法来说，RSA运算更为复杂，所以要慢得多。
从安全角度来讲，一般建议RSA密钥长度至少为2048位。世界上还没有任何可靠的攻击RSA算法的方式，如果密钥足够长或者没有密钥，想要RSA解密或者破解RSA解密基本是不可能的。RSA从提出到现在已近二十年，经历了各种攻击的考验，逐渐为人们接受，普遍认为是目前最优秀的公钥方案之一。
1.3 RSA存储格式 DER是RSA密钥的二进制格式，PEM是DER转码为Base64的字符格式，由于DER是二进制格式，不便于阅读和理解。一般而言，密钥都是通过PEM的格式进行存储的。
1.3.1 PKCS#1 标准主要用于 RSA密钥，其RSA公钥和RSA私钥PEM格式 // PKCS#1公钥格式 -----BEGIN RSA PUBLIC KEY----- BASE64 DATA... -----END RSA PUBLIC KEY----- // PKCS#1私钥格式 -----BEGIN RSA PRIVATE KEY----- BASE64 DATA.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8953b161de94209429b15d92267ecd18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/161988737fc5f5af400ee293089459b1/" rel="bookmark">
			[Spring] Spring配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌸个人主页:https://blog.csdn.net/2301_80050796?spm=1000.2115.3001.5343
🏵️热门专栏:
🧊 Java基本语法(97平均质量分)https://blog.csdn.net/2301_80050796/category_12615970.html?spm=1001.2014.3001.5482
🍕 Collection与数据结构 (92平均质量分)https://blog.csdn.net/2301_80050796/category_12621348.html?spm=1001.2014.3001.5482
🧀线程与网络(96平均质量分) https://blog.csdn.net/2301_80050796/category_12643370.html?spm=1001.2014.3001.5482
🍭MySql数据库(93平均质量分)https://blog.csdn.net/2301_80050796/category_12629890.html?spm=1001.2014.3001.5482
🍬算法(97平均质量分)https://blog.csdn.net/2301_80050796/category_12676091.html?spm=1001.2014.3001.5482
🍃 Spring(97平均质量分)https://blog.csdn.net/2301_80050796/category_12724152.html?spm=1001.2014.3001.5482
感谢点赞与关注~~~
目录 1. 配置文件快速上手2. 配置文件的格式3. properties配置文件的说明3.1 properties基本语法3.2 读取配置文件3.3 properties的缺点 4.yml配置文件说明4.1 yml基本语法4.2 yml使用进阶4.2.1 yml配置不同的数据类型及其null4.2.2 yml配置读取4.2.3 注意事项:value值佳单引号和双引号4.2.4 配置对象4.2.5 配置集合4.2.6 配置map 5. 综合性练习:验证码案例5.1 接口文档5.2 Hutool工具介绍5.3 后端代码5.4 前端代码 1. 配置文件快速上手 我们在前面讲解Tomcat的时候,默认的端口号是8080,如果我们有的程序访问的端口号也是8080的时候,这时候就会发生端口号冲突,所以我们需要通过配置文件来修改程序运行时的端口号.在项目创建的时候,就帮我们自动创建了一个配置文件.他的后缀是.properties.
我们点开配置文件修改程序的端口号:
spring.application.name=demo server.port=9090 运行程序:我们可以发现程序的端口号变成了9090.
这时候我们通过8080端口号访问其中的html页面的时候,就无法访问了.
2. 配置文件的格式 SpringBoot的配置文件有以下三种:
• application.properties
• application.yml
• application.yaml
其中yml格式和yaml格式其实是等同的.yml是yaml的缩写.
需要注意的一点是,配置文件的文件名只能是以上三个,文件名一旦修改,配置文件就会变成无效配置文件.
特殊说明: 如果properties和yml存在于同一个项目的时候,两个配置都会加载,但是如果配置文件内容有冲突的时候,.properties文件的优先级更高.虽然他们可以共存,但是我们在实际的也业务当中,我们一般只使用一个文件来配置,这样可以更好的维护. 3. properties配置文件的说明 properties配置文件是最早期的配置文件格式，也是创建SpringBoot项目默认的配置文件
3.1 properties基本语法 properties是以键值的形式配置的,单词和单词之间用.分割,就像导包一样.key和value之间是以=连接的.比如:
spring.application.name=demo server.port=9090 spring.datasource.url=jdbc:mysql://127.0.0.1:3306/mycnblog?characterEncoding=utf8&amp;useSSL=false spring.datasource.name=root spring.datasource.password=qwe123524 [提示] 配置文件中可以通过在前面加#来注释信息.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/161988737fc5f5af400ee293089459b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee0a4d17cf8afe0ba3c8df5b6623e38a/" rel="bookmark">
			【JAVA】数据类型及变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎉欢迎大家收看，请多多支持🌹
🥰关注小哇，和我一起成长🚀个人主页🚀
Java的数据类型 可以分为两类，基本数据类型和引用数据类型
基本数据类型有4类8种，4类分别是整型 浮点型 字符型 布尔型，
8种是byte、short、int、long、double、char、boolean
8种基本数据类型 字节型byte内存占用1字节短整型short2字节整型int4字节长整型long8字节单精度浮点型float4字节双精度浮点型double8字节字符型char2字节布尔型boolean无明确规定 在Java中数据类型大小固定，这与c中不同
整型 整型默认为int，int 的包装类型是Integer，int类型所能表示的数据范围：
//打印最大值和最小值
System.Out.println(Integer.MAX_VALUE);
System.Out.println(Integer.MIN_VALUE);
short、byte、long的包装类型都是将首字母大写，最大值都是 包装类型.MAX_VALUE，最小值都是 包装类型.MIN_VALUE。
long类型的数字后要加L或l，一般写大写L（与1区分）。
浮点型 浮点数的存储方式与在C语言中的存储方式相同。浮点型默认为double，单精度浮点数在后面加f或F。
字符型 char占两个字节，包装类型为Character。
与C语言中用ASCII码值来表示字符不同，Java中用Unicode表示字符。计算机中的字符本质仍是数字。
布尔型 只有两种取值，false表示假和true表示真，与C语言中不同的是，Java中不能用0表示假，非0表示真。包装类型为Boolean。
类型转换 分为自动类型转换（隐式）和强制类型转换（显式）。
自动类型转换的特点是:数据范围小的转为数据范围大的时会自动进行
int a = 10; long b = 5L; a=b;//编译报错，long的范围比int大，会丢失数据 b=a;//将int的a转换为long类型 强制类型转换特点：将范围大的类型赋给范围小的，可能有精度丢失
类型提升 类型不同的数据间进行运算时，类型小的数据会提升为类型大的数据
int和long之间：
int a = 3；
long b = 4；
int c = a + b；//编译报错，a+b时a提升为long类型，结果也为long类型，赋给int可能会丢失数据
long d = a + b；//编译成功
对于short, byte 这种比4个字节小的类型, 会先提升成4个字节的int , 再运算 ：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee0a4d17cf8afe0ba3c8df5b6623e38a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46538e6497a189cfdab708382702ac1f/" rel="bookmark">
			【Python正则表达式】：文本解析与模式匹配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.正则表达式2. re模块3.修饰符3.元字符3-1 字符匹配元字符3-2 重复次数限定元字符3-3 字符集合匹配元字符3-4 分组元字符3-5 边界匹配元字符3-6 字符类别匹配元字符 4.技巧4-1 贪婪与非贪婪 5.案例 1.正则表达式 正则表达式面向什么样的问题？
1、判断一个字符串是否匹配给定的格式（判断是不是邮箱或者电话号码） 数据校验
2、从一个字符串里面根据指定规则提取信息（抓取页面中的链接或者其它信息） 数据提取
2. re模块 正则表达式写出来后需要使用，那么需要使用re模块进行使用，提取及验证等操作，re模块为内置模块，使用时需要导包 ----- import re
常用方法分为：findall， match， search # re.findall() 是 Python 中 re 模块提供的一个函数，用于在字符串中查找所有满足指定正则表达式的子串，并返回一个列表。下面我将详细介绍 re.findall() 的使用方法及其相关参数。 """ re.findall(pattern, string, flags=0) pattern 是要匹配的正则表达式； string 是要在其中进行匹配的字符串； flags 参数可以指定正则表达式的匹配模式，如是否忽略大小写等。 """ import re # 定义正则表达式 '\d+'，它可以匹配一个或多个数字字符 pattern = r'\d+' # 定义字符串 string = 'The price of the apple is 2 dollars, and the price of the orange is 1 dollar.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46538e6497a189cfdab708382702ac1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d659a4256badc6430a9138fdf81b8136/" rel="bookmark">
			Tuxera 2024 NTFS for Mac 破解版安装、密钥下载与激活教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当您获得一台新 Mac 时，它只能读取 Windows NTFS 格式的 USB 驱动器。要将文件添加、保存或写入您的 Mac，您需要一个附加的 NTFS 驱动程序。Tuxera 的 Microsoft NTFS for Mac 2023是一款易于使用的软件，可以在 Mac 上打开、编辑、复制、移动或删除存储在 Windows NTFS 格式 USB 驱动器上的文件，使这一切成为可能。
Tuxera2024功能特性 1、轻松转换驱动器
无论使用Windows PC还是Mac，可以直接使用同一个USB设备，Tuxera NTFS为NTFS格式的磁盘增加了完整的读写功能。
2、保全重要内容
对于传输重要文件可以完全放心，Tuxera NTFS领先的驱动程序可完整无损地存储视频，图片，重要文档和其他文件。
3、文件传输安全迅速
Tuxera NTFS智能缓存技术提供了快速，持续的文件传输速度，使得Mac和外部磁盘传输文件无需长时间的等待。
4、技术爱好者的高级功能
Tuxera是市场上唯一包含对NTFS扩展属性支持的NTFS驱动程序。Tuxera NTFS配套应用程序Tuxera Disk Manager，可轻松格式化，检查和修复NTFS驱动器。此外，Tuxera NTFS for mac可方便地与双启动或虚拟机设置配合使用。
Tuxera2024 NTFS for Mac 软件特色
1.在Mac上读写Windows NTFS文件系统
NTFS for Mac提供完全读写NTFS磁盘功能，并兼容跨越Mac和Windows平台。
实现苹果Mac OS X系统读写Microsoft Windows NTFS文件系统，在硬盘、U盘等外接设备中进行全面访问、删除、修改等相关操作。
2.快速全面的数据保护
NTFS for Mac提供了最快的NTFS文件传输速度，同时保护您的数据是最新的智能缓存。
3.超强兼容性
Tuxera NTFS for Mac 2024简体版支持所有从OS X 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d659a4256badc6430a9138fdf81b8136/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39ed385c9b1515b5e6802f809a246d34/" rel="bookmark">
			数据结构【没头单链表】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
​
概念与结构
结点
链表的性质
链表的打印分析
实现单链表：
创建单链表数据
申请空间
尾插数据
打印
头插数据
尾删
头删
查询数据
指定位置前插入数据
指定位置后插入数据
删除pos节点
删除pos后面的节点
销毁
链表的分类
链表说明：
概念与结构 概念：链表是⼀种物理存储结构上⾮连续、⾮顺序的存储结构，数据元素的逻辑顺序是通过链表中的 指针链接次序实现的。
这个单链表我们需要一个整行或其他类型的存放数据，还有一个结构体指针，结构体指针连接下一个节点。
结点 与顺序表不同的是，链表⾥的每节"⻋厢"都是独⽴申请下来的空间，我们称之为“结点/结点” 结点的组成主要有两个部分：当前结点要保存的数据和保存下⼀个结点的地址（指针变量）。
图中指针变量plist保存的是第⼀个结点的地址，我们称plist此时“指向”第⼀个结点，如果我们希望 plist“指向”第⼆个结点时，只需要修改plist保存的内容为0x0012FFA0。 链表中每个结点都是独⽴申请的（即需要插⼊数据时才去申请⼀块结点的空间），我们需要通过指针 变量来保存下⼀个结点位置才能从当前结点找到下⼀个结点。
链表的性质 1、链式机构在逻辑上是连续的，在物理结构上不⼀定连续
2、结点⼀般是从堆上申请的
3、从堆上申请来的空间，是按照⼀定策略分配出来的，每次申请的空间可能连续，可能不连续
结合前⾯学到的结构体知识，我们可以给出每个结点对应的结构体代码：
假设当前保存的结点为整型：
struct SListNode { int data; //节点数据 struct SListNode* next; //指针变量⽤保存下⼀个节点的地址 }; 当我们想要保存⼀个整型数据时，实际是向操作系统申请了⼀块内存，这个内存不仅要保存整型数 据，也需要保存下⼀个节点的地址（当下⼀个节点为空时保存的地址为空）。 当我们想要从第⼀个节点⾛到最后⼀个节点时，只需要在当前节点拿上下⼀个结点的地址就可以了。
链表的打印分析 给定的链表结构中，如何实现结点从头到尾的打印？
思考：当我们想保存的数据类型为字符型、浮点型或者其他⾃定义的类型时，该如何修改？
实现单链表： 创建3个文件，slist.h头文件，slist.c存放函数的文件，test.c测试文件
创建单链表数据 arr用来存放数据，p指向下一个节点
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;assert.h&gt; typedef int data; typedef struct slist { //存放数据 data* arr; //指向下一个节点 struct slist* p; }SL; 在测试文件创建链表为NULL
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39ed385c9b1515b5e6802f809a246d34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f1cee7d37150070d917bdaa1187f6ad/" rel="bookmark">
			算法学习6——贪心算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是贪心算法？
贪心算法是一种在每一步选择中都采取当前状态下最优或最有利的选择的算法。其核心思想是通过一系列局部最优选择来达到全局最优解。贪心算法广泛应用于各种优化问题，如最短路径、最小生成树、背包问题等。
贪心算法的特点
局部最优选择：每一步都做出在当前情况下最优的选择。无后效性：一旦某个状态被确定，就不会再被改变或回溯。逐步构造解决方案：通过一系列的选择逐步构建出最终的解决方案。 经典例子及其Python实现
1. 活动选择问题 问题描述：给定一组活动，每个活动有一个开始时间和结束时间，要求选择尽可能多的互不重叠的活动。
贪心策略：每次选择结束时间最早且不与已选择活动重叠的活动。
实现过程：
将所有活动按结束时间排序。依次选择结束时间最早且不与已选择活动重叠的活动。 Python代码：
def activity_selection(activities): # 按结束时间排序 activities.sort(key=lambda x: x[1]) # 选择活动 selected_activities = [activities[0]] last_end_time = activities[0][1] for start, end in activities[1:]: if start &gt;= last_end_time: selected_activities.append((start, end)) last_end_time = end return selected_activities # 示例 activities = [(1, 4), (3, 5), (0, 6), (5, 7), (3, 9), (5, 9), (6, 10), (8, 11), (8, 12), (2, 14), (12, 16)] print(activity_selection(activities)) 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f1cee7d37150070d917bdaa1187f6ad/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/124/">«</a>
	<span class="pagination__item pagination__item--current">125/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/126/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>