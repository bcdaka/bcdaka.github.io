<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea273118e92b30ab15f1e6b75f737650/" rel="bookmark">
			【Midjourney】Midjourney全面开放网站版，所有用户每天可免费生成25次
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Midjourney一直作为AI文生图领域的龙头老大，最近对面对市场上日益增长的竞争压力，尤其是来自 Flux 的挑战，终于向所有用户开放官方网站。尽管还处于早期阶段，但为了吸引更多用户体验，它暂时是完全免费的。
下面是Midjourney 官方发布了一段展示其全新 Web 版本的视频，首次揭示了这个在线编辑器的强大功能。
【Midjourney】Midjourney全面开放网站版
关于Midjourney Web使用限制，用户每天可以生成25次，一次4张图，也就是说每天可以白嫖100张图。对于轻度使用用户而言，已经完全够用了。即使是重度使用者，也可以通过多账号的方式无限白嫖，还是很香的~
虽然可以免费使用，Midjourney Web还是有一些亮点：
**文本生成图像：**一次可以生成 4 张高质量图片，让创意更加丰富多样。图像风格引用：用户可以轻松引用其他图片的风格，提升作品的一致性和美感。**Chat 功能：**支持与其他用户一起实时生成图像，协作创作更具乐趣。**Inpaint（重绘）与扩图功能：**可以对图像的特定部分进行重绘，同时扩展画布，让作品更加完美。**社区提示词复用：**无需复制或拖拽，直接利用社区内的提示词，创作过程更加流畅高效。 Midjourney Web使用 首先打开Midjourney Web 网站：https://www.midjourney.com/imagine，使用Google或Discord账号登录。
在输入框这里输入你的提示词就Ok了，提示词越多越详细，生成的图片就越符合你的想法。
如果你只有一个大概的风格，但不知道画什么，可以在探索界面找灵感，找你想要参考的图片，点击图片里面，直接选择提示词，提示词就会直接复制到文本输入框里。这是它社区提示词复用的一个优点。
或者直接点这个也能复制过来。
用户能够重新绘制图像的选定区域，对特定细节进行修正或强化，并且可以延伸画布的边缘。这种灵活性确保了即便面对繁琐的修改和扩展工作，用户也能在不牺牲图像整体品质的前提下，轻松地完成它们，从而享受到更高层次的创意自由。
更强大的是，Midjourney Web现在支持融图功能，只需选择两张图片，轻轻一点，即可生成一张全新的融合图像。这无疑能给创作者带来更多的灵感，实现更多的创意。
如果你不觉得免费的生成次数不够用，又不想去多弄几个账号，可以考虑花钱订阅。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8428f131e85d8e06b6c4e32bc24697a/" rel="bookmark">
			Apache Spark Connect Go 使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache Spark Connect Go 使用指南 spark-connect-goApache Spark Connect Go: 是一个开源项目，用于连接 Apache Spark 和 Go 语言。它可以帮助开发者使用 Go 语言处理 Spark 数据。适合有 Spark 和 Go 语言开发经验的开发者。特点：Spark 和 Go 语言连接，易于使用。项目地址:https://gitcode.com/gh_mirrors/spa/spark-connect-go 项目介绍 Apache Spark 是一个用于大规模数据处理的开源统一分析引擎，支持批处理、交互式查询（Spark SQL）、机器学习（MLlib）和图计算（GraphX）。而 spark-connect-go 是一个非官方的 Go 语言客户端库，旨在使 Go 应用程序能够无缝连接到 Apache Spark，并利用其强大的数据分析能力。此项目使开发者能够在 Go 环境中轻松地执行 Spark SQL 查询、管理数据等操作，从而拓展了 Spark 的生态系统至 Go 语言领域。
项目快速启动 要快速开始使用 spark-connect-go，首先确保你的系统上安装了 Apache Spark 并且设置了相应的环境变量。接下来，通过以下步骤来体验基本的 Spark 连接与查询：
步骤 1: 安装 spark-connect-go 包 通过 Go 的包管理工具获取 spark-connect-go：
go get -u github.com/apache/spark-connect-go 步骤 2: 编写并运行示例代码 创建一个新的 Go 文件，例如 spark_query.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8428f131e85d8e06b6c4e32bc24697a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a917949b3615cd27e3c3d4447d710b6/" rel="bookmark">
			在 eggjs 中忽略 CSRF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Egg.js 中，如果你希望在某些情况下忽略 CSRF（跨站请求伪造）保护，可以通过以下几种方式实现：
1. 在特定路由中禁用 CSRF 检查 你可以在特定的路由中禁用 CSRF 检查。以下是如何在路由中禁用 CSRF 的示例：
// app/router.js module.exports = app =&gt; { const { router, controller } = app; // 禁用 CSRF 检查的路由 router.post('/api/no-csrf', controller.dataController.noCsrf); }; 2. 创建一个中间件来禁用 CSRF 你可以创建一个中间件来禁用 CSRF 检查。以下是如何实现的示例：
创建中间件
在 app/middleware 目录下创建一个名为 noCsrf.js 的文件：
// app/middleware/noCsrf.js module.exports = () =&gt; { return async (ctx, next) =&gt; { // 清空 CSRF 令牌，禁用 CSRF 检查 ctx.csrf = ''; await next(); }; }; 注册中间件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a917949b3615cd27e3c3d4447d710b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f0f11590879cbc283c46f9c3d931317/" rel="bookmark">
			Apache Toree：连接Jupyter与Apache Spark的桥梁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache Toree：连接Jupyter与Apache Spark的桥梁 incubator-toreeApache Toree: 是一个开源的Scala和Spark Notebook，用于交互式地编写和执行Spark代码。适合数据科学家、数据工程师和Spark开发者。特点包括提供简单易用的Web界面、支持多种Spark版本和配置、支持多种数据源和格式、易于集成到现有的数据处理流程中以及提供丰富的文档和社区支持。项目地址:https://gitcode.com/gh_mirrors/in/incubator-toree 项目介绍 Apache Toree 是一个强大的 Jupyter Notebook 内核，旨在为使用 Scala 语言连接和操作 Apache Spark 的交互式应用程序提供基础。通过 Toree，用户可以在 Jupyter Notebook 环境中直接编写和执行 Spark 任务，实现数据的高效处理和分析。
项目技术分析 Apache Toree 实现了最新的 Jupyter 消息协议（5.0），确保与最新版本的 Jupyter/IPython（3.2.x及以上）无缝集成。它支持 Scala 编程语言，并提供了一个接口，允许客户端与 Spark 集群进行交互。用户可以发送库和代码片段，这些片段会在预配置的 Spark 上下文中被解释和执行。
项目及技术应用场景 Apache Toree 适用于以下场景：
数据探索与分析：在 Jupyter Notebook 中进行交互式数据探索，利用 Spark 进行大规模数据处理。Spark 任务开发：直接在 Jupyter 环境中定义和运行各种 Spark 作业，简化开发流程。实时监控与流处理：启动和监控 Spark 流处理任务，实时收集和分析数据。依赖管理：加载运行代码所需的必要依赖，确保环境的一致性。 项目特点 无缝集成：与 Jupyter Notebook 和 Apache Spark 的最新版本完全兼容。高效交互：支持 Scala 语言，提供流畅的交互式编程体验。灵活构建：使用 make 作为构建、测试和打包的入口点，支持 Docker 容器化部署。易于安装：通过 pip 安装，简单快捷，支持多种 Spark 版本。社区支持：活跃的社区和开发者支持，提供丰富的文档和示例。 结语 Apache Toree 是一个强大的工具，它将 Jupyter Notebook 的交互式编程环境与 Apache Spark 的大规模数据处理能力完美结合。无论你是数据科学家、开发者还是研究人员，Apache Toree 都能为你提供一个高效、灵活的数据分析平台。立即尝试，体验前所未有的数据探索之旅！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f0f11590879cbc283c46f9c3d931317/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27b9583d4769e3959ed36ae65b157632/" rel="bookmark">
			京东的AIGC革新之旅：通过JoyCoder实现研发提效 | 新程序员
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【导读】从需求分析、设计编码到测试运维，AI已经逐步渗透到软件开发的各个环节，如何切实针对研发场景进行提效，是业内每个企业都在思考的问题。本文作者详细分析了AI在研发中的实际应用，并分享了JoyCoder与京东内部工具结合的实际案例，展示了AIGC在提升研发效能方面的巨大潜力。
本文出自 2024 全球软件研发技术大会中的演讲，同时收录于《新程序员 008》。《新程序员 008》聚焦于大模型对软件开发的全面支撑，囊括 Daniel Jackson 和 Daniel Povey 等研发专家的真知灼见与“AGI 技术 50 人”栏目的深度访谈内容，欢迎大家订阅年卡。
作者 | 刘兴东
责编 | 郑丽媛
出品丨新程序员编辑部
近年来大模型特别火热，诸多公司在这一领域投入了大量的研究精力，各种基于大模型的应用场景也应运而生，涵盖了健康、金融、教育等多个领域，当然也包括软件行业。在这场由生成式AI技术引领的软件行业革命中，京东也正在进行一场前所未有的AIGC革新之旅。
在这场技术驱动的变革中，京东自主研发的智能编程助手JoyCoder，成为了推动研发效率飞跃的关键力量。接下来，我将深入解析京东如何通过JoyCoder实现研发提效的具体实践，以及这一过程中所展现出的技术创新。
AIGC对软件行业的影响
自从AIGC成为热点以来，它对整个软件行业都产生了深远的影响。无论是软件的开发、测试、部署、维护还是使用方式，都在不同程度上发生了变化。例如在代码层面，AI技术已经能够生成软件代码，包括代码审查在内的许多环节都与AIGC密切相关。同时，在软件质量和安全性方面也因AIGC的出现，发生了相应改进。例如，自动化的单元测试以及软件漏洞分析技术能够帮助开发者提高效率，尽早发现并修复相关漏洞。
总体而言，AIGC在开发成本、效率和用户体验上都带来了显著提升，有助于促进行业发展——但同时，这个过程中也伴随着一系列的风险和挑战：
使用AIGC后，如何确保其生成的内容准确可靠，成为了我们必须面对的问题。这要求我们在技能上做出相应的迭代和提升，以更好地管理和使用AIGC的输出能力。与此同时，我们也需要提升工具的能力，以实现与内部工具的良好兼容。
若过度依赖AIGC生成的内容，可能会忽视对其准确性和创造性的审查。因此，我们要不断完善并补充自身技能，以确保在使用AIGC时能提升生产力，而不是因过度依赖而导致生产力下降。
如何借助AIGC进行研发场景提效
如上文所说，AIGC与我们最为相关的场景还是在研发领域中的应用。如图1所示，以DevOps为例，它涵盖了从需求开始直到产品上线和部署发布的全过程。那么，AIGC如何在DevOps工具中发挥生产力呢？这是整个行业都在思考和探索的问题。
图1 研发全流程AIGC提效
从需求分析开始，我们可以通过AIGC与大模型交互，使用自然语言生成需求文档，尝试让大模型理解文档内容，区分功能性需求、非功能性需求和安全性能需求。基于对需求的前期理解，大模型能够更准确地帮助用户定位需求，使需求文档更加清晰，从而在需求阶段和理解阶段做得更为细致。
到了系统开发阶段，这是一个从准备、开发到完成直至上线的迭代过程。基于对需求的理解，AIGC可生成相关代码文档和代码解释；在开发过程中，可利用AIGC生成代码片段，减少手动编写的工作量；此外，编写单元测试时常让研发人员感到头疼，这部分也可借助AIGC来完成，以节省大量时间和精力。在研发后期，AIGC还能帮助检测代码中的安全漏洞，快速定位和修复调试过程中的报错。哪怕是几年后的系统迭代更新，AIGC也能协助进行代码优化工作，例如从Vue 2升级到Vue 3，或者从Java转换到其他编程语言。
到了系统测试阶段，AIGC可以根据前期对需求和代码片段的理解，生成自动化单元测试、测试文档和测试用例，提高测试效率和准确性。在缺陷分析时，也能更快地找到并修复缺陷。
最后在系统上线后，我们还需要考虑如何在后期提供辅助。AI Office这一概念在行业里已提出多年，如何基于系统日志的产生来进行指标聚类，进而通过人工标注来快速识别指标是否异常，这也是AIGC可以发挥作用的地方。通过指标之间的关联性，比如发现502报错，不一定是前端网关问题，也可能是后端服务故障，AIGC可以帮助找到问题的具体根因。
若进一步聚焦到DevOps流程中的编程环节，AIGC也展现出了它强大的应用潜力。举例来说，在软件开发早期，我们常需编写大量重复的增删改查（CRUD）操作和工具类代码。面对这些重复性高的工作，如何提升效率并避免传统开发中的低效和错误，成为了亟待解决的问题。
在没有智能代码生成和代码标准的情况下，开发者可能因缺乏辅助工具而编写出错误代码，同时也不易了解公司内部的最佳实践或通用代码规范。这不仅造成了信息孤岛，也影响了新成员融入团队的速度和效率。
然而，AIGC的引入为这一困境带来了转机。利用自然语言生成技术，AIGC能够辅助生成相关的代码片段，从而加速开发过程。在代码重构、优化和合理性检查方面，AIGC同样能发挥重要作用。通过深度理解内部文档和代码库，AIGC能在开发者编写代码时，迅速定位并推荐公司内部或外部的相似通用能力，有效避免重复开发。
此外，AIGC还能根据代码库和上下文进行智能推理，为开发者提供代码辅助，使编写过程更加高效和合理。这一转变不仅有助于提升开发效率，也能推动从传统低效开发模式向基于AIGC的高效开发模式的转变——在这种思考下，京东推出了基于大模型的智能编码应用JoyCoder。
JoyCoder的产品架构与能力介绍
如图2所示，从京东JoyCoder的产品架构图来看，其底层服务主要分成两个部分：大模型和行云DevOps平台。
图2 JoyCoder的产品架构
在大模型层，主要包括JoyCoder Lite、JoyCoder Pro和JoyCoder-Base模型。其中JoyCoder Lite和JoyCoder Pro负责关于会话方面的大模型应用，JoyCoder Lite以7B的轻量级设计为用户提供快速高效的操作体验，JoyCoder Pro专注于提供更精准的服务。至于JoyCoder-Base，则是一个用于代码推理的模型。
尤为值得一提的是，JoyCoder支持配置接入其他模型，即不局限于自有模型，允许接入来自不同供应商的各种大模型，如百度文心、清华智谱以及GPT等。这种开放的态度不仅丰富了JoyCoder的应用场景，也使其能够为用户提供更加精准和多元化的服务。
引入更多模型后，如何有效管理这些模型成为了一个挑战。为此，我们创新性地为JoyCoder封装了一层模型网关：在模型对接层面直接与大模型进行交互，而无需关注上层应用，以此简化管理流程，同时确保用户信息的安全与合规。同时，模型网关还具备用户鉴权、涉黄涉暴信息拦截以及日志记录等功能，为未来的审计和内容规性检查提供了有力支持。最后如果有相关报警，也可以通过网关来进行处理。
在兼容性方面，JoyCoder同样表现出色，其插件已支持多系统平台（如Windows、Android、鸿蒙）以及多种编辑器和主流编程语言。此外，在代码智能生成、人机交互和DevOps平台上，我们也进行了详细的场景化划分。最终，通过管理后台的用户管理和数据统计，我们可得到用户活跃度、采纳率和调用次数，以此对大模型进行更有针对性的调整和优化，进一步提升其采纳率和优化效果。
基于以上的产品架构，JoyCoder在整套研发流程（从需求、设计、编码、测试到上线）中，几乎每个环节都能帮助开发者提高效能：
通过人机会话，能将需求描述更加标准化，帮助用户更好地整理和明确需求。
在设计阶段，能通过自然语言生成对应的代码模块。
在代码编辑区，可以用代码补全功能对编码过程进行辅助，减少重复劳动；代码注释功能能自动生成注释内容，减轻开发者负担；代码解释和代码评审能让研发人员快速理解代码，让新成员快速熟悉代码，提高工作效率。
在测试阶段，JoyCoder能快速生成单元测试和接口文档，减轻开发者写单测和文档的负担。它还能对问题代码提出修复建议，并将安全扫描和规约检测左移到编码阶段。
当然，对于AI编码应用来说，安全防控也是不可忽视的一环。在内容安全方面，JoyCoder能够识别并过滤敏感词和不良信息；在数据安全方面，它则通过大模型统一网关对上传的数据进行严格把关，防止身份信息、银行卡号等敏感信息的泄露；在安全审计方面，JoyCoder会生成安全日志记录，记录输入敏感信息的用户标识、用户IP、设备号和输入的敏感词，并提示管理员该用户的操作涉及数据安全。
基于以上AI能力，目前京东内部已有约12,000名研发人员在使用JoyCoder，占整体研发人员的70%。这些用户在代码续写、自然语言片段生成、单元测试和推理等方面的采纳率达到了30%以上。整体提效达到 20%以上，大大提升了研发效率和标准化程度。
JoyCoder与京东内部工具结合的最佳实践
然而，无论是产品架构还是能力建设，均仍属于理论层面——AI本身如同一座孤岛，要想真正发挥其作用，需要与工具进行结合并实践。
纵观整个开发过程，例如需求理解、编译、构建和部署等方面，实际上都需要AI能力的下沉。于是在京东内部，我们借助JoyCoder在DevOps过程中进行了全新的能力建设。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27b9583d4769e3959ed36ae65b157632/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dd82d37b6658c6c0557101d841ff2b1/" rel="bookmark">
			单片机-STM32 ADC应用（五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.ADC模数转换 模拟数字转换器即A/D转换器，或简称ADC，通常是指一个将模拟信号转变为数字信号的电子元件。通常的模数转换器是将一个输入电压信号转换为一个输出的数字信号。由于数字信号本身不具有实际意义，仅仅表示一个相对大小。故任何一个模数转换器都需要一个参考模拟量作为转换的标准，比较常见的参考标准为最大的可转换信号大小。而输出的数字量则表示输入信号相对于参考信号的大小。
模拟信号：连续的，不可突变的
模拟量是指变量在一定范围连续变化的量；也就是在一定范围（定义域）内可以取任意值（在值域内）。
数字信号：不连续，间断的
数字量是分立量，而不是连续变化量，只能取几个分立值，如二进制数字变量只能取两个值。
精度：也成为分辨率，我们当前使用的AD转换精度是12位，
12位的精度：值得是转换的数据2进制位数，区间：0--4095
AD转换的本质：将电压进行转换，转换为数字量
设备正常供电：3.3v
将3.3V分成4096份，精度：3.3/4096；（变化的步进值）
参考模拟量：用于比较的，参考电压也是3.3V
通道数量：16个外部通道
AD转换的框图： STM32F103ZET6单片机中的ADC控制器总共：3个
注入组和规则组：
2.AD转换的特性 AD转换的时钟： ADC的输入时钟不得超过14MHz，它是由PCLK2经分频产生;
AD转换的精度和转换时间有关系的，如果频率过高，会导致转换时间太短，精度降低了。
通道选择： 转换方式： 单次转换 ：单次转换模式下， ADC只执行一次转换
连续转换：在连续转换模式中，当前面ADC转换一结束马上就启动另一次转换。
扫描模式 此模式用来扫描一组模拟通道。
主要是用于多通道中，用于扫描不同的通道
扫描模式可通过设置ADC_CR1寄存器的SCAN位来选择。一旦这个位被设置， ADC扫描所有被ADC_SQRX寄存器(对规则通道)选中的所有通道。
间断模式： 数据对齐： 我们主要使用的是右对齐。
可编程的通道采样时间 ADC使用若干个ADC_CLK周期对输入电压采样，采样周期数目可以通过ADC_SMPR1和ADC_SMPR2寄存器中的SMP[2:0]位更改。每个通道可以分别用不同的时间采样
总的转换时间：
TCONV = 采样时间+ 12.5个周期（转换需要时间）
校准： ADC有一个内置自校准模式。校准可大幅减小因内部电容器组的变化而造成的准精度误差。
通过设置ADC_CR2寄存器的CAL位启动校准。一旦校准结束， CAL位被硬件复位，可以开始正常转换。建议在上电时执行一次ADC校准。
AD转换中的校准不是必须的，校准会增加数据的准确度。
3.AD转换的使用 原理图： 光敏--PF8
电位器---PF7
IO口的复用功能： 程序配置： 1.时钟--ADC3时钟，F端口
2.配置--PF7--输入
模拟输入--AD转换
3.ADC工作方式
时钟分频处理、通道选择、单次\连续 、校准、对齐方式、中断（可选）使能
时钟的分频处理： 具体的应用：
校验部分： 软件启动转换： 单次转换需要每次开启转换
设置规则转换通道： 规则组中用于设置使用的通道号
获取结果：
读取数据：
得到的结果是一个数字量：
对于我们的滑动变阻器：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dd82d37b6658c6c0557101d841ff2b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52b638ef82e6c6482420a7a868a5c797/" rel="bookmark">
			如何在 CentOS 6 上安装 Nagios
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站。
Status: 已弃用 本文涵盖的 CentOS 版本已不再受支持。如果您目前正在运行 CentOS 6 服务器，我们强烈建议升级或迁移到受支持的 CentOS 版本。
原因: CentOS 6 已于2020年11月30日到达生命周期终点（EOL），不再接收安全补丁或更新。因此，本指南已不再维护。
请参阅替代方案:
本指南可能仍然作为参考有用，但可能不适用于其他 CentOS 版本。如果有的话，我们强烈建议使用针对您正在使用的 CentOS 版本编写的指南。
以下 DigitalOcean 教程可能会立即引起您的兴趣，因为它概述了在 CentOS 7 服务器上安装 Nagios： 如何在 CentOS 7 上安装 Nagios 4 并监视您的服务器 步骤 1 - 在监控服务器上安装软件包 rpm -Uvh http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm rpm -Uvh http://rpms.famillecollet.com/enterprise/remi-release-6.rpm yum -y install nagios nagios-plugins-all nagios-plugins-nrpe nrpe php httpd chkconfig httpd on &amp;&amp; chkconfig nagios on service httpd start &amp;&amp; service nagios start 我们还应该在此 droplet 上启用 SWAP 内存，至少为 2GB：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52b638ef82e6c6482420a7a868a5c797/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a9b00fc80e0ebd6c0ae97311039c526/" rel="bookmark">
			数据仓库系列19：数据血缘分析在数据仓库中有什么应用?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你是否曾经在复杂的数据仓库中迷失方向，不知道某个数据是从哪里来的，又会流向何方？或者在处理数据质量问题时，无法快速定位根源？如果是这样，那么数据血缘分析将会成为你的得力助手，帮助你在数据的海洋中找到明确的航向。
目录 引言：数据血缘分析的魔力什么是数据血缘分析？数据血缘的核心概念 数据血缘分析在数据仓库中的应用1. 数据质量管理实际应用案例 2. 影响分析实际应用案例 3. 合规性和审计实际应用案例 4. 数据治理实际应用案例 5. 优化数据流程实际应用案例 6. 数据溯源和问题诊断实际应用案例 7. 支持数据民主化实际应用案例 8. 支持数据架构演进实际应用案例 9. 支持机器学习和人工智能项目实际应用案例 结论 引言：数据血缘分析的魔力 想象一下，如果你能够像追溯家族树一样，清晰地看到每一个数据元素的来源、变换过程和最终去向，那将会给你的数据管理带来怎样的变革？这就是数据血缘分析的魔力所在。本文将深入探讨数据血缘分析在数据仓库中的应用，为你揭示这一强大工具如何改变我们理解和管理数据的方式。
什么是数据血缘分析？ 数据血缘分析（Data Lineage Analysis）是一种追踪、记录和可视化数据在整个生命周期中流动和转换过程的技术。它就像是为数据建立了一个详细的"族谱"，记录了数据从产生、存储、处理到最终使用的每一个环节。
数据血缘的核心概念 数据源（Data Source）：数据的原始来源，可能是业务系统、外部接口等。数据转换（Data Transformation）：数据在流动过程中经历的各种处理和变换。数据目标（Data Target）：数据最终存储或使用的位置。数据流（Data Flow）：数据从源到目标的整个流动路径。元数据（Metadata）：描述数据特征的数据，如数据类型、格式、业务含义等。 数据血缘分析在数据仓库中的应用 1. 数据质量管理 数据血缘分析可以帮助我们更有效地进行数据质量管理。当发现数据质量问题时，我们可以快速追溯数据的来源和处理过程，从而更容易定位和解决问题。
实际应用案例 假设我们在数据仓库的销售报表中发现了异常数据。通过数据血缘分析，我们可以迅速追踪这些数据的来源和处理过程：
原始交易数据 清洗转换 汇总计算 客户数据 产品信息 销售系统 ETL过程 数据仓库 销售报表 客户信息系统 产品目录 通过这个血缘图，我们可以看到：
销售数据来源于销售系统在ETL过程中，销售数据与客户信息和产品信息进行了关联数据经过清洗和转换后进入数据仓库最后通过汇总计算生成销售报表 如果在销售报表中发现异常，我们可以沿着这个路径逐步排查：
检查销售系统的原始数据是否正确验证ETL过程中的数据转换逻辑确认客户信息和产品信息的准确性检查数据仓库中的存储是否有问题审核报表生成的汇总计算逻辑 这种有的放矢的排查方法大大提高了问题定位和解决的效率。
2. 影响分析 当需要对数据仓库进行变更时，数据血缘分析可以帮助我们评估变更的影响范围，避免意外破坏依赖于该数据的下游应用或报表。
实际应用案例 假设我们需要对客户表的结构进行修改，添加一个新的字段"客户等级"。通过数据血缘分析，我们可以清晰地看到这个变更会影响哪些downstream数据流和应用：
客户基础信息 客户画像 客户联系方式 销售业绩 目标客户群 服务记录 客户表 销售分析 营销活动 客户服务系统 管理层报表 精准营销 客户满意度分析 通过这个血缘图，我们可以看到：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a9b00fc80e0ebd6c0ae97311039c526/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db2fccf90e69242ac9b666769df4d5ec/" rel="bookmark">
			yolo8 目标检测、鉴黄
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		省流 看前必读 别浪费时间 ：本文只是一个记录，防止自己下次被改需求时浪费时间，在这里就随意的写了一下文章记录整个步骤，但是文章想必肯定没有对应的教程讲的详细，该文章只适合想要快速按照步骤完成一个简单的 demo 的同学，并不适合想完全掌握 yolo 的同学。
一、安装环境 前言预览：
环境的安装分为 anaconda、pytorch、ultralyticspytorch安装需要注意自己的显卡版本选择对应的，30、40 系显卡要装 cuda 11版本，16 系显卡安装cuda 102版本（本文没有进行说明，可以搜搜找到适合自己显卡的版本，若是40系显卡跟着我步骤就ok）注意python版本不在3.8-3.11之间则会报错（以下会有一个解决办法） 1.1 anaconda 在此建议使用Anaconda，不然本地环境配了还要换，贼麻烦，Anaconda真香，我以前是懒得用的，结果现在真香。
首先安装 Anaconda，安装完毕后直接打开，简单吧，咱们 winer 就是喜欢可视化，low 也认了，我懒。
打开后如下，然后找到 create 创建当前项目的环境：
给予python对应版本号，记得有些版本不支持，我忘记了，就按照这个来吧，你可以自己搜一下会比较清楚：
1.2 pytorch 接着开始装 pytorch，地址：https://pytorch.org/get-started/locally/
截图如下：
安装一些老版本会比较兼容稳定，不然太新会寄，这个我就不过多解释了，做开发的都懂：
对了，这里对你的显卡啥的有版本要求，找到适合你的，我是 4060 ti ，选择了适合的版本（你可以搜，我忘记了，这篇文章就是临时做了一个小项目，顺手做个笔记，防止下次叫我改需求啥啥啥的）：
这里我选择的是 cuda 11.8：
https://pytorch.org/get-started/previous-versions/
接着通过 conda 打开你的命令提示窗，就是 open Terminal：
输入以下命令：
conda install pytorch==2.3.0 torchvision==0.18.0 torchaudio==2.3.0 pytorch-cuda=11.8 -c pytorch -c nvidia 复制命令，enter执行：
1.2 ultralytics yyyyy… 后，然后安装 ultralytics：
pip install ultralytics 注意，在这几步注意你的网络，你是否设置了全局镜像源，不清楚的就切换网络试试，说不定就成了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db2fccf90e69242ac9b666769df4d5ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96ab3b53f9901fa34d042ec04144e06d/" rel="bookmark">
			【数据结构初阶】二叉树--堆(顺序结构实现)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hello！
目录
一、实现顺序结构二叉树
1.1 堆的概念和结构
1.2 堆及二叉树的性质
1.3 堆的实现
1.3.1 创建堆的结构
1.3.2 初始化和销毁
1.3.3 入堆+向上调整算法（创建一个小堆）
1.3.4 出堆+向下调整算法（小堆）
1.3.5 判空+取堆顶数据+堆中有效数据个数
二、顺序结构二叉树---源码
Heap.h
Heap.c
test.c
Relaxing Time！
————————————— 《星空物语》 —————————————
正文开始——
一、实现顺序结构二叉树 一般堆使用顺序结构的数组来存储数据，堆是一种特殊的二叉树，分为大根堆（大堆）和小根堆（小堆），具有二叉树的特性的同时，还具备其他的特性。
1.1 堆的概念和结构 如果有一个关键码的集合K={k1，k2,，k3，...，k（n-1）}，把它的所有元素按完全二叉树的顺序存储方式存储，在一个一维数组中，并满足：Ki &lt;= K(2*i+1)（Ki &gt;= K(2*i+1) 且 Ki &gt;= K(2*i+2)），i = 0，1，2...，则称为小堆（或大堆）。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。
小堆：父结点不大于孩子结点；大堆：父结点不小于孩子结点。
数组不一定是有序地。小堆堆顶是堆的最小值，大堆堆顶是堆的最大值。 1.2 堆及二叉树的性质 堆的性质
堆中某个结点的值总是不大于或不小于其父结点的值；堆总是一棵完全二叉树。 二叉树的性质
对于具有 n 个结点的完全二叉树，如果按照从上至下从左至右的数组顺序对所有结点从0开始编号，则对于序号为 i 的结点有： 若 i &gt; 0，i 位置结点的双亲序号：（ i - 1）/ 2；i = 0，i 为根结点编号，无双亲结点；若 2i + 1 &lt; n，左孩子序号：2i + 1，2i + 1 &gt;= n 则无左孩子；若 2i + 2 &lt; n，右孩子序号：2i + 2，2i + 2 &gt;= n 则无右孩子； 通俗点来讲，父结点i---&gt; 左孩子：2i+1，右孩子：2i+2。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96ab3b53f9901fa34d042ec04144e06d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a1d609ed8d98eaff6df8fcc7aaf5206/" rel="bookmark">
			【微服务】springboot 自定义注解&#43;反射&#43;aop实现动态修改请求参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、动态修改接口请求参数的场景
2.1 动态修改请求参场景汇总
2.1.1 数据格式标准化
2.1.2 安全需要
2.1.3 参数校验与默认值设定
2.1.4 数据隐私保护
2.1.5 适配不同客户端
2.1.6 统计与监控
2.1.7 高级功能特性
三、springboot 使用过滤器和拦截器动态修改接口请求参数
3.1 使用过滤器动态修改请求参数
3.1.1 自定义 HttpServletRequest 包装类 RequestWrapper
3.1.2 自定义 HttpServletResponse 包装类 ResponseWrapper
3.1.3 自定义过滤器 ParamModifyFilter
3.1.4 测试接口
3.2 使用拦截器动态修改请求参数
3.2.1 自定义 HttpServletRequest 包装类 RequestWrapper
3.2.2 自定义CustomInterceptor
3.2.3 自定义过滤器
3.2.4 请求参数对象
3.2.5 测试接口
3.2.6 效果测试
四、springboot使用反射+aop实现动态修改请求参数
4.1 实现思路
4.2 代码实现过程
4.2.1 导入aop依赖
4.2.2 自定义注解
4.2.3 请求对象参数
4.2.4 自定义aop实现类
4.2.5 测试接口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a1d609ed8d98eaff6df8fcc7aaf5206/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cedcfbbac02b2c8dbe79c9f600b293ec/" rel="bookmark">
			我用GPT对RAG技术的学习和探索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思维导图 下图是我的学习和探索过程，红点表示已研究，黄点表示待研究
目录 思维导图RAG技术概述RAG 的关键优点应用场景 如何了解RAG技术的原理和应用1. **基础理论学习**2. **实战演练**3. **学习资源利用**4. **保持学习的连贯性**5. **多角度理解**6. **定期复盘与实践** RAG 技术的原理是什么？1. **输入解析**2. **信息检索（Retrieval）**3. **生成模型（Generation）**4. **输出生成**5. **反馈与调整（可选）**RAG 技术的优势总结 预训练的检索模型预训练的检索模型的核心概念预训练的检索模型的优势示例：常见的预训练检索模型应用场景 对比学习对比学习的核心概念对比学习的常见方法对比学习的应用场景对比学习的优势 对比学习在信息检索中的应用1. **数据准备**2. **嵌入表示的生成**3. **损失函数的设计**4. **模型训练**5. **模型评估**6. **模型部署与应用**7. **持续优化**总结 双塔架构（Dual Encoder）1. 双塔架构的基本概念2. 双塔架构的工作流程3. 应用场景4. 双塔架构的优势5. 双塔架构的挑战6. 应对策略7. 示例8. 总结 不同处理策略的输入示例 1：问答系统中的问题和答案段落示例 2：图文匹配任务中的文本和图像示例 3：搜索系统中的用户和物品总结 三元组损失1. 三元组损失的基本概念2. 三元组损失的数学公式3. 三元组损失的工作机制4. 三元组损失的应用场景5. 三元组损失的优势6. 三元组损失的挑战与应对策略7. 示例8. 总结 如何收集正样本对，有哪些难点和挑战？1. **如何收集正样本对**2. **实践中的难点和挑战**1. **数据稀缺和质量问题**2. **用户行为数据的噪声**3. **样本不均衡**4. **领域特定的挑战**5. **样本质量控制** 总结 主动学习主动学习的核心思想主动学习的关键概念主动学习的流程实践中的难点和挑战应用场景总结 领域适应技术领域适应的基本概念领域适应的类型领域适应的常见方法领域适应的优点领域适应的挑战总结 特征分布常见的特征分布类型可视化特征分布的常用方法 数据模式1. **趋势（Trend）**2. **季节性（Seasonality）**3. **周期性（Cyclical Pattern）**4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cedcfbbac02b2c8dbe79c9f600b293ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a5586652389da99b3dab7b80c5b0147/" rel="bookmark">
			网络层 IV（ARP、DHCP、ICMP）【★★★★★★】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（★★）代表非常重要的知识点，（★）代表重要的知识点。
一、地址解析协议（ARP）（★★） 在局域网中，由于硬件地址已固化在网卡上的 ROM 中，因此常常将硬件地址称为物理地址。因为在局域网的 MAC 帧中的源地址和目的地址都是硬件地址，因此硬件地址又称为 MAC 地址。即物理地址、硬件地址和 MAC 地址常常作为同义词出现。
1. IP 地址与 MAC 地址 从层次的角度看，MAC 地址是数据链路层和物理层使用的地址，而 IP 地址是网络层和以上各层使用的地址，是一种逻辑地址（称 IP 地址为逻辑地址是因为 IP 地址是用软件实现的）。下图说明了这两种地址的区别。
在发送数据时，数据从高层下到低层，然后才到通信链路上传输。使用 IP 地址的 IP 数据报一旦交给了数据链路层，就被封装成 MAC 帧了。MAC 帧在传送时使用的源地址和目的地址都是硬件地址，这两个硬件地址都写在 MAC 帧的首部中。
连接在通信链路上的设备（主机或路由器）在收到 MAC 帧时，根据 MAC 帧首部中的硬件地址决定收下或丢弃。只有在剥去 MAC 帧的首部和尾部后把 MAC 层的数据上交给网络层后，网络层才能在 IP 数据报的首部中找到源 IP 地址和目的 IP 地址。
总之， IP 地址放在 IP 数据报的首部，而硬件地址则放在 MAC 帧的首部。在网络层和网络层以上使用的是 IP 地址，而数据链路层及以下使用的是 MAC 地址。在上图中，当 IP 数据报放入数据链路层的 MAC 帧中以后，整个的 IP 数据报就成为 MAC 帧的数据，因而在数据链路层看不见数据报的 IP 地址。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a5586652389da99b3dab7b80c5b0147/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/161e1b0ebbc79a7270b5e39bdaaeec52/" rel="bookmark">
			搭建基于QT的TCP服务器与客户端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、实现功能 1、服务器和客户端能够建立连接
2、服务器可以给客户端发送信息
3、客户端可以给服务器发送信息
2、server 2-1、widget.h #ifndef WIDGET_H #define WIDGET_H #include &lt;QWidget&gt; #include &lt;QTcpServer&gt; #include &lt;QTcpSocket&gt; QT_BEGIN_NAMESPACE namespace Ui { class Widget; } QT_END_NAMESPACE class Widget : public QWidget { Q_OBJECT public: Widget(QWidget *parent = nullptr); ~Widget(); public slots: void readData(); private slots: void on_send_btn_clicked(); private: Ui::Widget *ui; QTcpServer *server; QTcpSocket *client; }; #endif // WIDGET_H 2-2、widget.cpp #include "widget.h" #include "ui_widget.h" Widget::Widget(QWidget *parent) : QWidget(parent) , ui(new Ui::Widget) { ui-&gt;setupUi(this); //设置一下窗口标题 this-&gt;setWindowTitle("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/161e1b0ebbc79a7270b5e39bdaaeec52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb58ac7762b8bc660f02fb566be7cae3/" rel="bookmark">
			ACL实验配置学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拓扑描述：
R1作为所有PC的网关；
财务部用户：192.168.1.0/24
市场部用户：192.168.2.0/24
Server1：HTTP服务器地址为7.7.7.7/24
PC 2：192.168.1.2
PC 5:：192.168.2.2
PC 3：（由路由器模拟）192.168.1.3
注意事项：模拟器中路由器Router配置ACL不生效，需采用AR2220配置。
配置需求：
1.PC 1和PC 4自动获取IP地址；
2.配置静态路由使得全网互通；
3.R2上面启用Telnet服务，方便远程管理。用户名：admin 密码：admin@123
4.拒绝财务部和市场部用户互访；
5.在R2上配置ACL仅允许PC 3远程Telnet控制；
6.在R2上配置ACL拒绝PC 2访问Server1的HTTP服务，但可以ping通。
7.在R1上配置ACL拒绝PC 5 ping Server1 但可以访问其HTTP服务。
（1）配置PC 2、PC 3、PC 5和Server1的IP信息
PC 2：
PC 3：
sys
un in en
sys PC3
int g0/0/0
ip add 192.168.1.3 24
quit
ip route-static 0.0.0.0 0 192.168.1.1
PC 5：
Server1：
（2）配置R1和R2的接口IP
R1：
sys
un in en
sysn R1
int g0/0/0
ip add 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb58ac7762b8bc660f02fb566be7cae3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec2b4e46f55ea69c3332c564ea9299e8/" rel="bookmark">
			Node.js sqlite3事件深入解析：trace、profile、change、error、open
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Node.js环境中，sqlite3库不仅提供了丰富的API用于数据库操作，还定义了一系列的事件，使得开发者能够监听和响应数据库操作过程中的各种状态变化。本文将深入解析sqlite3库中的trace、profile、change、error、open这五个事件，包括它们的作用、触发时机以及如何使用代码进行监听和处理。
一、事件概述
trace事件：当数据库执行SQL语句时触发，可以用于跟踪和记录SQL语句的执行情况。
profile事件：提供SQL语句执行的详细性能数据，包括执行时间和资源消耗等，用于性能分析。
change事件：当数据库中的数据发生变化时触发，如插入、更新或删除操作。
error事件：当数据库操作发生错误时触发，用于捕获和处理错误。
open事件：当数据库连接成功打开时触发，可以用于执行一些初始化操作。
二、事件监听与处理
要使用这些事件，首先需要引入sqlite3库并创建一个数据库连接对象。然后，可以使用.on方法监听特定的事件，并定义回调函数来处理事件。
以下是一个代码示例，展示了如何监听和处理这些事件：
const sqlite3 = require('sqlite3').verbose(); const db = new sqlite3.Database(':memory:'); // 创建一个内存中的数据库 // 监听trace事件 db.on('trace', (sql) =&gt; { console.log(`Trace: ${sql}`); }); // 监听profile事件 db.on('profile', (sql, time) =&gt; { console.log(`Profile: ${sql} - ${time}ms`); }); // 监听change事件 db.on('change', (rowCount) =&gt; { console.log(`Change: ${rowCount} rows changed`); }); // 监听error事件 db.on('error', (err) =&gt; { console.error('Error:', err); }); // 监听open事件 db.on('open', () =&gt; { console.log('Database connection opened'); }); // 执行一些数据库操作以触发事件 db.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec2b4e46f55ea69c3332c564ea9299e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec67fe3f0fb79f87eef090366edd9ac0/" rel="bookmark">
			【数据结构】二叉树基础(带你详细了解二叉树）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌏个人博客主页：心.c
​
前言：最近学习了二叉树，和大家分享一下我的理解和感悟，希望对大家有所帮助，话不多说，开整！！！
🔥🔥🔥专题文章：二叉树
😽感谢大家的点赞👍收藏⭐️评论✍您的一键三连是我更新的动力 💓
目录
概念：
二叉树的结构：
图解：
结构体创建：
二叉树的分类：
满二叉树
完全二叉树：
平衡二叉树
二叉搜索树
二叉树遍历： 二叉树遍历方式：
递归遍历演示：
前序遍历：
中序遍历：
后续遍历：
迭代遍历演示（栈）：
前序遍历：
中序遍历：
后续遍历：
概念： 二叉树是一种每个节点最多有两个子节点的数据结构。通常，这两个子节点被称为左子节点和右子节点。
二叉树的结构： 图解： ​
结构体创建： // 二叉树节点结构体 struct TreeNode { int val; // 节点值 TreeNode* left; // 指向左子节点的指针 TreeNode* right; // 指向右子节点的指针 // 默认构造函数 TreeNode() : val(0), left(nullptr), right(nullptr) {} // 带值的构造函数 TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} // 带左右子节点的构造函数 TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {} }; 二叉树的分类： 满二叉树 每个节点都有0或2个子节点的二叉树。满二叉树的每一层都完全填满。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec67fe3f0fb79f87eef090366edd9ac0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4013698aa921abcfcee0b10def424e5/" rel="bookmark">
			neural-admixture：基于AI的快速基因组聚类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近学习祖源分析方面的内容，发现已经有了GPU版的软件，可以几十倍地加快运算速度，推荐使用！小数据集的话家用显卡即可hold住，十分给力！
ADMIXTURE 是常用的群体遗传学分析工具，可以估计个体的祖先成分。使用neural-admixture 可以将一个月的连续计算时间缩短到几个小时。多头方法允许神经 ADMIXTURE 通过在单个集群中计算多个集群数来进一步加速
在一次运行中计算多个集群数。此外
模型可以存储，从而可以在线性时间内对新数据执行集群分配，而无需共享数据。
无需共享训练样本
发表在NCS上的论文，nature子刊，应该足够权威的。
软件简介 Neural ADMIXTURE 是一种基于 ADMIXTURE 的无监督全局祖先推理技术。通过使用神经网络，Neural ADMIXTURE 提供高质量的祖先分配，运行时间比 ADMIX 快得多。
该软件可以通过 CLI 调用，并且具有与 ADMIXTURE 类似的界面（例如，输出格式完全可互换）。虽然该软件在 CPU 和 GPU 中运行，但我们建议使用 GPU（如果可用）以利用基于神经网络的实现。
系统要求 硬件要求 成功使用此软件包需要一台具有足够 RAM 的计算机，以便能够处理网络设计为使用的大型数据集。因此，我们建议尽可能使用计算集群，以避免内存问题。
软件要求 该软件包已在 Linux（CentOS 7.9.2009、Ubuntu 18.04.5 LTS）和 MacOS（BigSur 11.2.3、Intel 和 Monterey 12.3.1、M1）上进行了测试。如果使用 GPU，请确保正确安装了 CUDA 驱动程序，如果已经装好了CUDA会自动安装GPU版本。
亲测建议使用conda创建新的 Python 3.9 环境，然后在其中安装软件包。例如，对于 ，应启动以下命令：
conda create -n nadmenv python=python3.9 conda activate nadmenv pip install neural-admixture 用法 运行 Neural ADMIXTURE 要从头开始训练模型，只需从项目的根目录调用以下命令即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4013698aa921abcfcee0b10def424e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/799cb1ecbf74007142ef9922feac7807/" rel="bookmark">
			Java中的经典排序算法：快速排序、归并排序和计数排序详解（如果想知道Java中有关快速排序、归并排序和计数排序的知识点，那么只看这一篇就足够了！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：排序算法在计算机科学中占有重要地位，不同的算法适用于不同的场景。本文将深入探讨快速排序、归并排序和计数排序。
✨✨✨这里是秋刀鱼不做梦的BLOG
✨✨✨想要了解更多内容可以访问我的主页秋刀鱼不做梦-CSDN博客
先让我们看一下本文大致的讲解内容：
对于每个排序算法，我们都会从算法简介、其原理与步骤、代码实现、时间复杂度分析、空间复杂度分析与该排序算法的应用场景这几个方面来进行讲解。
目录
1.快速排序 (Quicksort)
（1）算法简介
（2）算法的原理与步骤
（3）Java代码实现
【1】Hoare法
【2】挖坑法
【3】前后指针法
（4）时间复杂度和空间复杂度
（5）算法的应用场景
2.归并排序 (Merge Sort)
（1）算法简介
（2）算法的原理与步骤
（3）Java代码实现
（4）时间复杂度和空间复杂度
（5）算法的应用场景
3.计数排序 (Counting Sort)
（1）算法简介
（2）算法的原理与步骤
（3）Java代码实现
（4）时间复杂度和空间复杂度
（5）算法的应用场景
1.快速排序 (Quicksort) （1）算法简介 快速排序是一种高效的排序算法，由C.A.R. Hoare在1960年提出。它采用分治法（Divide and Conquer），通过递归地将未排序的部分分割为较小的子数组进行排序，再将其合并。快速排序的平均时间复杂度为 O(nlog⁡n)，在大多数情况下比其他 O(nlog⁡n) 的算法，如归并排序，具有更好的性能。
当然，我相信读者读完快速排序的简介之后，对于快速排序算法的认识还是没什么认识的，接下来让我们直接带着你边学如何实现排序算法边理解该算法的内核。
（2）算法的原理与步骤 快速排序的核心思想是选择一个“基准”（pivot），并通过一系列的比较和交换操作将数组分成两部分：一部分所有元素小于基准，另一部分所有元素大于基准。然后，对这两部分分别递归地应用快速排序。具体步骤如下：
选择基准: 从数组中选择一个元素作为基准。选择基准的方法有多种，如选择第一个元素、最后一个元素、随机选择或三数取中法。
分区 (Partitioning): 通过遍历数组，将所有小于基准的元素放在基准的左边，所有大于基准的元素放在右边。
递归排序: 对基准左边和右边的子数组递归地进行快速排序。
组合: 由于分区已经确保了基准左边的元素小于基准，右边的元素大于基准，因此当递归完成后，数组已经是有序的。
——看完了上述大体如何实现快速排序算法之后，让我们从代码的层面来实现一下快速排序算法。
（3）Java代码实现 以下为Java中实现快速排序的大致代码：
public void quickSort(int[] array) { int end = array.length - 1; quickSort(array, 0, end); } private void quickSortHo(int[] array, int left, int right) { // 如果子数组长度为1或更小，则返回（即递归终止条件） if (left &gt;= right) { return; } // 查找基准元素的位置，并将数组分成两部分 int target = findTarget(array, left, right); // 对基准元素左边的子数组进行递归排序 quickSort(array, left, target - 1); // 对基准元素右边的子数组进行递归排序 quickSort(array, target + 1, right); } 从上述代码中我们可以看到我们在寻找基准元素位置的时候，使用了findTarget（）方法，那么这个方法该如何实现呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/799cb1ecbf74007142ef9922feac7807/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7d3a580af8596523fe125b3a9bfabc7/" rel="bookmark">
			【网络安全】CSRF漏洞—CSRF基础漏洞防御
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSRF（Cross-Site Request Forgery，跨站请求伪造）是一种常见的网络安全攻击手段，它利用用户已经认证的身份，通过第三方网站诱导用户点击链接或提交表单，从而在用户不知情的情况下，以用户的名义执行一些操作，比如转账、发帖、改密码等。
一、CSRF漏洞介绍 1.1 定义 理解：
跨站点的请求请求是伪造的（假装可信） Cross-Site Request Forgery，跨站请求伪造。它是一种挟持用户在当前已登陆的Web应用程序上执行非本意的操作的攻击方法。
1.2 成因 CSRF漏洞的成因就是网站的cookie在浏览器中不会过期，只要不关闭浏览器或者退出登录，那以后只要是访问这个网站，都会默认你已经登陆的状态。而在这个期间，攻击者发送了构造好的CSRF脚本或包含CSRF脚本的连接，可能会执行一些用户不想做的功能（比如添加账号等）。这个操作不是用户真正想要执行的
1.3 攻击过程 用户登陆受信任的网站A，并在本地生成Cookie在不登出A的情况下，访问危险网站B执行危险网站B上面的代码 1.4 CSRF攻击分类 正常的CSRF攻击，增删改等操作（基于操作的CSRF）另类的CSRF：JSONP、CORS、Flash跨域劫持（基于文件读取的CSRF） 1.5 攻击利用 CSRF的本质就是在不知情的情况下执行请求
根据请求分为了：get类型CSRF，post类型CSRF
1.5.1 GET型CSRF 攻击者可能会构造一个GET请求的URL，该URL指向一个恶意的操作，如转账或修改设置。用户在不知情的情况下点击这个链接，如果用户已经登录，服务器可能会执行该操作，因为GET请求通常不包含敏感数据。一般会这样利用：
&lt;img src="http://bank/exaple/withdraw?amount=10000&amp;for=hacker"&gt; 1.5.2 POST型CSRF 攻击者可能会诱导用户点击一个链接或提交一个表单，这个链接或表单使用POST方法。如果用户已经登录，服务器可能会处理这个请求，执行如修改密码或转账等敏感操作。
&lt;form action="http://bank.example/withdraw"method=POST&gt; &lt;input type="hidden" name="account" value="xiaoming"/&gt; //name为参数，value为参数的值 &lt;input type="hidden" name="amount"value="10000"/&gt; &lt;input type="hidden" name="for" value="hacker"/&gt; &lt;/form&gt; &lt;script&gt;document.forms[0].submit();&lt;/script&gt; //自动提交表单 二、CSRF漏洞利用 2.1 同源策略介绍 同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。所以 xyz.com下的js脚本采用ajax读取abc.com里面的文件数据会被拒绝
同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。
2.2 解决跨域问题 由于同源策略的影响，当我们从一个域名的网页去请求另一个域名的资源时，就无法成功获取资源。如果我们想要成功获取资源，那么就要用到跨域
跨域解决方案：jsonp、cors、postMessage
2.3 CORS介绍 CORS（Cross-Origin Resource Sharing，跨源资源共享）是一种安全机制，它允许或限制网页从另一个域名（即跨域）加载资源。这是由浏览器实施的安全策略，称为同源策略，它防止一个域的脚本与另一个域的资源交互，除非后者明确允许。
在配置了cors的前提下，当你登录网站A，并跨域访问网站B的时候，浏览器判断你的操作是跨域，这时候会在数据包里面加个origin字段，内容为：origin:b.com，这样你就能跨域了，当cors的配置错误时就会产生cors漏洞
2.4 jsonp JSONP（JSON with Padding）是一种在Web开发中用来绕过浏览器同源策略限制，实现跨域请求的技术。由于同源策略的限制，一个网页上的JavaScript代码通常不能直接请求另一个域的资源。JSONP通过动态创建&lt;script&gt;标签的方式，允许网页从不同域获取数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7d3a580af8596523fe125b3a9bfabc7/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/10/">«</a>
	<span class="pagination__item pagination__item--current">11/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/12/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>