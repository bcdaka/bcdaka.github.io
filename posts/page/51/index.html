<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/185f4d0d407084d0f509b0b62fc3a36f/" rel="bookmark">
			Docker 容器化技术：现代化应用部署的利器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引言
Docker 简介
什么是 Docker？
为什么会出现 Docker？
Docker 的工作原理
Docker 运行环境的工作原理
如何使用 Docker
基本操作
镜像和容器管理
Docker 使用的小技巧
总结
引言 在当今快速发展的云计算和微服务架构时代，Docker 以其轻量级、可移植性和快速部署的特点，成为开发者和运维人员的热门选择。本文将深入探讨 Docker 的概念、工作原理、安装步骤、使用方法以及一些实用技巧。
Docker 简介 什么是 Docker？ Docker 是一个开源的容器化平台，它允许开发者将应用及其依赖环境封装在轻量级、可移植的容器中，实现在不同计算环境中的一致运行。
为什么会出现 Docker？ 在 Docker 出现之前，虚拟化技术已经存在，但它们通常比较重，启动慢，资源消耗大。Docker 通过容器化技术解决了这些问题，提供了一种更高效、更快速的应用部署方式。
Docker 的工作原理 Docker 容器基于 Linux 容器（LXC）技术，但 Docker 进行了进一步的封装，使得容器更加轻量级。Docker 的核心组件包括：
Docker 客户端和服务器（Docker Engine）：客户端向服务器发送请求，服务器执行这些请求。Docker 镜像：只读模板，包含运行应用所需的所有内容。Docker 容器：镜像的运行实例，可以启动、停止、移动和删除。 Docker 运行环境的工作原理 Docker 利用 Linux 内核功能如 cgroups 和 namespaces 实现资源限制和隔离。Union File System（联合文件系统）允许 Docker 容器共享基础镜像层，而只复制必要的差异部分，从而提高存储效率。
如何使用 Docker 基本操作 获取镜像：docker pull [image] 下载指定的 Docker 镜像。运行容器：docker run [options] [image] 创建并启动一个容器实例。列出容器：docker ps 查看当前正在运行的容器。停止容器：docker stop [container] 停止运行中的容器。删除容器：docker rm [container] 删除已停止的容器。删除镜像：docker rmi [image] 删除指定的 Docker 镜像。 镜像和容器管理 查看镜像列表：docker images 列出本地的 Docker 镜像。构建镜像：docker build 从 Dockerfile 构建新的镜像。容器日志：docker logs [container] 查看容器的日志输出。 Docker 使用的小技巧 使用数据卷：通过挂载数据卷，可以在容器之间共享和持久化数据。网络设置：Docker 提供了多种网络配置选项，可以连接不同容器或外部网络。Docker Compose：用于定义和运行多容器 Docker 应用的工具。镜像优化：构建镜像时，合理安排 Dockerfile 指令顺序，减少镜像层数，优化存储和传输效率。 总结 Docker 容器化技术为现代应用的快速部署和运行提供了强大支持。通过本文的介绍，你应该对 Docker 有了更深入的了解。Docker 的学习曲线相对平缓，但掌握它将为你的技术开发带来无限可能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/185f4d0d407084d0f509b0b62fc3a36f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e243a5bf13997af3747f9de7b38e5753/" rel="bookmark">
			Elasticsearch拼音分词器的安装、配置与测试实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Elasticsearch的分词器对于文本分析至关重要。对于中文等语言，合适的分词器可以显著提高搜索相关性和结果的准确性。拼音分词器不仅支持基于拼音的搜索，还能实现拼音自动补全等功能。本文将介绍如何在Elasticsearch中安装拼音分词器，以及如何配置和测试它。
分词器的三要素 在Elasticsearch中，分词器（Analyzer）由以下三个主要部分组成：
Character Filters（字符过滤器）：在Tokenizer处理之前对文本进行预处理，如删除或替换特定字符。Tokenizer（分词器）：按照一定的规则将文本切分成词条（Term），例如ik_max_word就是智能切分中文。Token Filters（词条过滤器）：对Tokenizer输出的词条进行进一步处理，如转换为小写、同义词替换、拼音转换等。 安装拼音分词器插件 步骤1：下载插件 访问elasticsearch-analysis-pinyin GitHub页面，下载与您的Elasticsearch版本相匹配的插件。
步骤2：上传插件 将下载的插件压缩包上传到Elasticsearch的plugins目录。
步骤3：重启Elasticsearch ./elasticsearch-plugin install file:///path/to/elasticsearch-analysis-pinyin-7.x.x.zip 步骤4：测试插件 使用_analyze API测试拼音分词器：
POST /_analyze { "text": "如家酒店", "analyzer": "pinyin" } 配置自定义分词器 自定义分词器可以在创建索引时通过settings配置。
简版配置示例 PUT /my_index { "settings": { "analysis": { "analyzer": { "my_pinyin_analyzer": { "tokenizer": "ik_max_word", "filter": ["pinyin"] } } } } } 完整版配置示例 以下是完整版的配置示例：
PUT /my_index { "settings": { "analysis": { "analyzer": { "my_pinyin_analyzer": { "tokenizer": "ik_max_word", "filter": ["my_pinyin_filter"] } }, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e243a5bf13997af3747f9de7b38e5753/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52c401eb33a7841a231e37d499d2b5c6/" rel="bookmark">
			第七节 流编辑器sed(stream editor)(7.2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三,模式空间中的编辑操作 3,1,地址定界 地址定界示例说明不写地址定界表示对文件所有行进行处理num1,num21,3或者1,$对文件的1-3行进行处理或者1-$(表示文件的最后一行)num1,+N1,+3对文件的num1行和之后n行进行处理first~step1~2对文件的1,3,5,7,…的行内容进行处理/pattern//^root/,/r/l对任何能够被正则表达式匹配的行进行处理%pattern%%/r%可以使用其他的边界符号(例如#),对任何能够被正则表达式匹配的行处理/pattern1/,/pattern2//^root/,/^adm/表示正则表达式1和正则表达式2匹配的行和中间的所有行0,/pattern1/或者1,/pattern1/0,/^adm/从第一行开始到能够被正则表达式匹配的行 示例:
生成测试文件
head -n 5 /etc/passed &gt; testfile a)替换文件中所有:为@@@
sed 's/:/@@@/g' testfile root@@@x@@@0@@@0@@@root@@@/root@@@/bin/bash bin@@@x@@@1@@@1@@@bin@@@/bin@@@/sbin/nologin daemon@@@x@@@2@@@2@@@daemon@@@/sbin@@@/sbin/nologin adm@@@x@@@3@@@4@@@adm@@@/var/adm@@@/sbin/nologin lp@@@x@@@4@@@7@@@lp@@@/var/spool/lpd@@@/sbin/nologin b)替换1-3行
sed '1,3s/:/@@@/g' testfile root@@@x@@@0@@@0@@@root@@@/root@@@/bin/bash bin@@@x@@@1@@@1@@@bin@@@/bin@@@/sbin/nologin daemon@@@x@@@2@@@2@@@daemon@@@/sbin@@@/sbin/nologin adm: X: 3:4: adm:/var/adm: sbin/nologin/ lp: x: 4:7: lp:/var/spool/lpd:/sbin/nologin c)替换1行和3行的":"
sed -e '1s/:/@@@/g' -e '3s/:/@/g' testfile root@@@x@@@0@@@0@@@root@@@/root@@@/bin/bash bin: x: 1:1: bin:/bin:/sbin/nologin daemon@x@2@2@daemon@/sbin@/sbinnologin admx: 3:4: adm:/var/adm:/sbin/nologin lp: x: 4:7: lp:/var/spool/lpd:/sbin/nologin d)替换2行和之后两行":"
sed -e '2,+2s/:/@@@/g' -e '3s/:/@/g' testfile root: x: 0:0: root:/root:/bin/bash bin@@@x@@@1@@@1@@@bin@@@/bin@@@/sbin/nologin daemon@@@x@@@2@@@2@@@daemon@@@/sbin@@@sbin/nologin adm@@@x@@@3@@@4@@@adm@@@/var/adm@@@/sbin/nologin lp: x: 4:7: lp:/var/spool/lpd:/sbin/nologin e)每隔1行替换
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52c401eb33a7841a231e37d499d2b5c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8173c1137988e7ad5321d95cc8b09a74/" rel="bookmark">
			【Java数据结构】---Queue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		乐观学习，乐观生活，才能不断前进啊！！！
我的主页：optimistic_chen
我的专栏：c语言 ，Java
欢迎大家访问~
创作不易，大佬们点赞鼓励下吧~
文章目录 前言队列Queue队列的模拟实现环形队列队列练习Deque双端队列完结 前言 由图可知：Queue接口一定意义上和List接口“平级”
注意一个细节， LinkedList不仅属于List接口下的类，也属于Queue接口下的类 。根据上篇博客所说，链表与数组都可以模拟栈，而栈也是List接口下的类。
队列Queue 队列：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表。
入队列(Enqueue)：进行插入操作的一端称为队尾
出队列(Dequeue)：进行删除操作的一端称为队头
队列具有先进先出的特性
大家可以简单理解为日常生活中“排队”这一现象。
队列的模拟实现 简单想一想，因为LinkedList实现了Queue接口，所以Queue的底层是由链表实现的。
受到LinkedList的影响，我们下意识认为Queue的底层是双向链表，那单链表能不能来实现队列呢？
那么以LinkedList来实现队列怎么样呢？
建立内部类
//内部类 public static class ListNode { public ListNode prev; public ListNode next; int value; ListNode(int value){ this.value=value; } } public ListNode first=null; public ListNode last=null; int Usedsize=0; 入队列—向双向链表位置插入新节点
public void offer(int val){ ListNode node=new ListNode(val); if(first==null){ first=last=node; }else{ last.next=node; node.prev=last; } last=node; Usedsize++; } 出队列—将双向链表第一个节点删除掉
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8173c1137988e7ad5321d95cc8b09a74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60e0ad8e845ee8557d771718ec6678db/" rel="bookmark">
			【走迷宫】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 DFS代码 #include&lt;bits/stdc++.h&gt; using namespace std; const int N = 110; int matrix[N][N]; int n, m; int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; int dis[N][N]; void dfs(int x, int y, int cnt) { if(cnt &gt; dis[n-1][m-1]) return; if(x == n-1 &amp;&amp; y == m-1) return; for(int i = 0; i &lt; 4; i++) { int nx = x + dx[i], ny = y + dy[i]; if(nx &lt; 0 || ny &lt; 0 || nx &gt;= n || ny &gt;= m || matrix[nx][ny]) continue; if(dis[nx][ny] &gt; dis[x][y] + 1) { dis[nx][ny] = dis[x][y] + 1; dfs(nx, ny, cnt+1); } } } int main() { scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60e0ad8e845ee8557d771718ec6678db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf1a57bf45dba63e2a8381e087a59185/" rel="bookmark">
			多字段聚合查询在Elasticsearch中的实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Elasticsearch是一个功能强大的搜索引擎，它不仅支持全文搜索，还提供了丰富的聚合功能。聚合可以帮助我们对数据进行分组和统计，从而得到有意义的分析结果。本文将通过Java代码示例，介绍如何在Elasticsearch中实现多字段的聚合查询。
环境准备 在开始之前，请确保你已经安装了Elasticsearch服务，并且Java开发环境已经搭建好。同时，需要添加Elasticsearch的Java客户端依赖到你的项目中。
&lt;!-- 在pom.xml中添加依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt; &lt;version&gt;7.15.0&lt;/version&gt; &lt;!-- 使用最新的稳定版本 --&gt; &lt;/dependency&gt; 多字段聚合查询 概念解释 多字段聚合允许我们在一个聚合查询中对多个字段执行相同的聚合操作，例如，我们可以同时对brand、city和starName字段执行术语聚合。
Java代码实现 以下是使用Java代码和RestHighLevelClient进行多字段聚合查询的示例：
@Test void testAggs() throws IOException { // 创建一个搜索请求，指定索引名为"hotel" SearchRequest searchRequest = new SearchRequest("hotel"); // 构建搜索源，设置不需要原始文档（大小为0） SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder().size(0); // 添加多个术语聚合 searchSourceBuilder.aggregation( AggregationBuilders.terms("brand_agg").field("brand").size(20) ); searchSourceBuilder.aggregation( AggregationBuilders.terms("city_agg").field("city").size(20) ); searchSourceBuilder.aggregation( AggregationBuilders.terms("star_agg").field("starName").size(20) ); // 将构建的搜索源设置到搜索请求中 searchRequest.source(searchSourceBuilder); // 执行搜索请求，获取搜索响应 SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT); // 从搜索响应中获取聚合结果 Aggregations aggregations = searchResponse.getAggregations(); // 检查聚合结果是否为空 if (aggregations !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf1a57bf45dba63e2a8381e087a59185/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a7ccc46ccdf1dc13bec3f531561a5a1/" rel="bookmark">
			图论------迪杰斯特拉（Dijkstra）算法求单源最短路径。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编程要求 在图的应用中，有一个很重要的需求：我们需要知道从某一个点开始，到其他所有点的最短路径。这其中，Dijkstra 算法是典型的最短路径算法。
本关的编程任务是补全右侧代码片段中 Begin 至 End 中间的代码，实现 Dijkstra 算法求单源最短路径，具体要求如下：
补全代码 int[] Paths(int source) 方法，实现 Dijkstra 算法；
输出源点 source 到其他各个定点的距离，如果不可达，则距离输出 INF。
测试举例
测试过程：
平台将创建用户补全后的ShortestPath类的对象；
调用对象的addEdge(int u, int v, int w)方法，添加边和边的权重信息，构建图G；
调用对象的Paths(int source)方法执行Dijkstra算法，求最短路径，并输出返回的最短路径，这里源点设置为1；
接着根据程序的输出判断程序是否正确。
以下是测试样例：
测试输入：
5 7
1 2 8
1 3 1
1 4 2
3 4 2
2 4 3
3 5 3
4 5 3
(5 和 7 分别表示顶点数和边数)
预期输出：
0 5 1 2 4 思路解析： 求单源最短路径就是求一个点到除它以外所有点的最短距离，首先我们还是用邻接矩阵来储存图的信息。以测试输入为例，示意图如下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a7ccc46ccdf1dc13bec3f531561a5a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31f39e2d59c1ace595bb7d96c8cd45b9/" rel="bookmark">
			数据沙箱：构建安全的数据分析堡垒
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标题：数据沙箱：构建安全的数据分析堡垒 在当今数据驱动的世界中，数据安全与隐私保护已成为企业和组织关注的焦点。数据沙箱技术作为一种创新的解决方案，提供了一个安全的环境，使数据分析师和科学家能够在不泄露原始数据的前提下，进行数据的探索、分析和建模。本文将详细介绍数据沙箱的概念、重要性以及如何在保证数据安全的前提下进行高效的数据分析。
一、数据沙箱技术概述 数据沙箱是一种隔离环境，它允许用户在其中运行程序和处理数据，而不会影响到外部系统或数据的安全性。通过使用虚拟化技术、访问控制技术和防躲避技术，数据沙箱能够确保可疑文件或程序在隔离环境中运行，从而保护主机和操作系统免受病毒和未知威胁的侵害。
二、数据沙箱的重要性 数据隐私保护：数据沙箱可以在不暴露个人或敏感数据的情况下，进行数据分析和处理，满足数据隐私保护的要求。风险降低：在沙箱中测试新的算法和模型，可以在不影响真实数据和系统的情况下，评估潜在的风险和效果。合规性支持：数据沙箱帮助企业遵守数据保护法规，如《数据安全法》和《个人信息保护法》，避免法律风险。促进数据共享：通过确保数据安全，数据沙箱鼓励组织之间进行数据共享，从而实现数据价值的最大化。 三、数据沙箱在安全数据分析中的应用 金融行业：金融机构可以利用数据沙箱进行市场模拟，测试交易策略和风险管理模型，同时保护客户数据和隐私。医疗领域：数据沙箱可以用于医疗数据分析，帮助研究人员在保护患者隐私的前提下，进行疾病研究和药物开发。政府数据开放：政府机构可以利用数据沙箱技术，安全地开放公共数据，支持宏观经济监测和政策评估。 四、数据沙箱技术实现示例 以下是一个简化版的Python代码示例，展示如何在隔离环境中运行数据分析脚本，以保护数据安全：
# 假设这是数据分析脚本的简化版 def analyze_data(sandbox_data): # 对沙箱内的数据进行分析 results = sandbox_data.mean() return results # 假设这是从数据沙箱中获取的数据 sandbox_data = load_sandbox_data() # 在沙箱环境中运行分析 secure_results = analyze_data(sandbox_data) print("安全分析结果：", secure_results) 五、结论 数据沙箱技术为数据分析提供了一个安全的环境，使得数据的价值得以发挥，同时确保了数据的隐私和安全。随着数据安全法规的日益严格和技术的不断进步，数据沙箱将成为企业和组织在数据分析领域的重要工具。
通过本文的探讨，我们希望能够帮助读者更好地理解数据沙箱的概念和应用，以及如何利用这项技术在保障数据安全的前提下，实现高效的数据分析和建模。随着技术的不断发展，数据沙箱有望在更多领域发挥其独特的价值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73c4e0f9079a4c26885345ce9fefeeb1/" rel="bookmark">
			pyinstaller使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pyinstaller 入门 Pyat5 的安装程序开发PyQt6 的安装程序开发 编写好的程序编译成可执行文件+资源文件:用 zip 打包，基本可以压缩到 1/3 大小;然后再用 pyqt 写一个 setup 安装程序，安装到指定目录(安装的过程实际就是把文件解压、拷贝到指定目录、注册到注册表中) pyinstaller 简介 PyInstaller bundles a Python application and all its dependencies into a singlepackage.The user can run the packaged app without installing a Pythoninterpreter or any modules. Pyinstaller supports Python 3.7 and newer, andcorrectly bundles many major Python packages such as numpy, matplotlib, PyQtwxPython, and others.
PyInstaller is tested against Windows, MacOS X, and Linux. However, it is not across-compiler: to make a Windows app vou run PyInstaller on Windows, and tomake a tinux app you cor it on linps, etc, ioyinsts ler has beer asedst them isnot part of our continuous integration tests, and the development team offersno guarantee (all code for these platforms comes from external contributionsthat PyInstaller will work on these platforms or that they will continue to besupported.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73c4e0f9079a4c26885345ce9fefeeb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdd5175c1e7fc5318498ef410cf5615e/" rel="bookmark">
			【C语言初阶】C语言指针全攻略：解锁C语言深层奥秘的钥匙
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📝个人主页🌹：Eternity._
⏩收录专栏⏪：C语言 “ 登神长阶 ”
🤡往期回顾🤡：C语言操作符
🌹🌹期待您的关注 🌹🌹
❀指针 📒1. 指针和指针类型🌄指针的概念🏞️指针 + - 整数⛰️指针的解引用 📙2. 野指针🎈野指针成因🎩如何规避野指针 📕3. 指针运算🍁指针 - 指针🍂指针的关系运算 📚4. 指针和数组📜5. 二级指针📝6. 指针数组📖7. 总结 前言：在编程的广阔天地里，C语言以其接近硬件的特性和强大的灵活性，始终占据着举足轻重的地位。而在这片由代码构建的领域中，指针无疑是那把开启C语言深层奥秘的钥匙。它不仅让程序员能够直接访问和操作内存，更是构建复杂数据结构、实现高效算法、进行底层开发不可或缺的工具
对于许多初学者而言，指针或许是一个令人望而生畏的概念。那些看似晦涩难懂的语法规则和抽象的概念，常常让人望而却步。然而，正如攀登高峰的过程虽然艰难，但一旦站在山顶，便能领略到前所未有的壮丽景色。学习C语言指针，也是一场从迷茫到清晰、从畏惧到掌握的旅程
在这篇文章中，我们将一起踏上这段旅程，从指针的基础概念讲起，逐步深入到内存管理、数组操作、函数参数传递等核心话题。我们将通过生动的示例、清晰的解释和实用的技巧，帮助你克服对指针的恐惧，逐步建立起对指针的深刻理解和灵活运用能力
让我们一起，用指针这把钥匙，打开C语言世界的大门，探索其中的无限可能和精彩世界！
📒1. 指针和指针类型 🌄指针的概念 指针理解的2个要点：
指针是内存中一个最小单元的编号，也就是地址平时口语中说的指针，通常指的是指针变量，是用来存放内存地址的变量 总结：指针就是地址
指针变量
我们可以通过&amp;（取地址操作符）取出变量的内存其实地址，把地址可以存放到一个变量中，这个变量就是指针变量
代码示例 (C语言)：
int main() { int a = 10; // 在内存中开辟一块空间 int* p = &amp;a; // 这里我们对变量a，取出它的地址，可以使用&amp;操作符。 // a变量占用4个字节的空间，这里是将a的4个字节的第一个字节的地址存放在p变量 // 中，p就是一个之指针变量 return 0; } 指针变量，用来存放地址的变量。（存放在指针中的值都被当成地址处理）
对于32位的机器，假设有32根地址线
那么32根地址线产生的地址就会是：
//00000000 00000000 00000000 00000000 //00000000 00000000 00000000 00000001 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdd5175c1e7fc5318498ef410cf5615e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89fc9ffc4791370344b02b1df972a7d4/" rel="bookmark">
			Datawhale X 魔搭 AI夏令营第四期 魔搭-AIGC方向 task02笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		理解baseline代码 在task01中，我们根据教程实现了AI生图。接下来我们来细读和理解baseline代码。
首先我们来直观感知下这个文生图代码的框架结构：
接着我们按照上图的部分细读代码。
1.环境准备 # 安装 Data-Juicer 和 DiffSynth-Studio !pip install simple-aesthetics-predictor # 安装simple-aesthetics-predictor !pip install -v -e data-juicer # 安装data-juicer !pip uninstall pytorch-lightning -y # 卸载pytorch-lightning !pip install peft lightning pandas torchvision # 安装 peft lightning pandas torchvision !pip install -e DiffSynth-Studio # 安装DiffSynth-Studio 使用 !pip 命令来安装或卸载 Python 包。包括：
simple-aesthetics-predictor, data-juicer, peft, lightning, pandas, torchvision, 和 DiffSynth-Studio 的安装。
卸载 pytorch-lightning（使用 -y 自动确认卸载）。
2. 数据集加载和预处理 # 从魔搭数据集中下载数据集AI-ModelScope/lowres_anime from modelscope.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89fc9ffc4791370344b02b1df972a7d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/776f12c26c377787ecca9c8bf854ac8b/" rel="bookmark">
			【C&#43;&#43;】—— 类与对象（五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【C++】—— 类与对象（五） 1、类型转换1.1、类型转换介绍1.2、类型转换的应用1.3、explicit 关键字 2、static 静态成员2.1、static 静态成员变量2.2、static 静态成员函数2.3、总结 3、友元3.1、友元函数3.2、友元类 4.内部类5、匿名对象6、对象拷贝时的编译器优化6.1、情况一：类型转换6.2、情况二：传值传参6.3、情况三：传值返回 1、类型转换 1.1、类型转换介绍 我们知道，整型和浮点型之间可以发生隐式类型转换
int main() { int a = 2.2; cout &lt;&lt; a &lt;&lt; endl; return 0; } 运行结果：
int a = 2.2;这句代码，会发生隐式类型转换。中间生成一个临时对象，将右操作数强制类型转换为左操作数的类型，再将临时对象的值赋值给 a a a。
那么下面代码小伙伴们见过吗
class A { public : A(int a1) : _a1(a1) {} A(int a1, int a2) :_a1(a1) , _a2(a2) {} void Print() { cout &lt;&lt; _a1 &lt;&lt; " " &lt;&lt; _a2 &lt;&lt; endl; } private: int _a1 = 1; int _a2 = 2; }; int main() { A aa1(5); aa1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/776f12c26c377787ecca9c8bf854ac8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04ac44ebb86858e113a6ede14212ec49/" rel="bookmark">
			CSS 垂直居中显示的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Flexbox 使用 Flexbox 是一种非常常见且灵活的方法，可以轻松实现水平和垂直居中。
css复制代码 .container { display: flex; justify-content: center; /* 水平居中 */ align-items: center; /* 垂直居中 */ height: 100vh; /* 使容器高度为视口高度 */ } 2. Grid 使用 CSS Grid 也可以实现垂直居中。
css复制代码 .container { display: grid; place-items: center; /* 水平和垂直居中 */ height: 100vh; } 3. 使用 position 和 transform 这种方法适用于具有固定宽度和高度的元素。
css复制代码 .container { position: relative; height: 100vh; } ​ .element { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04ac44ebb86858e113a6ede14212ec49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd06de44ac1883fb5c65beef1e80ea09/" rel="bookmark">
			thymeleaf&#43;jquery&#43;bootstrap springboot&#43;mybatis项目学习记录1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近实习，好多收获都忘记了，从今天开始好好记录一下
8.13记录
今日工作: 通过Post发送请求，获取数据，来替代原本的mapper.
1. post 发送，接收的参数，和之前mapper的参数不一致，how？
为了方便修改，直接将新参数重命名，然后修改发生了变化的属性名。值得开心的是，前端的参数数量是灵活的，比如后端需要5个参数，返回10个参数，前端可以只给后端3个参数，只展示其中的8个参数。这个特性使得查找数据的接口可以少写很多，只要写一个最全的，然后都用这个找数据的接口就行，（不过显而易见，会影响传输速率欸，，，，，，）
2. jquery own-
现在也没搞懂这是哪一个包，反正是
前端html&lt;--&gt;前端js&lt;--&gt;后端 三者之间数据的传播也是挺神奇
html--&gt;js selector找到元素获得属性 own_ace_form_data
js--&gt;html selector找到元素赋值属性 own_ace_table {field}直接实现后端--&gt;js--&gt;html
js--&gt;后端 发送请求，post get
后端--&gt;js return
后端--&gt;html model.addatribute thymeleaf模板动态渲染，th, ${}
3. canvas偏离
设置偏置，偏回来即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65ced67b130ed4f44825611bebdafa93/" rel="bookmark">
			数据赋能（174）——开发：数据挖掘——技术方法、主要工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		技术方法
数据挖掘的技术方法多种多样，包括但不限于：
聚类分析：将数据划分为不同的组或簇，根据数据的相似性进行分组。关联规则挖掘：寻找数据中的相关联关系。异常检测：识别与正常模式不符的异常值。预测建模：利用历史数据进行模型建立，预测未来事件。文本挖掘：从非结构化文本数据中提取有用信息。图像和视觉数据挖掘：处理图像和视频数据，提取特征和模式。Web挖掘：从互联网数据中发现有价值的信息。集成学习：结合多个模型以获得更好的预测性能。 主要工具
数据挖掘主要工具如下：
Python：拥有丰富的数据挖掘库和工具包，如NumPy、Pandas、Scikit-learn等。R语言：专用于统计分析和数据挖掘，具有广泛的统计和机器学习包。KNIME：开源的数据挖掘和分析平台，提供直观的图形化界面。RapidMiner：易于使用的数据科学平台，支持数据挖掘、机器学习和预测建模等任务。Weka：一套用于数据挖掘和机器学习的开源软件工具，包含各种算法实现。 这些工具各有特点，用户可以根据具体需求和数据类型选择适合的工具进行数据挖掘工作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bff061f8dfe5c94e8619a456801880f/" rel="bookmark">
			【数据结构】TreeMap和TreeSet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言TreeMap实现的接口内部类常用方法 TreeSet实现的接口常用方法 前言 Map和set是一种专门用来进行搜索的容器或者数据结构，其搜索的效率与其具体的实例化子类有关。
一般把搜索的数据称为关键字（Key），
和关键字对应的称为值（Value），
将其称之为Key-value的键值对。
所以搜索有两种模型：
纯key模型：key-value 模型 Map中存储的就是key-value的键值对，并且key必须是唯一的，
Set中只存储了Key。
TreeMap 使用TreeMap必须导包import java.util.TreeMap;，底层是一棵红黑树。
实现的接口 实现了SortedMap表示TreeMap可以排序，没有实现Collection接口，但是value的类型是Collection。 内部类 内部类Entry，相当于我们前面实现的二叉搜索树中的TreeNode节点，
其中提供了getKey，getValue，setValue方法，
也重写了equals，hashCode，toString方法。
但是Map.Entry&lt;K,V&gt;并没有提供设置Key的方法
方法解释K getKey()返回 entry 中的 keyV getValue()返回 entry 中的 valueV setValue(V value)将键值对中的value替换为指定value 常用方法 方法解释V get(Object key)返回 key 对应的 valueV getOrDefault(Object key, V defaultValue)返回 key 对应的 value，key 不存在，返回默认值defaultValueV put(K key, V value)设置 key 对应的 valueV remove(Object key)删除 key 对应的映射关系Set keySet()返回所有 key 的不重复集合Collection values()返回所有 value 的可重复集合Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()返回所有的 key-value 映射关系boolean containsKey(Object key)判断是否包含 keyboolean containsValue(Object value)判断是否包含 value 注意事项：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bff061f8dfe5c94e8619a456801880f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3707d0eefe8c6a9960171accf65c578b/" rel="bookmark">
			基于 Flutter 从零开发一款产品（一）—— 跨端开发技术介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 相信很多开发者在学习技术的过程中，常常会陷入一种误区当中，就是学了很多技术理论知识，但是仍做不出什么产品出来，往往学了很多干货，但是并无实际的用处。其实，不论是做什么，我们都需要从中获得一些正反馈，有了这些正反馈，才能让我们能够坚持做下去，比如你去做自媒体，如果发布了很多稿件，但是一直没有什么流量，也没有什么人关注与互动，那么你可能很快就无法坚持做下去了，这些可能是一些负反馈，会阻碍你继续做下去，哪怕你真的很热爱做自媒体。学一项技术也是一样的，技术是构建产品的工具，带着目的去学习，在构建产品的过程中，你才会明白如何使用这些技术，理论结合实践，才能对技术有更加深刻的理解。
这个系列，会带你从零到一使用 Flutter 构建一款产品，从产品构想与设计入手，到项目搭建，介绍 Flutter 项目搭建、基础知识，在构建项目的过程中，逐步学会 Fluter 跨平台开发技术，相信通过这样一个项目下来，你也可以使用 Fluter 去做出一些有意思的项目与产品。这个系列的文章，会带你一步步构建一个 B 站视频下载器，目前只有适配桌面端，后续会逐步适配移动端。桌面端界面如下：
代码仓库：https://github.com/kangpeiqin/bilivideo_down 跨端技术：一套代码，多端运行 通常，我们要开发一款移动端或者桌面端应用都需要针对不同的平台使用特定的技术进行开发，比如，开发一款 iOS 和 macOS 应用，那么就需要使用 Swift 或者 ObjectC 语言进行开发，开发一款 Android 应用就需要使用 Java 或者 Kotlin 结合 Android SDK，如果是 Windows 桌面端应用，那么可能就需要使用 C# 语言进行开发，以上，针对不同的不同平台使用平台提供的原生技术进行的应用开发称为原生开发，使用原生开发可以很方便的调用系统提供的控件、API，原生应用的好处是性能可以做到最佳，缺点是每个端都不要单独维护一套代码，开发成本大。对于一个个人开发者或者小公司来说，开发和维护这么多端的应用不太现实，所以跨端技术就出现了，可以让一套代码运行在多个平台。相较于 ReactNative，Flutter 实现了一套自绘制 UI 的引擎，让各平台的 UI 风格保持一致，而且性能更佳，目前支持 Windows、Linux、iOS、macOS 等主流的平台，仅需要一套代码，就可以让应用运行在多个平台当中，当然，如果需要使用到硬件功能，如：调用摄像机拍照等功能，那还需要使用混合开发。更多关于跨端平台技术演变历史的介绍可以查看这里：https://docs.flutter.dev/ 。
后续章节，待更新…
其他章节 基于 Flutter 从零开发一款产品（二）—— 路由导航 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4284a334244eb41af0d384f349b2ebb/" rel="bookmark">
			C&#43;&#43; string模拟实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 如何区分自定义类与标准库中的同名类 // string.h #define _CRT_SECURE_NO_WARNINGS 1 #pragma once #include&lt;iostream&gt; using namespace std; namespace bit { class string { } } // Test.cpp include "string.h" int main() { return 0; } 既然要模拟实现string底层那就得先理解为什么我写的string和库string里面不会冲突。
1 头文件查找路径
当我们用双引号 "" 包围头文件时，编译器会首先在当前目录下查找这个头文件。这意味着它会优先找到我们自己定义的头文件（比如 string.h），而不是标准库中的头文件。因为标准库的头文件通常在其他系统目录中，所以不会发生冲突。
2 避免名字冲突
虽然使用双引号包含头文件可以让编译器优先使用我们自定义的头文件，但如果我们在头文件中定义了一个与标准库相同名称的类或函数，仍然可能导致混淆或冲突。
为了解决这个问题，我们可以使用命名空间。命名空间就像是一个独立的区域，把我们的代码和标准库的代码隔离开来。比如，我们创建一个 bit 命名空间，然后在这个命名空间里定义一个与标准库同名的类或函数，这样就可以避免冲突。
当我们在代码中使用这些定义时，需要明确指明是哪个命名空间下的。比如，使用 bit::string 来表示我们自定义的 string 类，而 std::string 则表示标准库中的 string 类。这样编译器就能清楚地区分它们。
二 构造 / 拷贝 / 析构函数 2.1 构造 2.1.1 空字符串构造函数（默认构造函数） string() :_str(new char[1]) ,_size(0) ,capacity(0) { _str[0] = '\0'; } 在std::string类,空字符串的初始化会创建一个包含单个字符('\0')这个字符用于表示字符串的结束。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4284a334244eb41af0d384f349b2ebb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/004b7a218a8ca441acbac1bd7d7291a8/" rel="bookmark">
			计算机网络——HTTP协议详解（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、HTTP协议简单介绍 1.1 什么是HTTP协议 HTTP（超文本传输协议）是一种用于在Web浏览器和Web服务器之间传输数据的应用层协议。它是一种无状态协议，即服务器不会保留与客户端的任何连接状态信息，每个请求都被视为一个独立的事务。
假设你使用Web浏览器（例如Chrome）访问一个网页。当你在浏览器中输入网址并按下"Enter"键时，浏览器会向服务器发送一个HTTP请求。你也可以理解为HTTP协议是在客户端（浏览器）和服务器之间传输数据的基础（约定）。
1.2 再次理解协议 协议是指在通信过程中，参与方之间所达成的一种约定或规范。在网络通信中，协议是用来定义数据传输规则和通信方式的一组规范。
具体来说，基于HTTP协议，它定义了客户端（例如Web浏览器）和服务器之间进行通信时所需遵循的规范。
HTTP协议主要包含以下几个方面的规定：
请求方式：HTTP协议定义了一系列的请求方法，如GET、POST、PUT、DELETE等，用于告知服务器进行何种操作。
请求和响应格式：HTTP协议规定了请求消息和响应消息的格式。请求消息由请求行、请求头部和请求正文组成，而响应消息由状态行、响应头部和响应正文组成。
状态码：HTTP协议定义了一系列的状态码，用于表示服务器对请求的处理结果。例如，200表示成功、404表示资源未找到、500表示服务器内部错误等。
头部信息：HTTP协议通过头部字段来携带各种元数据，例如Content-Type用于指示请求或响应的数据类型，Content-Length表示消息正文的长度等。
连接管理：HTTP协议还定义了一些机制用于管理连接，如持久连接（keep-alive）允许多个请求和响应复用同一个TCP连接，以减少连接建立的开销。
二、HTTP请求 2.1 HTTP的工作过程 我们不妨先来了解一下HTTP的工作过程。当你在浏览器中输入一个网址并按下"Enter"键时，浏览器就会向服务器发送一个HTTP请求。请求时，浏览器会给服务器发送请求报文。当服务器收到请求后，它会根据请求报文进行相应的处理，并生成一个HTTP响应（响应报文）返回给浏览器。一个请求再加一个回应，就完成了客户端与服务器的数据传输与交互。
上述讲述的都是概念。下面我们结合一段代码来理解。在看代码之前，强调一下HTTP 是一种应用层协议，是基于 TCP/IP 通信协议来传递数据的。具体也可看下图：
demo代码
首先我们需要基于套接字实现一个服务端HttpServer.hpp：
#include &lt;iostream&gt; #include &lt;signal.h&gt; #include "Sock.hpp" class HttpServer { public: using func_t = std::function&lt;void(int)&gt;; private: Sock _serverSock; int _sock; std::string _ip; uint16_t _port; func_t _func; public: HttpServer(uint16_t port, func_t func, std::string ip = "0.0.0.0") :_port(port) ,_func(func) ,_ip(ip) { _sock = _serverSock.Socket(); _serverSock.Bind(_sock, _port, _ip); _serverSock.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/004b7a218a8ca441acbac1bd7d7291a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3356a85287447a23a2d607d31098150d/" rel="bookmark">
			Sublime Text 常用快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你好，我是悦创。
Sublime Text 是一款轻量级且功能强大的代码编辑器，深受开发者喜爱。掌握一些常用的快捷键可以大大提高编码效率。以下是 Sublime Text 中一些常用的快捷键及其功能介绍。
基本操作 新建文件：Ctrl + N
创建一个新的文件。
打开文件：Ctrl + O
打开一个已有文件。
保存文件：Ctrl + S
保存当前文件。
另存为：Ctrl + Shift + S
将当前文件另存为其他文件。
关闭文件：Ctrl + W
关闭当前文件。
退出 Sublime Text：Alt + F4
退出编辑器。
编辑操作 剪切：Ctrl + X
剪切选中的文本。
复制：Ctrl + C
复制选中的文本。
粘贴：Ctrl + V
将剪切或复制的内容粘贴到光标位置。
全选：Ctrl + A
选中整个文件内容。
撤销：Ctrl + Z
撤销上一步操作。
重做：Ctrl + Y 或 Ctrl + Shift + Z
重新执行撤销的操作。
多光标编辑：Ctrl + D
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3356a85287447a23a2d607d31098150d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/50/">«</a>
	<span class="pagination__item pagination__item--current">51/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/52/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>