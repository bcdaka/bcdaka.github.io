<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b58194515ab28a4fc491ec440696081/" rel="bookmark">
			虚拟机可以玩Steam游戏吗？虚拟机怎么玩Steam Windows游戏 PD19虚拟机玩Steam
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你有没有在苹果电脑上玩游戏的需求呢？很多人认为只有“双系统”才能实现Mac电脑运行Windows操作系统，其实不然，近些年来，虚拟机技术在不断发展，越来越多的苹果用户开始使用虚拟机在苹果设备上玩游戏。Steam是一个非常受欢迎的游戏平台，提供了大量的Windows游戏。
对于苹果用户来说，能否在虚拟机中运行Steam及其游戏呢？虚拟机软件哪个更好呢？本文将详细探讨这个问题。
虚拟机可以玩Steam的游戏吗？ 虚拟机技术可以用于运行Steam游戏。通过特定的软件和配置，用户可以在非Windows操作系统（如macOS或Linux）上体验Steam平台上的游戏。这种技术利用了虚拟化软件，如‌Parallels Desktop（PD虚拟机）和VMware（VM虚拟机）等，它们能够在非Windows环境下模拟Windows运行环境，从而让用户能够在这些平台上运行Windows软件和游戏。
尽管许多Windows游戏可以在虚拟机中运行，但并非所有游戏都能顺利运行。原因以及解决办法如下：
1、一些游戏可能对虚拟机环境不兼容，导致无法启动。用户可能需要查找特定游戏的兼容性补丁或配置来解决这些问题。Parallels Desktop用户可以尝试安装Parallels Tools，并勾选自动更新尝试解决问题。
2、如果你玩某些3A大作，但是电脑本身配置较低，可能也无法流畅运行。你可以更换性能更强的Mac电脑。
为什么推荐Parallels Desktop？ 为了确保在虚拟机中可以顺利运行Steam游戏，非常重要的一步是：选择合适的虚拟机软件。与其讨论哪款虚拟机软件最好用，不如讨论哪款虚拟机软件更合适。因为我们需要从多个维度进行考量，包括用户需求、操作系统的兼容性、性能、资源消耗、易用性、价格等因素。适合自己的，才是最好的。
我推荐Parallels Desktop这款虚拟机，以下是推荐它的理由：
1、Parallels Desktop不仅能模拟基础的Windows环境，还提供了极高的性能和兼容性，特别是在图形和游戏方面，这款虚拟机支持DirectX接口。Parallels Desktop在运行游戏时，性能强劲，不会出现卡顿。
2、Parallels Desktop安装Windows以及配置的过程都非常简单，用户只需几步即可创建一个功能齐全的Windows虚拟环境，即使是小白用户也可以快速上手。
3、专为Mac设计，提供无缝的Windows与Mac应用共存体验。支持一键虚拟机创建、即时操作系统切换、触控栏集成等高级功能。对于需要在Mac上频繁使用Windows软件的用户非常友好。
对于Mac用户，尤其是对专业性要求较高的高级用户来说，Parallels Desktop是值得拥有的理想选择。
不过运行虚拟机本身就需要消耗一定的系统资源，可能会出现性能下降的问题。为了获得较好的游戏体验，做出如下建议：
1、建议你使用高配置的苹果设备，并在虚拟机设置中分配足够的CPU和内存资源。
2、建议你更改虚拟机的针对配置为“游戏”，从而获得更佳的游戏体验。
因此，苹果虚拟机能玩Win的Steam吗，对于这个问题，答案是肯定的，但需要满足一定的条件。首先，用户需要一台高性能（M系列芯片，8GB以上RAM）的苹果设备，并选择合适的虚拟机软件，如Parallels Desktop。希望本文对你有所帮助。
Parallels Desktop19 for Mac中文免费安装包（标准版永久）： https://souurl.cn/xmgwMz
Parallels Desktop19 for Mac激活码获取： https://souurl.cn/2SzRay
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c21781671e518dc520aca758f6fdaa8b/" rel="bookmark">
			Unix或Linux系统中创建链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Unix或Linux系统中，链接（Linking）通常指的是创建一个指向现有文件的快捷方式或别名。有两种主要的链接类型：
硬链接（Hard Link）： 硬链接是文件系统的原生特性，它允许一个文件名指向另一个文件的实际位置。硬链接共享文件系统上的实际数据块，因此，删除原始文件不会影响硬链接。硬链接不能跨文件系统创建。 软链接（Symbolic Link）： 软链接，也称为符号链接，是一个指向另一个文件或目录的文本指针。删除原始文件后，软链接将不再指向任何内容。软链接可以跨文件系统创建。 创建硬链接 使用ln命令创建硬链接。例如，要创建一个名为newlink的硬链接，指向现有文件existingfile，可以输入：
ln existingfile newlink 创建软链接 使用ln -s命令创建软链接。例如，要创建一个名为symlink的软链接，指向现有文件existingfile，可以输入：
ln -s existingfile symlink 删除链接 要删除一个硬链接，可以简单地使用rm命令：
rm newlink 要删除一个软链接，同样使用rm命令：
rm -s symlink 这些命令将删除指定的链接，但不会影响原始文件。如果您需要进一步的帮助或更详细的信息，请告诉我。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d971922fc5b6b96a0789994b63b5ec38/" rel="bookmark">
			基于嵌入式C&#43;&#43;、SQLite、MQTT、Modbus和Web技术的工业物联网网关：从边缘计算到云端集成的全栈解决方案设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、项目概述 1.1 项目目标与用途 随着工业4.0时代的到来，传统工业设备与现代信息技术的结合越来越紧密。物联网工业网关作为连接工业设备与云端平台的桥梁，在工业自动化、设备监控、远程运维等方面发挥着至关重要的作用。本项目旨在设计并实现一个能够适用于工业环境的物联网工业网关，支持多种通信协议和云平台集成，满足工业环境中的数据采集、边缘计算、安全管理等需求。
项目目标：
设计一个稳定、可靠的工业网关设备，用于工业数据采集与处理。
支持多种工业通信协议（如Modbus TCP/RTU, CAN, RS-232/485等）。
提供边缘计算能力，实时处理和分析数据。
支持主流云平台的集成，便于远程监控与管理。
确保设备具备高安全性，能够抵御常见的网络威胁。
项目用途：
实现工业设备的远程监控与管理，提高生产效率。
通过边缘计算减少对云端的依赖，降低延迟和带宽消耗。
提供灵活的接口，便于集成到现有的工业自动化系统中。
二、系统架构 2.1 系统架构设计 系统架构的设计需要充分考虑工业环境的需求，包括硬件平台的选择、通信协议的支持、数据处理与存储、安全性、云服务集成等。以下是该系统的整体架构图。
Modbus TCP/RTU, CAN, RS-232/485 边缘计算与数据处理 MQTT, HTTP/HTTPS, OPC UA RESTful API, gRPC Web管理 状态监控 工业设备 物联网工业网关 本地存储 云平台 第三方系统 远程管理界面 日志与监控 系统组件说明：
工业设备： 通过不同的工业通信协议连接到网关，传输数据。
物联网工业网关： 核心组件，负责与工业设备通信、进行数据处理和边缘计算，并将数据传输到云平台或第三方系统。
本地存储： 用于存储经过处理的数据，或在网络连接中断时提供数据缓冲。
云平台： 用于远程数据存储、分析和可视化。支持MQTT、HTTP/HTTPS、OPC UA等协议。
第三方系统： 通过RESTful API或gRPC与网关进行数据交互，实现更多的集成应用。
远程管理界面： 提供Web管理界面，便于用户对网关进行配置和管理。
日志与监控： 实时监控网关状态，并记录系统日志以供故障排查。
2.2 硬件平台选择 网关的硬件平台选择需要考虑工业环境的可靠性和扩展性，通常包括以下组件：
处理器： 选择工业级的ARM Cortex-A系列处理器，能够支持边缘计算需求。
通信接口： 提供丰富的接口如RS-232/485、CAN、以太网等，以支持多种工业协议。
存储： 配备足够的闪存和RAM，用于操作系统、应用程序和数据缓存。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d971922fc5b6b96a0789994b63b5ec38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2770463825b1ec7b49f6269f3a3c1d0/" rel="bookmark">
			在 Vue 2.0 中集成 Markdown 编辑器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在现代 web 开发中，Markdown 编辑器已经成为一种非常流行的工具，广泛应用于博客、评论、文档等场景。在 Vue 2.0 项目中集成一个 Markdown 编辑器，可以极大地提升用户的编辑体验和内容管理效率。本文将介绍如何在 Vue 2.0 中集成一个功能强大的 Markdown 编辑器 —— Vue Markdown Editor。
一、项目准备 首先，确保你已经有一个 Vue 2.0 的项目。如果还没有创建项目，你可以使用 Vue CLI 创建一个新的 Vue 项目：
vue create my-vue-app cd my-vue-app 二、安装 Vue Markdown Editor 我们将使用 @kangc/v-md-editor 这个 Vue 组件库，它提供了一个功能全面且易于使用的 Markdown 编辑器。首先，安装 @kangc/v-md-editor 和相关依赖：
npm install @kangc/v-md-editor @kangc/v-md-editor/lib/theme/default.css @kangc/v-md-editor/lib/themes/vuepress.css npm install @kangc/v-md-editor/lib/previewer/index.css npm install @kangc/v-md-editor/lib/plugins/mermaid 三、配置 Markdown 编辑器 接下来，我们需要在 Vue 项目中配置并使用 Markdown 编辑器。以下是详细的步骤：
1. 创建编辑器组件 在 src/components 目录下创建一个名为 MarkdownEditor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2770463825b1ec7b49f6269f3a3c1d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4468df10678bf2e91738fd99dbcb667d/" rel="bookmark">
			day23-测试自动化之Appium的滑动和拖拽事件、高级手势ActionChains、手机操作API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、滑动和拖拽事件
1.1.应用场景
1.2.swipe滑动事件
1.3.scroll滑动事件
1.4.drag_and_drop拖拽事件
1.5.滑动和拖拽事件的选择
二、高级手势ActionChains
2.1.应用场景
2.2.使用步骤
2.3.注意点
2.4.方法
1).手指轻敲操作 (掌握)
2).手势按下和抬起操作(掌握）
3).等待操作 (掌握)
4).长按操作 (掌握)
5).手指移动操作（掌握）
三、手机操作API
3.1.获取手机分辨率 (掌握)
3.2.手机截图 (掌握)
3.3.获取和设置手机网络 (掌握)
3.4.发送键到设备 (掌握)
3.5.操作手机通知栏 (掌握)
四、今日学习思维导图
一、滑动和拖拽事件 1.1.应用场景 我们在做自动化测试的时候，有些按钮是需要滑动几次屏幕后才会出现，此时，我们需要使用代码来模拟手指的滑动，也就是我们将要学习的滑动和拖拽事件
1.2.swipe滑动事件 1).概念
从一个坐标位置滑动到另一个坐标位置，只能是两个点之间的滑动。
2).方法
2.1).start_x:起点x轴坐标
2.2).start_y：起点Y轴坐标
2.3).end_x:终点x轴坐标
2.4).end_y:终点Y轴坐标
2.5).duration：清动这个操作一共持续的时间长度，单位：mS
2.6).driver.swipe(start_x,start_y,end_x, end_y.,duration=None)
3).核心代码
driver.swipe(100,2000,100,1000)
4).特点
4.1).参数是坐标点
4.2).持续时间短，惯性大
4.3).持续时间长，惯性小
5).代码
import unittest from time import sleep from appium import webdriver from selenium.webdriver.common.by import By # 打开相册 capabilities = {} capabilities['platformName'] = 'Android' capabilities['automationName'] = 'uiautomator2' capabilities['deviceName'] = 'Android' capabilities['appPackage'] = 'com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4468df10678bf2e91738fd99dbcb667d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7849e938c6f46dde3128c25a39e3dc95/" rel="bookmark">
			Python实现水果忍者（开源）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、整体介绍： 1.1 前言： 游戏代码基于Python制作经典游戏案例-水果忍者做出一些改动，优化并增加了一些功能。作为自己Python阶段学习的结束作品，文章最后有源码链接。
1.2 Python主要知识： （1）面向对象编程 类的定义与实例化、封装、继承（使用 pygame.sprite.Sprite 作为基类）
（2）模块与库
导入标准库（time, math, random）、导入第三方库（ pygame）
（3）事件处理
事件监听（pygame.event.get() 处理用户输入和游戏事件）、响应事件（根据不同事件，如关闭窗口、定时器事件，执行相应操作）
（4）图形绘制
图像加载（ pygame.image.load() 加载图像）、图像绘制（blit() 方法将图像绘制到窗口上）、图像旋转（ pygame.transform.rotate() 旋转图像）
（5）随机数生成
（6）计时与帧率控制
使用 pygame.time.Clock() 控制游戏的帧率
（7）文件操作
使用 open() 读取和写入文本文件，保存和读取最佳分数、逐行读取文件内容并解析数据
（8）碰撞检测
（9）Sprite 和 Group
使用 pygame.sprite.Sprite 创建精灵（如水果、刀光、背景）、使用 pygame.sprite.Group 管理和更新多个精灵，方便批量处理
（10）数学运算
使用三角函数，math.sin() 和 math.cos()，计算水果的抛出轨迹
（11）音频处理
使用 pygame.mixer 播放背景音乐和音效，增强游戏体验
（12）逻辑控制
（13）字体与文本渲染
使用 pygame.font.Font() 创建字体对象，并使用 render() 方法渲染文本以显示分数和信息
（14）参数传递与返回值
1.3 游戏素材 二、完善功能： （1）优化游戏参数 例如：首页旋转圆环速度，水果上抛高度等，使游戏体验更加平滑。
（2）禅宗模式倒计时 禅宗模式在游戏右上方增加了时间倒计时的图形化界面。
（3）增加额外音效 由于pygame同时播放音乐，会有覆盖现象。即后播放音乐会覆盖之前播放音乐，导致原版游戏结束，bgm.play_over被bgm.play_menu覆盖，播放不出来。使用独立线程对代码要求较高，取巧，利用睡眠（time.sleep）。玩家切到炸弹结束游戏，暂停0.3s画面，而不是原版的突然重新开始。
（4）游戏历史最高分数 利用IO流逐行读取txt文件，和原版分数一样的window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7849e938c6f46dde3128c25a39e3dc95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98a06b94addac1580bc6272b80bd1422/" rel="bookmark">
			Django后端架构开发：视图与模板的正确使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌟 Django后端架构开发：视图与模板的正确使用 🔹 view、render、redirect 在Django中，视图（view）是处理用户请求的核心，它接收一个HttpRequest对象并返回一个HttpResponse对象。Django提供了两种主要的视图方式：函数视图和类视图。
函数视图：最常见的视图类型，直接使用Python函数来处理请求。
from django.http import HttpResponse def my_view(request): # 处理逻辑 return HttpResponse("这是一个函数视图的响应") render：这是一个快捷函数，用于将模板与上下文数据结合并返回一个HttpResponse对象。
from django.shortcuts import render def my_render_view(request): context = {'name': 'Django'} return render(request, 'template.html', context) redirect：用于重定向到另一个URL或视图。
from django.shortcuts import redirect def my_redirect_view(request): return redirect('/some/url/') 🔹 视图 HttpResponse 和 JsonResponse HttpResponse：这是Django最基础的响应对象，表示服务器返回的内容。
from django.http import HttpResponse def simple_view(request): return HttpResponse("简单的文本响应") JsonResponse：这是HttpResponse的子类，用于返回JSON格式的数据，非常适合API开发。
from django.http import JsonResponse def json_view(request): data = {'key': 'value'} return JsonResponse(data) 🔹 函数视图和类视图 as_view() 方法 函数视图：前面已经展示过，直接使用Python函数来处理请求。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98a06b94addac1580bc6272b80bd1422/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f9e2a55075bcca1847abb47450c1837/" rel="bookmark">
			大数据-87 Spark 集群 案例学习 Spark Scala 案例 手写计算圆周率、计算共同好友
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点一下关注吧！！！非常感谢！！持续更新！！！ 目前已经更新到了： Hadoop（已更完）HDFS（已更完）MapReduce（已更完）Hive（已更完）Flume（已更完）Sqoop（已更完）Zookeeper（已更完）HBase（已更完）Redis （已更完）Kafka（已更完）Spark（正在更新！） 章节内容 上节我们完成了如下的内容：
Spark 学习 WordCount 程序Scala &amp; Java 的方式分别编写 WordCount 程序 计算圆周率 需求背景 我们要实现一个程序来实现圆周率的计算，将利用下面的公式：
编写代码 package icu.wzk import org.apache.spark.{SparkConf, SparkContext} import scala.math.random object SparkPi { def main(args: Array[String]): Unit = { var conf = new SparkConf() .setAppName("ScalaSparkPi") .setMaster("local[*]") val sc = new SparkContext(conf) sc.setLogLevel("WARN") val slices = if (args.length &gt; 0) { args(0).toInt } else { 0 } val N = 100000000 val count = sc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f9e2a55075bcca1847abb47450c1837/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67c756622ecc32d12d01194fc7ec84fe/" rel="bookmark">
			Bootstrap UI 编辑器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是 15 款最好的 Bootstrap 编辑器或者是在线编辑工具。
1. Bootstrap Magic 这是一个 Bootstrap 主题生成器，使用最新的 Bootstrap 3 版本和 Angular JS 版本，提供一个鲜活的用户修改预览。它包括了各种各样的导入，一个颜色选择器和智能的预先输入。更神奇的是，Bootstrap 会根据用户的每个选择来重新建立框架，方便用户的下载和使用。
2. BootSwatchr BootSwatchr 是由 Drew Strickiand 独立开发和维护的，是唯一支持从右到左语言显示的 Bootstrap 自定义构建工具，这也是它的特色之一。BootSwatchr 是个可视化的工具，可以从底层开始创建 Bootstrap 主题。
3. Bootstrap Live Editor Bootstrap Live Editor 是个所见即所得的构建 Bootstrap 的编辑器。在 Bootstrap 准备好的内容和代码片段的基础上提供一个又好又优雅的方法来编辑和美化 html，也因此它是个明智的选择。除此之外，它还包括高级的选项比如按钮配置，自定义标签和为用户做最明智最有益的选择。
4. Fancy Boot Fancyboot 是个非常有用的 Bootstrap 自定义工具，允许用户编辑 Bootstrap 的配置，自动预览他们的修改结果。通过滑动菜单可以选择需要使用的插件和组件。当用户做好了相应的修改，可以下载一个包含用户所使用的 jQuery 插件的编译好的和简化后的 CSS 文件。
5. Style Bootstrap Style Bootstrap 是个非常棒的内置浏览器的 GUI 实用工具，帮助用户自定义 Twitter Bootstrap 外观。它非常容易进行自定义操作。从 body 风格，字体排版，按钮，导航，格式，通知提示和其他用户很容易根据自己的意愿自定义的元素。除了强大的自定义功能，它还可以很容易生成可下载的 CSS 文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67c756622ecc32d12d01194fc7ec84fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7563dc61fabda659d0727b8b9cf28aed/" rel="bookmark">
			C:数组传参的本质
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、一维数组传参的本质 数组传参是指在函数调用时将数组作为参数传递给函数。
int main() { int arr[10] = { 1,2,3,4,5,6,7,8,9,10 }; test(arr); return 0;} 数组传参只需要写数组名就可以了。注意：数组名是arr，而不是arr[10]
数组传参形参该怎么写呢？
void test(int arr[])//元素个数写不写无所谓 等下会说为什么写不写都不影响
现在我们来分别在(test)函数外部与函数内部计算数组元素的个数、
来，展示！
可以看到在函数内部sz2结果为1，而函数外部sz1结果为10；这是为什么呢？
关于sz1 = 10；的结果我们都清楚，sizeof(arr)求得数组的总大小，sizeof(arr[0])求得数组首元素的大小，然后得出元素个数，但是为什么在test函数内部求得的元素个数结果变为1了呢？
我们来逆推一下，首先sizeof(arr[0])表示的是数组首元素的大小是不变的，因此sizeof(arr[0])等于4
sz2 = sizeof(arr) / 4 = 1；因此sizeof(arr)也等于4，那么在什么情况下能得到aizeof(arr) = 4 呢？
在数组传参的时候 test(arr)；我们传递的是整个数组吗？还记得前面关于数组名的理解吗？这里arr既不是在sizeof中，前面也没有&amp;符号，所以，test(arr)中的arr指的就是数组首元素的大小，因此我们传参过去的是首元素的地址，这便是一维数组传参的本质，既如此，我们便可以明白aizeof(arr) = 4是怎么得到的了，地址在32位机器上占4个字节，在64位机器上占8个字节 ，小编是在32位上操作的，所以最终得到izeof(arr) = 4 的结果。
void test(int arr[])//元素个数写不写无所谓 { int sz2 = sizeof(arr) / sizeof(arr[0]); printf("sz2 = %d\n", sz2); } #include &lt;stdio.h&gt; int main() { int arr[10] = { 1,2,3,4,5,6,7,8,9,10 }; int sz1 = sizeof(arr) / sizeof(arr[0]); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7563dc61fabda659d0727b8b9cf28aed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/239a4bd6b340b1a077fbcc7c5b11122a/" rel="bookmark">
			Sublime Text 4 (Build 4180) 编译环境设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查找和替换 : 【807905000F94C2】替换为【C6410501B20090】
Python.sublime-build { "cmd": ["python", "-u", "${file_name}"], "file_regex": "^[ ]*File \"(...*?)\", line ([0-9]*)", "working_dir": "${file_path}", "selector": "source.python", "env": {"PYTHONIOENCODING": "utf-8"}, "variants": [ { "name": "Python (cmd)", "shell_cmd": "start cmd /c \"python -u \"${file_name}\" &amp; pause\"" } ] } JavaC.sublime-build { "shell_cmd": "javac -encoding UTF-8 \"${file_name}\" &amp;&amp; start cmd /c \"java \"${file_base_name}\" &amp; pause\"", "file_regex": "^(...*?):([0-9]*):?([0-9]*)", "working_dir": "${file_path}", "selector": "source.java", "encoding": "gbk", "variants": [ { "name": "Single File Build"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/239a4bd6b340b1a077fbcc7c5b11122a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/072ae1d39c9c9eee54c59ad56885a7df/" rel="bookmark">
			算法【Java】—— 双指针算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双指针算法 常见的双指针有对撞指针，快慢指针以及前后指针（这个前后指针是指两个指针都是从从一个方向出发，去往另一个方法，也可以认为是小学学习过的两车并行，我也会叫做同向指针），在前后指针这里还有一个经典的算法叫做滑动窗口，滑动窗口会在下一篇算法文章中提到
对撞指针可以叫做左右指针，就是一个指针在最左端，另一个指针在最右端，然后两个指针开始向中间逼近。
快慢指针：相信大家在链表的时候就已经学到过，就是一个指针每次走一步（这就是慢指针），另一个指针每次走两步（这是快指针）。一般快慢指针是用来处理处理环形链表或数组。
前后指针：在不涉及到滑动窗口的使用的时候，我们一般会用于数组的分区。
如果大家学过排序，想必对双指针应该十分了解，正好在学习双指针算法的时候，可以回顾一下排序内容。
题目实战 下面题目讨论的时间复杂度没有进行化简，目的是让大家更好地感受算法对性能的优化。
移动零 https://leetcode.cn/problems/move-zeroes/description/
解法：前后指针
题目要求我们将数组前面的零移动到后面，将非零的元素按照原本的相对位置存放到数组的前面。
这时候这个数组显而易见地被分成了两个部分，一个是非零区域，一个是零区域
我们可以使用前后指针法，第一个指针从下标0开始遍历数组，第二个指针初始值设置为-1，当第一个指针遇到非零元素时，第二个指针向后移动一步，然后交换两个指针所对应的数组的元素，否则第二个指针原地不动。
通过前后指针，我们可以将数组分成上述的区域，这就是为什么前后指针一般用于数组的分区。
class Solution { public void moveZeroes(int[] nums) { int len = nums.length; int j = -1; for(int i = 0; i &lt; len; i++) { if(nums[i] != 0) { j++; int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; } } } } 如果可以使用额外的空间的话，还是使用两个指针，一个指针指向一个数组，时间复杂度为O(2N)，空间复杂度为O(N)，但是直接使用双指针算法，时间复杂度O(2N)，空间复杂度为O(1)
快乐数 https://leetcode.cn/problems/happy-number/
解法：快慢指针
在快乐数的循环中，我们知道循环最后的结果要么是无限循环，要么是 1，那无限循环是为什么？
以 n = 2 为例：2 ^ 2 = 4，4 ^ 2 = 16，1 ^ 2 + 6 ^ 2 = 37，3 ^ 2 + 7 ^ 2 = 58，5 ^ 2 + 8 ^ 2 = 89，8 ^ 2 + 9 ^ 2 = 145, 1 ^ 2 + 4 ^ 2 + 5 ^ 2 = 42，4 ^ 2 + 2 ^ 2 = 20，2 ^ 2 + 0 = 2，最后你会发现这个数它又回去了，也就是意味着这个循环形成了一个环
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/072ae1d39c9c9eee54c59ad56885a7df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/504002c014b124f36045ff048ece1330/" rel="bookmark">
			XMOS 多路音频解码器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当谈及高性能音频解码器，XMOS 是一个不容忽视的名字。作为音频解决方案领域的领军者，XMOS 的多路音频解码器在音频处理技术中扮演着至关重要的角色。下面我们一起深入探讨 XMOS 多路音频解码器去了解这一技术的魅力。
设计背景：追求音频极致
XMOS 的多路音频解码器源于对音频质量极致追求的设计理念。随着数字音频技术的发展，对音频解码器的要求不断提高。传统的音频解码器虽然能满足基本需求，但在多通道处理、高解析度音频支持、实时性能等方面常显得捉襟见肘。XMOS 作为一家领先的半导体公司，致力于开发一种能够突破这些限制的解决方案，满足现代音频系统对高质量、多通道音频处理的需求。
工作原理：音频解码的心脏
XMOS 多路音频解码器的核心在于其强大的处理能力和灵活的架构。其工作原理可以分为以下几个步骤：
数字信号处理（DSP）：XMOS 解码器内置了高性能的 DSP 核心，能够高效地处理复杂的音频信号。DSP 核心负责执行各种音频算法，包括滤波、均衡和空间处理等，确保音频信号在转换过程中的质量和准确性。多路通道处理：与传统解码器不同，XMOS 的解码器能够同时处理多个音频通道。这对于需要多声道音频的应用（如家庭影院和高端音响系统）至关重要。它支持从立体声到多声道音频的广泛格式，确保声音的全方位传递。高解析度支持：XMOS 解码器支持高分辨率音频格式（如 24 位/192 kHz 或更高），能够处理更加细腻和真实的音频信号。这样的高解析度支持使得音频重现更加准确，细节更丰富。实时处理：为了保证音频信号的实时性，XMOS 解码器采用了高效的处理架构，能够快速响应音频数据的变化。这对于需要低延迟处理的应用（如游戏音效和实时语音通信）尤其重要。 产品优点：无与伦比的音质体验
XMOS 多路音频解码器的优势在于其卓越的性能和广泛的适用性：
音质卓越：通过高精度的数字信号处理和高分辨率支持，XMOS 解码器能够提供清晰、细腻的音质，使用户能够听到音频中的每一个细节。无论是音乐、电影还是游戏，声音都能精准还原，带来身临其境的体验。灵活的配置：XMOS 解码器支持多种音频格式和通道配置，适用于各种音频系统。无论是简单的立体声系统还是复杂的多声道影院系统，XMOS 解码器都能轻松应对。低延迟性能：由于其高效的实时处理能力，XMOS 解码器在音频处理过程中几乎没有延迟。这对于需要快速响应的应用（如实时游戏和语音通信）尤为重要，确保音频与视觉效果同步。易于集成：XMOS 解码器的设计考虑了系统集成的便利性。它提供了多种接口选项和灵活的配置方式，能够与各种音频设备和系统无缝对接，简化了设计和集成过程。 适用范围：广泛应用，覆盖多个领域
XMOS 多路音频解码器的强大功能使其适用于广泛的应用场景，包括：
家庭影院系统：在家庭影院中，XMOS 解码器能够处理多声道音频信号，提供高质量的环绕声体验，让观众仿佛身临其境。高端音响系统：对于追求极致音质的音响爱好者，XMOS 解码器的高分辨率支持和精细音频处理能够提升整体音质，带来更真实的音乐体验。游戏设备：在游戏设备中，XMOS 解码器的低延迟性能确保了音频效果与游戏画面的实时同步，增强了玩家的沉浸感。实时语音通信：在需要实时语音通信的应用中，如会议系统和语音助手，XMOS 解码器的高效处理能力和低延迟表现尤为重要，提供清晰、流畅的语音质量。 结论
XMOS 多路音频解码器代表了音频技术的前沿，它通过强大的数字信号处理能力、灵活的多通道支持和高解析度音频处理，为用户带来了无与伦比的音质体验。无论是在家庭影院、高端音响系统、游戏设备还是实时语音通信中，XMOS 解码器都能提供卓越的音频性能，满足各种应用场景的需求。通过这些先进的技术，我们不仅能够享受高保真的音乐，还能体验到音频领域的未来科技。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6a0299504e7973af381105fb4849f65/" rel="bookmark">
			开源离线安卓九宫格拼音同文输入法(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开源离线九宫格拼音输入法(1) 本文从一个开源贡献者的视角，介绍了同文输入法项目，包括如何安装软件、如何克隆仓库、如何使用AndroidStudio运行和打包、如何配置九宫格输入法，并提供相关压缩包，帮助后来者少走弯路，减少从开始到放弃的情况。
众所周知，输入法极其容易泄露个人隐私。出于信息安全的考虑，本人对于开发独立自主的九宫输入法有极大的兴趣。然而，主要的开源输入法都对九宫输入的支持较差。因此，本人致力于完善同文输入法的九宫输入方式。恳请大家一起来！有任何问题都可以私信我！
一、安装Java8 因为支持九宫输入的trime的最后一个版本是v3.2.9，该版本使用Java8编写。
设置环境变量JAVA_HOME，在Path变量增加%JAVA_HOME%\bin。
二、安装AndroidStudio 参考Android实战——正确配置 XXX_HOME 环境变量，该博客介绍了JAVA_HOME、ANDROID_HOME、ANDROID_SDK_HOME、GRADLE_USER_HOME、GRADLE_HOME。
本人安装的是最新版2024.1.1 Patch 2版本。
然后设置环境变量ANDROID_HOME（X:xxx/Android/Sdk）、ANDROID_SDK_HOME（会自动新建.android目录保存模拟器文件）、GRADLE_USER_HOME（对应.gradle目录，保存Gradle包），在Path变量增加%ANDROID_HOME%。
不设置ANDROID_SDK_HOME、GRADLE_USER_HOME这两个变量的话，系统盘空间将被大量占用。
三、克隆trime仓库 可以简单阅读一下开源同文输入法trime文档。
由于GitHub网络不稳定，而仓库巨大，强烈建议使用外国服务器clone（比如google的colab，各显神通吧）。
也可以私信我要压缩包。
git config --global core.symlinks true git clone --branch v3.2.9 --single-branch git@github.com:osfans/trime.git cd trime git switch -c v3.2.9 # 或者 git checkout -b v3.2.9 git branch git submodule update --init --recursive 四、修改trime仓库 准备librime plugins
cd trime\app\src\main\jni，
将librime-lua-deps/lua5.4复制到librime-lua/thirdparty下，
然后将librime-charcode、librime-lua、librime-octagram复制到librime\plugins下。
修改trime/app/src/main/jni/librime_jni/rime_jni.cc
参考[dev] Cannot compile at windows (undefined symbol)，注释掉declare_librime_module_dependencies()、rime_require_module_lua()、rime_require_module_charcode()、rime_require_module_octagram()等相关代码，保存。
五、编译trime项目 AndroidStudio打开trime项目。
本人的P30手机搭载的是Hormony3 OS（基于安卓10，API Level 29），故修改trime/app/build.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6a0299504e7973af381105fb4849f65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3ab804c8d16d6a4ef32960f7f458777/" rel="bookmark">
			Datawhale AI夏令营第四期魔搭-AIGC文生图方向Task1笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Datawhale AI夏令营第四期魔搭-AIGC文生图方向Task1笔记 作者: 福州大学 切记我是一个温柔的刀客
2024/8/10
从零入门AI生图原理&amp;实践 是 Datawhale 2024 年 AI 夏令营第四期的学习活动（“AIGC”方向），基于魔搭社区“ 可图Kolors-LoRA风格故事挑战赛 ”开展的实践学习——
适合想 入门并实践 AIGC文生图、工作流搭建、LoRA微调 的学习者参与 学习内容提要：从文生图实现方案逐渐进阶，教程偏重图像工作流、微调、图像优化等思路，最后会简单介绍AIGC应用方向、数字人技术（选学）
1 赛题解读 2 文生图的历史 文生图（Text-to-Image Generation）是一种通过文本生成图像的技术，其发展历程可以追溯到早期的计算机视觉和自然语言处理研究。这一技术的历史可以分为几个关键阶段：
3 文生图基础知识介绍 文生图主要以SD系列基础模型为主，以及在其基础上微调的lora模型和人物基础模型等。
接下来，我们简单了解下提示词、lora、ComfyUI和参考图控制这些知识点。
提示词 提示词很重要，一般写法：主体描述，细节描述，修饰词，艺术风格，艺术家
举个例子:
【promts】Beautiful and cute girl, smiling, 16 years old, denim jacket, gradient background, soft colors, soft lighting, cinematic edge lighting, light and dark contrast, anime, super detail, 8k 【负向prompts】(lowres, low quality, worst quality:1.2), (text:1.2), deformed, black and white,disfigured, low contrast, cropped, missing fingers Lora Stable Diffusion中的Lora（LoRA）模型是一种轻量级的微调方法，它代表了“Low-Rank Adaptation”，即低秩适应。Lora不是指单一的具体模型，而是指一类通过特定微调技术应用于基础模型的扩展应用。在Stable Diffusion这一文本到图像合成模型的框架下，Lora被用来对预训练好的大模型进行针对性优化，以实现对特定主题、风格或任务的精细化控制。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3ab804c8d16d6a4ef32960f7f458777/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e4541f52316d2c11e18ee8cadfda38e/" rel="bookmark">
			【Redis】Redis 数据类型与结构—（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis 数据类型与结构 一、值的数据类型二、键值对数据结构三、集合数据操作效率 一、值的数据类型 Redis “快”取决于两方面，一方面，它是内存数据库，另一方面，则是高效的数据结构。
Redis 键值对中值的数据类型，也就是数据的保存形式有5种：String（字符串）、List（列表）、Hash（哈希）、Set（集合）和 Sorted Set（有序集合）。这5种数据类型由6种底层结构实现：简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组。
String 类型的底层实现只有一种数据结构，简单动态字符串，而 List、Hash、Set 和 Sorted Set 这四种数据类型，都有两种底层实现结构，这四种类型称为集合类型，特点是一个键对应了一个集合的数据
二、键值对数据结构 Redis 使用哈希表来保存所有键值对，实现从键到值的快速访问。哈希表就是一个数组，每个元素称为一个哈希桶，哈希桶中的元素保存的并不是值本身，而是指向具体值的指针。哈希表保存了所有的键值对，也称为全局哈希表，时间复杂度为O(1)
当 Redis 中写入大量数据后，哈希表的冲突问题和 rehash 可能导致操作变慢。
哈希冲突是指，两个 key 的哈希值落在了同一个哈希桶中，毕竟，哈希桶的个数通常要少于 key 的数量。
Redis 通过链式哈希解决哈希冲突，就是指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。
随着数据量增大，哈希冲突可能也会越来越多，这就会导致某些哈希冲突链过长，链上的元素只能通过指针逐一查找再操作，进而导致查询效率降低。
Redis 会对哈希表做 rehash 操作来解决这个问题，也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。
Redis 会将哈希表的数据拷贝到另一个容量更大的哈希表，清空原来的准备下一次 rehash，这样依然会有问题，因为在数据量大的基础上拷贝会造成 Redis 线程阻塞。为了避免这个问题，Redis 采用了渐进式 rehash，就是将拷贝过程的开销分摊到每次请求时进行，从而保证查询效率。
三、集合数据操作效率 对于 String 类型来说，找到哈希桶就能直接增删改查了，所以，哈希表的 O(1) 操作复杂度也就是它的复杂度了。对于集合类型来说，找到哈希桶后，增删改查都是对集合操作的，不同的集合类型时间复杂度是不一样的。
哈希表的特点上面提到了，复杂度是O(1)，整数数组和双向链表也很常见，通过数组下标或者链表的指针逐个元素访问，操作复杂度基本是 O(N)，操作效率比较低。压缩列表和跳表是 Redis 重要的数据结构，下面介绍一下。
压缩列表类似于一个数组，不同之处在于表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数，压缩列表在表尾还有一个 zlend，表示列表结束。
查找第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而查找其他元素时，复杂度就是 O(N) 了
跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位，当数据量很大时，跳表的查找复杂度就是 O(logN)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e4541f52316d2c11e18ee8cadfda38e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b36b62ecbc194722f42b783913b133ec/" rel="bookmark">
			【Redis】Linux CentOS Redis 的安装—（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Redis 一、获取源二、解压编译 一、获取源 //redis-stable是最新稳定版 wget https://download.redis.io/redis-stable.tar.gz 二、解压编译 //我指定目录/app tar -xzvf redis-stable.tar.gz -C /app cd /app/redis-stable make &amp;&amp; make install ##三 、修改配置启动
//设置后台运行 daemonize no 改成 yes //运行远程访问 #bind 127.0.0.1 -::1 注释这句 //设置密码 requirepass 你的密码 //启动（退出不停服务） redis-server /app/redis-stable/redis.conf 四、测试
redis-cli auth 你的密码 set test wintersir get test 客户端测试（云服务器需要设置安全组规则端口6379） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2a236b10838c6b6e8203acf64137bea/" rel="bookmark">
			【Python快速入门和实践020】Python常用脚本-查看电脑基本信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、功能介绍 这段代码的功能是收集并展示计算机系统的详细信息，包括操作系统、版本、架构、处理器等硬件信息以及内存和磁盘的使用情况。下面是代码的详细说明：
代码功能概述 获取系统信息 (get_system_info 函数): 这个函数负责收集系统的信息，包括操作系统名称、版本、架构、处理器型号、物理核心数、逻辑处理器数、总内存和可用内存等。
磁盘使用情况 (get_system_info 函数的一部分): 对于每个磁盘分区，该函数会获取其总容量、已用空间和剩余空间，并将这些信息存储在一个字典中。
打印系统信息 (print_system_info 函数): 这个函数用于格式化并打印从 get_system_info 函数中获取的数据。它会按照一定的格式输出每项信息，对于磁盘使用情况则进一步细分展示每个分区的信息。
代码结构详解 导入必要的模块:
platform: 用于获取操作系统相关的详细信息。psutil: 提供了跨平台的方法来获取进程和系统利用率（CPU、内存、磁盘、网络等）的信息。 定义 get_system_info 函数:
使用 platform 模块获取操作系统、版本、架构、处理器等信息。使用 psutil 模块获取 CPU 核心数、逻辑处理器数、内存使用情况。遍历所有磁盘分区，获取每个分区的总容量、已用空间和剩余空间。 定义 print_system_info 函数:
打印标题和分隔线。遍历收集到的信息字典，并根据数据类型进行格式化输出。如果遇到磁盘使用情况的子字典，则进一步展示每个磁盘分区的详细信息。 主执行部分 (if __name__ == "__main__":):
调用 get_system_info 函数获取系统信息。调用 print_system_info 函数打印收集到的信息。 二、代码 import platform import psutil def get_system_info(): info = {} info['操作系统'] = platform.system() info['系统版本'] = platform.version() info['架构'] = platform.architecture()[0] info['机器类型'] = platform.machine() info['处理器'] = platform.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2a236b10838c6b6e8203acf64137bea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8127218e6bcd4289fcbf8e8115e247f2/" rel="bookmark">
			【C&#43;&#43;深度探索】unordered_set、unordered_map封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥 个人主页：大耳朵土土垚 🔥 所属专栏：C++从入门至进阶 这里将会不定期更新有关C/C++的内容，欢迎大家点赞，收藏，评论🥳🥳🎉🎉🎉 文章目录 前言1. unordered_set和unordered_map介绍✨unordered_map介绍✨unordered_set介绍 2. 修改哈希表3. 迭代器✨const迭代器 4. unordered_map的[]访问5. unordered_set和unordered_map封装✨修改后的哈希表✨unordered_map类✨unordered_set类 6. 结语 前言 前面我们学习过红黑树实现map、set的封装，而unordered_set和unordered_map的功能与map和set类似，所不同的是其存储元素是无序的，底层是使用哈希表，所以今天我们就可以利用之前学习过的哈希表的实现，来对C++STL库中的unordered_set和unordered_map进行模拟实现。
1. unordered_set和unordered_map介绍 在C++98中，STL提供了底层为红黑树结构的一系列关联式容器，例如：map、set。在查询时效率可达到 l o g 2 N log_2 N log2​N，即最差情况下需要比较红黑树的高度次，当树中的节点非常多时，查询效率也不理想。最好的查询是，进行很少的比较次数就能够将元素找到，因此在C++11中，STL又提供了4个unordered系列的关联式容器，这四个容器与红黑树结构的关联式容器使用方式基本类似，只是其底层结构不同。
✨unordered_map介绍 介绍文档，点击跳转
unordered_map是存储&lt;key, value&gt;键值对的关联式容器，其允许通过key快速的索引到与其对应的value。在unordered_map中，键值通常用于惟一地标识元素，而映射值是一个对象，其内容与此键关联。键和映射值的类型可能不同。在内部,unordered_map没有对&lt;kye, value&gt;按照任何特定的顺序排序, 为了能在常数范围内找到key所对应的value，unordered_map将相同哈希值的键值对放在相同的桶中。unordered_map容器通过key访问单个元素要比map快，但它通常在遍历元素子集的范围迭代方面效率较低。unordered_maps实现了直接访问操作符(operator[])，它允许使用key作为参数直接访问value。 unordered_map和map核心功能重复90%，它们区别在于：
对键值对中key要求不同： map：key要支持比较大小unordered_map：key要支持转换成整型+比较相等 map遍历有序，unordered_map遍历无序map有双向迭代器，unordered_map单向迭代器它们之间性能有差异 unordered_map常见接口：
函数声明功能介绍unordered_map()构造不同格式的unordered_map对象bool empty() const检测unordered_map是否为空size_t size() const获取unordered_map的有效元素个数begin返回unordered_map第一个元素的迭代器end返回unordered_map最后一个元素下一个位置的迭代器cbegin返回unordered_map第一个元素的const迭代器cend返回unordered_map最后一个元素下一个位置的const迭代器operator[]返回与key对应的valueiterator find(const K&amp; key)返回key在哈希桶中的位置size_t count(const K&amp; key)返回哈希桶中关键码为key的键值对的个数insert向容器中插入键值对erase删除容器中的键值对void clear()清空容器中有效元素个数void swap(unordered_map&amp;)交换两个容器中的元素size_t bucket_count()const返回哈希桶中桶的总个数size_t bucket_size(size_t n)const返回n号桶中有效元素的总个数size_t bucket(const K&amp; key)返回元素key所在的桶号 注意：operator[]函数中实际调用哈希桶的插入操作，用参数key与V()构造一个默认值往底层哈希桶中插入，如果key不在哈希桶中，插入成功，返回V()，插入失败，说明key已经在哈希桶中，将key对应的value返回。这与之前的map类似，插入函数返回一个键值对，键存放指针，对存放bool值，用来判断是否插入成功。
✨unordered_set介绍 文档介绍，点击跳转
unordered_set与unordered_map类似，不同在于前者储存单个数据，后者储存键值对，这里就不过多介绍。
2. 修改哈希表 因为我们要使用哈希表来实现对unordered_set和unordered_map的封装，之前实现的哈希表都是插入键值对，是没办法很好封装unordered_set的，所以我们先得对哈希表进行改造，改造类似于使用红黑树封装map和set对红黑树的改造，具体实现如下：
我们之前模拟实现过哈希表，插入的节点是键值对pair类型，而如果要使用哈希表来对unordered_set和unordered_map封装的话，unordered_set存储的应该是单个值，而不是键值对，所以我们就需要对哈希表进行修改，使得unordered_set和unordered_map都能适用：
首先哈希表存储节点的类需要从只能存储键值对改为能够存储任意数据： 修改前： template&lt;class K,class V&gt; struct HashNode { pair&lt;K, V&gt; _kv; HashNode&lt;K, V&gt;* _next; HashNode(const pair&lt;K, V&gt;&amp; kv) :_kv(kv) , _next(nullptr) {} }; 修改后： template&lt;class T&gt; struct HashNode { T _data; HashNode&lt;T&gt;* _next; HashNode(const T&amp; data) :_data(data) , _next(nullptr) {} }; 相应的，哈希表的模板参数也需要修改： 修改前： //哈希表类 template&lt;class K,class V, class Hash = HashFunc&lt;K&gt;&gt; class HashTable { public: typedef HashNode&lt;K,V&gt; Node; Node* Find(const K&amp; key);//查找函数 private: vector&lt;Node*&gt; _tables; size_t _n;//记录存储数据个数 }; 因为节点类只有一个模板参数了，所以哈希表前面两个模板参数有点多余，但是如果将哈希表的模板参数也改为一个，如下面代码所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8127218e6bcd4289fcbf8e8115e247f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3782f317cb26809aaeeb9e5aadd1aee/" rel="bookmark">
			【JAVA多线程】JDK线程同步工具：Semaphore、CountDownLatch、CyclicBarrier
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.可能会遇到的线程协作场景
2.Semaphore
3.CountDownLatch
4.CyclicBarrier
1.可能会遇到的线程协作场景 在并发编程中，线程除了独自向前运行，还可能相互之间要进行协作，以保证完成最终总的目标。可能会遇到的几种任务之间的协作：
情景1：限定任务数
由于资源有限，限制最多有多少个线程进行工作
情景2：任务之间有依赖关系
一个线程依赖于其它线程的执行结果，这个线程就必须等待其它线程执行完成才能继续往下走
情景3：任务分阶段
批量线程分阶段执行，每一个阶段是一个同步点，执行完的线程必须阻塞在同步点上等待同批的其它线程也执行完，再进入下一个阶段。由于阶段可能有多个，所以要用condition来实现。
情景4：动态调整线程数量
不管是情景2也好还是情景3也好，都有可能有动态调整线程的可能性
2.Semaphore semaphore，信号量，用来解决情景1。
业务情景：
我们有一个资源，只允许最多 3 个线程同时访问。我们将使用 Semaphore 来实现这一功能。
代码示例：
import java.util.concurrent.Semaphore; import java.util.concurrent.TimeUnit; ​ public class SemaphoreExample { ​ private static final int MAX_CONCURRENT_ACCESS = 3; private static final Semaphore semaphore = new Semaphore(MAX_CONCURRENT_ACCESS); ​ public static void main(String[] args) { for (int i = 0; i &lt; 10; i++) { new Thread(() -&gt; { try { // 获取许可 semaphore.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3782f317cb26809aaeeb9e5aadd1aee/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/41/">«</a>
	<span class="pagination__item pagination__item--current">42/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/43/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>