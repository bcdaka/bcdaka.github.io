<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49864682aaf8d6addd2c2f2e28d43cad/" rel="bookmark">
			Redis学习——Redisson 分布式锁集成及其简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引言1. Redisson概述1.1 Redisson的基本概念1.2 Redisson的主要功能1.3 Redisson的优点 2. 开发环境3. Redisson的安装与配置3.1 添加依赖3.2 配置Redisson 4. 使用Redisson4.1 可重入锁4.1.1 可重入锁的概念4.1.2 可重入锁的实现原理4.1.3 简单使用锁的获取和释放 4.2 公平锁4.2.1 公平锁的概念4.2.2 公平锁的实现原理4.2.3 简单使用 4.3 读写锁4.3.1 读写锁的概念4.3.2 读写锁的实现原理4.3.3 简单使用 4.4 联锁4.4.1 联锁的概念4.4.2 联锁的实现原理4.4.3 简单使用 5. WatchDog机制6. 总结 引言 在分布式系统中，经常需要对共享资源进行并发访问控制，以确保数据的一致性和完整性。分布式锁是一种用于在分布式环境中控制对共享资源访问的机制，它可以保证在同一时刻只有一个客户端能够访问某些特定资源。
1. Redisson概述 1.1 Redisson的基本概念 Redisson是一个基于Redis的Java客户端，它不仅提供了对Redis的基础操作支持，还封装了许多高级功能，如分布式锁、分布式集合、分布式队列等。Redisson的设计目标是简化分布式系统的开发，提高开发效率和系统的可维护性。
1.2 Redisson的主要功能 分布式锁：支持可重入锁、公平锁、读写锁、红锁等多种分布式锁机制，保证分布式环境下的资源访问控制。比如：在电商系统中，防止超卖现象；在订单系统中，防止同一订单被多次处理。分布式集合：提供分布式Set、List、Map等集合类型，支持高并发环境下的数据操作。分布式队列：支持分布式阻塞队列、延迟队列等，适用于任务调度和消息传递场景。分布式对象：提供分布式AtomicLong、AtomicDouble、CountDownLatch、Semaphore等对象，简化分布式系统的开发。分布式服务：支持分布式执行器、分布式调度器等服务，增强分布式系统的功能。 1.3 Redisson的优点 Redisson是一个基于Redis的Java客户端，提供了许多高级特性和分布式数据结构。相比其他Redis客户端，Redisson的优势在于：
简洁易用：提供了丰富的API，简化了分布式编程的复杂性。高可用性：支持多种Redis部署模式，包括单节点、主从复制和集群模式。分布式对象：提供了分布式锁、分布式集合、分布式队列等高级数据结构，便于在分布式环境中使用。自动续期：Redisson的Watchdog机制可以自动续期分布式锁，避免锁超时问题。 2. 开发环境 JDK版本：JDK 17Spring Boot版本：Spring Boot 3.2.2Redis版本：5.0.14.1构建工具：Maven 3. Redisson的安装与配置 3.1 添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson&lt;/artifactId&gt; &lt;version&gt;3.24.3&lt;/version&gt; &lt;/dependency&gt; 3.2 配置Redisson 配置参考文档：2. Configuration · redisson/redisson Wiki (github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49864682aaf8d6addd2c2f2e28d43cad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0f8f5d3ee4fbd9478ff1fd812ae4264/" rel="bookmark">
			问题解决|endnote文献手工导入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景介绍 手工导入一篇文献是指手动编辑文献的相关信息Preference。为什么要手动这么麻烦？因为有的文献比较老只有纸质版本，有的文献信息不全，有的则是没有编码无法识别等等，需要手工录入；一般需要手工录入的情况比较少遇到；
一、Preference--&gt;New Reference（方法一） 手工导入两种基本方法，在菜单栏选Reference-New Reference ,快捷键Ctrl+N,如下图：
二、Preference--&gt;New Reference（方法二） 再一种方法就是在文献显示窗口右键选择，而此时所添加的文献也会归到显示的这个分组中，如下图：
三、将文献信息与PDF相关联 手工导入Preference信息后要与文献PDF关联起来，如下图
四、相关注意事项 注意，在编辑文献的Author时，一个作者占据一行，作者首字母大写，要按照国外作者姓名的表达方式，这关系到以后插入参考文献的格式是否正确；
例如李四的两种拼写方式（Li,Si)和(Si Li)在Word中插入参考文献后的表现形式是一样的。
五、参考引用 [1]Endnote：[5]文献手工导入-百度经验 (baidu.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/388d3688cdf587407170bc95c93536a7/" rel="bookmark">
			【Python】利用代理IP爬取当当网数据做数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在数字化浪潮的推动下，电商平台已经彻底改变了我们的购物方式。从简单的在线交易到复杂的用户交互，电商平台积累了海量的用户数据。这些数据，如同隐藏在深海中的宝藏，等待着被发掘和利用。通过分析用户的浏览、搜索、购买等行为，商家可以更准确地理解用户需求，提供个性化的推荐和服务。这不仅能够提升用户的购物体验，还能增加用户粘性和忠诚度。此外，电商平台数据分析在库存管理、价格策略制定、竞争分析、风险管理等方面也发挥着重要作用。它能够帮助商家优化库存，制定合理的定价策略，了解竞争对手的市场表现，以及及时发现并应对潜在的风险。
在本文中，我们将深入探讨如何构建出既高效的爬虫，为你的电商业务提供强大的支持。
亮数据数据获取工具https://www.bright.cn/proxy-types?utm_source=brand&amp;utm_campaign=brnd-mkt_cn_csdn_yingjie
利用代理IP爬取当当网
网站分析 本次爬取的目标是某知名购书平台，抓取内容是：标题、链接、价格、定价、图片链接。为了防止被识别为爬虫，首先我们先要获取登录用户的cookie。登录状态下按f12，选择网络，任选其中一个流量，在请求头中找到cookie并复制。
接下来，我们需要分析一下搜索请求的构建。可以看到我们搜索高等数学的时候，请求通过url构建。url中的key值代表搜索内容，act代表动作，page_index代表页码。
最后我们需要确定商品元素在页面中的结构。可以看到所有商品位于一个ul中，每个商品部对应一个li标签，都有对应的class标记。其中标题位于p标签的title属性，链接位于href标签，图片链接在下层的img标签中，价钱位于另一个p标签中。之后我们将用xpath定位这些标签。
获取代理 数据获取工具https://www.bright.cn/proxy-types?utm_source=brand&amp;utm_campaign=brnd-mkt_cn_csdn_yingjie
为了进一步隐藏爬虫身份，我们需要使用代理来隐藏真实的IP地址。这里我们选择亮数据作为代理服务商。选择代理服务商主要关注点在稳定性、ip区域多样性和价钱上。
亮数据的IP代理网络覆盖全球195个国家，拥有超过7200万个IP地址，确保用户可以进行任意城市定位，并且每日更新上百万IP，保证了数据采集的广泛性和实时性。公司提供的代理IP网络类型包括动态住宅、静态住宅、移动和机房，全方位满足用户的不同需求。在全球范围内，亮数据拥有超过2600个代理服务器，构建了一个高速稳定的智能交通网络，确保了99.99%的稳定运行时间，即使在网络高峰期间也能保持服务的稳定性。此外，亮数据所有服务都支持随时暂停，并且计费方式灵活多样。
首先我们需要注册并登录亮数据。之后来到用户控制面板，添加代理机房。
这里需要我们配置代理的名字和ip区域，其他选项保持默认。
之后需要将我们本机ip添加到白名单，并记录下来主机号、账户名和密码。
编写程序 首先我们要编写get_ip函数从亮数据服务器获取代理ip：先定义代理服务器的主机、用户名和密码。然后使用这些信息构建了一个代理URL。最后发送HTTP请求到http://lumtest.com/myip.json获取当前的代理IP地址。
def get_ip(): host = '' # 主机 user_name = '' # 用户名 password = '' # 密码 proxy_url = f'http://{user_name}:{password}@{host}' # 将上面三个参数拼接为专属代理IP获取网址 proxies = { 'http': proxy_url, 'https': proxy_url } url = "http://lumtest.com/myip.json" # 默认获取的接口（不用修改） response = requests.get(url, proxies=proxies, timeout=10).text # 发送请求获取IP # print('代理IP详情信息：',response) response_dict = eval(response) # 将字符串转为字典，方便我们提取代理IP ip = response_dict['ip'] # print('IP：',ip) return ip 之后需要我们定义get_html_str函数，来向电商网站发送搜索请求：先定义请求头，模拟浏览器访问，其中包含了一些cookie信息。调用get_ip函数获取代理IP，并设置到请求中。最后发送HTTP请求到指定的URL，并返回网页源码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/388d3688cdf587407170bc95c93536a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e75705d575a4eee1d6e239c021e48050/" rel="bookmark">
			基于springboot&#43;vue&#43;uniapp的语言课学习系统小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发语言：Java框架：springboot+uniappJDK版本：JDK1.8服务器：tomcat7数据库：mysql 5.7（一定要5.7版本）数据库工具：Navicat11开发软件：eclipse/myeclipse/ideaMaven包：Maven3.3.9 系统展示
用户信息管理
教师信息管理
课程信息管理
论坛信息管理
摘要
语言课学习系统使用Java语言进行编码，使用Mysql创建数据表保存本系统产生的数据。系统可以提供信息显示和相应服务，其管理语言课学习系统信息，查看语言课学习系统信息，管理语言课学习系统。
总之，语言课学习系统集中管理信息，有着保密性强，效率高，存储空间大，成本低等诸多优点。它可以降低信息管理成本，实现信息管理计算机化。
研究背景
互联网发展至今，无论是其理论还是技术都已经成熟，而且它广泛参与在社会中的方方面面。它让信息都可以通过网络传播，搭配信息管理工具可以很好地为人们提供服务。所以各行业，尤其是规模较大的企业和学校等都开始借助互联网和软件工具管理信息，传播信息，共享信息等等，以此可以增强自身实力，提高在同行业当中的竞争能力，并从各种激烈的竞争中获取发展的机会。针对高校教师成果信息管理混乱，出错率高，信息安全性差，劳动强度大，费时费力等问题，经过分析和考虑，在目前的情况下，可以引进一款语言课学习系统这样的现代化管理工具，这个工具就是解决上述问题的最好的解决方案。它不仅可以实时完成信息处理，还缩短高校教师成果信息管理流程，使其系统化和规范化。同时还可以减少工作量，节约高校教师成果信息管理需要的人力和资金。所以语言课学习系统是信息管理环节中不可缺少的工具，它对管理者来说非常重要。
关键技术
SpringBoot是一个全新开源的轻量级框架。基于Spring4.0设计，其不仅继承了Spring框架原来有的优秀特性，而且还通过简化配置文件来进一步简化了Spring应用的整个搭建以及开发过程。另外在原本的Spring中由于随着项目的扩大导入的jar包数量越来越大，随之出现了jar包版本之间的兼容性问题，而此时SpringBoot通过集成大量的框架使得依赖包的版本冲突，以及引用的不稳定性问题得到了很好的解决。
JS-SDK是对之前的 WeixinJSBrige 的一个包装，以及新能力的释放，并且由对内开放转为了对所有开发者开放，在很短的时间内获得了极大的关注。从数据监控来看，绝大部分在微信内传播的移动网页都使用到了相关的接口。
JS-SDK 解决了移动网页能力不足的问题，通过暴露微信的接口使得 微信小程序 开发者能够拥有更多的能力，然而在更多的能力之外，JS-SDK 的模式并没有解决使用移动网页遇到的体验不良的问题。用户在访问网页的时候，在浏览器开始显示之前都会有一个的白屏过程，在移动端，受限于设备性能和网络速度，白屏会更加明显。我们团队把很多技术精力放置在如何帮助平台上的微信小程序开发者解决这个问题。因此我们设计了一个 JS-SDK 的增强版本，其中有一个重要的功能，称之为“微信 微信小程序 资源离线存储”。
JAVA语言是目前软件市场上应用最广泛的语言开发程序。可以在多种平台上运用的，兼容性比较强，适应市面上大多数操作系统，不会出现乱码的现像，其扩展性和维护性都更好，具有分析问题和解决问题的能力，是面向过程的程序设计方便我们编写的代码更强壮。
Vue是一款流行的开源JavaScript框架，用于构建用户界面和单页面应用程序。Vue的核心库只关注视图层，易于上手并且可以与其他库或现有项目轻松整合。
MYSQL数据库运行速度快，安全性能也很高，而且对使用的平台没有任何的限制，所以被广泛应运到系统的开发中。MySQL是一个开源和多线程的关系管理数据库系统，MySQL是开放源代码的数据库，具有跨平台性。
B/S（浏览器/服务器）结构是目前主流的网络化的结构模式，它能够把系统核心功能集中在服务器上面，可以帮助系统开发人员简化操作，便于维护和使用。
系统分析
对系统的可行性分析以及对所有功能需求进行详细的分析，来查看该系统是否具有开发的可能。
系统设计
功能模块设计和数据库设计这两部分内容都有专门的表格和图片表示。
系统实现
用户信息管理页面，此页面提供给管理员的功能有：用户信息的查询管理，可以删除用户信息、修改用户信息、新增用户信息，还进行了对用户名称的模糊查询的条件。教师信息管理页面，此页面提供给管理员的功能有：查看已发布的教师信息数据，修改教师信息，教师信息作废，即可删除，还进行了对教师信息名称的模糊查询 教师信息信息的类型查询等等一些条件。课程信息管理页面，此页面提供给管理员的功能有：根据课程信息进行条件查询，还可以对课程信息进行新增、修改、查询操作等等。论坛信息管理页面，此页面提供给管理员的功能有：根据论坛信息进行新增、修改、查询操作等等。
系统测试
在系统编码完成之后，完成对本系统的测试工作，其主要的任务还是找出本系统可能出现的错误，而且是发现的错误越多越好，因为每发现一个程序错误，都需要进行文档记载，然后根据这些记载程序错误的文档，采取各种措施去解决这些程序问题，逐渐完善程序。所以，测试并不是去证明开发的系统是正确的，而是通过各种各样的方式去寻找系统中的缺陷，并针对性的完善系统。这样才能保证系统在实际运行中，可以保质保量的进行工作。
结论
采用Java+Mysql的方式设计制作的语言课学习系统，在功能上可以满足管理人员对于信息的管理需求；在界面的设计上，尽最大努力用自身的美工知识做到界面美观简洁。在操作方面上，让系统可以方便操作，同时对用户常见的误操作行为进行分析总结，并尽力在系统中避免同样的由于用户的误操作所带来的错误现象。
（可运行源码+sql文件+文档）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a83850d6820e3b27926618658b115d9b/" rel="bookmark">
			【AI大模型】跌倒监控与健康：技术实践及如何改变未来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. **背景与意义**2. **关键技术与方法**2.1 传感器数据融合2.2 深度学习模型2.3 行为模式识别2.4 预测与预防 3. **应用场景**3.1 老年人跌倒预警3.2 康复患者监测3.3 高风险职业防护 4. **实践案例**案例1：某老年社区的跌倒预警系统案例2：康复中心的患者监测系统 5. **未来展望**6. **技术架构与实现**6.1 数据采集层6.2 数据处理层6.3 模型训练与推理层6.4 预警与反馈层6.5 自适应学习与模型更新 7. **实际应用中的挑战与解决方案**7.1 数据隐私与安全7.2 模型的泛化能力7.3 能耗与计算资源 8. **未来发展方向**9. **具体实施方案与案例分析**案例1：老年人居家跌倒预警系统9.1 实施方案9.2 成效与优势 案例2：康复中心的患者跌倒预警系统9.3 实施方案9.4 成效与优势 10. **未来研究方向与挑战**10.1 多模态数据融合与分析10.2 个性化模型与自适应学习10.3 智能反馈与干预机制10.4 数据隐私与安全 11. **跨学科合作与生态系统构建**11.1 跨学科合作11.2 生态系统构建 12. **政策支持与伦理考虑**12.1 政策支持12.2 伦理考虑 13. **结语** 1. 背景与意义 据世界卫生组织数据显示，全球每年约有68余万人死于跌倒，是老年人因伤害就诊和死亡的首要原 因，可谓是“头号杀手”。而且随着年龄的增长，因跌倒发生致命伤害的风险也会增加，男性比女性的 风险更高！ 引用：华中科技大学同济医院公众号文章：不是癌症！老年人的“头号杀手”居然是“跌倒” 跌倒是老年人和某些高风险群体面临的重大健康问题，往往会导致严重的伤害，甚至死亡。随着人口老龄化，跌倒预警系统的需求日益增加。通过AI大模型在穿戴设备和健康监测系统中的深度融合，可以有效提升跌倒检测和预警的准确性和及时性，从而减少跌倒事件及其带来的不良后果。
2. 关键技术与方法 2.1 传感器数据融合 穿戴设备通常配备多种传感器，如加速度计、陀螺仪、心率传感器等。AI大模型可以整合这些传感器数据，以更全面地分析用户的运动状态和健康状况。
import numpy as np # 模拟传感器数据 acc_data = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a83850d6820e3b27926618658b115d9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/113c50bcc4992df99f13b5ef2f632d6f/" rel="bookmark">
			深入分析 Android BroadcastReceiver (四)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 深入分析 Android BroadcastReceiver (四)1. 广播接收器的深入优化与应用1.1 实时性要求高的应用1.1.1 示例：音乐播放器中处理耳机插拔事件1.1.2 动态注册接收器 1.2 处理耗时操作1.2.1 示例：使用 `IntentService` 处理耗时操作 1.3 安全性管理1.3.1 示例：声明权限 1.4 应用内广播优化1.4.1 示例：聊天应用中消息通知 2. 项目中的最佳实践3. 总结 深入分析 Android BroadcastReceiver (四) 1. 广播接收器的深入优化与应用 在实际项目中，如何优化广播接收器的使用是一个重要的问题，尤其是在复杂的应用中。下面将进一步探讨如何在不同场景下优化广播接收器，以及在实际应用中如何最佳实践这些策略。
1.1 实时性要求高的应用 对于实时性要求高的应用，如音乐播放器、导航应用等，需要保证广播消息的及时处理，避免延迟或丢失。
1.1.1 示例：音乐播放器中处理耳机插拔事件 在 AndroidManifest.xml 中声明接收器：
&lt;receiver android:name=".HeadphoneReceiver"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.HEADSET_PLUG" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 接收器实现：
public class HeadphoneReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { if (intent.hasExtra("state")) { if (intent.getIntExtra("state", 0) == 0) { // 耳机拔出，暂停播放 MusicPlayerService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/113c50bcc4992df99f13b5ef2f632d6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79c1e122386bfdd71e4f6c98b5d5895b/" rel="bookmark">
			Handling `nil` Values in `NSDictionary` in Objective-C
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Handling nil Values in NSDictionary in Objective-C When working with Objective-C, particularly when dealing with data returned from a server, it’s crucial (至关重要的) to handle nil values appropriately (适当地) to prevent unexpected crashes. Here, we explore (美 [ɪkˈsplɔːr]，探索，探讨) two common ways to insert values into a NSMutableDictionary and how they behave when the value is nil.
Scenario (美 [səˈnærioʊ]，情景) Consider the following code:
NSString *value = model.value; // Data returned from the server NSMutableDictionary *dic = @{}.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79c1e122386bfdd71e4f6c98b5d5895b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/379688c5d515f3fda1c295f1a9bb50ff/" rel="bookmark">
			【初阶数据结构】深入解析队列:探索底层逻辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥引言
本篇将深入解析队列:探索底层逻辑，理解底层是如何实现并了解该接口实现的优缺点，以便于我们在编写程序灵活地使用该数据结构。
🌈个人主页：是店小二呀
🌈C语言笔记专栏：C语言笔记
🌈C++笔记专栏： C++笔记
🌈初阶数据结构笔记专栏： 初阶数据结构笔记
🌈喜欢的诗句:无人扶我青云志 我自踏雪至山巅
文章目录 一、队列的概念及结构二、实现队列的相关接口(Stack.h)2.1 队列初始化2.2 队尾入队列2.3 队头出队列2.4 获得队列头部元素2.5 获得队列尾部元素2.6 获取队列中有效元素个数2.7 检测队列是否为空2.8 打印队列数据2.9 队列的销毁 三、循环队列 一、队列的概念及结构 队列是指只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表。队列具有先进先出 FIFO(First In First Out) 这一点跟栈的先进后出是相反的
入队列:进行插入操作的一端并且称为队尾
出队列：进行删除操作的一端并且称为队头
队列可用通过数组或链表结构实现，一般推荐使用链表实现更优一点。如果使用数组实现在出队列时，需要挪移大量数据，效率较低
这里采用链表结构实现队列
![外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传](https://img-home.csdnimg.cn/images/
在设计队列结构中，需要设计两个指针去控制队列各节点的情况。head(队头指针)指向实际对头元素，taill(队尾指针)，指向实际队尾元素，增加一个变量size用于统计元素个数，由于存在多种信息，可以使用结构体统一管理
二、实现队列的相关接口(Stack.h) 2.1 队列初始化 void QueueInit(Queue *pq)//所以导致了需要初始化 { assert(pq); pq-&gt;phead = NULL; pq-&gt;ptail = NULL; pq-&gt;size = 0; } 这里需要注意的是:这里不需要对于节点进行初始化，在创建节点时会完成对应的初始化工作。
2.2 队尾入队列 void QueuePush(Queue* pq, QDataType x) { assert(pq); Qnode* newnode = (Qnode*)malloc(sizeof(Qnode)); if (newnode == NULL) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/379688c5d515f3fda1c295f1a9bb50ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1ac76fc6d36030e54d339fb499b0a6e/" rel="bookmark">
			SpringMVC基础详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、SpringMVC简介1、什么是MVC2、MVC架构模式与三层模型的区别3、什么是SpringMVC 二、HelloWorld程序1、pom文件2、springmvc.xml3、配置web.xml文件4、html文件5、执行Controller 三、RequestMapping注解1、value属性1.1、基础使用1.2、Ant风格（模糊匹配路径）1.3、路径占位符（@PathVariable） 2、method属性2.1、基础使用2.2、衍生xxxMapping注解2.3、web的请求方式 3、params属性4、headers属性 四、获取请求参数1、原生Servlet API2、RequestParam注解2.1、value属性2.2、required属性2.2、defaultValue属性 3、根据形参名获取4、根据实体类接收5、RequestHeader注解6、CookieValue注解7、请求的中文乱码问题7.1、get请求乱码7.2、post请求乱码 五、Servlet的三个域对象1、request域对象2、session域对象3、application域对象 六、HttpMessageConverter消息转换器1、Form表单转换器和默认转换器2、@ResponseBody2.1、Servlet原生API方式2.2、@ResponseBody注解方式2.3、MappingJackson2HttpMessageConverter(JSON转换器) 3、@RestController4、@RequestBody4.1、&amp;拼接参数4.2、JSON格式参数 5、RequestEntity6、ResponseEntity 七、异常处理器1、默认异常处理器2、自定义异常处理器2.1、跳转错误页面2.2、返回错误响应对象 八、拦截器1、拦截器概述2、拦截器和过滤器的区别3、拦截器的创建与基本配置4、多个拦截器执行顺序 一、SpringMVC简介 1、什么是MVC MVC是一种软件架构模式（是一种软件架构设计思想，不止Java开发中用到，其它语言也需要用到），它将应用分为三块： M：Model（模型），负责业务处理及数据的收集V：View（视图），负责数据的展示C：Controller（控制器），负责调度。它是一个调度中心，它来决定什么时候调用Model来处理业务，什么时候调用View视图来展示数据 MVC架构模式的描述：前端浏览器发送请求给web服务器，web服务器中的Controller接收到用户的请求，Controller负责将前端提交的数据进行封装，然后Controller调用Model来处理业务，当Model处理完业务后会返回处理之后的数据给Controller，Controller再调用View来完成数据的展示，最终将结果响应给浏览器，浏览器进行渲染展示页面。
2、MVC架构模式与三层模型的区别 什么是三层模型
三层模型就是由Controller控制器和View视图组成的表现层，将Model数据模型拆封为业务层和与数据库交互的持久层 MVC架构模式与三层模型的区别？
MVC和三层模型都采用了分层结构来设计应用程序，都是降低耦合度，提高扩展力，提高组件复用性区别在于他们的关注点不同 三层模型更加关注业务逻辑组件的划分MVC架构模式关注的是整个应用程序的层次关系和分离思想 现代的开发方式大部分都是MVC架构模式结合三层模型一起用 3、什么是SpringMVC SpringMVC是一个实现了MVC架构模式的Web框架，底层基于Servlet实现SpringMVC已经将MVC架构模式实现了，因此只要我们是基于SpringMVC框架写代码Spring框架中有一个子项目叫做Spring Web，Spring Web子项目当中包含很多模块 Spring MVCSpring WebFluxSpring Web ServicesSpring Web FlowSpring WebSocketSpring Web Services Client Spring架构图如下，其中Web中的servlet指的就是Spring MVC 二、HelloWorld程序 1、pom文件 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.xc&lt;/groupId&gt; &lt;artifactId&gt;springmvc-xml&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;dependencies&gt; &lt;!--springmvc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--servletAPI--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1ac76fc6d36030e54d339fb499b0a6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64edc3041cc05d86d553e8baf6e008e0/" rel="bookmark">
			Linux 安装 Redis 教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优质博文：IT-BLOG-CN
一、准备工作 配置gcc：安装Redis前需要配置gcc：
yum install gcc 如果配置gcc出现依赖包问题，在安装时提示需要的依赖包版本和本地版本不一致，本地版本过高，出现如下问题：
[root@localhost ~] yum install gcc Loaded plugins: fastestmirror Loading mirror speeds from cached hostfile * base: mirrors.aliyun.com * epel: mirrors.bfsu.edu.cn * extras: mirros.aliyun.com * updates: mirros.aliyun.com No package gcc available. Error: Nothing to do 使用--skip--broken命令尝试绕过依赖包时，直接把gcc安装包也绕过了
卸载依赖包重装版本的方法过于繁琐，可能扯出来一堆版本问题。这种问题原因是之前配置yum源时配置的阿里源所以下载的大多数依赖包版本都比较高，在安装很多较低版本软件时都会遇到这个问题。
所以，如果是因为配置yum源问题，这里建议直接将yum源更换为Centos官方源。这里我的Centos版本是7.9 到官方找了镜像地址为：http://mirror.centos.org/centos-7/7.9.2009/os/x86_64/Packages/centos-release-7-9.2009.0.el7.centos.x86_64.rpm
操作步骤：
1、进入repo目录
cd /etc/yum.repos.d/ 2、备份系统原来的repo文件
mv CentOS-Base.repo CentOS-Base.repo.backup 3、用wget下载repo文件
wget http://mirrors.163.com/.help/CentOS6-Base-163.repo 4、替换系统原理的repo文件
mv CentOS6-Base-163.repo CentOS-Base.repo 5、清理缓存
yum clean all 6、缓存文件
yum makecache 7、重新更新yum源
yum update -y 二、Redis 安装包 Redis官网链接
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64edc3041cc05d86d553e8baf6e008e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3de88bf55345010f7bf16b5f60c91db/" rel="bookmark">
			1. Python语言介绍——《跟老吕学Python》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Python语言介绍——《跟老吕学Python》 Python介绍一、Python简介二、Python的发展简史1. 创造Python的理由是什么？2. Python的起源3. PSF4. Python版本发展史 三、Python的特点四、Python的知名应用案例五、Python的价值1. Python的广泛应用领域2. Python可以从事的职业3. Python职业的薪酬 六、使用Python是否存在版权限制？七、Python的社区和支持八、Python与其他语言的比较九、Python的未来展望十、Python官方和学习资源 Python介绍 一、Python简介 Pytho​n是一种开源1、跨平台2、解释型3、编译性3、交互式4、支持多种编程范式5，包括过程式5、面向对象6和函数式5，拥有动态数据类型7和垃圾回收机制8的高级9脚本语言10编程语言。
上文描述是对Python编程语言特性的全面总结，也就是python基础知识点总结，涉及到的专业术语还是挺多的，可能对刚学习 python入门教程 的朋友们来说是比较复杂且无法理解的，下面我将逐一简单解释这些特性，希望能让 零基础入门学习python 的朋友们能快速理解（如需详解请点击术语旁边的数字查看注脚的连接解释该术语的意义）：
开源（Open Source）：
Python是一种开源的编程语言，这意味着它的源代码是公开的，任何人都可以查看、修改和使用它。同时，这也促进了Python社区的发展，因为开发者可以共同贡献代码、修复错误和添加新功能。 跨平台（Cross-Platform）：
Python可以在多种操作系统上运行，包括Windows、Linux、macOS等。这是因为Python被设计为与底层平台无关，只需安装相应平台的Python解释器即可。 解释型（Interpreted）：
Python是一种解释型语言，这意味着Python代码在运行时由解释器逐行解释并执行，而不是像编译型语言那样先编译成机器代码再执行。这种特性使得Python的开发过程更为灵活和快速。 编译性（Compiled）：
严格来说，Python是解释型语言，但也有一些工具（如PyInstaller、Cython等）可以将Python代码编译成二进制文件或C代码，以提高执行效率。但这种编译与传统意义上的编译型语言有所不同。 交互式（Interactive）：
Python支持交互式编程，这意味着你可以在Python解释器中直接输入代码并立即看到结果。这对于学习和调试代码非常有用。 支持多种编程范式（Multiple Programming Paradigms）：
Python支持多种编程范式，包括过程式（Procedural）、面向对象（Object-Oriented）和函数式（Functional）。这使得Python在开发各种类型的应用程序时都非常灵活。 过程式编程：按照一系列步骤或过程来解决问题。面向对象编程：将数据和对数据的操作封装在对象中，通过对象之间的交互来解决问题。函数式编程：将计算视为数学函数的评估，避免改变状态和可变数据。 动态数据类型（Dynamic Data Typing）：
在Python中，你不需要在声明变量时指定其数据类型。Python解释器会在运行时自动确定变量的类型，并根据需要进行转换。这种动态类型系统使得Python代码更加简洁和灵活。 垃圾回收机制（Garbage Collection）：
Python具有自动垃圾回收机制，可以自动管理内存并释放不再使用的对象。这减少了内存泄漏的风险，并使得开发者可以更加专注于编写代码而不是管理内存。 高级（High-Level）：
Python是一种高级编程语言，它提供了丰富的抽象和简化机制，使得开发者可以使用更少的代码完成更多的工作。同时，Python也提供了许多内置的函数和库来支持各种常见的编程任务。 脚本语言（Scripting Language）：
Python也被广泛用作脚本语言，用于自动化任务、编写小型程序或作为大型应用程序的粘合剂。Python的简洁性和易用性使得它成为脚本编程的理想选择。 Python的这些特性使得它成为一种强大而灵活的编程语言，广泛应用于Web开发、数据分析、人工智能等领域。
二、Python的发展简史 1. 创造Python的理由是什么？ Python的创始人，被大家亲切地称为“龟叔”的Guido van Rossum，在当年是这样表示的：
“
我在 CWI 的 ABC 部门时在实现解释型语言方面积累了丰富经验，通过与这个部门成员的协同工作，我学到了大量有关语言设计的知识。 这是许多 Python 特性的最初来源，包括使用缩进来组织语句以及包含非常高层级的数据结构（虽然在 Python 中具体的实现细节完全不同）。
我对 ABC 语言有过许多抱怨，但同时也很喜欢它的许多特性。 没有可能通过扩展 ABC 语言（或它的实现）来弥补我的不满 —— 实际上缺乏可扩展性就是它最大的问题之一。 我也有一些使用 Modula-2+ 的经验，并曾与 Modula-3 的设计者进行交流，还阅读了 Modula-3 的报告。 Modula-3 是 Python 中异常机制所用语法和语义，以及其他一些语言特性的最初来源。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3de88bf55345010f7bf16b5f60c91db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06e9bc03e6d8d2203dd1727f36153920/" rel="bookmark">
			【前端】从零开始学习编写HTML
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、什么是前端
二、什么是HTML
三、HTML文件的基本结构
四、HTML常见标签
4.1 注释标签
4.2 标题标签
4.3 段落标签
4.4 换行标签
4.5 格式化标签
4.6 图片标签
4.7 超链接标签
4.8 表格标签
4.9 列表标签
4.10 表单标签
（1）form标签
（2）input标签
（3）label标签
（4）select标签
（5）textarea标签
4.11 无语义标签
五、实现简单的简历展示网页
六、实现简单的简历填写页面
一、什么是前端 前端开发是创建Web页面或APP等前端界面呈现给用户的过程，负责把界面更好的呈现给用户
相对于后端主要负责用户看不见的数据处理，前端是指用户可以看到和操作的部分，例如网页页面，PC端程序页面或移动端APP页面。
二、什么是HTML HTML（HyperText Markup Language）是超文本标记语言的简称，是一种用于创建网页的标准标记语言。
超文本：一种文本类型，允许通过链接（通常称为超链接）从一个文档跳转到另一个文档或文档中的特定部分 三、HTML文档的基本结构 &lt;html&gt; &lt;head&gt; &lt;title&gt;页面标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 页面内容 &lt;/body&gt; &lt;/html&gt; 如上：
html标签是整个HTML文档的根标签，用来标记HTML文档的开始和结束head标签用于标记HTML文档头部的开始和结束，其中填写页面的属性，例如head的子标签titie代表页面的标题body标签用于标记HTML文档主体的开始和结束，其中填写页面当中显示的内容 其中被尖括号包括的就是HTML标签，不同标签之间分为父子关系和兄弟关系
我们可以通过上面不同标签的缩进程度来观察它们的关系，例如head和body是html的子标签，title是head的子标签，head和body之间是兄弟关系
不同标签之间的结构关系就构成了一棵DOM树
四、HTML常见标签 HTML标签又分为单标签和双标签
单标签只会单独出现，用法：&lt;标签名/&gt;
双标签成对出现，用法：&lt;标签名&gt;&lt;/标签名&gt;
4.1 注释标签 &lt;!-- 我是注释 --&gt; 像这样，用尖括号、感叹号和横杠组成注释标签，其中填写自己需要的注释
注释不会显示在网页界面上，主要用于提高代码的可读性
4.2 标题标签 就像CSDN的富文本编辑器中提供了六级标题，HTML的标题标签也有六个，从h1到h6逐级变小
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06e9bc03e6d8d2203dd1727f36153920/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bea2accb703b48d375f9061a170834d2/" rel="bookmark">
			20240701 每日AI必读资讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🏫AI真·炼丹：整整14天，无需人类参与
- 英矽智能推出全球首个AI参与决策的生物学实验室，实现了14天内完成靶点发现和验证的全自动化闭环实验。 - 该实验室由PandaOmics平台驱动，集成多种预测模型和海量数据，支持专业的生物学研究。
- 还开发了端到端的药物发现平台Pharma.AI，大幅提高了新药研发效率。
- 为解决巨大的计算需求，AI制药企业普遍选择英特尔至强可扩展处理器作为主要算力平台。
- 英特尔针对AlphaFold2等AI模型进行了一系列硬件和软件优化，显著提升了性能和效率。
- AI和高性能CPU的结合正在重塑制药行业的创新模式，加速新药研发进程。
🔗 AI真·炼丹：整整14天，无需人类参与-CSDN博客
📚OmniParse ：一个开源的数据清理和整理的自动化工具
- 能够将各种非结构化数据（如文档、图片、视频等）转换为结构化数据的平台，便于 AI 应用程序使用。
- 支持20多种文件类型。
- 所有的数据处理都在本地完成，不需要通过外部API，从而确保用户的数据隐私和安全。
- 数据解析与优化：
-将文档、图像、音频、视频和网页内容转换为高质量的结构化Markdown格式。
- 文档解析：将文本内容提取并转换为结构化格式。
- 图像处理：图像提取和字幕生成。
- 音视频转录：将音频和视频内容转录为文本。
- 网页爬取：自动爬取网页内容并进行解析。
🛠️全球首款集成GPT-4o 的智能眼镜发布！
- 支持视觉能力和语音提示
- 可以根据用户所看到的内容和识别到的人或物体提供实时回答。
- 支持超过10种语言的实时翻译，轻松打破语言障碍。
- 同步运动计划和锻炼到应用程序，帮助实现健身目标。
- 支持文本转语音，消息朗读等多种功能。
- 该眼镜采用模块化设计，可更换不同样式的传统框架。
- 此外，它还具备 LED 通知灯，并将整合 Google Gemini 和 Anthropic 的 Claude AI 模型。
- Solos AirGo 3 音频眼镜不含相机，售价为 249 美元。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bea2accb703b48d375f9061a170834d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe3e29b1ae41e54ce821741e7da3d202/" rel="bookmark">
			重建controlfile后发现后datafile 漏了 rman catalog recovery area
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SYMPTOMS ORA-01110: data file 10: '/refresh/home/app/19.3.0.0/oracle/product/19.3.0.0/dbhome_6/dbs/MISSING00010'
ORA-01565: error in identifying file '/refresh/home/app/19.3.0.0/oracle/product/19.3.0.0/dbhome_6/dbs/MISSING00010'
ORA-27037: unable to obtain file status
SYS AS SYSDBA&gt;select name from v$datafile;
NAME
--------------------------------------------------------------------------------
/refresh/home/app/19.3.0.0/oracle/oradata/ORCL19300/system01.dbf
/refresh/home/app/19.3.0.0/oracle/oradata/ORCL19300/test01.dbf
/refresh/home/app/19.3.0.0/oracle/oradata/ORCL19300/sysaux01.dbf
/refresh/home/app/19.3.0.0/oracle/oradata/ORCL19300/undotbs01.dbf
/refresh/home/app/19.3.0.0/oracle/oradata/ORCL19300/rman01.dbf
/refresh/home/app/19.3.0.0/oracle/oradata/ORCL19300/users01.dbf
/refresh/home/app/19.3.0.0/oracle/oradata/ORCL19300/test02_01.dbf
/refresh/home/app/19.3.0.0/oracle/oradata/ORCL19300/test02_02.dbf
/refresh/home/app/19.3.0.0/oracle/product/19.3.0.0/dbhome_6/dbs/MISSING00010
CHANGES Customer recreated the controlfile
CAUSE Customer recreated the controlfile, and one of the datafile missed in create controlfile statment.
SOLUTION If the datafile exists on the filesystem, and DB was opened with resetlogs, after recreating the controlfile,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe3e29b1ae41e54ce821741e7da3d202/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64c609302c5efbd62e1b5e7f7dab3cb6/" rel="bookmark">
			[C&#43;&#43;][设计模式][备忘录模式]详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.动机2.模式定义3.要点总结4.代码感受 1.动机 在软件构建过程中，某些对象的状态转换过程中，可能由于某中需要，要求程序能够回溯到对象之前处于某个点的状态。 如果使用一些公开接口来让其他对象得到对象的状态，便会暴露对象的细节实现如何实现对象状态的良好保存与恢复？但同时又不会因此而破坏对象本身的封装性 2.模式定义 定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态 这样以后就可以将该对象恢复到原先保存的状态 结构
3.要点总结 备忘录(Memento)存储原发器(Originator)对象的内部状态，在需要时恢复原发器状态Memento模式的核心是信息隐藏，即Originator需要向外接隐藏信息，保持其封装性。但同时又需要将状态保持到外界Menmeto模式有些过时 4.代码感受 class Memento { string state; //.. public: Memento(const string&amp; s) : state(s) {} string getState() const { return state; } void setState(const string&amp; s) { state = s; } }; class Originator { string state; //.... public: Originator() {} Memento createMomento() { Memento m(state); return m; } void setMomento(const Memento &amp; m) { state = m.getState(); } }; int main() { Originator orginator; // 捕获对象状态，存储到备忘录 Memento mem = orginator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64c609302c5efbd62e1b5e7f7dab3cb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f76cf1d5164bda37fd23e3cd228be5d2/" rel="bookmark">
			BFS：Floodfill算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Floodfill，翻译为洪水灌溉，而floodfill算法本质上是为了解决在矩阵中性质相同的联通块问题。
一、图像渲染 . - 力扣（LeetCode）
与dfs一样，从指定的起点开始向四个方向扩展，区别就是用之前通过参数将下标关系传递给dfs，而现在是将下标关系的键值对传给queue。
class Solution { public: //定义4个方向 int dx[4]={0,0,1,-1}; int dy[4]={1,-1,0,0}; typedef pair&lt;int,int&gt; PII; vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int color) { //采用BFS算法解决floodfill算法， 解决相同性质的矩阵联通块问题 int prev=image[sr][sc]; if(prev==color) return image; int m=image.size(),n=image[0].size(); queue&lt;PII&gt; q;//队列 q.emplace(sr,sc); while(!q.empty()) { //先修改当前位置 auto [a,b]=q.front();//c++14的玩法 q.pop(); image[a][b]=color;//修改成color for(int k=0;k&lt;4;++k) { int x=dx[k]+a,y=dy[k]+b; if(x&gt;=0&amp;&amp;x&lt;m&amp;&amp;y&gt;=0&amp;&amp;y&lt;n&amp;&amp; image[x][y]==prev) q.emplace(x,y); } } return image; } }; 二、岛屿数量 . - 力扣（LeetCode）
1. 因为要计算岛屿的数量，所以我们每进行一次bfs就要统计一下该岛屿，因为我们可以将bfs单独封装成一个函数。
2.在扩展的时候，我们需要标记我们扩展过的网格，这里有两种方案：
（1）修改值，但是修改值会改变原数据，必须要想办法修改回来。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f76cf1d5164bda37fd23e3cd228be5d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7c225faf13691767ebe91f3edcd74e9/" rel="bookmark">
			前端工程化09-webpack静态的模块化打包工具(未完结)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		9.1、开发模式的进化历史 webpacks是一个非常非常的强大的一个工具，相应的这个东西的学习也是有一定的难度的，里边的东西非常的多，里面涉及到的
概念的话也是非常非常的多的。
这个东西既然非常重要，那么在我们前端到底处于怎样的一个地位呢？
有些人学习到这个阶段已经分不清楚了，到底什么是node,什么是npm/什么是webpack,所以我们有必要了解下前端开发的架构图
目前我们前端比较流行的三大框架，Vue/React/Angular/,国内用Angular的非常少，如果公司需要你会，那么可以研究下，如果不
是就没有必要把太多的精力放到、Angular上，本身这个东西的需求比较少，岗位也比较少，那么这个时候你花费更多时间学习
Angular是没有什么太大的回报的，但是不可否认Angular是一个非常优秀的框架，他里边的架构设计也是非常优秀的~后续聊，目
前我们国内用的最多的还是Vue和React
我们目前的开发模式已经不是以前的那种模式，我先创建一个index.html，然后写标签写内容，下几个js文件，引入到项目里，在
写对应的js,写css什么的
现在的模式，假如你现在要开发一个旅游项目，先考虑用什么包管理工具，用npm还是用yarn,之后在确定给你的项目用到的打包
工具webpack,然后在当前的架构下边确定用什么前端框架开发，比如Vue,React,Angular,在写具体的代码，有人说了，那我不会
搭建这个架构怎么办，这个不需要担心，因为现在，你不管去开发Vue项目还是开发React这个项目，他们都有对应的脚手架来帮
助你进行快速开发，所谓的脚手架，不管是Vue的还是React的他们呢都是基于Webpack的。
9.2、Webpack使用Node内置的Path模块 path模块是node的内置模块，通常用于对路径和文件进行处理，提供了很多好用的方法
我们知道在Mac OS、Linux和window上的路径时不一样的
window上会使用 \或者 \ 来作为文件路径的分隔符，当然目前也支持 /；在Mac OS、Linux的Unix操作系统上使用 / 来作为文件路径的分隔符； 那么如果我们在window上使用 \ 来作为分隔符开发了一个应用程序，要部署到Linux上面应该怎么办呢？
显示路径会出现一些问题；所以为了屏蔽他们之间的差异，在开发中对于路径的操作我们可以使用 path 模块； 可移植操作系统接口（英语：Portable Operating System Interface，缩写为POSIX）
Linux和Mac OS都实现了POSIX接口；Window部分电脑实现了POSIX接口； 9.3、path模块常见的API 从路径中获取信息
dirname：获取文件的父文件夹；basename：获取文件名；extname：获取文件扩展名； 路径的拼接：path.join
如果我们希望将多个路径进行拼接，但是不同的操作系统可能使用的是不同的分隔符；这个时候我们可以使用path.join函数； 拼接绝对路径：path.resolve
path.resolve() 方法会把一个路径或路径片段的序列解析为一个绝对路径；给定的路径的序列是从右往左被处理的，后面每个 path 被依次解析，直到构造完成一个绝对路径；如果在处理完所有给定path的段之后，还没有生成绝对路径，则使用当前工作目录；生成的路径被规范化并删除尾部斜杠，零长度path段被忽略；如果没有path传递段，path.resolve()将返回当前工作目录的绝对路径； 9.4、path模块在webpack中的使用 9.5、正确认识webpack 事实上随着前端的快速发展，目前前端的开发已经变的越来越复杂了：
比如开发过程中我们需要通过模块化的方式来开发；比如也会使用一些高级的特性来加快我们的开发效率或者安全性，比如通过ES6+、TypeScript开发脚本逻辑，通过sass、less等方式来编写css样式代码；比如开发过程中，我们还希望实时的监听文件的变化来并且反映到浏览器上，提高开发的效率；比如开发完成后我们还需要将代码进行压缩、合并以及其他相关的优化；等等 但是对于很多的前端开发者来说，并不需要思考这些问题，日常的开发中根本就没有面临这些问题：
这是因为目前前端开发我们通常都会直接使用三大框架来开发：Vue、React、Angular；但是事实上，这三大框架的创建过程我们都是==借助于脚手架（CLI）==的；事实上Vue-CLI、create-react-app、Angular-CLI都是基于webpack来帮助我们支持模块化、less、TypeScript、打包优化等的； 工程化章节会去学习一些webpack的高级特性
9.6、脚手架依赖于webpack 9.7、Webpack到底是什么呢？ 我们先来看一下官方的解释：
webpack is a static module bundler for modern JavaScript applications. webpack是一个静态的模块化打包工具，为现代的JavaScript应用程序；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7c225faf13691767ebe91f3edcd74e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96ddb0e03582810ce2d3854127eef412/" rel="bookmark">
			大数据开发中如何计算用户留存及SQL示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在大数据开发领域，用户留存是一个关键指标，它反映了产品吸引并保留用户的能力。
留存率的计算不仅有助于评估产品的健康状况，还能为产品优化和市场策略提供重要依据。
本文将详细介绍如何在大数据开发中计算用户留存，并附带具体的SQL示例。
目录 留存的定义与意义留存率的计算公式SQL示例：计算次日留存率第一步：数据预处理第二步：计算次日留存用户第三步：计算留存率 完成SQL其他留存率计算方法总结 留存的定义与意义 留存是指用户在某一时间点（如注册日、首次使用日）后，在后续特定时间段内继续使用该产品的行为。留存率则是这些留存用户占初始用户的比例。留存率越高，说明产品越能吸引并保持用户的兴趣。
留存的意义在于：
评估产品吸引力：留存率高的产品通常意味着用户对产品有较高的满意度和忠诚度。指导产品优化：通过分析不同时间段的留存率，可以识别产品改进的方向，如用户体验、功能设计等。制定市场策略：根据留存数据，可以制定更有针对性的营销策略，提高用户粘性和活跃度。 留存率的计算公式 留存率的计算公式通常为：
留存率 = 基准日后第n天活跃用户数 基准日用户数 × 100 % \text{留存率} = \frac{\text{基准日后第n天活跃用户数}}{\text{基准日用户数}} \times 100\% 留存率=基准日用户数基准日后第n天活跃用户数​×100%
其中，基准日可以是用户注册日、首次使用日等，n可以是1天、7天、30天等，具体取决于分析需求。
SQL示例：计算次日留存率 以下是一个使用SQL计算次日留存率的示例。假设我们有一个用户行为日志表user_log，包含字段user_id（用户ID）、login_time（登录时间）等。
第一步：数据预处理 首先，我们需要从用户行为日志表中提取出每个用户的首次登录时间和后续登录时间。这里我们使用窗口函数来找出每个用户的首次登录时间。
WITH first_login AS ( SELECT user_id, MIN(login_time) AS first_login_time FROM user_log GROUP BY user_id ) 第二步：计算次日留存用户 接下来，我们将用户行为日志表与首次登录时间表进行连接，并筛选出次日登录的用户。
, retention_users AS ( SELECT a.user_id, a.login_time, DATE_ADD(b.first_login_time, INTERVAL 1 DAY) AS expected_next_day FROM user_log a JOIN first_login b ON a.user_id = b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96ddb0e03582810ce2d3854127eef412/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebdaec526fe486f29ed1c63e5a5af2a2/" rel="bookmark">
			C#进阶-ASP.NET WebForms调用ASMX的WebService接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ASMX 文件在 ASP.NET WebForms 中提供了创建 Web 服务的便捷方式，通过公开 Web 方法，允许远程客户端调用这些方法并获取数据。本文介绍了 ASMX 文件的基本功能、如何定义 WebService 接口、通过 HTTP 和 SOAP 请求调用 WebService 接口，以及使用 Postman 进行测试的方法。掌握这些知识，可以帮助你在 ASP.NET WebForms 项目中更好地使用 ASMX 文件创建和调用 Web 服务。
一、名词简介 1、ASMX文件 ASMX 文件是 ASP.NET 中用于创建 Web 服务的文件。Web 服务是用于跨网络传输数据和服务的标准方法，使不同平台和编程语言的系统可以互相通信。通过 ASMX 文件，开发者可以创建基于 SOAP 协议 / HTTP 协议 的 Web 服务，这些服务可以被各种客户端（如浏览器、移动应用程序、其他服务器应用程序）调用。
ASMX 文件主要功能包括：
提供跨平台、跨语言的服务接口。支持标准的 SOAP 协议进行数据交换。能够通过 HTTP/HTTPS 协议传输数据。允许公开 Web 方法，这些方法可以被远程客户端调用。 简答来说，就是 ASP.NET 提供的 Web 接口文件。
2、WebService接口 我们可以 在ASMX 文件中创建 WebService 接口， 定义 Web 服务提供的具体功能。每个接口由一组公开的方法（即 Web 方法）组成，这些方法可以通过 HTTP 请求被调用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebdaec526fe486f29ed1c63e5a5af2a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed9fa2069802d229916c46778a93908d/" rel="bookmark">
			Vue前端面试题---写过自定义指令吗？原理是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		是的，我熟悉 Vue.js 中的自定义指令，这是 Vue 提供的一种强大的机制，允许你注册一些自定义的 DOM 行为。自定义指令可以让你对 DOM 进行底层操作，或者扩展 Vue 的模板语法。
自定义指令的原理 在 Vue 中，自定义指令是通过 Vue.directive() 方法进行全局注册，或者在组件的 directives 选项中进行局部注册的。一个自定义指令包含几个可选的钩子函数（hook functions），这些函数会在特定的时机被 Vue 调用。
bind：只调用一次，指令第一次绑定到元素时调用。在这个钩子函数中，你可以进行一些初始化的设置。inserted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新。componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。unbind：只调用一次，指令与元素解绑时调用。 示例 下面是一个简单的自定义指令示例，该指令用于将元素设置为只读（即无法编辑）：
Vue.directive('readonly', { // 当被绑定的元素挂载到 DOM 中时…… inserted: function (el) { el.setAttribute('readonly', 'readonly'); }, // 当组件更新时…… update: function (el, binding) { // 根据 binding.value 的值来动态设置 readonly 属性 if (binding.value) { el.setAttribute('readonly', 'readonly'); } else { el.removeAttribute('readonly'); } } }); 然后你可以在模板中这样使用它：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed9fa2069802d229916c46778a93908d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/208/">«</a>
	<span class="pagination__item pagination__item--current">209/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/210/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>