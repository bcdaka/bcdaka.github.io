<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b73156304f27866bfdb7b7214901215a/" rel="bookmark">
			[知识技巧] iPhone 15 卡在恢复模式修复方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果您发现您的iPhone 15 卡在恢复模式下，这可能是一次相当紧张的经历，尤其是当它阻止您使用手机时。请放心，这是许多 iPhone 用户面临的共同挑战。幸运的是，有一些行之有效的方法可以解决此问题并将您的 iPhone 恢复到正常功能。
最近，iPhone 用户中出现了关于特定并发症的嗡嗡声：他们的 iPhone 卡在恢复屏幕上，尤其是在尝试更新到最新的 iOS 17 之后。
无论情况如何，本文都旨在为您提供四种有效的策略，以了解如何让 iPhone 退出恢复模式。我们将介绍一个可以帮助解决问题的补充工具。继续阅读解决方案！
为什么我的 iPhone 15 卡在恢复模式并且无法恢复？ 有几种情况可能会导致您的 iPhone 15 意外进入恢复模式。如果您发现自己处于任何这些情况，以下信息将帮助您解决 iPhone 卡在恢复模式的问题：
1. iOS 或其他版本更新：iPhone 在更新后卡在恢复模式的情况并不少见，特别是如果在此过程中出现故障或在安装更新时电池电量严重不足。
2. 恢复出厂设置：如果您在执行标准恢复时遇到问题，您的 iPhone 可能会在此过程中或之后保持恢复模式。
3. 越狱：不正确的步骤、越狱出错，有时甚至是正确的越狱过程都可能导致 iPhone 卡在恢复模式。
4. 不可预见的原因：有时，iPhone 可能会因使用设备时不会立即显现的原因而切换到恢复模式。
如何让我的 iPhone 15 退出恢复模式？ iPhone 15/14 卡在恢复模式可能是一个令人生畏的问题，但解决方案因根本原因而异。无论是更新失败、越狱尝试还是未知故障，每种情况都有修复方法。让我们来看看如何立即退出 iPhone 恢复模式。
1 单击以修复卡在恢复模式下而不会丢失数据的 iPhone iPhone 15/14 卡在恢复模式的常见罪魁祸首是 iOS 更新不成功。虽然这似乎很难解决，但拥有正确的工具使其易于管理。
ReiBoot特别擅长解决这个问题。它提供了一种免费解决方案，可以有效地修复卡在恢复模式的 iPhone 或 iPad，同时保留您的数据。此实用程序与所有 iPhone 型号和 iOS 版本兼容，包括最新的 iPhone 15 和 iOS 17。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b73156304f27866bfdb7b7214901215a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f7b4b457605f1617e5fa4186159409b/" rel="bookmark">
			尚硅谷大数据技术-Kafka视频教程-笔记01【Kafka 入门】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视频地址：【尚硅谷】Kafka3.x教程（从入门到调优，深入全面）_哔哩哔哩_bilibili
尚硅谷大数据技术-Kafka视频教程-笔记01【Kafka 入门】尚硅谷大数据技术-Kafka视频教程-笔记02【Kafka 外部系统集成】尚硅谷大数据技术-Kafka视频教程-笔记03【Kafka 生产调优手册】尚硅谷大数据技术-Kafka视频教程-笔记04【Kafka 源码解析】 目录
01_尚硅谷大数据技术之Kafka
第 1 章 Kafka 概述
p001
p002
p003
p004
p005
第 2 章 Kafka 快速入门
p006
p007
p008
p009
第 3 章 Kafka 生产者
p010
p011
p012
p013
p014
第 4 章 Kafka Broker
第 5 章 Kafka 消费者
第 6 章 Kafka-Eagle 监控
第 7 章 Kafka-Kraft 模式
01_尚硅谷大数据技术之Kafka 第 1 章 Kafka 概述 p001 p002 p003 flume：时刻监控数据文件的变化，每产生一条数据日志都能监控的到，并将数据传送到hadoop集群。kafka：数据量太大，对数据进行缓冲。 同步处理：时刻处理，一步一步地做完。异步处理：先处理核心事务。 p004 消息队列的两种模式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f7b4b457605f1617e5fa4186159409b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d55402b983d414456ea968fd82b014f1/" rel="bookmark">
			第65期 | GPTSecurity周报
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GPTSecurity是一个涵盖了前沿学术研究和实践经验分享的社区，集成了生成预训练Transformer（GPT）、人工智能生成内容（AIGC）以及大语言模型（LLM）等安全领域应用的知识。在这里，您可以找到关于GPT/AIGC/LLM最新的研究论文、博客文章、实用的工具和预设指令（Prompts）。现为了更好地知悉近一周的贡献内容，现总结如下。
Security Papers 1. 基于第一性原理的大语言模型多轮上下文越狱攻击
简介：大语言模型（LLMs）极大地提升了从智能对话到文本生成等众多应用的性能。然而，其固有的安全漏洞已成为日益严峻的挑战，尤其是在越狱攻击方面。攻击者能够绕过 LLMs 的安全机制，突破安全约束并产生有害输出。研究者聚焦于多轮语义越狱攻击，发现现有方法未充分考虑多轮对话在攻击策略中的作用，致使在连续交互过程中出现语义偏离。为此，研究者通过考虑多轮攻击在越狱攻击中的支持作用，为多轮攻击建立了理论基础，并在此基础上提出了一种基于上下文的情境融合黑盒越狱攻击方法，名为上下文融合攻击（CFA）。该方法包括从目标中过滤和提取关键术语，围绕这些术语构建情境场景，将目标动态地融入场景中，替换目标中的恶意关键术语，从而隐藏直接的恶意意图。通过在各种主流大语言模型和红队数据集上进行比较，研究者证明了 CFA 与其他多轮攻击策略相比具有更高的成功率、发散性和危害性，尤其在 Llama3 和 GPT-4 上展现出显著优势。
链接：
https://arxiv.org/abs/2408.04686
2. 通过视觉提示注入对大型视觉-语言模型进行目标劫持的实证分析
简介：研究者探索了视觉提示注入（VPI），它恶意地利用大型视觉-语言模型（LVLMs）遵循绘制在输入图像上的指令的能力。研究者提出了一种新的 VPI 方法，即“通过视觉提示注入进行目标劫持”（GHVPI），它将大型视觉语言模型的执行任务从原始任务转换为攻击者指定的替代任务。定量分析表明，GPT-4V 容易受到 GHVPI 的攻击，并且显示出显著的 15.8%的攻击成功率，这是一个不可忽视的安全风险。研究者的分析还表明，成功的 GHVPI 需要大型视觉语言模型具有高字符识别能力和遵循指令的能力。
链接：
https://arxiv.org/abs/2408.03554
3. 针对集成大语言模型的移动机器人系统的提示注入攻击研究
简介：研究者指出，将像 GPT-4o 这样的大语言模型（LLMs）集成到机器人系统中代表了具身人工智能的重大进步。这些模型能够处理多模态提示，从而生成更具上下文感知的响应。然而，这种集成存在挑战，其中主要问题之一是在机器人导航任务中使用大语言模型带来的潜在安全风险。这些任务需要精确和可靠的响应以确保安全有效的操作。多模态提示虽增强了机器人的理解能力，但也引入了可能被恶意利用的复杂性，例如旨在误导模型的对抗性输入可能导致错误或危险的导航决策。本研究中，研究者调查了在集成大语言模型的系统中提示注入对移动机器人性能的影响，并探索安全的提示策略以减轻这些风险。研究结果表明，通过实施强大的防御机制，攻击检测和系统性能总体上有大约 30.8%的显著提升，突出了防御机制在增强面向任务的安全性和可靠性方面的关键作用。
链接：
https://arxiv.org/abs/2408.03515
4. SEAS：大语言模型的自进化对抗性安全优化
简介：研究者指出，随着大语言模型（LLMs）在能力和影响力方面不断提升，确保其安全性并防止有害输出已变得至关重要。一个有前途的方法是训练模型自动生成用于红队测试的对抗性提示。然而，大语言模型中不断演变的细微漏洞对当前对抗性方法的有效性构成了挑战，这些方法难以专门针对并探索这些模型的弱点。为了应对这些挑战，研究者引入了自进化对抗性安全（SEAS）优化框架，该框架通过利用模型自身生成的数据来增强安全性。SEAS 通过三个迭代阶段运行：初始化、攻击和对抗性优化，改进红队和目标模型以提高鲁棒性和安全性。这个框架减少了对人工测试的依赖，并显著增强了大语言模型的安全能力。研究者的贡献包括一个新颖的对抗性框架、一个全面的安全数据集，并且经过三轮迭代后，目标模型达到了与 GPT-4 相当的安全水平，同时红队模型在针对先进模型的攻击成功率（ASR）方面有显著提高。
链接：
https://arxiv.org/abs/2408.02632
5. 使用生成式预训练 Transformer 模型进行自动化软件漏洞静态代码分析
简介：研究者评估了开源 GPT 模型在自动识别易受攻击代码语法（特别是针对C 和 C++源代码）方面的有效性。他们以 NIST SARD 数据集的 36 个源代码示例进行测试，该数据集不含表明漏洞存在与否的自然英语，且能精确量化 GPT 输出分类错误率。共评估了 5 个 GPT 模型，不同推理温度下各重复 100 次。最终发现这些模型不适合完全自动化漏洞扫描，因误报和漏报率过高。但在某些测试用例中表现出色，超越随机抽样，能识别易受攻击代码行，成功率较低。如将推理温度为 0.1 的 Llama-2-70b-chat-hf 应用于特定测试用例，召回分数和精度均为 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d55402b983d414456ea968fd82b014f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/799541a3d06ec463dd951549d3e2b20b/" rel="bookmark">
			智能化升级：AI与大数据在TMS中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		智能化升级：AI与大数据在TMS中的应用
随着信息技术的飞速发展，AI（人工智能）与大数据已成为推动各行各业转型升级的重要力量。在物流运输管理领域，TMS（运输管理系统）作为核心系统，通过集成AI技术和大数据分析，实现了智能调度、路线优化、异常预警等功能，显著提升了物流决策的精准度和效率。本文将深入探讨AI与大数据在TMS中的应用，并分享智能TMS的成功应用案例，以展现其在实际操作中的巨大潜力。
一、AI技术在TMS中的应用
机器学习优化调度
机器学习是AI的一个重要分支，它通过让系统从大量数据中学习并自动改进算法，从而实现对复杂问题的智能处理。在TMS中，机器学习技术被广泛应用于调度优化。系统能够基于历史运输数据、实时交通信息、车辆状态等多维度数据，自动分析并预测最佳的运输方案。例如，通过分析不同时间段的交通拥堵情况、车辆载重限制、司机工作时间等因素，系统能够动态调整运输计划，减少等待时间和空驶率，提高运输效率。
预测分析助力决策
预测分析是AI在TMS中的另一项重要应用。通过大数据分析，系统能够预测未来的运输需求、交通状况、天气变化等因素，为物流决策提供有力支持。例如，在节假日或促销活动期间，系统可以预测运输量的激增，并提前规划运输资源和路线，确保物流顺畅。同时，系统还能根据历史数据预测运输过程中的潜在风险，如交通事故、设备故障等，并提前制定应对措施，降低损失。
智能路线优化
智能路线优化是TMS中AI技术的又一亮点。系统能够基于实时交通信息、道路状况、车辆性能等多方面数据，自动规划出最优的运输路线。这不仅可以减少运输时间和成本，还能降低车辆磨损和油耗，提升整体运营效率。此外，系统还能根据实时路况动态调整路线，确保运输过程的高效和灵活。
异常预警与应急处理
AI技术还能帮助TMS实现异常预警和应急处理。系统通过实时监控运输过程中的各项数据，如车辆位置、速度、载重等，一旦发现异常情况，如车辆偏离预定路线、速度异常、载重超标等，立即触发预警机制，并自动通知相关人员进行处理。同时，系统还能根据历史数据和实时信息，提供应急处理方案，帮助企业快速应对突发情况，减少损失。
二、大数据在TMS中的应用
数据驱动决策
大数据是TMS智能化升级的重要基础。通过收集和分析海量的运输数据，企业可以深入了解运输过程中的各个环节，发现潜在的问题和机会，为决策提供有力支持。例如，企业可以通过分析运输成本、运输时间、客户满意度等数据，评估不同运输方案的优劣，选择最优方案。同时，大数据还能帮助企业预测市场趋势，制定更加精准的物流战略。
精细化管理
大数据的应用使得TMS能够实现精细化管理。系统能够实时收集和处理运输过程中的各项数据，如车辆位置、速度、载重、油耗等，为管理者提供详细的运营报告和数据分析。通过这些数据，管理者可以深入了解运输过程中的各个环节，发现潜在的问题和瓶颈，并采取相应的措施进行改进。例如，通过分析车辆油耗数据，企业可以优化运输路线和车辆调度，降低油耗成本。
供应链协同
大数据还能促进供应链各环节的协同作业。TMS系统通过集成多种企业信息系统（如MES、WMS、ERP等），实现数据共享和业务协同。通过标准化的接口和协议，系统能够实时传输和共享运输过程中的各项数据，打破信息孤岛，提高整体运营效率。例如，企业可以通过TMS系统与供应商、承运商等合作伙伴共享运输计划和实时数据，实现供应链的透明化和协同化。
智能TMS的成功应用案例
无人值守系统
无人值守系统通过落地智能地磅和线上系统，成功解决了数据管理难、人工成本高、作弊损失大等痛点。该系统通过智慧门禁智能识别车辆和运单信息。同时，系统还提供了日报表功能，方便企业进行进销存对账和业务管理。无人值守系统不仅实现了厂区物流管理的数字化转型，还提高了企业的整体运营效率和市场竞争力。
山东港口日照港的木材理货系统
通过智能化升级，实现了高效、精准、安全的木材理货作业。该系统借助5G、AI、环境动态感知等先进技术，首创全地型远程遥控智能理货机器人，替代理货工人现场作业，使理货工作更加安全、高效、环保。通过智能理货系统，木材能够实现自动识别、方量自动计算、现场发货场景可追溯等功能，识别准确率达到98%以上，作业效率提升60%以上。此外，该系统还实现了数据与视频的双重监控，以及实时管控和有效分析，打造了木材监管货场远程无人理货模式，进一步提升了安全管控水平。这一系列智能化措施不仅优化了理货流程，还显著提高了工作效率和服务质量，为日照港木材业务的高质量发展提供了有力支撑。
新商软件官网链接：https://www.9885.net/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc565487353d8e788d0d4b485f081ea4/" rel="bookmark">
			spring boot 根据实体类生成表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发的过程中，经常会遇到数据库表结构发生变化或者新增表的情况，而spring 体系下提供的spring data jpa可以帮助我们很方便的处理这种情况，只需要简单的配置既可！以下便是实现路径以及其中需要注意的事项。
添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.33&lt;/version&gt; &lt;/dependency&gt; 如上所示，示例使用mysql作为数据库，其中需要导入jpa的依赖，其他的根据情况进行配置。
数据库相关配置 spring: application: name: demo datasource: url: jdbc:mysql://ip:port/demo username: username password: password driver-class-name: com.mysql.cj.jdbc.Driver jpa: hibernate: ddl-auto: update 如上所示，除了数据库的配置之外，需要配置hibernate的ddl-auto字段，我们设置为update，即实体类发生变化时，会自动的更新表结构。
实体类 我们在设置实体类时，一般会有一个父类，用于存储每个类都共有的字段，如主键Id，创建者、创建时间等，配置如下
父类 @Data @MappedSuperclass public class BaseEntity implements Serializable { /** * 主键 */ @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(updatable = false, unique = true, nullable = false) private Long id; @CreatedBy @Column(updatable = false, name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc565487353d8e788d0d4b485f081ea4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90a745f24145779b0834dd2a440a63d9/" rel="bookmark">
			GraphRAG如何使用ollama提供的llm model 和Embedding model服务构建本地知识库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用GraphRAG踩坑无数 在GraphRAG的使用过程中将需要踩的坑都踩了一遍（不得不吐槽下，官方代码有很多遗留问题，他们自己也承认工作重心在算法的优化而不是各种模型和框架的兼容性适配性上），经过了大量的查阅各种资料以及debug过程（Indexing的过程有点费机器），最终成功运行了GraphRAG项目。先后测试了两种方式，都成功了:
使用ollama提供本地llm model和Embedding model服务使用ollama提供llm model服务，使用lm-studio提供embedding model服务 之所以要使用ollama同时提供llm和Embedding模型服务，是因为ollama实在是太优雅了，使用超级简单，响应速度也超级快。
使用ollama提供服务的方式如下： 1、安装GraphRAG:
pip install graphrag -i https://pypi.tuna.tsinghua.edu.cn/simple 创建一个文件路径:./ragtest/input mkdir -p ./ragtest/input 将语料文本文件放在这个路径下， 文件格式为txt， 注意：txt文件必须是utf-8编码的，可以用记事本打开另存为得到。使用命令python -m graphrag.index --init --root ./ragtest初始化工程: python -m graphrag.index --init --root ./ragtest 修改.env文件内容如下: GRAPHRAG_API_KEY=ollama GRAPHRAG_CLAIM_EXTRACTION_ENABLED=True 注意：必须加上参数GRAPHRAG_CLAIM_EXTRACTION_ENABLED=True，否则无法生成协变量covariates， 在Local Search时会出错。
修改.setting.yaml文件，内容如下: encoding_model: cl100k_base skip_workflows: [] llm: api_key: ollama type: openai_chat # or azure_openai_chat model: qwen2 model_supports_json: true # recommended if this is available for your model. # max_tokens: 4000 # request_timeout: 180.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90a745f24145779b0834dd2a440a63d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5843ea509f6a874b54ef93ab079e90dd/" rel="bookmark">
			node中如何定义中间件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.中间件的概念
中间件可以理解为是一个进行数据或逻辑处理的方法，是数据或者逻辑处理的中枢，既然是中枢那么就有输入输出，输入就是我们使用该中间件的时候就是输入，输出就是要求我们在编写中间件的使用需要调用next(),没有next()那么处理完的数据还存放在中枢里那就没意义了。而全局中间件不管你在哪里做了什么都会进入该中间件进行处理；局部中间件就相当于有自己的作用域，一般挂载注册在需要该中间件去处理数据的路由上
2.局部中间件和全局中间件区别
2.1.全局中间件：使用server.use()注册挂载的中间件，而中间件其实就是进行数据处理和逻辑处理的方法，全局中间件在客服端访问了路由后就会调用中间件中的方法进行一系列处理
2.2.局部中间件：不使用server.use()注册挂载的中间件，而是在配置路由时直接在挂载在需要中间件去处理的路由中
// 1.导入express和router const express = require('express') const router = require('./21模块化路由') // 2.创建web服务器 const server = express() // 3.监听服务器的启动 server.listen(80,()=&gt;{ console.log("web服务器启动了 http://127.0.0.1:80"); }) // 4.定义中间件：分为全局中间件和局部中间件 // 全局中间件：只要是客户端进行了请求就会进入中间件，使用server.use()进行挂载的中间件 // 局部中间件:不使用server.use()进行挂载的中间件,在配置路由时使用 // next是一个函数，中间件必须调用才能进入下一个中间件或者路由 // 自定义中间件 const mv = function (req,res,next){ // 用于注册为全局中间件 console.log("这是一个中间件"); next() } const mv1 = function (req,res,next){ // 用于注册为局部中间件 console.log("这是第一个局部中间件"); next() } const mv2 = function (req,res,next){ // 用于注册为局部中间件 console.log("这是第二个局部中间件"); next() } const mv3 = function (req,res,next){ // 用于注册为局部中间件 console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5843ea509f6a874b54ef93ab079e90dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4340f83ef6c514de06f85703bb19cba8/" rel="bookmark">
			Docker存储目录问题，如何修改Docker默认存储位置？（Docker存储路径、Docker空间）/etc/docker/daemon.json（docker占用、docker容量）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 如何更改docker默认存储路径？版本1（我没测试，先别用！）版本2（可行）1. 停止 Docker 服务：2. 创建新的存储目录：3. 修改 Docker 配置文件：4. 移动现有的 Docker 数据：5. 重新启动 Docker 服务：6. 验证修改7. 真实验证（记录各时间点和存储占用）Thu 11 Jul 2024 01:33:57 PM CST（`/`Available 27445M）Thu 11 Jul 2024 04:04:38 PM CST（`/`Available 27444M）Fri 12 Jul 2024 01:51:59 PM CST（`/`Available 27444M） 为什么存在以上两种修改方法，有何异同？（修改`etc/systemd/system/docker.service.d/override.conf`和修改`etc/docker/daemon.json` ）20240830 另外一个，docker.service文件也可能对配置存储目录造成影响，这似乎是老版本配置 如何更改docker默认存储路径？ 版本1（我没测试，先别用！） 默认情况下，Docker 在 Linux 上安装时会将其数据（如镜像和容器）存储在 /var/lib/docker 目录下，这个目录通常位于根分区 /。如果你的根分区 / 的空间不足，你可以考虑将 Docker 的数据目录移动到其他分区，或者在安装 Docker 时直接配置它使用其他分区。
要更改 Docker 的默认存储位置，你可以通过修改 Docker 的配置文件或在启动 Docker 服务时设置环境变量来指定新的数据目录。下面是一些步骤说明如何进行配置：
停止 Docker 服务：
sudo systemctl stop docker 修改 Docker 配置文件（如果你使用的是 systemd）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4340f83ef6c514de06f85703bb19cba8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee7b63f36932b5b8431aeb8cd5aaa380/" rel="bookmark">
			Java经典框架之MyBatis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本介绍 MyBatis 是一个非常流行的 Java 持久层框架，它提供了简单的方法来处理数据库中的数据。MyBatis 可以看作是 JDBC 的一个薄封装，它简化了 JDBC 代码的编写，同时提供了强大的功能，如动态 SQL、映射自定义对象到数据库记录等。
二、核心特性 SQL Mapper: MyBatis 使用 XML 或注解来映射 SQL 语句，这使得 SQL 语句可以与 Java 代码分离，便于管理和维护。
动态 SQL: MyBatis 支持动态 SQL，这意味着 SQL 语句可以根据条件动态地构建，提高了代码的复用性。
高级映射: MyBatis 支持将数据库列映射到 Java 对象的属性，包括但不限于简单类型、自动增长的主键、关联查询等。
配置简单: MyBatis 的配置相对简单，通过 XML 文件或注解可以轻松配置数据源、事务管理器等。
事务支持: MyBatis 支持声明式事务和编程式事务，可以方便地管理数据库事务。
缓存机制: MyBatis 提供了一级缓存和二级缓存，可以显著提高数据访问的性能。
插件机制: MyBatis 允许开发者编写插件来拦截方法调用，实现自定义的功能，如分页、性能监控等。
Spring 集成: MyBatis 可以很容易地与 Spring 框架集成，利用 Spring 的依赖注入和事务管理。
MyBatis-Spring 框架: 这是 MyBatis 和 Spring 的整合版本，提供了额外的集成特性，如自动 SQL 映射和事务管理。
MyBatis Plus: 是 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee7b63f36932b5b8431aeb8cd5aaa380/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c74cf5c895f51608a44716b12bb6a89/" rel="bookmark">
			ubuntu c&#43;&#43; http服务端event使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序：
#ifndef PLATFROMCOMMUNICATION_H #define PLATFROMCOMMUNICATION_H #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;unistd.h&gt; #include &lt;curl/curl.h&gt; #include &lt;net/if.h&gt; #include &lt;sys/ioctl.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;string.h&gt; #include &lt;event.h&gt; #include &lt;event2/event.h&gt; #include &lt;event2/buffer.h&gt; #include &lt;event2/http.h&gt; #include &lt;event2/http_struct.h&gt; #include &lt;event2/http_compat.h&gt; #include &lt;event2/util.h&gt; #include &lt;jsoncpp/json/json.h&gt; #define ETH_NAME "ens33" #define MYHTTPD_SIGNATURE "MoCarHttpd v0.1" using namespace std; class RouteTasks{ public: RouteTasks(); void init(); private: static void login(struct evhttp_request *req, void *arg); string getIp(); int m_port; int m_timeout; }; #endif // PLATFROMCOMMUNICATION_H #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c74cf5c895f51608a44716b12bb6a89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e1fc078c2bc4a1f00246535625e1331/" rel="bookmark">
			顶级域名服务器 - TLD服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TLD服务器（顶级域名服务器）是负责管理互联网域名系统（DNS）中所有顶级域名（Top-Level Domains, TLDs）的DNS记录的服务器。顶级域名是域名层级结构中的最高级别，位于域名的最右侧，例如.com、.org、.net、国家代码顶级域名（ccTLDs）如.cn、.uk等，以及新的通用顶级域名（gTLDs）如.app、.blog等。
TLD服务器的作用 域名解析：当进行域名解析请求时，如果本地DNS服务器无法直接解析出域名对应的IP地址，它会首先向根DNS服务器查询。根DNS服务器不直接解析域名，而是指向负责该顶级域名的TLD服务器。然后，TLD服务器会指向该域名的权威DNS服务器的地址。
权威DNS服务器指引：TLD服务器存储了所有在其下注册的二级域名（如example.com中的example）的权威DNS服务器的地址。这些权威DNS服务器进一步负责存储关于域名的详细记录，如A记录（域名对应的IP地址）、MX记录（邮件交换服务器地址）等。
TLD服务器的重要性 互联网的基础设施：TLD服务器是互联网DNS查询过程中的关键组成部分，它们确保了域名可以被正确地解析到对应的IP地址，从而使得用户能够访问到正确的网站或服务。
全球分布：为了提高解析效率和确保服务的稳定性，TLD服务器通常会在全球多个地点部署。
安全性：TLD服务器的安全性对整个互联网的稳定运行至关重要。因此，它们通常会采取多种安全措施来防止DNS攻击，如DNS欺骗、DDoS攻击等。
TLD服务器与根DNS服务器的区别 根DNS服务器：是DNS层级结构的最顶层，全球共有13组根DNS服务器，它们主要负责管理指向TLD服务器的记录。TLD服务器：位于根DNS服务器之下，负责管理特定顶级域名下的域名记录，如指向权威DNS服务器的NS记录。 总之，TLD服务器在域名解析过程中扮演着桥梁的角色，连接根DNS服务器和权威DNS服务器，确保域名可以被正确快速地解析。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ef92834992d81cc26aaee8c99b35f6d/" rel="bookmark">
			金融知识普及月答题活动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		金融知识普及月答题活动
关键词：金融安全、风险防范、金融常识、反诈宣传
推荐功能：答题、倡议书
宣传角度：
1. 普及金融知识：讲解货币、信用、利率、汇率等基本金融概念，以及储蓄、贷款、信用卡、保险等常见金融产品的特点和使用方法。
2. 防范金融诈骗：揭露各种金融诈骗手段，如电信诈骗、网络诈骗、非法集资等，提高消费者的防范意识和识别能力。
推荐宣传方式：
1. 答题互动：通过在线答题的方式， 参与者可以随时随地通过网络进行答题， 答题后能立即得到结果反馈，有助于参与者了解自己对金融知识的掌握程度。还可以设置得分排名或有奖答题， 激发大家的竞争意识，提高参与积极性。
【普及金融知识 防范非法集资】
2. 倡议书：倡议书能够以正式、严肃的方式引起大家对金融知识的重视，以真挚的语言和诚恳的态度，引发读者的情感共鸣，促使他们积极响应倡议。
【金融防诈指南-倡议书】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df22847dac8edbf9bb9ac1c4ef88975a/" rel="bookmark">
			CARLA Drone: 首个实现从不同空中视角进行单目3D目标检测，并提供数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CARLA Drone: 首个实现从不同空中视角进行单目3D目标检测，并提供数据集 Abstract 现有的单目3D检测技术存在一个严重的限制。它们通常只能在有限的基准测试集上表现良好，要么在自车视角表现出色，要么在交通摄像机视角表现出色，但很少能同时在两者上表现良好。为了促进这一领域的进展，本文倡导对3D检测框架进行不同相机视角的扩展评估。我们提出了两个关键贡献。首先，我们引入了CARLA无人机数据集CDrone。该数据集模拟了无人机视角，大大增加了现有基准测试集中相机视角的多样性。尽管它是合成数据，但CDrone代表了一种真实的挑战。为证明这一点，我们确认了现有技术难以同时在CDrone和一个真实世界的3D无人机数据集上表现出色。其次，我们开发了一种名为GroundMix的有效数据增强管道。其独特之处在于使用地面来创建训练图像的3D一致性增强。GroundMix显著提升了一种轻量级单阶段检测器的检测准确性。在我们扩展的评估中，我们达到了与之前最先进技术相当或显著更高的平均精度，且适用于所有测试数据集。
项目地址：https://deepscenario.github.io/CDrone/
Introduction 检测交通参与者对提高道路安全和开发可靠的自动驾驶汽车至关重要。而从单幅图像中检测3D物体尤其具有挑战性。然而，以往的单目3D目标检测研究主要集中在自车视角，这仅提供了对交通的有限视角。通过利用广泛可用的监控摄像头，甚至无人机搭载的摄像头，可以获得更全面的理解，这些都可以在图1中体现出来。这些交通场景中的视角多样性为3D目标检测带来了独特的技术挑战。不出所料，当前的最先进技术往往仅能在特定视角下表现良好，而难以对其他相机视角进行准确预测。
为解决上述局限性，我们的工作提供了两个贡献。首先，我们设计了一个包含三类相机视角的综合基准测试集：自车视角、交通监控视角和无人机视角（参见图1）。该基准测试集的目标是对单目3D检测方法进行不同相机视角下的“压力测试”。这与之前仅关注单一视角检测的工作形成对比。自车和监控视角的数据可以从现有数据集（如Waymo和Rope3D）中轻松获取。然而，交通场景的真实世界无人机图像非常稀缺。因此，我们利用CARLA模拟器生成了一个带有精确3D注释的合成无人机数据集CDrone。为了支持CDrone的研究价值，我们展示了在内部真实世界无人机数据集和合成CDrone上的实验结果的一致性。
作为我们的第二个贡献，也是朝着单目3D目标检测器多功能性迈出的一步，我们开发了一种有效的数据增强管道——GroundMix。它将一致性正则化的常见技术（如缩放、2D-3D一致性旋转以及MixUp）扩展到了单目3D检测任务。GroundMix的关键新组件利用了地面平面方程，从而实现了3D感知的图像编辑。具体来说，它将挖掘出的困难对象样本放置在估计的地面平面上，从而呈现出越来越复杂的训练场景。
3. CDrone：一个新颖的无人机视角数据集 现有的无人机数据集主要提供2D标注，并且缺乏关键的3D边界框信息。这些局限性限制了从无人机视角开发和准确评估单目3D目标检测算法的研究工作。为弥补这一空白，我们引入了CARLA无人机数据集，简称CDrone。CDrone提供了全面的3D边界框标注。
数据生成与标注 一个用于3D目标检测的大规模、多样化的数据集CDrone的创建过程和特点如下：
渲染技术：为了实现更逼真的渲染效果，选择了CARLA模拟器，并在史诗级渲染模式下创建了多样化的户外场景。
数据生成选择：选择了CARLA而非AirSim进行数据生成，原因是在AirSim中获取3D边界框标注较为困难。
仿真环境：CDrone仿真环境包含42个地点，覆盖了城市和乡村景观。
场景录制：每个场景包含265辆车辆，以每秒12.5帧和1920x1080像素的分辨率，捕获了900张图像，包括夜间、白天、黎明和雨天场景。
场景内容：每个场景展示了户外驾驶场景，包括街道、交叉路口和其他交通元素。
无人机视角：无人机的高度范围从6.9米到60.6米，确保了目标检测器和地面真实边界框之间的准确重叠。视角角度从几乎垂直到几乎与地面共面，具有广泛的多样性。
物体深度：数据集保持了11.0米的最小物体深度，这增加了检测远距离物体的难度，使得任务更具挑战性。
数据集统计：CDrone数据集包含大量的不同类型对象，如汽车、卡车、摩托车、自行车、公交车和行人，并被划分为训练、验证和测试地点，分别对应不同数量的图像。
数据集划分：数据集被划分为24个训练地点，9个验证地点和9个测试地点，每个地点分别有不同数量的图像。
在图3中，我们将CDrone的数据统计与我们基准测试中使用的其他数据集进行了比较。首先，CDrone填补了Waymo和Rope3D深度分布模式之间的空白。CDrone中的3D边界框往往集中在距离相机较远的地方，但在大约80米处被限制住。需要注意的是，Rope3D中的交通视角允许看到更远的深度值。然而，与KITTI类似，Rope3D评估协议排除了高度低于25像素的远处物体。相比之下，CDrone评估考虑了所有可见物体。其次，与Waymo和Rope3D相比，CDrone的旋转分布更均匀，这突显了在无人机数据中旋转估计的挑战性。第三，物体通常具有较小的度量高度但较大的度量宽度。此外，与Waymo和Rope3D相比，物体长度分布具有更大的方差。这些特性使得物体尺寸的准确估计在评估中变得更加重要。
我们发布的标注格式与OMNI3D保持一致。我们通过将3D角点投影到图像上并在图像边界处截断它们来计算2D边界框。我们还为每个物体提供了跟踪ID，以便在未来的工作中促进联合跟踪与检测。
评估指标 按照既定的3D检测基准，本文采用广泛使用的平均精度（AP）作为CDrone的评估指标。考虑到较高的最小物体深度，在IoU阈值为0.5（APIoU=0.5）的情况下报告AP。与之前只评估围绕相机y轴旋转的基准不同，本文评估了类似于OMNI3D评估协议的3自由度旋转。
4. 从不同视角检测3D物体 4.1 问题陈述 单目3D目标检测涉及从RGB图像中提取特征，以确定每个物体的类别和三维边界框。设I表示具有内在参数K ∈ R^3×3的RGB图像，B(I) = {B1, …, Bn}表示I中包含的物体的真实3D边界框。每个边界框Bi由其相对于相机中心的位置(xi, yi, zi) ∈ R^3、尺寸(wi, hi, li) ∈ R^3、自中心旋转矩阵Ri ∈ SO(3)和物体类别ci ∈ N（例如“汽车”，“行人”）来参数化。训练样本由M个元组(Ij, Kj, B(Ij))M_j=1组成，本文的目标是逼近B(·)。
4.2 预测SO(3)旋转 出于实际考虑，我们使用轻量级的MonoCon单阶段3D目标检测器作为基线。与CenterNet类似，MonoCon通过类热图检测物体，使其适合实时自动驾驶应用。这与更昂贵且报告不稳定的Cube R-CNN形成对比。MonoCon只预测围绕相机y轴的旋转，假设其他旋转角度与相机的角度一致。这限制了MonoCon在没有提供地面平面方程的情况下进行完整的3D方向预测，从而限制了其对不同相机视角的泛化能力。本文通过预测6个值并通过Gram-Schmidt正交化将其转换为旋转矩阵来扩展MonoCon以预测完整的3D旋转。本文将标注转换为相对于相机的Lie群SO(3)表示，并在训练期间使用allocentric方向，在推理期间恢复到egocentric格式。
4.3 GroundMix：在地面平面上增强数据 为了提高MonoCon的检测精度，引入了GroundMix，一种新颖的数据增强管道。图4展示了该管道的概述。关键思想很简单：将物体贴片放置在物理上合理的地面平面位置上，这一假设仅在训练期间可用。
A. 拟合地面平面 采样位置 在自动驾驶的背景下，物体往往位于一个公共的地面平面上。基于这一假设，我们首先使用最小二乘法估计来拟合这个平面，需要三个物体。由于大多数数据集满足这一标准（Waymo: 79.5%，Rope3D: 98.5%，CDrone: 96.8%），我们在至少存在三个物体时执行贴片粘贴。尽管我们可以使用单个物体的底部角点，但使用三个不同的物体可以提高估计的鲁棒性。平面方程和物体标注允许我们通过随机采样像素并将其反投影到地面平面上来采样候选3D目标位置。
B. 硬采样 / D.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df22847dac8edbf9bb9ac1c4ef88975a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85d5de8bd0b6c9b5fd730b03bd983dd9/" rel="bookmark">
			Go锁 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		锁 - Go 函数并发编程中，锁是一种同步机制，用于协调对共享资源的访问，防止数据竞争 - Go 中提供了多种类型的锁，每种锁都有不同的特性和适用场景 类型 互斥锁（mutex）
基础锁，只能同时允许一个 goroutine 获取资源（悲观锁）保证了对共享资源的独占访问适用于对数据进行频繁写操作的场景 读写锁（RWMutex）
更高级的锁，它允许多个goroutine同时读取受保护的数据，但只允许一个goroutine同时写入（悲观锁）可以提高程序的性能，因为读取操作通常比写入操作要快适用于对数据进行频繁读操作的场景 互斥锁 底层结构 // sync 包下的mutex就是互斥锁 type Mutex struct { state int32 sema uint32 } - state：表示当前互斥锁的状态，复合型字段 - sema：信号量变量，用来控制等待goroutine的阻塞休眠和唤醒 state的不同位分别表示了不同的状态,使用最小的内存来表示更多的意义
// 其中低三位由低到高分别表示mutexLocked、mutexWoken 和 mutexStarving // 剩下的位则用来表示当前共有多少个goroutine在等待锁： const ( mutexLocked = 1 &lt;&lt; iota // 表示互斥锁的锁定状态 mutexWoken // 表示从正常模式被从唤醒 mutexStarving // 当前的互斥锁进入饥饿状态 mutexWaiterShift = iota // 当前互斥锁上等待者的数量 ) 提供了三个公开方法： Lock():获得锁，Unlock():释放锁，在Go1.18新提供了TryLock()方法可以非阻塞式的取锁操作 加锁
释放锁
正常模式（默认）
采用公平的先进先出策略当一个goroutine尝试获取锁时，如果锁处于加锁状态，该goroutine会被放入等待队列中，等待锁的释放。当锁被解锁后，等待队列中的goroutine会按照先后顺序获取锁当一个协程被唤醒后并不是直接拥有锁，该协程需要和刚刚到达的协程一起竞争锁的所有权当等待的 goroutine 1ms内没有获取到锁，将会把锁置为饥饿模式 饥饿模式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85d5de8bd0b6c9b5fd730b03bd983dd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/517b2cd0fbd9ca97fd272a690959c58c/" rel="bookmark">
			【C&#43;&#43;笔记】类和对象的深入理解(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【C++笔记】类和对象的深入理解(一) 🔥个人主页：大白的编程日记
🔥专栏：C++笔记
文章目录 【C++笔记】类和对象的深入理解(一)前言一.类的定义1.1类定义格式1.2访问限定符1.3类域 二.实例化2.1 实例化概念2.2对象大小 三.this指针四.练习五. C++和C语言实现Stack对比后言 前言 哈喽，各位小伙伴大家好！上期我们讲了C++的引用。今天我们就开始学习C++的重点—类和对象。话不多说，咱们进入正题！向大厂冲锋！
一.类的定义 C语言的结构体只能放变量。而C++的类除了能放成员变量，还能放成员函数。
1.1类定义格式 定义格式
例如我们用类定义一个栈。可以这样写 class为定义类的关键字，Stack为类的名字，{}中为类的主体，注意类定义结束时后面分号不能省略。类体中内容称为类的成员：类中的变量称为类的属性或成员变量;类中的函数称为类的方法或者成员函数。
class Stack//类名就是类型 { // 成员函数 void Init(int n = 4) { array = (int*)malloc(sizeof(int) * n); if (nullptr == array) { perror("malloc申请空间失败"); return; } capacity = n; top = 0; } void Push(int x) { // ...扩容 array[top++] = x; } int Top() { assert(top &gt; 0); return array[top - 1]; } void Destroy() { free(array); array = nullptr; top = capacity = 0; } private: // 成员变量 int* array; size_t capacity; size_t top; }; //分号不能省略 成员变量和函数可以在类位置可以任意顺序。一般成员在下，函数在上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/517b2cd0fbd9ca97fd272a690959c58c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86711b29349bc5413a3b151b35991b80/" rel="bookmark">
			Git和SVN了解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git Git是一种开源的分布式版本控制系统，它用于敏捷高效地处理任何或小或大的项目。Git由林纳斯·托瓦兹（Linux之父）设计并开发，自问世以来，因其强大的功能和灵活性，在软件开发和版本控制领域得到了广泛应用。以下是对Git的详细介绍：
一、Git的基本概念和特点
版本控制：Git是一个版本控制系统，用于记录文件的更改历史，以便能够追踪、恢复或比较不同版本的文件。
分布式：与集中式版本控制系统（如SVN）不同，Git是分布式的，意味着每个用户都可以在自己的计算机上拥有一个完整的仓库副本，包括所有的历史记录。这种设计提高了系统的灵活性和可靠性。
高效性：Git之所以高效，部分原因在于它直接记录快照而非差异比较，并且其绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络的信息。
二、Git的主要功能和优势
版本控制：Git可以记录项目文件的所有更改历史，包括每次提交的时间、作者和更改内容。这使得用户可以轻松地回溯到以前的版本或比较不同版本之间的差异。
分支管理：Git支持强大的分支功能，允许用户在不影响主分支的情况下，在分支上进行新的功能开发或错误修复。这有助于提高开发效率和代码质量。
团队协作：Git支持多人协作开发，通过分支合并和冲突解决机制，可以轻松实现团队成员之间的代码共享和合并。
离线工作：即使在没有网络连接的情况下，用户仍然可以在本地进行版本控制操作，并在连接恢复后将更改同步到远程仓库。
三、Git的工作流程
Git的工作流程通常包括以下几个步骤：
工作区：用户进行代码编辑的地方，也称为工作目录。
暂存区：用于临时存放将要提交到仓库的文件更改。用户可以使用git add命令将文件更改添加到暂存区。
仓库区：用于安全存放项目文件的所有版本数据。用户可以使用git commit命令将暂存区的文件更改提交到仓库区。
远程仓库：用于托管项目代码的服务器。用户可以通过git push和git pull等命令与远程仓库进行交互，实现代码的共享和同步。
四、Git的应用场景
软件开发：Git是软件开发中最常用的版本控制工具之一，可以帮助开发团队更好地管理代码变更和协作开发。
文档管理：除了代码之外，Git还可以用于管理项目文档、配置文件等文件的版本。
学术研究：在学术研究中，Git可以帮助研究人员管理实验数据、论文草稿等文件的版本历史。
SVN SVN（Subversion）是一个开源的版本控制系统，用于跟踪文件、目录树以及其中的更改。它允许开发者在开发过程中保存文件的不同版本，并可以轻松地恢复到以前的版本，这对于团队协作和项目管理至关重要。SVN 最初由 CollabNet 开发，并于 2000 年首次发布，至今仍然是许多开发团队和项目中广泛使用的版本控制工具之一。
SVN 的主要特点：
版本控制：SVN 允许用户保存文件或目录的多个版本，并可以跟踪这些版本之间的更改。
集中式管理：SVN 是一个集中式版本控制系统，意味着所有的版本信息都存储在一个中央仓库（repository）中。用户通过客户端软件（如 TortoiseSVN、SVNX、命令行工具等）与这个仓库进行交互，提交（commit）自己的更改或更新（update）到最新版本。
原子提交：SVN 支持原子性提交，即一次提交中的所有更改要么全部成功，要么全部失败，这有助于保持版本历史的清晰和一致性。
分支和标签：SVN 支持创建分支（branch）和标签（tag）。分支允许开发者在不影响主开发线的情况下进行新功能开发或错误修复。标签则用于标记特定的版本，如发布版本。
权限管理：SVN 提供了灵活的权限控制机制，可以限制不同用户对仓库中不同部分的访问权限。
钩子（Hooks）：SVN 允许用户定义在特定事件（如提交、更新等）发生时自动执行的脚本，这可以用于自动化测试、备份或其他自定义操作。
跨平台：SVN 可以在多种操作系统上运行，包括 Windows、Linux 和 macOS，这使得它成为跨平台开发项目的理想选择。
SVN 的使用场景：
软件开发：SVN 是软件开发中常用的版本控制工具，帮助开发者管理代码变更，促进团队协作。
文档管理：除了代码，SVN 也可以用于管理项目文档，如设计文档、用户手册等。
网站内容管理：对于需要频繁更新内容的网站，SVN 可以帮助管理网站文件的不同版本。
尽管 SVN 是一个功能强大的版本控制系统，但近年来随着 Git 等分布式版本控制系统的兴起，SVN 在一些新项目中的使用率有所下降。然而，对于需要集中式管理、对版本历史有严格要求或已经习惯使用 SVN 的团队来说，SVN 仍然是一个可靠且有效的选择。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86711b29349bc5413a3b151b35991b80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0edbce45b8dccf4d792229bab452e9f8/" rel="bookmark">
			全栈程序员 | 精通安卓、鸿蒙，小程序，Java、Vue.js、SpringBoot及更多技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是一个全栈程序员，擅长多种开发技术，包括安卓开发、Java编程、Vue.js、SpringBoot以及小程序开发等。我在技术上有广泛的涉猎，并致力于将创新解决方案应用于实际项目中。无论是开发高性能的安卓应用，还是构建响应式网页、实现复杂的后端功能，我都能提供专业的技术支持和高质量的代码实现。期待与您合作，共同打造卓越的技术产品。
Java 项目代做，小程序，安卓，鸿蒙，VUE 程序代写
Java调试安装、项目运行、代码代做、环境配置、工具安装、代码讲解、代码调试、代码运行、代码部署、项目调试、项目部署、Java Web、Spring Boot、项目设计、前后端分离、代码报错解决等相关问题。
Java开发，Java物联网开发，后台管理系统，项目定做，项目代写，项目外包，项目接单，问题咨询，项目定做，代码编程。一站式服务 (代码编写，远程配置，运行环境配置，答疑，售后)
技术包括但不限于：mysql html css JavaScript android spring mvc ssm mybatis springboot springcloud
24小时接单，可接从零开发，加功能，修改bug
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc17281a8b3016629902d7523d23535c/" rel="bookmark">
			算法训练营|图论第6天 108.冗余连接 109.冗余连接2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：108.冗余连接 题目链接： 108. 冗余连接 (kamacoder.com)
代码： #include&lt;bits/stdc++.h&gt; #include&lt;unordered_map&gt; #include&lt;unordered_set&gt; using namespace std; vector&lt;int&gt;father; int find(int u) { if (father[u] == u) { return u; } else { return father[u] = find(father[u]); } } void join(int u, int v) { u = find(u); v = find(v); if (u == v) return; father[v] = u; } bool isSame(int u, int v) { u = find(u); v = find(v); return u == v; } int main() { int n; cin &gt;&gt; n; father = vector&lt;int&gt;(n + 1); for (int i = 0; i &lt;= n; i++) father[i] = i; for (int i = 0; i &lt; n; i++) { int s, t; cin &gt;&gt; s &gt;&gt; t; if (isSame(s, t)) { cout &lt;&lt; s &lt;&lt; ' ' &lt;&lt; t &lt;&lt; endl; } else { join(s, t); } } } 题目：109.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc17281a8b3016629902d7523d23535c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/418f963fcf16b39a6b58f01658eb642e/" rel="bookmark">
			企业车辆|基于SprinBoot&#43;vue的企业车辆管理系统(源码&#43;数据库&#43;文档)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		企业车辆管理系统
基于SprinBoot+vue的企业车辆管理系统
一、前言
二、系统设计
三、系统功能设计 系统功能实现
后台模块实现
管理员模块实现
驾驶员模块实现
四、数据库设计
五、核心代码 六、论文参考
七、最新计算机毕设选题推荐
八、源码获取：
博主介绍：✌️大厂码农|毕设布道师，阿里云开发社区乘风者计划专家博主，CSDN平台Java领域优质创作者，专注于大学生项目实战开发、讲解和毕业答疑辅导。✌️
主要项目：小程序、SpringBoot、SSM、Vue、Html、Jsp、Nodejs等设计与开发。
🍅文末获取源码联系🍅
基于SprinBoot+vue的企业车辆管理系统 一、前言 企业车辆管理系统，聚焦于高效管理与安全控制，深度融合Java语言与SpringBoot框架的精髓。系统始于详尽的车辆管理需求分析，精准定位企业需求，构建出功能完备、结构清晰的系统框架。此框架不仅涵盖车辆管理的核心功能，还注重系统安全性的全面设计，确保数据稳定与隐私保护。通过精心设计的测试流程与结果分析，不断优化系统性能，为后续维护与升级奠定坚实基础。此车辆管理系统以其个性化的网络协作机制，促进管理团队协作与创新，为企业车辆管理带来前所未有的便捷与高效，成为行业内的标杆解决方案。
关键词：企业车辆，SpringBoot，Mysql
二、系统设计 系统功能结构图
三、系统功能设计 系统功能实现 当人们打开系统的网址后，首先看到的就是首页界面。在这里，人们能够看到系统的导航条，通过导航条导航进入各功能展示页面进行操作。系统首页界面如图5-1所示：
图5-1 系统首页界面
后台模块实现 后台登录，在登录页面正确输入用户名和密码后，点击登录进入操作系统进行操作；如图5-5所示。
图5-5 后台登录界面
管理员模块实现 管理员进入主页面，主要功能包括对个人中心、驾驶员管理、用户管理、车辆登记管理、维修信息管理、事故信息管理、违章信息管理、车辆运营管理、企业论坛、系统管理等进行操作。管理员主页面如图5-6所示：
图5-6 管理员主界面
驾驶员模块实现 驾驶员进入系统可以对个人中心、车辆登记管理、维修信息管理、事故信息管理、违章信息管理、车辆运营管理等功能进行操作。驾驶员主页面如图5-15所示：
图5-15驾驶员主界面
四、数据库设计 维修信息实体属性图如下图所示。
图4-5维修信息实体属性图
数据库表的设计，如下表：
表4-1：系统公告
字段名称
类型
长度
字段说明
主键
默认值
id
bigint
主键
主键
addtime
timestamp
创建时间
CURRENT_TIMESTAMP
title
varchar
200
标题
introduction
longtext
4294967295
简介
picture
longtext
4294967295
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/418f963fcf16b39a6b58f01658eb642e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da94ae7586ed7109e15c0c2c611eba32/" rel="bookmark">
			短视频流量|基于SprinBoot&#43;vue的短视频流量数据分析系统(源码&#43;数据库&#43;文档)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		短视频流量数据分析系统
基于SprinBoot+vue的短视频流量数据分析系统
一、前言
二、系统设计
三、系统功能设计
系统功能模块
管理员功能模块实现
四、数据库设计
五、核心代码 六、论文参考
七、最新计算机毕设选题推荐
八、源码获取：
博主介绍：✌️大厂码农|毕设布道师，阿里云开发社区乘风者计划专家博主，CSDN平台Java领域优质创作者，专注于大学生项目实战开发、讲解和毕业答疑辅导。✌️
主要项目：小程序、SpringBoot、SSM、Vue、Html、Jsp、Nodejs等设计与开发。
🍅文末获取源码联系🍅
基于SprinBoot+vue的短视频流量数据分析系统 一、前言 短视频流量数据分析与可视化管理展现了其蓬勃生命力和广阔的前景。与此同时，为解决短视频流量数据分析与可视化管理需求，短视频流量数据分析与可视化管理发展愈发多元化与网络化，与电子信息技术相结合，短视频流量数据分析与可视化系统应运而生，短视频流量数据分析系统基于Hadoop平台，利用Java语言、MySQL数据库，结合目前流行的 B/S架构，将短视频流量数据分析与可视化管理的各个方面都集中到数据库中，以便于用户的需要。在确保系统稳定的前提下，能够实现多功能模块的设计和应用。该系统由管理员功能模块和用户模块组成。不同角色的准入制度是有严格区别的。各功能模块的设计也便于以后的系统升级和维护。该系统采用了软件组件化、精化体系结构、分离逻辑和数据等方法。
关键字：Java技术；短视频流量数据分析与可视化；Hadoop；B/S结构
二、系统设计 系统功能结构图
三、系统功能设计 系统功能模块 当人们打开系统的网址后，首先看到的就是首页界面。在这里，人们能够看到短视频流量数据分析与可视化系统的导航条，通过导航条进入各功能信息展示页面进行操作。系统首页界面如图5-1所示：
图5-1 系统首页界面
管理员功能模块实现 管理员登录，在登录页面正确输入用户名和密码后，点击登录进入操作系统进行操作；如图5-5所示。
图5-5 管理员登录界面
四、数据库设计 番剧信息实体属性图如下图4-4所示。
图4-4番剧信息实体属性图
数据库表的设计，如下表：
token表
字段名称
类型
长度
字段说明
主键
默认值
id
bigint
主键
主键
userid
bigint
用户id
username
varchar
100
用户名
tablename
varchar
100
表名
role
varchar
100
角色
token
varchar
200
密码
addtime
timestamp
新增时间
CURRENT_TIMESTAMP
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da94ae7586ed7109e15c0c2c611eba32/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/14/">«</a>
	<span class="pagination__item pagination__item--current">15/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/16/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>