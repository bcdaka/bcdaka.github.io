<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b155ca303fc651b82f9c58ed6d121de/" rel="bookmark">
			网络服务器都包含哪些方面需要维护？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络服务器是现代互联网架构中不可或缺的一部分，它们承载着数据存储、处理和传输的重要任务。为了确保服务器能够稳定、高效地运行，定期的维护工作显得尤为重要。下面将介绍一些常见的网络服务器维护方法：
定期更新软件和系统
保持操作系统和应用软件的最新状态是维护服务器安全的基础措施之一。这包括安装安全补丁、升级软件版本以及更新系统内核等。通过这种方式，可以减少因软件漏洞而引发的安全风险。
监控系统性能
利用各种监控工具来跟踪服务器的CPU使用率、内存占用、磁盘空间和网络流量等关键指标。及时发现并解决性能瓶颈，可以防止服务器过载导致的服务中断。
定期备份数据
数据是服务器上最宝贵的资源，因此需要定期进行备份。备份策略可以是全量备份或增量备份，并且应该在多个地理位置存储备份副本以防灾难发生。
检查和优化硬件
对服务器硬件进行检查，确保所有组件都处于良好状态。这包括清理内部灰尘、检查散热系统、测试电源供应和确认冗余硬件（如RAID磁盘阵列）的正常运作。
安全管理
强化服务器的安全设置，包括配置防火墙规则、禁用不必要的服务、管理好用户权限和密码策略。同时，应定期进行安全审计，以识别潜在的安全隐患。
日志管理
合理配置和管理服务器日志可以帮助管理员追踪异常活动和故障原因。应定期审查日志文件，及时清理旧日志以释放存储空间，并确保日志中包含有用的信息。
能源管理
对于物理服务器来说，合理的能源管理不仅能降低运营成本，还能延长硬件寿命。这包括优化数据中心的冷却系统、使用节能设备和实施智能电源管理方案。
灾难恢复计划
制定和测试灾难恢复计划，以确保在发生严重故障时能快速恢复服务。这通常涉及备用服务器的配置、故障切换演练和恢复流程的明确指导。
通过上述方法的实施，可以显著提升网络服务器的稳定性和安全性，保障关键业务的连续性。维护工作虽然耗时且有时显得繁琐，但对于整个IT基础设施的健康运行至关重要。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bde2c6fe928082b44b692d9463d65028/" rel="bookmark">
			【初阶数据结构】1.算法复杂度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.数据结构前言1.1 数据结构1.2 算法1.3 如何学好数据结构和算法 2.算法效率2.1 复杂度的概念2.2 复杂度的重要性 3.时间复杂度3.1 大O的渐进表示法3.2 时间复杂度计算示例3.2.1 示例13.2.2 示例23.2.3 示例33.2.4 示例43.2.5 示例53.2.6 示例63.2.7 示例7 4.空间复杂度4.1 空间复杂度计算示例4.1.1 示例14.1.2 示例2 5.常见复杂度对比6.复杂度算法题6.1 旋转数组 1.数据结构前言 1.1 数据结构 数据结构(Data Structure)是计算机存储、组织数据的方式，指相互之间存在一种或多种特定关系的数据元素的集合。没有一种单一的数据结构对所有用途都有用，所以我们要学各式各样的数据结构。
如：线性表、树、图、哈希等
1.2 算法 算法(Algorithm):就是定义良好的计算过程，他取一个或一组的值为输入，并产生出一个或一组值作为输出。简单来说算法就是一系列的计算步骤，用来将输入数据转化成输出结果。
1.3 如何学好数据结构和算法 秘诀1：
死磕代码！！！
秘诀2：
画图画图画图+思考
2.算法效率 例题：
力扣189.轮转数组：
给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。
void rotate(int* nums, int numsSize, int k) { while(k--) { int end = nums[numsSize-1]; for(int i = numsSize - 1;i &gt; 0 ;i--) { nums[i] = nums[i-1]; } nums[0] = end; } } 这个算法是没有问题的，但是在力扣运行会报错，显示超过时间限制。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bde2c6fe928082b44b692d9463d65028/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fd2c0c047960b1b9d929c048d34545a/" rel="bookmark">
			【微服务】Spring Cloud中如何使用Eureka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 强烈推荐引言主要功能Eureka 的架构使用示例Eureka Server 配置Eureka Client 配置示例服务服务发现调用示例 Spring Cloud如何实现服务的注册?1. 搭建 Eureka 服务注册中心2. 配置服务注册到 Eureka3. 验证服务注册 总结应用场景1. 动态服务发现2. 负载均衡3. 服务治理4. 服务调用5. 灰度发布和蓝绿部署6. 多数据中心支持 强烈推荐专栏集锦写在最后 强烈推荐 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站:人工智能
引言 Eureka 是 Netflix 开源的一个服务发现组件，它在微服务架构中扮演着重要的角色。
Eureka 主要分为 Eureka Server 和 Eureka Client 两部分。
Eureka Server 作为服务注册中心，维护所有可用服务实例的信息。Eureka Client 作为服务提供者或消费者，负责向 Eureka Server 注册服务和获取其他服务的位置信息。
主要功能 服务注册：
服务提供者在启动时，会将自己的信息（如 IP 地址、端口、服务名称等）注册到 Eureka Server 上。
服务发现：
服务消费者从 Eureka Server 获取可用服务实例列表，并根据负载均衡策略调用具体的服务实例。
故障检测：
Eureka 定期发送心跳检测服务实例的健康状况。如果某个服务实例未能按时响应心跳，Eureka 会将其标记为不可用。
动态扩展：
Eureka 支持动态扩展和缩减服务实例。当服务实例上线或下线时，Eureka Server 会自动更新服务实例列表。
Eureka 的架构 Eureka Server：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fd2c0c047960b1b9d929c048d34545a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2effef30e746d4f2c54a8e33abec33de/" rel="bookmark">
			如何实现前端实时通信：WebSocket与Socket.io详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何实现前端实时通信：WebSocket与Socket.io详解 引言WebSocket：基础概念与作用实现步骤示例一：WebSocket客户端 Socket.io：增强的实时通信框架实现步骤示例二：Socket.io客户端 使用技巧与最佳实践结合实战经验结语 引言 在当今的互联网时代，实时通信已成为许多Web应用的核心功能之一。从在线聊天到实时游戏，从股票交易到协同编辑文档，实时通信技术为用户提供了即时互动的体验。在众多实时通信解决方案中，WebSocket 和 Socket.io 是最常被提及的两个技术。本文将深入探讨这两种技术的基本概念、实现细节及实际应用场景，旨在帮助前端开发者掌握前端实时通信的关键技能。
WebSocket：基础概念与作用 WebSocket 协议提供了一个全双工通信通道，在客户端和服务器之间建立一个持久连接，允许双方发送和接收数据。它基于TCP协议，通过HTTP握手建立连接，之后可以发送任意类型的数据（文本或二进制）。与传统的HTTP请求响应模型相比，WebSocket 提供了更高效的双向通信能力，大大减少了延迟并提高了数据传输效率。
实现步骤 创建WebSocket实例：
const socket = new WebSocket('ws://example.com/socket'); 监听事件：
open：连接成功时触发。message：接收到服务器消息时触发。error：发生错误时触发。close：连接关闭时触发。 socket.addEventListener('open', (event) =&gt; { console.log('Connection opened:', event); }); socket.addEventListener('message', (event) =&gt; { console.log('Received message:', event.data); }); socket.addEventListener('error', (event) =&gt; { console.log('Error occurred:', event); }); socket.addEventListener('close', (event) =&gt; { console.log('Connection closed:', event); }); 发送数据：
socket.send('Hello Server!'); 关闭连接：
socket.close(); 示例一：WebSocket客户端 const socket = new WebSocket('ws://localhost:8080'); socket.addEventListener('open', (event) =&gt; { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2effef30e746d4f2c54a8e33abec33de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a995a487b4437714a1d0e959814caaf/" rel="bookmark">
			相见恨晚的《新程序员》 AI 专辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明：本文并不什么“软文”，是我的真实感受分享。本人和《新程序员》无任何利益关系，读者购买专栏我不会获得任何分成。
一、前言 前不久有位朋友送我一本 CSDN 出品的 《新程序员 006：人工智能新十年》 的杂志。
说实话，虽然我经常在 CDSN 上写作，但并没听说 CSDN 有高质量的 AI 方面的内容；我自己也很久没读过技术类杂志了，印象中计算机类杂志要么偏理论化，要么着重于讲技术细节，相对枯燥乏味。因此对这份杂志并没抱很大期待。收到后杂志放了几天，没拆。
但，既然朋友推荐，而且是人工智能相关的内容，自己也非常感兴趣，上周末正好有时间，不妨拆看看讲的啥。
阅读几篇之后，发现和想象的完全不一样。杂志中有很多国内外 AI 领域专家的经验分享，质量非常高，有些内容有强烈共鸣，很多困惑也被解答了，颇为激动。
很多访谈的话题也是自己非常感兴趣的最近一直在思考的问题：
对话凯文凯利：AI 会取代人的 90% 技能，并放大剩余 10%人类与大模型应该双向奔赴CSDN 创始人蒋涛：现在就是成为“新程序员”的黄金时刻对话李彦宏：大模型 + AIGC 引领人工智能的下一个十年确定性和非确定性：GPT 时代的新编程范式ChatGPT 标志着 AI 进入了 iPhone 时刻AI 大模型时代，应用开发机会比移动互联网大十倍中国有机会做出赶超 ChatGPT 的 AI 吗？深度剖析 ChatGPT 类大模型的关键技术ChatGPT 类大模型为什么会带来“神奇”的涌现能力ChatGPT 还没到到“基础模型”的状态，国产大模型的“速胜论”不靠谱AI 编程： 边界在哪里腾讯混元 AI 大模型是如何训练的大语言模型时代的代码生成通用人工智能下的应用颠覆… 杂志中的很多访谈类的文章比单纯讨论某个技术（基础常识类或AI应用经验类的除外）对我来说更有价值。一个是能学到新的东西、一个是能产生共鸣 、一个是解答心里的困惑 。
读过几篇后发现收获很大，突然想到，既然是杂志是不是还有 AI 相关的其他期呢？搜了一下，果然还有《新程序员 007：大模型时代的开发者》，由于我工作也是在做 AI 的业务应用， 007 说的“大模型时代的开发者” 不正是我嘛！当即果断下单。
里面也讲了很多 AI 时代大家比较关心的问题：
以史为鉴，人工智能技术的过去、现在和未来对话图灵奖获得者 Joseph Sifakis: 大模型会毁掉初级程序员九问中国大模型掌门人，万字长文详解大模型进度趋势蒋涛对话李大海：AGI 革命是第四次重大技术变革，大模型 + Agent 创造无限想象空间对话智谱 AI CEO 张鹏：大模型原生应用将成为生成式 AI 是否会破灭的关键人工智能对齐问题大语言模型中的语言和知识分离现象我患上了AI 焦虑症AI 消灭软件工程师？GPT 时代的程序员生存之道大模型时代 ，开发者的成长指南Copilot 时代，开发者与 AI 如何相处？大模型在研发效率提升方向的应用实践… 尤其是读到《我患上了 AI 焦虑症》 ，产生强烈共鸣，相见恨晚。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a995a487b4437714a1d0e959814caaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a59f0d765f8ff1820acf5323af4a9135/" rel="bookmark">
			List、Map、Set 接口在Java中的存取元素特点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		List、Map、Set 接口在Java中的存取元素特点 1、List 接口2、Map 接口3、Set 接口4、总结 💖The Begin💖点点关注，收藏不迷路💖 在Java中，List、Map和Set是三个最常用的集合接口。它们各自有不同的特点和用途，使得在处理数据集合时能够灵活选择最适合的数据结构。下面我们将详细探讨这三个接口在存取元素时的特点。
1、List 接口 特点：
有序性：List中的元素是有序的，按照插入顺序排列。可重复性：List允许存储重复的元素。索引访问：可以通过索引（位置）来访问和修改List中的元素。 常见实现类：
ArrayList：基于动态数组实现，适合随机访问，插入和删除效率较低。LinkedList：基于双向链表实现，插入和删除操作效率高，但查询效率较低。 示例：
List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("Apple"); list.add("Banana"); list.add("Apple"); // 重复添加 System.out.println(list.get(1)); // 输出 "Banana"，通过索引访问元素 2、Map 接口 特点：
键值对存储：Map以键值对（key-value）的形式存储数据，每个键唯一，值可以重复。无序性：Map中的键值对没有顺序，不保证顺序性。键的唯一性：Map中的键是唯一的，每个键最多映射到一个值。 常见实现类：
HashMap：基于哈希表实现，查找效率高，无固定顺序。TreeMap：基于红黑树实现，按键的自然顺序或自定义顺序进行排序。LinkedHashMap：继承自HashMap，使用双向链表维护插入顺序或访问顺序。 示例：
Set&lt;String&gt; set = new HashSet&lt;&gt;(); set.add("Apple"); set.add("Banana"); set.add("Apple"); // 重复添加，不会成功 System.out.println(set); // 输出类似 "[Apple, Banana]"，但顺序可能不同 3、Set 接口 特点：
元素唯一性：Set中的元素是唯一的，不允许重复。无序性：Set中的元素没有顺序，不保证顺序性。不能通过索引访问：不能通过索引来访问和修改Set中的元素。 常见实现类：
HashSet：基于哈希表实现，查找效率高，无固定顺序。TreeSet：基于红黑树实现，按元素的自然顺序或自定义顺序进行排序。LinkedHashSet：继承自HashSet，使用双向链表维护插入顺序或访问顺序。 示例：
Set&lt;String&gt; set = new HashSet&lt;&gt;(); set.add("Apple"); set.add("Banana"); set.add("Apple"); // 重复添加，不会成功 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a59f0d765f8ff1820acf5323af4a9135/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/671a5c582376497b552ce0fe3c3e178f/" rel="bookmark">
			在亚马逊云科技AWS上利用SageMaker机器学习模型平台搭建生成式AI应用（附Llama大模型部署和测试代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目简介： 接下来，小李哥将会每天介绍一个基于亚马逊云科技AWS云计算平台的全球前沿AI技术解决方案，帮助大家快速了解国际上最热门的云计算平台亚马逊云科技AWS AI最佳实践，并应用到自己的日常工作里。本次介绍的是如何在Amazon SageMaker上使用大语言模型Meta Llama 7B，提供可扩展和安全的AI解决方案。通过Amazon API Gateway和AWS Lambda将应用程序与AI模型集成。本方案的解决方案架构图如下：
本方案将主要使用亚马逊云科技AWS上的大模型/机器学习模型托管服务Amazon SageMaker，下面我们介绍一下该服务。
什么是Amazon SageMaker？ Amazon SageMaker是一款由亚马逊云科技提供的全面模型托管服务，旨在帮助开发者和数据科学家快速、轻松地构建、训练和部署机器学习模型。SageMaker原生集成了机器行业热门的工具和框架，使用户能够专注于模型的开发和优化，而无需担心基础设施的管理。
通过SageMaker，用户可以使用预构建的算法和框架，或者将自己的自定义代码带入平台进行训练。其自动化的数据处理和模型训练功能，可以大大减少模型开发的时间和复杂性。此外，SageMaker还提供了云托管Jupyter Notebook，用户可以使用本地熟悉的训练模型工具，以便无缝从本地迁移到云端模型训练。
在模型训练完成后，SageMaker可以将模型部署为托管的推理服务，配置API节点，确保高可用性和可扩展性。借助SageMaker，用户可以无缝地集成机器学习模型到应用程序中，例如通过API Gateway和AWS Lambda来实现实时推理服务。
Amazon SageMaker还具备内置的监控和调优功能，使得模型的性能优化和管理更加高效。无论是初学者还是专业数据科学家，SageMaker都是一种理想的解决方案，帮助企业快速实现人工智能和机器学习的价值。
本方案包括的内容： 本方案主要包括如下内容：
1. 使用Amazon SageMaker部署基础AI/ML模型(Meta Llama 7B)作为推理的应用节点
2. 在云原生代码托管服务AWS Lambda部署代码以调用SageMaker推理。
3. 使用测试应用程序为已部署的模型进行功能测试。
项目搭建具体步骤： 下面跟着小李哥手把手搭建一个亚马逊云科技AWS上的生成式AI模型（Meta Llama 7B）的软件应用，并且测试大模型的多种应用场景下的表现。
1. 首先进入SageMarker
2. 点击进入Jumpstart-&gt;Foundation Models，查看目前SageMaker上现有的开源ML模型
3. 进入Studio，点击已经创建好的“Open Studio”
4. 点击“Studio Classic”，再点击右侧Open
5. 打开SageMaker Studio控制台
6. 下载存放在S3中的ML模型工程代码：
aws s3 sync s3://&lt;Replace with lab-code bucket name&gt; . 7. 配置ML模型训练、预测的Python工程环境
8. 在第一个代码单元中更新和安装SageMaker SDK
!pip install sagemaker --quiet --upgrade --force-reinstall 9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/671a5c582376497b552ce0fe3c3e178f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd5fa945194063d4a498583f3cf109c5/" rel="bookmark">
			RabbitMQ定义的MQ多个consumer重复消费同一条消息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RabbitMQ定义的MQ多个consumer重复消费同一条消息 @author:shengfq
@date:2024-07-09
@category: 数据一致性
@title:RabbitMQ定义的MQ多个consumer重复消费同一条消息
系统环境 direct类型的Exchange,通过routingKey:START/CONFORM绑定到业务队列Queue: START queue.xxx.qm.operationStart 工序开工质量监听队列 CONFORM queue.xxx.qm.operationEnd 工序完工质量监听队列 由于有多个qm服务实例,都监听了上述的queue,所以就有多个consumer. 问题描述 【2010工厂，生产环境，订单数据】 订单号 880006861916 订单状态 130-在制 订单类型 ZF01-成品订单 物料编码 130901000711B 同一个订单同一个工序生成了2个任务（检验计划里面也只有一个工序的检验规格呢） [图片] TKE日志如下,基本上通过requestId可以判断是同一条消息被多个consumer消费了.
2024-07-05 10:41:10projectitrcp20220217183240276namespacekhoros-mom-prodpodmom-service-qm-9a049-7665f4899b-62sxdpathstdoutlog_data2024-07-05 10:41:10.765 [TID: N/A] WARN [-,,,] 1 --- [Executor-128574] c.s.m.q.t.s.h.OperationStartReceiver : OperationStartReceiver msg：{"oprName":"打胶-玻璃装配","scrappedQuantity":0,"materialNo":"130901000711B","wipOrderNo":"880006861916","oprSequenceNo":"0041","goodQuantity":0,"operationWorkStationName":"打胶-玻璃装配","standOprName":"人工组装","wipOrderOperationId":596309434920902660,"requestId":"2b7eaabea93843dcb9bf6838f8da1ca3","workCenterId":579597295600041993,"progressStatus":130,"facilityCode":"2010","facilityId":571301815799623680,"operationWorkStationCode":"2010JS01A0002","completeSystem":"IMOM","operationWorkStationId":579600364052193290,"orderPlanQuantity":1,"materialId":575618864008929280,"creationDate":1720147195174,"workCenterCode":"303910","wipOrderId":596309434912514048,"createdBy":39020,"workType":0,"tenantId":2,"operationType":"START","standSequenceNo":"ZP00009","oprSerialNo":"000000"} UserDetails：CustomUserDetails{userId=39020, username=hecf6, realName='何超锋', email='null', timeZone='null', language='zh_CN', roleId=null, roleIds=null, siteRoleIds=null, tenantRoleIds=null, roleMergeFlag=null, tenantId=2, tenantNum='null', tenantIds=null, imageUrl='null', organizationId=2, isAdmin=null, clientId=null, clientName='null', clientAuthorizedGrantTypes=null, clientResourceIds=null, clientScope=null, clientRegisteredRedirectUri=null, clientAccessTokenValiditySeconds=null, clientRefreshTokenValiditySeconds=null, clientAutoApproveScopes=null, additionInfo={"facility_ids":"571301815799623680","employee_no":"80033656","account_no":"hecf6","facility_name":"2010-华湘工厂","facility_no":"2010","facility_id":"571301815799623680","phone_number":"15062676297","domain_account":"hecf6"}, apiEncryptFlag=null, apiReplayFlag=null, menuIdFlag=null, roleLabels='null} 2024-07-05 10:41:10projectitrcp20220217183240276namespacekhoros-mom-prodpodmom-service-qm-9a049-7665f4899b-62sxdpathstdoutlog_data2024-07-05 10:41:10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd5fa945194063d4a498583f3cf109c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e21363d5da8adfa3a7048c1a8633246/" rel="bookmark">
			Java项目：基于SSM框架实现的中小型企业财务管理系统【ssm&#43;B/S架构&#43;源码&#43;数据库&#43;答辩PPT&#43;开题报告&#43;毕业论文】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、项目简介 本项目是一套基于SSM框架实现的中小型企业财务管理系统
包含：项目源码、数据库脚本等，该项目附带全部源码可作为毕设使用。
项目都经过严格调试，eclipse或者idea 确保可以运行！
该系统功能完善、界面美观、操作简单、功能齐全、管理便捷，具有很高的实际应用价值
二、技术实现 jdk版本：1.8 及以上
ide工具：IDEA或者eclipse
数据库: mysql5.7
后端：spring+springmvc+mybatis+maven+mysql
前端：jsp，css，jquery
三、系统功能 系统用户包括有管理员、用户
主要功能如下：
用户登录
用户注册
首页
个人中心
修改密码
个人信息
职工管理
管理员信息
薪资管理
资产管理
经营管理
部门管理
资产类别管理
资产报表统计
经营报表统计等功能
四、页面 五、文档 六、数据库 七、源码地址 https://download.csdn.net/download/weixin_43860634/89528583
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8f4ffb081f5e248cca76983b75b5646/" rel="bookmark">
			Java项目：基于SSM框架实现的农家乐信息管理平台含前后台【ssm&#43;B/S架构&#43;源码&#43;数据库&#43;答辩PPT&#43;开题报告&#43;毕业论文】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、项目简介 本项目是一套基于SSM框架实现的农家乐信息管理平台
包含：项目源码、数据库脚本等，该项目附带全部源码可作为毕设使用。
项目都经过严格调试，eclipse或者idea 确保可以运行！
该系统功能完善、界面美观、操作简单、功能齐全、管理便捷，具有很高的实际应用价值
二、技术实现 jdk版本：1.8 及以上
ide工具：IDEA或者eclipse
数据库: mysql5.7
后端：spring+springmvc+mybatis+maven+mysql
前端：vue，css，js
三、系统功能 系统用户包括有管理员、用户
前台主要功能如下：
用户登录
用户注册
周边住宿
景点信息
周边餐饮
农作物
农家乐活动
旅游咨询
预订
点我收藏
评论
支付
余额充值
退款
客服
个人中心
我的订单
我的地址
我的收藏等功能
后台主要功能如下：
用户登录
用户注册
首页
个人中心
修改密码
个人信息
用户管理
周边住宿管理
房子类型管理
景点信息管理
周边餐饮管理
农作物类型管理
门票购买管理
餐饮类型管理
住宿预订管理
农作物管理
农家乐活动管理
系统管理
订单管理
四、页面 五、文档 六、数据库 七、源码地址 https://download.csdn.net/download/weixin_43860634/89528475
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ec05b694d70522212f287adc05b2823/" rel="bookmark">
			Jvm 垃圾回收算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在现代编程语言中，垃圾回收（Garbage Collection, GC）是一种自动内存管理的形式，它的任务是回收程序不再使用的内存。垃圾回收算法的设计和实现对于提高程序性能、防止内存泄露和降低开发者负担至关重要。本文将介绍四种主要的垃圾回收算法：标记-清除算法、复制算法、标记-整理算法以及分代收集算法。
1. 标记-清除算法（Mark-Sweep） 标记-清除是最古老的垃圾回收算法之一，它分为两个主要阶段：标记和清除。
标记阶段：从根集合（通常是全局变量和活动的函数调用栈）开始，遍历所有可达的对象，并标记所有存活的对象。清除阶段：遍历堆中的所有对象，回收未标记的对象占用的内存。 优点：
简单易于实现。不需要移动对象。 缺点：
执行效率较低，特别是当存活对象较多时。造成内存碎片，可能导致大对象难以找到连续的空间。 2. 复制算法（Copying） 复制算法将可用内存划分为两个半区。垃圾回收时，它将从一个半区中的活动对象复制到另一个半区，然后清除原半区中的所有对象。
复制阶段：从根集合开始，标记所有可达的对象，并将它们复制到另一个半区。清除阶段：清空原来存放对象的半区。 优点：
消除了内存碎片，因为复制时对象被紧密排列。复制存活对象通常比标记和清除所有对象更快。 缺点：
空间成本高，因为任何时候只有一半的内存是可用的。对象复制操作可能导致额外的运行时间开销。 3. 标记-整理算法（Mark-Compact） 标记-整理算法结合了标记-清除算法和复制算法的优点，通过移动活动对象来避免内存碎片，同时不需要将内存分成两半。
标记阶段：与标记-清除算法相同，标记所有可达的对象。整理阶段：将所有存活的对象压缩到堆的一端，然后清理掉剩余的空间。 优点：
解决了内存碎片问题，提高了内存的利用率。不需要复制算法中的一半内存开销。 缺点：
实现复杂性较高。移动对象可能导致更高的延迟。 4. 分代收集算法（Generational Collection） 分代收集算法是基于对象存活时间的统计特性。它将对象分为几代，通常为新生代和老年代。
新生代：包含新创建的对象。因为大多数新对象很快变得不可达，新生代使用复制算法进行高效回收。老年代：包含经过多次回收依然存活的对象。老年代的回收频率较低，通常使用标记-清除或标记-整理算法。 优点：
高效处理大量短命对象。通过频繁回收新生代来减少全堆回收的需要，从而减少停顿时间。 缺点：
需要更复杂的垃圾回收器设计。分代间的对象引用需要额外的处理。 总结 垃圾回收算法的选择和实现对于确保应用程序性能和可靠性至关重要。不同的算法各有优势和适用场景，现代的垃圾回收器往往结合使用多种技术，以达到最优的回收效率和最小的延迟。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5700f4c7c904e3b4f30ad2db1c38fc71/" rel="bookmark">
			【前端速通系列|第二篇】Vue3前置知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.前言2.包管理工具npm2.1下载node.js2.2配置 npm 镜像源2.3 npm 常用命令 3.Vite构建工具4.Vue3组件化5.Vue3运行原理 1.前言 本系列文章旨在帮助大家快速上手前端开发。
2.包管理工具npm npm 是 node.js中进行 包管理 的工具. 类似于Java中的Maven。
2.1下载node.js 因此要想使用npm,首先要下载node.js。
node.js下载地址: https://nodejs.org/zh-cn
node -v 查看node.js版本npm -v 查看npm版本 2.2配置 npm 镜像源 npm镜像源指的是npm包管理器所使用的替代性服务器，用于下载和安装npm包。由于npm的官方源服务器位于美国，对于中国或其它网络条件不佳的地区的用户来说，直接从官方源下载可能会非常缓慢。为了提高下载速度，一些组织和个人提供了npm的镜像源，这些镜像源定期与官方源同步，以提供相同的服务但更快的下载速度。
以阿里云镜像源举例:
npm config set registry https://registry.npmmirror.com #设置国内阿里云镜像源 npm config get registry #查看镜像源 2.3 npm 常用命令 npm init： 项目初始化；
npm init -y：默认一路yes，不用挨个输入信息 npm install 包名：安装js包到项目中（仅当前项目有效）。指定 包名，或者 包名@版本号
npm install -g： 全局安装，所有都能用可以去 npm仓库 搜索第三方库 npm update 包名：升级包到最新版本
npm uninstall 包名：卸载包
npm run：项目运行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5700f4c7c904e3b4f30ad2db1c38fc71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cddaa2bd8ec367c604f24b02c92c03cb/" rel="bookmark">
			idea集成本地tomcat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于网课老师使用的是eclipse,但是……本人用的是idea,所以不得不去找教程。
解决方案1：
https://blog.csdn.net/weixin_54048131/article/details/131359793
这个地方，路径一定要到这个tomcat 否则不识别：
这里的JRE也要配置一下
新问题：
解决方案2：
https://blog.csdn.net/weixin_45681435/article/details/116310341
照着操作一通，应该是运行成功了。
感慨：
写代码，真的是不断遇到问题，不断地查啊查啊，去解决问题。
越快找到问题，越解决的快。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a46b0cf8a6f34dc2510489f0a94a5f6a/" rel="bookmark">
			Consul与CoreDNS的对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Consul与CoreDNS的对比 最近在做服务注册与发现方案的选择，由于是在K8S上解决服务发现与注册，所以第一想到的就是K8S的CoreDNS，然后再想到的就是SpringCloud那一套中的Consul。
下面是我对这两者的思考与选择，欢迎大家一起讨论或者大佬给出意见。
一、CoreDNS简介 CoreDNS官网：https://coredns.io/
CoreDNS是一个DNS（域名解析）服务器，以插件的形式被提供。
可以处理服务发现。
在K8S中安装了CoreDNS后，每个服务就可以使用域名的方式调用其他服务。
感觉CoreDNS的优点就是专一、简单，适合规模比较小的微服务集群。
CoreDNS是使用Go语言开发的。
二、Consul简介 Consul官网：https://www.consul.io/
Consul是一个服务网络解决方案，主要解决的问题是知道服务在哪儿运行、如何守护服务间交流的安全、如何自动化网络任务的路由、如何控制对于环境的访问。
Consul作为SpringCloud中服务发现解决方案，它对于服务发现是一个完整的解决方案，而且它提供了心跳检测等能力，还有UI界面方便使用。
Consul是使用Go语言开发的。
三、总结与选择 下面是对于两者的优劣势总结。
方案优点缺点CoreDNS1、直接使用域名解析做服务发现，通过服务名就可以调用到服务，简单易用
2、直接使用K8S的插件安装CoreDNS，容易安装1、没有服务管理功能。
2、也没有相应的UI页面。Consul1、完整的服务注册与发现方案。
2、具有UI界面，可以管理微服务。1、Consul是一个服务网络解决方案，只是用到了其中的一部分功能，相对CoreDNS来说有点复杂和臃肿。 我想找的是一个完整的服务发现解决方案，而且需要可视化的界面方便管理微服务，因此选择Consul是比较正确的选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af3dd5fb80402590d6fb6018999e31be/" rel="bookmark">
			[Spring] SpringBoot基本配置与快速上手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌸个人主页:https://blog.csdn.net/2301_80050796?spm=1000.2115.3001.5343
🏵️热门专栏:
🧊 Java基本语法(97平均质量分)https://blog.csdn.net/2301_80050796/category_12615970.html?spm=1001.2014.3001.5482
🍕 Collection与数据结构 (92平均质量分)https://blog.csdn.net/2301_80050796/category_12621348.html?spm=1001.2014.3001.5482
🧀Java EE(96平均质量分) https://blog.csdn.net/2301_80050796/category_12643370.html?spm=1001.2014.3001.5482
🍭MySql数据库(93平均质量分)https://blog.csdn.net/2301_80050796/category_12629890.html?spm=1001.2014.3001.5482
🍬算法(97平均质量分)https://blog.csdn.net/2301_80050796/category_12676091.html?spm=1001.2014.3001.5482
感谢点赞与关注~~~
🍃 从今天开始,Spring板块正式开始更新,欢迎订阅~~
目录 1. 环境准备2. Maven2.1 什么是Maven2.2 创建一个Maven项目2.3 Maven的核心功能2.3.1 项目构建2.3.2 依赖管理 2.4 Maven Help插件2.5 Maven仓库2.5.1 坐标2.5.2 仓库 2.6 为Maven设置国内源 3. 第一个SpringBoot程序3.1 什么是SpringBoot3.2 创建SpringBoot项目(以专业版为例)3.3 项目代码与目录介绍3.3.1 项目目录3.3.2 pom文件 3.4 通过SpringBoot项目输出Hello World3.5 SpringBoot内置的Web服务器 1. 环境准备 社区版: 2021.1-2022.1.4
专业版:无要求
这里推荐大家在某东或者某宝上去找一个专业版的破解器,社区版在后期配置maven插件的时候可能会出现卡死的情况.而专业版就不会.
如果自己电脑上的社区版idea不在这个范围中,就要卸载重新安装.具体步骤可参考:
如何彻底卸载idea
在卸载idea的时候,注意一定不要忘记把注册表和残留的文件也一起卸载.
2. Maven 2.1 什么是Maven Maven是一个项目管理工具.Maven可以通过一小段描述信息来管理项目构建,报告和文档的项目管理工具软件.
比如在我们前期学习mysql的时候,我们要想通过idea实现jdbc编程,我们就必须去中央仓库中下载mysql与idea的连接驱动程序,这样才可以通过mysql提供的API接入idea的jdbcAPI以便操作数据库.这个文件的格式是.jar文件的格式,但是我们现在有了Maven,我们就没有必要在去中央仓库去下载这个.jar文件了,我们可以直接在pom.xml文件中配置获取jar包,而不是手动添加.
2.2 创建一个Maven项目 注:这里展现的是专业版界面
在创建java项目中,构建系统一栏选择Maven即可.
2.3 Maven的核心功能 主要体现在两个方面:
构建项目管理依赖 2.3.1 项目构建 当我们开发了一个项目之后,代码需要经过编译,测试,打包等流程,每次代码的修改都需要经过这些流程,如果反复进行调试修改,这个流程就要反复进行,就非常麻烦,而Maven给我们提供了一套简单的命令来完成项目的构建.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af3dd5fb80402590d6fb6018999e31be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f30cb44d449e938a27f4225c28aaceb/" rel="bookmark">
			Hive/Spark窗口函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		窗口函数 hive文档链接
spark文档链接
1. OVER支持的函数 自然序编号
Syntax: ROW_NUMBER按等级编号
Syntax: RANK | DENSE_RANK | PERCENT_RANK分组内分桶，并返回对应桶的序号
Syntax: NTILE(n)Analytic Functions（分析函数）
Syntax: CUME_DIST | LAG | LEAD | NTH_VALUE | FIRST_VALUE | LAST_VALUEAggregate Functions（聚合函数）
Syntax: MAX | MIN | COUNT | SUM | AVG | … 1.1. 准备工作 创建测试表并插入测试数据
CREATE TABLE employees (name STRING, dept STRING, salary INT, age INT); INSERT INTO employees VALUES ("Lisa", "Sales", 10000, 35) ,("Evan", "Sales", 32000, 38) ,("Fred", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f30cb44d449e938a27f4225c28aaceb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b9883810e5ab95277fa3611f84bc945/" rel="bookmark">
			Kafka 典型问题与排查以及相关优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kafka 是一个高吞吐量的分布式消息系统，但在实际应用中，用户经常会遇到一些性能问题和消息堆积的问题。本文将介绍 Kafka 中一些典型问题的原因和排查方法，帮助用户解决问题并优化 Kafka 集群的性能。
一、Topic 消息发送慢，并发性能低 问题描述：
某个或某几个 Topic 的消息并发发送性能低，具体表现为 Producer 的平均请求延迟大，平均生产吞吐量低。
可能原因：
网络带宽不足，导致 IO 等待时间长。消息未压缩，导致网络流量超负荷。消息未批量发送或批量阈值配置不当，导致发送速率慢。Topic 分区数量不足，导致 Broker 接收消息积压。Broker 磁盘性能低，导致磁盘同步慢。Broker 分区总量过多，导致碎片化，磁盘读写过载。 排查方法： 1、确认网络带宽：
检查 Producer 的平均 IO 等待时间指标，判断 Producer 到 Broker 之间的网络带宽是否满足业务的流量要求。
在一个节点上作为服务器启动 iperf iperf -s 在另一个节点上作为客户端测试网络带宽 iperf -c 192.168.10.21 2、确认消息压缩：
检查 Producer 的平均压缩率指标，确保压缩率符合预期。
在 Producer 配置中启用消息压缩 compression.type=gzip 3、消息未批量发送或批量阈值配置不当
检查 Producer 的批量发送配置 batch.size 和 linger.ms。
操作命令： 查看 Producer 配置文件或代码，确认 batch.size 和 linger.ms 设置。
优化方法： 调整 Producer 配置，增大批量发送大小和延迟时间：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b9883810e5ab95277fa3611f84bc945/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55f331f2c53e93d9a6a5d6adff8d54a2/" rel="bookmark">
			服务器为什么大多用 Linux？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个事，IIS（微软的 Web Server）至少要负一大半责任。
首先，大家不要去按照现在Linux的情况跟Windows比。
很多东西在发展过程中就是一种生态强弱的比较。在那个关键的时间点，你的生态强，大家都用你，那么你就统治了行业。
然后回头再看，当时很重要的那个业务或者特性，后面已经不存在了。但统治地位建立了，就很难逆转了。
就像安卓当年的一大优势就是允许刷机，对安卓的促进还是挺大的，但现在厂商都开始禁止 root 和 bootloader 解锁了。
Linux 统治服务器端，完全是 Linux 的WebServer打败 Windows 的 WebServer 的过程。
在大概 2000 年的时候，Windows 的 WebServer 其实还是有一定优势的。
自带 FTP 功能。ASP 动态网页不需要额外部署软件。（当时 ASP 还是挺好用的一种开发语言）有图形界面来做配置，适合小白管理员。 但很快，Windows 太封闭的问题，就开始有很大影响了。
IIS 在 apache + nginx + lighttpd 面前，被打得毫无还手之力。
首先是对 php、ruby 等越来越多的开发语言，支持太差。
IIS 过度绑定asp.net，其他开发语言在上边部署经常出现各种各样的幺蛾子。
2005 年前后那会，正是各种开发语言井喷的时间，大家对 apache 的兼容性，都要好于对 IIS 的兼容性。
IIS 搞那一大堆权限、运行生命周期啥的，让很多语言的 runtime 难以适从。
其次是，IIS 的性能被 nginx 和 lighttpd 吊打了。
这两个基于 poll 和 epoll 的项目，因为项目特别轻量，所以性能上往往能够拿出 IIS 几倍的并发能力来。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55f331f2c53e93d9a6a5d6adff8d54a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a170ec337a0f946b3a474bf9bad72e5/" rel="bookmark">
			stm32使用单通道规则组ADC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Driver_ADC.c 如果需要关闭adc转换，只需要设置CNT，将其置为0，后面再转换一次就停止了。
#include "Driver_ADC.h" void Driver_ADC1_Init(void) { /* 1. 时钟配置 */ /* 1.1 adc时钟 */ RCC-&gt;APB2ENR |= RCC_APB2ENR_ADC1EN; RCC-&gt;CFGR |= RCC_CFGR_ADCPRE_1; RCC-&gt;CFGR &amp;= ~RCC_CFGR_ADCPRE_0; /* 1.2 gpio的时钟 */ RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPCEN; /* 2. gpio工作模式: PC0 模拟输入 CNF=00 MODE=00 */ GPIOC-&gt;CRL &amp;= ~(GPIO_CRL_CNF0 | GPIO_CRL_MODE0); /* 2. ADC相关配置 */ /* 2.1 禁用扫描模式. 只有一个通道不用扫描 */ ADC1-&gt;CR1 &amp;= ~ADC_CR1_SCAN; /* 2.2 启用连续转换模式 CR2=CONT 1*/ ADC1-&gt;CR2 |= ADC_CR2_CONT; /* 2.3 数据对齐方式: 右对齐 左对齐 */ ADC1-&gt;CR2 &amp;= ~ADC_CR2_ALIGN; /* 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a170ec337a0f946b3a474bf9bad72e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/145d46c394b56b871cc7cd01e1cdc517/" rel="bookmark">
			Java客户端调用SOAP方式的WebService服务实现方式分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 在多系统交互中，有时候需要以Java作为客户端来调用SOAP方式的WebService服务，本文通过分析不同的调用方式，以Demo的形式，帮助读者在生产实践中选择合适的调用方式。
本文JDK环境为JDK17。
结论 推荐使用Axis2或者Jaxws，以无客户端的形式来调用WebService。
有客户端，推荐Maven插件。
有客户端调用 主要时利用wsdl文档，自动生成对应的Java代码来实现
建议在pom文件中，配置对应的Maven插件来实现WebService客户端代码的自动生成。
JDK wsimport命令生成（不推荐） 简介
主要是利用jdk的自带工具wsimport工具实现，执行命令如下：
wsimport -s C:\tmp\com -p com.example.demo5.wsdl -encoding utf-8 http://www.webxml.com.cn/WebServices/IpAddressSearchWebService.asmx?wsdl
优点
通常装有JDK的电脑或者服务器都可以直接运行，方便生成。
缺点
在实际的运用中wsimport命令会有很多问题，首先只有JDK1.8才支持这个命令，即使能使用，仍然存在一些问题。其次，在JDK17以上没有自带这个工具，可能要安装插件才能使用，但是笔者安装了一些插件仍然无法使用。
ApacheCXF自动生成（不推荐） 简介
ApacheCXF通过安装也可以自动生成对应的WebService客户端代码。具体操作可见链接。
缺点
需要额外安装ApacheCXF插件。
Maven插件自动生成（推荐） 简介
通过spring.io网址的Demo示例，可以配置pom的maven插件，自动生成代码。
demo获取链接如下：
Getting Started | Consuming a SOAP web service (spring.io)
pom配置示例如下：
&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- tag::wsdl[] --&gt; &lt;plugin&gt; &lt;groupId&gt;com.sun.xml.ws&lt;/groupId&gt; &lt;artifactId&gt;jaxws-maven-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;wsimport&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;packageName&gt;com.example.consumingwebservice.wsdl&lt;/packageName&gt; &lt;wsdlUrls&gt; &lt;!--	&lt;wsdlUrl&gt;http://localhost:8080/ws/countries.wsdl&lt;/wsdlUrl&gt;--&gt; &lt;wsdlUrl&gt;http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/145d46c394b56b871cc7cd01e1cdc517/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/175/">«</a>
	<span class="pagination__item pagination__item--current">176/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/177/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>