<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad3887027d8b6702743996e9c11b5101/" rel="bookmark">
			前端实现免密登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近接到个需求，就是实现免密登录，用户在url参数中携带加密的token，直接进入首页，不需要登录，具体实现如下：
在router.beforeEach守卫中进行处理 router.beforeEach(async (to: any, from, next) =&gt; { const token = to.query.token // 从路由参数中获取 token //判断url是否携带token if (to.meta.whiteList &amp;&amp; token) { const decodedToken = Base64.decode(token);// 解密 Base64 编码的 token //验证 token 的有效性并登录用户 let data = { token: decodedToken } try { let res:any = await checktoken(data) // .then((res: any) =&gt; { // 验证成功，将用户信息保存到全局状态管理或本地存储 pinia if (res.code == 0) { storage.local.set('token', res.data.accessToken); // storage.local.set('token', Base64.decode(token)); storage.local.set('username', res.data.userName) storage.local.set('expiresTime', res.data.expiresTime) storage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad3887027d8b6702743996e9c11b5101/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1868979ea1de92748b7352a824461a3f/" rel="bookmark">
			【python】python小说数据抓取&#43;可视化（源码&#43;数据）【独一无二】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👉博__主👈：米码收割机
👉技__能👈：C++/Python语言
👉公众号👈：测试开发自动化【获取源码+商业合作】
👉荣__誉👈：阿里云博客专家博主、51CTO技术博主
👉专__注👈：专注主流机器人、人工智能等相关领域的开发、测试技术。
【python】python小说数据抓取+可视化（源码+数据）【独一无二】 目录 【python】python小说数据抓取+可视化（源码+数据）【独一无二】一、功能描述二、可视化展示三、部分代码 一、功能描述 主要采集是创世中文网，网页中主要功能如下：
爬取小说信息： 通过循环遍历预设的小说类型和页数，使用requests库发送HTTP请求获取每一页小说信息的HTML页面，然后解析库提取页面中的小说标题、等级、类型、字数和简介等信息，并保存到Excel文件中。
数据清洗和转换： 读取Excel文件中的数据，对字数进行单位统一和异常处理，确保数据的准确性和一致性。
数据可视化： 绘制多种图表，包括散点图、折线图、柱状图、饼图和词云图，展示了小说数据的不同特征和分布情况，如小说等级与字数的关系、小说标题长度与字数的关系、不同类型小说的总字数和数量分布、每种类型小说的平均字数以及字数最多的前15篇小说等。
提供数据分析： 通过观察和分析生成的图表，用户可以更直观地了解小说数据的特征和规律，例如不同类型小说的数量和字数分布情况，以及字数最多的小说等。这些分析有助于用户做出进一步的决策或研究。
数据抓取内容如下，主要采集了 2000+ 条数据，保存到excel文件中：
👉👉👉源码关注【测试开发自动化】公众号，回复 “ 小说数据抓取 ” 获取。👈👈👈
爬取内容显示如下：
二、可视化展示 折线图：名字最长的前10篇小说的字数 通过 plt.plot() 函数绘制折线图，横轴为前10篇小说的标题，纵轴为字数（单位为万字）。通过 plt.xticks() 函数设置横坐标的旋转角度和对齐方式，使得标题能够清晰显示。通过 plt.title() 函数设置图表标题，plt.ylabel() 函数设置纵坐标标签，plt.tight_layout() 函数调整布局，最后使用 plt.show() 函数显示图表。 👉👉👉源码关注【测试开发自动化】公众号，回复 “ 小说数据抓取 ” 获取。👈👈👈
柱状图：类型 vs 总字数 首先使用 groupby() 函数按照小说类型对数据进行分组，然后使用 sum() 函数计算每种类型小说的总字数。通过 plot(kind='bar') 函数绘制柱状图，横轴为小说类型，纵轴为总字数（单位为万字）。同样使用 plt.title() 函数设置图表标题和纵坐标标签，最后使用 plt.show() 函数显示图表。 饼图：小说类型分布 使用 value_counts() 函数统计每种小说类型的数量。通过 plot(kind='pie') 函数绘制饼图，展示不同类型小说的数量占比。使用 autopct='%1.1f%%' 参数显示每个扇形的百分比标签，并通过 plt.title() 函数设置图表标题，最后使用 plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1868979ea1de92748b7352a824461a3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47db29d3c6cd3e70c01b5e1ceb47efba/" rel="bookmark">
			深入浅出：实现前端菜单权限控制的策略详解（结尾附vue3完整示例代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言
在构建企业级Web应用时，菜单权限控制很关键。前端层面实现菜单权限控制，确保系统安全性的同时提升用户体验。
@[一、权限模型和数据结构]
##一、权限模型和数据结构 1. 权限模型：常见的权限模型有基于角色的权限控制（RBAC，Role-Based Access Control），即用户通过角色与权限关联，角色再与具体的菜单项绑定。菜单结构一般采用树形结构，方便递归渲染与权限过滤。
2. 数据对接：前端通过与后端API交互，获取当前登录用户的角色及其所拥有的菜单权限数据。这部分数据通常包括菜单ID、名称、URL、父节点ID以及是否可见、是否可访问等权限标识。
3. 数据处理：拿到权限数据后，前端需要将其转换为易于操作的数据结构，例如数组或对象。可以按照菜单层级构建嵌套数组，便于递归生成菜单。
二、前端权限控制实现策略 1. 渲染前过滤
在渲染菜单组件前，根据用户权限数据对原始菜单数据进行筛选，去除无权限访问的菜单项。这是一种主动过滤的方式，可以减少无用DOM元素的生成，降低内存占用。
function filterMenusByPermission(menus, permissions) { return menus.filter(menu =&gt; permissions.includes(menu.id) &amp;&amp; menu.visible); } 2. 渲染时控制
在菜单组件的渲染函数内部，针对每个菜单项判断其权限属性，决定是否渲染。这种方式下，即使用户没有权限的菜单项也会被创建成DOM元素，但在最终呈现时会被隐藏。
function MenuItem({ menu }) { if (!menu.accessible) return null; // 权限不足，不渲染此菜单项 return &lt;div&gt;{menu.name}&lt;/div&gt;; } function MenuList({ menus }) { return ( &lt;ul&gt; {menus.map(menu =&gt; ( &lt;MenuItem key={menu.id} menu={menu} /&gt; ))} &lt;/ul&gt; ); } 3. 动态路由控制
在使用了路由系统的项目中，还可以结合路由配置实现权限控制。为每个路由配置对应的权限标识，然后在路由守卫（如Vue中的beforeEach钩子函数）中进行拦截和跳转处理。
router.beforeEach((to, from, next) =&gt; { const hasPermission = checkUserPermission(to.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47db29d3c6cd3e70c01b5e1ceb47efba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfa8d765c6662b6ac901bee7182adaa0/" rel="bookmark">
			【MySQL】事务？隔离级别？锁？详解MySQL并发控制机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.先理清一下概念
2.锁
2.1.分类
2.2.表锁
2.3.行锁（MVCC）
2.4.如何进行事务间数据的强制同步
2.5.间隙锁
2.6.行锁变表锁
2.7.强制锁行
1.先理清一下概念 所谓并发控制指的是在对数据库进行并发操作时如何保证数据的一致性和正确性。在数据库中与并发控制相关的概念有如下几个：
事务
隔离界别
锁
这几个概念大家应该都知道，但是我猜很多人没有把它们串在一起搞明白他们之间的关系，导致这三个概念各是各的，造成记忆负担，最后对整个数据库并发控制的体系也云里雾里的。
锁与事务的关系：
在计算机科学中，做并发控制都是用的“标志位”来实现的，说直白一点就是锁，我们基本上可以说计算机科学中并发控制的底层都是锁的思想。在数据库中也不例外，也是通过锁来实现并发控制的。使用上锁之后，整个数据库的读写都会对外呈现出一些特质，这些特质就是事务（ACID），原子性、一致性、隔离性、持久性。
锁与隔离级别的关系：
当然锁有很多，在数据库中有行锁、表锁、读锁、写锁等等......不同级别的锁，ACID这些特质的强弱不同，这个强弱的级别就是“隔离级别”。
所以综合起来说就是用锁来实现并发控制，对外会呈现出事务（ACID），锁的级别的不同，ACID的强弱也不同，隔离级别对应也不同。
三个东西的关系理清楚后，来回顾一下事务和隔离级别的具体内容。
事务：
事务是为了保证SQL之间不产生脏数据。innodb中默认没有被包裹在事务中的一个单条SQL就是一个事务。事务是一类特征的总称，合起来为ACID：
原子性 (Atomicity):一个事务是一个不可分割的工作单元；事务中的所有操作要么全部成功执行，要么全部不执行。如果事务中的任何部分失败，则整个事务将被回滚到事务开始前的状态。一致性 (Consistency):在事务开始和结束时，数据库都必须处于一致状态。这意味着事务的执行不会违反任何数据库约束或规则，并且会保持业务逻辑上的一致性。一旦事务完成，它应该使数据库从一个有效状态变为另一个有效状态。隔离性 (Isolation):并发执行的多个事务之间互不干扰，如同它们是按顺序独立执行一样。这防止了脏读（读取未提交的数据）、不可重复读（在同一事务内多次读取同一数据时结果不同）和幻读（在事务中多次执行相同的查询时，由于其他已提交事务的插入或删除操作导致结果集发生变化）等现象。持久性 (Durability):当事务成功提交后，其对数据库所做的修改将会永久保存，即使系统发生故障（如崩溃、重启等）也不会丢失这些修改。持久性通常是通过日志记录和恢复机制来保证的。 隔离级别：
事务内具有原子性，但是事务间不具有原子性，并发情况下，多事务间仍然会存在脏数据的问题。
1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据。
2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。
3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。
隔离级别就是为了保证事务之间不产生脏数据。
2.锁 2.1.分类 按照对数据的操作类型分类，分为：读锁、写锁。
按照对数据操作的粒度分类，分为：行锁、表锁、
表锁：
开销小、加锁快，无死锁，锁的粒度大，发生锁冲突的概率最高，并发度最低。
读锁：
又叫共享锁，针对同一份数据，多个读操作可以同时进行而不互相影响。针对被锁表，所有客户端都可以进行读操作，所有客户端都无法进行写操作，加锁方和其他客户端的区别是，加锁方直接不允许进行写操作，而其他客户端的写操作允许进行，只是会被阻塞挂起。锁解开后，所有挂起的操作线程会去重新争抢资源。
写锁：
又叫排它锁，当前写操作没有完成前，它会阻断其他写锁和读锁。针对被锁表，加锁方可以读写，其他客户端不行。其他客户端的写操作会直接失败，读操作会被阻塞挂起，解锁以后，被挂起的线程会重新去争抢资源。
保护机制：
读锁、写锁中，加锁方都只能读当前被自己锁定的表，这是MySQL的一个保护机制，为的就是强制要求加锁方给出一个说法，到底准备锁多久，不给说法不让走。
MySQL中不同引擎支持不同级别的锁，myIsam支持表锁，innodb支持行锁。
2.2.表锁 表锁，我们当然是要基于使用表锁的存储引擎来聊，也就是基于myIsam引擎。
myIsam引擎中的读写锁是自动加的。
myIsam引擎在解锁后的阻塞队列中进行读写锁调度是写优先，这样一旦阻塞队列中大量都是写操作，那么读操作会很难得到锁，变得很慢，从而造成永久堵塞。
当然除了自动加锁，表锁可以通过指令来加锁。
查看所有锁：
show open tables 解锁：
解铃还须系铃人，只有加锁方能解锁。
unlock tables 加读锁:
lock table 表名 read 加写锁
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfa8d765c6662b6ac901bee7182adaa0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6cafa064b9c711784fc0367886eb9e2/" rel="bookmark">
			springboot项目接入Oracle数据库配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Maven驱动配置： &lt;!-- oracle驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt; &lt;version&gt;11.2.0.3&lt;/version&gt; &lt;/dependency&gt; 一般情况下yml的配置如下 spring: datasource: username: pp password: 123456 url: jdbc:oracle:thin:@localhost:1521:XE driver-class-name: oracle.jdbc.OracleDriver 其中XE为服务名（Oracle没有MySQL中库的概念，有服务名、以及对应模式的概念）。 而针对如果一个oracle数据库有多个模式(即服务)的情况，每个模式应该配置对应的用户名和访问密码。 当然也可以像如下这样配置（mybatis生成配置文件中也是同样的格式，红色部分需要修改为具体信息）: connectionURL="jdbc:oracle:thin:@(DESCRIPTION =(ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.10.1)(PORT = 1521))(CONNECT_DATA =(SERVER = DEDICATED)(SERVICE_NAME = TESTORADB)))" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a59161630a7f67e87735c4b48015cf50/" rel="bookmark">
			数据仓库实验一：数据仓库建立实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、实验目的二、实验要求三、实验内容四、实验步骤1、维表设计2、事实表设计3、新建多维分析和挖掘项目 五、实验结果分析六、实验总结体会 一、实验目的 通过本实验，掌握在Sql Server（2012 或 2008 R2以上版本）中通过 Analysis Services 建立数据仓库的方法。包括如何在 BI Development Studio 的 Analysis Services 项目中定义数据源、数据源视图、维度、属性、层次结构和多维数据集，如何查看多维数据集的维度，理解并掌握 OLAP 分析的基本过程和方法。
二、实验要求 能够针对某个领域的分析主题，建立事实表与维度表，设计星型模型或雪花模型。查看、编辑数据仓库的基本模型（即事实表与维度表之间的关系）。针对某一系统需求，从无到有设计一 个数据仓库基本架构，要求能够按不同维度进行多维数据查询分析。
三、实验内容 某电商的业务销售涵盖全国范围，销售商品有家用电器和通信设备等。已建有网上销售业务管理系统，可以获取每日销售信息和顾客的基本信息等。要求为该电商建立一个能够提高市场竞争能力的数据仓库 SDWS，其主题是电商销售情况分析，包括以下分析功能。
（1）分析全国各地区每年、每季度的销售金额；
（2）分析各类商品在每年、每月的销售量。
（3）分析各年龄层次的顾客购买商品的次数。
（4）分析某年某季度各地区、各类商品的销售量。
（5）分析每年各省份、各年龄层次的商品购买金额。
（6）分析各产品子类、各地区、各年龄层次的销售量。
（7）其他销售情况分析等。
四、实验步骤 为了简化起见，数据仓库采用星型模型。
1、维表设计 在 SSMS 中，设计如下 4 个维度表。
（1）日期维度表Dates
手工录入适量数据：
（2）顾客维度表Customers
手工录入适量数据：
（3）地点维度表Locates
手工录入适量数据：
（4）商品维度表Products
手工录入适量数据：
2、事实表设计 设计一个销售事实表 Sales，对应的表结构如下：
假设该事实表中目前的数据如下所示：
请注意：
（1）以上的 4 个维度表和1个事实表，都设置了主键（这是必须的）。
（2）为 Sales 事实表设置外键约束，使 Date_key，Cust_key，Locate_key，Prod_key 分别参照另外的 4 个维度表中的主键。
可以新建一个查询，为 Sales 表增加 4 个外键约束，如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a59161630a7f67e87735c4b48015cf50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96269d48392876f5e1822b3884b4b70d/" rel="bookmark">
			Android获取经纬度的最佳实现方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android中获取定位信息的方式有很多种，系统自带的LocationManager，以及第三方厂商提供的一些定位sdk，都能帮助我们获取当前经纬度，但第三方厂商一般都需要申请相关的key，且调用量高时，还会产生资费问题。这里采用LocationManager + FusedLocationProviderClient 的方式进行经纬度的获取，以解决普通场景下获取经纬度和经纬度转换地址的功能。
一，添加定位权限 &lt;!--允许获取精确位置，精准定位必选--&gt; &lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt; &lt;!--后台获取位置信息，若需后台定位则必选--&gt; &lt;uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" /&gt; &lt;!--用于申请调用A-GPS模块,卫星定位加速--&gt; &lt;uses-permission android:name="android.permission.ACCESS_LOCATION_EXTRA_COMMANDS" /&gt; 二，添加依赖库 implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.4' implementation 'androidx.lifecycle:lifecycle-viewmodel-ktx:2.6.2' implementation 'com.google.android.gms:play-services-location:21.0.1' 三，使用LocationManager获取当前经纬度 获取经纬度时，可根据自己的诉求进行参数自定义，如果对经纬度要求不是很精确的可以自行配置Criteria里面的参数。
获取定位前需要先判断相关的服务是否可用，获取定位的服务其实有很多种选择，因为个人项目对经纬度准确性要求较高，为了保证获取的成功率和准确性，只使用了GPS和网络定位两种，如果在国内还会有基站获取等方式，可以自行修改。
import android.Manifest.permission import android.location.* import android.os.Bundle import android.util.Log import androidx.annotation.RequiresPermission import kotlinx.coroutines.suspendCancellableCoroutine import kotlinx.coroutines.withTimeout import kotlin.coroutines.resume object LocationManagerUtils { val TAG = "LocationManagerUtils" /** * @mLocationManager 传入LocationManager对象 * @minDistance 位置变化最小距离：当位置距离变化超过此值时，将更新位置信息（单位：米） * @timeOut 超时时间，如果超时未返回，则直接使用默认值 */ @RequiresPermission(anyOf = [permission.ACCESS_COARSE_LOCATION, permission.ACCESS_FINE_LOCATION]) suspend fun getCurrentPosition( mLocationManager: LocationManager, timeOut: Long = 3000, ):Location{ var locationListener : LocationListener?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96269d48392876f5e1822b3884b4b70d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95b8754a48928dd1b54184006e6280a6/" rel="bookmark">
			tokenpocket（钱包）：tp198.app、细致讲解MQ：RabbitMQ、RocketMQ、Kafka 2.0版本！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RabbitMQ、RocketMQ 和 Kafka 是当前最受欢迎的三个消息队列（Message Queue）系统，它们都具有高性能、高可靠性和可伸缩性的特点，但在一些方面有所不同。下面将详细介绍这三个消息队列系统。 ## RabbitMQ RabbitMQ 是一个基于 AMQP（Advanced Message Queuing Protocol）协议的开源消息队列系统，使用 Erlang 语言开发。它采用了生产者-消费者模型，支持多种消息传输模式，包括点对点、发布-订阅和请求-回复模式。以下是 RabbitMQ 的一些主要特点： 1. **可靠性**：RabbitMQ 提供了多种机制来确保消息的可靠传输，包括持久化消息、消息确认机制和事务支持。 2. **灵活的路由**：RabbitMQ 使用 Exchange 来进行消息的路由和分发，支持灵活的路由规则配置，可以根据消息的属性和路由键将消息发送到不同的队列。 3. **消息确认机制**：RabbitMQ 支持消息的确认机制，生产者可以通过确认机制来确保消息被正确接收和处理。 4. **高可用性**：RabbitMQ 支持集群部署，可以通过复制和镜像队列来保证高可用性和故障恢复。 5. **丰富的插件机制**：RabbitMQ 提供了丰富的插件机制，可以通过插件扩展其功能，如支持消息的压缩、消息的延迟发送等。 ## RocketMQ RocketMQ 是由阿里巴巴开源的一款分布式消息队列系统，它最初是为满足阿里巴巴内部的大规模消息处理需求而开发的。以下是 RocketMQ 的一些主要特点： 1. **高吞吐量**：RocketMQ 具有高吞吐量和低延迟的特点，可以支持每秒百万级别的消息处理能力。 2. **扩展性**：RocketMQ 支持线性扩展，可以通过增加 Broker 节点来提高整个系统的吞吐量和容量。 3. **顺序消息**：RocketMQ 支持顺序消息，可以确保按照消息的顺序进行处理，适用于一些对消息顺序要求较高的场景。 4. **分布式事务消息**：RocketMQ 提供了分布式事务消息的支持，可以保证在分布式环境下的消息事务的一致性。 5. **灾难恢复**：RocketMQ 提供了消息的持久化存储和复制机制，以及消息的冷备份，能够保证在发生故障时的数据可靠性和快速恢复能力。 ## Kafka Kafka 是由 Apache 开源的一款分布式流处理平台和消息队列系统，它的设计目标是处理高吞吐量的实时数据流。以下是 Kafka 的一些主要特点： 1. **高吞吐量**：Kafka 具有非常高的吞吐量和低的延迟，可以支持每秒百万级别的消息处理能力。 2. **持久化存储**：Kafka 使用磁盘进行消息的持久化存储，可以长期保留消息数据，并支持高效的消息读写。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95b8754a48928dd1b54184006e6280a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04c985c3a7ad451971d856ec1e13f247/" rel="bookmark">
			第十三届蓝桥杯省赛真题 Java A 组【原卷】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 发现宝藏【考生须知】试题 A: 裁纸刀试题 B: 寻找整数试题 C : \mathrm{C}: C: 求和试题 D: GCD试题 E: 蜂巢试题 F : \mathrm{F}: F: 全排列的价值试题 G: 青蛙过河试题 H \mathrm{H} H : 因数平方和试题 I: 最优清零方案试题 J : \mathrm{J}: J: 推导部分和 发现宝藏 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。【宝藏入口】。
第十三届蓝桥杯大赛软件赛省赛 Java A 组 【考生须知】 考试开始后, 选手首先下载题目, 并使用考场现场公布的解压密码解压试题。
考试时间为 4 小时。考试期间选手可浏览自己已经提交的答案, 被浏览的答案允许拷贝。时间截止后，将无法继续提交或浏览答案。
对同一题目, 选手可多次提交答案, 以最后一次提交的答案为准。
选手必须通过浏览器方式提交自己的答案。选手在其它位置的作答或其它方式提交的答案无效。
试题包含 “结果填空” 和 “程序设计” 两种题型。
结果填空题: 要求选手根据题目描述直接填写结果。求解方式不限。不要求源代码。把结果填空的答案直接通过网页提交即可, 不要书写多余的内容。
程序设计题: 要求选手设计的程序对于给定的输入能给出正确的输出结果。考生的程序只有能运行出正确结果才有机会得分。
注意: 在评卷时使用的输入数据与试卷中给出的示例数据可能是不同的。选手的程序必须是通用的, 不能只对试卷中给定的数据有效。
所有源码必须在同一文件中。调试通过后，拷贝提交。
注意: 不要使用 package 语句。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04c985c3a7ad451971d856ec1e13f247/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7382fdd202e929cdfed075f8478a2540/" rel="bookmark">
			第十三届蓝桥杯省赛真题 Java B 组【原卷】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 发现宝藏【考生须知】试题 A: 星期计算试题 B: 山试题 C: 字符统计试题 D: 最少刷题数试题 E \mathrm{E} E : 求阶乘试题 F : \mathrm{F}: F: 最大子矩阵试题 G: 数组切分试题 H: 回忆迷宫试题 I: 红绿灯试题 J 拉箱子 发现宝藏 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。【宝藏入口】。
第十三届蓝桥杯大赛软件赛省赛 Java B 组 【考生须知】 考试开始后, 选手首先下载题目, 并使用考场现场公布的解压密码解压试题。
考试时间为 4 小时。考试期间选手可浏览自己已经提交的答案, 被浏览的答案允许拷贝。时间截止后，将无法继续提交或浏览答案。
对同一题目, 选手可多次提交答案, 以最后一次提交的答案为准。
选手必须通过浏览器方式提交自己的答案。选手在其它位置的作答或其它方式提交的答案无效。
试题包含 “结果填空” 和 “程序设计” 两种题型。
结果填空题: 要求选手根据题目描述直接填写结果。求解方式不限。不要求源代码。把结果填空的答案直接通过网页提交即可, 不要书写多余的内容。
程序设计题: 要求选手设计的程序对于给定的输入能给出正确的输出结果。考生的程序只有能运行出正确结果才有机会得分。
注意: 在评卷时使用的输入数据与试卷中给出的示例数据可能是不同的。选手的程序必须是通用的, 不能只对试卷中给定的数据有效。
所有源码必须在同一文件中。调试通过后，拷贝提交。
注意: 不要使用 package 语句。
注意：选手代码的主类名必须为: Main, 否则会被判为无效代码。
注意: 如果程序中引用了类库, 在提交时必须将 import 语句与程序的其他部分同时提交。只允许使用 Java 自带的类库。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7382fdd202e929cdfed075f8478a2540/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d9725be8b4d1f4cb7874ff892f6d273/" rel="bookmark">
			javaSwing图书管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 引言 图书管理系统是一个用于图书馆或书店管理图书信息、借阅记录和读者信息的应用程序。本系统使用Java Swing框架进行开发，提供直观的用户界面，方便图书馆管理员或书店工作人员对图书信息进行管理。以下是系统的设计、功能和实现的详细报告。
二、系统设计 技术选型：
前端框架： Java Swing
后端语言： Java
数据库： 使用文件存储图书信息
系统架构：
MVC（Model-View-Controller）架构，以确保系统的可维护性和扩展性。
Model： 数据模型，包括图书、读者和借阅记录等类。
View： 用户界面，使用Swing组件实现各种窗口和表格。
Controller： 控制器，处理用户输入、调用业务逻辑和更新视图。
三、 系统功能 图书管理：
添加图书信息，包括书名、作者、出版社、出版日期等。
修改图书信息，支持编辑已有图书的属性。
删除图书，从系统中移除不需要的图书。
查询图书，根据书名、作者等条件进行搜索。
读者管理：
添加读者信息，包括姓名、学号（或工号）、联系方式等。
修改读者信息，更新读者的个人信息。
删除读者，从系统中注销读者账号。
查询读者，根据姓名、学号等条件进行搜索。
借阅管理：
借书，记录图书的借阅信息，包括借阅日期和应还日期。
还书，更新图书的借阅状态，计算逾期天数和罚金。
查询借阅记录，查看读者的借阅历史。
四、 用户界面 登录界面： 提供用户名和密码登录系统。
主界面： 显示图书管理、读者管理和借阅管理等功能按钮。
图书管理界面： 包括添加、修改、删除和查询图书的功能。
读者管理界面： 包括添加、修改、删除和查询读者的功能。
借阅管理界面： 包括借书、还书和查询借阅记录的功能。
五、数据库 1.book_admin表：存储管理员信息。 CREATE TABLE book_admin (
username varchar(20) NOT NULL COMMENT ‘用户名’,
password varchar(20) NOT NULL COMMENT ‘密码’,
PRIMARY KEY (username),
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d9725be8b4d1f4cb7874ff892f6d273/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c95af2f03340dd42716e9ffbb295aca4/" rel="bookmark">
			Java - Stream流详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、Stream流是什么？
二、流的分类
顺序流
并行流
区别
三.获取流的常用方式
1.通过集合获取流
2.通过数组获取流
3.通过Stream.of()方法获取流
四.常用方法用法
1.filter(Predicate predicate)：过滤流中的元素，只保留符合条件的元素
2.limit &amp;&amp; skip
3.distinct()：去重，去除流中重复的元素。
4.concat 合并a和b两个流为一个流
5. map(Function mapper)：将流中的元素按照指定的方式进行映射，返回一个新的流,&gt;
6.forEach(Consumer action)：对流中的每个元素执行指定的操作。
7.collect(Collector collector)：将流中的元素收集到一个集合中。,&gt;
5.练习
前言 大家好,好久不见了,最近由于实训的影响导致拖更了,在更新这一次估计javaSE基本上就算是完结了,还有一些落下的后面也会补上的,下次见面就是数据结构了
尽情期待吧!那么就让我们步入Stream流的学习吧! 一、Stream流是什么？ Stream流是Java 8中的一个新特性，它提供了一种处理集合和数组的方式。Stream流可以让我们以一种更加简洁、高效、可读性更强的方式来处理数据。Stream流可以用于过滤、映射、排序、聚合等操作，它可以让我们避免使用循环和条件语句来处理数据，从而让代码更加简洁易懂。Stream流的操作可以分为中间操作和终止操作两种类型，中间操作返回的是一个新的Stream流，终止操作返回的是一个非Stream类型的结果。Stream流的处理是惰性求值的，只有在执行终止操作时才会开始处理数据。
流（Stream）是一种基于支持一次性处理数据的数据源的元素序列,流只能使用一次。
流的设计初衷是为了支持函数式编程，它的目的是将数据处理和数据存储分离开来，使得数据处理更加灵活和高效。因此，流的元素只是在流中传递的临时数据，它们并不是永久存储在内存中的数据。当流的元素被消费后，它们就会被释放，不能再次使用.
如果需要对同一个数据集进行多次不同的操作，可以使用流的中间操作方法来构建多个流管道，每个流管道都可以对流进行不同的操作，并返回一个新的流。这样就可以对同一个数据集进行多次操作，而不需要重新获取数据集。
二、流的分类 顺序流 顺序流是一种单线程的流，它按照数据流的顺序依次处理每个元素，每个元素的处理都必须等待上一个元素的处理完成才能开始。
并行流 并行流是一种多线程的流，它可以将数据分成多个部分并行处理，每个部分都可以在不同的线程中处理，从而提高处理效率。
使用顺序流可以保证数据处理的顺序和一致性，适用于处理数据量较小的情况。而使用并行流可以提高数据处理的速度，适用于处理数据量较大、处理时间较长的情况。但是并行流也有一些缺点，比如线程之间的通信和同步会带来额外的开销，而且并行流可能会影响数据的顺序和一致性。因此在使用并行流时需要注意线程安全和数据一致性等问题。
区别 顺序流和并行流的区别在于它们的处理方式不同，顺序流是单线程的，而并行流是多线程的。使用的方法也有一些区别，例如：
获取顺序流：可以使用集合类的stream()方法、Arrays类的stream()方法、Stream类的of()方法、Stream类的iterate()方法、Stream类的generate()方法、Files类的lines()方法等来获取顺序流。
获取并行流：可以使用集合类的parallelStream()方法、Stream类的of()方法的parallel()方法、Stream类的iterate()方法的parallel()方法、Stream类的generate()方法的parallel()方法等来获取并行流。
除此之外，顺序流和并行流的使用方法基本相同，例如可以使用map()、filter()、reduce()等方法对流进行操作。但需要注意的是，在使用并行流时需要考虑线程安全和数据一致性等问题。
下面我只会详细讲解顺序流的使用,并行流的使用大差不差,大家有兴趣可以自行尝试
三.获取流的常用方式 前面提到过,流（Stream）是一种基于支持一次性处理数据的数据源的元素序列,流只能使用一次
所以将流保存起来没有任何意义,但是获取还是很有必要的,下面我会将常用的获取方式详解,不常用的也会给出获取方式,大家有兴趣的话可以自行尝试!
对了,我觉得有必要的是因为我现在的知识面不广,接触不到太复杂的内容,等回头成了大牛再来补
哈哈,其实不说的大部分是我不会,小黑子,漏出鸡脚了吧
1.通过集合获取流：可以使用集合类中的stream()方法或parallelStream()方法来获取流
2.通过数组获取流：可以使用Arrays类中的stream()方法来获取流。
3.通过Stream.of()方法获取流：可以使用Stream类中的of()方法来获取流。
4.通过Stream.iterate()方法获取流：可以使用Stream类中的iterate()方法来获取流
Stream&lt;Integer&gt; stream = Stream.iterate(0, n -&gt; n + 2).limit(5); // 获取顺序流 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c95af2f03340dd42716e9ffbb295aca4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14c73433dfa761feebd95a9237a4723b/" rel="bookmark">
			修改 RabbitMQ 默认超时时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MQ客户端正常运行，突然就报连接错误，
错误信息写的很明确，是客户端连接超时。
不过很疑虑，为什么会出现连接超时呢？代码没动过，网络也ok，也设置了心跳和重连机制。
最终在官网中找到了答案：
消息“手动确认”的模式下，MQ服务会强制执行超时机制，以防止消息一直不确认的潜在bug。
RabbitMQ默认的超时时间是30分钟，30分钟内一直无消息消费的话，则RabbitMQ会将Channel销毁，无法继续消费，导致代码报错。
因此需要自行解决，可以考虑几种解决方案：
方案一：修改客户端连接超时时间；
方法1：临时修改；
优点：无须重启MQ服务；
缺点：MQ服务重启后，设置失效，需要重新设置；
以Linux系统为例，直接登录服务器，执行如下命令：
#通过命令 修改超时时间： rabbitmqctl eval 'application:set_env(rabbit,consumer_timeout,180000000).' #通过命令 查看MQ的超时时间： rabbitmqctl eval 'application:get_env(rabbit,consumer_timeout).' 方法2：永久修改；
优点：MQ服务重启，设置依然生效；
缺点：需要重启MQ服务才能使设置生效，生产环境下，需要考虑业务是否可中断；
以Linux系统为例，
1、创建RabbitMQ的配置文件(默认没有该配置文件)：/etc/rabbitmq.conf
2、文件中设置
consumer_timeout = 18000000
3、重启RabbitMQ。
方案二：修改业务，定时发送空消息，防止超时（在无权修改MQ服务配置的场景）；
优点：无须或无权修改MQ服务的设置；
缺点：代码冗余，可能会影响业务；
略。
PS，看到有篇文章也详细讲解了BUG的原因以及解决方法，又重复造轮子了.......
https://www.cnblogs.com/long757747969/p/16936604.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8179e3ab4d122e25b61e353be422d0f/" rel="bookmark">
			Java-springboot集成&#43;drools规则引擎集成，动态化编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		drools+springboot集成 添加drools相关pom依赖 // 第一种：kie-spring 整体引入 &lt;dependency&gt; &lt;groupId&gt;org.kie&lt;/groupId&gt; &lt;artifactId&gt;kie-spring&lt;/artifactId&gt; &lt;version&gt;${kie.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.drools&lt;/groupId&gt; &lt;artifactId&gt;drools-core&lt;/artifactId&gt; &lt;version&gt;${kie.version}&lt;/version&gt; &lt;/dependency&gt; // 第二种：单独引入 &lt;!-- drools依赖 --&gt; &lt;properties&gt; &lt;drools.version&gt;7.24.0.Final&lt;/drools.version&gt; &lt;/properties&gt; &lt;dependency&gt; &lt;groupId&gt;org.drools&lt;/groupId&gt; &lt;artifactId&gt;drools-core&lt;/artifactId&gt; &lt;version&gt;${drools.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.drools&lt;/groupId&gt; &lt;artifactId&gt;drools-compiler&lt;/artifactId&gt; &lt;version&gt;${drools.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 决策表 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.drools&lt;/groupId&gt; &lt;artifactId&gt;drools-decisiontables&lt;/artifactId&gt; &lt;version&gt;${drools.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 模板 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.drools&lt;/groupId&gt; &lt;artifactId&gt;drools-templates&lt;/artifactId&gt; &lt;version&gt;${drools.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.kie&lt;/groupId&gt; &lt;artifactId&gt;kie-api&lt;/artifactId&gt; &lt;version&gt;${drools.version}&lt;/version&gt; &lt;/dependency&gt; 创建Kie相关 Bean 使其被spring管理 @Configuration public class KiaSessionConfig { private static final String RULES_PATH = "rules/"; @Bean public KieFileSystem kieFileSystem() throws IOException { KieFileSystem kieFileSystem = getKieServices().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8179e3ab4d122e25b61e353be422d0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7300c1d278cabba414e3ef049ee82668/" rel="bookmark">
			=＞ ERROR [internal] load metadata for docker.io/library/java:8-alpine问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[internal] load metadata for docker.io/library/java:8-alpine问题解决 这里上面说加载来自docker.io的数据出错，要注意：docker.io/library/java:8-alpine这个地址并不能访问，也ping不通，只是docker这里是这么写的而已。
分析 我的虚拟机和主机网络是可以ping通docker.com的，这里下载不了，可能是因为访问速度太慢的原因。可以更换阿里云镜像站点然后重试。
解决 添加阿里云镜像站点 sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF' { "registry-mirrors": ["https://otclw64h.mirror.aliyuncs.com"] } EOF 重启
···shell
sudo systemctl daemon-reload systemctl restart docker
···
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba8333781877bbed61ffb47f4bb81fea/" rel="bookmark">
			为什么不是Github Copilot,不是 Devin 而是 AutoCoder
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我之前常说，不要逆AGI潮流去做一些事情，但也要对当前的大模型的边界有清晰的了解。
Github Copilot 本质还是IDE工具的衍生，是一个更加“智能”的代码提示，而其提供的Copilot Chat 则更加只是把一个聊天框做到IDE而已，和集成一个搜索框到IDE工具没有任何区别，然还是一个古典产品的思维在做的一个产品。
更细节的，我可以从三个维度做给大家做分析：
第一个维度是 Github Copilot 的定位，我一直是 Github Copilot 的铁杆用户，但因为它的定位是只能代码提示，这决定了他需要追求响应延时而不是效果，所以他最大的问题是，它无法基于整个项目的源码去做新的代码实现（这样会导致延时增加到不可接受，并且成本太高）。
第二个维度是 Github Copilot 无法模拟人类的开发行为，我们实际做开发的时候，一般都是基于已有功能，并且根据某种“文档”，“第三方代码”和“搜索引擎”来进行开发。
比如 Byzer-LLM 要对接 Qwen-vl 多模态大模型，那么作为一个开发，我至少需要准备三个事情：
首先我们需要了解和参考Byzer-LLM 之前是怎么对接各种模型的代码
其次我要找到 Qwen-VL的API 文档了解 Qwen-VL 的API
我可能还需要搜索下参考下别人是怎么对接的，以及如果我使用了第三方SDK，我还需要第三方SDK的文档或者代码。
只有获取了这些信息之后，我们才能写出一个靠谱的代码。但 Github copilot 能做到这些么？显然做不到。
第三个维度是，我没有办法替换模型，也就是只能用 Github Copilot 背后的模型，哪怕我有 GPT-4/Claude3-Opus的 web订阅版，如果是公司在用，如何保证模型的私有化部署呢？
所以 Github Copilot 的产品本质决定了他只是一个更加smart的提示工具，而不是模拟人去编程。这个虽然说不上逆AGI潮流，但确实不够 AI Native, 没有把AI 充分利用起来。
而 Devin 则走了另外一个极端，他是一个AI辅助编程工具，但是他的目标是让AI通过一个简单的需求收集，自动完成为了实现这个需求的所有流程，需求分析，拆解，环境安装，构建项目，编写代码，自动debug,甚至自动运行，这个目标太过于宏大，而且不符合基本的规律，在当前大模型的能力边界上，基本只能作为Demo和科研探索。
为啥不符合基本的规律呢？因为但凡做过研发的人就知道，需求是一个动态变化的过程，是迭代出来的，也是迭代的过程中慢慢想明白的，中间有太多甲方，乙方，商业，技术，人性等等的因素在里面。所以我说 Devin 不仅仅目标过于宏达难以实现，而且也不符合基本的规律，就算AGI实现，也难以完全可行。
正好这两天看到一个star数很高的项目，也是做AI辅助编程的。作者用该工具来辅助自己用JS创建一个聊天程序，基本思路就是通过terminal shell交互来完成沟通，结果演示的时候，在最后关头，AI写的代码出现死循环，因为已经花了大量时间了，他又不想剪辑，就说，反正整体演示出来了。。。很尴尬。。。。
说白了，就算为了完成一个简单的应用，当前最聪明的大模型失败率都太高了。我之前在做 AutoCoder 的时候，也发现，就是根据用户的需求创建一个基本的项目模板，要稳定的重现，对很多大模型来说都是有挑战的。
所以我总结他演示其实有两个大的问题：
他演示整个过程最大的败笔就是不让程序员去修改和调整代码。
此外，现存需要维护的代码远比新建的代码多，如何帮助用户实现现有代码的迭代，远比重新创建一个新项目更有价值和挑战。
虽然该项目的同学还是很理性的认识到：
我不认为A能够（至少在不久的将来）创建应用程序而不涉及开发人员。因此，GPT Pilot会逐步编写应用程序，就像开发人员在现实生活中一样。
但就像很多人说自己坚信Scaling Law，但在具体实践的时候又容易背离Scaling Law。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba8333781877bbed61ffb47f4bb81fea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39825b09730ac28f00ee26fd368cb062/" rel="bookmark">
			Android-Studio下的JNI开发：NDK的配置，android音视频开发面试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Studio默认安装NDK目录是在SDK目录下，安装完成后，local.properties文件中NDK路径设置也将自动更新。
2.Gradle添加NDK模块
打开app模组下的build.gradle文件，在defaultConfig模块下添加ndk模块，如图：
其中moduleName是编译的.so的模组名称，就是原先Eclipse开发里Android.mk文件中LOCAL_MODULE变量，和System.loadLibrary()加载.so时的名称对应。例如moduleName配置为"JniTest"，则.so文件名称为"libJniTest.so"，加载时，名称为System.loadLibrary(“JniTest”)；
abiFilters指定要分配的平台，如果未指定，则将编译所有支持的平台。目前支持的平台有"armeabi"、“armeabi-v7a”、“arm64-v8a”、“mips”、“mips64”、“x86”、"x86_64"这七个；
ldLibs是要链接的库，就是原先Android.mk里LOCAL_LDLIBS变量指定的库。
3.添加C/C++文件
默认情况下，C/C++文件一般放在[module]/src/main/jni/目录下，如图：
当然，你也可以修改build.gradle配置，指定其他路径。在"android.sourceSets.main"模块里，使用"jni.srcDirs"指定jni的路径，如下图：
至此，Android Studio下开发JNI的基本配置就结束了
最后分享一个进阶学习资料送给有需要的朋友**《Android学习PDF+架构视频+最新面试文档+源码笔记》**
自我介绍一下，小编13年上海交大毕业，曾经在小公司待过，也去过华为、OPPO等大厂，18年进入阿里一直到现在。
深知大多数初中级安卓工程师，想要提升技能，往往是自己摸索成长，但自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年最新Android移动开发全套学习资料》送给大家，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友，同时减轻大家的负担。
由于文件比较大，这里只是将部分目录截图出来，每个节点里面都包含大厂面经、学习笔记、源码讲义、实战项目、讲解视频
如果你觉得这些内容对你有帮助，可以添加下面V无偿领取！（备注Android）
实战系列 话不多说，Android实战系列集合都已经系统分类好，由于文章篇幅问题没法过多展示，获取学习笔记链接：点击我的GitHub免费获取
18156601)**
[外链图片转存中…(img-ba4Lbfwq-1711322273037)]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a67184a0beabd889af9efde571ceef2b/" rel="bookmark">
			Java微服务分布式分库分表ShardingSphere - ShardingSphere-JDBC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌹作者主页：青花锁 🌹简介：Java领域优质创作者🏆、Java微服务架构公号作者😄
🌹简历模板、学习资料、面试题库、技术互助
🌹文末获取联系方式 📝
往期热门专栏回顾 专栏描述Java项目实战介绍Java组件安装、使用；手写框架等Aws服务器实战Aws Linux服务器上操作nginx、git、JDK、VueJava微服务实战Java 微服务实战，Spring Cloud Netflix套件、Spring Cloud Alibaba套件、Seata、gateway、shadingjdbc等实战操作 Java基础篇Java基础闲聊，已出HashMap、String、StringBuffer等源码分析，JVM分析，持续更新中 Springboot篇从创建Springboot项目，到加载数据库、静态资源、输出RestFul接口、跨越问题解决到统一返回、全局异常处理、Swagger文档 Spring MVC篇从创建Spring MVC项目，到加载数据库、静态资源、输出RestFul接口、跨越问题解决到统一返回 华为云服务器实战华为云Linux服务器上操作nginx、git、JDK、Vue等，以及使用宝塔运维操作添加Html网页、部署Springboot项目/Vue项目等 Java爬虫通过Java+Selenium+GoogleWebDriver 模拟真人网页操作爬取花瓣网图片、bing搜索图片等 Vue实战讲解Vue3的安装、环境配置，基本语法、循环语句、生命周期、路由设置、组件、axios交互、Element-ui的使用等 Spring讲解Spring(Bean)概念、IOC、AOP、集成jdbcTemplate/redis/事务等 系列文章目录 第一章 Java线程池技术应用
第二章 CountDownLatch和Semaphone的应用
第三章 Spring Cloud 简介
第四章 Spring Cloud Netflix 之 Eureka
第五章 Spring Cloud Netflix 之 Ribbon
第六章 Spring Cloud 之 OpenFeign
第七章 Spring Cloud 之 GateWay
第八章 Spring Cloud Netflix 之 Hystrix
第九章 代码管理gitlab 使用
第十章 SpringCloud Alibaba 之 Nacos discovery
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a67184a0beabd889af9efde571ceef2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b428201ea8386ed84387467175960734/" rel="bookmark">
			kafka3.7 集群 docker部署 springboot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提 你需要知道docker使用、springboot整合kafka
拉取kafka3.7镜像 docker pull apache/kafka:3.7.0 创建数据卷映射 创建以下两个目录（演示使用两个kafka节点）用于日志存储
/logs/kafka/kafka-node1 /logs/kafka/kafka-node2 #设置文件权限 sudo chmod 777 /logs/kafka/* 编写kafka-compose.yml version: '3' services: kafka-node1: image: apache/kafka:3.7.0 container_name: kafka-node1 networks: - kafka-cluster ports: - "9191:9092" - "9192:9093" volumes: - /logs/kafka/kafka-node1:/tmp/kafka-logs environment: KAFKA_PROCESS_ROLES: "broker,controller" KAFKA_NODE_ID: "1" KAFKA_CONTROLLER_QUORUM_VOTERS: "1@kafka-node1:9093,2@kafka-node2:9093" KAFKA_LISTENERS: "PLAINTEXT://0.0.0.0:9092,CONTROLLER://0.0.0.0:9093" KAFKA_ADVERTISED_LISTENERS: "PLAINTEXT://192.168.86.99:9191" KAFKA_CONTROLLER_LISTENER_NAMES: "CONTROLLER" KAFKA_INTER_BROKER_LISTENER_NAME: "PLAINTEXT" KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: "1" KAFKA_TRANSACTION_STATE_LOG_MIN_ISR: "1" KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR: "1" kafka-node2: image: apache/kafka:3.7.0 container_name: kafka-node2 networks: - kafka-cluster ports: - "9193:9092" - "9194:9093" volumes: - /logs/kafka/kafka-node2:/tmp/kafka-logs environment: KAFKA_PROCESS_ROLES: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b428201ea8386ed84387467175960734/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32c7d66c77abbca574d19fece387f554/" rel="bookmark">
			常用中间件redis，kafka及其测试方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用消息中间件及其测试方法 一、中间件的使用场景引入中间件的目的一般有两个：1、提升性能常用的中间件：1) 高速缓存：redis2) 全文检索：ES3) 存日志：ELK架构4) 流量削峰：kafka 2、提升可用性产品架构中高可用设计：1) 分布式锁：redis2) 数据分布式存储：redis，es，kafka 二、Redis1、redis 的数据同步策略以及数据一致性保证？2、哨兵模式的设计架构，如何理解读写分离，选举和脑裂1、什么是哨兵？2、哨兵的配置文件3、网络分区故障网络故障：1）master节点和哨兵节点出现网络故障：2）master节点和slave节点出现网络分区故障： 4、脑裂是什么，怎么解决？ 3、缓存失效下的熔断和降级以及测试方法1、造成缓存失效的几种情况？2、采取的应对策略？3、 如何模拟redis缓存失效？ 4、缓存击穿下的处理方法和测试方法1、什么是缓存击穿？2、缓存击穿解决方案？ 5、缓存穿透下的测试方法1、什么是缓存穿透？2、缓存穿透的解决方案？3、如何测试？ 6、淘汰缓存还是更新缓存1、缓存操作方式1）读操作流程？2）写操作流程：淘汰缓存 or更新缓存？3）写操作：先淘汰缓存再更新数据库 or 先更新数据库再淘汰缓存？ 7、缓存雪崩的测试方法1、如何处理雪崩？2、如何模拟雪崩？ 三、Kafka1、kafka的两个常用场景？2、为什么要用消息队列？3、和其他消息队列相比，kafka的优势在哪里？4、队列模型了解吗？Kafka 的消息模型知道吗？5、什么是Producer、Consumer、Broker、Topic、Partition？6、Kafka 的多副本机制了解吗？带来了什么好处？7、Zookeeper 在 Kafka 中的作用知道吗？8、Kafka 如何保证消息的消费顺序？9、Kafka 如何保证消息不重复消费？10、如何测试kafka？ 一、中间件的使用场景 引入中间件的目的一般有两个： 1、提升性能 产品架构中的性能设计： 常用的中间件： 1) 高速缓存：redis 基于内存，所以比mysql块（存在磁盘io）为什么查询速度快？ 单进程+IO多路复用去提高性能基于内存 做缓存，极大缓解了数据库压力非常适合读多写少的场景 2) 全文检索：ES 适用于大量搜索的场景用的倒排索引，应对读多写少的场景mysql用的正序索引，应对写多读少的场景 3) 存日志：ELK架构 logstash收集日志（目前已经被filebeat替代），然后存入es，再通过kibana展示
4) 流量削峰：kafka 目前最流行的消息中间件 2、提升可用性 产品架构中高可用设计： 1) 分布式锁：redis 应用场景：解决高可用设计中多实例部署下数据访问加锁的问题
2) 数据分布式存储：redis，es，kafka 自身就有非常好的高可用设计，都是集群，可以分布式部署，集群中一台挂了，其他机器也能继续提供服务。数据保存到这些软件，也是分布式部署，可以保证都有相应备份，即使一台挂了，其他机器也可以对外提供服务，也可以确保机器更加安全。 二、Redis 1、redis 的数据同步策略以及数据一致性保证？ 现在软件架构非常复杂，面对数以万计的qps的情况下，如果单台机器到达性能瓶颈，需要一种横向扩展策略，希望把用户请求用负载均衡方式分布在其他机器分担压力。当把所有数据分布到不同机器时候，如何保证每一台机器的数据是完全一致的呢？
为了提升性能，必须使用集群部署，比如我们现在要一主两从架构进行部署，我们可以把写请求发送到主节点，把读请求发送到从节点，以降低主节点的压力（读写分离的意义）。如果保证主从节点的数据是一致的呢，我们就需要数据同步策略（异步同步）
2、哨兵模式的设计架构，如何理解读写分离，选举和脑裂 1、什么是哨兵？ 哨兵是redis官方推荐的集群高可用解决方案它能够自动识别redis集群的健康状态并在master节点异常时将从节点提升为master节点 2、哨兵的配置文件 3、网络分区故障 高可用测试最常注入的故障类型之一 网络故障： 1）master节点和哨兵节点出现网络故障： 1、出现在master节点和哨兵节点之间。比如用户和master节点是正常的，但是master和哨兵节点连接不上，会造成哨兵认为master挂了，开始新一轮选举过程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32c7d66c77abbca574d19fece387f554/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/457/">«</a>
	<span class="pagination__item pagination__item--current">458/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/459/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>