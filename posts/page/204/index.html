<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0970b35ee47605f2bc6834ce81414677/" rel="bookmark">
			Java 并发集合：CopyOnWrite 写时复制集合介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是栗筝i，这篇文章是我的 “栗筝i 的 Java 技术栈” 专栏的第 016 篇文章，在 “栗筝i 的 Java 技术栈” 这个专栏中我会持续为大家更新 Java 技术相关全套技术栈内容。专栏的主要目标是已经有一定 Java 开发经验，并希望进一步完善自己对整个 Java 技术体系来充实自己的技术栈的同学。与此同时，本专栏的所有文章，也都会准备充足的代码示例和完善的知识点梳理，因此也十分适合零基础的小白和要准备工作面试的同学学习。当然，我也会在必要的时候进行相关技术深度的技术解读，相信即使是拥有多年 Java 开发经验的从业者和大佬们也会有所收获并找到乐趣。
–
Java 集合框架（Java Collections Framework）为开发者提供了一套强大且灵活的数据结构和算法工具，使得数据管理和操作变得更加高效和简洁。在多线程环境中，如何在保证线程安全的同时，保持集合操作的高效性，成为了一个至关重要的课题。为此，Java 提供了一系列并发集合类，其中 CopyOnWrite 系列集合因其独特的“写时复制”机制，成为了解决并发读写问题的一种有效方案。
CopyOnWrite 集合类主要包括 CopyOnWriteArrayList 和 CopyOnWriteArraySet。它们通过在每次修改集合时创建一个新副本，从而保证了读操作的无锁化，这种设计极大地提高了读操作的性能，同时也简化了开发者的使用难度。然而，写时复制的特性也带来了一定的内存开销和写操作的性能代价。因此，了解其工作原理和适用场景，对于我们在实际开发中选择合适的集合类至关重要。
在本文中，我们将深入探讨 CopyOnWrite 集合的实现原理、优缺点以及适用场景，帮助读者全面理解和正确使用这些集合类。无论是编写高性能的多线程应用程序，还是解决复杂的并发数据访问问题，掌握 CopyOnWrite 集合的使用技巧，都将为您的开发工作带来极大的助益。
文章目录 1、写时复制的介绍2、写时复制的实现2.1、CopyOnWriteArrayList 数据结构2.2、CopyOnWriteArrayList 读操作2.2、CopyOnWriteArrayList 写时复制2.2.1、add() 函数2.2.2、remove() 函数2.2.3、set() 函数 2.3、CopyOnWriteArraySet 的实现 3、写实复制的特性3.1、读多写少3.2、弱一致性3.3、连续存储3.3.1、数组容器3.3.3、非数组容器 1、写时复制的介绍 写时复制（Copy-on-Write，简称COW）是一种计算机程序设计领域的优化策略。
其核心思想是：如果有多个调用者同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这一过程对其他的调用者都是透明的。
当对容器进行写操作（这里的写可以理解为 “增、删、改”）时，为了避免读写操作同时进行而导致的线程安全问题
我们将原始容器中的数据复制一份放入新创建的容器，然后对新创建的容器进行写操作；而读操作继续在原始容器上进行，这样读写操作之间便不会存在数据访问冲突，也就不存在线程安全问题
当写操作执行完成之后，新创建的容器替代原始容器，原始容器便废弃。 写时复制的主要优点是，如果调用者没有修改该资源，就不会有副本被创建，因此多个调用者只是进行读取操作时可以共享同一份资源。这种策略不仅优化了内存使用，还保护了数据，因为在写操作之前，原始数据不会被覆盖或修改，从而避免了数据丢失的风险。
在 Java 中，CopyOnWriteArrayList 和 CopyOnWriteArraySet 就是使用了这种策略的两个类。这两个类都位于java.util.concurrent 包下，是线程安全的集合类。当需要修改集合中的元素时，它们不会直接在原集合上进行修改，而是复制一份新的集合，然后在新的集合上进行修改。修改完成后，再将指向原集合的引用指向新的集合。这种设计使得读操作可以在不加锁的情况下进行，从而提高了并发性能。
总的来说，写时复制是一种适用于读多写少场景的优化策略，它通过复制数据的方式实现了读写分离，提高了并发性能。但是，它也存在一些潜在的性能问题，如内存占用增加、写操作性能下降以及频繁的垃圾回收。因此，在使用时需要根据具体场景进行权衡和选择。
2、写时复制的实现 2.1、CopyOnWriteArrayList 数据结构 CopyOnWriteArrayList 是 Java 中的一种线程安全的 List 实现，它通过每次写操作时复制底层数组来保证线程安全。CopyOnWriteArrayList 跟 ArrayList 一样，也实现了 List 接口：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0970b35ee47605f2bc6834ce81414677/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc68400bbabe9f1802166df8879fa854/" rel="bookmark">
			怎么分区，新买的电脑只有一个C盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C盘在大多数默认情况下是一台电脑的系统盘，也是创建硬盘分区时，最先被创建的盘。不过在一些特殊情况下，电脑上只有一个C盘。
为什么会出现只有一个C盘这种情况？当我们发现电脑只有一个C盘时，能通过哪些方法去创建其他硬盘分区？本文将详细解答这些问题。
电脑只有C盘：原因分析 “对症下药”才是解决问题的关键，因此我们需要了解电脑上为什么只有一个C盘。
1、硬盘分区时只创建了C盘 在新电脑上安装操作系统时，安装程序会引导用户对硬盘分区。这时，一部分用户只创建了C盘作为系统盘，而没有继续创建其他分区。
2、所有硬盘空间都分配给了C盘 同样地，还是在安装操作系统的过程中，用户出于简化分区管理等目的，把所有的硬盘空间全部分配给了C盘。
3、硬盘分区丢失 硬盘因为人为误操作、病毒攻击、硬盘坏道等原因，导致硬盘上的其他分区全部丢失，只剩C盘。
怎样创建其他硬盘分区 根据上文中总结的“电脑只有C盘”的三大原因，这里有三种对应的措施去解决这些问题。
1、继续创建其他分区 如果硬盘上只创建了C盘，还有大量的未分配空间没有分配，我们可以通过易我分区大师这款专业的硬盘分区管理软件，利用“创建”功能，继续在未分配空间上创建分区。
2、拆分C盘 如果所有的硬盘空间全部分配给了C盘，我们可通过易我分区大师提供的“拆分”功能，把C盘拆分成两个盘或者多个盘。
3、分区恢复 当硬盘因逻辑故障出现分区丢失的情况时，易我分区大师强大的“分区恢复”功能，能帮助我们扫描硬盘，恢复丢失的分区。
有多种原因会导致电脑上只有一个C盘，我们应该具体情况具体分析，先排查造成这种现象的原因，再采取正确的措施去创建或者恢复其他分区。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c10b0cc125444b91d4043d509a2e855/" rel="bookmark">
			机器学习 C&#43;&#43; 的opencv实现SVM图像二分类的训练 (二)【附源码】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本节讲机器学习 C++ 的opencv实现SVM图像二分类的训练，下节讲测试：
数据集合data内容如下：
下载地址为：https://download.csdn.net/download/hgaohr1021/89506900
#include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;opencv2/opencv.hpp&gt; #include &lt;iostream&gt; #include &lt;opencv2/core/core.hpp&gt; #include &lt;opencv2/highgui/highgui.hpp&gt; #include &lt;opencv2/imgproc/imgproc.hpp&gt; #include "opencv2/imgcodecs.hpp" #include &lt;opencv2/core/utils/logger.hpp&gt; #include &lt;opencv2/ml/ml.hpp&gt; #include &lt;io.h&gt; using namespace std; using namespace cv; using namespace cv::ml; void getFiles(string path, vector&lt;string&gt;&amp; files); void get_1(Mat&amp; trainingImages, vector&lt;int&gt;&amp; trainingLabels); void get_0(Mat&amp; trainingImages, vector&lt;int&gt;&amp; trainingLabels); int main() { //获取训练数据 Mat classes; Mat trainingData; Mat trainingImages; vector&lt;int&gt; trainingLabels; get_1(trainingImages, trainingLabels); //waitKey(2000); get_0(trainingImages, trainingLabels); Mat(trainingImages).copyTo(trainingData); trainingData.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c10b0cc125444b91d4043d509a2e855/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96ba548cab9029c934f18f9aec0cb25f/" rel="bookmark">
			持续部署的7个陷阱及其避免方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是持续部署？ 持续部署是一种软件开发实践，其中代码更改会自动部署到生产中，无需开发人员或运营团队的明确批准。这实现了从开发到部署的完全自动化流程，确保新功能、错误修复和更新能够快速提供给最终用户。通过将此流程集成到开发生命周期中，组织可以显著减少软件发布所需的时间和精力。
持续部署的基石是自动化。从代码提交到测试再到部署，每个步骤都是自动化的，从而实现快速一致的交付流程。这种自动化确保只有通过所有预定检查和测试的代码才会被部署，从而最大限度地减少出错的可能性。持续部署是持续交付的演变，是 DevOps 中的一项核心实践，旨在确保软件始终处于可发布状态。
为何持续部署具有挑战性？ 持续部署带来了一些挑战，主要是因为它依赖于自动化，并且需要在软件开发生命周期的各个阶段进行强大、无缝的集成。一个主要障碍是确保自动部署代码的质量和可靠性。由于没有人工把关，整个过程在很大程度上取决于自动化测试的稳健性及其提供的覆盖范围。如果测试套件不全面或未能发现关键问题，则可能导致将有缺陷的代码部署到生产中，影响用户体验和可靠性。
另一个挑战是有效实施持续部署所需的文化和组织变革。传统的开发实践通常涉及具有明确界限的不同角色，例如开发人员编写代码，运营团队负责部署。持续部署模糊了这些界限，需要一种更具协作性的方法，开发人员还负责部署和持续监控他们的应用程序。
持续部署的陷阱及其避免方法 1. 监测和预警不足 一个常见的挑战是监控和警报机制不足。持续部署需要实时监控部署过程和应用程序在生产中的性能。如果没有适当的监控，未被发现的问题可能会对最终用户产生重大影响。有效的警报系统对于及时通知相关团队潜在问题是必不可少的。
组织可以通过实施全面的监控和警报工具来克服这一问题，这些工具可以查看应用程序和系统的运行状况。这些工具应该能够检测异常、性能下降和故障，确保团队能够快速响应以最大限度地减少中断。建立明确的警报阈值并保持明确的警报策略对于主动解决问题至关重要。
2.测试自动化不足 持续部署的基础是确保代码可以随时安全部署，这在很大程度上依赖于自动化测试。然而，测试自动化不足是一个常见的陷阱，可能会破坏这种保证。当自动化测试没有覆盖足够的应用程序功能或无法准确模拟实际使用场景时，缺陷很有可能会渗透到生产中。缺乏全面的测试覆盖可能会导致频繁回滚、用户不满意以及对部署过程失去信任。
为了降低这种风险，组织必须制定全面的自动化测试策略，包括单元测试、集成测试和端到端测试。将测试自动化作为开发过程的一部分而不是事后考虑，可确保新功能和更改始终伴随着相关测试。此外，结合测试驱动开发 (TDD) 等实践可以进一步提高代码库的质量和可靠性，使持续部署更安全、更有效。
3. 糟糕的部署策略 实施无效的部署策略会严重阻碍持续部署过程。缺乏明确回滚机制、分阶段部署或功能切换的策略可能会导致部署失败并对用户体验产生负面影响。经过深思熟虑的部署策略应包括降低风险和确保稳定性的机制。
采用蓝绿部署、金丝雀发布和功能标记等做法可以大大增强持续部署过程的安全性和可靠性。这些策略提供了一个框架，用于逐步引入变更、监控影响并根据需要进行调整，从而最大限度地减少潜在的中断。
4.缺乏回滚机制 缺乏有效的回滚机制是持续部署的一个关键缺陷，因为它直接影响组织应对部署失败或新发布功能意外问题的能力。如果无法快速恢复到应用程序的先前稳定版本，团队可能难以减轻部署问题的影响，从而导致停机时间延长和用户体验下降。
为了避免这种陷阱，组织应将自动回滚功能集成到其部署流程中。这包括为每个部署准备回滚计划，如果监控工具检测到异常或部署不符合某些预定义的成功标准，则可以自动触发该计划。此外，维护全面的变更日志和版本控制系统使团队能够轻松识别并恢复到稳定的应用程序版本，从而最大限度地减少中断。
5. 沟通与协作不足 持续部署需要开发和运营团队之间的有效沟通和协作。协作不足会导致误解和冲突，从而对部署流程和结果产生负面影响。确保无缝合作和沟通对于持续部署的成功至关重要。
采用可增强协作的工具和做法（例如共享仪表板、集成通信平台和定期的跨职能会议）可以弥合团队之间的差距。培养开放和共同责任的文化对于营造持续部署蓬勃发展的环境也至关重要。
6.不可靠的基础设施自动化 不可靠的基础设施自动化对持续部署构成了重大挑战，破坏了部署流程的稳定性和可预测性。这种不可靠性可能源于配置管理不善、基础设施即代码 (IaC) 实践不足或缺乏强大的自动化工具。当基础设施自动化不可靠时，部署可能会变得不一致，并且管理和排除部署环境故障所需的工作量也会增加。
为了解决这个问题，组织应优先采用基础设施自动化方面的最佳实践。这包括利用信誉良好的 IaC 工具通过版本控制代码来管理基础设施，确保一致性、透明度和跨环境复制的便利性。定期审核基础设施配置和自动化脚本有助于识别潜在的不一致或需要改进的领域。此外，结合强大的基础设施变更测试和验证流程可确保自动化可靠并符合持续部署的需求。
7.缺乏持续改进和反馈循环 最后，缺乏持续改进和反馈循环可能会阻碍持续部署的好处。持续改进对于使流程、工具和实践适应不断变化的需求和挑战至关重要。如果没有有效的反馈机制，识别和解决需要改进的领域就会变得困难。
在所有利益相关者之间实施定期审查周期和反馈渠道至关重要。来自用户的持续反馈，加上性能指标和事件报告，为改进持续部署流程提供了宝贵的见解。鼓励学习和适应的文化可确保持续优化和成功。
结论 持续部署代表着向更敏捷、响应更快的软件开发和发布流程的重大转变。它提供了许多好处，包括更快的上市时间、更高的软件质量和更高的反馈响应能力。然而，要实现这些好处，需要意识到并减少潜在的陷阱。
组织可以通过投资自动化测试、监控和警报以及采用有效的部署策略和工具来最大限度地发挥持续部署的优势。此外，培养协作文化、持续改进以及有效利用基础设施和流程中的自动化也是关键。通过应对这些挑战，DevOps 团队可以确保其持续部署计划的成功和可持续性，保持竞争力并满足不断变化的用户需求。
原文链接：7 Pitfalls of Continuous Deployment and How to Avoid Them | HackerNoon
以上就是《持续部署的7个陷阱及其避免方法》的全部内容，喜欢的可以给猴哥点赞👍关注收藏，下期想了解什么知识和功能，可以在评论区留言，欢迎大家积极讨论交流！谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e93f57dcdca95aa61c2cb19c815c0f0/" rel="bookmark">
			Python爬虫实战案例——王者荣耀皮肤抓取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是你们的老朋友——南枫，今天我们一起来学习一下该如何抓取大家经常玩的游戏——王者荣耀里面的所有英雄的皮肤。
老规矩，直接上代码：
导入我们需要使用到的，也是唯一用到的库：
我们要抓取皮肤其实就是相当于抓图片，那么像这种大网站，大批量的图片它基本上是在一个文件里面，那么我们首要目的就是要找到这个文件所在地，打开浏览器调试面板，进行刷新。
刷新之后在XHR中会出现很多文件，那么我们所有皮肤图片的地址是在哪呢？在哪个文件中呢？有些人可能会老老实实的一个个去找，那么我教大家一个邪术，当然并不适用所有的网站哈。
我们要抓取所有英雄的皮肤图片，英雄的英文单词叫啥？Hero，大批量是不是要用列表装起来？那么连起来不就是herolist？我们可以去找一下有没有herolist这么一个文件夹。
可以发现的是，有这么一个文件夹，那么我们秉持着良好的学习探究精神点击进去查看一下，看看到底有没有对应的数据。
有明显的数据集，继续下去！
有些人看到这玩意就懵逼了，这啥啊？这不都乱码了嘛，不要慌，不要急，咱慢慢来，看看数据有没有规律。
可以发现的是，他这个ename是在一个一个的增加。我们先保持怀疑态度，他到底与我们的项目有没有关系，继续去找下一个特征，先暂且搁置一边。
我们要抓取的是一张张大图，也就是高清无码的皮肤图片，比如这样：
但我们放大仔细看发现，这个并不是我们的目标，因为它并不是最大，最高清的，那么到底在哪呢？继续使用邪术！！！高清无码图片，不就是大图片嘛？大的英文单词是啥？Big啊！！！那有没有这么个文件呢？
这不是在图片这块有嘛？我们双击打开看看
唉，非常明显的高清无码大图片了吧，但仔细想想，我现在只是抓到了一张而已，但王者荣耀官网可是有非常多的，那我该如何进行批量抓取呢？
你们还记得我们开头分析的那个文件嘛？就是逐渐+1的ename？这个数字是不是有什么关系呢？我们一起来看下这个目标图片的网址：
这个是517，再来看看另外的。李信这个英雄是：
数字变成了507！我们是不是可以大胆的猜测一下，这个数字就是我们找到的ename？那我们想要拿到每一张高清无码图片的话，是不是只要改变这个数字就行了？邓小平爷爷说过：实践是检验真理的唯一标准！我们进行实践不就知道了？
改成105是廉颇！
改成106是小乔！！！这里就基本确定了，如果你还不敢确定的话，那你可以去进行多次尝试得到证实。言归正传，我们的目标是要下载所有的皮肤图片，那么是不是拿到这个链接地址，然后给他改变数字就行了？直接大胆尝试!
获取到这个文件的所有数据：
获取之后他是在列表里面，那么我们就可以通过循环拿到列表里面的数据：
除了拿到ename之外，我们还拿到了cname，cname是什么？仔细观察的小伙伴应该已经发现了，cname就是每个英雄的名字，我们图片保存下来是不是还得要名字？那么cname已经给我们写好了，我们就不用自己操心了，直接提取即可。
提取下来ename数字之后，直接进行拼接：
这样就拿到了我们每一张图片的地址，直接对他们进行二次请求，为什么呢？就是因为图片是二进制数据，而前面的是json数据，那么现在获取的是图片，就要进行二次请求，进行.content。一切准备就绪，进行保存。
看看效果：
可以看到的是，不仅保存下来了，并且每一个英雄的名字也没有出现差错！你学会没有？大家看完之后一定要去进行操作哦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf15d6b815f1c0745cf1cdb84ca7f105/" rel="bookmark">
			Mac 绝区零下载安装详细教程（IPA砸壳包完美运行）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		就在刚刚绝区零上线了，身为 mac 党我第一时间就在我的 macBook 上成功安装运行绝区零，如图：
整体安装步骤不难，和安装运行原神如出一辙，感兴趣的朋友可以按照下面的教程试一下
1、下载安装 playCover 首先我们想要在 Mac 上安装运行 IOS 手游，需要先在 Mac 上安装 playCover，该软件安装后可以将手机上的 IPA 软件游戏加载并在你的 Mac 上运行，安装也很简单，通过下方链接下载安装包，然后双击打开直接拖拽安装就可以了
playCover 安装包： https://macpa.cn/resource/playCoverNightly
拖拽安装后，前往控制台打开运行
2、下载绝区零 IPA 砸壳包 然后，我们需要下载绝区零的 IPA 砸壳包，也就是 IOS 手机上的解密安装包（正常是加密过的）
绝区零 IPA 砸壳包：https://macpa.cn/resource/id1606359076
3、安装运行 下载完成后，我们将 IPA 包直接拖拽到 playCover 界面内就开始安装了，如下图：
安装完成后，playCover 界面内就会出现该游戏图标，我们先右键点击游戏图标，选择设置-杂项-然后将第一栏分类改正 xxx.games
修改完分类后，我们就可以直接双击图标打开该游戏了，如下图，完美运行：
感兴趣的朋友快来试试吧，另外如果你想通过键盘控制游戏还需要设置键盘映射，具体的映射教程啥的 macpa.cn 上都有可以看一下
不错不错，mac 上又有新游戏玩了，哈哈~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d5a809f4fc4b493a7fac601d7361a22/" rel="bookmark">
			C# Web控件与数据感应之属性统一设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
关于属性统一设置
准备数据源
范例运行环境
AttributeInducingFieldName 方法
设计与实现
如何根据 ID 查找控件
FindControlEx 方法
调用示例 小结
关于属性统一设置 数据感应也即数据捆绑，是一种动态的，Web控件与数据源之间的交互，属性统一设置 ，是指业务规则，通过配置数据，统一对数据控件的属性进行赋值，以达到灵活应用的目的。比如是否为必填写项的设置，以便于统一操作。
如图其中放置了一些标签（Label）控件、（TextBox）文本框控件、（DropDownList）下拉列表框，用于录入及选择一些值，比如现工作单位、参加工作时间、职称、职务等信息。
实际业务中，如不同的用户类型，相同的注册界面，则可考虑某些输入项的必填写属性的变化，如没有工作单位的则无须填写现工作单位和参加工作时间，反之在职人员则必须填写（图中标签带有*号的均为必填写项的提示性标志）。根据统一属性设置，可以显示如下图：
图中的现工作单位和参加工作时间前面的*号不存了，则表示为不必填写项，以避免输入“无” 字来“绕” 过检查。 准备数据源 我们在 MS SQL Server 创建表 cfg_ypz（配置数据视图），其结构如下表：
序号字段名类型说明1fnamenvarchar控件主名（如字段名）2cnamenvarchar属性值 我们假设界面有如下控件，代码如下：
&lt;div &gt; &lt;asp:Label id="l_xgzdw" runat="server"&gt;&lt;/asp:Label&gt; &lt;asp:TextBox id="x_xgzdw" checkSchema="maxlen50" runat="server" /&gt; &lt;asp:Label id="l_cjgzsj" runat="server"&gt;&lt;/asp:Label&gt; &lt;asp:TextBox id="x_cjgzsj" checkSchema="maxlen50" runat="server" /&gt; &lt;/div&gt; 其中，xgzdw （现工作单位）和 cjgzsj （参加工作时间）即为控件主名，而 l_ 前缀为标签提示控件，x_ 前缀为输入控件，那么我们可以初始化配置数据， SQL语句如下：
​ insert into cfg_ypz (fname,cname) values('xgzdw','现工作单位') insert into cfg_ypz (fname,cname) values('cjgzsj','参加工作时间') 最后我们将数据填充到 DataReader ,并生成对应的二维数组。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d5a809f4fc4b493a7fac601d7361a22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28342263c7efa5f4766411d359b99593/" rel="bookmark">
			更加优雅的下载文件 --- http header Content-Disposition 学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更加优雅的下载文件 --- http header Content-Disposition 学习 在响应头中在请求头中a 标签的 download 属性小结 Content-Disposition 在响应头中，告诉浏览器如何处理返回的内容，在表单提交中，说明表单字段信息。
在响应头中 用在响应头中，告诉浏览器如何处理返回的内容。
'Content-Disposition': 'inline' 预览，返回的内容替换当前页面，可使用 a 标签的 target="_blank" 打开新标签。
'Content-Disposition': 'attachment' 下载，使用 a 访问，会把路径作为名字，文件后缀名浏览器自动识别。
'Content-Disposition': 'attachment;filename=filename' 下载，接口指定文件名字。
文件名含有中文，使用 encodeURIComponent 编码，否则报错。
Invalid character in header content [“Content-Disposition”]。
在请求头中 页面上有表单，并且我们选择的表单提交方式为 multipart/form-data 时， Content-Disposition 会出现在请求体中。
可能会这样出现：
Content-Disposition: form-data Content-Disposition: form-data; name="fieldName" Content-Disposition: form-data; name="fieldName"; filename="filename.jpg" 实例代码
a 标签的 download 属性 download 是 a 标签的属性，用于指定下载动作或者指定文件的名字。
&lt;!-- 下载 --&gt; &lt;a href="http://localhost:3000/download" download&gt;download&lt;/a&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28342263c7efa5f4766411d359b99593/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae8842dbd2510d2be87ef148c55156c9/" rel="bookmark">
			前端接入chatgpt,实现流式文字的显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端接入chatgpt,实现流式文字的显示 业务需求： 项目需要接入chatgpt提供的api，后端返回流式的字符，前端接收并实时显示。
相关技术原理： 1. JS中的Stream流: 在JavaScript中，使用Stream流通常指的是处理数据流的一种方式，特别是在Node.js环境下。Stream可以是可读的、可写的、或者既可读又可写的。它们允许数据被处理成块，而不是一次性处理整个数据集，这对于处理大量数据或者来自网络请求的数据非常有用。
但曾经这些对于 JavaScript 是不可用的。以前，如果我们想要处理某种资源（如视频、文本文件等），我们必须下载完整的文件，等待它反序列化成适当的格式，然后在完整地接收到所有的内容后再进行处理。
随着流在 JavaScript 中的使用，一切发生了改变——只要原始数据在客户端可用，你就可以使用 JavaScript 按位处理它，而不再需要缓冲区、字符串或 blob。
2. Stream API 以下是封装的用来调用的Stream API的核心代码，为了方便调用封装成了Hook组件。有以下组成部分：
useStream Hook: 接受一个URL和一个参数对象。这个对象可以包含几个回调函数（onFirst, onNext, onError, onDone）和一个fetchParams对象，用于自定义fetch请求。startStream 函数: 被useStream内部调用，用于实际发起fetch请求，并使用ReadableStream的reader来逐块读取数据。它处理流数据的读取，并根据提供的回调函数处理数据块、错误和流结束。 import React, { useCallback, useState, useRef, useEffect } from 'react'; import 'abortcontroller-polyfill'; import { getLoginToken } from '../../utils/localStorage.js'; import {getRoleFromLocation} from '../commonUtils.js'; /** * React hook for the [Streams API](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API). * Use this hook to stream data from a URL. * @param {string} url * @param {object} [params] * @param {function(Response)} [params.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae8842dbd2510d2be87ef148c55156c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71a561aaf58329393be8e3c8ade50b36/" rel="bookmark">
			有手就行，轻松本地部署 Llama、Qwen 大模型，无需 GPU
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用 CPU 也能部署私有化大模型？
对，没错，只要你的电脑有个 8G 内存，你就可以轻松部署 Llama、Gemma、Qwen 等多种开源大模型。
非技术人员，安装 Docker、Docker-compose 很费劲？
不用，这些都不需要安装，就一个要求：有手就行～
今天主要为大家分享保姆级教程：如何利用普通个人电脑，本地私有化部署 Qwen 大模型。
一、Ollama 与 Qwen7B 安装和使用 （一）下载 进入下载地址，目前支持 Mac、Windows、Linux 以及 docker 部署，本次演示，主要针对 Mac。
下载地址：https://github.com/ollama/ollama
我已经为大家提前下载好了 Mac、Windows 的安装包，公众号回复 ollama 领取。
（二）安装 Ollama 1、下载到本地，并解压后，双击 Ollama 图标。
2、点击 Move to Applications ，按照建议，将其移动到应用程序文件夹下。
3、按照从左到右的顺序执行这三步。到这 Ollama 安装完成了。
（三）安装模型 作为国内的优质大模型，Qwen 对于中文的支持力度还是很强的，最终选择用它来试手。
大家也可以尝试选择自己喜欢的模型，比如 Llama3、Gemma 等等。
1、进入模型仓库
地址：https://ollama.com/library
2、搜索对应模型。发现目前有 Qwen 0.5B ～ 110B 可供使用。
因为内存不够用，最终选择下载 Qwen:7b，大家可以按照自身硬件情况下载模型。
可以使用图中对应型号的命令，进行下载。7b 下载命令为：ollama run qwen:7b
官方建议： 至少有 8 GB 可用内存来运行 7 B 型号，16 GB 来运行 13 B 型号，32 GB 来运行 33 B 型号。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71a561aaf58329393be8e3c8ade50b36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d913649b2a2230b4100478ee5d948c44/" rel="bookmark">
			【TS】TypeScript 入门指南：强大的JavaScript超集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页: 鑫宝Code
🔥热门专栏: 闲话杂谈｜ 炫酷HTML | JavaScript基础 ​💫个人格言: "如无必要，勿增实体" 文章目录 TypeScript 入门指南：强大的JavaScript超集一、TypeScript 简介1.1 什么是 TypeScript？1.2 TypeScript 的目标 二、TypeScript 的核心特性2.1 类型系统基本类型接口与类型别名 2.2 类与面向对象编程2.3 模块系统2.4 高级特性 三、TypeScript 的工作流程四、TypeScript 的优势五、实战演练：开始使用TypeScript5.1 安装与配置5.2 编写第一个TypeScript程序5.3 使用IDE支持 六、总结 TypeScript 入门指南：强大的JavaScript超集 在现代Web开发领域，JavaScript作为浏览器的原生语言，其重要性不言而喻。然而，随着项目规模的扩大，JavaScript的动态类型特性逐渐显现出一些不足，比如难以维护的大规模代码库中的类型错误、IDE的智能提示不准确等问题。为了应对这些挑战，Microsoft于2012年推出了TypeScript——一种为JavaScript添加了静态类型的超集语言。本文将深入浅出地介绍TypeScript的基本概念、优势、核心特性以及如何在实际项目中应用它，旨在帮助开发者理解并掌握这一强大的工具。
一、TypeScript 简介 1.1 什么是 TypeScript？ TypeScript是一种开源编程语言，它在JavaScript的基础上添加了静态类型定义，支持类、接口、模块等面向对象编程特性。TypeScript代码最终会被编译成纯JavaScript代码，这意味着任何能够运行JavaScript的环境都能运行TypeScript程序。因此，TypeScript不仅继承了JavaScript的所有优点，还解决了JavaScript的一些痛点问题，如类型安全、开发工具的智能提示等。
1.2 TypeScript 的目标 提升开发效率：通过静态类型检查，在编码阶段就能发现潜在错误。增强代码可维护性：类型注解提供了更明确的文档说明，便于团队协作。支持现代开发工具：IDE能基于类型信息提供更智能的自动完成和重构功能。兼容现有JavaScript生态系统：无缝集成现有的JavaScript库和框架。 二、TypeScript 的核心特性 2.1 类型系统 TypeScript最显著的特性就是它的静态类型系统。这允许开发者为变量、函数参数和返回值指定类型，从而在编译阶段就能捕获类型不匹配的错误。
基本类型 TypeScript支持JavaScript的所有基本类型，如number、string、boolean等，并增加了枚举enum、any（用于表示任何类型）、void（无返回值的函数）、null与undefined等类型。
接口与类型别名 接口(interface)：用于定义对象结构的蓝图，确保遵循特定的形状。类型别名(type): 为复杂类型定义一个新的名字，提高代码的可读性和复用性。 2.2 类与面向对象编程 TypeScript全面支持面向对象编程特性，包括类的定义、继承、封装和多态性，使得构建复杂的大型应用程序更加方便。
2.3 模块系统 TypeScript引入了ES6模块语法，允许将代码组织成独立的模块，提高了代码的重用性和管理效率。
2.4 高级特性 泛型：允许编写可重用的组件，这些组件可以处理多种数据类型。装饰器：一种特殊类型的声明，可以被附加到类声明、方法、访问器、属性或参数上，用于修改类的行为。异步编程：支持async/await语法，简化异步操作的编写。 三、TypeScript 的工作流程 编写代码：开发者使用TypeScript编写带有类型注解的代码。编译：TypeScript编译器(tsc)将TypeScript代码转换为JavaScript代码。运行：生成的JavaScript代码在浏览器或Node.js环境中执行。 四、TypeScript 的优势 提高代码质量：静态类型检查有助于提前发现错误。提升开发体验：IDE的智能提示更加精确，加快开发速度。易于维护：类型定义增强了代码的可读性和可维护性。良好的兼容性：与现有的JavaScript生态无缝集成。 五、实战演练：开始使用TypeScript 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d913649b2a2230b4100478ee5d948c44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5efb6cef4068c25ed5ca5658b6b7b776/" rel="bookmark">
			【数据结构与算法】堆排序算法原理与实现：基于堆实现的高效排序算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💓 博客主页：倔强的石头的CSDN主页 📝Gitee主页：倔强的石头的gitee主页
⏩ 文章专栏：《数据结构与算法》
期待您的关注
​
目录
一、引言
堆排序的简介
堆排序的特点
二、堆的概念
三、堆排序算法的原理
四、堆排序的步骤
🍃构建堆 🍃交换与调整
🍃重复过程
五、堆排序的性能分析
🍃时间复杂度：
🍃空间复杂度：
六、示例代码
七、总结
一、引言 堆排序的简介 堆排序（Heap Sort）是一种基于堆数据结构实现的排序算法。利用堆这种数据结构的高效性，通过构建和调整堆来实现排序，是一种性能优秀的排序算法。
堆排序的特点 时间复杂度：堆排序的最坏、最好、平均时间复杂度均为O(nlogn)，其中n是待排序元素的数量。稳定性：堆排序在排序过程中相等的元素不会交换位置，因此它是稳定的排序算法。选择排序：堆排序是一种选择排序，它总是选择当前未排序部分的最大（或最小）元素进行排序。 二、堆的概念 关于堆的详细介绍，参考前置文章
【数据结构与算法】探索数组在堆数据结构中的妙用：从原理到实现-CSDN博客
三、堆排序算法的原理 堆排序的基本思想是将待排序的序列构建成一个堆，然后依次将堆顶元素与堆尾元素交换，并将堆的大小减小1，再对剩余的堆进行调整，使其满足堆的性质。重复这个过程，直到堆的大小为1，此时排序完成。 四、堆排序的步骤 🍃构建堆 借助建堆算法，降序建小堆，升序建大堆，可以选择向上或者向下调整算法
向上调整建堆的原理：
模仿堆的插入操作来构建堆，从第一个子结点开始，将它看做是新插入的元素，向上调整至满足堆的性质，然后依次往后走，直到最后一个叶子节点完成上述调整
向下调整建堆的原理：
从最后一个父结点开始，先保证它和左右子树成为堆，然后依次往前走，保证每个父结点与左右子树成堆，直到最后根结点与左右子树成堆
关于建堆的向上调整算法和向下调整算法有时间复杂度推导
限于篇幅，这里就不展开推导了，直接给出结论
向下调整建堆的时间复杂度为O（N）向上调整算法的时间复杂度为O（n*logN） 向下调整算法优于向上调整，所以应该选择向下调整算法
这里分别给出向下调整建小堆和向下调整建大堆的算法
（如果关于向上调整算法和向下调整算法有疑惑，建议了解完堆的这篇文章之后再来看
【数据结构与算法】探索数组在堆数据结构中的妙用：从原理到实现-CSDN博客）
void Adjustdownsmall(DataType* a, int parent, int size)//向下调整建小堆算法 { int child = parent * 2 + 1;//先假定左孩子小 while (child &lt; size)//循环条件是未调整至叶子节点 { if (child + 1 &lt; size &amp;&amp; a[child + 1] &lt; a[child])//如果右孩子存在且更小，改变为右孩子 child++; if (a[child] &lt; a[parent])//如果子节点小于父节点，交换位置 { Swap(&amp;a[child], &amp;a[parent]); parent = child; child = parent * 2 + 1; } else break; } } void Adjustdownbig(DataType* a, int parent, int size)//向下调整建大堆算法 { int child = parent * 2 + 1;//先假定左孩子大 while (child &lt; size)//循环条件是未调整至叶子节点 { if (child + 1 &lt; size &amp;&amp; a[child + 1] &gt; a[child])//如果右孩子存在且更大，改变为右孩子 child++; if (a[child] &gt; a[parent])//如果子节点大于父节点，交换位置 { Swap(&amp;a[child], &amp;a[parent]); parent = child; child = parent * 2 + 1; } else break; } } 🍃交换与调整 建堆之后，就是排序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5efb6cef4068c25ed5ca5658b6b7b776/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/356c588977773abeb386d756e59cf297/" rel="bookmark">
			AI 入门：Kimi 详细使用手册，Kimi 使用效率提升 60%（附 16 个高阶提示词）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当前AI文字大模型领域，ChatGPT4.0无疑是最强大。然而，最近最火爆的大模型非国产Kimi莫属。
相较于其它大模型，Kimi 最大的优势在于，超长文本输入，支持200万汉字，是全球范围内罕见的超长文本处理工具，用户无需分段处理资料。
以及强大记忆功能，可以长时间保持对话完整性和连贯性。还有其擅长超长文阅读、资料整理、文件解读、辅助编程和文案写作，以及操作简洁直观，文件拖入或网址粘贴即可提问，
在我看来是ChatGPT的中文最好的平替代品，这使 Kimi 一经发布便迅速火出圈，广受用户好评，并自发传播，成为2亿A股股民的追捧。
一、Kimi功能亮点 智能搜索：搜索实时信息，迅速整合，给出详尽回答，并提供搜集到的信息来源，让对话兼具丰富性和准确性。高效阅读：长文快速摘要，打破语言壁垒，帮你精准理解文献书籍、长篇报告、复杂合同、网页长文，提供深入洞察和分析。专业解读文件：无论是金融分析、法律咨询还是市场调研，Kimi 都能以专业水准提供支持。超长文档、多个文件，都可以快速摘要、翻译、答疑，支持上传 PDF、Word、Excel、PPT、TXT 文件和图片。整理资料：无论是堆积如山的发票，还是复杂冗长的会议记录，Kimi 都能智能识别整理，自动提取关键点，让资料整理不再繁琐，信息一目了然。辅助创作：根据你提供的网页链接、文件、指令，Kimi 可以帮助你梳理大纲、续写文章、创作文案、写作周报、撰写方案，成为你的内容创作手脚架，提供无限灵感。编程助手：Kimi 可以帮你快速阅读 API 文档，定位所需信息，还可以根据你的需求生成代码、快速 Debug，覆盖 Python、C++、Java 等多种编程语言。 二、Kimi适用人群 学术科研人群：快速阅读并深入理解大量文献，用母语掌握文献的精髓，解释复杂学术概念，分析研究结果，撰写论文，回应审稿人的建议。互联网从业者：高效搜集信息，辅助竞品分析、运营策划等方案撰写，并提供洞察。程序员：辅助编程、问题解答、代码注释、API 文档阅读，支持 Python、C++、Java 等多种编程语言，帮助你学习编程、解决技术问题。自媒体与内容创作者：学习特定公众号、文件、网页链接的风格，辅助创作；快速搜集创作所需信息，提供丰富的资料与灵感。法律从业人员：高效处理大量案件资料、整理证据、梳理法律政策，协助你撰写法律文书和报告，提升工作效率。 三、 Kimi 使用指南 接下来大全详细讲解一下，kimi 的使用入口，以及使用技巧。
1、使用入口 1）手机端，可以在各大应用市场，或者微信小程序搜索“Kimi 智能助手”使用。
2）网页端使用，打开网址即可：https://kimi.moonshot.cn
2、使用技巧 1）正常对话
这里可以输入你想知道的任何问题，Kimi 都会给你解答，我个人体验效果不错。
2）智商问题
可以看到，几个问题回答的都不错，尤其是最后一道很多模型包括 GPT 3.5 都回答错误的问题，也回答对啦。
3、智能搜索
Kimi 有联网功能，这就相当于 AI 搜索引擎了，可以直接获取多个网址汇总的内容，给你答案，省去你整理的烦恼。
这里有个小技巧，如果想限定某个网页的搜索结果，可以直接告诉 Kimi 即可，来看看我们限定搜索豆瓣效果，也可以使用浏览器常用语法：site。
4、解读文档
Kimi 超长文档、多个文件，都可以快速摘要、翻译、答疑，支持上传 PDF、Word、Excel、PPT、TXT 文件和图片，我们来看看效果。
我上传的是一份 30 多万字的小说，但是 kimi 没有读完，只读了 20 万字，网上查了才得知，这个还是内测阶段。
长文本阅读一本书的好处是，我们随时可以针对书中的内容进行提问，而无需自己去翻书找答案。
5、解析图片
还有一个炸裂的功能，就是直接可以解析一张图片的内容，然后有调理输出内容，我们来看看原图：
3、独特功能 1、常用语
这个就相当于快捷键，让 Kimi 记住一大串提示词，然后只需要几个词就可以唤醒，我们来看看效果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/356c588977773abeb386d756e59cf297/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b042ec9403db7783e936e57e18ae9174/" rel="bookmark">
			力扣hot100 -- 贪心算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👂 ▶ 逍遥叹 - 胡歌&amp;沈以城【Mashup】 (163.com) 👂 庐州月 - 许嵩 - 单曲 - 网易云音乐
2.7 小时，加上写博客，4 道题，😂 -- 希望二刷时，可以 3 小时，8 道题....
目录
🍉买卖股票的最佳时机
🌼跳跃游戏
🍓跳跃游戏 II
🎂划分字母区间
🍉买卖股票的最佳时机 121. 买卖股票的最佳时机 - 力扣（LeetCode）
贪心：维护目前为止的最小值
class Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices) { int minPrice = 1e4; // 维护一个最小值 int ans = 0; for (auto x : prices) { minPrice = min(minPrice, x); ans = max(ans, x - minPrice); } ans = ans &lt; 0 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b042ec9403db7783e936e57e18ae9174/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/936c5a5752c2963361936608f2e5daed/" rel="bookmark">
			财务RPA工具——探索用于财务自动化的常见RPA工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近年来数字化浪潮正席卷各大行业，数字化转型成为企业通向成功的一条必经之路。而财务管理作为企业经营过程中的有力支撑，是企业数字化转型的一个关键切入点。如今越来越多的数字技术在现代财务工作中得以应用，以提升财务工作效率，RPA由于应用条件与财务工作的业务特点高度匹配，成为众多财务人的“左膀右臂”。以下金智维将介绍几个常用的财务RPA工具。
1、薪资结算机器人 机器人可以按照预设从不同系统中自动收集员工工时、加班情况、请假记录等数据，并进行精确整合，再根据公司薪资政策和法规要求，进行工资和福利的计算，若涉及到税务计算，机器人会按税法规定计算每个员工的税款。完成结算后，机器人会自动生成薪资报表、工资单等相关文档供公司内部审计。审核无误后，由机器人触发相应的支付流程，并生成支付凭证。
2、财务报表机器人 财务报表机器人可以自动导出系统数据、发送催收邮件、进行数据汇总并生成最后的财务报告，辅助集团公司总部的财务部门完成每月的报表汇总工作，通过自动化流程提高财务数据汇总的工作效率。
3、报税机器人 报税机器人可以在企业编制好财务报表数据后，在税期内按照预定的计划，自动登录国家税务总局、自然人电子税务局平台完成具体税种报税申报全过程，并将报税申报表信息按照标准格式自动下载归档，实时汇总报税申报进度并进行反馈处理。
4、税务信息智能管理机器人 通过对接报税机器人，税务信息智能管理机器人能够提供更全面的报税信息管控，对纳税主体在国家税务总局、自然人电子税务局平台上涉及的所有税种的报税进展进行实时跟踪及预警提醒，对报税申报信息进行统一查询、分析、管控和处置，并对外提供数据查询服务与数据对接服务。
5、网银机器人 网银机器人可以按预定的计划，自动登录多个网银账户，对各个网银账户进行余额查询、数据归档、流水清单和回单下载。企业还可以通过网银机器人管理所有银行账户的资金动态，下载并管理所有网银流水和回单，并可根据业务要求和公司资金管理的需求自动生成台账和报告。
6、资金管理机器人 机器人可以对数据层、应用层和外部接口数据进行统一整合，实现对银行机构、银行版本、银行账户、账户流水、账户回单的集中管理。通过资金管理机器人，企业和财务人员能够对资金进行集中监控和运营，防范资金运营中的风险事件，提高资金运营效益。
7、合同录入机器人 合同录入机器人能够结合RPA与OCR技术，自动识别合同信息并完成信息录入，对比销售订单进行正确性验证，提交进入复核环境。完成任务后，机器人将自动生成日志记录，并对合同管理员予以回复。
8、差旅报销机器人 机器人按照预设从各个渠道收集员工提交的差旅报销单据，并对其中的数据进行自动录入、清理和格式化操作，提取其中的关键信息，并对费用进行分类，以便后续的审批和核算过程。由机器人进行合规性审查，确保报销流程符合相关规定。最后由机器人执行差旅费用的计算，并生成差旅报销单，自动启动审批流程。
9、自动开票机器人 机器人可在后台自动登录各个相关系统，自动读取开票需求、校验开票信息并完成开票操作，财务人员只需在发票打印完成后审核和盖章即可，大大节省开票时间，提升工作效率。
10、发票验真机器人 发票验真机器人能够从各个渠道采集发票数据，并进行数据提取和清理，以确保数据的准确性。由机器人自动登录国税局发票查验平台进行发票查验，机器人会将验证通过的发票发送给相关人员进行最终审批，并将查验结果录入企业管理系统，如发现问题，机器人会触发异常处理流程，通知相关人员进行处理。
在RPA技术的助力下，企业财务管理模式正经历一场巨大的变革，企业在应用财务RPA工具之前，需明确自身业务特征，识别工作流程中的痛点及可能运用RPA的业务场景，正确评估和制定RPA策略方案。金智维深耕企业级RPA技术十余年，始终坚持产品与场景双轮驱动，凭借雄厚的技术实力和深厚的经验积累，能够洞察用户痛点，“超用户所想，为用户所用”，多年来为各行业提供了专业的一站式数字员工整体解决方案，成为千行万业数字化转型的信赖之选。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d5f7beb5d9bd39e278015512151de72/" rel="bookmark">
			苹果电脑畅玩《魔兽世界巫妖王之怒》怀旧服国服 PD虚拟机能玩魔兽世界吗 Mac电脑运行Windows游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024年6月27日，万众期待的经典游戏魔兽世界重启中国服务器，并开启了免费畅玩服务，一直到7月10日都不会消耗游戏时间，不用充值点卡，很多Mac电脑用户也想第一时间回归体验。
特殊说明：由于魔兽世界国服刚刚回归，所以进服人数过多，导致可能存在无法进入游戏的情况，这并不是软件问题导致，请耐心排队等待。经网友测试分享，MacBook Air M1 8GB 低配置版本也可以成功安装运行游戏。
虽然魔兽世界本身是跨平台的游戏，支持Windows和Mac系统，由于官方版本更新不同步等情况，有些玩家可能会考虑在虚拟机中运行游戏，以便同时享受其他操作系统的优势。本文将探讨如何在苹果电脑畅玩《魔兽世界巫妖王之怒国服》怀旧服教程。
魔兽世界是暴雪娱乐（Blizzard Entertainment）开发的，支持Mac和Windows两大平台。要在Mac上直接运行魔兽世界，可以按照以下步骤进行：
一、直接在Mac上玩魔兽世界 1. 下载和安装游戏客户端：
- 访问暴雪并下载Battle.net应用程序。
- 安装Battle.net应用程序，并使用你的暴雪账号登录。
- 在Battle.net应用程序中找到魔兽世界，点击安装，选择适合的安装路径并等待安装完成。
2. 配置游戏设置：
- 安装完成后，打开魔兽世界客户端，进入游戏设置。
- 调整图像设置和其他选项，以获得最佳的游戏体验。
3. 运行游戏：
- 点击“播放”按钮，开始游戏，享受魔兽世界的奇幻冒险。
二、使用Parallels Desktop虚拟机玩魔兽世界 Parallels Desktop（简称PD）是一款流行的虚拟机软件，允许Mac用户在其设备上运行Windows应用程序。一些玩家可能会问，是否可以在PD虚拟机中运行魔兽世界。以下是具体步骤和注意事项：
1. 安装Parallels Desktop：
- 下载并安装Parallels Desktop。
Parallels Desktop 19 for Mac标准永久版免费体验：https://souurl.cn/xmgwMz
- 根据提示安装Windows操作系统，配置好虚拟机环境。
2. 安装Windows和Battle.net：
- 在虚拟机中启动Windows操作系统。
- 下载并安装Battle.net应用程序。
- 在Battle.net应用程序中下载并安装魔兽世界。
3. 配置虚拟机设置：
- 确保分配足够的CPU和内存资源给虚拟机，以确保游戏流畅运行。
- 开启3D加速功能，提高游戏的图形性能。
4. 运行魔兽世界：
- 在虚拟机的Windows环境中打开魔兽世界客户端，开始游戏。
三、使用CrossOver类虚拟机软件玩魔兽世界 准备工作：
1、下载CrossOver软件。
CrossOver 24 Mac中文免费安装包：https://souurl.cn/mWK48N
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d5f7beb5d9bd39e278015512151de72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/888d058281936decda5ce8bff49b8473/" rel="bookmark">
			大数据、人工智能、云计算、物联网、区块链序言【大数据导论】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各位大佬好 ，这里是阿川的博客，祝您变得更强 个人主页：在线OJ的阿川
大佬的支持和鼓励，将是我成长路上最大的动力
阿川水平有限，如有错误，欢迎大佬指正
本篇序言前 必看
【大数据导论】—大数据序言
这是目录 五大前沿领域云计算物联网人工智能人工智能产业 区块链 五大前沿领域 其中关于大数据序言
在如今这个数据爆炸的时代中，三大领域与数据息息相关（大数据、云计算、互联网）
云计算 先介绍IT资源 ：
数据中心
把大量的IT资源 存放到一个空间中，该空间称为数据中心
云计算离不开数据中心（目前中国最大的数据中心在贵州）
云计算定义
云计算的本质是：整合和优化各种IT资源，并通过网络廉价的提供给用户
技术上（次点）
大规模分布式并行计算技术
商业上（重点）
初期零成本，瞬间可获得后期免维护，使用成本低供应IT资源"予取予求" 云服务模式
公有云（即基础设施层） 面向所有用户提供服务 私有云（即平台层） 向特定用户提供服务 混合云（即应用层） 综合公有云和私有云的特点 目前全球 云计算厂商排名
亚马逊 微软 阿里云 云计算产业
其中硬件与设备制造 其中基础设施运营 其中软件与解决方案供应商 其中基础设施即服务 其中平台即服务 其中软件即服务 其中云安全 其中云计算交付/咨询/认证 物联网 物联网技术架构
其中感知层 包含许多传感器（例如温度传感器，湿度传感器，摄像头、GPS设备等）
网络层包含各种类型的网络（例如互联网、移动通信网络、卫星通信网络等）
处理层包含数据存储和分析平台
应用层满足各种应用的需求（例如智慧农业、智慧医疗、智能工业等）
物联网的关键技术
具体点
二维码
RFID标签
传感器
各种类型的网络连接
抽象点
其中网络与通信技术包含： 短距离无线通信技术
远程通信技术
物联网产业
核心感应器件提供商感知层末端设备提供商网络提供商软件与行业解决方案提供商系统集成商运营及服务提供商 未来两大前沿领域（人工智能、区块链）也与数据高度相连
人工智能 人工智能定义
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/888d058281936decda5ce8bff49b8473/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ba970180963d6d960c1aa51847b0312/" rel="bookmark">
			windows安装两个或多个JDK，并实现自由切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、前期准备二、安装三、注意事项四、配置环境变量五、测试 前言 在工作中遇到不同的项目需要使用不同版本的JDK,搜索查询资料后总结如下，按照这种方式可以安装两个或者更多版本（根据自己需求下载安装即可）
一、前期准备 我这里用两个JDK来做演示，分别是JDK8和JDK17(本人已安装JDK8，所以这里只演示JDK17的安装)。首先去官网下载所需要的对应版本的JDK安装包或者压缩包。
二、安装 下载完成后，安装包的话直接下一步安装到自己想要的目录即可，压缩包的话解压到自己想要的目录即可。
三、注意事项 解压版跳过此项
如果是安装版，请务必到以下位置删除这两个文件夹
C:\Program Files (x86)\Common Files\Oracle\Java\javapath
C:\Program Files\Common Files\Oracle\Java\javapath
四、配置环境变量 在系统变量中新建一个CLASSPATH，添加变量值如下 .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar 在系统变量里面找到Path选项，编辑，加入以下变量值 添加两条
%JAVA_HOME%\bin %JAVA_HOME%\jre\bin 在系统变量里新建3个JAVA_HOME 三个JAVA_HOME分别是
变量值JAVA_HOME%JAVA8_HOME% （这里这样写是使用JAVA8）JAVA8_HOMED:\java\jdk.1.8.0_221 (写自己的java8的安装目录)JAVA17_HOMED:\java\jdk-17 (写自己的java17的安装目录) JDK的安装目录复制到bin的上一级就可以了
五、测试 1. 切换JDK版本
修改如下图所示的值，修改为你想用的JDK的版本即可
2. 测试
Win + R 输入cmd打开命令提示符，键入
java -version
就可以查看你现在所启用的jdk版本信息（注意：修改完环境变量后，必须重新打开一个新的cmd窗口进行查看！！！）
参考：http://t.csdnimg.cn/5mR0B 如有侵权，联系删除。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebe3a8171bb8f14f84dbf81840a5b9c2/" rel="bookmark">
			zxing-cpp&#43;OpenCV根据字符串生成条形码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编译构建 需要使用到 CMake、Git、GCC 或 MSVC。
github 链接：https://github.com/zxing-cpp/zxing-cpp
编译之前请确保：
确保安装了 CMake 版本 3.15 或更高版本。
确保安装了与 C++17 兼容的编译器(最低VS 2019 16.8 / gcc 7 / clang 5)。
编译构建很简单，如同官网：
git clone https://github.com/zxing-cpp/zxing-cpp.git --recursive --single-branch --depth 1 cmake -S zxing-cpp -B zxing-cpp.release -DCMAKE_BUILD_TYPE=Release cmake --build zxing-cpp.release -j8 --config Release 如果出错那就只能自行解决，不过不用担心，我们已经提供了编译完成的静态库。
此库不支持动态库，我们提供了 debug 和 release 两种 .lib。
之后就是正常的引入静态库的环境配置了，不再介绍。
OpenCV ZXing 理论上不依赖 OpenCV 等其它库，不过涉及图形操作，我们的第一选择基本也就是 OpenCV 了。实测 OpenCV3 与 OpenCV4 都可使用。
OpenCV + Zxing 根据字符串生成 PDF417 条形码 #include &lt;opencv2/opencv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebe3a8171bb8f14f84dbf81840a5b9c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb07a489332cc2a7e476e7f4278bd707/" rel="bookmark">
			Spring AI 1.0.0 新变化，从 0.8.1 如何升级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring AI 1.0.0-M1 版本已经发布，距离 1.0.0 正式版又更近了一步。同时这也意味着，Spring AI 1.0.0 的 API 已经基本确定，不会发生大的改动。这里介绍一下，相对于上一个发布版本 0.8.1，Spring AI 1.0.0 的一些重要的变化。
首先是把与 AI 模型进行交互的 ModelClient 拆分成了两个接口。Model 接口负责与模型进行交互，承接了之前的 ModelClient 的功能。Client 则负责创建调用 Model 时的请求，以及对 Model 返回的结果进行解析。每个不同类型的 Model ， 都应该有与之对应的 Client。目前来说，只提供了与 ChatModel 对应的 ChatClient。ChatClient 提供的是流式 API 接口，在设计上类似 Spring 中已有的 RestClient 和 WebClient。
ChatClient 由 ChatClient.Builder 来负责创建。在创建时，可以配置 ChatClient 的默认行为。ChatClient 的流式 API，可以对发送给 ChatModel 的 Prompt 进行配置，并对返回的 ChatResponse 进行解析。
使用了 ChatClient 的流式 API 之后，调用大模型并返回结果的基本方式如下所示。
String output = chatClient.prompt().user(input).call().content(); 第二个改动是增加了 RequestResponseAdvisor 接口。这个接口的作用是对发送给模型的请求和得到的响应，进行统一的处理。从接口名称中可以看出来，用到的是 AOP 的思想。多个 Advisor 可以串联成一个链条，依次对请求和响应进行处理。多个 Advisor 通过一个 Map 来共享上下文。Spring AI 提供了一些内置的 RequestResponseAdvisor 实现，包括在请求中添加历史消息，以及实现基于向量数据库的问答功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb07a489332cc2a7e476e7f4278bd707/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/203/">«</a>
	<span class="pagination__item pagination__item--current">204/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/205/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>