<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27d969bfb68f818d8f150df4dd0fbb47/" rel="bookmark">
			Go Module详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 基本介绍相关环境变量Go Module的使用初始化项目（go mod init）管理依赖项（go mod edit）获取依赖项（go mod download）整理依赖项（go mod tidy）导入vendor目录（go mod vendor）查询依赖原因（go mod why）查询依赖结构（go mod graph）验证依赖项完整性（go mod verify） go get命令go list命令 基本介绍 基本介绍
Go Module是Go语言的官方依赖管理解决方案，其提供了一种简单、可靠的方式来管理项目的依赖关系。Go Module于Go1.11发布，并于Go1.14准备正式用于生产，Go官方也鼓励用户从其他的依赖管理工具迁移到Go Module。
Go Module主要解决了如下几个问题：
依赖管理：在引入Go Module之前，Go语言没有官方的依赖管理系统，开发人员需要手动下载和管理项目的依赖包。Go Module中提供了一种标准化的依赖管理解决方案，使开发人员能够轻松定义、下载和更新项目的依赖项。版本冲突：在原始的GOPATH模式中，多个项目共享同一个全局的依赖包集合，往往会导致版本冲突。Go Module中引入了模块版本的概念，每个模块都有明确的版本号，并通过go.mod文件中的版本要求来解决版本冲突问题。可重复构建：在GOPATH模式中，项目的构建结果受到GOPATH环境变量的影响，同一项目在不同环境下可能产生不一致的构建结果。Go Module中使用go.mod文件明确指定项目的依赖关系和版本要求，确保在不同环境下构建结果的一致性和可重复性。跨模块引用：在GOPATH模式中，无法直接引用其他项目中的代码，必须将代码复制到自己的项目中，或使用第三方工具来管理跨项目的共享代码。Go Module中允许直接引用其他模块中的代码，简化了代码的复用和共享，提高了开发效率。私有库支持：在GOPATH机制中，私有库的使用相对复杂，需要设置特殊的目录结构或使用第三方工具。Go Module中提供了对私有库的官方支持，开发人员可以使用私有代码块，并通过身份验证或代理来管理私有模块的访问权限。 相关环境变量 相关环境变量
通过go env命令可以查看与Go相关的环境变量信息。如下：
其中，与Go Module相关的环境变量主要有如下几个：
GO111MODULE：用于启用或禁用Go Module功能。设置为on和off分别表示启用和禁用Go Module功能，设置为auto表示根据当前目录下是否包含go.mod文件来决定是否启用Go Module功能。GOPROXY：用于设置模块代理的地址，多个代理地址之间使用逗号分隔。设置为off表示禁用模块代理，direct表示从源代码仓库下载模块。GONOPROXY：用于设置不需要通过代理访问的模块路径列表，多个模块路径之间使用逗号分隔，这些模块将会直接从源代码仓库下载。GOSUMDB：用于配置Go语言中模块验证的校验和的数据源。GONOSUMDB：用于设置不参与校验和验证的模块路径列表，多个模块路径之间使用逗号分隔。GOPRIVATE：用于设置不在公共代码仓库上的私有模块路径列表，多个模块路径之间使用逗号分隔。 说明一下：
在使用Go Module之前，需要确保GO111MODULE环境变量的值不为off，如果Go Module功能未启用，可通过go env -w GO111MODULE=on命令开启Go Module功能。如果将GOPROXY环境变量的值设置为off，意味着Go Module不会通过代理服务器来获取模块，此时Go Module默认会尝试从模块的导入路径所对应的源代码仓库下载模块，比如要下载的模块的导入路径为github.com/username/module，那么Go Module会直接从GitHub上的github.com/username/module仓库下载模块的代码。GOPROXY环境变量的值默认为https://proxy.golang.org,direct，在GOPROXY最后设置direct，意味着当无法从列出的代理服务器中获取所需模块时，直接从源代码仓库获取模块，即尝试使用获取模块的默认方式进行获取，确保代理服务器无法获取的模块，仍然能够从源代码仓库获取。https://proxy.golang.org是Go团队提供并由Google托管的Go模块代理服务，https://goproxy.cn是中国开发者提供的Go模块代理服务，为了提高Go Module下载模块的速度，通常会将GOPROXY的值设置为https://goproxy.cn,direct。 Go Module的使用 初始化项目（go mod init） 初始化项目
go mod init命令用于初始化一个新的Go模块，该命令会在当前目录下创建一个名为go.mod的文件。如下：
生成的go.mod文件如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27d969bfb68f818d8f150df4dd0fbb47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3369ac80b0a1401d721835d22cd3e2d6/" rel="bookmark">
			通过语言大模型来学习LLM和LMM（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、大模型学习 新的东西，学习的东西就是多，而且最简单最基础的都需要学习，仿佛一点基础知识都要细嚼慢咽，刨根问底，再加上一顿云里雾里的吹嘘，迷迷糊糊的感觉高大上。其实就是那么一回事。再过一段时日，发现如此简单，甚至不值得一提。从古到今，知识的学习都是如此，只有持续学习，奋力向前。
二、通过语言大模型来学习LLM LLM模型，即Large Language Model，是一种大语言模型，用于预测和生成自然语言文本。其核心思想是通过训练大量文本数据，学习语言的语法、语义和上下文信息[1][2][3]。以下是关于LLM模型的详细解释：
定义与功能： LLM是一种机器学习模型，通过深度学习技术，如神经网络，来学习文本数据中的模式和规律。在训练过程中，模型会不断优化其参数，以提高对文本数据的建模能力[1][2][3]。LLM模型的主要功能是生成文本内容，包括博客、长篇文章、短篇故事、摘要、脚本、问卷、调查和社交媒体帖子等[4]。同时，它们还能在代码开发、恶意软件分析、检测和预防网络攻击、搜索、文本翻译、虚拟助理和客户支持以及转录等领域发挥作用[4]。发展历史： 2017年6月，Google发布论文《Attention is all you need》，首次提出Transformer模型，为LLM模型的发展奠定了基础[1]。2018年6月，OpenAI发布论文《Improving Language Understanding by Generative Pre-Training》，首次提出GPT模型，这是LLM模型的重要里程碑[1]。2019年2月，OpenAI发布GPT-2模型，该模型在GPT-1的基础上引入任务相关信息作为输出预测的条件，并继续增大训练的数据规模和模型本身的参数量，提高了模型的性能[1]。2020年9月，OpenAI授权微软使用GPT-3模型，微软成为全球首个享用GPT-3能力的公司[3]。技术特点： LLM模型在NLP（自然语言处理）领域得到了广泛应用，特别是NLP生成类任务。其技术体系统一到了以GPT为代表的“自回归语言模型（即从左到右单向语言模型）+Zero/Few Shot Prompt”模式[1]。大模型通常指具有大量参数和复杂结构的模型，需要大量计算资源和数据集进行训练。这些模型能够提供准确和高质量的预测或生成结果，但训练和部署的成本通常较高[2]。最新研究进展： 2024年的最新研究表明，我们可能在不增大模型规模的前提下让模型变得更好，甚至让模型变得更小。例如，权重平均和模型融合可将多个LLM组合成单个更好的模型；代理调优技术可通过使用两个小型LLM来提升已有大型LLM的性能；混合专家模型通过组合多个小型模块来创建，其效果和效率可媲美甚至超越更大型的对应模型[5]。 三、通过语言大模型来学习LMM LMM大模型，即多模态大模型（Large Multimodal Model），是一种能够处理、理解和生成多种模态数据（如文本、图像、音频、视频等）的机器学习模型。以下是关于LMM大模型的详细解释：
定义与功能： LMM大模型是一种更为复杂和全面的模型，它不仅处理文本数据，还融合了图像、音频、视频等多种模态的数据进行训练。这种模型通常采用多模态Transformer结构，可以同时处理不同模态的数据，并学习它们之间的关联和交互[5]。LMM的目标是通过最大似然估计或最小二乘估计来估计模型中的固定效应和随机效应的参数。它的底层架构包括数据准备（如数据导入、数据清洗、变量选择等）[2]。LMM在健康方面有五大应用场景：协助诊断和临床护理；提供就医指导；处理文书和行政任务；参与医疗和护理教育以及科学研究和药物开发[3]。技术特点： LMM具有强大的跨模态理解和生成能力，可以用于处理更为复杂和多样化的任务，如图像标注、视频描述、音频识别等[5]。相比仅依赖文本数据的LLM模型，LMM需要处理多种模态的数据，因此其模型结构和训练过程更为复杂和困难。这导致LMM的训练需要大量的计算资源和时间，通常需要分布式训练、高性能计算等技术支持[5]。应用与挑战： 虽然LMM在多个领域都展现出了巨大的潜力，但在将LMM应用到计算机视觉任务上时，仍然面临一些挑战。例如，大多数LMM目前只限于文本输出，这限制了它们在处理更细粒度的视觉任务（如图像分割）方面的能力[4]。LMM的应用也存在风险。例如，LMM可能会提供不准确、不完整的信息。此外，和其他形式的人工智能一样，LMM也容易受到网络攻击，导致患者信息泄露或有损算法可信度[3]。监管与参与： 为了创建安全有效的LMM，世界卫生组织（WHO）认为需要各利益攸关方参与。政府、技术公司、医疗保健提供商、患者和民间社会应该参与此类技术开发和部署的所有阶段，并为技术的应用过程提供监督[3]。最新进展： 华中科技大学的研究团队针对多模态大模型（LMM）在视觉任务中的应用挑战，推出了PSALM模型。该模型通过一个统一的框架处理绝大多数类型的图像分割任务，实现了分割任务的全面覆盖。同时，PSALM在多个已见和未见开放场景任务中均表现出强大的性能[4]。 四、LLM和LMM的区别 大型语言模型（LLM）和大型多模态语言模型（LMM）在多个方面存在显著的区别。以下从技术手段和用户使用两个方面对这两种模型进行详细比较。
一、技术手段方面的区别
模型结构和训练数据
LLM主要依赖文本数据进行训练，通常采用Transformer等深度学习结构，专注于处理和理解自然语言文本。这些模型通过海量文本数据的训练，学会了生成和理解文本的能力，可以用于各种自然语言处理任务，如机器翻译、文本生成、问答系统等。
相比之下，LMM则是一种更为复杂和全面的模型，它不仅处理文本数据，还融合了图像、音频、视频等多种模态的数据进行训练。这种模型通常采用多模态Transformer结构，可以同时处理不同模态的数据，并学习它们之间的关联和交互。因此，LMM具有更强的跨模态理解和生成能力，可以用于处理更为复杂和多样化的任务，如图像标注、视频描述、音频识别等。
技术难度和计算资源
由于LMM需要处理多种模态的数据，其模型结构和训练过程都比LLM更为复杂和困难。这导致LMM的训练需要大量的计算资源和时间，通常需要分布式训练、高性能计算等技术支持。相比之下，LLM的训练相对简单，对计算资源的需求也较小。
二、用户使用方面的区别
应用场景和功能
LLM主要应用于文本处理和理解领域，如智能客服、机器翻译、文本生成等。这些应用通常涉及自然语言处理任务，需要模型具备强大的文本生成和理解能力。而LMM则具有更广泛的应用场景，如智能家居、自动驾驶、虚拟现实等，这些应用需要模型能够理解和处理多种模态的数据，实现跨模态的交互和生成。
交互方式和用户体验
由于LMM具有跨模态理解和生成能力，它可以实现更为自然和多样化的交互方式。例如，用户可以通过语音、图像、文字等多种方式与LMM进行交互，获得更为丰富和个性化的用户体验。相比之下，LLM的交互方式相对单一，主要通过文本与用户进行交互。
大模型语言模型（LLM）和大型多模态语言模型（LMM）是两种不同类型的语言模型。
大模型语言模型（LLM）是指在自然语言处理领域中使用的大规模预训练语言模型。这些模型通常是基于神经网络的深度学习模型，通过在大规模文本数据上进行预训练，学习到了丰富的语言知识和语义理解能力。LLM可以用于各种自然语言处理任务，如文本生成、机器翻译、问答系统等。
大型多模态语言模型（LMM）是在LLM的基础上进一步扩展，不仅可以处理文本数据，还可以处理多种模态的数据，如图像、音频、视频等。LMM结合了自然语言处理和计算机视觉、音频处理等领域的技术，可以实现更加复杂的多模态任务，如图像描述生成、视频理解等。
LLM主要关注文本数据的处理和生成，而LMM则在此基础上扩展了对多模态数据的处理能力。LMM有望在未来成为人工智能领域的重要发展方向之一。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9d35086e5ffce7afed5a553a8452d15/" rel="bookmark">
			Kafka高频面试题整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、什么是Kafka?2、kafka基本概念3、工作流程4、Kafka的数据模型与消息存储机制1)索引文件2)数据文件 5、ACKS 机制6、生产者重试机制:7、kafka是pull还是push8、kafka高性能高吞吐的原因1）磁盘顺序读写：保证了消息的堆积2）零拷贝机制3）分区分段+索引4）批量压缩5）直接操作pagecache 9、kafka的rebalance是什么1） Rebalance 的触发条件2）Rebalance 过程3）分区分配策略4）Rebalance 的影响5）Rebalance 的优化 10、kafka能保证消息的顺序消费吗11、kafka消息如何保证不被重复消费12、kafka如何保证消息不丢失1）生产者端保证2）Broker端保证3）消费者端保证4）事务保证 13、简述kafka副本同步机制 1、什么是Kafka? Kafka 是一个分布式流处理平台，最初由Linkedln开发并开源，后来成为Apache软件基金会的一个顶级项目。它被设计用于高吞吐量、持久性、分布式的数据流处理。
2、kafka基本概念 Producer - 消息生产者，就是向kafka broker发消息的客户端Consumer - 消息消费者，是消息的使用方，负责消费Kafka服务器上的消息。Topic - 主题，由用户定义并配置在Kafka服务器，用于建立Producer和Consumer之间的订关系。生产者发送消息到指定的Topic下，消息者从这个Topic下消费消息。Partition - 消息分区，一个topic可以分为多个 partition，每个partition是一个有序的队列。partition中的每条消息都会被分配一个有序的id (offset)Broker - 一台kafka服务器就是一个broker。一个集群由多个broker组成。一个broker可以容纳多个topic。Consumer Group - 消费者分组，用于归组同类消费者。每个consumer属于一个特定的consumer group，多个消费者可以共同消息一个Topic下的消息，每个消费者消费其中的部分消息，这些消费者就组成了一个分组，拥有同一个分组名称，通常也被称为消费者集群。Offset - 消息在partition中的偏移量。每一条消息在partition都有唯一的偏移量，消息者可以指定偏移量来指定要消费的消息。 3、工作流程 producer先从zookeeper的"/brokers/…/state"节点找到该partition的leaderproducer将消息发送给该leaderleader将消息写入本地logfollowers从leader pull消息写入本地log后向leader发送ACKleader收到所有SR中的replication的ACK后，增加HW (high watermark.最后commit 的offset)并向producer发送ACK tips:Kafka 中消息是以topic 进行分类的，生产者生产消息，消费者消费消息，都是面向topic的。topic 是逻辑上的概念，而partition 是物理上的概念，每个partition 对应一个log 文件，该log 文件中存储的就是producer 生产的数据。Producer 生产的数据会被不断追加到该log 文件未端，且每条数据都有自己的offset。消费者组中的每个消费者，都会实时记录自己消费到了哪个offset，以便出错恢复时，从上次的位置继续消费。
4、Kafka的数据模型与消息存储机制 消息存储机制:
Kafka 有Topic 和 Partition 两个概念，一个 Topic 可以有多个 Partition。在实际存储的时候，Topic + Partition 对应一个文件夹，这个文件夹对应的是这个 Partition 的数据。在 Kafka 的数据文件目录下，一个 Partition 对应一个唯一的文件夹。如果有 4个 Topic，每个 Topic 有 5个Partition，那么一共会有 4*5 =20 个文件夹。而在 文件夹下，Kafka 消息是采用 Segment File 的存储方式进行存储的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9d35086e5ffce7afed5a553a8452d15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b2ead830cf3ec83658474ef682b82a9/" rel="bookmark">
			Vue3源码【一】—— ref&amp;reactive响应式原理及简单实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		响应式 ref、reactive 源码地址：https://github.com/vuejs/core
首先还是从最开始学的ref的源码看起，他的路径在packages/reactivity/src/ref.ts，这里看源码分析就直接将源码执行的步骤给他粘贴出来了哈。首先我们看一下ref是怎么创建的
1、创建Ref // 第一步，我们还是直接到ref关键字，可以看到这个，这个就是我们使用的ref()用来创建响应式对象的关键。他会去调用createRef，并且第二个指定了false export function ref(value?: unknown) { return createRef(value, false); } // 第二步，顺着上面往下执行，会调用createRef，这个时候我们知道第二个参数false是指什么了，也就是shallow，这个时候可能会想到shallowRef？ // shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。那默认创建的这个ref指定了false，那要是shallowRef调用createRef创建Ref是不是就是指定的true呢？这个我们后面再看 // 在这里先判断isRef，这个很好理解，就是看入参的是不是一个ref了， function createRef(rawValue: unknown, shallow: boolean) { if (isRef(rawValue)) { return rawValue; } return new RefImpl(rawValue, shallow); } // 第三步，直接看RefImpl，这个就是将一个变量给包装成Ref（响应式对象） // 这里看构造函数，先都会判断一下shallow是真还是假，响应式对象入的是false，他数据包装会变成toRaw和toReactive // 在这里我们知道reactive是用来包对象类型的，这里ref创建本质上也是对调reactive的方法，同时我们也知道了为什么使用ref包的对象要加一个.value取取值赋值 // 看一下shallowRef的构造，果然就是return createRef(value, true)，这样也解释了shallowRef为什么处理的是基本数据类型 // 看一下isRef方法，return !!(r &amp;&amp; r.__v_isRef === true) r就是RefImpl实例对象，用来判断的也就是这个r.__v_isRef === true 是否为ref class RefImpl&lt;T&gt; { private _value: T; private _rawValue: T; public dep?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b2ead830cf3ec83658474ef682b82a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/320045d752bb4440d4693b9e16bb79ab/" rel="bookmark">
			【C语言题解】1、写一个宏来计算结构体中某成员相对于首地址的偏移量；2、写一个宏来交换一个整数二进制的奇偶位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🥰欢迎关注 轻松拿捏C语言系列，来和 小哇 一起进步！✊
🌈感谢大家的阅读、点赞、收藏和关注
💕希望大家喜欢我本次的讲解💕
目录👑
1、写一个宏，计算结构体中某变量相对于首地址的偏移，并给出说明。考察：offsetof宏的实现 2、写一个宏，可以将一个整数的二进制位的奇数位和偶数位交换。
1、写一个宏，计算结构体中某变量相对于首地址的偏移，并给出说明。考察：offsetof宏的实现 offsetof宏的原型如下：
#include &lt;stddef.h&gt; size_t offsetof(type, member); 但请注意，实际上offsetof是一个宏，而不是一个函数。
它接受两个参数：一个结构体类型和一个该类型中的成员名称，并返回该成员在结构体中的字节偏移量。
使用举例：
#include &lt;stdio.h&gt; #include &lt;stddef.h&gt; typedef struct { int a; char b; double c; } MyStruct; int main() { printf("%zu\n", offsetof(MyStruct, b)); printf("%zu\n", offsetof(MyStruct, c)); return 0; } 回归题目，
我们可以将0转换成一个结构体类型的指针，相当于这个结构体的首地址为0，所以结构体元素的偏移量就是相对于0的偏移量。
因为首元素地址为0，结构体类型指针指向结构体成员的地址，将该地址强转成size_t类型，就能得到这个偏移量了。
#include&lt;stdio.h&gt; struct A { char a; int b; }; #define OFFSET1(STRUCTtype,member) (size_t)&amp;(((STRUCTtype*)0)-&gt;member) //不能用成员指针减结构体起始位置地址的方式去计算偏移量 // #define OFFSET2(STRUCTname,member) (size_t)(&amp;(STRUCTname.member) - &amp;STRUCTname) int main() { struct A str = { 'a',2024 }; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/320045d752bb4440d4693b9e16bb79ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e43ee7ae6b7a2e86af77710a34b2d5cd/" rel="bookmark">
			DePIN赛道：从底层设施到上层应用的五大机遇与挑战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文改写来自香港Web3媒体Techub News专栏作者文章 在数字化浪潮席卷全球的今天，DePIN赛道作为连接物理世界与区块链的桥梁，正日益受到业界的关注。Future Money Group近日发布的深度研报指出，DePIN赛道蕴藏着从下至上的五大机遇，为投资者和开发者提供了广阔的想象空间。
首先，让我们来了解一下DePIN的基本概念。DePIN，即去中心化物理基础设施网络，代表了一种全新的应用范式。它利用加密经济来部署和管理现实世界中的物理基础设施，从而实现更高效、更安全的资源利用和价值创造。DePIN的出现，不仅为传统基础设施的升级提供了新路径，也为区块链技术的应用拓展了新领域。
那么，DePIN赛道究竟蕴藏着哪些机遇呢？
第一，DePIN区块链底层设施的建设是赛道的基础。这些底层设施充当着DePIN应用的结算层，为交易、代币经济模型的运转提供支持。随着DePIN应用的不断增多，对底层设施的需求也将持续增长，这为区块链技术的发展和应用提供了新的市场空间。
第二，中间件在DePIN生态系统中扮演着关键角色。它们连接底层基础设施和上层应用，提供标准化的接口和工具，使得开发者能够更便捷地构建DePIN应用。因此，中间件的发展将直接推动DePIN生态的繁荣。
第三，DePIN上层应用是赛道的核心价值所在。这些应用基于DePIN基础设施和中间件层构建，为用户提供实际的服务和价值。无论是物联网、边缘计算还是AI应用，都可以通过DePIN网络实现更高效、更智能的运行。随着技术的不断进步和应用场景的不断拓展，DePIN上层应用的市场空间将不断扩大。
第四，边缘AI是DePIN赛道的一个重要衍生机会。利用DePIN网络部署边缘计算和AI应用，可以在本地处理数据并提供智能服务，从而满足低延迟、高带宽的需求。这将为物联网、自动驾驶等领域的发展提供有力支持。
最后，将DePIN与现实世界资产（RWA）相结合也是赛道的一大机遇。通过将RWA数字化并上链，可以实现资产的更高效流通和价值发现。这将为金融、房地产等领域带来全新的商业模式和投资机会。
DePIN赛道作为连接物理世界与区块链的桥梁，蕴藏着从底层设施到上层应用的五大机遇。随着技术的不断进步和应用场景的不断拓展，这些机遇将逐渐转化为实际的价值和收益。对于投资者和开发者来说，关注并布局DePIN赛道将是一个明智的选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d07798d8e2b5e6d398cb46942e89516/" rel="bookmark">
			哈喽GPT-4o——对GPT-4o 写论文的思考与看法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 几小时即可完成一份1万字论文的编写1、改写降重2、同义词替换降重3、避免连续相同4、缩写扩写降重5、关键词汇替换降重6、句式变换降重7、逻辑重组8、综合改写9、数据呈现方式变更10、概念解释降重 大家好，我是哪吒。
在ChatGPT4o对话框中输入：写一个Spring Boot+Vue实现的车位管理系统的论文大纲，并对其具体章节进行详细描述。
👉 GPT功能：
GPT-4o知识问答：支持1000+token上下文记忆功能最强代码大模型Code Copilot：代码自动补全、代码优化建议、代码重构等DALL-E AI绘画：AI绘画 + 剪辑 = 自媒体新时代专职家教：精通语数外，拍照上传即可识别问题，给出权威回答论文小能手：写论文大模型Consensus、论文降重大模型联网查询（平替百度）、上传文件、数据分析等。 几小时即可完成一份1万字论文的编写 在GPTS中搜索论文降重，使用AI专业工具进行论文降重。
在ChatGPT4o对话框输入：指令+需要降重的段落（参考文中示例），即可完成降重。
1、改写降重 Please rephrase this passage by adjusting the word order, modifying the length, and substituting synonyms to avoid any sequence of eight consecutive words that match the original text, ensuring that the revised content is more logical and adheres to academic standards.
请将这段话改写，通过调整语序增减字数，替换同义词等方式，避免与原文出现连续八个字相同的句子，使这段话更加有逻辑，符合论文的规范。
2、同义词替换降重 Please assist me in reorganizing the following sentence by adjusting its logical structure, employing active and passive voice interchange, synonym replacement, and paraphrasing with near-synonyms to rewrite the sentence.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d07798d8e2b5e6d398cb46942e89516/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/724662a31e7f869bfb40954d02dbe04b/" rel="bookmark">
			MySQL如何执行.sql 文件：详细教学指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用MySQL数据库过程中，我们经常需要执行包含SQL语句的.sql文件。这些文件通常用于数据库的备份和恢复或批量执行SQL脚本。本文将详细介绍如何在不同环境下执行MySQL的.sql文件。
前置准备 在开始之前，请确保以下条件已经满足：
已经安装并配置好了MySQL Server。已经安装了MySQL客户端工具（如命令行客户端或图形化工具）。已准备好需要执行的.sql文件。 方法一：使用命令行客户端执行 .sql 文件 步骤1：打开命令行终端 在Windows系统中，可以使用命令提示符（Cmd）或PowerShell。在Linux或MacOS系统中，可以使用终端（Terminal）。
步骤2：连接到MySQL服务器 在命令行中输入以下命令，以连接到MySQL服务器：
mysql -u 用户名 -p 例如，如果你的用户名是root，则输入：
mysql -u root -p 系统会提示你输入密码。输入正确的密码后，按回车键即可成功连接到MySQL服务器。
步骤3：选择目标数据库 在连接到MySQL服务器后，选择你需要执行SQL文件的目标数据库：
USE 数据库名; 例如：
USE mydatabase; 步骤4：执行 .sql 文件 使用以下命令来执行你的.sql文件：
source 文件路径/文件名.sql; 例如，如果你的文件存放在桌面路径中，你可以输入：
source /Users/用户名/Desktop/filename.sql; 在Windows系统中，则路径可能类似于：
source C:/Users/用户名/Desktop/filename.sql; 方法二：使用图形化工具执行 .sql 文件 使用MySQL Workbench 打开MySQL Workbench并连接到你的MySQL服务器。在左侧导航栏中选择你的数据库。点击菜单栏中的“File” -&gt; “Open SQL Script”，然后选择你的.sql文件。文件打开后，点击上方工具栏中的“Execute”按钮（闪电图标）以执行SQL脚本。 使用phpMyAdmin 登录到phpMyAdmin。从左侧面板中选择目标数据库。点击顶部菜单中的“导入”选项。在“文件到导入”区域，点击“选择文件”按钮，选择你要执行的.sql文件。选择好文件后，点击页面底部的“执行”按钮。 方法三：使用批处理命令（Windows）或Shell脚本（Linux/MacOS） 如果你想在不进入MySQL命令行客户端的情况下执行.sql文件，可以通过批处理命令或Shell脚本来实现。
Windows批处理命令 创建一个.bat文件，例如execute_sql.bat，内容如下：
@echo off mysql -u 用户名 -p密码 数据库名 &lt; 文件路径\文件名.sql 例如：
@echo off mysql -u root -pmypassword mydatabase &lt; C:\Users\用户名\Desktop\filename.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/724662a31e7f869bfb40954d02dbe04b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fe6c69ae9bfd2b2673e4c541ff25e76/" rel="bookmark">
			C语言详解（预编译）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hi~！这里是奋斗的小羊，很荣幸您能阅读我的文章，诚请评论指点，欢迎欢迎 ~~
💥💥个人主页：奋斗的小羊
💥💥所属专栏：C语言
🚀本系列文章为个人学习笔记，在这里撰写成文一为巩固知识，二为展示我的学习过程及理解。文笔、排版拙劣，望见谅。
目录 前言1、预定义符号2、#define定义常量和标识符3、#define定义宏4、带有副作用的宏参数5、宏替换的规则6、宏和函数的对比7、#和##7.1 #运算符7.2 ##运算符 8、命名的约定9、#undef10、命令行定义11、条件编译12、头文件的包含12.1 头文件被包含的方式12.1.1 本地文件包含12.1.2 库文件包含 12.2 嵌套文件的包含 总结 前言 本篇文章将详细介绍编译过程中预编译的具体细节
在C语言的学习中部分人可能会忽视这一部分的学习，因为像VS这样相对强大的集成开发环境，我们在写好代码后只需要开始执行即可，所以部分人认为这一部分不值得我们花费时间去学习
其实不然，学习C语言预编译过程可以帮助我们更深入地了解C语言的编译过程和语法特性，提高代码编写的效率和质量，以及拓展编程技能
1、预定义符号 C语言设置了一些预定义符号，可以直接使用，预定义符号也是在预编译阶段处理的
__FILE__：正在编译的源文件的文件名__LINE__：文件当前的行号__DATE__：文件被编译的日期__TIME__：文件被编译的时间__STDC__：如果编译器遵循 ANSI C，其值为1，否则未定义 例如：
2、#define定义常量和标识符 #define定义的常量和标识符在预编译阶段完成替换
基本语法：
#define name stuff 特别的，为了区分普通常量这个name我们一般用大写形式
比如：
#define MAX 10000 #define REG register #define后面的代码理论上讲只能写一行，但是如果后面的代码过长，我们可以使用'\'来实现换行，相当于转义转义字符'\'转义了转义字符'\n'
#define DEBUG_PRINT printf("file:%s\tline:%d\t\ date:%s\ttime:%s\n,\ __FILE__,__LINE__,\ __DATE__,__TIME__) 值得注意的是，行末最好不要加;，在某些场景下是没什么问题，但是在大多数情况下是有语法错误的，所以我们要养成良好的编程习惯，行末不加;
3、#define定义宏 #define机制包括了一个规定，允许把参数替换到文本中，这种实现通常称为宏（macro）或定义宏（define macro）
基本语法：
#define name(parament_list) stuff 其中parament-list（参数列表）是一个由逗号隔开的符号表，它们可能出现在stuff中
注意： 参数列表的左括号必须与name紧邻，如果两者之间有任何空白存在，参数列表就会被解释为stuff的一部分
举例：输入一个数，输出它的平方数
#include &lt;stdio.h&gt; #define SQUARE(x) x*x int main() { int n = 0; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fe6c69ae9bfd2b2673e4c541ff25e76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93f293c00a5ffc5d79a1be8929504eaa/" rel="bookmark">
			监控易监测对象及指标之：全面监控MongoDB 5数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着企业数据量的持续增长，数据库的性能和稳定性对于保障业务连续性至关重要。MongoDB 5作为一款流行的NoSQL数据库，以其灵活的文档模型和强大的扩展能力，在各类业务场景中发挥着关键作用。
为了确保MongoDB 5数据库的稳定运行和高效性能，对其进行全面监控显得尤为重要。本文基于监控易工具，对MongoDB 5的监测指标进行解读，并探讨如何通过监控提升数据库性能。
一、数据库连接与连接数监控
数据库连接是业务应用与数据库交互的基础。监控易工具实时监测MongoDB 5数据库的连接状态、可用连接数和当前连接数，确保数据库服务的可用性。
当连接状态异常或连接数超过预设阈值时，监控工具会立即发出警报，提醒运维人员及时处理。这有助于预防因连接问题导致的业务中断和数据丢失。
二、记录操作监控
记录操作监控包括插入、删除、更新和返回记录的条数。监控易工具通过统计这些操作的数量，帮助运维人员了解数据库的业务负载情况。
当某个操作的数量异常增加时，可能意味着数据库正面临高并发压力或存在性能瓶颈。运维人员可以根据监控结果及时调整数据库配置或优化查询语句，提升数据库性能。
三、读写锁与内存监控
读写锁和内存是影响数据库性能的关键因素。监控易工具详细监控MongoDB 5的读写锁状态和内存消耗情况。通过监控当前活动的读连接数、写连接数以及锁等待情况，运维人员可以了解数据库的并发处理能力和锁竞争情况。
同时，通过监控物理内存和虚拟内存的消耗情况，运维人员可以评估数据库的内存需求，并根据实际情况调整内存配置。
四、操作计数器与游标统计
操作计数器和游标统计是评估数据库性能和资源利用率的重要指标。监控易工具实时监控MongoDB 5的操作次数和游标使用情况。通过统计执行命令、删除、插入、查询和更新等操作的次数，运维人员可以了解数据库的业务负载情况和性能瓶颈。
同时，通过监控游标的超时个数和打开游标的总个数，运维人员可以评估数据库的资源利用率，并根据实际情况优化游标管理策略。
五、网络流量与缺页中断监控
网络流量和缺页中断是评估数据库性能和稳定性的重要参数。监控易工具实时监控MongoDB 5的输入和输出网络流量以及缺页中断次数。通过监控网络流量，运维人员可以了解数据库的通信情况和数据传输效率。
当网络流量异常增加时，可能意味着数据库正面临网络瓶颈或存在安全隐患。同时，通过监控缺页中断次数，运维人员可以评估数据库的内存访问效率，当缺页中断次数显著上升时，可能意味着数据库性能较差或数据量极大。运维人员可以根据监控结果采取相应的优化措施，提升数据库性能和稳定性。
六、副本集监控
MongoDB支持副本集功能，通过复制数据到多个节点来提供数据冗余和高可用性。监控易工具实时监控MongoDB 5副本集的状态、网络延迟、心跳信息等关键指标。通过监控这些指标，运维人员可以了解副本集的健康状况和数据同步情况。
当某个节点的状态异常或网络延迟过高时，监控工具会立即发出警报，提醒运维人员及时处理，确保副本集的高可用性和数据一致性。
总结
通过全面监控MongoDB 5数据库的各项指标，运维人员可以及时发现并解决潜在问题，确保数据库的稳定运行和高效性能。监控易作为一款专业的监控工具，为MongoDB 5数据库的监控提供了全面而细致的支持。
在实际应用中，运维人员应根据业务需求和系统特点制定合理的监控策略和优化方案，不断提升数据库的性能和稳定性。随着技术的不断发展，监控工具的功能也将不断完善和优化，为企业的业务发展提供更加强有力的支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/866e144ca14760fe06b29708b351e8cd/" rel="bookmark">
			C语言之函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、函数的概念
二、库函数和自定义函数
自定义函数
三、形参和实参
四、数组做函数参数
五、 嵌套调用和链式访问
六、函数的声明和定义
七、总结
一、函数的概念 数学中我们其实就见过函数的概念，比如：⼀次函数 y=kx+b ，k和b都是常数，给⼀个任意的x，就得到⼀个y值。其实在C语言也引入函数（function）的概念，有些翻译为：子程序，子程序这种翻译更加准确⼀些。 C语言中的函数就是⼀个完成某项特定的任务的⼀小段代码。这段代码是有特殊的写法和调用方法的。C语言的程序其实是由无数个小的函数组合而成的，也可以说：⼀个⼤的计算任务可以分解成若干个较小的函数（对应较小的任务）完成。同时⼀个函数如果能完成某项特定任务的话，这个函数也是可以 复⽤的，提升了开发软件的效率。 C语言中⼀般会见到两类函数：库函数 自定义函数
二、库函数和自定义函数 标准库和头文件
C语言标准中规定了C语言的各种语法规则，C语言并不提供库函数；C语言的国际标准ANSIC规定了一些常用的函数的标准，被称为标准库，那不同的编译器⼚商根据ANSI提供的C语言标准就给出了⼀系列函数的实现。这些函数就被称为库函数。各种编译器的标准库中提供了⼀系列的库函数，这些库函数根据功能的划分，都在不同的头文件中进行了声明。
库函数相关头文件：https://zh.cppreference.com/w/c/header
自定义函数 了解了库函数，自定义函数其实更加重要，也能给程序员写代码更多的创造性。
函数的语法形式
其实自定义函数和库函数是⼀样的，形式如下：
ret_type fun_name(形式参数) { } • ret_type 是函数返回类型
• fun_name 是函数名
• 括号中放的是形式参数
• {}括起来的是函数体
可以把函数想象成小型的⼀个加工厂，工厂得输入原材料，经过工厂加工才能生产出产品，那函 数也是⼀样的，函数⼀般会输入⼀些值（可以是0个，也可以是多个），经过函数内的计算，得出结 果。
• ret_type 是用来表示函数计算结果的类型,有时候返回类型可以是 void ,表示什么都不返回
• fun_name 是为了方便使用函数；就像⼈的名字⼀样，有了名字方便称呼，函数有了名字方便调用，所以函数名尽量要根据函数的功能起的有意义。
• 函数的参数就相当于，工厂中送进去的原材料，函数的参数也可以是void ，明确表示函数没有参数。如果有参数，要交代清楚参数的类型和名字，以及参数个数。
• {}括起来的部分被称为函数体，函数体就是完成计算的过程。
return语句 return语句在函数的设计中,函数中经常会出现return语句,return语句使用的注意事项。
• return后边可以是⼀个数值，也可以是⼀个表达式，如果是表达式则先执行表达式，再返回表达式的结果。
• return后边也可以什么都没有，直接写 return; 这种写法适合函数返回类型是void的情况。
• return返回的值和函数返回类型不⼀致,系统会自动将返回的值隐式转换为函数的返回类型。
• return语句执行后，函数就彻底返回，后边的代码不再执行。
• 如果函数中存在if等分支的语句,则要保证每种情况下都有return返回,否则会出现编译错误。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/866e144ca14760fe06b29708b351e8cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7f108abf09165cf7f90a20a9aa01a3e/" rel="bookmark">
			Wireshark v4 修改版安装教程（免费开源的网络嗅探抓包工具）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 Wireshark（前称Ethereal）是一款免费开源的网络嗅探抓包工具，世界上最流行的网络协议分析器！网络封包分析软件的功能是撷取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark网络抓包工具使用WinPCAP作为接口，直接与网卡进行数据报文交换，可以实时检测网络通讯数据，检测其抓取的网络通讯数据快照文件，通过图形界面浏览这些数据，可以查看网络通讯数据包中每一层的详细内容。它的强大特性：例如包含有强显示过滤器语言和查看TCP会话重构流的能力，支持几百种协议和流媒体类型。
一、下载地址 下载链接：http://dygod/source 点击搜索：Wireshark
二、安装步骤 1、解压后先傻瓜式安装npcap-1.5.0.exe驱动包 2、驱动包安装完成后，将WiresharkPortable64.exe发送到桌面快捷方式 3、点击桌面图标启动 4、启动成功，选择一个网络 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c118e14cbde2b2b6d05e8a8573132885/" rel="bookmark">
			AI大模型探索之路-实战篇：智能化IT领域搜索引擎之知乎网站数据获取（初步实践）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列篇章💥 No.文章1AI大模型探索之路-实战篇：智能化IT领域搜索引擎的构建与初步实践2AI大模型探索之路-实战篇：智能化IT领域搜索引擎之GLM-4大模型技术的实践探索3AI大模型探索之路-实战篇：智能化IT领域搜索引擎之知乎网站数据获取（初步实践）4AI大模型探索之路-实战篇：智能化IT领域搜索引擎之知乎网站数据获取（函数封装）5AI大模型探索之路-实战篇：智能化IT领域搜索引擎之知乎网站数据获取（流程优化）6AI大模型探索之路-实战篇：智能化IT领域搜索引擎之github网站在线搜索7AI大模型探索之路-实战篇：智能化IT领域搜索引擎之HuggingFace网站在线搜索 目录 系列篇章💥一、前言二、总体概览三、搜索API封装测试1、导入依赖并初始化客户端2、大模型回答问题策略测试3、function calling函数测试4、谷歌搜索API开发 四、知乎网站数据爬取1、数据格式定义2、设置知乎排除的网站3、Google api调用测试4、爬虫之Cookie获取5、爬虫之user-agent6、爬虫之获取PATH7、网络爬虫代码编写8、question类型的网站爬虫测试9、网页数据保存10、question/answer网站爬虫测试11、专栏类网站爬虫测试 结语 一、前言 在先前的文章中，我们完成了智能化IT领域搜索引擎的基础架构设计以及Google Search API的申请等前期准备工作。同时，我们还实践测试了GLM4的Function Calling能力，为后续的开发奠定了坚实的基础。本文将正式进入代码开发阶段，首先从知乎网站的数据搜索开始。
二、总体概览 本文将详细阐述如何逐步实现知乎网站数据获取的整个流程。我们将从知乎网站的结构分析入手，通过编写高效的网络爬虫程序，实现对知乎问题的智能检索，并利用先进的数据分析技术，对获取的数据进行深度挖掘和整合，最终将这些有价值的信息融入我们的智能化IT领域搜索引擎中，为用户提供更全面、准确的搜索结果。这一过程中，我们将不断优化算法，提升数据获取的效率和准确性，确保搜索引擎的智能化水平得到持续提升。
三、搜索API封装测试 1、导入依赖并初始化客户端 导入依赖
! pip install --upgrade zhipuai ! pip install --upgrade google-auth google-auth-httplib2 google-auth-oauthlib google-api-python-client requests 创建客户端
import os import openai from openai import OpenAI import glob import shutil import numpy as np import pandas as pd import json import io import inspect import requests import re import random import string from googleapiclient.discovery import build from google.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c118e14cbde2b2b6d05e8a8573132885/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d780c5758dc840abf07274225655d2fe/" rel="bookmark">
			zookeeper的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、基础环境准备 将zookeeper-3.4.6.tar.gz上传到/opt/package中 解压 [root@master software]# tar -zxvf zookeeper-3.4.6.tar.gz -C /opt/programs/ 更名zookeeper [root@master software]# cd ../programs/ [root@master programs]# mv zookeeper-3.4.5 zookeeper 配置环境变量 [root@master programs]# vi /etc/profile .........省略...... export ZOOKEEPER_HOME=/opt/programs/zookeeper export PATH=$ZOOKEEPER_HOME/bin:$PATH 使当前会话生效 [root@master programs]# source /etc/profile 查看zookeeper的版本号 [root@master programs]# echo stat|nc localhost 2181 2、复制出一个zoo.cfg文件 [root@master zookeeper]# cd conf/ #进入zookeeper的conf目录 [root@master conf]# cp zoo_sample.cfg zoo.cfg #复制出zoo.cfg文件 3、修改zoo.cfg文件 [root@master conf]# vi zoo.cfg tickTime=2000 # 定义的时间单元(单位毫秒)，下面的两个值都是tickTime的倍数。 initLimit=10 #follower连接并同步leader的初始化连接时间。 syncLimit=5 #心跳机制的时间(正常情况下的请求和应答的时间) dataDir=/opt/programs/zookeeper/data/ #修改zookeeper的存储路径 dataLogDir=/opt/programs/zookeeper/log/ #修改zookeeper的日志存储路径 server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d780c5758dc840abf07274225655d2fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbe010ef7ea614f8bb08e5e631b500f5/" rel="bookmark">
			Python笔记 - 正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正则表达式（Regular Expression，简称regex）是一种强大的工具，用于匹配字符串模式。在Python中，正则表达式通过re模块提供。本文将带你深入了解Python中的正则表达式，从基础概念到高级用法。
1. 什么是正则表达式？ 正则表达式是一种用来描述字符串模式的方法。它可以用来匹配、查找和替换文本中的特定模式。通过使用正则表达式，你可以定义一些规则，然后搜索文本中符合这些规则的内容。这种功能在文本处理、数据抽取和字符串匹配等领域非常有用。
2. 基本概念 在介绍具体用法之前，先了解一些基本概念：
模式（Pattern）：正则表达式的核心，由字符和特殊符号组成，用于描述字符串的规则。匹配（Match）：字符串是否符合模式。组（Group）：通过括号()来定义子模式，方便提取子字符串。 3. 常用符号 以下是一些常用的正则表达式符号：
.：匹配除换行符以外的任意字符。^：匹配字符串的开头。$：匹配字符串的结尾。*：匹配前一个字符零次或多次。+：匹配前一个字符一次或多次。?：匹配前一个字符零次或一次。{n}：匹配前一个字符n次。{n,m}：匹配前一个字符n到m次。[]：匹配方括号内的任意字符。|：匹配左右任意一个表达式。\d：匹配任何数字，相当于[0-9]。\D：匹配任何非数字字符。\w：匹配任何字母、数字、下划线字符。\W：匹配任何非字母、数字、下划线字符。\s：匹配任何空白字符（包括空格、制表符等）。\S：匹配任何非空白字符。 4. Python中的正则表达式 在Python中，可以使用re模块进行正则表达式操作。以下是一些常用方法：
导入re模块 import re re.match() re.match从字符串的起始位置匹配正则表达式。
import re pattern = r'hello' text = 'hello world' match = re.match(pattern, text) if match: print("Match found:", match.group()) else: print("No match") re.search() re.search扫描整个字符串并返回第一个成功的匹配。
import re pattern = r'world' text = 'hello world' match = re.search(pattern, text) if match: print("Match found:", match.group()) else: print("No match") re.findall() re.findall返回字符串中所有非重叠的匹配。
import re pattern = r'\d+' text = 'There are 123 apples and 456 oranges.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbe010ef7ea614f8bb08e5e631b500f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14c0377c920ec40d72500f1d424b4f4e/" rel="bookmark">
			内网穿透方法有哪些？路由器端口映射外网和软件方案步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公网IP和私有IP不能互相通讯。我们通常在局域网内部署服务器和应用，当需要将本地服务提供到互联网外网连接访问时，由于本地服务器本身并无公网IP，就无法实现。这时候就需要内网穿透技术，即内网映射，内网IP端口映射到外网实现访问的过程。那么，内网穿透的方法有哪些呢？这里分享两种方法，一种是公网路由器端口映射方案步骤，一种是快解析软件映射外网访问的方案步骤。只要是能上网的网络环境，都可以通过这两种方式实现内网穿透。
一、路由映射外网方法
1.浏览器访问路由后台登陆到Web管理界面：在浏览器里面输入192.168.1.1(TP-Link路由器默认管理地址，输入用户名和密码（默认都是admin，其余有些路由器用户名和密码在路由器背面)----&gt;按回车键----&gt;点击“确定”进行登陆。
2.进入“虚拟服务器”设置界面：在路由器的管理界面点击“转发规则”，在“转发规则”下面点击“虚拟服务器”。
3.设置端口映射：设置端口映射就是在路由器的虚拟服务器下面添加一条新条目，点击“添加新条目”。在“服务端口号”后面填写自己实际应用使用端口号----&gt;在“ip地址”后面填写自己电脑本地固定不变的内网IP地址----&gt;协议选择“TCP”（如是UDP应用则选择UDP，其他协议和多协议应用则选择ALL）----&gt;状态后面选择“生效”----&gt;点击“保存”。（如果需要把多个端口好映射到同一个内网ip地址上，则需要对应添加多个规则条目。或在“服务端口号”后面填写一个端口的范围，例如需要把21、53、80、110等端口映射到192.168.1.100，在“服务端口号”后面填写21-110，其它的设置不便。）
4.内网访问场景：在虚拟服务器界面可以查看到刚才设置端口映射已经生效了。路由器端口映射后，即可以通过路由公网IP在外网进行连接访问；也可以将自己注册域名解析指向路由公网IP，用域名进行连接访问。这适用于本地有路由器权限，且有公网IP的网络环境。
如果本地公网IP是变化不固定的，可以同时使用快解析软件动态域名解析方法，用固定的域名来代替变化的IP。
二、快解析内网映射步骤
只要可以联网，即可以通过快解析，将本地内网IP端口映射到互联网，实现外网对内网指定服务的访问。此方法不但可以解决端口受限问题，同时适用于在任意网络环境下提供外网访问。
1.明确本地服务。在映射外网前，首先明确自己的应用场景。确保自己的服务本身有开启，且在局域网内可以正常访问。
2.软件工具上设置映射：在服务器本地，或所在内网另台主机电脑上，安装并登录快解析客户端添加端口映射。
3.涉及映射填写相关信息有：
应用程序端口（ 常见的服务器端口）：
WEB服务器（网站服务器）：80端口
FTP服务器（文件服务器）：21端口
终端服务器：3389端口
邮件服务器：25端口（SMTP）和110端口（POP）
VPN服务器：1723端口
公共端口类型：根据自己场景应用需求选择。
内网地址：内网访问固定地址。可以是固定内网IP或计算机名。如是在服务器本机使用映射的，推荐填写127.0.0.1格式。
4.外网访问连接
内网快解析端口映射域名生效后，即可以在任意上网环境，通过映射设置的域名和外网端口进行访问。外网远程桌面连接公司内网服务器时，对应使用远程桌面映射域名和外网端口号；异地浏览器访问企业内部办公OA网站时，通过对应网站地址映射域名和外网端口进行访问。
内网搭建服务器，利用快解析映射外网，广泛应用于远程桌面、SSH、数据库SQL服务、FTP文件共享、办公OA、ERP、web网站、GPRS、管家婆、财务管理、物业管理、用友等个人和企业应用场景。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2667d5be083cb4194ffa1747196bf99e/" rel="bookmark">
			图像生成新篇章：Stable Diffusion 3 Medium开源评析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 在数字艺术与人工智能的交汇点上，Stable Diffusion 3（SD3）的开源无疑是一场技术革新的盛宴。就在3月份，我撰写了一篇博文，深入探讨了SD3的技术报告内容与介绍，文章发表在CSDN博客上，https://blog.csdn.net/sunbaigui/article/details/136898729。如今，随着SD3 Medium版本的开源，https://huggingface.co/spaces/stabilityai/stable-diffusion-3-medium，我们迎来了新的里程碑。在本文中，我将分享我对这一开源版本的初步体验，以及它对文生图开源社区所带来的影响。Stable Diffusion 3 Medium的开源是一个重要的技术里程碑，它不仅展示了AI在图像生成领域的最新进展，也为未来的艺术创作和技术开发提供了丰富的土壤。虽然仍有挑战需要克服，但我相信，通过社区的共同努力和不断的技术创新，我们将能够解锁更多的创造潜力，开拓数字艺术的新境界。
体验与分析 为了确保体验的一致性和可复现性，我在所有样例中使用了相同的随机数种子——"888888888"。这一决定让我能够更准确地评估SD3 Medium的性能，并与其他用户的结果进行比较。
图像文字与背景的突破 SD3 Medium在图像文字和背景生成方面取得了显著的进步。它能够更好地理解和执行复杂的文本提示，生成的图像在视觉美学、提示遵循和排版方面都有了显著提升。这不仅推动了整个社区在图像生成技术上的发展，也为未来的艺术创作提供了更多可能性。
前景主体及其交互动作的挑战 尽管在图像文字和背景上取得了成功，SD3 Medium在前景物体、尤其是人物与物体的交互方面仍有提升空间。在一些生成的图像中，前景主体细节部分往往容易出错，尤其是躯干/手指等，另外物体间的交互动作也需进一步优化。这些挑战提示我们，尽管技术取得了巨大进步，但在实现高度逼真的图像生成方面，仍需不断地研究和提升。
样例1： An astronaut riding a green horse
首先我们先看下官方样例结果：
在这个官方样例效果还不错，不过如果放开随机种子，多生成几次的话，局部细节不良率比较高。
样例2： The elderly person sits on a wrought-iron chair, holding a glass of wine, facing the sea where spring is warm and flowers are blooming, at a seaside holiday home, with flowers and the sea around, savoring the fine wine while looking towards the coast.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2667d5be083cb4194ffa1747196bf99e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b199f6f55829a14be1b291eff81fda6/" rel="bookmark">
			用【R语言】揭示大学生恋爱心理：【机器学习】与【深度学习】的案例深度解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
第一部分：数据收集与预处理
1.1 数据来源
1.2 数据清洗
加载必要的库
读取数据
处理缺失值
转换数据类型
查看清洗后的数据 数据清洗的扩展与优化
检测异常值
处理异常值
重新查看清洗后的数据
优化与扩展总结
1.3 数据探索性分析
年龄分布图
性别分布图
恋爱状态分布图
按性别分组的年龄分布图
按恋爱状态分组的社交活动频率分布图
第二部分：特征工程与数据准备
2.1 特征选择
年龄（Age）
性别（Gender）
社交活动频率（Social_Activity）
情感特征（Emotional_Features）
2.2 特征提取
代码优化与扩展
添加词频分析
可视化词云
完整代码
第三部分：机器学习模型
3.1 逻辑回归模型
构建逻辑回归模型
模型总结
预测
模型评估
优化与扩展
使用交叉验证评估模型性能
计算更多评估指标
完整代码
3.2 决策树模型
优化与扩展
使用交叉验证评估模型性能
计算更多评估指标
完整代码
第四部分：深度学习模型
4.1 数据准备
4.2 构建和训练模型
第五部分：模型评估与比较
5.1 模型评估指标
5.2 模型比较
评估指标
评估结果分析
结果说明
选择最优模型
第六部分：案例分析
6.1 案例背景
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b199f6f55829a14be1b291eff81fda6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55b4ac82f0edd5c344e93e627941a5c3/" rel="bookmark">
			【python】tkinter编程三大布局管理器pack、grid、place应用实战解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨✨ 欢迎大家来到景天科技苑✨✨
🎈🎈 养成好习惯，先赞后看哦~🎈🎈
🏆 作者简介：景天科技苑
🏆《头衔》：大厂架构师，华为云开发者社区专家博主，阿里云开发者社区专家博主，CSDN全栈领域优质创作者，掘金优秀博主，51CTO博客专家等。
🏆《博客》：Python全栈，前后端开发，小程序开发，人工智能，js逆向，App逆向，网络系统安全，数据分析，Django，fastapi，flask等框架，linux，shell脚本等实操经验，网站搭建，数据库等分享。
所属的专栏：python图形化GUI编程tkinter精讲
景天的主页：景天科技苑
文章目录 tkinter布局管理器1.grid 布局管理器2.pack 布局管理器3.place 布局管理器 tkinter布局管理器 一个 GUI 应用程序必然有大量的组件，这些组件如何排布？
这时候，就需要使用 tkinter提供的布局管理器帮助我们组织、管理在父组件中子组件的布局方式。
tkinter 提供了三种管理器：pack、grid、place。
1.grid 布局管理器 grid 表格布局，采用表格结构组织组件。子组件的位置由行和列的单元格来确定，并
且可以跨行和跨列，从而实现复杂的布局。
【示例】grid 布局用法-登录界面设计
"""测试Grid布局管理器的基本用法，使用面向对象的方式""" from tkinter import * from tkinter import messagebox class Application(Frame): def __init__(self, master=None): super().__init__(master) # super()代表的是父类的定义，而不是父类对象 self.master = master self.pack() self.createWidget() def createWidget(self): """通过grid布局实现登录界面""" self.label01 = Label(self,text="用户名") self.label01.grid(row=0,column=0,pady=10) self.entry01 = Entry(self) self.entry01.grid(row=0,column=1,pady=10) Label(self,text="用户名为手机号",foreground="gray").grid(row=0,column=2) Label(self, text="密码").grid(row=1, column=0,pady=10) self.entry02 = Entry(self, show="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55b4ac82f0edd5c344e93e627941a5c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/693faff87cfbb062e0462cc1298f5969/" rel="bookmark">
			在VSCode中使用Vim
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在VSCode中使用Vim，主要涉及到Vim插件的安装和配置。以下是在VSCode中使用Vim的详细步骤：
1. 安装Vim插件 打开VSCode：首先，启动你的VSCode编辑器。进入扩展面板：在VSCode的左侧活动栏中，点击扩展图标（或使用快捷键Ctrl+Shift+X）打开扩展面板。搜索Vim插件：在扩展面板的搜索框中输入“Vim”，你会看到相关的Vim插件列表。安装Vim插件：从搜索结果中选择适合你需求的Vim插件（如“VSCodeVim”或“Vim”等），点击安装按钮进行安装。 2. 配置Vim插件（可选） 打开设置：点击VSCode左下角的齿轮图标，选择“设置”（或使用快捷键Ctrl+,）。搜索Vim设置：在设置面板的搜索框中输入“Vim”，你会看到与Vim相关的设置选项。配置Vim：根据你的需求，修改相应的Vim设置。例如，你可以设置Vim的快捷键、缩进、语法高亮等。 3. 使用Vim插件 安装并配置好Vim插件后，你就可以在VSCode中使用Vim的编辑模式了。Vim有三种主要模式：正常模式（Normal Mode）、插入模式（Insert Mode）和命令模式（Command Mode）。
正常模式：在正常模式下，你可以使用Vim的快捷键来移动光标、复制粘贴、删除文本等。例如，使用h、j、k、l来分别向左、向下、向上、向右移动光标；使用dd来删除整行文本；使用yy来复制整行文本等。插入模式：在正常模式下，按i、a、o等键可以进入插入模式，此时你可以像在普通文本编辑器中一样输入文本。命令模式：在正常模式下，按:可以进入命令模式，此时你可以执行保存文件、退出Vim等命令。 4. 快捷键和命令 VSCode中的Vim插件支持Vim的绝大多数快捷键和命令。以下是一些常用的Vim快捷键和命令（这里以VSCodeVim插件为例）：
移动光标：h（左）、j（下）、k（上）、l（右）、w（下一个单词）、b（上一个单词）等。复制粘贴：yy（复制当前行）、p（粘贴）等。删除文本：dd（删除当前行）、x（删除当前字符）等。搜索替换：/（开始搜索）、:%s/old/new/g（将文件中所有的"old"替换为"new"）等。保存退出：:w（保存文件）、:q（退出Vim）、:wq（保存并退出Vim）等。 5. 注意事项 在VSCode中使用Vim插件时，可能会与VSCode自身的快捷键产生冲突。你可以通过修改VSCode的设置或Vim插件的设置来解决这些冲突。Vim的学习曲线较陡峭，但一旦掌握其快捷键和命令，将会大大提高你的文本编辑效率。建议初学者参考Vim的官方文档或相关教程来学习Vim的使用。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/268/">«</a>
	<span class="pagination__item pagination__item--current">269/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/270/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>