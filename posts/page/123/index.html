<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/824c3929515ee593f4430a37490b5e6f/" rel="bookmark">
			ESlint | 通过VsCode中的ESLint插件来实现自动修正语法错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 安装ESLint插件 安装ESLint的好处：
ESLint会自动高亮错误显示通过配置，ESLint会自动帮助我们修复错误 注意：
ESLint的配置文件必须在根目录下，这个插件才能才能生效。打开项目必须以根目录打开，一次打开一个项目
使用了ESLint校验之后，把VsCode带的那些格式化工具全禁用了
如：Beatify 和 Prettier - Code formatter
2 配置seetings.json文件 添加如下代码：
// 当保存的时候，eslint自动帮我们修复错误 "editor.codeActionsOnSave": { "source.fixAll": true }, // 保存代码，不自动格式化 "editor.formatOnSave": false 3 保存即可生效 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/158aab19583a54dcf31bac9df084a3e0/" rel="bookmark">
			Django视图与URLs路由详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Django Web框架中，视图（Views）和URLs路由（URL routing）是Web应用开发的核心概念。它们共同负责将用户的请求映射到相应的Python函数，并返回适当的响应。本篇博客将深入探讨Django的视图和URLs路由系统，提供实际的代码示例和操作指导，确保读者能够具体而实际地了解如何使用这些功能来构建健壮的Web应用。
目录
Django视图与URLs路由详解
一、理解Django视图
1. 创建基本视图
2. 使用通用视图
3. 视图高级用法
二、配置URLs路由
1. 基本路由配置
1.动态路由参数
2. 高级路由技术
1.使用视图类
2.使用视图集
3.嵌套路令
三、进阶：使用装饰器和混入
1. 装饰器
2. 混入
四、安全性和权限
1. 安全性防护
2. 权限控制
五、测试和调试
1. 单元测试和集成测试
2. 调试工具
3. 测试覆盖率
六、总结
Django视图与URLs路由详解 一、理解Django视图 Django视图是一个Python函数，它接收一个Web请求并返回一个Web响应。视图函数处理从用户那里接收的数据，与模型交互（如果需要的话），并返回包含HTML内容的HttpResponse对象或其他类型的响应。
结合菜鸟观看：Django 视图 | 菜鸟教程
1. 创建基本视图 创建视图的第一步是定义一个函数。这个函数需要接收几个特定的参数，通常是request对象加上任意数量的HTTP方法（如GET或POST）。
from django.http import HttpResponse def hello(request): return HttpResponse("Hello, World!") 在这个例子中，hello函数就是一个简单视图。当用户访问与该视图相关联的URL时，他们将看到消息"Hello, World!"。
2. 使用通用视图 虽然可以手动编写视图来处理常见的Web请求，但Django提供了一系列的通用视图，这些视图可以帮助你快速实现标准的Web功能，例如创建、读取、更新和删除（CRUD）操作。
from django.views.generic import TemplateView class AboutView(TemplateView): template_name = 'about.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/158aab19583a54dcf31bac9df084a3e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faecb9060729d1cf8167d1cb44244af1/" rel="bookmark">
			使用Django Rest Framework构建API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Django Rest Framework (DRF) 是一个强大且灵活的工具集，用以构建Web API。它基于Django，一个非常流行的Python Web框架。在本文中，我们将深入探讨如何使用DRF来构建一个高效、结构化的API。
目录
使用Django Rest Framework构建API
一、环境设置和项目创建
1. Python和Django的安装
2. Django和DRF的安装
3. 创建新的Django项目
4. 添加应用
5. 虚拟环境与依赖管理
二、序列化数据
1. 理解序列化和反序列化
2. 创建序列化器
3. 序列化器的高级用法
三、视图和路由
1. 创建API视图
2. 配置路由
3. 高级路由配置
四、安全性和权限
1. 全局设置认证和权限
2. 细节级别安全设置
五、测试和文档
1. 单元测试
2. 集成测试和验收测试
3. 文档生成
六、总结
使用Django Rest Framework构建API 一、环境设置和项目创建 在开始之前，确保您已经安装了Python和Django的环境。Python和Django是开发任何Django项目的基石，因此，确认安装是初步且关键的步骤。安装Python通常是直接的，但确保您正在使用支持的版本（至少是Python 3.6及以上版本）。
1. Python和Django的安装 下载并安装Python： 访问Python官方网站，下载适合您操作系统的Python版本，并执行安装程序。（Welcome to Python.org）设置Python环境变量： 确保Python可执行文件的路径被添加到系统的环境变量中，这使得您可以在命令行中全局访问Python命令。验证Python安装： 在命令行中输入python或python3，您应该看到Python的交互式 shell。 2. Django和DRF的安装 安装Django： Django可以通过Python的包管理工具pip进行安装。在命令行中运行pip install django应该足够安装Django框架。 pip install djangorestframework 检查Django安装： 通过创建一个新的Django项目来测试安装是否成功。在命令行中输入django-admin startproject testproject，然后进入该项目目录，运行python manage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/faecb9060729d1cf8167d1cb44244af1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffac3f39754261a4eb4e516719487beb/" rel="bookmark">
			防御课第2次作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验拓扑图
实验目的
7，办公区设备可以通过电信链路和移动链路上网(多对多的NAT，并且需要保留一个公网IP不能用来转换)
8，分公司设备可以通过总公司的移动链路和电信链路访问到Dmz区的http服务器
9，多出口环境基于带宽比例进行选路，但是，办公区中10.0.2.10该设备只能通过电信的链路访问互联网。链路开启过载保护，保护阈值80%；
10，分公司内部的客户端可以通过域名访问到内部的服务器，公网设备也可以通过域名访问到分公司内部服务器；
11，游客区仅能通过移动链路访问互联网
实验开始 7，办公区设备可以通过电信链路和移动链路上网(多对多的NAT，并且需要保留一个公网IP不能用来转换) 建立nat策略
移动的nat策略配置完成，电信nat策略相同
8，分公司设备可以通过总公司的移动链路和电信链路访问到Dmz区的http服务器 分公司到总公司的nat策略：
9，多出口环境基于带宽比例进行选路，但是，办公区中10.0.2.10该设备只能通过电信的链路访问互联网。链路开启过载保护，保护阈值80%； 办公区中10.0.2.10该设备只能通过电信的链路访问互联网
配置·一条策略路由
10，分公司内部的客户端可以通过域名访问到内部的服务器，公网设备也可以通过域名访问到分公司内部服务器； 分公司到内部：
11，游客区仅能通过移动链路访问互联网 游客区写一条NAT，做一条easy ip
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef5444a8a77fdba3efefaec2b8df75ac/" rel="bookmark">
			关于银联支付交易状态码的一些分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
关于银联支付
一些准备
交易状态码的一些分析
小结
关于银联支付 目前B2C购物支付场景下，支付宝和微信的在线支付已经成为我们经常遇到的支付方式。另外，银联支付也是我们日常的一种支付方式，本文所指的银联支付即指中国银联网关支付产品，主要适用于持卡人在商户网站B2C购物支付场景，持卡人通过点击银联在线支付图标（可选择支付类型），并在银联在线支付网关完成支付信息录入，最终完成支付。银联在线支付支持输入卡号付款、用户登录支付、网银支付、迷你付（IC卡支付）等多种付款方式，用户通过统一入口，访问支付首页，按照提示和所列功能即可完成支付。
一些准备 做为软件开发商，实现银联在线支付，需要协助（但不必要）目标商户签署支付协议，开通商户平台。以2007版支付为例，开通过商户平台需要提交许多资料，包括企业及个人信息（如管理员用户名、名称、手机号等）备案。本文将不重点介绍如何实现在线支付，仅就支付反馈中遇到的一些问题进行分析。
在分析前，我们简单讲述一下要 POST 的一些参数和数据，参见下表：
序号字段名类型说明1MerId数字串必填，为银联统一分配给商户的商户号，15位长度2OrdId数字串必填，商户提交给银联的交易订单号，16位长度，请注意生成的订单号当天支付如果不成功，则再次使用相同的订单号提交后会提示重复交易，但次日该订单号仍可以做为交易失败后的“新”订单号继续在线支付。从另一个角度来说，使用固定订单号有助于商户端更新支付状态失败造成用户的重复交易。3TransAmt数字串必填，订单交易金额，12位长度，左补0，单位为分。如 000000007890，表示七十八元九角零分，即 78.90 元。4CuryId数字串必填，订单交易币种，3位长度，固定为人民币1565TransDate数字串必填，订单交易日期，8位长度6TransType数字串必填，交易类型，4位长度，0001 表示消费，0002 表示退款7Version数字串必填，支付接入版本号，如 200701298BgRetUrl数字串必填，后台交易接收的回调 URL，URL地址的长度不超过80个字节9PageRetUrl数字串必填，前台交易页面接收的回调 URL（显示给用户方的页面，交易情况显示详情页面），URL地址的长度不超过80个字节10GateId数字串非必填，支付网关号11Priv1数字串非必填，商户私有域，长度不超过60个字节，属于商户的备注内容12ChkValue数字串必填，256字节长的ASCII码，是本次交易的关键数字签名 以下是示例代码，提供了一个服务器 Form 和一些隐藏字段域 准备提交时使用
&lt;form id="payform" runat="server"&gt; &lt;input type="hidden" name="MerId" value="" id="MerId" runat="server"/&gt; &lt;input type="hidden" name="OrdId" value="" id="OrdId" runat="server"/&gt; &lt;input type="hidden" name="TransAmt" value="" id="TransAmt" runat="server"/&gt; &lt;input type="hidden" name="CuryId" value="156" id="CuryId" runat="server"/&gt; &lt;input type="hidden" name="TransDate" value="" id="TransDate" runat="server"/&gt; &lt;input type="hidden" name="TransType" value="0001" id="TransType" runat="server"/&gt; &lt;input type="hidden" name="Version" value="" id="Version" runat="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef5444a8a77fdba3efefaec2b8df75ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e003aa04ba700d8a477aa728456e055/" rel="bookmark">
			Redis常见面试题汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Redis中的底层数据结构 String(字符串、整数或浮点数)： String 是Redis最基本的数据类型，一个key对应一个value，value的最大值为512MString类型是二进制安全的（原理在2），意味着redis可以包含任何数据，如图片、视频（可以转换为二进制编码）和序列化对象 List(列表)：redis列表是简单的字符串列表，单键多值，按照插入顺序排序，可以选择添加一个元素到列表的表头或者表尾Set(无序集合)：redis的set是String类型的无序集合，可以实现元素的自动排重和判断元素是否存在Hash(包含键值对的无序散列表)：RedisHash是一个String类型的 field 和 value 的映射表，hash特别适合于存储对象Zset(有序集合)：Zset也就是SortedSet，每个元素都需要保存一个score值和一个member值，member必须唯一，可以根据score值进行排序，也可以根据member查询score。 2.Redis为什么那么快？ （1）完全基于内存，数据存在内存中，绝大部分请求是纯粹的内存操作，非常快速，跟传统的磁盘文件数据存储相比，避免了通过磁盘IO读取到内存这部分的开销。
（2）数据结构简单，对数据操作也简单。Redis中的数据结构是专门进行设计的，每种数据结构都有一种或多种数据结构来支持。Redis正是依赖这些灵活的数据结构，来提升读取和写入的性能。
（3）采用单线程，省去了很多上下文切换的时间以及CPU消耗，不存在竞争条件，不用去考虑各种锁的问题，不存在加锁释放锁操作，也不会出现死锁而导致的性能消耗。
（4）使用基于IO多路复用机制的线程模型，可以处理并发的链接。
3.解释一下什么是I/O多路复用模型？ I/O多路复用是指利用单个线程来同时监听多个Socket，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。目前的I/O多路复用都是采用的epoll模式实现，它会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间，不需要挨个遍历Socket来判断是否就绪，提升了性能。
其中Redis的网络模型就是使用I/O多路复用结合事件的处理器来应对多个Socket请求，比如，提供了连接应答处理器、命令回复处理器，命令请求处理器。
在Redis6.0之后，为了提升更好的性能，在命令回复处理器使用了多线程来处理回复事件，在命令请求处理器中，将命令的转换使用了多线程，增加命令转换速度，在命令执行的时候，依然是单线程。
4.什么是缓存穿透 ? 怎么解决 ? 缓存穿透是指查询一个一定不存在的数据，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到DB去查询，可能导致DB挂掉。这种情况大概率是遭到了攻击。解决方案的话，我们通常都会用布隆过滤器来解决它。
布隆过滤器：布隆过滤器主要是用于检索一个元素是否在一个集合中。我们当时使用的是redisson实现的布隆过滤器。
它的底层主要是先去初始化一个比较大的数组，里面存放的二进制0或1。在一开始都是0，当一个key来了之后经过3次hash计算，模于数组长度找到数据的下标然后把数组中原来的0改为1，这样的话，三个数组的位置就能标明一个key的存在。查找的过程也是一样的。
当然是有缺点的，布隆过滤器有可能会产生一定的误判，我们一般可以设置这个误判率，大概不会超过5%，其实这个误判是必然存在的，要不就得增加数组的长度，其实已经算是很划分了，5%以内的误判率一般的项目也能接爱，不至于高并发下压倒数据库。
5.什么是缓存击穿 ? 怎么解决 ? 缓存击穿的意思是对于设置了过期时间的key，缓存在某个时间点过期的时候，恰好这时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把DB压垮。
解决方案有两种方式：
第一可以使用互斥锁：当缓存失效时，不立即去load db，先使用如Redis的setnx去设置一个互斥锁，当操作成功返回时再进行load db的操作并回设缓存，否则重试get缓存的方法。
第二种方案可以设置当前key逻辑过期，大概是思路如下：
在设置key的时候，设置一个过期时间字段一块存入缓存中，不给当前key设置过期时间。当查询的时候，从redis取出数据后判断时间是否过期。如果过期则开通另外一个线程进行数据同步，当前线程正常返回数据，这个数据不是最新的。
当然两种方案各有利弊： 如果选择数据的强一致性，建议使用分布式锁的方案，性能上可能没那么高，锁需要等，也有可能产生死锁的问题。 如果选择key的逻辑删除，则优先考虑的高可用性，性能比较高，但是数据同步这块做不到强一致。
6.什么是缓存雪崩 ? 怎么解决 ? 缓存雪崩意思是设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。与缓存击穿的区别：雪崩是很多key，击穿是某一个key缓存。
解决方案：主要是可以将缓存失效时间分散开，比如可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。
7.redis做为缓存，mysql的数据如何与redis进行同步呢？（双写一致性） 双写一致性：当修改了数据库的数据也要同时更新缓存的数据，缓存和数据库的数据要保持一致。
强一致性：如果项目要求数据库与Redis保持高度一致，可以采用读写锁保证强一致性。采用redisson实现的读写锁，在读的时候添加共享锁，可以保证读读不互斥，读写互斥。当更新数据的时候，添加排他锁，它是读写，读读都互斥，这样就能保证在写数据的同时是不会让其他线程读数据的，避免了脏数据。这里面需要注意的是读方法和写方法上需要使用同一把锁才行。
允许短暂延迟：可以采用的阿里的canal组件实现数据同步:不需要更改业务代码，部署一个canal服务。canal服务把自己伪装成mysql的一个从节点，当mysql数据更新以后，canal会读取binlog数据，然后在通过canal的客户端获取到数据更新缓存即可。
延迟双删：在一个线程删除缓存以后，可以设置一个时间间隔，让这个线程再删除一次缓存，只要其他的线程的写缓存操作是在这个线程两次删缓存操作之间执行的，这个线程就可以在第二次删除缓存时把其他线程写的脏数据给删除掉。但是其中这个延时多久不太好确定，在延时的过程中可能会出现脏数据，并不能保证强致性，所以一般不采用。
8.Redis的数据持久化是怎么做的？ 在Redis中提供了两种数据持久化的方式：1、RDB 2、AOF：
RDB是一个快照文件，它是把redis内存存储的数据写到磁盘上，当redis实例宕机恢复数据的时候，方便从RDB的快照文件中恢复数据。AOF的含义是追加文件，当redis操作写命令的时候，都会存储这个文件中，当redis实例宕机恢复数据的时候，会从这个文件中再次执行一遍命令来恢复数据。 速度快慢：RDB因为是二进制文件，在保存的时候体积也是比较小的，它恢复的比较快，但是它有可能会丢数据，我们通常在项目中也会使用AOF来恢复数据，虽然AOF恢复的速度慢一些，但是它丢数据的风险要小很多，在AOF文件中可以设置刷盘策略，我们当时设置的就是每秒批量写入一次命令。
9.Redis的数据过期策略有哪些 ? 在redis中提供了两种数据过期删除策略。
第一种是惰性删除，在设置该key过期时间后，我们不去管它，当需要该key的时候，我们再检查其是否过期，如果过期，我们就删掉它，反之返回该key。
第二种是定期删除，就是说每隔一段时间，我们就对一些key进行检查，删除里面过期的key。定期删除的两种模式：
SLOW模式是定时任务，执行频率默认为10hz，每次不超过25ms，以通过修改配置文件redis.conf的hz选项来调整这个次数。FAST模式执行频率不固定，每次事件循环会尝试执行，但两次间隔不低于2ms，每次耗时不超过1ms。 通常情况下惰性删除+定期删除两种策略进行配合使用。
10.Redis的数据淘汰策略有哪些 ? 默认是noeviction，不删除任何数据，内部不足直接报错。
Redis的数据淘汰策略是可以在redis的配置文件中进行设置的，里面有两个非常重要的概念，一个是LRU，另外一个是LFU。
LRU的意思就是最近最少使用，用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。
LFU的意思是最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e003aa04ba700d8a477aa728456e055/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b63e8d8d2f8070307c92079ad692748/" rel="bookmark">
			力扣刷题-图论-岛屿类问题-集合实现（c&#43;&#43;实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的老师：力扣链接这道题题解中最高赞的回答nettee，从这篇题解中我学到了dfs框架以及解决思路，并独立完成了该题解里的几道习题本人刷题的习惯是学会一个板子，然后之后的同类题都机械的用这个板子去做，最好不做创新，或许能给其他朋友提供一些规律性帮助，所以本blog把我各个题目的代码都放上来！ 岛屿数量（简单） 岛屿数量
这道是母题，放代码（后面的题目我一律按照这个板子去做） class Solution { public: int num=0; int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) { int rn = grid.size(); // 行数 int cn = grid[0].size(); // 列数 for (int r = 0; r &lt; rn; r++) { for (int c = 0; c &lt; cn; c++) { // 先标记 if (grid[r][c] == '1') { num++; } dfs(grid, r, c); } } return num; } void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int r, int c) { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b63e8d8d2f8070307c92079ad692748/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba39f501f7256e7cd074224ce7adc879/" rel="bookmark">
			IEEE官方列表会议 | 第三届能源与环境工程国际会议(CFEEE 2024)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		会议简介 Brief Introduction
2024年第三届能源与环境工程国际会议(CFEEE 2024)
会议时间：2024年12月2日-4日
召开地点：澳大利亚·凯恩斯
大会官网：CFEEE 2024-2024 International Conference on Frontiers of Energy and Environment Engineering2024 International Conference on Frontiers of Energy and Environment Engineeringhttps://www.cfeee.org/
由詹姆斯·库克大学、浙江大学海南研究院主办，IEEE Northern Australia Section提供技术赞助，CoreShare科享学术交流中心协办的2024年第三届能源与环境工程国际会议(CFEEE 2024)将于2024年12月2日至4日在澳大利亚凯恩斯召开。会议将围绕“能源与环境工程”的最新研究领域而展开，为研究人员、工程师、专家学者以及行业专业人士提供一个交流与探讨最新研究成果的平台，并为与会者们交流新的思想和应用经验建立业务或研究关系。在会议期间您将有机会聆听到行业前沿的学术报告，见证该领域的成果与进步。现热忱欢迎从事相关技术研究的专家学者及学生踊跃投稿并参加本次会议。
CFEEE 2024已进入IEEE官方会议列表！
重要信息 Highlights
截稿时间：2024年9月15日
录用通知：投稿后两周内
检索信息：Ei Compendex＆Scopus双检索
论文出版 Publication
所有被大会接收的论文将收录至CFEEE 2024会议论文集，符合IEEE Xplore的范围和质量要求的文章将被收录，并提交至Ei Compendex, Scopus, CPCI, Google Scholar etc.等主流数据库检索。优秀论文将有机会被推荐至下列国际期刊上发表：
Composites Part B: Engineering (Chinese Academy of Sciences Q1; ISSN: 1879-1069; IF: 13.1; indexed in SCI, EI and Scopus)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba39f501f7256e7cd074224ce7adc879/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dd436eca58294d12c49862df91030fc/" rel="bookmark">
			Java---异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		乐观学习，乐观生活，才能不断前进啊！！！
我的主页：optimistic_chen
我的专栏：c语言 ，Java
欢迎大家访问~
创作不易，大佬们点赞鼓励下吧~
文章目录 什么是异常异常的分类编译时异常运行时异常 抛出异常异常的捕获异常声明throwstry-catch捕获异常finally 处理异常完结 什么是异常 在Java中，将程序执行过程中发生的不正常行为称为异常。
我们或许会遇到以下这些异常：
//算术异常 System.out.println(10 / 0); //数据越界异常 int[] arr = {1, 2, 3}; System.out.println(arr[100]); 由此我们可知，java中不同类型的异常，都有与其对应的类来进行描述。
异常的分类 编译时异常 在程序编译期间发生的异常，称为编译时异常，也称为受检查异常(Checked Exception)
运行时异常 在程序执行期间发生的异常，称为运行时异常，也称为非受检查异常(Unchecked Exception)
RunTimeException以及其子类对应的异常，都称为运行时异常。
注意：
编译时出现的语法性错误，不能称之为异常。例如将 System.out.println 拼写错了, 写成了
system.out.println. 此时编译过程中就会出错, 这是 “编译期” 出错。而运行时指的是程序已经编译通过得到class 文件了, 再由 JVM 执行过程中出现的错误.
抛出异常 在Java中，可以借助throw关键字，抛出一个指定的异常对象，将错误信息告知给调用者。具体语法如下：
throw new XXXException("异常产生的原因"); 代码示例：
public static int getElement(int[] array, int index){ if(null == array){ throw new NullPointerException("传递的数组为null"); } public static void main(String[] args) { int[] array = {1,2,3}; getElement(array, 3); } 【注意事项】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dd436eca58294d12c49862df91030fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6649bfa2584cf5eab7c3197dce9445a/" rel="bookmark">
			《程序猿入职必会（2） · 搭建具备前端展示效果的 Vue》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📢 大家好，我是 【战神刘玉栋】，有10多年的研发经验，致力于前后端技术栈的知识沉淀和传播。 💗
🌻 CSDN入驻不久，希望大家多多支持，后续会继续提升文章质量，绝不滥竽充数，欢迎多多交流。👍
文章目录 写在前面的话搭建 Vue 项目项目创建项目目录启动项目 提升 Vue 项目整合 Axios整合 ElementUI 总结陈词 写在前面的话 书接上回，本系列博文打算指引职场程序猿新人，掌握在企业刚入职时所需要的成长技能，期望可以帮助到大家，略尽绵薄之力。
上篇《程序猿入职必会（1） · 搭建拥有数据交互的 SpringBoot 》文章，介绍了需求背景和后端搭建，学完后，相信你已获得一个具备数据交互能力的后端服务。
那按照传统流程，接下来要开始搞前端了，开始！
搭建 Vue 项目 Tips：这里也可以抽空阅读一下博主之前的文章，《程序猿学会 Vue · 基础与实战篇》，相信可以有所帮助。
项目创建 创建 Vue 项目方式很多，可以先选用官网推荐的 create-vue 创建，详见官网。
操作很简单，输入下面的指令后，按步骤一步步执行即可。
npm create vue@latest
项目目录 如图所示，VueCli创建的项目，目录说明如下：
node_modules目录：用来存放当前项目中使用的 js 依赖，类似于 Maven 的本地 jar 仓库public：静态资源目录，包含主页入口，图标等src：开发主要关注的内容，assets是静态资源、components是组件，main.js是主页入口，App是主组件vue.config.js：Vue CLI配置文件（可选）package.json：项目依赖配置，类似 Maven 的 pom.xml 实际开发中，主要关注 src 和 package.json即可，其他短期内暂时不需要关注。
启动项目 命令行直接输入：npm run dev
看到如下内容：
浏览器访问：http://localhost:5173/，效果如下：
提升 Vue 项目 通过上面步骤，你已经得到了一个前端Vue项目（又得到了！），但是你发现啥也干不了啊，需求怎么做啊？我们是不是要先打通和后端的交互？
没错，接下来就是想办法调到后端接口，那你搜了一下，可以采用 Fetch、Axios、Ajax 等等技术方案。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6649bfa2584cf5eab7c3197dce9445a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bb7077701be2643e23dc39ca725fd40/" rel="bookmark">
			AI多模态实战教程：面壁智能MiniCPM-V多模态大模型问答交互、llama.cpp模型量化和推理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、项目简介 MiniCPM-V 系列是专为视觉-语⾔理解设计的多模态⼤型语⾔模型（MLLMs），提供⾼质量的⽂本输出，已发布4个版本。
1.1 主要模型及特性
（1）MiniCPM-Llama3-V 2.5：
参数规模: 8B性能: 超越GPT-4V-1106、Gemini Pro、Qwen-VL-Max和Claude 3，⽀持30+种语⾔，多模态对话，增强OCR和指令跟随能⼒。部署: 量化、编译优化，可⾼效部署于端侧设备上的CPU和NPU。 （2）MiniCPM-V 2.0
参数规模: 2B性能: 超越Yi-VL 34B、CogVLM-Chat 17B和Qwen-VL-Chat 10B，可处理任意纵横⽐和180万像素图像（例如，1344x1344），低幻觉率。 1.2 MiniCPM-Llama3-V 2.5 关键特性
领先的性能平均得分65.1（OpenCompass），超越多款专有模型。强⼤的OCR能⼒处理任意纵横⽐和180万像素图像，OCRBench评分700+，提供全⽂OCR提取和表格到Markdown转换等⾼级实⽤功能。值得信赖的⾏为采⽤RLAIF-V⽅法，幻觉率10.3%，优于GPT-4V-1106。多语⾔⽀持⽀持30+种语⾔（含德语、法语、⻄班⽛语、意⼤利语、韩语等）。⾼效部署模型量化、CPU/NPU优化，实现端侧设备上的150倍图像编码加速和3倍语⾔解码加速。易⽤性⽀持llama.cpp、ollama，GGUF格式量化模型，LoRA微调，流输出，本地WebUI演示和HuggingFaceSpaces交互演示。 1.3 MiniCPM-V 2.0 关键特性
MiniCPM-V 2.0，这是MiniCPM系列的多模态版本。该模型基于MiniCPM 2.4B和SigLip-400M构建，总共有2.8B参数。MiniCPM-V 2.0显示出强⼤的OCR和多模态理解能⼒，在开源模型中的OCRBench上表现出⾊，甚⾄在场景⽂本理解上可以与Gemini Pro相媲美。
前沿性能在多个基准测试中表现优异（如 OCRBench、TextVQA 等）。超越 Qwen-VL-Chat 9.6B、CogVLM-Chat 17.4B 和 Yi-VL 34B。强⼤的 OCR 能⼒，与 Gemini Pro 性能相当。可信⾏为使⽤多模态 RLHF 技术防⽌⽣成不符合事实的⽂本。与 GPT-4V 在防⽌幻觉⽅⾯匹配。⾼分辨率图像处理接受 180万像素（例如，1344x1344）的图像，⽀持任意⻓宽⽐。提升对细粒度视觉信息的感知能⼒。⾼效能⾼效部署于⼤多数 GPU 和个⼈电脑，⽀持移动设备。使⽤感知器重采样技术，降低内存成本并提升速度。双语⽀持⽀持英语和中⽂的双语多模态能⼒。基于 VisCPM 技术，实现跨语⾔的⼀般化多模态能⼒。 ⼆、案例实战 2.1 环境配置
conda create -n cpm python=3.11 conda activate cpm # 下载项⽬，并进⾏依赖包安装 git clone https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bb7077701be2643e23dc39ca725fd40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82879c87f40e4a030a6f5d71007bec38/" rel="bookmark">
			hadoop分布式云笔记系统-计算机毕业设计源码15725
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要
随着信息技术的飞速发展，人们对于数据的存储、管理和共享需求日益增长。传统的集中式存储系统在处理大规模数据时面临着性能瓶颈和扩展性问题。而 Hadoop 作为一种分布式计算框架，为解决这些问题提供了有效的解决方案。
本研究旨在设计并实现一种基于 Hadoop 的分布式云笔记系统。该系统将充分利用 Hadoop 的分布式存储和计算能力，提供高效、可靠和安全的云笔记服务。通过将数据分布在多个节点上，不仅可以提高系统的可靠性和容错性，还能够实现水平扩展，以应对不断增长的数据量和用户需求。
通过本研究，期望为用户提供一种灵活、高效且安全的云笔记解决方案，使他们能够更加方便地记录、组织和分享知识。同时，这也将为分布式系统的应用和发展提供有益的探索和实践。
关键词：分布式云笔记系统；Mysql； Abstract
With the rapid development of information technology, people's demand for data storage, management, and sharing is growing day by day. Traditional centralized storage systems face performance bottlenecks and scalability issues when processing large-scale data. As a distributed computing framework, Hadoop provides effective solutions to address these issues.
This study aims to design and implement a distributed cloud note taking system based on Hadoop.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82879c87f40e4a030a6f5d71007bec38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b6b72de36cacec51b960968dbf1efea/" rel="bookmark">
			【Java】：洗牌功能和杨辉三角的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		洗牌 此操作包含的基本功能有：
组牌：组建 52 张扑克牌 四种花色：“♥️”，“♠️”，“⬛️”，“♣️”每种花色 13 张牌：1~13 洗牌：将 52 张扑克牌打乱顺序发牌：给三个人每人发 5 张牌 扩展功能：
清牌：将每人手中牌按照面值进行从大到小排序 Card 类 在此类中，我们将完成对每一张牌的构造
类中含有成员变量
花色：suit面值：rank 带有一个含参的构造方法，用来之后传入对应参数进行新牌的构造
重写 toString() 方法，让输出的结果更美观
public class Card { public int rank; public String suit; public Card(int rank, String suit) { this.rank = rank; this.suit = suit; } @Override public String toString() { return "{" + + rank + " " + suit + "}"; } } CardBox 类 所有的功能都将在这个类中进行具体地实现
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b6b72de36cacec51b960968dbf1efea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a23f4d383ff57b1df0c0c232ea51a7e/" rel="bookmark">
			Easyspider 开源可视化爬虫工具，解决你身边数据提取的需求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 之前看到有博主推荐Easyspider工具，可用来进行可视化爬虫提取数据，想到自己平常有时需要提取一些页面数据，顺手一个收藏，等有时间的时候，开箱测试了下，果然好使，之前没这个工具，遇到不能下载的页面数据，还忙活半天研究使用python，自己学习写脚本提取数据。有了这个工具，瞬间自己之前搞的小工具是一点不香了~。所以还是要多学习，多借鉴，多使用各种工具，才能更好的解放生产劳动力。
二、基本介绍 可视化爬虫软件:EasySpider 30.4k⭐
OpenGithub社区：https://open.itc.cn/
Github : https://github.com/OpenGithubs
它是一个可视化爬虫软件，提供了图形化界面，使用户可以轻松设计和执行爬虫任务，无需编写复杂的代码。EasySpider提供了简单易用的工具，帮助用户快速爬取所需的数据，并支持数据的定制和导出，适用于各种爬虫应用和数据采集需求。
github地址：https://github.com/NaiboWang/EasySpider
B站视频地址：可视化爬虫易采集EasySpider：一个无需写代码，可视化的几分钟设计一个爬虫的开源免费软件_哔哩哔哩_bilibili
三、简单使用测试 1、下载安装
下载易采集/Download EasySpider
进入 Releases Page 下载最新版本。如果下载速度慢，可以考虑中国境内下载地址：中国境内下载地址。
Refer to the Releases Page to download the latest version of EasySpider.
2、解压使用
下载的压缩包直接解压后免安装使用。
3、程序运行
4、测试案例-全国百强大学名单信息提取
1）开始
点击【设计/修改任务】，先编制作业模板。
2）选择设计模式
根据使用场景，选择浏览器设计模式。如网站不需要登陆选【纯净版浏览器设计】，需要登陆则选择【带用户信息浏览器设计】。这里选择纯净版浏览器设计
3）进入到任务列表后，点击创建新任务
4）输入网址并开始设计
5）设计采集步骤
如果提取的页面没有翻页操作，可以保存当前的设计流程，提取的数据字段名可以根据需要进行自定义修改。
保存的任务也可以根据需要自定义部分参数。
6）任务执行
任务执行过程中，会调用打卡浏览器及执行窗口，如下图所示，有执行完成提示后，即可关闭窗口，到程序目录的data子目录中可看到提取的数据结果。
7）结果展示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b889dfa1d5e82d4601b04850644bed44/" rel="bookmark">
			内存泄漏详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是内存泄漏内存泄漏的原因排查及解决内存泄漏避免内存泄漏及时释放资源设置合理的变量作用域及时清理不需要的对象避免无限增长避免内部类持有外部类引用使用弱引用 什么是内存泄漏 内存泄漏是指不使用的对象持续占有内存使得内存得不到释放，从而造成内存空间的浪费。严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。但实际情况很多时候一些不太好的实践会导致对象的生命周期变得很长，甚至导致00M，也可以叫做宽泛意义上的“内存泄漏”。
举个例子，创建的连接不再使用时，需要调用close方法关闭连接，只有连接被关闭后，GC才会回收对应的对象。忘记关闭这些资源会导致持续占有内存，无法被GC回收。这样就会导致内存泄露，最终导致内存溢出。
public class MemoryLeak { public static void main(String[] args) { try{ Connection conn =null; Class.forName("com.mysql.jdbc.Driver"); conn =DriverManager.getConnection("url","",""); Statement stmt =conn.createStatement(); ResultSet rs =stmt.executeQuery("...."); } catch(Exception e){//异常日志 } finally { // 1．关闭结果集 Statement // 2．关闭声明的对象 ResultSet // 3．关闭连接 Connection } } } 内存泄漏最明显的问题是频繁GC，从而STW次数增加，导致用户体验变差。如果内存泄露问题严重，会导致OOM，直接导致程序不能正常运行。尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OutOfMemory异常，导致程序崩溃。
内存泄漏的原因 Java使用可达性分析算法来标记垃圾对象。在这个过程中，算法会标记那些仍然可以从根对象（如栈、静态变量等）直接访问到的对象为“可达”，而那些无法从根对象访问到的对象则标记为“不可达”。不可达的对象是候选垃圾，可以被回收。有时候即使某些对象不再使用，它们的引用链可能仍然存在，导致这些对象没有被标记为不可达，从而造成内存泄漏。在这种情况下，虽然这些对象已经不再被实际使用，但由于引用链未断开，它们仍然占用内存。
大多数内存泄露的原因是，长生命周期的对象引用了短生命周期的对象。例如，A对象引用B对象，A对象的生命周期（t1-t4）比B对象的生命周期（t2-t3）长的多。当B对象没有被应用程序使用之后，A对象仍然在引用着B对象。这样，垃圾回收器就没办法将B对象从内存中移除，从而导致内存泄露问题。
所以减少长生命周期对象持有短生命周期对象的强引用是解决内存泄漏的一个关键点。利用弱引用或者软引用可以让垃圾回收器更容易回收不再需要的对象。对于外部资源，如数据库连接、文件、网络连接，用完后应该及时关闭。try-with-resources语句是管理这些资源的有效工具，同时移除不再需要的事件监听器也能防止内存泄漏。管理集合时，设定大小限制并定期清理过期数据可以避免无限增长。使用有界数据结构能帮助控制缓存的大小。静态集合要特别留意，避免它们占用过多内存，通过定期清理来管理数据的存储。通过这些措施，可以减少内存泄漏的风险。
排查及解决内存泄漏 根据运维之前收集到的内存数据、GC日志尝试判断哪里出现了问题。结果发现老年代的内存使用就算是发生GC也一直居高不下，而且随着时间推移也越来越高。
使用jstat -gc &lt;vmid&gt; 查看GC垃圾回收统计信息，看Full GC后堆空间使用内存还持续增长，且有增长到Xmx设定值的趋势，基本可以肯定存在内存泄露。如果当前完全垃圾回收后内存增长到一个值之后，又能回落，总体上处于一个动态平衡，那么内存泄漏基本可以排除；也可以隔断时间抽取老年代占用内存情况，如果老年代占用情况持续上升也很有可能存在内存泄露的情况。
内存泄漏的主要表象就是内存不足，所以首先要看一下JVM启动参数中内存空间分配是否过小，如果是这种问题调整该参数即可。如果不是参数调的太小，那么应该确定是否新部署或有新变更。首先需要确认是否在最近进行了新的部署或有其他相关的变更，例如代码更新、配置修改等。这些变更可能导致应用出现性能问题，特别是在高负载情况下。
遇到内存泄漏问题，最经典的就是用MAT工具分析dump文件然后找到具体的代码。但如果dump文件巨大就不建议这样，可以使用其他方案，例如，重启、本地复现、jmap -histo:live &lt;pid&gt;在线进行分析等其他方案解决。使用MAT定位内存泄漏思路：
打开MAT中histogram，找到堆内存中占用最大的对象，内存泄漏很有可能就是由大对象导致的；
由大对象找被哪些线程引用，查看内存占用最大的线程；
从线程中的堆栈信息找到项目中自定义的包和对象，从而可定位到具体的代码；
避免内存泄漏 内存泄漏是由代码中的问题导致的，这些问题通常源于编程错误、设计不良或对资源管理的忽视。那想要避免内存泄漏，就需要从代码层面入手。
及时释放资源 如数据库连接、网络连接和IO连接等，当不再使用时，需要调用close方法来释放连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则如果在连接过程中，对一些对象不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b889dfa1d5e82d4601b04850644bed44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4acd0330dba439da81814df77f672fd/" rel="bookmark">
			Spark 大规模机器学习（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文：zh.annas-archive.org/md5/7A35D303E4132E910DFC5ADB5679B82A
译者：飞龙
协议：CC BY-NC-SA 4.0
前言 机器学习的核心是关注将原始数据转化为可操作智能的算法。这一事实使得机器学习非常适合于大数据的预测分析。因此，如果没有机器学习，要跟上这些大规模信息流几乎是不可能的。相对较新且新兴的技术 Spark 为大数据工程师和数据科学家提供了一个强大的响应和统一的引擎，既更快速又易于使用。
这使得来自多个领域的学习者能够以更大规模地交互解决他们的机器学习问题。本书旨在使数据科学家、工程师和研究人员能够开发和部署规模化的机器学习应用程序，以便他们学会如何在数据密集型环境中处理大数据集群，构建强大的机器学习模型。
本书的内容是从 Spark 和 ML 基础开始以自下而上的方式编写的，探索了特征工程中的数据，构建可扩展的 ML 管道，通过调整和适应新的数据和问题类型，最终进行模型构建和部署。为了更清晰，我们以这样一种方式提供了章节大纲，以便具有最基本的机器学习和 Spark 编程知识的新读者能够跟随示例，并朝着一些真实的机器学习问题及其解决方案迈进。
本书内容包括以下内容 第一章，使用 Spark 进行数据分析简介，本章介绍了 Spark 的概述、计算范式、安装，并帮助我们开始使用 Spark。它将简要描述 Spark 的主要组件，并专注于其具有弹性分布式数据集（RDD）和数据集的新计算进展。然后，它将专注于 Spark 的机器学习库生态系统。在扩展到 Amazon EC2 之前，将演示使用 Spark 和 Maven 安装、配置和打包简单的机器学习应用程序。
第二章，机器学习最佳实践，提供了对统计机器学习（ML）技术的概念介绍，旨在带领新手从对机器学习的最基本知识到成为熟练的从业者。本章的第二部分侧重于为根据应用类型和要求选择合适的机器学习算法提供一些建议。然后，它将介绍应用大规模机器学习管道时的一些最佳实践。
第三章，通过了解数据来理解问题，详细介绍了用于处理结构化数据的数据集和弹性分布式数据集（RDD）API，旨在提供对可用数据进行基本理解的机器学习问题。最后，您将能够轻松处理基本和复杂的数据操作。将提供使用 RDD 和基于数据集的数据操作的基本抽象的一些比较，以展示在编程和性能方面的收益。此外，我们将指导您走上正确的道路，以便您能够使用 Spark 将 RDD 或数据对象持久化在内存中，从而在后期的并行操作中有效地重复使用。
《第四章》《通过特征工程提取知识》解释了了解应该用于创建预测模型的特征不仅至关重要，而且可能是一个需要深入了解问题领域的难题。可以自动选择数据中对某人正在处理的问题最有用或最相关的特征。考虑到这些问题，本章详细介绍了特征工程，解释了应用它的原因以及特征工程中的一些最佳实践。
除此之外，还将讨论应用于大规模机器学习技术的特征提取、转换和选择的理论描述和示例，使用 Spark MLlib 和 Spark ML API。
《第五章》《通过示例进行监督和无监督学习》将提供围绕如何快速而有力地将监督和无监督技术应用于可用数据解决新问题的实际知识，这些知识是基于前几章的一些广泛使用的示例。这些示例将从 Spark 的角度进行演示。
《第六章》《构建可扩展的机器学习管道》解释了机器学习的最终目标是使机器能够在不需要繁琐和耗时的人工参与和交互的情况下自动从数据中构建模型。因此，本章将指导读者通过使用 Spark MLlib 和 Spark ML 创建一些实用和广泛使用的机器学习管道和应用。将详细描述这两个 API，并且还将涵盖基线用例。然后，我们将专注于扩展 ML 应用程序，使其能够应对不断增加的数据负载。
《第七章》《调整机器学习模型》表明，调整算法或机器学习应用可以简单地被视为一个过程，通过这个过程优化影响模型的参数，以使算法表现最佳。本章旨在指导读者进行模型调整。它将涵盖用于优化 ML 算法性能的主要技术。技术将从 MLlib 和 Spark ML 的角度进行解释。我们还将展示如何通过调整多个参数（如超参数、MLlib 和 Spark ML 的网格搜索参数、假设检验、随机搜索参数调整和交叉验证）来改善 ML 模型的性能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4acd0330dba439da81814df77f672fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba1d9bf994d4fcdd59a3b291e7c9089d/" rel="bookmark">
			数据结构——双向链表及其总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.概述 链表根据是否带头、是否双向、是否循环可以分为八种，双向链表是典型的带头双向循环链表。
双向链表的结构可以表示为下：
struct ListNode { int data; struct ListNode* next; struct ListNode* prev; } 2.双向链表的实现过程及其解析 双向链表的实现依旧包含List.h，List.c，test.c
2.1 链表初始化 双向链表为空的情况：只有一个哨兵位。
先定义一个结构如下：
typedef int LTDatatype; typedef struct ListNode { LTDatatype data; struct ListNode* next; struct ListNode* prev; }LTNode; 链表初始化时我们应该先创建一个哨兵位，则实现代码如下：
LTNode* LTBuyNode(LTDatatype x) { LTNode* newnode = (LTNode*)malloc(sizeof(LTNode)); if (newnode == NULL) { perror("malloc fail!"); exit(1); } newnode-&gt;data = x; newnode-&gt;next = newnode; newnode-&gt;prev = newnode; return newnode; } //初始化 void LTInit(LTNode** pphead) { //创建一个哨兵位 *pphead = LTBuyNode(-1); } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba1d9bf994d4fcdd59a3b291e7c9089d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d1a7f2281440d14f55751c888f0e5fe/" rel="bookmark">
			京东百万级调度系统(Buffalo)架构解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：集团数据计算平台 一、调度系统简介 Buffalo调度系统是京东自主研发的分布式DAG作业调度系统，为京东的数据开发工程师、算法工程师、数据分析师等用户提供离线作业的编排与调试、监控运维、DAG调度等功能。其目标是打造行业领先的稳定高效、产品简洁高体验、任务监控全面、资源容器化、系统能力开放化的ETL调度系统。
京东调度系统的核心挑战包括：
业务复杂导致的依赖关系复杂：复杂的数据链路使得部分任务有数百甚至上千个上下游，层级多达数十层。跨天依赖、数据回刷、月度汇总等业务场景使任务间的依赖关系形成一个庞大且复杂的有向无环图（DAG）。业务体量大且稳定性和性能要求高：当前平台拥有数十万任务，百万级依赖关系，日均百万级调度频次。任务关系复杂、执行量大，系统的任何细微异常都可能导致数据链路异常，核心数据受损，对调度系统的稳定性和性能提出了巨大挑战。数据加工场景复杂需要支持丰富的调度能力：平台支持多个BG业务，涉及数据采集、计算、推送、转换等多种任务类型、多种执行方式、多种触发规则，以及任务间的数据传递、数据补录等场景，对系统功能的丰富度和灵活度提出了新的要求。 二、核心技术方案 为支撑灵活的业务加工和工作流编排，快速应对业务发展带来的任务量增长，并保障系统的稳定性，我们在易用性、稳定性和高性能方面做了很多优化。以下将从这三个方面详细介绍。
1. 实体和编排调度模型 a) 双层实体模型 采用主流的双层实体模型，包含两个核心概念：
Action（环节）：最小粒度的执行单位，携带执行相关的信息，如脚本、参数、环境等。Task（任务）：由一个或多个环节和触发规则构成的DAG，Task之间也可以相互依赖，形成外层DAG，实现双层调度。 相比单层实体模型，双层模型具有更强的编排能力和灵活性，同时对单个业务的整合和管理也更友好。
b) 基于实例的调度 任务定义是任务配置的载体，无状态、不可执行。当任务达到运行周期时，会产生相应周期的任务实例（实例化过程）。实例化时会根据任务的配置信息（环节、上游依赖、数据依赖、运行周期等）生成当前周期实例，实例是真正可执行并具有状态的对象。
基于实例的调度模式优点包括：
周期稳定：每个周期都会有实例，不会出现周期缺失的情况，且每个周期的实例可独立操作。依赖明确：任务实例的依赖关系明确且可预期，可以快速追溯和修复问题。 c) 分类分级调度能力 平台提供任务分类分级管理和基于分级的调度能力，确保在资源紧张时优先保障重要业务。同时任务等级信息会传递到底层集群，底层计算集群增加相应保障策略，确保核心业务的稳定性。
2. 高可用架构 Buffalo整体分为三层，每层具备高可用架构，确保系统的高可用和容灾能力：
Manager管理层：提供任务创建、管理和运维功能，管理端无状态，可横向扩展。高可用Scheduler：作为核心调度引擎，负责任务实例的生成和调度，采用多活+主备架构，保障任务执行的唯一性和高效性。多个scheduler会通过数据分片负载处理任务，同时对于任务状态消息进行幂等处理，其中资源调度模块采用主备模式，以便支撑灵活和高效的资源调度能力。当一个节点故障时，其他节点会监测到节点下线，并自动触发接管逻辑，将异常节点任务接管处理，保障故障节点上的任务执行不受影响。容错执行层：负责任务启动和执行，支持物理机和基于K8s的容器化资源，具备高可用特性和灵活的资源管理能力。 ▪物理机：部署worker（也称TaskNode）长进程，任务以独立进程方式运行，多个worker构成节点组对（虚拟节点）外服务，避免单点故障问题。同时worker本身支持消息重传、cgroup资源隔离等高可用特性。
▪k8s弹性资源：与原生k8s对接，任务以短周期pod方式执行，任务结束时pod销毁，天然具备高可用特性，同时具备更精细化的资源管理、差异化执行环境的动态构建能力。
3. 高性能 为应对任务量增长和业务复杂度提升，Buffalo通过以下方式实现高容量、低延迟的编排和调度：
a) 水平扩展 调度引擎采用多活架构，通过数据哈希分片将任务负载分布到多台服务进行调度，保障任务执行的唯一性。
b) 事件驱动 相较传统的定时轮询方式，事件驱动模式在任务依赖条件变更时进行条件计算和校验，避免了遍历耗时和无用计算，提高整体处理性能。
c) 内存调度 前面提到Buffalo具备在物理机集群和k8s集群上启动任务执行的能力，所以需要具备这两种资源的管理和资源调度能力，资源调度的性能也是影响任务分发时效的关键部分。
调度引擎namenode采用的是多活的高可用架构，如果资源调度部分也采用该架构（如左图），那么涉及到同一资源的并发访问和修改的问题，进而引入分布式锁和外部存储，这样整体的性能很难达到理想的目标。
因此，我们在namenode多活架构的基础上，将资源调度部分做了一个主备架构的处理（如右图），会从多个namenode里选择一个作为主资源调度器，其他作为热备，所有namenode的任务资源请求都由主节点进行处理，这样主节点在内存中保存了所有的资源信息，资源调度过程在内存中就可进行，避免了分布式锁和对外部存储的依赖，性能有大幅提升。
d) 冷热数据分离 当系统中任务量较大，任务执行产生的实例数据会快速增长，buffalo每日的实例数据增量超过百万，随着任务量的增长还会持续增长，如果没有适当的方案来处理，数据库很难支撑如此快速的数据增长。
调度系统中的任务有个明显特征 - 定时，就是任务会定时执行，执行完成后的实例，除人为干预外其状态不会再自动发生变更，这部分数据一般只会做查询，所以这部分数据可以做独立存储。我们将状态还会发生变更或频繁操作的数据称作热数据，将这些已经执行结束且基本只有查询需求的数据称作冷数据，并将冷数据单独存储。
当冷热数据分离后，有三个核心问题需要解决：
1）数据结转
任务实例执行完成，处于结束状态的实例都可以被结转，目前采用定时结转的策略。为避免冷数据单表数据量过大，结转规则可以按照季度、月或则更小周期进行拆分存储。
2） 数据定位
当数据结转到冷数据表后，这些实例的状态不会发生变更，单可能还会被未执行的实例所依赖，用户也可能会对这些实例做检索操作，所以这些实例需要能从冷数据表中快速被定位。
•索引表：数据结转到冷数据表时，会根据冷数据表的分区粒度，在索引表记录各冷分区表中的数据范围，如计划运行时间在2023-01-01 至 2023-03-31的数据存储在2023Q1分区表，这样基于时间的范围查询场景，可快速定位。
•主键定位：为了能够根据任务实例主键快速定位，我们参照雪花算法，做了一定的调整，根据任务实例计划运行时间、当前时间、以及namenode id等信息，构建顺序增长的long型id，当给定主键，可从中解析计划运行时间，从而快速定位所在分区。
3）冷数据操作
冷数据被操作的几率比较低，但也存在操作的可能性，比如历史实例的重跑、强制成功等操作。为了保持调度引擎架构的简单性，所有相关的任务执行的处理，都是基于当前表（热表），所以为了能保障被结转的冷数据和热数据一样支持所有操作，冷数据被操作时会从冷数据表恢复至热数据表，从而实现与热数据相同的效果。
4. 开放能力 开放API：通过HTTP协议提供任务配置管理、任务实例操作、状态查询和日志查询等能力。开放事件：基于JDQ异步消息方式，将任务状态和实例状态开放给业务系统，实现状态变更的及时同步。 三、未来规划 Buffalo调度系统将持续优化和迭代升级，提供更好的用户体验和极致性能，包括容器化能力、插件化扩展能力、开放能力和精细化资源管理能力。希望大家提出更多的想法和建议，共同打造稳定、高效、易用的调度平台。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1165ce125b3e1535a353bf2e5610441/" rel="bookmark">
			TRIZ引领光伏电站创新革命：绿色能源的未来已来！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在绿色能源日益受到全球关注的今天，光伏电站作为其中的佼佼者，正以其独特的魅力引领着新能源产业的飞速发展。然而，在这个日新月异的时代，如何持续推动光伏电站的创新与发展，成为了摆在每一位从业者面前的重要课题。幸运的是，TRIZ理论为我们提供了一个全新的视角和方法，它正在悄然改变着光伏电站的未来。
TRIZ，即发明问题解决理论，是一种系统化的创新思维工具。它通过分析大量的专利和发明案例，提炼出了一系列解决复杂问题的通用方法和原则。在光伏电站的创新发展中，TRIZ理论的应用不仅能够帮助我们识别和解决技术难题，还能够激发创新灵感，推动整个产业的进步。
在光伏电站的设计阶段，TRIZ理论可以帮助我们优化电站的布局和结构设计。通过应用TRIZ中的资源分析法和功能分析法，我们可以更加全面地了解电站的各项功能和需求，从而设计出更加高效、稳定、安全的光伏电站。同时，TRIZ理论中的物理技术解法和化学技术解法，还可以为我们提供一系列创新性的解决方案，使得电站的性能得到进一步提升。
在光伏电站的运维阶段，TRIZ理论同样发挥着重要的作用。随着电站运行时间的增长，各种故障和问题也会随之而来。此时，我们可以利用TRIZ中的故障分析和解决原理，对电站进行全方位的故障排查和修复。同时，TRIZ理论中的进化法则和预测方法，还可以帮助我们预测电站未来的发展趋势和可能遇到的问题，从而提前做好应对措施。
除了在技术层面的应用外，TRIZ理论在光伏电站的创新发展中还发挥着更为广泛的作用。它可以帮助我们打破思维定势，激发创新灵感。在光伏电站的发展过程中，往往会遇到各种看似无法解决的问题。然而，正是这些问题推动着整个产业的不断进步。通过应用TRIZ理论中的创新思维方法，我们可以从全新的角度审视问题，找到解决问题的新思路和新方法。
此外，TRIZ理论还可以帮助我们建立更加紧密的产学研合作关系。在光伏电站的创新发展过程中，产学研合作是不可或缺的一环。通过应用TRIZ理论中的知识库和专利分析工具，我们可以更加精准地定位产学研合作的方向和重点，从而实现资源共享、优势互补和互利共赢。
总之，TRIZ理论在光伏电站的创新发展中发挥着越来越重要的作用。它不仅能够帮助我们解决技术难题、优化电站性能、提高运维效率，还能够激发创新灵感、推动产业进步。未来，随着TRIZ理论的不断发展和完善，相信它将会在光伏电站的创新发展中发挥更加重要的作用！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/655a94de2f67cc69e699b4953cbac9e3/" rel="bookmark">
			Scala 和 Spark 大数据分析（七）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文：zh.annas-archive.org/md5/39EECC62E023387EE8C22CA10D1A221A
译者：飞龙
协议：CC BY-NC-SA 4.0
第十四章：是时候整理一下了-用 Spark MLlib 对数据进行聚类 “如果你拿一个星系并试图让它变得更大，它就会成为一群星系，而不是一个星系。如果你试图让它变得比那小，它似乎会自己爆炸”
Jeremiah P. Ostriker 在本章中，我们将深入研究机器学习，并找出如何利用它来对无监督观测数据集中属于某一组或类的记录进行聚类。简而言之，本章将涵盖以下主题：
无监督学习
聚类技术
层次聚类（HC）
基于质心的聚类（CC）
基于分布的聚类（DC）
确定聚类数量
聚类算法之间的比较分析
在计算集群上提交作业
无监督学习 在本节中，我们将用适当的示例简要介绍无监督机器学习技术。让我们从一个实际例子开始讨论。假设你在硬盘上有一个拥挤而庞大的文件夹里有大量非盗版-完全合法的 mp3。现在，如果你可以建立一个预测模型，帮助自动将相似的歌曲分组并组织到你喜欢的类别中，比如乡村音乐、说唱、摇滚等。这种将项目分配到一个组中的行为，例如将 mp3 添加到相应的播放列表，是一种无监督的方式。在之前的章节中，我们假设你有一个正确标记数据的训练数据集。不幸的是，在现实世界中收集数据时，我们并不总是有这种奢侈。例如，假设我们想将大量音乐分成有趣的播放列表。如果我们没有直接访问它们的元数据，我们如何可能将歌曲分组在一起呢？一种可能的方法可能是混合各种机器学习技术，但聚类通常是解决方案的核心。
简而言之，在无监督机器学习问题中，训练数据集的正确类别不可用或未知。因此，类别必须从结构化或非结构化数据集中推导出来，如图 1所示。这基本上意味着这种算法的目标是以某种结构化的方式预处理数据。换句话说，无监督学习算法的主要目标是探索未标记的输入数据中的未知/隐藏模式。然而，无监督学习也包括其他技术，以探索性的方式解释数据的关键特征，以找到隐藏的模式。为了克服这一挑战，聚类技术被广泛使用，以无监督的方式基于某些相似性度量对未标记的数据点进行分组。
有关无监督算法工作原理的深入理论知识，请参考以下三本书：Bousquet，O.；von Luxburg，U.；Raetsch，G.，编辑（2004）。机器学习的高级讲座。Springer-Verlag。ISBN 978-3540231226。或者Duda*，Richard O.；Hart，Peter E.；Stork，David G。（2001）。无监督学习和聚类。模式分类（第 2 版）。Wiley。ISBN 0-471-05669-3 和Jordan，Michael I.；Bishop，Christopher M。（2004）神经网络。在Allen B. Tucker 计算机科学手册，第二版（第 VII 部分：智能系统）。博卡拉顿，FL：查普曼和霍尔/ CRC 出版社。ISBN 1-58488-360-X。
**图 1：**使用 Spark 进行无监督学习
无监督学习示例 在聚类任务中，算法通过分析输入示例之间的相似性将相关特征分组到类别中，其中相似的特征被聚类并用圆圈标记。聚类的用途包括但不限于以下内容：搜索结果分组，如客户分组，用于发现可疑模式的异常检测，用于在文本中找到有用模式的文本分类，用于找到连贯群体的社交网络分析，用于将相关计算机放在一起的数据中心计算集群，用于基于相似特征识别社区的房地产数据分析。我们将展示一个基于 Spark MLlib 的解决方案，用于最后一种用例。
聚类技术 在本节中，我们将讨论聚类技术以及相关挑战和适当的示例。还将提供对层次聚类、基于质心的聚类和基于分布的聚类的简要概述。
无监督学习和聚类 聚类分析是关于将数据样本或数据点分成相应的同类或簇的过程。因此，聚类的一个简单定义可以被认为是将对象组织成成员在某种方式上相似的组。
因此，簇是一组对象，它们在彼此之间是相似的，并且与属于其他簇的对象是不相似的。如图 2所示，如果给定一组对象，聚类算法会根据相似性将这些对象放入一组中。例如，K 均值这样的聚类算法已经找到了数据点组的质心。然而，为了使聚类准确和有效，算法评估了每个点与簇的质心之间的距离。最终，聚类的目标是确定一组未标记数据中的内在分组。
图 2： 聚类原始数据
Spark 支持许多聚类算法，如K 均值，高斯混合，幂迭代聚类（PIC），潜在狄利克雷分配（LDA），二分 K 均值和流式 K 均值。LDA 用于文档分类和文本挖掘中常用的聚类。PIC 用于将具有成对相似性的图的顶点聚类为边属性。然而，为了使本章的目标更清晰和集中，我们将限制我们的讨论在 K 均值，二分 K 均值和高斯混合算法上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/655a94de2f67cc69e699b4953cbac9e3/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/122/">«</a>
	<span class="pagination__item pagination__item--current">123/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/124/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>