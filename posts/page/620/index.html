<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8b10e030918dbcaa8928e2dbf8e386c/" rel="bookmark">
			Java项目实战【超级详细】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件开发流程 角色分工 开发环境搭建 创建普通Maven项目编写pom.xml导入依赖 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.5&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.yjq&lt;/groupId&gt; &lt;artifactId&gt;reggie_take_out&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8b10e030918dbcaa8928e2dbf8e386c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eb98055324c4927b2272743a584f041/" rel="bookmark">
			CUDA安装及环境配置——最新详细版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		确定安装版本 在安装之前呢，我们需要确定三件事
第一：查看显卡支持的最高CUDA的版本，以便下载对应的CUDA安装包
第二：查看对应CUDA对应的VS版本，以便下载并安装对应的VS版本（vs需要先安装）
第三：确定CUDA版本对应的cuDNN版本，这个其实不用太关注，因为在cudnn的下载页面会列出每个版本对应的cuda版本，11.x以上对应的范围很宽
确定显卡支持的CUDA版本 在显卡驱动被正确安装的前提下，在命令行里输入nvidia-smi.exe，效果如图所示
可以看到显示CUDA Version为11.6，说明该显卡最高支持到11.6，我这里就选择11.6的版本，你也可以选择更低的版本比如 11.5,11.4更低的版本
确定CUDA版本支持的VS版本 查询官方安装文档，这里给出文档地址：https://docs.nvidia.com/cuda/archive/11.6.0/cuda-installation-guide-microsoft-windows/index.html
可知，支持的VS版本如下表：
可以看到支持VS2017的15.x以上的版本，VS2019 16.x以上的版本，也支持VS2022 17.0
我这里选择VS2019
确定CUDA版本对应的cuDNN版本 在cudnn下载页面，我们cuda是11.6，这里就选择cuDNNV8.4.0版本的for CUDA11.x版本即可
好了三个安装版本都确定好了，现在开始一个个安装就行，安装的顺序是先安装vs2019、CUDA11.6、然后是cuDNNV8.4.0，如果 你安装的是别的版本，注意它们之间的版本对应就行，套路是一样的。
安装vs2019 官方下载地址：https://visualstudio.microsoft.com/zh-hans/vs/older-downloads/
因为现在最新的VS2022都出来了，要下载VS2019需要注册账户，不愿意注册的小伙伴，可以从我给的百度云盘链接中下（是个在线安装包，版本为VS2019社区版 v16.11,满足刚才CUDA对vs2019 16.x以上的要求）
链接：https://pan.baidu.com/s/1D8eGWZwkRBoGyDiriWa-Hw?pwd=g790
提取码：g790
下载vs2019社区版在线安装器，然后双击运行即可
注意，需要选择C++开发模块，其它根据自己的需求安装就好了，安装路径可以默认，也可以根据自己情况更改一下，然后点击安装就好了，后面都是自动安装了，因为需要在线下载东西，过程有点长，耐心等待一下~~
安装CUDA 下载安装包，在NVIDIA官方网站即可下载，地址为：https://developer.nvidia.com/cuda-toolkit-archive
注意选择你的操作系统，什么版本的 我是Windows11 需要选择11，离线安装包还是在线安装包，省得麻烦就选择离线安装包了，选择好后，点击下面的Download按钮。
安装包下载好后，双击安装包进行安装
弹出这个，临时抽取文件放置位置的，直接点击ok、随后进入系统兼容性的检查，就是看你是否下错安装包了
没问题后会弹出许可协议
直接点击同意并继续，弹出的安装选项，选择自定义
点击下一步
把CUDA选一下，还需要注意一点，如果 你前面没有安装vs，直接安装的这个，需要把CUDA里面的
Visual Studio Integration取消勾选，否则会安装不成功
我们前面已经安装vs2019了，所以我就不取消了，下一步就是选择安装的位置了，你可以直接默认安装在C盘，如果 你像我一样自定义的话，需要记住安装的位置，后面需要用到
下一步之后，就会进行安装
安装完成后，会提示Nsight Visual studio的整合情况，这里提示安装了vs2019版的，正是我们前面安装的VS版本，这样就能在vs2019里面做GPU方面的开发了
点击下一步
这里提示了你选择的组件的安装情况，到这就安装好了，点击关闭。
检查是否安装成功 打开cmd，输入 nvcc -V
出现了你安装的CUDA的版本信息，说明安装成功了
你可能还觉得不过瘾，CUDA里面有个demo_suite文件夹中有些工具，让我们测试，我们一起来试试吧 ，定位安装目录的demo_suite文件夹，我的是
D:\Program Files\Nvidia\CUDA\v11.6\extras\demo_suite
确定cmd的执行位置在这个文件夹
我们先输入deviceQuery，查询一下本机的gpu设备
我们再来测试一下带宽，输入bandwidthTest
能看出结果都是PASS，说明一切运行正常
安装cuDNN 下载安装包，在NVIDIA官方网站即可下载，地址为：https://developer.nvidia.com/rdp/cudnn-archive
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7eb98055324c4927b2272743a584f041/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5e1c913fe357295c03786a6b2769321/" rel="bookmark">
			yolov5-计算fps（新加入：4. 记录运行B导yolov7-tiny后计算fps的方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 0. FPS记录的原理1. 自己的2. 其实yolov5有自带的打印这些参数3. 清风大佬分享的3.1 单个的计算fps函数3.2 整体的完整代码 4. 记录运行B导yolov7-tiny后计算fps的方法 0. FPS记录的原理 参考自：睿智的目标检测21——如何调用摄像头进行目标检测
FPS简单来理解就是图像的刷新频率，也就是每秒多少帧
假设目标检测网络处理1帧要0.02s，此时FPS就是50
#---------------------------分割线-------------------------------- #
也就是说在计算FPS的时候，会强调每秒、每张。因此，在众多博客中计算FPS时，都会注意以下两点：
实现要求每张：将batch-size设置为1实现要求每秒：用1000去除以3个时间之和（1s=1000ms，调用yolov5中的val.py后会计算并打印出pre-process图像预处理、inference推理、NMS非极大值抑制处理这3个ms级时间） 1. 自己的 在yolov5的val.py文件中添加了如下两行代码，即可实现打印：
实现步骤：
在val.py中按住快捷键Ctrl+F搜索Print speeds定位过去在上图中的合适位置添加如下代码： FPS = 1000 / sum(t) LOGGER.info(f'FPS: {round(FPS, 3)}') 调整好合适参数，直接运行val.py即可（但是要注意一下，batch-size要设置为1） 2. 其实yolov5有自带的打印这些参数 参考链接：查看yolov5/lite各层参数量和各层FLOPs
实现方法：（主要是直接调用的yolov5中已经写好的代码utils/torch_utils.py中的profile等函数）
在终端运行yolo.py时，带上参数--profile，这样可以打印整体的参数量、浮点数运算等在终端运行yolo.py时，带上参数--line-profile，这样可以打印出每层的参数量、浮点数等（这第2种方法，在yolov5-master下载下来的val.py中可实现，如果单独下载的yolov5-v6.1中没有这个--line-profile参数） 3. 清风大佬分享的 3.1 单个的计算fps函数 def compute_speed(model, input_size, device, iteration=100): torch.cuda.set_device(device) cudnn.benchmark = True model.eval() model = model.cuda() input = torch.randn(*input_size, device=device) for _ in range(50): model(input) print('=========Eval Forward Time=========') torch.cuda.synchronize() t_start = time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5e1c913fe357295c03786a6b2769321/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7dd9bdd12a3e5aad2dc2dbf2bfb6394/" rel="bookmark">
			SQL Server详细使用教程(包含启动SQL server服务、建立数据库、建表的详细操作) 非常适合初学者
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
目录
前言
一、启动SQL server服务的三种方法
1.不启动SQL server服务的影响
2.方法一：利用cmd启动SQL server服务
3.方法二：利用SQL Server配置管理器启动SQL server服务
4.方法三：在服务管理器中启动SQL server服务
二、建立数据库的方法
三、建表的方法
总结
前言 本文主要详细介绍SQL server2019的简单使用，以《数据库系统概论（第5版）》的第79页—第80页为例，详细介绍如何使用SQL server2019这款数据库软件，包括启动SQL server服务，建立数据库（学生—课程模式S-T）,建立课程表等，内容比较简单，容易理解，适合广大初学者了解SQL server的简单使用。不会涉及到复杂的语法知识，如果有也会详细解释的！（下文标红的字请重点关注一下！）
本文的需要建表的数据如下：
2.Course
课程号
Cno
课程名
Cname
先行课
Cpno
学分
Ccredit
1数据库5 4
2数学23信息系统144操作系统635数据结构746数据处理27PASCAL语言64 一、启动SQL server服务的三种方法 1.不启动SQL server服务的影响 在使用Microsoft SQL Server Management Studio 18r时，必须先启动SQL server服务，如果直接打开Microsoft SQL Server Management Studio 18，输入用户密码后，点击连接，会提示类似下图的错误信息：
出现上面的错误提示的原因是没有启动SQL server服务，导致无法连接服务器，为了解决上面的出现的错误，需要启动SQL server服务器，关闭Microsoft SQL Server Management Studio，按照下述的三种方法之一，启动SQL server服务即可。
2.方法一：利用cmd启动SQL server服务 （1）在开始里面搜索cmd,如下图所示：
（2）选择命令提示符，鼠标右击，点击以管理员身份运行（一定要注意要以管理员身份运行，否则启动SQL server服务会失败！） 打开后界面如下：
（3）在命令提示符中，输入以下的代码：
net start mssqlserver 输入完上述的代码之后，按回车键，会自动启动SQL server服务，此时的界面如下图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7dd9bdd12a3e5aad2dc2dbf2bfb6394/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e85afa31d45b2e13b051fe8bd4724711/" rel="bookmark">
			Python123 期末题库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本篇文章记录在 Python123 上面的题库，代码仅供参考，题量除了学校作业之外还去收集了一些。对有益处的同学可以收藏一下，把感受写在评论区，切勿关注，社恐谢谢！
题库 1. Hello World I 输出Hello World，注意大小写。
print('Hello World') 这个太简单，不会就等着挂科吧，哈哈哈。
2. 说句心里话 A 分两次从控制台接收用户的两个输入：第一个内容为"人名"，第二个内容为"心里话"。
然后将这两个输入内容组成如下句型并输出出来：‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬
(人名)，我想对你说，(心里话)
a=input("") b=input("") print(f'{a:}，我想对你说，{b:}') 掌握输入和 f’ ’ 控制输出格式。
3. 计算矩阵面积A 用户输入矩形的长和宽，计算其面积并输出。
a, b = eval(input()), eval(input()) print(a*b) 和第四题一样注意输入的格式。
4. 输出某个数的整数部分和小数部分 要求用户输入一个小数，能够分别获取整数部分和小数部分，并输出。
zs,xs=input().split('.') print(f'整数部分是{zs},小数部分是{xs}') 5. 三角形周长及面积 输入的三角形的三条边a、b、c 的长度，计算并依次输出三角形的周长和面积。测试用例的数据保证三角形三边数据可以构成三角形。
import math a = eval(input()) b = eval(input()) c = eval(input()) # 保证三角形存在不用判断了 s = (a+b+c)/2 squar = math.sqrt(s*(s-a)*(s-b)*(s-c)) perimeter = a+b+c print('周长={:.2f}'.format(perimeter)) print('面积={:.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e85afa31d45b2e13b051fe8bd4724711/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/565877117642a06d11f311182e0199d2/" rel="bookmark">
			idea构建web项目-超详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、idea构建web项目 idea构建web项目的超级详细教程，一步一步来，完全没问题！
1、新建一个空项目
2、新建java模块，名为webDemo1
3、选择webDemo1右键，选择Add Framework Support
选择Web Application
4、在WEB-INF下新建文件夹classes和lib
5、打开项目结构(Project Structure)
6、项目配置
7、模块配置
8、Facets配置,这里制定了web目录不是一个普通的文件夹，而是web项目
9、 配置Artifacts
10、 添加Tomcat
11、配置Deployment。这个操作可以让Tomcat找到war包所在的位置，从而将web项目部署在Tomcat服务器上
12、添加项目所需要的依赖
(1)导入lib下得jar
web项目需要的jar包都存放在lib目录下，将lib导入
(2)将tomcat相关的jar导入
13、配置完成，运行服务
14、成功运行。
2、写第一个servlet 1、新建java类实现Servlet接口，并实现5个抽象方法
还可以继承GenericServlet,此时只需实现service()方法即可。
还可以继承HttpServlet类，此时只需要重写doGet()方法或者doPost()方法就可以了。
2、编写web.xml
3、在service方法中输入输出语句
4、地址栏输入地址
/5、控制台打印输出
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6450ffd7df66e4c42332009c37fb0e33/" rel="bookmark">
			vue2实现可拖拽甘特图（结合element-ui的gantt图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 接到公司需求，要做一个可拖拽的甘特图来实现排期需求，官方的插件要付费还没有中文的官方文档可以看，就去找了各种开源的demo来看，功能上都不是很齐全，于是总结了很多demo，合在一起组成了一版较为完整的满足需求的甘特图。
二、主要功能 1.拖拽 拖拽功能是甘特图的主要功能，该demo实现了甘特图时间块上、下、左、右拖拽功能。
2.排序 拖拽后时间块进行排序，计算重叠区域大小确定插入位置。
3.时间选择 结合element-ui的日期时间选择器来确定时间轴。
4.搜索 搜索已存在的时间块，并定位到相应位置。
5.新建排期任务 使用element-ui的弹框以及表单 新建成功的排期列表添加到排期任务中。
6.右键菜单 右击时间块，可以进行查看、删除、修改等操作。
7.撤回 每删除或移动时间块后，增加一条操作记录，点击撤回可撤回当前操作。
8.批量操作 在批量操作后点击保存，才向后端存储数据。
三、功能实现 1.默认时间轴线今天的前三后四
// 设置默认时间 当前日期前三后四 defaultDate() { const beg = new Date(new Date().getTime() - 3600 * 1000 * 24 * 3) .toISOString() .replace('T', ' ') .split('.')[0] //默认开始时间3天前 const end = new Date(new Date().getTime() + 3600 * 1000 * 24 * 4) .toISOString() .replace('T', ' ') .split('.')[0]//默认结束时间4天后 this.choiceTime = [beg, end] //将值设置给插件绑定的数据 // console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6450ffd7df66e4c42332009c37fb0e33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/347d2fb3d52e670597d2d45c195c98c0/" rel="bookmark">
			【Qt】边学边写之Qt教程（零基础）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、创建Qt项目1.1 使用向导创建1.2 一个最简单的Qt应用程序1.2.1 main函数中1.2.2 类头文件1.2.3 pro文件1.2.3 命名规范1.2.4 QtCreator常用快捷键 2、Qt 按键小程序2.1 按钮的创建和父子关系2.2 Qt窗口坐标体系2.3 Qt常用API函数2.4 对象树模型 3、信号和槽机制3.1 系统自带的信号和槽3.2 自定义信号和槽3.2.1 自定义信号使用条件3.2.2 自定义槽函数使用条件3.2.3 使用自定义信号和槽 3.3 信号和槽的拓展3.4 Qt4版本的信号槽写法3.5 QDebug3.5 Lambda表达式3.5.1 局部变量引入方式3.5.2 函数参数3.5.3 选项Opt3.5.4 槽函数使用Lambda表达式3.5.5 函数返回值 -&gt;retType 4、复习 1、创建Qt项目 1.1 使用向导创建 打开Qt Creator 界面选择 New Project或者选择菜单栏 【文件】-【新建文件或项目】菜单项
弹出New Project对话框，选择Qt Widgets Application，
选择【Choose】按钮，弹出如下对话框
设置项目名称和路径，按照向导进行下一步，
选择编译套件
向导会默认添加一个继承自QMainWindow的类，可以在此修改类的名字和基类。默认的基类有QMainWindow、QWidget以及QDialog三个，我们可以选择QWidget（类似于空窗口），QWidget 是所有能看到的窗口或者控件的父类，QMainWindow、QDialog 都继承自它
这里我们可以先创建一个不带UI的界面，继续下一步
系统会默认给我们添加main.cpp、mywidget.cpp、 mywidget.h和一个.pro项目文件，点击完成，即可创建出一个Qt桌面程序。
1.2 一个最简单的Qt应用程序 1.2.1 main函数中 #include "widget.h" #include &lt;QApplication&gt; int main(int argc, char *argv[]) { QApplication a(argc, argv); Widget w; w.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/347d2fb3d52e670597d2d45c195c98c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98473c18e6ead3f9ba1f89c1c5be89ed/" rel="bookmark">
			Tomcat安装步骤及详细配置教程（2022最新版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上的tomcat安装及配置教程一大堆，但是好多都过时了，根本不适用现在的版本，今天凯歌整理一篇Tomcat安装步骤及详细配置教程，2022年最新版~
Tomcat安装及配置教程主要分为四步： 步骤一：首先确认自己是否已经安装JDK
步骤二：下载安装Tomcat
步骤三：Tomcat配置环境变量
步骤四：验证Tomcat配置是否成功
OK，我们开始！！！
一、首先确认自己是否已经安装JDK Win+R打开运行，输入cmd回车，在DOS窗口中输入java。
出现这些代表已经安装，然后查看自己的JDK版本。
输入：java -version
可以看到我的JDK版本是1.8的。
Tomcat在JDK1.8版本下能够正常运行，其他版本不能正常启动。
二、下载安装Tomcat 官网地址：Apache Tomcat® - Welcome!
选择Tomcat8版本（自己随意，这里我是选择的8版本）
选择下载64位
链接: https://pan.baidu.com/s/1ouiM065WTzFK58rIBaeEcQ?pwd=y9nj 提取码: y9nj （官网下载比较慢，这里我放上百度网盘链接）
插播一条广告：需要开通正版JetBrains全家桶的可以联系我，56元一年，正版授权激活，官网可查有效期，有需要的加我微信：poxiaozhiai6，备注：904。
三、Tomcat配置环境变量 首先右击此电脑，属性，打开高级系统设置：
点击环境变量：
在系统变量这一栏里选择新建：
出现这个框：
变量名：CATALINA_HOME
变量值：解压后的路径（参考我的图片来就行）
之后找系统变量中的Path，点击编辑：
之后点击新建，输入%CATALINA_HOME%\bin。如图，再点击确定：
之后点击确定，确定。
四、验证Tomcat配置是否成功 首先win+R输入cmd回车，然后再DOS窗口输入startup.bat回车。
之后会出现Tomcat启动窗口。
代表配置成功。
如果出现报错或者一闪而过，可能是端口号被占用。Tomcat默认窗口时8080。
可以尝试重启电脑，再启动Tomcat试试。不行的话，就修改Tomcat端口号。
如果配置成功，打开浏览器，输入http://localhost:8080/
（刚才那个黑窗口一定不能关闭，否则肯定打不开这个页面）
如果出现如下图，则表示成功。
OK，搞定，帮到你了吗？如果帮你安装配置好了tomcat记得给我点个赞哈~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21a1e1998e95b21bef30b16bb58fc57f/" rel="bookmark">
			Node.js和Vue的安装与配置（超详细步骤）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、下载二、安装三、配置四、安装配置vue五、构建运行Vue项目 一、下载 Node.js官网下载
大家根据自己的系统进行下载安装包（我的电脑是windows10-64位，所以下载第一个）
二、安装 点击下载的安装包进行安装
点击Next
打勾并点击Next
默认安装路径是C:\Program Files\nodejs\，我这里选择在D:\Program Files\nodejs\目录下安装,点击Next
点击Next
点击Next
点击Install
安装完成点击Finish
安装完成后Node.js会自动将node配置到环境变量中，我们打开Windows的cmd窗口输入node -v，查看node版本
输入npm -v，看到npm版本
三、配置 在cmd窗口输入npm root -g，查看全局安装的模块所在目录
在安装的目录下新建两个文件夹node_cache和node_global
打开cmd命令窗口，配置全局安装的模块路径（注意"D:\Program Files\nodejs\node_global"是我电脑上的安装路径，你们以自己电脑实际安装路径进行替换）
npm config set prefix “D:\Program Files\nodejs\node_global”
配置缓存路径（注意路径）
npm config set cache “D:\Program Files\nodejs\node_cache”
在cmd窗口输入npm root -g，即可看见全局安装的模块路径已经切换成我们配置的路径了
为了之后使用npm下载东西时速度快一些，需要配置镜像站，这里选择淘宝镜像，打开cmd输入
npm config set registry=http://registry.npm.taobao.org 输入npm config get registry，输出http://registry.npm.taobao.org/即表示配置成功
现在配置一下Node.js的环境变量，设置环境变量的目的是在任何目录都可以执行node和vue命令。
windows10可以使用搜索功能搜索环境变量，点击编辑系统环境变量
点击环境变量
找到Path，点击编辑
点击新建，我电脑的node_global路径是"D:\Program Files\nodejs\node_global"，配置完成后点击确定，关闭环境变量配置的所有窗口
四、安装配置vue 输入npm info vue，查看是否能够获取vue信息，这里报下图的错误话需要使用windows PowerShell管理员模式
右键左下角的windows图标选择windows PowerShell（管理员），输入npm info vue即可
输入npm install vue -g 开始安装vue
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21a1e1998e95b21bef30b16bb58fc57f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/666b3b9fac3a1be6302c00f96034fe8c/" rel="bookmark">
			Eclipse与MySQL数据库的连接(已实操)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天介绍的是eclipse如何与MySQL相连，相信很多小伙伴和我一样，对路径啊，什么包放在那里啊很是头疼，今天一下午才弄好就赶来分享啦，超详细哦！ 以下为我个人通过总结大家的方法，自己操作以后分享给大家，如有问题，评论提问，大家商讨解决。
准备工作：下载MySQL和eclipse，这里就不讲了，注意的是你可能已经下载了MySQL，但是没有下载jdbc，它们的下载是分开的，首先确保你的电脑已经装了eclipse和MySQL，之后也许我会出安装教程（可私信）
1安装下载mysql的jar文件，并与mysql是同一版本很重要
打开MySQL的官网，点击图中标红方框中的内容即可，如不理解（可私信）
滑到最下面
选择connector/J(不要管workbench，这个是数据库的图形可视化页面) 这里注意一下：要选择与自己数据库版本相一致（eg：我的为8.0.29）
点击Archives可以选择相应的版本
根据自身习惯选择一个压缩包下载（个人选择ZIP）
如下图：看到红方框中的内容便是下载成功了 接下来，讲一讲eclipse中的操作
首先打开eclipse，创建一个新的Java project，然后右击，如图：
出现如下图所示证明已连接好： 最后，创建数据库来验证以下（该部分参考了菜鸟教程Java部分MySQL的讲解和代码）
（1）打开自己的MySQL
（2）在数据库中创建表
CREATE TABLE `websites` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` char(20) NOT NULL DEFAULT '' COMMENT '站点名称', `url` varchar(255) NOT NULL DEFAULT '', `alexa` int(11) NOT NULL DEFAULT '0' COMMENT 'Alexa 排名', `country` char(10) NOT NULL DEFAULT '' COMMENT '国家', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8; （3）向表中插入数据（忘记截图了）
INSERT INTO `websites` VALUES ('1', 'Google', 'https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/666b3b9fac3a1be6302c00f96034fe8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f761c0c8442ce78d8e448071c732c66e/" rel="bookmark">
			残差网络(Residual Network,ResNet)原理与结构概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		残差网络是为了解决模型层数增加时出现梯度消失或梯度爆炸的问题而出现的。传统的神经网络中，尤其是图像处理方面，往往使用非常多的卷积层、池化层等，每一层都是从前一层提取特征，所以随着层数增加一般会出现退化等问题。残差网络采取跳跃连接的方法避免了深层神经网络带来的一系列问题。
一：对模型原理与优点的理解 首先，我们把网络层看成是映射函数。(1)在传统的前馈网络中，网络中堆叠的层可以将输入x映射为F(x)，这一整体网络的输出为H(x)，F(x)=H(x)。但是对于恒等映射函数f(x)=x，即网络的输入与输出相等，直接让这样的层去拟合这样的恒等映射函数会很困难，不过f(x)=0还是比较容易训练拟合的。(2)所以我们可以让输出H(x)=F(x)+x，这样如果整体网络H(x)需要是恒等映射，只需要把堆叠层拟合成F(x)=0即可。
从另一角度考虑，在以往的网络中，都试图通过堆叠不同的层找到可将输入x映射为输出H(x)的函数，而残差网络的目的并不是学习x到H(x)的映射，而是x与H(x)的不同，这也正是“残差”一词名称由来。残差F(x)=H(x)-x，所以我们尝试学习F(x)+x，而不是像(1)直接学习H(x)。（这样解释或许有些牵强，但事实的确如此。）
当然，还有一种说法是拟合H(x)-x与（1）中那样直接拟合F(x)相比更简单，这和开始部分提到的恒等映射函数不好优化这种说法是一致的。
对于模型优点原理的各种解释并不是模型的重心，毕竟这些解释建立在实验事实之上，如果这样的模型并不理想，一切解释都是徒劳的，不过这些内容有助于我们对这一类网络的构想过程的理解。
二：模型结构 ResNet的种类是很多的，如ResNet-18，ResNet-34，ResNet-50，ResNet-101，ResNet152等。但是它们的基本结构都是相同的——由多层相同的ResNet block重复堆叠而成。ResNet block特点是由若干层网络（这里表示为Layers）组成，输出为网络的输出与输入的加和。
上图表示一个ResNet block，下图为重复的结构。
这里的加是两个张量相加。所以我们要保证x与layers后的输出形状相同，否则无法相加。这取决于Layers内部结构。在图像处理方面，常用的是采取卷积核为3，padding为1的两个卷积层处理，这样可以不改变张量形状。
当然，理论上ResNet block只要保证输出形状与输入形状相同即可。所以我们可以根据实际需要以及卷积层、池化层等输出输入维度计算公式来设计ResNet block。但是一般ResNet block内部不会有太多结构，毕竟一般都是用它来实现深层网络，使用时一般会使用几个或数十个这样的block。
三：ResNet block的其它结构 (二)中讲解的结构是最ResNet block中最基本的一种，即输入与输出直接相加。但实际的连接方式可以是多种多样的。在百度百科中介绍有以下六种，其中的a对应前面(二）。后面的五种虽然稍显复杂，但总体结构基本相同，最终也都是形状相同的张量相加。
三：关于跳跃连接(skip connection)，残差连接(residual connection)与捷径连接(shoutcut connection)的一些问题 这几个词在ResNet、Inception、DenseNet等文章中很常见。兔兔在前面只是说输入与输出相加，实际这个过程就是连接。有人说只要是模型内两个位置的连接即为跳跃连接，跳跃连接(skip connection)是很广泛的概念；残差连接(residual connection)是残差网络中的跳跃连接，也就是跳跃连接在残差网络中叫做残差连接(毕竟残差网络有一特点，所有的连接都是有规律的，是一块一块地连接)。而捷径连接(shortcut connection)可以理解为绕过中间的层去和后面输出连接，本质上体现的也是残差连接这个过程；也有人说捷径连接这个称呼可以理解为跳跃连接和残差连接最早定义，当时还是上个世纪，人工智能发展缓慢，人们使用这种连接主要用于全连接层网络；但是目前来看，这三种东西是用一个事物的不同称呼，只不过侧重点不同而已。
四：算法实现 如果直接使用ResNet模型，可以调用torchvision库。
from torchvision.models.resnet import resnet18 resnet18=resnet18() print(resnet18) 上述代码可以查看模型内部结构，并且该模型可以直接进行训练，或者作为其它网络的一部分。
下面兔兔以（二）为例，简要地实现该部分，代码如下。
from torch import nn from torch.nn import functional as F class ResNetBlock(nn.Module): def __init__(self): super(ResNetBlock, self).__init__() self.conv1=nn.Conv2d(kernel_size=3,in_channels=4,out_channels=3,padding=1) self.conv2=nn.Conv2d(kernel_size=4,in_channels=3,out_channels=3,padding=1) self.bn1=nn.BatchNorm2d(4) self.bn2=nn.BatchNorm2d(3) def forward(self,input): x0=input x=F.relu(self.bn1(self.conv1(x0))) x=self.bn2(self.conv2(x)) x=x+x0 return x0 class ResNet(nn.Module): def __init__(self,n_blocks): super(ResNet, self).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f761c0c8442ce78d8e448071c732c66e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d3e69af161f5f148a976362388fd0c1/" rel="bookmark">
			C&#43;&#43;知识总结（内附超详细知识框架图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++知识总结 由于在学习C++的同时博主也在学习Linux系统编程、Linux网络编程以及数据库，所以从开始学习C++到现在结束已经有一年多时间了。
C++是博主学习的第一个面向对象的语言，在学习过程中也是逐渐体会到了面向对象编程的种种好处，但C++相比C语言来说其语法会更加复杂，特别是继承和多态的语法(ಥ _ ಥ)，以及C++11中新增的很多特性，让C++的语法变得更加复杂。
下面博主将各大模块的思维导图罗列出来了，并在每张思维导图下面放上了博主的相关博客，对某一知识点有疑问的博友可以跳转阅读对应的博客。
其实本来是罗列在一张思维导图上的，但由于C++知识体系过于庞大，导致思维导图太大无法插入到博客当中，于是博主就将这些模块重新拆分为多个思维导图了¯\_(ツ)_/¯ 一、C++基础 下面是博主的相关博客：
C++入门基础：https://blog.csdn.net/chenlong_cxy/article/details/116990901 二、类和对象 下面是博主的相关博客：
C++类和对象（一）：https://blog.csdn.net/chenlong_cxy/article/details/117194830C++类和对象（二）：https://blog.csdn.net/chenlong_cxy/article/details/117307465C++类和对象（三）：https://blog.csdn.net/chenlong_cxy/article/details/117530132 三、C/C++内存管理 下面是博主的相关博客：
C/C++内存管理：https://blog.csdn.net/chenlong_cxy/article/details/117622502 四、模板 下面是博主的相关博客：
C++模板初阶：https://blog.csdn.net/chenlong_cxy/article/details/117629686C++模板进阶：https://blog.csdn.net/chenlong_cxy/article/details/120284967 五、C++的IO流 下面是博主的相关博客：
C++的IO流：https://blog.csdn.net/chenlong_cxy/article/details/120338757 六、继承 下面是博主的相关博客：
C++继承：https://blog.csdn.net/chenlong_cxy/article/details/120444215 七、多态 下面是博主的相关博客：
C++多态：https://blog.csdn.net/chenlong_cxy/article/details/120796570 八、C++11 下面是博主的相关博客：
C++11入门基础：https://blog.csdn.net/chenlong_cxy/article/details/126690586C++11右值引用和移动语义：https://blog.csdn.net/chenlong_cxy/article/details/126747523C++11类的新功能：https://blog.csdn.net/chenlong_cxy/article/details/126780535C++11可变参数模板：https://blog.csdn.net/chenlong_cxy/article/details/126807356C++11lambda表达式：https://blog.csdn.net/chenlong_cxy/article/details/126857091C++11包装器：https://blog.csdn.net/chenlong_cxy/article/details/126916023C++11线程库：https://blog.csdn.net/chenlong_cxy/article/details/126976346 九、异常 下面是博主的相关博客：
C++异常：https://blog.csdn.net/chenlong_cxy/article/details/127028110 十、智能指针 下面是博主的相关博客：
C++智能指针：https://blog.csdn.net/chenlong_cxy/article/details/127100528 十一、特殊类设计 下面是博主的相关博客：
特殊类设计：https://blog.csdn.net/chenlong_cxy/article/details/126603597 十二、C++的类型转换 下面是博主的相关博客：
C++的类型转换：https://blog.csdn.net/chenlong_cxy/article/details/127144522 十三、STL 下面是博主的相关博客：
STL —— string的介绍及使用：https://blog.csdn.net/chenlong_cxy/article/details/117885098STL —— string的模拟实现：https://blog.csdn.net/chenlong_cxy/article/details/118932318STL —— vector的介绍及使用：https://blog.csdn.net/chenlong_cxy/article/details/119212349STL —— vector的模拟实现：https://blog.csdn.net/chenlong_cxy/article/details/119254954STL —— list的介绍及使用：https://blog.csdn.net/chenlong_cxy/article/details/119455963STL —— list的模拟实现：https://blog.csdn.net/chenlong_cxy/article/details/119541500STL —— stack和queue的介绍及使用：https://blog.csdn.net/chenlong_cxy/article/details/120077784STL —— stack和queue的模拟实现：https://blog.csdn.net/chenlong_cxy/article/details/120216105STL —— priority_queue的使用及模拟实现：https://blog.csdn.net/chenlong_cxy/article/details/120267391STL —— map/set和multimap/multiset的介绍及使用：https://blog.csdn.net/chenlong_cxy/article/details/121544974STL —— map和set的模拟实现：https://blog.csdn.net/chenlong_cxy/article/details/121763649STL —— unordered_map和unordered_set的介绍及使用：https://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d3e69af161f5f148a976362388fd0c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a73f99f3f7ed3a768042d65bb06e62db/" rel="bookmark">
			【工具使用】Keil5软件使用-进阶调试篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 本文面向已经懂得软件基本操作的职业老手，如果是未使用过该软件的小鲜肉，请移步基础篇。这里以STM32芯片为例对工具进行讲解，其他品牌的芯片在调试方面上可能存在差异。
二、软件说明 Keil提供了包括C编译器、宏汇编、链接器、库管理和一个功能强大的仿真调试器等在内的完整开发方案，通过一个集成开发环境（μVision）将这些部分组合在一起。
目前软件对中文的支持不友好，不建议安装网上的一些汉化包之类的。另外建立的工程文件路径也尽量不要存在中文，否则可能会出现一些异常。
演示版本：5.24a
三、软件使用 3.1 基本调试操作 首先点击"Debug-&gt;Start/Stop Debug Session"或下图2位置，进入调试。
如果前面工程配置里选择了复位调试，则进入调试后，会停在main函数头部
复位（Reset）：对程序进行复位操作，根据烧录器不同的复位方式配置会触发不同的复位类型。
全速运行（Run）：使当前程序开始正常全速运行，直到程序遇到断点时停止。
停止运行（Stop）：当程序全速运行时，点击此按键可停止程序运行，停的是当前点击时的程序运行位置。
单步调试（Step）：根据当前调试的窗口的语言，执行单条语句。如果遇到函数，则会进入函数内部。如果是在反汇编窗口中，则只执行一条汇编指令。
单步跳过调试（Step Over）：如果是在C语言窗口中，则是按单条语句执行，与单步调试不同的是，遇到函数不会进入函数内部，而是直接全速运行函数，并跳到下一条语句。
单步返回调试（Step Out）：如果是在C语言窗口中，则是直接全速运行当前函数后面所有内容，直到函数返回上一级。
插入/移除断点：如果当前光标所在行未有断点，则插入断点（前提是当前行可以插入，如果无法插入会显示一个感叹号），在有断点的情况下则是移除断点。插入断点后，当前行前面会有个红圆表示断点位置。也可以通过直接点击红圆位置进行插入/移除断点的操作。另一种断点方式，是通过指令来控制，当然也可以使用Keil提供的界面化操作，设置某个变量读或写时触发断点。不过目前貌似有部分芯片不支持这种操作。注：断点最多只能打7个。
使能/禁止断点：开启或禁止当前光标所在行的断点。禁止后红圆变成白圆。
禁止所有断点：禁止当前所有的断点。
删除所有断点：删除所有断点。
3.1 调试窗口 变量查看窗口——Watch1，Watch2 通过"View-&gt;Watch Windows-&gt;Watch1、Watch2"可以选择打开Watch窗口，也可以在工具栏这里打开。再点击一次则可以关闭。
通过选中一个变量，右键添加入对应的Watch窗口，可以追踪查看当前变量的变化状态。注意，只有全局变量可以全程监视，临时变量只有在进入当前函数中才可监视到其数据，用static关键词修饰的变量无法监视。
如果当前变量没有实时更新，则需要点击"View-&gt;Periodic Window Update"将其勾选上。
在"Watch"窗口中，可以查看当前变量名称、值、数据类型，如果当前变量类型为结构体，则可以以对应的结构形式进行展开查看。
内存查看窗口——Memory 通过"View-&gt;Memory Windows-&gt;Memory1/2/3/4"打开Memory窗口，也可以通过工具栏
这个图标打开。打开的状态下再按一次则可关闭。
在Memory窗口中输入想要查看内存的起始地址，另外右上角的锁可以把当前界面锁定下来。
另外如果查看的是Ram的地址，那其中的数据也可以直接通过此窗口进行修改。
系统视窗——System Viewer Windows（这个根据不同芯片会有不同的展示） 可以在"Peripherals"选项栏中选择"System Viewer"系统视窗中对应的外设，选择"Core Peripherals"则是内核调试窗口。另外系统视窗也可以通过工具栏中这个位置可以打开。
这个窗口用于查看当前单片机外设及内核寄存器的值，在调试外设底层时经常会使用到。
在这个窗口中可以直接修改外设寄存器的值，当然部分只读寄存器是无法修改的，有些则是需要在特定条件下才可以设置生效，具体就得看对应的芯片手册里寄存器的说明了。
调度关系窗口——Call Stack Window 可以在"View-&gt;Call Stack Window"打开此窗口，也可以在工具栏这个位置打开 。
这个窗口用于查看当前程序调度关系，当出现有进入硬件错误异常调试时可以快速定位到是哪里触发的异常。这个窗口是的调度关系是从当前程序堆栈里获取的数据并将其图形化，所以如果当前堆栈数据被破坏，则此窗口也将无法查看调度关系。
该窗口里显示的调度关系是从下至上调用的，最上面的表示当前程序所处的函数。展开对应的函数，可以查看各层调用函数跳转之前保存的一些临时变量等信息。
寄存器窗口——Register Window 该窗口可在"View-&gt;Registers Window"处打开，也可以在工具栏这个位置打开。
这个窗口用于查看当前内核的相关寄存器，如汇编里常说的15个通用寄存器。当然调试中比较常用的是其中的SP、LR、PC三个寄存器。SP为当前栈的地址位置，PC为当前程序地址，LR为函数跳转前的地址，即当前函数返回的地址。
另外"Banked"中的MSP为当前程序系统主栈，PSP则为操作系统的任务栈，这两者的区别是，如果使用了操作系统，则当前任务中的所有调度关系使用的是任务栈，而类似中断这种内核的操作使用的是主栈；如果未使用操作系统，则只会使用主栈，不会使用任务栈。
通过"Internal"可以查看当前是处在中断还是任务中，Mode为"Thread"表示是在线程/任务中，或者是函数中（非中断），为"Handle"表示是在中断中；Privilege为"Privelege"表示当前处于特权模式。Stack为"PSP"表示当前使用的是任务栈，为"MSP"则表示使用的是主栈。
反汇编调试窗口——Disassembly Window 该窗口在"View-&gt;Disassembly Window"中可以打开，也可以在工具栏中这个位置打开。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a73f99f3f7ed3a768042d65bb06e62db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/059435a78e83392dc8c85799f1328b0b/" rel="bookmark">
			单链表的创建，插入，删除以及查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章依据学校的实验作业完成
目录
前言
一、链表是什么？
1.概念
2.链表的分类
二、单链表的创建，插入，删除以及查找
1.单链表的存储结构
2.单链表的创建
3.单链表的插入
4.单链表的删除
5.单链表的查找
6.主函数
7.完整代码
8.编译结果
三、总结
前言 链表是一种物理存储单元上非连续、非顺序的存储结构，由一系列结点组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。
一、链表是什么？ 1.概念 链表是一种物理存储结构上非连续存储结构，数据元素的逻辑顺序是通过链表中的引用链接次序实现的。
逻辑上连续是我们想象的连续，并不是真正的连续。
2.链表的分类 单向双向，带头结点不带头结点，循环非循环，组合起来共有8种
二、单链表的创建，插入，删除以及查找 1.单链表的存储结构 typedef int ElemType;	//便于后期的修改 //定义结点类型 typedef struct Node { ElemType data; //单链表中的数据域 struct Node *next; //单链表的指针域 }Node,*LinkedList; 2.单链表的创建 //单链表的建立（头插法） LinkedList ListCreatH() { Node *L; L = (Node *)malloc(sizeof(Node)); //申请头结点空间 L-&gt;next = NULL; //初始化一个空链表 int i=0; ElemType x; //x为链表数据域中的数据 while(i&lt;10) { Node *p; p = (Node *)malloc(sizeof(Node)); //申请新的结点 scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/059435a78e83392dc8c85799f1328b0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58dc874efd60b91e2db63a5e04ed1f86/" rel="bookmark">
			ERROR 1698 (28000): Access denied for user ‘root‘@‘localhost‘解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 ERROR 1698 (28000): Access denied for user 'root'@'localhost'解决方法1、问题描述2、问题原理3、解决方法3.1 其它用户登录MySQL3.2 查看user表3.3 修改root密码格式3.4 增加root密码3.5 退出登录3.6 重启mysql服务3.7 root登录 ERROR 1698 (28000): Access denied for user ‘root’@'localhost’解决方法 1、问题描述 在使用如下指令进入mysql shell界面时：
mysql -u root -p 报错：ERROR 1698 (28000): Access denied for user 'root'@'localhost'
参考博客：出现ERROR 1698 (28000): Access denied for user ‘root‘@‘localhost‘ 的解决方法
2、问题原理 一般出现这种情况多数是安装新版本mysql，root密码是随机的，也不是空密码，所以要通过查看随机密码进入，再进行修改原来的密码。
3、解决方法 3.1 其它用户登录MySQL 既然我们无法通过root用户进入MySQL，那我们就只能通过其他用户登录MySQL。
在我们下载安装MySQL的过程中，系统会自动给我们创建一个用户，我们借助如下指令便可以查看该用户信息：
sudo cat /etc/mysql/debian.cnf 然后使用该用户名和密码进入MySQL：
mysql -u debian-sys-maint -p # 用户：debian-sys-maint # 密码：7F6TVXxve2hh4EHI 3.2 查看user表 在mysql中输入指令，结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58dc874efd60b91e2db63a5e04ed1f86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24f5d5630c13c177579b97ac62bbdbb8/" rel="bookmark">
			视频实时行为检测——基于yolov5&#43;deepsort&#43;slowfast算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、核心功能设计二、核心实现步骤1.yolov5实现目标检测2.deepsort实现目标跟踪3.slowfast动作识别 三、核心代码解析1.参数2.主函数3.将结果保存成视频 总结 前言 前段时间打算做一个目标行为检测的项目，翻阅了大量资料，也借鉴了不少项目，于是打算通过yolov5实现目标检测，deepsort实现目标跟踪以及slowfast实现动作识别，最终实现端到端的目标行为检测模型。
一、核心功能设计 总的来说，我们需要能够实现实时检测视频中的人物，并且能够识别目标的动作，所以我们拆解需求后，整理核心功能如下所示：
yolov5实现目标检测，确定目标坐标deepsort实现目标跟踪，持续标注目标坐标slowfast实现动作识别，并给出置信率用框持续框住目标，并将动作类别以及置信度显示在框上 最终效果如下所示：
视频AI行为检测
二、核心实现步骤 1.yolov5实现目标检测 “YOLO”是一种运行速度很快的目标检测AI模型，YOLO将对象检测重新定义为一个回归问题。它将单个卷积神经网络(CNN)应用于整个图像，将图像分成网格，并预测每个网格的类概率和边界框。YOLO非常快，它比“R-CNN”快1000倍，比“Fast R-CNN”快100倍。YOLOv5是YOLO比较新的一个版本。
所以我们把视频分解成多幅图像，并利用yolov5算法进行目标检测并逐帧执行时，可以看到目标跟踪框随目标移动。
效果如下所示：
2.deepsort实现目标跟踪 但是，如果视频帧中有多个目标，如何知道一帧中的目标和上一帧是同一个对象？这就是目标跟踪的工作，应用多个检测来识别特定目标随时间的变化，实现目标跟踪。
Deepsort是实现目标跟踪的算法，从sort（simple online and realtime tracking）演变而来，其使用卡尔曼滤波器预测所检测对象的运动轨迹，匈牙利算法将它们与新的检测目标相匹配。Deepsort易于使用且运行速度快，成为AI目标检测跟踪之热门算法。
首先来看一下DeepSORT的核心流程：
预测(track)——&gt;观测（detection+数据关联）——&gt;更新
预测：预测下一帧的目标的bbox，即后文中的tracks观测：对当前帧进行目标检测，仅仅检测出目标并不能与上一帧的目标对应起来，所以还要进行数据关联更新：预测Bbox和检测Bbox都会有误差，所以进行更新，更新后的跟踪结果通常比单纯预测或者单纯检测的误差小很多。
3.slowfast动作识别 我们将视频序列和检测框信息输入行为分类模型，输出每个检测框的行为类别，达到行为检测的目的。
而行为分类模型我们采用的是slowfast算法，其包括一个Slow路径，以低帧速率操作，以捕捉空间语义，以及一个Fast路径，以高帧速率操作，以精细的时间分辨率捕捉运动。快速路径可以通过减少信道容量而变得非常轻量级，同时还可以学习有用的时间信息用于视频识别。
三、核心代码解析 1.参数 if __name__=="__main__": parser = argparse.ArgumentParser() parser.add_argument('--input', type=str, default="test/test1.mp4", help='test imgs folder or video or camera') parser.add_argument('--output', type=str, default="output/out1.mp4", help='folder to save result imgs, can not use input folder') # object detect config parser.add_argument('--imsize', type=int, default=640, help='inference size (pixels)') parser.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24f5d5630c13c177579b97ac62bbdbb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5ae6638206bca484450d4af25b63ab6/" rel="bookmark">
			Java入门级基础教学（史上最详细的整合）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一：基础语法
1.“Hello word”
2.Java的运行机制
3. Java基本语法
1.注释、标识符、关键字
2.数据类型（四类八种）
4.类型转换
1.自动转换
2.强制转换
5.常量和变量
1.常量
2.变量
3.变量的作用域
6.运算符
1.算数运算符
2.赋值运算符
3.关系运算符
4.逻辑运算符
5.自增、自减运算符
二：Scanner与流程控制：
1.Scanner用法
2.流程控制
1.顺序结构
3.if选择结构
1.单if语句
2.标准语句
3.扩展语句
4.switch选择结构
1.break关键字
2.default关键字
3.continue关键字
5.循环结构
1.while循环
2.do while循环
3.for循环（重点）
4. 增强for
三：方法的定义和调用
四：数组
1.维数组
1.数组的定义
2.动态和静态数组
3.数组的打印输出
4. Java内存
4.数组的使用
2.二维数组
3.冒泡排序法（江湖中人尽皆知）
五：什么是面向对象
六：类与对象的关系
1.什么是类
2.什么是对象
3.创建与初始化对象
1.什么是类
2.什么是构造器
3.创建对象内存分析
七：封装、继承、多态
1.封装
2.继承
3.this和super关键字
4.方法重写
静态方法：
非静态方法：
5.多态
6.instanceof关键字
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5ae6638206bca484450d4af25b63ab6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eab6f93df8e1025d7cde0504fe28fe49/" rel="bookmark">
			GWO灰狼优化算法综述（Grey Wolf Optimization）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GWO通过模拟灰狼群体捕食行为，基于狼群群体协作的机制来达到优化的目的。
GWO算法具有结构简单、需要调节的参数少、容易实现等特点，其中存在能够自适应调整的收敛因子以及信息反馈机制，能够在局部寻优与全局搜索之间实现平衡，因此在对问题的求解精度和收敛速度方面都有良好的性能。
1. 灰狼优化算法原理 第一层：层狼群。种群中的领导者，负责带领整个狼群狩猎猎物，即优化算法中的最优解。 第二层：层狼群。负责协助 层狼群，即优化算法中的次优解。
第三层：层狼群。听从和的命令和决策，负责侦查、放哨等。适应度差的 和 会降为。
第四层：层狼群。它们环绕、或进行位置更新。
灰狼的狩猎过程包含如下：①包围、跟踪猎物②追捕、骚扰猎物③攻击猎物。
2. 数学模型建立 为了对 GWO中灰狼的社会等级进行数学建模，将前3匹最好的狼（最优解）分别定义为α，β和δ，它们指导其他狼向着目标搜索。其余的狼 （候选解）被定义为 ω，它们围绕α，β或δ来更新位置。
2.1 包围猎物 在 GWO 中，灰狼在狩猎过程中利用以下位置更新公式实现对猎物的包围 ：
式（1）为灰狼和猎物之间的距离，式（２）是灰狼的位置更新公式，和分别是猎物的位置向量和灰狼的位置向量，t为当前迭代次数。和为确定的系数，其计算公式分别为：
其中，，是两个一维分量取值在[0,1]内的随机数向量，用于模拟灰狼对猎物的攻击行为，它的取值受到的影响。收敛因子 是一个平衡GWO 勘探与开发能力的关键参数。的取值随着迭代次数的增大从 2 到 0 线性递减。
2.2 追捕猎物 在自然界中，虽然狩猎过程通常由头狼 α 狼引导，其它等级的狼配合对猎物进行包围、追捕和攻击，但在演化计算过程中，猎物（最优解）位置是未知的，因此在 GWO 中我们认为最优的灰狼为α ，次优的灰狼为 β ，第三优的灰狼为 δ ，其余的灰狼是 ω，根据 α （潜在最优解）、β 和 δ 对猎物的位置有更多知识的这一特性建立模型，迭代过程中采用 α 、β 和 δ 来指导 ω 的移动，从而实现全局优化。利用α 、β 和 δ 的位置、、，使用下述方程更新所有灰狼的位置：
分别表示灰狼个体距离 层狼群、 层狼群、层狼群的距离。
X1、X2、X3分别表示受 层狼群、 层狼群、层狼群影响， 灰狼个体需要调整的位置。
这里取平均值，即
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eab6f93df8e1025d7cde0504fe28fe49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e06a331ea00f9b816575995dc96403e4/" rel="bookmark">
			（一）基于知识图谱的医疗问答系统(实例&#43;代码理解)保姆级教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章内容来源于刘焕勇老师在Github上的开源项目。https://github.com/liuhuanyong/QASystemOnMedicalKG
如果打不开或者是想要数据集、源码等文件，或者是帮忙调试程序请评论留言~
项目介绍详细方案，架构等问题不再赘诉，相关链接里已经介绍很详细。这里主要着重于运行程序和代码理解（因为代码很详细，包括运行过程、结果，整篇文章可能较长）。
我用的软件相关版本：
pycharm 2021.3
neo4j 4.2.19 (community)
python 3.7
py2neo 2021.2.3
先放部分效果图：左边是图谱的一部分，右边是实体的一些属性，包括疾病原因、科室、治疗时间、治疗药物等。
首先创建一个 MedicalGraph 类，定义一个连接数据库的方法。这里需要注意的是连接 Graph 语法的问题，旧版本是需要 username="xxx", password="xxx"。
def __init__(self): cur_dir = '/'.join(os.path.abspath(__file__).split('/')[:-1]) self.data_path = os.path.join(cur_dir, 'data/medical2.json') self.g = Graph("http://localhost:7474", auth=("neo4j", "***")) self.g.delete_all() 数据集的话是之前刘老师已经在网上爬虫好的json文件，长这个样子。
为了看官们舒适体验感和有助于下面代码理解，我还是把实体类型拿过来贴一下，单纯看json文件有些乱。。
实体关系类型：
知识图谱属性类型：
好了，我们回到代码，这里有一个主程序，将MedicalGraph()类实例化，然后创建结点和关系，我们点进去看看程序的执行过程。
首先，创建知识图谱实体结点类型，这里定义了如下结点和关系，对应之前的表格很好理解。
Drugs, Foods, Checks, Departments, Producers, Symptoms, Diseases, disease_infos,rels_check, rels_recommandeat, rels_noteat, rels_doeat, rels_department, rels_commonddrug, rels_drug_producer, rels_recommanddrug,rels_symptom, rels_acompany, rels_category
然后我们进去create_diseases_nodes创建一些疾病的信息。
def create_graphnodes(self): Drugs, Foods, Checks, Departments, Producers, Symptoms, Diseases, disease_infos,rels_check, rels_recommandeat, rels_noteat, rels_doeat, rels_department, rels_commonddrug, rels_drug_producer, rels_recommanddrug,rels_symptom, rels_acompany, rels_category = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e06a331ea00f9b816575995dc96403e4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/619/">«</a>
	<span class="pagination__item pagination__item--current">620/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/621/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>