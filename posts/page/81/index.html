<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ee6a0501284330a776469c9e9cf45b9/" rel="bookmark">
			Idea运行报错Error running Application Command line is too long的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新项目Idea里面启动的时候，有的时候报错Error running ‘Application’: Command line is too long. Shorten command line for Application or aalso for Spring Boot default configuration
首先找到项目里面的idea/workspace.xml文件，然后再找到&lt;component name="PropertiesComponent"&gt;&lt;/component &gt;标签
然后再在component 标签里加一行 &lt;property name="dynamic.classpath" value="true" /&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baa1b77a1b34c02ba95cf7d366459dfd/" rel="bookmark">
			【MySQL进阶】MySQL主从复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
MySQL主从复制
概念
主从形式
一主多从
多主一从
双主复制
主从级联复制
主从复制原理
三个线程
两个日志文件
主从复制的主要工作模式
异步复制
半同步复制
全同步复制
MySQL主从复制 概念 MySQL主从复制是一种数据分布机制，允许从一个数据库服务器（主服务器）复制数据到一个或多个数据库服务器（从服务器）。
解决问题（目的）
读写分离数据备份高可用 主从形式 一主多从 实现了：
读写分离
高可用
多主一从 用于多个节点写，一个节点负责查，报表系统
双主复制 实现了：
读写负载均衡
互相备份
主从级联复制 实现了：
缓解主节点io压力
主从复制原理 三个线程 实际上主从同步的原理就是基于 binlog 进行数据同步的。在主从复制过程中，会基于3 个线程来操作，一个主库线程，两个从库线程。
二进制日志转储线程（Binlog dump thread）是一个主库线程。当从库线程连接的时候， 主库可以将二进制日志发送给从库，当主库读取事件（Event）的时候，会在 Binlog 上加锁，读取完成之后，再将锁释放掉。
从库 I/O 线程会连接到主库，接收主库发送请求更新 Binlog。这时从库的 I/O 线程就可以读取到主库的二进制日志转储线程发送的 Binlog 更新部分，并且拷贝到本地的中继日志 （Relay log）。
从库 SQL 线程会读取从库中的中继日志，并且执行日志中的事件，将从库中的数据与主库保持同步。
两个日志文件 Binary Log
二进制日志（binary log） 以事件形式记录了对MySQL数据库执行更改的所有操作
Relay Log
用来保存从节点I/O线程接收的bin log日志，作为中继日志存在。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/baa1b77a1b34c02ba95cf7d366459dfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b436c7f76e9f1f0527ef8d7ec614723a/" rel="bookmark">
			【QT】Qt 网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt 网络 Qt 网络1. UDP Socket（1）核心 API 概览（2）回显服务器（3）回显客户端 2. TCP Socket（1）核心 API 概览（2）回显服务器（3）回显客户端 Qt 网络 和多线程类似，Qt 为了⽀持跨平台，对网络编程的 API 也进行了重新封装。
在进行网络编程之前，需要在项目中的 .pro 文件中添加 network 模块。添加之后要手动编译⼀下项目，使 Qt Creator 能够加载对应模块的头文件。
1. UDP Socket （1）核心 API 概览 主要的类有两个：QUdpSocket 和 QNetworkDatagram
QUdpSocket 表示⼀个 UDP 的 socket 文件。
QNetworkDatagram 表示⼀个 UDP 数据报
（2）回显服务器 1、创建界面，包含⼀个 QListWidget 用来显示信息
2、 创建 QUdpSocket 成员，修改 widget.h：
class Widget : public QWidget { Q_OBJECT public: Widget(QWidget *parent = nullptr); ~Widget(); private: Ui::Widget *ui; QUdpSocket *socket; }; 修改 widget.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b436c7f76e9f1f0527ef8d7ec614723a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47e1e0b0d380105cad2643a2ee5607be/" rel="bookmark">
			大数据-65 Kafka 高级特性 分区 Broker自动再平衡 ISR 副本 宕机恢复再重平衡 实测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点一下关注吧！！！非常感谢！！持续更新！！！ 目前已经更新到了： Hadoop（已更完）HDFS（已更完）MapReduce（已更完）Hive（已更完）Flume（已更完）Sqoop（已更完）Zookeeper（已更完）HBase（已更完）Redis （已更完）Kafka（正在更新…） 章节内容 上节我们完成了如下的内容：
我们模拟了让分区重新分配的过程，在业务上实际发生的情况。比如：当几台Kafka节点不够用后，我们将对Kafka进行扩容，但是此时遇到的问题是，之前的分区不会分配到新的Kafka节点上，那此时我们需要借助Kafka提供的脚本来实现这一过程：
Kafka分区重分配包含启动服务、创建主题、新增服务等操作查看集群、生成JSON、执行计划最终确认完成了新加Kafka节点后，分区进行了重分配。 Kafka启动再平衡 我们可以在新建主题的时候，手动指定主题各个Leader分区以及Follower分区的分配情况，即什么分区副本在哪个Broker节点上
随着系统的运行，Broker的宕机重启，会引发Leader分区和Follower分区的角色转换，最后可能Leader大部分都集中在少数几台Broker上，由于Leader负责客户端的读写操作，此时集中Leader分区的少数几台服务器的网络IO和CPU都会很紧张。
Leader和Follower的角色转换会引起Leader副本在集群中分布的不均衡，此时我们需要一种手段，让Leader的分布重新恢复到一个均衡的状态。
启动服务 目前我们需要启动两台Kafka进行测试：
分别在h121 和 h122节点上启动服务
kafka-server-start.sh /opt/servers/kafka_2.12-2.7.2/config/server.properties h121 h122 新建主题 kafka-topics.sh --zookeeper h121.wzk.icu:2181 --create --topic topic_test_01 --replica-assignment "0:1,1:0,0:1" 该命令的解释：
创建了主题 topic_test_01有三个分区，每个分区两个副本 创建的结果如下图：
查看主题 我们可以通过如下的命令进行查看：
kafka-topics.sh --zookeeper h121.wzk.icu:2181 --describe --topic topic_test_01 执行结果如下图：
主题信息 主题名称 topic_test_01分区数 3复制因子 2 分区详情 分区0：
Leader 0副本 0,1ISR(同步副本集合）0,1 分区1：
Leader 1副本：1,0ISR（同步副本集合）1,0 分区2：
Leader 0副本 0,1ISR（同步副本集合）0,1 模拟宕机 停止节点 我们结束掉 h122 的机器的Kafka
此时查看我们的主题信息：
kafka-topics.sh --zookeeper h121.wzk.icu:2181 --describe --topic topic_test_01 运行结果如下图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47e1e0b0d380105cad2643a2ee5607be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f53db0947906351b4b50b832fd0fee5/" rel="bookmark">
			Spring File Storage（文件的对象存储）框架基本使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 本文仅作为快速入门，深入学习及使用详见官网
云存储
在开发过程当中，会使用到存文档、图片、视频、音频等等，这些都会涉及存储的问题，文件可以直接存服务器，但需要考虑带宽和存储空间，另外一种方式就是使用云存储。目前主流的云存储有阿里云OSS、华为云OBS、七牛云Kodo、腾讯云COS、百度云 BOS、又拍云USS、MinIO 等。
X Spring File Storage 介绍
在 SpringBoot 中通过简单的方式将文件存储到 本地、FTP、SFTP、WebDAV、谷歌云存储、阿里云OSS、华为云OBS、七牛云Kodo、腾讯云COS、百度云 BOS、又拍云USS、MinIO、 AWS S3、金山云 KS3、美团云 MSS、京东云 OSS、天翼云 OOS、移动云 EOS、沃云 OSS、 网易数帆 NOS、Ucloud US3、青云 QingStor、平安云 OBS、首云 OSS、IBM COS、其它兼容 S3 协议的平台。
支持的平台如下图:
快速入门 添加依赖 &lt;dependencies&gt; &lt;!-- spring-file-storage 必须要引入 --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.xuyanwu&lt;/groupId&gt; &lt;artifactId&gt;spring-file-storage&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 华为云OBS 不使用的情况下可以不引入 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.huaweicloud&lt;/groupId&gt; &lt;artifactId&gt;esdk-obs-java&lt;/artifactId&gt; &lt;version&gt;3.22.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 阿里云OSS 不使用的情况下可以不引入 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt; &lt;version&gt;3.16.1&lt;/version&gt; &lt;/dependency&gt; 添加配置文件 注：以下配置是 2.1.0 版本的配置
dromara: x-file-storage: #文件存储配置 default-platform: huawei-obs-1 #默认使用的存储平台 thumbnail-suffix: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f53db0947906351b4b50b832fd0fee5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc238cd8826809489ee54732e496bc4f/" rel="bookmark">
			IDEA如何去掉编辑框右侧的竖线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 打开 IntelliJ Idea 软件 依次找到 File—&gt;Settings—&gt;Editor—&gt;General—&gt;Appearance 去掉勾选 Show hard wrap and visual guides (configured in Code Style options) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4837085c193b3623b14ba09473fc7be/" rel="bookmark">
			数据科学、数据分析、人工智能必备知识汇总-----Python爬虫-----持续更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据科学、数据分析、人工智能必备知识汇总-----主目录-----持续更新(进不去说明我没写完)：https://blog.csdn.net/grd_java/article/details/140174015 文章目录 一、基本配置和基础知识二、Urllib库三、解析库四、Selenium五、request 一、基本配置和基础知识 初期准备 安装ipython：进入python安装目录，进入Scripts文件夹，在这个文件夹进入cmd，执行pip install ipython命令即可安装
如果出现如下提示，就进入python安装目录，打开cmd执行它所提示的命令
为了保险起见，可以重新按照上面的步骤安装ipython，安装成功后，scripts文件夹会多出我们安装的脚本
如果安装的包太多，也可以选择执行pip list命令查看安装的包
2. 修改pip下载源 直接使用pip install命令会从默认的https://files.pythonnhosted.org/网站进行下载，这个是国外的网站，会比较慢我们只需要在命令后面加上 -i 国内源地址即可 pip install 包名 -i 国内源地址 #例如 pip install ipython -i https://pypi.mirrors.ustc.edu.cn/simple/ # 其中，常用国内源地址有 阿里云 http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣(douban) http://pypi.douban.com/simple/ 清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/ 中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/ 设置模版 打开Pycharm软件，在设置中的Editor中的File and Code Templates选择.py文件，为其设置模版
每次我们创建.py文件时，会自动将其添加 # _*_ coding : utf-8 _*_ # @Time : ${DATE} ${TIME} # @Author : Taylor Sinclair（殷志鹏） # @File : ${NAME} # @Project : ${PROJECT_NAME} # @Description : 在这里书写本文件的作用 什么是爬虫 如果我们把互联网比作一张大的蜘蛛网，那一台计算机上的数据便是蜘蛛网上的一个猎物，而爬虫程序就是一只小蜘蛛，沿着蜘蛛网抓取自己想要的数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4837085c193b3623b14ba09473fc7be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e6c41855e00bbf8789b44a6c23b8f54/" rel="bookmark">
			JAVA中实现线程安全的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JAVA中实现线程安全的三种方式 1. 同步代码块2. 同步方法3. ReentrantLock4. 总结 💖The Begin💖点点关注，收藏不迷路💖 1. 同步代码块 使用synchronized关键字加在需要同步的代码块上，并指定一个锁对象。这种方式可以精确控制同步的范围，减少不必要的同步开销。
public class Counter { private int count = 0; private final Object lock = new Object(); public void add(int value) { synchronized (lock) { count += value; } } } 2. 同步方法 将synchronized关键字放在方法声明上，这样整个方法体就会被同步。这种方式简单直观，但可能会降低并发性能。
public class Counter { private int count = 0; public synchronized void add(int value) { count += value; } } 3. ReentrantLock ReentrantLock是一个显式锁，提供了比synchronized更高的灵活性和功能。需要显式地调用lock()和unlock()方法来加锁和释放锁。
import java.util.concurrent.locks.Lock; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e6c41855e00bbf8789b44a6c23b8f54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceab5d65ab1b0a84f14ab4e26eb9e9db/" rel="bookmark">
			理解 Objective-C 中 &#43;load 方法的执行顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Objective-C 中，+load 方法是在类或分类（category）被加载到内存时调用的。它的执行顺序非常严格，并且在应用启动过程中可能会导致一些令人困惑的行为。理解 +load 方法的执行顺序对调试和控制应用的初始化过程非常重要。
+load 方法的执行顺序 类的 +load 方法：首先，所有类的 +load 方法会按照以下顺序执行：
按照类的编译顺序执行。主类的 +load 方法先于它的任何子类的 +load 方法执行。 分类的 +load 方法：其次，所有分类的 +load 方法会按照以下顺序执行：
在定义该分类的类的 +load 方法之后执行。多个分类的 +load 方法的执行顺序不确定（即，编译器可能会以任何顺序执行这些分类的 +load 方法）。 +load 方法的具体执行顺序示例 假设有如下的类和分类：
// SuperClass.h @interface SuperClass : NSObject @end // SuperClass.m @implementation SuperClass + (void)load { NSLog(@"SuperClass +load"); } @end // SubClass.h @interface SubClass : SuperClass @end // SubClass.m @implementation SubClass + (void)load { NSLog(@"SubClass +load"); } @end // SuperClass+CategoryA.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ceab5d65ab1b0a84f14ab4e26eb9e9db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f61b07cfa2fc1256868128a810f64dd/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(066)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
261、pandas.Series.dt.year属性
261-1、语法
261-2、参数
261-3、功能
261-4、返回值
261-5、说明
261-6、用法
261-6-1、数据准备
261-6-2、代码示例
261-6-3、结果输出
262、pandas.Series.dt.month属性
262-1、语法
262-2、参数
262-3、功能
262-4、返回值
262-5、说明
262-6、用法
262-6-1、数据准备
262-6-2、代码示例
262-6-3、结果输出
263、pandas.Series.dt.day属性
263-1、语法
263-2、参数
263-3、功能
263-4、返回值
263-5、说明
263-6、用法
263-6-1、数据准备
263-6-2、代码示例
263-6-3、结果输出
264、pandas.Series.dt.hour属性
264-1、语法
264-2、参数
264-3、功能
264-4、返回值
264-5、说明
264-6、用法
264-6-1、数据准备
264-6-2、代码示例
264-6-3、结果输出
265、pandas.Series.dt.minute属性
265-1、语法
265-2、参数
265-3、功能
265-4、返回值
265-5、说明
265-6、用法
265-6-1、数据准备
265-6-2、代码示例
265-6-3、结果输出
二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 261、pandas.Series.dt.year属性 261-1、语法 # 261、pandas.Series.dt.year属性 pandas.Series.dt.year The year of the datetime. 261-2、参数 无
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f61b07cfa2fc1256868128a810f64dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3062b8a06296fe713c0ae14ef1b24946/" rel="bookmark">
			JavaEE 第3节 线程安全知识铺垫2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中线程终止的方式 下面代码我们创建了一个thread线程，如何在main线程（main方法中）终止thread线程？
1、手动标记 public class Threads { public static void main(String[] args) { Thread thread = new Thread(() -&gt; { while (true) { System.out.println("我是thread线程"); } }); thread.start(); //如何在main线程（main方法中）终止thread线程？ } } 有一个很简单的办法，就是做一个标记：
public class Threads { //定义一个变量，来判断是否终止线程 private static boolean isQuit=true; public static void main(String[] args) { Thread thread = new Thread(() -&gt; { while (isQuit) { System.out.println("我是thread线程"); } }); thread.start(); System.out.println("主线程即将终止thread线程的运行"); isQuit=false; System.out.println("主线程终止了thread线程"); //如何在main线程（main方法中）终止thread线程？ } } 的确，thread线程被终止了：
这种方法可行，但是注意不要把isQuit定义在main方法中，不然会报错：
原因在于我们创建线程用到了lambda表达式（本质还是匿名内部类创建），如果把isQuit定义在main方法内部，那么就会触发变量捕获，提示说isQuit必须是final或者effectively final的，这个细节大家要注意。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3062b8a06296fe713c0ae14ef1b24946/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/367629214390e3a24b647af7b7aa7ec7/" rel="bookmark">
			C# 实现改造 GooFlow 流程图插件与数据库应用的结合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
关于 GooFlow
功能需求
范例运行环境
设计数据表
流程项目表
流程项目节点明细表
流程项目节点审批人表
人员信息表
示例代码
流程图主功能
设置审批人信息
运行结果演示
总结
关于 GooFlow GooFlow 一个基于 Jquery/FontAwesome 的流程图/架构图画图插件，本文介绍的是基于JS的一个版本，能够适用于大部分支持H5的浏览器。通过创建画布，我们可以在其上通过工具栏绘制想要绘制的流程图/框/线等，如下图所示：
图中包括操作工具栏（顶部）、绘图工具栏（左侧）和绘制画布区域，左上角显示的是当前流程的名称。 具体的操作我们不再详述，本文将介绍通过改造后的 GooFlow 简化版本，结合数据库满足实际的开发需求。
功能需求 我们需要实现一个审批流程，在关键流程节点可能会添加审批人信息，通过GoolFlow绘制并显示，则更加友好和直观， 基本需要实现如下功能：
1、改造 GooFlow JS 程序，简化绘制工具栏。
2、设计相关数据库数据表保存流程图设计相关信息、节点明细信息等。
3、改造 GooFlow 操作工具栏，满足实际应用。
范例运行环境 操作系统： Windows Server 2019 DataCenter
GooFlow 版本：GooFlow V1 JS 版 数据库：Microsoft SQL Server 2016
.net版本： .netFramework4.7.1 或以上
开发工具：VS2019 C#
设计数据表 流程项目表 cc_flow 表记录项目信息，主要说明见下表：
序号字段名类型说明1ciduniqueidentifier记录唯一标识2flowNamenvarchar(50)流程项目名称3nodeCountint节点总个数4desriptnvarchar(50)项目描述5flowJSONnvarchar(MAX)流程全部 JSON 数据6sys_insusernvarchar(100)创建信息用户名7sys_instimedatetime创建时间8sys_updusernvarchar(100)最后修改信息用户名9sys_updtimedatetime修改时间 创建脚本如下：
CREATE TABLE [dbo].[cc_flow]( [cid] [uniqueidentifier] ROWGUIDCOL NOT NULL, [flowName] [nvarchar](50) NOT NULL, [nodeCount] [int] NULL, [desript] [nvarchar](100) NULL, [flowJSON] [nvarchar](max) NULL, [sys_insuser] [nvarchar](100) NULL, [sys_instime] [datetime] NULL, [sys_upduser] [nvarchar](100) NULL, [sys_updtime] [datetime] NULL, CONSTRAINT [PK_cc_flow] PRIMARY KEY CLUSTERED ( [cid] ASC )WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY], CONSTRAINT [IX_cc_flow] UNIQUE NONCLUSTERED ( [flowName] ASC )WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY] ) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY] GO ALTER TABLE [dbo].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/367629214390e3a24b647af7b7aa7ec7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70ead8529cf1f80b809b0428c748d710/" rel="bookmark">
			【MySQL】库操作，数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 MySQL简介SQL语句分类库操作语句展示数据库创建数据库使用数据库删除数据库 数据类型整型浮点型字符串日期类型 MySQL简介 数据库有关系型数据库和非关系型数据库。
关系型数据库：是指采用了关系模型来组织数据的数据库。 简单来说，关系模型指的就是二维表格模型，而一个，关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。基于标准的SQL，只是内部一些实现有区别。非关系型数据库：不规定基于SQL实现。现在更多是指NoSQL数据库。 二者区别：
MySQL就是一个关系型数据库。
安装MYSQL直接在网上找个教程就行，我安装的是MYSQL8.0.33。
接下来介绍使用SQL语句操作数据库。
SQL语句分类 SQL语句不区分大小写。
DDL（data definition language）数据定义语言，用来维护存储数据的结构， 代表指令：create drop alter。DML（data manipulation language）数据操纵语言，用来对数据进行操作， 代表指令：insert delete update， 单独分了一个DQL（data query language），数据查询语言， 代表指令： select。DCL（data control language）数据控制语言，主要负责权限管理和事务 代表指令： grant revoke commit。 库操作语句 展示数据库 展示当前含有的所有的数据库，使用关键字show：
show databases； 创建数据库 创建数据库使用关键字create：
最简单写法：
create database 数据库名; 加上判断该数据库是否已经存在（if not exists ）：如果已存在就报个警告，没有就创建。
create database if not exists 数据库名; 指定字符集（character set）可简写为charset：
create database if not exists 数据库名 character set 字符集名; 如果没有指定会使用数据库默认的字符集5.7版本默认字符集为latin，该字符集不支持中文，8.0版本默认字符集为utf8mb4，
而我们一般指定字符集为utf8mb4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70ead8529cf1f80b809b0428c748d710/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d7f63698adcf24d27157a2a440fc4ea/" rel="bookmark">
			悠易科技周文彪：创始人专注度很重要，一旦战略分散无法形成合力 | 中国广告营销行业资本报告深访④
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 周文彪（悠易科技CEO） 问：近年来广告营销行业主要的融资事件发生在营销技术领域。您对此有何评论？
Roy：Adtech最早从2007年前后开始发展，差不多十年的时间，因为广告技术帮助企业成长，发展比较快，但是到了2017年前后，流量红利到顶，很多企业瞄准私域，消费者也比之前更加碎片化，种种因素结合起来，催生了许多Martech公司，而一些早期做的比较成功的Adtech公司也开始转向Martech。所以过去几年，Martech行业吸引了大量的投资。此外，Martech是解决企业的成长问题，涉及数据、私域、内容等更广的范围，所以大部分投资落在这个领域并不奇怪。
2022年，由于疫情的原因，Martech和Adtech在资本市场都面临挑战，进入资本的寒冬，包括Adobe、TTD在内的Martech公司都出现了估值下滑，但不影响其强劲的融资事件。甚至2022年Q4的数据与Q1相比较，还出现了反弹的趋势，估值在稳定上涨。所以总的趋势来看，我持乐观态度。
当然我认为这对整个Martech行业不是坏事——这些Martech公司早期的成长可以说是资本驱动型的，而现在必须回归本质，侧重产品打磨，最终把业务做起来。比如很多公司采用了SaaS模式，就要真正做好客户体验，带来增值。但对那些单纯以大客户定制化项目为主的Martech公司，挑战会非常大。
问：您认为现阶段的营销技术行业是一片蓝海还是红海？
Roy：既有红海也有蓝海。首先说我认为是红海的方面。各个赛道经过六七年的发展，有一定的拥挤度，像CDP相关的企业，你随便搜一下，就能找到二十多家；很多公司都宣称自己有MA产品，等等。悠易在投标的时候，也会发现很多没有听说过的公司。因为很多客户尤其是中腰部客户，认知还没有完全到位，只知道自己有需求的痛点，并不确切知道自己需要CDP还是MA，所以吸引了大量的公司来投标。从这个角度来说，是有一定红海的成分的。
但从整个中国Martech市场发展来看，远远没有到「卷」的程度，未来还是有很多蓝海市场。对Martech公司来说，需要真正深入了解企业的痛点，它肯定不仅仅满足于购买软件工具，最终目的是要用起来，所以我认为Martech未来的发展主要围绕应用场景的落地。
很多企业刚拿到投资的时候，往往忽略这一点，拼命追求规模，不论是定制化还是项目制，只求把量做大，以吸引新的投资，形成循环。有这样想法的公司，在过去几年里受到重挫。所以还是要回归Martech的本质：解决企业的问题，各种应用场景落地，真正创造价值，对企业业务增长有帮助。目前，Martech行业在中国还处于早期阶段，和美国相比还有很长的路要走。在这个过程中，如果围绕客户的痛点有根本性的差异化，就可以创造蓝海。
问：您说的「早期阶段」，它的特点是什么？
Roy：「早期阶段」的特点之一，是玩家多，各种各样的得到资本支持的创业公司加入进来，当然也有退出的。而中后期则是Martech公司进入到创造价值的阶段。早期阶段像短跑，需要Martech企业练好基本功，真正帮助客户解决根本性的问题。过去一年，资本也比较谨慎，推动Martech企业做好产品，做好交付，提升价值，这样才能做大。中后期阶段像中长跑，需要靠企业的产品能力、服务能力、运营能力，帮客户创造价值。
问：那么到一个什么样的阶段才能被称为中期，或者说下一个阶段？
Roy：过去两年因为融资容易，一些Martech公司并没有特别注重产品的打磨，而是一味扩大规模和业务量，去接各种项目。但是项目对产品的打磨未必有帮助，特别是形成一个标准化的产品，很难说一款SaaS产品能有多大的帮助。我们早期做过尝试，例如汽车行业，服务汽车品牌A的经验很难复制给汽车品牌B，业务逻辑等方面都不同。Martech公司需要打磨用户体验好的、开箱即用的交付型的产品。
目前在中国，绝大多数的Martech公司，没有非常核心的技术能力。其中营收达到5000万以上的公司，可能都没有到10%，超过一个亿营收的，就更少了。Martech公司需要进入到以客户为导向、而不是以融资为导向的阶段。在新的阶段里，Martech可以靠资本去扩大业务，但不会完全依赖于资本，我认为这是前期与中期的划分点。
问：2021年底起，行业屡次出现并购案例。「大鱼吃小鱼」会成为常态吗？
Roy：我认为会的。在早期阶段，大家发现了新的业务机会，都参与创业。就像现在AI、ChatGPT概念火了，可能有大批AI领域的创业公司。这在风口期是很正常的。但是发展到一定阶段，企业必须有一定的坚持和初心，才能够走得比较久。我认为Martech已经到了这个阶段，未来两三年会出现更多类似的并购案例。
其实美国市场也是一样，2022年就发生过10亿美元以上的并购案。我认为这是一个行业发展到比较稳健的阶段或者中期阶段的标志性事件。
问：您认为营销技术行业发展的下一个关键词就会是什么？
Roy：从我的角度来讲，我更关心的是我们能解决客户的什么痛点。因此我关注这几个关键词。
首先是我们要去交付价值，而不是交付软件工具。为了交付价值，Martech公司需要了解客户的痛点，了解客户的应用场景，将产品的解决方案与应用场景各方面结合起来。我认为一方面行业会发生整合与并购，一方面接下来会有明确的分工。
其次，AI first。AI将对Martech产生很多助力，甚至颠覆Martech行业，典型例子如预测模型，根据现有的历史数据去预测未来，等等。AI算法对公域领域的广告投放也起到非常大的作用。而AIGC对创意和内容行业的影响也是很大的。我相信侧重AIGC内容管理的企业会得到资本青睐，整个Martech行业的细分赛道里，内容与CDP、技术和分发结合起来，有很大的想象空间。
再次，生态。悠易比较早期认识到我们不可能什么都做，一定要通过强强联合来服务客户。像美国Martech行业有超过一万家企业，出现很多细分公司，CRM公司很难再做CMS或者CDP。所以Martech在中国的发展也类似。悠易合作过的一些公司，只负责做运营，它的运营能力超过悠易；而将数据平台和技术平台交给悠易来完成。所以未来Martech行业既有整合，也有分工。
问：您反复强调产品应用场景，那么今后会出现某个垂直赛道的Martech公司吗？
Roy：我认为会的。其实Martech最终还是要去解决客户的痛点，做用户增长，或是企业收入增长，这是终极目标。当然行业有差异化，美妆品牌与家装品牌的需求肯定不同，所以Martech公司需要深耕行业，围绕行业去构建生态。我认为在一些大的行业，像汽车、美妆、家装、快消品等，都应该出现一些深度垂直化的Martech公司和产品解决方案。只有做的足够深，才能更好地解决客户的痛点。
问：调研发现，很多融资金额排名靠前的营销技术公司表现并不尽如人意，一些公司甚至发生裁员、业务缩减等现象，您认为背后的原因是什么？
Roy：LinkedIn的创始人说过，创业公司尤其在早期的时候，不要拿太多钱，这不是一件好事情。创业者在缺乏资金的时候会精打细算，会谨慎决策，一着不慎就可能满盘皆输；但当他们突然拿到很多钱的时候，往往会快速扩张团队，布局新的方向和领域，而这些新的方向并没有真正协同朝向一个战略目标。例如Martech公司跨行进入政企相关的领域，需要进行深度行业磨合的。如果这样的方向得到CEO的关注低于20%，就会很危险，除非该方向的领头人很强。处于早期的创业公司，创始人的专注度很重要，一旦战略分散就无法形成合力。
其次，创业公司拿了投资人的钱，公司要实现增长，这必然受到宏观环境以及行业环境的影响。Martech行业有不少公司，会去拿一些以前不会拿、不该拿的项目，比如金额很大、但是高度定制化的重项目。有一家公司，一半的研发都被卷入项目的交付，导致产品全部延期，乃至于战略变形。这些公司原本想的是有新一轮融资，但当资金链发生问题的时候，为了存活下去，只有裁员。其结果最终背离了创业者的初心和战略方向。
当然疫情属于特殊情况，它是一柄双刃剑，一方面教育企业拥抱数字化转型；另一方面企业营收受影响，需要降本增效。需要等经济慢慢好转起来，行业才会恢复元气。
对于创业公司来说，企业服务行业是一场长跑比赛。作为方向的Martech是没有问题的，但道路比我们想象的要更长，我们需要更多的耐心。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c401d4fe9515aa08c645957ad7860fa/" rel="bookmark">
			自动化工具Selenium IDE基本使用——脚本编辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在上一篇文章自动化工具Selenium IDE基本使用——脚本录制中，我们学习了Selenium IDE的安装和基本使用，这篇文章我们来说说脚本编辑。
1 变量声明与赋值 2 控制逻辑使用 3 导出 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b76f9b79a40a0a72019daa349f0daa1/" rel="bookmark">
			利用Python进行金融数据分析的全面指南【文末送书】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Python金融数据分析技术文章Python金融数据分析【文末送书】 Python金融数据分析技术文章 金融数据分析在现代金融行业中扮演着至关重要的角色。通过使用Python编程语言，我们可以对大量金融数据进行处理、分析和可视化，从而获得有价值的洞察。本篇文章将介绍如何使用Python进行金融数据分析，涵盖数据获取、清洗、分析和可视化的全过程。
环境准备 首先，确保已安装以下库：
pip install pandas numpy matplotlib yfinance 获取金融数据 我们将使用yfinance库来获取股票数据。以下示例展示了如何获取苹果公司（AAPL）的历史股票价格数据：
import yfinance as yf import pandas as pd # 获取AAPL股票数据 ticker = 'AAPL' data = yf.download(ticker, start='2020-01-01', end='2023-12-31') print(data.head()) 数据清洗 在分析之前，我们需要对数据进行清洗。常见的清洗步骤包括处理缺失值和去除异常值：
# 检查缺失值 print(data.isnull().sum()) # 去除缺失值 data.dropna(inplace=True) # 检查异常值（如价格为0的情况） data = data[data['Close'] &gt; 0] 数据分析 接下来，我们可以进行一些基本的分析，例如计算股票的日收益率和移动平均线：
# 计算日收益率 data['Daily Return'] = data['Close'].pct_change() # 计算移动平均线 data['20 Day MA'] = data['Close'].rolling(window=20).mean() data['50 Day MA'] = data['Close'].rolling(window=50).mean() 数据可视化 使用matplotlib库，我们可以将分析结果进行可视化：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b76f9b79a40a0a72019daa349f0daa1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6614ccc67973791b79016b9129f86da/" rel="bookmark">
			【C&#43;&#43;深度探索】红黑树的底层实现机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥 个人主页：大耳朵土土垚 🔥 所属专栏：C++从入门至进阶 这里将会不定期更新有关C/C++的内容，欢迎大家点赞，收藏，评论🥳🥳🎉🎉🎉 前言 红黑树与AVL树一样，也是一种自平衡的二叉搜索树，它在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black，通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。
文章目录 前言1.红黑树结构2.红黑树的插入3.红黑树的验证4.中序遍历5.结语 1.红黑树结构 红黑树的性质：
每个结点不是红色就是黑色根节点是黑色的如果一个节点是红色的，则它的两个孩子结点是黑色的对于每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点 所以红黑树的节点必须包含一个值类存储该节点的颜色，我们可以利用枚举来实现：
//枚举颜色 enum Colour { RED, BLACK }; //节点类 template&lt;class K, class V&gt; struct RBTreeNode { pair&lt;K, V&gt; _kv;	//存放数据 RBTreeNode&lt;K, V&gt;* _left; RBTreeNode&lt;K, V&gt;* _right; RBTreeNode&lt;K, V&gt;* _parent; Colour _col;	//保存颜色 RBTreeNode(const pair&lt;K, V&gt;&amp; kv) :_kv(kv) , _left(nullptr) , _right(nullptr) , _parent(nullptr) ,_col(RED) {} }; //红黑树类 template&lt;class K, class V&gt; class RBTree { typedef RBTreeNode&lt;K, V&gt; Node; public: // 在红黑树中插入值为data的节点，插入成功返回true，否则返回false bool Insert(const pair&lt;K, V&gt;&amp; data); // 检测红黑树是否为有效的红黑树 bool IsValidRBTRee(); //中序遍历 void InOrder() { _InOrder(_pHead); } private: void _InOrder(Node* root); bool Check(Node* root, int blackNum, const int refNum); // 左单旋 void RotateL(Node* parent); // 右单旋 void RotateR(Node* parent); private: Node* _pHead = nullptr; }; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6614ccc67973791b79016b9129f86da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df26c657668820aa30f0c06f41e16ad2/" rel="bookmark">
			【微服务】Spring Cloud 服务网关之Zuul
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 强烈推荐引言用途使用情况使用场景基本使用示例总结强烈推荐专栏集锦写在最后 强烈推荐 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站:人工智能
引言 服务网关（API Gateway）它不仅负责请求的路由和负载均衡，还为微服务体系结构提供了一个安全和监控的统一入口。
Spring Cloud Zuul 作为 Netflix OSS 组件之一，是一种强大且灵活的服务网关解决方案。
通过 Zuul，我们可以实现动态路由、负载均衡、安全过滤、监控和自定义过滤器等功能，使得微服务系统更加健壮和易于管理。
用途 Spring Cloud Zuul 是一种 API Gateway 服务，用于处理所有请求路由和 API 调用的统一入口。在微服务架构中，Zuul 作为一个边缘服务，可以用于以下用途：
动态路由：Zuul 能够将请求转发到不同的微服务。它可以根据请求的 URL、HTTP 方法、参数等信息来决定将请求转发到哪个服务。负载均衡：Zuul 可以与 Ribbon 配合使用，提供负载均衡功能。它能够将请求均衡地分发到多个服务实例上。安全：Zuul 可以作为安全关卡，过滤不安全的请求，验证和认证请求。监控和指标：通过集成如 Hystrix 的熔断机制，Zuul 可以监控请求的健康状况，并在必要时熔断不健康的服务。过滤器：Zuul 提供了丰富的过滤器机制，可以在请求被路由之前或之后对请求进行处理。常见的过滤器类型包括： 前置过滤器（Pre Filter）：在请求路由到具体服务之前执行，可以用于身份认证、记录日志等。路由过滤器（Route Filter）：用于请求的路由逻辑处理。后置过滤器（Post Filter）：在请求路由之后执行，可以用于修改响应、记录日志等。错误过滤器（Error Filter）：在请求处理过程中发生错误时执行。 使用情况 Zuul 是 Netflix 开发的开源边缘服务，早期在 Spring Cloud 生态系统中广泛使用。
然而，随着时间的推移和技术的进步，Netflix 自己转向了其他技术，如基于 gRPC 的 API 网关，Spring Cloud 也推出了更现代化的替代方案，如 Spring Cloud Gateway。
虽然 Zuul 1.x 系列在社区中依然被一些项目和企业使用，但它的后续开发和维护已显著减缓。
Zuul 2.x 提供了一些性能和功能的改进，但它的使用并没有广泛推广。相比之下，Spring Cloud Gateway 作为一个更现代化、响应式的替代方案，已经成为 Spring Cloud 生态系统中的主要选择。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df26c657668820aa30f0c06f41e16ad2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d3fa21bd3d534b41ae86b053989bd59/" rel="bookmark">
			Liunx 小程序之进度条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Liunx 小程序之进度条 效果前提条件回车和换行缓冲区倒计时 进度条纯进度条模拟下载的进度条Progressbar.hProgressbar.cmain.cmakefile 效果 先来看效果，这其实是一个动态的进度条，后有源码，运行即可：
前提条件 在制作之前有两个前提条件需要了解
回车和换行 这个概念，一般人均会混为一谈，而程序员因为熟知 '\n' ，所以深刻理解 换行符 是 将当前光标位置换到下一行的开头
而 '\n' 这个字符其实是两个动作，一个是 回车 ，一个是 换行
换行：顾名思义，只是将当前光标位置换进下一行，但是其在下一行的什么位置，取决于之前上一行的所在位置回车：这是 将光标置于此行开头位置 所以一般来说， 换行符 所完成的是这 两个动作 的总和
而在 C 语言里，只 回车 为 '\r' ，所以有些人会写出 "\r\n" 这样的代码，这时候的 '\n' 就只表示 换行 了
缓冲区 有了上面 回车 和 换行 的解释，对于 缓冲区 ，我们需要对比观察这样两份代码：
// 第一份代码： #include &lt;stdio.h&gt; #include &lt;unidstd.h&gt; int main() { printf("Hello World...\n"); sleep(3); return 0; } // 第二份代码： #include &lt;stdio.h&gt; #include &lt;unidstd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d3fa21bd3d534b41ae86b053989bd59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32a74115d87239efbb97a86008e2f19f/" rel="bookmark">
			AMD Product Specifications - AMD 产品规格汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AMD Product Specifications - AMD 产品规格汇总 1. Desktop, Laptop and Workstation Processor Specifications (台式处理器、笔记本电脑处理器和工作站处理器规格)2. Server Processor Specifications (服务器处理器规格)3. Embedded Processor Specifications (嵌入式处理器规格)4. Accelerator Specifications (加速器规格)5. Desktop and Laptop Graphics Specifications (台式机显卡和笔记本电脑显卡规格)6. Workstation and Professional Graphics Specifications (工作站显卡和专业显卡规格)References https://www.amd.com/en/products/specifications.html
1. Desktop, Laptop and Workstation Processor Specifications (台式处理器、笔记本电脑处理器和工作站处理器规格) https://www.amd.com/en/products/specifications/processors.html
Full product specifications for AMD Ryzen TM ^{\text{TM}} TM, Ryzen PRO, AMD Athlon TM ^{\text{TM}} TM, and AMD legacy processors.
2. Server Processor Specifications (服务器处理器规格) https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32a74115d87239efbb97a86008e2f19f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/80/">«</a>
	<span class="pagination__item pagination__item--current">81/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/82/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>