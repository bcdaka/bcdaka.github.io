<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6bbb84c53bfd4aeb0e74883752041e8/" rel="bookmark">
			在Spring中实现资源的动态加载和卸载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Spring框架中，实现资源的动态加载和卸载通常涉及以下几个方面：
1. 使用@Bean注解动态注册Bean 通过在配置类中使用@Bean注解，可以在运行时动态创建和注册Bean。
@Configuration public class DynamicBeanConfig { @Bean public MyBean myBean() { // 创建并返回MyBean实例 return new MyBean(); } } 2. 利用@Profile注解 根据不同的Profile动态加载不同的Bean。
@Configuration @Profile("dev") public class DevConfig { @Bean public DataSource dataSource() { // 返回开发环境的DataSource return new DevDataSource(); } } 3. 使用@Conditional注解 自定义条件注解，根据条件动态加载Bean。
@Configuration public class ConditionalBeanConfig { @Bean @Conditional(OnPropertyCondition.class) public MyBean myConditionalBean() { return new MyBean(); } } OnPropertyCondition类需要实现Condition接口，并根据属性判断是否满足条件。
4. 动态创建Bean 可以在运行时根据需要动态创建Bean实例。
public class BeanFactoryPostProcessorImpl implements BeanFactoryPostProcessor { @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) { if (/* 条件满足 */) { beanFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6bbb84c53bfd4aeb0e74883752041e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d59fe996eb1eaec4d7db471671f0b62/" rel="bookmark">
			【机器学习】AI大模型的探索—分析ChatGPT及其工作原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📝个人主页：哈__
期待您的关注 目录
📚介绍ChatGPT
1.1 什么是ChatGPT
1.2 ChatGPT的应用场景
💡基础概念 1. 人工智能和机器学习
1.1 人工智能（AI）简介
1.2 机器学习（ML）简介
2. 自然语言处理（NLP）
2.1 NLP的定义与应用
2.2 NLP在ChatGPT中的角色
🔨ChatGPT的技术基础
1. GPT模型介绍
1.1 GPT（Generative Pre-trained Transformer）模型简介
1.2 GPT的版本演变（GPT-1、GPT-2、GPT-3、GPT-4等）
2. Transformer架构
2.1 Transformer架构的基本原理
2.2 注意力机制（Attention Mechanism）
2.3 自注意力机制（Self-Attention Mechanism）
🔥ChatGPT基本工作原理
输入处理
输入文本的预处理
Tokenization（分词）
生成响应
模型生成响应的步骤
如何确保生成的文本连贯性和相关性
后处理
响应文本的后处理
🌏未来发展方向
1. 技术改进
1.1 提高模型的准确性和可控性
1.2 改进对话连续性和上下文理解
2. 新应用探索
2.1 新兴应用场景
3. 多模态模型的发展
3.1 跨模态理解与生成
3.2 融合视觉和语言信息
📚介绍ChatGPT 1.1 什么是ChatGPT ChatGPT是一个由OpenAI开发的自然语言处理模型，基于生成式预训练变换器（Generative Pre-trained Transformer，简称GPT）架构。它旨在通过理解和生成类似人类的文本来进行对话和回答问题。ChatGPT能够根据输入文本的上下文生成连贯且相关的响应，展现出强大的语言理解和生成能力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d59fe996eb1eaec4d7db471671f0b62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0635180d4b094b00d7f77f28595e15a/" rel="bookmark">
			大数据农产品数据分析：基于Python机器学习算法农产品爬虫可视化分析预测系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 基于Python机器学习算法农产品爬虫可视化分析预测系统一、项目概述二、项目说明Navicat Premium 15简介Python语言Echarts简介Pycharm简介Mysql简介机器学习算法 LinearRegression简介三、功能需求分析四、系统总体架构设计五、部分模块核心代码六、功能实现七、总结八、结语 基于Python机器学习算法农产品爬虫可视化分析预测系统 一、项目概述 本研究致力于设计并实现了一款基于Python的农产品可视化分析预测系统，系统主要利用requests库进行网络数据爬取，BeautifulSoup库解析网页内容，从惠农网获取相关农产品信息。系统功能包括数据价格分析、管理查询等，用户可以根据农产品名称进行机器学习模型的训练与预测，采用sklearn中的多元线性回归模型进行未来一周农产品价格的预测，并通过可视化分析展示结果。此外，系统还具备flask_admin后台数据管理功能，管理员可以对数据进行增删改查及修改用户权限。本研究的核心在于将爬虫技术、机器学习算法和数据可视化技术相结合，为农产品市场提供了一种全新的数据分析与预测工具。通过本系统，用户可以更加直观地了解农产品价格趋势，为农业生产和经营决策提供科学依据。未来，将进一步完善系统功能，提升用户体验，为农业信息化发展做出更大贡献。
二、项目说明 Navicat Premium 15简介 Navicat Premium 15是一款功能强大的数据库管理工具，为用户提供了全面的数据库管理解决方案。其直观的用户界面和丰富的功能使得数据库管理变得简单而高效。Navicat Premium 15支持多种数据库系统，包括MySQL、MariaDB、SQL Server、SQLite、Oracle等，使得用户能够轻松地管理不同类型的数据库。
Python语言 Python是一种高级编程语言，以简洁、易读的语法而闻名。它被广泛应用于各种领域，包括数据科学、人工智能、Web开发等。Python具有丰富的第三方库和框架，例如NumPy、Pandas、Scikit-learn等，使得数据处理和机器学习变得简单而高效。
Echarts简介 ECharts是一个基于JavaScript的开源可视化库，专注于提供简单、直观的数据可视化解决方案。它支持多种常见的图表类型，包括折线图、柱状图、饼图等，以及更复杂的地图、关系图等。ECharts具有丰富的交互功能，用户可以通过鼠标交互或者触摸屏操作来探索数据，实现动态展示和用户参与。
Pycharm简介 PyCharm是一款功能强大的Python集成开发环境（IDE），为Python开发者提供了全方位的开发支持。它拥有直观的用户界面和丰富的功能，包括代码自动补全、调试器、版本控制集成等，使得Python开发变得更加高效和愉快。
Mysql简介 MySQL是一种流行的开源关系型数据库管理系统，广泛应用于各种规模的应用程序中。它具有高性能、可靠性和易用性的特点，支持多种操作系统平台，并且与多种编程语言兼容。MySQL采用了客户端/服务器体系结构，能够处理大规模的数据，并提供了丰富的功能。
机器学习算法 LinearRegression简介 线性回归是一种用于建立和预测变量之间线性关系的机器学习算法。它是统计学中最基本、最简单的回归分析方法之一，也是许多其他机器学习算法的基础之一。
线性回归的基本原理是假设自变量（特征）与因变量（目标）之间存在线性关系，通过拟合一条最佳直线来描述这种关系。这条直线被称为回归线，通过该线可以对新的自变量值进行预测，从而得到对应的因变量值。
在线性回归中，通常使用最小二乘法来确定回归系数，即通过最小化实际值与预测值之间的误差平方和来求解最优的回归系数。这些回归系数表示了自变量对因变量的影响程度。
线性回归适用于以下情况：
自变量与因变量之间存在线性关系。数据中的噪声相对较小。可以通过对数据进行适当的变换来满足线性关系的假设。 线性回归的优点包括：
简单易于理解和实现。计算速度快，适用于大规模数据集。提供了对于自变量与因变量之间关系的直观理解。 三、功能需求分析 系统需要能够通过requests爬虫和BeautifulSoup解析器，从惠农网等农产品信息平台上获取相关数据。这包括农产品的价格、供应量、市场趋势等信息。爬取到的数据需要经过解析和清洗，确保数据的准确性和可用性。用户需要能够对爬取到的数据进行管理和查询。这包括数据的存储、检索、更新和删除等功能。用户应该能够通过系统界面轻松地查询到所需的农产品信息，并进行必要的数据管理操作。系统应该具备使用sklearn机器学习库中的多元线性回归（LinearRegression）模型来对未来一周农产品价格进行预测的功能。用户输入农产品名称后，系统应该能够自动训练相应的模型，并生成价格预测结果。预测结果应该以直观的可视化形式展示给用户，以便他们更好地理解和分析数据。系统应该支持生成各种图表、趋势图和统计图，帮助用户直观地了解农产品价格的变化趋势和波动情况。管理员需要能够通过后台管理界面对系统中的数据进行管理。这包括对数据的增加、删除、修改和查询等操作，以及对用户权限的管理和控制。系统需要具备数据爬取与解析、数据管理与查询、机器学习模型应用、可视化分析和后台数据管理等多项功能，以实现对农产品价格的可视化分析预测。通过这些功能的整合和实现，用户可以方便地获取到农产品市场的相关信息，并利用机器学习模型进行价格预测和分析，从而为农业生产经营者提供科学的决策支持。
四、系统总体架构设计 五、部分模块核心代码 #预测某个产品价格的变化趋势。从数据库中获取产品的交易记录，然后利用线性回归模型进行训练，并预测未来几天的价格走势。 def yuce1(name): try: dates = models.XinXi.query.filter(models.XinXi.产品 == name).all() date_day = list(set([i.日期 for i in dates])) date_day.sort() liuliang = [] for i in date_day: record_list = models.XinXi.query.filter(and_(models.XinXi.日期 == i,models.XinXi.产品 == name)).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0635180d4b094b00d7f77f28595e15a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9d942cf4fc4bb4e0207b40c8044ba1e/" rel="bookmark">
			六一见！｜Post Microsoft Build and AI Day 上海开发者日
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编辑/排版：Alan Wang
大小朋友明天见！
6月1日，Microsoft Azure &amp; Microsoft Reactor 面向大小朋友特别推出六一特辑，「Post Microsoft Build and AI Day 上海开发者日」 探讨 Microsoft Build 2024 带来的最新发布，「Global Season of AI 2024 - Shanghai」探索有趣的生成式 AI 体验，「编程一小时·六一特辑：海洋环保中的人工智能」带小朋友们动手体验海洋环保中的人工智能。
更多玩法，超多惊喜，收下这份最全参会攻略，来微软 Reactor 一起过六一吧！
活动时间 2024年6月1日 10:00 - 17:00
活动地点 上海市徐汇区田林路192号J座 微软 Reactor
活动日程 现场惊喜 Post Microsoft Build and AI Day 上海开发者日 活动现场将提供免费午餐与茶歇现场提问互动还将获得微软 Reactor 鼠标垫以及小蜜蜂玩偶 编程一小时·六一特辑：海洋环保中的人工智能 参会即可领取微软 Reactor 六一限定惊喜现场参与互动还将有机会获得微软 Reactor 鼠标垫、小蜜蜂玩偶，以及萌可盲盒等奖品
注意事项 三场活动独立报名，请分别报名参与活动「编程一小时」动手实践面向3年级以上的小学生朋友，需能够使用平板或电脑操作浏览器，建议携带平板或笔记本电脑现场参与 社区集市 本次 Post Microsoft Build and AI Day 上海开发者日 现场还将有微软最有价值专家、Power Platform 中文社区、PyChina 社区、.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9d942cf4fc4bb4e0207b40c8044ba1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93d7fd4fe36a004c63eed5a457c2224b/" rel="bookmark">
			【C&#43;&#43;】：vector容器的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 🍒1，vector的介绍🍒2，vector的使用🐯2.1 vector的构造🦁2.2 vector iterator 的使用🌽2.3 vector 空间增长问题🍓2.4 vector 增删查改🐯2.5 vector 访问及遍历🦊2.6 vector实例化string类的初始化形式🌴2.7 sort算法的使用 🚀3，动态二维数组的理解 🍒1，vector的介绍 vector是表示可变大小数组的序列容器。就像数组一样，vector也采用的连续存储空间来存储元素。也就是意味着可以采用下标对vector的元素进行访问，和数组一样高效。但是又不像数组，它的大小是可以动态改变的，而且它的大小会被容器自动处理。与其它动态序列容器相比（deque, list and forward_list）， vector在访问元素的时候更加高效，在末尾添加和删除元素相对高效。对于其它不在末尾的删除和插入操作，效率更低。比起list和forward_list统一的迭代器和引用更好。 🍒2，vector的使用 vector学习时一定要学会查看文档：vector的文档介绍vector在实际中非常的重要，在实际中我们熟悉常见的接口就可以，下面列出了哪些接口是要重点掌握的。
注意：使用vector要包含 &lt; vector &gt;
🐯2.1 vector的构造 我们先介绍使用两个重点的构造使用，其余两个在下一篇模拟实现的文章中会涉及。
代码演示：
void TestVector1() { //无参构造 vector&lt;int&gt; v1; //构造并用4个100初始化 vector&lt;int&gt; v2(4, 100); //拷贝构造 vector&lt;int&gt; v4(v3); //用迭代区间初始化 vector&lt;int&gt; v3(second.begin(),second.end()); } 🦁2.2 vector iterator 的使用 代码演示：
void TestVector2() { // 使用push_back插入4个数据 vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(4); // 使用迭代器进行遍历打印 vector&lt;int&gt;::iterator it = v.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93d7fd4fe36a004c63eed5a457c2224b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41ee7baff7cfed8d166a41b3ab903486/" rel="bookmark">
			实战经验分享之移动云快速部署Stable Diffusion SDXL 1.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文目录 前言产品优势部署环境准备模型安装测试运行 前言 移动云是中国移动面向政府、企业和公众的新型资源服务。 客户以购买服务的方式，通过网络快速获取虚 拟计算机、存储、网络等基础设施服务；软件开发工具、运行环境、数据库等平台服务；以及ERP、 CRM等应用产品服务。 同时，移动云针对电子政务、金融、教育、医疗、互联网等不同行业特点提供行业 云、混合云等定制化解决方案。 – – 《中国移动产品手册》 产品优势 中国移动云凭借坚实的央企基石、安全智能的防护体系、卓越的算网融合能力以及广泛的属地化服务优势，稳稳地站在了行业前沿，积极推动着各行各业的数字化转型与创新步伐。
相较于其他产品的优势：
作为中国移动涉云业务的主入口，中国移动云在云计算领域担当着国家队和主力军的角色。依托数字科技，助力数字中国建设，提供央企级别的保障。提供五大类数十款安全产品，并通过首批可信云认证，确保通信级的安全体系保障，成为客户最值得信赖的云服务商。以“4+N+31+X”的泛在算力布局，确保资源省份100%覆盖。连续三年建设速度位居业界第一，体现出强大的算网一体化能力。在省、市、县全域覆盖服务，拥有5万人的客户经理团队和超过11.6万人的技术人员团队，提供7*24小时的属地化支撑服务，致力于打造客户身边的云。国内外奖项40+项，国家级自主知识产权成果50+项。首个OpenStack SuperUser全球黄金会员。230+款自有产品，丰富度排名国内前二。推动超过6000个行业云项目落地，签约4000+家央国企。 部署环境准备 移动云提供0元上云(试用申请网址)，开发者可以免费体验使用移动云的云服务器。
这里选择个人专享的通用型云主机。
选择地域，centos镜像及其他配置如图所示。
网络相关配置
支付完成后跳转页面，得到一台linux服务器（支付后等待两分钟即可成功跳转）。
点击实例名称进行修改密码。
修改后无需重启就可以生效。
查看弹性公网IP分配是否正确，如下图
开放SSH登陆端口，选择一键放通，具体信息如图所示。
使用远程登陆软件，这里以FinalShell为例
安装Git和Git LFS
注意：git lfs 直接下载可能会失败，建议下载官方压缩包解压后进行install下载安装。
安装Screen
这一步的目的是在远程命令交互终端退出之后，后台还可以自动运行。
安装conda
conda环境创建
conda create -n sdxl python=3.10
conda activate sdxl
模型安装 下载stable diffusion webui项目 git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui.git
cd stable-diffusion-webui
2. 下载模型文件
d …
mkdir models
cd models
下面分别下载三个模型：
GIT_LFS_SKIP_SMUDGE=1 git clone https://huggingface.co/stabilityai/stable-diffusion-xl-refiner-1.0
cd …
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41ee7baff7cfed8d166a41b3ab903486/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5060431359d2a7bf773bd98fe9e3e063/" rel="bookmark">
			Golang反射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 基本介绍reflect包reflect.Typereflect.Valuereflect.Kind具体类型、空接口与reflect.Value的相互转换 反射应用场景修改变量的值访问结构体的字段信息调用变量所绑定的方法实现函数适配器创建任意类型的变量 基本介绍 基本介绍
在Go中，反射（reflection）是一种机制，其允许程序在运行时检查并操作变量、类型和结构的信息，而不需要提前知道它们的具体定义，使得代码更加灵活和通用。反射通常用于动态获取获取类型信息、动态创建对象、动态调用函数、动态修改对象等，在实现反射时需要用到reflect包。需要注意的是，虽然反射的功能强大，但由于其使用了运行时的类型检查和动态调用，在性能上可能会有一定的开销，因此在性能敏感的场景中，应该尽量避免过度依赖反射来实现常规的编程任务。 reflect包 reflect.Type reflect.Type
reflect.Type是reflect包中的一个接口类型，用于表示任意变量的类型信息。通过reflect包中的TypeOf函数，可以获取指定变量的类型信息。 reflect.TypeOf函数的函数原型如下：
func TypeOf(i interface{}) Type reflect.Type接口中常用的方法如下：
方法名功能Kind获取该类型对应的KindSize获取该类型的大小Elem获取该类型的元素的TypeNumField获取结构体类型的字段数NumMethod获取该类型所绑定的方法数Field获取结构体类型的第i个字段的信息Method获取该类型所绑定的第i个方法的信息FieldByName获取结构体类型的字段中，指定字段名的字段信息MethodByName获取该类型所绑定的方法中，指定方法名的方法信息NumIn获取函数/方法类型的参数个数In获取函数/方法类型的第i个参数的TypeNumOut获取函数/方法类型的返回值个数Out获取函数/方法类型的第i个返回值的Type 说明一下：
reflect.Type接口中的方法不需要用户手动实现，这些方法由反射系统在运行时为每个类型自动生成。reflect.Type接口中的方法不是对所有类型都能使用，每个方法都有其特定的适用范围和前提条件，如果在不满足调用条件的情况下调用了某个方法，则会触发panic异常。比如Elem方法只适用于数组、channel、map、指针和切片类型，NumField和Field方法只适用于结构体类型，NumIn、In、NumOut和Out方法只适用于函数或方法类型。 字段信息
通过reflect.Type接口的Field或FieldByName方法，能够获取结构体中某个字段的字段信息，获取到的字段信息通过StructField结构体进行描述。StructField结构体的定义如下：
type StructField struct { Name string // field name PkgPath string // package path Type Type // field type Tag StructTag // field tag string Offset uintptr // offset within struct, in bytes Index []int // index sequence for Type.FieldByIndex Anonymous bool // is an embedded field } 字段说明：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5060431359d2a7bf773bd98fe9e3e063/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/677eaf35452b586f6d178f74ec85740a/" rel="bookmark">
			算法（十一）贪婪算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 算法简介算法概念算法举例 经典问题 -背包问题 算法简介 算法概念 贪婪算法（Greedy）是一种在每一步都采取当前状态下最好的或者最优的选择，从而希望导致结果也是全局最好或者最优的算法。贪婪算法是当下局部的最优判断，不能回退。贪婪算法的高效性，以及所求得的答案比较接近最优结果，因此贪心算法可以作为辅助算法或者解决一些要求结果不那么精确的问题。 算法举例 有硬币分值为10、9、4若干枚，问如果组成分值18，最少需要多少枚硬币？
采用贪心算法，选择当下硬币分值最大的：10，18-10=8，8/4=2。即：1个10、2个4，共需要3枚硬币。实际上我们知道，选择分值为9的硬币，2枚就够了，也就是18/9=2。
如果有硬币分值为10、5、1若干枚，问如果组成分值16，最少需要多少枚硬币？
采用贪心算法，选择当下硬币分值最大的：10，16-10=6，6-5=1，即：1个10，1个5，1个1 ，共需要3枚硬币
即为最优解，因此贪心算法适合于一些特殊的情况，如果能用一定是最优解。
经典问题 -背包问题 背包问题是算法的经典问题，分为部分背包和0-1背包，主要区别如下：
部分背包：某件物品是一堆，可以带走其一部分0-1背包：对于某件物品，要么被带走（选择了它），要么不被带走（没有选择它），不存在只带走一
部分的情况。
部分背包问题可以用贪心算法求解，且能够得到最优解。 假设一共有N件物品，第 i 件物品的价值为 Vi ，重量为Wi，一个小偷有一个最多只能装下重量为W的背
包，他希望带走的物品越有价值越好，可以带走某件物品的一部分，请问：他应该选择哪些物品？
假设背包可容纳50Kg的重量，物品信息如下表：
贪心算法的关键是贪心策略的选择
将物品按单位重量所具有的价值排序。总是优先选择单位重量下价值最大的物品
按照我们的贪心策略，单位重量的价值排序： 物品A &gt; 物品B &gt; 物品C
因此，我们尽可能地多拿物品A，直到将物品1拿完之后，才去拿物品B，然后是物品C 可以只拿一部
分…
package com.xxliao.algorithms.greedy.demo01; import java.util.ArrayList; import java.util.Comparator; import java.util.List; import java.util.stream.Collectors; /** * @author xxliao * @description: 贪心算法 - 背包问题 * @date 2024/5/31 19:05 */ public class Greedy { public static void main(String[] args) { Greedy greedy = new Greedy(); List&lt;Goods&gt; goodslist = new ArrayList&lt;&gt;(); goodslist.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/677eaf35452b586f6d178f74ec85740a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3076b45554c5af0638036d1b0c4acc9/" rel="bookmark">
			身份认证与口令攻击
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		身份认证与口令攻击 身份认证身份认证的五种方式口令认证静态口令动态口令(一次性口令)动态口令分类 密码学认证一次性口令认证S/KEY协议改进的S/KEY协议 其于共享密钥的认证 口令行为规律和口令猜测口令规律口令猜测 口令破解操作系统口令破解Windows密码存储机制Windows密码破解方法 Unix/Linux系统口令文件Unix的口令文件Unix口令破解程序CrackJohn the RipperXITSlurpie 密码哈希值破解网络应用口令破解远程口令攻击跨域拓展攻击 口令防御 身份认证 系统安全性常常依赖于对终端用户身份的正确识别与检查。最基本的安全问题：对计算机系统的访问必须根据访问者的身份施加一定的限制。身份认证有两方面的内容：识别和验证。 识别：要明确访问者身份，即必须对系统中的每个合法用户都有识别能力 要保证识别的有效性，必须保证任意两个不同的用户都不能具有相同的识别符 验证：在访问者声称自己的身份后(向系统输入它的识别符)，系统还必须对它所声称的身份进行验证，以防假冒。 个人身份验证方法的四种类型： 所知：验证他知道什么，如密码、口令所有：验证他拥有什么，如身份证、护照、信用卡、智能门卡所在：验证他的位置，如IP、办公室地址用户特征：验证他的生物特征（如指纹、虹膜、DNA等）、行为特征（如击键、笔迹） 身份认证的五种方式 口令认证信物认证地址认证用户特征认证密码学认证 口令的“魔咒”：可记忆、抗猜测 “可记忆”要求口令尽量短、有规律、不复杂“抗猜测”要求口令尽量长、无规律、越复杂越好 没有一种认证方案可实现“文本”口令方案的所有优点。 口令认证 口令认证的不可替代性：口令认证仍将是最主要的认证方式 成本低廉可用性可再生性口令是中硬件token否低生物特征否高 静态口令 用户在注册阶段生成用户名和初始口令，系统在其用户文件或数据库中保存用户的信息。当用户登录认证时，将自己的用户名和口令上传给服务器，服务器通过查询其保存的用户信息来验证用户上传的认证信息是否和保存的用户信息相匹配。如果匹配则认为用户是合法用户，否则拒绝服务，并将认证结果回传给客户端。用户定期改变口令，保证安全性。静态口令因实现简单、使用方便，得到广泛的应用。 动态口令(一次性口令) 基本原理：在用户登录过程中，基于用户口令加入不确定因子，对用户口令和不确定因子进行单向散列函数变换，将结果作为认证数据提交给认证服务器。认证服务器接收到用户的认证数据后，把用户的认证数据和自己用同样的散列算法计算出的数值进行比对，从而实现对用户身份的认证。 动态口令分类 动态口令按生成原理可分为非同步和同步两种认证技术。非同步认证技术生成的动态口令主要是依据挑战－响应原理来实现。 挑战—响应机制
同步认证技术包括与时间有关的时钟同步认证技术和与时间无关的事件同步认证技术。 图形口令：图形密码是一种基于知识的认证机制，它利用人类对视觉信息的记忆与共享的秘密或组成的图像或草图，以提高密码的可记忆性，同时保留传统密码的安全性。 密码学认证 常用的密码学认证协议有一次性口令认证、基于共享密钥的认证、基于公钥证书的认证、零知识证明和标识认证等。 一次性口令认证 一次性口令（One-Time Password, OTP）：一般使用双运算因子来实现 固定因子：即用户的口令或口令散列值动态因子：每次不一样的因子，如时间，事件序列，挑战/应答 挑战—响应机制
S/KEY协议 一次性口令认证协议S/KEY
S/KEY中，服务器产生挑战（challenge）信息。挑战信息由迭代值（Iteration Count, IC）和种子（seed）组成。迭代值，指定散列计算的迭代次数，为1~100之间的数，每执行一次挑战/响应过程，IC减1（当IC为1时，则必须
重新进行初始化）。种子由两个字母和5个数字组成。例如，挑战信息“05 xa13783”表示迭代值为05，种子为“xa13783”。客户端收到挑战后，要将秘密口令与种子“xa13783”拼接后，做5次散列运算。 S/KEY中支持三种散列函数，即MD4, MD5和SHA。OTP服务器将散列函数的固定输出折叠成64位（OTP的长度）。64位OTP可以被转换为一个由6个英文单词组成的短语，每个单词由1~4个字母组成，被编码成11位，6个单词共66位，其中最后2位（ 11 × 6 − 64 = 2 11\times 6 - 64 = 2 11×6−64=2）用于存储校验和。 安全性分析 用户的秘密口令没有在网络上传输，传输的只是一次性口令，并且一次性口令即使在传输过程中被窃取，也不能再次使用。客户端和服务器存储的是用户秘密口令的散列值，即使客户端和服务器被攻陷导致口令散列值被窃取，也需破解口令散列才能获得明文口令。用户登录一定次数后，客户和服务器必须重新初始化口令序列为了防止重放攻击，系统认证服务器具有唯一性，不适合分布式认证单向认证（即服务器对客户端进行认证），不能保证认证服务器的真实性S/KEY使用的种子和迭代值采用明文传输，攻击者可以利用小数攻击来获取一系列口令冒充合法用户。 改进的S/KEY协议 核心思想：不在网络中传输一次性口令散列值。使用用户的口令散列对挑战进行散列，并将计算结果发送给服务器。服务器收到后，同样使用服务器保存的用户口令散列对挑战进行散列计算，并与客户端发来的应答进行比较，如果相同则认证通过，否则拒绝。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3076b45554c5af0638036d1b0c4acc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cd564ac9e890ce0fbe79706b520ceaa/" rel="bookmark">
			7B2 PRO主题5.4.2 免授权开心版源码 | WordPress主题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		B2 PRO 5.4.2 最新免授权版不再需要改hosts，和正版一样上传安装就可以激活。
直接在WordPress上传安装即可
源码下载地址：
极速云
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/451c47615e6ac3f95be6286d86a25a89/" rel="bookmark">
			Python&#43;Selenium自动化测试项目实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第 1 章 自动化测试
1.1、自动化测试介绍
自动化测试就是通过自动化测试工具帮我们打开浏览器，输入网址，输入账号密码登录，及登录后的操作，总的说来自动化测试就是通过自动化测试脚本来帮我们从繁琐重复的手工测试里面解脱出来，把时间和精力花到更好的地方去，去挖掘更多的产品缺陷。
例如网上有一些人提供智慧树网、学习通等网课的刷课及答题的服务就是通过写自动化测试程序去完成的。还有一些高速抢票平台也是通过定时执行自动化程序脚本代替人工去抢票。
1.2、自动化测试优点
1. 更好的利用资源，节约人力成本；
2. 覆盖更全，提高工作效率；
3. 产品规格统一标准，增加软件的稳定性。
1.3、自动化测试缺点
问题：是不是自动化测试一定会取代手工测试？
答：不一定的，自动化测试只是帮我们从繁琐重复的手工测试里面解脱出来，把时间和精力花到更好的地方去，去挖掘更多的产品缺陷。因凡事都有利弊，自动化测试适合的场景是软件需求变更少，周期长，稳定性较强的项目。如果需求变更多，软件经常进行改版就不适合做整个系统的自动化测试了，因为每一次改版都要去维护测试脚本，但可以抽取部分稳定的功能做自动化测试。
1.4、自动化测试能解决的问题
高效完成回归测试。回归测试就项目在发新版本之后，对项目之前的功能进行验证；每一次小迭代，加了一个小功能可能会影响整个系统的功能，比如淘宝、京东等大型商城有几十万个商品列表，这样手工去回归验证就会非常麻烦。而使用自动化测试脚本，就可以根据迭代功能修改自动化测试的脚本去验证，没问题就上线，有问题就让开发改完再上线，这样就不用手工去一个个验证，这就是自动化测试的好处。
解决-兼容性测试，更换不同浏览器的驱动就可以解决兼容性测试。
提高测试效率，保证产品质量。
第 2 章 Python基础
2.1、Python常用快捷键
2.2、函数
在开发程序时，使用函数可以提高编写的效率以及代码的重用。
（1）函数的使用包含两个步骤：
1. 定义函数 —— 封装独立的功能；
2. 调用函数 —— 执行函数的代码；
（2）定义函数的格式如下：
函数名称应该能够表达函数封装代码的功能，方便后续的调用。
（3）变量作用域：
1. 局部变量只能在函数内部使用，局部变量从调用函数的时候开始在内存出现，函数调用完毕，局部变量从内存消失；
2. 全局变量从定义变量开始在内存中出现，一直到程序运行完成，和程序一起从内存中消失。
在其他的开发语言中，大多不推荐使用全局变量，因为可变范围太大，导致程序不好维护！
2.3、面向对象编程
面向对象就是将世间万物抽象成一个类，然后形成相应的对象。
（1）类
类就是一个模板，是对一群具有相同特征或者行为的事物的一个统称，是抽象的模板，不能直接使用。
1.类的特性----属性；
2.类中行为----方法；
比如猫这个类有年龄，姓名，主人等属性，有学习、跑步、吃饭、睡觉等方法。
（2）对象
对象就是类的实例化，比如猫这个类可以实例化，具体是什么猫。
（3）面向对象程序设计三大特性： 封装：根据职责将属性和方法封装到一个抽象的类中，需要用到的时候导包，就可以调用属性和方法了；
继承：实现代码的重用，子类继承父类就可以拥有父类的属性和方法，这样相同的代码不需要重复的编写；
多态：不同的对象调用相同的方法，产生不同的执行结果，这样可以增加代码的灵活度。
第 3 章 元素定位方式 3.1、Selenium3.x提供了八种定位元素方式
1. id
2. name
3. class_name 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/451c47615e6ac3f95be6286d86a25a89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d0ca27b893ac9e8df91e96e0b6308de/" rel="bookmark">
			若依[RuoYi-Vue]使用（五）- 认识ruoyi前端文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言1. 前端项目结构一、index.vue1. 控件在网页、代码之间的映对1.1.1 控件1.1.2 参数1.3 二、dept.js1.代码2.未完待续 总结 前言 以“系统管理 - 部门管理”
认识若依前端 index.vue
认识若依前端 dept.js
1. 前端项目结构 项目结构
├── build // 构建相关
├── bin // 执行脚本
├── public // 公共文件
│ ├── favicon.ico // favicon图标
│ └── index.html // html模板
├── src // 源代码
│ ├── api // 所有请求
│ ├── assets // 主题 字体等静态资源
│ ├── components // 全局公用组件
│ ├── directive // 全局指令
│ ├── layout // 布局
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d0ca27b893ac9e8df91e96e0b6308de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62ebbd4f9622f7563b63150b64fd4d7c/" rel="bookmark">
			iPhone/Mac 之间跨设备拷贝/粘贴失效解决方案汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 最近突然发现在mac上复制的文本等内容，不能直接在iphone端粘贴过来了，同样在iphone上复制的的文本等内容，不能直接在Mac上粘贴过来。
尝试一： 将手机和mac都进行关机重启，仍然无效。
尝试二： 1、iPhone 关闭 Wi-Fi、蓝牙、接力，同时 MacBook 关闭 Wi-Fi、蓝牙、接力
2、 两者都关机，等几十秒钟，再把两者开机
3、iPhone 和 MacBook 都打开 Wi-Fi、蓝牙、接力
最终结论是：能使用，但是过了大约几个小时，又失效了 尝试三： 咨询apple支持在尝试解决问题过程中成功了，方法如下：
1、打开mac系统设置&gt;&gt;用户与群组&gt;&gt;添加一个新的管理员用户&gt;&gt;点击左上角苹果图标&gt;&gt;退出登录
2、登录新注册的用户（过程能跳过的都跳过），进入系统后在系统设置中打开隔空接力，此时iphone应该会弹窗有新设备加入
3、再次退出登录，登录回原来的用户，在尝试重新打开隔空接力后iphone也弹窗新设备接入，在这里开始我的iphone和mac接力恢复了，如果成功了可以删除刚刚注册的新用户
最后结论：iPhone和Mac 之间终于可以跨设备拷贝/粘贴了，内心窃喜。 您是否最近也遇到过这种问题呢？都是怎么解决的呢？欢迎下方评论区留言交流😄😄
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7de820e75278618a6d259053944391f8/" rel="bookmark">
			B端UI设计，演绎高情逸态之妙
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		B端UI设计，演绎高情逸态之妙
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/159ce407ad79ac28eb55a90f1b801ca0/" rel="bookmark">
			2024华为OD机试（Python）真题【A卷&#43;B卷&#43;C卷&#43;D卷】目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各语言题库： 【Python+JS+Java合集】【超值优惠】：Py/JS/Java合集 【Python】：Python真题题库 【JavaScript】：JavaScript真题题库 【Java】：Java真题题库 【C++】：C++真题题库 【C语言】：C语言真题题库 【面试手撕代码题库】：面试手撕代码题库 2024年4月最新更新，有同学发了D卷的链接，但是实际机考的时候发现全都是C卷的题目，无需担心，有新题的话第一时间更新的。
集中答疑： 0：全网最全题库，400+题目。
1：考试链接上写着【A卷】，对应的就是OD统一考试A卷目录的题目。
2：考试链接上写着【B卷】，对应的就是OD统一考试B卷目录的题目。目前B卷的题目由一部分以前考过的旧题库的题目+一部分全新题目（之前没考过的）题目组成。
3：考试链接上写着【C卷、D卷】。目前由A+B卷的旧题 + 全新题目组成。也就是说C卷和D卷还会考到A+B卷的题目，比例大概是新题1道，旧题2道。
4：【C卷、D卷】的新题有一个特殊点，就是无需自己处理输入和输出，为leetcode模式，实现对应函数逻辑即可。
5：机试没过，半年的冷冻期。
6：订阅专栏后，专栏内所有的文章都可以看，以后再更新新的题目也可以看，每年更新的题目都会更新到一个专栏里面。
7：文章内均有题目+思路+代码。
8：已经订阅过我专栏的同学，推荐新人订阅的可享 8折 优惠，私信我即可！
OD统一考试【C卷题库】 2023Q4新题库【更新中】
（目录可能更新不及时，可以直接搜我的博客）
序号题目考点分值时间1山脉的个数数据结构2002023Q42数据单元的变量替换字符串处理1002023Q43密码输入检测字符串处理1002023Q44找出作弊的人自定义排序1002023Q45转盘寿司单调栈2002023Q46体育场找座位逻辑分析1002023Q475G网络建设并查集2002023Q48中庸行者BFS/DFS2002023Q49会议室占用时间段逻辑模拟1002023Q410小华地图寻宝BFS/DFS2002023Q411CPU算力分配逻辑分析1002023Q412高效货运贪心算法1002023Q413小明的幸运数逻辑模拟1002023Q414跳马问题BFS/DFS2002023Q415掌握单词的个数数据结构1002023Q416计算三叉搜索树的高度树遍历2002023Q417来自异国的客人/幸运数字进制转换1002023Q418石头剪刀布游戏逻辑分析1002023Q419园区参观路径BFS/DFS1002023Q420多线段数据压缩数学知识2002023Q421开源项目热度榜单自定义排序1002023Q422API集群负载统计数据结构1002023Q423机场航班调度自定义排序1002023Q424小明找位置二分法1002023Q425最优的投资方式逻辑分析1002023Q426分配土地数据结构1002023Q427最多购买宝石数目滑动窗口1002023Q428王者荣耀游戏分组回溯算法1002023Q429执行任务赚积分逻辑模拟1002023Q430智能成绩表自定义排序1002023Q431内存冷热标记自定义排序1002023Q432最富裕的小家庭数据结构1002023Q433机器人搬砖二分法1002023Q434剩余银饰的重量逻辑模拟1002023Q435分割均衡字符串逻辑模拟1002023Q436分披萨回溯法1002024Q137员工派遣二分法+数学2002024Q138测试用例执行计划自定义排序1002024Q139伐木工贪心算法1002024Q140快递员的烦恼 / 快递员最短路径BFS/DFS1002024Q141跳格子3动态规划2002024Q142堆内存申请自定义排序1002024Q143符号运算/求分数计算结果数据结构2002024Q144反射计数逻辑模拟1002024Q145路口最短时间问题BFS/DFS2002024Q146小扇和小船的数字游戏进制问题1002024Q147亲子游戏BFS/DFS2002024Q148传递悄悄话数据结构1002024Q149特殊的加密算法BFS/DFS1002024Q150贪吃的猴子双指针法1002024Q151结对编程逻辑模拟2002024Q152幸存数之和逻辑模拟1002024Q153电脑病毒感染图计算2002024Q154部门人力分配二分法2002024Q155分解正整数数学知识1002024Q156围棋的气数据结构1002024Q157小朋友来自多少小区贪心算法1002024Q158宽度最小的子矩阵滑动窗口1002024Q159智能驾驶BFS/DFS2002024Q160推荐多样性逻辑模拟2002024Q161螺旋数组矩阵逻辑模拟1002024Q162精准核酸检测BFS/DFS1002024Q163田忌赛马BFS/DFS2002024Q164运输时间逻辑模拟2002024Q165Wonderland游乐园动态规划2002024Q166灰度图存储逻辑模拟1002024Q167寻找最优的路测线路BFS/DFS2002024Q168项目排期/最少交付时间二分法2002024Q169幼儿园篮球游戏逻辑模拟2002024Q170根据IP查找城市逻辑模拟1002024Q171启动多任务排序拓扑排序2002024Q172攀登者2逻辑模拟2002024Q173文件缓存系统数据结构2002024Q174密码解密逻辑模拟1002024Q175查找一个有向网络的头节点和尾节点拓扑排序2002024Q176抢7游戏逻辑模拟2002024Q177中文分词模拟器动态规划2002024Q178可以处理的最大任务贪心算法2002024Q179生成哈夫曼树二叉树2002024Q180两个字符串间的最短路径问题BFS/DFS2002024Q181手机App防沉迷系统自定义排序1002024Q182最长子字符串的长度（二）前缀和状态压缩2002024Q183攀登者1数据结构1002024Q184有效子字符串双指针法1002024Q185模拟目录管理逻辑模拟2002024Q186二叉树计算DFS2002024Q187矩阵匹配二分图2002024Q188学生重新排队、小朋友最少调整次数逻辑模拟2002024Q189目录待更新~~题目已经有了（此目录只含C卷的最新题，旧题属于B卷） OD统一考试【B卷】题库 序号题目考点分值时间1宜居星球改造计划数据结构2002023Q2 2
需要打开多少监视器
逻辑分析1002023Q23最佳植树距离逻辑分析1002023Q24阿里巴巴找黄金宝箱前缀和2002023Q25选修课数据结构1002023Q26五子棋迷逻辑分析1002023Q27代表团坐车动态规划1002023Q28座位调整逻辑分析1002023Q29食堂供餐二分法1002023Q210寻找最大价值的矿堆DFS1002023Q211最长公共后缀逻辑分析1002023Q212模拟消息队列逻辑分析1002023Q213比赛数据结构1002023Q214告警抑制逻辑分析1002023Q215报文重排序字符串处理1002023Q216字符串摘要字符串处理1002023Q217稀疏矩阵逻辑分析1002023Q218AI 识别面板数据结构1002023Q219报文回路数据结构1002023Q220阿里巴巴找黄金宝箱 II数据结构1002023Q221阿里巴巴找黄金宝箱 III数据结构1002023Q222阿里巴巴找黄金宝箱 IV单调栈2002023Q223文件目录大小DFS1002023Q224组装最大可靠性设备动态规划2002023Q225找出两个整数数组中同时出现的整数数据结构1002023Q226通过软盘拷贝文件动态规划2002023Q227代码编辑器逻辑分析2002023Q228数据分类进制问题1002023Q229恢复数字序列滑动窗口1002023Q230阿里巴巴找黄金宝箱 V滑动窗口1002023Q231比赛的冠亚季军排序算法1002023Q232数字游戏逻辑分析1002023Q233经典屏保逻辑分析1002023Q234字符串化繁为简字符串处理2002023Q235数据最节约的备份方法二分法2002023Q236跳格子2逻辑分析1002023Q237跳房子2数据结构1002023Q238支持优先级的队列数据结构1002023Q239乘坐保密电梯回溯法1002023Q240计算最接近的数逻辑分析1002023Q241人气最高的店铺逻辑分析1002023Q242战场索敌DFS2002023Q243二维伞的雨滴效应二叉树1002023Q244跳房子I数据结构1002023Q245分割数组的最大差值逻辑分析1002023Q246生日礼物二分法1002023Q247求最小步数逻辑分析1002023Q248拔河比赛数据结构1002023Q249评论转换输出递归法2002023Q250树状结构查询数据结构2002023Q251不开心的小朋友逻辑分析2002023Q252数字序列比大小逻辑分析2002023Q253符合要求的元组个数 / K 数之和回溯法1002023Q254最小循环子数组KMP算法2002023Q255金字塔 / 微商的收入数据结构1002023Q256矩阵元素边界值字符串处理1002023Q257MELON的难题动态规划2002023Q258矩阵中非1的元素个数BFS2002023Q259计算误码率逻辑分析2002023Q260增强的strstr正则匹配1002023Q261关联子串字符串处理1002023Q262计算礼品发放的最小分组数目双指针1002023Q263字符匹配正则匹配1002023Q264最小传输时延I Dijkstra算法2002023Q265一种字符串压缩表示的解压正则匹配1002023Q266冠亚军排名排序方法1002023Q267报数游戏逻辑分析1002023Q268找出经过特定点的路径长度逻辑分析1002023Q269按单词下标区间翻转文章内容字符串处理1002023Q270数列描述逻辑分析1002023Q271字符串筛选排序排序方法1002023Q272相对开音节正则匹配1002023Q273字符串变换最小字符串字符串处理1002023Q274VLAN资源池数据结构1002023Q275拼接URL字符串处理1002023Q276执行时长/GPU算力逻辑分析1002023Q277荒岛求生数据结构2002023Q378查字典字符串处理1002023Q379周末爬山BFS2002023Q380最小数字排序方法1002023Q381最长的元音子串字符串处理1002023Q382TLV解析II数据结构1002023Q383玩牌高手逻辑分析2002023Q384最长连续子序列滑动窗口1002023Q385路灯照明II区间合并1002023Q386最多团队排序方法1002023Q387最长的顺子数据结构1002023Q388数字最低位排序排序方法1002023Q389整数编码字符串处理1002023Q390找车位逻辑分析1002023Q391选举拉票线段树2002023Q392单词加密字符串处理1002023Q393购物优先级队列2002023Q394最佳的出牌方法逻辑分析2002023Q395字符串划分数据结构1002023Q396洞穴探险字符串处理1002023Q397最大岛屿体积BFS1002023Q398DNA序列滑动窗口1002023Q399服务启动DFS1002023Q3100最长公共前缀字符串处理1002023Q3101查找舆情热词数据结构1002023Q3102排队游戏二分法2002023Q4103BOSS的收入数据结构1002023Q4104猴子吃桃二分法1002023Q4105滑动窗口最大值滑动窗口1002023Q4106全排列数学问题1002023Q4107编码能力提升计划逻辑处理2002023Q4108水果摊小买卖贪心算法1002023Q4109正整数到excel编号的转换进制转换1002023Q4110反转每对括号间的子串数据结构1002023Q4111模拟工作队列数据结构2002023Q4112删除字符串中出现次数最少的字符字符串处理1002023Q4 2023Q2 旧题目
序号题目考点分值时间1 德州扑克
数据结构2002022Q1+2023 2
字符串子序列 II
字符串处理1002022Q1+20233 分苹果
位运算1002022Q1+20234 事件推送
数据结构1002022Q1+20235 路灯照明
逻辑模拟1002022Q1+20236 补种未成活胡杨
滑动窗口1002022Q1+20237 统计射击比赛成绩
排序算法1002022Q1+20238 高矮个子排队
排序算法2002022Q1+20239 非严格递增连续数字序列
双指针1002022Q1+202310 最大股票收益
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/159ce407ad79ac28eb55a90f1b801ca0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e0237bbaf238b696a7e7dd3e04580da/" rel="bookmark">
			sgg大数据全套技术链接网盘地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		尚硅谷大数据全套技术链接
1 章 尚硅谷大数据全套技术 Java从入门到精通JDK版 链接：https://pan.baidu.com/s/1GAc610SYSMmZBuOX4DJ-lg
提取码：YYDS
--来自百度网盘超级会员V6的分享
尚硅谷大数据技术之Java编程语言 链接：https://pan.baidu.com/s/1pT5Pdnjy4hLiFX2Oov4BLQ
提取码：YYDS
--来自百度网盘超级会员V6的分享
尚硅谷大数据技术之MySQL基础 链接：https://pan.baidu.com/s/17Ua_HG4j8NALonpMvnQ16w
提取码：YYDS
--来自百度网盘超级会员V6的分享
尚硅谷大数据技术之jdbc 链接：https://pan.baidu.com/s/17oIlZCyTAT_5sE0w_CxifA
提取码：YYDS
--来自百度网盘超级会员V6的分享
尚硅谷大数据技术之Linux7.5 链接：https://pan.baidu.com/s/1SVt51kJjvFnNcMR30glOyA
提取码：YYDS
--来自百度网盘超级会员V6的分享
尚硅谷大数据技术之Shell 链接：https://pan.baidu.com/s/1XJNKHOZmI-QzijWzlpE2sw
提取码：YYDS
--来自百度网盘超级会员V6的分享
尚硅谷大数据技术之Hadoop3.x 链接：https://pan.baidu.com/s/1A4uQuhcHwaEPOUJSpP19Rw
提取码：YYDS
--来自百度网盘超级会员V6的分享
尚硅谷大数据技术之Hadoop高可用集群 链接：https://pan.baidu.com/s/1RZYAitVMb8d1XWxIC6GBOg
提取码：YYDS
--来自百度网盘超级会员V6的分享
尚硅谷大数据技术之Zookeeper3.5.7 链接：https://pan.baidu.com/s/116jF3zyQRK07xAOiY25qIQ
提取码：YYDS
--来自百度网盘超级会员V6的分享
尚硅谷大数据技术之Zookeeper源码 链接：https://pan.baidu.com/s/1vn3ITjLCmlEwNbJmBxcFDg
提取码：YYDS
--来自百度网盘超级会员V6的分享
尚硅谷大数据技术之HadoopHA 链接：https://pan.baidu.com/s/1jo_Z0K64_L8gBDlG4q8Bag
提取码：YYDS
--来自百度网盘超级会员V6的分享
尚硅谷大数据技术之Hive3.1.3 链接：https://pan.baidu.com/s/1Wt_WbvNErlcRY9uPVRZ1Xw
提取码：YYDS
--来自百度网盘超级会员V6的分享
尚硅谷大数据技术之Hive-on-Spark调优 链接：https://pan.baidu.com/s/1Cc_BFOZSt2oNn9YyDcqkCw
提取码：YYDS
--来自百度网盘超级会员V6的分享
尚硅谷大数据技术之Hive-on-Tez调优 链接：https://pan.baidu.com/s/1WnI8KPvjqeUFVa_n9SZoVQ
提取码：YYDS
--来自百度网盘超级会员V6的分享
尚硅谷大数据技术之Hive源码及优化 链接：https://pan.baidu.com/s/1bvkGjUhk4TlXw06XxI6vqQ
提取码：YYDS
--来自百度网盘超级会员V6的分享
尚硅谷大数据技术之Hive源码编译 链接：https://pan.baidu.com/s/1vsdKaVAeyQfKb-FvgyONOg
提取码：YYDS
--来自百度网盘超级会员V6的分享
尚硅谷大数据技术之HiveSQL案例70+ 链接：https://pan.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e0237bbaf238b696a7e7dd3e04580da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/822241db0d64180d9887e28aa79c484f/" rel="bookmark">
			免费，C&#43;&#43;蓝桥杯等级考试真题--第2级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++蓝桥杯等级考试真题–第2级
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e6a1b5ecb4ec745af74a2f1e720977a/" rel="bookmark">
			剖析【C&#43;&#43;】——类和对象(下篇)——超详解——小白篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.再谈构造函数
1.1 构造函数体赋值
1.2 初始化列表
1.3 explicit 关键字
2. Static成员
2.1 概念
2.2 特性
3. 友元
3.1 友元函数
3.2 友元类
3.3总结：
4. 内部类
1.概念
2.特性
示例代码：
代码分析
3.总结
5.再次理解类和对象
1. 抽象现实生活中的实体
2. 用类描述实体
3. 实例化对象
4. 总结类和对象的关系
1.再谈构造函数 1.1 构造函数体赋值 构造函数是用来初始化对象的特殊函数。当我们创建一个对象时，编译器会自动调用构造函数来给对象的成员变量赋值。
简单理解：当你买一个新手机，打开包装，这就像调用了构造函数。手机里的默认应用程序就像成员变量的初始值。这些默认应用虽然是预装的，但我们可以再安装新的应用，这相当于构造函数体内的赋值操作。
示例代码：
class MyClass { public: int x; int y; MyClass(int a, int b) : x(a), y(b) {} // 初始化列表 }; 在上面的代码中，当我们创建一个 MyClass 对象时，比如 MyClass obj(10);，构造函数 MyClass(int value) 会被调用，x 会被赋值为 10。但是这个过程叫赋值，不叫初始化，因为我们可以在构造函数内多次赋值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e6a1b5ecb4ec745af74a2f1e720977a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4833b9e282b1d7d586fe808ab3f809dc/" rel="bookmark">
			【C&#43;&#43;】string类模拟实现：探索其内部机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💞💞 前言 hello hello~ ，这里是大耳朵土土垚~💖💖 ，欢迎大家点赞🥳🥳关注💥💥收藏🌹🌹🌹
💥个人主页：大耳朵土土垚的博客
💥 所属专栏：C++入门至进阶
这里将会不定期更新有关C++的内容，希望大家多多点赞关注收藏💖💖
目录 💞💞 前言1.string类基本框架2.string类模拟实现2.1构造函数实现✨string(const char* str)✨ string(const string&amp; s) 2.2赋值运算符重载✨ string&amp; operator=(const string&amp; s) 2.3析构函数✨ ~string() 2.4迭代器✨普通迭代器✨常量迭代器 2.5获取字符串指针✨const char* c_str() const 2.6获取string类的容量✨ size_t size() const✨ size_t capacity()const 2.7[]重载✨ char&amp; operator[](size_t pos)✨ const char&amp; operator[](size_t pos) const 2.8空间操作✨ void reserve(size_t n)✨ void resize(size_t n, char ch = '\0')✨ bool empty()const✨ void clear() 2.9尾插操作✨void push_back(char ch)✨void append(const char* str)✨+=重载 2.10在pos位置插入✨void insert(size_t pos, char ch)✨void insert(size_t pos, const char* str) 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4833b9e282b1d7d586fe808ab3f809dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6224ff9859beff3fdb6da88f6ced09c4/" rel="bookmark">
			计算机图形学入门05：投影变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.投影变换 上一章已经介绍了投影变换，就是将三维图像投影到二维平面上，而投影变换又分为正交投影(Orthographic Projection)和透视投影(Perspective Projection)。如下图：
正交投影
没有近大远小的现象，无论图形与视点距离是远是近，图形多大画出来的图形就是多大。假设相机距离拉到无限远，远近物体的大小无限接近，所以显示不同距离的物体画面显示一样大小。正交投影会通过远近裁剪面、前后裁剪面、上下裁剪面六个面确定一个可视空间，在可视空间中的物体才能被看到，被映射在近裁剪面(Near clip plane)上。
透视投影
有近大远小的现象，更接近肉眼看到的画面，应用更加常见。假设相机放在某一个点投射出一个视锥空间，在视锥空间中通过近裁剪面和远裁剪面(Far clip plane)可以裁出一个椎体空间，这个空间称为透视投影的可视空间，在可视空间里的物体被映射到近裁剪面上。
2.正交投影 2.1简单的理解 1.相机在原点，方向是-z方向，上方向是Y轴。(上一章提到的相机标准位置)
2.扔掉z轴。如下图所示，物体映射到平面上跟Z轴坐标无关(这样无法判断物体前后)。
3.可以看出只要将物体平移和缩放到[-1,1]²矩阵里。到这个矩阵为了之后方便计算。
2.2正式推导正交投影矩阵 我们想要将一个长方体[l,r]×[b,t]×[f,n]映射到标准立方体(canonical cube)([-1, 1]³)中，表示对空间的某一块进行正交投影。这个变换过程就是先平移再缩放。如下图所示：
上图中的立方，l,r表示左边界和右边界，b,t表示下边界和上边界，f,n表示远裁剪面和近裁剪面。由于相机向-z方向看去，所以离相机越近意味着z值越大，离相机越远z值越小，所以这里z值越大距离相机越近，z值越小距离相机越远。
正交投影矩阵
先平移到原点(两点相加除以2等于中心点)，然后缩放(长、宽、高变为2)。原本长方体长宽高覆盖范围分别为r-l，t-b，n-f，缩放到2，因为标准立方体-1到1直接范围是2。
合并后最终正交投影矩阵为：
3.透视投影 在推导之前先回忆下齐次坐标的性质。坐标(x,y,z,1),(xk,yk,zk,k!=0),(xz,yz,zz,z!=0)在3D中都表示同一个点(x,y,z)。例如(1,0,0,1),(2,0,0,2)都表示(1,0,0)这个点。
3.1推导透视投影矩阵思路 推导思路是将透视投影的视锥体“压扁”长方体，做正交投影。如下图所示：
在挤压过程中，要保证近裁剪面不变，z值不发生变化，远裁剪面的中心点也不发生变化。挤压完成后就变成正交投影矩阵，所以要求透视投影矩阵就变成了先求透视投影到正交投影的变换矩阵，再进行正交投影矩阵。
3.2推导透视投影矩阵 下图是透视投影的侧视图：
如上图所示要将点(x,y,z)移到与点(x’,y’,z’)一样的高度和水平宽度，需要将y移到y’，x移到x’。根据图中的相似三角形性质，可得出两者的关系：
根据齐次坐标性质，给每个分量都乘以z，得到远裁剪面上的点与近裁剪面的点映射关系：
那么得到的这个挤压后远裁剪面的点，肯定是由远裁剪面乘以某个变换矩阵得到，也就是透视投影到正交投影的变换矩阵。
然后根据矩阵相乘的性质，反推算出这个变换矩阵，只有第三行还不知道。
第三行势必跟z有关系，而在挤压过程中近裁剪面上任何的点z值都不发生变化的。而近裁剪面的z值就是n，近裁剪面矩阵乘以这个M(4x4)矩阵一定等于它自己(点坐标一样)。所以可以代入做如下处理。
根据矩阵乘法反推，因此M(4x4)矩阵第三行必须是(0,0,A,B)，A和B为自己命名。推导：x*0+y*0+A*n+B*1 = n²；
所以得到An+B = n²。
又因为在挤压过程中远裁剪面上任何的点z值也都不发生变化的。拿到远裁剪面上的中心点(0,0,f)，这个中心点在挤压前和挤压后x，y的值也不变。
所以与近裁剪面同理，将远裁剪面中心点代入处理可得。
将上面得到的关系表达式，整理计算得到A和B的值。
至此，矩阵第三行得到(0,0,n+f,-nf)，代入可得透视投影到正交投影的变换矩阵。
挤压完成变成正交投影之后，就交给正交投影矩阵完成了。
3.3透视投影矩阵 上述已经求得了透视投影到正交投影的变换矩阵，再进行正交投影矩阵，即是透视投影矩阵。(矩阵相乘从右到左应用)
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/322/">«</a>
	<span class="pagination__item pagination__item--current">323/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/324/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>