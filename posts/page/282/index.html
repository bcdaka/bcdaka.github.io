<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e51f056c200b53a43905e2ff16d8dfd1/" rel="bookmark">
			世优科技AI数字人多模态交互系统“世优波塔”正式发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 2024年6月6日，世优科技“波塔发布会”在北京举办，本次发布会上，世优科技以全新的“波塔”产品诠释了更高效、更智能、更全面的AI数字人产品及软硬件全场景解决方案，实现了世优品牌、产品和价值的全面跃迁。来自行业协会、数字产业、科研高校、新闻媒体和投资机构的众多相关负责人参加了本次活动。 发布会现场，世优科技的数字人SIA担任本次的主持人进行开场互动，向外界介绍了本次的活动流程、参会嘉宾、核心理念等，为世优科技“波塔发布会”揭开序幕。 世优科技数字人 SIA 世优科技创始人&amp;CEO纪智辉为发布会进行开场致辞，他总结了世优科技近十年的发展历程，并指出品牌未来的战略规划，他表示：“在当下这个挑战与机遇并存的时期，国家大力提倡发展以AI为代表的新质生产力，当AI领域的突飞猛进让所有人都应接不暇时，作为深耕数字人领域的科技企业，世优科技在实践中探索，让技术的创新趋势成为每个企业发展新优势的方法。” 世优科技 纪智辉 世优科技的使命旨在通过AI数字人及AIGC产品，让市场、行业、企业与用户之间产生新价值、缔造新连接，让人们能够运用AI解决问题，经过长久的发展，世优科技从品牌数字资产打造的“造人”、传播素材制作的“养人”和数字人新质生产力的“用人”环节着手，逐步解决了AI数字人在品牌传播、服务升级、营销转化方面的问题。目前世优科技已经为央视、中国移动、华为、阿里巴巴、海尔集团等世界500强在内的近1000家客户，提供数字化、智能化的产品及服务，累积打造数字人超过1000个，生态建设面向全国伙伴、全球市场，已经在多个城市及国家建立子公司或合作伙伴。 作为发布会最核心的环节，世优科技韩光明为观众们详细介绍了世优波塔的技术底层逻辑、关键性能特色及其多元化应用领域等内容，为与会者呈现了一场技术与创新的盛宴。自世优BOTA1.0首次面世以来，获得了客户广泛的青睐，在医疗就医指引、自动化带货主播、气象数字主持人等众多项目的实践与检验中，通过不断迭代优化模型算法，实现了波塔更加流畅自然的语言交流、自动化识别与响应能力，现在进化至3.0版本的波塔，逐步深化了对AI驱动的交互式数字人解决方案的理解与应用方式，打造了人工智能时代有温度的多模态人机交互界面。 世优科技 韩光明
为了能够帮客户实现“AI+大模型”端到端的应用，世优科技持续升级数字人3D表情生成算法结构与算法工程，让数字人拥有更丰富的表现力，将大模型和小模型能力相结合，搭建了功能强大且简便易用的功能搭建AGENT平台，通过“波塔”的AGENT平台，可以快速实现业务流程的搭建和实现，同时波塔开放的API平台，还能够和现有业务系统进行快速集成，经过不断地测试和应用，最终端到端响应时间在1.5-2秒，而交互正确率达到98%。波塔支持数字大屏、AI数字人一体机、PC端以及H5小程序等多种应用终端，同时支持私有化部署等集成方案，满足不同客户的需求。 目前，世优波塔主要在政府、文旅、教育、医疗、互联网等行业的企业展厅、活动展馆、办事大厅、机场地铁公共服务场所，担任前台接待、数字客服等身份，为政企客户提供更新颖、更卓越的用户服务体验。 随后的嘉宾致辞环节，中国工程院院士丁文华发表题为“数字人技术方向的探索”的演讲，他向大家介绍了数字人的来源、演变，以及未来的发展方向，丁文华表示：“元宇宙是当下热点，而数字人是开启元宇宙大门的钥匙，数字人的应用场景已经愈发广泛，以后每个人都会拥有自己的元宇宙身份。”他认为，世优科技所展现的不仅是高精度的数字人技术，更是展现了数字人的应用价值及高效率、低成本的制作工序，世优波塔将会成为企业高效发展的实用工具。 中国工程院 丁文华 中国传媒大学动画与数字艺术学院党委书记黄心渊、华为云媒体服务MetaStudio北区总经理张靖、北京启元天地网络信息科技有限公司副总经理王贝贝、点维数字文旅科技总经理肖嘉惠，分别从AI数字人在传媒、教育、医疗、文旅等行业的探索及应用，阐释了AIGC为不同行业带来全新的发展机遇，也为各企业提供了新的增长点，成为国家数字经济的重要引擎。
中国传媒大学 黄心渊（左上）、华为云 张靖（右上）、启元天地 王贝贝（左下）、点维数字文旅 肖嘉慧（右下） 在嘉宾致辞环节结束后，世优科技的蒋正浩和赵唯，围绕世优波塔、世优科技AI产品、数字人业务等方面，解答了现场观众的疑问。
世优科技 蒋正浩（左）、世优科技 赵唯（右）
在世优波塔发布会现场，中传文旅总经理冉航、摩尔普斯董事长温从寅、点维数字文旅科技总经理肖嘉惠与世优科技代表集体签约，在文体旅融合、数字人直播等行业场景，达成战略合作协议并将展开紧密合作，实现优势互补、合作共赢，共同开拓更多行业、更为智能化的服务模式与应用场景。
签约代表中传文旅总经理冉航表示：“数字人IP已成为文旅、娱乐乃至商业领域的热门词汇，它不仅代表着技术的前沿探索，更是文旅产业创新的重要驱动力，不断探索技术与艺术的融合边界，是塑造可持续发展且具有广泛影响力的数字人IP的关键所在。” 中传文旅 冉航 发布会的结尾，与会嘉宾、行业代表们聚集波塔体验区，与各应用终端的世优波塔AI数字人进行实时互动，深度体验了世优波塔产品的前沿技术与创新应用，直观领略了其在人工智能交互领域的卓越成就与无限潜能。 AI数字人应用场景的加速落地，构建了一个通向未来的道路，从众多虚拟人的齐聚诞生，到数字人智能体的出现，再到消费级AI数字人产品的推出，世优科技的波塔及其他AIGC产品与服务，将赋能行业、助力政府企业、服务个人，最终走进千家万户，让每个人都拥有独属的AI助手。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec8f4cc1b1bfbf7ac53a4f96143d7327/" rel="bookmark">
			SpringAI--使用免费API-Key和API进行配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
📚 前言
📑Spring AI简介
💬 项目配置
📚 系统功能的具体实现
💬 编写Controller控件
📚 前言
📑博客主页：@丘比特惩罚陆
💖欢迎关注：点赞收藏⭐留言✒
💬系列专栏：Java 后端
🎮 加入社区： 丘比特惩罚陆
🥇人生格言：选对方向，每走一步都是进步！
✒️欢迎大佬指正，一起学习！一起加油！
👏 希望大家能小手一动，帮忙点个赞！
📑Spring AI简介 什么是Spring AI呢，Spring AI并不是一个标准术语或现有的技术框架。"Spring"通常指的是Spring Framework，这是一个广泛使用的Java开发框架，专为构建企业级应用程序提供轻量级的依赖注入和管理工具。然而，说到Spring和AI的结合，可能是指Spring Boot与人工智能技术的集成，比如使用Spring for Machine Learning (S4ML)或Spring Cloud Stream与AI微服务相结合。
在实际中，开发者可能会用Spring Boot作为基础，构建包含机器学习模型、自然语言处理（NLP）或者其他AI组件的应用。但这并不是Spring官方项目的一部分，而是开发者利用Spring生态进行扩展和集成AI功能的例子。
简单而言，Spring AI 是AI工程师所使用的一种应用性框架，通过提供出来的API和API key来进行开发应用，所用在于使用AI应用来简化开发工序流程。
本文使用的是免费的API key进行文章的叙述（免费的API有生成限制，每天生成内容为100条为限制，使用的是ChatGPT 3.5免费非商用的API key进行讲解讲述，付费的自行获取，该文章只用于讲解Springboot项目如何使用SpringAI。）
📑 准备工作
家政服务管理平台的主要功能的结构：
一个OpenAI的key秘钥；一个可以使用的OpenAi的API地址；一个java Springboot的jdk (本项目使用的为17版本)；一个开发软件 IDEA(本项目使用的是2023年的IDEA); 一般OpenAI 的key 秘钥和API地址都是要准备好的，很多人都是卡在这一步，所以我给大家提供了一个可以使用免费共享的API key，地址如下：
GitCode - 全球开发者的开源社区,开源代码托管平台
首先先是按部就班的先是设置好自己的登录信息：
进来之后就可以看到这个界面：
提供了GPT4在内的免费的可以申请的Key,还有其他的付费的五个模型，包括GPT4o,这里就不一一赘述；
📑项目搭建
第一步，我们先试用IDEA 大家一个Springboot项目，一定要使用JDK17的，其他版本的经过测试会出现版本报错的错误；建议大家还是使用17版本以上的JDK;
第二步：选择初始的依赖项
第三部：配置pom.xml的依赖；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec8f4cc1b1bfbf7ac53a4f96143d7327/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62023f033cc0d27c9c9fe7295d51963f/" rel="bookmark">
			AI出图模糊怎么办？3个神器让你的照片变高清！最高可放大至8K
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信很多小伙伴也都知道，像素图是由若干个像素点组成的，放大后会模糊失真。
不过，由于其色彩丰富，可逼真地表现自然界景物，所以被广泛应用于照片、摄影等方面。
如果要实现图片无损放大，就需要弥补图像放大后缺失的细节。
这对程序的计算分析能力要求，是非常高的。
考虑到大家的需求，系统迷这次就推荐下这款名为Topaz photo AI的电脑软件。
我们再看一组细节对比，如下图所示，左边是PS放大的效果，中间的是另一个图片放大工具，右边是本期介绍的工具——Topaz A.I.photo 。
一、推荐的AI绘画主流工具整理
1、midjourney：https://www.midjourney.com/
2、DALL E2：DALL·E
3、Stable Diffusion：https://stablediffusionweb.com/
4、Stable Diffusion一键安装：https://www.4b3.com/document/16.html
4、Dreamstudio：beta.dreamstudio.ai/
5、Novel AI（适合二次元风格）：https://novelai.net/
方法一：Stable-diffusion放大法(2K) 我们知道，一般AI绘画的图像大小都是512x512或者512x768这样的大小。
但是这种图像清晰度太低了，稍微放大一点看都不能看，全是格子，全是锯齿。
虽然可以在生成图片的时候，点击hires.fix直接放大，但是，这个功能对显存和算力的要求都十分高，勾选之后，动不动就爆显存，显示CUDA out of Memory，运算时间还超慢。
那怎么办呢？今天就教你如何用stable-diffusion-webui自带的工具放大图片（放大到2048像素x2048以上）。
这个方法可以快速放大图片，提高分辨率，让你的图片分辨率更高，更精细。
怎么做呢？
1.首先你要安装了stable-diffusion-webui。（如果没安装的请回去安装了再来看）
2.点击Extras Tab
3.点击source 选择你要放大的图片
4.选择放大算法
建议真人使用ESRGAN_4x 来放大。
动漫人物使用 R- ESR GAN 4x来放大。
当然，其他算法也各有特点，有空大家也可以一一尝试。
5.选好放大算法之后，点击generate按钮。等待操作完成。
通常几秒到一分钟就能完成一张图片的放大。
放大之后，可以右键右侧图片保存或者点击下方文件夹图标保存。
6.我们来看看放大的效果。
以ESRGAN_4x放大算法为例。
（1）图片分辨率从512x680变成了2048*2720，放大了4倍，图片大小从474 KB变成9.5 MB
（2）对比细节
放大来看脸部好了。
原图脸部细节不多，很多模糊的地方，而且比如眼睫毛，头发尾部，都感觉一团一团黏糊糊的，再放大一点就能看到像素点了。
而放大后的图，明显头发丝，眼睫毛都能看得到一根一根的效果，看起来更真实更细节。所以放大还是有效果的。
（可以放大这张图来看看差异）
7.批量放大
刚刚演示的是single image选项卡。也就是单张图片放大，那么多张图片放大怎么办呢？
可以选择batch process，可以一次选择多张图片来放大。
Batch from directory则是放大文件夹内的所有图片。
具体的就不一一演示了，相信大家自己点开也就会了，很简单的。
好了，总结一下，今天教大家用Extra功能来放大图片。让图像画质更清晰，分辨率更高，更精细。大家都学废了吗？
方法二：使用S D插件进行放大(4k) 方法来源 觉悟之坡 虽然可以在Extra附加功能里面，给小图放大，但是感觉它的放大，只是文件的放大，图像的质量和精细度，并没有明显提高。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62023f033cc0d27c9c9fe7295d51963f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d74d6ae4a95a8d9fab85b9519787dcb5/" rel="bookmark">
			51-57 CVPR 2024 | Cam4DOcc：自动驾驶应用中仅摄像机4D占用预测基准
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		23年12月，上海交通大学、国防科技大学、北京工业大学联合发布Cam4DOcc: Benchmark for Camera-Only 4D Occupancy Forecasting in Autonomous Driving Applications。
本文提出了一种仅摄像机4D占用预测的新基准Cam4Occ，利用现有nuScenes、nuScenes-Ocuplication 和 Lyft-Level5数据集构建。同时，引入了一种新的端到端时空网络OCFNet，其接收过去连续环视摄像头图像来预测当前和未来4D占用状态。它利用多帧特征聚合模块提取3D体素特征；利用未来状态预测模块，预测未来占用和后向向心流。
实验证明，端到端时空网络OCFNet可能是仅摄像头4D占用预测最有前途的研究方向。
数据集和代码已经开源：https://github.com/haomo-ai/Cam4DOcc.
Abstract 了解周围环境的变化对于在自动驾驶应用中安全可靠地执行下游任务至关重要。最近仅使用摄像机图像作为输入的占用估计技术可以提供基于当前观测的大规模场景的密集占用表示。然而，它们大多局限于表示当前的3D空间，没有考虑周围物体沿时间轴的未来状态。为了将仅摄像机占用估计扩展到时空预测，我们提出了Cam4Occ，这是一种用于仅摄像机4D占用预测的新基准，用于评估在不久的将来周围场景变化。我们基于多个公开可用数据集构建我们的基准，包括 nuScenes、nuScenes-Ocuplication 和 Lyft-Level5，它提供了一般可移动和静态对象的时序占用状态，以及它们的 3D 后向向心流。为了通过综合比较为未来的研究建立基准，我们从不同基于摄像机感知和预测实现中引入了4种基线类型，包括静态世界占用模型、点云体素化预测、基于2D-3D实例预测以及我们新提出的端到端4D占用预测网络。此外，还提供了预设多个任务的标准化评估协议，比较4种基线在目前和未来占用估计方面的性能，以应对自动驾驶场景中感兴趣的对象。
Fig. 1: Cam4DOcc focuses on providing a novel dataset format，creating four baselines and proposing a standardized evaluation protocol for the 4D occupancy forecasting task.
I. INTRODUCTION 利用摄像头准确感知周围环境中物体的状态，对于自动驾驶汽车或机器人做出合理的下游规划和行动决策至关重要。传统的基于摄像头的物体检测方法，如语义分割以及全视分割侧重于预定义的特定物体类别，因此在识别不常见物体时效果较差。为了解决这一限制，出现了一种转向基于摄像机的占用估计，通过对特定物体分类来估计空间占用状态。该方法降低了多类任务的复杂性，强调了总体占据状态估计，提高了自动驾驶系统的可靠性和自适应性。
尽管基于摄像机的占用估计越来越受到关注，但现有的方法只能估计当前和过去的占用状态。然而，自动驾驶汽车采用的先进避碰和轨迹优化方法要求具有预测未来环境条件的能力，以确保驾驶的安全性和可靠性。有些方法提出了一些语义/实例预测算法来预测感兴趣的物体运动，但它们大多局限于2D鸟瞰(BEV)格式，只能识别特定的物体，主要是车辆类别。现有的占用率预测算法在不考虑语义的情况下，需要LiDAR点云作为必要的先验信息来感知周围的空间结构，而基于LiDAR的解决方案比摄像机的解决方案更耗费资源，成本更高。很自然地，自动驾驶的下一个重大挑战将是仅靠摄像头的4D暂用预测。该任务不仅旨在扩展以摄像机图像为输入的时间占用预测，而且还将语义/实例预测扩展到BEV格式和预定义类别之外。为此，我们提出了Cam4DOcc，如图 1 所示，这是第一个仅摄像机的4D占用预测基准，包括新的数据集格式，各种类型的基线和标准化的评估协议，以促进这一新兴领域的发展。在本基准测试中，我们通过从原始的nuScenes、nuScenes- occupancy和Lift-Level5中提取沿时间轴的连续占用变化来构建数据集。该数据集包括时序语义、实例标注，以及指示占用网络运动的3D后向向心流。此外，为了实现基于摄像机的4D占用预测，我们引入了四种基线方法，包括静态世界占用率模型、点云体素化预测、2D-3D实例预测和端到端4D占用预测网络。最后，我们提出一个标准化协议来评估这些基线方法在当前和未来占用估计中的性能。
本文的主要贡献有四个方面：
提出了第一个基于摄像机的4D占用预测基准Cam4DOcc，为未来预测工作提供了便利。利用该领域现有数据集，提出了一种新的自动驾驶场景预测数据集。为基于摄像机的4D占用预测提供了四种新基线。其中三个是现成方法的扩展。此外介绍了一种新颖的端到端4D占用预测网络OCFnet，该网络具有较强的性能，可以为未来的研究提供有价值的参考。引入了一种新的标准化评估协议，并在该协议的基础上用Cam4Occ进行了全面的实验和详细的分析。 II. RELATED WORK Occupancy prediction
Occupancy prediction占用率预测/估计是一种综合估计周围环境占用状态的新兴技术。用几何细节来表现空间，大大增强了复杂场景的表现力。MonoScene首先解决了来自摄像机图像的3D场景语义补全问题，但只考虑了前视体素。相比之下，TPVFormer代替MonoScene的Feature Line of Sight Projection，提高了基于交叉注意机制的环视占用预测的性能。UniOcc将基于体素的神经辐射场(NeRF)与占用预测相结合，实现几何和语义渲染。OpenOccupancy建立了具有高分辨率占用地面真值nuScenes-Occupancy数据集，并进一步使用不同模式提供了几个基线。OpenOcc提出了另外一种占用预测基准，并将其估计的占用用于各种任务，包括语义场景补全、3D物体检测、BEV分割和运动规划。最近，Occ3D利用遮挡推理和图像引导细化来进一步提高标注质量。与OpenOcc类似，SurroundOcc也产生密集占用标签，并利用空间注意力将2D摄像机特征重新投影回3D Volumes。
Occupancy forecasting
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d74d6ae4a95a8d9fab85b9519787dcb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba169f884ceede1f393bc8236e289aea/" rel="bookmark">
			【Java】 Java中将Set转换为List的高效方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&gt; &gt; 【痕迹】QQ+微信朋友圈和聊天记录分析工具 &gt; &gt; （1）纯Python语言实现，使用Flask后端，本地分析，不上传个人数据。 &gt; &gt; （2）内含QQ、微信聊天记录保存到本地的方法，真正实现自己数据自己管理。 &gt; &gt; （3）数据可视化分析QQ、微信聊天记录，提取某一天的聊天记录与大模型对话。 &gt; &gt; 下载地址：https://www.alipan.com/s/x6fqXe1jVg1 &gt; 基本原理 在Java中，Set和List是两种常见的集合类型，它们都实现了Collection接口。Set集合不允许存储重复的元素，而List集合可以按顺序存储元素，并且可以包含重复的元素。有时我们需要将Set集合中的数据转换为List集合，以便于排序、索引访问等操作。然而，直接转换可能会创建一个新的List实例，这在某些情况下可能不是我们想要的。
代码示例 以下是几种将Set转换为List的方法，以及相应的代码示例和注释。
示例1：使用new ArrayList&lt;&gt;(set) 这是最直接的方法，但会创建一个新的List实例。
Set set = new HashSet&lt;&gt;(); set.add("Apple"); set.add("Banana"); set.add("Cherry"); List list = new ArrayList&lt;&gt;(set); // 输出：[Apple, Banana, Cherry] System.out.println(list); 示例2：使用Collections.addAll() 这个方法不会创建新的List，而是将Set中的元素添加到已有的List中。
Set set = new HashSet&lt;&gt;(); set.add("Apple"); set.add("Banana"); set.add("Cherry"); List list = new ArrayList&lt;&gt;(); Collections.addAll(list, set.toArray()); // 输出：[Apple, Banana, Cherry] System.out.println(list); 示例3：使用Java 8的Stream API 使用Stream API可以进行更复杂的转换操作，同时保持代码的可读性。
Set set = new HashSet&lt;&gt;(); set.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba169f884ceede1f393bc8236e289aea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e666878e73e2c567b0d5642ebd07c755/" rel="bookmark">
			AI绘画ComfyUI-插件-面部修复，快速入门安装使用！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 大家好，我是程序员晓晓
这期给大家分享一个插件AI绘画 ComfyUI的——Impact Pack
ComfyUI也是隶属于Stable Diffusion的工作流形式的AI绘画工具。如果你是新手入门AI绘画，建议你先使用Stable Diffusion WebUI，新手入门使用教程可以看我的往期教程 人工智能AI绘画，Stable Diffusion保姆级教程，小白也可以掌握SD使用
这是一个综合节点，这期先介绍下这个插件中的面部修复功能
Impact Pack插件 1、下载插件
在ComfyUI管理器中安装节点，搜索Impact Pack
点击安装，然后重启，这时候右键【新建节点】可以看到多了一个【Impact节点】
2、面部细化
右键【新建节点】-【Impact节点】-【简易】-【面部细化】。
找个节点看起来很复杂，其实很简单
3、节点连接
1）VAE解码节点的图像直接与面部细化节点的图像相连
2）模型、CLIP、VAE均与大模型相连
3）正负面条件与正反关键词相连
4）【新建节点】-【Impact节点】-【检测加载器】
将检测加载器的BBox检测与面部细化的BBox检测相连
PS：这里注意下【检测加载器】需要ultralytics模型，ultralytics就是WebUI中ADetailer插件的修脸模型 ，可以直接将WebUI中的模型直接拷贝过来
模型原路径：sd-webui\models\adetailer
拷贝后路径：ComfyUI\models\ultralytics\bbox
没有ADetailer模型请扫描获取哦，直接放到ComfyUI路径下
5）【新建节点】-【Impact节点】-【SAM加载器】
将SAM加载器的SAM模型与面部细化的SAM模型相连
其它的参数默认即可
4、保存图像
将右侧的图像节点拉出一个【保存图像】
写在最后 感兴趣的小伙伴，赠送全套AIGC学习资料，包含AI绘画、AI人工智能等前沿科技教程和软件工具，具体看这里。
AIGC技术的未来发展前景广阔，随着人工智能技术的不断发展，AIGC技术也将不断提高。未来，AIGC技术将在游戏和计算领域得到更广泛的应用，使游戏和计算系统具有更高效、更智能、更灵活的特性。同时，AIGC技术也将与人工智能技术紧密结合，在更多的领域得到广泛应用，对程序员来说影响至关重要。未来，AIGC技术将继续得到提高，同时也将与人工智能技术紧密结合，在更多的领域得到广泛应用。
一、AIGC所有方向的学习路线
AIGC所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照下面的知识点去找对应的学习资源，保证自己学得较为全面。
二、AIGC必备工具
工具都帮大家整理好了，安装就可直接上手！
三、最新AIGC学习笔记
当我学到一定基础，有自己的理解能力的时候，会去阅读一些前辈整理的书籍或者手写的笔记资料，这些笔记详细记载了他们对一些技术点的理解，这些理解是比较独到，可以学到不一样的思路。
四、AIGC视频教程合集
观看全面零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
五、实战案例
纸上得来终觉浅，要学会跟着视频一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
若有侵权，请联系删除 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a168241d656a54fb3216d7c73734de58/" rel="bookmark">
			前端HTML转word文档，绝对有效！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024.4.19 更新日志：有小伙伴私信我element-ui等ui插件等复杂样式无法转换生成，考虑到
html-docx-js本身不支持大多c3样式及标签，先提供解决方法将dom转成图片插入文档中，只需要用标签盒子 包裹住 你需要生成的dom模块，给标签盒子添加类目标识，配置项中传入 drawCanvas:[' .btn' ] ，就可以生成 具体效果图结尾有。
2024.3.11 更新日志 ：允许使用class标签在html模版中使用 此前只支持行内标签修改样式 过于繁琐与不便 ，配置项中加入 className: "xxx", 当前模版的class类明即可识别使用
公司有业务需求 需要将前端页面一键导出word模版
后来找了半天只找到一个16年的插件html-docx-js（膜拜大神，但是已经无人维护了） ，使用后踩了许多坑，因为js版本兼容问题，运行都报错使用了with() 先版本不兼容，使用也比较繁琐，
最无法容忍的是如果是使用的在线图片还有跨域问题导致图片无法导出！！！
所以直接做了些优化处理 主要是对超时 错误图片处理 可以传入导出图片超时时间等等系列问题坑！！！已封装成傻瓜式一键导出插件，小伙伴可以放心食用，目前已投入公司项目中使用。
xh-htmlword
使用方法 npm install xh-htmlword
&lt;template&gt; &lt;div class="export-box" style="width: 565pt"&gt; &lt;div id="main1"&gt;&lt;/div&gt; &lt;p style="text-align: center"&gt; &lt;span style=" font-family: 宋体; font-weight: bold; color: rgb(0, 0, 0); min-height: 16pt; font-size: 16pt; " &gt;深水汴北配套管网运维日报表&lt;/span &gt; &lt;/p&gt; &lt;table style="width: 565pt; border-collapse: collapse; border: 1px solid #dddddd"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a168241d656a54fb3216d7c73734de58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/714e8dc821afc64a1695c5d2e3d46e42/" rel="bookmark">
			C&#43;&#43;第二十六弹---stack和queue的基本操作详解与模拟实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨个人主页： 熬夜学编程的小林
💗系列专栏： 【C语言详解】 【数据结构详解】【C++详解】
目录
1. stack的介绍和使用
1.1 stack的介绍
​1.2 stack的使用
1.3 stack 模拟实现
2. queue的介绍和使用
2.1 queue的介绍
2.2 queue的使用
2.3 queue的模拟实现
3. deque的简单介绍
3.1 deque的原理介绍
3.2 deque的优势
3.3 deque的缺陷
3.4 为什么选择deque作为stack和queue的底层默认容器
总结
1. stack的介绍和使用 1.1 stack的介绍 stack文档介绍https://cplusplus.com/reference/stack/stack/?kw=stack
1. stack是一种容器适配器，专门用在具有后进先出操作的上下文环境中，其中元素只能从容器的一端进行元素的插入与提取操作。
2. stack是作为容器适配器被实现的，容器适配器即是对特定类封装作为其底层的容器，并提供一组特定的成员函数来访问其元素，将特定类作为其底层的，元素特定容器的尾部(即栈顶)被压入和弹出。
3. stack的底层容器可以是任何标准的容器类模板或者一些其他特定的容器类，这些容器类应该支持以下操作：
empty：判空操作back：获取尾部元素操作push_back：尾部插入元素操作pop_back：尾部删除元素操作 4. 标准容器vector、deque、list均符合这些需求，默认情况下，如果没有为stack指定特定的底层容器，默认情况下使用deque。
1.2 stack的使用 函数说明接口说明stack()构造空的栈empty()检测stack是否为空size()返回stack中元素的个数top()返回栈顶元素的引用push()将元素val压入stack中pop() 将stack中尾部的元素弹出
代码演示：
void test_stack() { //stack&lt;int, deque&lt;int&gt;&gt; st; stack&lt;int&gt; st;//实例化栈 st.push(1);//入栈 st.push(2); st.push(3); st.push(4); cout &lt;&lt; "size() = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/714e8dc821afc64a1695c5d2e3d46e42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffa01395889bf038fc20406a884bc44c/" rel="bookmark">
			【HarmonyOS】HUAWEI DevEco Studio 下载地址汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 OpenHarmony 4.x Releases
4.1 Release4.0 Release OpenHarmony 3.x Releases
3.2.1 Release3.2 Release3.1.3 Release3.1.2 Release3.1.1 Release3.1 Release 说明 Full SDK：面向OEM厂商提供，包含了需要使用系统权限的系统接口。
Public SDK：面向应用开发者提供，不包含需要使用系统权限的系统接口。
HUAWEI DevEco Studio：OpenHarmony 应用开发推荐使用。
HUAWEI DevEco Device Tool：OpenHarmony 智能设备集成开发环境推荐使用。
4.1 Release 软件版本备注OpenHarmony4.1 ReleasePublic SDKOhos_sdk_public 4.1.7.5 (API Version 11 Release)HUAWEI DevEco Studio Windows 64位4.1 Release下载地址HUAWEI DevEco Studio MacOS Intel 芯片4.1 Release下载地址HUAWEI DevEco Studio MacOS Apple M 芯片4.1 Release下载地址HUAWEI DevEco Device Tool4.0 Release获取地址 备注：官方链接
4.0 Release 软件版本备注OpenHarmony4.0 ReleasePublic SDKOhos_sdk_public 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffa01395889bf038fc20406a884bc44c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2423566feb7f52098bb2265107cc6127/" rel="bookmark">
			四、zabbix7.0推送告警至钉钉webhook机器人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前提条件
1、zabbix服务器能够访问钉钉的服务器，具体说是能访问https://oapi.dingtalk.com/robot/send
2、钉钉的webhook是有安全要求的，我采用的是ip的方式，我的zabbix服务器在内网，我的网络出口有多个固定公网ip，所以这样做省事，其他方式也可以你自己考虑。下图是webhook机器人的配置。
二、zabbix7配置报警媒介以及消息模板配置
告警----媒介---创建媒介类型
这一步，参数里面默认的跟我下图里不一样的，按我下图修改。Key是你的webhook机器人地址里的access_token=后面的内容。
脚本内容如下
var dingding = { key: null, message: null, msgtype: "markdown", proxy: null, // 发送消息的函数 sendMessage: function () { var params = { msgtype: dingding.msgtype, markdown: { title: "网络设备告警", // 消息的标题 text: dingding.message // 消息的内容 }, }; // 钉钉的Webhook URL var url = "https://oapi.dingtalk.com/robot/send?access_token=" + dingding.key; // 创建一个新的HttpRequest对象 var request = new HttpRequest(); if (dingding.proxy) { request.setProxy(dingding.proxy); // 设置代理，如果有的话 } // 设置请求头 request.addHeader("Content-Type: application/json"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2423566feb7f52098bb2265107cc6127/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13b381adac4f14366491fa55238a1fa5/" rel="bookmark">
			【数据结构（邓俊辉）学习笔记】图05——优先级搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 0. 概述1. BAG2. ADT 0. 概述 学习下优先级搜索
1. BAG 优先级搜索是非常广义的，概况来说，无论DFS 还是BFS从逻辑上来都属于这种搜索。
回忆下什么叫搜索或者遍历，对于像图这种数据结构里的元素逐一的没有重复的也没有遗漏的对它们进行访问，在不同的应用问题里，这种访问其实最最重要的是次序，怎么确定次序？
~ 以前在初级的数据结构，比如向量或者列表为代表，那种次序取决于结构本身的，它的结构是线性的，从头到尾从左到右一个一个访问过去就可以，线性在数学里是有很多含义在里面，既可以认为它有这种前驱后继，线性还有一些意思——是否显示的可以预测的。
~ 很多问题经常可以听到这是个非线性问题，什么叫非线性问题，说穿了就是在处理这个问题的时候，几乎只能用一种边走边看的策略，不可能一眼看穿，虽然心里知道在数学上肯定是确定的，但是它不会那么显示的更不会那么简明的给出这个次序，所以大概是一种摸着石头过河，慢慢地，走一步算一步。在这样一种非线性情况下，更重要的是通过一种策略来确定一种次序，比如可行的一种策略是：遍历到第k步，已经有k个元素被访问过了，那么第k+1个是谁？如果有一种策略，根据彼时彼刻地场景，能够确定下一个是谁，那不就可以了嘛。
优先级搜索PFS中重要的当然是优先级，它大概来说是借用某一种数据结构来处理这种东西的，这种数据结构笼统叫做BAG。
就像书包一样，所有的元素（红色的）一开始都在包里面，接下来会有一个访问完了的容器，它们中间会有一根线，这个线很重要，表示是访问完了的还是没有访问的，假设已经有部分元素访问完了（蓝色的），那么现在最核心的问题就是接下来要挑谁？
~ 这个所谓的第k+1个到底是谁，如果能够确定，对它进行访问并把它挪过来。如果有这个简明的策略，可以持续的反复的不断的进行操作，这不就是一个遍历的算法嘛。
~ 实际上，所有的东西从这个方向来审视都可以化为一个复杂的那样过程，但是每次都是一个很简明的策略，它其实都是去解释BAG中所有的元素各自的优先级。这个策略变得这么简单了，于是这个问题就转化为最最重要的BAG是什么，其实不同的BAG就会导致不同的优先级分配，当然也包括选取。
概括下所谓的PFS就是用某种数据结构把这些元素组织起来并且每个元素分配一个优先级，接下来过程每次都是做一个selection，选出来并标记为visited，接下来repeat，知道BAG耗尽。
2. ADT 对一个图的pfs，方法也是从任何一个点开始，通过迭代或递归做下去，这个过程是非线性，非线性允许这些元素的priority会有所变化，所以必然有更新priority的过程，这里把更新优先级的过程使用函数对象写出来，首先初始化s状态值，while中每次都找出最高优先级元素，把它摘出来并作访问。
while怎么作？
前面两行就是update priority。
每个元素优先级如果有改变的话，只有一个机会，当有一个元素这里取s被选出并访问，有些节点会占它的光，有机会提升它的优先级，这些节点就是它的邻居。对它的每一个相邻元素这里取w取出来，更新器priUpdater策略——（this）依据当前这幅图，如果确认s刚刚被访问过，它的邻居w便有机会update，具体的update依据算法而异。
update后，接下来select 出最高优先级元素
for循环虽然看起来复杂但活做的简单，就是从一个预设的开始，对于所有UNDISCOVERED的点（BAG中的元素）进行比较并更新优先级并记下对象。
选出来后，将这个点加入到已选的BAG中
这里借助函数对象prioUpdater，使算法设计者得以根据不同的问题需求，简明地描述和实现对应的更新策略。具体地，只需重新定义prioUpdater对象即可，而不必重复实现公共部分。比如，此前的BFS搜索和DFS搜索都可按照此模式统一实现。
后面，以最小支撑树和最短路径这两个经典的图算法为例，深入介绍这一框架的具体应用。
复杂度 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39470a14ab6426190cec9201a25a857a/" rel="bookmark">
			uniapp使用webview内嵌H5的注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、描述 uniapp项目中构建app，需要内嵌H5页面，在使用webview时，遇到了以下几个问题：
内嵌H5，默认全屏显示；内嵌页面遮挡住了app的自定义tabbar组件；样式修改无效； 二、解决方案： webview-style设置的样式，针对app生效，style的定义方式兼容web；
&lt;view class="page"&gt; &lt;web-view :src="url" class="webview" allow :fullscreen="false" :webview-styles="style" :frameBorder="0" style="width: 100%; height: calc(100% - 10px)"&gt; &lt;/web-view&gt; &lt;/view&gt; const style = reactive({ width: '100%', height: '100%', bottom: '56px' }); uni.getSystemInfo({ success: (res) =&gt; { console.log(res); style.height = res.screenHeight - res.statusBarHeight - res.safeAreaInsets?.bottom - 100 + 'px'; style.bottom = res.safeAreaInsets?.bottom + 56 + 'px'; } }); 三、经验&amp;结论 关于webview的使用，除了了解相关属性，其中webview-style才对app生效，值得关注。
web-view | uni-app官网
web-view 是一个 web 浏览器组件，可以用来承载网页的容器，会自动铺满整个页面（nvue 使用需要手动指定宽高）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39470a14ab6426190cec9201a25a857a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1cf22baf63e6f5f650c5dcaed510094/" rel="bookmark">
			AI科普 | 什么是人工智能的本质？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们将以科普的角度深入探讨AI的本质，揭示其内在的基本逻辑。
我希望能够为读者提供一个简单清晰的认识，所以我摒弃晦涩的专用名词，用大白话的方式让小白也能轻松看懂，让大家更加了解这位改变世界的“魔法师”。
通过这篇文章，你将学习到如下内容：传统软件的本质是什么？人工智能的本质是什么？两者有什么优缺点？
目录
传统软件
传统软件的本质传统软件的优点传统软件的缺点 人工智能
人工智能的本质
人工智能的优点
人工智能的缺点
PART/ 01
传统软件
传统软件的本质
传统软件就是「if-then」的强逻辑，人类通过自己的生活、工作经验总结出一些有效的规则，然后让计算机自动运行这些规则。传统软件永远不可能超越人类的知识边界，因为所有规则都是人类制定的。
简单说：传统软件就是基于「规则」的强逻辑，需要人去总结规则，设定条件，然后告诉计算机怎么执行，这个过程中程序员就是上帝视角。
说了半天可能有些人还是不太理解，什么是基于规则的强逻辑，有点抽象，接下来我举个例子，下面这段就是一个基于规则的购买火车票的实例，没有考虑军人、残疾人等特殊情况：
上面这个例子程序员朋友都比较熟悉，但我相信没有编程经验的朋友也应该能看懂了。
传统软件的优点：
基于「if-then」的强逻辑，处理简单问题时，因为规则明确，结果可预期
传统软件的缺点：
无法解决复杂问题，我们人类的生活工作中充满了复杂问题，这些问题几乎不可能通过规则来解决，比如人脸识别，通过规则来识别就无法到达很好的效果。
PART/ 02
人工智能
如果要我给人工智能下一个定义，我的答案是下面这句话。
人工智能：利用计算机的算力，结合统计学、概率论、高数基础知识形成的算法，从大量数据中找出规律、归纳出特性，最后用于解决实际问题的工具。
再简单点就是：利用算力从大量数据中归纳知识、解决问题的工具。
当然人工智能出现了很多分支，比如：机器学习、深度学习、NLP、CV、大模型、多模态、自动驾驶、机器人，但这里我要以深度学习为例说一下，因为深度学习相对典型和应用普遍。
深度学习：机器从「特定的」大量数据中总结规律，归纳出某些「特定的知识」，然后将这种「知识」应用到现实场景中去解决实际问题。
人工智能总结出来的知识并不是像传统软件一样，可以直观精确地表达出来。它更像人类学习到的知识一样，比较抽象，很难表达。
好了，以上就是人工智能的本质逻辑，是不是说了一大堆，还是有少数人不理解记不住。
没关系，你就记住一句话，AI就是个"锤子"，怎么理解？
大家思考一下锤子这个工具很可能是怎么发明出来的？
古代的石锤
我猜答案大致如下：某个人或某群人在生活中遇到某个东西（比如钉子）难砸或难拔的问题，基于自己的大脑智慧，结合大量反复的尝试，发明出来的一个工具。
本质上AI和锤子一样都是人类发明出来解决问题的工具。
人工智能这种工具之所以成为全世界的热门话题，是因为它大大扩展了传统软件的能力边界。
之前有很多事情计算机是做不了的，但是现在人工智能可以做了，并且大大提高了人类的生产力。
比如使用AI写作、绘画、生成音乐、创作视频，基本在几分钟之内就完成了，如果这些工作要人亲自做的话，将会付出成倍的时间，且不一定有现在的AI创作的好。
但是不管怎么变，传统软件和人工智能都是工具，是为了解决实际问题而存在的。这点并没有变化。
人工智能的优点：
1、提高效率和生产力：AI可以自动化执行重复性和繁琐的任务，从而提高生产效率。AI的应用大大减轻了人类的工作负担，使企业能够更快速地响应市场变化。
2、优化决策过程：AI能够处理大量数据，通过机器学习和数据分析，提供更精确的预测和决策支持。这使得决策者能够基于更全面的信息做出更优的决策，降低风险并提高成功率。
3、促进创新和科研发展：AI具有强大的计算和学习能力，可以应用于科学研究、技术创新等领域。例如，在药物研发、基因编辑等方面，AI可以帮助科学家更快地找到新的突破点，推动科技进步。
人工智能的缺点：
1、目前人工智能只解决特定问题
很多科幻电影里都出现了逆天的机器人，这种电影让大家有一种感觉：人工智能好像是无所不能的。
实际情况是：现在的人工智还处在单一任务的阶段，比如：扫地用扫地机器人、开车用自动驾驶。
2、知其然，但不知所以然
目前的AI是从大量数据中归纳总结的知识，这种方式导致AI并不知道“为什么”，只关心现象或结果，不关心为什么。
比如现在火热的大模型，你问它问题的时候，其实它生成的内容都是基于上下文概率性生成下一个字，其实它并不是真正理解了你的问题和它生成的答案。
3、算法偏见：AI系统的决策往往基于训练数据和算法，如果这些数据和算法存在偏见，那么AI的决策结果也可能带有偏见。这可能导致不公平的决策，影响社会的公正性。
4、道德和伦理问题：AI的决策过程可能缺乏道德和伦理考量，导致不公平或歧视性的结果。例如，在招聘、信贷等领域，如果AI系统基于历史数据做出决策，可能会放大社会偏见和歧视。
总结
传统软件就是「if-then」的强逻辑，人类通过自己的生活、工作经验总结出一些有效的规则，然后让计算机自动运行这些规则。传统软件永远不可能超越人类的知识边界，因为所有规则都是人类制定的。
人工智能的基本原理：机器从「特定的」大量数据中总结规律，形成某些「特定的知识」，然后将这种「知识」应用到现实场景中去解决实际问题。人工智能本质上是一种工具，只能解决特定的问题，而不是什么都能做。
​
如何学习AI大模型？ 作为一名热心肠的互联网老兵，我决定把宝贵的AI知识分享给大家。 至于能学习到多少就看你的学习毅力和能力了 。我已将重要的AI大模型资料包括AI大模型入门学习思维导图、精品AI大模型学习书籍手册、视频教程、实战学习等录播视频免费分享出来。
这份完整版的大模型 AI 学习资料已经上传CSDN，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】
一、全套AGI大模型学习路线 AI大模型时代的学习之旅：从基础到前沿，掌握人工智能的核心技能！
二、640套AI大模型报告合集 这套包含640份报告的合集，涵盖了AI大模型的理论研究、技术实现、行业应用等多个方面。无论您是科研人员、工程师，还是对AI大模型感兴趣的爱好者，这套报告合集都将为您提供宝贵的信息和启示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1cf22baf63e6f5f650c5dcaed510094/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea9032cbec035f3dbed56247966bb106/" rel="bookmark">
			推荐开源项目： LetsPPT - AI智能生成PPT助手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐开源项目： LetsPPT - AI智能生成PPT助手 1、项目介绍 LetsPPT 是一个基于Java的应用，专门用于AI自动生成PPT模板，其独特的亮点在于它的标题生成功能。项目还包括一系列前后端组件，如标注系统、生成系统以及审核系统，还有配套的PHP前端页面和微信小程序登录服务。此外，项目还提供了独立的PPT生成工具PPTShow.jar，可在官方网站了解详情。
2、项目技术分析 该项目采用了纯Java编写的核心生成系统，避免了对POI库的依赖，实现了原生的PPT生成，确保了跨平台的兼容性。另外，它利用标注系统和生成后的审核系统来提高PPT的质量。前端部分虽然使用PHP实现，但已被优化以适应多种设备和浏览器，同时还实现了SEO友好的页面结构。值得一提的是，项目即将接入ChatGPT，进一步提升内容的智能化程度。
3、项目及技术应用场景 LetsPPT 可广泛应用于各类办公场景，尤其是需要快速制作演示文稿的时候，例如企业报告、教学课件、产品展示等。通过AI自动生成，用户可以高效地创建多样化且专业的PPT模板。另外，开发者也可学习其Java原生生成PPT的技术，以及如何构建一个完整的前后端交互系统。
4、项目特点 智能生成: 利用AI技术自动生成PPT模板，节省用户时间。跨平台: 不依赖于特定操作系统，可以在Windows、Linux上运行。原生PPT生成: 使用Java编写，避免了对POI库的依赖，支持2010版PPT特性。前端优化: 具备良好的多端适应性和SEO优化，提供流畅用户体验。全面系统: 包括标注、生成、审核系统，以及前后端多个子模块。开源免费: 开源代码可供学习与改进，同时提供免费的技术支持。 如果你正在寻找一个能够简化PPT制作过程、提高效率的工具，LetsPPT 绝对值得一试。立即参与项目，体验AI带来的便捷吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0d2cc14a8f9a8d2fcf82a95812dc548/" rel="bookmark">
			【MySQL】复合查询&#43;表的内外连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		复合查询+表的内外连接 1.基本查询回顾2.多表查询3.自连接4.子查询4.1单列子查询4.2多列子查询 5.在from子句中使用子查询6.合并查询7.表的内连和外连7.1内连接7.2外连接7.2.1左外连接 7.2.2右外连接 点赞👍👍收藏🌟🌟关注💖💖
你的支持是对我最大的鼓励，我们一起努力吧!😃😃
前面我们讲解的mysql表的查询都是对一张表进行查询，在实际开发中这远远不够，未来可能还有多表查询，子查询。
1.基本查询回顾 查询工资高于500或岗位为MANAGER的雇员，同时还要满足他们的姓名首字母为大写的J
下面有两种写法，都没问题
select * from emp where (sal&gt;500 or job='MANAGER') and ename like 'J%'; select * from emp where (sal&gt;500 or job='MANAGER') and 'J'=substring(ename,1,1); 按照部门号升序而雇员的工资降序排序
select * from emp order by deptno asc,sal desc; 使用年薪进行降序排序
我们看到这个表奖金这一列有的是有的，有的是没有的为null，年薪=月薪*12+奖金
，但是null不参与运算，我们前面刚学的ifnull函数这个时候就可以用上了
ifnull(val1，val2)，如果val1为null，返回val2，否则返回val1的值
select ename,sal*12+ifnull(comm,0) 年薪 from emp order by 年薪 desc; 显示工资最高的员工的名字和工作岗位
最高工资我们可以使用聚合函数做统计，但是聚合函数只是对一列的相同数据做聚合，今天还要有名字，所以单纯的做聚合是无法满足需求的，它只能最高工资是多少。名字和工作岗位显示不出来。
因此我们先找最高工资是多少。然后拿着这个最高工资去把这个人和工作岗位找到。很显然这是两句select。
但是这样写太挫了。怎么办呢，想办法把两个select查询语句合在一块写。
sql允许在一条sql内部在执行select查询，这称为子查询，先执行内部的sql然后在执行外部的sql
select ename,job,sal from emp where sal=(select max(sal) from emp); 显示工资高于平均工资的员工信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0d2cc14a8f9a8d2fcf82a95812dc548/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e47701173ea6f497db955d5f3f60e940/" rel="bookmark">
			再度牵手，制造升级 | 毅达科技IMS OS&#43;通用产品集&#43;行业套件项目正式启动！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数字化与智能制造的浪潮中，制造业企业纷纷加快转型步伐，力求通过技术创新实现生产效率与质量的双重提升。近日，广东毅达医疗科技股份有限公司（以下简称“毅达科技”）再次携手盘古信息，正式启动了IMS 数字化升级项目，引入IMS OS数垒制造操作系统、通用产品集以及电子信息行业套件，赋能毅达科技实现数智升级，驱动企业高质量发展。
01
毅达科技：医疗器械电子制造的数字化转型之旅
毅达科技成立于2001年, 是专注于医疗健康，工业控制，通信设备等定制化生产制造服务的集团企业，总部设在东莞，在北京、香港设有研发基地与营销中心。公司厂房面积10,000多平米，拥有无尘防静电生产车间及优秀的办公环境，所属业务面向全球，服务的客户中有众多世界知名企业，对产品质量及服务有严格的要求。
早在十几年前，毅达科技便积极拥抱数字化转型，陆续实施了ERP、MES等数字化项目。然而，随着市场的不断变化和技术的飞速发展，企业对于生产管理的需求也日益多样化和复杂化。为了满足企业对于更高生产效率、更低生产成本以及更优产品质量的需求，毅达科技决定再次携手盘古信息，升级全新的数字化系统，为工厂的智能化、自动化生产注入新的动力。
02
再度牵手盘古信息：全面升级 变革发展
启动会上，盘古信息交付总监潘总详细讲解了本次项目的实施内容，本次升级项目不仅是一次技术的革新，更是对工厂生产制造执行的一次全面优化和升级。通过引入盘古信息IMS OS数垒制造操作系统、IMS通用产品集以及电子信息行业套件，开启数字化转型新篇章。
IMS OS数垒制造操作系统：该平台将为毅达科技构建完善灵活、标准易用的工软技术底座，支撑企业实现多重领域数字化系统的建立、运维及升级，打造一个强大的数字化建设基座。
IMS通用产品集：包括生产管理、仓库管理、质量管理、资产管理等模块，将实现生产过程的全面数字化管理，实现生产效率与质量的全面升级。
电子信息行业套件：针对电子信息行业的特点和需求，提供针对性的工艺流程管理、数据管理等功能，满足行业对于高精度、高效率、高质量的生产要求。
03
新项目升级：实施成效 共赢未来
盘古信息销售总监温总就本次升级项目的实施成效进行了详细的说明：
更强大的技术底座：
本次项目采用了最新的技术架构，为企业提供了更强大、更稳定的技术底座：IMS OS数垒制造操作系统。企业可以依托系统处理更复杂、更大规模的生产数据，实现更高效的生产管理和决策支持。
另外，系统具有可扩展性和可定制性，能够根据企业的实际需求进行灵活调整和优化，满足企业不断发展的需求。
更全面的系统范围：
项目涵盖了生产制造的各个环节，从生产计划、物料管理到质量控制等，实现了生产过程的全面数字化管理。全面的系统范围将帮助企业实现生产过程的透明化和可追溯性，提升生产管理的整体效果。通过将各个环节紧密连接在一起，实现生产资源的优化配置和协同工作，提高生产效率和降低运营成本。
更高阶的数字管理：
系统通过开放式三级平台，产品矩阵低耦合、易集成，赋能企业实现更高阶的数字管理。系统能够自动分析生产数据，提供准确的决策支持，帮助企业快速响应市场变化并优化生产策略。
在数字化转型的道路上，盘古信息与毅达科技携手并进，深化合作，共同推进新质生产力发展。展望未来，盘古信息也将持续发挥自身的技术优势和创新能力，不断推动制造业向更高水平、更高质量、更高效益的方向发展，为构建智能制造新生态贡献更多的力量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dc8a3e2cd551fcd9600df0cfc225b76/" rel="bookmark">
			Python基础教程（十一）：数据结构汇总梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💝💝💝首先，欢迎各位来到我的博客，很高兴能够在这里和您见面！希望您在这里不仅可以有所收获，同时也能感受到一份轻松欢乐的氛围，祝你生活愉快！
💝💝💝如有需要请大家订阅我的专栏【Python系列】哟！我会定期更新相关系列的文章
💝💝💝关注！关注！！请关注！！！请大家关注下博主，您的支持是我不断创作的最大动力！！！
文章目录 引言1. 列表（List）2. 元组（Tuple）3. 字典（Dictionary）4. 集合（Set） 结论结束语 引言 在编程的世界里，数据结构是构建高效算法和软件系统的基础。Python，作为一种广泛使用的高级编程语言，提供了丰富的内置数据结构，使得处理数据变得既直观又强大。本文将深入探讨Python中的主要数据结构类型，包括列表（List）、元组（Tuple）、字典（Dictionary）和集合（Set），并通过具体案例来展示它们的应用场景。
1. 列表（List） 定义：列表是最常用的数据结构之一，它是一个有序的元素集合，可以存储任意类型的元素，并且允许重复。
特点：
可变性：列表是可变的，意味着可以在列表创建后添加、删除或修改其中的元素。索引：列表中的每个元素都有一个对应的索引，从0开始计数。 案例：假设我们需要维护一个学生名单，记录每位学生的姓名和成绩。
students = ["Alice", "Bob", "Charlie"] scores = [90, 85, 88] # 添加新学生 students.append("David") scores.append(92) # 修改某个学生的成绩 scores[1] = 87 # 删除学生 del students[0] del scores[0] # 打印当前学生名单和成绩 print(students) print(scores) 2. 元组（Tuple） 定义：元组与列表相似，但它是不可变的，一旦创建就无法更改。
特点：
不可变性：元组创建后不能被修改，这使得它在需要确保数据不变的情况下非常有用。性能：由于不可变性，元组在某些情况下比列表更节省内存，运行速度也更快。 案例：假设我们有一个坐标点集合，每个点由其x和y坐标组成。
points = [(1, 2), (3, 4), (5, 6)] # 访问元组中的元素 print(points[0]) # 输出 (1, 2) print(points[0][1]) # 输出 2 # 遍历元组集合 for x, y in points: print(f"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dc8a3e2cd551fcd9600df0cfc225b76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aca81b1f8eef7b9bf9620e56da2c5559/" rel="bookmark">
			一.iOS核心动画 - 关于图层与视图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 Core Animation听起来会让人误以为它只是用来做动画的，但是事实上它是从Layer Kit库演变而来的，其中做动画的功能只是Core Animation特性的一小部分。
Core Animation是一个复核引起，它的作用就是尽可能快地组合屏幕上不同的显示内容，这些内容被分解成独立的图层，存在一个叫做图层树的体系当中。于是这个树形成了UIKit以及在iOS应用程序当中你所能在屏幕看见的一切的基础。
介绍 在日常开发中我们对视图的概念已经比较熟悉了。一个视图就是显示在屏幕上的一个矩形块，它可以拦截点击触摸等用户输入的事件。视图在层级关系中可以嵌套，一个视图可以管理它的所有子视图的位置。
我们创建一个非常简单例子来说明视图的层级关系，代码如下：
let view = UIView(frame: CGRect(x: 100, y: 100, width: 150, height: 150)) view.backgroundColor = .red self.view.addSubview(view) let subGreenView = UIView(frame: CGRect(x: 25, y: 10, width: 50, height: 50)) subGreenView.backgroundColor = .green view.addSubview(subGreenView) let subBlueView = UIView(frame: CGRect(x: 25, y: 75, width: 50, height: 50)) subBlueView.backgroundColor = .blue view.addSubview(subBlueView) 视图显示如下，两个subView嵌套在红色view当中：
在iOS当中，所有的视图都从UIView这个基类派生出来的，UIView可以处理触摸事件，可以支持基于Core Graphics绘图，可以做仿射变换，或者简单的滑动渐变的动画。
图层CALayer在概念上和UIView类似，同样也是一些被层级关系树管理的矩形块，同样也可以用于显示图片文本或者背景颜色，同样也可以管理子图层的位置。它和UIView最大的不同就是CALayer不处理用户的交互。
UIView和CALayer的层级关系 每一个UIView都有一个CALayer实例图层，视图的职责就是创建和管理这个图层，以确保当子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应在层级关系树当中有相同的操作。
事实上这些图层CALayer才是真正用来在屏幕上显示和做动画的，UIView仅仅是对它进行了封装，并提供了可以处理用户交互的能力。
但是为什么会这样设计呢？为什么会提供两个平行的层级关系呢？
原因就在于要做职责分离，这样也可以避免许多重复代码。在iOS和Mac OS两个平台上，事件和用户交互有很多地方不同，基于多点触控的用户界面和基于鼠标键盘有着本质的区别。
绘图，布局和动画，相比之下就是类似Mac笔记本和桌面系列一样应用于iPhone和iPad触屏的概念。把这种功能的逻辑分开并应用到独立的Core Animation框架，苹果就能够在iOS和Mac OS之间共享代码，使得对苹果自己的OS开发团队和第三方开发者去开发两个平台的应用更加便捷。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aca81b1f8eef7b9bf9620e56da2c5559/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d0303575eeede2a87e01d56a3358901/" rel="bookmark">
			【全篇】C语言从入门到入土
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【全篇】C语言从入门到入土 文章目录 【全篇】C语言从入门到入土第一章 前言如何去学习，学习方法论 第二章 初识1.代码编译工具2.c程序的基础框架3.数据的表现形式变量1.要先定义后使用（变量名的定义是由自己决定的，一般倾向于顾文生义）2.那么如何命名变量名，以及命名规则3.数据类型3.1整型数3.2字符型，，ASCII码3.3浮点类型（小数）3.4 变量的存储类型1.static2.extern 4.强制转换常量1.整型常量介绍几个概念1.自加自减运算符2.三目运算符 4.输入输出4.1printf–打印4.2 scanf /扫描键盘 5.其他6.结语：编程案例——了解为主 第三章 流程控制1.if()…else… 条件语句，层层递进的关系运算符如何交换两个数的值？逻辑运算符if…else嵌套如果有三个数，如何让它从小到大排序,,,,,,,,要用到冒泡排序法，之后学习 2.switch( ) case… 并列，多分支语句2.1练习题 3.while循环控制语句3.1练习题 4.do…while5.for（）{ }6.break，，，在还没有达到临界值的情况下，提前结束循环介绍一个重要概念，，取余7.用contine提前结束本次循环 循环嵌套嵌套练习题 第四章 数组4.1如何定义一个数组1.相同的数据类型，，，关于中括号[ ]的解释2.数组如何[遍历]3.初始化的方式4.数组的各种初始化方式以及數組的大小计算（代码） 4.2编程案例1.数组初始化及逆序输出2.斐波那契数列3.冒泡排序法,面试要考滴4.简单排序法,面试题 二维数组1.什么时候要用二维数组2.怎么样定义一个二维数组3.二维数组的初始化3.1.按行列的初始化3.2.没明确行列，类似一维数组3.3.部分赋初值 4.二维数组的遍历 第五章 函数1.为什么要用函数2.函数要先定义再使用，和变量一个道理定义：抓住三要素！牢牢记住！！！！！！！！！ 3.函数的定义与调用1.定义无参数的函数2.定义有参数有返回值的函数3.定义空函数4.函数调用 4.形式参数和实际参数1.全局变量与局部变量 编程案例1.输入两个整数，要求输出最大值，用函数实现 调用过程函数调用的条件 5.函数的嵌套练习用函数嵌套来实现四个数里取得最大值 6.函数的递归（嵌套了自己）编程案例求阶乘 7.数组作为函数中的参数传递数组中的某个元素（意义不大）数组名当做函数实际参数关于数组作为函数参数的一些坑有意思的案例，关于地址（未来的指针）编程案例算出两个班级学生成绩的平均分（API） 8.二维数组作为函数的参数，他的形参怎么写？正确写法错误写法关心两点练习 9.全局变量编程案例 第六章 指针1.认识一下指针2.指针变量 = 存放地址的变量2.1如何定义一个指针变量以及如何使用指针变量2..2变量的访问方式2.3既然指针变量是存放别人地址的变量，那什么要区分类型呢 3.我们为什么要用指针3.1封装函数，实现两个数的交换3.2指针指向固定的区域 4.通过指针引用数组,重要面试4.1定义一个指针变量指向数组4.2指针增量和数组的关系4.3通过指针引用数组1.下标法2.指针法2.1偏移2.2取内容 数组名和指针的区别两种方法效率对比 编程案例1.函数封装数组初始化，遍历2.将数组中的n个元素按逆序存放，函数封装 5.指针与二维数组树立认知 小总结（嵌入式工程师笔试题会考） 6.数组指针例题 7.函数指针1.如何定义一个函数指针2.好用之处 8.指针数组1.定义，注意和数组指针的区别（面试会考）2.函数指针的使用 9.指针函数10.二级指针11.总结 第七章 字符串1.字符串的引入以及注意事项1.1字符数组，与数组差不多 2.字符串的内存存放方式及结束标志3.sizeof 与 strlen的区别4.动态开辟字符串（难点）5.几种字符串常用的API6.C语言实现断言函数assert7.字符串拼接strcat的使用及实现8.字符串比较函数strcmp使用及实现 第八章 结构体1.初识1.1为什么要用结构体1.2定义一个结构体1.3初始化一个结构体变量并引用1.4例题 2.结构体数组3.应用练习：选票系统4.结构体指针1.概念引入2.小应用1.指针在结构体数组中的偏移 5.共用体/联合体1.概念引入 6.宏定义define7.typedef 往期文章回顾:
【C语言从入门到入土】第一章前言
【C语言从入门到入土】第二章初识
【C语言从入门到入土】第三章流程控制
【C语言从入门到入土】第四章数组
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d0303575eeede2a87e01d56a3358901/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0ba67f25e092637af5e6e6d0b24a56d/" rel="bookmark">
			C语言详解（文件操作）2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hi~！这里是奋斗的小羊，很荣幸您能阅读我的文章，诚请评论指点，欢迎欢迎 ~~
💥💥个人主页：奋斗的小羊
💥💥所属专栏：C语言
🚀本系列文章为个人学习笔记，在这里撰写成文一为巩固知识，二为展示我的学习过程及理解。文笔、排版拙劣，望见谅。
目录 前言四、文件的顺序读写4.1 顺序读写函数介绍4.1.1 fputc4.1.2 fgetc4.1.3 fputs4.1.4 fgets4.1.5 fprintf4.1.6 fscanf4.1.7 sprintf（操作的不是文件）4.1.8 sscanf（操作的不是文件）4.1.9 fwrite4.1.10 fread 五、文件结束的判定5.1 被错误使用的feof5.2 文本文件读取结束5.3 二进制文件读取结束 六、文件缓冲区总结 前言 上篇文章中我们初步了解了文件的相关信息，文件的打开和关闭，以及文件的随机读写等
本篇文章将详细介绍一些文件顺序读写函数的作用、特点和用法，使我们更加方便地操作文件，还会讲到如何判定文件的结束等，内容可能有点多，请耐心看完哦
四、文件的顺序读写 4.1 顺序读写函数介绍 下面这些函数都在头文件&lt;stdio.h&gt;中定义
函数名功能适用于fgetc字符输入函数所有输入流fputc字符输出函数所有输出流fgets文本行输入函数所有输入流fputs文本行输出函数所有输出流fscanf格式化输出函数所有输入流fprintf格式化输出函数所有输出流fread二进制输入文件输入流fwrite二进制输出文件输出流 4.1.1 fputc fputc函数的原型如下：
int fputc( int ch, FILE *stream ); fputc函数的功能是：写入字符ch到给定输出流stream
ch：要写入的字符stream： 输出流 开始时在当前工程目录底下创建一个文本文档，存入数据：
运行下面的代码：
#include &lt;stdio.h&gt; int main() { //打开文件 FILE* pf = fopen("test.txt", "w"); if (pf == NULL) { perror("fopen"); return 1; } //写文件 int i = 0; for (i = 'a'; i &lt;= 'z'; i++) { //fputc函数一次只能写入一个字符 fputc(i, pf); } //关闭文件 fclose(pf); pf = NULL; return 0; } 运行上面的代码后查看文档，可以看到里面的内容已经被修改
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0ba67f25e092637af5e6e6d0b24a56d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/281/">«</a>
	<span class="pagination__item pagination__item--current">282/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/283/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>