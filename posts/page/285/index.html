<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45e888d55fd2fc66473da9842b97d948/" rel="bookmark">
			【AI】人工智能（AI）的崛起与未来展望
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人工智能（AI）的崛起与未来展望 描述一、AI的基本概念二、AI的发展历程三、AI的应用场景与代码示例四、AI在自动驾驶中的应用五、AI的未来展望 描述 随着科技的飞速发展，人工智能（AI）已经成为当今科技领域的热门话题。从智能家居、自动驾驶到医疗诊断、金融分析，AI技术正逐渐渗透到我们生活的方方面面。本文将探讨AI的基本概念、发展历程、应用场景，并通过一些Python代码示例来展示AI的实际应用，最后对AI的未来进行展望。
一、AI的基本概念 人工智能（AI）是一门涉及计算机科学、数学、心理学、哲学等多个学科的交叉科学。它旨在研究和开发能够模拟、延伸和扩展人类智能的理论、方法、技术及应用系统。简单来说，AI就是让计算机具备类似人类的感知、学习、推理、决策等能力。
二、AI的发展历程 AI的发展经历了符号主义、连接主义和深度学习等多个阶段，而当前深度学习已成为AI领域的主流技术，推动着AI在各个领域的快速发展。
三、AI的应用场景与代码示例 智能家居
智能家居是AI技术在家庭生活中的应用之一，可以通过智能设备实现家庭环境的自动化、智能化和个性化。以下是一个简单的智能家居温度控制的伪代码示例： # 智能家居温度控制伪代码 class SmartThermostat: def __init__(self, target_temperature): self.target_temperature = target_temperature self.current_temperature = None def sense_temperature(self): # 模拟获取当前温度 self.current_temperature = np.random.rand() * 30 + 15 # 假设温度在15到45摄氏度之间 return self.current_temperature def adjust_temperature(self): if self.current_temperature &lt; self.target_temperature - 2: print("Increasing temperature...") elif self.current_temperature &gt; self.target_temperature + 2: print("Decreasing temperature...") else: print("Temperature is within the desired range.") # 使用示例 thermostat = SmartThermostat(target_temperature=22) current_temp = thermostat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45e888d55fd2fc66473da9842b97d948/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/362983b48e930b0943d19342735d8f35/" rel="bookmark">
			【数据结构】详解堆排序当中的topk问题（leetcode例题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言如何理解topk问题代码逻辑代码实现 前言 Leetcode相关题目：215. 数组中的第K个最大元素
如何理解topk问题 **Top K 问题是一个经典的问题，在计算机科学中，它的目标是在一组数据中找到前 K 个最大或最小的元素。**这个问题在许多场景下都很重要，比如搜索引擎的搜索结果排名、数据分析中的热门元素筛选等。
.
在最简单的形式中，给定一个数组（或列表）和一个整数 K，Top K 问题要求返回数组中最大的 K 个元素。例如，如果数组是 [4, 2, 9, 6, 23, 12]，而 K = 3，那么答案应该是 [23, 9, 12]，因为它们是前三个最大的元素。
.
在C语言中，我们可以使用优先队列（堆）或者快速选择等算法来解决Top K问题。堆是一种特殊的树形数据结构，其中每个父节点的值都大于或等于（对于最大堆）/小于或等于（对于最小堆）其子节点的值。堆排序就是基于堆的排序方法，我们可以利用堆的特性来快速找到最大或最小的元素。
当我们第一次接触这个问题时，我们会想到的方法可能是：
将这个数组建堆，进行堆排序调整为大根堆，然后再取出栈顶的前k个元素就是最大的前k个元素；
可如果我们在这个问题的前提下，再加入几个限制条件：例如
1.改变查找的数据个数——例如：在七千万个数据中找；
2.我们限制程序在执行时的内存空间——让你在1MB的空间里去找这七千万个数据中最大的前十个；
在这两个限制下，我们再去直接使用堆排序是不现实的，所以我们需要用一种更巧妙地方式，但代码的本质上仍然不离开堆排序；
代码逻辑 对于Top K问题，我们首先创建一个最大堆（或最小堆），然后依次将数组中的元素插入堆中。由于堆的性质，每次插入都会保证堆顶元素是最大的。当我们插入 K 个元素后，堆顶的 K 个元素就是我们想要的结果。如果数组中有多个相同的最大元素，堆可能包含多个相同的元素，但这不影响找到前 K 个最大元素。
如果你需要找到最小的 K 个元素，只需在创建堆时使用最小堆即可 解决Top K问题的常见方法主要有以下几种：
. . . .1.堆排序（Heap-based method）：这是最常见的方法，使用最大堆（或最小堆）来存储前 K 个元素。首先将所有元素插入堆中，保持堆的性质，然后每次从堆顶取出最大（或最小）元素，将其与数组末尾的元素交换，同时减小堆的大小。重复此过程直到堆的大小为 K。这种方法的时间复杂度为 O(N log K)，空间复杂度为 O(K)。
. . . .2.快速选择（QuickSelect）：这是一种基于分治的随机化算法，适用于大规模数据。基本思想是选取一个“随机”点，然后根据该点将数组分为两部分，使得左边的所有元素都小于或等于该点，右边的所有元素都大于该点。如果点恰好是第 K 大（或小）的元素，那么就找到了答案。否则，根据点的位置在左子数组或右子数组中递归查找。快速选择的平均时间复杂度为 O(N)，但最坏情况下为 O(N^2)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/362983b48e930b0943d19342735d8f35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29876ae8d603e7e1cb1b23c261118372/" rel="bookmark">
			C&#43;&#43;必修：探索C&#43;&#43;的内存管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨✨ 欢迎大家来到贝蒂大讲堂✨✨
🎈🎈养成好习惯，先赞后看哦~🎈🎈
所属专栏：C++学习
贝蒂的主页：Betty’s blog
1. C/C++的内存分布 我们首先来看一段代码及其相关问题
int globalVar = 1; static int staticGlobalVar = 1; void Test() { static int staticVar = 1; int localVar = 1; int num1[10] = { 1, 2, 3, 4 }; char char2[] = "abcd"; const char* pChar3 = "abcd"; int* ptr1 = (int*)malloc(sizeof(int) * 4); int* ptr2 = (int*)calloc(4, sizeof(int)); int* ptr3 = (int*)realloc(ptr2, sizeof(int) * 4); free(ptr1); free(ptr3); } 选择题：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29876ae8d603e7e1cb1b23c261118372/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0676b2152270cf7f9890ed30eb8900f7/" rel="bookmark">
			Navicat导入json文件（json文件数据导入到MySQL表中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		天行健，君子以自强不息；地势坤，君子以厚德载物。
每个人都有惰性，但不断学习是好好生活的根本，共勉！
文章均为学习整理笔记，分享记录为主，如有错误请指正，共同学习进步。
文章目录 一、介绍二、准备工作1. 工具2. 建表3. Json文件 三、JSON文件数据导入MySQL表1. 导入文件入口2. 文件类型选择3. 添加文件4. 分割符选择5. 附加选项定义6. 目标表的选择7. 确认字段8. 导入模式选择9. 开始导入10. 导入结果11. 查看表数据 四、注意事项1. 数据字段的数量2. 数据字段值的类型3. 数据字段值的取值范围 急需使用可直接跳过一、介绍、二、准备工作，直接看第三章三、导入json文件数据到MySQL表
一、介绍 如何使用json文件将数据导入到MySQL数据库中的表里？
Excel表格等文件的数据通过java或者python等语言读取后生成一个json文件，然后想要将文件中的数据写入到MySQL表中
二、准备工作 1. 工具 需要使用含有导入功能的MySQL数据库可视化工具，功能强大的Navicat具有导入多种类型的数据文件到表中的功能。其他的可视化工具也有，但目前试了两个好像都不是很好用。如果有好用的工具可以评论区分享一下。
推荐使用Navicat，虽然付费但功能强大，当然也可以参考文章进行免费试用
Navicat下载安装使用
navicat工具视图
2. 建表 创建一个表，用于json文件导入
MySQL数据库中需要先创建一个满足json文件中字段的表
表名：tb_json_data_import
建表语句
CREATE TABLE `tb_json_data_import` ( `id` INTEGER UNSIGNED AUTO_INCREMENT, `uuid` VARCHAR(300) UNIQUE , `user_name` VARCHAR(300), `age` INTEGER, `addr` VARCHAR(300), PRIMARY KEY (`id`) ); 如何建表
查询–&gt;新建查询–&gt;输入建表语句–&gt;运行
运行后刷新左侧数据库，新建的表出现，双击点开，表如下
3. Json文件 准备一个json文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0676b2152270cf7f9890ed30eb8900f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/635f2e3e22603cd97c20071838142243/" rel="bookmark">
			【Activiti7系列】基于Spring Security的Activiti7工作流管理系统简介及实现（附源码）（下篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：后端小肥肠
上篇：【Activiti7系列】基于Spring Security的Activiti7工作流管理系统简介及实现（上篇）_spring security activiti7-CSDN博客
目录
1.前言
2. 核心代码
2.1. 流程定义模型管理
2.1.1. 新增流程定义模型数据
2.1.2. 通过流程定义模型id部署流程定义
2.1.3. 导出流程定义模型zip压缩包
2.2. 流程定义管理
2.2.1. 更新流程状态：激活（启动）或者挂起（暂停）
2.2.2. 导出流程定义文件（xml,png)
2.2.3. 上传zip、bpmn、xml后缀的文件来进行部署流程定义
2.3. 流程配置管理
2.4. 流程实例管理
2.4.1. 提交申请，启动流程实例
2.4.2. 撤回申请
2.4.3. 挂起或激活流程实例
2.4.4. 通过流程实例id获取历史流程图
2.4.5. 通过流程实例id获取任务办理历史记录
2.5. 任务管理
2.5.1. 查询当前用户的待办任务
2.5.2. 获取目标节点（下一个节点）
2.5.3. 完成任务
2.5.4. 获取历史任务节点，用于驳回功能
2.5.5. 驳回历史节点
2.6. 请假申请管理
3. 源码地址
4. 结语
1.前言 在《基于Spring Security的Activiti7工作流管理系统简介及实现（上篇）》中，向大家展示了工作流管理系统的功能界面及模块，具体应用场景，在本文中将会讲解该工作流管理系统实现的具体技术细节及核心代码。
本文面向人群为有工作流基础的后端人员，如对您有帮助请三连支持一下小肥肠~
2. 核心代码 本章只做代码简介（部分代码，简单的crud不介绍）及核心代码讲解，文末会提供源代码链接（仅后端）。
2.1. 流程定义模型管理 流程定义模型管理对应前端的模型管理界面，相关接口包括新增流程定义模型数据、条件分页查询流程定义模型数据、通过流程定义模型id部署流程定义、导出流程定义模型zip压缩包、删除流程定义模型。
2.1.1. 新增流程定义模型数据 public Result add(ModelAddREQ req) throws Exception { /*String name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/635f2e3e22603cd97c20071838142243/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bff982c19246020042fa23589f907944/" rel="bookmark">
			GO语言 环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. ide GoLand 下载地址
感谢您下载GoLand！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abaae9489e547751e7a5ff70f516430b/" rel="bookmark">
			自动驾驶跟驰仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		联合仿真需求分析报告
一、项目背景 随着汽车技术的快速发展，自动驾驶和智能网联汽车已成为行业发展的重要趋势。为确保自动驾驶车辆在复杂交通环境中的安全性和可靠性，进行联合仿真测试显得尤为重要。本报告旨在明确联合仿真的具体需求，为后续仿真测试提供指导。
二、仿真目标 验证自动驾驶车辆在单向三车道高速公路（包括入口匝道、专用车道入口、普通直路、专用车道出口、出口匝道）中的行驶性能。测试自动驾驶车辆与网联车辆（CAV）及传统人驾驶车辆（HDV）的交互能力。评估自动驾驶车辆在不同交通密度和天气条件下的适应性。 三、仿真场景 场景设置：单向三车道高速公路，包含入口匝道、专用车道入口、普通直路、专用车道出口、出口匝道等典型路段。车辆类型：自动驾驶车辆（主车）、网联自动驾驶车辆（CAV）、传统人驾驶车辆（HDV）。交通流量：根据实际需求设定不同交通密度，模拟不同时段和路段的交通状况。天气条件：包括晴天、雨天、雾天等多种天气状况，以测试自动驾驶车辆在不同天气下的适应性。 四、仿真需求 车辆模型： 自动驾驶车辆（主车）：采用驾驶座舱控制，具备完整的自动驾驶功能。网联自动驾驶车辆（CAV）：采用CACC（协同自适应巡航控制）模型进行跟驰，LC2013模型进行换道。传统人驾驶车辆（HDV）：采用IDM（智能驾驶员模型）进行跟驰，LC2013模型进行换道。HDV的IDM模型参数可根据需要加入随机值，以模拟人类驾驶的多样性。交互能力： 自动驾驶车辆需具备与网联车辆（CAV）的通信能力，实现信息共享和协同驾驶。自动驾驶车辆需能够识别并响应传统人驾驶车辆（HDV）的驾驶行为，确保安全交互。数据采集： 采集每辆车的速度、位置、加速度等实时数据，用于后续分析和评估。记录仿真过程中的交通事件（如碰撞、换道等），以便分析自动驾驶车辆的决策和响应能力。仿真软件： 使用SUMO（Simulation of Urban MObility）等成熟的仿真软件构建仿真环境。自动驾驶车辆的控制算法和决策逻辑需在仿真环境中进行集成和验证。 五、仿真流程 确定仿真场景和车辆类型。配置仿真软件并构建仿真环境。导入车辆模型和交通流量数据。运行仿真并采集数据。分析仿真结果并评估自动驾驶车辆的性能。 六、仿真流程图 确定仿真目标 识别并明确仿真的主要目的和目标。设定仿真的关键性能指标（KPIs）。定义仿真范围 确定仿真的系统边界。识别并包括所有必要的组件、交互和约束。数据收集 收集系统输入数据，如初始条件、参数设置等。验证和清理数据以确保准确性。建立仿真模型 选择合适的仿真软件或工具。根据系统特性和仿真目标，建立数学模型或物理模型。设置模型参数和初始条件。模型验证 通过与已知数据或实验结果进行比较，验证模型的准确性。进行敏感性分析，确定模型参数对输出的影响。运行仿真 设置仿真运行的时间步长、迭代次数等参数。启动仿真并监控其进程。收集仿真输出数据，如系统状态、性能指标等。结果分析 分析仿真结果，识别系统中的关键问题和趋势。使用统计方法、可视化工具等对数据进行处理和分析。报告编写 编写仿真报告，总结仿真过程、结果和发现。提供对仿真结果的解释和讨论。决策支持 使用仿真结果来支持决策制定。评估不同策略或方案的效果和可行性。迭代优化 根据仿真结果和反馈，调整模型参数或改进模型结构。重复运行仿真以验证改进的有效性。模型维护 定期更新和维护仿真模型，以反映系统变化和新数据。记录模型变更和版本信息。知识转移与培训 将仿真知识和经验转移给团队成员或利益相关者。提供必要的培训和支持，以确保仿真活动的可持续性。 模型部分代码示例（以SUMO和Python为例） 由于SUMO的模型配置通常通过XML文件或SUMO的Python API进行，以下是一个简化的Python代码示例，用于设置车辆类型和模型：
import sumolib # SUMO的Python库 # 假设已经有一个配置好的SUMO网络文件network.xml net = sumolib.net.readNet("network.xml") # 创建一个车辆类型列表，包含CAV和HDV vehicle_types = [ sumolib.vehicle.VehicleType(id="CAV", carFollowModel="CACC", lcModel="LC2013"), sumolib.vehicle.VehicleType(id="HDV", carFollowModel="IDM", lcModel="LC2013", # 这里可以添加IDM模型的参数修改，包括随机值 parameter={"someIDMParam": "valueWithRandomness"}) ] # 将车辆类型添加到SUMO网络中 for vt in vehicle_types: net.addVehicleType(vt) # 假设已经有一个配置好的车辆投放文件routes.rou.xml # 使用SUMO命令行工具加载网络、车辆投放和车辆类型，并运行仿真 # 注意：这里只是一个示例命令，实际使用时需要根据你的SUMO安装和配置进行调整 sumo_cmd = ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abaae9489e547751e7a5ff70f516430b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64cb65d097ac531e6c17991d89f65201/" rel="bookmark">
			为什么选择海外服务器？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如何选择跨境电商服务器：详细指南 选择合适的服务器是跨境电商企业成功的基础。服务器的性能和稳定性直接影响着网站的访问速度、用户体验和安全性，进而影响着企业的销量和利润。那么，跨境电商企业该如何选择服务器呢？
​​​​​​​
1. 确定目标客户群 首先，要明确目标客户群所在地区。跨境电商面向的是全球用户，不同地区的客户对网站的访问速度要求不同。因此，在选择服务器时，要优先考虑目标客户群所在的地区，尽量选择离他们最近的机房。例如，如果主要面向欧美客户，可以选择美国或欧洲的服务器；如果主要面向东南亚客户，可以选择香港或新加坡的服务器。
2. 评估网站需求 根据网站的规模、流量和功能需求，选择合适的服务器配置。服务器的配置主要包括CPU、内存、硬盘和带宽等。
CPU：是服务器的“大脑”，负责处理数据。对于流量较大的网站，需要选择CPU性能较高的服务器。内存：是服务器的“工作台”，用于存储数据和程序。内存越大，可以同时处理的任务越多。硬盘：用于存储网站数据。硬盘的读写速度会影响网站的加载速度。带宽：是服务器与互联网的连接速度。带宽越大，可以同时为更多的用户提供服务。 3. 选择可靠的服务商 选择一家可靠的服务商也非常重要。服务商的口碑、技术实力和售后服务都会影响服务器的性能和稳定性。
调查服务商的口碑：可以阅读其他用户的评价，了解服务商的信誉和服务质量。评估服务商的技术实力：了解服务商的机房设施、网络线路和技术团队等情况。考察服务商的售后服务：了解服务商的响应速度和解决问题的能力。 4. 综合考虑性价比 在选择服务器时，要综合考虑价格和性能，选择性价比最高的方案。不要盲目追求高配置，也不要为了节省成本而选择低配服务器。
5. 其他注意事项 除了以上几点，在选择跨境电商服务器时，还需要注意以下几点：
数据安全：选择提供安全防护措施的服务商，例如防火墙、防病毒软件和数据备份等。可扩展性：随着业务的增长，可能需要升级服务器配置。选择可扩展性好的服务器，可以避免后期更换服务器的麻烦。售后服务：选择提供完善售后服务的服务商，以便在出现问题时及时得到帮助。 总而言之，选择跨境电商服务器需要综合考虑多方面因素，不能只看价格或配置。选择合适的服务器，可以为网站的成功运营奠定良好的基础。
以下是一些额外的建议： 使用CDN（内容分发网络）可以加速网站的访问速度。CDN可以将网站内容缓存到全球各地的节点，使客户可以从离他们最近的节点获取内容。定期监控服务器性能，及时发现并解决问题。对网站进行安全扫描，发现并修复安全漏洞。 希望这些信息能帮助您选择合适的跨境电商服务器。
请随时联系我们的商务（tg：@baixueku）进行咨询。
详情前往网站： 智开云服务器总代理 | 阿里云国际 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca4fa82c13188faea5402141f8b67f8e/" rel="bookmark">
			2024年高考作文考人工智能，人工智能写作文能否得高分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 众所周知，今年全国一卷考的是人工智能，那么，我们来测试一下，国内几家厉害的人工智能他们的作答情况，以及能取得多少高分呢。由于篇幅有限，我这里只测试一个高考真题，我们这里用百度的文心一言和科大讯飞的讯飞大模型，本测试结果仅供参考，无评价好坏之分。
2024高考作文 1.1 全国甲卷 试题内容：阅读下面的材料，根据要求写作。（60分）
每个人都要学习与他人相处。有时，我们为避免冲突而不愿表达自己的想法。其实，坦诚交流才有可能迎来真正的相遇。这引发了你怎样的联想和思考？请写一篇文章。
要求：选准角度，确定立意，明确文体，自拟标题；不要套作，不得抄袭；不得泄露个人信息；不少于800字。
1.2 新课标I卷 试题内容：阅读下面的材料，根据要求写作。（60分）
随着互联网的普及、人工智能的应用，越来越多的问题能很快得到答案。那么，我们的问题是否会越来越少？
以上材料引发了你怎样的联想和思考？请写一篇文章。
要求：选准角度，确定立意，明确文体，自拟标题；不要套作，不得抄袭；不得泄露个人信息；不少于800字。
1.3 新课标II卷 试题内容：阅读下面的材料，根据要求写作。（60分）
本试卷现代文阅读I提到，长久以来，人们只能看到月球固定朝向地球的一面，“嫦娥四号”探月任务揭开了月背的神秘面纱；随着“天问一号”飞离地球，航天人的目光又投向遥远的深空…… 正如人类的太空之旅，我们每个人也都在不断抵达未知之境。这引发了你怎样的联想与思考？请写一篇文章。
要求：选准角度，确定立意，明确文体，自拟标题；不要套作，不得抄袭；不得泄露个人信息；不少于800字。
文心一言 我们先来看看文心一言的作答情况：
互联网时代：问题的消解与再生 随着互联网的深入普及和人工智能技术的迅猛发展，我们似乎进入了一个信息极速获取的时代。在这个时代里，无论我们遇到什么问题，只需在搜索引擎中输入关键词，便能迅速找到答案。这种便捷性使得许多人乐观地认为，随着技术的进步，我们面临的问题将会越来越少。然而，事实是否真的如此呢？
在互联网和人工智能的助力下，我们确实能够更快速地解决某些问题。比如，学术问题可以通过在线数据库迅速查找相关资料；生活问题可以通过各种在线服务平台得到解答。这种高效的信息获取方式，无疑提升了我们解决问题的速度和效率。但与此同时，我们也应看到，这种便捷性并没有减少问题的总量，反而在某种程度上激发了更多新问题的产生。
首先，互联网的普及使得信息传播速度大大加快，但也带来了信息过载的问题。在海量的信息中筛选出有价值的信息，本身就是一个新的挑战。此外，随着技术的不断进步，新的技术问题和挑战也随之涌现。例如，人工智能技术的发展就带来了数据安全、隐私保护等一系列新问题。
其次，虽然互联网和人工智能为我们提供了便捷的信息获取方式，但这并不意味着所有问题都能通过搜索来解决。很多深层次、复杂的问题，如心理健康、人际关系、职业规划等，仍然需要专业的指导和个人的深入思考。这些问题往往不是简单的信息检索所能解决的。
再者，技术的快速发展也在不断地改变我们的生活方式和思维模式。在这个过程中，人们可能会遇到更多的适应性问题，比如如何平衡虚拟世界与现实世界的关系，如何在高度信息化的社会中保持独立思考等。
因此，虽然互联网和人工智能技术为我们提供了便捷的信息获取方式，但这并不意味着我们面临的问题会越来越少。相反，随着技术的发展，我们可能会面临更多元化、更复杂的问题。这就需要我们不断学习、不断进步，以适应这个快速发展的时代。
在这个信息爆炸的时代，我们应该学会如何有效地利用互联网和人工智能技术，同时也要保持对问题的敏感性和解决问题的主动性。只有这样，我们才能在享受技术带来的便利的同时，不断提升自己解决问题的能力，以应对这个多变世界的挑战。
综上所述，互联网和人工智能技术的普及并没有减少我们面临的问题，反而带来了新的挑战。我们应该正视这些挑战，以积极的态度去适应和解决它们，从而在这个信息化的社会中不断成长和进步。
评分 我们这里选用同一家的智能评分系统，由于不同家的智能评分系统评分维度不同，所以最终评分不能决定文章的好坏。
讯飞星火大模型 我们刚刚看到了文心一言的答题情况，我们看看科大讯飞的大模型作答情况：
互联网和人工智能：问题的答案，还是更多问题的开始？ 随着信息时代的飞速发展，互联网和人工智能逐渐渗透到我们生活的方方面面。如今，获取信息和知识变得前所未有的便捷，只需轻轻一点或一句简单的语音指令，我们便能获得所需答案。这无疑大幅提高了效率，增加了个体的学习能力。然而，这样的便利也引发了一个有趣的问题：在快速得到答案的同时，我们面临的问题是否会变少呢？
要回答这个问题，首先需要理解“问题”的本质及其在人类知识结构中的角色。问题不仅仅是一个待解答的疑问，更是推动人类思考、探索和进步的动力。在传统学习模式中，问题往往被视为学习的起点，引发一系列的思考、实验和研究，从而达到解决问题的目的。在这个过程中，新的问题不断产生，形成一系列更深层次的探究。从这个角度来看，问题实际上是知识发展的必要条件，是激发创新的重要因素。
互联网和人工智能提供的快速答案功能，显著降低了获取知识的时间和劳动成本。学生不必花费大量时间在图书馆筛选资料，专业人士也能迅速了解与工作相关的最新进展。这种速度和便捷性在一定程度上减少了因寻找答案而产生的分叉问题。例如，一个简单的在线搜索可以快速解答语法疑问，避免了长时间的翻阅语法书籍。
然而，互联网和人工智能的答案并非完美无缺。它们提供的信息往往是碎片化的，缺乏深度和系统性。这种表面化的答案可能隐藏了更深层次的问题和复杂性，从而阻碍我们对知识的全面理解和掌握。此外，容易获得的答案可能削弱了我们的问题解决能力。面对挑战时，我们可能习惯于立即寻求外部帮助，而不是通过自己的思考来找到解决方案。
更重要的是，互联网和人工智能本身也在持续产生新的问题。它们的高效运作背后隐藏着技术、伦理、法律等多方面的问题——智能算法是否侵犯隐私？自动化将如何影响就业市场？这些问题不仅涉及技术领域，还紧密联系着社会、经济和文化等多个层面。因此，虽然互联网和人工智能为我们提供了海量的便捷答案，但同时也催生了更为复杂和多元的新问题。
互联网和人工智能的确为我们提供了快速找到答案的便利，但这并不意味着我们面临的问题会减少。相反，这些问题和答案的交互作用实际上促进了更多新问题的出现，这些问题进一步推动了知识的深入探索和科技的持续发展。因此，我们应该更加深刻地认识到问题的价值，利用互联网和人工智能的便利，不断提升自我，同时保持对新问题的敏感和好奇心，以更加开放和创新的心态面对这个不断变化的世界。
评分 总结 总的来说，两家大模型回答的还可以，不过，中规中矩，没有感情，在这方面，人类还是高于人工智能的，也只有人才能写出真情实感的好文章，高考结束了，就等放榜了，预祝大家取得好成绩。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b910286b6df8b08713761455b8fc5f0b/" rel="bookmark">
			套餐信息分页查询——后端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.交互逻辑
页面发送ajax请求，将分页查询参数（page, pageSize, name）提交到服务端，获取分页数据；页面发送请求，请求服务端进行图片下载，用于页面图片展示。
2.代码逻辑
需要注意，Setmeal中只有套餐的Id，没有套餐的名称，因此，在返回分页数据的时候，要额外把套餐的名称带上，即用封装的对象SetmealDto。
/** * 套餐分页查询 * @param page * @param pageSize * @param name * @return */ @GetMapping("/page") public R&lt;Page&gt; page(int page, int pageSize, String name){ //分页构造器对象 Page&lt;Setmeal&gt; pageInfo = new Page&lt;&gt;(page, pageSize); Page&lt;SetmealDto&gt; dtoPage = new Page&lt;&gt;(); LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;(); //添加查询条件, 根据name进行模糊查询 queryWrapper.like(name != null, Setmeal::getName, name); //添加排序条件 queryWrapper.orderByDesc(Setmeal::getUpdateTime); setmealService.page(pageInfo, queryWrapper); //进行对象的拷贝 BeanUtils.copyProperties(pageInfo, dtoPage, "records"); List&lt;Setmeal&gt; records = pageInfo.getRecords(); List&lt;SetmealDto&gt; list = records.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b910286b6df8b08713761455b8fc5f0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a54bc9026e9d908aee2f4a789846e21/" rel="bookmark">
			数据仓库技术及应用（Hive索引）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.概述 将数据库表中的一列或者多列的值进行排序存储；用索引表记录字段的索引和偏移量，方便查询索引列时能快速定位到对应的行记录；索引类似于图书的目录，可以根据目录页码快速定位。 2.执行流程 （1）不使用索引时，hive执行流程
SELECT * FROM test_table WHERE key=‘xx’ （2）使用索引时，hive执行流程
3.使用场景 对于查询中经常被当做WHERE子句的判断条件的列；值不经常更新的列或者值是几个枚举值的列。Hive3.0开始，索引将被移除，但提供了与索引类似的功能： 使用带有自动重写的物化视图 ；选择列式的文件格式（ORC），它们可以进行选择性扫描，甚至可以跳过整个文件块 。
4.Hive索引与分区、分桶的区别！ Hive索引与分区、分桶都是Hive的优化手段；索引时使用额外的存储空间换取查询时间；分区是将大的数据库按分区字段拆分成多个小数据库，对应HDFS上不同的文件夹；分桶是按照列的哈希函数进行分隔，对应于HDFS不同的文件。 5.索引操作 （1）创建索引 #其中ROW FORMAT,STORED AS,STORED BY, LOCATION, PARTITION BY 等子句参照创建表的语法 #AS子句指定了索引处理器，Hive内置的索引处理器有CompactIndexHandler和BitMap #WITH DEFERRED REBUILD延迟重建标识，指定该处，新索引将呈现空白状态，在任何时间用户都可 #以进行第一次索引创建或者使用ALTER INDEX对索引进行重建。 #IN TABLE 指定索引表的名称，可选值，如果不指定，Hive会默认生成索引表名。 CREATE INDEX index_name ON TABLE base_table_name(col_name,…) AS ‘index.handler.class.name’ [WITH DEFERRED REBUILD] [IDXPROPERTIES(property_name=property_value,…)] [IN TABLE index_table_name] [PARTITION BY (col_name,…)] [ [ROW FORMAT …] STORED AS … | STORED BY… ] [LOCATION hdfs_path] [TBLPROPERTIES(…)] [COMMENT “index comment”]; （2）重建索引 #使用ALTER INDEX命令可以重建索引，该语句主要用于重建使用“WITH DEFERRED REBUILD”子句创建的索引，或 #者重建已经创建的索引，如果制定了分区，则仅重新构建指定分区的索引 ALTER INDEX index_name ON table_name [PARTITION partition_spec] REBUILD; （3）显示索引/删除索引 #索引创建后，可以使用SHOW INDEX命令查看索引 SHOW [FORMATTED] (INDEX|INDEXES) ON table_with_index [(FROM|IN)db_name]; #删除索引可以使用DROP INDEX语句 DROP INDEX [IF EXISTS] index_name ON table_name; 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a54bc9026e9d908aee2f4a789846e21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78e0cb0304befa174d448fc23b7f8285/" rel="bookmark">
			【大数据·hadoop】在hdfs上运行shell基本常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、准备工作 1.1启动Hadoop服务 参见Hadoop在ubuntu虚拟机上的伪分布式部署|保姆级教程的4.7节
二、HDFS常用命令 接着，就愉快地在刚刚的命令行里敲命令啦
1.显示hdfs目录结构 hadoop fs -ls -R / hadoop fs: 这是Hadoop文件系统命令行的一部分，用于与HDFS进行交互。-ls: 类似于UNIX/Linux中的 ls 命令，用于列出目录内容。-R: 这个参数使得 ls 命令递归地列出所有目录和子目录的内容。没有这个参数，ls 命令只会列出指定目录的直接内容。/: 指定要列出内容的目录路径。在这个命令中，它是根目录。
🌸Tips：这里的Hadoop的目录结构，是指hdfs文件系统的目录结构，而非hadoop这个软件所在的目录结构
根据运行结果我们可以得到以下信息：
1. 目录和权限:
/tmp: 这是一个临时目录，权限设置为 drwxrwx---，表明目录的拥有者（hadoop）和其所在的组（supergroup）具有读、写、执行权限，而其他用户没有任何权限。/tmp/hadoop-yarn: 这是存放与Hadoop YARN（资源管理器）相关的临时数据的目录，权限同上。/tmp/hadoop-yarn/staging: 用于存放YARN作业的准备阶段数据的目录，权限同上。/tmp/hadoop-yarn/staging/history: 存放YARN作业历史信息的目录，权限同上。/tmp/hadoop-yarn/staging/history/done: 存放已完成的YARN作业历史信息的目录，权限同上。/tmp/hadoop-yarn/staging/history/done_intermediate: 存放正在处理中的YARN作业历史信息的目录，权限设置为 drwxrwxrwt。这里的 t 权限（粘滞位）表明只有文件的拥有者、目录的拥有者或超级用户才能删除或重命名目录中的文件。 2. 所有者和组:
所有列出的目录均由用户 hadoop 拥有，并且属于 supergroup 组。在Hadoop生态系统中，supergroup 是一个默认的用户组，通常与HDFS的超级用户（即 Hadoop 的管理员账户，类似于 Unix 系统中的 root 用户）关联。超级用户和属于 supergroup 组的用户通常有着对HDFS上所有文件和目录的全权限，这包括读取、写入和执行权限。
3. 大小:所有目录的大小均为 0，这是因为在大多数文件系统中，目录不占用可见的存储空间，或者说目录的大小表示的是目录结构本身的大小，而不是其中包含的文件大小。 2.在hdfs指定目录内创建新目录 hadoop fs -mkdir /yaoyao 3.删除hdfs上指定文件夹（包含子目录等） hadoop fs -rm -r /yaoyao 4.在hdfs上创建文件和编辑❌ 其实我一开始就完全把HDFS当作像windows和linux那样的文件操作系统了，其实忽略了hdfs的本质：它是一个分布式文件存储系统，专为大文件的存储和处理设计，而非像windows和Linux那样常规的对本地文件进行操作（创建和编辑），因此一般不直接在hdfs上进行文件的创建和编辑。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78e0cb0304befa174d448fc23b7f8285/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5a3ca41708dd5634a323d9706e2665a/" rel="bookmark">
			探析—面向存算架构的神经网络数字系统【存内计算开发者社区】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面向存算架构的神经网络数字系统（Compute-in-Memory, CIM 或 Processing-in-Memory, PIM）是一种旨在突破传统计算架构瓶颈的新型系统设计。传统的计算系统中，数据存储和数据计算通常分开进行，这导致了大量的数据搬移和相关的时间、能量消耗。而存算一体化架构通过将计算单元和存储单元集成在一起，可以显著提高计算效率和能量效率，特别是在处理大量数据的神经网络任务中表现尤为突出。
面向存算架构的优势 减少数据搬移：传统架构中，处理器和内存之间的数据搬移会产生显著的延迟和能量消耗。CIM通过在存储器内执行计算，大大减少了数据搬移的需求。
提高能量效率：在存储器中执行计算任务可以显著降低功耗，尤其是在深度学习等需要大量矩阵乘法和加法运算的应用中。
提升计算性能：由于减少了数据搬移时间，存算一体化架构能够加速计算过程，提高系统的整体性能。
存算架构的实现方式 基于SRAM的CIM：静态随机存取存储器（SRAM）由于其高速和低功耗特性，常用于构建高性能的存算一体化单元。通过在SRAM单元中集成简单的计算逻辑单元，可以实现高效的并行计算。
基于DRAM的CIM：动态随机存取存储器（DRAM）虽然速度较慢，但其高密度和大容量特性使其适合于大规模数据存储和计算。通过在DRAM中集成计算单元，可以处理更大规模的数据集。
基于ReRAM的CIM：电阻式随机存取存储器（ReRAM）是一种新型存储技术，具有高速度和非易失性特点。在ReRAM中集成计算单元，可以在提高计算速度的同时保持数据的持久性。
存算架构在神经网络中的应用 加速训练过程：存算一体化架构能够加速神经网络训练过程中的矩阵运算，显著减少训练时间。
提高推理效率：在推理阶段，CIM架构能够快速处理输入数据并生成输出结果，适用于实时应用。
降低能耗：通过在存储器内直接进行计算，CIM架构可以显著降低神经网络计算的能耗，延长电池供电设备的使用时间。
ResNet14 算法基本架构 ResNet14 是一种深度卷积神经网络，属于 ResNet（残差网络）系列。尽管 ResNet14 并不是最常见的 ResNet 版本（如 ResNet18、ResNet34、ResNet50 等），其基本架构仍然遵循 ResNet 的设计理念。以下是 ResNet14 的基本架构和其关键组件的简要说明：
ResNet 基本设计理念 残差块（Residual Block）: 核心组件是残差块，通过引入快捷连接（skip connections）来缓解梯度消失问题。每个残差块可以表示为： [ y = F(x, {Wi}) + x ] 其中 (x) 是输入，(y) 是输出，(F(x, {Wi})) 是表示通过权重为 ({W_i}) 的卷积层等操作后的输出。
快捷连接（Skip Connection）: 将输入直接添加到输出，允许梯度直接传回较早的层，从而增强网络的训练能力。
ResNet14 架构 ResNet14 可以看作是一个简化版的 ResNet18，通常由以下几个部分组成：
输入层（Input Layer）: 输入图像大小：(224 \times 224)一个 (7 \times 7) 的卷积层，64 个滤波器，步幅为 2。一个 (3 \times 3) 的最大池化层，步幅为 2。 残差块组（Residual Blocks）: 第一个残差块组: 两个基本块（Basic Block），每个块包含两个 (3 \times 3) 的卷积层。第二个残差块组: 两个基本块，每个块包含两个 (3 \times 3) 的卷积层。第三个残差块组: 两个基本块，每个块包含两个 (3 \times 3) 的卷积层。 全局平均池化层（Global Average Pooling Layer）: 对整个特征图进行平均池化，将特征图转化为一个单一的特征向量。 全连接层（Fully Connected Layer）: 最后连接一个全连接层，用于分类。 详细结构 为了更清晰地理解，以下是 ResNet14 的具体层级结构：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5a3ca41708dd5634a323d9706e2665a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92fc023459015d95592563206fed78ec/" rel="bookmark">
			Tomcat源码解析(八)：一个请求的执行流程（附Tomcat整体总结）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tomcat源码系列文章
Tomcat源码解析(一)：Tomcat整体架构
Tomcat源码解析(二)：Bootstrap和Catalina
Tomcat源码解析(三)：LifeCycle生命周期管理
Tomcat源码解析(四)：StandardServer和StandardService
Tomcat源码解析(五)：StandardEngine、StandardHost、StandardContext、StandardWrapper
Tomcat源码解析(六)：Connector、ProtocolHandler、Endpoint
Tomcat源码解析(七)：底层如何获取请求url、请求头、json数据？
Tomcat源码解析(八)：一个请求的执行流程
文章目录 前言一、Engine管道内容1、StandardEngineValve2、如何通过Engine找到Host 二、Host管道内容1、ErrorReportValve（拼接html错误页面）2、StandardHostValve3、如何通过Host找到Context(上下文) 三、Context管道内容1、StandardContextValve2、如何通过Context找到Wrapper 四、Wrapper管道内容1、StandardWrapperValve1.1、创建过滤器链1.2、执行过滤器链1.2.1、Request和Response的门面模式1.2.2、doFilter方法 Tomcat最终总结 前言 前文中我们介绍了NIO解析请求数据，网络字节流转化为Request和Response对象。接下来介绍拿到Req和Res之后如何走到Servelt，以及正常响应返回。
回顾之前篇章，NioEndpoint通过socket服务端ServerSocketChannel.accept()监听8080端口接收连接，获取到连接扔给连接池处理，SocketProcessor从NioChannel通道中读取数据到ByteBuff缓冲区再赋值给对应属性，最后通过适配器CoyoteAdapter生成容器Req和Res调用容器管道的执行方法。
Endpoint是连接器Connector的核心组件之一，那么NioEndpoint接受到的连接最后交给自己的连接器connector；由如下server.xml可知，Service对象由一个容器Engine和多个连接器Connector组成，所以结合上面核心代码connector.getService().getContainer()获取到的就是自己的顶级容器Engine。
以前第一篇文章Tomcat源码解析(一)：Tomcat整体架构最后一部分有说过管道的结构。这里再简单的说下容器管道，其实可以理解为容器Engine、Host、Context、Wrapper设置的拦截器，一个请求进来，需要通过每个容器设置的拦截器(如下链状结构，可以设置多个)，也就是说每个容器可能有多个处理点。作用其实就是在请求Servelt之前可以拦截请求做一些额外处理。另外一方面，也是从顶级容器Engine找到Wrapper从而找到Servelt执行我们写的业务逻辑
一、Engine管道内容 1、StandardEngineValve 这里感觉没啥核心内容，其实就是找到对应的Host，然后调用Host的管道执行方法。
final class StandardEngineValve extends ValveBase { ... @Override public final void invoke(Request request, Response response) throws IOException, ServletException { // 从request中获取虚拟主机host Host host = request.getHost(); if (host == null) { response.sendError (HttpServletResponse.SC_BAD_REQUEST, sm.getString("standardEngine.noHost", request.getServerName())); return; } if (request.isAsyncSupported()) { request.setAsyncSupported(host.getPipeline().isAsyncSupported()); } // 请此主机处理此请求，调用对应主机的管道执行方法 host.getPipeline().getFirst().invoke(request, response); } } 2、如何通过Engine找到Host 顶级容器Engine下可以有多个虚拟主机Host(主机名称和ip地址，默认localhost)；在上篇文章中讲过NIO解析请求数据，里面自然包括请求ip地址，此时只要比对下即可在多个虚拟主机Host中找到。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92fc023459015d95592563206fed78ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96ba8b9a8a6bf4c5f4703b53e9709a4d/" rel="bookmark">
			Objective-C的初始化方法中,应该如何读写属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		除非有明确的原因需要使用setter, getter, 否则总是应该直接访问, 也就是直接使用实例变量（也称为 iVar）来读写数据
理由： 避免子类覆盖setter方法的影响：若在初始化方法中使用setter方法, 使用此方法实例化子类, 可能会调用子类重写的setter方法，这可能会导致意想不到的行为。在初始化期间，应该避免这种情况，以确保对象处于一个稳定和预期的状态。 // 假设SQIPerson有一个子类叫做SQISmithPerson, 专门表示那些姓"Smith"的人, 重写了 lastName 属性对应的设置方法 - (void)setLastName:(NSString *)lastName { if (![lastName isEqualToString:@"Smish"]) { [NSException raise:NSInvalidArgumentException format:@"Last name must be Smith"]; } [super setLastName:lastName]; // 使用super调用父类的setter方法, 而不是self.lastName = lastName; } 属性的 setter 方法可能依赖于对象的其他部分：在 init 方法中，对象可能还没有完全初始化，依赖于对象其他部分的 setter 方法可能会引发错误或不一致的状态。
属性的 getter 和 setter 方法可能包含副作用：属性的 getter 和 setter 方法通常会做一些额外的工作，比如通知观察者、触发 KVO（Key-Value Observing）通知、或者执行自定义的逻辑。如果在初始化或销毁过程中使用这些方法，可能会导致一些未定义行为或者不必要的操作。
性能考虑：直接访问实例变量比通过属性访问更高效，因为它避免了方法调用的开销。在性能敏感的场合，尤其是在对象初始化和销毁过程中，直接访问实例变量可以提高性能。
具体实现： 在初始化方法中直接访问实例变量，可以确保初始化逻辑的简单和明确，不会受到继承层次结构中的其他因素影响。
@interface MyClass : NSObject @property (nonatomic, strong) NSString *propertyName; @end @implementation MyClass - (instancetype)init { self = [super init]; if (self) { _propertyName = @"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96ba8b9a8a6bf4c5f4703b53e9709a4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/599aaeb0dcb27cf29e0f1d603ed042d0/" rel="bookmark">
			力扣每日一题 6/8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3040.相同分数的最大操作数目 II[中等] 题目： 给你一个整数数组 nums ，如果 nums 至少 包含 2 个元素，你可以执行以下操作中的 任意 一个：
选择 nums 中最前面两个元素并且删除它们。选择 nums 中最后两个元素并且删除它们。选择 nums 中第一个和最后一个元素并且删除它们。 一次操作的 分数 是被删除元素的和。
在确保 所有操作分数相同 的前提下，请你求出 最多 能进行多少次操作。
请你返回按照上述要求 最多 可以进行的操作次数。
示例 1：
输入：nums = [3,2,1,2,3,4] 输出：3 解释：我们执行以下操作： - 删除前两个元素，分数为 3 + 2 = 5 ，nums = [1,2,3,4] 。 - 删除第一个元素和最后一个元素，分数为 1 + 4 = 5 ，nums = [2,3] 。 - 删除第一个元素和最后一个元素，分数为 2 + 3 = 5 ，nums = [] 。 由于 nums 为空，我们无法继续进行任何操作。 示例 2：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/599aaeb0dcb27cf29e0f1d603ed042d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06eb24384bbf81130e5c328484375cc1/" rel="bookmark">
			力扣每日一题 6/10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		881.救生艇[中等] 题目： 给定数组 people 。people[i]表示第 i 个人的体重 ，船的数量不限，每艘船可以承载的最大重量为 limit。
每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。
返回 承载所有人所需的最小船数 。
示例 1：
输入：people = [1,2], limit = 3 输出：1 解释：1 艘船载 (1, 2) 示例 2：
输入：people = [3,2,2,1], limit = 3 输出：3 解释：3 艘船分别载 (1, 2), (2) 和 (3) 示例 3：
输入：people = [3,5,3,4], limit = 5 输出：4 解释：4 艘船分别载 (3), (3), (4), (5) 提示：
1 &lt;= people.length &lt;= 5 * 10**41 &lt;= people[i] &lt;= limit &lt;= 3 * 10**4 题目分析： 一艘船最多上两个人，要使船只最少那就只能让每只船载人尽可能多，那么最多就是两个人，这里对people数组进行排序(假设从小到大排)，然后定义双指针分别指头和尾。判断头+尾是否大于limit:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06eb24384bbf81130e5c328484375cc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36b898a5e0c8ce8d98db44462562a548/" rel="bookmark">
			14.《C语言》——【牛客网BC116—BC123题目讲解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		亲爱的读者，大家好！我是一名正在学习编程的高校生。在这个博客里，我将和大家一起探讨编程技巧、分享实用工具，并交流学习心得。希望通过我的博客，你能学到有用的知识，提高自己的技能，成为一名优秀的程序员。如果你有任何疑问或建议，请随时在评论区留言，让我们一起成长进步！现在，让我们开始这场知识之旅吧！
🧔🏻个人主页： FEN03
📚收入专栏： C语言
文章目录 📑前言📗牛客网题目🔖BC116 [NOIP2013]记数问题🔖BC117 逆序输出🔖BC118 N个数之和🔖BC119 最高分与最低分之差🔖BC120 争夺前五名🔖BC121 有序序列合并🔖BC122 有序序列判断🔖BC123 有序序列插入一个整数 👋🏻结束语 📑前言 本文章内容主要讲解牛客网 BC116—BC123 题目详细讲解
📗牛客网题目 🔖BC116 [NOIP2013]记数问题 题目要求：
试计算在区间1 到n 的所有整数中，数字x（0 ≤ x ≤ 9）共出现了多少次？
例如，在1到11 中，即在1、2、3、4、5、6、7、8、9、10、11 中，数字1 出现了4 次。
输入要求：
输入共1行，包含2个整数n、x，之间用一个空格隔开。
输出描述：
输出共1行，包含一个整数，表示x出现的次数。
示例1
解答：
代码如下：
//BC116[NOIP2013]记数问题 #include&lt;stdio.h&gt; int main() { int n = 0; int x = 0; int count = 0; scanf("%d %d", &amp;n, &amp;x); for (int i = 1; i &lt;= n; i++) { int m = i; while (m) { if (m % 10 == x) { count++; } m /= 10; } } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36b898a5e0c8ce8d98db44462562a548/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/833cc8f0f5394bce34a2ef7d66b32036/" rel="bookmark">
			超详解——​深入理解Python中的位运算与常用内置函数/模块——基础篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
​编辑
1.位运算
2.常用内置函数/模块
math模块
random模块
decimal模块
常用内置函数
3.深入理解和应用
位运算的实际应用
1.权限管理
2.位图
3.图像处理
2.math模块的高级应用
统计计算
几何计算
总结
1.位运算 位运算是对整数在内存中的二进制表示进行操作的一种方法。在计算机中，数据是以二进制形式存储的，位运算可以直接操作这些二进制位，从而实现高效的数据处理。Python支持以下常见的位运算符：
按位与（&amp;）：两个二进制数对应位都为1时，结果的该位才为1。按位或（|）：两个二进制数对应位有一个为1，结果的该位就为1。按位异或（^）：两个二进制数对应位不同，结果的该位为1。按位取反（~）：将二进制数的每一位取反（0变1，1变0）。左移（&lt;&lt;）：将二进制数的所有位向左移动指定的位数，右侧补0。右移（&gt;&gt;）：将二进制数的所有位向右移动指定的位数，左侧补0（对于无符号数）或补符号位（对于有符号数）。 a = 60 # 二进制：0011 1100 b = 13 # 二进制：0000 1101 # 按位与 result = a &amp; b # 结果：0000 1100 (12) print(result) # 输出：12 # 按位或 result = a | b # 结果：0011 1101 (61) print(result) # 输出：61 # 按位异或 result = a ^ b # 结果：0011 0001 (49) print(result) # 输出：49 # 按位取反 result = ~a # 结果：1100 0011 (-61)，在Python中，负数用补码表示 print(result) # 输出：-61 # 左移 result = a &lt;&lt; 2 # 结果：1111 0000 (240) print(result) # 输出：240 # 右移 result = a &gt;&gt; 2 # 结果：0000 1111 (15) print(result) # 输出：15 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/833cc8f0f5394bce34a2ef7d66b32036/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcdbaa057b5de6f72b34d73c119103e6/" rel="bookmark">
			一些简单却精妙的算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.树状数组2.红黑树3.星星打分4.欧几里得算法5.快速幂6.并查集 在编程的世界里，简洁的代码往往隐藏着深邃的智慧。一起来看看那些看似简单，实则精妙绝伦的代码片段，体会编程语言的优雅与力量。 1.树状数组 int lowbit(int x) { return x&amp;-x; } 树状数组里的这个，太精妙了，树状数组使区间求和复杂度降低到了log(n),发明这段代码的人一定是个天才,而这个lowbit恰恰是最精妙的一部分,可以准确的找到我们需要加的部分，巧妙的利用了计算机的位运算。
2.红黑树 defun rbt-balance (tree) "Balance the rbtree list TREE." (pcase tree (`(B (R (R ,a ,x ,b) ,y ,c) ,z ,d) `(R (B ,a ,x ,b) ,y (B ,c ,z ,d))) (`(B (R ,a ,x (R ,b ,y ,c)) ,z ,d) `(R (B ,a ,x ,b) ,y (B ,c ,z ,d))) (`(B ,a ,x (R (R ,b ,y ,c) ,z ,d)) `(R (B ,a ,x ,b) ,y (B ,c ,z ,d))) (`(B ,a ,x (R ,b ,y (R ,c ,z ,d))) `(R (B ,a ,x ,b) ,y (B ,c ,z ,d))) (_ tree))) (defun rbt-insert- (x s) "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcdbaa057b5de6f72b34d73c119103e6/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/284/">«</a>
	<span class="pagination__item pagination__item--current">285/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/286/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>