<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1028fec28fc399d4d9418054775f3b11/" rel="bookmark">
			随心笔记，第四更
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Windows环境
rabbitmq
1. 安装 RabbitMQ 和 Erlang
1.1、下载和安装 Erlang
1.2、下载和安装 RabbitMQ
2. 安装 RabbitMQ 服务
2.1、打开命令提示符
2.2、注册 RabbitMQ 服务
3. 配置 RabbitMQ 服务自启动
3.1、打开服务管理器
3.2、设置 RabbitMQ 服务为自动启动
3.3、启动 RabbitMQ 服务
4. 验证 RabbitMQ 服务状态
示例步骤
MySQL
1、启动并配置 MySQL 服务
1.1、启动 MySQL 服务
1.2、配置 MySQL 服务自启动
2、使用命令行配置 MySQL 服务自启动
2.1、打开命令提示符
2.2、使用 sc 命令配置 MySQL 服务
3、验证 MySQL 服务状态
4、测试 MySQL 自启动配置
示例步骤
Redis
1. 安装Redis
2. 配置环境变量
3. 将Redis注册为Windows服务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1028fec28fc399d4d9418054775f3b11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5895c58f1633e40793ede394c3811367/" rel="bookmark">
			LeetCode/NowCoder-栈和队列OJ练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		孜孜不倦：孜孜：勤勉，不懈怠。指工作或学习勤奋不知疲倦。💓💓💓
目录
说在前面
题目一：括号匹配问题
题目二：用队列实现栈
题目三：用栈实现队列
题目四：设计循环队列
SUMUP结尾
说在前面 dear朋友们大家好！💖💖💖我们又见面了，有到了我们数据结构的刷题时间了。我们上次刚学完了栈和队列，现在正好练练手~
👇👇👇
友友们！🎉🎉🎉点击这里进入力扣leetcode学习🎉🎉🎉
​以下是leetcode题库界面：
​​
👇👇👇
🎉🎉🎉点击这里进入牛客网NowCoder刷题学习🎉🎉🎉
​以下是NowCoder题库界面：
​
​​​
题目一：括号匹配问题 题目链接：20. 有效的括号 - 力扣（LeetCode）
题目描述：
​
题目分析：
思路：由于C语言没有单独提供栈的实现，我们首先需要把我们之前写的栈的实现的接口都复制到题当中，接口如下：
typedef char STDataType; typedef struct Stack { STDataType* a; int top; int capacity; }ST; //栈的初始化 void STInit(ST* pst) { assert(pst); pst-&gt;a = NULL; //top指的是栈顶数据的下一个位置 pst-&gt;top = pst-&gt;capacity = 0; } //扩容 static void STCheckCapacity(ST* pst) { if (pst-&gt;top == pst-&gt;capacity) { int NewCapacity = pst-&gt;capacity == 0 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5895c58f1633e40793ede394c3811367/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d465c9753d7c1d1ff0943e31e539364/" rel="bookmark">
			【AIGC】Diffusers:加载管道、模型和调度程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 拥有一种使用扩散系统进行推理的简单方法对于🧨扩散器至关重要。扩散系统通常由多个组件组成，例如参数化模型、分词器和调度器，它们以复杂的方式进行交互。这就是为什么我们设计了 DiffusionPipeline，将整个扩散系统的复杂性包装成一个易于使用的 API，同时保持足够的灵活性以适应其他用例，例如将每个组件单独加载为构建块以组装您自己的扩散系统。
推理或训练所需的一切都可以通过该 from_pretrained() 方法访问。
本指南将向您展示如何加载：
来自中心和本地的管道将不同的组件放入管道中模型变体，例如不同的浮点类型或非指数平均平均 （EMA） 权重模型和调度程序 扩散管线 💡 如果您有兴趣更详细地了解 DiffusionPipeline 类的工作原理，请跳到DiffusionPipeline 说明部分。
DiffusionPipeline 类是从 Hub 加载最新趋势扩散模型的最简单、最通用的方法。DiffusionPipeline.from_pretrained（） 方法自动从检查点检测正确的管道类，下载并缓存所有必需的配置和权重文件，并返回准备进行推理的管道实例。
from diffusers import DiffusionPipeline repo_id = "runwayml/stable-diffusion-v1-5" pipe = DiffusionPipeline.from_pretrained(repo_id, use_safetensors=True) 还可以加载具有特定管道类的检查点。上面的示例加载了一个稳定扩散模型;若要获得相同的结果，请使用 StableDiffusionPipeline 类：
from diffusers import StableDiffusionPipeline repo_id = "runwayml/stable-diffusion-v1-5" pipe = StableDiffusionPipeline.from_pretrained(repo_id, use_safetensors=True) 模型（如 CompVis/stable-diffusion-v1-4 或runwayml/stable-diffusion-v1-5 ）也可以用于多个任务，例如文本到图像或图像到图像。若要区分要将模型用于的任务，必须直接使用其相应的特定于任务的管道类加载它：
from diffusers import StableDiffusionImg2ImgPipeline repo_id = "runwayml/stable-diffusion-v1-5" pipe = StableDiffusionImg2ImgPipeline.from_pretrained(repo_id) 本地管道 若要在本地加载扩散管道，请使用 git-lfs 手动将模型（在本例中为 runwayml/stable-diffusion-v1-5 ）下载到本地磁盘。这会在磁盘上创建一个本地文件夹 ./stable-diffusion-v1-5 ， ：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d465c9753d7c1d1ff0943e31e539364/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cdae027aa1dae7d5fffb4faf40c5839/" rel="bookmark">
			通俗易懂-＞哈希表详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、什么是哈希表？
1.1哈希表长什么样？
1.2为什么会有哈希表？
1.3哈希表的特点
1.3.1 取余法、线性探测
1.3.2 映射
1.3.3负载因子
1.4哈希桶
1.5闲散列与开散列
1.6总结
二、设计hash表
1、哈希表的设计
1）插入
2）查找
3）删除
4）字符串哈希算法
2、封装map和set
1、完成对hash表的基础功能
2、完成封装
3、对应的迭代器
4、【】方括号重载
三、设计原码
1、HashTable
2、unordered_map
3、unordered_set
4、test
一、什么是哈希表？ 什么是哈希表？
哈希表，顾名思义，就是一个表。
可是为什么叫哈希表？
因为这是从老美哪里音译过来的
叫做-&gt;Hash Table
翻译过来就是-&gt;哈希表
既然是表，那么
第一，这个哈希表长什么样子？
第二，为什么会有这个哈希表？
第三，这个哈希表用来做什么？
第三，这个哈希表的特点是什么？
第四，什么是取余法？
第五，什么是映射？
第六，什么是线性探测？
第七，什么是哈希桶？
一些常见的概念，是什么？要怎么理解？
下面一一我来解析。
1.1哈希表长什么样？ 一般哈希表有两种形式（先别问为什么，先看，后面解释）
1.2为什么会有哈希表？ 假设你有一个数组或者链表，
传统的数组访问某一个数据，或者链表访问某一个数据，必须遍历，也只有遍历。
假如你的数组长度为100万，你现在要取某个值，而你知道这个值在就在数组的中间。
怎么办？
此时，无论从前往后，还是从后往前遍历，都绕不过50万个值。
蛋不蛋疼？蛋疼。
难受不难受？难受。
如果数据规模更大，例如100亿，那更难受。
所以，有困难，有麻烦，就会引发思考：我能不能不用遍历，咔的一下，马上就找到这个值？
而传统的数据结构显然无法突破这个难题。
既然旧的不行，干脆，那就搞一个新的。
于是，天空一声巨响，哈希表闪亮登场！
所以，哈希表就是为了解决查找必须遍历的问题而生。
1.3哈希表的特点 如何做到不遍历直接访问到数据？
很简单，非常简单，简单到不能再简单。
举个例子，你有5个值：1， 2， 3， 4 ，10001
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cdae027aa1dae7d5fffb4faf40c5839/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/043ef300fc686edb342bfd54fbd33e3c/" rel="bookmark">
			力扣刷题总结 -- 数组24
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		70. 数组中两元素的最大乘积（简单） 题目要求： 给定一个整数数组 nums，请你选择数组的两个不同下标 i 和 j，使 (nums[i]-1)*(nums[j]-1) 取得最大值。
请计算并返回该式的最大值。
题目分析： 找到数组中最大的两个元素即可。
题目解答： #include &lt;iostream&gt; using namespace std; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; class Solution { public: vector&lt;int&gt; maxProduct(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; ret; int a = nums[0], b = nums[1]; // 获取数组前两个元素 if (a &lt; b) { swap(a, b); // 将更大的元素赋给a } for (int i = 2; i &lt; nums.size(); i++) // 遍历数组后面的所有元素 { if (nums[i] &gt; a) // 如果当前元素大于a的值，将a原来的值赋给b，将当前元素的值赋给a { b = a; a = nums[i]; } else if (nums[i] &gt; b) // // 如果当前元素大于b但小于a的值，将当前元素的值赋给b { b = nums[i]; } } ret.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/043ef300fc686edb342bfd54fbd33e3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f8606a44c81899d7a1603109c589b5a/" rel="bookmark">
			Python魔法之旅-魔法方法(08)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、概述
1、定义
2、作用
二、应用场景
1、构造和析构
2、操作符重载
3、字符串和表示
4、容器管理
5、可调用对象
6、上下文管理
7、属性访问和描述符
8、迭代器和生成器
9、数值类型
10、复制和序列化
11、自定义元类行为
12、自定义类行为
13、类型检查和转换
14、自定义异常
三、学习方法
1、理解基础
2、查阅文档
3、编写示例
4、实践应用
5、阅读他人代码
6、参加社区讨论
7、持续学习
8、练习与总结
9、注意兼容性
10、避免过度使用
四、魔法方法
26、__getstate__方法
26-1、语法
26-2、参数
26-3、功能
26-4、返回值
26-5、说明
26-6、用法
27、__gt__方法
27-1、语法
27-2、参数
27-3、功能
27-4、返回值
27-5、说明
27-6、用法
28、__setstate__方法
28-1、语法
28-2、参数
28-3、功能
28-4、返回值
28-5、说明
28-6、用法
五、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、博客个人主页
​​​​​​​
一、概述 1、定义 魔法方法(Magic Methods/Special Methods，也称特殊方法或双下划线方法)是Python中一类具有特殊命名规则的方法，它们的名称通常以双下划线(`__`)开头和结尾。
魔法方法用于在特定情况下自动被Python解释器调用，而不需要显式地调用它们，它们提供了一种机制，让你可以定义自定义类时具有与内置类型相似的行为。
2、作用 魔法方法允许开发者重载Python中的一些内置操作或函数的行为，从而为自定义的类添加特殊的功能。
二、应用场景 1、构造和析构 1-1、__init__(self, [args.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f8606a44c81899d7a1603109c589b5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a59b31084605d58caa94304318ab6d5/" rel="bookmark">
			利用Python进行自然语言处理（NLP）（BERT与GPT的应用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文收录于专栏：精通AI实战千例专栏合集
从基础到实践，深入学习。无论你是初学者还是经验丰富的老手，对于本专栏案例和项目实践都有参考学习意义。
每一个案例都附带关键代码，详细讲解供大家学习，希望可以帮到大家。正在不断更新中~
一.利用Python进行自然语言处理（NLP）（BERT与GPT的应用） 自然语言处理（Natural Language Processing，NLP）是人工智能领域中一项重要的技术，它涉及了计算机与人类语言之间的交互与理解。近年来，随着深度学习技术的发展，NLP领域也迎来了革命性的进步。在众多NLP模型中，BERT（Bidirectional Encoder Representations from Transformers）和GPT（Generative Pre-trained Transformer）是两个备受关注的代表。本文将介绍如何利用Python和这两个模型进行自然语言处理，同时提供代码实例和技术深度探讨。
BERT简介与应用 BERT是由Google开发的预训练语言表示模型，其突出特点是双向编码器结构，能够更好地理解上下文信息。BERT可以应用于各种NLP任务，如文本分类、命名实体识别、问答系统等。
BERT的Python实现 在Python中，我们可以使用Hugging Face的Transformers库来方便地使用预训练的BERT模型。下面是一个简单的BERT文本分类示例：
from transformers import BertTokenizer, BertForSequenceClassification import torch # 加载预训练的BERT模型和tokenizer tokenizer = BertTokenizer.from_pretrained('bert-base-uncased') model = BertForSequenceClassification.from_pretrained('bert-base-uncased') # 准备输入文本并进行tokenize text = "This is a sample sentence." inputs = tokenizer(text, return_tensors="pt") # 使用BERT进行文本分类 outputs = model(**inputs) # 输出分类结果 print(outputs.logits) 上述代码首先加载了预训练的BERT模型和tokenizer，然后对输入文本进行tokenize，并最终使用BERT模型进行文本分类，输出分类结果。
GPT简介与应用 GPT是由OpenAI提出的生成式预训练转换模型，其核心思想是使用自回归模型生成文本。GPT模型在文本生成、对话系统等领域有着广泛的应用。
GPT的Python实现 同样地，我们可以使用Hugging Face的Transformers库来使用预训练的GPT模型。以下是一个简单的文本生成示例：
from transformers import GPT2Tokenizer, GPT2LMHeadModel # 加载预训练的GPT模型和tokenizer tokenizer = GPT2Tokenizer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a59b31084605d58caa94304318ab6d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0984340770f043778733691231ec317/" rel="bookmark">
			JavaScript中通过array.filter()实现数组的数据筛选、数据清洗和链式调用，JS中数组过滤器的使用详解（附实际应用代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、为什么要使用array.fifler(）
二、array.fifler(）的使用与技巧
2.1、基本语法
2.2、返回值
2.3、使用技巧
2.3.1、筛选数字数组中的偶数
2.3.2、数据筛选：筛选出高价值客户
2.3.3、数据清洗：移除无效的用户记录
2.3.4、链式调用：计算员工的平均薪资增长
三、总结
一、为什么要使用array.fifler(） 因为它简单，好用，清晰，可拓展性强，而且比for、foreach还有非常不常用的while、do...while高级，代码清晰，可读性强，代码就看起来很优雅，如果都是嵌套循环和嵌套回调，看起来就是一团乱麻，可读性差，很不优雅。
要做优雅的程序员，写优雅的代码。
array.fifler(）方法就像名字一样，他就是一个过滤器，比较语义化，上手较快。
二、array.fifler(）的使用与技巧 2.1、基本语法 array.filter(callback(element, index, array), thisArg)
其中callback回调函数对每个数组元素执行的函数，接受三个参数：
element：当前遍历到的元素index (可选)：当前遍历到的索引array (可选)：调用 filter 的数组本身 thisArg是执行 callback 时用作 this 的值。
2.2、返回值 一个新的数组，包含通过测试的元素。
2.3、使用技巧 综上所述，array.fifler(）就是一个数组的过滤器，同时不影响数组本身的样子，返回的是一个新的数组，常用于对基础数据进行筛选，以适用于特定的情况。
应用场景：数据筛选、数据清洗和链式调用。
2.3.1、筛选数字数组中的偶数 最基础的例子，基于原始数据numbers数组，通过array.fifler(）生成一个只含偶数的新数组evenNumbers。
// 示例1：筛选数组中的偶数 const numbers = [1, 2, 3, 4, 5, 6]; const evenNumbers = numbers.filter(number =&gt; number % 2 === 0); console.log(evenNumbers); // [2, 4, 6] 2.3.2、数据筛选：筛选出高价值客户 假设有一个客户消费记录的数组，我们想要筛选出过去一年内消费总额超过10000元且订单数量超过5个的高价值客户。
// 示例2：筛选出高价值客户 const customers = [ { id: 1, name: 'Alice', orders: [ { amount: 1200, date: '2023-05-15' }, { amount: 2500, date: '2023-07-22' }, { amount: 1800, date: '2023-08-05' } ]}, { id: 2, name: 'Bob', orders: [ { amount: 9000, date: '2023-03-01' }, { amount: 2200, date: '2023-09-12' } ]}, { id: 3, name: 'Charlie', orders: [ { amount: 750, date: '2023-02-17' }, { amount: 1100, date: '2023-04-03' }, { amount: 1500, date: '2023-05-09' }, { amount: 1300, date: '2023-06-21' } ]}, { id: 4, name: 'David', orders: [ { amount: 2000, date: '2023-01-05' }, { amount: 1700, date: '2023-02-20' }, { amount: 2300, date: '2023-03-18' } ]}, { id: 5, name: 'Eve', orders: [ { amount: 3500, date: '2023-04-08' }, { amount: 4200, date: '2023-05-22' } ]}, { id: 6, name: 'Frank', orders: [ { amount: 550, date: '2023-03-02' }, { amount: 850, date: '2023-08-16' } ]}, // .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0984340770f043778733691231ec317/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5bbb95bc104edef1616d6ac05b02c1b/" rel="bookmark">
			【活动】GPT-4O：AI语言生成技术的新里程碑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页: 鑫宝Code
🔥热门专栏: 闲话杂谈｜ 炫酷HTML | JavaScript基础 ​💫个人格言: "如无必要，勿增实体" 文章目录 GPT-4O：AI语言生成技术的新里程碑引言GPT系列简史回顾GPT-1: 初露锋芒GPT-2: 技术跃升GPT-3: 颠覆性创新 GPT-40: 横空出世的技术革新技术规格与性能提升核心技术创新版本间对比分析 技术能力评估生成能力理解与交互应用前景 个人整体感受 GPT-4O：AI语言生成技术的新里程碑 引言 随着人工智能领域的飞速发展，自然语言处理技术不断突破人们的想象边界。近期，OpenAI公司推出的GPT-40模型，再次震撼了整个科技界。作为GPT系列的最新力作，GPT-40不仅在技术层面上实现了质的飞跃，更是在应用领域展现了前所未有的广泛性和实用性。本文将深入探讨GPT-40的核心技术创新，通过与前代版本的对比分析，评估其技术能力，并分享个人对于这一技术突破的整体感受。
GPT系列简史回顾 GPT-1: 初露锋芒 2018年，OpenAI首次推出了GPT（Generative Pre-trained Transformer）模型，该模型基于Transformer架构，利用大规模未标注文本进行预训练，展示了强大的语言生成和理解能力。GPT-1拥有1.17亿个参数，虽然在当时已属先进，但与后续版本相比，其规模和能力都较为有限。
GPT-2: 技术跃升 2019年，GPT-2以15亿参数的规模面世，相较于GPT-1，其生成文本的质量和连贯性有了显著提升，能够完成更加复杂的任务，如文章续写、问答等。GPT-2的成功标志着预训练语言模型开始进入大众视野，对NLP领域产生了深远影响。
GPT-3: 颠覆性创新 2020年发布的GPT-3，凭借其前所未有的1750亿参数量，震撼了整个AI界。GPT-3展现出了惊人的泛化能力和创造力，能够根据少量提示生成文章、代码、诗歌甚至进行简单的逻辑推理，极大地推动了AI辅助创作和自动化工具的发展。
GPT-40: 横空出世的技术革新 技术规格与性能提升 GPT-40的发布，无疑将这一系列推向了新的高度。虽然具体参数量尚未完全公开，但据可靠消息，GPT-40的规模远超GPT-3，预计参数量达到数千亿乃至万亿级别。这一巨大的参数量不仅意味着模型可以学习到更深层次的语言结构和语境信息，也意味着它能够处理更为复杂和抽象的任务。
核心技术创新 高效训练机制：GPT-40引入了更为高效的训练算法和分布式计算优化，有效解决了大规模模型训练中的计算资源瓶颈问题。
多模态融合：不同于以往仅依赖文本数据的训练方式，GPT-40集成了图像、音频等多种模态的数据，实现了跨模态理解和生成，极大地拓宽了应用场景。
自适应学习：通过引入动态调整的学习率和权重衰减策略，GPT-40能够根据训练过程中的反馈自我优化，提高学习效率和模型表现。
强化伦理考量：鉴于AI伦理问题日益受到重视，GPT-40在设计之初就融入了伦理指导原则，通过算法减少偏见和不适当内容的生成，努力实现更加公正和安全的AI。
版本间对比分析 与前代相比，GPT-40最显著的进步在于其综合处理能力的飞跃。不仅文本生成质量更高、更自然，更重要的是，多模态融合能力使得GPT-40能够理解并生成与视觉、听觉信息相结合的内容，这是GPT-3及之前版本所不具备的。此外，GPT-40在对话交互中展现出更强的理解力和上下文关联能力，使机器与人类的交流更加流畅自然。
技术能力评估 生成能力 GPT-40的生成能力达到了前所未有的高度，无论是创意写作、新闻报道、代码生成还是学术论文草拟，都能以极高的质量和效率完成，且在特定领域内，其生成的内容往往能与人类专家的作品相媲美。
理解与交互 在理解复杂指令、执行多步骤推理任务以及个性化对话方面，GPT-40的性能显著优于前代。它能更好地捕捉用户意图，提供精准、个性化的反馈，极大地提升了人机交互的体验。
应用前景 GPT-40的广泛应用潜力巨大，从教育辅导、内容创作、智能客服到辅助科研，几乎每个需要高质量语言处理能力的行业都将受益。特别是结合其多模态处理能力，未来在虚拟现实、智能家居、数字娱乐等领域将有无限可能。
个人整体感受 GPT-40的问世不仅是技术上的巨大进步，更是对人工智能发展方向的一次深刻启示。它展示了在确保技术进步的同时，如何平衡伦理、安全和社会责任的重要性。尽管GPT-40带来了许多积极变化，但我们也应警惕其潜在的风险，比如对就业市场的影响、信息真实性的挑战等，这些问题需要社会各界共同努力，制定合理的规范和引导措施。
综上所述，GPT-40不仅是OpenAI的又一力作，更是AI发展历程中的重要里程碑，它预示着未来AI将更加智能、更加人性化，同时也对技术伦理和社会治理提出了更高的要求。我们期待GPT-40及其后续技术能够持续推动社会进步，为人类创造更多价值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ad5d98faa5af1c836d351b8143e70d4/" rel="bookmark">
			css特殊效果和页面布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 特殊效果 圆角边框：div{border-radius: 20px 10px 50px 30px;} 四个属性值按顺时针排列，左上的1/4圆半径为20px，右上10，右下50，左下30。
div{border-radius: 20px;} 四角都为20px。
div{border-radius: 20px 10px;} 左上和右下20px，右上左下10px。
div{border-radius: 20px 10px 50px;} 左上20px，右上左下10px，右下50px。
数值为0px时，角是尖的，为50%时是圆。
圆形边框：div{border-radius: 50%;} 盒子要为正方形。
胶囊按钮：div{border-radius: 50px;} 盒子要为长方形
边长100px，radius50px时，比50%方。
盒子阴影：div{box-shadow:inset x-offset y-offset blur-radius color;} inset:内阴影。默认outset。
x轴右为正，y轴下为正。单位px。offset偏移量。
blur-radius 模糊半径。
布局：display:block / inline / inline-block / none; 标准文档流：指元素根据块元素或行内元素的特性按从上到下，从左到右的方式自然排列。这也是元素默认的排列方式
块元素：独占一行从上到下排；宽默认父盒子宽，高由内容撑开；可以设置宽高
行内元素：可以与其它行内元素共用一行，宽高由内容撑开，不能设置宽高
行内标签可以包含于块级标签中，成为它的子元素，而反过来则不成立
块级元素与行级元素的转变（block、inline）
控制块元素水平排到一行（inline-block） 控制元素的显示和隐藏（none） display:none 隐藏，不占空间，不保留位置和大小
visibility:hidden 隐藏，占空间，保留位置和大小
visibility:visiable/show 显示
display:flex弹性盒子布局 display:flex 弹性盒子，实现水平排列 flex和上面的block，inline，inline-block并列， display只能设置一个属性
使用F12可快速调试各属性的页面效果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f0b7edb73c4eed7626ae09d72bc0499/" rel="bookmark">
			深入理解Python中的元组 ——Tuple（）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 元组（Tuple）是Python中一种重要的数据结构，具有不可变性和有序性的特点。它们可以存储不同类型的元素，是编写高效和安全代码的有力工具。今天我将全面介绍元组的定义、特性、常见操作及其在实际编程中的应用，并通过代码示例进行详细解释。
一、元组的定义与创建 在Python中，元组是一种有序的集合，元素用圆括号()包裹，元素之间用逗号,分隔。即使只包含一个元素的元组，也必须在元素后面加一个逗号。
下面是创建元组的几种方法：
1.使用括号() # 创建一个空元组 empty_tuple = () # 创建一个包含多个元素的元组 tuple1 = (1, 2, 3, 4) # 创建一个包含不同类型元素的元组 tuple2 = (1, "Hello", 3.14, True) # 创建一个单元素元组 single_element_tuple = (5,) 2.不使用圆括号，直接用逗号分隔元素 tuple3 = 1, 2, 3, 4 #这也是一种创建方法 3.使用内置函数tuple()将其他序列转换为元组 list1 = [1, 2, 3, 4] tuple_from_list = tuple(list1) #将列表转换为元组 string1 = "Hello" tuple_from_string = tuple(string1) #将字符串转换为元组 二、元组的特性 1. 不可变性 元组一旦创建，其元素就不能被修改。这使得元组在需要保护数据不被更改时特别有用。
tuple4 = (1, 2, 3, 4) # 试图修改元组中的元素会导致错误 # tuple4[0] = 10 # TypeError: 'tuple' object does not support item assignment #元组元素不可被修改 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f0b7edb73c4eed7626ae09d72bc0499/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45e58e9901999c69007196a48b7ce5db/" rel="bookmark">
			django基于大数据&#43;Spring的新冠肺炎疫情实时监控系统设计和实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌全网粉丝30W+,csdn特邀作者、博客专家、CSDN新星计划导师、Java领域优质创作者,博客之星、掘金/华为云/阿里云/InfoQ等平台优质作者、专注于Java技术领域和学生毕业项目实战,高校老师/讲师/同行前辈交流✌
主要内容：SpringBoot、Vue、SSM、HLMT、Jsp、PHP、Nodejs、Python、爬虫、数据可视化、小程序、安卓app、大数据、物联网、机器学习等设计与开发。
🍅文末获取源码联系🍅
👇🏻 精彩专栏推荐订阅👇🏻 不然下次找不到哟
2022-2024年最全的计算机软件毕业设计选题大全：1000个热门选题推荐✅
Java项目精品实战案例《100套》
Java微信小程序项目实战《100套》
Python项目实战《100套》
感兴趣的可以先收藏起来，还有大家在毕设选题，项目以及论文编写等相关问题都可以给我留言咨询，希望帮助更多的人
​ 系统介绍： 随着计算机技术发展，计算机系统的应用已延伸到社会的各个领域，大量基于网络的广泛应用给生活带来了十分的便利。所以把新冠肺炎疫情实时监控管理与现在网络相结合，利用计算机搭建新冠肺炎疫情实时监控系统，实现新冠肺炎疫情实时监控的信息化。则对于进一步提高新冠肺炎疫情实时监控管理发展，丰富新冠肺炎疫情实时监控管理经验能起到不少的促进作用。
系统阐述的是一款新冠肺炎疫情实时监控系统的设计与实现，对于Python、B/S结构、MySql进行了较为深入的学习与应用。主要针对系统的设计，描述，实现和分析与测试方面来表明开发的过程。开发中使用了 django框架和MySql数据库技术搭建系统的整体架构。利用这些技术结合实际需求开发了具有个人中心、用户管理、疫情数据管理、全国实时数据管理、国内实时动态管理、留言交流、系统管理等功能的系统，最后对系统进行相应的测试，测试系统有无存在问题以及测试用户权限来优化系统，最后系统达到预期目标。
程序上交给用户进行使用时，需要提供程序的操作流程图，这样便于用户容易理解程序的具体工作步骤，现如今程序的操作流程都有一个大致的标准，即先通过登录页面提交登录数据，通过程序验证正确之后，用户才能在程序功能操作区页面操作对应的功能。
​ 程序操作流程图
功能截图： 代码实现： /** * 登录相关 */ @RequestMapping("users") @RestController public class UserController{ @Autowired private UserService userService; @Autowired private TokenService tokenService; /** * 登录 */ @IgnoreAuth @PostMapping(value = "/login") public R login(String username, String password, String role, HttpServletRequest request) { UserEntity user = userService.selectOne(new EntityWrapper&lt;UserEntity&gt;().eq("username", username)); if(user != null){ if(!user.getRole().equals(role)){ return R.error("权限不正常"); } if(user==null || !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45e58e9901999c69007196a48b7ce5db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/671dbac30bc1a6c1af58515a7ac0ed6b/" rel="bookmark">
			C语言：深入了解（联合体和枚举）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
联合体
联合体的类型的声明
联合体的特点
相同成员的结构体和联合体对比
联合体大小的计算
联合体的使用举例
联合体的类型：判断联合体是大端还是小端
枚举类型
枚举类型声明
枚举类型的优点
枚举类型的使用
联合体 联合体的类型的声明 像结构体⼀样，联合体也是由⼀个或者多个成员构成，这些成员可以不同的类型。
但是编译器只为最⼤的成员分配⾜够的内存空间。联合体的特点是所有成员共⽤同⼀块内存空间。所
以联合体也叫：共⽤体。
给联合体其中⼀个成员赋值，其他成员的值也跟着变化。
联合体输出的结果为什么是4呢？
联合体的特点 联合的成员是共⽤同⼀块内存空间的，这样⼀个联合变量的⼤⼩，⾄少是最⼤成员的⼤⼩（因为联合
⾄少得有能⼒保存最⼤的那个成员）。
联合体是共⽤同⼀块内存空间的所以不能同时使用联合体，不能同时使用
我们可以看到3个地址都是一样的。
union a { char a; int b; }; int main() { union a p = { 0 }; printf("%zd\n", sizeof(union a)); printf("%p\n", &amp;p); printf("%p\n", &amp;p.a); printf("%p\n", &amp;p.b); } 相同成员的结构体和联合体对比 struct bp//结构体 { char a; int b; }; union ar//联合体 { char a; int b; }; 联合体大小的计算 联合的⼤⼩⾄少是最⼤成员的⼤⼩。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/671dbac30bc1a6c1af58515a7ac0ed6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3c7ef7c46f5f79676f81b7e428b98fb/" rel="bookmark">
			AI编程新手快速体验SpringCloud Alibaba 集成AI功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上周六写了一篇文章 震撼发布！Spring AI 框架重磅上线，Java 集成 AI 轻松搞定！ 部分同学可能没有科学上网的条件，本地ollama 集成又比较笨重。趁着周六，写一篇基于SpringCloud Alibaba 集成AI的文章。
先简单介绍下 Spring Cloud Alibaba AI。
Spring Cloud Alibaba AI 基于 Spring AI 0.8.1 版本完成通义系列大模型的接入。DashScope灵积模型服务建立在 模型即服务（Model-as-a-Service，MaaS）的理念基础之上，围绕AI各领域模型，通过标准化的API提供包括模型推理、模型微调训练在内的多种模型服务。目前支持的模型主要有：对话、文生图、文生语音，更多功能特性正在适配中。
实践前， Spring AI 0.8.1 最低需要JDK17版本， 公司项目还是JDK8， 先去下载JDK17。下载地址：
https://www.oracle.com/java/technologies/javase/jdk17-archive-downloads.html
springcloud、springboot对应小常识 2023.x 分支对应的是 Spring Cloud 2023 与 Spring Boot 3.2.x，最低支持 JDK 17。 2022.x 分支对应的是 Spring Cloud 2022 与 Spring Boot 3.0.x，最低支持 JDK 17。 2021.x 分支对应的是 Spring Cloud 2021 与 Spring Boot 2.6.x，最低支持 JDK 1.8。 2020.0 分支对应的是 Spring Cloud 2020 与 Spring Boot 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3c7ef7c46f5f79676f81b7e428b98fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72f682c02b845f6ce9797b614b84f4e7/" rel="bookmark">
			Mac上Steam安装的游戏已经卸载，但游戏的快捷方式图标仍存在的解决方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过终端打开Applications文件夹
打开终端（Terminal）输入以下内容并回车。 open ~/Applications 以上实际上打开的是 /Users/改为你的用户名/Applications 文件夹下的内容。
因此也可以通过打开访达（Finder），前往文件夹（或快捷键 Shift+Command+G），输入以上的路径来进入。
在弹出的窗口中，将看到包括游戏快捷方式图标在内的所有应用程序。找到想要删除的游戏快捷方式图标，将其拖入废纸篓（Trash）或右键选择“移到废纸篓”。 系统级的应用程序目录都在 /System/Applications 下。
这两个文件夹下的图标都会在启动台中显示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43729a2b84540be2af64c8693066c60b/" rel="bookmark">
			内存管理【C&#43;&#43;】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内存分布 C++中的内存区域主要有以下5种
栈（堆栈）：存放非静态局部变量/函数参数/函数返回值等等，栈是向下增长的【地址越高越先被使用】。栈区内存的开辟和销毁由系统自动执行
堆：用于程序运行时动态内存分配，由程序员申请和释放内存，堆是向上增长的【地址越低越先被使用】。
内存映射段：是高效的I/O映射方式，用于装载一个共享的动态内存库。用户可使用系统接口创建共享共享内存，做进程间通信。
数据段（全局区）：存储全局数据和静态数据。
代码段（常量区）：存放可执行的代码/只读常量。
C++动态内存管理 动态内存申请 动态内存申请，申请的是堆区的内存
申请一个类型大小的空间 不初始化申请的空间语法： T* p=new T（T代指类型，p可以是任意合法标识符）
例
int* p = new int; 即可申请1个int类型大小的未初始化的空间
初始化申请内置类型的空间语法： T* p=new T（要初始化的值）（T代指类型，p可以是任意合法标识符）
例
int* p = new int(200); 即可申请1个int类型大小的初始化为200的空间
调用指定构造函数申请自定义类型的空间语法： T* p=new T（传给自定义类型的构造函数的参数）（T代指类型，p可以是任意合法标识符）
申请连续多个类型大小的空间 不初始化申请的空间语法： T* p=new T【n】（T代指类型，p可以是任意合法标识符，n是要申请的连续的类型空间的个数）
例
int* p = new int[12]; 即可申请连续12个int类型大小未初始化的空间
初始化申请内置类型的空间语法： T* p=new T【n】{初始值1，初始值2，……}（T代指类型，p可以是任意合法标识符，n是要申请的连续的类型空间的个数）
例
int* p = new int[12] {1,2,3,4,5,6}; 即可申请连续12个int类型大小的前6个int空间的值为1,2,3,4,5,6，后6个int空间值为0的空间
调用指定构造函数申请自定义类型的空间语法： T* p=new T【n】{{传给第一个自定义类型的构造函数的参数}，{传给第二个}（T代指类型，p可以是任意合法标识符，n是要申请的连续的类型空间的个数）
例
动态内存释放 释放一个类型大小的空间 语法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43729a2b84540be2af64c8693066c60b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c63be291315499033c22ab747b843ae2/" rel="bookmark">
			Stable Diffusion WebUI安装简单教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里先提前说明一下，如果只是完成Stable Diffusion安装，那只提供命令行方式，加载模型并提供基础的文本分析、特征提取、图片生成这些核心功能，但自身是没有可视化UI的。我们通常看到的页面是Stable Diffusion WebUI提供的功能。所以我们就不单独进行Stable Diffusion安装，而是直接完成Stable Diffusion WebUI介绍。
首先，从github上下载源码：
如果不指定安装目录名称，使用以下明亮将会将源码下载到当前目录下的stable-diffusion-webui目录下。
git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui.git 如果想指定源码下载目录名称(例如stablediffusion)，命令行修改如下（在某位增加指定目录名称即可）
git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui.git stablediffusion
由于总所周知的原因，连接github不是很稳定。可以使用镜像目录，也可多运行该命令几次，一般可以完成源码下载。
其次，下载安装Stable Diffusion WebUI的依赖项：
先进入我们已经下载的源代码目录cd stablediffusion
然后执行以下命令
pip install -r requirements_versions.txt -i https://pypi.tuna.tsinghua.edu.cn/simple
其中 -r requirements_versions.txt指明需要下载安装的依赖项。
-i https://pypi.tuna.tsinghua.edu.cn/simple指明从清华的镜像网站下载安装的依赖项。这不是必须的，但强烈建议一定要使用，否则下载速度会很慢。后续涉及用pip安装其他软件包的时候，务必记住一定要加上这串命令。
如果看到这个界面，就是提示这一步安装完成。
再执行以下命令
pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple
正常情况下是不会需要额外安装什么（因为在上一步已经完成安装了）但这个确实是一个重要的技巧，以防有些安装包由于版本甚至安装源的问题，会有所缺失。
总结一下，需要执行两行命令
pip install -r requirements_versions.txt -i https://pypi.tuna.tsinghua.edu.cn/simple
pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple
提前将我们下载好的模型文件保存至models\Stable-diffusion目录下。基于前面的学习和应用，应该理解为什么要这么做的原因了吧？
然后执行web-user.bat命令，系统会自动继续执行后续安装过程，包括下载一些文件。如果网络给力的话，最后系统会自动启动网页。
http://127.0.0.1:7860
输入提示词，点击生成按钮。恭喜你，这可是成功地迈出了一大步,安装Stable Diffusion UI。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/226ff8e1b5eaebe12805d64063010fda/" rel="bookmark">
			【Python内功心法】：深挖内置函数，释放语言潜能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🚀一、常见内置函数🌈二、高级内置函数⭐1. enumerate函数👊2. eval函数❤️3. exec函数💥4. eval与exec 中 globals与locals如何用☔4-1 globals 参数🎬4-2 locals 参数 ❤️5. filter函数👊6. zip函数🚲7. map函数 🚀一、常见内置函数 Python 提供了许多内置函数，这些函数无需导入任何模块即可直接使用，极大地丰富了编程的便捷性。以下是一些常用的Python内置函数及其简要说明：
函数概念len()查长度min()求最小值max()求最大值sorted()排序reversed()反向（返回一个反转的迭代器）sum()求和bin()转化二进制int(‘转化进制数据’，‘进制类型’)转化为十进制oct()转化为八进制hex()转化为十六进制ord()字符转ASCLL码chr()ASCLL码转字符range()生成一个给定范围内的数字序列。…… 这些只是冰山一角，Python还有许多其他有用的内置函数，建议查阅官方文档或使用help()函数深入学习。
🌈二、高级内置函数 ⭐1. enumerate函数 enumerate是Python的一个内置函数，它在遍历（如循环）过程中为可迭代对象（如列表、元组、字符串等）的每个元素生成索引号，这样就可以同时访问到元素的索引和值。这对于需要追踪元素位置的情况非常有用，而无需单独维护一个计数器变量。
基本语法：
enumerate(iterable, start=0) iterable：需要遍历的可迭代对象。start：索引起始值，默认为0。你可以设置任意整数作为起始索引。 a = ['apple', 'banana', 'orange'] for index, value in enumerate(a): print(index, value) 👊2. eval函数 eval() 是 Python 中的一个内置函数，它的作用是执行一个字符串表达式，并返回表达式的值。这个功能强大但也危险，因为它可以执行任意的 Python 代码，这可能导致安全风险，特别是当处理来自不可信来源的数据时。
基本语法：
eval(expression, globals=None, locals=None) expression: 要被解析和执行的字符串形式的 Python 表达式。globals: 可选参数，一个字典，将用作全局命名空间。如果未提供，则使用当前的全局命名空间。locals: 可选参数，一个映射，将用作局部命名空间。如果未提供，则使用当前的局部命名空间。 x = 10 y = 5 # 使用 eval 计算两个数的和 sum_str = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/226ff8e1b5eaebe12805d64063010fda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f746a9cb0f8d4adb506d4e349ca1a8c/" rel="bookmark">
			【数据结构】二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、树的概念及结构1.树的结构2.树的相关概念3. 树的表示 二、二叉树概念及结构1. 概念2. 特殊二叉树3. 二叉树的性质4. 二叉树的储存结构 三、二叉树顺序结构及实现1. 二叉树的顺序结构2. 堆的概念及结构堆的实现堆的创建向上调整算法向下调整算法删除堆顶元素取栈顶元素 堆排序TOP-k问题 四、二叉树链式结构及实现二叉树的遍历前序遍历后序遍历中序遍历 节点个数叶子节点个数二叉树第k层节点个数二叉树查找值为x的节点二叉树的深度二叉树的销毁二叉树的构建 层序遍历判断二叉树是否为完全二叉树 一、树的概念及结构 1.树的结构 树是一种非线性的数据结构，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的集合。把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。
有一个特殊的结点，称为根结点，根节点没有前驱结点,除根节点外其余结点被分成M(M&gt;0)个互不相交的集合T1、T2、……、Tm，其中每一个集合Ti(1&lt;= i &lt;= m)又是一棵结构与树类似的子树。每棵子树的根结点有且只有一个前驱，可以有0个或多个后继 因此，树是递归定义的。
2.树的相关概念 **节点的度：**一个节点含有的子树的个数称为该节点的度； 如上图：A的为6
**叶节点或终端节点：**度为0的节点称为叶节点； 如上图：B、C、H、I…等节点为叶节点
**非终端节点或分支节点：**度不为0的节点； 如上图：D、E、F、G…等节点为分支节点
**双亲节点或父节点：**若一个节点含有子节点，则这个节点称为其子节点的父节点； 如上图：A是B的父节点
**孩子节点或子节点：**一个节点含有的子树的根节点称为该节点的子节点； 如上图：B是A的孩子节点
**兄弟节点：**具有相同父节点的节点互称为兄弟节点； 如上图：B、C是兄弟节点
**树的度：**一棵树中，最大的节点的度称为树的度； 如上图：树的度为6
**节点的层次：**从根开始定义起，根为第1层，根的子节点为第2层，以此类推；
**树的高度或深度：**树中节点的最大层次； 如上图：树的高度为4
**堂兄弟节点：**双亲在同一层的节点互为堂兄弟；如上图：H、I互为兄弟节点
**节点的祖先：**从根到该节点所经分支上的所有节点；如上图：A是所有节点的祖先
**子孙：**以某节点为根的子树中任一节点都称为该节点的子孙。如上图：所有节点都是A的子孙
**森林：**由m（m&gt;0）棵互不相交的树的集合称为森林；
3. 树的表示 树结构相对线性表就比较复杂了，要存储表示起来就比较麻烦了，既然保存值域，也要保存结点和结点之间的关系，实际中树有很多种表示方式如：双亲表示法，孩子表示法、孩子双亲表示法以及孩子兄弟表示法等。我们这里就简单的了解其中最常用的孩子兄弟表示法。
typedef int DataType; struct Node { struct Node* _firstChild1; // 第一个孩子结点 struct Node* _pNextBrother; // 指向其下一个兄弟结点 DataType _data; // 结点中的数据域 }; *
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f746a9cb0f8d4adb506d4e349ca1a8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0513ac6b5b3c5c03d24b6d898058de3e/" rel="bookmark">
			【一步一步了解Java系列】：子类继承以及代码块的初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看到这句话的时候证明：此刻你我都在努力
加油陌生人
个人主页：Gu Gu Study
专栏：一步一步了解Java
喜欢的一句话： 常常会回顾努力的自己，所以要为自己的努力留下足迹
喜欢的话可以点个赞谢谢了。
作者：小闭
继承的概念以及继承存在的意义
Java中的继承是一种面向对象编程（OOP）的基本概念，它允许一个类（称为子类或派生类）继承另一个类（称为父类或基类）的属性和方法。继承提供了一种机制，使得子类可以扩展或修改父类的行为。
意义：
首先，继承是面向对象编程的核心特性之一，它体现了面向对象设计的原则，如封装、抽象、继承和多态。其次继承可以提高代码的复用率，让子类继承运用到父类的一些数据和方法。还可以实现多态，使一个接口呈现不同的功能实现。还有实现程序的扩展性可以在一个代码的基础上进行扩展等等功能。当然继承还有好多意义，这里使列举不完的。
子类继承 讲到继承我们首先还是先了解子类，那么子类和父类如何分辨，还有如何继承，接下来都会讲到，我们先看一下下面的代码：
在这段代码中Animal为父类，Dog是子类，首先我们在生活中的逻辑上就是狗一定是动物，而动物不一定是狗，这就说明动物的范围更大，所以Animal是父类，Dog是子类。然后再从语法上分析，首先我们看到extends这个关键字，那么这个就代表继承，那么我们看到一个类使用了这个关键字就说明它就是这个关键字后面那个类的子类，extends后面的就是父类。比如： ** class Dog extends Animal{}**，那么Dog就为子类，Animal就是父类。
public class Animal { String type; int age; public void eat(){ System.out.println("吃食物"); } public void speak(){ System.out.println("发出叫声"); } } class Dog extends Animal{ String name; public Dog(String name){ type="狗"; this.name=name; System.out.println("他是一只"+type+" 它的名字为:"+name); } public static void main(String[] args) { Dog dog=new Dog("旺财"); dog.speak(); dog.eat(); } } 然后我们从上面的代码中也是发现子类能够使用父类的成员变量或给其赋值，也可以调用父类的成员方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0513ac6b5b3c5c03d24b6d898058de3e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/320/">«</a>
	<span class="pagination__item pagination__item--current">321/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/322/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>