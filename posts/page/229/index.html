<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ac6c01522e3ca4eb34335c90ce3b18e/" rel="bookmark">
			【AI落地应用实战】如何高效检索与阅读论文——302.AI学术论文工具评测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 作为一名学术领域的探索者，我们都知道，检索和阅读论文是我们获取知识、启发思考、验证假设的基石，也是日常学习中必不可少的基本功之一。然而在浩瀚的学术海洋中，如何快速、准确地找到我们需要的论文，就像是航海家如何在茫茫大海中找到正确的航线。海量的学术资源、复杂的检索系统、不断更新的研究热点，都为我们设置了重重障碍。最近，我就收到了不少同学私信说他们检索并阅读完一篇论文所花费的时间，甚至比追完一季电视剧还要长，那么：
如何快速检索找到那些真正有价值、与研究方向紧密相连的论文？如何高效地粗读并挑选出那些真正值得我们深入阅读的论文？如何有效地精读目标论文，提炼出其中的核心知识点？ 带着这些问题，今天给大家分享一款我正在使用的学术论文检索与阅读工具——302.AI学术论文搜索
二、AI学术论文工具实战 2.1、快速检索 首先进入https://heaven-all.tools302.com/?pwd=4300，点击上方进入工具超市，选择学术相关，然后选择不久前刚重磅更新的AI学术论文搜索工具：
进入AI学术论文搜索栏目后，在搜索栏输入关键词“text to image”搜索文本生成图像相关论文，然后可以根据“相关性”或“最新发布”进行排序搜索：
在短暂的等待之后，平台为我们搜索到超过225万条相关的学术论文，这一庞大的数字背后，映射出它覆盖丰富且全面的学术资源数据库。
搜索结果详尽地列出了原文标题、作者以及更新时间等关键信息，为用户提供了直观且全面的文献概览。值得一提的是，该工具还提供了原文标题的智能翻译，自动将外文标题翻译成中文，方便阅读和理解。另外，在搜索结果页面上，还可以直接点击“打开”等功能按钮，轻松获取所需文献的详细内容。这种简洁而高效的操作流程，无疑为用户带来了极大的便利和舒适体验。
2.2、高效粗读 下面我们打开搜索到的《CLIP-GEN: Language-Free Training of a Text-to-Image Generator with CLIP》一文，开始粗读。进入后，可以看到页面分为了两大块，左侧为论文原文，右侧则提供了全文摘要、全文翻译和AI解答功能。虽然英文原文摘要已经包含了论文的背景、论点与结果，但是往往不够通俗易懂。
为了高效粗读论文，我们可以点击全文摘要生成功能。在这个功能下，302.AI首先会将PDF文件进行分块处理。这是因为PDF文件通常包含多个部分，如标题、摘要、引言、正文、结论等，每个部分都有其特定的结构和内容。通过分块处理，302.AI可以更有针对性地对每个部分进行解析和理解。在分块理解的基础上，302.AI会进一步识别论文的语境，学习并理解论文的语言模式和语义结构。语境识别是生成准确摘要的关键步骤，通过理解论文的语境，302.AI可以把握论文的核心内容和重点，从而生成更加准确和有意义的摘要。
基于这项功能，当我们遇到一个新的研究方向时，不再需要花费大量时间在茫茫的学术海洋中寻找论文，而是可以通过这些工具快速找到相关的论文，并直接获取到它们的核心内容。
2.3、有效精读 找到论文和粗读论文只是第一步，真正的挑战在于如何高效地阅读和理解论文。大家应该都深有感悟，一篇高质量的论文往往包含丰富的理论、深奥的算法和繁多的实验结果，需要我们花费大量的时间和精力去理解和消化，即使是资深的研究者，也可能在阅读时感到吃力。
不过好在平台提供了全文翻译和AI解答功能，还是CLIP-GEN这篇文章，我们点击全文翻译功能，并等待解析：
302.AI会调用大语言模型能力和Latex翻译插件一键生成全文翻译，并生成PDF。在翻译过程中，调用大语言模型能够生成符合目标语言语法和习惯的译文，确保翻译的专业性和准确性，使得翻译结果更加贴近原文。而Latex翻译插件的加持能够将翻译后的文本正确地嵌入到LaTeX模板中，保证了文章格式的一致性。
除了翻译功能，还提供了AI解答功能，如下图所示，点击AI解答，系统将调用所选择的LLM模型进行解析：
通过切割PDF文件，调用ChatGPT3.5turbo，识别论文的语境并通读后输出论文解析，它可以识别论文中的关键概念、论点、论据和结论，并理解它们之间的关系和逻辑。基于这种功能，我们可以对论文进行提问和总结，比如对论文的细节进行提问：
或是对论文的创新点进行总结：
检索和阅读论文虽然是一项枯燥且需要花费大量时间的任务，但只要我们掌握了正确的方法和技巧，就能够更加高效地获取知识、启发思考并推动研究的进展。基于AI学术论文工具这项功能，我们不再需要逐句翻译和理解复杂的理论和算法，而是可以通过智能检索、摘要、翻译和AI解答功能，快速了解论文的内容和核心知识点。
三、AI工具超市功能速览 除了AI学术论文工具，302.AI的工具超市还集成了多种包括工作效率、文字处理、老照片修复、视频素材合成等各种功能。
老照片修复功能利用AI技术，不仅可以自动识别和修复老照片中的损坏部分，还可以通过智能算法让照片重新焕发光彩，用户可以根据自己的需求对修复后的照片进行无损放大、人物增强、黑白上色。
模型竞技场内置了GPT4、GPT3.5、Claude3.5、Claude3、通义千问、百度文心、百川、Kimi、智谱GLM等模型。提问一次，可以同时得到多个模型的回答，进行对比调研。
AI视频素材创意站可以根据视频主题和脚本，输入关键词，AI可以帮助用户快速找到符合需求的素材，从而降低视频制作的门槛，让更多人能够轻松地参与到自媒体创作中来。
AI网页复制器可以根据一张截图，拆分网页结构、分析和理解并复刻网页布局，最终以HTML和Tailwind CSS格式生成网页页面，对于网页设计师、前端开发者以及需要快速搭建网页原型的用户具有极大的便利性。
除了上述的优势和特点外，302.AI还提供了多种应用场景的AI服务，如绘画机器人、AI调研、AI搜索、电商场景生成等等，我们可以根据自己的需求选择合适的AI应用，轻松实现各种创意和想法。
四、最后 综合体验下来，让我感受最深刻的就是，302.AI平台的易用性，无需任何专业的编程知识，只需简单操作即可使用聊天机器人、学术论文工具、老照片修复、翻译大师等各种专属的AI应用，通过直观的用户界面和简单的操作流程，让即使是初次使用的用户也能快速上手，这种零门槛的使用方式使每个人都可以轻松尝试和使用AI工具。一键分享功能更是简化了分享流程，无需注册登录，只需输入分享码即可让他人体验AI的魅力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe0ca869b7e9ccb595bd6881257ed6b2/" rel="bookmark">
			AI大模型：垂直大模型vs通用大模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI大模型的战场正在分化：通用大模型在落地场景更广泛毋庸置疑，垂直大模型的落地有更高的可能性和更快的普及速度，谁能先形成绝对优势还没有肯定的答案。对于大模型的第一个赛点，你更青睐哪一方呢？
1. 背景介绍 1.1. 垂直大模型与通用大模型 1.1.1. 垂直大模型 定义：
垂直大模型是专为某一特定领域或任务设计的大模型，以满足该领域的特定需求。
特点：
针对性强：针对特定领域的数据和任务进行训练和优化。数据集专业：使用特定领域的数据集进行训练，确保模型对该领域有深入的理解。适应范围：适用于需要深入分析和处理特定领域数据的场景，例如医疗诊断、法律分析、金融风险评估等专业性强的领域。 优点：
特定任务性能优异：由于专注于某一领域，因此能够在该领域达到很高的精度和效率。计算资源消耗相对较低：相比通用大模型，垂直大模型在训练和推理时所需的计算资源较少。易于部署和维护：模型结构相对简单，部署和维护成本较低。 缺点：
泛化能力有限：通常只能在特定领域内表现出色，难以迁移到其他领域或任务。灵活性较差：不易于适应新的任务或领域变化。 1.1.2. 通用大模型 定义：
通用大模型设计用于处理多种类型的任务，不特定于某一领域，具有广泛的适用性。
特点：
泛化能力强：能够处理各种自然语言处理任务，如文本生成、问答系统、文本分类等。数据集多样化：使用多样化的数据集进行训练，学习广泛的知识和技能。适应范围：适用于需要处理多种类型数据和任务的场景，如多语言翻译、跨领域知识问答等。 优点：
灵活性高：易于迁移到新任务或领域，不需要大量定制即可适应新场景。数据利用率高：在预训练阶段能够充分利用大量无标注数据进行学习，提高模型的泛化性能。 缺点：
计算资源消耗大：由于模型复杂且数据集庞大，训练和推理过程需要大量的计算资源。特定任务性能可能不如垂直模型：在特定任务上可能无法达到垂直模型的精度和效率。 1.2. 垂直大模型与通用大模型 1.2.1. 垂直大模型与通用大模型的发展情况 垂直大模型：近年来，随着各行业智能化需求的提升，垂直大模型得到了广泛应用。例如，科大讯飞在金融领域推出的模型，能够深入理解金融数据，为风险控制和投资决策提供支持。通用大模型：通用大模型在自然语言处理、图像识别等领域取得了显著成果。例如，ChatGPT等模型通过海量的数据和复杂的算法进行训练，展现出强大的泛化能力。 1.2.2. 实践路径的火热程度探讨 市场需求：
垂直大模型：随着企业对智能化解决方案的需求日益增长，垂直大模型因其针对性和实用性而受到青睐。特别是在金融、医疗等专业性强的领域，垂直大模型的需求尤为突出。通用大模型：在搜索引擎、广告推荐等需要处理多种任务和应用的场景下，通用大模型因其广泛的适用性而具有较大市场。 发展趋势：
从当前的市场需求和应用趋势来看，垂直大模型和通用大模型都有广泛的应用。垂直大模型因其专业性和精准度在特定领域表现出色，而通用大模型则因其广泛的适用性在跨领域任务中发挥重要作用。 数字与信息支持：
根据相关统计数据显示，仅2024年前五个半月，国内大模型项目中标公告已发布超230个，远超2023年全年水平。这表明大模型市场正处于快速发展阶段，且应用领域广泛。从中标项目的采购需求来看，不仅有算力方面的需求，还包括数据层面和应用层面的需求。这显示出大模型的应用已经深入到各行各业，并且对于垂直领域和通用领域的需求都在增加。 总体来说：
垂直大模型和通用大模型在实践中都有广泛的应用和发展空间。选择哪种路径取决于具体的应用场景和需求。在未来，随着技术的不断进步和应用场景的不断拓展，这两种类型的大模型将继续在各自擅长的领域发挥重要作用。因此，无法一概而论哪种路径在具体实践中更为火热，而是应根据实际情况进行选择和应用。
2. 能力分析 2.1. 差异分析 2.1.1. 设计目标和应用范围 通用大模型：旨在处理多种类型的任务，不局限于特定领域，追求广泛的适用性。它可以应对多种自然语言处理任务，如文本生成、问答、分类等，并能在多样化的数据集中学习。垂直大模型：专门为某一特定领域或任务设计，以满足该领域的特定需求。它通常使用特定领域的数据集进行训练，确保模型对该领域有深入的理解。 2.1.2. 泛化能力和专业性 通用大模型：具有强大的泛化能力，可以轻松迁移到新的任务或领域，但可能在特定任务上的性能不如垂直模型精确。垂直大模型：在特定领域表现出色，具有高度的专业性，但泛化能力相对有限，不易迁移到其他领域。 2.1.3. 资源消耗和效率 通用大模型：由于模型复杂且训练数据集庞大，通常需要大量的计算资源，包括高性能计算机和大规模存储。垂直大模型：相比之下，由于专注于特定领域，其模型结构和数据集相对较小，因此资源消耗较少，部署和维护成本也较低。 2.2. 互补性分析 2.2.1. 技术互补 通用大模型提供的基础语言理解和生成能力可以为垂直大模型提供初始化的知识库和预训练参数，加速垂直模型的训练过程。垂直大模型在特定领域的数据和专业知识可以反馈给通用大模型，帮助其更好地理解特定语境和术语，提升在该领域的性能。 2.2.2. 应用场景互补 当需要处理跨领域或多任务时，通用大模型的灵活性使其成为首选。在需要深入分析和处理特定领域数据的场景下，如医疗诊断或金融风险评估，垂直大模型的专业性和精确性则更具优势。 2.2.3. 发展趋势互补 随着技术的进步，通用大模型可能会变得更加智能和高效，能够处理更复杂的跨领域任务。同时，垂直大模型也将不断深化其在特定领域的应用，提供更精准、更专业的解决方案。 2.2.4. 小结 通用大模型和垂直大模型虽然在设计目标、应用范围、资源消耗等方面存在差异，但二者在技术上和应用场景中具有显著的互补性。未来，随着人工智能技术的不断发展，这两种模型有望在更多领域实现深度融合，共同推动AI技术的进步和应用领域的拓展。
3. 难点探究 大模型的应用确实离不开算力、数据和算法这三大支柱。针对这三大难点，以下是一些可能的解决方案：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe0ca869b7e9ccb595bd6881257ed6b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0526262a30dafe086a9bad5cfe2c890/" rel="bookmark">
			论Lambda架构及其应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：
2023年3月，我公司承担了本市教育局智慧教育云平台的项目，该平台旨在为教育机构和学生提供一个在线学习与教学的环境，包含课程管理、在线学习、资源共享、互动交流等功能。在项目中我担任系统架构师，全面负责项目的需求分析和架构设计等工作。本文以具体项目为例，主要论述了Lambda架构技术在项目中运用。Lambda 架构可分解为批处理层、速度处理层和服务层。批处理层负责周期性地处理累积的数据集，用以产生详尽的报告和分析；速度处理层复杂实时数据处理，迅速响应用户需求并提供即时反馈；服务层负责整合批处理层产出的批量视图和速度处理层提供的实时数据视图，形成统一的数据视图供教育管理者使用。自2023年12月成功上线以来，该项目已经获得了客户的高度评价。
正文：
随着信息技术的迅猛发展，教育行业迫切需要采纳云计算、大数据、人工智能等前沿技术，以提高教育品质和效率，并实现教育资源的优化与共享。为此，某市教育局在2023年3月启动了智慧教育云平台项目，项目预计耗时10个月。我司有幸承担了此项任务，并委派我担任系统架构师，负责主导需求分析和架构设计等关键工作。
该项目由课程管理、在线学习、资源共享和互动交流四大部分组成。课程管理模块运用技术手段对课程内容、教学活动、学生进度和评估进行有效组织与监管；在线学习模块则通过互联网提供教育活动，使学生能够随时随地访问课程内容与资源；资源共享功能则便于在教育环境中共享教学材料、工具和信息；而互动交流模块则促进教师、学生及其他利益相关者之间的沟通与合作，对构建积极的学习社区至关重要。系统平台采用B/S架构设计，基于JavaEE多层框架进行开发，实现了前后端分离。后端采用SpringBoot和Mybatis框架构建，同时利用Zookeeper提供服务注册、配置管理、分布式锁和队列等分布式应用的核心功能。数据库方面，我们选择了MySQL分布式集群，而缓存则交由Redis集群处理。负载均衡方面使用了Nginx。前端应用则基于VUE框架。
在项目设计阶段，我们深入理解了Lambda架构的三个核心层次：批处理层、速度处理层和服务层。批处理层的职责是维护不可变的数据主集，并执行批量计算，它能够处理庞大的历史数据集，确保数据处理的精确性。速度处理层则专注于实时数据流的快速处理，迅速生成数据视图，以缩短查询响应时间。服务层的作用是融合来自批处理层和速度处理层的数据，形成一个统一的查询接口，它既利用了批处理层的精确性也利用了速度处理层的即时性，为用户提供一致性的数据视图。Lambda架构的优势在于其速度处理层的数据会被记录在批处理层，从而在批处理层重新计算时修正任何错误，确保数据的最终一致性。然而，Lambda架构也存在一些缺点，例如需要对相同的业务逻辑进行两次编程，分别对应批量和流处理，这无疑增加了开发的复杂性和维护难度。
智慧教育云平台面临着访问数据量大和实时性要求高的挑战。经过团队成员开会讨论，我们一致认为项目应该使用Lambda 架构技术。具体设计如下。
一 、批处理层
在智慧教育云平台中，批处理层的关键职能是周期性地处理累积的数据集，用以产生详尽的报告和分析。学生考试成绩及相关信息，如个人信息、考试时间、科目等，将被汇总并存储于Hadoop分布式文件系统（HDFS）中。为了减少对日常操作的影响，平台常在系统负载较低的时段，如夜间，安排MapReduce的任务来分析这些数据。 MapReduce作业分为两个阶段：Map阶段负责将成绩数据集分解成键值对，如将每个学生的成绩映射为以“学生ID”为键的记录；Reduce阶段则对这些键值对进行汇总，计算如平均成绩、最高分、最低分以及不同成绩区间的学生分布等统计数据。这些分析结果将用于生成涵盖个人、班级、学校乃至整个区域的详细成绩报告，为教育管理者提供教学效果和资源分配的综合视图。 此外，批处理层还能分析学生成绩的时间序列，揭示成绩随时间的变化趋势，比较不同学期的成绩，以及评估学生在不同学科或教学单元中的表现。
二、速度处理层
在智慧教育云平台中，速度处理层承担着实时数据处理的职责，以便迅速响应用户需求并提供即时反馈。学生答题时，他们的答案选择和提交时间被平台即时捕获，并通过前端API以数据流的方式传送至速度处理层。该层采用Flink等流处理技术，对流入的数据进行快速分析，如计算答题正确率和统计答题速度。基于这些实时分析结果，系统能够即时生成反馈。教师可以实时查看哪些问题学生普遍答错，以便立即调整教学方法，重点讲解难题。此外，速度处理层还能支持课堂互动，如实时投票和测验，将学生答案展示在大屏幕上，提升课堂互动性和趣味性。教师还能通过平台的仪表板实时监控学生的答题情况，包括答题进度和正确率，从而了解学生对课堂内容的理解程度，并据此调整教学内容。速度处理层甚至可以根据学生的答题表现，提供个性化学习资源，如为在特定概念上频繁出错的学生推荐额外的学习材料或练习题，帮助他们更深入地理解和掌握相关知识点。
三、服务层
在智慧教育云平台中，服务层扮演着中枢角色，负责整合批处理层产出的批量视图和速度处理层提供的实时数据视图，形成统一的数据视图供教育管理者使用。管理者发起查询时，服务层即时从两个视图中提取并融合数据，确保所提供信息的时效性和全面性。为适应不同管理者的需求，服务层还提供定制化的数据展示，支持按学校、年级、科目等多维度展示数据。通过这一综合视图，教育管理者能够全面审视教师的教学效果，包括长期教学成果和即时课堂表现，实现对教学质量的精确评估。同时，管理者可以利用学生的学习进度报告，及时发现并解决学生在学习中遇到的难题。此外，服务层的长期与实时数据分析功能，为教育政策的制定提供了数据支持，有助于教育部门调整课程设置、改进教学方法等。智慧教育云平台的前端应用，结合Power BI等可视化工具，为管理者提供了一个交互式的仪表板，使其能够轻松探索不同的数据视图，进行深入分析。
自2023年12月启动以来，我们的系统已稳定运行近半年，获得了相关部门与用户的广泛好评。在开发和试运行阶段，我们积极应对并解决了项目中的问题。针对Lambda架构中可能出现的数据一致性问题，我们采取了以下措施：首先，在数据流入批处理层和速度处理层之前，我们实施了数据校验，以确保数据的质量和一致性；其次，我们定期对速度层的数据进行与批处理层数据的对比，并重新计算，以维护数据的一致性；此外，我们尽可能在两个处理层中采用相同的逻辑和算法，以减少数据差异。通过这些措施，我们有效降低了数据一致性问题的发生。
Lambda架构通过结合批处理层和速度处理层，能够同时处理实时数据和批量历史数据，满足智慧教育云平台对于数据处理的多样化需求。Lambda架构的设计允许系统在处理大量数据时进行水平扩展，适用于智慧教育云平台可能面临的数据量增长和用户请求增加的情况。在智慧教育云平台中，Lambda架构可以应对由于学生数量增加和教学活动产生的大量数据，提供了有效的数据处理和分析框架。在开发过程中，我们致力于掌握并应用Lambda架构的最佳实践，这不仅增强了我们解决复杂问题的能力，也提升了我们的专业技术水平。我们坚信，持续学习和不懈努力是我们持续进步的动力源泉。面对未来的挑战，我们将保持积极乐观的态度，依靠团队合作和不断的创新，追求卓越，勇往直前。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4eaa3e127b5c44a5c8f9b003f960c460/" rel="bookmark">
			天才程序员周弈帆 | Stable Diffusion 解读（四）：Diffusers实现源码解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文来源公众号“天才程序员周弈帆”，仅用于学术分享，侵权删，干货满满。
原文链接：Stable Diffusion 解读（四）：Diffusers实现源码解读
接上一篇文章[天才程序员周弈帆 | Stable Diffusion 解读（三）：原版实现源码解读(篇幅略长，建议收藏！)-CSDN博客]，我们来学习Stable Diffusion在Diffusers中的实现。
本文用到的Stable Diffusion版本是v1.5。Diffusers版本是0.25.0。为了提升可读性，本文对源代码做了一定的精简，部分不会运行到的分支会被略过。
1 Diffusers Diffusers是由Hugging Face维护的一套Diffusion框架。这个库的代码被封装进了一个Python模块里，我们可以在安装了Diffusers的Python环境中用import diffusers随时调用该库。相比之下，Diffusers的代码架构更加清楚，且各类Stable Diffusion的新技术都会及时集成进Diffusers库中。
由于我们已经在上篇文章中学过了Stable Diffusion官方源码，在学习Diffusers代码时，我们只会大致过一过每一段代码是在做什么，而不会赘述Stable Diffusion的原理。
1.1 安装 安装该库时，不需要克隆仓库，只需要直接用pip即可。
pip install --upgrade diffusers[torch] 之后，随便在某个地方创建一个Python脚本文件，输入官方的示例项目代码。
from diffusers import DiffusionPipeline import torch pipeline = DiffusionPipeline.from_pretrained("runwayml/stable-diffusion-v1-5", torch_dtype=torch.float16) pipeline.to("cuda") pipeline("An image of a squirrel in Picasso style").images[0].save('output.jpg') 运行代码后，"一幅毕加索风格的松鼠图片"的绘制结果会保存在output.jpg中。我得到的结果如下：
在Diffusers中，from_pretrained函数可以直接从Hugging Face的模型仓库中下载预训练模型。比如，示例代码中from_pretrained("runwayml/stable-diffusion-v1-5", ...)指的就是从模型仓库https://huggingface.co/runwayml/stable-diffusion-v1-5中获取模型。
如果在当前网络下无法从命令行中访问Hugging Face，可以先想办法在网页上访问上面的模型仓库，手动下载v1-5-pruned.ckpt。之后，克隆Diffusers的GitHub仓库，再用Diffusers的工具把Stable Diffusion原版模型文件转换成Diffusers支持的模型格式。
git clone git@github.com:huggingface/diffusers.git cd diffusers python scripts/convert_original_stable_diffusion_to_diffusers.py --checkpoint_path &lt;src&gt; --dump_path &lt;dst&gt; 比如，假设你的模型文件存在ckpt/v1-5-pruned.ckpt，你想把输出的Diffusers的模型文件存在ckpt/sd15，则应该输入：
python scripts/convert_original_stable_diffusion_to_diffusers.py --checkpoint_path ckpt/v1-5-pruned.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4eaa3e127b5c44a5c8f9b003f960c460/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b8591bf57b8e2224b5027ad37443153/" rel="bookmark">
			Python中的并发编程（5）PyQt 多线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PyQt 多线程 1 卡住的计时器 我们定义了一个计时器，每秒钟更新一次显示的数字。此外我们定义了一个耗时5秒的任务oh_no，和按钮“危险”绑定。
当我们点击“危险”按钮时，程序去执行oh_no，导致显示停止更新了。
import sys import time from PyQt6.QtCore import QTimer from PyQt6.QtWidgets import ( QApplication, QLabel, QMainWindow, QPushButton, QVBoxLayout, QWidget, ) class MainWindow(QMainWindow): def __init__(self): super().__init__() self.counter = 0 layout = QVBoxLayout() self.l = QLabel("Start") b = QPushButton("DANGER!") b.pressed.connect(self.oh_no) layout.addWidget(self.l) layout.addWidget(b) w = QWidget() w.setLayout(layout) self.setCentralWidget(w) self.show() # 定时器，每1秒更新一次文本 self.timer = QTimer() self.timer.setInterval(1000) self.timer.timeout.connect(self.recurring_timer) self.timer.start() def oh_no(self): time.sleep(5) def recurring_timer(self): self.counter += 1 self.l.setText("Counter: %d" % self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b8591bf57b8e2224b5027ad37443153/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36874d9dc013b54d15bff0b0f15d1297/" rel="bookmark">
			Redis--18--Redis Desktop Manage下载与安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 Redis Desktop Manage1.官网下载https://redis.io/insight/ 2.安装方法3.使用方法3.1.进入RedisDesktopManager的主界面3.2 新建连接3.3 支持操作 Redis Desktop Manage Redis Desktop Manager是一款简单快速、跨平台的Redis桌面管理工具，也被称作Redis可视化工具；支持命令控制台操作，以及常用，查询key，rename，delete等操作。 1.官网下载 https://redis.io/insight/ 2.安装方法 3.使用方法 3.1.进入RedisDesktopManager的主界面 3.2 新建连接 连接到本地或公共redis服务器在“连接设置”的第一个选项卡上，输入有关您正在创建的连接的常规信
名称 - 新连接的名称（例如：my_local_redis）
主机 - redis-server主机（例如：localhost）
端口 - redis-server端口（例如：6379）
Auth - redis-server身份验证密码
3.3 支持操作 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf68f47f4e93c42fbb443ac70e3a7680/" rel="bookmark">
			【C&#43;&#43;/STL】：优先级队列的使用及底层剖析&amp;&amp;仿函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 💡前言一，优先级队列的使用二，仿函数1，什么是仿函数2，仿函数的简单示例 三，优先级队列的底层剖析 💡前言 优先队列(priority_queue)是一种容器适配器，默认使用vector作为其底层存储数据的容器，在vector上又使用了堆算法将vector中元素构造成堆的结构，因此priority_queue就是堆，所有需要用到堆的位置，都可以考虑使用priority_queue。注意：默认情况下priority_queue是大堆。
注意：使用优先级队列要包含头文件 &lt; queue &gt;。
一，优先级队列的使用 代码实现如下：
这里的建堆一般有两种方式：
(1) 一种是一个一个push进vector容器再进行向上调整建堆
(2) 另一种是直接用迭代器区间构造直接建堆(推荐用这种)。
#include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;functional&gt; using namespace std; void test_priority_queue() { vector&lt;int&gt; v = { 6,0,3,5,4,7,9,1,2,8 }; //默认升序 //priority_queue&lt;int&gt; pq(v.begin(), v.end()); //一个一个尾插建堆 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq; for (auto e : v) { pq.push(e); } //迭代器区间构造，直接建堆 //priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pq(v.begin(), v.end()); while (!pq.empty()) { cout &lt;&lt; pq.top() &lt;&lt; " "; pq.pop(); } cout &lt;&lt; endl; } int main() { test_priority_queue(); return 0; } 注意：优先级队列默认的大堆，降序排列，如果要升序，就要换仿函数。下图中第三个模板参数就是传仿函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf68f47f4e93c42fbb443ac70e3a7680/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fbcf14d72935e810acf7f8aa10bb26c/" rel="bookmark">
			信息化建设中的安全底座：实施等保的法律依据与实际效益分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 随着信息技术的飞速发展，信息化建设已成为推动社会进步和经济发展的关键引擎。然而，伴随而来的是日益复杂多变的网络安全威胁，这对国家的安全、社会的稳定以及公众的利益构成了严峻挑战。在此背景下，信息安全等级保护（简称“等保”）作为我国网络安全的基本国策与核心制度，为信息化建设提供了坚实的“安全底座”。本文旨在探讨实施等保的法律依据及其带来的实际效益。
一、实施等保的法律依据
1. 国家政策法规支撑：等保制度源于《中华人民共和国计算机信息系统安全保护条例》等法律法规，旨在规范和加强信息安全保障工作。近年来，《网络安全法》、《数据安全法》等相关法律的出台，进一步明确了网络运营者的安全责任，为等保实施提供了坚实的法律基础。
2. 国家标准与规范：以《信息安全技术 网络安全等级保护基本要求》为核心的一系列国家标准，为不同等级的信息系统提供了详细的安全保护要求和技术指南，确保了等保工作的标准化和规范化。
3. 政策导向与要求：国家网络安全等级保护政策要求网络运营者根据信息系统的重要程度，分等级进行安全规划、建设、测评与维护，确保信息系统的安全防护能力与系统重要性相匹配。
二、实施等保的实际效益
1. 增强风险抵御能力：通过等保的实施，组织能够系统性地识别安全风险，采取针对性的防护措施，有效抵御外部攻击和内部泄露，降低信息安全事件的发生概率。
2. 提升合规性与信誉：满足等保要求不仅是法律义务，也是提升企业或机构合规形象、增强公众信任的关键。对于涉及敏感信息处理的行业尤为重要，如金融、医疗、政府机构等。
3. 优化成本效益：等保的实施促使组织更加科学合理地分配安全资源，避免过度或不足投资，实现安全成本与风险控制的最佳平衡。
4. 促进业务可持续性：通过构建稳定可靠的信息安全环境，等保有助于保障业务连续性，减少因安全事件导致的服务中断，维护组织的核心竞争力。
5. 适应监管变化：随着网络安全法律法规的不断完善，等保2.0等新标准的推出，持续的等保工作有助于组织快速适应监管要求的变化，避免法律风险。
结论
信息化建设的深入发展，使得信息安全成为不可忽视的战略要素。实施等保不仅符合国家法律政策要求，更是提升组织自身安全能力、维护业务稳定运行、赢得市场信任的关键举措。面对不断演变的网络安全威胁，积极构建并持续优化等保体系，是每一家致力于信息化建设的单位不可回避的责任与选择。通过深入理解和实践等保，我们能够共同构筑起信息化时代的安全长城。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e9028f0a13ab5661b0064a675979bda/" rel="bookmark">
			【自然语言处理系列】手动安装和测试Spacy中en_core_web_sm模型的详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：本教程旨在为自然语言处理（NLP）初学者提供一个详细的指南，用于手动安装流行的NLP库Spacy及其英语模型en_core_web_sm。文章将逐步指导您如何安装Spacy库、查看其版本，确定并下载适合的en_core_web_sm模型版本，以及如何正确安装并测试这些组件确保它们正常工作。完成本教程后，您将能够使用Spacy进行基本的NLP任务，例如分词、命名实体识别和依赖关系解析。
目录
一、安装Spacy
二、查看本地的spacy版本
三、确定要下载的 en_core_web_sm版本
四、手动下载 en_core_web_sm文件
五、安装en_core_web_sm文件
六、测试是否成功安装
一、安装Spacy pip install -U spacy -i https://pypi.tuna.tsinghua.edu.cn/simple 二、查看本地的spacy版本 通过pip list查看本地的spacy版本，这一步很重要，因为安装的en_core_web_sm要和spaCy版本兼容。
下方是我电脑上本地的spacy版本，版本为3.-7.5
三、确定要下载的 en_core_web_sm版本 进入下方链接，找到与自己scpay版本对应的en_core_web_sm版本
en_core_web_sm · Releases · explosion/spacy-models (github.com) 笔者本地的Spcay版本是3.7.5，故选择其兼容的3.7.0版本的en_core_web_sm
怎么判断兼容不兼容呢？看下方图片红色框框圈起来的部分，这部分提示这个3.7.0版本的en_core_web_sm适用于3.7.0到3.8.0之间的spaCy。
四、手动下载 en_core_web_sm文件 分别点击下方的这两个downloads，分别下载.gz文件和.whl文件。
五、安装en_core_web_sm文件 确定好.gz文件和.whl文件这两个文件所在的路径，比如我这里的路径是：D:\spacy中的en_core_web_sm。那么就打开cmd,通过cd命令进入到这个路径（目录）下，如下图：
然后输入如下代码：
注意不要完全照抄下方代码，要把en_core_web_sm对应的版本号修改一下，比方你是3.6.0版本的en_core_web_sm，就改成pip install en_core_web_sm-3.6.0.tar.gz
pip install en_core_web_sm-3.7.0.tar.gz 安装之后，显示如下图就是安装成功了！ 六、测试是否成功安装 输入如下代码，如果正常运行，就再次验证安装成功了！
import spacy nlp = spacy.load("en_core_web_sm")#读进英文模型 doc = nlp('Weather is good, very windy and sunny. We have no classes in the afternoon.') # 分词 for token in doc: print (token) 运行结果如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a080bee44408271835e6fe00826a27a2/" rel="bookmark">
			学习笔记——动态路由——RIP（距离矢量协议）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、距离矢量协议
1、距离矢量协议
矢量行为：协议收到一个路由之后，查看是否可以加入到本地的路由表中，如果可以加入，则可以传递，如果不可以加入，则无法传递。 距离矢量路由协议
RIP基于距离矢量算法(又称为Bellman-ford)，路由以矢量(Distance,Direction)的方式通告。
周期性更新：每个路由器周期性地向直接相连的其他路由器发送自己的路由表。
2、路由泛洪
泛洪路由表：路由器将从邻居学习到的路由放进自己的路由表中，然后将路由表所有路由信息在通告给其他路由器，直到整个网络学习到。
1)路由表形成
RIP启动时，初始路由表仅包含直连路由，然后通过设备互相学习更新路由表。假设两个路由器R1和R2相连，路由表形成过程如下：
首先，RIP协议启动之后，R1会向相邻路由器广播一个请求报文；
其次，R2收到R1请求报文后，将自己的RIP路由表封装在响应报文中，以组播形式发出；
最后，R1从R2响应报文中学习新的路由，更新到自己的路由表中。
2)路由信息更新
定期更新：每隔30秒通过UDP 520端口以广播方式向邻居路由器发送一个路由更新包。
触发更新：网络拓扑发生变动，路由器会立即发送一个更新信息个邻居路由器，并以此产生出发更新通知它们的邻居路由器。
因此，当网络出现故障时，要经过较长的时间才能将信息传达所有路由器，即坏消息传播慢。
路由学习过程：路由器学习直连路由。(C代表直连路由)(下图)
所有路由器均配置RIP。更新周期30秒到，路由器会向邻居发送路由表。(下左图)
再过30秒，第二个更新周期到了，再次发送路由表。(上右图)
3、路由环路
路由环路：是指网络中产生矛盾的路由条目，导致数据包在网络中不断地循环传输，始终到达不了目的地的现象。
当192.168.3.0网络突然出现故障时，Router3中对应的路由信息被删除，Router2需要等待定时器超时才会删除该路由，在定时超时前，Router2仍认为192.168.3.0可达。
此时，若Router2先向Router3发送更新信息，则情况如(下图)：RIP路由环路产生示意图
1)Router2向Router3发送更新报文，报文中包含目的网络为192.168.3.0的路由信息；
2)Router3收到更新报文，学习192.168.3.0网络的路由，认为通过Router2可以到达192.168.3.0
3)此时，Router2中去往192.168.3.0的下一跳为Router3，Router3中去往192.168.3.0的下一跳为Router2，形成路由环路。
整个华为数通学习笔记系列中，本人是以网络视频与网络文章的方式自学的，并按自己理解的方式总结了学习笔记，某些笔记段落中可能有部分文字或图片与网络中有雷同，并非抄袭。完处于学习态度，觉得这段文字更通俗易懂，融入了自己的学习笔记中。如有相关文字涉及到某个人的版权利益，可以直接联系我，我会把相关文字删除。【VX：czlingyun 暗号：CSDN】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f05b3276322475a1b33f28aa9a010f16/" rel="bookmark">
			springboot easyexcel导入/导出excel自定义时间格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当使用java的easyExcel进行excel导入和导出时，如何接收表格中的各种自定义时间格式字符串转成LocalDateTime及导出时如何将LocalDateTime转为各种时间格式字符串。
一、 新建自定义时间格式转换类 package com.logwing.wyadmin.framework.excel; import com.alibaba.excel.converters.Converter; import com.alibaba.excel.enums.CellDataTypeEnum; import com.alibaba.excel.metadata.GlobalConfiguration; import com.alibaba.excel.metadata.data.ReadCellData; import com.alibaba.excel.metadata.data.WriteCellData; import com.alibaba.excel.metadata.property.ExcelContentProperty; import org.apache.poi.ss.usermodel.DateUtil; import java.time.LocalDateTime; import java.time.ZoneId; import java.time.format.DateTimeFormatter; import java.time.format.DateTimeFormatterBuilder; import java.time.temporal.ChronoField; import java.util.Date; public class LocalDateTimeConverter implements Converter&lt;LocalDateTime&gt; { @Override public Class&lt;LocalDateTime&gt; supportJavaTypeKey() { return LocalDateTime.class; } @Override public CellDataTypeEnum supportExcelTypeKey() { return CellDataTypeEnum.STRING; } @Override public LocalDateTime convertToJavaData(ReadCellData&lt;?&gt; cellData, ExcelContentProperty contentProperty, GlobalConfiguration globalConfiguration) { if(null==cellData) { return null; } LocalDateTime result=null; if(cellData.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f05b3276322475a1b33f28aa9a010f16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c8a9f97988472b90ebadb50d39da918/" rel="bookmark">
			（超简单、超易懂、超详细）算法精讲(四十五)： RSA加密算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你也喜欢C#开发或者.NET开发，可以关注我，我会一直更新相关内容，并且会是超级详细的教程，只要你有耐心，基本上不会有什么问题，如果有不懂的，也可以私信我加我联系方式，我将毫无保留的将我的经验和技术分享给你，不为其他，只为有更多的人进度代码的世界，而进入代码的世界，最快捷和最容易的就是C#.NET,准备好了，就随我加入代码的世界吧！
一、算法简介 RSA加密算法是一种非对称加密算法，其中RSA是由三位数学家（Ron Rivest、Adi Shamir和Leonard Adleman）的名字命名的。RSA算法使用两个密钥：公钥和私钥。公钥用于加密数据，私钥用于解密数据。
RSA算法的核心是基于大数的因数分解难题。该难题是指将一个大数分解为其质数因子的过程，在当前计算机技术下，对于非常大的数，该过程是非常时间复杂度的。因此，RSA算法的安全性基于该因数分解问题的难解性。
在RSA加密算法中，公钥是由两个数构成的：模数和公钥指数。模数是两个大质数的乘积，公钥指数是一个小于模数的数。私钥也由两个数构成：模数和私钥指数。私钥指数是一个与公钥指数对应的数。
发送方使用公钥对数据进行加密，并将加密后的数据发送给接收方。接收方使用私钥对加密数据进行解密，从而得到原始数据。
RSA算法被广泛应用于数据加密和数字签名等安全领域。它提供了一种安全可靠的加密方式，能够在公共网络上进行安全通信。然而，由于其计算量大，RSA算法在加密大量数据时效率较低。因此，在实际应用中，通常将RSA算法与对称加密算法结合使用，以提高数据加密效率。
二、为什么要学习RSA加密算法： 2.1 保护数据安全
RSA是一种非对称加密算法，具有很高的安全性。通过学习RSA算法，可以了解如何使用公钥和私钥进行加密和解密，从而保护敏感数据的安全。
2.2 理解加密原理
学习RSA算法可以帮助我们理解非对称加密的原理。了解RSA算法的工作流程和数学原理，可以更好地理解其他加密算法和密码学的基本原理。
2.3 应用于实际场景
RSA算法在实际应用中非常广泛，如网络通信、数据传输、数字签名等。学习RSA算法可以让我们了解如何在实际场景中应用加密算法，提高信息安全性。
2.4 加强计算机科学知识
学习RSA算法需要一定的数学基础和计算机科学知识，例如大数运算、模运算等。通过学习RSA算法，可以拓宽计算机科学知识，提升自己的专业水平。
三、RSA加密算法在项目中有哪些实际应用： 3.1 数据传输安全 RSA算法可以用于保护网络通信过程中的数据安全，例如在网上银行、电子商务平台等应用中，使用RSA算法对通信数据进行加密和解密，确保数据在传输过程中不被窃取或篡改。
3.2 数字签名 RSA算法可以用于生成数字签名，用于验证数据的完整性和真实性。在实体认证和数据验证的场景中，RSA算法可以用于生成和验证数字签名，确保数据的可靠性。
3.3 密钥交换 RSA算法可以用于在非安全通信渠道上安全地交换密钥。通过使用RSA算法，通信双方可以在公开信道上交换公钥，然后使用对方的公钥加密共享密钥，从而实现安全的密钥交换。
3.4 文件加密 RSA算法可以用于对文件进行加密和解密，以保护文件的机密性。文件加密可以用于保护敏感数据，例如个人隐私信息、商业机密等。
3.5 身份认证 RSA算法可以用于身份认证，例如在登录系统时，用户可以使用RSA算法生成身份证书，服务器可以使用此证书验证用户的身份。
四、RSA加密算法的实现与讲解： 4.1 RSA加密算法的实现 // 加密方法 static byte[] Encrypt(byte[] data, RSAParameters publicKey) { using (RSA rsa = RSA.Create()) { rsa.ImportParameters(publicKey); return rsa.Encrypt(data, RSAEncryptionPadding.OaepSHA256); } } // 解密方法 static byte[] Decrypt(byte[] data, RSAParameters privateKey) { using (RSA rsa = RSA.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c8a9f97988472b90ebadb50d39da918/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eef5c37b9effe06cdcc1512e9c5f85e6/" rel="bookmark">
			贝壳找房基于Flink&#43;Paimon进行全量数据实时分组排序的实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：本文投稿自贝壳家装数仓团队，在结合家装业务场景下所探索出的一种基于 Flink+Paimon 的排序方案。这种方案可以在实时环境对全量数据进行准确的分组排序，同时减少对内存资源的消耗。在这一方案中，引入了“事件时间分段”的概念，以避免 Flink State 中冗余数据对排序结果的干扰，在保证排序结果准确性的同时，减少了对内存的消耗。并且基于数据湖组件 Paimon 的聚合模型和 Audit Log 数据在数据湖内构建了拉链表，为排序结果提供了灵活的历史数据基础。内容主要分为以下四个部分：
背景现有的实时分组排序的一些做法及其特点Flink+Paimon进行全量数据实时分组排序总结与展望 一、背景 家装家居业务，作为贝壳“一体三翼”战略的重要组成部分，在房屋回归居住属性的大背景下，正在迅猛发展。在过去的2023年中，家装家居业务合同额为133亿元，可比口径同比增长93%；净收入取得74%的可比口径同比增幅，达到109亿元。其中，北京和杭州的合同额突破20亿，上海全年合同额超10亿，合同额超过5亿的城市共有6个。此外，家装家居业务在更多城市跑出正循环，全年有11个城市实现运营利润为正。
在家装业务中，随着设计师对客户需求和期望的逐步了解和把握，一个装修项目往往会产生多份合同。在合同签订的过程中，业务上期望通过合同的顺序、内容、金额等信息实时匹配相应的风控和运营策略，以实现智能额度、动态尾款等等功能，为客户提供更加优质的服务体验。要实现这些功能，就需要对全量合同数据进行分组排序。然而，在实时场景中，这是一个不小的挑战。为了解决这个问题，我们进行了一系列的探索和尝试。
二、现有的实时分组排序的一些做法及其特点 首先，结合以往的经验，我们梳理了现有在实时链路中进行分组排序的方法。
第一种方法是基于Flink引擎自带的排序能力进行分组排序。该方法实现简单，逻辑直观，但是比较依赖内存资源。随着数据量的增长，排序任务所需要的内存资源会不断增加，这会给本就紧张的内存资源带来更大的压力。
第二种方法是基于离线处理结果和实时处理结果的融合计算分组排序。这种方法可以在一定程度上缓解内存压力，并且复用已有的离线计算结果。然而，同时维护并迭代离线和实时两套数据链路，会带来不小的运维压力。
第三种方法则是通过Redis、Hbase等NoSQL组件来存储和累计实时排序结果。这种占用内存少，不依赖批处理结果。然而，由于无法提供类似事务的ACID保证，存在数据脏读，进而伴随一定程度的统计误差。
通过上诉分析可以看到，在实时链路中，现有的分组排序方案在处理全量数据时，很难同时兼顾内存资源、数据链路和数据准确性三个方面。
三、Flink+Paimon进行全量数据实时分组排序 在实时数据的处理中，我们希望在需要保证数据时效性的前提下，避免依赖额外的批处理逻辑，同时减少对内存的消耗。
以Paimon为代表的数据湖组件的兴起为我们提供了全新的思路。它具备强大的数据存储和加工能力，并且能够顺滑地与Flink引擎配合，进一步扩大了Flink生态的实时处理领域的领先优势。
接下来，我们将详细介绍基于Flink+Paimon进行全量数据实时排序的新方式。整体思路可以概括为两个核心步骤：第一步，利用Flink引擎接收增量流入的数据，依托其State在内存中对数据进行排序，并将排序结果存储到数据湖中；第二步，从数据湖中读取历史时点的累计结果，结合第一步得到的内存排序结果一起计算得出最终的准确结果。
这两个步骤循环配合，互为起止，形成了一个完整的数据处理流程。为了方便表述说明，在介绍第一步的时候，我们假设第二步所产出的数据已经就绪。而在介绍第二步的时候，我们将展开讲解究竟如何产出了第一步所依赖的数据。
3.1基于历史数据的实时分组排序 在不引入额外的批处理逻辑，并且不把全量数据保留在内存中的前提下，想要实现分组排序，需要解决两个问题。其一，需要引入其他组件暂存结果，并且需要保证Flink引擎对于暂存结果的写入和读取不能同时针对同一条记录，否则会造成脏读；其二，未及时过期的Flink State数据与暂存结果之间不能出现重叠，否则会造成双算，导致结果偏高。
我们借鉴了Flink引擎中的滚动窗口思路，引入一个“事件时间分段”的概念，将实时数据根据事件时间分段，以得到准确的分组排序结果。
接下来，我们举个例子来具体说明数据的处理过程。现在假设一个项目A，它在历史上已经签约过两份合同，分别为C1和C2，它们的签约时间对应为T1和T2。实时数据中新流入一条合同签约记录C3，对应的时间为T3。将事件时间进行取整处理后，我们得到它们分别归属于起点为TG1和TG2的两个时间分段内。
SQL代码可以参考如下样例：
select project_id -- 项目id ,contract_id -- 合同id ,sign_time -- 签约时间 ,FROM_UNIXTIME(UNIX_TIMESTAMP(sign_time,'yyyy-MM-dd HH:mm:ss')/(24*60*60)*(24*60*60) ,'yyyy-MM-dd HH:mm:ss' ) as event_time_group_start_point -- 事件时间分段起点 from default_catalog.default_database.mysql_project_contract_table -- 项目合同信息 接下来，在Flink SQL的排序代码中，将项目id和事件时间段的起点一同作为分组主键，对数据按照事件时间的进行排序。SQL代码可以参考如下样例：
insert into paimon_catalog.paimon_db.dwd_project_contract_memory_result_table -- 实时数据排序结果 ​ select project_id -- 项目id ,contract_id -- 合同id ,sign_time -- 签约时间 ,event_time ,event_time_group_start_point -- 事件时间分段起点` ,DENSE_RANK() over (PARTITION BY project_id ,event_time_group_start_point ORDER BY event_time asc) as mem_rn -- 实时数据排序结果 from paimon_catalog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eef5c37b9effe06cdcc1512e9c5f85e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10b9359a41c420e7beb0c495db792c9b/" rel="bookmark">
			Chrome开发者工具学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开开发者工具：
可以通过在网页上点击右键并选择“检查”来打开。 或者使用快捷键Ctrl + Shift + I（在Windows/Linux上）或Command + Option + I（在Mac上）。 界面概览：
熟悉DevTools的基本面板，如“Elements”（元素）、“Console”（控制台）、“Sources”（源代码）、“Network”（网络）、“Performance”（性能）、“Memory”（内存）、“Application”（应用）、“Security”（安全）和“Audits”（审计）等。 Elements（元素）面板：
用于检查和编辑DOM元素。可以实时看到对HTML和CSS的更改. Console（控制台）面板：
用于打印日志、错误和警告信息。可以执行JavaScript代码。 Sources（源代码）面板：
用于查看和编辑网页的JavaScript文件。设置断点和调试代码。 Network（网络）面板：
监控网页的网络请求和响应。分析加载资源的性能。 Performance（性能）面板：
记录和分析网页的性能，如加载时间、渲染时间等。 Memory（内存）面板：
用于检测内存泄漏和分析内存使用情况。 Application（应用）面板：
查看和管理存储在本地的应用程序数据，如Cookies、本地存储等。 Security（安全）面板：
检查网页的安全问题，如HTTPS证书、混合内容等。 Audits（审计）面板：
用于对网页进行性能、安全性和可访问性等方面的审计。 移动设备模拟：
使用DevTools模拟移动设备，测试响应式设计。 性能分析：
使用Performance面板记录网页的运行情况，分析性能瓶颈。 断点和调试：
在Sources面板中设置断点，逐步执行代码，调试JavaScript。 代码调试技巧：
学习如何使用DevTools的各种调试功能，如监视表达式、调用栈、作用域变量等。 网络条件模拟：
在Network面板中模拟不同的网络条件，如2G、3G等，测试网页在不同网络环境下的表现。 跨设备测试：
使用Remote Devices功能测试网页在不同设备上的表现。 自定义和快捷操作：
学习如何自定义DevTools的设置，以及使用快捷键提高效率。 访问性检查：
使用Lighthouse等工具检查网页的访问性。 持续学习和实践：
随着Web技术的发展，持续学习新的工具和技巧。 通过实践和不断探索，你可以更深入地了解和掌握Chrome开发者工具的各种功能。此外，官方文档和在线教程也是学习的好资源。
Application（应用）面板的重点内容 Chrome的"Application"（应用）面板提供了对网页应用的深入洞察，包括对存储、数据库、缓存、服务工作者、APIs等的访问和操作。以下是"Application"面板的一些重点内容：
存储（Storage）:
显示和管理Web Storage，包括localStorage和sessionStorage。可以查看、添加、修改或删除存储条目。 Cookies:
查看和管理文档的Cookies。可以查看每个Cookie的详细信息，包括名称、值、域、路径、过期时间等。 数据库（Databases）:
访问和操作IndexedDB数据库。可以查看数据库内容、执行事务、查询数据等。 缓存（Cache）:
检查和分析Service Workers创建的缓存。可以查看缓存条目、大小和状态。 服务工作者（Service Workers）:
管理服务工作者的生命周期，包括注册、注销和调试。查看服务工作者的状态（如激活、等待、运行）和相关事件。 APIs:
访问和管理网页使用的Web APIs，如Web Audio API、Web MIDI API等。可以查看API的使用情况和状态。 后台同步（Background Sync）:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10b9359a41c420e7beb0c495db792c9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b0a0c028b21695a6c61be57ca192ab1/" rel="bookmark">
			Rust Web开发入门指南：构建安全高效的Web应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💂 个人网站:【 摸鱼游戏】【神级代码资源网站】【工具大全】🤟 一站式轻松构建小程序、Web网站、移动应用：👉注册地址🤟 基于Web端打造的：👉轻量化工具创作平台💅 想寻找共同学习交流，摸鱼划水的小伙伴，请点击【全栈技术交流群】 引言 随着Rust语言的流行和成熟，它作为一门系统级的编程语言，在Web开发领域也逐渐展现出其独特的优势。本文将带你从零开始，介绍如何使用Rust语言进行Web开发，包括选择合适的Web框架、处理HTTP请求、数据库操作以及编写RESTful API。我们将主要以Actix-web作为示例框架，演示如何构建一个简单但完整的Web应用。
一、准备工作 在开始之前，确保你的系统已经安装了Rust编程语言的工具链。你可以通过以下命令检查和安装：
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh 安装完成后，通过以下命令验证安装：
rustc --version cargo --version 接下来，我们使用Cargo初始化一个新的Rust项目：
cargo new rust_web_app cd rust_web_app 二、选择Web框架：Actix-web Actix-web 是一个基于Actor模型的高性能Web框架，非常适合构建并发和高吞吐量的Web应用。它提供了异步处理、中间件支持和强大的路由系统，使得开发者能够快速搭建稳健的Web服务。
添加依赖 编辑项目的 Cargo.toml 文件，添加 actix-web 作为依赖：
[dependencies] actix-web = "4.0" 编写基本的Web应用 接下来，我们编写一个简单的Hello World应用，并启动一个HTTP服务器来处理请求：
use actix_web::{get, web, App, HttpServer, Responder}; // 定义处理器函数 #[get("/")] async fn index() -&gt; impl Responder { "Hello, Rust!" } #[actix_web::main] async fn main() -&gt; std::io::Result&lt;()&gt; { // 启动HTTP服务器并绑定到本地地址的8080端口 HttpServer::new(|| { App::new() // 注册路由 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b0a0c028b21695a6c61be57ca192ab1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76ad538f38585a770fd8528b092be9e0/" rel="bookmark">
			AI全能助手：革新未来生活的智能伙伴
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💂 个人网站:【 摸鱼游戏】【神级代码资源网站】【工具大全】🤟 一站式轻松构建小程序、Web网站、移动应用：👉注册地址🤟 基于Web端打造的：👉轻量化工具创作平台💅 想寻找共同学习交流，摸鱼划水的小伙伴，请点击【全栈技术交流群】 引言 在当今科技飞速发展的时代，人工智能（AI）已成为推动社会进步的关键力量之一。AI全能助手作为人工智能技术的重要应用，正在不断改变我们的生活方式。本文将深入探讨AI全能助手的定义、功能、应用场景以及未来的发展趋势，并通过示例代码展示其实际应用，全面展示其在现代社会中的重要性和潜力。
一、AI全能助手的定义与功能 AI全能助手是一种综合性智能系统，利用机器学习、自然语言处理和大数据分析等技术，为用户提供全方位的智能服务。它不仅能够理解和执行复杂的指令，还可以通过学习用户的行为和偏好，提供个性化的建议和解决方案。
主要功能包括：
语音识别与自然语言处理： 通过语音识别技术，AI全能助手可以准确理解用户的语音指令，并利用自然语言处理技术进行对话和互动。信息检索与数据分析： AI全能助手能够快速获取并分析海量信息，为用户提供精准的答案和建议。任务管理与自动化： 它可以帮助用户管理日常任务，如日程安排、提醒事项、电子邮件处理等，提高工作效率。智能家居控制： 通过与智能家居设备的联动，AI全能助手可以实现对家中各种设备的远程控制，如灯光、空调、安防系统等。个性化推荐： 基于用户的历史数据和行为分析，AI全能助手可以提供个性化的推荐服务，如新闻、音乐、购物等。 二、AI全能助手的应用场景 AI全能助手的应用场景非常广泛，涵盖了日常生活的方方面面。以下是几个典型的应用场景：
家庭生活： AI全能助手可以帮助用户管理家务，如提醒倒垃圾、自动订购日用品等。同时，它还能通过语音指令控制智能家居设备，提升家庭生活的便利性和舒适度。工作场所： 在办公环境中，AI全能助手可以充当虚拟秘书，帮助用户安排日程、记录会议纪要、筛选邮件等，极大地提高工作效率。健康管理： AI全能助手可以监测用户的健康数据，如步数、心率、睡眠情况等，并提供健康建议，帮助用户养成良好的生活习惯。教育领域： AI全能助手可以作为学生的学习助手，提供个性化的学习方案、解答问题、推送学习资源，辅助教师进行教学管理。智能客服： 在服务行业，AI全能助手可以作为智能客服，24小时在线解答用户问题，提升客户满意度和服务效率。 三、AI全能助手的技术实现 为了更好地理解AI全能助手的实际应用，以下是一个基于Python的简单示例，展示如何构建一个基本的语音识别和自然语言处理的助手。
1. 语音识别 首先，我们需要一个语音识别的功能，可以使用SpeechRecognition库来实现：
import speech_recognition as sr def recognize_speech_from_mic(): recognizer = sr.Recognizer() microphone = sr.Microphone() with microphone as source: recognizer.adjust_for_ambient_noise(source) print("Listening...") audio = recognizer.listen(source) try: print("Recognizing...") text = recognizer.recognize_google(audio) print(f"Recognized Text: {text}") return text except sr.RequestError: print("API unavailable") except sr.UnknownValueError: print("Unable to recognize speech"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76ad538f38585a770fd8528b092be9e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c77d91f185c6d0c0787c728ae273088/" rel="bookmark">
			微服务 | Springboot整合GateWay&#43;Nacos实现动态路由
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、简介 路由转发 + 执行过滤器链。
​ 网关，旨在为微服务架构提供一种简单有效的统一的API路由管理方式。同时，基于Filter链的方式提供了网关的基本功能，比如：鉴权、流量控制、熔断、路径重写、黑白名单、日志监控等。
基本功能如下：
统一入口：暴露出网关地址，作为请求唯一入口，隔离内部微服务，保障了后台服务的安全性鉴权校验：识别每个请求的权限，拒绝不符合要求的请求动态路由：动态的将请求路由到不同的后端集群中 2、gateway核心概念 路由(Route)：由一个ID，一个目标URI(最终路由到的url地址)，一组断言(匹配条件判断)和一组过滤器定义。如果断言为真，则路由匹配。
断言(Predicate)：通过断言匹配http请求中的任何内容(请求头、请求参数等)，如果匹配成功，则匹配断言所在路由。
过滤器(Filter)：在请求前后执行业务逻辑，比如鉴权、日志监控、流量控制、修改请求头、修改响应等。
3、路由 spring: cloud: gateway: routes: - id: manager	# 路由唯一标识 uri: lb://manager_server	# 路由指向目的地URL或服务名，客户端请求最终被转发到的微服务 predicates: - Path=/manager/** # 断言：以manager开头的请求都负载到manager_server服务 filters: - RewritePath=/manager/(?&lt;segment&gt;.*), /$\{segment} # 过滤器：过滤掉url里的manager,例如http://ip:port/manager/test -&gt; http://ip:port/test order: 5	# 用于多个Route之间的排序，数值越小越靠前，匹配优先级越高 4、实战练习 1、项目结构 2、依赖 1、父依赖 &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;dubbo.version&gt;3.2.0-beta.4&lt;/dubbo.version&gt; &lt;spring-boot.version&gt;2.6.11&lt;/spring-boot.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Spring Boot --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;${spring-boot.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--springcloudalibaba--&gt; &lt;dependency&gt; &lt;groupId&gt;com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c77d91f185c6d0c0787c728ae273088/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/384ccc94df8cdbff1dc0566ba71d9f18/" rel="bookmark">
			昇思25天学习打卡营第1天|快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昇思25天学习打卡营第1天|快速入门
快速入门 进行了平台的注册，然后学习了基本介绍和快速入门部分。代码非常友好，涵盖了常见的数据集读取、数据预处理、网络模型搭建、网络训练和模型的保存读取内容，适合新手入门上手。准备跟着把全部内容走一遍，查缺补漏，毕竟我也只是一个老白。MindSpore看起来类似于torch，研究研究。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd2c485c3ab8942abbedba1027c6100c/" rel="bookmark">
			【python】PyQt5各个控件语法解析，QObject父子对象的操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨✨ 欢迎大家来到景天科技苑✨✨
🎈🎈 养成好习惯，先赞后看哦~🎈🎈
🏆 作者简介：景天科技苑
🏆《头衔》：大厂架构师，华为云开发者社区专家博主，阿里云开发者社区专家博主，CSDN全栈领域优质创作者，掘金优秀博主，51CTO博客专家等。
🏆《博客》：Python全栈，前后端开发，小程序开发，云原生K8S，人工智能，js逆向，App逆向，网络系统安全，数据分析，PyQt5，tkinter，Django，fastapi，flask等框架，linux，shell脚本等实操经验，网站搭建，数据库等分享。
所属的专栏：PyQt5桌面应用开发，零基础到进阶应用实战
景天的主页：景天科技苑
文章目录 PyQt5控件PyQt5 的控件类型 QObject类QObject的对象名称和属性QObject对象的父子关系操作 PyQt5控件 在PyQt5界面设计中，显示控件扮演着至关重要的角色。它们不仅负责向用户展示信息、图像、或其他多媒体内容，而且在很大程度上决定了应用程序的用户体验和交互效果。
通过精心设计和使用这些控件，可以创建出直观、易于操作且视觉上吸引人的界面。
控件也称控件对象，是 Qt用户界面上最基本的组件类型，也是构成用户界面的基本结构。
用户界面上显示的所有内容都是控件，例如按钮、标签、文本框，又如菜单栏、工具栏、状态栏，甚至整个窗口本身也是控件。
PyQt5 的控件类型 这些控件类型，总体上可以分类如下：
输入控件：
按钮：QPushButton（按键按钮），QToolButton（工具按钮），QRadioButton（单选框），QCheckButton（多选框），QCommandLinkButton（连接命令的按钮） 键盘输入控件：QlineEdit（单行输入），QTextEdit（多行输入），QPlainTextEdit（普通多行输入），QkeySequenceEdit（快捷键输入） 调节输入控件：QAbstractSpinBox（步长调节输入），QDateEdit（日期输入），QTimeEdit（时间输入），QDateTimeEdit（日期和时间输入） 数字调节框控件：QSpinBox（整型数字调节框），QDoubleSpinBox（浮点数字调节框） 滑动输入控件：QDial（旋转拖滑输入），QSlider（直线拖动输入），QScrollBar（滚动条），QRubberBand（橡皮筋拖拽） 下拉输入控件：QComboBox（组合框下拉选项），QSlider（直线拖动输入），QScrollBar（滚动条），QRubberBand（橡皮筋拖拽） 对话框输入控件：QDialog（对话框），QColorDialog（颜色对话框），QFileDialog（文件对话框），QFontDialog（字体对话框），QInputDialog（输入对话框） 日历控件：QCalendarWidget（日期选择部件） 展示控件：
内容显示控件：QLabel（显示框），QLCDNumber（液晶显示器），QProgressBar（进度条） 对话框显示控件：QMessageBox（信息提示框），QErrorMessage（错误提示框），QProgressDialog（进度提示框） 高级控件：
容器控件：QToolBox，QDialogButtonBox，QGroupBox，QMdiSubWindow 结构控件：QMainWindow，QTabwidget，QStackedWidget，QSplitter，QDockWidget 滚动控件：QTextBrowser，QScrollArea，QAbstractItemView，QMdiarea，QGraphicsView 辅助控件：QFocusFrame，QSizeGrip，QDesktopWidget 其它控件 这么多控件，有些相同的共性，有些不同的共性
这些类具有一定的继承关系
QObject 类是 PyQt5 的基类，也是所有控件的父类。
所有的 Qt 控件都是 QObject 类的子类，因此都继承了 QObject 类的特性，可以接收用户的输入事件，如鼠标和键盘输入，并可以在用户界面上显示控件内容，还可以存放其它控件。
要了解 QObject 类的子类，可以使用 “__subclasses__()” 将所有的子类打印出来。
from PyQt5.Qt import * print(QObject.__subclasses__()) 我们主要研究GUI有关的类，QWidget这个类
我们看下QWidget具备的子类
#递归列出某个类的子类
def getSubClasses(cls): for subcls in cls.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd2c485c3ab8942abbedba1027c6100c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dab9f7646f48f4912d72c56d11acced4/" rel="bookmark">
			【云计算】阿里云、腾讯云、华为云平台数据库对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、云数据库关键信息调研对比
二、详细功能
1、阿里云RDS
2、腾讯云RDS
3、华为云RDS
一、云数据库关键信息调研对比 云平台支持数据库部署对比支持功能备注阿里云
Mysql、Postgresql等
特有数据库：PolarDB，适配mysql
基础-单节点账号管理
数据库管理
白名单与安全组
数据库连接
监控和报警
备份和恢复
数据安全性
日志管理
参数设置
数据迁移及同步
操作审计 部署机型：
通用型：最小规格：1C2G；最大规格：16C64G。独享型更高上限，更优性能。
连接方式：不使用ip直连，使用数据库代理进行连接
高可用-主备双节点集群-一主多备多节点腾讯云
Mysql、Postgresql等
特有数据库：TDSQL-C，适配mysql
单节点实例监控
数据库管理
安全组
备份恢复
操作日志
一键迁移 部署机型：
通用型：最小规格：1C1G。
连接方式：使用vpc分配的ip直连
双节点 (一主一备)三节点 (一主两备)华为云
Mysql、Postgresql等
单机模式 备份恢复
连接管理
账号管理
数据库管理
日志管理
sql审计
参数修改
高级运维(监控)
数据库代理
内存加速
迁移数据库
部署机型：
通用型：最小规格：2C4G；最大规格：8C32G。独享型更高上限，更优性能。
连接方式：使用vpc分配的ip直连，可配置代理
主备模式 二、详细功能 1、阿里云RDS API接口体系：TransformDBInstancePayType_云数据库 RDS_API调试-阿里云OpenAPI开发者门户
对比自建数据库：https://help.aliyun.com/zh/rds/product-overview/competitive-advantages-of-apsaradb-rds-instances-over-self-managed-databases
支持的数据库：Mysql、Postgresql
特有数据库：PolarDB
连接方式：不使用ip直连，使用数据库代理进行连接
部署对比：通用型：最小规格：1C2G；最大规格：16C64G。独享型更高上限，更优性能。
机型规格示例： (4C8G 6000最大连接数，100G存储)
支持的功能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dab9f7646f48f4912d72c56d11acced4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/228/">«</a>
	<span class="pagination__item pagination__item--current">229/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/230/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>