<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5034f9ef2c52f25e075bc4e93e82162/" rel="bookmark">
			【Linux】Centos7 shell实现MySQL5.7 tar 一键安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🦄 个人主页——🎐个人主页 🎐✨🍁
🪁🍁🪁🍁🪁🍁🪁🍁 感谢点赞和关注 ，每天进步一点点！加油！🪁🍁🪁🍁🪁🍁🪁🍁
目录
一、安装下载
二、执行安装
一、安装下载 下载地址：
https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.44-el7-x86_64.tar.gz
脚本和tar包结构
my.cnf 配置文件
[root@windp-aio opt]# cat config/my.cnf [mysql] socket=/var/lib/mysql/mysql.sock # set mysql client default chararter default-character-set=utf8 [mysqld] socket=/var/lib/mysql/mysql.sock # set mysql server port port = 3306 # set mysql install base dir basedir=/usr/local/mysql # set the data store dir datadir=/usr/local/mysql/data # set the number of allow max connnection max_connections=200 # set server charactre default encoding character-set-server=utf8 # the storage engine default-storage-engine=INNODB lower_case_table_names=1 max_allowed_packet=16M explicit_defaults_for_timestamp=true [mysql.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5034f9ef2c52f25e075bc4e93e82162/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b86e48e55a061cf86685107a918d871/" rel="bookmark">
			C/C&#43;&#43;数据结构之链表题目答案与解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人主页：点我进入主页
专栏分类：C语言初阶 C语言程序设计————KTV C语言小游戏 C语言进阶
C语言刷题 数据结构初阶
欢迎大家点赞，评论，收藏。
一起努力，一起奔赴大厂。
目录
1.前言 2.题目解析
2.1 移除链表元素
2.2反转链表
2.3链表的中间结点
2.4链表中倒数第k个结点
2.5合并两个有序链表
2.6链表分割
3.结语
1.前言 在前面我们讲解了一些关于链表的内容，其中还有一些关于链表的习题，今天我们主要对这些题目进行解析。
2.题目解析 2.1 移除链表元素 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。
示例 1：
输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5] 示例 2：
输入：head = [], val = 1 输出：[] 示例 3：
输入：head = [7,7,7,7], val = 7 输出：[] 提示：
列表中的节点数目在范围 [0, 104] 内1 &lt;= Node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b86e48e55a061cf86685107a918d871/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20a9fc19d59d237583694749c2925bd8/" rel="bookmark">
			【MybatisPlus】对数据库中datetime类型字段的处理（获取与格式处理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库中Datetime类型字段可以对应Java实体类中的Date数据类型或LocalDateTime数据类型。但这两种数据类型直接却有着很大的区别，被用在不同的应用场景中。（一般推荐使用LocalDateTime，有更多的灵活性和功能）
private Date createTime; private Date updateTime; // 或者 private LocalDateTime createTime; private LocalDateTime updateTime; 一、Data数据类型与LocalDateTime数据类型的区别
Date数据类型属于java.util包，是Java的一个日期和时间类，它代表特定时刻的时间戳，存储的是自1970年1月1日以来的毫秒数，但不包含时区信息，对时区不敏感。且Date数据类型是可变的，可以通过setTime(long time)来设置时间戳。
LocalDateTime数据类型属于java.time包，是Java 8引入的新日期和时间API的一部分，它代表了一个日期和时间，但没有时区信息，若要处理时区信息可以使用ZonedDateTime类。而LocalDateTime数据类型不可变，一旦创建LocalDateTime对象，它的值将不会改变。若想要修改值，只能创建一个新的LocalDateTime对象。
LocalDateTime的基本使用可以看下面这篇文章：
【Java LocalDateTime】LocalDateTime获取时间信息、格式化、转换为数字时间戳https://blog.csdn.net/zxy2361380031/article/details/134344872
二、对时间类型数据输出信息的格式化
这里需要引入jackson依赖来format时间的数据类型：
&lt;!-- jackson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.15.3&lt;/version&gt; &lt;/dependency&gt; 方法一： （全局配置）
在springBoot的配置文件中添加以下代码可以实现全局配置：
# application.properties的配置如下: spring.jackson.date-format=yyyy-MM-dd HH:mm:ss # 时间格式 spring.jackson.time-zone=GMT+8 # 时区 # application.yaml的配置如下: spring: jackson: date-format: yyyy-MM-dd HH:mm:ss # 时间格式 time-zone: GMT+8 # 时区 方法二： （对字段分别设置）
通过对字段添加@JsonFormat注解来设置该字段的时间格式，比较繁琐，但更加灵活。
@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss",timezone="GMT+8") private LocalDateTime startTime; @JsonFormat(pattern = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20a9fc19d59d237583694749c2925bd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d587c917f57656bd49d4b6e8433ee30c/" rel="bookmark">
			前端 a链接 如何实现下载功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
标签 download
a 标签链接下载的实现
1. 整体流程
2. 实现步骤
3. 类图
4. 代码示例 download 使用注意点
1. 同源 URL 的限制
2. 不能携带 Header
Blob 转换
方法1. 用作 URL（blob:）
方法2. 转换为 base64（data:）
两种方法总结与对比
responseType
扩展阅读
1. Blob
2. URL.createObjectURL()
3. URL.revokeObjectURL()
4. FileReader.readAsDataURL()
前言 在中后台项目中，前端难免需要处理下载的逻辑，需要下载的内容包括但不限于图片、Excel表格、CSV文件、MP4文件、PDF文件、TXT文件、JSON文件、HTML文件等等。虽然下载的内容各式各样，但是下载的原理大同小异。下面来一起学习一下前端是如何处理下载的。
&lt;a&gt; 标签 download 这应该是最常见，最受广大人民群众喜闻乐见的一种下载方式了，搭配上 download 属性， 就能让浏览器将链接的 URL 视为下载资源，而不是导航到该资源。
如果 download 再指定个 filename ，那么就可以在下载文件时，将其作为预填充的文件名。不过名字中的 / 和 \ 会被转化为下划线 _，而且文件系统可能会阻止文件名中的一些字符，因此浏览器会在必要时适当调整文件名。
a 标签链接下载的实现 1. 整体流程 为了实现通过a标签链接下载文件，我们需要对a标签的href属性进行设置，使其指向文件的下载链接。具体步骤如下表所示：
下面我们将逐步介绍每个步骤需要做的事情，并提供相应的代码和注释。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d587c917f57656bd49d4b6e8433ee30c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69252e93be614fe6d97aaaa45a16666c/" rel="bookmark">
			使用github copilot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在的大模型的应用太广了，作为程序员我们当然野可以借助大模型来帮我们敲代码。
下面是自己注册使用github copilot的过程。
一、注册github copilot 1. 需要拥有github账号 ，登录github之后，点右侧自己的头像位置，下面会出现copilot的选项。
2. 注册github copilot，然后填写一些内容，使用paypal方法绑定自己的银行卡。这些可以参考文末的链接非常详细。我在操作的时候没有截图😅😅。
3. 在自己的IDE上安装github copilot插件，我这里使用的是VScode，在商店搜索 'github copilot'，点击安装，我这个是已经安装好了。
4. 然后它需要链接上你的github账号，然后就可以开心地使用了🌸🌸。
🎈🎈当github copilot正常使用后，可以把PayPal中的银行卡解绑，github copilot中的付费关闭，防止下个月扣费。
二、使用github copilot演示 5. 使用github copilot。
这里有一个简短的视频演示。
在写代码时，出现了github copilot的提示后，可以按Tab键直接使用提示的代码。如果是出现多行提示，只使用某几个单词使用 Ctrl + ➡️就可以。
6.使用github copilot chat。
找到小机器人的头像，点击它打开github copilot chat。 然后，在输入框中输入 “写一个正则判断是否为手机号码”。不得不说，用github copilot chat写一些小的功能太好用了，也是需要自己验证对错哦。 三、参考下文： 简单快速安全地试用Copilot-详细步骤 - 知乎 (zhihu.com)https://zhuanlan.zhihu.com/p/625479189
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c770ff90d2a3a8bf3721b7ec426b8a6b/" rel="bookmark">
			用趋动云GPU部署自己的Stable Diffusion
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：本文内容来自于对DataWhale的开源学习项目——免费GPU线上跑AI项目实践的学习，参见：Docs，引用了多处DataWhale给出的教程。
1.创建项目
1）进入趋动云用户工作台，在当前空间处选择注册时系统自动生成的空间（其他空间无免费算力）；
2）点击 快速创建，选择 创建项目，创建新项目；
3）填写项目名称及项目描述；镜像和数据集选择如下；
4）点击 确定，其余无需填写，右下角 创建 ，系统弹出 上传代码 的提示，单击 暂不上传，项目创建成功。如下图示：
2. 初始化开发环境实例
找到最右侧 开发--&gt; 初始化开发环境实例
按照下图进行选择
运行初始化中，约5~10分钟，当右侧的 网页终端 和 JupyterLab 不再是灰色时，表明工具注入成功。此时便可以在此开发环境中通过工具进行模型调优，详情参见下一步。
3.部署模型 初始化完毕，点击下图所示右侧 网页终端
在网页终端输入
若出现以下报错：换镜像源，可以用任务1的镜像源，然后再运行python launch.py指令（当然，你换其他源也都一样）
这里，用中科大的镜像源：
pip config set global.index-url https://mirrors.ustc.edu.cn/pypi/web/simple
当命令窗口出现如下两个网址时表示部署成功，可以复制右侧的外部访问网址访问webui
访问这个网址时，会出现一个登录页面，账号 qdy 密码123456
4.体验自己的stable diffusion： 登录进去后，输入prompt提示词,譬如：a cat或a girl,先简单测试一下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43ae508f914e6813952e0df19deec7ab/" rel="bookmark">
			常用SQL——IF介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在SQL中，`IF`语句用于根据条件执行不同的操作。下面是一个简单的教程，介绍如何在不同的数据库中使用`IF`语句。
1. MySQL中的IF语句：
```sql
IF(condition, true_value, false_value)
```
在MySQL中，`IF`函数接受一个条件表达式，如果条件为真，则返回`true_value`，否则返回`false_value`。
示例：
```sql
SELECT IF(score &gt;= 60, '及格', '不及格') AS result FROM students;
```
上述示例中，如果`score`列的值大于等于60，则返回'及格'，否则返回'不及格'。
2. SQL Server中的IF语句：
```sql
IF condition
BEGIN
-- true_value
END
ELSE
BEGIN
-- false_value
END
```
在SQL Server中，`IF`语句用于根据条件执行不同的代码块。如果条件为真，则执行`BEGIN`和`END`之间的代码块，否则执行`ELSE`后的代码块。
示例：
```sql
IF EXISTS(SELECT * FROM students WHERE score &gt;= 60)
BEGIN
SELECT '及格' AS result;
END
ELSE
BEGIN
SELECT '不及格' AS result;
END
```
上述示例中，如果`students`表中存在`score`大于等于60的记录，则返回'及格'，否则返回'不及格'。
3. PostgreSQL中的IF语句：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43ae508f914e6813952e0df19deec7ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1f88147a54634a50a152cfdd39d1f15/" rel="bookmark">
			@JsonFormat 注解的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot 中的 @JsonFormat 注解 1. 引言2. 简介3. 使用①引入依赖②添加注解 1. 引言 在前后端交互过程当中，往往需要后端返回前端所需要的日期类型数据，所以在将数据返回给前端时，可能会需要对日期类型进行格式化；
为更便捷的返回需要的数据，可以用 @JsonFormat 注解，其作用就是把DATE类型的数据转化成为我们想要的格式。
2. 简介 @JsonFormat 是Jackson中定义的一个注解，可以在数据返回前端时进行格式化；
例如前端需要的字符串格式的日期：“2023年10月31日 18时22分22秒”，则需要如下配置：
@JsonFormat(pattern = “yyyy年MM月dd日 HH时mm分ss秒”) private Date createTime; 解析后存入DB中的依然为：2022-10-31 18:22:22，而在查询时返回的数据就会被格式化为：“2023年10月31日 18时22分22秒”
注意：只有在将实体返回JSON格式数据时才会转换格式，其他时候日期格式不会被转换！
3. 使用 ①引入依赖 @JsonFormat 注解不是SPRING自带的注解，而是Jackson的注解，所以需要在Maven中导入jackson相关的依赖包；
情况一：非SpringBoot项目：
&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.12.6&lt;/version&gt; &lt;/dependency&gt; 情况二：SpringBoot项目：
spring-boot-start-web下已经包了Jackson的相关依赖，不需要再添加依赖！
②添加注解 在实体类中的属性上面使用 @JsonFormat 注解；
情况一：时间类型为 LocalTime 或 LocalDataTime：
只需要在属性上方定义时间类型即可；
@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss") private LocalTime createTime; @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss") private LocalDateTime createTime; 情况二：时间类型 Data：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1f88147a54634a50a152cfdd39d1f15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c4f95f7f9f0aa9d580a360cd8f1afd8/" rel="bookmark">
			royal tsx —— 一款Mac平台MobaXterm平替工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网链接
https://www.royalapps.com/ts/mac/features
通过安装标准插件的方式，支持ssh等功能，价格方面免费版支持10个连接，370买断
插件可选
Terminal (基于 iTerm2) 可连ssh/telnet/串口
File Transfer 支持 FTP/SFTP/SCP
楼主使用设置如下（建议在Default Settings修改，修改后创建的新连接均为此配置）：
1、ssh keep alive，保持ssh连接不会超时断开
2、日志记录
3、断开session时执行task，此处楼主添加了关闭session的task（需要提前创建），用于关闭串口session
串口配置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/938a7e79f4fff9bba30dcb25abf3f94c/" rel="bookmark">
			【Vue.js】Vue3全局配置Axios并解决跨域请求问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 文章目录 系列文章目录背景一、部署Axios1. npm 安装 axios2. 创建 request.js，创建axios实例3. 在main.js中全局注册axios4. 在页面中使用axios 二、后端解决跨域请求问题方法一 解决单Contoller跨域访问方法二 全局解决跨域问题 背景 对于前后端分离项目，前端和后端端口不能重复，否则会导致前端或者后端服务起不来。例如前端访问地址为： http://localhost:8080/ ，后端访问地址为 http://localhost:8081/ 。后端写好Controller，当用Axios访问该接口时，将会报错：
Access to XMLHttpRequest at ' http://localhost:8081/login ' from origin ' http://localhost:8080 ' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
本文内容从axios部署开始到解决跨域问题。
前端: Vue3；Axios 1.6.0 ；Element-Plus
后端：Springboot 2.7.14 这里提供两种解决方案，都是基于后端跨域访问的配置，前端不作任何允许跨域访问的设置，因为试过无效。
一、部署Axios Axios的基本介绍：
（1）axios 是一个基于promise的HTTP库，支持promise所有的API
（2）浏览器端/node端（服务器端）都可以使用，浏览器中创建XMLHttpRequests
（3）支持请求／响应拦截器
（4）它可以转换请求数据和响应数据，并对响应回来的内容自动转换成 JSON类型的数据
（5）批量发送多个请求
（6）安全性更高，客户端支持防御XSRF
1. npm 安装 axios npm install axios 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/938a7e79f4fff9bba30dcb25abf3f94c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b0d072aaf81d97591929f0c84f559e1/" rel="bookmark">
			Failed to parse multipart servlet request； nested exception is java.io.IOException；
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：一次开发中遇到一个springboot的异常：Failed to parse multipart servlet request; nested exception is java.io.IOException；
原因：为啥上传文件失败，从异常信息上看，说缺少目录[/tmp/tomcat.1428942566812653608.8090/work/Tomcat/localhost/ROOT]导致的。
分析：
1. 首先，我们应该知道，对于http POST请求来说，它需要使用这个临时目录来存储post数据。
2. 其次，因为该目录是挂在到/temp目录下的临时文件，那么对于一些OS系统，像centOS将经常删除这个临时目录，所有导致该目录不存在了。
解决方案：
1. 重启你的项目就可以了。
2. 在application.yml文件中设置multipart location ，并重启项目：
yml文件配置填写
3. 添加启动参数 -java.tmp.dir=/path/to/application/temp/，并重启。
其实这个问题一直存在，上面说的方法也没有很好的解决问题，我只是想记录一下这种情况。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30da780b08bc5f84b73ea9f31244b803/" rel="bookmark">
			Linux系统下安装配置 Nginx 超详细图文教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载Nginx安装包 nginx官网：nginx: downloadhttp://nginx.org/en/download.html
找到我们所需要版本，把鼠标移动到上面，右键打开链接进行下载
或者如果Linux联网，直接在Linux服务上使用wget命令把Nginx安装包下载到/usr/local/目录中
#下载nginx安装包 wget -c http://nginx.org/download/nginx-1.24.0.tar.gz 注意：如果没有wget命令，需要先安装：（centos版本命令：）yum install -y wget
二、安装Nginx 2.1、安装Nginx相关依赖 在线版：centos使用yum命令安装
#安装nginx所需要的依赖包 yum install -y gcc-c++	zlib zlib-devel	openssl openssl-devel pcre pcre-devel 离线版：下载所需依赖安装包，解压到指定目录下，使用下面命令安装
#解压安装包 tar -zxvf nginx依赖的环境安装包.tar 解压后的文件 #安装当前路径下所有安装包 rpm -Uvh *.rpm --nodeps --force 2.2、安装Nginx 找到Nginx的安装包进行解压
#解压安装包 tar -zxvf nginx-1.24.0.tar.gz 进入解压之后的nginx目录下：
#进入nginx目录 cd /usr/local/nginx-1.24.0 执行配置脚本，--prefix是指定安装目录
#执行配置脚本 --prefix是指定安装目录 ./configure --prefix=/usr/local/nginx 如果遇到报错“./configure: error: C compiler cc is not found”，如下图
解决：
yum -y install gcc gcc-c++ autoconf automake make
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30da780b08bc5f84b73ea9f31244b803/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e28dfc24167b5dcca664128fa2091e2/" rel="bookmark">
			算法&#43;数据结构=程序，程序员怎样才能学好算法?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 🌹欢迎来到爱书不爱输的程序猿的博客, 本博客致力于知识分享，与更多的人进行学习交流
算法秘籍 🚩🚩🚩点击直达福利前言写书的初衷及过程本书的内容《算法秘籍》王一博 著联合推荐购买方式🎁文末福利（切记关注+三连，否则抽奖无效） 🚩🚩🚩点击直达福利 🚩🚩🚩点击直达福利
前言 数据结构和算法是计算机科学的基石，是计算机的灵魂，要想成为计算机专业人员，学习和掌握算法是十分必要的。
不懂数据结构和算法的人不可能写出效率更高的代码。计算机科学的很多新行业都离不开数据结构和算法作为基石，比如大数据、人工智能等。底层开发中也需要使用非常多的数据结构和算法知识，以保证底层系统的稳定性和高效性。 计算机科学家尼古拉斯·沃斯在计算机领域有一句人尽皆知的名言：“算法+数据结构=程序”（Algorithms+Data
Structures=Programs）
所以数据结构和算法是程序员必须掌握的技能。
尤其是到一些大公司面试的时候，算法更是一个少不了的环节，熟练掌握数据结构和算法，可以开拓我们的视野，提高我们的逻辑思维能力，在写代码和分析官方源码的时候也非常有帮助。学习数据结构和算法的一个好处就是：学完之后知识基本不会过时，可以永远为我们所用。
大家都知道程序员需要不停地学习，因为知识更新太快，记得在笔者（博哥）上大学和后来开始工作的时候，非常喜欢研究官方源码和框架，如痴如醉，但很遗憾，现在很多框架都已被淘汰了，没被淘汰的也被更新得面目全非，然后还要不停地学习其他新的框架。
笔者一直在思考，能不能学习一种永不过时的知识。后来就接触了数据结构和算法，这一接触就是好多年，学的那么多知识依然没有过时。比如KMP算法是在1977年被联合发表的，那么多年过去了，这种算法依然没有被淘汰，如果是一个框架，基本上很难保证那么多年还能存在，就算存在也会有大量的更新，还是需要不停地学习。
写书的初衷及过程 笔者（博哥）具有10多年的开发经验，2017年开始做算法试题并在公众号发布试题讲解，经常游走在全球30多个算法网站之间，累计做题2000多道，对算法试题有自己独特的解题思路和技巧。
笔者写这本书的初衷是希望能够帮助更多的程序员快速学习算法，我们都知道算法在整个IT行业算是比较难的，之前有很过程序员通过公众号加笔者微信，请教关于算法的题，刚开始笔者一一进行了回复，后来随着咨询量越来越大，笔者意识到大家迫切地需要算法相关知识的系统指导。结合笔者过往的写作和从业经历，便着手写一本算法书籍，希望能欧帮助大家更好地学习算法，于是这本《算法秘籍》就诞生了。 这本书的知识覆盖范围全面，总共分为13个章节，先是详细介绍了常见的八大数据结构。后面都是我们比较常见的算法题，其中包括了二叉树的Morris遍历，KMP算法，马拉车算法等经典题型。 关于数据结构，大家普遍认为难度较大的可能就是图了，本书对图的分类，图的表示方式，图的遍历，以及图的各种经典算法比如迪杰斯特拉算法，普里姆算法，拓扑排序等都有大量介绍。 本书的内容 本书以Java为描述语言，介绍了计算机编程中常用的数据结构和算法，主要内容如下。
第1章：主要介绍了8种数据结构，包括数组、链表、队列、栈、散列表、树、堆、图，然后每种数据结构又有细分，比如介绍树的时候有完全二叉树、满二叉树、二叉搜索树、AVL树、红黑树、字典树、哈夫曼树、线段树、笛卡儿树等。图的介绍中也有一些经典的算法，比如迪杰斯特拉算法、弗洛伊德算法、普里姆算法和克鲁斯卡尔算法等。
第2章：介绍了几种经典排序算法，以及它们的稳定性分析。
第3章：主要介绍了一些位运算和常见操作符，还有一些简单的操作和使用技巧，如有限状态机和相关示例讲解。
第4章：介绍了和树有关的知识，比如树的遍历方式，包括DFS遍历、Morris遍历，以及BFS遍历等。
第5章：分析了递归的原理和示例练习，可以把它看作是对一棵树的DFS遍历。
第6章：主要介绍了回溯算法的使用，然后得出回溯算法的使用模板，以及一些经典示例，还有一些重复问题和不符合条件的修剪分支。
第7章：主要介绍贪心算法的使用和存在的不足。
第8章：分别介绍了相向双指针、同向双指针和快慢双指针的使用技巧，还有滑动窗口的介绍和使用模板，以及大小可变窗口、固定窗口、只增不减窗口等。
第9章：主要介绍了BFS和DFS的使用模板和示例练习。
第10章：主要介绍了一维前缀和与二维前缀和的使用。
第11章：介绍动态规划和一些经典问题的讲解，如背包问题、组合与排列问题等。
第12章：通过三国人物的故事，生动形象地介绍了并查集的使用、并查集优化、并查集路径压缩以及合并优化等。
第13章：介绍了其他一些经典算法，比如KMP算法、马拉车算法、算术表达式的运算、牛顿迭代法求平方根、Base64编码等。
《算法秘籍》王一博 著 算法是编程的基石，开发的核心。本书包含55个二维码，300多分钟视频，100多个知识点，50多个示例，适合程序员、计算机专业相关师生，以及对算法感兴趣的读者。这是一本关于数据结构和算法的书，以Java为描述语言，介绍了计算机编程中常用的数据结构和算法。全书共13章，讲述了常见的数据结构、排序算法、位运算、树、递归、回溯算法、贪心算法、双指针和滑动窗口、BFS和DFS、前缀和、动态规划、并查集、其他经典算法等知识。本书内容丰富，实用性强，通过示例练习和问题分析等方式，详细讲解了与算法有关的知识点。本书附赠视频讲解二维码，以及源代码。 联合推荐 算法是编程的基石。本书以生动的案例，结合作者的丰富经验，诠释了算法学习的直观与趣味性，对算法感兴趣的开发者具有极高的参考价值。强烈推荐！ – 思否联合创始人兼CTO 祁宁
算法是学习开发的基础和核心。博哥关注算法讲解多年，笔耕不辍，深得51CTO网友爱戴。本书是他多年经验的结晶，文笔精准、图文并茂，让枯燥的算法生动有趣，是广大初学者全面学习和了解算法的极佳读物！ – 51CTO首席内容官 杨文飞
这是一本非常实用的算法学习书，书中使用大量插图详细介绍了常见的数据结构和算法，内容全面，代码中也有大量注释，容易理解，值得推荐。 --开源中国创始人 红薯
购买方式 点击自行购买
🎁文末福利（切记关注+三连，否则抽奖无效） 🎁本次送书1~3本【取决于阅读量，阅读量越多，送的越多】👈⌛️活动时间：截止到2023-10-25 10:00✳️参与方式： 关注博主+三连（点赞、收藏、评论）🏆🏆 抽奖方式： 添加文章底部的联系方式，备注：参与送书 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a55d1d7f049aab3759559d76c3615052/" rel="bookmark">
			mac 安装 selenium &#43; chrome driver
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 使用 selenium 模拟浏览器渲染数据，需要依赖各浏览器的驱动才能完成，因此需要单独安装chrome driver
查看本地 chrome 浏览器的版本 可以看到我这里已经是 arm 架构下最新的版本了
下载对应的 chrome driver 访问下面的地址：
Chrome for Testing availability
然后在 Stable 中找到对应的 driver，然后点击地址下载
安装 chrome driver 并添加信任授权 解压完 zip 压缩包之后，拷贝二进制文件到 /usr/local/bin 目录下即可
# 拷贝 cp chromedriver-mac-arm64/chromedriver /usr/local/bin # 授权 cd /usr/local/bin xattr -d com.apple.quarantine chromedriver 在 python 中使用 # 安装 selenium pip install selenium 例子：
from selenium import webdriver driver=webdriver.Chrome() #启动谷歌浏览器 driver.get("http://www.zhihu.com") #访问一个网页 driver.quit() #退出浏览器 selenium 会新唤起一个chrome浏览器，并显示为调试模式，即为成功了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16e8b276a24a2146188f44dd7db7c0d9/" rel="bookmark">
			AIGC：使用生成对抗网络GAN实现MINST手写数字图像生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 生成对抗网络 生成对抗网络（Generative Adversarial Networks, GAN）是一种非常经典的生成式模型，它受到双人零和博弈的启发，让两个神经网络在相互博弈中进行学习，开创了生成式模型的新范式。从 2017 年以后，GAN相关的论文呈现井喷式增长。GAN 的应用十分广泛，它的应用包括图像合成、图像编辑、风格迁移、图像超分辨率以及图像转换，数据增强等。
1.1 背景 具有开创性工作的生成对抗网络原文由Goodfellow在2014年发表，当时深度学习领域最好的成果有很大一部分都是判别式模型（比如AlexNet），它们使用反向传播和dropout方法，让模型能够拥有一个良好的梯度结构，从而更迅速地收敛到一个较好的状态。而此时的生成式模型相比之下效果却并不是很好。
论文地址：https://arxiv.org/pdf/1406.2661.pdf
生成式模型的任务是：给你一组原始数据 ，请你生成一组新数据 ，使得这两组数据看起来“尽可能的相似”。而这个任务本质上就是让新数据的概率密度 尽可能地接近原始数据的概率密度 ，也就是说我们要学习 这个函数。传统的生成式模型会将 建模出来，并通过梯度下降优化模型中的参数，最终达到逼近的目的。从理论上来这个方法似乎挺好，但是真实情况下的概率分布往往是难以逼近的，在当时也并没有今天这么多的优化技术，所以实际上这个方法效果一般。
因此，本文作者提供了一种新的思路：我们不去直接逼近 ，而是添加一个判别器来判断生成出来的数据“像不像”原始数据，并且轮流训练这个判别器和生成器。假如这两个model最终都能收敛，那么收敛到的位置一定是生成效果“最像”，而判别效果“最准”的位置，我们直接取此时的生成器作为最终答案即可。原文中举了一个例子：生成器就好比一个造假币的团伙，判别器就好比警察，现在我们来看他们互相博弈的过程：
第一次，假币团伙没有经验，造了很多7块钱一张的假币，拿出去一花就被警察抓了。第二次，假币团伙学聪明了，造了很多看起来很正常的假币；警察一开始没有发现，但是在拿到了一张假币样本之后开始研究，发现了假币的一个缺陷（比如没有让盲人摸的手感线），于是向民众推广这种辨别假币的方法，最终假币团伙的假币就花不出去了。第三次，假币团伙修复了上面的缺陷，造了很多新假币；警察又开始寻找新的缺陷并推广……久而久之，假币团伙造的假币会越来越接近真币，而警察辨别假币的水平也会越来越高。就像生物学上的协同进化一样，这两个团体会在互相博弈中共同进步。 1.2 工作原理 GAN网络能够在不使用标注数据的情况下来进行生成任务的学习。GAN网络由一个生成器和一个判别器组成。生成器从潜在空间随机取样作为输入，其输出结果需要尽量模仿训练集中的真实样本。判别器的输入则为真实样本或生成器的输出，其目的是将生成器的输出从真实样本中尽可能分别出来。生成器和判别器相互对抗、不断学习，最终目的使得判别器无法判断生成器的输出结果是否真实。
1.2.1 GAN网络组成 GAN网络由生成器和判别器组成：
生成器。生成器学习如何生成看似合理的数据。对判别器来说，这些生成的实例会变成负面训练样本。判别器。判别器学习如何通过真实数据的学习来辨别出生成器生成的假数据。判别器将惩罚生成器生成的“不可理（假）”的数据结果。 1.2.2 判别器如何工作 判别器在生成对抗网络中，简单来说是一个分类器。该分类器尝试从生成器生成的假数据中识别真实数据。它可以使用任何适用于数据分类的网络架构。判别器在训练中使用误差反向传播机制来计算损失和更新权重参数。
判别器的训练数据有两处来源，
真实数据。真实数据实例，比如人的照片。在训练中，判别器把这些实例用作正面样本。虚假数据。生成器生成的实例。在训练中，判别器把这些实例用作负面样本。 上图中两个Sample的框就是这两种输入到判别器的样本。注意，在判别器训练时，生成器不会训练，即在生成器为判别器生成示例数据时，生成器的权重保持恒定。
在训练判别器时，判别器连接到两个损失函数。在训练时，判别器忽略生成器的损失而只使用判别器损失。在训练过程中，
判别器对真实数据和来自生成器生成的假数据进行分类。判别器的损失函数将惩罚由判别器产生的误判，比如把真实实例判定成假，或者把假的实例判定为真。判别器通过对来自于判别器网损失函数计算的损失进行反向传播。如上图。 1.2.3 生成器如何工作 生成对抗网络里的生成器，通过接受来自于判别器的反馈来学习如何创建假数据。生成器学习如何让（欺骗）判别器把它的输出归类为真实数据。
相对于判别器的训练，生成器的训练要求生成器与判别器有更加紧密的集成。生成器训练包含：
随机输入。神经网络需要某种形式的输入。通常，为了达到某种目的而输入数据，比如一个输入的实例用来进行分类任务或者预测。但当希望输出一整个全新的数据实例，用什么样输入数据呢？
最常见基础形式里，GAN使用随机噪音作为它的输入。然后，生成器将把随机噪音转换成有意义的输出。通过引入噪音，可以从不同分布形式的不同空间采样，让GAN生成一个宽域的数据
实验结果表明，不同噪音的分布不会产生太大影响。因此，可以选择相对较易的采样来源，比如，均匀分布。方便起见，噪音采样空间的维度一般小于输出空间的维度。注意，有些GAN变种不使用随机输入来形成输出。
生成器网络，负责把随机输入转换成数据实例。
判别器网络，负责把上一步生成的数据归类，判别器输出。
生成器的损失函数，负责惩罚企图蒙骗判别器失败的情况（即生成器生成的假数据，被识别器成功识破）。
1.3 训练 1.3.1 GAN训练的整个步骤 当训练开始，生成器生成一个些很明显的假数据，判别器能快速地学习如何识别出是不是假数据， 随着训练稳步推进，生成器更接近于能生成蒙骗判别器的输出数据。 最终，如果生成器训练得当，在识别真实和虚假方面，判别器变得差强人意，而且将开始把假数据分类为真实数据，识别的准确率降低。 1.3.2 使用判别器训练生成器 要训练神经网络，通过修改网络的权重来减少误差或者输出的损失。在GAN里却不同，生成器不直接连接到损失函数来试图影响损失，而是把生成的数据输出到判别器，而判别器会制造影响误差损失的输出。当生成器生成的数据被判别器成功识别成仿冒时，生成器损失函数会惩罚生成器。
另外，反向传播里也包含网络的额外处理。反向传播通过计算对输出的影响——更改后的权重在多大程度上影响输，来调整每个权重以使其在正确的方向上。但，生成器权重的影响取决于直接输出到判别器的权重的影响。因此，反向传播始于输出且穿过判别器回流到生成器。
在生成器训练时，不希望判别器更改，就像尝试击中一个移动目标，会让一个本身就麻烦的问题变得更加困难。所以，在训练生成器时使用如下流程，
随机噪音采样作为输入。生成器从采样的随机噪音采样里生成输出。让判断器判断上述输出是“真”或“假”，以此作为生成器的输出。从判别器的分类输出计算误差损失。穿过判别器和生成器的反向传播，从而获得梯度。使用梯度来更新生成器的权重。 这个流程是生成器训练的一个迭代。
1.3.3 交替训练 生成器和判别器有不同的训练流程，那么如何才能作为一个整体来训练GAN呢？GAN的训练有交替阶段，
判别器训练一个或者多个迭代。生成器训练一个或者多个迭代。不断重复1和2步来训练生成器和判别器。 在判别器训练的阶段，保持生成器不变。因为判别器训练会尝试从仿冒数据里分辨出真实数据，判别器必须学习如何识别生成器的缺陷。这就是经过完整训练的生成器和只能生成随机输出的未训练生成器的不同之处。
类似地，在生成器训练的阶段，保持判别器不变。否则，生成器像尝试击中移动目标一样，可能永远无法收敛。
这种往复训练使得GAN能够处理另外一些棘手的数据生成问题。开始于相对较简单的分类任务问题，从而获得一个解决生成难题的立足点。相反地，如果不能训练一个分类器来识别真实数据和生成数据的区别，甚至无法识别与随机初始化输出的区别，那么GAN的训练根本无法开始。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16e8b276a24a2146188f44dd7db7c0d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4030fec846131bef8256d9b068051cb/" rel="bookmark">
			微信小程序使用webview后点击左上角返回按钮一次性返回小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们来到webview标签对应的网页地址的时候，在该页面内进行几次跳转后，发现点击小程序左上角返回按钮返回的是上一次跳转的内容，并没有达到我们返回小程序的需求，而是要一直点，然后才能返回小程序。
我的情况是webview标签放在一个单独的页面下宽高100%占比显示，所以点击左上角的返回按钮应该回到webview标签所在页的上一个页面。
解决办法：
在webview目标页面的h5中添加如下代码 =&gt;
// 引入对应包 &lt;script type="text/javascript" src="https://res.wx.qq.com/open/js/jweixin-1.3.2.js"&gt;&lt;/script&gt; &lt;script&gt; $(function() { pushHistory(); // popstate事件为-只有用户点击浏览器倒退按钮和前进按钮，或者使用JavaScript调用back、forward、go方法时才会触发 window.addEventListener("popstate", function(e) { WeixinJSBridge.call('closeWindow'); // 关闭外链接窗口 wx.miniProgram.navigateBack(); // 返回小程序 }, false); function pushHistory() { var state = { title: "title", url: "#" }; // pushstate：前端用来向​history​中塞入一条历史记录，且必须是当前域名下的， // 执行完成后，地址栏会变成塞入的url但页面不会改变。 window.history.pushState(state, state.title, state.url); } }) &lt;/script&gt; 注： pushState 必须和popstate 配合使用 这样我们就可以通过点击左上角的返回按钮一次性返回小程序了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/285692f75d9226b771c4dd1ccc864420/" rel="bookmark">
			springboot&#43;avue医院绩效考核系统源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		医院绩效考核系统是一种以人力资源管理为基础，选用适合医院组织机构属性的绩效理论和方法，基于医院战略目标，构建全方位的绩效考评体系，在科学、合理的绩效管理体系基础上，采用科学管理的方法，如平衡计分卡的管理理念与方法，选取关键指标，对目标的执行进行管理、考核、分析、评价，最终结合科室经济效益，通过奖金分配这一经济杠杆实现职工的有效激励的医院运营管理平台。
一、系统开发环境 开发语言：java
技术架构：B/S架构
开发工具：maven、Visual Studio Code
前端框架：avue
后端框架：springboot、mybaits
数 据 库：MySQL
二、医院绩效考核系统功能 （一）、绩效管理
（二）、标准管理
（三）、基础数据
（四）、组织管理
（五）、权限设置
（六）、系统管理
（七）、系统日志
三、KPI KPI是关键绩效指标（Key Performance Indicators）的缩写，它是一种用于衡量员工或组织绩效的量化指标。这些指标通常与组织的目标和战略相关，并帮助管理层评估员工和组织的实际表现。KPI还可以为员工提供清晰的方向，使他们知道他们的工作如何影响组织的成功。它们通常被用作评估员工表现的重要工具，并在员工薪酬、奖励和其他职业发展机会方面发挥重要作用。
四、医院注重绩效管理的重要性 通过绩效管理加强团队合作与协作是促使医院高质量发展的重要组成部分。员工必须共同努力才能使医院取得成功。 团队合作对于每个医院、行业都至关重要，它可以提高其绩效和服务水平。有效的医院战略规划模型能够使员工团结一致，并让医院提供优质的护理，出色的病患服务和并达到更高的绩效。 同时，员工经过主观努力，为社会做出并得到承认的劳动成果，完成工作的数量、质量与效益等。在实施考核中，只有以绩效为导向，才能引导员工把工作的着眼点放在提高工作质量和效率，努力创造良好的社会效益和经济效益上来，从而保证医院目标的实现。
五、医院绩效考核与管理的核心问题 从企业的角度来看绩效考核是企业在既定的战略目标下，运用特定的标准和指标，对员工的工作行为及取得的工作业绩进行评估，并运用评估的结果对员工将来的工作行为和工作业绩产生正面引导的过程和方法，是绩效管理最重要的组成部分。
医院，尤其是公立医院，作为具有社会性、公益性特征的组织机构，在市场化需求下，其绩效考核与管理也是组织管理中必不可少的环节。
绩效管理的目的
对任何组织而言，绩效管理的出发点都是相同的；即，绩效管理为组织战略服务。医院的绩效管理工作，要以医院发展战略目标为基础，倘若“为了绩效而绩效”，不但会耗费大量的人力物力，更无法达到绩效管理的目的。
当前，医院绩效考核机制的建设，要解决两个核心问题：
1、要在投入相对不足的情况下，合理筹集有效激励所需的资金；
2、要建立一套较为科学、且相对公平的绩效考核与分配体系，有效调动医务人员的工作积极性。
实现目标的手段
面对提高医院运行经济效益的难题，通过控制成本与支出间接增加收入的方法只能有限度的增加经济效益，且过分控制则会导致人员减少、以及安全风险的增加；而通过提高医院运行效率，增加服务量并控制成本支出的方法难度较大，这就需要医院的管理者在了解医院收支运营现状的基础上，通过科学的方法寻找提高医院运行效率与效益的突破口，同时建立切实有效的绩效考核体系和激励分配机制，科学、客观、真实的反映科室业绩，建立灵敏的运营信息反馈机制，以修正、完善医院绩效管理工作。
总结：有效的绩效考核有赖于整个绩效管理工作的成功开展，而成功的绩效管理也需要有效的绩效考核来支撑。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67d84a741502f0efe0cdfc50bb95e8e9/" rel="bookmark">
			Flink与Spring Boot集成实践：搭建实时数据处理平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在当今数据风暴的时代，实时数据处理已经成为众多企业关注的热点。Apache Flink作为一个高性能、可扩展的实时计算框架，在实时数据处理领域占据着举足轻重的地位。Spring Boot则以其快速开发、简化配置而广受欢迎，将两者结合，我们可以快速地搭建起一个实时数据处理平台。本文将详细讲述如何将Flink应用集成到Spring Boot项目中，为你开启实时数据处理的大门。
整合 Apache Flink 与 Spring Boot 环境准备 在开始之前，请确保你的开发环境已经安装了以下软件：
JDK 1.8 或更高版本Maven 3.xApache Flink 1.xSpring Boot 2.x 创建项目 我们将使用 Maven 来构建我们的 Spring Boot 与 Flink 整合项目。首先，创建一个 Maven 项目，并在 pom.xml 中添加 Spring Boot 与 Flink 的依赖。
&lt;!-- 添加 Flink 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-streaming-java_2.11&lt;/artifactId&gt; &lt;version&gt;1.13.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加 Spring Boot 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; 配置 Flink 在 Spring Boot 项目中集成 Flink，首先需要在配置文件 application.yml 中配置 Flink 相关的参数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67d84a741502f0efe0cdfc50bb95e8e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d684bd5dc9fc3b905ab0be17d77d9939/" rel="bookmark">
			Python中的链表：手把手教你实现基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在许多编程语言中，链表都是一种基本的数据结构，它由一系列节点组成，每个节点都包含数据部分和指向下一个节点的引用。虽然Python的标准库中并没有直接提供链表，但我们可以很容易地自己实现它。本文将指导你如何在Python中实现单链表及其基本操作。
链表节点的定义 首先，我们需要定义一个节点（Node）类，它将作为链表的基本构建块。
class ListNode: def __init__(self, value): self.value = value self.next = None 创建链表 接下来，我们定义一个链表（LinkedList）类来管理这些节点。
class LinkedList: def __init__(self): self.head = None def append(self, value): """ 在链表尾部添加一个新的元素 """ if not self.head: self.head = ListNode(value) else: current = self.head while current.next: current = current.next current.next = ListNode(value) def prepend(self, value): """ 在链表头部添加一个新的元素 """ new_head = ListNode(value) new_head.next = self.head self.head = new_head 打印链表 为了验证我们的链表操作是否正确，实现一个方法来打印链表中的所有元素。
def display(self): """ 打印链表的所有元素 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d684bd5dc9fc3b905ab0be17d77d9939/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b720882cc3ec733533cc79fd6e27a64d/" rel="bookmark">
			电路布线问题动态规划详解（做题思路）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于电路布线问题，想必学过动态规划的大家都很清除。今天就来讲解一下这个动态规划经典题目。
目录 问题描述输入分析最优子结构代码 问题描述 在一块电路板的上、下2端分别有n个接线柱。根据电路设计，要求用导 线(i,π(i))将上端接线柱与下端接线柱相连，如图所示。其中π(i)是 {1,2,…,n}的一个排列。导线(i,π(i))称为该电路板上的第i条连线。对于任 何1≤i&lt;j≤n，第i条连线和第j条连线相交的充分且必要的条件是π(i)&gt;π(j)。 电路布线问题要确定将哪些连线安排在第一层上，使得该层上有尽可能 多的连线。换句话说，该问题要求确定导线集Nets={(i,π(i)),1≤i≤n}的最 大不相交子集。
输入 两行输入
第一行是一排接线柱的个数
第二行是上接线柱对应的下接线柱位置，即下文的p(i)
对于上图输入就是
10
3 1 2 4 7 9 5 6 10 8
分析 那么什么是最大不相交子集呢。咱们来一个一个字 的 扣含义。
首先最大就是字面意思最大的，最多的。
其次不相交也是字面意思，就是单纯的两条线不能有交点。
最后子集的定义是如果集合A的任意一个元素都是集合B的元素，那么集合A称为集合B的子集（通俗点说就是在给出的导线集合里面，挑选几条导线，这挑选的导线组成的集合就是子集）。
那么组合起来说的就是，在现有的线中挑选数量最多的导线且它们还不相交
我们发现这个题，好像不能从考虑最后一个步骤来推导了，我们好像还真不太好找出最后一个问题是什么。那么我们就换一种思路，回想以前的动态规划好像都是在数组中记录数值，供以后使用的而且都是一行一行的计算子问题。那我们先定义一个数组，考虑到有上下两排线，那就定义二维数组吧.。
设dp[i][j]表示前i个上接线柱和前j个下接线柱组成的问题的最优解包含的导线的数量(即前i个上接线柱和前j个下接线柱组成的集合的最大不相交子集中包含的导线数)
为了方便说明再来定义一些规则：
上接线柱集合（1，2，3，4…n）
下接线柱集合（p(1),p(2),p(3),p(4)…p(n)）
p(n)代表上层接线柱n对应的下层接线柱的编号。例如下图中上接线柱1，p(1)就是3
接下来以上图为例先从第一行来看，来找一下规律触发一下灵感
(第1步) i=1，j=1
(第2步) i=1，j=2
(第3步) i=1，j=3
唉突然发现此时，增加了一个，那就来想一想是什么原因让他增加的呢。我们发现当j&gt;=p(1)时他就增加了，接下来继续看。
(第4步) i=1，j=3
然后类似的一直到 j==10 的时候
… …
(第10步) i=1，j=10
发现第一行除了j==3的时候增加了一个，其他的j&gt;=p(1)的情况并没有增加为什么会这样呢？思考一下。因为我们的i是等于1的所以我们的dp[1][j]他最多只有一条线，我们上接线柱只包含了一个，所以他只能是小于等于一的数
这就给我们一个灵感我们可以根据i,p(i)的关系进行动态规划列出可能的情况加以分析
1.考虑当 i =1的时候
（1）j&lt;p(i):肯定是零
（2）j&gt;=p(i):他也肯定是一，因为这时最优解里面是空的，不用考虑香蕉🍌 （相交）的情况
2.考虑当 i&gt;1时
（1）j&lt;p(i):这时肯定还是不能包含这一条导线的，因为这一条导线的下接线柱没有被包含前 j 个里面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b720882cc3ec733533cc79fd6e27a64d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/568/">«</a>
	<span class="pagination__item pagination__item--current">569/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/570/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>