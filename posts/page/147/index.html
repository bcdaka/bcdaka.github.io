<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b202c9c3c95c0c35097f3858be67ddf0/" rel="bookmark">
			【C&#43;&#43;】—— 从 C 到 C&#43;&#43; （上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【C++】—— 从 C 到 C++ （上） 一、第一个C++程序二、命名空间2.1、命名的烦恼2.2、命名空间的定义2.2.1、定义命名空间2.2.2、命名空间的嵌套2.2.3、命名空间的同名 2.3、命名空间的使用2.3.1、指定命名空间的访问2.3.2、展开命名空间2.3.3、展开某个成员2.2.4、总结 三、C++的输入&amp;输出3.1、输入输出的基本概念3.2、C++ 的输出3.3、C++ 的输入 四、缺省参数4.1、缺省参数的定义4.2、缺省参数的使用4.3、全缺省与半缺省4.3.1、全缺省4.3.2、半缺省 4.4、注意事项4.5、缺省参数的应用 五、函数重载 一、第一个C++程序 我们来写一下我们的第一个 C++ 程序：
#include&lt;stdio.h&gt; int main() { printf("hello world\n"); return 0; } 大家是不是很奇怪，这 C++ 怎么一股 C 的味道
其实 C++ 是兼容 C 语言的。C++ 本来就是在 C 的基础上增加许多东西。
在写 C++ 代码时，要把文件后缀名改为 . c p p .cpp .cpp，这样 VS编译器 就会调用 C++ 的编译器
那我们想写一段 C++ 自己的代码怎么写呢？我们来看看。
#include&lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; "hello world" &lt;&lt; endl; return 0; } 这段代码可能有些小伙伴看不懂，没关系，看完本篇文章就解惑啦。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b202c9c3c95c0c35097f3858be67ddf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4a9045035287010e3e04f8cac84acca/" rel="bookmark">
			自适应键盘，自带隐藏键盘的输入框（UITextField）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在iOS开发中，输入框占据着举足轻重的地位。与安卓不同，iOS输入框经常面临键盘遮挡的问题，或者无法方便地取消键盘。为了解决这些问题，有许多针对iOS键盘管理的库，如IQKeyboardManager、TPKeyboardAvoiding和KeyboardManager等等。
然而，一些库可能对整个项目的侵入性较大，可能会影响到其他功能。有时，我们可能不希望某些输入框被这些库管理，虽然它们通常也提供了相应的解决方案，但有时会显得有些繁琐。
因此，我们可以考虑自己实现一个输入框，根据项目需求定制输入框的功能。这样做不仅轻量级，而且更加灵活。
实现 本篇博客将通过继承的方式，分别介绍如何自定义实现UITextFiled和UITextView。即使你的项目已经存在一段时间，也可以采用"黑魔法"的方式来实现这些功能。
我们首先明确两个要解决的问题：第一个是解决键盘遮挡输入框的问题，第二个是管理键盘的显示和隐藏。
UITextField 首先继承UITextField创建一个名为LATextField的类，然后通过重写它的init方法来处理上面要解决的两个问题。
解决键盘遮挡 为它添加一个属性，该属性是指当键盘出现时，需要跟随键盘上移的视图，我们可以通过遍历父图层的方式自动获取，也可以使用主动赋值的方式。
但属性一定要使用weak来修饰（子视图不能持有它的父视图）。
代码如下：
class LATextField: UITextField { /// 滑动的视图 weak var sliderView:UIView? override init(frame: CGRect) { super.init(frame: frame) } required init?(coder: NSCoder) { fatalError("init(coder:) has not been implemented") } } 在init方法中添加关于键盘出现和消失的监听，代码如下：
override init(frame: CGRect) { super.init(frame: frame) addNotification() } fileprivate func addNotification() { // 监听键盘的弹出和收起 NotificationCenter.default.addObserver(self, selector: #selector(keyboardWillShow), name: UIResponder.keyboardWillShowNotification, object: nil) NotificationCenter.default.addObserver(self, selector: #selector(keyboardWillHide), name: UIResponder.keyboardWillHideNotification, object: nil) } 键盘弹出后，我们可以通过通知的userinfo来获取键盘出现的动画时长，以及键盘的frame。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4a9045035287010e3e04f8cac84acca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62c20e95dc8f7784bbbe00a5120d57ab/" rel="bookmark">
			【数据结构】二叉树全攻略，从实现到应用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
💎所属专栏：数据结构与算法学习 💎 欢迎大家互三：2的n次方_
​
🍁1. 树形结构的介绍 树是一种非线性的数据结构，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的集合。把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。
以下是树的一些基本术语
节点的度：一个节点含有子树的个数
树的度：一棵树中所有节点度的最大值
叶子节点（终端节点）：度为0的节点
双亲节点（父节点）：一个节点的直接前驱节点
孩子节点（子节点）：一个节点（除了根节点）的直接后继节点
根节点：没有双亲节点的节点
🍁2. 二叉树的介绍 二叉树是每个节点最多有两个子树的树结构，通常称为左子树和右子树，正如名字一样，每一个节点最多有两个子树。
​
🍁2.1 二叉树的类别 二叉树是树形结构中最重要的一种类型，它有多种特殊形态，如：
完全二叉树：除了最后一层外，每一层都被完全填满，并且所有节点都尽可能地向左对齐。满二叉树：除了叶子节点外，每个节点都有两个子节点。平衡二叉树（如AVL树、红黑树）：任何节点的两个子树的高度最大差别为一。搜索二叉树（BST）：左子树上所有节点的值均小于它的根节点的值，右子树上所有节点的值均大于它的根节点的值。 ​
🍁2.2 二叉树的基本性质 对于任意一棵二叉树，深度为 k 的二叉树，最多有 2的k次方 - 1 个节点。
在任何一棵二叉树中，如果度为2的节点数为 n₂，叶节点数为 n₀，则有关系式 n₀=n₂+1。
任意一棵包含 n 个节点的二叉树的高度至少为 log₂⁡(n+1)（即完全二叉树的高度），最多为 n（即所有节点构成一个链表）。 在具有2 n 个节点的完全二叉树中，叶子节点的个数为 n，2n - 1个节点的完全二叉树中，叶子节点的个数为 n
🍁 2.3 二叉树的存储 二叉树可以通过链式存储和顺序存储的方式存储，这一节主要介绍链式存储
链式存储方式使用节点（Node）对象来表示二叉树的结构。每个节点包含数据部分和两个指针，分别指向其左子节点和右子节点。
例如使用孩子兄弟表示法存储树的效果如下图所示：
​
🍁3. 二叉树的实现 class TreeNode { int val; TreeNode left;//左孩子 TreeNode right;//右孩子 TreeNode(int x) { val = x; } } 🍁3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62c20e95dc8f7784bbbe00a5120d57ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2770c458bfb4b45986d2e73a69d5a8f6/" rel="bookmark">
			[C&#43;&#43;]——同步异步日志系统（6）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		同步异步日志系统 一、日志器模块设计1.1 同步日志器模块设计1.1.1 局部日志器建造者模式设计1.1.2 同步日志器基本功能测试 1.2 异步日志器模块设计1.2.1 单缓冲区设计1.2.2 异步工作线程的设计（双缓冲区思想）1.2.3 异步日志器设计1.2.4 异步日志器建造者模式设计1.2.5 异步日志器基本功能测试 一、日志器模块设计 功能：对前面所有功能进行整合，向外提供接口完成不同等级日志的输出。
管理的成员：
1.格式化模块对象
2.落地模块对象
3.默认的日志输出限制等级（大于等于限制输出等级的日志才能输出）
4.互斥锁（保证日志输出过程的线程安全，不会出现交叉日志）
5.日志名称（日志器的唯一标识，方便查找）
提供的操作：
debug等级日志的输出操作（分别封装日志消息LogMsg——各个接口日志等级不同）
info等级日志的输出操作
warn等级日志的输出操作
error等级日志的输出操作
fatal等级日志的输出操作
实现：
1.实现Logger基类（派生出同步日志器和异步日志器）
2.因为两种日志器的落地方式不同，需要将落地操作给抽象出来，不同的日志器调用不同的落地操作进行日志落地
3.模块关联过程中使用基类指针对子类日志器对象进行日志管理和操作
当前日志系统支持同步日志&amp;异步日志，它们的不同点在于日志的落地方式上不同：
同步日志器：直接对日志消息进行输出
异步日志器：先将日志消息放到缓冲区，然后异步线程进行输出
因此：日志器类在设计的时候，先要设计一个Logger的基类，在Logger基类的基础上，继承出同步日志器（SyncLogger）和异步日志器（AsyncLoggrr）。
1.1 同步日志器模块设计 同步日志器的设计和具体框架 /*日志器模块 1.先设计一个日志器的基类 2.根据基类派生出不同的日志器 */ #include "util.hpp" #include "level.hpp" #include "sink.hpp" #include "format.hpp" #include &lt;memory&gt; #include &lt;mutex&gt; #include &lt;atomic&gt; namespace logslearn { // 设计日志器基类 class Logger { // 公有 public: // 基类指针，用来控制继承子类的对象 using ptr = std::shared_ptr&lt;Logger&gt;; // 操作方法 // 构造日志消息对象并进行格式化，得到格式化后的日志消息字符串--然后进行落地输出，5个等级 void debug(const std::string &amp;file, size_t line, const std::string &amp;fmt, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2770c458bfb4b45986d2e73a69d5a8f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab237c240c40ed0dde7a973d41602962/" rel="bookmark">
			【C&#43;&#43;】vector的认识与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vector的认识与使用 认识vectorvector的使用Member functions（成员函数）构造函数(constructor)析构函数(destructor)赋值构造函数(operator=) Iterators（迭代器）beginendrbeginrend Capacity（容量）sizemax_sizeresizecapacityemptyreserve Element access（元素访问）operator[]atfrontback Modifiers（修饰符）assignpush_backpop_backinserteraseswapclear 认识vector vector：翻译过来是向量，矢量。但是学习过来，给我的感觉类似于顺序表，或者说是数组？？
std::vectortemplate &lt; class T, class Alloc = allocator &gt; class vector; // generic template class T代表的是一个类型，是成员变量。
allocator代表的是空间配置器。
vector是一个可以改变大小的代表数组的序列容器。类似于数组，vector使用连续的存储位置存储元素，意味着可以采用下标对vector的元素进行访问，并且和数组一样高效。但是不同于数组，其大小可以随着存储被容器自动处理而动态改变。本质来将，vector使用动态分配数组来存储它的元素。对于数组而言，当新元素被插入的时候，数组为了增加存储空间需要被重新分配大小。其做法是，分配一个新的数组，然后将全部元素移到这个数组。就时间而言，这是一个相对代价高的任务，vector并不会每次都重新分配大小。vector分配空间策略：vector会分配一些额外的空间以适应可能的增长，因为存储空间比实际需要的存储空间更大。不同的库采用不同的策略权衡空间的使用和重新分配。但是无论如何，重新分配都应该是对数增长的间隔下进行增长的，以至于在末尾插入一个元素的时候可以提供摊销的恒定时间复杂度。因此，vector占用了更多的存储空间，为了获得管理存储空间的能力，并且以一种有效的方式动态增长。与其他动态序列容器相比（deque，list，forward_list），vector在访问元素的时候更加高效，在末尾添加和删除元素相对高效。对于其他不在末尾的删除和插入操作，效率更低。比起list和forward_list统一的迭代器和引用更好。 vector的使用 在使用STL的三个境界：能用，明理，能扩展。
在介绍vector的时候，需要结合文档来学习：链接: vector
Member functions（成员函数） 构造函数(constructor) std::vector::vector构造vector构造一个vector容器，根据使用的构造函数版本初始化其内容default (1) explicit vector (const allocator_type&amp; alloc = allocator_type());
无参构造函数（默认构造）
构造一个没有任何元素的空的容器 vector&lt;int&gt; v1; fill (2) explicit vector (size_type n, const value_type&amp; val = value_type(),
const allocator_type&amp; alloc = allocator_type());
fill构造函数
构造一个有n个元素的容器，每一个元素都是val的值。 vector&lt;int&gt; v2(10, 1); vector&lt;char&gt; v3(5, 'x'); vector&lt;string&gt; v4(6, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab237c240c40ed0dde7a973d41602962/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b7050b296ede6e4f1572d22f307a8a5/" rel="bookmark">
			基于LORA的Stable Diffusion模型在虚拟试衣中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于LORA的Stable Diffusion模型在虚拟试衣中的应用 引言1.1 简述虚拟试衣的市场背景和技术需求1.2 介绍LORA与Stable Diffusion模型的结合在虚拟试衣领域的潜力1.3 强调基于LORA的Stable Diffusion模型如何改善用户体验 Stable Diffusion模型概览2.1 解释Stable Diffusion的基本原理2.2 描述Stable Diffusion在图像生成和处理方面的优势2.3 讨论Stable Diffusion模型的局限性及其在虚拟试衣场景中的适用性 LORA模型简介3.1 阐述LORA模型的设计理念和架构特点3.2 分析LORA如何减少微调大型预训练模型的成本3.3 探讨LORA模型在资源效率和性能之间的平衡 LORA与Stable Diffusion的融合4.1 描述LORA如何应用于Stable Diffusion以优化虚拟试衣体验4.2 分析LORA在Stable Diffusion中的具体实施细节4.3 讨论LORA如何提升Stable Diffusion模型的适应性和响应速度 虚拟试衣场景中的技术挑战5.1 列举虚拟试衣技术面临的常见问题5.2 分析基于LORA的Stable Diffusion如何应对这些挑战5.3 探索LORA模型在解决服装纹理和人体姿势变化方面的潜力 实验与结果6.1 设计实验以验证LORA+Stable Diffusion在虚拟试衣中的有效性6.2 展示实验结果，包括模型性能和用户体验反馈6.3 对比LORA+Stable Diffusion与传统方法的差异 案例研究7.1 选取具体品牌或平台作为案例，阐述LORA+Stable Diffusion的应用7.2 分析该案例中技术的具体实现和效果7.3 总结案例研究中的关键学习点和启示 未来展望8.1 探讨LORA+Stable Diffusion在虚拟试衣领域的未来发展方向8.2 预测技术进步如何影响在线购物和零售行业8.3 提出对未来研究和开发的建议 结论9.1 回顾基于LORA的Stable Diffusion模型在虚拟试衣中的主要贡献9.2 强调技术创新对提升消费者体验的重要性9.3 呼吁行业和学术界合作，推动虚拟试衣技术的发展9.4 指出持续研究和优化的必要性，以应对市场变化和技术进步 引言 1.1 简述虚拟试衣的市场背景和技术需求 随着电子商务的蓬勃发展，虚拟试衣技术已成为时尚行业的重要组成部分。它允许消费者在不离开家的情况下，通过数字化手段“试穿”各种服装，极大地提升了在线购物的体验。然而，这一技术面临着诸如衣物贴合度、动态姿势匹配以及真实感渲染等技术挑战。为了克服这些难题，AI领域开始探索更高级的算法，其中LORA与Stable Diffusion模型的结合展现了巨大的潜力。
1.2 介绍LORA与Stable Diffusion模型的结合在虚拟试衣领域的潜力 LORA（Low-Rank Adaptation）是一种轻量级的模型微调技术，而Stable Diffusion则是一种强大的图像生成模型。两者结合，能够高效地生成高质量、高保真的虚拟试衣图像，同时保持较低的计算成本。这种结合不仅提高了虚拟试衣的准确性和实时性，还增强了用户体验，使消费者能够在几秒钟内看到自己穿着不同款式的效果。
1.3 强调基于LORA的Stable Diffusion模型如何改善用户体验 借助LORA的灵活性和Stable Diffusion的强大生成能力，用户可以即时调整服装的颜色、款式甚至材质，无需等待冗长的加载时间。这不仅节省了用户的时间，也减少了退货率，因为消费者在购买前就能获得更接近真实的预览效果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b7050b296ede6e4f1572d22f307a8a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e70624ae56589692e42d8f43f241bdc/" rel="bookmark">
			c＋＋初阶知识——类和对象（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.构造函数深入
2.类型转换
3.static成员 4.友元
5.内部类
6.匿名对象 7.对象拷⻉时的编译器优化
1.构造函数深入 （1）前我们实现构造函数时，初始化成员变量主要使⽤函数体内赋值，构造函数初始化还有⼀种⽅式，就是初始化列表，初始化列表的使⽤⽅式是以⼀个冒号开始，接着是⼀个以逗号分隔的数据成员列表，每个"成员变量"后⾯跟⼀个放在括号中的初始值或表达式。
#define _CRT_SECURE_NO_WARNINGS 1 #include&lt;iostream&gt; using namespace std; class Data { Data(int year=1900, int month=1, int day=1) :_year(year) ,_month(month) ,_day(day) { } private: int _year; int _month; int _day; }; int main() { return 0; } （2）每个成员变量在初始化列表中只能出现⼀次，语法理解上初始化列表可以认为是每个成员变量定义初始化的地⽅。 （3）引⽤成员变量，const成员变量，没有默认构造的类类型变量，必须放在初始化列表位置进⾏初始化，否则会编译报错。
（4）C++11⽀持在成员变量声明的位置给缺省值，这个缺省值主要是给没有显⽰在初始化列表初始化的成员使⽤的。
（5）尽量使⽤初始化列表初始化，因为那些你不在初始化列表初始化的成员也会⾛初始化列表，如果这个成员在声明位置给了缺省值，初始化列表会⽤这个缺省值初始化。如果你没有给缺省值，对于没有显⽰在初始化列表初始化的内置类型成员是否初始化取决于编译器，C++并没有规定。对于没有显⽰在初始化列表初始化的⾃定义类型成员会调⽤这个成员类型的默认构造函数，如果没有默认构造会编译错误。
（6）初始化列表中按照成员变量在类中声明顺序进⾏初始化，跟成员在初始化列表出现的的先后顺序⽆关。建议声明顺序和初始化列表顺序保持⼀致。
总结：
每个成员都要走初始化列表：
1.在初始化列表初始化的成员
2.没有在初始化列表的成员
（1）声明的地方有缺省值用缺省值
（2）没有缺省值
a.内置类型，不确定，看编译器，大概率是随机值。
b.自定义类型，调用默认构造，没有默认构造就编译报错。
3.引用 const 没有默认构造自定义，必须在初始化列表初始化。
2.类型转换 （1）C++⽀持内置类型隐式类型转换为类类型对象，需要有相关内置类型为参数的构造函数
（2）构造函数前⾯加explicit就不再⽀持隐式类型转换
#include&lt;iostream&gt; using namespace std; class A { public: // 构造函数explicit就不再⽀持隐式类型转换 // explicit A(int a1) A(int a1) :_a1(a1) {} //explicit A(int a1, int a2) A(int a1, int a2) :_a1(a1) ,_a2(a2) {} void Print() { cout &lt;&lt; _a1 &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e70624ae56589692e42d8f43f241bdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c300187de5c49c6c2d96f0f6bb33ad9c/" rel="bookmark">
			C#进阶-基于.NET Framework 4.x框架实现ASP.NET WebForms项目IP拦截器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这篇文章中，我们将探讨如何在 ASP.NET WebForms 中实现IP拦截器，以便在 ASMX Web 服务方法 和 HTTP 请求 中根据IP地址进行访问控制。我们将使用自定义的 SoapExtension 和 IHttpModule 来实现这一功能，并根据常用的两种文本传输协议：SOAP协议 和 HTTP协议进行分别讲解。
一、创建ASMX接口文件 首先，我们创建一个 ASP.NET WebForms 项目，创建 TestAsmxProject.Asmx 文件，并定义里面的 WebService 服务。
如果不会创建 ASMX 文件，可以参考我的上一篇文章：C#进阶-ASP.NET WebForms调用ASMX的WebService接口。
TestAsmxProject.Asmx 代码如下：
using System.Web.Services; namespace TestAsmxProject.Asmx { /// &lt;summary&gt; /// Test 的摘要说明 /// &lt;/summary&gt; [WebService(Namespace = "http://tempuri.org/")] [WebServiceBinding(ConformsTo = WsiProfiles.BasicProfile1_1)] [System.ComponentModel.ToolboxItem(false)] // 若要允许使用 ASP.NET AJAX 从脚本中调用此 Web 服务，请取消注释以下行。 [System.Web.Script.Services.ScriptService] public class Test : System.Web.Services.WebService { [WebMethod] public string HelloWorld() { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c300187de5c49c6c2d96f0f6bb33ad9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bce21bc6c2ba46afd0ea0245d88b9ec/" rel="bookmark">
			[MySQL][内置函数][日期函数][字符串函数][数学函数]详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.日期函数1.基础语法2.示例13.示例2 2.字符串函数1.基础语法2.示例 3.数学函数1.基础语法2.示例 4.其他函数 1.日期函数 1.基础语法 日期时间在MYSQL中是区分开的 日期：年月日时间：时分秒 获得年月日select current_date(); +----------------+ | current_date() | +----------------+ | 2024-01-24 | +----------------+ 获得时分秒select current_time(); +----------------+ | current_time() | +----------------+ | 13:51:21 | +----------------+ 获得时间戳select current_timestamp(); +---------------------+ | current_timestamp() | +---------------------+ | 2024-01-24 13:51:48 | +---------------------+ 在日期的基础上加日期select date_add('2024-01-14', interval 10 day); +-----------------------------------------+ | date_add('2024-01-14', interval 10 day) | +-----------------------------------------+ | 2024-01-24 | +-----------------------------------------+ 在日期的基础上减去时间select date_sub('2024-01-24', interval 2 day); +----------------------------------------+ | date_sub('2024-01-24', interval 2 day) | +----------------------------------------+ | 2024-01-22 | +----------------------------------------+ 计算两个日期之间相差多少天+-------------------------------+ | datediff(now(), '1949-10-01') | +-------------------------------+ | 27143 | +-------------------------------+ 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bce21bc6c2ba46afd0ea0245d88b9ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69dc5ae05aae282884127bcdf8e24e0f/" rel="bookmark">
			WebGL的管线流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		还是大剑师兰特：曾是美国某知名大学计算机专业研究生，现为航空航海领域高级前端工程师；CSDN知名博主，GIS领域优质创作者，深耕openlayers、leaflet、mapbox、cesium，canvas，webgl，echarts等技术开发，欢迎加底部微信（gis-dajianshi），一起交流。
No.内容链接1Openlayers 【入门教程】 - 【源代码+示例300+】 2Leaflet 【入门教程】 - 【源代码+图文示例 150+】 3Cesium 【入门教程】 - 【源代码+图文示例200+】 4MapboxGL【入门教程】 - 【源代码+图文示例150+】 5前端就业宝典 【面试题+详细答案 1000+】 基本阶段 WebGL（Web Graphics Library）是基于OpenGL ES 2.0的一个API，用于在网页浏览器中渲染交互式的3D图形和复杂的2D图形，而无需任何插件。WebGL利用现代GPU的渲染能力，在浏览器中实现高性能的图形渲染。WebGL的渲染管线流程与传统的GPU渲染管线相似，主要可以分为以下几个阶段：
应用阶段：
在这一阶段，JavaScript代码负责准备数据，比如顶点坐标、颜色、纹理坐标等，并将这些数据传递给WebGL上下文。数据会被组织成缓冲区，并且通过顶点着色器程序和片段着色器程序进行处理。 顶点着色器阶段：
顶点着色器（Vertex Shader）是可编程的GLSL（OpenGL Shading Language）脚本，用于处理每个顶点。它通常执行几何变换，如模型变换、视图变换和投影变换，将3D坐标转换到裁剪空间中。顶点着色器还可以处理光照计算和纹理坐标计算。 图元装配阶段：
这一阶段，WebGL将顶点数据组装成图元，如点、线或三角形。顶点着色器为每个顶点生成输出，这些顶点随后被组合成图元。 光栅化阶段：
当图元被装配完成后，它们会被光栅化成像素。在此阶段，三角形被转化为屏幕上的像素，并执行深度测试（Z-buffer）和模板测试（Stencil buffer）。还会进行纹理映射和混合（Blending）。 片段着色器阶段：
片段着色器（Fragment Shader）也是可编程的GLSL脚本，用于处理光栅化阶段产生的每个像素（或片段）。它可以计算像素的颜色、光照效果、纹理采样等。输出的结果是每个像素的颜色值。 后处理阶段：
最后的阶段是将片段着色器的输出写入到帧缓冲区中，即颜色缓冲区、深度缓冲区和模板缓冲区。这些缓冲区的内容最终会被读取并显示在屏幕上。 整个流程是一个流水线，其中某些阶段是可编程的，允许开发者自定义顶点和片段的处理方式。WebGL的渲染管线是高度并行的，大部分计算都在GPU上完成，这使得WebGL能够高效地处理大量图形数据。
一个示例 WebGL的管线流程涉及到多个步骤，包括初始化WebGL上下文、设置着色器、配置缓冲区、发送数据到GPU以及渲染。下面是一个基本的WebGL管线流程的示例代码，它将渲染一个红色的三角形。
首先，确保你的HTML页面有一个&lt;canvas&gt;元素，因为WebGL需要一个画布来工作：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;canvas id="myCanvas" width="500" height="500"&gt;&lt;/canvas&gt; &lt;/body&gt; &lt;/html&gt; 接下来是JavaScript代码，用于设置WebGL环境并渲染三角形：
// 获取画布 var canvas = document.getElementById('myCanvas'); // 初始化WebGL上下文 var gl = canvas.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69dc5ae05aae282884127bcdf8e24e0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28e9f63b89a185ce05335aca25e6072a/" rel="bookmark">
			MySQL单表千万数据求解思路：实现可持续运行的策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言
优化数据库设计
1、规范化与反规范化
2、合适的数据类型
3、数据分区
优化索引策略
1、合理使用索引
2、使用复合索引
查询优化
1、避免SELECT *
2、使用LIMIT分页查询
3、使用EXPLAIN分析查询
4、简化查询语句
5、优化JOIN操作
系统架构与硬件升级
1、使用缓存技术
2、读写分离与主从复制
3、硬件升级
定期维护与监控
1、定期执行OPTIMIZE TABLE
2. 监控与分析
结束语
前言 众所周知，近几年数据量逐年剧增，对于大数据量处理成为越来越重要的事情，尤其是随着数据量的不断增长，MySQL数据库在处理千万级甚至更大规模的数据时，性能优化成为了至关重要的问题，查询性能的优化成为了一个核心挑战。面对单表数据超过千万行时，查询速度显著下降，这不仅影响用户体验，还可能对整个系统的稳定性和响应速度造成严重影响，还直接影响到系统的整体稳定性和可扩展性，所以如何有效优化MySQL数据库以应对大数据量挑战，确保系统可持续运行，成为了数据库管理员和开发者需要深入思考的问题。那么本文就来探讨几种有效的策略来优化MySQL数据库，以确保在大数据量下仍能高效、可持续地运行，欢迎在评论区留言交流。
优化数据库设计 先来分享一下关于优化数据库设计这块内容，这里从三个方面：规范化与反规范化、合适的数据类型、数据分区。
1、规范化与反规范化 据我所知，规范化设计有助于减少数据冗余，提高数据一致性和查询效率，但是在大数据量场景下，过度的规范化可能会导致查询时产生大量的表连接（JOIN），从而降低查询性能。也就是说虽然规范化设计有助于减少数据冗余，但在大数据量下适当的反规范化可以显著提升查询性能。
所以适当进行反规范化（如增加冗余字段、创建汇总表等）可以有效减少JOIN操作，提升查询速度，比如可以通过添加冗余字段或创建汇总表来减少JOIN操作。
2、合适的数据类型 其实在实际应用中，选择合适的数据类型可以显著减少存储空间占用，提高数据检索和计算的效率，比如使用INT代替VARCHAR来存储整数类型的数据，使用TINYINT、SMALLINT等更小的整数类型来存储较小范围内的数据。
3、数据分区 还有就是在实际使用中，数据分区是一种物理数据库设计技术，它可以将表中的数据分成较小的、更易于管理的部分。就拿MySQL来讲，MySQL支持多种分区类型，比如RANGE、LIST、HASH和KEY分区。通过合理的数据分区，可以提高查询性能，因为查询可以只扫描包含所需数据的分区。接下来用一个简单的示例来简单分享一下，假设使用RANGE分区，具体如下所示：
CREATE TABLE sales ( id INT AUTO_INCREMENT, sale_date DATE NOT NULL, amount DECIMAL(10, 2) NOT NULL, PRIMARY KEY (id, sale_date) ) PARTITION BY RANGE (YEAR(sale_date)) ( PARTITION p0 VALUES LESS THAN (1991), PARTITION p1 VALUES LESS THAN (1992), PARTITION p2 VALUES LESS THAN (1993), .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28e9f63b89a185ce05335aca25e6072a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f3aa308d1583e9da4670eeb5403d03c/" rel="bookmark">
			【Godot4.2】MLTag类：HTML、XML通用标签类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 HTML和XML采用类似的标签形式。
之前在Godot中以函数库形式实现了网页标签和内容生成。能用，但是缺点也很明显。函数之间没有从属关系，但是多有依赖，而且没有划分出各种对象和类型。
如果以完全的面向对象形式来设计标签类或者元素类，将可以更贴近HTML或XML的本来面目。也更容易生成。
整体思路是设计如下的类继承结构：
实现之后，将可以充分的定义和生成HTML、XML和SVG标签，并用于内容生成或文档解析。
通用标签类 因为HTML和XML标签的语法格式和要素是类似的，因此可以通过创建一个通用的标签类，来生成HTML或XML标签。
MLtag就是这个通用的标签类，它定义了几个核心的属性：
tag_name ：标签名称attrs：包含标签所有属性的字典is_single:是否为单标签，默认为falsecontent ：标签的子内容,可以直接赋值，也可以使用append()方法追加。单标签（is_single为true）时被忽略get_end_tag()：获取结束标签，单标签时返回空字符串append()：追加当前标签的子内容，可以是字符串形式，也可以是SVG标签实例（会自动调用to_string()方法转化为字符串） # ============================================= # 名称：MLtag # 类型：类 # 描述：HTML、XML通用标签类，用于定义和生成HTML、XML标签字符串 # 作者：巽星石 # 创建时间：2024年7月16日17:48:01 # 最后修改时间：2024年7月16日22:27:53 # ============================================= class_name MLTag # ====================== 属性 ====================== var tag_name = "" # 标签名称 var attrs:Dictionary = {} # 属性字典 var is_single = false # 是否单标签 var content = "" # 子内容 # ====================== 方法 ====================== # 获取结束标签 func get_end_tag() -&gt; String: return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f3aa308d1583e9da4670eeb5403d03c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18c670b364015060f4110ad428e7c175/" rel="bookmark">
			分享6个AI一键生成PPT的工具【国内最新】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 PPT（PowerPoint演示文稿）在商业演示、教育授课以及各种演讲中扮演着关键角色。然而，制作一份既吸引人又能有效传递信息的PPT并不是一件容易的事。幸运的是，随着人工智能技术的发展，现在有一些免费的AI工具可以帮助你轻松地一键生成PPT，让整个设计过程变得更加简单和有趣。
二、生成PPT的AI工具 1. 轻竹AIPPT 传送入口：http://u6v.cn/6hq9Fs
推荐指数：⭐⭐⭐⭐⭐
一键快速生成PPT模板
例如：写一份Python答辩PPT
如果对模板不满意，还可以切换其他PPT模板
2. 比格AIPPT 传送入口：http://m6z.cn/6hWfza
推荐指数：⭐⭐⭐⭐⭐
比格AIPPT是135编辑器旗下的一款AI赋能的颠覆性在线制作PPT的网站，用户只需输入所需的PPT主题，AI就能够一键生成内容大纲并辅助完成PPT的设计制作。登录有免费生成和下载次数
不仅如此，平台还支持在线编辑PPT，并且有多种素材、PPT模板可供选择，也可以导入自己的PPT
甚至还支持在线PPT演示
3. ChatGAI 传送入口：ChatGAi
推荐指数：⭐⭐⭐⭐⭐
每天2次免费生成和下载，不仅能生成ppt大纲，模板也不少，还能在线编辑
根据自己的需要生成ppt大纲，接着挑选喜欢的PPT风格一键生成
生成之后可以直接在线编辑（这个功能真的太棒了）
下载后如下：
4. ChatPPT 传送入口：chat-ppt
推荐指数：⭐⭐⭐⭐⭐
通过上面的“传送入口”参与活动就有3天SVIP，相当于免费使用，并且普通用户每天也可以免费生成20张ppt
输入你的PPT主题即可快速一键生成文档，或下载官方插件，体验更丰富的创作功能
5. Kimi PPT助手 传送入口：http://m6z.cn/63vlPw
推荐指数：⭐⭐⭐⭐⭐
kimi是一款国产的AI问答产品，支持生成PPT大纲在内等多种场景，并且完全免费
6. AIPPT 传送入口：AiPPT - 全智能 AI 一键生成 PPT
推荐指数：⭐⭐⭐⭐⭐
每天有2次可以免费生成
简单输入自己想要的PPT主题或内容大纲，AI助手会快速生成PPT下详细大纲
接着挑选喜欢的PPT风格一键生成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9894b9b576909cb7f6dc19aa89939cd3/" rel="bookmark">
			linux的学习（七）：读取，函数，正则表达式，文本处理工具cut和awk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		##简介
shell编程中的读取，函数，正则表达式，文本处理工具的简单使用
read read：读取控制台的输入
参数：
-p：指定读取时的提示符-t：等待读取的时间 脚本例子 编写i.sh脚本，enter your name:提示用户在控制台输入，如果5秒未输入自动执行退出
#!/bin/bash read -t 5 -p "enter your name:" name echo "hello,$name" . i.sh运行脚本
函数 分为系统函数和自定义函数
系统函数 系统自带的一些，但是感觉使用起来和命令差不多
basename basename：截取文件名
可带参数 suffix：后缀，会去掉文件名的后缀
basename /tmp/a.txt .txt dirname dirname：获得文件的路径，不包括文件名
dirname /tmp/a.txt 自定义函数 语法 方法名()
{
方法体
}
在脚本中编写方法：
#! /bin/bash function add(){ s=$[ $1 + $2 ] echo $s } read -p "enter first numnber: " a read -p "enter second number: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9894b9b576909cb7f6dc19aa89939cd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f155bbdefd5fc5e56f220267fcc4e815/" rel="bookmark">
			在VScode下配置C/C&#43;&#43;环境(tasks.json、launch.json、c_cpp_properties.json)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. tasks.json、launch.json配置文件中参数(属性)的说明2. tasks.json介绍3. launch.json介绍4. 直接生成tasks.json、launch.json配置文件的另外一种方式5. c_cpp_properties.json介绍6. 运行多个C/C++文件7. 命令行方式编译C++ 1. tasks.json、launch.json配置文件中参数(属性)的说明 首先我们创建了一个code项目，然后在code文件夹下分别建立了day1和day2两个目录(文件夹)，最后在day1和day2文件夹下分别创建hello.c和main.cpp两个文件，code项目的组织结构如下图1所示。在VScode中，默认情况下code文件夹是一个workspace(工作区、工作空间)。
图1 code项目的组织结构 下面，我们基于上面code项目的组织结构对tasks.json、launch.json配置文件中的参数(属性)进行说明。（以hello.c文件为例）
（1）${workspaceFolder}：表示当前workspace(工作区、工作空间)文件夹的路径，也即当前项目绝对路径。例如：D:\code，code就是一个工作区。
（2）${fileDirname}：表示当前打开文件的绝对路径，但不包括文件名。例如打开hello.c文件，该文件所在的绝对路径(${fileDirname})为：D:\code\day1，day1就是hello.c文件的目录。
（3）${workspaceFolder}/**：表示当前workspace(工作区、工作空间)文件夹的路径，而且还会递归搜索所有子目录。例如：当前项目的绝对路径为D:\code，不仅要搜索code文件夹，还会递归搜索code的所有子目录（子文件夹）。
（4）${workspaceRootFolderName}：表示workspace(工作区、工作空间)文件夹名字，也就是当前项目所在文件夹名字，例如code文件夹。
（5）${file}：表示当前打开的文件，指的是当前活动文件。包括绝对路径，文件名，文件后缀名。例如：D:\code\day1\hello.c。
（6）${fileBasename}：当前打开含有后缀的文件名，不包括路径。
（7）${fileBasenameNoExtension}：表示当前打开的文件名，但不包括路径和后缀名。
（8）cwd(current working directory)：当前工作目录，它是操作系统当前正在运行进程所在的目录。在命令行界面(比如，cmd)中，用户输入命令时，默认情况下会在cwd下执行。
更多命令参考：变量参考
参考文章
最新VS code配置C/C++环境(tasks.json, launch.json,c_cpp_properties.json)及运行多个文件、配置Cmake
（上面这篇文章介绍的比较详细，我下面总结的大部分内容都摘抄于该文章，非常感谢该博主）
2. tasks.json介绍 tasks.json在编译时用的到，配置tasks.json文件的步骤(下面以hello.c文件为例)：
首先运行hello.c文件(点击右上角的运行图标)，再点击"C/C++：gcc.exe生成和调试活动文件"，如图2所示。
图2 运行当前活动文件 经过步骤1，在工作区code文件夹下可以生成一个.vscode\tasks.json文件，如下图3所示。除了tasks.json配置文件外，launch.json、c_cpp_properties.json配置文件也放在.vscode文件夹下。
图3 产生的tasks.json文件 tasks.json文件配置内容如下。在配置路径时只能使用\\或/隔开目录。 { "tasks": [ { "type": "cppbuild", "label": "C/C++: gcc.exe 生成活动文件", "command": "d:\\AppInstall\\GCCAPP\\mingw64\\bin\\gcc.exe", "args": [ "-fdiagnostics-color=always", "-g", "${file}", "-o", "${fileDirname}\\${fileBasenameNoExtension}.exe" ], "options": { "cwd": "d:\\AppInstall\\GCCAPP\\mingw64\\bin" // "cwd": "${fileDirname}"：有时候"cwd"的值为："${fileDirname}" }, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f155bbdefd5fc5e56f220267fcc4e815/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd028dcf78ee339b9f7f41421e6756ff/" rel="bookmark">
			C&#43;&#43;必修：深入探索多态的奥秘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨✨ 欢迎大家来到贝蒂大讲堂✨✨
🎈🎈养成好习惯，先赞后看哦~🎈🎈
所属专栏：C++学习
贝蒂的主页：Betty’s blog
前言需知： 本文中的代码及解释都是在vs2022下的x86程序中，涉及的指针都是4bytes。如果要其他平台下，部分代码需要改动。比如：如果是x64程序，则需要考虑指针是8bytes问题等等。
1. 多态的引入 1.1. 多态的概念 通俗来说，多态就是多种形态，具体点就是去完成某个行为，当不同的对象去完成时会产生出不同的状态。举一个简单的例子：
当我们去买票时，普通人买票时，是全价买票；学生买票时，是半价买票；军人买票时是优先买票。普通人，学生，军人虽然都属于人这类整体，但是在进行买票这个行为时却会发生不同的状态。这就是一种典型的多态行为。
1.2. 多态的定义 在 C++ 中，多态指的是通过基类的指针或引用，在运行时能够调用派生类中实现的同名函数，从而表现出不同的行为。而构成多态一定要满足两个条件：
必须通过基类的指针或者引用调用虚函数。被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写。 下面是一个简单的多态调用：
class Person { public: virtual void BuyTicket() //虚函数 { cout &lt;&lt; "买票-全价" &lt;&lt; endl; } }; class Student : public Person { public: virtual void BuyTicket()//虚函数重写 { cout &lt;&lt; "买票-半价" &lt;&lt; endl; } }; void Func(Person&amp; p)//基类引用调用 { p.BuyTicket(); } int main() { Person ps; Student st; Func(ps); Func(st); return 0; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd028dcf78ee339b9f7f41421e6756ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f6955fc6b967bcae3656a0b509250b2/" rel="bookmark">
			HTTP背后的故事：理解现代网络如何工作的关键（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.认识请求方法(method) 1.GET方法 请求体中的首行包括：方法，URL，版本号
方法描述的是这次请求，是具体去做什么
GET方法：
1.GET 是最常用的 HTTP 方法. 常用于获取服务器上的某个资源。
2.在浏览器中直接输入 URL, 此时浏览器就会发送出一个 GET 请求. 另外, HTML 中的 link, img, script 等标签, 也会触发 GET 请求. GET 请求的特点 首行的第一部分为 GET URL 的 query string 可以为空, 也可以不为空. header 部分有若干个键值对结构. body 部分为空. 2.POST方法 POST 方法也是一种常见的方法, 多用于提交用户输入的数据给服务器(例如登陆页面). 通过 HTML 中的 form 标签可以构造 POST 请求, 或者使用 JavaScript 的 ajax 也可以构造 POST 请求. 两个非常经典使用POST场景
1.登录
2.上传
登录码云时
POST 请求的特点 首行的第一部分为 POST URL 的 query string 一般为空 (也可以不为空) header 部分有若干个键值对结构.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f6955fc6b967bcae3656a0b509250b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/513636c3da2e39b430a8750a89f9427a/" rel="bookmark">
			20240717 每日AI必读资讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌐 H2O-Danube3：无需联网，可以直接在手机上运行的开源模型！
- 一个由 http://H2O.ai 开发的一系列小型语言模型。
- 该模型能够提供聊天、问答服务、文本分类、数据分析等功能。
- 能够在普通边缘硬件设备（如智能手机）上运行，而且无需连接网络。
🔗模型下载：https://huggingface.co/collections/h2oai/h2o-danube3-6687a993641452457854c609
🔗论文：https://arxiv.org/pdf/2407.09276
🔗 H2O-Danube3：无需联网可以直接在手机上运行的开源模-CSDN blink-领先的开发者技术社区
🔧新型验证码破解工具GPT4o Captcha Bypass
- 支持多种验证码类型: 包括拼图验证码、文本验证码、复杂文本验证码和reCAPTCHA系统。
- 集成先进AI技术: 内置OpenAI的GPT-4语言模型，解决复杂验证码问题。
- 基于Python开发且使用Selenium自动化: 方便扩展和定制，提高测试效率。
🔗 https://github.com/aydinnyunus/gpt4-captcha-bypass
📰一个用于认知行为疗法（CBT）的提示词，识别生活中令人困扰的事情
- 提示内容：提示设计为一个认知行为治疗师，通过温和和开放的方式帮助用户进行CBT。治疗师会逐一提问，并根据用户的回答实施CBT的各个步骤。
- 识别问题：帮助用户识别生活中令人困扰的情况或条件。
- 认识情绪和信念：帮助用户意识到自己对这些问题的想法、情绪和信念。
- 识别负面思维：根据用户的回答，识别并分类导致用户痛苦的负面或不准确的思维。
- 认知重构：通过提问，帮助用户重新构建他们的思维。
🔗 https://xiaohu.ai/p/11313
🔊谷歌开发实时语音转换系统！！
- 在不改变语音内容和语调的情况下改变说话者音色
- 可以在手机上直接运行，在 Pixel 7智能手机上的端到端延迟为 70.8 毫秒。
- 并适用于电话和视频会议等实时通信场景，还能实现语音匿名化。
- 主要应用场景包括：
电话会议：在企业电话会议中使用，转换语音以保护与会者的隐私。
视频通话：在视频通话中使用，实时改变语音音色以达到特定效果。
在线游戏：在多人在线游戏中使用，改变玩家的语音音色以增强游戏体验。
🔗论文：https://arxiv.org/pdf/2401.03078 🚀 争气！Claude 3.5 Sonnet在数据可视化领域超越GPT-4o
- 速度翻倍：Claude3.5Sonnet的运行速度是之前版本的两倍，编码能力显著提升，解决了64%的编码问题。
- 卓越数据可视化：在图表和图像理解能力上表现优异，适用于零售、物流和金融等多个行业。
- 安全与隐私保障：确保用户数据不会未经同意用于模型训练，关注用户隐私和安全。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/513636c3da2e39b430a8750a89f9427a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f4e9968229a26df6a50b9b5be8250e5/" rel="bookmark">
			二维空间和三维空间刚体变换中雅克比矩阵的推导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 预备的知识1.1 李群 S E ( 2 ) \mathrm{SE}(2) SE(2)1.2 李代数 s e ( 2 ) {{s e}(2)} se(2)1.3 指数映射（将李代数 se ⁡ ( 2 ) \operatorname{se}(2) se(2) 转换为李群 S E ( 2 ) \mathrm{SE}(2) SE(2) )1.4 求极限 2 二维和三维刚体变换求雅可比矩阵2.1 问题描述2.2 方法 1: 对扰动的量 Δ T \Delta T ΔT 对应的李代数 ξ \xi ξ 进行求导2.2 方法 2: 直接用公式推导 [^3]2.3 将方法 2 类比推导到三维空间 1 预备的知识 补充一些李群 SE ⁡ ( 2 ) \operatorname{SE}(2) SE(2) 和李代数 se ⁡ ( 2 ) \operatorname{se}(2) se(2) 的知识, 因为视觉 SLAM十四讲1中只给出了 S E ( 3 ) \mathrm{SE}(3) SE(3) 和 s e ( 3 ) \mathrm{se}(3) se(3) 的对应关系, 但是没有给出二维空间的对应关系。其中二维空间的李群李代数参考Lie Groups for 2D and 3D Transformations。2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f4e9968229a26df6a50b9b5be8250e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/305f60b431b91146936098a1de49c8d4/" rel="bookmark">
			口袋算法的示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理 口袋算法是感知器（Perceptron）算法的一种改进。感知器算法是一种线性分类算法，但在训练数据不是线性可分的情况下，它可能无法收敛，即无法找到一个线性分类器来正确分类所有的训练样本。为了解决这个问题，口袋算法引入了一个"口袋"（Pocket），用来存储迄今为止最好的权重向量（即使它不能正确分类所有样本，但错误率最低）。
口袋算法的基本思想是：
初始化权重向量。在每次迭代中，随机选择一个误分类样本。根据这个样本更新权重向量。如果更新后的权重向量比当前最佳的权重向量更好（即误分类样本更少），则将其存入"口袋"中。继续迭代直到达到预定的最大迭代次数或连续若干次迭代不再更新最佳权重向量。 作用 口袋算法的作用是改进感知器算法，使其能够在训练数据非线性可分的情况下仍然能够找到一个尽可能好的线性分类器。它能够在一定程度上减少误分类的样本数，提高分类器的准确性。
口袋算法步骤 初始化：
迭代：
终止条件：
达到预定的最大迭代次数。连续若干次迭代不再更新最佳权重向量。 数学原理推导过程 口袋算法（Pocket Algorithm）是感知器算法的一种改进版本。它旨在解决感知器算法在处理非线性可分数据集时可能无法收敛的问题。口袋算法引入了一个“口袋”来存储迄今为止最好的权重向量，以确保即使在数据集不可线性分的情况下，算法也能找到一个尽可能好的线性分类器。
口袋算法的改进 口袋算法在感知器算法的基础上引入了一个“口袋”，用于存储迄今为止最好的权重向量。具体步骤如下：
3. 终止条件：
达到预定的最大迭代次数。连续若干次迭代不再更新最佳权重向量。 数学推导 感知器学习算法（PLA） 感知器学习算法（PLA，Perceptron Learning Algorithm）是机器学习中的一种基础算法，专用于处理二分类问题。它的目标是找到一条能够线性分割两个类别的超平面。
PLA的关键概念 线性可分：
PLA假设数据是线性可分的，即存在一个超平面能够将两个类别的数据完全分开。 算法步骤：
PLA从初始权重开始，通常设置为零向量。遍历训练数据，对每个样本进行分类，如果分类错误，则更新权重。更新规则是简单的：对于一个分类错误的样本，按照样本的特征向量和标签的乘积进行更新。 更新规则：
权重更新规则可以表示为： 收敛性：
如果数据是线性可分的，PLA保证能找到一个超平面正确分类所有训练数据。如果数据不是线性可分的，PLA可能永远不会收敛。 PLA与口袋算法 口袋算法是PLA的扩展，设计用来处理线性不可分的数据。其关键思想是保持（或放入口袋）迄今为止找到的最佳解决方案，即使当前权重向量不能完美分类所有数据，也会保留错误最少的那个。
PLA的例子 以下是PLA的一个简化版本的实现：
import numpy as np def perceptron_learning_algorithm(X, y): """ 感知器学习算法实现。 注意：该算法仅适用于线性可分的数据集。对于不可线性分的数据集，算法可能不会收敛。 参数： X (ndarray): 训练数据特征，形状为 (样本数, 特征数) y (ndarray): 目标标签，形状为 (样本数,) 返回值： ndarray: 学习到的权重系数，形状为 (特征数,) """ # 初始化变量 done = False W = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/305f60b431b91146936098a1de49c8d4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/146/">«</a>
	<span class="pagination__item pagination__item--current">147/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/148/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>