<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d424889be6b0edbad2704f60e04579c/" rel="bookmark">
			一文带你了解三大开源关系型数据库：SQLite、MySQL和PostgreSQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、概述
2、SQLite数据库
2.1、SQLite简介
2.2、SQLite优缺点
2.3、SQLite应用场景
3、MySQL数据库
3.1、MySQL简介
3.2、MySQL优缺点
3.3、MySQL应用场景
4、PostgreSQL数据库
4.1、PostgreSQL简介
4.2、PostgreSQL优势
4.3、PostgreSQL应用场景
5、在实际系统中的选择
VC++常用功能开发汇总（专栏文章列表，欢迎订阅，持续更新...）https://blog.csdn.net/chenlycly/article/details/124272585C++软件异常排查从入门到精通系列教程（专栏文章列表，欢迎订阅，持续更新...）https://blog.csdn.net/chenlycly/article/details/125529931C++软件分析工具从入门到精通案例集锦（专栏文章正在更新中...）https://blog.csdn.net/chenlycly/article/details/131405795C/C++基础与进阶（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/category_11931267.html 一个完整的IT系统一般少不了数据库系统的支撑，大量的数据需要保存到数据库中。不同的数据库在使用场景和性能上，有一定的差异。IT系统需要根据运行环境、数据量的大小以及业务需求，选择合适的数据库。今天我们就来讲讲三个常用的免费开源的关系型数据库SQLite、MySQL和PostgreSQL，大概地了解一下这三个数据库的差异与应用场景。
1、概述 数据库可以分商业数据库和免费数据库，常见的商业数据库有Microsoft SQL Server、Oracle、Sybase、DB2和Informix，普遍使用的免费数据库则有SQLite、MySQL和PostgreSQL。商业数据库的性能和功能强大全面，而且他们还有强大的技术团队支持。免费开源数据库的稳定性和性能也不逊色，有着活跃开源社区的支撑。
一些政府和银行的项目，使用商业数据库比较多，比如Microsoft SQL Server、Oracle、Sybase、DB2和Informix等。但对于大部分IT厂商，出于成本的考虑，会选用免费开源的数据库，开源的数据库也更可控。
本文我们主要来讨论一下SQLite、MySQL和PostgreSQL这三个免费开源数据库。轻量级数据库SQLite主要用于客户端和嵌入式设备中，存放一些轻量级的数据。MySQL和PostgreSQL主要用于服务端，存放一些大量或海量的数据。
此外，国内的一线大厂在数据库领域进行了深入的研究和布局，在MySQL和PostgreSQL等开源数据库的基础上进行深度优化和创新，开发出了满足他们大型业务系统海量数据存储需求的新型数据库以及应用于云计算领域的云数据库，比如腾讯的TBase数据库、阿里的OceanBase数据库以及华为的GaussDB数据库。并且这些大厂，根据自身业务系统的需求，开发出了用于不同业务场景的多种数据库。
这些大厂之所以能将自主创新的数据库玩起来，主要有以下几个原因：
1）他们有雄厚的资金与人才储备，可以投入大量的人力和资源去做深度的研究和布局；
2）他们有自家的大型业务系统（比如腾讯有微信、阿里有淘宝、华为有庞大的电信运营支撑系统，这些产品系统中深度地融入了云计算和大数据技术），为了满足自家系统的海量数据高效存储与查询需求，他们必须要在现有技术的基础上进行持续的技术创新；
3）新产品和技术应用到自家的大型业务系统之后，可以会遇到这样或那样的问题或瓶颈，这能持续地推动产品和技术的优化与改进。
近十年来，也诞生了很多国产数据库厂商，比如瀚高公司的瀚高数据库（基于开源的PostgreSQL数据库）、达梦公司的达梦数据库、人大金仓的Kingbase数据库。
2、SQLite数据库 2.1、SQLite简介 SQLite，是一款轻量级的关系型数据库，是一个用C语言开发库。它的设计目标是用于嵌入式系统中的，很多嵌入式产品中使用了它，它占用资源很低，可能只需要几百K的内存就够了。它支持Windows、Linux、Unix等主流的操作系统，因为它是用C语言开发的，可以和很多程序语言相结合，比如 C++、C#、PHP、Java、Python、Ruby等：
1）C/C++
由于SQLite本身是C写的，它自带的API也是C接口的。所以C/C++用起来最直接了。假如你不喜欢面向过程的C API风格，可以另外找个C++的包装库。想重新发明轮子的同学，也可以自己包装一个。
2）Java
如果要用Java访问SQLite，可以通过SQLite的JDBC驱动，或者通过专门的SQLite包装库。个人建议走JDBC方式，万一将来要换数据库，代码就不用大改。
3）Python
pysqlite是Python操作SQLite的首选。从Python 2.5开始，它已经被整合到Python的标准库中。看来Python社区还是蛮喜欢SQLite嘛。
4）.Net
对于喜欢dotNet的同学，可以通过SQLite的ADO.NET驱动来访问。
5）Ruby
Ruby可以通过SQLite-Ruby操作SQLite数据库。
SQLite第一个Alpha版本诞生于2000年5月。 至2023年已经接近有23个年头，SQLite也迭代到了3.0版本。不像常见的客户 - 服务器数据库范例，SQLite引擎不是一个与数据库服务器通信的独立进程，而是直接链接到程序中成为程序的一部分（可以直接将.h和.c添加到目标工程中，也可以封装成dll供目标程序调用）。
使用SQLite数据库的方式很简单，只需要将之集成到程序中，直接调用SQLite提供的API接口即可完成数据库和表的创建、数据的增删改查等操作。整个数据库(定义、表、索引和数据本身)都是存储在宿主主机上的一个或多个db文件。关于如何调用SQLite库提供的API函数，可以参见之前写的文章：
轻量级数据库SQLite的API接口说明https://blog.csdn.net/chenlycly/article/details/123482588
2.2、SQLite优缺点 SQLite是完全免费开源的，是一种轻量级的数据，运行时占用很少的内存资源，只需要集成到程序中即可使用。支持多个操作系统，支持C、C++、Java和Python多种开发语言。SQLite支持大部分SQL语句和数据库特性。
SQLite有以下的缺点：
1）并发访问的锁机，SQLite在并发（包括多进程和多线程）读写方面的性能一直不太理想。数据库可能会被写操作独占，从而导致其它读写操作阻塞或出错。
2）SQL标准支持不全，在它的官方网站上，具体列举了不支持哪些SQL92标准。我个人感觉比较不爽的是不支持外键约束。
3）有时候需要访问其它机器上的SQLite库文件，就会把数据库文件放置到网络共享目录上。这时候你就要小心了。当SQLite文件放置于NFS时，在并发读写的情况下可能会出问题（比如数据损坏）。原因据说是由于某些NFS的文件锁实现上有Bug。
在这里，给大家重点推荐一下我的几个热门畅销专栏，欢迎订阅：（博客主页还有其他专栏，可以去查看）
专栏1：（该精品技术专栏的订阅量已达到430多个，专栏中包含大量项目实战分析案例，有很强的实战参考价值，广受好评！专栏文章持续更新中，预计更新到200篇以上！欢迎订阅！）
C++软件异常排查从入门到精通系列教程（专栏文章列表，欢迎订阅，持续更新...）https://blog.csdn.net/chenlycly/article/details/125529931
本专栏根据多年C++软件异常排查的项目实践，系统地总结了引发C++软件异常的常见原因以及排查C++软件异常的常用思路与方法，详细讲述了C++软件的调试方法与手段，以图文并茂的方式给出具体的项目问题实战分析实例（很有实战参考价值），带领大家逐步掌握C++软件调试与异常排查的相关技术，适合基础进阶和想做技术提升的相关C++开发人员！
考察一个开发人员的水平，一是看其编码及设计能力，二是要看其软件调试能力！所以软件调试能力（排查软件异常的能力）很重要，必须重视起来！能解决一般人解决不了的问题，既能提升个人能力及价值，也能体现对团队及公司的贡献！
专栏中的文章都是通过项目实战总结出来的，包含大量项目问题实战分析案例，有很强的实战参考价值！专栏文章还在持续更新中，预计文章篇数能更新到200篇以上！
专栏2： C/C++基础与进阶https://blog.csdn.net/chenlycly/category_11931267.html
以多年的开发实战为基础，总结并讲解一些的C/C++基础与进阶内容，以图文并茂的方式对相关知识点进行详细地展开与阐述！专栏涉及了C/C++领域的多个方面的内容，同时给出C/C++及网络方面的常见笔试面试题，并详细讲述Visual Studio常用调试手段与技巧！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d424889be6b0edbad2704f60e04579c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94e1540b7abbf520ce20cecddbf5de14/" rel="bookmark">
			【基础算法总结】二分查找二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二分查找二 1.山脉数组的峰顶索引2.寻找峰值3.寻找旋转排序数组中的最小值4.点名 点赞👍👍收藏🌟🌟关注💖💖
你的支持是对我最大的鼓励，我们一起努力吧!😃😃
1.山脉数组的峰顶索引 题目链接：852. 山脉数组的峰顶索引
题目描述：
题目描述的有些复杂，换成图形就是一个山峰让你找最顶点
算法原理：
首先我们会想到遍历，找到这个数组中第一次出现当前这个值比下一个值大的下标，
解法一：暴力枚举 O(N)
题目要求O(logn)，我们看看有没有优化的地方。我们发现这个峰顶值把数组分成了两部分，这时你会想到什么 二段性
解法二：二分查找算法
class Solution { public: int peakIndexInMountainArray(vector&lt;int&gt;&amp; arr) { int left=1,right=arr.size()-2;//第一个位置,最后一个位置绝对不可能是 while(left&lt;right) { int mid=left+(right-left+1)/2; if(arr[mid]&gt;arr[mid-1]) left=mid; else right=mid-1; } return left; } }; 2.寻找峰值 题目链接：162. 寻找峰值
题目描述：
这道题也是找峰值但是和上面不一样的是上面那道题数组就是上下一种情况，而这里数组可能会有三种情况：
算法原理：
解法一：暴力求解 O(N)
从第一个位置开始，一直往后走，分情况讨论即可
分析一下有没有优化的地方。因为我们就是比较当前位置和下一个位置的关系，所以我们把这个数组抽象出来。
arr[i] &gt; arr[i+1] ，此时是一个下降趋势，左边区间一定会存在一个峰值，左右都是负无穷，左边是从负无穷开始的，呈现上升趋势然后才下降，所以左边一定是有峰值的。但是右边区间不一定，因为右边是负无穷可能一直下降。接下来去左边寻找。arr[i] &lt; arr[i+1]，此时是一个上升趋势，左边是从服务器开始可能一直在上升，那可能是没有最终结果的。但是右边一定是有最终结果的，因为右边是负无穷，会降到负无穷的。接下来去右边寻找。 我们发现这两个点的关系把整个数组分成了两部分。然后我们去一个部分去搜索结果。
解法二：二分查找
这道题是严格无序的，因为可能存在一升一降、一升一降。但是我们找到了二段性，因此也可以用二分查找算法。
class Solution { public: int findPeakElement(vector&lt;int&gt;&amp; nums) { int left=0,right=nums.size()-1; while(left&lt;right) { int mid=left+(right-left)/2; if(nums[mid]&gt;nums[mid+1]) right=mid; else left=mid+1; } return left; } }; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94e1540b7abbf520ce20cecddbf5de14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91f22b70a6e161d5a3cb3273577eecf4/" rel="bookmark">
			基于Python的jieba库分析《斗破苍穹》文本中的高频词汇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分析《斗破苍穹》文本中的高频词汇 在进行文本分析时，了解文本中出现频率较高的词汇对于把握文本的主题和风格非常有帮助。本文将介绍如何使用Python的jieba库对《斗破苍穹》这部小说的文本进行分词处理，并统计高频词汇的出现次数（本文只统计了小说前四百章节的内容）。
背景介绍 《斗破苍穹》是一部非常受欢迎的玄幻小说，由天蚕土豆所著。为了更好地理解这部小说的词汇使用情况，我们决定排除一些常见的虚词和无意义的词汇，同时将一些角色的别名统一为全名，以便于统计。
环境准备 文本资料：微信公众号“码银学编程”后台回复 斗破文本。
在开始之前，请确保你的环境中已经安装了jieba库。如果没有安装，可以通过以下命令安装：
pip install jieba 代码实现 首先，我们定义了一个excluded_words集合，包含了需要排除的词汇。这些词汇大多是一些虚词或在统计中意义不大的词汇。然后，我们定义了一个alias_to_full_name字典，用于将小说中人物的别名映射到全名。
接下来，我们读取了《斗破苍穹》的文本文件，并使用jieba库进行分词。在分词过程中，我们排除了单字词汇和之前定义的排除词汇。最后，我们统计了剩余词汇的出现次数，并对统计结果进行了排序。
以下是完整的代码实现：
import jieba # 定义一个集合，包含需要排除的词汇 excluded_words = { '有些', '便是', '我们', '你们', '如今', '说道', '知道', '起来', '这里', '之中', '能够', '一面', '自己', '怎么', '两个', '没有', '不是' ,'不知' ,'这个' ,'咱们' ,'告诉' ,'就是' ,'东西', '他们', '众人', '进来','回来','只是','大家', '老爷', '只见', '听见', '只得' ,'这些' ,'不敢' ,'出去' ,'出来' ,'微微','然后', '竟然','之后','已经','不过','心中','身体','一个','虽然','一般','犹如','点头','现在', '最后','缓缓','时间','什么','一些','这种','之上','目光','忽然','略微','实力','却是','一声','那些','似乎','一口气','出现','摇头','脸色' ,'所以','一抹','有着','手掌','脸庞','体内','这般','旋即','顿时','淡淡的','随着','一道','恐怕','随着','先前','极为','而出','声音','...' ,'而出','青色','面前','极为','手中','逐渐','进入','因为','几乎','方才','缓缓的','不会','一名','的话','终于','开始','一眼','能量','火焰' ,'斗气','修炼','强者','药师','一下','少年','家族','呵呵','哈哈','丹药','长老','闻言','无奈','家伙' ,'一股','需要','帝国','依然','以及','而且','两人','需要','周围','此时' # ... 其他排除词汇 ... } # 定义一个映射，将《斗破苍穹》中的别名映射到对应的全名 alias_to_full_name = { ('炎帝', '炎儿'): '萧炎', ('药尘'):'药老', ('纳兰'):'纳兰嫣然', ('嫣然'):'纳兰嫣然', ('海波'):'海波东', ('萧熏儿'):'萧熏儿', ('熏儿'):'萧熏儿', ('古熏儿'):'萧熏儿', } # 读取文本文件 try: with open("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91f22b70a6e161d5a3cb3273577eecf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/904e20300c5393ce7f06847ec7ec953b/" rel="bookmark">
			ES 数据写入方式:直连 VS Flink 集成系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ES 作为一个分布式搜索引擎，从扩展能力和搜索特性上而言无出其右，然而它有自身的弱势存在，其作为近实时存储系统，由于其分片和复制的设计原理，也使其在数据延迟和一致性方面都是无法和 OLTP（Online Transaction Processing）系统相媲美的。
也正因如此，通常它的数据都来源于其他存储系统同步而来，做二次过滤和分析的。这就引入了一个关键节点，即 ES 数据的同步写入方式，本文介绍的则是 MySQL 同步 ES 方式。
将 MySQL 数据写入 ES，首先想到的一定是消费 Binlog 直连 ES 写入，这种方式简单明了，然而如果稍微考量维度多一点，就会发现该方式的一些弊端。因此还有另外一个方式，即【RocketMQ + Flink Consumer + ES Bulk】集成生态，我们将从同步延迟、消费特性，ES 写入性能、系统容灾能力四个方面评估这两种接入方式，希望给到大家灵感并选择适合业务的同步方式。
ES 基础写入原理 ES 写入属于追加式写入，先形成特定大小的 Segment，然后定时 Merge 小数据段为大数据段以减少内存碎片，提升查询效率的过程。一个 Index 由 N 个 Shard 及其副本构成，存储了同一种 Type 类型的 Documents，由 Mapping 定义了其索引方式，每一个 Shard 由 N 个 Segment 组成，每个 Shard 都是一个全功能且完整的 Lucene 索引，它是 ES 的最小处理单元；Segment 是 ES 最小的数据处理单位，每个 Segment 都是一个独立的倒排索引。
ES 写入其实是不断将数据写入到同一个 Segment（内存），然后触发 Refresh 刷新，将 Segment 刷新到 OS Cache（默认 1s），此时数据就可以查询到了，OS Cache 会由操作系统触发 Flush 操作持久化到磁盘。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/904e20300c5393ce7f06847ec7ec953b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfd9756dffd442304ea62bcab07c60ab/" rel="bookmark">
			Stable Diffusion本地安装详细教程（Mac篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01引言
今天给大家重点介绍下AI绘图工具——Stable-Diffusion-WebUI。大家都知道Midjourney生成图片效果很惊艳，其实Stable Diffusion是目前开源免费且最好用的本地运行AI绘画工具。
Stable Diffusion是22年8月份由Stability AI推出的基于python的文本生成图像模型。Stable Diffusion对于普通用户而言，目前最大的优势就是免费，安装到电脑本地即可使用。
就生成图像的效果和性能来说：
**- Stable Diffusion的模型规模更大、稳定性更高，渲染效果更强大，也更具有人类创作水平；
**
- 生成图像质量更高于其他模型：图像真实感更高，更清晰且富有细节；
- 支持多种风格和主题的图像生成，不局限于特定类型，但支持定制化训练模型专注特定领域；
- 输入prompt文本描述更自由更灵活，不需要遵循特定的格式或者模板，且支持多种参数调整和设置；
- 模型是在本地电脑运行，不需要排队，适合在各种硬件环境中部署使用。
相比而言，Midjourney生成的图像更抽象，在图片的艺术性和想象空间上更强，如生成完全虚构的风景等,可能略胜一筹。当然Stable Diffusion因为模型庞大，对电脑的GPU性能要求高，每次输出速度会慢。
总的来说，Stable Diffusion是目前文本到图像生成的最领先模型,在大多数方面都超过mid journey。
不过Stable Diffusion的安装还是有不小门槛的。限于我手头只有Mac电脑，就先详细介绍一下Mac电脑如何安装Stable Diffusion。
02安装步骤
1、软硬件要求：
1）Mac电脑，最好是搭载m1或者m2的Mac本，内存在16G以上，这样运行速度会更快一些。当然如果你和我一样是旧本（MBP15款，16G），也是可以运行的，图片质量不会有太大差别，只是会比较慢；
2）硬盘空间：至少10个G，考虑到后续会添加不同的模型，所以最好有30G以上空间；
3）保持网络连接稳定；需要能够流畅访问内外网。
2、具体安装步骤如下：
1）从启动台打开terminal终端命令，也可以使用快捷键：control+空格键调起聚焦搜索，输入terminal，回车打开终端；
2）如果使用代理的，需要复制终端代理命令（你在电脑上安装代理的界面上通常会有这一项，直接点击即可复制），是以“export https_proxy=”开头的一段代码，复制到终端敲回车运行即可。
3）打开homebrew网站（https://brew.sh/），安装homebrew
- 点击页面右侧的复制操作，或者直接复制下面这段代码：
/bin/bash -c “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)”
- 在terminal内运行代码，即可安装。安装过程中看到**“password”是需要输入你电脑的开机密码，直接键盘输入，敲回车即可继续。这里面，如果电脑没有安装Xcode，会优先安装Xcode，再安装homebrew。显示“return/enter”**后再次敲回车，如果显示下面界面——Installation successful，则homebrew安装成功。
4）通过brew安装 python 等相关软件
复制下面这个安装文件，继续在当前终端窗口运行：
brew install cmake protobuf rust python@3.10 git wget
安装成功后关闭终端即可。
5）克隆stable diffusion webui
需要在自己的电脑里新建一个文件夹，比如我建的“SD-AI”，你点击右键可以选择“新建位于文件夹位置的终端窗口”，然后复制下面git地址到终端运行：
git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui
这样stable diffusion webui的github开源程序就可以全部克隆到自己的mac电脑本地了，原来的空文件就会展示stable-diffusion-webui文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfd9756dffd442304ea62bcab07c60ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e50aea592ed2e119bf6630cd8cfef595/" rel="bookmark">
			数组（Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一维数组 数组是相同类型元素的集合。
数组的定义和使用 数组的创建 数组名又叫引用变量，简称引用
下面代码段中new表示创建新的对象
T[ ] 数组名 = new T[ N ];//数组名又叫引用变量，简称变量 //T：表示数组中存放元素的类型 //T[]：表示数组的类型 //N：表示数组的长度 与C语言不同的是，数组在创建时数组类型 T[ ] 写的清楚明了，
而不像C语言中的创建为 :T 数组名 [ ]，数组类型为T [ ]，难以分辨
数组的初始化 数组的初始化主要分为动态初始化以及静态初始化。
动态初始化：在创建数组时，直接指定数组中元素的个数 int[] array = new int[10];//元素个数为10 静态初始化：在创建数组时不指定数据元素个数，直接将内容进行指定
静态初始化可以简写，省去后面的new T [ ] 。( 注意：虽然省去了new T [ ] , 但是编译器编译代码时还是会还原) T[] 数组名称 = {data1, data2, data3, ..., datan}; 数组也可以按照如下C语言个数创建，不推荐
该种定义方式不太友好，容易造成数组的类型就是int的误解 [ ] 如果在类型之后，就表示数组类型，因此int[]结合在一块写意思更清晰
int arr[] = {1, 2, 3}; 静态和动态初始化也可以分为两步，但是省略格式（省去了 new T [ ] ）不可以
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e50aea592ed2e119bf6630cd8cfef595/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72ea8ae3ee77156a6ee6b313b88f27ba/" rel="bookmark">
			怎么用AI生成PPT演讲稿？这六个AI工具值得一试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		花了好多时间赶制出来的PPT，却总觉得内容过于平淡，或者设计缺乏新意？
看到同事随手一做就能设计出精美的PPT文稿，你们是不是也特别羡慕？
不如来试试用ai制作PPT吧，只要输入关键词，就能完成制作，还有大量创作模板可选，轻松就能打造出精彩的文稿作品。
想知道什么软件可以AI生成PPT吗？快跟着我的步伐一起往下看吧。
『AI技术简化制作过程』--迅捷PPT
◮综合评分：4/5
◮使用体验：直观易用，减少PPT准备时间
◮软件介绍：
◔它通过AI技术简化了PPT的制作，能够智能分析输入的内容，快速生成具有专业外观的幻灯片。
◔提供有多种预设模板，覆盖各种行业，适应不同的演示需求。
◔支持智能排版，帮助大家自动调整文字和图片布局，确保视觉上的平衡和吸引力。
♠它还有网页版本呢，习惯网页操作的小伙伴也可以去试试~
『结合自然语言处理技术』--ChatBA
◮综合评分：3/5
◮使用体验：新颖交互，操作自然直观
◮软件介绍：
◔结合了自然语言处理的技术，可以根据语言描述自动创建幻灯片，通过聊天的方式生成文稿。
◔交互方式新颖，能够以更自然直观的方式创建演示文稿。
◔它的AI算法根据大家的描述，提供个性化的设计选项，满足不同的设计需求。
『提供个性化设计建议』--Desktopus AI
◮综合评分：3/5
◮使用体验：提升PPT吸引力，个性化选项
◮软件介绍：
◔它利用AI技术提供个性化的设计建议，快速填充页面，提升内容质量。
◔大家可以通过AI驱动的设计引擎，自动完成设计流程，提高制作效率。
『专注于简洁、高效的创作』--Gamma
◮综合评分：3/5
◮使用体验：操作简洁，适合商务演示
◮软件介绍：
◔作为AI驱动的演示文稿工具，它专注于提供简洁、高效的PPT制作体验。
◔可以快速识别大家的需求，并生成简洁专业的设计，带来高质量的作品。
◔通过提供丰富的图表类型和定制选项，适应不同的展示需求。
『提供布局优化的功能』--SlidesAI
◮综合评分：3/5
◮使用体验：提升演示专业度，自动化功能
◮软件介绍：
◔集成了AI技术，通过智能设计来提升演示的效果。
◔可以智能分析内容，并提供设计建议，优化演示文稿的流畅性和逻辑性。
『AI辅助PPT制作』--Tome
◮综合评分：3/5
◮使用体验：直观操作，智能推荐设计
◮软件介绍：
◔通过智能分析帮助大家创建内容丰富且设计精美的文稿。
◔可以根据内容自动生成幻灯片，并提供多种设计选项，适应不同的演示风格。
◔操作直观，根据内容智能推荐，提供优化建议，增强故事吸引力和完整性。
通过今天的分享，相信你们都知道什么软件可以AI生成PPT了，在它们的帮助下，我们可以在各个场景中制作出既美观又实用的演示文稿。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f846d693a911c75fc7b2da954e08218/" rel="bookmark">
			Spring Boot实现简单的登录注册功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、环境搭建
（一）创建数据库表
（二）创建Spring Boot项目
（三）引入依赖 （四）配置MyBatis
（五）导入包结构
二、注册接口
（一）使用Lombok的@DATE注解为实体类提供getter、setter、toString方法
（二）在pojo包中创建一个实体类（Result）
（三）编写实际代码
（四）进行数据校验
（五）异常处理
三、登录接口 （一）在UserController类中加入登录逻辑并添加JWT令牌
四、测试
（一）注册测试
（二）登录测试
一、环境搭建 （一）创建数据库表 我们需要用到的SQL语句（可复制备用）。
-- 创建数据库 create database big_event; -- 使用数据库 use big_event; -- 用户表 create table user ( id int unsigned primary key auto_increment comment 'ID', username varchar(20) not null unique comment '用户名', password varchar(32) comment '密码', nickname varchar(10) default '' comment '昵称', email varchar(128) default '' comment '邮箱', user_pic varchar(128) default '' comment '头像', create_time datetime not null comment '创建时间', update_time datetime not null comment '修改时间' ) comment '用户表'; -- 分类表 create table category( id int unsigned primary key auto_increment comment 'ID', category_name varchar(32) not null comment '分类名称', category_alias varchar(32) not null comment '分类别名', create_user int unsigned not null comment '创建人ID', create_time datetime not null comment '创建时间', update_time datetime not null comment '修改时间', constraint fk_category_user foreign key (create_user) references user(id) -- 外键约束 ); -- 文章表 create table article( id int unsigned primary key auto_increment comment 'ID', title varchar(30) not null comment '文章标题', content varchar(10000) not null comment '文章内容', cover_img varchar(128) not null comment '文章封面', state varchar(3) default '草稿' comment '文章状态: 只能是[已发布] 或者 [草稿]', category_id int unsigned comment '文章分类ID', create_user int unsigned not null comment '创建人ID', create_time datetime not null comment '创建时间', update_time datetime not null comment '修改时间', constraint fk_article_category foreign key (category_id) references category(id),-- 外键约束 constraint fk_article_user foreign key (create_user) references user(id) -- 外键约束 ) 首先打开IDEA配置数据源，选择自己的数据库软件（以MySQL为例）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f846d693a911c75fc7b2da954e08218/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d1f35c9a7271c8cf4e24e4379db9ebe/" rel="bookmark">
			javaSE:类和对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面向对象 java是一种面向对象的编程语言，面向对象就是把能为我们所用的东西直接拿来使用，省去中间过程，比如洗衣服，要完成这一个动作，我们本来需要一个盆，放水，放衣服，换水，放洗衣粉，手搓，拧干，晾衣服，这是面向过程的，我们一步一步是怎么实现的，而面向对象，就相当于我们直接把衣服扔进洗衣机，按下开关，然后洗衣机就能帮我们实现我们的目的，我们不需要管洗衣机是怎么洗的，直接用就好了；
再比如我们需要键盘录入，我们就会通过import关键字导入java已经帮我们写好的util包中的Scanner类，再通过new关键字，new一个对象出来，就可以使用键盘录入的功能了
类的定义 如何定义一个类呢？
类是用来对一个实体(对象)来进行描述的，定义了类中都具有什么属性（成员变量）
在java中,必须先设计类，才能获得对象
通过关键字class
格式是：
public class 类名{
成员变量成员方法构造方法代码块内部类 }
举例：我们定义一个学生类，我们写一个标准的javabean，不认识的关键字都会在下面一一讲解；
public class Student { private String name; private int age; private String sex; private String phone; private String email; //空参构造 public Student() { } //带参数的构造方法 public Student(String name, int age, String sex, String phone, String email) { this.name = name; this.age = age; this.sex = sex; this.phone = phone; this.email = email; } public String getName() { return name; } public void setName(String name) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d1f35c9a7271c8cf4e24e4379db9ebe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d738811ac1396501963727c2608cc877/" rel="bookmark">
			vue项目基于WebRTC实现一对一音视频通话
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果 前端代码 &lt;template&gt; &lt;div class="flex items-center flex-col text-center p-12 h-screen"&gt; &lt;div class="relative h-full mb-4 fBox"&gt; &lt;video id="localVideo"&gt;&lt;/video&gt; &lt;video id="remoteVideo"&gt;&lt;/video&gt; &lt;div v-if="caller &amp;&amp; calling"&gt; &lt;p class="mb-4 text-white"&gt;等待对方接听...&lt;/p&gt; &lt;img style="width: 60px;" @click="hangUp" src="@/assets/guaDuang.png" alt=""&gt; &lt;/div&gt; &lt;div v-if="called &amp;&amp; calling"&gt; &lt;p&gt;收到视频邀请...&lt;/p&gt; &lt;div class="flex"&gt; &lt;img style="width: 60px" @click="hangUp" src="@/assets/guaDuang.png" alt=""&gt; &lt;img style="width: 60px" @click="acceptCall" src="@/assets/jieTing.png" alt=""&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;button @click="callRemote" style="margin-right: 10px"&gt;发起视频&lt;/button&gt; &lt;button @click="hangUp" style="margin-left: 10px"&gt;挂断视频&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { io, Socket } from "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d738811ac1396501963727c2608cc877/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8fe4a1f10ddad0961118a93ad8f1812/" rel="bookmark">
			数据库迁移·Oracle--＞Dm(达梦)、Kingbase-pg(人大金仓)、Vastbase-g100(海量)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本节内容：
如何使用工具，将Oracle数据库数据正确迁移到达梦、人大金仓、海量数据库。
迁移工具获取地址：
链接：https://pan.baidu.com/s/1KybSgyjwjhGBaDkahJeaHA?pwd=1024
提取码：1024
含dm8+Kingbase Windows安装包
数据库安装教程： Docker部署数据库--达梦(DM) Docker部署数据库--人大金仓（kingbase） Docker部署数据库--高斯DB(opengauss) Docker部署数据库--海量数据库Vastbase-g100 拓展内容：
迁移前先清理oracle数据库的回收站： -- 清除回收站里的信息 例如 存在："BIN$MWHn5aSuRwmw04EqfTcpTQ==$0" -- 清除指定表：purge table ; -- 清除当前用户的回收站：purge recyclebin; -- 清除所有用户的回收站：purge dba_recyclebin; 在 Oracle 数据库中，回收站（Recycle Bin）是一个特殊的功能，用于在删除表或索引时将其放入回收站而不是永久删除。回收站允许您在需要时还原或彻底删除这些对象。 回收站中存储的内容包括已被删除的表、索引、视图和其他数据库对象。当您执行 DROP 命令删除这些对象时，它们会被移到回收站中，并保留一段时间，以便您可以在需要时进行恢复。 用到的工具： 迁移工具：达梦迁移工具、人大金仓DTS、海量exbase 数据库连接工具：达梦管理工具、Navicat15 主要内容：
0x001:达梦数据库用户创建+数据迁移； 0x002：人大金仓用户创建+数据迁移； 0x003：海量用户创建+数据迁移； 0x004：open高斯用户创建+数据迁移； 0x001:达梦数据库用户创建+数据迁移；
达梦常用sql：
-- 创建表空间 create tablespace "GRP" datafile '/data/dm8/DAMENG/GRP01.DBF' size 64 autoextend on next 1024 maxsize 33554431 CACHE = NORMAL; -- 创建用户 create user "GSU_FRS_0506" identified by "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8fe4a1f10ddad0961118a93ad8f1812/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/751ae993157c7f3ffbf4dd7c31c50d21/" rel="bookmark">
			AI绘画进阶工具ComfyUI 傻瓜整合包安装教程！模型共享，一键安装！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈喽大家好，今天给大家分享一下AI绘画工具Stable Diffusion的另一种UI界面，常见的有：
窗口式界面的WebUI
节点式工作流的ComfyUI
ComfyUI更加进阶一些，是一个节点式工作流的AI绘画界面，它高度可定制、自定义编辑Ai生成图片的流程。
官方的整合包打包方式导致依赖安装问题，推荐秋叶大神的整合包
一、ComfyUI 简介 ComfyUI 本体 Github 主页：https://github.com/comfyanonymous/ComfyUI （注意：访问需要科学上网）
ComfyUI 和同学们熟知的 WebUI 一样，都是 Stable Diffusion 的一种用户界面，可以实现文生图、图生图、图像处理、AI 视频生成等操作。但 ComfyUI 是节点式模块化的界面，需要用户自己搭建工作流，而且各方面的资源比较松散，需要自己安装部署，因此入门难度较高，不适合零基础的 AI 绘画小白，一般都推荐同学们先掌握 Stable Diffusion WebUI 的用法，再学习 ComfyUI。
ComfyUI 越来越受欢迎，是因为用户可以按需要搭建自定义工作流，高效完成各种图像生成任务，很多最新的 AI 技术比如 SVD、InstantID 发布没多久就能在 ComfyUI 中用上，这点是 WebUI 做不到的；ComfyUI 会将图像生成流程保存为工作流（workflow）文件，下次使用时直接拖入界面加载就行，这样不仅方便自己复用已有工作流，还能轻松借用大神的生成作品；而且 ComfyUI 对低显存用户也更友好，在 WebUI 中容易爆显存生成任务在 ComfyUI 中可以顺利完成。
ComfyUI 界面：
二、整合包安装方式 ComfyUI整合包下载（请看文末扫描获取最新版安装包）
首先我们下载最并解压 v1.9 整合包，解压后找到里面的 “ A 绘世启动器” 程序文件并双击启动，等待程序验证后就能看到熟悉的绘世启动器界面了。启动器首页的 4 个按钮可以帮我们快速打开根目录、自定义节点（custom nodes）目录、图片储存等路径；右下角的 “一键启动” 用于开启网页操作界面。
正式使用前还需要查看「版本管理」版块的相关内容，里面包含内核管理、拓展管理和安装新扩展 3 项重要功能。
「内核」里面会显示 ComfyUI 本体的版本更新情况，一般都需要更新到最新版本，否则某些节点会使用不了。更新方法为先点击右上角的刷新按钮，然后点击最新版本一行末尾的 “切换”按钮，确定后系统会弹出绿色的提示框，末尾的方框也会变成勾选的状态，表示版本切换成功。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/751ae993157c7f3ffbf4dd7c31c50d21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6189722e4a66657f7403490a8eb7bfc3/" rel="bookmark">
			【AIGC调研系列】GPT-4O比GPT-4强在哪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GPT-4O与GPT-4在多个方面有所不同，主要体现在性能、响应速度、成本效益以及多模态处理能力上。
性能提升：GPT-4O在文本分析、推理和编程能力上相较于GPT-4有显著提升。特别是在视觉和音频理解能力上，GPT-4O表现出更优越的性能[3][8][10]。响应速度：GPT-4O的响应速度是GPT-4 Turbo的两倍，具体到音频输入的响应时间，最短可达232毫秒，平均320毫秒，这使得它在实时交互方面具有明显优势[1][2][5]。成本效益：GPT-4O的使用成本比GPT-4低50%，这对于开发者来说是一个重大的吸引力，因为它降低了实施成本，同时提高了使用率限制[2][3][15]。多模态处理能力：GPT-4O支持文本、音频、图像任意组合的输入，并能以同样的方式输出。这表明GPT-4O不仅能够处理传统的文本数据，还能理解和生成与之相关的音频和视觉内容[4][12][16]。 GPT-4O在保持与GPT-4相当的智能水平的同时，通过技术改进和优化，在响应速度、成本效益以及多模态处理能力上都有显著的提升。这些改进使得GPT-4O在实际应用中更具竞争力，尤其是在需要快速响应和高效处理多种数据类型的场景中[7][18][27]。
GPT-4O在视觉和音频理解能力上的具体表现和技术细节是什么？ GPT-4O在视觉和音频理解能力上的具体表现和技术细节如下：
视觉理解能力： GPT-4O能够理解和处理图像及其内容，包括图像中的文本信息。这意味着它可以同时处理和理解图像以及图像中包含的文本内容[30]。它具备原生多模态能力，不仅能处理文本、音频和图像任意组合的输入，还能对这些输入进行深入理解[31]。GPT-4O的视觉功能还包括阅读网页并转录图像和视频中的内容。其训练数据包括渲染的LaTeX/文本、网页截图、YouTube视频采样帧等[34]。此外，GPT-4O还能分析和理解图像内容，提供描述、识别对象，甚至解释场景，为图像分类、对象检测和视觉内容审核提供了可能性[37]。音频理解能力： GPT-4O在响应速度上有显著提升，最快232毫秒响应音频输入，平均响应时间为320毫秒，与人类在对话中的响应速度相当[32][33]。它能够整合处理视觉和文本信息，这暗示了其在音频方面也具有高度的整合和理解能力[30]。在训练数据方面，GPT-4O使用了YouTube视频采样帧，并运行Whisper（OpenAI的语音识别大模型）来获得transcript，这表明其在音频理解方面采用了高级的技术手段[34]。 GPT-4O在视觉和音频理解能力上的表现体现在其强大的多模态推理能力、快速的响应速度以及对复杂数据集的处理能力上。
GPT-4O的响应速度提升是如何实现的，与GPT-4 Turbo相比有哪些关键技术或方法？ GPT-4o的响应速度提升主要通过以下几个关键技术或方法实现：
多模式支持：GPT-4o支持多种输入和输出模式，包括文本、图像等，这使得其在处理非英语语言文本方面具有显著优势[41]。API性能提升：与GPT-4 Turbo相比，GPT-4o在API中提供了更快的速度和更低的成本，同时还能处理速率限制高出5倍的情况[40]。视觉和音频表现：GPT-4o在视频和音频方面的表现尤为出色，这表明它在处理这些特定类型的内容时具有较强的能力[42]。类人响应速度：GPT-4o能够在短至0.23秒（平均为0.32秒）的时间内响应音频输入，其响应速度与人类相似，这一点在与GPT-3.5对话时尤为明显[43][46]。成本效益：GPT-4o不仅在速度上有所提升，还在成本上实现了50%的降低，这使得其在经济性方面也具有优势[41]。多语言支持：GPT-4o能够处理50种不同的语言，这进一步证明了其在全球范围内的应用潜力[47]。 GPT-4O使用成本降低50%的具体原因是什么，与GPT-4在性能和功能上有哪些显著差异？ GPT-4O使用成本降低50%的具体原因主要包括以下几点：
技术优化和规模经济：通过在一个模型中集成所有模态，GPT-4O实现了更精细的多模态整合，这不仅提高了效率，还降低了成本[50][51][54]。此外，流式传输的神经网络也为进一步控制成本提供了可能[53]。性能提升与速率限制提高：与GPT-4 Turbo相比，GPT-4O的速度提高了2倍，同时速率限制提高了5倍，这直接导致了成本的大幅降低[52]。 在性能和功能上，GPT-4O与GPT-4的显著差异包括：
多模态支持：GPT-4O能够识别物体并根据视觉做出快速响应和回答，这表明它具有更强的逻辑推理能力[49]。此外，它还能感知情绪、语气、表情，实现更自然的人机交互[50][51]。跨文本、音频和视频的实时推理能力：GPT-4O可以跨文本、音频和视频进行实时推理，这使得它在非英语文本上的性能显著提高[55]。更快的生成速度：GPT-4O的生成速度比GPT-4 Turbo快2倍，这意味着用户可以更快地获得回答或内容[49]。 GPT-4O在成本和功能上的优势主要来源于其技术优化、多模态整合以及对大规模数据处理的能力提升。
GPT-4O如何处理文本、音频、图像的多模态输入，其技术原理和实现方式是什么？ GPT-4O处理文本、音频、图像的多模态输入主要依赖于其作为一个原生多模态模型的特性。这种模型能够直接理解和处理这些不同类型的数据，而无需将它们转换为同一种格式，如先将音频转录为文本再进行处理[61][63]。GPT-4O通过端到端的方式处理所有输入和输出，这意味着所有的文本、视觉和音频数据都由同一个神经网络处理[62][66]。
具体来说，GPT-4O利用其强大的语言模型能力，对文本数据进行处理。对于音频输入，它能够直接映射音频到音频，实现低延迟的实时交互[68]。而对于图像输入，虽然具体的技术细节未在证据中明确描述，但可以推测，GPT-4O同样能够直接理解图像内容，并与文本和音频数据一起被模型处理。
此外，GPT-4O在处理多模态输入时展现出了天然的多模态特性，能够处理文本、音频、图像任何组合的输入和输出，这一点是向更自然人机交互迈进的重大步骤[67]。这种能力不仅提升了人机交互的效率和自然度，也使得GPT-4O在速度和成本方面相比前代产品有了显著的提升[59]。
总结来说，GPT-4O通过其作为原生多模态模型的设计，以及端到端的处理方式，实现了对文本、音频、图像等多种模态输入的高效处理。
在实际应用场景中，GPT-4O的多模态处理能力对用户体验有何影响，是否有具体的案例研究或反馈？ GPT-4O的多模态处理能力对用户体验产生了显著的正面影响。首先，GPT-4O能够处理文本、音频和图像等多种模态的输入，这使得它能够提供更自然、流畅的交互体验[77]。例如，它可以在最快232毫秒内响应音频输入，与人类对话的反应速度基本一致，这相比之前的模型有了明显的提升[78]。
此外，GPT-4O的多模态能力还被应用于特定的实际场景中，如帮助盲人通过实时视觉和语音能力了解周围环境并做出决策[76]。这种应用不仅展示了GPT-4O技术的先进性，也极大地改善了目标用户群体的生活质量。
从商业角度来看，GPT-4O的多模态处理能力也为企业带来了便利，例如在智能终端Agent和机器人等领域的应用，有望提升用户体验[69]。此外，GPT-4O的易用性大幅提升，语音响应延迟大幅降低，这些都有助于增强其在各行各业中的应用潜力[75]。
总结来说，GPT-4O的多模态处理能力不仅提高了用户交互的自然度和流畅性，还通过具体的应用案例，如辅助盲人“看见”世界，直接改善了用户的生活质量，同时也为企业提供了更多的商业机会和效率提升。
参考资料 1. GPT-4o API 全新版本发布：性能更高，价格更优惠
2. We tried out GPT-4o, and it's so much faster than GPT-4 - XDA Developers
3. 如何评价 OpenAI 2024 Spring 发布的支持实时语音对话的模型 GPT-4O? - 知乎
4. 基本就是AGI？GPT-4o“它”来了
5. 一文总结OpenAI新发布的GPT-4o的能力和信息，免费ChatGPT用户也可以使用的GPT-4模型，开发者接口价格下降一半，数学推理评测 ...
6. GPT-4o大模型凭性能翻倍，揭示AI未来新篇章
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6189722e4a66657f7403490a8eb7bfc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39f33602c5de6302b8b4f9482a4afc44/" rel="bookmark">
			AI绘画Stable Diffusion | 如何利用SD垫图实现照片风格转换，动漫真人互转教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“ 小红书上有很多用AI做卡通头像的，大概思路是你拍一张个人照片发给博主，博主利用midjourney的垫图功能转换成卡通形象，一张收取一定费用……”
稍微了解AI绘画的人都应该知道，midjourney是付费的软件，而且需要一定魔法上网能力。
今天给大家分享，利用免费的AI绘画工具Stable Diffusion（以下简称SD）的垫图功能，实现真人照片风格转换。
虽然SD用起来没有midjourney体验好，但是软件免费，而且可控性好，因此就选它了。
01、工具准备 准备好SD webui工具，contronet版本要在V1.140以上，也可以直接升级到最新版本V1.440。（如果你的SD没有ControlNet插件，请看文末扫描获取插件安装包哦）
ControlNet等插件升级，依次点击SDwebui界面上的扩展，已安装，检查更新，出现升级检查进度条，然后勾选最新版本，如下图。
我们利用contronet控制类型IP-Adapter来垫图，提前下载对应模型，放入stable-diffusion-webui\models\ControlNet目录。（模型已备好，请看文末扫描获取IP-Adapter模型文件）
02、案例讲解 2.1 书写提示词，描述你想要的内容
模型这里选择的是大模型xxmix9realistic_v40，没有使用lora模型，
在文生图界面，第一个输入框，输入以下正向提示词，也就是你想要的内容描述：
masterpiece,best quality,hyper quality,8k,insane details,intricate details,hyperdetailed,high detail,ultra detailed,
大师级，最好画质，高品质，8K，疯狂的细节，复杂的细节，超详细的，高细节，超细节
Realistic, RAW photo, dslr, soft lighting, film grain,Fuji film XT3, Screen Space Refraction, high detailed skin, natural skin texture,cartoon, eye facing lens
真实感，RAW照片，dslr，柔和照明，胶片颗粒，富士胶片XT3，屏幕空间折射，高细节皮肤，自然皮肤纹理，卡通，鱼眼镜头
1 girl,solo,Grape Purple long curly hair,light proof,gentle smile,silver gray background,
1个女孩，独自，葡萄紫长卷发，耐光，温柔的微笑，银灰色背景，
第二个输入框，输入以下负向提示词，也就是你不想在AI生成图片中看到的内容，画人物一般都是通用的提示词。
NSFW, nude, naked, porn, (worst quality, low quality:1.4), deformed iris, deformed pupils, (deformed，distorted, disfigured:1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39f33602c5de6302b8b4f9482a4afc44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/913d93e9214518aea50b10a31dc05dcc/" rel="bookmark">
			Stable Diffusion入门使用技巧及个人试用实例分享--SD提示词及ControlNet篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上节我们简单介绍了一下Stable Diffusion的基础模型及lora，今天我们接着讲解一下SD提示词的实践篇及ControlNet常用模型篇，本文总字数3000+，同时包含大量的图片及提示词分享。欢迎阅读。
SD如何写提示词 提示词库分享在文末！免费领取
下面是我多方整理以及自己常用的一些标准提示词，在我的案例中，大家也基本能看出来，我经常用这些提示词。 我按标准提示词、内容提示词、画幅构图视角、提示词的权重分配、正向提示词示例、反向提示词给大家都举了一些例子，欢迎尝试。
一、标准提示词 提示词库分享在文末！免费领取
通用高画质：
masterpiece:杰作
nsanely detailed，ultra-detailed，highly detailed：疯狂的细节，超精细的细节绘制
best quality：高质量
特定高分辨率类型：
HD Quality：高清
8k：8k高清
sharp focus：焦点清晰
unreal engine rendered：虚幻渲染
画家风格：
19世纪肖像画家：John Collier
偏写实和现代风格：Stanley Artgerm Lau
擅长女性肖像，偏印象派：John Singer Sargent
擅长画平面肖像：Alphonse Mucha
画风：
插画风：illustration,painting,paintbrush
二次元：anime,comic,game CG
写实系：photorealistic,realistic,photograph，Ultra realistic illustration
肖像画风：Portrait 用于生成脸部或者头像
数字艺术风格：Digital painting
2D插图风格：Concept art
Ultra realistic illustration
风格：
印象派：hyperrealistic
超现实主义：fantasy
波普艺术：surrealist
二、内容提示词： 人物及主体特征：
精致的脸，清晰的脸：exquisite face，clear face
服饰搭配：white dress
发型发色：blonde hair,long hair
五官特点：small eyes, big mouth
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/913d93e9214518aea50b10a31dc05dcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67cb786e10e04bb0cdcfe042fe49e4c7/" rel="bookmark">
			Linux启动或重启mysql失败:Job for mysqld.service failed because the control process exited with erro（多种解决方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天重装在centos 的linux上重装了mysql，然后发现报了如下错误：
Job for mysqld.service failed because the control process exited with error code. 原因有很多，具体要看日志记录信息，解决方法如下：
Linux启动或重启mysql失败:Job for mysqld.service failed because the control process exited with error code._linux mysql启动失败 job for mysql.service failed becau-CSDN博客
CentOS 7下MySQL服务启动失败的解决思路 - iVictor - 博客园 (cnblogs.com)
MySQL 启动报错：Job for mysqld.service failed because the control process exited with error code.-CSDN博客
问题记录之mysql：Job for mysqld.service failed because the control process exited with error code. See "systemctl status mysqld.service" and "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67cb786e10e04bb0cdcfe042fe49e4c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f285c9896752128f2c794183bb4f8418/" rel="bookmark">
			finallyshell激活-支持所有版本（老版 &#43; 最新版） &#43; 所有平台（mac &#43; windows）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：打开finally shell的激活页面 二：点击离线激活 三：复制机器码，然后执行一下代码 原文：大哥原文，但是这个大佬是用java实现的，执行因为依赖的问题一直报错
基于以上问题，所以使用python改造实现了一下。
本次激活支持Windows + mac 平台，同时支持所有所有版本的finallshell（eg: 4.3.11 、3.9.6 …）
直接执行以下代码即可：
# 安装包 pip3 install pycryptodome from hashlib import md5, sha3_384 from Crypto.Hash import keccak def md5_hash(msg): return md5(msg.encode()).hexdigest() def keccak384_hash(msg): keccak_hash = keccak.new(digest_bits=384) keccak_hash.update(msg.encode()) return keccak_hash.hexdigest() def main(): code = input("输入机器码: ") print("版本号 &lt; 3.9.6 (旧版)") try: print("高级版: " + md5_hash("61305" + code + "8552")[8:24]) print("专业版: " + md5_hash("2356" + code + "13593")[8:24]) except Exception as e: print(str(e)) print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f285c9896752128f2c794183bb4f8418/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/024dab311a1674c6f51f30711e31ab29/" rel="bookmark">
			一文搞懂前端渲染技术：什么是SSR、SSG、CSR？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前端开发的世界里，我们经常遇到SSR（服务器端渲染）、SSG（静态站点生成）和CSR（客户端渲染）这三种渲染技术。它们各自有着独特的优缺点，适用于不同的场景和需求。下面，我们将详细介绍这三种技术，并通过代码示例来加深理解。
一、CSR（客户端渲染） 介绍：
CSR（Client-Side Rendering）是前端开发中最常见的渲染方式。在这种模式下，服务器主要负责提供静态的HTML文件（可能包含一些基本的HTML结构和JavaScript脚本），而真正的页面渲染工作则完全由客户端的浏览器来完成。这意味着页面内容是在用户的浏览器上动态生成的。
优点：
响应速度快：一旦HTML文件加载完成，浏览器就可以开始渲染页面，而不需要等待服务器返回完整的渲染结果。动态性强：由于页面渲染在客户端进行，因此可以方便地实现各种动态交互效果。前端部署简单：只需要一个静态服务即可部署前端代码，降低了部署成本。 缺点：
首屏加载时间长：由于需要加载整个JavaScript包，可能导致首屏加载时间较长，特别是对于复杂的单页应用（SPA）。不利于SEO：搜索引擎爬虫可能无法很好地解析由JavaScript动态生成的页面内容，导致SEO效果较差。白屏时间：在JavaScript代码加载和执行期间，用户可能会看到空白的页面，即所谓的“白屏时间”。 示例（使用React）：
// 假设有一个React组件 import React from 'react'; function MyComponent() { const [message, setMessage] = React.useState('Hello, CSR!'); const handleClick = () =&gt; { setMessage('Clicked!'); }; return ( &lt;div&gt; &lt;p&gt;{message}&lt;/p&gt; &lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt; &lt;/div&gt; ); } // 在HTML文件中引入React和组件的JavaScript文件 // 浏览器加载并执行这些JavaScript，从而渲染页面 二、SSR（服务器端渲染） 介绍：
SSR（Server-Side Rendering）是一种在服务器端完成页面渲染的技术。在这种模式下，服务器接收到客户端的请求后，会先根据请求数据和模板文件生成完整的HTML页面，然后将这个页面直接发送给客户端。这样，用户可以直接看到完成的内容，无需等待JavaScript加载和执行。
优点：
首屏加载速度快：由于服务器已经生成了完整的HTML页面，因此客户端可以直接显示这个页面，无需等待JavaScript加载和执行。SEO友好：搜索引擎爬虫可以很好地解析由服务器生成的HTML页面内容，有利于SEO优化。适合复杂页面：对于包含大量数据、需要复杂计算的页面，SSR可以更好地处理并减少客户端的负载。 缺点：
服务器压力大：对于每个请求，服务器都需要重新渲染页面，这可能导致服务器压力过大。开发限制：SSR要求开发者在编写Vue组件时，需要考虑到服务器端和客户端环境的差异，不能过度依赖客户端环境。调试困难：SSR的调试过程相对复杂，需要同时考虑到服务器端和客户端的日志和错误信息。 示例（使用React的服务器端渲染）：
// 服务器端代码（Node.js） const React = require('react'); const ReactDOMServer = require('react-dom/server'); const MyComponent = require('.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/024dab311a1674c6f51f30711e31ab29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d047252d26feed93f07b38459f63ec01/" rel="bookmark">
			【AI语音基础】ASR基本知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
背景
语音识别ASR原理
HMM隐马尔可夫链语音识别
端到端语音识别
识别衡量标准
参考1
参考2
参考3
参考4
背景 语音识别（Speech Recognition）也被称为自动语音识别（英语：Automatic Speech Recognition, ASR），将语音音频转换为文字的技术。
简单点说：把语音音频转化为文字。
语音识别ASR原理 新手语音入门（三）： 语音识别ASR算法初探 | 编码与解码 | 声学模型与语音模型 | 贝叶斯公式 | 音素-云社区-华为云 (huaweicloud.com)
编码过程：语音识别的输入是声音，计算机无法直接处理，
需要编码过程将其转变为数字信息，并提取其中的特征进行处理。
编码时一般会将声音信号按照很短的时间间隔，切成小段，成为帧。
对于每一帧，可以通过某种规则（例如MFCC特征）提取信号中的特征，将其变成一个多维向量。向量中的每个维度都是这帧信号的一个特征。
解码过程：解码过程则是将编码得到的向量变成文字的过程，需要经过两个模型的处理，一个模型是声学模型，一个模型是语言模型。
声学模型通过处理编码得到的向量，将相邻的帧组合起来变成音素，如中文拼音中的声母和韵母，再组合起来变成单个单词或汉字。语言模型用来调整声学模型所得到的符合逻辑的字词，使识别结果变得通顺。 已知一段音频信号，处理成声学特征向量Acoustic Feature Vector后表示为，X=[x1,x2,x3,…]X=[x1​,x2​,x3​,…],其中xixi​表示一帧特征向量；可能的文本序列表示为W=[w1,w2,w3,…]W=[w1​,w2​,w3​,…],其中wiwi​表示一个词，求W∗=argmaxwP(W∣X)W∗=argmaxw​P(W∣X)，这便是语音识别的基本出发点。并且由贝叶斯公式可知：
其中，P(X∣W)P(X∣W)称之为声学模型（Acoustic Model, AM）, P（W）P（W）称之为语言模型（Language Model, LM），由于P(W)P(W)一般是一个不变量，可以省去不算。
许多研究将语音识别问题看做声学模型与语音模型两部分，分别求取P(X∣W)P(X∣W)和P(W)P(W)。
后来，基于深度学习和大数据的端对端（End-to-End）方法发展起来，直接计算P(W∣X)P(W∣X)，把声学模型和语言模型融为了一体。
语音识别的问题可以看做是语音到文本的对应关系，语音识别问题大体可以归结为文本基本组成单位的选择上。单位不同，则建模力度也随之改变。
图中文本基本组成单位从大到小分别是：
整句文本，如“Hello
World”,对应的语音建模尺度为整条语音。
词，如孤立词“Good”、“World”、对应的语音建模尺度大约为每个词的发音范围。
音素，如将“world”进一步表示为“/wɘrld//wɘrld/”,其中的每个音标作为基本单位，对应的语音建模尺度则缩减为每个音素的发音范围。
三音素，即考虑上下文的音素，如将音素“/d//d/”进一步表示为“/l−d−sil,/u−d−l/,…/l−d−sil,/u−d−l/,…”,对应的语音建模尺度是每个三音素的发音范围，长度与单音素差不多。
隐马尔可夫模型状态，即将每个三因素都用一个三状态隐马尔可夫模型表示，并用每个状态作为建模粒度，对应的语音建模尺度将进一步缩短。
上面每种实现方法都对应着不同的建模粒度，大体可以分为以隐马尔可夫模型结构和端对端的结构。
HMM隐马尔可夫链语音识别 新手语音入门（四）： 传统语音识别技术简介 | 隐马尔可夫链 | 声学/语言模型 | WFST解码-云社区-华为云 (huaweicloud.com)
隐马尔可夫链HMM模型自从1980年代被用于语音识别以来，一直都是实际语音识别系统的主流方法。
声学模型 P(X∣W)P(X∣W)对应的是声学模型，首先需要考虑的是，语音和文本的不定长关系使得二者的序列之间无法一一对应。隐马尔可夫链模型正好可以解决这个问题。
比如P(X│W)=P(x1,x2,x3∣w1,w2)P(X│W)=P(x1​,x2​,x3​∣w1​,w2​)可以表示成上面隐马尔可夫链的形式，图中ww是HMM的隐含状态，xx是HMM的观测值，隐含状态数与观测值数目不受彼此约束，这便解决了输入输出的不定长问题，并有:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d047252d26feed93f07b38459f63ec01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/570fee3549bb049a40ff78ea28316075/" rel="bookmark">
			uniapp开发h5页面的扫码功能(html5-qrcode和mumu-getQrcode两种方式)，以及后续用安卓扫码传h5的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后续 后续就是下面两方法都无法解决http的问题，安卓开发说不是混合开发吗？你让我来调摄像头，有值传你不就行了。。。
具体方法：点扫码时调安卓函数，让安卓知道要扫码了，然后在main.js绑定事件window.android.scanBarcode()(备注：事件名字是安卓给的，相当于自己取的函数名称，后面这个一样，别被误导了) ，安卓扫码后触发一个window.handleScanResult，这个事件传值回来，把window事件赋值给自己的this.什么的vue函数事件就行了，下面看看我的源代码
dome.vue
// 扫码 scanCode() { this.$toast({ title: '测试-1.5s后进入扫码' }, () =&gt; { console.log('测试扫码'); // 核心是调安卓的函数 if (window.android) { window.android.scanBarcode() } }) }, // 监听扫码结果，和下面的main.js相呼应 watch: { '$store.state.scanCode'(newVal) { if (newVal) { this.form.CowID = newVal this.$store.commit('setScanCode', '') } } }, main.js
// 处理扫码 window.handleScanResult = (result) =&gt; { //我这里是存vuex中，存本地或者其他方式也可以 store.commit('setScanCode', result) } 上面是后续，下面是原文： 说明 只支持https域名
只支持https域名
只支持https域名
因为uniapp自带的api不支持h5，而且非微信环境也无法使用公众号jsjdk的扫码，只能尝试其他方法
但是发现只能https域名才可以调用，其他所有人的都不许http域名。
开发调试记得去把这两个点起来，manifest.json =&gt; web配置 =&gt; 启动https协议 ，和 App模块配置 =&gt; 打包模块配置 =&gt; Barcode扫码（相当于你在源码视图加
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/570fee3549bb049a40ff78ea28316075/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/361/">«</a>
	<span class="pagination__item pagination__item--current">362/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/363/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>