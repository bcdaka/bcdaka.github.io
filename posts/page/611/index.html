<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dad7f4415c02621817ed0dde8721ba64/" rel="bookmark">
			判断素数的常见方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 ​一、素数的定义二、素数测试：暴力法三、暴力法的优化：试除法四、素数生成：埃氏筛五、埃氏筛的优化：欧拉筛欧拉筛的原理欧拉筛代码示例(C++)欧拉筛的正确性证明欧拉筛的线性时间复杂度证明 六、参考资料 ​一、素数的定义 素数(Prime number)，又称质数，是指在大于1的自然数中，除了1和它自身外，不能被任何其他自然数整除的数叫做质数；否则称为合数。
值得注意的是，0 与 1 既不是素数，也不是合数。
二、素数测试：暴力法 素性测试(Primality test)，或素数判定，是检验一个给定的整数是否为素数的测试。
判断 n n n 是否为素数时，最简单的方式就是暴力法(Brute Force)：遍历的所有大于 1 且小于 n n n 的整数，判断 n n n 是否可以被这些数整除，如果不存在可以整除的数，则为素数；否则为合数。
bool isPrime(int n) { for (int i = 2; i &lt; n; ++i) { // 遍历大于1且小于根号n的整数 if (n % i == 0) { // 如果n可以被某数整除，则为合数 return false; } } return true; // 遍历结束，则为素数 } 优点： 简单易懂，完全利用了素数的定义。 缺点： 时间复杂度为 O ( n ) O(n) O(n), 当需要判断大量的数时十分缓慢。 如果需要判断从 1 到 n n n 的的每一个数，则总体时间复杂度为 O ( n 2 ) O(n^2) O(n2).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dad7f4415c02621817ed0dde8721ba64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fee4bbc11b26c73b988d6b7b07d90119/" rel="bookmark">
			【第十一届泰迪杯数据挖掘挑战赛】A 题：新冠疫情防控数据的分析 思路&#43;代码（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【第十一届泰迪杯数据挖掘挑战赛】A 题：新冠疫情防控数据的分析 思路+代码（持续更新） 问题背景解决问题代码下载数据分析Task1Task2Task3Task4 问题背景 自 2019 年底至今，全国各地陆续出现不同程度的新冠病毒感染疫情，如何控制疫情蔓 延、维持社会生活及经济秩序的正常运行是疫情防控的重要课题。大数据分析为疫情的精准 防控提供了高效处置、方便快捷的工具，特别是在人员的分类管理、传播途径追踪、疫情研 判等工作中起到了重要作用，为卫生防疫部门的管理决策提供了可靠依据。疫情数据主要包 括人员信息、场所信息、个人自查上报信息、场所码扫码信息、核酸采样检测信息、疫苗接 种信息等。 本赛题提供了某市新冠疫情防疫系统的相关数据信息，请根据这些数据信息进行综合分 析，主要任务包括数据仓库设计、疫情传播途径追踪、传播指数估计及疫情趋势研判等。 解决问题 根据核酸检测中阳性人员的出行时间与场所追踪密接者，将结果保存到
“result1.csv”文件中（文件模板见附件 1 中的 result1.csv）。由问题 1 的结果，根据密接者的出行时间与场所追踪相应的次密接者，将结果保存
到“result2.csv”文件中（文件模板见附件 1 中的 result2.csv）。建立模型，分析接种疫苗对病毒传播指数的影响。根据阳性人员的数量及辐射范围，分析确定需要重点管控的场所。为了更精准地进行疫情防控和人员管理，你认为还需要收集哪些相关数据。基于这
些数据构建模型，分析其精准防控的效果。
注 在解决上述问题时，要求结合赛题提供的数据信息表建立数据仓库，实现数据治理
的内容，请在论文中明确阐述做了哪些数据治理工作，具体是如何实现的。
！！注意：以下代码是在Aistudio上面写的，因此就没有建立相关数据库，根据题目要求你们自行建立数据库，然后在代码中进行读取就好了。 代码下载 代码下载地址：第十一届泰迪杯数据挖掘挑战赛-ABC-Baseline
大家Fork项目即可查阅所有代码了（free）
本项目仅供学习参考，鼓励大家以赛促学，为了保证比赛的公平性（只提供初级Baseline及简易思路分享）
若涉嫌违规，将会第一时间删除项目
注：思路仅代表作者个人见解，不一定正确。 数据分析 导入常用的包 import pandas as pd import numpy as np import matplotlib.pyplot as plt import seaborn as sns from tqdm import tqdm import warnings warnings.filterwarnings('ignore') %matplotlib inline 导入文件的时候发现，附件的编码有问题，因此我们需要封装一个获取文件编码的函数 # 获取文件编码 import chardet def detect_encoding(file_path): with open(file_path,'rb') as f: data = f.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fee4bbc11b26c73b988d6b7b07d90119/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de750874c178129c90c390078fe7df45/" rel="bookmark">
			java 使用stream累加对象中某个属性的值并返回总和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假设有一个包含对象的List列表，每个对象都有一个属性value，可以使用Java 8中的Stream流来累加对象中某个属性的值并返回总和。以下是一些可能的实现方法：
1、使用reduce方法： List&lt;MyObject&gt; list = ...; int sum = list.stream().mapToInt(MyObject::getValue).reduce(0, Integer::sum); 这里使用了mapToInt方法将每个对象转换为其value属性的值，然后使用reduce方法将这些值累加起来。
2、使用sum方法：
List&lt;MyObject&gt; list = ...; int sum = list.stream().mapToInt(MyObject::getValue).sum(); 这里也使用了mapToInt方法将每个对象转换为其value属性的值，然后使用sum方法将这些值累加起来。
3、使用forEach方法：
List&lt;MyObject&gt; list = ...; AtomicInteger sum = new AtomicInteger(); list.stream().forEach(o -&gt; sum.addAndGet(o.getValue())); 这里使用了AtomicInteger来存储总和，并使用forEach方法遍历每个对象并将其value属性的值累加到总和中。
无论使用哪种方法，都应该根据实际情况选择最合适的方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f767ada0a6cfa33f8d8500e6bbab1c95/" rel="bookmark">
			Vue3通透教程【二】更高效的构建工具—Vite
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🌟 写在前面🌟 webpack🌟 Vite是什么？🌟 使用Vite创建项目🌟 写在最后 🌟 写在前面 专栏介绍：
凉哥作为 Vue 的忠实 粉丝输出过大量的 Vue 文章，应粉丝要求开始更新 Vue3 的相关技术文章，Vue 框架目前的地位大家应该都晓得，所谓三大框架使用人数最多，公司选型最多的框架，凉哥之前在文章中也提到过就是 Vue 框架之所以火起来的原因，和 Vue 框架相比其他框架的巨大优势，有兴趣的伙伴可以看一下 Vue框架背后的故事，随着 Vue 框架不断的被认可，现如今的 Vue 框架已经是前端工程师必备的技能了，记得尤大大开发 Vue 的初衷，为了让自己的开发工作更加便捷，也希望这个框架能让更多人的开发工作变得轻松；现如今 Vue 框架做到了，尤大大做到了，当然在 20 年的 9 月 18 日，Vue 又向前端同僚们报告了一次大的突破 Vue3.0 版本正式发布！如今已经过去了两年多的时间，更多的公司选择了Vue3技术，所以凉哥也在这个时候为大家出这份专栏，本专栏将帮助大家掌握Vue3+TS技术，提升自己竞争力！
温故知新：
上一篇文章中通过 Vue默认版本、众多UI框架向Vue3靠拢、以及Vue3显著的优势等内容向大家介绍了Vue的现状以及Vue3.0将成为大趋势，让大家了解Vue3.0的学习必要；至于Vite底层存在的优势以及Vue3是否更符合前端的发展生态大家可以看之前的一篇文章 👉 尤雨溪对 2022 Web前端生态趋势是这样看的，今天这篇文章将为大家介绍新一款的构建工具——Vite，当然我们Vite更多的是被用于开发阶段，下面也为大家介绍到了 Vite 想比于 webpack 编译中的优势，以及Vite构建Vue3项目的步骤教程，赶快跟着我尝试一下吧！
🌟 webpack 我们在前面使用Vue2进行开发的时候通常都是使用我们的vue-cli脚手架进行项目的搭建，cli脚手架中就是基于webpack进行构建打包，webpack 作为代码编译工具，有入口、出口、loader 和插件。webpack 是一个用于现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个依赖图(dependency graph)，此依赖图对应映射到项目所需的每个模块，并生成一个或多个 bundle。从图中我们可以看出，Webpack 可以将多种静态资源 js、css、less、sass 转换成一个静态文件，减少了页面的请求。
关于webpack的介绍和配置以及使用这里就不过多介绍了，如果有小伙伴有兴趣了解的话可以阅读一些我早些前发布的两篇文章 👉 安装webpack及使用 、webpack相关配置，今天呢我们为大家介绍一款新型的构建工具——Vite
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f767ada0a6cfa33f8d8500e6bbab1c95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b4d3b724bfebbccd8ecb301129f198a/" rel="bookmark">
			ChatGPT必将在文档处理领域大有所为，未来以来，拭目以待【文末送书】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		您好，我是码农飞哥（wei158556），感谢您阅读本文，欢迎一键三连哦。
💪🏻 1. Python基础专栏，基础知识一网打尽，9.9元买不了吃亏，买不了上当。 Python从入门到精通
😁 2. 毕业设计专栏，毕业季咱们不慌忙，几百款毕业设计等你选。
❤️ 3. Python爬虫专栏，系统性的学习爬虫的知识点。9.9元买不了吃亏，买不了上当 。python爬虫入门进阶
❤️ 4. Ceph实战，从原理到实战应有尽有。 Ceph实战
❤️ 5. Java高并发编程入门，打卡学习Java高并发。 Java高并发编程入门
文章目录 1. 前言2.现有图像处理流程2.1. 图像不清楚咋办？2.2. 问题图像轻松识别！ 3.ChatGPT在文档图像处理领域中展望3.1. ChatGPT的简介与原理3.2. ChatGPT在图像领域的展望 4. 总结5. 如何免费获得ChatGPT相关图书呢？5.1. 评论获得5.2. 关注【码农飞哥】抽奖获得 1. 前言 文档处理和图像处理是人们在日常生活中不可或缺的一部分。从商业合同到医学报告，人们需要文档来记录和传递信息。这些文档有时非常复杂，需要花费大量的时间和劳动力来处理。 然而，随着技术的进步，我们已经看到了许多革命性的工具和技术的出现，可以简化文档处理的过程。其中最有前景的是 ChatGPT 技术，它能够自动识别和处理文档中的信息，同时它也可以识别图像并且理解图像表达的信息。本文由现有图像识别领域和文档建模领域的一些突破出发，进而探讨 ChatGPT 技术在文档处理和图像处理中的应用和未来发展趋势。
2.现有图像处理流程 首先，我们需要了解何为图像处理呢？通俗易懂的说就是通过计算机来处理图像，从图像中提取有价值的信息。如下图所示：
人类可以通过听觉感知（耳朵）来识别语音信号；通过视觉感知（眼睛）来识别图像信号；通过运动感知（手）来识别轨迹信号。
同理，计算机也可以通过相应的技术来处理这些外部信号。计算机可以通过语音识别技术来识别语音信号；通过OCR（Optical Character Recognition，光学字符识别）技术来识别图像信号；通过手写识别来识别轨迹信号（手写信息）。
识别完成之后就可以对识别到的信号进行后续处理，从而提取图像或语音中的文本/结构/语义等信息。
2.1. 图像不清楚咋办？ 然而，理想很丰满，现实很骨感，在实际场景中图像识别会存在诸多的痛点和难点。如下罗列了几种常见的图像问题。
如何处理图像形变（弯曲，折叠，皱等）的问题呢？ 手持镜头拍照得到的文档图像往往存在着复杂的几何形变，包括拍摄视角、纸张本身的折叠、褶皱、弯曲以及厚度等因素，都会造成拍摄图像存在畸变。
如下图图片右边发生了折叠，并且拍摄角度倾斜，有无关的区域，对这图像不处理直接去进行OCR识别是比较困难的一件事。
如何去除图像中的摩尔纹呢？ 当我们对着电脑屏幕拍照时，所拍摄的图片会出现彩色的高频率条纹，也就是摩尔纹，如下图所示的图片。该图片不仅仅出现了摩尔纹，而且还存在倾斜的情况，这些情况给图像识别带来了很大的困难。
拍摄的图片模糊不清晰该如何处理呢？ 有时候受限于拍摄角度和拍摄光线的影响，用户所拍摄的照片内容非常不清晰，并且图片中还存在污渍，如下图所示：
2.2. 问题图像轻松识别！ 上述图像问题一度让我感到十分困惑，不过近期，我在CSIG企业行-走进合合信息的直播中通过郭老师的讲述了解到， 合合信息是如何通过一系列自研的关键技术来处理这些问题。下图展示了整个OCR识别的过程，即在接收到一张图片之后，扫描全能王所进行一系列操作。
ROI提取：首先，识别到一张图像之后，将图像分为若干个待提取信息的区域，然后按照区域提取信息。
形变矫正：针对图像的形变矫正，合合信息采用基于位移场网络学习方法的系统构架，可对形变文档进行智能矫正，包括弯曲矫正与透视矫正，同时智能定位文档边缘，切除多余背景。
图像恢复：合合信息采用多重神经网络技术，通过分析暗角、摩尔纹的形成原理，对图像中存在的干扰因素进行对应处理，可去除所有样式的摩尔纹，同时保证图像信息完整、颜色不失真。与此同时，通过合合信息阴影处理技术，可以智能消除图像中的阴影，提升材料规范性与后续的识别准确性。
质量增强：通过增强锐化提升图像质量、突出文字，使之达到清晰可读的效果。
下面我们可以看下上述三张图片增强之后的效果。
经过上述四个步骤的处理之后，就可以得到能够清晰方便识别的图像，接着就可以对文档进行智能扫描，识别分析，图片转成Word/Excel等操作。
文档和图像识别的问题解决了，那么将这些技术与ChatGPT结合会碰撞成怎样的火花呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b4d3b724bfebbccd8ecb301129f198a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6736bf459552f88207d9c5bdc3307f3a/" rel="bookmark">
			原神抢码，米游社抢码-首发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章仅供学习使用-侵权请联系删除_2023年3月14日08:17:06
本来在深渊12层打不过的我偶然在刷到了一个dy的直播间，看到主播在抢码上号帮忙打深渊还号称痛苦号打不满不送原石的旗号我就决定扫码试试，在直播间内使用了两部手机互相扫码在扫了一下午的码后发现根本抢不到二维码心态崩溃后我就想着写一个脚本来帮我抢码（本人py小白），终于在又白忙活了一下的后终于决定抱着学习的态度写一个程序来帮我进行抢码的操作！
原理讲解
进行屏幕区域的截图（用来获取二维码）
将获取到的二维码进行解析
将解析后的内容截取出ticket
最后发送给米哈游的服务器
在抢码登陆中一共分为两步
第一步抢码
第二步登陆
哈哈听起来像废话，我们首先会进行二维码扫码的认主，先确定这个二维码的主人是谁只要确认好这个主人后就算等待几分钟再确认登陆也没有问题。
# 抢码开始 def Request(ticket): conn = http.client.HTTPSConnection("api-sdk.mihoyo.com") payload = json.dumps({ "app_id": 4, "device": "", "ticket": ticket }) headers = {} conn.request("POST", "/hk4e_cn/combo/panda/qrcode/scan", payload, headers) res = conn.getresponse() data = res.read() data = json.loads(data.decode("utf-8")) retcode = data["retcode"] return retcode 我们先进行二维码的认主 ticket这个参数为二维码解析后的参数自行获取
# 确认登陆 def ConfirmRequest(ticket): conn = http.client.HTTPSConnection("api-takumi.miyoushe.com") payload = '' headers = { 'DS': '', 'cookie': '', 'x-rpc-client_type': '', 'x-rpc-app_version': '', 'x-rpc-sys_version': '', 'x-rpc-channel': '', 'x-rpc-device_id': '', 'x-rpc-device_fp': '', 'x-rpc-device_name': '', 'x-rpc-device_model': '', 'Referer': ' https://app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6736bf459552f88207d9c5bdc3307f3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91f0acfd8e00c6ab4d6c9297f7f57bb8/" rel="bookmark">
			若依(RuoYi-Vue)&#43;Flowable工作流前后端整合教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此教程适合若依前后端分离项目，其他项目可以在扩展列表中进行查找。
近期公司里需要对很久以前的RuoYi-Vue前后端分离项目扩展出flowable的功能，当然这个重任也是落在了我的身上（不然也不会有这篇文章），然后我在官网看到了RuoYi-Vue-Flowable这个项目，按照文档提供的迁移方式对于我们这个老版本的项目来说无法正常运行，所以我联系了作者并更新了一下文档，打算在网上在发布一篇（毕竟有的人懒得看官方文档）。
官方项目地址：https://gitee.com/tony2y/RuoYi-flowable
把项目拉到本地后下面开始整合教程，整合教程分为前端和后端两个模块。
前端迁移流程 1.flowale功能页面相关内容迁移 1.1 把目录ruoyi-ui/src/views/下的flowable文件夹移动到你自己前端项目中的/src/views/文件下。
​
1.2 移动页面配套的js文件，将ruoyi-ui/src/api/下的flowable文件夹移动到自己项目中的/src/api/文件下。
​
2.flowale流程设计器相关内容迁移 将ruoyi-ui/src/components目录下的customBpmn，flow，parser，Process，render，tinymce文件夹移动到自己项目中的/src/components文件下。
​
3.表单设计器与人员选择模块相关文件迁移 3.1 将ruoyi-ui/src/views/tool中的build文件夹移动到自己项目中的/src/views/tool文件下，存在则覆盖。
​
3.2 迁移表单设计器相关样式，将ruoyi-ui/src下的styles文件移动到自己项目中的/src文件夹下。
​
3.3 修改ruoyi-ui/src/utils/index.js中的deepClone函数。
​
修改为如下内容，存在该函数做修改，不存在做新增。
// 深拷贝对象 export function deepClone(obj) { const _toString = Object.prototype.toString // null, undefined, non-object, function if (!obj || typeof obj !== 'object') { return obj } // DOM Node if (obj.nodeType &amp;&amp; 'cloneNode' in obj) { return obj.cloneNode(true) } // Date if (_toString.call(obj) === '[object Date]') { return new Date(obj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91f0acfd8e00c6ab4d6c9297f7f57bb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1fa6b1494d7a944ea8a84b5c8b00f14/" rel="bookmark">
			ComfyUI部署流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ComfyUI部署流程 下载ComfyUI安装Pytorch环境准备启动其它 环境：Ubuntu 20.04.6 LTS / Python3.8 / AMD RX6500XT显卡 （ N卡安装方式也差不多，Windows应该也是这个安装方式 下载ComfyUI git clone https://github.com/comfyanonymous/ComfyUI.git 安装Pytorch N卡执行：pip3 install torch==1.13.1 torchvision torchaudio --extra-index-url https://download.pytorch.org/whl/cu117 xformers
A卡执行：pip3 install torch torchvision torchaudio --extra-index-url https://download.pytorch.org/whl/rocm5.4.2
环境准备 在 ComfyUI 文件夹中打开终端来安装依赖项：
pip3 install -r requirements.txt 如果之前已经安装过WebUI，可以直接使用WebUI的环境
pip3 install -r stable-diffusion-webui/requirements.txt 将模型文件拷贝到/ComfyUI/models/checkpoints目录下：
启动 回到ComfyUI目录，执行启动命令
N卡：python3 main.pyA卡执行：HSA_OVERRIDE_GFX_VERSION=10.3.0 python3 main.py
执行成功 http://127.0.0.1:8188/
其它 跑图如果遇到下面报错
ValueError: The device_map provided does not give any device for the following parameters…
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1fa6b1494d7a944ea8a84b5c8b00f14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a758942c762eba51f92671dede0d75ae/" rel="bookmark">
			SQL SERVER专题实验4 复杂查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1关：基本知识 任务描述 本关任务：根据复杂查询相关知识介绍，完成相关选择题。
知识要求 为了完成本关任务，你需要掌握：
基于多个表或视图的SELECT语法结构；包括自然连接、普通连接、自身连接在内的各种连接查询使用场景及语法要点；包括左外连接、右外连接和全外连接的外连接查询使用场景及语法要点；包括相关子查询和不相关子查询的嵌套查询使用场景及语法要点；包括并集、交集和差集的集合查询使用场景及语法要点。基于派生表的查询。 知识链接 关于SELECT语句在复杂查询中的使用场景、语法要点等相关内容和分类示例请参看：4-1 实验导引
测试说明 本关主要介绍的是概念性知识，因此测试以选择题的形式对本关介绍的知识进行测试。
开始你的任务吧，祝你成功！
1、关于自身连接，下面说法正确的有：(ABC)
A、自身连接的表必须取别名
B、自身连接的目标列表达式必须带上表的别名
C、自身连接往往用于查询同一个表中不同属性之间满足某种比较条件的结果
D、自身连接也可以使用相同属性值的比较条件的作为连接条件
2、关于自然连接，下面说法正确的有：(ABC)
A、自然连接可以理解为是主外码值相等且目标列表达式去掉外码保留主码的连接
B、两个表即便没有参照完整性也可以有自然连接
C、自然连接的两个表中必然要有两组相同的属性名及其数据类型和宽度
D、自然连接就是自身连接
3、关于嵌套查询，下面说法正确的有：(ABCD)
A嵌套查询就是查询的条件表达式中含有查询块的查询
B、不相关子查询的执行顺序从层查询开始逐级向上一层查询推进，查询的结果放在上一层查询的条件表达式的常量部分
C、相关子查询一定有WHERE子句，而且都会带有父查询的某个属性作为条件表达式中常量部分的内容
D、某些嵌套子查询也可以用连接查询来实现
4、关于集合查询，下面说法正确的有：(ABCD)
A、集合查询就是把表的查询操作当集合操作理解的查询
B、集合查询要求参与运算的子查询的目标列表达式必须个数相同且能按对应顺序进行比较
C、有些集合查询也可以用嵌套查询或连接查询替代
D、集合查询的查询表目标列表达式为第一个子查询的目标列表达式
5、关于基于派生表的查询，下面说法正确的有：(ABD)
A、派生表就是子查询放到WHERE语句中作为查询对象的查询表
B、派生表在SELECT语句中必须使用别名
C、派生表的目标列表达式必须也使用别名
D、派生表的目标列表达式只有在含有聚集函数、计算表达式等情况下才必须使用别名
第2关：连接查询（含普通连接、自然连接和外连接） SET NOCOUNT ON GO USE JX GO ----------------------BEGIN------------------- --*****1、查询选修了‘3’号课程且成绩在70分以上的学生信息***** select Student.* from Student,SC where Student.Sno=SC.Sno and Cno='3' and Grade&gt;70 --*****2、查询选修了‘3’课程的学生姓名，成绩及任课教师姓名***** select Sname,Grade,Tname from Student,SC,Teacher where Student.Sno=SC.Sno and Teacher.Tno=SC.Tno and Cno= '3' --*****3、列出所有参加了"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a758942c762eba51f92671dede0d75ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6735a3fba5a167434a4f0fb97cab54e/" rel="bookmark">
			机器学习——线性回归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习目标 了解线性回归的应用场景知道线性回归的定义 1 线性回归应用场景 房价预测
销售额度预测
贷款额度预测
举例：
2 什么是线性回归 2.1 定义与公式 线性回归(Linear regression)是利用回归方程(函数)对一个或多个自变量(特征值)和因变量(目标值)之间关系进行建模的一种分析方式。
特点：只有一个自变量的情况称为单变量回归，多于一个自变量情况的叫做多元回归 线性回归用矩阵表示举例 那么怎么理解呢？我们来看几个例子
期末成绩：0.7×考试成绩+0.3×平时成绩房子价格 = 0.02×中心区域的距离 + 0.04×城市一氧化氮浓度 + (-0.12×自住房平均房价) + 0.254×城镇犯罪率 上面两个例子，我们看到特征值与目标值之间建立了一个关系，这个关系可以理解为线性模型。
2.2 线性回归的特征与目标的关系分析 线性回归当中主要有两种模型，一种是线性关系，另一种是非线性关系。在这里我们只能画一个平面更好去理解，所以都用单个特征或两个特征举例子。
假设刚才的房子例子，真实的数据之间存在这样的关系：
真实关系：真实房子价格 = 0.02×中心区域的距离 + 0.04×城市一氧化氮浓度 + (-0.12×自住房平均房价) + 0.254×城镇犯罪率 那么现在呢，我们随意指定一个关系（猜测）
随机指定关系：预测房子价格 = 0.25×中心区域的距离 + 0.14×城市一氧化氮浓度 + 0.42×自住房平均房价 + 0.34×城镇犯罪率 请问这样的话，会发生什么？真实结果与我们预测的结果之间是不是存在一定的误差呢？类似这样样子
既然存在这个误差，那我们就将这个误差给衡量出来
1 损失函数 总损失定义为：
如何去减少这个损失，使我们预测的更加准确些？既然存在了这个损失，我们一直说机器学习有自动学习的功能，在线性回归这里更是能够体现。这里可以通过一些优化方法去优化（其实是数学当中的求导功能）回归的总损失！！！
2 优化算法 如何去求模型当中的W，使得损失最小？（目的是找到最小损失对应的W值）
​
2.1 正规方程 2.1.1 什么是正规方程
理解：X为特征值矩阵，y为目标值矩阵。直接求到最好的结果
缺点：当特征过多过复杂时，求解速度太慢并且得不到结果
2.1.2 正规方程求解举例
以下表示数据为例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6735a3fba5a167434a4f0fb97cab54e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a7feb0e71a4348490e83bd87b17ca19/" rel="bookmark">
			JDBC 技术 | Java连接MySQL数据库（四万字零基础保姆级超全详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一. JDBC概述1. JDBC 概念2. JDBC 本质3. JDBC 的好处 二. JDBC 快速入门1. 编写Java 程序步骤2. 在IDEA 中的操作流程3. 正式编写 Java程序 三. JDBC API详解1. DriverManager 类2. Connection 接口2.1 获取执行SQL语句的对象 3 .ResultSet 类3.1 概述3.2 代码实现使用ResultSet 对象 4. Statement 接口4.1 概述4.2 代码实现4.3 Statement 对象应用案例 5. PreparedStatement 接口5.1 什么是SQL注入5.2 代码模拟SQL注入问题5.3 PreparedStatement 概述5.4 使用 PreparedStatement 改进刚才存在SQL注入漏洞的代码5.5 PreparedStatement 对象的原理5.6 小结 6. JDBC API 小结 四. 封装 JDBCUtils 工具类1. JDBCUtils 的封装2. JDBCUtils 测试 五. JDBC 事务管理六. JDBC 批处理七. 数据库连接池1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a7feb0e71a4348490e83bd87b17ca19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b36e63d1a41de31c1bac26450f64a6db/" rel="bookmark">
			PyTorch 深度学习实战 | 基于生成式对抗网络生成动漫人物
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生成式对抗网络（Generative Adversarial Network, GAN）是近些年计算机视觉领域非常常见的一类方法，其强大的从已有数据集中生成新数据的能力令人惊叹，甚至连人眼都无法进行分辨。本文将会介绍基于最原始的DCGAN的动漫人物生成任务，通过定义生成器和判别器，并让这两个网络在参数优化过程中不断“打架”，最终得到较好的生成结果。
01、生成动漫人物任务概述 日本动漫中会出现很多的卡通人物，这些卡通人物都是漫画家花费大量的时间设计绘制出来的，那么，假设已经有了一个卡通人物的集合，那么深度学习技术可否帮助漫画家们根据已有的动漫人物形象，设计出新的动漫人物形象呢？
本文使用的数据集包含已经裁减完成的头像如图1所示，每张图像的大小为96*96*3像素，总数为51000张。
图 1 动漫人物数据集
这项任务与之前的有监督任务不同之处在于，监督任务是有明确的输入和输出来对模型进行优化调整，而这一项任务是基于已有的数据集生成新的与原有数据集相似的新的数据。这是一个典型生成式任务，即假设原始数据集中所有的动漫图像都服从于某一分布，数据集中的图片是从这个分布随机采样得到的，倘若可以获得这个分布是什么，那么就可以获得与数据集中图片分布相同但完全不同的新的动漫形象。因此，生成式任务最重要核心任务就在于如何去获得这个分布。现有的基于图像的生成式框架有VAE和GAN两大分支，GAN的大名想必很多人都有所耳闻，其实验效果也是要由于VAE分支，本文将介绍基于GAN的动漫人物生成任务。
02、反卷积网络 反卷积层是GAN网络的非常重要的一个部件。大多数卷积层会使特征图的尺寸不断变小，但反卷积层是为了使得特征图逐渐变大，甚至与最初的输入图片一致。反卷积层最开始用于分割任务，后来也被广泛应用于生成式任务中，如图2所示，为一个反卷积层的正向传播时的计算过程，下层蓝色色块的为输入，白色虚线色块为padding的部分，上层绿色的为反卷积层的输出，原本3×3大小的特征图经过反卷积可以得到5×5的输出。本文的网络结构中也使用了反卷积层作为重要的一环。
图2 反卷积示意图
在分类或者分割等计算机视觉的任务当中，最终损失函数都需要对网络的输出与标签的差异进行量化，比如常见的L1、L2、交叉熵等损失函数，那么在生成式任务当中，当网络输出一张新的图片，如何去评判这张图片与原始数据集的分布是否一致？这是非常困难的一项事情，而GAN用很巧妙的思路规避了直接去判断分布是否一致，通过引入另一个网络（判别器）实现了判断两张图片是否一致这一任务。
具体来说，假设原始的分布为Pdata（X） ，PG（X;θ） 指参数值为θ的卷积网络，其以随机数x作为初入，输出一张图像，该卷积网络称为生成器，根据最大似然定理，希望每个样例出现的概率的乘积最大，即最大化:
对 θ 进行求解，可得：
即GAN的生成器目标是找到PG（X;θ）的一组参数，使其接近Pdata（X）分布，从而最小化生成器G生成结果与原始数据之间的差异
为了解决这个问题，GAN引入了判别器的概念，使用判别器D(X)，来判断PG（X;θ）生成的结果与Pdata（X）分布是否一致，判别器的目标是给真样本奖励，假样本惩罚，判别器的目的在于尽可能的区分生成器生成的样本与数据集的样本，当输入为数据集的样本时，判别器输出为真，当输入为生成器生成的样本时，判别器输出为假，GAN的结构如图 3所示。
图3 GAN模型结构
判别器希望最大化的目标函数，就是
这一优化目标与交叉熵函数的形式非常相似，需要注意的是，在优化判别器时，生成器中的参数是不变的。生成器与判别器的目标不同，由于没有像监督学习那样的标签用于生成器，因此，生成器的目标为尽可能的骗过判别器，使判别器认为生成器生成的样本与原始数据集分布一致，即生成器的目标函数为
至此，GAN的损失函数可写为
03、DCGAN 本文中使用DCGAN作为网络模型，其核心思想与GAN一致，只是将原始GAN的多层感知器替换为了卷积神经网络，从而更符合图像的性质。下面介绍DCGAN的结构。
图4 DCGAN生成器网络结构
如图4可知，DCGAN的生成器从一个100维的随机变量开始，不断叠加使用反卷积层，最终得到的64*64*3的输出层。
其判别器为一个5层的卷积结构，以64*64*3大小作为输入，单独一个值作为输出，为输入判别器的图像与数据集图像同分布的概率。
训练步骤与损失函数与上文中GAN的一致，通过交替更新参数的方式，使生成器和判别器逐渐收敛。在下文中将具体介绍如何构建DCGAN并实现动漫人物生成。
04、基于DCGAN的动漫人物生成 新建GanModel.py文件，并在这个脚本中构建DCGAN的生成器和判别器模型，首先是生成器模型，由于本数据集的图片大小为96*96，因此对原始DCGAN的参数做了一些调整，使得最终经过生成器得到的图片大小也是96*96。
如代码清单1所示为经过调整后的生成器网络，同样包含有5层，出去最后一层，每层中都有一个卷积层、一个归一化层以及一个激活函数。
代码清单1 调整后的生成器网络
1.import torch.nn as nn 2.# 定义生成器网络G 3.class Generator(nn.Module): 4. def __init__(self, nz=100): 5. super(Generator, self).__init__() 6. # layer1输入的是一个100x1x1的随机噪声, 输出尺寸1024x4x4 7. self.layer1 = nn.Sequential( 8. nn.ConvTranspose2d(nz, 1024, kernel_size=4, stride=1, padding=0, bias=False), 9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b36e63d1a41de31c1bac26450f64a6db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2db93e38dc80ac0b0a89fbc7920c7216/" rel="bookmark">
			Github学生认证 &#43; Copilot，这一篇就够了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Github学生认证 + Copilot，这一篇就够了！ Github学生认证一遍过 + Copilot Free TrialStep1：修改个人信息Step2：准备材料Step3：提交材料Step4：Check结果Step5：Github Copilot Github学生认证一遍过 + Copilot Free Trial 14次学生认证失败经历总结出来的一遍过究极攻略
Step1：修改个人信息 Github右上角头像点击Your profile Name：改成你的英文名字，例如 Li MingtianBio：I am Li Mingtian, a student in xxx university. I want to study in Github and try to make some contributions to the community.Company：Xxx UniversityLocation：Xxx University Step2：准备材料 导出你的英文成绩单，需要有当前日期（我用的是校务行英文成绩单（包括绩点和平均分）电脑截图成绩单，保存为jpeg格式 Step3：提交材料 用手机（不要用电脑）打开Github学生认证网址（注意千万不要科学上网！！！）然后这样填： 邮箱：随便选一个学校：直接中文输入你的学校名字，然后选择弹出来的学校信息理由：I want to study in Github and try to make some contributions to the community.选continue，允许获取位置 手机选上传照片，上传step2的jpeg图片type选transcript，提交 Step4：Check结果 在你的邮箱check结果，一般晚上申请的话2-3分钟就能出结果 Step5：Github Copilot 打开copilot网址点击Start my free trial安装vscode github copilot插件，登录验证就可以用了~加入Copilot X waiting list 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7674a66f3a0c5e49119d4720b6dbfd98/" rel="bookmark">
			【ChatGPT】参加计算机科学考试（GPT-4对比GPT-3.5）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ChatGPT真的“无敌”了吗？？？？
当【ChatGPT】参加大学生计算机科学考试 1.简介2.介绍3.ChatGPT（GPT-4对比GPT-3.5)参加计算机考试实验4.实验设计4.1实验介绍4.2 对ChatGPT提出问题4.3测试结果 5. GTP-46. 讨论 1.简介 我们邀请ChatGPT参加一项关于算法和数据结构的本科计算机科学考试。我们把它的答案手抄到一张考卷上，然后在盲测的情况下，随机选200名参与的学生。我们发现ChatGPT以20.5(满分40分)的成绩勉强通过了考试。这一令人印象深刻的表现表明，ChatGPT确实可以成功完成大学考试等具有挑战性的任务。同时，我们考试中的问题在结构上与其他考试相似，解决的家庭作业题，以及可以在网上找到的教学材料，这些材料可能是ChatGPT训练数据的一部分。因此，从这个实验中得出ChatGPT对计算机科学有任何理解的结论是不充分的。我们也评估了GPT-4带来的改进。我们发现，GPT-4比GPT-3.5多获得17%的考试分数，达到了普通学生的表现。
2.介绍 许多人已经注意到ChatGPT1的功能OpenAI的一种新型聊天机器人模型令人印象深刻，该模型甚至可以成功完成大学考试等具有挑战性的现实任务。事实上，已有证据表明这可能是事实。此外，对模型响应的评估通常不是盲目的，这可能是有问题的，因为众所周知ChatGPT会产生需要解释的奇怪答案。因此，尽管有很多关于这个话题的讨论，到目前为止，关于ChatGPT在大学考试中的能力的系统证据很少。
3.ChatGPT（GPT-4对比GPT-3.5)参加计算机考试实验 我们提出了一个简单但严格的实验的结果，评估的能力。关于算法和数据结构的本科生计算机科学考试。我们在常规大学考试的同时进行了这个实验，这使我们能够在一个盲设置中与学生一起评估模型的反应。我们以简单的标准化格式提出了不同的考试问题，使ChatGPT能够对所有考试问题给出明确的答案。
表1：在我们的考试中，ChatGPT在10个不同的练习中获得的分数，与参加我们考试的200名学生获得的平均分数进行比较。
第一行描述了ChatGPT使用GPT-3.5基本模型获得的点。这是本文讨论的主要实验的结果，其中模型反应与学生反应一起盲目评分。ChatGPT-3.5获得了20.5分(满分40分)。第二行描述了ChatGPT使用GPT-4基本模型获得的点。在这里，模型响应根据主实验中使用的相同评分方案进行评分，但评分不是盲目的。我们估计ChatGPT-4将获得约24分，达到平均学生的表现。第三行表示参加考试的200名学生获得的平均分数。 实验的结果是，ChatGPT将以20.5分(满分40分)的成绩侥幸通过考试。这令人印象深刻，但也突出了当前模型版本的局限性。特别是，该模型的表现比参加考试的平均学生的表现更差(平均学生获得约24分，比较表1)。就考试相对标准化而言，ChatGPT的混合表现是有趣的。类似的考试在世界各地都有，并且涵盖了很多关于主题的信息。
我们也评估了GPT-4带来的改进。我们发现，使用GPT-4基础模型的ChatGPT在考试中比使用GPT-3.5基础模型的ChatGPT多获得17%的分数，达到了普通学生的成绩。
4.实验设计 4.1实验介绍 我们考虑一个关于算法和数据结构的入门课程的考试。考试内容包括排序算法、图遍历和动态规划。总的来说，考试涵盖的主题在世界各地都以类似的方式进行教学。考试包含不同类型的问题，包括多项选择题、写小题、写伪代码和画图。进行这个实验的想法并没有把考试中的练习偏向于ChatGPT的能力。
4.2 对ChatGPT提出问题 我们在与模型的19个不同的对话中提出了考试问题，依赖于考试的latex源文件。我们告诉模型，我们正在问计算机科学考试中关于算法的问题，并要求它提供简短、准确的答案，在整个过程中，我们并没有试图设计提示来引导模型走向更好或更差的答案，唯一的目标是，该模型将为所有问题提供明确的答案。
一些考试题目涉及数学、伪代码或图形。在本例中，我们简单地使用来自考试的latex源代码提示模型，如下例所示:
例如，当我们要求模型写一个小的证明时，它会用乳胶方程来回应。类似地，当我们要求模型完成伪代码时，它以有效的方式完成了给定的伪代码。
在与模型进行对话之后，我们将答案手写在一张试卷上，在这样做的过程中，我们当然将模型的所有乳胶输出“渲染”到纸张上。
4.3测试结果 在本节中，我们将讨论GPT-3.5的主要实验结果。所带来的改善GPT-4将在下一节讨论。主要结果是，ChatGPT获得20.5分(满分40分)，通过了考试。由于要通过考试至少需要20分，ChatGPT仅以非常微弱的优势通过。
在考试的其他部分，ChatGPT给出了错误的答案，有时甚至是奇怪的答案，（如下图）特别是，该模型在涉及结构化输出(不是伪代码)的所有练习中都遇到了困难。
5. GTP-4 在本节中，除了本文考虑的主要实验外，我们还评估了GPT-4带来的改进。GPT-4技术报告在许多不同的考试中比较了GPT-4和GPT-3.5，并报告了巨大的性能提升(OpenAI, 2023)。然而，由于报告中使用的数据集不可用，因此很难复制和评估这些结果。然而，有人指出，有证据可以对训练数据进行测试。
总的来说，ChatGPT-4获得了24分(满分40分)。这是3.5个百分点，即17%ChatGPT与GPT-3.5基础模型。有趣的是，这意味着ChatGPT-4在我们的考试中与普通学生的表现相当。虽然改进看起来很小，但实际上它确实意味着ChatGPT-4能够回答一些更有挑战性的多项选择题，这些问题是以前版本的模型难以回答的。
6. 讨论 我们的实验结果与现有的研究一致，这些研究记录了大型语言模型令人印象深刻的能力，以及它们严重的局限性。我们想强调的是，ChatGPT能够通过我们的考试这一事实并不意味着它对计算机科学有任何理解，就像我们可能期望它能够通过考试的人那样。当然可以合理地假设ChatGPT在培训过程中看到了许多与我们考试中相似的练习和解决方案。一般来说，为了了解像ChatGPT这样的模型的能力和局限性，需要进行更多的研究。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0eea0f17a929ba02a63c8fe892190559/" rel="bookmark">
			【数据结构与算法】堆的实现（附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.堆的概念及结构
二.接口实现
A.初始化 Heapinit 销毁 Heapdestroy
B.插入 Heappush 向上调整 AdjustUp
1.Heappush
2.AdjustUp
C.删除 Heappop 向下调整 AdjustDown
D.堆的判空 Heapempty 堆顶数据 Heaptop 堆的大小 Heapsize
三.源码
Heap.h
Heap.c
test.c
一.堆的概念及结构 1.概念
如果有一个关键码的集合K = { ， ， ，…， }，把它的所有元素按完全二叉树的顺序存储方式存储在一个一维数组中，并满足： &lt;= 且 &lt;= ( &gt;= 且 &gt;= ) i = 0，1，2…，则称为小堆(或大堆)。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。
2.堆的性质：
A.堆中某个节点的值总是不大于或不小于其父节点的值；
B.堆总是一棵完全二叉树。
其实堆是一种二叉树，通常我们都是用数据表实现，也就是说堆的底层是数组，数组中的小标表示二叉树的节点，所以在实现堆之前，我们有必要了解完全二叉树中节点之间的关系。
1.理解父节点 parent 和子节点 child；
2.了解父节点与子节点之间的关系：
A.parent=（child-1）/2；
B.左孩子child=2*parent+1；
C.右孩子child=2*parent+2。
二.接口实现 A.初始化 Heapinit 销毁 Heapdestroy 这里的初始化和销毁都很简单，相信这对学到堆的人并不是什么难事，和顺序表的操作是一样的，如果实在不理解的话，请看 -&gt; 顺序表
B.插入 Heappush 向上调整 AdjustUp 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0eea0f17a929ba02a63c8fe892190559/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c401c08f6efe76def0b336dad629bbf4/" rel="bookmark">
			RANSAC算法（仅供学习使用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.定义 RANSAC（Random Sample Consensus）算法是一种基于随机采样的迭代算法，用于估计一个数学模型参数。它最初由Fischler和Bolles于1981年提出，主要用于计算机视觉和计算机图形学中的模型拟合和参数估计问题。
RANSAC算法的基本思想是通过随机采样一小部分数据来估计模型参数，然后用这个模型对所有数据进行测试，将满足模型的数据点作为内点，不满足模型的数据点作为外点。通过迭代的方式不断随机采样和估计模型参数，最终得到内点数目最多的模型作为最终的估计结果。
RANSAC算法的优点是可以处理包含大量外点的数据集，并且不需要事先知道外点的数量。它可以用于解决许多计算机视觉和计算机图形学中的问题，如图像配准、物体识别、三维重建、特征点匹配等。
应用：
1.在点云中我们要平面
2.求解基础矩阵和本质矩阵
2.基本步骤 需要注意的是，RANSAC算法的可靠性取决于内点比例和迭代次数，内点比例越高，越容易得到正确的估计结果。但是，随着内点比例的增加，需要的迭代次数也会增加。因此，算法的可靠性和效率需要平衡考虑。
总之，RANSAC算法的基本步骤是随机采样、模型估计、内点外点分类、重复迭代以及最终模型选择。通过迭代的方式逐步提高模型的可靠性，最终得到准确的模型参数。
3.外点率和自适应RANSAC 也就是说，每一次迭代，建立一个模型，得到外点率，计算相应的N1,记录count；再次迭代建立模型，得到新的外点率和N，应比上一次要小，这样一来N更新，同时更新count
4.如何计算迭代次数 5.RANSAC算法在C++中的实现： 1）PCL（点云库） PCL是一个功能强大的点云处理库，其中包含了许多用于3D点云处理的算法，包括RANSAC。它提供了一组现成的数据结构和算法，可用于点云滤波、分割、重建等应用中。
2）OpenCV OpenCV是一个开源的计算机视觉库，也可以用于3D点云处理。它提供了许多用于3D点云处理的函数和类，包括RANSAC和其它一些用于计算几何的工具。
3）CGAL CGAL是一个计算几何算法库，也包含了一些用于3D点云处理的算法和数据结构。其中包括用于拟合平面和直线的RANSAC算法。
这些库都可以在C++中用于实现RANSAC-3D算法。选择哪一个库取决于你的具体需求和应用场景。如果你主要需要处理点云数据，那么PCL可能是一个不错的选择。如果你需要进行更一般的计算几何任务，那么CGAL可能更适合你。如果你已经熟悉OpenCV，那么它也可以作为一个选择。
6.Python中相关示例代码 pyransac-3d库官网：pyRANSAC-3D
​ import numpy as np from sklearn.neighbors import NearestNeighbors from sklearn.decomposition import PCA def ransac_3d(data, n, k, t, d): """ RANSAC-3D algorithm for plane fitting :param data: 3D point cloud data :param n: the minimum number of points to fit a plane :param k: the maximum number of iterations :param t: the inlier distance threshold :param d: the number of inliers required to accept the result :return: the best fit plane model and the corresponding inliers "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c401c08f6efe76def0b336dad629bbf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16da625308562d54f8704ad84dcb937c/" rel="bookmark">
			学二叉树之前，先来认识下树吧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到 Claffic 的博客 💞💞💞 前言：
往期给大家讲了链表，栈，队列等数据结构， 它们都是线性结构，而今天要讲的是一种非线性结构：树，让我们开始吧！ 目录
🌳1.什么是树？
🪲2.有关树的概念
🎄3.树的表示 ⛏️4.树的实际应用
1.什么是树？ 树，木本植物之总名... ...欸，走错频道了？
其实数据结构中的树就是由大自然中的树定义来的，因为它们有很多相似之处：
自然中的树(倒置) 数据结构的树
怎么样？是不是还蛮像的🤩
自然地，最顶端的那个结点就叫做 根节点 (图中A结点)
此时引出树的概念：
树是一种非线性的数据结构，它是由 n (n&gt;=0)个有限结点组成的一个具有层次关系的集合。
我们仔细来看看这颗树： 从顶端开始，可以发现 根结点 以上是没有结点的，这里暂称为没有前驱结点
注意看，这棵树由根节点分出了三个方向，这三个箭头下又分别有一颗小树，我们称它们为子树。
把子树2拿出来再进行分割：
子树2下又有子树2.1...
子树下有子树，子树下又有子树... ...
怎么有点像，
递归？
是的，可以理解为 树是递归定义的 。
接下来跟我看看下面的结构是不是树： 记住：这不是树，三条红边不能存在任意一条！！！
这部分的总结： • 树顶端的结点称为根节点，根节点没有前驱结点；
• 子树之间不能相交🍌；
• 除了根节点之外，每个结点有且仅有一个前驱节点；
• 一棵N个结点的树有N-1条边；
• 树是递归定义的。
2.有关树的概念 为了更好介绍树的有关概念，这里画一个更复杂的树：
• 结点的度：一个结点含有的子树个数（结点下的分支） 如结点A的度为5；
• 树的度：一棵树中最大的结点的度 如上树的度为5；
• 结点的层次：根是第1层，根的子节点所在层是第2层，如此递增；
• 树的高(深)度：最大的结点的层次 如上树的高(深)度是4；
• 叶子结点：度为0的结点（没有子树） 如结点 N，O；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16da625308562d54f8704ad84dcb937c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a69844c50c196d9ece6adf564490e80/" rel="bookmark">
			【数据结构】单链表 &amp;&amp; 双链表(链式和数组实现)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥🔥 欢迎来到小林的博客！！
🛰️博客主页：✈️小林爱敲代码
🛰️博客专栏：✈️ 数据结构与算法
🛰️社区 :✈️ 进步学堂
🛰️欢迎关注：👍点赞🙌收藏✍️留言
目录 前言单链表头插尾插头删尾删指定位置后插入指定位置后删除 双链表指定位置前插入指定位置删除 数组模拟单链表数组模拟双链表总结： 前言 今天给大家带来四个内容，一个是单链表非带头的实现，一个是双链表带头循环的实现。剩下的就是数组模拟单链表和双链表。
单链表 链表，在内存中并不是连续存储的。而链表通常会有next指针指向它的下一个节点。链表的最后一个节点一定指向空。
头插 头插我们需要让新节点指向头节点，然后更换头节点为新节点即可。
尾插 我们只需要找到最后一个节点，让它的next指向新节点，再把新节点指向NULL即可。
头删 先保存头节点的下一个节点，然后删除头节点。并把保存下来的下一个节点设置为新的头节点。
尾删 尾删需要记录一下最后一个节点的前一个节点。然后删除最后一个节点，把前一个节点指向NULL。否则会出现指向野指针的情况。
指定位置后插入 我们这里只讲解在指定位置的后一个元素插入，因为单链表在指定节点的前一个插入，需要前一个节点。但是单链表只指后不指前。所以想拿到前一个节点必须再遍历一次，所以不建议单链表用前插。在指定位置后插，我们只需要保存一下这个位置的下一个节点，然后让新节点指向这个位置的下一个节点。这个位置指向新节点。
假设我们在pos位置后面插入：
指定位置后删除 我们还是删除指定位置后的元素，因为如果删除指定元素，我们也需要它的前一个节点。单链表无法直接获取前一个节点。指定位置后删除，我们只需要保存下一个节点的下一个节点，然后删除下一个节点，然后让这个位置指向保存下来的的节点。
单链表的代码实现：
#include&lt;stdlib.h&gt; #include&lt;assert.h&gt; #include&lt;stdio.h&gt; typedef int SLTDateType; typedef struct SListNode { SLTDateType data; struct SListNode* next; }SListNode; // 动态申请一个节点 SListNode* BuySListNode(SLTDateType x) { SListNode* newNode = (SListNode*)malloc(sizeof(SListNode)); //开辟空间 newNode-&gt;data = x; //空间值为x return newNode; } // 单链表打印 void SListPrint(SListNode* plist) { SListNode* cur = plist; while (cur) //遍历一遍链表 { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a69844c50c196d9ece6adf564490e80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d972c9f31556d872f90839eda1ef6676/" rel="bookmark">
			【文本生成评价指标】 ROUGE原理及代码示例py
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【文本生成评价指标】 BLEU原理及代码示例py
【文本生成评价指标】 METEOR原理及代码示例py
【文本生成评价指标】 DISTINCT原理及代码示例py
【文本生成评价指标】文本生成客观评价指标总结py
1. ROUGE原理 在自然语言处理中，ROUGE是一种广泛使用的自动文本评估指标，用于比较生成文本和参考文本之间的相似度。ROUGE可以看做是BLEU 的改进版，专注于召回率而非精度。换句话说，它会查看有多少个参考译句中的 n 元词组出现在了输出之中。
ROUGE大致分为四种（常用的是前两种）：
ROUGE-N （将BLEU的精确率优化为召回率）ROUGE-L （将BLEU的n-gram优化为公共子序列）ROUGE-W （将ROUGE-L的连续匹配给予更高的奖励）ROUGE-S （允许n-gram出现跳词(skip)） 四者具体的公式及不同，见链接：ROUGE原理
ROUGE 用作机器翻译评价指标的初衷是这样的：在 SMT（统计机器翻译）时代，机器翻译效果稀烂，需要同时评价翻译的准确度和流畅度；等到 NMT （神经网络机器翻译）出来以后，神经网络脑补能力极强，翻译出的结果都是通顺的，但是有时候容易瞎翻译。
ROUGE的出现很大程度上是为了解决NMT的漏翻问题（低召回率）。所以 ROUGE 只适合评价 NMT，而不适用于 SMT，因为它不管候选译文流不流畅。
2. 代码实现 下面是一个基于 Python 的示例代码，用于计算生成文本和参考文本之间的 ROUGE 指标。这段代码使用 Python 的 rouge 库来计算生成文本和参考文本之间的 ROUGE 指标。
from rouge import Rouge # 生成文本 generated_text = "This is some generated text." # 参考文本列表 reference_texts = ["This is a reference text.", "This is another reference text.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d972c9f31556d872f90839eda1ef6676/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bea8fe7b17c553fe10a41e00afb81363/" rel="bookmark">
			【机器学习】DBSCAN聚类算法（含Python实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、算法介绍二、例子三、Python实现3.1 例13.2 算法参数详解3.3 鸢尾花数据集 一、算法介绍 DBSCAN（Density-Based Spatial Clustering of Applications with Noise）是一种基于密度的聚类算法，可以将数据点分成不同的簇，并且能够识别噪声点（不属于任何簇的点）。
DBSCAN聚类算法的基本思想是：
在给定的数据集中，根据每个数据点周围其他数据点的密度情况，将数据点分为核心点、边界点和噪声点。
核心点是周围某个半径内有足够多其他数据点的数据点；边界点是不满足核心点要求，但在某个核心点的半径内的数据点；噪声点则是不满足任何条件的点。 接着，从核心点开始，通过密度相连的数据点不断扩张，形成一个簇。
DBSCAN算法的优点是能够处理任意形状的簇，不需要先预先指定簇的个数，能够自动识别噪声点并将其排除在聚类之外。
然而，该算法的缺点是对于密度差异较大的数据集，可能无法有效聚类。此外，算法的参数需要根据数据集的特性来合理选择，如半径参数和密度参数。
二、例子 假设我们有以下的数据点集合：
[(1,1), (1,2), (2,1), (8,8), (8,9), (9,8), (15,15)] 我们可以使用DBSCAN算法来将这些点分成不同的簇。
首先，我们需要设置两个参数：
半径 ϵ \epsilon ϵ最小样本数 m i n P t s minPts minPts 我们这里设置 ϵ = 2 \epsilon=2 ϵ=2， m i n P t s = 3 minPts=3 minPts=3。
接下来，我们从数据集中选取一个点，比如第一个点 ( 1 , 1 ) (1,1) (1,1)作为种子点，并将该点标记为“核心点”，因为它周围有超过 m i n P t s minPts minPts个点在半径 ϵ \epsilon ϵ的范围内。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bea8fe7b17c553fe10a41e00afb81363/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/610/">«</a>
	<span class="pagination__item pagination__item--current">611/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/612/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>