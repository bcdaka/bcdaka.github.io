<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1366fa3a9dacc91eb772385edf9d9fc7/" rel="bookmark">
			如何实现class文件的反编译：java-decompiler 反编译工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java-decompiler 反编译工具 😀 Java Decompiler 是Java反编译工具，可以对 Java 5 和更高版本的 class 文件进行反编译分析。 📝 主旨内容 Java Decompiler是一项开源工具，Java Decompiler工具不仅可以实现反编译.class文件，将.class文件变为可以被我们阅读的.java文件，而且还可以对jar包进行反编译，得到jar包中.class文件反编译的.java文件。
该工具有图形化界面工具：JD-GUI，同时也有IDE开发工具的插件，如：eclipse和IntelliJ IDEA，这些插件可以将Java Decompiler集成到IDE开发工具上。
我们可以直接搜索Java Decompiler，就可以找到Java Decompiler的官网首页。打开官方文章，我们会发现这个工具已经已经很久没有更新了，到现在，2024年安装一个旧版本工具，不出意外会遇到很多兼容性问题，所以在本篇文章中，主要说明下在2024年使用这个工具可能存在的一些问题。
有需要安装Java Decompiler工具的同学，可以参考下博主小鱼（鳄鱼儿）的安装过程，博主电脑环境如下：
MacBook Pro, M1 PromacOS Sonoma 14.1.1jd-gui-osx-1.6.6.tar 官方下载：http://java-decompiler.github.io/
在打开上面这个官方网站后，我们点击下载，选择JD-GUI下面的Download选择相应的Releases版本下载即可。
如果是windows系统，直接下载jar文件。jar文件是java的可执行文件，右键点击或双击下载后的jd-gui-1.4.0.jar文件即可运行该反编译工具，运行时可以看到咖啡的图标，传统Java=咖啡。
安装遇到的疑问 安装后不能打开，提示“This program requires Java 1.8+”
解决方法1: 修改 universalJavaApplicationStub.sh, 将 -v 更改为 -V，但是博主尝试这种方法并没有效果。
如果你只安装了一个Java版本，这种方法是生效的，我们通过 /usr/libexec/java_home -F -V 指令就可以窥见原因。
如博主电脑就安装了两个Java环境，通过指令检索到两个 Java 环境，
usr/libexec/java_home -F -V Matching Java Virtual Machines (2): 17.0.3 (arm64) "Azul Systems, Inc." - "Zulu 17.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1366fa3a9dacc91eb772385edf9d9fc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a29337d95ff140bd04b887921c21ecd5/" rel="bookmark">
			【数仓】Kafka消息可视化工具：Offset Explorer（原名kafka Tool）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Offset Explorer（以前称为Kafka Tool）是一个用于管理和使用Apache Kafka®集群的GUI应用程序。 它提供了一个直观的界面，允许用户快速查看Kafka集群中的对象以及集群主题中存储的消息。 它包含面向开发人员和管理员的功能。 一些主要功能包括：
快速查看所有Kafka集群，包括其代理，主题和消费者查看分区中的消息内容并添加新消息查看消费者的偏移量，包括Apache Storm Kafka spout消费者以漂亮的打印格式显示JSON，XML和Avro消息添加和删除主题以及其他管理功能将分区中的单个消息保存到本地硬盘驱动器编写自己的插件，以查看自定义数据格式Offset Explorer可在Windows，Linux和Mac OS上运行 Offset Explorer仅供个人使用。 未经购买许可，不得进行任何非个人使用，包括商业，教育和非营利工作。 非个人使用可在下载Offset Explorer后的30天内进行评估，之后您必须购买有效许可证或删除该软件。
一、下载安装 登录官网下载
二、配置使用 建议先配置key、value默认的contentType（改成String)，默认值是Byte Array，方便直观查看数据
功能位置：Tools -&gt; Settings -&gt; Topics
三、软件使用 1、链接kafka 点击 File -&gt; Add New Connection…
输入参数：
cluster name : 随便输入，比如 mykafkaBootstrap servers：kafka集群地址，比如 kafka01:9092,kafka02:9092 然后点击 Add 保存链接，双击链接即可链接到kafka服务。
2、查看数据 点击想要查看的topic，选择Data选项卡，然后点击运行按钮，查询已有数据
选择 Value，点击左上角的展开数据按钮，可以看见完整的数据，如果是json格式数据，还要可以选择数据格式，以便查看
3、创建主题 选择 菜单 Topics ，然后点击 + 号按钮，可以创建新的Topic数据
4、发送消息 展开具体的topic，选择到最底层的 partition，然后选择Data选项看，点击 + 号按钮，可以发送新的消息，可以发送单个或多个消息，这里以多个消息为例
参考 https://www.kafkatool.com/download.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9fb62c1c1438f5667e09f837af8085c/" rel="bookmark">
			C# List使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 C# 中，List 和数组都是用于存储一组元素的数据结构，但它们之间有一些关键的区别和各自的优缺点。
数组（Array）的特点： 静态大小： 数组在创建时需要指定大小，且大小不能更改。例如，int[] numbers = new int[3]; 创建了一个包含3个整数的数组。
类型固定： 数组中的元素类型是固定的，无法在运行时更改。
直接访问元素： 数组提供了通过索引直接访问元素的方式，例如，int value = numbers[1];。
性能： 由于数组大小固定，可以在内存中分配连续的空间，因此在某些情况下可能具有更好的性能。
List 的特点： 动态大小： List 是动态数组，可以根据需要动态调整大小，通过 Add、Remove 等方法进行操作。
泛型支持： List 是泛型集合，可以存储任意类型的元素，例如，List&lt;int&gt; numbers = new List&lt;int&gt;();。
灵活性： 提供了丰富的方法和属性，如 Add、Remove、Count 等，使操作更加灵活。
类型灵活： List 可以存储不同类型的元素，而数组中的元素类型是固定的。
比较： 灵活性： List 更灵活，可以根据需要动态调整大小，而数组的大小是固定的。
类型灵活性： List 可以存储不同类型的元素，而数组要求所有元素是相同类型的。
性能： 数组在某些情况下可能具有更好的性能，因为它们在内存中分配连续的空间，而 List 的元素可能分散在堆上的不同位置。
直接访问 vs 方法调用： 数组通过索引直接访问元素，而 List 则需要通过方法调用来进行操作。
总体而言，如果需要静态大小和直接访问元素，并且元素类型相同且固定，数组可能更合适。如果需要动态大小、灵活性和可以存储不同类型的元素，List 则是更好的选择。在实际应用中，选择取决于具体的需求和性能要求。
List使用以及嵌套使用
using System; using System.Collections.Generic; class Program { static void Main() { // 创建一个整数类型的 List List&lt;int&gt; numbers = new List&lt;int&gt;(); // 添加元素 numbers.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9fb62c1c1438f5667e09f837af8085c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/445c8eb59dd447f46d0953ebd0f4bf6e/" rel="bookmark">
			前端React篇之哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？setState()案例需求总结 forceUpdate()案例需求总结 props改变案例需求总结 context改变案例需求总结 哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？ 在React中，以下方法会触发重新渲染：
setState()：当调用组件的setState方法并传入新的状态值时，React会触发重新渲染。forceUpdate()：可以强制组件重新渲染，不管组件的状态是否发生变化。props改变：当组件接收到新的props时，它会进行重新渲染。context改变：如果使用了context API，在context值发生变化时，会触发依赖于该context的组件重新渲染。 当React组件重新渲染时，render方法会执行以下操作：
比较虚拟DOM：React会比较前后两次渲染生成的虚拟DOM树，找出差异。计算需要更新的部分：React会确定哪些部分需要进行实际的DOM更新。应用更新：React将只更新需要更改的部分，而不是整个DOM树。这种优化称为“协调”（Reconciliation）。调用生命周期方法：如果有需要，React会调用相应的生命周期方法，如componentDidUpdate，以便进行一些额外的操作。 总的来说，重新渲染过程包括对比虚拟DOM、计算更新部分以及应用更新，以确保只有必要的部分会被实际更新，从而提高性能和效率。
setState() setState是React组件中用于更新状态的方法。当调用setState并传入新的状态值时，React会自动比较新旧状态的差异，并执行相应的更新操作。
在实际工作项目中，setState通常用于处理以下需求：
用户交互：当用户与页面进行交互时，组件的状态可能需要更新，如表单输入、按钮点击等。
数据获取和异步操作：当组件依赖的数据发生变化或进行异步操作后返回新的数据时，可以通过setState更新组件的状态，从而触发重新渲染。
条件渲染：通过更新组件的状态，可以实现条件渲染，根据不同的状态值显示不同的内容。
案例需求 假设我们有一个计数器组件，点击按钮后计数器的值会递增。需要实现以下功能：
初始计数器的值为0。点击按钮后，计数器的值加1。将计数器的值显示在页面上。 import React, { useState } from 'react' function App() { const [count, setCount] = useState(0) const increment = () =&gt; { setCount(count + 1) } return ( &lt;div&gt; &lt;h1&gt;Counter: {count}&lt;/h1&gt; &lt;button onClick={increment}&gt;增加&lt;/button&gt; &lt;/div&gt; ) } export default App 首先，使用React的useState钩子函数声明一个名为count的状态变量，并将其初始值设置为0。创建一个名为increment的函数，当按钮被点击时，这个函数会在当前计数的基础上加1，并通过调用setCount来更新计数器的值。在组件的返回值中，将计数器的值以文本形式显示在页面上，并将increment函数作为按钮的点击事件处理函数。 在调用setState方法时，传入的新状态不会立即生效，而是在下一次React的重新渲染过程中才会生效。React会使用新的状态值重新渲染组件，并只更新需要更新的部分，以提升性能。setState方法可以接受一个对象或一个函数作为参数。当传入一个函数时，React会将当前状态作为参数传递给这个函数，函数返回的结果将作为新的状态值。在使用函数更新状态时，应该使用回调函数的形式确保获取到最新的状态值。例如：setCount(prevCount =&gt; prevCount + 1)。 总结 在React中，setState方法用于更新组件的状态，并触发重新渲染。通过setState方法，我们可以根据不同的需求更新组件的状态，使得页面能够及时显示最新的数据和交互效果。在使用setState时，需要注意更新状态的方式和时机，以及遵循React的一些规范和最佳实践，以保证代码的可读性、性能和可靠性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/445c8eb59dd447f46d0953ebd0f4bf6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62e44fd8460ffd568046f6b9d4f361fa/" rel="bookmark">
			用真实数据告诉你前10大AI对话工具排行！（国内&#43;国外篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是木易，一个持续关注AI领域的互联网技术产品经理，国内Top2本科，美国Top10 CS研究生，MBA。我坚信AI是普通人变强的“外挂”，所以创建了“AI信息Gap”这个公众号，专注于分享AI全维度知识，包括但不限于AI科普，AI工具测评，AI效率提升，AI行业洞察。关注我，AI之路不迷路，2024我们一起变强。
在以前的文章里，我介绍过很多AI对话工具，国内的有百度文心一言，讯飞星火大模型，阿里通义千问，天工，智谱清言，以及Kimi Chat；国外的有ChatGPT，谷歌Gemini，Claude，微软Copilot，以及像字节Coze这种专注于AI Agent智能体创建的AI工具。同时，我也写了很多关于这些AI工具的对比和测评，帮助大家选择最合适的AI工具，来提高学习、工作和生活的效率。
今天，就和大家聊一聊，从用户数据来看，这些AI工具是一个什么样的排名，毕竟群众的眼睛是雪亮的，用户数据是能够在一定程度上反映AI工具的好与坏的。本次排名依据是2024年1月AI工具的访问量，排名数据来源：AI产品榜 aicpb.com。感谢榜主的数据支持。
国内篇 结论 序号AI产品名称1月访问量🥇百度文心一言15.1M🥈阿里通义千问6.5M🥉讯飞星火大模型2.73M4️⃣抖音豆包1.73M5️⃣Kimi Chat1.42M6️⃣清华智谱清言1.31M7️⃣天工1.23M 单位M为百万。
分析点评 首先，这样的排名结果并不出乎意料，第一名百度，有着庞大的用户基础以及AI的先发优势；第二名通义千问，是我在之前的测试文章里提到的，目前测试下来体验最好的国内LLM，甚至要好于百度文心一言，并且阿里擅长整一些花活，比如一键生成跳舞视频的智能体，一键全家福等等。另外，值得一提的是Kimi Chat，也是目前国内AI领域的网红产品，尽管推理能力和排名靠前的几个相比稍弱，但它主打的就是20万汉字上下文，进行一些长文本的对话体验很不错，也算是差异化竞争的一种吧。阿里通义千问和Kimi Chat也荣登增速榜的第一名和第二名。
术业有专攻，我个人很欣赏Kimi Chat这样的差异化打法，真实体验下来也确实有不少可取之处，之前也写过一些介绍和测评文章：
AI领域的国产之光，ChatGPT的免费平替：Kimi Chat！
Kimi Chat，不仅仅是聊天！深度剖析Kimi Chat 5大使用场景！
国外篇 结论 序号AI产品名称1月访问量🥇ChatGPT1.65B🥈微软Copilot1.44B🥉谷歌Gemini340.04M4️⃣Poe52.59M5️⃣Claude20.19M6️⃣Coze1.95M 单位B为十亿，M为百万。
分析点评 首先，ChatGPT以1.65B（16.5亿）的全球访问量遥遥领先，再次证明了GPT系列模型的一哥地位。紧随其后的是微软Copilot，以1.44B（14.4B）的访问量位居第二，毕竟提供免费的GPT-4，虽然使用体验上不如ChatGPT，但毕竟免费，还是很香的。谷歌Gemini，我个人认为和百度有点像，有钱，有搜索引擎以及其他产品，比如浏览器、Youtube、谷歌地图、谷歌文档等，积累起来的用户基础，希望发力AI但一直没有比较大的突破。Gemini Ultra的体验说实话也没有很惊艳，感兴趣的朋友可以翻看我之前的测评文章。
Claude，在Claude 2时代就号称是GPT-4之下第二强推理能力的模型，最近发布了Claude 3，更是收获了一大波关注，其中的Claude 3-opus模型，在推理能力上确实有很大的提高，官方号称全面超越了GPT-4，但真实性还有待证实。我之前写过关于Claude 3的文章：
Claude 3模型重磅发布！号称已全面超越GPT4！附详细解读和体验地址
Claude 3有点东西！这个看似简单的问题只有GPT-4和Claude 3回答正确！通义千问和讯飞星火表现同样亮眼！
字节Coze本不在这次的AI对话工具榜单里，但看到它这个体量，我还是把它加了进来。Coze的原意是打造可定制化的AI Agent，即智能体，凭借免费提供最新的GPT-4模型圈了一波粉。
AI对话工具综合排名 综合结论 序号AI产品名称1月访问量 (B/M)🥇ChatGPT1.65B🥈微软Copilot1.44B🥉谷歌Gemini340.04M4️⃣Poe52.59M5️⃣Claude20.19M6️⃣百度文心一言15.1M7️⃣阿里通义千问6.5M8️⃣讯飞星火大模型2.73M9️⃣Coze1.95M🔟抖音豆包1.73M1️⃣1️⃣Kimi Chat1.42M1️⃣2️⃣清华智谱清言1.31M1️⃣3️⃣天工1.23M 分析点评 全球AI巨头的主导地位： ChatGPT和微软Copilot位列前两位，显示了英文AI对话工具在全球范围内的巨大影响力和用户基础。这两款产品背后的公司——OpenAI和微软，凭借强大的技术实力和广泛的市场推广，成功占据了市场的领导地位。
技术实力和品牌影响力的结合：谷歌Gemini位列第三，其后是Poe和Claude，尽管访问量有所差距，但高质量的技术和创新能力依然能够吸引大量用户。特别是在特定领域或功能上具有独特优势的产品，如Poe和Claude，尽管在整体访问量上不及领头羊，但在其细分市场内仍表现出色。
中文AI工具的市场表现： 百度文心一言是排名最高的中文AI对话工具，其后紧跟着是阿里通义千问和讯飞星火大模型，显示出中文AI对话工具在国内市场上的影响力和用户基础。同时也说明，本土化的AI解决方案在满足特定语言和文化需求方面具有不可忽视的优势。但不得不承认，国内AI工具在用户体量上和前面的AI工具相比还是有着不小的差距。
市场多样性与竞争： 从Coze到Kimi Chat，尽管这些产品的访问量相对较低，但它们的存在和表现展现了AI对话工具市场的多样性和活力。小型或新兴企业通过独特的产品定位和技术创新，在竞争激烈的市场中寻找到自己的生存和发展空间。
精选推荐 完全免费白嫖GPT4的三个方法，都给你整理好了！
AI领域的国产之光，ChatGPT的免费平替：Kimi Chat！
Kimi Chat，不仅仅是聊天！深度剖析Kimi Chat 5大使用场景！
我用AI工具5分钟制作一个动画微电影！这个AI现在免费！
当全网都在疯转OpenAI的Sora时，我们普通人能做哪些准备？——关于Sora，你需要了解这些！
文心一言4.0 VS ChatGPT4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62e44fd8460ffd568046f6b9d4f361fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5f975527d7c6e826e524e180f7446f9/" rel="bookmark">
			图像分割实战-系列教程2：Unet系列算法（Unet、Unet&#43;&#43;、Unet&#43;&#43;&#43;、网络架构、损失计算方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像分割实战-系列教程 总目录
语义分割与实例分割概述
Unet系列算法
1、Unet网络 1.1 概述 整体结构：概述就是编码解码过程简单但是很实用，应用广起初是做医学方向，现在也是 虽然用的不是很多，在16年特别火，在医学领域、小目标领域做分割，其实到现在为止也还在用，因为在深度学习中网络越简单越好，这篇内容也会介绍Unet++版和Unet最新版
相比于yolo、maskrcnn、fastrcnn这些，Unet远比这些网络简单。网络越大的时候，感受野也越大，实际上就会更加适合一些大目标。
1.2 结构 如图的网络架构中，左边从上到下，仍然是一层一层卷积的过程，三层卷积一个block，这个过程也就是图像长宽减小、通道变多的过程。一直到最底下的一层，tensor维度从（572,572,1）变成了（28,28，1024），当然这个过程从代码中打印出来会比较清晰。
第一个Block的输出会给到最后一个Block的输入和第二个Block的输入而第二个Block的输出会给到第三个Block的输入和倒数第二个Block的输入而同时最后一个Block会接受倒数第二个Block的输入和第一个Block的输入这种从上到下，从左到右的结构与以前的网络有所不同其中第一个Block和最后一个Block是一个对应的输入输出，对应的数据维度也是一样的，在当前这个网络中没有保持一样在后续新版本会保持一致 这整个过程相当于编码和解码的过程，整个网络呈现一个U字形，Unet在医学领域一直有不错的发挥
2、Unet各版本比较 2.1 Unet 主要网络结构：还引入了特征拼接操作以前我们都是加法，现在全都要这么简单的结构就能把分割任务做好 2.2 U-net++概述 整体网络结构：特征融合，拼接更全面其实跟densenet思想一致把能拼能凑的特征全用上就是升级版了
相比于Unet，++版本多做了一些融合的事情 2.3 U-net++损失计算方式 Deep Supervision ：也是很常见的事，多输出损失由多个位置计算，再更新现在来看，很多视觉任务都可以套用这招 如图所示，第一层中 x 0 , 1 x^{0,1} x0,1、 x 0 , 2 x^{0,2} x0,2、 x 0 , 3 x^{0,3} x0,3、 x 0 , 4 x^{0,4} x0,4等4个位置都参与了损失计算，由于很多位置都参与了损失计算可以再各个阶段都获取一个比较好的效果，使得最终的结果更好。
2.4 Unet++优点 可以更容易剪枝：因为前面也单独有监督训练可以根据速度要求来快速完成剪枝训练的时候同样会用到L4，效果还不错
如图所示，原本是一个4层的网络，由于多个部分参与了损失计算，可以很方便的直接去掉最后一层看最后的结果，如果对速度要求发生变化，就可以尝试去掉第四层。 2.5 Unet+++ U-net+++（了解下就行）不同的max pool整合低阶特征(X1和X2，轮廓之类的)上采样整合高阶特征（感受野大的，全局的）各层统一用卷积得到64个特征图5*64=320，最终组合得到全部特征 这里看清楚了，是有3个+，其实这方面的论文有不少，4+和5+都有，实际上大同小异。
低阶特征（长宽大、特征图数少，如图 X E n 1 X^1_{En} XEn1​、 X E n 2 X^2_{En} XEn2​）通过maxpooling降维，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5f975527d7c6e826e524e180f7446f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8e50fdb28b318f4a53e4532411568a1/" rel="bookmark">
			python 安装库pycrypto失败的一系列问题[已解决]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要安装pycrypto这个库。 /*****************安装pycryptodome***********************/ 说来难受，后面发现这个貌似不再维护了，可以安装另外一个库pycryptodome，是这个库的延伸版本，和这个库的作用是一样的，我也是看别人的。
安装pycryptodome
pip install pycryptodome /*****************安装pycryptodome***********************/ 安装pycrypto 需要安装pycrypto的继续：注意3.9以上版本的python可能都无法使用。存在一个错误。
File "c:\Users\ice\Desktop\112.py", line 7, in &lt;module&gt; cipher = AES.new(key, AES.MODE_ECB) ^^^^^^^^^^^^^^^^^^^^^^^^^^ File "D:\software\compiler\python\python3.11.5\Lib\site-packages\Crypto\Cipher\AES.py", line 95, in new return AESCipher(key, *args, **kwargs) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File "D:\software\compiler\python\python3.11.5\Lib\site-packages\Crypto\Cipher\AES.py", line 59, in __init__ blockalgo.BlockAlgo.__init__(self, _AES, key, *args, **kwargs) File "D:\software\compiler\python\python3.11.5\Lib\site-packages\Crypto\Cipher\blockalgo.py", line 141, in __init__ self._cipher = factory.new(key, *args, **kwargs) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SystemError: PY_SSIZE_T_CLEAN macro must be defined for '#' formats 目前知道是要加宏定义
Note For all # variants of formats (s#, y#, etc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8e50fdb28b318f4a53e4532411568a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77b625e3ada59637e0fca66227dcc0a9/" rel="bookmark">
			Web自动化测试—webdriver的环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥 交流讨论：欢迎加入我们一起学习！
🔥 资源分享：耗时200+小时精选的「软件测试」资料包
🔥 教程推荐：火遍全网的《软件测试》教程 📢欢迎点赞 👍 收藏 ⭐留言 📝 如有错误敬请指正！
环境： win10 +
想要Python通过selenium操作浏览器搞些事情，就必须有两个前提条件：
下载selenium模块安装selenium的浏览器驱动 webdriver selenium模块下载
pip install selenium pip install -i https://pypi.doubanio.com/simple/ selenium pip install -i https://pypi.doubanio.com/simple/ selenium==3.141.0
浏览器驱下载
浏览器驱动的安装时新手阶段遇到较多问题之一，因为可选择的浏览器较多，我们先来聊聊各种场景的浏览器：
网页浏览器，也就是我们现在经常用到的浏览器，打开浏览器有个可视化的界面供我们操作，常见的有： GoogleFirefoxSafariIE/edgeOpera无头浏览器(Headless Browser)，无头，这里是说无界面的，这种浏览器的运行是不可见的，selenium中常用的无头浏览器有： PhantomJS无头浏览器Google无头浏览器Firefox无头浏览器 关于无头浏览器：无头浏览器指的是没有图形用户界面的浏览器。无头浏览器在类似于流行网络浏览器的环境中提供对网页的自动控制，但是通过命令行界面或使用网络通信来执行。 它们对于测试网页特别有用，因为它们能够像浏览器一样呈现和理解超文本标记语言，包括页面布局、颜色、字体选择以及JavaScript和AJAX的执行等样式元素，这些元素在使用其他测试方法时通常是不可用的。
无头浏览器常用于：
Web应用程序中的测试自动化。拍摄网页截图对JavaScript库运行自动化测试收集网站数据自动化网页交互 使用无头浏览器的优势：
对于UI自动化测试，少了真实浏览器加载css，js以及渲染页面的工作。无头测试要比真实浏览器快的多。可以在无界面的服务器或CI上运行测试，减少了外界的干扰，使自动化测试更稳定。在一台机器上可以模拟运行多个无头浏览器，方便进行并发测试。 关于PhantomJS无头浏览器：PhantomJS是一个可以用JavaScript编写脚本的无头web浏览器。它在Windows、macOS、Linux和FreeBSD上运行。使用QtWebKit作为后端，它为各种web标准提供了快速的本地支持：DOM处理、CSS选择器、JSON、Canvas和SVG。
另外，说一个比较悲痛的消息：PhantomJS暂停维护(可能的原因是内部问题和外部压力(Google和Firefox无头带来的压力))，所以，我们现在使用PhantomJS的话，你会看到提示：
UserWarning: Selenium support for PhantomJS has been deprecated, please use headless versions of Chrome or Firefox instead warnings.warn('Selenium support for PhantomJS has been deprecated, please use headless '
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77b625e3ada59637e0fca66227dcc0a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbad2de0d9d88bfa0f85f2586f2bb580/" rel="bookmark">
			详解Spring中@RequestMapping、@PostMapping、@GetMapping三个注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Spring Boot框架中，注解的使用是开发过程中不可或缺的一部分。其中，@RequestMapping、@PostMapping和@GetMapping是三个非常常用的注解，它们用于处理HTTP请求映射。本文将详细介绍这三个注解的知识点以及它们之间的区别以及使用。
一、@RequestMapping注解
@RequestMapping是Spring MVC中用于映射web请求（如URL路径）到具体的方法上的注解。它既可以标注在类上，也可以标注在方法上。标注在类上时，表示类中的所有响应请求的方法都是以该类路径为父路径。
示例：
@RestController @RequestMapping("/users") public class UserController { @GetMapping("/{id}") public User getUserById(@PathVariable Long id) { // ... 获取用户信息的逻辑 return user; } } 在上述代码中，@RequestMapping("/users")注解表示该控制器处理所有以/users为前缀的URL请求。而@GetMapping("/{id}")则表示处理GET类型的请求，具体路径为/users/{id}。
二、@PostMapping注解
@PostMapping是一个组合注解，它是@RequestMapping(method = RequestMethod.POST)的缩写。它用于处理HTTP POST请求的方法，只能标注在方法上。使用@PostMapping注解的方法将仅响应POST请求。
示例：
@RestController @RequestMapping("/users") public class UserController { @PostMapping("/create") public User createUser(@RequestBody User user) { // ... 创建用户信息的逻辑 return createdUser; } } 在上述代码中，@PostMapping("/create")表示该方法处理的是POST请求，路径为/users/create。通常用于创建新的资源。
三、@GetMapping注解
@GetMapping也是一个组合注解，它是@RequestMapping(method = RequestMethod.GET)的缩写。它用于处理HTTP GET请求的方法，也只能标注在方法上。使用@GetMapping注解的方法将仅响应GET请求。
示例：
@RestController @RequestMapping("/users") public class UserController { @GetMapping("/list") public List&lt;User&gt; listUsers() { // .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbad2de0d9d88bfa0f85f2586f2bb580/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de57139e10029276b6ebf9d043d57f99/" rel="bookmark">
			如何安装&amp;升级：XCode CommandLine Tools
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 安装：XCode CommandLine Tools xcode-select --install 安装成功后，使用下面指令验证：
xcode-select -p 打印结果：/Library/Developer/CommandLineTools
2. 升级XCode CommandLine Tools 升级要使用系统的Software Update进行升级，点击左上角的苹果图标 -&gt; 关于本机。
3. 切换路径 卸载了XCode后，更新版本的Command Line Tools之后，需要切换到新版本的路径。
# reset to the default command line tools path sudo xcode-select -r sudo xcode-select --switch /Library/Developer/CommandLineTools 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/407fbc2a3d25e97edee8c6afc4889048/" rel="bookmark">
			【C&#43;&#43;】string类的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：在前面我们说过，前面的绝大部分内容都是在为了后面真正进入C++这块大门做铺垫，今天我们将正式的步入string类来进一步了解C++的奥妙。
💖 博主CSDN主页:卫卫卫的个人主页 💞
👉 专栏分类:高质量Ｃ++学习 👈
💯代码仓库:卫卫周大胖的学习日记💫
💪关注博主和博主一起学习!一起努力！
目录标题 string类的使用string类对象的常见构造构造函数string类对象的容量操作string类对象的访问及遍历操作迭代器(非常重要)string中operator[ ]重载的使用 string类对象的修改操作C++中的string与C语言字符串的区别string类中的运算符重载 string类的使用 string类对象的常见构造 字符串是表示字符序列的类标准的字符串类提供了对此类对象的支持，其接口类似于标准字符容器的接口，但添加了专门用于操作单字节字符字符串的设计特性。string类是使用char(即作为它的字符类型，使用它的默认char_traits和分配器类型(关于模板的更多信息，请参阅basic_string)。string类是basic_string模板类的一个实例，它使用char来实例化basic_string模板类，并用char_traits
和allocator作为basic_string的默认参数(根于更多的模板信息请basic_string)。注意，这个类独立于所使用的编码来处理字节:如果用来处理多字节或变长字符(如UTF-8)的序列，这个类的所有成员(如长度或大小)以及它的迭代器，将仍然按照字节(而不是实际编码的字符)来操作。 构造函数 1string().默认构造函数，创建一个空字符串。
int main() { string emptyString;// 使用默认构造函数创建空字符串对象 string emptyString1 = "";// 使用空字符串字面值构造函数创建空字符串对象 string StrOutput("hello"); emptyString = StrOutput; emptyString1 = StrOutput; cout &lt;&lt; emptyString &lt;&lt; endl; cout &lt;&lt; emptyString1&lt;&lt;endl; return 0; } 这两种方法都将创建一个空的字符串对象，可以在后续的代码中对其进行赋值或修改。
2.string(const char* str)： 使用C风格的字符串来初始化一个string对象
int main() { string StrOutput = "Hello string";//构建一个对象并赋值 cout &lt;&lt; StrOutput &lt;&lt; endl;//打印对象 const char* str_cur = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/407fbc2a3d25e97edee8c6afc4889048/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97b50c9af3da3c001281ee60b3a3bfc3/" rel="bookmark">
			【C语言】深入理解指针（一篇让你完全搞懂指针）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是指针？ 1.1指针概念 本质上指针就是地址，口语中所说的指针，其实就是指针变量，指针变量是用来存放地址的一个指针。
我们知道计算机上CPU（中央处理器）在处理数据的时候，需要的数据是内存中读取的，处理后的数据也会放回内存中。
电脑上内存是8CB/16GB/32GB等，这些内存空间如何高效的管理？
其实就是把内存划分成一个一个的内存单元，每个内存单元的大小取1字节，每个内存单元都有一个编号。
有了内存单元的编号，CPU就可以快速找到一个内存空间。
内存单元的编号 == 地址 == 指针
二、指针变量和地址 2.1 取地址操作符（&amp;） 在C语言中，创建变量其实就是向内存申请空间
上述代码创建整型变量a，向内存申请了4个字节，用于存放整数10，其中每个字节都有地址，上图中4个字节地址分别是：
0x00F5FCEC 0x00F5FCED 0x00F5FCEE 0x00F5FCEF
那我们如何得到a的地址？ 这里就用到取地址操作符（&amp;）
#include &lt;stdio.h&gt; int main() { int a = 10; &amp;a; printf("%p\n", &amp;a); return 0; } 上述代码，运行之后，打印：0x00F5FCEC &amp;a取出来的是a所占4个字节中地址最小的字节的地址。
2.2 指针变量和解引用操作符（*） 2.2.1 指针变量 我们通过取地址操作符（&amp;）拿到的地址是一个数组，比如：0x00F5FCEC，这个数组有时候需要存储起来，方便后期使用，那我们就可以把地址值存放在指针变量中。
总结：变量a和指针变量pa都有各自的地址，只是把变量a的地址存放在指针变量pa里。
指针变量也是一种变量，这种变量就是用来存放地址的，存放在指针变量中的值都会理解为地址
2.2.2 解引用操作符（*） #include &lt;stdio.h&gt; int main() { int a = 10; int* pa = &amp;a;//取出a地址，并存放在指针变量中 //①int说明pa指向的对象是int类型 ②*说明pa是指针变量 *pa=100; printf("%d",*pa); return 0; } 输出：100
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97b50c9af3da3c001281ee60b3a3bfc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/504ce31b6b44ffea58a3b635da29808d/" rel="bookmark">
			Spark概述及Scala搭建操作步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一：Spark概述
a：定义
b:创始和服务公司
c:spark发展历史
二：spark特点
三.认识spark的生态圈
a.定义：
b.spark生态圈中重要组件的简要介绍：
四.spark作业工作运行流程
五.spark核心数据RDD
六.Scala
a.定义
b.scala特性
七:spark部署与安装：
搭建Hadoop伪分布式集群：
d.搭建完全分布式集群。
八.scala搭建
在Linux和macOS系统上安装Scala https://www.scala-lang.org/html(1)上传并解压安装scala安装包
在Windows系统上安装Scala https://www.scala-lang.org/html
spark对比MapReduce框架
spark内置模块
图解Scala和Java的关系
一：Spark概述 a：定义 spark是一种基于内存的快速，通用，可扩展的大数据分析计算引擎。
b:创始和服务公司 是加州大学伯克利分校AMP实验室（Algorithms, Machines, and People Lab）开发的通用内存并行计算框架Spark得到了众多大数据公司的支持，这些公司包括Hortonworks、IBM、Intel、Cloudera、MapR、Pivotal、百度、阿里、腾讯、京东、携程、优酷土豆。当前百度的Spark已应用于大搜索、直达号、百度大数据等业务；阿里利用GraphX构建了大规模的图计算和图挖掘系统，实现了很多生产系统的推荐算法；腾讯Spark集群达到8000台的规模，是当前已知的世界上最大的Spark集群。
c:spark发展历史 1、2009年，Spark诞生于伯克利大学AMPLab，属于伯克利大学的研究性项目；
2、2010 年，通过BSD 许可协议正式对外开源发布；
3、2012年，Spark第一篇论文发布，第一个正式版（Spark 0.6.0）发布；
4、2013年，成为了Aparch基金项目；发布Spark Streaming、Spark Mllib（机器学习）、Shark（Spark on Hadoop）；
5、2014 年，Spark 成为 Apache 的顶级项目； 5 月底 Spark1.0.0 发布；发布 Spark Graphx（图计算）、Spark SQL代替Shark；
6、2015年，推出DataFrame（大数据分析）；2015年至今，Spark在国内IT行业变得愈发火爆，大量的公司开始重点部署或者使用Spark来替代MapReduce、Hive、Storm等传统的大数据计算框架；
7、2016年，推出dataset（更强的数据分析手段）；
8、2017年，structured streaming 发布；
9、2018年，Spark2.4.0发布，成为全球最大的开源项目。
而后spark的发展主要针对spark的可用性、稳定性进行改进，并持续进行润色代码。
二：spark特点 1.快速：逻辑回归算法一般需要多次迭代。分别使用Hadoop，mapreduce,spark运行逻辑回归算法。spark的运行速度是Hadoop mapreduce运行速度的100多倍，spark在内存中运行速度是Hadoop mapreduce运行速度的100多倍，spark在磁盘上的运行速度是Hadoop mapreduce运行速度的10多倍。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/504ce31b6b44ffea58a3b635da29808d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98deae2ebc2334c24d802aa74314a3f6/" rel="bookmark">
			websocket 实现后端主动前端推送数据、及时通讯(vue3 &#43; springboot)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 WebSocket 是一种全双工通信协议，用于在 Web 浏览器和服务器之间建立持久的连接。
WebSocket 协议由 IETF 定为标准，WebSocket API 由 W3C 定为标准。一旦 Web 客户端与服务器建立连接，之后的全部数据通信都通过这个连接进行。可以互相发送 JSON、XML、HTML 或图片等任意格式的数据。 WebSocket 与 HTTP 协议的异同:
相同点：
都是基于 TCP 的应用层协议。都使用 Request/Response 模型进行连接的建立。可以在网络中传输数据。 不同点：
WebSocket 使用 HTTP 来建立连接，但定义了一系列新的 header 域，这些域在 HTTP 中并不会使用。WebSocket 支持持久连接，而 HTTP 协议不支持持久连接。 WebSocket 优点:
高效性： 允许在一条 WebSocket 连接上同时并发多个请求，避免了传统 HTTP 请求的多个 TCP 连接。
WebSocket 的长连接特性提高了效率，避免了 TCP 慢启动和连接握手的开销。
节省带宽：HTTP 协议的头部较大，且请求中的大部分头部内容是重复的。WebSocket 复用长连接，避免了这一问题。
服务器推送：WebSocket 支持服务器主动推送消息，实现实时消息通知。
WebSocket 缺点:
长期维护成本：服务器需要维护长连接，成本较高。
浏览器兼容性：不同浏览器对 WebSocket 的支持程度不一致。
受网络限制：WebSocket 是长连接，受网络限制较大，需要处理好重连。
WebSocket 应用场景:
实时通信领域：社交聊天弹幕多玩家游戏协同编辑股票基金实时报价体育实况更新视频会议/聊天基于位置的应用在线教育智能家居等需要高实时性的场景。 一、后端代码 1、安装核心jar包: spring-boot-starter-websocket &lt;dependencies&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98deae2ebc2334c24d802aa74314a3f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5134dcc91482fb2e889c707b80f23b60/" rel="bookmark">
			使用ENSP模拟器配置华为防火墙的WEB登录页面 ---＞＞ 保姆级教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先要创建本地测试环回接口 点击此电脑 -- &gt; 计算机管理
点击设备管理器中的网络适配器
点击操作中的添加过时硬件
继续点击下一步
点击下一步
点击网络适配器
选择Microsoft中的环回适配器
下一步
OK！环回适配添加完成
网络 ---&gt;&gt; 属性 ---&gt;&gt; 更改适配器设置
并配置一条IP地址
2.打开ENSP模拟器，并拉好一个拓扑图（USG6000V安装包放在最下面了！！！） 先增加一条UDP流量
在选择刚刚增加的以太网网卡
最后再出端口编号选择2，点击双向通道，点击增加
配置防火墙，初次点击防火墙需要输入账户和密码分别是：admin、Admin@123，之后需要手动去修改初始密码
进入接口以后，配置同刚才以太网网卡上面相同网段的IP
在接口中还需要执行server-manage all promint ，需要在接口中放行http服务 3.进入防火墙的WEB页面 在浏览器上面属于刚才防火墙接口配的地址：
点击高级
选择继续浏览：
最后输入刚才修改的账户、密码，点击登录就可以啦！
防火墙USG6000V安装包：https://pan.baidu.com/s/1f5CuUI9ZbPNYdTlO-owIDg 提取码：6678
自己整理的防火墙笔记：链接：https://pan.baidu.com/s/1FMx0uk0saFFlCoySXvV5KQ 提取码：6678
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9e1a115edc8b342993d812f9094d0ef/" rel="bookmark">
			今日推荐库：@microsoft/fetch-event-source 前端发送SSE请求实现GPT流式输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 @microsoft/fetch-event-source 改善服务器发送事件的请求@microsoft/fetch-event-source - npm 在前端开发中，处理服务器发送事件（server-sent events）时，我们通常使用浏览器提供的 EventSource API。然而，该默认 API 存在一些限制，本文介绍了一个名为 @microsoft/fetch-event-source 的包，它提供了更强大的 API，使我们能够更灵活地进行服务器发送事件的请求。
问题与限制 默认的浏览器 EventSource API 在以下方面存在一些限制：
无法传递请求体（request body），必须将执行请求所需的所有信息编码到 URL 中，而大多数浏览器对 URL 的长度限制为 2000 个字符。无法传递自定义请求头。只能进行 GET 请求，无法指定其他方法。如果连接中断，无法控制重试策略，浏览器会自动进行几次尝试然后停止。 @microsoft/fetch-event-source 的优势 @microsoft/fetch-event-source 提供了一个基于 Fetch API 的替代接口，完全兼容 Event Stream 格式。这使得我们能够以更加灵活的方式进行服务器发送事件的消费。以下是该库的一些主要优势：
支持任何请求方法、请求头和请求体，以及 Fetch API 提供的其他功能。甚至可以提供替代的 fetch() 实现，以应对默认浏览器实现无法满足需求的情况。提供对响应对象的访问权限，允许在解析事件源之前进行自定义验证/处理。这在存在 API 网关（如 nginx）的情况下非常有用，如果网关返回错误，我们可能希望正确处理它。对连接中断或发生错误时，提供完全控制的重试策略。 此外，该库还集成了浏览器的 Page Visibility API，使得在文档被隐藏时（例如用户最小化窗口），连接会关闭，当文档再次可见时会自动使用上次事件 ID 进行重试。这有助于减轻服务器负担，避免不必要的开放连接（但如果需要，可以选择禁用此行为）。
安装 npm install @microsoft/fetch-event-source
使用示例 在使用 @microsoft/fetch-event-source 之前，我们通常使用以下方式处理服务器发送事件：
const sse = new EventSource('/api/sse'); sse.onmessage = (ev) =&gt; { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9e1a115edc8b342993d812f9094d0ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1b11b8bca1f7d2af368a83b1b4c4bff/" rel="bookmark">
			AI 绘画平台难开发，难变现？试试 Stable Diffusion API Serverless 版解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Stable Diffusion 模型，已经成为 AI 行业从传统深度学习时代走向 AIGC 时代的标志性里程碑。越来越多的开发者借助 stable-diffusion-webui（以下简称 SDWebUI）能力进行 AI 绘画领域创业或者业务上新，获得高流量及商业价值，但是面对多客户、高并发的复杂场景，使用原生 Stable Diffusion API 会面临以下挑战：
1. 显卡资源昂贵且难以购买，GPU 卡池管理技术门槛高：高性能的 GPU 资源不仅价格昂贵，而且往往难以大规模采购。此外，GPU 卡池的有效管理和维护需要复杂的技术支持，也带来了额外的挑战。
2. 难以应对高并发：原生的 Stable Diffusion API 采用单实例推理模式，其并发处理能力有限。在面对高并发场景时，尤其是并发请求具有大的波动性时，资源配置难以精确预测，从而可能导致系统错误和业务中断。
3. 多模型切换难度大：当不同模型的请求在高并发条件下同时发送到同一实例时，频繁的模型切换成为一个显著的瓶颈。这种切换不仅消耗巨大，而且影响了推理效率，使得多模型部署在实际应用中变得复杂和低效。
为了帮助用户高效率、低成本应对企业级复杂场景，函数计算团队正式推出 Stable Diffusion API Serverless 版解决方案，通过使用该方案，用户可以充分利用 Stable Diffusion +Serverless 技术优势快速开发上线 AI 绘画应用，期待为广大开发者 AI 绘画创业及变现提供思路。
基于 Stable Diffusion API Serverless 版解决方案搭建的，部署 AI 艺术字应用活动火热进行中！生成姓氏头像赢新春好礼，欢迎点击 “阅读原文”体验。 活动链接： https://developer.aliyun.com/topic/fcnewyear 01 应用场景 Stable Diffusion API Serverless 版本提供了多种可能性，以适应不同的应用场景和业务需求。
1. 个性化内容创作：利用 Stable Diffusion API，内容创作者和数字艺术家可以快速生成个性化的艺术作品和图像。例如，艺术家可以根据用户的描述或关键词，即时创作出独特的艺术风格图像，实现个性化的艺术创作和用户互动。
2. 广告和市场营销：在广告和市场营销领域，Stable Diffusion API 可以用来生成吸引人的视觉内容，从而增强广告效果。例如，企业可以根据产品特性和目标受众的偏好，快速创建多样化的广告图像，以提升品牌形象和市场吸引力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1b11b8bca1f7d2af368a83b1b4c4bff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eabc04d89af8f633d5fe42ae7a27bfc8/" rel="bookmark">
			Android基础篇-基本布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android布局是开发中必不可少的一部分，熟悉一些常用的布局和属性可以大大提高开发效率。
布局名称使用场景使用率LinearLayout适合比较简单的布局场景，按照水平或垂直方向排列视图频繁RelativeLayout适合复杂的布局，子布局需要相对于其他布局或父布局进行摆放。频繁ConstraintLayout适合复杂的布局，通过约束条件轻松排列子视图的位置频繁FrameLayout适合单一子视图简单布局。覆盖式布局，可以实现布局叠加一般GridLayout适合展示类似于网格一样、大小相等的多个视图的布局单独用较少，通常用组件RecyclerView创建和管理TableLayout适合展示表格结构布局较少 编写布局的时候，尽量扁平化布局，减少层级嵌套，因为布局层级越深，UI的加载速度越慢。
通常情况下，不同的布局是需要配合使用的。
设计布局中通用的一些属性如下： layout_gravity 布局重心，将布局中的所有元素位于父元素的某个位置上gravity 重心，把控件内的元素放在控件的某个位置，文本控件适用textAllCaps 按钮英文默认全大写，设置该属性值false允许小写
1.线性布局(LinearLayout) 属性属性值作用orientation
- vertical：垂直方向
- horizontal：水平方向
选择布局的排列方向baselineAligned
- true - false
设置布局子元素的基线对齐，默认是true。对子视图是TextView、Button等包含文本的组件才有效，用于文本对齐功能比较有用baselineAlignedChildIndex子视图的索引，从0开始指定线性布局元素在垂直方向以指定子视图索引的基线对齐divider资源文件通过引入资源设置布局中子视图之间的分割效果，需要搭配showDividers一起使用showDividers
- middle 子视图之间显示
- beginning 第一个视图前显示
- end 最后一个视图后显示
- none 不显示
设置分割效果资源在布局子视图中的显示位置，可以组合使用，如在第一个视图前，最后一个视图后同时显示： android:showDividers=“beginning|end”dividerPadding像素值设置分割资源的内边距，如果线性布局是垂直布局，表示设置分割资源左右内边距，否则为上下内边距layout_weight整数如果多个元素设置这个属性，他们会根据权重大小将剩余空间按照比例进行划分空间，通常用来实现均分，按比例划分布局等 使用线性布局构造一个垂直布局，子元素之间需要有分割线,分割线左右不填满。
1.定义分割线的资源divider.xml
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item&gt; &lt;shape&gt; &lt;size android:height="1dp" /&gt; &lt;solid android:color="@android:color/black" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; 2.主布局
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;LinearLayout android:layout_width="wrap_content" android:layout_height="wrap_content" android:divider="@drawable/divider" android:dividerPadding="3dp" android:orientation="vertical" android:showDividers="middle"&gt; &lt;Button android:layout_width="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eabc04d89af8f633d5fe42ae7a27bfc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e74fed1394e3627c399db3528cacd4bb/" rel="bookmark">
			如何学习、上手点云算法(一)：点云基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 本文内容
点云算法的学习基础，入门方法，相关领域，资源，开源库，算法等的介绍；
以Open3D和PCL等为基础工具的点云处理代码讲解、实现；
文中涉及的参考以链接形式给出，涉及文件资源如点云，已上传至网盘本博客资源链接，路径为:
share_noel/csdn/how_to_learn_point_cloud/how_to_learn_point_cloud_1；
本文尽力用最简单易懂的语言和方式来介绍相关内容，欢迎补充指正！
如何学习、上手点云算法系列：
如何学习、上手点云算法(一)：点云基础
如何学习、上手点云算法(二)：点云处理相关开源算法库、软件、工具
如何学习、上手点云算法(三)：用VsCode、Visual Studio来debug基于PCL、Open3D的代码
更多点云基础、算法相关内容请关注专栏：
点云处理基础
点云配准(PointCloud Registration)
Open3D点云处理
PCL点云处理
点云算法平台/环境
Windows10, Ubuntu1804, CMake, Open3D, PCL转载请注明出处：
https://blog.csdn.net/qq_41102371/article/details/136288203 目录 写在前面点云基础什么是点云点云获取方式、作用、相关领域 点云算法有哪些有何用？资源常用开源库参考完 点云基础 什么是点云 最好的认知方式莫过于实践，现在你可以下载一个开源且跨平台的点云可视化、处理软件CloudCompare(如果你以后的学习或工作经常和点云打交道，请一定记住这个软件，它将成为你的得力助手！)，以及上述网盘中的点云或者你自己的点云，用CloudCompare打开下载的点云看看，建立一个感性认知，一切的故事，将从这里开始。
下面是比较理性的认知：
点云(PointCloud)，是一种三维空间目标的表现形式，可用一群空间离散三维点 ( x , y , z ) (x, y, z) (x,y,z) 的集合来表达，如 { P } \{P\} {P} 表示一个有 N N N 个点的点云， p i , i ∈ { 0 , 1 , 2... n } p_i, i\in\{0,1,2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e74fed1394e3627c399db3528cacd4bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/550fd9b2c0a3c48d91d940c5a4f0f864/" rel="bookmark">
			Lightly —— Java轻量级在线编译器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Lightly，一款轻量级在线集成开发工具（IDE）。Lightly，支持客户端和云端在线开发模式。Lightly，支持项目实时协作、共同开发。 Lightly食用教程 初始界面——引导 了解Lightly IDE提供多种语言的项目编译环境以及数据库云端存储，其为两大重要特性。
支持的语言编译环境（13）：Java、Python、PHP、GoLang、Vue、C、C++、C#、HTML、Node.js、React、Rust、Svelte支持的数据库环境（4）：MySQL、Redis、MongoDB、PostgreSQL会员付费相关及使用机制 创立demo及开发界面、使用体验 界面整洁度以及UI布局一见如故，具有基本的运行调试控制台功能界面； 从数据库查询工具来看，其云端服务提供了类似IDEA的数据库连接查询功能，并支持4种数据库语言。
其程序整体运行速度流畅，一见如故。 总结 这是一款不错的在线编程工具 ，值得推荐。小伙伴们，你们还有哪些十分好用的线上编译工具值得推荐呢？
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/482/">«</a>
	<span class="pagination__item pagination__item--current">483/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/484/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>