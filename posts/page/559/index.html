<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd147f4d413ee73fc0d9acd479b72e7e/" rel="bookmark">
			docker 安装 mysql5.7（全网最详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装，以MySql5.7版本为例子。
docker默认的仓库比较慢，可以参考以下文章 第五标题 设置阿里云镜像仓库。
docker （简介、dcoker详细安装步骤、容器常用命令）一站打包- day01-CSDN博客
一、拉去mysql镜像 docker pull mysql:5.7 如下安装完成 [root@syf ~]# docker pull mysql:5.7 5.7: Pulling from library/mysql 72a69066d2fe: Pull complete 93619dbc5b36: Pull complete 99da31dd6142: Pull complete 626033c43d70: Pull complete 37d5d7efb64e: Pull complete ac563158d721: Pull complete d2ba16033dad: Pull complete 0ceb82207cd7: Pull complete 37f2405cae96: Pull complete e2482e017e53: Pull complete 70deed891d42: Pull complete Digest: sha256:f2ad209efe9c67104167fc609cca6973c8422939491c9345270175a300419f94 Status: Downloaded newer image for mysql:5.7 docker.io/library/mysql:5.7 查看本地镜像仓库拉去好的mysql，确认版本号
docker images 如下： [root@syf ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE mysql 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd147f4d413ee73fc0d9acd479b72e7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efe1e1cfbae545d1092e0a2bad855c14/" rel="bookmark">
			算法笔记：样条插值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 什么是样条 样条来源于早期工程制图，为了将一些固定点连成一条光滑的曲线，采用具有弹性的木条固定在这些点上通过样条画出来的曲线不仅经过各固定点，而且连续光滑 2 样条函数 数学上定义成一个分段多项式函数 每两个点之间用一个多项式来表示，这些多项式的阶数相同，但是系数是不一样的样条插值的目的就是求这些多项式系数，已知系数，那些中间点的值就能唯一确定了 线性样条 在每两点间画一条直线
二次样条 三次样条 3 样条插值原理 连续光滑边界条件 下面以三次样条插值为例，假设是已知的n+1个数据点，整个函数有这4n个未知数组成
若想求得这4n个未知系数，需要构建4n个方程
3.1 连续 根据连续性原则，每个分段函数都经过其两侧端点因此，可得到2n个方程： 3.2 光滑性原则 根据光滑性原则，相邻的两个分段函数连接处低阶导数相等 对于三次样条来说，就是一阶导数和二阶导数 3.3 边界条件 目前一共4n-2个方程，不足以得到4n个系数的解在公式(3)和(4)中，第1个点和第n+1个点在边界，只被使用了一次，导致整个方程组还差2个方程才能求解。此时，可以假设不同的边界条件来构成4n个方程。需要注意的是，不同的边界条件导致插值结果也有所不同。 Natural Spline 假设第1个和最后一个端点的二阶导为0
Not-a-Knot Spline 假设第一段和第二段函数的三阶导在端点处相等；第n-1段和第n段函数的三阶导在端点处也相等
Periodic Spline 最后一个分段函数的一阶段和二阶导于第一个分段的一阶导和二阶导相等
这种假设特别适合用在周期函数中，尤其是第一点与最后一点相等时
Quadratic Spline 强制第一个与最后一个分段函数的第一个系数为0
参考内容：样条插值(Spline Interpolation)-云社区-华为云 (huaweicloud.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f2b7d3069e3b7426eece3617148e971/" rel="bookmark">
			Android-Studio编译不过提示caused by: org.gradle.api.internal.plugins.PluginApplicationException: Failed t错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.遇到的问题 Caused by: org.gradle.api.internal.plugins.PluginApplicationException: Failed to apply plugin [id ‘com.android.internal.application’] 2.尝试方法 根据搜索在Gradle Scripts的gradle.properties中添加以下语句
android.overridePathCheck=true
但是问题没有得到解决，搜索了很多方法不行，最后想到是不是Android-studio版本太高问题，我用的是2023.2.3版本 ，根据下载代码的时间降到2021.2.1版本问题最终解决。 3.总结 不断尝试，就会有不一样的收获，程序就这样有趣。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a05506d90bcbaf224d79456b93590609/" rel="bookmark">
			【AI绘画】万字长文——（超详细）ControlNet的详细介绍&amp;使用Stable Diffusion的艺术二维码完全生成攻略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、名词解释1-1、Stable Diffusion介绍1-2、ControlNet介绍1-2-1、ControlNet介绍&amp;工作原理1-2-2、ControlNet控制方法介绍 1-3、案例分析1-3-1、室内装修设计1-3-2、品牌创意海报 1-4、stable-diffusion-webui 的参数解释 二、生成方法2-1、图像到图像2-1-1、二维码生成2-1-2、选择云端平台来启动Stable Diffusion的Web UI2-1-3、使用Stable Diffusion来修饰二维码 2-2、使用控制网络将文本转图像2-2-1、二维码生成2-2-2、安装插件——After Detailer 2-2-3、安装QR Code Monster 模型2-2-4、模型参数设置2-2-5、出图 三、附录3-1、ControlNet模型3-1-1、Controlnet QR Pattern (QR Codes)3-1-2、monster-labs/control_v1p_sd15_qrcode_monster3-1-2、ioclab/ioc-controlnet 总结 前言 详细介绍ControlNet的各个部分，相关案例，以及使用二维码作为ControlNet模型的输入的Stable Diffusion生成的图像，使二维码转变为艺术图像 一、名词解释 1-1、Stable Diffusion介绍 Stable Diffusion：是StabilityAI于2022年8月22日发布的文本到图像模型。它类似于OpenAI的DALL·E 2和Midjourney等其他图像生成模型，但有一个很大的不同:它是开源的,在发布后的短短几周内，围绕Stable Diffusion模型和相关工具的创新出现了爆炸式增长。Stable Diffusion在速度上的突破也意味着，模型第一次可以在消费类gpu上运行，而不是在超级计算机上。这对于Stable Diffusion影响力的快速增长带来了巨大意义！ Stable Diffusion的技术细节如下：
Stable Diffusion是一种扩散模型（diffusion model）的变体，叫做“潜在扩散模型”（latent diffusion model; LDM）。扩散模型是在2015年推出的，其目的是消除对训练图像的连续应用高斯噪声，可以将其视为一系列去噪自编码器。Stable Diffusion由3个部分组成：变分自编码器（VAE）、U-Net和一个文本编码器。与其学习去噪图像数据（在“像素空间”中），而是训练VAE将图像转换为低维潜在空间​（英语）。添加和去除高斯噪声的过程被应用于这个潜在表示，然后将最终的去噪输出解码到像素空间中。在前向扩散过程中，高斯噪声被迭代地应用于压缩的潜在表征。每个去噪步骤都由一个包含残差神经网络​（粤语）（ResNet）中间的U-Net架构完成，通过从前向扩散往反方向去噪而获得潜在表征。最后，VAE解码器通过将表征转换回像素空间来生成输出图像。研究人员指出，降低训练和生成的计算要求是LDM的一个优势。去噪步骤可以以文本串、图像或一些其他数据为条件。调节数据的编码通过交叉注意机制（cross-attention mechanism）暴露给去噪U-Net的架构。为了对文本进行调节，一个预训练的固定CLIP ViT-L/14文本编码器被用来将提示词​转化为嵌入空间。
简单来说：Stable Diffusion是一种深度学习算法，它使用文本作为输入来生成渲染图像。它的工作原理是一个扩散过程，在这个过程中，图像通过一系列步骤逐渐从随机噪声变成连贯图像。该模型经过训练，可以根据提供的文本提示来指导此过程，
以下是stablediffusion官方仓库：https://github.com/Stability-AI/StableDiffusion
1-2、ControlNet介绍 1-2-1、ControlNet介绍&amp;工作原理 ControlNet: ControlNet是一种通过添加附加条件来控制扩散模型（例如Stable Diffusion）的神经网络结构。一般的使用方法是结合Stable Diffusion来做到精准控图。
简单工作原理：在带有ControlNet的图像训练过程中，一共有2种条件会作用到生成图像上，其一是提示词（prompt），另一个就是由ControlNet引入的各种自定义条件（Condition）。
以下是ControlNet对应模型的一个命名规则：需要注意的是是否是p，即可用于生成以及控制方法。
1-2-2、ControlNet控制方法介绍 Invert
Invert 用于检测用户上传的图像。预处理器和模型通常需要在黑色图像上使用白线来检测（也就是灰度图）。但如果你的图是白色图像上的黑线，就必须使用这个工具来切换颜色了，不然controlNet模型会无法正确识别输入图中的信息。注意这种情况在涂鸦模式和线稿填色场景中非常常见。
对应模型：无
测试如下：点击中间的按钮可以预览预处理后的轮廓线，左侧是原图，右侧是预处理后的图。
Canny
Canny 通过使用边缘检测器提取图像中的所有重要轮廓线。通过调节阈值，可以使线条捕捉到非常详细的信息，但也会因此让图像背景中固有的干扰信息影响你的目标物体，所以在必要时可通过设置边缘检测阈值达到过滤出特定边缘信息的目的。注意，对于一些细节丰富的训练图可能并不适合使用Canny提取边缘。
对应模型：control_v11p_sd15_canny
测试如下：点击中间的按钮可以预览。
Lineart
是Canny的替代者，但是能够比canny更加精准的提取二次元(使用anime后缀)，或真实照片(使用realistic后缀)图片的线稿。具体效果参考下方图示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a05506d90bcbaf224d79456b93590609/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e2d6b9f39ee98503203c28973e7b8f3/" rel="bookmark">
			MacOS 12 开放指定端口 指定ip访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MacOS 12 开放指定端口 指定ip访问 在 macOS 上开放一个端口，并指定只能特定的 IP 访问，你可以使用 macOS 内置的 pfctl（Packet Filter）工具来实现。 以下是一些基本的步骤：
1、 编辑 pf 配置文件： 打开 /etc/pf.conf 文件进行编辑。可以使用任何文本编辑器，如 sudo vim /etc/pf.conf。
2、添加规则： 在文件中添加规则，例如
# 指定只允许特定 IP 访问端口 pass in on en0 proto tcp from 192.168.1.2 to any port 8080 注：请将 en0 替换为你的网络接口，192.168.1.2 替换为允许访问的 IP 地址，8080 替换为你要开发的端口。
3、加载配置： 在终端中运行以下命令，以重新加载 pf 配置：
sudo pfctl -f /etc/pf.conf 4、启用 pf： 在终端中运行以下命令，以启用 pf：
sudo pfctl -e 过程示例：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edaf137edc75c8f9b948647092e77f90/" rel="bookmark">
			Python GUI 新手入门教程：轻松构建图形用户界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要 Python 凭借其简单性和多功能性，已经成为最流行的编程语言之一。被广泛应用于从 web 开发到数据科学的各个领域。
在本教程中，我们将探索用于创建图形用户界面（GUIs）的 Python 内置库：
Tkinter：无论你是初学者还是经验丰富的开发人员，了解如何创建 Python GUI 都可以增强你构建交互式应用程序的能力。
Tkinter 是 Python 附带的标准 GUI 工具包。它提供了一组用于创建图形用户界面的工具和小部件。
一、从创建一个简单的 Hello World 开始 让我们从一个基本的例子开始了解 Tkinter。打开你最喜欢的 Python 编辑器（我的是 Pycharm）并创建一个新文件，例如就叫 hello_tkinter.py。编写以下代码：
import tkinter as tk def say_hello(): label.config(text="Hello, Tkinter!") # Create the main window root = tk.Tk() root.title("Tkinter Hello World") # Create a label widget label = tk.Label(root, text="Welcome to Tkinter!") # Pack the label into the main window label.pack(pady=10) # Create a button widget button = tk.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edaf137edc75c8f9b948647092e77f90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a8e7e0fc32280df945e17b4517c518b/" rel="bookmark">
			Kafka中的Topic
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Kafka中，Topic是消息的逻辑容器，用于组织和分类消息。本文将深入探讨Kafka Topic的各个方面，包括创建、配置、生产者和消费者，以及一些实际应用中的示例代码。
1. 介绍 在Kafka中，Topic是消息的逻辑通道，生产者将消息发布到Topic，而消费者从Topic订阅消息。每个Topic可以有多个分区（Partitions），每个分区可以在不同的服务器上，以实现横向扩展。
2. 创建和配置Topic 2.1 创建Topic 使用Kafka提供的命令行工具（kafka-topics.sh）或Kafka的API来创建Topic。下面是一个使用命令行工具创建Topic的示例：
bin/kafka-topics.sh --create --topic my_topic --partitions 3 --replication-factor 2 --bootstrap-server localhost:9092 这将创建一个名为my_topic的Topic，有3个分区，复制因子为2。
2.2 配置Topic Kafka的Topic有各种配置选项，可以通过修改Topic的属性来满足不同的需求。例如，可以设置消息保留时间、清理策略等。以下是一个配置Topic属性的示例：
bin/kafka-configs.sh --zookeeper localhost:2181 --entity-type topics --entity-name my_topic --alter --add-config max.message.bytes=1048576 这将修改my_topic的配置，将最大消息字节数设置为1 MB。
3. 生产者和消费者 3.1 生产者 生产者负责将消息发布到Topic。使用Kafka的Producer API，可以轻松地创建一个生产者。以下是一个简单的Java示例代码：
Properties properties = new Properties(); properties.put("bootstrap.servers", "localhost:9092"); properties.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer"); properties.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer"); Producer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(properties); producer.send(new ProducerRecord&lt;&gt;("my_topic", "key1", "value1")); producer.close(); 3.2 消费者 消费者从Topic中读取消息。Kafka的Consumer API提供了强大而灵活的方式来实现消费者。
以下是一个简单的Java示例代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a8e7e0fc32280df945e17b4517c518b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57d49c71f7b8c2239f275af3d26309d0/" rel="bookmark">
			Java中三种定时任务总结（schedule，quartz，xxl-job）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、Spring框架的定时任务
2、Quartz
Quartz的用法
3、xxl-job
3.1 docker 安装xxl-job
3.2 xxl-job编程测试
补充：Java中自带的定时任务调度
1. java.util.Timer和java.util.TimerTask
2. java.util.concurrent.Executors和java.util.concurrent.ScheduledExecutorService
小结
1、Spring框架的定时任务 Spring框架提供了强大的定时任务支持。通过使用@Scheduled注解，可以将一个方法标记为定时任务，并指定任务的执行时间规则。可以设置任务在固定的时间点执行，也可以设置任务在一定的时间间隔内重复执行。Spring的定时任务功能更加灵活，支持各种时间表达式，也可以配置多线程执行任务。
Spring @Scheduled注解：这是一个基于Spring框架的应用程序，并通过Spring提供的@Scheduled注解来非常简便地实现定时任务。只需在方法上添加@Scheduled注解，并指定一个cron表达式，就可以在指定的时间执行该方法。Spring Boot @Scheduled注解：在Spring Boot框架中，也可以使用@Scheduled注解来创建定时任务。Spring Boot还提供了一个自动配置的Scheduler，使得创建和配置定时任务变得非常简单。 2、Quartz Quartz是一个由Java编写的开源作业调度框架，它允许与J2EE和J2SE应用程序相结合，也可以单独使用。Quartz可以用来创建简单或复杂的程序，包括运行十个、百个甚至上万个Jobs。这些Jobs可以做成标准的Java组件或EJBs。Quartz支持丰富的调度策略，例如支持多线程、优先级、异常处理等。
详情可见以下地址：
Quartz Enterprise Job Scheduler
java 调度框架 java任务调度框架有哪些_mob64ca140fd7c1的技术博客_51CTO博客
Java任务调度框架Quartz教程-腾讯云开发者社区-腾讯云
Quartz的核心概念包括Job、JobDetail和Trigger等。Job表示一个工作，包含要执行的具体内容，其接口中只有一个方法。JobDetail表示一个具体的可执行的调度程序，包含了这个任务调度的方案和策略。Trigger代表一个调度参数的配置，定义了何时去调度。Scheduler则是代表一个调度容器，一个调度容器中可以注册多个JobDetail和Trigger，当Trigger与JobDetail组合时，就可以被Scheduler容器调度了。
作业（Job）：表示一个要执行的任务或工作单元。根据具体需求，可以自定义实现 org.quartz.Job 接口或继承 org.quartz.InterruptableJob 接口，并实现 execute() 方法来定义任务的执行逻辑。
任务（Task）：是作业的实例，即具体要执行的任务对象。每次作业被触发时，都会创建一个新的任务实例。
触发器（Trigger）：定义作业何时触发执行的条件。Quartz 提供了多种触发器类型，如简单触发器 SimpleTrigger、日历触发器 CalendarTrigger 和 Cron 触发器 CronTrigger 等。通过配置触发器的属性，如触发时间、重复间隔等，可以灵活地定义作业的触发规则。
调度器（Scheduler）：是 Quartz 的核心组件，负责管理和协调作业的调度和执行。调度器可以启动、停止和暂停作业的执行，并根据触发器的配置规则触发作业执行。
上下文（Context）：提供了在作业执行期间访问调度器和其他环境信息的方式。作业实例可以通过上下文对象获取调度器、触发器和其他相关信息。
监听器（Listener）：用于监听作业和触发器的事件，如作业执行前后、触发器触发前后等。通过实现监听器接口，可以在特定事件发生时执行自定义的逻辑。
任务存储（JobStore）：Quartz 使用任务存储来持久化作业和触发器的状态信息，以便在应用重启后能够恢复调度任务。Quartz 提供了多种任务存储实现，包括内存存储、数据库存储和集群存储等。
Quartz的使用非常灵活。比如，可以配置一个Job实现类并设定好调度时间表，Quartz就会密切注意剩余时间，当调度程序确定该是通知作业的时候，Quartz框架就会调用Job实现类（作业类）上的execute()方法并允许做它该做的事情。这个过程无需报告任何东西给调度器或调用任何特定的东西，Quartz会执行任务并结束任务。如果配置作业在随后再次被调用，Quartz框架也将在恰当的时间再次调用它。
Quartz的内部架构大约包含300个Java类和接口，并被组织到12个包中。尽管规模几乎不会用来作为衡量框架质量的一个特性，但这里的关键是quartz内含很多功能，这些功能和特性集是否成为、或者应该成为评判一个开源或非开源框架质量的因素。
Quartz的用法 1. 添加Quartz依赖
首先需要在项目中添加Quartz的依赖。如果你使用Maven，可以在pom.xml文件中添加以下依赖：
&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57d49c71f7b8c2239f275af3d26309d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be3cac014846f3a0c8236c0a1b2768a8/" rel="bookmark">
			个人Windows电脑通过Cloudreve&#43;Cpolar搭建PHP云盘系统公网可访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、前言2、本地网站搭建2.1 环境使用2.2 支持组件选择2.3 网页安装2.4 测试和使用2.5 问题解决 3、本地网页发布3.1 cpolar云端设置3.2 cpolar本地设置 4、公网访问测试5、结语 1、前言 自云存储概念兴起已经有段时间了，各互联网大厂也纷纷加入战局，一时间公有云盘遍地开花。但一段时间后，公有云盘潜在的安全问题也暴露出来，原有的共有云盘用户纷纷转为搭建私有云盘，也带动了群晖等一众私有云盘供应商的发展。可群晖硬件动辄数千，让个人消费者难以招架，是否能将个人电脑改造为私有云盘呢？答案自然是肯定的，今天我们就为大家介绍，如何使用Cpolar与Cloudreve，在个人Windows电脑上搭建一个强大的PHP云盘系统。
2、本地网站搭建 2.1 环境使用 Cloudreve是一个网页程序，由于其运行在本地电脑上，因此需要一个虚拟运行环境，这里我们使用的是PHPStudy这款软件。由于PHPStudy是独立软件，因此只需要在PHPStudy下载完成后，双击安装包内的安装程序，依照软件提示即可完成安装。
2.2 支持组件选择 与常见的网页程序一样，Cloudreve也是以PHP为基础，加上其文件传输功能，因此需要PHP、MySQL、Nginx、FTP、FileZilla、SQL-Front几个程序的支持。好在PHPStudy提供了这些支持软件的安装，省去了我们不少麻烦。
2.3 网页安装 在PHPStudy软件准备好后，我们就可以开始安装Cloudreve网页。在Cloudreve官网下载网页包（官网网页被挂在GitHub，网页打不开常态，可以从其他渠道下载）
网页压缩包下载完毕后，将Cloudreve压缩包解压至PHPStudy的WWW文件夹下，作为网页的根目录。本例中PHPStudy安装在D盘下，因此路径为此电脑 – D盘 – PHPStudy pro – WWW。
接着返回PHPStudy主界面的“网站”页面，点击该页面左上角的“创建网站”，开始对Cloudreve网页运行环境进行设置。
在“创建网站”页面，我们需要对网站运行环境进行几项基本设置，包括：
域名：本地访问网站的域名；端口：本地网页的输出端口号；根目录：即网页文件存放的路径，可以通过栏位右侧的“浏览”按钮进行选择；创建FTP和数据库：勾选这两项会弹出新窗口进行设置，设置内容主要为用户名、密码、名称几项；PHP版本：通常这项不必单独选择，PHPStudy会自动选择较高版本，但为避免安装后网站打开错误，最好选择7.2X版本的PHP。 在完成各项设置后，就可以点击页面下方的“确认”按钮，将这些配置保存下来。接着在浏览器地址栏中输入(localhost:80/cloudreveinstaller)，进入网页安装程序。在这一步，Cloudreve会对运行环境和支持功能进行检查，只有必要项目自检通过，才能进行下一步部署。
下一步安装工作，主要是对数据库信息进行填写，我们只需要依照之前设定的数据库信息填入即可。
设置完数据库信息后，点击页面下方的“开始安装”，只需等待很短时间，Cloudreve就能安装完成。在网页安装完成页面，会给出Cloudreve后台地址、管理员登录信息和安全注意事项。
2.4 测试和使用 接着我们在浏览器地址栏中输入localhost:80（端口号需要根据实际设定输入，在这个例子中，我们使用的端口号为80），就能使用本地电脑上的Cloudreve网盘系统。
2.5 问题解决 在Cloudreve安装过程中，最容易出的一个问题，就是环境检查中URL Rewrite项目错误，这个问题解决方法也很简单，只要对网页进行伪静态设置即可。
首先我们打开PHPStudy，在Cloudreve网站条目右侧，点击“管理”选项，从中找到“伪静态”按钮，点击进入伪静态设置页面。
在伪静态设置框内，输入以下命令：
location / { if (!-e $request_filename) { rewrite ^(.*)$ /index.php?s=/$1 last; break; } } 输入完成后，点击下方的“确认”进行保存，再刷新一次安装页面，就能看到原本报错的URL Rewrite项目已经通过检查，我们就能继续进行下一步安装。
3、本地网页发布 3.1 cpolar云端设置 在Cloudreve网页安装完成后，我们就可以着手将位于本地电脑上的Cloudreve云盘，通过Cpolar创建的内网穿透数据隧道，将这个云盘发布到公共互联网上，在限定范围内接受注册用户（或分发已注册用户信息）访问该云盘。首先访问cpolar的官网，在官网页面，能找到cpolar客户端的下载按钮，我们可以先将cpolar下载至本地，等到对数据隧道关联本地网站时再进行安装。
Cpolar客户端下载完成后，先不着急离开官网页面，我们需要在官网页面预留一条空白数据隧道，用以承载本地Cloudreve。在以用户登录cpolar官网后，在“仪表盘”页面左侧点击“预留”按钮，进入cpolar云端空白数据隧道的预留设置页面。
在这个页面，我们可以选择预留“二级子域名”、“自定义域名”、“TCP地址”、“FTP地址”等多个项目（需要注意的是，云端保留各种数据隧道为高级功能，需要将cpolar升级至基础版及以上才能使用），对于Cloudreve网页来说，我们可选择“保留二级子域名”或“保留自定义域名”。其中“保留自定义域名”需要从域名供应商处购买域名，并对CNAME进行设置，为避免混淆，我们以“保留二级子域名”进行演示。
在“保留二级子域名”栏位，我们需要对拟保留的二级子域名进行简单设置，设置内容包括：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be3cac014846f3a0c8236c0a1b2768a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47b755d0626aa33d36f718e264d7b6ca/" rel="bookmark">
			Redis下载安装教程（详细步骤）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先来介绍一下什么是Redis
Redis是一个开源的、高性能的键值存储系统，支持多种数据结构，包括字符串、哈希表、列表、集合、有序集合。它采用C语言编写，主要特点是速度快、使用简单、可靠性高、支持数据持久化、支持主从复制等功能。
Redis 是完全开源免费的，遵守BSD协议，高性能的基于键值对（key-value）的NoSQL（Not Only SQL）数据库。
Redis被广泛应用于缓存、队列、数据存储和消息传递等场景，是当前最受欢迎的NoSQL数据存储之一。
SQL (Struct Query Lanauge 结构化的查询语言) 。引申含义 RDBMS产品，传统的关系型数据库，存储格式化的表格数据。NOSQL (Not Only SQL )不仅仅只有关系型数据库。引申含义：非关系型数据库。存储半格式化和非格式化的数据，如k-v、json、xml 关系型数据库的特点 存储结构化数据：多行多列的表结构数据。强事务：支持完整的ACID事务特性。在磁盘中存储数据：可通过索引加速检索。数据量到达一定量级，查询性能就会出现瓶颈：根据表字段不同，在百万或者千万级时会遇到。支持SQL：大部分的SQL语句都可以跨越数据库。原生不支持分布式：需要借助第3方中间件分库分表，以应对海量存储需求。 Redis的特点 存储非结构化的数据：k-v方式存储数据。弱事务：支持事务的部分特性。在内存中存储数据，但能同时持久化数据到磁盘。查询性能非常好，但不支持连接查询。不支持SQL，需要使用特定的命令。天然支持集群、数据分片，扩展容易。 Redis就是一个在内存中，存储k-v格式数据，支持自动持久化的NoSQL型数据库。
Redis开发中的应用 典型应用：
在一定程度上代替关系型数据库，保存需要持久化，但对事务要求不高的数据：购物车充当应用中的缓存，Redis查询性能非常好，可支持的并发远高于关系型数据库。可以优先从Redis中查询数据，缓存为命中后，再从数据库中查询并缓存数据到Redis中，以提升程序性能。Redis提供了丰富的数据类型，可以解决关系型数据库不方便解决的问题，比如：排行榜（热度、时间等维度）、计数器（播放量、浏览数）、社交网络（赞\踩、粉丝、共同好友）解决分布式系统带来的新问题，比如对tomcat集群的session进行统一的存储管理。 说明：Redis并不是万金油，有很多适合它解决的问题，但是也有很多不合适它解决的问题。
从数据规模的角度上看，数据可以分为大规模数据小规模数据，Redis的数据是存放在内存中的，虽然现在内存已经足够便宜，但是如果数据量非常大，例如每天有几亿的用户行为数据，使用Redis来存储的话，基本上是个无底洞，经济成本相当的高。从数据冷热的角度上看，数据分为热数据和冷数据。热数据通常是指需要频繁操作的数据，反之为冷数据。如果将这些冷数据放在Redis中，基本上是对于内存的一种浪费，但是对于一些热数据可以放在Redis中加速读写，也可以减轻后端存储的负载，可以说是事半功倍。 接下来就是重点了，Redis要如何安装以及打开它并运行使用呢
Redis的安装使用 博主本人在这里是在Centos7环境下安装的Redis
上传 redis-5.x.x.tar.gz 到linux虚拟机的 /opt 文件夹
下载链接:链接：https://pan.baidu.com/s/1DbDvG0RTdbU7NigSPipOjg
提取码：b8p5
安装gcc（上面提到了Redis是采用C语言编写的）
[root@localhost ~]# yum install -y gcc 解压缩 redis-5.x.x.tar.gz [root@localhost opt]# tar xzvf redis-5.0.10.tar.gz 进入到redis根目录，进行编译、安装
（注意在这里最好是先编译在安装这样子绝对不会出什么问题，如果make &amp;&amp; make install 可能会安装失败） [root@localhost opt]# cd redis-5.0.10 [root@localhost redis-5.0.10]# make [root@localhost redis-5.0.10]# make install （进行到这里就安装完毕了Redis可以直接跳到第6步运行了）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47b755d0626aa33d36f718e264d7b6ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5bbeb32157ad13dc84dff05613ab6b8/" rel="bookmark">
			掌握排序的艺术：Python中sorted()函数全面解析！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更多资料获取 📚 个人网站：ipengtao.com
1. 引言 排序在编程中是一个基本且重要的操作，而 Python 中的 sorted() 函数则为我们提供了强大的排序能力。在本篇文章中，我们将深入研究不同排序算法、sorted() 函数的灵活性，以及各种排序场景下的最佳实践。
2. 排序算法概述 冒泡排序 冒泡排序是一种简单的排序算法，通过多次遍历比较相邻元素并交换来实现排序。以下是一个冒泡排序的例子：
# 冒泡排序示例代码 def bubble_sort(arr): n = len(arr) for i in range(n): for j in range(0, n - i - 1): if arr[j] &gt; arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] return arr arr = [64, 34, 25, 12, 22, 11, 90] sorted_arr = bubble_sort(arr) print("冒泡排序结果:", sorted_arr) 插入排序 插入排序通过构建有序序列，逐个将未排序的元素插入到已排序序列的适当位置来排序。以下是一个插入排序的例子：
# 插入排序示例代码 def insertion_sort(arr): for i in range(1, len(arr)): key = arr[i] j = i - 1 while j &gt;= 0 and key &lt; arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr arr = [64, 34, 25, 12, 22, 11, 90] sorted_arr = insertion_sort(arr) print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5bbeb32157ad13dc84dff05613ab6b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b312622aa9434c277116b63d625309f/" rel="bookmark">
			MySQL查询语句大全（基础查询、函数使用、高级查询）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、基础查询1.1、直接查询1.2、为字段取别名1.3、去重查询1.4、条件查询1.5、模糊查询1.6、逻辑运算符1.7、in与not in运算符1.8、算术运算符1.9、between and的范围查询1.10、排序查询1.11、分组查询1.12、分页查询 二、函数使用2.1、统计函数2.2、字符串函数2.2.1、CONCAT（拼接内容）2.2.2、REPLACE / INSERT（字符串替换）2.2.3、LOWER（指定内容转换为小写）2.2.4、UPPER（指定内容转换为大写）2.2.5、SUBSTRING（指定内容截取）2.2.6、CAST / CONVERT （将字符串数字转换成数字类型） 2.3、时间函数2.3.1、获取时间相关函数2.3.2、将数字类型时间戳转换成时间格式2.3.3、将字符串时间转换成数字时间戳 2.4、取整、取小数、取模函数2.4.1、向上取整2.4.2、向下取整2.4.3、不四舍五入取整、取小数2.4.4、四舍五入取整、取小数2.4.5、取模 2.5、特殊函数（例如获取随机数）2.5.1、获取随机数2.5.2、判断正负 三、高级查询3.1 内连接3.2 左连接3.3 右连接3.4 union 拼接结果集（不包含重复行）3.5 union all 拼接结果集（包含重复行） 一、基础查询 1.1、直接查询 # 语法：select 字段 from 表名； # 举例： 从 student 表中查询 name 与 age select name, age from student; 1.2、为字段取别名 # 语法：select 字段 as 别名 from 表名； # 举例： 从 student 表中查询 name 与 age select name as 'myName', age as 'myAge' from student; 1.3、去重查询 # 语法：select distinct 字段 from 表名； # 举例： 从 student 表中查询 name 并且将结果去重 select distinct name from student; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b312622aa9434c277116b63d625309f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3e5126716cc8a970faaae0eb3f21277/" rel="bookmark">
			Java_JDK8到JDK21各版本发行时间及重要特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java_JDK8到JDK21各版本发行时间及重要特性 背景JDK8新特性(2014年3月)JDK9新特性（2017年9月）JDK10新特性（2018年3月）JDK11新特性（2018年9月）（LTS版本）JDK12新特性（2019年3月）JDK13新特性（2019年9月）JDK14新特性（2020年3月）JDK15新特性（2020年9月）JDK16新特性（2021年3月）JDK17新特性（2021年9月）（LTS版本）JDK18新特性（2022年3月）JDK19新特性（2022年10月）JDK20新特性（2023年3月）JDK21新特性（2023年9月）（LTS版本） 背景 2022年Spring6和SpringBoot3相继推出，在此之前，Java社区一直是"新版任你发，我用Java 8"，不管新版本怎么出，很少有人愿意升级。
这一次，Spring 直接来了个大招，SpringBoot3和Spring6的最低依赖就是JDK17！跨过 JDK 8-16，直接升级到 JDK 17。那么为什么是 JDK 17呢？
为什么是JDK17这么多新版本的 JDK，而且2022年还会推出 JDK 18 和 JDK 19，为什么 Spring 选择了 JDK 17呢。
主要是因为他是一个 Oracle官宣可以免费商用的LTS版本，所谓 LTS，是 Long Term Support，也就是官方保证会长期支持的版本。
JDK 17 最多可以支持到 2029 年 9 月份。按照技术更新迭代的速度，这次免费商用 8 年可谓是良苦用心，为的就是让使用者放心大胆地将 JDK 升级到 JDK 17(不过JDK 8 支持的时间更长，可以延长到 2030 年 12 月,JDK8可谓是YYDS！)
从 JDK 诞生到现在，还在长期支持的版本主要有 JDK 7、JDK 8 、JDK 11以及 JDK 1，JDK 17 将是继 Java 8 以来最重要的LTS版本，是 Java 社区八年努力的成果。
一直以来，Java8 都是 Java 社区心头的痛，Java8提供了很多特性，比如Lambda 表达式、Optional 类，加上Java8超长的支持时间，都导致了JDK8的使用至今。它代表着以稳定性为主的企业管理层与拥抱变化为主的程序猿之间的拉锯战。不升！成为各大厂心照不宣的选择。现在，这种平衡或将打破。因为 Java 届的霸主框架 SpringBoot，选择了最小支持的 Java lts 版本，就是最新的 Java17。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3e5126716cc8a970faaae0eb3f21277/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/624a4e94c2a81967f25e3e338e48fc64/" rel="bookmark">
			【文末送书】Python OpenCV从入门到精通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🍔简介opencv🌹内容简介🛸编辑推荐🎄导读🌺彩蛋 🍔简介opencv OpenCV（Open Source Computer Vision Library）是一个开源的计算机视觉库，提供了丰富的图像处理和计算机视觉算法。它由一组用C++编写的函数和工具组成，同时也支持多种编程语言，如Python、Java等。
OpenCV的主要特点包括：
跨平台性：OpenCV可以在多个操作系统上运行，包括Windows、Linux、macOS等。多功能性：OpenCV提供了丰富的图像和视频处理功能，包括图像读取和保存、图像变换、滤波、边缘检测、特征提取、目标检测、图像匹配等。高效性：OpenCV的算法经过优化，能够高效地处理大规模的图像和视频数据。开放性：OpenCV是一个开源项目，用户可以查看和修改其源代码，以满足自己的需求。 OpenCV广泛应用于计算机视觉相关领域，如人脸识别、车牌识别、物体跟踪、图像分割、图像拼接等。同时，OpenCV还提供了与其他库和工具的接口，如深度学习框架（如TensorFlow、PyTorch）、图像处理软件（如Adobe Photoshop）等，方便用户进行综合应用。
总之，OpenCV是一个功能强大、易用且高度可定制的计算机视觉库，为开发者提供了丰富的图像处理和计算机视觉算法，助力他们在各种应用中实现图像分析和处理的任务。
京东购买链接：https://item.jd.com/13409660.html
🌹内容简介 《Python OpenCV从入门到精通》以在Python开发环境下运用OpenCV处理图像为主线，全面介绍OpenCV提供的处理图像的方法。全书共分为16章，包括Python与OpenCV、搭建开发环境、图像处理的基本操作、像素的操作、色彩空间与通道、绘制图形和文字、图像的几何变换、图像的阈值处理、图像的运算、模板匹配、滤波器、腐蚀与膨胀、图形检测、视频处理、人脸检测和人脸识别以及MR智能视频打卡系统。本书图文丰富，直观呈现处理后的图像与原图之间的差异；在讲解OpenCV提供的方法时，列举了其中的必选参数和可选参数，读者能更快地掌握方法的语法格式；最后一章以MR智能视频打卡系统为例，指导读者系统地运用OpenCV解决工作中的实际问题。本书专注于图像处理本身，尽可能忽略图像处理算法的具体实现细节，降低阅读和学习的难度，有助于读者更好更快地达到入门的目的。此外，本书资源包中提供了完整的示例源码、要使用到的图像等配套学习资源。
🛸编辑推荐 适读人群 ：如果读者有Python基础，想系统学习OpenCV，那么本书对于你来说是不错的选择。
《Python OpenCV从入门到精通》以入门为主、进阶为辅，提供了从Python OpenCV入门到编程高手所必需的各项知识。
（1）主流技术，全面解析。本书内容丰富，涵盖OpenCV图像处理技术的方方面面，包括图像的几何变换、阈值处理、图像运算、模板匹配、滤波器、腐蚀与膨胀、图形检测、视频处理、人脸检测和人脸识别等。一本书教你掌握计算机视觉开发领域的主流核心技术。
（2）由浅入深，循序渐进。本书引领读者按照基础入门→核心框架→项目实战循序渐进地学习，符合认知规律。
（3）边学边练，学以致用。130个应用实例+1个行业项目案例+136集Python零基础扫盲课，边学边练，在实践中提升技能。
（4）精彩栏目，贴心提醒。本书设置了很多“注意”“说明”“技巧”等小栏目，有利于读者在学习过程中更轻松地理解相关知识点及概念，并轻松地掌握个别技术的应用技巧。
（5）在线解答，高效学习。在线答疑QQ及技术支持网站，不定期进行在线直播课程。
🎄导读 适读人群 ：如果读者有Python基础，想系统学习OpenCV，那么本书对于你来说是不错的选择。
《Python OpenCV从入门到精通》以入门为主、进阶为辅，提供了从Python OpenCV入门到编程高手所必需的各项知识。
（1）主流技术，全面解析。本书内容丰富，涵盖OpenCV图像处理技术的方方面面，包括图像的几何变换、阈值处理、图像运算、模板匹配、滤波器、腐蚀与膨胀、图形检测、视频处理、人脸检测和人脸识别等。一本书教你掌握计算机视觉开发领域的主流核心技术。
（2）由浅入深，循序渐进。本书引领读者按照基础入门→核心框架→项目实战循序渐进地学习，符合认知规律。
（3）边学边练，学以致用。130个应用实例+1个行业项目案例+136集Python零基础扫盲课，边学边练，在实践中提升技能。
（4）精彩栏目，贴心提醒。本书设置了很多“注意”“说明”“技巧”等小栏目，有利于读者在学习过程中更轻松地理解相关知识点及概念，并轻松地掌握个别技术的应用技巧。
（5）在线解答，高效学习。在线答疑QQ及技术支持网站，不定期进行在线直播课程。
🌺彩蛋 ⭐ 《Python OpenCV从入门到精通》免费包邮送2 ~ 3本！
⭐活动时间：截止到 2023-12-10 20:00:00
⭐ 抽奖方式：利用程序进行抽奖。
⭐参与方式：关注博主、点赞、收藏、评论区进行高质量评论（不少于10个字），即可参加抽奖活动
⭐本次活动一共赠2 ~ 3本，评论区抽取2~ 3位小伙伴免费送出！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e3bad6bd937026f53ae8a7bf77c21cd/" rel="bookmark">
			【头歌-Python】Python第一章作业（初级）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1关：浮点数四则运算与格式化输出 任务描述示例 任务描述 Python 可以方便的实现计算器的功能。数学意义上的加、减、乘、除在Python中分别以符号“+、-、*、/”表示。
试编程实现分两行输入两个非零浮点数，并在4 行中按顺序输出两个数的加、减、乘、除的计算式和计算结果。计算结果str.format()方法严格保留小数点后3位数字。要求输出与如下示例格式相同，符号前后各有一个空格。
浮点数1 + 浮点数2 = 和 浮点数1 - 浮点数2 = 差 浮点数1 * 浮点数2 = 积 浮点数1 / 浮点数2 = 商
示例 输入:
2.66
3.1415926
输出:
2.66 + 3.1415926 = 5.802
2.66 - 3.1415926 = -0.482
2.66 * 3.1415926 = 8.357
2.66 / 3.1415926 = 0.847
参考代码 a=float(input()) b=float(input()) print("{} + {} = {:.3f}".format(a,b,a+b)) print("{} - {} = {:.3f}".format(a,b,a-b)) print("{} * {} = {:.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e3bad6bd937026f53ae8a7bf77c21cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/311a9f69fd7ba13e59df75b0c0279548/" rel="bookmark">
			Python自动化报错：The chromedriver version (114.0.5735.90) detected in PATH at D:\Python\Scripts\chromedri
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 报错信息为：The chromedriver version (114.0.5735.90) detected in PATH at D:\Python\Scripts\chromedriver.exe might not be compatible with the detected chrome version (119.0.6045.200); currently, chromedriver 119.0.6045.105 is recommended for chrome 119.*, so it is advised to delete the driver in PATH and retry 如下：
今早运行selenium程序，突然报这个错误，我也不知道是什么原因，毕竟昨天运行这个程序是可以正常打开当前谷歌浏览器的。看错误信息，说是因为谷歌浏览器和谷歌驱动程序的版本不一致，可是，我的两个版本都是119.啊！如下：
仔细查看报错信息，终于找到报错根源所在，说在Scripts下的谷歌驱动程序与谷歌浏览器的版本不一致。
2. 解决方案 删除Scripts目录下的谷歌驱动程序，如下：
删掉之后就可以正常运行程序了。我也不知道什么原因我的这个目录下会多出一个谷歌驱动程序。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e047a584a696f5a758534f7be913e694/" rel="bookmark">
			前端：JS：将图片转为二进制与其他文本传入后端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前端，可以将图片转换为二进制数据，并将其与其他文本字符串一起发送到后端。一种常见的方法是将所有数据组合为一个 FormData 对象，然后通过 AJAX 或 Fetch API 将其发送给后端。以下是一个示例：
// 获取文件输入框和其他文本输入框 const fileInput = document.getElementById('fileInput'); const textInput = document.getElementById('textInput'); // 监听文件输入框的 change 事件 fileInput.addEventListener('change', function () { // 获取选中的文件 const file = fileInput.files[0]; if (file) { // 创建 FileReader 对象 const reader = new FileReader(); // 监听读取完成事件 reader.onloadend = function () { // 读取完成后，reader.result 包含转换后的二进制数据 const binaryData = reader.result; // 创建 FormData 对象 const formData = new FormData(); // 将二进制数据和其他文本添加到 FormData formData.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e047a584a696f5a758534f7be913e694/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2eacc7cb22b6100fd50ff39286580e1/" rel="bookmark">
			Android 手机的高级终端 Termux 安装使用、busybox、安卓 手机 web
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		From：https://www.sqlsec.com/2018/05/termux.html
Termux 高级终端安装使用配置教程 ：https://www.cnblogs.com/cutesnow/p/11430833.html
神器Termux 的使用记录：https://cloud.tencent.com/developer/article/1609398
​adb shell 下使用 termux：https://github.com/alwaystest/blog/issues/68
ttyd — ( 通过 web 共享、访问 终端 )：https://github.com/tsl0922/ttyd
安卓手机安装web环境搭建个人网站-免root：https://zhuanlan.zhihu.com/p/127076419
KSWeb是一款Android手机上的Web服务器软件，可以在手机上搭建一个Web服务器，使用MySQL 服务，找到 mysql 然后单击 “配置文件”按钮。在文本编辑器中打开配置文件，找到“bind-address”行，并将其注释掉（在行前加上“#”号）。保存并关闭配置文件。打开 MySQL客户端工具（如MySQL Workbench），在连接设置中输入以下信息：主机名：127.0.0.1，端口号：3306，用户名：root，密码：默认为空，然后单击“连接”按钮，连接到MySQL数据库。如果连接成功，则您可以开始使用MySQL数据了。
phpMyAdmin 是一个以PHP为基础，以Web-Base方式架构在网站主机上的MySQL的数据库管理工具，让管理者可用Web接口管理MySQL数据库。由此 Web 接口可以成为一个简易方式输入繁杂 SQL 语法的较佳途径，尤其要处理大量资料的汇入及汇出更为方便。
可以看到 root 只能本地访问，想要远程访问，需要 mysql 中执行
use mysql;
update user set host =‘%’ where user =‘root’;
GRANT ALL PRIVILEGES ON *.* TO ‘root’@‘%’ IDENTIFIED BY ‘youpassword’ WITH GRANT OPTION;
my.ini中添加
[mysqld]
skip-grant-tables
​busybox ( 嵌入式 Linux 的瑞士军刀 )：https://github.com/mirror/busybox
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2eacc7cb22b6100fd50ff39286580e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/676a3038cfeace1e473f02cf67802ab0/" rel="bookmark">
			头歌—Hive的安装与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1关：Hive的安装与配置 在修改 conf 下面的hive-site.xml文件这里，题目给的信息是错误的，正确的内容如下：
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt; &lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt; &lt;configuration&gt; &lt;!-- WARNING!!! This file is auto generated for documentation purposes ONLY! --&gt; &lt;!-- WARNING!!! Any changes you make to this file will be ignored by Hive. --&gt; &lt;!-- WARNING!!! You must make your changes in hive-site.xml instead. --&gt; &lt;!-- Hive Execution Parameters --&gt; &lt;property&gt; &lt;name&gt;hive.metastore.warehouse.dir&lt;/name&gt; &lt;value&gt;/opt/hive/warehouse&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.exec.scratchdir&lt;/name&gt; &lt;value&gt;/opt/hive/tmp&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.querylog.location&lt;/name&gt; &lt;value&gt;/opt/hive/logs&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.server2.thrift.port&lt;/name&gt; &lt;value&gt;10000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/676a3038cfeace1e473f02cf67802ab0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2f34a434fb651b02cda7664bdfd8601/" rel="bookmark">
			Python读取二进制文件：深入解析与技术实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、引言
二、二进制文件的基础
1、二进制文件的组成
2、二进制文件的编码
三、Python读取二进制文件的方法
1、使用内置函数open()
2、使用numpy库
四、处理读取的二进制数据
1、解析数据
2. 转换数据类型
五、总结与展望
1、高效读取二进制文件
2、处理复杂的二进制文件格式
3、二进制数据处理的应用拓展
一、引言 在编程中，二进制文件的处理是常见的任务之一。二进制文件包括图像、音频、视频、可执行文件等，这些文件通常以二进制格式存储。Python作为一种强大的编程语言，提供了丰富的库和工具来读取和处理二进制文件。本文将深入解析Python读取二进制文件的方法，并提供技术实现和实例。
二、二进制文件的基础 1、二进制文件的组成 二进制文件由字节组成，每个字节包含8位二进制数。字节是二进制文件的基本单位，用于存储各种类型的数据，如整数、浮点数、字符等。
2、二进制文件的编码 二进制文件的编码方式有多种，如ASCII、UTF-8、GBK等。在读取二进制文件时，需要知道文件的编码方式，以便正确解析文件内容。
三、Python读取二进制文件的方法 Python提供了几种读取二进制文件的方法，包括使用内置函数和标准库。以下是几种常用的方法：
1、使用内置函数open() open()函数是Python中用于打开文件的内置函数。它可以以二进制模式打开文件，然后使用read()方法读取文件内容。示例如下：
with open('file.bin', 'rb') as f: data = f.read() 在上述代码中，'file.bin'是要读取的二进制文件名，'rb'是以二进制模式打开文件的标志。read()方法将读取整个文件内容，并将其作为字节对象返回。
2、使用numpy库 numpy是Python中用于科学计算的库，它提供了读取二进制文件的功能。numpy.fromfile()函数可以从二进制文件中读取数据，并将其转换为numpy数组。示例如下：
import numpy as np data = np.fromfile('file.bin', dtype=np.float32) 在上述代码中，'file.bin'是要读取的二进制文件名，dtype参数指定了数组中元素的数据类型。np.float32表示数组中的元素是32位浮点数。fromfile()函数将读取整个文件内容，并将其转换为numpy数组。
四、处理读取的二进制数据 读取二进制数据后，可能需要进行一些处理，如解析数据、转换数据类型等。以下是一些常用的处理方法：
1、解析数据 解析数据是指从二进制数据中提取有用的信息。这通常需要根据数据的结构和格式进行。例如，如果二进制数据表示图像，可能需要解析图像的宽度、高度、像素值等信息。这可以通过使用Python的结构体（struct）模块来实现。结构体模块可以将二进制数据解析为Python中的数据结构，如元组、列表等。示例如下：
import struct with open('image.bin', 'rb') as f: # 假设图像数据的格式为：宽度（4字节）、高度（4字节）、像素值（每个像素3字节） width, = struct.unpack('i', f.read(4)) # 读取宽度 height, = struct.unpack('i', f.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2f34a434fb651b02cda7664bdfd8601/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/558/">«</a>
	<span class="pagination__item pagination__item--current">559/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/560/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>