<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b946f61ef0025f64be93e63353157d11/" rel="bookmark">
			linux恶意IP溯源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Linux系统中，如果你怀疑某台机器可能与一个恶意IP（如96.66.15.152）有通信，可以通过以下几个步骤进行溯源和调查：
一、查看网络连接： 使用netstat或ss命令来检查当前的网络连接。命令如下：
netstat -antp | grep 96.66.15.152 ss -antp | grep 96.66.15.152 这两个命令都可以用来查找与指定IP地址相关的所有网络连接。-antp选项的意思是列出所有（a）当前的网络连接，不限制网络协议（n），并显示监听状态的（t）TCP连接以及相关进程信息（p）。
二、检查日志文件： 查找系统和应用程序的日志文件，可以帮助你理解某一时间点系统的网络活动情况。尤其是/var/log/目录下的日志，如/var/log/syslog，/var/log/messages，/var/log/secure或特定服务的日志，例如Apache的/var/log/apache2/access.log（或对应您使用的web服务器日志），可以提供有用的信息。例如，你可以使用grep命令搜索日志：
grep -r "96.66.15.152" /var/log/ 三、使用Wireshark或tcpdump： 如果可疑通信仍在进行中，你可以使用tcpdump或Wireshark等工具实时捕获与恶意IP的数据包。例如，使用tcpdump：
tcpdump ip host 96.66.15.152 这会显示所有发送到或来自该IP地址的数据包。请注意，你可能需要相应的权限（通常是root权限）来运行这些命令。
四、查看防火墙日志： 如果你的系统使用防火墙（如iptables或firewalld），检查防火墙日志也能提供与恶意IP通信的线索。防火墙可能已经记录了尝试连接的尝试或阻止的连接。
五、恶意软件扫描： 使用恶意软件扫描工具（如ClamAV）对系统进行扫描，确保没有被恶意软件感染，可能是恶意IP通信的原因之一。
进行以上检查后，应该能够确认是否真的与指定的恶意IP有通信，并得到一些关于通信性质的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e55c146689fd69a874ec410ba4a23e72/" rel="bookmark">
			微软将于 2024 下半年开始淘汰 VBScript
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微软将于 2024 下半年开始淘汰 VBScript 微软宣布将从 2024 年下半年开始弃用 VBScript，使其成为一项按需功能 (Features on Demand，FOD)，直至完全删除。
按需功能是 Windows 操作系统中的可选功能，如 .NET Framework（.NetFx3）、Hyper-V 和 Windows Subsystem for Linux，这些功能默认情况下不会安装，但可以在必要时随时添加。
VBScript VBScript 即 Visual Basic Scripting Edition，是微软于 1996 年首次推出的一种轻量级脚本语言。该语言已作为 Windows 操作系统中的系统组件提供，并已广泛用于自动执行任务和控制基于 Windows 的系统上的应用程序。它通常嵌入在 HTML 页面中，以向网页添加动态交互性和功能，并且通常与 Microsoft 技术（如 Active Server Pages (ASP) 和 Windows Script Host (WSH)）结合使用。
但微软方面认为，如今随着技术的进步，已经有了更多现代和高效的选项。“为了向您提供最现代、最高效的选项，我们正在用更高级的替代方案（如 JavaScript 和 PowerShell）替换 VBScript。”
弃用 VBScript 的计划 微软制定了一个分阶段弃用 VBScript 的计划，将分三个阶段进行：
第一阶段将于 2024 年下半年开始，VBScript 将作为可选功能在 Windows 11 24H2 中默认启用。
第二阶段将于 2027 年左右开始，VBScript 仍将作为按需功能提供，但不再默认启用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e55c146689fd69a874ec410ba4a23e72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/398655aeb9a51ddcacbfaaf5ca9713c1/" rel="bookmark">
			【设计模式】JAVA Design Patterns——Observer（观察者模式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔍目的 定义一种一对多的对象依赖关系这样当一个对象改变状态时，所有依赖它的对象都将自动通知或更新。
🔍解释 真实世界例子 在遥远的土地上生活着霍比特人和兽人的种族。他们都是户外生活的人所以他们密切关注天气的变化。可以说他们不断地关注着天气。
通俗描述 注册成为一个观察者以接收对象状态的改变。
维基百科 观察者模式是这样的一种软件设计模式：它有一个被称为主题的对象，维护着一个所有依赖于它的依赖者清单，也就是观察者清单，当主题的状态发生改变时，主题通常会调用观察者的方法来自动通知观察者们。
编程示例 首先创建天气观察者的接口以及我们的种族，兽人和霍比特人。
public interface WeatherObserver { void update(WeatherType currentWeather); } @Slf4j public class Orcs implements WeatherObserver { @Override public void update(WeatherType currentWeather) { LOGGER.info("The orcs are facing " + currentWeather.getDescription() + " weather now"); } } @Slf4j public class Hobbits implements WeatherObserver { @Override public void update(WeatherType currentWeather) { switch (currentWeather) { LOGGER.info("The hobbits are facing " + currentWeather.getDescription() + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/398655aeb9a51ddcacbfaaf5ca9713c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/280b2b82c58e78cd1784955b37b7cae2/" rel="bookmark">
			揭秘大数据时代的数据库存储引擎：关系型、NoSQL与NewSQL如何选择？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 01 关系型数据库&amp;NoSQL数据库&amp;NewSQL数据库1. 关系型数据库2. NoSQL数据库3. NewSQL数据库 02 OLTP&amp;OLAP&amp;HTAP对比1. OLTP数据库2. OLAP数据库3. HTAP数据库 03 总结 在大数据和AI时代，数据库成为各类应用不可或缺的重要组成部分。而数据库中的数据依赖存储引擎进行管理，包括数据的存储、查询、更新和删除等。因此，在设计系统时，选择正确的数据库存储引擎方案变得尤为重要。这篇文章将以关系型、NoSQL和NewSQL数据库，以及OLTP、OLAP和HTAP处理方式为切入点，深入探讨不同类型的数据库背后的存储引擎方案选型取舍。
作者：文小飞
01 关系型数据库&amp;NoSQL数据库&amp;NewSQL数据库 下图展示了关系型数据库、NoSQL数据库、NewSQL数据库的发展过程。
1. 关系型数据库 关系型数据库也称为SQL数据库，最早的数据库发展可以追溯至1970年IBM研发的第一个SQL数据库System R，这也是最早的SQL数据库，再后来1980～1990年这段时间涌现出来了一些SQL数据库产品，例如Oracle、DB2、SQL Server、PostgreSQL、MySQL等。
到2000年左右，关系型数据库越来越丰富，出现了很多迄今一直在发挥重要的组件，例如MySQL、Oracle等。
SQL数据库按照以“行”为单位的二维表格存储数据，这种方式最符合现实世界中的实体，同时通过事务的支持为数据的一致性提供了非常强的保证。因此SQL数据库主要适合的场景是读多写少的场景。
关系型数据库中为了适配不同的应用场景，通常会将存储引擎设计为插件式的接口。然而主流的存储引擎，仍然是读多写少的特点。以MySQL为例，InnoDB存储引擎被广泛运用，它通过B+树来存储索引和数据。B+树这种数据结构，由于其独特的特性使得查询的性能非常高。
B+树存储引擎适用于需要高效的数据查找、范围查询和顺序访问的场景。它在关系型数据库中被广泛应用，如MySQL的InnoDB存储引擎和Oracle的B+树索引。然而，B+树存储引擎对于频繁的数据插入和删除操作可能会有一定的开销，因为这会触发节点的分裂和合并操作。
2. NoSQL数据库 在面对海量数据存储、高并发访问的场景下，关系型数据库的扩展性和性能会受到限制。随着互联网的飞速发展，到2000年左右，存储海量数据、高并发处理读写的需求变得非常明显。这对SQL数据库提出了巨大挑战。为了解决这个问题，出现了支持数据可扩展性、最终一致性的NoSQL数据库。因此，NoSQL数据库可以看作是基于SQL数据库的缺陷而诞生的一种新产品。
NoSQL组件普遍选择牺牲复杂SQL的支持及ACID事务功能，以换取弹性扩展能力和更高的读写性能。这类系统主要存储半结构化或非结构化数据。根据存储的数据种类，NoSQL数据库主要分为基于文档存储的文档数据库（Document-based Database）、基于键-值存储的键值数据库（Key-Value Database）、图数据库（Graph-based Database）、时序数据库（Time Series Datebase）、宽列式存储（Wide Column-based Store）以及多模数据库（Multi-Model Database）。
不同类型的NoSQL数据库特性如下图所示。
NoSQL数据库典型的特点是具备很高的读写性能，但数据一致性保证较弱。绝大多数的NoSQL数据库适合写多读少、写多读多的场景。以列式数据库、时序数据库而言，它们通过LSM的思想，提供了非常高的写入性能。这类系统的存储引擎广泛意义上也称为LSM Tree存储引擎，这些系统单机的存储引擎有RocksDB、LevelDB等。此外再以键值数据库为例，它们绝大部分通过利用哈希表这种数据结构，外加内存介质存储数据。实现非常高的读写性能。Redis就是这类系统的典型代表。
3. NewSQL数据库 虽然NoSQL数据库解决了关系型数据库存储的缺陷，但它也没法完全替代掉关系型数据库。在NoSQL数据库出现后的一段时间内，互联网软件的构建基本上都是结合二者来提供服务。在不同的场景下选择不同的数据库进行存储数据。虽然这样的合作方式很好，但是在这样的模式下，一个用户可能会因为场景的不同而存储多份相同的数据到不同的数据库中，当用户量级和存储数据量很小的情况下没什么问题。一旦量级发生变化就会引发出新的问题。
随着存储数据量的不断增加，造成资源的浪费和成本的上升不容忽略。于是工业界和学术界都在寻找更好的解决方案，直到2010年左右，诞生了NewSQL数据库（也称为分布式数据库）。它的出发点是结合关系型数据库事务一致性，又具备NoSQL数据库的扩展性及访问性能。这无疑给系统的设计及实现带来了更大的挑战，NewSQL数据库不仅要考虑单机环境下高效存储的问题，还需要考虑多机情况下数据复制、一致性、容灾、分布式事务等问题。目前NewSQL数据库典型的代表作有TiDB、OceanBase、CockroachDB等。NewSQL数据库中绝大部分的系统还是采用LSM 树存储引擎，来实现系统高性能的写入。
02 OLTP&amp;OLAP&amp;HTAP对比 在现代数据管理领域，OLTP、OLAP和HTAP是常见的数据库类型，它们各自针对不同的数据处理场景和需求。本文将对这三种数据库进行对比，以帮助读者更好地理解它们的特点和适用性。
1. OLTP数据库 OLTP数据库（联机事务处理）是专门设计用于处理事务性工作负载的数据库系统。它们被广泛应用于业务应用程序，如在线购物、银行交易和订单处理等。OLTP数据库的主要特点是高并发、低延迟和高事务吞吐量。它们通过支持ACID（原子性、一致性、隔离性和持久性）特性来确保数据的一致性和可靠性。OLTP数据库通常采用规范化的数据模型，以支持高效的事务处理和即时的数据更新。
OLTP数据库主要的功能是处理用户在线实时的请求，直接为用户提供服务，因此这类数据库通常对处理请求的时延要求比较高，绝大部分的请求正常情况下会在毫秒级完成。OLTP数据库很多，除了大家最熟悉的关系型数据库（如MySQL、Oracle）外，还有Redis、MongoDB等这些非关系型数据库。绝大部分的OLTP数据库则是采用B树、B+树甚至哈希表来构建存储引擎。
2. OLAP数据库 OLAP数据库（联机分析处理），它们专注于支持决策支持和分析工作负载。OLAP数据库用于处理大量数据的复杂分析查询和报表生成。OLAP系统的关键特点是高度可扩展、支持复杂的分析操作和提供灵活的数据聚合能力。为了实现这些特性，OLAP数据库通常采用了针对分析查询优化的特殊数据结构，如多维数据模型（如星型或雪花模型）和列存储技术。此外，OLAP数据库还提供了灵活的查询语言和数据切片、切块、钻取等功能，以支持交互式的数据分析和探索。
OLAP数据库在功能上侧重于对数据或者任务进行离线处理，它不直接对用户提供服务。OLAP系统对请求的处理通常比OLTP慢得多，一般在秒级、分钟级甚至小时级，通常在数据统计、报表分析、推荐系统数据聚合分析等场景用的比较多。这一类数据库典型的代表有HBase、Teradata、Hive、Presto、Druid、ClickHouse等。互联网企业往往都需要使用OLTP和OLAP。因此为了满足这两类需求，通常需要结合多个系统一起开发使用。这样的做法当然是可行的，而且基本也是采用这种方式进行实现。绝大部分的OLAP数据库是采用LSM树构建存储引擎。
3. HTAP数据库 随着数据处理需求的不断演变，需要存储的数据量爆炸式增长，在这种模式下直接带来的存储成本问题成为新的矛盾点，人们开始探索是否能诞生一种数据库将OLTP和OLAP这两类应用合二为一呢？于是，HTAP（混合事务/分析处理）数据库应运而生。HTAP数据库旨在将OLTP和OLAP的功能集成到同一个数据库系统中，以满足实时分析和事务处理的需求。HTAP数据库通过在同一数据库上同时支持事务处理和分析查询，消除了数据复制和数据移动的需求，提供了更高的数据一致性和实时性。HTAP数据库通常采用了内存计算、分布式架构和智能查询优化等技术，以保证高性能和灵活性。这类数据库既可以处理在线事务处理，又可以处理在线分析处理。可以认为HTAP=OLTP+OLAP。HTAP的主要代表有TiDB、OceanBase、CockroachDB等。
在选择数据库时，需要考虑具体的业务需求和性能要求。如果您需要处理大量的事务性工作负载，如在线交易，那么OLTP数据库是一个理想的选择。如果您的需求是进行复杂的数据分析和报表生成，那么OLAP数据库可能更适合。而如果您需要同时满足实时分析和事务处理的需求，那么HTAP数据库是一个值得考虑的选项。
总而言之，OLTP、OLAP和HTAP数据库各自针对不同的数据处理场景和需求。了解它们的特点和适用性，可以帮助您在选择数据库时做出明智的决策，并确保满足业务的需求和性能要求。
03 总结 如果以组件的类型是关系型数据库还是非关系型数据库，并结合服务的场景是OLTP还是OLAP来对业界各种存储组件进行划分的话，可以得到如下图所示的结果。关系型数据库中既有为OLTP设计的，也有为OLAP设计的，同时还有新兴发展起来兼容二者的HTAP数据库。这些系统都有各自适用的业务场景，它们在存储引擎选型时，往往会根据适用场景来决定。如果是读多写少的场景，通常会选择B+树、哈希表来构建存储引擎。而如果是写多读少的场景，往往会选择LSM树来构建存储引擎。
关于作者：文小飞 （网名：jaydenwen/jaydenwen123），大厂资深研发工程师、公司级讲师。曾就职于腾讯等互联网公司，从事基础架构、后端开发、推荐系统架构等工作，具有丰富的基础架构经验。对技术充满热情，尤其对存储引擎、分布式共识算法等技术有较为深入的理解，曾编写开源书籍“自底向上分析 BoltDB 源码”，并发布“数据存储与检索”等网络课程。业余时间喜欢阅读开源项目源码，学习新技术。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/280b2b82c58e78cd1784955b37b7cae2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11f20d50f793b48f2e56b82dd4622b70/" rel="bookmark">
			英伟达CEO黄仁勋公布芯片路线图，直言机器人时代已来、下一波浪潮是物理AI...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整理 | 王轶群
责编 | 唐小引‍‍‍
出品丨AI 科技大本营（ID：rgznai100）
“你所看到的一切的基础是两项基本技术，加速计算和在宇宙中运行的人工智能。”6月2日晚7点，英伟达 CEO 黄仁勋在 Computex 2024 开幕前带来现场主题演讲《揭开新工业革命序幕》。
在这场不到2小时的演讲中，黄仁勋承接 GTC 2024 的科技成果，官宣了最新的芯片计划，并带来了芯片设备、数字孪生技术，以及机器人的最新构想及产业应用突破。 “这是我们第一次举办夜间演讲，这些是早间演讲中做不来的。”黄仁勋的多个重磅推出和精彩的demo演示把台大体育馆现场氛围拉满。
芯片布局再上分：
Blackwell 量产，继任者 Rubin 2026年推出
英伟达新架构Blackwell宣布不过3个月，老黄又带来了重磅消息。
老黄表示，Blackwell芯片现已开始投产。他还表示，英伟达计划每年升级其 AI 加速器，在最新的芯片规划中：
2025 年推出 Blackwell Ultra 芯片；‍
2026 年推出使用 HBM4 内存的 Blackwell 继任者 Rubin 芯片；
2027年推出 Rubin Ultra，新一代基于 Arm 的 Vera CPU，以及 NVLink 6 Switch（3600GB/s）。
后续芯片计划中的Rubin 和 Vera 的命名均源自美国天文学家 Vera Rubin，她是研究暗物质先驱。 “我在这里向你们展示的所有这些芯片都在完全开发中，百分之百。" 英伟达创始人兼 CEO 黄仁勋说，英伟达的更新节奏以年为单位，所有架构都是兼容的，" 以一年为周期，我们把所有东西推向技术极限。”
到这一代Blackwell为止，英伟达已经把AI模型有效扩展到万亿参数。同时，老黄还给token定了个中文译名“词元”。
这次的主角依旧是 Blackwell。
老黄在现场展示了 Blackwell 芯片主板，称这是“世界上最复杂、性能最高的计算机”。
越大越节能，秒杀摩尔定律
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11f20d50f793b48f2e56b82dd4622b70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fb01321fa92d870f6285e05f5ae9cb3/" rel="bookmark">
			【面试干货】 非关系型数据库（NoSQL）与 关系型数据库（RDBMS）的比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【面试干货】 非关系型数据库（NoSQL）与 关系型数据库（RDBMS）的比较 一、引言二、非关系型数据库（NoSQL）2.1 优势 三、关系型数据库（RDBMS）3.1 优势 四、结论 💖The Begin💖点点关注，收藏不迷路💖 一、引言 在数据库技术中，关系型数据库（RDBMS）长期占据主导地位，但随着大数据和云计算的兴起，非关系型数据库（NoSQL）逐渐崭露头角。本文将探讨这两种数据库的区别及其各自的优势。
二、非关系型数据库（NoSQL） 2.1 优势 高性能
NoSQL 数据库通常基于键值对（Key-Value Pair）存储，这种结构使得数据查询更加直接，无需经过复杂的 SQL 层解析，从而 大大提高了性能。 可扩展性
由于 NoSQL 数据库中的数据之间没有严格的耦合性，因此可以非常方便地进行水平扩展。无论是通过添加更多的服务器节点还是通过数据分片（Sharding）技术，都可以实现 数据库性能的提升。 灵活性
NoSQL 数据库支持多种数据模型，如文档型（Document-Oriented）、列式（Column-Oriented）、图形（Graph）等，这使得开发者可以根据实际需求选择合适的数据模型，从而更加灵活地处理数据。 三、关系型数据库（RDBMS） 3.1 优势 复杂查询
关系型数据库支持 SQL 语言，通过 SQL 语句可以方便地在单个表或多个表之间进行非常复杂的数据查询。这种查询能力使得关系型数据库在处理结构化数据方面具有天然的优势。 事务支持
关系型数据库支持 ACID 特性（原子性、一致性、隔离性、持久性），这使得对于安全性能要求很高的数据访问得以实现。同时，事务的支持也使得在多个操作之间保持数据的一致性成为可能。 成熟稳定
关系型数据库经过数十年的发展，已经形成了成熟的理论体系和技术标准。许多知名的关系型数据库（如 Oracle、MySQL、PostgreSQL 等）都经过了大量的实践验证，具有良好的稳定性和可靠性。 四、结论 非关系型数据库和关系型数据库各有其优势和适用场景。
1、非关系型数据库在性能、可扩展性和灵活性方面具有优势，适用于处理大量非结构化数据或需要高性能读写的场景；
2、而关系型数据库则在复杂查询、事务支持和成熟稳定性方面具有优势，适用于处理结构化数据或需要保证数据一致性和安全性的场景。
在选择数据库时，应根据实际需求进行权衡和选择。
💖The End💖点点关注，收藏不迷路💖 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb3ca93d7d355b7c3ef79a0659b2dbfb/" rel="bookmark">
			Stable diffusion prompts 使用语法、参数讲解、插件安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Stable diffusion prompts 使用语法、参数讲解、插件安装教程 本文基于 Stable diffusion WebUI 进行讲解（安装在 AutoDL 上，安装在本地电脑上的也同样适用本教程）。
初始界面：
文件目录结构：
上图红框中的 4 个文件夹是我们常用到的，embeddings 放置训练的 embedding 模型，它可以在我们使用基础模型时，再添加此模型进行叠加效果。
extensions 插件安装目录，在 WebUI 插件安装界面安装后，可以此文件夹中查看，并上传相应的插件模型（如 ControlNet 需要专门的模型）
Models 模型文件夹，安装时会默认下载 v1-5-pruned-emaonly，我们从其它地方下载的模型可以拷贝到此文件夹，在需要使用某个模型时，可以进行切换，如下图：
outputs 生成的图系统会输出到这个文件夹里，可进行查看及保存。
上图从左到右，依次是：
txt2img： 文字生成图片
img2img： 图片生成图片
Extras： “无损”放大图片，优化(清晰、扩展)图像
**PNG info：**从图片 exif 里获取图片的信息，如果是 Stable Diffusion 原始生成的 png 图片，图片的 exif 信息里会写入图片生成参数
**Checkpoint Merger：**合并不同的模型，生成新的模型
**Train：**训练 embedding 或者 hypernetwork
**Settings：**设置页面
**Extensions：**插件的安装和管理页面
txt2img **Sampling method：**采样方法
● Euler a ：富有创造力，不同步数可以生产出不同的图片。 超过 30~40 步基本就没什么增益了
● Euler：最常见的基础算法，最简单也最快
● DDIM：速度快，一般 20 步差不多
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb3ca93d7d355b7c3ef79a0659b2dbfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94c0d0d43682097f2a42f84bd1a29f1b/" rel="bookmark">
			Python魔法之旅-魔法方法(14)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、概述
1、定义
2、作用
二、应用场景
1、构造和析构
2、操作符重载
3、字符串和表示
4、容器管理
5、可调用对象
6、上下文管理
7、属性访问和描述符
8、迭代器和生成器
9、数值类型
10、复制和序列化
11、自定义元类行为
12、自定义类行为
13、类型检查和转换
14、自定义异常
三、学习方法
1、理解基础
2、查阅文档
3、编写示例
4、实践应用
5、阅读他人代码
6、参加社区讨论
7、持续学习
8、练习与总结
9、注意兼容性
10、避免过度使用
四、魔法方法
44、__length_hint__方法
44-1、语法
44-2、参数
44-3、功能
44-4、返回值
44-5、说明
44-6、用法
45、__lshift__方法
45-1、语法
45-2、参数
45-3、功能
45-4、返回值
45-5、说明
45-6、用法
46、__lt__方法
46-1、语法
46-2、参数
46-3、功能
46-4、返回值
46-5、说明
46-6、用法
五、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、博客个人主页
一、概述 1、定义 魔法方法(Magic Methods/Special Methods，也称特殊方法或双下划线方法)是Python中一类具有特殊命名规则的方法，它们的名称通常以双下划线(`__`)开头和结尾。
魔法方法用于在特定情况下自动被Python解释器调用，而不需要显式地调用它们，它们提供了一种机制，让你可以定义自定义类时具有与内置类型相似的行为。
2、作用 魔法方法允许开发者重载Python中的一些内置操作或函数的行为，从而为自定义的类添加特殊的功能。
二、应用场景 1、构造和析构 1-1、__init__(self, [args...])：在创建对象时初始化属性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94c0d0d43682097f2a42f84bd1a29f1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e33c5f42d825788e3b774a30e10bda46/" rel="bookmark">
			【高阶数据结构(八)】跳表详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💓博主CSDN主页:杭电码农-NEO💓
⏩专栏分类:高阶数据结构专栏⏪
🚚代码仓库:NEO的学习日记🚚
🌹关注我🫵带你学习更多数据结构
🔝🔝
高阶数据结构 1. 前言2. 跳表的概念3. 跳表的特性分析4. 跳表的效率分析5. 跳表模拟实现7. 跳表和传统查找结构的对比8. 总结 1. 前言 跳表也是一种查找结构,和红黑树,哈希的价值是一样的,那么跳表的优势是什么呢?
本章重点:
本篇文章会着重讲解跳表的基本概念和特性, 讲解实现跳表的逻辑,以及手撕一个跳表. 最后会将跳表和红黑树/哈希进行对比, 分析优势和缺点
2. 跳表的概念 跳表是基于有序链表的基础上发展而来的
有序链表的查找效率为O(N). 优化策略:
假如每相邻两个节点升高一层，增加一个指针，让指针指向下下个节点，如图b。这样所有新增加的指针连成了一个新的链表，但它包含的节点个数只有原来的一半。由于新增加的指针，我们不再需要与链表中每个节点逐个进行比较了，需要比较的节点数大概只有原来的一半 以此类推，我们可以在第二层新产生的链表上，继续为每相邻的两个节点升高一层，增加一个指针，从而产生第三层链表。如下图c，这样搜索效率就进一步提高了。 跳表正是受这种多层链表的想法的启发而设计出来的。这样设计确实可以大大提高效率,但问题是,一旦此结构进行插入或删除, 整个跳表的规则就会被打乱. 插入/删除一个元素后, 后面节点的高度可能就不符合跳表的规则了. 跳表的发明者为了避免上诉情况,设计了这样的一种结构:
skiplist的设计为了避免这种问题，做了一个大胆的处理，不再严格要求对应比例关系，而是插入一个节点的时候随机出一个层数。这样每次插入和删除都不需要考虑其他节点的层数，这样就好处理多了 3. 跳表的特性分析 拿下图举例:
查找19分析:
从头节点的最上面的节点开始, next=6,19大于6.直接向右跳到6. next=空,向下走,next=25.25大于19.再向下走. next=9.19大于9,向右走到9. next=17. 19大于17, 向右跳到17. next=25. 25大于19.向下走. next=19.找到19. 总结: 比它大, 向右走. 比它小, 向下走
插入/删除分析:
插入和删除操作的关键都是, 找到此位置的每一层节点的前一个和后一个节点. 插入和删除和其他节点无关, 只需要修改每一层的next指针指向即可. 比如现在要在节点7和9之间插入节点8. 节点8假设是三层. 那么插入只需要考虑节点8的第一层和第二层的前一个节点是6,而第三层的前一个节点是7. 第一层的后一个节点是25.第二层的后一个节点是9.第三次的后一个节点也是9. 依次改变指针知晓即可.
4. 跳表的效率分析 上面我们说到，skiplist插入一个节点时随机出一个层数，听起来怎么这么随意，如何保证搜索时
的效率呢？这里首先要细节分析的是这个随机层数是怎么来的。一般跳表会设计一个最大层数maxLevel的限制，其次会设置一个多增加一层的概率p。那么计算这个随机层数的伪代码如下图：
p代表概率,maxlevel代表最高层数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e33c5f42d825788e3b774a30e10bda46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5672792b2872a7275d9510f59a69c786/" rel="bookmark">
			RabbitMQ消息的发布确认机制详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RabbitMQ发布确认机制确保消息从生产者成功传输到交换机和队列，提高系统可靠性。在Spring Boot项目中，通过配置publisher-confirm-type和publisher-returns，启用发布确认和消息返回机制。配置RabbitTemplate的确认回调和返回回调，可以捕捉消息传输状态，处理不同传输结果。测试场景包括消息无法到达交换机、消息到达交换机但无法到达队列以及消息成功到达队列。通过合理设置和优化，可以确保高并发环境下的消息可靠传输，适用于金融支付、电商系统等对消息传输可靠性要求高的场景。
1. RabbitMQ发布确认机制概述 发布确认（Publisher Confirms）是RabbitMQ提供的一种机制，用于确保消息从生产者发送到RabbitMQ服务器并被成功处理。与事务机制不同，发布确认的性能开销更小，非常适合高吞吐量的场景。发布确认机制提供了两种类型的确认：
消息到达交换机（Exchange）后的确认消息从交换机路由到队列（Queue）后的确认 2. 配置文件中添加发布确认相关配置 在Spring Boot项目中，通过配置文件来启用发布确认机制非常方便。以下是需要添加到application.properties或application.yml中的配置：
# 消息到达交换机后会回调发送者 spring.rabbitmq.publisher-confirm-type=correlated # 消息无法路由到队列时回调发送者 spring.rabbitmq.publisher-returns=true 配置解释：
publisher-confirm-type：设置为correlated表示使用CorrelationData来关联确认与发送的消息。publisher-returns：设置为true表示启用消息返回机制，当消息无法路由到队列时会触发回调。 3. 发布确认类型 在Spring AMQP中，发布确认类型通过ConfirmType枚举类来定义：
public enum ConfirmType { SIMPLE, // 使用 RabbitTemplate#waitForConfirms() 或 waitForConfirmsOrDie() CORRELATED, // 使用 CorrelationData 关联确认与发送的消息 NONE // 不启用发布确认 } 4. 配置RabbitTemplate 为了使用发布确认机制，需要配置RabbitTemplate，包括设置确认回调和返回回调：
@Slf4j @Configuration public class RabbitTemplateConfig { @Bean public RabbitTemplate createRabbitTemplate(ConnectionFactory connectionFactory) { RabbitTemplate rabbitTemplate = new RabbitTemplate(); rabbitTemplate.setConnectionFactory(connectionFactory); // 设置mandatory为true，当找不到队列时，broker会调用basic.return方法将消息返还给生产者 rabbitTemplate.setMandatory(true); // 设置确认回调 rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -&gt; { if (ack) { log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5672792b2872a7275d9510f59a69c786/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d950f3b1c7b5cc16be9b4f75bdab324c/" rel="bookmark">
			深度学习（中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前馈全连接神经网络对鸢尾花数据集进行分类 1.1导入鸢尾花数据集 iris =load_iris() 1.2划分训练集测试集 x_train,x_test,y_train,y_test = train_test_split(iris.data,iris.target,test_size=0.2,random_state=23) 参数1：数据集数据
参数2：数据集标签
参数3：测试集大小
参数4：随机种子
1.3划分验证集 x_train,X_valid,y_train,y_valid = train_test_split(x_train,y_train,test_size=0.2,random_state=12) 1.4输出验证集训练集的形状 print(X_valid.shape) print(X_train.shape) 运行结果： 1.5 训练模型（和上篇文章有些方法是一样的） keras.layers.Dropout(rate=0.2) Dropout是一种正则化方法，用于防止过拟合；rate=0.2表示在训练时，该层会随机地将20%的输入单元置0
8.6使用fit训练模型，将训练过程转为二维数组 h = model.fit(x_train,y_train,batch_size=10,epochs=20,validation_data=(X_valid,y_valid)) pd.DataFrame(h.history) 运行结果： 1.7 画图 运行结果： 1.8评估模型:使用函数evaluate model.evaluate(x_test,y_test,batch_size=1) 运行结果： 2.卷积神经网络 2.1加载显示图像 2.1.1导入加载内置图像的库 from sklearn.datasets import load_sample_image 2.1.2将图像进行归一化 china = load_sample_image('china.jpg')/255 flower = load_sample_image('flower.jpg')/255 2.1.3绘制图像 plt.subplot(1,2,1) plt.imshow(china) plt.subplot(1,2,2) plt.imshow(flower) 2.1.4输出维度 print('china.jpg的维度：',china.shape) print('flower.jpg的维度：',flower.shape) 2.1.5将两张图像组成一个数组 imgs = np.array([china,flower]) img_shape = imgs.shape print('数据集的维度：',img_shape) 运行结果： 2.2确定卷积层大小，滑动步长 输出特征图数目 u = 7 #卷积层大小 s = 1 #滑动步长 p = 5 #输出特征图数目 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d950f3b1c7b5cc16be9b4f75bdab324c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50269b9571b3c2e308e6453a23d82332/" rel="bookmark">
			从零手写实现 nginx-04-基于 netty http 出入参优化处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 大家好，我是老马。很高兴遇到你。
我们希望实现最简单的 http 服务信息，可以处理静态文件。
如果你想知道 servlet 如何处理的，可以参考我的另一个项目：
手写从零实现简易版 tomcat minicat netty 相关 如果你对 netty 不是很熟悉，可以读一下
Netty 权威指南-01-BIO 案例
Netty 权威指南-02-NIO 案例
Netty 权威指南-03-AIO 案例
Netty 权威指南-04-为什么选择 Netty？Netty 入门教程
手写 nginx 系列 如果你对 nginx 原理感兴趣，可以阅读：
从零手写实现 nginx-01-为什么不能有 java 版本的 nginx?
从零手写实现 nginx-02-nginx 的核心能力
从零手写实现 nginx-03-nginx 基于 Netty 实现
从零手写实现 nginx-04-基于 netty http 出入参优化处理
从零手写实现 nginx-05-MIME类型（Multipurpose Internet Mail Extensions，多用途互联网邮件扩展类型）
从零手写实现 nginx-06-文件夹自动索引
从零手写实现 nginx-07-大文件下载
从零手写实现 nginx-08-范围查询
从零手写实现 nginx-09-文件压缩
从零手写实现 nginx-10-sendfile 零拷贝
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50269b9571b3c2e308e6453a23d82332/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d342a5e302f0546322d542b8b10f23f/" rel="bookmark">
			AIGC 011-SAM第一个图像分割大模型-分割一切！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AIGC 011-SAM第一个图像分割大模型-分割一切！
文章目录 0 论文工作1论文方法2 效果 0 论文工作 这篇论文介绍了 Segment Anything (SA) 项目，这是一个全新的图像分割任务、模型和数据集。SA 项目是一个具有里程碑意义的工作，它为图像分割领域带来了新的机遇和挑战。该项目的模型和数据集将推动计算机视觉基础模型的研究，为构建更强大、更通用的图像分割模型奠定基础。
Segment Anything (SA) 项目提出了一种新的图像分割任务、模型和数据集。研究人员利用一个高效的模型，在数据收集循环中构建了迄今为止最大的分割数据集，包含超过 10 亿个掩码，覆盖了 1100 万张经过许可和尊重隐私的图像。该模型被设计并训练成可提示的，因此它可以零样本迁移到新的图像分布和任务中。对多个任务的评估表明，该模型的零样本性能令人印象深刻，通常可以与或甚至超过先前完全监督的结果。为了促进计算机视觉基础模型的研究，Segment Anything 模型 (SAM) 和包含 10 亿个掩码和 1100 万张图像的对应数据集 (SA-1B) 已发布在 https://segment-anything.com 上。
CLIP-diffusion-SAM-LRM再有就是一些多模态大模型，可以发现大模型的能力开始在开始在不同的视觉任务上开始涌现。
从目前来看无论2d还是3d方面都是大力出奇迹。在十亿级别的数据上2d大模型能力得到很强的展现。在这一点上3d数据集就差很多，一方面数据量有限，另外一方面3d数据集都是合成数据集，对模型泛化能力还是有限制。
接下来我们想分享的3d理解的论文，无论是nerf基还是Gaussian基都是以CLIP或者SAM为基础。这真的是一件很酷的事情。
论文链接
github
objaverse
1论文方法 任务、模型和数据集:
任务: SA 项目定义了一个新的图像分割任务，旨在构建一个可以处理各种图像和分割场景的通用模型。
模型: 论文提出了一种高效的分割模型，可以被提示（promptable），即可以零样本迁移到新的图像分布和任务中。
数据集: 该项目构建了迄今为止最大的分割数据集，包含超过 10 亿个掩码，覆盖了 1100 万张经过许可和尊重隐私的图像。
模型特点:
可提示性: 模型被设计成可提示的，这意味着它可以根据不同的提示（例如点、框或文本描述）进行分割，无需重新训练。
零样本迁移: 模型可以零样本迁移到新的图像分布和任务中，无需额外的训练数据。评估结果:
论文在多个任务上评估了模型的能力，发现其零样本性能非常出色，通常可以与或甚至超过先前完全监督的结果。贡献:
SAM项目定义了一个新的图像分割任务，为计算机视觉领域的研究开辟了新方向。
SAM模型 (SAM) 和数据集 (SA-1B) 的发布，将推动计算机视觉基础模型的研究。
方法实现:
论文没有详细描述模型的具体实现细节，但强调模型的可提示性和零样本迁移能力。zero-shot的能力主要还是对比学习来展现的，即相似度。
论文中提到模型是高效的，可能使用了Transformer 或者其他高效的架构。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d342a5e302f0546322d542b8b10f23f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f6c1abb32633e55e05c121a4d676068/" rel="bookmark">
			【前端 - Vue】关于ESlint代码规范及格式化插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要讲解：ESlint代码规范及手动修复，以及如何通过eslint插件来实现自动修正
目录
一、ESlint代码规范及手动修复
1.JavaScript Standard Style 规范说明
2.代码规范错误
3.手动修正
二、通过eslint插件来实现自动修正
如何安装
如何配置
一、ESlint代码规范及手动修复 思考代码应该有哪些规范：一套写代码的约定规则。例如：赋值符号的左右是否需要空格？一句结束是否是要加;？......
没有规矩不成方圆
ESLint:是一个代码检查工具，用来检查你的代码是否符合指定的规则(你和你的团队可以自行约定一套规则)。在自定义创建vue项目时，我们通常使用的是 JavaScript Standard Style 代码风格的规则。
1.JavaScript Standard Style 规范说明 建议把：JavaScript Standard Style 看一遍，然后在写的时候, 遇到错误就查询解决。
下面是这份规则中的一小部分：
字符串使用单引号 – 需要转义的地方除外
关键字后加空格 if (condition) { ... }
函数名后加空格 function name (arg) { ... }
坚持使用全等 === ，摒弃 == ，但在需要检查 null || undefined 时可以使用 obj == null
......
2.代码规范错误 如果你的代码不符合standard的要求，eslint会跳出来刀子嘴，豆腐心地提示你。
下面我们在main.js中随意做一些改动：添加一些空行，空格。
import Vue from 'vue' import App from '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f6c1abb32633e55e05c121a4d676068/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4225d4d4c622fff44c2a3aa5237182a/" rel="bookmark">
			OpenCv之简单的人脸识别项目（特征标注页面）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人脸识别 准备八、特征标注页面1.导入所需的包2.设置窗口2.1定义窗口外观和大小2.2设置窗口背景2.2.1设置背景图片2.2.2创建label控件 3.定义两个全局变量4.定义选择图片的函数4.1函数定义和全局变量声明4.2打开文件对话框并获取文件路径4.3处理图片并创建标签4.4显示图像 5.定义标注函数5.1函数定义和全局变量声明5.2条件判断和关键点预测器文件检查5.3加载dlib的人脸检测器和预测器5.4读取图片和检测人脸5.5标注关键点和显示标注后的图像 6.定义关闭窗口的函数7.按钮设计7.1选择图片按钮7.2开始标注按钮7.3返回按钮 10.定义关键函数10. 人脸标注运行结果图11. 人脸标注功能展示图 特征标注页面完整代码 准备 本篇将展示特征标注页面，并与登录页面连接起来。
八、特征标注页面 1.导入所需的包 tkinter:
Tkinter是Python的标准GUI（图形用户界面）库。它提供了一个快速和简单的方式来创建GUI应用程序。tkinter模块是Tkinter库的主模块，包含了创建窗口、按钮、文本框等基本GUI组件的类和函数。
filedialog:
这个模块是tkinter的一个扩展，提供了一个文件对话框，允许用户选择文件或目录。它是tkinter的一部分，通常与tkinter一起使用来创建文件选择器。
PIL (Python Imaging Library):
PIL是一个强大的图像处理库，它支持多种图像文件格式，并提供了一系列图像处理功能，如打开、修改、保存图像，以及图像处理操作（如缩放、裁剪、颜色转换等）。
ImageTk:
ImageTk是PIL库中用于与Tkinter一起使用的模块，它提供了在Tkinter中显示图像的功能。它通常与Tkinter的PhotoImage类一起使用，以在Tkinter应用程序中显示PIL的Image对象。
dlib:
dlib是一个C++库，它提供了大量机器学习和计算机视觉功能。dlib模块是dlib库的Python接口，它允许您在Python中使用dlib的功能。在图像处理和机器学习领域，dlib被广泛用于人脸识别、物体检测、图像分割等任务。
cv2 (OpenCV):
OpenCV是一个开源的计算机视觉库，它提供了大量用于图像和视频处理的功能。cv2模块是OpenCV的Python接口，它允许您在Python中使用OpenCV的功能。OpenCV广泛用于图像识别、图像处理、物体检测、视频分析等任务。
subprocess:
这个模块允许您启动新的进程，连接到它们的输入/输出/错误管道，并获取它们的返回码。通常用于执行系统命令或运行外部程序。
os:
os模块提供了与操作系统交互的功能。它提供了用于文件和目录操作的函数，如文件读写、目录遍历、文件路径处理等。
import tkinter as tk from tkinter import filedialog from PIL import Image, ImageTk import dlib import cv2 import subprocess import os 2.设置窗口 2.1定义窗口外观和大小 实例化窗口，设置窗口标题，尺寸。
# 创建Tkinter窗口 win = tk.Tk() win.title('欢迎') win.geometry('780x650') 2.2设置窗口背景 2.2.1设置背景图片 调用image对象的resize方法来调整图像的大小。将调整大小后的PIL Image对象转换为Tkinter兼容的PhotoImage对象。
#背景设计 image = Image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4225d4d4c622fff44c2a3aa5237182a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01e4854976449304287342fe41f92286/" rel="bookmark">
			代理IP使用api接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 代理IP使用API接口，通常是指通过API接口获取代理IP地址，并将其应用于爬虫、数据采集、反爬虫等场景中，以提高数据采集效率和保护数据采集安全。
一般来说，代理IP提供商会提供API接口文档和SDK供开发者使用。你需要先注册并登录代理IP提供商的网站，然后根据提供商的文档和SDK进行开发。在使用代理IP API接口时，你需要注意以下几点：
接口请求频率：有些代理IP提供商对API接口请求频率有限制，需要遵守限制要求;接口访问权限：一些高级功能可能需要特定的权限才能访问，需要确认是否拥有相应权限；返回结果格式：不同的API接口返回结果可能会有所不同，需要根据文档进行解析；异常处理：在使用API接口过程中，可能会出现一些异常情况，需要进行相应的异常处理。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6ed85ad63856b681e6cd4f6d2baf7ae/" rel="bookmark">
			让开发更高效：Windows 平台下 Clang 和 Clangd 的安装与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows 平台下 Clang 和 Clangd 的安装与配置 由于平时都在linux平台下进行开发，抽空想同步下Windows上的开发环境
Clang Clang 的开发始于 2007 年，由 Chris Lattner （同时也是 Swift 语言的创始人）和他的团队在苹果公司启动。最初的动机是为了替代 GCC，解决 GCC 在编译速度、内存使用和错误信息方面的不足，苹果公司在 Xcode 4.2 中默认使用 Clang 作为编译器。
Clang与GCC一样同属于编译器套件，是一个编译器前端，它主要用于处理 C、C++、Objective-C 和 Objective-C++ 代码。它将源代码转换成中间表示（IR），然后由后端进一步处理成机器代码，
LLVM（Low Level Virtual Machine）是一个编译器基础架构项目，提供了一系列编译器和工具链技术，用于创建前端和后端编译器。LLVM 提供了 Clang 需要的后端支持，将中间表示（IR）转换成机器代码。
需要从LLVM官方网站下载并安装LLVM和Clang的预编译二进制文件包。可以通过访问LLVM下载页面获取安装包。
Clang在Windows上通常依赖于Microsoft的编译工具链，包括链接器和标准库（rust也同样依赖）。你可以安装完整的Visual Studio IDE，或者如果只需要编译工具，可以安装Visual Studio Build Tools。
选择 使用 C++ 的桌面开发 即可
也可以在 GitHub 直接下载LLVM，我下载的是LLVM 18.1.6，Assets中选择LLVM-18.1.6-win64.exe
之后无脑下一步就行，安装位置在C:\Program Files\LLVM，安装完毕后在Path中加入环境变量C:\Program Files\LLVM\bin即可
之后打开终端输入clang -v就可以看到了
clang -v clang version 18.1.6 Target: x86_64-pc-windows-msvc Thread model: posix InstalledDir: C:\Program Files\LLVM\bin 注意Windows下编译文件需要将文件编译成.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6ed85ad63856b681e6cd4f6d2baf7ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3cc61b26f838809baae1dc0145c7668/" rel="bookmark">
			Python求解微分方程，详细版（部分含Matlab）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是微分方程 （一）什么是微分方程 微分方程（differential equation）：表示未知函数、未知函数的导数与自变量之间的关系的方程，叫做微分方程。
（二）微分方程分类 如果自变量的个数只有一个，称为常微分方程（Ordinary differential equation，ODE）；如果自变量的个数不止一个，称为偏微分方程（Partial differential equation，PDE）。
线性微分方程（Linear differential equation）：若未知函数与其导数（偏导数）是一次有理整式，则称该微分方程是线性的。
微分方程组：用两个及以上的关系式表示的微分方程称为微分方程组。
1、常微分方程 一般 n 阶常微分方程具有如下形式：
而 n 阶线性常微分方程具有如下形式：
在牛顿力学中，位移，速度，时间三者之间的关系就是最简单的一阶线性常微分方程：
d x / d t = v ( t )
其中自变量是t，未知函数是x，未知函数的导数是 v 。再比如传染病模型，是一阶非线性常微分方程：
d x / d t=k*x*(n-x)
其中自变量是t表示某一时刻；x 是未知函数，表示t时刻染病人数；k是传染系数；n是该地区总人数。
常见常微分方程的表达式表示如下：
令那么 n 阶常微分方程可用一阶方程组代替：
2、偏微分方程 设Ω是 Rⁿ中的一个集合， x =(x1,x2,…, xn）表示Ω上的一点。
u = u ( x ):Ω→ R表示一个 n元函数。记：
其中，(i1, i2 ,…, ik）是集合｛1,2,…, n ｝中k个元素的任意排列。那么一般的
k阶偏微分方程具有如下形式：
k 阶线性偏微分方程具有如下形式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3cc61b26f838809baae1dc0145c7668/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42eff2d090101514170c9d268afb1f56/" rel="bookmark">
			HTML跳动的爱心
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
写在前面
HTML简介
程序设计
修改文字
推荐系列
写在后面
写在前面 本期小编给大家分享可以写字的html动态爱心代码，一起来看看叭~
HTML简介 HTML（HyperText Markup Language）是一种用于创建网页的标记语言。它是互联网的基础，几乎每一个网页都是由HTML编写的。学习HTML入门是每个想要进入网页开发领域的人的第一步。
HTML使用一系列标签来定义网页的结构和内容。每个标签都有特定的含义和作用，用于描述页面的各个元素。一个基本的HTML文档由&lt;html&gt;标签包围，其中包含&lt;head&gt;和&lt;body&gt;标签。
&lt;head&gt;标签通常包含一些元数据，例如页面的标题，作者，样式表等。这些信息对于浏览器和搜索引擎来理解和处理网页非常重要。
&lt;body&gt;标签包含页面的主要内容，例如文本，图像，链接等。通过使用不同的HTML标签，可以创建标题，段落，列表，表格以及其他各种元素。
例如，可以使用&lt;h1&gt;到&lt;h6&gt;标签创建不同级别的标题。&lt;p&gt;标签可以用于创建段落。&lt;ul&gt;和&lt;li&gt;标签可以用于创建无序列表。&lt;table&gt;和&lt;tr&gt;标签可以用于创建表格。
HTML还具有一些常用的属性，可以用于进一步定义和控制元素的行为和样式。例如，可以使用href属性为链接指定目标URL。可以使用src属性为图像指定来源URL。可以使用style属性为元素指定CSS样式。
编写HTML时应遵循一些最佳实践。首先，要保持代码结构的清晰和有序。使用缩进和换行来提高代码的可读性。其次，要注意标签的嵌套和闭合。每个开始标签都必须有一个匹配的结束标签，否则页面可能无法正常显示。最后，遵守语义化的原则，选择合适的标签来描述内容，以提高网页的可访问性和SEO优化。
编写HTML后，可以在浏览器中打开文件预览结果。在浏览器中，可以通过查看源代码来检查HTML的结构和内容。还可以使用开发者工具来调试和优化页面。
HTML入门只是网页开发的基础，后续还需要学习CSS和JavaScript等技术来实现更复杂的功能和效果。希望这个简要的介绍能帮助你开始学习HTML，并为你的网页开发之旅铺平道路。
程序设计 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;💗&lt;/title&gt; &lt;style type="text/css"&gt; body { margin: 0; overflow: hidden; background: #000; } canvas { position: absolute; width: 100%; height: 100%; } #pinkboard { animation: anim 1.5s ease-in-out infinite; -webkit-animation: anim 1.5s ease-in-out infinite; -o-animation: anim 1.5s ease-in-out infinite; -moz-animation: anim 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42eff2d090101514170c9d268afb1f56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cc937937dbe349a48be476a8b3ae234/" rel="bookmark">
			OpenCV图像裁剪：使用&amp;运算符在OpenCV图像裁剪时进行边界检查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定ROI的图像裁剪 假设需要按照既定的ROI对图像进行取窗裁剪，用cv::Rect给定ROI区域，裁剪可以按照如下方式：
cv::Mat image = cv::imread("/path/to/image.jpg"); cv::Rect roi = cv::Rect(x, y, width, height); cv::Mat crop = image(roi); 限制边界 如果roi的坐标超出了图像的合法区域，会引发运行时错误，导致程序崩溃。此时一般要提前进行边界检查和规范，比如这样：
if(roi.x&lt;0) roi.x=0; if(roi.y&lt;0) roi.y=0; if(roi.x+roi.width &gt;= image.cols) roi.width = image.cols-roi.x; if(roi.y+roi.height &gt;= image.rows) roi.heigth = image.rows-roi.y; 这样写代码，看上去不太直观，而且有些冗长，更谈不上优雅或者可读性。
或者这样：
int w = image.cols; int h = image.rows; int x0 = std::max&lt;int&gt;(0, roi.tl().x); int y0 = std::max&lt;int&gt;(0, roi.tl().y); int x1 = std::min&lt;int&gt;(w, roi.br().x); int y1 = std::min&lt;int&gt;(h, roi.br().y); roi = cv::Rect(cv::Point(x0, y0), cv::Point(x1, y1)); 稍微增加了些可读性，特别是如果习惯于使用stl的max/min函数进行边界检查。但是仍然冗长，不够优雅。冗长有什么坏处？一般来讲，冗长的代码不易于维护，可读性不会太强。另外以上面这段实现为例，由于反复使用同一变量，仅仅为了对其不同的成员做类似的操作，非常容易导致低级错误。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cc937937dbe349a48be476a8b3ae234/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/310/">«</a>
	<span class="pagination__item pagination__item--current">311/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/312/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>