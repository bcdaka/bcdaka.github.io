<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68244e74eb0467a10a192a6f8e6c03ea/" rel="bookmark">
			iRemovalPro完美解4G信号,支持A12&#43;,支持6S~14ProMax，支持iOS17.4&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iRemovalPro是一款绕过激活锁界面的解锁工具，可以激活所有iPhone/ipad恢复信号，并且支持插卡接打电话、收发短信、4G流量上网，支持iCloud登录，有消息通知，支持iPhone6S~14ProMax的所有型号，支持iOS15-iOS17.4+，支持Windows10以上系统。
官方售价：
iPhone 6s /6sp 30美刀 iPhone 7/7P 40美刀
iPhone 8/8P 50美刀 iPhone X 60美刀
不能有网络锁的，IPAD只支持插卡版本。
工具需要授权才可以使用，需要代购可以联系本公众号作者，24小时在线秒授权。
工具下载地址：
https://wwi.lanzoup.com/b017qemkb密码:bw8s
A12+处理器：https://www.123pan.com/s/yc4uVv-qTjHA.html
6S-X使用教程：
1.将设备全新刷机到最新系统，下载iRemovalPro解压到电脑上，打开iRemoval PRO点击iRa1n，第一次使用工具会提示需要安装驱动，点击是安装驱动程序，安装完成之后重启电脑。（如果安装不了请打开iRemoval PRO v6.1.1\ref\ira1n\bin\driver\usbdk手动安装驱动）
2.打开iRemoval PRO点击iRa1n ，打开越狱工具点击Start,Next之后，点完Start马上同时按住手机电源键和音量减键(iPhone7/8/X)，马上同时按住电源键和hom键(iPhone6S/SE)，4秒钟之后松开电源键，继续按住音量减键(iPhone7/8/X)，继续按住home键(iPhone6S/SE)，10秒钟之后松开音量减键或者home键。显示All Done越狱成功，返回软件主界面会自动检测提示Your device is supported for MEID/GSMSIGNAL bypasss表示可以解锁
3.复制设备序列号（SN）给作者授权。
4.设备不要插SIM卡连上WIFI，授权完了以后重新打开软件点击Activated开始解锁设备，等待工具提示解锁成功。
5.工具提示激活成功!设备会自动重启，重启完成设置手机进入系统解锁成功。
Xr-14PM（iOS15-17.4+）A12+使用教程：
1.下载软件并解压到电脑上，设备开机并且连接电脑软件会自动检测提示Your device is supported for A12+ SIGNAL bypasss表示支持解锁，联系本公众号作者注册序列号。
2.提交完成后需要等待1-4天，注册成功后设备连上WiFi并且连接电脑，软件点击Activate开始激活设备，根据软件提示操作激活设备。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/713299e49385554a5399905123cdac06/" rel="bookmark">
			除自身以外数组的乘积[中等]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优质博文：IT-BLOG-CN
一、题目 给你一个整数数组nums，返回数组answer，其中answer[i]等于nums中除nums[i]之外其余各元素的乘积。题目数据保证数组nums之中任意元素的全部前缀元素和后缀的乘积都在32位整数范围内。请不要使用除法，且在O(n)时间复杂度内完成此题。
示例 1:
输入: nums = [1,2,3,4]
输出: [24,12,8,6]
示例 2:
输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]
2 &lt;= nums.length &lt;= 105
-30 &lt;= nums[i] &lt;= 30
保证数组nums之中任意元素的全部前缀元素和后缀的乘积都在32位整数范围内
进阶：你可以在O(1)的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 不被视为 额外空间。）
二、代码 【1】创建左右乘积列表： 我们不能将所有数字的乘积除以给定索引处的数字得到相应的答案，而是利用索引左侧所有数字的乘积和右侧所有数字的乘积（即前缀与后缀）相乘得到答案。初始化两个数组Left和Right，对于指定的下表i，left[i]代表i左侧所有数据的乘积，right[i]代表i右侧所有数据的乘积。我们利用循环将数据填充到lfet[]和right[]数组中，然后将left[i]和right[i]相乘就是i的左右乘积。
class Solution { public int[] productExceptSelf(int[] nums) { if (nums == null || nums.length == 0) { return null; } // 我们使用数组，也就是当前数字的left[] 和 right[] 数组，分别存储左右两边的和; int len = nums.length; int res[] = new int[len]; int left[] = new int[len]; int right[] = new int[len]; // 第一个数之前的数的乘积为1，所以先给个默认值 left[0] = 1; for (int i = 1; i &lt; len; i++) { // left 中保存的是i之前所有数的乘积 left[i] = left[i - 1] * nums[i - 1]; } // 最有边的数也保存为1 right[len - 1] = 1; for (int i = len - 2; i &gt;= 0; i--) { right[i] = right[i + 1] * nums[i + 1]; } for (int i = 0; i &lt; len; i++) { res[i] = left[i] * right[i]; } return res; } } 时间复杂度： O(N)，其中N指的是数组nums的大小。预处理L和R数组以及最后的遍历计算都是O(N)的时间复杂度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/713299e49385554a5399905123cdac06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69bba8a70a676ca363f5d67d7d625253/" rel="bookmark">
			Hive 调优(包含hive所有调优方式 看这一篇就够了)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Hive 调优1、调优方式2、hive数据压缩2.1 压缩对比2.2 开启压缩 3、hive数据存储3.1 行列存储原理3.2 存储压缩比 4、fetch抓取5、本地模式6、join的优化操作7、列裁剪8、分区裁剪9、group by 操作10、count(distinct)11、笛卡尔积12、动态分区13、如何调整map和reduce的数量14、并行执行15、严格模式16、JVM 重用17、推测执行18、执行计划explain Hive 调优 hive官方配置url: https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties
1、调优方式 hive参数配置的意义: 开发Hive应用/调优时，不可避免地需要设定Hive的参数。设定Hive的参数可以调优HQL代码的执行效率，或帮助定位问题。然而实践中经常遇到的一个问题是，为什么我设定的参数没有起作用？这是对hive参数配置几种方式不了解导致的! hive参数设置范围（从大到小）: 配置文件 &gt; 命令行参数 &gt; set参数声明 hive参数设置优先级（从高优先级到低优先级）: set参数声明 &gt; 命令行参数 &gt; 配置文件 注意: 在工作中，推荐使用set参数声明，因为最简单最方便。而且同一个大数据集群除了你了还有其他的人或者项目组在使用。 2、hive数据压缩 Hive底层是运行MapReduce，所以Hive支持什么压缩格式本质上取决于MapReduce。
2.1 压缩对比 在后续可能会使用GZ(GZIP), 保证压缩后的数据更小, 同时压缩和解压的速度比较OK的,
但是大部分的选择主要会选择另一种压缩方案, snappy, 此种方案可以保证在合理的压缩比下, 拥有更高的解压缩的速度，在大数据领域中主要是关注数据的处理速度
http://google.github.io/snappy/
On a single core of a Core i7 processor in 64-bit mode, Snappy compresses at about 250 MB/sec or more and decompresses at about 500 MB/sec or more.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69bba8a70a676ca363f5d67d7d625253/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65b8db539c2ae9587cb49ba84ded940a/" rel="bookmark">
			【数据结构】时间、空间复杂度实例分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跌倒了，就重新站起来，继续向前走；傻坐在地上是没用的。💓💓💓
目录
•✨说在前面
🍋知识点一：算法的效率
• 🌰1.斐波那契数列的第n项
• 🌰2.算法的复杂度
🍋知识点二：时间复杂度
• 🌰1.时间复杂度的概念
• 🌰2.大O的渐进表示法
🔥复杂度的一般分析法则
🔥总结求解复杂度的方法
• 🌰3.时间复杂度的量级
• 🌰4.时间复杂度增长趋势​​​​​​​
• 🌰5.时间复杂度计算案例
🔥案例1：单个同量级for循环
🔥案例2：多个同量级for循环
🔥案例3：常数控制的for循环
🔥案例4：strchr函数的时间复杂度
🔥案例5：冒泡排序的时间复杂度
🔥案例6：调整语句为i=i*2的for循环
🔥案例7：二分查找的时间复杂度
🔥案例8：递归求阶乘
🔥案例9：递归求斐波那契数列的第n项
🍋知识点三：空间复杂度
• 🌰1.空间复杂度的概念
• 🌰2.空间复杂度计算案例
🔥案例1：冒泡排序的空间复杂度
🔥案例2：递归求阶乘
• ✨SumUp结语
•✨说在前面 亲爱的读者们大家好！💖💖💖，我们又见面了，在之前的阶段我们学习了顺序表、链表，包括单链表和双向链表，还刷了一些算法OJ练习。这些练习，我们有时可以有多种思路和方法解决，那我们如何对这些方法进行取舍呢？哪些方法是最优的呢？为此，我们必须进入学习时间复杂度和空间复杂度的相关知识，相信你学习完后就可以回答这个问题了。
👇👇👇
💘💘💘知识连线时刻（直接点击即可）
🎉🎉🎉复习回顾🎉🎉🎉
【数据结构】顺序表专题详解（带图解析）
【数据结构】单链表专题详细分析
【数据结构】双向循环链表专题解析
博主主页传送门：愿天垂怜的博客
​
🍋知识点一：算法的效率 • 🌰1.斐波那契数列的第n项 在讲解时间复杂度与空间复杂度之前，我们先看一个简单的例子：
练习：写一个程序，求出斐波那契数列的第n项的值。
方法1：迭代法
long long Fibonacci(int n) { int x1 = 1; int x2 = 1; int x3 = 1; while (n &gt;= 3) { x3 = x1 + x2; x1 = x2; x2 = x3; n--; } return x3; } 方法2：递归法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65b8db539c2ae9587cb49ba84ded940a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a81b650aecc0dc80c3edf870976e7a85/" rel="bookmark">
			C中Mysql的基本api接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、初始化参数返回值 二、链接服务器三、执行SQL语句注意事项 四、获取结果集4.1mysql_affected_rows和mysql_num_rows4.2mysql_store_result与mysql_free_result注意事项注意事项整体的工作流程 4.3mysql_use_result（）4.4mysql_field_count（） 五、关闭MySQL使用和区别 六、错误处理mysql_errno()` 和 `mysql_error() 一、初始化 创建MYSQL* 对象，使用mysql_init函数
MYSQL * mysql; mysql_init(mysql); 参数 mysql：指向一个 MYSQL 结构的指针。通常传递 NULL，系统将自动为您分配和初始化一个新的 MYSQL 对象。 返回值 成功：返回一个指向 MYSQL 结构的指针。失败：返回 NULL。 二、链接服务器 使用函数mysql_real_connect（）；
MYSQL *mysql_real_connect( MYSQL *mysql, // mysql_init() 函数的返回值 const char *host, // mysql服务器的主机地址, 写IP地址即可 // localhost, null -&gt; 代表本地连接 const char *user, // 连接mysql服务器的用户名, 默认: root const char *passwd, // 连接mysql服务器用户对应的密码, root用户的密码 const char *db, // 要使用的数据库的名字 unsigned int port, // 连接的mysql服务器监听的端口 // 如果==0, 使用mysql的默认端口3306, !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a81b650aecc0dc80c3edf870976e7a85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08e0c13840592f6a1fa12f50ea1ab1d6/" rel="bookmark">
			Flutter 中的 Icon 小部件：全面指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flutter 中的 Icon 小部件：全面指南 Flutter 提供了多种方式来展示图标，其中 Icon 是最常用的小部件之一。它不仅用于展示简单的图标，还可以与文本、按钮和其他小部件组合使用，以增强用户界面的交互性。本篇文章将详细介绍 Icon 小部件的用途、属性、使用方式以及一些高级技巧。
什么是 Icon 小部件？ Icon 是 Flutter 中用于展示图标的小部件。它通常与图标数据（如字体图标）一起使用，可以很容易地集成到各种用户界面元素中。Flutter 自带了一套 Material Icons 和 Cupertino Icons，分别对应于 Material 和 iOS 设计语言。
如何使用 Icon 使用 Icon 小部件非常简单：
import 'package:flutter/material.dart'; class IconExample extends StatelessWidget { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('Icon Example'), ), body: Center( // 使用Icon小部件 child: Icon( Icons.star_border, // Material Icons size: 128.0, // 设置图标大小 color: Colors.black, // 设置图标颜色 ), ), ); } } Icon 的属性 Icon 小部件有几个重要的属性：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08e0c13840592f6a1fa12f50ea1ab1d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81749c9f842b69b2aba9d8106827a942/" rel="bookmark">
			暴力数据结构之二叉树（堆的相关知识）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 堆的基本了解 堆（heap）是计算机科学中一种特殊的数据结构，通常被视为一个完全二叉树，并且可以用数组来存储。堆的主要应用是在一组变化频繁（增删查改的频率较高）的数据集中查找最值。堆分为大根堆和小根堆，大根堆中任意节点的值都大于其子树中节点的值，而小根堆则相反。堆的存储方式遵循层序遍历的规则，这样可以高效地利用存储空间。在数组中，根节点的下标为0，节点的左右孩子的下标可以通过特定的公式计算得出。堆的实现通常利用动态数组，这样可以快速扩展容量而不造成空间浪费。
堆的一些性质：1.堆中某个结点的值总是不大于或不小于其父结点的值；
2.堆总是一棵完全二叉树。
2. 堆的实现 我们知道堆的逻辑结构是一个完全二叉树，但是其物理结构仍然是一个数组，所以实现堆创建一个数组即可。
typedef int HPDateType; typedef struct Heap { HPDateType* a; int size; int capacity; }HP; void HPInit(HP* php) { assert(php); php-&gt;a = NULL; php-&gt;capacity = php-&gt;size = 0; } void HPDesTroy(HP* php) { assert(php); free(php-&gt;a); php-&gt;a = NULL; php-&gt;capacity = php-&gt;size = 0; } void Swap(HPDateType* p1, HPDateType* p2) { HPDateType tmp = *p1; *p1 = *p2; *p2 = tmp; } void AdjustUp(HPDateType* a, int child) { int parent = (child - 1) / 2; while (child &gt; 0) { if (a[child] &lt; a[parent]) { Swap(&amp;a[child], &amp;a[child]); child = parent; parent = (child - 1) / 2; } else { break; } } } void HPPush(HP* php, HPDateType x) { if (php-&gt;capacity == php-&gt;size) { int newcapacity = php-&gt;capacity == 0 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81749c9f842b69b2aba9d8106827a942/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af72345a0a004e1d0bbd06d17f78132a/" rel="bookmark">
			数据结构（C）：树的概念和二叉树初见
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
🍺0.前言
1.树概念及结构
2.认识一棵树
3.树的表示
3.1树在实际中的运用（表示文件系统的目录树结构） 4.二叉树 4.1特殊的二叉树 4.2二叉树的性质
💎5.结束语
🍺0.前言 言C之言，聊C之识，以C会友，共向远方。各位博友的各位你们好啊，这里是持续分享数据结构知识的小赵同学，今天要分享的数据结构知识是树的概念和二叉树，在这一章，小赵将会向大家展开聊聊树的概念和二叉树。✊
1.树概念及结构 树是一种非线性的数据结构，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的集合。把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。 有一个特殊的结点，称为根结点，根节点没有前驱结点
除根节点外，其余结点被分成M(M&gt;0)个互不相交的集合T1、T2、……、Tm，其中每一个集合Ti(1&lt;= i &lt;= m)又是一棵结构与树类似的子树。每棵子树的根结点有且只有一个前驱，可以有0个或多个后继 因此，树是递归定义的。
这个定义其实看起来也是很耐看的，如果我们看这个去学习二叉树，我感觉还是很有难度，那么下面小赵就用自己的语言来说一下什么叫树。
先看一下现实中的树：
我们现实中的树往往是长成这样，我们可以这样想一下就是这个根就好像是我们的磁盘，然后每个树根就好像是我们的文件夹，而每个文件里面又是不同的文件夹，这或许就是一个很好的树的概念，这样我们也能发现就是我们的树的结构在我们的计算机中是极其常见的。 至于上面所说的根节点，递归实现等，小赵会在下面和大家一一聊到。
树状结构：
当然这里还有一个特别要注意的地方即：树形结构中，子树之间不能有交集，否则就不是树形结构 。
2.认识一棵树 其实认识一个全新的东西就好像是认识全新的物质，我们要知道他长什么样子，他的每个部位叫什么，那么我们要想认识一棵树也是一样，那么下面我们就来感受一下这棵庞大的树结构。
子树：我们在树结构里的命名是很像我们人类的家族一样的，最上面一层的就好像是我们的祖先，那么子的意思其实就很像儿女的意思，那么对于A的儿女就是BCDEFG而不包含下面的那些HIJK等因为那些已经跨过了子了。
节点的度：一个节点含有的子树的个数称为该节点的度； 如上图：A的为6
叶节点或终端节点（也就是这棵树的最后）：度为0的节点称为叶节点； 如上图：B、C、H、I...等节点为叶节点
非终端节点或分支节点：度不为0的节点； 如上图：D、E、F、G...等节点为分支节点
双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点； 如上图：A是B的父节点
孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点； 如上图：B是A的孩子节点
兄弟节点：具有相同父节点的节点互称为兄弟节点； 如上图：B、C是兄弟节点
树的度：一棵树中，最大的节点的度称为树的度； 如上图：树的度为6
节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推
树的高度或深度：树中节点的最大层次； 如上图：树的高度为4（用家族的感觉就是这个家族有几代人）
堂兄弟节点：双亲在同一层的节点互为堂兄弟；如上图：H、I互为兄弟节点
节点的祖先：从根到该节点所经分支上的所有节点；如上图：A是所有节点的祖先
子孙：以某节点为根的子树中任一节点都称为该节点的子孙。如上图：所有节点都是A的子孙
森林：由m（m&gt;0）棵互不相交的树的集合称为森林；
3.树的表示 树结构相对线性表就比较复杂了，要存储表示起来就比较麻烦了，既然保存值域，也要保存结点和结点之间 的关系，实际中树有很多种表示方式如：双亲表示法，孩子表示法、孩子双亲表示法以及孩子兄弟表示法 等。我们这里就简单的了解其中最常用的孩子兄弟表示法。
typedef int Datatype; struct node { struct node* leftchild;//左孩子（左子树） struct node* rightchild;//右孩子（右子数） Datatype data;//当前节点存的数据 }; 结构图： 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af72345a0a004e1d0bbd06d17f78132a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15e485627ea4996c37679ce1bfd322ce/" rel="bookmark">
			大模型算法(一)：从Transformer到ViT再到LLaMA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单任务/单领域模型 深度学习最早的研究集中在针对单个领域或者单个任务设计相应的模型。
对于CV计算机视觉领域，最常用的模型是CNN卷积模型。其中针对计算机视觉中的不同具体任务例如分类任务，目标检测任务，图像分割任务，以CNN作为骨干backbone，加上不同的前后处理以及一些辅助层，来达到针对不同任务的更好效果。
对于NLP自然语言处理领域，最常用的模型起初是RNN，后续发展有LSTM，Transformer等。这个方向了解不多，具体自行百度。
Transformer：统一架构 Transformer起源于NLP领域，后面人们发现在CV领域Transformer也能用，甚至效果比CNN还要好，使得CV和NLP两个领域的模型架构得到统一，为多模态和大模型打下基础。
Transformer最广为人知的就是它的自注意力机制，要了解为什么创新出了这个机制，还要从RNN谈起。
在NLP领域，第一代模型范式就是RNN，循环神经网络。循环神经网络原理比较简单，RNN中的节点接受两个输入：上个节点的输出以及本次输入对应的词向量：
但是RNN缺点也很明显，不断地将输出再次输入，这种方法虽然可以关联到上文所包含的信息，但是只能关联到附近的上文信息，较远的上文信息对当下影响较小，而且容易出现梯度消失的问题。所以RNN在90年以后就很少用了，取而代之的是它的两个改进：LSTM长短时记忆网络和GRU门控循环网络。
但是二者也只是缓解了RNN的问题，并没有从根本上解决，后面又推出了seq2seq结构，依旧是缝缝补补。再后面计算机视觉中90年代提出的注意力机制，被Google mind团队应用在RNN上来做图像分类后，有学者把注意力机制从CV领域拿到了NLP领域来做机器翻译，Attention-based RNN。在这之后才到transformer的兴起，也就是那句“Attention is all your need”。
transformer简而言之即：将输入向量化，然后通过encoder编码层编码，再经过decoder解码层进行解码得到结果。
encoder的作用是理解和提取输入文本中的相关信息以及上下文的信息。解码器的任务是解码器则根据编码器的输出和先前生成的部分序列来生成输出序列。
注意，由于解码器需要根据先前生成部分的内容来生成输出序列中的下一部分，所以具有自回归的效果，这是encoder没有的，这个特性后面要提到。
这篇文章写的非常清晰明了，通俗易懂，我就不再班门弄斧了，大家可以直接看这篇文章。
一些细节问题的讲解
ViT：视觉领域的Transformer Vit李沐大神团队出的讲解非常好：ViT讲解
自注意力和transformer自从提出没多久就有人用在了计算机视觉领域，但是因为如果直接将图像拉长成一个数组，数据复杂度太高，所以提出了stand-alone attention和axial attention等折中方案，分别是将局部窗口输入给transformer和将图像划分为两个维度，分别进行transformer
ViT基本使用了Transformer的原结构，没有什么大的改动。图像数据shape一般都是 C × H × W C\times H \times W C×H×W的，Transformer接受的数据是二维的，所以需要将三维的数据reformat为二维的，原文给出的方法是将图像分为 m × n m\times n m×n个patch，每个patch的尺寸为 H m × W n × C \frac{H}{m} \times \frac{W}{n}\times C mH​×nW​×C的，将patch拉长为长度为 H m × W n × C \frac{H}{m} \times \frac{W}{n}\times C mH​×nW​×C的一维数组，这样图像就变成了 [ m × n , H m × W n × C ] [m \times n,\frac{H}{m} \times \frac{W}{n}\times C] [m×n,mH​×nW​×C]的二维数组，原文是将一个224*224的图像分为了 14 × 14 14\times 14 14×14个patch，每个patch的尺寸为 16 × 16 16\times 16 16×16，输入数据为 196 × 768 196\times 768 196×768。从图像到patch的这个过程，可以直接简单分割，也可以使用768个 16 × 16 × 3 16\times 16 \times 3 16×16×3的卷积核提取，得到的结果是是 14 × 14 × 768 14\times 14\times 768 14×14×768的数据，再将其reformat一下得到 196 × 768 196\times 768 196×768。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15e485627ea4996c37679ce1bfd322ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c6bab2597d4fa3137bb9571b1393cd9/" rel="bookmark">
			使用nvm下载nodejs【win10】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、安装nvm二、nvm切换国内镜像三、安装node四、配置 NVM 和 NodeJS五、配置npm镜像源 [2] [3]5.1、查看当前镜像源5.2、设置淘宝镜像源 参考资料如下，特此感谢： 一、安装nvm https://nvm.uihtm.com/ nvm文档手册
nvm全英文也叫node.js version management，是一个nodejs的版本管理工具。nvm和n都是node.js版本管理工具，为了解决node.js各种版本存在不兼容现象可以通过它可以安装和切换不同版本的node.js。
设置使用nvm安装的node时，node的路径（附加有详讲）[1]
​
二、nvm切换国内镜像 如果下载node过慢或者安装失败，请更换国内镜像源， 在 nvm 的安装路径下，找到 settings.txt，设置node_mirro与npm_mirror为国内镜像地址。下载就飞快了~~
WIN+R 输入cmd直接执行以下代码
`nvm npm_mirror https://npmmirror.com/mirrors/npm/` `nvm node_mirror https://npmmirror.com/mirrors/node/` 三、安装node 1、使用 NVM 下载 NodeJS，以管理员身份运行 cmd，然后输入nvm list available ，查看所有可下载的Node版本
2、下载指定版本的 NodeJS nvm install 17.8.0
3、查看下载的所有node版本 nvm ls
4、使用版本17.8.0 nvm use 17.8.0
5、然后使用node -v 和 npm -v 命令查看node是否安装和使用成功
至此，安装node完成。
四、配置 NVM 和 NodeJS 1、配置环境变量
NVM 和 NodeJS 的环境变量无需配置，在安装过程中已经帮我们自动配置好了，可以在环境变量中查看
2、配置node_global和node_cache
在NVM的安装目录新建两个文件夹node_global和node_cache。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c6bab2597d4fa3137bb9571b1393cd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/276e8d2246ce671543a22b984cf9488b/" rel="bookmark">
			大数据最新跟着罗某人认识spark和scala带你上大分(2)，这套Github上40K&#43;star面试笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，涵盖了95%以上大数据知识点，真正体系化！
由于文件比较多，这里只是将部分目录截图出来，全套包含大厂面经、学习笔记、源码讲义、实战项目、大纲路线、讲解视频，并且后续会持续更新
需要这份系统化资料的朋友，可以戳这里获取
Spark Streaming：是Spark提供的对实时数据进行流式计算的组件。提供了用来操作数据流的API，并且与Spark Core中的 RDD API高度对应。
Spark MLlib：提供常见的机器学习功能的程序库。包括分类、回归、聚类、协同过滤等，还提供了模型评估、数据 导入等额外的支持功能。
Spark GraphX：主要用于图形并行计算和图挖掘系统的组件。
集群管理器：Spark设计为可以高效地在一个计算节点到数千个计算节点之间伸缩计算。为了实现这样的要求，同时获得最大灵活性，Spark支持在各种集群管理器(Cluster Manager)上运行，包括Hadoop YARN、Apache Mesos，以及Spark自带的一个简易调度器，叫作独立调度器。
spark特点 运行速度快： 与Hadoop的MapReduce相比，Spark基于内存的运算要快100倍以上，基于硬盘的运算也要快10倍以上。Spark实现了高效的DAG执行引擎，可以通过基于内存来高效处理数据流。计算的中间结果是存在于内存中
易用性好：
Spark支持Java、Python和Scala的API，还支持超过80种高级算法，使用户可以快速构建不同的应用。而且Spark支持交互式的Python和Scala的Shell，可以非常方便地在这些Shell中使用Spark集群来验证解决问题的方法
通用性强： Spark提供了统一的解决方案。Spark可以用于，交互式查询（Spark SQL）、实时流处理（Spark Streaming）、机器学习（Spark MLlib）和图计算（GraphX）。这些不同类型的处理都可以在同一个应用中无缝使用。减少了开发和维护的人力成本和部署平台的物力成本
高兼容性： Spark可以非常方便地与其他的开源产品进行融合。比如，Spark可以使用Hadoop的YARN和Apache Mesos作为它的资源管理和调度器，并且可以处理所有Hadoop支持的数据，包括HDFS、HBase等。这对于已经部署Hadoop集群的用户特别重要，因为不需要做任何数据迁移就可以使用Spark的强大处理能力
Spark的运行架构：
1.基本概念
在具体讲解Spark运行架构之前，需要先了解以下7个重要的概念。
① RDD：是弹性分布式数据集的英文缩写，是分布式内存的一个抽象概念，提供了一种高度受限的共享内存模型。
② DAG：是有向无环图的英文缩写，反映RDD之间的依赖关系。
③ Executor：是运行在工作节点上的一个进程，负责运行任务，并为应用程序存储数据。
④ 应用：用户编写的Spark应用程序。
⑤ 任务：运行在Executor上的工作单元。
⑥ 作业：一个作业包含多个RDD及作用于相应RDD上的各种操作。
⑦ 阶段：是作业的基本调度单位，一个作业会分为多组任务，每组任务被称为“阶段”，或者也被称为“任务集”
二.了解Scala语言 Scala是Scalable Language的缩写，是一种多范式的编程语言，由洛桑联邦理工学院的马丁·奥德斯在2001年基于Funnel的工作开始设计，设计初衷是想集成面向对象编程和函数式编程的各种特性。
Scala 是一种纯粹的面向对象的语言，每个值都是对象。Scala也是一种函数式语言，因此函数可以当成值使用。
由于Scala整合了面向对象编程和函数式编程的特性，因此Scala相对于Java、C#、C++等其他语言更加简洁。
Scala源代码会被编译成Java字节码，因此Scala可以运行于Java虚拟机（Java Virtual Machine，JVM）之上，并可以调用现有的Java类库。
Scala 具有以下特性。
（1）面向对象
scala 是一种纯粹的面向对象语言。一个对象的类型和行 是由类和特征描述的。类通过子类化和灵活的混合类进行扩展，成为多重继承的可靠解决方案。
（2）函数式编程
Scala 提供了轻量级语法来定义匿名函数，支持高阶函数，允许函数嵌套，并支持函数柯里化。Scala 的样例类与模式匹配支持函数式编程語言中的代数类型。Scala 的单例对象提供了方便的方法来组合不属于类的函数。用户还可以使用 Scala的模式匹配，编写类似正则表达式的代码处理可扩展标记语言（Extensible Markup Language, XML）格式的数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/276e8d2246ce671543a22b984cf9488b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8df5081e130de276d6afa52811d6547e/" rel="bookmark">
			初识Java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录： 1.数据类型
2.数据输入
3.方法
4.数组
5.二维数组
序言： 与学习其他计算机语言一样，都是从它的语法形式开始学习的，Java与C语言有所相同也有所不同，接下来我就将Java与C类比着介绍一下Java的一些简单语法。（ 声明：我使用的Java集成开发环境是idea）
正文： 1.数据类型： 不管在什么系统，Java中的数据类型占用的字节数都是一定的，这就体现了Java语言可移植性强的优点，这便体现了那句口号：“Write once，run anywhere”
在变量初始化的时候，Java也和C语言不同：
在Java中，如果一个变量没有初始化，那么在编译时会报错，不会有默认值。例：
如果进行变量赋值的时候，字面值超过了取值范围，也会报错（int 类型的取值范围是-2147483648 到 2147483647）。例：
在Java中浮点数的储存方式与C与语言一样，所以并不能精确地表示每一位，如以下例子可直观看出。
在Java中，整数的默认类型是int， 小数的默认类型是double，在进行变量赋值的时候要注意在数字后加一个f或F来表示它是什么类型的变量，否则编译器会报错。例：
强制类型转换在编译层面不会报错，但它是有风险的，尽量不要从大范围类型的数强转成小类型的数，可能会产生数据丢失。例：
0是假，非0是真这句话在Java中不适用，boolean类型只有两个值——true和false。
以下这种代码在Java中就是错误代码，括号中必须是布尔表达式。
int a = 0; if (a) { System.out.println(a); } 下面的代码出现错误的原因是数据类型低于四个字节时，在运算时会提升为4个字节，详细点来说就是a和b在运算的时候会提升成四个字节，相加后的结果就是一个四个字节的数，而byte的字节大小为1，所以会出现不兼容的警告出现。这就体现了Java代码的严谨性。
使用“ + ”可以对字符串进行拼接，并且字符串没有所谓的“ \0 ”结尾的说法！
2.常用的数据输入： 整数类型 (int, long, short, byte)：
使用 Scanner 类的 nextInt() 方法来输入整数。如果需要输入长整型 (long)，则可以使用 nextLong() 方法。如果需要输入短整型 (short)，则可以使用 nextShort() 方法。如果需要输入字节 (byte)，则可以使用 nextByte() 方法。 Scanner scanner = new Scanner(System.in); int intValue = scanner.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8df5081e130de276d6afa52811d6547e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d81c2b88a62fe63f5384a5c23c047de8/" rel="bookmark">
			Oracle的数据备份与恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle的数据备份与恢复_oracle数据库备份和恢复命令-CSDN博客
目录
一、数据备份与恢复方式
二、备份与恢复的策略
三、备份与恢复的步骤
Ⅰ、备份：
Ⅱ、恢复：
四、数据迁移
Ⅰ、数据迁移的方法：
Ⅱ、数据迁移的步骤：
五、简单实用的备份实例
Ⅰ、使用RMAN工具
Ⅱ、备份表
Ⅲ、单独备份表或用户
在《Oracle数据库的数据备份http://t.csdn.cn/9aL0Z》中描述了数据备份的类型以及方式，那么此节就再描述下数据备份的些许方式以及数据恢复！！！
一、数据备份与恢复方式
备份和恢复都是数据库管理中非常重要的任务，用于保护数据库免受故障和灾难的影响。在Oracle数据库中，备份和恢复可以通过多种方式实现。
一种常见的备份方式是使用Oracle RMAN（Recovery Manager）工具进行备份。RMAN可以创建全备份、增量备份和归档日志备份等多种备份类型，可以将备份数据存储在磁盘、磁带等多种介质上。
在恢复数据时，可以使用RMAN工具执行恢复操作。如果数据库无法启动，可以使用恢复目录和备份集创建一个临时的控制文件，以便进行数据库恢复。RMAN还支持基于时间点的恢复，可以将数据库恢复到指定的时间点或SCN（System Change Number）。关于RMAN工具的使用方法可以参考下http://t.csdn.cn/QdoWb这篇文章！！！
除了RMAN，还可以使用Oracle Data Pump和Oracle Export/Import工具进行备份和恢复。这些工具可以将数据库对象导出到文件中，并在需要时将其导入到数据库中。
注意：
备份和恢复操作需要谨慎处理，避免数据丢失和损坏。必须对备份数据进行定期测试和验证，以确保备份数据的完整性和可用性。同时，需要根据具体情况选择合适的备份策略和恢复方案，以最大程度地保护数据库数据。
二、备份与恢复的策略
数据库备份和恢复策略是保障数据库系统数据安全和可靠性的重要措施。以下是常用的策略：
1.定期备份：
定期备份是数据库备份的基本措施。可以根据业务需求和数据变化情况定期备份数据库，一般选择在非高峰期进行备份。
2.全量备份和增量备份：
全量备份和增量备份是备份数据的两种方式。全量备份将整个数据库备份到备份设备上，而增量备份只备份自上次全量备份以来新增或修改的数据。增量备份相比全量备份可以节省备份时间和备份设备的空间。
3.备份设备的选择：
备份设备的选择对备份和恢复的效率有着重要的影响。可以选择磁带、硬盘、网络存储等设备作为备份设备，根据备份数据的大小和备份时间的要求选择合适的备份设备。
4.备份数据的加密和压缩：
备份数据的加密和压缩可以保障备份数据的安全性和节约备份设备的空间。可以通过使用加密软件和压缩工具来实现备份数据的加密和压缩。
5.恢复测试：
恢复测试是验证备份和恢复策略是否可靠的重要步骤。可以选择一些关键数据进行恢复测试，验证备份和恢复的可行性和正确性。
总结：
1. 完全备份策略：将数据库的所有数据和日志备份到磁盘或磁带上。
2. 增量备份策略：只备份上次完全备份之后新增或修改的数据和日志。
3. 差异备份策略：只备份上次完全备份之后新增或修改的数据和日志变化的部分。
4. 归档日志备份策略：备份数据库的归档日志文件，以保证在恢复时能够完整地恢复数据库。
5. 热备份策略：使用Oracle的在线备份功能，将数据库的数据和日志备份到磁盘上，同时保证数据库正常运行。
6. 冷备份策略：在数据库停止运行时，将数据库的数据和日志备份到磁盘上。
7. 基于快照的备份策略：使用存储设备的快照功能，将数据库的数据和日志备份到快照上。
8. 恢复测试策略：定期进行恢复测试，以确保备份和恢复过程的有效性和可靠性。
总之，数据库备份和恢复策略是保障数据库系统数据安全和可靠性的重要措施。通过合理的备份和恢复策略，可以保障数据库系统的稳定性和可靠性，避免数据丢失和系统宕机等问题。
三、备份与恢复的步骤
可以通过以下步骤进行备份和恢复：
Ⅰ、备份：
1. 确定备份类型：
完全备份、增量备份、差异备份、归档日志备份、热备份、冷备份、基于快照的备份等。
2. 创建备份脚本：
根据备份类型选择相应的备份脚本，设置备份路径、备份文件名、备份类型等参数。
完全备份脚本：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d81c2b88a62fe63f5384a5c23c047de8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/762d7a0f4addd59330aff0340f867746/" rel="bookmark">
			提取b站字幕（视频字幕、AI字幕）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提取b站字幕（视频字幕、AI字幕） 打开视频按 F12 进行开发者界面 视频自己的紫米输入的是 json，如果是AI字幕则需要输入 ai_subtitle
3. 进入这个网址：https://www.dreamlyn.cn/bsrt
文字步骤 先把up的字幕提取工具链接打开打开想要提取字幕的b站视频F12打开开发者工具点击网络，并刷新页面在筛选器里输入命令：ai_subtitle打开b站的AI字幕：中文（中国）红色的 { ; }符号+一串数字 就是目标，点击它的名称点击响应，再点击响应下的内容部分，ctrl+A全选，然后复制到牧尘的B站字幕转换网站那么一粘贴，还可以直接生成txt格式，直接下载完事。 https://nav.dreamlyn.cn/
补充一点，对于没有外挂字幕的视频，可以在视频中输入json过滤的地方输入ai_subtitle，来获取AI自动生成字幕的json数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e93d7958a103e1aacdd4a507cb3cb381/" rel="bookmark">
			Android Studio kotlin 转 Java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一. 随笔记录 java代码可以转化成kotlin代码，当然 Kotlin 反过来也可以转java
在Android Studio中 可以很方便的操作
AS 环境：Android Studio Iguana | 2023.2.1 二. 操作步骤 1.步骤 顶部Tools -----&gt;Kotlin ------&gt;Show Kotlin Bytecode
步骤2：kotlin文件转为字节码 显示如图：
步骤3：点击插件窗口左上角Decompile 按钮，就会反编译为Java文件
代码转化率90%左右，剩下的需要自己调整一下代码格式。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6937e4ce1108ff9f577bfdc49b7c41e/" rel="bookmark">
			【练习】分治--快排思想
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎥 个人主页：Dikz12🔥个人专栏：算法(Java)📕格言：吾愚多不敏，而愿加学欢迎大家👍点赞✍评论⭐收藏 目录
颜色分类
题目描述 题解 代码实现
排序数组
题目描述 题解
代码实现 数组中的第k个最大元素
题目描述 题解
​编辑 代码实现
库存管理III( 最小k个数)
题目描述 ​编辑 题解
代码实现 分治：分而治之. 颜色分类 题目描述 题解 解法：三指针（数组分三块）.
代码实现 public void sortColors(int[] nums) { int i = 0, left = -1, right = nums.length; while(i &lt; right) { if (nums[i] == 0) { swap(nums,++left,i++); } else if (nums[i] == 1) { i++; }else { swap(nums,--right,i); } } } public void swap(int[] nums, int i , int j) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; } 排序数组 题目描述 题解 解法：快速排序（数组分三块+随机选择基准）.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6937e4ce1108ff9f577bfdc49b7c41e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/576ef81815face9f0d279cd4a50b7101/" rel="bookmark">
			其它高阶数据结构②_图（概念&#43;存储&#43;遍历&#43;最小生成树）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 图的概念
2. 图的存储结构
2.1 邻接矩阵（后面算法所用）
2.2 邻接表
3. 图的遍历
3.1 BFS广度优先遍历
3.2 DFS深度优先遍历
4. 最小生成树
4.1 Kruskal算法
4.2 Prim算法
本篇完。
1. 图的概念 图是由顶点集合及顶点间的关系组成的一种数据结构：G = (V， E)，其中：
顶点集合V = {x|x属于某个数据对象集}是有穷非空集合；E = {(x,y)|x,y属于V}或者E = {&lt;x, y&gt;|x,y属于V &amp;&amp; Path(x, y)}是顶点间关系的有穷集合，也叫做边的集合。(x, y)表示x到y的一条双向通路，即(x, y)是无方向的；Path(x, y)表示从x到y的一条单向通路，即Path(x, y)是有方向的。顶点和边：图中结点称为顶点，第i个顶点记作vi。两个顶点vi和vj相关联称作顶点vi和顶点vj之间有一条边，图中的第k条边记作ek，ek = (vi，vj)或&lt;vi，vj&gt;。有向图和无向图：在有向图中，顶点对&lt;x, y&gt;是有序的，顶点对&lt;x，y&gt;称为顶点x到顶点y的一条边(弧)，&lt;x, y&gt;和&lt;y, x&gt;是两条不同的边，比如下图G3和G4为有向图。在无向图中，顶点对(x, y)是无序的，顶点对(x,y)称为顶点x和顶点y相关联的一条边，这条边没有特定方向，(x, y)和(y，x)是同一条边，比如下图G1和G2为无向图。注意：无向边(x, y)等于有向边&lt;x, y&gt;和&lt;y, x&gt;。 完全图：在有n个顶点的无向图中，若有n * (n-1)/2条边，即任意两个顶点之间有且仅有一条边，则称此图为无向完全图，比如上图G1；在n个顶点的有向图中，若有n * (n-1)条边，即任意两个顶点之间有且仅有方向相反的边，则称此图为有向完全图，比如下图G4。 邻接顶点：在无向图中G中，若(u, v)是E(G)中的一条边，则称u和v互为邻接顶点，并称边(u,v)依附于顶点u和v；在有向图G中，若&lt;u, v&gt;是E(G)中的一条边，则称顶点u邻接到v，顶点v邻接自顶点u，并称边&lt;u, v&gt;与顶点u和顶点v相关联。顶点的度：顶点v的度是指与它相关联的边的条数，记作deg(v)。在有向图中，顶点的度等于该顶点的入度与出度之和，其中顶点v的入度是以v为终点的有向边的条数，记作indev(v);顶点v的出度是以v为起始点的有向边的条数，记作outdev(v)。因此：dev(v) = indev(v) + outdev(v)。注意：对于无向图，顶点的度等于该顶点的入度和出度，即dev(v) = indev(v) = outdev(v)。路径：在图G = (V， E)中，若从顶点vi出发有一组边使其可到达顶点vj，则称顶点vi到顶点vj的顶点序列为从顶点vi到顶点vj的路径。路径长度：对于不带权的图，一条路径的路径长度是指该路径上的边的条数；对于带权的图，一条路径的路径长度是指该路径上各个边权值的总和。 带权图示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/576ef81815face9f0d279cd4a50b7101/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eefd4e070bf33107670abebdcba6bc47/" rel="bookmark">
			【C&#43;&#43;】从零开始构建二叉搜索树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		送给大家一句话：
我们始终有选择的自由。选错了，只要真诚的反思，真诚面对，也随时有机会修正错误和选择。
– 《奇迹男孩(电影)》
💻💻💻💻💻💻💻💻
💗💗💗💗💗💗💗💗
⚜️从零开始构建二叉搜索树⚜️ ✅1 前言✅2 二叉搜索树（BST）2.1 什么是二叉搜索树2.2 二叉搜索树的功能 ✅3 实现二叉搜索树3.1 整体框架3.2 插入功能3.3 中序遍历3.4 搜索功能3.5 删除操作 ✅4 应用一下Thanks♪(･ω･)ﾉ谢谢阅读！！！下一篇文章见！！！ ✅1 前言 在之前初阶数据结构的篇章中，我们学习过二叉树的基础知识稍微复习一下：
二叉树的度不超过 2二叉树可以通过数组或链表结构记录（左孩子右兄弟法） 普通的二叉树没有特别的性质，今天我们就来赋予其一个全新的性质来满足高速搜索的需求 ，并为后序的map与set做铺垫 ，二叉搜索树的特性了解，有助于更好的理解map和set的特性
✅2 二叉搜索树（BST） 2.1 什么是二叉搜索树 二叉搜索树又称二叉排序树（BST），它或者是一棵空树，或者是具有以下性质的二叉树:
若它的左子树不为空，则左子树上所有节点的值都小于根节点的值若它的右子树不为空，则右子树上所有节点的值都大于根节点的值它的左右子树也分别为二叉搜索树注意通常二叉搜索树不会有相同的键值 这些性质使得二叉搜索树成为一种高效的搜索工具。在大部分情况下，对于包含 n 个节点的二叉搜索树，搜索、插入和删除等操作的时间复杂度为 O(logn)。然而，在某些情况下，二叉搜索树可能会出现不平衡的情况，导致时间复杂度激增至 O(n)。为了解决这个问题，出现了进阶版的 AVL 树和红黑树。
AVL 树 和 红黑树 都是在保持二叉搜索树基本性质的基础上，通过旋转和重新平衡等操作，确保树的高度保持在一个相对平衡的状态，从而保证了操作的时间复杂度始终为 O(logn)。它们的出现大大提高了二叉搜索树在实际应用中的性能和稳定性。
我们常常会选择使用 AVL 树或红黑树来解决搜索问题。
今天，我们主要来学习二叉搜索树，为后序的学习打好基础！！！
2.2 二叉搜索树的功能 二叉搜索树（Binary Search Tree, BST）是一种非常实用的数据结构，用于存储具有可比较键的数据项。其功能和应用场景非常广泛，主要包括以下几点：
✨核心功能✨
🎈搜索：提供高效的搜索功能，允许快速查找特定键值的数据项。如果树保持平衡，搜索的平均时间复杂度可以保持在 O(log n)。🎈插入和删除：允许在保持树结构的前提下添加和移除节点。插入和删除操作也尽量维持树的平衡，以避免性能下降。🎈排序：可以中序遍历二叉搜索树以获得有序的数据序列，这对于数据排序和报表生成等功能非常有用。 ✨应用场景✨
🎈数据库管理系统：许多数据库索引就是使用二叉搜索树或其变种（如B树、红黑树）来实现的，以便快速地查询和更新数据。🎈符号表应用：在编译器实现中，二叉搜索树可以用来构建和管理符号表，以支持变量名的快速查找和属性的存取。🎈优先队列实现：通过特定方式实现的二叉搜索树（如二叉堆），可以用于实现优先队列，支持快速插入元素和删除最小或最大元素的操作。 接下来我们就根据其性质，来实现二叉搜索树 ❗ ❗ ❗
✅3 实现二叉搜索树 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eefd4e070bf33107670abebdcba6bc47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21f432f3099ce9d012076089fc7cf731/" rel="bookmark">
			linux系统安装kafka（新版本3.7.0）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux系统安装kafka 1、安装包下载2、安装3、配置zookeeper.properties4、配置server.properties5、启动6、测试使用7、停止服务 1、安装包下载 wget https://downloads.apache.org/kafka/3.7.0/kafka_2.13-3.7.0.tgz 注意事项：kafka会用到jdk，kafka_2.13-3.7.0版本的kafka不再支持jdk8，我这里用的jdk11
openjdk11下载1：https://mirrors.tuna.tsinghua.edu.cn/Adoptium/11/jdk/x64/linux/
openjdk11下载2：https://learn.microsoft.com/zh-cn/java/openjdk/download
我的解压目录/usr/local/jdk-11.0.23+9
2、安装 我安装到 /usr/local目录下了 cs /usr/local #解压 tar -xzf kafka_2.13-3.7.0.tgz cd kafka_2.13-3.7.0 首先要启动ZooKeeper服务，因为Kafka使用ZooKeeper，新版本中kafka集成了zookeeper
3、配置zookeeper.properties 配置kafka_2.13-3.7.0/config下的“zookeeper.properties”：
修改dataDir和clientPort：前者是快照存放地址(自己随意配置)，后者是客户端连接zookeeper服务的端口。默认端口2181
#创建一个目录 mkdir zookeeper-data #修改文件路径为： dataDir=/usr/local/kafka_2.13-3.7.0/zookeeper-data 截图如下：
4、配置server.properties 配置kafka_2.13-3.7.0/config下的“server.properties”：
修改log.dirs和zookeeper.connect。前者是日志存放文件夹，后者是zookeeper连接地址（端口和clientPort保持一致）
创建一个目录： mkdir kafka-logs 修改配置： #日志目录 log.dirs=/usr/local/kafka_2.13-3.7.0/kafka-logs #zookeeper连接地址 zookeeper.connect=localhost:2181 注意：若需要外部访问，一定需要配置listeners ， 默认为本机IP 、端口默认9092。
截图：
5、启动 由于我的服务器有其他程序用jdk8，并配置了环境变量，所以在启动之前，我要修改脚本中使用jdk的路径：
修改：kafka-run-class.sh
在文件开始位置指定JAVA_HOME位置，文件中会用到
export JAVA_HOME=/usr/local/jdk-11.0.23+9 截图：
# 后台启动zookeeper，指定启动日志 nohup ./bin/zookeeper-server-start.sh ./config/zookeeper.properties &gt; ./zookeeper-run.log 2&gt;&amp;1 &amp; # 后台启动kafka，指定启动日志 nohup ./bin/kafka-server-start.sh ./config/server.properties &gt; ./kafka-run.log 2&gt;&amp;1 &amp; 现在，Kafka单机版已经安装并运行。你可以使用内置的命令行工具来创建主题、生产消息和消费消息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21f432f3099ce9d012076089fc7cf731/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/030bd57f57a0b250df592157590e81a0/" rel="bookmark">
			利用llama.cpp量化部署Llama-3-Chinese-8B-Instruct大模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关大模型项目：https://github.com/ymcui/Chinese-LLaMA-Alpaca-3
量化部署是将机器学习模型压缩以减少内存占用和计算成本的过程。本文将详细介绍如何使用llama.cpp工具进行模型量化并在本地部署。
环境准备 首先，确保你的系统满足以下要求：
编译工具：
MacOS/Linux：自带makeWindows：需自行安装cmake Python：
建议使用Python 3.10及以上版本 此外，推荐使用经过指令精调的Llama-3-Chinese-Instruct模型，并选择6-bit或8-bit的量化版本，以获得最佳效果。
步骤一：克隆和编译llama.cpp 重要提示：llama.cpp在2024年4月30日对Llama-3 pre-tokenizer进行了重大改动，请务必拉取最新代码进行编译。
如果你已下载旧版仓库，建议执行以下命令更新代码并清理旧文件：
$ git pull $ make clean 克隆最新版llama.cpp仓库代码：
$ git clone https://github.com/ggerganov/llama.cpp 编译llama.cpp项目，生成./main（用于推理）和./quantize（用于量化）二进制文件：
$ make 启用GPU推理：
Windows/Linux用户：可与BLAS（或cuBLAS）一起编译，以提高处理速度。以下是与cuBLAS一起编译的命令：
$ make LLAMA_CUDA=1 macOS用户：无需额外操作，llama.cpp已对ARM NEON进行优化，并默认启用BLAS。M系列芯片用户可使用Metal启用GPU推理，只需将编译命令改为：
$ LLAMA_METAL=1 make 步骤二：生成量化版本模型 你可以直接下载已量化好的GGUF模型：下载地址。
此外，llama.cpp支持将.safetensors文件和Hugging Face格式的.bin文件转换为FP16的GGUF格式。具体命令如下：
$ python convert-hf-to-gguf.py llama-3-chinese-8b-instruct $ ./quantize llama-3-chinese-instruct-8b/ggml-model-f16.gguf llama-3-chinese-8b-instruct/ggml-model-q4_0.gguf q4_0 步骤三：加载并启动模型 由于Llama-3-Chinese-Instruct模型使用了原版Llama-3-Instruct的指令模板，请将scripts/llama_cpp/chat.sh拷贝至llama.cpp的根目录。chat.sh文件内容如下，可根据需要进行修改：
FIRST_INSTRUCTION=$2 SYSTEM_PROMPT="You are a helpful assistant. 你是一个乐于助人的助手。" ./main -m $1 --color -i \ -c 0 -t 6 --temp 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/030bd57f57a0b250df592157590e81a0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/360/">«</a>
	<span class="pagination__item pagination__item--current">361/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/362/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>