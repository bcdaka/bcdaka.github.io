<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f0434dce3cf9064b565edba474aded2/" rel="bookmark">
			【数据结构】选择排序 &amp; 堆排序（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一，选择排序
1，基本思想
2， 基本思路
3，思路实现
二，堆排序
1，直接选择排序的特性总结：
2，思路实现
3，源代码
最后祝大家国庆快乐！
一，选择排序 1，基本思想 每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始（末尾）位置，直到全部待排序的数据元素排完 。
2， 基本思路 1，在元素集合 array[ i ] -- array[ n-1 ] 中选择关键码最大(小)的数据元素
2，若它不是这组元素中的最后一个(第一个)元素，则将它与这组元素中的最后一个（第一个）元素交换
3，在剩余的 array[ i ] -- array[ n-2 ]（array [ i+1] -- array [ n-1 ] ）集合中，重复上述步骤，直到集合剩余1个元素
直接选择排序的特性总结：
1. 直接选择排序思考非常好理解，但是效率不是很好。实际中很少使用
2. 时间复杂度：O(N^2)
3. 空间复杂度：O(1)
4. 稳定性：不稳定
3，思路实现 选择排序嘛，就是先遍历数组找出最大数和最小数，然后让最小数与首元素交换，最大数与末尾元素交换，当然啦在排序的过程中与之交换的 " 首元素 " 和 " 末尾元素 " 会一直变化的；
第一趟排序时，首元素是 arr [ 0 ] ，末尾元素是 arr [ n-1 ] ；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f0434dce3cf9064b565edba474aded2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61aa1715b12e0030f79a5fab3cccd5d0/" rel="bookmark">
			【腾讯云 TDSQL-C Serverless 产品体验】TDSQL-C MySQL Serverless实践之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【腾讯云 TDSQL-C Serverless 产品体验】TDSQL-C MySQL Serverless实践之路
腾讯云TDSQL-C联合CSDN推出了一款云数据库产品测评活动，让我们一起来体验一下。
一、什么是云数据库？ 云数据库是指被优化或部署到一个虚拟计算环境中的数据库，可以实现按需付费、按需扩展、高可用性以及存储整合等优势。
云数据库的特性有：实例创建快速、支持只读实例、读写分离、故障自动切换、数据备份、Binlog备份、SQL审计、访问白名单、监控与消息通知等。
1. 优势： 可以使用户按照存储容量和带宽的需求付费可以将数据库从一个地方移到另一个地方（云的可移植性）可实现按需扩展高可用性（HA） 1.1 轻松部署： 用户能够在控制台轻松的完成数据库申请和创建，数据库实例在几分钟内就可以准备就绪并投入使用。
1.2 高可靠： 云数据库具有故障自动单点切换、数据库自动备份等功能，保证实例高可用和数据安全。
1.3 低成本： 数据库支付的费用远低于自建数据库所需的成本，用户可以根据自己的需求选择不同套餐，使用很低的价格得到一整套专业的数据库支持服务。
云数据库发展经历了三个时代：
1.0时代是以云托管数据库为主2.0时代是容器架构的云原生数据库时代3.0时代，云Serverless数据库将成为主流趋势。 腾讯云数据库TDSQL-C Serverless新版发布，标志着云原生数据库Serverless化正式步入全面推进阶段。
二、TDSQL-C MySQL云数据库： TDSQL是腾讯云自研企业级分布式数据库，旗下涵盖金融级分布式、云原生、分析型等多引擎融合的完整数据库产品体系，提供业界领先的金融级高可用、计算存储分离、数据仓库、企业级安全等能力，同时具备智能运维平台、Serverless版本等完善的产品服务体系。
TDSQL，100%兼容MySQL和PostgreSQL，包含三大产品系列，分别为分析型数据库TDSQL-A（Tencent Analytical Database）、云原生数据库TDSQL-C （Tencent CloudNative Database）和分布式数据库TDSQL（Tencent DistributedDatabase），全方位满足各行各业的业务需求。
云原生数据库TDSQL-C MySQL，采用计算和存储分离（日志即数据库）的 Shared Storage 架构，融合了传统数据库、云计算与新硬件技术的优势，100%兼容 MySQL 等开源数据库，实现了超百万级 QPS 的吞吐，超百 TB 的海量分布式智能存储，能够很好地支撑大数据量的归档存储和高效查询性能。
三、TDSQL-C MySQL Serverless版本： Serverless 服务是腾讯云自研的新一代云原生关系型数据库 TDSQL-C MySQL 版的无服务器架构版，是全 Serverless 架构的云原生数据库。Serverless 服务支持按实际计算和存储资源使用量收取费用，不用不付费。
1. Serverless 服务架构： 按需启动，不需要时可关闭。自动扩展/收缩。缩放对应用程序无影响。 四、购买并开通TDSQL-C MySQL Serverless： 如下我们在选择数据库实例时，可以看到预置资源的MySQL，一年的费用是3250.94，就是说你哪怕是数据库没有使用，只要买了，就要付这么多的钱。那想像一下，我们在学校开发系统，只有白天才会使用，到了晚上的话、周未时间段，基本上没有使用的，这样买数据库的话，感觉十分的浪费。
但是我们切换Serverless来看一下，是按小时来收费的，不就是按量收费吗?这样是不是很符合我们的场景呢？
接下来的几个选项：
数据库版本，有5.7、有8.0，可以符合大部分的需求场景算力配置，CCU（TDSQL-C Compute Unit）为 Serverless 的计算计费单位，一个 CCU 近似等于1个 CPU 和 2GB 内存的计算资源，每个计费周期的 CCU 使用数量为：数据库所使用的 CPU 核数 与 内存大小的1/2 二者中取最大值。自动启停，数据库在该时间内没有连接和 CPU 使用时，将自动暂停，暂停后计算不计费，存储仍然按实际使用量计费。存储资源包，通过资源包，可以提前预留资源，而且，相对于按量付费方式，资源包可以帮助节省更多成本，资源包的购买容量越大，有效期越长，越划算。 我们可以看到存储的资源包也是比较便宜的，相对于传统MySQL的实例的空间要划算多了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61aa1715b12e0030f79a5fab3cccd5d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7b056ec7bf01e439c054f829e8bdc78/" rel="bookmark">
			【C&#43;&#43;】高精度模板大整合！高精度模板看这篇真的就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版本信息 版本号版本内容版本时间V 1.0.0 高精定义
高精加高精（普通+负数版）
高精减高精（普通+负数版）
高精乘高精（普通+负数版）
高精除高精（普通+负数版）
高精取模高精（普通+负数版）
高精加低精（普通版）
高精减低精（普通版）
高精乘低精（普通版）
高精除低精（普通版）
高精取模低精（普通版）
高精开根低精（普通版）
2023/9/29 开工
2023/9/30 完工
引语 大家好！本期我们来看一下高精度的C++代码
首先感谢一下那些为我提供帮助的人，主要包括CSDN和洛谷的好心人
制作不易，求支持qwq
正文 高精度定义 高精度算法（High Accuracy Algorithm）是处理大数字的数学计算方法。在一般的科学计算中，会经常算到小数点后几百位或者更多，当然也可能是几千亿几百亿的大数字。一般这类数字我们统称为高精度数，高精度算法是用计算机对于超大数据的一种模拟加，减，乘，除，乘方，阶乘，开方等运算。对于非常庞大的数字无法在计算机中正常存储，于是，将这个数字拆开，拆成一位一位的，或者是四位四位的存储到一个数组中， 用一个数组去表示一个数字，这样这个数字就被称为是高精度数。高精度算法就是能处理高精度数各种运算的算法，但又因其特殊性，故从普通数的算法中分离，自成一家。
——百度百科
高精度op高精度 高精度加法（高精度加高精度） 普通版 #include &lt;bits/stdc++.h&gt; using namespace std; // 函数名称:add // 函数参数:两个vector&lt;int&gt; // 函数返回值:一个vector&lt;int&gt; // 函数功能:返回输入的两个vector的和 // 中文名称:高精度加法 vector &lt;int&gt; add(vector&lt;int&gt; &amp;A,vector&lt;int&gt; &amp;B){ if (A.size() &lt; B.size()) return add(B,A); // 因为下面for循环用A.size()当条件，所以现在只能让A比B长 vector&lt;int&gt; C; int t = 0; for(int i = 0;i &lt; A.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7b056ec7bf01e439c054f829e8bdc78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d50e4916e6c7c1bd7324c5b4c93adb36/" rel="bookmark">
			【腾讯云 TDSQL-C Serverless 产品体验】基于TDSQL-C Serverless最佳实践助力企业降本增效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、业务增长MySQL带来的业务痛点分析： 1. 性能瓶颈： 随着公司的业务快速发展，数据库中的数据量猛增，访问性能也变慢了，单台MySQL实例无法应对和满足大规模数据管理和请求访问，导致数据库性能下降，成为瓶颈。关系型数据本身就比较容易形成系统瓶颈，无论是从单机存储容量、连接数、处理能力都有限。当单表的数据量达到1000W以后，由于查询和操作的维度较广，哪怕使用了MySQL从库读写分离、优化索引等操作时，性能还是无可避免严重下降。 2. 数据强一致性同步延迟： 当架构增加Redis、RabbitMQ等消息队列OLTP的大数据量统计数据类异构表同步只能满足业务的T+1系统架构中，异步设计方案中的中间件故障，导致数据重传、数据丢失 二、数据库应用的类型： Item区分OLAPOLTP1名称在线分析处理(Online Analytical Processing) 在线事务处理(Online Transaction Processing)2作用处理企业级的决策分析、战略分析以及业务分析等处理企业级的常规业务操作，如公司的采购、销售、存储、支付等3侧重点多维数据分析技术和聚合算法，方便分析数据强调数据的精确、事务的原子性和并发性4数据类型历史性、汇总性、非实时性、不可变性数据实时的、明细的、实时性的、可变性数据5场景数据仓库常规业务操作6查询模式采用复杂的算法和存储结构，如多维数据库和立方体结构需要简单的SQL语句，如基本的、事务相关的查询7性能要求更高的存储要求和处理能力快速且稳定的响应速度，可扩展性和高可用性8应用场景企业级的决策支持和战略分析等领域采购、销售、库存管理、银行交易等领域，极短的时间内快速响应用户请求，从而保证业务的正常运行 所以，在日常的企业级应用中，OLAP和OLTP针对不同的业务场景，有不同的解决方案。OLAP主要用于企业级决策和战略分析，需要快速的数据查询和分析技术。相反，OLTP主要用于企业日常操作，需要快速的数据更新和处理技术。
三、项目中的优化手段之《分库分表》： 1. 业务痛点： 由于数据量过大而导致数据库性能降低的问题 2. 解决的问题： 优化单一表数据量过大而产生的性能问题，使得单个表的数据量变小，提高检索性能，一定程度上可以缓解查询性能瓶颈避免IO争抢并减少锁表的几率解决业务层面的耦合，业务清晰能对不同业务的数据进行分级管理、维护、监控、扩展等高并发场景下，在一定程度的提升IO、数据库连接数、降低单机硬件资源的瓶颈有些系统中使用的“冷热数据分离”，备份历史库在高并发和海量数据的场景下，分库分表能够有效缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源的瓶颈 3. 带来新的问题： 跨库join（安全性等方面考虑，一般是禁止跨库join的）分布式事务业务复杂度增加投入的硬件成本也会更高跨分片的复杂查询，跨分片事务等跨节点关联查询跨节点多库进行查询时，limit分页，order by排序问题，就变得比较复杂主键避重，主键值ID无法保证全局唯一公共表、参数表、数据字典表等都是数据量较小，变动少，每个数据库都保存一份 四、TDSQL-C MySQL Serverless解决的痛点： TDSQL-C MySQL Serverless实例提供了CPU、内存的实时弹性能力，构建云上资源架构下的MySQL产品新形态。
1. 常规业务下的痛点： Item业务方案业务痛点Serverless实例解决方案1自建MySQL实例(1). 需要购买大量的云服务器构建MySQL集群，设备成本费用高
(2). 专人运维成本，部署业务
(3). 双11等活动时，提前负责服务的扩缩容(1). 按量收费，不使用不收费
(2). 云函数计算，从CI/CD到服务部署，扩缩容，全部自动完成，客户可以更专注于业务代码2传统的云数据库(1). 提供多种内存/CPU规格给用户购买
(2). 用户只能按最大负载量购买满负载配置，即使没有使用到，也需要为选中的规格付费(1). 自动扩缩容，访问量上来时自动扩容，降低时自动缩容，用户不需要关注规格
(2). 按照实际使用的资源付费
(3). 不使用不计费，如果没有访问，不应该收费 2. Serverless数据库特点： 举个场景：如果自己想要出行就只能购买汽车、摩托车，现在可以直接通过滴滴等第三方平台使用打车服务，只需输入目的地即可，不需要再关注买车的坑、开车怕被撞和汽车保养的问题，核心诉求得到了更好的满足。
Serverless数据库可以看做，直接在云上直接购买虚拟机，部署业务，负责服务的扩缩容，从CI/CD到服务部署，扩缩容，全部自动完成，用户只需要更专注于业务代码即可。
Serverless数据库的基本特点是无需运维、以API方式提供服务、按实际使用计费、无使用无费用等。
3. 在业务波动较大的场景下，普通实例和Serverless实例资源使用和规格变化情况如下图所示： 由上图可以看到，在业务波动较大的场景下：
Item数据实例资源低谷期资源高峰期灵活性1普通实例在低谷期浪费的资源较多在高峰期资源不足，业务受损比较固定的资源2Serverless实例在低谷期可以动态弹性释放不需要的资源，从而减少了资源浪费在高峰期也能完全满足业务需求，保证业务不受损，提高了系统的稳定性动态弹性伸缩能力 总结：由于Serverless实例的规格会随业务需求量随时调整，总体浪费的资源很少，提升了资源利用率，降低了资源使用量。
4. TDSQL-C MySQL Serverless的优势： Item优势项描述1更低的成本(1). 对于创业初期的企业，MySQL Serverless不依赖其它的基础设施和相关服务。
(2). 即买即用并可以提供稳定和高效的数据存取服务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d50e4916e6c7c1bd7324c5b4c93adb36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd14205301d7bbb85bd276f3eeabff0f/" rel="bookmark">
			mysql的mvcc详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 MVCC的作用 1.1 mvcc的作用 1.MVCC（Multiversion Concurrency Control）多版本并发控制。即通过数据行的多个版本管理来实现数据库的并发控制，使得在InnoDB事务隔离级别下执行一致性读操作有了保障。
2.mysql中的InnoDB中实现了MVCC主要是为了提高数据库的并发性能，在无锁的情况下也能处理读写并发，大大提高数据库的并发度。
3..MySQl中只有InnoDB支持MVCC，其他存储引擎不支持
4.为了查询一些正在被其他事务更新的值的时候，能够查到它们被更新之前的值，这样做就能在查询的时候不必等待更新事务的提交。
在InnoDB中，会对增删改操作自动添加排它锁，因此两个事务不会出现脏写的情况，也就是不会出现两个事务交叉着对同一条记录进行修改，必须等待第一个事务提交才能进行第二个事务。
1.2 快照读与当前读的区别与联系 1.MVCC在InnoDB中的实现主要是为了提高数据库的并发性能，用更好的方式处理读写冲突，做到即使有读写冲突，也能不加锁实现非堵塞并发读，这个读指的是快照读而不是当前读。
2.当前读实质上是一种加锁的操作，是悲观锁的体现；而MVCC是采用乐观锁的一种方式
1.3 快照读 1.快照读，顾名思义读取的是一份快照数据，所以读到的并不一定是最新数据，可能是历史数据。
2.简单的select查询就是快照读，不加锁非阻塞读，降低数据库的开销。
3.但是快照读在隔离级别是串行化级别是没有意义的，因为串行化的sql都是排队执行的，不存在并发，所以就会变成当前读。
1.4 当前读 当前读获取的数据是最新数据，而且在读取时不能被其他修改的，所以会对读取的记录加锁来控制。
加锁的SELECT（共享或排它锁）或者对数据进行增删改操作（自动添加排它锁）都会进行当前读。
select * from ajisun where id &gt; 1 lock in share mode;// 或者select * from ajisun where id &gt;1 for update; 1.5 mvcc可以解决问题 读写之间的堵塞问题，提高事务的并发读写能力
降低了死锁的概率，MVCC采用了乐观锁的方式，读取数据的时候不需要加锁，对于写操作，也只要锁定必要的行
解决快照读问题，当查询数据库某个时间节点的快照的时候，只能查看到在这个节点之前提交的事务的结果而看不到时间点之后事务提交的更新结果
1.6 mvcc面试题：mvcc是怎么实现的 mvcc 是多版本并发控制，通过生成记录的历史版本解决幻读问题，并提高数据库的性能，无锁实现读写并发操作。
1.mvcc 的实现主要是通过三个隐藏字段，undo log以及readView 实现的。
2.三个隐藏字段分别是隐藏主键，事务ID，回滚指针。
3.undo log是各个事务修改同一条记录的时候生成的历史记录，方便回滚，同时会生成一条版本链。
4.readView是事务在进行快照读的时候生成的记录快照，用于判断数据的可见性。
5.描述readView 可见性判断规则。
二 MVCC实现原理 2.1 原理 ​ MVCC的实现依赖于：隐藏字段、Undo log、Read View 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd14205301d7bbb85bd276f3eeabff0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee8ed62200758c9ae925d56e186f2cd8/" rel="bookmark">
			Oracle物化视图（Materialized View）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		与Oracle普通视图仅存储查询定义不同，物化视图（Materialized View）会将查询结果"物化"并保存下来，这意味着物化视图会消耗存储空间，物化的数据需要一定的刷新策略才能和基表同步，在使用和管理上比普通视图要略复杂。
目录
一、物化视图简介
1.1 物化视图应用场景
1.2 物化视图的类型
二、物化视图创建
2.1 通过语句创建物化视图
2.2 通过注册创建物化视图
三、物化视图刷新
3.1 刷新类型
3.1.1 全量刷新（refresh complete）
3.1.2 增量刷新（refresh fast）
3.2 刷新模式
3.2.1 手动刷新（on demand）
3.2.1.1 使用dbms_mview.refresh刷新指定物化视图
3.2.1.2 使用dbms_mview.refresh_all_mviews刷新所有物化视图
3.2.1.2 使用dbms_mview.refresh_dependent刷新某基表上的所有物化视图
3.2.2 事务级自动刷新（on commit）
3.2.3 语句级自动刷新（on statement）
3.2.4 定期刷新（start with … next）
四、查询重写
一、物化视图简介 物化视图主要用在OLAP环境，可以提前运行大量运算并保存结果，为后续查询加速。
1.1 物化视图应用场景 为什么要使用物化视图？假设一个场景，用户每天都需要分析销售数据，而每天产生的数据量都非常庞大，在原始数据上直接运行查询SQL（例如进行sum，avg的操作），速度会非常缓慢。传统的查询优化手段，例如索引、分区、并行执行等，在这种场景下都无法将速度提升到一个可接受的范围。
对于这种问题，传统的解决方案是建立一张中间表，提前运行查询SQL并将结果保存下来，当用户查询的时候直接查询结果表。此解决方案虽然可以大幅提升相应时间，但也存在两个问题：
对于应用，原先访问的是基表，现在需要访问结果表，意味着应用代码需要修改。结果表需要手动的刷新，如果需要频繁的全量刷新很麻烦。 而利用Oracle物化视图则可以完美解决上述问题：
物化视图也是预先计算出结果并保存，利用"查询重写"（Query Rewirte）的特定，优化器如果发现可以通过物化视图提升速度，那么会直接改写原SQL，转而查询物化视图，这个操作对应用和用户是完全透明的（应用不需要知道物化视图的存在）。物化视图有各种刷新策略，可以很好的适应复杂的数据刷新场景。 1.2 物化视图的类型 物化视图根据其查询SQL的特点，可以分为下面3类：
聚合物化视图，查询定义中包含例如sum(), avg(), count()等聚合函数，这类视图用来预先计算统计数据。连接物化视图，查询定义中不包含聚合函数，仅包含连接，这类视图用来预先计算一些高成本的连接。嵌套物化视图，查询定义中引用了其他的物化视图，这类视图通常用来作为一些大物化视图的中间结果集，可以被多个物化视图重复引用，以防止类似的结果集在多个物化视图中重复计算很多次。 二、物化视图创建 物化视图可以通过create materialized view语句直接创建，如果你已经在使用中间表，也可以将其注册为物化视图。
2.1 通过语句创建物化视图 物化视图是通过 create materialized view 语句创建的，在创建时可以指定物化视图的特性。我们以Oracle自带的sample schema下SH用户下的sales和customers表为示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee8ed62200758c9ae925d56e186f2cd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13201c958c4140ec2ed5975f91b4d6e9/" rel="bookmark">
			【数据结构】深度剖析最优建堆及堆的经典应用 - 堆排列与topk问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚩纸上得来终觉浅， 绝知此事要躬行。
🌟主页：June-Frost
🚀专栏：数据结构
🔥该文章分别探讨了向上建堆和向下建堆的复杂度和一些堆的经典应用 - 堆排列与topk问题。
❗️该文章内的思想需要用到实现堆结构的一些思想（如向上调整和向下调整等），可以在另一篇文章《堆的顺序实现》中再次了解一下，其中一些接口有具体的实现💖。
目录： 🌍 建堆🔭 向下建堆✈️时间复杂度 🔭 向上建堆✈️时间复杂度 🌎 堆的经典应用🔭 堆排序🔭TOPK问题 ❤️ 结语 🌍 建堆 建堆的常见方式有两种：向上建堆和向下建堆。
🔭 向下建堆 这些交换其实就是向下调整的过程，所以向下建堆只要通过不断的向下调整就可以实现。
int arr[] = { 10,20,25,35,60,36,15 }; int n = sizeof(arr) / sizeof(arr[0]); int i = 0; for (i = (n - 1 - 1) / 2; i &gt;= 0; i--) { AdjustDown(arr, n, i);//向下调整 } ✈️时间复杂度 将每层数据个数 * 向下移动的层数求和，得到 T(h) = 2(h-2)*1 + 2(h-3)*2+…+21 *(h-2) + 20 *(h-1) 。通过错位相减，可以得到T(h) = 2h-1-h。因为是满二叉树，所以假设节点为N，则N = 2h - 1 , h = log2(N+1) ，将h换为N，可以得到向下调整建堆合计调整次数 T(N) = N-log(N+1)，所以时间复杂度为： O(N) 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13201c958c4140ec2ed5975f91b4d6e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19e431e9ac035f807585d617f69932cc/" rel="bookmark">
			python经典百题之static定义静态变量的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目: 学习 static 定义静态变量 程序分析 在Python中，“static”（静态变量）的概念通常与类的属性相关联。虽然Python没有严格的静态变量概念，但可以通过类属性或模块级变量来模拟静态变量的功能。我们将探讨三种不同的方法来模拟静态变量，以及各种方法的解题思路、优缺点。
解题思路 我们将介绍三种模拟静态变量的方式：
类属性：通过类的属性来模拟静态变量。类的所有实例共享这些属性，类似于静态变量的概念。类方法：通过类方法来模拟静态变量。在类方法中使用类变量来实现静态变量的效果。装饰器：使用装饰器来模拟静态变量。通过装饰器的方式将函数转换为类的静态方法，实现静态变量的效果。 方法一：类属性 解题思路 在类中定义一个类属性，所有类的实例都可以访问该类属性，模拟静态变量的效果。 优点： 实现简单，易于理解和使用。 缺点： 需要注意共享属性可能被修改的情况。 class MyClass: static_variable = 10 # 类属性 def __init__(self, value): self.value = value def print_values(self): print("Static variable:", MyClass.static_variable) print("Instance variable:", self.value) # 访问类属性 print(MyClass.static_variable) # 输出: 10 # 创建实例 obj1 = MyClass(20) obj2 = MyClass(30) # 访问实例属性和类属性 obj1.print_values() obj2.print_values() 方法二：类方法 解题思路 在类中定义一个类方法，通过该方法访问类变量，模拟静态变量的效果。 优点： 不同于实例方法，类方法中可以访问类级别的属性，实现了静态变量的效果。 缺点： 需要额外的类方法来访问静态变量，可能略显繁琐。 class MyClass: static_variable = 10 # 类属性 def __init__(self, value): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19e431e9ac035f807585d617f69932cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/807032d133299062c1a3dc7f8c10df2d/" rel="bookmark">
			IDEA运行第一个Java简单程序（新建项目到运行类）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、准备工作
JDK下载安装
1.IDEA下载安装
二、IDEA建立项目
（一）新建项目（银河系）
（二）新建模块（地球）
（三）新建包（国家）
（四）新建类（省份）
（五）新建main方法（省会城市）
（六）新建方法（楼层）
运行类
额外讲解
前言 在刚开始学习Java中，会遇到许多的问题，分不清类和包，对象方法这些概念，很多名称都是一个概念而已，真正去运用多测试写几遍就会悟出来，一直想是属于空想了，代码必须要真正的去敲，去行动。本篇文章就是给刚学习Java的小伙伴建立一个结构性的一点思维。从建立项目到建立类这些步骤都详细有。有什么问题欢迎指出 一、准备工作 要运行Java程序，必须要有软件去运行，常用的软件就是IDEA，还要有能够让我们的Java程序去运行的环境--KDK，这些环境就是Java虚拟机啊这些。IDEA就是一把弓箭，JDK就是箭，缺少了箭肯定不能去正常使用，所以这两个要装起来。
JDK和IDEA都有的就这个跳过这个步骤
JDK下载安装 官网下载JAVA的JDK11版本（下载、安装、配置环境变量）_java11下载-CSDN博客
1.IDEA下载安装 idea2023版本下载安装配置与卸载详细步骤（包含运行第一个java程序教程）_idea2022_云边的快乐猫的博客-CSDN博客
二、IDEA建立项目 （一）新建项目（银河系） 1.打开主菜单
2.新建项目
新建项目就像你新建一个银河系一样
ps：idea需要中文界面的看这个
idea中国人能看懂的方法_idea汉化插件_云边的快乐猫的博客-CSDN博客
3.点击空项目，给这个项目命名一下，位置可以自定义，最好全部英文的位置。然后点击创建
4.点击此窗口和新窗口打开都可以
（二）新建模块（地球） 接下来就是新建一个地球（模块）
4.点击建立好的项目。右键--新建--新模块
5.这个模块的名称可以自定义，位置不用改动。语言选Java，系统默认的IntelliJ，JDK会自动检测你的JDK给你选择，这个一般也不用动，然后创建
6.在创建完模块后，IDEA会自动给你创建一个包和一个类，并且方法也帮我们写好了，点击这个就可以直接运行，下面的控制台也会出运行结果
（三）新建包（国家） 7.包是在模块的里面的，这里选择在src包下再去新建一个包，当然了，你也可以在模块的下面去新建一个包。都是一样的。个人习惯在src包下新建
以后学到炉火纯青就会在模块下直接新建包了，没有src了，现在可以先按照我的方式来
8.不知道命名为什么，暂且命名为bao吧
9.这个包就建立好了
（四）新建类（省份） 10.点击bao这个包，右键--新建--类
11.这个类命名为aa吧，回车键建立
12.类建立完成
（五）新建main方法（省会城市） 在类建立完成后，要有个入口方法去加载运行这个类，这个就是main方法，也是一个省份的代表负责带头大哥，没有这个main，这个类里面就运行不起来
13.在包的{}里面打上这个main，都会有提示的，出现main就回车就好了，IDEA就会帮我们写好了main方法。
14.main方法建立完成，有了这个main方法，这个类才算激活能去运行，要不然这个类是运气不起来的 （六）新建方法（楼层） 15.在main方法的里面去编写自己想要写的方法
System.out.println();
这个是打印语句，在()里面的内容运行了后，会显示在下面的控制台，写这个语句的快捷方式就是打sout出现提示就回车键就好了
运行类 点击这个运行，然后控制台下面就会显示运行的结果
额外讲解 在Java的前面学习中，一般要写新的代码就直接新建一个类，然后在类里面去写上main方法，再在main方法里面去写自己要写的代码就好了，没有main方法，这个类就运行不起来的
怕混乱的话，可以再建立个包，然后再新建类也可以，这些都是嵌套关系的，不能乱
项目--模块--包---类--main方法--自己的方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4feef463885850bb988f64e34d0e89b2/" rel="bookmark">
			【链表】还不会用C&#43;&#43;实现链表？一文教会你各种链表的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文将用C++语言来实现数据结构中的无头单链表，带头循环链表，以及带头循环双向链表等链表结构（带头单链表与后两种链表的结构相似，实现起来比后两种更简单，读者阅读完本文即可自行实现）
一、无头单链表的实现 无头单链表在头插时需要改变头指针的位置，具体代码实现如下：
//无头单链表 #include &lt;iostream&gt; #include &lt;assert.h&gt; using namespace std; template &lt;class T&gt; //先定义链表中的节点 struct SListNode { T data; SListNode* next; SListNode(T x) { this-&gt;data = x; this-&gt;next = nullptr; } }; template &lt;class T&gt; class SList { private: //链表初始化后链表中就有一个节点 SListNode&lt;T&gt;* head; public: SList(T x) { this-&gt;head = new SListNode&lt;T&gt;(x); } ~SList() { SListNode&lt;T&gt;* cur = head; while (cur) { SListNode&lt;T&gt;* next = cur-&gt;next; delete cur; cur = next; } } // 动态申请一个节点 SListNode&lt;T&gt;* BuySListNode(T x); // 单链表打印 void SListPrint(); // 单链表尾插 void SListPushBack(T x); // 单链表的头插 void SListPushFront(T x); // 单链表的尾删 void SListPopBack(); // 单链表头删 void SListPopFront(); // 单链表查找 SListNode&lt;T&gt;* SListFind(T x); // 单链表在pos位置之后插入x void SListInsertAfter(SListNode&lt;T&gt;* pos, T x); // 单链表删除pos位置之后的值 void SListEraseAfter(SListNode&lt;T&gt;* pos); }; template &lt;class T&gt; SListNode&lt;T&gt;* SList&lt;T&gt;:: BuySListNode(T x) { SListNode&lt;T&gt;* tmp = new SListNode&lt;T&gt;(x); tmp-&gt;next = nullptr; return tmp; } template &lt;class T&gt; void SList&lt;T&gt;::SListPrint() { SListNode&lt;T&gt;* cur =head; while (cur) { cout &lt;&lt; cur-&gt;data &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4feef463885850bb988f64e34d0e89b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e6aac0d6b69cd02f96c558e49fee5d3/" rel="bookmark">
			Android WebView 开发通过 chrome://inspect 调试页面设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 首先在app/src/main/AndroidManifest.xml 设置允许对app debug
&lt;!--添加以下两个属性--&gt; &lt;application android:debuggable="true" tools:ignore="HardcodedDebugMode" &gt; 2. 在初始化 WebView 时调用 webView.setJavaScriptEnabled(true) 方法
WebView webView = findViewById(R.id.webView); webView.setWebContentsDebuggingEnabled(true); // 主要是执行这一行，参数传 true 3. 手机端/模拟器安装移动端chrome浏览器，如果是配合pc端chrome调试，手机端chrome版本不能比pc端chrome版本高，否则可能无法成功调试。此外也可以使用手机端chrome+pc端edge调试，同样的，调试之前有必要将pc端edge更新至最新版本，edge版本号不能低于手机端chrome版本。
4. 将设置了1、2步骤的可调试版的app安装到手机/模拟器上，注意，真机调试需要用数据线连接电脑，同时真机需要打开开发者模式并允许调试。如果是模拟器，默认已经打开了调试功能，无需额外设置。然后在模拟器打开需要调试的WebView 页面。再然后在电脑chrome浏览器打开chrome://inspect页面；如果使用电脑的edge浏览器调试，请打开edge://inspect 页面；网上看到也有使用电脑qq浏览器调试的，那么请打开 qqbrowser://inspect；还有其他浏览器则不再例举，请自由发挥。
不出意外你会看到如下界面，红框所示则是你在手机或模拟器打开的WebView页面。
点击链接下方的 inspect 按钮，即可打开页面的快照，其实就是实时同步了移动端的屏幕；还支持在pc界面操作移动端界面，其实就是远程控制（edge支持，chrome貌似不支持，只能在手机上操作）。
当界面成功显示后，会自动在右侧打开chrome的开发者工具，这时候就进入到我们所熟悉的前端开发调试方式了。此时可以在开发者工具中使用 element、network、console、source、application 等面板对页面进行调试，极其方便。
通过pc端的chrome调试时，首次点击inspect按钮后页面可能一直处于加载中（白屏），或是显示 404 not found，这时候我们改用 edge 浏览器尝试，也可以搭好梯子后继续用chrome尝试。出现这种问题的原因是在调试界面需要先通过chrome官方链接加载支持调试功能的相关依赖，但是这个链接应该是被墙了，因此需要挂梯子，之后就不需要了，这个依赖会被浏览器缓存下来。但是edge 浏览器中的这个链接貌似是用了巨硬自己的镜像，且没有被墙，因此edge大概率可以直接无阻碍访问。
如有疑问，欢迎评论区交流。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a2d732753c8a8518fbfd32df79115b4/" rel="bookmark">
			【从入门到起飞】JavaAPI—BigInteger，BigDecimal的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎊专栏【Java基础】
🍔喜欢的诗句：更喜岷山千里雪 三军过后尽开颜。
🎆音乐分享【The truth that you leave】
🥰欢迎并且感谢大家指出我的问题
文章目录 🎁BigInteger🍔获取BigInteger对象⭐获取一个随机的大整数⭐获取指定的大整数✨注意 ⭐ 获取指定进制的大整数✨注意 ⭐静态方法获取BigInteger的对象，内部有优化✨注意 🍔BigInteger常见成员方法⭐加减乘⭐除🏳️‍🌈获取商🏳️‍🌈获取商和余数 ⭐比较是否相同⭐次幂⭐获取较大值⭐变为long类型的整数 🌺总结🎁 BigDecimal⭐通过传递字符串表示的数字来创建对象⭐通过静态方法获取对象🏳️‍🌈注意 ⭐加减乘⭐除🏳️‍🌈精确模式 🍔总结 🎁BigInteger BigInteger 是 Java 中的一个类，用于表示任意大小的整数。与基本数据类型 int 或 long 不同，BigInteger 没有固定的范围，可以表示非常大的整数值。
BigInteger 类提供了许多方法来进行整数的运算，包括加法、减法、乘法、除法、取余等。它还支持比较、位操作、幂运算等功能。
BigInteger 类的优点是可以准确地表示和计算任意大小的整数，而不会出现溢出的情况。这对于处理大整数、加密算法、密码学等领域非常有用。
但需要注意的是，由于 BigInteger 是一个对象，而不是基本数据类型，因此在使用时需要进行对象的创建和方法调用，会导致一定的性能损失。在处理一般大小的整数时，可以使用基本数据类型 int 或 long 来获得更高的性能。
总之，BigInteger 是用于处理任意大小整数的类，适用于需要高精度计算或处理非常大整数值的场景。
🍔获取BigInteger对象 ⭐获取一个随机的大整数 Random random=new Random(); BigInteger bigInteger=new BigInteger(number,random); 表示返回0 ~ 2^number-1之间的一个整数
⭐获取指定的大整数 BigInteger bigInteger=new BigInteger(number); ✨注意 只能是获取整数，不能获取小数或者字母
⭐ 获取指定进制的大整数 BigInteger bigInteger=new BigInteger(number,进制); ✨注意 进制与number一定要吻合，比如设置为二进制时，number必须为0和1组成的数(例如100，123就不行)数字不能是小数 ⭐静态方法获取BigInteger的对象，内部有优化 ✨注意 🏳️‍🌈能表示的范围比较小，在long的取值范围之内，超出long的范围就不行了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a2d732753c8a8518fbfd32df79115b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/142f5fe7e729af6c528f25ae049713f6/" rel="bookmark">
			MySQL ——多表连接查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、（左、右和全）连接概念 内连接： 假设A和B表进行连接，使用内连接的话，凡是A表和B表能够匹配上的记录查询出来。A和B两张表没有主付之分，两张表是平等的。
关键字：inner join on
语句：select * from a_table a inner join b_table b on a.a_id = b.b_id;
说明：组合两个表中的记录，返回关联字段相符的记录，也就是返回两个表的交集（阴影）部分。
左连接（左外连接，表示左边的这张表是主表）： 假设A和B表进行连接，使用外连接的话，A，B两张表中有一张主表，一张副表，主要查询主表中数据，捎带着查询副表。当副表中数据没有和主表中的数据匹配上，副表自动模拟出NULL与之匹配。外连接主要特点： 主表中的数据无条件全部查询出来。
关键字：left join on / left outer join on
语句：select * from a_table a left join b_table b on a.a_id = b.b_id;
说明：left join 是left outer join的简写，称是左外连接，是外连接中的一种。
左(外)连接，左表(a_table)的记录将会全部表示出来，而右表(b_table)只会显示符合搜索条件的记录。右表记录不足的地方均为NULL。
右连接（右外连接，表示右边的这张表是主表）
关键字：right join on / right outer join on
语句：select * from a_table a right outer join b_table b on a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/142f5fe7e729af6c528f25ae049713f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc64f692c65b6ce59e804ca3363f02e9/" rel="bookmark">
			Visual Studio Code配置Tomcat运行Java Web项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置Tomcat运行Java Web项目 创建项目创建Java Web项目补全项目结构 配置Tomcat Server项目部署部署编译目录部署war包 热部署热部署配置编译配置部署启动热部署 创建项目 创建Java Web项目 ctrl+shift+p打开搜索Maven原型， 并选择从maven原型创建新项目
或者按如下方式：选择从Maven原型创建Web项目
从maven-archetype-webapp原型创建项目
接着选择原型版本、输入包名、项目名、选择项目存放位置
注意：到此需要按一下回车来继续
输入Y或者回车确认
补全项目结构 通过Maven原型创建的的项目目录结构是不完整的
手动补全，新工程目录如下
修改pom.xml
&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; 配置Tomcat Server 安装Tomcat for Java插件，但是其已经过时了
但是其推荐使用Community Server Connector插件
安装Community Server Connectors插件之后会在控制栏多了一个SERVERS的选项卡
点击创建新的Server
可能出现异常：
Unable to create the server: Extension backend error - there are no rsp providers currently running to choose from. they may still be initializing. 原因：
项目使用的JDK版本过低，让项目使用更高的JDK版本即可解决
解决：
修改当前项目的.vscode文件夹中的settings.json文件，添加JDK11配置，不使用全局settings.json中配置的JDK8
// Java配置 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc64f692c65b6ce59e804ca3363f02e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97a76264f9b159637fe233cc6a33446b/" rel="bookmark">
			Hive-concat_ws 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		concat_ws 是 Hive 中的一个函数，用于在给定分隔符的情况下连接字符串数组或字符串。它的语法如下：
concat_ws(separator, const1, const2, const3, ...) 参数说明：
separator: 分隔符，用于连接字符串。可以是任何有效的字符串。const1, const2, const3, ...: 要连接的字符串或字符串数组。 该函数将使用指定的分隔符将所有提供的字符串或字符串数组连接在一起。它接受任意数量的参数，并且可以用于连接单个字符串或字符串数组。
下面是一个示例：
sqlSELECT concat_ws(', ', 'apple', 'banana', 'orange'); 输出结果为：
apple, banana, orange 在上面的示例中，我们使用逗号和空格作为分隔符，将三个字符串 'apple'、'banana' 和 'orange' 连接在一起。
如果要将一个字符串数组连接起来，可以将数组作为参数传递给 concat_ws 函数。例如：
SELECT concat_ws(', ', ('apple', 'banana', 'orange')); 输出结果为：
apple, banana, orange 在这个例子中，我们将一个包含三个字符串的数组 ('apple', 'banana', 'orange') 作为参数传递给 concat_ws 函数，并使用逗号和空格作为分隔符。
需要注意的是，如果传递给 concat_ws 的参数中有 NULL 值，那么连接的结果中将会忽略这些 NULL 值。例如：
SELECT concat_ws(', ', ('apple', NULL, 'orange')); 输出结果为：
apple, orange 在上面的示例中，尽管第二个参数是 NULL，但 concat_ws 函数仍然能够正确地连接其他非 NULL 字符串。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7ea0bc9792a1704dfee1faab9d71cfc/" rel="bookmark">
			Spring Boot 技术架构图（InsCode AI 创作助手辅助）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Spring Boot 技术架构是一种用于构建现代应用程序的框架，它可以与各种前端、代理、网关、业务服务、中间件、存储、持续集成和容器服务集成在一起，以创建功能强大的应用程序。
源文件下载链接！！！！！：https://download.csdn.net/download/LSW1737554365/88372834
前端：前端通常由 HTML、CSS 和 JavaScript 组成，用于构建用户界面。前端可以通过 HTTP 请求与后端服务进行通信，Spring Boot 应用程序可以提供 RESTful API 或 GraphQL 等方式与前端进行数据交互。代理：代理服务器可以位于前端和网关之间，用于处理一些网络层面的任务，如负载均衡、反向代理、SSL 终结、安全性策略等。网关：API 网关是用于管理和公开 API 的服务。Spring Cloud Gateway 或 Netflix Zuul 是常见的网关实现，它们可以用于路由、安全性、负载均衡、请求转发等。业务服务：在 Spring Boot 中，业务服务通常是应用程序的核心组件，负责实现应用程序的具体业务逻辑。除了业务逻辑外，业务服务还可以依赖于其他组件和工具类来完成其任务。中间件：中间件是用于连接和协调不同组件的软件层。在 Spring Boot 架构中，中间件可以包括消息队列（如 RabbitMQ、Apache Kafka）、缓存（如 Redis、Memcached）、身份验证服务、分布式日志等。存储：Spring Boot 应用程序通常需要与不同类型的存储进行交互，包括关系型数据库（如 MySQL、PostgreSQL）、NoSQL 数据库（如 MongoDB、Cassandra）、文件存储、对象存储等。持续集成：持续集成（CI）是一种开发实践，可以使用 CI/CD 工具（如 Jenkins、Travis CI、CircleCI）来自动化构建、测试和部署应用程序。这些工具与版本控制系统（如 Git）集成，确保代码的高质量和可靠性。容器服务：容器服务提供了一种轻量级的方式来打包、部署和管理应用程序及其依赖项。Docker 和 Kubernetes 是常见的容器服务，它们支持容器化应用程序的部署和扩展。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98ed71c6fd31feb1f6129bdf1b9eb087/" rel="bookmark">
			【Java】JSONArray详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSONArray是JSON数据格式中的一种数据结构，主要用于存储和操作有序的元素集合。本文将对JSONArray进行详细介绍，包括其定义、使用方法和实际应用场景。
定义 JSONArray是一种有序的元素集合，可以包含任意类型的数据，如字符串、数字、布尔值、null、数组或另一个JSON对象。JSONArray在JavaScript和Java等编程语言中都有广泛应用。
在JavaScript中，JSONArray是一组数组元素，可以是任何类型的数据，如字符串、数字、布尔值、null、数组或对象。数组元素可以通过索引访问，也可以使用push和pop方法添加或删除元素。
在Java中，JSONArray是一个类，用于表示JSON数组。它提供了各种方法来操作数组元素，如add、remove、get等。
使用 在使用JSONArray时，可以通过以下方法创建和操作它：
创建JSONArray对象 在JavaScript中，可以使用new Array()来创建一个空的数组对象，然后通过push方法添加元素，如下所示：
var jsonArray = []; // 创建一个空的JSONArray对象 jsonArray.push("apple"); // 添加一个字符串元素 jsonArray.push(123); // 添加一个数字元素 jsonArray.push(true); // 添加一个布尔元素 jsonArray.push(null); // 添加一个null元素 jsonArray.push([1, 2, 3]); // 添加一个数组元素 jsonArray.push({"name": "John", "age": 30}); // 添加一个JSON对象元素 在Java中，可以使用org.json库中的JSONArray类来创建一个JSONArray对象，如下所示：
import org.json.JSONArray; //... JSONArray jsonArray = new JSONArray(); // 创建一个空的JSONArray对象 jsonArray.put("apple"); // 添加一个字符串元素 jsonArray.put(123); // 添加一个数字元素 jsonArray.put(true); // 添加一个布尔元素 jsonArray.put(null); // 添加一个null元素 JSONArray innerArray = new JSONArray(); innerArray.put(1); innerArray.put(2); innerArray.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98ed71c6fd31feb1f6129bdf1b9eb087/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7886ab3933571bbaa7d96249d4c363f/" rel="bookmark">
			微信小程序开发【前端&#43;后端（Java）】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言
现在微信小程序越来越火了，相信不少人都通过各种途径学习过微信小程序或者尝试开发，作者就是曾经由于兴趣了解开发过微信小程序，所以现在用这篇博客记录我之前开发的一些经验和一些心得吧。
二、主要内容
springboot后端架构构建
小程序项目构建
小程序api调用
后台resetful接口编写
小程序调用后台接口
免费的https申请
linux下部署上线
三、微信小程序项目构建
这些基础的东西我就不过多介绍，大家在刚开始开发的时候一般都没有自己的服务器及域名，所以大家在本地编写的时候，在“详细”下的“项目设置”里面将“不校验域名安全性”勾选。
至于微信小程序的组件，即前端页面的开发希望大家耐住寂寞认真在微信开发平台上。
组件: https://developers.weixin.qq.com/miniprogram/dev/component/
api： https://developers.weixin.qq.com/miniprogram/dev/api/
四、后端详解
我在后端编写主要是用java，当然对其他开发语言熟悉的也可以使用其他语言开发后端。现在我就java编写后端api的讲解。主要框架springboot，开发工具myeclipse，服务器阿里云服务器。
创建一个maven项目，导入相关依赖：
pom.xml依赖
&lt;!-- 统一版本控制 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;!-- freemarker渲染页面 --&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-freemarker --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- spring boot 核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- springboot整合jsp --&gt; &lt;!-- tomcat 的支持. --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 在配置文件src/main/resources/下创建application.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7886ab3933571bbaa7d96249d4c363f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4ec42d92dcbbb71de8a5457c186f5aa/" rel="bookmark">
			【Redis】在Mac上安装使用redis的教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网： https://redis.io
中文网： https://www.redis.net.cn/
1、安装 brew install redis 开启服务 brew services start redis 关闭服务 brew services stop redis 指定端口 redis-cli -h localhost -p 6379 -h ip地址-p 端口号-a 密码（如果需要） 配置文件开启密码 cd /opt/homebrew/etc open redis.conf redis-server /opt/homebrew/etc/redis.conf ➜ ~ redis-cli 127.0.0.1:6379&gt; keys * (error) NOAUTH Authentication required. 127.0.0.1:6379&gt; 说明已开启密码
➜ ~ redis-cli -a 123456 Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4ec42d92dcbbb71de8a5457c186f5aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0db7b95b10a3e2faf86fc7f3bdf93717/" rel="bookmark">
			Android Studio安装超详细步骤（包括SDK安装不成功，模拟器无法创建等问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要介绍CPU为AMD锐龙和英特尔两种类型在安装中出现的一些问题，两种解决的方案不同，所以首先查看属于哪种，然后找相对应的安装方法。
Android Studio的安装需要准备两个安装文件，一个是java JDK ,一个是Android Studio均可在官网下载或者百度网盘自取 这篇文章以JDK1.8和Android Studio最新版本示例。
链接：https://pan.baidu.com/s/1UEPpZGohIZ5sgoLLYEstNQ?pwd=94yj-
提取码：94yj
在安装Audroid Studio之前，要确定java JDK的版本必须是1.7或以上，否则安装之后会报错。
目录
步骤一 （JDK的安装和环境变量配置）
步骤二（Audroid Studio的安装前准备）
情况1：CPU为AMD锐龙
情况2：CPU为因特尔
步骤三（Audroid Studio的安装）
步骤四：创建一个Android Studio项目
步骤五（Android Studio连接真机，模拟器调试学习已经足够，不想要连接自己手机的直接忽略该步骤）
1.请确定adb的环境变量是否配置
2.请确定下图这两个工具是否下载，没有下载勾选下载，然后依次点击apply和OK
3.请确定手机开发人员选项中USB调试以及允许USB安装应用（或者监控ADB安装应用是否打开）
步骤一 （JDK的安装和环境变量配置） 如果已经安装并且配置好环境变量，请忽略该步骤，直接看下一步骤
请参考下面博客文章链接中步骤2和步骤3
JSP常用软件IntelliJ IDEA从安装到运行超详细过程（包括环境变量配置）_IT菜鸟新手霞霞的博客-CSDN博客_idea安装jsp插件
步骤二（Audroid Studio的安装前准备） 建议在安装前就进行情况1和情况2的两种设置，否则后续会出现各种各样的问题。如果已经安装有错误了，建议先进行卸载，并将相应文件夹中的内容删掉。如果你安装过程没有出现问题，请忽略该步骤。
情况1：CPU为AMD锐龙 打开控制面板—&gt;程序—&gt;程序和功能—&gt;启用或关闭Windows功能
勾选Hyper-V和Windows虚拟机监控程序平台
如果这里可以两个都勾选，那就直接下一步骤进行安装
但是如果和我当时一样根本找不到Hyper-V,很有可能是Windows10家庭版未安装Hyper-V，先勾选Windows虚拟机监控程序平台，然后进行如下操作
解决办法：
新建一个文本文档或记事本，输入如下代码，另存为hyper.cmd ，以管理员身份运行该脚本（右键），等待命令执行完毕，可能需要很长时间，一定要确定联网耐心等待。时间会比较长。。。。最后会重启电脑，重启后就有Hyper-V了。
pushd "%~dp0" dir /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum &gt;hyper-v.txt for /f %%i in ('findstr /i . hyper-v.txt 2^&gt;nul') do dism /online /norestart /add-package:"%SystemRoot%\servicing\Packages\%%i" del hyper-v.txt Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL ​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0db7b95b10a3e2faf86fc7f3bdf93717/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/580/">«</a>
	<span class="pagination__item pagination__item--current">581/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/582/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>