<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cdc1a23ee938eda99f0437571322cb3/" rel="bookmark">
			LeetCode790多米诺和托米诺平铺
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 有两种形状的瓷砖：一种是 2 x 1 的多米诺形，另一种是形如 “L” 的托米诺形。两种形状都可以旋转。给定整数 n ，返回可以平铺 2 x n 的面板的方法的数量。返回对 109 + 7 取模 的值。平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。
解析 题目最后一句翻译成人话就是用这两种瓷砖要铺满且不能有重合。动态规划，对当前的位置分成四种情况：上下两个都是空，上空，下空和都是满的。
class Solution { static final int MOD = 1000000007; public int numTilings(int n) { int[][] dp = new int[n + 1][4]; dp[0][3] = 1; for(int i = 1; i &lt;= n; i++) { dp[i][0] = dp[i - 1][3]; dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % MOD; dp[i][2] = (dp[i - 1][0] + dp[i - 1][1]) % MOD; dp[i][3] = (((dp[i - 1][0] + dp[i - 1][1]) % MOD + dp[i - 1][2]) % MOD + dp[i - 1][3]) % MOD; } return dp[n][3]; } } 由于上面的过程可以写成矩阵乘法，可以用快速幂来计算。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cdc1a23ee938eda99f0437571322cb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/534fbdf16b1b65a58f949d76870db08c/" rel="bookmark">
			【springboot&amp;neo4j】版本差异对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring官方提供的指南，包含如何使用Spring Data
Neo4j构建应用程序的入门教程
本文旨在向读者介绍Spring Data Neo4j的旧版本（主要使用Neo4j OGM）和新版本（最新的Spring Data Neo4j）之间的主要差异。我们将重点讨论注解、API、配置方式等多个方面的变化。
1. 注解和实体定义的变化 1.1 旧版本（基于Neo4j OGM） 在旧版本的Spring Data Neo4j中，主要基于Neo4j OGM（Object-Graph Mapping）。这意味着我们需要使用org.neo4j.ogm.annotation包中的注解来定义Neo4j节点和关系。
下面的示例代码展示了如何使用这些注解：
import org.neo4j.ogm.annotation.GeneratedValue; import org.neo4j.ogm.annotation.Id; import org.neo4j.ogm.annotation.NodeEntity; import org.neo4j.ogm.annotation.Property; @NodeEntity(label = "Person") public class Person { @Id @GeneratedValue private Long id; @Property(name = "personId") private String personId; @Property(name = "name") private String name; // Getters and setters } 在这个示例中，注解的用途如下：
@NodeEntity：标识这是一个Neo4j的节点实体。@Id：节点的唯一标识符。@GeneratedValue：用于自动生成ID。@Property：定义节点属性，映射Java字段和Neo4j属性。 1.2 新版本（最新的Spring Data Neo4j） 从Spring Data Neo4j 6.0开始，Spring团队开始推荐使用Spring Data本身的注解，同时也移除了对Neo4j OGM的依赖。这些注解位于org.springframework.data.neo4j.core.schema包中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/534fbdf16b1b65a58f949d76870db08c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c8d31f8ff1e983a5d0b49aec88d3c71/" rel="bookmark">
			20240607 每日AI必读资讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🤖Seed-TTS：由字节跳动开发的几乎完美接近人类的文本到语音（TTS）模型
- 该模型能够生成高质量、几乎无法与人类声音无法区分的语音。
- 无需训练的情况下，只需要简短的语音片段即可克隆生成高度自然且富有表现力的语音。
- 完全能否胜任读小说、配音等任务。
- Seed-TTS 还提供了对各种语音属性的高级控制能力，包括但不限于情感、语调、说话风格等。
- 还可以通过编辑文本来编辑生成的语音。
🔗 Seed-TTS:
🔗https://blink.csdn.net/details/1720229
🔊Stability AI 开源其音频生成模型：Stable Audio Open
- 能够通过简单的文本提示生成最长47秒的立体声音频（44.1kHz）。
- 适用于创建鼓点、乐器片段、环境声音和拟音录音等。
- 基于transforms扩散模型（DiT），在自动编码器的潜在空间中操作，提高生成音频质量和多样性。
- 用户可以在自定义音频数据上微调模型，生成符合个人需求的音频样本。
- 与Stable Audio 的比较：与能够生成最长三分钟完整曲目的商业版Stable Audio Open不同，Stable Audio Open 专注于短音频片段和音效。
🔗 https://blink.csdn.net/details/1720232
🎵Suno新功能被Udio抢跑！上传任意音频Udio自动帮延长创作
- 可以上传任意音频片段，Udio会帮你解析旋律、和弦并延长32秒！
- 新功能还包括 WAV 下载、更新的移动界面、更好的桌面端可用性和改进的标签和歌曲搜索。
- 目前上传音频生成的曲目无法发布在平台上，但可以下载保存。
🔗 Udio | AI Music Generator - Official Website
🔗 https://blink.csdn.net/details/1720233
📱Mobile-Agent-v2：让AI可以像真人一样来操控手机执行各种任务
- Mobile-Agent 是一个通过多种技术手段，实现了对移动设备的自动化操作和视觉感知功能。
- 也就是让AI可以像你一样模拟点击、滑动、输入等操作，来操控你的手机，来帮你自动完成一些列任务。 - 引入了多代理协作架构，通过多个代理协同工作，实现更高效的导航和任务执行。
🔗 https://blink.csdn.net/details/1720235
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c8d31f8ff1e983a5d0b49aec88d3c71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/468c7b882447130e518853f73f8ac969/" rel="bookmark">
			【大数据】计算引擎：Spark核心概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
1.什么是Spark
2.核心概念
2.1.Spark如何拉高计算性能
2.2.RDD
2.3.Stage
3.运行流程
前言 本文是作者大数据系列中的一文，专栏地址：
https://blog.csdn.net/joker_zjn/category_12631789.html?spm=1001.2014.3001.5482
该系列会成体系的聊一聊整个大数据的技术栈，绝对干货，欢迎订阅。
1.什么是Spark 整个大数据的计算引擎是先有了MapReduce，再有的其它，可以理解为后面出现的其它计算引擎都是对MapReduce的一个补足与升级。
Spark就是对MapReduce的一个补足与升级，其弥补了MapReduce在迭代计算上孱弱的缺陷。其核心就是将数据内存中来，而不是每次都要去读磁盘，进行磁盘IO。
spark是什么：
spark是基于内存的计算引擎，它不是指单个技术，而是指一个技术栈，一个构建于spark core上面的全套的用来处理各种计算的技术栈。
Spark Core提供了什么能力：
Spark既然是补足，就要先说MapReduce在计算这一方面的不足，MapReduce在计算性能上存在的核心问题是迭代计算性能不好，原因是结果需要写入HDFS中。要用到这个结果的后续作业要先去读HDFS，拿到数据，这无疑是十分缓慢的。
我们反过来想，MapReduce为什么要这样干？
MapReduce不是想这么干，而是只能这么干，因为如果不将结果写入HDFS中，全局怎么能找得到这个数据喃？要是写入HDFS，就能通过NameNode找到数据。
要更好的支持迭代计算，无疑将计算结果放在内存中是最好的，读内存毕竟比读磁盘快多了。落磁盘是因为HDFS帮我们管理了分布式的磁盘资源，我们可以找它拿数据，落内存还要找到分布式系统中存储的数据，这就需要另一套内存管理机制来帮我们管理分布式内存了。这套内存管理机制叫RDD，就是Spark Core提供的。
Spark的特点总结：
spark是基于内存的计算引擎，其也是mapreduce模式的，但是相较于mapreducce：
spark支持更多种数据集操作，编程模型更灵活。
由于是在内存中流转的，不像mapreducce的结果是落在分布式文件系统中的，所以spark的速度更快。
天生基于DAG，比MapReduce过程更简洁高效。
在大数据领域一般存在以下几种使用场景：
复杂的批量数据处理，用mapreduce，一般业务耗时需求能忍受在数十分钟到数小时
基于历史数据的交互式查询，用数据仓库，一般业务耗时需求能忍受在数十秒到数分钟
基于实时数据流的数据处理，用spark，一般业务耗时需求能忍受在数百毫秒到数秒
Spark其实是一个全套的基于内存的技术栈，其基于spark core可以完成各种各样数据的计算。Spark提供了一组什么能力？就是接下来我们在下一节要讲的核心概念的内容。
2.核心概念 2.1.Spark如何拉高计算性能 Spark对比MapReuce之所以做迭代计算性能好，是因为两个核心点：
有向无环图
基于内存
以上就是Spark Core提供的东西，接下来会通过一个例子来逐步带大家一点点的推出Spark Core的这两个核心概念。
首先是计算任务的过程有两种，一种是要分前后阶段，前后阶段之间有依赖关系，一种是不分前后阶段，可以并行执行的。
分前后阶段的：
ALTER TABLE PR_EXPERT_PEOPLE DROP COLUMN description_bak; 这个查询会有两个阶段。首先k会执行子查询（过滤年龄大于18的记录），这个操作产生一个中间结果。然后，它会在中间结果上执行第二个过滤操作（筛选性别为男性的记录）。由于这两个操作是连续的，它们之间存在依赖关系，必须按照顺序执行。
可以并行执行的：
这个查询可以分成两个子任务，去查a的数据。去查b的数据，这两个任务是可以并行执行的，最后合在一起就可以了。
SELECT * FROM a JOIN b ON a.type=b.type 上面的例子主要是带大家感受一下，计算任务的子流程无非就是两种，要么有先后依赖关系，要么可以并行执行。
对于一个计算任务而言，最高效的方式就是将能并行的子流程并行执行，有依赖关系的子流程串行执行，也就是说逻辑关系上子任务之间组成这样的有向无环图，效率上是最佳的：
OK，其实把上面聊完，Spark的核心概念就已经出来了：
RDD
Stage
2.2.RDD RDD其实就是有向无环图的节点。我们想一想这些节点会是什么？其实就是计算任务，但是光有任务是无法完成工作的，还需要对应数据，所以这个有向无环图上的节点就是任务+数据的一个抽象，理解为一个单独可以完成的子任务即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/468c7b882447130e518853f73f8ac969/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da3d54ecb19aee2849e307911b4f3f2f/" rel="bookmark">
			C语言：详解gcc驱动程序完成编译、汇编、链接的过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关阅读
C语言https://blog.csdn.net/weixin_45791458/category_12423166.html?spm=1001.2014.3001.5482
gcc是一个命令，严格意义上说，它只是一个驱动程序，而不是一个编译器。gcc负责调用GNU工具链中的预处理器、编译器、汇编器、链接器等工具，通过传递不同的选项给gcc命令，可以让其只完成某些步骤，比如下面的命令，用于只对源文件进行预处理。
gcc -E test.c 实际上，gcc命令的参数不仅可以是C语言源文件（.c后缀），也可以是C++语言（.cc、.cpp、.c++、.CPP等后缀）， 还可以是fortran语言（.f、.for、.f90、.f95等后缀），ada语言（.adb、.adb后缀）等。
具体支持的语言后缀，可以在gcc命令的源代码中找到，如下所示（也可以使用man命令在gcc的手册中找到）。
1409 static const struct compiler default_compilers[] = 1410 { 1411 /* Add lists of suffixes of known languages here. If those languages 1412 were not present when we built the driver, we will hit these copies 1413 and be given a more meaningful error than "file not used since 1414 linking is not done". */ 1415 {".m", "#Objective-C", 0, 0, 0}, {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da3d54ecb19aee2849e307911b4f3f2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38e129fa372812c94d2cde7f9998c74a/" rel="bookmark">
			【数据集划分】oracle数据集划分（总结版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【数据集划分】假如你有接近百万条oracle数据库数据（成真版） 写在最前面最终代码原理：生成随机索引并打乱顺序示例作用应用场景 遇到报错：ORA-01795，通过CTE（Common Table Expressions）和窗口函数解决 🌈你好呀！我是 是Yu欸 🌌 2024每日百字篆刻时光，感谢你的陪伴与支持 ~ 🚀 欢迎一起踏上探险之旅，挖掘无限可能，共同成长！ 写在最前面 前文：【数据集划分】假如你有超百万条oracle数据库数据（成真版）
大模型，何所谓大？先从大数据开始。
假如你有超百万条oracle数据库数据，那么一直使用的代码：train_df, temp_df = train_test_split(df, test_size=0.3, random_state=42)，很可能1h还没划分完数据。
最终解决方案：生成一列随机数，然后随机打乱。取前70%的样本划分为训练集，70%到90%之间的样本划分为测试集，剩余的样本划分为验证集。
最终代码 连接Oracle数据库：使用jaydebeapi连接Oracle数据库，确保提供正确的JDBC驱动路径和数据库连接信息。添加新列：在deal_ct_report表中添加一个新列dataset来保存数据集标签。如果列已经存在，会捕捉到异常并继续执行后续操作。获取总行数：查询表的总行数，用于生成随机索引。生成随机索引并打乱顺序：生成从1到总行数的索引列表，并打乱顺序。计算各数据集的分界点：计算训练集、测试集和验证集的分界点。创建临时表：将原表的rowid和ROWNUM保存到临时表中。更新数据集标签列：使用CTE和窗口函数一次性更新所有记录，避免分批次更新的效率问题。 使用dbms_random.value生成随机数进行排序。使用ROW_NUMBER()窗口函数为每条记录分配一个随机序号。根据随机序号进行数据集划分并更新dataset列。 删除临时表：删除临时表以清理临时数据。提交事务：将所有更改提交到数据库。关闭连接：关闭数据库连接。 通过将参数直接插入到SQL语句中，避免了参数传递中的问题。这种方法可以高效地实现数据集的随机划分和更新操作。
import jaydebeapi import random # 连接Oracle数据库 conn = jaydebeapi.connect( 'oracle.jdbc.driver.OracleDriver', 'jdbc:oracle:thin:@hostname:port:service_name', ['username', 'password'], 'path/to/ojdbc8.jar' ) cursor = conn.cursor() # 添加新列dataset try: cursor.execute("ALTER TABLE deal_ct_report ADD dataset VARCHAR2(10)") except jaydebeapi.DatabaseError as e: print("Column 'dataset' may already exist. Proceeding with data split...") # 获取表的行数 cursor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38e129fa372812c94d2cde7f9998c74a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e086a8b241feba4da3bbb8278ce6e8ad/" rel="bookmark">
			Flink协调器Coordinator及自定义Operator
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink协调器Coordinator及自定义Operator 最近的项目开发过程中，使用到了Flink中的协调器以及自定义算子相关的内容，本篇文章主要介绍Flink中的协调器是什么，如何用，以及协调器与算子间的交互。
协调器Coordinator Flink中的协调器是用来协调运行时的算子，运行在JobManager中，通过事件的方式与算子通信。例如Source和Sink算子中的协调器是用来发现和分配工作或者聚合和提交元数据。
线程模型 所有协调器方法都由作业管理器的主线程（邮箱线程）调用。这意味着这些方法在任何情况下都不得执行阻塞操作（如 I/ O 或等待锁或或Futures）。这很有可能使整个 JobManager 瘫痪。
因此，涉及更复杂操作的协调器应生成线程来处理 I/ O 工作。上 OperatorCoordinator. Context 的方法可以安全地从另一个线程调用，而不是从调用协调器方法的线程调用。
一致性 与调度程序的视图相比，协调器对任务执行的视图高度简化，但允许与在并行子任务上运行的操作员进行一致的交互。具体而言，保证严格按顺序调用以下方法：
executionAttemptReady(int, int, OperatorCoordinator.SubtaskGateway)：在子任务就绪的时候调用一次。SubtaskGateway是用来与子任务交互的网关。这是与子任务尝试交互的开始。
executionAttemptFailed(int, int, Throwable)：在尝试失败或取消后立即调用每个子任务。此时，应停止与子任务尝试的交互。subtaskReset(int, long) 或 resetToCheckpoint(long, byte[])：一旦调度程序确定了要还原的检查点，这些方法就会通知协调器。前一种方法在发生区域故障/ 恢复（可能影响子任务的子集）时调用，后一种方法在全局故障/ 恢复的情况下调用。此方法应用于确定要恢复的操作，因为它会告诉要回退到哪个检查点。协调器实现需要恢复自还原的检查点以来与相关任务的交互。只有在子任务的所有尝试被调用后 executionAttemptFailed(int, int, Throwable) ，才会调用它。executionAttemptReady(int, int, OperatorCoordinator. SubtaskGateway)：在恢复的任务（新尝试）准备就绪后再次调用。这晚于 subtaskReset(int, long)，因为在这些方法之间，会计划和部署新的尝试。 接口方法说明 实现自定义的协调器需要实现OperatorCoordinator接口方法，各方法说明如下所示：
public interface OperatorCoordinator extends CheckpointListener, AutoCloseable { // ------------------------------------------------------------------------ /** * 启动协调器，启动时调用一次当前方法在所有方法之前 * 此方法抛出的异常都会导致当前作业失败 */ void start() throws Exception; /** * 释放协调器时调用当前方法，此方法应当释放持有的资源 * 此方法抛出的异常不会导致作业失败 */ @Override void close() throws Exception; // ------------------------------------------------------------------------ /** * 处理来自并行算子实例的事件 * 此方法抛出的异常会导致作业失败并恢复 */ void handleEventFromOperator(int subtask, int attemptNumber, OperatorEvent event) throws Exception; // ------------------------------------------------------------------------ /** * 为协调器做checkpoint，将当前协调器中的状态序列化到checkpoint中，执行成功需要调用CompletableFuture的complete方法，失败需要调用CompletableFuture的completeExceptionally方法 */ void checkpointCoordinator(long checkpointId, CompletableFuture&lt;byte[]&gt; resultFuture) throws Exception; /** * We override the method here to remove the checked exception.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e086a8b241feba4da3bbb8278ce6e8ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3d85008a7b970356323c086c969b97b/" rel="bookmark">
			黑客团伙利用Python、Golang和Rust恶意软件袭击印国防部门；OpenAI揭秘，AI模型如何被用于全球虚假信息传播？ | 安全周报0531
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		黑客团伙利用Python、Golang和Rust恶意软件袭击印度国防部门！ 与巴基斯坦有联系的Transparent Tribe组织已被确认与一系列新的攻击有关，这些攻击使用Python、Golang和Rust编写的跨平台恶意软件，针对印度政府、国防和航空航天部门。
“这一系列活动从2023年底持续到2024年4月，并预计将持续下去.”黑莓研究和情报团队在上周初发布的一份技术报告中说。
此次鱼叉式网络钓鱼活动还因滥用Discord、Google Drive、Slack和Telegram等热门在线服务而引人注目，这再次强调了黑客是如何将合法程序纳入其攻击流程的。
据黑莓称，基于电子邮件的攻击目标包括国防部生产部（DDP）的三个重要利益相关者和客户公司。这三家目标公司的总部都设在印度班加罗尔市。
虽然没有透露这些公司的名称，但有迹象表明，这些电子邮件的目标是印度斯坦航空有限公司（HAL），这是世界上最大的航空航天和国防公司之一；巴拉特电子有限公司（BEL），这是一家国有航空航天和国防电子公司；以及BEML有限公司，这是一家生产土方设备的公共部门企业。
关键词：Python、Golang、Rust、跨平台恶意软件、鱼叉式网络钓鱼、黑莓研究和情报团队、Discord、Google Drive、Slack、Telegram
来源：https://thehackernews.com/2024/05/pakistan-linked-hackers-deploy-python.html
OpenAI揭秘：AI模型如何被用于全球虚假信息传播？ OpenAI周四披露，他们已采取措施切断了源自伊朗、以色列和俄罗斯的五个隐蔽影响力行动（IO），这些行动试图滥用其人工智能（AI）工具来操纵网络上的公众舆论或政治结果，同时掩盖他们的真实身份。
这些活动在过去三个月中被发现，利用OpenAI的人工智能模型生成各种语言的简短评论和长篇文章，编造社交媒体账户的名称和个人简介，进行开源研究，调试简单的代码，以及翻译和校对文本。
这家人工智能研究机构表示，其中两个网络与俄罗斯的黑客有关，包括一个以前未记录的行动，代号为“Bad Grammar”，主要使用至少十几个Telegram账户，用俄语和英语向乌克兰、摩尔多瓦、波罗的海国家和美国的受众发布粗制滥造的内容。
“该网络使用我们在Telegram上的模型和账户建立了一个评论垃圾邮件传输管道，”OpenAI说，“首先，操作者使用我们的模型来调试显然是为自动化在Telegram上发布而设计的代码。然后，他们用俄语和英语生成评论，回复特定的Telegram帖子。”
操作者还利用其模型，以美国政治光谱两端的各种虚构人物的名义，生成评论。
另一个与俄罗斯有关的信息行动对应于多产的Doppelganger网络（又名“Recent Reliable News”），该网络今年3月早些时候因从事网络影响力行动而受到美国财政部外国资产控制办公室（OFAC）的制裁。
据说，该网络使用了OpenAI的模型，生成了英语、法语、德语、意大利语和波兰语的评论，并在X和9GAG上分享；将文章从俄语翻译成英语和法语，然后发布在该组织维护的虚假网站上；生成标题；并将发布在其网站上的新闻报道转化为Facebook帖子。
“这项活动针对欧洲和北美的受众，侧重于为网站和社交媒体生成内容，”OpenAI说，“这场运动在网上发布的大部分内容都集中在乌克兰战争上。它把乌克兰、美国、北约和欧盟描绘成负面形象，而把俄罗斯描绘成正面形象。”
其他li个活动集群如下：
一个名为国际虚拟媒体联盟（IUVM）的伊朗行动，该行动使用其AI模型生成和翻译英文和法文的长篇文章、标题和网站标签，随后在名为iuvmpress[.]co的网站上发布。
一个名为Zero Zeno的网络，源自以色列一家名为STOIC的商业情报公司雇佣的黑客，该公司使用其AI模型在Instagram、Facebook、X和其附属网站上生成和传播反哈马斯、反卡塔尔、亲以色列、反印度人民党和亲以色列工会的内容，针对加拿大、美国、印度和加纳的用户。“Zero Zeno行动还使用我们的模型，基于年龄、性别和位置等某些变量，为社交媒体创建虚构的角色和简介，并对在以色列公开发表关于以色列工会的评论的人进行研究，”OpenAI说，并补充说，其模型拒绝提供个人数据作为对这些提示的回应。
关键词：人工智能、AI模型、影响力行动、评论垃圾邮件、调试代码、
来源：https://thehackernews.com/2024/05/openai-meta-tiktok-disrupt-multiple-ai.html
紧急警告！CISA敦促修补被黑客利用的Linux内核大漏洞！ 美国网络安全和基础设施安全局（CISA）周四将一个影响Linux内核的安全漏洞添加到已知被利用漏洞（KEV）目录中，并引用了该漏洞被积极利用的证据。
该高严重性漏洞编号为CVE-2024-1086（CVSS评分：7.8），与netfilter组件中的一个释放后使用（use-after-free）漏洞有关，该漏洞允许本地攻击者将权限从普通用户提升到root用户，并可能执行任意代码。
CISA表示：“Linux内核的netfilter：nf_tables组件中存在一个释放后使用的漏洞，该漏洞允许攻击者实现本地权限提升。”
Netfilter是Linux内核提供的一个框架，它允许以自定义处理程序的形式实现各种网络相关操作，以简化数据包过滤、网络地址转换和端口转换。
关键词：Linux Kernel、netfilter、Known Exploited Vulnerabilities (KEV) Catalog、CVE-2024-1086、CVSS Score、Local Privilege Escalation
来源：https://thehackernews.com/2024/05/cisa-alerts-federal-agencies-to-patch.html
警惕！网络罪犯利用Python包进行加密货币大盗！ 网络安全研究人员发出警告，称在Python包索引（PyPI）存储库中发现了一个新的恶意Python包，这是一项更大规模活动的一部分，旨在窃取加密货币。
有问题的包是pytoileur，截至撰写本文时，该包已被下载316次。有趣的是，名为PhilipsPY的包作者在PyPI维护人员于2024年5月28日撤下先前的版本（1.0.1）后，上传了一个功能相同的新版本（1.0.2）。
根据Sonatype发布的分析，恶意代码嵌入在包的setup.py脚本中，允许它执行一个Base64编码的有效载荷，该有效载荷负责从外部服务器检索Windows二进制文件。
关键词：Python Package Index (PyPI)、恶意Python包、cryptocurrency theft（加密货币盗窃）、pytoileur、Base64编码
来源：https://thehackernews.com/2024/05/cybercriminals-abuse-stackoverflow-to.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/386ceaf3220be7870a3e3373c6a4044a/" rel="bookmark">
			【Oracle】Oracle导入导出dmp文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、什么是dmp？二、imp/impdp、exp/expdp对比及示例1.区别2.imp/impdp对比及示例a. impb. impbp 3.exp/expdp对比及示例a. expb.expdp 3.其他事项 三、执行导入导出前置条件1.创建角色并授权2.创建目录映射 前言 在工作中，经常会遇到需要备份库，库表迁移的场景，对于oracle会使用dmp文件进行数据迁移和备份。基于一次迁移数据库的经历，整理记录dmp相关知识点，供后续工作参考使用。
一、什么是dmp？ ● dmp是"Data Pump"的缩写，它是Oracle独有的一种数据导入导出文件格式。.dmp文件是一种数据库导出文件的扩展名，通常用于存储数据库中的表、数据、视图等对象的结构和内容。是一种特定数据库系统的二进制信息，因此不能直接用文本编辑器打开。
●.dmp文件一般包含数据定义语言(DDL)和数据操作语言(DML)。具体来说，DDL是用来定义数据库对象，例如表、视图、用户等等；DML则是用来操作这些对象，例如插入、删除、更新数据等。常用来进行数据库迁移或者备份操作。
●其他数据库也有类似备份文件，比如MySQL数据库使用.sql文件或者.dump文件来表示数据库导出文件，而SQL Server数据库使用.bak文件来表示备份文件。
二、imp/impdp、exp/expdp对比及示例 imp/exp（Oracle导入导出实用程序）是使用传统的导出技术，而impdp/expdp（数据泵导入实用程序）是使用Oracle Data Pump技术。Data Pump是Oracle在10g版本中引入的高性能、可扩展的导入导出工具，即 Oracle 10g 之前的版本不可以使用 impdp/expdp。
1.区别 ●imp和exp是传统的导入和导出工具，而impdp和expdp是数据泵工具，采用了新的架构和方法。
●imp和exp是基于基于二进制文件的，而impdp和expdp则是使用数据泵作业来执行数据移动操作，可以提供更高的性能和扩展性。
●imp和exp不支持在分布式环境中执行，而impdp和expdp可以在分布式环境中执行。
●数据泵通常指的是一种高性能的数据导入和导出工具，用于在数据库系统中进行快速的数据迁移和加载操作。数据泵工具能够提供比传统的导入导出工具更快速、更灵活的数据传输方式，通常支持并行处理、大容量数据传输和高性能加载等特点。
2.imp/impdp对比及示例 a. imp 可通过 imp help=y 命令查询相关参数
imp常用参数说明,可以根据需要指定不同的参数来控制导入的方式和内容。 参数使用说明TOUSER指定要导入数据的用户名。FROMUSER指定导入数据来自的用户名。FILE指定要导入的文件路径和名称。例如，FILE=/path/to/import.dmp。IGNORE指定是否忽略导入过程中遇到的错误。可以是Y或N。INDEXES指定是否导入索引。可以是Y或N。ROWS控制是否导入表中的行数据。可以是Y或N。DATA_ONLY指定只导入数据，不包括对象定义。可以是Y或N。IGNORECASE指定导入时是否忽略大小写。可以是Y或N。FULL指定导入前先删除现有对象。可以是Y或N。LOG指定导入操作的日志文件路径和名称。例如，LOG=/path/to/import.log。BUFFER指定读取导入文件时的缓冲区大小。REMAP_SCHEMA指定要将导入的对象映射到的新模式名。REMAP_TABLESPACE指定要将导入的表空间映射到的新表空间名。TABLES指定要导入的特定表。举例：IMP SCOTT/TIGER IGNORE=Y TABLES=(EMP,DEPT) FULL=N（or TABLES=(T1:P1,T1:P2) 表分区可用） 命令格式： imp 用户名/密码@数据库实例 FILE=导入文件的路径.dmp FROMUSER=源用户名 TOUSER=目标用户名 命令示例： --windows环境下 imp username/password@SERVICENAME:1521 file=e:\temp.dmp rows=y log=E:/test/dmp/kf_workflow_0512.log full = y; -linux环境路径进行替换 b. impbp 可通过 impbp help=y 命令查询相关参数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/386ceaf3220be7870a3e3373c6a4044a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5a68cd4ee6d06cf809b3dfba9e68be9/" rel="bookmark">
			浮动静态路由及负载均衡配置（华为）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#交换设备
浮动静态路由及负载均衡（华为） 浮动静态路由（ Floating Static Route) 是一种特殊的静态路由， 通过配置去往相同的目的网段， 但优先级不同的静态路由， 以保证在网络中优先级较高的路由， 即主路由失效的情况下， 提供备份路由。正常情况下， 备份路由不会出现在路由表中。 负载均衡(Load sharing ） 当数据有多条可选路径前往同一目的网络， 可以通过配置相同优先级和开销的静态路由实现负载均衡， 使得数据的传输均衡地分配到多条路径上， 从而实现数据分流、减轻单条路径负载过重的效果。而当其中某一条路径失效时，其他路径仍然能够正常传输数据， 也起到了冗余作用。 一、实验要求 分部A和B需要通信，主用链路是A–R1–R3–B，被用链路是 A–R1–R2–R3–B，通过浮动路由来实现主备用链路的功能，并根据实际需要实现负载均衡 二、实验步骤 1.基本配置 按照编址表设置IP地址在R1 R3上分别设置 PC2 PC1的路由，使得PC1通过R1和R3与PC2通信在R2上设置 PC1 和PC2 的路由 使得总部路由器 R2能够访问PC1 PC2 [R1]ip route-static 192.168.20.0 24 s1/0/1 [R3]ip route-static 192.168.10.0 24 s1/0/1 [R2]ip route-static 192.168.20.0 24 s1/0/1 [R2]ip route-static 192.168.10.0 24 s1/0/0 2.配置浮动路由，实现备份路由链路 PC1–R1–R3–PC2 为主要链路 , PC1–R1–R2–R3–PC3 为被用链路在R1、R3上配置静态路由，链路方向是R1–R2，优先级100 [R1]ip route-static 192.168.20.0 24 s1/0/0 preference 100 #优先级为100, [R3]ip route-static 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5a68cd4ee6d06cf809b3dfba9e68be9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11fc193eb48d06990c5f12d9c3abd761/" rel="bookmark">
			uniapp在自定义tabbar上动态修改svg图标颜色和字体颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：在uniapp项目内，自定义tabbar，需要将图标更换成svg格式，可动态修改图标及字体颜色。 效果图如下：
我使用的是uniapp结合uview2的组件使用，代码如下：
&lt;u-tabbar :value="currentIndex" @change="tabbarChange" :fixed="true" :activeColor="themeColor" :safeAreaInsetBottom="true" zIndex='99'&gt; &lt;u-tabbar-item v-for="(item,index) in tabbarList" :key="index" :text="item.text" :badge="item.isBadge?carNum:''"&gt; &lt;!-- 选中的svg --&gt; &lt;view class="u-page__item__slot-icon tabbarItemIcon" slot="active-icon" :style="{backgroundImage: 'url('+item.selectedIconPath+')'}"&gt; &lt;/view&gt; &lt;!-- 未选中的svg --&gt; &lt;view class="u-page__item__slot-icon tabbarItemIcon" slot="inactive-icon" :style="{backgroundImage: 'url('+item.iconPath+')'}"&gt; &lt;/view&gt; &lt;/u-tabbar-item&gt; &lt;/u-tabbar&gt; 对上述代码进行解析：
currentIndex：是父组件传递过来的需要选中的下标fixed：是否固定底部themeColor：主题色tabbarChange：切换tabbar的事件 数据来源：
// 将对应的svg导入进来 import {index,category,cart,mine} from "./svgUrls.js" export default { props: { // 当前索引 currentIndex: { type: Number, default: 0 }, }, data() { let that=this; return { // 主题色 themeColor:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11fc193eb48d06990c5f12d9c3abd761/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e93c33be26cbb9aa2403a776f1e615b/" rel="bookmark">
			[office] excel运用计算公式进行运算的方法 #知识分享#其他#学习方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		excel运用计算公式进行运算的方法
在excel建立财务等报表后，通常都需要进行相关数据计算，这也是我们使用excel程序的目的语便利所在。在进行数据计算时，需要建立公式来实现，而在使用公式时，需要引用单元格的值进行计算，那么在excel怎么运用计算公式进行运算?下面小编就为大家介绍exce简单公式、应用公式方法介绍，来看看吧!
在excel运用计算公式进行运算的方法
方法/步骤
1、这里先简单的说下自己加到单元格中去。直接在空的单元格中先输入=号，这个意思是告诉excel我要输入公式了，而不是一般的输入。直接可以进行数字的加减乘除。这里的话我们可以看到公式
在excel运用计算公式进行运算的方法图1
在excel运用计算公式进行运算的方法图2
2、单元格的的数字相加，这里说的是单元格的内容相加，我们来看下是怎么设置的。加减乘除是同样的道理
在excel运用计算公式进行运算的方法图3
3、这里需要说明的是，这里也是要在哟个空白的单元格中放置运算完成的数值。=号之后按住ctrl再单击你要选中的加数和被加数，并按enter完成运算
在excel运用计算公式进行运算的方法图4
在excel运用计算公式进行运算的方法图5
在excel运用计算公式进行运算的方法图6
4、复制公式：在完成一个加法运算之后，我们选择运算完成的数字，用鼠标移动到右下角直到出现一个加号的形状，一直向下拉
在excel运用计算公式进行运算的方法图7
5、我们先来介绍一下基本的运算符号：下面依次的顺序是 加减乘除
在excel运用计算公式进行运算的方法图8
6、多种运算符的运算，这个不用我们管，里面的程序已经设计好的，我们就要跟用计算器一样 就好
在excel运用计算公式进行运算的方法图9
7、当我们不记得公式的时候可以选择当时利用公式算出的数值，我们就能在上方公式区看到
在excel运用计算公式进行运算的方法图10
8、这里的公式计算你可以是在行也可以在竖列都可以，也可以上下都行，也可以是选中一个四方形
以上就是在excel怎么运用计算公式进行运算方法介绍，大家学会了吗?方法很简单的，有需要的朋友可以跟着教程来学习哦!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dca76347162a81efd2e6b985c011544a/" rel="bookmark">
			Centos7安装Zookeeper
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Centos7安装Zookeeper 准备工作 https://zookeeper.apache.org/releases.html
下载稳定版的安装包。【注意：下载的是xxx-bin.tar.gz包 是可运行的zookeeper 而 xxx.tar.gz是源码包不可运行】
上传zookeeper的压缩包到指定目录/usr/local/zookeeper/
安装Zookeeper 执行 tar -zxvf apache-zookeeper-3.8.4-bin.tar.gz 命令解压缩压缩包
进入解压缩文件并创建data 和 logs文件夹
mkdir data
mkdir logs
进入conf文件夹 复制zookeeper的配置模板zoo_sample.cfg
修改配置文件zoo.cfg
vim zoo.cfg
#数据文件夹
dataDir=/usr/local/zookeeper/apache-zookeeper-3.8.4-bin/data
#日志文件夹
dataLogDir=/usr/local/zookeeper/apache-zookeeper-3.8.4-bin/logs
vim /etc/profile 进入系统配置文件，将以下内容插入进入，保存退出
#zookeeper-3.8.4配 置
export ZOOKEEPER_HOME=/usr/local/zookeeper/apache-zookeeper-3.8.4-bin/
export PATH= Z O O K E E P E R H O M E / b i n : ZOOKEEPER_HOME/bin: ZOOKEEPERH​OME/bin:PATH
export PATH
重新加载配置文件使其生效source /etc/profile
开放端口2181
firewall-cmd --zone=public --add-port=2181/tcp --permanent firewall-cmd --reload # 配置立即生效 进入/usr/local/zookeeper/apache-zookeeper-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dca76347162a81efd2e6b985c011544a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c57df3b20a0132e67c457e95a87c7fc3/" rel="bookmark">
			Android 平台编解码——软解、硬解对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关键词：Android，音视频编解码，软解码，硬解码，MediaPlayer，MediaCodec
文章目录 前言
一、概念解释 1. 概念：
2. 优缺点对比：
3. 播放器示例：
二、Android 硬解组件
1. MediaPlayer
2. MediaCodec
3. MediaCodec 的函数调用流程
总结
前言 提示：本文只做相关概念总体上的介绍和解释，不做深入讨论。
一、概念解释 1. 概念： 硬解，即硬件解码：硬件解码是图形芯片厂商提出的用 GPU 资源解码视频流的方案；
软解，即软件解码：相对于硬件解码，传统的软件解码是用 CPU 承担解码工作。
2. 优缺点对比： 对比优点缺点硬解 效率高、
功耗低、
热功耗低
a）缺乏有力的支持（包括滤镜、字幕）、局限性较大、设置较为复杂；
b）需要硬件有硬件解码模块、相关的驱动配合、合适的播放软件以及对播放软件的正确设置，缺一不可。否则无法开启硬件解码功能。
软解具备普遍适应性主要靠算法解码，很耗费CPU性能、耗电。 3. 播放器示例： 3.1 硬解播放器
最简单的播放器组件 —— VideoView VideoView 基于 MediaPlayer 实现，其基本等价于 MediaPalyer + Surface 的组合。通常原生的 Android 系统，其 MediaPlayer 本身对于视频编解码协议支持比较有限。而 MediaPlayer 内部实现主要通过 MediaExtractor + MediaCodec 的组合实现。
Google 的 ExoPlayer ExoPlayer 基于 MediaCodec 实现。而 MediaCodec 则具备很高的拓展性，支持的协议较多，可以根据流媒体的协议和设备硬件本身来自定义硬件解码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c57df3b20a0132e67c457e95a87c7fc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c26906b5626ccb7c24659dfd3d78281a/" rel="bookmark">
			xstream运用，JAVA对象转xml，xml转JAVA对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
xstream
优点：
缺点：
XStream的应用场景
用到的依赖
代码实现
xml标签对应的实体类
Header
Package
Request
Response
TradeInfo
工具类
XmlUtils
执行结果
xstream XStream是一个Java类库，主要用于将对象序列化为XML（或JSON）或将XML（或JSON）反序列化为对象。XStream使用Java反射机制对要进行序列化的对象树的结构进行探索，无需对对象进行修改。它可以序列化内部字段，包括私有（private）和最终（final）字段，并支持非公开类以及内部类。在缺省情况下，XStream不需要配置映射关系，对象和字段将映射为同名XML元素。
优点： 易用性：XStream不需要额外的辅助类或映射文件，使得XML序列化不再繁琐。灵活性：支持多种数据类型转换，包括用户自定义的类型转换器。可读性：输出通常比其他工具更清晰和易于阅读。 缺点： 效率：相对于某些工具（如XMLEncoder），XStream在处理大型数据集时可能会较慢，因为它需要在每个对象实例上运行解析器。内存使用：XStream使用流操作可能导致较高的内存使用，特别是在处理大型数据集时。 XStream的应用场景 XStream的常见用途包括对象传输、持久化、配置以及单元测试等。它在许多项目中，特别是在支付API对接时，被用于实现Java对象和XML文档的互转。
用到的依赖 &lt;!--XML解析--&gt; &lt;dependency&gt; &lt;groupId&gt;com.thoughtworks.xstream&lt;/groupId&gt; &lt;artifactId&gt;xstream&lt;/artifactId&gt; &lt;version&gt;1.4.20&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt; 代码实现 &lt;!--xml报文--&gt; &lt;?xml version='1.0' encoding='UTF-8'?&gt; &lt;Package&gt; &lt;Header&gt; &lt;RequestType&gt;131&lt;/RequestType&gt; &lt;SystemNo&gt;001&lt;/SystemNo&gt; &lt;SendTime&gt;2024-06-05 09:53:38&lt;/SendTime&gt; &lt;Status&gt;100&lt;/Status&gt; &lt;ErrorMessage /&gt; &lt;/Header&gt; &lt;Sign&gt;NgJzJyhoeXYd/TJvJitByhUR1UVMJ+FjuMl4WVBjP0CsOM6owyX9nCn1c/IL+OpVeSYkl4k60Du8nLa13wRB1oqFA8I2zel9+Xiq7lAL0otIcdww4F9i5uULk2wpq8ApXcghO5suL54FPOutc+2gWNUUmdP6fb2/L2RFKOlcBig=&lt;/Sign&gt; &lt;Response&gt; &lt;DepartmentCode&gt;5&lt;/DepartmentCode&gt; &lt;TransSourceCode&gt;0&lt;/TransSourceCode&gt; &lt;PayNo /&gt; &lt;PayAmount&gt;100&lt;/PayAmount&gt; &lt;RealPayAmount&gt;100&lt;/RealPayAmount&gt; &lt;PaymentTime&gt;2024-06-05 09:50:49&lt;/PaymentTime&gt; &lt;DealTime&gt;2024-06-05 09:50:49&lt;/DealTime&gt; &lt;PayType&gt;1&lt;/PayType&gt; &lt;PlatformCode&gt;35&lt;/PlatformCode&gt; &lt;PlatformName /&gt; &lt;OrderId&gt;1000000001678451&lt;/OrderId&gt; &lt;OrderStatus&gt;2&lt;/OrderStatus&gt; &lt;PageUrl&gt;https://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c26906b5626ccb7c24659dfd3d78281a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1548b0b6aa645155716bfed2765be7c7/" rel="bookmark">
			AI框架之Spring AI与Spring Cloud Alibaba AI使用讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 AI框架1.1 Spring AI 简介1.2 Spring AI 使用1.2.1 pom.xml1.2.2 可实现的功能 1.3 Spring Cloud Alibaba AI1.4 Spring Cloud Alibaba AI 实践操作1.4.1 pom.xml1.4.2 配置文件1.4.3 对接文本模型1.4.4 文生图模型1.4.5 语音合成模型 1 AI框架 1.1 Spring AI 简介 在软件开发的世界中，Java一直是企业级应用的主力军。而Spring框架，尤其是Spring Boot，以其生态系统的丰富性，为开发者提供了无与伦比的便利。现在，Spring Boot正迈向一个新的纪元——人工智-能的时代。
Spring AI项目的推出，不仅标志着Spring生态的进一步扩展，也为广大Java开发者开启了一个全新的编程领域。
Spring AI 是从著名的 Python 项目LangChain和LlamaIndex中汲取灵感，它不是这些项目的直接移植，它的成立信念是，下一波生成式人工智能应用程序将不仅适用于 Python 开发人员，而且将在许多编程语言中无处不在。
Spring AI功能，可以看Spring推出的官方文档：https://spring.io/projects/spring-ai
我们可以从Spring AI的官网描述中，总结出Spring AI的几个核心的关键词：
提供抽象能力简化AI应用的开发模型与向量支持AI集成与自动配置 Spring AI 简化了我们构建大型复杂的AI应用的过程，当然如果你的项目仅仅是需要调用一个AI接口，那其实直接调用官方SDK反而更方便。
Spring AI提供的功能如下：
SQL类过滤器API： 提供类似SQL的元数据过滤器API，实现跨供应商的一致性。Spring Boot集成： 专为Spring Boot设计的自动配置和启动器，让AI集成变得轻而易举。API可移植性，支持所有主要的模型提供商，如OpenAI，Microsoft，Amazon，Google和Huggingface。支持的模型类型包括聊天和文本到图像。跨 AI 提供商的可移植 API，用于聊天和嵌入模型。支持同步和流 API 选项。还支持下拉以访问特定于模型的功能。将 AI 模型输出映射到 POJO。支持所有主要的向量数据库，例如 Azure Vector Search、Chroma、Milvus、Neo4j、PostgreSQL/PGVector、PineCone、Qdrant、Redis 和 Weaviate。跨 Vector Store 提供程序的可移植 API，包括新颖的类似 SQL 的元数据过滤器 API，该 API 也是可移植的。AI 模型和矢量存储的 Spring Boot stater。用于数据工程的 ETL 框架 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1548b0b6aa645155716bfed2765be7c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6b142d1caa72433c970a2bb309b45fe/" rel="bookmark">
			Android 动态修改APP图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Android 动态修改APP图标定义activity-alias修改图标和App名监听APP前后台状态切换进入后台时切换修改图标和名字缺点 Android 动态修改APP图标 修改前：
修改后：
定义activity-alias 在 AndroidManifest.xml 中设置 activity-alias：
activity-alias标签中的属性：
标签作用android:name别名android:enabled是否启用别名android:icon应用图标android:label应用名android:targetActivity必须指向原入口Activity 下面定义了2个alias标签：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.myapplication"&gt; &lt;application android:name=".BaseApplication" android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/Theme.MyApplication"&gt; &lt;activity android:name=".SecondActivity" /&gt; &lt;activity android:name=".MainActivity" /&gt; &lt;activity-alias android:name=".DefaultAliasActivity" android:enabled="true" android:exported="true" android:icon="@mipmap/ic_launcher" android:roundIcon="@mipmap/ic_launcher_round" android:targetActivity=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity-alias&gt; &lt;activity-alias android:name=".TaobaoAliasActivity" android:enabled="false" android:exported="true" android:icon="@mipmap/ic_taobao" android:label="taobao" android:targetActivity=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity-alias&gt; &lt;/application&gt; &lt;/manifest&gt; 修改图标和App名 object AliasUtils { private const val DEFAULT_ALIAS = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6b142d1caa72433c970a2bb309b45fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67f42ab92e097f772864f2e832ffa0ff/" rel="bookmark">
			java版知识付费saas租户平台：剖析现代知识付费平台的功能架构与运营逻辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数字化学习的时代背景下，知识付费平台已经成为教育行业的一颗璀璨明星，以其用户需求为中心，提供便捷高效的学习途径。这些平台汇聚了众多专业知识，覆盖职业技能、生活兴趣和人文社科等多个领域，满足不同用户的学习需求。同时，提供视频播放、在线问答、作业批改等学习工具和服务，帮助用户更好地掌握知识。用户可以根据自己的兴趣和需求选择合适的课程，进行系统性地学习，提升自身综合素质。
本文将深入探讨该知识付费平台的核心功能模块及其子模块，揭示其背后的功能拆分逻辑。
一、用户管理模块
用户管理是平台运营的核心，包括用户列表、粉丝列表和用户动态。用户列表支持多维度查询、列表分页、用户管理、详情、编辑、删除和余额调整等功能。粉丝列表和用户动态同样支持多维度查询和列表分页，为平台带来更紧密的社区互动体验。
二、课程管理模块
课程管理是平台的教学基石，包括课程列表、首页推荐、观看记录、收藏管理和评论管理。课程列表支持多维度查询、列表分页、课程管理、修改、删除、视频码、添加报告和系列课程等功能。首页推荐、观看记录、收藏管理和评论管理也支持多维度查询和列表分页，为用户提供个性化的学习体验。
三、专家管理模块
专家管理为用户提供了与行业专家互动的机会，包括专家列表、专家话题、首页推荐、专家收藏和评论管理。专家列表支持多维度查询、列表分页、修改和删除等功能。专家话题、首页推荐、专家收藏和评论管理同样支持多维度查询和列表分页，使用户能够轻松追踪心仪的专家及其最新动态。
四、商业机会模块
商业机会模块为平台带来了商业价值的提升，包括商业机会列表、商业机会推荐和商业机会用户。商业机会列表支持多维度查询、列表分页、添加推荐和取消推荐等功能。商业机会推荐和商业机会用户同样支持多维度查询和列表分页，为用户和商家提供了有效的对接平台。
五、职业发展模块
职业发展模块为用户提供职业发展的机会，包括基础数据管理、招聘审核管理和招聘人才管理。基础数据管理包括职位管理、技能管理和行业管理，支持查询、重置、添加、列表分页、修改、删除等功能。招聘审核管理包括岗位审核和人才审核，支持多维度查询、列表分页、查询、重置和查看等功能。招聘人才管理支持人才信息的查询、列表分页、重置、添加、修改和删除等功能。
六、活动管理模块
活动管理为平台带来丰富的线下互动体验，包括活动列表、活动推荐、活动用户和活动评价。活动列表支持多维度查询、列表分页、查询、重置、添加、修改、票种管理、签到码下载、活动二维码、成员管理和删除等功能。活动推荐、活动用户和活动评价同样支持多维度查询和列表分页，为用户提供了全面的活动管理功能。
七、行业资讯模块
行业资讯为用户提供行业动态和资讯，包括资讯列表和推荐资讯。资讯列表支持多维度查询、列表分页、重置、添加、修改、查看评论和删除等功能。推荐资讯支持多维度查询、列表分页、添加推荐和取消推荐，为用户提供了丰富的资讯获取渠道。
八、平台信息模块
平台信息为用户提供了平台的基本信息和联系方式，包括平台信息的查询、重置、修改和删除等功能。
九、交易管理模块
交易管理为平台提供了交易管理的功能，包括专家订单、商业机会订单、开通会员订单、付费课程订单和活动订单。各订单管理支持多维度查询、列表分页和查看等功能。
十、资金管理模块
资金管理为平台提供了资金管理的功能，包括提现配置、用户账单和提现审核。提现配置支持查询、重置和修改等功能。用户账单和提现审核支持多维度查询、列表分页、重置、导出、处理和详情等功能。
十一、内容审核模块
内容审核为平台提供了内容审核的功能，包括专家认证审核和专家信息审核，支持多维度查询、列表分页和详情等功能。
十二、消息通知模块
消息通知为用户提供了消息通知的功能，包括消息列表，支持多维度查询、列表分页、重置和添加等功能。
十三、运营工具模块
运营工具为平台运营者提供了全面的运营管理工具，包括分享注册、广告管理、专家分享收益设置、VIP会员收费设置、课程收益设置和订单设置。各管理支持查询、重置、列表分页、修改等功能。
在数字化学习的时代背景下，知识付费平台已经成为教育行业的一颗璀璨明星，以其用户需求为中心，提供便捷高效的学习途径。这些平台汇聚了众多专业知识，覆盖职业技能、生活兴趣和人文社科等多个领域，满足不同用户的学习需求。同时，提供视频播放、在线问答、作业批改等学习工具和服务，帮助用户更好地掌握知识。用户可以根据自己的兴趣和需求选择合适的课程，进行系统性地学习，提升自身综合素质。
本文将深入探讨该知识付费平台的核心功能模块及其子模块，揭示其背后的功能拆分逻辑。
一、用户管理模块
用户管理是平台运营的核心，包括用户列表、粉丝列表和用户动态。用户列表支持多维度查询、列表分页、用户管理、详情、编辑、删除和余额调整等功能。粉丝列表和用户动态同样支持多维度查询和列表分页，为平台带来更紧密的社区互动体验。
二、课程管理模块
课程管理是平台的教学基石，包括课程列表、首页推荐、观看记录、收藏管理和评论管理。课程列表支持多维度查询、列表分页、课程管理、修改、删除、视频码、添加报告和系列课程等功能。首页推荐、观看记录、收藏管理和评论管理也支持多维度查询和列表分页，为用户提供个性化的学习体验。
三、专家管理模块
专家管理为用户提供了与行业专家互动的机会，包括专家列表、专家话题、首页推荐、专家收藏和评论管理。专家列表支持多维度查询、列表分页、修改和删除等功能。专家话题、首页推荐、专家收藏和评论管理同样支持多维度查询和列表分页，使用户能够轻松追踪心仪的专家及其最新动态。
四、商业机会模块
商业机会模块为平台带来了商业价值的提升，包括商业机会列表、商业机会推荐和商业机会用户。商业机会列表支持多维度查询、列表分页、添加推荐和取消推荐等功能。商业机会推荐和商业机会用户同样支持多维度查询和列表分页，为用户和商家提供了有效的对接平台。
五、职业发展模块
职业发展模块为用户提供职业发展的机会，包括基础数据管理、招聘审核管理和招聘人才管理。基础数据管理包括职位管理、技能管理和行业管理，支持查询、重置、添加、列表分页、修改、删除等功能。招聘审核管理包括岗位审核和人才审核，支持多维度查询、列表分页、查询、重置和查看等功能。招聘人才管理支持人才信息的查询、列表分页、重置、添加、修改和删除等功能。
六、活动管理模块
活动管理为平台带来丰富的线下互动体验，包括活动列表、活动推荐、活动用户和活动评价。活动列表支持多维度查询、列表分页、查询、重置、添加、修改、票种管理、签到码下载、活动二维码、成员管理和删除等功能。活动推荐、活动用户和活动评价同样支持多维度查询和列表分页，为用户提供了全面的活动管理功能。
七、行业资讯模块
行业资讯为用户提供行业动态和资讯，包括资讯列表和推荐资讯。资讯列表支持多维度查询、列表分页、重置、添加、修改、查看评论和删除等功能。推荐资讯支持多维度查询、列表分页、添加推荐和取消推荐，为用户提供了丰富的资讯获取渠道。
八、平台信息模块
平台信息为用户提供了平台的基本信息和联系方式，包括平台信息的查询、重置、修改和删除等功能。
九、交易管理模块
交易管理为平台提供了交易管理的功能，包括专家订单、商业机会订单、开通会员订单、付费课程订单和活动订单。各订单管理支持多维度查询、列表分页和查看等功能。
十、资金管理模块
资金管理为平台提供了资金管理的功能，包括提现配置、用户账单和提现审核。提现配置支持查询、重置和修改等功能。用户账单和提现审核支持多维度查询、列表分页、重置、导出、处理和详情等功能。
十一、内容审核模块
内容审核为平台提供了内容审核的功能，包括专家认证审核和专家信息审核，支持多维度查询、列表分页和详情等功能。
十二、消息通知模块
消息通知为用户提供了消息通知的功能，包括消息列表，支持多维度查询、列表分页、重置和添加等功能。
十三、运营工具模块
运营工具为平台运营者提供了全面的运营管理工具，包括分享注册、广告管理、专家分享收益设置、VIP会员收费设置、课程收益设置和订单设置。各管理支持查询、重置、列表分页、修改等功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/676cd8d4b2515dd047ffcc77a6c32758/" rel="bookmark">
			七月份大理站、ACM独立出版、高录用稳检索，2024年云计算与大数据国际学术会议（ICCBD 2024)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【ACM独立出版 | 高录用 | EI核心检索稳定】
2024年云计算与大数据国际学术会议（ICCBD 2024) 2024 International Conference on Cloud Computing and Big Data (ICCBD 2024)
一、重要信息
大会官网：www.iccbd.net （点击投稿/参会/了解会议详情）
会议时间：2024年7月26-28日
会议地点：中国-大理
截稿时间：2024年06月30日（早投递，早送审，早录用）
接受/拒稿通知：投稿后1周左右
收录检索：EI Compendex，Scopus
支持单位：电子科技大学、AEIC学术交流中心、西南交通大学、莱斯特大学、斯威本科技大学、纽约州立大学
二、大会简介
2024年云计算与大数据国际学术会议(ICCBD 2024)将于2024年7月26-28日在中国大理召开。ICCBD 2024将围绕“云计算与大数据”的最新研究领域,旨在为从事研究的专家、学者、工程师和技术人员提供一个国际平台，分享科研成果和尖端技术，了解学术发展趋势，拓宽研究思路，加强学术研究和讨论，促进学术成果的产业化和合作。热切欢迎各高校、科研机构、学者、企业界等有关人士参加会议，发表意见。 三、大会组委 大会主席 李克勤
IEEE/AAAS/AAIA Fellow
纽约州立大学
湖南大学
龙承念 教授
IEEE Senior Member
上海交通大学
陈志奎 教授
大连理工大学
吴晓 教授
西南交通大学
程序委员会主席 张引 教授
IEEE/ACM Senior Member
电子科技大学
Jinsong Wu
IEEE Senior Member
智利大学
邓玉辉 教授
暨南大学
孔祥杰 教授
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/676cd8d4b2515dd047ffcc77a6c32758/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91af875cc69a2080e6572769e5183ae5/" rel="bookmark">
			Incredibuild for Mac 来了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mac 开发者在寻找适合自己需求的工具时可能会遇到一些困难，因为 Mac 操作系统相对封闭，不像其他系统那样开放和灵活。尽管如此，Mac 开发者在开发应用程序时的需求（比如功能、效率等）和使用其他操作系统的开发者是类似的。有时候，这种封闭性可能会让 Mac 开发者在开发 iOS 和 MacOS 应用时以及将 Windows 应用移植到 Mac 时，遇到一些额外的挑战或不便。
今天，我们很高兴地宣布，Mac 开发者（以及将应用程序移植到 Mac 和 iOS 的 Windows 开发者）不再需要花费数小时等待构建了！Incredibuild 正式支持 Mac 和 iOS 的开发，并带来更快的构建和成本优化。这对 Mac 开发者来说意味着什么呢？
在原生开发环境中，Incredibuild 助力开发！ Mac 开发的一个重要部分是需要在与发布应用程序相同的开发环境中进行构建。原因很简单——开发者需要确保构建的产品在它们将运行的生态系统中正常工作。这也是 Mac 开发者面临的挑战之一。
对于 Windows 和 Linux 开发者来说，有无数的工具可用，Incredibuild 多年来一直在这些生态系统上加速构建 3 倍到 4 倍（在某些情况下甚至更多），现在，Mac 开发者也可以得到类似的效率提升了！
使用 Incredibuild，开发者可以使用已经在开发的工具，不必担心添加到工具链中的工具会影响工作流程。
Incredibuild 当前支持：
操作系统：
MacOS 13.xMac 14.x 编程语言：
CC++ development 构建系统：
Xcode 14.xXcode 15.x 构建管理工具：
CmakeXcode Native 编译器：
Clang (Apple)Clang ++GCC, G++/GNU 虚幻引擎：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91af875cc69a2080e6572769e5183ae5/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/298/">«</a>
	<span class="pagination__item pagination__item--current">299/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/300/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>