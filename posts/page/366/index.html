<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e525e226cbcb911f2a65eaab8a31941/" rel="bookmark">
			whisper报错：hp， ht， pid， tid = _winapi.CreateProcess [WinError 2] 系统找不到指定的文件。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		in _execute_child
hp， ht， pid， tid = _winapi.CreateProcess（executable， args，
FileNotFoundError： [WinError 2] 系统找不到指定的文件。
原因：
没装ffmpeg 或者 ffmpeg没添加到系统环境变量
解决办法：
https://www.gyan.dev/ffmpeg/builds/
下载下图压缩包，并解压
然后在系统Path环境变量添加bin路径：
右击此电脑——&gt;属性——&gt;高级系统设置——&gt;环境变量
配置完成后运行cmd，输入ffmpeg，若显示如下界面，则说明配置成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/097770b74bd690e0adf6f51c76233a23/" rel="bookmark">
			HIVE调优-数据倾斜优化（详细版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HIVE调优-数据倾斜优化 目录
HIVE调优-数据倾斜优化
1.排序优化
1）order by 2）distribute by + sort by 3）cluster by语句：
2.数据倾斜优化
1）原因：
2）表现：
3）创建表格（查看一下具体效果）
4) 如果想展示数据倾斜效果：
5) 解决方法：
1.排序优化 1）order by 全局排序操作, 只有一个Reduce任务去对数据进行排序，会造成全部的数据堆积在一个Reduce任务中进行处理
经常会出现OOM异常？ 一个Reduce任务的内存是有限的，承载不了太多数据
2）distribute by + sort by distribute by：是指我们的分区操作
sort by： 跟上distribute by 之后可以实现在分区内进行排序，
如果当前的Reduce数量为1，那么也没有优化的效果，可以通过设置reduce的数量对不同分区中的数据进行拆分排序
通过 set mapreduce.job.reduces = N; 设置Reduce数量，默认参数值为-1 即根据资源及查询语句情况进行分配reduce,
3）cluster by语句： 如果分区字段和排序字段是同一个字段，那么和 distribute by + sort by 效果一致
2.数据倾斜优化 1）原因： 1.Key分布不均,导致某一些Key在做Reduce端处理时，执行较慢
2.数据重复，在关联时，会产生笛卡尔积，致使数据膨胀，严重的可能会导致集群挂掉 2）表现： 任务进度长时间维持在99%（或100%），
查看任务监控页面，发现只有少量（1个或几个）reduce子任务未完成。因为其处理的数据量和其他reduce差异过大
3）创建表格（查看一下具体效果） 1.创建带有部分NULL的学生表和成绩表
1.创建带有部分NULL的学生表和成绩表 DROP TABLE learn4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/097770b74bd690e0adf6f51c76233a23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b2f164ff7c92c640aef8c08fcbe806f/" rel="bookmark">
			Android Studio实现美食外卖系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目目录 一、项目概述二、开发环境三、详细设计1、数据库设计2、增删改查3、数据源（1）JSON文件（2）JSON解析 四、运行演示五、源码获取 一、项目概述 安卓美食外卖系统应用SQLite数据库、RecycleView列表、SharedPreferences存储、Adapter、Fragment等技术完成，对数据库的CRUD使用的淋漓尽致。启动应用，进入欢迎页面，选择新用户注册，注册成功后自动跳转至登录页面，选择记住密码则下次登录时免输账号和密码。登录成功进入主页面，底部导航栏默认显示店铺，进入任意店铺，显示商品的信息，点击商品图片显示详情，点击加入购物车，也可以在下方选择加减数量，或者清空购物车。在下方可以查看购物车中商品总数量和总价格，点击去结算进入支付页面。支付页面需要先选择收货地址，没有就要从我的导航栏中添加收货地址，然后进行支付；如果余额不足，则需要账户余额中进行充值。地址选择之后，余额也充足则支付成功，提交好订单。回到我的导航栏，在此可以更换头像、添加地址信息、充值账户余额、查看历史订单。长按可以删除地址信息和历史订单，还可以分享软件和退出登录。
总体而言，系统设计逻辑清晰合理，用户提示丰富，使用体验良好，界面美观大方，功能齐全。
二、开发环境 三、详细设计 1、数据库设计 数据库名称为takeaway.db，数据表有4张，分别为：用户表、地址表、余额表和订单表。
用户表：账号（主键）、密码地址表：账号、姓名、电话、详细地址（复合键）余额表：账号（主键）、金额订单表：账号、编号（主键）、日期、店铺、价格、内容 public class MyDBOpenHelper extends SQLiteOpenHelper { // 数据库文件名为takeaway.db，版本号为1 public MyDBOpenHelper(Context context) { super(context, "takeaway.db", null, 1); } // 创建用户表User public static final String CREATE_TABLE_USER = "create table User (" + "account text primary key," + "password text)"; // 创建地址表Address，定义复合键为所有字段 public static final String CREATE_TABLE_ADDRESS = "create table Address (" + "account text," + "name text," + "phone text," + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b2f164ff7c92c640aef8c08fcbe806f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8b06a0c585209987b1f7d9d92ccaa0b/" rel="bookmark">
			Flutter 中的 GestureDetector 小部件：全面指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flutter 中的 GestureDetector 小部件：全面指南 在 Flutter 中，GestureDetector 是一个允许你检测和处理各种手势的小部件。它可以识别多种手势，包括点击、双击、长按、拖动、缩放等。GestureDetector 非常灵活，常用于为应用中的交互添加手势支持。
基础用法 GestureDetector 最基本的用法是包裹其他小部件，并为其添加点击事件处理：
GestureDetector( onTap: () { // 当用户点击时执行的代码 }, child: Container( width: 100.0, height: 100.0, color: Colors.blue, ), ) 在这个例子中，当用户点击蓝色方块时，会执行 onTap 回调。
处理多种手势 GestureDetector 可以同时处理多种手势。以下是一些常用的手势处理：
onDoubleTap（双击） onDoubleTap: () { // 用户双击时执行的代码 } onLongPress（长按） onLongPress: () { // 用户长按时执行的代码 } onPanUpdate（拖动更新） onPanUpdate: (details) { // 用户拖动时执行的代码 // details.localPosition 包含当前触摸点的位置 } onScaleUpdate（缩放更新） onScaleUpdate: (details) { // 用户缩放时执行的代码 // details.scaleFactor 包含缩放因子 // details.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8b06a0c585209987b1f7d9d92ccaa0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6dbf9e136d9eb82de0e158397defd10/" rel="bookmark">
			C&#43;&#43;初阶学习第七弹——探索STL奥秘（二）——string的模拟实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标准库中的string：C++初阶学习第六弹——string（1）——标准库中的string类-CSDN博客
前言：
在前面我们已经学习了如何使用标准库中的string类，但作为一个合格的程序员，我们不仅要会用，还要知道如何实现string中的类函数等内容，今天我们就来讲解一下string的模拟实现
目录
一、string类的构造
二、string类的拷贝构造
三、string类的析构函数
四、string类的运算符重载
1、operator=的传统写法
2、operator=的现代写法
五、代码实例
六、总结
string的模拟实现中最重要的就是string类的构造、拷贝构造、赋值运算符重载以及析构函数
接下来我们就围绕这些重点进行学习
一、string类的构造 首先我们要清楚string类在底层实际上就是一个字符指针和许多类函数，所以它的类成员变量就是：
private: char* _str; 我们先把模拟构造给出来再来讲解：
//为了区分标准库，我们用String class String { public: String(const char* str = "") { if (str == nullptr) { assert(false); return; } _str = new char[strlen(str) + 1]; strcpy(_str, str); } void String_print() { cout &lt;&lt; _str &lt;&lt; endl; } private: char* _str; }; int main() { String s1("abc"); s1.String_print(); return 0; } 运行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6dbf9e136d9eb82de0e158397defd10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb89e56e35b0a04d21967d5b1f9686b2/" rel="bookmark">
			前端开发者必备：Nginx入门实战宝典，从部署到优化一网打尽
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥 个人主页：空白诗 文章目录 引言 👋一、Nginx简介 📚二、常见的Web服务器架构 🌀📌 架构概述📌 Nginx的深入探讨 三、正向代理与反向代理 🔮📌 正向代理工作原理📌 反向代理工作原理📌 Nginx 实现正向代理配置（Nginx）反向代理配置（Nginx） 四、负载均衡策略与Nginx的深度应用 🚀📌 负载均衡策略概述📌 Nginx：反向代理与负载均衡的进阶实践📌 微服务架构与Nginx的集成📌 中间件集成与数据一致性保障 五、深入Nginx配置与实践 🔧1. 配置文件结构2. 配置详情2.1 HTTP全局配置2.2 Events模块配置2.3 Server块配置2.4 Location块配置 3. 日志与监控3.1 日志配置基础3.2 自定义日志格式3.3 日志切割与管理3.4 日志分析与监控 4. 性能调优4.1 优化Worker配置4.2 优化静态资源处理4.3 配置高效SSL/TLS4.4 利用HTTP/2特性4.5 避免不必要的模块加载4.6 使用Micro-Caching4.7 监控与日志分析4.8 定期评估与调整 5. 高可用部署5.1 使用Keepalived实现高可用5.2 Nginx-Upstream-Checksum-Module5.3 集成Zabbix等监控系统 六、完整Nginx配置示例 - CentOS为例 🖥️📌 安装📌 验证📌 配置 七、总结 🏁 引言 👋 在现代Web开发的浪潮中，前端工程师不仅要精通HTML、CSS、JavaScript等基础技术，了解后端服务和网络架构也变得日益重要。Nginx，这个以高性能著称的Web服务器和反向代理服务器，便是每位前端开发者不应错过的技能点。本文旨在为前端开发者提供一份详尽的Nginx学习指南，从理论到实践，助你解锁性能优化的新技能树。✨
一、Nginx简介 📚 Nginx，正确发音为"engine-x"，诞生于2004年，由俄罗斯程序员Igor Sysoev匠心打造。它迅速崛起为互联网基础架构中的关键技术组件。
📊 核心特性概览：
高并发处理能力：有效管理数以万计的同时请求，无损性能。低内存消耗：在资源受限环境维持高效运作，对成本控制意义重大。稳定性：确保服务持续可用与可靠性，赢得广泛企业信任。 ⚙️ 技术核心 - 事件驱动模型，这一机制使得Nginx能在执行请求处理时实施非阻塞IO操作，即使面临突发的大流量冲击，系统也能保持快速响应和整体稳健。这使得Nginx成为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb89e56e35b0a04d21967d5b1f9686b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecfd0517cacf328ede645f298eb7dd1a/" rel="bookmark">
			浅谈java，python，c&#43;&#43;的差异
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java，Python和C++是三种常见的编程语言，它们在很多方面有着不同的特点。以下是它们的一些主要异同点：
宏观应用 语法和风格：
Java：Java是一种静态类型语言，语法相对严谨，需要显式声明变量的类型。Java通常被用于大型企业应用程序开发。Python：Python是一种动态类型语言，语法简洁清晰，被称为“优雅的编程语言”。Python适合快速开发原型和小型项目。C++：C++是一种中级语言，支持面向对象编程、过程式编程和泛型编程。C++通常被用于系统级编程和游戏开发等领域。 性能：
Java：Java是一种解释型语言，通常比C++和Python运行速度稍慢，但有着良好的跨平台性。Python：Python是一种解释型语言，运行速度相对较慢，适合开发速度要求不高的应用。C++：C++是一种编译型语言，通常比Java和Python运行速度更快，适合对性能要求较高的应用。 内存管理：
Java：Java具有自动内存管理（垃圾回收），开发者不需要手动管理内存。Python：Python也具有自动内存管理，使用了垃圾回收机制。C++：C++需要手动管理内存，开发者需要负责分配和释放内存，这可能导致内存泄漏和指针错误。 平台支持：
Java：Java是一种跨平台语言，一次编写，到处运行（Write Once, Run Anywhere），通过Java虚拟机（JVM）实现跨平台性。Python：Python同样具有良好的跨平台性，可以在多个操作系统上运行。C++：C++的跨平台性取决于编译器和目标平台，需要针对不同平台进行编译。
类型安全性： 应用领域：
Java：Java在企业级开发和Web开发领域有很强的优势，拥有丰富的框架支持。Python：Python在科学计算、人工智能等领域有很强的应用，也有丰富的框架支持。C++：C++在游戏开发、系统级编程等领域有较为突出的表现，框架相对专业化。 编程细节 类型安全性：
Java：Java是一种强类型语言，要求变量的类型在编译时就确定，不允许隐式类型转换。Python：Python是一种动态类型语言，变量的类型在运行时确定，允许灵活的类型转换。C++：C++是一种静态类型语言，要求变量的类型在编译时确定，但也允许显式类型转换。 函数重载：
Java和C++：Java和C++支持函数重载，允许定义多个同名函数。Python：Python不支持函数重载，因为Python是动态类型语言，函数的参数类型在运行时确定。 参数传递方式：
Java和Python：Java和Python都是值传递，但对于可变对象，Python传递的是对象的引用。C++：C++支持值传递、引用传递和指针传递，提供更多的灵活性。 返回值：
Java和C++：Java和C++都支持明确指定函数的返回类型。Python：Python函数可以返回多个值，实际上是返回一个元组。 面向对象 Java： 类和对象：Java是一种纯粹的面向对象编程语言，所有代码都必须定义在类中。Java通过类和对象的方式来组织代码，支持封装、继承和多态。
封装：Java通过访问修饰符（public、private、protected）来实现封装，控制类的成员的访问权限。
继承：Java支持单继承，一个类可以继承另一个类的属性和方法。Java中的继承通过关键字extends来实现。
多态：Java支持多态，允许不同类的对象对同一消息作出不同响应。多态性通过方法重写（override）和方法重载（overload）来实现。
Python： 类和对象：Python也是一种面向对象的语言，支持类和对象的概念。Python中的一切都是对象，包括数字、字符串等基本类型。
封装：Python通过命名约定（以单下划线开头表示protected，以双下划线开头表示private）来实现封装，但是并不能真正限制访问。
继承：Python支持多继承，一个类可以继承多个父类的属性和方法。Python中的继承通过在类定义时指定父类来实现。
多态：Python同样支持多态，Python的多态性是动态的，不需要显式声明。
C++： 类和对象：C++也是一种面向对象的语言，支持类和对象的概念。C++中的类可以包含成员变量和成员函数。
封装：C++通过访问修饰符（public、private、protected）来实现封装，控制类的成员的访问权限。
继承：C++支持单继承和多继承，一个类可以继承另一个类或多个类的属性和方法。C++中的继承通过关键字public、protected、private来实现。
多态：C++同样支持多态，通过虚函数（virtual function）和纯虚函数（pure virtual function）来实现运行时多态。
编程框架 Java： 框架丰富：Java生态系统非常庞大且成熟，拥有众多优秀的框架和库，涵盖了各种领域，如企业应用开发、Web开发、移动开发等。一些知名的Java框架包括Spring框架、Hibernate、Struts等。
企业级框架：Java在企业级开发中非常流行，有很多专门为企业级应用开发的框架，如Spring框架，它提供了全面的解决方案，包括依赖注入、面向切面编程等。
Web框架：Java也有很多优秀的Web框架，如Spring MVC、Struts、Play Framework等，用于开发Web应用程序。
Python： 框架生态：Python的框架生态也非常丰富，适用于各种应用场景，如Web开发、科学计算、人工智能等。知名的Python框架包括Django、Flask、PyTorch等。
Web框架：Python在Web开发领域有很多流行的框架，如Django、Flask、FastAPI等，它们提供了简单易用的方式来构建Web应用。
数据科学框架：Python在数据科学和人工智能领域也非常流行，有很多优秀的框架和库，如NumPy、Pandas、TensorFlow、PyTorch等。
C++： 框架相对较少：相对于Java和Python，C++的框架相对较少，主要集中在特定领域，如游戏开发、图形学等。
游戏开发框架：C++在游戏开发领域非常流行，有一些知名的游戏引擎和框架，如Unity、Unreal Engine等，它们提供了强大的功能和性能优势。
系统级框架：C++在系统级编程和嵌入式开发中也有一些框架，如Boost库，它提供了许多功能强大的C++库，用于系统级编程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d4f4fbd2c16983cfbe2f9d48cea5a09/" rel="bookmark">
			AI&#43;新能源充电桩数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要的同学私信联系，推荐关注上面图片右下角的订阅号平台 自取下载。
随着我国新能源汽车市场的蓬勃发展，充电桩的需求量日益增加，充电桩的智能化程度不仅影响充电站运营商的经营效益，也大大影响着用户的充电体验。AI技术可以涵盖充电站/充电桩从车辆进场、充电中、充电完成离场的全流程算法方案赋能，目标检测、语义分割等AI技术可以识别充电桩产品零件中缺陷；AI预测性维护技术可以对充电桩进行实时感知，进行相应的预测并发出警报；AI时空预测技术还可以建模充电桩使用电量，提高充电桩的使用率。
AI+新能源充电桩可以促进充电桩领域的人工智能技术产、学、研、用协作，引领行业技术创新，助力新能源充电桩的高质量发展，进一步推广人工智能与充电桩领域的融合创新应用。因此小编在这里整理了一份AI+新能源充电桩数据集，共包含7+细分场景数据集，助力AI+新能源充电桩领域的研究与创新。来吧，涨涨姿势~
1. California EV Charging Dataset
2. South Korea EV Charging Dataset
3. 深圳市充电桩时空需求数据集
4. 广州市充电桩占用率数据集
5. 新能源充电桩故障检测数据集
6. 居民家用新能源充电桩数据集
7. 新能源充电站负荷预测数据集
01
—
California EV Charging Dataset
【数据背景】Palo Alto EV充电站数据集提供了加利福尼亚州帕洛阿尔托市电动汽车（EV）充电站的使用模式数据，研究人员可以利用该数据集研究收费行为，开发预测模型，并提出优化充电站放置的策略。企业可以使用数据来确定扩大充电基础架构并改善用户体验的机会。Palo Alto EV充电站通过数据驱动的方法来支持EV基础架构计划和管理，从而支持可持续的移动性计划。它使利益相关者有能力做出明智的决定，增强电动汽车充电生态系统，并为更广泛的电动汽车采用，以实现更绿色可持续的未来。
【应用领域】AI+充电站模式管理
【文件目录】包含以下所示的文件：
EVChargingStation.csv：数据文件夹
eda-evchargingpaloaltoca.ipynb：eda分析
【数据说明】包括有关充电站位置的详细信息、可用的充电连接器类型、充电会话持续时间、能源消耗和其他相关指标，使用户能够分析趋势，确定峰值使用时间，评估基础架构性能以及开发数据驱动的解决方案，以提高EV充电服务的效率和可访问性。EVChargingStation.csv将每个充电会话的所有字段数据存档为单个数据点，数据收集开始日期为2011年7月29日，结束日期为2020年12月31日，数据持续时间达9年多，所有可用数据都以逗号分隔值（csv）文件的形式逐行保存，所包含的主要数据字段如下所示：
1. Station Name：充电站名字；
2. MAC Address：充电桩的MAC地址；
2. Org Name：城市名字；
3. Start Date：开始充电的时间戳；
4. Start Time Zone：进行充电所在的时区；
5. End Date：充电结束的时间戳；
6. End Time Zone：结束充电所在的时区；
7. Transaction Date (Pacific Time)：交易时间（太平洋时间）；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d4f4fbd2c16983cfbe2f9d48cea5a09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce176ffe6cf5f2d02c3a3ffea315c29b/" rel="bookmark">
			Java安装与环境搭建（Mac）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		⚠️注：本教程只适用于Mac操作系统
一、安装JDK开发工具包 打开Oracle官网www.oracle.com-&gt;developer，选择java版本，应选择长期版本，例如1.17、1.11、1.8、1.7、1.6，但官网下载速度太慢。
这里推荐国内镜像下载https://www.injdk.cn，对于Mac操作系统，应用程序是dmg扩展的，选择ARM64 DMG Installer
“macosx-x64.dmg” 下载完成后，直接按指引安装。默认安装路径是/library/java/JavaVirtualMachines，其中bin目录存放的是开发工具、lib目录存放的是jar包，src目录存放的是源码。
二、环境配置 在Mac搜索“终端”，编写dos命令。为了方便编辑配置文件，需要有root超级管理权限。
1、开启root用户 打开系统偏好设置，选择“用户与群组”，
按图选择，打开锁，点击“加入”
点击“打开目录使用工具”
解锁
在菜单栏里“编辑”中，如果没有启用root，会有“启用Root用户”选项，点击；如果没有就是下图中的样子。
创建Root密码
登录终端，在终端执行以下命令，切换Root账号，此时需要盲输入密码。若要退出root账号，则执行命令exit后返回普通用户。 &gt;&gt; su root &gt;&gt; exit 2、查看路径 新下载的jbk安装后的默认路径是/library/java/JavaVirtualMachines，作为JAVA_HOME目录
在终端可执行命令查看
&gt;&gt; cd /Library/Java/JavaVirtualMachines 接着查看该目录下的文件列表，若安装了多个版本的jdk，则会有多个结果
&gt;&gt; ls jdk-1.8.jdk	jdk-11.jdk 查看当前目录
&gt;&gt; pwd /Library/Java/JavaVirtualMachines 进入当前用户的 home 目录
&gt;&gt; cd ~ /Users/xxx xxx改为自己的电脑用户名称 3、修改配置文件 修改配置文件在终端运行VIM文本编辑器。并在普通用户目录下，执行sudo命令可以使用超级管理权限编辑和保存配置文件。
查看当前环境变量
&gt;&gt; export 在默认用户目录下，创建配置文件
&gt;&gt; touch ~/.bash_profile 打开VIM编辑器编辑配置文件
&gt;&gt; sudo vim ~/.bash_profile 在VIM编辑器输入 i 进入编辑模式，若安装多个jdk版本，则输入文本内容如下。
⚠️：配置文件中alias定义的别名jdk8、jdk11是用来切换jdk版本的。
# JDK Config JAVA_HOME_8=/Library/Java/JavaVirtualMachines/jdk-1.8.jdk/Contents/Home JAVA_HOME_11=/Library/Java/JavaVirtualMachines/jdk-11.jdk/Contents/Home export JAVA_HOME=$JAVA_HOME_8 alias jdk8="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce176ffe6cf5f2d02c3a3ffea315c29b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e370721e37c80883ce38a2477ec9c70/" rel="bookmark">
			「屏蔽更新」 Mac如何屏蔽系统更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.直接修改host文件
首先打开访达界面，然后按住快捷键：Command+Shift+G；
最后在弹出的对话框里复制下方路径并粘贴，如下图：
/private/etc/hosts
127.0.0.1 swdist.apple.com 127.0.0.1 swscan.apple.com 127.0.0.1 swcdn.apple.com #optional, download url 127.0.0.1 gdmf.apple.com 127.0.0.1 mesu.apple.com 127.0.0.1 xp.apple.com 2.通过命令修改
command+空格键输入「终端」，并输入以下命令：
sudo vi /etc/hosts
3.恢复升级
后续想要恢复系统更新的话也比较简单，将添加到 hosts 文件里的条目删除即可，执行第二步然后删除条目并保存就可以恢复如初了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24af33023869c970bd46d32ea9289c0c/" rel="bookmark">
			MongoDB和AI 赋能行业应用：制造业和汽车行业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎阅读“MongoDB和AI 赋能行业应用”系列的第一篇。
本系列重点介绍AI应用于不同行业的关键用例，涵盖制造业和汽车行业、金融服务、零售、电信和媒体、保险以及医疗保健行业。
随着人工智能（AI）在制造业和汽车行业的集成，传统的价值链正在经历一场革命性的转变。工业物联网（IoT）的引入使得企业能够从资产中收集和分析大量数据，这不仅提升了库存管理的智能化水平，还使得预测性维护成为可能，极大地提高了运营效率和可靠性。
库存管理 高效的供应链不仅可以确保准时向客户交付，而且还可以控制运营成本。为了实现这个目标，管理并优化库存水平、规划需求波动以及削减成本都是至关重要的。然而，高效的库存管理也给制造商带来了复杂的数据挑战，主要是在准确预测需求和优化库存水平方面。这些正是AI可以提供帮助的地方。
图1：使用MongoDB 进行的生成式人工智能（Gen AI）需求预测
AI算法可以分析复杂的数据集，从而预测客户对产品或组件未来的需求。需求预测的准确性越高，则越有利于维持最佳的库存水平。
●预测需求量：客户需求是在快速变化的，而基于AI的时间序列预测可以帮助制造商快速适应，通过分析历史销售数据和市场趋势，确定最合适的库存水平，甚至避免人工错误。
●制定需求管理模式：Gen AI可以帮助生成库存的综合数据和时令性调整的需求模式。
●场景模拟：Gen AI可以帮助创建模拟供应链中断的场景。
MongoDB 可以让这些过程更轻松地实现。在仓库中，可以使用移动设备扫描库存，并将这些数据持久化到MongoDB中，并使用Device Sync同步到MongoDB（此方案已有MongoDB客户在使用，如Grainger）。一旦数据进入MongoDB，它就可以作为所有库存相关数据的中央存储库，同时为AI应用程序提供数据来源，从而消除数据孤岛，提高整体库存水平和动态的可见性。通过使用MongoDB 的Vector Search和Gen AI，制造商可以轻松地根据时令属性对产品进行分类，对具有相似时令需求模式的产品进行聚类，并为基础模型提供上下文，从而提高库存的综合数据生成的准确性。
预测性维护 如今，最基本的维护方法是被动的——让资产保持运行，直到实际发生故障为止。资产仅根据需要维护，因此很难进行预估。然而，预防性维护则根据保守的时间表更换系统或组件，从而防止常见故障的发生，但由于要在产品报废前频繁更换组件，因此预防性维护的实施成本很高。
图2：使用MongoDB进行基于音频的异常检测
AI可以让预测性维护更加高效，利用物联网传感器从机器上收集数据，并通过对数据进行训练来检测异常情况，从而有效地进行预测性维护。
●异常预警：ML/AI 算法（如回归模型或决策树）在预处理数据上进行训练，部署在现场环境进行推理，并持续分析传感器数据。检测到异常情况时，会生成警报通知维护人员，这样就可以主动规划和执行维护操作，最大限度地减少停机时间，优化设备可靠性和性能。为了提高准确性，可以部署检索增强生成（RAG）架构来生成或管理数据预处理器，从而补充专业的数据科学知识，同时也可以让领域专家为大型语言模型提供正确的指令。
●维修指导：一旦AI模型生成了维修警报，Gen AI就可以进一步提出维修策略建议，并将备件库存数据、维修预算和个人可用性考虑在内。最后，还可以将维修手册可以处理成向量，输入给智能问答机器人，从而指导技术人员进行实际维修。
MongoDB能够有效支撑以上场景。
一方面，MongoDB固有的灵活的文档模型支持开发者随时进行数据管理。由于机器健康预测模型不仅需要传感器数据，还需要维护历史和库存数据，因此文档模型非常适合对这些不同的数据源进行建模，从而支撑预测模型的训练。
另一方面，在物理产品的维护和支持过程中，必须提供产品信息和备件文档等信息，并方便支持人员访问，而MongoDB 提供的全文检索功能就可以帮助工作人员从集群中轻松检索信息。制造商可以使用MongoDB 探索简化机器诊断的方法，比如从机器中录制音频文件并转化为向量，通过向量检索获得类似的案例。还可以使用RAG实现一个智能问答机器人，技术人员通过与机器人对话获得最符合当下情况的维修指导，了解如何一步一步进行维修操作。
自动驾驶 随着车联网的兴起，汽车制造商不得不将其业务模式转变为软件优先型。汽车制造商开始利用联网汽车产生的数据创建更好的辅助驾驶系统，然而，要制造出比人类驾驶更安全的全自动驾驶汽车是非常难的。一些专家估计，实现 5 级自动驾驶的技术已开发了约 80%，但剩下的 20% 是非常难攻克的，需要大量时间来完善。
图3：MongoDB在自动驾驶中的应用
汽车应用中基于AI的图像和目标识别存在不确定性，但制造商仍然要利用雷达、激光雷达、摄像头和车辆遥测数据来不断进行模型训练。现代汽车就像一个数据中心，不断收集和处理来自车载传感器和摄像头的信息，从而产生大量的数据。强大的存储和分析能力对于管理这些数据至关重要，而实时分析对于作出即时决策以确保安全导航至关重要。MongoDB可以在这些挑战面前发挥重要作用。
●MongoDB能够处理大量非结构化数据，是同时容纳传感器读数、远程信息处理、地图和模型结果等各种数据类型的绝佳方式。
●MongoDB支持在运行时随时添加新字段，让开发人员能够轻松地为原始遥测数据添加上下文信息。
●MongoDB的Search提供了一个高性能搜索引擎，允许数据科学家迭代其感知AI模型。
其他用例 AI在实现工业4.0的承诺中发挥着关键作用。MongoDB 还可支持许多其他AI用例，其中包括：
●物流优化：AI可以帮助优化路线，从而减少延误并提高日常配送的效率。
●质量控制和缺陷检测：在产品生产过程中，计算机或机器视觉可用于识别产品中的异常，确保产品精度达标。
●生产优化：通过分析生产线上安装的传感器的时间序列数据，可以识别并减少浪费，从而提高产量和效率。
●智能售后支持：制造商可以利用AI驱动的对话机器人和预测分析，为客户提供主动维护、故障排除和个性化帮助等服务。
●个性化产品推荐：AI可用于分析用户行为和偏好，通过移动或Web应用提供个性化产品推荐，从而提高客户满意度并促进销售。
AI与制造业和汽车业的融合已经彻底改变了传统流程，为效率和创新带来了大量的机会。借助工业物联网和先进的分析技术，企业现在可以利用大量数据来加强库存管理和预测性维护。AI驱动的需求预测可确保最佳库存水平，而预测性维护技术可最大限度地减少停机时间并优化设备性能。
此外，随着汽车制造商对实现自动驾驶的投入，AI驱动的图像识别和实时数据分析能力变得至关重要。MongoDB 是一个有效的解决方案，通过提供灵活的文档建模和强大的存储功能，应对工业 4.0 的复杂问题。
除制造业和汽车行业外，MongoDB 具备的AI潜力还可扩展到物流优化、质量控制、生产效率、智能售后支持和个性化客户体验等领域，从而塑造工业 4.0 及更远的未来。
以上是本篇的全部内容，在本系列的下一篇文章中，我们将讨论MongoDB+AI在电信和媒体行业的应用。敬请持续关注MongoDB数据平台官方公众号。
敬请期待阿里云MongoDB 的检索和向量新特性
👉点击访问 MongoDB中文官网
👉立即免费试用 MongoDB Atlas
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24af33023869c970bd46d32ea9289c0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/560a8c57e2555de5b6a7904416f6087a/" rel="bookmark">
			llama-cpp-python安装bug：error: subprocess-exited-。scikit-build-core 0.8.2 using CMake 3.28.3 (wheel)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		–
llama-cpp-python安装bug：error: subprocess-exited-。scikit-build-core 0.8.2 using CMake 3.28.3 (wheel) 环境 系统 linux python 3.10 llama_cpp_python==0.2.55 1 Bug详情 # 导致安装错误的命令 pip install llama-cpp-python 错误信息 Building wheel for llama-cpp-python (pyproject.toml) ... error error: subprocess-exited-with-error × Building wheel for llama-cpp-python (pyproject.toml) did not run successfully. │ exit code: 1 ╰─&gt; [325 lines of output] *** scikit-build-core 0.8.2 using CMake 3.28.3 (wheel) *** Configuring CMake... 2024-03-04 17:29:03,943 - scikit_build_core - WARNING - libdir/ldlibrary: /home/zmp/.conda/envs/base_torch_201cu118_cp310/lib/libpython3.10.a is not a real file!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/560a8c57e2555de5b6a7904416f6087a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a4fc70dd6295b973a2c3a45c2a8154f/" rel="bookmark">
			2024年大数据最全使用logstash迁移ES数据并解决限流等问题(1)，2024年最新字节跳动大数据开发三面凉凉
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上学习资料一大堆，但如果学到的知识不成体系，遇到问题时只是浅尝辄止，不再深入研究，那么很难做到真正的技术提升。
需要这份系统化资料的朋友，可以戳这里获取
一个人可以走的很快，但一群人才能走的更远！不论你是正从事IT行业的老鸟或是对IT行业感兴趣的新人，都欢迎加入我们的的圈子（技术交流、学习资源、职场吐槽、大厂内推、面试辅导），让我们一起学习成长！
不知道nohup啥意思的自己搜索下 ## 配置文件 上游elasticsearch文档 https://www.elastic.co/guide/en/logstash/7.10/plugins-inputs-elasticsearch.html 下游elasticsearch文档 https://www.elastic.co/guide/en/logstash/7.10/plugins-outputs-elasticsearch.html 查看文档一顿吭哧吭哧配置文件写好了 input {
上游 elasticsearch {
hosts =&gt; “http://es1.es.com:80”
index =&gt; “xxx”
user =&gt; “elastic”
password =&gt; “XXX”
query =&gt; ‘{ “query”: { “query_string”: { “query”: “*” } } }’
size =&gt; 2000
scroll =&gt; “10m”
docinfo =&gt; true
}
}
output {
下游 elasticsearch {
hosts =&gt; “http://es2.es.com:80”
index =&gt; “xxx”
user =&gt; “elastic”
password =&gt; “XXX”
document_id =&gt; “%{[@metadata][_id]}”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a4fc70dd6295b973a2c3a45c2a8154f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02cf4954fae50d49760155d91048a5cd/" rel="bookmark">
			2024年前端最新WEB前端工具推荐丨分享6个热门颜色选择器组件，2024年最新近期有什么面试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最后 技术是没有终点的，也是学不完的，最重要的是活着、不秃。零基础入门的时候看书还是看视频，我觉得成年人，何必做选择题呢，两个都要。喜欢看书就看书，喜欢看视频就看视频。最重要的是在自学的过程中，一定不要眼高手低，要实战，把学到的技术投入到项目当中，解决问题，之后进一步锤炼自己的技术。
开源分享：【大厂前端面试题解析+核心总结学习笔记+真实项目实战+最新讲解视频】
技术学到手后，就要开始准备面试了，找工作的时候一定要好好准备简历，毕竟简历是找工作的敲门砖，还有就是要多做面试题，复习巩固。
colorjoe 是一个具有触控和 AMD 支持的可扩展颜色选择器。可以通过 CSS 定义其实际尺寸和布局。通过这种方式，该组件非常适合响应式布局。
与那里的许多其他颜色选择器不同，colorjoe 是真正可扩展的。它基于 CSS，不依赖于外部图像。因此，您可以调整其大小以适应您的目的。还支持触控和 AMD 模块定义。
colorjoe 受到 ColorJack 和 RightJS Colorpicker 的启发。与那些不同的是，它实际上可以很好地扩展。从本质上讲，这意味着您将能够使用一些 CSS 定义其实际尺寸和布局。通过这种方式，小部件非常适合响应式布局。
此外，由于它提供的简单 API，实现缺失的功能（RGB 字段等）相对容易。
项目地址：https://github.com/bebraw/colorjoe 安装 npm i colorjoe 如果您更喜欢独立的 dist，请将预打包的dist/colorjoe.js和添加css/colorjoe.css到您的页面或从 src/使用 AMD 。
用法 const joe = colorjoe.rgb(element_id_or_dom_object, initial_color_value, extras); 或者
const joe = colorjoe.hsl(element_id_or_dom_object, initial_color_value, extras); 二、 Colorful
今天，每个依赖项都会拖累更多的依赖项，并且无法控制地增加项目的包大小。但是大小对于打算在浏览器中工作的所有内容都非常重要。React Colorful 是一个用于 React 和 Preact 应用程序的小型颜色选择器组件，使用 hooks 和函数组件构建。它使用严格的 TypeScript 编写，具有 100% 的测试覆盖率，界面简单易用，适用于大多数浏览器，支持移动设备和触摸屏遵循 WAI-ARIA 指南以支持辅助技术的用户，压缩后仅 2,8 KB（比 react-color 轻小13 倍）。react-colorful 是一个简单的颜色选择器，适合那些关心包大小和客户端性能的人。。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02cf4954fae50d49760155d91048a5cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c15fa7ba4ec3af9887a2a1b624ad4dbf/" rel="bookmark">
			opencv车道偏离系统-代码&#43;原理-人工智能-自动驾驶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		车道偏离预警系统（Lane Departure Warning System, LDWS）是一种主动安全技术，旨在帮助驾驶员避免因无意中偏离车道而引发的事故。从原理到实战应用，其工作流程大致如下：
传感器采集
：系统通常配备有一个或多个摄像头，安装在车辆的前挡风玻璃上方、侧边或后视镜内，用于持续捕捉前方道路的图像。某些系统可能还会结合雷达或超声波传感器以增强准确性。
图像处理与分析：摄像头捕捉到的图像通过图像处理算法进行分析，这些算法能够识别出车道标记线（如白线、黄线）。算法会计算车辆相对于车道的位置，确定车辆是否保持在车道内。
状态监测：系统同时监测车辆的行驶状态（如速度、方向角度）和驾驶员的操作行为（如是否开启了转向灯），以判断车道偏离是否为驾驶员的有意操作。
预警触发：当系统判断车辆无意识地偏离车道（即没有打转向灯且车辆靠近或越过车道线），控制器会在极短时间内（通常是0.5秒内）激活预警机制，向驾驶员发出警告。警告方式通常包括声音警报、方向盘震动或仪表盘上的视觉警告。
实战应用 日常驾驶：在高速公路或城市快速路上，当驾驶员因疲劳、分心等原因未注意到车辆正在偏离车道时，LDWS能及时发出警告，提醒驾驶员采取措施回到车道中心，从而预防碰撞事故的发生。
恶劣天气适应性：虽然一些系统在雨雪天气或车道线不清晰的情况下性能可能会下降，但现代LDWS通过算法优化和传感器融合技术努力提高在复杂环境下的可靠性 。
与ADAS集成：在更高级的自动驾驶辅助系统（ADAS）中，LDWS不仅提供警告，还可以与车道保持辅助系统（LKA）等其他功能协同工作，自动轻微调整转向，帮助车辆保持在车道内。
算法步骤 步骤：
相机校准
收集一组使用相机拍摄的棋盘格图像。利用这组图像计算相机的校准矩阵和畸变系数。对原始图像应用畸变校正。 车道检测/追踪
使用颜色转换、梯度等方法，创建一个二值化（阈值化）图像。对二值化图像应用透视变换，以获得“鸟瞰图”效果。检测/追踪车道像素，并拟合以找到车道边界。 车道状态分析
确定车道的曲率。计算车辆相对于车道中心的位置。 车道增强
将检测到的车道边界重新映射回原始图像上。在图像上打印道路状态信息。
应用畸变校正 在此步骤中，使用了之前校准的结果，通过cv2.undistort函数实现（参见lane.py第580行）。校正畸变后的测试图像示例如下：（此处应有图片说明，但文字描述无法展示图像内容）
使用颜色和梯度过滤获取二值图像
我结合使用了颜色和梯度（阈值）来生成一个二值图像（参见lane.py中的find_edges函数，第187行）。首先，将图像转换到HLS色彩空间，并利用S通道进行过滤，这样做在不同光照条件下定位黄色和白色车道线更加稳定。接着，应用了沿着x方向的Sobel滤波器和梯度方向滤波器，以滤除大部分水平线。最后，为了处理发现多于两条候选车道的情况，我给S通道的过滤结果分配了两倍于梯度过滤的权重，这样黄色车道就比路缘的边缘更加明显。此步骤输出的一个示例如下：（此处应有图片说明，但文字描述无法展示图像内容）
使用透视变换实现鸟瞰视角查看图像
我的透视变换代码包含了一个名为warper()的函数（位于lane.py第214行）。首先，选择一张直线行驶时的图像，并选取4个源点，这些点沿两条车道线形成一个梯形。然后定义另外4个目标点，以便使用
代码 为了提供帮助，我将概述上述步骤中涉及的一些关键Python代码片段，基于OpenCV库进行实现。请注意，这些代码段是示意性的，您可能需要根据您的具体需求和环境调整它们。
1. 应用畸变校正 import cv2 import numpy as np # 假设 mtx 和 dist 是之前相机标定得到的内参矩阵和畸变系数 mtx = np.array(...) # 内参矩阵 dist = np.array(...) # 畸变系数 # 读取图片 img = cv2.imread('test_image.jpg') # 应用畸变校正 undistorted_img = cv2.undistort(img, mtx, dist, None, mtx) 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c15fa7ba4ec3af9887a2a1b624ad4dbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2a4f41c7cf4a0cb1e9dfd9377378385/" rel="bookmark">
			Flutter for Web：跨平台移动与Web开发的新篇章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flutter是Google推出的一款开源的UI工具包，用于构建高性能、高保真度的跨平台应用程序。Flutter最初专注于移动平台，但随着Flutter for Web的推出，它也扩展到了Web开发领域。本文将深入解析Flutter for Web的架构、核心概念、开发流程、性能优化以及与传统Web开发框架的比较。
2024年礼包：2500G计算机入门到高级架构师开发资料超级大礼包免费送！
Flutter for Web架构 Flutter for Web基于Flutter的核心框架，保留了其原有的Dart编程语言、Widget系统和声明式编程模型。它将Flutter的组件渲染引擎（Skia）转换为Web友好的格式，如HTML、CSS和SVG，同时利用Web平台的原生功能，如WebAssembly和WebGL，以实现高性能的Web应用。
1. 引擎层 Flutter for Web使用Skia图形库，通过WebAssembly在Web上运行。Skia经过优化，可以高效地绘制复杂的UI，确保了与原生Flutter应用相似的性能。
2. Dart to JavaScript编译 Flutter for Web将Dart代码编译为JavaScript，以便在Web浏览器中执行。这个过程包括两个主要步骤：AOT编译（Ahead-of-Time）和Tree Shaking。
AOT编译：将Dart代码转换为JavaScript字节码，提高加载速度。Tree Shaking：通过分析Dart代码，移除未使用的部分，减少最终输出的JavaScript文件大小。 3. Web组件 Flutter for Web将Flutter的Widget转换为Web组件，这些组件可以被浏览器理解和渲染。同时，它还支持与原生Web API的交互，如事件处理和DOM操作。
开发流程 使用Flutter for Web开发Web应用的基本流程如下：
安装和设置：安装Flutter SDK，配置开发环境，包括Dart SDK和相关IDE插件。创建项目：使用flutter create命令创建一个新的Flutter项目，选择Web目标。编写代码：使用Dart和Flutter Widget构建UI，处理业务逻辑。运行和调试：使用flutter run -d web-server启动本地服务器，实时预览和调试应用。打包和部署：使用flutter build web生成生产准备的静态文件，部署到Web服务器。 性能优化 减少渲染开销：优化Widget层次结构，避免不必要的重绘和重建。代码压缩：使用flutter build命令时，启用–release标志进行代码压缩和优化。资源优化：优化图片和其他资源的大小和格式，减少网络传输成本。延迟加载：对于大组件或资源，可以考虑使用懒加载技术，只在需要时加载。 与传统Web框架比较 开发效率：Flutter for Web的声明式编程和丰富的Widget库可以提高开发速度，尤其是对于已有Flutter经验的开发者。性能：得益于Skia和WebAssembly，Flutter for Web在某些场景下可能比传统Web框架（如React、Vue）更快，特别是在动画和复杂UI渲染方面。兼容性：Flutter for Web的兼容性不如原生Web框架，有些浏览器特性可能不完全支持。生态系统：Flutter for Web的库和插件数量较少，但随着社区的发展，这一情况正在改善。学习曲线：对于已熟悉Dart和Flutter的开发者，Flutter for Web的学习曲线较低。对于没有Flutter背景的开发者，可能需要花费时间学习新的框架和语言。 示例代码解析
import 'package:flutter/material.dart'; void main() { runApp(MyApp()); } class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return MaterialApp( title: 'Flutter Web Demo', theme: ThemeData( primarySwatch: Colors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2a4f41c7cf4a0cb1e9dfd9377378385/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2043db5eabe9214a723b9c782734d395/" rel="bookmark">
			AI 入门：AI 提示词如何入门？这篇就够了！（含提示词）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看案例，一目了然
一个通用的提示词案例： 普通的提示词：
我给你我写的参考文章，请你学习我的风格来根据主题创作1篇文章。 请你根据我给你的参考文章，学习我的写作风格，并进行风格学习模仿创作。为了更好的帮你更好的理解，我总结了我的写作风格。如下： 1.语言通俗易懂,词语朴实无华,避免使用专业术语,文章需要显得专业但又贴近生活，以平实的口语化语言创作文章,令读者易于理解。 2.以用户痛点开始，写作开篇方法，引入对应的商品主题，直击用户痛点。 3.提高文章亲和力,让读者容易感同身受。 4.结构清晰,每篇文章结构合理,层层推进,容易阅读理解。 5.语气温和理性,在问题时保持客观平和的语气,避免情绪化。 6.文章结构：分析参考文章的写作风格和写作特色和写作大纲结构，进行模仿创作。 7.字数要求2500字以上 额外要求： 文体：干货文章。 结构：开头直击用户痛点，引入话题。 段落：金字塔结构 用词：规范，拒绝生僻字 句子：长句要结构完整，短句要简洁有力，少用长句，多用短句。 修辞：合理应用类似，比喻，夸张，不要用排比句。把一些复杂的概念或者事物，换一种方式表达清楚。 排版：优化排版，使文章结构一目了然，重点内容或观点可以加粗，方便读者快速获取信息。采用小段落，避免段落文字太多造成阅读压力。 创作：创作时候根据你学习到的写作风格进行文章创作。 写作主题是：{title} 参考文章如下：{content} 一个结构化的提示词案例： 按照特定的结构，写好提示词，AI更便于理解我们的要求。
# Role: 知乎文案专家 ## Profile: - author: 大全Prompter - version: 1.0 - language: 中文 - description: 作为一名资深的知乎文案专家，专长于创作引人入胜且专业的内容，特别是在人工智能领域。 ## Background: 你被邀请帮助运营一个专注于人工智能ChatGPT的知乎账号。你的任务是撰写一篇关于指定主题的高质量文章，这篇文章需要符合知乎用户的喜好和阅读习惯。 ## Goals: 1. 撰写一篇关于指定主题的知乎文章。 2. 确保文章长度约为1600字。 3. 采用口语化而专业的风格。 4. 提供严谨的解决方案，同时保证用词优美且表达简练。 5. 结合实例或案例来丰富内容。 6. 确保文章既有深度又具有吸引力。 ## Constraints: 1. 文章内容需贴合知乎用户的阅读习惯和偏好。 2. 语言风格需要适合知乎平台的文化和风格。 3. 确保信息准确无误，避免误导读者。 4. 文章应融入恰当的梗，以增加趣味性和易读性，并且要求口语化输出。 ## Skills: 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2043db5eabe9214a723b9c782734d395/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a146b2c25633c040174bd7505955e8d/" rel="bookmark">
			Linux文件管理（超详细讲解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux文件管理 一、管理文件1.目录和路径2.目录操作命令3.文件操作命令4.文件内容操作命令 一、管理文件 1.目录和路径 文件与目录简介
文件是Linux操作系统用来存储信息的基本结构，是一组信息的集合。目录是一种特殊的文件，用来保存文件及其相关信息。所有的文件都会保存到目录中。
工作目录与用户主目录
（1）工作目录是用户当前所在的目录，他是可以随时改变的。
（2）用户主目录是用户登录成功后进入的默认目录，一般在“/home/用户名”目录下。
路径
通过“/”结合在一起的一个或多个目录及文件名的集合称为路径，路径又分为绝对路径和相对路径。绝对路径是指从根目录（/）开始的路径，如“/usr/local”。相对路径是相对于用户工作目录的路径，如“…/local”。
Linux操作系统中的特殊目录
特殊目录含义.工作目录. .工作目录的上一级目录，也就是父目录~用户主目录 2.目录操作命令 常用的目录操作包括创建目录（mkdir），删除空目录（rmdir）,切换工作目录（cd）,
查看当前目录（pwd）,和列出目录内容（ls）等。
1.创建目录——mkdir命令
mkdir [-p] 目录名 “-p” 选项表示创建嵌套的多级目录树。如果不加“-p”选项，则只能在已经存在的目录下创建子目录。
创建目录
# 在当前目录下创建子目录“book” [root@localhost ~]# mkdir book # 在“package” 目录下创建子目录“mysql” 。如果“package” 目录不存在，则同时创建该目录 [root@localhost ~]# mkdir -p package/mysql 删除空目录——rmdir命令
rmdir [-p] 目录名 “-p”选项表示递归删除空目录。如果子目录删除后其父目录为空，则同时删除父目录。
删除空目录
# 在当前目录下删除 “package” 目录，由于 “package” 目录不存在 "mysql" 目录， 所以无法将其删除 [root@localhost ~]# rmdir package rmdir:删除 'package' 失败：目录非空 # 在当前目录下删除 “package/mysql” 目录，执行命令后，子目录“mysql” 和父目录“package” 同时被删除 [root@localhost ~]# rmdir -p package/mysql 切换工作目录——cd命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a146b2c25633c040174bd7505955e8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/148b284d1509fa40819a466eafac9ba6/" rel="bookmark">
			Spark期末汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
第二章 Scala基础
一.scala的特性
二.定义与使用数组
第三章 Spark编程基础
RDD简介
1. parallelize()
2. makeRDD()
3.使用 union()方法合并多个 RDD
4.使用 filter()方法进行过滤
5.使用 distinct()方法进行去重
6.使用map()方法转换数据
7.使用 sortBy)方法进行排序
8.使用 collect()方法查询数据
9.使用 flatMap)方法转换数据
第四章 Spark编程进阶
在集群环境中运行 Spark
spark-submit常用项配置
第五章 Spark SQL——结构化数据文件处理
一.DataFrame简介
二.DataFrame的创建
1.数据准备
2.RDD直接转换为DataFrame
3.DataFrame的常用操作
第二章 Scala基础 一.scala的特性 (1)面向对象
Seala是一种纯释的面向对象语言。一个对象的类型和行为是由类和特征描迷的。类通过子类化和灵活的混合类进行扩展，成为多重继承的可靠解快方案。
(2)函数式编程
Scala 提供了轻量级语法来定义匿名函数，支持高阶函数，允许函数嵌套，并支持函数柯里化。Scala 的样例类与模式匹配支持两数式编程语言中的代数类型。Scala 的单例对象提供了方便的方法来组合不属于类的函数。用户还可以使用 Seala 的模式匹配，编写类似正则表达式的代码处理可扩展标记语言(Extensible Markup Language, XML)格式的数据。
(3)静态类型
Scala 配备了表现型的系统，以静态的方式进行抽象，以安全和连贯的方式进行使用。
系统支持将通用类、内部类、抽象类和复合类作为对象成员，也支持隐式参数、转换和多态方法等，这为抽象编程的安全重用和软件类型的安全扩展提供了强大的支持。
(4)可扩展
在实践中，专用领域的应用程序开发往往需要特定的语言扩展。Scala 提供了许多独特
的语言机制，可以以库的形式无缝添加新的语言结构。
二.定义与使用数组 方式一
方式二
操作数组
# 查看数组z的长度
z.length
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/148b284d1509fa40819a466eafac9ba6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/953592e49fda4a693158abb88e541ece/" rel="bookmark">
			MacOS BurpSuite安装指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		觉得麻烦或自己操作不懂，请购买BurpSuite Pro正版，双击即可使用，一年仅需449USDSubscribe to Burp Suite Professional - PortSwigger
# burpsuite破解 用户家目录中创建文件夹burp 两个文件：
burp最新版jar包 burpsuite_pro_v2024.3.1.4.jar
在哪下载？
官网：Professional / Community 2024.3.1.4 | Releases
百度云盘：链接: 百度网盘 请输入提取码 提取码: sgsk
burp注册机 BurpLoaderKeygen.jar
在哪下载？
百度云盘：链接: 百度网盘 请输入提取码 提取码: z3fx
burp最新版仅支持java22版本，首先切换java版本，然后运行注册机
java安装：蚁景网安学院-一个开放的网络安全交流学习论坛
sdk use java 22 java -version cd ~/burp java -jar BurpLoaderKeygen.jar 打开注册机后，点击 Run 按钮 首次运行会弹出此弹窗，如果你不想看到他，请勾选 Don't show again for this JRE 以后就不会再出现了 密钥激活步骤1: 如下图所示，复制注册机 License 内容粘贴到burp的输入框中，点击 Next 密钥激活步骤2: 如下图所示，点击 Manual activation 密钥激活步骤3: 如下入所示，点击burp Copy request 按钮，在注册机Activation Request位置粘贴，注册机Activation Response位置会自动出现新的密钥 密钥激活步骤4: 复制注册机Activation Response内容，然后点击burp Paste response粘贴，最后点击Next 恭喜你，完成burp的破解 第一次打开Burp，会出现 Delete old temporary files?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/953592e49fda4a693158abb88e541ece/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/365/">«</a>
	<span class="pagination__item pagination__item--current">366/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/367/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>