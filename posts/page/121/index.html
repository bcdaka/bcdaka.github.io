<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c38a3899536c3319a9c4420cbca098c/" rel="bookmark">
			第三十五篇-各大模型测评地址和说明集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Open LLM Leaderboard - 开放式LLM排行榜 测评地址：https://huggingface.co/spaces/open-llm-leaderboard/open_llm_leaderboard
说明：使用Eleuther AI的语言模型评估工具，针对六个核心任务进行基准测试，包括AI2推理挑战、HellaSwag、MMLU等。
2.MTEB Leaderboard - 海量文本嵌入基准排行榜 测评地址：https://huggingface.co/spaces/mteb/leaderboard
说明：覆盖八大核心嵌入任务，横跨58个数据集及112种语言，对33种不同模型进行基准测试。
3.Big Code Models Leaderboard - 大型代码模型排行榜 测评地址：https://huggingface.co/spaces/bigcode/bigcode-models-leaderboard
说明：专注于多语言代码生成模型，特别是在HumanEval与MultiPL-E基准测试上的性能对比。
4.SEAL Leaderboards - SEAL排行榜 测评地址：https://scale.com/leaderboard
说明：采用Elo等级分制度来比较不同数据集上模型的表现，使用Bradley-Terry模型进行统计分析。
5.Berkeley Function-Calling Leaderboard - 伯克利大模型函数调用排行榜 测评地址：https://gorilla.cs.berkeley.edu/leaderboard
说明：评估大型语言模型在调用函数和实用工具方面的能力，涵盖2,000对问答对。
6.Occiglot Euro LLM 排行榜 - Occiglot Euro LLM排行榜 测评地址：https://huggingface.co/spaces/occiglot/euro-llm-leaderboard
说明：是Open LLM排行榜的补充，特别增添了翻译任务的评估维度。
7.LMSYS Chatbot Arena Leaderboard - LMSYS聊天机器人竞技场排行榜 测评地址：https://chat.lmsys.org/?leaderboard=
说明：众包平台，用于评测大型语言模型在对话交互中的表现，通过超过一百万次的人工配对比较。
8.Artificial Analysis LLM Performance Leaderboard - 人工分析LLM性能排行榜 测评地址：https://huggingface.co/spaces/ArtificialAnalysis/LLM-Performance-Leaderboard
说明：在无服务器API端点上对大型语言模型实施基准测试，综合评价性能与质量。
9.Open Medical LLM Leaderboard - 开放医学模型排行榜 测评地址：https://huggingface.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c38a3899536c3319a9c4420cbca098c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/437c61061b1a7f191a76996f0719d941/" rel="bookmark">
			CSP-J复赛模拟赛2————赵义弘补题报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.题目目录 T1简单的问题T2寻找“五维空间”T3约定T4遗忘的过去 二.模拟赛题目期望得分 T1：100
T2: 60
T3: 60
T4: 80
因为蒟蒻自己没有参加这场模拟赛，所以就只有期望得分了 三.比赛分析 T1:[简单的问题(problem)] 题目大意：给你一个分段函数求它的一些对应的函数值 思考过程：读了一遍题以后发现这道题的数据范围 对于30%的数据，𝑥≥101
另外40%的数据，𝑥≤10
对于100%的数据，𝑥≤1000000 如果你想要AC一定要将cin和cout改成scanf和printf 同时蒟蒻我看了一下上面的题目描述和输入和输出样例，发现：如果x是小于等于100时，那么输出的答案一定是91。如果x是大于等于101时输出的答案一定是x-10 代码实现(由于蒟蒻我的辟谷报废了,所以蒟蒻我是现写的代码,写的可能不大好) #include&lt;bits/stdc++.h&gt; using namespace std; int main(){ int x; while(~scanf("%d",&amp;x)&amp;&amp;x!=0){ if(x&gt;=101) printf("%d\n",x-10); else printf("91\n",91); } return 0; } 我觉得是T1题因该不会有人AC不了吧
T2:[寻找“五维空间”(space)] 题目大意：帮助两个帅哥(小A和小C)找到要求的最简真分数。 思考过程：在看到这个样例的蒟蒻我都蒙了，这啥呀 仔细一看后我发现199/299约等于三分之二，也就是输入样例的第一行，至于输入样例的第二行则是输出样例的两个数所在的区间范围，那了解样例后的蒟蒻我就是无敌的。(后面会打脸)
代码实现： 自信的蒟蒻提交了代码
自信的蒟蒻寄了(只有60分)
毕竟失败乃成功他娘，错误代码也是要放出来的
#include&lt;bits/stdc++.h&gt; using namespace std; int x,y; int n,d,m; int ans=1.0*100000000000; int X,Y; int inf; int gcd(int x,int y){ if(y==0) return x; gcd(y,x%y); } bool check(int x,int y){ if(x==n&amp;&amp;y==d) return 0; if(gcd(x,y)!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/437c61061b1a7f191a76996f0719d941/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/640c31932bcf8ac933ba92f174399b2e/" rel="bookmark">
			Sentinel限流规则详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一期教程讲解了 Sentinel 的快速入门：Sentinel快速入门，这一期主要讲述 Sentinel 的限流规则
簇点链路 簇点链路就是项目内的调用链路（Controller -&gt; Service -&gt; Mapper），链路中被监控的每个接口就是一个资源。默认情况下 Sentinel 会监控 SpringMVC 的每一个端点（Endpoint），因此 SpringMVC 的每一个端点（Endpoint）就是调用链路中的一个资源（这里指的就是 Controller 中的方法）
流控、熔断等都是针对簇点链路中的资源来设置的，因此我们可以点击对应资源后面的按钮来设置规则：
点击后面的流控按钮，就可以弹出表单。表单中可以添加流控规则，如下图所示：
然后，我们在单击阈值的框中填写数字 1 并点击新增按钮，表示限制 /service1/hello 这个资源的单击 QPS 为1，即每秒只允许1次请求，超出的请求会被拦截并报错
之后在浏览器快速刷新对应的页面，结果如下所示，表示限流规则已经生效
流控模式 在添加限流规则时，点击高级选项，可以选择三种流控模式：
三种模式对应的含义是：
1.直接
统计当前资源的请求，触发阈值时对当前资源直接限流，是默认的模式
2.关联
统计与当前资源相关的另一个资源，当另一个资源触发阈值时，对当前资源限流
使用场景：用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁，产生竞争。业务需求是优先支付和更新订单的业务，因此当修改订单业务触发阈值时，需要对查询订单业务限流
例如，对于下图来说，当 /write 资源访问量触发阈值时，就会对 /read 资源限流，避免影响 /write 资源
一般来说，满足下面条件就可以使用关联模式：
① 两个有竞争关系的资源
② 一个优先级较高，一个优先级较低
3.链路
统计从指定链路访问到本资源的请求，触发阈值时，对指定链路限流
例如，有两条请求链路：
① /link1 -&gt; /common
② /link2 -&gt; /common
如果只希望统计从 /link2 进入到 /common 的请求，就可以设置链路模式的流控规则
实现步骤：
1.在服务层中填写共同调用的方法
@Service public class WebServiceImpl implements WebService { @Override @SentinelResource("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/640c31932bcf8ac933ba92f174399b2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6efd382f728ae804f3a878ae8a23b653/" rel="bookmark">
			vue3&#43;vite纯前端实现自动触发浏览器刷新更新版本内容，并在打包时生成版本号文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在前端项目中，有时候为了实现自动触发浏览器刷新并更新版本内容，可以采取一系列巧妙的措施。我的项目中是需要在打包时候生成一个version.js文件，用当前打包时间作为版本的唯一标识，然后打包发版 ，从实现对版本更新的监控。
因为项目使用 vite 打包的，vite又是基于rollup打包，rollup不像webpack有contentHash可以实现增量构建；而是每次打包，所有文件的hash都会更新，这样就会导致浏览器缓存的资源失效。
当用户已经打开页面，此时前端重新部署代码发版，会导致index.html未更新，而项目静态资源已经替换。当用户切换路由时，因为按需加载的原因，会继续访问旧的资源。
项目是基于 vue 3.4.21 + vite 4.3.9 + typescript 5.1.3 + node 16.1.0 开发的。
解决思路 注入版本信息：通过vite构建打包时，注入一个版本信息的version.js 文件，文件内容是一个版本号（这里用时间戳代替）。定义监控版本函数并执行：定义一个函数并调用执行，该函数内容为生产环境下，从本地缓存中获取版本号，如果没有版本号或者和缓存中的版本号不一致，表示版本已更新。就刷新页面，然后本地存储新的版本号以便下次使用。在合适的时机（路由载入前），判断是否已经有 version.js 文件，如果有，先删除掉，再重新创建一个&lt;script&gt; 标签并赋值，值为最新版本号（时间戳）。 了解fs模块 开始之前先了解下fs模块吧，本文会使用到。
fs 通常是指 Node.js 中的 fs 模块，它是文件系统模块（File System
module）的简写。 这个模块允许你与文件系统进行交互，包括读取、写入、修改、删除文件等操作 。在 Node.js 中，fs模块是内置的核心模块之一，因此 无需额外安装即可使用。fs 模块提供了丰富的 API 来处理文件和目录，包括同步和异步的操作方式。在使用 fs 模块时，需要特别注意错误处理，因为文件操作可能会涉及到磁盘访问和系统资源，因此 处理错误非常重要。 其中的 fs.writeFile() 方法用于异步地将数据写入文件。其基本语法如下：
fs.writeFile(file, data, options, callback) 参数说明：
file（必需）：表示要写入的文件的路径（包括文件名）。
data（必需）：表示要写入文件的数据，可以是字符串或者 Buffer 对象。
options（可选）：一个对象，包含指定如何写入文件的选项。常用选项包括：encoding：指定文件的编码，默认为 ‘utf8’。 mode：指定文件的权限，默认为 0o666（可读写）。 flag：指定文件的打开行为，默认为 ‘w’（覆盖写入）。
callback（可选）：写入操作完成后的回调函数，通常以 (err)形式接收一个可能的错误参数。如果未提供回调函数，则返回一个 Promise。
使用解释：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6efd382f728ae804f3a878ae8a23b653/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/beb415ffd4d8f9eee5f49add224b5b8b/" rel="bookmark">
			ES中聚合查询之date_histogram查询出现key_as_string 和 key含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ES中聚合查询之date_histogram查询出现key_as_string 和 key含义 DSL语句 #实例 GET /capture_features_202407/_search { "query": { "bool": { "must": [ { "terms": { "plateNo": [ "汉A00001" ] } }, { "range": { "absTime": { "gte": "2024-07-17 00:00:00", "lt": "2024-07-23 09:38:17", "time_zone": "Asia/Shanghai", "format": "yyyy-MM-dd HH:mm:ss" } } } ] } }, "aggs": { "date_histogram": { "date_histogram": { "field": "absTime", "format": "yyyy-MM-dd HH", "interval": "1h", "time_zone": "Asia/Shanghai", "order": { "_key": "asc" }, "keyed": false, "min_doc_count": 0 } } } } 返回结果 当dateHistogram聚合查询返回的结果里面 为什么会有 key_as_string,key,其中key的形式返回的是 1721282400000 怎么去理解？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/beb415ffd4d8f9eee5f49add224b5b8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/889543f53415327b7e0c7f8e4ec61a7f/" rel="bookmark">
			【es】elasticsearch 自定义排序-按关键字位置排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 背景
要求es查询的结果按关键字位置排序，位置越靠前优先级越高。
es版本7.14.0，项目是thrift，也可以平替springboot，使用easyes连接es。
二 easyes使用
配easyes按官方文档就差不多了
排序 | Easy-Es
主要的一个问题是easyes有与mybatis相同的一套mapper，如果项目也用了mybatis，那需要将mybatis、easyes的mapper分成两个目录
见：避坑指南 | Easy-Es
还有实体类的主键，按ee官方推荐是留个没注解的id自动生成id，而不是指定自己生成的主键，因为会影响数据储存的分区，导致查询效率降低
具体查询：（config、mapper、实体类略）
// 查询构造 LambdaEsQueryWrapper&lt;EsSearchDocument&gt; listWrapper = new LambdaEsQueryWrapper&lt;&gt;(); // 查询条件（相等） listWrapper.eq(EsSearchDocument::getType, searchType); // 查询条件（模糊），与上条是and关系 listWrapper.like(EsSearchDocument::getTitle, searchContent); // 分页偏移量计算 int offset = ((pageNum != null ? Integer.parseInt(pageNum) : 1) - 1) * size; //查询总条数 Long count = esMapper.selectCount(listWrapper); // 设置分页 listWrapper.limit(offset, size); // 分页 // 查询结果列表 List&lt;EsSearchDocument&gt; esList = esMapper.selectList(listWrapper); //打印 System.out.println("count="+count); System.out.println(JSON.toJSONString(esList)); 三 自定义排序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/889543f53415327b7e0c7f8e4ec61a7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d915762e8f8e68a6be94339d9a535ed/" rel="bookmark">
			100个python的基本语法知识【下】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		50. 压缩文件：
import zipfile with zipfile.ZipFile("file.zip", "r") as zip_ref: zip_ref.extractall("extracted") 51. 数据库操作：
import sqlite3 conn = sqlite3.connect("my_database.db") cursor = conn.cursor() cursor.execute("CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT)") conn.commit() conn.close() 52. 网络请求：
import requests response = requests.get("https://www.example.com") 53. 多线程：
import threading def my_thread(): print("Thread running") thread = threading.Thread(target=my_thread) thread.start() thread.join() 54. 多进程：
import multiprocessing def my_process(): print("Process running") process = multiprocessing.Process(target=my_process) process.start() process.join() 55. 进程池：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d915762e8f8e68a6be94339d9a535ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/146f2133d1f41c8d672f0a2edc67444d/" rel="bookmark">
			100个python的基本语法知识【上】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0. 变量和赋值：
x = 5
name = “John”
1. 数据类型：
整数（int）
浮点数（float）
字符串（str）
布尔值（bool）
2. 注释：
# 这是单行注释 """ 这是 多行注释 """ 3. 算术运算：
a + b # 加法 a - b # 减法 a * b # 乘法 a / b # 除法 a % b # 取余 a ** b # 幂运算 4. 比较运算：
a == b # 等于 a != b # 不等于 a &gt; b # 大于 a &lt; b # 小于 a &gt;= b # 大于等于 a &lt;= b # 小于等于 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/146f2133d1f41c8d672f0a2edc67444d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dfd96465c3e3cc29bdf4fd5f591cc5c/" rel="bookmark">
			MAT使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念 Shallow heap &amp; Retained Heap Shallow Heap就是对象本身占用内存的大小。
Retained Heap就是当前对象被GC后，从Heap上总共能释放掉的内存(表示如果一个对象被释放掉，那会因为该对象的释放而减少引用进而被释放的所有的对象（包括被递归释放的）所占用的heap大小)。
具体可以参考：官方文档
Incoming References &amp; Outgoing References Incoming References ：表示该对象的入节点（引用到该对象的对象）
Outgoing References：表示该对象的出节点（被该对象引用的对象）
举个例子，对象 A 持有对象 B 的引用，对象 B 持有对象 C 的引用；
对象 B 的“Incoming references”是对象 A、B 的类对象
对象 B 的“outgoing references”是对象 C、 B 的类对象
视图 Histogram 列出内存中的对象，对象的个数以及大小。支持正则表达式查找，也可以计算出该类所有对象的retained size
Dominator Tree 列出最大的对象以及其依赖存活的Object （大小是以Retained Heap为标准排序的）。
Dominator Tree和Histogram的区别是站的角度不一样，Histogram是站在类的角度上去看，Dominator Tree是站在对象实例的角度上看，Dominator Tree可以更方便的看出其引用关系。
Unreachable Unreachable指的是不可达对象。
Group 在Histogram和Domiantor Tree界面，可以选择将结果用另一种Group的方式显示（默认是Group by Object），切换到Group by package，可以更好地查看具体是哪个包里的类占用内存大，也很容易定位到自己的应用程序。
Path to GC Roots 查看一个对象到RC Roots的引用链。通常在排查内存泄漏的时候，我们会选择exclude all phantom/weak/soft etc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dfd96465c3e3cc29bdf4fd5f591cc5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/569ff50cbb3200361464581bae9a7d87/" rel="bookmark">
			Java 集合框架：TreeMap 的介绍、使用、原理与源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是栗筝i，这篇文章是我的 “栗筝i 的 Java 技术栈” 专栏的第 021 篇文章，在 “栗筝i 的 Java 技术栈” 这个专栏中我会持续为大家更新 Java 技术相关全套技术栈内容。专栏的主要目标是已经有一定 Java 开发经验，并希望进一步完善自己对整个 Java 技术体系来充实自己的技术栈的同学。与此同时，本专栏的所有文章，也都会准备充足的代码示例和完善的知识点梳理，因此也十分适合零基础的小白和要准备工作面试的同学学习。当然，我也会在必要的时候进行相关技术深度的技术解读，相信即使是拥有多年 Java 开发经验的从业者和大佬们也会有所收获并找到乐趣。
–
在 Java 的集合框架中，TreeMap 是一种重要的数据结构，它基于红黑树实现，提供了有序的键值对存储方式。与 HashMap 不同，TreeMap 保证了元素的顺序性，使得我们可以在集合中按自然顺序或自定义顺序进行排序和查找。这使得 TreeMap 在需要排序的数据操作中表现出色，尤其适合处理有序的数据集合和范围查询。
TreeMap 的实现原理涉及红黑树，一种自平衡的二叉搜索树。这种树结构能够在 O(log n) 时间复杂度内完成插入、删除和查找操作。与之相比，HashMap 的操作虽然平均时间复杂度为 O(1)，但不保持元素的顺序。因此，TreeMap 在需要保持键顺序的场景中显得尤为重要。
本文将深入探讨 TreeMap 的使用方法、内部原理及其源码实现。我们将从基本概念和常见操作入手，逐步分析 TreeMap 的实现细节。通过对源码的解析，您将能够深入理解 TreeMap 的工作机制，从而在实际编程中更好地利用这一强大的数据结构。无论您是 Java 初学者还是有经验的开发者，都能通过本篇文章获得对 TreeMap 更加深入的认识和实践经验。
文章目录 1、TreeMap 概述1.1、TreeMap 介绍1.2、红黑树回顾 2、TreeMap 底层实现2.1、TreeMap 底层结构2.2、添加元素2.3、删除元素2.4、查询元素 3、TreeMap 相关知识点3.1、`HashMap` 和 `TreeMap` 的实现3.2、`HashMap` 和 `TreeMap` 的线程安全性3.3、`SortedMap` 接口3.4、自定义比较器实现降序排序 1、TreeMap 概述 1.1、TreeMap 介绍 Map 在 Java 里面分为两种：HashMap 和 TreeMap，区别就是 TreeMap 有序，HashMap 无序。如果只需要存映射，那么 HashMap 就够了，但是如果需要存有顺序的 key 那么就用 TreeMap。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/569ff50cbb3200361464581bae9a7d87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f72e28063c30c7468fb6af4653f4f9c/" rel="bookmark">
			Tomcat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tomcat 1.JVM是啥2.Tomcattomcat启动慢解决方案 3.tomcat目录结构介绍binconfliblogswebappsworktempRELEASE-NOTESRUNNING.txt 4.tomcat主配置文件5.tomcat部署java项目示例：zrlog6.配置tomcat basic认证7.Nginx+Tomcat集群架构8.tomcat+nfs实现文件共享安装配置nfs服务端客户端配置nfs 9.nginx做静态资源缓存缓存服务器配置参数介绍缓存结果验证 10.Nginx+Tomcat实现Https11.使用maven编译java程序maven安装配置编译java程序配置tomcat站点 12.使用redisson实现session共享方法一：ip_hash 做会话保持方法二：使用redisson实现session共享redis部署配置redisson1.添加会话管理器2.将下载好的jar包放到指定目录重启tomcat 13.使用JConsole 监控jvm在被监控的tomcat服务器上开启监控接口使用JConsole 监控环境变量配置启动jconsole.exe 14.Tomcat性能优化15.JVM内存分代年轻代年轻代垃圾回收算法（复制算法）老年代老年代垃圾回收算法 （标记清除算法）永久代垃圾回收何时进行系统崩溃前的一些现象：dump文件Tomcat内存调整(JVM内存调整)年轻代和老年代设置多大才合理调优方法 1.JVM是啥 JVM是Java Virtual Machine（Java虚拟机）的缩写
是运行Java程序的抽象计算机，是Java语言的运行环境，Java虚拟机本质是就是一个程序，当它在命令行上启动的时候，就开始执行保存在某字节码文件中的指令。Java语言的可移植性正是建立在Java虚拟机的基础上。任何平台只要装有针对于该平台的Java虚拟机，字节码文件（.class）就可以在该平台上运行。实现“一次编译，多次运行”。
jvm java虚拟机
jre java运行环境
jdk java开发工具包
jdk包含jre，jre包含jvm虚拟机
常用的是jdk8
jdk下载地址：https://www.oracle.com/java/technologies/downloads/?er=221886#java8
其他版本jdk下载地址：https://www.oracle.com/java/technologies/downloads/archive/
2.Tomcat Tomcat和 Nginx 类似，也是一个Web服务器。
tomcat是一个java编写的web服务器，需要java运行环境，运行java。
Nginx默认仅支持处理静态资源，而Tomcat则支持Java开发的 jsp 动态资源和静态资源。
Nginx适合做前端负载均衡，而Tomcat适合做后端应用服务处理。
通常情况下会将 Nginx+tomcat 结合使用，由Nginx处理静态资源，Tomcat处理动态资源。
tomcat下载地址：https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/
将下载好的jdk包传到服务器上
安装jdk
rpm -ivh jdk-8u411-linux-x64.rpm
安装启动tomcat
mkdir app -p tar xf apache-tomcat-9.0.90.tar.gz -C /app /app/apache-tomcat-9.0.90/bin/startup.sh 安装方法二：
#适合debian和ubuntu等其他linux发行版 tar xf jdk-8u60-linux-x64.tar.gz -C /app/ ln -s /app/jdk1.8.0_60 /app/jdk sed -i.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f72e28063c30c7468fb6af4653f4f9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55f5b86856d473fb895713586dee0915/" rel="bookmark">
			Java 集合框架：HashMap 的介绍、使用、原理与源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是栗筝i，这篇文章是我的 “栗筝i 的 Java 技术栈” 专栏的第 020 篇文章，在 “栗筝i 的 Java 技术栈” 这个专栏中我会持续为大家更新 Java 技术相关全套技术栈内容。专栏的主要目标是已经有一定 Java 开发经验，并希望进一步完善自己对整个 Java 技术体系来充实自己的技术栈的同学。与此同时，本专栏的所有文章，也都会准备充足的代码示例和完善的知识点梳理，因此也十分适合零基础的小白和要准备工作面试的同学学习。当然，我也会在必要的时候进行相关技术深度的技术解读，相信即使是拥有多年 Java 开发经验的从业者和大佬们也会有所收获并找到乐趣。
–
在 Java 编程中，集合框架提供了强大而灵活的数据存储和操作方式。作为 Java 集合框架中的重要一员，HashMap 是一种常用的键值对映射实现。它广泛应用于需要高效数据查找、插入和删除的场景中。理解 HashMap 的工作原理对于编写高效的 Java 程序至关重要。
HashMap 是一个基于哈希表的 Map 实现，它的设计目标是提供高效的键值对存储和操作。通过将键的哈希值映射到哈希表的索引位置，HashMap 能够以接近常数时间的复杂度完成 get 和 put 操作。然而，HashMap 的内部实现包含多个复杂的机制，如哈希函数、冲突解决、扩容策略等，这些都是确保其高效性能的关键因素。
本篇文章将深入探讨 HashMap 的各种方面，包括其基础介绍、常见用法、工作原理以及源码解析。我们将从 HashMap 的基本特性和构造函数入手，逐步揭示其内部数据结构和方法的实现细节。同时，我们也会分析其性能特点和可能的优化策略，以帮助读者更好地理解和使用 HashMap。
通过对 HashMap 的全面解读，希望读者能够深入掌握这一关键集合类的工作机制，从而在实际开发中做出更加合理的选择和优化。无论你是刚刚接触 Java 集合框架的新手，还是希望深入了解其实现细节的资深开发者，本篇文章都将为你提供有价值的参考和指导。
文章目录 @[toc]1、HashMap 概述2、HashMap 底层数据结构1.1、JAVA7 实现1.2、JAVA8 实现1.3、源码解读 3、HashMap 的扩容机制3.1、什么时候触发扩容？3.2、JDK7 中的扩容机制3.3、JDK8 的扩容机制3.4、JDK7 的元素迁移3.5、JDK8 的元素迁移3.6、源码解读3.6.1、`resize` 方法3.6.2、`transfer` 方法3.6.3、`indexFor` 方法3.6.4、`ensureCapacity` 方法3.6.5、`addEntry` 方法 4、HashMap 相关知识点4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55f5b86856d473fb895713586dee0915/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5716970ed92892c8933c63c9ecd46390/" rel="bookmark">
			解决kkfileview 使用https预览问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景：项目使用了开源的kkfileview进行文件在线预览，部署方式使用的是docker，使用IP进行访问，但是http协议直接访问有漏洞告警，现在需要调整为https，且仍然需要使用IP访问。
kkfileview官网kkFileView - 在线文件预览
问题：使用自签证书将web中间件访问方式调整为https，代理kkfile容器8012端口，后预览图片正常，预览其他类型文件提示如下错误
错误信息： 下载失败:org.springframework.web.client.ResourceAccessException: I/O error on GET request for "https://192.168.1.1:80/api/admin/image/local/c639a28c6e4b4278b8c93ff94352957a.txt": sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target; nested exception is javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
解决方法：
1.重新自包含签证书SAN(Subject Alternative Name)的证书
openssl genrsa -out server.key 2048 cat &gt;server.cnf&lt;&lt;EOF [req] default_bits = 2048 prompt = no default_md = sha256 distinguished_name = dn req_extensions = req_ext [dn] C = CN ST = Province L = City O = Organization OU = Organizational Unit CN = test [req_ext] subjectAltName = @alt_names [alt_names] # 如果需要，可以添加更多的DNS或IP地址 #DNS.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5716970ed92892c8933c63c9ecd46390/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ee9ff9a6719fe102fd05eb8f3742149/" rel="bookmark">
			剖析 Kafka 消息丢失的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、生产者导致消息丢失的场景场景1：消息体太大解决方案 ：1、减少生产者发送消息体体积2、调整参数`max.request.size` 场景2：异步发送机制解决方案 ：1、使用带回调函数的发送方法 场景3：网络问题和配置不当解决方案 ：1、设置`acks`参数设置为"all"2、设置重试参数3、设置 `min.insync.replicas`参数 二、Broker服务端导致消息丢失的场景场景1：Broker 宕机解决方案 ：1、增加副本数量 场景2：leader挂掉，follower未同步解决方案 ：1、leader竞选资格2、增加副本数量 场景3：持久化错误解决方案 ：1、调整刷盘参数2、增加副本数量 三、消费者导致消息丢失的场景场景1：提交偏移量后消息处理失败解决方案 ： 场景2：并发消费解决方案 ： 场景3：消息堆积解决方案 ： 场景4：消费者组rebalance解决方案 ：1、尽量提高客户端的消费速度2、调整参数避免不 必要的rebalance 依然会丢消息的场景场景 1：场景 2： 总结 前言 Kafka消息丢失的原因通常涉及多个方面，包括生产者、消费者和Kafka服务端（Broker）的配置和行为。下面将围绕这三个关键点，详细探讨Kafka消息丢失的常见原因，并提供相应的解决方案和最佳实践。具体分析如下：
一、生产者导致消息丢失的场景 场景1：消息体太大 消息大小超过Broker的message.max.bytes的值。此时Broker会直接返回错误。
解决方案 ： 1、减少生产者发送消息体体积 可以通过压缩消息体、去除不必要的字段等方式减小消息大小。
2、调整参数max.request.size max.request.size，表示生产者发送的单个消息的最大值，也可以指单个请求中所有消息的总和大小。默认值为1048576B，1MB。这个参数的值值必须小于Broker的message.max.bytes。
场景2：异步发送机制 Kafka生产者默认采用异步发送消息，如果未正确处理发送结果，可能导致消息丢失。
解决方案 ： 1、使用带回调函数的发送方法 不要使用 producer.send(msg)，而要使用 producer.send(msg, callback)。带有回调通知的 send 方法可以针对发送失败的消息进行重试处理。
场景3：网络问题和配置不当 ​ 生产者在发送消息时可能遇到网络抖动或完全中断，导致消息未能到达Broker。如果生产者的配置没有考虑这种情况，例如未设置恰当的重试机制（retries参数）和确认机制（acks参数），消息就可能在网络不稳定时丢失。
解决方案 ： 1、设置acks参数设置为"all" acks参数指定了必须要有多少个分区副本收到消息，生产者才认为该消息是写入成功的，这个参数对于消息是否丢失起着重要作用，该参数的配置具体如下：
all/-1 : 表示kafka isr列表中所有的副本同步数据成功，才返回消息给客户端0 ：表示客户端只管发送数据，不管服务端接收数据的任何情况1 ：表示客户端发送数据后，需要在服务端 leader 副本写入数据成功后，返回响应 使用同步发送方式或确保acks参数设置为"all"，以确保所有副本接收到消息。
2、设置重试参数 重试参数主要有retries和retry.backoff.ms两个参数。
（1）参数 retries是指生产者重试次数，该参数默认值为0。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ee9ff9a6719fe102fd05eb8f3742149/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b046afe39d078ac4ffd67e681e1a774/" rel="bookmark">
			【Linux】条件变量及生产者消费者模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要将这两者放在一起进行呢？
主要是因为生产消费与条件变量关系密切，正好相辅相成。
目录 条件变量：条件变量的引出：条件变量的解释与接口：测试代码： 生产者消费者模型：概念：代码实现Blocking Queue：完整代码：测试结果：一些问题： 条件变量： 条件变量的引出： 我们假设有一个自习室，这个自习室每次只能有一个人进入（使用挂在自习室门前钥匙），其他的人都要排队（排队之前都去试图找钥匙）。
今天小A起了个大早去拿钥匙，一直学到中午，此时饿得受不了了，于是想出去吃饭，他就走到门前打算归还钥匙，可是刚挂到门前就后悔了，因为她不想排队那么久才能继续学习，于是又拿着钥匙将门打开，但是又很饿，就这样循环往复，自己没有得到知识，外面的人也只能干排队等待。
与之对应：
自习室就相当于临界资源，钥匙就是锁，当其中一个线程拿到锁就可以访问临界资源，其他的线程都陷入阻塞状态。
由于线程A继续访问临界资源已经没有意义，但是竞争锁的能力很强，因为距离自己很近，造成了其他线程饥饿问题。
虽然线程A这样做合法，但是不道德。
我们此时需要制定规则，保证过程具有一定顺序性，也就是同步。
而条件变量就是确保这个顺序性的！
条件变量的解释与接口： 我们知道了条件变量的作用，但是还是并不清楚条件变量是什么。
我们再来一个例子进行解释。
假设有一个游戏，一个蒙眼拿盘子中的苹果，一个睁眼将苹果放入盘子。
现在我们就可以对应一下了。
铃铛就是条件变量，他是一个队列，可以让线程进行等待
他的唤醒有两种策略，全部唤醒与单个唤醒。
我们也就可以对应一下条件变量的接口了。
有些接口与锁很类似。
其中init是条件变量初始化的函数，与锁一致。
signal与broadcast就是通知接口，signal是一次通知一个，boardcast就是全部通知
wait就是去铃铛下等待，也就是去条件变量下等待。
timedwait我们不管。
desory就是销毁条件。
关于这里还有一个细节，为什么条件变量要把锁业传入？
后面会进行解释。
测试代码： 我们目前可以浅浅的使用一下条件变量，熟悉一下接口。
我们现在要实现一个场景，
主要逻辑是先创建一批线程并进行管理，每个创建好的线程都去执行各自的任务，任务是个死循环，每次进入在条件变量下等待被唤醒。
#include &lt;iostream&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; const int N = 5; pthread_mutex_t g_mutex = PTHREAD_MUTEX_INITIALIZER; pthread_cond_t g_cond = PTHREAD_COND_INITIALIZER; void *Run(void *args) { while (true) { pthread_mutex_lock(&amp;g_mutex); pthread_cond_wait(&amp;g_cond, &amp;g_mutex); std::cout &lt;&lt; "i am new thread-"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b046afe39d078ac4ffd67e681e1a774/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fab37cc8bd24243d393a1547add5ac8/" rel="bookmark">
			Coolmuster Android Assistant: 手机数据管理的全能助手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数字化时代，智能手机不仅是通讯工具，更是个人数据的中心。随着数据量的不断增加，如何有效管理和保护这些数据成为了一个重要议题。Coolmuster Android Assistant应运而生，它是一款专为安卓用户设计的综合数据管理软件，提供了一整套解决方案，帮助用户轻松管理手机中的各类数据。
Coolmuster Android Assistant以其强大的功能和用户友好的设计，简化了数据备份、恢复、传输和管理的过程。它支持广泛的Windows操作系统，从XP到最新的Windows 11，确保了广泛的适用性。软件界面直观，操作简便，即使是电脑初学者也能快速上手。
主要特点和功能 一键备份与恢复：用户可以轻松备份手机中的所有数据到电脑，并在需要时一键恢复，确保数据的完整性和质量。数据传输：软件支持在电脑和手机之间传输各类数据，包括联系人、短信、通话记录、音乐、视频和照片等。联系人管理：用户可以在电脑上对联系人进行添加、删除、去重和编辑等操作。短信管理：软件允许用户直接在电脑上发送和回复短信，提高了处理短信的效率。应用管理：用户可以从电脑上安装和卸载手机应用程序，简化了应用管理流程。通话记录管理：提供了通话记录的导入、导出、删除和刷新功能。Outlook集成：支持将联系人导出到Outlook并从Outlook导入，方便了使用Outlook管理联系人的用户。 优点和优势 广泛的系统兼容性：支持多个Windows操作系统版本，几乎涵盖了所有主流的Windows系统。低硬件要求：最低硬件配置要求低，适合大多数用户的电脑。简便的安装卸载：软件安装和卸载过程简单，用户可以轻松完成。清晰的注册流程：用户购买后通过电子邮件接收许可证代码，注册步骤明确，易于操作。
Coolmuster Android Assistant： 在计算机上管理 Android 数据Coolmuster Android Assistant 是一款专业的 Android 管理程序，供 Android 用户在 PC 上自由管理 Android 联系人、短信、媒体、应用程序等 Windows 。通过签到了解更多信息。https://www.coolmuster.cn/android-assistant.html 如何使用 下载与安装：
访问Coolmuster官网并找到Android Assistant的下载链接。 启动软件：
双击桌面上的Coolmuster Android Assistant快捷方式启动软件。软件启动后，将显示主界面，用户可以选择不同的模块进行操作。 连接设备：
使用数据线将安卓手机连接到电脑。在手机上选择允许电脑进行数据操作的选项。 数据管理：
备份数据：选择“备份”功能，选择需要备份的数据类型，然后点击“备份”按钮。恢复数据：选择“还原”功能，选择备份文件，然后点击“还原”按钮。传输数据：在主界面选择“传输”功能，选择需要传输的数据类型，然后进行数据传输。管理联系人：选择“联系人”模块，进行添加、删除、编辑等操作。发送和回复短信：选择“短信”模块，可以直接在电脑上发送和回复短信。管理应用程序：选择“应用”模块，进行应用程序的安装和卸载。管理通话记录：选择“通话记录”模块，进行通话记录的导入、导出、删除和刷新。 退出软件：
完成所有操作后，可以通过点击软件右上角的“X”按钮退出软件。 Coolmuster Android Assistant以其全面的管理功能和简便的操作流程，为用户提供了一个高效、可靠的手机数据管理解决方案。无论是备份重要数据、日常的数据传输，还是高效的联系人和短信管理，Coolmuster Android Assistant都能为用户提供满意的服务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f9b57c5734e39bef6235b4d449c7512/" rel="bookmark">
			uart开发调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Uart基本框架
1.1概念
通信系统有两种方式，同步通信和异步通信.
同步通信的典型特征：通信双方公用同一个时钟，发送/接受速率完全一致，通信时需要带时钟信号传输.
异步通信的典型特征：通信双方各自具有独立的时钟系统，通信时不需要时钟信号传输，发送/接收速率按照约定值进行通信，缺点是速率越高数据量越大可能会存在误差，因为双方独立的时钟系统在达到一定的高频率下双方的误差会体现出来.
1.2UART
串口(uart)是典型的异步通信.其中又分为串行通信和并行通信。
串行通信每次只能发送/接收1个bit位只用1根信号线传输数据，一般是TX一根线、RX一根线，因此数据按有序传输、占用引脚少、传输速度慢；
并行通信每次能传输多个bit位有多根传输线，RX多根线、TX多根线，因此传输速度快、占用引脚多。
一般情况下为了节省引脚数量都会采用串行通信，而串行通信中又分为单工、半双工、全双工。
单工：只允许数据在一个方向上传输；
半双工：允许数据在两个方向上传输，但发送和接收不能同时进行；
全双工；允许数据在两个方向上同时传输，发送和接收可以同时进行。
Uart中由于开发板和PC等外部不通载体之间通信，所以不会互相接上一根时钟线来做时钟同步，所以uart串口通信一般采用异步通信+串行通信+全双工模式.
1.3串口电路连接
1.4串口通讯协议
2.Uart基本寄存器介绍
3.串口编程基本思路
3.1查看硬件原理图弄清楚硬件接线
通过原理图可以看到UART0通过J2模块的2和8针接入到PA9和PA10，再查看寄存器手册PA9和PA10对应的GPIO组为GPIOA。
3.2GPIO
对GPIOA组中PA9和PA10对应bit位初始化。
3.2.1GPIO属性：
Memory-map地址：即GPIO挂在哪个总线上，所属总线上GPIO的地址范围，GPIO-A对应的地址偏移。这样才能访问到GPIO-A并进行设置.
该GPIO-A组对应的pin引脚：每个GPIO组为32位，高16位保留，其中低16位有效每个BIT位对应1个pin引脚;
GPIO的模式：输入模式、输出模式、复用输出模式，其中复选模式是某个GPIO可能对应多个功能，我们需要AF-ALERT1对应功能UART0-RX、AF-ALERT2对应功能SDIO-D2、其他8种复选功能。我们需要再PA9/10对应的GPIO设置成复用输出模式，然后复用输出寄存器设置成AF-ALERT1，这样该GPIO就对应成我们需要的UART0-RX/TX了。
GPIO的极性：即默认为1还是0.当GPIO模式为输出/复用输出时，需要设置推免/开漏模式，推免模式可以通过上拉电阻输出1或0，开漏模式只能输出0.一般都有上拉电阻，选择推免模式.
GPIO速率：寄存中不通的输出等级，对应不通速率，譬如50HZ\25HZ\2HZ，速率越高功耗越大.
GPIO组时钟：打开总线上下挂的GPIO组对应的时钟，enable相关寄存器.
3.2.2GPIO寄存器配置
根据上述GPIO属性以及初始化，相关联的GPIO寄存器 如下图：
4 中断处理
中断涉及到嵌套向量控制器NVIC、中断/异常向量表、中断优先级.
GD/STM32中负责传递中断到CPU的总中断控制器NVIC，各外设设备（UART\I2C\...）也存在一个自身的中断控制单元。总体框图如下：
当发生中断时，CPU处理过程如下图：
4.1 嵌套向量控制器NVIC
4.1.1中断管理
4.1.2中断和异常向量表
4.1.3中断优先级/嵌套中断
4.2外部中断
中断分为内部中断和外部中断，其中外部中断来自于外设产生的中断.外部中断也有一个外部中断控制器和总中断控制器NVIC相连,用于传递并处理外部中断.外部中断/事件框图如下：
上图中触发事件时采用脉冲信号，事件本质上是一个信号，譬如唤醒睡眠的电源模块等. 事件是中断的触发源，事件可以触发中断也可以不触发，开放了对应的中断屏蔽位，则事件可以触发相应的中断。 事件还是其它一些操作的触发源，比如DMA，还有TIM中影子寄存器的传递与更新等。简单点就是中断一定要有中断服务函数,但是事件却没有对应的函数。事件可以在不需要CPU干预的情况下,执行这些操作，但是中断则必须要CPU介入。
上升沿/下降沿选择寄存器：需要软件选择中断发生的检测方式，是采用电平信号上升沿还是下降沿变化来判断中断/事件的发生；
软件中断/事件寄存器：
挂起请求寄存器：当中断发生时，如果CPU在执行优先级更高的中断或该中断无法打断的任务，则该中断请求被暂时挂起。待之后CPU再来执行该挂起的中断；当事件发生时过程雷同，差别不是由CPU参与而是由脉冲发生器参与;该寄存器由硬件自动完成，不需要软件配置；
中断屏蔽寄存器：配置是否屏蔽该中断，他和“请求挂起寄存器”做&amp;操作，最后决定是否把中断发送给NVIC总控制器;
事件屏蔽寄存器：配置是否屏蔽该事件，他和“请求挂起寄存器”做&amp;操作，最后决定是否把事件发送给脉冲发生器。
4.2.1外部中断控制器EXTI
每个GPIO引脚存在在一个外部控制器中，需要在外部控制器中配置打开这些GPIO对应的引脚.框图如下：
4.2.2系统配置控制器SYSCFG
打开EXTI控制器中存在的某个GPIO引脚中断功能后（ENABLE），还要保证每个引脚（GPIO）对应的中断能够传递到总中断NVIC控制器，需要配置GPIO引脚所在EXTI控制器到NVIC控制器的连通性，这个配置寄存器就是SYSCFG寄存器,如下图
5.时钟配置
6.uart开发思路
弄清楚原理图----&gt;初始化GPIO（包括时钟配置和GPIO属性配置）-----&gt;初始化UART寄存器------&gt;配置中断相关寄存器------&gt;编写收发包中断函数并将对应中断号写入中断寄存器。
7.其他
7.1 PIN和GPIO的联系
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fad1be2389010b25c277e8df51b2619/" rel="bookmark">
			C语言100道基础拔高题（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.有1,2,3,4这几个数字，问能组成多少个互不相同且无重复数字的三位数？
解题思路：首先输出由这几个数字所组成的所有三位数，接着再设置条件，使其输出的三位数不重复，下面我们来看下源代码。值得注意的是：所以题目的代码都是作者自行编写，如有更好的思路或者代码的优化，还请指出更正。
#include &lt;stdio.h&gt; int main() { //有1,2,3,4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少 //思路：首先输出所有由1,2,3,4组成的三位数，接着设置条件，只有不重复的三位数才打印出来 //定义三个变量，分别表示百位，十位，个位 int bai; int shi; int ge; int count = 0; //外层循环表示百位上的数，里层循环分别表示十位，个位 for ( bai = 1; bai &lt; 5; bai++) { for ( shi = 1; shi &lt; 5; shi++) { for ( ge = 1; ge&lt; 5; ge++) { if (bai != shi &amp;&amp; bai != ge &amp;&amp; shi != ge) { printf("%d%d%d\n", bai, shi, ge); count++; } } } } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fad1be2389010b25c277e8df51b2619/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9deecfe79ac081808c1bd06277756134/" rel="bookmark">
			Java面试八股之后Spring、spring mvc和spring boot的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring、spring mvc和spring boot的区别 Spring, Spring Boot和Spring MVC都是Spring框架家族的一部分，它们各自有其特定的用途和优势。下面是它们之间的主要区别：
Spring:
Spring 是一个开源的轻量级Java开发框架，最初由Rod Johnson创建，旨在简化企业级应用的开发。Spring的核心特性是依赖注入（Dependency Injection, DI）和面向切面编程（Aspect Oriented Programming, AOP），这有助于实现组件之间的解耦和可测试性。
Spring 提供了模块化的支持，包括数据访问/集成、事务管理、模型-视图-控制器（MVC）Web应用、远程处理、测试和安全服务等。
Spring MVC:
Spring MVC 是Spring框架的一部分，专注于Web应用程序的开发，它实现了MVC设计模式，将业务逻辑、数据和展示层分开，使得Web应用的开发更加清晰和结构化。
Spring MVC 提供了处理HTTP请求和响应的机制，以及视图解析和表单处理等功能，它使用注解来简化配置和控制器类的定义。
Spring Boot:
Spring Boot 是建立在Spring框架之上的一个微服务框架，它的目标是简化新Spring应用的初始设置和配置。Spring Boot 采用“约定优于配置”的原则，提供了默认配置来减少需要显式配置的选项数量。
Spring Boot 自动配置了许多常见场景下的bean，例如连接数据库、使用缓存、安全、邮件发送等，这使得开发者可以快速启动并运行一个Spring应用。
它内置了嵌入式的Servlet容器（如Tomcat或Jetty），因此不需要外部的Web服务器就可以运行应用。
总结来说：
Spring 是一个核心的、基础的框架，提供了广泛的开发支持。
Spring MVC 是一个专注于Web应用的框架，是Spring框架的一部分，用于构建MVC架构的Web应用。
Spring Boot 是一个建立在Spring框架之上的快速应用开发框架，它简化了配置和部署过程，适合现代微服务架构的快速开发。
如果大家需要视频版本的讲解，欢迎关注我的B站：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79c798ef3a682abf6dee96dd368edebc/" rel="bookmark">
			服务器是否需要安装杀毒软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在许多服务器都自带杀毒软件，这些软件可以更好的保护服务器的安全，防止使用者的信息被泄露。那么服务器是否需要杀毒软件，这里壹基比小鑫就和大家一起看看。
一、为什么要装服务器杀毒软件？
装服务器杀毒软件主要是保护服务器安全，避免受到病毒的入侵以及影响。这个是主要的原因，另外一方面，服务器杀毒软件也可以做一些安全的策略，提高系统的安全稳定性。
二、市面上有哪里免费的杀毒软件呢？
我想说真正免费的杀毒软件是没有的，都是伴随着一些收费的服务，有著名的诺顿杀毒软件、瑞星杀毒软件、MCAFEE杀毒软件，还有百度安全卫士之类的，金山毒霸等。这时就有很多人在问了，装什么样的杀毒软件比较好呢？我觉得还是从下面的角度去思考您要不要装杀毒软件。
三、我的服务器要不要装杀毒软件呢？
其实从安全的角度来说，您不用大费周章地去想你要装什么样的杀毒软件，其实就装一个安全卫士基本的就可以了，查查木马、病毒等之类的，其实杀毒软件都大同 小异。
远程安全以及数据安全方面，还是得靠您自己来做，所以不必要花费太多的时间在杀毒软件上面。
1、远程登陆安全，允许哪些用户登陆，从哪里登陆，限制某条件登陆等，
2、文件的权限是否可以提权，特别是网站的权限是否恰当，这个要做一定的检查，
3、端口的使用是否开放，哪些端口允许开放，哪些端口不能开放，就用系统自带的安全策略做就得了。
4、数据的安全，备份以及监控等操作都必须做到位，
5、值得一提，您当前使用的用户名与密码是否安全？有没有过于简单？
服务器杀毒软件只是辅助检查有没有文件感染病毒以及有没有木马等，安全方面使用自己自带的工具就可以满足的了。所以
没有必要花太多费用与精力在挑选服务器杀毒软件上面。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/120/">«</a>
	<span class="pagination__item pagination__item--current">121/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/122/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>