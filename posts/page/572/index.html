<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfad7363c147555e7b5ab48592641601/" rel="bookmark">
			Java 8 中的 Stream API - map() 方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要： Java 8 中的 Stream API 提供了一种新的处理集合和数组的方式，可以使代码更加简洁、易读，同时还可以提高性能。其中 map() 方法是比较常用的方法之一，它可以将 Stream 对象中的每个元素映射为另一个元素。本文将对 Java 8 中的 Stream API 和 map() 方法进行详细介绍，并通过示例代码演示其使用方法。
什么是 Stream API 在 Java 8 中，引入了一个新的 Stream API，提供了一种更便捷、高效、灵活的处理集合和数组的方式。Stream API 将集合和数组中的元素转变为一个流（Stream），可以对其进行一系列的操作，比如筛选、过滤、排序、映射等，最后得到一个新的集合或数组。
使用 Stream API 可以实现代码的简化、易读性的提高，同时还可以提高代码的执行效率。当集合或数组中的元素过多时，Stream API 可以实现并行化处理，从而加速数据处理的效率。
&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) map() 方法的使用方法
map() 方法是 Stream API 中比较常用的方法之一，在 Stream 对象中的每个元素上应用一个函数，然后将函数的结果收集到一个新的 Stream 对象中。以下是 map() 方法的语法：
其中，Function 接口表示一个函数，接收一个参数并返回结果，参数类型为 T，结果类型为 R。在 map() 方法中，传入一个函数作为参数，用于将 Stream 对象中的每个元素进行转换，转换后得到一个新的 Stream 对象。
以下是一个示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfad7363c147555e7b5ab48592641601/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47a95675fa09a02c574248b54f400791/" rel="bookmark">
			Java 中的 static：静态变量、静态方法，一切都在掌握中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎏：你只管努力，剩下的交给时间
🏠 ：小破站
Java 中的 static：静态变量、静态方法，一切都在掌握中 前言第一：静态方法第二：静态变量第三：静态块第四：静态内部类第五：静态导入第六：单例模式第七：常见问题和最佳实践第八：案例研究 前言 static，这个小小的关键字在Java中扮演着重要的角色，但它的用途和工作原理可能会让人感到困惑。你是否曾想过为什么有些方法和变量可以直接从类访问，而无需创建实例？或者为什么某些变量在多个实例之间共享相同的值？在本文中，我们将探索static的奥秘，深入了解它的各种用法，从静态方法的调用到静态变量的共享，让你对Java中的static有一个清晰的认识。
第一：静态方法 静态方法（Static Method）是属于类而不是类的实例的方法。它可以在不创建类的实例的情况下被调用。静态方法通常用于执行与类相关的操作，而不需要访问或修改特定实例的状态。
以下是关于静态方法的声明、调用以及与实例方法的区别：
声明静态方法：
在Java中，声明静态方法需要使用static关键字。静态方法可以直接属于类，而不是类的实例。
public class MyClass { public static void myStaticMethod() { // 静态方法的代码 } } 调用静态方法：
你可以通过类名来调用静态方法，而不需要创建类的实例。
MyClass.myStaticMethod(); 静态方法与实例方法的区别：
关联性：静态方法与类本身相关，而实例方法与类的实例相关。
调用方式：静态方法通过类名调用，而实例方法需要通过对象实例来调用。
访问权限：静态方法可以访问类的静态成员，但不能访问非静态成员（实例成员）。实例方法可以访问类的静态和非静态成员。
内部引用：静态方法中不能使用this关键字，因为它没有当前对象的引用。实例方法可以使用this来引用当前对象。
生命周期：静态方法在类加载时初始化，而实例方法在对象创建时初始化。
总之，静态方法是与类本身相关的方法，通常用于执行通用操作或访问静态成员。实例方法则是与类的实例相关的方法，可以访问和修改实例的状态。选择使用静态方法还是实例方法取决于你的需求和代码设计。
第二：静态变量 静态变量，也称为类变量，是属于类而不是类的实例的变量。它在类加载时被初始化，只有一个副本，被所有类的实例共享。静态变量通常用于存储类级别的数据，它们不依赖于特定对象的状态，而是与整个类相关联。
以下是有关静态变量的声明、使用、生命周期和作用域的信息：
声明静态变量：
在Java中，声明静态变量需要使用static关键字。静态变量通常位于类的顶部，通常在类内部，方法外部进行声明。静态变量通常用public, private, 或 protected等修饰符修饰。
public class MyClass { // 静态变量声明 public static int staticVariable; private static String name; } 使用静态变量：
你可以通过类名来访问静态变量，也可以通过类的实例来访问它。通常建议使用类名来访问静态变量，因为它们与类相关联，而不是与特定对象实例相关。
MyClass.staticVariable = 42; // 通过类名访问静态变量 int value = MyClass.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47a95675fa09a02c574248b54f400791/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e20f81fb356da9df929362be6b3db82/" rel="bookmark">
			Redis内存满的最佳解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言造成内存满原因数据量过大键过期机制不合理内存碎片内存泄漏大量短期数据存储 解决方案1.增加内存2.设置过期时间2.1.在set命令中指定过期时间(秒):2.2.在set命令中指定过期时间(毫秒):2.3.使用expire命令为已有key设置过期时间(秒):2.4.使用pexpire命令为已有key设置过期时间(毫秒):2.5.使用expireat命令直接设置key的过期时间: 3.使用LRU算法3.1 什么是LRU算法3.2 用java 实现一个LRU算法 4.持久化数据5.分片数据6.优化数据结构7.监控和调优 总结写在最后 前言 Redis是一款高性能的内存数据库，被广泛应用于缓存、消息队列、计数器等场景。然而，由于Redis是基于内存的数据库，当数据量过大或者配置不合理时，就有可能导致Redis的内存满。内存满的情况会严重影响Redis的性能和可用性，甚至导致系统崩溃。因此，了解Redis内存满的原因以及如何应对是非常重要的。本文将介绍Redis内存满的几种原因，并提供相应的解决方案，帮助读者有效应对Redis内存满的问题。
造成内存满原因 Redis造成内存满的几种原因包括：
数据量过大 如果Redis中存储的数据量超过了可用内存的限制，就会导致内存满。这可能是因为数据量的增长超过了内存的增长速度，或者是由于Redis实例的内存配置不足。
键过期机制不合理 如果Redis中的键没有设置过期时间，或者过期时间设置不合理，就会导致过期的键一直占用内存。这会导致内存不断增长，最终导致内存满。
内存碎片 Redis使用内存分配器来管理内存，当频繁进行键的删除和修改操作时，可能会产生内存碎片。内存碎片会导致内存无法被充分利用，最终导致内存满。
内存泄漏 如果Redis中存在内存泄漏的情况，即某些键值对占用的内存没有被正确释放，就会导致内存不断增长，最终导致内存满。
大量短期数据存储 如果Redis中存储了大量的短期数据，而这些数据没有被及时清理，就会导致内存不断增长，最终导致内存满。
为了避免Redis内存满的问题，需要合理配置Redis的内存大小，设置合理的键过期时间，定期清理过期的键值对，避免内存碎片和内存泄漏问题，并根据实际需求进行监控和调优。
解决方案 当Redis的内存满了时，可以采取以下几种方式来处理：
1.增加内存 可以通过增加Redis实例的内存大小来解决内存满的问题。可以通过修改Redis配置文件中的maxmemory参数来设置Redis实例的最大内存限制。如果Redis实例运行在集群模式下，可以增加集群中的节点数量来增加总体的内存容量。
配置Redis能使用的最大的内存大小方式
1.1.通过在Redis配置文件redis.conf中设置maxmemory参数来限制Redis能使用的最大内存。例如,限制Redis最大使用100MB内存:
# Redis最大内存限制 &gt;CONFIG SET maxmemory 100mb # 达到限制时淘汰策略 &gt;CONFIG SET maxmemory-policy allkeys-lru 1.2.通过Redis命令动态设置:
config set maxmemory 100mb 2.设置过期时间 可以通过设置键的过期时间来释放一些不再使用的键值对。可以使用EXPIRE命令或者在插入键值对时设置过期时间。
2.1.在set命令中指定过期时间(秒): set key value EX 10 这个key将在10秒后自动删除。
2.2.在set命令中指定过期时间(毫秒): set key value PX 100000 这个key将在100000毫秒(100秒)后自动删除。
2.3.使用expire命令为已有key设置过期时间(秒): expire key 20 为已存在的key设置20秒过期时间。
2.4.使用pexpire命令为已有key设置过期时间(毫秒): pexpire key 120000 为已存在的key设置120000毫秒(120秒)过期时间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e20f81fb356da9df929362be6b3db82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcb1b6177444dd31abe41b9462e60052/" rel="bookmark">
			Zookeeper详解（最详细的zookeeper解析&#43;项目实例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Zookeeper 在学习Zookeeper之前，我们还是先了解它的概念：
一、什么是zookeeper? 1、简介 zooKeeper 是一个开放源码的分布式协调服务，主要为了解决分布式架构下数据一致性问题， 它是集群的管理者， 监视着集群中各个节点的状态，根据节点提交的反馈进行下一步合理操作。 最终， 将简单易用的接口和性能高效、 功能稳定的系统提供给用户
2、应用场景 分布式配置中心、分布式注册中心、分布式锁、分布式队列、集群选举、分布式屏障、发布/订阅等场景。
二、Zookeeper数据结构 1、简介 Zookeeper的数据模型类似于文件系统，是树状结构，每个树节点（目录）对应一个Znode节点。这些目录节点和我们普通的目录一样可以新建、删除、修改。
2、常用的数据格式有： 我们常用的主要有四种类型的znode。
1、持久化目录节点：PERSISTENT 客户端与zookeeper断开连接后，该节点依旧存在，只要不手动删除该节点，他将永远存在。
2、持久化顺序编号目录节点：PERSISTENT_SEQUENTIAL : -s 客户端与zookeeper断开连接后，该节点依旧存在，只是zookeeper给该节点名称进行顺序编号。
3、临时目录节点：EPHEMERAL : -e 客户端与zookeeper断开连接后，该节点被删除。
4、临时顺序编号目录节点： EPHEMERAL_SEQUENTIAL : -es 客户端与zookeeper断开连接后，该节点被删除，只是zookeeper给该节点名称进行顺序编号。
3、zookeeper客户端常用命令： 1）、连接zookeeper服务端（Linux）： ./zkCli.sh -server ip:port
2）、断开zookeeper服务端的连接： quit
3）、查看帮助： help
4）、查询所有的目录节点： ls /
5）、创建目录节点： create /节点名 值（可写可不写）
6）、设置目录节点的值（修改时也可以）： set /节点名 值
7）、删除单个目录节点： delete /节点名
8）、删除带有子节点的目录： deleteall /节点名
9）、创建临时目录节点： create -e /节点名 值（可写可不写）
10）、创建持久化目录节点： create -s /节点名 值（可写可不写）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcb1b6177444dd31abe41b9462e60052/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/775f8f11290cedfecaaac9a14f2238ec/" rel="bookmark">
			二维数字图像相关算法软件Ncorr的使用心得
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二维DIC分析引言已更新【含散斑图像生成方法】（2023.11.2） 专栏文章：二维DIC分析——引言———— &gt;点击前往
Ncorr数据处理已更新（2023.11.2） 专栏文章：Ncorr二维DIC分析注意点与数据导出、处理 ———— &gt;点击前往
二维数字图像相关算法软件Ncorr的使用心得已更新与修改（2023.11.2） 二维数字图像相关(2D Digital Image Correlation)是一种非接触式的光学测量方法，常应用于图像分析处理上，它可以根据变形前后的2张或多张图像，求解出规定区域 近似的位移与应变情况。
Ncorr下载与编译 1.下载 Ncorr下载点击这里, 提取码：2023 。
链接永久，放心食用！！！
2.编译 Ncorr的一些使用要求:
1.要求Matlab版本在R2015a 以上；
2.Matlab需要图像处理工具箱（Image Processing Toolbox）与统计工具箱（Statistics Toolbox ）
3.操作系统需要是Windows或者Linux。
4.编译器需要Visual Studio 2008+或者GCC 4.2+。
本文使用Matlab版本为R2022a，编译器平台为Visual Studio 2017。
Visual Studio2017安装可参考这里。
下载完Ncorr软件后，将其在matlab环境下打开，注意的是如果打开的时候Ncorr所在文件夹是灰色的，则需要双击，切换为当前工作文件夹！！！如下所示。 然后在Matlab命令行窗口输入下述代码后按下Enter键出现如下图所示的提示框，点击确定即可。
addpath(pwd); handles_ncorr = ncorr; 紧接着会跳出OpenMP Support的提示框，不勾选默认CPU核数为1，即单线程进行DIC分析（后面设置种子点个数的话与此线程数有关，默认单线程也能工作，只不过相比多线程的并行计算会慢点）。勾选的话，则需要你的Visual Studio版本支持openMP语言的编译才行，本文的Visual Studio 2017版本支持openMP的编译，可以勾选。
勾选以后，cores的数量填选取决于你的电脑CPU是几核的。CPU核数的查询可右击桌面此电脑，点击属性,然后点击设备管理器查询。本文填选如下图所示。
当出现下图所示编译成功与Ncorr的图形用户界面（GUI）时，说明你已经下载Ncorr成功，接下来就可以在GUI界面上进行操作，完成你的DIC分析。
以后再次打开Matlab，只要在命令行窗口输入ncorr即可打开该软件。
Ncorr通用DIC分析流程 首先看一张我画的Ncorr操作流程图，如下图所示 1.设置参考图像 2.设置当前图像 Load All (memory heavy)选项表示将所有图像存储到Matlab工作区中，如果一次分析大量图像，这个选项是不可取的，因为这会导致RAM空间不足。 Load Lazy （slower but less memory）选项表示延迟加载，Matlab只存储图像的名称和路径，适用于大量图像分析，不过会影响一些DIC分析速度。 本文使用Load All选项
3.设置ROI区域 Set Reference ROI选项是从参考图像设置感兴趣区域（ROI） Set Current ROI（For “Backward” Analysis）选项是从当前图像设置感兴趣区域（ROI），适合反向DIC分析 本文使用Set Reference ROI选项
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/775f8f11290cedfecaaac9a14f2238ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/154e7b80d53e4467c740e24b07456226/" rel="bookmark">
			kafka客户端工具（Kafka Tool）的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 下载 官方下载
2. 安装客户端 根据不同的系统下载对应的版本，点击下载后双击，如何一直下一步，安装
3、简单使用 kafka环境搭建请参考：CentOS 搭建Kafka集群
（1）连接kafka （2）简单使用 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb591bbe6445c691de80892eab4b8983/" rel="bookmark">
			【Python】判断素数的三种方法以及for-else语句的介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 输入一个数，如果是素数就输出"Yes"，否则输出"No"
方法一：暴力枚举法 def is_prime(x): if x==1: return False; for i in range(2,x): if x%i==0: return False return True n=int(input()) if is_prime(n): print("Yes") else: print("No") 自定义函数is_prime()，首先排除1，然后再对该数之前的数进行枚举，当遇到能被当前的数整除时返回False，若没有数能将其整除意味着这个数是素数，返回True。然后对返回的结果进行判断从而输出"Yes"或"No"
当然，我们可以省去最后if-else的判断，直接在函数is_prime()里来输出"Yes"或"No"
def is_prime(x): if x==1: print("No") return for i in range(2,x): if x%i==0: print("No") break else: print("Yes") n=int(input()) is_prime(n) for-else语句 在上面的代码中，我采用了for-else语句，这是一个比较特殊的语句。当for循环正常结束时，else也会执行，而当for循环未正常结束，例如使用break提前退出时，则不会执行。使用这个语句往往可以减少代码量，避免使用flag。
方法二：内置函数 import sympy n = int(input()) if sympy.isprime(n): print("Yes") else: print("No") 使用python自带的sympy库中的isprime()函数仅需一行就能判断素数
方法三：优化了时间复杂度 import math def is_prime(n): if n &lt;= 1: return False if n &lt;= 3: return True if n % 2 == 0 or n % 3 == 0: return False for i in range(5, int(math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb591bbe6445c691de80892eab4b8983/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ab6ea737b1c433b16147c8a206cffa5/" rel="bookmark">
			Python GUI界面界面—tkinter，学习、复习、查阅，这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言引入 PythonGUI程序界面设计tkinter优点：无需另外下载，是自带的、操作简单、易方便；
缺点：界面控件较少，页面不够美观
注：一般来说做小软件tkinter足够了（页面可以用ttkbootstrap美化）。
参考材料：https://blog.csdn.net/qq_48979387/article/details/125706562
二、创建窗口 2.1生成窗口 方法一 # 导入模块(库) import tkinter # 创建一个窗口，格式：窗口名 = tkinter.Tk() root = tkinter.Tk() 方法二 # 导入模块，并起一个别名tk import tkinter as tk # 创建一个窗口，格式：窗口名 = 别名.Tk() root = tk.Tk() 2.2窗口显示 窗口一闪而过，我们要让窗口一直出现，就要加一个窗口循环代码
# 窗口循环代码，格式：窗口名.mainloop() root.mainloop() 效果：成功生成了一个窗口！！！！
虽是学习tkinter的一小步，却是开发小软件的一大步！
2.3窗口标题及窗口大小、位置 # 设置窗口标题 root.title("窗口标题") # 给窗口设置宽高以及窗口在屏幕的位置 root.geometry("300x100+630+80") # (宽度x高度)+(x轴+y轴) 效果：
2.31窗口生成到屏幕中间
# 获取窗口宽度、宽度 w = root.winfo_reqwidth() h = root.winfo_reqheight() # 获取屏幕宽度、高度 screen_w, screen_h = root.maxsize() # 计算窗口坐标 x = (screen_w - w) / 2 y = (screen_h - h) / 2 # 设置窗口坐标 root.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ab6ea737b1c433b16147c8a206cffa5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/212775d18b5bf1e9d28c6b5486bca5e8/" rel="bookmark">
			Mac -- zsh-最新全网超详细的个性化终端(Terminal)颜色及vim颜色配置(亲测可行)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自 Mac -- zsh-最新全网超详细的个性化终端(Terminal)颜色及vim颜色配置(亲测可行)_mac zsh-CSDN博客
以下都是苹果 设置，这是简化版的，详细的看我引用的
个性化终端颜色背景设置 显示检查器 打开终端，鼠标在终端中，右击，选择“显示检查器”，在自动弹出的“检查器”中选择自己喜欢的终端背景并双击
描述文件 在自动弹出的对话框中选择“描述文件”，在这里依然可以重新选择自己喜欢的终端背景，选择好之后一定要点击左下角的默认键
系统默认主题是Basic，这里我把黑色背景的Pro主题设为默认，并对字体、颜色等进行了修改，具体如下：
修改了背景色的饱和度和亮度，让背景看上去没有那么黑；不透明度调整为100%，因为感觉原来的半透明看上去挺尴尬的；
修改字体为Menlo 16磅；
取消选择“使用粗体字”，增加选择“对粗体文本使用亮丽颜色”；
修改了ANSI颜色中两种蓝色的参数，使其能够在黑色的背景上显示得更清楚一些；
修改光标颜色为较深的绿色，更加醒目；增加选择“闪动光标”；
修改后的显示效果可参考后续步骤中的图。
不同文件(ls) -- 颜色配置 编辑.bash_profile配置文件 sudo vim ~/.bash_profile 用超级管理员权限打开文件，在文件末尾添加如下代码：
export CLICOLOR='Yes' # 是否输出颜色
# export LS_OPTIONS='--color=auto' # 不同文件类型颜色配置，自动选择颜色
export LSCOLORS='ExGxFxdaCxDaDahbadacec' # 指定颜色，Linux配色方案 按Esc退出到命令模式,输入：:wq! (!一定不可以省略,否则会报错) 生效配置 source .bash_profile ok,ls目录颜色修改到这就ok了,关闭当前Terminal，重启一个新的Terminal使配置生效。显示效果如下图所示:
这里完全沿用了Linux的配色方案 vim -- 配色 Mac默认的vim配色也是黑底白字，没有任何高亮，需要我们自行配置，这里配置vim人气超高的molokai配色方案，废话不多，先上效果
切换到主用户目录
复制vim的系统配置文件
cd ~
cp /usr/share/vim/vimrc ~/.vimrc
vim .vimrc
配置文件 colorscheme default " 设置颜色主题 syntax on " 语法高亮 filetype on "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/212775d18b5bf1e9d28c6b5486bca5e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b8f860ce8eb99623075dc217367f49b/" rel="bookmark">
			【数据结构】堆的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大小堆的概念 将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。
堆的接口函数 void HeapInit(Heap*st);//堆的初始化 void swap(int* str1, int* str2);//交换两个数据 void Adjustup(int* a, int child);//向上调整 void HeapPush(Heap* st, int x);//插入元素 void AdjustDown(int* a, int n, int parent);//向下调整 bool HeapEmpty(Heap* st);//堆是否为空 int HeapSize(Heap* st);//堆数据个数 void HeapPop(Heap* hp);//堆元素的删除 void HeapDestroy(Heap* st);//堆的销毁 int HeapTop(Heap* st);//堆顶元素 定义堆结构体 typedef struct Heap { int* a; int size; int capacity; }Heap; 初始化堆 void HeapInit(Heap*st) { st-&gt;a = NULL; st-&gt;capacity = 0; st-&gt;size = 0; } 交换两个数据 void swap(int* str1, int* str2) { int tmp = *str1; *str1 = *str2; *str2 = tmp; } 判断堆是否为空 bool HeapEmpty(Heap* st) { assert(st); if (st-&gt;size == 0) { return true; } else { return false; } } 堆元素的个数 int HeapSize(Heap* st) { assert(st); return st-&gt;size; } 堆的销毁 void HeapDestroy(Heap* st) { assert(st); free(st-&gt;a); st-&gt;a = NULL; st-&gt;size = 0; st-&gt;capacity = 0; } 堆顶元素 int HeapTop(Heap* st) { assert(st); assert(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b8f860ce8eb99623075dc217367f49b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2868f1457b225b31dd0083e75c6aadb8/" rel="bookmark">
			【腾讯云 TDSQL-C Serverless 产品体验】聚焦业务价值之在Serverless上的探索和实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【腾讯云 TDSQL-C Serverless 产品体验】聚焦业务价值之在Serverless上的探索和实践
简介：随着公司商城的业务规模量的逐渐增长，对系统服务的弹性诉求越来越强烈，通过借助腾讯云TDSQL-C Serverless最佳落地实践如何对企业有效的降低成本，提高效率。
公司的业务现状： 公司在今年上半年开发了一个商城，在投入运营阶段发现在业务的初期5、6、7、8月初，用户量比较少，基本上还不到100的访问量，经过公司的策略改变，加上运营团队进行了几波疯狂有效的推广与促销，使系统的访问量逐渐在这2个月起来了，以下是公司的流量趋势图。
项目上线后，非但没有有效的盈收，反正每月还要消耗大量的IT软硬件资源成本。
Serverless的探索： Serverless计算模式一直是各大云厂商追求的目标。Serverless概念以及FaaS+BaaS的设计思想的提出也极大地影响了近几年云计算的发展。随着腾讯云的Serverless Framework以及国内各云厂商FaaS模式的不断发展，业内对数据库模式的BaaS需求也越发强烈。
Serverless数据库的核心是解决实例CPU、内存和磁盘等资源平滑升降的问题，使得数据库实例可以根据负载情况按需分配资源。这种方式可以让用户获得最合理的IT资源，从而优化用户价值。
在业务波动较大的场景下，普通实例和Serverless实例资源使用和规格变化情况不同的对比：
Serverless这种模式在我们日常生活中无处不在。比如，我们日常用的水电，每月交水费和电费时，系统都会精确到几分钱，水电作为一种公共设施，完全可以按照个人需要去付费，用多少付多少，无需额外支付，其实这就是一种Serverless服务。
进入云计算模式以后，客户不用再去买服务器，直接使用云服务厂商提供的服务即可。这相当于是一种租车模式，相比买车成本更低，但同时也存在一个问题，因为你的业务不是每天都在跑，却时刻需要为这个服务去付费，租赁成本比较高昂。
而Serverless服务相当于打车模式，在你需要时才去为此付费，你不用特意去买车，也不用租车，需要用车时直接打车就行，更节约成本。从用户视角看，Serverless服务是一种完全按需付费的商业模式。
Serverless服务背后需要很强大的计算能力和资源池化的调度能力来支撑，对底层基础设施服务要求较高。而且随着技术演进，未来会有很多后端服务逐步走向Serverless化，比如云数据库，面临的技术挑战也会更大。
TDSQL-C Serverless 的实践： TDSQL-C基于全新计算存储分离的分布式数据库架构，融合传统数据库和云计算技术优势，100%兼容MySQL和PostgreSQL，极致计算能力突破千核，存储容量达PB级别，使得性能和安全性媲美商用数据库。并且TDSQL-C支持集群和Serverless灵活弹性部署，克服传统架构下的存储量受限、扩展难、主从延迟高等缺点，充分释放领先技术的成本效益，最高可为企业节省90%的成本。
TDSQL-C Serverless数据库对比传统云数据库的优势：
Serverless计费方式无需按固定资源付费，根据业务负载自适应动态匹配资源，秒级弹性升降资源与计费，最高可节省 90% 费用。
TDSQL-C MySQL Serverless实例提供了CPU、内存的实时弹性能力，实例不仅提供网络资源、命名空间、存储空间的垂直资源隔离能力，还提供计算资源按需计费的能力，具有资源用量低、简单易用、弹性灵活和价格低廉等优点，赋能用户面向业务峰谷时对计算能力进行快速且独立的扩缩要求，做到快速响应业务变化的同时，合理优化使用成本，进一步助力企业降本增效。
优势：
更低的成本：对于创业初期的企业，MySQL Serverless不依赖其他的基础设施和相关服务，即买即用并可以提供稳定和高效的数据存取服务。使用期间只需要为占用的资源按使用量付费。更大的存储空间：存储空间最大可高达32 TB，根据实例数据量自动扩展，可以有效避免集群存储资源不足对业务造成影响。计算资源自动弹性扩缩容：用户读取和写入需要的计算资源可弹性伸缩，不需要手动扩缩容，极大减少了运维成本和系统风险。全面托管和免运维：版本升级、系统部署、扩缩容、报警处理等所有运维工作由阿里云专业团队完成，用户无感知，业务无影响，服务持续可用，真正免运维。 适用场景：
开发、测试环境等低频数据库使用场景中小企业建站服务等SaaS应用场景个人开发者用户学校教学、学生实验等教育场景物联网（IoT）、边缘计算等不确定负载场景全托管或希望完全免运维的用户业务有波动或不可预测的用户具有间歇性定时任务的业务场景 TDSQL-C Serverless 的落地实践： 生态接入能力： TDSQL-C Serverless数据库可以通过HTTP请求直接访问数据库，降低了传统数据库的使用门槛。相比通过JDBC/ODBC进行CRUD等操作，对程序员的要求更低，为用户提供RESTful API等方式，以灵活地执行SQL语句并与数据库进行交互：
秒级计费能力： TDSQL-C MySQL Serverless数据库实现了秒级计费：
正常运行的实例，计费系统会记录实例秒级CCU资源量变化，实现精确计费。当实例进入自动暂停阶段时，计费系统只会计算存储云盘费用，以节省费用。当实例恢复启动状态后，计费系统会重新按照资源CCU进行秒级计费。 按量计费的模式：
资源包的模式：
实例自动启停： TDSQL-C MySQL Serverless支持实例的自动启停功能，这项功能为研发实例、测试实例或周期无负载的实例提供了更为极致的成本优化。
当用户不需要访问数据库时，该功能能够让实例进入暂停状态，从而进一步节省资源成本。通过实现自动启停，TDSQL-C MySQL Serverless数据库能够更加智能地管理资源，使得资源的使用更加高效和灵活，为用户提供了更为经济和便捷的服务。
为了保障实例启停体验，TDSQL-C MySQL Serverless数据库在以下几个方面进行了深入改造和优化：
增加恢复感知器：
通过恢复感知器，TDSQL-C MySQL Serverless实例在暂停期间也不会宕机。当MySQL处于暂停状态时，一旦有请求访问，恢复感知器，保证系统一直在线，随时响应用户的请求，提高实例的可用性和效率，将实例内核本身的启动时间压缩到2秒内，极大地提高了实例启动的效率和速度。
云原生资源监控调度优化：
为保障实例资源分配和加载的效率，TDSQL-C MySQL Serverless采用了计算与存储分离的架构模式，极大地降低了实例启动管控时间。
购买数据库后。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2868f1457b225b31dd0083e75c6aadb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3298267b827a0613cb97eab6f8b27c28/" rel="bookmark">
			前端（二十七）——封装指南：Axios接口、常用功能、Vue和React中的封装技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😊博主：小猫娃来啦
😊文章核心：前端封装指南：Axios接口、常用功能、Vue和React中的封装技术
本文目录 小引前端封装以真实项目举个例子 Axios接口封装常用功能封装封装 Vue中的封装技术React中的封装技术Vue和React封装技术的对比 小引 在我们前端开发当中，封装是种将代码和功能组织起来以便重复使用的方式。它可以使开发人员更高效地编写、维护和管理代码。本文将探讨前端封装的定义、重要性以及在Web开发中实施封装的方法。
随着Web应用程序的复杂性不断增加，程序员需要应对各种挑战，如代码复用、维护性、可扩展性等。前端封装作为一种解决方案出现，旨在帮助开发人员更好地管理和组织代码。
接下来我们一起探讨一下前端封装的概念和优势，并提供一些常见的实施封装的方法，以帮助大家更好地理解和应用前端封装。
前端封装 前端封装是指将代码和功能组织起来，以便在项目中重复使用。它可以将复的代码抽象成简单易懂的模块，提高代码的可读性和可护性。封装还可以降低代码之间的耦合度使代码更易于测试和重构。
前端封装的优势:
代码用: 封装可以使开发人员将常用功能和代码片段组织起来，以便在个项目中重用，减少冗余代码的编写。可维护性: 封装可以将复杂的代码逻辑封装在一个独立的模块中，使其易于解和维护。当需要修改某个时，只需要修改封装的块，而不需要修改整个项目的代码。
. 可扩展性:
封装将应用程序的不同部分分离来，使其独立于其他部分。这样当需要新增功能或修改现有功能时，只需要修改封装模块，而不需要影响其他分的代码。提开发效率: 封装可以使开发人员更快地编写代码，因为他们可以重复使用现有的封装模块，而不需要从头开始编写代码。 在Web开发中，可以使用同的方法来实施前端封装。以下是一些常见的实施方法：
模块化开发: 使用模块化开发的方式，将应程序划分为独立的模，并使用导入和导出语句将模块组织来。这样可以使代码更于维护和测试，同时也提供了良好的代码复用性。组件化开发: 使用组件化开发的方式，将应用程序划分为不同的组件，并将每组件封装成独立的模块。这样可以将应用程序的不同部分分离开来，提高可维护性和可扩性。工具库 使用工具库来封装常用的功能、方法和工具。发人员可以使用这些工具库来快速实现一些常见的功能，提高开发效率。 以真实项目举个例子 封装一个Header组件
直接在全局导入使用，非常舒服。
还可以将这些东西保存起来，以后在其他项目中直接移植过去使用，不香吗？这个就是技术积累了。
Axios接口封装 Axios是一个基于Promise的JavaScript HTTP客户端，用于在浏览器和Node.js中发送异步请求。它支持封装请求和响应的拦截器，提供了简的API来处理AJAX请求。
在使用Axios进行接口封装之前，我们需要先进行Axios的配置。可以通过创建实例来配置Axios，设置一些全局的默认属性，如baseURL、headers等。
import axios from 'axios'; const instance = axios.create({ baseURL: 'https://api.example.com', timeout: 5000, headers: { 'Content-Type': 'application/json', }, }); export default instance; 在上述代码中，我们创建了一个名为instance的Axios实例，并设置了baseURL、timeout和headers等属性。这些属性将在之后的请求中作为默认值。
接下来，我们可以通过封装API请求和响应来简化我们的代码，并提高代码的可读性和维护性。可以创建一个api.js文件，封装常用的API请求和响应。
import instance from './axios-instance'; export const getUser = () =&gt; { return instance.get(`/users/${userId}`); }; export const updateUser = (userId, userData) =&gt; { return instance.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3298267b827a0613cb97eab6f8b27c28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3fcda822688d545a2edfadfb5eb664a/" rel="bookmark">
			【大数据毕设】基于Hadoop的音乐推荐系统的设计和实现(六)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌全网粉丝6W+,csdn特邀作者、博客专家、大数据领域优质创作者,博客之星、掘金/华为云/阿里云/InfoQ等平台优质作者、专注于大数据技术领域和毕业项目实战✌
🍅首页可直接下载项目🍅
🍅文末获取联系,有偿部署🍅
文章目录 基于Hadoop的音乐推荐系统的设计和实现1.1 研究的背景及意义1.1.1 选题的背景1.1.2 国内外研究现状1.1.3 研究的意义 1.2 系统目标2.1 功能需求2.1.1 数据清洗2.1.2 数据上传2.1.3 数据分析 2.2 非功能需求2.2.1 可维护性分析2.2.2 可扩展性分析2.2.3 应用场景分析2.2.4 可测试性分析2.2.5 其它需求 3.1 运行环境3.2 基本处理流程3.3 模块结构3.3.1数据清洗3.3.2数据上传3.3.3数据分析3.3.4数据存储3.3.5数据可视化 3.4 外部接口3.5 内部接口4.1 概念结构设计4.1.1 设计思路4.1.2 实体属性图 4.2 逻辑结构设计4.2.1 设计思路4.2.2 逻辑模型 4.3 物理结构设计4.3.1 存取方式4.3.2 存储结构 5.1 界面关系图或工作流图5.2 界面设计成果6 详细设计6.1 系统主要功能模块介绍6.2 数据清洗模块设计6.2.1 数据清洗模块算法描述 7 编码7.1 代码实现与核心算法（1）核心算法（2）代码实现 img7.2 代码优化分析8 测试8.1 测试方案设计8.1.1 测试策略8.1.2 测试进度安排8.1.3 测试资源8.1.4 关键测试点 8.2 测试用例构建8.2.1 测试用例编写约定8.2.2 测试用例设计8.2.3 关键测试用例8.2.4 测试用例维护 基于Hadoop的音乐推荐系统的设计和实现 摘 要
随着音乐行业的不断发展和热爱音乐的人不断增加，为了适应当今社会人们追求质量和高标准的生活，从大量的歌曲中找到个人喜好的小部分歌曲成了当务之急，然而普通的系统已经无法处理这种相当大的数据，然而基于大数据的音乐推荐系统作为可以解决这个重要难题的主要解决办法，其方法的好用程度已经成为了人类高标准生活的重要的一部分。随着计算机技术和互联网的高速发展，大量的数据随之产生，如何从大量的、冗余度、低质量的数据中找到符合要求的高质量数据成为了重中之重，所以构建一个能够将大量低质量、复杂、冗余的数据转换成高质量数据的音乐推荐系统有非常重要的意义。
本文一开始分析了基于大数据音乐推荐系统和音乐推荐系统的背景，指明了本文的研究思路和方向，然后，根据软件工程项目的要求，进行了基于大数据的音乐推荐系统的需求分析，并通过数据处理流程的整理和分析，进行了系统的整体设计，主要包括数据的模拟、集群的搭建、Maven项目的构建、代码的编写以及代码的运行。在系统分析和设计的基础上进行了数据库的设计，主要包括了数据库建模和数据库逻辑设计，最后，对系统进行了开发和运行测试，通过Hadoop、Yarn、Zookeeper等技术的运用，开发了一个能够基于大量数据，处理好大量数据并且产生准确结果的基于大数据的音乐推荐系统。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3fcda822688d545a2edfadfb5eb664a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c56dcb47af5de937fd11bbf1c551909/" rel="bookmark">
			Android 理解/生成/使用/查看 签名(V1-V4)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该文章主要针对于android签名部分进行较为详细的说明，旨在理解签名的整体使用体系及keytool和apksigner的常见用法，重在实践意义。
1 签名的理解（V1 V2 V3 V4签名） 在 Android 应用签名中，V1 V2 V3 V4签名是不同的签名方案，具体描述如下：
V1 签名（JAR 签名）：早期 Android 应用签名的基本形式，基于 Java 签名（JAR 签名）规范。它将应用的整个 APK 文件作为一个整体进行签名，包括应用的所有内容（包括清单文件、资源文件和代码文件等）。V1 签名使用了基于 MD5 和 SHA1 的哈希算法，以及 RSA 或 DSA 加密算法。V2 签名（APK 签名方案 v2+）：Android 7.0（API 级别 24）及更高版本引入的新签名方案。它采用了一种增量签名的方法，只对 APK 内容的部分进行签名，而不是整个 APK 文件。这种增量签名可以提供更好的签名效率和验证性能，并且不会破坏 APK 的完整性。V2 签名使用了基于 SHA256 的哈希算法，并采用 ECDSA（椭圆曲线数字签名算法）进行签名。它还提供了对 APK 文件进行验证和完整性检查的机制，以确保 APK 在传输和安装过程中没有被篡改。V2 签名是对 V1 签名的增强，而不是互斥的。在支持 V2 签名的设备上，应用将同时包含 V1 和 V2 两种签名方案，以保证在各种设备上的兼容性和验证方式。V2 签名是在 V1 签名基础上引入的增强方案，提供了更好的效率和安全性。V3 签名（APK 签名方案 v3+）： Android 9.0（API 级别 28）及更高版本引入的新签名方案。它是对 V2 签名的进一步增强。V3 签名采用了更强大的签名算法（基于 RSA 或 ECDSA）和更长的密钥长度，以提供更高的安全性。V3 签名与 V2 签名类似，仍然采用增量签名的方式，只对 APK 内容的部分进行签名。V3 签名在验证和完整性检查方面与 V2 签名相似，但它还提供了一些额外的安全特性，例如签名块的完整性保护和签名的附加时间戳。需要注意的是，V3 签名是可选的，应用可以同时包含 V1、V2 和 V3 三种签名方案。V3 签名的引入进一步提升了应用的安全性和验证机制，同时确保了对旧版 Android 设备的兼容性。开发者可以选择在构建应用时使用 V3 签名来提高应用的安全性水平。V4 签名（APK 签名方案 v4+）： Android 11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c56dcb47af5de937fd11bbf1c551909/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc20508d8a2998db84df343a3683e84c/" rel="bookmark">
			Android Studio的笔记--SerialPort串口通讯学习和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SerialPort串口通讯学习和使用 SerialPortandroid-serialport-api源码下载 Android-SerialPort-API源码下载readme版本 Android-SerialPort-Tool源码下载 Android-Serialport源码下载使用方法readme android中使用串口通信使用android-serialport-api方式第1种 链接第2种 导入SerialPort库第3种 编译SerialPort模块 串口通信部分代码 摘要：本篇介绍android中SerialPort串口通讯学习和使用。主要用到android-serialport-api。 SerialPort 几个工程参考学习使用
android-serialport-api Google开源的Android串口通信Demo android-serialport-api
源码下载 cepr/android-serialport-api
SerialPort获取串口输入输出流
SerialPortFinder获取硬件地址
可以推荐看android串口通信——android-serialport-api 源
Android-SerialPort-API 源码下载 licheedev/Android-SerialPort-API
readme 版本 添加依赖：implementation ‘com.licheedev:android-serialport:2.1.3’
allprojects { repositories { ... jcenter() mavenCentral() // since 2.1.3 } } dependencies { implementation 'com.licheedev:android-serialport:2.1.3' } 除了选择2.1.3版本，还可以看 releases 选择其他版本。
Android-SerialPort-Tool 源码下载 licheedev/Android-SerialPort-Tool
Android-Serialport 源码下载 xmaihh/Android-Serialport
使用方法 Android移植谷歌官方串口库支持校验位、数据位、停止位、流控配置
1. 检验参数合法性 /* Check arguments */ { speed = getBaudrate(baudrate); if (speed == -1) { /* TODO: throw an exception */ LOGE("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc20508d8a2998db84df343a3683e84c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/284a43d04470f95aed7dbffc3c621f2f/" rel="bookmark">
			【详细版】Linux系统中搭建Hadoop
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Hadoop单机版环境搭建 1、上传JDK至服务器 创建tools目录，用于存放文件
mkdir /opt/tools 切换tools目录，rz上传JDK安装包
jdk-8u361-linux-x64.tar.gz （文章结尾附安装包链接）
2、解压JDK安装包 创建server目录，用于存放JDK解压后的文件
mkdir /opt/server 解压至server目录
tar -zvxf jdk-8u131-linux-x64.tar.gz -C /opt/server 3、配置JDK环境变量 编辑 /etc/profile 文件
vim /etc/profile # 文件末尾增加 export JAVA_HOME=/opt/server/jdk1.8.0_361 export PATH=${JAVA_HOME}/bin:$PATH 执行source命令，使配置立即生效
source /etc/profile 检查是否安装成功
java -version 4、配置免密登录 Hadoop 组件之间需要基于 SSH 进行通讯，配置免密登录后不需要每次都输入密码
更改当前用户名为server，reboot后生效
echo "server" &gt; /etc/hostname 配置映射，配置 ip 地址和主机名映射
vim /etc/hosts # 文件末尾增加 192.168.1.153 server 生成公钥私钥
ssh-keygen -t rsa 进入 ~/.ssh 目录下，查看生成的公匙和私匙，并将公匙写入到授权文件
cd ~/.ssh cat id_rsa.pub &gt;&gt; authorized_keys chmod 600 authorized_keys 5、下载并解压Hadoop 切换/opt/tools目录下，rz上传Hadoop安装包
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/284a43d04470f95aed7dbffc3c621f2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ab24c25d8cf4a76de07dbf8c99381f5/" rel="bookmark">
			网络流量调度的艺术：权重公平排队算法（WFQ）揭秘，全面解析！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络流量调度的艺术：权重公平排队算法（WFQ）揭秘，全面解析！ 1. 前言 在计算机网络中，流量调度是一个重要的问题。为了有效地利用网络资源，保证各个应用程序获得公平的带宽分配，一种常用的流量调度算法——权重公平排队（Weighted Fair Queuing，简称WFQ）应运而生。本文将从基本概念、工作原理、优点和缺点等方面对WFQ进行详细解析。
2. 基本概念 2.1 排队模型 在介绍WFQ之前，我们先来了解一下排队模型。在网络通信中，数据包通常会被存储在路由器的缓冲区中，等待发送。排队模型可以通过对缓冲区中的数据包进行管理，以实现对网络流量的调度。
2.2 权重公平排队 WFQ是一种基于虚拟时钟的排队算法，它为每个数据流分配一个虚拟时钟，并按照时钟的进度来完成流量调度。WFQ根据数据流的权重分配带宽，以实现公平的排队和传输。
3. 工作原理 3.1 虚拟时钟 WFQ使用虚拟时钟来模拟时间片轮转调度。每个数据流都有一个与之对应的虚拟时钟，时钟以恒定速率前进。当某个数据流的虚拟时钟到达特定值时，该数据流的数据包被发送。
3.2 排队和调度 WFQ维护了一个队列，用于存储待发送的数据包。每当一个数据包到达时，WFQ根据数据流的权重将其放入相应的队列中。在每个时钟周期中，WFQ从队列中选择一个数据包发送，直到所有队列为空。
3.3 权重计算 WFQ使用权重计算来确定每个数据流的虚拟时钟速率。较高权重的数据流获得更多的带宽分配，而较低权重的数据流获得较少的带宽分配。这种方式可以保证高权重的数据流优先传输，并实现公平的流量调度。
4. 优点与缺点 4.1 优点 公平性：WFQ可以根据数据流的权重进行公平的排队和传输，保证了各个应用程序获得合理的带宽分配。防止饥饿：由于采用了轮转调度和虚拟时钟的机制，WFQ能够避免某些数据流长时间被忽视的情况，有效地防止了饥饿现象的发生。支持多种应用：WFQ适用于各种不同类型的应用程序，包括实时流媒体、Web浏览、文件传输等。 4.2 缺点 复杂性：WFQ算法相对较为复杂，实现和管理上需要一定的开销和复杂度。延迟增加：由于需要维护队列和虚拟时钟，并进行权重计算，WFQ会引入一定的延迟，可能会影响实时性要求较高的应用程序。 5. 总结 本文对权重公平排队（WFQ）算法进行了详细解析。我们从基本概念、工作原理、优点和缺点等方面进行了讨论。WFQ作为一种流量调度算法，可以有效地实现带宽分配的公平性，并且适用于各种不同类型的应用程序。然而，也需要注意到其复杂性和延迟增加的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65f364b3d78603e141d54356c70550e6/" rel="bookmark">
			【C&#43;&#43;】详解priority_queue（优先级队列）与函数对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、priority_queue 的介绍和使用
1.1priority_queue 的介绍
2.2priority_queue 的使用
二、仿函数
2.1什么是仿函数
2.2仿函数的作用
三、函数对象的特点（知识点多）
3.1分析特点5（比较普通函数与函数对象）
3.1.1利用普通函数传递参数
拓展之：深度剖析函数利用模板的本质
3.1.2利用函数对象传递参数
3.1.3函数对象作为for_each的参数（知识点较多）
2.第三个参数传递函数：（计算从0到100）
3.第三个参数传递函数对象：（计算从0到100）
4.难点：关于第三个参数是传值的易错点
5.拓展：如果我重写for_each，加上引用，会不会得到我想要的效果？
3.2分析特点6（一共俩句话）
3.2.1分析保持函数的调用状态（本质是因为成员变量不会销毁）
3.2.2参数个数可变是什么意思？代码分析过程中居然用到了匿名对象！
1.分析函数对象的用法及匿名对象
2.探究匿名对象的生命周期
3.回忆匿名对象拆分开怎么写
4.讨论多参数问题（多参数不是重载函数多，而是类中多变量）
四、函数对象的分类
4.1一元函数
4.2二元函数
4.3一元判定函数
4.4二元判定函数 五、总结知识点（未完待续.....）
一、priority_queue 的介绍和使用 1.1priority_queue 的介绍 priority_queue （优先级队列）是一种容器适配器，它与 queue 共用一个头文件，其底层结构是一个堆，并且默认情况下是一个大根堆，所以它的第一个元素总是它所包含的元素中最大的，并且为了不破坏堆结构，它也不支持迭代器。
同时，由于堆需要进行下标计算，所以 priority_queue 使用 vector 作为它的默认适配容器 (支持随机访问)：
但是，priority_queue 比 queue 和 stack 多了一个模板参数 – 仿函数；关于仿函数的具体细节，我们将在后文介绍
class Compare = less&lt;typename Container::value_type&gt; 2.2priority_queue 的使用 优先级队列默认使用 vector 作为其底层存储数据的容器，在 vector 上又使用了堆算法将 vector 中元素构造成堆的结构，因此 priority_queue 就是堆，所有需要用到堆的位置，都可以考虑使用 priority_queue。(注意：默认情况下priority_queue是大堆)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65f364b3d78603e141d54356c70550e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e96d05f3dfc2fd8886baaf1af07e38a/" rel="bookmark">
			【JavaEE初阶】 认识文件与Java中操作文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🌴认识文件🚩树型结构组织和目录🚩文件路径（Path）🚩知识扩展 🎍Java 中操作文件🚩File 概述📌属性📌构造方法📌方法 🚩File使用实例代码演示📌实例一📌实例二📌实例三📌实例四📌实例五📌实例六📌实例七 ⭕总结 🌴认识文件 我们先来认识狭义上的文件(file)。针对硬盘这种持久化存储的I/O设备，当我们想要进行数据保存时，往往不是保存成一个整体，而是独立成一个个的单位进行保存，这个独立的单位就被抽象成文件的概念，就类似办公桌上的一份份真实的文件一般。
文件除了有数据内容之外，还有一部分信息，例如文件名、文件类型、文件大小等并不作为文件的数据而存在，我们把这部分信息可以视为文件的元信息
🚩树型结构组织和目录 同时，随着文件越来越多，对文件的系统管理也被提上了日程，如何进行文件的组织呢，一种合乎自然的想法出现了，就是按照层级结构进行组织 —— 也就是我们数据结构中学习过的树形结构。这样，一种专门用来存放管理信息的特殊文件诞生了，也就是我们平时所谓文件夹(folder)或者目录(directory)的概念。
🚩文件路径（Path） 如何在文件系统中如何定位我们的一个唯一的文件就成为当前要解决的问题，但这难不倒计算机科学家，因为从树型结构的角度来看，树中的每个结点都可以被一条从根开始，一直到达的结点的路径所描述，而这种描述方式就被称为文件的绝对路径（absolute path）
除了可以从根开始进行路径的描述，我们可以从任意结点出发，进行路径的描述，而这种描述方式就被
称为相对路径（relative path），相对于当前所在结点的一条路径
🚩知识扩展 即使是普通文件，根据其保存数据的不同，也经常被分为不同的类型，我们一般简单的划分为文本文件和二进制文件，分别指代保存被字符集编码的文本和按照标准格式保存的非被字符集编码过的文件。
Windows 操作系统上，会按照文件名中的后缀来确定文件类型以及该类型文件的默认打开程序。但这个习俗并不是通用的，在 OSX、Unix、Linux 等操作系统上，就没有这样的习惯，一般不对文件类型做如此精确地分类。
文件由于被操作系统进行了管理，所以根据不同的用户，会赋予用户不同的对待该文件的权限，一般地可以认为有可读、可写、可执行权限
Windows 操作系统上，还有一类文件比较特殊，就是平时我们看到的快捷方式（shortcut），这种文件只是对真实文件的一种引用而已。其他操作系统上也有类似的概念，例如，软链接（soft link）等
最后，很多操作系统为了实现接口的统一性，将所有的 I/O 设备都抽象成了文件的概念，使用这一理念，最为知名的就是 Unix、Linux 操作系统 —— 万物皆文件
🎍Java 中操作文件 Java 中通过 java.io.File 类来对一个文件（包括目录）进行抽象的描述。
值得注意的是，有 File 对象，并不代表真实存在该文件
🚩File 概述 我们先来看看 File 类中的常见属性、构造方法和方法
📌属性 修饰符及类型属性说明static StringpathSeparator依赖于系统的路径分隔符，String 类型的表示static charpathSeparator依赖于系统的路径分隔符，char 类型的表示 📌构造方法 签名说明File(File parent, Stringchild)根据父目录 + 孩子文件路径，创建一个新的 File 实例File(String pathname)根据文件路径创建一个新的 File 实例，路径可以是绝对路径或者相对路径File(String parent, Stringchild)根据父目录 + 孩子文件路径，创建一个新的 File 实例，父目录用路径表示 📌方法 修饰符及返回值类型方法签名说明StringgetParent()返回 File 对象的父目录文件路径StringgetName()返回 FIle 对象的纯文件名称StringgetPath()返回 File 对象的文件路径StringgetAbsolutePath()返回 File 对象的绝对路径StringgetCanonicalPath()返回 File 对象的修饰过的绝对路径booleanexists()判断 File 对象描述的文件是否真实存在booleanisDirectory()判断 File 对象代表的文件是否是一个目录booleanisFile()判断 File 对象代表的文件是否是一个普通文件booleancreateNewFile()根据 File 对象，自动创建一个空文件。成功创建后返回 truebooleandelete()根据 File 对象，删除该文件。成功删除后返回 truevoiddeleteOnExit()根据 File 对象，标注文件将被删除，删除动作会到JVM 运行结束时才会进行String[]list()返回 File 对象代表的目录下的所有文件名File[]listFiles()返回 File 对象代表的目录下的所有文件，以 File 对象表示booleanmkdir()创建 File 对象代表的目录booleanmkdirs()创建 File 对象代表的目录，如果必要，会创建中间目录booleanrenameTo(Filedest)进行文件改名，也可以视为我们平时的剪切、粘贴操作booleancanRead()判断用户是否对文件有可读权限booleancanWrite()判断用户是否对文件有可写权限 🚩File使用实例代码演示 📌实例一 观察get系列的特点和差异
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e96d05f3dfc2fd8886baaf1af07e38a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc82b2fb933a8da1fcae9feede6c3986/" rel="bookmark">
			Tigger绕过激活锁/屏幕锁隐藏工具，支持登入iCloud有消息通知，支持iOS12.0-14.8.1。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		绕过激活锁工具Tigger可以用来帮助因为忘记自己的ID或者密码而导致iPhone/iPad无法激活的工具来绕过自己的iPhone/iPad。工具支持Windows和Mac。
工具支持的功能：
1.Hello界面两网/三网/无基带/乱码绕过，可以完美重启，支持iCloud登录、有消息通知。
2.Hello界面GSM两网iPhone7~X绕过，可以打电话、发短信、4G流量上网，完美重启、可以登入iCloud、有消息通知。仅支持12.0~14.5.1的系统版本。
3.屏幕锁/停用界面的机器完美绕过，可以接打电话、收发短信、4G流量上网，完美重启、可以登入iCloud、有消息通知。
4.新增支持ios16免越狱带有隐藏ID的MDM配置锁完美绕过。
软件需要注册设备序列号才能使用， 需要注册或者开户的联系本公众号作者。
工具下载地址：
https://cowtransfer.com/s/e9ea2634719e4d
奶牛快传口令：6w2e62
一.游戏机绕过教程：
1.用checkra1n越狱iPhone/iPad，并且连上WiFi。
2.打开绕过激活锁工具Tigger，待工具识别到设备点击完美游戏机(三/两网/无基带/乱码)工具提示解锁成功，手机会自动进入系统绕过完成。
二.屏幕锁/能进系统正常使用隐藏教程：
1.用checkra1n越狱iPhone/iPad。（用checkra1n0.11.0的版本）
2.越狱成功后软件点提取系统文件。
3.提取成功后点ios12-14抹除。
4.抹除成功后重新越狱点还原系统文件。
三.配置锁绕过教程：
iphone/ipad断网点远程配置锁绕过（全系列免越狱），绕过成功设备会重启，重启完正常激活设备进系统就可以了。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/571/">«</a>
	<span class="pagination__item pagination__item--current">572/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/573/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>