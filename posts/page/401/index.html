<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b99dbc16c817086d9fc7da7f344c5f5a/" rel="bookmark">
			java中计算两个Date日期相差的月份
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 在Java中使用Date对象，计算两个日期相差的月份
示例代码 import java.util.Calendar; import java.util.Date; public class DateUtils { public static int monthsBetween(Date startDate, Date endDate) { Calendar startCalendar = Calendar.getInstance(); startCalendar.setTime(startDate); Calendar endCalendar = Calendar.getInstance(); endCalendar.setTime(endDate); // 确保 startCalendar 的日期在 endCalendar 之前 if (startCalendar.after(endCalendar)) { Calendar temp = startCalendar; startCalendar = endCalendar; endCalendar = temp; } int months = endCalendar.get(Calendar.MONTH) - startCalendar.get(Calendar.MONTH); int years = endCalendar.get(Calendar.YEAR) - startCalendar.get(Calendar.YEAR); // 如果年份差不为0，则从月份差中减去（年份差 * 12） return months - years * 12; } public static void main(String[] args) { // 示例：计算两个日期之间的月份差 Date date1 = new Date(); // 当前日期 // 假设有一个日期，比如 2023-01-01 Date date2 = new Date(); // 需要替换为实际日期 int months = monthsBetween(date1, date2); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b99dbc16c817086d9fc7da7f344c5f5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e16b538247b6da2b0a08148b2fc7fb8d/" rel="bookmark">
			【机器学习技术系列】FM系列算法详解(FM、FFM、DeepFM)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 综述FM算法1. 逻辑回归2. 逻辑回归原理1. 线性回归（Liner Regression）与逻辑回归（Logistic Regression）2. 极大似然估计3. 逻辑回归模型推导4. 损失函数 （Loss Function）5. 梯度下降求解5. 总结6. QA 3 FM算法示例引入FM模型 FFM算法FFM模型训练注意事项 综述 CTR（click-through-rate）即点击通过率FM算法（Factorization Machines）即因子分解机，是CTR的重要模型之一，自2010年被提出后，得到了大规模的应该，也是美团和头条做推荐和CTR预估的方法之一。FFM算法（Field-aware Factorization Machine）即域分解机模型，是FM算法的升级版。DeepFM () FM算法 对因子分解机的理解需要对逻辑回归LR（logistic Rgeression） 和矩阵分解MF(Matrix Factorization)
1. 逻辑回归 下图显示了，在传统的推荐系统中，逻辑回归衍生出来经典的模型和算法，常见的因子分解机FM 以及升级版的FFM模型。Facebook提出的GBDT+LR组合的模型。阿里巴巴曾经主流的LS-PLM（MLR）。
机器学习算法中的监督学习分为两类：分类和回归。分类就是判断目标变量的所属类别，目标变量是离散值。而回归则是预测，目标变量是连续型的数值。
逻辑回归是在数据服从伯努利分布的假设下，通过极大似然的方法，运用梯度下降法来求解参数，从而达到将数据二分类的目的。
逻辑回归是分类的问题，其中回归体现在：通过模型预测得到结果在0-1之间的连续数值，代表可能性而不是概率。通过"可能性" 排序推荐给用户，或者给可能性设立一个阈值，判断用户 点击 或者 不点击，喜欢 或者 不喜欢。所以逻辑回归将 推荐问题转化成了CTR的问题。
逻辑回归是一种广义的线性回归分析模型，属于机器学习中的监督学习。推导过程与计算方法类似于回归的过程，实际上主要来解决二分类问题（也可以解决多分类问题）。通过给定n组数据（训练集）来训练模型，并在训练结束后对给定的一组或者多组数据进行分类。
2. 逻辑回归原理 1. 线性回归（Liner Regression）与逻辑回归（Logistic Regression） 线性回归，比如一元二次方程可以表示身高和体重的线性关系。身高和体重数据是连续的可以表示成一元二次方程。
如果我们的目标数据不是连续的，比如广告投入金额和用户是否购买的关系。购买则为1，不购买则为0，因此数据是离散的点。 这时候就不能用一元二次方程这种确定的线性关系拟合。
这个时候可以加一个限制，z(x) &gt; 0.5 输出1 z(x) &lt; 0.5 输出 0 。 这就相当于线性回归的基础上，套用了一个函数，使他能够具有分类的效果。这种函数是不连续的阶跃函数。
但是工程上求最大值需要函数式连续可导的，这样才可以无限接近于最优解。因此我们用Sigmoid函数来替代阶跃函数
函数公式如下：
其中y的值在 0-1之间，从拟合图中可以看出 横轴z 接近0的时候 y变的敏感（值变换快），z 远离0时，变得不敏感。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e16b538247b6da2b0a08148b2fc7fb8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bc81ef8fd03b413dbed63a44b8d7ce9/" rel="bookmark">
			Llama网络结构介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LLaMA现在已经是开源社区里炙手可热的模型了，但是原文中仅仅介绍了其和标准Transformer的差别，并没有一个全局的模型介绍。因此打算写篇文章，争取让读者不参考任何其他资料把LLaMA的模型搞懂。
结构 如图所示为LLaMA的示意图，由Attention和MLP层堆叠而成
LLaMA模型主要由Attention和MLP层堆叠而成，具有以下特点：
1、前置的RMSNorm：RMSNorm是一种归一化技术，用于稳定模型的训练过程，提高模型的收敛速度。
2、Q、K上的RoPE旋转式位置编码：位置编码用于捕捉序列中的位置信息，RoPE旋转式位置编码能够有效地处理长序列，提高模型的性能。
3、Causal mask：该机制保证每个位置只能看到前面的tokens，确保了模型的自回归性质。
4、使用了Group Query Attention：通过使用分组查询注意力（GQA），LLaMA能够在保持性能的同时，降低模型的计算复杂度，提高推理速度。
5、MLP表达式：down(up(x) * SILU(gate(x)))，其中down, up, gate都是线性层
LLaMA各个不同大小的结构设置如下表所示。其中最大的65B的LLaMA用了2048张80GB的A100，batch size为4百万，训练一次需要21天。
Group Query Attention(V2 only) 自回归模型生成回答时，需要前面生成的KV缓存起来，来加速计算。多头注意力机制(MHA)需要的缓存量很大，Multi-Query Attention指出多个头之间可以共享KV对。Group Query Attention没有像MQA一样极端，将query分组，组内共享KV，效果接近MHA，速度上与MQA可比较。p.s. 这个技术falcon已经用上了，当时falcon说自己用的是multi query attention，因为当group=1时，GQA和MQA是等价的。falcon支持设置不同的G。
RMSNorm 这是在BERT、GPT等模型中广泛使用的LayerNorm：
RMSNorm(root mean square)发现LayerNorm的中心偏移没什么用(减去均值等操作)。将其去掉之后，效果几乎不变，但是速度提升了40%。最终公式为：
注意除了没有减均值，加偏置以外，分母上求的RMS而不是方差。
LLaMA在 Attention Layer和MLP的输入上使用了RMSNorm，相比在输出上使用，训练会更加稳定。
SwiGLU LLaMA没有使用ReLU，而是使用了SwiGLU，有时也被称为SiLU。公式为：
，效果类似平滑版的ReLU：
RoPE LLaMA使用了Rotary Position Embedding。对于Q的第m个位置向量q，通过以下方法注入位置编码：
class LlamaRotaryEmbedding(torch.nn.Module): def __init__(self, dim, max_position_embeddings=2048, base=10000): super().__init__() theta = 1.0 / (base ** (torch.arange(0, dim, 2) / dim)) t = torch.arange(max_position_mbeddings) freqs = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bc81ef8fd03b413dbed63a44b8d7ce9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2c4cc7f9c41824949e28e20f72b9d4d/" rel="bookmark">
			AI测试干货！实例讲解AI自动生成测试用例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.引言
在软件开发过程中，测试用例的生成是至关重要的一步。测试用例是用于验证软件功能、性能和安全性的具体测试方法，是确保软件质量的关键手段。
随着人工智能（AI）技术的发展，基于AI的测试用例生成技术逐渐成为未来趋势。
1.1.测试用例的重要性
1.1.1.测试工作的基础
测试用例是测试工作的基础，是测试工程师执行测试的重要依据。
测试工程师需要根据测试用例的设计要求，执行测试用例，记录测试结果，并对测试结果进行分析和总结，为后续的修复工作和改进提供依据。
1.1.2.设计应全面、合理、可行
测试用例的设计应全面、合理、可行，尽可能覆盖软件的各个功能、接口、性能和安全等方面。
同时，测试用例的设计应该遵循一定的规范和标准，以确保测试工作的准确性和一致性。
此外，测试用例的设计还应该考虑到实际情况和用户需求，以确保测试结果的可靠性和有效性。
1.1.3.软件质量的关键保证
通过执行测试用例，可以验证软件的功能、性能和安全性等方面的表现，及时发现软件中的缺陷和错误并进行修复，从而确保软件的质量和可靠性。
1.2.传统测试用例生成方法的局限性
1.2.1.耗时耗力
传统测试用例生成方法通常需要人工编写和整理测试用例，这需要耗费大量的人力和时间。
在开发周期紧张的情况下，手工编写测试用例可能会影响测试进度和质量。
1.2.2.易出错，缺乏精度
人工编写测试用例容易出错，且缺乏准确性。测试工程师可能因为疏忽、理解偏差或经验不足等原因导致测试用例的设计不合理或遗漏重要测试点，从而影响测试效果。
1.2.3.缺乏灵活性
传统的手动测试用例生成方法通常需要事先定义测试场景和条件，无法灵活应对快速变化的需求。当需求变更或软件功能发生变化时，需要重新设计和编写测试用例，这会影响测试效率和质量。
1.2.4.历史数据利用率低
传统的手动测试用例生成方法通常仅基于当前测试数据和测试结果进行设计，无法充分利用历史数据和知识经验。
通过分析历史数据和知识经验，可以更好地了解软件的质量状况和趋势，从而制定更合理的测试策略和计划。
1.2.5.无法应对复杂应用
复杂系统和应用的功能和接口众多，人工测试用例生成方法难以全面覆盖各种场景和需求，同时复杂系统和应用还涉及到大量的数据和算法，人工测试用例生成方法难以准确模拟用户人工测试用例生成方法可能受到测试工程师的经验和知识水平的限制。
如果测试工程师经验不足或缺乏相关知识，可能无法发现软件中的潜在问题或遗漏重要测试点，导致测试效果不佳。
1.3.基于AI的测试用例生成方法的可能性
1.3.1.提高测试效率和质量
AI测试用例生成方法能够自动化地分析软件数据和历史测试结果，根据实际情况和用户需求生成符合要求的测试用例，从而减少了人工编写和整理测试用例的时间和人力成本，提高了测试效率和质量。
1.3.2.降低测试成本和风险
通过自动化的测试用例生成方法，可以减少对测试工程师的经验和知识水平的依赖，降低了测试成本和风险。
同时，这种方法也可以更好地应对需求变更和软件功能变化的情况，减少了重新设计和编写测试用例的需求。
1.3.3.应对复杂应用挑战
AI测试用例生成方法可以通过自动识别不同的用户群体和场景，全面覆盖复杂系统和应用的场景和需求。
复杂系统和应用通常涉及到不同的用户群体和场景，不同的用户群体和场景对软件的功能和性能有不同的需求和期望。
通过自动识别不同的用户群体和场景，AI测试用例生成方法可以生成针对不同用户群体的测试用例，从而更好地满足不同用户的需求，提高测试的覆盖率和准确性。
1.3.4.标准化和一致性
AI测试用例生成方法可以通过制定规范和标准，实现测试用例的标准化和一致性，从而提高了测试质量和可靠性。
1.3.5.知识积累和共享
AI测试用例生成方法可以自动分析历史数据和知识经验，实现测试知识的积累和共享，为后续的测试工作提供了更好的支持和参考。
2.AI生成测试用例的应用
在测试用例生成中，人工智能（AI）技术的应用已经取得了显著的进展。以下是一些关于AI在测试用例生成中的应用的主要方面：
2.1.利用大数据和机器学习分析测试数据
2.1.1.数据收集与准备
2.1.1.1.数据来源：
在进行测试数据分析前，首先需要深入了解不同测试阶段的数据，以获得全面的视角。以下是可能的数据来源：
测试执行结果：收集测试用例的执行结果，包括通过的用例、失败的用例以及执行时间等信息。这可通过测试执行工具、持续集成系统等来获取。
代码仓库的版本控制历史：分析代码仓库的变更历史，包括代码提交、分支合并等，以了解代码的演化过程。这有助于理解代码质量和稳定性。
缺陷报告：获取缺陷管理系统中的数据，包括缺陷的严重性、解决状态、影响范围等信息。这有助于发现测试覆盖的盲点和关键功能区域。
性能监测数据：收集应用程序的性能监测数据，包括响应时间、资源利用率等。这有助于识别性能瓶颈和优化测试用例。
用户反馈：考虑收集用户的反馈信息，包括用户报告的问题、需求变更等。这可以帮助测试团队关注用户关心的方面。
为了自动化数据收集，可以集成相关工具，例如：
版本控制系统集成：使用Git或其他版本控制工具，结合相关API，实现对代码仓库的实时监测和数据收集。
缺陷管理系统集成：将测试工具与缺陷管理系统（如Jira、Bugzilla）连接，以自动捕捉测试执行和缺陷信息。
性能监测工具集成：使用性能监测工具（如New Relic、AppDynamics），将性能数据集成到测试数据分析流程中。
2.1.1.2.数据清洗：
在数据收集后，数据清洗是确保分析准确性的关键步骤。
处理异常值：
在处理异常值时，我们采用统计学方法来检测和处理异常值，以确保它们不会影响后续分析的结果。例如，我们可以使用离群值检测算法来识别和处理异常值。
#使用离群值检测算法处理异常值
from sklearn.ensemble import IsolationForest
#初始化Isolation Forest模型
iso_forest=IsolationForest(contamination=0.1)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2c4cc7f9c41824949e28e20f72b9d4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2ef95fa34b48da80d40962d6e5003da/" rel="bookmark">
			springboot使用Mybatis中兼容多数据源的databaseId（databaseIdProvider）的简单使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有兼容多数据库的需求，原有数据库使用的mysql，现在需要同时兼容mysql和pgsql，后期可能会兼容更多。
mysql和pgsql很多语法和函数不同，所以有些sql需要写两份，于是在全网搜索如何在mapper中sql不通用的情况下兼容多数据库，中文网络下，能搜到的解决方案大概有两种：1.使用@DS注解的动态数据源；2.使用数据库厂商标识，即databaseIdProvider。第一种多用来同时连接多个数据源，且配置复杂，暂不考虑。第二种明显符合需求，只需要指定sql对应的数据库即可，不指定的即为通用sql。
常规方法 在全网搜索databaseIdProvider的使用方法，大概有两种：
1.在mybatis的xml中配置，大多数人都能搜到这个结果：
&lt;databaseIdProvider type="DB_VENDOR"&gt; &lt;property name="MySQL" value="mysql"/&gt; &lt;property name="Oracle" value="oracle" /&gt; &lt;/databaseIdProvider&gt; 然后在mapper中：
&lt;select id="selectStudent" databaseId="mysql"&gt; select * from student where name = #{name} limit 1 &lt;/select&gt; &lt;select id="selectStudent" databaseId="oracle"&gt; select * from student where name = #{name} and rownum &lt; 2 &lt;/select&gt; 2.创建mybatis的配置类：
import org.apache.ibatis.mapping.DatabaseIdProvider; import org.apache.ibatis.mapping.VendorDatabaseIdProvider; import org.apache.ibatis.session.SqlSessionFactory; import org.mybatis.spring.SqlSessionFactoryBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.core.io.support.PathMatchingResourcePatternResolver; import javax.sql.DataSource; import java.util.Properties; @Configuration public class MyBatisConfig { @Bean public DatabaseIdProvider databaseIdProvider() { VendorDatabaseIdProvider provider = new VendorDatabaseIdProvider(); Properties props = new Properties(); props.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2ef95fa34b48da80d40962d6e5003da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dfeebce3c3a709f02d7595a52be89c0/" rel="bookmark">
			利用ollama和open-webui本地部署通义千问Qwen1.5-7B-Chat模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 安装ollama
2 安装open-webui
2.1 镜像下载
3 配置ollama的模型转换工具环境
3.1 下载ollama源码
3.2 下载ollama子模块
3.3 创建ollama虚拟环境
3.4 安装依赖
3.5 编译量化工具
7 创建ollama模型
8 运行模型
参考文献：
1 安装ollama curl -fsSL https://ollama.com/install.sh | sh 启动、关闭ollama
systemctl start ollama
systemctl stop ollama
systemctl restart ollama
systemctl status ollama
2 安装open-webui git clone https://github.com/open-webui/open-webui.git cd open-webui 这里open-webui的源码其实用不到，直接用下面的镜像就行。 2.1 镜像下载 官方没有在 docker hub 上发布镜像，而是发布在 ghcr.io，地址在 https://Github.com/open-webui/open-webui/pkgs/container/open-webui
docker pull ghcr.io/open-webui/open-webui:main 如果没有科学上网，很可能会拉不动，可以试试 docker 代理网站：https://dockerproxy.com/，但是会多几个步骤
# 如果拉不动的话加个代理 docker pull ghcr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dfeebce3c3a709f02d7595a52be89c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9905c62c7f5a439920b8b6e85e9bf061/" rel="bookmark">
			Flink学习（八）-Flink 集群搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，准备三台机器 装好 jdk 等必要的组件。
注意，由于本身没有额外的 dns做转发。因此，需要在每台机器的 host 文件里，配置好相关 ip
具体方法
vim /etc/hosts 2，flink做配置 2.1 资源规划 节点服务器
node01
node02
node03
角色
JobManager
TaskManager
TaskManager
TaskManager
2.2 下载 flink-1.19.0-bin-scala_2.12.tgz的包，并上传解压 下载地址
解压命令
tar xzvf flink-1.19.0-bin-scala_2.12.tgz 2.3 编辑相关配置信息 分别在 node01 、 node02以及 node03上
cd flink-1.19.0/conf vim config.yaml # JobManager节点地址.
jobmanager.rpc.address: node01
jobmanager.bind-host: 0.0.0.0
rest.address: node01
rest.bind-address: 0.0.0.0
# TaskManager节点地址.需要配置为当前机器名
taskmanager.bind-host: 0.0.0.0
taskmanager.host: node01
vim workers node01
node02
node03 vim masters node01:8081
注意，在 node02 和 node03节点上，只需要编辑对应的 config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9905c62c7f5a439920b8b6e85e9bf061/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac5ef8d46c5d78d110e152bac361af88/" rel="bookmark">
			下载及安装PHP，composer，phpstudy,thinkPHP6.0框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 目录
文章目录
前言
一、下载PHP
二、下载composer
三、下载PHPstudy
四、下载think PHP
1.下载
2.多应用开发
前言 thinkPHP是一款开源的PHP框架，它是基于MVC（Model-View-Controller）设计模式构建的。thinkPHP提供了丰富的功能和组件，使得开发人员可以快速、高效地构建和维护Web应用程序。
以下是thinkPHP框架的一些特点和功能：
1.简单易用：thinkPHP提供了简洁的语法和易于理解的代码结构，使得开发人员可以迅速上手并快速开发应用程序。
2.灵活性：框架提供了丰富的扩展功能，可以轻松地集成第三方库和组件。同时，它也支持自定义配置和路由规则，使得开发人员能够根据自己的需求进行灵活的配置和定制。
3.性能优化：thinkPHP采用了多种性能优化技术，如缓存机制、代码自动加载、数据库连接池等，以提高应用程序的性能和响应速度。
4.安全性：框架内置了丰富的安全特性，如数据过滤、防止SQL注入、防止XSS攻击等，以确保应用程序的安全性和数据的完整性。
5.丰富的文档和社区支持：thinkPHP拥有详细的官方文档和活跃的开发社区，开发人员可以方便地查阅文档和获取技术支持。
总的来说，thinkPHP框架简化了PHP应用程序的开发过程，提高了开发效率和代码质量，是一个非常流行和成熟的PHP框架。
一、下载PHP 下载地址
ziaxPHP: Hypertext Preprocessorhttps://www.php.net/按照图片步骤操作
下载好后解压到你所想存放的磁盘，然后打开我的电脑右键属性进入点击高级系统设置，找到path点击编辑，然后添加文件地址，最后win+r回车后输入php -v,如果出现所安装的PHP版本则安装成功，安装步骤如下图
二、下载composer Composer是一个PHP的依赖管理工具，可以用于管理项目中的PHP库和包的依赖关系。它可以帮助开发人员轻松地安装、更新和卸载项目所需的各种依赖库。Composer还可以自动解决依赖冲突问题，并且可以根据项目需要自动加载所需的库文件。使用Composer可以更好地组织和管理PHP项目的代码和依赖关系。
下载网ComposerA Dependency Manager for PHPhttps://getcomposer.org/
下载步骤如下
下载完成之后双击安装程序进行安装
选择你所下载的PHP文件中PHP.exe文件
随后继续点下一步完成安装即可。
三、下载PHPstudy 网址：小皮面板(phpstudy) - 让天下没有难配的服务器环境！
这个安装较为简单就不演示了，就是下载之后一直点下一步安装即可
四、下载think PHP 1.下载 地址：
基础 · ThinkPHP6.0完全开发手册 · 看云
点击进入选择基础--》安装--》找到安装基础版复制里面的代码，然后win+r回车输入磁盘名进入你安装PHPstudy的磁盘,进入然后输入cd phpstudy/www回车之后粘贴刚才的代码回车进行安装
回车即可安装，安装完后命令行窗口先不要关闭，需要下载开发需要的一些东西
2.多应用开发 进入所安装的tp文件夹下，
然后回到官网按照下面步骤进行操作
最后回车运行即可
随后还需安装模板引擎
回到tp6官网依次点击以下操作
如何在命令行中再次粘贴回车安装到tp文件夹中
然后打开PHP study点击启动
随后在浏览器中输入localhost/tp/public然后回车如果显示如下图即安装成功
如果有小伙伴在安装途中出现问题欢迎向我提问
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e6542fffe887c8ff50d91edb13e448b/" rel="bookmark">
			换脸插件升级导致SDWebUI无法启动cannot import name ‘Undefined‘ from ‘pydantic.fields‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在一台新的机器环境装了SDWEBUI，都使用最新的版本，升级了下换脸的插件，于是乎启动崩溃了。错误如下
Launching Web UI with arguments: --listen --skip-torch-cuda-test --disable-nan-check --skip-version-check --skip-python-version-check --enable-insecure-extension-access --api --xformers --xformers-flash-attention --opt-sdp-attention --no-half-vae --ad-no-huggingface --theme=dark --lora-dir /mnt/e/sddata/Lora --vae-dir /mnt/e/sddata/VAE --ckpt-dir /mnt/e/sddata/checkpoint --controlnet-dir /mnt/e/sddata/ControlNet --embeddings-dir /mnt/e/sddata/embeddings --controlnet-annotator-models-path /mnt/e/sddata/downloads Traceback (most recent call last): File "/mnt/e/sd-webui-aki-v4.7/launch.py", line 48, in &lt;module&gt; main() File "/mnt/e/sd-webui-aki-v4.7/launch.py", line 44, in main start() File "/mnt/e/sd-webui-aki-v4.7/modules/launch_utils.py", line 465, in start import webui File "/mnt/e/sd-webui-aki-v4.7/webui.py", line 13, in &lt;module&gt; initialize.imports() File "/mnt/e/sd-webui-aki-v4.7/modules/initialize.py", line 23, in imports import gradio # noqa: F401 ^^^^^^^^^^^^^ File "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e6542fffe887c8ff50d91edb13e448b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68a4790105f4bbac2f2646c5c5c6eb40/" rel="bookmark">
			【MySQL 所遇问题】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【MySQL 所遇问题】 总结：Error Code: 1064.You have an error in your SQL syntax报错解释1：报错解释2处理过程 Error Code：1366 - Incorrect string value:报错解释处理过程 总结： Error Code: 1064
不可见字符。 某些文本处理软件可能会添加不可见的字符，从这些软件中复制过来的代码可能因此出现问题。 解决方案：尝试在纯文本编辑器（如 Notepad++ 或 Sublime Text）中 重新键入 SQL 语句，而不是复制粘贴。 MySQL各版本服务器的语法区别。 Error Code: 1366
字符集不匹配。 解决方案：修改数据库、表的字符集；配置文件恢复默认。 Error Code: 1064.You have an error in your SQL syntax 报错解释1： Error Code: 1064. You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '﻿/* Navicat MySQL Data Transfer Source Server : 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68a4790105f4bbac2f2646c5c5c6eb40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c6e15c649bc932f9a3b61ba0bc108d0/" rel="bookmark">
			python模拟操作edge浏览器，完成问题的采集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天是自动化操作的第一步，是基础。
1、添加按钮，启动edge浏览器。 要在Python中添加一个打开Edge浏览器的按钮，并安装Edge浏览器模块，你可以使用Selenium库。以下是详细的步骤：
安装Selenium库 首先，你需要安装Selenium库，如果尚未安装的话。你可以使用pip来安装它：
pip install selenium 安装Edge浏览器驱动 为了使用Selenium控制Edge浏览器，你需要下载并安装Edge浏览器的驱动程序。你可以从Microsoft Edge开发者网站下载对应的驱动程序，并将其放在Python的安装目录下，通常是在Scripts文件夹中。确保下载的驱动程序与你当前Edge浏览器的版本相匹配。
安装Edge浏览器驱动的详细步骤
1. 确认Edge浏览器版本
首先，你需要知道你的Edge浏览器的版本。可以通过Edge浏览器的设置菜单查看。在Edge浏览器中，点击右上角的齿轮图标，选择“关于Microsoft Edge”，就可以查看到当前的版本号。
2. 下载Edge浏览器驱动
接着，你需要下载与你的Edge浏览器版本相对应的驱动程序。你可以访问Microsoft Edge开发者网站（Microsoft Edge WebDriver | Microsoft Edge Developer）下载对应的驱动程序。在网站上，你可以根据你的浏览器版本选择相应的驱动程序压缩包进行下载。
3. 解压并放置驱动程序
下载完成后，解压驱动程序压缩包，并将`msedgedriver.exe`文件复制到Python解释器的目录下，通常是`Scripts`文件夹中。如果你在Windows系统上，也可以将其放在`PATH`环境变量的目录下，这样Selenium就能自动识别并使用了。
4. 验证驱动程序是否成功安装
最后，你可以通过运行一段简单的Python代码来验证Edge浏览器驱动程序是否成功安装。以下是一段示例代码：
from selenium import webdriver # 初始化Edge浏览器驱动 driver = webdriver.Edge() # 打开网页 driver.get("https://www.example.com") # 替换为你想要打开的URL 如果驱动程序安装成功，当你运行这段代码时，Edge浏览器将会启动并打开指定的网页。否则，你会遇到错误信息，可能是因为驱动程序的路径不正确或者驱动程序与浏览器版本不匹配。
请注意，以上步骤是基于Windows系统的。如果你在其他操作系统上安装Edge浏览器驱动，步骤可能会有所不同。此外，由于Edge浏览器可能会更新其驱动程序的路径，你可能需要根据你的操作系统和Edge版本调整代码中的路径。
2编写代码 接下来，你需要编写Python脚本来创建一个图形界面，并添加一个按钮来打开Edge浏览器。这里提供一个简单的示例代码：
import tkinter as tk from tkinter import messagebox from selenium import webdriver # 创建窗口 window = tk.Tk() window.title("Open Edge Browser"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c6e15c649bc932f9a3b61ba0bc108d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8473f38c072bf0538f755da250c58bd/" rel="bookmark">
			【圆桌论坛】个人作为嘉宾参与问答环节的总结，Create 2024百度AI开发者大会之AI智能体开发与应用论坛
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 ⭐前言⭐讨论话题✨本质和价值✨端侧部署✨应用商业模式✨商业模式 ⭐主题总结⭐有趣分享 ⭐前言 首先，非常荣幸和开心作为开发者和创业者代表参加百度Create AI大会分论坛圆桌论坛的问答环节。
在分论坛活动开始前，参加了文心智能体平台（之前叫灵镜矩阵）的首届智能体创意大赛，
很幸运获得了第一期的Top 5，也深深体会到《人人都可以是智能体的开发者》，只要你有创意就能被看见。
Create 2024百度AI开发者大会，主论坛大佬们给我们分享了很多AI相关的知识，演讲非常精彩，内容也非常吸引人，干货满满，对于博主而言也是增长了不少见识，开阔了视野。AI和我们的生活和工作越来越近，甚至已经能够深深感受到AI他们是无所不在，正如我们感受到的，AI和大模型正在重构和改变着千行百业。自动驾驶、智能机器人、智能客服等等都会更加成熟和完善。
本论坛汇聚大语言模型智能体顶尖智慧，探讨AI技术助力普通人创造、激发探索、推动行业应用等前沿话题，期待与各领域杰出伙伴，共创AI智能体未来新篇章。
本次圆桌论坛，主要讨论三个方向，分别是智能体的定义、智能体的技术、以及智能体的应用和商业模式。
⭐讨论话题 ✨本质和价值 ❤️圆桌论坛讨论的第一个问题：关于智能体的本质和它的价值？
智能体的本质和定义是什么？我们摒弃掉教科书上的定义，⽐如环境感知、从数据中学习、推理决策这些名词，⼤家有哪些新的的⻆度。（这里小伙伴们也可以在评论区留下您的看法，简单展开来说说）
博主结合相关知识点，整理如下大概本质分析：
持续进化，自我成长，对环境感知的越多，提供学习数据的越多，推理能力越来越强，那么TA的效果就越明显越准确，
比如：自动驾驶汽车、智能家居系统、医疗诊断系统、金融投资决策系统
总之，未来智能体非常值得期待和更多落地场景，提高我们的工作和生活水平
1-智能体本质和价值
前面几位老师对智能体从不同角度进行了阐述，讲得非常详细也讲的非常好，我这边主要从两点进行简单讲述，创新和降本增效。
❤️圆桌论坛讨论的第一个问题补充问题：目前还没有太多成熟智能体的原因？
同时主持人也提到了市面上其实并没有太多成熟的智能体，这个是什么原因呢
当时漏了回答原因这点，现在总结回想，以及和朋友讨论到智能体市场时，大概也能整理出一些原因，
比如，朋友他们大多担心的是，智能体回答输出内容的准确性和稳定性问题，其实就是对智能体信任的问题。
尽管和他们说，这个是完全可以通过限定智能体输出的内容，但是他们依然是存在担心的，我觉得这个需要点时间和适应过程。
❤️圆桌论坛讨论的第二个问题：智能体是不是伪命题？
这个当时在现场也是比较简洁的作了回答，博主认为智能体本身能够带来一些价值以及解决一些实际问题。
比如：智能体落地能够帮助我们在客服领域解决重复回答得问题，这样能够减少重复回答的时间成本，从而提升效率，留出宝贵时间做更多提升自己的事情。
总结：尽管线下演讲过很多，但是类似本次圆桌论坛，特别是有一定知名度以及现场直播类的博主还是第一次参加，多少会有点紧张，所以，第一个问答，现场以及小伙伴会觉得有点不连贯。同时现场此类问答大多数也是临场发挥，也是靠平时的积累和实际经验来回答。对于临场发挥，博主对自己评价还是有待提高，以及专业度和相关知识点再多接触多理解多巩固。
✨端侧部署 圆桌论坛讨论的第三个问题：智能体在端侧部署，应该重点考虑那些问题？
斯坦福⼤学研究⼈员推出了 Octopus v2 ，20 亿参数的模型可以在智能⼿机、汽⻋、个⼈电脑等端侧运⾏，在准确性和延迟⽅⾯超越了 GPT-4，并将上下⽂⻓度减少了 95%。此外，Octopus v2 ⽐ Llama7B + RAG ⽅案快 36 倍。这项研究降低了在移动设备上开发和部署智能Agent应⽤的技术⻔槛，也为Agent应⽤的商业化提供了新的思路。
2-智能体端侧部署
❤️1、端侧方向
那么端侧AI是不是智能体应该重要考虑的⼀个⽅向？
基于上面这个问题，应该要重点考虑的一个方向，原因如下：
实时性：端侧AI则能够将计算和分析任务直接放在设备端进行，减少了数据传输和处理的延迟，使得智能体能够更快地做出决策和响应。
降低成本：云端AI需要依赖强大的服务器和数据中心来支持，而端侧AI则能够利用设备自身的计算能力，减少了对外部资源的依赖，从而降低了运行成本
安全和隐私：端侧AI则能够在本地进行数据处理和分析，减少了数据泄露的风险，提高了用户隐私的保护水平。
❤️2、端云结合
有位老师提到的一点，我觉得非常不错，他说未来肯定是端云结合，特定功能的小模型
万卡集群训练，减少无效模型训练，入门级大模型训练都要一百多万元，小白就不太建议去做，这个就交给专家做，毕竟专业的事情交给专业的人去做，我们只需要去用就行，在大模型之上的应用进行创新等
✨应用商业模式 圆桌论坛讨论的第四个问题：智能体的应用与商业模式？
基于各⾃熟悉领域的场景及需求，谈⼀下对智能体有哪些期待
对于我来说，本次问答就是从部署和使用智能体过程中遇到的问题和效果如何，有没有一个盈利方向？
3-智能体应用
❤️1、智能体应用
博主这一次算是二次创业，大模型之上的应用落地，比如智能体就可以给我们创业者提供了一次很好的机会。我们不需要考虑太多大模型底层技术的问题，我们只需要使用它，本次论坛也提到了，最简单大模型训练也得上百万，小白就不要去尝试了。
博主也可以分享一个实际案例，博主已经有一个盈利的图片类应用，并且集成了智能体图片功能，因为智能体生成的图片效果也非常不错，能够给我的图片类应用增加一些亮点的功能，从而提高用户的留存率和支付率。
比如，下面就是博主创建图片类相关的智能体，生成的效果也是非常不错：
4-智能体部署遇到问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8473f38c072bf0538f755da250c58bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0557f91766ae62c051f2cd51477abd1/" rel="bookmark">
			python import 自己写的py文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Python 中导入自己编写的 .py 文件，遵循以下基本原则：
1. 确保文件结构与导入路径：
将您编写的 Python 模块（.py 文件）放在合适的目录结构中。确保待导入的模块与当前执行文件（主程序）位于同一目录，或者位于已知的目录（如在 sys.path 中的目录）内，或者它们之间的关系可以通过相对导入来表达。 2. 使用标准导入语句：
使用 import 语句来导入模块。如果模块名与文件名相同（不包括扩展名），可以直接使用模块名。例如，如果您有一个名为 my_module.py 的文件，导入时使用： python
import my_module 如果模块位于某个子目录中，需要按照目录结构进行导入。例如，有一个目录结构如下： project/ main.py modules/ my_module.py 在 `main.py` 中导入 `my_module.py`：
python
import modules.my_module 如果需要导入模块中的某个特定对象（如函数、类或变量），可以使用 from ... import ... 语句。例如，假设 my_module.py 中有一个名为 my_function 的函数： python
from modules.my_module import my_function 3. 处理相对导入：
如果模块间存在嵌套关系，可以使用相对导入。例如： project/ package/ __init__.py subpackage/ __init__.py module_a.py module_b.py 在 `module_b.py` 中导入 `subpackage/module_a.py` 中的 `foo` 函数：
from .subpackage.module_a import foo 注意，使用相对导入时，当前模块必须是一个包的一部分（即在其目录下有 __init__.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0557f91766ae62c051f2cd51477abd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0be9900586a2c9605259053893ea041/" rel="bookmark">
			【C&#43;&#43;】一篇文章带你深入了解list
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、list的介绍二、 标准库中的list类2.1 list的常见接口说明2.1.1 list对象的常见构造2.1.1.1 [无参构造函数](https://legacy.cplusplus.com/reference/list/list/list/)2.1.1.2 [有参构造函数(构造并初始化n个val)](https://legacy.cplusplus.com/reference/list/list/list/)2.1.1.3 [有参构造函数(使用迭代器进行初始化构造)](https://legacy.cplusplus.com/reference/list/list/list/)2.1.1.4 [拷贝构造函数](https://legacy.cplusplus.com/reference/list/list/list/) 2.1.2 list iterator的使用2.1.2.1 [begin()](https://legacy.cplusplus.com/reference/list/list/begin/) + [end()](https://legacy.cplusplus.com/reference/list/list/end/)2.1.2.2 [rbegin()](https://legacy.cplusplus.com/reference/list/list/rbegin/) + [rend()](https://legacy.cplusplus.com/reference/list/list/rend/) 2.1.3 list对象的容量操作2.1.3.1 [empty()函数](https://legacy.cplusplus.com/reference/list/list/empty/)2.1.3.2 [size()函数](https://legacy.cplusplus.com/reference/list/list/size/) 2.1.4 list对象的增删查改及访问2.1.4.1 [push_front()函数](https://legacy.cplusplus.com/reference/list/list/push_front/)2.1.4.2 [pop_front()函数](https://legacy.cplusplus.com/reference/list/list/pop_front/)2.1.4.3 [push_back()函数](https://legacy.cplusplus.com/reference/list/list/push_back/)2.1.4.4 [pop_back()函数](https://legacy.cplusplus.com/reference/list/list/pop_back/)2.1.4.5 [insert()函数](https://legacy.cplusplus.com/reference/list/list/insert/)2.1.4.6 [erase()函数](https://legacy.cplusplus.com/reference/list/list/erase/)2.1.4.7 [swap()函数](https://legacy.cplusplus.com/reference/list/list/swap/)2.1.4.8 [clear()函数](https://legacy.cplusplus.com/reference/list/list/clear/)2.1.4.9 [front()函数](https://legacy.cplusplus.com/reference/list/list/front/) + [back()函数](https://legacy.cplusplus.com/reference/list/list/back/) 2.1.5 list的迭代器失效 三、list的模拟实现3.1 list 节点类的实现3.2 list 中默认成员函数的实现3.3 list 中 size、empty 和 swap 函数的实现3.4 list 中 迭代器类 的实现3.5 list 中 迭代器 、 范围构造函数 和 clear 函数 的实现3.6 list 中 insert 和 erase 的实现3.7 list 中 push_back、pop_back、push_front 和 pop_front 函数的实现3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0be9900586a2c9605259053893ea041/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1fd4bb4ecfbc63b3b726fcd1e220fb7/" rel="bookmark">
			小游戏贪吃蛇的实现之C语言版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找往期文章包括但不限于本期文章中不懂的知识点：
个人主页：我要学编程(ಥ_ಥ)-CSDN博客
所属专栏：C语言
游戏演示：
贪吃蛇游戏演示
目录
游戏前期准备：
设置控制台相关的信息 GetStdHandle
GetConsoleCursorInfo SetConsoleCursorInfo
SetConsoleCursorPosition
GetAsyncKeyState
贪吃蛇游戏设计与分析 本地化
地图，食物和蛇身的设计 GameStart（）—— 游戏的初始化
打印欢迎界面 绘制贪吃蛇地图 初始化贪吃蛇
初始化食物
GameRun（）——游戏的运行
打印右侧的帮助信息
贪吃蛇的相关运行信息 GameOver（）——游戏的结束（善后工作） 贪吃蛇源码 使用C语言在Windows环境的控制台中模拟实现经典小游戏贪吃蛇。
游戏前期准备： 本次实现贪吃蛇会使用到的一些Win32 API知识，接下来我们就学习一下。
背景介绍：
Windows 这个多作业系统除了协调应用程序的执行、分配内存、管理资源之外， 它同时也是一个很大的服务中心，调用这个服务中心的各种服务（每一种服务就是一个函数），可以帮应用程序达到开启视窗、描绘图形、使用周边设备等目的，由于这些函数服务的对象是应用程序(Application)， 所以便称之为 Application Programming Interface，简称 API 函数。WIN32 API也就是Microsoft Windows 32位平台的应用程序编程接口。
设置控制台相关的信息 平常我们运行起来的黑框程序其实就是控制台程序（如下图所示）。
我们可以使用cmd命令来设置控制台窗口的长宽。例如：设置控制台窗口的大小，30行，100列。 //格式： 列 行 mode con cols=100 lines=30 注意：
1. 列和行在赋值时，不能带有空格。例如：cols = 100，这就是不行的，没有影响到控制台的大小。
2. 使用这个命令之前，需要把这个控制台改为让Windows决定或者Windows 控制台主机
演示：
改变VS编译器的控制台
3. 使用system函数所需要包含的头文件既可以是stdlib.h，也可以是Windows.h(不分大小写的，因此可以使用"windows.h"、"WINDOWS.H"或者"Windows.h"等形式来引用该头文件。不过，一般约定使用"Windows.h"的形式来引用该头文件，以保持代码的一致性和可读性。) 下面就来使用这个来改变控制台的大小。
从上面的结果来看：行列对应不一致。没错，一行的宽度是一列的宽度的二倍。
也可以通过命令设置控制台窗口的名字： //格式： title 要修改的名字 注意：在更改之后要观察到的话，就不能让程序运行结束，也就是说只能在程序运行期间才能够观察的到。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1fd4bb4ecfbc63b3b726fcd1e220fb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65e0b010e28080537d28d858dd5ebef0/" rel="bookmark">
			JavaScript中的map()方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. map() 的返回值是一个新的数组，新数组中的元素为 “原数组调用函数处理过后的值” 2. 简单使用：遍历整个数组，将大于4的元素乘以2 const array = [2, 3, 4, 4, 5, 6] console.log("array",array) const map = array.map(x =&gt; { if (x == 4) { return x * 2 } return x }) console.log("map",map) 输出的结果为：等于4的元素乘以2
3. map()函数的参数详解 一般参数是一个回调函数 array.map((item,index,arr)=&gt;{ //item是操作的当前元素 //index是操作元素的下表 //arr是需要被操作的元素 //具体需要哪些参数 就传入那个 }) const array = [2, 3, 4, 4, 5, 6] console.log("原数组array为",array) const map2=array.map((item,index,arr)=&gt;{ console.log("操作的当前元素",item) console.log("当前元素下标",index) console.log("被操作的元素",arr) //对元素乘以2 return item*2 }) console.log("处理之后先产生的数组map",map2) 输出的结果为：
4. 总结：map()方法经常拿来遍历数组，但是不改变原数组，但是会返回一个新的数组； 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65e0b010e28080537d28d858dd5ebef0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5016c9c35278f4757275233a3cd7fa43/" rel="bookmark">
			SpringBoot3 实现webclient 通用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： Spring Boot WebClient 是 Spring Framework 5 中引入的一个新的响应式 Web 客户端，用于异步和响应式地与外部服务进行通信。它是基于 Project Reactor 的响应式编程模型构建的，提供了比传统的 RestTemplate 更现代和强大的功能
介绍： 响应式编程模型：WebClient 是基于响应式编程模型的，这意味着它可以非阻塞地执行网络请求，并且能够与流式数据交互。这使得 WebClient 在处理大量并发请求时具有更高的性能和可伸缩性。
异步操作：WebClient 支持异步操作，这意味着它可以在等待网络响应的同时继续执行其他任务。这有助于提高应用程序的响应能力和吞吐量。
强大的 API：WebClient 提供了一个简洁而强大的 API，用于构建 HTTP 请求和接收响应。它支持多种 HTTP 方法（如 GET、POST、PUT、DELETE 等），并提供了丰富的功能来处理请求头、请求体、响应体等。
流式处理：WebClient 支持流式处理响应数据，这意味着它可以在接收响应数据的同时进行处理，而不需要将整个响应加载到内存中。这有助于处理大型响应数据，并减少内存使用。
错误处理：WebClient 提供了强大的错误处理机制，可以方便地处理网络请求中出现的错误和异常情况。它支持自定义错误处理器，可以根据需要定义错误处理逻辑。
集成性：WebClient 可以轻松地与 Spring Boot 的其他组件集成，如 Spring Data、Spring Security 等。这使得在构建基于微服务的响应式应用程序时更加方便和灵活。
替代 RestTemplate：虽然 RestTemplate 在以前的 Spring 版本中广泛使用，但 WebClient 被视为其现代替代品。WebClient 提供了更强大和灵活的功能，并且更适合与响应式编程模型一起使用
一、引包 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5016c9c35278f4757275233a3cd7fa43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/099ba5096bba8b06b65a5a581d5d7247/" rel="bookmark">
			【前端缓存】localStorage是同步还是异步的？为什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在开头 点赞 + 收藏 === 学会
首先明确一点，localStorage是同步的
一、首先为什么会有这样的问题 localStorage 是 Web Storage API 的一部分，它提供了一种存储键值对的机制。localStorage 的数据是持久存储在用户的硬盘上的，而不是内存。这意味着即使用户关闭浏览器或电脑，localStorage 中的数据也不会丢失，除非主动清除浏览器缓存或者使用代码删除。
当你通过 JavaScript 访问 localStorage 时，浏览器会从硬盘中读取数据或向硬盘写入数据。然而，在读写操作期间，数据可能会被暂时存放在内存中，以提高处理速度。但主要的特点是它的持久性，以及它不依赖于会话的持续性。
二、硬盘不是io设备吗？io读取不都是异步的吗？ 是的，硬盘确实是一个 IO 设备，而大部分与硬盘相关的操作系统级IO操作确实是异步进行的，以避免阻塞进程。不过，在 Web 浏览器环境中，localStorage 的API是设计为同步的，即使底层的硬盘读写操作有着IO的特性。
js代码在访问 localStorage 时，浏览器提供的API接口通常会处于js执行线程上下文中直接调用。这意味着尽管硬盘是IO设备，当一个js执行流程访问 localStorage 时，它将同步地等待数据读取或写入完成，该过程中js执行线程会阻塞。
这种同步API设计意味着开发者在操作 localStorage 时不需要考虑回调函数或者Promise等异步处理模式，可以按照同步代码的方式来编写。不过，这也意味着如果涉及较多数据的读写操作时，可能对性能产生负面影响，特别是在主线程上，因为它会阻塞UI的更新和其他js的执行。
三、完整操作流程 localStorage 实现同步存储的方式就是阻塞 JavaScript 的执行，直到数据的读取或者写入操作完成。这种同步操作的实现可以简单概述如下：
js线程调用: 当 JavaScript 代码执行一个 localStorage 的操作，比如 localStorage.getItem('key') 或 localStorage.setItem('key', 'value')，这个调用发生在 js 的单个线程上。浏览器引擎处理: 浏览器的 js 引擎接收到调用请求后，会向浏览器的存储子系统发出同步IO请求。此时 js 引擎等待IO操作的完成。文件系统的同步IO: 浏览器存储子系统对硬盘执行实际的存储或检索操作。尽管操作系统层面可能对文件访问进行缓存或优化，但从浏览器的角度看，它会进行一个同步的文件系统操作，直到这个操作返回结果。操作完成返回: 一旦IO操作完成，数据要么被写入硬盘，要么被从硬盘读取出来，浏览器存储子系统会将结果返回给 js 引擎。JavaScript线程继续执行: js 引擎在接收到操作完成的信号后，才会继续执行下一条 js 代码。 在同步的 localStorage 操作期间，由于 js 的单线程性质，整个线程会阻塞，即不会执行其他任何js代码，也不会进行任何渲染操作，直到 localStorage 调用返回。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/099ba5096bba8b06b65a5a581d5d7247/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bed33520b6fbff8b24f99eecec52df4c/" rel="bookmark">
			智能优化算法的原理分类，为什么要用最新的算法？为什么要掌握多种算法？（附2023/2024最新智能优化算法合集matlab代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		所有链接建议使用电脑端打开，手机端打开较慢 专题推荐：论文推荐，代码分享，典藏级代码，视角（点击即可跳转）
【代码推荐购买指南】电力系统运行优化与规划、时间序列预测、回归分类预测matlab代码
高创新组合模型（优化和预测方向）典藏级matlab代码，倾情推送24.4.21
公众号历史推文合集24.4.20（预测和优化方向matlab代码/电力系统前沿视角/电力系统优秀论文推荐
近两年最新智能优化算法，高创新，可融合预测和优化模型，小论文不愁了！（附matlab代码实现）
2024-04-11
现在研究基于“智能优化算法”的电力系统优化运行、规划和预测方法还能不能发小论文？
2024-03-20
【代码分享】高新颖性多目标智能优化算法matlab实现
2024-03-11
群智能优化算法和模态分解算法在基于深度学习模型时间序列预测中的运用（matlab代码实现）
2024-03-10
【代码分享】高创新性改进智能优化算法！基于黄金正弦和混沌映射思想的改进减法优化器算法matlab实现
2024-03-07
【代码分享】水论文神器！最新智能优化算法推荐与matlab代码实现
2024-03-05
智能优化算法的原理主要是从自然界或人工系统中汲取灵感，通过模仿这些系统中的优化机制来设计算法，以解决复杂的优化问题。这些算法通常不依赖于梯度信息，而是采用直接搜索或随机搜索策略，在解空间中寻找全局最优解或近似最优解。它们往往能够处理高维度、非线性、多模态及约束条件复杂的优化问题。智能优化算法的核心在于其搜索策略和群体互动机制，旨在通过迭代过程逐渐逼近最优解。
按照原理和策略，智能优化算法大致可以分为以下几类：
进化类算法：
遗传算法（Genetic Algorithm, GA）：受自然界遗传学和自然选择原理启发，通过模拟遗传过程中的交叉、变异和自然选择操作，对解进行编码并进化出更优解。
差分进化算法（Differential Evolution, DE）：利用种群中个体间的差分向量来引导搜索方向，实现解的进化。
免疫算法（Immune Algorithm, IA）：模拟生物免疫系统的工作机制，如免疫记忆、克隆选择等，用于识别和排除不良解，增强解的质量。
群智能算法：
粒子群优化算法（Particle Swarm Optimization, PSO）：模拟鸟群觅食行为，每个粒子代表一个潜在解，通过跟踪个体最优解和全局最优解来调整搜索方向。
蚁群算法（Ant Colony Optimization, ACO）：模仿蚂蚁寻找食物时的信息素留下与跟随机制，通过正反馈机制发现并加强好的路径。
蜂群算法（Bee Colony Optimization, BCO）或其他模拟蜜蜂采蜜行为的算法，利用蜜蜂的分工合作和舞蹈语言来搜索最优解。
模拟退火算法（Simulated Annealing, SA）：借鉴固体物理学中的退火过程，通过控制温度参数来平衡探索与利用，从而跳出局部最优，寻找全局最优解。
混沌优化算法：利用混沌系统的遍历性和随机性特点，引入混沌映射以增加算法的全局搜索能力。
禁忌搜索算法（Tabu Search, TS）：通过维护禁忌表来避免重复搜索同一区域，促进搜索向未被充分探索的解空间前进。
这些算法各有特点，适用于不同的问题场景，有些算法还可以结合使用，形成混合优化策略，以提高解决问题的效率和效果。
智能优化算法与预测算法的结合主要体现在以下几个方面：
参数优化
预测模型（如神经网络、支持向量机、时间序列分析模型等）通常包含多个可调参数（超参数），这些参数直接影响模型的预测性能。智能优化算法（如粒子群优化PSO、遗传算法GA、模拟退火SA等）可以用来自动寻找这些超参数的最佳组合。通过将预测模型的预测误差或某种评价指标（如均方误差、准确率等）作为优化目标函数，智能优化算法可以在参数空间中搜索，找到使预测性能最优的参数设置。
特征选择与权重优化
在复杂的数据集中，特征选择是一项关键任务，它直接影响模型的预测精度和计算效率。智能优化算法可以帮助确定哪些特征对预测最有价值，并可能为这些特征分配权重，进一步提升模型性能。通过优化特征子集或特征权重，可以减少噪音干扰，突出有用信息。
模型集成与组合优化
在某些情况下，不是单一模型而是模型的集成（如随机森林、梯度提升机等）能提供更好的预测能力。智能优化算法可以用于优化模型集成中的模型选择、权重分配以及决策融合策略，以达到更高的预测准确性和稳定性。
数据预处理
在预测前的数据预处理阶段，智能优化算法也可以发挥作用，比如在特征缩放、缺失值填充、异常值处理等方面，通过优化预处理参数，确保输入到预测模型的数据质量，进而提高预测效果。
实时优化与自适应调整
在需要持续更新预测模型的场景中，智能优化算法可以实现模型参数的在线调整或模型结构的自适应优化，使得模型能够更好地适应数据随时间的变化，保持预测的时效性和准确性。
综上所述，智能优化算法与预测算法的结合，不仅能够提升预测模型的性能，还能提高模型对实际问题的适应性和鲁棒性，广泛应用于工业控制、金融分析、资源调度、医疗健康等多个领域。
在撰写学术论文时倾向于使用最新的智能优化算法，原因主要有以下几点：
1.创新性与新颖性：科学研究强调创新，使用最新算法可以体现研究工作的前沿性和新颖性。这有助于提升论文的学术价值，吸引审稿人和读者的注意，因为它展示了作者对领域发展的紧跟和贡献。
2.性能提升：随着算法理论和技术的不断进步，新提出的智能优化算法往往在解决特定问题时相比旧有算法有所改进，如提高求解速度、增强鲁棒性、扩展应用范围等。采用最新算法可能带来更优的解决方案，提升问题解决的效率和精确度。
3.解决新问题的能力：面对新兴领域或复杂问题，传统的算法可能不再适用或效率低下。新的智能优化算法可能专门针对这些问题进行了设计，能够更好地应对挑战，如大规模数据处理、高度非线性问题、多目标优化等。
4.理论与方法的贡献：介绍和评估最新的智能优化算法，有助于推动算法理论的发展和完善。通过论文详细阐述新算法的原理、优势、适用场景及实验结果，可以为后续研究者提供参考和借鉴，促进整个领域的知识积累和技术进步。
5.满足期刊或会议要求：许多高质量的学术期刊和国际会议倾向于接收包含最新研究成果的文章，尤其是那些能够展示领域进展和突破的研究。使用最新的智能优化算法有助于符合这类出版物的高标准要求。
在撰写关于智能优化算法的学术论文时，采用多种智能优化算法进行对比分析是至关重要的，原因如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bed33520b6fbff8b24f99eecec52df4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87e988a9794557be209fc92dde53cebb/" rel="bookmark">
			Hbase Java编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.准备工作 首先创建一个Maven，选择 IDEA 所 关联的 Maven 配置文件（settings.xml）。
在pom.xml文件里面插入一段代码（改成自己的hbase版本）
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt; &lt;artifactId&gt;hbase-client&lt;/artifactId&gt; &lt;version&gt;2.4.11&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 添加配置文件 hbase-site.xml到resource里面
二.操作 建表
import org.apache.hadoop.conf.Configuration; import org.apache.hadoop.hbase.HBaseConfiguration; import org.apache.hadoop.hbase.TableName; import org.apache.hadoop.hbase.client.*; import org.apache.hadoop.hbase.util.Bytes; import java.io.IOException; public class createTbale { public static void main(String[] args) throws IOException { Configuration configuration = HBaseConfiguration.create(); configuration.set("hbase.zookeeper.quorum","192.168.56.8"); Connection connection = ConnectionFactory.createConnection(configuration); Admin admin = null; { try { connection = ConnectionFactory.createConnection(configuration); System.out.println(connection); admin = connection.getAdmin(); System.out.println(admin); TableName tableName = TableName.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87e988a9794557be209fc92dde53cebb/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/400/">«</a>
	<span class="pagination__item pagination__item--current">401/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/402/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>