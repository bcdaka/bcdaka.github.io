<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c51bcfde826a852cc40e4965246dac98/" rel="bookmark">
			[UTCTF2020]babymips
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		水一篇
32位
c++写的，长得比较丑陋
进入sub-401164函数
V7的数据可以得到
unsigned char ida_chars[] = { 0x62, 0x6C, 0x7F, 0x76, 0x7A, 0x7B, 0x66, 0x73, 0x76, 0x50, 0x52, 0x7D, 0x40, 0x54, 0x55, 0x79, 0x40, 0x49, 0x47, 0x4D, 0x74, 0x19, 0x7B, 0x6A, 0x42, 0x0A, 0x4F, 0x52, 0x7D, 0x69, 0x4F, 0x53, 0x0C, 0x64, 0x10, 0x0F, 0x1E, 0x4A, 0x67, 0x03, 0x7C, 0x67, 0x02, 0x6A, 0x31, 0x67, 0x61, 0x37, 0x7A, 0x62, 0x2C, 0x2C, 0x0F, 0x6E, 0x17, 0x00, 0x16, 0x0F, 0x16, 0x0A, 0x6D, 0x62, 0x73, 0x25, 0x39, 0x76, 0x2E, 0x1C, 0x63, 0x78, 0x2B, 0x74, 0x32, 0x16, 0x20, 0x22, 0x44, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4E }; 大概意思应该是异或那里相等
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c51bcfde826a852cc40e4965246dac98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d341fb26febe3d8cf3ad038ef092169c/" rel="bookmark">
			@google/model-viewer 导入 改纹理 （http-serve）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导入模型 改纹理
效果图
&lt;template&gt; &lt;div&gt; &lt;h1&gt;鞋模型&lt;/h1&gt; &lt;model-viewer style="width: 300px; height: 300px" id="my-replace-people" src="/imgApi/Astronaut.glb" auto-rotate camera-controls &gt; &lt;/model-viewer&gt; &lt;h1&gt;图片贴到模型上&lt;/h1&gt; &lt;div class="example-wrapper"&gt; &lt;model-viewer id="my-replace-shop" src="/imgApi/scene.gltf" auto-rotate camera-controls &gt; &lt;div class="controls" id="color-controls"&gt; &lt;button data-color="#ff0000"&gt;Red&lt;/button&gt; &lt;button data-color="#00ff00"&gt;Green&lt;/button&gt; &lt;button data-color="#0000ff"&gt;Blue&lt;/button&gt; &lt;button data-color="#ffffff"&gt;White&lt;/button&gt; &lt;/div&gt; &lt;div id="progress-bar"&gt;&lt;/div&gt; &lt;!-- &lt;template #progress-bar&gt;&lt;/template&gt; --&gt; &lt;/model-viewer&gt; &lt;/div&gt; &lt;h1&gt;原模型&lt;/h1&gt; &lt;!-- src="/imgApittps://res.theuniquer.com/pgc-models/picture.gltf" --&gt; &lt;model-viewer src="/imgApi/pgc-models_picture.gltf" auto-rotate camera-controls &gt; &lt;/model-viewer&gt; &lt;h1&gt;原图片&lt;/h1&gt; &lt;img style="width: 100%; height: 100px; object-fit: contain" src="/imgApi/tietu.jpg" alt="" /&gt; &lt;h1&gt;图片贴到模型上&lt;/h1&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d341fb26febe3d8cf3ad038ef092169c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dece040b5ee3fc820b11609c59460fee/" rel="bookmark">
			spdlog一个非常好用的C&#43;&#43;日志库(八): 自定义格式化符号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.前言
2.使用set_pattern(..)自定义格式符号
3.格式化标记符(Pattern flags)
4.对齐方式
5.扩展spdlog自定义格式
6.字符串格式化
1.前言 每个记录器的接收器sink都有一个格式化器，用于将消息格式化到其目的地。
spdlog的默认日志记录格式为： [2014-10-31 23:46:59.678] [my_loggername] [info] Some message 有两种方法可以自定义记录器的格式：
1）设置模式字符串（推荐）：
set_pattern(pattern_string); 2) 实现实现格式化程序接口和调用的自定义格式化程序：
set_formatter(std::make_unique&lt;my_custom_formater&gt;()); 2.使用set_pattern(..)自定义格式符号 格式可以全局应用于所有注册的记录器 loggers：
spdlog::set_pattern("*** [%H:%M:%S %z] [thread %t] %v ***"); 或者用于特定的记录器 loggers：
some_logger-&gt;set_pattern("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; %H:%M:%S %z %v &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"); 或者用于特定sink对象：
some_logger-&gt;sinks()[0]-&gt;set_pattern("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; %H:%M:%S %z %v &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"); some_logger-&gt;sinks()[1]-&gt;set_pattern(".."); 3.格式化标记符(Pattern flags) 格式化标记符以%flag的形式出现，类似于strftime函数。以下是一些常用的模式标志及其含义：
标记含义例子%v 要记录的实际文本
"some user text"%t 线程ID
"1232"%P 进程ID
"3456"%n logger的名称
"some logger name"%l 消息的日志级别（如"debug"、"info"等）
"debug", "info", etc%L 消息的简短日志级别（如"D"、"I"等）
"D", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dece040b5ee3fc820b11609c59460fee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b5fe88ea9230ac8940c7ba8593b9eef/" rel="bookmark">
			链表的回文结构（链表的中间节点&#43;反转链表）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链表的回文结构 一.链表的中间节点思路1：暴力求解思路2：快慢指针 二.返回倒数第k个节点思路1：暴力求解思路2：快慢指针 三.反转链表思路1：头插法思路2：反转指针的指向 四.链表的回文结构思路1：利用数组，判断是否回文思路2：求链表的中间节点+反转链表 要解决链表的回文结构：首先需要求中间节点，其次是会反转链表。
一.链表的中间节点 链表的中间节点
思路1：暴力求解 求出链表的长度。求出要返回的中间节点的位置（除2+1），遍历链表返回节点指针即可。注意：兼容奇数个节点与偶数个节点。 typedef struct ListNode ListNode; struct ListNode* middleNode(struct ListNode* head) { ListNode* cur = head; int listLength = 0; while(cur) { //求链表的长度 listLength++; cur = cur-&gt;next; } //链表中间节点的位置 int middle = listLength / 2 + 1; int i = 1; //注意：非i=0 cur = head; while(i &lt; middle) { i++; cur = cur-&gt;next; } return cur; } 思路2：快慢指针 定义两个指针fast、slow保存链表头节点的地址。进入循环，fast指针一次走两个节点，slow指针一次走一个节点，当fast != NULL &amp;&amp; fast-&gt;next !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b5fe88ea9230ac8940c7ba8593b9eef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/094a75bfd5ac808fe8cdcbaf0b6cdaa3/" rel="bookmark">
			elasticsearch性能调优方法原理与实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		❃博主首页 ： 「码到三十五」 ，同名公众号 :「码到三十五」，wx号 : 「liwu0213」 ☠博主专栏 ： &lt;mysql高手&gt; &lt;elasticsearch高手&gt; &lt;源码解读&gt; &lt;java核心&gt; &lt;面试攻关&gt; ♝博主的话 ： 搬的每块砖，皆为峰峦之基；公众号搜索「码到三十五」关注这个爱发技术干货的coder，一起筑基 文章目录 引言1. 硬件选择和优化磁盘优化CPU优化网络优化存储与压缩优化JVM与内存管理 2. 索引与分片策略索引生命周期管理分片与副本策略 3. 查询优化缓存机制聚合优化数据建模优化其他 4. 监控与日志5. 高级调优技巧脚本优化文档路由插件与扩展 5. 案例背景痛点分析解决方案具体设置及代码JVM设置索引设置查询优化 结语 引言 Elasticsearch性能调优对于提升系统整体效能至关重要。然而，性能调优并非一蹴而就，需要深入理解ES的内部工作机制，并结合实际业务场景进行精细化调整。本文将深入解释ES性能调优方法的原理，结合具体案例展示如何在实际应用中优化ES性能。
1. 硬件选择和优化 磁盘优化 使用SSD：对于频繁读写操作的Elasticsearch集群，使用SSD（固态硬盘）可以显著提高I/O性能。
RAID配置：可以考虑使用RAID0来提高写入性能，或者使用RAID10（镜像+条带化来兼顾性能和数据安全性。
冷热数据分离：对于不经常访问的“冷数据”，可以将其存储在成本更低的机械硬盘上，以节省成本。
CPU优化 多核与多线程：选择CPU时，优先考虑核心数和线程数多的型号，以便更好地处理并发查询和索引操作
避免单核高性能：对于Elasticsearch来说，高单核性能并不是首要考虑的因素，因为Elasticsearch的设计可以很好地利用多核多线程。
网络优化 低延迟网络：确保Elasticsearch集群部署在低延迟的网络环境中，以减少节点间通信的延迟。
跨地域部署的注意事项：尽量避免跨地域部署单个集群，以减少网络故障的风险。
存储与压缩优化 Elasticsearch内部对倒排表的存储进行了深度优化，使用了多种压缩算法来减少存储空间和提高查询效率。在数据建模时，应尽可能采用通用最小化法则，例如使用合适的字段类型（如Keyword代替数值类型进行精确匹配查询）、避免重复存储等。
FST（Finite State Transducers）模型：Elasticsearch使用FST模型来存储词项字典，可以极大地节省存储空间并提升查询效率。一个TB级的索引，通过FST存储后，其构建的模型大小可缩小至1GB左右。 JVM与内存管理 Elasticsearch运行在JVM上，合理的JVM配置对于提升性能至关重要。JVM堆内存大小、垃圾回收策略等都会影响ES的写入和查询性能。
堆内存设置：一般建议JVM堆内存大小不超过物理内存的50%，且最大不超过32GB（对于支持Compressed OOP的JVM）。
禁用Swap：Swap交换会导致JVM堆内存被换出到磁盘，严重影响性能，应尽可能禁用Swap。
2. 索引与分片策略 索引生命周期管理 Rollover Index：定期创建新的索引来存储新数据，避免单个索引过大。
Index Lifecycle Management (ILM)：利用Elasticsearch的ILM功能，自动化地管理索引的生命周期，包括创建、滚动、删除等操作。
分片与副本策略 ES通过分片（Shard）和副本（Replica）机制来实现数据的分布式存储和查询，从而提高系统的可用性和性能。
分片分配：分片用于数据的水平拆分，可以将数据分片存储在不同的节点上，提高查询的并行处理能力。合理的分片数量和大小对于优化性能至关重要。一般建议单个分片大小控制在10GB到50GB之间。根据数据的增长速度和查询负载来动态调整分片数量和大小。分片过多会增加查询时的JVM开销和协调节点的转发压力，影响查询性能。 副本策略：副本用于数据的冗余存储，提高数据的可用性和容错能力。在写入大量数据时，可以暂时关闭副本以加速索引过程，待数据写入完成后再恢复副本。 3. 查询优化 缓存机制 利用查询缓存：Elasticsearch会自动缓存频繁执行的查询结果，以减少查询延迟。可以通过调整indices.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/094a75bfd5ac808fe8cdcbaf0b6cdaa3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cabd86afe49f1f5a9e72839f55196eb2/" rel="bookmark">
			《Python数据科学之四：建模与机器学习基础》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《Python数据科学之四：建模与机器学习基础》 在数据科学项目中，经过数据清洗、探索性数据分析（EDA）和数据可视化之后，下一个重要步骤是建立数据模型并应用机器学习技术。本文将深入探讨如何使用 Python 进行建模和机器学习，特别是通过 Scikit-learn、XGBoost 和 TensorFlow 这些强大的库。
一、建模与机器学习的重要性 建模与机器学习是数据科学的核心，它们帮助数据科学家从数据中提取有价值的信息，做出预测和决策。通过建立数学模型，我们能够理解数据中的特征如何影响目标变量。机器学习算法能够根据训练数据自动调整模型参数，从而提高预测的准确性。
二、Python 中的建模与机器学习工具 Python 提供了多个强大的库来帮助进行建模和机器学习，其中最常用的包括 Scikit-learn、XGBoost 和 TensorFlow。
Scikit-learn（scikit-learn.org） Scikit-learn是 Python 中进行机器学习的基础库，它提供了丰富的监督和非监督学习算法。Scikit-learn 的 API 设计简洁一致，便于用户快速实现原型设计和算法比较。
XGBoost XGBoost是一个高效的梯度提升库，它以极高的计算效率和准确率而闻名。XGBoost 特别适合处理大规模数据集，其算法在许多数据科学竞赛中取得了优异的成绩。
TensorFlow TensorFlow是 Google 开发的一个开源深度学习框架，它支持复杂的神经网络模型和大规模的深度学习计算。TensorFlow 提供了灵活的低级 API，同时也支持高级封装，如 Keras，使得构建和训练深度学习模型更加容易。
三、建模与机器学习的实践 在进行建模和机器学习时，首先需要选择合适的模型和算法。这通常取决于问题的类型（如分类、回归或聚类）以及数据的特性（如数据量、特征维度和噪声水平）。例如，对于小规模的数据集，简单的线性回归或决策树可能足够；而对于大规模或高维度的数据集，可能需要使用更复杂的模型，如随机森林、梯度提升或深度学习。
接下来，我们需要对模型进行训练和验证。这通常涉及数据的划分（如训练集、验证集和测试集的划分）、模型参数的选择（如通过交叉验证进行超参数调优）以及模型性能的评估（如准确率、召回率和 F1 分数等指标）。
四、代码实例 下面是一个使用 Python、Scikit-learn 和 XGBoost 进行建模和机器学习的简单示例：
import pandas as pd from sklearn.model_selection import train_test_split from sklearn.ensemble import RandomForestClassifier from xgboost import XGBClassifier # 加载数据集 df = pd.read_csv('data.csv') # 准备特征和标签 X = df.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cabd86afe49f1f5a9e72839f55196eb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c298d0405effdf261086237a6c2b2e41/" rel="bookmark">
			CentOS软件安装与vim使用操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
CentOS软件安装
软件生态的概念
CentOS软件安装
CentOS软件卸载
CentOS查看软件包
rz和sz命令
vim多模式文本编辑器
vim 的使用
命令模式
输入模式
底线命令模式
vim 按键说明
第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等
光标移动
搜索替换
删除、复制与贴上
第二部分：一般模式切换到编辑模式的可用的按钮说明
进入输入或取代的编辑模式
第三部分：一般模式切换到指令行模式的可用的按钮说明
指令行的储存、离开等指令
vim 环境的变更
额外补充（注释）
Vim的配置
CentOS软件安装 软件生态的概念 软件生态：一款操作系统是否可以在市场上有一席之地最主要看的还是操作系统的软件生态，软件生态包括：论坛、官方文档、软件体系……
CentOS软件安装 在CentOS下，使用yum指令进行软件安装，但是安装软件只能是root用户，如果普通用户想安装只可以使用sudo提权（前提是在sudoers文件中），例如安装tree命令：（root用户下）yum install -y tree
在yum命令使用使用-y选项可以在安装软件的过程中不询问用户
CentOS软件卸载 软件卸载同软件安装，只有root用户和可以sudo提权的用户可以执行，例如卸载tree命令：（root用户下）yum remove tree
CentOS查看软件包 使用yum list可以罗列出远端服务器中可以下载的所有软件，结合管道和grep指令可以筛选出需要的软件，例如查找tree命令：yum list | grep tree
rz和sz命令 rz和sz用于Windows机器和云服务器的Linux机器通过XShell传输文件，使用rz可以从Windows机器中选择文件发送给Linux机器，使用sz可以从Linux机器向Windows机器中发送文件
vim多模式文本编辑器 vim 的使用 基本上vim共分为三种模式，命令模式（Command Mode）、输入模式（Insert Mode）和命令行模式（Command-Line Mode）。
命令模式 用户刚刚启动 vim，便进入了命令模式。
此状态下敲击键盘动作会被Vim识别为命令，而非输入字符，比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。
以下是普通模式常用的几个命令：
i -- 切换到输入模式，在光标当前位置开始输入文本。
x -- 删除当前光标所在处的字符。
:（shift+;） -- 切换到底线命令模式，以在最底一行输入命令。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c298d0405effdf261086237a6c2b2e41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59498840f12b57ff81a90a69b66b8eef/" rel="bookmark">
			【Linux】Ubuntu配置JDK环境、MySQL环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、 Ubuntu配置JDK环境 在Ubuntu系统中安装JDK 8可以通过以下步骤进行：
打开终端。更新包列表： sudo apt update 安装OpenJDK 8： sudo apt install openjdk-8-jdk 验证安装是否成功： java -version 注：如果系统中安装了多个Java版本，可以使用以下命令设置系统默认的Java版本：
sudo update-alternatives --config java 然后根据提示选择JDK 8。
Ubunto配置MySQL环境 在Ubuntu上安装MySQL可以通过以下步骤进行：
打开终端。更新包列表： sudo apt update 安装MySQL服务器： sudo apt install mysql-server 安全设置（设置root密码，移除匿名用户，禁止root远程访问等）： sudo mysql_secure_installation （可选）检查MySQL服务状态： sudo systemctl status mysql.service （可选）登录MySQL以确保一切正常： mysql -u root -p 输入你在安全设置中设置的密码。
注：以上步骤会在Ubuntu系统上安装MySQL服务器，并执行基本的安全设置。如果你需要进一步配置MySQL，可以编辑 /etc/mysql/mysql.conf.d/mysqld.cnf 文件来调整配置，然后重启MySQL服务：
sudo systemctl restart mysql.service 注：如果不使用默认密码，使⽤alter user命令修改密码
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '自己密码'; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a08014f01b4898ffc480a7c967f656cb/" rel="bookmark">
			【Java--数据结构】栈：不仅仅是数据存储，它是编程的艺术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎关注个人主页：逸狼
创造不易，可以点点赞吗~
如有错误，欢迎指出~
目录
栈
栈的方法介绍
入栈push
出栈pop和
瞄一眼peek
判空isEmpty和判满isFull
模拟实现栈
push入栈
pop出栈和peek
测试
使用泛型实现栈
测试
使用链表实现栈（链式栈）
栈 栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端称为栈 顶，另一端称为栈底。
栈是一种 先进后出 的数据结构
栈的方法介绍 入栈push Stack&lt;Integer&gt; stack=new Stack&lt;&gt;(); //入栈 stack.push(1); stack.push(2); stack.push(3); stack.push(4); 出栈pop和 pop出栈,会删除栈顶元素
//出栈 Integer x=stack.pop(); System.out.println(x); 瞄一眼peek peek（瞄一眼~）获取栈顶元素，不删除
//peek Integer y1=stack.peek(); System.out.println(y1); Integer y2=stack.peek(); System.out.println(y2); 判空isEmpty和判满isFull Stack&lt;Integer&gt; stack=new Stack&lt;&gt;(); System.out.println(stack.isEmpty()); System.out.println(stack.isFull()); 模拟实现栈 下面是利用数组模拟实现一个栈，这种叫做顺序栈。
定义一个数组来实现栈
usedSize表示
当前存放的数据个数当前存放数据的下标 public class MyStack { public int[] elem; public int usedSize; public MyStack(){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a08014f01b4898ffc480a7c967f656cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44a50b44304a544447bb405522ec7d52/" rel="bookmark">
			基于MATHCAD的傅里叶级数模拟和方波图像绘制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、MATHCAD软件简介
MATHCAD是一款功能强大的数学计算软件，它允许用户以类似手写公式的方式输入数学表达式，并即时显示计算结果和图形。在工程研究和学术写作的世界里，MathCAD以其强大的符号运算能力和直观的数学书写体验脱颖而出。MATHCAD支持动态WYSIWYG（所见即所得）操作，允许用户在任何位置轻松输入，还能创建和管理对象域Region，为复杂表达式的计算和可视化提供便利。MATHCAD软件与其他数学工具软件相比，操作简单，且所见即所得，
MATHCAD模拟由11个正弦波和5000个正弦波叠加产生的波形 MATHCAD模拟由11个正弦波叠加的波形 1）先定义函数
2) 绘制图形鼠标左键点击 ，在图窗里输入x和f(x),然后鼠标移出图窗后点击鼠标左键，绘制图形结果如下：
2. MATHCAD模拟由5000个正弦波叠加的波形
1）先定义函数
2) 绘制图形鼠标左键点击 ，在图窗里输入x和f(x),然后鼠标移出图窗后点击鼠标左键，绘制图形结果如下：
从上面运行结果可以看出，随着正弦波叠加数的增加，其叠加波形的形状越来越趋近于理想方波。也从上面的正弦波叠加模拟方波的过程中可以看出，MATHCAD与MATLAB相比具有操作简单
，对编程能力要求不高。方波的MATLAB实现可见我的另外一篇文章方波的傅里叶变换及方波的MATLAB实现-CSDN博客。
如本篇文章对大家有所帮助，请点赞、收藏和关注，谢谢大家！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34a3fa4e16be33f026237a1b47ba4728/" rel="bookmark">
			Datawhale AI 夏令营 学习笔记——机器学习竞赛——Task2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Task1 的baseline我们是基于经验模型（使用均值作为结果数据）来解决的问题，Task2 版本教程将使用机器学习模型解决本次问题，模型使用简单，数据不需要过多预处理；
使用机器学习方法一般主要需要从 获取数据&amp;增强、特征提取和模型 三个方面下手。
一般的使用机器学习模型解决问题的主要步骤为探索性数据分析、数据预处理、提取特征、切分训练集与验证集、训练模型、预测结果。
一、代码详解 1、导入模块 import numpy as np import pandas as pd import lightgbm as lgb from sklearn.metrics import mean_squared_log_error, mean_absolute_error, mean_squared_error import tqdm import sys import os import gc import argparse import warnings warnings.filterwarnings('ignore') 2、探索性数据分析 在数据准备阶段，主要读取训练数据和测试数据，并进行基本的数据展示。
train = pd.read_csv('./data/train.csv') test = pd.read_csv('./data/test.csv') 数据简单介绍：其中id为房屋id，dt为日标识，训练数据dt最小为11，不同id对应序列长度不同；type为房屋类型，通常而言不同类型的房屋整体消耗存在比较大的差异；target为实际电力消耗，也是我们的本次比赛的预测目标。
不同type类型对应target的柱状图
import matplotlib.pyplot as plt # 不同type类型对应target的柱状图 type_target_df = train.groupby('type')['target'].mean().reset_index() plt.figure(figsize=(8, 4)) plt.bar(type_target_df['type'], type_target_df['target'], color=['blue', 'green']) plt.xlabel('Type') plt.ylabel('Average Target Value') plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34a3fa4e16be33f026237a1b47ba4728/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b863c70a6457d892dabda83ef76418a/" rel="bookmark">
			【C&#43;&#43;航海王：追寻罗杰的编程之路】哈希的应用——位图 | 布隆过滤器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 -&gt; 位图
1.1 -&gt; 位图的概念
1.2 -&gt; 位图的应用
2 -&gt; 布隆过滤器
2.1 -&gt; 布隆过滤器的提出 2.2 -&gt; 布隆过滤器的概念
2.3 -&gt; 布隆过滤器的插入
2.4 -&gt; 布隆过滤器的查找
2.5 -&gt; 布隆过滤器的删除
2.6 -&gt; 布隆过滤器的优点
2.7 -&gt; 布隆过滤器的缺陷
1 -&gt; 位图 1.1 -&gt; 位图的概念 位图的概念：所谓位图，就是用每一位来存放某种状态，适用于海量数据，数据无重复的场景。通常是用来判断某个数据是否存在的。
下面是一道面试题：
给40亿个不重复的无符号整数，没排过序。给一个无符号整数，如何快速判断一个数是否在这40亿个数中。
遍历，时间复杂度O(N)。排序(O(NlogN))，利用二分查找：logN。位图解决：数据是否在给定的整形数据中，结果是在或者不在，刚好是两种状态，那么可以使用一个二进制比特位来代表数据是否存在的信息，如果二进制比特位为1，代表存在，为0代表不存在。比如： #define _CRT_SECURE_NO_WARNINGS 1 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; class bitset { public: bitset(size_t bitCount) : _bit((bitCount &gt;&gt; 5) + 1), _bitCount(bitCount) {} // 将which比特位置1 void set(size_t which) { if (which &gt; _bitCount) return; size_t index = (which &gt;&gt; 5); size_t pos = which % 32; _bit[index] |= (1 &lt;&lt; pos); } // 将which比特位置0 void reset(size_t which) { if (which &gt; _bitCount) return; size_t index = (which &gt;&gt; 5); size_t pos = which % 32; _bit[index] &amp;= ~(1 &lt;&lt; pos); } // 检测位图中which是否为1 bool test(size_t which) { if (which &gt; _bitCount) return false; size_t index = (which &gt;&gt; 5); size_t pos = which % 32; return _bit[index] &amp; (1 &lt;&lt; pos); } // 获取位图中比特位的总个数 size_t size()const { return _bitCount; } // 位图中比特为1的个数 size_t Count()const { int bitCnttable[256] = { 0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8 }; size_t size = _bit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b863c70a6457d892dabda83ef76418a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3112bd7b1520ff58455b85501aafa7c/" rel="bookmark">
			Docker Compose部署Kafka集群并在宿主机Windows连接开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 常用参数2. 理解参数和原理3. Docker Compose4. 验证 Docker for Windows4.23.0windows11Java17 1. 常用参数 kafka容器常用参数如下
-e KAFKA_BROKER_ID=1：设置 Kafka broker 的 ID 为 1。每个 Kafka broker 都需要一个唯一的 ID。
-e KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181：指定 Kafka 连接到 Zookeeper 的地址，这里假设 Zookeeper 容器的名称为 zookeeper，并且它在 2181 端口监听。
-e ALLOW_PLAINTEXT_LISTENER=yes：允许 Kafka 使用纯文本监听器。即允许非加密的通信。
-e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092：Kafka broker 实际监听在容器内的 0.0.0.0:9092 上。这意味着 Kafka 接受来自任何网络接口的连接。
-e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://localhost:9092：指定 Kafka 广播其监听器地址，客户端将使用该地址连接到 broker。在这个例子中，Kafka 广播它在 localhost:9092 上监听。
KAFKA_LISTENER_SECURITY_PROTOCOL_MAP：指定 Kafka 使用的监听器协议映射。例如：PLAINTEXT:PLAINTEXT,SSL:SSL。
KAFKA_INTER_BROKER_LISTENER_NAME：指定 broker 间通信使用的监听器名称。例如：PLAINTEXT。
2. 理解参数和原理 KAFKA_LISTENERS是broker实际监听的地址。
KAFKA_ADVERTISED_LISTENERS是broker注册在zookeeper或者controller broker里面的元数据，当消费者或者生产者使用Bootstrap-Server去连接kafka集群时，集群会返回元数据等信息到客户端，客户端会根据每个broker提供的KAFKA_ADVERTISED_LISTENERS去连接对应的broker。
所以首先，集群之间，broker之间需要通信，所以每个kafka容器需要设置一个KAFKA_ADVERTISED_LISTENERS用于告诉别的容器如何连接到自己，如果容器都是处于同一bridge网络，那么直接使用容器名即可。
其次，我们想要在宿主机比如windows的idea开发，我们一般只能通过docker容器-p暴露的端口去连接kafka，所以每个kafka容器还需要设置一个KAFKA_ADVERTISED_LISTENERS来告诉宿主机的客户端，如何连接到自己，这里需要使用localhost+暴露在宿主机的端口。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3112bd7b1520ff58455b85501aafa7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/853cebc3faf32eda9464a5da67afb534/" rel="bookmark">
			说一下GET请求和POST请求的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面试官常常会问到的一个问题就是：GET请求和POST请求的区别。因为一个看似简单的问题就能考察出面试者对网络协议和通信的掌握程度以及对前后端开发基础知识是否了解、安全性意识是否足够强，以及综合分析与总结能力等。
所以答的好可以让面试官对你刮目相看，答不好很可能马上就被面试官心里pass掉了。
所以接下来我们就来好好回答一下这个问题！！
1.浏览器回退表现不同：GET在浏览器回退时是无害的，而POST会再次提交请求。 当我们在浏览器中使用GET方法进行页面请求时，浏览器会将请求参数附加到URL的查询字符串中，并通过HTTP协议发送给服务器。由于GET是一种幂等的操作，即多次执行同一个GET请求不会产生副作用或改变服务器状态。
因此当我们点击浏览器的回退按钮后重新加载之前访问过的页面时，浏览器会自动从缓存中获取该页面并显示出来。
相反地，当我们使用POST方法提交表单数据或执行某些非幂等操作时，浏览器会将请求参数包含在HTTP请求体中，并发送给服务器。POST可能导致对服务器状态进行更改、资源创建、更新或删除等重要操作。
因此，在当我们点击回退按钮返回到之前访问过的页面时，浏览器默认行为是再次向服务器发送相同的POST请求以保证执行那个特定操作。
当然这种区别是由浏览器和HTTP规范所决定的默认行为。但我们需要注意的是，并非所有情况下都遵循这样的原则。具体而言：
GET 请求也可以被缓存起来，取决于 HTTP 响应头部设置。在 POST 请求上添加合适响应头（例如 Cache-Control: no-store）可以阻止其被缓存。JavaScript 或其他客户端脚本可以修改默认行为并控制如何处理历史记录和回退按钮事件。 2.GET产生的URL地址可以被Bookmark（即书签保存），而POST不可以。 当我们使用GET发送请求时，所有的参数都会附加在URL后面，并以键值对形式进行传递。例如：
http://example.com/page?param1=value1&amp;param2=value2 这意味着浏览器中会显示的完整URL，URL中包含了全部的参数信息，因此我们可以将该URL添加到书签或者通过复制粘贴方式共享给其他人。
相比之下，当我们使用POST请求时，参数数据并没有直接附加在URL上。相反，在HTTP消息体中以表单形式发送给服务器。由于POST请求不会把参数暴露在URL上，所以无法直接被我们保存为书签。
虽然POST不能直接请求保存为书签，但仍然有一些其他的方法来共享一个包含POST请求的链接。我们可以通过电子邮件、即时通讯应用程序等手段将链接分享给他人，并且他们可以点击该链接打开页面并进行相关操作。
3.浏览器对请求地址的处理不同：GET请求会被浏览器主动cache，而POST不会，除非手动设置。 当浏览器发送GET请求时，如果该请求的URL和参数与之前已经访问过的URL和参数相匹配，则浏览器会尝试从本地缓存获取响应结果。
这是因为GET请求通常被认为是无副作用（不改变服务器状态或资源）且幂等（多次执行产生同样结果）的操作。
由于幂等性，浏览器认为可以安全地使用上次获取到的响应结果，并避免再次向服务器发起请求。
相反，当浏览器发送POST请求时，默认情况下不会将其结果缓存。
这是因为POST通常具有副作用（可能会更改服务器状态或资源），而且不具备幂等性。如果每次都直接使用缓存结果，则可能导致数据不一致或意外操作。
然而，在某些特殊情况下我们希望能够对POST请求进行缓存以提高性能或减少网络流量消耗。
在这种情况下, 我们可以通过设置 Cache-Control 和 Expires 等HTTP头字段来告诉浏览器是否可以对POST响应进行缓存，并指定有效期限。
例如：
POST /api/submit HTTP/1.1 Host: example.com Cache-Control: max-age=3600 在上面这个例子中，通过设置 Cache-Control 为 max-age=3600，我们告诉浏览器可以将该POST请求的响应结果缓存，并且有效期限是3600秒。
需要注意的是，虽然可以手动设置POST请求进行缓存，但仍需谨慎使用。
因为对于具有副作用和非幂等性的操作，默认不进行缓存是出于安全和数据一致性方面的考虑。
如果确实需要对特定类型的POST请求进行缓存，我们需要确保了解其影响，并在设计时考虑清楚相关风险与利益。
4.编码方式不同：GET请求只能进行url编码，而POST支持多种编码方式。 我们在使用GET请求时会将参数附加到URL的查询字符串中，以便将其发送给服务器。
GET请求会把参数进行URL编码（也称为百分号编码或URL转义），以确保特殊字符不会干扰URL结构。以及URL编码会使用%符号后跟两个十六进制数字来表示非ASCII字符或某些特殊字符。
例如
GET /search?query=hello%20world HTTP/1.1 Host: example.com hello world这个查询词被进行了URL编码(%20代表空格)并作为参数传递给服务器。
POST请求：
POST请求将数据作为消息正文发送到服务器，并且我们可以使用多种不同的数据编码方式来对消息体进行格式化。
最常用的POST数据编码方式是 application/x-www-form-urlencoded ，它与GET相似，也会对非ASCII字符和特殊字符进行URL编码。
这种方式下，参数按照键值对形式出现在消息正文中，并用&amp;符号连接起来。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/853cebc3faf32eda9464a5da67afb534/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1741a16bc21ce1f37f604629ca3b48dc/" rel="bookmark">
			【机器学习-00】机器学习是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在科技飞速发展的今天，机器学习已成为一个热门话题，广泛应用于各个行业和领域。那么，机器学习到底是什么？它又是如何工作的？本文将深入探讨机器学习的定义、原理及其在各领域的应用，带领读者走进这个神秘而充满魅力的世界。
一、机器学习的定义
机器学习是一门研究计算机如何模拟或实现人类学习行为的科学。它通过对大量数据的分析，使计算机能够自动地改进和优化其性能，从而实现对新数据的准确预测和决策。简而言之，机器学习就是让计算机从数据中“学习”并改进自身性能的过程。
机器学习是人工智能的一个子集，其核心在于让计算机具备从数据中提取有用信息并自主进行决策的能力。这种能力使得机器学习在各个领域具有广泛的应用前景，如自然语言处理、图像识别、语音识别、推荐系统等。
二、机器学习的原理
机器学习的原理主要基于统计学和计算机科学。它通过对大量数据进行训练，使计算机能够自动地发现数据中的规律，并据此进行预测和决策。机器学习的基本过程可以分为以下几个步骤：
数据收集：收集与任务相关的数据，确保数据的质量和数量能够满足训练需求。
数据预处理：对数据进行清洗、转换和特征提取等操作，以便更好地适应机器学习算法。
模型选择：根据任务需求选择合适的机器学习算法，如线性回归、决策树、神经网络等。
模型训练：利用收集到的数据对所选模型进行训练，使模型能够自动地发现数据中的规律。
模型评估：通过测试数据集对训练好的模型进行评估，检验其预测和决策能力。
模型优化：根据评估结果对模型进行调整和优化，以提高其性能。
在这个过程中，机器学习算法发挥着至关重要的作用。它们通过不断地迭代和优化，使模型能够更准确地拟合数据并预测新数据。
三、机器学习的应用
机器学习在各个领域都有广泛的应用，以下是一些典型的例子：
自然语言处理：机器学习可以帮助计算机理解和生成人类语言，实现文本分类、情感分析、机器翻译等功能。例如，智能客服系统可以通过机器学习识别用户的意图并提供相应的回答。
图像识别：机器学习在图像识别领域的应用非常广泛，如人脸识别、物体检测等。通过训练大量的图像数据，机器学习模型可以自动地识别图像中的特征并进行分类。
语音识别：语音识别技术利用机器学习算法将人类语音转换为文本，为智能音箱、语音助手等设备提供了强大的支持。
推荐系统：机器学习在推荐系统中的应用也日益广泛。通过分析用户的行为和偏好，机器学习可以为用户推荐相关的商品、内容或服务，提高用户满意度和粘性。
此外，机器学习还在医疗、金融、交通等领域发挥着重要作用。例如，在医疗领域，机器学习可以帮助医生进行疾病诊断、药物研发和患者管理等工作；在金融领域，机器学习可以用于风险评估、欺诈检测和投资策略制定等方面。
四、机器学习的挑战与未来
尽管机器学习已经取得了显著的成果，但仍面临着一些挑战。首先，数据的质量和数量对机器学习模型的性能具有重要影响。在实际应用中，往往难以获取到足够的高质量数据来训练模型。其次，机器学习模型的解释性仍然是一个问题。尽管模型可以取得很好的预测效果，但人们往往难以理解模型是如何做出决策的。此外，随着数据量的不断增加和算法的不断优化，机器学习模型可能会变得越来越复杂，导致计算资源和时间的消耗增加。
然而，尽管面临这些挑战，机器学习的未来发展仍然充满希望。随着技术的不断进步和应用场景的不断扩展，机器学习将在更多领域发挥重要作用。同时，随着研究者们对机器学习原理的深入探索，相信未来会涌现出更多高效、可解释的机器学习算法，为各个领域的发展提供有力支持。
五、结语
机器学习作为人工智能的一个重要分支，正在引领着一场科技革命。通过让计算机从数据中“学习”并改进自身性能，机器学习为各个领域带来了前所未有的机遇和挑战。在未来，我们有理由相信，随着技术的不断进步和应用场景的不断扩展，机器学习将在更多领域发挥重要作用，为人类社会的进步和发展做出更大的贡献。
在结束本文之前，我想强调的是，机器学习并非万能的。虽然它在许多领域取得了显著的成果，但仍然存在一些局限性和挑战。因此，在应用机器学习时，我们需要结合具体场景和需求，理性看待其优点和不足，以便更好地发挥其潜力并推动相关领域的发展。
最后编辑于：2024-03-20 23:40 © 著作权归作者所有,转载或内容合作请联系作者 喜欢的朋友记得点赞、收藏、关注哦！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f7e415d49e94e3e33cca232562a767f/" rel="bookmark">
			JavaScript 中 await 永远不会 resolve 的 Promise 会导致内存泄露吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在 JavaScript 中，await 关键字用于等待一个 Promise 完成，它只能在异步函数（async function）内部使用。当 await 一个永远不会 resolve 的 Promise 时，它确实会阻塞异步函数的进一步执行，但不会直接导致内存泄露（memory leak）。然而，这种情况可能会间接导致问题，特别是在处理资源（如数据库连接、文件句柄、网络请求等）时。
为什么说它不会直接导致内存泄露？ 内存泄露通常指的是程序在不需要某些内存时未能释放它，导致内存使用量持续增加。在 JavaScript（特别是在 V8 引擎中，Chrome 和 Node.js 的 JavaScript 引擎）中，垃圾回收器（Garbage Collector, GC）会定期清理不再被引用的对象。如果一个 Promise 永远不会 resolve，那么它自身及其依赖的对象（除非有其他引用指向它们）最终会因为没有任何引用指向它们而被垃圾回收器回收。
间接问题 尽管 await 一个永远不会 resolve 的 Promise 不会直接导致内存泄露，但它可能导致以下问题：
阻塞执行：异步函数将停留在 await 表达式处，无法继续执行后续代码，这可能会阻塞事件循环中的其他任务。
资源占用：如果 Promise 依赖于某些外部资源（如数据库连接、文件句柄、网络请求等），这些资源将不会被释放，直到 Promise 被解决或拒绝。如果 Promise 永远不解决，这些资源可能会长时间被占用，甚至可能导致资源耗尽。
死锁和性能问题：在复杂的应用程序中，多个异步操作可能相互依赖。如果一个操作因为等待一个永远不会 resolve 的 Promise 而阻塞，它可能会阻止其他依赖它的操作执行，从而导致死锁或性能问题。
想要知道 promise 对象有没有被回收掉，可以在控制台使用 queryObjects() ：
queryObjects(Promise) 做的是就是先手动执行一次垃圾回收，然后输出当前页面内存里还存在的 promise 对象。有 0 个，证明所有的 promise 对象都已经被回收了。
为了更明确的看到回收的确发生了，我们还可以给传入 test() 的 promise 对象和 test() 返回的 promise 对象都添加上垃圾回收的回调：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f7e415d49e94e3e33cca232562a767f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9a38988ae232afadf58745c776a4276/" rel="bookmark">
			轻松上手MYSQL：掌握MYSQL聚合函数，数据分析不再难
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​🌈 个人主页：danci_
🔥 系列专栏：《设计模式》《MYSQL》
💪🏻 制定明确可量化的目标，坚持默默的做事。
✨欢迎加入探索MYSQL聚合函数之旅✨
👋 大家好！文本学习和探索MYSQL聚合函数。👋 效率与精准是制胜的关键。MySQL聚合函数，作为数据库操作中的强大工具，能帮你快速进行数据统计、分析和汇总。本篇文章将带你轻松上手MySQL聚合函数，让复杂的数据处理变得简单高效。准备好提升你的数据库技能了吗？让我们一同揭开MySQL聚合函数的神秘面纱，让你的数据飞起来！
目录
一、AVG 求平均值
二、COUNT 统计数量(非null值)
三、GROUP_CONCAT 分组列连接成字符串
四、MAX 取最大值
五、MIN 取最小值
六、SUM 求和(非null值)
七、BIT_AND 按位与运算(非null值)
八、BIT_OR 按位或运算(非null值)
九、BIT_XOR 按位异或运算(非null值)
十、JSON_ARRAYAGG 聚合为一个 JSON 数组
十一、JSON_OBJECTAGG 聚合为一个 JSON 对象
十二、STD 求总体标准差(非null)
十三、STDDEV 求总体标准差(非null)
十四、STDDEV_POP 求总体标准差(非null)
十五、STDDEV_SAMP 计算样本标准差(非null)
十六、VAR_POP 计算总体方差(非null)
十七、VARIANCE 计算总体方差(非null)
十八、VAR_SAMP 计算样本方差(非null)
一、AVG 求平均值 MySQL AVG() 函数计算并返回表达式的平均值。
忽略 NULL 值。
语法：
AVG(expr) AVG(DISTINCT expr) SELECT AVG(expr), ... FROM table_name [WHERE .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9a38988ae232afadf58745c776a4276/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/902b5a86de8cac9bfaca95911622983e/" rel="bookmark">
			一篇文章教你如何快速上手Spring MVC框架【万字详解|包含常用注解分析讲解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.什么是Spring Web MVC
二.Spring MVC的使用
▐ 建立连接
@RestController
@RequestMapping
▐ 传递参数
1.简单类型传参
2.类对象传参（@RequestParam）
3.数组&amp;集合传参
4.JSON传参（@RequestBody）
5.URL中的参数（@PathVariable）
6.上传文件（@RequestPart）
7.Cookie传参（@CookieValue）
8.Session传参（@SessionAttribute）
9.获取Header（@RequestHeader）
▐ 响应 @Controller &amp; @ResponseBody
一.什么是Spring Web MVC 首先引入官方的一段文字：
Spring Web MVC is the original web framework built on the Servlet API and has been included in the Spring Framework from the very beginning. The formal name, "Spring Web MVC," comes from the name of its source module (spring-webmvc), but it is more commonly known as "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/902b5a86de8cac9bfaca95911622983e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cbb5c7cbfcce86f3f5a9572717c3a7b/" rel="bookmark">
			Ubuntu安装配置全分布式Hbase
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hbase相关软件安装包及其版本说明如表所示。
软件
版本
安装包称
Oracle VM VirtualBox6.1.48ubuntu24.04ubuntu-24.04-desktop-amd64.isohadoop3.3.5 hadoop-3.3.5.tar.gz
JDKJDK1.8Hbase2.5.8-hadoop3hbase-2.5.8-hadoop3-bin.tar.gz 1、Hbase下载 Index of /dist/hbase/stablehttps://archive.apache.org/dist/hbase/stable/
2、Hbase安装 解压安装包hbase-thirdparty-4.1.7-src.tar.gz至路径 /usr/local，命令如下：
cd ~ sudo tar -zxf ~/下载/hbase-2.5.8-hadoop3-bin.tar.gz -C /usr/local 将解压的文件名改为hbase，命令如下：
cd /usr/local sudo mv ./hbase-2.5.8-hadoop3 ./hbase sudo chown -R hadoop ./hbase #赋予权限 3、配置环境变量 将hbase下的bin目录添加到path中，这样，启动hbase就无需到/usr/local/hbase目录下，大大的方便了hbase的使用。教程下面的部分还是切换到了/usr/local/hbase目录操作，有助于初学者理解运行过程，熟练之后可以不必切换。
编辑~/.bashrc文件
vim ~/.bashrc export PATH=$PATH:/usr/local/hbase/bin #在最下面添加这行代码 编辑完成后，再执行source命令使上述配置在当前终端立即生效，命令如下：
source ~/.bashrc 查看HBase版本，确定hbase安装成功,命令如下：
/usr/local/hbase/bin/hbase version 4、Hbase配置 HBase有三种运行模式，单机模式、伪分布式模式、分布式模式。作为学习，我们重点讨论单机模式和伪分布式模式。本文主要进行分布式配置
4.1 配置HBase相关文件 切换到hbase的conf目录下修改 hbase-env.sh 文件
export HBASE_MANAGES_ZK=false export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_162 配置 hbase-site.xml 文件
&lt;configuration&gt; &lt;!--指定 hbase 根路径 --&gt; &lt;property&gt; &lt;name&gt;hbase.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cbb5c7cbfcce86f3f5a9572717c3a7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b6a126980c5ca86d9037a7cb8fafff2/" rel="bookmark">
			【数据结构初阶】C语言实现动态顺序表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、顺序表基础知识1.1 线性表1.2 顺序表 二、代码实现动态顺序表2.1 所需文件2.2 SeqList .h文件(1) 顺序表结构的初始化、销毁、打印 - - 函数声明(2) 插入数据（头插，尾插）- - 函数声明(3) 删除数据(头删，尾删) - - 函数声明(4) 在指定位置插入，删除数据 -- 函数声明(5)查找数据 -- 函数声明 2.3 SeqList.c文件(1) 顺序表的初始化，销毁，打印(2) 插入数据（头插，尾插）(3) 删除数据（头删，尾删）(4) 在指定位置插入，删除数据(5)查找数据 2.4 Test.c文件中(1) 测试顺序表的初始化和销毁(2) 测试插入数据（头插，尾插）(3) 测试删除数据（头删，尾删）(4) 测试在指定位置插入、删除数据(5)测试查找数据 三、动态顺序表完整代码SeqList .h文件SeqList.c文件 一、顺序表基础知识 1.1 线性表 线性表是具有一类相同特性的数据结构的集合
常见的线性表：顺序表、链表、栈、队列、字符串
线性表的数据呈线性从左往右挨着存放
线性表的两种结构
逻辑结构：人为想象出来的数据组织形式 - - 一定是线性
例如：我们认为排队的时候，人们整体是呈一条直线或曲线在排列
物理结构：数据在内存上的存储形式 - - 不一定是线性
（1）数组 - -&gt; 空间是连续的
（2）链表：数据是一块一块的，用指针链接起来（java中用引用来链接）- -&gt; 空间是不连续的
1.2 顺序表 作用：把数据存起来
顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，
一般采用数组存储，在数组上完成数据的增删查改
数据结构完成的是对顺序表的增删查改等接口函数
顺序表要求
1.连续的物理空间存储 ，一般采用数组存储
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b6a126980c5ca86d9037a7cb8fafff2/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/155/">«</a>
	<span class="pagination__item pagination__item--current">156/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/157/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>