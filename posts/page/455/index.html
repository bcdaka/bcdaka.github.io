<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0f9dc26f8c6e422dee742a6edc8ed2d/" rel="bookmark">
			Java：List中常见的方法和五种遍历方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.List集合的特点： 有序：存和取的元素顺序一致
有索引：可以通过索引操作元素
可重复：存储的元素可以重复
2.List集合的特有方法 Collection的方法List都继承了
List集合因为有索引，所以多了很多索引操作的方法
方法： void add(int index,E element)-----------&gt;在此集合中的指定插入指定的元素
E remove(int index)-----------&gt;删除指定索引处的元素，返回被删除的元素
E set(int index,E element)-----------&gt;修改指定索引处的元素，返回被修改的元素
E get(int index)-----------&gt;返回指定索引处的元素
代码运行：
package a04mylistdemo; import java.util.ArrayList; import java.util.List; public class ListDemo1 { public static void main(String[] args) { //1.创建一个集合 List&lt;String&gt; list=new ArrayList&lt;&gt;(); //2.添加元素 list.add("aaa"); list.add("bbb"); list.add("ccc"); // System.out.println(list);//[aaa, bbb, ccc] // //在此集合的指定位置插入指定元素 // //细节：原来索引上的元素会一次往后移 // list.add(1,"qqq");//[aaa, qqq, bbb, ccc] // System.out.println(list); // //删除指定索引的元素，返回被删除的元素 // String remove = list.remove(0); // System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0f9dc26f8c6e422dee742a6edc8ed2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abb6e8ca9158faa873a132d7a694318f/" rel="bookmark">
			【收藏】35个JDK 21新特性（含示例代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024年威哥携三位兄弟，Mask、强哥、索尓一起探索Java JDK21 LTS版，JDK 21 带来了一些令人兴奋的新特性和改进，总结了一些自己的笔记，分享给大家，本文将介绍其中一些重要的内容，并提供相应的示例代码以帮助读者更好地理解，阅读全文需要花费你10分钟，收藏起来肯定有需要用的时候。
1. JEP 400: Java 程序集
JDK 21 引入了 JEP 400，它为 Java 程序集提供了一种新的模块化方式。这项功能使得开发者能够更轻松地组织和管理大型项目中的代码。它通过 java.assembly 模块提供支持。
示例代码：
import java.assembly.*; assembly HelloWorld { module com.example.helloworld { requires java.base; exports com.example.helloworld; } } 解释：上面的示例代码展示了如何使用 java.assembly 模块来定义一个简单的 Java 程序集。你可以通过 requires 来指定依赖关系，并通过 exports 来导出你的模块。
2. JEP 405: 增强的 Pattern Matching for instanceof
Java 17 引入了模式匹配，JDK 21 在此基础上进一步改进了对 instanceof 的模式匹配支持。现在，可以直接在 instanceof 表达式中使用类型转换。
示例代码：
class Example { void process(Object obj) { if (obj instanceof String s) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abb6e8ca9158faa873a132d7a694318f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a36e78fa92d5a614232dc781b86611bc/" rel="bookmark">
			java: 无法访问jakarta.servlet.ServletException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题 使用SpringMvc时出现报错报错
java: 无法访问jakarta.servlet.ServletException
找不到jakarta.servlet.ServletException的类文件
原因分析 在 Java EE 8 中，一些标准的 Java EE 包已经从 javax 包迁移到了 jakarta 包，其中包括 javax.servlet 包。这个问题通常是由于使用的依赖版本过低所导致的。因此，如果你在较旧的 Tomcat 版本中使用 Jakarta EE 相关的包，就会遇到这样的问题
解决方案
可以更换Jakarta 相关的依赖
&lt;!-- https://mvnrepository.com/artifact/jakarta.servlet/jakarta.servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;jakarta.servlet&lt;/groupId&gt; &lt;artifactId&gt;jakarta.servlet-api&lt;/artifactId&gt; &lt;version&gt;6.0.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98dbfd9b9cfd92274d88ea189c161fe7/" rel="bookmark">
			JSON的几种注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSON的几种注释 本身JSON是没有类似于Java语法中的 // 或者/* */ 等语法级别的注释语句的
在json文件中用传统的注释格式（// /**/）进行注释，是不符合json规范的。
json里面有自己约定俗成的注释规范。
1、在json文件中，采用"//"，其value就是添加的注释内容。
{ "//": "注释语句最小值", "min": "58", } 2、在需要注释的字段前面添加?， 当然#和_也是可以的。
{ "?min": "注释语句最小值", "min": "58", } 字段注释 增加一个字段，字段名为 特殊字符(@,#,?等) + 正常字段名， 字段的内容即为注释内容。为了区分容易，注释内容尽量避免使用 :,{,},[,] 等正常JSON语法一样的标记。 { "code":1, "@code":"0=男; 1=女"	} 描述 可以参照Java的大段注释标记 /**/ 作为字段名 { "/**/": "这是一段描述" } 语句注释 可以参照Java的注释标记 // 作为字段名前缀： { "name": "我的名字", "//name": "你的名字"	} 完整描述 如果是对一个JSON文件作完整的描述，则另外写一个和字段结构一样的描述结构，这样更加清晰。
例子 { "code": 0, "message": "OK", "data": { "id": "12345", "type": 0, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98dbfd9b9cfd92274d88ea189c161fe7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3696776a084318db061514644781dedb/" rel="bookmark">
			Vue-WebTopo-SVGEditor：下一代SVG图形编辑器的创新实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue-WebTopo-SVGEditor：下一代SVG图形编辑器的创新实践 项目简介 是一个基于 Vue.js 框架开发的Web端SVG图形编辑器，它提供了丰富的图形绘制和编辑功能，旨在为开发者提供一个易于集成、高度可定制化的SVG图形设计解决方案。无论是网络拓扑图、流程图还是其他复杂的矢量图形，Vue-WebTopo-SVGEditor都能轻松应对。
技术解析 该项目的核心采用了 SVG（Scalable Vector Graphics）技术，这是一种XML语言，用于在Web上描述2D图形。SVG具有以下优点：
矢量化：图像质量不会因缩放而降低。动态性：可以进行实时更新和交互。可搜索性和可访问性：由于SVG是文本格式，所以可以被搜索引擎索引，也能通过辅助技术读取。 Vue-WebTopo-SVGEditor 使用Vue.js作为前端框架，利用其组件化的优势，将编辑器拆分成多个独立且可复用的部分，使代码结构清晰，维护性强。同时，它还结合了D3.js库，用于数据驱动的图形操作，使得数据可视化更加灵活。
此外，项目采用模块化设计，支持自定义图形库和事件处理，方便开发者根据需求扩展功能或整合到现有项目中。
应用场景 Vue-WebTopo-SVGEditor 可广泛应用于以下几个领域：
网络及系统管理：快速创建和编辑网络拓扑图，动态展示网络状态。软件工程：绘制流程图、UML图等，辅助编程和设计讨论。教育与培训：制作教学示意图，增加互动性。数据分析：将复杂的数据转化为直观的图表，便于理解和分析。内容创作：在线创作SVG艺术作品，实现丰富的视觉效果。 特点与优势 易用性：简洁的API接口，提供拖拽、旋转、缩放等多种操作方式。可定制化：允许添加自定义图形，支持自定义编辑行为。性能优化：利用Vue.js的虚拟DOM特性，减少不必要的重绘，提高性能。跨平台：基于浏览器运行，兼容多种操作系统和设备。社区支持：开源项目，有活跃的社区和及时的技术支持。 结语 Vue-WebTopo-SVGEditor 以其强大的图形编辑能力和灵活性，为Web应用开发带来了全新的可能性。无论你是希望提升用户体验，还是寻找一个高效的图形编辑工具，Vue-WebTopo-SVGEditor 都值得你尝试和使用。现在就去探索这个项目的无限潜力吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6155983d9990e287670a01eb8ea00b17/" rel="bookmark">
			接口开发笔记-WebApi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基础概念与原理 1、WebAPI的基本概念。 WebAPI是一种基于HTTP协议的网络应用程序接口，它使用JSON或XML格式来传输数据。WebAPI是服务器端应用程序，允许客户端应用程序通过HTTP请求来访问服务器上的数据。WebAPI支持RESTful服务，是构建这种服务的理想选择。同时，WebAPI的客户端系统和服务系统彼此独立，调用者可以使用不同的语言（如Java、Python、Ruby等）进行API的调用。
2、与WebService、WCF等技术的区别与联系。 2.1、WebAPI与WebService的区别 数据传输格式：虽然WebService也支持基于XML格式的数据传输，但在实际生产过程中，WebAPI更常见的数据类型格式是JSON。与XML相比，JSON更加轻量，序列化和反序列化的工作量更少，因此在解析速率方面更快，对带宽的要求更低。交互方式：WebService基于SOAP协议，而WebAPI使用json数据来传递信息，更加轻量化地构建HTTP服务框架。系统交互：WebService通常仅在两个系统之间交互，并且不同的客户端下各浏览器对XML的解析方式不一致，需要重复编写很多代码。而WebAPI的客户端系统和服务系统彼此独立，具有更广泛的适用性。 2.2、WebAPI与WCF的区别 框架与开放性：WCF是附带.NET框架的，不是开源的；而WebAPI是开源的，并且也附带.NET框架。服务支持：WCF提供对有限RESTFUL服务的支持；而WebAPI是构建RESTFUL服务的理想选择。配置方式：WCF使用web.config和属性来配置一个HttpConfiguration类；而WebAPI则主要使用web.config服务进行配置。编程模型：WCF依赖于基于属性的编程模型；而WebAPI将HTTP动词映射到方法。功能支持：WCF不支持MVC功能，如控制器、路由、过滤器等；而WebAPI则与这些功能紧密集成。 3、如何通过WebAPI实现资源的操作。 通过ASP.NET Web API框架，可以实现资源的创建（POST）、读取（GET）、更新（PUT/PATCH）和删除（DELETE）等操作，这些操作都遵循RESTful架构风格。以下是一个简单的步骤：
1.1、创建ASP.NET Web API项目 首先，需要在Visual Studio中创建一个ASP.NET Web API项目。通过选择“文件” -&gt; “新建” -&gt; “项目”，然后在项目模板中选择“ASP.NET Web 应用程序”来完成。在创建过程中，选择“Web API”作为项目类型。
1.2、定义模型（Model） 模型类代表了你想要通过API操作的数据资源。例如，如果你想要操作一个用户资源，你可以定义一个User类：
public class User { public int Id { get; set; } public string Name { get; set; } public string Email { get; set; } } 1.3、创建控制器（Controller） 控制器负责处理HTTP请求并返回响应。你需要创建一个继承自ApiController的类，并添加与资源操作对应的方法。
using System; using System.Collections.Generic; using System.Linq; using System.Web; using System.Web.Http; using WebApplication1.Models; namespace WebApplication1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6155983d9990e287670a01eb8ea00b17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be47adf2cdbc5e7fb00c87512bbf65b3/" rel="bookmark">
			基于Java的图书管理系统论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要 现代经济快节奏发展以及不断完善升级的信息化技术，让传统数据信息的管理升级为软件存储，归纳，集中处理数据信息的管理方式。本图书管理系统就是在这样的大环境下诞生，其可以帮助管理者在短时间内处理完毕庞大的数据信息，使用这种软件工具可以帮助管理人员提高事务处理效率，达到事半功倍的效果。此图书管理系统利用当下成熟完善的SSM框架，使用跨平台的可开发大型商业网站的Java语言，以及最受欢迎的RDBMS应用软件之一的Mysql数据库进行程序开发.图书管理系统的开发根据操作人员需要设计的界面简洁美观，在功能模块布局上跟同类型网站保持一致，程序在实现基本要求功能时，也为数据信息面临的安全问题提供了一些实用的解决方案。可以说该程序在帮助管理者高效率地处理工作事务的同时，也实现了数据信息的整体化，规范化与自动化。
关键词：图书管理系统；SSM框架；Mysql；自动化
Abstract The fast-paced development of the modern economy and the continuous improvement and upgrading of information technology have allowed the management of traditional data information to be upgraded to software storage, induction, and centralized management of data information. This book lending system was born in such a large environment, which can help managers to process huge data information in a short time. Using this software tool can help managers improve transaction processing efficiency and achieve double the result with half the effort.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be47adf2cdbc5e7fb00c87512bbf65b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d33c753d191cf35ec26403a538d80f55/" rel="bookmark">
			【Oracle】Oracle数据库中查看所有表和字段以及表注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**user_tables：**TABLE_NAME,TABLESPACE_NAME,LAST_ANALYZED等
**dba_tables：**ower,table_name,tablespace_name,last_analyzed等
**all_tables：**ower,table_name,tablespace_name,last_analyzed等
**all_objects：**ower,object_name,subobject_name,object_id,created,last_ddl_time,timestamp,status等
2、获取表字段：
select * from user_tab_columns where Table_Name=‘用户表’;
select * from all_tab_columns where Table_Name=‘用户表’;
select * from dba_tab_columns where Table_Name=‘用户表’;
3、获取表注释：
user_tab_comments;表注释
select * from user_tab_comments
user_tab_comments：table_name,table_type,comments
相应的还有dba_tab_comments，all_tab_comments，这两个比user_tab_comments多了ower列。
先自我介绍一下，小编13年上海交大毕业，曾经在小公司待过，也去过华为、OPPO等大厂，18年进入阿里一直到现在。
深知大多数初中级Java工程师，想要提升技能，往往是自己摸索成长或者是报班学习，但对于培训机构动则近万的学费，着实压力不小。自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《Java开发全套学习资料》送给大家，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友，同时减轻大家的负担。
由于文件比较大，这里只是将部分目录截图出来，每个节点里面都包含大厂面经、学习笔记、源码讲义、实战项目、讲解视频
如果你觉得这些内容对你有帮助，可以扫码领取！
Spring全套教学资料 Spring是Java程序员的《葵花宝典》，其中提供的各种大招，能简化我们的开发，大大提升开发效率！目前99%的公司使用了Spring，大家可以去各大招聘网站看一下，Spring算是必备技能，所以一定要掌握。
目录：
部分内容：
Spring源码 第一部分 Spring 概述第二部分 核心思想第三部分 手写实现 IoC 和 AOP（自定义Spring框架）第四部分 Spring IOC 高级应用
基础特性
高级特性第五部分 Spring IOC源码深度剖析
设计优雅
设计模式
注意：原则、方法和技巧第六部分 Spring AOP 应用
声明事务控制第七部分 Spring AOP源码深度剖析
必要的笔记、必要的图、通俗易懂的语言化解知识难点 脚手框架：SpringBoot技术 它的目标是简化Spring应用和服务的创建、开发与部署，简化了配置文件，使用嵌入式web服务器，含有诸多开箱即用的微服务功能，可以和spring cloud联合部署。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d33c753d191cf35ec26403a538d80f55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff846ccd6279f60428024168692c8596/" rel="bookmark">
			Java中的@Nullable和@NotNull注解：提高代码可读性与安全性新姿势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java编程中，空指针异常（NullPointerException）是一个常见的运行时错误，它通常发生在尝试在空引用上调用方法或访问字段时。为了避免这类错误，Java程序员需要仔细处理可能为null的对象引用。而自从Java 8开始，我们可以利用注解（Annotations）来显式地表明一个字段、方法参数或返回值是否可能为null，从而提高代码的可读性和安全性。其中，@Nullable和@NotNull就是两个非常有用的注解。
一、什么是@Nullable和@NotNull？ @Nullable注解用于标识一个字段、方法参数或返回值可能为null。当其他开发者阅读或使用这段代码时，他们会立即意识到需要对这个引用进行null检查。
@NotNull注解则用于标识一个字段、方法参数或返回值在正常情况下不会为null。如果尝试将一个null值赋给这样的字段，或者在调用方法时传递一个null参数，那么在运行时可能会抛出异常，或者在编译时（如果使用静态代码分析工具）会发出警告。
二、如何使用@Nullable和@NotNull？ 在Java中，@Nullable和@NotNull并不是内置的注解，而是由一些第三方库提供的，比如JetBrains的IntelliJ IDEA和Android Studio中内置的注解，或者Apache Commons Lang库中的注解。
下面是一个简单的示例，展示了如何在IntelliJ IDEA中使用这两个注解：
import org.jetbrains.annotations.NotNull; import org.jetbrains.annotations.Nullable; public class UserService { // 使用@Nullable注解表明这个方法可能返回null @Nullable public User getUserById(int id) { // ... 实现获取用户的逻辑，可能返回null } // 使用@NotNull注解表明这个方法不会返回null @NotNull public User getUserByName(@NotNull String name) { if (name == null) { throw new IllegalArgumentException("Name must not be null"); } // ... 实现根据名称获取用户的逻辑，确保不会返回null } public void processUser(@Nullable User user) { if (user != null) { // 处理非null的用户对象 } else { // 处理user为null的情况 } } } 在这个示例中，getUserById方法可能返回null，因此使用了@Nullable注解。而getUserByName方法则通过参数检查和内部逻辑确保不会返回null，因此使用了@NotNull注解。在processUser方法中，我们显式地检查了传入的User对象是否为null，以处理可能的null情况。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff846ccd6279f60428024168692c8596/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b56d9fa081becdddb04c3ba5a40f17ff/" rel="bookmark">
			写代码神器！48个主流代码生成LLM大模型盘点，包含专用、微调等4大类Code llama
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写代码神器！48个主流代码生成LLM大模型盘点，包含专用、微调等4大类 学姐带你玩AI 2023-12-06 18:20
代码大模型具有强大的表达能力和复杂性，可以处理各种自然语言任务，包括文本分类、问答、对话等。这些模型通常基于深度学习架构，如Transformer，并使用预训练目标（如语言建模）进行训练。
在对大量代码数据的学习和训练过程中，代码大模型能够提升代码编写的效率和质量，辅助代码理解和决策，在代码生成、代码补全、代码解释、代码纠错以及单元测试等任务中都表现出十分出色的能力。
为了帮大家深入掌握代码大模型的发展历程和挑战，学姐这次整理了相关的48个模型以供同学们学习，分为了4大类，包括原始LM、LM改进、专用LM，以及微调模型。
原始LM 1.Lamda: Language models for dialog applications 用于对话应用程序的语言模型
模型简介：LaMDA是一种专门用于对话的神经网络语言模型，通过预训练和微调，可以显著提高其安全性和事实依据。在安全性方面，使用少量众包工人注释的数据进行微调的分类器过滤候选响应可以提高模型的安全性。在事实依据方面，允许模型咨询外部知识源可以使生成的响应基于已知来源。
2.Palm: Scaling language modeling with pathways 使用路径缩放语言模型
模型简介：本文介绍了一种名为PaLM的540亿参数密集激活Transformer语言模型，使用Pathways新机器学习系统在多个TPU Pod上进行高效训练。作者通过数百个语言理解和生成基准测试展示了规模缩放的持续优势，PaLM在一些多步推理任务上实现了突破性的性能，超过了最新的细调最先进技术和人类平均水平。此外，PaLM在多语言任务和源代码生成方面也表现出强大的能力。
3.Gpt-neox-20b: An open-source autoregressive language model 一个开源的自回归语言模型
模型简介：论文介绍了一种200亿参数的自回归语言模型GPT-NeoX-20B，该模型在Pile上进行训练，并通过允许性许可证向公众免费提供其权重。GPT-NeoX-20B是目前提交时公开可用权重最大的密集自回归模型。在这项工作中，作者描述了该模型的架构和训练，并在一系列语言理解、数学和基于知识的任务上评估了其性能。作者发现GPT-NeoX-20B是一个非常强大的少样本推理器，当评估5个示例时，其性能比类似的GPT-3和FairSeq模型获得更多收益。
4.BLOOM: A 176b-parameter open-access multilingual language model
5.lama: Open and efficient foundation language models
6.GPT-4 technical report
7.lama 2: Open foundation and finetuned chat models
8.Textbooks are all you need II: phi-1.5 technical report
LM改进 1.Evaluating large language models trained on code 评估基于代码训练的大型语言模型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b56d9fa081becdddb04c3ba5a40f17ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9fa3d4207ed127938d3fa450474b38b/" rel="bookmark">
			两种最简单的方式教会你如何实现前端一件换肤！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第一种方法：window.document.documentElement.style.setProperty()黑色主题白色主题 第二种方法：html 自定义属性配合 css 的属性选择器HTML自定义属性：CSS的属性选择器： 通常，前端一键换肤功能需要通过使用 CSS 样式表来定义不同的主题样式，然后通过 JavaScript 来控制切换不同的样式表，以达到换肤的效果。用户在点击换肤按钮或者选择不同的主题选项后，页面会立即应用新的样式，从而改变界面的外观。这种功能在很多网站、应用中都有广泛的应用，特别是一些内容丰富、用户群体广泛的平台，以满足不同用户对于外观风格的偏好。
今天我就教大家用两种方式实现前端一键换肤的功能，都是给予原生 css 和 js 的方法属性，不用安装任何的第三方库
第一种方法：window.document.documentElement.style.setProperty() 先介绍一下 window.document.documentElement.style.setProperty()这个方法
document.documentElement代表的是文档对象模型（DOM）中的根元素，即HTML文档中的元素。style.setProperty()是用于在JavaScript中设置元素样式的方法。
具体来说，document.documentElement.style.setProperty() 方法可以用于动态地设置根元素的 CSS 样式属性。它接受两个参数：
属性名： 第一个参数是要设置的 CSS 属性名称，例如 “color”, “font-size”, “background-color” 等等。属性值： 第二个参数是要为属性设置的值，可以是字符串或者变量，表示对应样式属性的值。 例如，以下代码将修改根元素的背景颜色为红色：
document.documentElement.style.setProperty('background-color', 'red'); 这种方法可以用于动态改变页面的整体样式，在实现一键换肤功能时非常有用。通过 JavaScript 动态地调用 setProperty() 方法，可以实现在用户操作后改变整个页面的外观，从而实现换肤的效果。
话不多说，show time 时间到！看我操作，我只演示一遍！
打开前端项目，在 src 项目下创建一个 theme 文件夹用来保存主题样式相关的 css 和 js 文件。我这里默认有两种主题，分别是黑夜和白昼。你可以根据自己的项目情况来设置有多少种主题。
在 theme 文件夹种创建 dark.ts,light.ts 和 theme.css 等三个文件。
首先在 theme.css 文件中的 root 根选择器里面定义默认的 css 变量
:root { --bgColor: #000000; } 然后在项目的根样式 index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9fa3d4207ed127938d3fa450474b38b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3128e429efe1da94044084406042460/" rel="bookmark">
			【JavaSE】数据类型和运算符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 从这一篇我们开始Java的学习~
欢迎关注个人主页：逸狼
创造不易，可以点点赞吗~
如有错误，欢迎指出~
目录
前言
Java第一个程序
字面常量
字面常量的分类
结合代码理解
类型转换
类型提升
byte与byte的运算
正确写法
字符串类型String
int与String相互转换
int转String
String转int
算术运算符
加减乘除模(+ - * / %)
+加
/ 除
%取余
小数也可以%
增量运算符 += -= *= %=
自增/自减运算符 ++ --
关系运算符 == != &lt; &gt; =
逻辑运算符&amp;&amp; || !
逻辑与&amp;&amp;
逻辑或||
逻辑非！
短路
位运算符
按位与&amp;
按位与|
按位取反 ~
按位异或
条件运算符
移位运算
Java第一个程序 public class Helloworld { //快捷键main 或者首字母psvm创建main方法 public static void main(String[] args) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3128e429efe1da94044084406042460/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d8d8302b9c422002f42bc8242baf5bd/" rel="bookmark">
			基于SpringBoot和Leaflet的行政区划地图掩膜效果实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、掩膜小知识
1、GIS掩膜的实现原理
2、图层掩膜流程 二、使用插件
1、leaflet-mask介绍
2、核心代码解释 三、完整实例实现
1、后台逻辑实现
2、省级行政区划查询实现
3、行政区划定位及掩膜实现 4、成果展示
总结
前言 在之前的博客提过按空间矢量范围下载遥感，有兴趣的同学可以参考已下的博文地址：基于QGIS的研究区域遥感影像裁切下载方法-以岳麓区为例。在这篇博客中采用的是Qgis软件，这是 一款桌面端的GIS软件。在这里，首先简单解释一下gis中掩膜的相关概念。掩膜在制图中是一种遮盖工具，用于处理要素在显示上的冲突。掩膜可以理解为一种看不见的面要素，它遮挡住了不需要显示的图形。用这个工具可以将影像按面要素周长裁剪。
存在两种类型的掩膜策略：一是：图层掩膜 - 是指在地图或场景中，某一要素图层或掩膜图层可以掩盖另一图层中的任何重叠要素。二是要素级掩膜 - 是指按照两图层间关系类所指定的方式对各相关要素进行的掩膜。无论采用哪种掩膜方式，掩膜要素的几何均会掩盖被掩膜要素的符号系统。 即使掩膜要素的符号化形状与几何不同，（例如，如果应用了符号缓冲），要素几何的形状会进行掩膜。 然而，被掩膜要素的符号系统会受到影响。 被掩膜要素看起来可能存在孔洞，但它们只是可见符号中的孔洞。 要素几何并未更改。
本文讲解的是一种图层级的掩膜，即使用行政区划图层来进行掩膜。使用场景为，用户只需要在地图页面中展示目标行政区划内的影像信息，对于行政边界外的影像，则不展示。这就是WebGIS中掩膜的一种表达方式。本文重点讲解在Webgis中如何进行行政区划掩膜实现，通过代码实战的方式对功能进行详细的实现，采用网友编写一个掩膜组件，不仅避免了自己的区域绘制太小，也避免了不同行政区划切换时，有部分缝隙的问题。如果您目前也有WebGIS掩膜可视化需求，不妨来看看博客。
一、掩膜小知识 在讲解地图之前，如果了解前端的朋友一定知道，在HTML5的应用中，可能会存在两个DIV，可能由于其内容和位置的设置存在空间重叠，有一部分区域会被另一个DIV进行遮盖。这种效果就是掩膜。（以上不是官网的定义，只是翻译成了大白话，易于大家理解）。通过上面的解释可以看出，在这个场景中涉及的图层起码有两个，而且存在空间折叠的关系。而实现效果就是通过叠加，使用遮罩这种方式来进行。
1、GIS掩膜的实现原理 与上述Html的实现原始一致的，在这个场景当中。首先我们会使用栅格底图（一般是遥感影像）。然后在展示行政区划时，自动将行政区划外的地图遮住。比如在展示湖南省的行政区划时，只展示湖南省区域内的影像，对于湖南省外的区域则不展示，以空白的方式展现出来。先来看一下实际的效果。
2、图层掩膜流程 对于图层掩膜的流程，使用流程图描述如下：
第一步是在地图上加载原始的遥感影像，可以是WMS或者XYZ瓦片。第二步是输入要叠加的升级行政区划范围，这里一般是采用GeoJSON的方式进行获取。第三步是从GeoJSON中解析出空间面信息，构建出遮罩范围，通过绘制遮罩面，设置遮罩面的透明度。同时将无需遮罩的范围留空，这样就能实现空间掩膜的效果。
二、使用插件 在实现这个需求时，可以完全不用外部的插件，通过Leaflet自己构建Polygon面来实现遮罩掩膜的效果即可。但是使用自己绘制的面时，进行地图缩放时，会有一些不顺畅的原因。因此在开源社区找了一款开源的组件。通过组件来实现地图遮罩，方便又美观。
1、leaflet-mask介绍 leaflet-mask是一个简单的地图遮罩层控件，继承自L.polygon。我们很多时候希望只显示某块区域内的内容,隐藏或者模糊区域外内容。此插件可以实现传入polygon的latlngs创建对应的遮罩图层。其gitee地址是leaflet-mask。大家可以将代码下载到本地，然后运行其官方的实例即可。
2、核心代码解释 对于这个插件来说，核心代码其实非常少，也是很容易看懂的。在下载的源代码中，可以直接打开来看，在src目录下有leaflet-Mask.js。使用文本编辑器或者javascript脚本编辑器打开这个脚本。
/** * 遮罩 */ L.Mask = L.Polygon.extend({ options: { isRect: true, //是否为矩形遮罩,如果为是,则使用northWest，northEast，sourthEast，sourthWest创建矩形遮罩层外边界,如果为false，则使用传入的坐标数组作为遮罩层外边界 northWest: { lat: 180.0, lng: -180.0 }, //遮罩层西北角坐标 northEast: { lat: 180.0, lng: 180.0 }, //遮罩层东北角坐标 sourthEast: { lat: -180.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d8d8302b9c422002f42bc8242baf5bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c467f29f849916634e377ee884209fa3/" rel="bookmark">
			若依vue（前后端分离版本）前端获取登录用户id
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		步骤流程 1.找到user.js
2.在user.js中找到以下几个地方
属性：state{}属性：mutations{}函数：GetInfo() 3.在user.js中添加代码 4.在自己的页面中添加获取id的代码
步骤一 在该若依的版本中，从下列目录找到，ruoyi-ui-&gt;src-&gt;store-&gt;modules-&gt;user.js
步骤二 属性state在页面中的位置
state: { token: getToken(), name: '', avatar: '', roles: [], permissions: [] }, 还有mutations
mutations: { SET_TOKEN: (state, token) =&gt; { state.token = token }, SET_NAME: (state, name) =&gt; { state.name = name }, SET_AVATAR: (state, avatar) =&gt; { state.avatar = avatar }, SET_ROLES: (state, roles) =&gt; { state.roles = roles }, SET_PERMISSIONS: (state, permissions) =&gt; { state.permissions = permissions } } 最后是GetInfo方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c467f29f849916634e377ee884209fa3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e698db148742731361a01da46aed407/" rel="bookmark">
			C&#43;&#43;中数组作为函数参数传入的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++中数组作为函数参数传入的几种方式
在C++中，函数可以接受数组作为参数，但是需要注意的是，数组在传递给函数时，其大小信息会丢失，因此通常需要额外的参数来指明数组的大小。此外，C++支持传递数组到函数的多种方式，包括传递数组、传递数组的引用、传递指针等。下面是一些示例：
传递数组 #include &lt;iostream&gt; void printArray(int arr[], int size) { for (int i = 0; i &lt; size; ++i) { std::cout &lt;&lt; arr[i] &lt;&lt; " "; } std::cout &lt;&lt; std::endl; } int main() { int myArray[] = {1, 2, 3, 4, 5}; int size = sizeof(myArray) / sizeof(myArray[0]); printArray(myArray, size); return 0; } 在这个例子中，printArray函数接受一个整型数组arr和一个表示数组大小的整型变量size。在main函数中，我们计算了数组myArray的大小，并将其传递给printArray函数。这种方法会对arr数组进行拷贝,因此采用该方式传递时要注意数组本身不要过大。
传递数组引用 #include &lt;iostream&gt; void printArray(int (&amp;arrRef)[5]) { for (int i = 0; i &lt; 5; ++i) { std::cout &lt;&lt; arrRef[i] &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e698db148742731361a01da46aed407/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3411e472aa6cc95dd9283bdb843ff12c/" rel="bookmark">
			cryptography，一个神奇的 Python 库！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更多资料获取 📚 个人网站：ipengtao.com
大家好，今天为大家分享一个神奇的 Python 库 - cryptography。
Github地址：https://github.com/pyca/cryptography
在当今数字化时代，信息安全越来越受到重视。数据加密是保护数据安全的重要手段之一，而Python的cryptography库提供了丰富的功能来支持各种加密算法和协议。本文将深入探讨cryptography库的各个方面，包括其基本概念、常见用法、高级特性、安全性考虑以及示例代码。
什么是cryptography库？ cryptography是一个用于Python的密码学工具包，它提供了安全的密码学算法和协议的实现，用于加密、解密、签名、验证等操作。cryptography库致力于提供简单、易用且高度安全的API接口，使得开发人员能够轻松地实现数据加密和安全通信。
安装cryptography库 在开始使用cryptography之前，需要先安装它。
可以使用pip来安装cryptography：
pip install cryptography 安装完成后，就可以开始使用cryptography库了。
基本功能 1. 对称加密 cryptography库支持常见的对称加密算法，比如AES、DES等。
下面是一个使用AES对称加密算法加密和解密数据的示例：
from cryptography.fernet import Fernet # 生成密钥 key = Fernet.generate_key() # 创建加密器 cipher = Fernet(key) # 加密数据 encrypted_data = cipher.encrypt(b"Hello, World!") # 解密数据 decrypted_data = cipher.decrypt(encrypted_data) print(decrypted_data.decode()) 2. 非对称加密 cryptography库还支持非对称加密算法，比如RSA。
下面是一个使用RSA非对称加密算法加密和解密数据的示例：
from cryptography.hazmat.backends import default_backend from cryptography.hazmat.primitives import serialization, rsa from cryptography.hazmat.primitives.asymmetric import padding # 生成RSA密钥对 private_key = rsa.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3411e472aa6cc95dd9283bdb843ff12c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c1f9fdad7eaf335982f6bb479d955a2/" rel="bookmark">
			软件测试|解决 Git Push 出现 “error: failed to push some refs to“错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题介绍 在使用Git推送代码到远程仓库时，我们可能会遇到以下错误消息之一：
error: failed to push some refs to 'remote-repository' 这个错误通常发生在我们尝试将本地分支的更改推送到远程仓库时。这篇文章将详细解释可能导致此错误的原因以及如何解决它。
原因分析 这个错误通常有以下几种原因：
远程仓库的分支比本地分支更新：在我们推送更改之前，其他人可能已经推送了更改到远程仓库的相同分支。
本地分支与远程分支不一致：我们的本地分支可能与远程分支有不同的提交历史，或者它们的分支关系可能已经发生了变化。
权限问题：我们可能没有足够的权限将更改推送到远程仓库。
解决方法 以下是解决error: failed to push some refs to错误的一些方法：
拉取远程更改并重新推送 这是最常见的情况之一。其他人可能已经推送了更改到远程分支，我们需要先将这些更改拉取到本地，解决任何冲突，然后重新推送更改。
# 拉取远程更改 git pull origin &lt;branch-name&gt; # 解决冲突（如果有的话） # 推送您的更改 git push origin &lt;branch-name&gt; 强制推送 在某些情况下，如果我们确定要覆盖远程分支的更改，可以使用--force标志来强制推送。
git push --force origin &lt;branch-name&gt; 请注意，强制推送可能会覆盖远程分支的历史，谨慎使用。
检查分支关系 确保我们的本地分支与远程分支的关系正确，可以使用以下命令来查看和设置本地分支与远程分支的关联：
# 查看分支关系 git branch -vv # 设置本地分支与远程分支的关联 git branch --set-upstream-to=origin/&lt;branch-name&gt; &lt;branch-name&gt; 检查权限 如果没有足够的权限将更改推送到远程仓库，请联系仓库管理员或相关团队成员，以获取必要的权限。
其他解决方案 如果上述方法都无法解决问题，还有其他可能性，例如本地Git配置或仓库状态的问题,可以尝试以下步骤：
检查Git配置，确保用户名和电子邮件地址设置正确。确保有足够的磁盘空间。检查仓库状态，确保没有未提交的更改。 总结 error: failed to push some refs to错误通常是由于本地分支与远程分支之间的不一致或权限问题引起的。根据具体情况，采取上述方法之一来解决问题。在进行强制推送等可能具有风险的操作时，请谨慎操作，以免不必要的数据丢失。最终，了解如何正确地处理这些Git错误是Git版本控制中的重要一步。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c1f9fdad7eaf335982f6bb479d955a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fbc968098491f55002aa49cdb34cef0/" rel="bookmark">
			通义千文大模型API调用示例(python)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		API详情 通义千问是阿里云自主研发的大语言模型，能够在用户自然语言输入的基础上，通过自然语言理解和语义分析，理解用户意图，在不同领域、任务内为用户提供服务和帮助。您可以通过提供尽可能清晰详细的指令，来获取更符合您预期的结果。
模型具备的能力包括但不限于：
创作文字，如写故事、写公文、写邮件、写剧本、写诗歌等编写代码提供各类语言的翻译服务，如英语、日语、法语、西班牙语等进行文本润色和文本摘要等工作扮演角色进行对话制作图表 通义千问以用户以文本形式输入的指令（prompt）以及不定轮次的对话历史（history）作为输入，返回模型生成的回复作为输出。在这一过程中，文本将被转换为语言模型可以处理的token序列。Token是模型用来表示自然语言文本的基本单位，可以直观的理解为“字”或“词”。对于中文文本来说，1个token通常对应一个汉字；对于英文文本来说，1个token通常对应3至4个字母或1个单词。例如，中文文本“你好，我是通义千问”会被转换成序列[‘你’, ‘好’, ‘，’, ‘我’, ‘是’, ‘通’, ‘义’, ‘千’, ‘问’]，而英文文本"Nice to meet you."则会被转换成[‘Nice’, ’ to’, ’ meet’, ’ you’, ‘.’]。
目前(2023-12-15)API调用免费，具体截止时间还没有通知，大家赶快尝试一下！！！
官网文档：点击查看
模型概览 模型名模型简介模型输入输出限制qwen-turbo通义千问超大规模语言模型，支持中文英文等不同语言输入。模型支持 8k tokens上下文，为了保障正常的使用和输出，API限定用户输入为6k tokens。qwen-plus通义千问超大规模语言模型增强版，支持中文英文等不同语言输入。模型支持 32k tokens上下文，为了保障正常的使用和输出，API限定用户输入为 30k tokens。qwen-max （限时免费开放中）通义千问千亿级别超大规模语言模型，支持中文英文等不同语言输入。随着模型的升级，qwen-max将滚动更新升级，如果希望使用稳定版本，请使用qwen-max-1201。模型支持 8k tokens上下文，为了保障正常的使用和输出，API限定用户输入为6k tokens。qwen-max-1201 （限时免费开放中）通义千问千亿级别超大规模语言模型，支持中文英文等不同语言输入。该模型为qwen-max的快照稳定版本，预期维护到下个快照版本发布时间（待定）后一个月。模型支持 8k tokens上下文，为了保障正常的使用和输出，API限定用户输入为6k tokens。qwen-max-longcontext （限时免费开放中）通义千问千亿级别超大规模语言模型，支持中文英文等不同语言输入。模型支持 30k tokens上下文，为了保障正常的使用和输出，API限定用户输入为 28k tokens。qwen-vl-plus通义千问VL plus支持灵活的交互方式，包括多图、多轮问答、创作等能力的模型，大幅提升了图片文字处理能力，增加可处理分辨率范围，增强视觉推理和决策能力- 开通DashScope并创建API-KEY API-KEY创建说明
说明：需要通过阿里云主账号或者得到主账号AliyunDashScopeFullAccess授权的子账号进行DashScope模型服务的开通及API-KEY的创建。
开通DashScope灵积模型服务 访问DashScope管理控制台：前往控制台。
创建API-KEY 访问DashScope管理控制台API-KEY管理页面：前往API-KEY管理，然后点击“创建新的API-KEY”。
API-KEY添加至系统变量 新建用户变量输入变量名(可以自定义)：DASHSCOPE_API_KEY输入变量值(API-KEY)：直接复制
Python调用示例 import os import time import json import random from http import HTTPStatus import dashscope from dashscope import Generation from dashscope.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fbc968098491f55002aa49cdb34cef0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/925b43542ec0215b08f61140e4bb82ef/" rel="bookmark">
			【Android】系统启动流程分析 —— Zygote 进程启动过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文基于 Android 14.0.0_r2 的系统启动流程分析。
一、概述 Zygote 是 Android 系统中的一个核心进程，它在系统启动时被初始化。Zygote 的主要任务是加载系统的核心类库（如 Java 核心库和 Android 核心库），然后进入一个循环，等待请求来创建新的 Android 应用程序进程。
当一个新的 Android 应用程序需要启动时，Zygote 会 fork 出一个新的进程，这个新的进程继承了 Zygote 的内存空间，包括已经预加载的类库。这种方式可以大大提高新进程的启动速度，因为不需要再次加载这些类库。
Zygote 进程是所有 Android 应用程序进程的父进程，它的启动和初始化对于 Android 系统的运行至关重要。
二、源码分析 在 init.rc 文件中会执行 class_start main 来启动 Zygote，源代码如下：
路径：/system/core/rootdir/init.rc on nonencrypted class_start main class_start late_start 这个 main 就是 Zygote，可以通过 init.zygote64.rc 来查看，源代码如下：
路径：/system/core/rootdir/init.zygote64.rc // 定义了一个名为 zygote 的服务，它运行的是 /system/bin/app_process64 可执行文件。 // “-Xzygote” 参数指定了这是一个 Zygote 进程，用于启动 Android 应用进程和系统服务。 // “--zygote” 标志表明这是一个 Zygote 服务实例。 // “--start-system-server” 意味着在 Zygote 启动时同时启动系统服务。 service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote // 指定服务所属的主要控制类，即在 init 进程中优先启动。 class main // 设置服务启动的优先级为-20（数值越低，优先级越高）。 priority -20 // 指定服务运行时的用户和组，这里是 root 用户，以及包含 root 组和其他两个附加权限组 readproc 和 reserved_disk。 user root group root readproc reserved_disk // 创建两个命名 socket。 // zygote socket 用于与系统进行通信，以便请求创建新的应用程序进程。 // usap_pool_primary 用途可能与进程间通信或资源池管理有关。 socket zygote stream 660 root system socket usap_pool_primary stream 660 root system // 定义了一系列在 zygote 服务重启时执行的操作。 onrestart exec_background - system system -- /system/bin/vdc volume abort_fuse onrestart write /sys/power/state on onrestart write /sys/power/wake_lock zygote_kwl onrestart restart audioserver onrestart restart cameraserver onrestart restart media onrestart restart media.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/925b43542ec0215b08f61140e4bb82ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b3f1c10e8a2e54f1f28e12c1e52a3e0/" rel="bookmark">
			SD(Stable Diffusion) 简易教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近给家里的小朋友用 SD(Stable Diffusion) 生成卡通头像，顺便记录一下 SD 的基础使用教程。
教程目录 SD 安装与部署
认识模型和插件
基础使用教程
SD 安装与部署 SD 安装和部署可以分为本地和云端。本地安装对电脑配置有一些基本要求，云端安装对电脑要求不高，但是云端服务商会收取使用费用，两种方法各有优劣。
本地电脑安装配置最核心的关键点：显卡、内存、硬盘、CPU。其中最重要的是显卡。
显卡：N卡（英伟达Nvida独立显卡）首选，效率远超集显/AMD/Intel显卡和CPU渲染，最低10系起步，体验感佳用40系，显存最低4G。建议 3060 8G 以上。
内存：内存最低8G，越大越好。
硬盘：建议使用固态硬盘，可以加快模型加载、切换速度。
系统：支持 Win10/Win11/macOS（仅限Apple Silicon，Intel 版本的 Mac 无法调用 Radeon 显卡）和 Linux 系统，苹果版 SD 兼容的插件数量较少，功能性不及 Windows 与 Linux 电脑。
如果没有合适的电脑可以考虑购买使用云端主机。若无法使用独立显卡和云服务，也可修改本地软件启动配置，使用CPU渲染（兼容性强，出图速度慢，需要16G以上内存）。或者使用第三方免费的体验产品。比如 LibLib ，每天可以免费生成 100 张图片。
本地安装与部署 目前普遍采用的 SD UI 是 Github 上的 Python 项目，在使用时需要对项目项目在不同的电脑和系统上编译源码，这需要使用者拥有一定的程序开发经验，所以这里我们直接使用 B 站秋叶大佬的整合包，直接安装使用。
1**.软件下载
**百度网盘：https://pan.baidu.com/s/1dl_ON9Yb4En8hW9WsicEng?pwd=y8cb 提取码: y8cb
2**.软件安装**
- 下载后，解压文件，首先安装运行依赖。
- 解压 sd-webui-v4.2
在刚刚解压的文件夹内找到启动器，双击后可以启动。
软件启动后，点击右下角的 “一键启动” 。
点击后会跳出如下界面，等待加载一段时间后，会自动跳转到网页操作页面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b3f1c10e8a2e54f1f28e12c1e52a3e0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/454/">«</a>
	<span class="pagination__item pagination__item--current">455/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/456/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>