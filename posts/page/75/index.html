<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1060dbf463d7c9ce1b1c9b5c49d9efdc/" rel="bookmark">
			C 和 C&#43;&#43; 中信号处理简单介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		信号处理是编程中一个重要的主题，特别是在需要处理异步事件和错误情况的系统中。在 C++ 和 C 语言中，信号处理机制提供了一种优雅的方式来响应特定的系统事件，例如用户中断、异常情况或其他信号。在这里，我将详细介绍 C 和 C++ 中信号处理的概念、用法和示例。
1. 信号的基本概念 信号是由操作系统或硬件事件触发的通知，表示某种特定的事件已经发生。常见的信号包括：
SIGINT：终端中断（通常由 Ctrl+C 触发）。SIGTERM：请求程序终止。SIGSEGV：无效内存引用（段错误）。SIGFPE：算术运算错误（例如除以零）。 2. C 和 C++ 中的信号处理 在 C 和 C++ 中，信号处理主要通过以下两个方面实现：
注册信号处理函数响应信号事件 使用标准库 &lt;signal.h&gt; 来处理信号。
3. 信号处理函数 信号处理函数是特定类型的函数，用于响应特定信号。这些函数不能接受任何额外参数，并且通常不返回值（返回类型是 void）。它们的签名如下：
void signal_handler(int signum); 4. 常用的信号处理函数 使用 signal() 函数或 sigaction() 来注册信号处理函数：
a. 使用 signal() #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;signal.h&gt; #include &lt;unistd.h&gt; void signal_handler(int signum) { printf("Caught signal %d\n", signum); exit(signum); } int main() { // 注册信号处理函数 signal(SIGINT, signal_handler); // 捕捉 Ctrl+C while (1) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1060dbf463d7c9ce1b1c9b5c49d9efdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ee1ae7027b6f649ed5c9dd0cde20969/" rel="bookmark">
			html&#43;css前端作业和平精英2个页面（无js）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 html+css前端作业和平精英2个页面（无js）有视频播放器等功能效果 网页作品代码简单，可使用任意HTML编辑软件（如：Dreamweaver、HBuilder、Vscode 、Sublime 、Webstorm、Text 、Notepad++ 等任意html编辑软件进行运行及修改编辑等操作）。 获取源码 1，访问该网站 https://download.csdn.net/download/qq_42431718/89608232
2，点击上方下载
目录1 目录2 项目视频 和平精英2个页面（无js）带视频播放
页面1 页面2 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a635475a93a80c82d7121558f6d0d78/" rel="bookmark">
			small bird
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		this-&gt;setWindowFlags(Qt::FramelessWindowHint);//去掉标题栏 // Translucent 透明化 this-&gt;setAttribute(Qt::WA_TranslucentBackground); //窗口透明化 // this-&gt;setWindowFlags(this-&gt;windowFlags() | Qt::WindowStaysOnTopHint);//设置窗口最顶层 this-&gt;setWindowIcon(abc);//设置窗口图标 “用鼠标全局坐标的位置减去父窗口的左上角位置”，这正是这段代码所做的。这种计算方式常用于实现拖拽窗口的功能，特别是当窗口没有标准的标题栏时。通过这种方式，你可以确定鼠标相对于父窗口的位置，进而实现拖拽窗口的功能 event-&gt;globalPos(): 获取鼠标光标在全局坐标系中的位置。 ((QWidget*)this-&gt;parent())-&gt;frameGeometry().topLeft(): 获取父窗口左上角的位置。 event-&gt;globalPos() - ((QWidget*)this-&gt;parent())-&gt;frameGeometry().topLeft(): 计算鼠标光标在全局坐标系中的位置与父窗口左上角位置之间的差值。 m_pos = ...: 将计算得到的差值赋给 m_pos，m_pos 是一个 QPoint 类型的成员变量，表示鼠标光标相对于父窗口左上角的位置。 void Bird_::mouseMoveEvent(QMouseEvent *event) { //获取窗口的gai变量 this-&gt;m_pos= event-&gt;globalPos()-this-&gt;m_pos; emit aftermove(m_pos); // } //((QWidget*)this-&gt;parent())-&gt;frameGeometry().topLeft(); 获取当前窗口左上角的坐标 void Bird_::mousePressEvent(QMouseEvent *event) { //用鼠标全局坐标的位置减去父窗口的左上角位置 m_pos = event-&gt;globalPos() - ((QWidget*)this-&gt;parent())-&gt;frameGeometry().topLeft(); } if(this-&gt;auto_pos.x()&gt;QGuiApplication::primaryScreen()-&gt;geometry().width())
{
this-&gt;auto_pos.setX(-this-&gt;width());
// 需要减去一个尺寸从屏幕左边飞过来 //超出屏幕 x设为 窗口的-宽度
}
当前位置 为屏幕的尺寸的宽度就可 到达最右侧 将 x置为最左侧的-1倍
bird.cpp 及 bird.h
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a635475a93a80c82d7121558f6d0d78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eba283f8cd18d0d8c755618c7a593526/" rel="bookmark">
			C:初识指针—学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：
1、内存和地址
1.1 理解内存和地址
1.2 理解编址
2、指针变量和地址
2.1 取地址操作符：&amp;
2.2 指针变量
2.3 如何拆解指针类型
2.4 解引用操作符（*）
2.5 指针变量的大小
3、指针变量类型的意义
3.1 指针的解引用
3.2 指针+-整数
4、void* 指针
结语：
前言： 谈及指针，大部分人只有一个感觉：太难学了，好抽象啊！但是，请不要着急，今天当你看完这一篇后，相信你肯定能够理解什么是指针了。
1、内存和地址 1.1 理解内存和地址 在介绍指针前，我们需要先了解什么是内存和地址。
关于内存和地址，生活中有一个例子可以很好的解释它们
比如说你住在一栋宿舍楼，大楼内有100个房间，但是房间并没有编号。这时，你的一个朋友来找你玩，如果想找到你，就得一个房间一个房间的寻找，这样效率很低。但是，如果我根据楼层和楼层的房间的情况，给每一个房间都编上号，比如：
1楼：101 102 103……
当有了门牌号，这时候你只需要将门牌号告诉你朋友，他就可以很快速的找到房间，找到房间里的你。
如何将上面的例子抽象到计算机里呢？你可以理解宿舍楼就是内存，房间就是内存中的一个内存单元，房间里的你就是数据，而门牌号就是地址。
所以内存就是存储数据的空间
我们知道计算机上CPU（中央处理器）在处理数据的时候，需要的数据是在内存中读取的，处理后的数据也会放回内存中，那我们买电脑的时候，电脑上内存是8GB/16GB/32GB等，那这些内存空间如何高效的管理呢？
cpu从内存中读取数据，就好比是你朋友要在宿舍楼里找到你，而你朋友找你，也只是在一个个房间寻找。大楼里的一个一个房间的划分，让人们对大楼内的面积能够充分利用，而计算机中也是如此。内存的空间只有8GB/16GB/32GB，因此对于内存的合理运用也变的很重要。
计算机中把内存也划分为一个个的内存单元，每个内存单元的大小取1字节。
（补充）计算机中常见的单位：
一个bit可以存储一个2进制位的1和0
地址（门牌号）内存（大楼）其中，每个内存单元，相当于⼀个学⽣宿舍，一
个字节空间里面能放8个比特位，就好比同学们住
的八⼈间，每个人是⼀个比特位。0xFFFFFFFF（16进制）1个字节0xFFFFFFFE1个字节1个字节 每个内存单元也都有⼀个编号（这个编号就相当
于宿舍房间的门牌号），有了这个内存单元的编
号，CPU就可以快速找到⼀个内存空间。
（内存单元） 生活中我们把门牌号也叫地址，在计算机中我们
把内存单元的编号也称为地址，
C语言中给地址起了新的名字叫：指针
1个字节0x000000011个字节0x000000001个字节 所以我们可以理解为：
内存单元的编号 == 地址 == 指针
1.2 理解编址 生活中关于我们可以看到通过宿舍门上的门牌号，直接找到我们想去的地方。门牌号是真实存在与宿舍门上的。而内存中的地址我们该怎么理解呢？
计算机中的编址，并不是把每个字节的地址记录下来，而是通过硬件设计完成的。
这就像钢琴，吉他上面没有刻上“剁、来、咪、发、 唆、拉、西”这样的信息，但演奏者照样能够准 确找到每⼀个琴弦的每⼀个位置，这是为何？因为制造商已经在乐器硬件层面上设计好了，并且 所有的演奏者都知道。本质是⼀种约定出来的共识！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eba283f8cd18d0d8c755618c7a593526/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0354d983ad9298208a09c09c3d664f2a/" rel="bookmark">
			vue&#43;elementui 表格分页限制最大页码数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue3+element-plus ：
在组件里直接使用page-count属性，在获取数据的时候测试一下总条数/每页数量向上取整是否大于1000，是默认count为1000，否则使用计算后的值；
vue2 + elementui
el-pagination ：total与page-count同时使用page-count不生效，使用page-count属性：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/856b2463c7f0f4384171507664d5b54b/" rel="bookmark">
			Python爬虫入门实战（详细步骤）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 技术选型 爬虫这个功能，我个人理解是什么语言都能写的，只要能正常发送 HTTP 请求，将响应回来的静态页面模版 HTML 上把我们所需要的数据提取出来就可以了，原理很简单，这个东西当然可以手动去统计收集，但是网络平台毕竟还是很多的，还是画点时间，写个爬虫把数据爬取下来，存到数据库里，然后写一个统计报表的 SQL 语句比较方便，后续如果有时间的话，我会写一个简单的前后端分离的报表样例分享出来。
网上现在 Python 爬虫的课程非常的火爆，其实我心里也有点小九九，想玩点骚操作，不想用老本行去写这个爬虫，当然最后的事实是证明确实用 Python 写爬虫要比用 Java 来写爬虫要简单的多。
2. 环境准备 首先笔者的电脑是 Win10 的，Python 选用的是 3.7.4 ，貌似现在网上 Python3 的爬虫教程并不多，其中还是遇到不少的问题，下面也会分享给大家。
开发工具笔者选用的是 VSCode ，在这里推荐一下微软这个开源的产品，非常的轻量化，需要什么插件自己安装就好，不用的插件一律不要，自主性非常高，如果感觉搞不定的朋友可以选择 JetBrains 提供的 Pycharm ，分为社区版和付费版，一般而言，我们使用社区版足矣。
笔者这里直接新建了一个文件夹，创建了一个名为 spider-demo.py 的文件，这个就是我们一会要写的爬虫的文件了，可以给大家看下笔者的开发环境，如下：
这其实是一个调试成功的截图，从下面打印的日志中可以看到，笔者这里抓取了三个平台的数据。
3. 数据库 笔者使用的数据是 Mysql 5.7.19 版本，数据库的字符集是使用的 utf8mb4 ，至于为什么使用 utf8mb4 而不是 utf8 ，各位百度一下吧，很多人讲的都比我讲的好，我简单说一句就是 Mysql 的 utf8 其实是一个假的 utf8 ，而后面增加的字符集 utf8mb4 才是真正的 utf8 。
而 Python 连接 Mysql 也是需要驱动的，和在 Java 中连接数据库需要驱动一样，这里使用的是 pymysql ，安装命令：
pip install pymysql 有没有感觉很简单， pip 是 Python 的一个包管理工具，我的个人理解是类似于一个 Maven 的东西，所有的我们需要的第三方的包都能在这个上面下载到。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/856b2463c7f0f4384171507664d5b54b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86187cd5372e1ca5c049b1d8f67de5e6/" rel="bookmark">
			ASP.Net Core设置接口根路径的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用asp.net core开发微服务项目，需要给每个服务设置不同的根路径，这样既能使用网关转发请求，又方便对单个服务进行测试，保证请求路径的统一。
设置方法需要使用中间件，在Program.cs添加如下代码
app.UsePathBase("/acl"); app.MapControllers(); app.Urls.Add("http://0.0.0.0:8081"); app.Run(); 其中，UsePathBase方法添加了一个中间件，设置所有请求的根路径是acl，要注意中间件添加的位置，在MapControllers方法前面，才能生效。
但是，这样做了以后，swagger相关的接口路径并没有发生变化。也就是说，所有的接口都对应两个请求路径，一个是以acl开头的路径，另一个是swagger里面的请求路径。如果想让swagger的接口路径都加上相同的前缀，需要改成如下代码
if (app.Environment.IsDevelopment()) { app.UseSwaggerUI(options =&gt; { options.RoutePrefix = "acl"; options.SwaggerEndpoint("swagger/v1/swagger.json", "system"); }); app.UsePathBase("/acl"); app.UseSwagger(); app.UseCors(builder =&gt; builder.AllowAnyOrigin().AllowAnyMethod().AllowAnyHeader()); } else { app.UsePathBase("/acl"); } app.MapControllers(); app.Urls.Add("http://0.0.0.0:8081"); app.Run(); 重点是这一部分
app.UseSwaggerUI(options =&gt; { options.RoutePrefix = "acl"; options.SwaggerEndpoint("swagger/v1/swagger.json", "system"); }); app.UsePathBase("/acl"); app.UseSwagger(); 这样一来，swagger的接口路径也都带有acl前缀了。
访问http://localhost:8081/acl/index.html，就能打开swagger的页面，可以看到，请求路径已经变了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8890595af9aef25b6b76ae61914bd88a/" rel="bookmark">
			Flutter 学习 一部分注意点记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用AndroidStudio进行开发
假设你已经配置好Flutter和dart的SDK.
创建一个可执行dart文件 如果需要直接新建一个dart文件来运行，可以点击 File-&gt;New-&gt;New Flutter Project ，下面是接下来弹出的新建项目弹窗，选中左边的Dart，点击右下角的Next。
接下来需要新建目录和dart文件如下结构，具体操作是是"右键-&gt;New-&gt;Directory" 和"右键-&gt;New-&gt;Dart File 命名文件"
打开AS左下角的Dart Analysis的设置，然后勾上Scope Analysis to the Current Package
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99e718f04a94af397c5faea3eece4f05/" rel="bookmark">
			第12节课：本地存储与应用缓存——提升离线体验和性能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 本地存储：`localStorage`和`sessionStorage``localStorage`使用`localStorage` `sessionStorage`使用`sessionStorage` 本地存储的应用场景 应用缓存：通过Manifest定义应用缓存概述创建和使用应用缓存应用缓存的限制和替代方案 实践：使用本地存储和应用缓存示例：使用`localStorage`保存用户偏好设置示例：使用应用缓存 结语 随着Web应用的日益复杂化，用户期望获得更快的加载速度和更好的离线体验。HTML5引入了本地存储和应用缓存功能，以满足这些需求。本节课将详细介绍localStorage、sessionStorage以及应用缓存（通过manifest文件），探讨它们如何帮助提升Web应用的性能和用户体验。
本地存储：localStorage和sessionStorage localStorage localStorage提供了一种方式，允许Web应用在用户浏览器中存储数据，直到显式地清除它们。数据以字符串的形式存储，没有时间限制。
使用localStorage 存储数据：localStorage.setItem('key', 'value');检索数据：localStorage.getItem('key');删除数据：localStorage.removeItem('key');清除所有数据：localStorage.clear(); sessionStorage 与localStorage类似，sessionStorage也用于存储数据，但它提供了会话级别的存储，即数据仅在页面会话期间有效，关闭浏览器标签后数据即被清除。
使用sessionStorage 存储数据：sessionStorage.setItem('key', 'value');检索数据：sessionStorage.getItem('key');删除数据：sessionStorage.removeItem('key');清除所有数据：sessionStorage.clear(); 本地存储的应用场景 用户偏好设置：存储用户的主题选择、字体大小等偏好设置。表单数据：自动填充表单或在提交前保存数据。应用程序状态：保存游戏进度或应用的当前状态。 应用缓存：通过Manifest定义 应用缓存概述 应用缓存（AppCache）允许Web应用在用户设备上存储资源，以便在没有网络连接时也能访问这些资源。通过一个manifest文件，开发者可以列出需要缓存的资源。
创建和使用应用缓存 创建manifest文件：创建一个名为manifest.appcache的文件，列出所有需要缓存的资源。
CACHE MANIFEST # 版本号 v=1.0 CACHE: index.html style.css script.js NETWORK: resourse.php 在HTML中引用manifest：
&lt;html manifest="manifest.appcache"&gt; 应用缓存的生命周期：包括下载、安装、使用和更新。
应用缓存的限制和替代方案 由于一些兼容性和使用上的问题，应用缓存已逐渐被废弃。现代Web开发倾向于使用服务工作线程（Service Workers）来实现更灵活的离线体验。
实践：使用本地存储和应用缓存 示例：使用localStorage保存用户偏好设置 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;本地存储示例&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button id="saveTheme"&gt;保存主题&lt;/button&gt; &lt;script&gt; document.getElementById('saveTheme').addEventListener('click', function() { var userTheme = 'dark'; // 假设用户选择了深色主题 localStorage.setItem('theme', userTheme); alert('主题已保存！'); }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 示例：使用应用缓存 创建manifest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99e718f04a94af397c5faea3eece4f05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/701488ddfa2eded7b983ddaec4bb3659/" rel="bookmark">
			JVM的面试考点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JVM内存划分 1.堆,整个内存区域中,内存最大的区域,放的都是new出来的对象,new+类名这一部分存放在堆中,
而这个scanner是一个临时变量,这个scanner的地址存放在栈上,scanner里面存放的值是new+类名这个对象的首地址
2.栈,分为JVM虚拟机栈(Java代码),和本地方法栈(C++),这个栈包含了方法的调用关系
3.元数据区(以前叫做方法区),放的是类对象,代码中的每个类,在JVM上运行的时候,都会有对应的类对象,Text.class还存放了方法相关的信息,类有一些方法,每个方法都代表了一系列的"指令集合"(JVM指令集合)
4.程序计数器,是内存区域中最小的一个区域,只需要保存,当前要执行的下一条指令(JVM字节码)的地址,这个地址就是元数据区里面的一个地址,JVM的PC保存的地址是JVM字节码的地址
关于内存中的地址划分
内存存放基本原则:1)局部变量,堆上
2)成员变量,堆上
3)静态成员变量 方法区/元数据区
上述四个区域中,堆和元数据区,是整个进程只有一份,栈和程序计数器是每个线程都有,多个线程同享一份数据,每个线程的局部变量,不是共享的,每个线程有自己的一份
类加载的过程 当前写的Java代码,是.java文件(硬盘),一个Java进程要跑起来,需要执行cpu指令,通过字节码让JVM翻译出来,就需要把.java文件变为.class文件(硬盘),再加载到内存上,得到类对象
重要过程
1.加载:在硬盘上,找到对应的.class文件,读取文件内容
2.验证:检查.class里的内容,是否符合要求,把读取出来的内容,往这个格式里套,看能不能套进去
u4是unsigned int 无符号的int u2是unsigned short 无符号的short
3.准备:给类对象,分配内存空间(在元数据区中),类加载最终要得到的就是类对象,会先把这个空间里的数据全填为0
4.解析:针对字符串常量进行初始化,把刚才.class文件中的常量内容取出来,放到元数据区
5.初始化:针对类对象中的各部分进行初始化(不是针对对象初始化,与构造方法无关)
双亲委派模型 这是一个类加载的机制,根据代码中写的"全限定类名"(包名+类名,例如Java.lang.String)找到对应的.class文件
这个模型描述了JVM加载.class文件过程中,找文件的过程,这个模型中内置了三个类加载器,在JVM中包含了一个特定的模块/类,这个类负责完成后续类加载的工作
JVM中内置了三个类加载器(负责加载不同的类)
1.BootStrapClassLoader,负责加载标准库的类,这个类是Java官方给出的"标准类",
2.ExtentionClassLoader,负责加载JVM扩展库的类
3.ApplicationClassLoader,负责加载第三方库的类和你自己写代码的类
三者之间的关系
此处的父子关系,不是通过类的继承表示的,而是通过类加载器中有一个"parent"这样的字段,指向自己父亲的地址,类似于二叉树的三叉实现
工作过程如下:例如给定一个全限定类名,Java.Test,此时加载过程如下
1.工作从ApplicationClassLoader开始进行,这个类加载器并不会立即从第三方库/自己写的代码开始搜索,而是交给自己的父亲ExtentionClassLoader去处理
2.工作就到了.ExtentionClassLoader,这个类加载器也不会立即从JVM扩展库开始搜索,而是交给自己的父亲BootStrapClassLoader去处理
3.工作就到了BootStrapClassLoader,这个类加载器,也不会立即从标准库中开始搜索,而是继续交给自己的父亲,由于自己的父亲为null,只能自己来处理,BootStrapClassLoader尝试在标准库的路径上开始搜索,如果这个类找到了,搜索过程完成,然后打开文件进行后续操作,如果没找到则交给自己的儿子来进行处理,
4.工作回到了.ExtentionClassLoader这个类加载器尝试在JVM扩展库的路径上开始搜索,如果这个类找到了,搜索过程完成,然后打开文件进行后续操作,如果没找到则交给自己的儿子来进行处理,
5.工作回到了ApplicationClassLoader,这个类加载器尝试在第三方库/自己写的代码中的路径上开始搜索,如果这个类找到了,搜索过程完成,然后打开文件进行后续操作,如果没找到则交给自己的儿子来进行处理,由于它的儿子为null,所以会抛出一个异常ClassNotFoundException
上述工作流程,主要应对这个场景,如果自己写的一个类和标准库/扩展库中的类冲突了,此时JVM就会确保标准库/扩展库的类加载成功,
类加载器并非只有三个,还可以手动写更多的类加载器,添加到中间
JVM的垃圾回收机制GC 垃圾回收机制,是Java提供的对于自动回收的机制,自动回收相对于C++的手动回收来命名的,C++回收需要手动free函数,可能会遗漏这个操作,
GC需要消耗额外的系统资源,而且存在非常影响效率的"STW"(stop the world)问题,GC回收的是内存,更准确的说是"对象",回收的是堆上的内存
1)程序计数器(不需要额外回收,线程销毁,自然就回收了)
2)栈(不需要额外回收,线程销毁,自然回收)
3)元数据区(一般也不需要,都是加载类,很少有"卸载类")
4)堆(GC回收的主力军)
一定是一次回收一个完整的对象,把对象中的成员全都回收
JAVAGC机制有一个方法,GC机制有两个方法
GC的主要流程
1.找到谁是垃圾,不被继续使用的对象
使用对象都是通过引用的方式来使用,如果没有引用指向这个对象,意味着这个对象注定无法在代码被使用,被视为垃圾了,对于JVM来说不是实时的,JVM需要一定的时间周期
如何判断某个对象是否有引用指向呢?
1)引用计数(不是JVM的方案,是Python和PHP的方案)
当引用计数为0时,这个对象就是垃圾了
缺陷如下:
1)消耗额外的存储空间:如果对象的空间比较大,浪费的空间很小,但是如果对象的空间比较小,浪费的空间就会特别大了
2)存在"循环引用"的问题
2)可达性分析(是JVM采取的方案)
解决了空间问题,也解决了循环引用的问题,但是时间上效率变慢,通过"遍历",JVM把对象之间的引用关系,理解成一个"树形结构",JVM就会不停的遍历这个结构,把所有能够访问到的对象标记成"可达",剩下的就是"不可达"
2.释放对应的内存
由于可达性分析,需要消耗一定的时间,因此,JAVA垃圾回收,没法做到实时性,会周期性进行扫描(JVM提供了一组专门负责GC的线程,不停的进行扫描工作)
清理垃圾的策略:
1)标记-清除,直接把视为垃圾的对象对应的内存给释放掉,这样的做法会造成内存碎片化,后续很难申请到连续的空间,申请内存都是需要连续的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/701488ddfa2eded7b983ddaec4bb3659/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f64d02916ffd4472324f871afb9d1650/" rel="bookmark">
			腾讯云AI代码助手评测：如何智能高效完成Go语言Web项目开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		腾讯云AI代码助手评测：如何智能高效完成Go语言Web项目开发 🚀 文章目录 腾讯云AI代码助手评测：如何智能高效完成Go语言Web项目开发 🚀背景引言开发环境介绍腾讯云AI代码助手使用实例1. 代码补全2. 技术对话3. 代码优化4. 规范代码5. Bug处理 获得的帮助与提升建议更多玩法结语 背景 腾讯云AI代码助手是一款辅助编码工具，基于混元代码大模型，提供技术对话、代码补全、代码诊断和优化等能力。它可以为开发者生成优质代码，解决技术难题，提升编码效率。
支持补全语言： 支持Go, Python, JavaScript/TypeScript, Java, C/C++, C#, Lua, Kotlin, Vue, Proto, PHP, Rust、Swift、Shell、Dart、YAML等100+编程语言。支持IDE编辑器：Visual Studio Code，JetBrains 系列IDE(如GoLand、IntelliJ IDEA、PyCharm、Android Studio等)（即将上线Vim/Xcode）。 👉体验地址：
点击进入产品官网，在线免费体验。或在Visual Studio、JetBrains 系列等IDE插件市场手动搜索「腾讯云 AI 代码助手」下载安装。 腾讯云AI代码助手让编程变得更简单，无论你是编程高手还是新手，都可以成为我们的「AI编程达人」！
引言 在Go语言开发中，如何提升编码效率和代码质量一直是开发者们关注的重点。今天，猫头虎将为大家展示如何利用腾讯云AI代码助手完成一个Go语言Web项目，通过实际案例展示其强大功能。📈
开发环境介绍 在本次评测中，开发环境如下：
编程语言：GoIDE：GoLand操作系统：Mac OS 首先，在GoLand的插件市场搜索并安装了“腾讯云AI代码助手”。安装完成后，进行了基本配置，使其能够正常工作。以下是安装和配置步骤的简要介绍：
打开GoLand，进入插件市场。搜索“腾讯云AI代码助手”并安装。 重启GoLand，完成插件配置。 5. 重启完成之后需要授权登陆一下插件，如下图所示：
接下来，我们就可以正式开始我们的腾讯云AI代码助手上手体验啦。
腾讯云AI代码助手使用实例 在这个案例中，我们将开发一个简单的Web服务器，提供基本的HTTP服务。项目包括启动服务器、处理HTTP请求和响应、以及日志记录等功能。具体步骤如下：
1. 代码补全 问题描述： 开发过程中，我们需要启动一个基本的HTTP服务器。以往手动编写代码不仅耗时，还容易出错。
使用前：
手动编写启动服务器的代码如下：
package main import ( "fmt" "html" "net/http" ) func main() { http.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f64d02916ffd4472324f871afb9d1650/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ca8b4eb710663b18339b6dd715b3b7d/" rel="bookmark">
			回溯组合篇--代码随想录算法训练营第二十一天| 回溯算法介绍，77. 组合，216.组合总和III，17.电话号码的字母组合，39. 组合总和，40.组合总和II
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回溯算法介绍 回溯算法理论基础https://www.programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80
终止条件：达到树最大深度 &amp;&amp; 满足题目额外条件
void backtracking(参数) { if (终止条件) { //常常跟树的深度有关 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { //某一层的宽度 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 77. 组合 题目链接：. - 力扣（LeetCode） 讲解视频： 未优化：带你学透回溯算法-组合问题（对应力扣题目：77.组合） 优化：组合问题的剪枝操作
题目描述： 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。
你可以按 任何顺序 返回答案。
示例 1：
输入：n = 4, k = 2 输出： [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] 解题思路： 树的宽度：1~n n个数
树的最大深度：k个数组合
额外条件：无
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ca8b4eb710663b18339b6dd715b3b7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79b3c3b1c92da33596ed3403dd2d12f6/" rel="bookmark">
			Unity强化工程 之 SpriteShape（精灵地形编辑器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文仅作笔记学习和分享，不用做任何商业用途
本文包括但不限于unity官方手册，unity唐老狮等教程知识，如有不足还请斧正
1.什么是SpriteShape？ SpriteShape 是一个灵活且功能强大的世界构建资源，它可以沿着形状的轮廓进行精灵平铺，根据轮廓的角度自动变形并交换精灵。此外，还可以为 SpriteShape 分配填充纹理，以创建具有平铺纹理的填充形状，作为背景或其他大型关卡构建道具
在包管理器内搜索安装可以安装示范样例（samples）以查看功能
2.关键内容 Sprite Shape Profile Sprite Shape Profile 包含了决定哪些精灵在特定角度范围内出现在 Sprite Shape 上的设置，以及其他显示设置
说白了，就是一个精灵形状配置文件
创建一个Sprite Shape Profile，并了解其功能：Sprite Shape Profile | 2D SpriteShape | 10.0.6 (unity3d.com)
我觉得文档写的不太好，所以找来了翻译
PS：不容忽视的一个重要的点就是随着该包的更新
sprite shape profile创建时已经不会包括封闭和开放图形选项了，那么封闭图形就可以单独创建一个配置文件
在需要创建角度范围的地方会弹出click to add a new range选项
需要的时候可以在层级窗口创建开放/封闭图形
将配置文件拖拽挂载使用
实际效果：
Sprite Shape Render Sprite Shape Renderer - Unity 手册
这些内容和sprite renderer神似，所以不做赘述 Unity强化工程 之 SpriteRender-CSDN博客
Sprite Shape Controller Sprite 形状控制器 |2D 精灵形状 |10.0.6 (unity3d.com)
Corner Threshold 就是说水平和临边线夹角大于该值才会出现角度填充内容
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79b3c3b1c92da33596ed3403dd2d12f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5afb1a986218c761a234c236ecb1c89b/" rel="bookmark">
			OceanBase VS Doris 对比分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OceanBase与Doris在多个方面存在显著的差异，这些差异主要体现在它们的设计目标、应用场景、性能特点、架构以及兼容性等方面。以下是对两者的详细对比：
一、设计目标与应用场景 OceanBase
设计目标：OceanBase是由蚂蚁金服、阿里巴巴完全自主研发的分布式关系型数据库，旨在提供高性能、高可用、强一致、可扩展和低成本的数据存储解决方案。应用场景：OceanBase广泛应用于金融、证券等对高可用、强一致要求特别高的场景，以及对性能、成本和扩展性有需求的金融属性场景。同时，它也支持各种关系型结构化存储的OLTP应用。 Doris
设计目标：Doris（原名Apache Doris）是一个用于商业智能（BI）的开源MPP（大规模并行处理）数据库系统，专注于构建数据仓库和进行数据分析。应用场景：Doris适用于需要快速响应和复杂数据分析的场景，如电商的用户行为分析、金融市场的实时数据分析等。同时，它也支持大规模数据的处理和报表生成。 二、性能特点 OceanBase
高性能：采用读写分离架构，把数据分为基线数据和增量数据，其中增量数据放在内存里（MemTable），基线数据放在SSD盘（SSTable），对数据的修改都是增量数据，只写内存，性能非常高。低成本：通过数据编码压缩技术实现高压缩，降低存储成本；使用PC服务器和低端SSD，高性能降低计算成本；多租户混部充分利用系统资源。高可用：数据采用多副本存储，少数副本故障不影响数据可用性；通过“三地五中心”部署实现城市级故障自动无损容灾。 Doris
高性能：设计用于处理大规模数据，提供高并发和低延迟的查询性能。实时查询：支持接近实时的数据更新和查询。水平扩展性：可以通过增加更多节点来提升系统的处理能力。 三、架构与存储引擎 OceanBase
架构：采用Shared-Nothing架构，各个节点之间完全对等，每个节点都有自己的SQL引擎、存储引擎，运行在普通PC服务器组成的集群之上。存储引擎：基于LSM-Tree的架构，把基线数据和增量数据分别保存在磁盘（SSTable）和内存（MemTable）中。 Doris
架构：前端（FE）负责元数据管理、查询计划的生成和优化；后端（BE）负责数据存储、数据查询处理等；Broker用于数据导入和导出的组件。存储引擎：最终落盘也是SSTable的组织格式，但全列存储方式与OceanBase的行组划分有所不同。 四、兼容性 OceanBase
高兼容：兼容常用MySQL/ORACLE功能及MySQL/ORACLE前后台协议，业务零修改或少量修改即可从MySQL/ORACLE迁移至OceanBase。 Doris
易用性：支持SQL查询，与MySQL有较高的兼容性，便于用户上手和使用。 五、总结 OceanBase和Doris各有其独特的优势和适用场景。OceanBase更适合对性能、高可用、强一致和成本有较高要求的金融和OLTP应用场景；而Doris则更擅长于商业智能、数据分析以及大规模数据处理等场景。在选择时，用户应根据自己的实际需求和应用场景进行综合考虑。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ea20b629f913b692a21ea6b871c5490/" rel="bookmark">
			CSDN 僵尸粉 机器人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSDN 僵尸粉 机器人 1. 前言 不知道什么时候开始每天创作2篇就有1500流量爆光，每次都能收获一些关注和收藏，感觉还是挻开心的感觉CSDN人气还是挻可以的以前各把月一个收藏和关注都没有写的动力了。
2. 正文 后面又连接做了2天的每日创建2篇任务，连续2天每天1500流量爆光感觉不对劲了，感觉收获到关注和收藏太容易了，而且感觉关注和收藏的都没有发过评论与我有过互动感觉不是正常的用户，像是官方机器人的账号😅。
去百度看看有没有其他人有类似疑问：
CSDN上是不是有机器人点赞和收藏？原来 CSDN 都是僵尸粉！这很没劲~一万粉的时候，我爬光了我所有的粉丝，只为验证一个事情 大概特征：
评论互动与收藏/关注不是正比。只有转载文章或最近转载是几个月前，特别是最后转载时间是2021年7、8月份的。大量转载时间并且在2021年7、8月份转载过，中间间隔很长时间没有转载。 看了下别人的发文章感觉心都拔凉拔凉，我的创作动力都是机器人、僵尸粉（虽然不能百分百确定）感觉被诈骗一样，唉😮‍💨。大家试试下完成每日2篇创作任务任务，用1500流量曝光看下关闭和收藏人的情况就知道了。
此贴所有关注和收藏的我都会列出来，大家自己查看吧。
关注（关注不能看来源）：
Feng.HE喻双pner孙伟莲成楠Peter微基因WeGene律师王晶 收藏（都是该文收藏）：
华丰卫浴林剑超IvanhihiGary Wozniak婧在机器学习中Wong Kosheng 3. 总结 联系了下官方聊天，想想在问之前已经知道结果的问题实际上也没有必要在问了，但想想还是问下吧。不管是不是或者说真的有机器人官方肯定都不会承认的。
最后
想想以前刚入行就是想做一个自己的技术博客，当初技术不够做不到，但转眼5-6年过去了我也从菜鸟成为一名成熟的程序员了，在看看其他程序员写作平台，没有合适的就开始开发自己的博客站了。
有活着的吗，评论区留下言。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68d538fd30e3bcfe69df6ae2c9887427/" rel="bookmark">
			Python爬虫实战：利用代理IP爬取百度翻译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、爬取目标二、环境准备三、代理IP获取3.1 爬虫和代理IP的关系3.2 巨量IP介绍3.3 超值企业极速池推荐3.4 IP领取3.5 代码获取IP 四、爬虫代码实战4.1分析网页4.2 寻找接口4.3 参数构建4.4 完整代码 一、爬取目标 本次目标网站：百度翻译（https://fanyi.baidu.com/），输入一个关键词后返回翻译结果：
二、环境准备 Python：3.10
编辑器：PyCharm
第三方模块，自行安装：
pip install requests # 网页数据爬取 三、代理IP获取 由于百度翻译限制很严，为了能正常获取数据这里必须使用到代理IP。
3.1 爬虫和代理IP的关系 爬虫和代理IP之间的关系是相互依存的。代理IP为爬虫提供了绕过IP限制、隐藏真实IP、提高访问速度等能力，使得爬虫能够更有效地进行数据抓取。然而，在使用时也需要注意合法性、稳定性、成本以及隐私保护等问题。
3.2 巨量IP介绍 巨量IP提供免费HTTP代理IP和长效静态IP、短效IP、动态IP代理、隧道代理等服务，支持按时、按量、按时按量3种计费方式，根据业务场景需求，让套餐的选择变得更灵活：巨量IP官网
3.3 超值企业极速池推荐 博主经常写爬虫代码使用的是巨量IP家的企业极速池，每日500万去重IP，单IP低至0.005元 （按量计费），并且充值加赠50%，不得不说真的很香：
经常使用爬虫的小伙伴推荐使用IP时效：1分钟的套餐性价比超高。
3.4 IP领取 巨量IP还提供每日1000个免费IP供大家使用：代理IP免费领取
3.5 代码获取IP 1、点击产品管理找到我们 购买或者领取 的套餐：
2、将自己电脑的IP添加为白名单能获取代理IP，点击授权信息：
3、依次点击修改授权》快速添加》确定
4、添加完成后，点击生成提取链接：
5、设置每次提取的数量，点击生成链接，并复制链接：
6、将复制链接，复制到地址栏就可以看到我们获取到的代理IP了：
7、代理获取IP（注意：下面url需要换成你的链接）：
import requests import time import random def get_ip(): url = "这里放你自己的API链接" while 1: try: r = requests.get(url, timeout=10) except: continue ip = r.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68d538fd30e3bcfe69df6ae2c9887427/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f23eebeb65dbb31ffb9d773a11918165/" rel="bookmark">
			Redis数据失效监听
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、配置Redis开启
打开conf/redis.conf 文件，添加参数：notify-keyspace-events Ex
二、验证配置
步骤一：进入redis客户端：redis-cli步骤二：执行 CONFIG GET notify-keyspace-events ，如果有返回值证明配置成功，如果没有执行步骤三步骤三：执行CONFIG SET notify-keyspace-events "Ex"，再查看步骤二是否有值 三、两个类
package com.ciih.autopaddleGetway.config.redis; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.connection.RedisConnectionFactory; import org.springframework.data.redis.listener.RedisMessageListenerContainer; import javax.annotation.Resource; @Configuration public class RedisConfig { @Resource private RedisConnectionFactory redisConnectionFactory; @Resource private RedisKeyExpirationListener redisExpiredListener; @Bean public RedisMessageListenerContainer redisMessageListenerContainer() { RedisMessageListenerContainer redisMessageListenerContainer = new RedisMessageListenerContainer(); redisMessageListenerContainer.setConnectionFactory(redisConnectionFactory); //监听所有key的过期事件 redisMessageListenerContainer.addMessageListener(redisExpiredListener, redisExpiredListener.getTopic()); return redisMessageListenerContainer; } } package com.ciih.autopaddleGetway.config.redis; import lombok.Data; import org.springframework.data.redis.connection.Message; import org.springframework.data.redis.connection.MessageListener; import org.springframework.data.redis.listener.PatternTopic; import org.springframework.stereotype.Component; @Data @Component public class RedisKeyExpirationListener implements MessageListener { //监听的主题(只监听redis数据库1，如果要监听redis所有的库，把1替换为*) public final PatternTopic topic = new PatternTopic("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f23eebeb65dbb31ffb9d773a11918165/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac396dcf8bbc30d459594091451a570f/" rel="bookmark">
			MySQL的安装&amp;数据库的简单操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💎所属专栏： MySQL
💎1. 数据库相关概念 数据库：存储数据的仓库，数据是有组织的进行存储
数据库管理系统：操纵和管理数据库的大型软件
SQL:操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准
关系型数据库：建立在关系模型的基础上，由多张相互连接的二维表组成的数据库
💎2. MySQL的安装与配置 MySQL的安装过程相对简单，可以从MySQL官网下载适合你操作系统的安装包，并按照向导完成安装。
下面来介绍一下MySQL的全局配置文件my.ini，基本上都是在下面这个路径中的
当MySQL启动的时候会读取这个文件中的内容，作为启动的默认值，所以每次改动这个文件之后都要重启一下MySQL的服务，以便配置生效
打开这个文件之后首先可以看到[client]的板块，所有的mysql客户端程序的配置都在这个节点下
port = 3306 也就是MySQL服务开启的默认端口号，如果需要修改的话修改为1025-65535之间的值
之后的[mysql]也就是只针对mysql单独的客户端程序的配置，接着是[mysqld]
接下来的这个目录存储的是一些数据，如果放在C盘费空间的话可以修改为其他目录
修改方法：把原来的Data文件夹整体复制一份，粘贴到需要存放的位置，再自定义文件夹名字 接下来这个是默认的存储引擎
然后是一些日志相关的配置，可以选择存储路径等
最后是关于字符集的一些修改，建议在默认的基础上修改为一下内容，mysql5.7默认的编码集是latin1，不能写入中文，8.0默认的是utf8mb4，可以写入中文
💎3. MySQL的启动 在mysql的安装目录的bin目录下点击右键，选择在终端中运行
如果说想要直接在桌面打开的cmd命令行窗口运行需要配置环境变量
配置过程：
找到MySQL的安装目录：首先，需要知道MySQL的安装路径，比如默认安装路径可能为C:\Program Files\MySQL\MySQL Server 8.0\。
打开系统属性：右键点击“此电脑”（或“我的电脑”），选择“属性”，然后点击“高级系统设置”。
编辑环境变量：在“系统属性”窗口中，点击“环境变量”按钮。
添加MySQL到Path变量：
在“系统变量”区域找到名为Path的变量，点击“编辑”。
点击“新建”，然后添加MySQL的bin目录路径，如C:\Program Files\MySQL\MySQL Server 8.0\bin。
点击“确定”保存更改。
无论是配环境变量的方式还是点击到bin目录下再在终端打开，打开之后输入"mysql -uroot -p"的命令，接着输入密码即可登录
另外一种启动方式就是直接点击这两个快捷方式，一个是不带字符集的，另一个是带字符集的，点击任意一个输入密码即可
💎4. 数据库的操作 SQL语句有以下分类
MySQL的语法大小写不敏感，也就是使用大写和小写都一样，本节先来看DDL的一些语句：
[ ] 里的表示可选项，可以选也可以不选
💎4.1 显示数据库 首先看一下显示的操作，登录之后就可以使用下面的这个命令来查看当前服务器的所有数据库
show databases; 如果说输入的命令错误的话，想重起一行重新输入，可以使用快捷键ctrl + c
💎4.2 创建数据库 先来看以下创建数据库的语法：
大括号里表示这两个关键字必须要有一个，database和schema都表示数据库的意思
db_name就是自定义的数据库名字
if not exists 表示如果不存在就创建
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac396dcf8bbc30d459594091451a570f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/661b82666ef5da8a420ff2e3d06c56ac/" rel="bookmark">
			详解贪心算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		贪心算法（Greedy Algorithm) 概述： 贪心算法是一种在求解最优化问题时采取的一种常用算法策略。贪心算法的基本思想是，每次选择当前情况下的局部最优解，并相信这个局部最优解能够导致全局最优解。贪心算法通过迭代的方式一步步地构建最优解，并不进行回溯。
贪心算法的一般步骤： 1. 将问题分解成多个子问题；
2. 对每个子问题，确定一个最优解；
3. 对每个子问题的最优解进行合并，得到原问题的最优解。
贪心算法的正确性需要满足两个条件： 1.最优子结构：问题的最优解能够由子问题的最优解组合而成。
2. 贪心选择性：通过局部最优选择能够得到全局最优解。
贪心算法适用的问题一般具有以下特点： 1. 子问题的最优解能够推导出原问题的最优解；
2. 子问题的最优解构成原问题的最优解时，原问题的最优解也能由它推导出。
贪心算法的优点是简单、高效，时间复杂度通常较低。然而，贪心算法并不适用于所有问题，有些问题需要使用其他更复杂的算法来求解。在使用贪心算法时，需要仔细分析问题的特点并证明贪心策略的正确性。
由于贪心是一种思想，没有具体的算法模板，而且贪心一般不会单独作为一种算法出现在题目中，一般会跟其他算法结合在一起出现。例如：动态规划、递归、高级数据结构等。在此基础上保证每一步时最优解的情况下就可以得到最优的答案。下面我们将以例题的形式让大家来了解这种思想。
例题一： AcWing 3769. 移动石子 题目： 一共有 n 个箱子排成一排，从左到右依次编号为 1∼n。
其中，第 i 号箱子中放有 ai个石子。
现在，你可以进行最多 d 次操作。
每次操作可以将一个石子从一个箱子移动至另一个与其相邻的箱子里。
我们希望通过合理操作使得 1 号箱子内的石子数量尽可能大。
请问，这个最大可能值是多少？
输入格式 第一行包含整数 T，表示共有 T 组测试数据。
每组数据第一行包含两个整数 n和 d。
第二行包含 n 个整数 a1,a2,…,an。
输出格式 每组数据输出一行结果，表示答案。
数据范围 1≤T≤100,
1≤n,d≤100,
0≤ai≤100.
输入样例： 3 4 5 1 0 3 2 2 2 100 1 1 8 0 输出样例： 3 101 0 解题思路： 这个题很明显贪心思想，要让第一个箱子尽可能多的石子，在操作次数的限制下，我们最优解，要从第二个箱子开始贪心，第二个、第三个.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/661b82666ef5da8a420ff2e3d06c56ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c811568d7163a1ebcb3f3b1a4c1c840e/" rel="bookmark">
			从科幻到现实：AIGC助力打造个性化数字人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、技术基础：多领域技术的深度融合1.先进的人工智能技术：2.实时交互与反馈机制：3.个性化定制技术： 二、打造策略：从设计到实施的全方位考量1.深入理解用户需求：2.精细化设计与开发：3.持续优化与迭代： 三、未来展望：个性化数字人的无限可能1.跨领域融合与创新：2.增强现实与虚拟现实的结合：3.智能协同与生态构建： 《AI虚拟数字人：商业模式+形象创建+视频直播+案例应用》内容简介作者简介目录 在人工智能生成内容（AIGC）技术日新月异的今天，个性化数字人已不再仅仅是科幻电影中的幻想，而是正逐步成为我们日常生活和工作中不可或缺的一部分。这些数字人不仅拥有逼真的外观和声音，还具备高度智能化的交互能力，能够根据用户的偏好和需求进行个性化定制。本文将深入探讨在AIGC时代如何深度打造个性化数字人，从技术基础、打造策略到未来展望，全方位解析这一领域的最新进展与趋势。
一、技术基础：多领域技术的深度融合 1.先进的人工智能技术： 深度学习：利用深度学习算法，数字人能够学习并理解复杂的语言模式、情感表达和行为习惯，从而实现更加自然的交互。自然语言处理（NLP）：通过NLP技术，数字人能够解析和理解人类语言，进行流畅的对话交流，甚至参与复杂的讨论和辩论。计算机视觉与图形渲染：结合GAN（生成对抗网络）和其他图形渲染技术，数字人能够呈现出高度逼真的面部表情、身体动作和场景背景，为用户带来沉浸式体验。 2.实时交互与反馈机制： 实时语音合成与识别：TTS（文本到语音）和ASR（自动语音识别）技术的结合，使数字人能够实时将文本转化为语音并理解用户的语音输入。智能情感分析：通过分析用户的语音、文本和表情等信息，数字人能够感知用户的情感状态，并据此调整自己的交互策略，实现更加人性化的交流。 3.个性化定制技术： 形象定制：提供多样化的外观设计选项，包括肤色、发型、服饰等，让用户可以根据自己的喜好打造独一无二的数字人形象。声音定制：利用AI实时变声和定制化声音克隆功能，为数字人配置个性化的声音，增强用户的代入感和沉浸感。 二、打造策略：从设计到实施的全方位考量 1.深入理解用户需求： 通过市场调研和用户访谈等方式，收集并分析用户对个性化数字人的需求和期望，为设计提供有力依据。关注不同领域和行业的特点和需求，为数字人定制专属的知识库和交互场景。 2.精细化设计与开发： 在形象设计上，注重细节和美感，确保数字人形象既符合用户的审美需求又具备独特性。在技术实现上，采用先进的算法和模型，确保数字人在交互过程中表现出高度的智能化和个性化。 3.持续优化与迭代： 通过用户反馈和数据分析等手段，及时发现并解决数字人在使用过程中存在的问题和不足。不断引入新技术和新方法，对数字人进行持续优化和迭代升级，保持其竞争力和生命力。 三、未来展望：个性化数字人的无限可能 1.跨领域融合与创新： 随着技术的不断进步和应用场景的不断拓展，个性化数字人将在更多领域发挥重要作用。例如，在教育领域作为智能助教辅助教学；在医疗领域作为虚拟护士提供健康咨询等。跨领域的融合与创新将推动个性化数字人向更加智能化、个性化的方向发展。 2.增强现实与虚拟现实的结合： 随着AR（增强现实）和VR（虚拟现实）技术的不断发展，个性化数字人将能够在更加逼真的虚拟环境中与用户进行交互。这将为用户带来更加沉浸式和互动式的体验。 3.智能协同与生态构建： 未来的个性化数字人将不再是孤立的存在，而是能够与各种智能设备和系统实现无缝连接和协同工作。通过构建智能生态系统，数字人将能够更好地服务于用户的生活和工作需求。 AIGC时代为个性化数字人的打造提供了广阔的空间和无限的可能。通过综合运用先进的人工智能技术、深入理解用户需求以及持续优化与迭代等策略，我们可以打造出具有高度智能化和个性化的数字人产品。未来随着技术的不断进步和应用场景的不断拓展，个性化数字人将在更多领域发挥重要作用并为用户带来更加便捷、高效和智能的体验。
《AI虚拟数字人：商业模式+形象创建+视频直播+案例应用》 获取方式：https://item.jd.com/14686224.html
内容简介 《AI虚拟数字人：商业模式+形象创建+视频直播+案例应用》一书以实战案例为主，通过以下4篇内容，帮助读者完成AI虚拟数字人从入门到精通的学习。
商业模式篇：介绍了AI虚拟数字人的前景、价值、原理、应用、产业链、商业模式等内容。
形象创建篇：介绍了生成虚拟数字人的工具和平台，以及使用主流软件剪映和腾讯智影生成与设置数字人的过程。
视频直播篇：介绍了数字人的视频直播素材和效果的制作与剪辑，丰富画面的各类效果。
案例应用篇：通过《人生哲理播报》《抖音电商带货》《戏曲知识口播》《延时摄影攻略》4个大型案例，介绍了数字人在心理学、电商、教育和摄影等领域的实战应用。
本书适合对象：一是对AI虚拟数字人感兴趣的读者和初学者；二是想要制定虚拟形象的博主，如直播主播、短视频博主、电商商家等；三是需要制定虚拟偶像、游戏角色的娱乐和文化产业；四是想要强化营销效果的商家和企业；五是可作为高校相关专业的参考教材。
本书赠送了书中案例的教学视频、素材文件、效果文件和教学课件，读者可扫描书中二维码及封底的“文泉云盘”二维码，在线观看学习并下载素材。
作者简介 李军仁，从事基于数字技术的智能化应用多年，特别是大数据、人工智能、AI数字人领域的应用。是国内首批研究与应用AI技术的行业人员，熟悉ChatGPT、Midjourney、Dall•E、百度文心一言、文心一格、Photoshop AI、Firefly AI、Stable Diffusion、Novel等AI相关工具。对AI短视频的生成，如文生视频、图生视频、视频生视频，以及AI虚拟数字人的技术原理、商业运作、形象定制、身份创建、视频制作、主播打造、直播运营、教育培训、营销推广等，有丰富的实战经验。一直致力于AI在商业领域的应用，如AI对电商的应用、AI在客服工作中的应用、AI在营销、宣传、推广等领域的应用，以及AI在教育、金融、设计等各行业的渗透与影响。编写过的图书有《大数据：从海量到精准》《实战大数据：客户定位和精准营销》。
目录 【商业模式篇】 第1 章 初识：掌握AI 虚拟数字人的概况 002 ◎ 1.1 新手入门，学习基础知识 003 1.1.1　基本定义 003 1.1.2　主要亮点 003 ◎ 1.2 应用前景，了解潜在价值 004 1.2.1　应用领域 005 1.2.2　机遇与挑战 007 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c811568d7163a1ebcb3f3b1a4c1c840e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/74/">«</a>
	<span class="pagination__item pagination__item--current">75/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/76/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>