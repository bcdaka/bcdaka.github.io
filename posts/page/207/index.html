<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba0109b7694e4eec8fa580479974b35e/" rel="bookmark">
			Python爬取豆瓣电影&#43;数据可视化，爬虫教程！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 爬取数据 1.1 导入以下模块 import os import re import time import requests from bs4 import BeautifulSoup from fake_useragent import UserAgent from openpyxl import Workbook, load_workbook 1.2 获取每页电影链接 def getonepagelist(url,headers): try: r = requests.get(url, headers=headers, timeout=10) r.raise_for_status() r.encoding = 'utf-8' soup = BeautifulSoup(r.text, 'html.parser') lsts = soup.find_all(attrs={'class': 'hd'}) for lst in lsts: href = lst.a['href'] time.sleep(0.5) getfilminfo(href, headers) except: print('getonepagelist error!') 1.3 获取每部电影具体信息 def getfilminfo(url,headers): filminfo = [] r = requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba0109b7694e4eec8fa580479974b35e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb26192a6dd09566e2e7bac536e8dc1b/" rel="bookmark">
			VSCode创建Vue 项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载node.js 安装；
安装后环境变量添加，path。node -v
npm -v
npm install -g @vue/cli vue --version
–
vue create test_vue
手动配置 test_vue_config (应该有默认的，不用手动配置)
– 启动项目
cd test_vue
npm run serve
http://localhost:8080/
–安装axios
npm install axios
参考：
https://cn.vuejs.org/guide/quick-start.html
https://blog.csdn.net/yy12345_6_/article/details/119796741
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8402cc401eb3c9092185a48fea03b7e7/" rel="bookmark">
			JavaScript 事件监听器 addEventListener() 方法 和一些基本的事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. HTML DOM 事件 什么是事件？
事件是在编译的过程中发生的事情，当事件发生的时候计算机可以自动采取某种行动（即运行一些代码，通常是我们所制定的函数）。常见的事件有：
单击事件双击事件鼠标划入鼠标划出鼠标悬停某个键盘被按下某个键盘被松开 1.1 鼠标事件 onclick在对象被点击的时候发生ondblclick在对象被双击的时候发生onmousedown在鼠标被按下的时候发生onmouseup在鼠标被松开的时候发生onmousemove在鼠标被移动的时候发生onmouseover在鼠标指针被移动到指定元素的时候发生onmouseout在鼠标指针被移出到指定元素的时候发生 1.2 键盘事件 onkeydown键盘被按下的时候触发事件onkeypress在键盘按下一个键，然后再松开的时候会触发onkeyup当键盘上的一个键被松开的时候会触发 1.3 表单事件 onblur元素失去焦点时触发onfocus元素获取焦点时触发oninput元素获取用户输入时触发onreset表单重置时触发onselect用户选取文本时触发 (比如 &lt;input&gt; 和 &lt;textarea&gt; 中的内容)onsubmit表单提交时触发 1.4 其他相对常见的事件 onscroll 指定元素滑轮发生滚动的时候会触发事件
onresize 窗口或框架被重新调整大小。
onchange该事件在表单元素的内容改变时触发( &lt;input&gt;, &lt;keygen&gt;, &lt;select&gt;, 和 &lt;textarea&gt;) 二. addEventListener() 方法的介绍和使用 addEventListener() 方法用于向指定元素添加事件句柄。当计算机属性检测到事件发生的时候，运行一些代码，通常是我们所制定的函数。
2.1 语法知识 element.addEventListener(event, function, useCapture)
event：
必须填写不可省略。
注意: 在 addEventListener() 方法中不能使用 "on" 前缀，会报错。 例如，我们要使用 "click" ,而不是使用 "onclick"。
function：
必须填写不可省略。
事件发生时运行的函数。
useCapture:
可以省略不写，默认值是 false
true ：使用事件捕获
false ：使用事件冒泡
2.2 addEventListener() 方法的性质 可以使用外部函数，也可以使用隐函数向一个元素添加多个相同类型的事件处理程序。向一个元素添加多个事件处理程序可以向任何 DOM 对象添加事件处理程序而非仅仅 HTML 元素，例如 window 对象。可以对事件进行冒泡或者捕获可以被删除。（removeEventListener() 方法删除事件监听器） 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8402cc401eb3c9092185a48fea03b7e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6decde62688ef263f433b09cc2cb5e99/" rel="bookmark">
			《数据仓库与数据挖掘》自测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		试卷一 一、选择题（每题2分，共20分） 1. 数据仓库的主要特征不包括以下哪一项？
A. 数据量大
B. 异构数据整合
C. 事务处理
D. 支持决策分析
2. OLAP的核心功能是：
A. 事务处理
B. 多维数据分析
C. 数据清洗
D. 数据转换
3. 以下哪个不是元数据的分类？
A. 数据源元数据
B. 数据模型元数据
C. 数据仓库映射元数据
D. 数据备份元数据
4. 数据挖掘中的KDD指的是：
A. 数据清洗
B. 知识发现
C. 知识库设计
D. 知识库查询
5. 决策树算法中，用于评估属性分割优劣的指标是：
A. 基尼不纯度
B. 信息熵
C. 信息增益
D. 互信息
二、填空题（每空2分，共20分） 6. 数据仓库的演变包括从________到DW，数据的________和________，以及操作的________和________。
7. OLAP的基本操作包括________、________、________和________。
8. 元数据在数据仓库中的作用包括________、________和________。
9. 数据立方体的典型压缩型包括冰山立方体、________、________和________。
10. 决策树的构建过程中，特征选择的方法包括信息增益、________和基尼不纯度。
三、简答题（每题10分，共30分） 11. 简述数据集市与数据仓库的主要区别。
12. 解释什么是数据立方体，并说明其在数据仓库中的作用。
13. 描述遗传算法的基本工作原理及其在数据挖掘中的应用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6decde62688ef263f433b09cc2cb5e99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/862b1d63c11953bb7ca2b1989ba0e354/" rel="bookmark">
			IT启航：高考后的IT学习之旅与未来规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着高考分数的揭晓，你们即将迎来人生新的篇章。对于有志于踏入IT领域的你们来说，这个假期是开启探索之旅的绝佳时机。作为一位已经在社会大学摸爬滚打多年的牛马来说，我想从自己的经历和观察出发，给你们提供一些实质性的建议和学习路线图。
一、明确目标与兴趣
首先，你需要明确自己对IT领域的哪个方向感兴趣。是前端开发、后端开发、数据科学、网络安全还是其他？不同的方向有着不同的技术栈和技能要求，明确目标有助于你更有针对性地学习和准备。
二、掌握基础编程语言
对于初学者来说，掌握一门基础编程语言是非常重要的。Python是一个很好的选择，因为它既适合初学者入门，又广泛应用于数据科学、人工智能等领域。你可以通过在线教程、视频课程或相关书籍来学习Python。
三、深入学习专业知识
除了编程语言，你还需要深入学习与你目标方向相关的专业知识。例如，如果你对前端开发感兴趣，那么你需要学习HTML、CSS、JavaScript等前端技术；如果你对后端开发感兴趣，那么你需要学习数据库、服务器、网络等相关知识。
四、参与实际项目
理论知识的学习固然重要，但实践同样不可或缺。你可以通过参与开源项目、加入学生团队或自己发起个人项目来锻炼自己的实践能力。这不仅有助于你巩固所学知识，还能让你更好地了解实际开发中遇到的问题和挑战。
五、持续学习与自我提升
IT领域是一个快速发展的领域，新技术层出不穷。因此，你需要保持持续学习的态度，不断跟上行业的最新动态和技术趋势。你可以通过参加技术社区、阅读技术博客、参加线上或线下的技术讲座等方式来获取最新的技术信息。
六、培养团队协作与沟通能力
在IT领域，团队协作和沟通能力同样重要。你可以通过参与学生组织、加入技术社团或参与团队项目来锻炼自己的团队协作和沟通能力。同时，也要学会倾听他人的意见和建议，尊重他人的观点和想法。
七、保持积极心态与耐心
学习IT领域需要耐心和毅力。你可能会遇到各种困难和挑战，但请相信，只要保持积极的心态和坚定的信念，你一定能够克服这些困难并取得成功。同时，也要学会调整自己的心态和情绪，保持平和的心态面对学习和生活中的各种挑战。
最后，我想说的是，学习IT领域是一个充满挑战和机遇的过程。希望你们能够珍惜这个假期的时间，按照这份学习路线图进行规划和安排。相信通过你们的努力和坚持，一定能够在IT领域取得优异的成绩并为未来的职业生涯打下坚实的基础！加油！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6a927825a5579bf53d2e6c66d861a8e/" rel="bookmark">
			【一步一步了解Java系列】：对这个系列的总结以及对缺漏内部类知识的补充
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看到这句话的时候证明：此刻你我都在努力
加油陌生人
br /&gt;个人主页：Gu Gu Study
专栏：一步一步了解Java
喜欢的一句话： 常常会回顾努力的自己，所以要为自己的努力留下足迹
喜欢的话可以点个赞谢谢了。
作者：小闭
一路来的文章 第一篇文章： 记得这个系列是我今年4月29日开始写的，写的是我初始Java的总结，第一篇便是写了Java基本类型与C语言的区别，至于为什么我一开始就跟C语言对标呢？原因有两个：
我那时刚学完C语言，对C语言记忆尤为深刻。我初始Java的基本数据类型时我就发现Java有C语言没有的基本类型如：byte，而且char在Java中占2个字节。 不知不觉已经过去了两个月了，这个系列也差不多结束了，之后会是Java实现的数据结构的系列了，在之后就是更高级的Java系列。现在这个系列差一个图书馆系统的博客没有写，不过应该也快写了。
第二篇文章： 这篇文章没想到就是我这个系列里面阅读量最高的一篇，这是万万没想到的。这篇是对基本数据类型的转换得总结。关于什么int转换成double什么什么得，还有Java中得float的类型还得必须加上一个F或f等等。主要就是自动类型转换，强制类型转换，类型提升，以及字符串得转换成int，double等。
第三篇文章： 这篇文章还是不知不觉与C语言进行了对比，讲的是各式各样的得运算符，像简单的算术运算符，赋值和++，逻辑运算符，位运算符，移位运算符等，
记得那时讲解取模时第一次遇到了异常，这可是与C语言大不相同的一个知识点，那时不懂还没学到异常，就简单说是报错哈哈哈。还有就是Java中的double是支持取模运算的，也是和C语言的一个不同呢。
第四、五篇文章 第四篇的阅读量就比较凄惨了，里面的内容也比较简单，简单的逻辑结构，记得逻辑结构我在C语言得文章里是没有写过得，那时就觉得太简单了，但到Java想想还是写一下吧，然后就有了这第四篇文章。里面讲了简单得顺序结构，选择结构，循环结构以及switch语句等等，都是非常简单的结构了。
最深刻的还是，Java中不能用数字代表真假，if里的括号只能用true来表示真，false代表假，这也是和C语言的一个不同吧。
然后第五篇：
也算是回到正常的播放量了吧，这篇主要也是和C语言进行对比，因为这是真的和C语言的不同了，在C语言中函数就是Java中的方法，叫法完全不一样了，但性质差不多，只不过Java面向对象的语言，多了一些限定修饰符。
这篇文章主要讲了方法的意义和形参实参，方法的递归，然后就是新概念方法重载，其实到后面还有一个方法·重写，但是那时没有学到类与对象，所以就没在这篇文章里讲。
第六篇文章： 这篇文章是第一次接触引用这个概念，引用是个新概念，Java中没有指针的学习，但是有引用。
数组就是一个引用类型，记得那时我以为能直接用System.out.println直接打印出来呢，没想到的是直接打印出来的是一个地址，哈哈哈。
还有在Java中数组中让我真正跟感觉到Java的简便，只需点length就可以得到数组的长度，换到C语言就是还得使用sizeof慢慢求呢。这里还学到了现成包Arrays，使用其toString就可以将数组转含为字符串就可以直接printf直接将里面的数组给打印出来了。
第七、八篇文章 第七篇文章就是真正与C语言不同的部分了，这时我学到了类与对象，说实话那时类给我的感觉就是一个C语言的结构体，他们的用法也是用“.”操作符来进行的。这篇文章主要讲述了类和对象的关系，类经过实例化后就是一个对象。然后就是一系列的有关类的知识如：构造方法，this关键字。
那时知识初始类与对象，对对象的概念还不是很清楚，但在后面的学习中对对象的理解也是会越来越深的。
然后到第八篇文章的话：
既然学的是类的话，那肯定就要讲到继承了，就有了父类和子类了，这时就要牵扯到super关键字了。然后还有代码块的初始化顺序，现在印象还是很深刻呢。父类静态代码块----&gt;子类的静态代码块----&gt;父类的实例代码块----&gt;父类的构造方法----&gt;子类的实例代码块----&gt;子类的构造方法。
第九篇文章 第九篇文章写的是关于多态，但是这时是没有讲接口和抽象类的，所以之讲了子类的多态，这时我们就讲到函数重写了，重写之后是向上转型和向下转型。
第十、十一篇文章 然后在第十篇终于迎来了，抽象类和接口得学习，不得不说抽象类和接口真的很像，两个都是为了简便代码而存在的，这篇里详细讲解了抽象类与接口的相关知识，包括抽象类不能被final，private修饰，以及不能被new直接实例化，然后就是接口，感觉与抽象类最大的不同就是它不能有构造方法，且它里面的数据和方法都是默认有一些限定修饰符修饰的。
然后这是最后一篇异常类，然后异常类就只需要知道都是Exception类的子类或者是RuntimeException的子类都是异常类，我们还可以通过继承异常类类自定义异常类，然后就是里面的相关关键字try-catch之类的。finally，总之异常类啊还是挺简单的。
补充内部类内容 静态内部类 public class Test { static class Test1{ String name; int a=10; public void setA(int a) { this.a = a; System.out.println(a); } } } class Test2{ public static void main(String[] args) { Test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6a927825a5579bf53d2e6c66d861a8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d79af4f8cf9ef8356a76b7e7674765a/" rel="bookmark">
			【Spring】Spring Security 核心类介绍及Spring Security 的验证机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Security 核心类介绍及Spring Security 的验证机制 一、Spring Security 核心类1.1 Authentication1.2 SecurityContextHolder1.3 UserDetails1.4 UserDetailsService1.5 GrantedAuthority1.6 DaoAuthenticationProvider1.7 PasswordEncoder 二、 Spring Security 的验证机制 一、Spring Security 核心类 Spring Security 核心类包括 Authentication、SecurityContextHolder、UserDetails、UserDetailsService、GrantedAuthority、DaoAuthenticationProvider 和 PasswordEncoder。
1.1 Authentication Authentication 用来表示用户认证信息，在用户登录认证之前，Spring Security 会将相关信息封装为一个 Authentication 具体实现类的对象，在登录认证成功之后又会生成一个信息更全面、包含用户权限等信息的 Authentication 对象，然后把它保存在 SecurityContextHolder 所持有的 SecurityContext 中，供后续的程序进行调用，如访问权限的鉴定等。
1.2 SecurityContextHolder SecurityContextHolder 是用来保存 SecurityContext 的。 SecurityContext 中含有当前所访问系统的用户的详细信息。默认情况下， SecurityContextHolder 将使用 ThreadLocal 来保存 SecurityContext，这也就意味着在处于同一线程的方法中，可以从 ThreadLocal 获取到当前的 SecurityContext。
Spring Security 使用一个 Authentication 对象来描述当前用户的相关信息。SecurityContextHolder 中持有的是当前用户的 SecurityContext，而 SecurityContext 持有的是代表当前用户相关信息的 Authentication 的引用。这个 Authentication 对象不需要我们自己创建，在与系统交互的过程中， Spring Security 会自动创建相应的 Authentication 对象，然后赋值给当前的 SecurityContext。开发过程中常常需要在程序中获取当前用户的相关信息，比如最常见的是获取当前登录用户的用户名。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d79af4f8cf9ef8356a76b7e7674765a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f577ec291acb0dafa8c5943fabe4e377/" rel="bookmark">
			Kafka集群之-ZooKeeper未授权访问漏洞修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ZooKeeper 配置修改 一、修改 zoo.cfg 配置 ZooKeeper 的配置文件，修改 /usr/local/zookeeper/conf/zoo.cfg 文件，添加以下内容：
authProvider.1=org.apache.zookeeper.server.auth.SASLAuthenticationProvider jaasLoginRenew=3600000 requireClientAuthScheme=sasl zookeeper.sasl.client=true sessionRequireClientSASLAuth=true 二、创建 JAAS 文件 在 ZooKeeper 的安装目录下的 conf 目录中创建 zk_jaas.conf 文件，并编辑内容如下：
abnf复制代码Server { org.apache.zookeeper.server.auth.DigestLoginModule required username="admin" password="admin" user_admin="admin"; }; Client { org.apache.zookeeper.server.auth.DigestLoginModule required username="admin" password="admin"; }; user_admin="admin" 的含义是 user_username="password"，添加一个用户名为 admin，密码为 admin 的认证用户，用户名和密码可以自行定义。
三、配置 ZooKeeper 客户端环境变量 因为如果要连接 ZooKeeper 是需要通过 SASL 认证的，所以需要配置环境变量，这里的环境变量主要是使用 zk_jaas.conf 文件中的 Client 配置，会在连接时使用用户名和密码。
在 zkEnv.sh 文件的最后添加一行： export JVMFLAGS="-Djava.security.auth.login.config=/usr/local/zookeeper/conf/zk_jaas.conf ${JVMFLAGS}" 四、重启 ZooKeeper 服务 重启 ZooKeeper 服务，正常启动一般便无问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f577ec291acb0dafa8c5943fabe4e377/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b28745119091b50d130fb321d5c6b52/" rel="bookmark">
			WSL——忘记root密码（Ubuntu）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、问题描述 Windows下的WSL（Ubuntu）忘记了root密码，无法使用管理员权限。 2、解决方法 关闭 Ubuntu 窗口。打开 Windows 的 Powershell 或 cmd， 以 root 默认登陆 WSL。 wsl -u root 修改对应用户密码。 # xxx为要修改密码的用户名 passwd xxx 输入密码，确认密码，修改成功。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a68fd6bb0e443401b6c9dc83a775efd7/" rel="bookmark">
			文生图王者登场：Stable Diffusion 3 Medium正式开源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今年2月，Stability.ai发布了Stable Diffusion 3预览版，在多主题提示、图像质量和拼写能力方面具有显著的性能提升。Stable Diffusion 3是一个系列模型，参数量从800M到8B不等。
6月12日，Stability AI正式开源了Stable Diffusion 3 Medium（2B），这是迄今为止最先进的文生图开源模型，被视为生成式AI发展的一个重要里程碑。它具有一些显著的优点：
照片写实主义：克服手部和面部常见的瑕疵，无需复杂的工作流即可提供高质量的图像。
提示遵循：理解涉及空间关系、构图元素、动作和风格的复杂提示。
排版：在Diffusion Transformer架构的帮助下，在生成没有伪影和拼写错误的文本方面取得了前所未有的效果。
资源高效利用：由于占用较低的VRAM空间，非常适合在标准消费者GPU上运行且不会降低性能。
微调：能够从小数据集中吸收细微的细节，非常适合定制化。
现在，硅基流动团队在云服务平台SiliconCloud上线了SD 3 Medium开源模型。
欢迎来玩儿：
https://cloud.siliconflow.cn/models/image/text-to-image/17885302526
注意！！！除了最新的Qwen2、DeepSeek V2等语言模型，SD 3 Medium已进入“6.18购物狂欢节”福利包：“新用户送3亿token（相当于1500张图片）”。
注册即可畅玩（截止6月18日23:59）：
www.siliconflow.cn/zh-cn/siliconcloud
SD3 Medium 模型效果及表现 （提示词：Masterpiece, best quality, girl, having a tattoo that says "Welcome to SiliconFlow". collarbone, wavy hair, looking at viewer, blurry foreground, upper body, necklace, contemporary, plain pants, intricate, print, pattern, ponytail, red hair, dappled sunlight, smile, happy.）
（提示词：a small, plush cat figurine with orange stripes and large black eyes holds a billboard calld“ SiliconCloud” amidst a dreamy landscape of blue felt waves, pink felt hearts, and soft, hazy clouds glowing with a golden sunset, creating a whimsical, serene scene.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a68fd6bb0e443401b6c9dc83a775efd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/851aa2fdfb7e10ade00e5d2f1f7ed71d/" rel="bookmark">
			【爱上C&#43;&#43;】详解string类2:模拟实现、深浅拷贝
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上一篇文章中我们介绍了string类的基本使用，本篇文章我们将讲解string类一些常用的模拟实现，其中有很多细小的知识点值得我们深入学习。Let’s go！
文章目录 类声明默认成员函数构造函数析构函数拷贝构造函数深浅拷贝问题传统写法现代写法 赋值运算符重载传统写法现代写法 容器操作获取长度：size获取当前容量：capacity查询是否为空：empty扩容：reserve调整字符串大小：resize 字符串访问[]访问迭代器访问 插入类尾插一个字符push_backappend在尾部追加一个string对象在尾部追加一个C风格字符串在尾部追加n个字符 insert在pos位置插入一个字符在pos位置插入一个字符串 operator+= 删除类erase 其他操作swapfind返回字符c在string中第一次出现的位置返回子串s在string中第一次出现的位置 substrprintf_strclearc_str逻辑判断 流操作流插入&lt;&lt;流提取&gt;&gt; 拓展:关于string其他常用函数to_stringstoi 完整代码展示.h文件.cpp文件 类声明 namespace Mystring { // 定义一个字符串类 class string { public: // 公共成员函数和接口 private: // 私有成员变量，限制直接访问底层数据 size_t _capacity = 0; // 字符串的容量 size_t _size = 0; // 字符串的长度 char* _str = nullptr; // 指向字符串数据的指针 const static size_t npos = -1; // 静态常量，表示未找到位置或无效位置 }; } 在C++中，静态成员变量（static）的定义通常需要在类的外部进行，而非静态成员变量则需要在类的内部进行定义。然而，对于静态成员变量如果其为 const 且为整数类型（包括枚举类型），则可以在类内部直接进行初始化。因此，对于 const static size_t npos = -1; 这样的声明，其允许在类内部直接进行初始化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/851aa2fdfb7e10ade00e5d2f1f7ed71d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e135565881d28ff0db5628f88731bcd/" rel="bookmark">
			MySQL 死锁问题排查与分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数据库管理系统中，死锁是一个常见且棘手的问题。当两个或多个事务相互等待对方释放资源时，就会发生死锁，导致事务无法继续执行，严重时甚至会影响整个系统的稳定性。MySQL作为广泛使用的关系型数据库管理系统，也不例外。本文将详细介绍在遇到MySQL死锁问题时，如何进行排查和分析，帮助读者快速定位问题并采取有效措施解决死锁问题。
1. 死锁的基本概念 1.1 死锁的定义 死锁是指两个或多个事务在执行过程中，因争夺资源而造成的一种僵持状态，若无外力作用，这些事务将无法继续执行。
1.2 死锁的四个必要条件 死锁的发生必须满足以下四个必要条件：
互斥条件：资源不能被共享，只能由一个事务占用。请求与保持条件：事务已经占用了至少一个资源，同时又在请求其他资源。不剥夺条件：资源不能被强制剥夺，只能由占用资源的事务主动释放。循环等待条件：存在一个事务的循环链，链中的每个事务都在等待下一个事务占用的资源。 2. 死锁的常见原因 2.1 事务并发控制不当 事务并发控制不当是导致死锁的常见原因之一。例如，事务的隔离级别设置不当、锁的粒度过大或过小、锁的持有时间过长等。
2.2 事务顺序不一致 当多个事务以不同的顺序请求相同的资源时，容易导致死锁。例如，事务A先请求资源1再请求资源2，而事务B先请求资源2再请求资源1。
2.3 资源竞争激烈 在高并发的场景下，多个事务同时请求相同的资源，容易导致资源竞争激烈，从而引发死锁。
2.4 事务设计不合理 事务设计不合理也是导致死锁的原因之一。例如，事务中包含过多的操作、事务的逻辑过于复杂、事务的执行时间过长等。
3. 死锁的排查方法 3.1 查看死锁日志 MySQL提供了详细的死锁日志，可以通过查看死锁日志来获取死锁的相关信息。死锁日志通常包含以下内容：
死锁发生的时间：死锁日志中会记录死锁发生的具体时间。死锁涉及的事务：死锁日志中会记录涉及死锁的事务ID。死锁涉及的资源：死锁日志中会记录涉及死锁的资源，包括表、行等。死锁的详细信息：死锁日志中会记录死锁的详细信息，包括事务的执行语句、锁的类型、锁的持有时间等。 3.1.1 启用死锁日志 在MySQL配置文件中启用死锁日志：
[mysqld] innodb_print_all_deadlocks = 1 3.1.2 查看死锁日志 死锁日志通常存储在MySQL的错误日志文件中，可以通过以下命令查看：
tail -f /var/log/mysql/error.log 3.2 使用SHOW ENGINE INNODB STATUS SHOW ENGINE INNODB STATUS命令可以显示InnoDB存储引擎的状态信息，包括最近发生的死锁信息。
3.2.1 执行SHOW ENGINE INNODB STATUS SHOW ENGINE INNODB STATUS; 3.2.2 分析死锁信息 在输出结果中，找到LATEST DETECTED DEADLOCK部分，可以查看最近发生的死锁信息。死锁信息通常包含以下内容：
死锁涉及的事务：包括事务ID、事务的执行语句、锁的类型等。死锁涉及的资源：包括表、行等。死锁的详细信息：包括锁的持有时间、锁的等待时间等。 3.3 使用Performance Schema MySQL的Performance Schema提供了丰富的性能监控信息，包括锁的等待信息。可以通过Performance Schema来排查死锁问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e135565881d28ff0db5628f88731bcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/873fd2983169663e5b916b5c30e2382d/" rel="bookmark">
			Pandas(全网最详细攻略)（Python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、简介二、安装1、Anaconda（开源、安装简单、高性能、免费的社区支持）2、Pycharm（推荐下载社区版（免费使用））3、pip 三、数据结构1、Series2、DataFrame（常用） 四、基本属性&amp;方法：1、数据筛选方法2、插入新列3、删除重复的行4、处理缺失的值5、修改列名6、修改数据类型7、连接数据表8、透视数据表9、排序10、数据分组11、处理excel 总结 前言 Pandas 最初由 AQR Capital Management 于2008年4月开发，并于2009年底开源出来。Pandas 这个名字来源于面板数据（Panel Data）与数据分析（data analysis）这两个名词的组合。在经济学中，Panel Data 是一个关于多维数据集的术语。Pandas 最初被应用于金融量化交易领域，现在它的应用领域更加广泛，涵盖了科学研究、市场营销、社交媒体、医疗保健、教育研究等众多行业。
一、简介 Pandas 是一个免费、开源的数据分析和数据处理库，它是基于 Python 编程语言的。
二、安装 首先为你的终端，下载并安装自己想要的 Python 版本。
1、Anaconda（开源、安装简单、高性能、免费的社区支持） Anaconda，是一个开源的Python发行版本，其包含了（包管理器）conda、Python等180多个科学包及其依赖项，但是还有一些没有被包含在内的包需要通过 pip 安装；为你的电脑下载并安装 Anaconda，运行安装程序，然后按照步骤操作，安装完成后重启终端。
2、Pycharm（推荐下载社区版（免费使用）） PyCharm 是一种Python IDE（Integrated Development Environment，集成开发环境），带有一整套可以帮助用户在使用Python语言开发时提高其效率的工具，比如调试、语法高亮、项目管理、代码跳转、智能提示、自动完成、单元测试、版本控制。此外，该IDE提供了一些高级功能，以用于支持Django框架下的专业Web开发；为你的电脑下载并安装 Pycharm，运行安装程序，然后按照步骤操作，最后安装完成重启终端。
3、pip pip 是 Python 的包管理工具，该工具提供了对 Python 包的查找、下载、安装、卸载的功能；目前如果你在 python.org 下载最新版本的安装包，则是已经自带了该工具。
pip install pandas 三、数据结构 1、Series 一维数组；与numpy中的一维array类似，二者与Python基本的数据结构List也很相近，以时间为索引的Series：
''' pandas.Series() 参数： data：Series 的数据部分，可以是列表、数组、字典、标量值等。如果不提供此参数，则创建一个空的 Series。 index：Series 的索引部分，用于对数据进行标记。可以是列表、数组、索引对象等。如果不提供此参数，则创建一个默认的整数索引。 dtype：指定 Series 的数据类型。可以是 NumPy 的数据类型，例如 np.int64、np.float64 等。如果不提供此参数，则根据数据自动推断数据类型。 name：Series 的名称，用于标识 Series 对象。如果提供了此参数，则创建的 Series 对象将具有指定的名称。 copy：是否复制数据。默认为 False，表示不复制数据。如果设置为 True，则复制输入的数据。 fastpath：是否启用快速路径。默认为 False。启用快速路径可能会在某些情况下提高性能。 ''' ''' 方法（1）创建Series ''' # example import numpy as np import pandas as pd df = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/873fd2983169663e5b916b5c30e2382d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/640770c7ecac52de1ba184fb1c2d1c50/" rel="bookmark">
			【Unity】 HTFramework框架（五十二）使用 HybridCLR 热更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更新日期：2024年7月1日。
Github源码：[点我获取源码]
Gitee源码：[点我获取源码]
索引 HybridCLR 热更新一、启用宏定义二、导入HybridCLR三、设置热更新程序集四、资源、代码热更 HybridCLR 热更新 HybridCLR是一个特性完整、零成本、高性能、低内存的近乎完美的Unity全平台原生C#热更方案。
只要简阅官方文档，就会发现项目中接入HybridCLR极其简单，所以在框架中使用HybridCLR热更新并没有做太多的调整，只需要做如下几个简单的步骤即可。
注意，HTFrameworkILHotfix及HTFrameworkXLua可选模块已不再支持与维护，HybridCLR官方文档中也有说明如何将基于ILRuntime或XLua热更的项目改进为HybridCLR热更。
一、启用宏定义 定义宏HOTFIX_HybridCLR，以告诉框架当前已启用HybridCLR热更新（该宏在预定义列表中，可直接点击Use进行定义）：
HTFramework框架采用了单一入口场景的策略，且框架的初始化、生命周期等会在进入入口场景时优先执行，那么我们的一些需要热更的资源或代码，很可能在还未进行热更的前提下，便已被框架加载调用。
所以，定义宏HOTFIX_HybridCLR后，再运行程序进入入口场景，主框架将处于静默状态，以等待进行自定义的资源更新、代码更新的完成。
二、导入HybridCLR 完成了上一步宏定义后，此时我们查看主模块Main的检视面板，便会发现多出了HybridCLR的分页：
此处显示的HybridCLR并未导入，我们点击Quick Start按钮跳转到HybridCLR的官方页面，开始导入并快速体验HybridCLR热更新。
导入成功后，在检视面板上便能够看到当前导入的HybridCLR版本：
三、设置热更新程序集 同HybridCLR一样，在主程序发布前，你需要告诉框架所有热更新程序集的名称，在如下位置即可设置：
四、资源、代码热更 然后，由于我们定义了宏HOTFIX_HybridCLR，框架运行时已进入静默状态，此时所有模块皆是不可使用的（比如不能使用WebRequest模块去下载文件）。
所以需要自己实现资源、代码热更的逻辑，比如：
1.从资源服务器下载最新AB包到本地Application.persistentDataPath路径（框架的AB包加载根路径默认为此）；2.从资源服务器下载最新的热更程序集到本地，路径随意，但下载完成后最好立即Assembly.Load。 如上的资源、代码热更完成后，只需调用如下一句，便可使框架解除静默状态，并开始所有生命周期：
//HybridCLR 热更新程序集已加载完成 Main.Current.HybridCLRCompleted(); 框架生命周期开始后，会立即进入默认流程，此时即使默认流程类型存在于热更新程序集中也能正确加载，因为我们已经在框架静默时将热更新程序集Assembly.Load了。
如此，整个框架便完全适配HybridCLR热更新了，其他关于HybridCLR热更新的使用要点和注意事项，参考官方文档即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5874c8e2d0bf8b6f3dfb05c2a63c061f/" rel="bookmark">
			H5在Android在Webview中申请语音、相机等资源权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录关于H5在Android的webView中申请语音、相机等资源权限开发过程 1、申请权限的JavaScript端（Vue） 这里申请权限时一直走了catch异常，提示语音权限禁止获取。
if (navigator.mediaDevices &amp;&amp; navigator.mediaDevices.getUserMedia) { // 请求麦克风权限 navigator.mediaDevices .getUserMedia({ audio: true }) .then(function (stream) { console.log('录音权限已获取') }) .catch(function (err) { // 用户拒绝或者发生错误 console.log('无法获取录音权限:', err) }) } 2、Android端的 Webview授权（Kotlint） 这里使用AgentWeb做为Webview框架，可参考：github地址，gitee地址
webViewAgentWeb = AgentWeb.with(this) .setAgentWebParent(webViewContainer, -1, LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)) .useDefaultIndicator(ContextCompat.getColor(this, R.color.light_blue), 3) .setSecurityType(AgentWeb.SecurityType.STRICT_CHECK) .setMainFrameErrorView(R.layout.agentweb_error_page, -1) .setOpenOtherPageWays(DefaultWebClient.OpenOtherPageWays.DISALLOW) .setWebChromeClient(object : WebChromeClient(){ // H5授权检查 override fun onPermissionRequest(request: PermissionRequest?) { try { if (request != null) { if( !request.resources.contains(PermissionRequest.RESOURCE_AUDIO_CAPTURE)) return if(allPermissionsGranted()){ //允许H5申请资源权限 request.grant(request.resources) //如果需要限制H5资源申请的权限类型，则使用For循环进行检查授权即可 // for (r in request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5874c8e2d0bf8b6f3dfb05c2a63c061f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40624054c96f331cd1bdf9d87521157e/" rel="bookmark">
			强大的AI创作工作流comfyUI能够实现什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如今，AI在艺术创作中的应用日益广泛，从风格迁移到图像生成，从音乐创作到交互式艺术，AI技术正在帮助艺术家以前所未有的方式探索和表达创意。
ComfyUI作为一款基于Stable Diffusion模型的开源界面，不仅为艺术家和设计师提供了一个强大的工具，而且通过其模块化和节点化的工作流程设计，极大地丰富了图像生成的可能性。
ComfyUI的出现，标志着AI在艺术创作领域应用的进一步深化，为创作者提供了一个自由度高、灵活性强的平台，以实现他们独特的艺术构想。
通过ComfyUI，用户可以轻松地构建和执行复杂的图像生成工作流，无论是修复图像、扩展画布，还是集成高级功能如ControlNet和T2I，ComfyUI都能满足用户的需求。此外，ComfyUI的开源特性意味着它能够不断吸纳社区的智慧，不断进化和完善，为艺术创作提供持续的动力和灵感。
01 ComfyUI简介
定义与角色
ComfyUI是一个创新的开源软件，专为AI图像生成而设计。它基于Stable Diffusion模型，提供了一个用户友好的图形界面，使得艺术家和设计师能够轻松地探索和实现他们的创意构想。ComfyUI的核心在于其模块化框架，它允许用户通过拖放和连接不同的节点来构建个性化的图像生成工作流，从而实现高度定制化的图像创作过程。
开源特性
ComfyUI的开源特性是其最大的优势之一。作为一个基于GNU通用公共许可证v3.0发布的项目，ComfyUI允许任何人免费使用、学习和修改软件。这种开放性鼓励了广泛的用户参与和贡献，促进了软件的持续改进和创新。
社区支持
ComfyUI背后有一个活跃的开发者和爱好者社区，他们不断地为项目提供支持和贡献。社区成员通过GitHub等平台分享代码、讨论改进方案、报告问题并提供解决方案。这种协作精神不仅加速了ComfyUI的发展，也为用户创造了一个丰富的资源库，包括教程、插件和最佳实践，帮助新用户快速上手并充分利用ComfyUI的功能。
通过结合开源特性和强大的社区支持，ComfyUI正在成为AI图像生成领域的一个重要工具，它不仅推动了技术的发展，也为艺术创作提供了新的可能性。
02 ComfyUI的核心功能
基于节点的工作流设计
ComfyUI的核心功能之一是其基于节点的工作流设计。这种设计允许用户通过构建一个可视化的流程图来控制图像生成的每个步骤。每个节点代表一个特定的功能或操作，如文本提示、图像输入、风格转换、滤镜应用等。用户可以通过拖放来添加节点，并通过连接这些节点来定义图像生成的流程。
节点化工作流的概念
节点化工作流是一种编程范式，它将复杂的任务分解成一系列可重用和可配置的组件。在ComfyUI中，每个节点都是一个独立的功能单元，可以独立操作或与其他节点协同工作。这种设计使得用户可以轻松地修改工作流，添加新的操作，或者重新排列节点以实现不同的效果。在工作流中，如果出现错误，ComfyUI 可以帮助用户快速定位问题节点。用户也可以导出他们的工作流，以便在其他环境中使用或与他人分享。
实现复杂的图像生成任务
通过节点连接，用户可以构建从简单到复杂的各种图像生成任务。例如，用户可以首先使用文本到图像的节点生成一个基本图像，然后通过风格转换节点来改变其艺术风格，接着使用滤镜节点进行细节增强，最后通过合成节点将多个图像元素合并成最终作品。整个过程是可视化的，用户可以直观地看到每个步骤如何影响最终结果。
高度的可定制性和灵活性
ComfyUI的高度可定制性和灵活性是其最大的优势之一。用户可以根据自己的特定需求和创意来定制工作流。用户可以安装各种插件来扩展 ComfyUI 的功能，无论是专业的艺术家寻找特定的风格效果，还是设计师需要快速迭代多个设计方案，ComfyUI都能提供必要的工具和功能来支持这些需求。用户还可以添加自定义脚本和样式，以实现特定的图像效果或工作流需求。
显存和性能优化
ComfyUI对显存要求较低，同时优化了生成流程，提高了出图速度。
与其他工具的比较
与其他图像生成工具相比，ComfyUI提供了独特的优势。例如，Automatic1111 WebUI是一个使用Gradio库实现的Stable Diffusion Web界面，它提供了一个直观的Web界面来生成图像。Forge是一个旨在简化开发、优化资源管理并加快推理速度的平台。Fooocus是一款图像生成软件，它结合了Stable Diffusion的开源特性和Midjourney的用户友好性。
ComfyUI与这些工具相比，提供了更加灵活和可定制的工作流设计，允许用户通过节点化的方法来构建复杂的图像生成流程。这种设计不仅适合高级用户，也适合那些希望深入了解AI图像生成过程并掌握其细节的用户。
03 ComfyUI的常见使用场景
基础图像生成
ComfyUI提供了一个直观的界面，使得进行基本的文本到图像生成变得简单。用户首先需要打开ComfyUI软件，并通过界面中的文本输入框输入描述性文本，这些文本将作为AI生成图像的基础提示。接着，用户可以设置生成参数，如采样方法、采样步骤、CFG比例等，以控制生成过程的细节。最后，用户点击生成按钮，ComfyUI将根据提供的文本提示和参数生成图像。
图像修复与扩展
在图像修复和扩展方面，ComfyUI展现了其强大的功能。例如，如果用户需要修复一张破损的旧照片，可以使用ComfyUI中的修复节点，这个节点能够识别图像中的损坏区域并尝试恢复。同样，如果需要将图像扩展到原始边界之外，可以使用外绘节点，它能够智能地推断图像边缘并将其延伸。
高质量、高可控、多样性生图
ComfyUI支持集成ControlNet和T2I等高级功能，这些功能可以显著提升图像生成的质量和多样性。ControlNet允许用户通过控制点来精细调整图像的特定区域，实现更精确的图像编辑。而T2I（Text-to-Image）功能则允许用户通过文本描述来生成图像，这在创作概念艺术或设计原型时非常有用。
提升图像分辨率
ComfyUI还支持使用ESRGAN和SwinIR等模型来提升图像分辨率。ESRGAN是一种用于图像超分辨率的生成对抗网络，它可以在保持图像质量的同时显著提高图像的分辨率。SwinIR则是一种基于Swin Transformer的图像恢复模型，它能够修复低分辨率图像的细节，使其看起来更加清晰。
自定义嵌入和文本反转
ComfyUI的自定义嵌入功能允许用户将特定的风格或特征嵌入到生成的图像中。例如，用户可以上传一个风格独特的图像，并使用自定义嵌入节点来提取其风格特征，然后将这些特征应用到新的图像生成过程中。文本反转功能则允许用户通过反向工程文本提示来探索AI如何理解和生成图像，这对于优化生成过程和提高图像质量非常有价值。
04 ComfyUI对于高手而言是创意平台
ComfyUI不仅仅是一个图像生成工具，它还是一个强大的创意平台，能够帮助用户实现复杂的图像编辑和创作任务。
由于ComfyUI是开源软件，深度发烧友会通过持续开发各种插件，以及发布调用其他多媒体制作工具的API代码来无限扩展ComfyUI的可能性，使得艺术创作的工作流充满无限可能。例如：
1.AI 研究与实验：AI 研究人员和开发者可以使用 ComfyUI 构建和测试图像生成模型和算法。
2.个性化内容创作：视频制作者、博客作者和社交媒体影响者可以快速生成个性化的视觉内容。
3.游戏开发与动画制作：游戏和动画制作人员可以使用 ComfyUI 生成游戏素材和角色设计。
4.产品设计与模拟：产品设计师可以利用 ComfyUI 快速生成设计原型和视觉效果图。
5.教育与培训：教育工作者可以利用 ComfyUI 帮助学生理解图像处理和生成的基本概念。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40624054c96f331cd1bdf9d87521157e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb157b0ab38a72ea90db71a936c7ac50/" rel="bookmark">
			css美化滚动条样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果展示 实现 滚动条宽，高度
/* 整体滚动条 */ ::-webkit-scrollbar { width: 10px; } /* 滚动条轨道 */ ::-webkit-scrollbar-track { background-color: #ffffff; border-radius: 6px; } /* 滚动条滑块 */ ::-webkit-scrollbar-thumb { background-color: #888; border-radius: 6px; border: 2px solid #f1f1f1; } /* 滚动条滑块 - 悬停 */ ::-webkit-scrollbar-thumb:hover { background-color: #555; } 讲解 scrollbar设置宽度，高度不设，自适应页面内容即可
thumb滑块设置颜色， 伪类选择器hover 悬浮样式
track背景色fff白色
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b43867cdedb5bd966f1e31397b42f1cc/" rel="bookmark">
			【AI基础】大模型部署工具之ollama的安装部署以及api调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ollama是大模型部署方案，对应docker，本质也是基于docker的容器化技术。
从前面的文章可以看到，部署大模型做的准备工作是比较繁琐的，包括各个环节的版本对应。ollama提供了一个很好的解决方案。
ollama主要针对主流的LLaMA架构的开源大模型设计，并且已被LangChain、Taskweaver等在内的多个热门项目高度集成。同时ollama提供了openAI兼容的api，可以最大限度的减少理解和开发成本。
一、下载安装ollama 1.1 安装 官方地址：https://ollama.com/
开源地址：https://github.com/ollama/ollama
下载后双击安装：
一路下一步即可。
1.2 检验 ollama安装后默认已经启动，我们可以通过访问其提供的api服务来进行检验。
参考官方文档：ollama的api · ollama/ollama · GitHub
这里运行ollama的机器为windows系统， ip为192.168.3.154。
1.2.1 通过localhost检验 运行命令： &gt; curl http://localhost:11434/api/generate -d "{\"model\": \"qwen2\",\"prompt\": \"who are you?\",\"stream\":false}" 查看结果：
这里注意两点：
1、不要使用PowerShell(里面的curl参数不一样)，使用 cmd 或者 git Cmd 。
2、注意参数的引号，通过斜杠 \ 来转义。 1.2.2 通过IP地址检验 运行命令： &gt; curl http://192.168.3.154:11434/api/generate -d "{\"model\": \"qwen2\",\"prompt\": \"who are you?\",\"stream\":false}" 查看结果：
提示连接不上："curl: (7) Failed to connect to 192.168.3.154 port 11434 after 2021 ms: Couldn't connect to server"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b43867cdedb5bd966f1e31397b42f1cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b596e51aa0707f7b8b44e43aefab99ba/" rel="bookmark">
			Linux[高级管理]——Squid代理服务器的部署和应用(反向代理详解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🏡作者主页：点击！ 👨‍💻Linux高级管理专栏：点击！
⏰️创作时间：2024年6月24日11点11分
🀄️文章质量：95分
目录
————前言————
Squid的几种模式
1. 传统模式
2. 透明模式
3. 反向代理模式
实验环境
1.Web服务器配置
2.代理服务器配置
3.PC机（外网）
4.访问测试
5.证明真理
————前言———— Squid是一种高性能的代理缓存服务器，用于改善网络性能、提供缓存服务以及增强网络安全性。它在企业网络和互联网服务提供商中广泛使用，尤其适用于加速web访问、减少带宽使用和提高网络访问控制。下面是Squid代理服务器的详细介绍，包括其功能、部署和应用。
建议从传统模式开始看，有squid的安装教程！
建议从传统模式开始看，有squid的安装教程！
建议从传统模式开始看，有squid的安装教程！
第一篇：Squid代理服务器的部署和应用(传统模式详解)
第二篇：Squid代理服务器的部署和应用(透明模式详解）
第三篇：Squid代理服务器的部署和应用(反向代理详解)
按着顺序观看效果更好
Squid的几种模式 Squid代理服务器可以部署在多种模式下，以满足不同的网络需求。下面是对Squid三种主要模式的介绍：传统模式、透明模式和反向代理模式。
1. 传统模式 传统模式（Forward Proxy）是最常见的代理模式，客户端显式地将请求发送到Squid代理服务器，由代理服务器转发请求到目标服务器，并将响应返回给客户端。
特点：
客户端需要配置代理服务器的IP地址和端口。主要用于缓存和访问控制。常用于网络加速、带宽优化以及网络访问控制。 2. 透明模式 透明模式（Transparent Proxy）允许客户端无需配置代理设置，所有的流量通过网络设备（如路由器或防火墙）自动重定向到Squid代理服务器。
特点：
客户端无需配置代理服务器。常用于企业网络以便无缝管理和控制网络流量。配置相对复杂，需要配合网络设备（如iptables或思科设备）。 3. 反向代理模式 反向代理模式（Reverse Proxy），也称为Web加速器模式，Squid代理服务器位于客户端和Web服务器之间，客户端请求被转发到代理服务器，再由代理服务器请求实际的Web服务器。通常用于加速Web应用和负载均衡。
特点：
客户端请求无感知代理存在。提供Web服务器的缓存和负载均衡服务。常用于提高Web服务器的性能和可靠性。 本章节我们围绕反向代理的模式来讲解
前边文章有讲解 传统模式 透明模式的方式
建议从传统模式开始看，有squid的安装教程！
实验环境 一台代理服务器squid
两台web服务器
Web1：192.168.192.112
Web2：192.168.192.100
一台PC模拟外网通过squid反向代理访问内网web
1.Web服务器配置 首先就是web服务器的安装和配置
第一台192.168.192.112
关闭防火墙 selinux yum install -y httpd [root@localhost ~]# echo '22222222' &gt; /var/www/html/index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b596e51aa0707f7b8b44e43aefab99ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72e7476b2a975768ef403faad6755de6/" rel="bookmark">
			Linux[高级管理]——Squid代理服务器的部署和应用(传统模式详解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🏡作者主页：点击！ 👨‍💻Linux高级管理专栏：点击！
⏰️创作时间：2024年6月24日11点11分
🀄️文章质量：95分
目录
————前言————
Squid功能
Squid的几种模式
1. 传统模式
2. 透明模式
3. 反向代理模式
外网服务器
代理服务器
客户端
测试
————前言———— Squid是一种高性能的代理缓存服务器，用于改善网络性能、提供缓存服务以及增强网络安全性。它在企业网络和互联网服务提供商中广泛使用，尤其适用于加速web访问、减少带宽使用和提高网络访问控制。下面是Squid代理服务器的详细介绍，包括其功能、部署和应用。
第一篇：Squid代理服务器的部署和应用(传统模式详解)
第二篇：Squid代理服务器的部署和应用(透明模式详解）
第三篇：Squid代理服务器的部署和应用(反向代理详解)
按着顺序观看效果更好
Squid功能 缓存管理：Squid能够缓存频繁访问的网页内容，从而减少对原始服务器的请求次数，降低带宽消耗并加快用户的访问速度。
访问控制：提供强大的访问控制列表（ACL）功能，可以基于IP地址、时间、URL等条件来控制用户的访问权限。
内容过滤：通过配置，可以过滤不良网站、限制访问某些类型的内容，提高网络使用的安全性。
负载均衡：支持多个上游代理的负载均衡，提升代理服务的可靠性和性能。
日志记录：详细记录用户的访问日志，方便管理员进行审计和分析。
Squid的几种模式 Squid代理服务器可以部署在多种模式下，以满足不同的网络需求。下面是对Squid三种主要模式的介绍：传统模式、透明模式和反向代理模式。
1. 传统模式 传统模式（Forward Proxy）是最常见的代理模式，客户端显式地将请求发送到Squid代理服务器，由代理服务器转发请求到目标服务器，并将响应返回给客户端。
特点：
客户端需要配置代理服务器的IP地址和端口。主要用于缓存和访问控制。常用于网络加速、带宽优化以及网络访问控制。 2. 透明模式 透明模式（Transparent Proxy）允许客户端无需配置代理设置，所有的流量通过网络设备（如路由器或防火墙）自动重定向到Squid代理服务器。
特点：
客户端无需配置代理服务器。常用于企业网络以便无缝管理和控制网络流量。配置相对复杂，需要配合网络设备（如iptables或思科设备）。 3. 反向代理模式 反向代理模式（Reverse Proxy），也称为Web加速器模式，Squid代理服务器位于客户端和Web服务器之间，客户端请求被转发到代理服务器，再由代理服务器请求实际的Web服务器。通常用于加速Web应用和负载均衡。
特点：
客户端请求无感知代理存在。提供Web服务器的缓存和负载均衡服务。常用于提高Web服务器的性能和可靠性。 本次实验讲解传统模式的代理方式
实验环境
一台服务器模拟外网服务器搭建web服务 IP地址 100.0.0.2 24
一台服务器作为squid代理服务器 两块网卡 ens33 192.168.192.111 24 ens36 100.0.0.1 24
一台win7作为客户端
实验要求 win7通过squid代理服务器来访问外网web服务
注释：以上均关闭 防火墙 selinux
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72e7476b2a975768ef403faad6755de6/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/206/">«</a>
	<span class="pagination__item pagination__item--current">207/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/208/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>