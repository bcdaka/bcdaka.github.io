<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d991e2194d6858161305aeabdb5b70d9/" rel="bookmark">
			python CondaValueError: Malformed version string ‘~‘: invalid character(s).
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		conda创建新环境时出错
python CondaValueError: Malformed version string ‘~’: invalid character(s).
Solving environment: failed
InvalidVersionSpecError: Invalid version spec: =2.7
问题描述 今天在使用conda安装python环境时出现了如下的报错:
C:\Users\10044&gt;conda create --name tf_GPU python=3.7.10 Solving environment: failed CondaValueError: Malformed version string '~': invalid character(s). 原因分析： 这个报错可能是由于conda环境配置文件中存在语法问题引起的。
例如：例如之前可能使用了一些国内的镜像源 删除等一些操作不当引起的
解决方案： 网上有很多解决方案 但是本人尝试后基本都不太行 这边将上述解决方案都列出 并给出本人最终的解决方法
1.如果您使用的是conda版本较旧，请尝试升级到最新版本。您可以使用以下命令进行升级：
conda update conda 2.使用
conda upgrade -n base -c defaults --override-channels conda 但我在尝试（上述方法以及其他一些方法后）依旧出现之前问题，无法解决 依旧出现之前报错
3.后面思考既然知道是环境源出现问题 那直接替换成一个正确的源不就解决了吗
首先找到源文件**.condarc**位置：
用记事本打开，与同门可以正常安装环境的文件对比 果然有问题：
这是同门正常的文件内容（他自己添加了一些镜像源 但是后买你并没有使用）
这是我的 明显感觉缺失文件
再将我的文件替换之后 终于 安装成功！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d991e2194d6858161305aeabdb5b70d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4501452b68c5cc7a0c758b16699fab1/" rel="bookmark">
			mysql中from_unixtime的用法，日期格式表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FROM_UNIXTIME(unix_timestamp, format)
unix_timestamp: 要转换的 Unix 时间戳，可以是一个数字或者一个包含 Unix 时间戳的字段。
format: （可选）日期和时间的格式。如果不指定，则默认为 %Y-%m-%d %H:%i:%s。
不传入format：
select FROM_UNIXTIME(1710316645); 输出： +---------------------------+ | FROM_UNIXTIME(1710316645) | +---------------------------+ | 2024-03-13 07:57:25 | +---------------------------+ 1 row in set (0.00 sec) 传入format 自定义格式：
select FROM_UNIXTIME(1710316645,'%Y-%m-%d'); 输出： +--------------------------------------+ | FROM_UNIXTIME(1710316645,'%Y-%m-%d') | +--------------------------------------+ | 2024-03-13 | +--------------------------------------+ 1 row in set (0.02 sec) select FROM_UNIXTIME(1710316645,'%m-%d-%Y'); 输出： +--------------------------------------+ | FROM_UNIXTIME(1710316645,'%m-%d-%Y') | +--------------------------------------+ | 03-13-2024 | +--------------------------------------+ 1 row in set (0.00 sec) select FROM_UNIXTIME(1710316645,'%M-%d'); 输出： +-----------------------------------+ | FROM_UNIXTIME(1710316645,'%M-%d') | +-----------------------------------+ | March-13 | +-----------------------------------+ 1 row in set (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4501452b68c5cc7a0c758b16699fab1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a772b459fc5457971f874c91278f7475/" rel="bookmark">
			JDK默认的垃圾回收器是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在不同版本的Java开发工具包（JDK）中，JDK默认的垃圾回收器可能会有所不同。然而，自从Java 9发布后，G1（Garbage-First）垃圾回收器成为了Java平台的默认垃圾回收器。在此之前，Java 8及之前版本的默认垃圾回收器是Parallel GC（并行垃圾回收器）。
简要概括如下：
Java 8及之前版本：Parallel GC是默认的垃圾回收器。它通过多线程并行地进行垃圾收集，适用于多核处理器，并且通常用于处理大型堆内存。 Java 9及以后版本：G1垃圾回收器成为了默认的垃圾回收器。G1垃圾回收器是一种面向服务端应用的垃圾回收器，它采用了分代的垃圾回收策略，可以更加灵活地管理堆内存，并且能够在不牺牲太多吞吐量的情况下实现更加可预测的垃圾回收。 需要注意的是，虽然G1是默认的垃圾回收器，但在特定的场景下，开发人员仍然可以选择使用其他的垃圾回收器，如CMS（Concurrent Mark-Sweep）回收器或者Serial GC，以满足特定应用程序的性能和稳定性需求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caf1f073b15d24addf99148c281c5676/" rel="bookmark">
			Linux下PostgreSQL-12.0安装部署详细步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装环境 postgresql-12.0CentOS-7.6注意：确认linux系统可以正常连接网络，因为在后面需要添加依赖包。 二、pg数据库安装包下载 下载地址：PostgreSQL: File Browser
选择要安装的版本进行下载：
三、安装依赖包 在要安装postgresql数据库的Linux服务器上执行以下命令安装所需要的依赖包：
yum install -y perl-ExtUtils-Embed readline-devel zlib-devel pam-devel libxml2-devel libxslt-devel openldap-devel python-devel gcc-c++ openssl-devel cmake 四、安装postgres 1、在根目录下新建/opt/pgsql文件夹，并将pgsql的压缩包移入。
2、解压压缩包
tar -zxvf postgresql-12.0.tar.gz 3、进入解压后的文件夹 cd postgresql-12.0 4、编译postgresql源码
./configure --prefix=/opt/pgsql/postgresql make make install 至此，已完成postgreql的安装。进入/opt/pgsql/postgresql目录可以看到安装后的postgresql的文件。
五、创建用户组postgres并创建用户postgres groupadd postgres useradd -g postgres postgres id postgres 六、创建postgresql数据库的数据主目录并修改文件所有者 这个数据库主目录是随实际情况而不同，这里我们的主目录是在/opt/pgsql/postgresql/data目录下 mkdir data chown postgres:postgres data 七、配置环境变量 进入home/postgres目录可以看到.bash_profile文件。
cd /home/postgres ls -al 编辑修改.bash_profile文件。
vim .bash_profile 添加以下内容。
export PGHOME=/opt/pgsql/postgresql export PGDATA=/opt/pgsql/postgresql/data PATH=$PATH:$HOME/bin:$PGHOME/bin 保存，退出vim。执行以下命令，使环境变量生效
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/caf1f073b15d24addf99148c281c5676/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c520a2abfc82a360ce9f55e6f1148574/" rel="bookmark">
			数据仓库数据分层详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数据仓库中的数据分层是一种重要的数据组织方式，其目的是为了在管理数据时能够对数据有一个更加清晰的掌控。以下是数据仓库中的数据分层详解：
原始数据层（Raw Data Layer）：这是数仓中最底层的层级，用于存储从各个数据源获取的原始数据。这些数据通常是未经处理和清洗的，包括来自数据库、日志文件、传感器等的数据。原始数据层的目的是保留数据的完整性和可追溯性，以备后续的数据处理和分析。数据清洗层（Data Cleansing Layer）：该层对原始数据进行清洗、去重、转换和标准化等处理。在这一层中，数据质量和一致性是关键考虑因素。清洗后的数据可以更好地支持后续的数据分析和建模。集成层（Integration Layer）：这一层是将来自不同数据源的数据进行整合和集成的层级。数据被转换为一致的格式和结构，以便于跨数据源的查询和分析。集成层通常包括数据仓库和数据集市等组件，数据被组织为维度和事实表的结构，以支持多维分析和报告。 此外，数据仓库中还有更细化的分层，例如数据明细层（DWD）、数据中间层（DWM）和数据服务层（DWS）等。这些分层使得数据仓库的设计更加复杂和精细，能够更好地满足不同的数据需求。
1、ODS层
数据仓库ODS层，即操作型数据存储层（Operational Data Store），是数据仓库的第一层，主要用来接收和存储数据源系统中的数据，同时保证数据的准确性和完整性。
数据源中的数据，经过ETL（即抽取、转换、装载）过程后，装入本层。这一层中的数据，大多是按照源业务系统的分类方式而分类的。ODS层会对数据进行简单的清洗、去重、格式转换等操作，为后续的数据处理提供基础数据。由于该层是最接近数据源的，因此不建议对该层数据做过多的数据清洗工作。
此外，ODS层的作用还包括支持数据仓库ETL过程，将ODS层中的数据转换为适合DW层使用的格式；支持历史数据追溯，以便用户进行历史趋势分析；以及减轻源系统负担，提高系统性能。
2、DWD层
数据仓库DWD层，即数据仓库明细层（Data Warehouse Detail），是数据处理的核心层，其主要任务是将ODS层中的数据进行清洗、加工、集成、聚合等操作，构建出符合业务需求的数据模型。
DWD层的主要目的是将业务数据库中的数据进行清洗和整合，形成相应的事实表。这些事实表是数据仓库维度建模的核心，紧密围绕业务过程来设计。DWD层会对业务方的整个业务过程进行分析，明确关键的业务步骤，并在满足业务需求的前提下，尽可能设计出更通用的模型。
在DWD层中，主要的事实表有三种类型：事务事实表、周期快照事实表和累积快照事实表。这些事实表为后续的决策层提供了精细化的数据支持。
3、DWB层
数据仓库DWB层，即数据仓库基础层（Data Warehouse Basic），位于数据仓库架构的中间位置，也是数据仓库中最核心的一层。
该层的主要任务是对DWD层中的数据进行进一步的加工和整合，以形成适合于决策分析的数据结构和粒度。在DWB层中，数据被进一步处理以满足不同决策分析需求的数据展示需求。这一层主要包括抽取、转换、加载和归并四个部分，需要对数据进行过滤、排序和校验等处理，以消除重复值并确保数据格式的统一性。同时，DWB层还可以根据不同的维度来建立多维数据模型，以支持灵活的数据查询和分析。
4、DWS层
数据仓库DWS层，即数据仓库服务层（Data Warehouse Service），是数据仓库架构中的关键组成部分，主要用于数据存储、数据处理、数据管理和数据查询。它是数据仓库的核心部分，具备高效的数据管理和存储能力。
在DWS层中，数据通常是按照主题和业务领域进行组织，以方便数据分析和查询。该层主要用于存储和管理数据，通过ETL操作等方式对数据进行加工和处理，为用户提供实时数据服务。此外，DWS层还可以提供各种类型的服务，如数据查询、统计、报表、分析等，以满足业务决策的需求。
从数据存储形式来看，DWS层主要采用列式存储方式，这种方式适合于批量查询和OLAP（联机分析处理）操作。而与之相对的是，ADS层（数据应用服务层）则主要采用行式存储方式，更适合于实时查询和OLTP（联机事务处理）操作。
5、ADS层
数据仓库ADS层，即应用数据服务层（Application Data Store），是数据仓库架构的顶层，主要用于为各种应用提供数据服务。
ADS层一般以业务或者部门来划分库，可以为各个业务线创建一个数据库。该层的数据是基于底层数据（如DWD层或DWS层的数据）生成的业务报表数据，可以直接作为数据仓库的输出，导出到外部的操作型系统中，如MySQL、HBase等。在数据仓库的分层架构中，ADS层是数据应用的最后一层，提供的是结果类型的数据，这些数据可以直接用于展示或进一步的分析。
同时，ADS层的数据抽离分析程度最高，因此是需求最明确的一层。它根据业务需求来决定数据维度和结果，以满足各种应用的数据需求。
数据仓库分层的主要优势包括：
把复杂问题简单化：将复杂的任务分解成多层来完成，每一层只处理简单的任务，方便定位问题。减少重复计算：规范数据分层，通过的中间层数据，能够减少极大的重复计算，增加一次计算结果的复用性。隔离原始数据：不论是数据的异常还是数据的敏感性，使真实数据与统计数据解耦开。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82e1efab17ba3e2f2ac8c6e55d12fda3/" rel="bookmark">
			VScode&#43;Maven&#43;Tomcat构建java Web开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		去我博客看吧，csdn图片炸了，点这里
前言 本文记录使用vscode搭建基于maven的Java Web 环境。
::: warning
注意
经过查证，VSC并不适合作为JSP文件的编辑器，就连微软也对此持推诿态度，因此，我们建议读者使用Intellij IDEA或者Eclipse来开发JAVA Web程序。
如果你仍然执着于使用VSC编辑你的JSP(犟种)，你可以继续往下看。
:::
1 资源列表 1.1 相关链接 名称链接1（官网）链接2（本站）VS CodeDownload Visual Studio CodeMaven 3Maven – Download Apache MavenTomcat 9Apache Tomcat® - Apache Tomcat 9 软件下载open JDK 17存档的 OpenJDK GA 版本 (java.net) 部分站点国内访问受限，无法打开请自行解决。
1.2 说明 如未特殊说明，如果没有exe文件，请下载zip格式的文件，稍后提供环境变量配置方法。vscode建议下载system installer版本，安装时勾选添加到环境变量和添加右键菜单。maven下载最新版本即可Tomcat请下载9.x版本zip文件，10以及最新版本仍然有问题。JDK请下载17（zip资源），较高的版本（21）在某些情况下导致Maven无法生成pom文件。 2 安装和配置资源 2.1 安装 除了VS Code之外，其他的软件都解压到预安装位置，本文对应位置如下：
名称位置open JDK 17D:\Program Files\Java\JDK_17Tomcat 9D:\Program Files\Servers\Tomcat_9Mavern 3D:\Program Files\Servers\Maven_3 2.2 配置环境变量以及配置文件 本小节所有环境变量均为系统环境变量，且所有名为Path的变量均为path变量追加内容
::: danger
注意
误删Path将会导致系统出现无法拯救的问题，请当心!!!
:::
2.2.1 Open JDK NameValueJAVA_HOMED:\Program Files\Java\JDK_17Path%JAVA_HOME%\bin; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82e1efab17ba3e2f2ac8c6e55d12fda3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c776054843d7472950e93eb9cbc52fa7/" rel="bookmark">
			Oracle使用数据泵expdp、impdp导入导出指定表详解（数据库服务器为Linux）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载安装Xshell（执行导入导出脚本）和Xftp（直观展示Linux服务器文件目录详情）
家庭/学校免费版，下载地址：XFTP - NetSarang Website家庭/学校免费 - NetSarang WebsiteXFTP - NetSarang Website
2、使用Xshell，登录数据库服务器（用户名一般为:oracle），使用oracle用户登录成功后，也可使用 su - root 命令切换至root用户
3、指定导出的数据库文件地址，使用命令 sqlplus / as sysdba，连接数据库，使用命令 create directory data_test as '/mnt/data' 指定数据库文件地址（其中data_test代表目录别名，后续会用到，'/mnt/data'代表Linux服务器物理路径）
4、给要导出的数据库用户，授予文件读取的权限，比如要导出的数据库用户名为：TEST，密码：TEST，则使用命令：Grant read,write on directory data_test to TEST;
5、断开连接数据库，命令：quit;
6、使用导出命令，导出自己想要的表t_table1和t_table2，命令：
expdp TEST/TEST tables=t_table1,t_table2 dumpfile=test.dmp directory=data_test logfile=expdp.log;
关于导入、导出的参数详解，请看：Oracle数据泵EXPDP/IMPDP导出导入功能详细深入解析_oracle_脚本之家
7、使用Xftp查看成功导出的文件，在目录/mnt/data中就能看到
8、通过Xftp，将导出的数据库文件test.dmp拷贝至自己电脑桌面，然后再从自己电脑桌面，拷贝至要导入的数据库服务器上（例如目录：/mnt/target），一般会提示权限不足（permmsion denied）；
这时使用Xshell登录要导入的目标服务器，并切换至root用户，使用命令：chmod 777 /mnt/target 给其他用户授予读写的权限，然后再拷贝数据库文件
9、使用Xshell，使用命令 sqlplus / as sysdba，连接目标数据库，并给要导入的用户，比如：target数据库用户，密码：target，授予读写的权限；命令：
create directory data_target as '/mnt/target';
Grant read,write on directory data_target to target;
10、断开目标数据库连接，命令：quit;
11、使用导入命令，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c776054843d7472950e93eb9cbc52fa7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/377440ae1a0b0157dee5ace6f9383829/" rel="bookmark">
			【JAVA】Date、LocalDate、LocalDateTime 详解，实践应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Date、LocalDate、LocalDateTime 详解，实践应用 一、Date、LocalDate 简介1、 `java.util.Date`：2、 `java.time.LocalDateTime`：3、 `java.time.LocalDate`： 二、输出格式1、使用 java.util.Date 的示例代码如下：2、使用 java.time.LocalDateTime 的示例代码如下： 三、区别1、表示的范围：2、线程安全性：3、可读性和易用性：4、时区： 四、项目中的使用1、数据库中的数据是date类型，在实体类中对应什么类型？（1）使用 java.sql.Date：（2）使用 java.time.LocalDate： 2、数据库中的数据是time类型，在实体类中对应什么类型？（1）使用 java.sql.Time：(2)、使用 java.time.LocalTime： 一、Date、LocalDate 简介 在 Java 中，处理日期和时间的方式经历了演变。在 Java 8 之前，主要使用 java.util.Date 类来表示日期和时间，但它存在一些问题，如不可变性、线程安全性等。Java 8 引入了新的日期时间 API，位于 java.time 包中，提供了更加强大、易用和安全的日期时间处理方式。以下是对于不同类型的时间表达的详细解释：
1、 java.util.Date： 是 Java 中早期用于表示日期和时间的类。 表示一个特定的日期和时间，以自 1970 年 1 月 1 日 00:00:00 GMT 以来的毫秒数来表示。 不可变的，表示一个时间点，但是其设计存在一些问题，如线程不安全、设计上不够清晰等。
2、 java.time.LocalDateTime： 是 Java 8 中引入的日期时间类之一，位于 java.time 包中。 表示不带时区的日期和时间，即一个本地的日期时间，不受时区影响。使用 LocalDateTime.now() 来获取当前本地日期时间。 例如LocalDateTime.of(2022, Month.JANUARY, 1, 12, 0) 可以创建一个表示 2022 年 1 月 1 日中午 12 点的 LocalDateTime 对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/377440ae1a0b0157dee5ace6f9383829/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b493ac104a3fdb192894d01323e23dd6/" rel="bookmark">
			「哈哥赠书活动 - 50期」-『AI赋能写作：AI大模型高效写作一本通』
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		⭐️ 赠书 - 《AI赋能写作：AI大模型高效写作一本通》 ⭐️ 内容简介 本书以ChatGPT为科技行业带来的颠覆性革新为起点，深入探讨了人工智能大模型如何为我们的创作提供强大支持。本书旨在帮助创作者更好地理解AI的价值，并充分利用其能力提升写作效率和质量。本书共7章，全面阐述了ChatGPT如何帮助创作者突破写作瓶颈、建立稳固的创作基础，并掌握高效成稿能力。此外，书中还详细介绍了在各类创意写作和职场写作领域中，如何利用ChatGPT进行高效创作。同时，本书还深入探讨了提示词在创作过程中所发挥的关键节点效应，以及ChatGPT如何帮助创作者塑造个人品牌价值，进而提升个人在职场中的发展空间。本书以通俗易懂的语言和丰富的案例，为致力于提高写作效率的创作者、追求结构化表达的商业人士等群体提供了实用的指导。此外，本书还可以作为相关培训课程的教材使用，帮助读者更好地掌握人工智能大模型在写作中的应用。 全书分为 7 章：第一章 2 个要点摸清ChatGPT如何高效赋能写作 1.1　ChatGPT 带来的 3 大颠覆性革新1.2　ChatGPT 为写作赋予的 4 项能力 第二章 3 个步骤洞察提示词如何发挥关键节点效应 2.1　塑造高成就角色的 2 个技巧2.2　给出开放性指令的 4 个技巧2.3　设定期望目标的 3 个技巧 第三章 3 个细节突破预设的写作瓶颈 3.1　完善写作准备的 5 个技能3.2　聚焦“擅长”定位的 4 个策略3.3　发掘爆款选题的 4 个策略 第四章 3 个方面建立坚实的创作基础 4.1　构思严谨的 3 种提纲结构4.2　汲取创意灵感的 6 种方法4.3　打造吸睛标题的 6 种方法 第五章 4 个技巧提升成稿能力 5.1　写出引人入胜的开头的 6 个策略5.2　写出令人回味的结尾的 6 个策略5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b493ac104a3fdb192894d01323e23dd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a96e8aeceb49e9da7d2c9bdfdf41c12/" rel="bookmark">
			Java经典代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.九九乘法表 代码图：
package day0306; ​ public class Demo01 { public static void main(String[] args) { for (int i = 1; i &lt;= 9; i++) { for (int j = 1; j &lt;= i; j++) { System.out.print(i+"*"+j+"="+(i*j)+" "); } System.out.println(); } } } 效果图：
​ 1*1=1 2*1=2 2*2=4 3*1=3 3*2=6 3*3=9 4*1=4 4*2=8 4*3=12 4*4=16 5*1=5 5*2=10 5*3=15 5*4=20 5*5=25 6*1=6 6*2=12 6*3=18 6*4=24 6*5=30 6*6=36 7*1=7 7*2=14 7*3=21 7*4=28 7*5=35 7*6=42 7*7=49 8*1=8 8*2=16 8*3=24 8*4=32 8*5=40 8*6=48 8*7=56 8*8=64 9*1=9 9*2=18 9*3=27 9*4=36 9*5=45 9*6=54 9*7=63 9*8=72 9*9=81 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a96e8aeceb49e9da7d2c9bdfdf41c12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0072f6002a06664e4128febd91506a00/" rel="bookmark">
			一键美化ppt的ai工具有哪些？推荐5款自动生成PPT的ai软件！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		伴随着 ai 人工智能技术的发展，作为普通个体的我们，也有机会享受到技术发展带来的红利，比如用 ai 来润色文章，用 ai 来美化 ppt 演示文稿，用 ai 辅助进行数据分析等等，ai 的应用场景多种多样，使用得当的话，可以极大地赋能个体，轻松完成绝大部分工作。
譬如职场中最常见的 PPT 制作场景，你是否曾为了制作一份精美的 PPT 而熬夜，只为了在会议中给人留下深刻的印象？或者是在准备 PPT 报告的过程中，苦恼于如何将枯燥的数据转化为生动有趣的视觉展示？
如果你有过这样的经历，不要担心，在 ai 时代这些都会成为过去！现在就有一些 ppt 美化 AI 工具可以轻松解决这些问题，它们能够基于输入的 PPT 主题，自动生成美观的 PPT，让我们在制作 PPT 报告或演讲时更加轻松。接下来，我将介绍业内 5 款非常优秀的 AI 美化 PPT 软件，它们不仅能节省你的时间，还能一键生成不同风格的精美 PPT。
ppt 美化 ai 软件是什么？ PPT 美化 AI 软件，也叫 AI 美化 PPT 软件，是指使用 AI 人工智能技术来提升 PPT 演示文稿的视觉效果和专业感的软件。这类软件可以自动调整 PPT 的布局、颜色、字体等元素，使其看起来更加专业和吸引人。它们通常具有用户友好的界面，并且能够根据用户的需求和喜好进行个性化的设计。这样，即使用户不具备专业的设计技能，也能制作出高质量、精美的 PPT 演示文稿。
*ppt美化ai软件
ppt 美化 ai 软件有哪些特点？ ai 大火，也让市场上出现了很多基于 ai 技术打造的工具软件，其中包括了这里提及的 ppt 美化 ai 软件，目前国内外有多款 ppt 美化 ai 软件可供选择，具体到每一款 ppt 美化 ai 软件，彼此间存在着差异，但在宏观层面，这些 ppt 美化 ai 软件又有诸多共性，表现在——
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0072f6002a06664e4128febd91506a00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c5673e1bbcdbd1a68b78a3242318689/" rel="bookmark">
			【大模型API调用初尝试一】智谱AI &amp;&amp; 通义千问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大模型API调用初尝试一 调用大模型API能干什么智谱AI大模型API调用的过程获取API_KEYGLM_4同步调用GLM_4异步调用文生图大模型API调用 阿里云通义千问API调用过程单轮会话多轮会话 调用大模型API能干什么 大模型的参数非常庞大，功能非常强大，但是训练成本高昂，因此个人或者小企业自己去训练一个大模型是不可能的。我们可以通过直接调用大模型的API，将大模型集成到自己的应用中。 大模型的API就是一个接口，类似MaaS，用户通过调用API访问大模型，获得大模型针对用户prompt（问题）的输出，一般输出是json格式的，然后我们利用这个输出进行后续的操作。
但是大模型是一个已经训练好的模型，类似一个封装好的盒子，其能够运用的知识是有限的，比如chatgpt的知识截至2021年9月，让它提供实时的天气预报是不可行的，因此现在的大模型API中还增加了外部API/函数的调用功能，大模型能够根据用户的prompt确定要去调用的外部API/function–&gt;调用外部API/function并获得结果–&gt;大模型整合结果再输出，如下图所示：
我们可以参考某一个大模型对应的官方文档，学习如何调用其API。
智谱AI大模型API调用的过程 智谱AI是清华大学计算机系技术成果转化而来的公司，公司产品包括：中英双语千亿级超大规模预训练模型GLM-130B，并基于此推出对话模型ChatGLM；高效率代码模型CodeGeeX；多模态理解模型CogVLM和文生图模型CogView等。
获取API_KEY 调用API首先需要获取API，每个用户需要自己注册申请对应的API。进入智谱AI官网，注册后申请API，复制API_KEY以便后续调用：
现在打开API调用参考文档：通用大模型和图像大模型，直接复制其代码，看看输出是什么样的！
GLM_4同步调用 同步调用就是创建一个调用任务后，一直运行这个任务直到收到大模型的响应输出；对应的是异步调用，创建调用任务后获得这个任务的request-id，之后可以去干其他事情，后续通过这个任务ID查看模型的输出。
from zhipuai import ZhipuAI # 先安装ZhipuAI的包 pip install ZhipuAI client = ZhipuAI(api_key="xxxx") # 填写您自己的APIKey response = client.chat.completions.create( model="glm-4", # 填写需要调用的模型名称 messages=[ # messages是json格式的数据，大模型逐条响应 {"role": "user", "content": "作为一名营销专家，请为我的产品创作一个吸引人的slogan"}, {"role": "assistant", "content": "当然，为了创作一个吸引人的slogan，请告诉我一些关于您产品的信息"}, {"role": "user", "content": "智谱AI开放平台"}, {"role": "assistant", "content": "智启未来，谱绘无限一智谱AI，让创新触手可及!"}, {"role": "user", "content": "创造一个更精准、吸引人的slogan"} ], ) # 直接输出response，查看响应的具体内容 print(response) 输出的完整json数据：
如果只关注最终输出的message的content，可以只取response.choices[0].message.content。
上面例子传入大模型的message列表里面，有user的信息，也有assistant的信息，大模型实际响应的只有user对应的content，但是assistant的内容可以为大模型提供一些上下文或者提示。
message只传入用户的输入，并多次问答的例子如下：
from zhipuai import ZhipuAI client = ZhipuAI(api_key="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c5673e1bbcdbd1a68b78a3242318689/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bc5145d20e8e3acb64cae24299c452c/" rel="bookmark">
			轻松上手MacOS：HomeBrew安装全指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		轻松上手MacOS：HomeBrew安装全指南 你是否曾为在MacOS上安装软件而烦恼？是否想要一个既强大又简单的包管理器来简化你的安装过程？HomeBrew正是你所需要的工具。作为MacOS上的包管理器，HomeBrew让安装软件变得像数123一样容易。在这篇博客里，我将向你详细介绍如何在MacOS上安装和使用HomeBrew。
什么是HomeBrew？ HomeBrew是一个免费且开源的包管理器，它简化了MacOS用户安装软件的过程。无论是命令行工具、语言运行时还是应用程序，HomeBrew都能帮助你轻松管理。它的口号是“The missing package manager for macOS”，意即它弥补了MacOS缺失的包管理功能。
安装前的准备 在安装HomeBrew之前，请确保你的MacOS系统满足以下条件：
MacOS版本至少为10.14（Mojave）或更新版本。
你的Mac拥有英特尔处理器或Apple Silicon处理器。
安装了Xcode的命令行工具。如果未安装，请打开终端（Terminal）并输入以下命令：
xcode-select --install 按照提示完成安装即可。
安装HomeBrew 安装HomeBrew非常简单，只需打开终端并输入以下命令：
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" 该命令会从HomeBrew的GitHub仓库下载安装脚本并执行。在安装过程中，可能会提示你输入管理员密码，以便安装必要的组件。
如果你使用的是Apple Silicon（M1, M1 Pro, M1 Max等）的Mac，终端可能会提示你在Rosetta 2下打开一个新的终端窗口来完成安装。Rosetta 2是Apple为了兼容性而提供的一个转译层，它可以让你运行为英特尔处理器优化的软件。
安装完成后，你可以通过以下命令来检查HomeBrew是否安装成功：
brew doctor 如果看到Your system is ready to brew.的消息，恭喜你，你已经成功安装了HomeBrew！
使用HomeBrew安装软件 有了HomeBrew，安装软件只需要一条简单的命令。比如，如果你想安装wget，只需输入：
brew install wget HomeBrew会自动下载并安装wget及其依赖。安装完成后，你可以直接使用wget了。
更新和卸载软件 使用HomeBrew，你还可以轻松更新和卸载软件。要更新所有已安装的包，使用：
brew update brew upgrade 如果你想卸载某个软件，只需：
brew uninstall 软件名称 例如，要卸载wget，只需输入：
brew uninstall wget 小结 HomeBrew是MacOS上的必备工具，它使得安装、更新和卸载软件变得简单快捷。通过本文的介绍，相信你已经掌握了如何在MacOS上安装和使用HomeBrew。现在，尽情探索HomeBrew的强大功能吧！
记得，要想更深入了解HomeBrew的高级用法，可以访问官方文档或关注我们的博客，我们会不定期更新更多实用的技巧和教程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c008988f9ffd1247b8bf8ff20f727174/" rel="bookmark">
			qt 汉字输出 中文输出 显示乱码 qDebug() 乱码 解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要正确显示汉字，必须要先了解计算机文字编码相关知识，参考：
unicode ucs2 utf16 utf8 ansi GBK GB2312 互转 及 渲染_ucs2编码转换-CSDN博客 qt vs 编程 字符编码 程序从源码到编译到显示过程中存在的字符编码-CSDN博客
1、汉字输出到 应用程序输出面板 qt 自定义的输出类qDebug() 、QDebug对象、QMessageLogger默认输出到 应用程序输出面板 当qt使用vs编译器时，对于输出到应用程序输出面板上时，给OutputDebugStringW()投喂unicode的utf-16编码的字符串，对于GB2312范围内的字符串是不会乱码的或出现文字遗失的。
当qt使用mingw编译器时，输出到应用程序输出面板上时，给OutputDebugStringW()投喂unicode的utf-16编码（双字节）的字符串，会被莫名其妙的按单个字节拆成unicode的utf16编码，暂时还没找到什么原因。比如"你好" ，utf16为0x4F60 0x597D，但是在选用Mingw编译器输出到output panel时显示成ÄãºÃ，对应的utf16编码为：0x00C4 0x00E3 0x00BA 0x00C3
下面是两个可以直接显示到output panel 的windows api。加上&lt;windows.h&gt;就可以直接调用
OutputDebugStringW(L"aaa你好"); //windows api，用于将utf16编码的字符串显示到output panel上 OutputDebugStringA("aaa你好"); //windows api，用于将ansi编码的字符串显示到output panel上 2、汉字输出到控制台窗口 qt自定义输出类QDebug类、qDebug()、QMessageLogger类、qt_message_output() 默认输出到到qt ide 的 应用程序输出面板 (application output panel）上，需要通过设置来输出到 控制台窗口
vs qt 调试 输出 打印 到 输出窗口 或 控制台窗口_qt输出信息到窗口-CSDN博客
控制台窗口显示正确的汉字需要很小心。
1、最基础的是要明确知道你投喂给控制台窗口的字符串是什么编码的。QString中字符串是以unicode的utf16编码进行保存的。当需要输出到控制台的时候，内部会通过QTextCodec进行转码，转成QTextCodec所设置的目标编码的字符串。然后再输出给控制台。
2、控制台只支持显示兼容ascii编码的编码方式，可以是ansi（GB2312），可以是utf8，但是不支持显示utf16编码。
控制台所支持的字体库有限，并且只能是GB2312字符集，对于超出的显示会乱码或两问号。具体原因比较复杂。
通过system("chcp 65001"); 设置控制台显示utf8编码的字符，通过system("chcp 936")，设置控制台显示GB2312编码的字符。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c008988f9ffd1247b8bf8ff20f727174/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a00b513a9f62ae29d1200403aa9954d/" rel="bookmark">
			详细完整pycharm远程连接服务器，远程环境配置，虚拟环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pycharm远程连接，远程环境配置，虚拟环境配置 写这篇文章的目的虚拟环境的创建pycharm远程连接服务器 写这篇文章的目的 我发现很多教程其实都比较偏向于有基础的人，对于完全没有基础的人来说，一些微小步骤的省略都是难以跨域的鸿沟。因此，想写一篇适合小白的配置过程。
虚拟环境的创建 想要在pycharm上远程连接服务器，那我们得先创建一个虚拟环境，我们可以用xshell来操作。（可以自己去下载，这里不提供资源噢）
打开xshell连接服务器，点击左上角文件，新建
然后再next填密码啥的你就连上了。
连上了之后，开始下载anaconda，输入
wget https://repo.continuum.io/archive/Anaconda3-2021.05-Linux-x86_64.sh这句话就好
输入完了之后，输入bash Anaconda3-2021.05-Linux-x86_64.sh一直回车，需要输入yes或no的地方输入yes就好了
安装完成之后输入conda info看看有没有显示信息，有的话恭喜你成功安装
没有的话（注意这是说没有的话，有的不要进行这一步！！！），输入vim ~/.bashrc 然后按I键（没错就是键盘上的那个英文字母I）进入编辑模式，再最后一行加入export PATH=/home/XXX/anaconda3/bin:$PATH（这个XXX就是你登录的那个名字，不知道的话你也可以输入pwd看看你现在的地址），修改完之后按esc退出修改模式，再输入:w保存，输入:q退出 (冒号不要漏掉啊)，再输入source ~/.bashrc更新文件，最后再输入conda info就可以看到信息了
恭喜你装完了anaconda，接下来我们需要看看虚拟环境的默认地址。一般来说是要在anaconda/envs下面的，但是有一些的默认地址在.conda/envs下面,同样输入conda info看看envs_dirs虚拟环境地址是在哪，如果在anaconda下就不要管，在.conda下的话，我们得继续长征。
我们可以输入conda config --add envs_dirs /home/xxx/anaconda3/envs来指定虚拟环境位置（我这是anaconda3啊，你那里是啥你自己瞅瞅，可以输入ls看看有哪些文件夹）
okk更改成功之后，开始创建我们的虚拟环境，输入conda create -n xxx python=3.8（xxx是你的虚拟环境想要叫什么，3.8是我想要3.8，你想要多少随便你自己）
该你输入yes你就输入yes,如果创建过程很缓慢的话，你就试着换源，至于怎么换源你看这个地址https://cloud.tencent.com/developer/article/1572996（别急着看，这里有一步是找到.condarc文件，方法是输入 vim .condarc之后就是上面提到的步骤按I进入编辑模式，编辑后ESC 退出编辑模式，输入:w保存，输入;q退出 冒号不能丢）一切完成之后你再create一遍就好了
然后你的环境就创建成功了，接着你就进入你的环境，输入conda activate xxx（xxx是你自己取的名字，不要忘记了）
进入了之后你就可以下载pytorch了（至于下载哪个版本的pytorch这就不是我这个教程要教的了，你自己去查hhh,好吧你也可以输入nvidia-smi看看你的cuda版本，再去查查对对应的pytorch），反正我是输入conda install pytorch== 1.11.0 torchvision== 0.12.0 torchaudio==0.11.0 cudatoolkit=10.2 -c pytorch（注意去掉==后面的空格，我这里为了格式隔开来了）
如果很慢失败，老规矩继续换源https://blog.csdn.net/weixin_44413191/article/details/107849696看这个教程，这个不用细讲了哈
基础的咱已经搞好了，开始打开你亲爱的pycharm
pycharm远程连接服务器 选择file然后点击settings
话不多说，如图所示
选择add
填IP，填名字
输入密码，再下一步
6. 6、选择虚拟环境，第一个糊掉的地方是你登录的名字，第二个是你虚拟环境的名称
7、选择映射地址，最好自己创建一个文件夹放啊，比如我又一个项目叫test，那我可以创建一个文件夹叫demo，demo里面再创建一个文件夹叫test。如图所示糊掉的是登录名
8、finish 然后该点啥点啥
9、完美
10.开启一下自动更新，也可以开启一下SSH连接，这样子你就可以在terminal里对服务器进行操作了
OKK 完结撒花，没补的图看心情以后补补。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a00b513a9f62ae29d1200403aa9954d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86f415b7b7a15b9884cbf770f7738ea3/" rel="bookmark">
			数据结构——二叉树的遍历【前序、中序、后序】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💞💞 前言 hello hello~ ，这里是大耳朵土土垚~💖💖 ，欢迎大家点赞🥳🥳关注💥💥收藏🌹🌹🌹
💥个人主页：大耳朵土土垚的博客
💥 所属专栏：数据结构学习笔记 、C语言系列函数实现
💥对于数据结构顺序表、链表、堆有疑问的都可以在上面数据结构的专栏进行学习哦~ 有问题可以写在评论区或者私信我哦~
复习巩固：🥳🥳 在学习二叉树基本操作前，再回顾下二叉树的概念，二叉树是：
空树非空：根节点，根节点的左子树、根节点的右子树组成的。
从概念中可以看出，二叉树定义是递归式的，因此后序基本操作中基本都是按照该概念实现的。 一、手动创建一个简单二叉树🥳🥳 在学习二叉树的基本操作前，需先要创建一棵二叉树，然后才能学习其相关的基本操作。由于现在大家对二叉树结构掌握还不够深入，为了降低大家学习成本，此处手动快速创建一棵简单的二叉树，快速进入二叉树操作学习，等二叉树结构了解的差不多时，我们反过头再来研究二叉树真正的创建方式。
手动创建简单二叉树代码如下：
typedef struct BinaryTreeNode { BTDataType data; struct BinaryTreeNode* left; struct BinaryTreeNode* right; }BTNode; BTNode* BuyNode(BTDataType x) { BTNode* newnode = (BTNode*)malloc(sizeof(BTNode)); if (newnode == NULL) { perror("malloc fail"); return NULL; } newnode-&gt;right = NULL; newnode-&gt;data = x; newnode-&gt;left = NULL; return newnode; } BTNode* CreatBinaryTree() { BTNode* node1 = BuyNode(1); BTNode* node2 = BuyNode(2); BTNode* node3 = BuyNode(3); BTNode* node4 = BuyNode(4); BTNode* node5 = BuyNode(5); BTNode* node6 = BuyNode(6); node1-&gt;left = node2; node1-&gt;right = node4; node2-&gt;left = node3; node4-&gt;left = node5; node4-&gt;right = node6; return node1; } 创建的二叉树逻辑结构如下图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86f415b7b7a15b9884cbf770f7738ea3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bd0416d561e1fb2f6e3ba825e513232/" rel="bookmark">
			深入了解Kafka的数据持久化机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到我的博客，代码的世界里，每一行都是一个故事 深入了解Kafka的数据持久化机制 前言持久化的基本概念硬盘存储与日志段1. 磁盘存储：2. 日志段： 数据的索引与检索1. 索引的作用：2. 高效的数据检索： 日志段的滚动和管理1. 日志段的管理：2. 日志段的滚动： 前言 在消息传递的舞台上，数据就像是时间的旅行者，承载着信息的流动。然而，时间不停歇。本文将带你进入数据的永恒之路，探寻在Kafka中，数据如何通过持久化机制守护信息的不朽之旅。
持久化的基本概念 持久化的基本概念：
在 Kafka 中，持久化是指将消息保存在磁盘上，以确保数据在发生故障或重启时不会丢失。持久化是 Kafka 的核心原理之一，确保消息的可靠性和持久性。
基本原理：
消息写入到日志文件：
Kafka 中的消息首先被追加写入到一个称为日志（Log）的文件中。这个日志文件是一个持久化的、有序的、不可修改的消息记录。 磁盘存储：
一旦消息写入到日志文件中，就会被存储在磁盘上。这样即使 Kafka 服务发生故障、Broker 重启，消息数据仍然可以从磁盘上加载并重新构建。 消息索引：
为了快速检索消息，Kafka 维护了一个消息索引。这个索引存储了每个分区中消息的偏移量和物理位置，使得 Kafka 能够快速定位和检索消息。 复制和 ISR：
为了进一步提高可靠性，Kafka 支持消息的复制。每个分区的消息可以有多个副本，它们分布在不同的 Broker 上。ISR（In-Sync Replica）机制确保了 Leader 和 Follower 之间的数据同步，保障了消息的持久性。 为何数据持久化是不可或缺的组成部分：
数据可靠性：
持久化确保了数据的可靠性。一旦消息被写入到磁盘，即使 Kafka 服务发生故障，消息也不会丢失。这是关键的特性，尤其对于需要保障每条消息可靠传递的应用场景而言。 系统容错：
持久化是 Kafka 实现系统容错的基础。通过将消息保存在磁盘上，Kafka 可以在发生故障时迅速恢复，保持数据的一致性和可用性。 消息顺序性：
持久化保障了消息的顺序性。消息按照写入的顺序追加到日志文件中，这确保了消息在磁盘上的存储和检索是有序的。 支持离线消费：
持久化使得 Kafka 支持离线消费场景。即使消费者在消息产生后的一段时间内连接不上 Kafka，它仍然可以获取到过去存储在磁盘上的消息。 综上所述，数据持久化是 Kafka 消息传递的关键组成部分，它确保了消息的可靠传递、系统容错性和高性能。
硬盘存储与日志段 磁盘存储与日志段：
Kafka 将消息持久化存储到磁盘的主要机制是通过使用日志（Log）的概念。以下是 Kafka 中磁盘存储和日志段的基本原理：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bd0416d561e1fb2f6e3ba825e513232/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ca42bb13fdfb44e649cdb2ccfc5f106/" rel="bookmark">
			Transmission的容器化部署与webui增强、权限设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Transmission是一款流行的BitTorrent客户端，也是很多PT站推荐的客户端，和qBittorrent相比两者各有特色。本文介绍在armbian上容器化安装部署transmission的方法，并将保存目录映射为外置硬盘、增强/美化webui界面等配置方法一并进行说明。本文是盒子/NAS党主题博文的其中一篇，示例平台为大街货S905l3a方案盒子，更多相关内容敬请关注「」。
安装与使用 基于ophub非官方armbian，使用armbian-software脚本，可以很方便的安装、卸载、升级相关的软件包docker镜像。
armbian-software armbian-software脚本加载后，输入104以选择transmission。
脚本自动拉取transmission镜像并创建、加载容器，在拉取前，需要指定transmission的管理员用户名、密码。默认管理员用户名为admin，可保持，密码建议自行设定，而不是使用系统随机生成的。
正常情况下，脚本会启动transmission容器并成功加载运行。
这时就可以使用http://ip:9091打开transmission web，在其中点击左上角的图标，即可添加p2p种子文件，可以手动指定下载保存目录，点击『Add』就可以开启pt下载了。
默认保存目录配置为外置硬盘挂载点 使用以下命令查看目录映射关系，在上面的图示中可以看到剩余空间为11.88GB，这是老E的m401a盒子根文件系统下剩余的全部存储空间。因此，嵌入式设备上务必在使用前进行编辑修改，否则默认的保存目录会导致设备空间迅速耗尽。
docker inspect transmission | grep Mounts -A 30 armbian-software脚本默认配置的映射关系如下，“亮点”是"/opt/downloads"，完全没有考虑 TVBox 的设备状况和需求。新手上来就用，一不留神就会“中招”，表现为下载个几分钟盒子空间就100%使用率了。通常情况下，不会有人将外置存储的挂载点设置为/opt/downloads，4K乃至8K内容的转移也非常耗时。
​编辑
我们需要先停止、删除容器，配置好外置硬盘挂载点，使用正确的映射关系重新创建、加载transmission容器。
docker stop transmission docker rm -f transmission docker run -d --name transmission \ -e USER=admin \ -e PASS=pass1234 \ -e TZ=Asia/Shanghai \ -p 9091:9091 \ -p 51413:51413 \ -p 51413:51413/udp \ -v /opt/docker/transmission/config:/config \ -v /media/sda1/downloads:/downloads \ -v /opt/docker/transmission/watch/folder:/watch \ --restart unless-stopped linuxserver/transmission:arm64v8-latest 上述命令中的/mnt/sda1是我们创建的外置硬盘挂载点，参见上期博文「Armbian下挂载多硬盘」。重新创建、运行transmission容器后，再打开web页可以看到默认的下载保存目录剩余空间的变化，新手很难理解变化背后的原因，甚至也不会去修改保存目录。
​编辑
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ca42bb13fdfb44e649cdb2ccfc5f106/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/749431d953826bdea97d37711cfc26b3/" rel="bookmark">
			最详细的Keycloak教程（建议收藏）：Keycloak实现手机号、验证码登陆——（三）基于springboot&amp;keycloak&#43;vue的前后端分离项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前面两节分别介绍了 Keycloak的下载与使用和keycloak与springboot的集成。
接下来第三节让我们一步步的去完成一个简单的前后端分离项目，并且可以扩展实现sso。
一、简介 本文将介绍如何使用Spring Boot、Keycloak和Vue构建一个具有前后端分离架构的Web应用程序。通过将前端与后端完全独立开发和部署，我们可以实现更高效的团队协作和灵活的技术选型。Spring Boot提供了一个稳定可靠的后台框架，Keycloak提供了身份验证和授权的解决方案，而Vue作为一种灵活易用的前端框架，使我们能够快速开发出优秀的用户界面。
二、keycloak配置 首先回顾一下上一节提到的访问类型：
public： 适用于客户端应用，如前端web系统，包括采用vue、react实现的前端项目等。不需要秘钥访问。
confidential： 适用于服务端应用，比如需要浏览器登录以及需要通过密钥获取access token的web系统。需要秘钥访问。
bearer-only： 适用于服务端应用，只允许使用bearer token请接口，项目里的权限是针对接口做校验，请求没有带上token就会返回401。需要秘钥访问。
在这里我们新创一个keycloak客户端，因为我们的项目是前后端分离的，所以此客户端的访问类型为 bearer-only。
三、springboot配置 创建好一个新的springboot项目之后，配置yml文件，下面是我的配置，仅供大家参考。
keycloak: realm: springboot resource: sso-project-backend auth-server-url: http://localhost:8080/ ssl-required: NONE bearer-only: true credentials: secret: nCTbFSEBZDTME14MMf0LBxyzSmmPzbee cors: true #允许跨域 # use-resource-role-mappings: false #鉴权 security-constraints: #需要用户权限的接口 - auth-roles: - user - admin security-collections: - name: user-role - patterns: - /api/v1/* #放行接口 - auth-roles: security-collections: - name: any - patterns: - /api/v1/user/login - /api/v1/user/register - /api/v1/user/register/register-captcha - /api/v1/user/login/captcha - /api/v1/user/retrieve-pwd/captcha - /api/v1/user/getTokenByRefreshToken 里面的相关数据在keycloak客户端的“安装”中，选择json格式，复制粘贴即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/749431d953826bdea97d37711cfc26b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4f2b44e189740e4413bcb238ef037ec/" rel="bookmark">
			Mac 免费模拟器推荐适配m1芯片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是一些在 macOS 上推荐安装的 Android 模拟器：
Bluestacks：Bluestacks 是一款功能强大的 Android 模拟器，支持在 Mac 上运行 Android 应用程序和游戏。它具有良好的兼容性和稳定性。
Nox App Player：Nox App Player 是另一款受欢迎的 Android 模拟器，也适用于 macOS。它提供了完整的 Android 用户界面和丰富的功能，使用户可以在 Mac 上轻松运行 Android 应用。
MEmu：MEmu 是一款专注于游戏体验的 Android 模拟器，它在 Mac 上提供了流畅的游戏运行和良好的性能。它支持键鼠映射、多开等高级功能。
Genymotion：Genymotion 是一款面向开发人员的 Android 模拟器，它提供了广泛的开发工具和选项。它在 Mac 上提供了快速、稳定的模拟器环境，方便进行应用程序测试和调试。
5.mumu pro模拟器 M1芯片推荐
有些mac m1芯片可能没有适配，如果使用m1芯片推荐大家使用mumu pro模拟器，MuMu模拟器Pro率先适配了Apple M 系列芯片，并且除了能够通过模拟器使用安卓应用之外，MuMu还搭配了智能按键适配、模拟器/应用多开、等诸多功能，无论是用来玩游戏还是用于调试开发安卓应用，都非常合适，若有需要可私信我获取永久使用教程
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/474/">«</a>
	<span class="pagination__item pagination__item--current">475/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/476/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>