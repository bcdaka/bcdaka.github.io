<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ab72b111bcec1cde9982b30b37f3005/" rel="bookmark">
			分布式领域计算模型及Spark&amp;Ray实现对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、分布式计算领域概览
二、Spark计算模型分析
三、Ray计算模型分析
3.1 需求分析
3.2 系统设计
3.3 系统实现
四、总结
一、分布式计算领域概览 当前分布式计算模型主要分为以下4种：
Bulk Synchronous Parallel Model（块同步并行模型）
BSP模型在大数据处理场景下应用非常广泛，例如MapReduce、Spark等框架都是采用BSP模型。BSP编程模型的实现较为简单，但也具有相当多的限制。
BSP模型具有以下特点：
BSP模型将计算划分为一个一个的超步(superstep)，有效避免死锁。
它将处理器和路由器分开，强调了计算任务和通信任务的分开，而路由器仅仅完成点到点的消息传递，不提供组合、复制和广播等功能，这样做既掩盖具体的互连网络拓扑，又简化了通信协议；
采用障碍同步的方式以硬件实现的全局同步是在可控的粗粒度级，从而提供了执行紧耦合同步式并行算法的有效方式，而程序员并无过分的负担；
在分析BSP模型的性能时，假定局部操作可以在一个时间步内完成，而在每一个超级步中，一个处理器至多发送或接收h条消息（称为h-relation）。假定s是传输建立时间，所以传送h条消息的时间为gh+s，如果 ，则障碍同步时间L至少应该大于等于gh。很清楚，硬件可以将L设置尽量小（例如使用流水线或大的通信带宽使g尽量小），而软件可以设置L的上限（因为L越大，并行粒度越大）。在实际使用中，g可以定义为每秒处理器所能完成的局部计算数目与每秒路由器所能传输的数据量之比。如果能够合适的平衡计算和通信，则BSP模型在可编程性方面具有主要的优点，而直接在BSP模型上执行算法（不是自动的编译它们），这个优点将随着g的增加而更加明显；
BSP的成本模型：一个超步的计算成本
，其中wi是进程I的局部计算时间，hi是进程I发送或接受的最大通信包数，g是带宽的倒数(时间步/通信包)，L是障碍同步时间。在BSP计算中，如果使用了s个超步，那总的运行时间为：
为PRAM模型所设计的算法，都可以采用在每个BSP处理器上模拟一些PRAM处理器的方法来实现。
但BSP模型的限制在于，它不支持状态，而且在无法天然拆解为多个超步（可以理解为MapReduce）的应用场景下并行计算就会变得非常困难。
Task Parallel Model（任务并行模型）
Task Parallel Model允许以分布式的方式执行任意无副作用的函数，任务之间可以任意地传输数据。
Task Parallel Model比BSP模型更强大，而且与单机顺序程序的表达方式更兼容。它可以通过checkpoint或是lineage来实现容错，但同样也不支持状态。
Communicating Processes Model（通信进程模型）
通信进程模型支持状态，它是task parallel model的通用化，因为每个task 并行程序都可以再一个通信进程上执行，方法是将函数调度到正确的进程上。
通信进程有几种实现方式，包括消息传递实现，例如MPI，或是actor system，例如Erlang/ Akka/ Orleans。这里我们可以重点关注actor system，因为它足够强大，同时编程模型更结构化。
Distributed Shared Memory Model（分布式共享内存模型）
分布式共享内存模型是一个理想的版本，它将整个集群暴露为一个单一的大核机器，可以使用多个执行线程进行编程，这些线程通过共享内存的读写进行通信。
实际上这种理想状态是无法实现的。通过网络访问远程内存的延迟通常比访问本地内存的延迟大得多。此外，这种架构不具有容错性。
二、Spark计算模型分析 Spark其应用程序在集群中以独立的进程组来运行，分为Driver和Executor两个角色。Driver即用户的主程序，Executor会为用户的应用程序处理计算和数据程序，driver程序会在其生命周期中监听并接收来自它的executor连接。
Spark作为典型的BSP模型，它在接收到用户的action算子会执行一个Job的调度，Job的整体调度过程分为以下几个步骤：
DAG图的构建：根据用户的算子/SQL输入进行解析，构建一个RDD DAG
Stage的划分和提交：DAGScheduler根据shuffle划分Stage，Stage的依赖关系也是一个DAG图
Task/TaskSet的创建：在每个Stage中，为每个分区创建一个Task，同一个Stage的Task组成一个TaskSet，交由TaskScheduler
Task的提交和执行：TaskScheduler根据调度算法将Task提交到远端执行
这里我们需要注意的是，前面所说的调度过程全部发生在Driver节点，远端的Executor作为执行器，只负责执行独立的Task，而对整个Job是完全无感知的。
当一个远端的Task执行完毕后，DAG调度是被如何继续触发的呢？
远端的Executor会将执行成功/失败的信息发送给Driver
Driver中的TaskScheduler负责处理Task级别的反馈信息，只有当一个Stage中的所有Task，即一个TaskSet全部成功，才代表着一个Stage成功。若任一Task失败，则会启动容错机制，进行Task重试或是Job失败的触发。
当一个Stage成功后，DAGScheduler会以事件的形式接收到信息，进而根据DAG依赖关系检查所有依赖于这一Stage的下游Stage，一个Stage只有在它所依赖的所有Stage都成功后才能启动执行。
对比前面我们提到的BSP模型，我们可以发现Spark中的Stage即为BSP模型中所提到的"超步"抽象。Spark的调度模式具有以下特点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ab72b111bcec1cde9982b30b37f3005/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bdd2eb9034ca247ef2b67eeb1ce4853/" rel="bookmark">
			【MySQL】第一次作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【MySQL】第一次作业 1、在官网下载安装包2、解压安装包，创建一个dev_soft文件夹，解压到里面。3、创建一个数据库`db_classes`4、创建一行表`db_hero`5、将四大名著中的常见人物插入这个英雄表 写一篇博客，在window系统安装MySQL将本机的MySQL一定要安装成功创建一个数据库db_classes创建一行表db_hero将四大名著中的常见人物插入这个英雄表 1、在官网下载安装包 官网：www.mysql.com 下载地址：https://downloads.mysql.com/archives/community/ 2、解压安装包，创建一个dev_soft文件夹，解压到里面。 进入文件夹里打开文件，进入bin文件，将bin目录配置到此电脑的属性中的环境变量中的path里面。
配置完成后，以管理员的身份运行cmd,
接着创建一个my.ini文件，将下面内容粘贴进去
[mysqld] #skip_grant_tables #设置3306端口 port=3306 #设置mysql的安装目录 basedir=D:\dev_soft\mysql-8.0.20-winx64 文件位置要正确 #设置mysql数据库的数据的存放目录 datadir=D:\dev_soft\mysql-8.0.20-winx64\data date文件位置要正确 #允许最大连接数 max_connections=200 #允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统 max_connect_errors=10 #服务端使用的字符集默认为UTF8 character-set-server=utf8mb4 #创建新表时将使用的默认存储引擎 default-storage-engine=INNODB #默认使用“mysql_native_password”插件认证 default_authentication_plugin=mysql_native_password [client] #password = your_password #设置mysql客户端连接服务端时默认使用的端口 port=3306 default-character-set=utf8mb4 [mysql] #设置mysql客户端默认字符集 default-character-set=utf8mb4 粘贴完后保存，使用初始化命令生成一个初始密码（后面会用），将密码保存下来，后面登陆需要用到。 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost:xxxxxx 给服务创建名称 mysqld --install mysql 启动服务 net start mysql D:\dev_soft\mysql-8.1.0-winx64\bin&gt;net start mysql8 请求的服务已经启动。 请键入 NET HELPMSG 2182 以获得更多的帮助。 使用初始密码登陆 D:\dev_soft\mysql-8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bdd2eb9034ca247ef2b67eeb1ce4853/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91a7b087ea3c6d6273b9412ea89e7d0b/" rel="bookmark">
			【数据结构】二叉树的相关操作以及OJ题目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 二叉树2.二叉树的遍历2.1前序遍历2.2中序遍历2.3后序遍历2.4层序遍历 3.树的节点个数4.树的高度5.叶子节点的个数6.第k层节点的个数7.查找x所在的节点8.树的销毁9.相关题目9.1相同的树9.2单值二叉树9.3对称二叉树9.4二叉树的构建与遍历9.5翻转二叉树9.6另一颗树的子树 10.判断二叉树是否是完全二叉树 1. 二叉树 当一个树不是满二叉树或完全二叉树时，它是不适合使用数组存储的，它应该使用链式结构来存储。
再看二叉树基本操作前，再回顾下二叉树的概念，二叉树是：
空树非空：根节点，根节点的左子树、根节点的右子树组成的。 从概念中可以看出，二叉树定义是递归式的，因此后序基本操作中基本都是按照该概念实现的。
所以可以定义成下面这种：
typedef int TNDataType; typedef struct TreeNode { TNDataType val; struct TreeNode* left; struct TreeNode* right; }TreeNode; 2.二叉树的遍历 所谓二叉树遍历(Traversal)是按照某种特定的规则，依次对二叉树中的节点进行相应的操作，并且每个节点只操作一次。访问结点所做的操作依赖于具体的应用问题。 遍历是二叉树上最重要的运算之一，也是二叉树上进行其它运算的基础。
按照规则，二叉树的遍历有：前序/中序/后序的递归结构遍历：
前序遍历——访问根结点的操作发生在遍历其左右子树之前。 （根左右）中序遍历——访问根结点的操作发生在遍历其左右子树之中（间）。（左根右）后序遍历——访问根结点的操作发生在遍历其左右子树之后。（左右根） 2.1前序遍历 前序遍历：先访问树的根，然后访问左子树（左子树又被分为根、左子树、右子树，直到左子树不能拆分），然后再访问右子树（右子树又被分为根、左子树、右子树，直到右子树不能拆分）
先遍历根（有根一直根），然后左（有左一直左），最后右，拆分了以后就从头来
遍历结果	1 2 3 NULL NULL NULL 4 5 NULL NULL 6 NULL NULL 谁的NULL: 3 3 2 5 5 6 6 void PreOrder(TreeNode* root) { if (root == NULL) { printf("NULL "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91a7b087ea3c6d6273b9412ea89e7d0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6354a01c99fb2e0318472bafe717ad44/" rel="bookmark">
			SpringBoot——Quartz 定时任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优质博文：IT-BLOG-CN
一、Scheduled 定时任务 【1】添加Scheduled相关依赖，它是Spring自带的一个jar包因此引入Spring的依赖：
&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;/dependency&gt; 【2】导入依赖之后，就可以在Maven Dependencies中看到相关的依赖，如下：
【3】编写定时任务类：重点是@Scheduled注解和cron属性；
/** * Scheduled 定时任务 * 定时任务不属于持久层也不属于业务层，所以应该使用 @Component 进行标记 * @author Administrator * */ @Component public class ScheduledDemo { /** * 定时任务方法，如果是定时任务方法，需要添加 scheduled注解 * scheduled:表示当前方法就是一个定时任务方法 * cron属性: 定时任务触发时间的一个字符串表达式 * 触发条件：每2秒触发一次，博客后面重点说 cron 表达式 */ @Scheduled(cron="0/2 * * * * ?") public void scheduledMethod() { System.out.println("定时任务"+new Date()); } } 【4】在启动类中开启定时任务的启动：@EnableScheduling注解
@SpringBootApplication @EnableScheduling public class ScheduledApplication { public static void main(String[] args) { SpringApplication.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6354a01c99fb2e0318472bafe717ad44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa9a4fb1ccbaa18b99d6239573867257/" rel="bookmark">
			springboot&#43;vue项目接入文心一言API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文心一言ERNIE-Bot 4.0模型流式和非流式API调用(SpringBoot+OkHttp3+SSE+WebSocket) - autunomy - 博客园 (cnblogs.com)
后端
引入依赖 &lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;4.9.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.79&lt;/version&gt; &lt;/dependency&gt; 配置okHttp,创建OkHttpConfiguration.java import okhttp3.ConnectionPool; import okhttp3.OkHttpClient; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import javax.net.ssl.*; import java.security.*; import java.security.cert.CertificateException; import java.security.cert.X509Certificate; import java.util.concurrent.TimeUnit; @Configuration public class OkHttpConfiguration { @Value("${ok.http.connect-timeout}") private Integer connectTimeout; @Value("${ok.http.read-timeout}") private Integer readTimeout; @Value("${ok.http.write-timeout}") private Integer writeTimeout; @Value("${ok.http.max-idle-connections}") private Integer maxIdleConnections; @Value("${ok.http.keep-alive-duration}") private Long keepAliveDuration; @Bean public OkHttpClient okHttpClient() { return new OkHttpClient.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa9a4fb1ccbaa18b99d6239573867257/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/837afc1ac09cd55252ec56817350fed8/" rel="bookmark">
			数据结构之图的基本概念及应用（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言：
图是一种一对多的关系，是一种较线性表和树更加复杂的线性结构。
与线性表和树相比，我们需要注意图的哪些区别呢？
线性表中可以没有数据元素，称为空表；树中可以没有结点，称为空树。但！图中不允许没有顶点，从定义中我们可以得知，顶点集合V是有穷非空的。图中顶点间的逻辑关系用边来表示，边集可以为空。 目录
一、图的术语概念
1、有向图&amp;&amp;无向图
2、简单图
3、无向完全图&amp;&amp;有向完全图
​编辑
4、稀疏图&amp;&amp;稠密图
5、权&amp;&amp;网
6、子图
7、有向连通图&amp;&amp;无向连通图
8、极大连通&amp;&amp;极小连通
9、极大强连通&amp;&amp;极小强连通
二、存储结构
1、邻接矩阵
2、邻接表
3、十字链表
4、邻接多重表
三、图的遍历
1、深度优先遍历（DFS）
2、广度优先遍历（BFS）
四、图的应用
1、最小生成树
（1）Prim算法（选择点）
（2）Kruskal算法（选择边）
2、最短路径
（1）Dijkstra算法
（2）Floyd算法 3、拓扑排序
4、关键路径
五、总结
一、图的术语概念 1、有向图&amp;&amp;无向图 有向图：任意两顶点间的边都是无向边（），如图7-2-2无向图：任意两顶点间的边都是有向边 &lt;&gt; ，如图7-2-3 注意：
&lt;vi,vj&gt;表示从vi到vj的有向边
其中vi称为弧尾，vj称为弧头（切忌惯性思维！）
2、简单图 不存在顶点到自身的边同一条边不重复出现 我们一般讨论的都是简单图的情况，显然以下两种情况不属于我们讨论的范围
3、无向完全图&amp;&amp;有向完全图 无向完全图：无向图中，任意两个顶点都存在边。含有n个顶点的无向完全图有n(n-1)/2条边。 有向完全图：有向图中，任意两个顶点间都存在方向互为相反的两条弧。含有n个顶点的无向完全图有n(n-1)条边。 4、稀疏图&amp;&amp;稠密图 有很少条边或弧的图称为稀疏图，反之为稠密图
5、权&amp;&amp;网 权：图的边或权相关的数网：带权的图 6、子图 如下图所示：
7、有向连通图&amp;&amp;无向连通图 连通：顶点v到顶点v'间有路径连通图：任意两个顶点连通 注意连通图和完全图的区别（间接相连和直接相连）
8、极大连通&amp;&amp;极小连通 均在无向图中讨论极大连通图：加入任一顶点，不再连通。=&gt;对应连通分量 连通分量强调：
1、要是子图
2、子图要是连通的
3、含有极大顶点数
4、具有极大顶点数的连通子图包含依附于这些顶点的所有边
&gt;&gt;&gt;如何判断？
①本身为连通图：只有一个极大连通（对应其本身）
②本身为非连通图：多个极大连通（即连通分量）
极小连通图：删除任一边，不再连通。=&gt;对应生成树 注意：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/837afc1ac09cd55252ec56817350fed8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06648f18be83a27d2a8d52b3748f24bd/" rel="bookmark">
			浅浅探讨一下AIGC技术的发展现状和未来趋势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AIGC（Artificial Intelligence Generated Content）即人工智能生成内容，是利用生成式人工智能来自动创作文本、图像、视频等内容的技术。（文末有福利，站长总结了网上比较流行的AI工具，整理分类后分享的~）
以下是对 AIGC 技术的发展现状和未来趋势的探讨：
一、发展现状 1. 技术创新：AIGC 领域的关键技术如生成算法、预训练模型和多模态技术正在经历快速发展和突破创新。例如，OpenAI 的 Sora 模型可以根据提示词生成长达一分钟的连贯视频，标志着视觉叙事新时代的到来。
2. 产业生态：AIGC 的产业生态可划分为上游基础设施层、中游模型层和下游的应用层。基础设施层包括数据、算力和模型开发训练平台等；模型层包括底层通用大模型、中间层模型和开源社区；应用层则在文本、音频、图像、视频四类模态的基础上，发展出了策略生成和跨模态生成，并在金融、数据分析、设计等多个行业实现了商业应用。
3. 应用广泛：AIGC 技术的应用范围不断扩大，涵盖了文章、视频、音乐等多种内容形式的自动化生成，提高了生产效率，降低了制作成本，并能满足个性化需求。
4. 经济价值与社会影响：AIGC 技术的发展预计将在未来几年内产生数万亿美元的经济价值。同时，它也带来了对数据安全和伦理问题的深思，例如如何确保内容的真实性和合法性，以及如何处理由此产生的社会结构和分配方式的变化。
二、未来趋势 1. 技术积累融合：预计 AIGC 将在基础生成算法模型方面继续取得突破，性能、稳定性和生成内容的质量将不断提升。
2. 应用场景拓展：AIGC 将继续拓展新的应用场景，尤其是在个性化内容创作、互动娱乐、在线教育等领域有着广阔的应用前景。
3. 产业链完善：随着技术的成熟和市场需求的增长，AIGC 相关的产业链将进一步完善，包括硬件设施、平台服务、内容分发等环节。
4. 治理挑战：AIGC 的发展也将面临治理挑战，包括版权保护、内容真实性验证、伦理道德等问题，需要行业共同努力解决。
5. 个性化与定制化：随着消费者对于内容个性化和定制化需求的增加，AIGC 将更加注重提供个性化的内容生成服务。
6. 跨领域融合：AIGC 技术与其他领域如虚拟现实（VR）、增强现实（AR）以及元宇宙等新兴技术的融合，将为内容创作带来新的维度和体验。
7. 发展潜力巨大：AIGC 技术正处于一个快速上升期，未来的发展潜力巨大，但同时也伴随着一系列挑战和问题。随着技术的不断进步和应用领域的不断拓展，AIGC 有望在未来几年内成为推动经济高质量发展的重要引擎。
三、具体案例 1. ChatGPT：ChatGPT 是 OpenAI 研发的聊天机器人程序，于 2022 年 11 月推出。它能够通过学习和理解人类的语言来进行对话，并协助人类完成一系列任务，包括撰写邮件、论文、脚本，制定商业提案，甚至敲代码、检查程序错误等。
2. DALL·E2：DALL·E2 是 OpenAI 于 2023 年发布的一款人工智能绘画工具。它可以根据输入的文本描述生成逼真的图像，其效果令人惊叹。
3. StableDiffusion：StableDiffusion 是一款强大的 AI 绘画工具，能够生成各种风格的图像，包括写实、抽象、卡通等。用户可以通过输入关键词或提示来指导图像的生成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06648f18be83a27d2a8d52b3748f24bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9d7e97de897e9c8e620e4637ef83796/" rel="bookmark">
			链表经典算法OJ题目（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.寻找链表的中间节点 题目链接：876. 链表的中间结点 - 力扣（LeetCode）
我们来直接介绍一个思路：快慢指针
快慢指针是指我们创建创建2个指针，一个为快指针，一个为慢指针，且快指针一次走的步数是慢指针的两倍。两个指针同时往后走，当快指针为空或者快指针-&gt;next为空时，此时，慢指针的位置恰好是中间节点。
1.1 节点的个数为奇数 上图为了方便理解，画了两条链表。其实两个指针是在一条链表里面实现的。
节点个数为奇数时，当fast指针走到节点末尾时，slow指针指针的位置恰好是节点的中间位置。
1.2 节点的个数为偶数 当节点的个数为偶数时，当fast指针最后为空指针时，slow指针的位置恰好是节点的中间节点。
代码实现
typedef struct ListNode ListNode; struct ListNode* middleNode(struct ListNode* head) { ListNode*slow=head; ListNode*fast=head; while(fast&amp;&amp;fast-&gt;next) { slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; } return slow; } 注意事项：循环条件不能写成while(fast-&gt;next&amp;&amp;fast)，因为当链表的节点个数为偶数个时，fast指针最终会为空指针，则fast-&gt;next就会报错，如果按照我上面那样写，当fast为空时，循环条件的表达式就会短路，不会执行后面的fast-&gt;next。
2.合并两个有序链表 做题链接：21. 合并两个有序链表 - 力扣（LeetCode）​​​​​
暴力解题思路：直接创建一个新链表，两个链表之间各个节点的数据依次进行比较，数据小的插入新链表。
如上面的过程图所示，数据小对应的节点被拿出来插入新的节点，接着让对应的节点向后走到下一个节点，直到有一条链表走完。
代码实现
typedef struct ListNode ListNode; struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) { if(list1==NULL) { return list2; } if(list2==NULL) { return list1; } //创建新链表 ListNode*newhead,*newtail; newhead=newtail=NULL; //遍历原链表 ListNode*l1=list1; ListNode*l2=list2; while(l1&amp;&amp;l2) { if(l1-&gt;val&lt;l2-&gt;val) { if(newhead==NULL) { newhead=newtail=l1; } else { newtail-&gt;next=l1; newtail=l1; } l1=l1-&gt;next; } else { if(newhead==NULL) { newhead=newtail=l2; } else { newtail-&gt;next=l2; newtail=l2; } l2=l2-&gt;next; } } if(l1) { newtail-&gt;next=l1; } if(l2) { newtail-&gt;next=l2; } return newhead; } 当写完代码我们发现，如上图，有两段一样的代码，这就造成了代码的拥挤，造成有这两段带码的原因：因为新建的头节点和尾节点存在空指针的情况，需要就行判空。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9d7e97de897e9c8e620e4637ef83796/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40ef29c9e970af1eac1fca047203debe/" rel="bookmark">
			2024年 Java 面试八股文——SpringCloud篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.Spring Cloud Alibaba 中的 Nacos 是如何进行服务注册和发现的？
2.Spring Cloud Alibaba Sentinel 的流量控制规则有哪些？
3.Spring Cloud Alibaba 中如何实现分布式配置管理？
4.Spring Cloud Alibaba RocketMQ 的主要特点有哪些？
5.Spring Cloud Alibaba Seata 是如何处理分布式事务的？
6.Spring Cloud Alibaba 环境中实现服务限流？
7.Spring Cloud Alibaba 中 Sentinel 和 Hystrix 在服务熔断方面的区别是什么？
8.Spring Cloud Alibaba 环境中，如何处理微服务间的异步通信？
9.Spring Cloud Alibaba 中 Dubbo 和 Spring Cloud 在微服务架构中的适用场景有何不同？
10.使用 Spring Cloud Alibaba 时，如何保证数据的一致性？
11.如何使用 Spring Cloud Alibaba 实现服务的灰度发布？
12.Spring Cloud Alibaba 提供哪些安全性相关的特性？
13.Spring Cloud Alibaba 如何实现服务降级？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40ef29c9e970af1eac1fca047203debe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f695d34bcbe11c314475c236b2c64a83/" rel="bookmark">
			android应用开发系列-如何在新版本的Android Studio中创建java项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新版本的Android Studio中创建java项目有两种方式可以实现，第一种：
1、选择新建一个空的project
2、创建一个mainActive
3、在res/layout/的目录中找到布局文件activity_main.xml 中编辑布局xml文件修改AndroidManifast.xml 指定 mainActive，指定LAUNCHER
其中android.intent.action.MAIN 与 android.intent.category.LAUNCHER 决定应用程序在luncher中的显示方式；
两者的作用如下：
android.intent.action.MAIN决定应用程序最先启动的Activity
android.intent.category.LAUNCHER决定应用程序是否显示在程序列表里
也可以在创建mainActive的时候指定launcher Activity，这样就不需要再修改对应xml文件了。 第二种比较简单的方式就是在创建project的时候选择 empty views activity
在第二步的配置中可以选择java或者kotlin。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/684d124624b83ac84271bbcc3b133439/" rel="bookmark">
			一文讲清楚，AI、AGI、AIGC与AIGC、NLP、LLM，ChatGPT等概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 随着chatgpt3.5的横空出试，大模型爆火，这个风暴传递到了各行各业。
各类公众号、帖子，也涌现出了各种概念，AI、大模型、LLM、AI、AIGC、AGI、GPT、ChatGPT等等。
总觉得被这些概念搞得头晕。
我花了点时间，梳理了下一些常见的概念，希望从基本上能对大模型（LLM）有个基本的认识。
一图胜千言 我自己查阅了一些资料的针对各个概念的解释之后，整理了以下的一个图，来试图说明这些概念之间的关系（如有不对之处，还请看到的大佬予以指正）：
概念之间的关系 AI、AGI、AIGC AI（人工智能）： 先说说AI，这个大家可能都不陌生。AI，就是人工智能，它涵盖了各种技术和领域，目的是让计算机模仿、延伸甚至超越人类智能。想象一下，你的智能手机、智能家居设备，这些都是AI技术的应用。
AIGC（AI生成内容）： 接下来是AIGC，即AI Generated Content。这就是利用AI技术生成的内容：
markdown 复制代码 1. 文本生成：可以用于自动生成新闻报道、广告文案、产品描述等。 2. 图像生成：可以用于自动生成图像素材、艺术创作、设计等。 3. 音频生成：可以用于自动生成音乐、电台广播等。 4. 视频生成：可以用于自动生成视频剪辑、电影预告片等。 又称生成式AI，被认为是继专业生产内容（PGC）、用户生产内容（UGC）之后的新型内容创作方式。
互联网内容生产方式经历了PGC——UGC——AIGC的过程。
AGI（通用人工智能）： 然后我们来看AGI，即Artificial General Intelligence，中文叫通用人工智能。这可比一般的AI高级多了。AGI的目标是创造一个能像人类一样思考、学习、执行多种任务的系统。想象一下，如果有了AGI，它可能会成为全能的“超级大脑”，能在任何领域都超越人类。听起来是不是有点像科幻电影里的情节？
AGI与AIGC（Artificial Intelligence Generated Content，人工智能生成内容）有显著区别。AIGC指的是利用AI技术，尤其是机器学习和深度学习模型，自动生成内容，如文本、图像、音乐或视频。AIGC通常专注于特定的创作任务，而不具备AGI的广泛智能和通用学习能力。
在谈论AGI时，人工智能 和 机器学习领域国际上最权威的学者之一DeepLearning.AI创始人吴恩达认为，尽管AGI是一个激动人心的概念，但我们目前对实现真正的AGI还有很长的路要走。他强调，现有的AI技术，尽管在特定任务上表现出色，但仍然缺乏通用性和灵活性。
AIGC、NLP、LLM 从上面可以看出，现在被我们广泛谈起的AI，主要是指的AIGC领域。
AIGC涉及到的领域和技术很广泛，其中很重要的一项技术就是NLP(自然语言处理)，之所以把这3个概念放在一起描述，这两年来，AIGC取得了令人瞩目的增长，有很大因素就在于自然语言处理（NLP），而推动NLP发展到的就是LLM（大型语言模型），也就是我们接下来学习的重点，LLM。
用相对官方的描述，就是说：
NLP(自然语言处理)它是研究如何让计算机读懂人类语言，也就是将人的自然语言转换为计算机可以阅读的指令，NLP是人工智能和语言学领域的分支学科。
而LLM是 NLP 中的一个重要组成部分，主要是用来预测自然语言文本中下一个词或字符的概率分布情况，可以看作是一种对语言规律的学习和抽象。
在NLP中，LLM是一种基本技术，用于处理和理解文本，包括词法分析、句法分析、语义分析等，广泛应用于机器翻译、自动问答系统、信息抽取、文本分类、情感分析等多个领域。而LLM，特别是基于Transformer架构的模型，如GPT-3和T5，通过大规模无监督学习来学习语言规律和上下文信息，然后在微调阶段根据具体任务进行有监督学习和优化，从而能够生成连贯、有意义的文本。这些模型的核心在于预训练和微调，预训练阶段使用掩码语言模型或下一句预测等技术，微调阶段则针对特定任务进行优化。
NLP、GPT、ChatGPT GPT是NLP领域中的一个重要模型，它是基于Transformer架构构建的预训练语言模型。GPT（Generative Pre-trained Transformer）通过预先训练大量文本数据，学习到语言的基本结构和模式，从而能够理解自然语言文本的意义和语义。
而ChatGPT从名字上就可以看出来，ChatGPT是GPT在对话生成领域的特定应用。
大模型的发展历程 如何学习大模型 AI ？ 由于新岗位的生产效率，要优于被取代岗位的生产效率，所以实际上整个社会的生产效率是提升的。
但是具体到个人，只能说是：
“最先掌握AI的人，将会比较晚掌握AI的人有竞争优势”。
这句话，放在计算机、互联网、移动互联网的开局时期，都是一样的道理。
我在一线互联网企业工作十余年里，指导过不少同行后辈。帮助很多人得到了学习和成长。
我意识到有很多经验和知识值得分享给大家，也可以通过我们的能力和经验解答大家在人工智能学习中的很多困惑，所以在工作繁忙的情况下还是坚持各种整理和分享。但苦于知识传播途径有限，很多互联网行业朋友无法获得正确的资料得到学习提升，故此将并将重要的AI大模型资料包括AI大模型入门学习思维导图、精品AI大模型学习书籍手册、视频教程、实战学习等录播视频免费分享出来。
😝有需要的小伙伴，可以点击下方链接免费领取或者V扫描下方二维码免费领取🆓
第一阶段（10天）：初阶应用 该阶段让大家对大模型 AI有一个最前沿的认识，对大模型 AI 的理解超过 95% 的人，可以在相关讨论时发表高级、不跟风、又接地气的见解，别人只会和 AI 聊天，而你能调教 AI，并能用代码将大模型和业务衔接。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/684d124624b83ac84271bbcc3b133439/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8c2761b73b3a6cb5c8f4734ab285e4d/" rel="bookmark">
			大模型提示工程（Prompt）（上篇），掌握Prompt原理与技巧，提高AI生成内容质量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们了解到，现在的大模型，基本都是基于transformer的GPT模型，以ChatGPT为例，之前我们提到了，它是一种基于GPT模型的对话生成模型，它可以让计算机自动学习对话语料库中的模式，并生成连贯、自然的对话回复。
对于我们普通用户来说，使用ChatGPT也好，还是文心一言、通义千问，等等这些大模型，就是通过一轮一轮的对话来实现我们的诉求。
像这样：
前言 关于ChatGPT等的账号如何注册，这里不再说描述，网上教程一搜一大把。
好多人有这样一种感觉，拿到ChatGPT的账号，一顿尝试操作，当你过了新鲜的阶段，发现不好用，ChatGPT 回答的好空，没有太多参考价值；或者说，发现自己好像并没有什么好问的，不知道可以用 GPT 怎么来使用，于是过了这阵风，可能好久也想不起来再登录一次了。
然而实际情况是，不管是相关技术从业者还是其他行业的从业者，越来越多的人正把它变为自己的生产力工具。
ChatGPT（以下我们就以ChatGPT为例来介绍），基于GPT模型的对话生成模型都一样，可能跟各自的训练情况，在回答上有差异，但是逻辑都是一样的。由于目前人类的技术对自然语言（人说的话）处理的技术还不完美，所以导致目前 AI 生成内容的质量，非常依赖于–提示工程（Prompt），来引导语言模型更好地响应。
提示工程（Prompt） 所谓提示词，就是如何让ChatGPT更精准的理解你的意图，输出你想要的答案。找到与ChatGPT对话的技巧。
学会写提示词 先让大家感受下不同的发问方式，ChatGPT的回答效果：
写提示词的一些原则 清晰的指令：足够清晰明确地说明你希望模型为你返回什么，最后更加细致地说明需求，避免模糊表达。提供上下文和例子：给出较为充分的上下文信息，让模型更好地理解相关背景。如果能够提供示例，模型能表现更好（类似传统LLM中的in-context learning）。善用符号和语法：使用清晰的标点符号，标题，标记有助于转达意图，并使输出更加容易被解析让模型一步一步地思考：在这种方法中，模型逐步进行思考，并呈现出涉及的步骤，这样做可以降低结果的不准确的可能性，并对模型响应的可解释性有很大的帮助。激励模型反思和给出思路：可以在prompt中用一些措辞激励模型给出理由，这样有助于我们更好地分析模型生成结果，同时，思维过程的生成，也有助于其生成更高质量的结果。给容错空间：如模型无法完成指定的任务，给模型提供一个备用路径，比如针对文本提问，可以加入如果答案不存在，则回复“无答案”让模型给出信息来源：在模型结合搜索或者外部知识库时，要求模型提供他的答案的信息来源，可以帮助LLM的答案减少捏造，并获取到最新的信息。 善于总结自己的提示词模板 一个Prompt 可能包含的6个要素：任务，上下文，示例，角色，格式和语气，而且这些要素是按重要性降序排列的。
【角色】-- 选填 角色明确指定ChatGPT和Bard（如果涉及到虚构的角色）所扮演的角色或身份。这可以是具体的人，也可以是虚构的角色，有助于调整语气和内容以适应特定角色的需求。
【任务】-- 必填 明确表达你希望ChatGPT完成的任务或目标。
这里可以具体拆分：
1.你的问题或者任务描述
2.你的目标
3.你的要求
【上下文】–选填 上下文提供了与任务相关的背景信息，以确保模型可以理解问题的背景和约束条件。这包括用户的背景信息、成功标准、所处环境等。上下文对于任务的明确性和有效性至关重要。
【示例】–选填 提供示例可以明确示范所需的内容和格式，从而提高输出质量。
【输出格式】–选填 格式部分可视化了你期望输出的外观和结构，如表格、列表、段落等。明确指定输出的格式可以确保ChatGPT生成的内容符合你的预期。
【语气】–选填 语气定义了输出文本的语气或风格，如正式、非正式、幽默等。指定语气有助于确保ChatGPT的回应符合所需的情感和风格要求。
我们再来根据模板进行提问，看下效果：
带示例与不带示例的区别：
以上，我们如果能够用好提示词模板，符合提示词的一些原则，在一些基本的场景中，我们能够准确的获得我们想要的答案。
基于ChatGPT可以多轮对话，我们可以通过追问、奖惩指令来，来进一步提升模型的推理能力。
找到自己使用的场景 1.可以利用ChatGPT成为你的知识助手和百科全书。
2.让ChatGPT成为你的工作助理：
帮你写文章，优化文章，帮你做数据分析，帮你做各类场景的指导，比如健身教练，比如营养师。
3.你可以逐渐沉淀你各类场景的prompt，来形成你自己的多维度工具库
如何更深层次的激发大模型的涌现能力（学习一点点原理） 激发大型语言模型的涌现能力有两种方法：提示工程（prompt engineering）和微调（fine-tuning） 。
了解以下这些原理，对于理解和应用LLM模型来说，这些知识都具有重要的参考价值。
作为非技术人员的日常应用，我们要关注的是：
经典小样本提示(Few-shot) 最简单的提示工程的方法就是通过输入一些类似问题和问题答案，让模型参考学习，并在同一个prompt的末尾提出新的问题，以此来提升模型的推理能力。这种方法也被称为One-shot或者Few-shot提示方法。
zero-shot zero-shot可以理解为：不给大模型任何的提示，直接提问，让大模型自己做决策。
当大模型遇到它未知的知识时，使用Zero-shot提示是无法得到比较好的回复，但并不意味着它不具备学习的能力，“照猫画虎” 它还是非常优秀的，所以进阶的提示法叫做Few-shot。
Few-shot提示法 Few-shot提示法可以简单理解为：在提问之前，先给大模型一个示例和解释让它学习和模仿，从而在一定程度上赋予它泛化能力。就像上述，我们提炼招标方的例子。
这里，从一个大佬从论文中总结的结论，我觉得我们也需要知道一点：
在zero-shot、one-shot、few-shot 上，规模越大，效果越好few-shot只要参数够不比fine-tuned差 从这些理论上，再回顾上述我们的提示词原则和实验，就能感受到，这些理论都有实际在指导我们如何写更好的prompt
CoT+Few-shot 提示 STaR Fine-Tune提示法 代码提示工程（Code Prompting) 代码提示工程是指通过设计特殊的代码提示来激发模型的涌现能力。这种方法不需要对模型进行额外的训练，只需要通过设计合适的代码提示来引导模型完成特定任务，代码提示工程通常用于解决那些无法通过语言提示工程解决的问题。这个不在这里描述，也是后续需要学习的一个重点专题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8c2761b73b3a6cb5c8f4734ab285e4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2af1a80a1ce6ace19d1b53cca4a443f4/" rel="bookmark">
			一对一WebRTC视频通话系列（四）——offer、answer、candidate信令实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇博客主要讲解offer、answer、candidate信令实现，涵盖了媒体协商和网络协商相关实现。
本系列博客主要记录一对一WebRTC视频通话实现过程中的一些重点，代码全部进行了注释，便于理解WebRTC整体实现。
一对一WebRTC视频通话系列往期博客
一对一WebRTC视频通话系列（一）—— 创建页面并显示摄像头画面
一对一WebRTC视频通话系列（二）——websocket和join信令实现
一对一WebRTC视频通话系列（三）——leave和peer-leave信令实现
offer、answer、candidate信令实现 整体实现思路1. 客户端2. 服务端 整体实现思路 整体实现思路(红色部分为客户端，蓝色为服务端)：
（1）收到new­peer （handleRemoteNewPeer处理），作为发起者创建RTCPeerConnection，绑定事件响应函数，加入本地流；
（2）创建offer sdp，设置本地sdp，并将offer sdp发送到服务器；
（3）服务器收到offer sdp 转发给指定的remoteClient；
（4）接收者收到offer，也创建RTCPeerConnection，绑定事件响应函数，加入本地流；
（5）接收者设置远程sdp，并创建answer sdp，然后设置本地sdp并将answer sdp发送到服务器；
（6）服务器收到answer sdp 转发给指定的remoteClient；
（7）发起者收到answer sdp，则设置远程sdp；
（8）发起者和接收者都收到ontrack回调事件，获取到对方码流的对象句柄；
（9）发起者和接收者都开始请求打洞，通过onIceCandidate获取到打洞信息（candidate）并发送给对方
（10）如果P2P能成功则进行P2P通话，如果P2P不成功则进行中继转发通话。
1. 客户端 （1）创建RTCPeerConnection，绑定事件响应函数，加入本地流
handleRemoteNewPeer-&gt;doOffer-&gt;ceratePeerConnection()
function doOffer() { //创建RTCPeerConnection对象 if(pc == null) ceratePeerConnection(); pc.createOffer().then(createOfferAndSendMessage).catch(handleCreateOfferError); } function ceratePeerConnection() { //创建RTCPeerConnection对象 pc = new RTCPeerConnection(null); pc.onicecandidate = handleIceCandidate; pc.ontrack = handleRemoteStreamAdd; localStream.getTracks().forEach(track =&gt; { pc.addTrack(track, localStream); }); } （2）创建offer sdp，设置本地sdp，并将offer sdp发送到服务器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2af1a80a1ce6ace19d1b53cca4a443f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00fea2c9dc729f6e7da58b64774b087f/" rel="bookmark">
			【Linux】进程间通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👀樊梓慕：个人主页
🎥个人专栏：《C语言》《数据结构》《蓝桥杯试题》《LeetCode刷题笔记》《实训项目》《C++》《Linux》《算法》
🌝每一个不曾起舞的日子，都是对生命的辜负
目录
前言
1.进程间通信
1.1进程间通信的目的
1.2进程间通信的方式
1.2.1一般规律
1.2.2具体做法
2.管道
2.1命令行上的管道
2.2匿名管道 2.2.1匿名管道的原理
2.2.2系统调用pipe()
2.2.3管道通信的4种特殊情况
2.2.4管道通信的4种特性 2.2.5管道的大小
2.2.6进程池
源码
子进程拷贝父进程导致管道有多个写端的问题解决
2.3命名管道
2.3.1使用命令创建命名管道
2.3.2使用程序创建命名管道
2.3.3用命名管道实现server&amp;client通信 3.system V进程间通信
3.1system V共享内存
3.1.1原理
3.1.2共享内存的建立与释放
3.1.3系统调用函数
创建共享内存——shmget函数
挂接共享内存——shmat函数
拆卸共享内存——shmdt函数
释放共享内存——shmctl函数
3.1.4命令行操作共享内存
查看共享内存信息——ipcs命令
释放共享内存——ipcrm -m shmid命令
3.1.5用共享内存实现server&amp;client通信
源码
管道提供进程间协同机制的讲解
3.1.6system V共享内存通信方式与管道通信的对比
3.2system V消息队列
3.3system V信号量
前言 由于进程间具有独立性，他们之间是不能直接访问获取甚至修改对方的数据的，但是在实际需求中，我们需要进程之间进行交互，所以必须开发某种方式使进程间可以建立联系。
在最开始，进程间通信最原始的方式就是利用管道，当然随之也有诸多不同的进程间通信的标准，接下来就让我们一起来学习下吧！
欢迎大家📂收藏📂以便未来做题时可以快速找到思路，巧妙的方法可以事半功倍。 =========================================================================
GITEE相关代码：🌟樊飞 (fanfei_c) - Gitee.com🌟
=========================================================================
1.进程间通信 1.1进程间通信的目的 数据传输：一个进程需要将它的数据发送给另一个进程。资源共享：多个进程之间共享同样的资源。通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。 总结：我们往往需要多个进程协同完成一些事情。
1.2进程间通信的方式 1.2.1一般规律 进程间通信的本质就是让不同的进程看到同一份资源，我们需要一块空间作为交换数据的『 空间』，但是为了保证进程间的独立性，这块『 空间』不能由通信双方任何一个提供，所以我们就需要一个第三方来提供，这个第三方一般就是操作系统。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00fea2c9dc729f6e7da58b64774b087f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/827fa90b59aacf479fa8095dcb94c85a/" rel="bookmark">
			7个VS Code大模型AI插件，编程如虎添翼
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，在编程领域，效率和速度是项目成功的核心要素。对于开发者来说，拥有合适的工具可以在复杂的编程任务中游刃有余。
VS Code 插件正是这样一种强大的辅助，能够帮助提升工作效率，让开发者在面对编程挑战时更加从容不迫。本文将介绍7个实现快速编码的 VS Code AI 插件。
1 GitHub Copilot 安装链接：https://marketplace.visualstudio.com/items?itemName=GitHub.copilot
GitHub Copilot是一款尖端的AI编程助手，能够优化和提升编程体验。当编写代码时，它能够实时提供智能的代码补全建议，使代码编写更加简单快捷。
GitHub Copilot提供的建议源于OpenAI Codex的AI配对编程模型，能够为开发者提供资深专家级的代码建议，有效提升编码的效率和代码质量。
2 Tabnine 安装链接：https://marketplace.visualstudio.com/items?itemName=TabNine.tabnine-vscode
Tabnine作为集成了人工智能的代码助手，致力于协助开发者提升编码的速率和效率。
与GitHub Copilot类似，Tabnine 通过智能补全功能，在用户输入代码的过程中，能即时给出建议和补全选项。
Tabnine的特色在于其丰富的代码推荐、预测以及提示工具，这些功能共同作用，帮助开发者节约宝贵的时间，同时提高编码速度。
3 Codeium 安装链接：https://marketplace.visualstudio.com/items?itemName=Codeium.codeium
Codeium 是款免费的代码加速工具包，搭载了先进的AI技术，为用户提供超过20种编程语言的智能代码补全服务。此工具不仅响应迅速，如同闪电般迅捷，还能提供高质量的代码建议。
Codeium 提供无限制的单行及多行代码补全，支持如 Javascript、Python 等流行的编程语言。
此外，Codeium 通过设立 Discord 频道，建立了一个活跃的社区环境，让开发者们能够相互交流并获取更多帮助与支持。
4 Captain Stack 安装链接：https://marketplace.visualstudio.com/items?itemName=captainstack.captain-stack
Captain Stack是集成到VSCode中的代码建议插件，能直接将StackOverflow和Github Gist的丰富资源引入到编程环境中。
区别于其他依赖人工智能的代码辅助工具，Captain Stack通过将查询直接发送给搜索引擎，精准地从StackOverflow和Github Gist中提取解答，并把这些信息智能地补全到你的代码中。
使用Captain Stack，既能享受到StackOverflow提供的详尽准确信息，又可以体验到VSCode自动完成带来的便捷，两者结合，让开发者的编程体验达到最佳状态。
5 IntelliCode 安装链接：https://marketplace.visualstudio.com/items?itemName=VisualStudioExptTeam.vscodeintellicode
IntelliCode是微软为Visual Studio用户推出的一款前沿AI编码助手。
该工具独具匠心的团队协作补全功能，为那些以微软技术栈为核心的组织和远程开发团队提供了量身定制的解决方案，尤其适合那些对Visual Studio有深入了解的用户。
IntelliCode在精选的GitHub项目上进行训练，能够增强用户的编码体验，有效提升工作效率。
6 CodeWhisperer 安装链接：https://marketplace.visualstudio.com/items?itemName=AmazonWebServices.aws-toolkit-vscode
CodeWhisperer是由亚马逊开发的AI编码助手，其训练数据源自开源代码库、亚马逊内部代码库、API文档及各类技术论坛，涵盖了数十亿行代码。
目前，CodeWhisper的预览版本兼容所有支持AWS IDE工具的集成开发环境。
用户只需完成注册，即可准备体验CodeWhisperer带来的全新编码效率。
7 YouCompleteMe 安装链接：https://marketplace.visualstudio.com/items?itemName=RichardHe.you-complete-me
YouCompleteMe（简称YCM）是专为Vim编辑器用户打造的高效自动补全解决方案，完全免费。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/827fa90b59aacf479fa8095dcb94c85a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2944cf74c84367968ef85cd78dd7a43/" rel="bookmark">
			LLM2Vec介绍和将Llama 3转换为嵌入模型代码示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嵌入模型是大型语言模型检索增强生成(RAG)的关键组成部分。它们对知识库和用户编写的查询进行编码。
使用与LLM相同领域的训练或微调的嵌入模型可以显著改进RAG系统。然而，寻找或训练这样的嵌入模型往往是一项困难的任务，因为领域内的数据通常是稀缺的。
但是这篇论文LLM2Vec，可以将任何的LLM转换为文本嵌入模型，这样我们就可以直接使用现有的大语言模型的信息进行RAG了。
嵌入模型和生成模型 嵌入模型主要用于将文本数据转换为数值形式的向量表示，这些向量能够捕捉单词、短语或整个文档的语义信息。这些向量表示也被称为嵌入（embeddings），可以用于各种下游任务，如文本分类、搜索、相似度计算等。
最有名的嵌入模型就是BERT是一个典型的encoder-only模型
生成模型则设计用来基于训练数据生成新的数据实例。在NLP中，这通常意味着生成文本。这类模型能够学习到数据的分布，并能创造出符合这一分布的新实例，如新的句子或文档。
如GPT系列，通常是decoder-only模型。
这两种架构在设计和应用上有所不同：
BERT (Encoder-only)：BERT利用双向Transformer编码器，这意味着它在处理文本时可以同时考虑前面和后面的上下文。这种双向上下文理解使得BERT非常适合用于各种理解任务，如问答、自然语言推理和实体识别等。LLM (Decoder-only)：如GPT系列模型，通常采用单向Transformer解码器。这意味着在生成文本时，每个新词只能基于前面的词生成。这种结构适合于文本生成任务，如文本续写、自动编写程序代码等。 在论文中对encoder-only和decoder-only模型的特点进行了讨论，特别是在解释为什么将decoder-only的大型语言模型（LLM）转换为有效的文本编码器时。论文指出了几个关键点：
Decoder-only模型的局限性：这些模型，如GPT系列，使用因果（单向）注意力机制。这意味着在生成文本时，每个标记只能看到它之前的标记。这种结构虽然适合文本生成，但在需要丰富的上下文信息（如文本嵌入任务）时可能不够理想。克服Decoder-only模型的限制：论文中提出的LLM2Vec方法特别通过几个步骤来克服这些限制，包括启用双向注意力，这使得模型能够在处理文本时同时考虑前后文本，从而生成更丰富的上下文表示。与Encoder-only模型的对比：论文比较了使用LLM2Vec转换的decoder-only模型与传统的encoder-only模型（如BERT）。结果显示，通过适当的转换和训练，原本设计为decoder-only的模型在多个文本嵌入任务上能够达到甚至超过传统encoder-only模型的性能。 这表明，尽管decoder-only和encoder-only模型在设计和功能上有本质的不同，但通过创新的方法可以扩展或改变这些模型的能力，使它们适应更广泛的应用场景。
其实我们可以将这篇论文的重点简单的理解为，如何将一个decoder-only的模型快速并且无损的转换成一个encoder-only模型。
LLM2Vec 在论文中提出了一种名为LLM2Vec的方法，用于将仅解码器的大型语言模型（LLM）转换为强大的文本编码器。这种方法包括三个简单的步骤：1）启用双向注意力；2）蒙版下一个标记预测；3）无监督对比学习。这种转换不需要标记数据，且在数据和参数上都非常高效。
具体来说，研究中首先解决了LLM在文本嵌入任务中由于其因果关注机制而受限的问题，该机制仅允许标记与其前面的标记交互。通过启用双向注意力，每个标记能够访问序列中的所有其他标记，从而转换为双向LLM。然后，通过蒙版下一个标记预测（MNTP），调整模型以利用其双向注意力。最后，应用无监督对比学习以改进序列表示。
这些步骤的组合不仅在单词级任务上提升了模型的性能，还在大规模文本嵌入基准（MTEB）上达到了新的无监督性能水平。此外，当将LLM2Vec与监督对比学习相结合时，还在仅使用公开可用数据的模型中实现了最先进的性能。这表明，通过这种简单且有效的方法，原本仅用于生成任务的解码器模型也能被转化为通用的文本编码器，从而在多种NLP任务中表现出色。
方法详解 论文中描述的LLM2Vec方法在代码层面主要涉及以下几个关键的修改，以将decoder-only模型转换为能够生成丰富文本编码的模型：
启用双向注意力：通常，decoder-only模型使用的是单向（因果）注意力机制，这限制了模型只能看到当前标记之前的信息。为了转换这一点，论文中提到通过替换因果注意力掩码（causal attention mask）为全1矩阵，使得每个标记都能看到序列中的所有其他标记，从而实现双向注意力。蒙版下一个标记预测（MNTP）：这是一个训练目标，结合了下一个标记预测和蒙版语言模型的元素。具体来说，首先在输入序列中随机蒙版一些标记，然后训练模型预测这些蒙版的标记，同时考虑前后文。这种训练方式帮助模型适应其新的双向注意力能力。无监督对比学习：使用SimCSE（Simple Contrastive Learning of Sentence Embeddings）方法，这种方法通过对同一句子生成两个不同的嵌入表示，并训练模型最大化这两个表示之间的相似度，同时最小化与批次中其他不相关句子表示的相似度。这一步骤不需要配对数据，可以使用任何文本集合。 这些代码修改主要集中在模型的预训练和微调阶段，旨在不仅使模型能够处理更丰富的上下文信息，还提高了模型在不同NLP任务中的通用性和有效性，也就是说我们最终还是需要进行微调训练的，所以下面我们就要展示一些代码来看看如何进行这部分的微调训练。
利用LLM2Vec将Llama 3转化为文本嵌入模型 首先我们安装依赖
pip install llm2vec pip install flash-attn --no-build-isolation 我们这里演示使用单卡的4090，对于现有模型，我们直接加载现有的模型：
import torch from llm2vec import LLM2Vec l2v = LLM2Vec.from_pretrained( "meta-llama/Meta-Llama-3-8B", device_map="cuda" if torch.cuda.is_available() else "cpu", torch_dtype=torch.bfloat16, ) l2v.save("Llama-3-8B-Emb") “torch_dtype=torch.bfloat16”是能够在24 GB GPU上运行转换所必需的配置。如果不设置它，模型将是float32参数的原始大小，内存是不够的。
这时，其实这个模型已经可以使用了。但是如果其插入到RAG中。它的性能是不如标准嵌入模型，因为他的运行方式还是因果推断，而不是我们的嵌入。
所以下一步，就需要用MNTP的目标来训练羊驼他。论文的作者还提供了一个脚本:
experiments/run_mntp.py
它目前支持Llama和Mistral架构的模型，所以我们直接可以拿来使用
git clone https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2944cf74c84367968ef85cd78dd7a43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3dcbe694d1170da93d5864589741430/" rel="bookmark">
			全方位了解 Meta Llama 3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文将为您提供 Llama 3 的全面概览，从其架构、性能到未来的发展方向，让您一文了解这一革命性大语言模型的所有要点。
Meta Llama 发展历程 Llama 1 Llama 是由 Meta(FaceBook) AI 发布的一个开源项目，允许商用，影响力巨大。Llama 1 是 Meta 在 2021 年进入人工智能语言模型世界的第一步。它非常聪明，能够理解和创造语言，这要归功于它拥有的 70 亿参数。但它并不完美，有时在理解复杂的观念时会有困难，或者并不总是知道基本事实。
Llama 2 从 Llama 1 中学到的经验后，Meta 在 2022 年推出了 Llama 2。这个版本更大，拥有 210 亿参数，通过阅读了更多的书籍、维基百科和公共领域的内容而变得更加智能。Llama 2 在弄清事情、理解人们的意思和了解更多事实方面变得更加优秀。Llama 2 支持 4096 上下文，性能卓越，被认为是 GPT 系列最大的竞争对手（之一）。
Llama 2 的核心改进：Llama 2 经过人类对齐微调后，更善于理解人们表达的意思，能够更准确地将言语转化为行动。它在逻辑方面更智能，通过阅读不同来源的信息学到了更多的事实，知道更多的常识。它在检测 AI 在语言任务上表现优秀的测试中表现得出色。
但是即使进行了这些升级，Llama 2 仍有很大的增长空间，尤其是在处理复杂的语言挑战方面距离GPT 3.5 和 GPT 4还有不小的差距，这也引出了 Llama 3 的出现。
Llama 3 4 月 19 日 0 点 0 分，Meta 发布了 Meta Llama 3 系列语言模型（LLM），具体包括一个 8B 模型和一个 70 B 模型。在测试基准中，Llama 3 模型的表现相当出色，在实用性和安全性评估中，与那些市面上流行的闭源模型不相上下。 模型以开源形式提供，包含 8B 和 70B 两种参数规模，涵盖预训练和指令调优的变体。Llama 3 支持多种商业和研究用途，并已在多个行业标准测试中展示了其卓越的性能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3dcbe694d1170da93d5864589741430/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54e386d4d0803579f740b1515f8b8a43/" rel="bookmark">
			Android 14 变更及适配攻略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备工作 首先将我们项目中的 targetSdkVersion和compileSdkVersion 升至 34。
影响Android 14上所有应用 1.最低可安装的目标 API 级别 从 Android 14 开始，targetSdkVersion 低于 23 的应用无法安装。要求应用满足这些最低目标 API 级别要求有助于提高用户的安全性和隐私性。
恶意软件通常会以较旧的 API 级别为目标平台，以绕过在较新版本 Android 中引入的安全和隐私保护机制。例如，有些恶意软件应用使用 targetSdkVersion 22，以避免受到 Android 6.0 Marshmallow（API 级别 23）在 2015 年引入的运行时权限的约束。这项 Android 14 变更使恶意软件更难以规避安全和隐私权方面的改进限制。
注意在升级到 Android 14 的设备上，targetSdkVersion 低于 23 的所有应用都将继续保持安装状态。
2.默认拒绝设定精确的闹钟 精确闹钟适用于用户指定的通知，或是在确切时间需要执行的操作。
SCHEDULE_EXACT_ALARM 是 Android 12 中引入的可让应用安排精确闹钟的权限，不再预先授予以 Android 13 和更高版本为目标平台的最新安装应用（默认情况下，设置为“拒绝”）。如果用户通过备份和恢复操作将应用数据转移到搭载 Android 14 的设备，则该权限仍然会被拒绝。如果现有应用已拥有此权限，则当设备升级到 Android 14 时，系统会预先授予此权限。
需要 SCHEDULE_EXACT_ALARM 权限才能通过以下 API 启动精确闹钟，否则系统会抛出 SecurityException：
setExact()setExactAndAllowWhileIdle()setAlarmClock() 注意：如果使用 OnAlarmListener 对象设置精确闹钟（例如在 setExact API 中），则不需要 SCHEDULE_EXACT_ALARM 权限。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54e386d4d0803579f740b1515f8b8a43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08d767c31d16004fe5382bdbb1d31d5b/" rel="bookmark">
			【数据结构】--- 深入剖析二叉树（上篇）--- 初识树和二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Welcome to 9ilk's Code World (๑•́ ₃ •̀๑) 个人主页: 9ilk (๑•́ ₃ •̀๑) 文章专栏： 数据结构之旅 🏠 初识树 📒 树的概念 树是一种非线性的数据结构，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的集合。把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。
正如现实生活中的树一样，我们的树数据结构也有一个根结点，根节点没有前驱结点树是递归定义的，根节点下有多个分支也就是多个子树，多个子树下又有多个子树对于一颗树可以拆解成根和n颗子树，同样，子树也可以按照相同方式拆分，直到不可拆分 ⚠️ 1.子树不能有交集
2.除了根结点外，每个结点只能有一个父亲
3.一颗N个结点的树有N-1条边
以下的都是子树有交集的，不能叫做树
4.树中不能有环，有环就是图了
为了方便我们深入了解树，我们来普及一些树中的专有名词 ~
📒 树中的专有名词 孩子结点或子结点：某一个结点含有的子树的根结点，如上图中的B,C,D..都是A的子结点双亲结点：若一个节点含有子节点，则这个节点称为其子节点的父节点，，如上图中的A都是B,C,D..的双亲结点兄弟结点：顾名思义，就是有同个双亲结点的子节点，如上图的D,E是兄弟，I,J是兄弟。堂兄弟结点：双亲在同一层的节点互为堂兄弟，如上图的I和K是堂兄弟，注意堂兄弟结点的双亲结点不同结点的祖先：从根到该节点所经分支上的所有节点，如上图A是所有结点祖先，E是IJQP祖先。子孙：以某节点为根的子树中任一节点都称为该节点的子孙.如上图所有结点都是A的子孙，IJQP是E的子孙。结点的度：一个节含有的子树的个数称为该节点的度。叶子结点或终端结点：度为0的结点，也就是没有子树，如上图的P,Q。分支结点或非终端结点：度大于0的结点，如上图的D,H,F...树的度：认为最大的节点的度称为树的度。结点的层次：从根开始定义起，根为第1层（以根为第一层方便区分空树和非空树），根的子节点为第2层，如上图的E层次是2树的高度或深度：树中节点的最大层次，如上图树的深度是4森林：由m（m&gt;0）棵互不相交的树的集合称为森林。（互不相交不仅指没有交集，还有归属关系） 📒 树的表示方法 线性表表示 struct TreeNode { int val; struct TreeNode** subA; int size; int capacity; } 双亲表示法 孩子表示法 这两种较为复杂，博主就不演示了，本人推荐看这位博主文章树的表示
左孩子右兄弟 struct TreeNode { struct TreeNode* leftchild; struct TreeNode* rightbrother; int data; } 🏠 初识二叉树 📒 何为二叉树 一棵二叉树是结点的一个有限集合，该集合:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08d767c31d16004fe5382bdbb1d31d5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ae256c6f0d8979023d001e647c0ba2b/" rel="bookmark">
			文献综述无从下手，这5款AI工具帮你一键搞定，千万别错过！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是娜姐 @迪娜学姐 ，一个SCI医学期刊编辑，探索用AI工具提效论文写作和发表。
五一假期快过完了，你的论文写怎么样了？
最近不少同学诉苦说，文献综述太难了，写Introduction、Discussion太难了。
确实，面对浩瀚如烟的文献，不仅要记住它们的主要结论，还要能组织成有序的语言，引出自己的课题，在Discussion部分就是和自己的研究结果进行对比讨论。
人类的大脑天生适合创意思考，不适合大量记忆。因此，面对庞大的学术论文库，前面看后面忘，会感到力不从心。
之前，娜姐曾写过借助AI工具搞定文献综述的方法：
ChatGPT辅助论文文献综述，再加这个AI工具找论据，绝了！
SCI论文发表:Discussion讨论部分被3个审稿人说没深度没逻辑，用这个AI工具三步拯救了我！
今天，娜姐介绍5款AI工具，帮你轻松搞定文献综述。
这些工具擅长从 PubMed 和 Google Scholar 等数据库中筛选出数百万篇论文，运用 AI 算法和自然语言处理技术（NLP）精准地找到相关研究，并提供关键信息的摘要：
AI 工具
主要功能
Semantic Scholar
- AI 驱动搜索引擎
- 文献的上下文分析
- 高级引文分析
Research Rabbit
- 映射论文间的联系
- 发现关键研究领域
- 探索研究主题
Scite
- 智能引用（包括支持、对立、提到的文献）
- 引用上下文及文本摘要
- 详尽的引用数据和分析
Connected papers
- 可视化研究全景
- 识别关键论文和趋势
- 研究论文间的相互联系
ChatGPT
- 基于提示词的研究辅助
- 自动化的内容总结
- 快速理解复杂议题
Connected Papers：
如其名称所示，该工具专注于展示不同论文之间的联系。该生成式 AI 工具能帮助您直观地了解围绕您的研究主题的全貌，从而更容易地发现：
关键文献；
识别文献综述中的research gap；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ae256c6f0d8979023d001e647c0ba2b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/382/">«</a>
	<span class="pagination__item pagination__item--current">383/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/384/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>