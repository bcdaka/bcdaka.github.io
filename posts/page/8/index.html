<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/498a0a3b6011e5b960254d30d48d6c5d/" rel="bookmark">
			Python程序交易助你发现均线粘合的股票
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		炒股自动化：申请官方API接口，散户也可以
python炒股自动化（0），申请券商API接口
python炒股自动化（1），量化交易接口区别
Python炒股自动化（2）：获取股票实时数据和历史数据
Python炒股自动化（3）：分析取回的实时数据和历史数据
Python炒股自动化（4）：通过接口向交易所发送订单
Python炒股自动化（5）：通过接口查询订单，查询账户资产
什么是均线粘合 均线粘合是指股票价格的短期均线、中期均线和长期均线相互靠近，交织在一起的现象。这种现象在股市中具有重要的意义，它往往暗示着市场的一种平衡状态，也是主力吸筹或酝酿行情的重要信号。
均线粘合的形成原因 均线粘合的形成通常与主力的运作密切相关。主力在低位区间吸筹时，会使得股价在一定范围内波动，从而导致不同周期的均线逐渐靠近并粘合。市场的多空力量在一段时间内达到相对平衡，也会造成均线粘合。
均线粘合与主力吸筹 主力为了获取足够的筹码，会在低位进行长时间的吸筹操作。在这个过程中，股价波动较小，成交量也相对低迷。随着主力吸筹的进行，均线逐渐粘合。当主力完成吸筹后，往往会通过放量拉升来突破均线粘合区域，开启一轮上涨行情。
均线粘合后的股价走势 向上突破 当均线粘合后，股价向上突破，往往伴随着成交量的明显放大，这是强势上涨的信号。此时，投资者应密切关注，及时跟进。
向下突破 反之，如果股价向下突破均线粘合区域，且成交量放大，可能预示着行情的走弱，投资者应及时止损。
如何判断均线粘合后的突破方向 判断均线粘合后的突破方向需要综合考虑多种因素，如成交量、市场热点、公司基本面等。如果成交量持续放大，且公司有良好的基本面和市场热点的支持，向上突破的可能性较大。
均线粘合的周期与涨跌幅度 一般来说，均线粘合涉及的周期越大，未来股价的涨跌幅度可能越大。长期均线的粘合往往意味着更大规模的行情。
均线粘合与孕线结合的操作策略 当均线粘合后出现孕线形态，是一个较为明确的买入信号。投资者可在次日平开附近介入，再次突破孕线高点时加仓。但要注意控制风险，设置好止损位。
选股时对公司领头人的考量 公司的实际控制人对上市公司的发展起着关键作用。一个有能力且有野心的领头人，能够带领公司取得良好的业绩，从而推动股价上涨。
均线粘合在技术分析中的应用 除了观察均线的粘合和突破，还可以结合其他技术指标，如移动平均线的交叉、成交量的变化等，来更准确地判断股票的走势。
遵循市场规律的重要性 在股市中，要遵循市场的自然涨跌之道，不做主观判断，只做跟随。保持良好的心态，耐心等待投资机会的出现。
相关问答 均线粘合是什么意思？
均线粘合是指股票价格的短期、中期和长期均线相互靠近交织在一起，通常暗示市场平衡或主力吸筹。
均线粘合一定意味着股票上涨吗？
不一定，均线粘合后股价可能向上突破也可能向下突破，要综合多种因素判断。
如何判断均线粘合后的突破方向？
要综合考虑成交量、市场热点、公司基本面等，成交量放大且有其他有利因素支持，向上突破可能性大。
均线粘合周期对股价涨跌有何影响？
一般均线粘合涉及周期越大，未来涨跌幅度可能越大，长期均线粘合往往预示更大行情。
均线粘合与孕线结合怎么操作？
均线粘合出现孕线可次日平开附近介入，突破孕线高点时加仓，同时设好止损。
选股时为何要考虑公司领头人？
公司领头人的能力和野心对公司业绩影响大，进而影响股价。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73844748a9d40af48baab118723e20a2/" rel="bookmark">
			npm install 下载异常原因之一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题
npm ERR! code CERT_HAS_EXPIRED npm ERR! errno CERT_HAS_EXPIRED npm ERR! request to https://registry.npm.taobao.org/yorkie/download/yorkie-2.0.0.tgz failed, reason: certificate has expired 原因
npm 报错提示证书已过期的问题，通常是因为你使用的 npm 源（在这个案例中是淘宝的 npm 镜像 https://registry.npm.taobao.org/）的 SSL 证书已经过期或者你的系统时间设置不正确。
解决方法
如果问题是由淘宝 npm 镜像的证书问题引起的，你可以尝试切换到官方的 npm 源或其他可靠的源。
切换到官方 npm 源：
npm config set registry https://registry.npmjs.org/ 如果你仍然想使用淘宝的 npm 镜像，但希望临时绕过 SSL 验证（注意：这样做可能会带来安全风险，因为 SSL 用于保护数据传输的安全），你可以设置 npm 忽略 SSL 证书错误： npm config set strict-ssl false 注意：这只是一个临时解决方案，不建议长期这样做，因为它会使你的 npm 安装容易受到中间人攻击。 下载完后，恢复
npm config set strict-ssl true 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb39e64d1d2897f55f4a0db9f66edc02/" rel="bookmark">
			AIGC时代从新手到高手：B端竞品分析实战案例与技巧分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1）B端产品的信息获取困难2）B端产品标准化程度低3）需要具备业务知识1）竞品画布就像一个菜谱，帮助新手快速上手2）竞品画布相当于竞品分析报告的MVP（最小可用产品），低成本快速验证竞品分析的思路。 01 明确目标案例案例背景： 02 选择竞品2.1 竞品的分类2.2 如何找到B端的竞品？1. 找售前/销售沟通。2. 各个行业、各个业务领域都有比较成熟的产品3. B端产品的“大众点评”4. 找招标信息 2.3 案例 03 确定分析维度案例 04 收集竞品信息4.1 B端信息获取渠道4.2 获取信息的案例1）证券分析师获取行业信息2）浑水调研公司的调查方法公司实地调研调研客户调查关联方调查供应商请教行业专家 4.3 案例 05 信息整理与分析案例 06 总结报告案例 总结 作者 / 来源：张在旺
竞品分析是产品经理的基本功，B端产品经理同样也需要经常做竞品分析。
B端产品的竞品分析难度更大，主要体现在如下几个方面：
1）B端产品的信息获取困难 产品试用成本高，不像互联网产品那样可以随时下载体验。
对外公开信息较少，很多产品资料在互联网上搜索不到。
2）B端产品标准化程度低 B端产品由于受到多种因素影响（客户的定制化需求、行业特殊性、组织架构差异、业务流程差异、商业模式、地域特征等），同类型的B端产品差异性很大。比如，汽车行业的ERP与医院行业的ERP有很大的差别，大医院用的ERP与小医院用的ERP也有很大差别。
产品的标准化程度低会造成选择竞品困难、对比分析困难。
3）需要具备业务知识 B端产品是为企业的业务服务，所以要理解B端产品的逻辑，就需要具备业务知识。例如，要分析税务软件时，如果缺乏税务领域的业务知识，就很难进行深入的分析。
这些难点对B端产品经理做竞品分析时都是很大的挑战，其中第一点信息获取困难最麻烦。
接下来本文将结合案例，与你分享几点实践经验，希望有助于做好B端产品的竞品分析。
在笔者的上一本书籍《有效竞品分析》有提到，竞品分析的流程可以分为以下6个步骤：
为了让大家更规范地做竞品分析，我们把竞品分析的几个关键步骤固化在一张纸上形成模板，就是竞品画布，如图所示。
竞品画布有两种用途：
1）竞品画布就像一个菜谱，帮助新手快速上手 竞品画布把竞品分析的几个关键步骤固化在一张纸上作为模板，就像竞品分析的SOP（标准操作流程）一样，新手可以按部就班地操作。在写正式的竞品报告之前使用，在流程上予以规范，避免遗漏。
2）竞品画布相当于竞品分析报告的MVP（最小可用产品），低成本快速验证竞品分析的思路。 如果领导让你写一份竞品分析报告，你可以先填写一份竞品画布，跟领导确认关键内容后再去着手做竞品分析、写竞品分析报告，避免你做的竞品分析不符合领导的需求。
如果你让下属做竞品分析，可以先让他填写一份竞品画布，确保他明确了竞品分析的目标，以及他选的竞品、分析的维度等与你的期望一致。否则他可能花了1星期的时间做了一份竞品分析报告，结果选错了竞品或者分析维度欠缺，造成返工、浪费时间。
B端产品的竞品分析同样也可以用这6个步骤、用竞品画布。接下来将按照这6个步骤，结合一个B端竞品分析的案例，逐步分享B端竞品分析的要点。
01 明确目标 竞品分析的目的与目标如下图：
如果竞品分析的目的是决策支持，常见的竞品分析目标：
判断是否该进入一个新市场、是否该做一个新产品帮助新产品做定位，找到细分市场，避免与巨头正面竞争在产品销售、竞标时，提炼卖点，帮助销售人员卖出产品通过分析竞品，制定产品的竞争策略 如果竞品分析的目的是学习借鉴，常见的竞品分析目标：
通过分析业界的成功产品，找到产品机会，先“抄”再“超”从而得到“钞”与业界标杆比较，发现差距，取长补短通过借鉴竞品，帮助形成产品的功能列表为功能的原型设计提供参考学习竞品的运营推广手段 如果竞品分析的目的是市场预警，常见的竞品分析目标：
宏观环境预警：发现政治环境、经济环境、技术环境和社会环境的异动。行业环境预警：发现供应商、客户、现有竞争者、新进入者和替代者的异动。竞争对手监测：监测竞品的市场表现、竞品的推广手段、新竞争对手的出现。 在产品的每一个阶段都可以做竞品分析，但是，在不同阶段做竞品分析的目标与侧重点不同，如图所示。
我们在确定竞品分析的目标时，可以根据产品当前所处的阶段确定竞品分析的目标。
案例 我们将采用一个完整的竞品分析案例，贯穿竞品分析的6个步骤。
案例背景： A上市公司有数千人的产品研发团队，主要开发游戏与企业应用软件。
大型研发团队都会面临一个问题：“人来人往”：
“人来”——新人加入团队时，如何让新人快速成长、快速融入产品团队？“人往”——技术骨干离开团队时，如何减少损失、规避风险？ 员工的知识经验是公司的宝贵资产，但这些资产散落在各个地方：员工的头脑、个人电脑、公司论坛、共享目录、网盘……
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb39e64d1d2897f55f4a0db9f66edc02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6900953ce01a7bfefdbbd6973aa81603/" rel="bookmark">
			2025第十二届广州国际汽车零部件加工技术及汽车模具展览会
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2025第十二届广州国际汽车零部件加工技术及汽车模具展览会
时间：2025年11月20日-22日
地点：广州保利世贸博览馆 (PWTC Expo)
预计20000平方米展出面积；400多家参展商：20000多名观众；
汇集了各种汽车零部件成品、汽车模具以及机床加工技术的行业盛会；
聚集超过80家汽车主机厂以及3000家一二级零部件制造商参观展览会！
展会简介：
2025 第十二届广州国际汽车零部件加工技术及汽车模具展览会是 AUTO TECH 2025 华南展重要组成部分，将于2025年11月20-22日在广州保利世贸博览馆举办！AUTO TECH 2025 零部件加工技术及汽车模具展会汇集国内外上百家知名品牌或实力参展商，同期论坛网罗时下热门议题，集中展示了汽车零部件（包括各类汽车铝、镁、锌、铜合金压铸件、精密铸件、分动器总成、链轮室、变速器总成、变速箱、离合器壳体、轮管、套筒、泵体等部件）、汽车零部件的冲压加工、钣金加工、铸造/锻造、压铸设备、注塑机、表面处理/热处理、切割/研磨加工、树脂成形；刀具、加工设备磨具、塑料模具、自动化及检测设备、汽车模具及相关配套、EV部件及加工技术等，为汽车行业的机加工以及模具成型方面行业打造了一场集技术、商贸、品牌、专业会议为一体的行业盛会！
AUTO TECH 经过多年的发展和完善，已经成为汽车前装领域不可多得的专注于技术和贸易的展览会，成功吸引了上千家国内外知名品牌参展，本届以“绿色发展，科技创新”为主题，坚持技术引领科技，技术推动产业发展，为中国汽车产业新四化和走向世界贡献力量。
广州市是全国三大汽车整车研发制造基地之一，以广东省为中心的大湾区聚集数十家整车和上万家零部件生产企业，在汽车电动化和智能化研发领域走在了世界前沿，AUTO TECH 2025 继续在广州举办，立足华南，辐射亚洲，着力打造全球汽车科技盛会。
展品范围：
汽车零部件产品：
各类汽车铝、镁合金压铸件、铸件、锻件、金属冲压件及加工成型精密部件等；动力系统（发动机缸体、缸盖、支架、曲轴、连杆、活塞、链轮室盖、正时链罩、机油泵壳体、油底壳等）；传动系统（变速箱壳体、离合器壳体、传动轴、主轴、副轴、发电机轴、马达轴、齿轮等）；悬挂系统（弹簧、减振器、万向轴、悬挂臂、摆臂、转向节、横梁、球头等）；转向系统（横拉杆、直拉杆、转向节、转向节臂、万向节、传动轴、转向轴等）；冷却系统（散热器壳体、水泵壳体等）；制动系统部件；内外饰部件；汽车轮毂等；
汽车零部件自动化加工及检测设备：
汽车零部件加工机床上下料、智能取件、切割、智能装配和线体自动化、智能焊接、喷涂、自动化打磨去毛刺抛光、超声波清洗设备、工业机器人、3D打印设备、工业CT系统、三维扫描、X射线、无损检测、工业测量设备、气密性测试仪、打标设备等；
汽车零部件加工技术及成形工艺装备：
金属切、削、磨、铣、钻、机床设备；冲压设备、钣金设备、折弯设备、激光切割、切削刀具、硬质合金、磨料磨具、金属切削油、润滑油等；热处理技术与设备；压铸/铸造设备；树脂工艺等；
汽车模具/材料及配件：
各种注塑模具、冲压模具、压铸模具、铸锻模具等；各种模具钢、特殊钢等模具材料；汽车模具生产用的辅料；模架、顶针、弹簧、热流道、导柱导套、限位夹、锁模扣、镶件、夹具等配件；
汽车模具工艺技术及成型装备：
金切精密加工设备、金属成形设备、激光加工、自动化技术与装置、检测系统及设备、CAD/CAM/CAE及集成系统、信息化管理技术、模具及模具制件、切削刀具、脱模剂、润滑油等；
EV车零部件及加工技术：
电机壳体及加工、动力电池系统壳体加工、热管理系统阀体加工、控制器外壳铸件及加工、新能源汽车部件检测及制造自动化设备等。
同期举办：
APSME 2025 亚洲国际功率半导体、材料及装备技术展览会
AUTO TECH 2025 华南展——第十二届广州国际汽车技术展览会
AUTO TECH 2025 华南展——第五届广州国际新能源汽车产业智能制造技术展览会
同期论坛活动：
2025 新能源汽车零部件加工及智能制造论坛
2025 汽车零部件高效加工技术论坛
2025 新能源汽车行业模具应用技术研讨会
2025 汽车零部件产业3D打印技术的应用论坛
2025 汽车零部件表面处理技术研讨会
日程安排：
布展时间：2025年11月18-19日
开幕时间：2025年11月20日（9:00）
展出时间：2025年11月20-22日（9:00-16:00）
撤展时间：2025年11月22日（16:00）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7533e00c4a83bc86a00e78ca082cb71f/" rel="bookmark">
			毕设分享 基于大数据人才岗位数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 前言1. 数据集说明2. 数据处理2.1 数据清洗2.2 数据导入 3. 数据分析可视化3.1 整体情况（招聘企业数、岗位数、招聘人数、平均工资）3.2 企业主题行业情况公司类型最缺人的公司 TOP平均薪资最高的公司 TOP工作时间工作地点福利词云 3.3 岗位主题工作经验要求学历要求性别要求年龄要求语言要求编程语言要求 4. 模型预测 1 前言 这里是毕设分享系列，学长分享优质毕业设计项目，今天要分享的是
🚩 基于大数据人才岗位数据分析
项目运行效果：
毕业设计 基于大数据人才岗位数据分析
🧿 项目分享:见文末!
1. 数据集说明 这是一份来自厦门人才网的企业招聘数据，采集日期为 2021-01-14，总计 100,077 条记录，大小为 122 M，包含 19 个字段。
2. 数据处理 2.1 数据清洗 使用 pandas 对数据进行清洗，主要包括：去重、缺失值填充、格式化、计算冗余字段。
# 数据重复处理: 删除重复值 # print(data[data.duplicated()]) data.drop_duplicates(inplace=True) data.reset_index(drop=True, inplace=True) # 缺失值查看、处理： data.isnull().sum() # 招聘人数处理：缺失值填 1 ，一般是一人; 若干人当成 3人 data['num'].unique() data['num'].fillna(1, inplace=True) data['num'].replace('若干', 3, inplace=True) # 年龄要求：缺失值填 无限；格式化 data['age'].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7533e00c4a83bc86a00e78ca082cb71f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2a5008c1675d3dd2745886c10741fcb/" rel="bookmark">
			qmt量化交易策略小白学习笔记第57期【qmt编程之期权数据--获取指定期权品种的详细信息--内置Python】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		qmt编程之获取期权数据 qmt更加详细的教程方法，会持续慢慢梳理。
也可找寻博主的历史文章，搜索关键词查看解决方案 ！
获取指定期权品种的详细信息 该函数能帮助用户获取指定期权品种的详细信息，如期权代码、市场、涨跌停价、期权行权价以及期权行权终止日等关键数据。通过使用此功能，投资者可以快速获取与特定期权品种有关的各项重要信息，更加清楚地理解该期权的具体状况，从而为投资决策提供准确的参考依据。
方法1：内置python 调用方法 内置python #encoding:gbk def init(ContextInfo): pass def after_init(ContextInfo): ContextInfo.get_option_detail_data(optioncode) 参数 字段类型说明optioncodestr期权代码 提示 当填写空字符串时候默认为当前主图的期权品种
返回 字典类型 字段类型说明ExchangeIDstr期权市场代码InstrumentIDstr期权代码ProductIDstr期权标的的产品IDOpenDate-发行日期ExpireDate-到期日PreClosefloat前收价格SettlementPricefloat前结算价格UpStopPricefloat当日涨停价DownStopPricefloat当日跌停价LongMarginRatiofloat多头保证金率ShortMarginRatiofloat空头保证金率PriceTickfloat最小变价单位VolumeMultipleint合约乘数MaxMarketOrderVolumeint涨跌停价最大下单量MinMarketOrderVolumeint涨跌停价最小下单量MaxLimitOrderVolumeint限价单最大下单量MinLimitOrderVolumeint限价单最小下单量OptUnitint期权合约单位MarginUnitfloat期权单位保证金OptUndlCodestr期权标的证券代码OptUndlMarketstr期权标的证券市场OptExercisePricefloat期权行权价NeeqExeTypestr全国股转转让类型OptUndlRiskFreeRatefloat期权标的无风险利率OptUndlHistoryRatefloat期权标的历史波动率EndDelivDate-期权行权终止日optTypestr期权类型 示例 #encoding:gbk def init(ContextInfo): pass def after_init(ContextInfo): print(ContextInfo.get_option_detail_data('10002235.SHO')) 返回值 {'ExchangeID': 'SHO', 'InstrumentID': '10002235', 'ProductID': '50ETF(510050)', 'OpenDate': 20200123, 'ExpireDate': 20200923, 'PreClose': 0.3199, 'SettlementPrice': 0.322, 'UpStopPrice': 0.6542, 'DownStopPrice': 0.0001, 'LongMarginRatio': 12.0, 'ShortMarginRatio': 7.0, 'PriceTick': 0.0001, 'VolumeMultiple': 10000, 'MaxMarketOrderVolume': 10, 'MinMarketOrderVolume': 1, 'MaxLimitOrderVolume': 50, 'MinLimitOrderVolume': 1, 'OptUnit': 1.7976931348623157e+308, 'MarginUnit': 7206.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2a5008c1675d3dd2745886c10741fcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1271bef2e38b133a0251089ee968b0b0/" rel="bookmark">
			将python项目打包成一个可执行文件（包含需要的资源文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目标 项目源码是采用Python编写，代码中需要读取部分资源文件。现在需要将项目打包成一个exe文件，没有其他任何多余文件，仅1个exe文件。
打包 安装pyinstaller 在自己项目的虚拟环境中，安装pyinstaller。注意一定要是虚拟环境，不然可能会报错。
pip install pyinstaller 打包命令 pyinstaller --onefile -w -i ./logo.ico --add-data "xxxx/;xxxx/" --name="exe文件名称" .\main.py 参数解释：
–onefile: 将所有依赖项打包到一个单独的可执行文件中。这意味着所有的资源文件、库文件和其他依赖项都将被打包进同一个 .exe 文件中。
-w: 隐藏控制台窗口
-i: 指定图标文件为当前目录下的 logo.ico，这样打包成的程序就会有指定的logo
–add-data: 资源文件或文件夹，我这里是文件夹xxxx。
–name: exe文件名称
.\main.py: 要打包的python脚本
打包成功后显示日志，并在项目的dist文件夹内生成exe文件，且图标为指定的logo.ico，如果多次打包，logo没变，是因为有缓存！可以换个–name或清理缓存解决
部分源码 对于打包进exe的资源文件，源码中采用sys._MEIPASS获取路径，如本例中
def get_resource_path(relative_path): """ 获取资源文件的绝对路径 """ # 如果应用程序是被打包过的，则 base 路径为 sys._MEIPASS base_path = sys._MEIPASS + "\\xxxx/" return os.path.join(base_path, relative_path) 如果需要窗口也显示小图标logo.则需要将logo.ico文件也放入xxxx下，一起打包入exe代码中。并在代码中指定：
base_path = sys._MEIPASS + "\\xxxx/" root.iconbitmap(os.path.join(base_path, "logo.ico")) 获取exe执行文件路径
application_path = os.path.dirname(sys.executable) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd07674c0b513dfa886ad0811410415e/" rel="bookmark">
			Docker 简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习 Docker 之前，先了解 Docker 为什么出现，解决了什么痛点；然后简单介绍 Docker 是什么。
‍
在 Docker 出现之前 假如你在自己的笔记本上，开发一个商城项目，那么开发环境就是你自己的笔记本，并且该开发环境具有特定的配置；而其他同事也有自己的本地开发环境，并且配置一般是互不相同的（比如使用的 IDE 不同，项目位置不同，端口号和数据库连接信息不同… 等等）
除此之外，在测试环境和生产环境中，配置也是不同的，那么在部署过程中，经常会出现版本和配置问题（俗称环境问题）。
为了解决环境问题，容器技术出现了（例如 Docker）。Docker 之所以发展如此迅速，也是因为它对此给出了一个标准化的解决方案-----系统平滑移植，容器虚拟化技术。
环境配置是相当麻烦的，例如安装 Java，Tomcat、Nginx 等；换一台机器，又要重新安装一遍，费力费时。那能不能从根本上解决问题：软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作，在其他机器上不行”的问题。
除此之外，还能解决扩容和缩容的问题：想要增加一台服务器，那么只需在上面用 Docker 复制一份开发环境即可，非常方便。
Docker 还能解决跨平台的问题，比如一个项目是在 Windows 下开发的，那么使用 Docker，项目也能在 Linux 和 Mac OS 下运行。
Docker 的出现使得过去「程序即应用」的观念被打破。透过镜像（images）将项目，运行项目所需要的系统环境等信息，由下而上打包，达到应用程式跨平台间的无缝接轨运作。
镜像就好比一个打包好的环境，里面包含了源代码 + 配置 + 环境 + 版本。
比如，使用虚拟机安装 Centos 的时候，就用到了 Centos 镜像，直接安装该镜像，安装好后就可以获得一个 Centos 服务器。
‍
注意，容器技术的出现，使得开发也要慢慢的兼顾运维的一些工作。
‍
Docker 是什么 Docker 是基于 Go 语言实现的云开源项目。
Docker 的主要目标是“Build, Ship and Run Any App, Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的 APP（可以是一个 WEB 应用或数据库应用等等）及其运行环境能够做到“一次镜像，处处运行”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd07674c0b513dfa886ad0811410415e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41144f230563c00685d734168f950f7f/" rel="bookmark">
			使用openhtmltopdf 工具进行转PDF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 springBoot后台如何共用一个css文件
1.首先在META-INF路径下添加一个公共的css文件，然后在springboot启动设置静态资源，要确保项目启动后能够访问到此文件，如：
META-INF/resources/static/css/index.css 测试访问是否成功：http://localhost:8000/static/css/index.css
如果不能访问，请检查是否有白名单设置
String html = "html 内容"; ByteArrayOutputStream baos = new ByteArrayOutputStream(); try { PdfRendererBuilder builder = new PdfRendererBuilder(); builder.toStream(baos); builder.useFastMode(); builder.useFont(() -&gt; TcFonts.readFont(fontFamily), fontFamily); builder.withW3cDocument(new W3CDom().fromJsoup(Jsoup.parse(html)),"/"); builder.run(); return baos.toByteArray(); } finally { html = null; if (baos != null) { baos.close(); } } 读取静态文件超时或失败，我这边给出两个解决方案：
1.修改HTTP默认时长
重写com.openhtmltopdf.swing.NaiveUserAgent 类
//默认 //final static int CONNECTION_TIMEOUT = 10_000; //final static int READ_TIMEOUT = 30_000; //增加一倍 final static int CONNECTION_TIMEOUT = 30_000; final static int READ_TIMEOUT = 60_000; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcc9d5a00e4021391924f26ae0a618e6/" rel="bookmark">
			【Python机器学习】词向量推理——词向量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
面向向量的推理
使用词向量的更多原因
如何计算Word2vec表示
skip-gram方法
什么是softmax
神经网络如何学习向量表示
用线性代数检索词向量
连续词袋方法
skip-gram和CBOW：什么时候用哪种方法
word2vec计算技巧
高频2-gram
高频词条降采样
负采样
如何使用gensim.word2vec模块
生成定制化词向量表示
预处理阶段
面向特定领域的word2vec模型
word2vec和GloVe
fastText
如何使用预训练fastText模型
Word2vec和LSA
词关系可视化
非自然词
利用Doc2vec计算文档相似度
如何训练文档向量
Mikolov发现了一种用一定维度的向量表示词的含义的方法，他训练了一个神经网络来预测每个目标词附近的共现词，之后，其在谷歌发布了创建这些词向量的软件，称为Word2vec。
Word2vec仅仅基于大型未标记文本语料库来学习词的含义，而不需要标记Word2vec词汇表中的词。我们不需要告诉西雅图是一个城市，也不需要告诉它足球是一项运动，Word2vec完全可以靠自己学到更多的知识。用户需要做的只是准备一个足够大的语料库。
Word2vec这种无监督的特性使它无比强大，因为现实世界中充满了未标记、未分类、非结构化的自然语言文本。
监督学习：
监督学习中，必须对训练数据进行某种标注；监督学习只有在能够度量预测输出（标签）与其预测值之间的差异时，模型才能变得更好。
相反，无监督学习使机器能够直接从数据中学习，而不需要人类的任何帮助。训练数据不要人工组织、结构化、标注。所以像Word2vec这样的无监督学习算法对自然语言文本来说非常完美。
无监督学习：
在无监督学习中，同样也是训练模型去执行某种人物，但没有任何任务标注，只有原始数据。聚类算法（比如k均值或DBSCAN）就属于无监督学习，像PCA、t-SNE这样的降维算法也属于无监督机器学习技术。在无监督学习中，模型根据数据点自身的关系中去发现模型。通过向无监督模型投入更多的数据，它可以变得更智能更精确。
教神经网络预测句子中目标词附近的词，而不是带有词含义的标签来直接学习目标词的含义。在这个意义上，也可以算是有标注：待预测的相邻词。不过这些标注来自数据集本身，不需要手工标注，因此Word2vec训练算法确实是一个无监督学习算法。
使用无监督训练技术的另一个领域是时间序列建模。时间序列建模通常被训练在一个序列中基于前一个窗口的值预测下一个值。时间序列问题与自然语言问题在很多方面非常相似，它们处理的都是有序值（词或数值）。
预测本身并不是Word2vec的关键，预测只是达到目的的一种手段。大家真正关心的是它的内部表示，即Word2vec在生成这些预测过程中逐渐构建的向量。与隐性语义分析和隐性狄利克雷分布中的词-主题向量不同，Word2vec词向量表示能够捕捉更丰富的目标词含义（语义）。
Word2vec将学习到一些人们可能认为的与所有词本身并不相关的东西，例如每个词都有一定的地理位置、情感和性别倾向性，如果语料库中有任何一个词具有某种属性，如“placeness”（平和）、“peopleness”（有人情味）等，那么其他所有的词也会在词向量的这些属性上得分。当Word2vec学习词向量时，可以认为某些词的意义“感染”了其相邻词。
语料库中的所有词都将由数字向量表示，类似于词-主题向量，只是这次主题具有更具体、更准确的含义。在LSA中，词只需要在相同文档出现，它们的含义就会相互“感染”，并融入词的主题向量中。对于Word2vec词向量，这些词必须彼此相邻——通常在同一个句子中的间隔不超过5个词。而且Word2vec词向量的主题权重可以通过加减运算来创建新的有意义的词向量。
下面，把词向量看作是一个权重或分数的列表，列表中的每个权重或分数都对应于这个词在某个特定维度的含义：
from nlpia.book.examples.ch06_nessvectors import * print(nessvector('Marie_Curie').round(2)) 我们还可以使用nlpia提供的工具为Word2vec词汇表中的任何词或n-gram计算属性向量（nessvector），这种方法适用于我们创建的所有属性。
Mikolov在思考如何用数字向量表示词的过程中开发了Word2vec算法，而且不满足于不太精确的词“情感”计算。他想做的是面向向量的推理，就像前面的类比问题。这个概念意味着可以用词向量做数学运算，再把得到的结果向量转换成词，这样就能得到有意义的答案。我们可以对词向量做加减法来对它们所表示的词进行推理，从而回答一些问题，比如：
mv['Timbers']-mv['Portland']+mv['Seattle']=? 在理想情况下，希望这个数学运算（词向量推理）能返回这个结果：
mv['Seattle_Sounders'] LSA中基于整篇文档构建的主题向量非常适合文档分类、语义搜索和聚类。但是LSA生成的主题-词向量不够精确，不能用于短语或复合词的语义推理、分类和聚类。之后，可以对LSA词向量表示法进行改进。
面向向量的推理 在某个阶段，Word2vec词嵌入的精确率是LSA模型精确率的4倍（45%对11%）。
有了词向量之后，类似于 Portland Timbers + Seattle - Portland = ? 的问题就可以用向量代数来进行解答：
Word2vec模型包含词之间的关系信息，包括词的相似性。Word2vec模型“知道”术语Portland（波特兰）和Portland Timbers（波特兰伐木者队）之间的距离与Seattle（西雅图）和Seattle Sounders（西雅图海湾人队）之间的距离大致相同，并且这些距离的方向（向量对之间的差异）大致相同。所以Word2vec模型可以用来回答球队的类比问题。将Portland和Seattle两个向量之间的差值加到表示Portland Timbers的向量上，这样得到的结果应该接近术语Seattle Sounders的向量：
在进行词向量的加减法运算后，得到的向量一般不会正好等于词向量表中的某个向量。不过，Word2vec词向量通常由100维，每个维度上都有连续的实值，词向量表中与运算结果最接近的向量通常就是NLP问题的答案。与这个相邻向量相关联正式上述问题的自然语言答案。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcc9d5a00e4021391924f26ae0a618e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/feed136e57ec3b83c42486c9a36e0883/" rel="bookmark">
			碰撞检测 | 详解矩形AABB与OBB碰撞检测算法(附ROS C&#43;&#43;可视化)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 0 专栏介绍1 AABB碰撞检测2 OBB碰撞检测3 算法仿真与可视化 0 专栏介绍 🔥课设、毕设、创新竞赛必备！🔥本专栏涉及更高阶的运动规划算法轨迹优化实战，包括：曲线生成、碰撞检测、安全走廊、优化建模(QP、SQP、NMPC、iLQR等)、轨迹优化(梯度法、曲线法等)，每个算法都包含代码实现加深理解
🚀详情：运动规划实战进阶：轨迹优化篇
矩形包围盒碰撞检测的核心原理是用矩形近似待检测物体轮廓，通过计算两个矩形间是否有重叠区域来进行碰撞判断。常用的包围形式有轴对齐包围盒(Axis-Aligned Bounding Box, AABB)以及更精细化具有角度的方向包围盒(Oriented Bounding Box)
本文的最终效果如下所示
1 AABB碰撞检测 如图所示为AABB碰撞检测的原理，其通过计算两个矩形在对齐的若干条轴上的投影来判碰，当且仅当所有轴的投影都发生重叠时两个AABB产生碰撞。
算法原理如表所示，其中矩形用左上角坐标和长宽来表示
按照算法流程实现核心算法
bool VRectangle::_AABBCollisionDetection(const std::shared_ptr&lt;VRectangle&gt;&amp; other) { return lt_pt_.x &lt; other-&gt;left_top_point().x + std::fabs(other-&gt;length()) &amp;&amp; other-&gt;left_top_point().x &lt; lt_pt_.x + std::fabs(l_) &amp;&amp; lt_pt_.y &lt; other-&gt;left_top_point().y + std::fabs(other-&gt;width()) &amp;&amp; other-&gt;left_top_point().y &lt; lt_pt_.y + std::fabs(w_); } 2 OBB碰撞检测 OBB碰撞检测的核心原理是应用分离轴定理，在矩形的长宽两个方向进行投影(共计4次)，判断投影是否重叠；只要存在一条投影轴不发生重叠，表明找到了至少一条分离轴，即两个OBB不发生碰撞
沿矩形长宽方向设置方向向量以及待投影的几何向量
{ k 1 = [ cos ⁡ α sin ⁡ α ] T k 2 = [ sin ⁡ α − cos ⁡ α ] T k 3 = [ cos ⁡ β sin ⁡ β ] T k 4 = [ sin ⁡ β − cos ⁡ β ] T , { v 1 = l 1 − k 1 v 2 = w 1 − k 2 v 3 = l 2 − k 3 v 4 = w 2 − k 4 \begin{cases} \boldsymbol{k}_1=\left[ \begin{matrix} \cos \alpha&amp; \sin \alpha\\\end{matrix} \right] ^T\\ \boldsymbol{k}_2=\left[ \begin{matrix} \sin \alpha&amp; -\cos \alpha\\\end{matrix} \right] ^T\\ \boldsymbol{k}_3=\left[ \begin{matrix} \cos \beta&amp; \sin \beta\\\end{matrix} \right] ^T\\ \boldsymbol{k}_4=\left[ \begin{matrix} \sin \beta&amp; -\cos \beta\\\end{matrix} \right] ^T\\\end{cases}, \begin{cases} \boldsymbol{v}_1=l_{1}^{-}\boldsymbol{k}_1\\ \boldsymbol{v}_2=w_{1}^{-}\boldsymbol{k}_2\\ \boldsymbol{v}_3=l_{2}^{-}\boldsymbol{k}_3\\ \boldsymbol{v}_4=w_{2}^{-}\boldsymbol{k}_4\\\end{cases} ⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​k1​=[cosα​sinα​]Tk2​=[sinα​−cosα​]Tk3​=[cosβ​sinβ​]Tk4​=[sinβ​−cosβ​]T​,⎩⎪⎪⎪⎨⎪⎪⎪⎧​v1​=l1−​k1​v2​=w1−​k2​v3​=l2−​k3​v4​=w2−​k4​​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/feed136e57ec3b83c42486c9a36e0883/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11ec385676730f8bd9e2db5df64b3f7e/" rel="bookmark">
			【工具篇】vscode设置护眼色主题皮肤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载对应配置主题的插件：https://marketplace.visualstudio.com/items?itemName=Hyzeta.vscode-theme-github-light&amp;ssr=false#overview
2、放在本地文件夹目录，并使用vscode离线加载插件github light theme
3、使用everything搜索 Github-Light-Theme-Gray-color-theme.json文件
4、使用以下内容全部覆盖该json文件
{ "name": "Github Light Theme", "type": "light", "colors": { // base color "focusBorder": "#f0f0f000", "foreground": "#000000", "editor.background": "#fdf6e3", "editor.foreground": "#000000", "scrollbar.shadow": "#eee8d5", // activity bar "activityBar.border": "#eee8d5", "activityBar.background": "#eee8d5", "activityBar.foreground": "#000000", "activityBarBadge.background": "#d73a49", // status bar "statusBar.border": "#eee8d5", "statusBar.background": "#eee8d5", "statusBar.foreground": "#000000", "statusBar.noFolderBackground": "#eee8d5", "statusBar.noFolderForeground": "#000000", "statusBar.debuggingBackground": "#eee8d5", "statusBar.debuggingForeground": "#000000", // editor groups and tabs "editorGroup.border": "#eee8d5", "editorGroupHeader.tabsBackground": "#eee8d5", "editorGroupHeader.noTabsBackground": "#eee8d5", "editorGroupHeader.tabsBorder": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11ec385676730f8bd9e2db5df64b3f7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d762dc80d35157fddbbce0cf4d1aedef/" rel="bookmark">
			SprinBoot&#43;Vue宠物领养救助微信小程序的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 项目介绍2 项目截图3 核心代码3.1 Controller3.2 Service3.3 Dao3.4 application.yml3.5 SpringbootApplication3.5 Vue3.6 uniapp代码 4 数据库表设计5 文档参考6 计算机毕设选题推荐7 源码获取 1 项目介绍 博主个人介绍：CSDN认证博客专家，CSDN平台Java领域优质创作者，全网30w+粉丝，超300w访问量，专注于大学生项目实战开发、讲解和答疑辅导，对于专业性数据证明一切！
主要项目：javaweb、ssm、springboot、vue、小程序、python、安卓、uniapp等设计与开发,万套源码成品可供选择学习。
👇🏻👇🏻文末获取源码
SprinBoot+Vue宠物领养救助微信小程序的设计与实现(源码+数据库+文档)
项目描述
本研究设计并实现了一个基于Springboot框架的小动物救助领养小程序。该小程序旨在为动物救助组织和爱心人士搭建一个平台，方便对流浪动物进行救助和领养。本小程序的定位在于提供一个便捷快速的交流平台，在保证用户信息安全的同时，为动物救助事业和流浪动物寻找更多机会和资源。
创新性方面，本小程序采用了Springboot框架，实现了高效的开发和部署，有效提高了小程序的性能和响应速度。同时，通过整合微信小程序接口和定制化开发，实现了用户的在线预约和动物信息的展示功能。此外，本小程序还引入了人工智能识别技术，为用户提供更快速、准确的信息识别和查询服务，大大提高了用户体验。
特色功能方面，本小程序提供了动物分类、领养预约、实时定位、在线支付等功能，用户可以根据自己的需求和喜好快速找到适合自己的动物并进行领养。同时，小程序还支持用户发布寻找家的流浪动物信息，帮助更多动物找到温暖的家园。此外，小程序还提供动物健康档案管理和在线社区交流功能，促进用户之间的互动和交流。
本小程序的意义和价值在于提倡人与动物和谐相处的理念，促进了社会公益事业的发展和流浪动物的保护。同时，通过技术手段的运用，实现了动物救助信息的快速传递和动物领养过程的便捷化，提高了动物救助组织的效率和用户体验。未来，本研究将不断完善和优化小程序功能，扩大用户覆盖范围，为更多的流浪动物和有爱心的人士搭建桥梁，推动动物保护事业的发展。
2 项目截图 springboot小动物救助领养小程序端演示录像
springboot小动物救助领养小程序服务端演示录像
3 核心代码 3.1 Controller package com.controller; import java.util.Arrays; import java.util.Calendar; import java.util.Date; import java.util.Map; import javax.servlet.http.HttpServletRequest; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.bind.annotation.RestController; import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d762dc80d35157fddbbce0cf4d1aedef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eef65f3af4d8ed325714c3ed3c95a651/" rel="bookmark">
			交易处理商TAAL公司深度参与BSV区块链的ARC研发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ​​发表时间：2024年8月7日
TAAL技术主管Michael Böckli表示，TAAL公司一直在对ARC进行测试，并准备在今年年底全面发布。因TAAL在区块链交易处理方面具备深厚的专业知识，BSV区块链委托TAAL进行ARC开源参考落地方案的开发。
ARC是一个多层交易处理系统，能够追踪交易在BSV区块链上的整个生命周期。
除了遵循BSV区块链的开源指南和要求开发ARC的开源版本之外，TAAL还开发了一个商业版本的ARC，并将其作为一项适合商业和企业级应用的服务向企业推广。
在2024年伦敦区块链大会上，Böckli提到ARC的开发过程已经进行了一年多。他指出，ARC最初是为了取代mAPI，但现在已经发展成为一个更加全面的工具。
Böckli指出：“ARC的运作方式有点像一个独立的节点，而不仅仅是一个向节点发起远程过程调用（RPC）的程序。它已经为即将到来的Teranode时代做好了准备。然而，在我们达到那个阶段之前，ARC还需要进一步的调整和更广泛的开发。
ARC将可能成为覆盖网络中的一个节点，任何人都可以使用和运行。ARC的设计和功能使其能够适应并被集成到这个网络中，作为一个功能性的节点存在。”
除了标准的ARC实现方案之外，ARC还可能会有根据特定需求定制的版本。这些定制版本可能会添加或修改某些功能，以更好地服务于特定的业务场景或行业需求。ARC本质上是这类组件的参考标准。作为一个开源项目，ARC为其他开发者提供了一个基础框架和标准，使他们可以基于这个标准来创建自己的应用方案，无论是保持原有功能还是进行定制化开发。
这个观点引发了关于开源和商业应用之间的讨论。Böckli指出，尽管TAAL正在积极进行ARC的整体开发，但也在努力改进对ARC系统运行状态的跟踪、观察和管理的监控技术，以便更有效地维护和优化ARC系统。他提到，TAAL可能会开发一些非开源的功能优化，这些优化可能涉及到更高级的监控技术或专注于商业版本的功能增强，以提供额外价值，区分开源版本和商业版本，满足不同用户群体的需求。
“这并不表示开源版本的开发会中断。”Böckli强调自己和团队正全力以赴，确保在今年年底的Teranode升级中，ARC能够成功部署。
快速了解什么是ARC ARC是一个区块链上的多层交易处理系统，能够追踪交易在BSV区块链上的整个生命周期。
与传统的交易处理器不同，ARC通过点对点（P2P）网络广播所有交易，并不依赖于单一节点的远程过程调用（RPC）接口。这种设计让ARC能够与任意数量的节点建立连接并进行广播，满足用户对连接和广播到的节点数量的需求。
未来，ARC将能够利用IPv6多播技术发送交易，这将让它在不产生大量带宽成本的情况下连接到众多节点。
ARC的设计将交易处理器的核心功能解耦，并将其封装成能够灵活进行水平扩展的微服务。在可能的情况下，这些微服务之间的交互通过异步消息传递来实现解耦。
ARC由几个关键的微服务组成，包括API服务器、验证器（具备根据工作量增加而进行扩展的能力）、用于管理交易状态变化的变形服务，以及处理连接的对等体管理器。此外，ARC采用了一种新的区块存储格式，它只包含交易ID而不是完整的交易数据。这种架构旨在提高BSV区块链网络中的交易可靠性和效率。
ARC的四个微服务包括：API、Metamorph、BlockTX和Callbacker。
ARC API： API作为与ARC系统交互的接口，具有几个关键的端点。包括设置政策要求的端点，如每字节的挖矿费用，以及用于并行或串行处理交易的交易提交端点。交易通过一种“扩展格式”提交，这不仅包含了必要的基础信息，还额外包括了用于脚本验证和费用核算的数据，有效解决了仅使用原始交易数据时可能遇到的问题。为了在广播之前确保交易的准确性，这种格式需要依赖一个正在开发中的UTXO查找服务。这项服务的引入，将大幅提升交易的可靠性。
Metamorph： Metamorph的角色是通过点对点网络将预先验证的交易放置在区块链上。它可以连接到多个实例，使用轮询负载平衡来处理高交易量。Metamorph从API接收并处理交易，监控它们的状态，并根据需要转发更新。
BlockTx： BlockTx是一个监听点对点消息，特别是区块公告的微服务。在检测到区块公告后，BlockTx就会提取并处理关键数据，确认交易ID是否嵌入了区块头部的默克尔根中。它将交易进行哈希处理，生成交易ID列表，并为这些ID计算出相应的默克尔路径。随后，BlockTx会将这些交易的状态标记为“已挖矿”，并按照BRC 71标准来存储这些路径信息。
**Callbacker：**Callbacker服务让用户能够追踪他们交易的实时状态。用户可以通过API的“get tx”接口查询交易状态，并选择他们希望接收的更新类型。用户只需提供一个网址和Token，就可以在交易状态发生变化时，比如挖掘状态更新或默克尔路径数据变化时，接收到通知。
更多关于ARC的信息请看：
https://www.bsvblockchain.org/news/bsv-blockchain-launches-arc-v1
目前，全球已有超过400个项目构建于BSV区块链之上。凭借坚如磐石的协议及超高的网络性能，BSV生态系统迅猛发展，我们期待未来出现更多前所未有的商业应用。
对BSV区块链开发感兴趣的朋友，可以前往我们的中文开发者专区：BSV区块链 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24020a0f366c537280507458b5bba9da/" rel="bookmark">
			数字图像处理基础：图像处理概念、步骤、方式介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《博主简介》
小伙伴们好，我是阿旭。专注于人工智能、AIGC、python、计算机视觉相关分享研究。
👍感谢小伙伴们点赞、关注！
《------往期经典推荐------》
一、AI应用软件开发实战专栏【链接】
项目名称项目名称1.【人脸识别与管理系统开发】2.【车牌识别与自动收费管理系统开发】3.【手势识别系统开发】4.【人脸面部活体检测系统开发】5.【图片风格快速迁移软件开发】6.【人脸表表情识别系统】7.【YOLOv8多目标识别与自动标注软件开发】8.【基于YOLOv8深度学习的行人跌倒检测系统】9.【基于YOLOv8深度学习的PCB板缺陷检测系统】10.【基于YOLOv8深度学习的生活垃圾分类目标检测系统】11.【基于YOLOv8深度学习的安全帽目标检测系统】12.【基于YOLOv8深度学习的120种犬类检测与识别系统】13.【基于YOLOv8深度学习的路面坑洞检测系统】14.【基于YOLOv8深度学习的火焰烟雾检测系统】15.【基于YOLOv8深度学习的钢材表面缺陷检测系统】16.【基于YOLOv8深度学习的舰船目标分类检测系统】17.【基于YOLOv8深度学习的西红柿成熟度检测系统】18.【基于YOLOv8深度学习的血细胞检测与计数系统】19.【基于YOLOv8深度学习的吸烟/抽烟行为检测系统】20.【基于YOLOv8深度学习的水稻害虫检测与识别系统】21.【基于YOLOv8深度学习的高精度车辆行人检测与计数系统】22.【基于YOLOv8深度学习的路面标志线检测与识别系统】23.【基于YOLOv8深度学习的智能小麦害虫检测识别系统】24.【基于YOLOv8深度学习的智能玉米害虫检测识别系统】25.【基于YOLOv8深度学习的200种鸟类智能检测与识别系统】26.【基于YOLOv8深度学习的45种交通标志智能检测与识别系统】27.【基于YOLOv8深度学习的人脸面部表情识别系统】28.【基于YOLOv8深度学习的苹果叶片病害智能诊断系统】29.【基于YOLOv8深度学习的智能肺炎诊断系统】30.【基于YOLOv8深度学习的葡萄簇目标检测系统】31.【基于YOLOv8深度学习的100种中草药智能识别系统】32.【基于YOLOv8深度学习的102种花卉智能识别系统】33.【基于YOLOv8深度学习的100种蝴蝶智能识别系统】34.【基于YOLOv8深度学习的水稻叶片病害智能诊断系统】35.【基于YOLOv8与ByteTrack的车辆行人多目标检测与追踪系统】36.【基于YOLOv8深度学习的智能草莓病害检测与分割系统】37.【基于YOLOv8深度学习的复杂场景下船舶目标检测系统】38.【基于YOLOv8深度学习的农作物幼苗与杂草检测系统】39.【基于YOLOv8深度学习的智能道路裂缝检测与分析系统】40.【基于YOLOv8深度学习的葡萄病害智能诊断与防治系统】41.【基于YOLOv8深度学习的遥感地理空间物体检测系统】42.【基于YOLOv8深度学习的无人机视角地面物体检测系统】43.【基于YOLOv8深度学习的木薯病害智能诊断与防治系统】44.【基于YOLOv8深度学习的野外火焰烟雾检测系统】45.【基于YOLOv8深度学习的脑肿瘤智能检测系统】46.【基于YOLOv8深度学习的玉米叶片病害智能诊断与防治系统】47.【基于YOLOv8深度学习的橙子病害智能诊断与防治系统】48.【车辆检测追踪与流量计数系统】49.【行人检测追踪与双向流量计数系统】50.【基于YOLOv8深度学习的反光衣检测与预警系统】51.【危险区域人员闯入检测与报警系统】52.【高密度人脸智能检测与统计系统】53.【CT扫描图像肾结石智能检测系统】54.【水果智能检测系统】55.【水果质量好坏智能检测系统】56.【蔬菜目标检测与识别系统】57.【非机动车驾驶员头盔检测系统】58.【太阳能电池板检测与分析系统】59.【工业螺栓螺母检测】60.【金属焊缝缺陷检测系统】61.【链条缺陷检测与识别系统】62.【交通信号灯检测识别】 二、机器学习实战专栏【链接】，已更新31期，欢迎关注，持续更新中~~
三、深度学习【Pytorch】专栏【链接】
四、【Stable Diffusion绘画系列】专栏【链接】
五、YOLOv8改进专栏【链接】，持续更新中~~
六、YOLO性能对比专栏【链接】，持续更新中~
《------正文------》
目录 数字图像处理基础数字图像处理的基本步骤图像处理主要步骤什么是图像？图像的类型图像作为矩阵MATLAB中的数字图像表示：图像处理的阶段：重叠场与图像处理数字图像处理的优势：数字图像处理的缺点： 数字图像处理基础 数字图像处理是指利用数字计算机对数字图像进行处理。我们也可以说它是一种利用计算机算法，为了得到增强的图像或者提取一些有用的信息。
数字图像处理是使用算法和数学模型来处理和分析数字图像。数字图像处理的目标是提高图像质量，从图像中提取有意义的信息，并自动执行基于图像的任务。
数字图像处理的基本步骤 图像采集：这涉及使用数码相机或扫描仪捕获图像，或将现有图像导入计算机。图像增强：这涉及提高图像的视觉质量，例如增加对比度，减少噪音和消除伪影。图像恢复：这涉及从图像中去除退化，如模糊，噪声和失真。图像分割：这涉及将图像划分为区域或片段，每个区域或片段对应于图像中的特定对象或特征。图像表示和描述：这涉及以计算机可以分析和操作的方式表示图像，并以紧凑和有意义的方式描述图像的特征。图像分析：这涉及使用算法和数学模型从图像中提取信息，例如识别对象，检测模式和量化特征。图像合成和压缩：这涉及生成新图像或压缩现有图像以降低存储和传输要求。数字图像处理广泛应用于医学成像、遥感、计算机视觉和多媒体等领域。 图像处理主要步骤 1.通过图像采集工具采集图像;
2.分析和处理图像;
3.输出结果可以是改变的图像或基于分析该图像的报告。
什么是图像？ 图像被定义为二维函数F（x，y），其中x和y是空间坐标，并且F在任何一对坐标（x，y）处的振幅被称为该图像在该点处的强度。当F的x、y和幅值都是有限的时，我们称之为数字图像。
换句话说，图像可以由特定地以行和列布置的二维阵列来定义。
数字图像由有限个元素组成，每个元素在特定位置具有特定值。这些元素被称为图像元素，图像元素和像素。像素最广泛用于表示数字图像的元素。
图像的类型 二进制图像-二进制图像顾名思义，只包含两个像素元素，即0和1，其中0表示黑色，1表示白色。这种图像也被称为Monochrome。黑白图像-仅由黑色和白色颜色组成的图像称为黑白图像。8位彩色格式-它是最著名的图像格式。它有256种不同的颜色，通常被称为灰度图像。在此格式中，0代表黑色，255代表白色，127代表灰色。16位彩色格式-它是一种彩色图像格式。它有65，536种不同的颜色在里面。它也被称为高颜色格式。在这种格式中，颜色的分布与灰度图像不同。 一个16位格式实际上被进一步分成三种格式，即红色、绿色和蓝色。著名的RGB格式。
图像作为矩阵 正如我们所知，图像是以行和列表示的，我们有以下语法来表示图像：
这个等式的右边是数字图像的定义。这个矩阵的每一个元素都被称为图像元素、图像元素或像素。
MATLAB中的数字图像表示： 在MATLAB中，起始索引是从1开始，而不是从0开始。因此，f（1，1）= f（0，0）。
此后，除了原点的移位之外，图像的两种表示是相同的。
在MATLAB中，矩阵存储在一个变量中，即X，x，input_image等。变量必须是一个字母，与其他编程语言相同。
图像处理的阶段： 获取-它可以是简单的，因为被赋予一个图像，这是在数字形式。主要工作包括：
a）缩放
B）颜色转换（RGB到灰色或反之亦然）
图像增强-它是图像处理领域中最简单和最吸引人的方法之一，它也用于从图像中提取一些隐藏的细节，并且是主观的。
图像恢复-它也处理图像的吸引力，但它是客观的（恢复是基于数学或概率模型或图像退化）。
彩色图像处理-它处理伪彩色和全色图像处理，彩色模型适用于数字图像处理。
小波和多分辨率处理-它是表示图像在不同程度上的基础。
图像压缩-它涉及开发一些函数来执行此操作。它主要处理图像大小或分辨率。
形态处理-它处理用于提取在形状的表示和描述中有用的图像成分的工具。
分割过程-它包括将图像分割成其组成部分或对象。自主分割是图像处理中最困难的任务。
表示描述-它遵循分割阶段的输出，选择表示只是将原始数据转换为处理数据的解决方案的一部分。
对象检测和识别-这是一个基于对象的描述符为对象分配标签的过程。
重叠场与图像处理 根据第1块，如果输入是图像，我们得到图像作为输出，那么它被称为数字图像处理。
根据第2块，如果输入是图像，我们得到某种信息或描述作为输出，那么它被称为计算机视觉。
根据第3块，如果输入是一些描述或代码，我们得到图像作为输出，那么它被称为计算机图形学。
根据第4块，如果输入是描述或一些关键字或一些代码，并且我们得到描述或一些关键字作为输出，那么它被称为人工智能
数字图像处理的优势： 提高图像质量：数字图像处理算法可以提高图像的视觉质量，使其更清晰，更锐利，信息量更大。自动化的基于图像的任务：数字图像处理可以自动化许多基于图像的任务，例如对象识别，模式检测和测量。提高效率：数字图像处理算法可以比人类更快地处理图像，从而可以在短时间内分析大量数据。提高准确性：数字图像处理算法可以提供比人类更准确的结果，特别是对于需要精确测量或定量分析的任务。 数字图像处理的缺点： 高计算成本：一些数字图像处理算法是计算密集型的，需要大量的计算资源。有限的可解释性：一些数字图像处理算法可能产生人类难以解释的结果，特别是对于复杂或复杂的算法。对输入质量的依赖：数字图像处理算法的输出质量高度依赖于输入图像的质量。低质量的输入图像可能导致低质量的输出。算法的局限性：数字图像处理算法具有局限性，例如难以识别杂乱或光线不足的场景中的对象，或者无法识别具有显著变形或遮挡的对象。依赖于良好的训练数据：许多数字图像处理算法的性能取决于用于开发算法的训练数据的质量。质量差的训练数据会导致算法性能差 关注文末名片G-Z-H：【阿旭算法与机器学习】，发送【开源】可获取更多学习资源
好了，这篇文章就介绍到这里，喜欢的小伙伴感谢给点个赞和关注，更多精彩内容持续更新~~
关于本篇文章大家有任何建议或意见，欢迎在评论区留言交流！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72baf744bf4b59acbd72bc9c81a88810/" rel="bookmark">
			Unity【Colliders碰撞器】和【Rigibody刚体】的应用——小球反弹效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Collider 2D
定义：
类型：
Rigidbody 2D
定义：
属性和行为：
运动控制：
碰撞检测：
结合使用
实用检测 延伸拓展 1、在Unity中优化Collider 2D和Rigidbody 2D的性能
2、Unity中Collider 2D的高级使用技巧
3、Rigidbody 2D与其他物理组件（如Collider 2D）结合使用的最佳实践
4、在Unity中实现复杂物理效果（如水体、火光等）时，有效地使用Collider 2D和Rigidbody 2D
5、针对不同类型的碰撞器（Box, Circle, Polygon, Edge），Unity提供的特定优化或调整建议
Box Collider：
Circle Collider：
Polygon Collider：
Sphere Collider：
Collider 2D 定义： Collider 2D是一个组件，它为游戏对象提供了一个物理边界，允许与其他具有相同或不同类型的Collider 2D进行碰撞检测。可以选择“Is Trigger”选项来决定该碰撞器是否具有实际物理存在。如果设置为true，则该碰撞器仅用于检测碰撞事件，而不影响物理模拟。
类型： Unity提供了多种类型的Collider 2D，包括： Box Collider 2D：矩形形状的碰撞器，非常高效且适用于可交互的形状。Circle Collider 2D：圆形碰撞器，适用于简单的圆形物体。Polygon Collider 2D：多边形碰撞器，可以自定义任何多边形形状，但计算较慢。Edge Collider 2D：边缘碰撞器，没有面积，适用于静态、非交互的凹形形状。 Rigidbody 2D 定义： Rigidbody 2D是一个组件，它将游戏对象置于物理引擎的控制之下，使其能够响应重力、摩擦力、碰撞等物理现象。
属性和行为： Rigidbody 2D与标准的Rigidbody类似，但专为二维开发进行了优化。例如，带有Rigidbody 2D的游戏对象只能在XY平面内移动，并且只能围绕垂直于该平面的轴旋转。它可以设置不同的质量（Mass），并根据需要调整其他物理参数如阻力（Drag）和角阻力（Angular Drag）。 运动控制： 使用API如Rigidbody2D.MovePosition或Rigidbody2D.MoveRotation来直接移动或旋转游戏对象。可以通过脚本编写逻辑来决定物体如何移动和反应于各种物理事件。 碰撞检测： 当一个带有Rigidbody 2D的游戏对象与另一个带有碰撞器的游戏对象发生碰撞时，Unity会自动处理这些碰撞事件，并更新物体的位置和速度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72baf744bf4b59acbd72bc9c81a88810/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a86118f161a6989f0c26a13d5b0c970f/" rel="bookmark">
			【网络安全协议】SSL/TLS、IPSec等网络安全协议的原理与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络安全协议 SSL/TLS、IPSec等网络安全协议的原理与应用 1. 引言 随着互联网的迅速发展，网络安全的重要性日益凸显。网络安全协议是保护数据传输安全的关键技术，通过加密、身份验证和数据完整性等手段，防止数据在传输过程中被窃取或篡改。本文将深入探讨常见的网络安全协议，包括SSL/TLS、IPSec等，详细解释其工作原理及在实际应用中的使用方法。
2. SSL/TLS协议 2.1 SSL/TLS的基本概念 SSL（Secure Sockets Layer）和TLS（Transport Layer Security）是用于保障网络通信安全的加密协议。TLS是SSL的继任者，主要用于在客户端和服务器之间建立安全连接，确保数据的保密性、完整性和身份验证。
2.2 SSL/TLS的工作原理 SSL/TLS协议通过以下步骤建立安全连接：
握手过程：
客户端向服务器发送支持的加密算法列表。服务器从列表中选择一种加密算法，并返回服务器证书。客户端验证服务器证书的真实性。客户端生成会话密钥并使用服务器的公钥加密该密钥，发送给服务器。服务器使用自己的私钥解密会话密钥。 数据加密传输：
双方使用会话密钥对数据进行加密和解密，确保数据在传输过程中的安全性。 2.3 SSL/TLS的应用 SSL/TLS广泛应用于以下场景：
Web浏览器安全：HTTPS（HTTP over SSL/TLS）用于加密Web流量，保护用户数据。电子邮件安全：通过STARTTLS命令，邮件客户端可以升级到加密连接，保障电子邮件的传输安全。虚拟专用网络（VPN）：基于SSL/TLS的VPN，如OpenVPN，提供加密隧道，用于安全的远程访问。 2.4 SSL/TLS的配置示例 在Apache服务器上启用SSL/TLS：
安装所需模块： sudo apt-get install openssl sudo a2enmod ssl 生成自签名证书： sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/ssl/private/apache-selfsigned.key -out /etc/ssl/certs/apache-selfsigned.crt 配置Apache使用SSL/TLS： 编辑/etc/apache2/sites-available/default-ssl.conf文件：
&lt;VirtualHost *:443&gt; ServerAdmin admin@example.com DocumentRoot /var/www/html SSLEngine on SSLCertificateFile /etc/ssl/certs/apache-selfsigned.crt SSLCertificateKeyFile /etc/ssl/private/apache-selfsigned.key &lt;/VirtualHost&gt; 启用SSL站点并重新启动Apache： sudo a2ensite default-ssl sudo systemctl restart apache2 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a86118f161a6989f0c26a13d5b0c970f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66700e8450b881d6334a5e5e486949a7/" rel="bookmark">
			深度学习系列（1) TensorFlow---Tensorflow学习路线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习 TensorFlow 是掌握深度学习和机器学习的关键一步。以下是一个详细的 TensorFlow 学习路线图，涵盖从基础到高级的知识点和实践，帮助你逐步掌握 TensorFlow 并应用于实际问题中。
1. 基础知识 1.1 了解 TensorFlow 概念：什么是 TensorFlow？它的用途和应用场景。安装：如何在本地机器上安装 TensorFlow，使用 pip 安装基本库。文档和教程：熟悉 TensorFlow 的官方文档和教程。 1.2 Python 编程基础 Python 基础：掌握 Python 编程语言，包括数据类型、控制结构、函数、类等。数据处理：了解 NumPy 和 pandas，用于数据预处理和操作。 2. TensorFlow 入门 2.1 TensorFlow 基础 张量（Tensors）：理解张量的概念，TensorFlow 中的张量操作。计算图（Computation Graph）：TensorFlow 的计算图和执行模型。基本操作：学习如何创建和操作张量，基本的数学运算。 2.2 TensorFlow 1.x vs. TensorFlow 2.x TensorFlow 1.x：了解 TensorFlow 1.x 的工作原理，计算图、会话（Session）。TensorFlow 2.x：学习 TensorFlow 2.x 的改进，Eager Execution、Keras API、简化的模型构建流程。 3. 核心 API 学习 3.1 Keras API Keras 简介：Keras 是 TensorFlow 2.x 中的高级 API，用于快速构建和训练深度学习模型。模型构建：学习如何使用 Sequential 模型和功能性 API 构建模型。层（Layers）：掌握常用的层（Dense, Convolutional, Recurrent等）。激活函数：了解常用的激活函数（ReLU, Sigmoid, Tanh等）。优化器：学习优化器的工作原理和使用（SGD, Adam, RMSprop等）。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66700e8450b881d6334a5e5e486949a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bfab5057529e155807e60c455a2fdca/" rel="bookmark">
			基于SpringBoot&#43;Vue&#43;MySQL的家具销售管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统背景 基于SpringBoot+Vue+MySQL的家具销售管理系统，其系统背景主要可以从以下几个方面进行阐述：
一、市场需求与技术发展 随着互联网技术的飞速发展和电子商务的普及，线上购物已成为人们日常生活中不可或缺的一部分。家具行业作为传统消费领域的重要分支，也逐渐向线上销售模式转型。这一转型不仅满足了消费者便捷购物的需求，也为家具企业提供了更广阔的市场空间。然而，传统的家具销售管理模式在应对大规模线上交易时显得力不从心，亟需一套高效、稳定、易用的管理系统来支撑。
二、系统开发的必要性 提升运营效率：通过系统化的管理，家具企业可以实现商品信息的快速录入、修改和查询，减少人工操作错误，提高整体运营效率。优化用户体验：系统提供友好的用户界面和便捷的购物流程，能够增强用户的购物体验，提高用户满意度和忠诚度。促进销售增长：通过数据分析功能，企业可以精准把握市场需求和用户偏好，制定针对性的销售策略，从而促进销售增长。 三、技术选型与优势 SpringBoot作为当前流行的Java Web开发框架，以其轻量级、快速开发和便捷部署等特点成为众多开发者的首选。Vue.js作为前端开发的热门框架，以其简洁化、轻量级和数据驱动等优势深受企业喜爱。MySQL数据库则因其稳定可靠、性能优越而被广泛应用于各类系统中。这三者的结合，为家具销售管理系统的开发提供了坚实的技术基础。
四、行业应用与前景 在国内外，家具销售管理系统的应用已经相当广泛。国外发达国家或地区的系统不仅功能完善，还融入了智能推荐、虚拟现实展示等先进技术手段，为用户提供更为丰富的购物体验。在国内，随着电商行业的迅猛发展，越来越多的家具企业开始重视线上销售渠道的建设，家具销售管理系统的市场需求不断增长。因此，基于SpringBoot+Vue+MySQL的家具销售管理系统的开发和应用具有广阔的市场前景。基于SpringBoot+Vue+MySQL的家具销售管理系统的开发是顺应市场需求和技术发展趋势的必然选择。该系统将为企业带来显著的运营效率提升、用户体验优化和销售增长促进等效益，推动家具行业向数字化、智能化方向迈进。
研究现状 SpringBoot、Vue和MySQL作为当前软件开发领域的主流技术，已被广泛应用于各类管理系统的开发中。家具销售管理系统作为电商领域的一个重要分支，也充分利用了这些技术的优势。SpringBoot以其快速开发、便捷部署和高度可配置的特点，成为后端开发的首选框架；Vue以其简洁化、轻量级和数据驱动的特性，为前端界面的开发提供了有力支持；MySQL数据库则以其稳定可靠、性能优越，保障了数据的存储和访问效率。现有的基于SpringBoot+Vue+MySQL的家具销售管理系统大多具备完善的功能模块，包括但不限于商品管理、订单管理、用户管理、库存管理等。这些模块通过系统化的设计和实现，为家具企业提供了全面的销售管理解决方案。例如，商品管理模块支持商品的添加、编辑、删除和查询，订单管理模块则能够跟踪订单状态、处理退换货请求等。为了提升用户体验，现有的家具销售管理系统在界面设计和交互流程上进行了优化。前端采用Vue框架开发的界面简洁明了，操作流畅，能够提供良好的用户体验。同时，系统还注重响应速度和稳定性，确保在高并发情况下仍能保持稳定的运行。在国内外，基于SpringBoot+Vue+MySQL的家具销售管理系统已经得到了广泛应用和推广。一些知名的家具电商平台和线下家具企业都采用了这种技术架构来构建自己的销售管理系统。这些系统的成功应用不仅提升了企业的管理效率和市场竞争力，也为整个家具行业的数字化转型提供了有力支持。部分先进的家具销售管理系统还集成了数据分析功能，通过收集和分析销售数据、用户行为等数据，为商家提供精准的决策支持。这些数据可以帮助商家了解市场需求、优化商品结构、制定销售策略等，从而提升整体销售业绩。
技术介绍 测试基于SpringBoot+Vue+MySQL的家具销售管理系统的目的，主要是为了验证系统是否满足设计要求，确保系统的稳定性、可靠性、易用性和性能表现均达到预期目标。通过全面的测试，可以及时发现并修复系统中的潜在问题，提升用户体验，保障系统在实际应用中的顺利运行。
测试目的 一、技术栈概述 该系统采用了当前流行的前后端分离架构，后端使用Java的SpringBoot框架，前端则采用Vue.js框架，数据库则选用了MySQL。这种技术组合既保证了系统的稳定性和高效性，又提升了开发效率和用户体验。
二、后端技术介绍 1. SpringBoot框架
简介：SpringBoot是一个基于Spring框架的开源项目，它简化了Spring应用的初始搭建以及开发过程。通过集成大量的框架，SpringBoot解决了依赖包的版本冲突和引用的不稳定性问题，使得开发者能够更专注于业务逻辑的实现。优势：快速开发、易于部署、简化配置、集成大量框架等。 2. MySQL数据库
简介：MySQL是一个流行的关系型数据库管理系统，它支持多线程、能够充分利用系统资源，提供高效的数据存储和访问服务。优势：数据独立性强、安全性高、支持多种连接方式、易于扩展等。 三、前端技术介绍 1. Vue.js框架
简介：Vue.js是一套用于构建用户界面的渐进式框架，它以其简洁化、轻量级、数据驱动和模块友好的特点深受企业和前端开发者的喜爱。Vue.js被设计为可以自底向上逐层应用，其核心库只关注视图层，易于上手且便于与第三方库或既有项目整合。优势：响应式数据绑定、组件化开发、易于学习、生态系统丰富等。 四、技术整合与优势 1. 前后端分离
实现方式：前端通过HTTP请求与后端进行通信，后端则负责处理业务逻辑和数据存储。这种架构使得前后端可以独立开发、测试和部署，提高了开发效率。优势：降低耦合度、提升开发效率、便于维护等。 2. 高效的数据处理
数据交互：前端通过Vue.js的双向数据绑定机制实现与用户的交互，并将数据通过HTTP请求发送给后端。后端接收到请求后，通过SpringBoot框架处理业务逻辑，并操作MySQL数据库进行数据的增删改查操作。性能优化：通过合理的数据库设计、索引优化、缓存策略等手段，提升系统的数据处理能力和响应速度。 3. 丰富的功能实现
功能模块：系统通常包括用户管理、商品管理、订单管理、支付管理等多个功能模块。每个模块都通过前后端的紧密协作实现具体的业务逻辑。用户体验：前端通过Vue.js的组件化开发方式，实现丰富的界面效果和交互体验；后端则通过SpringBoot框架提供稳定的数据支持和业务处理能力。 综上所述，基于SpringBoot+Vue+MySQL的家具销售管理系统通过采用先进的技术栈和合理的架构设计，实现了高效、稳定、易用的销售管理功能，为家具企业提供了有力的技术支持和解决方案。
系统展示 代码展示 package com.dao; import com.entity.DiscussxinlizixunshiEntity; import com.baomidou.mybatisplus.mapper.BaseMapper; import java.util.List; import com.baomidou.mybatisplus.mapper.Wrapper; import com.baomidou.mybatisplus.plugins.pagination.Pagination; import org.apache.ibatis.annotations.Param; import com.entity.vo.DiscussxinlizixunshiVO; import com.entity.view.DiscussxinlizixunshiView; public interface DiscussxinlizixunshiDao extends BaseMapper&lt;DiscussxinlizixunshiEntity&gt; { List&lt;DiscussxinlizixunshiVO&gt; selectListVO(@Param("ew") Wrapper&lt;DiscussxinlizixunshiEntity&gt; wrapper); DiscussxinlizixunshiVO selectVO(@Param("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bfab5057529e155807e60c455a2fdca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a83eef13a39a8aa65eb16d10e66a345f/" rel="bookmark">
			iOS UIColletionView实现header和footter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// ProfileViewController.m
// scxhgh
// Created by xmkjsoft on 2024/7/16.
#import "ProfileViewController.h"
@interface ProfileViewController () &lt;UICollectionViewDataSource, UICollectionViewDelegateFlowLayout&gt;
@property (nonatomic, strong) UICollectionView *collectionView; // 声明UICollectionView属性
@end
@implementation ProfileViewController
- (void)viewDidLoad {
[super viewDidLoad];
// 设置背景色
self.view.backgroundColor = [UIColor whiteColor];
// 创建并设置UICollectionView
[self setupCollectionView];
}
- (void)setupCollectionView {
UICollectionViewFlowLayout *layout = [[UICollectionViewFlowLayout alloc] init];
layout.itemSize = CGSizeMake(100, 100); // 设置每个cell的大小
layout.minimumLineSpacing = 10; // 设置行间距
layout.minimumInteritemSpacing = 10; // 设置列间距
layout.sectionInset = UIEdgeInsetsMake(10, 10, 10, 10); // 设置section的内边距
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a83eef13a39a8aa65eb16d10e66a345f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/7/">«</a>
	<span class="pagination__item pagination__item--current">8/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/9/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>