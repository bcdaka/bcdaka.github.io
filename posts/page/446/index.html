<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2835dc34d4b293d5e50a207ef169842e/" rel="bookmark">
			统计HBase表记录条数的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java 表的记录集个数_HBase统计表行数(RowCount)的四种方法-CSDN博客
一、hbase-shell的count命令
这是最简单直接的操作，但是执行效率非常低，适用于百万级以下的小表RowCount统计！
hbase&gt; count 'ns1:t1'
hbase&gt; count 't1'
hbase&gt; count 't1', INTERVAL =&gt; 100000
三、利用hbase.RowCounter包执行MR任务
这种方式效率非常高！利用了hbase jar中自带的统计行数的工具类！
通过 $HBASE_HOME/bin/hbase 命令执行：
[root@cdh1 ~]# hbase org.apache.hadoop.hbase.mapreduce.RowCounter 'sda_crm_calls20180102'
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3ff6d79947cbe7ab913b102da4e71d4/" rel="bookmark">
			深度学习：AIGC重塑金融大模型驱动金融变革
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：林建明 来源：IT阅读排行榜 本文摘编自《AIGC重塑金融：AI大模型驱动的金融变革与实践》，机械工业出版社出版 这是最好的时代，也是最坏的时代。尽管大模型技术在金融领域具有巨大的应用潜力，但其应用也面临不容忽视的风险和挑战。本文将深入研究大模型在金融领域的数据隐私和安全风险、模型可解释性和透明度、监管和合 规要求，梳理中国、美国、欧洲等地 AIGC 技术的应用规则，探索对应的风险管理和应对策略。
01 大模型在金融领域的 5 个典型应用场景 当前，金融科技已经从“立柱架梁”迈入了“积厚成势”新阶段，越来越多的金融机构积极使用数字技术来为金融血脉注入全新能量。人工智能技术正加速与金融产业深度融合，以 ChatGPT 为代表的大模型技术不断进化，为金融业带来深刻变革，驱动金融服务更加高效、便捷、有温度。
ChatGPT 拥有持续的多轮对话能力，并具备一定逻辑推理能力，在生成文章、生成代码、翻译等方面展现出令人惊叹的水平。ChatGPT 的问世，意味着人工智能从 1.0 时代迈入了 2.0 时代。ChatGPT 背后的 GPT 大模型技术是下一代 AI 技术竞争的核心，将重新定义包括金融在内的众多行业，重塑全球科技竞争格局。
金融行业属于信息密集型行业，是大模型技术的最佳应用场景之一。未来，具有通用能力的大模型将成为信息处理的基础设施，大幅降低中小银行应用人工智能技术的门槛。由于在数字资源、科技能力、业务场景等方面的天然劣势，中小银行与大银行相比，在数字化转型方面相对落后，且差距越拉越大，“智能化鸿沟”也越来越明显。在大模型时代，各类银行重新站在同一条起跑线上，都可以便捷地使用 AI 技术，插上一双数智化“翅膀”，曾经再“阳春白雪”的复杂数据，也能飞入“寻常人家”。
如果将大模型的能力放在金融行业中去处理原有的任务，会对很多工作产生颠覆性的影响。相比现有的 AI 技术，大模型技术在众多金融场景具有广泛的应用潜力和影响力。
金融风险管理。大模型技术可以用于构建更准确、更全面的风险模型， 帮助金融机构评估和管理市场风险、信用风险、操作风险等，提供更 精确的风险预测和决策支持，有助于金融机构制定有效的风险管理策略。
量化交易。大模型技术可以应用于量化交易策略的开发和执行。通过 分析海量的金融数据和市场信息，识别出潜在的交易机会和趋势，自 动执行交易策略并进行实时调整。这有助于提高交易效率，降低交易 成本，提升交易的稳定性，以及增加收益。
个性化投资建议。大模型技术可以根据个体投资者的偏好和风险承受 能力，生成个性化的投资建议和组合配置，辅助投资者做出更明智的 决策。
金融欺诈检测和预防。大模型技术可以应用于金融欺诈检测和预防。通过分析用户的交易数据、行为模式和历史记录，识别出潜在的欺诈行为和异常交易，提高金融机构对欺诈风险的识别和应对能力，保护 客户和金融系统的安全。
智能客户服务。大模型技术可以用于构建智能客户服务系统，通过提 供流畅的人机对话服务，提升客户满意度和忠诚度。
02 大模型在金融领域应用所面临的风险及其防范 自 2020 年 OpenAI 提出大语言模型的缩放法则（Scaling Law）以来，用 “大力出奇迹”的方式去做大模型仿佛成为“金科玉律”，“大炼丹”时代序幕 拉开，百亿、千亿参数规模的大模型比比皆是。量变引发质变，超大模型蕴 含着的涌现能力被发现，但在惊讶于这种神奇能力的同时，我们同样应该审 视其潜在风险。在斯坦福大学的学者们的眼里，大模型涌现的能力既是科学兴奋的源泉，也是意外后果的忧虑之源。换言之，如果不能引导大模型“向 善”，那么它随时可能伤及人类本身，带来不可估量的后果。
金融行业是数据密集型行业，涉及海量的金融数据和复杂的金融业务。大模型对于提高金融业务的自动化和智能化水平、提高风险控制和决策效率 具有重要意义，在生成书面报告、开展培训和投教、提升客户陪伴质量等应用场景中潜力巨大。目前，国内外金融机构已经纷纷开始探索将 GPT 等大语 言模型应用在金融领域的各个场景。
1. 大模型应用在金融领域的 5 个风险和挑战 尽管大模型技术在金融领域有着广阔的应用前景，但其稳定性、可靠性 和安全性有待提升，面临着不少风险和挑战。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3ff6d79947cbe7ab913b102da4e71d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5d1fa7e15b9f88c1907d88f60cb0c79/" rel="bookmark">
			【Flink 从 Kafka 读取数据报错】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Exception in thread "main" org.apache.flink.runtime.client.JobExecutionException: Job execution failed. at org.apache.flink.runtime.jobmaster.JobResult.toJobExecutionResult(JobResult.java:144) at org.apache.flink.runtime.minicluster.MiniClusterJobClient.lambda$getJobExecutionResult$3(MiniClusterJobClient.java:141) at java.util.concurrent.CompletableFuture.uniApply(CompletableFuture.java:602) at java.util.concurrent.CompletableFuture$UniApply.tryFire(CompletableFuture.java:577) at java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:474) at java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:1962) at org.apache.flink.runtime.rpc.akka.AkkaInvocationHandler.lambda$invokeRpc$1(AkkaInvocationHandler.java:267) at java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:760) at java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:736) at java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:474) at java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:1962) at org.apache.flink.util.concurrent.FutureUtils.doForward(FutureUtils.java:1300) at org.apache.flink.runtime.concurrent.akka.ClassLoadingUtils.lambda$null$1(ClassLoadingUtils.java:93) at org.apache.flink.runtime.concurrent.akka.ClassLoadingUtils.runWithContextClassLoader(ClassLoadingUtils.java:68) at org.apache.flink.runtime.concurrent.akka.ClassLoadingUtils.lambda$guardCompletionWithContextClassLoader$2(ClassLoadingUtils.java:92) at java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:760) at java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:736) at java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:474) at java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:1962) at org.apache.flink.runtime.concurrent.akka.AkkaFutureUtils$1.onComplete(AkkaFutureUtils.java:47) at akka.dispatch.OnComplete.internal(Future.scala:300) at akka.dispatch.OnComplete.internal(Future.scala:297) at akka.dispatch.japi$CallbackBridge.apply(Future.scala:224) at akka.dispatch.japi$CallbackBridge.apply(Future.scala:221) at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64) at org.apache.flink.runtime.concurrent.akka.AkkaFutureUtils$DirectExecutionContext.execute(AkkaFutureUtils.java:65) at scala.concurrent.impl.CallbackRunnable.executeWithValue(Promise.scala:72) at scala.concurrent.impl.Promise$DefaultPromise.$anonfun$tryComplete$1(Promise.scala:288) at scala.concurrent.impl.Promise$DefaultPromise.$anonfun$tryComplete$1$adapted(Promise.scala:288) at scala.concurrent.impl.Promise$DefaultPromise.tryComplete(Promise.scala:288) at akka.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5d1fa7e15b9f88c1907d88f60cb0c79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c145df1fb257fa2c24d73d923966228/" rel="bookmark">
			jdbc连SQL server，显示1433端口连接失败解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Exception in thread "main" com.microsoft.sqlserver.jdbc.SQLServerException: 通过端口 1433 连接到主机 localhost 的 TCP/IP 连接失败。错误:“connect timed out。请验证连接属性。确保 SQL Server 的实例正在主机上运行，且在此端口接受 TCP/IP 连接，还要确保防火墙没有阻止到此端口的 TCP 连接。”。 at com.microsoft.sqlserver.jdbc.SQLServerException.makeFromDriverError(SQLServerException.java:190) at com.microsoft.sqlserver.jdbc.SQLServerException.ConvertConnectExceptionToSQLServerException(SQLServerException.java:241) at com.microsoft.sqlserver.jdbc.SocketFinder.findSocket(IOBuffer.java:2243) at com.microsoft.sqlserver.jdbc.TDSChannel.open(IOBuffer.java:491) at com.microsoft.sqlserver.jdbc.SQLServerConnection.connectHelper(SQLServerConnection.java:1309) at com.microsoft.sqlserver.jdbc.SQLServerConnection.login(SQLServerConnection.java:991) at com.microsoft.sqlserver.jdbc.SQLServerConnection.connect(SQLServerConnection.java:827) at com.microsoft.sqlserver.jdbc.SQLServerDriver.connect(SQLServerDriver.java:1012) at java.sql.DriverManager.getConnection(DriverManager.java:664) at java.sql.DriverManager.getConnection(DriverManager.java:247) at SqlServerTest.main(SqlServerTest.java:18) 解决办法（注意：添加的是IPALL的tcp端口为1433：
找到SQL Server配置管理器，以管理员身份打开
点击网络配置
点击TCP/IP属性进行设置
启动TCP/IP
之后点击IP地址，将**IPALL**的tcp端口修改为1433，之后点击应用。
在服务部分，点击Sql Server重新启动即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/184a6e140f17bb893f15e903e81341e0/" rel="bookmark">
			AI助力程序员：如何利用最新技术提升开发效率和质量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、AI赋能程序员的实践应用 代码生成：AI技术可以通过自然语言处理和机器学习算法自动生成代码。例如，开发者可以输入一段描述性的文本，AI会根据文本生成相应的代码。这种技术可以减轻程序员的编码负担，提高开发效率。目前已经有一些工具和服务，如OpenAI的Codex，可以实现这一功能。
代码审查：AI可以辅助程序员进行代码审查，自动检测潜在的代码问题，如语法错误、逻辑错误、性能瓶颈等。此外，AI还可以根据项目的编码规范和最佳实践给出建议，帮助程序员提高代码质量。例如，DeepCode和GitHub的CodeQL等工具可以实现这一功能。
缺陷检测：AI可以通过机器学习算法自动检测代码中的缺陷，如内存泄漏、空指针异常等。这有助于程序员在早期发现问题，降低修复成本。例如，Facebook的Infer和Google的Error Prone等工具可以实现这一功能。
智能编程助手：AI可以作为智能编程助手，帮助程序员快速查找文档、解决编程问题、学习新技术等。例如，Kite和Tabnine等工具可以为程序员提供智能代码补全功能，提高编码速度。此外，一些AI-driven的问答平台，如Stack Overflow和Quora，也可以帮助程序员解决编程问题。
性能优化：AI可以通过分析代码的运行情况和性能数据，自动给出优化建议。例如，AI可以识别出性能瓶颈所在的代码段，给出相应的优化建议。这有助于程序员提高软件性能，提升用户体验。
二、具体案例：AI技术助力程序员工作 2.1 国外的一些工具 Github Copilot：这是GitHub和OpenAI合作开发的AI驱动的代码自动补全工具。它可以理解程序员正在编写的代码的上下文，并提供相关的代码片段建议，大大提高了编程效率。
DeepCode：这是一个AI驱动的代码审查工具，它可以在代码提交时自动检测出潜在的错误和漏洞。DeepCode通过机器学习算法分析大量的开源代码库，学习到了各种编程错误和漏洞的模式，从而能够在程序员编写代码时实时提供反馈。
Kite：这是一个AI驱动的编程助手，它可以提供智能代码补全功能，并且能够根据代码的上下文提供相关的API文档和用法示例。
Facebook Infer：这是Facebook开发的一个静态分析工具，它可以在代码编译时自动检测出各种潜在的错误和漏洞，如空指针引用、资源泄露等。
2.2 国内的一些工具 在中国国内，有很多好用的大模型应用，以下是一些例子：
百度文心一言：百度推出的基于飞桨深度学习平台和知识增强大模型技术的AI创作工具，可以帮助用户快速生成包括古诗、词、现代诗、歌词、对联、广告语等多种文本内容。
讯飞星火认知大模型：科大讯飞推出的新一代认知智能大模型，具备跨领域的知识和语言理解能力，可以实现智能问答、文本生成、语言翻译等功能。
腾讯混元助手：腾讯推出的基于多模态的大规模预训练模型，具备图文跨模态理解与生成、实时对话、智能问答、代码生成等功能，可以为用户提供便捷的服务。
华为盘古大模型：华为推出的面向行业的大模型系列，包括NLP大模型、CV大模型、科学计算大模型等，可以应用于智能搜索、智能推荐、智能翻译、智能语音交互等领域。
阿里巴巴通义千问：阿里巴巴推出的超大规模的语言模型，功能包括多轮对话、文案创作、逻辑推理、多模态理解、多语言支持。跟ChatGPT一样，它能够跟人类进行多轮的交互，也融入了多模态的知识理解，且有文案创作能力，能够续写小说，编写邮件等。
商汤日日新大模型：商汤科技推出的涵盖自然语言处理、内容生成、自动化数据标注等多种大模型及能力，可以为用户提供了多种高效的AI应用。
科大讯飞星火的认知智能大模型：科大讯飞在人工智能领域深耕20余年，在深度学习算法、大模型技术、行业大数据等方面有深厚的积累。星火的认知智能大模型在智慧教育、智慧办公、智慧医疗等领域都有广泛应用。
昆仑万维天工：昆仑万维发布了千亿级大语言模型“天工”，并有文案创作、知识问答、代码编程等多种功能，满足你的多样需求。
此外，还有很多其他好用的大模型应用，如网易的“玉言”、复旦的“MOSS”等。这些应用在不同领域有着广泛的应用前景，可以为用户提供便捷、高效的服务。
三、AI是否会替代程序员 AI技术在未来可能会改变程序员的工作方式，但不太可能完全替代程序员。
编程需要创造力：程序员在开发软件时需要具备创造力，以便设计出符合用户需求和业务场景的解决方案。尽管AI可以在一定程度上辅助程序员进行重复性工作，但它很难完全模拟人类的创造力和想象力。
人际沟通：程序员的工作不仅仅是编写代码，还需要与团队成员、产品经理、设计师等进行沟通，以便更好地理解需求并进行协作。AI在理解人类情感和沟通方面仍然有很大的局限性。
适应新技术：软件开发领域不断涌现新技术和新方法，程序员需要不断学习和适应。尽管AI可以快速学习和应用新技术，但它仍然需要人类程序员来引导和教育。
复杂问题解决：在软件开发过程中，程序员需要解决各种复杂问题。虽然AI可以辅助程序员进行一些任务，但在处理复杂问题时，它很难替代人类程序员的经验和专业知识。
道德和法律责任：软件开发涉及到道德和法律责任，例如数据隐私、安全和合规性等。AI在这方面的判断力有限，因此需要人类程序员来确保软件符合道德和法律规定。
综上所述，AI可能会在一定程度上改变程序员的工作方式，例如自动化一些重复性任务，辅助程序员进行代码审查和优化等。然而，AI很难完全替代程序员，因为程序员在创造力、人际沟通、适应新技术、解决复杂问题以及承担道德和法律责任等方面具有不可替代的优势。
四、总结 随着AI技术的发展，越来越多的工具和服务可以帮助程序员提高工作效率和代码质量。通过利用这些最新的AI技术，程序员可以专注于解决更复杂的问题，创造更有价值的产品。然而，AI并不能完全替代程序员，程序员在创造力、人际沟通、适应新技术、解决复杂问题等方面仍然具有不可替代的优势。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3beca0ff6add197dbe564d9dfb73d634/" rel="bookmark">
			MySQL：replace函数的几种实用场景，大厂面试必备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		REPLACE语法
操作实例
使用场景1 – (Query语句)： 使用场景2 – (update语句)：
使用场景3 – (插入或替换：REPLACE INTO)
附、一张有故事的照片（五）
REPLACE语法
========================================================================
REPLACE(String,from_str,to_str)
即：将String中所有出现的from_str替换为to_str，这里的from_str不支持正则匹配。
操作实例
===================================================================
测试表数据如下：
mysql&gt; select * from LOL;
±—±---------------±-------------±------+
| id | hero_title | hero_name | price |
±—±---------------±-------------±------+
| 1 | 刀锋之影 | 泰隆 | 6300 |
| 2 | 迅捷斥候 | 提莫 | 6300 |
| 3 | 光辉女郎AA | 拉克丝 | 1350 |
| 4 | 发条A魔灵A | 奥莉安娜 | 6300 |
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3beca0ff6add197dbe564d9dfb73d634/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9af32172838df024ba398c104545ad91/" rel="bookmark">
			【SD教程- ! 清晰易懂 ! 】1 本地部署Stable Diffusion绘图环境【超简单】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		废话不多说直接上内容 附上SD官网：https://stability.ai/
1 部署SD环境分类 我们知道SD需要对电脑配置有一定的要求，如果自己的电脑配置够用，就可以直接拿自己的电脑使用SD，如果电脑配置不够，需要在花钱云端部署（类型买一个好一些的GPU使用）。
所以部署SD绘图环境有两种方式：
1.1云端部署： 买其他平台的GPU使用，不对电脑硬件有配置要求，费用不高。
1.2 本地部署： 需要在个人电脑上进行安装和配置，因此会依赖于电脑的硬件配置。
2 如何进行本地部署 再进行本地部署之前，需要先检查一下自己的电脑配置是否符合要求。
2.1 是否符合配置要求 我使用的Windows系统，我们知道Windows系统的显卡通常为NVIDIA（N卡）和AMD（A卡）。
所以个人电脑需要满足以下要求：
NVIDIA卡运行内存8GB+显存4GB+
2.2 安装SD 2.2.1 先下载需要用到的软件包与资源 链接：https://pan.baidu.com/s/1t3EjwhZuhyNr5bAS7t4rzA?pwd=22y9
提取码：22y9
2.2.2 解压与安装 到此已经安装结束
2.2.3 打开SD 双击进行打开，会先安装一些文件，安装后需要重启电脑
重启之后再次找到上图的“A绘世启动器”双击即可
这个界面稍微等待，是进入SD界面的准备工作
以上就是打开了SD绘图界面的样子
3 总结 大家如果有相关的问题可以在评论区留言，看到会进行回复！
您的收藏、关注、点赞是我持续更新的动力！
立志做清晰易懂不废话的内容！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e66faad0e99773e0e9558c2a8438c80/" rel="bookmark">
			每日一题（相交链表 ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎大家来我们主页进行指导
LaNzikinh-CSDN博客
160. 相交链表 - 力扣（LeetCode）
给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。
图示两个链表在节点 c1 开始相交：
题目数据 保证 整个链式结构中不存在环。
注意，函数返回结果后，链表必须 保持其原始结构 。
自定义评测：
评测系统 的输入如下（你设计的程序 不适用 此输入）：
intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0listA - 第一个链表listB - 第二个链表skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数 评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。
首先做这个题目有两个核心的关键就是，1.你要判断它是不是相交的。2.它的交点 思路一：暴力求解 依次去A链表中的每个节点跟B链表中的所有节点比较，如果有地址相同的节点，就是相交，第一个相同的就是交点
时间复杂度为O（N^2），非常麻烦，这里就不多说了，我们直接来说思路二
思路二：长度差法 核心：尾结点相同，就是相交否则就不相交，长的链表先走长度差步，再同时走，第一个相同的就是交点 2.1计算长度 先保存两个头结点用来比较长度，因为我遍历完了两个链表，所以把是不是相交一起判断了
//先保存两个头结点用来比较长度 struct ListNode* tailA = headA; struct ListNode* tailB = headB; //计算A的长度 int lenA = 1; while (tailA-&gt;next !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e66faad0e99773e0e9558c2a8438c80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4de41ef5d53e6b665c80c1d6911eefa1/" rel="bookmark">
			Unity中Newtonsoft.Json的使用（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.介绍
1.1 什么是Json
1.2 Json和其他数据序列化方案对比
1.3 为什么选择Newtonsoft.Json
2.安装Newtonsoft.json
2.1 网上其他安装方式
2.2 Unity下载匹配的版本
3.Newtonsoft.Json的使用
3.1 写一个Json工具类进行序列化和反序列化
3.2 进行测试
简单小结
1.介绍 1.1 什么是Json Json全名为“JavaScript Object Notation”，直接翻译过来就是“JavaScript 对象表示法”。
Json最初由道格拉斯·克罗克福德(Douglas Crockford)在2001年提出,并在RFC 4627中正式定义。它的设计之初是提供一种易于阅读和编写的数据交换格式,同时也易于机器解析和生成，用来作为XML的一种轻量级替代。
也就是说，Json并不属于一种编程语言，而是一种轻量级的数据交换格式。它的语法是基于JavaScript的，学习JavaScript的同学可以无缝使用，且由于语法的简单性，学习其他编程语言的同学也可以非常容易上手。
1.2 Json和其他数据序列化方案对比 除了Json，我们知道还有XML、Protobuf、二进制等序列化方式，接下来我们就来进行一下平行对比
序列化文件大小可读性跨语言跨平台性能易用性适用场景XML大高，包含所有层级结构和信息支持支持低复杂，像Excel一样逐节点查询配置文件、定义协议等Json较小较高，所有数据以键值对形式储存支持支持较高简单轻量级的数据存储和网络传输通信Protobuf小低，不包含字段名等信息，且需要适用专门的工具进行反序列化支持支持高较复杂，需要自己定义Proto数据结构，但序列化反序列化过程简单高性能，低带宽的网络传输通信二进制极小低，全是0和1二进制字节不支持不支持极高简单有加密需求的大规模网络传输通信，数据存储等 1.3 为什么选择Newtonsoft.Json Newtonsoft.Json（Json.NET）是.Net生态中最流行，使用最广的JSON库。Unity中常用的其他JSON工具，如System.Json、LitJson还有Unity自带的Jsonutility，或多或少都存在一切缺陷，比如不支持复杂数据结构类型，移动端平台不支持等。
相比其他的JSON工具，Newtonsoft.Json支持绝大多数平台。有着最丰富的功能和API，不夸张的说，可以支持所有的数据结构类型，包括你自定义的数据结构类型，且序列化反序列化过程可定制。
与之相对的，Newtonsoft.Json的包体也会稍大，如果对包体的大小不追求极限的话，可以说Newtonsoft.Json就是你在Unity开发中使用Json的不二之选。
2.安装Newtonsoft.json 首先在你的Unity中建个脚本，using一下Newtonsoft.Json的命名空间，如果可以引用，表示你的Unity版本已经自带了Newtonsoft.Json，请直接跳到第三部分Newtonsoft.json的使用中，如果不行，请继续向下看
using Newtonsoft.Json; 2.1 网上其他安装方式 网上很多教程都教你从Github下载.NET的Newtonsoft.Json，或者使用VS的Nuget包管理器进行安装，这些教程大家都可以在网上找到。
但是Newtonsoft.Json有着非常多的版本，支持不同的.NET环境和不同平台，且大部分都是不带AOT库的。你下载的库可能在Unity编译器和Windows下能正常使用，但是在移动端和主机端会遇到序列化失败的问题。
笔者这就教你一招取巧的方法，直接让Unity为我们下载好匹配的版本
2.2 Unity下载匹配的版本 找到你项目根路径下的Packages目录，Packages和你的Assets文件夹是同级的
打开manifest.json，找到com.unity.collab-proxy，可以看到现在的版本号是2.0.1
我们先去看一下刚才Packages目录下的packages-lock.json，可以看到现在的版本是2.0.1，dependencies依赖项是空的
接下来我们返回manifest.json，将com.unity.collab-proxy的版本号修改为1.15.4，像这样
返回Unity，就会弹出窗口重新生成packages了
这时候我们再看下packages-lock.json文件，可以看到版本号已经变为1.15.4了，且依赖里面多了Newtonsoft.Json
去Library中看一下，可以看到已经下载到包体了，且自带AOT库，支持所有的平台
这时候我们就可以在Unity中使用Newtonsoft.Json了
3.Newtonsoft.Json的使用 3.1 写一个Json工具类进行序列化和反序列化 using Newtonsoft.Json; //记得引用命名空间 public class JsonMgr { public static string Serialize&lt;T&gt;(T t) { return JsonConvert.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4de41ef5d53e6b665c80c1d6911eefa1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a2ef2c424ca941de4a8d4876a515b68/" rel="bookmark">
			Mac OS下Docker的安装与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mac OS上Docker Desktop 安装与配置 Docker Desktop 下载开发人员的Docker日常如何正确修改Docker的配置Mac OS下Docker Desktop的默认配置Docker Desktop修改Disk Image Location无效怎样才是正确的姿势？还有哪些坑 Docker Desktop 下载 Docker 的安装文件可以通常docker.com官方网站直接下载，官方提供了不同操作系统版本的Docker安装文件。点击下边的地址可进入下载页面
链接: Download Docker Desktop
如上图所示，Docker 提供了4个版本的Docker Desktop, 其中Mac版本需要大家根据自己的MacBook的芯片进行选择。
开发人员的Docker日常 本人是一名服务端开发人员，Docker在开发的日常工作中扮演了重要的角色，如果你还没有在开发中使用过Docker，强列建议大家使用，因为在云原生应用时代，容器是大家必须要学会使用的一个工具。
试想一下，在容器还未出现的年代，如果我们想在自己的Mac电脑上安装某个中间件组件，比如Redis，那么我们通常使用Mac下比较有名的安装工具Homebrew 来进行安装，而Homebrew也是需要安装的。 /bin/zsh -c "$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)" brew install redis 如果你所负责的项目中，有些项目使用Mysql 5.7, 而有一些使用Mysql 8.0，你要怎么在这两个版本间切换？有时候想在项目中引用某一个开源组件，比如EMQX。想在本地搭建一个Nexus 私服想构建自己的容器应用 以上就是一些常见的Docker使用场景，我们可以使用Docker来快速且轻松的解决，我们只需要安装好Docker Desktop后，执行Docker pull 命令下载相应的镜像，然后执行docker run 命启来启动相应容器就可以了。
以mysql 为例,如果想下载最新版本的mysql，使用如下命令
docker pull mysql 如果想下载某一个版本的mysql，使用如下命令
docker pull mysql:5.7 关键在于，可以同时运行两个版本的mysql 服务，使用docker大大的简化了不同版本需要同时存在的问题。
如何正确修改Docker的配置 Mac OS下Docker Desktop的默认配置 通常来讲安装好后，也不需要进行什么配置，直接启动Docker Desktop 即可。但本人的MacBook 碰盘空间有限，而且在安装OS时，还特意将磁盘划分为了系统盘和数据盘，其中给到系统盘的空间较少。默认情况下，如果不在修改配置，我们所下载的镜像，以及为容器创建的持久化卷都是保存在系统盘底下，如图所示：
大家可以在安装完DockerDesktop后去检查一下这个目录：
~/Library/Containers/com.docker.docker/Data/vms/0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a2ef2c424ca941de4a8d4876a515b68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fa6576773409e2a7b4fcdbb89baffbd/" rel="bookmark">
			Docker搭建hadoop和spark集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker搭建hadoop和spark集群 本次集群的配置如下
Docker 25.0.3JDK 1.8Hadoop 3.1.2Hive 3.1.2mysql 8.0.1mysql-connector-java-8.0.1.jarhive_jdbc_2.5.15.1040 拉取docker镜像，初始化hadoop集群 拉取docker镜像,该镜像为ubuntu:22.04,已经安装好了hadoop docker pull registry.cn-hangzhou.aliyuncs.com/hadoop_test/hadoop_base 使用docker images可以查看已经拉取的镜像的列表 docker images 建立使用桥接模式的docker子网，一般来说下载完docker会在宿主机虚拟出一个172.17.0.0/16的子网出来，这里我们使用桥接模式创建了一个172.19.0.0/16的子网出来 docker network create --driver=bridge --subnet=172.19.0.0/16 hadoop 使用拉取的镜像，启动三个容器，分别是Master,Slave1,Slave2作为集群的三个节点 docker run -it --network hadoop --ulimit nofile=65535 -h Slave1 --name Slave1 registry.cn-hangzhou.aliyuncs.com/hadoop_test/hadoop_base bash docker run -it --network hadoop --ulimit nofile=65535 -h Slave2 --name Slave2 registry.cn-hangzhou.aliyuncs.com/hadoop_test/hadoop_base bash docker run -it --network hadoop --ulimit nofile=100000 -h Master --name Master -p 9870:9870 -p 8088:8088 -p 10000:10000 registry.cn-hangzhou.aliyuncs.com/hadoop_test/hadoop_base bash 使用dokcer ps -a查看所用容器的状态 docker ps -a 可以使用以下命令启动容器 docker start Master Slave1 Slave2 使用dokcer attach命令进入容器的bash docker attach Master #Slave1 or Slave2 注意以下命令使用sudo是在非root用户下才需如此,默认是root用户,不需要使用sudo
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fa6576773409e2a7b4fcdbb89baffbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49df11dd80fab9f8588047412f17783c/" rel="bookmark">
			vsCode 刷 leetcode 使用 Cookie 登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 安装插件 打开 vsCode，选择扩展，搜索 leetcode，选择第一个，带有中文'力扣'字样，安装后重启
2. 切换终端 插件安装成功之后，侧边栏选择 leetcode 菜单，切换终端，选择中文版本，切换成功后，会显示一个打勾，图示笔者已切换成中文版本
3. 登录 选择小球旁边的有箭头的小门，选择cookie登录，图示笔者已登录 4. 输入 cookie 按提示输入用户名或邮箱，Enter 键后输入 cookie 就行了
5. 如何找到对应的 cookie 呢？ 进入已经登录了的网页版 Leetcode 页面，按 F12
依次点击网络（Network）、选择 FetchXHR，按F5刷新，出现下面的页面（注意，笔者这里是中文版本）
找到 graphql/ 请求（可能多个，随便选择一个就行了），右边 Headers 下方主要有三个部分，分别是常规（General）、响应标头(Response Headers)、请求标头(Request Headers)，下划找到到请求标头(Request Headers)的 Cookie，复制 Cookie 的值 粘贴 到 vscode 就可以登录了
6. 显示 leetcode 题目 登录成功之后，点击面板上的刷新按钮，即可显示 leetcode 题目​​​​​​​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c2a6c657f04435573d1f079a8fedb3d/" rel="bookmark">
			Python 人工智能实战|产生式规则推理系统：动物识别系统、智能客服系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、动物识别系统 1.1：前言 产生式系统是基于产生式规则的推理系统，它以产生式规则为基础，利用规则匹配的推理机制来进行推断和解决问题。下图是产生式系统的组成，请从“动物识别系统”程序代码中分别找出规则库、综合数据库和推理机部分，并分析系统实现流程，以及三个部分的所使用的数据存储结构和基本语法。
1.2：核心思路 如何保存规则-&gt;规则库： 使用feature列表存储特征，rule数组表示即将待匹配的规则前提（根据feature列表中特征相应的序号）如何存储用户输入&amp;中间结果-&gt;综合数据库： 以一个数组/列表变量存储用户输入的相应特征以及推理过程产生的中间前提匹配流程-&gt;推理机： 将综合数据库中的特征信息和rule规则前提依次进行匹配（注意：其实就是前提匹配），并且将得到的中间结论添加到综合数据库，依次完规则匹配，得到最终结果。
1.3：代码实现 # -*- coding: utf-8 -*- import sys # 存储规则中所有的feature features = ["", "有奶", "有毛发", "有羽毛", "会飞", "会下蛋", \ "吃肉", "有犬齿", "有爪","眼盯前方", "有蹄", "嚼反刍",\ "黄褐色", "身上有暗斑点", "身上有黑色条纹", "有长脖子", \ "有长腿", "不会飞", "会游泳", "有黑白二色", "善飞",\ "哺乳动物", "鸟", "食肉动物", "蹄类动物", "金钱豹", "虎",\ "长颈鹿", "斑马", "鸵鸟", "企鹅", "信天翁"] print('以下是一些动物的特征：') print('\n') i = 1 while i &lt; len(features): print('%d' %i +'.'+ features[i]+ ' ', end='') i = i+1 if i % 4 == 1: print('\n') print('\n') answer = input('请选择动物的特征编号，用英文逗号分开，回车结束输入：') # 接收到的answer是一个字符串 try: answer = list(answer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c2a6c657f04435573d1f079a8fedb3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e083a45988fe3023d9114ebf4330da8/" rel="bookmark">
			【合合TextIn】AI构建新质生产力，合合信息Embedding模型助力专业知识应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、合合信息acge模型获MTEB中文榜单第一
二、MTEB与C-MTEB
三、Embedding模型的意义
四、合合信息acge模型
（一）acge模型特点
（二）acge模型功能
（三）acge模型优势
五、公司介绍
一、合合信息acge模型获MTEB中文榜单第一 现阶段，大语言模型的飞速发展吸引着社会各界的目光，背后支撑大型语言模型应用落地的Embedding模型也成为业内关注的焦点。近期，合合信息发布了文本向量化模型acge_text_embedding（简称“acge模型”），获得MTEB中文榜单（C-MTEB）第一的成绩。
图1：C-MTEB榜单结果
二、MTEB与C-MTEB MTEB（Massive Text Embedding Benchmark）是衡量文本嵌入模型（Embedding模型）的评估指标的合集，是目前业内评测文本向量模型性能的重要参考。对应的C-MTEB则是专门针对中文文本向量的评测基准。
C-MTEB被公认为是目前业界最全面、最权威的中文语义向量评测基准之一，涵盖了分类、聚类、检索、排序、文本相似度、STS等6个经典任务，共计35个数据集，为深度测试中文语义向量的全面性和可靠性提供了可靠的实验平台。
三、Embedding模型的意义 互联网时代中，随着信息量急剧膨胀，人们接触信息的渠道不断拓展，大量无关的信息已成为信息检索的干扰项。Embedding模型通过理解查询的深层含义和上下文，能够显著提高搜索和问答的质量、效率和准确性，让搜索和问答引擎不再只是匹配文字，而是可以真正理解人的意图。
Embedding模型能够将单词、句子或图像特征等高维的离散数据转换为低维的连续向量，捕捉到数据的语义特征和关系，被广泛应用于搜索、推荐、问答、检索增强生成、数据挖掘等领域。
“假设你需要了解如何在家中自制咖啡，可能会在搜索引擎中输入‘家庭咖啡制作方法’。如果没有Embedding模型，传统的引擎会简单地匹配包含关键词的文章，提供一些表面相关的内容而非实用的指南。”团队成员提到，借助Embedding模型，引擎便能更准确地理解用户意图，从而提供包括但不限于选择咖啡豆、磨豆技巧、不同的冲泡方法等更专业的内容。”
图2：embedding模型原理示意图
四、合合信息acge模型 Embedding模型在当前大模型实际落地应用过程中扮演着至关重要的角色。为了更好地发挥大模型在应用过程中的价值，合合信息技术团队重点从数据集、训练策略等方面针对Embedding模型进行了优化，打造了acge模型。技术人员构造了大量的数据集，保证训练的质量与场景覆盖面；在模型训练方面，团队也引入多种有效的模型调优技术。
（一）acge模型特点 据合合信息技术团队成员介绍，相比于传统的预训练或微调垂直领域模型，acge模型支持在不同场景下构建通用分类模型、提升长文档信息抽取精度，且应用成本相对较低，可帮助大模型在多个行业中快速创造价值，推动科技创新和产业升级，为构建新质生产力提供强有力的技术支持。
（二）acge模型功能 具体实践上，为做好不同任务的针对性学习，团队使用策略学习训练方式，显著提升了检索、聚类、排序等任务上的性能；引入持续学习训练方式，克服了神经网络存在灾难性遗忘的问题，使模型训练迭代能够达到相对优秀的收敛空间；运用MRL技术，实现一次训练，获取不同维度的表征。
（三）acge模型优势 与目前C-MTEB榜单上排名前五的开源模型相比，合合信息本次发布的acge模型较小，占用资源少；模型输入文本长度为1024，满足绝大部分场景的需求。此外，acge模型还支持可变输出维度，让企业能够根据具体场景去合理分配资源。
五、公司介绍 合合信息是一家人工智能及大数据科技企业，基于自主研发的领先的智能文字识别及商业大数据核心技术，为全球C端用户和多元行业B端客户提供数字化、智能化的产品及服务。公开资料显示，公司的C端产品覆盖了全球百余个国家和地区的亿级用户，B端服务覆盖了近30个行业的企业客户。《财富》杂志2022年发布的世界500强公司名单中，公司客户已覆盖超过125家。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b38b64fa6db532b4e50af781e370430f/" rel="bookmark">
			MySQL 到 Kafka 实时数据同步实操分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：很多 DBA 同学经常会遇到要从一个数据库实时同步到另一个数据库的问题，同构数据还相对容易，遇上异构数据、表多、数据量大等情况就难以同步。我自己亲测了一种方式，可以非常方便地完成 MySQL 数据实时同步到 Kafka ，跟大家分享一下，希望对你有帮助。
本次 MySQL 数据实时同步到 Kafka 大概只花了几分钟就完成。使用的工具是 Tapdata Cloud ，这个工具是永久免费的。
MySQL 到 Kafka 实时数据同步实操分享 第一步：配置MySQL 连接 第二步：配置 Kafka 连接
第三步：选择同步模式-全量/增量/全+增
第四步：进行数据校验
其他数据库的同步操作
第一步：配置MySQL 连接
1.点击 Tapdata Cloud 操作后台左侧菜单栏的【连接管理】，然后点击右侧区域【连接列表】右上角的【创建连接】按钮，打开连接类型选择页面，然后选择MySQL
2.在打开的连接信息配置页面依次输入需要的配置信息
【连 接 名 称】：设置连接的名称，多个连接的名称不能重复
【数据库地址】：数据库 IP / Host
【端 口】：数据库端口
【数据库名称】：tapdata 数据库连接是以一个 db 为一个数据源。这里的 db 是指一个数据库实例中的 database，而不是一个 mysql 实例。
【账 号】：可以访问数据库的账号
【密 码】：数据库账号对应的密码
【时 间 时 区】：默认使用该数据库的时区；若指定时区，则使用指定后的时区设置
3.测试连接，提示测试通过
4.测试通过后保存连接即可。
第二步：配置 Kafka 连接
1.同第一步操作，点击左侧菜单栏的【连接管理】，然后点击右侧区域【连接列表】右上角的【创建连接】按钮，打开连接类型选择页面，然后选择 Kafka
2.在打开的连接信息配置页面依次输入需要的配置信息，配置完成后测试连接保存即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b38b64fa6db532b4e50af781e370430f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1034a2ee22df36ecf82d2a68b14fa88/" rel="bookmark">
			前端自定义导出excel内容（xlsx插件用法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端自定义导出excel内容（xlsx用法） 1.下载安装xlsx插件2.新建xlsx.js文件，放在utils文件夹下3.页面中使用 1.下载安装xlsx插件 npm install xlsx -D
2.新建xlsx.js文件，放在utils文件夹下 // 下载excel功能 import XLSX from 'xlsx' /** * @param dataList 表格数据内容 array * @param fileName 文件标题。必须以 .xlsx结尾 */ export const downloadXlsx = (dataList, fileName) =&gt; { const stringToBuff = str =&gt; { let buf = new ArrayBuffer(str.length) let view = new Uint8Array(buf) for (let i = 0; i !== str.length; ++i) { view[i] = str.charCodeAt(i) &amp; 0xff } return buf }; // 创建表格 let workbook = XLSX.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1034a2ee22df36ecf82d2a68b14fa88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c207c6079ff6a08220775f3dafb9ed6/" rel="bookmark">
			JavaScript 入门指南（三）BOM 对象和 DOM 对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BOM 对象 BOM 简介 BOM（browser Object Model）即浏览器对象模型BOM 由一系列对象组成，是访问、控制、修改浏览器的属性的方法BOM 没有统一的标准（每种客户端都可以自定标准）。BOM 的顶层是 window 对象 window 对象 window 对象表示浏览器中打开的窗口。
使用 window 对象中的属性和方法，可以省略对象名，直接写方法名和对象名
属性：
location ：当前 URL 的信息history ：客户访问过的 URL 的信息screen ：客户端的屏幕信息navigator ：浏览器基本信息document ：文档对象 函数：
弹框
// 提示框（显示带有一段消息和一个确认按钮的警告框） alert(提示信息); // 确认框（显示带有一段消息以及确认按钮和取消按钮的对话框）。点击确定，返回true；点击取消，返回false confirm(提示信息); // 输入框（显示可提示用户输入的对话框）。点击确定，返回输入的内容；点击取消，返回null prompt(提示信息); 浏览器窗口
// 打开一个新的浏览器窗口或查找一个已命名的窗口 open(网址) // 关闭浏览器窗口 close() 定时器
// 执行一次的定时器 setTimeout(函数, 毫秒值); // 反复执行的定时器 setInterval(函数, 毫秒值); // 参数： // 函数：定义一个有名函数，传递函数名字，或者使用匿名函数 // 毫秒值：设置定时器的时间，在指定的时间结束之后，会执行传递的函数 // 返回值：返回的是定时器的 id 值，可以用于取消定时器使用 // 取消执行一次的定时器 clearTimeout(定时器的id值); // 取消反复执行的定时器 clearInterval(定时器的id值); 示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c207c6079ff6a08220775f3dafb9ed6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb406c04b5eca1b72b372e2f10e189e3/" rel="bookmark">
			【Java初阶（七）】接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		❣博主主页: 33的博客❣
▶文章专栏分类: Java从入门到精通◀
🚚我的代码仓库: 33的代码仓库🚚
目录 1.前言2.接口2.1语法规则2.2接口使用2.3接口特性2.4实现多个接口2.5接口使用实例2.6Clonable接口和深拷贝 3.Object类3.1对象比较equals方法3.2hashcode方法 4.总结 1.前言 在现实生活中，接口的例子比比皆是，比如：笔记本上的USB口，电源插座等,在Java中也有接口，这篇文章我们将进行接口的学习。
本章重点
接口的概念，接口的语法规则，接口特性，实现接口，接口间的继承，抽象类和接口的区别，object类
2.接口 接口就是公共的行为规范标准，大家在实现时，只要符合规范标准，就可以通用。在Java中，接口可以看成是：多个类的公共规范，是一种引用数据类型。
2.1语法规则 接口的定义格式与定义类的格式基本相同，将class关键字换成interface 关键字，就定义了一个接口。
public interface 接口名称{ //成员变量 public static final int a;//public static final 可以不写，这是默认的 //抽象方法 public abstract void method1();//public abstrac 可以不写，这是默认的 } 提示
创建接口时，接口命名一般以大写字母I开头
2.2接口使用 接口不能直接使用，必须要有一个"实现类"来"实现"该接口，实现接口中的所有抽象方法。
public class 类名称 implements 接口名称{ // ... } 例如：
请实现笔记本电脑使用USB鼠标、USB键盘的例子
USB接口：包含打开设备、关闭设备功能笔记本类：包含开机功能、关机功能、使用USB设备功能鼠标类：实现USB接口，并具备点击功能键盘类：实现USB接口，并具备输入功能 //USB接口 public interface USB { void openDevice(); void closeDevice(); } //Mouse public class Mouse implements USB{ @Override public void openDevice() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb406c04b5eca1b72b372e2f10e189e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a793c4bf53075b3e212cd6e586aefa0/" rel="bookmark">
			30天拿下Rust之unsafe代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 在Rust语言的设计哲学中，"安全优先" 是其核心原则之一。然而，在追求极致性能或者与底层硬件进行交互等特定场景下，Rust提供了unsafe关键字。unsafe代码允许开发者暂时脱离Rust的安全限制，直接操作内存和执行低级操作。虽然unsafe代码在某些情况下是必要的，但使用它时必须格外小心，以避免引入难以调试的内存错误。
什么是unsafe代码 在Rust中，unsafe关键字用于标记那些可能破坏Rust的内存安全保证的代码块，使用unsafe关键字编写的代码块或函数被称为unsafe代码。unsafe代码允许程序员执行诸如裸指针操作、类型转换和直接内存访问等低级别操作。由于这些操作可能导致未定义行为或内存安全漏洞，Rust编译器不会对它们进行常规的安全性检查。
unsafe代码主要用于以下三个场景。
性能优化：在某些性能关键的应用中，程序员可能会选择使用unsafe代码来绕过Rust的一些安全检查，以获得更高的性能。
底层系统编程：在操作系统开发、设备驱动或嵌入式系统编程中，可能需要直接操作硬件或使用特定的内存布局，这时就需要使用unsafe代码。
与C语言库交互：当使用Rust调用C语言编写的库时，可能需要执行一些不安全的操作来正确地管理内存和调用约定。
在Rust中，unsafe代码的使用主要涉及以下三个方面：使用裸指针、使用外部函数接口、实现不安全Trait，下面分别进行介绍。
使用裸指针 在Rust中，裸指针是一种可以绕过Rust的常规所有权和借用检查机制的低级工具。它允许程序员直接操作内存地址，从而进行更为底层和灵活的操作。然而，正因为裸指针绕过了Rust的内存安全保证，使用时必须格外小心，以避免引入未定义行为或内存安全问题。
裸指针有两种主要类型：*const T（指向常量数据的裸指针）和*mut T（指向可变数据的裸指针）。前者用于读取数据，后者用于读取和修改数据。
裸指针通常通过取址操作符&amp;和类型转换来创建。在下面的示例代码中，我们首先创建了一个整数x和一个可变的整数y。然后，我们使用取址操作符&amp;获取它们的地址，并通过类型转换将它们转换为裸指针raw_ptr和mut_raw_ptr 。获取裸指针并不是unsafe代码，解引用裸指针才是unsafe代码。
fn main() { let x = 66; let raw_ptr: *const i32 = &amp;x as *const i32; let mut y = 99; let mut_raw_ptr = &amp;mut y as *mut i32; } 解引用裸指针是通过在裸指针前使用*操作符来完成的，这允许我们读取或修改裸指针指向的值。注意：解引用裸指针时，必须确保指针是有效的，否则会导致未定义行为。
在下面的示例代码中，我们使用unsafe块来解引用裸指针。在unsafe块内，我们打印出raw_ptr指向的值，并将mut_raw_ptr指向的值修改为1024。
fn main() { let x = 66; let raw_ptr: *const i32 = &amp;x as *const i32; let mut y = 99; let mut_raw_ptr = &amp;mut y as *mut i32; unsafe { println!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a793c4bf53075b3e212cd6e586aefa0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c002de5def4d75e171b4ca6c7d31253/" rel="bookmark">
			Android输入法框架，安卓开发实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		另外，InputMethodManagerService内部还有一个PackageReceiver，当系统中有程序的安装、删除、重启等事件发生时，会更新mMethodList。InputMethodManagerService打开，关闭，切换输入法时，其实就是在操作mMethodList中某个InputMethodInfo。把InputMethodInfo中的代表某个输入法的InputMethodService启动或者销毁，就实现了输入法的打开和关闭。
3、与InputMethodManager的交互
InputMethodManager中会包含一个IInputMethodManager，这个东西就是InputMethodManagerService的代理，打开关闭输入法这些操作就是由InputMethodManager中的某些方法调用IInputMethodManager中相应的方法来实现的。比如：
mService.getInputMethodList()获取输入法列表。
mService.updateStatusIcon(imeToken, packageName, iconId)更新输入法图标，即屏幕上方状态栏中的输入法图标。
mService.finishInput(mClient)隐藏当前输入法。这所以不说关闭输入法，是因为输入法服务启动起来以后，只有在系统关闭或者切换输入法时才会关闭。
mService.showSoftInput(mClient, flags, resultReceiver)打开当前输入法。
…
分别介绍完三大模块之后，再介绍两个东西，输入法的实现和怎么样调用输入法。
1、以系统的SoftKeyboard为例，实现一个输入法至少需要Keyboard,KeyboardView,CandidateView,SoftKeyboard这四个东西。
CandidateView负责显示软键盘上面的那个候选区域。
Keyboard负责解析并保存键盘布局，并提供选词算法，供程序运行当中使用。其中键盘布局是以XML文件存放在资源当中的。比如我们在汉字输入法下，按下b、a两个字母。Keyboard就负责把这两个字母变成爸、把、巴等显示在CandidateView上。
KeyboardView负责显示，就是我们看到的按键。
上面这两人东西合起来，组成了InputView，就是我们看到的软键盘。
SoftKeyboard继承了InputMethodService，启动一个输入法，其实就是启动一个InputMethodService，当SoftKeyboard输入法被使用时，启动就会启动SoftKeyboard这个Service。InputMethodService中管理着一个继承自Dialog的SoftInputWindow，而SoftInputWindow里面就包括了InputView和CandidateView这两个东西。
2、怎么样调用输入法呢？
说起这个东西，很自然地想起EditText来，我们团队跟踪过这个Widget，EditText本身很简单，主要的代码在TextView和View当中。这两个Widget本身又很复杂，杂在一起说不清楚。这里我就把我们团队以前做过的一个小例子拿进来做参考，说明一下如何从一个View上调用输入法和如何接收输入法传过来的字符串。
小例子的起源来自于我们要做一个浏览器，需要在SurfaceView来在Canvas上面绘制自己需要的东西，开启自己的主控制循环线程，事件处理等。比如我要在SurfaceView上绘制输入浏览器中的按钮、文本、图片、输入框等，当然这些和ImageView,TextView没有关系，都是用自己的UI引擎来做的。最后所有问题都解决了，却在输入框上卡壳了。因为要实现输入，得调用EditText，否则就必须自己去和EditText一样连接输入法。以前找过相关资料，看网上也有人碰到过这个问题，但都没有答案。最后，还是团队中一个很牛的娃给解决了。代码很简单，不出二十行，但没资料，View的源码又太庞大，费的劲却是只有我们团队的人才能体会得到的。。。这里佩服张老二同学一下，没有他的努力，就没有下面这二十多行很重要很重要的源码的诞生。
首先，定义一个继承自BaseInputConnection的类。
public class MyBaseInputConnection extends BaseInputConnection{
public MyBaseInputConnection(View targetView, boolean fullEditor) {
super(targetView, fullEditor);
}
public static String tx=“”;
@Override
public boolean commitText(CharSequence text, int newCursorPosition) {//输入法程序就是通过调用这个方法把最终结果输出来的。
tx = text.toString();
return true;
}
}
BaseInputConnection相当于一个InputMethodService和View之间的一个通道。每当InputMethodService产生一个结果时，都会调用BaseInputConnection的commitText方法，把结果传递出来。
public class MyView extends SurfaceView …{
InputMethodManager input = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);//得到InputMethodManager。
ResultReceiver receiver = new ResultReceiver(new Handler() {//定义事件处理器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c002de5def4d75e171b4ca6c7d31253/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/445/">«</a>
	<span class="pagination__item pagination__item--current">446/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/447/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>