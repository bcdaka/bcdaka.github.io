<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eed5eee3d7f0fe3f75961770a397b66/" rel="bookmark">
			LeetCode 144. 二叉树的前序遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 更多题解尽在 https://sugar.matrixlab.dev/algorithm 每日更新。
组队打卡，更多解法等你一起来参与哦！
LeetCode 144. 二叉树的前序遍历，难度中等。
class Solution { public void preorderTraversal(TreeNode root, List&lt;Integer&gt; ans) { if (root == null) return; ans.add(root.val); preorderTraversal(root.left, ans); preorderTraversal(root.right, ans); } public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); preorderTraversal(root, ans); return ans; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd18af09e5b324b6f45afbcef94c3252/" rel="bookmark">
			stm32使用串口打印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Driver_USART.c #include "Driver_USART.h" /** * @description: 初始化串口1 */ void Driver_USART1_Init(void) { /* 1. 开启时钟 */ /* 1.1 串口1外设的时钟 */ RCC-&gt;APB2ENR |= RCC_APB2ENR_USART1EN; /* 1.2 GPIO时钟 */ RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPAEN; /* 2. 配置GPIO引脚的工作模式 PA9=Tx(复用推挽 CNF=10 MODE=11) PA10=Rx(浮空输入 CNF=01 MODE=00)*/ GPIOA-&gt;CRH |= GPIO_CRH_CNF9_1; GPIOA-&gt;CRH &amp;= ~GPIO_CRH_CNF9_0; GPIOA-&gt;CRH |= GPIO_CRH_MODE9; GPIOA-&gt;CRH &amp;= ~GPIO_CRH_CNF10_1; GPIOA-&gt;CRH |= GPIO_CRH_CNF10_0; GPIOA-&gt;CRH &amp;= ~GPIO_CRH_MODE10; /* 3. 串口的参数配置 */ /* 3.1 配置波特率 115200 */ USART1-&gt;BRR = 0x271; /* 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd18af09e5b324b6f45afbcef94c3252/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/706e5696ee2d2c3148f55f8d439d865f/" rel="bookmark">
			【SD教程】全网最详细的AI绘画提示词语法讲解！（附提示词插件包）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI绘画提示词如何写？对于入门的小伙伴来说这是一个大问题，提示词写的好，才能有高质量的作品，那今天给大家详细讲解一下，建议点赞收藏！
文末附提示词插件
一、SD提示词基础
AI绘画提示词基本规则
1、提示词（prompt）由多个词缀构成。
提示词分为正向提示词（positive prompt）和反向提示词（negative prompt），用来告诉AI哪些需要，哪些不需要。
2、词缀的权重默认值都是1，从左到右依次减弱，权重会影响画面生成结果。
比如景色Tag在前，人物就会小：
相反的人物提示词在前景物在后人物会变大或半身：
选择正确的顺序、语法来使用提示词，将更好、更快、更有效率地展现所想所愿的画面。
所以SD提示词撰写的大体逻辑是这样的：
首先我们要保证画面中质量，因此在最前面的永远是强调画面质量的提示词，之后我们要考虑我们的画面风格，你想要什么画风，接着就是我们画面需要体现的主要元素，最后是增添的细节。
若是想明确某主体，应当使其生成步骤向前，生成步骤数加大，词缀排序向前，权重提高：
画面质量 → 主要元素 → 细节
若是想明确风格，则风格词缀应当优于内容词缀：
画面质量 → 风格 → 元素 → 细节
举例：一串长的提示词可以拆分为如下：
· 画面质量：
best quality,masterpiece,HDR,UHD,8K,best quality,oil_painting,
· 主要元素：
princess,oval face,dancing,smile,bright pupils,
· 细节：
Movie light, elves, floating light points, dreams, magic
· 画风lora：
如果有的话写在这里
best quality,masterpiece,HDR,UHD,8K,best quality,((oil_painting)),
princess,oval face,dancing,bright pupils,twintails,smile,
Movie light,elves,floating light points,dreams,magic,panoramic,grand scenes,(Bokeh:1.4),
3、AI 会依照概率来选择性执行提示词。
如提示词之间有冲突，AI 会根据权重确定的概率来随机选择执行哪个提示词。
生成图片的大小会影响 Prompt 的效果，图片越大需要的 Prompt 越多，不然 Prompt 会相互污染。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/706e5696ee2d2c3148f55f8d439d865f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d2752e3e2cc15db3465f4c5a168d18c/" rel="bookmark">
			昇思学习打卡-16-热门LLM及其他AI应用/K近邻算法实现红酒聚类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 算法原理距离定义模型构建 算法原理 K近邻算法可以用在分类问题和回归问题上，它的原理如下：要确定一个样本的类别，可以计算它与所有训练样本的距离，然后找出和该样本最接近的k个样本，统计出这些样本的类别并进行投票，票数最多的那个类就是分类的结果。
KNN的三个基本要素：
K值，一个样本的分类是由K个邻居的“多数表决”确定的。K值越小，容易受噪声影响，反之，会使类别之间的界限变得模糊。距离度量，反映了特征空间中两个样本间的相似度，距离越小，越相似。常用的有Lp距离（p=2时，即为欧式距离）、曼哈顿距离、海明距离等。分类决策规则，通常是多数表决，或者基于距离加权的多数表决（权值与距离成反比）。 距离定义 计算不同样本间的距离，可以使用欧氏距离，有时也是用Mahalanobis距离、Bhattacharyya距离
使用欧式距离时，应将特征向量的每个分量进行归一化，以减少特征值得尺度范围不同带来的干扰
模型构建 class KnnNet(nn.Cell): def __init__(self, k): super(KnnNet, self).__init__() self.k = k def construct(self, x, X_train): #平铺输入x以匹配X_train中的样本数 x_tile = ops.tile(x, (128, 1)) square_diff = ops.square(x_tile - X_train) square_dist = ops.sum(square_diff, 1) dist = ops.sqrt(square_dist) #-dist表示值越大，样本就越接近 values, indices = ops.topk(-dist, self.k) return indices def knn(knn_net, x, X_train, Y_train): x, X_train = ms.Tensor(x), ms.Tensor(X_train) indices = knn_net(x, X_train) topk_cls = [0]*len(indices.asnumpy()) for idx in indices.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d2752e3e2cc15db3465f4c5a168d18c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4b99952649c06e879c2274ec0f3675c/" rel="bookmark">
			【前端新手小白】学习Javascript的【开源好项目】推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
1 项目介绍
1.1 时间日期类
1.2 网页store类
1.3 事件类
1.4 Number类
1.5 String类
1.6 正则验证类
1.7 ajax类
1.8 data数据类
1.9 browser浏览器类
2 学习js-tool-big-box开源项目时有哪些收获
2.1 你可以这样做
2.2 如果你需要使用本项目 2.3 你也可以为本git项目点个赞 3 开源项目的发展趋势
前言 如果你是一位前端新手小白，如果你觉得自己的JS功底还有所欠缺，如果你觉得自己平时做的项目还不够丰富，如果你觉得自己遇到的场景还不够丰富。
如果你想要一个练手的好项目，如果你想学习更多的场景，如果你想学习更多的公共方法，如果你想从新手小白中挣脱出来。
那么我推荐的这个开源项目，你一定会需要的。
1 项目介绍 我说的这个开源项目呢，是一个前端JS的公共方法库。无论是Vue项目，还是React项目，他都可以胜任。他是一个更多更丰富的公共方法集合。
首先，我们来个github的链接地址，点我：js-tool-big-box的github地址
然后，我们来个他的学习文档：js-tool-big-box的学习地址
他目前包含的功能有：
1.1 时间日期类 时间日期的转换；更灵活的时间格式；更个性化的时间获取；某个时间点距离现在的时间段（更加详细的返回信息）判断平年还是闰年；某个月有多少天；属相；一年中的法定节假日；获取全球重点城市时间； 1.2 网页store类 获取url中的参数值设置cookie；获取cookie；删除cookie；设置localStorage;获取localStorage 1.3 事件类 防抖节流 1.4 Number类 千分位逗号分割；判断是否大于0；判断是否大于0的整数；生成指定范围内的随机数；生成指定位数的随机数；数字转小写中文；数字转大写中文； 1.5 String类 字符串反转；横岗转小驼峰横岗转大驼峰；版本号比较；获取一个字符串的字节长度；生成uuid；根据身份证号获取性别、年龄和出生日期；字符串中间加特殊符号，隐藏关键信息；字符串大小写字母转换； 1.6 正则验证类 邮箱格式验证；手机号格式验证；url格式验证；身份证号格式验证；IP地址格式验证；邮政编码格式验证； 判断是否是Unicode字符；
检测密码强度值；
1.7 ajax类 发送jsonp请求；下载文件纯功能版本；下载文件，fetch + 下载功能版本； 1.8 data数据类 数组中获取随机个数的值；复制文字到剪贴板；数组去重；获取更详细的数据类型；数值型数组排序（正序和倒序）；对象型数组排序（正序和倒序） 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4b99952649c06e879c2274ec0f3675c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4affbb82c50b0ef653c1c008862f456/" rel="bookmark">
			微前端：乾坤 、无界、single-spa、iframe对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、微前端框架概述 微前端框架是一种技术解决方案，旨在将大型前端应用拆分为多个小型、独立、可维护的微前端应用，每个微前端应用可以独立开发、测试、部署和运行，同时保持整体的协同工作和用户体验。这种架构类似于微服务架构，但专注于前端领域
二、常见的微前端框架 qiankun（乾坤）：由蚂蚁金服开发维护，基于Single-SPA，提供了技术栈无关、接入简单的特性。它支持Vue、React等多种前端框架，并且具有较低的改造成本和友好的开发体验。single-spa：是一个轻量级的JavaScript前端路由框架，专注于单页面应用（SPA）的路由管理。虽然它本身不是一个完整的微前端框架，但它是许多微前端实现的基础。iframe：虽然iframe本身不是一个微前端框架，但它经常被用作微前端的一种简单实现方式无界：无界微前端框架是一款基于Web Components + iframe的微前端解决方案，它具备成本低、速度快、原生隔离、功能强等一系列优点。以下是对无界微前端框架的详细介绍 共同点： 当路由切换的时候，可以去加载对应应用的代码，让其跑在容器里。
具备加载和卸载子应用的能力，页面从一个子应用切换到另一个子应用时，能正常进行加载和渲染；具有路由状态保持能力，激活子应用后，浏览器刷新、前进、后退子应用的路由都可以正常工作；主应用和子应用、子应用和子应用之间可以相互进行通信；每个微应用都可独立仓库管理，独立技术栈开发、独立部署、独立运行； 三、各微前端框架对比 特性qiankun无界single-spaiframe技术栈支持技术栈无关，支持React、Vue、Angular等基于WebComponent，支持多种技术栈技术栈无关，支持多种前端框架技术栈无关，但集成需考虑兼容性接入方式简单，通过JS API接入较为简单，通过WebComponent封装复杂，需配置single-spa生命周期简单，通过HTML标签嵌入沙箱隔离提供JS沙箱和样式隔离使用WebComponent天然隔离需开发者自行实现沙箱隔离iframe天然隔离路由管理支持路由状态保持，可配置路由映射支持虚拟路由，保持路由状态作为顶层路由，需自行管理子应用路由路由由iframe内应用自行管理应用通信提供父子应用及子子应用间通信机制提供组件式API，支持通信需开发者自行实现通信机制可通过postMessage或URL参数等方式通信资源预加载支持静态资源预加载支持静态资源预加载支持延迟加载应用不支持预加载，按需加载性能影响较低，通过沙箱和懒加载优化较低，但WebComponent可能有性能开销较低，但依赖应用的优化较高，iframe加载和渲染开销较大开发体验较好，提供了丰富的API和文档较好，组件式API更直观一般，需自行处理很多细节较好，易于集成现有应用生产可用性经过验证，适用于生产环境适用于生产环境，但社区支持可能较少适用于生产环境，需开发者自行完善适用于生产环境，但需谨慎处理安全性和性能问题适配成本较高，需适配路由、生命周期等适中，主要适配WebComponent较高，需深入理解single-spa架构较低，但需注意兼容性和性能问题 微前端框架为前端应用的开发带来了诸多优势，如技术栈无关性、独立开发和部署、增量升级等。然而，它也存在一定的缺点，如接入难度高、资源共享能力差等。因此，在选择是否使用微前端框架时，需要根据项目的具体需求和团队的技术能力进行综合考虑。同时，在实际应用中，还需要注意微前端框架的选型、架构设计、代码管理等方面的问题，以确保项目的顺利进行和系统的稳定运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7aa37de6f462efaa7bffee2d73ab798/" rel="bookmark">
			【数据结构】线性表----队列详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 队列的基本概念 话不多说，直接开始！
队列是一种线性数据结构，同栈类似但又不同，遵循先进先出（FIFO, First In First Out）的原则。换句话说，最先进入队列的元素会最先被移除。这样的特点使得队列非常适合用于需要按顺序处理任务的场景。
特点：
先进先出：第一个进入队列的元素最先被处理。操作受限：元素只能从队尾插入，从队头移除。 2. 队列的实现 队列可以通过多种方式实现，常见的有数组和链表两种。
使用数组实现队列：
使用数组实现队列需要维护两个指针，分别指向队头和队尾，并且需要处理数组的溢出问题。所以数组不是很适合用来实现队列。
使用链表实现队列：
链表不会受到同数组一样的困扰，并且链表实现的队列没有数组的大小限制；但需要额外的指针来管理链表的节点。
4. 队列的基本操作 队列的基本操作包括入队（Enqueue）、出队（Dequeue）、查看队头（Peek）和检查队列是否为空（IsEmpty）。
入队（Enqueue）：
将元素添加到队尾。
出队（Dequeue）：
移除队头的元素。
查看队头（Peek）：
查看队头的元素，但不移除。
检查队列是否为空（IsEmpty）：
检查队列中是否有元素。
5. 队列的高级用法 循环队列：
循环队列是一种优化的队列实现，避免了数组实现中由于出队操作造成的空间浪费。
优先队列：
优先队列中的元素具有优先级，出队时优先级高的元素会被优先移除。
6.两种形式的队列实现 入队（Enqueue） 将元素添加到队尾。如果使用数组实现，需要检查队列是否已满。如果使用链表实现，只需将新节点添加到链表的末尾。
数组实现的入队操作：
void enqueue(Queue* q, int value) { if (isFull(q)) { printf("Queue is full!\n"); return; } if (isEmpty(q)) { q-&gt;front = 0; } q-&gt;rear++; q-&gt;items[q-&gt;rear] = value; } 链表实现的入队操作：
void enqueue(Queue* q, int value) { Node* newNode = (Node*)malloc(sizeof(Node)); newNode-&gt;data = value; newNode-&gt;next = NULL; if (isEmpty(q)) { q-&gt;front = newNode; } else { q-&gt;rear-&gt;next = newNode; } q-&gt;rear = newNode; } 出队（Dequeue） 移除队头的元素。如果使用数组实现，需要检查队列是否为空，并调整队头指针。如果使用链表实现，需要移除链表的第一个节点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7aa37de6f462efaa7bffee2d73ab798/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/861efe946dbd3c7af8a91b7faffc9a23/" rel="bookmark">
			【初阶数据结构】树与二叉树：从零开始的奇幻之旅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初阶数据结构相关知识点可以通过点击以下链接进行学习一起加油！时间与空间复杂度的深度剖析深入解析顺序表:探索底层逻辑深入解析单链表:探索底层逻辑深入解析带头双向循环链表:探索底层逻辑深入解析栈:探索底层逻辑深入解析队列:探索底层逻辑深入解析循环队列:探索底层逻辑 本篇将从树与二叉树相关概念进行入手，帮助我们接下二叉树更进一步的学习。
🌈个人主页：是店小二呀
🌈C语言笔记专栏：C语言笔记
🌈C++笔记专栏： C++笔记
🌈初阶数据结构笔记专栏： 初阶数据结构笔记
🌈喜欢的诗句:无人扶我青云志 我自踏雪至山巅
文章目录 一、树概念及结构1.1 树的相关概念 二、树的存储表示三、二叉树概念3.1 现实中的二叉树(见到都要拜几下) 四、特殊的二叉树4.1 不属于完全二叉树的情况 五、二叉树的存储结构5.1 顺序存储5.2 父子节点间下标规律关系(重要)5.3 链式存储5.4 小总结 一、树概念及结构 树是一种非线性的数据结构，它是由n(n&gt;=0)个有限节点组成一个具有层次关系的集合，然而树在实践中价值不大，但是二叉树实践价值比较大(这种集合称为树的理由，是它是根朝上，而叶朝下，看起来很像树)
有一个特殊的节点，称为根节点，根节点没有前驱节点除根节点外，其余节点被分成M(M&gt;0)个互不相交的集合T1、T2、....、Tm，其中每一个集合Ti(1&lt;=i&lt;=m)又是一颗结构与树类似的子树。每颗子树的根节点有且只有一个前驱，可有0个或多个后继。树是递归定义，与此同时需要注意。在树形结构中子树之间不能有交集，否则就不是树形结构 1.1 树的相关概念 节点的度：一个节点含有的子树的个数称为该节点的度； 如上图：A的为6叶节点或终端节点：度为0的节点称为叶节点； 如上图：B、C、H、I…等节点为叶节点非终端节点或分支节点：度不为0的节点； 如上图：D、E、F、G…等节点为分支节点双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点； 如上图：A是B的父节点孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点； 如上图：B是A的孩子节点兄弟节点：具有相同父节点的节点互称为兄弟节点； 如上图：B、C是兄弟节点树的度：一棵树中，最大的节点的度称为树的度； 如上图：树的度为6节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推树的高度或深度：树中节点的最大层次； 如上图：树的高度为4堂兄弟节点：双亲在同一层的节点互为堂兄弟；如上图：H、I互为兄弟节点节点的祖先：从根到该节点所经分支上的所有节点；如上图：A是所有节点的祖先子孙：以某节点为根的子树中任一节点都称为该节点的子孙。如上图：所有节点都是A的子孙森林：由m（m&gt;0）棵互不相交的树的集合称为森林 二、树的存储表示 由于树状结构相对线性表复杂，存储方式也更加麻烦，既要保存值域，也要保存好结点和结点之间的关系。
以下根据之前知识得到的几种方法
每个孩子都有一个地址，可以通过指针数组存储数据(空间是固定，申请新空间有代价和空间情况问题出现)对于第一种方法优化，将指针数组改用为顺序表存储孩子，解决了空间固定的问题推荐常用的解法:左孩子右兄弟法(老大带着老二，老二带着老三，不用双亲累) typedef int DataType; struct Node { struct Node* _firstChild1; // 第一个孩子结点 struct Node* _pNextBrother; // 指向其下一个兄弟结点 DataType _data; // 结点中的数据域 }; 当然不局限以上几种方式，还有双亲表示法，孩子表示法、孩子双亲表示法以及孩子兄弟表示法等。我们这里就简单的了解其中最常用的孩子兄弟表示法
三、二叉树概念 一颗二叉树是节点的一个有限集合，该集合可能有两种情况
空树由一个根节点加上两颗别称为左子树和右子树的二叉树组成(子树可能为空树) 从图中可以得出两个结论:
二叉树不存在度大于2的结点
二叉树的子树有左右之分，次序不能颠倒，因此二叉树是有序树
注意:对于任意的二叉树都是通过下列几种情况组成的(空树的情况最容易忘记)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/861efe946dbd3c7af8a91b7faffc9a23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6712ee091c4c453ae1d4c9bc9e510ddf/" rel="bookmark">
			关闭Linux服务器的swap分区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 关闭当前的交换分区 首先，需要临时关闭当前正在使用的交换分区，
sudo swapoff -a 2. 注释掉/etc/fstab中的交换分区条目 为了防止系统在重启时重新启用交换分区，需要编辑/etc/fstab文件并注释掉（或删除）与交换分区相关的条目，
sudo nano /etc/fstab 找到类似下面的行，注释或者删掉，
UUID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx none swap sw 0 0 3. 删除交换分区（可选） 如果确定不再需要这个交换分区，可以选择删除它。首先，使用lsblk或fdisk -l等命令找到交换分区的设备名称。例如，
sudo lsblk 假设交换分区是/dev/sda3，可以使用fdisk或parted来删除这个分区，
sudo fdisk /dev/sda """ 在fdisk提示符下，输入以下命令： p: 打印分区表，找到交换分区的编号 d: 删除分区，输入交换分区的编号 w: 写入更改并退出 """ sudo parted /dev/sda """ 在parted提示符下，输入以下命令： print: 打印分区表，找到交换分区的编号 rm N: 删除编号为N的分区 quit: 退出 parted """ 4. 确认交换分区已关闭 最后，确认交换分区已关闭并且不会在重启后重新启用（如果没有输出，说明没有启用的交换分区）,
sudo swapon --show 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa74ff1ea4f767a572dab218e5d714aa/" rel="bookmark">
			Mysql 8.0.38安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mysql8.0.38安装 需要去官网下载
https://dev.mysql.com/downloads/installer/
下载 选择8.0.38版本
平台选中 Windows
下载MSI应用程序
选择Download
点击后选择 No thaks，jist start my Download
安装 打开后的默认界面
点击Custom
点击Next
选择展开Mysql Servers下的Mysql Server 下的 Mysql Server 8.0 下的 Mysql Server8.0.38 -X64
点击Mysql Server8.0.38 -X64 然后点击向右的箭头
点击右边的 Mysql Server8.0.38 -X64
然后点击Advanced Options（更改安装目录，不需要更改的跳过这一步）
修改完成后点击Ok，并且选择Next
选择Execute，等待，
然后点击next，来到Product Configuration页面
点击Next，来到 Type and Networking
点击Next，来到Authention Method页面
点击Next，来到设置密码的界面，创建root的密码
然后点击Next，来到 Windows Service
点击Next，来到Server File Permisions
点击Next，来到Apply Configuration页面
点击Execute，等待完成
Execute完成后，点击Finish
点击Next
点击Finish
安装完成！
添加环境变量（不添加使用不了） 找到Mysql的安装目录
本教程的路径是
C:\Program Files\MySQL\MySQL Server 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa74ff1ea4f767a572dab218e5d714aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80ae31b795c6a8e91dee5ff52af48a43/" rel="bookmark">
			QT跨平台开发（windows、mac）中.pro文件设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一： 在配置前面加上平台标识符的前缀 # windows win32:INCLUDEPATH += F:/Dev/ffmpeg-4.3.2/include win32:LIBS += -LF:/Dev/ffmpeg-4.3.2/lib \ -lavcodec \ -lavdevice \ -lavfilter \ -lavformat \ -lavutil \ -lpostproc \ -lswscale \ -lswresample # mac macx:INCLUDEPATH += /usr/local/Cellar/ffmpeg/4.3.2/include macx:LIBS += -L/usr/local/Cellar/ffmpeg/4.3.2/lib \ -lavcodec \ -lavdevice \ -lavfilter \ -lavformat \ -lavutil \ -lpostproc \ -lswscale \ -lswresample \ -lavresample # linux # linux:INCLUDEPATH += ... # linux:LIBS += ... 或使用 大括号 简化：
# windows win32 { INCLUDEPATH += F:/Dev/ffmpeg-4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80ae31b795c6a8e91dee5ff52af48a43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02165dea58d39d860fb51e18989910d8/" rel="bookmark">
			Stable Diffusion【二次元模型】：最强扁平化风格大模型一键生成插画风格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是安琪！！！
二次元世界，以其独特的魅力，吸引了无数艺术爱好者和动漫迷。如今，借助Stable Diffusion的二次元模型，你只需一键操作，就能轻松实现扁平化风格的插画创作。本文将带你深入了解Stable Diffusion二次元模型的使用方法，助你轻松掌握这一技巧。
Stable Diffusion是一款基于深度学习的图像生成模型，它能够在没有任何人类指导的情况下生成高质量、逼真的图像。与传统的图像生成技术相比，Stable Diffusion具有更高的生成质量和更快的生成速度。
今天和大家分享一款基于SD1.5的扁平化风格的二次元大模型：纯平简彩flatanime-mix。对于喜欢扁平风格的小伙伴们，该模型还是非常值得推荐的。
目前最新的版本是V1.0版本，该版本对提示词的识别非常友好好，人物/场景/物体都能够表现。更多时候，该模型可以作为扁平化插画风格的二次元底膜使用。
模型下载地址（文末可自行扫描获取）
作者在官网给出了该大模型推荐参数设置。
无需外挂VAE，或者用animevae，(vae-ft-mse-840000-ema-pruned.safetensors可能有一点模糊)
采样：Euler a
CFG：7-8
高清修复：R-ESRGAN 4X+Anime6，重绘幅度0.3左右
下面我们来实际体验一下，看使用这个模型出来的图片效果如何吧。
反向提示词
(worst quality:2),(low quality:2),(normal quality:2),lowres,bad anatomy,bad hands,text,error,missing fingers,extra digit,fewer digits,cropped,jpeg artifacts,signature,watermark,username,blurry
公共参数设置
大模型：纯平简彩 flatanime-mix V1.0
采样器：Euler a
采样迭代步数：20
CFG：7
图片宽高：512*768
1. 微笑
Prompt:(masterpiece, best quality:1.3),1girl,smile,red dress,upper body,flowers,city background,
提示词：(杰作，最佳质量:1.3)，1女孩，微笑，红衣服，上身，花朵，城市背景，
2. 办公女士
Prompt：(masterpiece, best quality:1.3),1girl,solo,long hair,office lady,sitting,full body,laptop,working,flowers,
提示词：(杰作，最佳质量:1.3)，1个女孩，独唱，长发，办公室女士，坐着，全身，笔记本电脑，工作，鲜花
3. 圣诞节
Prompt：(masterpiece, best quality:1.3),1 girl holds Christmas gifts in her hands,wears a Christmas hat,Christmas tree,night lighting
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02165dea58d39d860fb51e18989910d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab01d294e4070af4a0883e1521c95aa9/" rel="bookmark">
			AI 正在取代工作岗位、ChatBot 进入厌倦期、向量数据库崛起，人工智能现状报告有这些重要发现！...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 | Echo Tang&amp;GPT
出品丨AI 科技大本营（ID：rgznai100）
百度的无人驾驶“萝卜快跑”已经在武汉大面积推广，在部分城市进行小量的试运行，以低廉的价格直接卷翻滴滴、出租车司机，让人们热议“五年、十年后，网约车、出租车基本都是无人驾驶了”。
这是 AI 取代工作岗位的一个缩影。
GPT 生成
国外软件开发平台 Retool 日前调查了约 750 位技术人员（包括开发者、数据团队、管理层以及其他跨技术及行业人士）发现，AI 的采用率并没有飙升，但工作岗位的替代危机正在上演。45.7% 的人认为初级人员最有可能被 AI 取代，而高级人才和高层管理者被取代的风险则较低。这就带来了一个至关重要的问题，如果初级都被取代了，那么未来中高级人才从何而来呢？
AI 科技大本营对这份反映人工智能最新现状的报告进行了要点提炼，接下来就让我们一起来看有哪些颇值得我们关注的现状。
AI 被高估了！
毫无疑问，AI 行业正在快速发展，技术也在不断迭代，伴随着这一切而来的还有炒作、怀疑、焦虑和好奇。在 Retool 2023 年报告中，受访者对 AI 持谨慎态度，大多数人认为它有些被高估了。到目前为止，2024 年这种看法并没有太大变化：
在经历了 2023 年的炒作风暴之后（可以说，这使得任何与 AI 相关的事物都难以符合预期），对 AI 相对不成熟、当前局限性和巨大潜力的更清晰的看法似乎正在浮现。
在填写的回答中，我们看到了一种感觉，即激进的炒作暂时掩盖了 AI 的真正潜力：
1. AI 被硬塞进产品中，但并没有真正增加价值。（有人想起“我们用$HOTLANG 重写了一切”吗？）
2. “AI”被用作机器学习、LLM 和自动化的总称。
3. AI 被视为一个魔法锤，包括在传统编程就足够或优于 AI 的情况下，无需应对繁琐的提示和幻觉。
似乎仍有大量无用的信息需要筛选，才能让我们发现对日常技术和商业用例真正有用的 AI 应用，但受访者乐观地认为，AI 的实用性和应用范围将会显现出来。
一句话总结：当谈到可操作的 AI 时，这才刚刚开始。
AI 的采用率真的在飙升吗？
尽管媒体关于AI的主要叙述是其采用率和实用性正在激增，并且正在接管世界，但现实是，现在的情况要温和得多。
或许每个人都在使用它，但大多数受访者明确表示，他们离顶峰还有很长的路要走。相当多的受访者对他们的公司给予了好评——约30%认为自己在采用方面“奔跑”或“飞翔”的状态，咨询（46%）、房地产（46%）和消费品（37%）行业的受访者排名最高。但总体而言，认为自己处于领先地位（即飞翔）的受访者从2023年的13.4%下降到2024年的9.8%。此外，受访者们指出的进展大部分不具备变革性。
管理层想要在 AI 上更多地投资！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab01d294e4070af4a0883e1521c95aa9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aabb812c7f2c1e856fc1b635b3b1b298/" rel="bookmark">
			[计算机网络] VPN技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VPN技术 1. 概述 虚拟专用网络（VPN）技术利用互联网服务提供商（ISP）和网络服务提供商（NSP）的网络基础设备，在公用网络中建立专用的数据通信通道。VPN的主要优点包括节约成本和提供安全保障。
优点：
​ VPN可以节约成本​ 为安全提供保障 2. VPN类型 VPN主要有三种应用方式：远程接入VPN、内联网VPN、外联网VPN。
远程接入VPN（Access VPN）
远程接入VPN允许移动用户在外部网络上访问内部网络。例如，一些学校和企业的门户平台只有在内网环境下才能访问，通过远程接入VPN，用户可以在任何地方安全地连接到这些内部资源。
内联网VPN
内联网VPN将两个内部网络通过公用网络连接起来，形成一个逻辑上的局域网。这种方式可以用于连接不同办公室、分支机构，使其共享内部资源，提升整体协作效率。
外联网VPN
外联网VPN使得不同的用户在逻辑上的局域网中不平等。通常用于合作伙伴或客户之间的安全通信，在保护公司内部资源的同时，提供必要的访问权限。
3. 使用的技术 3.1 隧道技术 隧道技术主要是利用隧道协议来传输另外一种协议。隧道由隧道开通器（TI）、有路由能力的公用网络和隧道终止器（TT）组成。隧道可以将数据流量强制传输到特定的目的地，隐藏私有的网络地址、在IP网络上传输非IP协议的数据包，简单的来说，隧道技术就像现实生活中的隧道，它可以从一地到一地，而它穿过的“大山”在这里就是外网。
3.1.1 实现方式 隧道的实现主要分为两个过程：封装、解封装。
封装：由隧道开通器（TI）完成，将数据包封装在隧道协议的外壳内。解封装：由隧道终止器（TT）完成，将数据包从隧道协议的外壳中解封。 3.1.2 基本类型 隧道有两种基本类型：主动式隧道和被动式隧道
主动式隧道（Access VPN）：
​ 客户端主动与目标隧道服务器建立连接。这种方式，客户端需要安装所需要的隧道协议
被动式隧道（Intranet VPN、Extranet VPN）：
​ 被动式隧道主要用于两个内部网络之间的固定连接，所以需要先交给隧道服务器A，在接收到数据后，将其强制通过已建立的隧道传输到对端的隧道服务器。
4. VPN相关协议 在VPN技术中，隧道协议用于在公用网络上建立安全的通信通道。根据工作在OSI模型中的层次，可以将隧道协议分为第二层隧道协议和第三层隧道协议。
4.1 第二层隧道协议 第二层隧道协议工作在OSI模型的第二层，即数据链路层。常见的第二层隧道协议包括PPTP和L2TP。
4.1.1. PPTP（Point-to-Point Tunneling Protocol） PPTP是由微软和其他厂商开发的早期VPN协议。它在PPP（Point-to-Point Protocol）基础上进行封装，通过互联网传输PPP帧。
特点：
简单易用：PPTP配置相对简单，广泛支持于Windows操作系统。性能较好：由于其较轻的协议开销，PPTP具有良好的传输性能。安全性较低：PPTP的加密机制（通常是MPPE）相对较弱，容易受到攻击。 4.1.2. L2TP（Layer 2 Tunneling Protocol） L2TP是由思科和微软共同开发的协议，结合了PPTP和L2F（Layer 2 Forwarding）的特点。L2TP本身不提供加密功能，通常与IPSec一起使用，以提供强大的加密和认证机制。
特点：
灵活性高：L2TP可以通过多种网络（如ATM、帧中继等）传输数据。安全性好：当与IPSec结合使用时，L2TP/IPSec提供了强大的加密和认证功能。性能较差：由于双重封装（L2TP和IPSec），L2TP/IPSec的性能可能不如其他协议。 L2TP主要是由LAC（L2TP接入集中器）和LNS（L2TP网络服务器）构成。
LAC：用于客户端的L2TP来接发呼叫、建立隧道，为客户端提供通过PNST、ISDN、xDSL等方式的接入网路服务。LNS：隧道的终点。 L2TP具有两种报文格式：控制报文、数据报文。
L2TP控制报文：用于隧道的建立、维护与断开。使用的是UDP1701端口，对封装后的UDP数据报使用IPSec ESP进行加密处理并认证。L2TP数据报文：负责传输用户的数据。 4.2 第三层隧道协议 第三层隧道协议工作在OSI模型的第三层，即网络层。常见的第三层隧道协议包括IPSec和GRE。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aabb812c7f2c1e856fc1b635b3b1b298/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d5903cda7aec11d83c8246fb4d7c1d6/" rel="bookmark">
			SQL职场必备：掌握数据库技能提升职场竞争力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💂 个人网站:【 摸鱼游戏】【网址导航】【神级代码资源网站】🤟 一站式轻松构建小程序、Web网站、移动应用：👉注册地址🤟 基于Web端打造的：👉轻量化工具创作平台💅 想寻找共同学习交流，摸鱼划水的小伙伴，请点击【全栈技术交流群】 在现代职场中，数据的重要性日益凸显。无论你是数据分析师、软件开发人员，还是业务经理，掌握SQL（Structured Query Language）都将大大提升你的职场竞争力。SQL是用于管理和操作关系数据库的标准语言。本文将介绍SQL的基本概念、常用语法，并通过代码示例展示如何在职场中高效地使用SQL。
一、SQL基础概念 关系数据库：关系数据库是由多个表组成的，每个表包含一组有相同属性的数据记录。表与表之间通过键（Key）建立联系。SQL：SQL是用于访问和操作关系数据库的语言。它包括数据查询、插入、更新和删除等操作。 二、SQL的核心操作 SQL的核心操作包括CRUD，即创建（Create）、读取（Read）、更新（Update）和删除（Delete）。下面我们将逐一介绍这些操作及其常用语法。
1. 创建表（Create） 创建表是数据库操作的第一步。在创建表时，需要定义表的名称和列的属性，包括列名、数据类型和约束条件。
CREATE TABLE Employees ( EmployeeID INT PRIMARY KEY, FirstName VARCHAR(50), LastName VARCHAR(50), BirthDate DATE, Position VARCHAR(50), Salary DECIMAL(10, 2) ); 在上述代码中，我们创建了一个名为Employees的表，包含六个列：EmployeeID、FirstName、LastName、BirthDate、Position和Salary。其中，EmployeeID被定义为主键。
2. 插入数据（Insert） 插入数据是将新的记录添加到表中。
INSERT INTO Employees (EmployeeID, FirstName, LastName, BirthDate, Position, Salary) VALUES (1, 'John', 'Doe', '1980-01-01', 'Manager', 75000.00); 这段代码将一条新记录插入到Employees表中。
3. 查询数据（Select） 查询是SQL中最常用的操作之一，用于从表中检索数据。
SELECT * FROM Employees; 上述代码将检索Employees表中的所有记录。可以使用WHERE子句来筛选特定的记录：
SELECT * FROM Employees WHERE Position = 'Manager'; 这段代码将检索职位为“Manager”的所有员工记录。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d5903cda7aec11d83c8246fb4d7c1d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04a279174552cfdef4491b745c690c82/" rel="bookmark">
			《故障复盘 · 记一次事务用法错误导致的大量锁表问题》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📢 大家好，我是 【战神刘玉栋】，有10多年的研发经验，致力于前后端技术栈的知识沉淀和传播。 💗
🌻 CSDN入驻不久，希望大家多多支持，后续会继续提升文章质量，绝不滥竽充数，如需交流，欢迎留言评论。👍
文章目录 写在前面的话故障描述排查过程排查前期排查过程 1排查过程 2排查过程 3排查结论 知识拓展事务前置知识回到上述问题关于手动控制关于事务封装问题排查经验事务使用经验 总结陈词 写在前面的话 博主所在公司的产品线，部署上线了多家客户，遇到的线上故障的场景也较多，这里新开一个故障复盘系列，记录并分享一下这些故障的的定位、分析、解决过程。
首先分享的这篇，是排查定位耗时较久的一个由于事务用法错误，导致的大量锁表，进而引发大范围故障的问题。
故障描述 某客户线上环境的死锁问题持续了一个多月了，隔一天会出现一次，业务侧的代码，陆续调整过几次，但都治标不治本。
现象大概是，业务高峰期（9点-9点30），会出现大量锁表，DBA介入杀锁有时候仍无法正常，需要搭配重启相关服务才可以。
相关报错截图如下所示：
由于影响越来越大，公司领导组织研发骨干，针对DBA提供的数据库锁表语法.xslt，以此为突破口进行技术攻关，最终发现了相关问题代码，修正后故障得到恢复，这里针对本次故障进行复盘总结，交流分享排查经验和事务用法。
排查过程 排查前期 【DBA发出锁表Excel】
2024-03-20下午，DBA发出了锁表语法，如下图所示，发现单个事务就执行了大量的语法，9点10分开始事务，9点25失败回滚，持续了15分钟的事务（该事务包含了 976 个语法）。
【分析锁表业务语法特征】
通过分析上面的数据库锁表语法发现里面涉及到的语法并不是来源于同一个接口，且业务范围也各不相同，说明各个不同业务的数据库操作都被嵌入到了同一个事务当中，且定位到锁表语法来自于收费服务，后续开始重点排查收费服务项目。
【组织人员排查】
Excel 暴露出一些问题：
这些语法背后的数据确实没入库，但为何用户没有反馈问题语法涉及的接口看日志是操作成功了，但是为何数据没入库为什么这么多语句会在同一个事务中一起 rollback 疑问点比较多，但可以先从“为什么接口成功了，但数据确没有入库”这一点来分析。
排查过程 1 通过Excel提供的信息，结合应用日志分析，定位到收费服务的encounterCardInfoAdd是属于有问题的接口。
从应用日志看，该接口基本都是INFO，即操作成功的。
接口完整地址：[HTTP] /open/thirdParty/physical/encounterCardInfoAdd
但是比对了SkyWalking，确实DBA反馈的Excel里面合并到一个事务的SQL，所在的接口在SkyWaling看就是没有 commit。
然后该接口的正常的情况，看日志是有commit的，如下图，89ba3310ce46ffa2 没提交，ef65b1e6ea8a2280有提交 查看代码，除了一些规范问题，并没有看到什么不妥之处，也没有手动控制事务。
但没有定位到，为什么会有这种接口成功，但是没有commit或rollback的情况。
排查过程 2 上面接口上没看出来问题，那就继续观察现场环境，发现下面两个异常点。
1、锁的高峰期，收费控制台日志有大量异常：
Closed Connection org.springframework.dao.RecoverableDataAccessException: ### Error querying database. Cause: java.sql.SQLRecoverableException: Closed Connection
30分钟2000个，其中9点28分，1分钟有500个。
其他服务和其他时间段都没有。
2、锁的高峰期，从prometheus看，收费的数据库连接数比其他服务高很多，同时段其他服务，或非该时段，收费的连接数正常。
从上面两个点，可以得出的结论是，出现锁问题的时间段，确实收费服务的数据库连接是有问题的。
结合之前排查来看，感觉大概率和手动开启事务但没操作回滚提交有关系，应该和TransactionSynchronizationManager.registerSynchronization关系不大。
继续测试了一下，只要有手动开启事务，但没有提交。
这次事务里面又有for update语句，那数据就会一直处于锁状态，这时候其他也锁同样数据的接口，将被阻塞。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04a279174552cfdef4491b745c690c82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cc926e8fda23cf0fcc24dc0327c63d0/" rel="bookmark">
			机器学习库实战：DL4J与Weka在Java中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习是当今技术领域的热门话题，而Java作为一门广泛使用的编程语言，也有许多强大的机器学习库可供选择。本文将深入探讨两个流行的Java机器学习库：Deeplearning4j（DL4J）和Weka，并通过详细的代码示例帮助新手理解它们的实战应用。
1. Deeplearning4j（DL4J）简介 Deeplearning4j（DL4J）是一个用于Java和JVM的开源深度学习库，它支持各种神经网络架构，包括卷积神经网络（CNN）、循环神经网络（RNN）和长短期记忆网络（LSTM）。DL4J旨在与Hadoop和Spark等大数据技术无缝集成。
1.1 安装与配置 首先，我们需要在项目中添加DL4J的依赖。如果你使用的是Maven，可以在pom.xml文件中添加以下依赖：
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.deeplearning4j&lt;/groupId&gt; &lt;artifactId&gt;deeplearning4j-core&lt;/artifactId&gt; &lt;version&gt;1.0.0-beta7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.nd4j&lt;/groupId&gt; &lt;artifactId&gt;nd4j-native-platform&lt;/artifactId&gt; &lt;version&gt;1.0.0-beta7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 1.2 构建一个简单的神经网络 接下来，我们将构建一个简单的多层感知器（MLP）神经网络来解决分类问题。以下是一个完整的代码示例：
import org.deeplearning4j.nn.api.OptimizationAlgorithm; import org.deeplearning4j.nn.conf.NeuralNetConfiguration; import org.deeplearning4j.nn.conf.layers.DenseLayer; import org.deeplearning4j.nn.conf.layers.OutputLayer; import org.deeplearning4j.nn.weights.WeightInit; import org.nd4j.linalg.activations.Activation; import org.nd4j.linalg.learning.config.Nesterovs; import org.nd4j.linalg.lossfunctions.LossFunctions; public class SimpleMLP { public static void main(String[] args) { int numInputs = 2; int numOutputs = 2; int numHiddenNodes = 20; NeuralNetConfiguration.ListBuilder builder = new NeuralNetConfiguration.Builder() .seed(123) .optimizationAlgo(OptimizationAlgorithm.STOCHASTIC_GRADIENT_DESCENT) .updater(new Nesterovs(0.1, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cc926e8fda23cf0fcc24dc0327c63d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c264b1142295125f28c0a3fc954a41c/" rel="bookmark">
			Android12 MultiMedia框架之GenericSource extractor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面两节学习到了各种Source的创建和extractor service的启动，本节将以本地播放为例记录下GenericSource是如何创建一个extractor的。extractor是在PrepareAsync()方法中被创建出来的，为了不过多赘述，我们直接从GenericSource的onPrepareAsync()开始看。
onPrepareAsync() Android系统自带了很多源生的extractor，我们这里主要基于MP4 extractor来进行以下内容的分析。
//frameworks/av/media/libmediaplayerservice/nuplayer/GenericSource.cpp void NuPlayer::GenericSource::onPrepareAsync() { mDisconnectLock.lock(); // delayed data source creation if (mDataSource == NULL) { // set to false first, if the extractor // comes back as secure, set it to true then. mIsSecure = false; if (!mUri.empty()) { //省略 } else { //第一部分 if (property_get_bool("media.stagefright.extractremote", true) &amp;&amp; !PlayerServiceFileSource::requiresDrm( mFd.get(), mOffset, mLength, nullptr /* mime */)) { sp&lt;IBinder&gt; binder = defaultServiceManager()-&gt;getService(String16("media.extractor")); if (binder != nullptr) { ALOGD("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c264b1142295125f28c0a3fc954a41c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0a46f3f351785f7a09612ae1b61eca6/" rel="bookmark">
			报错：python扩展中的调试器不再支持小于3.7的python版本（debugpy）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错：python扩展中的调试器不再支持小于3.7的python版本 原因1： debugpy的版本问题原因2 原因1： debugpy的版本问题 是debugpy和你vscode安装的python解释器不匹配，根据你使用的python解释器的版本重新安装一个debugpy。
原因2 你vscode 安装的python解释器版本太低或太高。需要重新安装一下vscode的python解释器。
可以参考下述帖子
【VSCode运行Python3.6.5项目 无法debug调试的解决办法】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/beb63c9a9561f205b90df03a67906a41/" rel="bookmark">
			Python31 自然语言处理NLP之NLTK的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.关于自然语言处理NLP 自然语言处理NLP是人工智能和计算机科学的一个子领域，专注于计算机与人类（自然）语言之间的互动。其目的是使计算机能够理解、解释和生成人类语言。NLP 涉及语言学、计算机科学和人工智能的多学科交叉，通过统计、机器学习和深度学习等方法处理和分析大量的自然语言数据。
核心任务和应用 NLP 包括多种任务和应用，主要分为以下几类：
1. 文本处理 分词：将文本分割成独立的单词或短语。
词性标注：标识每个单词在句子中的词性（如名词、动词、形容词等）。
句法分析：解析句子的语法结构，包括依存关系和短语结构分析。
2. 文本分类 情感分析：检测文本中的情感倾向，如积极、中立或消极。
主题建模：识别文本中的主题或隐藏的语义结构。
垃圾邮件过滤：检测并过滤电子邮件中的垃圾内容。
3. 信息提取 命名实体识别（NER）：识别文本中的实体，如人名、地名、组织等。
关系抽取：从文本中提取实体之间的关系。
事件抽取：识别和分类文本中的事件信息。
4. 机器翻译 自动翻译：将文本从一种语言翻译成另一种语言，如 Google 翻译。
5. 文本生成 语言生成：生成与输入语义相关的自然语言文本。
摘要生成：从长文本中提取关键内容生成摘要。
6. 对话系统 聊天机器人：与用户进行自然语言对话，如客服机器人。
智能助理：提供信息查询、任务管理等服务，如 Siri、Alexa。
主要技术和方法 1. 统计方法 早期的 NLP 方法主要依赖于统计模型，如 n-gram 模型、隐马尔可夫模型（HMM）和条件随机场（CRF），用于各种语言处理任务。
2. 机器学习 传统机器学习方法，如支持向量机（SVM）、朴素贝叶斯、决策树等被广泛应用于文本分类、情感分析等任务。
3. 深度学习 近年来，深度学习技术在 NLP 中取得了显著进展，主要包括：
循环神经网络（RNN）：特别是长短期记忆（LSTM）和门控循环单元（GRU）被用于处理序列数据，如文本生成和机器翻译。
卷积神经网络（CNN）：用于文本分类和句子建模。
Transformer：由 Google 提出的 Transformer 结构及其衍生模型（如 BERT、GPT）在多种 NLP 任务中表现优异。
工具和库 NLTK：Python 的自然语言处理库，提供丰富的工具和资源。
spaCy：高效的 NLP 库，适用于工业应用。
Gensim：用于主题建模和文档相似性计算的库。
Transformers：Hugging Face 提供的库，包含多种预训练模型，如 BERT、GPT 等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/beb63c9a9561f205b90df03a67906a41/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/169/">«</a>
	<span class="pagination__item pagination__item--current">170/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/171/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>