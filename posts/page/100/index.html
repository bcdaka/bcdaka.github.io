<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c1eaafbef563841b786056d6e1d79d4/" rel="bookmark">
			Langchain--如何使用大模型 2.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【🍊易编橙·终身成长社群🍊】
大家好，我是小森( ﹡ˆoˆ﹡ ) ！ 易编橙·终身成长社群创始团队嘉宾，橙似锦计划领衔成员、阿里云专家博主、腾讯云内容共创官、CSDN人工智能领域优质创作者 。 Langchain使用大模型 我们除了可以使用Langchain进行模型对话、提示词创作、嵌入模型，还可以使用其他的组件对大模型封装使用，打造我们自己的大模型。
Agents 首先，我们来谈谈Agents。在Langchain，Agents是执行特定任务或功能的智能实体。它们可以被看作是自动化的小助手，能够根据预设的规则和逻辑，在Langchain生态系统中自主地执行操作。比如，有的Agent负责监控区块链上的交易活动，有的则负责处理语言任务，如文本生成、翻译或情感分析等。这些Agent的存在，极大地提高了Langchain系统的自动化程度和效率。
AI大模型虽然很强大，但是还有一些局限性，比如：
数据不及时：ChatGPT数据更新到2022年底，也就是说今年的新闻它是不知道的。处理复杂任务：大模型虽然在问答方面很出色，但是不能直接处理复杂任务。大模型的核心能力是理解意图和文本生成。 我们在使用Langchain的时候，可以通过pycharm的某个函数，Ctrl + b 查看提供的参数，也可以去Langchain官网查看提供的各种API，如我们之前使用的baiduqianfan：
可以看到LLMs是我们的LLMs模块，BaiduQianfan是其中的库。
其中：ERNIE-Bot-turbo是默认的模型（文心一言 ），也可以使用其他的模型，比如：Qianfan-Chinese-Llama-2-7B，是通过Llama微调的中文大模型。
我们先假设，想要查询山东省2023年高考人数有多少，我们可以使用多个代理工具，让Agents选择执行。
pip install duckduckgo-search 集成DuckDuckGo搜索引擎的功能，可以去浏览器搜索并集成信息。 import os from langchain_community.chat_models import QianfanChatEndpoint from langchain.agents import load_tools from langchain.agents import initialize_agent from langchain.agents import AgentType os.environ['QIANFAN_AK'] = "******" os.environ['QIANFAN_SK'] = "******" llm = QianfanChatEndpoint(model='Chinese-Llama-2-7B') tools = load_tools(["ddg-search", "llm-math"], llm=llm) agent = initialize_agent(tools, llm, agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=True) # verbose=True参数是在执行任务时打印更多的调试信息。 print('agent', agent) from langchain import PromptTemplate prompt_template = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c1eaafbef563841b786056d6e1d79d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84e38505ae97b10ca7d1ecc4761dfca8/" rel="bookmark">
			x-cmd pkg | yazi - 超快终端文件管理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 简介快速入门功能特点竞品和相关项目进一步阅读 简介 yazi 是由 github.com/sxyazi 用 Rust 开发的终端文件管理器，支持预览文本文件、pdf 文件、图像、视频，内置代码高亮功能。在内部，它使用 Tokio 作为其异步运行时，以非阻塞（事件驱动）的方式处理任务，效率高响应快。
TIP:
Yazi 采用了特殊的 Unicode 符号来标识各种类型的文件，这需要终端使用的字体中包含正确的字形才能正常显示。
官方推荐使用 nerd-fonts 字体，你可以从 Nerd Fonts project 网站中获取它。
快速入门 启动 yazi：
eval "$(curl https://get.x-cmd.com)" # 安装 x-cmd x env use yazi # 安装 yazi yazi # 直接启动 yazi EDITOR='nvim' yazi # 设定 nvim 为 yazi 默认使用的文本编辑器并启动 yazi Tip:
Linux/macOS：需要使用 $EDITOR 指定 yazi 调用的文本编辑器。Windows：没有 $EDITOR 的概念，用户需要根据需要修改文本打开器。 常用快捷键：
目录导航： j：向下移动光标k：向上移动光标h：返回上一级目录l：进入选中目录 处理文件： d：删除选中文件x：剪切选中文件y：复制选中文件p：粘贴文件r：重命名文件 其他： .：显示隐藏文件q：退出~：打开帮助Z：使用 fzf 跳转到目录或显示文件（需要安装 fzf ） yy shell 包装器，它能提供在退出 yazi 时更改当前工作目录的功能：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84e38505ae97b10ca7d1ecc4761dfca8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fc156f0d01b6813c554ad8ad6fe2c8e/" rel="bookmark">
			javafx的ListView代入项目的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 创建一个可观察的列表，用于存储ListView中的数据,这里的User是包装了用户的相关信息。
2.通过本人id获取friendid，及好友的id，然后用集合接送，更方便直观一点。
3.用for遍历集合，逐个添加。
4.渲染器（ImageCellFctoryFriendList）定制
5.渲染器具体方法如下：
1. 创建一个可观察的列表，用于存储ListView中的数据,这里的User是包装了用户的相关信息。 // 创建一个可观察的列表，用于存储ListView中的数据 ObservableList&lt;User&gt; friendList = FXCollections.observableArrayList(); 记得把javafx的你需要使用的ListView命名
2.通过本人id获取friendid，及好友的id，然后用集合接送，更方便直观一点。 ​ List&lt;User&gt; ren = (List&lt;User&gt;) Connection.ois.readObject();//我的id，好友id及添加时间 ​ 3.用for遍历集合，逐个添加。 for (User user : ren) { sitItems展示我添加的好友信息（项目中我只展示了好友的头像，昵称及在线状态）
​ this.friendListview.setItems(this.friendList); this.friendList.add(person); ​ 最后，通过setCellFctory（渲染器）展示控件的每个单元格，并且它可以允许你为每个单元格提供一个定制的渲染器，这里我定制的渲染器为ImageCellFctoryFriendList（方法名自定义），为自定义函数，格式需要一样，但是内容可以自定义。
this.friendListview.setCellFactory(new ImageCellFactoryFriendList()); 4.渲染器（ImageCellFctoryFriendList）定制 具体代码在本文章的最后！！！
这里先获取需要的用户信息，然后进行展示，两个50分别为展示头像的长和宽。
//更新单元格内容 String username = listviewmember.name;//获取用户名 String imagePath = listviewmember.image;//获取用户头像 int online = listviewmember.online; // 获取用户在线状态 //显示头像 File imageFile = new File(imagePath); Image images = new Image(imageFile.toURI().toString()); this.imageView.setFitWidth(50.0); this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fc156f0d01b6813c554ad8ad6fe2c8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10fcf4356bf399ba3ed5911a5ac22991/" rel="bookmark">
			OpenCV库学习之cv2.threshold函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenCV库学习之cv2.threshold函数 一、简介 cv2.threshold是OpenCV库中用于实现图像二值化处理的函数。此函数可以将图像转换为二值图像，即像素值只包含0和最大值（通常是255）的图像。这种转换常用于图像的预处理和特征提取，尤其是在边缘检测和轮廓发现中。
二、语法和参数 ret, dst = cv2.threshold(src, thresh, maxval, type[, dst]) 参数:
src：源图像，必须是单通道灰度图像。thresh：阈值，用于确定像素是否应该被视为前景或背景。maxval：二值化操作中使用的最大值，通常设为255。type：阈值类型，定义了多种二值化方法，包括： cv2.THRESH_BINARY：简单二值化。cv2.THRESH_BINARY_INV：反向二值化。cv2.THRESH_TRUNC：截断二值化，所有高于阈值的像素被设为阈值。cv2.THRESH_TOZERO：高于阈值的像素被设为0。cv2.THRESH_TOZERO_INV：低于阈值的像素被设为0。cv2.THRESH_OTSU：使用Otsu’s方法自动确定阈值。cv2.THRESH_TRIANGLE：使用三角方法自动确定阈值。 dst：（可选）目标图像，用于存储二值化结果。 返回值：
ret：返回的阈值，对于自动阈值方法（如cv2.THRESH_OTSU），返回计算得到的阈值。dst：二值化后的图像。 三、实例 3.1 简单二值化 import cv2 # 读取灰度图像 image = cv2.imread('path_to_image.jpg', cv2.IMREAD_GRAYSCALE) # 应用二值化 _, binary_image = cv2.threshold(image, 127, 255, cv2.THRESH_BINARY) # 显示二值化后的图像 cv2.imshow('Binary Image', binary_image) cv2.waitKey(0) cv2.destroyAllWindows() 输出：
图像中像素值高于127的变为255，其余变为0。
3.2 自动阈值二值化（Otsu’s方法） import cv2 # 读取灰度图像 image = cv2.imread('path_to_image.jpg', cv2.IMREAD_GRAYSCALE) # 应用Otsu's方法自动二值化 ret, binary_image = cv2.threshold(image, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU) # 显示二值化后的图像 cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10fcf4356bf399ba3ed5911a5ac22991/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78177fd6405799f4e6e9c7bc39b2a636/" rel="bookmark">
			typescript 断言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/* 断言 确定后期一定是某种格式 可用于表单大对象初始化是空，赋值时有具体字段。前期断言是会是某种格式 */ interface obj { name: string location: string age?: number } // 会报错 // let data: obj = { // // } let data: obj = { } as obj; // 断言data会有obj里的字段 data.name = "全易"; data.location = "北京"; data.age = 18 interface fnT { (n: number): string title: string age?: number } let fn: fnT = function (n: number) { return "123" } as fnT; // 断言后面会添加title fn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78177fd6405799f4e6e9c7bc39b2a636/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c50896405b04ebc81fffc2c4ca582271/" rel="bookmark">
			el-ui 导航菜单重复点击报错问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 重复点击菜单报错 NavigationDuplicated: Avoided redundant navigation to current location: xxxxx
解决办法:
路由文件.js最下边加入这段代码
//NavigationDuplicated: Avoided redundant navigation to current location 解决重复点击路由报错 // 重写路由push方法 const originalPush = Router.prototype.push Router.prototype.push = function push(location) { return originalPush.call(this, location).catch(err =&gt; err) }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/604de445908840a9ff9228bcc7797b57/" rel="bookmark">
			Java中的二叉搜索树（如果想知道Java中有关二叉搜索树的知识点，那么只看这一篇就足够了！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：Java 提供了丰富的数据结构来处理和管理数据，其中 TreeSet 和 TreeMap 是基于红黑树实现的集合和映射接口。它们有序地存储数据，提供高效的搜索、插入和删除操作。
✨✨✨这里是秋刀鱼不做梦的BLOG
✨✨✨想要了解更多内容可以访问我的主页秋刀鱼不做梦-CSDN博客
先让我们看一下本文大致的讲解内容：
目录
1.二叉搜索树的认识
（1）二叉搜索树的概念
（2）二叉搜索树的性质
2.有关二叉搜索树的常用操作
【1】插入操作
【2】查找操作
【3】删除操作
1.cur.left == null
2.cur.right == null
3.cur.left != null &amp;&amp; cur.right != null
3.二叉树的应用场景
1. 数据结构和算法
2. 数据库和文件系统
3. 图形和游戏开发
1.二叉搜索树的认识 （1）二叉搜索树的概念 在开始学习TreeSet与TreeMap之前，我们需要先学习一下Java中的二叉搜索树，二叉搜索树是一种特殊的二叉树，其中每个节点都有一个值，并满足以下性质：
对于每个节点，左子树所有节点的值都小于该节点的值。
对于每个节点，右子树所有节点的值都大于该节点的值。
如图：
从上图中我们可以很明显的观察出二叉搜索树的上述两个特性。
（2）二叉搜索树的性质 在了解完了二叉搜索树的概念之后，我们需要学习一下有关二叉搜索树的性质，对于一棵二叉搜索树而言，其都有以下三个性质：
有序性：二叉搜索树的中序遍历结果是一个递增的有序序列。
动态性：二叉搜索树支持动态插入和删除操作，适用于需要频繁更新的数据集合。
查找效率：在理想情况下，二叉搜索树的查找、插入和删除操作的时间复杂度为 O(log n)。
——这里读者可能会对其中的一些性质不是很理解，没有关系，继续向下进行阅读即可，在后续的文本中，我们会慢慢的理解其中的意思。
2.有关二叉搜索树的常用操作 【1】插入操作 插入操作用于向二叉搜索树中插入新值。插入过程从根节点开始，根据当前节点的值与新值的比较结果，决定将新值插入到左子树还是右子树。
以下是实现该操作的代码：
public void insertNode(int key) { // 如果根节点为空，直接插入新节点作为根节点 if (root == null) { root = new TreeNode(key); return; } // 初始化当前节点为根节点，父节点为null TreeNode cur = root; TreeNode parent = null; TreeNode node = new TreeNode(key); // 寻找合适的位置插入节点 while (cur !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/604de445908840a9ff9228bcc7797b57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05b633fb58f2512d952ad1c37cdd2fc2/" rel="bookmark">
			Laravel路由模型绑定：简化依赖注入的艺术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Laravel路由模型绑定：简化依赖注入的艺术 引言 在现代Web应用开发中，Laravel框架以其优雅和简洁的代码而闻名。Laravel的路由模型绑定（Route Model Binding）是框架提供的一项强大功能，它允许开发者在路由处理中自动注入模型实例，从而简化控制器的依赖注入过程。本文将深入探讨路由模型绑定的概念、优势以及如何在实际项目中应用这一技术。
路由模型绑定简介 路由模型绑定是一种在Laravel路由中自动解析和注入模型对象到控制器方法的技术。这意味着，当一个请求到达时，Laravel会自动查找与给定路由参数匹配的模型实例，并将其传递给控制器方法，而无需手动查询数据库。
为什么使用路由模型绑定？ 简化代码：减少手动查询数据库和传递模型实例的代码。提高效率：自动解析模型，减少开发时间，提高开发效率。降低错误率：自动注入减少了因手动查询错误导致的问题。 如何使用路由模型绑定 1. 定义路由 在routes/web.php或routes/api.php文件中定义路由，并使用{model}占位符来指明需要模型绑定的参数。
Route::get('users/{user}', 'UserController@show'); 2. 创建隐式模型绑定 Laravel允许你创建自定义的模型绑定，通过在控制器中定义一个$model属性。
namespace App\Http\Controllers; use App\Models\User; class UserController extends Controller { protected $model; public function __construct() { $this-&gt;model = User::class; } } 3. 使用显式模型绑定 在控制器的方法中，直接类型声明需要模型绑定的参数。
public function show(User $user) { return view('user.profile', compact('user')); } 4. 定义自定义模型绑定 如果需要更复杂的模型绑定逻辑，可以定义一个服务提供者或使用已有的服务提供者。
use Illuminate\Routing\RouteCollection; public function boot() { $this-&gt;app-&gt;booted(function () { $this-&gt;app['router']-&gt;bind('custom', function ($value) { // 定义自定义的模型绑定逻辑 return CustomModel::where('key', $value)-&gt;firstOrFail(); }); }); } 然后在路由中使用自定义的模型绑定：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05b633fb58f2512d952ad1c37cdd2fc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c9eac1e747cefcb55d1fa5660d48cb9/" rel="bookmark">
			7月29（信息差）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌍最强模型 Llama 3.1 如期而至！扎克伯格最新访谈：Llama 会成为 AI 界的 Linux 🎄谷歌AlphaProof攻克国际奥赛数学题 https://www.51cto.com/article/793632.html
✨SearchGPT第一波评测来了！响应速度超快还没广告，“OpenAI杀手锏” 1.PyTorch 2.4 携手 Python 3.12：开启深度学习新纪元 在这个日新月异的时代，人工智能与机器学习技术正以前所未有的速度推动着各行各业的变革。作为深度学习领域的两大重量级工具——PyTorch与Python，它们的每一次更新都牵动着无数开发者与科研人员的心弦。近日，PyTorch 2.4正式携手Python 3.12震撼发布，这一组合不仅标志着技术栈的又一次飞跃，更为深度学习领域的创新与发展注入了新的活力。本文将深入解析PyTorch 2.4与Python 3.12的亮点特性，探讨它们如何共同开启深度学习的新纪元。
一、PyTorch 2.4：深度学习的加速器 1. 性能优化与效率提升 PyTorch 2.4在性能优化方面下足了功夫，通过引入一系列底层优化和算法改进，显著提升了模型的训练速度和推理效率。具体而言，新版本优化了CUDA内核的执行路径，减少了内存访问延迟，使得在GPU上的计算更加高效。同时，针对分布式训练场景，PyTorch 2.4增强了通信库的功能，降低了节点间的通信开销，使得大规模模型训练更加流畅。
2. 更强大的API与扩展性 为了满足日益增长的用户需求，PyTorch 2.4在API设计上进行了全面升级，新增了众多实用功能和高级模块。例如，新增的自动混合精度（Automatic Mixed Precision, AMP）功能，能够自动管理模型的精度设置，以较小的精度损失换取显著的速度提升，这对于资源受限环境下的深度学习应用尤为重要。此外，PyTorch 2.4还加强了与第三方库和框架的集成，如TensorBoard、ONNX等，进一步提升了其扩展性和兼容性。
3. 简化模型开发与部署 PyTorch 2.4在模型开发与部署流程上进行了大幅简化。通过引入更直观的模型定义方式和更便捷的模型导出工具，开发者可以更加轻松地构建、训练和部署深度学习模型。同时，新版本还加强了对移动端和嵌入式设备的支持，使得深度学习应用能够更广泛地服务于社会各个领域。
二、Python 3.12：编程语言的进化 1. 性能提升与内存管理 Python 3.12在性能提升方面取得了显著进展。通过优化解释器内部结构和算法，新版本在执行速度上有了显著提升。同时，Python 3.12引入了更精细的内存管理机制，减少了内存泄漏和碎片化问题，提高了程序的稳定性和可靠性。这些改进为运行大型深度学习模型提供了坚实的基础。
2. 新特性与语法糖 Python 3.12在保持语言简洁性的同时，也加入了一些新特性和语法糖，进一步提升了编程的便捷性和效率。例如，新增的“结构化模式匹配”（Structural Pattern Matching）功能，允许开发者以更直观的方式处理复杂的数据结构；而“参数化泛型”（Parametric Generics）的引入，则增强了类型系统的灵活性和表达能力。这些新特性为深度学习模型的编写和调试带来了诸多便利。
3. 生态系统与兼容性 Python 3.12的发布不仅带来了语言层面的改进，还推动了整个生态系统的进步。随着新版本的普及，越来越多的第三方库和框架开始支持Python 3.12，为开发者提供了更丰富的选择。同时，Python 3.12在保持向后兼容性的同时，也鼓励开发者采用更加现代和高效的编程范式和工具链。
三、PyTorch 2.4与Python 3.12的协同作用 PyTorch 2.4与Python 3.12的联合发布，不仅仅是两个独立软件的简单叠加，更是深度学习与编程语言技术进步的深度融合。它们之间的协同作用体现在以下几个方面：
性能加速：PyTorch 2.4的性能优化与Python 3.12的性能提升相得益彰，共同为深度学习模型的训练和推理提供了强大的动力。无论是单GPU训练还是多节点分布式训练，都能获得显著的速度提升。开发效率：PyTorch 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c9eac1e747cefcb55d1fa5660d48cb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab05938845532dc69473150b92314018/" rel="bookmark">
			【C&#43;&#43;11】C&#43;&#43;11新纪元：深入探索右值引用与移动语义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📝个人主页🌹：Eternity._
⏩收录专栏⏪：C++ “ 登神长阶 ”
🤡往期回顾🤡：位图与布隆过滤器
🌹🌹期待您的关注 🌹🌹
❀C++11 📒1. C++11简介📜2. 统一的列表初始化🌸{ }初始化🌺initializer_list 📚3. decltype与新容器 array🎩decltype🎈新容器 array 📝4. 右值引用和移动语义⛰️左值引用和右值引用🌄左值引用与右值引用比较🌞右值引用使用场景和意义⭐完美转发 📙5. 新的类功能📖6. 总结 前言：在C++的悠久历史中，每一次标准的更新都如同为这门强大的编程语言注入了新的活力。C++11，作为这一进程中的一个重要里程碑，不仅带来了众多新特性，还深刻改变了C++编程的范式，其中右值引用（Rvalue References）无疑是最为引人注目的特性之一
在传统的C++编程中，我们习惯于通过左值（Lvalues）来引用和操作对象，这些左值通常指向具有持久身份的对象。然而，随着C++应用的日益复杂和对性能要求的不断提高，如何高效地处理临时对象（即右值，Rvalues）成为了亟待解决的问题。C++11引入的右值引用，正是为了填补这一空白，它允许我们直接引用即将被销毁的临时对象，从而开启了C++编程的新纪元
本篇将带您深入探索C++11中的右值引用及其相关特性，包括移动语义（MoveSemantics）、完美转发（Perfect Forwarding）等。我们将从基础概念讲起，逐步深入到实际应用和最佳实践，旨在帮助您全面理解并掌握这一强大的编程工具
让我们一起踏上学习的旅程，探索它带来的无尽可能！
📒1. C++11简介 C++11是C++编程语言的一个重大更新版本，也被称为C++标准第三版，正式名称为ISO/IEC 14882:2011 - Information technology – Programming languages – C++
相比于C++98/03，C++11则带来了数量可观的变化，其中包含了约140个新特性，以及对C++03标准中约600个缺陷的修正，这使得C++11更像是从C++98/03中孕育出的一种新语言。相比较而言，C++11能更好地用于系统开发和库开发、语法更加泛华和简单化、更加稳定和安全，不仅功能更强大，而且能提升程序员的开发效率，公司实际项目开发中也用得比较多，所以我们要作为一个重点去学习
C++11标准的发布对C++编程产生了深远的影响，推动了C++语言的现代化和性能提升。随着各大主流编译器（如GCC、Clang、MSVC等）对C++11语法的支持逐渐完善，越来越多的项目开始采用C++11标准进行开发。同时，相关的技术书籍和教程也相继更新，以支持C++11的新特性
总之，C++11是C++编程语言发展历程中的一个重要里程碑，它带来了众多新特性和改进，为C++程序员提供了更加强大和灵活的工具来编写高效、可维护的代码
C++11介绍
📜2. 统一的列表初始化 在C++11及以后的版本中，引入了统一的列表初始化（Uniform Initialization）或称为初始化列表（Initialization List），这是一种新的初始化语法，使用大括号{}来初始化变量。统一的列表初始化不仅提高了代码的一致性和可读性，还解决了之前初始化语法中的一些歧义和限制
🌸{ }初始化 在C++98中，标准允许使用花括号{}对数组或者结构体元素进行统一的列表初始值设定
代码示例 (C++)：
// C++98 struct Pxt { int _x; int _y; }; int main() { Pxt p = { 1, 2 }; return 0; } C++11扩大了用大括号括起的列表(初始化列表)的使用范围，使其可用于所有的内置类型和用户自定义的类型，使用初始化列表时，可添加等号(=)，也可不添加
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab05938845532dc69473150b92314018/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dbcfbca19c60aee1bc3efbf6fb68f17/" rel="bookmark">
			保姆级教程 ！SQL Server数据库的备份和还原
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 SQL Server Management Studio (SSMS) 备份和还原数据库 1、数据库备份 Step 1
打开 SSMS 输入server name 以及用户名和密码连接到你的 SQL Server 实例
Step 2
展开Database,选中你要备份的数据库
Step 3
右击选中的数据库，点击Tasks --&gt; Back Up
Step 4
点击Remove，删除默认备份地址
Step 5
点击Add
Step 6
点击 … ，去浏览本地目录。
Step 7
选择一个目录用来保存备份文件，并填写备份文件的文件名，要以.bak结尾，并点击OK
Step 8
一直点击OK
Step 9
出现如下提示，则说明去数据库备份成功。
Step 10
在Step 7选中的目录下面即可找到备份的数据库文件。
2、数据库还原 Step 1
打开 SSMS 输入server name 以及用户名和密码连接到你的 SQL Server 实例
Step 2
右击Database，点击New Database
Step 3
输入你想要的数据库名字，并点击OK
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dbcfbca19c60aee1bc3efbf6fb68f17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/169dc899883e4bf5574753f503745a9f/" rel="bookmark">
			极致的灵活度满足工程美学：用Vue Flow绘制一个完美流程图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
极致的灵活度满足工程美学：用Vue Flow绘制一个完美流程图
一、环境要求
二、初识Vue Flow
2.1、安装Vue Flow
2.2、Vue Flow构成
2.3、一个小坑
2.4、入门案例
三、Vue Flow优秀的自定义功能
3.1、引入
3.2、节点与连线的自定义
①打样（做模板）
②模版取名
③替换模版
3.3、节点与连线的事件
①节点事件
②连线事件
3.4、句柄（handles）
四、一个优质的案例
五、总结
极致的灵活度满足工程美学：用Vue Flow绘制一个完美流程图 Vue Flow的入门门槛要高不少，毕竟找不到中文文档，反正我是不太喜欢看纯英文的文档的。不过没关系，看完这篇还用不好Vue Flow请来找我麻烦。
一、环境要求 Node.js v20 或更高版本
Vue 3.3 或更高版本
前者，没有装nvm建议装一个nvm，noder没有nvm是行不通的。后者意味着Vue Flow不支持Vue2，据说有些辅助组件可以让部分功能在Vue中使用。
Tips:
如果把我的源码抄过去都跑不动，要么是依赖没有装好，要么是依赖的版本不对，Vue Flow的版本更迭是会伴随着API的更迭的，所以可以安装特定版本的Vue Flow来解决问题。我的Vue Flow版本是：​v1.39.0​
package.json：
"@vue-flow/background": "^1.3.0",
"@vue-flow/controls": "^1.1.2",
"@vue-flow/core": "^1.38.5",
"@vue-flow/minimap": "^1.5.0",
二、初识Vue Flow 2.1、安装Vue Flow 根据自己的包管理器安装
不习惯用add就用install，也没问题
npm add @vue-flow/core
pnpm add @vue-flow/core
yarn add @vue-flow/core
2.2、Vue Flow构成 在 Vue Flow 中，图由节点和边组成，每个节点或边都需要一个唯一的ID，节点还需要 XY 位置，而边需要 source 和 target 节点 ID，具体参照下方示例中的数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/169dc899883e4bf5574753f503745a9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55d53ac0424afcee0acb8fe90dfe92f5/" rel="bookmark">
			【C&#43;&#43;/STL】：哈希 -- 线性探测&amp;哈希桶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 💡前言一，unordered系列容器二，哈希2.1 哈希的概念2.2 哈希函数2.3 哈希冲突 三，哈希冲突解决(重点)3.1 开放定址法3.2 哈希桶(重点) 四，线性探测的实现4.1 线性探测的基本框架4.2 插入操作4.3 查找操作4.4 删除操作 五，哈希桶的实现(重点)5.1 哈希桶的基本框架5.2 插入操作5.3 查找操作5.4 删除操作 六，优化思考 点击跳转至文章： 【C++/STL】：set和map的介绍及基本使用 💡前言 在C++98中，STL提供了底层为红黑树结构的一系列关联式容器，在查询时效率可达到 l o g 2 N log_2 N log2​N，即最差情况下需要比较红黑树的高度次。
在C++11中，STL又提供了4个unordered系列的关联式容器，这四个容器与红黑树结构的关联式容器使用方式基本类似，只是其底层结构不同，unordered系列的底层是哈希表。
本篇文章的内容是学习unordered系列的容器，重点学习什么是哈希，知道什么是哈希冲突，并且掌握解决哈希冲突的两种常用方法：线性探测&amp;哈希桶。
一，unordered系列容器 unordered系列容器有4个：
(1) unordered_map
(2) unordered_set
(3) unordered_multimap
(4) unordered_multiset
它们与 map/set 系列容器的核心功能的重叠度90%，使用方法基本类似，这里不再重复演示。最主要的区别是：遍历unordered系列容器中存储的数据是无序的，并且就性能而言，unordered系列容器在插入，查找，删除方面时间复杂度是 O(1)。因此在平时，我们更加推荐使用unordered系列容器。
二，哈希 2.1 哈希的概念 构造一种存储结构，通过某种函数(hashFunc)使元素的存储位置与元素之间能够建立一一映射的关系，那么在查找时通过该函数可以很快找到该元素。
该方式即为哈希(散列)方法，哈希方法中使用的转换函数称为哈希(散列)函数，构造出来的结构称为哈希表(Hash Table)(或者称散列表)
2.2 哈希函数 这里介绍两种常见的哈希函数：直接定址法和除留余数法。
(1) 直接定址法：用 key 值直接在哈希表中映射一个绝对位置或相对位置。
优点：快，无冲突。
缺点：要事先知道 key 值的分步情况，并且适用于范围集中的数据。
(2) 除留余数法：用 key 值模(%)表的大小 N，利用得到的余数(0 ~ N-1)把 key 值映射到表中的位置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55d53ac0424afcee0acb8fe90dfe92f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0058a709e3809c2b39ef7d0d6a7192be/" rel="bookmark">
			二、八、十、十六进制介绍及相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、引言：
2、进制介绍及区分
2.1 介绍
2.2 区分
2.3 各进制的数字组成
3、2进制与10进制
3.1 十进制的介绍
3.2 二进制的介绍
4、2进制与10进制的转换
4.1 二进制转十进制
4.2 十进制转二进制
5、8进制和16进制
5.1 八进制的介绍
5.2 十六进制的介绍
6、2进制转8进制和16进制
6.1 二进制转八进制
6.2 二进制转十六进制
7、8进制和16进制转2进制
8、结语：
1、引言： 关于二进制、八进制、十进制、十六进制，相信大家都曾有过一些了解。然而，或许您对这些进制并没有深入的理解。接下来，本文将带您深入了解这些数制，让您对它们有更清晰的认知，并掌握它们之间的转换方法。
2、进制介绍及区分 2.1 介绍 二进制，八进制，十进制，十六进制指的是数值的不同表示形式。
举个例子：
假设数值就是我自己，无论处于何种情境，我的本质始终如一。就像在不同的场景中我有着不同的身份，在学校我是学生，在家里我是子女，在公司我是员工，在战场我是战士。无论我在学校、家里、公司还是战场，我这个人的本质是不变的。只是因为所处的“环境规则”不同，导致了外在的表现形式有所差异。
比如说：数值15的各种进制表示形式：
1：15 的 2 进制：1111
2：15 的 8 进制：17
3：15 的 10 进制：15
4：15 的 16进制：F
尽管‘1111’ ‘17’ ‘15‘ ’F‘形式不同，但是他们都是指的是15这个数值。
2.2 区分 在上面的例子中，我们可以看到8进制的17和2进制的15实际上是相等的。如果没有事先告诉我们，只给出17和15这两个数，我们该如何区分它们是8进制还是2进制呢？同样地，16进制的 F 和字符 F 又该如何区分呢？如果我们无法区分，那么计算机也无法识别它们。因此，我们需要一种方法来标记这些数字的进制，以确保计算机能够正确地识别它们。
因此，在计算机上写八进制和十六进制的数值时，需要一些标记：
16进制的数值之前写：0x8 进制的数值之前写：0 这样在输入到计算机的时候，计算机就可以很轻易的区分输入的值是上面形式了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0058a709e3809c2b39ef7d0d6a7192be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0841b7a82d9924aab43dc837ef79e16/" rel="bookmark">
			Cordova从0到1开始打包APP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		截至2024-07-23为止我的绝对是最新的，直接上步骤
（
成功条件：
1：java17（低了高了都不行测试版本20，18，11）
2：gradle-8.7（低了高了都不行测试版本8.9，8.3）
3：android studio 2024.1.1
4：VPN（必需品 Pig Farm）
）
1：环境部署
1.1：java的jdk：一定要18.0.0的不要以上的，android不兼容，链接兄弟们就自己找个吧
1.2：android studio： Android 移动应用开发者工具 – Android 开发者 | Android Developers
下载步骤直接随便找个博客跟着走就行，新版的跟旧版的差了几步但是不碍事
1.3：Cordova（新版的android studio从2024.1.1就开始不支持内置Cordova了 因为我的就是这个版本）
Gradle | Releases
直接下载二进制的8.7版本就行，8.9版本的不兼容
1.4：环境变量
_JAVA_OPTIONS：-Xmx512M
JAVA_HOME C:\Program Files\Java\jdk-17 (下面文章有解释)
path：
C:\Users\my\AppData\Local\Android\Sdk\gradle-8.7\bin（自己下载的路径）
GRADLE_HOME：C:\Users\my\AppData\Local\Android\Sdk\gradle-8.7\bin
2：创建项目
npm i -g cordova cordova create hello com.example.hello HelloWorld cd hello 添加编译 环境
cordova platform add ios cordova platform add android 检查编辑环境
cordova platform ls 检查环境（安装的jdk等东西）
cordova requirements 如果按照我说的版本去安装绝对没问题，如果出了问题评论区留言
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0841b7a82d9924aab43dc837ef79e16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdb459eabc91bd1fdf08cc3d99cfc9dc/" rel="bookmark">
			记一次因为在html两个地方引入vue.js导致组件注入失败的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个问题我遇到两次了，是在恼火，不对，三次了，我如果不做这个笔记，我确定我还会遇到第三次。
尾部这个去掉就行
因为头部有了
遇到这种bu g好恼火，解决了又怎么样呢？重蹈覆辙的滋味不好受
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a77ee53061ba8df3d8205a90ece45100/" rel="bookmark">
			Chrome谷歌浏览器Console（控制台）显示文件名及行数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有没有这样的困扰？Chrome谷歌浏览器console(控制台)不显示编译文件名及行数? 设置（Settings）- &gt; 忽略列表（lgnore List）-&gt; 自定义排除规则（Custom exclusion rules）
将自定义排除规则（Custom exclusion rules）里的“/node_modules/|/bower_components/”选项删除或者去掉选中状态
或者将
设置（Settings）- &gt; 忽略列表（lgnore List）-&gt; 启用忽略清单（Enable lgnore Listing ）取消选中​​​​​​​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a79255e35d53b9883b60ccbe57c6d5f/" rel="bookmark">
			【C&#43;&#43;】红黑树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页：秦jh_-CSDN博客
🔥 系列专栏：https://blog.csdn.net/qinjh_/category_12575764.html?spm=1001.2014.3001.5482
​ 目录
前言
红黑树的概念
红黑树的性质
节点的定义
红黑树的插入操作 检测操作：
情况一: cur为红，p为红，g为黑，u存在且为红
情况二: cur为红，p为红，g为黑，u不存在/u存在且为黑 Insert 代码
红黑树的验证
红黑树与AVL树的比较
完整代码
前言 💬 hello! 各位铁子们大家好哇。
今日更新了红黑树的相关内容
🎉 欢迎大家关注🔍点赞👍收藏⭐️留言📝
红黑树的概念 红黑树，是一种二叉搜索树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或 Black。 通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。
红黑树的性质 每个结点不是红色就是黑色 根节点是黑色的 如果一个节点是红色的，则它的两个孩子结点是黑色的。(不存在连续的红节点) 对于每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点(每条路径都存在相同数量的黑色节点) 每个叶子结点都是黑色的(此处的叶子结点指的是空结点) 注意：这里的叶子节点指的是空节点，也就是上图中的NIL节点。NIL节点也方便我们数路径，有几个NIL节点，就有几条路径。 最长路径&lt;=最短路径*2 （最长路径就是一红一黑间隔，最短路径就是全黑）
节点的定义 红黑树的插入操作 红黑树是在二叉搜索树的基础上加上其平衡限制条件，因此红黑树的插入可分为两步：
按照二叉搜索的树规则插入新节点检测新节点插入后，红黑树的性质是否造到破坏 新节点的默认颜色是红色，因此：如果其父亲节点的颜色是黑色，没有违反红黑树任何性质，则不需要调整；但当新插入节点的父亲节点颜色为红色时，就违反了性质三不能有连在一起的红色节点，此时需要对红黑树分情况来讨论。
检测操作： 约定:cur为当前节点，p为父节点，g为祖父节点，u为叔叔节点
情况一: cur为红，p为红，g为黑，u存在且为红 上图是抽象图，a/b/c/d/e代表每条路径有x个黑色节点的红黑子树，且x&gt;=0。 注意：这里所看到的树，可能是一棵完整的树，也可能是一棵子树。
假设此时x==0，cur就是新增节点。
解决方式：将p,u改为黑，g改为红，然后把g当成cur，继续向上调整。
如果g是根节点，调整完成后，将g改成黑色。
如果g是子树，g一定有父亲，如果父亲是红色，就继续往上调整，如果父亲是黑，就结束。
如果x==1，c/d/e就是m/n/p/q四种组合之一。此时新增节点的位置就是a和b的孩子之一。 方法跟上面x==0的情况一样。
情况二: cur为红，p为红，g为黑，u不存在/u存在且为黑 说明：u的情况有两种：
若u不存在，则cur就是新插入节点。因为如果cur不是新插入节点，cur和p一定有一个节点是黑色的，就不满足性质4：每条路径的黑色节点个数相同。若u存在且为黑，则 cur原来的颜色一定是黑的，现在看到是红色是因为cur子树在调整过程中将cur的颜色由黑色改成红色，如下图： 解决方式：
p为g的左孩子，cur为p的左孩子，则进行右单旋转；
相反， p为g的右孩子，cur为p的右孩子，则进行左单旋转
p、g变色--p变黑，g变红
情况二的双旋情况：
解决方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a79255e35d53b9883b60ccbe57c6d5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88e5e7190cf2c0fcccc354bbbfdeff8e/" rel="bookmark">
			Stable Diffusion模型训练：从数据准备到模型优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Stable Diffusion模型训练：从数据准备到模型优化 开篇引入：探索创意无限的Stable Diffusion数据集构建秘籍：打造专属训练素材如何收集高质量图像数据？数据预处理小技巧：清洗与标注 模型配置与训练实战：让创意流淌Stable Diffusion架构简介训练过程中的超参数调整秘诀 性能调优攻略：挖掘模型潜力如何评估生成图像的质量？提升生成速度与减少资源消耗的策略 创意应用案例分享：释放你的想象力文字转图像的实际应用场景跨领域合作的可能性探讨 社区互动与未来展望：共同塑造AI艺术之路参与开源项目的途径下一代Stable Diffusion模型的发展趋势 开篇引入：探索创意无限的Stable Diffusion 在数字艺术的世界里，每一幅画作都承载着创作者的情感与想象。随着人工智能技术的进步，一种名为Stable Diffusion的模型正在逐渐改变这一领域。你可能已经在网上看到过一些令人惊叹的图像，它们是由AI创造的，而背后的技术就是Stable Diffusion。那么，究竟是什么使得这种模型如此受到追捧呢？
首先，Stable Diffusion模型可以高效地生成高质量的图像，而且它的灵活性非常高。无论是逼真的风景画还是抽象的艺术作品，它都能轻松应对。更重要的是，这个模型的训练和使用相对简单，即使是非专业人士也能快速上手。这让创意变得更加容易实现，也让AI艺术创作不再遥不可及。
Stable Diffusion模型的出现，不仅为艺术家们提供了新的工具，也为设计师、开发者甚至普通用户打开了通往无限可能的大门。想象一下，只需简单的文字描述，就能得到一张符合你想象的精美图像，这难道不是每个人心中的梦想吗？
数据集构建秘籍：打造专属训练素材 要训练出一个强大的Stable Diffusion模型，首先得有一套高质量的数据集。数据集就像是模型的食物，只有营养丰富，模型才能健康成长。
如何收集高质量图像数据？ 在构建数据集时，我们需要注意数据的多样性和质量。理想情况下，数据集应该包含尽可能多的图像类型，从自然风景到人物肖像，再到抽象艺术等。这样可以让模型学习到更广泛的知识，从而生成更多样化的图像。
对于数据来源，我们可以从公开的数据库如Flickr、Unsplash等网站获取，也可以通过爬虫技术从网络上抓取。但要注意版权问题，确保使用的图像都是可以自由使用的。此外，还可以尝试自己拍摄照片或绘画，为数据集增添独特的内容。
数据预处理小技巧：清洗与标注 数据收集完成后，下一步就是数据预处理了。数据预处理包括清洗、缩放、裁剪等步骤。清洗主要是去除噪声和不相关的图像，保证数据集的质量。缩放则是将所有图像统一到相同的尺寸，以便于模型处理。而标注则是给图像打上标签，比如类别、关键点位置等，这对于监督学习尤为重要。
例如，在处理人物图像时，我们可以手动标记眼睛、鼻子、嘴巴等关键特征的位置，这样模型在学习时就能够更加准确地捕捉到这些细节。
模型配置与训练实战：让创意流淌 了解了数据集的构建之后，接下来就要着手配置和训练Stable Diffusion模型了。这一步虽然有些技术含量，但其实并不复杂。
Stable Diffusion架构简介 Stable Diffusion模型是一种基于扩散过程的生成模型，它通过一系列反向扩散步骤来生成图像。模型的核心在于如何在随机噪声的基础上逐步恢复出清晰的图像。这个过程就像是一滴墨水在水中慢慢扩散再逐渐凝固成形的过程。
该模型通常采用Transformer架构，这是一种非常强大的序列建模方法。通过调整Transformer的层数、注意力头的数量以及隐藏层的大小等参数，可以定制出适合特定任务的模型结构。
训练过程中的超参数调整秘诀 在训练过程中，超参数的选择至关重要。常见的超参数有学习率、批次大小、迭代次数等。这些超参数的不同设置会直接影响到模型的训练效果。
比如，学习率决定了模型权重更新的速度。如果设置得太高，模型可能会跳过最优解；如果太低，则训练过程会非常缓慢。一般而言，我们会从较小的学习率开始，然后逐渐增加，找到最佳平衡点。
另外，批次大小也是影响训练效率的重要因素。较大的批次大小可以提高训练速度，但可能会导致模型收敛到较差的局部最小值。相反，较小的批次大小有助于模型探索更多的解空间，但训练时间较长。因此，我们需要根据实际情况来选择合适的批次大小。
性能调优攻略：挖掘模型潜力 模型训练完成后，下一步就是要对其进行性能调优，让模型发挥出最大的潜力。
如何评估生成图像的质量？ 评估生成图像的质量是一个多维度的问题。我们可以通过多种指标来进行综合评估，包括图像的真实性、多样性以及与输入描述的匹配度等。其中，真实性和多样性可以通过人类的主观判断来衡量，而匹配度则可以通过计算相似度得分来量化。
例如，我们可以组织一个盲测，让参与者对生成的图像进行评分，以此来评估图像的真实感。同时，我们也可以使用诸如FID（Fréchet Inception Distance）这样的自动化指标来评估图像质量。
提升生成速度与减少资源消耗的策略 除了提升图像质量之外，我们还需要考虑模型的运行效率。对于Stable Diffusion这样的模型来说，生成一张图像往往需要一定的计算资源。因此，优化模型以提高生成速度和降低资源消耗是非常重要的。
一种常见的做法是使用蒸馏技术来创建一个更小但性能接近原模型的小型版本。蒸馏技术可以通过训练一个小型模型来模仿大型模型的行为，从而在保持较高精度的同时显著减少计算成本。
此外，还可以利用硬件加速器如GPU或TPU来加速模型的训练和推理过程。这些硬件专门针对深度学习进行了优化，可以大幅提高处理速度。
创意应用案例分享：释放你的想象力 随着Stable Diffusion模型的普及，它已经被应用于各种创意领域，从艺术创作到产品设计，甚至是科学研究中。
文字转图像的实际应用场景 一个典型的例子是使用Stable Diffusion模型将文字描述转化为图像。例如，一家广告公司想要为一款新产品制作宣传海报，只需要给出产品的简短描述，Stable Diffusion就能自动生成多张风格各异的设计方案供选择。这种方式大大节省了时间和成本，同时也增加了创意的可能性。
跨领域合作的可能性探讨 Stable Diffusion模型还促进了跨领域的合作。例如，医学研究人员可以利用该模型生成虚拟的人体器官图像，用于疾病诊断或手术模拟。而在教育领域，教师可以利用这种技术来制作生动的教学材料，提高学生的兴趣和参与度。
社区互动与未来展望：共同塑造AI艺术之路 Stable Diffusion模型的成功离不开活跃的社区支持。社区成员们不断分享自己的经验、技巧以及遇到的问题，这种开放的合作精神促进了技术的进步和发展。
参与开源项目的途径 想要参与到Stable Diffusion模型的开发中来，最直接的方式就是加入相关的开源项目。GitHub上有许多活跃的社区，如Hugging Face等，它们提供了大量的资源和支持。你不仅可以贡献代码，还可以提出新的想法或改进现有功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88e5e7190cf2c0fcccc354bbbfdeff8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ec7334701bccbe6baa41ae50abee784/" rel="bookmark">
			【初阶数据结构篇】顺序表的实现（赋源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 本篇代码位置顺序表和链表1.线性表2.顺序表2.1 概念与结构2.2分类2.2.1 静态顺序表2.2.2 动态顺序表 2.3 动态顺序表的实现2.3.1动态顺序表的初始化和销毁及打印2.3.2动态顺序表的插入动态顺序表的尾插动态顺序表的头插动态顺序表的在指定位置插入数据 2.3.3动态顺序表的删除动态顺序表的尾删动态顺序表的头删动态顺序表的在指定位置删除数据 2.3.4动态顺序表查找指定数据 本篇代码位置 代码位置
顺序表和链表 1.线性表 ​ 线性表（linearlist）是n个具有相同特性的数据元素的有限序列。线性表是⼀种在实际中⼴泛使⽤的 数据结构，常见的线性表：顺序表、链表、栈、队列、字符串······
​ 线性表在逻辑上是线性结构，也就说是连续的⼀条直线。但是在物理结构上并不⼀定是连续的，线性 表在物理上存储时，通常以数组和链式结构的形式存储。
2.顺序表 2.1 概念与结构 ​ 概念：顺序表是⽤⼀段物理地址连续的存储单元依次存储数据元素的线性结构，⼀般情况下采⽤数组存储。
顺序表和数组的区别？
顺序表的底层结构是数组，对数组的封装，实现了常⽤的增删改查等接⼝。可以这么理解，我们使用数组来存储数据，并提供了增删查改数据的接口(函数)，这样组织和存储数据的结构我们将它称为顺序表。
2.2分类 2.2.1 静态顺序表 概念：使用定长数组存储元素
缺陷：显而易见的，空间一定，给少了不够用，给多了太浪费 2.2.2 动态顺序表 概念：不存储数组，而是存储一个指向一块动态开辟的内存空间的指针
优点：按需开辟，可增容
故我们一般都使用动态顺序表
2.3 动态顺序表的实现 2.3.1动态顺序表的初始化和销毁及打印 创建顺序表，并将其中的指针置为NULL，容量和有效数据个数置为0，销毁大致相同，不过如果arr指针非空，不要忘了释放动态申请的空间
SeqList.h(其中方法会一一讲到)
定义顺序表结构将存储数据类型重命名(方便之后替换-&gt;例如我们要求顺序表内存储char类型数据，只用改一行代码即可)所写的函数的声明，声明的时候参数只需要类型就可以了，名字加不加都一样 #pragma once #include &lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include &lt;assert.h&gt; typedef int sldatatype; typedef struct Seqlist { sldatatype* arr; sldatatype size; sldatatype capacity; } sl; void slinit(sl*);//初始化 void sldestroy(sl*);//销毁 void slprint(sl*);//打印 void checkcapacity(sl*);//判断空间是否足够 void slpushback(sl*, sldatatype);//尾插 void slpushfront(sl*, sldatatype);//头插 void slpopfront(sl*);//头删 void slpopback(sl*);//尾删 //在指定位置插入和删除数据 void slinsert(sl*, sldatatype, int); void slfrase(sl*, int); //查找指定数据 int slfind(sl*, sldatatype); test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ec7334701bccbe6baa41ae50abee784/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/99/">«</a>
	<span class="pagination__item pagination__item--current">100/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/101/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>