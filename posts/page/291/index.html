<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/813f247e5cfa8a773a33fc234dce4891/" rel="bookmark">
			数据结构之ArrayList与顺序表（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找往期文章包括但不限于本期文章中不懂的知识点：
个人主页：我要学编程(ಥ_ಥ)-CSDN博客
所属专栏：数据结构（Java版）
目录
ArrayList的具体使用 118. 杨辉三角
扑克洗牌算法 接上篇：数据结构之ArrayList与顺序表（上）-CSDN博客
ArrayList的具体使用 118. 杨辉三角 给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。
在「杨辉三角」中，每个数是它左上方和右上方的数的和。
示例 1:
输入: numRows = 5 输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]] 示例 2:
输入: numRows = 1 输出: [[1]] 1 &lt;= numRows &lt;= 30 分析：首先是一个杨辉三角的问题，杨辉三角其实就是一个只有一半的二维数组。 public class Test { public static void main(String[] args) { // 打印杨辉三角 Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int count = 0; // 创建一个n行n列的二维数组 int[][] array = new int[n][n]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (i == j) { array[i][j] = 1; }else if (j == 0) { array[i][j] = 1; }else { // 只有从第二行开始才会有下面的规律 if (i &gt;= 2) { array[i][j] = array[i-1][j] + array[i-1][j-1]; } } } } for (int[] x:array) { for (int y:x) { if (y !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/813f247e5cfa8a773a33fc234dce4891/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e5b201309532ae87983693d31f48fc7/" rel="bookmark">
			三端植物大战僵尸杂交版来了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hi，好久不见，最近植物大战僵尸杂交版蛮火的
那今天苏音整理给大家三端的植物大战僵尸杂交版包括【苹果端、电脑端、安卓端】
想要下载的直接划到最下方即可下载。
植物大战僵尸，作为一款古老的单机游戏，近期随着B站一位UP主@潜艇伟伟迷的爆改，粉丝数单月涨粉百万。
植物大战僵尸承载了许多玩家的童年记忆，游戏圈爆火，苏音身边的很多朋友也都玩开了这款游戏找到了曾经的记忆。
杂交版植物僵尸为何如此爆火？ 那为什么杂交版植物僵尸如此上头？我觉得分为几方面
第一是杂交版不仅是换皮改版，而且改变了游戏机制和玩法，可玩性更高
第二是得益于互联网的助推，各大游戏主播，包括身边朋友的推荐，流量效益愈发明显。
第三方面是游戏的返璞归真，面对市场纷杂的游戏圈，大家都乐意去下载，去回忆童年的那份乐趣
那杂交版，到底新在哪里？
与原版不同，爆改版加入了杂交植物玩法，可使用特殊能力的全新植物
例如向日葵和豌豆射手，每一个新杂交植物都有强化和特殊的能力
在杂交版中，笨笨的僵尸也学会了伪装自己，僵尸也长得千奇百怪
寒冰高坚果、忧郁南瓜头、魅惑菇射手、开冰车的巨人僵尸等各种新奇的品种层出不穷
同时，在杂交版中，植物们也许会了联合对抗僵尸，合理利用他们各自的能力组合在一起就能形成毁灭灭地的攻击力。
爆改的背后 爆改的背后，不是偶然，是来自于作者@潜艇伟伟迷日久坚持的更新，可能你没想到
植物大战僵尸的爆改，从六七年前已经开始了
但是一直不愠不火的
由于一个人高强度的工作，从最初的雷暴蘑菇、双发卷心菜，到后来强势出圈的豌豆向日葵、毁灭菇投手
他在半年的时间就自制了120多个植物，在2022年8月发动态表示身体和精神状态也不好
苏音在此还是建议各位，不管是什么，身体才是革命的本钱，是第一要素。
让作者能够一直坚持下来的，也许是粉丝的鼓励，也许是梦想，
终于在今年4月发布了杂交版的宣传片，这一刻，作者这么多年的辛苦，值了！
而你，我的朋友，你才是真正的赛博孟德尔【注：孟德尔代表作品：论文《植物杂交试验》】
最后送上苏音分享给大家的三端下载链接
电脑端一般直接点击此exe文件安装即可
苹果和安卓端也有对应的安装教程，需要的小伙伴可以自取
链接就放在这里啦：https://www.suyin66.com/plantszjb.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ec188da73f3ecbd998b1361d63d0cc3/" rel="bookmark">
			Hadoop 3.4.0&#43;HBase2.5.8&#43;ZooKeeper3.8.4&#43;Hive4.0&#43;Sqoop 分布式高可用集群部署安装 大数据系列二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建服务器,参考
虚拟机创建服务器
节点名字节点IP系统版本master11192.168.50.11centos 8.5slave12192.168.50.12centos 8.5slave13192.168.50.13centos 8.5 1 下载组件
Hadoop:官网地址
Hbase:官网地址
ZooKeeper:官网下载
Hive:官网下载
Sqoop:官网下载
为方便同学们下载，特整理到网盘
链接地址 提取码：i2ev
2 通过xftp 上传软件到服务器,统一放到/data/soft/
3 配置ZooKeeper
tar zxvf apache-zookeeper-3.8.4-bin.tar.gz mv apache-zookeeper-3.8.4-bin/ /data/zookeeper #修改配置文件 cd /data/zookeeper/conf cp zoo_sample.cfg zoo.cfg #创建数据保存目录 mkdir -p /data/zookeeper/zkdata mkdir -p /data/zookeeper/logs vim zoo.cfg dataDir=/tmp/zookeeper--&gt;dataDir=/data/zookeeper/zkdata dataLogDir=/data/zookeeper/logs server.1=master11:2888:3888 server.2=slave12:2888:3888 server.3=slave13:2888:3888 #配置环境变量 vim /etc/profile export ZooKeeper_HOME=/data/zookeeper export PATH=$PATH:$ZooKeeper_HOME/bin source /etc/profile #新建myid并且写入对应的myid
[root@master11 zkdata]# cat myid 1 #对应修改 slave12 myid--2 slave13 myid--3 4 配置HBase
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ec188da73f3ecbd998b1361d63d0cc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/548fd7b52ebeda464f632a8d627f8a83/" rel="bookmark">
			ChatGPT Prompt技术全攻略-探索篇：前沿Prompt工程技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列篇章💥 No.文章1ChatGPT Prompt技术全攻略-入门篇：AI提示工程基础2ChatGPT Prompt技术全攻略-进阶篇：深入Prompt工程技术3ChatGPT Prompt技术全攻略-高级篇：掌握高级Prompt工程技术4ChatGPT Prompt技术全攻略-应用篇：Prompt工程技术的实际应用5ChatGPT Prompt技术全攻略-探索篇：前沿Prompt工程技术6ChatGPT Prompt技术全攻略-精通篇：Prompt工程技术的高级应用7ChatGPT Prompt技术全攻略-总结篇：Prompt工程技术的未来发展 目录 系列篇章💥引言一、前沿Prompt工程技术概述二、自我学习和适应性Prompt1. 自我学习Prompt2. 适应性Prompt 三、跨模态理解和生成1. 文本到图像生成2. 音频到文本转换 四、AI伦理和安全性优化1. 伦理标准遵循2. 安全协议优化 结语 引言 在人工智能的浩瀚星空中，ChatGPT作为一颗璀璨的明星，以其卓越的语言处理能力和广阔的应用前景，引领着人机交互的新纪元。然而，要充分发挥ChatGPT的潜力，我们需要掌握Prompt Engineering的艺术。Prompt Engineering不仅是一种技术手段，它更是一种策略，一种通过精心设计的提示来引导AI沿着我们设定的路径思考和创造的方法。
在基础和进阶的应用阶段，我们已经见证了Prompt Engineering带来的巨大变革。现在，随着技术的不断进步，我们开始探索这一技术的前沿领域，解锁AI的更多可能性。在探索篇中，我们将一起踏上旅程，深入了解那些正在推动AI领域发展的尖端Prompt工程技术。
这些前沿技术包括但不限于自我学习和适应性Prompt、跨模态理解和生成，以及使用Prompt进行AI伦理和安全性的优化。它们将帮助我们进一步拓展AI的应用边界，实现更加高效和智能的人机交互。
让我们一同探索Prompt Engineering的前沿领域，解锁AI的无限可能，共同迈向人机交互的新纪元。
一、前沿Prompt工程技术概述 前沿Prompt工程技术正以前所未有的速度拓展AI的边界。这些技术不仅包括自我学习和适应性Prompt，还涵盖了跨模态理解和生成，以及使用Prompt进行AI伦理和安全性的优化。这些技术的发展，不仅增强了AI的智能程度，也为人类带来了更加丰富和便捷的交互体验。
二、自我学习和适应性Prompt 自我学习和适应性Prompt是Prompt工程技术的前沿应用之一，它使得AI能够根据用户交互自动调整和优化Prompt，以更好地适应用户的需求。这种技术的核心在于AI能够从每次对话中学习，并根据用户的反馈和交互历史，不断优化自己的回答和行为，从而提供更加个性化和精准的服务。
1. 自我学习Prompt 在实际应用中，自我学习Prompt可以应用于多种场景，如智能客服、在线教育、虚拟助手等。例如，在智能客服领域，自我学习Prompt可以帮助AI更好地理解用户的问题和需求，提供更准确的答案和解决方案。在在线教育领域，自我学习Prompt可以帮助AI根据学生的学习进度和习惯，调整教学内容和难度，以提高学习效果。
Prompt实践： “设计一个自我学习型的Prompt，用于追踪用户在语言学习应用中的进度，并根据其学习习惯调整教学内容和难度。”
2. 适应性Prompt 在实际应用中，适应性Prompt可以应用于多种场景，如个性化推荐、智能对话、智能客服等。例如，在个性化推荐领域，适应性Prompt可以帮助AI根据用户的购买历史和偏好，推荐更加符合用户需求的商品。在智能对话领域，适应性Prompt可以帮助AI根据用户的对话内容和情感，提供更加贴心的回答和解决方案。
Prompt实践： “创建一个适应性Prompt，用于在线购物助手，根据用户的购买历史和偏好推荐商品，并根据用户的反馈调整推荐算法。”
三、跨模态理解和生成 跨模态理解和生成技术是Prompt工程中的一个前沿领域，它涉及到AI在不同的数据类型和模态之间进行转换和理解的能力。这种技术的核心在于AI能够综合处理和转换多种模态的数据，从而实现更高级的认知和交互能力。
在跨模态理解和生成中，AI能够处理文本、图像、音频、视频等多种数据类型，并能够理解和生成这些不同模态的数据。这种技术在虚拟现实（VR）、增强现实（AR）、自动驾驶、医疗诊断等领域都有广泛的应用。
1. 文本到图像生成 在实际应用中，文本到图像生成可以提供极大的便利。例如，作家可以快速获得小说的插图，设计师可以根据产品描述生成广告设计，而VR和AR开发者则可以利用这种技术创建更加丰富和逼真的虚拟场景。
Prompt实践： “根据用户给出的文本描述，生成一幅描绘未来城市景象的图像。”
2. 音频到文本转换 在实际应用中，音频到文本转换可以提供极大的便利。例如，在视频会议、在线教育、语音助手和智能语音交互等领域，音频到文本转换可以帮助用户更好地理解和记录语音信息。此外，在听障人士和语言障碍人士中，音频到文本转换可以帮助他们更好地获取和理解语音信息，提高生活质量。
Prompt实践： “将这段关于环境保护的演讲音频转换为详细的文字记录，并确保捕捉到所有的技术术语和关键论点。”
四、AI伦理和安全性优化 AI技术的广泛应用使得它在各个领域都发挥着重要作用，从医疗诊断到金融交易，从自动驾驶到智能家居，AI正在逐渐改变我们的生活方式。然而，随着AI技术的普及，其伦理性和安全性也受到了越来越多的关注。
Prompt工程技术在这一领域的应用，可以帮助创建遵循伦理标准和安全协议的AI系统。通过设计符合伦理标准的Prompt，我们可以引导AI系统在生成内容时避免偏见和歧视，尊重不同文化和社会群体的价值观。同时，通过设计安全协议优化的Prompt，我们可以帮助AI系统识别和防御潜在的安全威胁，如钓鱼攻击、恶意软件等，从而保护用户数据和资产安全。
1. 伦理标准遵循 随着AI技术的飞速发展，确保其遵循伦理标准变得日益重要。Prompt工程技术在这一领域的应用，可以帮助创建遵循伦理标准和安全协议的AI系统。
伦理标准遵循的Prompt设计要求AI模型能够识别和避免生成有偏见或不恰当的内容。这涉及到对数据进行清洗和处理，以确保训练数据的多样性和平衡性，以及AI模型在生成输出时能够遵守一定的道德和法律标准。
例如，在设计一个用于新闻报道的AI模型时，Prompt可以要求模型在生成新闻内容时避免使用歧视性语言，尊重不同文化和社会群体的价值观。
通过伦理标准遵循的Prompt设计，我们可以帮助AI系统更好地服务于人类，减少潜在的偏见和歧视，确保AI技术的发展符合人类的伦理和道德标准。
Prompt实践： “设计一个Prompt，确保AI在生成任何涉及个人数据的内容时，都遵循严格的隐私保护和数据安全标准。”
2. 安全协议优化 随着AI技术的广泛应用，安全问题变得越来越重要。Prompt工程技术在这一领域的应用，可以帮助创建更加安全和可靠的AI系统。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/548fd7b52ebeda464f632a8d627f8a83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d9821bf928a6a48902e172186e9b448/" rel="bookmark">
			Hadoop的安装与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建hadoop用户 创建了可以登陆的 hadoop 用户，并使用 /bin/bash 作为 shell。
sudo useradd -m hadoop -s /bin/bash 为 hadoop 用户增加管理员权限，方便部署
sudo passwd hadoop 最后注销当前用户（点击屏幕右上角的齿轮，选择注销），返回登陆界面。在登陆界面中选择刚创建的 hadoop 用户进行登陆。
sudo adduser hadoop sudo 更新apt 用 hadoop 用户登录后，我们先更新一下 apt，后续我们使用 apt 安装软件，如果没更新可能有一些软件安装不了
sudo apt-get update 后续需要更改一些配置文件，安装一下vim
sudo apt-get install vim 安装SSH、配置SSH无密码登陆 安装 SSH server
sudo apt-get install openssh-server 使用如下命令登陆本机
ssh localhost 首先退出刚才的 ssh，就回到了我们原先的终端窗口，然后利用 ssh-keygen 生成密钥，并将密钥加入到授权中
exit # 退出刚才的 ssh localhost cd ~/.ssh/ # 若没有该目录，请先执行一次ssh localhost ssh-keygen -t rsa # 会有提示，都按回车就可以 cat .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d9821bf928a6a48902e172186e9b448/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4eef116b0b4f087a8f54d2232490f16/" rel="bookmark">
			【C语言】基于C语言实现的贪吃蛇游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【C语言】基于C语言实现的贪吃蛇游戏 🔥个人主页：大白的编程日记
🔥专栏：C语言学习之路
文章目录 【C语言】基于C语言实现的贪吃蛇游戏前言一.最终实现效果一.Win32 API介绍1.1Win32 API1.2控制台程序1.3控制台屏幕上的坐标COORD1.4GetStdHandle1.5GetConsoleCursorInfo1.6SetConsoleCursorInfo1.7SetConsoleCursorPosition1.8GetAsyncKeyState 二.C语言的国际化2.1国际化2.2&lt;locale.h&gt;本地化2.3类项2.4setlocale函数2.5宽字符的打印 三.思路分析四.GameStar函数4.1设置控制台信息4.2欢迎界面的打印4.3地图的绘制4.4初始化贪吃蛇 五.GameRun函数5.1提示信息函数5.2打印分数5.3检测键值5.4蛇的移动5.5检测是否撞墙 六.GameEnd函数七.游戏主体设计八.源码后言 前言 哈喽，各位小伙伴大家好！今天给大家带来的是使用C语言实现的贪吃蛇小游戏。也是检验C语言是否学好的试金石。话不多说，咱们进入正题！向大厂冲锋！
一.最终实现效果 贪吃蛇实现视频
一.Win32 API介绍 本次实现贪吃蛇会使用到的⼀些Win32 API知识，接下来我们就学习⼀下什么是Win32 API。
1.1Win32 API Windows 这个多作业系统除了协调应⽤程序的执行、分配内存、管理资源之外，
它同时也是⼀个很大的服务中心，调用这个服务中心的各种服务（每⼀种服务就是⼀个函数），可以帮应用程序达到开启视窗、描绘图形、使⽤周边设备等目的，由于这些函数服务的对象是应⽤程序(Application)， 所以便称之为 Application Programming Interface，简称 API 函数。
WIN32 API也就是Microsoft Windows32位平台的应用程序编程接口。
1.2控制台程序 平常我们运行起来的黑框程序其实就是控制台程序。
那这个控制台的大小我们可不可设置呢？其实是能的。
设置大小
我们可以使用cmd命令来设置控制台窗口的长宽：设置控制台窗口的大小，30行，100列。 mode con cols=100 lines=30 我们要设置控制台的话就需要使用system函数，system函数可以用来执行系统命令。
int main() { system("mode con cols=40 lines=40"); return 0; } 设置名字
控制台的名字也能修改，使用title命令即可 title 贪吃蛇 int main() { system("mode con cols=100 lines=30"); system("title 贪吃蛇"); getchar(); return 0; } 控制台设置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4eef116b0b4f087a8f54d2232490f16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85673f93a5f4429fba2e262c7b5becfa/" rel="bookmark">
			【计算机视觉】数字图像处理基础：以像素为单位的图像基本运算（点运算、代数运算、逻辑运算、几何运算、插值）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0、前言 在上篇文章中，我们对什么是数字图像、以及数字图像的组成（离散的像素点）进行了讲解🔗【计算机视觉】数字图像处理基础知识：模拟和数字图像、采样量化、像素的基本关系、灰度直方图、图像的分类。
我们知道，数字图像其实就是像素点组成的二维矩阵。本节我们要讲的就是基于这个二维矩阵进行一些数学上的基本运算（本质就是就是矩阵的计算——线性代数），对图像进行处理，这些基本运算也是数字图像处理的基础和基本算法，本节我们将介绍这些基本算法。
分别有以下几类
点运算：以一副图像（一个二维矩阵）为处理对象，图像中的像素点（矩阵中的值）为处理单位，对图像中的每个像素点进行按一定函数关系的运算，得到一副新图像的处理过程。代数运算：以两幅图像（两个二维矩阵）为处理对象，对两幅图像的对应像素之间进行加减乘除，得到一副输出图像。逻辑运算：也是以两幅图像（两个二维矩阵）为处理对象，对两幅图像的对应像素之间进行逻辑运算，得到输出图像。几何运算：是以一副图像为处理单位，对图像中的不同像素进行变换（改变像素之间的空间关系），从而实现处理后得到的图像进行了几何变换（翻转、镜像、平移等）。 Tips: 我们在进行下面的基本运算时，都是将像素值进行归一化到[0, 1]的取值范围的，方便变换和计算。在对应变换的时候也需要注意这点，避免产生误解。
一、点运算 点运算是基于图像中每个像素点的像素值进行运算的图像处理方法。通过对输入图像的像素值和输入图像的像素值之间建立函数映射关系，实现“从像素到像素”的复制操作，输出图像中的每个像素值仅仅和输入图像中对应位置的像素值以及输入到输出像素之间的函数映射关系有关。
💐根据这个函数关系是否线性，我们可以把点运算分为两类：
线性点运算非线性点运算 1.1：线性点运算 线性点运算是指输入图像的像素值和输出图像的像素值之间为线性函数关系：
O ( x , y ) = a × I ( x , y ) + b O(x,y) = a\times I(x,y)+b O(x,y)=a×I(x,y)+b
a = 1 , b = 0 a=1, b=0 a=1,b=0，则 O ( x , y ) = I ( x , y ) O(x,y) = I(x,y) O(x,y)=I(x,y)，输入图像和输出图像相同； a = 1 , b ≠ 0 a=1, b\ne 0 a=1,b=0，则输出图像整体的灰度值增加或减少，图像整体变得更两或更暗 a &gt; 1 a &gt; 1 a&gt;1，则输出图像对比度增大（因为像素之间的灰度差也增大了a倍），输出图像整体显示效果较输入图像会更亮。 0 ≤ a &lt; 1 0 \le a&lt; 1 0≤a&lt;1,则输出图像对比度减小（因为像素之间的灰度差也减小了a倍），输出图像整体显示效果较输入图像更暗。 a &lt; 0 a&lt;0 a&lt;0, 则灰度值翻转：原来暗的地方变亮，原来亮的地方变暗 import cv2 import numpy as np import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85673f93a5f4429fba2e262c7b5becfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cccfdf1ae68215188e47f837a867c3c/" rel="bookmark">
			【机器学习】与【数据挖掘】技术下【C&#43;&#43;】驱动的【嵌入式】智能系统优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、嵌入式系统简介
二、C++在嵌入式系统中的优势
三、机器学习在嵌入式系统中的挑战
四、C++实现机器学习模型的基本步骤
五、实例分析：使用C++在嵌入式系统中实现手写数字识别
1. 数据准备
2. 模型训练与压缩
3. 模型部署
六、优化与分析
1. 模型优化
模型量化
模型剪枝
2. 系统优化
内存管理
计算资源分配
电源管理
七、性能评估与优化策略
1. 性能评估指标
2. 性能优化策略
八、实际应用案例 -嵌入式图像分类系统
概述
步骤
1. 数据准备
2. 模型部署
3. 实时推理
九、总结与展望
随着物联网（IoT）和智能设备的普及，嵌入式系统变得越来越重要。而随着人工智能（AI）和机器学习（ML）技术的发展，将这些技术应用于嵌入式系统中可以实现许多智能应用，如智能家居、自动驾驶和工业自动化等。然而，由于嵌入式系统的资源有限，将AI和ML应用到嵌入式系统中面临许多挑战。
一、嵌入式系统简介 嵌入式系统是一种专用计算机系统，通常嵌入到大型系统中，执行特定任务。典型的嵌入式系统包括微控制器（MCU）、单板计算机（SBC）和专用AI加速器。嵌入式系统的主要特点包括：
资源受限：CPU、内存和存储资源较少。实时性要求：需要在严格的时间限制内完成任务。专用性强：专为特定任务或设备设计。 二、C++在嵌入式系统中的优势 C++因其高效性和面向对象的特性，在嵌入式系统中得到了广泛应用。其优势包括：
高性能：C++的编译后代码执行效率高，适合资源受限的嵌入式系统。面向对象：便于代码模块化和重用。丰富的库支持：标准库和第三方库丰富，便于实现复杂功能。 三、机器学习在嵌入式系统中的挑战 将机器学习模型部署到嵌入式系统中需要克服多种挑战：
模型压缩：减少模型的大小和计算复杂度。实时性：确保模型推理的实时响应。资源管理：优化内存和计算资源的使用。 四、C++实现机器学习模型的基本步骤 数据准备：获取并预处理数据。模型训练：在PC或服务器上训练模型。模型压缩：使用量化、剪枝等技术压缩模型。模型部署：将模型移植到嵌入式系统中。实时推理：在嵌入式设备上进行实时推理。 五、实例分析：使用C++在嵌入式系统中实现手写数字识别 以下实例将展示如何在嵌入式系统中使用C++和TensorFlow Lite实现手写数字识别。
1. 数据准备 我们使用MNIST数据集进行手写数字识别。首先，需要将数据集转换为适合嵌入式系统使用的格式。
#include &lt;fstream&gt; #include &lt;vector&gt; #include &lt;iostream&gt; void read_mnist(const std::string &amp;filename, std::vector&lt;std::vector&lt;uint8_t&gt;&gt; &amp;images) { std::ifstream file(filename, std::ios::binary); if (file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cccfdf1ae68215188e47f837a867c3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdc100c33f640ff6016d86bb4d548b23/" rel="bookmark">
			自然语言处理（NLP）技术在AIGC中的突破
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文收录于专栏：精通AI实战千例专栏合集
https://blog.csdn.net/weixin_52908342/category_11863492.html 从基础到实践，深入学习。无论你是初学者还是经验丰富的老手，对于本专栏案例和项目实践都有参考学习意义。
每一个案例都附带关键代码，详细讲解供大家学习，希望可以帮到大家。正在不断更新中~
一.自然语言处理（NLP）技术在AIGC中的突破 近年来，人工智能生成内容（AIGC）在各行各业中崭露头角。AIGC通过生成文本、图像、音频和视频等多种形式的内容，为用户提供了丰富的体验和强大的工具。在这些技术中，自然语言处理（NLP）作为生成文本和理解语言的核心技术，起到了至关重要的作用。本文将深入探讨NLP技术在AIGC中的突破，并通过代码实例展示其应用。
NLP技术的核心突破 1. Transformer架构的出现 Transformer架构是NLP领域的革命性进展。与传统的RNN和LSTM相比，Transformer通过自注意力机制（Self-Attention）实现了并行化处理，大大提高了训练速度和效果。最著名的Transformer模型之一是BERT，它在多项NLP任务中刷新了性能记录。
2. 预训练和微调 预训练模型（如BERT、GPT-3）的出现使得NLP应用变得更加高效。通过在大规模数据集上预训练，模型可以学习到丰富的语言知识。随后，通过微调，可以将预训练模型适应于特定任务，从而达到较高的精度和性能。
3. 自回归生成模型 自回归生成模型（如GPT-3）在生成任务中表现卓越。这类模型通过逐词预测的方式生成文本，能够产生连贯且有创意的内容。GPT-3的强大能力使其在文本生成、对话系统和内容创作等方面展现出巨大潜力。
代码实例：基于GPT-3的文本生成 以下是一个基于GPT-3的文本生成示例，展示了如何利用NLP技术生成高质量的文本内容。由于GPT-3是一个需要访问外部API的模型，此处将使用OpenAI的API进行文本生成。
安装和设置 首先，确保安装了OpenAI的Python库：
pip install openai 代码示例 import openai # 设置API密钥 openai.api_key = 'YOUR_API_KEY' def generate_text(prompt, max_tokens=100): response = openai.Completion.create( engine="text-davinci-003", # 使用GPT-3的davinci引擎 prompt=prompt, max_tokens=max_tokens, n=1, stop=None, temperature=0.7 ) return response.choices[0].text.strip() # 示例使用 prompt = "写一段关于人工智能在医疗领域应用的文章" generated_text = generate_text(prompt) print(generated_text) 在上面的代码中，我们通过调用OpenAI的API来生成文本。prompt变量中包含了我们希望生成的文本主题，max_tokens参数控制生成文本的长度，temperature参数控制文本生成的随机性。
NLP在AIGC中的应用前景 1. 内容创作 NLP技术可以帮助创作者生成文章、诗歌、小说等多种形式的内容，大幅提高创作效率。例如，新闻机构可以利用NLP技术生成新闻稿，减少人工写作的时间和成本。
2. 对话系统 通过NLP技术，智能对话系统可以更好地理解用户意图并生成自然的对话内容。这在客服、教育、娱乐等领域具有广泛应用前景。
3. 数据分析与总结 NLP技术还可以用于大规模数据的分析与总结，帮助企业快速获取有价值的信息。例如，在金融领域，NLP可以分析市场新闻和报告，生成投资分析和建议。
NLP在AIGC中的挑战与解决方案 尽管NLP技术在AIGC领域取得了显著的进展，但仍然面临一些挑战。这些挑战包括模型的理解和生成能力、数据隐私和安全性、以及多语言支持等问题。针对这些挑战，学术界和工业界提出了多种解决方案。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdc100c33f640ff6016d86bb4d548b23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3661bb54bd172b6fd7e1e10a5f8d22e4/" rel="bookmark">
			【C&#43;&#43;】C&#43;&#43; 基于QT实现散列表学生管理系统（源码&#43;数据&#43;课程论文）【独一无二】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👉博__主👈：米码收割机
👉技__能👈：C++/Python语言
👉公众号👈：测试开发自动化【获取源码+商业合作】
👉荣__誉👈：阿里云博客专家博主、51CTO技术博主
👉专__注👈：专注主流机器人、人工智能等相关领域的开发、测试技术。
C++ 基于QT实现散列表学生管理系统（源码+数据+课程论文）【独一无二】 目录 C++ 基于QT实现散列表学生管理系统（源码+数据+课程论文）【独一无二】一、设计要求二、功能展示添加学生信息查询学生信息显示学生信息排序学生总成绩保存学生信息删除学生信息 三、代码分析 一、设计要求 （1）问题描述
使用该散列表存储学生的信息。学生的信息中至少包括学号、姓名、性别、年龄等数据项。以姓名做为关键字，当出现重名时，采用一定方法解决冲突。要求有界面，方便用户进行输入输出操作。
（2）基本要求
(1)完成散列表的插入、删除、查找学生信息等操作。
(2)可以为学生输入若干门课程的成绩信息，并能够统计出每位学生的总成绩。
(3)可对每门课程的成绩进行排序，统计各分数段人数。
(4) 设计不同的散列函数，比较冲突率；在散列函数确定的前提下，请用拉链法和一种开地址法处理冲突的方法。
(5)所有信息需存放在文本文件中。
👉👉👉 源码获取 关注【测试开发自动化】公众号，回复 “散列学生管理系统” 获取。👈👈👈
二、功能展示 添加学生信息 👉👉👉 源码获取 关注【测试开发自动化】公众号，回复 “散列学生管理系统” 获取。👈👈👈
查询学生信息 显示学生信息 👉👉👉 源码获取 关注【测试开发自动化】公众号，回复 “散列学生管理系统” 获取。👈👈👈
排序学生总成绩 👉👉👉 源码获取 关注【测试开发自动化】公众号，回复 “散列学生管理系统” 获取。👈👈👈
保存学生信息 删除学生信息 👉👉👉 源码获取 关注【测试开发自动化】公众号，回复 “散列学生管理系统” 获取。👈👈👈
三、代码分析 struct Student { string student_id; string name; string gender; int age; unordered_map&lt;string, int&gt; courses; int getTotalScore() const { int total = 0; for (const auto&amp; course : courses) { total += course.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3661bb54bd172b6fd7e1e10a5f8d22e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f79bf2e47c750be9be9c36fa0b66a7fa/" rel="bookmark">
			loading组件封装原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以vue3为例，采用ts 的语言
首先可对所需数据定义在接口中
interface Prop{ //核心所需的就是 lading:boolean ,type: 'lading' | 'skeleton'}
进行调用
封装的话采用的是插槽
&lt;div v-if="loading" &gt; &lt;slot name="template"&gt; &lt;div v-if="type === 'loading'"&gt; &lt;VanLoading&gt;&lt;/VanLoading&gt; &lt;/div&gt; &lt;div v-if="type === 'skeleton'"&gt; &lt;VanSkeleton :row="10" &gt;&lt;/VanSkeleton&gt; &lt;VanSkeleton avatar :row="5"&gt;&lt;/VanSkeleton&gt; &lt;!-- &lt;VanSkeleton :row="5"&gt;&lt;/VanSkeleton&gt; --&gt; &lt;/div&gt; &lt;/slot&gt; &lt;/div&gt; &lt;slot v-else&gt;&lt;/slot&gt; vant组件需要引用
骨架屏官网查看 Vant 4 - A lightweight, customizable Vue UI library for mobile web apps.
组件的使用
&lt;组件名 :loading="pending" type="skeleton"&gt; &lt;/组件名 &gt;
loading采用的布尔值在调用的时候可以和变量相联合使用
比如调用接口实话数据可以采用包裹的形式
包装成一个函数的形式进行 export 里面return一个promise函数等等
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f79bf2e47c750be9be9c36fa0b66a7fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93fec6019f97795c77aca512b884a1a0/" rel="bookmark">
			AI 边缘计算平台 - 6 TOPS 低功耗 RK3576
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RK3576 是瑞芯微第二代 8nm 高性能 AIOT 平台，CPU 采用八核大小核构架（4×A72@ 2.2GHz + 4×A53@ 1.8GHz），以及一个 M0 协处理器。其 CPU 算力高达 58K DMIPS，足以应对各种复杂计算任务。搭载 Mali-G52 MC3 GPU，145G FLOPS 的 GPU 可以支持有效的异构计算，支持硬件编解码，提供了强大的图形处理能力和人工智能计算能力，满足图形密集型应用的需求。并配备了独立的 6 Tops NPU，支持 Transformer 架构下超大规模参数模型的私有化部署，支持多种深度学习框架、自定义算子开发、Docker 容器化管理技术。
相比于 RK3588（93K DMIPS，典型功耗 8W），RK3576 的 CPU 和 GPU 性能稍差一些，其最大的特点是 CPU 结温（Tj）低，典型功耗只有 1.2W，可以胜任无散热片的应用，大大降低了能源消耗和散热成本。
为了满足不同领域的需求，瑞芯微还推出符合工业和车规级标准的 RK3576J 和 RK3576M 版本。RK3576J 适用于工业等级温度（-40~85度），可用于电力集中器、能源控制器、专变采集终端、HMI、PLC 控制及各种网关等工业应用。RK3576M 不仅符合上述温度范围，还符合AEC-Q100 规范，适用于智能座舱等汽车应用领域。
一、RK3576 方框图和典型应用： 二、跑分对比： 三、AI 能力： RK3576 内置强劲 NPU，算力可达 6 TOPS；能够进行更智能的数据处理、语音识别、图像分析，满足大多数终端设备边缘计算 AI 应用需求。
语言大模型 ： 支持 Transformer 架构下超大规模参数模型的私有化部署，如 Gemma-2B、LlaMa2-7B、ChatGLM3-6B、Qwen1.5-1.8B 等大型语言模型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93fec6019f97795c77aca512b884a1a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/295b8f4404699eb74711cb95f9dd9bda/" rel="bookmark">
			TalkingData数据统计：洞察与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TalkingData数据统计：洞察与应用 在数据驱动的时代，数据统计和分析已经成为各行各业的重要工具。在这个过程中，TalkingData作为一家领先的数据智能服务提供商，为我们提供了丰富的数据分析工具和解决方案。本文将带您深入了解TalkingData的数据统计方法，并探讨其在实际应用中的重要性和效果。
数据统计的基本概念 数据统计是通过对数据的收集、整理、分析和解释，来揭示数据背后的规律和趋势。它不仅仅是简单的数据计算，更是一门将复杂的数据转化为有用信息的艺术。数据统计的核心任务包括数据的描述性统计、推断性统计以及预测性统计。
描述性统计 描述性统计主要关注数据的特征，通过计算均值、中位数、标准差等统计量，来描述数据的基本情况。例如，在用户行为分析中，我们可以通过描述性统计了解用户的平均使用时长、频率等。
推断性统计 推断性统计则通过样本数据来推测总体情况。它包括假设检验、置信区间等技术，帮助我们从有限的数据中得出可靠的结论。例如，在市场调查中，我们可以通过对部分用户的调查结果推断整个市场的趋势。
预测性统计 预测性统计利用历史数据来预测未来的趋势和行为。常用的方法有时间序列分析、回归分析等。例如，在销售预测中，我们可以通过历史销售数据来预测未来的销售情况。
TalkingData的数据统计方法 作为一家专业的数据智能服务提供商，TalkingData提供了一整套先进的数据统计方法和工具，帮助企业从海量数据中挖掘有价值的信息。
数据采集与处理 TalkingData通过其强大的数据采集平台，能够从多个渠道实时采集海量数据。这些数据包括用户行为数据、设备数据、地理位置数据等。为了保证数据的质量，TalkingData采用了严格的数据清洗和预处理技术，去除噪声和异常值，确保数据的准确性和可靠性。
数据分析与挖掘 在数据分析方面，TalkingData提供了丰富的数据分析工具和算法库，包括传统的统计分析方法和先进的机器学习算法。通过这些工具，企业可以对数据进行深度分析，发现隐藏的模式和规律。例如，通过聚类分析，可以将用户分为不同的群体，针对不同群体制定差异化的营销策略。
数据可视化 数据可视化是将复杂的数据转化为直观的图表和图形，帮助用户更好地理解数据。TalkingData提供了一系列强大的数据可视化工具，支持多种图表类型和交互方式，用户可以根据需求自定义可视化报表。例如，通过时间序列图，可以直观地展示销售数据的变化趋势。
TalkingData在实际应用中的案例 用户行为分析 某电商平台通过TalkingData的数据统计和分析工具，对用户行为进行了深度分析。通过描述性统计，平台发现了用户的平均浏览时长和频率；通过推断性统计，平台识别出了影响用户购买决策的关键因素；通过预测性统计，平台成功预测了未来的销售趋势，提前调整了库存和营销策略。
广告效果评估 某广告公司利用TalkingData的数据分析工具，对广告投放效果进行了全面评估。通过数据采集和处理，公司获取了广告曝光量、点击率等数据；通过数据分析，公司发现了不同广告形式和投放渠道的效果差异；通过数据可视化，公司生成了详细的效果评估报表，为客户提供了有力的决策支持。
结语 在数据驱动的时代，数据统计和分析已经成为企业获取竞争优势的重要手段。通过TalkingData的数据统计方法和工具，企业可以深入挖掘数据的价值，做出更加明智的决策。无论是在用户行为分析、市场预测，还是在广告效果评估等方面，TalkingData都展现出了强大的实力和广泛的应用前景。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/134f66d991cd66797215cc7adb4bc5b6/" rel="bookmark">
			Linux shell编程基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问 Linux 内核的服务。
Shell 脚本（shell script），是一种为 shell 编写的脚本程序，一般文件后缀为 .sh。
一、shell环境 Linux 环境下有很多可以使用的shell，每个用户都拥有一个特定的默认shell。在Linux系统中，/etc/shells文件用于指定哪些程序路径可以作为有效的登录shell。
Shell 的解释器种类众多，常见的有：
shell 解释器说明shBourne Shell。sh 是 Unix 标准默认的 shell。bashBourne Again Shell。bash 是 Linux 标准默认的 shell。tcsh整合 C Shell ，提供更多的功能csh已经被 /bin/tcsh 所取代zsh功能强大的 shell 与脚本语言。 要查看系统中允许的合法登录shell，可以执行以下命令：
cat /etc/shells 1.1 当前用户的默认shell 用户的“默认shell”是指他们登录系统后自动启动的命令行解释器或交互式shell。这个shell用于处理用户在命令行界面输入的命令和操作。
可以使用如下命令查看当前默认shell
echo $SHELL 1.2 修改当前用户默认shell 要更改用户的默认shell，可以在命令行中输入以下命令：
chsh -s &lt;shell&gt; 其中是你想要设置为用户默认shell的路径。例如，要将当前用户的默认shell更改为Bash，可以执行：
chsh -s /bin/bash 系统会要求你输入当前用户的密码以确认此操作。确认后，用户的默认shell将被更改为Bash。但是似乎修改失败了。
1.3 指定脚本解释器 shell脚本中，#! 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 解释器。#! 被称作shebang。
#! 决定了脚本可以像一个独立的可执行文件一样执行，而不用在终端之前输入sh, bash, python, php等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/134f66d991cd66797215cc7adb4bc5b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28cb7c35d7657d6478fb14db63958561/" rel="bookmark">
			【SpringBoot】SpringBoot整合RabbitMQ消息中间件，实现延迟队列和死信队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📝个人主页：哈__
期待您的关注 目录
一、🔥死信队列
RabbitMQ的工作模式
死信队列的工作模式
二、🍉RabbitMQ相关的安装 三、🍎SpringBoot引入RabbitMQ
1.引入依赖
2.创建队列和交换器
2.1 变量声明 2.2 创建延迟交换器
2.3 创建延迟队列
2.4 延迟队列绑定延迟交换器
2.5 死信队列配置
3. 添加application.yml
4. 添加RabbitMQListener （消费者）
5. 创建DelayMessageSender 6. 创建Controller 7.测试 四、🍌死信队列的应用场景
一、🔥死信队列 RabbitMQ的死信队列（Dead Letter Queue，DLQ）是一种特殊的队列，用于接收其他队列中的“死信”消息。所谓“死信”，是指满足一定条件而无法被消费者正确处理的消息，这些条件包括消息被拒绝、消息过期、消息达到最大重试次数等。
当消息成为死信时，RabbitMQ会将其重新发送到指定的死信队列，而不是丢弃它们。这样做的好处是可以对死信进行分析和处理，例如记录日志、重新入队或者进一步处理。
死信队列通常与RabbitMQ的延迟队列（Delayed Message Queue）一起使用，通过延迟队列延迟消息的处理时间，可以更容易地触发消息成为死信的条件，从而进行测试和调试。
死信队列在消息中间件中有许多实际应用场景，主要用于处理无法被正常消费的消息，增强了消息的可靠性和处理能力。以下是一些常见的应用场景：
延迟消息处理：通过将消息发送到延迟队列，在指定的时间后再将消息发送到目标队列，实现延迟处理消息的功能。
消息重试：当消费者无法处理消息时，消息可以被重新发送到队列并设置重试次数，达到最大重试次数后转发到死信队列，以便进行进一步处理。
异常处理：当消息无法被消费者正常处理时（如格式错误、业务异常等），将消息转发到死信队列，用于记录日志、报警或人工处理。
消息超时处理：当消息在队列中等待时间过长时，可以设置消息的过期时间（TTL），超过时间后将消息转发到死信队列。
消息路由失败：当消息无法被正确路由到目标队列时，可以将消息发送到死信队列，避免消息丢失。
消息版本兼容性处理：当消息的格式或内容发生变化时，通过死信队列可以处理老版本消息，确保新版本系统的兼容性。
RabbitMQ的工作模式 死信队列的工作模式 今天我要实现的就是这个延迟队列和死信队列。生产者首先向延迟队列发送消息，待达到TTL后消息会被转送到死信队列当中，消费者会从死信队列中获取消息进行消费。
二、🍉RabbitMQ相关的安装 win10 安装rabbitMQ详细步骤_rabbitmq 安装-CSDN博客
我这里直接引用别人的文章了，下载需要大家去看一看。
RabbitMQ延迟插件的安装。
[超详细]RabbitMQ安装延迟消息插件_rabbitmq安装延迟插件-CSDN博客
三、🍎SpringBoot引入RabbitMQ 1.引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28cb7c35d7657d6478fb14db63958561/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5a0b9fc33ae96802d5dd433d09514e9/" rel="bookmark">
			Web前端安全测试：深入剖析与实战策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Web前端安全测试：深入剖析与实战策略
在数字化时代，Web前端作为用户与互联网服务交互的直接窗口，其安全性至关重要。然而，随着技术的不断进步，前端安全面临的威胁也日益复杂和多样化。因此，进行Web前端安全测试成为确保应用安全性的关键一环。本文将从四个方面、五个方面、六个方面和七个方面对Web前端安全测试进行深入剖析，并提出相应的实战策略。
四个方面：Web前端安全测试的重要性与挑战
Web前端安全测试的重要性不言而喻，它能够有效发现和修复潜在的安全漏洞，提升应用的安全防护能力。然而，前端安全测试也面临着诸多挑战，如技术的快速更新、安全威胁的多样化以及测试环境的复杂性等。因此，我们需要不断更新测试技术和rmrbggkd.com方法，以应对这些挑战。
五个方面：常见的前端安全漏洞与风险
在Web前端安全测试中，我们需要重点关注一些常见的安全漏洞和风险，如跨站脚本攻击（XSS）、跨站请求伪造（CSRF）、点击劫持、HTTP头部注入等。这些漏洞可能导致用户数据泄露、恶意代码执行等严重后果。因此，我们需要深入了解这些漏洞的原理和攻击方式，以便在测试过程中有效识别和防范。
六个方面：前端安全测试的技术与工具
为了提升Web前端安全测试的效果和效率，我们可以借助一些专业的技术和工具。例如，使用自动化测试工具可以快速发现常见的安全漏洞；使用代码审计工具可以对前端代码进行静态分析，发现潜在的安全风险；使用安全扫描工具可以对整个应用进行全面的安全检查。此外，我们还需要掌握一些渗透测试的技巧和方法，以模拟攻击者的行为来检验应用的安全性。
七个方面：实战策略与最佳实践
在进行Web前端安全测试时，我们需要结合实际情况制定具体的实战策略和最佳实践。首先，我们需要明确测试的目标和范围，确保测试的全面性和有效性。其次，我们需要选择合适的测试方法和工具，以提高测试的效率和准确性。同时，我们还需要注重测试数据的收集和www.rmrbggkd.com分析，以便更好地评估应用的安全性。最后，我们需要及时更新测试技术和方法，以应对不断变化的安全威胁。
总之，Web前端安全测试是一项复杂而重要的工作。通过深入了解安全漏洞和风险、掌握测试技术和工具、制定实战策略和最佳实践，我们可以有效提升Web应用的安全性，保障用户数据的安全和隐私。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9223b86795917a1ca6d2bc90de287da1/" rel="bookmark">
			C&#43;&#43;11：列表初始化 &amp;&amp; 初始化列表initializer_list &amp;&amp; decltype关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
列表初始化
初始化列表initializer_list
decltype关键字
左值和右值
move
前言 2003年C++标准委员会曾经提交了一份技术勘误表（简称TC1），使得C++03这个名字取代了C++98成为了C++11前最新的C++标准名称。不过由于C++03主要是对C++98标准中的漏洞进行修复，语言的核心部分则没有改动，因此人们习惯性的把两个标准合并成为C++98/03标准，从C++0x到C++11到，C++委员会十年磨一剑，第二个真正意义上的C++新标准C++11在2011年姗姗来迟。
C++11则带来了数量可观的变化，其中包含了约140个新特性，以及对C++03标准中约600个缺陷的修正，此外C++11能更好的用于系统开发和库开发、语言更加泛化和简单化、程序更加稳定和安全，不仅功能强大，而且还能提升程序员的开发效率，在公司实际项目开发中也用的较多。
官网查看各编译器对C++11标准的接收情况：C++11 - 维基百科，自由的百科全书 (wikipedia.org)
补充：模板的概念是C++98引入的，不是C++11 列表初始化 基本概念：C++98只能使用{}对聚合类型进行聚合初始化（此时{}还不叫列表初始化），可以使用()对内置类型进行直接初始化，对自定义类型的对象进行构造和初始化（构造 != 初始化，先调用构造函数，可以在调用构造函数的同时进行初始化，也可以在调用构造函数后进行初始化）
问题：什么是聚合类型？
解释：聚合类型是一种特殊的自定义类型，它具有以下四个特征：
没有用户定义的构造函数：聚合类型不能有用户自定义的构造函数所有成员都是公有的：聚合类型的所有成员变量必须是公有的没有基类：聚合类型不能继承自其他类没有虚函数：聚合类型不能有虚函数 C++98中{}的注意事项：
1、对聚合类型进行的初始化叫做聚合初始化，聚合初始化与构造无关，不会调用构造函数
//聚合类型 struct Point { int x; int y; }; Point p = {1, 2}; 2、{} 可对聚合类型进行部分初始化，未显式初始化的成员会被默认初始化为零
#include &lt;iostream&gt; struct Point { int x; int y; int z; }; int main() { Point p = { 1, 2 }; // 只初始化了 x 和 y，z 会被默认初始化为 0 std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9223b86795917a1ca6d2bc90de287da1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b955e501e5d2a5b89e6b3cfd7634767b/" rel="bookmark">
			【数据结构】栈和队列--＞理解和实现（赋源码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Toc
欢迎光临我的Blog，喜欢就点歌关注吧♥
前面介绍了顺序表、单链表、双向循环链表，基本上已经结束了链表的讲解，今天谈一下栈、队列。可以简单的说是前面学习的一特殊化实现，但是总体是相似的。
前言 栈是一种特殊的线性表，它只允许在一端进行插入和删除操作。这一端被称为栈顶，另一端被称为栈底。栈的特点是后进先出（LIFO），即最后进入的元素最先被移除。
队列是另一种特殊的线性表，它允许在一端进行插入操作，在另一端进行删除操作。插入操作的一端称为队尾，删除操作的一端称为队头。队列的特点是先进先出（FIFO），即最先进入的元素最先被移除。
栈和队列有各自的特点，严格讲用顺序表还是链表的实现都可以。但我们根据结构特点选择一个更加适合的结构进行是实现。
一、栈和队列的理解 对于栈的理解： 栈如同这个图一样，要是想拿出数据，必须从上面一个一个往下面拿。这也正是 LIFO 的体现。
对于队列的理解： 队列如同这个图一样，要是想拿出数据，必须前面一个一个往向后面拿。这也正是 FIFO 的体现。
二、栈的实现（顺组表） 2.1 栈的功能 //初始化 void STInit(ST* ps); //压栈 void STpush(ST* ps, STDataType x); //删除 void STPop(ST* ps); //大小 int STSize(ST* ps); //判空 bool STEmpty(ST* ps); //出栈 STDataType STTop(ST* ps); //检查容量 void CheckCapacity(ST* ps); //销毁 void STDestroy(ST* ps); 2.2 栈结构体的定义及其初始化 结构体的定义 typedef int STDataType; typedef struct stack { STDataType* a; int top; int capacity; }ST; 初始化（开辟空间） void STInit(ST* ps) { assert(ps); ps-&gt;a = (STDataType*)malloc(sizeof(STDataType)*4); if (ps-&gt;a == NULL) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b955e501e5d2a5b89e6b3cfd7634767b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d1561ad67cb1562af8a5f36506a597f/" rel="bookmark">
			【数据结构】双向带头（哨兵位）循环链表 —详细讲解（赋源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到我的Blog，点击关注哦💕
前面介绍单向不带头（哨兵位）链表，双向相比于单向而言，存贮，查找，会更加便利。
前言 双向循环列表是一种特殊的数据结构，它结合了双向链表和循环链表的特点。在双向循环列表中，每个节点除了拥有指向下一个节点的指针外，还拥有指向上一个节点的指针。此外，列表的头节点和尾节点通过这些指针相互连接，形成一个闭环。这种结构允许从任何一个节点开始，既可以向前遍历，也可以向后遍历，直到回到起点，从而实现高效的双向遍历。
一、双向带头循环链表的基本介绍 定义节点结构：每个节点包含数据部分和两个指针部分，分别指向前一个节点和后一个节点。
创建头节点：头节点是双向循环列表的起始点，它的前驱指针指向自己，后继指针也指向自己，形成一个闭环。
插入节点：在特定位置插入新节点时，需要更新新旧节点的前驱和后继指针，确保列表的完整性。
删除节点：删除特定节点时，同样需要更新前后节点的指针，避免出现悬空指针。
遍历列表：可以通过前驱指针或后继指针从任意节点开始，向前或向后遍历整个列表。
双向带头链表的操作 常见操作包括初始化、插入、删除、查找和遍历。这些操作通常涉及到对链表节点的指针进行操作，以实现数据的动态管理。
双向带头循环链表基本理解 head A b C D E .... 二、双向带头循环链表的实现 2.1 双向带头循环链表的功能 //链表初始化创建哨兵位 ListNode* ListInit(); //连接表增加节点 ListNode* BuyNewNode(ListDataType x); //链表打印 void DlistPrint(ListNode* phead); //链表尾插 void DLlistPushBack(ListNode* phead, ListDataType x); //链表尾删 void DLlistPopBack(ListNode* phead); //链表头插 void DLlistPushFront(ListNode* phead, ListDataType x); //链表头删 void DLlistPopFront(ListNode* phead); //链表查找 ListNode* DListFind(ListNode* phead, ListDataType pos); //链表pos插入 void DListInset(ListNode* pos, ListDataType); //链表pos删除 void DListErase(ListNode* phead, ListNode* pos); //链表销毁 void DListDestory(ListNode* phead); 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d1561ad67cb1562af8a5f36506a597f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d24c0fbfa5c09382842ae73add6aa700/" rel="bookmark">
			【数据结构】单链表--＞详细讲解，后赋源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到我的Blog，点击关注哦💕
前面已经介绍顺序表，顺序表存在一定的局限性，空间管理上存在一定的缺陷，今天介绍新的存储结构单链表。
前言： 单链表是一种基本的数据结构，它由一系列节点组成，每个节点包含数据部分和一个指向下一个节点的指针。在单链表中，每个节点的地址不一定是连续的，而是通过指针相互链接起来。单链表的特点是存储灵活，可以动态地添加或删除节点，不需要预先分配固定大小的存储空间。
一、单链表基本介绍 单链表创建 1.定义节点结构体：首先需要定义一个结构体来表示链表的节点，通常包括数据域和指针域。
2.动态创建节点：使用malloc函数为每个节点分配内存空间，并初始化数据域和指针域。
3.插入节点：根据需要将新节点插入到链表的适当位置。插入操作可以是头插法或尾插法。
4.遍历链表：通过遍历链表，可以访问链表中的每个节点，通常用于打印或搜索特定数据。
单链表的操作 单链表的常见操作包括插入、删除、查找和遍历。这些操作通常涉及到对链表节点的指针进行操作，以实现数据的动态管理。
单链表的理解 链表同名字一样，像一个链子一样，有一个一个节点相连接。
A B C D E .... 二、单链表的实现 2.1 单链表的功能 分装成函数，有助于我们一一管理。
// 动态申请一个节点 SListNode* BuySListNode(SLTDateType x); // 单链表打印 void SListPrint(SListNode* plist); // 单链表尾插 void SListPushBack(SListNode** pplist, SLTDateType x); // 单链表的头插 void SListPushFront(SListNode** pplist, SLTDateType x); // 单链表的尾删 void SListPopBack(SListNode** pplist); // 单链表头删 void SListPopFront(SListNode** pplist); // 单链表查找 SListNode* SListFind(SListNode* plist, SLTDateType x); // 单链表在pos位置之后插入x void SListInsertAfter(SListNode* pos, SLTDateType x); // 在pos的前面插入 void SLTInsert(SListNode** pplist, SListNode* pos, SLTDateType x); // 单链表删除pos位置之后的值 void SListEraseAfter(SListNode* pos); // 删除pos位置 void SLTErase(SListNode** pplist, SListNode* pos); ///删除pos前面的值 void SListEraseFront(SListNode* pos); //单链表的销毁 void SLTDestory(SListNode** pphead); 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d24c0fbfa5c09382842ae73add6aa700/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/290/">«</a>
	<span class="pagination__item pagination__item--current">291/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/292/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>