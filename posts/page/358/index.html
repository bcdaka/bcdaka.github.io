<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6afd5e92648ece9ff15e6c28a8475b3/" rel="bookmark">
			手撕数据结构之双向链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.链表的分类 有三种属性可以组成8（2*2*2）种 带头 不带头
单向 双向
循环 不循环
其中最常用的为两种形式：单链表 和 双向链表
2.双向链表的基本结构 双向链表的全称为（带头双向循环链表），所以要定义出双向链表就得从这三步来入手
1.带头：说明它拥有头结点（也就是有哨兵位）
2.双向：说明他不仅拥有后继指针（这里暂且命名为next）也拥有前置指针（命名为prev）
3.循环：说明链表首位相连，即尾节点指向哨兵位
4.实现：
3.初始化双向链表 双向链表初始化与单链表初始化并不一样
双向链表需要在初始化前定义头结点
4.尾插 1.为尾插数据开辟出一块节点
2.根据位置关系改变其后置指针以及前置指针
3.注意改完后phead-&gt;prev会不会改变，最好将其放到最后
5.尾删 1.首先得保证有的删：即assert(phead&amp;&amp;phead-&gt;next)
2.记得删完后进行销毁操作
6.头插 1.头插不是在哨兵位前面，而是在哨兵位与第一个节点之间
2.进行节点连接前先定义插入节点的前置和后置指针，这样双向链表的指针关系不会被误改
3.注意改完后phead-&gt;next会不会改变，最好将其放到最后
7.头删 8.查找 注意循环结束条件
9.在指定位置之后插入数据 1.pos后必须得有数据：assert (pos&amp;&amp;pos-&gt;next);
2.进行节点连接前先定义插入节点的前置和后置指针，这样双向链表的指针关系不会被误改
3.注意改完后phead-&gt;next会不会改变，最好将其放到最后
10.删除指定位置数据 代码 List.h List.c 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d33a9257469d764edd46a3fa9f182aeb/" rel="bookmark">
			【flutter】 Running Gradle task ‘assembleDebug‘...超时问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关联搜索：flutter下载gradle失败、AndroidStudio下载gradle失败
构建Flutter项目时遇到控制台一直卡在 Running Gradle task ‘assembleDebug’…
解决方案 1. 修改gradle-wrapper.properties 文件 如果找不到就直接搜索：
把https\://services.gradle.org/distributions/替换为https://mirrors.cloud.tencent.com/gradle/：
2. 修改build.gradle文件 插入以下代码：
maven { url 'https://maven.aliyun.com/repository/google' } maven { url 'https://maven.aliyun.com/repository/jcenter' } maven { url 'https://maven.aliyun.com/nexus/content/groups/public' } 更换下载源，重新构建基本就能解决问题，如果仍不行，还可能有gradle已被污染的问题
3. 删除gradle 找到Gradle下载位置，默认在C:\Users\你的用户名\.gradle\wrapper\dists
把对应版本的gradle文件删除，然后重新构建项目会重新下载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f5b48aeb1c5fcfe7d47102d7aada5dc/" rel="bookmark">
			vue前端实现导出页面为word(两种方法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将vue页面导出为word文档，不用写模板，直接导出即可。 第一种方法(简单版) 第一步：安装所需依赖 npm install html-docx-js -S npm install file-saver -S 第二步：创建容器，页面使用方法 注意：在当前页面引入依赖
import FileSaver from "file-saver"; import htmlDocx from "html-docx-js/dist/html-docx";** 第二种方法（需要使用jquery） 第一步：安装所需依赖 npm install jquery --save npm install file-saver 第二步：创建两个js文件，一个是jquery文件(jq.js)，一个是插件js的文件(jquery.wordexport.js)，我把这两个js文件都放到utils文件夹下，注意：使用的时候一定要注意引用路径。这两个js文件代码我都放到文章最后（有一个插件没有依赖包，所以需要自己创建一个js文件（jquery.wordexport.js）） 第三步：在需要导出的页面引入文件 import $ from "@/utils/jq"; // 文件引入路径一定要正确，这是第二步创建的js文件（jq.js） import saveAs from "file-saver/dist/FileSaver"; import "@/utils/jquery.wordexport"; // 文件引入路径一定要正确，这是第二步创建的js文件(jquery.wordexport.js) 第三步：页面使用方法 注意：如果导出的时候出现bug，大多是因为文件路径引入有问题，再次排查路径引入
jq.js import $ from "jquery"; window.$ = $; window.jQuery = $; export default $; jquery.wordexport.js if (typeof jQuery !== "undefined" &amp;&amp; typeof saveAs !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f5b48aeb1c5fcfe7d47102d7aada5dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ded44612f84428af35f4a41613df8f21/" rel="bookmark">
			Spring Cloud系列—Spring Cloud Gateway服务网关的部署与使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Gateway网关 文章目录 Gateway网关1. 网关基本简介1.1 什么是网关1.2 为什么需要网关？ 2. 快速搭建gateway网关2.1 创建新模块2.2 引入依赖2.3 编写启动类2.4 配置路由规则2.5 测试 3. 路由过滤4. 过滤器4.1 简介4.2 网关过滤器4.2.2 种类 4.3 自定义过滤器4.3.1 自定义GatewayFilter4.3.2 自定义GlobalFilter 4.4 跨域问题4.4.1 什么是跨域问题4.4.2 解决跨域问题 5. 总结 1. 网关基本简介 1.1 什么是网关 网关，简而言之，是一个系统的单一入口点，它接收所有外部请求，并根据请求的特性（如路径、HTTP方法等）将其转发给内部的各个微服务。
比如说，你想要向一个小区内的一个朋友送信，必须要经过看门大爷的同意，大爷如果认为好人，就会把信带给你要送的人；如果大爷认为你是坏人，就会拦截你。
1.2 为什么需要网关？ 路由：微服务架构通常由多个服务组成，每个服务可能部署在不同的地址和端口上。网关可以根据请求的URL或其他条件，将外部请求路由到正确的服务实例上，从而隐藏了服务实例的具体位置。负载均衡：当服务有多个实例时，网关可以根据不同的负载均衡策略（如轮询、随机、最少连接等）将请求分发到不同的实例，确保系统资源的有效利用和服务的稳定性。统一鉴权和认证：在微服务架构中，每个服务都可能有自己的安全要求。网关可以作为统一的鉴权和认证点，处理所有服务的安全验证，简化了服务之间的安全通信。跨域处理：由于浏览器的同源策略，前端应用在访问不同域名或端口的后端服务时可能会遇到跨域问题。网关可以配置CORS（跨源资源共享）策略，允许前端应用安全地访问后端服务。熔断和限流：网关可以集成熔断和限流机制，当后端服务出现问题时，网关可以快速失败，防止级联故障。同时，限流可以控制对后端服务的请求速率，防止服务过载。监控和日志：网关是所有外部请求的入口点，可以在这一层收集和记录重要的监控数据和日志信息，帮助开发者和运维人员快速定位问题和性能瓶颈。 2. 快速搭建gateway网关 基本步骤：
创建新模块引入网关依赖编写启动类配置路由规则 2.1 创建新模块 创建一个新模块gatewawy：
2.2 引入依赖 &lt;!--网关--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--nacos 服务发现--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--负载均衡--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt; &lt;/dependency&gt; 2.3 编写启动类 @SpringBootApplication public class GatewayApplication { public static void main(String[] args) { SpringApplication.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ded44612f84428af35f4a41613df8f21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2b7b74879fd64d8cb75a1917aa4fb22/" rel="bookmark">
			【C&#43;&#43;要哮着学】初识C&#43;&#43;，函数重载、引用和内联函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、函数重载1.函数重载概念2.函数重载分类1.形参类型不同2.参数个数不同3.参数类型顺序不同 3.函数重载的陷阱4. C++支持函数重载的原理--名字修饰(name Mangling) 二、引用1.引用概念2.引用的特性3.常引用4.应用场景1.做参数2.做返回值 5.引用陷阱6.传值、传引用的效率比较7. 值和引用的作为返回值类型的性能比较8.引用和指针的区别 三、内联函数1.概念2.内联函数的特性3.内联函数与宏的比较4.内联函数的不足 前言 一、函数重载 自然语言中，一个词可以有多重含义，人们可以通过上下文来判断该词真实的含义，即该词被重载了。
1.函数重载概念 函数重载：是函数的一种特殊情况，C++允许在同一作用域中声明几个功能类似的同名函数，这些同名函数的形参列表(参数个数 或 类型 或 类型顺序)不同，常用来处理实现功能类似数据类型不同的问题。
2.函数重载分类 1.形参类型不同 #include&lt;iostream&gt; using namespace std; int func(int a, int b) { cout &lt;&lt; "int func(int a,int b)" &lt;&lt; endl; return a + b; } double func(double a, double b) { cout &lt;&lt; "double func(double a, double b)" &lt;&lt; endl; return a + b; } int main() { func(1, 2); func(1.0, 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2b7b74879fd64d8cb75a1917aa4fb22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef81863548a839ddb7650df75f6e7f9c/" rel="bookmark">
			Oracle表关联更新几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、测试表及数据准备 create table T_update01(ID int ,infoname varchar2(32),sys_guid varchar2(36)); create table T_update02(ID int ,infoname varchar2(32),sys_guid varchar2(36)); insert into T_update01 select 1,N'1_updateName',sys_guid() from dual union select 2,N'2_updateName',sys_guid() from dual; commit; insert into T_update02 select 1,N'update_set_exists',sys_guid() from dual; insert into T_update02 select 2,N'update_set_cursor',sys_guid() from dual; insert into T_update02 select 3,N'3_Name',sys_guid() from dual; commit; -- 查询表T_update01、T_update02 select * from T_update01; ID INFONAME SYS_GUID ---------- ------------------------------ ------------------------------------ 1 1_updateName 189F5A1099BF6606E0639C0AA8C0F15E 2 2_updateName 189F5A1099C06606E0639C0AA8C0F15E select * from T_update02; ID INFONAME SYS_GUID ---------- ------------------------------ ------------------------------------ 1 update_set_exists 189F5A1099C46606E0639C0AA8C0F15E 2 update_set_cursor 189F5A1099C56606E0639C0AA8C0F15E 3 3_Name 189F5A1099C66606E0639C0AA8C0F15E 2、update set column .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef81863548a839ddb7650df75f6e7f9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e962b37e9ca72485a7f86b1101b259b1/" rel="bookmark">
			Centos7安装MongoDB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、安装包安装MongoDB1. MongoDB安装包下载2. 安装3. 启动4. 其他配置（1）开放端口（2）设置开机自启动 参考 二、yum安装MongoDB 一、安装包安装MongoDB 1. MongoDB安装包下载 官网地址：https://www.mongodb.com/try/download/community
或者输入：
wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-4.0.27.tgz 2. 安装 1、解压安装包
tar -zxvf mongodb-linux-x86_64-rhel70-4.0.27.tgz 2、将解压后的目录移动到 /usr/local 目录下，并改名为 mongodb
mv mongodb-linux-x86_64-rhel70-4.0.27 /usr/local/mongodb 3、进入 mongodb 目录，并创建文件夹 data，在 data 文件夹下再创建 db 文件夹（用于存放数据库数据）和 log文件夹（存放 mongo 日志）。然后为其设置可读写权限。
# 进入目录 cd /usr/local/mongodb/ # 创建三个文件夹 mkdir data data/db data/log # 设置可读写权限 sudo chmod 666 data/db data/log/ 4、在 mongodb 目录下新建配置文件 mongodb.conf（可选，但建议配置），打开文件输入以下内容
# 数据库数据存放目录 dbpath=/usr/local/mongodb/data/db # 日志文件存放目录 logpath=/usr/local/mongodb/data/log/mongodb.log # 日志追加方式 logappend=true # 端口 port=27017 # 是否认证 auth=true # 以守护进程方式在后台运行 fork=true # 远程连接要指定ip，否则无法连接；0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e962b37e9ca72485a7f86b1101b259b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3227dd9c2a22789db628a0e3bc3089be/" rel="bookmark">
			三十个中文AI对话网站推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
写在前面
一、kimi
二、WeexAI
三、Cursor
四、智谱清言
五、讯飞星火
六、通义千问
七、文心一言
八、混元
九、豆包AI
十、其它
写在前面 总的来说，现在国内能用到的大模型类产品分国产和套壳两种。对于中文任务，这些大模型功能都大同小异，能力也相差不大，扩写、润色、写论文都够用了，写代码的话肯定还是老外的大模型更靠谱些。
如果确实觉得国产大模型不够劲，你可以直接注册OpenAI，这里不介绍，我怕这篇文章无了。或者从下面的工具中找一个充会员，做一个尊贵VVVIP用户。
一、kimi 地址：https://kimi.moonshot.cn/
介绍：新近的国货之光，公司是月球之暗面，这名字还怪有文化，完全免费，支持联网查询，支持文档理解。一发布就因为“工作压力”太大 彻底崩溃了，当然已经恢复，应该是习惯了“工作压力”。
二、WeexAI 地址：https://a.weexai.pro/zh-CN/chat/
介绍：有对话和文生图功能，文生图比较弱，主要用对话就可以了，集成了GPT、Claude、Gemini、Llama 2等大模型，其中GPT-3.5-turbo和Llama 2可以免费试用一万Tokens，好处是注册只用邮箱，不验证手机号，每个新账号送一万Tokens。
三、Cursor 下载地址：https://cursor.sh/ 介绍：这是一个客户端，可以免费使用GPT-4，登录（可以用github账号登录）之后每月可以免费使用GPT-4 50次、GPT-3.5 100次，具体的使用可以看这里，当然现在升级了，增加了很多功能，比如可以输入自己的OpenAI API。
四、智谱清言 地址： https://www.chatglm.cn/
介绍：国产大模型，而且开源了ChatGLM，能对话、能画图、能联网、能角色扮演（妙啊），完全免费，质量还不错。
五、讯飞星火 地址：https://xinghuo.xfyun.cn/
介绍：讯飞的大模型，国产、免费、中规中矩，感觉返回的结果有点短，缺少一泻千里的感觉o(*￣︶￣*)o。
六、通义千问 地址：https://tongyi.aliyun.com/
介绍：阿里的大模型，国产、免费、中规中矩，可以下载他的APP玩玩，一张图片就能跳舞的那个功能还挺有意思。
七、文心一言 地址：https://yiyan.baidu.com/
介绍：号称最优秀的中文大模型，中文能力超过GPT-4，对话之余有一些工具可用。值得注意的是，不要上传违禁的图片，真封号啊！！不要问我怎么知道的。
八、混元 地址：https://hunyuan.tencent.com/bot/chat
介绍：腾讯的大模型，国产、免费、中规中矩，也有一些场景可用。
九、豆包AI 地址：https://www.doubao.com/chat/
介绍：抖音的大模型，国产、免费、中规中矩，有一些场景工具。
十、其它 下面还有几个套壳的工具，功能都差不多，集成了好多国外模型。
0.一个不错的AI工具汇总网站 https://feizhuke.com/#term-6606
1.Poe https://poe.com/
2.magic-ai http://chat.magic-ai.cc/#/preset
3.https://chat.tool4j.com 4.https://seboai.github.io 5.http://gpt1.v2.ikmai.cn 6.https://amgpt4.github.io
7.https://chat.iosshop.xyz 8.https://ai.xiamis.xyz 9.https://chat18.aichatos.xyz 10.https://www.ai.iisgpt.com 11.https://chat.irss.eu.org 12.https://a.aging.run 13.https://chatbot.js.cn 14.https://gezhe.com 15.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3227dd9c2a22789db628a0e3bc3089be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d0aab0b271cc989a030eac4374f1557/" rel="bookmark">
			Stable Diffusion详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Stable Diffusion详解 一、Stable Diffusion简介 Stable Diffusion是一种生成对抗网络（GAN）的变体，专注于高质量图像生成。它利用扩散过程和去噪技术逐步生成图像，并且在各类图像生成任务中表现出色。本文将详细介绍Stable Diffusion的原理、实现步骤以及一些实际应用案例。
二、Stable Diffusion的核心原理 2.1 扩散过程（Diffusion Process） 扩散过程是一种从噪声逐渐生成图像的技术。其核心思想是将随机噪声通过一系列逐步去噪的步骤转化为高质量的图像。这个过程包含了以下几个步骤：
初始噪声生成：生成一个完全随机的噪声图像。逐步去噪：通过多次迭代，将噪声图像逐步转化为目标图像。 2.2 去噪过程（Denoising Process） 去噪过程使用深度学习模型对噪声图像进行逐步去噪。在每一步，模型会预测当前图像的去噪版本，并且随着步骤的增加，图像的细节逐步清晰。
2.3 模型架构 Stable Diffusion通常采用UNet架构来进行图像生成。UNet是一种常用于图像处理任务的卷积神经网络，具有跳跃连接（skip connections），可以在高分辨率和低分辨率特征之间传递信息。
三、Stable Diffusion的实现步骤 3.1 环境准备 首先，需要准备好运行环境，包括安装必要的库和工具。这里以Python和PyTorch为例。
pip install torch torchvision torchaudio pip install diffusers 3.2 数据准备 为了训练Stable Diffusion模型，需要准备好高质量的图像数据集。这里以CIFAR-10数据集为例。
from torchvision import datasets, transforms transform = transforms.Compose([ transforms.ToTensor(), transforms.Normalize((0.5,), (0.5,)) ]) train_dataset = datasets.CIFAR10(root='./data', train=True, download=True, transform=transform) train_loader = torch.utils.data.DataLoader(train_dataset, batch_size=64, shuffle=True) 3.3 模型定义 定义UNet模型，用于逐步去噪图像。
import torch import torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d0aab0b271cc989a030eac4374f1557/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1441c8a97c36959332f66a3e074ba39f/" rel="bookmark">
			【Llama3:8b】手把手教你如何在本地部署 自己的 AI 大模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、为什么需要本地部署属于自己的大模型？ 趋势：我们正处于AI人工智能时代，各行各业的公司和产品都在向AI靠拢。打造垂直领域的AI模型将成为每个公司未来的发展趋势。数据安全：在无法掌握核心算法的情况下，许多公司选择使用大公司的成熟方案。然而，这涉及到数据安全的问题。训练垂直定制化的大模型需要大量数据，而数据是公司的核心资产和基石。没有公司愿意将这些关键数据上传到外部服务器，这是公司的命脉所在。本地部署的重要性：因此，本地部署和训练自有或定制化的大模型显得尤为重要。这不仅是未来的发展趋势，也是程序员必须掌握的关键流程和解决方案。 二、如何拥有属于自己的本地大模型呢？ 经过博主深入评估和多次测试，为您推荐以下解决方案：
使用 Llama3:8b 作为模型通过 Ollama 部署利用 Llama.cpp 进行量化优化采用 Unsloth 进行模型训练和微调 三、为什么要选择这个方案？ 1、Llama3:8b 低算力需求和成本：Llama3:8b 对计算资源的需求较小，运营成本低。卓越的上下文记忆能力：模型能够有效记住上下文，满足业务需求。灵活的微调能力：适应不同的业务场景和需求。开源：社区支持强大，开发者资源丰富。 2、Ollama 活跃的生态和开发者社区：提供丰富的资源和支持。高效的部署和运行：确保模型的稳定性和性能。灵活的 API 接口：满足业务对训练模型的多样化需求。开源且易于使用：降低了上手难度，适合快速开发和迭代。 3、Llama.cpp 广泛支持 Llama3:8b 的量化工具：目前市面上对 Llama3:8b 支持最好的量化工具之一。丰富的教程资源：学习和使用成本低。开源：开发者可以自由使用和修改，社区贡献积极。 4、Unsloth 多样化的数据集支持：能够处理不同类型的数据，适应性强。优异的性能：训练效果显著，能够提高模型的精度。本地训练支持：对数据隐私有更好的保护。开源：开发者可以自由访问和修改，提升了灵活性和可控性。 四、话不多说，让我们开始吧！ 1、安装 Ubuntu 【NVIDIA GPU驱动安装】 为什么需要使用 GPU 去跑我们的大模型呢？
训练时间：使用GPU可以显著缩短模型的训练时间。例如，一个复杂的深度学习模型在GPU上可能只需要几小时，而在CPU上可能需要几天甚至几周。模型推理：在推理阶段，尤其是需要处理大量实时数据时，GPU的高并行处理能力可以提供更快的响应时间和更高的吞吐量。 虽然CPU也可以用于运行大模型，但在处理深度学习任务时，GPU的并行计算能力、计算性能和专用硬件支持使其更为适合。GPU能够显著提升大模型的训练和推理效率，降低时间和功耗成本。
一、官方方案
参考文档：
CUDA Toolkit 12.4 Update 1 Downloads | NVIDIA Developer
二、方案二（经实践，简单 好用）
1、安装 CUDA:
官网脚本： developer.nvidia.com/cuda-toolki…
shell 复制代码 # 脚本文件命令（根据上述网站） wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2204/x86_64/cuda-ubuntu2204.pin sudo mv cuda-ubuntu2204.pin /etc/apt/preferences.d/cuda-repository-pin-600 wget https://developer.download.nvidia.com/compute/cuda/12.1.0/local_installers/cuda-repo-ubuntu2204-12-1-local_12.1.0-530.30.02-1_amd64.deb sudo dpkg -i cuda-repo-ubuntu2204-12-1-local_12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1441c8a97c36959332f66a3e074ba39f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c47cb9edd1ee685569f206327e901eb/" rel="bookmark">
			系列学习前端之第 11 章：将前端项目部署到本机运行起来 2 种方式（使用 Express 和 Nginx），使用花生壳做内网穿透，让外网可以访问网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导语 当我们开发完前端项目的时候，需要把项目部署到服务器上运行起来。一般来说在公司里开发的项目，都有专门的运维人员负责部署，或者通过 Jenkins 等集成部署工具让开发人员自行部署。本篇博客简单介绍将前端项目部署到自己的电脑并运行起来。主要讲解 Express 框架和 Nginx。
在前后端分离的社会环境下，大部分前端项目都是通过 Nginx 的方式进行部署，因为 Express 框架是基于 Node.js 平台，Node.js运行的是 js 代码，而现在已经很少很少有企业级项目使用纯 js 代码来编写后端业务逻辑了。
部署完之后，我们想让外网来访问（而不是localhost 或者局域网）项目（不购买云服务器的情况下），让远在他乡的同学朋友能访问，趁机炫技一波，就需要将本机的内网穿透出去（如果你的电脑连网络都没有就当我没说）。
1、Express Express是一个基于 Node.js 平台的极简、灵活的 Web 应用开发框架。简单来说，Express 是一个封装好的工具包，封装了很多功能，方便我们开发 web 应用。
官网地址：https://www.expressjs.com.cn/
1.1 Express 环境搭建 Express 本身是一个 npm 包，所以可以通过 npm 安装。如果你对 Node.js 和 npm 一无所知，可以先阅读我之前的博客：
系列学习前端之第 9 章：一文搞懂 Node.js 和 nvm，掌握 npm
OK，我们使用 VSCode 工具新建一个 express 空目录。鼠标右键【在集成终端中打开】
1.1.1 包初始化 npm init -y 说明： npm init -y 或者 npm init --yes
如果命令行不加 -y 或者 --yes，npm 则会采用“交互式”的方式带领我们去创建 package.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c47cb9edd1ee685569f206327e901eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eea6996233e983d2e51b3144636002ec/" rel="bookmark">
			万字长文，详细解读AI大模型技术原理！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大模型是指具有大规模参数和复杂计算结构的机器学习模型。
本文从大模型的发展历程出发，对大模型领域的各个技术细节进行详细解读，供大家在了解大模型基本知识的过程中起到一定参考作用。
一、大模型的定义 大语言模型作为一个被验证可行的方向，其“大”体现在训练数据集广，模型参数和层数大，计算量大，其价值体现在通用性上，并且有更好的泛化能力。
这些模型通常由深度神经网络构建而成，拥有数十亿甚至数千亿个参数。
大模型的设计目的是为了提高模型的表达能力和预测性能，能够处理更加复杂的任务和数据。
大模型在各种领域都有广泛的应用，包括自然语言处理、计算机视觉、语音识别和推荐系统等。
大模型通过训练海量数据来学习复杂的模式和特征，具有更强大的泛化能力，可以对未见过的数据做出准确的预测。
ChatGPT 对大模型的解释更为通俗易懂，也更体现出类似人类的归纳和思考能力：大模型本质上是一个使用海量数据训练而成的深度神经网络模型，其巨大的数据和参数规模，实现了智能的涌现，展现出类似人类的智能 。
那么，大模型和小模型有什么区别？ 小模型通常指参数较少、层数较浅的模型，它们具有轻量级、高效率、易于部署等优点，适用于数据量较小、计算资源有限的场景，例如移动端应用、嵌入式设备、物联网等。
而当模型的训练数据和参数不断扩大，直到达到一定的临界规模后，其表现出了一些未能预测的、更复杂的能力和特性，模型能够从原始训练数据中自动学习并发现新的、更高层次的特征和模式，这种能力被称为“涌现能力”。
而具备涌现能力的机器学习模型就被认为是独立意义上的大模型，这也是其和小模型最大意义上的区别。 相比小模型，大模型通常参数较多、层数较深，具有更强的表达能力和更高的准确度，但也需要更多的计算资源和时间来训练和推理，适用于数据量较大、计算资源充足的场景，例如云端计算、高性能计算、人工智能等。
二、大模型相关概念区分
大模型（Large Model,也称基础模型，即 Foundation Model），是指具有大量参数和复杂结构的机器学习模型，能够处理海量数据、完成各种复杂的任务，如自然语言处理、计算机视觉、语音识别等。
超大模型：超大模型是大模型的一个子集，它们的参数量远超过大模型。
大语言模型（Large Language Model）：通常是具有大规模参数和计算能力的自然语言处理模型，例如 OpenAI 的 GPT-3 模型。这些模型可以通过大量的数据和参数进行训练，以生成人类类似的文本或回答自然语言的问题。大型语言模型在自然语言处理、文本生成和智能对话等领域有广泛应用。
GPT（Generative Pre-trained Transformer）：GPT 和 ChatGPT 都是基于 Transformer 架构的语言模型，但它们在设计和应用上存在区别：GPT 模型旨在生成自然语言文本并处理各种自然语言处理任务，如文本生成、翻译、摘要等。它通常在单向生成的情况下使用，即根据给定的文本生成连贯的输出。
ChatGPT：ChatGPT 则专注于对话和交互式对话。它经过特定的训练，以更好地处理多轮对话和上下文理解。ChatGPT 设计用于提供流畅、连贯和有趣的对话体验，以响应用户的输入并生成合适的回复。
三、大语言模型的发展 大模型相较于传统特定领域训练出来的语言模型，有更广泛的应用场景。
3.1 Transformer模型的提出 在Transformer提出之前，自然语言处理领域的主流模型是循环神经网络RNN，使用递归和卷积神经网络进行语言序列转换。
2017年，谷歌大脑团队在人工智能领域的顶会NeurIPS发表了一篇名为“Attention is all you need”的论文，首次提出了一种新的简单网络架构，即 Transformer，它完全基于注意力机制(attention)，完全摒弃了循环递归和卷积。
递归模型通常沿输入和输出序列的符号位置进行计算，来预测后面的值。
但这种固有的顺序性质阻碍了训练样例内的并行化，因为内存约束限制了样例之间的批处理。
而注意力机制允许对依赖项进行建模，而无需考虑它们在输入或输出序列中的距离。
Transformer避开了递归网络的模型体系结构，并且完全依赖于注意力机制来绘制输入和输出之间的全局依存关系。
在八个P100 GPU上进行了仅仅12个小时的训练之后，Transformer就可以在翻译质量方面达到新的最先进水平，体现了很好的并行能力。
总结两个核心突破：
1）突破了远距离文本依赖的学习限制，避开了递归网络的模型体系结构，并且完全依赖于注意力机制来绘制输入和输出之间的全局依赖关系。
2）可高度并行进行训练，这对发挥硬件红利以及快速迭代模型非常重要。
下图是论文提到的Transformer模型，对编码器和解码器使用堆叠式的自注意力和逐点式、全连接层，分别如图1的左半部分（编码器）和右半部分（解码器）所示，相关技术细节后面会重点讲到。
OpenAI基于该工作基础上发展了GPT（Generative Pre-training）生成式预训练模型，这里借用网上一张图简单改过，相关细节将在后面展开。
3.2 生成式预训练初现潜力：GPT-1 2018年，OpenAI公司发表了论文“Improving Language Understanding by Generative Pre-training”，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eea6996233e983d2e51b3144636002ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c498c5e4ec153d7873708de00af95610/" rel="bookmark">
			【TPC-C】TPC-C标准化基准测试设计RDBMS的相关表结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
🌞1. TPC-C的初步认识
🌊1.1 TPC的概念
🌊1.2 TPC-C 的概念
🌊1.3 TPC-C 的事务处理
🌞2. TPC-C的逻辑数据库设计
🌊2.1 业务及应用环境
🌊2.2 数据库实体、关系和特征
🌊2.3 表布局
🌞3. TPC-C表结构的sqlite语句实现
🌊3.1 创建数据库表，共9个表
🌊3.2 创建索引和外键
🌊3.3 删除的约束
🌞4. TPCC-MySQL
🌊4.1 TPCC-MySQL简介
🌊4.2 操作步骤
🌍a. 构建二进制文件
🌍b. 加载数据
🌍c. 开始基准测试
🌊4.3 结果分析
🌍a. 官网示例说明
🌍b. 本文示例说明
🌞参考链接
🌞1. TPC-C的初步认识 🌊1.1 TPC的概念 TPC 是事务处理性能委员会组织，该委员会致力于制定和维护一系列标准化的基准测试，以评估商业计算系统的性能。其中最著名的是一系列用于评估计算机系统性能的基准测试。
以下是TPC组织使用的一些标准：
TPC-C： 用于评估在线事务处理（OLTP）系统的性能，模拟了一个批发商环境中的典型业务场景，包括订单处理、库存管理等操作。
TPC-H： 用于评估数据仓库系统的性能，模拟了一个典型的决策支持系统环境，包括复杂的查询和报表操作。
TPC-DI： 用于评估数据仓库系统的性能，模拟了一个典型的决策支持系统环境，包括数据加载、查询等操作。
TPC-DS： 用于评估数据仓库系统的性能，模拟了一个典型的决策支持系统环境，包括复杂的查询操作、数据加载等。
TPCx-BB： 用于评估大数据系统的性能，包括数据加载、复杂查询等操作。
除了这些基准测试之外，TPC组织还制定了一些其他标准，用于规范化基准测试的执行和报告，以确保测试的公正性、可重复性和可比性。
🌊1.2 TPC-C 的概念 官网传送门：TPC-C 官网
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c498c5e4ec153d7873708de00af95610/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1473f5f08e30905c6247f700df85c12f/" rel="bookmark">
			python:删掉重复行之drop_duplicates（）用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、基本用法
二。示例
drop_duplicates()是Pandas中一个非常实用的方法，用于从DataFrame或Series中删除重复的行或值，只保留第一次出现的记录。
一、基本用法 它的基本语法如下：
DataFrame.drop_duplicates(subset=None, keep='first', inplace=False) subset：可选参数，指定考虑哪些列来判断重复，默认为所有列。你可以传入一列或多列的列名列表（作为字符串列表）来确定重复性。
keep：可选参数，决定如何处理重复项。
'first'（默认）：保留每个重复组中的第一个出现的行。'last'：保留每个重复组中的最后一个出现的行。False：删除所有重复的行。 inplace：可选参数，如果设置为True，则直接在原DataFrame上进行修改，不返回新的DataFrame。
二。示例 import pandas as pd data = {'Name': ['Alex', 'Bob', 'Clarke', 'Alex', 'Bob'], 'Age': [25, 30, 22, 25, 30], 'City': ['NY', 'LA', 'SF', 'NY', 'LA']} df = pd.DataFrame(data) print("Original DataFrame:") print(df) 如果我们想删除所有重复的行（基于所有列），可以这样做：
df_unique = df.drop_duplicates() print("\nDataFrame after removing duplicates (all columns):") print(df_unique) 如果我们只想根据'Name'和'Age'列来判断重复，并保留每个重复组的第一个出现：
df_unique_subset = df.drop_duplicates(subset=['Name', 'Age']) print("\nDataFrame after removing duplicates (Name and Age columns):") print(df_unique_subset) 如果希望删除所有重复，不保留任何重复行：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1473f5f08e30905c6247f700df85c12f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48562be234d07c1684aa487091962ea8/" rel="bookmark">
			【C语言】精妙运用内存函数：深入底层逻辑的探索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、内存函数的使用1.1 Memcpy(内存拷贝函数) 1.1.1 特殊情况:当dest和sour出现重叠拷贝（访问同一块空间） 1.1.3 VS下解决了重叠拷贝的问题 1.2 Memmove(内存拷贝函数)1.3 Memset(初始化函数)1.4 Memcmp(内存对比函数) 二、模拟实现内存函数2.1 模拟实现Memcpy2.2 模拟实现Memmove 🔥引言
上篇文章介绍了字符串相关函数，但是缺点在于只针对于字符类型。
本篇文章涉及的函数不单单只能用于字符类型的数据，通过内存进行修改适用于任意类型数据，逐字节修改。
内存函数大部分在string.h头文件中进行声明。
🌈个人主页：是店小二呀
🌈C语言笔记专栏：C语言笔记
🌈C++笔记专栏： C++笔记
🌈喜欢的诗句:无人扶我青云志 我自踏雪至山巅
文章目录 一、内存函数的使用1.1 Memcpy(内存拷贝函数) 1.1.1 特殊情况:当dest和sour出现重叠拷贝（访问同一块空间） 1.1.3 VS下解决了重叠拷贝的问题 1.2 Memmove(内存拷贝函数)1.3 Memset(初始化函数)1.4 Memcmp(内存对比函数) 二、模拟实现内存函数2.1 模拟实现Memcpy2.2 模拟实现Memmove 一、内存函数的使用 1.1 Memcpy(内存拷贝函数) #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { //定义两个数组 int arr[] = { 1,2,3,4,5,6,7,8,9,10 }; int p[20] = { 0 }; memcpy(arr, p, 20); for (int i = 0; i &lt; 10; i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48562be234d07c1684aa487091962ea8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07a5c8a8b52b7ad8de4a4c674fdf6613/" rel="bookmark">
			Spring Boot集成Kafka：最佳实践与详细指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在构建分布式和微服务架构时，消息队列如Apache Kafka已成为实现高效通信和数据处理的关键组件。Spring Boot作为Java领域的流行框架，提供了与Kafka的无缝集成。本文将详细介绍如何在Spring Boot项目中优雅地集成Kafka，并通过最佳实践和代码示例来指导你。
一、前提条件 确保你已经安装了Kafka和ZooKeeper，并且它们正在正常运行。首先，你需要创建一个Spring Boot项目。你可以使用Spring Initializr（https://start.spring.io/）来快速生成一个包含所需依赖的初始项目。
二、添加依赖 在Spring Boot项目的pom.xml文件中，添加Kafka的Spring Boot Starter依赖：
&lt;dependencies&gt; &lt;!-- 其他依赖 --&gt; &lt;!-- Kafka Starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt; &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt; &lt;version&gt;你的Spring Kafka版本号&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 三、配置Kafka 在application.properties或application.yml文件中，配置Kafka的相关参数。以下是一个示例配置：
application.yml
spring: kafka: bootstrap-servers: localhost:9092 consumer: group-id: my-group auto-offset-reset: earliest key-deserializer: org.apache.kafka.common.serialization.StringDeserializer value-deserializer: org.apache.kafka.common.serialization.StringDeserializer producer: key-serializer: org.apache.kafka.common.serialization.StringSerializer value-serializer: org.apache.kafka.common.serialization.StringSerializer template: default-topic: my-topic 四、发送消息 创建一个KafkaProducerService类，用于发送消息到Kafka。首先，在需要的类中注入KafkaTemplate。
KafkaProducerService.java
@Service public class KafkaProducerService { @Autowired private KafkaTemplate&lt;String, String&gt; kafkaTemplate; public void sendMessage(String topic, String message) { // 异步发送消息 kafkaTemplate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07a5c8a8b52b7ad8de4a4c674fdf6613/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38658dd0fb86467a4daa9a7a5e7f7912/" rel="bookmark">
			Android 出现4G模块无法上网问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者简介： 一个平凡而乐于分享的小比特，中南民族大学通信工程专业研究生在读，研究方向无线联邦学习
擅长领域：驱动开发，嵌入式软件开发，BSP开发
作者主页：一个平凡而乐于分享的小比特的个人主页
文章收录专栏：RK3568_Android11_驱动开发，此专栏为RK3568开发板Android11系统开发，学习记录
欢迎大家点赞 👍 收藏 ⭐ 加关注哦！💖💖
背景： 出现这个问题之前，4G模块EM05在Linux系统可以通过ECM模式上网，但是到了Android系统发现usb0网络无法获取到IP地址，从而无法上网。在Windows和Linux系统下会有后台进程帮我们自动获取IP，只需要我们把模块设置成ECM模式就可以了，但是Android下没有这个服务。
RILD介绍 Android系统带的RIL机制，Android RIL提供了Android电话服务和无线电硬件之间的抽象层。Android RIL在HAL(Hardware Abstract Layer)层（C++层）由三个部分组成：
RILD是系统的守护进程，主要用于初始化LIBRIL以及启动厂商自定义的Vendor RIL；LIBRIL被RILD初始化完成后，用于与Vendor RIL之间进行交互，负责接收、发送指令；Vendor RIL是第三方厂商自定义的一个库，用于向Modem发送指令或者接收来自LIBRIL或者Modem的指令。 三者之间的关系图如下所示：
从这里可以看到，RILD在启动时，负责将LibRil以及Vendor RIL进行初始化，将相应的回调函数以及调用接口进行注册，LibRIL向vendor RIL提供了接口RIL_Env，当Vendor有消息时，利用该回调返回；而Vendor RIL 同样提供了接口RIL_RadioFunctions,给LibRIl调用。
在Android系统下存在一个rild_damon这个守护进程，RILD(RIL Daemon)是系统的守护进程，系统已启动，就会一直运行。手机开机时，kernel完成初始化后，Android启动一个初始化进程Init用于加载系统基础服务，如文件系统，zygote进程，服务管家ServiceManager,以及RILD
解决方法： 在/home/android/rk3568/android11/hardware/ril/rild下存在一个rild.rc文件，在这个文件中配置了rild_damon这个服务，也是解决这个问题的关键。
获取移远公司提供的libreference-ril.so , 在系统执行rild可执行文件的时候会链接到这个动态库
将libreference-ril.so添到/home/android/rk3568/android11/vendor/rockchip/common/phone/lib目录下，并重命名为libreference-ril-em05.so
修改/home/android/rk3568/android11/vendor/rockchip/common/phone/phone.mk
(这里添加这个动态库的目的是让最后生成的根文件系统里的/vendor/lib64/下存在libreference-ril-em05.so，如果不存在这个动态库，rild_daemon守护进程会一直打印退出重启信息，直到/vendor/lib64/下存在该动态库)
修改/home/android/rk3568/android11/hardware/ril/rild/rild.rc
​ (从第一行可以看到，在启动ril-daemon这个服务的时候，系统会调用/vendor/bin/hw/rild程序，该程序需要链接到动态库)
修改好上面内容后，重新编译，烧录新的镜像到开发板中
测试结果：
将EM05上电（上电流程参考RK3568—4G模块驱动实验）
上电后会出现如下信息
（中间的denied信息是由于SELinux下权限问题，暂时先不用管）
我们通过ifconfig usb0查看usb0的信息
通过ping www.baidu.com测试上网功能
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aae1d662f216c107adc723fdfb42421/" rel="bookmark">
			执行go install报错go.mod:5: unknown directive: toolchain
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
背景
解决
背景 在安装etcd benchmark工具时报etcd-main/go.mod:5: unknown directive: toolchain
当前go版本为1.20。
为什么提交到toolchain？看看etcd的mod文件：
module go.etcd.io/etcd/v3 go 1.22 toolchain go1.22.2 果然看到了toolchain指令。
解决 在Go 1.21版本之前，该文件中go指令用于声明建议的Go版本，但并不强制实施。
但在Go 1.21版本后，向前兼容性策略的调整就是参考了go module对依赖的管理方法：即将go版本和go toolchain 版本作为一个module的“依赖”来管理。
为解决向前兼容不确定性的问题，Go从1.21版本开始，改变了go.mod中go x.x.x的语义：它不再是建议，而是指定了module最小可用的Go版本。
也就是说，按上面etcd 的mod文件来看，我们需要使用1.22版本。
尝试升级go版本到go1.22.2，重试发现解决了。
关于toolchain
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36f1cb27954d89d062e357c60ea31eee/" rel="bookmark">
			springboot的kafka动态工具类（动态创建topic、监听和监听方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot的kafka动态工具类（动态创建topic、监听和监听方法） 一、使用场景 需要动态创建topic，然后动态创建该topic的监听容器，同时可以指定该监听容器的处理方法，避免增删监听topic时需要重启操作等情况。
很多情况下，使用kafka一般都会主动创建好队列（Topic）和消费者监听（@KafkaListener），特别是监听者，一般都是动态创建好后，然后使用@KafkaListener指定Topic后创建。
上述情况的优点在于：可以明确topic和消费者，启动时程序主动就创建好对应topic的消费容器和消费方法，直接消费即可。
缺点：如果需要监听新的topic，则需要添加@KafkaListener的配置并且重新启动项目，对于灵活性要求高或者线上的程序是比较麻烦的。
二、工具类概述 所以基于上述情况，为了更加灵活的创建和使用Kafka的topic和listener，专门写了一个kafka相关的工具类：
topic相关的包含了：topic创建、删除、列表、是否存在等方法。
Listener相关包含了：容器的创建、启动、停止、暂停、恢复等方法。
这里有个概念需要先了解下，监听容器里有两个状态，可以简单理解为：一个是容器的运行状态running，一个是容器的监听状态pauseRequest，再容器运行状态开启的基础上，监听状态开启，才能够正常消费消息。
三、代码展示 那么老规矩，万事先依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt; &lt;artifactId&gt;spring-kafka&lt;/artifactId &lt;/dependency&gt; 然后是配置文件类KafkaConfig，设置kafka相关配置 import org.apache.kafka.clients.admin.AdminClient; import org.apache.kafka.clients.consumer.ConsumerConfig; import org.apache.kafka.clients.producer.ProducerConfig; import org.apache.kafka.common.serialization.StringDeserializer; import org.apache.kafka.common.serialization.StringSerializer; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.kafka.annotation.EnableKafka; import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory; import org.springframework.kafka.core.*; import java.util.HashMap; import java.util.Map; import java.util.Properties; /** *@ClassName KafkaConfig *@Description: TODO kafka的配置类 **/ @Configuration @EnableKafka public class KafkaConfig { private static final String kafkaServer = "kafka-ip:9092";//kafka地址 /** * @Title producerFactory * @Description TODO 生产者工厂类，设置生产者相关配置 * @return org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36f1cb27954d89d062e357c60ea31eee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3be664b8afe037a082053d2966df97e5/" rel="bookmark">
			某发布会大模型出现time.sleep(6)后，我捋了一下数据库的sleep...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：IT邦德
中国DBA联盟(ACDU)成员，10余年DBA工作经验，
Oracle、PostgreSQL ACE
CSDN博客专家及B站知名UP主，全网粉丝10万+
擅长主流Oracle、MySQL、PG、高斯及Greenplum备份恢复，
安装迁移，性能优化、故障应急处理
微信:jem_db
QQ交流群:587159446
公众号：IT邦德
文章目录 前言📣 1.time.sleep(6)广泛讨论📣 2.Oracle中的sleep📣 2.1 使用场景📣 2.2 注意事项 📣 3.MySQL中的sleep📣 3.1 使用场景📣 3.2 注意事项 📣 4.PostgreSQL中的sleep📣 4.1 使用场景📣 4.2 注意事项 📣 5.数据库静默安装脚本📣 6.总结 前言 某发布会上展示的大模型能力引发了广泛讨论，尤其是展示过程中涉及的time.sleep(6)代码
📣 1.time.sleep(6)广泛讨论 近期，某发布会上展示的大模型能力引发了广泛讨论，尤其是展示过程中涉及的time.sleep(6)代码。有一些技术专家认为time.sleep（6）可能只是为了确保程序在演示过程中不会出现意外情况，而预设的一个缓冲步骤。这种做法在技术演示中并不鲜见，旨在使整个展示过程变得平稳和可控。
接下来我带大家来一起梳理一下数据库中用到sleep
📣 2.Oracle中的sleep 📣 2.1 使用场景 在Oracle数据库中，SLEEP用于暂停当前会话一定的时间。
这个函数在实际应用中有一定的作用，
比如调试代码时需要测试程序在不同时间间隔下的执行情况，
或者在某些特定场景下需要等待一段时间再执行后续操作
1.例如，要暂停查询10秒钟， 可以使用以下语句： BEGIN DBMS_LOCK.SLEEP(5); END; 2.操作之间暂停了2秒钟， 可以观察程序在不同时间点的执行情况， 以便进行调试 BEGIN -- 执行一些操作 DBMS_OUTPUT.PUT_LINE('开始执行操作'); -- 暂停2秒钟 DBMS_LOCK.SLEEP(2); -- 执行一些其他操作 DBMS_OUTPUT.PUT_LINE('继续执行其他操作'); END; / 有一次故障案例中就用到了，非常方便
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3be664b8afe037a082053d2966df97e5/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/357/">«</a>
	<span class="pagination__item pagination__item--current">358/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/359/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>