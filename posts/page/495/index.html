<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b89cc8fe24be7414adbe96691f5e6349/" rel="bookmark">
			鸿蒙HarmonyOS项目实战开发：分布式购物车
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 分布式购物车demo 模拟的是我们购物时参加满减活动，进行拼单的场景；实现两人拼单时，其他一人添加商品到购物车，另外一人购物车列表能同步更新，且在购物车列表页面结算时，某一人结算对方也能实时知道结算金额和优惠金额。整个操作效果分为3个小动画，
拉起对方用户 添加商品到购物车列表 购物车列表勾选 demo效果（HH-SCDAYU200） 工程目录 完整的项目结构目录如下
├─entry\src\main │ │ config.json 应用配置文件 │ │ │ ├─ets │ │ └─MainAbility │ │ │ app.ets ets应用程序主入口 │ │ │ │ │ ├─model │ │ │ ArsData.ets // 初始化我的页面数据 │ │ │ CommonLog.ets // 日志类 │ │ │ GoodsData.ets // 初始化商品信息数据类 │ │ │ MenuData.ets // 初始化我的页面数据类 │ │ │ RemoteDeviceManager.ets // 分布式拉起设备管理类 │ │ │ ShoppingCartDistributedData.ets // 加入购物车分布式数据库 │ │ │ TotalSelectedDistributedData.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b89cc8fe24be7414adbe96691f5e6349/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb93dc403f8f3aa7481292a57690ba11/" rel="bookmark">
			【Unity】使用ADB连接真机、模拟器测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.打一个Development包 2.打开cmd，CD到sdk的Platform-tools下 3.连接安卓设备 ①连接安卓手机，需要开启开发者模式，
不同的手机开启方式有所不同，比如华为的手机需要在：设置-关于手机-版本号，连续点击7次版本号
②打开USB调试
③同意调试，出现如下界面，点击同意即可链接成功
4.连接模拟器 cmd框输入：adb connect 127.0.0.1:5555
不同模拟器的端口不一样
夜神模拟器 62001逍遥模拟器 21503雷电模拟器 5555BlueStacks（蓝叠） 5555网易MuMu 7555天天模拟器 5037安卓模拟器大师 54001
5.查看设备设备连接情况 cmd框输入：adb devices
6.连接unity游戏 cmd框输入： adb forward tcp:34999 localabstract:Unity-com.xx.yy
其中com.xx.yy为游戏包名，不清楚的小伙伴可以到如图位置查看
7.ADB常用命令汇总 adb kill-server：杀掉ADB服务adb start-server：启动adb服务adb logcat：查看手机上的运行日志adb logcat -s Unity ：只查看unity相关日志adb help：帮助adb connect 127.0.0.1:5555：连接设备adb devices ：查看设备adb forward tcp:34999 localabstract:Unity-com.xx.yy：连接Unity游戏adb version：查看版本adb disconnect xxx ：端口设备adb shell ps：查看进程adb shell ：进入手机系统（进入shell模式）adb install [apk文件路径] ：apk指的是安卓应用程序的安装包adb install -r [apk文件路径] ： 参数 -r 表示覆盖安装，保留缓存和数据处理adb uninstall [文件名，即包名] ：卸载软件adb uninstall -k [文件名，即包名] ： 参数 -k 表示卸载软件，保存配置和缓存文件netstat -aon：查看端口占用netstat -aon|findstr “端口号” ：查看被占用端口对应的PID 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5415d3a950669332ccbede8d75163b1c/" rel="bookmark">
			Kafka安全模式之身份认证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 Kafka作为一个分布式的发布-订阅消息系统，在日常项目中被频繁使用，通常情况下无论是生产者还是消费者只要订阅Topic后，即可进行消息的发送和接收。而kafka在0.9.0.0版本后添加了身份认证和权限控制两种安全服务，本文主要介绍在实际项目使用过程中遇到第三方kafka需身份认证时如何解决，以及对可能会碰到的问题进行总结。
二、原理介绍 Kafka身份认证主要分为以下几种：
（1）客户端与broker之间的连接认证
（2）broker与broker之间的连接认证
（3）broker与zookeeper之间的连接认证
日常项目中，无论是生产者还是消费者，我们都是作为客户端与kafka进行交互，因此使用的最多的是客户端与broker之间的连接认证。图1是客户端与服务端broker之间的认证过程图，客户端提交认证数据，服务端会根据认证数据对当前客户端进行身份校验，校验成功后的客户端即可成功登录kafka，进行后续操作。
图1 客户端与broker之间认证过程图
目前Kafka提供了SASL、SSL、Delegation Tokem三种安全认证机制，而SASL认证又分为了以下几种方式：
（1）基于Kerberos的GSSAPI
SASL-GSSAPI提供了一种非常安全的身份验证方法，但使用前提是企业中有Kerberos基础，一般使用随机密码的keytab认证方式，密码是加密的，在0.9版本中引入，目前是企业中使用最多的认证方式。
（2）SASL-PLAIN
SASL-PLAIN方式是一个经典的用户名/密码的认证方式，其中用户名和密码是以明文形式保存在服务端的JAAS配置文件中的，当客户端使用PLAIN模式进行认证时，密码是明文传输的，因此安全性较低，但好处是足够简单，方便我们对其进行二次开发，在0.10版本引入。
（3）SASL-SCRAM
SASL-SCRAM是针对SASL-PLAIN方式的不足而提供的另一种认证方式，它将用户名/密码存储在zookeeper中，并且可以通过脚本动态增减用户，当客户端使用SCRAM模式进行认证时，密码会经过SHA-256或SHA-512哈希加密后传输到服务器，因此安全性较高，在0.10.2版本中引入。
对Kafka集群来说，要想实现完整的安全模式，首先为集群中的每台机器生成密钥和证书是第一步，其次利用SASL对客户端进行身份验证是第二步，最后对不同客户端进行读写操作的授权是第三步，这些步骤即可以单独运作也可以同时运作，从而提高kafka集群的安全性。
三、具体实现 本文主要介绍作为kafka生产者，如何基于Kerberos进行身份认证给第三方kafka发送数据。
Kerberos主要由三个部分组成：密钥分发中心Key Distribution Center（即KDC）、客户端Client、服务端Service，大致关系图如下图2所示，其中KDC是实现身份认证的核心组件，其包含三个部分：
Kerberos Database：储存用户密码以及其他信息Authentication Service(AS)：进行用户身份信息验证，为客户端提供Ticket Granting Tickets(TGT)Ticket Granting Service(TGS)：验证TGT，为客户端提供Service Tickets 我们作为生产者向第三方kafka发送数据，因此需要第三方提供以下安全认证文件：
用户名principle：标识客户端的用户身份，也即用于登录的用户名指定用户名对应的秘钥文件xx.keytab：存储了用户的加密密码指定安全认证的服务配置文件krb5.conf：客户端根据该文件中的信息去访问KDC 获取以上安全认证文件后，即可编写java代码连接第三方kafka，步骤如下：
1、将安全认证文件xx.keytab和krb5.conf放置于某一路径下，确保后续java代码可进行读取
2、添加kafka配置文件，开启安全模式认证，其中kerberos.path是第一步中认证文件所在的目录
3、修改Kafka生产者配置，开启安全连接
4、调用认证工具类进行登录认证
LoginUtil认证工具类的核心是根据第一步中提供的安全认证文件自动生成jaas配置文件，该文件是kafka安全模式下认证的核心。代码如下：
import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.io.File; import java.io.FileWriter; import java.io.IOException; /** * @ProjectName: stdp-security-demo * @Package: * @ClassName: LoginUtil * @Author: stdp * @Description: ${description} */ public class LoginUtil { public enum Module { KAFKA("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5415d3a950669332ccbede8d75163b1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/089d2bfdc152f4188e43ddbacd454eb8/" rel="bookmark">
			LLaMA-Factory 8卡4090 deepspeed zero3 微调Qwen14B-chat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境安装 推荐使用docker，Ubuntu20.04
https://www.modelscope.cn/docs/%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85
docker pull registry.cn-beijing.aliyuncs.com/modelscope-repo/modelscope:ubuntu22.04-cuda12.1.0-py310-torch2.1.2-tf2.14.0-1.12.0 下载模型 在modelscope主页，找到模型
https://modelscope.cn/models/qwen/Qwen-14B-Chat/summary
可以使用如下脚本
import os from modelscope import snapshot_download # cache_dir 指定你的保存模型的路径 model_dir = snapshot_download('qwen/Qwen-14B-Chat',cache_dir="/workspace/models/AI-ModelScope") 微调 使用LLaMA-Factory，
下载下面仓库的代码，
https://github.com/hiyouga/LLaMA-Factory
在代码目录，新建一个脚本 run_train_bash.sh
CUDA_VISIBLE_DEVICES=0,1,2,3,4,5,6,7 accelerate launch src/train_bash.py \ --deepspeed ds_config_zero3.json \ --stage sft \ --do_train True \ --model_name_or_path /workspace/models/AI-ModelScope/qwen/Qwen-14B-Chat/ \ --finetuning_type lora \ --template qwen \ --dataset_dir data \ --dataset lhs_merged_data \ --cutoff_len 1024 \ --learning_rate 5e-04 \ --num_train_epochs 3 \ --max_samples 100000 \ --per_device_train_batch_size 4 \ --gradient_accumulation_steps 4 \ --lr_scheduler_type cosine \ --max_grad_norm 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/089d2bfdc152f4188e43ddbacd454eb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a33dfb9f13e19be52004ca1e8ce70e09/" rel="bookmark">
			JAVA PDF 给PDF添加文字/图片水印（指定内容），并且设置位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：看完这个简单的demo 后就知道怎样去操作一个PDF了
文章目录 前言一、前提准备二、使用步骤 1.引入库2.以下是部分代码的作用总结 前言 提示：操作PDF其实是一件很简单的事情，比一般的CRUD都简单
例如：我们拿到了一个需求，我需要给这个PDF设置一个电子签名(就是一张图片盖在这个PDF上，然后输出到服务器的某个指定文件夹中)和年月日(自定义的文字)
提示：以下是本篇文章正文内容，下面案例可供参考
一、前提准备 示例：因为我这个是demo 所以我们准备两个文件
1.原始PDF（模板PDF，需要操作的文件） J:/test.pdf
2.需要放到PDF种的签名（就是一张图片嘛）J:/666.png
二、使用步骤 1.引入库 代码如下（示例）：
其实我们只需要用到两个包，maven引入即可（复制过去） &lt;!-- pdfbox --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.pdfbox&lt;/groupId&gt; &lt;artifactId&gt;pdfbox&lt;/artifactId&gt; &lt;version&gt;2.0.28&lt;/version&gt; &lt;/dependency&gt; &lt;!-- itextpdf --&gt; &lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itextpdf&lt;/artifactId&gt; &lt;version&gt;5.5.13.3&lt;/version&gt; &lt;/dependency&gt; 2.以下是部分代码的作用 代码如下（示例）：
首先我们需要读取这两个文件（路径换成你自己的服务器路径就好）File file = ResourceUtils.getFile("J:/test.pdf"); Image img = Image.getInstance("J:/ikun.jpg"); 然后我们需要提前设置需要输出的路径（就是你生成后文件放到哪儿） PdfStamper stamper = new PdfStamper(reader, Files.newOutputStream(Paths.get("J:/abc.pdf"))); 图片操作的代码块
PdfGState pdfGState = new PdfGState(); pdfGState.setFillOpacity(0.7F); contentByte.setGState(pdfGState); //图片的位置 img.setAbsolutePosition(430, 220); //这是图片的尺寸 img.scaleAbsolute(100, 100); img.setCompressionLevel(100); 文字的代码块
//设置字体大小contentByte.setFontAndSize(BaseFont.createFont(fontFile.getAbsolutePath(),BaseFont .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a33dfb9f13e19be52004ca1e8ce70e09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f067bb501121a7f74b3bccb53384035d/" rel="bookmark">
			使用Docker部署DataX3.0&#43;DataX-Web
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、准备基础镜像，开通所需端口 先查看3306和9527端口是否开放，如果未开放先在防火墙添加
firewall-cmd --zone=public --add-port=3306/tcp --permanent firewall-cmd --zone=public --add-port=9527/tcp --permanent firewall-cmd --reload systemctl stop docker systemctl restart docker 拉取镜像
docker pull linshellfeng/datax_web:3.0.1 或者
docker pull swr.cn-north-1.myhuaweicloud.com/softwares/datax-web:2.1.2 注意：datax_web:3.0.1镜像已经整合了datax3.0和datax-web，整合后的镜像大小约990M
2、初始化数据库 下载DataX-Web源码
https://github.com/WeiYe-Jing/datax-web 1.IDEA编译打包 下载链接：https://pan.baidu.com/s/13a8nIpz6FL8y4fdE94trjQ 提取码：data 2.官方提供的版本tar版本包 https://pan.baidu.com/s/13yoqhGpD00I82K4lOYtQhg 提取码：cpsk 创建数据库
mysql&gt; create database datax_web; 解压DataX-Web压缩包
# 找到 bin/db/datax_web.sql 文件，进行初始化 3、在宿主机创建挂载文件 在宿主机创建/usr/datax/datax-web/datax-admin/conf目录，并将bootstrap.properties拷贝到/usr/datax/datax-web/datax-admin/conf目录下，该文件用来配置datax-web连接数据库的信息，ip地址和xxxxxx需要按实际情况填写。
bootstrap.properties内容参考如下：
#Database DB_HOST=192.168.1.xx DB_PORT=3306 DB_USERNAME=datax_web DB_PASSWORD=xxxxxx DB_DATABASE=datax_web_db 4、启动容器 docker run -d --name datax_web -p 9527:9527 -v /usr/datax/datax-web/datax-admin/conf/bootstrap.properties:/home/datax/datax-web-2.1.2/modules/datax-admin/conf/bootstrap.properties linshellfeng/datax_web:3.0.1 或者
docker run -d --name datax_web -p 9527:9527 -v /usr/datax/datax-web/datax-admin/conf/bootstrap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f067bb501121a7f74b3bccb53384035d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb26371cfd5cde58f2a85c2c1c69c835/" rel="bookmark">
			【DFS简单题汇总】递归与递推
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀个人主页：为梦而生~ 关注我一起学习吧！
💡专栏：算法题、 基础算法~赶紧来学算法吧
💡往期推荐：
【算法基础 &amp; 数学】快速幂求逆元（逆元、扩展欧几里得定理、小费马定理）
【算法基础】深搜
文章目录 递归实现指数型枚举递归实现排列型枚举简单斐波那契递归实现组合型枚举费解的开关 递归实现指数型枚举 从 1∼n 这 n 个整数中随机选取任意多个，输出所有可能的选择方案。
输入格式
输入一个整数 n。
输出格式
每行输出一种方案。
同一行内的数必须升序排列，相邻两个数用恰好 1
个空格隔开。
对于没有选任何数的方案，输出空行。
数据范围
1 ≤ n ≤ 15 1≤n≤15 1≤n≤15
输入样例：
3 输出样例：
3 2 2 3 1 1 3 1 2 1 2 3 代码：
这里从1~n，依次考虑每个数选或不选
#include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; int n; void dfs(int cur, int state){ if(cur &gt; n){ for(int i = 0; i &lt; n; i++) if(state &gt;&gt; 1 &amp; 1) } } int main(){ cin &gt;&gt; n; dfs(1); return 0; } 数量级小技巧：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb26371cfd5cde58f2a85c2c1c69c835/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/994f0b8ae826bf85af8d717a2b76584c/" rel="bookmark">
			【算法分析与设计】岛的数量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📝个人主页：五敷有你 🔥系列专栏：算法分析与设计
⛺️稳中求进，晒太阳
题目 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。
示例 示例 1：
输入：grid = [ ["1","1","1","1","0"], ["1","1","0","1","0"], ["1","1","0","0","0"], ["0","0","0","0","0"] ] 输出：1 示例 2：
输入：grid = [ ["1","1","0","0","0"], ["1","1","0","0","0"], ["0","0","1","0","0"], ["0","0","0","1","1"] ] 输出：3s 思路 深度优先遍历 DFS 的基本结构 首先，网格结构中的格子有多少相邻结点？答案是上下左右四个。对于格子 (r, c) 来说（r 和 c 分别代表行坐标和列坐标），四个相邻的格子分别是 (r-1, c)、(r+1, c)、(r, c-1)、(r, c+1)。换句话说，网格结构是「四叉」的。
其次，网格 DFS 中的 base case 是什么？应该是网格中不需要继续遍历、grid[r][c] 会出现数组下标越界异常的格子，也就是那些超出网格范围的格子。
这一点稍微有些反直觉，坐标竟然可以临时超出网格的范围？这种方法我称为「先污染后治理」—— 甭管当前是在哪个格子，先往四个方向走一步再说，如果发现走出了网格范围再赶紧返回。这跟二叉树的遍历方法是一样的，先递归调用，发现 root == null 再返回。
如何避免重复遍历 网格结构的 DFS 与二叉树的 DFS 最大的不同之处在于，遍历中可能遇到遍历过的结点。这是因为，网格结构本质上是一个「图」，我们可以把每个格子看成图中的结点，每个结点有向上下左右的四条边。在图中遍历时，自然可能遇到重复遍历结点。
这时候，DFS 可能会不停地「兜圈子」，永远停不下来。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/994f0b8ae826bf85af8d717a2b76584c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b59417e93a7ee5a28d891503d046e724/" rel="bookmark">
			前端vuex中dispatch的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、vuex和this.$store.dispatch是什么？二、使用方法总结 前言 Vuex中dispatch的用法！
一、vuex和this.$store.dispatch是什么？ Vuex: Vuex是专为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。
this.$store.dispatch: this.$store.dispatch是用于触发vuex中action的方法。
二、使用方法 #基础用法
this.$store.dispatch('actionName');
#实际案例(登录)
this.$store.dispatch('LoginByUsername', this.loginForm).then(() =&gt; { this.$router.push({ path: '/' }); //登录成功之后重定向到首页 }).catch(err =&gt; { this.$message.error(err); //登录失败提示错误 }); action:
LoginByUsername({ commit }, userInfo) { const username = userInfo.username.trim() return new Promise((resolve, reject) =&gt; { loginByUsername(username, userInfo.password).then(response =&gt; { const data = response.data Cookies.set('Token', response.data.token) //登录成功后将token存储在cookie之中 commit('SET_TOKEN', data.token) resolve() }).catch(error =&gt; { reject(error) }); }); } 总结 Vuex是专为Vue.js应用程序开发的状态管理模式。
this.$store.dispatch是用于触发vuex中action的方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bb772227f668c9ef7064c9666c2385d/" rel="bookmark">
			轻松掌握数据库中JSON数据提取：json_extract函数用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 json_extract。这个函数在处理JSON数据时非常有用，它能帮助我们轻松地从JSON字符串中提取需要的信息。
json_extract函数是MySQL数据库中的一个内置函数，用于从JSON字符串中提取数据。它的语法相对简单，功能却非常强大。
json_extract函数的语法 select json_extract(json_doc, path[, path] ...) json_doc：这是你要提取数据的JSON字符串。 path：这是你要提取的数据的路径，可以是一个或多个。 假设我们有一个名为users的表，其中有一个名为data的列，存储着JSON格式的数据，如下所示：
{ "name": "张三", "age": 30, "address": { "city": "北京", "street": "长安街" } } 如果我们想要提取name字段的值，可以这样写：
SELECT json_extract(data, '$.name')； 这样相应的就可以获取到 。张三。
如果我们想要获取到city字段的值，涉及到了嵌套。那么可以这么处理。
SELECT json_extract(data, '$.address.city') ； #使用.来拼接，获取内部字段内容 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dca8ceca7a0078ccaf0bf1d614cd9d3f/" rel="bookmark">
			DB-GPT：大模型 &#43; 数据库，全流程自动化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DB-GPT：大模型 + 数据库，全流程自动化 提出背景DB-GPT 结构具体问题与解法背景分析对比其他工具DB-GPT系统设计 提出背景 论文：https://arxiv.org/pdf/2312.17449.pdf
代码：https://github.com/eosphoros-ai/DB-GPT
本文介绍了DB-GPT，一个智能且生产就绪的项目，旨在通过增强型大型语言模型（LLMs）来改善数据摄取、结构化和访问，同时采用隐私化技术。
DB-GPT不仅利用了LLMs固有的自然语言理解和生成能力，还通过代理和插件机制不断优化数据驱动引擎。
DB-GPT 结构 DB-GPT系统处理查询的架构，展示了以下组件和流程：
提交一个查询。检索器组件选择相关信息。重排器细化选择以确保最佳匹配。为文本转SQL任务细化调整的**语言模型（LLM）**处理精炼信息。系统确保身份安全。生成并返回一个响应。 架构下方还展示了一个多源知识库，表明系统使用多个来源，如数据库、网页和PDF文件。
还有如AIOps代理、SQL代理和商业分析代理，可以与不同类型的数据和服务接口。
具体问题与解法 隐私和安全保护
子问题：如何在不牺牲用户隐私和数据安全的前提下，允许用户与数据库进行自然语言交互？子解法：DB-GPT允许用户在个人设备或本地服务器上部署，并且可以在没有互联网连接的情况下运行，确保数据不会离开执行环境，通过代理去标识化技术中介隐藏个人标识符，从而降低未授权访问和私人信息利用的风险。 多源知识库问答优化
子问题：如何处理和回答基于多源非结构化数据（如PDF、网页、图像等）的查询？子解法：DB-GPT构建了一个管道，将多源非结构化数据转换为中间表示，存储在结构化知识库中，检索最相关的信息，并针对给定查询生成全面的自然语言响应。该管道针对效率进行了优化，并且支持双语查询。 文本转SQL细化调整
子问题：如何降低没有SQL专业知识的用户与数据交互的障碍？子解法：DB-GPT对几种常用的LLMs（如Llama-2、GLM）进行了细化调整，专门针对文本转SQL任务。这显著降低了用户的门槛，并且针对双语查询进行了优化。 知识代理和插件集成
子问题：如何通过自动化决策和数据分析增强与数据的交互？子解法：DB-GPT使得开发和应用具有高级数据分析能力的对话代理成为可能，这些自动化决策支持数据上的交互式用例。它还提供了多种查询和检索服务的插件作为与数据交互的工具。 背景分析 隐私和安全保护：之所以采用隐私和安全保护，是因为在处理敏感数据时用户隐私和数据安全是首要考虑的。
在这个场景中，医疗工作者可能需要查询包含患者敏感信息的数据库来辅助治疗决策。
采用隐私和安全保护措施，比如代理去标识化技术，可以确保在执行此类查询时，患者的个人信息不会被泄露。
系统可以设计成在处理查询结果之前自动去除或替换掉敏感数据，如姓名、社会保障号码或地址，以保护个人隐私。
文本转SQL细化调整：采用这个解决方案是因为非技术用户通常不熟悉SQL查询语言，这一特征要求系统能够理解自然语言查询并转换为SQL命令，从而简化用户与数据库的交互。
当医疗工作者使用自然语言提出查询，如“显示所有糖尿病患者的最新血糖记录”，系统需要将这个自然语言查询转换成SQL语句，以便从数据库中检索信息。
文本转SQL细化调整功能可以帮助实现这一点，让非技术背景的用户也能轻松地与数据库进行交互。
多源知识库问答优化：之所以优化基于多源知识库的问答系统，是因为现代数据通常分布在多种格式和源中。
这要求系统能够处理和理解来自不同来源的非结构化数据，从而提供准确且全面的回答。
同时，由于相关数据可能散布在电子健康记录、实验室结果和第三方健康应用程序中，多源知识库问答优化可以确保从所有相关来源中提取和综合信息，从而为医疗工作者提供一个全面的患者健康概况。
知识代理和插件集成：之所以集成知识代理和插件，是因为自动化决策和高效的数据分析能力可以显著提高用户与数据交互的效率和质量。
最后，集成的知识代理和插件，比如一个药物相互作用检查器，可以自动提醒医生关于患者当前用药可能存在的风险。
这样的工具通过整合多种数据源和应用专业知识，增加了从大量数据中提取有价值信息的效率。
DB-GPT通过这些创新解决方案，不仅提高了用户与数据库交互的自然性和直观性，而且在保护用户隐私和数据安全的同时，还优化了数据处理和查询的效率。
对比其他工具 比较了五种不同的方法或系统：LangChain、LlmalIndex、PrivateGPT 、ChatDB和 DB-GPT。
比较了这些模型的七个特性：
多LLM整合文本转SQL细化调整多代理策略数据隐私和安全多源知识双语查询生成数据分析 每个系统都用对号（✓）或叉号（✗）标记，表示它是否具有所讨论的特性。
例如，LangChain 具有多LLM整合、多代理策略、数据隐私和安全、多源知识，但它不支持文本转SQL细化调整、双语查询或生成数据分析。
DB-GPT系统设计 是一个基于检索增强生成(RAG)框架的系统，用于提升语言模型(LLMs)的性能和效率。
系统设计概述：DB-GPT是在RAG框架的基础上建立的，通过结合新的训练和推理技术来提高性能和效率。
多源RAG用于问答(QA)：
知识构建：构建一个包含大量文档的知识库，并将文档分段并嵌入到多维空间中。知识检索：当有查询时，系统将查询转换为向量，并从知识库中检索相关段落。学习嵌入和搜索：训练编码器以提高检索的相关性。自适应上下文学习(ICL)和LLM生成：根据相关性对检索结果进行排名，并结合模板生成响应。 部署和推理：面向服务的多模型框架(SMMF)：
设计了一个用于部署和推理多LLMs的平台，包含模型推理层和模型部署层。 多智能体策略：DB-GPT支持不同角色的互动，并且提供了协调机制以促进多个LLM智能体之间的合作。
DB插件：LLMs通过集成插件来提升数据库交互能力，包括结构分析器和查询执行器。
解法拆解：
子解法1：知识构建使用多维嵌入表示文档。子解法2：知识检索通过将查询转换为向量来检索相关段落。子解法3：自适应ICL结合模板和LLM生成响应来提高上下文理解。子解法4：SMMF提供了一个快速且易于使用的部署和推理平台。子解法5：多智能体策略使不同角色的LLM智能体能够协同工作。子解法6：DB插件提高了LLMs的数据库交互能力。 历史问题及其背景：
之所以使用知识构建，是因为需要处理的文档数量庞大，需要将其有效地嵌入到模型中以增强检索能力。之所以使用知识检索，是因为模型需要能够理解并找到与用户查询最相关的信息。之所以使用自适应ICL，是因为LLMs需要更好地理解上下文信息，提供准确的响应。之所以使用SMMF，是因为需要一个能够快速部署和推理多种LLMs的可扩展平台。之所以使用多智能体策略，是因为不同的任务需要不同角色的专业知识和技能。之所以使用DB插件，是因为LLMs自身不擅长数据库查询，需要特定的工具来增强这一能力。 DB-GPT 三步：
知识构建（Knowledge Construction）
知识检索（Knowledge Retrieval），进一步分为：
查询理解（Query Understanding）检索路由（Retrieval Router）文档重新排名（Document Rerank）相关块（Relevant Chunks） 自适应交互式编程（Adaptive ICL），包括：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dca8ceca7a0078ccaf0bf1d614cd9d3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06b9a185a0a696dfd4a2d0de55c1c739/" rel="bookmark">
			pycharm安装Amazon CodeWhisperer 免费AI辅助编程插件教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、github copilot 和 Amazon CodeWhisperer区别 Copilot非常易于使用，并与所有主要的代码编辑器进行了简化集成。GitHub Copilot针对七种主要的编程语言进行了优化（详见下表），但也可以生成其他语言和各种框架的建议。
Copilot在预览阶段是免费的，但GitHub在2022年宣布转向订阅模式。开发者仍然可以获得为期60天的免费试用，而且对于经过验证的学生和热门开源项目的维护者，它将保持免费。
Amazon CodeWhisperer：个人开发者可以免费使用CodeWhisperer。
二、在pycharm使用中如果想使用 Amazon CodeWhisperer首先点击File选择setting 如果是初次使用默认选择“Use a personal email to sign up and sign in with AWS Builder ID”，接着点击“Connect”
点击后接着会弹出下图所示的界面，我们点击图示标注所示的“Open and Copy Code”；
接着会跳转到网页浏览器中打开登录界面，我们在图中所示的code一栏中粘贴上验证码，点击"next"按钮
接着会跳转到网页浏览器中打开登录界面，我们在图中所示的code一栏中粘贴上验证码，点击"next"按钮
填写的邮箱会收到相应的验证码，将验证码进行复制, 将验证码填入图中点击"next"按钮，就会出现下图的设置密码，按照要求设置好密码后，点击“Create AWS Builder ID”按钮
登录成功后如下图所示，我们点击图示标注所示的“Allow”按钮完成授权即可。
授权成功会弹出绿色的小框
返回pycharm会进行提示，点击“yes”即可
图中表示以安装成功，这样我们就可以开始使用 CodeWhisperer 了。
在我们编写代码时，CodeWhisperer 会给出与当前光标位置相关的代码建议。如上图所示，我们在代码编辑窗口写上一个注释，例如快速排序”，然后回车，我们就可以看到该插件为我们给出了相关代码建议，&lt;–或者–&gt;来切换查看生成的AI代码，选中后直接按TAB键选中生成代码插入即可，注释描述信息写的越精准，⽣成的代码质量越好。
参考文章：
AI编程，详细比较GitHub Copilot对比Amazon CodeWhisperer
https://blog.csdn.net/weixin_39915649/article/details/135213694
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/542e14132899f2dc84610df0bbb32d25/" rel="bookmark">
			AI漫画小说推广操作全攻略，在家轻松日入200&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天跟大家分享一个宝藏副业项目，操作非常简单，变现也非常可观，那就是AI漫画小说推广项目。在AI技术的推动下，小说推文正迎来革命性的变革，不再局限于传统的视频形式，而是以生动的漫画画面赢得观众的喜爱。
一个在互联网网赚圈摸索了5年的学者，从开始的处处踩坑，到现在的得心应手，我用了整整5年的时间，我励志要用我摸爬滚打积累的经验，帮助每个新入圈的小白，让他们少走弯路。
这是我最近收的学员和学员近期出的成绩，数据不会骗人，可自行看看：
由于网络上各种割韭菜的层出不穷，导致现在副业行业鱼龙混杂，但是有一点非常重要，那就是项目不会割韭菜，割韭菜的是人，真正落地的好项目很快就会饱和，重点是要抓住时机，不然就只能吃别人剩的残羹剩饭了，遇到自己觉得可行的项目马上动手操作才是真理，把机会掌握在自己手上。
言归正传，我们来详细说说这个AI漫画小说推广副业项目的具体操作流程:
第一步：申请小说授权
获取合法的小说授权是项目的第一步，确保您的创作在法律范围内。以下是获取授权的具体步骤：
寻找来源**：在担心版权问题时，选择正规渠道获取授权是关键。许多小说平台如7猫、起点等都提供免费授权后台。**
申请授权**：登录授权平台，填写必要信息并提交申请。一般情况下，您可以在几小时内获得授权。**
选择关键词**：为了便于用户搜索，建议选择简洁的关键词，通常4到5个字为宜。**
第二步，视频文案改写
做AI漫画小说项目，不能直接用小说原文作为文案，那样不能适配视频制作，为了适配视频制作，就需要对小说文本的进行修改，具体修改方向可以自行搜索同行的做法，这里提供一些常用的方法：
使用官方文案**：参考小说平台提供的转化高的书单文案作为改写的基础。**
借助ChatGPT**：使用ChatGPT调整小说简介，使其在视频开头部分更吸引人。**
AI示例：“请帮我改写以下文案，在开头用三句话吸引观众，保持原意不变。”
第三步：生成画面
这个副业项目基本都可以靠AI来实现，对自身的技术操作难度完全没有，AI工具的使用简化了漫画制作的过程。我这里将介绍几种常用的工具：
comicai：此工具可以根据脚本内容自动生成主角形象和分镜画面，是一种成本低、操作简便的方式。
动态视频工具：如runway或pika，可以制作动态视频，但请注意，这可能会增加制作时间。
chatGPT：由AI来根据文章生成画面，这是最简单的一种。
Stable Diffusion：全能型的AI绘画平台，本地部署，不管是真实人物风，还是二次元动漫风，借助AI漫画助手插件，一键生成你需要的角色人物。
如果找不到工具或者找的是盗版的可以私信我，我把我用的发你。
第四步：合成视频
使用剪映等视频编辑工具将所有素材合并为一个完整的视频。这一步骤包括：
添加配音和字幕：选择字幕框，复制文案，并生成配音。为适应快节奏，可以加速播放声音。
添加特效：为画面添加特效，如发光或关键帧的移动效果。
选择背景音乐：可以从剪映内部选择，也可以用免版权音乐。
添加标识：在视频中标明AI生成的声明，以避免限流。
大致成品就像这样，可以自行搜索看看：
第五步：变现方法
做副业兼职项目当然变现才是主要目的，为了实现变现，我们采用多渠道引流与会员分佣相结合的策略：
多平台发布 ：在抖音、西瓜视频、YouTube等平台发布视频，以增加曝光度。
会员分佣 ：引导观众点击链接成为小说平台会员，从而获得分佣。
以上就是AI漫画小说推广项目的全部步骤了，如果文字表达难以理解，我还制作了一份视频教学，里面包含了各种工具软件，需要的可以私信我免费领取；
结语：
AI不仅改变了我们的创作方式，也为我们提供了赚取被动收入的新途径。无论你是做什么工作的，都可以尝试着做一下这个副业兼职项目，每天就一两个小时，平均一天能拿到200左右的收益，何乐而不为，如果看懂了操作步骤的就赶快行动起来吧！
写在最后 感兴趣的小伙伴，赠送全套AIGC学习资料，包含AI绘画、AI人工智能等前沿科技教程和软件工具，具体看这里。
AIGC技术的未来发展前景广阔，随着人工智能技术的不断发展，AIGC技术也将不断提高。未来，AIGC技术将在游戏和计算领域得到更广泛的应用，使游戏和计算系统具有更高效、更智能、更灵活的特性。同时，AIGC技术也将与人工智能技术紧密结合，在更多的领域得到广泛应用，对程序员来说影响至关重要。未来，AIGC技术将继续得到提高，同时也将与人工智能技术紧密结合，在更多的领域得到广泛应用。
一、AIGC所有方向的学习路线
AIGC所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照下面的知识点去找对应的学习资源，保证自己学得较为全面。
二、AIGC必备工具
工具都帮大家整理好了，安装就可直接上手！
三、最新AIGC学习笔记
当我学到一定基础，有自己的理解能力的时候，会去阅读一些前辈整理的书籍或者手写的笔记资料，这些笔记详细记载了他们对一些技术点的理解，这些理解是比较独到，可以学到不一样的思路。
四、AIGC视频教程合集
观看全面零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
五、实战案例
纸上得来终觉浅，要学会跟着视频一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
若有侵权，请联系删除 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a857c3fceb2d9e5f5895edf00303f44/" rel="bookmark">
			Python 中的 hash() 函数：哈希值的奥秘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更多Python学习内容：ipengtao.com
在 Python 中，hash() 函数是用于获取对象的哈希值的方法。本文将深入探讨 hash() 函数的用法、工作原理以及常见应用场景，方便大家能够更好地理解和应用这个函数。
什么是 hash() 函数？ hash() 函数是 Python 中的一个内置函数，用于获取对象的哈希值。哈希值是一个固定长度的整数，用于唯一标识对象。具有相同内容的对象将具有相同的哈希值，不同内容的对象将具有不同的哈希值。
hash() 函数的基本语法如下：
hash(object) 其中，object 是要获取哈希值的对象，可以是数字、字符串、元组等不可变类型的对象。
hash() 函数的基本用法 先来看一些 hash() 函数的基本用法。
1. 获取数字的哈希值 print(hash(42)) # 42 print(hash(3.14)) # 3430007490030933 在这个示例中，使用 hash() 函数获取了整数和浮点数的哈希值。
2. 获取字符串的哈希值 print(hash("hello")) # -1556557540336409064 print(hash("world")) # 7705868722141818761 在这个示例中，使用 hash() 函数获取了两个字符串的哈希值。
3. 获取元组的哈希值 print(hash((1, 2, 3))) # 2528502973977326415 print(hash((4, 5, 6))) # 3550055125485641917 在这个示例中，使用 hash() 函数获取了两个元组的哈希值。
hash() 函数的常见应用场景 hash() 函数在 Python 编程中有许多应用场景，以下是一些常见的用法：
1. 字典的键 hash() 函数常用于字典的键，通过对象的哈希值来快速定位键值对。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a857c3fceb2d9e5f5895edf00303f44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79e6b3168d3a434733d9daeabc307250/" rel="bookmark">
			Mac找不到.ssh文件夹的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先打开终端，输入命令：ssh localhost
右键访达，前往文件夹
输入命令：~/.ssh 即可找到ssh文件夹
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17b2243b6a0a3e98d642039fb3d28ea5/" rel="bookmark">
			boto3：Python连接S3对象存储并进行文件操作（上传、下载、删除）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、boto3
三、代码
1、连接
2、列出桶中文件
3、删除文件
4、上传下载
一、前言 在日常进行数据高可用时，会将数据存入对象存储中。在一般的企业中，对象存储资源池只有管理员拥有Web界面管理，普通账号需要对数据进行管理时，有如下方法：
一、通用对象存储管理客户端，如对于S3对象存储有S3browser可以进行使用，其优点是操作简单，界面可视化；缺点是每次需要手动操作。
二、利用对象存储指定的API或者SDK工具进行开发，其优点是适合无法使用可视化界面的IT环境和可自动完成，缺点是需要自己编辑。
二、boto3 boto3是针对S3云存储的Python SDK工具，是boto2的迭代版本，对于可使用S3对象存储接口协议的基本可使用boto3。
安装：pip install boto3
三、代码 1、连接 import boto3 from datetime import datetime, timedelta # 定义 endpoint、access key 和 secret key endpoint_url = 'http://*************' access_key = '****' secret_key = '****' # 创建 S3 客户端实例并指定 endpoint 和凭证信息 s3 = boto3.client('s3', endpoint_url=endpoint_url, aws_access_key_id=access_key, aws_secret_access_key=secret_key, verify=False) # 如果不需要SSL验证，可以设置verify=False，即http或者https # 列出所有的桶 responses = s3.list_buckets() buckets = [bucket['Name'] for bucket in responses['Buckets']] print('All of Buckets:', buckets) 2、列出桶中文件 #前面连接桶的代码段此处已省略 response = s3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17b2243b6a0a3e98d642039fb3d28ea5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/804aa287bb84a62217ed5b4937fa6218/" rel="bookmark">
			Python日志记录库——loguru
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. 概述二、基本使用2.1 安装2.2 日志输出 三、进阶用法3.1 显示格式3.2 写入文件3.3 模块名参数化3.4 日志留存、压缩与清理3.5 序列化为json格式3.6 并发安全 参考资料 一. 概述 在 Python 中用到日志记录，那就不可避免地会用到内置的 logging标准库 。虽然logging 库采用的是模块化设计，你可以设置不同的 handler 来进行组合，但是在配置上通常较为繁琐；而且如果不是特别处理，在一些多线程或多进程的场景下使用 logging还会导致日志记录会出现错乱或是丢失的情况。
关于Python内置的 logging标准库介绍可参见博客：Python 日志记录工具logging
标准库logging的替代品是loguru，loguru使用起来就简单的多。它不仅能够减少繁琐的配置过程还能实现和logging类似的功能，同时还能保证日志记录的线程进程安全，又能够和logging 相兼容，并进一步追踪异常也能进行代码回溯。
loguru默认的输出格式是：时间、级别、模块、行号以及日志内容。loguru不需要手动创建 logger，开箱即用；另外，日志输出内置了彩色功能，颜色和非颜色控制很方便，更加友好。
loguru官方文档：https://loguru.readthedocs.io/en/stable/index.html
二、基本使用 2.1 安装 loguru是非标准库，需要事先安装，命令是：
pip install loguru logger 本身就是一个已经实例化好的对象，如果没有特殊的配置需求，那么自身就已经带有通用的配置参数；同时它的用法和 logging库输出日志时的用法一致。
2.2 日志输出 （1）输出到控制台
安装后，最简单的使用样例如下：
from loguru import logger logger.debug('hello, this debug loguru') logger.info('hello, this is info loguru') logger.warning('hello, this is warning loguru') logger.error('hello, this is error loguru') logger.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/804aa287bb84a62217ed5b4937fa6218/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f2d0f241ff269faeb5ac245c6d95a58/" rel="bookmark">
			利用 Coze 快速搭建 AI 技术原型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 在当今技术日新月异的时代，AI 技术 已经渗透到了各个领域。作为工程师的我们需要紧跟技术潮流，将AI技术应用到我们的项目中。在此之前，我们还需要解决一个问题，如何获取到 AI 资源？如何通过 AI 资源将我们想要的功能实现？ 在这篇博客中，我将分享如何利用 Coze，快速搭建一个 AI 功能原型，为项目上线前做技术可行性验证。
需求 假设我今天突然想到一个创意，希望通过 AI 进行美食推荐。那么，如何说服我的领导这个想法是可行的呢？
答案是利用 Coze 搭建一个 AI 功能，通过实际演示向领导展示技术的可行性。
梳理需求 美食：食物名称、包含食材、推荐理由
附加信息：卡路里、附近的店、食物的图片
方案 通过大模型获取食物名称、包含食材及推荐理由利用 bingImageSearch 获取食物图片通过地图查询周边信息 实施 通过 Coze 的工作流，我们可以很快的实现上述方案
在个人空间中，点击 新建工作流 进行创建。填写完名称和描述后，系统会自动为您生成 开始节点 和 结束节点。
我们只需将左侧所需的组件拖拽至画布中，便可轻松完成操作。
搭建工作流 虽然看上去似乎很复杂，但实际上 Coze 已经为我们实现了底层逻辑。因此，我们只需通过简单的拖拽操作即可完成整个过程。
输入用户需求 query配置大模型 prompt css复制代码身为美食专家，您能根据用户的描述提供符合条件的美食。 用户的要求如下：{{input}}， 请根据用户的要求，推荐一道美食。 请严格按照以下格式输出： { "foodName":"(食物名称)", "params":"(所用食材)", "argument":"(推荐理由)" } 将 searchLocation、bingImageSearch 和 food 插件从左侧拖拽至画布中。（引用值可为上一个节点的结果）拖拽两个 代码 模块进行数据处理将所有元素进行连接 需要注意，插件可以通过 批处理 实现遍历请求，要求引用的数据必须是一个数组
举个例子，在我搭建的工作流中，需要使用 food 插件来计算所有食材的热量。在此过程中，上一个节点（大模型）输出的 params 参数为一个字符串数组：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f2d0f241ff269faeb5ac245c6d95a58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/843882c02c10e3f22e50e7b898963fd0/" rel="bookmark">
			mysql中DATE_FORMAT() 函数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql中DATE_FORMAT() 函数详解 一. 说明 在 MySQL 中，DATE_FORMAT() 函数用于将日期/时间类型的值按照指定的格式进行格式化输出。它的一般语法如下：
DATE_FORMAT(date, format) 其中，date 参数是要被格式化的日期/时间值，format 参数是指定的日期/时间格式，可以是一个字符串常量或者包含日期格式控制符的字符串。
下面是一些常用的日期和时间格式控制符：
格式控制符描述%Y年份，四位数字%y年份，两位数字%m月份，两位数字%c月份，没有前导零%d月份中的第几天，两位数字%e月份中的第几天，没有前导零%H小时，24小时制，两位数字%h小时，12小时制，两位数字%i分钟，两位数字%s秒钟，两位数字%pAM 或 PM 二. 举例 demo玩具：
下面的语句会将 CREATE_DATETIME 列的日期格式化为年份和月份： SELECT DATE_FORMAT(CREATE_DATETIME,'%Y-%m') as month_col FROM t_enjoyment_card_order; 此语句会返回一个包含年份和月份的字符串，例如 ‘2022-12’。
真实实例
统计各月份不同订单状态下的订单数量 select order_status,DATE_FORMAT(CREATE_DATETIME,'%Y-%m') as month_col,count(1) from t_enjoyment_card_order where order_status in('PAYMENTING','REFUND_ING','ABNORMAL','open_ing') group by order_status,month_col order by month_col desc 执行结果：
该SQL语句将根据指定的订单状态和年月份分组，统计每个组中的订单数量，并按照月份降序进行排列。
这个查询可以用于分析指定订单状态在不同月份的变化趋势或统计特定订单状态的总数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27557aefa4be6f17181e8bcf80de116a/" rel="bookmark">
			选择 Python IDE(VSCode、Spyder、Visual Studio 2022和 PyCharm)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 当选择 Python 开发工具时，你需要考虑自己的需求、偏好和项目类型。下面是对VSCode、Spyder、Visual Studio 2022和 PyCharm的对比推荐总结：
结论 1、如果你专注于“数据科学”，选择SpyDer没错。
内容 Visual Studio Code (VS Code): 优点： 轻量级，快速启动。免费、开源。丰富的插件市场，可以根据需求扩展功能。跨平台支持（Windows、Linux、Mac OS）。缺点： Debug 功能有限。没有内置模板。适用场景： 适合小型项目、快速编辑文件。推荐意见： 如果你需要一个轻量级、灵活且可自定义的编辑器，VS Code 是不错的选择。 Spyder:(专注于“数据科学”)
优点： 针对数据科学而设计。内置科学计算和数据分析工具。良好的 NumPy 和 Pandas 集成。缺点： 功能相对较少。适用场景： 适合数据处理、科学计算和数据分析。推荐意见： 如果你主要从事数据科学领域，Spyder 是不错的选择。 Visual Studio 2022: 优点： 强大的 IDE，适用于大型项目。支持多种编程语言。缺点： 不是 Python 使用者常用的工具。适用场景： 适合大型项目开发。推荐意见： 如果你需要深度调试和专业级工具，Visual Studio 2022 可能是你的最佳选择。 PyCharm: 优点： 专为 Python 开发而设计。支持多种 Python 框架。智能代码功能，精确且快速的 bug 修复。缺点： 界面庞杂。专业版较昂贵。适用场景： 适合大型项目、Web 开发、人工智能和机器学习。推荐意见： 如果你专注于 Python 开发，PyCharm 是不错的选择。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/494/">«</a>
	<span class="pagination__item pagination__item--current">495/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/496/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>