<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a863219ce03ca116a308afd5052d62ab/" rel="bookmark">
			面向对象编程：一切皆对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面向对象(OOP)是一种编程范式,它使用''对象''来设计软件。对象可以包含数据和代码：数据代表对象的状态，而代码代表操作数据的方式。在面向对象编程中，一切皆对象，这意味着将现实世界事务使用类与实例来模拟，如灯，汽车，导弹，杯子，都可以用类和实例来模拟。
一 、类与实例 类 类是对现实世界描述的一种类型。它定义了一组具有相同属性和方法的对象的结构。类名通常使用大驼峰命名法，例如 ElectricCar。
class ElectricCar: pass 类是抽象的，约定了未来实例应该有的内容，是实例的模板。
实例 实例是类的具现化。通过调用类来生成实例：
class ElectricCar: pass my_car = ElectricCar() 实例是具体的，具有具体的数据。实例的内容依赖于类。
二、self self 是类的一个特殊变量，用于代表未来的实例。在类的内部，self 用于访问类的属性和方法。
初始化函数 __init__ 是一个特殊的方法，称为构造器，用于初始化新创建的对象。
class ElectricCar: def __init__(self, make, model): self.make = make self.model = model 魔法函数 Python 提供了一系列特殊的方法，称为魔法函数，例如 __str__、__len__ 和比较方法 __eq__ 等。
# 内部编写所有魔法方法的使用案例 ''' 以双下滑线开头和结尾的为魔法函数 __init__: 用于初始化对象。 __str__: 返回实例用字符串表示，自定义内容 __len__:当使用 len() 函数时调用，返回容器类型的长度。 实例与实例之间也可以比较了 __eq__ :==触发 __ne__ :!=触发 __gt__ :&gt;触发 __ge__ :&gt;=触发 __lt__ :&lt; 触发 __le__ :&lt;=触发 __add__ :+触发 __sub__ :-触发 __mul__ :*触发 __truediv:/触发 __floordiv__://触发 __mod__:%触发 __divmod__:div(x,y)触发 ''' # class Myclass: # def __init__(self, name, age): # print('初始化函数执行了') # self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a863219ce03ca116a308afd5052d62ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5563d39d75c00d41654ae88640831188/" rel="bookmark">
			Mooncake：LLM服务的KVCache为中心分解架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		24年6月AI公司月之暗面的技术报告“Mooncake: A KVCache-centric Disaggregated Architecture for LLM Serving”。
Mooncake 是 Kimi 的服务平台，Kimi 是月之暗面公司提供的一项 LLM 服务。它采用以 K-V Cache 为中心的分解式架构，将预填充和解码 cluster 分开。它还利用 GPU cluster 中未充分利用的 CPU、DRAM 和 SSD 资源来实现 K-V Cache 的分解式缓存。
Mooncake 的核心是以 K-V Cache 为中心的调度程序，在最大化整体有效吞吐量和满足与延迟相关的服务级目标 (SLO) 之间取得平衡。与假设所有请求都将被处理的传统研究不同，Mooncake 面临着高度超载场景带来的挑战。为了缓解这些问题，开发一种基于预测的早期放弃（early rejection）策略。实验表明，Mooncake 在长上下文场景中表现出色。
随着大语言模型 (LLM) 在各种场景中的快速应用 [1、2、3、4]，LLM 服务的工作负载变得非常多样化。这些工作负载在输入/输出长度、频率和分布方面有所不同，最重要的是，需要不同类型的服务级目标 (SLO)。作为模型即服务 (MaaS) 提供商，Kimi [5] 的主要目标之一是解决具有多个复杂约束的优化问题。优化目标是最大化整体有效吞吐量，这直接影响收入，而约束反映了不同级的 SLO。这些 SLO 通常涉及满足与延迟相关的要求，主要是第一个token的时间 (TTFT) 和token之间的时间 (TBT)。
为了实现这一目标，先决条件是充分利用 GPU 集群中可用的各种资源。具体而言，尽管 GPU 服务器目前以高度集成的节点形式提供（例如 DGX/HGX 超级计算机 [6]），但有必要将它们解耦并重组为几个分散的资源池，每个资源池针对不同但协作的目标进行优化。例如，许多研究人员 [7、8、9] 建议将预填充服务器与解码服务器分开，因为 LLM 服务的这两个阶段具有非常不同的计算特性，其中 K-V Cache 会随着请求从预填充服务器转移到解码服务器而发生变化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5563d39d75c00d41654ae88640831188/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e49e2cd8876cf6669642ce1546097da/" rel="bookmark">
			花几千上万学习Java，真没必要！（三十五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Map：
Map接口的基本且常用的操作，用于管理键值对集合。
V put(K key, V value)
作用：向映射中添加一个键值对。
参数：K key 是键的类型，V value 是与键关联的值。
返回值：如果映射以前包含该键的映射关系，则返回旧值（即替换前的值）。如果映射不包含该键的映射关系，则返回null。
键是唯一的，如果尝试添加一个已经存在的键，则旧值将被新值替换。
V remove(Object key)
作用：从映射中移除与指定键相关联的键值对。
参数：Object key 是要移除的键。
返回值：如果映射包含该键的映射关系，则返回与该键相关联的值；如果不包含，则返回null。
void clear()
作用：从映射中移除所有键值对。
参数：无。
返回值：无。
调用此方法后，映射将为空。
boolean containsKey(Object key)
作用：判断映射中是否包含指定的键。
参数：Object key 是要检查的键。
返回值：如果映射包含该键的映射关系，则返回true；否则返回false。
boolean containsValue(Object value)
作用：判断映射中是否包含指定的值。
参数：Object value 是要检查的值。
返回值：如果映射包含至少一个键值对，其值等于value，则返回true；否则返回false。
此方法可能需要遍历映射中的所有键值对以查找值，因此效率较低。
boolean isEmpty()
作用：判断映射是否为空。
参数：无。
返回值：如果映射不包含任何键值对，则返回true；否则返回false。
int size()
作用：返回映射中键值对的数量。
参数：无。
返回值：映射中键值对的数量。
遍历方式1：
遍历方式2： 测试代码1： package maptest.com; import java.util.HashMap; import java.util.Map; //put(K key, V value)：将指定的值与此映射中的指定键关联（可选操作）。如果此映射以前包含该键的映射，则替换旧值（和键关联的旧值，如果有的话）。 //get(Object key)：返回指定键所映射的值；如果此映射不包含该键的映射，则返回null。 //remove(Object key)：如果存在一个键的映射，则将其从此映射中移除（可选操作）。 //containsKey(Object key)：如果此映射包含指定键的映射，则返回true。 //containsValue(Object value)：如果此映射将一个或多个键映射到指定值，则返回true。 public class HashMapDemo { public static void main(String[] args) { // 创建HashMap实例 Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); // 使用put方法添加键值对 map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e49e2cd8876cf6669642ce1546097da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69d09b1a88f6b94541773e9fff62b6a4/" rel="bookmark">
			【排序算法（二）】——冒泡排序、快速排序和归并排序—＞深层解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 接上篇，排序算法除了选择排序（希尔排序）和插入排序（堆排序）之外，还用交换排序（冒泡排序、快速排序）和归并排序已经非比较排序，本篇来深层解析这些排序算法
一、交换排序 1.1、冒泡排序 冒泡排序，这个再熟悉不过了，学校中老师讲的第一个排序就是冒泡排序；直接看代码
代码如下：
//冒泡排序 void BubbleSort(int* arr, int n) { int exchange = 0; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n - i - 1; j++) { if (arr[j] &gt; arr[j + 1]) { exchange = 1; Swap(&amp;arr[j], &amp;arr[j + 1]); } } if (exchange == 0) { break; } } } 时间复杂度：O(n^2)；空间复杂度O(1)。
1.2、快速排序 快速排序，是hoare于1962年提出的一种二叉树结构的交换排序算法，其基本思想为：任意取待排序元素序列中的某元素作为基准值，按照该排序码将待排序集合分割成两个子序列，左子序列中所有元素均小于基准值，右子序列所有元素均大于基准值然后左右子序列重复此过程，直到所有元素都排列在相应位置上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69d09b1a88f6b94541773e9fff62b6a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3ebb5d342fee89c7b70a4fcd5ddcbfc/" rel="bookmark">
			js中map属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript中的Map对象保存键值对，并且能够记住键的原始插入顺序
以下是关于如何在JavaScript中使用Map对象的博客文章概要：
一、创建和初始化Map对象
使用new Map()构造函数可以创建一个新的Map对象。你还可以在构造函数中传入一个可迭代对象（如键值对数组）来初始化Map对象。
const map1 = new Map(); // 创建一个空的Map对象 const map2 = new Map([ ['key1', 'value1'], ['key2', 'value2'], ['key3', 'value3'] ]); // 使用键值对数组初始化Map对象 二、添加和获取键值对
使用set()方法向Map对象中添加键值对，使用get()方法根据键获取对应的值。
map1.set('key1', 'value1'); map1.set('key2', 'value2'); console.log(map1.get('key1')); // 输出：'value1' console.log(map1.get('key2')); // 输出：'value2' 三、检查键是否存在
使用has()方法检查Map对象中是否存在指定的键。
console.log(map1.has('key1')); // 输出：true console.log(map1.has('key3')); // 输出：false 四、删除键值对
使用delete()方法从Map对象中删除指定的键及其对应的值。
map1.delete('key1'); console.log(map1.has('key1')); // 输出：false 五、遍历Map对象
Map对象支持使用forEach()方法或for...of循环进行遍历。
// 使用forEach()方法遍历 map1.forEach((value, key) =&gt; { console.log(`${key}: ${value}`); }); // 使用for...of循环遍历 for (const [key, value] of map1) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3ebb5d342fee89c7b70a4fcd5ddcbfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74edb0a114367a9155646f7dd5f404b0/" rel="bookmark">
			Linux系统安装opencv
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Linux系统上安装OpenCV时，使用pip install opencv-python-headless是一个常见的选择。以下是安装OpenCV的步骤总结：
安装步骤： 更新系统软件包（可选）：
sudo apt update sudo apt upgrade 安装pip（如果尚未安装）：
sudo apt install python3-pip 安装OpenCV：
使用以下命令安装OpenCV的无GUI版本（适用于服务器或不需要图形界面的环境）：
pip install opencv-python-headless 说明： opencv-python：包含完整的OpenCV库，包括GUI功能（需要X11等图形环境）。opencv-python-headless：去除了GUI功能，适合在没有图形界面的服务器上使用，减少依赖和安装包大小。 验证安装： 可以通过以下Python代码来验证是否成功安装：
import cv2 print(cv2.__version__) 如果能够正确输出OpenCV的版本号，则表示安装成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e10e27db636b99a4da3a2819e051cbfb/" rel="bookmark">
			Python爬虫利器requests：数据传递、代理隧道与证书异常处理！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔸 数据传递：params参数 在使用requests库时，最常用的参数之一就是params，它用于在GET请求中传递查询参数：
import requests # 构建URL url = 'https://api.example.com/data' # 定义查询参数 params = { 'key1': 'value1', 'key2': 'value2' } # 发送GET请求 response = requests.get(url, params=params) # 打印响应内容 print(response.url) print(response.json()) 🔹 在这个例子中，params参数将查询参数添加到URL中，最终URL变成https://api.example.com/data?key1=value1&amp;key2=value2。这非常适合用于过滤或搜索数据。
🔸 数据传递：data参数 data参数通常用于POST请求，传递表单数据：
import requests # 构建URL url = 'https://api.example.com/login' # 定义表单数据 data = { 'username': 'myusername', 'password': 'mypassword' } # 发送POST请求 response = requests.post(url, data=data) # 打印响应内容 print(response.text) 🔹 使用data参数可以模拟表单提交，将数据以表单格式发送到服务器。这在登录、注册等操作中非常常见。
🔸 数据传递：json参数 json参数用于传递JSON格式的数据，通常用于API请求：
import requests # 构建URL url = 'https://api.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e10e27db636b99a4da3a2819e051cbfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32742899bd0d443157961ba36f6fc3bd/" rel="bookmark">
			STL模板库超详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STL模板库 标准模板库STL（‌Standard Template Library）‌是C++语言中的一个重要组成部分，‌它提供了一套通用的数据结构和算法，‌旨在提高软件开发的效率和可重用性。‌ STL主要由容器、‌算法和迭代器三个核心部分组成，‌这些组件共同构成了C++标准程序库的一部分，‌尽管STL本身并不是C++标准程序库的全部。‌
容器：‌STL容器是用于存储数据的类，‌包括向量（‌vector）‌、‌双端队列（‌deque）‌、‌表（‌list）‌、‌队列（‌queue）‌、‌堆栈（‌stack）‌、‌集合（‌set）‌、‌多重集合（‌multiset）‌、‌映射（‌map）‌和多重映射（‌multimap）‌等。‌每种容器都有其独特的特点和适用场景，‌例如，‌向量适合频繁访问元素且可能在尾部进行大量插入和删除操作的场景，‌而集合则用于存储不重复的元素。‌
算法：‌STL算法是一组用于解决常见问题的有限步骤函数，‌它们不依赖于特定的容器类型，‌而是通过迭代器访问容器中的元素。‌这些算法可以高度通用，‌能够应用于多种不同的容器类型，‌例如排序（‌sort）‌、‌查找（‌find）‌、‌替换等。‌
迭代器：‌迭代器是STL中的一个核心概念，‌它提供了一种统一的方法来访问容器中的元素。‌迭代器类似于指针，‌但比指针更加安全，‌因为它们被设计为只能进行有限的、‌安全的操作。‌
STL的代码从广义上讲分为三类：‌algorithm（‌算法）‌、‌container（‌容器）‌和iterator（‌迭代器）‌，‌几乎所有的代码都采用了模板类和模板函数的方式，‌这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。‌STL的出现，‌使得C++编程语言在有了同Java一样强大的类库的同时，‌保有了更大的可扩展性。‌
此外，‌STL还强调了类型参数的使用，‌通过使用typename或class关键字声明类型参数，‌使得STL具有高度的灵活性，‌能够适应不同的数据类型和需求。
一、序列容器 1.vector vector容器提供了许多操作，‌如push_back、‌pop_back、‌insert、‌erase等，‌以方便用户对容器中的元素进行添加、‌删除和修改。‌此外，‌vector还支持随机访问，‌即可以通过索引直接访问容器中的元素。‌
vector的构造函数有多种形式，‌包括默认构造函数、‌带有初始大小的构造函数、‌带有初始元素值和大小的构造函数等。‌例如：‌
默认构造函数：‌vector&lt;int&gt; vec1; 创建一个空的vector。‌带有初始大小的构造函数：‌vector&lt;int&gt; vec2(10); 创建一个包含10个默认初始化元素的vector。‌带有初始元素值和大小的构造函数：‌vector&lt;int&gt; vec3(10, 6); 创建一个包含10个元素，‌初始值都为6的vector。‌vector&lt;int&gt; vec4(vec2.begin(), vec2.begin() + 3); 通过vec2的迭代器范围构造一个新的vector，‌包含vec2的前三个元素。‌class Person { /*...*/ };vector&lt;Person&gt; people; 创建一个存储Person对象的vector。‌ 此外，‌vector还支持预留空间、‌插入和删除元素等操作，‌使得它成为一个非常实用的数据结构。‌总的来说，‌STL中的vector是一个功能强大且灵活的容器，‌适用于需要动态调整大小的场景。
2.array STL中的array是一个固定大小的数组容器，‌它提供了比原生数组更安全、‌更易于使用的接口。‌
sarray的主要特点包括：‌
固定大小：‌与原生数组类似，‌array也是一个固定大小的容器，‌这意味着在定义时就需要确定其大小，‌并且之后不能改变这个大小。‌这种特性使得array在处理需要固定大小数据的情况时非常有用。‌
类型安全：‌array提供了类型安全保证，‌因为它在编译时检查数组的大小和类型，‌这有助于减少运行时错误。‌
支持随机访问：‌array支持随机访问元素，‌即可以通过索引直接访问数组中的任何元素。‌
提供了一系列成员函数：‌包括size()、‌front()、‌back()、‌data()等，‌这些函数提供了对数组元素的便捷访问和操作。‌
支持迭代器和范围for循环：‌array支持迭代器访问，‌这使得它可以与STL中的其他算法和容器进行交互。‌同时，‌也支持C++11引入的范围for循环，‌使得遍历数组元素变得更加简单。‌
非类型模板参数：‌array是一个模板类，‌其中包含一个非类型模板参数，‌用于指定数组的大小。‌这使得array可以定义具有不同大小的数组实例。‌
3.deque（‌双端队列）‌ deque，‌即双端队列，‌是STL（‌Standard Template Library）‌中的一个序列式容器，‌它允许在容器的头部和尾部进行插入和删除操作。‌与vector容器相比，‌deque特别适合在需要频繁进行前后端操作的应用中，‌因为它对头部的插入和删除操作具有较高的效率。‌deque的物理结构由多块离散且连续的存储空间组成，‌通常这些存储空间是定长的数组缓冲区，‌通过一个中控器（‌一般是map结构）‌来维护这些缓冲区的指针，‌从而实现双端队列的功能。‌
deque的主要特点包括：‌
双端操作：‌允许在容器的头部和尾部进行元素的插入和删除。‌高效性：‌相对于vector，‌deque在头部和尾部的操作效率更高，‌尤其是在需要频繁进行前后端操作的应用中表现更佳。‌动态管理：‌通过中控器管理多个缓冲区，‌当某个缓冲区满时，‌中控器会自动为其分配新的缓冲区；‌当不再需要某个缓冲区时，‌中控器会回收该缓冲区，‌实现动态内存管理。‌随机访问：‌deque提供双向随机访问迭代器，‌支持通过索引直接访问元素。‌ deque的成员函数包括但不限于：‌
插入和删除：‌push_front(), push_back(), pop_front(), pop_back(), insert(), erase() 等，‌用于在头部和尾部插入或删除元素。‌访问元素：‌front(), back(), at(idx), operator[] 等，‌用于访问容器中的元素。‌大小和清空：‌size(), empty(), clear() 等，‌用于获取容器大小、‌判断是否为空或清空容器。‌赋值和交换：‌assign(), swap() 等，‌用于为容器赋值或与另一个容器交换内容。‌ 此外，‌deque还支持一些标准容器的通用算法，‌如排序、‌查找等。‌需要注意的是，‌虽然deque和vector在很多操作上相似，‌但它们在内部实现、‌性能特点以及适用场景上有所区别。‌例如，‌vector在连续内存空间中存储元素，‌因此随机访问速度较快，‌但在头部插入或删除元素时效率较低，‌尤其是当数据量较大时。‌相比之下，‌deque通过维护多个缓冲区的方式，‌使得头部和尾部的操作更加高效。
4.list STL模板库中的list是一个双向链表容器，‌它提供了一种灵活且高效的方式来管理对象的集合。‌
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32742899bd0d443157961ba36f6fc3bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6aef1d44f4be98e44863b0d3017c3ce1/" rel="bookmark">
			c语言第七天笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作业题：
设计TVM（地铁自动售票机）机软件。
输入站数，计算费用，计费规则，6站2元，7-10站3元，11站以上为4元。 输入钱数，计算找零(找零时优先找回面额大的钞票)，找零方式为各种面额张数，可识别面额： 100,50,20,10,5,1
案例代码：
运行效果：
循环结构
什么是循环
代码的重复执行，就叫做循环。
循环的分类
无限循环：程序设计中尽量避免无限循环。(程序中的无限循环必须可控)
有限循环：循环限定循环次数或者循环的条件。
循环的构成
循环体
循环条件
当型循环的实现
while
语法：
说明：
1. 循环条件的返回值必须是布尔类型，在C语言中，布尔类型为真使用 非0 来表示，布尔类型为假使 用 0 表示。
2. {} 包起来的内容整体称之为为 循环体 。
3. 我们要在 循环体 中控制 循环条件 的变化，否则会产生死循环。
执行过程：
特点：
先判断，后执行，循环体语句有可能一次都不执行。
案例：
案例：
死循环
for..
语法：
说明：
1. () 中可以只保留两个分号，举例： (;;)
2. ① 是循环变量，我们需要赋初值，循环变量可以是列表，多个循环变量使用逗号分隔，举例： in t i=0,j=0
3. ② 是循环条件，用来限制循环的次数，循环条件支持关系表达式，如果加入逻辑表达式，会变成 复合表达式，举例： i &lt; 10 &amp;&amp; j &lt; 10
4. ③ 改变循环条件，支持列表，这里可以使用赋值表达式，举例： i++,j++
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6aef1d44f4be98e44863b0d3017c3ce1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3d0756a3d0c9e737546fe53be37c73a/" rel="bookmark">
			【数据结构】包装类和泛型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎉欢迎大家收看，请多多支持🌹
🥰关注小哇，和我一起成长🚀个人主页🚀
⭐在更专栏Java ⭐数据结构
⭐已更专栏有C语言、计算机网络⭐
👑目录
包装类🌙
⭐基本类型对应的包装类
⭐装箱与拆箱
🌈自动装箱和显式装箱
🚀自动装箱：
🚀显式装箱
🚀 Integer类的缓存机制：
🌈自动拆箱和显式拆箱
🚀自动拆箱
🚀显式拆箱
🌈相关面试题及知识点
泛型🌙
⭐语法
🌈基本泛型类定义：
🌈多类型参数的泛型类：
🌈泛型类继承自其它泛型类：
🌈泛型类继承自特定类型的泛型类：
🌈具体代码举例：
⭐泛型类的使用：
🌈语法：
🌈举例：
⭐裸类型（了解）：
⭐泛型的擦除机制（泛型如何编译）：
⭐泛型的上界
🌈语法：
🌈例子：
🌈复杂例子：
⭐泛型方法：
🌈方法示例：
🌈 使用方法示例：
🚀可以类型推导：
🚀不使用类型推导：
包装类🌙 Java中每个基本数据类型都对应了一个包装类，
除了int的包装类是Integer，char的包装类是Character，其他的基本类型对应的包装类都是将首字母大写。
⭐基本类型对应的包装类 基本数据类型包装类byteByteshortShortintIntegerlongLongcharCharacterbooleanBooleanfloatFloatdoubleDouble Java中的泛型中，不能直接使用基本数据类型作为类型参数；
如果需要使用与基本数据类型相关的泛型，应该使用它们对应的包装类。
⭐装箱与拆箱 又叫装包或拆包。
🌈自动装箱和显式装箱 🚀自动装箱： 自动地将基本数据类型（如int、double等）转换为它们对应的包装类（如Integer、Double等）
int a = 6; //自动装箱 Integer b = a; Integer b2 = (Integer)a; 🚀显式装箱 int a = 6; //显式装箱,调用valueOf()方法 Integer d = Integer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3d0756a3d0c9e737546fe53be37c73a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1d648018dcaa9c4f1fa601f8a0dd789/" rel="bookmark">
			Python爬虫技术 第24节 数据清洗和预处理（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python爬虫项目中，数据清洗和预处理是非常关键的步骤。这部分工作通常涉及到字符串操作、缺失值处理和数据格式转换等方面。下面我将详细讲解这些方面的内容，并提供具体的代码示例。
1. 字符串操作 字符串操作在数据清洗过程中非常重要，因为网页内容通常包含大量的文本数据。常见的字符串操作包括去除空白字符、大小写转换、去除特殊字符等。
示例代码： # 去除空白字符 def remove_whitespace(text): return text.strip() # 大小写转换 def to_lowercase(text): return text.lower() # 去除特殊字符 import re def remove_special_chars(text): return re.sub(r'[^a-zA-Z0-9\s]', '', text) # 示例使用 text = " Hello, World! " cleaned_text = remove_whitespace(text) cleaned_text = to_lowercase(cleaned_text) cleaned_text = remove_special_chars(cleaned_text) print(cleaned_text) # 输出: hello world 2. 缺失值处理 在爬取数据时，有时会遇到缺失值的情况。缺失值可能出现在任何数据类型中，包括字符串、数字等。处理缺失值的方法通常包括删除含有缺失值的记录、填充缺失值等。
示例代码： import pandas as pd # 创建一个包含缺失值的DataFrame data = { 'Name': ['Alice', 'Bob', 'Charlie'], 'Age': [25, None, 30], 'Email': ['alice@example.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1d648018dcaa9c4f1fa601f8a0dd789/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fb73a6304dde76ca627026c56df27d2/" rel="bookmark">
			【人工智能】人工智能的历史发展与机器学习和神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你应该看过《终结者》，《机械公敌》等电影吧，但你知道为什么机器能像人一样思考吗 ？
人工智能早已不是科学幻想，它们是一种已经应用到我们生活方方面面的技术，例如：许多公司的门禁采用了人脸识别系统；医院里要利用计算机快速诊断肺部 CT 影像；在路上开车违章，会被电子烟抓拍罚款…
这里的人脸识别、CT 影像识别、车牌识别通通用到了人工智能。除此之外，手机上的各种语音助手软件、智能音响、美颜软件、短视频平台的推荐机制、电子邮件的防垃圾邮件系统都是人工智能的应用。
在未来我们要实现的自动驾驶、智慧工业等领域，人工智能是不可或缺的。如果将人工智能从我们的生活中剥离，人类恐怕要退回到三十年以前
今天我们就来聊一聊人工智能的话题，希望能让大家了解人工智能和神经网络的基本工作原理
一、人工智能的发展史 人工智能并不是一个新生的科学概念。在上古时代，东西方文明都出现了人造人的神话，到了二十世纪 30-50 年代，由于神经生物学、计算机科学、数学等学科的发展，人工智能第一次进入了科学家的视野。
1950 年，英国计算机科学家图灵提出了一个问题——机器会思考吗？
图灵提出了一种测试机器智能的标准—— 图灵测试。
一个人 C 通过文字等方式，与另外一个人 A 和一个计算机 B 进行交流，他能否通过一连串的问题区分 A 和 B 哪个是人，哪个是计算机呢？如果人类无法区分出 A 和 B，那么就称为计算机通过了图灵测试。
图灵预言，到 2000 年的时候，计算机在经过五分钟的提问之后，就会骗过 30%的人类，让人相信对方是真实地人类，而非计算机。
图灵测试每年都会举办，在 2014 年的时候，终于有一个人工智能软件，被 33%的人类认为是一个 13 岁的小男孩，通过了图灵测试，这个软件叫尤金·古斯特曼。
到了 1956 年，美国计算机科学家马文·明斯基、约翰·麦卡锡以及信息论的奠基者香农等人，召开了“达特茅斯会议“，在这次会议上，人们创造出了“人工智能”这个词。从这次会议开始，人工智能进入了人大发展时代
后来，明斯基和麦卡锡都因为在人工智能领域的贡献，获得了图灵奖，而香农已经不需要图灵奖了，他的名字被命名到通信理论方面的诺贝尔奖——“香农奖”上。
从此之后的几十年中，由于算法和算力的限制，人工智能几经起落，直到 1997 年，IBM 的人工智能程序“深蓝”，战胜了雄踞国际象棋霸主 12 年的卡斯帕罗夫，人工智能迎来了第三次大发展。从这之后的二十多年里，在人工智能算法方面，涌现出许多灵魂人物，例如被誉为"深度学习之父"的多伦多大学的计算机学家——杰弗里·辛顿，他将反向传播算法（BP）引入了人工智能领域；纽约大学计算机学家——杨立昆，他最著名的工夫作是卷积神经网络（CNN），他们俩连同加拿大蒙特利尔大学计算机学家——约书亚·本吉奥共同获得了 2018 年的图灵奖
经过众多科学家的努力，在特定的领域——例如图像识别，人工智能识别率已经超过了人类。在语音识别、智能翻译等领域，人工智能也有长足的应用。现在我们上网，遇到看不懂的外文，只需要按一下“翻译”按钮就能变成汉语了。去国外旅游，也可以双方用一个人工智能软件就能交流了。
二、机器学习 计算机到底是如何做到这一点的呢？说到底，这是一个数学问题，我们先来举一个例子，“如何预测房屋的成交价格？”
如何预测房屋价格 也许我们每个人都有一种简单判断，大城市比小城市的房子值钱，市区的房子比郊区的房子值钱，学区房比非学区房值钱… 那么，你能用数学关系把它表示出来吗？
比如，在最简单的模型下，我们考虑房屋价格与面积有关，我们有了一些房屋的面积以及它们的成交价格，把数据 ( x i , y i ) (xi, yi) (xi,yi) 画在一张图上。从图形上看，我们发现房价和面积接近于正相关，我们希望获得一个函数关系，使得它尽量准确的表示出房价 y y y 与面积 x x x 的关系。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fb73a6304dde76ca627026c56df27d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ec74de7f82c3224c09ed0b882915fb0/" rel="bookmark">
			npm install报错原因记录：npm ERR! code ENOENT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错原因：路径打开错了，你需要在package.json这个文件的文件夹目录打开终端执行命令才行。
比如我的前端项目中，package.json项目在back-system-font-ts文件下，我就需要右击该文件，从该目录打开终端才有用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1ac3db0e1d7b4255d7ce873783bb856/" rel="bookmark">
			【C&#43;&#43;/STL】：哈希表的改造 -- 封装unordered系列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一，哈希表的改造1. 哈希表的基本框架2. 对哈希桶节点结构的改造3. 哈希表的迭代器3.1 迭代器类3.2 Begin() 和 End() 四，哈希表相关接口的改造4.1 Find 函数的改造4.2 Insert 函数的改造 五，哈希表改造的完整代码六，unordered_set 的封装实现七，unordered_map 的封装实现 点击跳转至文章： 【C++/STL】：哈希 – 线性探测&amp;哈希桶 前言 与map/set的封装类似，unordered系列的底层本质上也是复用，通过对哈希表的改造，再分别套上一层 unordered_map 和 unordered_set 的 “壳子”，以达到 “一表二用” 的目的。
各个结构的改造不再详细说明，细节可参考文章：map和set的封装
unordered系列的底层哈希表是用哈希桶结构实现的。
一，哈希表的改造 1. 哈希表的基本框架 (1) K：关键码类型；
(2) V:：不同容器V的类型不同，如果unordered_map，V代表一个键值对，如果是unordered_set，V 为 K；
(3) KeyOfValue：因为V的类型不同，通过value取key的方式就不同，详细见unordered_map/set的实现；
(4) Hash：哈希函数仿函数对象类型，哈希函数使用除留余数法，需要将Key转换为整形数字才能取模。
template &lt;class K, class T, class KeyOfT,class Hash = HashFunc&lt;K&gt;&gt; class HashBucket { //友元 template &lt;class K, class T, class Ref, class Ptr,class KeyOfT, class Hash &gt; friend struct HTIterator; typedef BucketNode&lt;T&gt; Node; public: typedef HTIterator&lt;K, T, T&amp;, T*, KeyOfT, Hash&gt; Iterator; typedef HTIterator&lt;K, T, const T&amp;, const T*, KeyOfT, Hash&gt; ConstIterator; //其他核心操作…… private: vector&lt;Node*&gt; _tables; //指针数组 size_t _n = 0; //表中数据的个数 }; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1ac3db0e1d7b4255d7ce873783bb856/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e024a468713855fc36678fb3d4fdf28d/" rel="bookmark">
			【编程向导】Nginx-静态资源服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		静态资源 静态资源即非服务器动态生成的文件。
常见静态资源类型：
浏览器端渲染：HTML、CSS、JS图片：JPEG、GIF、PNG视频：FLV、MPEG文件：TXT 等任意下载文件 基本配置 Web 服务器一个重要的功能是服务静态文件（图像或静态 HTML 页面）。例如，Nginx 可以很方便的让服务器从 /data/www 获取 html 文件，从 /data/images 获取图片来返回给客户端，这只需要在 http 块指令中的 server 块指令中设置两个 location 块指令。
首先，创建 /data/www 目录，并放入 index.html，创建 /data/images 目录并在其中放置一些图片。
接下来，打开配置文件。 创建一个 server 块：
http { server { } } 通常，配置文件可以包括多个 server 块，它们以 端口 和 服务器名称 来区分。当 Nginx 决定某一个 server 处理请求后，它将请求头中的 URI 和 server 块中的 location 块进行对比。
加入 location 块指令到 server 中：
将以下 location 块添加到 server 块：
location / { root /data/www; } 上面的 location 块指定 / 前缀与请求中的 URI 对比。对于匹配的请求，URI 将被添加到 root 指令中指定的路径，即 /data/www，以此形成本地文件系统的路径，如访问 http://localhost/bog/welcome.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e024a468713855fc36678fb3d4fdf28d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc54de13bcd23843cc3928a816badf51/" rel="bookmark">
			Python实战——轻松实现动态网页爬虫(附详细源码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是东眠的鱼，专注原创，致力于用浅显易懂的语言分享爬虫、数据分析及可视化等干货，希望人人都能学到新知识。&lt;文末附带精品籽料哦，也可以和博主一起学Python呀！&gt;
项目背景
有同学自学爬虫时，发现翻页的时候，url一直不变。其实他爬取的是较高难度的网页——动态网页。今天给大家介绍动态网页的爬虫!
AJAX动态加载网页
一、什么是动态网页
所谓的动态网页，是指跟静态网页相对的一种网页编程技术。静态网页，随着html代码的生成，页面的内容和显示效果就基本上不会发生变化了——除非你修改页面代码。而动态网页则不然，页面代码虽然没有变，但是显示的内容却是可以随着时间、环境或者数据库操作的结果而发生改变的。——来源百度百科
动态网页具有减少工作量、内容更新快、可完成功能多等特点，被很多公司所采用，比如狗东、某宝、某瓣、某乎等等。
二、什么是AJAX
随着人们对动态网页加载速度的要求越来越高，AJAX技术应运而生并成为许多站点的首选。AJAX是一种用于创建快速动态网页的技术，通过在后台与服务器进行少量数据交换，使网页实现异步更新。这意味着在不重新加载整个网页的情况下，可以对网页的某部分进行更新。
三、如何爬取AJAX动态加载网页
1. 解析接口
只要是有数据发送过来，那肯定是有发送到服务器的请求的吧。我们只需找出它悄悄加载出的页面的真实请求即可。特点：爬取速度快，爬取的数据干净，有些网站解析难度较大。
2. Selenium
selenium是什么呢？它本来是个自动化测试工具，但是被广泛的用户拿去爬虫了。它是一个工具，这个工具可以用代码操作浏览器，比如控制浏览器的下滑、模拟鼠标点击等。特点：代码较简单，爬取速度慢，容易被封ip。
项目实操
怎么说了那么多理论，说实话也不想那么啰嗦。可是吧，这些东西经常会被问到，干脆直接写下来，下次还有人问就直接把这篇文章发给他，一劳永逸！
我们拿一个法院信息公示网页举例：
那我们就开启爬虫的正确姿势吧，先用解析接口的方法来写爬虫。
首先，找到真实请求。右键检查，点击Network，选中XHR，刷新网页，选择Name列表中的jsp文件。没错，就这么简单，真实请求就藏在里面。
‍
我们再仔细看看这个jsp，这简直是个宝啊。有真实请求url，有请求方法post，有Headers，还有Form Data，而From Data表示给url传递的参数，通过改变参数，咱们就可以获得数据！
我们再仔细看看这些参数，pagesnum参数不就是代表页数嘛！我们尝试点击翻页，发现只有pagesnum参数会变化。
既然发现了它，那就赶紧抓住它。打开PyCharm，导入了爬虫所需的库。
1from urllib.parse import urlencode 2import csv 3import random 4import requests 5import traceback 6from time import sleep 7from lxml import etree #lxml为第三方网页解析库，强大且速度快 构造真实请求，添加Headers。
1base_url = 'http://www.hshfy.sh.cn/shfy/gweb2017/ktgg_search_content.jsp?' #这里要换成对应Ajax请求中的链接 2 3headers = { 4 'Connection': 'keep-alive', 5 'Accept': '*/*', 6 'X-Requested-With': 'XMLHttpRequest', 7 'User-Agent': '你的User-Agent', 8 'Origin': 'http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc54de13bcd23843cc3928a816badf51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8de15f43db048d9b190e8218114567bd/" rel="bookmark">
			golang离线引用依赖包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		go mod vendor 是Go语言中用于模块化管理的一个命令，它将当前项目的依赖包复制到项目根目录下的 vendor 子目录中。这个命令主要服务于以下两个目的：
离线开发与构建：当你把所有依赖都放入 vendor 目录后，即使在没有网络连接的情况下，也可以正常编译和运行项目，因为Go工具链会优先从 vendor 目录加载依赖。
版本锁定与一致性：vendor 目录包含了项目精确到某一时刻的所有依赖版本，确保了项目在未来任何时候重新构建时，使用的都是与当时一致的依赖版本，从而避免因依赖升级导致的潜在问题。
使用方法如下：
在项目根目录下运行
go mod vendor 执行后，所有项目依赖（包括间接依赖）都会被复制到 vendor 文件夹内。这样，在团队协作或者持续集成(CI/CD)流程中，都可以基于 vendor 中的依赖进行稳定、一致的构建。同时，一些支持Go模块的构建工具和服务，默认会查找并使用 vendor 目录内的依赖。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd7f1c1a650bd251e1d3dc16ce5861fa/" rel="bookmark">
			现在的Java面试都这么扯淡了吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		估计跟我3年经验的时候差不多，在开始前刚好我有一些资料，是我根据网友给的问题精心整理了一份「Java的资料从专业入门到高级教程」，
点个关注在评论区回复“888”之后私信回复“888”，全部无偿共享给大家！！！
那个时候觉得技术牛就是把框架的源码，配置搞精通，后来把几个常用php框架源码都看了几遍，那个时候觉得自己挺厉害啊，觉得自己是高手，因为日常工作就是用框架curd,既然我把源码都搞熟了，我能不是高手吗?
后来第4-5年，觉得实在不知道学啥了，好像没东西学了，就去学前端，vue，react9,又充实了几年。
这个时候我还是觉得自己厉害的，毕竟前后端都会，直到后来这几年我觉得我计算机基础太差，开始看其它语言，c，go，java，学数据结构，在后来深入到操作系统底层，单片机，汇编，我才发现我工作前面那5年是多菜，那个时候听都没听说过线程安全9，线程同步，安全队列，阻塞队列, hash，b+树，不懂算法复杂度°，啥叫编译，没听过sizeof这种在编译期获取变量长度的概念，标准库，共享库9，不懂c语言字符串啥要结束符，不懂为啥字符串内存结构为啥是数组，不懂指针，不懂变量本身的名字保存在内存哪里，不懂对象在内存的结构以及位置，不懂网络，tcp协议Q，网络模型，没听过寄存器，不懂他们常说的堆栈Q是啥，不懂虚拟内存，进程，线程，协程，没听过中断，软中断，没听过那一堆锁，自旋锁9，重入锁，公平锁，更不知道锁的底层实现，想说的实在太多，这就是一个非科班，学php的，真实经历，因为php就是一个上面这些东西，你全部不需要懂，都能干好工作的语言。所以说很可能出现一个类似我这样，专业的计算机知识一个都不懂，但是框架用的很溜,curd写的飞起的人。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb7623bdbf9fcd8e99c7d75947c4d669/" rel="bookmark">
			【AI大模型】：结合wxauto实现智能微信聊天机器人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🧐一、wxauto简介🎯二、wxauto的主要功能📦三、wxauto的安装与使用1. wxauto的安装2. wxauto的简单使用3. wxauto的消息对象 💻四、wxauto结合大模型实现简单的聊天机器人三、完整代码 🧐一、wxauto简介 wxauto 是我在2020年开发的一个基于 UIAutomation 的开源 Python 微信自动化库。Python 初学者也可以简单上手自动化微信操作。目前已实现很多日常的微信操作的自动化，如自动发送消息、自动添加好友、自动回复、自动获取聊天记录、图片、文件等功能，后续还会根据反馈更新更多功能。
wxauto的github链接：https://github.com/cluic/wxauto【点击跳转】
🎯二、wxauto的主要功能 消息发送：支持发送文字、图片、文件、@群好友、引用消息等功能聊天记录：可获取好友的聊天记录内容监听消息：实时获取指定监听好友（群）的新消息其他定制功能：根据需求定制自动化流程，满足各种特殊需求。 📦三、wxauto的安装与使用 1. wxauto的安装 安装 wxauto 非常简单，和其他第三方库一样在命令行输入以下命令即可：
pip install wxauto
pip install wxauto -i https://pypi.tuna.tsinghua.edu.cn/simple （换源安装）
注意： 目前wxauto只支持 Windows 10|11|Server2016+ 系统，苹果等电脑的系统并不支持，Python环境要求 Python：3.7+（不支持3.7.6和3.8.1），注意！！！ Python版本不支持3.7.6和3.8.1，微信版本默认分支为微信3.9.11.17版本，使用前请先检查自己电脑微信是否为该版本，版本不同可能由于UI问题导致某些功能无法正常调用。
注意： 如果你的微信版本可以用的话，也不需要过多纠结这个。
2. wxauto的简单使用 注意： 在运行代码前一定要确保PC微信客户端已经登陆。
【示例1】：基于wxauto发送消息
使用场景：可以重复发送一样的内容达到消息轰炸
from wxauto import * wx = WeChat() content = 'hello world' who = '文件传输助手' for i in range(15): wx.SendMsg(msg=content, who=who) 附带@好友的消息
from wxauto import * wx = WeChat() content = 'hello world' who = '文件传输助手' name = '文件传输助手' wx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb7623bdbf9fcd8e99c7d75947c4d669/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/739195c9281f65919289e942b90a2753/" rel="bookmark">
			Python 爬虫入门（四）：使用 pandas 处理和分析数据 「详细介绍」
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 爬虫入门（四）：使用 pandas 处理和分析数据 「详细介绍」 前言1. pandas简介1.1 什么是pandas?1.2 为什么要使用pandas?1.3 安装 Pandas 2. pandas的核心概念2.1 Series2.2 DataFrame2.3 索引 3. 数据导入和导出3.1 从CSV文件读取数据3.2 从Excel文件读取数据3.3 导出数据到CSV3.4 导出数据到Excel 4. 数据清洗4.1 处理缺失值4.2 删除重复数据4.3 重命名列 5. 数据转换5.1 选择和过滤5.2 排序5.3 分组和聚合5.4 合并数据 6. 时间序列操作6.1 创建日期范围6.2 重采样6.3 移动窗口计算 7. 数据可视化7.1 绘制折线图7.2 绘制柱状图7.3 绘制散点图 8. 高级功能8.1 多层索引8.2 透视表8.3 类别数据 9. 性能优化9.1 使用适当的数据类型9.2 使用迭代器处理大数据集9.3 使用内置的矢量化操作 10. 实战案例：分析爬虫数据10.1 导入数据10.2 数据清洗10.3 数据分析10.4 数据可视化10.5 导出结果 11. 注意事项和最佳实践 总结 前言 欢迎来到"Python 爬虫入门"系列的第四篇文章。在前面的教程中,我们学习了如何抓取网页数据。但是获取数据只是第一步,如何高效地处理和分析这些数据同样重要。这就是我们今天要学习的内容 - 使用pandas库进行数据处理。pandas是Python中最强大的数据分析工具之一。它提供了高性能、易用的数据结构和数据分析工具。不管你是数据科学家、金融分析师,还是网络爬虫开发者,pandas都是一个不可或缺的工具。在这篇文章里,我们会深入探讨pandas的核心概念,学习如何使用pandas处理爬虫获取的数据,以及如何进行数据清洗、转换和分析。即使你是pandas新手,也不用担心,我们会从最基础的知识开始,一步步带你掌握pandas的使用技巧。 1. pandas简介 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/739195c9281f65919289e942b90a2753/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/97/">«</a>
	<span class="pagination__item pagination__item--current">98/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/99/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>