<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de9e9e4d5081d6f5fddb62b434104d98/" rel="bookmark">
			el-table自定义表头样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;el-table ref="multipleTableRef" :data="tableData" style="width: 100%;margin-top: 20px;" @selection-change="handleSelectionChange" height="500px" :header-cell-style="{ 'text-align': 'center', 'background': '#02B980', 'color': '#fff' }" :cell-style="{ 'text-align': 'center' }"&gt; 效果图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d743e3bedd9f20cfe994f80e234805d/" rel="bookmark">
			【栈和队列】常见面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.[有效的括号](https://leetcode.cn/problems/valid-parentheses/description/)1.1 题目要求1.2 利用栈解决 2. [用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/description/)2.1 题目要求2.2 用队列实现栈 3.[用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/description/)3.1 题目要求3.2 用栈实现队列 4.[设计循环队列](https://leetcode.cn/problems/design-circular-queue/description/)4.1 题目要求4.2 设计循环队列 1.有效的括号 1.1 题目要求 判断所给字符串的括号是否有效。
有效的条件：
左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。每个右括号都有一个对应的相同类型的左括号。 1.2 利用栈解决 遍历给定字符串时，当我们遇到左括号时，把它入栈。目的是为了期望在后续的遍历中有一个相同类型的右括号与其匹配。
当我们遍历时遇到的是右括号，此时有3种情况：
1.栈为空，无法匹配返回false。
2.栈不为空，但不是与之匹配的左括号，返回false。
3.栈不为空，是与之匹配的左括号，继续遍历。
在2，3情况下，为了简化书写，我们可以先把栈顶元素出栈，用一个临时变量保存。
如果我们在遍历时都顺利通过，也不能代表这个字符串就是有效的。
比如这种情况：( ( ( ) )
遍历完后，栈中还会剩下(.
为此最后我们还需要判断栈是否为空，不为空返回false，为空返回true。
注意记得销毁栈
typedef struct stack { char* a; int size;//写错了，代表top的意思 int capacity; }stack; void init(stack* ps) { assert(ps); ps-&gt;a = (char*)malloc(sizeof(char)*4); ps-&gt;size = 0; ps-&gt;capacity = 4; } bool empty(stack* ps) { return ps-&gt;size == 0; } void push(stack* ps,char x) { assert(ps); if(ps-&gt;size == ps-&gt;capacity) { char* tmp = (char*)realloc(ps-&gt;a,sizeof(char)*ps-&gt;capacity*2); if(tmp == NULL) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d743e3bedd9f20cfe994f80e234805d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/964093a38b80ed1d6beeac33f4d74248/" rel="bookmark">
			实时数据监控，三防平板在工业领域的应用解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着工业4.0时代的到来，数字化转型已成为各行各业的共同目标。在这一过程中，实时数据监控扮演着至关重要的角色，为企业提供数据驱动的决策支持，提升效率、降低成本、提高安全性。而作为移动终端设备，三防平板凭借其可靠性、稳定性、以及强大的数据处理能力，在工业领域的数据采集、监控、和管理方面发挥着越来越重要的作用。
一、三防平板的优势：工业应用的理想选择 与普通平板电脑相比，三防平板在设计上更加注重耐用性和可靠性，能够适应恶劣的工业环境，并提供更高效的数据处理和传输能力，使其成为工业应用的理想选择。
高可靠性与耐用性：三防平板通常采用坚固的金属外壳和防尘防水设计，能够抵御冲击、振动、高温、低温、以及潮湿等恶劣环境，确保设备的正常运行。
稳定性与安全性：工业级操作系统和硬件配置，以及专业的安全管理功能，保障数据安全和系统稳定性，防止数据丢失或被篡改。强大的数据处理能力：三防平板通常搭载高性能处理器和充足的内存，能够快速高效地处理和分析数据，并支持多种数据格式和连接方式。灵活性和便捷性：三防平板轻便易携，并可配备多种外设，例如条形码扫描器、RFID读写器、蓝牙模块等，满足不同应用场景的需求，方便现场作业人员随时随地进行数据采集和管理。
二、三防平板在工业领域的应用场景分析 三防平板在工业领域的应用场景非常广泛，涵盖生产、物流、仓储、能源、交通等多个领域。以下是几个典型的应用案例：
1.生产制造： 数据采集：利用三防平板配备的摄像头、传感器、以及数据采集软件，可以实时采集生产过程中的数据，例如生产进度、设备运行状态、产品质量等。设备维护：通过三防平板，维护人员可以远程监控设备运行状态，及时发现故障并进行维修，提高设备运行效率和安全性。质量管理：利用三防平板进行产品检验和数据记录，实现实时质量监控，提高产品质量和生产效率。 2.物流仓储： 库存管理：利用三防平板进行货物盘点和出入库管理，实现库存信息的实时更新，提高仓储效率和管理水平。物流配送：利用三防平板进行货物配送信息采集和追踪，实现物流过程的可视化管理，提高配送效率和安全性。 3.能源电力： 电网监控：利用三防平板远程监控电力设备运行状态，及时发现故障并进行处理，提高电网安全性和可靠性。线路巡检：利用三防平板进行线路巡检，记录巡检数据和发现的故障，并进行远程汇报，提高巡检效率和安全。 4.交通运输： 轨道交通：利用三防平板进行车辆运行状态监控、故障报修、以及乘客信息采集等，提高轨道交通安全性和运营效率。公路交通：利用三防平板进行道路巡检、交通事故记录、以及交通拥堵信息采集等，提高道路交通安全性和效率。
三防平板凭借其强大的功能和灵活的应用场景，正在成为工业领域不可或缺的移动终端设备。随着科技的进步和应用场景的不断扩展，三防平板将会在工业数字化转型中发挥更加重要的作用，推动工业生产效率和安全水平的不断提升。
XF
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/887b1bbb424e022e600c98792156d4bc/" rel="bookmark">
			Ubuntu环境安装MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu环境安装MySQL 1. 访问下载界面并下载发布包2. 安装发布包3. 安装MySQL 1. 访问下载界面并下载发布包 下载地址
也可直接去mysql.com官网下载
这里如果要下载其他版本的或可以去http://repo.mysql.com/这个网页查询相关的版本。
2. 安装发布包 使用切换到root用户 su 如果你还没有添加root用户的话，执行下面执行添加root用户
sudo -i 输入以下命令以创建一个root用户的密码：
sudo passwd root 输入两次密码以确认。
创建完密码后，就可以使用以下命令退出root用户并返回到普通用户：
exit 安装rz工具 apt install lrzsz #安装rz⼯具 拖拽上传发布包并查看（也可执行rz命令） sz #执行rz命令 执行安装命令 dpkg -i + 安装包名称 这里我的是 dpkg -i mysql-apt-config_0.8.32-1_all.deb 第一个选项
第二个选项
然后直接点击OK即可。
从MySQL APT 源更新包信息 apt-get update 3. 安装MySQL 安装 指令
apt-get install mysql-server #输⼊安装命令 设置密码
查看MySQL状态 systemctl status mysql #查看mysql服务状态 可以使⽤systemctl [stop|start|restart|status] mysql,命令对MySQL服务进⾏[停⽌|启动|重启|查看服务状态]操作
开启自启动 systemctl enable mysql #设置⾃启动 systemctl list-unit-files|grep mysql #查看状态 登陆MySQL mysql -uroot -p 测试
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/887b1bbb424e022e600c98792156d4bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ea3ae57f624a23dafd359c5576e6198/" rel="bookmark">
			Ansible自动化运维中剧本角色(roles)来完成apache服务操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🏡作者主页：点击！ 🐧Linux基础知识(初学)：点击！
🐧Linux高级管理防护和群集专栏：点击！
🔐Linux中firewalld防火墙：点击！
Ansible自动化运维：点击！
⏰️创作时间：2024年8月8日8点8分
目录
1.编写YAML
2.执行剧本
2.测试结果
4.修改端口号8888
1.编写剧本(角色)
目录介绍
files:
tasks:
handlers:
templates:
编写脚本
总结
在现代IT运维中，自动化已经成为提升效率和降低错误率的关键手段。Ansible作为一种强大的自动化工具，通过剧本（Playbooks）和角色（Roles）使得复杂的配置管理变得简单而高效。本文将探讨如何利用Ansible的角色功能来实现Apache服务的自动化管理。我们将通过定义角色结构、编写剧本以及执行相关操作，展示如何轻松部署和管理Apache Web服务器，从而提高运维工作的灵活性和可维护性。无论是在开发环境还是生产环境，通过Ansible，我们都能实现快速、可靠的服务部署与管理。
以下分开来讲解首先就是 单独的步骤 最后才是使用定义角色目录的方式来完成一整套流程操作
1.编写YAML 实现要求
1.安装apache
2.修改端口号为8080
3.启动apache服务
vim a.yaml --- - hosts: web remote_user: root tasks: - name: install httpd yum: name: httpd state: present tags: - aaa ​ - name: change apache port shell: sed -i 's/Listen 80/Listen 8080/' /etc/httpd/conf/httpd.conf tags: - bbb ​ - name: start apache service: name: httpd state: started enabled: yes tags: - ccc .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ea3ae57f624a23dafd359c5576e6198/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc91eb401d6041ec8421f1ff3ab3020b/" rel="bookmark">
			Java I/O (Input/Output)——文件字节流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博客主页：誓则盟约系列专栏：Java SE 专栏关注博主，后期持续更新系列文章如果有错误感谢请大家批评指出，及时修改感谢大家点赞👍收藏⭐评论✍ Java I/O 简介 Java I/O（输入/输出）是 Java 程序中用于处理数据输入和输出的重要部分。
输入流（Input Streams）：用于从数据源读取数据。常见的输入流包括FileInputStream（从文件读取）、BufferedInputStream（提高读取效率）等。
输出流（Output Streams）：用于将数据写入到目的地。例如FileOutputStream（向文件写入）、BufferedOutputStream（提高写入效率）。
字符流（Reader 和 Writer）：处理字符数据，更适合处理文本。如FileReader和FileWriter。
缓冲流（Buffered Streams）：通过缓冲区来减少实际的 I/O 操作次数，提高性能。
对象流（Object Streams）：用于实现对象的序列化和反序列化，如ObjectInputStream和ObjectOutputStream。
在实际编程中，根据具体的需求选择合适的 I/O 流可以提高程序的效率和可读性。
计算机总线结构： 那么为什么会有I/O呢？其实I/O无时无刻不在我们身边，比如读取硬盘上的文件，网络文件的传输，鼠标键盘输入，也可以是接受单片机发回的数据，而能够支持这些操作的设备就是I/O设备。
我们可以大致看一下整个计算机的总线结构：
最核心的是CPU，CPU像计算机的大脑一样，是计算机的核心部件，几乎所有的计算都是靠这个CPU来进行的，CPU懂的比较多，它可以对各种类型进行计算，但是随着时代的发展对图形的要求越来越高，CPU就略显乏力；于是就出现了GPU(显卡)，显卡就是专门对于图形进行计算。
通过北桥芯片连接到内存，这样CPU就可以对内存进行操作；南桥芯片是用于读取U盘或者硬盘内的数据 。
常见的I/O设备一般是鼠标、键盘这类通过USB进行传输的外设或者是通过Sata接口或是M.2连接的硬盘。一般情况下，这些设备是由CPU发出指令通过南桥芯片间接进行控制，而不是由CPU直接操作。
而我们在程序中，想要读取这些外部连接的!O设备中的内容，就需要将数据传输到内存中。而需要实现这样的操作，单单凭借一个小的程序是无法做到的，而操作系统(如:Windows/inux/MacOS)就是专门用于控制和管理计算机硬件和软件资源的软件，我们需要读取一个IO设备的内容时，就可以向操作系统发出请求，由操作系统帮助我们来和底层的硬件交互以完成我们的读取/写入请求。
JDK提供了一套用于IO操作的框架，为了方便我们开发者使用，就定义了一个像水流一样，根据流的传输方向和读取单位，分为字节流InputStream和OutputStream以及字符流Reader和Writer的IO框架，当然，这里的流指的是数据流，通过流，我们就可以一直从流中读取数据，直到读取到尽头，或是不断向其中写入数据，直到我们写入完成，而这类IO就是我们所说的BIO。
文件字节流： 字节流一次读取一个字节，也就是一个 byte 的大小，而字符流顾名思义，就是一次读取一个字符，也就是一个 char 的大小(在读取纯文本文件的时候更加适合)。
文件输入流： 在 Java 中，文件输入流（FileInputStream）用于从文件中读取数据。FileInputStream 允许程序以字节为单位读取文件的内容。
创建方式：
通常通过指定要读取的文件路径来创建文件输入流对象。例如：
try { FileInputStream fis = new FileInputStream("your_file_path"); // 后续的读取操作 } catch (FileNotFoundException e) { e.printStackTrace(); } 但是这种方式需要处理各种可能的异常，比如 FileNotFoundException 异常和 IOException 异常，并且需要手动关闭文件，完整代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc91eb401d6041ec8421f1ff3ab3020b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcc9fdcae7d97ee68ca17f51492339f7/" rel="bookmark">
			Python &#43; Playwright（1）：Page 页面操作[详细介绍]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python + Playwright（1）：Page 页面操作[详细介绍] Page概述Page类的API类别1. 导航和页面操作API2. 页面元素定位和交互API3. 页面内容获取API4. 页面事件和等待API5. JavaScript 执行和脚本处理API6. 网络请求和拦截处理API7. 期待特定事件或条件发生API8. 其他操作API Page概述 Playwright 提供了丰富的页面操作功能，通过 page 对象可以实现对网页的导航、元素定位、交互、页面事件监测等操作。
Page 对象是 Playwright 中表示页面的核心对象，它允许我们控制和操作浏览器中的页面。
Page类的API类别 Page类的常用方法包括的API类别如下：
导航和页面操作API：控制浏览器的导航行为，如 goto 跳转到新页面，reload 重新加载当前页面，go_back 和 go_forward 在历史记录中前进和后退。
页面元素定位和交互API：提供了 click、fill、type 等方法，模拟用户与页面元素的交互，以及 locator 用于通过 CSS 选择器、XPath 等定位页面元素。
页面内容获取API：通过 content 获取页面的 HTML 内容，title 获取页面标题，screenshot 进行页面截图，以及 pdf 生成页面的 PDF。
页面事件和等待API：使用 wait_for_event 等待页面上的特定事件，wait_for_load_state 等待页面加载到特定状态，以及 expect_event 期待事件的发生。
JavaScript 执行和脚本处理API：evaluate 在页面上下文中执行 JavaScript 并获取结果，evaluate_handle 执行脚本并返回一个 JSHandle 对象，允许进一步操作。
网络请求和拦截处理API：route 拦截网络请求，unroute 取消拦截，以及 request、response 和 websocket 相关的 API 来处理网络交互。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcc9fdcae7d97ee68ca17f51492339f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e113ff0f98e9cd45aae09f749015479/" rel="bookmark">
			2024年最新MacBook苹果电脑安装JDK8、JDK11、JDK17、JDK22教程，配置环境变量 &#43; 快速切换JDK版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本帖发布日期：2024年01月26日，全网最新教程整理。
2024年02月01日更新：环境变量新增jdk17配置代码。
2024年05月13日更新：记录解决添加maven后不能自动切换jdk版本。
2024年06月16日更新：友情提醒：如果是m芯片，推荐下载arm版本。
2024年08月08日更新：新增JDK22版本安装。
在这里我要说一下，本帖所有内容本人亲手操作百分百成功。教程是提供方式方法教怎么做，个人觉得并不适合傻瓜式伸手党，看评论区看的心累，本帖从此永不更新。 1、概述 本文主要为在MacBook苹果电脑系统下安装JDK及环境变量配置。
教程摘抄自互联网，本人作为更新+整理+亲测。（也算给自己记录一贴）
本帖分为四步：
在Oracle官网下载JDK安装JDk配置环境变量快速切换 JDK是Java开发工具包（Java Development Kit）。
JDK 8 版本于2014年3月18日发布。引入了一系列新功能，如Lambda表达式、函数式接口、Stream API和新的日期/时间API等。JDK 11 版本于2018年9月25日发布。提供了一些重要的改进，如模块化系统、增强的性能、新的HTTP客户端API和局部变量类型推断等。JDK 17 版本于2021年9月14日发布，是Oracle官方长期支持（LTS）版本，提供了一些性能优化、安全性改进、API 更新等方面的调整，以提高 Java 平台的稳定性和可靠性。 JavaSE、JavaEE和JavaME是Java平台的不同配置和规范。
JavaSE（Java Standard Edition）是Java平台的标准配置，提供了基本的Java编程环境和核心API，适用于通用的桌面、服务器和嵌入式应用程序开发。JavaEE（Java Enterprise Edition）是Java平台的企业级配置，提供了用于开发大型企业应用程序的扩展API和服务，包括Web应用程序开发、企业级数据库访问、消息队列和分布式计算等。JavaME（Java Micro Edition）是Java平台的微型配置，专门用于嵌入式设备和移动设备的应用程序开发，如手机、智能卡和小型传感器等。 Installer和Compressed Archive区别：
Installer下载的是一个.dmg可执行文档。
Compressed Archive压缩文档，下载的是一个.tar.gz压缩包。
另外，刚接触Mac的小伙伴你需要知道：
DMG文件通常用作Mac应用程序的安装包。是苹果电脑上常见的磁盘映像文件格式，全称为Disk Image。
2、下载JDK（官网） 2.1、官网下载dmg安装包 Java Archive | Oracle
​​​​​​Java Archive | Oracle 中国
选择需要安装的jdk版本，我需要的是JDK8版本，这里我选择Java SE 8 (8u211 and later)，点击进入下载页面。
2.2、根据对应系统选择下载安装包 我是Intel Core i9芯片，选择的是 macOS x64 DMG Installer 点击下载后面的dmg文件
这里友情提示：有时候网络延迟，可能不会立即响应下载，需要耐心等一会，或者刷新页面重复下载。
，弹出对话框 选择勾选同意协议即可。 注意：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e113ff0f98e9cd45aae09f749015479/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e937ce9e0ea594198692abb9fcf3ea67/" rel="bookmark">
			设计模式之观察者模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在软件开发中，设计模式为我们提供了一种可重用的解决方案，用以解决常见的设计问题。观察者模式（Observer Pattern）是其中一种，它定义了一种一对多的依赖关系，使得一个对象状态的改变能够自动通知并更新其他依赖对象。这种模式在事件驱动系统中尤为常见，如 GUI 应用程序和实时数据处理系统。
观察者模式的定义 观察者模式，也称为发布-订阅模式（Publish-Subscribe Pattern），主要由以下几个核心组件组成：
Subject（主题）：
主题是被观察的对象，它维护了一个观察者列表，并提供方法以供观察者注册和取消注册。当主题的状态发生变化时，它会通知所有已注册的观察者。 Observer（观察者）：
观察者是需要对主题的变化做出反应的对象。每个观察者都实现了一个更新接口，当主题状态变化时，主题会调用观察者的更新方法。 组件和工作原理 观察者模式的关键在于松耦合。主题和观察者之间的依赖是最小化的，主题只需要知道观察者实现了一个特定的接口即可，不需要了解具体的观察者实现。以下是观察者模式的工作原理：
主题类（Subject）： class Subject: def __init__(self): self._observers = [] def attach(self, observer): self._observers.append(observer) def detach(self, observer): self._observers.remove(observer) def notify(self): for observer in self._observers: observer.update(self) # 主题状态的变化 def change_state(self, state): self._state = state self.notify() def get_state(self): return self._state 观察者接口（Observer）： class Observer: def update(self, subject): pass 具体观察者类（ConcreteObserver）： class ConcreteObserver(Observer): def update(self, subject): print(f"Observer: Subject's state is now {subject.get_state()}") 代码示例 以下是一个简单的代码示例，展示了观察者模式的应用：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e937ce9e0ea594198692abb9fcf3ea67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ec01f0c3fc4a6532b4464ef7dabc3f9/" rel="bookmark">
			为啥https比http慢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Https有ssl的握手 HTTP没有
HTTPS TCP 和HTTP 的TCP 时间差不是很大
HTTPS请求中,ssl所占的时间比例是请求时间总和93.37%,
HTTPS请求中,ssl的请求会是tcp请求的14倍,而HTTP中没有这个问题
建议:对安全要求不是很高的,不要使用https请求
图例
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/562e8b32107dcd80fc00b6883045fbe2/" rel="bookmark">
			视频循环存储的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 三方工具
2. 视频存储的实现 2.1 分段存储 - 比如每15分钟
2.2 对齐到15分钟整边界
2.3 循环存储的实现 video_space_daemon.sh
3.封装
3.1 主执行程序，修订版
3.2 创建服务 3.3 service关联的执行脚本文件
4.额外的工作
附录A: ffmpeg视频存储，运行时错误处理 1.运行ffmpeg存储视频时
1.1 处理
附录B 服务创建加载以及运行时异常处理 1.service无法enable
1.1 处理
1. 三方工具 建议使用ffmpeg，这个工具多平台可用，命令行和API都有提供，非常便捷。下载的位置：
Download FFmpeg
我工作在debian环境，下载对应的源码后编译：
./configure
make
make install
2. 视频存储的实现 2.1 分段存储 - 比如每15分钟 下面的脚本里 MIN_PER_FILE控制的是每个视频文件的最大尺寸
#usage: video_recorder &lt;video_file_path&gt; &lt;min_per_file&gt; &lt;rtsp_path&gt; RTSP_URL_WITH_PASSWORD='rtsp://admin:xxxx@192.168.0.6:554/Streaming/Channels/101?transportmode=unicast&amp;amp;profile=Profile_1' MIN_PER_FILE=03 VIDEO_FILE_PATH='/tmp/video/' #include postfix mkdir -p $VIDEO_FILE_PATH ffmpeg -rtsp_transport tcp -i $RTSP_URL_WITH_PASSWORD -c:v libx265 -preset fast -crf 28 -t 00:$MIN_PER_FILE:00 $VIDEO_FILE_PATH$(date +"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/562e8b32107dcd80fc00b6883045fbe2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2b4dc956fbfb6524cd37104b5ffa8dc/" rel="bookmark">
			SpringBoot教程（十四） | SpringBoot之集成Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot教程（十四） | SpringBoot之集成Redis 一、Redis集成简介二、集成步骤2.1 添加依赖2.2 添加配置2.3 项目中使用 三、工具类封装四、序列化 （正常都需要自定义序列化）五、分布式锁（一）RedisTemplate 去实现场景一：单体应用场景二：分布式架构部署 （二） Redisson去实现 总结 一、Redis集成简介 Redis是我们Java开发中，使用频次非常高的一个nosql数据库，数据以key-value键值对的形式存储在内存中。redis的常用使用场景，可以做缓存，分布式锁，自增序列等，使用redis的方式和我们使用数据库的方式差不多，首先我们要在自己的本机电脑或者服务器上安装一个redis的服务器，通过我们的java客户端在程序中进行集成，然后通过客户端完成对redis的增删改查操作。
redis的Java客户端类型还是很多的，常见的有jedis, redission,lettuce等，
所以我们在集成的时候，我们可以选择直接集成这些原生客户端。
但是在springBoot中更常见的方式是集成spring-data-redis，这是spring提供的一个专门用来操作redis的项目，封装了对redis的常用操作，里边主要封装了jedis和lettuce两个客户端。相当于是在他们的基础上加了一层门面。
二、集成步骤 2.1 添加依赖 添加redis所需依赖：（在 Spring Boot 2.x及以后的版本中，spring-boot-starter-data-redis 默认使用的就是lettuce这个客户端）
&lt;!-- 集成redis依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 完整pom.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.lsqingfeng.springboot&lt;/groupId&gt; &lt;artifactId&gt;springboot-learning&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2b4dc956fbfb6524cd37104b5ffa8dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a3b3f5de9fb4dd156e892a54af660ef/" rel="bookmark">
			京东小程序数据中心架构设计与最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、京东小程序是什么 京东小程序平台能够提供开放、安全的产品，成为品牌开发者链接京东内部核心产品的桥梁，致力于服务每一个信任我们的外部开发者，为不同开发能力的品牌商家提供合适的服务和产品，让技术开放成为品牌的新机会。“Once Build, Run Anywhere”，一个小程序可以在多个APP运行，引擎层抹平差异，一套代码，相同页面，云端下发，多端运行。
﻿
﻿﻿
可能大家还不太了解我们的京东小程序，京东小程序到底是什么呢？它和微信小程序有什么区别？首先呢，需要明确的是，京东小程序不是运行在微信端的京东商城购物小程序，而是运行在京东APP的，基于京东小程序引擎的一套京东系的小程序。
它是和支付宝小程序或者微信小程序对标的一类京东化的小程序。
举个例子，大家可以体验一下，比如在主站搜索宝格丽，会通过搜索直达直接跳转到宝格丽小程序上，我们可以在这里购买奢侈品，或者在首页的同城Tab页下，可以浏览到非常多的到家门店类的小程序，总之，京东小程序所覆盖的业务还是极其广泛的！
当然，京东小程序不仅仅可以运行在京东APP上，只要宿主在运行时依赖了我们的小程序SDK引擎，就可以实现在各类其他宿主APP上的运行，譬如，在京东小家APP上，可以通过小程序去控制智能IOT设备，在京ME的APP上，可以远程操作打印机，实现一键打印。小程序作为一种轻量级的即用即走的工具，用户群体广泛，早已覆盖到了我们生活的方方面面。
京东小程序是链接商家和京东内部核心产品的重要桥梁，也是助力商家实现流量增长、业务发展的一个重要方式。
那么，小程序平台是怎么保证商家业务的稳定、健康发展，服务好这些外部商家的呢？这里面非常重要的是我们平台对小程序基本流量的运营与监控。如何不让业务的小程序在线上裸奔？如何帮助业务对自身小程序流量的冲高回落有一种直观的把握和监测？如何基于海量数据指导业务去进行一个精细化的运营？实际上，京东小程序数据中心就扮演了一个这样的小程序数据问题终结者的角色，充分利用各类数据手段，解决这些痛点问题。
二、京东小程序数据中心建设里程碑 ﻿
﻿﻿
京东小程序数据中心的建设，主要经历了四个阶段，从最开始的由0到1搭建了数据基础能力，到丰富拓展各类数据指标，接着下钻分析到用户，帮助商家实现基于用户的精细化的运营，到目前的小程序数智化建设，在整个小程序的迭代建设的过程中，都从各个维度为小程序的业务发展实现了保驾护航。
三、京东小程序数据中心业务全景图 ﻿
﻿﻿
•从功能角度，京东小程序运营数据分析，京东小程序监控数据分析；
•从展现角度，开发者控制台，管理后台，移动端小程序助手，宙斯开放能力；
•从功能领域角度，用户行为分析，交易链路数据分析，用户画像，流失率监控，流量监控等；
•从上报通道角度，子午线，自定义上报，服务端埋点；
•从数据存储角度，JED，JimDB，ES，HBase等；
目前京东小程序数据中心功能范围广泛，我们在根据业务发展的需求，不断完善整个京东小程序数据中心的功能架构。
从展现角度看，包括开发者控制台，管理后台，移动端小程序助手，实时数据大屏, 开放openApi能力；
其次是从功能领域角度看，主要包括运营数据分析，监控数据分析。
运营数据分析，包括用户行为分析，比如小程序基础的pv和uv；
来源分析，可以去分析小程序在各个广告投放渠道下的营销转化效果；
用户画像分析，可以分析到浏览过小程序的人群中的哪些是高净值用户群体，以及性别以及年龄等基础的用户画像数据。
监控数据分析，主要是针对线上运行的小程序的奔溃异常，网络请求异常，启动性能数据的分析，用户流失率的实时监测等，可以在小程序出现异常时第一时间通知到开发者。
﻿
﻿﻿
四、京东小程序数据中心技术架构图 ﻿
﻿﻿
对于整体的架构设计，其实在我看来，数据的分析，主要是解决三个问题，第一个要解决的是数据如何上报的问题，第二个是解决数据如何存储的问题？第三个才是解决数据如何分析的问题？
1、京东小程序数据中心的数据上报主要包括三个途径，主要包括客户端埋点，服务端埋点或者其他外部的数据源，客户端埋点主要利用的是子午线，服务端埋点主要是我们服务之间采集数据，服务之间消费和同步。
2、数据存到哪里去，这个需要基于我们业务上对这些数据的实时性要求，判断是实时还是离线，进而采用不同的数据源进行存储，数据指标是要秒级的？分钟级的？还是T+1l类型的，实时性要求不同，那么存储的数据源自然也就不同。
3、数据如何分析，实际上就是我们的业务逻辑，在设计时也需要充分考虑数据模型的复用性和可拓展性。
小程序数据中心对于来自子午线客户端埋点数据，以离线的方式构建小程序自己的业务数仓，一层一层地进行数据的降噪，清洗和计算，将聚合好的维度数据再推送到关系型数据库，方便业务快速接入。对于来自自建通道的实时数据以及外部系统的埋点数据，通过统一上报服务将数据上报到消息队列，进行流量数据的异步处理和消峰，采用专门的消费者服务对上报数据进行消费落库，存储到ES和HBase数据库，便于平台进行多维度的明细或者汇总数据查询；同时，也会基于Flink对消息队列中的数据进行流式实时计算，实现异常波动流量的告警和分析。
五、它山之石可以攻玉，借助集团数据工具打造小程序业务数仓 痛点问题：
1.京东小程序的数据来源多样化，数据量级庞大，如何立足业务数据，发挥数据价值，帮助商家实现精细化的运营？
2.如何复用主站已有的数据模型和能力，让更多的小程序商家参与到京东主站的流量场，让数据驱动商家精准营销？
3.业务指标纷繁复杂，如何沉淀和抽离通用数据模型，减少重复工作？
如何解决：
基于集团BDP平台，自上而下构建京东小程序的业务数仓，借助BDP平台丰富的数据产品工具，多维度地构建小程序的数据能力。离线计算+实时计算相结合，小程序业务数据+集团模型数据相结合。
1.数据分类化，将小程序流量进行主题划分，拆分为点击、浏览、曝光、订单等大维度的主题模型，方便数据定位，增加业务理解；
2.数据分层化，同一个流量主题下，进一步按照ODS-&gt;DWD-&gt;DWS-&gt;ADS的层级结构进行分层，方便追踪数据血缘，减少重复数据模型的开发；
3.数据多元化，下游系统可从小程序数据仓库拉取符合业务需要的领域数据，比如数纺，搜推广等系统，利用下游系统成熟稳定的数据能力，为商家营销充分赋能；
﻿
﻿
﻿﻿
﻿
﻿﻿
﻿
﻿﻿
在京东小程序的业务数仓搭建过程中，主要还是应用了集团BDP大数据平台提供的丰富的产品工具和通用能力。
几种典型的使用案例是：
1、离线hive表数据同步到jed等关系型业务库，使用buffalo任务中的出库算子；
2、业务产生的实时MQ数据同步到hive数仓，使用DTS，实时数据传输任务，可以把业务数据同步到数仓；
3、我们需要在数仓中构建业务维表，比如构建小程序基本信息的维表，业务数据需要同步到hive表，可以采用数据直通车DataBus，在表记录的生成上，可以根据业务的需要，采用全量表，增量表，快照表，拉链表或者流水表的不同的记录生成方式。
京东小程序客户端埋点统一上报的子午线，需要从最原始的gdm层底表提取小程序自己的业务数据，原始底表数据量级非常大，不可能每次直接对原始底表查询，这样的话耗费计算资源，效率较低。所以，我们尽量提高底层数据模型的复用度，对数据进行分类化和分层化处理。
所谓分类话，就是将小程序流量进行主题划分，拆分为点击、浏览、曝光、订单等大维度的主题模型，方便数据定位，增加业务理解；
所谓分层化，就是在同一个流量主题下，进一步按照ODS-&gt;DWD-&gt;DWS-&gt;ADS的层级结构进行数据分层，方便追踪数据血缘，减少重复数据模型的开发。
所谓多元化，就是复用度，加工好的这些数据，可以给下游的团队接入使用，比如商智，黄金眼，数纺这些团队。以小程序广告投放为例，在小程序数仓中我们构建了各个类型的用户群体，在数纺注册了用户群体标签，比如关注用户，粉丝用户或者提单用户等，下游的广告精准通系统会基于我们的这些标签进行人群的圈选，进而实现小程序广告的投放。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a3b3f5de9fb4dd156e892a54af660ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6e75ad29f8d57d4ad3ff1c86294b043/" rel="bookmark">
			【工具测评】腾讯云 AI 代码助手——你的下一位编码“伙伴”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引言一、VS Code下安装腾讯云 AI 代码助手插件二、腾讯云AI代码助手使用实例2.1 通过对话生成代码2.2 通过注释生成代码2.3 规范、修复代码错误2.4 人工智能技术对话，有求必应2.5 智能代码分析，快速上手历史代码 三、获得的帮助与提升四、建议五、结语 引言 今天为大家测评的是 腾讯云 AI 代码助手，它是由腾讯云自主研发的一款用于提升开发编程效率的辅助工具。开发者可以通过插件的方式将 AI 代码助手安装到编辑器中辅助自己完成开发工作。目前该插件已在 VS Code 和 JetBrians 系列的 IDE 中上架。AI 代码助手可以为您提供：代码补全、修复错误代码、解释既有代码、生成单元测试、根据注释自动生成代码、技术对话 等功能（小 Tips：不限制任何类型的语言哦！）。下面，我将从插件的安装开始，向大家展示 腾讯云 AI 代码助手 的优点以及“食用”方法。
一、VS Code下安装腾讯云 AI 代码助手插件 我会在 Visual Studio Code 上向大家演示腾讯云 AI 代码助手的使用。VS Code 是一款免费、开源的代码编辑器，支持多种编程语言，包括但不限于JavaScript、Python、Java、C++、Go、PHP、Ruby等，通过安装相应的扩展，可以获得更好的语言支持。
第一步：打开 Visual Studio Code，在左侧导航上点击扩展 第二步：在插件市场中搜索框中输入“腾讯云 AI 代码助手”，并搜索 第三步：点击安装 安装成功后，左侧的导航栏会多出一个对话按钮，这就是 腾讯云 AI 对话助手，如下图所示：
二、腾讯云AI代码助手使用实例 2.1 通过对话生成代码 如上图所示，我们可以在对话框中输入想要生成的代码，这里我让 腾云 AI 代码助手 （后文简称“小助手”）帮我生成了一份用 C++ 语言编写的快排代码，可以看出来，“小助手”的反映非常快，蹭蹭蹭就将代码生成了出来，对于生成的代码，我们可以选择复制，也可以一键将其导入当前的文件，亦或是导入一个新的文件中，甚至还可以直接拷贝至终端。最终从运行结果来看，“小助手”写的这个快排代码是完全正确的，没有任何毛病。
2.2 通过注释生成代码 除了通过对话框生成代码外，“小助手”还可以直接通过你写的 注释 来生成对应的代码，是的，你没听错，什么？不相信？下面把时间交给“小助手”，各位看官准备好你们的掌声。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6e75ad29f8d57d4ad3ff1c86294b043/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a27a3607feef1a9da6741dcbbfadf29/" rel="bookmark">
			Google Mock 和 Google Test编写单元测试入门（环境配置、简单执行）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 环境的配置方法1：从源代码构建第一步：克隆库的源代码第二步：构建库 方法 2：使用 CMake 的 `FetchContent`示例 CMakeLists.txt 项目的创建项目结构CMakeLists.txt (根目录)main.cpp (示例程序)tests/CMakeLists.txt (测试部分)tests/MyClassTest.cpp (示例测试)终端命令添加一个测试用例注意事项 环境的配置 Google Mock 和 Google Test环境配置
方法1：从源代码构建 第一步：克隆库的源代码 你可以使用 git 来克隆 gTest 和 gMock 的代码：
git clone https://github.com/google/googletest.git 第二步：构建库 进入 googletest 目录：
cd googletest 创建构建目录并构建：
mkdir build cd build cmake .. make 安装：
如果你希望将库安装到系统目录，可以使用：
sudo make install 要安装 Google Mock（gMock）和 Google Test（gTest）库，你可以通过几种方法进行，下面将介绍常用的两种方法：使用包管理器和从源代码构建。
方法 2：使用 CMake 的 FetchContent 如果不想手动安装库，可以在 CMake 项目的 CMakeLists.txt 中使用 FetchContent 来自动下载并构建 gTest 和 gMock。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a27a3607feef1a9da6741dcbbfadf29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/423e3435800e05199a11fa03d816d594/" rel="bookmark">
			“百里挑一”AI原生应用亮相，百度智能云千帆AI加速器首个Demo Day来了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者主页： 七七的个人主页
文章收录专栏： 七七的闲谈
欢迎大家点赞 👍 收藏 ⭐ 加关注哦！💖💖
自动化、智能化的企业AI智能法务，私人专属的健康孪生体，打破求职信息差的AI职业规划助理，准确、高效、可靠的AI产业顾问……
日前，百度智能云AI加速器首个Demo Day活动在北京成功举办。从第一期、第二期AI加速器入营企业的100+项目脱颖而出的10个AI原生应用项目登上演讲台，展示在法律、医疗、招聘等方向的探索成果。本次活动由百度智能云联合非凡资本主办，特别邀请百度战投、联想之星、考拉基金、德物资本、汉能创投、御乾天使等国内众多投资机构和创投媒体担任专业观察团。
百度创始人、董事长兼首席执行官李彦宏曾提出，中国的大模型很多，但是基于大模型开发出来的 AI 原生应用却非常少。AI 原生时代，我们需要 100 万量级的 AI 原生应用，但是不需要 100 个大模型。
为了推动大模型技术的普及和应用，实现大模型时代的生态繁荣。今年3月百度智能云推出一站式的企业级大模型平台“百度智能云千帆大模型平台”，并在8月31日向企业客户全面开放文心一言服务。9月百度智能云推出千帆AI加速器，为企业提供技术赋能、技术资源支持、牵引投资和营销支持。目前，千帆AI加速器已经开营四期，100+家企业参加训练，学员中70%以上为企业的创始人或CXO。
百度智能云千帆AI加速器首个Demo Day，“百里挑一”的创新项目有哪些？他们如何推动产业技术革新和解决实际问题？让我们一起了解。
“AI智能法务"平台 北京慧云数智科技有限公司
法大慧云人工智能法律服务平台融合了中国政法大学专家智库资源，利用AI技术，实现了自动化和智能化的法律事务处理，如合同审查、法律咨询等，大幅提升了工作效率。该平台可智能问答、自动生成法律文书，解决中小企业日常运营中的法律问题，节省人力和时间成本，为企业提供有力支持。
医疗数字化Agent 元场科技（北京）有限公司
元场科技公司主打产品是医疗数字化Agent，有望降低医院和医疗监管机构的科研/运营/临床/管理等成本到之前的10%，约有百亿级别的市场规模。未来希望扩展到医疗数据要素Agent和个人健康助理Agent，分别对应千亿和万亿的市场规模。
AI降临派 人格AI引擎 Bit Knight Pty Ltd
通过情绪感知、记忆调度、欲望模型，实现AI人格化。这三个模型（强化学习模型）组成战略网络，配合lIms作为战术网络，赋予Al灵魂。公司产品是to B的API接口，目前商业客户包括数字人、情感陪伴、npc智能化、智能销售等领域，已实现不错的商业营收。
医者•AI 北京医者信息科技有限责任公司
北京医者信息科技有限责任公司，由清华计算机博士、医学博士及连续创业者等组成。团队自研700亿参数MoE架构大模型，赋能“大健康”赛道公司，包括健康垂直行业专项模型训练、应用级健康AI Agents产品、用户个人数字健康孪生体等，为消费者提供7*24小时健康管理服务。
烯牛数据 上海烯牛信息技术有限公司
烯牛科创Al是基于大模型构建的烯牛智慧体，打造了烯牛全新的科创金融问答助手，将大模型的语言能力与我们的实时科创金融数据进行了结合，在科创金融细分领域，可以达到更好的问答效果，大幅降低了使用数据的门槛，同时拓宽了更多B端与C端用户，为科创金融从业者提供全新的数据查询及工作体验——软件交互的改变、使用效率的提升、辅助决策成为可能。
人机协同创智流水线工厂 北京烽火万家科技有限公司
AI工具和AIGC大模型驱动的人机协同创智流水线工厂以百度文心大模型为引擎底座，开发整合了基于大模型的AIGC工具链，能迅速培训Al应用工程师，以流水线迭代开发满足市场订单。工具链涵盖：领域知识库增强的聊天机器人，自适应智能问答、定制数字人、定制语音、文生图、文生视频以及语音会议纪要总结，致力于高效快速的数字产品生成。
知潜AI 上海知潜科技有限公司
定位于下一代AI 原生的职业规划助理，旨在基于专业的职业规划和岗位匹配 pipeline，结合百度千帆大模型平台和文心大模型4.0的能力，为每一个未来的社会生产力人才提供职业方向探索，求职信息差补齐，最优岗位匹配以及职业辅导方案生成等全流程服务。B端产品-梧桐流程管理后台及C端产品-知潜小程序、招聘品牌-知潜。目前，知潜正在开发AI NATIVE的应用产品，持续让AI赋能B、C两端产品（B：AI招聘助理、C：AI求职助理）。
敏行AI经营诊断平台 广东敏行数据有限公司
敏行AI经营诊断平台致力于为企业打造一套量化指标数据分析体系，为客户提供科学的决策依据。平台为企业提供一整套全面的指标数据以及衡量其各指标的完成情况。
通过敏行AI经营诊断平台，可以快速、低成本的帮助企业构建自己专属的指标库，使其和实际运营保持高度一致，从而帮助企业在经营管理过程中可以获得更加精准、快速、有效的数据支撑，更好地把握市场机遇、提升经营效益和管理效率。
云合•AI产业顾问 厦门市合趣信息科技有限公司
云合•AI产业顾问是一款基于大语言模型技术及产业大数据的AI效率工具，面向全国500万产业招商人员及更广泛的产业办公人群提供准确、高效、可靠的产业分析、数字招商及辅助办公服务，并支持政企私有化数据训练和功能定制。
AI智能薪酬分析 江西用友薪酬数字科技有限公司
用友薪酬数科是用友公司孵化企业，专注于为企业提供薪酬和人力资源管理解决方案。用上亿张工资表打造行业领先的薪酬AI模型，帮助企业更好地做出经决策。为企业提供专业的的智能薪酬数据服务，帮助企业洞察人力成本，提高组织人效。
Demo Day现场，台上企业创新者们用生动的案例和富有感染力的演讲，展示了他们基于大模型开发的产品及服务。台下来自投资机构和创投媒体组成的专业观察团，针对项目的发展方向、盈利模式、产品推广等进行深入剖析和精彩点评，为企业提供了全新的视角和宝贵的建议。
活动最后，百度智能云产业发展部总经理段永华为10家企业颁发了百度智能云千帆AI加速器结营证书。同时，厦门合趣智能开发的“云合·AI产业顾问”项目荣获百度智能云特别评选的“百里挑一”奖，给予10000元百度智能云千帆平台代金券支持。
非凡资本合伙人吴畏在活动致辞中谈到，生成式AI正在全球范围内引起革命性的变化，大模型将改变每个人的生活和工作方式，也将改变每个企业的组织形态和工作流。百度智能云加速器提供了一个极具价值的平台，它不仅加速了AI项目的发展，更为创新理念的孵化提供了肥沃的土壤。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/423e3435800e05199a11fa03d816d594/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a739ccc609fac9123f5c8a4d1a88dea5/" rel="bookmark">
			H5内嵌到APP-实现PDF浏览功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载插件
npm install vue-pdf-embed vue3-pdfjs vue3-pdfjs：获取PDF文件总页数
2、页面引入并使用
&lt;template&gt; &lt;div class="vuePdfEmbed"&gt; &lt;div class="wraper" v-if="flagCover"&gt; &lt;div class="articleTitle"&gt; {{ reportDetail.title }} &lt;/div&gt; &lt;div class="articleTagBox"&gt; &lt;div&gt;{{ reportDetail.createTime }}&lt;/div&gt; &lt;/div&gt; &lt;div class="articleDetailCover"&gt; &lt;el-image :src="reportDetail.cover" alt="" lazy class="articleDetailCoverImg" /&gt; &lt;/div&gt; &lt;div class="articleIntroduce"&gt; {{ reportDetail.summary }} &lt;/div&gt; &lt;/div&gt; &lt;VuePdfEmbed :source="state.source" :style="scaleFun" class="vue-pdf-embed" :page="state.pageNum" lazy /&gt; &lt;div class="page-tool" v-if="!bottomVisible"&gt; &lt;div class="page-tool-item" @click="lastPage"&gt;上一页&lt;/div&gt; &lt;div class="page-tool-item"&gt;{{ state.pageNum }}/{{ state.numPages }}&lt;/div&gt; &lt;div class="page-tool-item" @click="nextPage"&gt;下一页&lt;/div&gt; &lt;/div&gt; &lt;!-- 购买提示 --&gt; &lt;div class="bottomVisible" v-if="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a739ccc609fac9123f5c8a4d1a88dea5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73a25758de1d2e37234008e498d2645f/" rel="bookmark">
			决策树算法:原理及实例应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是决策树算法? 决策树算法是一种监督式机器学习算法,它通过构建一个树状的决策模型来进行分类和预测。
决策树由节点(node)和边(branch)组成,每个内部节点代表一个特征属性的测试,每个分支代表一个测试输出,每个叶节点代表一个分类结果。
二、工作原理 决策树（Decision
Tree）是一种常用的机器学习算法，用于分类和回归任务。它通过一系列的规则对数据进行分割，最终形成一个树状结构，其中每个内部节点表示一个特征或属性，每个分支代表一个特征的取值，每个叶节点代表一种类别（分类问题）或一个数值（回归问题）。
下面是决策树算法的工作原理：
1. 特征选择 信息增益（ID3算法）、信息增益比（C4.5算法）、**基尼不纯度（CART算法）**等是常用的特征选择标准。算法会根据选择的标准找出最佳的特征来进行数据集的划分。 2. 决策树的生成 递归地选择最优特征，根据这一特征对数据集进行划分，直到满足停止条件（如节点中的样本数小于某个阈值、树的深度达到设定值等）为止。这个过程可以看作是一个递归地选择最优特征进行划分的过程。 3. 决策树的剪枝 决策树生成过程中可能会出现过拟合（Overfitting）的问题，为了避免过拟合，需要对生成的决策树进行剪枝。常见的剪枝策略有预剪枝和后剪枝两种。 4. 决策树的预测 当新样本进入决策树时，根据每个节点的特征属性进行判断，最终到达叶节点并得到分类或回归结果。这个过程就是使用决策树进行预测的过程。 三、算法优点 总的来说，决策树算法具有易于理解、可解释性强、适用于各种数据类型、高效、鲁棒性好等优点，使其在许多领域得到广泛应用。然而，决策树算法也有一些缺点，如容易过拟合、对噪声数据敏感等，因此在实际应用中需要根据具体情况进行适当调参和优化。
1. 易于理解和解释 决策树可以直观地呈现数据的分类过程，类似于人类的决策过程，易于理解和解释。生成的决策树可以被可视化展示，帮助用户直观地了解模型的决策规则。 2. 能够处理数值型和分类型数据 决策树算法可以处理多种数据类型，包括连续型和离散型变量，无需对数据进行特殊的转换或标准化。 3. 对缺失值不敏感 决策树算法可以处理缺失值，在构建决策树时会跳过缺失值，不需要填充缺失值或删除带有缺失值的样本。 4. 高效 在预测阶段，决策树的查询速度非常快，由于树状结构，预测时间复杂度为O(logN)，具有高效的预测能力。 5. 能够处理大规模数据集 决策树算法在处理大规模数据集时具有较好的扩展性，可以处理大量特征和样本。 6. 鲁棒性 对异常值不敏感，能够处理不平衡数据集和噪声数据。 7. 可以灵活性 决策树算法可以很容易地与其他算法进行集成，例如集成学习方法（如随机森林、梯度提升树），能够提高预测性能。
8. 决策树的可解释性 生成的决策树可以提供清晰的决策路径，帮助用户理解模型的决策过程，从而更好地解释模型的预测结果。 四、决策树算法的实现 1. Python 实现 下面我们以一个简单的泰坦尼克号乘客生存预测为例,介绍如何使用Python的scikit-learn库实现决策树算法。
首先导入必要的库并加载数据:
import pandas as pd from sklearn.tree import DecisionTreeClassifier from sklearn.model_selection import train_test_split from sklearn.metrics import accuracy_score # 加载泰坦尼克号数据集 data = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73a25758de1d2e37234008e498d2645f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aad666c9184c6d52d3e81402dda34ce2/" rel="bookmark">
			【C&#43;&#43;高阶】：智能指针的全面解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨ 落絮无声春堕泪，行云有影月含羞 🌏
📃个人主页：island1314
🔥个人专栏：C++学习
🚀 欢迎关注：👍点赞 👂🏽留言 😍收藏 💞 💞 💞
目录
1.引言
1.1 动态内存与智能指针
🌸1.1.1 动态内存
🌸1.1.2 智能指针
1.2 智能指针的重要性
1.3 像指针一样使用
1.4 支持智能指针对象拷贝
2. C++标准库的智能指针
2.1 auto_ptr
🌈2.1.1 基本概念
🌈2.1.2 基本用法
2.2 unique_ptr
✨2.2.1 基本概念
✨2.2.2 基本用法
2.3 shared_ptr
🎈2.3.1 基本概念
🎈2.3.2 基本用法
🎈2.3.3 注意事项
2.4 weak_ptr
🧩2.4.1 基本概念
🧩2.4.2 基本用法
🧩2.4.3 对循环引用的解决
🧩2.4.4 与shared_ptr的关系
3. 智能指针的实现
3.1 auto_ptr模拟实现
3.2 unique_ptr模拟实现
3.3 shared_ptr模拟实现
3.4 weak_ptr模拟实现
📖总结
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aad666c9184c6d52d3e81402dda34ce2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b28057106774deb25e2e51be51a780a6/" rel="bookmark">
			什么是云原生？（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 云原生的定义 云原生指构建和运行应用以充分利用通过云技术交付模式交付的分布式计算。云原生应用旨在充分利用云技术平台特有的可扩展性、弹性和灵活性优势。
根据云原生计算基金会 (CNCF) 的定义，云原生技术可帮助企业在公有云、私有云和混合云环境中构建和运行可扩展的应用。云原生方法的典型特性包括容器、服务网络、微服务、不可变基础设施以及声明式应用编程接口 (API) 等等。
借助这些特性，企业可以获得松散耦合的弹性、可管理、可观测的系统，工程师也能尽可能减轻工作负担，高频实施重大变更。
为了满足现代复杂应用的要求以及用户对持续创新和无与伦比的响应能力的期望，企业的业务系统必须具有更高的战略性和灵活性。对此，云原生不仅能确保业务系统快速运行，还能提供杰出的敏捷性。
云原生服务可使用 Kubernetes、Docker、无服务器函数、API 和 Kafka 等技术助力现代应用开发。通过使用来自有实力的云技术提供商的云工具和云技术服务，开发人员可以减轻运营工作负担，更快地构建应用。
简而言之，云原生服务可以提供一个全面、基于标准的平台，帮助开发人员更好地构建、部署和管理云原生应用（例如微服务和无服务器函数）。
2. 使用云原生服务交付优秀软件 了解如何释放云原生的全部优势，轻松、快速地构建弹性、易于管理、可扩展的现代云技术应用。
通过迁移到云原生技术，企业可以在整个组织平台上尽可能改善客户体验，永久性地革新软件开发和业务模式。不久前，很多组织都迁移到了“云友好”的 IT 基础设施。但是，IT 团队如果不能创建云原生应用来充分发挥云技术投资的价值，即使迁移到了云端，也会在竞争中远远落后。为了从竞争中脱颖而出，企业需要快速调整和迭代，而云基础设施杰出的弹性和按需功能可助力任何业务迁移到云原生模式。
3. 云原生计算基金会 (CNCF) 2015 年，随着大量组织和服务开始采用云原生系统，云原生计算基金会 (CNCF) 应运而生。作为 Linux 基金会创建的一个项目，CNCF 是一个旨在促进云原生技术采用的开源软件基金会。时至今日，CNCF 共拥有 400 多名成员，其中既有公有云技术提供商，也有企业软件公司和技术初创企业，例如 Microsoft、Oracle、VMware 和 Intel 等均为 CNCF 白金成员。
CNCF 旨在确保云原生技术可访问、可用和可靠。它孵化了一个专门面向 Kubernetes、Prometheus 和 CoreDNS 等项目的社区，为各种致力于构建（支持在微服务架构下编排容器的）可持续环境的组织提供支持。
迁移至云原生系统对于企业而言可能是一个艰难的过程，但最终绝对是“物有所值”。这不仅仅意味着重新设计应用，还意味着革新企业的结构和文化，最终推动企业向前发展。借助 CNCF 路线图，企业可以逐步采用云原生技术。按照这一路线图，企业要采用更复杂的软件来交付微服务、无服务器函数、基于事件的流以及其他类型的云原生应用。
4. 云原生应用的优势 云原生应用，或者说原生云应用 (NCA)，是专为云计算架构而设计的程序。它们具有多重优势。
独立：云原生应用架构支持企业构建相互独立的云原生应用，同时单独管理和部署各个云原生应用。可恢复性：即便基础设施发生故障，云原生应用也能继续运行，保持联机状态。基于标准：为实现出色的互操作性和工作负载可移植性，云原生服务通常基于开源和标准技术构建而成。这有助于降低供应商依赖，提高可移植性。业务敏捷性：云原生应用支持跨网络灵活部署，同时相比传统应用规模更小，更易于开发、部署和迭代。自动化：云原生应用支持 DevOps 自动化特性，支持持续交付以及持续部署定期软件变更。此外，开发人员还可以使用蓝绿部署和金丝雀部署等方法来优化应用，避免对用户体验产生任何不利影响。零停机：借助 Kubernetes 等容器编排器，企业可以零停机地部署软件更新。 5. 云原生对于一项技术意味着什么？ 云原生应用可视为打包为自包含的、可移植的、可按需快速纵向或横向扩展的轻量级容器的独立服务。通过将所有元素封装到容器（例如 Docker 容器）中，企业可以将应用及其依赖关系与底层基础设施相隔离，进而在任何拥有容器运行时引擎的环境下部署该容器化应用。此外，Kubernetes 容器编排支持企业对容器生命周期进行有效管理。云原生应用一般通过具有持续集成和持续交付 (CI/CD) 工具链的 DevOps 管道交付。CI/CD 管道对于自动构建、测试和部署云原生应用非常重要。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b28057106774deb25e2e51be51a780a6/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/67/">«</a>
	<span class="pagination__item pagination__item--current">68/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/69/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>