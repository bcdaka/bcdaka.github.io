<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2508d33cbc2ee869c5ed1f35a4e0fcf5/" rel="bookmark">
			国产化低功耗HDMI转VGA方案，大量出货产品，广泛应用在显示器以及广告机产品
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		芯片描述：
兼具高性能和低成本效益的优点，是一款可以将高清视频 HDMI1.4 数字信号转换成
VGA 模拟信号输出的芯片。不需要提供外部电源，ICNM7301 就可以在正常模式下使用；ICNM7301 广
泛适用于各种市场系统和显示应用体系，例如笔记本电脑、主板、台式机、转换和对接系统等。
芯片特点：
 支持 1920X1080@60Hz 视频分辨率；高达 1920x1200@60Hz
 兼容支持 HDMIRX 1.4b 输入
 VGA 接口输出带热插拔功能
 无需外部晶振
 芯内的 HDCP 引擎符合 HDCP 1.4 规范要求
 集成 HDCP1.4 密钥
 嵌入式 EDID（如果终端设备没有，芯片将响应 EDID）
 支持自动省电模式
 支持内部上电复位
 内置 3.3VI/O 和 1.1V core LDO 转换电源
 工作温度范围: -10°C to +85°C
 封装: QFN32 4x4
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55613b3a080143dc5ab1dbe0efa924fb/" rel="bookmark">
			怎么给PDF文件设置加密保护？有哪些方法？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pdf作为一种便携式文档，是展示内容的首选，目前也已广泛应用于交换和分享等，例如内部报告以及商业提案等。然而，在如今的数字化时代，随着越来越多的企业将其文档存储和在线分享，pdf文件也可能面临安全隐私泄露问题，为此了解pdf怎么加密，以防止编辑和复制对于保护您的数据在网络上的安全至关重要。快来花一分钟时间来，学习了解吧。
PDF密码设置 点击【保护】—【文档加密】，编可以给PDF文件设置密码和对应的权限。
支持设置打开密码和支持设置编辑及页面提取密码，设置编辑及页面提取密码还可以对打印、复制、注释、插入和删除页面、填写表单和注释等功能进行权限设置。
如果后续想要取消密码保护的话，可以点击【保护保护】—【文档加密】，然后会弹窗让你输入权限密码，输入原本设置好的密码后，会进入加密的弹窗，这个时候我们取消设置密码和设置编辑及页面提取密码前面方框内的√，在点击确认，我们就可以取消PDF的编辑限制啦。
但如果忘记了原本设置的PDF加密密码的话，我们就需要借助PassFab for PDF的“移除编辑权限”的功能来取消pfd的编辑权限了，具体操作步骤如下：
第 1 步：打开软件点击移除PDF编辑限制。
第2步：添加PDF文件点击“移除”按钮，开始取消编辑权限。
第 3 步：成功移除pdf限制编辑后，单击“打开文件夹”找到该文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad5ffc9f7173e7e47846fdd19e9b2b4c/" rel="bookmark">
			【Spring全家桶系列之核心篇 | Spring Cloud】 - 第七章 掌握Gateway核心技术，实现高效路由与转发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言示例创建一个服务提供者创建网关 创建common子项目 前言 Spring Cloud Gateway 是一个基于 Spring Boot 的非阻塞 API 网关服务，它提供了动态路由、请求断言、过滤器等功能。
以下是关于 Spring Cloud Gateway 的示例：
示例 创建一个服务提供者 新建Module
dependency选择Spring Web及Eureka Discovery Client。
2. 打开pom.xml文件，修改如下：
3. 定义服务
在src/main/java下面的com.cherry.provider 下创建新的包controller（也可以不创建新的包，在当前provider包下），并新建下面的类： package com.cherry.provider1.controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping("product") public class ProductController { @RequestMapping("list") public String list(){ return "这是product列表"; } } 在resource中的配置文件中加入配置 server.port=8009 spring.application.name=my_provider1 #注册中心的地址 eureka.client.service-url.defaultZone=http://localhost:8001/eureka/ 修改启动类，如下： package com.cherry.provider1; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; @SpringBootApplication @EnableEurekaClient public class Provider1Application { public static void main(String[] args) { SpringApplication.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad5ffc9f7173e7e47846fdd19e9b2b4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dc006e3ea9f48e9a76d8fbaa86c1c4c/" rel="bookmark">
			香橙派AIpro-携手华为-为AI赋能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 香橙派AIpro-携手华为-为AI赋能开箱和功能介绍开箱功能介绍 环境搭建镜像烧录进入系统 测试项目YOLOv5部署YOLOv5识别单张图片实时识别视频使用Ascend测试yolov5 产品评价 香橙派AIpro-携手华为-为AI赋能 今天新入手了一款香橙派AIPro，让我们一起跟着文章体验一下不一样的
开箱和功能介绍 开箱 香橙派AIpro包装是比较精致的，一共包含开发板，65W充电器和充电线一根，开发板中有一个32G的内存卡，里面是包含自带的系统。
主板对比，香橙派和我手中现有的AI板 Alinx zynq7000相比，体积更小，且不需要接入外置模块即可使用串口进行通信，整体结构更干净整洁。接通电源之后，香橙派的风扇声音也较小，且正常运行时在我的环境下，感知不到风扇的声音。
功能介绍 OrangePi AIpro(8-12T)采用昇腾AI技术路线，具体为4核64位处理器+AI处理器，集成图形处理器，支持8-12TOPS AI算力，拥有8GB/16GB LPDDR4X，可以外接32GB/64GB/128GB/256GB eMMC模块，支持双4K高清输出。 Orange Pi AIpro引用了相当丰富的接口，包括两个HDMI输出、GPIO接口、Type-C电源接口、支持SATA/NVMe SSD 2280的M.2插槽、TF插槽、千兆网口、两个USB3.0、一个USB Type-C 3.0、一个Micro USB（串口打印调试功能）、两个MIPI摄像头、一个MIPI屏等，预留电池接口，可广泛适用于AI边缘计算、深度视觉学习及视频流AI分析、视频图像分析、自然语言处理、智能小车、机械臂、人工智能、无人机、云计算、AR/VR、智能安防、智能家居等领域，覆盖 AIoT各个行业。 Orange Pi AIpro支持Ubuntu、openEuler操作系统，满足大多数AI算法原型验证、推理应用开发的需求。
硬件规格参数： 硬件参数CPU4核64位处理器+ AI处理器GPU集成图形处理器AI算力8-12TOPS算力内存LPDDR4X：8GB/16GB（可选），速率：3200Mbps存储1.SPI FLASH：32MB SATA/NVME SSD 2.（M.2接口2280）
3. eMMC插槽：32GB/64GB/128GB/256GB（可选），eMMC5.1 HS400 4.TF插槽WIFI+蓝牙Wi-Fi 5双频2.4G和5G BT4.2/BLE以太网收发器10/100/1000Mbps以太网显示2xHDMI2.0 Type-A TX 4K@60FPS 1x2 lane MIPI DSI via FPC connector摄像头2x2-lane MIPI CSI camera interface，兼容树莓派摄像头USBUSB 3.0 HOST x2 USB Type-C 3.0 HOST x1 Micro USB x1 串口打印功能音频3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dc006e3ea9f48e9a76d8fbaa86c1c4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92d4908977a57827b5bf0c7e6b80e93a/" rel="bookmark">
			谷粒商城-全文检索-ElasticSearch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.简介 一个分布式的开源搜索和分析引擎,可以 秒 级的从海量数据中检索
主要功能:做数据的检索和分析(MySQL专攻于数据的持久化存储与管理CRUD达到百万以上的数据MSQL就会很慢,海量数据的检索和分析还是要用ElasticSearch)
用途:我们电商项目里的所有的检索功能都是由ElasticSearch完成的
底层:开源库 Lucene ,然后对 Lucene 进行封装,提供了 REST API 接口,开箱即用
REST API: 天然的跨平台
版本对应:
1.基本概念 类比MySQL:
1.Index(索引) 1.动词:类似于MySQL的insert: 创建一条数据在 ElasticSearch 里叫 索引一条数据
2.名词:类似于MySQL的Database
2.Type(类型) (es7以后不能再创建多个type,只能用默认的,已被弃用) 在 Index 中可以定义一个或者多个 Type
类似于MySQL 数据库 和 表 的关系:MySQL里叫在某个数据库的某张表里,在ES里叫某个索引的某个类型下
已经没有type了 现在索引就是表 索引还有映射 然后索引库里边存的就是文档了.......
3.Document(文档) 保存在某个索引(Index)下，某种类型(Type)的一个数据(Document)，文档是JSON格式的，Document就像是 MySQL中的某个Table 里面的内容;
4.倒排索引 比如我们保存一条记录:红海行动
ES会先把 红海行动 进行分词,比如分成 红海 和 行动 两个单词,除了存入1号记录 红海行动 这个文档之外,额外又维护了一张 倒排索引表 :倒排索引表就会存 红海 1,行动 1,两个文档
然后我们再来保存2号记录 探索红海行动
先分词成: 探索 红海 行动 ,先存入2号记录 探索红海行动 ,再额外维护 倒排索引表 更新 红海 和 行动的记录 加入 探索 的记录 :红海 1,2 和 行动 1,2 和 探索 2 以此类推.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92d4908977a57827b5bf0c7e6b80e93a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ae03779a89c3c0203e990346cbe5872/" rel="bookmark">
			【排序算法】—— 计数排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 计数排序，顾名思义就是记录数据出现的次数进行排序，时间复杂度为O(N+K)，空间复杂度为O(N)。只能用于整型，对于比较集中重复率比较高数据更为适用。
二、排序原理 比如对接下来这些数进行排序
arr[11] = { 8,6,4,1,6,2,9,6,2,4,3 }
定义一个tmp用来记录数字出现的次数，那么tmp的长度可以设为需要排序的最大的数字加1，因为我们要做的是用下标来表示这个数，
比如tmp[6]=2，其中下标6表示6这个数字，2表示出现两次
所以得先把tmp初始化为0，然后进行计数，比如第一个数字为1那么就在1下标位置加1，以此类推遍历完数组arr。然后根据每个数出现的个数依次赋值给原数组arr。
#include&lt;stdio.h&gt; int main() { int arr[11] = { 8,6,4,1,6,2,9,6,2,4,3 }; int tmp[10] = { 0 }; for (int i = 0; i &lt; 11; i++) tmp[arr[i]]++; for (int i = 0, j = 0; i &lt; 10; i++) { while (tmp[i]--) { arr[j++] = i; } } for (int i = 0; i &lt; 11; i++) printf("%d "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ae03779a89c3c0203e990346cbe5872/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57b7107f955ba8fe789fa71b0b3d0997/" rel="bookmark">
			【人工智能】AI时代：探索个人潜能的新视角
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🍊Al时代的个人发展1 AI的高速发展意味着什么1.1 生产力大幅提升1.2 生产关系的改变1.3 产品范式1.4 产业革命1.5 Al的局限性1.5.1局限一:大模型的幻觉1.5.2 局限二：Token 2 个体如何应对这种改变?2.1 职场人2.2 K12家长2.3 大学生2.4 创业者 3 人工智能发展史4 人工智能领域的常见概念4.1生成式Al和AIGC4.2 AGI4.3 决策式(判别式) AI4.4 生成式AI 5 常用的AI工具5.1 AI搜索:5.2 AI内容:5.3 AI绘画:5.4 AI视频:5.5 AI音乐: 🍊Al时代的个人发展 随着人工智能（AI）技术的迅猛发展，我们正步入一个充满变革的新时代。AI不仅深刻改变了社会生产力和生产关系，还对我们的生活方式、职业选择和个人成长产生了深远影响。在这个时代，如何适应AI带来的变化，把握机遇，实现自我提升，成为了每个人都需要面对的重要课题。
本文将从AI对个人生产力的提升、职业路径的重塑、学习方式的变革等多个方面进行探讨，旨在为读者提供一份实用的AI时代生存与发展指南。通过了解AI的最新进展和未来趋势，分析其对个人和社会的影响，我们将共同探索在AI浪潮中如何实现个人价值的最大化。
1 AI的高速发展意味着什么 近30年来，我一直在思考智能体，并在1995年出版的《未来之路》书中提到了它们，但直到最近，由于人工智能的进步，它们才变得实用起来。智能体不仅会改变每个人与电脑互动的方式。它们还将颠覆软件行业，引领自我们从输入命令到点击图标以来最大的计算机革命。——比尔·盖茨（微软公司创始人、中国工程院外籍院士）人工智能未来会像电力一样改变世界。——凯文·凯利（《连线》杂志创始主编、畅销书籍“失控”作者）我们最开始以为这是互联网十年不遇的机会，但是越想越觉得这是几百年不遇的、类似发明电的工业革命一样的机遇！（马化腾谈ChatGPT）——马化腾（企业家、腾讯公司创始人、腾讯公司董事会主席）我们即将进入一个正在经历巨大变革的世界，就像我毕业时遇到个人电脑和晶片革命时一样，我们正处于Al 的起跑线上。每个行业都将被革命、重生，为新思想做好准备！——黄仁勋（英伟达CEO）ChatGPT的出现意义重大，因为，它带来了交互革命和生产力革命。——傅盛(猎豹CEO) 1.1 生产力大幅提升 全人类全场景的生产力的提升，300%-700%
1.2 生产关系的改变 生产力提升，必然引起生产关系的改变
雇佣关系:螺丝钉、需要一个技能。合作关系: T字型人才，要为结果负责。
1.3 产品范式 1.4 产业革命 重工业轻工业第一产业“农林牧渔”农业林业畜牧业渔业第二产业草造纸塑料制药电子工业半导体能源电力可再生能源广告化学 草造纸塑料制药电子工业半导体能源电力可再生能源广告化学第三产业讯信技术 软件在线 服务金融 保险 旅游 和接待酒店餐饮第四产业创意时装电影音乐电子游戏广播通讯社无线电电视文化医疗卫生产业专业服务体育不动产教育娱乐业演艺音像动画其他语言产业休闲产业第五产业 1、重复性的、理性规则的、初级的事情
2、基于人口红利的产业将失去竞争力
3、人更像人，推理预测创新感悟-- 性灵
1.5 Al的局限性 1.5.1局限一:大模型的幻觉 在人工智能领域，"幻觉"通常指的是模型在处理输入数据时产生的错误或不准确的输出。这些幻觉可能是由于数据不足、训练不充分、模型设计缺陷或输入数据的复杂性引起的。尤其是中文中的古诗词、古文、各种人名等。
1.在某些情况下，模型可能错误地将物理接近或频繁出现的词汇视为实际知识的证据。
2.有时，模型过于自信，即使在提供不准确的信息时也表现得像在给出正确答案一样。
3.当概念对齐处理不当时，可能会误导模型，导致它产生错觉。此外，存在一种风险，即模型倾向于迎合用户，提供符合用户预期而非客观事实的答案，这可能进一步加剧错觉现象。
4.这些模型逐步构建回应，每次只添加一个词。即使在后期意识到之前的错误，它们有时也倾向于保持一致性，而不是纠正错误，这种现象可以类比为“流雪球效应”
1.5.2 局限二：Token 1、什么是 token?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57b7107f955ba8fe789fa71b0b3d0997/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2df302d48f0bcc1b85047e5487320592/" rel="bookmark">
			SwiftUI 5.0（iOS 17）滚动视图的滚动目标行为（Target Behavior）解惑和实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概览 在 SwiftUI 的开发过程中我们常说：“屏幕不够，滚动来凑”。可见滚动视图对于超长内容的呈现有着多么秉轴持钧的重要作用。
这不，从 SwiftUI 5.0（iOS 17）开始苹果又为滚动视图增加了全新的功能。但是官方的示例可能会让小伙伴们“雾里看花”、不求甚解。所以，本篇博文存在的真谛就尽在于此了！
在本篇博文中，您将学到如下内容： 概览1. 什么是滚动目标行为（Scroll Target Behavior）？2. scrollTargetLayout 视图修改器到底是干嘛用的？3. 定制我们自己的 ScrollTargetBehavior 滚动目标行为总结 相信学完本课后，小伙伴们一定会对 SwiftUI 5.0 中新的 scrollTargetLayout 以及 scrollTargetBehavior 修改器的含义和使用“醍醐灌顶”、如梦初醒！
那还等什么呢？让我们马上进入滚动的世界吧！
Let’s rolling！！！😉
本文对应的视频课在此，欢迎小伙伴们恣意观赏：
SwiftUI 5.0 滚动视图的滚动目标行为解惑和实战
1. 什么是滚动目标行为（Scroll Target Behavior）？ 从 SwiftUI 5.0 开始，苹果为滚动视图特地新增了 scrollTargetBehavior 修改器方法：
使用它我们可以根据滚动轴来设置滚动视图的滚动目标行为（Scroll Target Behavior）。那么，什么是滚动目标行为呢？简单来说，它表示滚动视图中的滚动目标（Scroll Targets）在滚动停止时以何种方式对齐。
import SwiftUI enum ScrollAlignType: Identifiable, CaseIterable { case none, paging, view var align: AnyScrollTargetBehavior { switch self { case .none: .init(.viewAligned(limitBehavior: .never)) case .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2df302d48f0bcc1b85047e5487320592/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21e63bc8e4bb815cb718b50007234055/" rel="bookmark">
			python每日学习9：正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python每日学习9：正则表达式 定义 在Python中，正则表达式是一种用于匹配字符串中字符组合的模式。它被广泛用于执行各种字符串搜索和替换任务。Python提供了内置的re模块，用于处理正则表达式。 常用的元字符 \d：匹配一个数字字符。等价于[0-9]。\D：匹配一个非数字字符。等价于非[0-9]。\s：匹配任何空白字符，包括空格、制表符、换页符等。等价于[\f\r\n\t\v]。\S：匹配任何非空白字符，包括空格、制表符、换页符等。等价于非[\f\r\n\t\v]。\w：匹配字母数字字符。\W：匹配非字母数字字符。 字符匹配 ?：匹配前面的字符0次或1次。
*：匹配前面的字符0次或多次。
+：匹配前面的字符1次或多次。
. :匹配除’\n’之外的任何单个字符。使用[.\n]匹配包括\n的任何字符。
{n}表示n个字符，用{n,m}表示n~m个字符。
:将特殊字符转义。
A|B可以匹配A或B，所以(P|p)ython可以匹配’Python’或者’python’。
^:表示行的开头。
^\d:表示必须以数字开头。
$:表示行的结束。
\d$:表示必须以数字结束。
\d{3}表示匹配3个数字，例如'010' \s可以匹配一个空格（也包括Tab等空白符），所以\s+表示至少有一个空格，例如匹配 '空格'，'空格空格'，'空格空格空格'等； \d{3,8}表示3-8个数字，例如'1234567','123','12345' 综上，该正则表达式可以匹配以任意个空格隔开的带三位区号的电话号码4 要匹配'010-12345'这样的号码，由于'-'是特殊字符，要用'\'转义，所以可用\d{3}\-\d{3,8}进行匹配。 复杂的正则表达式 常用方法 [0-9a-zA-Z_]可以匹配一个数字、字母或者下划线。[0-9a-zA-Z_]+可以匹配至少由一个数字、字母或者下划线组成的字符串。[0-9a-zA-Z_]{0, 19}更精确地限制了长度是0-19个字符（最多19个字符）。 re模块 match方法 定义：match()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None（match方法通常会结合if选择结构进行判断）。
格式
import re 使用前需要先导入re模块 re.match(r'^\d{3}\-\d{3,8}$', '010-12345') 调用match方法，左边需要传入一个正则表达式，右边为待匹配的字符串 如果能匹配上则返回：&lt;_sre.SRE_Match object; span=(0, 9), match='010-12345'&gt; re.match(r'^\d{3}\-\d{3,8}$', '010 12345') 无法匹配则返回空,即None 切分字符串 re模块提供了split方法，可以按照指定的正则表达式进行字符串的切分。
#无论多少个空格都可以正常分割 import re m=re.split(r'\s+','a bb c') print(m) 分组 m=re.match(r'^(\d{3})\-(\d{3,8})$') m.group(0)#默认为0 全部读取 m.group(1)#读取第一个字串 m.group(2)#读取第二个字串 m.groups()#以列表的形式读取 贪婪匹配 定义：正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。
re.match(r'^(\d+)(0*)$', '102300').groups() 最终结果：('102300', '') 非贪婪匹配：就是尽可能少匹配。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21e63bc8e4bb815cb718b50007234055/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae856d23d6a3c12d087c2fcfb630fbea/" rel="bookmark">
			比肩Midjourney-v6！没有GPU也能跑可图Kolors
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比肩Midjourney-v6，快手的文生图开源模型可图Kolors一发布，开源社区就炸开了锅。短短几天，可图在Github上收获2k Star，Huggingface模型下载热榜第一。
7月6日，快手宣布开源数十亿参数的文生图模型可图Kolors，可图支持中英文双语，支持长达256 token的上下文长度，最重要的是可以渲染中文，生成效果上实现了质的飞跃。
值得一提的是，可图采用了智谱的开源大模型ChatGLM3作为文本编码器，对中文的理解能力远超很多竞品。
国产文生图模型的强势崛起让人振奋，不过，由于硬件等客观条件限制，大多数跃跃欲试的用户却很难在本地部署并体验可图。
首先，可图模型完整下载有28G，下载模型、存放模型比较不方便；其次，可图采用的ChatGLM3代替了传统的CLIP模型做文本提示词嵌入，语义能力增强的同时显存消耗也从原来的几百MB变成十几G，这样，本地显存少于20G的用户，需要用有损量化或者损失推理速度的办法运行可图。
为了让用户无痛使用可图，硅基流动团队开源了BizyAir节点，这是一个专用于ComfyUI的节点仓库，首批节点就有可图Kolors。
现在，没有显卡，不用下载模型，你也能用可图极速生成图片。
BizyAir还同步上线了一个小惊喜。考虑到写提示词的环节也很费劲，我们开源了SiliconCloud LLM节点，让GLM4、DeepSeek V2 Chat这类顶尖大语言模型接入ComfyUI，帮助你在工作流中生成、提炼提示词。
以DeepSeek V2 Chat为例，如果用它提炼提示词，需要500G左右的硬盘空间和8张A100以上的显卡才能部署这个模型，而SiliconCloud LLM节点直接提供了这个能力。
除了免去了用户搭配环境、模型下载与模型部署的门槛与烦恼。硅基流动还对Kolors节点提供基于专用的图片生成推理引擎OneDiff优化，节约图片生成时间与成本。
当然，你也可以一键无缝接入已有ComfyUI工作流，并可自由与本地节点做平替或组合。
一键直达传送门：
代码：github.com/siliconflow/BizyAir
文档：bizyair.siliconflow.cn
那么，如何在ComfyUI中使用可图Kolors？
只需两大步。
一、安装BizyAir
在ComfyUI Manager中搜索“BizyAir”即可完成安装。
此外，你还可以通过源码、Comfy-cli安装。Windows新手可以下载独立的压缩包，具体可见：siliconflow.github.io/BizyAir/getting-started/
二、快速开始
设置API密钥
首次使用，你需要通过“Set SiliconCloud API Key（设置SiliconCloud API密钥）”来生成API密钥（https://cloud.siliconflow.cn/account/ak）。之后，这个节点就可以删除了。之后重启程序，也不需要重新输入。
使用BizyAir节点
所有BizyAir节点都在“☁️BizyAir”目录下。其中“☁️BizyAir SiliconCloud LLM API”节点可以利用大型语言模型帮你精炼提示词、翻译或执行任何其他任务。
现在，你也可以添加“Kolors”节点快速进行文生图了。目前，BizyAir提供了与Kolors相关的节点，包括Kolors Sampler、Text encoding、VAE decoding、VAE encoding。
当然，图生图也不在话下。
快试试吧：
github.com/siliconflow/BizyAir
其他人都在看
800+页免费“大模型”电子书
文生图王者登场：SD3 Medium正式开源
大模型产品化第一年：战术、运营与战略
国产大模型新标杆！DeepSeek V2重磅升级
最强开源代码模型DeepSeek-Coder-V2问世
20+公司AI产品分析；工程师的LLM使用痛点
国产大模型免费用！开发者Token自由实现了
开发生成式AI应用，减少响应时间
就用SiliconCloud
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ac5033aea5850786f118e2617a38e03/" rel="bookmark">
			阿里开源语音大模型：SenseVoice 识别，语音识别效果和性能强于 Whisper，还能检测掌声、笑声、咳嗽等！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里开源语音大模型：语音识别效果和性能强于 Whisper，还能检测掌声、笑声、咳嗽等！ 原创 kakuqo AI真好玩 2024年07月06日 10:21 福建
语音识别技术在人工智能（AI）领域扮演着至关重要的角色，它不仅是人机交互的基石，也是推动智能系统发展的关键驱动力。以下是语音识别在AI领域的一些主要作用：
改善用户体验：通过语音识别，用户可以与智能设备进行自然语言交流，无需手动输入，这极大地提升了用户体验的便捷性和直观性。
数据收集与分析：语音识别可以自动转录语音数据，为企业提供大量的自然语言数据，这些数据可用于市场研究、消费者行为分析等。
智能助手和虚拟助手：语音识别是智能助手（如 Siri、Google Assistant 等）的核心功能，允许用户通过语音指令获取信息、设置提醒或控制智能家居设备。
医疗和健康领域：在医疗领域，语音识别可以帮助医生在诊断过程中记录患者信息，减少手动输入的时间，同时也可以辅助听力受损的患者与医疗人员沟通。
教育和培训：语音识别技术可以用于语言学习和语音反馈，帮助学习者提高语言能力，同时也可以用于远程教育和在线课程。
本文我将介绍 SenseVoice，它是由阿里开源的具有音频理解能力的音频基础模型，该模型拥有以下能力：
语音识别（ASR）
语种识别（LID）
语音情感识别（SER）
声学事件分类（AEC）
声学事件检测（AED）
近期热文 当 AI 遇上爬虫：让数据提取变得前所未有的简单！
2024 年最完整的 AI Agents 清单来了，涉及 13 个领域，上百个 Agents！
超强 OCR 神器：支持批量 OCR、文档识别、公式识别，离线可用、完全免费！
SenseVoice 主要功能 支持中、粤、英、日、韩语等 50 多种语言，识别效果优于 Whisper 模型。
情感识别技术在测试数据上的表现，超过了现有的最佳模型。
能够检测多种声音事件，包括音乐、掌声、笑声、哭声、咳嗽和喷嚏等常见的人机交互声音。
拥有完善的服务部署流程，能够处理多并发请求，并且支持多种客户端语言，包括 Python、C++、Java 和 C# 等。
推理速度极快，10 秒音频的推理时间仅需 70 毫秒，性能是 Whisper-Large 的 15 倍。
SenseVoice 使用示例 粤语识别 英语识别 语音情感识别 能够识别音频中的情感，比如，积极和消极等。
声学事件检测 能够识别音频文件中的掌声（👏）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ac5033aea5850786f118e2617a38e03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ff2b0d7b8a5a03e49ee202c8335fb9d/" rel="bookmark">
			【C&#43;&#43;高阶】二叉搜索树的全面解析与高效实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨ 人生到处知何似，应似飞鸿踏雪泥 🌏 📃个人主页：island1314
🔥个人专栏：C++学习
🚀 欢迎关注：👍点赞 👂🏽留言 😍收藏 💞 💞 💞
二叉搜索树目录
一、二叉搜索树的概念
二、二叉搜索树的功能
三、二叉搜索树的实现
🧩1. 节点定义：
🧩2. BST定义：
🧩3. 二叉搜索树的操作
🌈a. 查找
🌈b. 插入
🌈c. 删除
🌈d. 遍历
🧩4、二叉搜索树默认成员函数
🎉构造
🎉拷贝构造
🎉赋值重载
🎉析构
4. 二叉搜索树的应用
🍁1. K模型
💧数组的排序实现
🍁2. KV模型
🍁3. KV模型实现
💧英汉词典的查找实现
💧计数
5.二叉搜索树的性能分析
🌄二叉树巩固知识
一、二叉搜索树的概念 二叉搜索树(BST,Binary Search Tree)又称二叉排序树，是一种特殊的二叉树，它或者是一棵空树，或者是具有以下性质的二叉树:
若它的左子树不为空，则左子树上所有节点的值都小于根节点的值若它的右子树不为空，则右子树上所有节点的值都大于根节点的值它的左右子树也分别为二叉搜索树 二叉搜索树（Binary Search Tree）的每个节点的左子树中的所有节点都比该节点小，右子树中的所有节点都比该节点大。这个特性使得二叉搜索树可以用来实现非常高效的查找、插入和删除操作。
二、二叉搜索树的功能 🎈首先，在二叉搜索树的操作中只支持插入，查找，删除，遍历，并不支持修改操作，因为在修改后谁也不能保证它依然是一棵二叉搜索树，二叉搜索树的时间复杂度范围在(O(logN)~O(N))
🎈在二叉搜索树的遍历中一般采用中序遍历： 先遍历左子树，然后访问根节点，最后遍历右子树。在BST中，中序遍历会按照升序访问所有节点
int a[] = {8, 3, 1, 10, 6, 4, 7, 14, 13}; 三、二叉搜索树的实现 二叉搜索树结构的和树形结构差不多，这意味着每个元素（通常称为节点）都有两个指针：一个指向前一个左子树，另一个指向右子树，因此我们需要单独再定义一个类来表示节点结构，每个节点再串联起来构成BST
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ff2b0d7b8a5a03e49ee202c8335fb9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dda10d7d5ce261a57fdc05b7083e28b5/" rel="bookmark">
			java.io.IOException : Broken pipe 什么情况下会出现这个错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java.io.IOException: Broken pipe 错误通常在以下几种情况下出现，它表示通信的另一端已经关闭了连接，而当前端尝试继续发送数据时发生了这个错误。
常见情况 客户端关闭连接：
在服务器端处理请求的过程中，客户端突然关闭了连接，例如浏览器关闭、网络断开等。这时，服务器端尝试写入数据到已经关闭的连接，就会触发这个异常。 超时：
如果网络连接在传输数据的过程中超时，并且另一端关闭了连接，也会发生这个错误。 网络问题：
由于网络不稳定或网络故障导致的连接中断。例如，路由器、交换机等网络设备出现问题。 服务器资源不足：
服务器资源耗尽，例如线程池、连接池用尽，导致连接无法继续维护。 示例代码 以下是一个简单的示例，展示了当客户端突然关闭连接时，服务器可能会抛出 Broken pipe 错误。
服务器端代码（Java） import java.io.IOException; import java.io.OutputStream; import java.net.ServerSocket; import java.net.Socket; public class Server { public static void main(String[] args) { try (ServerSocket serverSocket = new ServerSocket(8080)) { System.out.println("服务器启动，等待客户端连接..."); Socket clientSocket = serverSocket.accept(); System.out.println("客户端已连接"); OutputStream outputStream = clientSocket.getOutputStream(); // 模拟长时间写数据 for (int i = 0; i &lt; 1000; i++) { outputStream.write(("数据块 " + i + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dda10d7d5ce261a57fdc05b7083e28b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44c1344d36af86865373f63d5ae6e3c7/" rel="bookmark">
			web安全之SQL手工注入漏洞测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、目的
1.掌握SQL注入原理；
Sql注入详解(原理篇)_sql注入攻击的原理-CSDN博客
2.了解手工注入的方法；
3.了解MySQL的数据结构；
4.了解字符串的MD5加解密
二、过程
1.进去后出现以下界面
找注入点
发现有注入点，即id被代入执行
先找列名
首先order by查询了有几列数据，然后union看下哪几列数据可以显示出来，然后将能显示的替换成注入语句就可以了
结果
KEY：mozhe38c56cde0e054a6086362dad8ab
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93a98abab2f6dc009908206973525776/" rel="bookmark">
			TCP三次握手与四次挥手详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是TCP TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的通信协议，属于互联网协议族（TCP/IP）的一部分。TCP 提供可靠的、顺序的、无差错的数据传输服务，是许多重要网络应用（如 HTTP、FTP、SMTP）的基础。
主要特点 面向连接：
TCP 是面向连接的协议，在传输数据之前，必须先建立连接。连接的建立通过“三次握手”进行，确保通信双方都准备好了进行数据传输。 可靠传输：
TCP 提供可靠的数据传输服务，确保数据包按序到达且无丢失、无重复、无差错。通过确认（ACK）和重传机制实现可靠性。 流量控制：
TCP 采用流量控制机制，通过滑动窗口协议调整发送方的发送速度，以防止接收方的缓存溢出，确保数据传输的平稳性。 拥塞控制：
TCP 具有拥塞控制机制，能够检测网络拥塞并适当减少数据传输速率，以避免进一步加剧网络拥塞。常见的拥塞控制算法有慢启动、拥塞避免、快速重传和快速恢复等。 基于字节流：
用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。 顺序保证：
TCP 保证数据按序到达。通过序列号（Sequence Number）标识每个字节，接收方根据序列号重排序收到的数据包，确保应用程序收到的数据是按发送顺序排列的。 2.TCP协议头格式介绍 在Tcp协议中，比较重要的字段有：
源端口：表示发送端端口号，字段长 16 位，2个字节
目的端口：表示接收端端口号，字段长 16 位，2个字节
序号（sequence number）：字段长 32 位，占4个字节，序号的范围为 [0，4284967296]。由于TCP是面向字节流的，在一个TCP连接中传送的字节流中的每一个字节都按顺序编号首部中的序号字段则是指本报文段所发送的数据的第一个字节的序号，这是随机生成的。序号是循环使用的，当序号增加到最大值时，下一个序号就又回到了0
确认序号（acknowledgement number）：占32位（4字节），表示收到的下一个报文段的第一个数据字节的序号，如果确认序号为N，序号为S，则表明到序号N-S为止的所有数据字节都已经被正确地接收到了。
8个标志位（Flag）:（标红的为重要的）
CWR：CWR 标志与后面的 ECE 标志都用于 IP 首部的 ECN 字段，ECE 标志为 1 时，则通知对方已将拥塞窗口缩小；
ECE：若其值为 1 则会通知对方，从对方到这边的网络有阻塞。在收到数据包的 IP 首部中 ECN 为 1 时将 TCP 首部中的 ECE 设为 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93a98abab2f6dc009908206973525776/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/335e7f7732f9a429518383eb0fefd011/" rel="bookmark">
			算法笔记|Day1数组基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法笔记|Day1数组基础 ☆☆☆☆☆leetcode 704. 二分查找题目分析代码 ☆☆☆leetcode 35.搜索插入位置（待补充）题目分析代码 ☆☆☆leetcode 34. 在排序数组中查找元素的第一个和最后一个位置（待补充）题目分析代码 ☆leetcode 69. x 的平方根（待补充）题目分析代码 ☆leetcode 367.有效的完全平方数（待补充）题目分析代码 ☆☆☆☆☆leetcode 27. 移除元素题目分析代码 ☆leetcode 26.删除排序数组中的重复项（待补充）题目分析代码 ☆leetcode 283.移动零（待补充）题目分析代码 ☆leetcode 844.比较含退格的字符串（待补充）题目分析代码 ☆☆☆☆☆leetcode 704. 二分查找 题目链接：leetcode 704. 二分查找
题目分析 1.二分法的前提是有序数组，且本题无重复元素；
2.若采用左闭右闭区间[left,right]，这决定循环满足的条件为left&lt;=right，right初始值为n-1，每次迭代中right=mid-1；
3.若采用左闭右开区间[left,right)，这决定循环满足的条件为left&lt;right，right初始值为n，每次迭代中right=mid；
4.时间复杂度为O(log2n)，空间复杂度为O(1)。
5.关于mid溢出问题
若采用mid=(right+left)&gt;&gt;1或mid=(right+left)/2，可能会出现right+left超出整形的上限，导致溢出；可改写为mid=left+(right-left)/2，可以避免上述溢出问题；还可以采用位运算mid=left+((right-left)&gt;&gt;1)，优点是比直接相除的操作快。
此处要注意运算符优先级：加减&gt;移位运算，故需要加括号 代码 1.左闭右闭区间 class Solution { public int search(int[] nums, int target) { int left=0,right=nums.length-1; while(left&lt;=right){ int mid=left+((right-left)&gt;&gt;1); if(nums[mid]&lt;target){ left=mid+1; }else if(nums[mid]&gt;target){ right=mid-1; }else if(nums[mid]==target){ return mid; } } return -1; } } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/335e7f7732f9a429518383eb0fefd011/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/746a341ecdf3104b98e5423d4fb88ee3/" rel="bookmark">
			【C&#43;&#43;高阶】高效数据结构的探索（map&amp;&amp;set）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨ 人生到处知何似，应似飞鸿踏雪泥 🌏 📃个人主页：island1314
🔥个人专栏：C++学习
🚀 欢迎关注：👍点赞 👂🏽留言 😍收藏 💞 💞 💞
🚀前言： 【C++深度学习】二叉搜索树的全面解析与高效实现-CSDN博客
通过之前对二叉搜索树的学习，我相信大家对set和map也应该有所了解，set就类似于二叉搜索树的K模型，而map就类似于二叉搜索树的KV模型，下面就让我们进入对其的了解吧，踏上这神秘的学习之旅
1. 关联式容器 📒在初阶阶段，我们已经接触过STL中的部分容器，比如：vector、list、deque、
forward_list(C++11)等，这些容器统称为序列式容器，因为其底层为线性序列的数据结构，里面存储的是元素本身
📙关联式容器（Associative Containers） 是C++标准模板库（STL）中的一类重要容器，主要用于存储和快速检索键值对（key-value pairs）形式的数据。这类容器与序列式容器（如vector、deque、list）的主要区别在于，关联式容器中的元素是按照特定的排序准则（通常是键的大小）进行排序的，从而允许通过键来快速查找、插入和删除元素。
关联式容器： 也是用来存储数据的，与序列式容器不同的是，其里面存储的是&lt;key, value&gt;结构的键值对，在数据检索时比序列式容器效率更高
2. 键值对 概念： 用来表示具有一一对应关系的一种结构，该结构中一般只包含两个成员变量key和value，key代表键值，value表示与key对应的信息，比如我们上一篇所提到的kv模型结构 存在对应关系
SGI-STL中关于键值对的定义：(示例)
template &lt;class T1, class T2&gt; struct pair { typedef T1 first_type; typedef T2 second_type; T1 first; T2 second; pair(): first(T1()), second(T2()) {} pair(const T1&amp; a, const T2&amp; b) : first(a) , second(b) {} }; 3. 树形结构的关联式容器 📕根据应用场景的不桶，STL总共实现了两种不同结构的管理式容器：树型结构与哈希结构
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/746a341ecdf3104b98e5423d4fb88ee3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84183fc0a41f8f3913d08613ecf44a95/" rel="bookmark">
			【Qt】QTcpServer/QTcpSocket通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 1.pro文件2.服务器3.客户端 1.pro文件 QT += network 2.服务器 h文件
#ifndef MAINWINDOW_H #define MAINWINDOW_H #include &lt;QMainWindow&gt; #include &lt;QTcpServer&gt; #include &lt;QTcpSocket&gt; QT_BEGIN_NAMESPACE namespace Ui { class MainWindow; } QT_END_NAMESPACE class MainWindow : public QMainWindow { Q_OBJECT public: MainWindow(QWidget *parent = nullptr); ~MainWindow(); private slots: void on_setListenButton_clicked(); void on_sendMsgButton_clicked(); private: Ui::MainWindow *ui; QTcpServer *tcpServer; QTcpSocket *tcpSocket; }; #endif // MAINWINDOW_H cpp
#include "mainwindow.h" #include "ui_mainwindow.h" MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow) { ui-&gt;setupUi(this); ui-&gt;portEdit-&gt;setText("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84183fc0a41f8f3913d08613ecf44a95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d42274c4dd5b7f6468d602d36bb67eec/" rel="bookmark">
			关于dom4j主节点的xmlns无法写入的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于最近需要做一个xml的文件，使用dom4j的时候发现了一个bug，就是我的xmlns根本无法写入到xml的头部标签中。
Element element = document.addElement("test"); element.addAttribute("xmlns", "urn:Declaration:datamodel:standard:CN") 这种其实主要原因是因为你要写入的xmlns，再dom4j是主节点，那么这种情况是可以解决的，直接把内容放到你主节点名称后面，例如下图：
解决方法：
Element element = document.addElement("Manifest","urn:Declaration:datamodel:standard:CN:") 亲测有效哦！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/942a7fd17bd203f2a925cb07bdd16db4/" rel="bookmark">
			【排序算法】—— 归并排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		归并排序时间复杂度O(NlongN)，空间复杂度O(N)，是一种稳定的排序，其次可以用来做外排序算法，即对磁盘(文件)上的数据进行排序。
目录
一、有序数组排序
二、排序思路
三、递归实现
四、非递归实现
一、有序数组排序 要理解归并排序的核心逻辑我们得先看懂下面一个题：
刚接触这个题的时候，大家可能会想把他俩写到一个数组里面然后再写一个排序算法，这是一个比较容易想到也是比较蛮力的一种方法，但是这里有一个特点这两个数组是有序的。所以有一个很巧妙的方法。
使用两个变量分别记录他们的下标，并从零下标开始，比较他们下标对应下的值把小的那个先放进去新数组里面，然后把他的下标移到下一位。然后重复进行该操作，直到把其中的一个遍历完。
当然此时还没有完全排完序，当其中一组遍历完后，还有另一组剩余的的元素没有放在新数组内，因为无法确定那一组会先遍历完所以我们俩组都需要检查一遍，检查他们的下标并把剩余元素放在新数组内。
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;assert.h&gt; int main() { int ar1[] = { 1,2,3,4 }; int ar2[] = { 3,4,5,6,7 }; int sz1 = sizeof(ar1)/sizeof(int), sz2 = sizeof(ar2) / sizeof(int); int* arr = (int*)malloc(sizeof(int) * (sz1 + sz2)); assert(arr); int i = 0, j = 0, t = 0; while (i &lt; sz1 &amp;&amp; j &lt; sz2) { if (ar1[i] &lt; ar2[j]) arr[t++] = ar1[i++]; else arr[t++] = ar2[j++]; } while (i &lt; sz1) arr[t++] = ar1[i++]; while (j &lt; sz2) arr[t++] = ar2[j++]; for (int i = 0; i &lt; sz1 + sz2; i++) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/942a7fd17bd203f2a925cb07bdd16db4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/138/">«</a>
	<span class="pagination__item pagination__item--current">139/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/140/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>