<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1c7518973ee8ab5069557ebcf725da4/" rel="bookmark">
			某雪冰城小程序逆向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		app和小程序算法一样 小程序是wasm
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/246e107da2b7860daaca9a043a18d7ce/" rel="bookmark">
			Doris: Multi Catalog 多源数据目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、基本概念 :目前能支持以下数据源：JDBC 外部表 二、基本操作2.1 查看 catalog2.2 新增catalog2.3 切换 catalog2.4 删除 catalog2.5 查看catalog创建信息 三、元数据更新3.1手动刷新3.2定时刷新3.3自动刷新 四、JDBC Catalog4.1 上传mysql驱动包4.2 创建mysql catalog 总结 前言 Doris 是一个高性能的分析型数据库，它能够处理大规模的数据存储和分析任务。Doris 的 Catalog 是其核心组件之一，负责存储和管理元数据。 一、基本概念 : 多源数据目录（Multi-Catalog）功能，旨在能够更方便对接外部数据目录，以增强Doris的数据湖分析和联邦数据查询能力。 目前能支持以下数据源： 1、Hive Metastore：可以访问包括 Hive、Iceberg、Hudi 在内的数据表，也可对接兼容 Hive Metastore 的数据源，如阿里云的 DataLake Formation，同时支持 HDFS 和对象存储上的数据访问。
2、Elasticsearch：访问 ES 数据源。
3、JDBC：支持通过 JDBC 访问 MySQL 数据源。
JDBC 外部表 在过去版本中，Apache Doris 提供了 ODBC 外部表的方式来访问 MySQL、Oracle、SQL Server、PostgreSQL 等数据源，但由于 ODBC 驱动版本问题可能造成系统的不稳定。相对于 ODBC，JDBC 接口更为统一且支持数据库众多，因此在 1.2.0 版本中我们实现了 JDBC 外部表以替换原有的 ODBC 外部表。在新版本中，用户可以通过 JDBC 连接支持 JDBC 协议的外部数据源，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/246e107da2b7860daaca9a043a18d7ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36b0449684ce73e8f53e9a732b5170e4/" rel="bookmark">
			【Godot4.2】GodotXML插件 - 解析和生成XML
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 近期在研究Godot的XML和SVG解析，Godot提供了XMLParser类型，但本身只提供了低级的XML解析接口和功能，想要完成完整的XML文档解析和存储可能还需要在其基础上编写类或功能，就像我在昨天（2024年7月20日）基于XMLParser编写了一个简易的SVG文件解析器SVGParser。
但是我早就知道存在GodotXML这样的解析器。加上群友推荐，于是上手试用了一下。和以往一样，看源码里一堆英文注释就手痒，就机翻之，感觉代码布局不合理就稍加改动，并自己加一些注释。
本文主要简介GodotXML项目及其核心文件和核心类的方法，并贴出了汉化后的源代码内容。希望大家一起来学习和使用。
GodotXML简介 GodotXML是一个为Godot4.x引擎提供高级XML支持的插件。支持Godot 4.0-4.2，以及可能的未来版本。项目代码在Github上开源，项目地址：https://github.com/elenakrittik/GodotXML。 功能 基于GDSCript内置的XMLParser编写可以解析文件或字符串形式XML数据，并方便转换为GDSCript中的字典形式美化XML（带换行和Tab缩进，类似于VSCode中的“文档格式化”功能）可以基于GDSCript对象形式生成XML文档结构并方便存储 下载安装 在Godot4资产库中搜索 “GodotXML” 插件安装或者在Github项目主页下载ZIP压缩包到本地，将 addons/ 文件夹复制到项目的根目录。 下载下来后核心只有3个.gd文件，说是插件其实本质就是1个静态函数库+2个类。
源码翻译+重排 XML [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-qnBr0RJ5-1721699899307)(https://i-blog.csdnimg.cn/direct/e9d1943b34444ef49256d5d2ddaca551.png)]
xml.gd内部是一个class_name为XML的静态函数库使用XML.parse_file()可以解析XML文件为XMLDocument实例使用XML.parse_string()可以解析XML字符串为XMLDocument实例使用XML.parse_buffer()可以解析PackedByteArray类型的XML内容为XMLDocument实例 源代码：
# ================================================================== # 名称：XML # 描述：GodotXML - Godot4的高级XML支持。此类允许从文件解析XML数据并将其转储到各种源。 # 原作者：elenakrittik（https://github.com/elenakrittik） # 翻译+重排：巽星石 最后修改：2024年7月21日15:56:39 # ================================================================== class_name XML extends RefCounted # =============================== 表层解析函数（直接调用） =============================== # 将文件内容作为XML解析为 XMLDocument 实例 # 指定路径处的文件必须可读，文件内容必须是语法有效的XML文档。 static func parse_file(path: String) -&gt; XMLDocument: var file = FileAccess.open(path, FileAccess.READ) var xml: PackedByteArray = file.get_as_text().to_utf8_buffer() file = null return XML.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36b0449684ce73e8f53e9a732b5170e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/758aa83424619508e00de145deeb448e/" rel="bookmark">
			轨迹优化 | 基于ESDF的共轭梯度优化算法(附ROS C&#43;&#43;/Python仿真)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 0 专栏介绍1 数值优化：共轭梯度法2 基于共轭梯度法的轨迹优化2.1 障碍约束函数2.2 曲率约束函数2.3 平滑约束函数 3 算法仿真3.1 ROS C++实现3.2 Python实现 0 专栏介绍 🔥课程设计、毕业设计、创新竞赛、学术研究必备！本专栏涉及更高阶的运动规划算法实战：曲线生成与轨迹优化、碰撞模型与检测、多智能体群控、深度强化学习运动规划、社会性导航、全覆盖路径规划等内容，每个模型都包含代码实现加深理解。
🚀详情：运动规划实战进阶
1 数值优化：共轭梯度法 共轭梯度法是一种用于解决大型稀疏线性方程组或无约束优化问题的迭代数值方法。它利用了线性代数中的共轭概念，并结合了梯度下降法的思想，以更有效地找到函数的极小值点。
形式化地，对于 n n n维二次优化问题
x ∗ = a r g min ⁡ x 1 2 x T Q x + q T x \boldsymbol{x}^*=\mathrm{arg}\min _{\boldsymbol{x}}\frac{1}{2}\boldsymbol{x}^T\boldsymbol{Qx}+\boldsymbol{q}^T\boldsymbol{x} x∗=argxmin​21​xTQx+qTx
其中 Q \boldsymbol{Q} Q是 n n n维对称正定阵， q ∈ R n \boldsymbol{q}\in \mathbb{R} ^n q∈Rn，共轭梯度法既克服了梯度下降法收敛慢的缺点，又避免存储和计算牛顿类算法所需的二阶梯度信息，其核心原理是：求解矩阵 Q \boldsymbol{Q} Q的共轭向量组 d 0 , d 1 , ⋯ , d n \boldsymbol{d}_0,\boldsymbol{d}_1,\cdots ,\boldsymbol{d}_n d0​,d1​,⋯,dn​作为 n n n个优化方向，由于优化方向间彼此正交，故每次迭代只需沿着一个方向 d i \boldsymbol{d}_i di​寻优而互不影响。所以理论上最多 n n n次迭代就能找到最优解，收敛速度快，但实际应用中需要视具体情况确定阈值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/758aa83424619508e00de145deeb448e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fdad4e38e39843bfced61e24c373ec4/" rel="bookmark">
			日期类的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		感谢大佬的光临各位，希望和大家一起进步，望得到你的三连，互三支持，一起进步
个人主页：LaNzikinh-CSDN博客
文章目录 前言一、日期类的.h文件二.日期类的.cpp文件三.日期类的.测试文件总结 前言 我们前面讲了类与对象的知识、今天我们就用类与对象的知识来完成一个应用，日期类，可以把它理解成一个日期计算机，可以来计算从今天到昨天或者是到一些指定的天数，需要好久等一些运算。
一、日期类的.h文件 我们先来大致看一下这个头文件里有一些什么东西需要我们实现，这里我们用到了友元函数在后面的输入插入流的时候，我们需要用到有原函数的声明去访问那里面的私有成员，还有很多的运算符重载等着我们去构造，还有构造函数等。
using namespace std; class Date { //友元函数 friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const Date&amp; d); friend istream&amp; operator&gt;&gt;(istream&amp; in, Date&amp; d); public: //为什么这个函数要在类里完成，因为他要频繁调用，所以在类里做为内联函数去实现 int GetMonthDay(int year, int month) { assert(month &gt; 0 &amp;&amp; month &lt; 13); //为什么要static，因为要频繁调用，每次都要创建，所以直接放到全局去 static int monthDay[13] = { -1.31,28,31,30,31,30,31,31,30,31,30,31 }; if (month == 2 &amp;&amp; (year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0)) { return 29; } else { return monthDay[month]; } } Date(int year = 2024, int month = 1, int day = 1); bool CheckDate(); bool operator&lt;(const Date&amp; d) const; bool operator&lt;=(const Date&amp; d) const; bool operator&gt;(const Date&amp; d) const; bool operator&gt;=(const Date&amp; d) const; bool operator==(const Date&amp; d) const; bool operator!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fdad4e38e39843bfced61e24c373ec4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e25215e464e5487821c8e6eeed0a212/" rel="bookmark">
			面向小白的 Spring Thymeleaf 教程 完结篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Thymeleaf 表单 在接下来的课程中，我们逐步完成一个简易版的图书管理系统进而更进一步的学习和掌握 Spring 以及 Thymeleaf 框架
首先我们从添加图书开始
图书模型 抽象成java类
上面的UML写成java代码：
public class Book{ // 主键 private long id; // 图书的名称 private String name; // 图书的作者 private String author; // 图书的描述 private String desc; // 图书的编号 private String isbn; // 图书的价格 private double price; // 图书的封面图片 private String pictureUrl; // 省略 getter、setter } 有了这些信息我们就可以通过 Java 对象来描述一本书了
细心的你可能会发现在 Book 类中，我们把 id 主键的类型设置为long 了，这是因为 long 类型的 id 更易于搜索引擎。我们如果期望被搜索引擎能够关注到产品，那么就可以把id 设置为 long，否则还是用 String，因为 long 很容易被机器猜到，所以很容易被爬取数据(既是优点又是缺点，由产品特性来决定)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e25215e464e5487821c8e6eeed0a212/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d35278afc7f16bf47b8a768fe1172e5c/" rel="bookmark">
			DeepMind CEO：AI可以发现室温超导；Llama 3.1算对9.9＞9.11 | AI头条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整理 | 王启隆
出品 | AI 科技大本营（ID：rgznai100）
一分钟速览新闻点！
DeepMind CEO：AI 将增强科学，如设计新药、发现室温超导、破解数学猜想
传谷歌、Meta 竞购雷朋眼镜母公司
340 万浏览！Claude 编程引发开发者热潮
可以解决“9.11 &gt; 9.9”问题？Llama-3.1 模型即将发布
尼克·博斯特罗姆：人工智能会超越人类智能
ElevenLabs 发布 Turbo 2.5 模型，性能提升且支持多语言
英国家庭医生借助 AI 提高 8% 癌症检测率
WPS 辟谣用户文档被用作训练抖音豆包 AI：完全失实 严格遵守个人信息保护法规
OpenAI「造芯」计划再曝新进展：前 TPU 团队华人工程师领衔，最快年内官宣
国内外 AI 要闻
DeepMind CEO：AI 将增强科学，如设计新药、发现室温超导、破解数学猜想
在 2024 世界移动通信大会（MWC24）上，Google DeepMind CEO Demis Hassabis 表示，AI 将在设计新药、发现室温超导体、破解数学猜想及提出新猜想等方面增强科学。Demis Hassabis 因开发出 AlphaGo 而闻名，DeepMind 已发表超 1000 篇研究论文，在多个 AI 领域取得突破。此次大会还讨论了 AI 行业现状、负责任部署以及 Google DeepMind 迄今最大、最有能力的 AI 模型 Gemini 等内容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d35278afc7f16bf47b8a768fe1172e5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9baa11f92e190cf1f0b6cf5a7959aac6/" rel="bookmark">
			深入分析 Android ContentProvider (三)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 深入分析 Android ContentProvider (三)ContentProvider 的高级使用和性能优化1. 高级使用场景1.1. 数据分页加载示例：分页加载 1.2. 使用 Loader 实现异步加载示例：使用 CursorLoader 加载数据 1.3. ContentProvider 与权限管理示例：配置权限 2. 性能优化策略2.1. 缓存机制示例：使用 LruCache 进行缓存 2.2. 批量操作示例：批量插入数据 2.3. 使用异步操作示例：使用 AsyncTask 进行异步查询 2.4. 索引优化示例：创建索引 3. 总结 深入分析 Android ContentProvider (三) ContentProvider 的高级使用和性能优化 在实际应用中，合理使用 ContentProvider 并进行性能优化是确保应用高效运行的关键。以下内容将介绍一些高级使用场景和性能优化策略。
1. 高级使用场景 1.1. 数据分页加载 对于大量数据的查询，可以通过分页加载提高效率。分页加载常用于列表视图中，以避免一次性加载所有数据导致的性能问题。
示例：分页加载 在 query 方法中实现分页加载：
@Override public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) { int limit = 20; // 每页加载的数据量 int offset = 0; // 偏移量 String limitClause = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9baa11f92e190cf1f0b6cf5a7959aac6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6aa8f6ee0c78e344a80a6561a88ba02a/" rel="bookmark">
			关于海康威视&#43;WPF&#43;MVVM实时取图代码整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		依赖项：MvCameraControl.Net.dll 版本4.4.0.2
相机：MV-CH250-90YM
背景：使用自定义WPF控件显示图片，通过实现INotifyPropertyChanged接口，实现PropertyChanged事件，修改图像控件的显示值。海康自带Demo虽然有WPF的使用示例，底层还是使用Winform的WindowsFormHost。我的代码彻底抛弃Winform，通过多线程+队列+回调取图+Dispatcher.Invoke实现不卡顿，实时显示海康相机的结果图。
代码说明：
这段代码是一个WPF应用程序的一部分，主要用于处理和显示从相机捕获的图像。它使用了Hikvision的MvCameraControl库来控制和获取图像。以下是代码的主要逻辑：
在构造函数中，它初始化了一些变量，启动了一个接收线程用于处理和显示图像，并调用了InitService函数来初始化相机。
InitService函数中，首先初始化了SDK，枚举设备并打开第一个设备。然后设置触发模式为off，设置了图像节点数量，注册了回调函数，并开始抓图。
FrameGrabedEventHandler函数是图像抓取的回调函数，每当新的图像被抓取时，它会被调用，并将新的图像帧添加到m_frameList队列中。
ShowThread函数是在一个单独的线程中运行的，用于处理和显示m_frameList队列中的图像帧。它会将图像帧转换为Bitmap，然后使用Dispatcher.Invoke将Bitmap显示在UI上。
btnStopGrab_Click和btnStartGrab_Click函数分别用于停止和开始图像抓取。
GetTriggerMode和btnGetSetting_Click函数用于获取相机的设置，btnSetSetting_Click函数用于设置相机的参数。
代码如下：
using MvCameraControl; using System.Diagnostics; using System.Drawing; using System.Drawing.Imaging; using System.IO; using System.Windows; using System.Windows.Controls; using System.Windows.Media.Imaging; using System.Windows.Threading; using WpfApp1.ViewModel; namespace WpfApp1 { /// &lt;summary&gt; /// PolishinLargeScreen.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class PolishinLargeScreen : UserControl { const DeviceTLayerType devLayerType = DeviceTLayerType.MvGigEDevice | DeviceTLayerType.MvUsbDevice | DeviceTLayerType.MvGenTLCameraLinkDevice | DeviceTLayerType.MvGenTLCXPDevice | DeviceTLayerType.MvGenTLXoFDevice; IDevice device = null; Thread receiveThread = null; // ch:接收图像线程 | en: Receive image thread bool m_bShowLoop = true; // 线程控制变量 | thread looping flag bool isGrabbing = false; // ch:是否正在取图 | en: Grabbing flag List&lt;IFrameOut&gt; m_frameList = new List&lt;IFrameOut&gt;(); // 图像缓存列表 | frame data list Mutex m_mutex = new Mutex(); // 锁，保证多线程安全 | mutex PolishinLargeViewModel viewModel; public PolishinLargeScreen() { InitializeComponent(); viewModel = new PolishinLargeViewModel(); this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6aa8f6ee0c78e344a80a6561a88ba02a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11a934c2dfc4ad950c495698cf5ce800/" rel="bookmark">
			nodejs启动项目报错 Error: listen EACCES: permission denied 0.0.0.0:5000
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nodejs启动项目报错 Error: listen EACCES: permission denied 0.0.0.0:5000，截图如下：
解决方法
在管理员权限下打开 CMD（命令行）并运行：
net stop winnatnet start winnat 执行完成后在此通过nodejs启动项目即可成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bebf748e90bff767961b2158cc9739a0/" rel="bookmark">
			MongoDB教程（十九）：MongoDB全文检索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💝💝💝首先，欢迎各位来到我的博客，很高兴能够在这里和您见面！希望您在这里不仅可以有所收获，同时也能感受到一份轻松欢乐的氛围，祝你生活愉快！
文章目录 引言一、全文索引概述二、创建全文索引步骤 1：确定索引字段步骤 2：创建全文索引 三、执行全文检索步骤 1：构建查询步骤 2：解释查询结果 四、案例代码：实现全文检索1. 创建全文索引2. 插入示例数据3. 执行全文检索4. 输出结果 五、全文检索的高级选项六、结论 引言 在现代应用程序中，提供强大的搜索功能已经成为提升用户体验的关键因素。MongoDB 通过引入全文索引，为开发者提供了一个高效且易于使用的全文检索解决方案。本文将深入探讨 MongoDB 全文索引的创建、配置及使用，通过具体的案例代码展示如何在 MongoDB 中实现全文检索。
一、全文索引概述 全文索引是 MongoDB 用于支持文本字段的全文搜索功能。当创建了全文索引后，可以使用 $text 操作符进行文本搜索，MongoDB 会返回与给定搜索词匹配的文档。
二、创建全文索引 步骤 1：确定索引字段 首先，你需要确定哪些字段需要被全文索引。例如，假设我们有一个 articles 集合，其中包含 title 和 content 字段，我们想要在这两个字段上创建全文索引。
步骤 2：创建全文索引 在 MongoDB shell 中，使用 createIndex() 方法来创建全文索引：
db.articles.createIndex( { title: "text", content: "text" } ); 这将创建一个全文索引，覆盖 title 和 content 字段。
三、执行全文检索 步骤 1：构建查询 使用 $text 操作符来构建全文检索查询。例如，如果我们想搜索包含 “MongoDB” 和 “tutorial” 的文章：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bebf748e90bff767961b2158cc9739a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69ffbf9e1494836e6aa47a5b79d8edb6/" rel="bookmark">
			Ubuntu-迁移22.04从机械盘到固态盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用dd迁移22.04到新硬盘 一、概述二、详细过程1. 拷贝数据2. 更新硬盘信息3. 修改Grub 引导4. 参考链接 一、概述 Ubuntu：22.04
记录一下把机械硬盘中的Ubuntu移动到新的固态硬盘中，原机械硬盘大小是1T，目标固态硬盘为1T。
之前的Ubuntu安装的是全盘安装模式。
二、详细过程 Linux 一切皆文件, 所以拷贝系统其实就是拷贝文件！
机械盘： /dev/sda
固态盘：/dev/sdb
1. 拷贝数据 我使用dd 命令来进行字节级别的迁移，我的原根目录所在的分区是 /dev/sda，新固态盘是 /dev/sdb。
命令如下
dd if=/dev/sda of=/dev/sdb 因为dd命令没有展示中间过程，因此在另外一个终端，使用另一条命令来输出当前进度：
具体想了解下面命令含义的，可以参考 Linux-查看dd命令进度
sudo watch -n 5 pkill -USR1 ^dd$ 看机械盘的性能，我的1T基本上拷贝了 9 小时，速度从 60/Mb/s 掉到了 30 Mb/s 。还是比较慢
2. 更新硬盘信息 先卸载挂载 umount /dev/sdb1　修复磁盘
e2fsck命令用于检查使用 Linux ext2 档案系统的 partition 是否正常工作 e2fsck -f /dev/sdb1 调整ext2\ext3\ext4文件系统的大小 resize2fs /dev/sdb1 3. 修改Grub 引导 先安装 boot-repair 工具
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69ffbf9e1494836e6aa47a5b79d8edb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c278104febabe982f1b003220449c1e4/" rel="bookmark">
			在Ubuntu上安装、配置和调优Zerotier服务器以支持IPv6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嘿，朋友们！今天我们来谈谈如何在Ubuntu上安装、配置和调优Zerotier服务器，让它支持IPv6。废话不多说，我们直接进入正题。
首先，我要夸夸那款让我爱不释手的免费云服务器——三丰云。这家免费云服务器的配置简直不要太棒！1核CPU、1G内存、10G硬盘和5M带宽，真是不错的选择。我今天就是在三丰云的服务器上进行部署和测试的。
现在让我们先来简要介绍一下Zerotier服务器。这个服务器是一个神奇的工具，它能够让你在不同设备之间创建虚拟局域网（VPN），实现安全的互联。使用Zerotier，你可以轻松连接设备，实现高效的数据传输，而且它还支持IPv6，真是太棒了！
好，接下来是我们的主菜，如何在Ubuntu上安装、配置和调优Zerotier服务器以支持IPv6。让我们来一步一步走。
第一步，我们需要安装Zerotier软件包。打开终端，输入以下命令：
sudo apt-get install zerotier-one 安装完成后，我们需要启动Zerotier服务。输入以下命令：
sudo systemctl start zerotier-one 现在，我们需要获取设备的Zerotier ID。输入以下命令：
sudo zerotier-cli info 你会看到一个类似于"200xxxxxxxxx"的Zerotier ID。记住它，我们会在后面用到。
接下来，我们需要将设备加入到Zerotier网络中。输入以下命令，将设备加入到指定的网络：
sudo zerotier-cli join &lt;network-id&gt; 将&lt;network-id&gt;替换为你要加入的网络的ID。这样，你的设备就成功加入到Zerotier网络了。
现在，我们需要在Zerotier服务器上启用IPv6支持。打开终端，输入以下命令：
sudo zerotier-cli set &lt;network-id&gt; allowGlobal=true 将&lt;network-id&gt;替换为你的Zerotier网络的ID。这个命令会启用IPv6支持。
最后，我们要在Ubuntu上配置IPv6。打开网络设置，选择你的网络接口，然后点击"IPv6"选项卡。选择"自动"或者"手动"配置，根据你的网络要求进行设置。
好了，现在我们的Zerotier服务器已经安装、配置和调优完毕，并且支持IPv6了！你可以享受安全、高效的互联体验了。
希望这篇博客对你有所帮助。如果你有任何问题或者需要进一步的指导，请随时留言。我会尽快回复你。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc46dad5fa607ab8f376e83a60d10ff4/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(040)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
131、pandas.Series.round方法
131-1、语法
131-2、参数
131-3、功能
131-4、返回值
131-5、说明
131-6、用法
131-6-1、数据准备
131-6-2、代码示例
131-6-3、结果输出
132、pandas.Series.lt方法
132-1、语法
132-2、参数
132-3、功能
132-4、返回值
132-5、说明
132-6、用法
132-6-1、数据准备
132-6-2、代码示例
132-6-3、结果输出
133、pandas.Series.gt方法
133-1、语法
133-2、参数
133-3、功能
133-4、返回值
133-5、说明
133-6、用法
133-6-1、数据准备
133-6-2、代码示例
133-6-3、结果输出
134、pandas.Series.le方法
134-1、语法
134-2、参数
134-3、功能
134-4、返回值
134-5、说明
134-6、用法
134-6-1、数据准备
134-6-2、代码示例
134-6-3、结果输出
135、pandas.Series.ge方法
135-1、语法
135-2、参数
135-3、功能
135-4、返回值
135-5、说明
135-6、用法
135-6-1、数据准备
135-6-2、代码示例
135-6-3、结果输出
二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 131、pandas.Series.round方法 131-1、语法 # 131、pandas.Series.round方法 pandas.Series.round(decimals=0, *args, **kwargs) Round each value in a Series to the given number of decimals.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc46dad5fa607ab8f376e83a60d10ff4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3454ed254a6930a396f6e1be63ed6671/" rel="bookmark">
			如何学习Python：糙快猛的大数据之路（学习地图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这个AI和大数据主宰的时代,Python无疑是最炙手可热的编程语言之一。无论你是想转行还是提升技能,学习Python都是一个明智之选。但是,该如何开始呢?今天,让我们聊聊"糙快猛"的Python学习之道。
什么是"糙快猛"学习法? "糙快猛"学习法,顾名思义,就是:
糙:不追求完美,允许存在粗糙快:以最快的速度推进猛:勇往直前,不畏困难 这种方法强调在学习过程中保持前进的动力,而不是过分追求完美主义。
我的故事:从0到1的大数据之旅 作为一个曾经的Python小白,我深知学习编程的困难。还记得我刚开始学习时,常常被各种概念和语法搞得头昏脑胀。有一次,我花了整整一周时间来理解"列表推导式"这个概念。
那时候,我遵循传统的学习方法:细嚼慢咽,力求完美。结果呢?进度缓慢,常常陷入自我怀疑的泥潭。
直到有一天,我偶然看到"糙快猛"这个词,灵光乍现。我决定改变学习策略,开始了我的"糙快猛"Python学习之旅。
"糙快猛"学习Python的实践指南 1. 从简单的项目开始,快速上手 别被复杂的概念吓到,先从简单的项目开始。比如,写一个简单的计算器:
def calculator(): operation = input("请选择运算 (+, -, *, /): ") num1 = float(input("请输入第一个数字: ")) num2 = float(input("请输入第二个数字: ")) if operation == '+': result = num1 + num2 elif operation == '-': result = num1 - num2 elif operation == '*': result = num1 * num2 elif operation == '/': result = num1 / num2 else: return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3454ed254a6930a396f6e1be63ed6671/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df1f67ebc6720ca6569c9745bd18291f/" rel="bookmark">
			【AI大模型】程序员AI的未来——Copilot还是Claude3.5 Sonnet？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期，Anthropic发布了Claude 3.5 的“大杯”模型 —— Claude 3.5 Sonnet！
这次发布的 Sonnet 代表意大利的“十四行诗”，结构复杂，在智能水平、功能多样性和处理能力上都有所提升，能够应对更复杂的认知任务，提供更高质量的输出。
Claude 3.5 Sonnet 作为 Claude 3.5 系列的首个模型版本，在行业智能水平上取得了显著提升。它不仅超越了竞争对手的性能，还超越了自家的上一代“超大杯” Claude 3 Opus，同时保持了与中端模型 Claude 3 Sonnet 相同的速度和成本优势。
Sonnet 在研究生级推理（GPQA）、本科级知识（MMLU）和编程能力（HumanEval）方面都设立了全新的行业标准。
它在理解细微差别、幽默和复杂指令方面有显著提高，并能以自然、易于理解的语调撰写高质量内容。其运行速度是 Claude 3 Opus 的两倍，性能提升与成本效益相结合，使 Claude 3.5 Sonnet 成为复杂任务的理想选择，例如上下文敏感的客户支持和多步骤工作流程的管理。
划重点，在编程能力方面都设立了全新的行业标准。
我记得，ChatGPT4o的Copilot号称最强编程插件。
👉 GPT功能：
GPT-4o知识问答：支持1000+token上下文记忆功能最强代码大模型Code Copilot：代码自动补全、代码优化建议、代码重构等DALL-E AI绘画：AI绘画 + 剪辑 = 自媒体新时代私信哪吒，直接使用GPT-4o 下面从7个方面，横向对比一下ChatGPT4o和Claude 3.5 Sonnet，看谁的编程能力更强。
round 1：图片识别能力 上传一张图片，是经典算法题“猴子吃桃”的题目。
PS：只上传图片，啥也不说，对比一下ChatGPT4o和Claude3.5 Sonnet的图片识别能力和理解能力。
原图：
ChatGPT4o ChatGPT4o识别了图片内容，不过默认转化为了英文。
ChatGPT4o给出了解决方案，默认是Python语言。
ChatGPT4o最后给出了代码的解释说明：
Claude3.5 Sonnet Claude3.5 Sonnet识别了图片内容，默认也是英文。
Claude也识别出这是一道算法题，并给出了解决问题需要的算法，不过只给出了一个简单的解题思路。
图片识别能力小结： 在我看来，ChatGPT4o完全理解了我的用意，不仅识别了图片内容，还给出了解题思路、代码示例和解释说明，图片识别能力堪称完美。
反观Claude3.5 Sonnet，只是识别了图片中的内容，给出了了一个简单的解题思路。
图片识别能力，ChatGPT4o完胜。 round 2：代码能力 Prompt：请根据上面描述，给出解题思路，通过Java代码解答此题，关键代码添加注释，并根据示例中的输入输出进行代码测试，代码如果有错误，请重新修改代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df1f67ebc6720ca6569c9745bd18291f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0a33944eddad25da76398e35cf0d904/" rel="bookmark">
			PHP SimpleXML
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PHP SimpleXML PHP的SimpleXML扩展提供了一个非常方便的方式来处理XML数据。它是PHP内置的，因此不需要安装额外的库。SimpleXML可以将XML数据转换成对象，使得操作XML变得简单直观。本文将详细介绍SimpleXML的使用方法，包括加载XML、访问和修改数据、以及将SimpleXML对象转换回XML字符串。
加载XML 要使用SimpleXML，首先需要加载XML数据。这可以通过simplexml_load_file()函数从文件加载，或者通过simplexml_load_string()函数从字符串加载。
$xmlString = &lt;&lt;&lt;XML &lt;book&gt; &lt;title&gt;PHP SimpleXML教程&lt;/title&gt; &lt;author&gt;作者&lt;/author&gt; &lt;/book&gt; XML; // 从字符串加载XML $xml = simplexml_load_string($xmlString); // 从文件加载XML $xml = simplexml_load_file('path/to/file.xml'); 访问和修改数据 加载XML后，你可以像访问对象属性一样访问XML元素。
echo $xml-&gt;title; // 输出: PHP SimpleXML教程 echo $xml-&gt;author; // 输出: 作者 要修改数据，只需简单地给属性赋新值。
$xml-&gt;title = '新的标题'; $xml-&gt;author = '新的作者'; 如果你需要访问带有命名空间的XML元素，可以使用children()方法。
$xml = simplexml_load_string('&lt;?xml version="1.0" ?&gt;&lt;root xmlns:h="http://www.w3.org/TR/html4/"&gt;&lt;h:table&gt;&lt;h:tr&gt;&lt;h:td&gt;Apples&lt;/h:td&gt;&lt;h:td&gt;Bananas&lt;/h:td&gt;&lt;/h:tr&gt;&lt;/h:table&gt;&lt;/root&gt;'); echo $xml-&gt;children('h', true)-&gt;table-&gt;tr-&gt;td[0]; // 输出: Apples 遍历XML SimpleXML支持使用foreach循环遍历XML元素。
foreach ($xml-&gt;children() as $child) { echo $child-&gt;getName() . ': ' .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0a33944eddad25da76398e35cf0d904/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/839b230ed3d10a7c018b03486fd77ac0/" rel="bookmark">
			【Python】Pandas简要教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、简介二、Pandas基本数据结构及其方法2.1 Series2.2 DataFrame 三、标签和索引四、常用方法4.1 数据读取和写入4.11 🟢CSV文件4.12🟢Excel文件4.13 其它文件 4.2 字符串处理4.3 表格拼接4.4 时间数据处理 一、简介 Pandas 是一个用于数据操作和分析的开源 Python 库。它提供了高效的数据结构和数据分析工具，特别适合处理结构化数据（如表格数据）。Pandas 在数据清洗、预处理、统计分析、数据可视化等方面有广泛的应用。
Github：https://github.com/pandas-dev/pandas
User Guide：https://pandas.pydata.org/docs/user_guide/index.html
主要特点：
易用的数据结构：
Series：一维数组，类似于 Python 的列表或字典。DataFrame：二维数据结构，类似于 Excel 表格或 SQL 表。 数据操作：
支持对数据进行增删改查操作。提供丰富的数据清洗和预处理功能，包括缺失值处理、数据过滤、分组、聚合等。支持多种数据格式的读写，如 CSV、Excel、SQL、JSON 等。 高效的性能：
基于 NumPy 实现，具有高效的计算性能。支持多种加速库，如 Dask、Modin，可以在大数据处理时提升性能。 数据可视化：
与 Matplotlib、Seaborn 等可视化库无缝集成，方便生成各种类型的图表。 二、Pandas基本数据结构及其方法 2.1 Series pd.Series是Pandas库中的一种基本数据结构，用于表示一维的带标签数组。它既可以包含整数、浮点数、字符串等数据类型，也可以包含其他Python对象。
可以通过多种方式创建一个Series：
import pandas as pd # 通过列表创建 s = pd.Series([1, 3, 5, 7, 9]) # 通过字典创建 data = {'a': 1, 'b': 3, 'c': 5} s = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/839b230ed3d10a7c018b03486fd77ac0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dab85cd759ab3d76a615ce4c2657cecf/" rel="bookmark">
			langchain 入门指南 - 让 AI 记住你说过的话
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站。
在我们通过 web 端的聊天界面与 AI 对话时，AI 会记住你说过的话。这样，你可以在对话中引用之前的话语，或者在之后的对话中提到之前的话语。
但是如果我们像下面这样调用 API 的时候，就会发现 AI 不会记住我们之前说过的话：
from langchain_openai import ChatOpenAI chat = ChatOpenAI( model="yi-large", temperature=0.3, max_tokens=200, api_key='your key', base_url="https://api.lingyiwanwu.com/v1", ) response = chat.invoke('今天广州天气晴朗，26~35摄氏度。') print(response.content) response = chat.invoke('今天广州适合穿什么？') print(response.content) 输出：
这句话的意思是今天广州的天气非常好，晴朗无云，气温在26摄氏度到35摄氏度之间。这是一个适合户外活动的好天气，但也要注意防晒和补水，因为气温较高。 很抱歉，我无法提供实时天气信息或建议。要了解今天的广州适合穿什么，您可以查看当地的天气预报，了解当前的气温、湿度和天气状况，然后根据这些信息选择合适的衣物。 通常，广州属于亚热带季风气候，夏季炎热潮湿，冬季温和，春秋季节宜人。根据季节和天气预报，您可以选择穿短袖、长袖、薄外套或厚外套等。 别忘了查看是否需要携带雨具，因为广州的降雨量也比较丰富。 虽然我们告诉了 LLM 今天广州的天气，但是在第二次调用的时候，AI 并没有记住我们之前说过的话，所以不能依据当前的天气状况给我提供穿衣建议。
为什么 AI 不会记住我说过的话 这是因为大模型本身并不具备记忆功能。在我们每次使用大模型的 API 的时候，它都是基于训练模型时候的数据以及我们传递的信息来进行推理的。
如果让大模型记住我们说过的话，那么它需要存储的信息量会非常庞大，这样的成本是非常高昂的。
同时，如果每一次调用的时候，都在一个庞大的上下文中进行推理，那么推理的时间也会非常长，消耗的资源会非常多。
所以，大模型通常是不会记住我们说过的话的。
解决办法：我们自己记住 既然大模型记不住我们说过的话，那唯一的办法就是我们自己记住，然后下次调用的时候，将之前的话语传递给 AI。
from langchain_openai import ChatOpenAI from langchain_core.messages import HumanMessage, AIMessage chat = ChatOpenAI( model="yi-large", temperature=0.3, max_tokens=200, api_key='your key', base_url="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dab85cd759ab3d76a615ce4c2657cecf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01aa7a4ab4ee29c97aa3d5b317a0cb34/" rel="bookmark">
			数据挖掘-数据预处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来自🥬🐶程序员 Truraly | 田园 的博客，最新文章首发于：田园幻想乡 | 原文链接 | github （欢迎关注）
文章目录 3.3.1 数据的中心趋势平均数和加权平均数众数，中位数和均值描述数据的离散程度 &amp; 箱线图其他描述数据的方法 3.4 数据清洗3.4.1 缺失值3.4.2 数据清洗 3.5 数据集成和转换3.5.3 数据转换 3.6 数据规约和数据变换3.6.2 数据离散化 数据类型：
名称型：区别性 比如：性别顺序型：区别性，顺序性 比如：身高间隔型：区别性，顺序性，可加减 比如：温度比率型：区别性，顺序性，可加减，可乘除 比如：百分比 为什么要预处理数据：
数据不完整，比如缺失值数据不一致，比如单位不一致有噪声，比如错误数据 3.3.1 数据的中心趋势 平均数和加权平均数 首先这里有一组数据
1,,53,22,39,73,9,14 （算数）平均值：
x ‾ = 1 n ∑ i = 1 n x i \overline{x}=\frac{1}{n}\sum_{i=1}^{n}x_{i} x=n1​∑i=1n​xi​
加权平均值：
x ‾ = ∑ i = 1 n w i x i ∑ i = 1 n w i \overline{x}=\frac{\sum_{i=1}^{n}w_{i}x_{i}}{\sum_{i=1}^{n}w_{i}} x=∑i=1n​wi​∑i=1n​wi​xi​​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01aa7a4ab4ee29c97aa3d5b317a0cb34/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/123/">«</a>
	<span class="pagination__item pagination__item--current">124/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/125/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>