<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a27b6b8bf0c62127eae5f6995fe70c16/" rel="bookmark">
			冒泡排序与快速排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主主页: 码农派大星.
数据结构专栏:Java数据结构
数据库专栏:MySQL数据库
关注博主带你了解更多数据结构知识
1.冒泡排序 冒泡排序
private static void swap(int[] arrary,int i,int j){ int tmp = arrary[i]; arrary[i] = arrary[j]; arrary[j] = tmp; public static void bubbleSort(int[] arrary){ for (int i = 0; i &lt;arrary.length-1 ; i++) { for (int j = 0; j &lt; arrary.length-1-i; j++) { if(arrary[j]&gt; arrary[j+1]){ swap(arrary,j,j+1); } } } return arrary; } 冒泡排序总结
1. 冒泡排序是一种非常容易理解的排序
2. 时间复杂度：O(N^2)
3. 空间复杂度：O(1)
4. 稳定性：稳定 2.快速排序 快速排序是Hoare于1962年提出的一种二叉树结构的交换排序方法，其基本思想为：任取待排序元素序列中的某元 素作为基准值，按照该排序码将待排序集合分割成两子序列，左子序列中所有元素均小于基准值，右子序列中所有 元素均大于基准值，然后最左右子序列重复该过程，直到所有元素都排列在相应位置上为止。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a27b6b8bf0c62127eae5f6995fe70c16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b87e4919241f4b7878e2f0e0faf5d909/" rel="bookmark">
			【吊打面试官系列】Java高并发篇 - 什么是自旋 ？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 大家好，我是锋哥。今天分享关于 【什么是自旋 ？】面试题，希望对大家有帮助；
什么是自旋 ？ 很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。 1000道 互联网大厂Java工程师 精选面试题-Java资源分享网 既然synchronized 里面的代码执行得非常快，不妨让等待锁的线 程不要被阻塞，而是在 synchronized 的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccd24cbb2f72b107d866bdd1fe99d20e/" rel="bookmark">
			Python魔法之旅-魔法方法(10)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、概述
1、定义
2、作用
二、应用场景
1、构造和析构
2、操作符重载
3、字符串和表示
4、容器管理
5、可调用对象
6、上下文管理
7、属性访问和描述符
8、迭代器和生成器
9、数值类型
10、复制和序列化
11、自定义元类行为
12、自定义类行为
13、类型检查和转换
14、自定义异常
三、学习方法
1、理解基础
2、查阅文档
3、编写示例
4、实践应用
5、阅读他人代码
6、参加社区讨论
7、持续学习
8、练习与总结
9、注意兼容性
10、避免过度使用
四、魔法方法
32、__index__方法
32-1、语法
32-2、参数
32-3、功能
32-4、返回值
32-5、说明
32-6、用法
33、__init__方法
33-1、语法
33-2、参数
33-3、功能
33-4、返回值
33-5、说明
33-6、用法
34、__init_subclass__方法
34-1、语法
34-2、参数
34-3、功能
34-4、返回值
34-5、说明
34-6、用法
五、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、博客个人主页
一、概述 1、定义 魔法方法(Magic Methods/Special Methods，也称特殊方法或双下划线方法)是Python中一类具有特殊命名规则的方法，它们的名称通常以双下划线(`__`)开头和结尾。
魔法方法用于在特定情况下自动被Python解释器调用，而不需要显式地调用它们，它们提供了一种机制，让你可以定义自定义类时具有与内置类型相似的行为。
2、作用 魔法方法允许开发者重载Python中的一些内置操作或函数的行为，从而为自定义的类添加特殊的功能。
二、应用场景 1、构造和析构 1-1、__init__(self, [args...])：在创建对象时初始化属性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccd24cbb2f72b107d866bdd1fe99d20e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cf63172e9a68b6e6378931f8fcfc3e7/" rel="bookmark">
			生成随机图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 package com.zhuguohui.app.lib.tools; /** * Created by zhuguohui * Date: 2024/6/1 * Time: 13:39 * Desc:获取随机图片 */ public class RandomImage { // static final String url= "https://picsum.photos/%d/%d?random=%d"; static final String url= "https://source.unsplash.com/%dx%d/?beauty&amp;random=%d"; public static String get(int width,int height){ return String.format(url,width,height,(int)(Math.random()*100)); } } 上面的代码可以生成随机图片。而且内容可以指定 **“https://source.unsplash.com/%dx%d/?beauty&amp;random=%d”**比如？后面的beauty返回的就是美女图片
效果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07fb00bf5a514d6ae1065824bed31ca8/" rel="bookmark">
			Salesforce推出Einstein 1 Studio：用于自定义Einstein Copilot并将人工智能嵌入任何CRM应用程序的低代码人工智能工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、关键要点 1. Salesforce管理员和开发人员现在可以在每个Salesforce应用程序和工作流程中构建、定制和嵌入人工智能，包括Einstein Copilot。
2. Einstein 1 Studio与数据云深度集成，通过对客户数据和元数据的全面理解，解锁并统一被捕获的数据和基础人工智能模型
3. 新的开拓者人工智能课程——包括Einstein Copilot和Prompt Builder——在Salesforce的免费在线学习平台上为600多万开拓者介绍职业道路和技能
旧金山–2024年3月6日–在Salesforce的开发者大会开拓者大会上，Salesforce（NYSE:CRM）宣布推出Einstein 1 Studio，这是一套低代码工具，使Salesforce管理员和开发者能够定制Einstein Copilot-CRM的对话式人工智能助手-并将人工智能无缝嵌入任何应用程序，以满足每个客户和员工的体验。
Einstein 1 Studio包括用于创建自定义人工智能动作以完成特定业务任务的Copilot Builder，用于在工作流程中构建和激活自定义提示的Prompt Builder，以及用户可以在其中构建或导入各种人工智能模型的Model Builder。这使企业能够在Salesforce的Einstein 1平台上提供值得信赖的人工智能体验，这些体验是根据客户的需求量身定制的。
二、为什么重要 企业在整个业务中释放人工智能的力量方面面临着重大挑战，十分之九的it专业人士表示，生成性人工智能迫使他们改变了新技术的实施和使用方式。他们需要直观的用户界面，以便在工作流程中轻松与人工智能交互；适合其用例的人工智能模型；以及访问可信的客户和业务数据，以建立人工智能模型并确保准确、相关的输出。
Salesforce的Einstein 1平台将用户界面、各种人工智能模型和数据集成在一个元数据驱动的平台中。这就是Einstein 1 Studio工具的动力所在，促进了Einstein Copilot的低代码和无代码定制，以及构建和修改嵌入式提示和操作，这些提示和操作在每个Salesforce应用程序的工作流程中无缝连接到人工智能模型。Einstein 1 Studio与数据云深度集成，通过全面了解客户的数据和元数据，安全地解锁和统一被捕获的数据和基础人工智能模型。
使用Einstein 1 Studio更深入：Salesforce管理员和开发人员可以使用以下新的Einstein 2 Studio工具，通过在每个Salesforce应用程序和工作流程中定制人工智能，构建下一代人工智能应用程序。这将有助于公司提高生产力，改善客户体验，并提高利润率。这些工具包括：
1. Copilot Builder 创建人工智能动作来完成业务任务（测试版）——Copilot生成器帮助每家公司为其业务配置和定制Einstein Copilot。Salesforce管理员和开发人员可以使用他们现有的工具，如Apex、Flow和MuleSoft API，以及提示等新的生成人工智能组件，使Einstein Copilot能够完成工作流程中的任务。Einstein Copilot可以利用这些自定义操作在任何Salesforce应用程序或外部系统中完成任务。
2. 提示生成器 轻松制作自定义和可信的人工智能提示（GA）——提示生成器使管理员和开发人员能够在无需编码的情况下创建自定义、可重复使用的人工智能提醒，简化复杂流程并推动业务创新。这不仅将生成人工智能的使用范围扩大到对话界面之外，还允许客户设计和重新调整提示的用途，以便在其他体验中使用。例如，可以将自定义提示作为按钮无缝嵌入联系人记录中，使联络中心的代理人能够一键获取客户所有上报案例的快照。
3. 模型生成器 选择LLM或根据要做的工作构建人工智能模型（GA）——与其他将业务限制在单个大型语言模型（LLM）的解决方案不同，Einstein 1 Studio提供了连接到各种人工智能模型的灵活性。此外，Model Builder是一种无代码、低代码和亲代码的方式，供公司根据其数据云数据构建自己的预测人工智能模型。对于生成型人工智能，Model Builder允许客户从Salesforce管理的LLM中进行选择，或者自带模型。企业可以使用Salesforce合作伙伴提供的预测和生成人工智能模型和服务，包括通过亚马逊Bedrock和亚马逊SageMaker提供的亚马逊网络服务（AWS）、Anthropic、Azure OpenAI、Cohere、Databricks、谷歌云的Vertex AI和OpenAI，并在数据云数据上训练或微调选定模型，而无需移动或复制数据。
4. 爱因斯坦信任层 根据您的条件部署您可以信任的人工智能：爱因斯坦信任层是为企业人工智能设计的，它是一系列功能，可以帮助公司在不损害安全或安全标准的情况下从生成人工智能中受益。爱因斯坦信任层的新功能是客户配置的数据屏蔽，使管理员能够选择他们想要屏蔽的字段，从而提供更好的控制。此外，从人工智能提示和响应中收集的审计跟踪和反馈数据现在存储在数据云中，可以通过Flow和其他Einstein 1平台工具轻松报告或用于自动警报。
三、Salesforce的官方价值主张 “客户一直喜欢定制Salesforce是多么容易。我们新的Einstein 1 Studio使管理员和开发人员能够轻松地构建和定制Einstein Copilot，并将人工智能应用嵌入Salesforce内的工作流程中，以适应公司和行业的特定要求，”Salesforce AI首席执行官Clara Shih如是说。
“我们新的Einstein 1 Studio使管理员和开发人员能够轻松构建和定制Einstein Copilot，并将人工智能应用程序嵌入Salesforce的工作流程中，以满足公司和行业的特定要求。”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07fb00bf5a514d6ae1065824bed31ca8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c9167474270776e966102823f7c1291/" rel="bookmark">
			深入分析 Android Service (完)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 深入分析 Android Service (完)1. Service 的生命周期管理2. Service 的生命周期方法2.1 onCreate()2.2 onStartCommand(Intent intent, int flags, int startId)2.3 onBind(Intent intent)2.4 onUnbind(Intent intent)2.5 onRebind(Intent intent)2.6 onDestroy() 3. Service 重启策略4. 使用 Service 进行前台任务5. 实现前台服务示例5.1 创建前台服务5.2 启动前台服务 6. Service 的优化和调试6.1 使用 JobScheduler 替代传统 Service6.2 使用 WorkManager 处理后台任务6.3 调试和监控 7. 示例代码汇总7.1 服务端代码（Messenger）7.2 客户端代码（Messenger）7.3 服务端代码（AIDL）7.4 客户端代码（AIDL） 8. 总结 深入分析 Android Service (完) 1. Service 的生命周期管理 Service 的生命周期管理是确保 Service 能够正确启动、运行、停止和清理资源的关键。理解 Service 的生命周期方法可以帮助开发者更好地管理和优化 Service。
2. Service 的生命周期方法 Service 的主要生命周期方法包括：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c9167474270776e966102823f7c1291/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05899385ba72c74a0787299f01003dc9/" rel="bookmark">
			算法思想总结：哈希表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、哈希表剖析 1、哈希表底层：通过对C++的学习，我们知道STL中哈希表底层是用的链地址法封装的开散列。
2、哈希表作用：存储数据的容器，插入、删除、搜索的时间复杂度都是O（1），无序。
3、什么时候使用哈希表：需要频繁查找数据的场景。
4、OJ中如何使用哈希表？？？
（1）STL中的容器（适用所有场景，比如字符串相关、数据映射下标）
（2）数组模拟简易哈希表（减小时间损耗，容器的封装有一定代价）—&gt;大多以下两种情况适用
情况1：（char）涉及到字符串中的“字符” ，hash[26]可以映射所有的字母。
情况2：（int）数据范围较小的时候
二、两数之和 . - 力扣（LeetCode）
解法2代码： class Solution { public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { unordered_map&lt;int,int&gt; hash; //数值和下标的映射关系 int n=nums.size(); for(int i=0;i&lt;n;++i) { int x=target-nums[i]; if(hash.count(x)) return {hash[x],i}; hash[nums[i]]=i; } return {-1,-1}; } }; 三、判定是否互为字符重排 . - 力扣（LeetCode）
解法2代码：
class Solution { public: bool CheckPermutation(string s1, string s2) { //小优化 if(s1.size()!=s2.size()) return false; //用哈希表 int hash[26]={0}; for(char&amp;ch:s1) ++hash[ch-'a']; //检测第二个数组 for(char&amp;ch:s2) if(--hash[ch-'a']&lt;0) return false; return true; } }; 四、存在重复元素I .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05899385ba72c74a0787299f01003dc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01ed3872366b093bac96a1791e4bd81a/" rel="bookmark">
			HR青睐的数据库热门考题——事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇会加入个人的所谓鱼式疯言
❤️❤️❤️鱼式疯言:❤️❤️❤️此疯言非彼疯言
而是理解过并总结出来通俗易懂的大白话,
小编会尽可能的在每个概念后插入鱼式疯言,帮助大家理解的.
🤭🤭🤭可能说的不是那么严谨.但小编初心是能让更多人能接受我们这个概念 ！！！
前言 在上一篇MySQL数据库的文章中，我们提及HR喜欢考的 一个话题 就是：索引 。
我们讲解了
索引是什么？ 索引就是相当于书本的一种特殊的 目录 , 对于 特定的索引列 的查询能够加快 查询的速度
索引的使用特点 像 主键 ，unique ， 外键 会自带索引， 但不能通过 SQL 删除这些索引。 我们也可以通过 SQL 来创建 自身的索引 ，并且删除 自己创建 的索引
索引的不足 创建索引会占用 额外的内存空间 索引可能会加快，减慢，数据库的 增删改 操作的速度 。 索引底层的数据结构 底层是一颗 N叉的B+ 搜索树 B+ 的 特点 B+ 树的 优势 关于这些小伙伴们可以移步 HR眷恋的数据库高频考题之一 —— 索引 文章中。
而本篇文章中
我们核心讲解事务的概念和它最核心的四个特性
目录 事务的初识
事务的四大核心特性
隔离性需要解决的三大问题
不同隔离级别的特点
一. 事务的初始 在提及事务，和小伙伴们分享个场景
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01ed3872366b093bac96a1791e4bd81a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/845ebef0f4f6efa844b009d17a573043/" rel="bookmark">
			2024蓝桥杯国赛C&#43;&#43;研究生组游记&#43;个人题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Day0 开始复习，过了一遍大部分板子
本来打算再学一遍SAM，但是想到去年考了字符串大题今年应该不会再考了吧。。
过了一遍数据结构和图论，就1点了
两点的时候还没睡着，舍友打游戏好像打到2点过。。
Day1 相当困
第一题： 数田字有多少条直线可以只经过两个点，12条
第二题： 求长度42的置换中，周期恰好为2024的置换个数
首先2024=8*11*23，然后8+11+23=42，然后就是组合数C(42,8)*C(34,11)
结果赛后复盘的时候发现不对劲，想简单了，还有环内部的顺序需要计算，应该还要乘上每个环长度的欧拉函数值（？
第三题： 限流器，T条访问记录，每条访问记录有一个时间戳，每n个时间单位作为一个限流区间，每个区间最多能提供m次访问机会。求成功访问的次数。
由于时间给的很小（&lt;=1000），直接除一下n，放桶里，最后和m取min再求和。
第四题： 给一个数组a[i]，求把所有数加上x再mod k之后，小于等于t的数最多能有多少个
先对所有a[i] mod一下k，变成求一段长度为t+1的区间最多能够覆盖多少值，由于这个问题是环形的，我们套路地把数组a[i]的每个值加上k的复制一段在后面，转化为区间问题。
贪心一下，我们选取的区间左端点一定是某个a[i]值，否则就可以让区间更靠后，以此获取更多覆盖的区域。
two-pointers扫一遍就可以知道结果了。注意边界条件判断。
当然，数据范围比较温和，二分查找logn也可以过。
此时9：34。
第五题： 小模拟，模拟vim指令编辑字符串，n^3
发现insert是中文引号，很诡异，但是不影响结果
这题写了我一个小时，厉害吧，我是真的唐啊
写完10：24了
第六题： 一个字符串，定义一个合法划分：划分中任意两个相邻的子串不能有公共字符。求该字符串中所有长度为1~5的本质不同的子串，这些子串在任意一个合法划分中都没有出现，请将他们按字典序输出。
首先，合法划分必然存在（怎么有点像绕口令），ababaabb可分为a|b|a|b|aa|bb
考虑一个串能在合法划分中出现，例如abcde，那么他的两端必然没有与a、b、c、d、e这五个字符相同的字符，否则这个子串就不能被划分出来。
于是我们枚举所有长度1~5的串，判断他是否能在合法划分中出现，能的话就给他的哈希值打上一个标记，因为字符串长度只有5，map+long long就可以过。
然后我们第二次，扫描所有长度为1~5的子串，看哈希值是否被标记过，如果没有就加入答案的集合。
最后对答案集合进行排序、去重就结束了。
ps：为什么不直接求不合法的子串，因为一段字符串中，aabaccaba，例如aba实际上是可以在合法划分中出现的，划分为：aa|b|a|cc|aba，但是如果直接求的话，a|aba|cc|a|b|a就发现前面这里的aba实际上不合法。
写完调完直接11：00
第七题： 一个带权有向图n个点（n&lt;=50），给出邻接矩阵，m次查询（m&lt;=1000），查询u点到v点恰好经过c条边的最短路径，并且可以将路径上的一条边边权减半（但是多次经过的话只能减半一次）。
一眼就是倍增floyd，再加上一个求路径max，同样可以倍增做。
不过时间复杂度非常逆天O(m*n^3*logc)，考虑怎么优化
发现我不会，70分遗憾离场。
此时11：32，很急，后面还有三道大题没看。
第八题： 给一段序列，它来源于对一棵树的先序遍历的节点深度，已知该序列的一部分（未知的部分用-1
代替），求这个序列一共有多少种可能。
首先发现，先序遍历的深度序列任意一个值都满足a[i]&lt;=a[i-1]+1（i&gt;1）
然后，对于每一段-1，我们都可以对其进行计数。
设f[i][j]为第i位的值为j时，序列1~i构成的方案数
f[i][j]=f[i-1][j-1]+f[i-1][j]+f[i-1][j+1]+……+f[i-1][i-1]，即对前一个f[i-1]的一个后缀和，再向后平移一位
假设这一段-1（区间为[l,r]）的前一个数为x，后一个数为y，那么设f[l-1][x]=1
最终答案为f[r+1][y]
最后把每段的答案乘起来就是最终答案。
考虑如何优化这个后缀和
发现我不会，30分遗憾离场。
做完之后12：15，顿时觉得可以开摆了。
赛后复盘其实觉得不应该放弃这一点的，毕竟初值只有一个1，后面也只查询一个点，应该是可以用数学公式推出来的。
第九题： n个点，每两个点i,j之间有一条边，若i*j为完全平方数则边权为1，否则为0。
特殊生成树定义为任意一个点都必定有一条边连接一个比自己权值小的点。
对每个k，求边权为k（k=0~n-1）的特殊生成树有多少个。
首先，这个特殊的性质规定了生成树的产生方式：顺序枚举1~n点，依次加入生成树，并且只能选择1~i-1的其中一个点进行连接。
于是乎，我们维护的n-1个点的答案数组f[i]，表示边权为i的生成树有多少个，
在加入点n之后f[i]=cnt*f[i-1]+(n-1-cnt)*f[i]，cnt表示n与1~n-1中乘积为完全平方数的个数。
这样就可以n^2拿到60分
至于85分就是分治NTT，模数还正好是998244353，相当于求一下乘积Π(i-1-cnti+cnti*x)的多项式系数。 最后的100分应该是NTT过程中其实可以优化，因为cnti可能为0，这样可以在常数上小一点，然后n(logn)^2过掉。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/845ebef0f4f6efa844b009d17a573043/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba2500ce8cca7ca5273cc9de3e262dee/" rel="bookmark">
			新版AndroidStudio使用switch-case语句时出现Constant expression required错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因:
在新版的Android Studio中使用JDK17以上版本，会出现switch语句报错"Constant expression required"的问题，这是因为在JDK17中switch语句的条件表达式支持使用枚举类型，而这个特性还没有被支持。
解决方法:
①在gradle.properties配置文件下添加代码(推荐,最简便)
android.nonFinalResIds=false ②替换为if-else语法
③降低jdk版本(不推荐,新版AS强制要求jdk版本)
④使用枚举替换(写法比较麻烦,仅供参考)
创建一个枚举类
在Activity中声明成员变量
然后，将枚举类型与按钮关联起来。你可以使用Map来将按钮的资源ID与枚举类型进行映射。在Activity的onCreate方法中，或者Fragment的onCreateView方法中，进行如下操作：
最后，在你的Activity或Fragment中实现onButtonClick方法，根据枚举类型来执行相应的逻辑：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25857acc62c45f97e2341598e784c497/" rel="bookmark">
			Stable Diffusion | Gradio界面设计及webUI API调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文基于webUI API编写了类似于webUI的Gradio交互式界面，支持文生图/图生图（SD1.x，SD2.x，SDXL），Embedding，Lora，X/Y/Z Plot，ADetailer、ControlNet，超分放大（Extras），图片信息读取（PNG Info）。
1. 在线体验 本文代码已部署到百度飞桨AI Studio平台，以供大家在线体验Stable Diffusion ComfyUI/webUI 原版界面及自制Gradio界面。
项目链接：Stable Diffusion webUI 在线体验
2. 自制Gradio界面展示 文生图界面：
Adetailer 设置界面：
ControlNet 设置界面：
X/Y/Z Plot 设置界面：
图生图界面：
图片放大界面：
图片信息读取界面：
3. Gradio界面设计及webUI API调用 import base64 import datetime import io import os import re import subprocess import gradio as gr import requests from PIL import Image, PngImagePlugin design_mode = 1 save_images = "Yes" url = "http://127.0.0.1:7860" if design_mode == 0: cmd = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25857acc62c45f97e2341598e784c497/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ff7aea03c1450c80b82d73a77cc4fc3/" rel="bookmark">
			RedisSearch与Elasticsearch：技术对比与选择指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 码到三十五 ： 个人主页 数据时代，全文搜索已经成为许多应用程序中不可或缺的一部分。RedisSearch和Elasticsearch是两个流行的搜索解决方案，它们各自具有独特的特点和优势。本文简单探讨一些RedisSearch和Elasticsearch之间的技术差异。
目录 一、RedisSearch简介二、Elasticsearch简介三、基础介绍四、技术细节对比4.1 数据存储与性能4.2 搜索功能4.3 扩展性与集群4.4 易用性与集成 五、选择考量5.1 性能需求5.2 数据规模与处理需求5.3 功能需求与复杂性5.4 技术栈与集成考虑5.5 学习与维护成本 结语 一、RedisSearch简介 RedisSearch是Redis的一个模块，它将全文搜索功能集成到Redis中。RedisSearch利用Redis的内存存储和高性能特性，为用户提供快速、准确的搜索体验。它支持多种查询方式，包括全文搜索、精确匹配、模糊搜索等，并且具有可扩展性，能够轻松应对大规模数据的搜索需求。
二、Elasticsearch简介 Elasticsearch是一个基于Lucene的开源搜索和分析引擎。它提供了一个分布式、多租户的全文搜索引擎，具有强大的搜索和分析功能。Elasticsearch可以处理大规模的数据，并提供了复杂的搜索查询、聚合分析和数据可视化等功能。它广泛应用于日志分析、安全监控、企业级搜索等领域。
三、基础介绍 1.1 RedisSearch
定义：RedisSearch是Redis的一个扩展模块，为存储在Redis中的数据提供全文搜索功能。数据存储：数据主要存储在内存中，确保快速访问。特点：注重实时性和高性能搜索。 1.2 Elasticsearch
定义：基于Lucene的开源搜索和分析引擎。数据存储：数据主要存储在磁盘上，依赖缓存提升性能。特点：功能强大，适用于复杂搜索查询、聚合分析和数据可视化。 四、技术细节对比 4.1 数据存储与性能 RedisSearch：由于数据存储在内存中，读写性能和响应速度极高，非常适合实时搜索和高并发场景。Elasticsearch：虽然基于磁盘存储，但通过多种优化和缓存机制，也能提供高性能搜索。在处理大规模数据时表现尤为出色。 4.2 搜索功能 RedisSearch：支持全文搜索、条件过滤等，适用于需要快速响应的搜索场景。Elasticsearch：提供更复杂的查询语法、多种搜索类型（如范围搜索、模糊搜索等），以及强大的聚合分析和数据可视化功能。 4.3 扩展性与集群 RedisSearch：可通过增加Redis节点和分片提高扩展性，但受限于内存大小。Elasticsearch：水平可扩展，轻松增加节点处理更多数据和查询负载。提供完善的集群管理功能，如集群监控、故障恢复等。 4.4 易用性与集成 RedisSearch：API和命令与Redis一致，易于集成和使用，尤其适合已熟悉Redis的开发者。Elasticsearch：提供丰富的API和查询语言，有大量文档和社区资源支持。学习曲线可能较陡峭，但功能更为强大。 五、选择考量 5.1 性能需求 对于实时性和高性能搜索有极高要求的场景，RedisSearch更为合适。 5.2 数据规模与处理需求 需要处理大规模数据或进行复杂搜索分析时，Elasticsearch更具优势。 5.3 功能需求与复杂性 简单全文搜索和实时搜索场景可选择RedisSearch。需要复杂查询、聚合分析、数据可视化等功能的，应选择Elasticsearch。 5.4 技术栈与集成考虑 已有Redis技术栈的项目可优先考虑集成RedisSearch。需要更强大搜索分析功能的，可考虑引入Elasticsearch。 5.5 学习与维护成本 RedisSearch上手容易，适合快速集成和使用。Elasticsearch功能更强大，但学习曲线相对较陡峭。 结语 RedisSearch和Elasticsearch各有其优势和适用场景。RedisSearch更适合实时性要求高、数据规模相对较小、搜索功能需求简单的场景；而Elasticsearch在处理大规模数据、复杂搜索分析和数据可视化方面表现更出色。在选择时，需综合考虑性能需求、数据规模、功能需求、技术栈集成以及学习与维护成本等因素。
听说...关注下面公众号的人都变牛了，纯技术，纯干货 ! 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c05d95821d6ed3153cc0c5fa2a59d5a/" rel="bookmark">
			【数据结构】二叉树：简约和复杂的交织之美
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		专栏引入： 哈喽大家好，我是野生的编程萌新，首先感谢大家的观看。数据结构的学习者大多有这样的想法：数据结构很重要，一定要学好，但数据结构比较抽象，有些算法理解起来很困难，学的很累。我想让大家知道的是：数据结构非常有趣，很多算法是智慧的结晶，我希望大家在学习数据结构的过程是一种愉悦的心情感受。因此我开创了《数据结构》专栏，在这里我将把数据结构内容以有趣易懂的方式展现给大家。
1.二叉树 生活中，我们经常会遇到管理大量数据的情况，比如图书馆书记的分类。而二叉树这种数据结构正是用来解决这种问题的，当我们阅读书时，书中的每个条目都有专门分类和子分类，为了更好的组织这些内容，需要使用一种高效的数据结构来存储和访问信息。下面举个简单的例子来引入二叉树，我们在中学学习生物时知道了植物主要分为：种子植物、苔藓植物等。那它们是如何进行分类的呢？我们看下面这张图片：
通过这种方式，我们可以逐级展开二叉树，更详细的组织植物分类的信息，每个节点都代表一个特定的分类，而子节点则代表该分类的下一级分类。这样我们可以更加轻松的查找和比较不同的植物分类信息。下面我们就来揭开二叉树的神秘面纱。
1.1二叉树的定义 二叉树是n（n&gt;=0）个节点的有限集合，该集合或者为空集合（称为空二叉树），或者由一个根节点和两棵互不相交的、分别称为根节点的左子树和右子树的二叉树组成。在下面的图中，左边的就是一棵二叉树，而右边的因为它的F节点有3个子节点，所以它不是二叉树。
1.2二叉树的特点 二叉树具有以下几个特点：
每个节点最多有两个子节点，所以二叉树中不存在度大于2的节点。注意不是一定要有两个节点，而是最多有两个节点，没有节点或者只有一个节点也是可以滴。左子树和右子树是有顺序的，次序不能颠倒，因此二叉树是有序树。即使结构中某节点只有一个子节点，也要区分它是左节点还是右节点。 二叉树具有以下五种基本形态：空二叉树、只有一个根节点、根节点只有左子树、根节点只有右子树、根节点既有左子树又有右子树。
1.3特殊的二叉树 1.3.1斜树 斜树，顾名思义，斜树一定是斜的，但是向哪里斜还是有讲究的。所有节点都只有左子树的二叉树的叫做左斜树，所有节点都只有右子树的二叉树叫做右斜树，这两者统称为斜树。在上一张图中根节点只有左子树和根节点只有右子树就是左斜树和右斜树的一个简单例子。斜树也有很明显的特点，就是每一层只有一个节点，节点个数和二叉树的深度相同。肯定也有人好奇：这也叫树？这不和线性表一样吗？确实，线性表可以理解成树的一种极其特殊的表现形式。
1.3.2满二叉树 我们通常举例子都是参差不齐的二叉树，那是否存在完美的二叉树呢？我们看下面这张图片：
看来完美的二叉树是存在的。在一棵二叉树中，如果所有分支节点都存在左子树和右子树，并且所有叶子都在一层上，这样的二叉树叫做满二叉树。下面就是一个满二叉树，从样子上看就感觉它很完美：
单是每一个节点都存在左右子树，不能算满二叉树，还必须要所有叶子都在一层上，这样才能做到整棵树的平衡。因此，满二叉树的特点有：
叶子只能出现在最底层，出现在其他层就不能达到平衡状态。除了叶子节点外，每个节点都有两个子节点。即所有非叶子节点的度都为2.在同样深度的二叉树中，满二叉树的节点个数最多，叶子数最多。 满二叉树的每一层都是满的，没有任何缺失节点。由于每个节点都具有两个子节点，满二叉树的平衡性很好。这使得在满二叉树上执行搜索、插入和删除等操作的平均时间复杂度非常高效。在满二叉树中，从根节点到任意一个叶子节点的路径长度都相同，是最短的路径。满二叉树常用于堆数据结构。满二叉树在实际应用中比较少见，因为它要求节点数必须是2的幂次方，而真实的数据往往不具备这样的特点。
1.3.3完全二叉树 对一棵具有n个节点的二叉树进行层序编号，如果编号为i（1≤i≤n）的节点与同样深度的满二叉树中的编号为i的节点在二叉树中的位置完全相同，则这棵二叉树称为完全二叉树。如下图：
在理解时，我们要注意区分满二叉树和完全二叉树。首先，从字面上区分，“完全”和“满”的区别，满二叉树一定是一棵完全二叉树，完全二叉树不一定是满的。其次，完全二叉树的所有节点和同样深度的满二叉树，它们按层序编号相同的节点，是一一对应的，这个关键词是按层序编号。像下面的二叉树中，因为5节点没有右子树，只有左子树，使得按层序编号的第11个编号空档了，它不是完全二叉树：
只有下面图中的树，尽管它不是满二叉树，但编号是连续的，所以它是完全二叉树：
这里我们就可以总结出完全二叉树的一些特点：
叶子节点只能出现在最后两层。最下层的叶子节点一定是集中在左部连续位置。倒数第二层，如果有叶子节点，一定都在右部连续位置。如果节点的度为1，则该节点只有左孩子，及不存在右子树的情况。同样节点数的二叉树，完全二叉树的深度最小。 通过上面的理解，我们也知道了一个判断二叉树是否是完全二叉树的方法：那就是看树的示意图，给每个节点按照满二叉树的结构逐层顺序编号，如果编号出现空挡，就说明不是完全二叉树，反之就是。完全二叉树在实际应用中较为常见，它具有以下的优点：
节点的存储更加高效：由于完全二叉树的特点，可以使用数组来存储节点。这样可以大大节省存储空间，因为不需要为每个节点额外存储左右子节点的指针。访问效率更高：由于节点的存储更加高效，可以使用数组的索引来访问节点。这样可以实现随机访问，访问的时间复杂度是O(1)。而在其他类型的二叉树中，如果要找到某个节点，需要从根节点出发进行遍历，访问的时间复杂度较高。 1.4二叉树的性质 1.4.1二叉树的性质1 在二叉树的第i层至多有个节点（i≥1）。这个性质很容易理解，我们观察一下满二叉树：
第一层是根节点，只有一个，所以=1。第二层有两个，=2。第三层有四个，=4。第四层有八个，=8。通过数据归纳法的论证，我们可以很轻松的得出在二叉树的第i层上至多有个节点（i≥1）的结论。这个性质的重要性在于它给出了二叉树的每一层上节点数量的上限。通过这个性质，我们可以更好地理解和分析二叉树的结构。同时，这个性质也为二叉树的遍历、搜索等操作提供了重要的依据和限制。
1.4.2二叉树的性质2 深度为k的二叉树至多有个节点（k≥1）。这里一定要注意，是后再减1，而不是。如果不注意的话很容易和性质1搞混。深度为k也就是有k层的二叉树，我们接着以上面那个满二叉树为例来看：如果只有一层，至多有个节点。如果只有两层，至多有个节点。如果只有三层，至多有个节点。如果只有四层，至多有个节点通过数据归纳法，我们可以得出：二叉树的深度为k层，此二叉树至多有个节点。
1.4.3二叉树的性质3 对于任何一棵二叉树，如果其终端节点数为，度为2的节点数为，则。这是一个非常重要的性质，首先我们从二叉树的构建过程一步一步来理解它：
首先，我们先看只有一个根节点的时候，度为0的节点个数n0=1，度为2的节点的个数为n2=0。我们设度为1的节点的个数为n1，接着，我们给根节点加一个节点，这时候一定会减少一个度为0的节点（一个度为0的节点变为度为1的节点），然后再加一个度为0的节点（新增的节点因为没有子节点，所以增加一个度为0的节点），度为0的节点个数变化之后和之前的个数一样，所以n0仍为1，n2仍为0。然后，我们再加一个节点，这时候会减少一个度为1的节点，然后增加一个度为0的节点和一个度为2的节点 （度为1的节点变来）。通过这个规律我们可以发现度为0的节点比度为2的节点多1个，即n0=n2+1。
同时我们也可以发现树节点的总数为n=n0+n1+n2。通过下图的例子，节点总数为10，它是由A、B、C、D度为2的节点，F、G、H、I、J度为0的叶子节点和E这个度为1的节点组成的。总和为4+1+5=10。
因为这个性质很重要，刷题时会经常出现考察这个性质的题，我从网上找了两个试题来帮助大家对这个性质加深印象：
1.某二叉树共有 399 个结点，其中有 199 个度为 2 的结点，则该二叉树中的叶子结点数为
（ ）
A 不存在这样的二叉树
B 200
C 198
D 199
答案：C
2.在具有 2n 个结点的完全二叉树中，叶子结点个数为（ ）
A n
B n+1
C n-1
D n/2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c05d95821d6ed3153cc0c5fa2a59d5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c67be182a1020779b2d65fc88b7b696/" rel="bookmark">
			外包干了5天，技术明显退步。。。。。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先说一下自己的情况，本科生，21年通过校招进入南京某软件公司，干了接近2年的功能测试，今年年初，感觉自己不能够在这样下去了，长时间呆在一个舒适的环境会让一个人堕落!而我已经在一个企业干了2年的功能测试，已经让我变得不思进取，谈了2年的女朋友也因为我的心态和工资和我分手了。于是，我决定要改变现状，冲击下大厂。
刚开始准备时，自己都蒙了，2年的功能测试让我的技术没有一丝的进步，提升的只有我的年龄…
没办法，我找到了我在抖音集团的老哥，作为他的小老表，在他了解了我的情况后(几乎就是软件测试基础开始)，直接甩给我一个网盘，说到：“去吧，这里有你需要的所有东西，不要来找我了，我都嫌丢人!”。
盘里头是一整套软件测试面试必备文档PDF，和完整学习路线视频教程，看完之后直接给我老哥给跪了…这下面试稳了。
内容涵盖：包括测试理论、Linux基础、MySQL基础、Web测试、接口测试、App测试、管理工具、Python基础、Selenium相关、性能测试、LordRunner相关等… 质量非常高，需要的可自行领取！！
第一部分，测试理论（测试基础+需求分析+测试模型+测试计划+测试策略+测试案例等等）
第二部分，Linux（ Linux基础+Linux练习题）
第三部分，MySQL（基础知识+查询练习+万年学生表经典面试题汇总+数据库企业真题）
第四部分，Web测试
第五部分，API测试
第六部分，App测试
第七部分，管理工具
第八部分，Python基础（Python基础+编程题+集合+函数+Python特性等等）
第九部分，Selenium相关
第十部分，性能测试
第十一部分，LordRunner相关
第十二部分，计算机网络
第十三部分，组成原理
第十四部分，数据结构与算法
第十五部分，逻辑题
第十六部分，人力资源
软件测试基础
软件测试的步骤是什么?
如何录制测试脚本?
应该考虑进行如何测试的测试方法
怎样估计测试工作量?
测试设计的问题
当测试过程发生错误时，有哪几种解决办法?
测试执行的问题
测试评估的目标
如何提高测试?
C/S模式的优点和缺点
B/S模式的优点和缺点
…
Linux
grep和find的区别? grep 都有哪些用法?
查看IP地址?
创建和删除一个多级目录?
在当前用户家目录中查找haha.txt文件?
如何查询出tomcat的进程并杀掉这个进程，写出linux命令?
动态查看日志文件?
查看系統硬盘空间的命令?
查看当前机器listen 的所有端口?
…
Python
统计python源代码文件中代码行数，去除注释，空行，进行输出?
python调用cmd并返回结果?
冒泡排序
1,2,3,4 这4个数字，能组成多少个互不相同的且无重复的三位数，都是多少?
请用 python 打印出 10000 以内的对称数（对称数特点：数字左右对称，如：1,2,11,121,1221 等）
给定一个整数 N，和一个 0-9 的数 K，要求返回 0-N 中数字 K 出现的次数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c67be182a1020779b2d65fc88b7b696/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acc9f1f5b791387d567f569b995517e4/" rel="bookmark">
			git 下载失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		-- 错误0
加 sudo
-- 错误
$ git clone https://github.com/espressif/arduino-esp32.git -b release/v2.x arduino Cloning into 'arduino'... remote: Enumerating objects: 53886, done. remote: Counting objects: 100% (1194/1194), done. remote: Compressing objects: 100% (568/568), done. error: RPC failed; curl 56 OpenSSL SSL_read: Connection was reset, errno 10054 error: 5871 bytes of body are still expected fetch-pack: unexpected disconnect while reading sideband packet fatal: early EOF fatal: fetch-pack: invalid index-pack output 下面的办法没用，还会出现错误， 最后没有下面的设置，就是多试了好几次，换用手机热点，最后下载成功
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acc9f1f5b791387d567f569b995517e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19dcf211cbffe71cc9841250c94c71ec/" rel="bookmark">
			数据库在线生成ER图,er图自动生成工具,ER图在线设计工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		er图制作软件
数据库sql自动生成er图 毕业论文的er图怎么画
er图自动生成工具软件 er图画图工具
er图的软件 er图怎么画用什么软件
这些问题一直困扰着大家，今天就给大家介绍一款在线生成ER图的神器
实体类工具地址： https://www.yaojiedan.com/sqltoer
ER图工具地址： https://yaojiedan.com/sqltoer/create_er
视频教程： https://www.bilibili.com/video/BV1Xi421Q7aC
使用前一定先看 对应的教程哦，再操作，都是直接可以在线编辑的
ER图（Entity-Relationship Diagram）是数据库设计中用来表示实体之间关系的图形化工具。如果你需要制作ER图，有许多软件和在线工具可以帮助你完成这项任务。以下是一些流行的ER图制作软件和工具：
Lucidchart：一个在线绘图工具，支持多种图表类型，包括ER图。它提供了直观的拖放界面，可以轻松创建和共享ER图。
ERD Tool：一个在线ER图生成器，用户可以通过它创建ER图，并导出为多种格式。
MySQL Workbench：MySQL数据库的官方工具，它提供了ER图设计和建模功能。
Oracle SQL Developer：Oracle数据库的免费集成开发环境，支持ER图的创建和管理。
DbSchema：一个可视化数据库设计和管理工具，支持多种数据库系统。
Microsoft Visio：一个强大的图表和图形设计软件，提供了创建ER图的功能。
ER/Studio：由Embarcadero Technologies开发的ER图设计工具，专门用于设计和建模数据库。
Draw.io (现在叫 diagrams.net)：一个免费的在线图表软件，支持ER图的创建，并且可以导出为多种格式。
QuickDBD：一个在线ER图设计工具，支持从SQL自动生成ER图。
ERDPlus：一个简单的在线ER图制作工具，可以快速创建ER图。
对于毕业论文中的ER图，你可以根据你的具体需求选择合适的工具。如果需要从SQL代码自动生成ER图，可以考虑使用QuickDBD或者一些数据库管理工具中的ER图功能。这些工具通常能够解析SQL代码，并根据定义的表和关系自动生成ER图。
最后，选择一个适合你需求的工具，并遵循其提供的指南来创建你的ER图。如果你需要进一步的帮助或者具体的操作步骤，可以提供更多的信息，我会尽力协助你。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8df947b9df59190478564dea94970438/" rel="bookmark">
			卷积神经网络——为什么卷积哪儿都能用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两个函数的卷积 本质上就是先将一个函数翻转，然后进行滑动叠加。
在连续情况下，叠加指的是对两个函数的乘积求积分。
在离散情况下就是加权求和。
它在不同的领域有着不同的解释 在热力系统中，卷积通常用来计算持续添加的燃料，在燃烧过程中产生的总热量。
在信号分析中，卷积又被用于计算输入信号，对系统产生影响的累积效果。
在概率论中，卷积会被用来计算二维随机变量的概率密度。 在经济学中，卷积还可以用来计算连续复利。
在机器学上的应用，卷积在数字图像处理中的有趣现象。
接下来用3x3的卷积核举例，数字图像在计算机中的表示为三色通道的数字矩阵
进行卷积操作时，卷积核与图像对应位置相乘再求和
将求得的和放在被卷积操作的图中心的位置
再让卷积核在图像上移动，重复求和并放在中心位置，从而求出所有位置的图像卷积值，从而求出所有位置的图像卷积值。
图像卷积操作在不同的卷积核下具备不同的意义 如果用一个全为1/9的3x3卷积核做卷积操作，相等于取9个值得平均值代替中间像素的值。所以一定会起到一定的平滑效果。
换一个高斯卷积核，它在水平和垂直方向平滑上都满足高斯分布。它突出了中心像素在平滑后的权重，相比于均值滤波而言，有着更好的平滑效果。
这个卷积核把像素周围的差值变大，这意味着这个卷积操作会增加像素周围的对比度，从而使图像显得棱角分明画面清晰，它起到了锐化图像的效果。
这个卷积核的卷积操作得到了图像的轮廓效果，因为它相等于求了图像水平方向的一阶导数。
而这个卷积核会将图像整体向一个方向平移。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fd4a8277a67f1c1318b1787ef3c58ba/" rel="bookmark">
			【Java】面向对象的三大特征：封装、继承、多态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		封装 什么叫封装？
在我们写代码的时候经常会涉及两种角色： 类的实现者 和 类的调用者。 封装的本质就是让类的调用者不必太多的了解类的实现者是如何实现类的， 只要知道如何使用类就行了，这样就降低了类使用者的学习和使用成本， 从而 降低了复杂程度。 下面我们来介绍一下在我们Java里的几个访问权限修饰符： private: 类内部能访问, 类外部不能访问默认(也叫包访问权限): 类内部能访问, 同一个包中的类可以访问, 其他类不能访问protected: 类内部能访问, 子类和同一个包中的类可以访问, 其他类不能访问public : 类内部和类的调用者都能访问 使用private实现封装 被 public 修饰的成员变量或者成员方法， 可以直接被类的调用者使用。被 private 修饰的成员变量或者成员方法， 不能被类的调用者使用。 封装的本质是：类的使用者根本不需要知道， 也不需要关注一个类都有哪些 private 的成员。从而让类调用者以更低的成本来使用类。
代码示例：
class Student{ private String name = "张三"; private int age = 20; public void show(){ System.out.println("姓名："+name+" ,年龄："+age); } } public class Demo1 { public static void main(String[] args) { Student student = new Student(); student.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fd4a8277a67f1c1318b1787ef3c58ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72418d0909956de6c9e5321222f56b5c/" rel="bookmark">
			认识JAVA中的异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录： 一. 异常概念与体系结构 二. 异常的处理 三. 自定义异常类 一. 异常概念与体系结构: 1 异常的概念:在 Java 中，将程序执行过程中发生的 不正常行为 称为异常， 如：算数异常： ArithmeticException System.out.println(10 / 0); // 执行结果 Exception in thread "main" java.lang.ArithmeticException: / by zero 数组越界异常：ArrayIndexOutOfBoundsException
int[] arr = {1, 2, 3}; System.out.println(arr[100]); // 执行结果 Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 100 空指针异常： NullPointerException int[] arr = null; System.out.println(arr.length); // 执行结果 Exception in thread "main" java.lang.NullPointerException 2.异常的体系结构：异常种类繁多，为了对不同异常或者错误进行很好的分类管理， Java 内部维护了一个 异常的体系结构 如图： 从图中可以看出： (1).Throwable ： 是异常体系的顶层类，其派生出两个重要的子类, Error 和 Exception (2).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72418d0909956de6c9e5321222f56b5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b22453e28de92455b2703bd4d4152ab5/" rel="bookmark">
			【数据结构】——堆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1：堆的概念及结构
1）：概念：
2：堆的实现 1）：向下调整算法
2）：堆的初始化和销毁
3）： 堆的插入
一）：向上调整
4）：交换节点
5）：堆的删除
1）： 向下调整
6）：取堆顶数据
7）：判空
3：总代码 1：堆的概念及结构 1）：概念： 如果有一个关键码的集合K = { ， ， ，…， }，把它的所有元素按完全二叉树的顺序存储方式存储 在一个一维数组中，并满足： &lt;= 且 &lt;= ( &gt;= 且 &gt;= ) i = 0，1， 2…，则称为小堆(或大堆)。将根结点最大的堆叫做最大堆或大根堆，根结点最小的堆叫做最小堆或小根堆。 堆的性质： 堆中某个结点的值总是不大于或不小于其父结点的值； 堆总是一棵完全二叉树。 2：堆的实现 1）：向下调整算法 一：这里我们需要注意一下向下调整算法： 现在我们给出一个数组，逻辑上看做一颗完全二叉树（物理上其实是数组）。我们通过从根结点开始的向下调整算法可以把它调整成一个小堆。 向下调整算法有一个前提：左右子树必须是一个堆，才能调整。 2）：堆的初始化和销毁 1：对堆进行初始化，因为堆的底层是数组，所以我们也就相当于是对数组进行初始化，将数组（a）初始为NULL、将有效数据个数（size）以及空间大小（capacity）都初始化为0；
2：销毁时，先将数组（a）释放（free），然后需要手动将数组a置为NULL，再将有效数据个数（size）以及空间大小（capacity）都置为0；
//初始化 void HPInit(HP* php) { assert(php); php-&gt;a = NULL; php-&gt;size = php-&gt;capacity = 0; } //销毁 void HPDestory(HP* php) { assert(php); free(php-&gt;a); php-&gt;a = NULL; php-&gt;size = php-&gt;capacity = 0; } 3）： 堆的插入 插入数据要从倒数第一个叶子节点的后面开始插入，然后再向上进行调整
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b22453e28de92455b2703bd4d4152ab5/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/318/">«</a>
	<span class="pagination__item pagination__item--current">319/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/320/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>