<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c8d0a59bd7de5a75ea6d852c5c679ff/" rel="bookmark">
			QT&#43;OpenCV在Android上实现人脸实时检测与目标检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、功能介绍 在当今的移动应用领域，随着技术的飞速发展和智能设备的普及，将先进的计算机视觉技术集成到移动平台，特别是Android系统中，已成为提升用户体验、拓展应用功能的关键。其中，目标检测与人脸识别作为计算机视觉领域的两大基石，广泛应用于安全监控、智能门禁、图像分类、增强现实等多个场景，对促进物联网、智慧城市等前沿科技的发展起着至关重要的作用。
YOLOv3，作为YOLO系列的最新版本，以其快速、准确的目标检测能力著称，能够在单个神经网络中同时进行对象分类和定位，特别适合实时应用需求。该模型通过优化的网络结构设计，实现了速度与精度的较好平衡，是目前广泛应用的目标检测模型之一。
卷积神经网络（CNN，Convolutional Neural Networks）作为深度学习领域的重要组成部分，尤其在图像识别和处理方面展现出了卓越的能力。在人脸识别任务中，CNN能够学习并提取人脸特征，实现高精度的人脸检测与识别。结合特定的人脸识别模型，如FaceNet等，可以在移动平台上实现快速且准确的人脸验证或识别功能，这对于安全认证、个性化服务等领域有着直接的应用价值。
本项目通过Qt框架整合OpenCV与YOLOv3及CNN模型，不仅展示了如何在Android平台上高效实现复杂计算机视觉算法的集成，还为开发者提供了一个实践案例，探索了移动设备上高性能目标检测与人脸识别技术的可行性。这不仅促进了人工智能技术在移动应用中的普及与深化，也为未来的智能安防、健康管理、娱乐互动等应用场景提供了坚实的技术基础。项目的跨平台特性也为软件的广泛部署与应用提供了便利，进一步推动了AI技术与移动互联网的融合创新。
Qt是一个由Qt Company（前身为Trolltech，后被诺基亚收购，再后由Digia接手，并最终成立Qt公司）开发的跨平台C++图形用户界面应用程序开发框架。它自1991年起由Haavard Nord和Eirik Chambe-Eng创建，支持多个主流平台的应用程序开发，包括Android、Windows、iOS和Linux等。Qt框架提供了丰富的功能和工具，涵盖图形用户界面设计、数据库操作、网络编程、文件处理等多个方面，并通过其广泛的类库加速应用程序的开发过程。Qt具有良好的文档和社区支持，广泛用于桌面应用、移动应用、嵌入式系统等多种类型的应用程序开发。不仅可用于开发图形用户界面程序，还可用于非GUI程序，如控制台工具和服务器。Qt的发展历程展现了其不断适应市场需求和技术进步的能力，为开发者提供了强大的工具和平台。
本篇文章用到的全部软件工具、库的模型，以及APP都可以在这里下载（网盘）：https://pan.quark.cn/s/145a9b3f7f53
实现效果：
二、OpenCV下载 OpenCV是开源的计算机视觉、机器学习软件库，其图片处理的功能非常强大，并且速度很快。 作为目标检测功能，OpenCV里本身就自带了很多的模型，比如: 人眼检测、鼻子检测、嘴巴检测、人脸检测、人体检测、猫脸检测等等，下载完OpenCV，就能直接进行图像识别测试体验，并且OpenCV也可以直接调用YOLO的模型，精确识别各种物体，yolo v3 里自带的模型文件可以精确识别常见的很多物体: 比如： 狗、汽车、自行车、人体、书本、手机等等。
OpenCV下载地址：https://opencv.org/releases/page/3/
可以直接下载不同平台的SDK包，非常的方便。
下载下来之后。
主要需要使用的文件就在这里面。
三、YOLO目标检测算法 3.1 YOLO算法介绍 YOLO算法官网介绍：https://pjreddie.com/darknet/yolo/
You only look once (YOLO) is a state-of-the-art, real-time object detection system. On a Pascal Titan X it processes images at 30 FPS and has a mAP of 57.9% on COCO test-dev.
You Only Look Once (YOLO) 是最先进的实时目标检测系统。在 Pascal Titan X 上，它以 30 FPS 处理图像，并且在 COCO 测试开发上的 mAP 为 57.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c8d0a59bd7de5a75ea6d852c5c679ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e82443c1dd7cdf41e7296382aacdc795/" rel="bookmark">
			深入了解Linux中的udhcpc：动态主机配置协议客户端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 什么是udhcpc？安装udhcpc配置网络接口使用udhcpc获取IP地址配置静态IP地址自定义udhcpc脚本高级选项udhcpc常见问题及排查方法1. 无法获取IP地址2. DNS配置不正确3. IP地址冲突4. 无法连接到默认网关5. 无法执行自定义脚本 在Linux系统中，网络配置是确保设备能够连接到网络并进行通信的关键步骤。动态主机配置协议（DHCP）是一种网络管理协议，用于自动分配IP地址给网络中的设备。udhcpc是一个轻量级的DHCP客户端，广泛用于嵌入式Linux系统中。本文将详细介绍如何在Linux系统中使用udhcpc进行网络配置。
什么是udhcpc？ udhcpc是BusyBox工具集中的一个组件，用于从DHCP服务器获取网络配置信息，如IP地址、子网掩码、默认网关和DNS服务器等。它是一个轻量级的工具，非常适合资源受限的嵌入式系统。
安装udhcpc 大多数基于BusyBox的Linux发行版默认已经包含了udhcpc。如果你的系统没有包含，可以通过以下步骤安装：
在BusyBox配置中启用DHCP客户端功能。重新构建并刷入系统镜像。 对于Debian或Ubuntu系统，可以通过以下命令安装BusyBox：
sudo apt-get update sudo apt-get install busybox 配置网络接口 在使用udhcpc之前，需要确保网络接口已经启用并处于活动状态。假设我们要配置的网络接口是eth0。
ifconfig eth0 up 使用udhcpc获取IP地址 接下来，我们使用udhcpc来获取IP地址和其他网络配置信息。
udhcpc -i eth0 udhcpc将自动从DHCP服务器获取配置信息，并在成功后显示如下信息：
udhcpc (v1.30.1) started Sending discover... Sending select for 192.168.1.100... Lease of 192.168.1.100 obtained, lease time 86400 /etc/udhcpc.d/50default: Adding DNS 8.8.8.8 /etc/udhcpc.d/50default: Adding DNS 8.8.4.4 配置静态IP地址 如果你需要配置静态IP地址，可以在/etc/network/interfaces文件中进行配置。
auto eth0 iface eth0 inet static address 192.168.1.100 netmask 255.255.255.0 gateway 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e82443c1dd7cdf41e7296382aacdc795/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/542f7906705c6a3388bfb5da4cab0bbe/" rel="bookmark">
			实战大数据：分布式大数据分析处理系统的开发与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💂 个人网站:【 摸鱼游戏】【网址导航】【神级代码资源网站】🤟 一站式轻松构建小程序、Web网站、移动应用：👉注册地址🤟 基于Web端打造的：👉轻量化工具创作平台💅 想寻找共同学习交流，摸鱼划水的小伙伴，请点击【全栈技术交流群】 1. 引言 在数据驱动的时代，大数据技术已经成为企业和组织获取竞争优势的关键。通过分析和处理大量数据，可以揭示隐藏的模式和趋势，从而做出更明智的决策。分布式大数据分析处理系统通过利用多个计算节点的资源来处理和存储海量数据，极大地提升了数据处理的效率和能力。
2. 大数据的特征 数据量（Volume）：每天生成的数据量巨大，以PB甚至EB计量。
数据种类（Variety）：数据形式多样，包括文本、图像、视频、传感器数据等。
数据速度（Velocity）：数据生成和传输速度快，要求实时或近实时处理。
数据价值（Value）：从数据中提取有价值的信息，实现数据的商业价值。
数据真实性（Veracity）：确保数据的准确性和可信度，减少数据噪音和错误。
3. 分布式大数据处理系统的架构 分布式大数据处理系统的架构通常包括数据存储、数据处理和数据流处理三个部分。
数据存储：
HDFS（Hadoop Distributed File System）：用于存储大规模数据的分布式文件系统。
示例代码（HDFS读取文件）：
from pyspark import SparkContext from pyspark.sql import SparkSession sc = SparkContext("local", "HDFS Example") spark = SparkSession.builder.appName("HDFS Example").getOrCreate() # 读取HDFS文件 df = spark.read.text("hdfs://namenode:9000/path/to/file") df.show() 数据处理：
MapReduce：分布式数据处理模型，通过map和reduce函数进行数据处理。
示例代码（MapReduce示例）：
from mrjob.job import MRJob class MRWordCount(MRJob): def mapper(self, _, line): yield "chars", len(line) yield "words", len(line.split()) yield "lines", 1 def reducer(self, key, values): yield key, sum(values) if __name__ == '__main__': MRWordCount.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/542f7906705c6a3388bfb5da4cab0bbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/267e0876d5c66d8895fbd6df89f41e60/" rel="bookmark">
			【DataSophon】DataSophon1.2.1服务组件开启 kerberos
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、DataSophon是什么
1.1 DataSophon概述
1.2 架构概览
1.3 设计思想
二、集成组件
三、环境准备
四、安装kerberos服务
4.1 Zookeeper
4.2 HDFS
4.3 HBase
4.4 YARN
4.5 hive
【DataSophon】大数据管理平台DataSophon-1.2.1安装部署详细流程-CSDN博客
【DataSophon】大数据服务组件之Flink升级_datasophon1.2 升级flink-CSDN博客
【DataSophon】大数据管理平台DataSophon-1.2.1基本使用-CSDN博客
一、DataSophon是什么 1.1 DataSophon概述 DataSophon也是个类似的管理平台，只不过与智子不同的是，智子的目的是锁死人类的基础科学阻碍人类技术爆炸，而DataSophon是致力于自动化监控、运维、管理大数据基础组件和节点的，帮助您快速构建起稳定，高效的大数据集群服务。
主要特性有:
快速部署,可快速完成300个节点的大数据集群部署兼容复杂环境,极少的依赖使其很容易适配各种复杂环境监控指标全面丰富，基于生产实践展示用户最关心的监控指标灵活便捷的告警服务，可实现用户自定义告警组和告警指标可扩展性强，用户可通过配置的方式集成或升级大数据组件 官方地址：DataSophon | DataSophon
GITHUB地址：datasophon/README_CN.md at dev · datavane/datasophon
1.2 架构概览 1.3 设计思想 为设计出轻量级，高性能，高可扩的，可满足国产化环境要求的大数据集群管理平台。需满足以下设计要求：
（1）一次编译，处处运行，项目部署仅依赖java环境，无其他系统环境依赖。
（2）DataSophon工作端占用资源少，不占用大数据计算节点资源。
（3）可扩展性高，可通过配置的方式集成托管第三方组件。
二、集成组件 各集成组件均进行过兼容性测试，并稳定运行于300+个节点规模的大数据集群，日处理数据量约4000亿条。在海量数据下，各大数据组件调优成本低，平台默认展示用户关心和需要调优的配置。如下DDP1.2.1服务版本信息：
序号
名称
版本
描述
1
HDFS
3.3.3
分布式大数据存储
2
YARN
3.3.3
分布式资源调度与管理平台
3
ZooKeeper
3.5.10
分布式协调系统
4
FLINK
1.16.2
实时计算引擎
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/267e0876d5c66d8895fbd6df89f41e60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/890d45d77f5f87016a1b4d9eda3ae7c9/" rel="bookmark">
			GNU/Linux - Linux Kernel Device model
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 设备模型是 Linux 内核中的一个框架，它提供了一种统一、一致的方式来管理和表示硬件设备。设备模型抽象了硬件的细节，使得开发和维护驱动程序和子系统变得更加容易。以下是 Linux 设备模型的关键组成部分和概念：
关键组成部分 设备 (Devices)
表示系统中的硬件组件。
每个设备在内核中由 struct device 表示。
设备按照层次结构组织，反映它们的物理或逻辑关系（例如，USB 设备是 USB 主机控制器的子设备）。
驱动程序 (Drivers)
管理和控制设备的软件组件。
每个驱动程序在内核中由 struct device_driver 表示。
驱动程序提供初始化、配置和管理设备的方法。
总线 (Buses)
表示设备之间的通信通道。
例如 PCI、USB 和 I2C。
每种总线类型在内核中由 struct bus_type 表示。
总线负责设备的枚举和设备与驱动程序的绑定。
类 (Classes)
表示具有共同功能的设备类别。
例如块设备、网络设备和输入设备。
每个类在内核中由 struct class 表示。
类提供了一种将具有相似功能的设备分组并以一致的方式向用户空间公开的方法。
子系统 (Subsystems)
分组相关设备和驱动程序的更高级抽象。
子系统通常对应于特定类型的硬件或功能（例如 USB 子系统、SCSI 子系统）。
核心概念 设备树 (Device Tree)
系统中设备的层次表示。
设备树反映设备的物理或逻辑排列。
用于表示内置硬件和可热插拔设备。
Sysfs
一个虚拟文件系统，将设备、驱动程序和总线的信息暴露给用户空间。
位于文件系统层次结构中的 /sys。
允许用户空间应用程序与设备进行交互和配置。
设备注册和注销 (Device Registration and Deregistration)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/890d45d77f5f87016a1b4d9eda3ae7c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48873b734e0dcfbb965310df7af85644/" rel="bookmark">
			【Python】Python中的数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据类型 导读一、数据类型的分类1.1 Number（数字）1.1.1 静态数据类型1.1.2 动态数据类型 1.2 String（字符串）1.3 bool（布尔类型） 二、数据类型的转换2.1 隐式类型转换2.2 显式类型转换2.2.1 `int(x[,base])`——将x转换为一个base进制的整数 结语 导读 大家好，很高兴又和大家见面啦！！！
在上一篇内容中我们介绍了Python中的常量与变量的相关内容。常量也就是不可改变的量，与之对应的变量则是可以改变的量。
Python中的常量可以分为四类：
数字常量字符串常量布尔常量特殊常量——None 而Python中的变量与C/C++中的变量不一样的是，在Python中变量在定义时是不需要指明数据类型的，变量的数据类型会根据定义变量时的初始值来进行确定。
计算机语言作为人类与计算机交流的工具，它的作用就是用来给计算机下达相关的指令来使计算机执行相关的操作。
程序猿在使用计算机语言与计算机进行沟通时，则需要通过所使用的语言来描述想要传达的信息。
就比如描述一个人的年龄可以通过整数来描述；描述一个人的姓名可以通过字符串来描述；描述一件衣服的价格可以通过浮点数来描述；描述一件事的真假可以通过布尔值来描述……
这里就涉及到了我们在描述这些数据时所对应的数据类型，在C语言中，我们已经接触到的数据类型可以分为以下几个大类：
整型数据类型浮点型数据类型指针型数据类型数组型数据类型布尔型数据类型自定义数据类型 而这些大类中又会分为几个小类，这里我们以整型和浮点型为例，这里我们不考虑无符号数据类型：
整型可分为： 字符型数据类型（char）短整型数据类型（short）整型数据类型（int）长整型数据类型（long int）更长的整型数据类型（long long int） 浮点型可分为： 单精度浮点型数据类型（float）双精度浮点型数据类型（double） 从这里我们可以看到，C 语言这种面向过程的计算机语言在语法上是非常的精细的，通过C语言我们可以很详细的描述一件事情发生的经过，但是相对应的，在处理同一件事情上，C语言的代码量是相比于其它语言更加庞大的，因此C语言无法处理特别复杂的问题。
C++作为面向对象的计算机语言，它相比于C语言则是能够处理更加高度抽象化的问题，因此在C++中舍弃了C语言中的部分数据类型，如指针类型。
那么在Python中，其数据类型又会和C/C++之间有哪些不同之处呢？在今天的内容中我们将会介绍Python中的数据类型。
一、数据类型的分类 Python 作为一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言，它相比于C/C++而言，代码的可读性更强，描述事物的过程更加直接，因此在Python中，其数据类型主要有以下几类：
Number（数字）String（字符串）bool（布尔类型）List（列表）Tuple（元组）Set（集合）Dictionary（字典） 在这七种数据类型中，根据其对应类型的值是否可变可以将其分为两类：
不可变类型——数字、字符串、布尔、元组这四种数据类型的值是不可变的；可变类型——列表、集合、字典中这三种数据类型的值是可变的。 这里所说的可变可不变，我们通过具体的代码来进行理解：
# 数据类型 a = 1 # 数字（Number) b = 'A' # 字符串（String） c = True # 布尔（bool） tup = (a, b, c) # 元组（Tuple） 在代码中，我们分别展示了这四种类型的变量以及这些变量所对应的值，我们在描述数字、字符串、和布尔这三种数据类型的值时，实际上说的是这些数据类型的常量值，这些常量值是不可变的；
而对于元组而言，它相比于C语言中的数组来说在存储数据这一块的能力要更加的强大，元组中的数据可以是不同类型的数据，但是一旦元组中的数据确定后，就无法再对这些数据进行修改，如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48873b734e0dcfbb965310df7af85644/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef8629f1860c3daef17335900630ac2f/" rel="bookmark">
			Apache Flink 任意 JAR 包上传漏洞利用及防范策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache Flink 任意 JAR 包上传漏洞利用及防范策略
引言 Apache Flink 是一个流行的开源流处理框架，由于其强大的流处理能力，被广泛应用于大数据处理领域。然而，近期发现 Apache Flink 1.9.1 版本存在一个严重的安全漏洞，允许攻击者上传并执行任意 JAR 包。本文将探讨该漏洞的成因、利用方法以及如何有效防范。
Apache Flink 任意 JAR 包上传漏洞概述 该漏洞主要影响配置不当的 Apache Flink 集群，允许攻击者通过 Web 界面上传恶意 JAR 包，执行远程代码。
漏洞成因分析 漏洞产生的原因主要是 Apache Flink 的 JobManager 组件在处理外部提交的 JAR 包时，缺少了必要的安全校验，导致未授权的用户可以上传并执行 JAR 包。
漏洞影响范围 Apache Flink 1.9.1 版本及其之前的版本。 漏洞利用方法 环境搭建 安装 Java 环境。下载并解压 Apache Flink 1.9.1。 漏洞复现步骤 利用 msfvenom 创建一个包含 Meterpreter 的恶意 JAR 文件。通过 Apache Flink 的 Web 界面上传恶意 JAR 文件。提交新的 Job 并指定上传的 JAR 文件，触发远程代码执行。 实战案例 攻击者通过 Flink Web 界面上传名为 xuegod.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef8629f1860c3daef17335900630ac2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9bcecb57a8a02069369c734b488e545/" rel="bookmark">
			哈喽GPT-4o，对GPT-4o 论文速写的思考与探索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一款强大的语言模型，ChatGPT 在论文写作上具备显著优势。它能够辅助学者或研究人员自动创建论文框架、摘要、文献综述及论文段落（如引言、方法、结果、结论等）。此外，ChatGPT 还能优化论文结构、润色、降低内容重复率，并检查语法和拼写错误，提供语言修改和风格建议等功能。
如果用户在论文写作中缺乏创新观点和创意，ChatGPT 能提供新颖的思路和方法，激发创作灵感。尤其在学术领域，ChatGPT 最擅长提出新颖的构思和概念。总之，ChatGPT 在论文写作中有广泛的应用，可以帮助研究人员节省时间和精力，提高论文的质量。随着 ChatGPT 功能和性能的不断进步，它将提供更加精细和个性化的论文写作服务。
在撰写论文时，用户需要广泛阅读相关文献。通过阅读文献，不仅可以掌握该研究领域的最新进展，还能学习他人的结构布局和写作风格。然而，在阅读文献的过程中，用户常常会遇到一些困难。例如，难以理解专业术语和词汇，难以解读数据分析、模型和公式，无法抓住论文的重点或看出文献的创新之处。这些问题都会影响用户顺利阅读文献。对于功能强大的 ChatGPT 来说，这些障碍都能被有效克服。
👉 GPT功能：
GPT-4o知识问答：支持1000+token上下文记忆功能最强代码大模型Code Copilot：代码自动补全、代码优化建议、代码重构等DALL-E AI绘画：AI绘画 + 剪辑 = 自媒体新时代私信哪吒，直接使用GPT-4o 一、阅读论文 对于万能的ChatGPT来说，这些障碍可以迅速解决。只需将需要阅读的文献告诉ChatGPT，它会自动进行语言分析，迅速掌握论文的精髓并生成摘要。因此，ChatGPT能帮助用户更快捷、更高效地获取论文的核心内容，更好地理解论文。此外，还有一些基于ChatGPT开发的平台，如ChatPDF，也能辅助阅读论文。
需要注意的是，ChatGPT尚未接入知网等国内数据库，其训练的数据截止到2021年。如果希望ChatGPT协助阅读知网中的论文或2021年之后的论文内容，则需要将论文内容输入到ChatGPT中。
比如我们问一下ChatGPT，一个比较有名的关于ChatGPT的论文。
Prompt：你知道《Language Models are Few-Shot Learners》这篇论文吗？
Prompt：这篇论文主要介绍了什么？对世界AI的有什么推动作用？
《Language Models are Few-Shot Learners》这篇论文通过介绍GPT-3，展示了大规模预训练模型和少样本学习在NLP任务中的强大能力，对推动AI技术的发展和应用起到了重要作用。它不仅提升了NLP的性能和应用范围，还促进了大规模预训练模型和少样本学习的研究，推动了AI在更多实际应用中的落地。
二、选择题目 在论文写作中，选题至关重要，其质量会直接影响论文的水平和价值。然而，选出一个既具创新性又有实际意义的选题并不容易。在此情况下，利用ChatGPT可以大大简化选题过程。首先，用户可以使用ChatGPT进行主题探索，以获取某个研究领域的最新动态、趋势和热点问题；然后，向ChatGPT提问，以筛选出具有创新性和实际价值的选题；最后，再结合自己的专业知识和实际情况，对选题进行调整和优化。
Prompt：我是一名计算机专业的本科生，请问Java有哪些前沿技术，有哪些最新动态和热点问题？
Prompt：我想研究云原生开发的相关知识，请提供5个研究题目
在逐步引导下，ChatGPT给我提供了5个研究题目，下面可以选择一个感兴趣的题目，让ChatGPT给出论文大纲，再通过论文大纲，逐步展开描述，一篇云原生热点问题的优质论文，几个小时就搞定了。
三、生成论文摘要 论文摘要简要概述了论文的内容，是一段具有独立性和完整性的文字，简明扼要地阐明了研究工作的目的、研究方法以及最终结论等。只需在ChatGPT中输入论文要求，ChatGPT便能协助生成符合学术标准的摘要。
Prompt：我想写一篇关于《容器化应用的安全性研究》的论文，请为我生成一篇300字左右的摘要
四、生成论文提纲 很多研究人员常常需要耗费大量时间来构思和修改论文提纲。优质的提纲是掌握论文框架的关键，使其结构严谨统一。通过使用论文提纲，研究人员能够明确层次和重点，进而有效地安排内容，使主论点和各分论点有机结合在一起。利用ChatGPT工具，研究人员可以轻松完成提纲编写。要生成提纲，只需在ChatGPT中输入论文的核心思想和关键词，或提供论文摘要。上面展示了生成论文摘要的过程，而本案例则基于前一案例，继续根据摘要内容生成提纲。
Prompt：请根据上面摘要内容，生成该论文的提纲
五、生成论文内容 生成完论文提纲之后，再根据提纲内容，一一展开描述就好了。
Prompt：请详细描述背景介绍
六、推荐参考文献 在研究某个问题时，文献搜索是不可避免的。在进行文献搜索时，可以使用 ChatGPT 的搜索引擎，例如 Google Scholar、Microsoft Academic 等，以获取与研究主题相关的文献。输入关键词和相关主题后，ChatGPT 会提供相应的搜索结果，帮助缩小研究领域和文献的范围。此外，ChatGPT 还具备文献推荐功能，可以根据已找到的文献推荐相关的其他文献。需要注意的是，ChatGPT 尚未接入知网等数据库，因此其提供的搜索结果和推荐的文献可能不完全准确（英文文献除外），用户需要对结果进行甄别，以确保找到的文献与研究主题相关。
Prompt：请给我推荐10篇与容器化应用的安全性相关的学术论文，这些论文发表在2020年以后
根据 ChatGPT 的推荐文献可以看出，这些文献全部为英文，并且截至到 2021 年，这与 ChatGPT 的训练数据范围有关。如果希望查阅 2021 年之后的文献，可以参考后文中的使用方法 150，通过 ChatGPT 的 DAN (Do Anything Now) 功能进行无限制检索。若需要查找中文文献，可以利用万方、知网和维普等数据库进行搜索。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9bcecb57a8a02069369c734b488e545/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6091fe59817213b2272cecbb7f0865e9/" rel="bookmark">
			【Elasticsearch】Elasticsearch动态映射与静态映射详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 📑前言一、Elasticsearch 映射概述1.1 什么是映射？1.2 映射的分类 二、动态映射2.1 动态映射的定义2.2 动态映射的优点2.3 动态映射的缺点2.4 动态映射的应用场景2.5 动态映射的配置示例 三、静态映射3.1 静态映射的定义3.2 静态映射的优点3.3 静态映射的缺点3.4 静态映射的应用场景3.5 静态映射的配置示例 四、动态映射与静态映射的比较4.1 应用场景4.2 配置和管理4.3 性能和风险 五、动态映射和静态映射的最佳实践5.1 动态映射的最佳实践5.2 静态映射的最佳实践5.3 动态映射与静态映射结合使用 六、小结 📑前言 Elasticsearch 是一个分布式搜索和分析引擎，广泛应用于实时数据分析和全文检索中。在使用 Elasticsearch 时，映射（Mapping）是定义索引中文档结构和字段类型的过程。映射主要分为动态映射和静态映射两种方式。本文将详细介绍这两种映射的区别及其在不同场景中的应用。
一、Elasticsearch 映射概述 1.1 什么是映射？ 映射是 Elasticsearch 中定义索引中文档结构、字段类型及其属性的过程。通过映射，Elasticsearch 可以理解数据的结构和类型，从而进行有效的存储和检索。映射可以定义字段的类型（如字符串、整数、日期等）、字段是否可以被索引、是否存储原始值等属性。
1.2 映射的分类 映射主要分为两类：
动态映射（Dynamic Mapping）静态映射（Static Mapping） 这两种映射方式在字段定义和管理上存在显著区别，适用于不同的数据处理场景。
二、动态映射 2.1 动态映射的定义 动态映射是 Elasticsearch 自动推断和创建字段类型的过程。当索引中插入新文档时，如果文档包含了映射中尚未定义的新字段，Elasticsearch 会根据字段的值自动推断其类型并将其添加到映射中。
2.2 动态映射的优点 方便快捷：无需提前定义所有字段类型，减少了开发和配置的工作量。适应性强：适用于字段结构不固定或变化频繁的场景，能够自动适应新字段的加入。 2.3 动态映射的缺点 不精确性：自动推断的类型可能不完全符合预期，例如字符串类型的日期被推断为文本类型。风险控制：在高并发写入时可能会引起映射爆炸（Mapping Explosion）问题，导致内存和性能问题。不可预测性：映射变化可能会影响查询性能和结果的准确性。 2.4 动态映射的应用场景 动态映射适用于以下场景：
数据结构不固定或频繁变化的应用，例如日志分析、社交媒体数据采集等。开发阶段或快速原型设计时，用于快速验证数据模型。 2.5 动态映射的配置示例 PUT /my_index { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6091fe59817213b2272cecbb7f0865e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e174781db68457e9e1969271653d9e06/" rel="bookmark">
			【C语言入门】初识C语言：掌握编程的基石
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📝个人主页🌹：Eternity._
⏩收录专栏⏪：C语言 “ 登神长阶 ”
🤡往期回顾🤡：C语言入门
🌹🌹期待您的关注 🌹🌹
❀C语言入门 📒1. 选择语句与循环语句🍁选择语句🍂循环语句 📙2. 函数📜3. 数组⛰️数组定义🏞️数组下标🌄数组使用 📚4. 操作符，常见关键字与 #define🌞操作符🌙#define⭐常见关键字🌈关键字 typedef🌈关键字static 📝5. 指针🎩内存🎈指针变量的大小 📘6. 结构体📖7. 总结 前言： 在踏入C语言编程的奇妙旅程之初，掌握基本语句无疑是我们搭建知识大厦的坚实基石。C语言，作为一门历史悠久且功能强大的编程语言，其简洁明了的语法结构为我们提供了表达逻辑、控制程序流程的强大工具。而基本语句，正是这些工具中的基础与核心。
本篇文章旨在引领初学者走进C语言基本语句的世界，通过深入浅出的讲解和实例演示，帮助大家理解并掌握这些语句的用法。我们将从最基本的赋值语句开始，逐步深入到条件判断、循环控制等关键语句，让每一位读者都能清晰地感受到C语言编程的魅力与力量
让我们一同踏上这段充满挑战与收获的C语言编程之旅吧！
📒1. 选择语句与循环语句 🍁选择语句 C语言中的选择语句主要用于基于不同条件执行不同的代码块。C语言中主要有两种选择语句：if语句和switch语句
选择语句流程图
Created with Raphaël 2.3.0 开始 表达式 语句一 结束 语句二 yes no 选择语句代码示例
int main() { int n = 0; printf("你会去敲代码吗？（选择1 or 0）:&gt;"); scanf("%d", &amp;n); if(n == 1) { prinf("坚持，你会有好offer\n"); } else { printf("放弃，回家卖红薯\n"); } return 0; } 🍂循环语句 C语言中的循环语句允许我们重复执行一段代码多次，直到满足某个条件为止。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e174781db68457e9e1969271653d9e06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec40e0d150b3f37bcbeee25004e42c30/" rel="bookmark">
			搏击与防卫笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 降龙十八掌 咏春个人防身笔记防卫直拳应对耳光防卫摆拳坐马冲拳 本来想以武术为标题的，想了想武术这个标题太大太深，自己连一知半解都算不上，就谢为搏击与防卫吧。 每个男孩都有个武侠梦，独步江湖，仗剑走天涯。
岁月蹉跎，曾经我以为我是河，风雨中爱恨成河任我穿梭，现实是小小旋涡，圈一圈将我吞没。
武侠梦谈不上了，但是也要会几手，哪怕是简单的招数。
一是不枉这些年的武侠梦，看了那么多的武侠片(或功夫片、甚至是警匪片)
二是可以强身健体
三是临场多少会有点用(如果实战中保护了自己，也可以认为是对武侠片的另一种致敬方式)
降龙十八掌 没有人不想会降龙十八掌，不过岁月蹉跎，曾经我以为我是河，风雨中爱恨成河任我穿梭，现实是小小旋涡，圈一圈将我吞没。
跑题了，提这个主要为了节目效果。
咏春 对咏春的了解主要来自于叶问系列电影，不怕您说我外行，各抒己见。
个人防身笔记 有人说练习没用，你又成不了全国冠军。
这个观点是错误的，就好像说：挣钱没用，你又成不了全国首富。
那么干脆我们就不干活了?当然不是。
还是那个观点，虽然成不了全国首富，但是多挣一分，用的时候就方便一分。
武术也同样如此，习练一分有一分的好处。
又有人说，我们普通人学这个有什么用?
只能说您比较幸运，难道真的没遇到过什么事?
即使是菜鸡互啄，也分轻重巧拙。
防卫直拳 直拳概率最高，应法也是多种多样。
应对耳光 都以右手为例。
左臂立掌如刀，向外磕即可。(右手可反击)
右掌向里磕也可。(反掌向外可反击)
左臂向上迎也可。(右手可反击)
防卫摆拳 坐马冲拳 一般人不了解马步的厉害。
感觉姿势呆呆的。实际马步是非常重要的基本功。
马步练到家，下盘稳如狗，稳如老狗。
人家蹲在哪里让你扫都扫不动，腿上站个人照样禁得住。
坐马就是马步基础上，猛然下坐，一般配合拉颈击头。这个力道比手臂大多了，是非常凶猛的招数，如果力道掌握的好，这一拉一般人就受不了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c829c7d47fd934cfe666946337657ccb/" rel="bookmark">
			LabVIEW干涉仪测向系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发了一套基于LabVIEW的软件系统，结合硬件设备，构建一个干涉仪测向实验教学平台。该平台应用于信号处理课程，帮助学生将理论知识与实际应用相结合，深化对信号处理核心概念的理解和应用。
项目背景： 当前信号处理教学多依赖于软件仿真，缺乏与硬件结合的系统实验支持，导致学生难以全面理解和应用信号处理理论。该干涉仪测向实验教学系统的设计，通过实际的硬件操作和LabVIEW软件的实验设计，构建一个系统化的教学平台，使学生能够通过实验操作，更好地理解和掌握信号处理的核心知识，解决实际问题。
系统组成： 信号采集：
天线阵列
低噪声放大器（LNA）
下变频模块
中频模块
数字信号采集卡（NI 5171R）
信号处理：
LabVIEW软件
快速傅里叶变换（FFT）
频谱分析
数据显示：
实时波形显示
频谱特性显示
方向测量结果显示
硬件选择理由： 天线阵列：多单元设计，增强信号接收能力和方向分辨率。
低噪声放大器：提供必要的信号增强，减少系统噪声，保证信号的清晰度和准确性。
数字信号采集卡（NI 5171R）：高采样率保证信号的忠实还原，支持高速数据传输。
软件体系结构与特点： LabVIEW软件为本系统的核心，提供了数据流编程环境，简化了数据采集和处理程序的开发。软件通过图形化界面展示实时数据，实验者可以直观地看到信号处理的结果，包括时域波形和频域特性。LabVIEW的模块化设计使得系统易于扩展和修改，适应不同的教学和研究需求。
工作原理： 信号采集与预处理：系统首先通过天线阵列捕获信号，通过前端放大和滤波后，信号被送至ADC进行数字化。此阶段，信号的质量被大幅提升，为后续的数字处理奠定了基础。
数字信号处理：数字化后的信号在LabVIEW中进行进一步处理，包括快速傅里叶变换（FFT）和频谱分析。系统通过算法分析频谱中的特定成分，计算出信号的方向信息。
数据显示与用户交互：处理后的数据通过LabVIEW的前端界面显示，用户可以实时观察到信号的时域波形、频谱及方向测量结果。界面中还包括控制按钮和参数设置选项，允许用户根据需要调整实验设置，如信号源的频率、功率等，实现与实验过程的实时交互。
系统或硬件的指标： 工作频率：33.5 GHz，提供足够的信号分辨率。
带宽：100 MHz，确保广泛的信号处理能力。
天线阵列：8单元，提高方向确定的精确性。
采样率：至少500 MHz，满足Nyquist采样定理要求。
硬件与软件的配合： 通过LabVIEW平台与硬件的紧密集成，实现了从信号采集到处理的无缝对接。LabVIEW的程序结构清晰，易于学习和使用，大大降低了实验设置的复杂性。同时，LabVIEW强大的信号处理库和图形用户界面（GUI）设计工具，使得实验过程既专业又用户友好。
系统总结： 本系统不仅提供了一个稳定可靠的实验平台，还通过实际操作加深了学生对信号处理理论的理解，增强了理论与实践的结合。通过这种教学模式，学生能够直观地学习和掌握复杂的信号处理技术，为未来在科研或工业应用中解决实际问题打下坚实的基础。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dfd9b2cbcbc85aa69734ea15a3bfabd/" rel="bookmark">
			任天堂称未来第一方游戏不会使用生成式AI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虽然EA、育碧、暴雪、Embracer等西方游戏厂商都大力支持生成式AI技术，但日本老牌游戏公司任天堂并不会追随这一步伐。任天堂已经确认该公司未来的第一方游戏不会使用生成式AI技术。
在公司最近的投资人问答会上，任天堂描绘了公司未来游戏愿景。在谈到AI技术时，社长古川俊太郎说AI确实很厉害，但还没到终结所有的时候。
他说：“我们希望继续呈现我们独有的价值，而这是无法仅凭AI技术就能实现的。”
可见，任天堂高层在AI技术的看法上和欧美厂商很不同。此前EA和微软等公司高层都盛赞了AI技术能力，能缩减成本和加快游戏开发进程。
西方游戏公司正在探索使用AI改进游戏环境，让NPC表现更自然，从而提高游戏的互动和沉浸感。此外，英伟达还在考虑为DLSS 4引入AI生成物体和纹理等新功能。这会让游戏开发更快，成本更低，减少对人工的依赖。然而这样做，许多游戏从业者恐怕要丢掉工作。
老任果然一如既往，硬件配置主打一个四两拨千斤，但是也可能是考虑到游戏机续航的问题吧。反正，宫崎英高表示老头环上Switch目前不存在的。
感谢大家花时间阅读我的文章，你们的支持是我不断前进的动力。期望未来能为大家带来更多有价值的内容，请多多关注我的动态！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7058e99826bd6f3a985c34b8884f094b/" rel="bookmark">
			【C&#43;&#43;】类和对象（中）--上篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人主页~
类和对象上
类和对象 一、类的六个默认成员函数二、构造函数1、构造函数基本概念2、构造函数的特性 三、析构函数1、析构函数的概念2、特性 四、拷贝构造函数1、拷贝构造函数的概念2、特征 一、类的六个默认成员函数 如果有个类中什么成员都没有，那么被称为空类
由编译器自动生成的成员函数称为默认成员函数
空类中会自动生成六个默认成员函数，这六个默认成员函数在每个类中都会自动生成
①初始化功能的构造函数
②清理功能的析构函数
③使用同类对象初始化创建对象的拷贝构造
④把一个对象赋值给另一个对象的赋值重载
⑤对普通对象取地址重载
⑥对const对象取地址重载
这六个默认成员函数主要将操作对象分为内置类型和自定义类型，对二者有不同的操作
二、构造函数 1、构造函数基本概念 构造函数是一个特殊的成员函数，名字与类名相同，创建类类型对象时由编译器自动调用，以保证每个成员都要初始化，并且在对象整个生命周期内只调用一次
2、构造函数的特性 构造函数是特殊的成员函数，主要任务就是初始化对象
（1）函数名与类名相同
（2）无返回值
（3）对象实例化时编译器自动调用
（4）可以重载
class Date { public: //无参构造函数 Date() {} //带参构造函数 Date(int year, int month, int day) { _year = year; _month = month; _day = day; } private: int _year; int _month; int _day; }; 无参调用不用加括号：
//无参调用 Date d1; //有参调用 Date d2(2024,6,22); （5）如果类中没有显式定义构造函数，则编译器会自动生成一个无参的默认构造函数，如果有显式定义，编译器将不再生成
class Date { public: //无参构造函数 Date() {} private: int _year; int _month; int _day; }; 由编译器自己生成：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7058e99826bd6f3a985c34b8884f094b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de3c78120376e1b55339081520ae316d/" rel="bookmark">
			Webpack: 三种Chunk产物的打包逻辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 在前文 Webpack: Dependency Graph 管理模块间依赖 中，我们已经详细讲解了「构建」阶段如何从 Entry 开始逐步递归读入、解析模块内容，并最终构建出模块依赖关系图 —— ModuleGraph 对象。本文我们继续往下，讲解在接下来的「封装」阶段，如何根据 ModuleGraph 内容组织 Chunk，并进一步构建出 ChunkGroup、ChunkGraph 依赖关系对象的主流程。 主流程之外，我们还会详细讲解几个比较模糊的概念：
Chunk、ChunkGroup、ChunGraph 对象分别是什么？互相之间存在怎样的交互关系？Webpack 默认分包规则，以及规则中存在的问题。 ChunkGraph 构建过程 在 前 Init、Make、Seal》中，我们已经介绍了 Webpack 底层构建逻辑大体上可以划分为：「初始化、构建、封装」三个阶段：
其中，「构建」阶段负责分析模块间的依赖关系，建立起模块之间的 依赖关系图（ModuleGraph）；紧接着，在「封装」阶段根据依赖关系图，将模块分开封装进若干 Chunk 对象中，并将 Chunk 之间的父子依赖关系梳理成 ChunkGraph 与若干 ChunkGroup 对象。
「封装」阶段最重要的目标就是根据「构建」阶段收集到的 ModuleGraph 关系图构建 ChunkGraph 关系图，这个过程的逻辑比较复杂：
我们简单分析一下这里面几个重要步骤的实现逻辑。
第一步非常关键： 调用 seal() 函数后，遍历 entry 配置，为每个入口创建一个空的 Chunk 与 EntryPoint 对象（一种特殊的 ChunkGroup），并初步设置好基本的 ChunkGraph 结构关系，为下一步骤做好准备，关键代码：
class Compilation { seal(callback) { // ... const chunkGraphInit = new Map(); // 遍历入口模块列表 for (const [name, { dependencies, includeDependencies, options }] of this .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de3c78120376e1b55339081520ae316d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6745531f83ca1e91f9c4d4e03f9ddb1/" rel="bookmark">
			20240704 每日AI必读资讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Runway Gen-3 Alpha 详细使用教程
- 以及提示词指南大全，包括摄像机风格、灯光效果、运动状态类型以及风格美学、文本风格等。
- Gen-3 Alpha是Runway推出的新—代视频生成模型，它在保真度、一致性、运动和速度方面都比以前的模型有所改进，能够进行精细时间控制。
🔗 https://blink.csdn.net/details/1748313
微软开源GraphRAG，构建知识图谱增强大模型的问答、推理等能力
- GraphRAG通过构建实体知识图谱来增强大模型的搜索、问答、摘要、推理等能力，特别擅长处理大规模数据集。
- GraphRAG的核心包括构建实体知识图谱和生成社区摘要两个步骤，通过社区摘要提取数据集中相关信息，生成更全面和准确的答案。
- GraphRAG对tokens的需求很低，能够帮助开发者节省成本。在综合测试中表现优异，是目前最佳的RAG方法之一。
🔗详情链接：Project GraphRAG - Microsoft Research
Fish Speech：完美支持中英日语言的开源TTS模型
- 语音处理接近人类水平
- 模型使用约十五万小时三语数据训练，对中文支持非常的完美。
- 该项目由 fishaudio 开发，作为一个仅有亿级参数的模型，Fish Speech 设计高效轻量，可以在个人设备上轻松运行和微调，成为您的私人语音助手。
🔗GitHub：https://github.com/fishaudio/fish-speech
🔗 https://blink.csdn.net/details/1748317
Figure宣布与BMW制造公司签署商业协议 将通用机器人引入汽车生产
- 视频为Figure展示的与宝马集团在斯帕坦堡工厂的合作，旨在实现完全自动化操作。项目中使用了AI驱动的视觉模型和神经网络，以确保所有抓取动作的精准和高效。
- 根据协议，BMW Manufacturing 和 Figure 将采用基于里程碑的方法。
- 在第一阶段，Figure 将确定在汽车生产中应用 Figure 机器人的初步用例。
- 第一阶段完成后，Figure 机器人将在宝马位于南卡罗来纳州斯帕坦堡的制造工厂开始分阶段部署。
🔗新闻来源: https://www.prnewswire.com/news-releases/figure-announces-commercial-agreement-with-bmw-manufacturing-to-bring-general-purpose-robots-into-automotive-production-302036263.html
🔗 https://blink.csdn.net/details/1748314 Meta AI发布端到端生成高质量的 3D 资产生成模型
- 不到一分钟时间即可根据文本生成高质量3D模型
- 生成的结果优于现有解决方案，速度是该领域现有工作的 3-10 倍。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6745531f83ca1e91f9c4d4e03f9ddb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18d9d3654a0c152d858325b3747782a8/" rel="bookmark">
			计算机网络八股文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机网络体系架构？ OSI结构：理论上的 7应用层：定义了应用进程间通信和交互的规则，常见协议有HTTP、SFTP、DNS、WebSocket6表示层：数据的表示、安全、压缩。确保一个系统的应用层所发消息能被另一个系统的应用层读取。GIF、JEPG5会话层：建立、管理、终止会话，是用户应用程序和网络之间的接口。RPC、SQL4传输层：提供源端和目的端之间提供可靠的透明数据传输，传输层协议为不同主机上运行的进程提供了逻辑通信。TCP、UDP、SSH3网络层：将网络地址翻译成对应的物理地址，实现不同网络之间的路径选择，寻址，路由。ICMP、IGMP、IP等2数据链路层：在物理层提供比特流服务的基础上、建立像零件点之间的数据链路。1物理层：建立、维护、断开物理连接。TCP/IP结构：实际上的 应用 传输 网络 链路层五层结构：为了介绍原理而折中的，在这个基础上层层包装层层拆包 DNS的迭代查询和递归查询？ 递归查询举例：
客户端想要解析 www.example.com 的IP地址，发送请求到本地DNS解析器：
本地解析器查询根DNS服务器。
根DNS服务器返回 .com TLD服务器地址。
本地解析器查询 .com TLD服务器。
.com TLD服务器返回 example.com 的权威DNS服务器地址。
本地解析器查询 example.com 的权威DNS服务器。
权威DNS服务器返回 www.example.com 的IP地址。
本地解析器将IP地址返回给客户端。
迭代查询举例：
客户端想要解析 www.example.com 的IP地址，依次查询各个DNS服务器：
客户端查询本地DNS解析器。
本地解析器查询根DNS服务器。
根DNS服务器返回 .com TLD服务器地址。
本地解析器将 .com TLD服务器地址返回给客户端。
客户端查询 .com TLD服务器。
.com TLD服务器返回 example.com 的权威DNS服务器地址。
客户端查询 example.com 的权威DNS服务器。
权威DNS服务器返回 www.example.com 的IP地址。
客户端获取到IP地址。
结论
递归查询和迭代查询是DNS查询的两种方式，各有优缺点。递归查询对客户端友好，但增加了DNS解析器的负担；迭代查询对解析器负担小，但增加了客户端的复杂性。实际应用中，客户端通常会使用递归查询，通过本地DNS解析器处理大部分的查询过程。
DNS解析过程？ 常见端口： 21：FTP22：SSH53：DNS解析80：HTTP443：HTTPS1080：sockets3306：mysql 常见状态码： 1XX：临时的响应，客户端应继续请求。2XX：请求已成功被服务器接收。3XX：用来重定向。4XX：请求可能出错。5XX：服务器在尝试处理请求时发生了错误。 404：表示客户端（如浏览器）请求的资源在服务器上不存在
GET和POST的区别？ 传参方式不同，一个在URL一个在请求体幂等性GET大部分都被CDN缓存起来了 HTTP报文结构？ 请求报文： 报文首部 请求行请求首部字段通用首部字段实体首部字段 GET /index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18d9d3654a0c152d858325b3747782a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b06ffcdacf9e64776acdfeec490f6cdc/" rel="bookmark">
			windows上安装Frida环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python安装 下载地址 Python Release Python 3.12.4 | Python.org
python安装好后，使用如下命令安装frida客户端 pip install frida-tools
使用frida --version 查看frida版本
安装手机模拟器（雷电模拟器） 我的版本是4.0.61
查看CPU架构
adb shell getprop ro.product.cpu.abi
安装frida-server 下载地址
Releases · frida/frida · GitHub
版本选择
1.要和python中安装的frida版本一致，所以frida-server也要选择16.3.3
2.CPU架构要选择与模拟器一致的架构
综上，最终选择
将下载的frida-server解压后放到雷电模拟器的/data/local/tmp下
命令如下：
adb push C:\Users\Administrator\Downloads\frida-server-16.3.3-android-x86\frida-server-16.3.3-android-x86 /data/local/tmp
使用adb 进入shell 将frida-server文件的权限更改为777
chmod 777 frida-server-16.3.3-android-x86
启动frida-server
最后将雷电模拟器的USB调试开关要打开
到此，frida-server已经安装成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a84322551c063befd272940cbd2b2166/" rel="bookmark">
			Vuetify3：文章显示html标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Vuetify 3中，如果你想要显示一个包含HTML标签的文章，你可以使用v-html指令来渲染这些标签。这个指令会将绑定的HTML内容渲染到模板中，但要注意，由于直接渲染HTML可能会有XSS攻击的风险，因此只在可靠内容上使用v-html指令。
我们直接上代码：
&lt;template&gt; &lt;v-card&gt; &lt;v-card-title&gt;文章标题&lt;/v-card-title&gt; &lt;v-card-subtitle&gt;更新：2024-7-1 10:47:11 发布：178校园网 纠错&lt;/v-card-subtitle&gt; &lt;v-card-text v-html="rawHtml"&gt;&lt;/v-card-text&gt; &lt;/v-card&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { rawHtml: '&lt;p&gt;这里是文章的&lt;strong&gt;HTML&lt;/strong&gt;内容，例如加粗文本。&lt;/p&gt;&lt;img src="https://www.baidu.com/img/flexible/logo/pc/result.png" class="icon" /&gt;' }; } }; &lt;/script&gt; 如果在过程中，遇到图片不能正常访问，需要查看一下源码，是否需要设置路由。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a9c40b778b97d80975d6412d523646f/" rel="bookmark">
			地表最强的Python开源库，可让微信秒变助手的-itchat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		地表最强的Python开源库，可让微信秒变助手的-itchat itchat 是什么 itchat是一个开源的Python库，主要用于微信个人号的接口。通过这个库，开发者可以实现自动回复、模拟人工操作、实现机器人等功能。itchat的出现极大地降低了微信个人号开发的门槛，让更多的开发者能够轻松地实现微信相关的项目。
itchat的功能丰富，可以实现文本、图片、视频等多种类型的消息交互。同时，它也支持微信的各项基本操作，如添加好友、发送朋友圈等。这使得itchat成为了微信开发的热门选择。
安装和引入itchat 通过pip安装itchat 要使用itchat，首先需要确保已经安装了Python环境。然后，可以通过pip命令安装itchat库。在命令行中输入以下命令：
pip install itchat 如果你使用的是Linux或Mac系统，可能需要使用pip3而不是pip。
引入itchat库 安装完成后，你可以在Python代码中通过以下方式引入itchat库：
import itchat 确保在代码的顶部引入itchat，这样你就可以使用库中提供的功能了。
itchat 使用示例 Python 中的 itchat 是一个非常流行的微信个人号接口，它允许开发者利用 Python 进行微信的个人号互动。在了解如何使用 itchat 之前，需要确保你已经安装了它。
安装 itchat 首先，通过 pip 安装 itchat：
pip install itchat 接着，你需要使用 wechaty 许可证，这需要你进行一些配置。首先，克隆 wechaty 的许可证：
git clone https://github.com/wechaty/wechaty-许可证.git 然后，在许可证文件夹中运行：
npm install 最后，使用以下命令启动许可证服务器：
node start.js 这将生成一个许可证二维码，你需要在微信中扫描它以激活许可证。
引入 itchat 在 Python 代码中引入 itchat：
from itchat.content import TEXT import itchat 基本使用示例 下面是一个使用 itchat 进行简单交互的示例：
# 登录微信 itchat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a9c40b778b97d80975d6412d523646f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/196/">«</a>
	<span class="pagination__item pagination__item--current">197/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/198/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>