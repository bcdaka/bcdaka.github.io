<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0441b98173cac62988a19756f2a521ae/" rel="bookmark">
			【C&#43;&#43; STL】模拟实现 string
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标题：【C++ :: STL】手撕 STL _string
@水墨不写bug
（图片来源于网络）
C++标准模板库（STL）中的string是一个可变长的字符序列，它提供了一系列操作字符串的方法和功能。
本篇文章，我们将模拟实现STL的string类的部分功能，以增强对STL的熟练度，了解STL容器的工作原理，积累项目经验，也为将来自主实现和改造容器奠定坚实的基础。
STL的string类是一个模板，而我们为了方便实现，以达到练习的目的，我们暂时先实现一个成员变量为（下图示）的string类。 char* _str; size_t _size;//字符串长度，不加上\0 size_t _capacity; C++ STL的string类提供了以下常用的成员函数和接口：
构造函数和赋值操作函数接口：
默认构造函数：创建一个空字符串。带string参数的构造函数：将一个string对象复制到另一个string对象中。带字符数组参数的构造函数：将字符数组转换为string对象。带整数参数的构造函数：将整数转换为字符串。赋值操作符：用另一个string对象、字符数组或字符来赋值。 访问字符串内容相关函数接口：
at()：返回指定位置的字符。operator[]：返回指定位置的字符。front()：返回第一个字符。back()：返回最后一个字符。c_str()：返回一个以空字符结尾的字符数组。 修改字符串内容接口：
insert()：在指定位置插入字符、字符串或字符数组。erase()：删除指定位置的字符。replace()：替换指定位置的字符串或字符。append()：在字符串末尾添加字符、字符串或字符数组。clear()：清空字符串。 字符串操作接口：
size() 或 length()：返回字符串的长度。empty()：判断字符串是否为空。find()：查找指定字符串或字符的位置。substr()：返回指定位置和长度的子字符串。compare()：比较两个字符串 （具体用法在上一篇讲解：【Cpp::STL】标准模板库_ string详解） （一）头文件 我们在C语言阶段实现声明和定义分离的时候，只是单一的把函数的定义放在.c（源）文件，把函数的声明，头文件的包含，宏定义等放在.h（头）文件。
但是，在C++，不仅要遵守以上的规则，由于类的出现，需要域作用限定符（：：）来限定方位；由于成员的访问权限的出现，需要考虑访问权限的问题；此外不同类型的成员的定义的位置也有讲究，比如静态成员尽量不要直接定义在头文件中，因为这会引发 多次包含多文件 在链接时的 头文件内的对象的重定义问题。
本文根据STL标准模板库的功能，给出头文件，包括string类的定义，众多成员函数，部分非成员函数（流插入，流提取的重载），并在后半节详细讲解各个函数的实现思路。
#define _CRT_SECURE_NO_WARNINGS 1 #pragma once #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cassert&gt; using namespace std; namespace ddsm { class string { friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const string&amp; s1); public: //迭代器 typedef char* iterator; typedef const char* const_iterator; iterator begin(); const_iterator begin() const; iterator end(); const_iterator end() const; //传参构造,默认构造，给默认值为空串，巧妙 string(const char* str = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0441b98173cac62988a19756f2a521ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f00e2b7618037ee89040207855d889e/" rel="bookmark">
			用AI制作历史解说视频：GPT &#43; MidJourney &#43; PiKa &#43; FunSound &#43; 剪映
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 项目介绍 最近某站看到一个看到利用AI创作视频解说，成品画面很酷炫。对此以初学者视角进行复现，创意来源：用AI制作历史解说视频
2. 开始创作 我们参照原作者展示的内容，对古代人物屈原来生成解说视频。
2.1 故事脚本+分镜 【由GPT-4o支持】 2.1.1 生成分镜 GPT对话：
以屈原人物解说为主题，写一个具有传奇色彩和反差感的人物传记故事脚本，一共涵盖10个分镜（包含画面和旁白）
2.1.2 细化内容（面向文生图） GPT对话：
依次对十个分镜生成画面描述，用于midjourney绘图，并翻译成英文
初步得到优质的画面描述英文版
2.2 文生图【由MidJourney支持】 输入英文描述，
/Imagine promot[描述]
这里得到场景1生成的图片
接下来我们需要根据第一张图片确定人物形象风格，来保证后续人物的一致性，获取该图片的链接用于后续场景图片生成的参数
对于后续图片的人物一致性，MidJourney 提供 ”–cref &lt;url&gt;“ 参数进行人物描绘参考
挑选了10张
2.3 图生视频【由PiKa支持】 上传图片到pika，Strength of motion 设置为2，增加动感
效果如下
全部视频生成完毕，开始剪辑
2.4 语音旁白【由Funsound支持】 这里为每个旁边生成语音
2.5 语音视频长度对齐 因为生成的视频和生成的音频长度不对等，这里我们需要保持音频长度不变，对视频帧率进行调整，长度一致后合成，顺便添加中文字幕。
参考我另一篇博客 音视频对齐，这里我给出python批量处理脚本
import os from av_alignment import sync_audio_video_add_subtitle def process(audio_dir, video_dir, text_file, output_dir, output_list_file, font_path="./NotoSansCJKsc-Regular.ttf"): if not os.path.exists(output_dir):os.makedirs(output_dir) if os.path.exists(output_list_file):os.remove(output_list_file) audio_list = os.listdir(audio_dir) video_list = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f00e2b7618037ee89040207855d889e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0092ec364401bdfa514e46f819150140/" rel="bookmark">
			20240609 每日AI必读资讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💻奥特曼百万年薪挖角谷歌TPU人才，欲砸7万亿实现「芯片自由」？
- 今年2月，奥特曼会见软银CEO和台积电的谈判代表，讨论合资事宜，计划在未来几年内共同建造和运营数十座芯片制造工厂。
- 谷歌与openAI，大公司和创业公司在发展速度上的本质差异。
- OpenAI需要在芯片和算力方面逐渐独立，微软在试图减少对OpenAI模型的依赖。
🔗 https://blog.csdn.net/m0_46163918/article/details/139553699
🌐测试 Chrome 内置 Gemini Nano 的方法！
- 下载 Chrome 127，可以到 Chrome Release Channels 下载 Canary 版本 Chrome Release Channels
- 打开 chrome://components/，检查 Optimization Guide On Device Model 中模型是否成功下载，点击 Check for update
- 打开控制台，输入 http://window.ai 测试是否能有返回结果，可以用下面的完整代码测试
🔗 https://blink.csdn.net/details/1723145
🤖DuckDuckGo 推出私密AI 聊天机器人 - 承诺不会使用你的数据训练模型
- 目前免费，无需注册即可使用
- DuckDuckGo通过替换用户的IP地址，确保聊天内容无法追溯到个人。
- 不会存储用户数据，并确保 AI 提供商在 30天内删除保存的聊天记录。
- 目前支持OpenAI的GPT-3.5 Turbo、Anthropic的Claude 3 Haiku以及两个开源模型（Meta的Llama 3和Mistral的Mixtral 8x7B）
🔗访问：http://duckduckgo.com/chat
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3596cd881e895c27421c4e80cfcc2622/" rel="bookmark">
			Mysql 8.0.37 安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图片有点长，慢慢来
安装教程 安装地址：MySQL :: MySQL Downloads
进入官网
下载社区版
此处有两个版本，我们下载的是8.0.37版本
第一个需要联网安装，我们现在第二个离线安装
server only：仅安装MySQL server
client only：仅安装MySQL client
Full：安装所有模块
custom：自定义安装
这里我们选择自定义安装
点击左边框框中的+，选择需要的扩展进行安装
设置一个密码：自己可以记住就好
验证是否安装成功 环境配置 如果想在Win+R， 输入cmd 窗口访问Mysql，需要配置环境变量。
右键点击此电脑,点击属性
点击电脑键盘上的 Win+R， 输入cmd 来访问Mysql
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/565c3ace6b3f6beae637bd07ffea31c9/" rel="bookmark">
			Python GUI编程：深入探索现代GUI库及其创新应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引言
Python GUI库概览
1. Tkinter
2. PyQt/PySide
3. wxPython
4. Kivy
5. PyGTK
6.FLTK (pyFLTK)
创新应用案例
1. 交互式数据分析工具
2. 智能物联网(IoT)仪表板
3. 增强现实(AR)辅助设计软件
4. 跨平台的科学计算软件
5. 交互式教育软件
实战示例1：使用PyQt5开发智能仪表板
实战示例2：简单的任务清单（To-Do List）应用
结论
引言 在软件开发领域，用户体验的重要性日益凸显，而图形用户界面（GUI）是提升用户体验的关键因素。Python，以其简洁的语法和强大的库支持，为GUI编程提供了丰富的选择。本文将深入探讨Python中的GUI库，评估它们的功能，并探索如何利用这些库开发创新的应用程序。
Python GUI库概览 1. Tkinter 特点：Python的标准GUI库，简单易学，跨平台。优势：轻量级，无需额外安装。局限：外观较旧，不够现代。 2. PyQt/PySide 特点：基于强大的Qt框架，提供丰富的组件和样式。优势：功能全面，支持跨平台，可创建复杂应用。局限：学习曲线较陡，许可证可能成为商业应用的考虑因素。 3. wxPython 特点：提供与本地操作系统一致的GUI组件。优势：外观自然，易于集成系统功能。局限：文档和社区支持相对较少。 4. Kivy 特点：支持多点触控，适合开发移动和多点触控应用。优势：适合开发触摸界面，可移植性好。局限：性能和成熟度不如Qt。 5. PyGTK 特点：基于GTK+库，适合创建复杂的GUI。优势：功能强大，适合开发GNOME应用。局限：GTK+本身较为复杂，学习曲线陡峭。 6.FLTK (pyFLTK) 特点：轻量级的C++ GUI工具包的Python绑定。优势：轻量级，适合小型或嵌入式应用。局限：社区和组件支持有限。 创新应用案例 1. 交互式数据分析工具 技术结合：利用Pandas、Matplotlib与PyQt5，开发交互式数据分析和可视化工具。 2. 智能物联网(IoT)仪表板 技术结合：结合MQTT协议和Kivy，开发实时监控和控制IoT设备的仪表板。 3. 增强现实(AR)辅助设计软件 技术结合：使用OpenCV和wxPython，开发AR辅助的室内设计和建模软件。 4. 跨平台的科学计算软件 技术结合：利用NumPy、SciPy与PySide，开发功能强大的科学计算软件。 5. 交互式教育软件 技术结合：结合教育理论模型和Tkinter，开发交互式学习工具。 实战示例1：使用PyQt5开发智能仪表板 以下是一个使用PyQt5开发的智能仪表板的示例，展示了如何实现一个具有实时数据监控和控制功能的GUI应用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/565c3ace6b3f6beae637bd07ffea31c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fce696f6054ec7543da1744a709bedf8/" rel="bookmark">
			深入了解Git：从数据模型到集成IDEA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git是现代软件开发中不可或缺的版本控制工具。理解Git的数据模型、暂存区、命令行接口，并将其集成到IDE（如IntelliJ IDEA），可以显著提升开发效率。本文将从底层开始，逐步深入Git的各个方面，并介绍如何将其集成到IntelliJ IDEA中。
目录 Git的数据模型暂存区Git的命令行接口将Git集成到IntelliJ IDEA总结 Git的数据模型 Git的数据模型是理解其强大功能的关键。Git实际上是一个内容寻址文件系统，使用SHA-1哈希算法唯一标识文件和目录的内容。主要包括以下对象：
Blob（Binary Large Object） Blob是Git中最基础的对象，用于存储文件内容。每个文件对应一个Blob对象，通过内容的SHA-1哈希值唯一标识。
伪代码表示：
blob_content = read_file(file_path) blob_hash = sha1(blob_content) store_object(blob_hash, blob_content) Tree Tree对象表示一个目录，记录目录中的文件名和对应的Blob对象，以及子目录和对应的Tree对象。Tree对象通过其内容的SHA-1哈希值唯一标识。
伪代码表示：
tree_entries = [] for entry in directory: if entry is file: blob_hash = create_blob(entry) tree_entries.append((file_name, blob_hash)) elif entry is directory: subtree_hash = create_tree(entry) tree_entries.append((directory_name, subtree_hash)) tree_content = serialize(tree_entries) tree_hash = sha1(tree_content) store_object(tree_hash, tree_content) Commit Commit对象表示一次提交，包含一个Tree对象、父Commit对象以及提交信息。Commit对象通过其内容生成的SHA-1哈希值唯一标识。
伪代码表示：
commit_content = { "tree": tree_hash, "parents": parent_commit_hashes, "author": author_info, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fce696f6054ec7543da1744a709bedf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce8bb9723cc3c58a70a1cf8e7072ed88/" rel="bookmark">
			计算机毕业设计hadoop&#43;spark&#43;hive动漫推荐系统 漫画推荐系统 漫画分析可视化大屏 漫画爬虫 漫画推荐系统 漫画爬虫 知识图谱 大数据毕设
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 流程：
1.DrissionPage采集知音漫客约2万条国产动漫数据存入mysql数据库；
2.Mapreduce对采集的动漫数据进行数据清洗、拆分数据项等，转为.csv文件上传hadoop的hdfs集群；
3.hive建库建表导入.csv动漫数据；
4.一半指标使用hive_sql分析得出，一半指标使用Spark之Scala完成；
5.sqoop对分析结果导入mysql数据库；
6.Flask+echarts搭建可视化大屏；
创新点：Python全新DrissionPage爬虫使用、海量数据、爬虫、可视化大屏、离线hive+实时Spark双实现
可选装：推荐系统、预测系统、知识图谱、后台管理等。
核心算法代码分享如下：
/* Navicat MySQL Data Transfer Source Server : Win7本地测试_localhost_3306_123456_版本5.7 Source Server Version : 50714 Source Host : localhost:3306 Source Database : hive_zymk Target Server Type : MYSQL Target Server Version : 50714 File Encoding : 65001 Date: 2023-08-30 11:43:34 */ SET FOREIGN_KEY_CHECKS=0; -- ---------------------------- -- Table structure for tb_zymk -- ---------------------------- DROP TABLE IF EXISTS `tb_zymk`; CREATE TABLE `tb_zymk` ( `id` int(11) NOT NULL AUTO_INCREMENT, `title` text COLLATE utf8mb4_bin COMMENT '漫画名称', `update_times` text COLLATE utf8mb4_bin COMMENT '每周更新时间', `tags` text COLLATE utf8mb4_bin COMMENT '标签', `content` text COLLATE utf8mb4_bin COMMENT '内容', `readings` text COLLATE utf8mb4_bin COMMENT '阅读量', `subscribes` text COLLATE utf8mb4_bin COMMENT '订阅量', `rewards` text COLLATE utf8mb4_bin COMMENT '打赏', `monthtickets` text COLLATE utf8mb4_bin COMMENT '月票', `recommends` text COLLATE utf8mb4_bin COMMENT '推荐次数', `comments` text COLLATE utf8mb4_bin COMMENT '评论量', `scores` text COLLATE utf8mb4_bin COMMENT '评分', `author` text COLLATE utf8mb4_bin COMMENT '作者', `zps` text COLLATE utf8mb4_bin COMMENT '代表作', `ctime` text COLLATE utf8mb4_bin COMMENT '章节最后更新时间', `img` text COLLATE utf8mb4_bin, `url` text COLLATE utf8mb4_bin, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=1437 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ca66d505dbe7adedcee7c8df195a713/" rel="bookmark">
			【YOLO系列】YOLOv1学习（PyTorch）原理加代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文网址：https://arxiv.org/pdf/1506.02640 训练集博客链接：目标检测实战篇1——数据集介绍(PASCAL VOC，MS COCO)-CSDN博客 代码文件：在我资源里，但是好像还在审核，大家可以先可以，如果没有的话就评论，我发给你。 0、作者 Joseph Redmon是发表这篇论文的作者，最著名的四篇论文为YOLOv1，YOLO9000（YOLOV2）、YOLOv3和Xron-Net（与轻量化相关），作者毕业于华盛顿大学。很厉害的一位人。大家可以去了解一下。
一、前言和预备知识 之前我所发布的，都是分类问题，解决的概念就是输入一张图片，然后输出这个图片中的内容是什么类别，这种方法在很多问题上以及能够解决了，但是要清楚这个物体在图片中那个位置，这还是很难解决的，所以就引入了目标检测的概念，目标检测就是做到不仅判断物体的类别还可以得出物体所在位置，而目前最热门的目标检测的模型也就是YOLO系列了。
YOLO系列的模型，是为了解决当时目标检测模型的帧率太低而提出来的模型。英文全称是You only look once。
深度学习目标检测算法分类：
（1）two-stage 两个阶段的检测，模型举例 Faster-RCNN Mask-Rcnn系列
(2) one-stage 一个阶段的检测：YOLO系列
这两个主要区别可以简单理解为，两个阶段有一个选择预选框和物体分类的一个过程，而单阶段的将检测问题转换为一个回归问题。
YOLO是目前比较流行的目标检测算法，速度快并且结构简单。
YOLOV1，是以Joseph Redmon为首的大佬们于2015年提出的一种新的目标检测算法。它与之前的目标检测算法如R-CNN等不同之处在于，R-CNN等目标检测算法是两阶段算法， 步骤为先在图片上生成候选框，然后利用分类器对这些候选框进行逐一的判断；而YOLOv1是一阶段算法，是端到端的算法，它把目标检测问题看作回归问题，将图片输入单一的神经网络，然后就输出得到了图片的物体边界框（boundingbox）以及分类概率等信息。
总结：YOLOv1直接从输入的图像，仅仅经过一个神经网络，直接得到一些bounding box（位置坐标）以及每个bounding box对所有类别的一个概率情况，因为整个的检测过程仅仅有一个网络，所以可以直接进行端到端的优化，而无需像Faster R-CNN的分阶段的优化。
end-to-end(端到端)：指的是一个过程，输入原始数据，输出最后结果。之前的网络Fast RCNN等这种网络分为两个阶段，一个是预选框的生成和目标分类与边界框回归，具体内容大家可以自行理解。
YOLO的核心思想就是把目标检测转变为一个回归问题，利用整张图作为网络的输入，仅仅经过一个神经网络，得到bounding box（边界框） 的位置及其所属的类别。
二、网络结构 YOLOv1的网络结构简单清晰，是一个最传统的one-stage的卷积神经网络。
网络输入：448*448*3的彩色图片。
中间层：由若干卷积层和最大池化层组成，用于提取图片的抽象特征。
全连接层：由两个全连接层组成，用来预测目标的位置和类别概率值。
网络输出：7*7*30的预测结果。
三、网络细节 YOLOv1采用的是“分而治之”的策略，将一张图片平均分成7×7个网格，每个网格分别负责预测中心点落在该网格内的目标。回忆一下，在Faster R-CNN中，是通过一个RPN来获得目标的感兴趣区域，这种方法精度高，但是需要额外再训练一个RPN网络，这无疑增加了训练的负担。在YOLOv1中，通过划分得到了7×7个网格，这49个网格就相当于是目标的感兴趣区域。通过这种方式，我们就不需要再额外设计一个RPN网络，这正是YOLOv1作为单阶段网络的简单快捷之处！
四、预测阶段讲解（前向推断） 就是模型训练完后，向训练好的模型输入图片，然后得到最后结果的一个过程。
YOLOv1训练完后，是一个深度卷积神经网络，网络结构如下图所示
将网络当成一个黑箱子，输入的是一个448*448*3的RGB图像，输出的是一个7*7*30的向量。
网络结构很简单，大概就是卷积、池化、全连接层，一目了然。
而最后输出的向量，包含了类别、框、置信度等结果，而我们只需要解释这个向量就得到最后的结果了。
下面对最后输出的向量，进行一个分析，当我们输入一张图片的时候，最后会生成7*7*30的向量，如何去理解呢，可以将这个向量看做成7*7个1*30的向量，也就是49个1*30的向量，这里的每个1*30的向量，对应于前面的一个grid cell，将向量拆分为两个预测框的坐标以及预测框包含物体的置信度，和20个类别的条件概率。其中每个gridcell只会预测一个物体，也因此暴露出YOLOv1在小目标上检测的缺陷。然后预测中又引入了NMS向量对上述的98个框进行筛选，最后才可以得出我们的结果，大家读到这里，可能还是有一些不能理解的，所以请大家观看代码，代码都有注释。
import numpy as np import torch from PIL import ImageFont, ImageDraw from cv2 import cv2 from matplotlib import pyplot as plt # import cv2 from torchvision.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ca66d505dbe7adedcee7c8df195a713/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc1ea7d6bd14283f1b899d7c287ce97e/" rel="bookmark">
			SpringBoot&#43;Vue图书管理系统（前后端分离）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 技术栈 JavaSpringBootMavenMySQLMyBatisVueShiroElement-UI 角色对应功能 用户管理员 功能截图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca2181ae28c823d42d006f0d9b40c2b4/" rel="bookmark">
			IIoT（智能物联网）的现状、应用及安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近年来，物联网（IoT）作为推动现代公司和智能城市发展的一个范式，已经取得了显著的发展。IoT使得分布式设备（如手机、平板电脑和计算机）能够感知并从外部环境传输数据，以服务于最终用户。IoT的概念主要依赖于设备之间的通信，以提供本地服务，例如协作数据收集，以及设备与服务器（如云服务器、边缘服务器或数据中心）之间的互连，以提供高级服务，如数据管理和网络监控。
智能解决方案与ML/AI在IoT网络中的整合形成了一种新的网络范式，即智能物联网（IIoT）。IIoT已经改变了智能医疗保健、智能交通和智能工业等IoT应用。特别是，IIoT为设备进步打开了众多机会，例如为本地IoT设备配备由集成AI模型驱动的设备智能，以及服务提供，包括智能数据传输和AI辅助的数据处理。
1 智能物联网的现状 1.1 人工智能（AI）及其子领域如机器学习（ML）、深度学习（DL）、联邦学习（FL）和强化学习（RL）之间的关系及主要模型 ML 是 AI 的基础：ML 是 AI 技术的核心，它允许计算机从数据中学习并改进其性能。DL 是 ML 的一种特殊形式：DL 使用深层神经网络来学习数据的复杂特征和模式，它在图像和语音识别等领域取得了巨大成功。FL 是一种分布式 ML 技术，用于保护用户隐私和数据安全：FL 允许多个设备在本地训练模型，同时保护用户隐私和数据安全。RL 是一种 ML 技术，用于创建可以与周围环境互动并学习如何做出最佳决策的智能体：RL 在游戏、机器人技术和推荐系统等领域得到了广泛应用。 1.2 AI的子领域在物联网（IoT）系统中的应用和发展 机器学习（ML）：ML是一种让计算机系统从经验中学习的技术，它在IoT中的应用包括分类、检测和数据加密等任务。ML方法如监督学习、无监督学习和半监督学习被广泛用于IoT系统中，以提高系统的效率和准确性。深度学习（DL）：DL因其在处理大型数据集时的出色性能而在IoT系统中越来越受欢迎。DL模型的改进可以归因于其固有的非线性，这允许模型大小的增加，从而能够更有效地扩展到更大的数据集。此外，由IoT网络生成的大量数据是DL成功的关键驱动力。DL模型采用复杂的线性和非线性函数组合来有效学习相关特征。在IoT中，DL模型能够处理视觉数据、时间序列数据和视频文本等多种类型的数据，并在智能医疗、智能电网和智能农业等领域展现出显著的性能提升。联邦学习（FL）：FL是一种分布式机器学习方法，它允许在不共享原始数据的情况下训练模型。这对于保护用户隐私尤为重要，因此在IoT中得到了广泛应用，尤其是在处理敏感医疗数据时。FL技术还包括水平FL（HFL）、垂直FL（VFL）和联邦迁移学习（FTL）等变体。深度强化学习（DRL）：DRL结合了深度学习和强化学习的原理，使代理能够通过与环境互动来学习最优策略。在IoT中，DRL被用于优化资源分配、灌溉计划和交通流量预测等任务，提高了系统的自主性和适应性。 2 智能物联网的应用 2.1 智能医疗 智能医疗保健是IIoT系统应用中的一个重要领域，特别是在患者监测方面。IIoT系统的发展可以为医疗保健带来显著的好处，包括帮助医疗人员及早发现异常、监测和预测严重疾病，并尽可能减少对重症患者的潜在风险。可穿戴设备、生活方式辅助设备和医疗辅助IoT设备的普及有助于收集大量数据，以训练和提高基于机器学习（ML）模型的性能，进而提供更好的医疗服务。
个性化医疗： 利用 IIoT 设备收集患者的健康数据，并结合 AI 技术进行深度分析，为患者提供个性化的治疗方案和健康建议。药物研发： IIoT 可以加速药物研发过程，例如通过监测动物实验中的生理指标，或利用传感器收集患者对药物的反应数据。远程医疗： IIoT 设备可以实现远程医疗诊断和治疗，例如远程手术、远程监测患者健康状况等。智慧养老： IIoT 设备可以帮助老年人进行日常生活，例如自动开关家电、监测健康状况、预防跌倒等。 2.2 智能城市 IIoT在智能城市的发展中扮演着关键角色，它可以促进数据收集、交换和分析，从而提高服务、效率和生活质量。IIoT可以在智能城市的几个关键领域提供有用的服务，包括智能电网和水管理。
智能交通管理： 利用 IIoT 设备收集交通数据，并结合 AI 技术进行交通预测和优化，例如实时路况显示、智能交通信号灯控制、自动驾驶等。智能环境监测： IIoT 设备可以实时监测空气质量、水质、噪声等环境指标，并采取措施进行改善。智能能源管理： 利用 IIoT 设备进行能源消耗监测和管理，例如智能电表、智能家居等，实现节能减排和高效能源利用。智能城市规划： IIoT 可以帮助城市规划者更好地了解城市运行状况，并进行更科学的规划和决策。 2.3 智能交通 IIoT在智能交通系统的发展中取得了显著进展，提高了城市交通的安全性和可持续性，使日常生活更加便捷和高效。IIoT可以通过处理和分析从各种传感器收集的数据来做出实时决策，从而促进智能交通。
智能驾驶： 利用 IIoT 设备实现自动驾驶，例如环境感知、路径规划、决策控制等。智能物流： IIoT 可以优化物流运输路线和效率，例如实时追踪货物位置、智能调度车辆等。智能交通基础设施： IIoT 可以提高交通基础设施的智能化水平，例如智能路网、智能停车场等。智能出行： IIoT 可以提供更加便捷的出行方式，例如共享单车、共享汽车等。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca2181ae28c823d42d006f0d9b40c2b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed2d726604a8b33588a95b7ec0c943cd/" rel="bookmark">
			从零手写实现 nginx-12-keepalive HTTP 持久连接或连接复用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 大家好，我是老马。很高兴遇到你。
我们为 java 开发者实现了 java 版本的 nginx
https://github.com/houbb/nginx4j
如果你想知道 servlet 如何处理的，可以参考我的另一个项目：
手写从零实现简易版 tomcat minicat 手写 nginx 系列 如果你对 nginx 原理感兴趣，可以阅读：
从零手写实现 nginx-01-为什么不能有 java 版本的 nginx?
从零手写实现 nginx-02-nginx 的核心能力
从零手写实现 nginx-03-nginx 基于 Netty 实现
从零手写实现 nginx-04-基于 netty http 出入参优化处理
从零手写实现 nginx-05-MIME类型（Multipurpose Internet Mail Extensions，多用途互联网邮件扩展类型）
从零手写实现 nginx-06-文件夹自动索引
从零手写实现 nginx-07-大文件下载
从零手写实现 nginx-08-范围查询
从零手写实现 nginx-09-文件压缩
从零手写实现 nginx-10-sendfile 零拷贝
从零手写实现 nginx-11-file+range 合并
从零手写实现 nginx-12-keep-alive 连接复用
从零手写实现 nginx-13-nginx.conf 配置文件介绍
从零手写实现 nginx-14-nginx.conf 和 hocon 格式有关系吗？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed2d726604a8b33588a95b7ec0c943cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/098f17937b209881d624519f061120ab/" rel="bookmark">
			RustDesk 搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Web、API 部署教程：https://www.52pojie.cn/thread-1708319-1-1.html
RustDesk 服务端下载：https://github.com/rustdesk/rustdesk-server/releases
RustDesk 客户端下载：https://github.com/rustdesk/rustdesk/releases/tag/1.2.3-2
RustDesk 官方部署教程：https://rustdesk.com/docs/zh-cn/
1：RustDesk 概览 1.1：项目简介 RustDesk 它是一个远程控制开源项目，该项目支持自己搭建服务器。
RustDesk 默认提供免费公共中继服务，但 RustDesk 的中继服务器在海外，所以延迟非常明显，所以可以自己搭建服务器。
1.2：工作原理 RustDesk 会先用 TCP 21116 信令服务 NAT 打洞，如果打洞成功，直接 P2P 直连，RustDesk 不参与中继。
RustDesk 如果没有打洞成功，则走 TCP 21117 中继服务，延迟、画质取决于中继服务器的带宽。
hbbs 监听端口hbbr 监听端口21115(tcp)：用作 NAT 类型测试21117(tcp)：中继服务21116(tcp)：NAT 打洞与连接服务21119(tcp)：支持 Web 客户端21118(tcp)：支持 Web 客户端21116(udp)：ID 注册与心跳服务 2：部署 RustDesk 服务 我的服务器是 CentOS7.6 64位，所以下载 rustdesk-server-linux-amd64.zip，用 unzip 解压后执行 hbbr(ID)、hbbs(中继)。
请注意 TCP 21115-21119 和 1 个 UDP 21116 都要在安全组放行，如果有宝塔，宝塔的防火墙也要放行。
unzip rustdesk-server-linux-amd64.zip mv amd64 rustdesk_server cd rustdesk_server # 启动ID注册服务，后台运行 # -k _ 用于强制被控端输入Key，因为默认情况下只需要主控端输入Key就能连接 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/098f17937b209881d624519f061120ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b87eff97f00a174d04b2c70bc627404b/" rel="bookmark">
			EntitiesSample_6. Reparenting
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该示例的关键点有两个，一个是 Parent，Child组件的使用，这两个组件是内置的，标识对象之间嵌套的引用，第二个关键点是 ecb.Playback(state.EntityManager)的使用，在使用EntityCommandBuffer对实体惊醒操作之后，使用playback接口保证数据的同步，EntityCommandBuffer命令执行在各个job中,无法确定执行的顺序和时间，就像是Mono托管编程中的协程，通过回调函数与主线程数据同步 public partial struct ReparentingSystem : ISystem { bool attached; float timer; const float interval = 0.7f; [BurstCompile] public void OnCreate(ref SystemState state) { timer = interval; attached = true; state.RequireForUpdate&lt;ExecuteReparenting&gt;(); state.RequireForUpdate&lt;RotationSpeed&gt;(); } [BurstCompile] public void OnUpdate(ref SystemState state) { //时间计时 interval，interval秒设置一次 timer -= SystemAPI.Time.DeltaTime; if (timer &gt; 0) { return; } timer = interval; //获取场景中RotationSpeed挂载这个脚本的实体 var rotatorEntity = SystemAPI.GetSingletonEntity&lt;RotationSpeed&gt;(); //创建ecb命令，使用该命令对实体世界操作，这个命令可以在各个job上调度 var ecb = new EntityCommandBuffer(Allocator.Temp); if (attached) { //获取挂载RotationSpeed脚本的子实体，如果一个实体有子实体， //会自动被挂载上Child组件，引用的所有的子实体，Child继承自IBufferElementData，就像mono中的getComponentsInChild //子实体拥有一个Parent组件，引用的父级 DynamicBuffer&lt;Child&gt; children = SystemAPI.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b87eff97f00a174d04b2c70bc627404b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1705dc8fd2026f7635dd22fb28c69432/" rel="bookmark">
			spark-3.5.1&#43;Hadoop 3.4.0&#43;Hive4.0 分布式集群 安装配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hadoop安装参考:
Hadoop 3.4.0+HBase2.5.8+ZooKeeper3.8.4+Hive4.0+Sqoop 分布式高可用集群部署安装 大数据系列二-CSDN博客
一 下载:
Downloads | Apache Spark
1 下载Maven – Welcome to Apache Maven
# maven安装及配置教程 wget https://dlcdn.apache.org/maven/maven-3/3.8.8/binaries/apache-maven-3.8.8-bin.tar.gz # tar zxvf apache-maven-3.8.8-bin.tar.gz mv apache-maven-3.8.8/ /usr/local/maven #vi /etc/profile export MAVEN_HOME=/usr/local/maven export PATH=$PATH:$MAVEN_HOME/bin #source /etc/profile #查看版本 root@slave13 soft]# mvn --version Apache Maven 3.8.8 (4c87b05d9aedce574290d1acc98575ed5eb6cd39) Maven home: /usr/local/maven Java version: 1.8.0_191, vendor: Oracle Corporation, runtime: /usr/local/jdk/jre Default locale: en_US, platform encoding: UTF-8 OS name: "linux", version: "4.18.0-348.el8.x86_64", arch: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1705dc8fd2026f7635dd22fb28c69432/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f8c7cfdf4937e2670bf4e374c5b3fb7/" rel="bookmark">
			Elasticsearch之写入原理以及调优
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、ES 的写入过程 1.1 ES支持四种对文档的数据写操作 create：如果在PUT数据的时候当前数据已经存在，则数据会被覆盖，如果在PUT的时候加上操作类型create，此时如果数据已存在则会返回失败，因为已经强制指定了操作类型为create，ES就不会再去执行update操作。比如：PUT /pruduct/_create/1/ （ 老版本的语法为 PUT /pruduct/_doc/1/_create ）指的就是在索引product中强制创建id为1的数据，如果id为1的数据已存在，则返回失败。delete：删除文档，ES对文档的删除是懒删除机制，即标记删除。index：在ES中，写入操作被称为Index，这里Index为动词，即索引数据为将数据创建在ES中的索引，后面章节中均称之为“索引数据”。update：执行partial update（全量替换，部分替换） 1.2 写流程 ES中的数据写入均发生在Primary Shard，当数据在Primary写入完成之后会同步到相应的Replica Shard。下图演示了单条数据写入ES的流程：
以下为数据写入的步骤：
客户端发起写入请求至node 4node 4通过文档 id 在路由表中的映射信息确定当前数据的位置为分片0，分片0的主分片位于node 5，并将数据转发至node 5。数据在node 5写入，写入成功之后将数据的同步请求转发至其副本所在的node 4和node 6上面，等待所有副本数据写入成功之后node 5将结果报告node 4，并由node 4将结果返回给客户端，报告数据写入成功。 在这个过程中，接收用户请求的节点是不固定的，上述例子中，node 4 发挥了协调节点和客户端节点的作用，将数据转发至对应节点和接收以及返回用户请求。
数据在由 node4 转发至 node5的时候，是通过以下公式来计算，指定的文档具体在那个分片的
shard_num = hash(_routing) % num_primary_shards 其中，_routing 的默认值是文档的 id。
1.3 写一致性策略 ES 5.x 之后，一致性策略由 wait_for_active_shards 参数控制：
即确定客户端返回数据之前必须处于active 的分片分片数（包括主分片和副本），默认为 wait_for_active_shards = 1，即只需要主分片写入成功，设置为 all或任何正整数，最大值为索引中的分片总数 ( number_of_replicas + 1 )。如果当前 active 状态的副本没有达到设定阈值，写操作必须等待并且重试，默认等待时间30秒，直到 active 状态的副本数量超过设定的阈值或者超时返回失败为止。
。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f8c7cfdf4937e2670bf4e374c5b3fb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0367f0d8d158d890367e26dbef2dabf3/" rel="bookmark">
			微信小程序基础工作模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.轮播图 点击跳转官方文档
简单例子 &lt;!-- 顶部轮播图 --&gt; &lt;swiper indicator-dots="true" class="banner" autoplay="true" interval="2000"&gt; &lt;swiper-item&gt; &lt;image src="../../images/轮播图1.jpg" &gt;&lt;/image&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;image src="../../images/轮播图2.jpg" &gt;&lt;/image&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;image src="../../images/轮播图3.jpg" &gt;&lt;/image&gt; &lt;/swiper-item&gt; &lt;/swiper&gt; `&lt;swiper&gt;` 组件通常用于实现轮播图效果。
1. indicator-dots="true"：
* `indicator-dots` 属性用于控制是否显示面板指示点。
* `true` 表示显示指示点，即在轮播图的下方显示一些小的圆点，每个圆点代表一个轮播项，当前激活的轮播项对应的圆点会被高亮显示。
2. autoplay="true"（通常配合interval使用）：
* `autoplay` 属性用于控制是否自动切换轮播项。
* `true` 表示自动切换，即轮播图会自动滚动到下一个轮播项。
3. interval="2000"：
* `interval` 属性用于设置自动切换时间间隔，单位是毫秒（ms）。
* 在这个例子中，`interval="2000"` 表示每过 2000 毫秒（即 2 秒）轮播图会自动滚动到下一个轮播项。
2.导航 &lt;!-- 导航图 --&gt; &lt;view class="body"&gt; &lt;navigator url="../spring/index" class="body-item"&gt; &lt;image src="../../images/荠菜（野荠）.png" class="pic" &gt;&lt;/image&gt; &lt;view class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0367f0d8d158d890367e26dbef2dabf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a21587f57cc23fde4d11d3f493684171/" rel="bookmark">
			集成学习概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 集成学习(Ensemble learning)就是将多个机器学习模型组合起来，共同工作以达到优化算法的目的。具体来讲，集成学习可以通过多个学习器相结合，来获得比单一学习器更优越的泛化性能。集成学习的一般步骤为：1.生产一组“个体学习器(individual learner)”；2.用某种策略将他们结合起来。
个体学习器通常由一个现有的学习算法从训练数据产生。在同质集成（系统中个体学习器的类型相同）中，个体学习器又被称为“基学习器”，而在异质集成（系统中个体学习器的类型不同）中，个体学习器又被称为“组建学习(component learner)”。
集成学习的集成框架主要有：Bagging，Boosting和Stacking，其中Bagging和Boosting为同质集成，而Stacking为异质集成。
Bagging可以减少弱分类器的方差，而Boosting 可以减少弱分类器的偏差;
Bagging就是再取样 (Bootstrap) 然后在每个样本上训练出来的模型取平均，所以是降低模型的variance. Bagging 比如Random Forest 这种先天并行的算法都有这个效果。
Boosting 则是迭代算法，每一次迭代都根据上一次迭代的预测结果对样本进行加权，所以随着迭代不断进行，误差会越来越小，所以模型的 bias 会不断降低。这种算法无法并行，如Adaptive Boosting.
多样性增强的几种方法 一般的做法主要是对数据样本，输入属性，输出表示，算法参数进行扰动。
（1）数据样本扰动
这个其实主要就是采样，比如在bagging中的自助采样法，数据样本扰动对决策树，神经网络这样对数据样本变化非常敏感的学习算法非常有效，但是对支持向量机，朴素贝叶斯，k近邻这些对样本扰动不敏感的算法没用。对此类算法作为基学习器进行集成时往往需要使用输入属性扰动等机制。（2）输入属性扰动
这个就是从样本的特征空间中产生不同的特征子集。这样训练出来的基学习器必然是不同的。在包含大量冗余属性的数据，在特征子集中训练基学习器不仅能产生多样性大的个体，还会因属性数的减少而大幅节省时间开销，同时，由于冗余属性多，减少一些冗余属性后训练出来的基学习器性能也不会差。若数据只包含少量属性，或者冗余属性少，则不适宜使用输入属性扰动法。（3）输出表示扰动
这类做法的基本思路是对输出表示进行操纵以增强多样性。比如可对训练样本的label稍作变动，比如“翻转法”随机改变一些训练样本的标记；也可以对输出表示进行转化，如“输出调制法”将分类输出转化为回归输出后构建基学习器。这一类貌似用的不多。（4）算法参数扰动
这个在现在深度学习比赛中很常见，主要是神经网络有很多参数可以设置，不同的参数往往可以产生差别比较大的基学习器。 Bagging 核心思想：并行地训练一系列各自独立的同类模型，然后再将各个模型的输出结果按照某种策略进行聚合。例如，分类中可以采用投票策略，回归中可以采用平均策略;Bagging主要分为两个阶段：
步骤：
Boostrap阶段，即采用有放回的采样方式，将训练集分为n个子样本集；并用基学习器对每组样本分布进行训练，得到n个基模型；Aggregating阶段，将上一个阶段训练得到的n个基模型组合起来，共同做决策。在分类任务中，可采用投票法，比如相对多数投票法，将结果预测为得票最多的类别。而在回归任务中可采用平均法，即将每个基模型预测得到的结果进行简单平均或加权平均来获得最终的预测结果。 Bagging就是再取样 (Bootstrap) 然后在每个样本上训练出来的模型取平均，所以是降低模型的variance.；Bagging 比如Random Forest 这种先天并行的算法都有这个效果
随机森林（Random Forest） 1. 算法原理 随机森林（Random Forest）是一种基于决策树的集成学习方法。它通过构建多个决策树，并将它们的预测结果进行投票（分类问题）或平均（回归问题），以获得最终的预测结果。随机森林的构建过程包括两个关键步骤：自助采样（bootstrap sampling）和特征随机选择。自助采样用于生成不同的训练数据子集，每个子集用于构建一个决策树。特征随机选择则在每个决策树节点上随机选择一部分特征进行划分，以增加决策树的多样性。这两个步骤共同提高了随机森林的泛化能力和鲁棒性。
2.优缺点 优点：
a) 随机森林具有较高的预测准确性，通常比单个决策树的性能要好。
b) 能够有效地处理高维数据和大量特征。
c) 对噪声和异常值具有较强的鲁棒性。
d) 可以进行特征重要性评估，有助于特征选择。
e) 并行化能力强，易于实现并行计算。
缺点：
a) 相比单个决策树，随机森林的模型可解释性较差。
b) 训练和预测时间可能较长，尤其是在大数据集上。
c) 对于某些不平衡的数据集，随机森林的性能可能不尽如人意。
3.适用场景 随机森林适用于以下场景：
a) 需要提高预测准确性的分类和回归问题。
b) 数据集具有高维特征或特征数量较多。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a21587f57cc23fde4d11d3f493684171/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/103bd4c8fa9c5db1fd8756b758dbe399/" rel="bookmark">
			kafka的leader和follower
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 leader和follower kafka的leader和follower是相对于分区有意义的，不是相对于broker。
因为每个分区都有leader和follower,
leader负责读写数据。
follower负责复制leader的数据保存到自己的日志数据中，并在leader挂掉后重新选举出leader。
kafka会再创建topic的时候尽量让分配分区的leader在不同的broker中，就是负载均衡。
与Zookeeper区分 zookeeper的leader负责读写，follower可以读取。
kafka的leader负责读写，follower不能读写数据(确保每个消费者消费的数据是一致的)，kafka一个topic有多个分区leader，一样可以实现负载均衡。
AR/ISR/OSR kafka的follower可以分为三类：AR ISR OSR
AR(Assigned Replicas)表示一个topic下的所有副本。ISR(In-Sync Replicas)表示一个topic下正在同步的副本。OSR表示(OUT-SYNC-Replicas)不再同步的副本。 AR=ISR+OSR
查看分区的ISR 使用Kafka Eagle查看某个Topic的partition的ISR有哪几个节点。
partition是创建的topic为test的 0 1 2 三个分区。
Log Size是日志文件的大小
Leader是leader副本在那个broker节点上
Replicas是它的副本在哪些broker节点上。
In sync Replicas是正在同步的副本（包括leader）
尝试关闭id为0的broker（杀掉该broker的进程），参看topic的ISR情况。
leader的选举 leader的选举对于消息的写入以及读取非常关键，此时有两个疑问：
kafka是如何确定partition的哪个副本是leader，那个副本是follower呢？某个leader崩溃后，怎么快速确定另一个leader呢？因为Kafka的吞吐量很高、延迟很低，所以选举leader必须非常快 leader崩溃，kafka如果处理 使用Kafka Eagle找到某个partition的leader，再找到leader所在的broker。在Linux中强制杀掉该Kafka的进程，然后观察leader的情况。
通过观察，我们发现，leader在崩溃后，Kafka又从其他的follower中快速选举出来了leader。
Controller kafka启动的时候，会在所有的broker中选举出controller前面的leader和follower是针对partition的副本，而controller是针对broker的。创建topic或者添加分区，修改副本数量之类的管理任务都是交给controller完成的。kafka分区leader的选举，也是由controller决定的。 Controller的选举
在kafka集群启动的时候，每个broker都会尝试去Zookeeper上注册为controller（ZK临时节点）但是只有一个竞争成功，其他的broker会注册该节点的监视器。一但节点的状态发生变化，就可以进行处理。Controller也是高可用的，一旦某个broker崩溃，其他的broker会重新注册为Controller。 Controller选举partition的leader 所有Partition的leader选举都由controller决定.controller会将leader的改变通过RPC的方式通知需要为此做出响应的Brokercontroller读取当前分区的ISR,只要有一个Replica还幸存，就选择其中一个作为leader。如果该partition的所有Replica都已经宕机，则新的leader为-1 为什么不通过ZK的方式进行选举？ 如果kafka是居于ZK进行选举，ZK的压力比较大，例如某个节点崩溃，这个节点上不仅仅只有一个leader，是有不少的leader需要选举，通过ISR可以快速选举。
leader的负载均衡 kafka中引入Preferred Replica的概念，意思是优先的Replica。
在ISR中第一个replica就是preferred-replica.
副本存放的第一个broker，肯定就是preferred-replica
执行以下脚本可以将preferred-replica设置为leader，均匀分配每个分区的leader。
./kafka-leader-election.sh --bootstrap-server node1.itcast.cn:9092 --topic 主题 --partition=1 --election-type preferred 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e28b9f549241f18343f774e26db63e33/" rel="bookmark">
			深入解析Kafka消息传递的可靠性保证机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深入解析Kafka消息传递的可靠性保证机制 Kafka在设计上提供了不同层次的消息传递保证，包括at most once（至多一次）、at least once（至少一次）和exactly once（精确一次）。每种保证通过不同的机制实现，下面详细介绍Kafka如何实现这些消息传递保证。
1. At Most Once（至多一次） 在这种模式下，消息可能会丢失，但不会被重复传递。这通常发生在消费者在处理消息之前提交了偏移量，导致即使消息处理失败，也认为已经处理完成。
实现机制： 消费者配置enable.auto.commit=true，并且默认提交偏移量的时间间隔较短（auto.commit.interval.ms）。消费者在处理消息之前提交偏移量，处理过程中如果发生故障，消息不会被重新处理。 2. At Least Once（至少一次） 在这种模式下，消息不会丢失，但可能会被重复传递。消费者确保在处理消息后才提交偏移量，故障恢复后会重新处理未提交偏移量的消息。
实现机制： 消费者配置enable.auto.commit=false，手动提交偏移量。消费者在处理完每条消息后调用consumer.commitSync()或consumer.commitAsync()提交偏移量。 示例代码：
Properties props = new Properties(); props.put("bootstrap.servers", "your_kafka_broker:9092"); props.put("group.id", "test_group"); props.put("enable.auto.commit", "false"); props.put("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer"); props.put("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer"); KafkaConsumer&lt;String, String&gt; consumer = new KafkaConsumer&lt;&gt;(props); consumer.subscribe(Arrays.asList("your_topic")); try { while (true) { ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(100)); for (ConsumerRecord&lt;String, String&gt; record : records) { // 处理消息 } consumer.commitSync(); // 确保消息处理后提交偏移量 } } finally { consumer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e28b9f549241f18343f774e26db63e33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/129851e9eb896eb5b3b23ef0c5c62203/" rel="bookmark">
			深入解析Kafka消息丢失的原因与解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深入解析Kafka消息丢失的原因与解决方案 Apache Kafka是一种高吞吐量、分布式的消息系统，广泛应用于实时数据流处理。然而，在某些情况下，Kafka可能会出现消息丢失的情况，这对于数据敏感的应用来说是不可接受的。本文将深入解析Kafka消息丢失的各种原因，包括生产者、broker和消费者配置问题，以及硬件故障等。同时，我们将提供详细的解决方案和最佳实践，帮助您确保Kafka消息的可靠传递，提升系统的稳定性和数据安全性。
一、Kafka消息丢失的原因 生产者配置问题： acks配置：生产者的acks配置决定了生产者在发送消息时需要等待的确认数量。如果设置为0（不等待确认）或1（只等待leader确认），在leader broker宕机的情况下，消息可能丢失。重试配置：生产者未设置足够的重试次数或者未开启重试，网络抖动或临时故障可能导致消息丢失。未启用幂等性：未启用幂等性（idempotence），在生产者重试发送时可能会产生重复数据。 broker配置问题： min.insync.replicas设置：如果min.insync.replicas设置过低，允许在较少副本（replica）在线的情况下确认写入操作，可能导致数据丢失。replication.factor设置：如果副本数（replication factor）设置较低（例如1），当broker宕机时，消息没有副本可以恢复。 消费者配置问题： 自动提交偏移量：如果消费者配置为自动提交偏移量（auto commit），在消息处理失败或消费者宕机时，可能会丢失未处理的消息。 硬件故障： 磁盘故障、网络分区或节点宕机会导致消息丢失。 二、解决方案 1. 生产者配置 acks设置为all：
Properties props = new Properties(); props.put("acks", "all"); 启用幂等性和重试：
props.put("enable.idempotence", "true"); // 确保幂等性 props.put("retries", Integer.MAX_VALUE); // 最大重试次数 其他重要配置：
props.put("max.in.flight.requests.per.connection", "5"); // 限制每个连接的最大请求数 props.put("request.timeout.ms", "30000"); // 请求超时时间 props.put("retry.backoff.ms", "100"); // 重试之间的等待时间 2. Broker配置 设置min.insync.replicas：
min.insync.replicas=2 这意味着至少有两个副本需要确认消息已写入，才能认为消息成功。
增加副本数（replication factor）：
kafka-topics --alter --topic your_topic --partitions 3 --replication-factor 3 --zookeeper your_zookeeper:2181 副本数设置为3是一个比较好的实践，确保即使有一个broker宕机，数据依然是安全的。
3. 消费者配置 禁用自动提交偏移量：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/129851e9eb896eb5b3b23ef0c5c62203/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/289/">«</a>
	<span class="pagination__item pagination__item--current">290/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/291/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>