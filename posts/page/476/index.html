<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12ec9de5afd668686be8d49a52bdeebf/" rel="bookmark">
			盘点Python中4种读取JSON文件和提取JSON文件内容的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、使用json模块的load()方法
二、使用json模块的loads()方法
三、使用pandas库的read_json()方法
四、使用第三方库如requests从网络API获取JSON数据
总结
JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，它基于ECMAScript的一个子集，采用完全独立于语言的文本格式来存储和表示数据。Python中提供了多种方式来读取和处理JSON文件，本文将详细介绍四种常见的方法，并附带案例和代码，帮助新手朋友快速上手。
一、使用json模块的load()方法 Python的json模块提供了丰富的函数来解析和处理JSON数据。其中，load()方法用于读取JSON文件并将其解析为Python对象。
案例与代码：
假设我们有一个名为data.json的JSON文件，内容如下：
{ "name": "张三", "age": 30, "city": "北京" } 我们可以使用以下代码来读取并解析这个文件：
import json # 打开文件并读取内容 with open('data.json', 'r', encoding='utf-8') as file: # 使用json.load()方法解析JSON数据 data = json.load(file) # 打印解析后的Python对象 print(data) print(data['name']) # 提取name字段的值 print(data['age']) # 提取age字段的值 二、使用json模块的loads()方法 与load()方法不同，loads()方法用于将JSON格式的字符串解析为Python对象。如果你已经将JSON文件的内容读取为一个字符串，那么可以使用这个方法。
案例与代码：
首先，读取JSON文件内容到字符串中：
import json # 读取文件内容到字符串中 with open('data.json', 'r', encoding='utf-8') as file: json_str = file.read() # 使用json.loads()方法解析JSON字符串 data = json.loads(json_str) # 打印解析后的Python对象 print(data) print(data['name']) # 提取name字段的值 三、使用pandas库的read_json()方法 对于处理大量数据和表格形式的数据，pandas库是一个非常强大的工具。它提供了一个read_json()方法，可以方便地将JSON文件读取为DataFrame对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12ec9de5afd668686be8d49a52bdeebf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50c150fa973d4a581c545b91c169c10e/" rel="bookmark">
			全代码分享｜R语言孟德尔随机化怎么做？TwoSampleMR包MR一套标准流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.前言1.1 成立条件1.2 三大要素1.3 统计原理 2.demo2.1 加载R包2.2 主要MR分析2.3 MR补充分析、多态性、验证 2.4 结果可视化 1.前言 孟德尔随机化(Mendelian randomization，MR)是一种利用基因变异作为工具变量来评估暴露与结果之间因果关系的统计方法。
它基于这样的原理：基因变异是在出生前就随机分配给个体的，类似于在随机对照试验中随机分配治疗，因此可以帮助区分因果关系和简单相关性。孟德尔随机化通常用于观察性数据，以确定一个特定的生物标志物、行为或其他暴露是否真正地影响了健康结果，而不是仅仅与之相关。通过这种方法，研究者可以减少混杂因素的影响，避免了传统观察性研究中常见的一些偏差。
1.1 成立条件 孟德尔随机化方法的关键在于三个基本假设的成立：
相关性假设（Relevance assumption）：所选的遗传变异与暴露因素必须有明确的关联。这意味着这些遗传变异能够作为影响暴露水平的可靠指标。独立性假设（Independence assumption）：遗传变异与任何影响结果的混杂因素必须独立。基于孟德尔遗传定律，遗传变异在受精时随机分配给后代，这个随机分配过程保证了其与后天环境因素的独立性。排他性假设（Exclusion restriction assumption）：遗传变异对结果的影响只能通过其对暴露的影响来体现，不应存在其他路径。这意味着遗传变异与结果之间的关联完全是通过暴露因素介导的。 孟德尔随机化的实施通常需要大量的基因组数据，包括与暴露因素和结果变量相关的遗传变异信息。通过统计分析这些数据，研究者可以估计出暴露与结果之间的因果关系大小。
这种方法在流行病学和遗传流行病学领域尤其有用，特别是在探索疾病的潜在风险因素时。不过，孟德尔随机化研究的解释需要谨慎，因为违反上述任一假设都可能导致估计的偏误。此外，该方法还受限于可用的遗传变异信息和样本大小。
1.2 三大要素 在孟德尔随机化研究中，主要涉及三个关键组成部分：暴露因素、结果，以及作为连接两者的桥梁的遗传变异。
暴露因素：这指的是可能对某个健康结果产生影响的任何因素，如生活方式、环境因素、生物标志物等。在孟德尔随机化中，研究人员试图评估这种暴露是否对结果具有因果效应。例如，暴露因素可以是饮酒量、体育锻炼、血压或血脂水平等。
结果：这是研究的终点，通常是健康相关的结果，如疾病发生、健康状况指标、生理测量值等。在孟德尔随机化研究中，结果是研究者试图了解其是否受到暴露因素的影响。例如，结果可以是心血管疾病、糖尿病、肥胖或寿命等。
遗传变异：在孟德尔随机化框架中，遗传变异是连接暴露因素和结果的关键。这些遗传变异（通常是单核苷酸多态性，SNPs）根据遗传原理，在人群中随机分布，与暴露因素具有相关性但又不受后天环境因素的影响。遗传变异作为工具变量，其作用是帮助研究者推断暴露因素与结果之间的因果关系，而不是仅仅描述它们之间的关联。这些遗传变异必须满足特定条件，即与暴露因素强相关、与混杂因素无关，且仅通过影响暴露因素来影响结果。
1.3 统计原理 孟德尔随机化分析中通常使用的是工具变量(IV)估计的数学框架。这个框架可以帮助我们理解如何通过遗传变异（作为工具变量）来估计一个暴露因素对结果的因果效应。下面是一个简化的版本，描述了这一过程中涉及的主要步骤和公式。
看起来你对LaTeX格式的数学公式表示很感兴趣！那么，按照你提供的官方格式，孟德尔随机化中的关键公式也可以这样优雅地展示：
第一阶段回归：
给定遗传变异 (Z) 对暴露因素 (X) 的影响可以表示为：
X = α + β Z X Z + ϵ X = \alpha + \beta_{ZX}Z + \epsilon X=α+βZX​Z+ϵ
其中，(X) 代表暴露因素，(Z) 是遗传变异（工具变量），(\alpha) 是截距，(\beta_{ZX}) 表示遗传变异对暴露因素的影响程度，(\epsilon) 是误差项。
第二阶段回归：
调整后的暴露因素 (X) 对结果 (Y) 的影响可以通过下面的方程来估计：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50c150fa973d4a581c545b91c169c10e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b50618c9da23924d15916a91c0eacf84/" rel="bookmark">
			前端npm和yarn更换国内淘宝镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NPM 查询当前镜像 npm get registry 设置为淘宝镜像
npm config set registry https://registry.npm.taobao.org/ (旧地址)
npm config set registry https://registry.npmmirror.com/ (最新地址)
设置为官方镜像
npm config set registry https://registry.npmjs.org/
YARN
查询当前镜像 yarn config get registry
设置为淘宝镜像
yarn config set registry https://registry.npm.taobao.org/ (旧地址)
yarn config set registry https://registry.npmmirror.com/ (最新地址)
设置为官方镜像
yarn config set registry https://registry.yarnpkg.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6bae6f309a454b16839265b439e21ce/" rel="bookmark">
			Visual Studio Code 配置 java/maven 环境(Windows版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装JDK 进入Oracle官网下载jdk，本文已jdk8为主
官网下载地址：Java Downloads | Oracle
配置系统环境变量： 1.JAVA_HOME 创建系统环境变量 JAVA_HOME, 赋值为 jdk安装路径
(Maven 由 Java 开发，执行时需用到环境变量 JAVA_HOME )
2.PATH 编辑 PATH 环境变量内容，添加 %JAVA_HOME%\bin (暴露JDK自带指令给外部)
(可参考：VsCode 配置java环境（详细教程）_vscode配置java开发环境-CSDN博客)
2.安装maven 进入Apache Maven官网下载maven
官网下载地址：Maven – Download Apache Maven
3.配置vscode插件 Extension Pack for Java： 核心插件，负责管理 Java 项目，内带 Maven for Java 插件，以管理 maven。
Spring Initializr Java Support： Spring 项目快速构建插件
4.vscode基本配置 打开 vscode 配置，输入java，查看其相关配置
4.1 Maven 配置 maven 的 settings.xml 位置 （存放位置不重要，内部内容重要）
4.2 Maven for Java 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6bae6f309a454b16839265b439e21ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db5d7af24e0755338ad4d5bc6fba496b/" rel="bookmark">
			SeaTunnel-web in K8S
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载，官网下载有问题，上dlcdn.apache.org下载
https://dlcdn.apache.org/seatunnel/seatunnel-web/1.0.0/apache-seatunnel-web-1.0.0-bin.tar.gz
apache-seatunnel-2.3.3中执行bin/install-plugin.sh下载connectors
下载web的源码
https://github.com/apache/seatunnel-web.git
seatunnel-server/seatunnel-app/src/main/bin/download_datasource.sh
将download_datasource.sh复制到/root/seatunnel/apache-seatunnel-web-1.0.0-bin/bin目录
sh download_datasource.sh 下载 datasource
vim conf/application.yml修改端口号和数据源信息
根据script目录下的数据表初始化脚本，把数据库建好 seatunnel_server_mysql.sql
将apache-seatunnel-2.3.4/conf目录下的hazelcast-client.yaml和plugin-mapping.properties复制过来
hazelcast-client.yaml中的信息连接到之前部署好的SeaTunnel集群
参考：SeaTunnel 2.3.4 Cluster in K8S-CSDN博客
logback-spring.xml文件中的日志级别如果需要可改成debug方便调试
准备创建镜像文件
apache-seatunnel-2.3.3（重命名为：seatunnel-zeta）和apache-seatunnel-web-1.0.0-bin（重命名为：seatunnel，web依赖zeta连接集群）都放在一个容器中。
在镜像中配置相关的环境变量
SEATUNNEL_HOME=/opt/seatunnel-zeta
SEATUNNEL_WEB_HOME=/opt/seatunnel
ST_WEB_BASEDIR_PATH=/opt/seatunnel/ui
将connectors和plugins目录复制到web下，打包后拷贝到镜像中，然后镜像中编写的启动脚本会把该目录移动到seatunnel-zeta目录下，不然在web界面选择不了数据源，connectors又依赖plugins cp -r /root/seatunnel/apache-seatunnel-2.3.3/connectors /root/seatunnel/apache-seatunnel-web-1.0.0-bin/
cp -r /root/seatunnel/apache-seatunnel-2.3.3/plugins /root/seatunnel/apache-seatunnel-web-1.0.0-bin/
创建启动脚本 web自带的是后台启动，所以需要自己写个脚本在容器中前台运行
vi apache-seatunnel-web-1.0.0-bin/start.sh
一定要在bin目录下执行启动后的脚本 sh bin/seatunnel-backend-daemon.sh start ，不然找不到首页 jetty err_empty_response 404
参考：CentOs7.x安装部署SeaTunnelWeb遇到的坑_seatunnel unable to connect to any cluster-CSDN博客
#!/bin/bash cp /opt/seatunnel-zeta/lib/* /opt/seatunnel/libs/ cp /opt/seatunnel/libs/datasource*.jar /opt/seatunnel-zeta/lib/ mv -r /opt/seatunnel/connectors /opt/seatunnel-zeta/ cd /opt/seatunnel/ # 一定要在这个目录执行，不然找不到首页 jetty err_empty_response 404 # https://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db5d7af24e0755338ad4d5bc6fba496b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09c0158e553c264d9bc9f256e844979a/" rel="bookmark">
			docker部署rustdesk远程控制服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、rustdesk是什么？二、服务端配置1.安装docker2、拉取镜像3、运行容器3、防火墙配置 三、客户端配置 前言 本实例主要方便在内网没有远程控制环境下使用
一、rustdesk是什么？ rustdesk是github上一个开源的远程控制项目。
二、服务端配置 1.安装docker 参考这个
https://blog.csdn.net/gsl371/article/details/107567731 2、拉取镜像 docker image pull rustdesk/rustdesk-server [root@localhost ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE rustdesk/rustdesk-server latest 9a7dedfd1994 5 weeks ago 23.5MB 3、运行容器 #创建目录 mkdir -p /opt/rustdesk/{hbbs,hbbr}/root #拉去镜像 -r后为中继服务器地址，如果在公网，需要指定公网地址或私网映射出去的地址，-k 为客户端配置是输入的key，--net=host表示容器应用使用宿主机网络，不需要再进行dockers端口映射，方便。 docker run --restart=always --name hbbs -v /opt/rustdesk/hbbs/root:/root -td --net=host rustdesk/rustdesk-server hbbs -r 192.168.1.11 -k 123456 docker run --restart=always --name hbbr -v /opt/rustdesk/hbbr/root:/root -td --net=host rustdesk/rustdesk-server hbbr 查看结果
[root@localhost ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1c9452d8d1cb rustdesk/rustdesk-server "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09c0158e553c264d9bc9f256e844979a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51b4c64abf783bf9d9527e87e05995ae/" rel="bookmark">
			老虎/TiggerRamDisk注册/下载/官网 绕过激活锁，屏幕锁隐藏工具，支持最新iOS17系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		支持的版本：iOS12.0 ~ 17.3
支持的型号：
iPhone 6 6s、6sp、SE、7、7P、8、8P、X
iPad Air 2 WiFi (A1566)
iPad Air 2 4G (A1567)
iPad Mini 4 WiFi (A1538)
iPad Mini 4 4G (A1550)
iPad 5 2017 WiFi (A1822)
iPad 5 2017 4G (A1823)
iPad 6 2018 WiFi (A1893)
iPad 6 2018 4G (A1954)
iPad 7 2019 WiFi (A2197)
iPad 7 2019 4G (A2198、A2199、A2200)
iPad Pro10.5 Wi-Fi + Cellular (A1701 A1709)
iPad Pro 9.7/12.9寸 1代 (1673、1674、1675、1584、1652)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51b4c64abf783bf9d9527e87e05995ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49c6394525126343c063a7f2f1edb91b/" rel="bookmark">
			如何使用ADB Sideload 线刷第三方ROM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解锁Bootloader 任何刷机和root的前提都是解锁bl。现在国内只有小米和一加手机支持解锁bl后还有手机质保，而小米除了出厂HyperOS的手机外解锁起来都较为简单，只是需要等待罢了。
关于MIUI14及以下的系统如何解锁bootloader，其实非常简单。在开发者选项中的设备解锁状态页面中绑定后等待168个小时，然后将手机重启至bootloader模式，连接至Windows电脑用小米官方的解锁工具进行解锁即可。
准备文件 我们在开始刷机前需要将以下文件在电脑上准备好：
需要刷入的第三方ROM压缩包需要刷入的第三方Recovery镜像文件手机正在使用的系统的卡刷包或线刷包Android Platform Tools（包含adb、fastboot等刷机需要用到的程序，SDK版本不能过低） 刷入TWRP 对于较新的使用V-A/B分区的安卓系统，TWRP的刷入稍有不同。
我们将手机切换到bootloader模式，手机在显示第一屏后会保持在橙色的FASTBOOT界面。
将手机通过USB数据线连接至Windows电脑，在CMD中输入：
cd PathToFastboot :: 切换到保存有fastboot可执行文件的目录，比如小米解锁工具的目录下 .\fastboot devices :: 检查是否有输出，即设备是否有被电脑识别 .\fastboot flash --disable-verity --disable-verification vbmeta_a vbmeta.img :: 将vbmeta.img刷入插槽a，vbmeta.img需从正在使用的ROM中提取（可从对应ROM的卡刷包或线刷包中提取。） .\fastboot flash --disable-verity --disable-verification vbmeta_b vbmeta.img :: 将vbmeta.img刷入是插槽b .\fastboot flash recovery_a TWRP.img :: 将TWRP刷入插槽a，TWRP.img为你下载的适配你的设备的TWRP的文件名 .\fastboot flash recovery_b TWRP.img :: 将TWRP刷入插槽b .\fastboot reboot recovery :: 启动TWRP 命令如果都执行成功的话，手机会进入如下界面：
刷入第三方ROM 我们首先点击Select Language选择语言为Chinese (Simplified)：
然后输入锁屏密码进入TWRP的界面：
点击高级：
然后点击右上角的ADB Sideload：
滑动下方的滑块后将手机通过USB数据线连接至电脑：
在电脑上使用以下代码查看设备是否已连接：
cd PathToAndroidPlatformTools :: 切换到adb所在的目录 .\adb devices :: 看到attached列下有sideload字样即为连接成功 如图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49c6394525126343c063a7f2f1edb91b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ecd5084218af25b78650f11f4d3b6a4/" rel="bookmark">
			【死磕Elasticsearch】从实战中来，到实战中去
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 写在前面：1、索引阻塞的种类2、什么时候使用阻塞？场景1：进行系统维护场景。场景2：保护数据不被随意更改场景。场景3：优化资源使用的场景。场景4：遵守安全规则场景。 3、添加索引阻塞API4、解除设置API5、小结6、参考文档粉丝福利 写在前面： Elasticsearch 是一种强大的搜索和分析引擎，被广泛用于各种应用中，以其强大的全文搜索能力而著称。
不过，在日常管理 Elasticsearch 时，我们经常需要对索引进行保护，以防止数据被意外修改或删除，特别是在进行系统维护或者需要优化资源使用时。
Elasticsearch提供了一种名为“索引阻塞（Index blocks）”的功能，让我们能够限制对某个索引的操作类型。
Elasticsearch的索引阻塞功能在早期版本中就已存在，用于管理对索引的访问和操作。随着 Elasticsearch 版本的更新，该功能也在不断得到改进和扩展。
参见官方文档：https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules-blocks.html
大白话——"索引阻塞"就是给我们的索引加把锁，防止别人随意修改。
1、索引阻塞的种类 Elasticsearch中的索引阻塞可以根据需要，限制对索引的读取、写入或元数据操作。
所谓的元数据，可以理解为索引的基本信息和设置，比如索引包含哪些字段，这些字段是什么类型的等等。
这些阻塞可以通过动态索引设置添加或移除，也可以通过专门的API来添加，这样做的好处是能确保在添加写入阻塞后，所有索引的分片都正确地应用了阻塞，比如确保在添加写入阻塞后，所有正在进行的写入操作都已完成。
以下是一些动态索引设置，用于确定索引上存在的阻塞类型：
index.blocks.read_only：设置为 true 使索引及索引元数据只读，设置为false则允许写入和元数据更改。index.blocks.read_only_allow_delete：类似于index.blocks.read_only，但也允许删除索引以释放更多资源。index.blocks.read：设置为 true 以禁用对索引的读取操作。index.blocks.write：设置为 true 以禁用对索引的数据写入操作。与read_only不同，这个设置不影响元数据。例如，你可以调整带有写入阻塞的索引的设置，但不能调整带有read_only阻塞的索引的设置。index.blocks.metadata：设置为true以禁用索引元数据的读写操作。 设置名称描述index.blocks.read_only设置为true使索引及索引元数据只读，设置为false则允许写入和元数据更改。index.blocks.read_only_allow_delete类似于index.blocks.write，但也允许删除索引以释放更多资源。磁盘基础的分片分配器可能会自动添加和移除这个阻塞。index.blocks.read设置为true以禁用对索引的读取操作。index.blocks.write设置为true以禁用对索引的数据写入操作。与read_only不同，这个设置不影响元数据。例如，你可以调整带有写入阻塞的索引的设置，但不能调整带有read_only阻塞的索引的设置。index.blocks.metadata设置为true以禁用索引元数据的读写操作。 解释一下：index.blocks.read_only 和 index.blocks.write 区别？
如下设置了禁止写入，但是可以修改索引的设置，比如：副本数的调整，这个是允许的。
PUT test-001/_settings { "blocks.write": true } PUT test-001/_settings { "number_of_replicas": 2 } 但是换成这样：
PUT test-002 PUT test-002/_settings { "blocks.read_only": true } PUT test-002/_settings { "number_of_replicas": 2 } 如上的 read_only 设置后，如果再进行修改索引设置的设置就会报错。
{ "error": { "root_cause": [ { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ecd5084218af25b78650f11f4d3b6a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e77ac313575ebbb778082a5f20857a8d/" rel="bookmark">
			【数据结构】初识二叉搜索树（Binary Search Tree）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 1. 二叉搜索树的概念2. 二叉搜索树的操作1.1 二叉搜索树的查找1.2 二叉搜索树的插入1.3 二叉搜索树的删除 1. 二叉搜索树的概念 二叉搜索树又称二叉排序树，它可能是一棵空树，也可能是具有以下性质的二叉树：
若它的左子树不为空，则左子树上所有节点的值都小于根节点的值。若它的右子树不为空，则右子树上所有节点的值都大于根节点的值。它的左右子树也分别为二叉搜索树。 2. 二叉搜索树的操作 int a[] = { 8, 3, 1, 10, 6, 4, 7, 14, 13 }; 1.1 二叉搜索树的查找 从根开始比较、查找，比根大则往右边走查找，比根小则往左边走查找。最多查找高度次，若走到空还没找到，则这个值不存在。 1.2 二叉搜索树的插入 树为空，则直接新增节点，赋值给 root 指针。树不空，按二叉搜索树性质查找插入位置，插入新节点。 1.3 二叉搜索树的删除 首先查找元素是否在二叉搜索树中，如果不存在，就返回；否则要删除的节点可能分下面四种情况：
要删除的节点无孩子节点；要删除的节点只有左孩子节点；要删除的节点只有右孩子节点；要删除的节点有左、右孩子节点。 看起来待删除节点有 4 种情况，实际情况 a 可以与情况 b 或者情况 c 合并起来，因此真正的删除过程如下：
情况 b ：删除该节点且使被删除节点的双亲节点指向被删除节点的左孩子节点 - 直接删除；情况 c ：删除该节点且使被删除节点的双亲节点指向被删除节点的右孩子节点 - 直接删除；情况 d ：在它的右子树中寻找中序下的第一个节点（关键码最小），用它的值填补到被删除节点中，再来处理该节点的删除问题 - 替换法删除。 本文完 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3c181742d4c50e43ade9c1706956789/" rel="bookmark">
			【C&#43;&#43;】string学习 — 手搓string类项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手搓string项目 1 string类介绍2 功能描述3 代码实现3.0 基础框架3.1 构造函数 和 析构函数3.2 流操作符重载 和 尾插扩容3.4 运算符重载3.5 实用功能3.6 迭代器模拟 总结这里提供一下源代码：Thanks♪(･ω･)ﾉ谢谢阅读！！！下一篇文章见！！！ 1 string类介绍 C++ 的 string 类是 C++ 标准库中提供的一个用于处理字符串的类。它在 C++ 的历史中扮演了重要的角色，为字符串处理提供了更加方便、高效的方法。
在 C++ 的早期版本中，字符串处理并不是一个简单的事情。在 C++ 的最初版本中，字符串被处理为 char* 类型的指针，这使得字符串处理变得非常复杂，容易出错。例如，简单的字符串连接操作都需要手动管理内存，这无疑增加了编程的难度。
为了解决这个问题，C++98 引入了 头文件，其中包含了 string 类。这个类的引入，可以说是一场革命，因为它提供了一个安全、方便、可移植的字符串处理方式。也为以后STL的出现埋下了伏笔…
在现实生活中，string也有着大量的应用：
社交媒体： 当你在社交媒体上发布状态或评论时，你输入的文字内容会存储在一个 string 变量中。例如，你可能会写一条消息 like “I had a great day at the park!”，这条消息就是存储在一个 string 变量中的。电子邮件： 当你写一封电子邮件时，正文内容、主题行和收件人地址等都可能是 string 类型的。例如，你可能会写一封主题为 “Meeting Invitation” 的邮件，内容为 “Dear John, please join us for a meeting at 10am tomorrow.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3c181742d4c50e43ade9c1706956789/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a60d65f39d45bcfb01a205be6946046d/" rel="bookmark">
			python迭代器和生成器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		迭代器（Iterator）和生成器（Generator）在python中都是处理序列数据时非常重要的概念，它们都属于python的迭代协议的一部分，用于遍历数据集合。
目录
一、迭代器
1、什么是迭代器
2、创建迭代器
1）、内置类型迭代：
2）、自定义迭代器类：
二、生成器
1、什么是生成器
2、创建生成器
方式1：
方式2：
3、访问生成器
方式1：
方式2：
方式3：
方式4：
4、生成器的应用实例：
三、总结
生成器（Generator）
一、迭代器 1、什么是迭代器 迭代器（Iterator）是一种设计模式和编程接口，它在计算机科学中扮演着至关重要的角色，特别是在处理集合数据结构时。迭代器提供了一种标准的方法来访问一个容器对象中的元素序列，而无需暴露容器的底层实现细节。
迭代器是一个实现了迭代协议的对象，它可以让我们遍历一个容器中的所有元素，而不需要知道容器的内部结构，迭代器可以被用于遍历列表、元组、字典、集合等容器类型。迭代器的工作原理是通过实现两个方法：__iter__()和__next__()方法，__iter__()方法返回迭代器对象本身，__next__()方法每次调用都会返回容器中的下一个元素，直到容器中的所有元素都被遍历完毕后，再调用__next__()方法就会抛出StopIteration异常，表示迭代已结束。Python内置的数据类型如列表、元组、字符串等，以及自定义的类，只要实现了这两个方法，都可以作为迭代器使用。在Python中，几乎只要涉及有序访问一组元素而无需同时将所有元素保留在内存中时，都可能用到迭代器。 python的for循环就是通过迭代器来实现的，当我们使用for循环遍历一个容器时，python会自动创建一个迭代对象，并调用__next__()方法来获取容器中的下一个元素，知道容器中的所有元素都被遍历完毕。除了使用for循环，还可以使用iter()函数来手动创建一个迭代器对象，并使用next()函数来获取容器中的下一个元素，这种方式可以让我们更灵活地控制迭代的过程。迭代器可以让我们更加方便的遍历容器中的元素，提高代码可读性和可维护性。
可以直接作用于for循环的数据类型有：1、集合数据类型，如list、tuple、dict、set、str等；2、generator，包括生成器和带yeild的generator function。这些可以直接作用于for循环的对象统称为可迭代对象：iterable；而可以被next()函数调用并不断返回下一个值的对象称为迭代器：iterator。
list，dict，str虽然是iterable，却不是iterator
from collections.abc import Iterator,Iterable dic={} lis=[] str1="123" print(isinstance(dic,Iterable),isinstance(lis,Iterable),isinstance(str1,Iterable)) #True True True print(isinstance(dic,Iterator),isinstance(lis,Iterator),isinstance(str1,Iterator)) #False False False 注：为什么list、dict、str等数据类型不是Iterator？---因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。Iterator甚至可以表示一个无限大的数据流，例如全体自然数，而使用list是永远不可能存储全体自然数的。
小结：
1、凡是可作用于for循环的对象都是Iterable类型；
2、凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；
3、集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。
再举个生活例子来解释一下迭代器：
迭代器这个概念，其实可以把它比喻成一个在图书馆里帮你找书的图书管理员。想象一下：
在图书馆中，图书按照一定的规则排列在不同的书架上。我们想要读遍整个图书馆的所有书籍，但不需要一次性把所有书都搬出来堆在一起。
这时，图书管理员（迭代器）就出场了。你只需要告诉管理员：“我想一本接一本地看所有的书。”管理员就会从第一个书架的第一个位置开始，每次给你取出一本书，并告诉你书的名字和内容（即访问集合中的每个元素）。当你看完一本后，只需说一声“下一本”，管理员就会找到下一个书的位置并递给你（调用next()方法获取下一个元素）。
如果图书馆很大，图书很多，而你的书包很小（内存有限），那么这个图书管理员服务就显得非常实用且高效，因为它只在你需要的时候才取出下一本书，而不是一次性拿出所有书占用大量空间。
当图书馆里的书都被你看完了（容器中所有元素都被访问过），管理员会告诉你没有更多的书可看了（抛出StopIteration异常），这意味着遍历过程结束。
这样，通过迭代器，你可以方便地按照一定顺序逐个访问一组数据，无需关心这些数据是如何存储或组织的，就像你不用了解图书馆的内部布局一样，只需要和图书管理员打交道即可。
2、创建迭代器 1）、内置类型迭代： 对于Python内置的可迭代对象（如列表、元组、字符串、字典、集合等），可以直接通过调用内建函数iter()来获取对应的迭代器。
list1=[1,2,3] list_it=iter(list1) print(isinstance(list_it,Iterator)) #True print(next(list_it)) #输出1 print(next(list_it)) #输出2 print(next(list_it)) #输出3 # print(next(list_it)) '''遍历完容器，没有数据后继续next()调用会报错： print(next(list_it)) StopIteration ''' dict1={1:1,2:2,3:3} dict_it=iter(dict1) print(isinstance(dict_it,Iterator)) print(next(dict_it)) #输出1 print(next(dict_it)) #输出2 print(next(dict_it)) #输出3 str2='123' str_it=iter(str2) print(isinstance(str_it,Iterator)) print(next(str_it))#输出1 print(next(str_it))#输出2 print(next(str_it))#输出3 Python的for循环本质上就是通过不断调用next()函数实现的：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a60d65f39d45bcfb01a205be6946046d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f793185ebe0a550c6cd6b52f050ad5a9/" rel="bookmark">
			超详细MySQL 8.0安装与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL的安装与配置 还不会安装MySQL的同学们，还不会配置MySQL的同学们，赶紧按照下面步骤操作起来，超详细安装步骤如下：
进入MySQL官网
1、点击download
2、点击MySQL Community Server
3、选好选项点击go to download page
4、点击download
5、点击no thanks，just start my download
6、选Server only，点击Next
7、点击Execute
8、点击Next
9、点击Next
10、点击Next
11、设置MySQL密码，点击Next
12、点击Next
13、点击Next
14、点击Execute
15、点击Finish
16、点击Next
17、点击Finish
18、右键此电脑选择属性
19、选择高级系统设置
20、点击环境变量
21、系统变量里找到path，点击编辑
22、点击新建
23、把MySQL，bin目录的地址复制粘贴到新建位置处，一直点确定
24、win+r，输入cmd，测试一下MySQL是否安装成功
此时MySQL就安装成功了，收藏起来吧，以免忘记。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd167d081b05a33256e2d351eacb5cf9/" rel="bookmark">
			Midjourney角色一致性功能使用方法教程(附今日提示词）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		‍Midjourney推出了一种新工具——角色一致性功能，帮助用户复制他们喜欢的风格。
这是Midjourney V6 的新功能。与基于图像提示的方法不同，这个工具更注重捕捉风格和外观。用户可以同时使用图像提示和风格参考，并调整风格权重来控制风格效果。风格参考是一种快速获取所期望风格的方法，而无需用文字描述。这对于创作者来说是一种神奇的工具，让他们更轻松地表达他们的创意。
角色一致性功能使用说明：
该功能类似于之前的风格参照功能，但不同之处在于不再是匹配特定风格，而是让角色与给定的角色参照图像相匹配。
使用范围
该功能最适合用于Midjourney创作的角色图像，不太适合用于真人照片（可能会导致一些扭曲，就像普通图像提示一样）。
Cref的工作方式类似于普通图像提示，但更注重角色的特征。
请注意，这项技术的精确度有限，无法复制极其微小的特征，如特定的酒窝、雀斑或T恤上的标志。Cref也适用于Niji和普通MJ模型，并可与--sref一起使用。
使用方法：
在输入指令后加上 --cref URL，其中URL是您选择的角色图像的链接。
您还可以使用 --cw 来调整参照的“强度”，范围从 100 到0。
默认强度为100（--cw 100），此时系统会参考人物的脸部、发型和服饰。
如果将强度设为0（--cw 0），则系统只会关注脸部（这对于更换服饰或发型非常有帮助）。
高级功能：
您可以使用多个URL，通过 --cref URL1 URL2 的方式结合多个图像中的角色信息（类似于使用多重图像或风格提示）。
在web alpha版本中的操作方式：
只需将图片拖动或粘贴到想象工具栏，您会看到三个图标。选择其中一个图标，即可将图片设置为图像提示、风格参照或角色参照。
如果希望一张图片同时用于多个类别，只需按住Shift键并选择即可。
请注意，由于MJ V6 目前仍处于alpha测试阶段，该功能及其他功能可能会有所变化。不久后，将推出官方的V6 beta版。
AIbase测试效果：
原图，生成提示词：A little girl in a white dress singing, clean background, picture book style --ar 4:3 --niji 6
使用角色一致性功能生成的效果图：
提示词：A little girl in a white dress writing, picture book style --ar 4:3 --cw 100 --cref https://s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd167d081b05a33256e2d351eacb5cf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adca7d055f7ef87721f6ed0e954125e8/" rel="bookmark">
			php使用ElasticSearch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ElasticSearch简介 Elasticsearch 是一个分布式的、开源的搜索分析引擎，支持各种数据类型，包括文本、数字、地理、结构化、非结构化。
Lucene与ElasticSearch Apache Lucene是一款高性能的、可扩展的信息检索（IR）工具库，是由Java语言开发的成熟、自由开源的搜索类库，基于Apache协议授权。Lucene只是一个软件类库，如果要发挥Lucene的功能，还需要开发一个调用Lucene类库的应用程序。
ElasticSearch在底层利用Lucene完成其索引功能，因此其许多基本概念源于Lucene。ElasticSearch封装了许多lucene底层功能，提供了分布式的服务、简单易用的restful API接口和许多语言的客户端。
倒排索引 Lucene中对文档检索基于倒排索引实现，并将它发挥到了极致。
倒排索引是实现“单词-文档矩阵”的一种具体存储形式，通过倒排索引，可以根据单词快速获取包含这个单词的文档列表。
例如：
id句子1I like apples2I dislike apples3I dislike apples too 如果要用单词作为索引，而句子的位置作为被索引的元素，那么索引就发生了倒置：
id单词索引I{1,2,3}like{1}apples{1,2,3}dislike{2,3}too{3} 如果要检索I dislike apples这句话，那么就可以这么计算 : {1,2,3} ^ {2,3} ^ {1,2,3} (^是交集)
核心概念 索引(Index)
ES将数据存储于一个或多个索引中，索引是具有类似特性的文档的集合。类比传统的关系型数据库领域来说，索引相当于SQL中的一个数据库，或者一个数据存储方案(schema)。索引由其名称(必须为全小写字符)进行标识，并通过引用此名称完成文档的创建、搜索、更新及删除操作。一个ES集群中可以按需创建任意数目的索引。
类型(Type)
类型是索引内部的逻辑分区(category/partition)，然而其意义完全取决于用户需求。因此，一个索引内部可定义一个或多个类型(type)。一般来说，类型就是为那些拥有相同的域的文档做的预定义。例如，在索引中，可以定义一个用于存储用户数据的类型，一个存储日志数据的类型，以及一个存储评论数据的类型。类比传统的关系型数据库领域来说，类型相当于“表”。
文档(Document)
文档是Lucene索引和搜索的原子单位，它是包含了一个或多个域的容器，基于JSON格式进行表示。文档由一个或多个域组成，每个域拥有一个名字及一个或多个值，有多个值的域通常称为“多值域”。每个文档可以存储不同的域集，但同一类型下的文档至应该有某种程度上的相似之处。
映射(Mapping)
ES中，所有的文档在存储之前都要首先进行分析。用户可根据需要定义如何将文本分割成token、哪些token应该被过滤掉，以及哪些文本需要进行额外处理等等。另外，ES还提供了额外功能，例如将域中的内容按需排序。事实上，ES也能自动根据其值确定域的类型。
**节点（Node） **
一个es实例即为一个节点，也是集群的一部分，它存储你的数据，并参与集群的索引和搜索。和集群一样，节点也是通过唯一的名字去区分，默认名字是一个随机的UUID，当服务器启动的时候就会设置到节点。你也可以自定义节点的名称。名称对管理员来说十分重要，它可以帮助你辨认出集群中的各个服务器和哪个节点相对应。
分片(Shard)和副本(Replica)
ES的“分片(shard)”机制可将一个索引内部的数据分布地存储于多个节点，它通过将一个索引切分为多个底层物理的Lucene索引完成索引数据的分割存储功能，这每一个物理的Lucene索引称为一个分片(shard)。每个分片其内部都是一个全功能且独立的索引，因此可由集群中的任何主机存储。创建索引时，用户可指定其分片的数量，默认数量为5个。
集群（Cluster） 集群是一个或多个节点（服务器）的集合，它们联合起来保存所有的数据（索引以分片为单位分散到多个节点上保存）并且可以在所有的节点上进行索引和搜索操作。集群通过一个唯一的名字区分，默认的名字是“elasticsearch”。这个名字十分重要，因为一个节点仅仅可以属于一个集群，并根据集群名称加入集群。
与关系型数据库核心概念对比
Elasticsearch关系型数据库（如Mysql）索引Index数据库Database类型Type（8.x版本已废弃）表Table文档Document数据行Row字段Field数据列Column映射Mapping约束Schema 数据类型 Elasticsearch 8.x中已经完全删除了数据类型，创建映射时也不再支持使用type字段指定数据类型，不然会报错"index" is not a valid parameter. Allowed parameters are "create", "error_trace"
这里就不继续介绍数据类型了
安装和启动 Windows 1.去官网Download Elasticsearch | Elastic下载windows版本压缩包，然后解压；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adca7d055f7ef87721f6ed0e954125e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5256848274c2fcd9231b2831e4fddf6e/" rel="bookmark">
			2024最新GPT4.0使用教程，AI绘画，一站式解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 ChatGPT3.5、GPT4.0、GPT语音对话、Midjourney绘画，文档对话总结+DALL-E3文生图，相信对大家应该不感到陌生吧？简单来说，GPT-4技术比之前的GPT-3.5相对来说更加智能，会根据用户的要求生成多种内容甚至也可以和用户进行创作交流。 然而，GPT-4对普通用户来说都是需要额外付费才可以使用。所以今天小编就整理一个真正可免费的AI工具。不是一天只能使用一两次就不能使用的网站。
二、特点优势 极速部署，宝塔5分钟部署完成，低内存高并发，内存占用不到100MB！配置简单快捷，配置文件仅需数据库配置即可启动强大的在线配置框架及丝滑版的体验，95%数据都可以后台在线统一管理！完美的自适应，支持手机、平板、电脑等多种尺寸设备的浏览器在线访问！ChatGPT + Azure OpenAI + 文心一言 + 讯飞星火 + 清华智谱 + 自定义对话模型支持🔥 自定义对话模型支持：包括模型名称、别名、单次积分扣除数量等等🔥 对话账号池（无限量）：支持OpenAI、文心一言、讯飞星火、清华智谱、OpenAISB、API2D、OneAPI🔥 对话多会话隔离支持、参数独立配置云端存储、消息云端漫游🔥 内容安全多层过滤：内置词库 -&gt; 自定义词库 -&gt; 第三方（百度内容审核）安全检测，可同时启用🍃 对话多模态支持：支持GPT-4-VISION的多模态支持，同时支持自定义对话模型开启多模态支持🍃 文档解析对话：支持PDF文档解析对话🔥 开放式对话插件：已支持联网查询、IP信息、天气查询、快递查询等13+款插件，同时可结合开发文档扩展你自己的插件！支持ECMAScript5.1引擎、PHP、Python、NodeJS进行开发（插件持续增加中...）🔥 AI绘画支持：文生图 / 放大 / 微调 / 垫图 / 混图 / 咒语解析 / 平移(Pan) / 扩图(Zoom) / 变幻(Vary) / 区域重绘 / Seed值获取🔥 Midjourney绘画API、WSS、CDN反向代理支持🍃 Dall-E-3绘画支持：支持在绘画面板上对Dall-E-3的参数完全调控和生成🍃 Stable Diffusion XL绘画支持：支持在绘画面板上对Stable Diffusion XL的参数调控和生成🔥 绘画账号池（无限量）：每个账号同时支持单独的并发线程设定，线程隔离。✨ 绘图服务在线启动、重启、关闭 + 队列数量实时查看👾 绘图普通/快速模式区分，可单独设置扣除积分思维导图：一键根据需求生成思维导图，可导出PNG或SVG绘画画廊：用户绘图公开展示（私有绘图不展示）应用市场：可后台管理动态添加及其他管理用户系统：邮箱 + 手机号码（登陆 / 注册 / 找回密码 / 修改密码 / 验证码登陆等等）支付系统：微信（支持扫码支付+JSAPI支持） / 支付宝 / 虎皮椒 / 自定义外链第三方登录：QQ / 微信扫码（个人订阅号、未认证公众号、已认证服务号均支持） / 微信网页授权 / Github / Gitee推广模块：支持用户推广分佣模式，分佣所获得的奖励可以兑换套餐。套餐系统：支持周期内每日重置 + 固定周期内总量多种方式对话Tokens消耗、单积分消耗多种模式支持兑换码系统站点在线DIY：例如主题色、LOGO、名称、SEO、区块圆角、自定义全局CSS、自定义全局流量统计等等均可在后台管理在线配置后台管理系统：与前台账户一体化，管理身份自动出现管理入口一键管理绘画服务在线管理：启动、停止、重启；可实时查看进行中的任务和等待队列数量邀请机制：好友邀请获得对应奖励，包含防止恶意自己邀请自己机制检测管理后台在线自定义全局各种模板：注册+登陆邮件模板、余额不足模板、默认对话提示、默认各类型Prompt等对话各个模型+绘画各个操作单独自定义扣除积分数量支持动态用户侧边栏菜单控制显隐用户端动态菜单（支持内嵌网页、外部链接跳转、内部路径跳转）对话记录PNG长图导出允许游客免登陆访问界面支持用户必须绑定手机或邮箱才可以使用支持敏感词噪音去除开关和自定义正则支持 用户自定义上传头像，包含头像的图像安全检测
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5256848274c2fcd9231b2831e4fddf6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d37bf442ff9ed2a8b3c66a9bb060aa50/" rel="bookmark">
			Java进程CPU高负载排查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java进程CPU高负载排查步骤_java进程cpu使用率高排查_YouluBank的博客-CSDN博客
【问题定位】使用arthas定位CPU高的问题_arthas cpu高_秋装什么的博客-CSDN博客
CPU飙升可能原因 CPU 上下文切换过多。 对于 CPU 来说，同一时刻下每个 CPU 核心只能运行-个线程，如果有多个线程要执行，CPU 只能通过上下文切换的方式来执行不同的线程。上下文切换需要做两个事情：保存运行线程的执行状态；让处于等待中的线程执行这两个过程需要 CPU 执行内核相关指令实现状态保存，如果较多的上下文切换会占据大量 CPU 资源，从而使得 cpu 无法去执行用户进程中的指令，导致响应速度下降。 在 Java 中，文件1O、网络 1O、锁等待、线程阻塞等操作都会造成线程阻塞从而触发上下文切换CPU 资源过度消耗，也就是在程序中创建了大量的线程，或者有线程一直占用CPU 资源无法被释放，比如死循环!CPU 利用率过高之后，导致应用中的线程无法获得 CPU 的调度，从而影响程序的执行效率! 使用命令查找 采用top命令定位进程 登录服务器，执行top命令，查看CPU占用情况，找到进程的pid
很容易发现，PID为29706的java进程的CPU飙升到700%多，且一直降不下来，很显然出现了问题。
使用top -Hp命令定位线程 使用 top -Hp 命令（为Java进程的id号）查看该Java进程内所有线程的资源占用情况
top -Hp 29706 很容易发现，多个线程的CPU占用达到了90%多。我们挑选线程号为30309的线程继续分析。
使用jstack命令定位代码 线程号转换为16进制 printf “%x\n” 命令（tid指线程的id号）将以上10进制的线程号转换为16进制：
printf "%x\n" 30309 转换后的结果分别为7665，由于导出的线程快照中线程的nid是16进制的，而16进制以0x开头，所以对应的16进制的线程号nid为0x7665
采用jstack命令导出线程快照 通过使用dk自带命令jstack获取该java进程的线程快照并输入到文件中： jstack -l &gt; ./jstack_result.txt 命令（为Java进程的id号）来获取线程快照结果并输入到指定文件。
jstack -l 29706 &gt; ./jstack_result.txt 根据线程号定位具体代码 在jstack_result.txt 文件中根据线程好nid搜索对应的线程描述
cat jstack_result.txt |grep -A 100 7665 根据搜索结果，判断应该是ImageConverter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d37bf442ff9ed2a8b3c66a9bb060aa50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d917dc4d4a371e65a23acbf2fe6d9a0/" rel="bookmark">
			开源模型应用落地-工具使用篇-Spring AI（七）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 在AI大模型百花齐放的时代，很多人都对新兴技术充满了热情，都想尝试一下。但是，实际上要入门AI技术的门槛非常高。除了需要高端设备，还需要面临复杂的部署和安装过程，这让很多人望而却步。不过，随着开源技术的不断进步，使得入门AI变得越来越容易。通过使用Ollama，您可以快速体验大语言模型的乐趣，不再需要担心繁琐的设置和安装过程。另外，通过集成Spring AI，让更多Java爱好者能便捷的将AI能力集成到项目中，接下来，跟随我的脚步，一起来体验一把。
二、术语 2.1、Spring AI 是 Spring 生态系统的一个新项目，它简化了 Java 中 AI 应用程序的创建。它提供以下功能：
支持所有主要模型提供商，例如 OpenAI、Microsoft、Amazon、Google 和 Huggingface。支持的模型类型包括“聊天”和“文本到图像”，还有更多模型类型正在开发中。跨 AI 提供商的可移植 API，用于聊天和嵌入模型。支持同步和流 API 选项。支持下拉访问模型特定功能。AI 模型输出到 POJO 的映射。 2.2、Ollama ​​​​​​​ 是一个强大的框架，用于在 Docker 容器中部署 LLM（大型语言模型）。它的主要功能是在 Docker 容器内部署和管理 LLM 的促进者，使该过程变得简单。它可以帮助用户快速在本地运行大模型，通过简单的安装指令，用户可以执行一条命令就在本地运行开源大型语言模型。
Ollama 支持 GPU/CPU 混合模式运行，允许用户根据自己的硬件条件（如 GPU、显存、CPU 和内存）选择不同量化版本的大模型。它提供了一种方式，使得即使在没有高性能 GPU 的设备上，也能够运行大型模型。
三、前置条件 3.1、JDK 17+ 下载地址：https://www.oracle.com/java/technologies/downloads/#jdk17-windows
类文件具有错误的版本 61.0, 应为 52.0
3.2、创建Maven项目 SpringBoot版本为3.2.3
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.2.3&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; 3.3、导入Maven依赖包 &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d917dc4d4a371e65a23acbf2fe6d9a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/306d3fad25b59393e7f9352827f668e0/" rel="bookmark">
			Unity2021.3.35f1配置安卓APK发布环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在Unity3d中点击菜单【Edit】【Preferences】，在External Tools中可以看到Android平台需要配置JDK、SDK、NDK、Gradle。对应的版本需要在官方文档中查看
JDK：指Java开发环境
SDK：指安卓开发包，包括Build Tools、Commond-line Tools、Platform-Tools等工具包
NDK：与C++相关的开发工具
Gradle：打包APK的。
2.打开Unity2021.3帮助文档
2.在【Platform development】【Android】【Getting started with Android】【Android environment setup】中查看SDK、NDK、JDK版本。
3.在【Platform development】【Android】【Introducing Android】【Gradle for Android】中查看Gradle版本。 4.下载Android Studio历史版本，下载后安装
注意Android Studio的安装目录和Android SDK是不同的
5.下载Android SDK
打开Android Studio，点击菜单【Tools】 【SDK Manager】
Unity官方文档要求SDK是26.1.1，这里34也是可以用的
至于Build Tools、Commond-line Tools、Platform-Tools的版本先不用管。如果列表中没有对应的版本，可以用tools\bin\sdkmanager.bat进行下载
sdkmanager.bat build-tools;30.0.2 6.下载NDK 官方文档要求是r21d，列表中没有的话可以网上找
7.下载JDK，也就是安装Java
7.下载Gradle
8.配置Unity中的安卓环境
9. 在Player Settings中设置包名、签名等，发布apk
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/782b1a79788f9bc3648acdd18079ad52/" rel="bookmark">
			VUE3 播放RTSP实时、回放(NVR录像机)视频流（使用WebRTC）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载webrtc-streamer，下载的最新window版本 Releases · mpromonet/webrtc-streamer · GitHub
2、解压下载包 3、webrtc-streamer.exe启动服务 （注意：这里可以通过当前文件夹下用cmd命令webrtc-streamer.exe -o这样占用cpu会很少，直接双击exe文件会占用cpu）
cmd webrtc-streamer.exe -o 启动如下图所示，此时在浏览器访问127.0.0.1:8000可以看到本机监控画面
4、将下载包html文件夹下webrtcstreamer.js文件和html/libs文件夹下adapter.min.js文件复制到vue项目public目录下。在index.html文件里引入这两个js文件 5、修改视频编码：(H.264) 6、编写实时播放测试页面 &lt;template&gt;
&lt;video id="video" controls autoplay muted width="800" height="600"&gt;&lt;/video&gt;
&lt;/template&gt;
&lt;script setup&gt;
const webRtcServer = ref();
// webrtc服务器地址
const IP = "http://127.0.0.1:8000";
onMounted(() =&gt; {
initVideo();
});
onBeforeUnmount(() =&gt; {
destroyVideo();
});
// 页面激活
onActivated(() =&gt; {
// 缓存页面 打开页面 实现播放
const video = document.getElementById("video");
video.paused &amp;&amp; video.play();
});
// 页面停用
onDeactivated(() =&gt; {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/782b1a79788f9bc3648acdd18079ad52/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/475/">«</a>
	<span class="pagination__item pagination__item--current">476/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/477/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>