<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/990626b0a8bc65cc863cce98e03742ec/" rel="bookmark">
			贪心算法总结（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、贪心算法简介 常用方法：交换论证法、数学归纳法、反证法、分类讨论 二、柠檬水找零（交换论证法） . - 力扣（LeetCode）
class Solution { public: bool lemonadeChange(vector&lt;int&gt;&amp; bills) { int five=0,ten=0; for(auto&amp;e:bills) if(e==5) ++five; else if(e==10) { if(five==0) return false; --five,++ten; } else //贪心策略 { if(five&amp;&amp;ten) --five,--ten; else if(five&gt;=3) five-=3; else return false; } return true; } //交换论证法、数学归纳法和反证法常用的策略 }; 三、将数组减半的最小操作次数（交换论证法） . - 力扣（LeetCode）
class Solution { public: int halveArray(vector&lt;int&gt;&amp; nums) { priority_queue&lt;double&gt; q(nums.begin(),nums.end()); double sum=accumulate(nums.begin(),nums.end(),0.0); int ret=0; sum/=2.0; while(sum&gt;0) { double t=q.top()/2.0; q.pop(); sum-=t; q.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/990626b0a8bc65cc863cce98e03742ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cc2e9ddd4b96d89a6105e4cb9a3a011/" rel="bookmark">
			目前比较好用的AI大模型创作工具地址合集及亮点应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI背景：2024年，可以说是AI人工智能大模型爆发的元年，各类AI模型应用层出不穷，令人应接不暇。从前年底国外OpenAI公司的ChatGPT大模型推出开始，到去年国内百度公司的文心一言大模型率先向全社会开放使用，很多人都为人工智能时代的到来感到震惊和无所适从；有的人感到了焦虑和恐惧，担心AI不久就会取代自己的工作；有的人则感到不可思议，甚至有些欣喜若狂，因为AI确实在很多方面极大解放了生产力。下面本文将从文、音、图、视，四个维度和视角，分门别类介绍目前比较使用性价比较高的AI大模型网址及特色应用：
一、AI语言大模型
1、Kimi
网页端地址：https://kimi.ai
移动端：应用市场
2、文心一言
网页端地址：https://yiyan.baidu.com/
移动端：应用市场
3、讯飞星火
网页端地址：https://xinghuo.xfyun.cn/desk
移动端：应用市场
4、腾讯元宝
网页端地址：https://yuanbao.tencent.com/
移动端：应用市场
5、豆包
网页端地址：https://www.doubao.com/
移动端：应用市场
6、火山写作（文本润色）
网页端地址：https://writingo.net/document?docId=1
7、其他
除了ChatGPT、Kimi、文心一言、讯飞星火、元宝、豆包这些AI大模型外，还有许多其他一些比较知名和活跃的大语言模型，比如阿里巴巴通义千问、智谱华章的智谱清言、华为的盘古大模型、360智脑AI、昆仑万维的天工AI、网易AI、赤兔大模型、文修大模型等等。
二、AI音频音乐
1、AI人声配音（TTS文本转语音）
喜马拉雅音剪AI画本：https://voicefactory.ximalaya.com/（目前完全免费）
魔音工坊：https://www.moyin.com/（部分角色音需要付费）
Fish Speech：https://fish.audio/zh-CN/（语音处理接近人类水平，效果媲美GPT-SoVITS、ChatTTS）
阿里最强中文语音克隆模型CosyVoice：需要下载安装使用。
其他文转音途径：抖音的剪映、腾讯智影等视频工具都具有AI配音功能，缺点是没有画本功能，多角色声音需要手动分段设置。
2、Suno音乐AI
网页端地址1：https://suno.cn/?from=sunowx#/create
网页端地址2：https://suno.com/create
移动端：微信搜索小程序
3、天工AI音乐
移动端：天工APP
微信官方小程序：天工AI智能助手
网页端地址：https://www.tiangong.cn/music
4、其他音乐AI
除了Suno和天工，其他音乐AI还有Udio、Muse AI、快音AI、歌歌AI等等，不过目前的音乐AI都需要积分和会员，并且都有抽卡机制，很多时候生成出来的歌曲大部分都不尽人意，所以如果你也想拥有自己创作的专属音乐歌曲，可能还需要一点点运气。
三、AI绘图
1、即梦（抖音字节系列）
网页端地址：https://jimeng.jianying.com/ai-tool/image/generate
2、哩布哩布
网页端地址：https://www.liblib.art/sd
3、其他绘图AI
即梦和哩布，是性价比较高并且相对容易上手的的AI绘图工具，此外还有Midjourney、Stable Diffusion(需要下载安装)、可画、美图设计室、百度AI图片工具、文心一格、无界AI等等。
四、AI视频
1、剪映（抖音字节系列）
剪映是相对常用的视频后期剪辑工具，需要下载安装进行使用，具有丰富的AI角色配音、转场、特效、贴纸、以及智能字幕、人声分离等功能。
2、腾讯智影
腾讯智影具有与剪映类似的一些基础功能，此外还能生成时间轴字幕。
官网：https://zenvideo.qq.com/
3、其他视频AI
其他的视频AI，比如可灵（快手快影）、即创（抖音字节系列）、一帧秒创、Runway gen3、Luma ai、Pixverse、Stable Video等等，AI发展实在太快了，目前仍然有很多AI如雨后春笋般涌现。
五、结语
有人说，AI让“无人××”成为普遍，还要人干什么？对此你有何看法？
不管你是悲是喜，总之AI时代，未来已来，未来可期。
下期我将分享使用AI工具进行变现的一些途径，让AI成为自己的“数字员工”。敬请期待。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f68aefa933ddaec909c1a7c77b6e5d0a/" rel="bookmark">
			基于微信小程序&#43;SpringBoot&#43;数据可视化的校园快餐配送小程序设计和实现(源码&#43;论文&#43;部署讲解等)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌全网粉丝50W+,csdn特邀作者、博客专家、CSDN新星计划导师、Java领域优质创作者,博客之星、掘金/华为云/阿里云/InfoQ等平台优质作者、专注于Java技术领域和学生毕业项目实战,高校老师/讲师/同行前辈交流✌
技术范围：SpringBoot、Vue、SSM、HLMT、Jsp、PHP、Nodejs、Python、爬虫、数据可视化、小程序、安卓app、大数据、物联网、机器学习等设计与开发。
主要内容：免费功能设计、开题报告、任务书、中期检查PPT、系统功能实现、代码编写、论文编写和辅导、论文降重、长期答辩答疑辅导、腾讯会议一对一专业讲解辅导答辩、模拟答辩演练、和理解代码逻辑思路。
🍅文末获取源码联系🍅
👇🏻 精彩专栏推荐订阅👇🏻 不然下次找不到哟
2022-2024年最全的计算机软件毕业设计选题大全：1000个热门选题推荐✅
Java项目精品实战案例《100套》
Java微信小程序项目实战《100套》
大数据项目实战《100套》
Python项目实战《100套》
感兴趣的可以先收藏起来，还有大家在毕设选题，项目以及论文编写等相关问题都可以给我留言咨询，希望帮助更多的人​
系统介绍： 校园外卖平台致力于为在校学生提供便捷、多样的餐饮选择。通过线上订购、快速配送的方式，满足学生在校园内的饮食需求。平台精选优质商家，严格把控食品安全，确保每一份外卖都能让顾客放心品尝。同时，丰富的优惠活动和定制化服务，让校园外卖成为学生日常生活的重要组成部分。系统采用基于Java语言网站开发技术设计的，结合Mysql数据库管理系统对校园外卖相关信息进行管理。按照软件工程学理论完成各阶段设计，经过调试测试达到了校园外卖平台的能力。满足了管理员、商家、用户和快递员的需要。论文从系统开发过程概述、开发工具简介、系统总体设计、系统开发、软件测试等几个方面进行了介绍。最后总结了系统开发的得失
程序上交给用户进行使用时，需要提供程序的操作流程图，这样便于用户容易理解程序的具体工作步骤，现如今程序的操作流程都有一个大致的标准，即先通过登录页面提交登录数据，通过程序验证正确之后，用户才能在程序功能操作区页面操作对应的功能。
​
程序操作流程图
首先前端通过Vue和axios发送HTTP请求到后端的登录接口。在后端接收登录请求的Controller会使用`@RequestParam Map&lt;String, Object&gt; params`来接收前端传递的用户参数，用户名和密码。然后后端根据接收到的参数创建一个查询条件封装对象MyBatis的EntityWrapper用于构建查询条件。接着在业务层，调用相应的service方法来查询数据库中是否存在匹配的用户信息。这个查询方法Login()会将前端传递的对象参数传递到后台的DAO层，进行数据库的交互操作。如果存在符合条件的用户，则会返回相关的用户信息。最后在后端控制器中将查询结果封装成响应体，通过`return R.ok().put("data", userService.selecView(ew))`将用户信息返回给前端。前端收到响应后，可以通过调用Vue、ElementUI等组件来渲染登录结果，例如显示用户信息或者跳转到相应的页面。
详细视频演示 请联系我获取更详细的演示视频
功能截图： 在系统前台首页，调用`$route(newValue)`方法监听路由变化，根据当前的路由地址来确定活动菜单的索引，并且根据路由的哈希部分（即URL的`#`后面的部分）来判断是否需要滚动页面到顶部或者某个特定元素的位置。如果不是首页，会将页面滚动到指定元素处，否则滚动到页面顶部。另外通过`headportrait()`方法用于更新组件渲染点前用户头像。在用户登录后，后端返回了新的用户信息，需要及时更新页面上的用户头像信息。
论文参考： 1 绪 论 1.1研究背景与意义 1.2系统研究现状 1.3 论文主要工作内容 2 系统关键技术 2.1 java简介 2.2 MySQL数据库 2.3 B/S结构 2.4 SpringBoot框架 2.5 VUE框架 3 系统分析 3.1 系统可行性分析 3.1.1 技术可行性 3.1.2 操作可行性 3.1.3 经济可行性 3.1.4 法律可行性 3.2 系统性能分析 3.3 系统功能分析 3.4 系统流程分析 3.4.1 数据开发流程 3.4.2 用户登录流程 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f68aefa933ddaec909c1a7c77b6e5d0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4915465bba0322f0496683d610ca35d7/" rel="bookmark">
			​数据结构之初始二叉树（3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找往期文章包括但不限于本期文章中不懂的知识点：
个人主页：我要学编程(ಥ_ಥ)-CSDN博客
所属专栏：数据结构（Java版）
二叉树的基本操作
通过上篇文章的学习，我们简单的了解了二叉树的相关操作。接下来就是有关二叉树的经典题型练习。
递归相关的题目都有一个套路：例如：确定一个节点要做的事情，其余的套框架，递归就行了。下面我们就来细细品味。 目录
100. 相同的树
572. 另一棵树的子树
226. 翻转二叉树
101. 对称二叉树
110. 平衡二叉树
牛客网——JZ36 二叉搜索树与双向链表
牛客网——KY11 二叉树遍历
100. 相同的树 题目：
给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。
如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
示例 1：
输入：p = [1,2,3], q = [1,2,3] 输出：true 示例 2：
输入：p = [1,2], q = [1,null,2] 输出：false 示例 3：
输入：p = [1,2,1], q = [1,1,2] 输出：false 提示：
两棵树上的节点数目都在范围 [0, 100] 内-104 &lt;= Node.val &lt;= 104 思路： 按照上面的套路，我们应该找到一个节点所做的事情，即判断这个节点是否相同。
if (p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4915465bba0322f0496683d610ca35d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c06760384ac261b6214a05a08dd56bd3/" rel="bookmark">
			Oracle数据库 v$archived_log
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		v$archived_log详解 V$ARCHIVED_LOG视图描述了系统中已经归档的日志文件的相关信息。归档日志是ARCHIVELOG模式的一种，用来记录DML以及DDL对数据库中对象所做的更改，保护数据库以及实施重做数据库恢复。
V$ARCHIVED_LOG视图的主要用途是查看已经归档的日志的信息，确定要恢复的日志。可以直接执行：
#查询当前被归档日志的相关信息 SELECT ARCHIVED, DELETED, SEQUENCE#, RESETLOGS_CHANGE#, FLAGS, ARCHIVE_DATE, ARCHIVE_SCN, SESSION_INFO FROM V$ARCHIVED_LOG; V$ARCHIVED_LOG displays archived log information from the control file, including archive log names.
An archive log record is inserted after the online redo log is successfully archived or cleared (name column is NULL if the log was cleared). If the log is archived twice, there will be two archived log records with the same THREAD#, SEQUENCE#, and FIRST_CHANGE#, but with a different name.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c06760384ac261b6214a05a08dd56bd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54b80a168d23285b6522486057fc7fd3/" rel="bookmark">
			概率论中的卷积公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
简介
卷积公式的推导与应用
实际例子
卷积公式在多维情况下的推导和应用是什么？
多维卷积的推导
多维卷积的应用
延伸拓展
如何使用卷积公式解决实际问题，例如信号处理中的噪声消除？
在统计学中，卷积公式是如何应用于样本量估计和假设检验的？
卷积公式在量子力学中的应用有哪些例子？
如何证明卷积公式对于独立随机变量之和的概率密度函数的重要性？
简介 在概率论中，卷积公式是用于计算两个独立随机变量之和的概率密度函数的重要工具。具体来说，如果 𝑋X 和 𝑌Y 是两个独立的连续型随机变量，其概率密度函数分别为 𝑓𝑋(𝑥)fX​(x) 和 𝑓𝑌(𝑦)fY​(y)，那么它们和 𝑍=𝑋+𝑌Z=X+Y 的概率密度函数 𝑓𝑍(𝑧)fZ​(z) 可以通过卷积公式来求得：
𝑓𝑍(𝑧)=∫−∞∞𝑓𝑋(𝑥)𝑓𝑌(𝑧−𝑥)𝑑𝑥fZ​(z)=∫−∞∞​fX​(x)fY​(z−x)dx
这个公式表示的是对 𝑓𝑋(𝑥)fX​(x) 进行平移和翻转后与 𝑓𝑌(𝑦)fY​(y) 相乘并积分的过程。
卷积公式的推导与应用 推导过程：
首先，考虑 𝑓𝑋(𝑥)fX​(x) 和 𝑓𝑌(𝑦)fY​(y) 的联合密度函数。由于 𝑋X 和 𝑌Y 独立，联合密度函数可以写为：
𝑓𝑋,𝑌(𝑥,𝑦)=𝑓𝑋(𝑥)𝑓𝑌(𝑦)fX,Y​(x,y)=fX​(x)fY​(y)将 𝑌Y 替换为 𝑧−𝑥z−x，得到：
𝑓𝑋,𝑌(𝑥,𝑧−𝑥)=𝑓𝑋(𝑥)𝑓𝑌(𝑧−𝑥)fX,Y​(x,z−x)=fX​(x)fY​(z−x)对 𝑥x 进行积分，即可得到 𝑍Z 的边缘密度函数：
𝑓𝑍(𝑧)=∫−∞∞𝑓𝑋(𝑥)𝑓𝑌(𝑧−𝑥)𝑑𝑥fZ​(z)=∫−∞∞​fX​(x)fY​(z−x)dx 卷积公式在处理独立随机变量之和的分布问题时非常有用。例如，在统计学、信号处理等领域，常常需要计算两个随机变量之和的分布情况。通过卷积公式，可以直接从单个变量的密度函数推导出其和的密度函数，从而简化了复杂的计算。
卷积不仅限于一维情况，还可以扩展到多维情况。例如，在二维情况下，可以将卷积公式推广为：𝑓𝑋,𝑌(𝑥,𝑦)=∫−∞∞𝑓𝑋∣𝑌(𝑥∣𝑦)𝑓𝑌(𝑦)𝑑𝑦fX,Y​(x,y)=∫−∞∞​fX∣Y​(x∣y)fY​(y)dy
其中，𝑓𝑋∣𝑌(𝑥∣𝑦)fX∣Y​(x∣y) 是在 𝑌=𝑦Y=y 条件下 𝑋=𝑥X=x 的条件密度函数。
实际例子 假设 𝑋X 和 𝑌Y 都是均匀分布在区间 [0,1] 上的随机变量，求它们和 𝑍=𝑋+𝑌Z=X+Y 的概率密度函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54b80a168d23285b6522486057fc7fd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdc3ced5794430f2064b8eefb0ff0455/" rel="bookmark">
			【C&#43;&#43;】—— 从 C 到 C&#43;&#43; （下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【C++】—— 从 C 到 C++ （下） 六、引用6.1、什么是引用6.2、引用在传参的使用6.2.1、例一6.2.2、例二 6.3、引用在做返回值的使用6.4、引用的特性6.5、引用的使用总结6.6、 c o n s t const const 引用6.6.1、 c o n s t const const 引用的规则6.6.2、 c o n s t const const 引用的情况6.6.2.1、常量6.6.2.2、表达式6.6.2.3、隐式类型转换 6.7、引用的本质6.8、指针与引用的关系 七、 i n l i n e inline inline 内联函数7.1、引子7.2、 i n l i n e inline inline 的特点 八、 n u l l p t r nullptr nullptr 空指针 六、引用 6.1、什么是引用 在大家学习C语言指针的部分时，是不是觉得指针特别难学，还有点繁琐，每次使用都要取地址、解引用、还有二级指针什么的。为此，C++引入了引用的语法
引用并不是新定义一个变量，而是在已有变量的基础上给它取一个别名，编译器不会为引用变量开辟新的内存空间，它和它的引用变量公用一块内存空间。
什么意思呢？就拿《水浒传》中的任务来说，林冲别名叫豹子头、李逵别名叫黑旋风；林冲和豹子头指向的是同一个人，李逵和黑旋风也是指向同一个人
类型&amp; 应用别名 = 引用对象；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdc3ced5794430f2064b8eefb0ff0455/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48e581b6bde36c05caa0f71cd1a6dccc/" rel="bookmark">
			如何学习Flink：糙快猛的大数据之路（图文并茂）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一名大数据开发，我深知学习新技术的重要性。今天，我想和大家分享如何高效学习Flink这个强大的流处理框架。
目录 Flink是什么？为什么选择Flink？学习Flink的糙快猛之路1. 建立概念框架2. 动手实践3. 利用大模型助手4. 构建小项目5. 阅读官方文档6. 参与社区 进阶学习：深入Flink核心概念1. 时间语义2. 状态管理 实战项目：实时用户行为分析项目需求代码框架 高级特性：Flink的精华所在1. 复杂事件处理（CEP）2. 表API和SQL3. 机器学习集成 实战项目：实时数据湖构建项目需求代码框架 Flink 生态系统：beyond 核心 API1. Flink CDC (Change Data Capture)2. Flink ML (Machine Learning) 高级优化技巧1. 背压处理2. 状态优化 实战项目：实时异常检测系统项目需求代码框架 结语 Flink是什么？ Apache Flink是一个开源的分布式大数据处理引擎，用于对无界和有界数据流进行有状态的计算。它提供了数据流上的精确一次处理语义，以及事件时间和处理时间的灵活窗口机制。
为什么选择Flink？ 高吞吐、低延迟精确一次语义灵活的窗口操作丰富的API 学习Flink的糙快猛之路 1. 建立概念框架 首先，我们需要对Flink的核心概念有一个大致了解：
DataStream API窗口操作状态管理时间语义 不要一开始就追求完全理解每个细节，先建立一个框架，后续再填充。
2. 动手实践 记得我刚开始学习Flink时，连Java都不太熟悉。但我没有被这些困难吓倒，而是选择直接上手写代码。
这里有一个简单的WordCount示例：
public class WordCount { public static void main(String[] args) throws Exception { StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); DataStream&lt;String&gt; text = env.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48e581b6bde36c05caa0f71cd1a6dccc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea18a059d649d5be93218873f1e7ba5f/" rel="bookmark">
			【数据结构入门 】单链表详解之无头单向非循环链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、链表的概念及结构二、无头单向非循环链表链表的实现1.结构体声明2.单链表打印3.尾插4.头插5.尾删6.头删7.单链表查找8.插入（在pos之前插入）9.删除（在pos之前删除）10.插入（在pos之后插入）11.删除（在pos之后删除）12.销毁 总结 前言 链表是数据结构中常用的结构，它可以在任意内存上申请适合的空间，极大的提高了内存的利用率，有效的解决了内存浪费的问题，那么就让我们了了解一下单链表吧。
一、链表的概念及结构 概念：链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的 。
结构图示：
注意：
1.从上图可看出，链式结构在逻辑上是连续的，但是在物理上不一定连续；
2.现实中的结点一般都是从堆上申请的；
3.从堆上申请的空间，是按照一定的策略来分配的，两次分配的空间可能连续也可能不连续，所以需要使用指针去连接；
二、无头单向非循环链表 无头单向非循环链表：结构简单，一般不会单独用来存数据。实际中更多是作为其他数据结构的子结构，如哈希桶、图的邻接表等等。
链表的实现 1.结构体声明 typedef int SLTDataType; typedef struct SListNode { SLTDataType data; struct SListNode* next; }SLTNode; 2.单链表打印 空链表也可以打印所以不需要在开头断言
void SLTPrint(SLTNode* phead) { //不可以断言 SLTNode* cur = phead; while (cur != NULL) { printf("%d-&gt;", cur-&gt;data); cur = cur-&gt;next; } printf("NULL\n"); } 3.尾插 空链表也可以尾插，此处不用断言；
单链表的尾插比较麻烦，需要先找尾，然后插入数据。
void SLTPushBack(SLTNode** pphead, SLTDataType x) { SLTNode* newnode = BuySLTNode(x); if (*pphead == NULL) { *pphead = newnode; } else { //找尾 SLTNode* tail = *pphead; while (tail-&gt;next !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea18a059d649d5be93218873f1e7ba5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb23482d89d4fc22f57ebb6f9cb3325d/" rel="bookmark">
			【Datawhale AI夏令营】Task02学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		了解深度学习（Deep Learning）
机器学习和深度学习（深度学习是机器学习一个子集）
深度学习进行训练
深度学习与迁移学习
常见的图像分类网络
1.AlexNet
2.ResNet
3.EfficientNet
这次学习主要是了解深度学习、机器学习，学习几个常见网络。
了解深度学习（Deep Learning） 深度学习是机器学习一个分支，通过神经网络模拟人脑的学习方式，可以处理大量数据并且从中自动学习和提取特征，进行预测。
类似人类的神经元，在人工智能中，可以用数学模型来模拟其行为：
输入：神经元树突接收到的信号权重：调整信号强度的小调节器激活函数：决定是否产生输出输出：传递给其他神经元的信号 深度学习就是将这些 神经元模型层层堆叠起来的复杂结构，按一定的层次形成一个庞大的网络，从网络最底层接收输入数据；然后通过每一层的处理，逐步提取出更高级别的特征；最后在顶层输出结果。现如今科学家将基本的神经元模型组合起来形成了多层次的网络结构，这些网络称之为神经网络。
为了进一步提高模型的准确性和泛化能力，可以对模型进行以下优化
改进激活函数权重初始化正则化技术梯度下降的变种使用新的网络结构：CNN/RNN等。 机器学习和深度学习（深度学习是机器学习一个子集） 机器学习：通常使用相对简单的算法（如线性回归、决策树）处理数据。需要人工设计特征工程来提高模型性能。
典型的机器学习算法：线性回归、逻辑回归、决策树、随机森林、SVM(支持向量机)、K-近邻(KNN)等。
线性回归（输入特征与输出标签之间存在线性关系、训练集中的数据独立且同分布）决策树（每个特征在决策过程中是相互独立的、特征可以是离散的）神经网络（通过非线性激活函数建模数据中的复杂非线性关系、分层结构） 深度学习：通过深层神经网络自动学习特征，能够处理和学习高维度和复杂的数据模式，适用于图像识别、自然语言处理等复杂任务。（自动从原始数据中学习到有用的特征：端到端）
学习基础的神经网络结构，理解神经元、层、前进传播和反向传播等，进而学习相关模型。
深度学习进行训练 通过大量的数据反复训练来调整权重，进而使网络更准确地完成特定任务。
梯度下降算法：损失函数梯度指向函数增长最快的方向。如果要减少损失函数的值，就需要沿着梯度的反方向调整模型的参数。 步骤：1.训练前对数据进行加载、预处理和分割 2.训练代码包括前向传播、计算损失、反向传播和参数更新（多轮）。
首先，我们需要准备一批图片数据（通过train_loader）和这些图片对应的正确标签（target）。
在开始训练之前，将模型设置为训练模式（ model.train() ）。
接着，开始喂给模型图片数据，并让它尝试预测这些图片的内容。
模型会基于它目前的学习给出预测结果（output），而会计算这些预测结果与实际标签之间的差异，这个差异就是损失（loss）。
为了让模型学会准确预测，需要指出它的错误，并更新它的内部参数来减少这些错误（通过loss.backward()和optimizer.step()）。
这个过程就像是模型在自我调整，以便在下一次遇到类似图片时能够做出更准确的预测。
深度学习与迁移学习 迁移学习：一种机器学习技术，将已在一个任务所学应用到另一个任务。
通常使用在大规模数据集上预训练的模型作为起点，在预训练模型基础上使用少量标记对模型微调来适应新任务。
实现方法：微调。将预训练模型适配到新的目标任务上，常涉及以下步骤：
替换输出层冻结预训练模型中的大部分层（可做可不做）使用目标任务的数据集对模型进行训练。 优势：
（1）可以快速训练出一个理想的结果。
（2）数据集较小时也能训练出理想的效果。
常见的迁移学习方式：
（1）载入权重后训练所有参数。（效果更好）
（2）载入权重后只训练最后几层参数。（更快）
（3）载入权重后再原网络基础上再添加一层全连接层，仅训练最后一个全连接层。（更快）
常见的图像分类网络 1.AlexNet AlexNet包含八个层次结构，前五个是卷积层，其中一些后面跟最大池化层，最后三个是全连接层。具体如下：
卷积层：AlexNet的前五个层次都是卷积层，每个卷积层后面跟着一个ReLU激活函数，以引入非线性。这些卷积层旨在提取图像的特征。
局部响应归一化（LRN）：在某些卷积层后使用了局部响应归一化，这是一种提高模型泛化能力的正则化方法。
最大池化层：在部分卷积层之后使用最大池化层来降低特征的空间维度，减少计算量和过拟合的风险。
全连接层：网络的最后三个层次是全连接层，其中最后两个全连接层后跟有Dropout，以进一步防止过拟合。
输出层：最后一个全连接层后是线性层，然后是softmax激活函数，输出1000个类别上的概率分布。
2.ResNet 引入残差学习，缓解梯度消失和梯度爆炸的问题。
ResNet的核心是残差块（residual block），网络通过堆叠这些残差块来构建。一个基本的残差块包含以下几部分：
跳跃连接（Skip Connections）：这是ResNet最关键的创新，通过跳跃连接，输入可以直接绕过一个或多个层传到输出，输出是输入与这些层的输出的加和。这种结构使得网络可以学习输入到输出的残差，而不是直接学习输出，这有助于缓解梯度消失问题。
卷积层：残差块内部包含多个卷积层，通常使用小尺寸的卷积核（如3x3），并且通常会有批量归一化（Batch Normalization）和ReLU激活函数。
池化层：在某些残差块之间会插入最大池化层来降低特征图的空间维度。
左边针对网络层数较少的网络所使用的残差结构，右边主要针对网络层数较多的网络所使用的结构。1*1的卷积层保证了shape相同的情况下减少参数。
3.EfficientNet EfficientNet的复合缩放方法的直觉在于，如果输入图像更大，网络就需要更多的层来增加感受野，以及更多的通道来捕捉更细粒度的模式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb23482d89d4fc22f57ebb6f9cb3325d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbac72c80ac4a1f3b315cb4824f29c54/" rel="bookmark">
			数据结构之树的存储结构详解与示例（C/C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 树的存储结构1. 顺序存储结构2. 链式存储结构结论 树（Tree）是一种非常常见的数据结构，它模拟了一种层级或分支结构。树由节点（或称为顶点）组成，每个节点包含一个值，并且可能有多个子节点。在本文中，我们将探讨树的几种存储结构，并提供C和C++的示例。
树的存储结构 树的存储结构主要有以下几种：
1. 顺序存储结构 顺序存储结构通常用于表示完全二叉树，它使用数组来存储树的节点。在这种情况下，如果父节点的索引是i，那么它的左子节点的索引是2i + 1，右子节点的索引是2i + 2。
特点：
数组的第一个元素存储树的根节点。对于数组中任意一个元素（节点），其左子节点的位置是2i（其中i是当前节点的索引，从0开始计数）。其右子节点的位置是2i + 1。如果树不是完全二叉树，那么数组中会有一些位置是空的，这会造成空间浪费。 优点
简单，易于实现。节省空间，特别是对于完全二叉树。
缺点不适用于非完全二叉树，会导致空间浪费。插入和删除操作比较复杂。 示例
假设我们有以下完全二叉树：
1 / \ 2 3 / \ / \ 4 5 6 7 使用顺序存储结构，我们可以将其存储在数组中如下：
[1, 2, 3, 4, 5, 6, 7]
以下是一个使用C语言实现的顺序存储结构的示例：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define MAX_SIZE 100 typedef struct { int data[MAX_SIZE]; int size; } SeqTree; void initTree(SeqTree *tree) { tree-&gt;size = 0; } void insert(SeqTree *tree, int value, int index) { if (index &lt; 0 || index &gt;= MAX_SIZE) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbac72c80ac4a1f3b315cb4824f29c54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5af87e268c4f4fdd18bda345b939711/" rel="bookmark">
			时序数据库-03-opentsdb-分布式时序数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时序数据库系列 时序数据库-01-时序数据库有哪些？为什么要使用
时序数据库-02-聊一聊时序数据库
时序数据库-03-opentsdb-分布式时序数据库
时序数据库-04-InfluxData-分布式时序数据库
时序数据库-05-TDengine 是一款开源、高性能、云原生的时序数据库 (Time-Series Database, TSDB)
时序数据库-05-TDengine Time-Series Database, TSDB
时序数据库-05-TDengine windows11 WSL 安装实战笔记 docker
时序数据库-06-01-vm VictoriaMetrics 快速、经济高效的监控解决方案和时间序列数据库
时序数据库-06-02-vm VictoriaMetrics install on docker 安装 vm
时序数据库-06-03-vm VictoriaMetrics java 整合
时序数据库-06-04-vm VictoriaMetrics storage 存储原理简介
时序数据库-06-05-vm VictoriaMetrics cluster 集群原理
时序数据库-06-06-vm VictoriaMetrics cluster 集群访问方式
Opentsdb Opentsdb 是一个可扩展的时序数据库。
在不丢失数据粒度的情况下存储和服务大量的时序数据。
特性 存储 数据会被精确地按您提供的内容存储
支持毫秒级精度写入
可永久保留原始数据
扩展 运行在 Hadoop 和 HBase 上
每秒可扩展至百万级写入量
通过增加节点来增加容量
读取 可以从 GUI 生成图表
可以从 HTTP API 提取数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5af87e268c4f4fdd18bda345b939711/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cbad84c03a6b8c49506c3b3c30c1faf/" rel="bookmark">
			【C&#43;&#43;/STL】：set和map的介绍及基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一，树形结构的关联式容器二，set1，set 的介绍2，set 常用接口的使用(1) set 的插入，迭代器遍历(2) set 的区间构造，范围for(3) set 的删除 三，multiset1, multiset 的介绍2，multiset 的简单使用 四，map1，map 的介绍2，map 常用接口的使用(1) map 的构造(2) map 的迭代器和范围 for 3，map 中的下标访问符 [ ](1)，下标访问符 [ ] 的多种功能(2)，统计字符串个数示例 五，multimap1，multimap 的介绍2，multimap 的简单使用 前言 在前面，我们已经接触过STL中的部分容器，比如：vector、list、deque等，这些容器统称为序列式容器，因为其底层为线性序列的数据结构，里面存储的是元素本身。那什么是关联式容器？它与序列式容器有什么区别？
关联式容器也是用来存储数据的，与序列式容器不同的是，其里面存储的是&lt;key, value&gt;结构的键值对，在数据检索时比序列式容器效率更高。
一，树形结构的关联式容器 根据应用场景的不同，STL总共实现了两种不同结构的管理式容器：树型结构与哈希结构。树型结构的关联式容器主要有四种：map、set、multimap、multiset。这四种容器的共同点是：使用平衡搜索树(即红黑树)作为其底层结果，容器中的元素是一个有序的序列。下面一依次介绍每一个容器。
二，set 1，set 的介绍 (1) set是按照一定次序存储元素的容器
(2) 在set中，元素的value也标识它(value就是key，类型为T)，并且每个value必须是唯一的。set中的元素不能在容器中修改(元素总是const)，但是可以从容器中插入或删除它们。
(3) set在底层是用二叉搜索树(红黑树) 实现的。
注意：
(1) set中的元素不可以重复(因此可以使用set进行去重)。
(2) 使用set的迭代器遍历set中的元素，可以得到有序序列。
(3) set中的元素默认排升序。
(4) set中查找某个元素，时间复杂度为： l o g 2 n log_2 n log2​n。
2，set 常用接口的使用 使用set容器要包含头文件：
#include &lt;set&gt; set 常用接口的使用举例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cbad84c03a6b8c49506c3b3c30c1faf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee699f4dc0d801f4292e6373f0516fb8/" rel="bookmark">
			如何学习MySQL：糙快猛的大数据之路（万字长文，建议收藏）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这个数据驱动的时代,MySQL作为一款强大的关系型数据库管理系统,已经成为大数据开发者的必备技能之一。然而,面对浩如烟海的MySQL知识,很多人常常不知从何下手。今天,让我们一起探讨如何以"糙快猛"的方式高效学习MySQL。
什么是"糙快猛"学习法? "糙快猛"学习法源于一个简单而深刻的道理:学习就应该糙快猛,不要一下子追求完美,在不完美的状态下前行才是最高效的姿势。这种方法强调:
快速入门,不拘小节持续实践,边学边用勇于尝试,不怕犯错
这种学习方法特别适合在当今快速变化的技术环境中学习新技能,比如MySQL。
我的MySQL学习故事 作为一名从0基础跨行到大数据领域的开发者,我深深体会到"糙快猛"学习法的威力。记得刚开始学习MySQL时,我并没有去追求掌握每一个细节,而是迅速搭建了一个简单的数据库环境,开始了我的实践之旅。
有一次,我需要为一个小项目创建一个用户表。虽然我对数据库设计还不够熟悉,但我决定先尝试一下:
CREATE TABLE users ( id INT AUTO_INCREMENT PRIMARY KEY, username VARCHAR(50) NOT NULL, email VARCHAR(100) NOT NULL, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ); 这个表结构可能不是最优的,但它让我快速开始了我的项目。随着我对MySQL的理解加深,我逐渐优化了这个表结构,添加了索引,调整了字段类型。这个过程让我深刻体会到,"糙快猛"并不意味着永远停留在"糙"的阶段,而是一个不断迭代、持续优化的过程。
MySQL学习的"糙快猛"之道 1. 快速搭建环境 不要在环境搭建上花费太多时间。使用Docker可以快速启动一个MySQL实例:
docker run --name mysql-learn -e MYSQL_ROOT_PASSWORD=mypassword -d mysql:latest 2. 从基本的CRUD操作开始 掌握基本的增删改查(CRUD)操作是学习MySQL的第一步:
-- 插入数据 INSERT INTO users (username, email) VALUES ('john_doe', 'john@example.com'); -- 查询数据 SELECT * FROM users WHERE username = 'john_doe'; -- 更新数据 UPDATE users SET email = 'john.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee699f4dc0d801f4292e6373f0516fb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdd3b74f065bcec2131d7f76020af5dc/" rel="bookmark">
			如何学习Spark：糙快猛的大数据之旅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一名大数据开发者,我深知学习Spark的重要性。今天,我想和大家分享一下我的Spark学习心得,希望能够帮助到正在学习或准备学习Spark的朋友们。
目录 Spark是什么?学习Spark的"糙快猛"之道1. 不要追求完美,在实践中学习2. 利用大模型作为24小时助教3. 根据自己的节奏来4. 实战项目是最好的老师 深入Spark：进阶学习策略1. 理解Spark的核心概念2. 拥抱Spark生态系统3. 实战驱动学习4. 性能调优：磨刀不误砍柴工5. 保持学习的激情 Spark高级应用：从入门到精通1. 机器学习与Spark MLlib2. 图计算与GraphX3. 性能调优进阶4. 实战案例：日志分析系统5. 保持学习和探索的态度 Spark在企业级应用中的实战经验1. 数据湖构建与管理2. 实时数据处理与分析3. 大规模机器学习4. 性能调优的艺术5. 与其他大数据技术的集成 结语：持续学习，不断突破 Spark是什么? 首先,让我们简单了解一下Spark。Apache Spark是一个快速、通用的分布式计算系统,专为大规模数据处理而设计。它提供了高级API,支持Java、Scala、Python和R等多种编程语言,能够运行各种工作负载,包括批处理、流处理、机器学习和交互式查询等。
学习Spark的"糙快猛"之道 说到学习Spark,我想分享一个我的亲身经历。秘诀是什么?就是"糙快猛"!
1. 不要追求完美,在实践中学习 学习Spark时,不要一开始就追求完美。先快速上手,了解基本概念和操作,然后在实践中不断深化理解。比如,你可以先学习如何创建一个简单的SparkSession:
from pyspark.sql import SparkSession spark = SparkSession.builder \ .appName("MyFirstSparkApp") \ .getOrCreate() # 读取一个CSV文件 df = spark.read.csv("path/to/your/file.csv", header=True, inferSchema=True) # 显示数据的前几行 df.show() # 关闭SparkSession spark.stop() 这个简单的例子让你快速体验了Spark的基本操作。记住,不完美没关系,重要的是你迈出了第一步!
2. 利用大模型作为24小时助教 现在我们有了大模型作为24小时助教,学习效率可以大大提高。遇到问题时,可以随时向大模型提问,获取解答和建议。但要注意,大模型虽然能帮上不少忙,但还远没到能完全代劳的地步。建立自己的审美和判断力仍然很重要。
3. 根据自己的节奏来 每个人的学习节奏不同,不要盲目跟风。有人可能一周就能掌握Spark的基础,有人可能需要一个月。找到适合自己的节奏,稳步前进才是王道。
4. 实战项目是最好的老师 理论学习固然重要,但实战项目才是真正提升技能的关键。试着用Spark解决一些实际问题,比如分析一个大型数据集:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdd3b74f065bcec2131d7f76020af5dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5a5a70d7e98dc86bd8cd3b07cbff2bc/" rel="bookmark">
			Java——学生信息管理系统（简单&#43;超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：该系统使用Java中的基础技术，其中采用技术：ArrayList集合储存学生对象信息，实现了很简单学生信息管理系统，其中有通过控制台的键盘录入实现了添加学生信息功能，删除学生信息功能，修改学生信息功能，查看学生信息功能。都有完整代码，也有注释。
注：该系统博主按照自己的思路写的，想到什么写什么，逻辑可能存在问题或者不完美等，还请见谅，其中详细介绍了添加学生功能的代码逻辑以及存储是的内存图等，其他功能感觉用到的技术感觉和添加功能的差不多就不做多介绍了。
目录
一、主页面展示
二、项目结构
三、封装Student类
1、封装学生信息字段代码部分
2、生成Getter和Setter方法
3、生成有参构造方法和无参构造方法
4、Student完整代码
四、service业务逻辑层StudentDao类封装实现方法
1、添加学生信息代码
2、查询学生信息功能代码
3、删除学习信息功能代码
4、修改学生信息功能代码
5、StudentDao类完整代码
五、Main启动类编写系统的主页面
1、Main启动类完整代码
一、主页面展示 二、项目结构 首先创建pojo包，以及pojo包下的Student类
service层同理，都创建好后是这样的
pojo层用于封装一些实体类，其中我们封装Student类
service层我们用于封装业务逻辑代码（增删改查）
Main启动类我们用于实现主界面
三、封装Student类 1、封装学生信息字段代码部分 package pojo; public class Student { //学生姓名 private String name; //学生年龄 private int age; //学生学号 private int id; //班级信息 private String team; } 封装学生信息字段
name 学生名字age 学生年龄id 学生学号team 所属班级 2、生成Getter和Setter方法 3、生成有参构造方法和无参构造方法 至此学生信息Student类封装完成
4、Student完整代码 package pojo; public class Student { //学生姓名 private String name; //学生年龄 private int age; //学生学号 private int id; //班级信息 private String team; public String getName() { return name; } public void setName(String name) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5a5a70d7e98dc86bd8cd3b07cbff2bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfa53566d7070a57fdfa8c8332fc2971/" rel="bookmark">
			计算机网络入门 -- 常用网络协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机网络入门 – 常用网络协议 1.分类 1.1 模型回顾 计算机网络细分可以划为七层模型，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。而上三层可以划为应用层中。
1.2 分类 1.2.1 应用层 为用户的应用进程提供网络通信服务，包括DNS协议、HTTP协议和HTTPS协议。
1.2.2 传输层 负责两台主机之间的数据传输，将数据从发送端传输到接收端，其中包括TCP和UDP协议。
1.2.3 网络层 负责传输的地址管理和路由选择，在众多复杂网络环境中确定一条合适的路径，包括IP协议。
1.2.4 数据链路层 负责设备之间数据帧的传输和识别，将网络层传递的数据报封装成帧，在处于同一个数据链路节点的两个设备之间传输，包括ARP协议和MTU协议。
1.2.5 物理层 负责光电信号传输，实现相邻计算机节点之间比特流透明传输。
1.3 意义 无论是将网络模型分为五层还是七层，都是为了简化网络设计的复杂性，通信协议采用分层结构，各层之间相互独立但又协同工作。在设计一个复杂庞大的框架时，尽可能使之间的功能解耦是一种很明智的做法。
2.应用层协议 2.1 概念 应用层网络负责各个程序之间通信。发生网络传输一个数据时，先由应用层对数据按照对应的协议封装，并交给下一层传输层，经过层层网络传输后数据到达接收端，又从下往上分用。
2.2 协议 2.2.1 DNS协议 DNS建立在TCP和UDP通信协议上，默认端口为53。正常传输通过UDP进行通信，当报文较长时切换至TCP协议。其功能是将便于人类理解的网络域名(如:www.baidu.com)转换为IP地址，而这种映射关系则保存于DNS服务器中。总体来说，域名解析可以分为两个步骤：第一步客户端向本地DNS服务器发起一个DNS请求报文，报文里携带需要查询的域名，第二步本地DNS服务器向本机回应一个DNS响应报文，报文里携带查询域名所对应的IP地址。
1.在本地缓存中查询，如果有则返回IP，反之请求本地DNS。2.本地DNS收到请求后，先在服务器管理区域记录中查询，若无数据则在服务器本地缓存中查询，若还没有则将请求送达根域名服务器。3.根域名服务器解析请求的根域部分，然后将包含下一级域名信息的DNS服务器地址返回至本地DNS服务器。4.本地DNS服务器利用根域名服务器解析的地址访问下一级DNS服务器，得到再下一级的DNS服务器地址。5.按照上述递归方法逐级接近查询目标，最后在有目标的DNS服务器上找到相应的IP信息。6.本地DNS服务器将最终擦寻的IP返回至客户端，让客户端访问对应主机。 2.2.2 HTTP协议 HTTP本身是一个简单的请求，即响应协议，运行在TCP协议之上。该协议指定了客户端可能发送给服务器什么样的消息以及会得到什么样的响应。同其他应用层协议一样，是为了实现某一类具体应用的协议，并由某一运行在用户空间的应用程序来实现其功能。HTTP是一种协议规范，这种规范记录在文档上，为真正通过HTTP进行通信的HTTP的实现程序。
2.2.2.1 HTTP事务处理 1.客户端域服务器建立连接2.客户端向服务端发送请求3.服务器响应请求，并根据请求返回相应的数据4.客户端与服务端关闭连接 2.2.2.2 HTTP报文格式 请求本身由请求行、请求头和请求体狗工程
请求行：包括请求方法、路径、版本号等请求头：为多个键值对数据请求体：包含请求数据响应行：包含状态码、版本号 2.2.2.3 响应码 200：客户端请求成功；3xx；4xx；5xx
2.2.2.4 特点 1.支持C/S模式2.传输速度快，客户端向服务器发送请求，只需要传输请求方法和路径3.请求灵活，HTTP允许传输任意类型的数据对象4.无连接，每次连接只能处理一个请求，服务器处理完客户端请求，客户端收到响应后就断开连接5.无状态，协议本身对事务处理没有记忆能力，如果后序连接需要之前发送的信息时就需要重传 2.2.3 HTTPS协议 HTTPS同样作为应用层协议，可以说它是HTTP的升级版，增加了传输数据的安全性，HTTPS协议是在HTTP的基础上增加了一个SSL外壳，HTTPS运行在SSL上，SSL运行在TCP上，对数据的加密工作就是在SSL上完成的
3.传输层协议 3.1 概念 传输层的主要功能是为了实现“端口到端口”的通信，以确保一条数据发送到主机上后，能够正确的传递到对应的端口上。
3.2 协议 3.2.1 UDP协议 UDP是一种面向无连接的传输协议，无需连接就可以发送封装IP的数据包。但面向无连接的缺点就是不稳定，一旦在通信链路上出现网络波动或连接问题则会发生数据丢包。
3.2.1.1 UDP报文 3.2.1.2 特点 无连接：只需要指导目标机的IP和端口就可以发送数据，其间无连接。不可靠：没有一系列机制保证数据传输的丢包问题。面向数据报发送：应用层交给UDP什么样的数据，UDP就发送什么样的数据，不会拆分、合并。传输限制：UDP一次传输上限为64K。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfa53566d7070a57fdfa8c8332fc2971/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cef4b8b0bab1bcbdaf75afb9c688e638/" rel="bookmark">
			《0基础》学习Python——第十七讲__正则表达式（requests）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是正则表 正则表达式是一种用于匹配和操作字符串的强大工具。它可以用于检索、替换和验证字符串。正则表达式使用特定的语法来描述字符串的模式，然后用于查找符合该模式的字符串。
在Python中，可以使用re模块来使用正则表达式。re模块提供了一组函数，包括match()、search()、findall()、finditer()等，用于执行不同类型的匹配操作。
因为正则表达式也是用字符串表示的，所以首先了解如何用字符来描述字符，如果直接给出字符，就是精确匹配，但有一些字符加上转义符后就具有特殊含义
二、正则表达式元字符 1、\d : 可以匹配一个数字，例如：'00\d'可以匹配'007'，但无法匹配'00A'，'\d\d\d'可以匹配'010'
2、\w ：可以匹配一个字母或数字，例如：'\w\w\d'可以匹配'py3'
3、'.' ：点可以匹配除\n,\r的任意单个字符，例如：'py.'可以匹配'pyc'、'pyo'、'py!'等等
4、\s ：可以匹配任何不可见字符，包括空格、制表符、换页符等
5、\D ：匹配一个非数字字符，等价于 [^0-9 ]
6、\S ：匹配可见字符，[^\f\n\r\t\v]
7、\W：匹配任何非单词字符，[^A-Za-z0-9_ ]
8、\b ：匹配一个单词的边界，指单词和空格间的位置
9、\B：匹配非单词边界，"er\B"能够匹配"er",但不能匹配"never"中的er
10、\f：换页符
11、\n：换行符
12、\r：回车符
13、\t：制表符
14、\v：垂直制表符 三、匹配长字符串 要匹配变长的字符，在正则表达式中，用 * 表示任意个字符（包括0个），用 + 表示至少一个字符，用 ? 表示0个或1个字符，用{n}表示n个字符，用{n,m}表示n~m个字符
[xyz]：字符集合，匹配所包含的任意一个字符，eg：[abc],即只能匹配abc中的一个字符
[a-z]：字符范围，匹配指定范围的任意字符，如：[A-Z],即可匹配一个A-Z之间的大写字母
[0-9]：数字范围，匹配指定范围的任意数字一个
*：匹配前面的子表达式任意次 ，即&gt;=0
+：匹配前面的子表达式一次或多次，即&gt;=1
?：匹配前面的子表达式一次或零次，即0或1
^：匹配输入的字符首，即限制开头,^\d表示必须以数字开头
$：匹配输入的字符尾，即限制结尾,\d$表示必须以数字结束
{n}：n是一个非负整数，匹配确定的n次
{n，}：n是一个非负整数，至少匹配n次
{n，m}：n是一个非负整数，最少匹配n次，最多匹配m次
A|B可以匹配A或B，所以(P|p)ython可以匹配'Python'或者'python'
在正则中 - 表示从什么到什么，[ ] 表示范围，例如：
[0-9a-zA-Z\_] 可以匹配一个数字、字母或者下划线
[0-9a-zA-Z\_]+ 可以匹配至少由一个数字、字母或者下划线组成的字符串,比如'a100'，'0_Z'，'Py3000'等
[a-zA-Z\_][0-9a-zA-Z\_]* 可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的命名规则
[a-zA-Z\_][0-9a-zA-Z\_]{0, 19} 更精确地限制了长度是1-20个字符（前面1个字符，后面最多19个字符）
四、match（）可以判断正则表达式是否匹配 在正则表达式中，match()是用于从字符串的起始位置开始匹配模式的函数。它尝试从字符串的开头匹配正则表达式模式，如果匹配成功则返回一个Match对象，否则返回None。
Match对象包含了匹配的结果以及其他相关信息，可以通过调用group()方法来获取匹配的字符串。如果正则表达式中包含了分组，可以通过传递分组索引或分组名称给group()方法来获取特定的分组匹配结果。
例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cef4b8b0bab1bcbdaf75afb9c688e638/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cab7a1d3fc678f87c56fd405c1cbadb/" rel="bookmark">
			【数据结构】堆的实现以及建堆算法和堆排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【数据结构】堆的实现以及建堆算法和堆排序 🔥个人主页：大白的编程日记
🔥专栏：数据结构
文章目录 【数据结构】堆的实现以及建堆算法和堆排序前言一.堆的实现1.1 堆数据的插入1.2堆数据的删除 二.建堆算法和堆排序2.1思路分析2.2向上建堆算法2.3向下调整建堆2.4堆排序 后言 前言 哈喽，各位小伙伴大家好！上期给大家讲了树，二叉树以及堆。今天带着大家实现堆这个数据结构，以及堆排序。话不多说，咱们进入正题！向大厂冲锋！
一.堆的实现 堆的定义
我们用数组控制堆,在物理上是一个数组。逻辑上想象成堆。然后用size记录堆的节点个数。后面涉及扩容，所以用capacity记录数组空间大小。这里我们实现的是小堆 typedef int HPDataType; typedef struct Heap { HPDataType* a; int size; int capacity; }HP; 堆的初始化 初始化时我们可以先给堆开好空间，也可以不开。我们不开就先给NULL，然后size和capacity都先给0。
void HPInit(HP* php) { assert(php); php-&gt;a = NULL; php-&gt;size = php-&gt;capacity = 0; }//初始化 堆的销毁 我们先free销毁数组，在把size和capacity置为0.
void HPDestroy(HP* php) { assert(php); free(php-&gt;a);//销毁数组 php-&gt;a = NULL; php-&gt;capacity = php-&gt;size = 0; }//销毁 1.1 堆数据的插入 思路分析
想要实现堆的插入，我们需要在数组插入数据后进行向上调整。
堆数据插入
插入数据前我们需要检查一下是否需要扩容。
第一次没开空间，我们就给4个数据的空间。
否则我们就realloc扩容为2倍。
最后在赋值。然后size++更新节点个数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cab7a1d3fc678f87c56fd405c1cbadb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f3bda82775a1938702e822790e1c37f/" rel="bookmark">
			C&#43;&#43;树形结构（2 树的直径）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.定义：
2.直径的性质：
3.树的直径求解方法：
4.直径端点求解方法：
朴素方法：
优化方法：
5.例题：
6.直径公共点：
7.例题：
8.去掉再加上：
9.例题：
1.定义： 树的直径是树上两点间距离的最大值。即树中最远的两个节点之间的距离被称为树的直径，连接这两点的路径被称为树的最长链
最长链：4-2-1-7-6-3
所以这颗树的直径是15，直径路径为4-2-1-3-6
2.直径的性质： 直径的性质1：直径的端点一定是叶子节点
直径的性质2：任意点的最长链端点一定是直径端点
直径的性质3：如果一棵树有多条直径且边权都为正，那么它们必然相交，且有极长连续段（可以是一个点，交点为树的中心）
直径的性质4：树T1的直径为x,y，树T2的直径为s,t。现有一边u,v与两颗树相连，新树的直径端点一点是x,y,s,t中的两个
3.树的直径求解方法： 引理性质2：任意点的最长链端点一定是直径端点。方法：我们随意找一个点x,进行dfs找到最长链的端点s,再以端点s做第二遍dfs，此时可以找到直径的第二个端点t。此时端点s到t的距离就是树的直径。
输入一颗无根树，第一行为一个正整数n(n&lt;1e5),表示这颗树有n个节点接下来的n−1行,每行三个正整数u,v,w，表示u,v（u,v&lt;=n）有一条权值为w(w&lt;100)的边相连，求树的直径。 #include&lt;bits/stdc++.h&gt; using namespace std; int n,data[100005],pl,maxn; vector&lt;int&gt; v[100005]; vector&lt;int&gt; w[100005]; void dfs(int x,int fa) { for(int i=0; i&lt;v[x].size(); i++) { int y=v[x][i]; if(y==fa) continue; data[y]=data[x]+w[x][i]; if(data[y]&gt;maxn) maxn=data[y],pl=y;//记录端点 dfs(y,x); } } int main() { cin&gt;&gt;n; for(int i=1; i&lt;n; i++) { int x,y,z;cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; v[x].push_back(y); v[y].push_back(x); w[x].push_back(z); w[y].push_back(z); } dfs(1,0);//寻找直径 memset(data,0,sizeof data);//清空距离 dfs(pl,0);//从pl出发寻找端点 cout&lt;&lt;maxn; return 0; } 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f3bda82775a1938702e822790e1c37f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/134/">«</a>
	<span class="pagination__item pagination__item--current">135/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/136/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>