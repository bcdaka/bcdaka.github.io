<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b5d8798c736882a528dcd5ddbe84ec8/" rel="bookmark">
			算法【Java】 —— 前缀和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模板引入 一维前缀和 https://www.nowcoder.com/share/jump/9257752291725692504394
解法一：暴力枚举
在每次提供 l 与 r 的时候，都从 l 开始遍历数组，直到遇到 r 停止，这个方法的时间复杂度为 O(N * q)
解法二：前缀和
如果我们事先就知道所有从 0 开始的子数组的前缀和的话，那么要计算 从 l 到 r 之间的字数组的和的时候，我们就可以利用这个已知的前缀和数组进行计算，也就是 ans = dp[r] - dp[l] + nums[l]
时间复杂度为 O(N + q) , 空间复杂度为 O(N)
import java.util.Scanner; // 注意类名必须为 Main, 不要有任何 package xxx 信息 public class Main { public static void main(String[] args) { Scanner in = new Scanner(System.in); int n = in.nextInt(); int q = in.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b5d8798c736882a528dcd5ddbe84ec8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68ea031c59d733b6d6f222dc58aeb5f9/" rel="bookmark">
			算法练习题17——leetcode54螺旋矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。
代码 import java.util.*; class Solution { public List&lt;Integer&gt; spiralOrder(int[][] matrix) { // 用于存储螺旋顺序遍历的结果 List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); // 如果矩阵为空，直接返回空的结果列表 if (matrix == null || matrix.length == 0) return result; // 获取矩阵的行数 m 和列数 n int m = matrix.length; // 行数 int n = matrix[0].length; // 列数 // 初始化四个边界，用于控制螺旋遍历的范围 int top = 0; // 上边界 int bottom = m - 1; // 下边界 int left = 0; // 左边界 int right = n - 1; // 右边界 // 当上、下、左、右边界没有相互交错时，继续遍历 while (top &lt;= bottom &amp;&amp; left &lt;= right) { // 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68ea031c59d733b6d6f222dc58aeb5f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87e92db61d788e171e24e5f96f8de241/" rel="bookmark">
			【Qt】qt发布Release版本,打包.exe可执行文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：Qt编译的可执行程序，如果直接运行，会出现0xc000007b报错，或者“由于占不到Qt5Network.dll,无法继续执行代码。重新安装程序可能会解决此问题”的报错，因为缺少相关的依赖包和动态库。
1、第一步：找到exe可执行文件 2、第二步：把exe文件复制到一个空白文件夹 注意：文件夹路径不能有中文，这里以output为例
3、第三步：根据Qt的编译器，选择Qt命令行打开。 4、第四步：在终端中输入以下命令 cd D:/output(输入完按下空格）
windeployqt DatabaseManageSystem.exe(输入完按下空格）
此时会自动出来一大堆日志，等到日志打印结束，output文件夹出现很多文件：
然后我们在把这些文件复制回原来的exe文件夹，现在就可以直接运行exe文件了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1d2e4785a38f00d4948f93a3f0ee29b/" rel="bookmark">
			【第0007页 · 数组】数组中重复的数据（如何实现数组的原地修改）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【前言】本文以及之后的一些题解都会陆续整理到目录中，若想了解全部题解整理，请看这里：
第0007页 · 数组中重复的数据 今天，我们来看一个在实际工作中运用不多，但是对于一些算法题还是有必要的奇技淫巧——数组的原地修改。下面我们将通过两道题目来学习这种技巧。
【找到所有数组中消失的数】 给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。
示例1示例2输入描述：nums = [4, 3, 2, 7, 8, 2, 3,1]输入描述：nums = [1, 1]输出描述：[5, 6]输出描述：[2] 【解题分析】这道题本来十分简单，但是如果加上一个要求：在不使用额外空间且时间复杂度为 O(n) 的情况下解决这个问题吗? 可以假定返回的数组不算在额外空间内。那么这道题就有些内容可以说了。
这里我们先来讲解一下这种原地修改的想法：首先，由于 nums 的长度恰好为 n，而我们要查找的数字范围均在 [1, n] 中，那么我们不妨将位置 k 处的值当成数字 k + 1 是否出现的凭证。以上是 Hash 的思想。
接下来，我们需要考虑如何才能使位置 k 处的值能够代表数字 k + 1 是否出现过。我们提供一种想法是如果 k + 1 出现过，需要将位置 k 处的值加上 n，因为本来数组中所有的数都小于 n，只能是由于出现过而导致大于 n。根据以上想法，我们就可以使位置 k 处的值能够代表数字 k + 1 是否出现过。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1d2e4785a38f00d4948f93a3f0ee29b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40827bcc58d09bf62be214466295cad7/" rel="bookmark">
			C语言练习题之 数组中出现次数超过一半的数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 给一个长度为 n 的数组，数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。
例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。
数据范围：n≤50000，数组中元素的值0≤val≤10000
要求：空间复杂度：O(1)，时间复杂度O(n)
输入描述： 保证数组输入非空，且保证有解
示例1 输入：[1,2,3,2,2,2,5,4,2]
返回值：2
示例2 输入：[3,3,3,3,2,2,2]
返回值：3
示例3
输入：[1]
返回值：1
分析如下： 题目意思比较明确，就是要找出数组中的一个数字，这个数字在数组中出现次数超过数组长度的一半。
而题目提供的数组长度是≤50000，数组中元素的取值是 0 - 10000。
基于这些信息，很容易从循环的角度出发，对数组每个数字进行循环统计。
代码如下：
//循环法查找 int find(int arr[], int sz) { if (sz == 0)	//如果数组内没有元素，则返回-1。 return -1; int i = 0; int j = 0; for (i = 0; i &lt; sz; i++)	//遍历数组，每个数都查一遍 { int count = 0; for (j = 0; j &lt; sz; j++)	//数组中每个数与数组中其余数遍历一遍 { if (arr[j] == arr[i] &amp;&amp; i!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40827bcc58d09bf62be214466295cad7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71936fbf73b9a09610b468821dc568ff/" rel="bookmark">
			【Python 千题 —— 算法篇】无重复字符最长子段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 千题持续更新中 ……
脑图地址 👉：⭐https://twilight-fanyi.gitee.io/mind-map/Python千题.html⭐
题目背景 在编程过程中，处理字符串的任务时常遇到，其中一个经典问题是查找无重复字符的最长子串。这在很多应用场景中有实际价值，例如在文本处理、数据分析、加密技术等领域中，确保字符串的唯一性和最长性是至关重要的。本题目要求我们不仅要找出最长的无重复字符的子串，还要优化算法，以应对大量输入的需求。
通过本题的学习，我们可以进一步提升对字符串的理解和操作，掌握滑动窗口、哈希表等高效的算法技巧。
题目描述 给定一个字符串 s，请你找出其中不含有重复字符的最长子串的长度。
你需要实现一个函数 lengthOfLongestSubstring()，该函数接收一个字符串 s 作为输入，并返回无重复字符的最长子串的长度。
输入描述 一个字符串 s，长度不超过 10^5，只包含 ASCII 字符。 输出描述 一个整数，表示无重复字符的最长子串的长度。 示例 示例 ① 输入：
# 调用 lengthOfLongestSubstring() 函数 print(lengthOfLongestSubstring("abcabcbb")) 输出：
3 解释：无重复字符的最长子串是 “abc”，其长度为 3。
示例 ② 输入：
print(lengthOfLongestSubstring("bbbbb")) 输出：
1 解释：最长子串是 “b”，其长度为 1。
代码讲解与多种解法 解法一：暴力破解法 最简单的解法是尝试枚举字符串中每一个子串，并判断这个子串中是否包含重复字符。这种方法需要嵌套循环遍历每个子串，并检查是否有重复字符。
def lengthOfLongestSubstring(s): def is_unique(substring): return len(substring) == len(set(substring)) n = len(s) max_len = 0 for i in range(n): for j in range(i + 1, n + 1): if is_unique(s[i:j]): max_len = max(max_len, j - i) return max_len 优点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71936fbf73b9a09610b468821dc568ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/570d6b82aff0d34b8726155946eadde3/" rel="bookmark">
			深入探秘 Java 网络编程：从基础到多线程服务器的全方位指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的主页：2的n次方_ Java 作为一门功能强大的编程语言，不仅在桌面应用、移动开发、后端开发等领域表现出色，还在网络编程中拥有广泛的应用。网络编程涉及在两个或多个设备之间通过网络进行通信，这对于构建分布式系统、客户端-服务器应用程序、以及互联网服务至关重要。在这篇博客中，我们将详细探讨 Java 网络编程的基础知识，并通过代码示例展示如何在 Java 中实现网络通信。
1. Java 网络编程基础 Java 网络编程主要基于 java.net 包，该包提供了处理网络操作的类和接口。以下是网络编程中几个重要的概念和类：
1.1 IP 地址和端口 IP 地址: 每个连接到网络的设备都有一个唯一的 IP 地址，用于标识设备的网络位置。端口: 端口是设备上的通信端点，每个端口用于与特定服务进行通信。常见端口如 HTTP 的 80 端口，HTTPS 的 443 端口。 1.2 Socket 编程 Socket 是 Java 中用于实现客户端和服务器之间通信的基础类。它允许应用程序通过 TCP 或 UDP 协议传输数据。
TCP (Transmission Control Protocol): 一种可靠的、面向连接的协议，用于在网络上传输数据。UDP (User Datagram Protocol): 一种无连接的协议，允许发送数据报文，但不保证数据的送达顺序或成功送达。 2. 基于 TCP 的 Socket 编程 TCP 是一种可靠的传输协议，适用于需要保证数据完整传输的应用。以下是如何在 Java 中使用 TCP 进行网络编程的示例。
2.1 创建服务器端 服务器端需要监听一个特定的端口，并等待客户端连接。ServerSocket 类用于在指定的端口上侦听请求。
import java.io.*; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/570d6b82aff0d34b8726155946eadde3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d22b99359b73bedd437fd6f7d3e9525/" rel="bookmark">
			【MySQL】MySQL常用的数据类型——表的操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 🌟🌟本期讲解关于MySQL常用数据类型，表的简单使用，希望能帮到屏幕前的你。
🌈上期博客在这里：http://t.csdnimg.cn/wwaqe
🌈感兴趣的小伙伴看一看小编主页：GGBondlctrl-CSDN博客
目录
前言：
📚️1.MySQL常用的数据类型
1.1数值类型
1.2字符串类型
1.3日期类型
📚️2.表的简单操作
2.1创建表
2.2查看表
2.3查看表结构
2.4删除表
📚️3.总结
📚️1.MySQL常用的数据类型 1.1数值类型 分为整型和浮点型：
注解：
BIT:这里的bit是二进制的比特位，目的是为了压缩节省空间；
TINYINT--BIGINT：都是表示的整型，其大小如上述图片所示，但是一般来说用INT就足够了。
FLOAT(M,D)与DOUBLE(M,D)：都是表示浮点型数据，M表示长度，D表示小数点后面的数字个数，但是他们都是IEEE 754标准的浮点数，都有精度丢失，存在误差。
DECIMAL(M,D)与NUMERIC(M,D)都是精度更高的浮点数，但是代价就是运算速度会变慢，消耗的空间会变得更大。这里一般用decimal表示浮点数。
扩展： 数值类型可以指定为无符号（unsigned），表示不取负数。 1字节（bytes）= 8bit。 对于整型类型的范围： 1. 有符号范围：-2^（类型字节数*8-1）到2^（类型字节数*8-1）-1，如int是4字节，就是-2^31到2^31-1 2. 无符号范围：0到2^（类型字节数*8）-1，如int就是2^32-1 尽量不使用unsigned，对于int类型可能存放不下的数据，int unsigned同样可能存放不下，与其如此，还不如设计时，将int类型提升为bigint类型。 1.2字符串类型 注解：
VARCHAR(SIZE) :这里的size表示最多存储几个字符，这里的字符不是字节，字符是由几个字节组成，这里的分配字符空间不是立即分配，而是先分配小的空间，然后在扩展。
BLOB：存储二进制数据，这里注意字符数据否是可以在码表上查询到的，查不到的例如：图片，音乐，视频就是二进制数据。
1.3日期类型 注解：
在这里的时间戳是以1970.1.1日为基础来进行计算的，用四个字节，可能在2038年就捉襟见肘了，所以这里一般用datetime来表示时间类型。
所以总结：一般用到的数据类型是
INT-----整型
DECIMAL-----浮点型
VARCHAR()-----字符类型
DATETIME------时间类型
📚️2.表的简单操作 2.1创建表 SQL执行语句：create table 表名（列名 类型，列名 类型.....）；
mysql&gt; use test96; Database changed mysql&gt; create table teacher( -&gt; name varchar(10), -&gt; age int, -&gt; high decimal, -&gt; weight decimal, -&gt; sex varchar(10), -&gt; education varchar(10), -&gt; birthday datetime, -&gt; id int); Query OK, 0 rows affected (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d22b99359b73bedd437fd6f7d3e9525/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d2e4cd0f7227d0a54e049c049c9d668/" rel="bookmark">
			电路基础笔记 --- 第一章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 关于电路吸收及发出功率的判断： 其实关于这个问题根据实际电流和电压更好判断，我们根据参考电压及参考电流再结合各自数值画出对于元件来说的实际电流方向和电位高低，在实际电流方向通过元件时如果电位变高则代表元件在产生功率，反之则表明在吸收功率
结果：
由此 我们又可以得到一个结论，在一个电路中我们提供多少功率就吸收了多少功率
电阻元件 电阻元件永远是消耗功率的元件
电压源电流源 电压源 电流源 受控电源 受控电压源 受控电流源 例题：
基尔霍夫定律 电流定律 电压定律 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ed79ef6e9d18fe0542f54ec25d9bfd6/" rel="bookmark">
			SpringBoot3 简单集成 Mybatis plus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot3 集成 Mybatis plus 1、引入Mybatisplus的starter
&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-spring-boot3-starter&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt; &lt;/dependency&gt; 2、引入数据库连接器，我这里连接mysql5.7 。 如果你的数据库版本是mysql8的话，mysql-connector-java可能需要更高的版本。
&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.30&lt;/version&gt; &lt;/dependency&gt; 3、配置mapper扫描器
@MapperScan("com.sifan.springai.mapper") // 配置mapper扫描器 @SpringBootApplication public class SpringAiApplication { public static void main(String[] args) throws Exception { SpringApplication.run(SpringAiApplication.class, args); } } 4、配置数据源
spring: datasource: url: jdbc:mysql://xx.43xxxxx.xxx:3306/db?useUnicode=true&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;useSSL=false&amp;allowMultiQueries=true password: password username: root 5、测试连接情况
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fa98c200f6236fcfd96201652b05573/" rel="bookmark">
			Spark2.x 入门： KMeans 聚类算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 KMeans简介 KMeans 是一个迭代求解的聚类算法，其属于 划分（Partitioning） 型的聚类方法，即首先创建K个划分，然后迭代地将样本从一个划分转移到另一个划分来改善最终聚类的质量。
ML包下的KMeans方法位于org.apache.spark.ml.clustering包下，其过程大致如下：
1.根据给定的k值，选取k个样本点作为初始划分中心； 2.计算所有样本点到每一个划分中心的距离，并将所有样本点划分到距离最近的划分中心； 3.计算每个划分中样本点的平均值，将其作为新的中心； 循环进行2~3步直至达到最大迭代次数，或划分中心的变化小于某一预定义阈值 显然，初始划分中心的选取在很大程度上决定了最终聚类的质量，和MLlib包一样，ML包内置的KMeans类也提供了名为 KMeans|| 的初始划分中心选择方法，它是著名的 KMeans++ 方法的并行化版本，其思想是令初始聚类中心尽可能的互相远离，具体实现细节可以参见斯坦福大学的B Bahmani在PVLDB上的论文Scalable K-Means++，这里不再赘述。
二 实战 与MLlib版本的Kmeans教程相同，本文亦使用UCI数据集中的鸢尾花数据Iris进行实验，它可以在iris获取，Iris数据的样本容量为150，有四个实数值的特征，分别代表花朵四个部位的尺寸，以及该样本对应鸢尾花的亚种类型（共有3种亚种类型），如下所示：
5.1,3.5,1.4,0.2,setosa ... 5.4,3.0,4.5,1.5,versicolor ... 7.1,3.0,5.9,2.1,virginica ... 在使用前，引入需要的包：
import org.apache.spark.ml.clustering.{KMeans,KMeansModel} import org.apache.spark.ml.linalg.{Vector,Vectors} 开启RDD的隐式转换：
import spark.implicits._ 下文中，我们默认名为spark的SparkSession已经创建。
为了便于生成相应的DataFrame，这里定义一个名为model_instance的case class作为DataFrame每一行（一个数据样本）的数据类型。
注：因为是非监督学习，所以不需要数据中的label,只需要使用特征向量数据就可以。
scala&gt; case class model_instance(features: org.apache.spark.ml.linalg.Vector) defined class model_instance 在定义数据类型完成后，即可将数据读入RDD[model_instance]的结构中，并通过RDD的隐式转换.toDF()方法完成RDD到DataFrame的转换：
val rawData = sc.textFile("file:///root/data/iris.txt") rawData: org.apache.spark.rdd.RDD[String] = file:///root/data/iris.txt MapPartitionsRDD[220] at textFile at &lt;console&gt;:56 scala&gt; val df = rawData.map(line =&gt;{ model_instance( Vectors.dense(line.split(",").filter(p =&gt; p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fa98c200f6236fcfd96201652b05573/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15a00ab5053aa11342d6ed4eca1db857/" rel="bookmark">
			Llama中的曼巴：通过推测解码加速推理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大型语言模型（LLMs）已经彻底改变了自然语言处理领域，但在处理非常长的序列时面临重大挑战。主要问题来自于Transformer架构的计算复杂度随序列长度呈二次方增长以及其巨大的键值（KV）缓存需求。这些限制严重影响了模型的效率，特别是在推理过程中，使生成长序列的速度极其缓慢。这一瓶颈限制了需要对多个长文件进行推理、处理大型代码库或在基于代理的系统中建模复杂环境的应用程序的发展。因此，研究人员正在寻找更高效的架构，既能保持或超越Transformer的性能，同时显著降低计算需求。
研究人员已经探索了各种方法来解决LLM中的效率挑战。无注意力模型，如S4、GSS和BiGS，展示了更高的计算和内存效率。结合了特定输入上下文选择的Mamba模型在不同规模上比Transformer表现出色。其他次二次方和混合架构也已被提出。知识蒸馏技术已被用来将Transformer的知识转移到线性RNN风格的模型中，如在Laughing Hyena和渐进知识方法中所示。推测解码成为加速推理的一种有前途的方法，利用较小的草稿模型生成候选标记，由较大的目标模型验证。这些方法包括拒绝采样方案、树状候选组织，以及训练和无训练的草稿模型。
康奈尔大学、日内瓦大学、Together AI和普林斯顿大学的研究人员提出了一种独特的方法，通过将预训练的Transformer蒸馏到线性RNN中来缓解LLM模型的效率挑战。此方法旨在保持生成质量的同时显著提高推理速度。该方法涉及将Transformer的权重映射到修改后的Mamba架构，该架构可以直接从预训练模型的注意力模块初始化。提出了一种多阶段蒸馏管道，结合渐进蒸馏、监督微调和定向偏好优化，以提高复杂度和下游性能。研究人员还开发了一种硬件感知的推测采样算法和快速内核，以在Mamba和混合架构上进行推测解码，实现了一个7B参数模型超过300标记/秒的吞吐量。此方法有效地将推测解码应用于混合架构，解决了复杂LLM应用中高效推理的需求。
该方法通过使用线性RNN将Transformer模型转换为Mamba模型，解决了注意力机制的限制。通过Mamba的连续时间状态空间模型扩展线性隐藏状态容量，该方法动态构建了离散时间线性RNN。这种创新架构从注意力参数初始化，并采用硬件感知分解以实现高效实施。然后，方法应用知识蒸馏将大型Transformer模型压缩到较小的基于Mamba的网络中，重点在于微调和对齐步骤。此过程结合了序列级知识蒸馏和单词级KL散度的监督微调，同时适应直接偏好优化以实现偏好对齐。
蒸馏过程使学生模型能够从教师模型的输出分布和生成中学习，优化性能并与预期偏好对齐。在此过程中，原始模型中的MLP层保持冻结状态，而Mamba层则进行训练以捕获蒸馏知识。这种方法使得可以用线性RNN块替换注意力块，同时保持模型性能。通过扩大隐藏状态大小和使用硬件感知的分解方法，该方法实现了高效的实现，允许更大的隐藏状态大小而不会显著增加计算成本。最终的基于Mamba的模型结合了Transformer架构的优势与线性RNN的效率，可能会在LLM领域取得进展。
蒸馏后的混合Mamba模型在各种基准测试中表现出竞争力。在AlpacaEval和MT-Bench这样的聊天基准测试中，50%混合模型的得分与其教师模型相当或略有优势，甚至超过了一些更大的Transformer模型。在零样本和少样本评估中，混合模型超越了从头训练的开源线性RNN模型，随着更多注意力层被替换，性能有所下降。混合模型在OpenLLM排行榜和ZeroEval基准测试中也表现出了良好结果。使用这些混合模型进行的推测解码实验在单个GPU上实现了高达1.88倍的加速。总体来看，结果表明蒸馏后的混合Mamba模型在效率和性能之间提供了良好的平衡。
本研究提出了一种通过线性RNN将Transformer模型转化为更高效的基于Mamba的模型的方法。结果表明，蒸馏后的混合Mamba模型在各种基准测试中，尤其是在聊天任务和通用语言理解任务中，表现出与教师模型相当或更好的性能。该方法在减少计算成本的同时，尤其是当保留25-50%的注意力层时，表现出特别的成功。此外，研究人员介绍了一种创新的线性RNN推测解码算法，进一步提升了推理速度。这些发现表明，在提高LLM效率的同时保持其能力方面具有显著潜力。
总结： 大型语言模型（LLMs）虽然在自然语言处理领域取得了革命性突破，但在面对长序列处理时依然存在显著的计算复杂度和内存需求问题，影响了高效推理的能力。为了解决这一瓶颈问题，研究人员提出了多种高效架构，如无注意力模型（S4、GSS和BiGS），以及结合特定上下文选择的Mamba模型，展示了较高的计算和内存效率。特别是通过将预训练的Transformer蒸馏到线性RNN中，康奈尔大学和其他机构的研究人员显著提高了推理速度，同时保持了生成质量。
通过使用线性RNN和多阶段蒸馏管道，这种新方法实现了复杂度优化和下游性能提升。研究人员还开发了硬件感知的推测采样算法和快速内核，使7B参数模型的标记生成速度超过300标记/秒。这一创新显著提高了LLM的推断效率，特别是在聊天任务和通用语言理解任务中表现优秀，并超越了一些更大的Transformer模型。
在AI技术的加持下，光年AI不仅助您轻松提升私域流量转化，还能全面优化私域流量管理，精准触达每一位潜在客户。光年AI智能化的私域流量管理体系，使您在竞争激烈的市场中快速突破，实现业务的飞速增长。选择光年AI，全面提升私域营销效果，让品牌影响力大幅提升！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09a39ee24f5dc3fb74120d973146a21c/" rel="bookmark">
			HTML 列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 列表是网页中最常用的一种数据排列方式
在HTML中，列表共分为三种：有序列表、无序列表和定义列表。在有序列表中，列表项之间有先后顺序之分。在无序列表中，列表项之间是没有先后顺序之分的。而定义列表是一组带有特殊含义的列表，一个列表项中包含“条件”和“列表”两部分。
在HTML中，有序列表中的各个列表项是有顺序的。有序列表从&lt;ol&gt;开始，到&lt;/ol&gt;结束。有序列表一般采用数字或字母作为顺序，默认是采用数字顺序。
有序列表的列表项是有一定顺序的，而无序列表的列表项是没有顺序的
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset='ut8-8'&gt; &lt;/head&gt; &lt;body&gt; &lt;!--type 属性值，默认1 是12345 a：小写的英文字母--&gt; &lt;ol type="a"&gt; &lt;li&gt;Html&lt;/li&gt; &lt;li&gt;Css&lt;/li&gt; &lt;li&gt;JavaScript&lt;/li&gt; &lt;li&gt;JQuery&lt;/li&gt; &lt;li&gt;Vue.js&lt;/li&gt; &lt;/ol&gt; &lt;!------ul元素的子元素只能是li元素，不能是其他元素--&gt; &lt;ul type="square"&gt; &lt;li&gt;Html&lt;/li&gt; &lt;li&gt;Css&lt;/li&gt; &lt;li&gt;JavaScript&lt;/li&gt; &lt;li&gt;JQuery&lt;/li&gt; &lt;li&gt;Vue.js&lt;/li&gt; &lt;/ul&gt; &lt;dl&gt; &lt;dt&gt;HTML&lt;/dt&gt; &lt;dd&gt;制作网页的标准语言，控制网页的结构&lt;/dd&gt; &lt;dt&gt;CSS&lt;/dt&gt; &lt;dd&gt;层叠样式表，控制网页的样式&lt;/dd&gt; &lt;dt&gt;JavaScript&lt;/dt&gt; &lt;dd&gt;脚本语言，控制网页的行为&lt;/dd&gt; &lt;/dl&gt; &lt;/body&gt; &lt;/html&gt; &lt;/!DOCTYPE&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6aabd48bd418f6382917c52bd40a877b/" rel="bookmark">
			紫微斗数算法的实现流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题外话 我想了又想大凡能够修炼成绝世高手的都是“魔鬼”。只有魔鬼才会纯粹的“敢贪，敢嗔，敢痴”。 你我都困在了敢字。程序猿拿起拿锋利的刀，解构世间的一切吧！最近看西游有感而发。
“联系是普遍存在的，规律是客观存在的”，那能不能用程序来解构命运的客观存在？那就来试试吧！
紫微斗数 紫微斗数，能够网上搜索出来的东西，在此不在啰嗦，简单来说就是可以算命。听起来好神秘，那我们一步步来，打怪通关。
排盘规则 排十二宫 不就是排十二个宫格子吗，先准备十二个格子，So easy! 有十二地支，有十二个宫位。为了快速通关，这里只讲解核心原理。
对应代码，提前把要用的十二格格准备好，以备不时之需。
/// &lt;summary&gt; /// 十二宫 /// &lt;/summary&gt; public readonly static string[] CONST_SHIERGONG = { "命宫", "兄弟", "夫妻", "子女", "财帛", "疾厄", "迁移", "交友", "官禄", "田宅", "福德", "父母" }; /// &lt;summary&gt; /// 天干 /// &lt;/summary&gt; public readonly static string[] CONST_TIANGAN = { "甲", "乙", "丙", "丁", "戊", "己", "庚", "辛", "壬", "癸" }; /// &lt;summary&gt; /// 地支 /// &lt;/summary&gt; public readonly static string[] CONST_DIZHI = { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6aabd48bd418f6382917c52bd40a877b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b0315fe342202c0a59eefcc1e7fd404/" rel="bookmark">
			对极约束及其性质 —— 公式详细推导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Title: 对极约束及其性质 —— 公式详细推导
文章目录 前言1. 对极约束 (Epipolar Constraint)2. 坐标转换 (Coordinate Transformations)3. 像素坐标 (Pixel Coordinates)4. 像素坐标转换 (Transformations of Pixel Coordinates)5. 本质矩阵 (Essential Matrix)6. 线坐标 (Coordinates of a Line)7. 对极线 (Epipolar Lines)8. 对极线的线坐标 (Coordinates of Epipolar Lines)9. 本质矩阵的零空间 (Null Space of a Essential Matrix)10. 本质矩阵的奇异值 (Singular Values of a Essential Matrix)总结参考文献 前言 参考学习资料 [1] (Carlo Tomasi, Epipolar Geometry and the Essential Matrix) 过程中, 对其坐标系描述存在疑问, 尝试自己推导了一下, 也补充了一些其他性质的推导.
形成了这篇博文, 以备忘.
1. 对极约束 (Epipolar Constraint) 对极几何就是描述两个相机之间的对极约束的几何[1], 如 Fig.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b0315fe342202c0a59eefcc1e7fd404/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a61c5039f0579d6ec731d237f13565e/" rel="bookmark">
			Nginx部署前端Vue项目的深度解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、准备工作
1.1 开发环境
1.2 服务器环境
1.3 Nginx安装
二、构建Vue项目
三、上传静态文件到服务器
四、配置Nginx
五、测试并重新加载Nginx
六、访问Vue应用
七、高级配置
7.1 启用HTTPS
7.2 启用Gzip压缩
7.3 缓存控制
八、常见问题与解决方案
8.1 404错误
8.2 权限问题
8.3 跨域问题
九、总结
在现代Web开发中，Vue.js因其组件化、响应式数据绑定和易于上手的特点，成为了前端开发者构建单页应用（SPA）的首选框架之一。而Nginx，作为一个高性能的HTTP和反向代理服务器，以其稳定性、丰富的功能集和低资源消耗，成为了部署前端Vue项目的理想选择。
一、准备工作 1.1 开发环境 首先，确保你的Vue项目已经在本地开发完成，并且能够通过npm run serve命令正常运行。Vue CLI工具会在本地启动一个开发服务器，通常监听在http://localhost:8080。然而，这个开发服务器并不适合用于生产环境，因为它没有提供足够的性能优化和安全性保障。
1.2 服务器环境 你需要一台安装了Linux（如Ubuntu或CentOS）的服务器，并确保Node.js和npm已经安装。虽然Node.js和npm在部署Vue项目到Nginx时不是必需的（因为Vue项目已经被打包成了静态文件），但它们对于在本地构建Vue项目是必要的。
1.3 Nginx安装 如果服务器上还没有安装Nginx，你可以通过操作系统的包管理器进行安装。以Ubuntu为例，可以使用以下命令：
sudo apt update sudo apt install nginx 安装完成后，你可以通过sudo systemctl status nginx命令检查Nginx是否成功启动。
二、构建Vue项目 在将Vue项目部署到Nginx之前，你需要先将其构建成静态文件。这通常通过运行Vue CLI提供的npm run build命令来完成。
npm run build 构建完成后，Vue CLI会在项目的根目录下生成一个dist文件夹，里面包含了所有用于生产环境的静态文件，如index.html、JavaScript、CSS和图像资源等。
三、上传静态文件到服务器 将dist文件夹中的所有文件上传到服务器的指定目录。你可以使用SCP、FTP或其他文件传输工具来完成这一步骤。假设我们将这些文件上传到/var/www/vue-app目录：
scp -r dist/* user@your-server-ip:/var/www/vue-app 四、配置Nginx 接下来，你需要编辑Nginx的配置文件，以便它能够正确地服务于你的Vue项目。Nginx的配置文件通常位于/etc/nginx/sites-available/目录下，你可以在该目录下创建一个新的配置文件，或者编辑默认的default文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a61c5039f0579d6ec731d237f13565e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/179077136e9d1e2fe78ae6707fe63725/" rel="bookmark">
			python环境中，pytorch、tensorflow、opencv 包的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知不足而奋进，望远山而前行
—— 24.9.6
tensorflow pip install -i https://pypi.tuna.tsinghua.edu.cn/simple tensorflow-gpu==1.13.1
pip install tensorflow -i https://pypi.tuna.tsinghua.edu.cn/simple
pytorch pip install torch==2.0.0+cu118 torchvision==0.15.1+cu118 torchaudio==2.0.1+cu118 -f https://download.pytorch.org/whl/torch_stable.html
opencv pip install -i https://pypi.tuna.tsinghua.edu.cn/simple opencv-python
在终端安装python解释器的目录下安装这三个包，然后在python中import导入
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9756f6539b5e2c952aa6e3b41d499f1f/" rel="bookmark">
			【LeetCode】：面试题 16.05. 阶乘尾数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 🎁个人主页：我们的五年
🔍系列专栏：C++课程学习
🎉欢迎大家点赞👍评论📝收藏⭐文章
好久没有写文章了，今天碰见了一道有趣的题目，写下来分享一下。
🏆1.问题描述： 🏆2.问题分析： 🎲优化一： 首先看到这道题的时候，暴力肯定是不行的，n的阶乘可能会是一个很大的数，肯定是会超过int，long long的范围的。
然后再去想其他的方法优化，n的阶乘：1*2*3*……*n。两个数相乘，尾部要新增0，这两个数的最低位的非0必须是（2*5）（4*5）（6*5）（8*5），从这里面可以看出全部都有 5，而且其他的是2的倍数，其实最重要的还是2*5，其他的相乘不会新增0。
一个2和一个5相乘就会在尾部新增一个 0。所以我们计算 1到n之间有个2和5，然后取2和5的最小的个数，就是最后尾部的0的个数。
比如：4*5*5*5=2*2*5*5*5
这里面有2个为2的因子，3个为5的因子，所以一共有2对（2,5）；最后尾部就有2个0。
🎲优化二： 如果根据上面的通过循环计算2和5的个数 ，这样的算法的时间复杂度肯定是要大于logn的，那就会发生时间超限。
然后我们必须在进行优化计算2和5的个数的算法。
我们先来看看不管n是多少，1~n之间，2的因子肯定是要&gt;=5的因子。
所以我们最后只要计算有多少个5，尾部就有多少个0。
🎬1.每五个数中，就有一个是5的倍数。这些都包含一个以上为5的因子。
n/5=n1。
🎬2.但是25有2个5，在25也是5的倍数，计算过一次5，这里也只需要计算一个。
n/25=n2。
🎬125中有3个5,125是5的倍数5的倍数的时候计算过一次，125是25的倍数，在25的时候也计算过一次。最后也只需要计算一次就可以了。
n/125=n3
……
直到计算超过n
最后n1+n2+n3……就是5的个数。
🏆3.实现代码： 一：
class Solution { public: int trailingZeroes(int n) { int num=0; while(n){ num+=n/5; n/=5; } return num; } }; 二：
class Solution { public: int trailingZeroes(int n) { int num=0; //最后面i*5的返回可能超过int long long i=5; for(;i&lt;=n;i*=5) { num+=n/i; } return num; } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e046a1b36f0a41ecac36e928ad66a385/" rel="bookmark">
			嵌入式软件--51单片机 DAY 4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、蜂鸣器 当电流通过线圈时会产生电磁场，电磁场与永磁体相互作用，从而使金属膜产生震动而发声。为使金属膜持续震动，蜂鸣器需要使用震荡电路进行驱动。有些蜂鸣器元件内部自带震荡驱动电路，这种蜂鸣器叫做有源蜂鸣器（Active Buzzer，自激式蜂鸣器）；而有些则不带震荡驱动电路，这种蜂鸣器叫做无源蜂鸣器（Passive Buzzer，它激式蜂鸣器）。
1.原理图 2.软件实现 Int_Buzzer.h
#ifndef __INT_BUZZER_H__ #define __INT_BUZZER_H__ #include &lt;STC89C5xRC.H&gt; #define BUZZ P46 /** * @brief 蜂鸣器响0.1s * */ void Int_Buzzer_Buzz(); #endif /* __INT_BUZZER_H__ */ Int_Buzzer.c
#include "Int_Buzzer.h" #include "Util.h" void Int_Buzzer_Buzz() { unsigned char counter = 100; while (counter) { BUZZ = ~BUZZ; Delay1ms(1); --counter; } } main.c #include "Int_DigitalTube.h" #include "Int_MatrixKey.h" #include "Int_Buzzer.h" int main() { u8 key_pressed = 0; Int_DigitalTube_Init(); Int_DigitalTube_DisplayNum(key_pressed); while (1) { key_pressed = Int_MatrixKey_CheckKey(); if (key_pressed) { Int_DigitalTube_DisplayNum(key_pressed); Int_Buzzer_Buzz(); //按键提示音 } Int_DigitalTube_Refresh(); } } 二、中断系统 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e046a1b36f0a41ecac36e928ad66a385/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76c001e5ef17e545276dab622483c100/" rel="bookmark">
			代码随想录：377. 组合总和 Ⅳ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 377. 组合总和 Ⅳ 这个题是求排列数量，（1，5）和（5，1）不一样，与组合数不同。
所以我们先遍历容量再遍历物品即可，而求组合数正好相反。
这里有可能中间计算数值略大，所以我们用unsigned int来开dp数组
class Solution { public: int combinationSum4(vector&lt;int&gt;&amp; nums, int target) { int n=nums.size(); unsigned int dp[2010]={0}; dp[0]=1; for(int j=1;j&lt;=target;j++) for(int i=0;i&lt;n;i++) if(j&gt;=nums[i])dp[j]+=dp[j-nums[i]]; return dp[target]; } }; 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/">«</a>
	<span class="pagination__item pagination__item--current">2/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/3/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>