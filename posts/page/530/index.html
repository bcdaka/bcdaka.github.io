<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/119a0f13fe8fa0b3410defa8c2576174/" rel="bookmark">
			Android APP开发集成微信登陆流程（手把手新手版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文比较适合新手玩家，老玩家就不要看了
昨天整了下微信登陆，乍一看官方文档还有点难懂！遂自己整理了下流程，给大家参考参考。
官方文档链接：准备工作 | 微信开放文档微信开发者平台文档https://developers.weixin.qq.com/doc/oplatform/Mobile_App/WeChat_Login/Development_Guide.html
第一步 ：申请应用AppID 申请地址：微信开放平台https://open.weixin.qq.com注意事项：包名和签名信息一定不能错，错了拉不起微信！应用通过审核了才能进行测试。
第二步：项目添加依赖 在app的build.grade文件里添加微信的依赖。至此，微信已经成功集成了
dependencies { //微信 implementation 'com.tencent.mm.opensdk:wechat-sdk-android-without-mta:+' } 第三步：请求调用微信登陆 在需要调用微信登陆的地方调用下面方法，参数【你的微信appid】换成你自己的，第一步注册的那个就是这个玩意。
private void wcLogin() { //发起登陆请求前先注册微信api IWXAPI api = WXAPIFactory.createWXAPI(this,“你的微信appid”,true); api.registerApp(“你的微信appid”); if (!api.isWXAppInstalled()){ //todo 提醒未安装微信 return; } //开始发起登陆请求 final SendAuth.Req req = new SendAuth.Req(); req.scope = "snsapi_userinfo"; req.state = "自定义state"; api.sendReq(req); } 第四步：创建微信回调的Activity Activity路径一定要为：你的包名+/wxapi/WXEntryActivity
例如我的包名是：com.aaa.bbb
那么回调activity的路径就是com.aaa.bbb.wxapi.WXEntryActivity
该Activity需要实现IWXAPIEventHandler的接口。
然后在注册文件AndroidManifest.xml中注册该Activity
&lt;activity android:name=".wxapi.WXEntryActivity" android:exported="true" android:launchMode="singleTask"&gt; &lt;meta-data android:name="android.app.lib_name" android:value="" /&gt; &lt;/activity&gt; exported属性一定要为true！另外注册文件AndroidManifest.xml中在权限下方添加安装包查询的请求权限，否则新版本无法检查出是否安装微信，直接拉不起来。
&lt;uses-permission android:name="android.permission.INTERNET" /&gt; &lt;!-- 方案2 --&gt; &lt;queries&gt; &lt;package android:name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/119a0f13fe8fa0b3410defa8c2576174/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd457cc3e2093f16ff83b58fce688d49/" rel="bookmark">
			【好书推荐-第四期】《Go专家编程（第2版）》华为资深技术专家力作，第1版评分9.4，适合Go程序员面试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😎 作者介绍：我是程序员洲洲，一个热爱写作的非著名程序员。CSDN全栈优质领域创作者、华为云博客社区云享专家、阿里云博客社区专家博主、前后端开发、人工智能研究生。公粽号：程序员洲洲。
🎈 本文专栏：本文收录于洲洲的《送书福利》系列专栏，该专栏福利多多，只需 关注+点赞+收藏 三连即可参与送书活动！欢迎大家关注本专栏~专栏一键跳转
🤓 同时欢迎大家关注其他专栏，我将分享Web前后端开发、人工智能、机器学习、深度学习从0到1系列文章。
🌼 同时洲洲已经建立了程序员技术交流群，如果您感兴趣，可以私信我加入我的社群~社群中将不定时分享各类福利
🖥 随时欢迎您跟我沟通，一起交流，一起成长、进步！点此即可获得联系方式~
本文目录 一、推荐书籍：《Go专家编程（第2版）》二、内容介绍三、抽奖方式总结 一、推荐书籍：《Go专家编程（第2版）》 各位友友，今天给大家推荐的书籍是电子工业出版社的《Go专家编程（第2版）》，京东购书链接：https://item.jd.com/13710415.html，本书是华为资深技术专家力作，第1版评分9.4，适合Go程序员面试。
Go语言是由Google公司开源的一门编程语言，虽然历史只有10余年（2012年发布1.0版本），但在多个领域尤其是云计算领域得到了快速及广泛的使用。相对于C语言这种底层系统语言，Go语言增加了自动垃圾回收、协程、接口等现代语言中常见的高级特性，而相对于Java、Python等应用开发语言，Go语言移除或弱化了类、元编程、Lambda表达式等高级特性。Go语言因此兼备了系统级语言所需要的“轻快灵”，以及应用级语言所需要的“低门槛、高生产力”。Go语言非常适合用于云服务开发、应用服务端开发，以及在通用Linux上的部分嵌入式系统开发。
Go语言的快速发展也离不开开源社区的支持。Go语言自开源起就引发了大量开发者的关注，并且基于Go语言诞生了大批知名的开源项目，其中最引人瞩目的无疑是Kubernetes、Docker，以及托管在CNCF（云原生计算基金会）旗下的大批云原生开源项目。 Go语言也因此被称为“云基础设施语言”，谷歌的Go产品负责人更是称Go语言为“云的语言”。
在笔者所在的华为公司，Go语言被作为公司级的五种指定编程语言之一（其他四种为C、C++、Java、Python），并且在华为云云原生产品研发部门被作为首选编程语言。华为云目前有30多款云服务产品是以Go语言为主力编程语言的，并且基于Go语言制定了公司级的编程规范，以及生产级高可靠、高安全、高性能的可信编程要求。本书内容也源自笔者团队在Kubernetes、Docker等云原生开源社区，以及华为云多款云原生服务产品中的实际生产级经验总结。
二、内容介绍 本书深入地讲解了Go语言常见特性的内部机制和实现方式，大部分内容源自对Go源码的分析，并从中提炼出实现原理。通过阅读本书，读者可以快速、轻松地了解Go语言的内部运作机制。
本书首先介绍常见数据结构及控制结构的实现原理，包括管道、切片、Hash表、select和for-range等，这部分内容大都以几个精心准备的测验题目开头，每个测验题目均对应一个知识点，读者借此可以测验自身对该知识点的掌握程度。接着介绍了Go语言最核心的概念，包括协程的概念、协程调度模型、协程调度策略，以及内存分配和垃圾回收相关的内容。本书还介绍了测试、泛型、依赖管理等比较实用的特性。最后结合笔者的见闻，整理了一些发生在真实项目中的编程陷阱。
作者也是非常厉害的华为技术专家：任洪彩。
华为云原生开源团队成员，CNCF（云原生计算基金会）官方大使，Kubernetes、Karmada等项目的资深维护者。
华为员工培训中心讲师，负责Go语言培训及软件工程能力建设。在Nokia、华为等公司参与过多个大型项目的研发与重构，对Go、C/C++、Python、Swift等语言均有深入的研究与实践。
同时本书也对第一版的书籍进行了如下修订：
三、抽奖方式 抽奖送书老规矩（不点赞收藏中奖无效）：注意记得关注博主及时获取中奖通知。
1. 点赞+收藏 文章 2. 评论区留言：我要成为架构师（留言才能进入奖池，每人最多留言三条） 3. 2024年1月20日-即本周6晚 八点随机抽奖5人 4. 京东自营购买链接：https://item.jd.com/13710415.html 总结 Hello，各位看官老爷们好，洲洲已经建立了CSDN技术交流群，如果你很感兴趣，可以私信我加入我的社群。
📝社群中不定时会有很多活动，例如每周都会包邮免费送一些技术书籍及精美礼品、学习资料分享、大厂面经分享、技术讨论、行业大佬创业杂谈等等。
📝社群方向很多，相关领域有Web全栈（前后端）、人工智能、机器学习、自媒体变现、前沿科技文章分享、论文精读等等。
📝不管你是多新手的小白，都欢迎你加入社群中讨论、聊天、分享，加速助力你成为下一个技术大佬！也随时欢迎您跟我沟通，一起交流，一起成长。变现、进步、技术、资料、项目、你想要的这里都会有
📝网络的风口只会越来越大，风浪越大，鱼越贵！欢迎您加入社群~一个人可以或许可以走的很快，但一群人将走的更远！
📝关注我的公众号（与CSDN同ID：程序员洲洲）可以获得一份Java 10万字面试宝典及相关资料！~
📝想都是问题，做都是答案！行动起来吧！欢迎评论区or后台与我沟通交流，也欢迎您点击下方的链接直接加入到我的交流社群！~ 跳转链接社区~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/526dad2d4f5e721f63334dc10ea24ec5/" rel="bookmark">
			【SpringBoot3】Spring Boot 3.0 介绍以及新特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Spring Boot 3.01、介绍2、Spring Boot 核心概念3、Spring Boot 3.0 新特性 二、Spring Boot Starter1、介绍2、Starter 命名规则3、官方提供了哪些Starter 三、spring-boot-starter-parent 说明四、示例：创建web项目参考 一、Spring Boot 3.0 1、介绍 Spring Boot 3.0 是 Spring Boot 框架的一个重要版本，它在保持了 Spring Boot 的一贯优点的同时，也进行了一些重要的改进和更新。
首先，Spring Boot 3.0 对 Java 版本的要求进行了更新。这个版本要求使用 Java 17 作为最低版本，以利用最新的语言特性和性能改进。如果你正在使用的是 Java 8 或 Java 11，则需要先升级 JDK 版本，然后再开发 Spring Boot 3.0 应用程序。
其次，Spring Boot 3.0 对 Spring Framework 的版本也进行了更新。这个版本要求使用 Spring Framework 6.0.2 或更高版本。Spring Framework 的新版本进行了一些特性的改进，包括 WebFlux 的改进、更好的性能和可扩展性。
此外，Spring Boot 3.0 还进行了一些非功能特性的改进，例如对嵌入式服务器、安全、度量、健康检查和外部化配置等特性的支持。这些改进可以帮助开发者更方便地构建和管理应用程序。
另外，Spring Boot 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/526dad2d4f5e721f63334dc10ea24ec5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d905c62caccc20a3a2ef426f71a0130a/" rel="bookmark">
			前端下载文件流，设置返回值类型responseType:‘blob‘无效的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 本是一个非常简单的请求，即是下载文件。通常的做法如下：
1.前端通过Vue Axios向后端请求，同时在请求中设置响应体为Blob格式。
2.后端相应前端的请求，同时返回Blob格式的文件给到前端（如果没有步骤1设置响应体，则后端返回的是一个文件流，前端）
3.前端创建a标签进行下载
提示：如果后端返回的是文件的地址，那么前端可以直接通过window.location.href加文件路径即可下载文件。但是如果后台返回的是文件流，那么前端就需要做一些处理。处理的核心也是将文件流转成文件，然后使用a标签模拟点击下载。
找出问题 &amp;&amp; 解决问题 我遇到的问题也是我想写篇文章记录一下的原因，因为下载文件这样的需求我都写烂了都，觉得这是得心应手的事情，在跟后端对接的时候，我非常坚定是后台返回流有问题（后面打脸了...）
这里我贴上我下载文件实现代码：
1.请求API
重点设置： responseType: 'blob' 2.封装的异步请求
3.调用接口，拿到返回值，模拟超链接点击下载文件
以上步骤似乎感觉是妥妥的了，但是我在自测的时候，一整个人蒙住，文件直接是打不开
然后我看控制台的输出，一看，不对劲啊，经过转换应该返回正常的blob格式才对，却是如下：
正式因为如此，导致下载下来的是一个无效的文件。
然后开始进一步的排查，代码都被我看烂了，也没看出来哪里会不对劲，各种百度也都试了，就是没有发现有什么问题。最后也是很突然的，我看到有个博主的文章，真的起到醍醐灌顶的作用，文章其中一句“mock模块会影响原生的ajax请求，使得服务器返回的blob类型变成乱码”，我才惊愕，因为我在项目中却是用到了mock，打开控制台发现，mockjs初始化的时候给拦截响应设置了responseType:''，证据如下：
终于找到原因了，同时把mock注释掉就可以了。真的是怎么也没有想到是mock模块影响了，可是花了好长一段时间去排查这个问题呢，解决了就好呀！！
下面是正常后拿到的数据格式：
优化 tip：我们可以把模拟a标签下载文件这个逻辑封装起来，如果后面又下载文件的需求的时候，可以直接拿来用即可。
1.封装：获取文件流转成文件，并模拟点击该文件，实现下载
​​​​​​​
2.使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e0a1960c3dc9144a833bd47ce3c1009/" rel="bookmark">
			MacOS系统 安装ZooKeeper 和常见问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装ZooKeeper 和 常见问题 一、安装和启动二、常见问题和解决2.1 配置文件在哪？2.2 安装路径在哪？2.3 如果不想后台运行zookeeper，用完就关，省资源，可以的！2.4 启动时，报错2.4 启动/停止使用 zkServer 可以吗？ 可以 ZooKeeper 是一个分布式的开源协调服务，用于构建分布式应用程序。
使用 Homebrew 安装，如果没有的话，强烈推荐 Homebrew，安装命令参考如下：
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" 一、安装和启动 安装 ZooKeeper：
brew install zookeeper 启动 ZooKeeper 服务：
brew services start zookeeper 停止 ZooKeeper 服务 ：
brew services stop zookeeper 测试 ZooKeeper 是否正常启动 ：
zkCli 二、常见问题和解决 2.1 配置文件在哪？ 使用 Homebrew 安装，一般会在 /usr/local/etc/zookeeper/zoo.cfg。
2.2 安装路径在哪？ 使用 Homebrew 安装，可以通过命令查询：
brew info zookeeper 2.3 如果不想后台运行zookeeper，用完就关，省资源，可以的！ 参考上图，不用自己记住命令的！
SERVER_JVMFLAGS="-Dapple.awt.UIElement=true" /usr/local/opt/zookeeper/bin/zkServer start-foreground 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e0a1960c3dc9144a833bd47ce3c1009/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4443e2911dbd7698243812135c863295/" rel="bookmark">
			python 集合的详细用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当前版本：
Python 3.8.4 简介
Python中的集合是一种无序、可哈希的且不重复的数据类型，用于存储唯一的元素。集合的实现基于哈希表，因此在插入、查找和删除元素时具有高效性能。集合的每个元素都必须是不可变的，可以是数字、字符串、元组等。
文章目录如下
1. 如何定义集合
集合都有哪些特点呢？
集合的定义方法
2. 集合的操作
2.1. 添加元素
2.2. 删除元素
2.3. 修改元素
2.4. 访问元素
2.5. 统计元素
2.6. 成员检查
3. 集合的运算
3.1. 并集运算
3.2. 交集运算
3.3. 差集运算
3.4. 对称差集
1. 如何定义集合 在python中，一般通过花括号或set来定义一个集合，例如
S = set() # 定义一个空的集合 使用花括号定义一个有数据的集合
S = {1} 注意：由于定义集合的符号与字典一致，所以当定义一个空的花括号会被识别为字典，而不是集合
集合都有哪些特点呢？ 集合中的元素是唯一的，重复的元素会被自动忽略。集合是无序的，元素没有固定的位置。集合中的元素必须是可哈希的，因此，只能包含不可变对象，如数字、字符串、元组等。集合支持常用的集合操作，如并集、交集、差集等。 集合的定义方法 我们一般使用花括号来定义一个集合，当集合中存在多个数据时，使用逗号将其分割，而这些数据被称为元素。
S = {"元素1", "元素2", "元素3"} 这些元素可以是数字、字符串、元组等
S = {1.1, "AA", ("X", "Y")} 由于集合中的元素必须是可哈希的（hashable）。
可哈希的对象是指在其生命周期内其哈希值不变的对象，例如数字、字符串、元组等。 如列表、字典是不可哈希的对象（指在其生命周期中可能发生变化的对象）是无法定义到集合中
虽然不能定义到集合中，但是可以将列表转换为集合
L = [1, 2, 3] S = set(L) 由于集合其中一个特性是不可重复，这也就意味着将某个列表元素去重时，可以利用集合来实现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4443e2911dbd7698243812135c863295/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44746d6069b8aa2dd60a2db29cc508e9/" rel="bookmark">
			图像识别技术的发展历程：从传统算法到深度学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景介绍 图像识别技术是人工智能领域的一个重要分支，它旨在自动识别和分析图像中的对象、特征和场景。图像识别技术在许多应用中发挥着重要作用，例如自动驾驶、医疗诊断、物流管理、安全监控等。随着计算机视觉技术的不断发展，图像识别技术也不断进化，从传统算法逐渐向深度学习转变。
在本文中，我们将从传统算法的起源和发展，到深度学习的兴起和发展，梳理图像识别技术的发展历程。同时，我们还将深入探讨图像识别技术的核心概念、算法原理、具体操作步骤以及数学模型，并通过具体代码实例进行详细解释。最后，我们将讨论图像识别技术的未来发展趋势与挑战。
2.核心概念与联系 在图像识别技术中，核心概念主要包括：
图像处理：图像处理是指对图像进行预处理、增强、分割、特征提取等操作，以提高图像识别的准确性和效率。
特征提取：特征提取是指从图像中提取出与对象相关的特征信息，以便于对象识别。
模式识别：模式识别是指根据特征信息判断图像中的对象，并将其与已知对象进行比较和匹配。
深度学习：深度学习是一种基于人工神经网络的机器学习方法，它可以自动学习特征并进行模式识别，从而实现图像识别的目标。
这些概念之间的联系如下：图像处理是对图像进行预处理、增强、分割等操作，以提高图像识别的准确性和效率；特征提取是在图像处理后提取出与对象相关的特征信息；模式识别是根据特征信息判断图像中的对象，并将其与已知对象进行比较和匹配；深度学习则是一种自动学习特征并进行模式识别的方法。
3.核心算法原理和具体操作步骤以及数学模型公式详细讲解 3.1 传统算法 传统图像识别算法主要包括：
灰度图像处理：灰度图像处理是指将彩色图像转换为灰度图像，以简化图像识别过程。
边缘检测：边缘检测是指从图像中提取出对象的边缘信息，以便于对象识别。
形状描述：形状描述是指从图像中提取出对象的形状特征信息，以便于对象识别。
模板匹配：模板匹配是指将一张图像与另一张图像进行比较，以判断图像中的对象。
支持向量机(SVM)：SVM是一种基于最大间隔的分类方法，它可以用于图像识别任务。
3.1.1 灰度图像处理 灰度图像处理的核心算法原理是将彩色图像转换为灰度图像，以简化图像识别过程。灰度图像处理的具体操作步骤如下：
读取彩色图像。将彩色图像转换为灰度图像，即将RGB三个通道的值相加，得到一个灰度值。对灰度图像进行预处理，如噪声去除、锐化等。对灰度图像进行增强，如对比度调整、直方图均衡化等。对灰度图像进行分割，以提取出目标对象。 3.1.2 边缘检测 边缘检测的核心算法原理是从图像中提取出对象的边缘信息，以便于对象识别。边缘检测的具体操作步骤如下：
读取灰度图像。对灰度图像进行滤波，以消除噪声。对灰度图像进行梯度计算，以得到梯度图像。对梯度图像进行非极大值抑制，以消除梯度噪声。对非极大值抑制后的梯度图像进行连通域分析，以提取出边缘。 3.1.3 形状描述 形状描述的核心算法原理是从图像中提取出对象的形状特征信息，以便于对象识别。形状描述的具体操作步骤如下：
读取边缘图像。对边缘图像进行连通域分析，以提取出目标对象。计算目标对象的几何特征，如面积、周长、形状因子等。对几何特征进行特征提取，以便于对象识别。 3.1.4 模板匹配 模板匹配的核心算法原理是将一张图像与另一张图像进行比较，以判断图像中的对象。模板匹配的具体操作步骤如下：
读取图像和模板。对图像和模板进行灰度处理。对图像和模板进行边缘检测。使用相关或非相关匹配方法，比较图像和模板之间的相似度。根据相似度判断图像中的对象。 3.1.5 支持向量机(SVM) SVM的核心算法原理是基于最大间隔的分类方法，它可以用于图像识别任务。SVM的具体操作步骤如下：
读取图像数据集。对图像数据进行预处理，如灰度处理、边缘检测等。对预处理后的图像数据进行特征提取，以便于对象识别。使用SVM算法进行分类，以判断图像中的对象。 3.2 深度学习 深度学习的核心算法原理是基于人工神经网络的机器学习方法，它可以自动学习特征并进行模式识别，从而实现图像识别的目标。深度学习的具体操作步骤如下：
读取图像数据集。对图像数据进行预处理，如灰度处理、边缘检测等。使用卷积神经网络(CNN)或其他深度学习模型进行特征学习。使用深度学习模型进行模式识别，以判断图像中的对象。 3.2.1 卷积神经网络(CNN) CNN的核心算法原理是基于卷积和池化操作的神经网络结构，它可以自动学习特征并进行模式识别，从而实现图像识别的目标。CNN的具体操作步骤如下：
读取图像数据集。对图像数据进行预处理，如灰度处理、边缘检测等。使用卷积层学习图像的特征信息。使用池化层减少特征维度，以提高模型的鲁棒性。使用全连接层进行分类，以判断图像中的对象。 3.2.2 数学模型公式 CNN的数学模型公式主要包括卷积、池化、激活函数和损失函数等。
卷积公式： $$ y(x,y) = \sum{i=0}^{k-1}\sum{j=0}^{k-1}w(i,j)x(x+i,y+j) + b $$
池化公式： $$ y(x,y) = \max(x(x,y),x(x+1,y),x(x,y+1),x(x+1,y+1)) $$
激活函数： $$ f(x) = \frac{1}{1+e^{-x}} $$
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44746d6069b8aa2dd60a2db29cc508e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da751891835716254082e6919779b952/" rel="bookmark">
			Python Socketio 介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		socketio是一个Python库，用于处理实时网络通信，它实现了Socket.IO协议。Socket.IO是一个JavaScript库，用于实时、双向和基于事件的通信。它在浏览器和服务器之间建立一个持久的连接，允许它们进行实时通信。
socketio.Client()是socketio库中的一个类，用于创建一个Socket.IO客户端。这个客户端可以连接到一个Socket.IO服务器，并与其进行实时通信。
socketio.Client()的一些主要方法和事件： **connect(url, kwargs): 这个方法用于连接到一个Socket.IO服务器。你需要提供服务器的URL。你还可以提供一些可选的关键字参数，如transports（指定连接使用的协议类型）。
emit(event, data): 这个方法用于发送一个事件到服务器。你需要提供事件的名称和要发送的数据。
on(event): 这个装饰器用于定义一个事件处理器。当客户端收到指定的事件时，它会调用相应的事件处理器。
disconnect(): 这个方法用于断开与服务器的连接。
以下是一个简单的例子，展示了如何使用socketio.Client()：
import socketio sio = socketio.Client() @sio.event def connect(): print("I'm connected!") @sio.event def disconnect(): print("I'm disconnected!") sio.connect('http://localhost:5000') sio.emit('my event', {'data': 'Hello, world!'}) sio.disconnect() 我们首先创建了一个socketio.Client()实例。然后，我们定义了两个事件处理器：一个用于处理connect事件，另一个用于处理disconnect事件。然后，我们连接到服务器，发送一个名为my event的事件，然后断开连接。
socketio 库中的一些主要方法： socketio.Client(): 这是一个类，用于创建一个新的Socket.IO客户端实例。
**sio.connect(url, kwargs): 这个方法用于连接到一个Socket.IO服务器。你需要提供服务器的URL。你还可以提供一些可选的关键字参数，如transports（指定连接使用的协议类型）。
sio.emit(event, data): 这个方法用于发送一个事件到服务器。你需要提供事件的名称和要发送的数据。
sio.disconnect(): 这个方法用于断开与服务器的连接。
sio.on(event, handler): 这个方法用于注册一个事件处理器。当客户端收到指定的事件时，它会调用相应的事件处理器。例如，你可以使用 sio.on('message', message_handler) 来注册一个处理 'message' 事件的处理器。
sio.wait(): 这个方法会阻塞当前线程，直到客户端断开连接。这对于需要保持连接的应用（如聊天应用、实时游戏等）非常有用。
**sio.start_background_task(target, *args, kwargs): 这个方法用于启动一个后台任务。这对于需要在后台运行的长时间任务非常有用。
sio.sleep(seconds): 这个方法会暂停当前线程指定的秒数。这对于需要在发送事件之间添加延迟的情况非常有用。
sio.event: 这是一个装饰器，用于定义一个事件处理器。当客户端收到指定的事件时，它会调用相应的事件处理器。例如，你可以使用 @sio.event 来定义一个处理 'connect' 事件的处理器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da751891835716254082e6919779b952/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a07542bd021a4cb5cbac5cbb10591e7d/" rel="bookmark">
			毕业设计：python商品销售数据采集分析可视化系统 京东商品数据爬取&#43;可视化 大数据 python（源码）✅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍅大家好，今天给大家分享一个Python项目，感兴趣的可以先收藏起来，点赞、关注不迷路!🍅
大家在毕设选题，项目以及论文编写等相关问题都可以给我留言咨询，希望帮助同学们顺利毕业 。 1、项目介绍 技术栈：
Python语言、Flask框架、Vue框架、requests爬虫、Echarts可视化、MySQL数据库、HTML
使用爬虫爬取京东商品信息数据，对数据进行清洗、存储、分析展示
使用爬虫爬取[京东商品信息]数据，对数据进行清洗、存储、分析展示，应用Python爬虫、Flask框架、Vue、Echarts等技术实现。此系统适用于目标网站任何类型的商品分析。
2、项目界面 （1）商品价格可视化分析
（2）商品价格区间分析
（3）商品数据信息
（4）店铺评分排名
（5）平均价格排名
（6）商品评论分析
（7）后台数据管理
3、项目说明 （1）介绍 使用爬虫爬取[京东商品信息]数据，对数据进行清洗、存储、分析展示，应用Python爬虫、Flask框架、Vue、Echarts等技术实现。此系统适用于目标网站任何类型的商品分析。
（2）系统功能 1、数据概览 ​ 使用爬虫爬取京东商品数据后，将数据在此模块进行展示。所有爬虫在文章后面进行介绍
​ 搜索：输入商品标题，可对商品进行模糊查询
​ 获取评论：管理员功能,点击此按钮调用获取评论爬虫，开始获取对应商品的评论信息，默认爬5页，可在程序中修改爬取页数
​ 获取店铺信息：管理员功能，点击此按钮调用获取店铺信息爬虫，获取该商品对应店铺的信息，包括店铺星级、店铺评分等
​ 详情：点击详情按钮，跳转到商品详情页面
​ 店铺：点击按钮，跳转到店铺页面
2、商品价格排名 ​ 将所有商品的价格进行排序，使用echarts柱状图从高到低展示前20条数据。支持按照店铺查询店内商品排名
​ 搜索：选择店铺（可以输入）后点击搜索，查询该店铺所有商品排名
3、店铺星级排名 ​ 对已获取信息的店铺星级进行排序，使用echarts折线图进行展示。
4、店铺评分排名 ​ 对已获取信息的店铺评分进行排序，可分别展示商品评分，物流评分和售后评分。
5、店铺均价排名 ​ 计算所有店铺的商品均价，使用echarts折线图从高到低展示前20条数据。
6、评论分析 ​ 展示评论信息的词云图和评分占比，使用词云和饼状图实现。可根据条件展示不同的结果
​ 店铺空、商品空：展示所有数据的评论信息词云，以及评分占比
​ 店铺不空、商品空：展示该店铺的评论信息词云，以及评分占比
​ 店铺不空、商品不空：展示该商品的评论信息词云，以及评分占比
7、个人信息 ​ 用户查看个人信息，输入新的信息点击提交，可更新个人信息
9、修改密码 ​ 输入原密码与新密码，可修改密码
10、登录注册 ​ 用户登录注册
11、用户管理 ​ 该功能是管理员功能，管理用户信息
​ 新增：点击新增按钮，输入用户信息，可添加新用户
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a07542bd021a4cb5cbac5cbb10591e7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ec22649bf08c1e271fefe5b7c954e71/" rel="bookmark">
			轻松掌握Java增删改查（CRUD）操作的代码示例！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在Java开发中，CRUD操作是基础且必不可少的一部分。本文将带您通过具体的代码示例，轻松学习如何使用Java实现增加、删除、修改和查询功能。
代码实现 1. 增加（Create）：插入新数据 import java.sql.*; ​ public class InsertExample { public static void main(String[] args) { // 建立数据库连接 Connection connection = null; Statement statement = null; try { Class.forName("com.mysql.jdbc.Driver"); connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/mydatabase", "username", "password"); statement = connection.createStatement(); ​ // 准备插入数据的SQL语句 String sql = "INSERT INTO employees (id, name, age) VALUES (1, 'John Doe', 30)"; statement.executeUpdate(sql); ​ System.out.println("Data inserted successfully!"); ​ } catch (ClassNotFoundException | SQLException e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ec22649bf08c1e271fefe5b7c954e71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/801050bca007b6d64b14774d1771f261/" rel="bookmark">
			关于postgresql 报错there is no unique or exclusion constraint matching the ON CONFLICT specification
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.场景：执行upsret语句时报错there is no unique or exclusion constraint matching the ON CONFLICT specification
2.解决方法:找到CONFLICT 语句约束的条件，将其增加唯一约束，如果是id则主键，这次的问题是id主键被删除。
3.sql语句:
INSERT INTO 表名 (id, 字段) VALUES ($1, $2) ON CONFLICT (id) DO UPDATE SET 字段= XXX RETURNING id 4.解释：CONFLICT表示冲突，用于upsert操作，这种写法跟update，insert的区别就是当执行 INSERT 操作时，如果数据表中不存在对应的记录，PostgreSQL 将会执行插入操作，否则将会更新这条数据，就无须在代码里面先去查询某条语句是否存在。
CONFLICT约束的值必须是唯一的，如果不唯一将会报错。
RETURNING id 表示此次查询将返回id。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34c8cd933d931b5a46c82fad31ec8ebd/" rel="bookmark">
			Kafka 清空Topic
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、背景 测试环境某topic的数据格式发生了更改，需要将原有数据清空重新生产数据。
2、操作 2.1 检查当前topic的配置 [root@localhost ~]# /export/server/kafka/bin/kafka-configs.sh --zookeeper x.x.x.x:2181 --entity-type topics --entity-name topicName --describe 还需检查当前kafka topic对应的分区副本（假定单分区单副本）大小，用于验证数据是否已删除。
[root@localhost ~]# du -sh /export/server/kafka/logs/kafka/topicName-0 68M /export/server/kafka/logs/kafka/topicName-0 2.2 添加数据过期时间配置 将过期时间设置为1秒
[root@localhost ~]# /export/server/kafka/bin/kafka-configs.sh --zookeeper x.x.x.x:2181 --entity-type topics --entity-name topicName --alter --add-config retention.ms=1000 2.3 检查数据已删除 [root@localhost ~]# du -sh /export/server/kafka/logs/kafka/topicName-0 直到该文件夹显示大小是20K即证明数据已清理
同时需注意，数据清理时机受server.properties中log.retention.check.interval.ms配置控制，比如我的配置是5分钟：300000，那么最长需要等5分钟才能看到结果。
2.4 删除过期时间配置 [root@localhost ~]# /export/server/kafka/bin/kafka-configs.sh --zookeeper x.x.x.x:2181 --entity-type topics --entity-name topicName --alter --delete-config retention.ms 此配置一定要删除，否则后续数据可能没被消费就被删掉啦。
3、借鉴内容 Kafka——管理Kafka(命令行工具)详解
这篇博客详细写了kafka管理脚本的实际使用，我测了几个都是正确的，大家有兴趣的可以验证。
不过最好是官网阅读哈：
kafka-配置
kafka-操作
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/518b75fb1dcab6b16feda277cea7d75d/" rel="bookmark">
			2024年人工智能顶会/顶刊截稿时间汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人工智能顶会/顶刊汇总 ，方便查阅，持续更新，若有错误烦请大家及时提出！
一、CCF A类 简称 全称录用率频次内容官网截稿日期IJCAIInternational Joint Conference on Artificial Intelligence2020年12.55%，2021年13.9%，2022年14.97%。每年一次 1.IJCAI主要接收人工智能领域的论文，包括但不限于机器学习、计算机视觉、自然语言处理、智能机器人、智能控制、专家系统等方面的论文。具体而言，IJCAI接收的论文主题涵盖了人工智能基础理论、智能算法与技术、机器学习与数据挖掘、自然语言处理、智能人机交互、智能感知与识别、智能机器人、智能信息处理与应用等领域。
2.IJCAI注重接收创新性强、理论和实践结合的论文，对于有创新点、有深度的工作更为青睐。同时，IJCAI也重视论文的学术规范和质量控制，要求论文具有高度的规范性和严谨性。
ijcai24.org/ 投稿截稿日期：2024/1/17
录用通知日期：2024/4/16
ICML International Conference on Machine Learning
（国际机器学习会议）
2022年21.9%，2023年27.94%。两年一次ICML主要接收机器学习领域的论文，包括但不限于深度学习、强化学习、监督学习、无监督学习、半监督学习、在线学习、集成学习、生成对抗网络、自适应学习、贝叶斯方法等。ICML 2024 截稿日期：2024/2/1
录用通知日期：2024/5/1
ACL Association for Computational Linguistics
（国际计算语言学协会）
2022年不到25%每年一次ACL主要接收自然语言处理领域的论文，包括语音识别、文本分析、机器翻译、对话系统、信息检索、信息抽取、情感分析等方向。https://www.aclweb.org/ 截稿日期：2024 年 2 月 15 日
审稿结果：2024 年 4 月 15 日
录用通知：2024 年 5 月 15 日
ICCVInternational Conference on Computer Vision(国际计算机视觉大会)2022年26.8%，2023年26.77%两年一次ICCV主要接收计算机视觉领域的论文，包括图像处理、图像分析、图像理解、机器学习、人工智能等方面的内容。该会议注重接收关于理论和实践相结合的研究成果，旨在推动计算机视觉领域的发展和应用。https://iccv2023.org/CVPRIEEE Conference on Computer Vision and Pattern Recognition(国际计算机视觉与模式识别会议)2022年25%，2023年25.78%两年一次CVPR主要接收计算机视觉和模式识别领域的论文，包括图像处理、图像分析、图像理解、机器学习、人工智能等方面的内容。该会议注重接收关于理论和实践相结合的研究成果，旨在推动计算机视觉和模式识别领域的发展和应用。CVPR 2024 截稿日期：2023/11/18
录用通知日期：2024/2/27
NeurIPSConference and Workshop on Neural Information Processing Systems（神经信息处理系统会议）2022年25.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/518b75fb1dcab6b16feda277cea7d75d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bf3d32b02023aba3e095b3391723729/" rel="bookmark">
			Python数据分析案例32——财经新闻爬虫和可视化分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		案例背景 很多同学的课程作业都是需要自己爬虫数据然后进行分析，这里提供一个财经新闻的爬虫案例供学习。本案例的全部数据和代码获取可以参考：财经新闻数据
数据来源 新浪财经的新闻网，说实话，他这个网站做成这样就是用来爬虫的...
代码实现 首先导入包
import requests from bs4 import BeautifulSoup import pandas as pd import numpy as np import matplotlib.pyplot as plt import seaborn as sns from collections import Counter from wordcloud import WordCloud import jieba ,re import chardet plt.rcParams ['font.sans-serif'] ='SimHei' #显示中文 plt.rcParams ['axes.unicode_minus']=False #显示负号 爬虫获取数据：
#定义爬取函数 def crawl_sina_finance_reports(pages=100): base_url = "https://stock.finance.sina.com.cn/stock/go.php/vReport_List/kind/lastest/index.phtml" reports = [] headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bf3d32b02023aba3e095b3391723729/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/040182ee393f015149dfedc02ea6f28b/" rel="bookmark">
			python AES 加密解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简述python中常用于AES加密解密的库AES常用加密模式及填充方式使用pycrypto加密解密实例使用pycryptodome加密解密实例 简述 AES（Advanced Encryption Standard）是一种对称加密算法，常用于保护敏感数据的机密性。它采用了替代算法（substitution）和置换算法（permutation）的组合，使用相同的密钥对数据进行加密和解密。
python中常用于AES加密解密的库 在Python中，有几个常用的库可用于进行AES加密和解密。以下是其中一些常见的库：
cryptography：这是一个功能强大且易于使用的加密库，支持多种对称和非对称加密算法，包括AES。它提供了高级的加密原语和密码学操作，适用于各种加密需求。
pycryptodome：这是一个功能齐全的密码学库，是PyCrypto库的一个分支，提供了对称和非对称加密算法的实现，包括AES。它具有广泛的功能，并且在实现中经过了广泛的测试和使用。
cryptography.io：这是一个基于cryptography库的高级加密工具包，提供了易于使用的高级加密功能。它支持多种加密模式和填充方案，并提供了更高级别的API，简化了加密和解密操作。
pycrypto：这是一个古老的密码学库，提供了对称和非对称加密算法的实现，包括AES。尽管该库不再维护，但在一些旧的项目中仍然被广泛使用。
AES常用加密模式及填充方式 在AES中，常用的加密模式（mode）和填充（padding）方式如下：
加密模式（Mode of Operation）：
ECB（Electronic Codebook）：最简单的模式，将每个分组独立加密，没有使用IV（Initialization Vector）。CBC（Cipher Block Chaining）：使用前一个分组的密文与当前分组的明文进行异或操作，引入了IV以增加随机性。CFB（Cipher Feedback）：将前一个密文块作为密钥加密当前明文块，再将得到的密文与明文进行异或操作。OFB（Output Feedback）：类似于CFB模式，但使用的是一个可变的非密钥变量，称为反馈变量（feedback variable）。CTR（Counter）：使用一个计数器和密钥生成密钥流，然后将密钥流与明文进行异或操作得到密文。 填充方式（Padding）：
PKCS#7（或PKCS#5）：使用合适的字节填充明文，填充字节的值为缺少的字节数。Zero Padding：在明文末尾添加零字节，直到满足块大小的要求。ANSI X.923：在明文末尾添加零字节，并在最后一个字节处写入填充长度。ISO 10126：在明文末尾添加随机生成的字节，并在最后一个字节处写入填充长度。 选择加密模式和填充方式需要根据具体的安全需求和应用场景来决定。需要注意的是，ECB模式由于没有引入IV和每个分组独立加密的特性，会带来一些安全性问题，因此在实际应用中，推荐使用更安全的模式（如CBC、CTR等）并配合适当的填充方式。
使用pycrypto加密解密实例 from Crypto.Cipher import AES def encrypt(key, mode, text): # 创建一个AES加密器/解密器对象 cryptor = AES.new(key.encode('utf-8'), mode, key.encode('utf-8')) block_size = AES.block_size # 进行零字节填充 padding_length = block_size - (len(text) % block_size) padded_text = text + b'\0' * padding_length # ---------------------------------------- # 除了零字节填充也可以使用PKCS#7填充 # padding_length = block_size - (len(text) % block_size) # padded_text = text + padding_length.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/040182ee393f015149dfedc02ea6f28b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6375110eea4817059071c190dd9bbf20/" rel="bookmark">
			spring boot学习第六篇:SpringBoot 集成WebSocket详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、WebSocket概述 1、WebSocket简介 WebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。
2、为什么需要WebSocket HTTP 是基于请求响应式的，即通信只能由客户端发起，服务端做出响应，无状态，无连接。
无状态：每次连接只处理一个请求，请求结束后断开连接。
无连接：对于事务处理没有记忆能力，服务器不知道客户端是什么状态。
通过HTTP实现即时通讯，只能是页面轮询向服务器发出请求，服务器返回查询结果。轮询的效率低，非常浪费资源，因为必须不停连接，或者 HTTP 连接始终打开。
WebSocket的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话。
WebSocket特点：
（1）建立在 TCP 协议之上，服务器端的实现比较容易。
（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。
（3）数据格式比较轻量，性能开销小，通信高效。
（4）可以发送文本，也可以发送二进制数据。
（5）没有同源限制，客户端可以与任意服务器通信。
（6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。
二、SpringBoot整合WebSocket 创建 SpringBoot项目，引入 WebSocket依赖，前端这里比较简陋。
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;version&gt;2.7.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;version&gt;2.7.12&lt;/version&gt; &lt;/dependency&gt; application.yml：
server: port: 8081 spring: thymeleaf: mode: HTML cache: true prefix: classpath:/templates/ encoding: UTF-8 suffix: .html check-template-location: true template-resolver-order: 1 1、WebSocketConfig 启用 WebSocket的支持也是很简单。
/** * WebSocket配置类。开启WebSocket的支持 */ @Configuration public class WebSocketConfig { /** * bean注册：会自动扫描带有@ServerEndpoint注解声明的Websocket Endpoint(端点)，注册成为Websocket bean。 * 要注意，如果项目使用外置的servlet容器，而不是直接使用springboot内置容器的话，就不要注入ServerEndpointExporter，因为它将由容器自己提供和管理。 */ @Bean public ServerEndpointExporter serverEndpointExporter() { return new ServerEndpointExporter(); } } 2、WebSocketServer
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6375110eea4817059071c190dd9bbf20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f34506b4989c896cd6da5c2b0af3da6a/" rel="bookmark">
			Android Installed Build Tools revision 34.0.0 is corrupted. Remove and install again using the SDK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 ERROR: Installed Build Tools revision 34.0.0 is corrupted. Remove and install again using the SDK Manager.
错误：已安装的生成工具修订版34.0.0已损坏。使用SDK管理器删除并重新安装。
上面提示看似简单 只需要 重新卸载 再下载Build Tools34.0.0就行了
但实际上并不行
降低版本 降低 Build Tools revision 实测不行 行也是治标不治本 解决方案 通过查资料 自己测试下面方法可行
这个android build tools 版本你用哪个都可以 但是需要修改文件名字
比如我用的版本号是 34.0.0 打开你的SDK目录
第一步： 在你的 android sdk 安卓目录中找到 build tools 目录中的 d8.bat，将文件名修改为dx.bat 第二步：找到 build tools 目录中的 lib 文件夹里面的d8.jar，将文件名修改为dx.jar 还有一种是复制方案 比如你找个低于30版本的build tools
第一步：将android sdk/build-tools/28.0.3/dx.bat 复制一份 android sdk/build-tools/34.0.0/dx.bat 第二步： 将android sdk/build-tools/28.0.3/lib/dx.bat 复制一份 android sdk/build-tools/34.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f34506b4989c896cd6da5c2b0af3da6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e6c54f56865316e2c03c3c3a236ee5e/" rel="bookmark">
			python安卓开发——kivy打包安卓APK逐步教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前偶尔接触到了python开发app的工具kivy（也能开发windows/linux/mac应用），然后发现网上教程极少，甚至第一步打包apk就劝退了很多人，我也踩了很多坑，最后还是一一解决了，这里写个博文记录下。
我选择用buidlozer打包apk，主要参考官方文档：https://buildozer.readthedocs.io/en/latest/installation.html
从文档上看，这个工具主要是在linux和macos上用，我这边主要用windows，所以我选择用虚拟机来搭建打包环境。
整个搭建过程录频传到b站上了，供参考python安卓开发——kivy打包安卓APK逐步教学
一、准备linux环境和相关工具 这里直接VMware+Ubuntu20.04解决环境问题，这一有个坑，一定要用18以上的ubuntu，否则可能因为openssl版本导致后续步骤失败。如何安装虚拟机和在虚拟机上安装系统就不赘述了，一般按照安装引导就ok。
安装完成后为了后续方便使用，建议安装以下两个工具：
openssl-server（linux）+Mobaxterm（windows）。ssh登录linux，方便windows下贴命令，否则的话需要安装vmware-tools，但是感觉这个不太好用。另外也可以通过这个来在虚拟机和windows间传输文件。这个配置也简单，直接sudo apt install openssl-server即可samba。linux上配置samba方便共享文件，这样windows可以直接添加网络位置，可以方便地在windows上编辑文件并在linux编译运行。可参考博文【详细步骤】Ubuntu安装Samba服务及配置共享文件夹进行配置 二、准备python环境 官方文档说的需要3.8以上版本，因此我也就直接用3.8了。
为了后续方便，还是用conda来管理python环境，我这里用的miniconda，因为文件要小一些，所需要的功能也都有。
conda create -n kivy python=3.8 source activate kivy pip install kivy 然后把我们在windows下写的程序传到虚拟机里面，代码是一段简单的demo如下，python ./main验证ok
from kivy.app import App from kivy.uix.button import Button class TestApp(App): def build(self): return Button(text='iPaoMi') TestApp().run() 三、buildozer打包apk 在工程目录下，执行以下命令
3.1 初始化 在工程目录下执行buildozer init，会生成一个.spec配置文件，内容可以自己看看，包括App名称等，这里我也没有仔细研究。
3.2 buildozer -v android debug 接下来是个巨坑，官方文档上说明是执行buildozer -v android debug，如果你是初次运行，就可以去泡一杯咖啡了。因为这个过程中会自动下载SDK/NDK等内容。
然后第一个坑就来了，如果你是ubuntu16，那么大概跑了十几分钟后会失败，提示ssl之类的错误。
其实这里并不需要魔法，可以正常下载，原因就在ubuntu的ssl版本。
SDK里面用的python3.10.10，要求openssl版本大于1.1.1
如果你愿意折腾，可以试试升级一下是否能解决这个问题，但我建议直接用ubuntu20.04，按官方文档来。
然后是第二个坑，如果下载过程中网络波动导致失败，重新尝试下载时，会提示文件已存在，或者是某某工具找不到
因为之前下载未完成但是可能文件已经存在，这将影响工具对下载状态的判断，需要删除工程目录下的.buildozer文件夹和用户目录下的.buildozer文件夹
然后是第三个坑，下了十几分钟文件后，有一个文件无法下载，看域名确实是需要魔法才能下载，但是这并不意味着我们需要这个文件
重新执行之前的命令，发现没有出现前面的问题，开始正式编译了，最终生成目录bin，并在其下能找到apk文件。
四、验证 这里没有像官方文档中建议那样直接用USB调试，而是简单的将APK文件拖入安卓模拟器验证，执行ok。
后续修改代码内容重新编译，大约只需要半分钟即可打包完成。也就是第一次使用比较困难。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88a5e31580471ad45c6d32a9c8b5e690/" rel="bookmark">
			Springboot利用CompletableFuture异步执行线程（有回调和无回调）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
背景
实现
一、异步线程配置类
二、自定义异步异常统一处理类
三、实现调用异步（无回调-runAsync()）
四、实现调用异步（有回调-supplyAsync()） 五、异步执行错误异常示例
背景 项目中总会有需要异步执行来避免浪费时间资源的情况，这就需要异步操作。异步又分两种：
1、无回调：有一些执行过程对用户而言不需要反馈回调，只需要自己执行即可，且执行过程时间较长（某些第三方接口，如发送短信验证码、查取ip属地等等），如果同步执行，势必会影响到用户体验，这时候就可以使用CompletableFuture.runAsync()方法了。
2、有回调：在执行异步操作结束后，需要获得异步方法返回的值，然后再回调给用户展示，这时候就需要用到CompletableFuture.supplyAsync()方法了。
实现 一、异步线程配置类 /** * 异步线程配置类 */ @EnableAsync @Configuration public class AsyncConfig implements AsyncConfigurer { @Override public Executor getAsyncExecutor() { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); // 设置核心线程数 executor.setCorePoolSize(8); // 设置最大线程数 executor.setMaxPoolSize(20); // 设置队列大小 executor.setQueueCapacity(Integer.MAX_VALUE); // 设置线程活跃时间(秒) executor.setKeepAliveSeconds(60); // 设置线程名前缀+分组名称 executor.setThreadNamePrefix("AsyncOperationThread-"); executor.setThreadGroupName("AsyncOperationGroup"); // 所有任务结束后关闭线程池 executor.setWaitForTasksToCompleteOnShutdown(true); // 初始化 executor.initialize(); return executor; } /** * 自定义异步异常 * @return */ @Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() { return new AsyncException(); } } 二、自定义异步异常统一处理类 /** * 异步请求异常错误 */ public class AsyncException implements AsyncUncaughtExceptionHandler { @Override public void handleUncaughtException(Throwable throwable, Method method, Object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88a5e31580471ad45c6d32a9c8b5e690/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ac4f71b7c00f7a3791b1613699bcbf3/" rel="bookmark">
			万元预算打造高质量13B私有模型，Colossal-AI LLaMA-2 开源方案再升级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		几个月前，Colossal-AI 团队仅利用8.5B token数据、15小时、数千元的训练成本，成功构建了性能卓越的中文LLaMA-2 7B 版本模型，在多个评测榜单性能优越。
在原有训练方案的基础上，Colossal-AI 团队再次迭代，并通过构建更为细致完善的数据体系，利用 25B token 的数据，打造了效果更佳的 13B 模型，并开源相关权重。
开源代码与权重：https://github.com/hpcaitech/ColossalAI
性能表现 注：基于ColossalEval评分，括号中分数来源于对应模型官方发布的榜单分数，C-Eval 分数来源于官网 Leaderboard。
在英文 MMLU 榜单中，Colossal-LLaMA-2-13B-base 在低成本增量预训练的加持下，英文效果稳中有升。在 GSM8k 的评估中发现，英文数学与推理能力有了显著的提升（31.31 -&gt; 58.83），在所有 13B 的模型中，表现优异。
在中文榜单中，我们主要对比了 CMMLU, AGIEVAL, GAOKAO 与 C-Eval，效果远超基于 LLaMA-2 的其他中文汉化模型。即使与其他采用中文语料，可能花费上千万元成本，从头预训练的各大知名模型相比，Colossal-LLaMA-2在同规模下仍表现抢眼。尤其是与原始 LLaMA-2 相比，在中文能力上有了质的飞跃 (CMMLU: 38.14 -&gt; 61.8)。
从整个训练的 Loss 记录来看，在利用 Colossal-AI 系统降本增效能力的同时，模型收敛性也得到充分保证，仅通过约 25 B tokens（250 亿 tokens），数万元算力成本，让模型达到如此惊艳的效果。而市面上的大模型动辄使用几万亿token进行训练才有效果保证，成本高昂。
数据构建 为了更大程度地降低训练的成本，高质量的数据在其中起着关键作用，尤其是对于增量预训练，对于数据的质量，分布都有着极高的要求。在训练 7B 版本的过程中，为了更好地筛选高质量的数据，Colossal-AI 团队构建了完整的数据清洗体系与工具包，以便筛选更为高质量的数据用于增量预训练。
相比于 7B 版本，在此次训练 13B 版本过程中，Colossal-AI 团队构建了更为完善的数据体系，将数据划分为知识性数据，功能性数据，与记忆回放数据。其中，将知识性数据划分为十几个大类，包括金融，法律，教育等；每个大类又划分为不同的小类，从而对不同类型的数据进行更为精准的调控。同时增加了不同垂类数据的规模，以确保基座模型本身对于不同领域数据的掌握程度都有一定的提升。
而为应对社区对于大模型功能性的需求，我们针对于不同的自然语言处理任务，进行针对性提升，以确保模型在预训练阶段就对常见自然语言处理任务有一定的了解与掌握，如常见的文本摘要，信息抽取能力，以及复杂问题的思维链理解能力。
另外，记忆回放类数据是激发模型对于所见知识掌握程度的关键步骤与数据组成，该数据有效提升了模型整体的表现能力与泛化能力。
除此之外，针对于日益关注的安全性与价值观问题，Colossal-AI 团队进行了多维度（政治敏感，宗教敏感，辱骂仇恨，偏见歧视，违法犯罪，身体伤害，心理健康，财产隐私，道德伦理等）的提升，以确保基座模型更为强大的安全性与价值观正确。
低成本高质量模型构建 经过以上多维度数据的构建以及对基座模型自然语言基础能力的提升，Colossal-AI 团队打造出性能更强的 13B 版本模型。基于此方案，社区用户可在微调阶段可以借助更少量的，高质量的微调数据，更少的成本，打造属于自己的微调模型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ac4f71b7c00f7a3791b1613699bcbf3/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/529/">«</a>
	<span class="pagination__item pagination__item--current">530/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/531/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>