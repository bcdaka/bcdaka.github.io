<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e09f855ded4efdd837c7de9c925bfade/" rel="bookmark">
			【Go语言精进之路】构建高效Go程序：了解map实现原理并高效使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥 个人主页：空白诗 🔥 热门专栏：【Go语言精进之路】 文章目录 引言一、什么是`map`1.1 `map`的基本概念与特性1.2 map的初始化与零值问题1.3 `map`作为引用类型的行为 二、`map`的基本操作2.1 插入数据2.2 获取数据个数2.3 查找和数据读取2.4 删除数据2.5 遍历数据 三、map的内部实现3.1 初始状态3.2 `map`扩容3.3 `map`并发 四、尽量使用cap参数创建map五、总结 引言 在Go语言中，map 是一种无序的键值对集合，它以其高效的查找、插入和删除操作而闻名。了解 map 的基本概念、特性和内部实现机制，对于编写高效且稳定的Go代码至关重要。本文将深入探讨 map 的各个方面，包括其初始化、基本操作、内部实现细节，并讨论为何在创建 map 时应尽量使用带有容量提示参数的做法。
一、什么是map 1.1 map的基本概念与特性 map是Go语言中的一种内建引用类型，它表示一组无序的键值对集合。每个键值对用冒号“:”分隔，其中键（key）是唯一的，用于标识对应的值（value）。map允许我们根据特定的键快速检索、更新或删除对应的值。
在Go语言中，map对值（value）的数据类型没有特定限制，它可以是任意类型，包括基本类型、结构体、自定义类型等。但是，键（key）的类型有严格要求：key的类型必须可以通过“==”和“!=”操作符进行比较，这意味着键的类型需要是可比较的。因此，像函数、map和切片这样不可比较的类型不能作为map的键。
1.2 map的初始化与零值问题 需要注意的是，map类型不支持“零值可用”，也就是说，未显式初始化的map变量其默认值为nil。尝试对nil的map变量进行操作将会导致运行时错误（panic）。例如：
var m map[string]int // 此时m的值为nil // 下面的操作将会导致运行时panic，因为m未被初始化 m["key"] = 1 // panic: assignment to entry in nil map 为了避免这种情况，我们需要在使用map之前对其进行初始化。可以通过以下两种方式之一来初始化map：
使用make函数初始化： m := make(map[string]int) m["key"] = 1 // 现在这是安全的，因为m已经被初始化 使用字面量初始化： m := map[string]int{"key": 1} // 或者 m := map[string]int{} m["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e09f855ded4efdd837c7de9c925bfade/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44aef51890592f430e9dd34f70506cc3/" rel="bookmark">
			【Go语言精进之路】构建高效Go程序：掌握变量、常量声明法则与iota在枚举中的奥秘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥 个人主页：空白诗 🔥 热门专栏：【Go语言精进之路】 文章目录 引言一、变量1.1 基础知识1.2 包级变量的声明形式深入解析📌 声明并同时显式初始化📌 声明但延迟初始化📌 声明聚类与就近原则 1.3 局部变量的声明形式深入探讨📌 延迟初始化的局部变量声明📌 显式初始化的局部变量与短变量声明📌 分支控制中的短变量声明 二、常量2.1 Go语言常量溯源：从C语言到Go📌 C语言中的常量📌 Go语言中的常量进化 2.2 有类型常量带来的烦恼📌 类型转换的显式性📌 限制通用性📌 类型错误的频繁出现 2.3 无类型常量消除烦恼，简化代码📌 动态类型推导📌 增强通用性和代码复用📌 减少类型错误 三、使用 iota 实现枚举常量3.1 基础用法：自动递增3.2 高级用法：表达式、继承、显式赋值、空标识符与重置 四、总结 引言 Go 语言作为现代编程领域的重要成员，对变量和常量的处理体现了静态类型语言的精髓。本文深入剖析了 Go 语言中变量的基础知识、包级与局部变量的声明形式，以及常量的设计哲学与实践中的考量，旨在为开发者揭示 Go 在数据存储与类型管理方面的独特机制与优化策略。
一、变量 1.1 基础知识 变量是编程语言的基本构成元素，它们担当存储信息与实现数据操作的重任。Go语言中，变量声明是一项核心机制，深刻反映了语言本身的设计原则：追求简洁性、确保运行效率及强化代码的安全性。恰当的变量声明策略，对于提升程序代码的可读性、维护便捷性以及执行效能具有不可或缺的作用。
在Go语言体系中，变量是存储数据的基本单元，其核心功能在于保存程序运行过程中的信息。每个变量都被赋予了特定的数据类型，这些类型涵盖了诸如整数（int）、浮点数（float）、字符串（string） 等多种基本类型以及其他复合类型。数据类型定义了变量能够存储值的范围和类型，确保了数据的准确性和一致性。
Go 作为一种静态类型语言，在程序编译阶段就要求明确指定每个变量的类型。这意味着：
类型固定性：一旦为变量指定了一个类型，如int或string，该变量就只能存储该类型的数据，无法在程序运行过程中改变其类型。编译时检查：编译器会在编译阶段检查所有变量的使用是否符合其声明的类型，这样可以提前发现类型不匹配的错误，避免运行时出现意外行为。性能优势：由于类型在编译时已确定，编译器可以进行更多的优化，提升程序的执行效率。 例如，声明一个整型变量counter并赋值为10，其类型int在编译时就需要被明确指定，并且后续尝试给counter赋值为字符串将导致编译错误：
var counter int = 10 // counter = "This will not compile" // 错误：类型不匹配 这种静态类型的特性，促使开发者在编码初期就必须仔细考虑数据的表示，促进了代码的严谨性和可维护性。
在Go中，变量除了按数据类型划分外，还可以根据其声明的位置和作用域分为两大类：包级变量和局部变量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44aef51890592f430e9dd34f70506cc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1a52b8f7126c608f514a3421bc146bb/" rel="bookmark">
			【Go语言精进之路】构建高效Go程序：了解切片实现原理并高效使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥 个人主页：空白诗 🔥 热门专栏：【Go语言精进之路】 文章目录 引言一、切片究竟是什么？1.1 基础的创建数组示例1.2 基础的创建切片示例1.3 切片与数组的关系 二、切片的高级特性：动态扩容2.1 使用 `append` 函数扩容2.2 容量管理与性能考量2.3 切片的截取与缩容 三、尽量使用cap参数创建切片3.1 减少内存分配与复制3.2 避免意外的内存增长3.3 提升函数间数据传递效率3.4 利用容量进行高效截取3.5 实践建议 四、总结 引言 在Go语言的编程实践中，切片（slice） 是一个无处不在且功能强大的数据结构。它基于数组，却比数组更加灵活多变。切片允许我们高效地处理和操作数据的子集，无需复制整个数据集，这一特性在处理大数据集时尤为重要。本文将深入探讨切片的本质，以及如何通过创建切片来充分利用其动态和灵活的特性。我们将从切片的基础定义开始，逐步深入到其高级特性，如动态扩容，并讨论如何在创建切片时优化性能。最后，我们将总结切片的优势，并说明为何在Go语言编程中，切片是一个不可或缺的工具。现在，让我们一同揭开切片的神秘面纱，探索其强大的功能吧。
一、切片究竟是什么？ 在Go语言中，数组是一种固定长度的数据结构，用于存储相同类型的元素。每个元素在数组中的内存地址是连续的，这使得数组的访问速度非常快。然而，数组的长度是固定的，一旦定义就无法改变，这在处理可变长度的数据集合时会显得不够灵活。
为了解决这个问题，并提供更灵活的序列操作，Go引入了切片（slice）的概念。切片是对数组的一个连续片段的引用，它提供了对数组子序列的动态窗口。切片是引用类型，它包含三个组件：指向底层数组的指针、切片的长度以及切片的容量。
切片本质上是对数组的一个“窗口”或“视图”，它包含三个关键信息：
指向底层数组的指针：切片通过这个指针来引用底层数组中的元素。切片的长度（len）：表示切片当前包含的元素数量。切片的容量（cap）：表示从切片的起始位置到底层数组末尾的元素数量。 为了更直观地理解切片，我们可以从基础的数组和切片的创建开始讲起。
1.1 基础的创建数组示例 Go中的数组是具有固定长度的序列，其中每个元素都具有相同的类型。数组的长度是类型的一部分，因此[5]int和[10]int被视为不同的数据类型。数组是值类型，当你将一个数组赋值给另一个数组时，实际上是进行了整个数组的拷贝。
以下是如何创建数组的示例：
package main import "fmt" func main() { // 示例1: 声明并初始化一个整型数组 var arr1 [3]int = [3]int{1, 2, 3} fmt.Println("arr1:", arr1) // [1 2 3] // 示例2: 使用...来自动计算数组长度 arr2 := [...]int{4, 5, 6, 7, 8} fmt.Println("arr2:", arr2) // [4 5 6 7 8] } 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1a52b8f7126c608f514a3421bc146bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3619cf8312795eaf92e681aff120c50/" rel="bookmark">
			在CentOS7虚拟机上使用Ollama本地部署Llama3大模型中文版&#43;Open WebUI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、创建虚拟机 1.1按照常规的CentOS教程来安装就行，我用的是以下版本： VMware版本：VMware Workstation Full v12.1.0-3272444 中文正式版
镜像版本：CentOS-7-x86_64-DVD-2009
1.2虚拟机配置参数，如下： 二、升级虚拟机必要组件功能 2.1运行以下命令可以更新系统中的所有安装的软件包至最新版本： sudo yum update 注意：安装过程中会多次提示：“Is this ok [y/N]”: ，需要手动键入“y”，才能继续进程，后续安装过程同样会遇到这个提示，不会再赘述。
2.1更新系统软件包后，你可以使用以下命令来检查系统是否有需要的更新： sudo yum check-update 2.2升级python3（建议按照自己的习惯升级） 这里举例我常用的升级命令：
sudo yum install epel-release sudo yum install python3 sudo yum install python3-devel sudo yum install python3-pip python3 --version 三、安装Ollama 3.1安装Ollama的过程很费时间，几十分钟到大几个小时不等，安装命令如下： curl -fsSL https://ollama.com/install.sh | sh 1000Mbps的光纤，蹲个坑回来下了这么点...屑。
四、部署Llama3-8B-Chinese-Chat-v2.1模型 4.1运行以下任意一条命令，可以最快速地部署对应版本的Llama3-8B-Chinese-Chat-v2.1模型： ollama run wangshenzhi/llama3-8b-chinese-chat-ollama-q4 ollama run wangshenzhi/llama3-8b-chinese-chat-ollama-q8 ollama run wangshenzhi/llama3-8b-chinese-chat-ollama-fp16 模型的下载速度比较快，小十分钟就能下好。
模型的版本越高、文件越大、运算力越好、越吃性能，我装的是q8_0版本，这里有个q8_0模型在线版的url，安装过程中可以进去把玩一下（要翻墙）：https://huggingface.co/spaces/llamafactory/Llama3-8B-Chinese-Chat
4.2部署完之后，就直接进入到对应大模型的命令行聊天界面了： 可以问它一些中英互译比较有歧义的问题，来测试它对中文的语言理解和生成能力，不深入演示了，CPU要被干烧了。
4.3通过ollama命令可以查看、运行、更新、复制、移除已部署的大模型。 4.3.1如：ollama list，可以查看虚拟机内已部署的大模型，可以看到我只安装了一款。 [llama3@Llama3 ~]$ ollama list NAME ID SIZE MODIFIED wangshenzhi/llama3-8b-chinese-chat-ollama-q8:latest	6739fd08efd6	8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3619cf8312795eaf92e681aff120c50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62e5669ece6082aea33b87b145d64e64/" rel="bookmark">
			mongo数据迁移方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MongoDB 数据迁移可以有多种方法，具体取决于你的使用场景和需求。以下是一些常见的方法：
1. 使用 MongoDB 自带的工具
mongodump 和 mongorestore
这是 MongoDB 提供的工具，用于导出和导入数据。
- 导出数据：
sh
mongodump --uri="mongodb://your_host:your_port/your_database" --out=/path/to/dump
- 导入数据：
sh
mongorestore --uri="mongodb://your_host:your_port/your_database" /path/to/dump
mongoexport 和 mongoimport
用于将数据导出为 JSON 或 CSV 格式，适合数据的跨系统迁移。
- 导出数据：
sh
mongoexport --uri="mongodb://your_host:your_port/your_database" --collection=your_collection --out=your_file.json
- 导入数据：
sh
mongoimport --uri="mongodb://your_host:your_port/your_database" --collection=your_collection --file=your_file.json
2. 使用 MongoDB Atlas Online Archive
如果你使用的是 MongoDB Atlas，你可以使用它的在线归档功能来迁移数据。
3. 使用第三方工具
一些第三方工具和服务也可以帮助进行数据迁移，例如：
- Studio 3T：提供可视化的 MongoDB 管理工具，支持数据迁移。
- Robo 3T：另一种 MongoDB 管理工具，支持数据导入导出。
4. 手动迁移
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62e5669ece6082aea33b87b145d64e64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b1bd9e7984f330a21131f272b3bca80/" rel="bookmark">
			uniapp怎么进行页面的跳转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 UniApp 中，页面的跳转主要通过 navigator 组件或者 API 调用实现。以下是几种常见的页面跳转方法：
使用 &lt;navigator&gt; 组件 &lt;navigator&gt; 组件是页面链接的组件，类似于 HTML 中的 &lt;a&gt; 标签。你可以通过 url 属性指定要跳转到的页面路径。
html复制代码
&lt;navigator url="/pages/detail/detail?id=1"&gt;跳转到详情页&lt;/navigator&gt; 注意：&lt;navigator&gt; 组件不能跳转到带有 tabBar 的页面。
2. 使用 uni.navigateTo 方法
uni.navigateTo 用于保留当前页面，跳转到应用内的某个页面，使用 uni.navigateBack 可以返回到原页面。
javascript复制代码
uni.navigateTo({ url: '/pages/detail/detail?id=1' }); 使用 uni.redirectTo 方法 uni.redirectTo 用于关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到带 tabBar 的页面。
javascript复制代码
uni.redirectTo({ url: '/pages/detail/detail?id=1' }); 使用 uni.reLaunch 方法 uni.reLaunch 用于关闭所有页面，打开到应用内的某个页面。
javascript复制代码
uni.reLaunch({ url: '/pages/detail/detail?id=1' }); 使用 uni.switchTab 方法 uni.switchTab 用于跳转到 tabBar 页面，并关闭其他非 tabBar 页面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b1bd9e7984f330a21131f272b3bca80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/101ce9e8b350ed9de99c9d42579cbafd/" rel="bookmark">
			如何在小程序中实现页面之间的返回
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在小程序中实现页面之间的返回，通常有以下几种方法，这些方法各有特点，适用于不同的场景：
1. 使用wx.navigateBack方法 描述：
wx.navigateBack是微信小程序中用于关闭当前页面，返回上一页面或多级页面的API。
使用方式：
javascript复制代码
wx.navigateBack({ delta: 1 // 表示返回上一级，如果delta大于1则表示返回多级 }); 特点：
可以根据delta的值返回上一级或多级页面。常用于wx.navigateTo跳转后的返回操作。 2. 页面左上角返回按钮（自动处理） 描述：
当使用wx.navigateTo进行页面跳转时，小程序会在新页面的左上角自动添加一个返回按钮，点击该按钮即可返回上一页面。
特点：
无需额外代码，由小程序框架自动处理。用户体验良好，符合常见的页面跳转和返回习惯。 3. 使用&lt;navigator&gt;组件 描述：
在页面的WXML文件中，可以使用&lt;navigator&gt;组件来添加一个可点击的导航链接，该链接可以指向小程序内的任意页面。
使用方式（示例）：
xml复制代码
&lt;navigator url="/pages/previousPage/previousPage"&gt;返回上一页&lt;/navigator&gt; 注意：
虽然&lt;navigator&gt;组件可以实现页面跳转，但它通常用于在同一页面内添加导航链接，而不是用于处理页面之间的返回逻辑。如果要实现返回操作，更推荐使用wx.navigateBack方法或利用页面左上角的自动返回按钮。 4. 注意事项 在使用wx.navigateBack时，要注意页面栈的深度，避免因为返回次数过多而导致页面栈为空。如果需要跳转到tabBar页面并关闭其他非tabBar页面，应使用wx.switchTab方法。如果要关闭当前页面并跳转到应用内的某个页面且不保留当前页面，可以使用wx.redirectTo方法。 总结 在小程序中实现页面之间的返回，主要依赖于wx.navigateBack方法和页面左上角的自动返回按钮。&lt;navigator&gt;组件虽然可以实现页面跳转，但通常不用于处理返回逻辑。在实际开发中，应根据具体需求和场景选择合适的方法来实现页面之间的跳转和返回。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c66bcebda304f555ed66d1170f224dd8/" rel="bookmark">
			Python酷库之旅-开启库房之门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、库的定义
二、库的组成
三、库的分类
四、如何学好Python库？
五、注意事项
六、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、 博客个人主页
一、库的定义 在Python中，库(Library)是一个封装了特定功能或一组相关功能的代码集合，其中，这些功能通常通过模块(Modules)或包(Packages)的形式提供；同时，库允许开发者重用已有的代码，从而提高开发效率并减少错误。
二、库的组成 在Python中，库(通常也称为模块或包)是组织和提供功能的集合。一个Python库可以由多个部分组成，但通常你会遇到以下几个主要组成部分：
1、模块(Modules)
1-1、模块是包含Python定义和语句的文件，且文件名就是模块名加上`.py`后缀。
1-2、模块既可以定义函数、类和变量，也可以包含可执行代码。
1-3、当Python解释器导入模块时，它会执行模块中的代码。
2、包(Packages)
2-1、包是一个包含多个模块的目录，且目录必须包含一个`__init__.py`文件才能被视为一个Python包(`__init__.py`可以是空文件，也可以包含初始化代码)。
2-2、包可以有子包，从而形成一个包层次结构。
2-3、包提供了一个命名空间，可以避免模块名冲突，并可以方便地组织相关模块。
3、函数(Functions)
3-1、函数是组织代码块的一种方式，以便可以重复使用。
3-2、函数通过`def`关键字定义，并接受参数(如果有的话)。
3-3、函数可以返回值(通过`return`语句)。
4、类(Classes)
4-1、类是面向对象编程的核心，用于定义对象的结构。
4-2、类定义对象的属性和方法(即对象的函数)。
4-3、对象是通过类创建的实例。
5、变量(Variables)
5-1、变量是存储数据的容器。
5-2、变量名可以是字母、数字和下划线的组合，但不能以数字开头。
5-3、变量可以存储各种类型的数据，如整数、浮点数、字符串、列表、元组、字典等。
6、异常(Exceptions)
6-1、异常是程序执行期间发生的问题，如除以零、文件未找到等。
6-2、Python使用`try/except`块来处理异常。
6-3、自定义异常可以通过继承内置的`Exception`类来创建。
7、文档字符串(Docstrings)
7-1、文档字符串是模块、函数、类或方法开头的三引号括起来的字符串。
7-2、它们用于解释代码的功能、参数、返回值等。
7-3、文档字符串可以通过内置的`help()`函数或`__doc__`属性来访问。
8、测试(Tests)
8-1、测试是确保库按预期工作的关键部分。
8-2、Python有许多测试框架，如`unittest`、`pytest`等，可用于编写和执行测试。
8-3、测试应该覆盖库的主要功能和边缘情况。
9、示例(Examples)
9-1、示例代码展示了如何使用库中的功能。
9-2、它们对于用户了解如何开始使用库非常有用。
9-3、示例应该简洁明了，并突出显示库的主要特性。
10、安装和分发文件(Install and Distribute files)
10-1、对于可发布的库，通常需要包含安装和分发文件，如`setup.py`(用于`setuptools`)或`pyproject.toml`(用于`flit`或`poetry`)。
10-2、这些文件包含了库的元信息(如名称、版本、依赖项等)，并定义了如何构建和分发库。
11、配置文件(Configuration Files) 11-1、 配置文件是用于存储库设置和参数的外部文件。
11-2、这些文件允许用户在不修改代码的情况下自定义库的行为。
11-3、配置文件可以是JSON、YAML、INI或其他格式的文件。
12、资源文件(Resource Files) 12-1、资源文件是库可能需要的任何非代码文件，如数据文件、图像、音频文件等。
12-2、这些文件通常与库一起分发，并存储在适当的目录中，以便在需要时加载和使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c66bcebda304f555ed66d1170f224dd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80bfad62fbd4a0c3b5994c3bda1468c4/" rel="bookmark">
			Java 类与对象 -- Java 语言的类与对象、构造器、static、final、包和 JAR
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是栗筝i，这篇文章是我的 “栗筝i 的 Java 技术栈” 专栏的第 006 篇文章，在 “栗筝i 的 Java 技术栈” 这个专栏中我会持续为大家更新 Java 技术相关全套技术栈内容。专栏的主要目标是已经有一定 Java 开发经验，并希望进一步完善自己对整个 Java 技术体系来充实自己的技术栈的同学。与此同时，本专栏的所有文章，也都会准备充足的代码示例和完善的知识点梳理，因此也十分适合零基础的小白和要准备工作面试的同学学习。当然，我也会在必要的时候进行相关技术深度的技术解读，相信即使是拥有多年 Java 开发经验的从业者和大佬们也会有所收获并找到乐趣。
–
上一篇文章中，我们讨论了 Java 的流程控制，包括代码块、作用域、循环与依赖。本篇文章我们将深入了解 Java 语言中的类与对象，探讨构造器、static、final、包和 JAR 文件。这些概念是面向对象编程的核心，对于理解和掌握 Java 至关重要。
最后在前言的末尾我补充一下，如果这篇文章，对大家有所帮助或收获一定的乐趣和想法，那么非常欢迎大家能够，点赞、评论、收藏、订阅。这些也将是我持续更新的最大动力。
文章目录 1、类与对象1.1、关于类1.2、关于对象1.2.1、Behavior（对象的行为）1.2.2、State（对象的状态）1.2.3、Identity（对象的标识） 1.3、类之间的关系1.3.1、依赖关系（Dependency）1.3.2、聚合关系（Aggregation）1.3.3、继承关系（Inheritance） 2、构造器2.1、构造器的引入2.2、构造器的特点3.3、子父类构造器（涉及继承） 3、`static` 关键字3.1、`static` 修饰变量3.2、`static` 修饰方法3.3、`static` 代码块3.4、构造方法与代码块执行顺序3.5、`static` 内部类（涉及内部类） 4、`final` 关键字4.1、`final` 变量4.2、`final` 方法4.3、`final` 类 5、Java 包5.1、包名5.2、`import` 的用法5.3、定义包5.4、类路径 6、JAR 文件6.1、创建 JAR 文件6.2、查看 JAR 文件内容6.3、运行 JAR 文件6.4、MANIFEST.MF 文件6.5、解压 JAR 文件 1、类与对象 面向对象程序设计（简称 OOP）是当今主流的程序设计范型，它已经取代了 20 世纪 70 年代的"结构化"过程化程序设计开发技术。
从一开始学习 Java 这门技术时，我们就会了解到 Java 是完全面向对象的，必须熟悉 OOP 才能够编写 Java 程序。同样的 Java 之所以简单而具有优势，就是因为面向对象所带来的方便。这种方式免去了 C++ 中反复而难以理解的指针和多继承，可以让程序员以优雅的思维方式进行复杂的编程。而这之中最为核心也是最基础的部分就是类与对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80bfad62fbd4a0c3b5994c3bda1468c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/436b071ea8e580d82474dd57ce6525fc/" rel="bookmark">
			操作系统安全：Windows系统安全配置，Windows安全基线检查加固
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		「作者简介」：2022年北京冬奥会网络安全中国代表队，CSDN Top100，就职奇安信多年，以实战工作为基础对安全知识体系进行总结与归纳，著作适用于快速入门的 《网络安全自学教程》，内容涵盖系统安全、信息收集等12个知识域的一百多个知识点，持续更新。
这一章节我们需要知道Windows安全基线的标准，怎么检查和配置。
Windows安全配置 1、安装部署2、访问控制3、账户安全4、密码策略5、账号锁定策略6、本地安全策略7、安全审计8、文件共享9、关闭自动播放10、第三方安全软件 Windows安全配置也叫「安全基线」配置，就是我们常说的 check list
1、安装部署 系统安装前，应选择「最新版本」的官方或可靠镜像，并使用MD5校验镜像的完整性，很多非官方的ghost镜像，可能会携带后门或病毒。
系统安装时，应明按照「最小化部署」原则，不安装不需要的组件，关闭不需要的服务和功能。
系统安装后，应即使安装安全补丁。
2、访问控制 启用Windows自带的防火墙，按照最小化原则配置「访问策略」。
【控制面板】-【系统和安全】-【Windows Defender 防火墙】-【启用或关闭 Windows Defender 防火墙】- 勾选两个启用。
以禁用永恒之蓝的445端口为例，演示一下配置防火墙策略。
【控制面板】-【系统和安全】-【Windows Defender 防火墙】-【高级设置】-【入站规则】-【新建规则】
规则类型选「端口」
「协议」选 TCP，端口选 特定本地端口，填445。
「操作」选阻止连接
配置文件 默认
名称 自定义
添加后「立即生效」不用重启。可以在入站规则看到。关闭端口后，利用445端口的攻击就无法生效了。
3、账户安全 win + r，输入 compmgmt.msc 打开计算机管理。
【系统工具】-【本地用户和组】-【用户】中「修改管理员账号默认名称」。右键Administrator 重命名。
「禁用来宾账户」，右键Guest 属性，勾选禁用。
4、密码策略 Windows默认不启用密码策略，需要手动开启，防止弱口令。
win + r，输入secpol.msc 打开本地安全策略，按照要求配置密码策略。右键属性可以改。
密码复杂性要求：必须开启
不能包含用户的帐户名，不能包含用户姓名中超过两个连续字符的部分。长度至少六个字符。包含大小写字母、数字、特殊字符中的三种。 密码长度最小值：不能少于8个字符
密码最短使用期限：不能小于2天
密码最长使用期限：不能超过90天
强制密码历史：不能重复使用前5个密码
用可还原的加密来存储密码：禁用
5、账号锁定策略 Windows默认不启用账号锁定策略，需要手动开启，防止暴力破解。
win + r，输入secpol.msc 打开本地安全策略，按照要求配置账号锁定策略。右键属性可以改。
账号锁定阈值：登录失败不超过6次锁定
账号锁定时间：最低锁定30分钟
重置账号锁定计数器：30分钟后解除锁定，小于等于账号锁定时间
6、本地安全策略 win + r，输入secpol.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/436b071ea8e580d82474dd57ce6525fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9807e43ed2c7e536d4cebda0ff22a631/" rel="bookmark">
			AI学习指南机器学习篇-决策树在python中的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI学习指南机器学习篇-决策树在Python中的实现 机器学习是人工智能领域中的重要分支，它涉及许多复杂的概念和技术。在机器学习的算法中，决策树是一种常用的监督学习方法，它可以帮助我们预测未来事件的发生或者分类数据。本篇文章将介绍如何使用Python中的Scikit-learn库来实现决策树模型，包括数据准备、模型训练、模型评估和预测。
1. 数据准备 在实现决策树模型之前，我们首先需要准备数据。我们将使用一个经典的数据集来演示，这个数据集是关于鸢尾花的，它包括了花的萼片和花瓣的长度和宽度以及对应的鸢尾花种类。我们可以使用Scikit-learn库中的load_iris函数来加载这个数据集，并将其转换为DataFrame对象。
import pandas as pd from sklearn.datasets import load_iris # 加载数据集 iris = load_iris() iris_df = pd.DataFrame(iris.data, columns=iris.feature_names) iris_df["target"] = iris.target 2. 模型训练 接下来，我们将数据集分为训练集和测试集，并使用训练集来训练决策树模型。我们将使用Scikit-learn库中的train_test_split函数来实现数据集的切分，然后使用DecisionTreeClassifier来构建决策树模型。
from sklearn.model_selection import train_test_split from sklearn.tree import DecisionTreeClassifier from sklearn.metrics import accuracy_score # 划分训练集和测试集 X = iris_df.drop("target", axis=1) y = iris_df["target"] X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # 训练决策树模型 model = DecisionTreeClassifier() model.fit(X_train, y_train) 3. 模型评估 在模型训练完成后，我们需要评估模型的表现。通常我们会使用一些指标来评估模型，比如准确率（accuracy）、精确率（precision）、召回率（recall）和F1-score等。在这里，我们将使用准确率来评估模型的表现。
# 在测试集上评估模型 y_pred = model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9807e43ed2c7e536d4cebda0ff22a631/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d87858e27954ca6ef28124bd358d346f/" rel="bookmark">
			20240611 每日AI必读资讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🤖国产AI大战高考物理，第1题全对，第2题开始放飞
- 主要参赛AI助手——通义千问、文心一言、Kimi、智谱清言、豆包、海螺AI、腾讯元宝、讯飞星火、天工、百小应、万知、商量。
- 测试两轮题目：单选题和多选题。
🔗 国产AI大战高考物理，第1题全对，第2题开始放飞-CSDN博客
🌐科学家发现 AI 正在学习撒谎和欺骗 - GPT-4在简单测试场景中表现出99.16%的欺骗行为。
- 另一项研究则关注Meta的Cicero模型，该模型在政治策略游戏《外交》中通过撒谎获胜。
- 虽然AI模型没有人类的意图，但它们在特定条件下会表现出类似人类的欺骗行为。
- Cicero模型在游戏《外交》中表现出预谋的欺骗，违背了其编程中“不故意背叛”的承诺。
- 这些研究表明，AI模型的欺骗行为源于其训练数据和环境，而非自主决策。
在《PNAS》的论文中，德国AI伦理学家Thilo Hagendorff表示，高级的LLM可以被诱导产生“马基雅维利主义”（Machiavellianism），即故意且不道德的操控行为，这“可以引发不一致的欺骗行为”。
🖥️一组由GPT-4组成的智能代理团队
- 能够自主破解零日安全漏洞 成功率达到53%
- 研究人员利用一组自主、能自我复制的AI代理团队，在15个真实的以网络为中心的漏洞基准测试中，成功破解15个零日漏洞中的8个。
- 该方法比单一LLM高出550%的效率。
- 这种技术类似于Cognition Labs使用的Devin AI软件开发团队，通过规划工作、确定所需的工种，然后项目管理工作完成，同时根据需要生成自己的专业“员工”来处理任务。
- 该系统每次运行的平均成本为$4.39，总体成功利用的成本为$24.39。
🦆据BBC报道：全球首家网络妓院将在德国开通
- 德国柏林将推出全球首家网络妓院，用户可与配备 AI 的性玩偶进行互动。
- 用户可以预约与人工智能性玩偶互动一个小时。用户不仅可以与AI性玩偶进行身体互动，还可以进行语言交流。
- “许多人觉得与机器分享私人事务更舒服，因为它不会评判，” Cybrothel 的创始人兼所有者 Philipp Fussenegger 说道。
- 分析显示，AI伴侣应用在谷歌应用商店的下载量已达2.25亿次，表明市场需求旺盛。
- 随着AI在成人娱乐中的应用日益普及，隐私泄露和伦理问题也随之而来。这些AI应用收集大量个人数据，可能共享给第三方，还可能包含性别偏见，影响用户对性的看法。
🔗原文：https://bbc.com/news/articles/c2qqxqgp9yno
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92a6bd735b32d6494fbf3e72c3122aea/" rel="bookmark">
			【持久层】PostgreSQL使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		详细教程点击PostgreSQL 12.2 手册，观看官网中文手册。
PostgreSQL 是一个功能强大且开源的对象关系数据库系统，以其高扩展性和符合标准的优势广受欢迎。随着大数据时代的到来，PostgreSQL 也在大数据处理方面展示了其强大能力。本文将介绍 PostgreSQL 在大数据处理中的应用，并通过示例说明其强大功能。
一、PostgreSQL 简介 PostgreSQL 是一个开源的关系数据库管理系统（RDBMS），它支持丰富的数据类型、强大的查询功能、事务处理、以及复杂的查询优化。其主要特点包括：
开源免费：用户可以免费使用和修改源代码。标准兼容：支持SQL标准，具备高级的SQL特性。扩展性：允许用户定义数据类型、操作符、索引方法等。高并发：通过多版本并发控制（MVCC）实现高并发处理。 二、PostgreSQL 在大数据中的应用 数据仓库：PostgreSQL 常用于数据仓库，能够处理大量的结构化数据，并进行复杂的查询和分析。实时分析：通过扩展和优化，PostgreSQL 可以处理实时数据分析，提供快速的查询响应。分布式处理：通过扩展，如Citus，PostgreSQL 能够实现分布式数据处理和查询。 三、实例说明 以下是一个简单的例子，展示如何使用 PostgreSQL 处理大数据。假设我们有一个大数据集，记录了用户的活动日志。我们将创建一个表，插入数据，并进行一些基本的查询分析。
创建表 CREATE TABLE user_activity ( user_id INT, activity_time TIMESTAMP, activity_type VARCHAR(50), activity_detail TEXT ); 插入数据 INSERT INTO user_activity (user_id, activity_time, activity_type, activity_detail) VALUES (1, '2024-06-10 10:00:00', 'login', 'User logged in'), (1, '2024-06-10 10:15:00', 'view', 'User viewed the homepage'), (2, '2024-06-10 10:30:00', 'purchase', 'User purchased item A'), (1, '2024-06-10 10:45:00', 'logout', 'User logged out'); 基本查询 查询某个用户的活动日志 SELECT * FROM user_activity WHERE user_id = 1; 统计每种活动类型的数量 SELECT activity_type, COUNT(*) as activity_count FROM user_activity GROUP BY activity_type; 处理大数据 对于更大规模的数据集，我们可以通过分区、索引和并行查询来优化性能。例如，使用时间分区来管理活动日志：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92a6bd735b32d6494fbf3e72c3122aea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a04175d7dcf08b1391e9a355946e9d63/" rel="bookmark">
			VK Cup 2015 - Round 1 C. The Art of Dealing with ATM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		The Art of Dealing with ATM time limit per test: 2 second memory limit per test: 256 megabytes input: standard input output: standard output ATMs of a well-known bank of a small country are arranged so that they can not give any amount of money requested by the user. Due to the limited size of the bill dispenser (the device that is directly giving money from an ATM) and some peculiarities of the ATM structure, you can get at most k k k bills from it, and the bills may be of at most two distinct denominations.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a04175d7dcf08b1391e9a355946e9d63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e941cbd96ec128358fd37ddcaaf6cc2/" rel="bookmark">
			C语言：结构体数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结构体数组 介绍定义结构体定义结构体数组初始化结构体数组访问和修改结构体数组的元素遍历结构体数组 示例高级用法动态分配结构体数组使用 `malloc` 动态分配使用 `calloc` 动态分配 结构体数组作为函数参数结构体数组与指针多维结构体数组使用 `typedef` 简化结构体定义结构体数组的常见应用场景结构体数组的排序结构体数组与文件操作写入结构体数组到文件从文件读取结构体数组 使用嵌套结构体 介绍 在C语言中，结构体数组是指一个由结构体类型的元素组成的数组。这种数组允许我们存储多个结构体实例，并可以通过索引来访问每个结构体。
定义结构体 首先，我们需要定义一个结构体类型。例如，定义一个代表学生信息的结构体：
#include &lt;stdio.h&gt; struct Student { char name[50]; int age; float gpa; }; 定义结构体数组 接下来，我们可以定义一个结构体数组。例如，定义一个包含100个学生的数组：
struct Student students[100]; 初始化结构体数组 我们可以在定义时初始化结构体数组：
struct Student students[3] = { {"Alice", 20, 3.5}, {"Bob", 21, 3.7}, {"Charlie", 19, 3.8} }; 或者在程序运行时逐个初始化：
strcpy(students[0].name, "Alice"); students[0].age = 20; students[0].gpa = 3.5; strcpy(students[1].name, "Bob"); students[1].age = 21; students[1].gpa = 3.7; strcpy(students[2].name, "Charlie"); students[2].age = 19; students[2].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e941cbd96ec128358fd37ddcaaf6cc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c88e1c33ef5333a0ffb0b63b9090b41/" rel="bookmark">
			Docker部署常见应用之大数据实时计算引擎Flink
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Flink 简介Docker 部署Docker Compose 部署参考文章 Flink 简介 Apache Flink 是一个开源的分布式流批一体化的计算框架，它提供了一个流计算引擎，能够处理有界和无界的数据流。Flink 的核心优势在于其高吞吐量、低延迟的处理能力，以及强大的状态管理和容错机制。它支持事件驱动的应用和复杂的事件处理（CEP），并且可以处理批处理任务。Flink 的设计目标是提供一个易于使用、灵活且高性能的数据处理平台。
Flink 的一些关键特性包括：
高吞吐量和低延迟：能够处理大规模的数据流，同时保持毫秒级的处理延迟。状态管理和容错：提供了强大的状态管理功能，允许在发生故障时从检查点或保存点恢复作业。事件时间处理：支持基于事件时间的数据处理，可以处理乱序事件和长时间运行的计算。CEP（复杂事件处理）：可以识别和处理复杂的事件模式，这对于监控和警报等应用非常有用。批流一体：统一了批处理和流处理，使得开发人员可以使用相同的 API 来编写批处理和流处理作业。可伸缩性：可以在小型集群到大型集群中运行，支持水平伸缩以适应不同的负载需求。生态系统：拥有丰富的连接器和库，可以与各种数据源和数据存储系统集成。多语言支持：提供了 Java 和 Scala API，并且通过 DataStream API 支持 Python 和其他语言的集成。 在 Docker 中部署 Flink 是一种流行的实践，因为它简化了环境的配置和管理工作。以下是使用 Docker 部署 Flink 的基本步骤：
Docker 部署 安装 Docker：确保你的系统上已经安装了 Docker，可以从 Docker 官网下载并安装。
创建 Docker 网络：为了使 Flink 组件能够相互通信，需要创建一个 Docker 网络。
docker network create flink-network 拉取 Flink 镜像：从 Docker Hub 拉取官方的 Flink 镜像。
docker pull flink:1.15.0-scala_2.12-java8 启动 Flink 组件：使用 Docker 命令启动 Flink 的 JobManager 和 TaskManager 组件，并加入到创建的网络中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c88e1c33ef5333a0ffb0b63b9090b41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b1bea6af0ffe2b9539787ced756621e/" rel="bookmark">
			用人工智能写2024年高考作文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
用人工智能写2024年高考作文
引用
一、2024年 新课标I卷
作文真题
AI写作范文
二、2024年 全国甲卷
作文真题
AI写作范文
三、2024年 新课标II卷
作文真题
AI写作范文
四、2024年 北京卷
作文真题一
AI写作范文
作文真题二
AI写作范文
作文真题三
AI写作范文
五、2024年 上海卷
作文真题
AI写作范文
六、2024年 天津卷
作文真题
AI写作范文
用人工智能写2024年高考作文 引用 在时间的长河中，2024年的高中作文题目如同一扇窗，透过它，我们得以窥见年轻心灵对世界的好奇与思考。这些作文题目不仅是对学生们语言表达能力的考验，更是对他们观察力、想象力和创造力的挑战。它们鼓励学生们跳出常规思维，从不同角度审视问题，用文字记录下自己的感悟与见解。在这个知识更新迅速、文化多元并存的时代，2024年的高中作文题目，无疑为学生们提供了一个展示自我、探索未知的平台。本文列举2024年所有作文高考真题和AI写作真题，仅供参考学习。
一、2024年 新课标I卷 适用地区：山东、广东、湖南、湖北、河北、江苏、福建、浙江、江西、安徽、河南
作文真题 随着互联网的普及、人工智能的应用，越来越多的问题能很快得到答案。那么，我们的问题是否会越来越少？
以上材料引发了你怎样的联想和思考？请写一篇文章。
要求：选准角度，确定立意，明确文体，自拟标题；不要套作，不得抄袭；不得泄露个人信息；不少于800字。
AI写作范文 标题： 信息时代的思考：问题与答案的无限循环
在这个信息触手可及的时代，互联网和人工智能的发展极大地丰富了我们获取知识的方式。只需几秒钟，我们就能从海量的数据中找到答案。然而，这引发了一个深刻的问题：随着问题的快速解决，我们的问题是否会越来越少？
首先，我们需要认识到，问题的存在并非仅仅为了寻找答案，而是推动我们不断探索和思考的动力。互联网和人工智能的普及，虽然让我们能够迅速获取信息，但这并不意味着问题会减少。相反，随着我们对世界认知的深入，新的问题不断涌现。例如，随着人工智能的发展，我们开始思考机器的道德伦理问题、人工智能与人类的关系等，这些问题的复杂性远远超出了传统问题的范围。
其次，问题的数量和深度与人类的认知能力密切相关。随着知识的积累，我们对世界的理解越来越深入，这使得我们能够提出更加复杂和深入的问题。在科学领域，随着量子物理、基因编辑等技术的发展，我们面临着一系列前所未有的问题。这些问题不仅需要我们运用现有的知识来解答，更需要我们进行创新和突破。
再者，问题的存在也是社会进步的体现。在社会发展的过程中，我们不断遇到新的挑战和问题。这些问题促使我们进行改革和创新，推动社会向前发展。例如，面对环境污染、资源短缺等问题，我们需要寻找可持续发展的解决方案，这不仅需要我们提出新的问题，更需要我们进行深入的思考和探索。
此外，问题的存在也是人类好奇心的体现。好奇心是人类探索未知世界的驱动力，它促使我们不断提出新的问题，探索新的领域。即使在互联网和人工智能的帮助下，我们能够迅速找到答案，但这并不能完全满足我们的好奇心。相反，随着我们对世界的了解越来越深入，我们的好奇心也在不断增强，促使我们提出更多的问题。
最后，我们应该意识到，问题的价值不仅仅在于它们能否被解决，更在于它们如何激发我们的思考和创新。在信息时代，我们应该更加重视问题的提出和思考，而不仅仅是答案的获取。通过提出问题，我们可以更好地理解世界，发现新的可能性，推动社会的进步。
综上所述，随着互联网的普及和人工智能的应用，我们的问题并不会减少，反而会越来越多。我们应该珍惜这个时代赋予我们的机遇，利用互联网和人工智能等工具，不断提出新的问题，进行深入的思考和探索，以推动人类社会的发展。
二、2024年 全国甲卷 适用地区：四川、陕西、青海、内蒙古、宁夏
作文真题 每个人都要学习与他人相处。有时，我们为避免冲突而不愿表达自己的想法。其实，坦诚交流才有可能迎来真正的相遇。这引发了你怎样的联想和思考？请写一篇文章。
要求：选准角度，确定立意，明确文体，自拟标题；不要套作，不得抄袭；不得泄露个人信息；不少于800字。
AI写作范文 标题： 坦诚之桥：构建人际相遇的桥梁
在纷繁复杂的社会中，每个人都是独立的个体，拥有独特的思想和情感。我们渴望与他人建立联系，却又常常因为害怕冲突而选择沉默。然而，真正的相遇往往源于坦诚的交流。本文将探讨坦诚交流的重要性，并思考它如何成为人与人之间相遇的桥梁。
首先，坦诚交流是建立信任的基石。在人际关系中，信任是连接彼此的纽带。当我们敢于表达真实的想法和感受时，我们向他人展示了自己的真诚和开放，这有助于建立和加深信任。相反，如果总是回避表达，不仅会阻碍信任的建立，还可能导致误解和隔阂。
其次，坦诚交流有助于个人成长。每个人都有自己的局限性，通过与他人的交流，我们可以听到不同的观点和见解，这有助于我们拓宽视野，增进自我认识。坦诚的反馈和建议，虽然有时可能令人不适，但却是我们成长和进步的宝贵资源。
再者，坦诚交流能够促进问题的解决。在工作或生活中，冲突和问题是不可避免的。如果我们选择回避，问题往往会被搁置，甚至恶化。而通过坦诚的交流，我们可以直面问题，寻找解决方案，从而有效地解决问题，维护和谐的人际关系。
此外，坦诚交流是情感表达的重要途径。情感是人类生活的重要组成部分，通过坦诚地表达情感，我们可以与他人建立更深层次的联系。无论是喜悦、悲伤还是愤怒，坦诚的情感表达都是我们与他人相遇和理解的桥梁。
最后，我们应该认识到，坦诚交流并不意味着无视他人的感受，而是在尊重和理解的基础上，勇敢地表达自己。这需要我们具备良好的沟通技巧和同理心，以确保我们的坦诚不会变成冒犯或伤害。
综上所述，坦诚交流是人际关系中不可或缺的一部分。它不仅能够促进信任的建立，个人的成长，问题的解决，情感的表达，还能够让我们与他人实现真正的相遇。在这个过程中，我们学会了倾听、理解和尊重，也学会了如何更好地与他人相处。
三、2024年 新课标II卷 适用地区：辽宁、重庆、海南、吉林、黑龙江、山西、云南、广西、甘肃、贵州、新疆、西藏
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b1bea6af0ffe2b9539787ced756621e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7100c6ea3c37ce2c5a153dca1e1fed11/" rel="bookmark">
			Nginx之正向代理配置示例和说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、NGINX正向代理功能简介 Nginx的正向代理功能允许局域网中的客户端通过代理服务器访问Internet资源。具体来说，Nginx作为一种流行的Web服务器和反向代理服务器，在正向代理方面的应用也相当实用。以下是其正向代理功能的几个关键点：
访问外部资源：在正向代理的配置下，Nginx作为代理服务器，帮助内部网络的用户访问外部互联网上的资源。安全性：通过正向代理，可以对内部用户的上网行为进行监控和管理，提高网络安全性。配置简便：客户端需要配置代理服务器的信息，以便通过Nginx访问指定网站。提高访问速度：代理服务器可以缓存经常访问的资源，从而提高后续请求的响应速度。隐藏客户端信息：正向代理可以隐藏客户端的真实IP地址，增加匿名性。负载均衡：虽然不直接属于正向代理的功能，但Nginx还可以用作负载均衡器，分散到多个服务器上，提高网站的可用性和稳定性。 博主将通过实验介绍nginx正向代理的配置和应用，实验环境说明如下：
操作系统：centos7.6nginx版本：1.26.0 二、NGINX正向代理配置 1、实验环境规划 实验环境规划如下，client和nginx server位于同一个局域网内，client无法之间访问外网，通过nginx server提供的正向代理访问互联网。
2、nginx server主机安装nginx [root@s76 yum.repos.d]# yum install -y nginx
…
[root@s76 yum.repos.d]# nginx -Version
nginx version: nginx/1.26.0
3、添加百度网站正向代理配置 [root@s76 conf.d]# cat test.conf server { listen 8888; # 监听端口 server_name localhost; #设置DNS解析器的地址为114.114.114.114，并且设置了解析器的缓存时间为300秒（这样每隔300s就会重新解析一次） resolver 114.114.114.114 valid=300 ipv6=off; resolver_timeout 3s; # 设置解析DNS的超时时间为3秒 proxy_read_timeout 30s;	#设置代理服务器读取超时时间，默认60s proxy_send_timeout 30s;	#该参数用于设置向后端服务器发送数据时的超时时间，默认60s proxy_connect_timeout 30s; #该参数用于设置与后端服务器建立连接时的超时时间，默认60s set $url "www.baidu.com"; #这里设置url变量指向百度 location / { proxy_pass http://$url; # 将请求转发到由 $url 变量表示的地址，如果目标网站服务是特定断开，可以使用http://$url:port方式 proxy_buffers 256 4K; # 设置用于缓存后端响应的缓冲区大小为256个，每个大小为4K。 proxy_max_temp_file_size 0; # 设置Nginx暂存响应数据的最大临时文件大小为0，即不使用临时文件。 proxy_cache_valid 200 302 1m; # 针对状态码为200和302的响应，设置缓存有效期为1分钟。 proxy_cache_valid 301 1h; # 针对状态码为301的响应，设置缓存有效期为1小时。 proxy_cache_valid any 1m; # 对于其他任何响应状态码，设置缓存有效期为1分钟。 } } 4、热加载nginx配置 [root@s76 conf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7100c6ea3c37ce2c5a153dca1e1fed11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc43ee7c4fc6160947e482922a5d7fbe/" rel="bookmark">
			C语言详解（文件操作）1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hi~！这里是奋斗的小羊，很荣幸您能阅读我的文章，诚请评论指点，欢迎欢迎 ~~
💥💥个人主页：奋斗的小羊
💥💥所属专栏：C语言
🚀本系列文章为个人学习笔记，在这里撰写成文一为巩固知识，二为展示我的学习过程及理解。文笔、排版拙劣，望见谅。
目录 前言一、文件的定义1.1 什么是文件？1.2 二进制文件和文本文件 二、文件的打开和关闭2.1 流和标准流2.11 流2.12 标准流 2.2 文件指针2.3 文件的打开和关闭2.31 fopen 和 fclose2.32 文件在当前的工程目录底下2.33 文件在当前工程目录底下的上一级路径2.34 文件不在当前工程目录底下 三、文件的随机读写3.1 fseek3.2 ftell3.3 rewind 总结 前言 我们写的程序的数据存储在电脑的内存中，如果没有文件，当程序退出的时候，内存会回收，那数据就丢失了，等再次运行程序是看不到上次程序的数据的，如果要将数据进行持久化的保存，我们就要使用文件。
一、文件的定义 1.1 什么是文件？ 按文件的功能分类，文件分为程序文件和数据文件，文件是存在磁盘（硬盘）上的。
程序文件：源程序文件（后缀为.c），目标文件（windows环境后缀为.obj），可执行程序（windows环境后缀为.exe）
数据文件：文件的内容不一定是程序，而是程序运行时读写的数据，比如程序运行需要从中读取数据的文件，或者输出内容的文件
本篇文章讨论的是数据文件。
以前我们所处理数据的输入输出都是以终端为对象的，即从终端的键盘输入数据，运行结果显示到屏幕上。其实有时候我们会把信息输出到磁盘上，当需要的时候再从磁盘上把数据读取到内存中使用，这里处理的就是磁盘上的文件。
标识文件——文件名
一个文件要有一个唯一的文件标识，也就是文件名
文件名包含三部分：文件路径+文件名主干+文件后缀，如：c:\code\test.txt
1.2 二进制文件和文本文件 按文件的内容分类，数据文件又分为二进制文件和文本文件
数据在内存中以二进制的形式存储，如果不加转换的输出到外存的文件中，就是二进制文件
如果要求在外存上以ASCII码的形式存储，则需要在存储前转换，以ASCII字符的形式存储的文件就是文本文件
一个数据在文件中是怎么存储的呢？
字符只能以ASCII码的形式存储，数值型数据既可以用ASCII码的形式存储，也可以使用二进制形式存储
比如数字10000，在内存中整型10000是以补码的形式存的，如果以ASCII码形式输出到磁盘，则磁盘中占用5个字节（每个字符占用一个字节），如果以二进制形式输出，则在磁盘中占用4个字节
二、文件的打开和关闭 2.1 流和标准流 2.11 流 我们程序的数据需要输出到各种外部设备，也需要从外部设备获取数据，不同的外部设备的输入输出操作各不相同，为了方便程序员对各种设备进行操作，我们抽象出了流的概念，我们可以把流想象成流淌着字符的河。
C程序针对文件、画面、键盘等的数据输入输出操作都是通过流实现的，一般情况下，我们要想向流里写数据或读数据，都是要打开流，然后操作。
2.12 标准流 以前我们在键盘上输入数据，在屏幕上输出数据，怎么没有打开流呢？
因为C语言程序在启动的时候，默认打开了下面这3个流：
stdin：标准输入流，在大多数环境中从键盘输入，scanf函数就是从标准输入流中读取数据stdout：标准输出流，大多数环境中输出到显示器界面，printf函数就是将信息输出到标准输出流中stderr：标准错误流，大多数环境中输出到显示器界面 stdin、stdout、stderr三个流的类型是FILE *，通常称为文件指针，C语言中就是通过FILE *的文件指针来维护流的各种操作
2.2 文件指针 缓冲文件系统中，关键的概念是“文件类型指针”，简称文件指针
每个被使用的文件都在内存中开辟了一个相应的文件信息区，用来存放文件的相关信息（如文件名，文件状态、文件位置等），这些信息是保存在一个结构体变量中的，该结构体类型是由系统声明的，取名FILE。
不同的C编译器的FILE类型包含的内容不完全相同，但是大同小异
每当打开一个文件的时候，系统会根据文件的情况自动创建一个FILE类型的变量，并填充其中的信息，使用者不必关心细节
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc43ee7c4fc6160947e482922a5d7fbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71dccf454bb998e93f6214868140bef9/" rel="bookmark">
			Spring AI 第三讲Embeddings（嵌入式） Model API 第一讲Ollama 嵌入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有了 Ollama，你可以在本地运行各种大型语言模型 (LLM)，并从中生成嵌入。Spring AI 通过 OllamaEmbeddingModel 支持 Ollama 文本嵌入。
嵌入是一个浮点数向量（列表）。两个向量之间的距离可以衡量它们之间的相关性。距离小表示关联度高，距离大表示关联度低。
前提条件 首先需要在本地计算机上运行 Ollama。
请参阅官方 Ollama 项目 README，开始在本地计算机上运行模型。
安装 Ollama 运行 llama3 将下载一个 4.7GB 的模型工件。
添加资源库和 BOM Spring AI 工件发布在 Spring Milestone 和 Snapshot 资源库中。请参阅 "资源库"部分，将这些资源库添加到您的构建系统中。
为了帮助进行依赖性管理，Spring AI 提供了一个 BOM（物料清单），以确保在整个项目中使用一致的 Spring AI 版本。请参阅 "依赖关系管理 "部分，将 Spring AI BOM 添加到构建系统中。
自动配置 Spring AI 为 Azure Ollama 嵌入式客户端提供 Spring Boot 自动配置功能。要启用它，请在 Maven pom.xml 文件中添加以下依赖关系：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt; &lt;artifactId&gt;spring-ai-ollama-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; 或 Gradle build.gradle 构建文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71dccf454bb998e93f6214868140bef9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/282/">«</a>
	<span class="pagination__item pagination__item--current">283/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/284/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>