<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9abae0c59bea57dae4bec5d10f8a990/" rel="bookmark">
			用ChatGPT&#43;Midjourney 5分钟生成30条爆款小红书图文（内有详细教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本期是赤辰第35期AI项目教程，文章底部准备了粉丝福利，看完后可免费领取！
今天给大家讲一下如何5分钟生成30条爆款小红书图文
先说个账号，这个应该有同学也看过，前几个月在小红书有个涨粉很快的AI绘画项目，就是分享猫咪时尚走秀就能轻松获得1W+的点赞，三个月就涨粉超4.7W+，而这些猫咪图片全部都是AI生成的，并且5分钟就能生成三十条这种爆款小红书图文。
本期就借助这类账号，来把从文案到图片设计的全过程都演示一遍，让你快速学会爆款笔记制作逻辑，也能在短期内账号快速涨粉破万。
首先来分析一下AI拟人化宠物账号的特性：
穿着人类衣服的萌宠做着人类的动作在现实场景中活动 大家在路上看见人类逛街的行为和动作一定不会好奇，但如果是一只小猫，在双脚走路逛街购物，那一定是引爆焦点，这种AI绘画新玩法，其实就是抓住用户的猎奇心理，对于超出认知范围的东西，就会控制不住想多看几眼。
自媒体最需要的就是关注度，像这些很新奇的图片往往能够满足人们的这一特性，这类笔记生产也很简单，只需要用到两个AI工具，ChatGPT+Midjourney。
ChatGPT负责提供灵感和文案，Midjourney负责输出设计和图片。
接下来演示详细操作步骤
1.用ChatGPT生成文案
首先借助ChatGPT生成笔记文案及图片提示词，只要告诉GPT，定位角色扮演，账号的类型，以及我们图片描述，它就能快速给到一份让我们满意的回答，提示词我也给大家整理出来了。
prompt：你的角色是:专业的小红书运营背景:目前你正在运营一个像人类一样的猫咪分享穿搭的账号账号内容：猫咪模特分享穿搭注意:这些猫咪需要使用双脚站着走路需要制作的内容有3部分:图片、标题、文案需要你提供：图片描述、标题和文案用表格的形式给我
这一步，你也可以让GPT批量一次性生产30组内容。
prompt：按照这样的结构，帮我生产30组猫咪扮演人物的日常生活内容。
图片描述、标题、文案都有了，非常符合我们的预期，然后再继续告诉他要补充上主体场景，图像风格、图像长宽比等信息，并且用英文的方式返回给我们。
prompt：不错，再加入英文版的图片描述，英文图片描述需要包括主体、场景、图像风格、图片长宽比。
2.Midjourney生成图片将刚才ChatGPT生成的提示词，复制黏贴至Midjourney中生成图片，接着就是选择你满意的图片保存。
最后我们只要把下载好的图片和文案都上传到小红书，打上对应的标签后，就可以发表爆款的笔记了。
OK，今天的内容就到这，篇幅比较长，如果制作过程中有卡点，欢迎私我交流探讨。上期AI数字人训练营已经结训，正在挖掘第四期AI项目，需要学习了解AI项目的可以私信我。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12c929f66fe93e96e6a4272f8db8f359/" rel="bookmark">
			数据库课设---学生宿舍管理系统(sql server&#43;C#)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.引言 1.1 内容及要求 设计内容：设计学生宿舍管理系统。
设计要求：
（1）数据库应用系统开发的需求分析，写出比较完善系统功能。
（2）数据库概念模型设计、逻辑模型设计以及物理模型设计。
（3）完成功能模块结构设计并编写代码实现。
（4）软件总体测试及修改。
（5）撰写软件设计说明书。
1.2 系统环境选择 数据库系统选择：Microsoft SQL Server 2019数据库管理系统选择：Microsoft SQL Server Management Studio 18前端开发语言选择：C#前端开发软件：Visual Studio 2019前端开发框架：Windows 窗体应用(.NET Framework 4.8) 2.需求分析 2.1 设计背景 学生宿舍管理系统的设计背景源于对传统宿舍管理方式的改进需求。传统方式存在信息不透明、手动操作繁琐等问题，导致住宿分配不公平、报修反馈滞后等困扰。通过引入宿舍管理系统，可以提高管理效率和便捷性，简化操作流程，提供学生宿舍申请、报修、查询等功能。系统能够数字化宿舍分配，实现公平和透明，同时提供维修管理和访客功能，提升宿舍管理质量和学生满意度。数据统计和分析功能为管理员提供决策支持，帮助改进管理策略。通过系统，学生和管理员可以获得准确、实时的宿舍信息，增加管理的透明性和公正性。综上所述，学生宿舍管理系统的设计背景是为了提高管理效率、提供便捷服务、实现公平和透明的宿舍管理，提升学生生活质量和学习环境。
2.2 功能分析 系统需要有一个登录页面，不同用户登录后，对不同的功能具有不同的权限。数据库用户包括学生、维修员、管理员等多个角色。
信息要求：
管理员可以查询学生信息、宿舍信息、维修人员信息、维修信息及访客信息。维修人员可以查询修改维修单号、查询维修评价等信息。学生可以查询访客审批进度、维修进度等信息。 处理要求：
学生可以在系统内部报销损坏，申请访客访问，访客离开报备。在维修之后还可以对此次维修做出评价。管理员看到学生提交上来的申请后会进行审批。审批的结果学生都可以查询到。当维修申请通过后，此维修单将会自动传递给维修师傅，维修师傅便可以维修。在维修完之后管理员还要对维修人员提交的报销进行审批，通过则报销维修费用。管理员还会核实访客离开的报备。维修人员可以查询到通过审批且未维修的单子从而选择接单。维修完成后由维修人员提交维修完成表和报销单。维修人员可以查询报销状态和学生对自己的维修评价。 2.3 数据项和数据结构 数据项：
宿舍号、宿舍人数、宿舍地址、楼栋号、楼栋地址、学生学号、姓名、班级、学生性别、床号、访客号、访客姓名、访客电话、访客日期、访客时间、访问理由、访客审批状态、离开时间、核实状态、维修单号、维修时间、维修审核状态、维修状态、报销状态、维修人员姓名、损坏描述、维修人员工号、维修人员性别、维修人员年龄、维修评分、维修具体评价、报销金额、管理员账户、维修人员账户、用户账户、密码。
宿舍号。类型：字符串型。长度：20。含义：唯一标识用来区别每个宿舍。宿舍人数。类型：整数类型。含义：记录当前宿舍居住人数。宿舍地址。类型：字符串型。长度：40。含义：记录宿舍地址。楼栋号。类型：字符串型。长度：20。含义：唯一标识楼栋。楼栋地址。类型：字符串型。长度：40。含义：记录楼栋地址。学生学号。类型：字符串型。长度：20。含义：唯一标识学生。学生姓名。类型：字符串型。长度：20。含义：学生的姓名。班级。类型：字符串型。长度：25。含义：学生班级。学生性别。类型：字符串类型。长度：2。含义：学生的性别只能是男生或者女生。床号。类型：整数。含义：学生睡的床号。不能超过宿舍最大人数。访客号：类型：字符串类型。长度25。含义：唯一标识访客信息。访客姓名。类型：字符串型。长度：20。含义：记录访客的姓名。访客电话。类型：字符串型。长度：20。含义：记录访客联系方式。访客日期。类型：时间类型。含义：记录访客访问时间。访客时间。类型：字符串型。长度：10。含义：记录访客具体访问时间。访问理由。类型：字符串型。长度：100。含义：描述访问原因。访客审批状态。类型：字符串型。长度：10。含义：审批状态只能是三种：待审核，已通过，未通过。离开时间。类型：字符串型。长度：10。含义：访客离开时间。核实状态：类型：字符串型。长度：10。含义：核实状态只能是三种：待核实，已核实，核实有误。维修单号。类型：字符串型。长度：20。含义：唯一区分维修单。维修时间。类型：时间类型。含义：记录维修时间。维修审核状态。类型：字符串型。长度：10。含义：审批状态只能是三种：待审核，已通过，未通过。维修状态。类型：字符串型。长度：10。含义：维修状态只能是三种：待审核，已维修，未维修。报销状态。类型：字符串型。长度：10。含义：报销状态只能是三种：待审核，已报销，未报销。维修人员姓名。类型：字符串型。长度10.含义：维修人员姓名。损坏描述。类型：字符串型。长度：100。含义：描述损坏原因。维修人员工号。类型：字符串型。长度：15。含义：唯一记录维修人员。维修人员性别。类型：字符串类型。长度：2。含义：维修人员的性别只能是男生或者女生。维修人员年龄。类型：整型。含义：记录维修人员年龄。维修评分。类型：整数类型。含义：评分大于等于0且小等用于100。维修具体评价。类型：字符串型。长度：100。含义：描述维修评价。报销金额。类型：字符串型。含义：报销费用。管理员账户、维修人员账户、用户账户。类型：字符串型。长度：100。含义：账号不能重复。密码。类型：字符串型。长度：100。含义：当密码正确时，才能登陆成功。 数据结构：
学生信息(学号，姓名，班级，性别，床位，居住宿舍)宿舍(宿舍门牌号，宿舍人数，宿舍地址)楼栋(楼栋号，楼栋地址)访客记录表(访客号，访问学生学号，访客姓名，访客电话，访客日期，访客时间，访问审批状态)访客报备表(访客号，离开状态，离开时间，核实状态)维修记录表(维修单号，维修宿舍号，维修时间，维修人员姓名，损坏原因描述，审核状态，维修状态)维修人员(工号，姓名，年龄，性别)评分表(维修单号，维修人员姓名，评分，具体评价)报销表(维修单号，维修人员姓名，报销金额，报销状态)账户登录表(账号，密码) 2.4 安全性和完整性 安全性要求：
设置管理员，维修员，用户多种角色。在设计时，对不同的角色赋予不同的权限。用户的权限有申请维修，访客申请。查询访客申请进度，查询维修进度。在维修人员维修完之后，用户还可以评分。除此以外，用户还可以查询修改个人信息，修改登录密码。维修人员的权限有查询选择维修单进行维修，还可以修改维修状态。查询维修评价。申请维修报销等。但是维修人员只能修改维修单上的部分属性。例如维修单号，维修地点，损坏原因等维修员是修改不了的。除此以外，维修员可以自己修改密码和查询个人信息。管理员被赋予的权限是最大的。管理员对所有基本表基本都可以进行增删改查。管理员还被赋予审核的权限。例如访客申请，管理员可以通过也可以拒绝访问。在管理员做出决策后，用户或者维修人员都可以查询到。 完整性要求：
无论是管理员，维修员还是用户他们的账号是主键，密码均不可以为空。学生的学号是主键，姓名，班级等均都不能为空。年龄为正整数。楼栋表中，楼栋号为主键，楼栋地址不为空。学生和维修人员的性别只能是男或者女。在宿舍表中，宿舍门牌号为主键，居住人数可为0，宿舍所处楼栋不能为空。维修人员信息表中，工号为主键，姓名不能为空。年龄为正整数且年龄要大于等于25。维修表中，维修号是主键。宿舍号是外码参照宿舍表。其中维修审核状态，维修状态不能为空且只能处于：待审核，已通过，未通过三种状态。评分表中，维修单号是外码，参照维修表。评分大于等于0且小于等于100且不为空。具体评价可为空。报销表中，报销单号为主键。维修单号和维修工姓名为外码参照维修人员表。报销金额不为空且为正整数。报销状态只能是:待审核，已报销，拒绝报销这三种。访客表中，访客号为主键。拜访学生学号为外键，参照学 生表。访客信号，访客电话，访客访问日期和访问理由均 不能为空。访客未离开时，离开报备无法提交删除宿舍时，把学生表中住在此宿舍的学生床位置0并且 把宿舍置空。维修表里的宿舍号码也置为空值。删除学生信息时，其所居住的宿舍人数减一。同时访客记录中与该学生对应的记录也会删除。当修改学生住宿的宿舍时，原宿舍人数减一，新宿舍人数加一。同时床位不能重复以及这个宿舍是否满员要进行判断。添加学生信息时，不能与已经存在的学生学号相同，同时若该学生入住某宿舍此宿舍人数加一。 概念结构的设计 实体属性 实体属性如图所示：
图1 实体属性图
3.2 实体间的联系(E-R图) 实体间联系见下图
图2 E-R图
3.3数据设计图 利用Power Designer 设计的数据库图如下所示：
图3 Power Designer设计图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12c929f66fe93e96e6a4272f8db8f359/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62019c3ffc8901cadb96599cbf48331e/" rel="bookmark">
			python导出requirements.txt的几种方法及环境配置流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python导出requirements.txt的几种方法及环境配置流程 一、pip1、导出结果含有路径2、导出不带路径的 二、Conda1、导出requirements.txt2、导出yml 文件 三、第三方包：pipreqs（推荐）四、环境配置一般流程1、创建并激活conda环境2、安装requirements文件的pip源的包3、安装正确版本的pytorch+torchvision+cuda4、完整流程举例 一、pip 1、导出结果含有路径 导出结果会存在路径，生成的requirements.txt文件在当前目录下。
pip freezen &gt; requirements.txt 2、导出不带路径的 生成的requirements.txt文件在当前目录下。
pip list --format=freeze &gt;requirement.txt 生成requirements.txt，pip freeze会将当前PC环境下所有的安装包都进行生成,再进行安装的时候会全部安装很多没有的包.此方法要注意。
二、Conda 1、导出requirements.txt a.导出
conda list -e &gt; requirements.txt b.导入安装
conda install --yes --file requirements.txt 2、导出yml 文件 a.导出
conda env export &gt; freeze.yml b.导入安装
conda env create -f freeze.yml 三、第三方包：pipreqs（推荐） 使用pipreqs，这个工具的好处是可以通过对项目目录的扫描，发现使用了哪些库，生成依赖清单。
step1：安装pipreqs(默认没有安装)
pip install pipreqs step2：使用pipreqs导出
在python项目的根目录下 使用
pipreqs ./ 如果报错，则采用下面的代码
pipreqs ./ --encoding=utf-8 生成的requirements.txt文件在当前目录下。
四、环境配置一般流程 1、创建并激活conda环境 conda create -n 环境名称 python=3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62019c3ffc8901cadb96599cbf48331e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05a4dfb3312a6b56a5029fa3af6eea43/" rel="bookmark">
			手动下载/安装Xcode的simulator
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 前言解决方案1.获取simulator包下载地址1.1 Apple后台1.2 手动 2.使用三方下载工具下载3.使用命令安装simulator 前言 Xcode某个版本更新之后不带iOS的Simulator,导致全新下载一个Xcode后没法编译项目.公司的网又很坑,每次断掉点重试都重新下载,导致完全没法下下来.特别影响工作进度.
解决方案 1.获取simulator包下载地址 1.1 Apple后台 https://developer.apple.com/download/all/?q=Xcode
1.2 手动 在LaunchPad/聚焦搜索中搜索控制台(console).
选中当前电脑,然后点击开始流式传输.右上角搜索框内输入"DVTDownloadable"
然后进入Xcode的下载页面
Xcode-&gt;Settings…-&gt;Platforms
这里因为我都下载过了.所以点击左下角的+号来演示一下如何获取下载地址
等这里出来之后点击取消(x按钮)
控制台内会出现下载的地址.可以选中上面蓝色的那一条粘贴,然后获取内容,或者直接在下面的说明里面把下载地址粘贴出来.
2.使用三方下载工具下载 我这里使用的是chrome下载
3.使用命令安装simulator xcrun simctl runtime add "~/Downloads/iOS_16.4_Simulator_Runtime.dmg" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7963e610d9645bbc94b2eb17550e33b/" rel="bookmark">
			深入解析Oracle数据泵EXPDP/IMPDP导出导入功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 深入解析Oracle数据泵EXPDP/IMPDP导出导入功能一.概述二.数据泵导出三.数据泵导入四.高级选项1.并行设置2.导出文件压缩3.导出文件大小设置4.导出不同级别的数据a. 导出表b. 导出模式c. 导出表空间d. 导出全库 5.数据过滤6.转换映射a. 转换模式b. 转换表空间c. 转换数据文件d. 转换表 7.导入表已存在时的处理8.排除/指定对象a. 指定b. 排除 五.注意事项六.相比传统exp/imp工具的优势1.性能更高2.并行执行3.更灵活的选项 总结 深入解析Oracle数据泵EXPDP/IMPDP导出导入功能 一.概述 Oracle数据库是企业级应用中最常用的数据库之一，其数据泵导入导出功能是非常重要且广泛使用的功能。数据泵是一个高效的数据传输工具，能以二进制格式导出和导入数据库对象和数据。相较传统导出导入工具，数据泵具有更高的性能和可靠性，并支持更多功能选项。
二.数据泵导出 数据泵导出将数据库对象和数据导出到文件中，以便在其他数据库中导入或备份。以下是进行数据泵导出的基本步骤：
a. 连接到目标数据库
b. 使用EXPDP命令指定导出的对象和选项
c. 执行导出命令并等待导出完成
d. 检查导出日志并验证导出结果
示例：
create directory dpump_dir1 as '/home/back'; --创建目录路径 expdp username/password@dbname DIRECTORY=dpump_dir1 DUMPFILE=expdp.dmp logfile=expdp.log SCHEMAS=hr 三.数据泵导入 数据泵导入将数据泵文件中的对象和数据导入到数据库中。以下是进行数据泵导入的基本步骤：
a. 连接到目标数据库
b. 使用IMPDP命令指定导入的对象和选项
c. 执行导入命令并等待导入完成
d. 检查导入日志并验证导入结果
示例：
impdp username/password@dbname DIRECTORY=dpump_dir1 DUMPFILE=expdp.dmp logfile=impdp.log SCHEMAS=hr 四.高级选项 数据泵导入导出功能提供了一些高级选项，可灵活控制导入导出过程。以下是一些常用的高级选项：
1.并行设置 并行设置允许同时使用多个进程来加速导出导入操作。通过指定PARALLEL参数，可以控制导出过程中的并行度。
示例：
expdp username/password@dbname DIRECTORY=dpump_dir1 DUMPFILE=expdp%U.dmp PARALLEL=4 在上述示例中，"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7963e610d9645bbc94b2eb17550e33b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0594b9932c08b0711ba9aa3358745877/" rel="bookmark">
			python下载安装教程（Python 3.10版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、Python下载二、Python安装三、检查Python是否安装成功学习资源推荐1.Python学习路线2.Python基础学习01.开发工具02.学习笔记03.学习视频 3.Python小白必备手册4.数据分析全套资源5.Python面试集锦01.面试资料02.简历模板 今天换了新的电脑，需要重新安装python和PyCharm，就简单的写个教程吧~
一、Python下载 1、进入Python官网
官网地址：https://www.python.org
2、点击【Downloads】展开后点击【Windows】跳转到下载python版本页面，选择"Stable Releases"稳定版本，我下载的是Python 3.10.10版本，所以找到【Python 3.10.10-Feb.8,2023】 版本，点击【Download Windows installer(64-bit)】下载Windows64位操作系统。
【Stable Releases】：稳定发布版本，指的是已经测试过的版本，相对稳定。
【Pre-releases】：预发布版本，指的是版本还处于测试阶段，不怎么稳定。
【Windows embeddable package】：Windows可嵌入程序包，通俗一点就是一个压缩包。
【Windows help file】：指的是帮助文档，可无视，对于小白帮助不了什么。
如果不知道自己是多少位操作系统，按一下Windows键找到“设置”→“系统”→“关于”→“系统类型”可查看自己是多少位操作系统。
3、正在下载
二、Python安装 1、下载完后双击打开Python，勾选【Add python.exe to PATH】,点击【Customize installation】进行自定义安装。
【Install Now】：立即安装，点了会默认安装python的位置与默认勾选python功能
【Customize installation choose location and features】：自定义安装选择位置和功能。
【Use admin privileges when installing py.exe】： 安装py.exe时使用管理员权限，勾选这个是为了程序或者命令运行过程中更改系统设置或则注册表，如果没勾选，那你就只能以普通用户的身份进行读的权限，没有改的权限，也就没法完成更改操作。
【Add python.exe to PATH】：将python.exe添加到PATH,就是把python的路径添加到PATH环境变量中。
2、所有功能全部默认勾选，单击【Next】下一步。
【Documentation】：安装Python文档文件。
【pip】：安装pip，这个是一个安装和管理Python包的工具，就是以后你可以通过Win+R输入cmd回车，然后输入pip install+包名下载相应的python模块。
【tcl/tk and IDLE】：安装tkinter和IDLE开发环境。
【Python test suite】：安装标准库测试套件。
【py launcher】： Python启动器。【for all user】所用用户（需要管理员权限）两个一起勾选后会安装全局Python启动器，使启动Python变得更容易。
3、创建桌面快捷方式根据自己的需求勾选，其他两个默认勾选不进行改动，点击【Browse】按钮修改安装路径，我的是安装在D盘里的Python文件里，然后单击【Install】进行安装。
【Associate files with Python】：将文件与Python关联。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0594b9932c08b0711ba9aa3358745877/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6a16088a5920840ab829285ea92390c/" rel="bookmark">
			AI情绪检测器：准确检测并解读人类情绪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 情绪分析在数字世界中被广泛应用，用于评估消费者对产品或品牌的情绪。然而，在线下环境中，用户与品牌和产品进行互动的场所（如零售店、展示厅）仍然面临着自动测量用户反应的挑战。使用人工智能进行面部表情情绪检测可以成为衡量消费者对内容和品牌参与度的可行替代方案。 ParallelDots结合了心理学、人类表情和人工智能，开发出一种能够自动识别个人脸上不同情绪的面部情绪检测算法。该算法能够实时识别七种不同类型的情绪状态。
当前情感识别市场预计在未来五年内将呈指数级增长，从2020年的195亿美元增长到2026年的371亿美元。其他消息来源称，可能会达到850亿美元的更高数字。这些估计表明，情感识别市场正在不断增长。尽管当前的情绪识别技术存在一些明显和隐藏的缺陷，但业务需求依然存在。
AI情绪检测器是一种利用人工智能从各种数据源（如面部表情、声音、肢体语言、文本或生理信号）检测和解释人类情绪的系统。它为各个行业和应用提供有价值的见解和反馈，例如营销、医疗保健、教育、娱乐、安全等。
想象一下，如果您能够读懂周围人的想法和内心。如果您只需观察他们的脸、听他们的声音或阅读他们的文字就能了解他们的感受、想法和需求，那会有怎样的结果？这将如何改变您的个人和职业关系、您的决策以及您的幸福感？
现在，您无需再想象了。借助人工智能（AI），您可以访问一个强大的系统，该系统可以从各种数据源检测和解释人类情绪。这个系统被称为人工智能情绪检测器，它正在彻底改变我们对自己和他人的理解，以及与他人互动的方式。
二、应用场景 2.1、让汽车更安全、个性化 世界各地的汽车制造商越来越注重让汽车变得更加个性化和安全。在追求打造更多智能汽车功能的过程中，制造商使用人工智能来帮助他们理解人类情感是有意义的。使用面部情绪检测智能汽车可以在驾驶员感到困倦时发出警报。
根据中国交通安全年报数据，大约 20%～30% 的致命道路事故是由疲劳驾驶造成的。面部情绪检测可以发现困倦之前面部微表情的微妙变化，并向驾驶员发送个性化警报，要求他停下来喝杯咖啡，改变音乐或温度。
2.2、面试中的面部情绪检测 候选人与面试官的互动很容易受到多种判断和主观性的影响。这种主观性使得很难确定候选人的性格是否适合该工作。由于语言解释、认知偏见和介于两者之间的上下文的多层，识别候选人想要说的内容是我们无法掌控的。这就是人工智能的用武之地，它可以测量候选人的面部表情，捕捉他们的情绪，并进一步评估他们的性格特征。
值得注意的是，已经有企业开始将这项技术纳入他们的招聘流程。借助这项技术，招聘人员将能够了解面试者的整体信心水平，并决定该候选人是否能够在面向客户的工作中表现出色。同样，通过测量候选人回答过程中的情绪变化并将其与该领域的大量可用知识相关联，可以发现候选人是否诚实地回答了所有问题。
使用这项技术，还可以通过保持和记录工作中的互动来了解员工的士气。作为一种人力资源工具，它不仅可以帮助制定招聘策略，还可以帮助设计可实现员工最佳绩效的人力资源政策。
2.3、视频游戏测试 视频游戏的设计考虑到了特定的目标受众。每个视频游戏都旨在唤起用户的特定行为和情绪。在测试阶段，用户被要求在给定的时间内玩游戏，他们的反馈将被纳入最终产品的制作中。使用面部情绪检测可以帮助了解用户在玩游戏时实时经历的情绪，而无需手动分析整个视频。
可以通过分析用户的实时反馈并检测他的面部情绪来获取此类产品反馈。虽然在高级视频游戏中通常会经历沮丧和愤怒的感觉，但利用面部情绪检测将有助于了解在游戏中的哪些时刻会经历哪些情绪。也有可能在游戏过程中观察到一些意想不到的或不良的情绪。从体验过游戏的用户那里获取反馈可能效率很低。这是因为通常很难用语言表达经历。此外，用户可能无法记住他们在游戏的不同部分中到底经历了什么情绪。面部情绪检测是一种超越口头或书面反馈并了解用户体验的实用方法。当以这种格式获取反馈时，就用户体验而言，它变得真正非侵入性。同时，这种反馈比其他形式更可靠。
2.4、市场研究 传统上，市场研究公司采用调查等口头方法来寻找消费者的需求。然而，此类方法假设消费者可以口头表达他们的偏好，并且所陈述的偏好对应于未来的行为，但可能并不总是正确的。
市场研究行业的另一种流行方法是采用行为方法来观察用户在与品牌或产品互动时的反应。此类方法被认为比口头方法更客观。行为方法使用用户与产品交互的视频源，然后手动分析这些视频以观察他们的反应和情绪。然而，随着样本量的增加，此类技术很快就会变得非常劳动密集。面部情绪识别可以帮助市场研究公司自动测量每时每刻的面部情绪表情（面部编码）并汇总结果。
利用技术检测情绪是一项具有挑战性的任务，但机器学习算法已显示出巨大的前景。使用 ParallelDots 的面部情绪检测 API，客户可以实时处理图像和视频，以监控视频源或自动进行视频分析，从而节省成本并改善用户的生活。该 API 采用即用即付模式定价，允许您在扩展之前测试该技术。
面部情绪检测只是视觉智能自动分析视频和图像的一部分。单击此处查看照片中的面部表情。
三、什么是情绪识别？ 3.1、什么是情感人工智能？ 情感人工智能，也称为情感计算，是人工智能的一个快速发展的分支，它允许计算机分析和理解人类非语言信号，如面部表情、肢体语言、手势和语气，以评估他们的情绪状态。因此，视觉情感人工智能利用计算机视觉技术分析图像和视频中的面部外观，以分析个人的情绪状态。
3.2、视觉AI情绪识别 情绪识别是机器试图通过面部特征分析来分析、解释和分类人类情绪的任务。
在所有高级视觉任务中，视觉情感分析（VEA）是针对低级像素和高级情感之间现有的情感差距最具挑战性的任务之一。尽管困难重重，视觉情感分析仍然很有前途，因为理解人类情感是迈向强大人工智能的关键一步。随着卷积神经网络（CNN）的快速发展，深度学习成为情感分析任务的新选择方法。
四、什么是人工智能情绪检测器 情绪识别是面部识别技术的自然发展。目前，情绪检测（或称为情绪检测）基于通用情绪理论，该理论具有六种“基本”情绪：恐惧、愤怒、快乐、悲伤、厌恶和惊讶。该理论由美国著名心理学家保罗·艾克曼提出、研究和辩护。
有些算法可能有第七种情感，比如微软的 Face API，算法中添加了蔑视。然而，从事人类心理学领域的研究人员有时认为这种传统方法是缺乏和不完整的。
基本上，情绪识别算法所做的就是根据一个人当时的面部表情来预测他们的情绪。这允许估计用户对某些内容、提供的产品、过程中的参与度等的反应（取决于情感识别算法的实施领域）。让我们更深入地了解此类算法的内部工作原理。
AI情绪检测器是利用人工智能从各种数据源中识别和理解人类情绪的过程。情绪是与生理变化、认知过程、行为表达和社会背景相关的主观心理状态。情绪可以分为两种主要类型：
基本情绪是普遍存在的（快乐、悲伤、愤怒、恐惧、惊讶、厌恶），通过面部或声音表达。
受经历和文化影响的复杂情绪包括通过肢体语言或言语表现出来的自豪、内疚、羞耻、嫉妒、感激、爱、恨。
AI 情绪检测器很重要，因为它可以通过使人机交互更加自然、真实和富有同理心来增强人机交互。通过了解人类在不同情况下的感受，人工智能系统可以提供更加个性化的服务、建议或反馈，并相应地调整他们的行为。
AI情绪检测器还可以通过测量和分析客户、员工、学生、患者或用户对不同产品、服务、内容或场景的情绪反应，为各个行业和领域提供有价值的见解。
五、AI 情绪分析的工作原理 从较高的层面来看，人工智能情感应用或视觉系统包括以下步骤：
步骤#1：从摄像机源（IP、CCTV、USB 摄像机）获取图像帧。
步骤#2：图像预处理（裁剪、调整大小、旋转、色彩校正）。
步骤#3：使用 CNN 模型提取重要特征
步骤#4：执行情绪分类 人工智能情感识别的基础基于三个连续步骤：
5.1、图像和视频帧中的人脸检测 第一步，使用摄像机的视频来检测和定位人脸。边界框坐标用于实时指示准确的人脸位置。人脸检测任务仍然具有挑战性，并且不能保证在给定的输入图像中检测到所有人脸，特别是在具有挑战性的照明条件、不同头部姿势相距很远或遮挡的不受控制的环境中。
5.2、图像预处理 当检测到面部时，图像数据会在输入情感分类器之前进行优化。这一步大大提高了检测精度。图像预处理通常包括多个子步骤，以针对照明变化对图像进行归一化、减少噪声、执行图像平滑、图像旋转校正、图像调整大小和图像裁剪。
5.3、情绪分类AI模型 预处理后，从包含检测到的人脸的预处理数据中检索相关特征。有不同的方法可以检测多种面部特征。例如，动作单元 (AU)、面部标志的运动、面部标志之间的距离、梯度特征、面部纹理等等。一般来说，用于人工智能情感识别的分类器基于支持机器向量（SVM）或卷积神经网络（CNN）。最后，通过分配预定义的类别（标签）（例如“快乐”或“中性”），根据面部表情对识别出的人脸进行分类。
六、AI 情绪检测器如何工作 与任何其他人工智能项目一样，构建情感识别模型的过程从项目规划和数据收集开始。您可以在我们的专门文章中详细了解人工智能项目的阶段和数据集的收集。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6a16088a5920840ab829285ea92390c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29f24f027021143f97a1d43df5cc0f12/" rel="bookmark">
			解决MySQL8.0报错Client does not support authentication protocol requested by server...问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决MySQL8.0报错Client does not support authentication protocol requested by server; consider upgrading MySQL client问题
原创：丶无殇 2023-10-07
报错内容 使用node.js连接数据库MySQL 8时候，报错ER_NOT_SUPPORTED_AUTH_MODE，并且提示Client does not support authentication protocol requested by server; consider upgrading MySQL client：客户端不支持服务器请求的身份验证协议；考虑升级MySQL客户端；
报错原因 最新的MySQL模块并未完全支持MySQL 8.0的caching_sha2_password加密方式，而MySQL 8.0中默认仍然是caching_sha2_password加密方式，因此用户认证不通过了。
如下查询：
mysql&gt; alter user 'root'@'localhost' identified by '123456'; Query OK, 0 rows affected (0.02 sec) 这里的“123456”是你自己的密码
解决方法 直接数据库工具里面修改加密方式mysql_native_password：
或者通过指令方式修改：
mysql&gt; alter user 'root'@'localhost' identified with mysql_native_password by '123456'; Query OK, 0 rows affected (0.01 sec) 数据库连接和关闭都成功，连接问题解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee74ef7b3b9e70bad402d55a0fa78869/" rel="bookmark">
			python 读取 通达信 数据 pytdx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python 读取 通达信 数据 pytdx
pytdx 1.72
https://www.cnpython.com/pypi/pytdx
https://rainx.gitbooks.io/pytdx/content/pytdx_reader.html
pip3 install pytdx
from pytdx.reader import TdxDailyBarReader, TdxFileNotFoundException from pytdx.reader import BlockReader reader = TdxDailyBarReader() df = reader.get_df("C:\\new_tdx\\vipdoc\\sz\\lday\\sz000001.day") print(df) df = BlockReader().get_df("C:\\new_tdx\\T0002\\hq_cache\\block_zs.dat") print(df) df = reader.get_df("C:\\new_tdx\\vipdoc\\sh\\lday\\sh601688.day") print(df) 11
[9843 rows x 4 columns] open high low close amount volume date 2010-02-26 21.01 21.94 21.00 21.06 6.631745e+09 3109136.36 2023-10-09 15.61 15.82 15.32 15.78 7.417075e+08 475096.64 volume — 成交量 47.51万手 475096.64手 一手等于一百股
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee74ef7b3b9e70bad402d55a0fa78869/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/096a3ecf635a4d22cac278856fdf79aa/" rel="bookmark">
			【RabbitMQ 实战】10 消息持久化和存储原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、持久化 1.1 持久化对象 rabbitmq的持久化分为三个部分：
交换器的持久化。队列的持久化。消息的持久化。 1.1.1 交换器持久化 交换器的持久化是通过在声明交换器时， 指定Durability参数为durable实现的。若交换器不设置持久化，在rabbitmq服务重启之后，相关的交换器元数据会丢失，但消息不会丢失，只是不能将消息发送到这个交换器中。
所以在声明交换器时，都要设置持久化。在web监控创建时，默认也是持久化模式，指定持久化模式带有标识“D”。
springboot监听器，实现交换器持久化示例
1.1.2 队列持久化 队列的持久化是通过在声明队列时， 指定Durability参数为durable实现的。若队列不设置持久化，在rabbitmq服务重启之后，相关队列的元数据和消息数据同时丢失。若队列设置持久化，只能保证队列本身的元数据不会因异常情况而丢失，但是并不能保证内部所存储的消息不会丢失。要确保消息不会丢失，需要将消息设置为持久化。在web监控创建时，默认也是持久化模式，指定持久化模式带有标识“D”。
springboot监听器，实现队列持久化示例
1.1.3 消息持久化 消息的持久化可以通过消息的投递模式来实现，属于代码层面上的。可以控制每一条消息是否久化。
但是将所有消息都设置为持久化，会严重影响rabbitmq服务器性能，写入磁盘的速度比写入内存的速度慢得不只一点点。所以对于可靠性不是那么高的消息可以不采用持久化处理以提高整体的吞吐量。在选择是否要将消息持久化时，需要在可靠性和吐吞量之间做一个权衡。
springboot代码设置消息的持久化示例
1.2 总结要点 交换器、队列、消息都可以设置是否持久化。交换器和队列持久化的含义是元数据持久化。消息持久化的含义是消息本身持久化。 将交换器、队列、消息都设置了持久化之后能百分之百保证数据不丢失吗？答案是不能
从消费者来说，如果在订阅消费队列时将 autoAck 参数设置为 true，那么当消费者接收到相关消息之后，还没来得及处理就宕机了，这样也算数据丢失。这种情况很好解决，将autoAck 参数设置为 false，并进行手动确认。在持久化的消息正确存入rabbitmq之后，还需要有一段时间(虽然很短，但是不可忽视) 才能存入磁盘之中。如果在这段时间内rabbitmq服务节点发生了宕机、重启等异常情况，消息保存还没来得及落盘，那么这些消息将会丢失。这种情况可以使用镜像队列来解决。 二、存储机制 前面提到的消息持久化，其实是在rabbitmq的“持久层”中完成的。不管是持久化的消息，还是非持久化的消息都可以被写入到磁盘。
持久化的消息在到达队列时就入盘，而且还可以设置持久化的消息在内存中也保存一份备份，这么做可以提高业务效率，当内存吃紧时会从内存中清除。非持久化的消息一般只保存在内存中，在内存吃紧的时候会被换入到磁盘中，以节省内存空间。 2.1 存储方式 持久层是一个逻辑上的概念，实际包含两个部分：
队列索引 (rabbit_queue_index)：负责维护队列中落盘消息的信息，包括消息的存储地点、消息在队列中的位置、是否已被交付给消费者、是否已被消费者 ack 等。每个队列都有与之对应的一个队列索引。消息存储(rabbit_msg_store)：而消息存储是以键值对的形式存储消息，它被所有队列共享，所以在每个节点中有且只有一个。从技术层面上来说，rabbit_msg_store 具体还可以分两类： msg_store_persistent ：负责持久化消息的持久化，重启后消息不会丢失。msg_store_transient：负责非持久化消息的持久化，重启后消息会丢失。
我们一般说消息存储，是习惯性地将 msg_store_persistent 和 msg_store_transient 看成 rabbit_msg_store 一个整体。 I have no name!@ed73deb9f1c5:/bitnami/rabbitmq/mnesia/rabbit@stats/msg_stores/vhosts/9PIHRMVSJH6VBOR100H7141ZT$ ls -al drwxr-xr-x. 2 1001 root 19 Oct 7 02:57 msg_store_persistent drwxr-xr-x. 2 1001 root 19 Oct 7 02:57 msg_store_transient 存在队列索引里的好处？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/096a3ecf635a4d22cac278856fdf79aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df5d99effe6efa40a45cf60eddcfbb35/" rel="bookmark">
			邻域搜索（Neighborhood Search ，NS）、大邻域搜索(Large NS , LNS)和自适应大邻域搜索（Adaptive LNS, ALNS）算法的联系与区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		邻域搜索（Neighborhood Search ，NS）、大邻域搜索(Large Neighborhood Search , LNS)和自适应大邻域搜索（Adaptive Large Neighborhood Search , ALNS）算法的联系与区别 邻域搜索算法、大邻域搜索算法和自适应大邻域搜索算法是一类用于求解组合优化问题的算法，它们在搜索问题解空间时有一些联系和区别。以下是它们之间的联系与区别：
1.邻域搜索算法（Neighborhood Search ，NS）：
基本思想： 邻域搜索算法通过在当前解的邻域内寻找更优解来不断改进当前解。
搜索策略： 典型的邻域搜索算法包括局部搜索、模拟退火、禁忌搜索等。这些算法使用不同的策略来生成邻域解，并选择改进的解进行移动。
特点： 邻域搜索算法通常从一个初始解开始，迭代地在邻域内搜索，直到找到一个满足某个停止条件的最优解或近似最优解。
2.大邻域搜索算法(Large Neighborhood Search , LNS)：
基本思想： 大邻域搜索算法与邻域搜索算法类似，但它更加聚焦于探索更大规模的邻域，通常会涉及到更多的解的改变。
搜索策略： 大邻域搜索算法通常会采用一些高级的邻域生成策略，以扩展搜索空间，例如，通过引入更多的约束条件或变量。
特点： 大邻域搜索算法的优点是可以更快地找到更优的解，但也可能会增加搜索的复杂性和计算成本。
3.自适应大邻域搜索算法（Adaptive Large Neighborhood Search , ALNS）：
基本思想： 自适应大邻域搜索算法结合了邻域搜索和大邻域搜索的思想，并具备自适应性，即根据问题的特性动态地调整搜索策略。
搜索策略： 这种算法会根据搜索的进展情况，选择合适的邻域大小和搜索策略，以平衡搜索速度和搜索效果。
特点： 自适应大邻域搜索算法试图在不同阶段充分利用大邻域的优势，同时避免因搜索空间过大而导致搜索难度增加的问题。
联系与区别： 1.邻域搜索算法是大邻域搜索算法和自适应大邻域搜索算法的基础。大邻域搜索和自适应大邻域搜索都可以被看作是邻域搜索的变种或扩展。
2.大邻域搜索专注于扩大搜索邻域，以期更快地找到更好的解，而邻域搜索一般使用较小的邻域。
3.自适应大邻域搜索算法结合了两者的优点，通过动态调整邻域大小和搜索策略，以适应问题的特性和搜索进展情况。
邻域搜索算法、大邻域搜索算法和自适应大邻域搜索算法都是启发式算法，用于处理组合优化问题。选择哪种算法取决于问题的性质和求解效率的需求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57919367cfd07d40bb39c48c8df2eb73/" rel="bookmark">
			机器学习之——K近邻（KNN）算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、k-近邻算法概述 1、算法介绍 k-近邻算法（K-Nearest Neighbors，简称KNN）是一种用于分类和回归的统计方法。KNN 可以说是最简单的分类算法之一，同时，它也是最常用的分类算法之一。
2、算法原理 k-近邻算法基于某种距离度量来找到输入样本在训练集中的k个最近邻居，并且根据这k个邻居的属性来预测输入样本的属性。
比如我们的输入样本是图中的蓝色，那么k个近邻就是距离绿色小圆最近的k个邻居，然后在这k个邻居中，若黑色小圆的数量多于红色小圆，那么输入样本的属性就与蓝黑色小圆相同，反之则与红色小圆的属性相同，这就是k-近邻算法的算法思想。
3、KNN算法中常用的距离指标 在knn算法中怎样计算输入点与其他向量点之间的距离呢？这里就用到了两种距离公式。
欧几里得距离
欧几里得距离是我们在平面几何中最常用的距离计算方法，即两点之间的直线距离。
曼哈顿距离
曼哈顿距离是计算两点在一个网格上的路径距离，与上述的直线距离不同，它只允许沿着网格的水平和垂直方向移动。
4、算法优缺点 优点：
准确度较高：K近邻算法准确度较高为它可以适应不同的数据分布。适用性广泛：K近邻算法可用于分类和回归问题，同时也支持多分类和多回归问题。实现简单：K近邻算法的实现非常简单，特别适用于初学者学习模式识别的入门算法 缺点：
计算复杂度高：当数据集很大时，计算距离的时间和空间开销都会很大，影响算法执行效率。受样本分布影响大：K近邻算法对训练集中样本的密度很敏感，对于密度相差很大的数据集，分类精度会受到较大影响。数据不平衡问题：当训练集中某些类别的样本数目远远大于其他类别的样本数目时，K近邻算法的准确度会明显下降。 5、算法流程 1、准备数据集： 收集数据集，包括特征与对应的类别标签
对数据进行预处理，例如数据清洗、归一化等。
2、选择k值： 选择一个合适的k值，即确定最近邻居的个数。
3、选择距离度量方法 确定用于比较样本之间相似性的度量方法，常见的如欧几里得距离、曼哈顿距离等。
4、确定最近邻居 选择与待分类样本距离最近的k个训练样本
5、预测 对于分类任务：查看K个最近邻居中最常见的类别，作为预测结果。
对于回归任务：预测结果可以是K个最近邻居的平均值或加权平均值。
6、评估 使用适当的评价的评级骄傲指标评估模型的性能。
7、优化 基于性能评估结果，可能需要返回并调整某些参数，如K值、距离度量方法等，以获得更好的性能。
二、knn分类算法实例——性别预测 1、想法：设计一个KNN分类来用人的身高和体重来预测人的性别。 2、创建数据集：创立一个包含身高，体重与性别的数据集用来训练模型。 3、读取数据集 # 准备数据：从文本文件中解析数据 import numpy as np def file2matrix(filename): #打开文件 fr = open(filename) arrayOLines = fr.readlines() #得到文件行数 numberOfLines = len(arrayOLines) #返回的NumPy矩阵 returnMat = np.zeros((numberOfLines,2)) #返回的分类标签向量 classLabelVector = [] #行的索引值 index = 0 for line in arrayOLines: line = line.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57919367cfd07d40bb39c48c8df2eb73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62419914b184bfc81544e3bc00c5b4c1/" rel="bookmark">
			mysql中varchar长度为多少
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. varchar存储规则： 4.0版本以下，varchar(20)，指的是20字节，如果存放UTF8汉字时，只能存6个（每个汉字3字节） 5.0版本以上，varchar(20)，指的是20字符，无论存放的是数字、字母还是UTF8汉字（每个汉字3字节），都可以存放20个，最大大小是65532字节 二. varchar和char 的区别： char是一种固定长度的类型，varchar则是一种可变长度的类型，它们的区别是： char(M)类型的数据列里，每个值都占用M个字节，如果某个长度小于M，MySQL就会在它的右边用空格字符补足．（在检索操作中那些填补出来的空格字符将被去掉）在varchar(M)类型的数据列里，每个值只占用刚好够用的字节再加上一个用来记录其长度的字节（即总长度为L+1字节）． 在MySQL中用来判断是否需要进行对数据列类型转换的规则
1、在一个数据表里，如果每一个数据列的长度都是固定的，那么每一个数据行的长度也将是固定的．
2、只要数据表里有一个数据列的长度的可变的，那么各数据行的长度都是可变的．
3、如果某个数据表里的数据行的长度是可变的，那么，为了节约存储空间，MySQL会把这个数据表里的固定长度类型的数据列转换为相应的可变长度类型．例外：长度小于4个字符的char数据列不会被转换为varchar类型
ps :被问到一个问题：MySQL中varchar最大长度是多少？ 这不是一个固定的数字。本文简要说明一下限制规则。
1、限制规则 字段的限制在字段定义的时候有以下规则：
a) 存储限制
varchar最多能存储65535个字节的数据。varchar 的最大长度受限于最大行长度（max row size，65535bytes）。65535并不是一个很精确的上限，可以继续缩小这个上限。65535个字节包括所有字段的长度，变长字段的长度标识（每个变长字段额外使用1或者2个字节记录实际数据长度）、NULL标识位的累计。
NULL标识位，如果varchar字段定义中带有default null允许列空,则需要需要1bit来标识，每8个bits的标识组成一个字段。一张表中存在N个varchar字段，那么需要（N+7）/8 （取整）bytes存储所有的NULL标识位。
如果数据表只有一个varchar字段且该字段DEFAULT NULL，那么该varchar字段的最大长度为65532个字节，即65535-2-1=65532 byte。
mysql&gt; create table t1 ( name varchar(65532) default null)charset=latin1; Query OK, 0 rows affected (0.09 sec) mysql&gt; mysql&gt; create table t2 ( name varchar(65533) default null)charset=latin1; ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62419914b184bfc81544e3bc00c5b4c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b90917f2feb9497ff85e8f82dbe311c3/" rel="bookmark">
			MySQL——使用mysqldump备份与恢复数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.mysqldump简介
2.mysqldump备份数据
2.1 备份所有数据库
2.2 备份一个/多个数据库
2.3 备份指定库中的指定表
3.mysqldump恢复数据
3.1 恢复数据库
3.2 恢复数据表
前言：mysqldump和binlog都可以作为MySQL数据库备份的方式：
mysqldump用于将整个或部分数据库导出为可执行的SQL文件，也可以用于导入或还原数据库，它可以创建一个数据库的逻辑备份，包括表结构和数据binlog（二进制日志）是一种事务日志，记录了对数据库进行的每个更改操作，如插入、更新、删除等。它用于增量备份和数据恢复，可以重放这些更改以还原到之前的状态 mysqldump和binlog的主要区别如下：
数据格式：mysqldump生成的备份文件是以文本形式保存的SQL语句，可以读取和修改。binlog则是以二进制格式保存的事务日志，不能直接查看或修改，需要专门的工具（如mysqlbinlog）进行解析和分析。备份范围：mysqldump可以备份整个数据库或特定的表，以及备份时可以选择备份的数据内容（例如只备份表结构、只备份数据等）。而binlog会记录所有的更改操作，包括对表结构和数据的更改，因此可以用来恢复到任何一个时间点之前的状态。使用场景：mysqldump适用于定期完整备份数据库或移植数据库，以便将数据导入到不同的MySQL服务器。binlog则适用于增量备份和恢复，可以用于故障恢复、数据同步、主从复制等场景。 通过binlog恢复数据传送门：通过binlog恢复数据https://blog.csdn.net/DreamEhome/article/details/130010601
1.mysqldump简介 mysqldump命令可以将数据库中指定或所有的库、表导出为SQL脚本。表的结构和表中的数据将存储在生成的SQL脚本中。
mysqldump备份恢复原理：通过先查出需要备份的库及表的结构，在SQL脚本中生成CREATE语句。然后将表中的所有记录转换成INSERT语句并写入SQL脚本中。这些CREATE语句和INSERT语句都是还原时使用的：还原数据时可使用其中的CREATE语句来创建表，使用INSERT语句还原数据。
环境准备：如下图所示，共准备了database_test1和database_test2两个数据库，每个数据库中都有两个表table_test1和table_test2(未演示database_test2，同database_test1)，每个表中各有一条数据。
2.mysqldump备份数据 备份的形式可以分为以下4种：
备份所有数据库（包含库中所有表及数据）备份一个/多个数据库（包含库中所有表及数据）备份指定库中的指定表（指定表及其数据） 下面将分别介绍如何实现这3种形式的数据备份。
2.1 备份所有数据库 语法：mysqldump -u[用户名] -p[密码] --all-databases &gt; /备份路径/备份文件名.sql
#备份全部数据库 mysqldump -uroot -p123456 --all-databases &gt; backup_all_databases.sql mysqldump
-uroot -p123456 登录MySQL的用户名/密码 --all-databases &gt;
backup_all_databases.sql 备份文件的名称，可加保存路径
2.2 备份一个/多个数据库 语法：mysqldump -u[用户名] -p[密码] --databases DB1 [DB2 DB3...] &gt; /备份路径/备份文件名.sql
#备份一个数据库 mysqldump -uroot -p123456 --databases database_test1 &gt; backup_database_test1.sql #备份多个数据库 mysqldump -uroot -p123456 --databases database_test1 database_test2 &gt; backup_database_test1_test2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b90917f2feb9497ff85e8f82dbe311c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce808181a345735f1de4bede75959a8b/" rel="bookmark">
			【数据结构】计数排序 &amp; 排序系列所有源代码 &amp; 复杂度分析（终章）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一，计数排序
1，基本思想
2，思路实现
3，计数排序的特性总结：
二，排序算法复杂度及稳定性分析
三，排序系列所有源代码
Sort.h
Sort.c
Stack.h
Stack.c
一，计数排序 计数排序也叫非比较排序；
1，基本思想 计数排序又称为鸽巢原理，是对哈希直接定址法的变形应用
操作步骤：
1，统计相同元素出现次数
2，根据统计的结果将序列回收到原来的序列中
图解原理：
对这样一个不需要比较的排序就完成了；
2，思路实现 // 计数排序 void CountSort(int* arr, int n) { int i = 0; int max = arr[0], min = arr[0]; //找最大，最小值 for (i = 0; i &lt; n; i++) { if (arr[i] &gt; max) { max = arr[i]; } if (arr[i] &lt; min) { min = arr[i]; } } //空间大小 int sum = max - min + 1; //开辟空间并且使元素值都为0 int* arr1 = (int*)calloc(sum, sizeof(int)); //给新数组赋值 for (i = 0; i &lt; n; i++) { arr1[arr[i] - min]++; } int j = 0; //回收到原来的序列中 for (i = 0; i &lt; sum; i++) { while (arr1[i]--) { arr[j++] = i + min; } } } 然后我们运行测试一下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce808181a345735f1de4bede75959a8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0bf73e290bb99003b820a8e4715bfb6/" rel="bookmark">
			Flutter运行报错：系统找不到指定的路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Flutter assets will be downloaded from https://storage.flutter-io.cn. Make sure you trust this source!
/F:/flutter/packages/flutter/lib/src/material/bottom_navigation_bar.dart:9:8: Error: Error when reading ‘/C:/Users/用户名/AppData/Local/Pub/Cache/hosted/pub.flutter-io.cn/vector_math-2.1.4/lib/vector_math_64.dart’: 系统找不到指定的路径�?
原因：可能是清空垃圾或者缓存，或者修改了AppData的路径。
解决方案：
# 清空之前的缓存，然后重新get一下 flutter clean flutter pub get #也可以更新一下flutter到最新版 flutter upgrade # 确保你的Flutter配置正确设置了下载源 flutter config 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad3b0d9d61da18441c43089bbd18297f/" rel="bookmark">
			开发日志：企业微信实现扫码登录（WEB）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：获取扫码登陆所需的参数：appid,secret,agentid
登录企业微信：https://work.weixin.qq.com/
扫码登录文档：https://work.weixin.qq.com/api/doc/90000/90135/90988
1：获取appid
点击我的企业就可以看到企业ID信息，这就是appid
2：获取secret和agentid
(1)：点击应用管理-》点击创建应用
(2)：应用创建完成之后我们就可以在应用中看到secret和agentid
2：配置企业微信授权登录
二：开发企业微信二维码登录功能
(1)：开发企业微信二维码登录页面
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="renderer" content="webkit"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"&gt; &lt;title&gt;企业微信扫码登录&lt;/title&gt; &lt;script src="http://rescdn.qqmail.com/node/ww/wwopenmng/js/sso/wwLogin-1.0.0.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body class="body"&gt; &lt;div id="wx_reg" style="text-align: center;margin-top: 10%;"&gt; &lt;/div&gt; &lt;script&gt; var wwLogin = new WwLogin({ "id": "wx_reg", "appid": "wwee5d37c708b1ecfb", "agentid": "1000020", "redirect_uri": encodeURIComponent('http://www.xxx.com/login/qywxlogin.ashx?type=qywxLogin'), "state": "lmg", "href":"", }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; (2)：开发企业微信二维码登录回调 qywxlogin.ashx
&lt;%@ WebHandler Language="C#" Class="qywxlogin" Debug="true" %&gt; using System; using System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad3b0d9d61da18441c43089bbd18297f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42e7c693c3c02c6f959399aaf3a572ec/" rel="bookmark">
			flutter开发实战-inappwebview实现flutter与Javascript的交互JSBridge
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		flutter开发实战-inappwebview实现flutter与Javascript的交互JSBridge
在使用webview中，需要实现flutter与Javascript交互，在使用webview_flutter插件的时候，整理了一下webview与Javascript的交互JSBridge，具体可以查看
https://blog.csdn.net/gloryFlow/article/details/131683122
这里使用inappwebview插件来实现flutter与Javascript的交互JSBridge。
一、什么是JSBridge JSBridge是一种实现webview与原生端的相互调用的能力。
在比较流行的JSBridge中，主要是通过拦截URL请求来达到 native 端和 webview 端相互通信的效果的。如WebviewJavascriptBridge。
那在inappwebview中有实现javascript交互的方式。在inappwebview中，可以使用JavaScript Handlers，来实现flutter端与javascript的交互。可以查看
https://blog.csdn.net/gloryFlow/article/details/133643136
二、修改JSBridge的JS端实现 在WebviewJavascriptBridge中，代码中使用iframe中，拦截url来达到webview与原生交互。那在inappwebview，我们可以直接嵌套使用JavaScript Handlers来实现交互。
我们定义WebviewJSBridgeReady
const String kWebviewJsBridgeReady = ''' window.onerror = function(err) { log('window.onerror: ' + err) } function setupWebViewJavascriptBridge(callback) { if (window.AppJSBridge) { return callback(AppJSBridge); } else { document.addEventListener('AppJSBridgeReady', function() { callback(AppJSBridge); },false); } } setupWebViewJavascriptBridge(function(bridge) { bridge.registerHandler('testJavascriptHandler', function(data, responseCallback) { var responseData = { 'Javascript Says':'Right back atcha!' } responseCallback(responseData) }); bridge.registerHandler('JSHandler', function(data, responseCallback) { var responseData = { 'Javascript Says':'Right back atcha!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42e7c693c3c02c6f959399aaf3a572ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af105e91495c05a43bc1d53c3334e875/" rel="bookmark">
			android槽位切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这里写自定义目录标题 手动切换android槽位 a槽位 b槽位1. 进入 fastboot2. 重启进入fastboot3. 切换4. 查看 手动切换android槽位 a槽位 b槽位 1. 进入 fastboot ssh root@223.255.255.1 可选命令
export $(cat /tmp/dbusenv.txt) slay lifecycle dbus-send --type=signal /ipcl.in.from.qx.LC2PM_INFO_NOTIFY array:byte:0x53,0x01,0x0 2. 重启进入fastboot reset -f 此时已经进入了fastboot，屏幕是黑的
3. 切换 fastboot set_active a //使a槽位变成active fastboot set_active b //使b槽位变成active 查看当前槽位
fastboot getvar current-slot A-&gt;B:swdl_utils -d 0 -l 1
B-&gt;A:swdl_utils -d 1 -l 1
4. 查看 getprop |grep slot fastboot reboot 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a253c5fac39dd9871e56cbc51609d9c9/" rel="bookmark">
			用PyTorch轻松实现二分类：逻辑回归入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💗💗💗欢迎来到我的博客，你将找到有关如何使用技术解决问题的文章，也会找到某个技术的学习路线。无论你是何种职业，我都希望我的博客对你有所帮助。最后不要忘记订阅我的博客以获取最新文章，也欢迎在文章下方留下你的评论和反馈。我期待着与你分享知识、互相学习和建立一个积极的社区。谢谢你的光临，让我们一起踏上这个知识之旅！
文章目录 🥦引言🥦什么是逻辑回归？🥦分类问题🥦交叉熵🥦代码实现🥦总结 🥦引言 当谈到机器学习和深度学习时，逻辑回归是一个非常重要的算法，它通常用于二分类问题。在这篇博客中，我们将使用PyTorch来实现逻辑回归。PyTorch是一个流行的深度学习框架，它提供了强大的工具来构建和训练神经网络，适用于各种机器学习任务。
在机器学习中已经使用了sklearn库介绍过逻辑回归，这里重点使用pytorch这个深度学习框架
🥦什么是逻辑回归？ 我们首先来回顾一下什么是逻辑回归？
逻辑回归是一种用于二分类问题的监督学习算法。它的主要思想是通过一个S形曲线（通常是Sigmoid函数）将输入特征映射到0和1之间的概率值，然后根据这些概率值进行分类决策。在逻辑回归中，我们使用一个线性模型和一个激活函数来实现这个映射。
🥦分类问题 这里以MINIST Dataset手写数字集为例
这个数据集中包含了6w个训练集1w个测试集，类别10个
这里我们不再向之前线性回归那样，根据属于判断具体的数值大小；而是根据输入的值判断从0-9每个数字的概率大小记为p（0）、p（1）…而且十个概率值和为1，我们的目标就是根据输入得到这十个分类对于输入的每一个的概率值，哪个大就是我们需要的。
这里介绍一下与torch相关联的库—torchvision
torchvision：
“torchvision” 是一个PyTorch的附加库，专门用于处理图像和视觉任务。
它包含了一系列用于数据加载、数据增强、计算机视觉任务（如图像分类、目标检测等）的工具和数据集。“torchvision” 提供了许多预训练的视觉模型（例如，ResNet、VGG、AlexNet等），可以用于迁移学习或作为基准模型。
此外，它还包括了用于图像预处理、转换和可视化的函数。 上图已经清楚的显示了，这个库包含了一些自带的数据集，但是并不是我们安装完这个库就有了，而且需要进行调用的，类似在线下载，root指定下载的路径，train表示你需要训练集还是测试集，通常情况下就是两个一个训练，一个测试，download就是判断你下没下载，下载了就是摆设，没下载就给你下载了
我们再来看一个数据集（CIFAR-10）
包含了5w训练样本，1w测试样本，10类。调用方式与上一个类似。
接下来我们从一张图更加直观的查看分类和回归
左边的是回归，右边的是分类
过去我们使用回归例如 y ^ \hat{y} y^​=wx+b∈R，这是属于一个实数的；但是在分类问题， y ^ \hat{y} y^​∈[0,1]
这说明我们需要寻找一个函数，将原本实数的值经过函数的映射转化为[0,1]之间。这里我们引入Logistic函数，使用极限很清楚的得出x趋向于正无穷的时候函数为1，x趋向于负无穷的时候，函数为0，x=0的时候，函数为0.5，当我们计算的时候将 y ^ \hat{y} y^​带入这样就会出现一个0到1的概率了。
下图展示一些其他的Sigmoid函数
🥦交叉熵 过去我们所使用的损失函数普遍都是MSE，这里引入一个新的损失函数—交叉熵
==交叉熵（Cross-Entropy）==是一种用于衡量两个概率分布之间差异的数学方法，常用于机器学习和深度学习中，特别是在分类问题中。它是一个非常重要的损失函数，用于衡量模型的预测与真实标签之间的差异，从而帮助优化模型参数。
在交叉熵的上下文中，通常有两个概率分布：
真实分布（True Distribution）： 这是指问题的实际概率分布，表示样本的真实标签分布。通常用 p ( x ) p(x) p(x)表示，其中 x x x表示样本或类别。
预测分布（Predicted Distribution）： 这是指模型的预测概率分布，表示模型对每个类别的预测概率。通常用 q ( x ) q(x) q(x)表示，其中 x x x表示样本或类别。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a253c5fac39dd9871e56cbc51609d9c9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/578/">«</a>
	<span class="pagination__item pagination__item--current">579/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/580/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>