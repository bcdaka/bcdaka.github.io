<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a97a0f95b7960588cd6e75a50b6f804/" rel="bookmark">
			【postgresql初级使用】条件表达式触发器，兼顾DML执行性能，又能执行复杂逻辑，只在结帐时计算总帐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		条件触发器 ​专栏内容：
postgresql使用入门基础手写数据库toadb并发编程 个人主页：我的主页
管理社区：开源数据库
座右铭：天行健，君子以自强不息；地势坤，君子以厚德载物.
文章目录 条件触发器概述 原理机制 语法 原理 案例 场景介绍 数据准备 创建触发器 效果验证 总结 结尾 概述 触发器trigger 是语句级的(row-level) 时, 被触发的频率是相当高的，会带来一定的性能开销。
今天给大家分享一种带有条件表达式的触发器，只在条件满足时触发，其它情况下并不会执行，这样既能满足触发器的复杂处理，也能满足性能的要求。
原理机制 下面就来详细了解一下带条件表达式的触发器吧。
语法 带条件表达式的触发器的SQL语法格式如下：
CREATE TRIGGER trigger_name {BEFORE | AFTER} { INSERT OR UPDATE OR DELETE OR TRUNCATE } ON table_name WHEN condition FOR [EACH] ROW EXECUTE FUNCTION function_name(); 说明
这里与普通触发器的语法类似，可以参见前面的分享；如果是行级的触发器，需要指定BEFORE或AFTER以及对应的事件；此处通过WHEN子句指定触发的条件，只有在条件满足时才能执行；触发器类型指定，行级触发器为FOR EACH ROW；最后指定触发器执行函数； 原理 在行级触发器中：
可以访问修改前的行与修改后的行，通过访问这两行的值设定条件表达式。修改前的行使用OLD.column_name进行引用，修改后的行引用方式为 NEW.column_name；INSERT命令没有OLD行，DELETE命令没有NEW行；INSTEAD OF不支持设置条件； 而在语句级触发器中没有可引用的行数据。
案例 下面我们通过一个案例来看看条件触发器的使用场景。
场景介绍 当在饭店消费时，会先点一些菜，过程中又会根据需要再加一些菜或者饮品，最后再统一结帐。
对于这样一个很常见的场景，通过条件触发器可以实现自动计算账单。
数据准备 新建两张表，一张为订单表，记录客户消费情况，以及订单状态；另一张为客户统计，记录客户总的消费金额。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a97a0f95b7960588cd6e75a50b6f804/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/431225d199a0358da0aca3f3139d9fb6/" rel="bookmark">
			python GUI开发: tkinter选项卡，移动滑块，颜色选择框，文本对话框，对话输入框，通用消息框模块用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨✨ 欢迎大家来到景天科技苑✨✨
🎈🎈 养成好习惯，先赞后看哦~🎈🎈
🏆 作者简介：景天科技苑
🏆《头衔》：大厂架构师，华为云开发者社区专家博主，阿里云开发者社区专家博主，CSDN全栈领域优质创作者，掘金优秀博主，51CTO博客专家等。
🏆《博客》：Python全栈，前后端开发，小程序开发，人工智能，js逆向，App逆向，网络系统安全，数据分析，Django，fastapi，flask等框架，linux，shell脚本等实操经验，网站搭建，数据库等分享。
所属的专栏：python图形化GUI编程tkinter精讲
景天的主页：景天科技苑
文章目录 tkinter其他组件1.OptionMenu 选择项【示例】OptionMenu(选择项)的基本用法 2.Scale 移动滑块【示例】使用 Scale(移动滑块)控制字体大小变化 3.颜色选择框【示例】颜色选择框基本用法 4.文件对话框【示例】文件对话框基本用法【示例】打开指定 txt 文件，并读出文件内容到窗口 5.简单输入对话框【示例】简单对话框基本用法 6.通用消息框【示例】通用消息框案例展示 tkinter其他组件 我们在前面介绍了最常用的几个组件，接下来我们介绍其他一些组件。
1.OptionMenu 选择项 OptionMenu(选择项)用来做多选一，选中的项在顶部显示。
OptionMenu（选择菜单）事实上是下拉菜单的改版，它的发明弥补了 Listbox 组件无法实现下拉列表框的遗憾。
【示例】OptionMenu(选择项)的基本用法 """optionmenu的使用测试""" from tkinter import * root = Tk() root.geometry("250x120+200+300") root.title('选项卡测试') #设置个变量 v = StringVar() #默认选中百战程序员 v.set("百战程序员") #创建选项卡,后面选项都通过普通实参传参即可，不可用关键字传参 om = OptionMenu(root, v, "景天科技苑", "百战程序员", "卓越班[保底20万]","天涯课堂") om["width"] = 12 om.pack() def test1(): #选中哪个，就把哪个打印出来 print("最喜爱的机构:", v.get()) # v.set("景天科技苑") # 直接修改了optionmenu中选中的值 #按钮绑定事件，点击确定，打印出最喜欢的机构 Button(root, text="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/431225d199a0358da0aca3f3139d9fb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/442083f707863a1b74cc36ab36e13c11/" rel="bookmark">
			SpringBoot3整合SpringDoc实现在线接口文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 在现目前项目开发中，一般都是前后端分离项目。前端小姐姐负责开发前端，苦逼的我们负责后端开发
事实是一个人全干，在这过程中编写接口文档就显得尤为重要了。然而作为一个程序员，最怕的莫过于自己写文档和别人不写文档
大家都不想写文档，那这活就交给今天的主角Swagger来实现了
一、专业名词介绍 ①OpenApi是什么？
解答：OpenApi是一个用于描述、定义和共享 RESTful API 文档的规范。最新规范是 OpenAPI 3.0
② Swagger是什么？
解答： Swagger 是一个用于设计和测试 RESTful APIs 的工具。
它提供了API 描述、请求和响应示例、API 测试和文档生成等丰富的功能。最新版本是Swagger3,支持OpenAPI3.0规范
③ SpringFox 是什么？
SpringFox 是 Spring 社区维护的一个项目（非官方），帮助使用者将 Swagger 2 集成到 Spring 中。
目前国内项目使用的都是它
github地址：https://github.com/springfox/springfox
④springDoc是什么？
解答： Spring-doc也是 Spring 社区维护的一个项目（非官方），帮助使用者将 Swagger 3 集成到 Spring 中
SpringDoc 支持 Swagger 页面 Oauth2 登录，相较于 SpringFox 而言，它的支撑时间更长，无疑是更好的选择。
但是在国内发展较慢，网上一找资料，出来的基本上是 Swagger2的内容。
地址：https://springdoc.org/
⑤ OpenAPI 、Spring-doc和 Swagger 之间的关系
解答：OpenAPI 定义了一种标准的格式来表示 API 文档，而 Swagger 是一个实现 OpenAPI 规范的工具
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/442083f707863a1b74cc36ab36e13c11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2e6079b665a380d9bb7c6c693022e41/" rel="bookmark">
			AI学习指南机器学习篇-KNN算法超参数选择与调优
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI学习指南机器学习篇-KNN算法超参数选择与调优 在机器学习领域中，K最近邻（KNN）算法是一种简单而又常用的分类和回归方法。它的工作原理是通过计算样本之间的距离来进行分类或预测。在实际应用中，KNN算法的性能很大程度上取决于超参数的选择和调优。本文将详细探讨KNN算法中的超参数选择和调优问题，包括K值的选择和距离度量方法的选择，并介绍如何通过交叉验证等方法进行超参数调优。
KNN算法简介 KNN算法是一种基于实例的学习方法，它的核心思想是样本的类别由其最近邻居的类别决定。在KNN算法中，要预测一个新样本的类别或值，首先需要找到训练集中离该样本最近的K个样本，然后根据这K个最近邻居的类别或值来进行预测。KNN算法的优点是易于理解和实现，适用于多分类和回归问题，但同时也存在着计算复杂度高、对异常值敏感等缺点。
KNN算法中的超参数 在KNN算法中，有两个重要的超参数需要进行选择和调优，即K值和距离度量方法。K值表示在进行预测时需要考虑的最近邻居的数量，而距离度量方法用来衡量样本之间的距离，常见的距离度量方法包括欧式距离、曼哈顿距离、闵可夫斯基距离等。超参数的选择对KNN算法的性能有着重要的影响，下面将分别介绍这两个超参数的选择原则。
K值的选择 K值的选择是KNN算法中最关键的超参数之一，不恰当的K值会导致模型的过拟合或欠拟合。通常来说，K值较小会使模型对噪声敏感，容易受到单一异常值的影响，而K值较大则会使模型的决策面更加平缓，容易受到样本分布不均匀的影响。因此，选择合适的K值对于KNN算法的性能至关重要。
K值的选择可以通过交叉验证方法来进行。通常通过将训练集划分为若干份，然后分别对每一份数据进行KNN算法的训练和验证，最后取性能最佳的K值作为最终的选择。在实际应用中，一般采用K折交叉验证或留一交叉验证等方法。
距离度量方法的选择 在KNN算法中，距离度量方法是用来衡量样本之间的距离，从而找到最近的K个邻居。常用的距离度量方法包括欧式距离、曼哈顿距离、闵可夫斯基距离等。不同的距离度量方法适用于不同的数据类型和分布，因此选择合适的距离度量方法对于KNN算法的性能也非常重要。
对于距离度量方法的选择，一般需要根据实际数据的特点进行调整。在多数情况下，欧式距离是最常用的距离度量方法，特别适用于连续型数据。而曼哈顿距离适用于城市街区间的样本距离度量。在实际应用中，我们也可以结合交叉验证等方法来选择最适合的距离度量方法。
超参数调优 超参数的选择和调优对于模型的性能有着重要的影响，是机器学习中的一个重要环节。在KNN算法中，通过选择合适的K值和距离度量方法可以提高模型的性能。在实际应用中，超参数的调优可以通过网格搜索、随机搜索和贝叶斯优化等方法来实现。
网格搜索 网格搜索是一种基于遍历的超参数搜索方法，它的原理是通过定义一个超参数空间，然后对该空间进行穷举搜索，最终找到最优的超参数组合。在KNN算法中，可以通过定义K值的范围和距离度量方法的选择范围，然后对这两个超参数空间进行穷举搜索，最终找到最优的超参数组合。
from sklearn.model_selection import GridSearchCV from sklearn.neighbors import KNeighborsClassifier param_grid = {"n_neighbors": [3, 5, 7], "metric": ["euclidean", "manhattan"]} knn = KNeighborsClassifier() grid_search = GridSearchCV(knn, param_grid, cv=5) grid_search.fit(X_train, y_train) print("Best parameters: {}".format(grid_search.best_params_)) 随机搜索 随机搜索是一种基于随机抽样的超参数搜索方法，它的原理是通过对超参数空间进行随机抽样，然后根据预先定义的搜索次数找到最优的超参数组合。在KNN算法中，可以通过随机抽样K值和距离度量方法，然后根据预先定义的搜索次数找到最优的超参数组合。
from sklearn.model_selection import RandomizedSearchCV from scipy.stats import randint param_dist = {"n_neighbors": randint(3, 10), "metric": ["euclidean", "manhattan"]} knn = KNeighborsClassifier() random_search = RandomizedSearchCV(knn, param_dist, n_iter=10, cv=5) random_search.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2e6079b665a380d9bb7c6c693022e41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46b912b049dd7b4ce12b7d29df3e7770/" rel="bookmark">
			SQLite Delete 语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQLite Delete 语句 SQLite 的 DELETE 语句用于从表中删除数据。它是 SQL 数据库管理中非常基础且重要的操作之一。在使用 DELETE 语句时，可以删除表中的特定行，也可以删除整个表的数据。本文将详细介绍 SQLite 中的 DELETE 语句，包括其语法、用法以及如何安全地执行删除操作。
DELETE 语句的基本语法 SQLite 中的 DELETE 语句的基本语法如下：
DELETE FROM table_name WHERE condition; table_name 是你希望删除数据的表的名称。WHERE 子句是可选的，用于指定删除哪些行的条件。如果不使用 WHERE 子句，将会删除表中的所有行。 删除特定行 当你只想删除满足特定条件的行时，可以在 DELETE 语句中使用 WHERE 子句。例如，假设我们有一个名为 employees 的表，我们想要删除所有工资低于 3000 的员工，可以使用以下语句：
DELETE FROM employees WHERE salary &lt; 3000; 执行这条语句后，employees 表中所有 salary 小于 3000 的行将被删除。
删除所有行 如果不指定 WHERE 子句，DELETE 语句将删除表中的所有行。例如：
DELETE FROM employees; 这条语句将删除 employees 表中的所有数据，但不会删除表结构。
注意事项 在执行 DELETE 语句时，应该非常小心，因为一旦执行，被删除的数据将无法恢复。以下是一些最佳实践：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46b912b049dd7b4ce12b7d29df3e7770/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbd0004026d8a5a1b22af528cdea6c66/" rel="bookmark">
			mysql之介绍CAST函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CAST 函数在 SQL 中用于将一种数据类型转换为另一种数据类型。在 MySQL 中，你可以使用 CAST() 函数来显式地进行数据类型转换，这在你需要确保数据以特定格式处理时非常有用。
以下是 CAST() 函数的基本语法：
CAST(expression AS type) expression：要转换的表达式。
type：你希望转换到的目标数据类型，它可以是以下类型之一：
BINARY：转换为二进制字符串。
CHAR：转换为非二进制字符串。
DATE：转换为日期值。
DATETIME：转换为日期和时间值。
DECIMAL：转换为定点数。
SIGNED：转换为有符号整数。
UNSIGNED：转换为无符号整数。
TIME：转换为时间值。
DOUBLE：转换为双精度浮点数。
FLOAT：转换为单精度浮点数。
使用 CAST() 函数时，你需要指定你想要转换的表达式，以及你希望转换到的数据类型。
以下是一些使用 CAST() 函数的示例：
将字符串转换为整数：
SELECT CAST('123' AS SIGNED); 这将返回整数 123。
将整数转换为日期：
SELECT CAST(20210101 AS DATE); 这将返回日期 2021-01-01。
将字符串转换为日期和时间：
SELECT CAST('2021-01-01 13:14:15' AS DATETIME); 这将返回日期和时间 2021-01-01 13:14:15。
将浮点数转换为定点数：
SELECT CAST(123.45678 AS DECIMAL(10,2)); 这将返回定点数 123.46，保留两位小数。
将字符串转换为二进制字符串：
SELECT CAST('hello' AS BINARY); 这将返回字符串 'hello' 的二进制表示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbd0004026d8a5a1b22af528cdea6c66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1731c1dec03945e2196dfd864378b426/" rel="bookmark">
			【ComfyUI】Stable Diffusion 3 加Controlnet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于 instantX-research/diffusers_sd3_control: 🤗 Diffusers: State-of-the-art diffusion models for image and audio generation in PyTorch and FLAX. (github.com)
和 ZHO-ZHO-ZHO/ComfyUI-SD3-Medium-CN-Diffusers: ComfyUI SD3-Medium ControlNet（Diffusers） (github.com)
改的，这两个repo都有些问题，中间看提交记录，有好些人在参与改动，为了能跑的了，我分别fork了这两个分支， 在这里：
prodogape/ComfyUI-SD3-Medium-CN-Diffusers: ComfyUI SD3-Medium ControlNet（Diffusers） (github.com)
prodogape/diffusers_sd3_control: refactor name from "diffusers" to "diffusers_sd3_control" (github.com)
1. 先说怎么装 打开第一个橘色背景的repo：
prodogape/ComfyUI-SD3-Medium-CN-Diffusers: ComfyUI SD3-Medium ControlNet（Diffusers） (github.com)
按照Install这里的步骤安装
时间有限只写了手动安装的步骤，分4步：
（1）git 克隆 comfyui的节点
（2）下载hf的两个仓库的模型（一个controlnet一个sd3）
（3）修改sd3模型文件夹下的文件model_index.json，因为要安装的特殊版本的diffusers我改名为diffusers_sd3_control了
（4）安装diffusers_sd3_control
2. 工作流及效果 这个版本的实现应该还是有些问题的，可能跟control的百分比和control了不太对的部分有关
3. 上图的工作流（非API版本工作流） { "last_node_id": 82, "last_link_id": 139, "nodes": [ { "id": 77, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1731c1dec03945e2196dfd864378b426/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8e750514d331e4e0d881cf20ebe4b09/" rel="bookmark">
			mac如何检测硬盘损坏 常用mac硬盘检测坏道工具推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mac有时候也出现一些问题，比如硬盘损坏。硬盘损坏会导致数据丢失、系统崩溃、性能下降等严重的后果，所以及时检测和修复硬盘损坏是非常必要的。那么，mac如何检测硬盘损坏呢？有哪些常用的mac硬盘检测坏道工具呢？
一、mac如何检测硬盘损坏 mac系统自带了一个名为“磁盘工具”的应用程序，可以用来检测和修复硬盘的一些问题。你可以通过以下步骤来使用“磁盘工具”：
1、打开“应用程序”文件夹，找到并双击“实用工具”文件夹，再找到并双击“磁盘工具”图标。
图1：磁盘工具
2、在“磁盘工具”的左侧栏中，选择你想要检测的硬盘或分区。
3、在“磁盘工具”的上方栏中，点击“急救”按钮。
4、在弹出的窗口中，点击“运行”按钮，开始检测硬盘。
图2：急救
5、等待检测完成后，查看结果。如果显示“操作成功”，则说明没有发现任何问题；如果显示“磁盘需要修复”，则说明发现了一些问题，需要进一步修复；如果显示“磁盘无法修复”，则说明问题很严重，可能需要更换硬盘。
图3：检测完成
6、如果需要修复硬盘，请点击“继续”按钮，并按照提示操作。请注意，在修复过程中，请不要关闭电源或中断操作，否则可能造成更大的损害。
二、常用mac硬盘检测坏道工具推荐 除了系统自带的“磁盘工具”外，还有一些第三方的软件可以用来检测和修复mac硬盘的坏道。坏道是指硬盘上无法读写或存储数据的区域，通常是由于物理损伤或老化造成的。坏道会影响硬盘的正常运行和数据安全，所以及时发现和处理坏道是非常重要的。
以下是一些常用的mac硬盘检测坏道工具推荐：
1、Tuxera NTFS for mac 这是一个专业的Mac NTFS格式驱动器读写软件，可以让你在mac上轻松访问和管理NTFS格式的存储设备。Tuxera NTFS for mac不仅提供了高速稳定的读写性能，还提供了一个名为Disk Manager的功能，可以让你在mac上对NTFS格式驱动器进行格式化、分区、检测和修复等操作。
Tuxera NTFS for mac 2023中文免费安装包下载：https://souurl.cn/IE35lO
​​​​​​​Tuxera NTFS for mac激活码获取（永久使用）：https://souurl.cn/kg02Ve
图4：Disk Manager
2、DriveDx 这是一个专业的mac硬盘健康监测和诊断软件，可以实时监控硬盘的温度、性能、寿命等指标，并提供详细的报告和建议。DriveDx还可以预警潜在的硬盘故障，并提供数据备份和恢复功能。DriveDx支持多种类型的硬盘和固态驱动器（SSD），并且有着简洁友好的用户界面。
图5：DriveDX
三、总结 本文介绍了mac如何检测硬盘损坏，以及常用mac硬盘检测坏道工具推荐。其中，“磁盘工具”是系统自带的应用程序，第三方工具有各自的特点和优势，你可以根据自己的需求选择合适的工具来保护你的mac硬盘和数据。希望本文对你有所帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3795a768d700995ec4404c970650eedc/" rel="bookmark">
			Python - 一个恶意脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python - 恶意脚本 使用此脚本或修改前请注意以下几点：
系统资源：大量模拟键盘和鼠标事件可能会占用大量系统资源，会导致其他应用程序运行缓慢或崩溃。
隐私和安全：如果此脚本在未经用户同意的情况下运行，它可能侵犯了用户的隐私和安全。
法律责任：在某些情况下，未经授权地发送大量消息可能构成违法行为，并可能导致法律责任。
pynput库用于模拟键盘和鼠标操作，在实际使用中，您应该确保这样的操作是合法的，并遵守您所在地区的相关法律法规。此外，滥用这种自动化工具可能会导致您的账户被封禁或其他不良后果。
在使用此类代码时，请确保您拥有合法的权限和目的，并避免对任何系统或网络进行非法或未经授权的访问。在未经许可的情况下，使用此类代码发送大量消息可能被视为恶意行为，并可能导致法律后果。
本代码仅用于学习和教育目的，在学习和实验过程中，请确保你的行为合法、合规，并避免对他人或网络造成任何损害。
__author__ = 'Mac' __date__ = '19/10/31 15:05' import time from pynput.keyboard import Controller as KeyController from pynput.mouse import Button, Controller as MouseController def keyboard_input(string): """ 模拟键盘输入给定的字符串。 :string: 要模拟输入的字符串 :return: None """ keyboard = KeyController() for char in string: keyboard.press(char) keyboard.release(char) time.sleep(0.05) # 稍微延迟一下，避免发送过快 def mouse_click(): """ 模拟鼠标点击左键，用于发送消息。 """ mouse = MouseController() mouse.press(Button.left) mouse.release(Button.left) def main(number, message): """ 主函数，控制发送消息的次数和内容。 :number: 要发送的消息数量 :message: 要发送的消息内容 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3795a768d700995ec4404c970650eedc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e3c6b0ccd16276e6349cfb0b237e8e8/" rel="bookmark">
			uniapp 微信小程序更改轮播图指示点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 仅微信小程序有效
/* #ifdef MP-WEIXIN */ // 默认指示点样式 wx-swiper .wx-swiper-dot { position: relative; background-color: #ffffff; width: 28rpx; border-radius: 10rpx; height: 8rpx; opacity: 0.4; } // 当前选中样式 wx-swiper .wx-swiper-dot-active { background-color: #ffffff; width: 48rpx; border-radius: 10rpx; opacity: 10; } /* #endif */ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/481d5ac91b3406440488fd41e60a4b48/" rel="bookmark">
			大学生毕设神器 | 二手房房源分析 二手房房源爬虫 基于Python的二手房可视化分析 基于大数据的二手房可视化分析 基于sklearn的二手房房价预测 基于随机森林的二手房房价预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥作者主页：疯狂行者🔥 💖✌java领域优质创作者,专注于Java技术领域技术交流✌💖
💖文末获取源码💖
精彩专栏推荐订阅：在 下方专栏👇🏻👇🏻👇🏻👇🏻
Java精彩实战项目案例 Java精彩新手项目案例 Python精彩新手项目案例 文章目录 Java精彩实战项目案例Java精彩新手项目案例Python精彩新手项目案例 前言一、系统功能1.1 开发环境 二、系统设计2.1 架构分析2.2 系统功能结构2.2.1. 数据爬虫2.2.2. 数据可视化2.2.3. 数据管理2.2.4. 算法应用 三、部分功能展示四、部分代码设计4.1.登录【代码如下（示例）：】4.2.退出登录【代码如下（示例）：】4.3.查询数据【代码如下（示例）：】 总结&lt;font color=#999AAA &gt;源码获取：Java精彩实战项目案例Java精彩新手项目案例Python精彩新手项目案例 前言 大学生毕设神器 | 二手房房源分析 二手房房源爬虫 基于Python的二手房可视化分析 基于大数据的二手房可视化分析 基于sklearn的二手房房价预测 基于随机森林的二手房房价预测
一、系统功能 1.1 开发环境 开发语言：Python - 技术：Django数据库：MySQL - 架构：B/S - 源码类型： Web编译工具：Pycharm爬虫技术：selenium数据清洗：BeautifulSoup算法（可选装）：知识图谱 房价预测 二、系统设计 2.1 架构分析 本系统采用B/S架构，前端UI使用Bootstrap框架结合Echarts以及d3进行数据可视化展示，提供清晰、直观的用户界面。业务层基于Django框架进行设计，负责处理数据爬取、数据处理与逻辑分析等核心功能。数据层以MySQL数据库为基础，存储爬取的房源数据及用户信息，而基础服务包括Windows操作系统或者Nginx服务器，确保系统稳定运行。
各层功能说明：
客户端浏览器：用户通过浏览器访问系统的前端界面，进行数据查询、可视化查看和操作。
Web服务器：Nginx作为反向代理服务器，Django处理业务逻辑、数据爬取和数据分析。
MySQL数据库：存储爬取的房源数据、房源详情、用户信息等。
2.2 系统功能结构 在当前课题的功能模块设计中，主要包含以下几个部分：
2.2.1. 数据爬虫 房源数据爬虫：定期从各大房产网站爬取房源数据，包括房源名称、区域、价格、面积等。
房源详情爬虫：爬取每个房源的详细信息，如房屋结构、朝向、装修风格等。
房源评论爬虫：爬取用户对房源的评论数据，包括评论内容、评论时间、用户评分等。
2.2.2. 数据可视化 房源数据可视化：使用Echarts展示房源数据的趋势图、柱状图等。
房源价格分布：展示房源价格的分布情况，通过直方图、饼图等形式直观展示。
评论词云：通过Echarts生成房源评论的词云图，展示评论中出现频率最高的词汇。
2.2.3. 数据管理 房源数据管理：提供界面让管理员查看、添加、修改、删除房源数据。
评论数据管理：管理员可以查看和管理用户评论数据，处理不良评论。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/481d5ac91b3406440488fd41e60a4b48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c898692080a60d2b87906a1c495fa68/" rel="bookmark">
			C语言：文件操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
​
为什么使用文件
什么是文件？
程序文件
数据⽂件
文件名
二进制文件和文本文件
文件的打开和关闭
流和标准流、
流
标准流
文件指针
文件的打开和关闭
文件打开方式
文件的顺序读写
fputc函数示范（写字符）
fgetc函数示范（读字符）
（字符）stdin标准输入流和stdout标准输出流
fputs函数的示范（写字符串）
fgets函数示范（读字符串）
(字符串)stdin标准输入流和stdout标准输出流
fprintf(写整数，浮点数，字符，字符串)
fscanf(读整数，浮点数，字符，字符串)
（整数，浮点数，字符，字符串）stdin标准输入流和stdout标准输出流
对比一组函数：
fwrite函数
fread函数
文件的随机读写
fseek
从文件开头向后偏移
从光标位置偏移
文件末尾向前面偏移
ftell函数
rewind函数
⽂件读取结束的判定
拷贝字符串代码
文件缓冲区
为什么使用文件 如果没有⽂件，我们写的程序的数据是存储在电脑的内存中，如果程序退出，内存回收，数据就丢失了，等再次运⾏程序，是看不到上次程序的数据的，如果要将数据进⾏持久化的保存，我们可以使⽤⽂件，因为文件是存放在硬盘上的
什么是文件？ 磁盘上的⽂件和文件夹都是⽂件。
但是在程序设计中，我们⼀般谈的⽂件有两种：程序⽂件、数据⽂件（从⽂件功能的⻆度来分类
的）。
程序文件 程序⽂件包括源程序⽂件（后缀为.c）,
⽬标⽂件（windows环境后缀为.obj）,
可执⾏程序（windows环境后缀为.exe）。
程序文件
目标文件
可执行程序
数据⽂件 ⽂件的内容不⼀定是程序，⽽是程序运⾏时读写的数据，⽐如程序运⾏需要从中读取数据的⽂件，或者输出内容的⽂件。
本篇讨论的是数据⽂件。
在以前各章所处理数据的输⼊输出都是以终端为对象的，即从终端的键盘输⼊数据，运⾏结果显⽰到显⽰器上。
其实有时候我们会把信息输出到磁盘上，当需要的时候再从磁盘上把数据读取到内存中使⽤，这⾥处理的就是磁盘上⽂件。
文件名 ⼀个⽂件要有⼀个唯⼀的⽂件标识，以便⽤⼾识别和引⽤。
⽂件名包含3部分：⽂件路径+⽂件主⼲名+⽂件后缀
例如： c:\code\test.txt
为了⽅便起⻅，⽂件标识常被称为⽂件名。
二进制文件和文本文件 根据数据的组织形式，数据⽂件被称为⽂本⽂件或者⼆进制⽂件。
数据在内存中以⼆进制的形式存储，如果不加转换的输出到外存，就是⼆进制⽂件。
如果要求在外存上以ASCII码的形式存储，则需要在存储前转换。以ASCII字符的形式存储的⽂件就是⽂本⽂件。
⼀个数据在内存中是怎么存储的呢
字符⼀律以ASCII形式存储，数值型数据既可以⽤ASCII形式存储，也可以使⽤⼆进制形式存储。
如有整数10000，如果以ASCII码的形式输出到磁盘，则磁盘中占⽤5个字节（每个字符⼀个字节），⽽⼆进制形式输出，则在磁盘上只占4个字节（VS2019测试）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c898692080a60d2b87906a1c495fa68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/953d874d9f10bcbff18325d99f70dcf3/" rel="bookmark">
			Novartis诺华制药社招综合能力性格动机问卷入职测评笔试题库答案及包过助攻
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【华东同舟求职】由资深各行业从业者建立的一站式人才服务网络平台，现阶段目标是“提升全市场各行业岗位信息的流动性和透明度”。我们接受众多行业机构的直接委托发布，并尽力通过各种方法搜寻高价值岗位信息。事实上，我们以发现不为人知的优质岗位为乐趣。
【华东同舟求职】一站式求职测评笔试题库平台
▶️小程序：华东同舟求职（推荐手机）一站式求职测评笔试题库
▶️H5网页：www.tongzhouqiuzhi.com/h5（推荐电脑）
▶️电脑网页：www.tongzhouqiuzhi.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f74b12baaa5d494b76c1a05e0241e9bd/" rel="bookmark">
			【C语言】排序算法 -------- 计数排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人主页
创作不易，感谢大家的关注！
文章目录 1. 计数排序的概念2. 计数排序使用场景3. 计数排序思想4. 计数排序实现过程5. 计数排序的效率6. 总结（附源代码） 1. 计数排序的概念 计数排序是一种非比较的排序算法，其基本思想是统计待排序元素中小于等于每个元素的个数，从而确定每个元素的位置。
2. 计数排序使用场景 计数排序适用于以下几种情况：
数据的取值范围比较小，序列中最大值和最小值之间的差值不能过大，防止建立数组时造成内存浪费。数据是整数类型，不能为浮点数类型。 3. 计数排序思想 计数排序的核心是：利用数组的索引是有序的前提下，通过将序列中的元素作为索引，其个数作为值放入数组，遍历数组来排序。
4. 计数排序实现过程 方法步骤如下：
先选出待排序序列中的最小数和最大数。给出一个范围range，为 max-min+1。创建一个count数组，大小为每个元素的大小。遍历待排序数组，统计每个元素出现的次数，并将其存储在count数组中。本质是利用count数组的自然序号排序。根据count数组中的元素，遍历依次更新待排序数组中的元素，实现排序。统计count数组里的每个元素出现的次数，然后映射给tmp数组。（使用相对映射）将tmp数组里不为0的元素的下标+min反赋给数组count,遍历结束,排序完成。 5. 计数排序的效率 时间复杂度：O（N+range），N为待排序序列的长度，range为max-min+1的大小。
空间复杂度：O（range）。
稳定性：稳定。
6. 总结（附源代码） #define _CRT_SECURE_NO_WARNINGS 1 void PrintArray(int* a, int n); void CountSort(int* a, int n); void PrintArray(int* a, int n) { for (int i = 0; i &lt; n; i++) { printf("%d ", a[i]); } printf("\n"); } //时间复杂度：O(N+range) //只适合整数/适合范围集中 //空间复杂度：O(range) void CountSort(int* a, int n) { int min = a[0], max = a[0]; for (int i = 1; i &lt; n; i++) { if (a[i] &lt; min) { min = a[i]; } if (a[i] &gt; max) { max = a[i]; } } int range = max - min + 1; int* count = (int*)calloc(range,sizeof(int)); if (count == NULL) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f74b12baaa5d494b76c1a05e0241e9bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8858c75495013543482adbf14aa4eb8d/" rel="bookmark">
			基于Spark天气数据分析系统的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编号：2461701 项目+LW（说明书）+任务书（开题报告）
完整项目联系方式在文章最下面
项目简介 在大数据时代，天气数据作为一种重要的公共资源，不仅影响人们的日常生活，还对农业、交通、能源等多个领域产生深远影响。通过对天气数据的全面处理和展示，可以帮助人们更好地理解和预测天气变化，从而做出更加科学的决策。我们设计并实现了一个基于Spark的天气数据分析系统，该系统通过数据采集、清洗、分析和可视化，为用户提供了高效、准确的天气数据分析服务。
技术架构 后端技术 Spark：用于大规模数据处理和分析，利用其内存计算的优势，高效地处理和分析大规模天气数据。Selenium：用于自动化数据采集，模拟用户操作，自动化地从网络上抓取天气数据。Pandas：用于数据清洗和预处理，确保数据的质量和一致性。Flask：轻量级Web框架，用于构建Web应用的后端服务，处理用户请求和响应。 前端技术 ECharts：用于数据可视化，展示天气数据的分析结果，包括气温变化、空气质量指数等，为用户提供直观的决策支持。HTML/CSS/JavaScript：用于构建用户友好的界面，确保系统的易用性和交互性。 系统功能 1. 数据采集 使用Selenium从指定的天气网站上抓取历史天气数据，并将数据保存为CSV文件。采集的数据包括每个月的平均高温、平均低温、极端高温、极端低温、平均空气质量指数等，以及每日的详细天气情况。
2. 数据清洗 使用Pandas对采集到的原始数据进行清洗，移除冗余符号，将字符串类型的数据转换为数值类型，并对日期格式进行处理，确保数据的一致性和可用性。
3. 数据分析 在Linux环境下使用Spark进行数据分析，提取有价值的信息。分析内容包括每个月的平均气温、空气质量指数、极端温度、最常见的天气类型、降水天数和晴天数等。
4. 数据可视化 通过Flask和ECharts进行数据可视化展示，将分析结果以图表的形式直观展示给用户。用户可以通过Web界面查看每个月的平均气温变化、空气质量指数分布、极端温度变化、天气类型分布等。
系统特色 1. 全面数据处理 系统涵盖了从数据采集、清洗、分析到可视化展示的完整流程，确保数据处理的高效性和准确性。
2. 高效大数据处理 利用Spark的内存计算优势，系统能够高效处理和分析大规模天气数据，快速提取出有价值的信息。
3. 直观的数据展示 通过ECharts进行数据可视化，系统能够以直观、易理解的方式展示天气数据的分析结果，帮助用户更好地理解数据。
4. 用户友好的界面 系统采用Flask框架构建Web应用，提供简洁、易用的用户界面，用户可以轻松浏览和查询天气数据的分析结果。
部分运行截图 通过本系统的开发和实施，不仅实现了对天气数据的全面分析和展示，也为天气数据的科学决策提供了有力支持。未来，我们将继续优化数据分析算法，提升系统性能，并增加更多数据源和分析维度，力求为用户提供更优质的天气数据分析服务。
V - WeiDaPang_T
Q - 977266623
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0f206270af37aa063e8ef22335a8e2c/" rel="bookmark">
			【机器学习】机器的登神长阶——AIGC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是AIGC
普通用户接触AIGC网站推荐
通义千问
白马
普通用户如何用好AIGC
关键提示词的作用
AIGC的影响
就业市场：
教育领域：
创意产业：
经济活动：
社交媒体与信息传播：
AIGC面临的挑战
什么是AIGC AIGC，全称为Artificial Intelligence Generated Content，即人工智能生成内容。
它是人工智能技术发展到一定阶段的产物，主要依赖于深度学习算法，尤其是GAN（生成对抗网络）、CLIP（对比语言-图像预训练）、Transformer架构、Diffusion模型、预训练模型以及多模态技术等。
AIGC的核心在于使用机器学习算法来生成各种类型的内容，包括但不限于：
文本创作，如文章、诗歌、故事、新闻报道、报告等。图像生成，包括艺术作品、照片、设计元素等。视频制作，涉及动画、电影片段、广告等。音频和音乐创作，涵盖歌曲、配乐、播客等。游戏内容，如关卡设计、NPC对话、游戏内物品等。 AIGC的出现和发展标志着人工智能从简单的计算智能和感知智能向认知智能迈进。
通过在大量数据集上的训练，AIGC模型能够理解和模仿人类的创造过程，生成看似由人类创作的内容。
这种技术不仅提高了内容生产的效率和多样性，而且正在改变创意产业的格局，影响着版权、伦理和艺术创作的本质。
在经济层面，AIGC放大了数据的价值，将其提升为关键生产要素。
普通用户接触AIGC网站推荐 通义千问 通义千问：通义
通义千问是阿里云自主研发的超大规模语言模型，能够回答问题、创作文字，还能表达观点、撰写代码。
作为预训练语言模型，通义千问在多个领域有着广泛的应用，可以为用户提供各种自然语言处理服务，包括但不限于智能对话、文本生成、情感分析、翻译等等。
同时，通义千问也是阿里云在人工智能领域的重大突破，代表了中国在该领域的研发实力和创新能力
通义千问具备多种功能，主要包括：
多轮对话：它能与用户进行连续的对话交流，理解上下文并给出连贯的回应。文案创作：能够撰写各类文本，如小说续写、邮件编写、商品描述文案、菜谱生成、小学生作文等。逻辑推理和多模态理解：能够理解并处理多种类型的信息，包括文本、图像等。多语言支持：支持多种语言的交互，能够理解和生成不同语言的文本。效率类应用： 自定义主题生成提纲SWOT分析商品描述文案生成生活类应用： 根据菜名生成菜谱作文生成下文续写娱乐类应用： 彩虹屁文案生成情书写作根据关键词创作诗歌 白马 白马AI：https://chat.jalabaima.com/h5/#/
白马AI专注于提高科技咨询效率，是国内最早将生成式人工智能应用于科技咨询领域的品牌之一！白马AI聚合了GPT-3.5-turbo、讯飞星火3.0、智谱GLM-3-turbo、文心ERNIE3.5等模型，GPT-4.0、百度文心4.0、GLM-4高级大模型，主要功能如下：
1、申报模型：输入企业专利、产品、研发项目、专利创新方案等基本信息资料生成报告内容；
2、自由对话：上下文记忆迭代式问答获得启发性内容深度对话
3、角色扮演：模拟特定角色的人员回答专业问题
4、图片生成：基于MJ理解自然语言的AI绘画
5、思维导图：根据标题生成思维导图，开阔思路
6、批量生成：设置特定提示词，批量生成文本报告
7、模型擂台：同提示词对比不同模型的使用效果
​
普通用户如何用好AIGC 提供详细的上下文： 给AI提供尽可能多的上下文信息，包括具体的场景、人物、地点、时间等，这样可以帮助AI更好地理解你的需求并生成相关的内容。
明确指令和目标： 清晰地说明你期望AI完成的任务，比如“撰写一篇关于环保的科普文章”，而不是模糊的“写点东西”。确保指令中包含了所有必要的细节和要求。
使用专业术语和领域知识： 如果内容涉及某个专业领域，使用该领域的专业术语和概念，这有助于AI理解并生成更专业的内容。
给出例子或模板： 提供一些样例文本或模板，可以帮助AI学习和模仿你的写作风格或所需内容的格式。
逐步指导： 不要一次性要求AI完成复杂任务，可以分步骤提出要求，先完成一部分，检查后再进行下一部分，这样可以逐步修正和调整生成的内容。
反馈和迭代： 利用AI生成的内容进行反馈，指出哪些部分满足了你的需求，哪些部分需要改进。通过多次迭代，AI可以逐渐学习到你的偏好。
设置约束条件： 明确指出内容不应包含什么，如避免敏感话题、特定的语法错误或风格偏差，这有助于限制AI生成内容的方向。
使用高质量的数据集： 如果可能的话，训练AI模型时使用高质量、多样化的数据集，这可以提高生成内容的准确性和丰富性。
如下是AIGC生成代码示例（Java链表）
public class LinkedList { private Node head; // 链表头结点 // 链表节点定义 private static class Node { int data; // 节点存储的数据 Node next; // 指向下一个节点的引用 Node(int data) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0f206270af37aa063e8ef22335a8e2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/debe9ea3a39896c13b0df0dbf87131bc/" rel="bookmark">
			CentOS7安装Kafka_2.12-3.3.1集群及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前提条件
集群规划
安装步骤
下载kafka_2.12-3.3.1.tgz安装包
解压
同步至其他机器
配置环境变量（所有机器都执行）
配置kafka
启动zk集群（三台都执行）
启动kafka（三台都执行）
查看进程（三台都执行）
Kafka集群启动停止脚本
Kafka常用命令
启动集群
创建topic
查看topic
查看zk里的topic节点
kafka生产消息
kafka消费消息
删除topic
前提条件 三台CentOS7都安装好zookeeper-3.7.1，可参考 CentOS7安装ZooKeeper3.7.1集群
集群规划 node2node3node4zkzkzkkafkakafkakafka 安装步骤 下载kafka_2.12-3.3.1.tgz安装包 [hadoop@node2 installfile]$ wget https://archive.apache.org/dist/kafka/3.3.1/kafka_2.12-3.3.1.tgz 解压 [hadoop@node2 installfile]$ tar -zxvf kafka_2.12-3.3.1.tgz -C ~/soft 同步至其他机器 [hadoop@node2 installfile]$ cd ~/soft/ [hadoop@node2 soft]$ xsync kafka_2.12-3.3.1 配置环境变量（所有机器都执行） $ sudo nano /etc/profile.d/my_env.sh
添加如下内容
#KAFKA_HOME export KAFKA_HOME=/home/hadoop/soft/kafka_2.12-3.3.1 export PATH=$PATH:$KAFKA_HOME/bin 让环境变量生效
$ source /etc/profile 注意：node2、node3、node4都需要设置环境变量并让环境变量生效。
配置kafka 切换到kafka配置目录
[hadoop@node2 soft]$ cd $KAFKA_HOME/config 修改配置文件server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/debe9ea3a39896c13b0df0dbf87131bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84dc240999139d7f5b9ca9683a8eaedd/" rel="bookmark">
			oracle中使用临时表GLOBAL TEMPORARY TABLE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要在存储过程中返回一个临时结果集，这个结果集又是多个语句通过循环查询出来的，这时候就想到了将结果插入到临时表中，然后返回临时表的数据的思路，于是有了以下操作：
1.创建临时表
-- Create table create global temporary table T_PROJECT_AMOUNT_TEMP ( project_id VARCHAR2(1000), con_amount_tax_s NUMBER ) on commit preserve rows; -- Add comments to the table comment on table T_PROJECT_AMOUNT_TEMP is '临时表'; -- Add comments to the columns comment on column T_PROJECT_AMOUNT_TEMP.project_id is '项目ID'; comment on column T_PROJECT_AMOUNT_TEMP.con_amount_tax_s is '项目合同金额'; 2.创建存储过程
CREATE OR REPLACE PROCEDURE PRC_XXXX( TODO_CUR OUT PKG_QUERY.CUR_QUERY ) AS BEGIN delete from T_PROJECT_AMOUNT_TEMP; --遍历数据 for dataOjb in ( select * from xxx t where xxx ) loop --往临时表插入记录 insert into T_PROJECT_AMOUNT_TEMP select xx,xx from XXX; insert into T_PROJECT_AMOUNT_TEMP select xx,xx from XXX; END LOOP; --将临时表中的记录返回 open TODO_CUR for select * from T_PROJECT_AMOUNT_TEMP k; END PRC_XXXX; 在存储过程中先将临时表清空，然后再往临时表插入记录，不然数据会重复插入。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fe61ac5a65cc485b0b30edafaa34907/" rel="bookmark">
			多目标跟踪中用到的求解线性分配问题（Linear Assignment Problem，LAP）Python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多目标跟踪中用到的求解线性分配问题（Linear Assignment Problem，LAP）Python flyfish
如果想看 C++版本的，请点这里。
线性分配问题（LAP，Linear Assignment Problem）是一个经典的优化问题，其目标是在若干任务和若干工人之间进行分配，以最小化总成本。成本可以是时间、金钱等。
LAPJV算法（Linear Assignment Problem Jonker-Volgenant algorithm）是解决线性分配问题的一种具体方法。这是一种基于Jonker和Volgenant提出的优化算法，旨在高效地求解LAP。
我们有一个公司，当前有5个任务需要完成，同时公司有5名工人可供选择。每个工人完成每个任务的成本（例如时间、金钱等）不同。公司的目标是找到一种分配方案，使得所有任务都能被一个工人完成，并且总成本最小。
具体而言，成本矩阵如下：
任务1任务2任务3任务4任务5工人191114117工人2615131310工人31213688工人411910129工人5712141014 该矩阵中的每个值表示分配工人完成任务的成本。公司希望最小化这些成本的总和。
用Python代码来理解，使用lap库来验证写的对不对
依赖库
conda install -c conda-forge lap 代码实现 import numpy as np import matplotlib.pyplot as plt import lap class LAPJV: def __init__(self, cost_matrix): self.cost_matrix = np.array(cost_matrix) self.n = self.cost_matrix.shape[0] self.x = np.full(self.n, -1, dtype=int) self.y = np.full(self.n, -1, dtype=int) self.v = np.zeros(self.n) self.free_rows = [] def solve(self): self.column_reduction() self.augment() def column_reduction(self): for j in range(self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fe61ac5a65cc485b0b30edafaa34907/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61e0f5440a5e81019b3748120dfb36bb/" rel="bookmark">
			在ie edge 浏览器中，uni-easyinput 组件类型为password时，出现两个小眼睛图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述：
在ie edge 浏览器中，uni-easyinput 组件类型为password时，出现两个小眼睛图标，此为官方组件已存在的bug
解决思路：
在/uni_modules/uni-easyinput/components/uni-easyinput.vue组件中样式中增加以下代码
详细代码：
/*去除ie edge浏览器中密码框默认出现的小眼睛*/ .uni-easyinput__content-input ::-ms-reveal { display: none; } 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/255/">«</a>
	<span class="pagination__item pagination__item--current">256/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/257/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>