<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51c496d0c12d785c95323ca968ffc7bd/" rel="bookmark">
			Docker 命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker 命令详解 Docker 是一种流行的容器化技术，它允许开发者将应用程序及其依赖项打包到一个轻量级、可移植的容器中，从而实现快速部署和一致性的运行环境。本文档将详细介绍 Docker 的基础知识，并通过一系列实用的命令来帮助你更好地管理 Docker 环境。
一、Docker 简介 Docker 包含三个核心组件：
Docker 客户端 - 用户与 Docker 交互的界面。Docker 守护进程 - 运行在主机上，处理客户端发送的指令。Docker 镜像 - 包含了运行应用程序所需的所有文件和依赖。 Docker 的优点 一致性：无论在哪个环境中运行，应用的行为都是一致的。资源高效：容器共享主机的操作系统内核，占用资源较少。隔离性：每个容器都有自己的文件系统和运行空间，相互之间不会干扰。 二、安装 Docker 确保你的系统已经安装了 Docker。如果还没有安装，可以访问 Docker 官方网站 获取安装指南。
三、Docker 基础命令 查看版本信息 docker --version 搜索镜像 docker search &lt;image_name&gt; 下载镜像 docker pull &lt;image_name&gt; 列出本地镜像 docker images 删除镜像 docker rmi &lt;image_id&gt; 启动容器 docker run &lt;image_name&gt; [command] 查看运行中的容器 docker ps 查看所有容器（包括停止的） docker ps -a 停止容器 docker stop &lt;container_id&gt; 删除容器 docker rm &lt;container_id&gt; 进入容器 docker exec -it &lt;container_id&gt; /bin/bash 查看容器日志 docker logs &lt;container_id&gt; 查看容器详细信息 docker inspect &lt;container_id&gt; 四、进阶命令 构建镜像 docker build -t &lt;image_name&gt; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51c496d0c12d785c95323ca968ffc7bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3febd7212860049798cf82c4c04007f0/" rel="bookmark">
			Linux：修改网卡名称（redhat-centos-redora）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决问题: 我现在有块网卡名ens160，我想把他改为ens33（仅是模拟，实际中你可以任意更改，不是局限在这两名称中，举一反三）
我当前的操作系统为：centos9 解决办法： 1.修改grub配置 vi /etc/default/grub 找到GRUB_CMDLINE_LINUX行
# 在末尾添加 net.ifnames=1 biosdevname=0 net.ifnames=1 表示启用基于硬件的命名，而 biosdevname=0 禁用旧的 eth* 命名规则。
然后保存退出
grub2-mkconfig -o /boot/grub2/grub.cfg 然后更新 grub 配置
2.获取指定网卡MAC地址 ip link show link/ether后面就是，你和我的MAC地址都不一样，我这里的是00:0c:29:43:d9:0f，记好这串数组
（你要修改哪个网卡，就找哪个mac） 3.修改网络接口的 udev 规则 vi /etc/udev/rules.d/10-network.rules 里面写入
SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", ATTR{address}=="改为你上面找到的mac地址", NAME="ens33" 然后再重启
reboot nmcli connection delete ens160 如果之前修改网卡的原名称不是160那就修改成之前的名称
nmcli connection add type ethernet ifname ens33 con-name ens33 ipv4.method disabled autoconnect yes 如果你网卡的新名称不是ens33那么就修改成新的名称
nmcli connection up ens33 同上，不是ens33就修改成你指定的
这样就修改完成了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3febd7212860049798cf82c4c04007f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24652481ce2ceab02a9973ca4fa8f0ad/" rel="bookmark">
			使用WSGI部署Django的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		部署服务器介绍： Gunicorn ('Green Unicorn') 是一个 UNIX 下的纯 Python WSGI 服务器uWSGI 是一个快速的，自我驱动的，对开发者和系统管理员友好的应用容器服务器，完全由 C 编写Apache 和 mod_wsgi 在生产环境部署已经过充分测试 方式一：使用 Gunicorn 托管 Django 安装 Gunicorn
&gt; pip install gunicorn
把 Django 当作普通 WSGI 应用在 Gunicorn 中运行
安装了 Gunicorn 后，将提供一个 gunicorn 命令，该命令用于启动 Gunicorn 服务器进程。最简单的使用方式是传递包含名为 application 的 WSGI 应用程序对象的模块的位置，对于典型的 Django 项目，如下所示：
&gt; gunicorn myproject.wsgi
这样会创建一个进程，包含了一个监听在 127.0.0.1:8000 的线程。前提是你的项目在 Python path 中，要满足这个条件，最简单的方法是在 manage.py 文件所在的目录中运行这条命令。
方式二：使用 uWSGI 托管 Django uWSGI 文档提供了一个覆盖 Django，nginx，和 uWSGI（一个配置，多种适配）。以下文档专注于如何用 uWSGI 集成 Django。
前置条件：uWSGI
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24652481ce2ceab02a9973ca4fa8f0ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a53e758f37a996e8d6cac5505543b31/" rel="bookmark">
			Linux云计算 |【第二阶段】NETWORK-DAY5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要内容： SSH远程、进制数转换、子网划分、IPv6配置
一、SSH远程概述 前言：网络设备在配置后，为了方便管理通常要开启远程登录功能，传统工具telnet可以实现方便的连接，但是连接过程中数据无加密，可能会产生安全问题；而使用SSH（Secure Shell）协议可以在设备进行远程登录时产生的数据进行加密，从而避免信息泄漏；
SSH（Secure Shell）是一种网络协议，用于在不安全的网络中为网络服务提供安全的传输环境。SSH通过加密技术确保数据传输的安全性，常用于远程登录系统和其他网络服务。
SSH的基本概念
SSH协议：
SSH协议包括三个主要部分：传输层协议、用户认证协议和连接协议。传输层协议提供服务器认证、数据机密性和完整性保护。用户认证协议用于验证客户端的身份。连接协议允许多个加密通道共享一个单一的SSH连接。 SSH客户端和服务器：
SSH客户端用于发起连接请求，通常是用户使用的终端或图形界面工具。SSH服务器运行在目标系统上，接受并处理来自客户端的连接请求。 SSH密钥：
SSH使用公钥加密技术进行身份验证。用户生成一对密钥：公钥和私钥。公钥放在服务器上，私钥保留在客户端。当客户端连接到服务器时，服务器使用公钥加密一个随机数，客户端使用私钥解密并返回给服务器，从而验证身份。 在网络设备实现远程登录过程：
1）拥有一个可以使用的账户；2）定义该账户的 Privilege level（权限级别）与服务类型再定义允许登录的用户数量；3）使用 stelnet server enable 指令开启服务； 配置SSH远程
① 创建用户
[Huawei] aaa //进入路由器管理账户视图 [Huawei-aaa] local-user 用户名 password cipher 密码 //设置账户密码 [Huawei-aaa] locel-user 用户名 service-type ssh //开启账户远程功能 [Huawei-aaa] local-user 用户名 privilege level 3 //修改账户权限 ② 服务器端
[Huawei] user-interface vty 0 //进入远程接口（0是允许登录的第一个账户） [Huawei-ui-vty0] authentication-mode aaa //允许远程时使用aaa中创建的用户 [Huawei-ui-vty0] protocol inbound ssh //放行ssh数据 [Huawei-ui-vty0] quit [Huawei] stelnet server enable //开启远程服务 ③ 客户端
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a53e758f37a996e8d6cac5505543b31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a20860f61986766ecfec5f385852a8b/" rel="bookmark">
			腾讯云AI代码助手 —— 编程新体验，智能编码新纪元
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读导航 引言一、开发环境介绍1. 支持的编程语言2. 支持的集成开发环境（IDE） 二、腾讯云AI代码助手使用实例1. 开发环境配置2. 代码补全功能使用💻自动生成单句代码💻自动生成整个代码块 3. 技术对话3. 规范/修复错误代码4. 智能生成代码注释5. 常用的快捷键📦macOS 快捷键📦Windows 快捷键 三、获得的帮助与提升四、建议五、结语 引言 在数字化转型的浪潮中，软件开发与编程已经成为推动各行各业创新与发展的重要引擎。然而，随着项目规模的扩大和复杂度的提升，开发者们面临着前所未有的挑战：如何在保证代码质量的同时，提高开发效率，快速响应市场变化？为了解答这一难题，腾讯云凭借其深厚的技术积累与创新能力，推出了AI代码助手——一款辅助编码工具，基于混元代码大模型，提供技术对话、代码补全、代码诊断和优化等能力。
一、开发环境介绍 腾讯云AI代码助手作为一款编程提效辅助工具，其开发环境支持多种编程语言和主流集成开发环境（IDE），为开发者提供了灵活、高效的编程体验。
1. 支持的编程语言 腾讯云AI代码助手支持多种编程语言，包括但不限于Python、Java、C/C++、Go等数十种编程语言或框架。
2. 支持的集成开发环境（IDE） 腾讯云AI代码助手以插件形式集成到主流IDE中，为开发者提供无缝的编程体验。目前，它支持以下IDE：
Visual Studio Code（VS Code）：作为轻量级但功能强大的代码编辑器，VS Code广受开发者喜爱。腾讯云AI代码助手为VS Code提供了专门的插件，开发者可以轻松安装并体验AI辅助编程的便利。JetBrains系列IDE：JetBrains公司旗下的IDE，如IntelliJ IDEA、PyCharm等，在软件开发领域享有盛誉。腾讯云AI代码助手同样为这些IDE提供了插件支持，让开发者能够在自己熟悉的开发环境中享受到AI带来的提效优势。 二、腾讯云AI代码助手使用实例 1. 开发环境配置 为了使用腾讯云AI代码助手，开发者需要在自己的开发环境中进行简单的配置。以VS Code为例，配置过程大致如下：
安装插件：打开VS Code，进入扩展市场（Extensions），搜索“腾讯云AI代码助手”，找到并安装该插件。 3. 登录认证：安装完成后，根据插件提示进行登录认证。通常需要开发者使用腾讯云账号进行登录，并进行相应的安全认证。
4. 开始使用：登录认证完成后，即可在VS Code中开始使用腾讯云AI代码助手的功能。它会自动根据当前编写的代码上下文提供智能的代码补全、技术对话、代码诊断等辅助服务。
2. 代码补全功能使用 按回车触发补全按空格行补全按 Tab 接受建议 💻自动生成单句代码 💻自动生成整个代码块 3. 技术对话 人工智能技术对话，复杂问题轻松解决
技术对话集成 IDE，支持将对话代码内容一键插入编译区当中；
首先找到上面这个图标唤醒腾讯云 AI 代码助手
你可以在输入框内输入你的技术性问题，代码助手会给你详细解决 3. 规范/修复错误代码 精准修复错误代码，减少漏洞不出差错
支持框选或全选编译区代码内容，进行代码规范检查与错误修复； 选中要修复的代码，鼠标右键选择腾讯云AI代码助手，点击修复代码在左侧对话框内会出现修复的结果 4. 智能生成代码注释 选中想要注释的代码，右键点击重构
点击补全注释，会在左侧对话框内生成注释结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a20860f61986766ecfec5f385852a8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e75170bf6b9c5564311b8258b44ed2f/" rel="bookmark">
			微信小程序子组件调用父组件的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：通义千文2.5
步骤 1: 定义父组件中的方法 首先，在父组件中定义一个方法（如 handleClick），并准备一个用于接收子组件传来的数据的方法。
父组件（Parent.wxml） html &lt;!-- parent.wxml --&gt; &lt;view class="parent"&gt; &lt;view&gt;这是父组件&lt;/view&gt; &lt;child id="childComponent" bind:customEvent="handleClickFromChild"&gt;&lt;/child&gt; &lt;/view&gt; 父组件逻辑文件（Parent.js） // parent.js Page({ data: { message: '' }, handleClickFromChild: function (e) { console.log('接收到子组件的数据:', e.detail); this.setData({ message: e.detail.message }); } }); 步骤 2: 在子组件中触发事件 接下来，在子组件中触发一个自定义事件，将数据传递给父组件。
子组件模板文件（Child.wxml） &lt;!-- child.wxml --&gt; &lt;view class="child"&gt; &lt;button bindtap="sendDataToParent"&gt;发送数据给父组件&lt;/button&gt; &lt;/view&gt; 子组件逻辑文件（Child.js） // child.js Component({ methods: { sendDataToParent: function () { var data = { message: '你好，我是子组件！' }; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e75170bf6b9c5564311b8258b44ed2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/311dcc786525006f7bc5c0cef2566791/" rel="bookmark">
			租用服务器建站要考虑网站的哪些因素？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数字化时代，拥有一个稳定、高效且符合需求的网站是企业或个人在线展示与业务拓展的关键。租用服务器作为建站的基础设施之一，其选择直接影响到网站的性能、安全性、可扩展性及成本效益。以下是在租用服务器建站时需要考虑的几个关键因素：
1. 网站规模与流量预估 明确网站的预期规模和未来可能面临的访问量至关重要。对于初创企业或小型个人博客，初期可能选择共享主机或入门级虚拟私有服务器（VPS）即可满足需求，成本相对较低。但随着业务增长和访问量的增加，可能需要升级到更高配置的VPS或独立服务器，甚至考虑云服务器以应对突发流量。
2. 性能与稳定性 网站的性能直接影响到用户体验，包括页面加载速度、响应时间和并发处理能力。选择服务器时，需关注其处理器性能、内存大小、磁盘读写速度及网络带宽等硬件配置。同时，服务商的数据中心稳定性、网络架构及冗余设计也是保障网站持续在线的关键。
3. 安全性 随着网络攻击日益频繁，服务器的安全性不容忽视。租用服务器时，应确认服务商是否提供防火墙、DDoS防护、定期安全扫描及备份恢复等安全服务。此外，了解服务器操作系统的安全更新策略及用户权限管理也是保障网站安全的重要一环。
4. 可扩展性 随着业务的发展，网站可能需要不断升级以满足新的需求。因此，服务器的可扩展性成为了一个重要考量因素。云服务器因其按需付费、灵活扩展的特点，成为许多企业的首选。无论是增加CPU、内存还是存储空间，都能在短时间内完成，无需担心硬件升级带来的停机时间。
5. 成本效益 成本是任何商业决策中不可忽视的因素。在租用服务器时，需综合考虑初期投入、长期运维成本及可能产生的额外费用（如数据迁移费、升级费等）。同时，也要评估不同服务商的性价比，选择最适合自身预算和需求的服务方案。
6. 技术支持与服务 优秀的技术支持和服务是保障网站顺利运行的重要后盾。在选择服务器服务商时，应了解其技术支持团队的响应速度、专业水平及服务范围。24/7在线支持、快速故障排查及定制化解决方案等，都是衡量服务商服务质量的重要指标。
租用服务器建站需综合考虑网站规模、性能稳定性、安全性、可扩展性、成本效益以及技术支持与服务等多个因素。通过全面评估与比较，选择最适合自身需求的服务器方案，为网站的长期稳定发展奠定坚实基础。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdc7d439fef786bd167567ec04bd100f/" rel="bookmark">
			Spring WebFlux 实现 SSE 流式回复：类GPT逐字显示回复效果完整指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本节将提供基于 Spring WebFlux 和 SSE 实现类ChatGPT流式回复效果的完整代码示例，并详细说明所需的依赖和配置。
1. 项目配置 构建工具: Maven 或 Gradle依赖: &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt; &lt;/dependency&gt; 2. 后端代码 (Spring WebFlux) package com.example.ssedemo; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.http.MediaType; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import reactor.core.publisher.Flux; import org.springframework.http.codec.ServerSentEvent; import java.time.Duration; @SpringBootApplication @RestController public class SseDemoApplication { public static void main(String[] args) { SpringApplication.run(SseDemoApplication.class, args); } @GetMapping(value = "/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE) public Flux&lt;ServerSentEvent&lt;String&gt;&gt; streamChatGPTReply(@RequestParam String message) { // 模拟调用 ChatGPT API 获取回复 String reply = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdc7d439fef786bd167567ec04bd100f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9c981a2e042460a05b9aa7ba728e6fc/" rel="bookmark">
			Django 使用 Session 实现用户唯一标识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、问题背景 在开发一个拍卖网站模型时，需要解决以下问题：
每个学生只能对每个物品出价一次。每个学生可以看到自己对每个物品的出价。每个学生可以在一定时间内修改自己的出价。 为了实现这些功能，需要在 Bid 模型中添加一个字段来标识出价人。可以选择使用完整的用户模型，但这样会增加实现的复杂性。也可以使用 CharField 来存储出价人标识, 但这无法防止学生通过创建多个出价人标识来多次出价。
2、解决方案 可以使用 Django 的 session 来实现出价人标识。Session 是一个存储在服务器端的临时数据，可以用来存储用户的相关信息。每个用户都有自己的 session，因此可以使用 session 来标识出价人。
以下是实现步骤：
在 Bid 模型中添加一个 CharField 字段 bidderid。在 Bid 模型的 save 方法中，将 bidderid 设置为 request.session.session_key。在 views.py 中，在创建 Bid 实例之前，先检查 request.session.session_key 是否存在。如果不存在，则创建一个新的 session。在模板中，使用 {% if user.is_authenticated %} 来判断用户是否已登录。如果已登录，则显示用户的出价记录。如果没有登录，则显示一个表单，让用户输入姓名。在处理表单时，将用户输入的姓名存储在 SessionName 模型中。在 views.py 中，在创建 Bid 实例之前，先检查 SessionName 模型中是否存在与 request.session.session_key 对应的记录。如果存在，则将 bidderid 设置为该记录的 chosenname 字段的值。 这样，就可以实现每个学生只能对每个物品出价一次，并且每个学生可以看到自己对每个物品的出价，还可以修改自己的出价。
代码示例：
from django.db import models from django.contrib.sessions.models import Session class Lot(models.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9c981a2e042460a05b9aa7ba728e6fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40340ea750df31a89308354834625906/" rel="bookmark">
			服务器数据恢复—服务器raid常见故障产生原因&amp;数据恢复方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		磁盘阵列（raid）是一种将多块物理硬盘整合成一个虚拟存储的技术。raid模块相当于一个存储管理中间层，上层接收并执行操作系统及文件系统的数据读写指令，下层管理数据在各个物理硬盘上的存储及读写。相对于单独的物理硬盘，raid可以为用户提供更大的独立存储空间，更快的读写速度，更高的数据存储安全及更方便的统一管理模式。磁盘阵列的正常运行是保障服务器中数据正常读写的关键。
服务器raid常见的故障表现：
1、Raid中多块物理硬盘的指示灯报警。
2、Raid中多块硬盘离线。
3、Raid信息丢失，物理硬盘不是online状态。
4、无法进入raid管理界面或查看raid相关信息时死机。
服务器磁盘阵列故障原因分析：
1、Raid中的单块硬盘出现物理故障。
2、Raid数据传输通道不畅或者数据传输模块老化。
3、服务器系统更新、重启或服务器意外断电导致raid信息丢失或raid模块损坏。
4、Raid模块升级或重装系统导致raid信息丢失或被重建。
5、错误插拔Raid中的物理硬盘或者强制硬盘online/rebuild。
服务器raid常见的故障的数据恢复方案：
1、将磁盘阵列中所有运行状态良好的非热备盘完整镜像备份到带有冗余功能的安全存储中，对于存在物理故障的硬盘则按照相应故障类型的解决方案处理，尽可能将故障物理硬盘中的数据镜像备份至安全存储中。
2、基于所有硬盘镜像文件分析，确定故障raid的原结构参数（raid级别、条带块大小、硬盘盘序、数据校验方式等），还需要判断故障raid中各硬盘的离线情况。
3、根据分析所获取到的raid参数及硬盘离线情况在只读环境中重新构建raid，并对新建raid进行逻辑校验。确定文件系统结构无误后将raid生成完整镜像。
4、对生成的raid镜像进行完整的逻辑分析和校验，若文件系统仍存在不一致的情况则依据相应文件系统损坏情况的解决方案进行修复，直至迁移出所有需要的数据。
服务器Raid出现故障后的关于数据安全的Tips：
1、切忌再次让硬盘磕碰或者受到其他物理伤害。服务器raid中任何一块硬盘对于数据恢复都非常重要，如果有硬盘出现严重物理损坏，数据恢复难度将呈几何倍数上升，甚至无法恢复raid数据。
2、切忌重新创建raid或者强制online/rebuild。
3、切忌非专业人士对故障raid的模块进行拆卸、更换等操作，不当操作很有可能对服务器raid中的数据造成严重破坏，甚至导致数据无法恢复。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/115d780a1d13796316c83c05669d9ccd/" rel="bookmark">
			AIGC引领未来：搜索引擎、广告系统与推荐系统的重塑与革新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、搜索引擎的智能化升级1. 语义理解的飞跃2. 对话式搜索的兴起3. 跨模态检索的探索 二、广告系统的智能化转型1. 个性化创意生成2. 实时优化投放策略3. 内容与广告深度融合 三、推荐系统的精准化与智能化1. 精准推荐算法2. 长尾内容发现3. 内容生产与消费闭环 《搜广推策略产品经理——互联网大厂搜索+广告+推荐案例》编辑推荐内容简介作者简介目录获取方式 在AIGC（AI生成内容）技术的推动下，搜索引擎、广告系统与推荐系统正经历着深刻的变革。这项技术不仅极大地提升了内容生成的效率与质量，还为用户与信息之间构建了更加智能、个性化的交互桥梁。
一、搜索引擎的智能化升级 1. 语义理解的飞跃 传统搜索引擎主要依赖于关键词匹配来检索信息，而AIGC技术则使搜索引擎能够深入理解用户查询的语义含义。通过对自然语言处理技术的运用，搜索引擎能够更准确地把握用户的搜索意图，从而提供更加精准、个性化的搜索结果。这种转变不仅提升了搜索效率，还极大地改善了用户体验。
2. 对话式搜索的兴起 AIGC技术还催生了对话式搜索的兴起。这种搜索方式允许用户以自然语言的形式与搜索引擎进行交互，仿佛在与一个智能助手对话。对话式搜索能够更好地理解用户的复杂需求和上下文信息，从而提供更加全面、深入的搜索结果。例如，微软的新必应搜索引擎就集成了ChatGPT技术，实现了对话式搜索的功能。
3. 跨模态检索的探索 随着AIGC技术的不断发展，跨模态检索也成为了搜索引擎领域的一个研究热点。跨模态检索能够打破文本、图像、视频等不同模态之间的壁垒，实现跨模态的信息检索与融合。这种技术将为用户提供更加多元化、丰富化的搜索结果，满足用户在不同场景下的信息需求。
二、广告系统的智能化转型 1. 个性化创意生成 AIGC技术为广告系统带来了个性化创意生成的可能性。传统的广告创意需要广告人员手动撰写和设计，而AIGC技术则能够自动生成符合用户兴趣与品牌调性的广告内容。这不仅提高了广告创作的效率，还降低了人力成本。同时，个性化创意生成还能够提升广告的针对性和吸引力，从而提高广告效果。
2. 实时优化投放策略 AIGC技术还能够根据用户的实时反馈和行为数据，对广告投放策略进行实时优化。通过对用户数据的深度挖掘和分析，广告系统能够更准确地了解用户的兴趣和需求变化，从而调整广告投放的时机、渠道和形式等策略。这种实时优化能力将大大提升广告的转化率和ROI（投资回报率）。
3. 内容与广告深度融合 AIGC技术还促进了内容与广告的深度融合。在对话式搜索和推荐系统中，广告不再是以往那种生硬地插入在内容中的形式，而是与内容深度融合、相互补充。这种深度融合的广告形式不仅能够提升用户体验，还能够提高广告的点击率和转化率。
三、推荐系统的精准化与智能化 1. 精准推荐算法 AIGC技术为推荐系统提供了更加精准的推荐算法。通过对用户历史行为数据的深度挖掘和分析，推荐系统能够更准确地了解用户的兴趣和偏好变化，从而为用户推荐更加符合其需求的内容。这种精准推荐算法将大大提升用户的满意度和粘性。
2. 长尾内容发现 除了热门内容外，AIGC技术还能够帮助推荐系统发现那些被忽视的长尾内容。这些长尾内容虽然受众较小但具有独特的价值和吸引力。通过将这些长尾内容推荐给感兴趣的用户群体，推荐系统不仅能够丰富用户的阅读体验还能够促进内容的多样化和繁荣。
3. 内容生产与消费闭环 AIGC技术还促进了推荐系统构建内容生产与消费的闭环生态。在这个生态中用户不仅是内容的消费者还是内容的生产者或参与者。他们可以通过与推荐系统的交互来产生新的内容或参与到现有内容的创作中来。这种闭环生态将激发用户的创造力和参与热情从而推动内容的持续更新和迭代。
AIGC技术正在深刻地改变着搜索引擎、广告系统与推荐系统的面貌。随着技术的不断发展和应用场景的不断拓展，这些领域将迎来更加智能化、个性化、精准化的未来。
《搜广推策略产品经理——互联网大厂搜索+广告+推荐案例》 编辑推荐 本书全面介绍了搜索引擎、广告系统和推荐系统的各个模块本书包含丰富的阿里、字节和美团等互联网大厂的实际应用案例本书介绍了与策略产品经理工作紧密相关的机器学习知识，能够让读者深入理解策略优化的底层逻辑 内容简介 《搜广推策略产品经理——互联网大厂搜索+广告+推荐案例》通过通俗易懂的语言和生动形象的案例向读者介绍互联网大厂的搜广推产品技术体系和前沿的 AI 技术应用，是一本兼具 AI 技术理论和行业策略优化实践的工具书。
本书分为 6 章，第 1 章介绍 AI 时代下的新型产品经理岗位——策略产品经理；第 2 章介绍策略产品经理必备的机器学习基础知识；第 3、 4、 5 章分别介绍当前互联网大厂的推荐场景、搜索场景和广告场景里的先进策略产品设计以及落地应用效果；第 6 章结合行业实际落地案例介绍前沿的 AI 技术应用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/115d780a1d13796316c83c05669d9ccd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88835d0302ade141b1519385262bab2c/" rel="bookmark">
			2024 NVIDIA开发者社区夏令营环境配置指南(Win &amp; Mac)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024 NVIDIA开发者社区夏令营环境配置指南(Win &amp; Mac) 1 创建Python环境 首先需要安装Miniconda：
大家可以根据自己的网络情况从下面的地址下载：
miniconda官网地址：https://docs.conda.io/en/latest/miniconda.html
清华大学镜像地址： https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/
安装完之后，打开Anaconda Powershell:
在打开的终端中按照下面的步骤执行,配置环境:
创建python 3.8虚拟环境
conda create --name ai_endpoint python=3.8 进入虚拟环境
conda activate ai_endpoint 安装nvidia_ai_endpoint工具
pip install langchain-nvidia-ai-endpoints 安装Jupyter Lab
pip install jupyterlab 安装langchain_core
pip install langchain_core 安装langchain
pip install langchain 安装matplotlib
pip install matplotlib 安装Numpy
pip install numpy 安装faiss, 这里如果没有GPU可以安装CPU版本
pip install faiss-cpu==1.7.2 安装OPENAI库
pip install openai 2.利用Jupyter Lab打开课件执行 在上面打开的终端中, 输入以下命令:
jupyter-lab 利用Jupyter 打开课件
3.Macbook 环境 Macbook也可以按照上面的步骤同样执行, 只是在下载Miniconda的时候要下载Mac OS版本的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b4e4cad9d9d395beed0cf12f29f60ab/" rel="bookmark">
			Docker三剑客之Docker Engine
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Docker Engine作为Docker的核心组件，其功能和重要性不言而喻。以下是对Docker Engine的详细介绍，内容涵盖其定义、核心组件、工作原理、配置方法、安全性以及最佳实践等多个方面，但由于篇幅限制，我将尽量在6000字以内概括性地介绍这些内容。
一、Docker Engine概述 Docker Engine是Docker的底层技术实现，它是一个轻量级的容器运行时，能够在Linux、Windows和macOS等多种操作系统上运行。Docker Engine通过容器技术，将应用程序及其所有依赖项打包成一个可移植的容器，从而实现了应用程序在不同环境中的快速部署和运行。这种容器化技术极大地简化了应用程序的部署、扩展和管理过程，成为现代软件开发和运维的重要工具。
二、Docker Engine的核心组件 Docker Engine包含多个核心组件，这些组件共同协作以实现容器的创建、运行和管理。以下是Docker Engine的主要核心组件：
Docker Daemon Docker Daemon是Docker Engine的后台进程，负责管理和运行容器。它管理所有Docker容器的创建、启动、停止和删除，以及Docker镜像的下载、构建和保存。Docker Daemon通过REST API与Docker客户端进行通信，以响应用户的请求。用户通过Docker客户端发送指令给Docker Daemon，以执行相应的操作。Docker 客户端 Docker客户端是用户与Docker Engine交互的命令行工具。用户通过Docker客户端发送指令给Docker Daemon，以创建、启动、停止和删除容器及镜像。Docker客户端还提供了其他功能，如构建Docker镜像、管理Docker网络和数据卷等。它是用户与Docker Engine进行交互的主要接口。Docker 镜像 Docker镜像是Docker容器的模板，包含了应用程序及其所有依赖项，如操作系统、库文件、配置文件等。Docker镜像可以从Docker Hub或其他Docker仓库中下载，也可以通过Dockerfile构建。Docker镜像是不可变的，一旦创建就不能修改，但可以通过Dockerfile重新构建。Docker 容器 Docker容器是Docker镜像的运行实例，是一个独立的、轻量级的运行环境，包含了应用程序及其所有依赖项。Docker容器可以在任何支持Docker Engine的操作系统上运行，且与宿主机器隔离。容器可以启动、停止、暂停、恢复和删除，为应用程序提供了灵活的运行环境。Dockerfile Dockerfile是一种文本文件，用于定义Docker镜像的构建过程。它包含了一系列指令，如FROM、RUN、COPY、EXPOSE等，用于指定镜像的基础操作系统、安装软件包、拷贝文件等。Dockerfile通过docker build命令来构建Docker镜像。它是Docker镜像构建过程的核心文件。Docker Compose Docker Compose是一个工具，用于定义和运行多个Docker容器的应用程序。它使用YAML文件来定义容器、网络、数据卷等，并提供了一组命令来管理这些资源。Docker Compose可以在单个主机上运行多个容器，也可以在多个主机上运行容器，为复杂的应用程序提供了方便的部署和管理方式。 三、Docker Engine的工作原理 Docker Engine的工作原理可以概括为以下几个步骤：
检查本地镜像 当用户需要运行一个Docker容器时，Docker Engine首先检查本地是否已经存在该Docker镜像。下载镜像 如果本地不存在该镜像，Docker Engine会从Docker Hub或其他Docker仓库中下载该镜像。这个过程中，Docker Engine会解析Dockerfile中的指令，按照顺序执行这些指令来构建镜像。创建容器 一旦Docker镜像下载完成，Docker Engine会创建一个独立的命名空间，该命名空间包含了一个独立的文件系统、网络和进程空间。然后，Docker Engine将Docker镜像加载到该命名空间中，并分配一个唯一的标识符给容器。启动容器 Docker Engine启动容器中的应用程序，并将其绑定到指定的端口上，以便与外部进行通信。同时，Docker Engine会监控容器的运行状态，确保容器能够正常运行。管理容器 用户可以通过Docker客户端执行一系列操作来管理容器，如停止、暂停、恢复和删除容器。Docker Engine会响应这些请求，并相应地更新容器的状态。 四、Docker Engine的配置方法 Docker Engine的配置主要涉及Docker Daemon的配置和Docker客户端的配置。以下是Docker Engine配置的一般方法：
Docker Daemon配置 Docker Daemon的配置文件通常位于/etc/docker/daemon.json（在Linux系统上）。用户可以使用文本编辑器打开该文件，并添加或修改配置项。配置项包括日志级别、存储驱动程序、网络配置、安全性设置等。用户可以根据自己的需求来配置这些选项。修改配置后，需要重启Docker服务以使更改生效。在大多数Linux系统上，可以使用sudo systemctl restart docker命令来重启Docker服务 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d9a1ac07104ef71df9c5bfb200e360a/" rel="bookmark">
			完美解决Error loading “D:\python\lib\site-packages\torch\lib\fbgemm.dll“ or one of its dependencies.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pip安装torch后，import torch报错，说明缺少一个依赖libomp，官网下载即可
libomp140.x86_64.dll : Free .DLL download. (dllme.com)
然后将libomp140.x86_64.dll复制到 \python路径下\Lib\site-packages\torch\lib 即可解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e907fa13ab4cb1adbba1140096b6baca/" rel="bookmark">
			vue3&#43;gsap实现圆形路径动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有任何问题，欢迎站内私信博主交流。
正文开始 前言一、引入并使用gsap二、详解gsap.to的各参数三、路径svg四、其他路径文字路径动画总结 前言 我开发的桌面端软件最近增加了在线更新功能，其中更新动画部分是由gsap实现的，整体实现思路已经在electron系列文章中简单介绍过，因为关注我的桌面软件——中二少年工具箱开发的同学，不一定会关注gsap动画插件，所以这里单独拿出来，详细介绍如何使用gsap实现路径动画。
一、引入并使用gsap 下载：
npm i gsap 引入页面：
import {gsap} from "gsap/all"; 制作路径动画，还需要MotionPathPlugin插件，此 插件是内置免费插件，可直接使用：
import {MotionPathPlugin} from "gsap/MotionPathPlugin"; gsap.registerPlugin(MotionPathPlugin) 调用gsap.to()方法，为页面元素创建动画：
function createAnimation(movementRange = 3) { // 使用GSAP创建动画 particlesList.value.forEach((particle, index) =&gt; { // 使用GSAP创建动画 gsap.to(particleRefs.value[index], { motionPath: { path: '#svg', align: '#svg', alignOrigin: [Math.random() * 10 - 5, Math.random() * 10 - 5] }, repeat: -1, // 无限重复 duration: 3 * Math.random() + 2, // 随机持续时间 ease: 'linear', // 线性运动 delay: Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e907fa13ab4cb1adbba1140096b6baca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f483c88cf6583fce0aa734b1906bfb7/" rel="bookmark">
			Kaldi 之父：AI 最终会破坏它触及的一切 | 新程序员
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【导读】本文作者站在 AI 整个历史长河的发展中看待当下 LLM 技术，他表示，AI 的发展是个漫长的过程，没有终点。模型更迭迅猛，未来充满未知，但唯一令人担忧的是，人们会越来越依赖那些集中化、复杂且脆弱的系统，这将带来巨大的安全隐患。一个黑客或一个简单的漏洞，可能会导致某个供应商的所有自动驾驶汽车全部停止，有可能直接导致整个国家甚至全球的交通瘫痪。
本文整理自 Kaldi 之父， IEEE Fellow，小米集团首席语音科学家 Daniel Povey 在 2024 全球软件研发技术大会中的演讲，同时收录于《新程序员 008》。《新程序员 008》聚焦于大模型对软件开发的全面支撑，囊括 Daniel Jackson 和 Daniel Povey 等研发专家的真知灼见与“AGI 技术 50 人”栏目的深度访谈内容，欢迎大家订阅。
作者 | Daniel Povey
责编 | 王启隆
出品丨《新程序员》编辑部
我想从宏观角度思考我们当前在 AI 领域的地位。如今像 ChatGPT 这样的聊天机器人，从产品角度来说确实很有意思。但打造 AI 依然是一个漫长的旅程，我们还有很长的路要走。到目前为止，我得到了以下两点认识：
首先，我们可以通过单纯的预测任务，比如预测下一个词（next-word prediction），让模型学习到很多关于世界的知识。
其次，当你扩大规模时（无论是扩大参数还是训练数据的规模），这些模型的性能会更好。
这些经验论都很好，但事实上我不认为它们特别出人意料，我也不认为这意味着我们解决了通用人工智能（AGI）。在过去，每当科幻作家试图想象一个超级智能 AI 时，他们通常会把我们现在所拥有的技术放大。比如在艾萨克·阿西莫夫的小说中，很多故事都出现了一台叫做 Multi-Path 的计算机，那是一台巨大的、有许多真空管的计算机，而他的灵感显然是基于 ENIAC 计算机（世界上第一台通用电子计算机）。重点在于，人们难以想象超出自己现有认知范围的事物，而我不认为 AGI 就是将现在的智能放大。
我们常认为人类有非常大的大脑，但实际上我们的大脑一直在变小 —— 如果和大约 5 万年前的克鲁马农人相比，他们的大脑实际上比我们的还大。狩猎采集时期的人类实际上需要记住比我们更多的东西，因为他们会吃很多不同种类的食物，必须熟悉周围的野生环境。也许在那个时候，他们不太依赖语言和向他人询问事情。
到了现代，我们的记忆力远不如古代人，所以才需要搜索技术。我们只知道如何找出答案，知道使用什么搜索词，知道在哪里查找。我认为也许在未来，AI 可能会更多地依赖于在 AI 系统之外查找信息。比如说，我们可能不会建立一个有万亿参数的 AI，而是建立一个有十亿参数的 AI，并给它搜索网络的能力，这么做反而更实际。
就像和孩子们进行长途车旅行的时候，他们经常会问：“我们到了吗？”或者“我们快到了吗？”我觉得在这个通往 AI 的旅程中，很多人在问，“我们到了吗？这就是通用人工智能了吗？”我认为总的来说，答案基本上都是否定的。
但同时，这也不是一个特别有意义的问题，因为它某种程度上取决于你如何定义通用人工智能。更有意义的问题应该是，“AI 能否系鞋带？”或者“AI 能否给老人或者盲人指路？”这些才是具体的应用问题。但“这是通用人工智能吗？”并不是一个真正可以回答的问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f483c88cf6583fce0aa734b1906bfb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/917c8f7605c6bbf61c18d7ca3181a21e/" rel="bookmark">
			阿里云智能大数据演进
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文根据7月24日飞天发布时刻产品发布会、7月5日DataFunCon2024·北京站：大数据·大模型.双核时代实录整理而成，演讲信息如下：
演讲人：徐晟 阿里云研究员/计算平台产品负责人
主要内容：
Overview - 阿里云大数据 + AI 产品线介绍
Trending - 大数据和 AI 趋势分析
Solution - 阿里云智能大数据产品解决方案
Future - 未来展望
一、Overview - 阿里云 + AI 产品线介绍 首先简单介绍一下阿里云的大数据和AI产品。阿里云在全球布局30个region，基本已覆盖国际各主要地区，包括89个可用区， 超过3200个CDN节点，为客户提供高效稳定的基础云化的计算和存储服务。
阿里云拥有非常多的大数据和AI系列产品，大数据产品主要包括两条线：
一是自研产品线，自阿里云成立之初便自主研发，涵盖大数据处理、机器学习、数据仓库等多个领域，如MaxCompute、DataWorks、Hologres、PAI等。
二是开源产品线，阿里云积极参与开源社区，贡献并维护了一系列开源项目，如Apache Flink、Apache Spark、StarRocks等，为全球开发者提供了丰富的工具和资源。
2023年，阿里云大数据与AI平台实现了3位数增长，成为国内领先的技术驱动力。据统计，国内超过半数的大模型预训练工作在阿里云平台上完成，彰显了其在AI领域的强大实力。在大数据平台性能测试中，阿里云在TPC-DS、TPC-H、TPC-BB等多个榜单上均有出色表现，证明了其在决策型数据分析领域的卓越能力。市场份额方面，阿里云在2022年占据了约49亿市场份额中的20亿，稳居国内领先地位。同时，阿里云在云数仓、AI基础架构和AI开发服务等领域的国际测评中也取得了显著成绩。尽管在国内市场保持领先地位，但阿里云也清醒地认识到，在国际竞争中仍需努力追赶。
阿里云大数据平台的核心优势包括：
首先，阿里云凭借强大的基础设施，构建了业界领先的弹性伸缩能力。无论是在业务高峰期还是低谷期，阿里云都能迅速调整资源按需弹性和分时弹性等，多种弹性配置灵活资源供给确保客户应用的平稳运行。这一能力的实现，得益于阿里云对云计算底层技术的深入研究和创新。
在技术优化方面，阿里云持续投入，通过算法优化、架构改进等手段，显著提升了服务的性价比。客户在享受高性能计算和存储服务的同时，也获得了成本效益的双重优势。
稳定性是阿里云的另一大优势。在数据密集型和高并发场景下，阿里云的服务依然保持了极高的稳定性和可靠性，这背后是阿里云对系统架构的精心设计和对故障恢复机制的不断完善。
随着AI技术的兴起，阿里云积极探索大数据与AI的深度融合，推出了一系列创新解决方案。从智能数据分析到AI模型训练，阿里云为客户提供了一站式服务，推出AI for Science、Data for AI等助力企业快速实现AI赋能。
此外，阿里云在安全管控和企业服务方面也做了大量工作。从数据加密、访问控制到合规性审计，阿里云构建了全方位的安全防护体系，让客户在享受云计算便利的同时，无需担心数据安全问题。
阿里云的这些努力，不仅提升了自身的竞争力，也为客户带来了实实在在的价值。在数字化转型的浪潮中，阿里云正成为企业信赖的合作伙伴，共同探索未来无限可能。
二、Trending - 大数据和 AI 趋势分析 接下来分享一下大数据和AI的发展趋势，以及阿里云大数据产品是如何顺应这种趋势而演进的。
1. 从数据湖到大数据AI一体 数据湖作为一种数据存储架构，允许以原始格式存储海量数据，无需预定义数据模型，为数据分析提供了极大的灵活性。在系统规模较小、数据处理需求相对简单时，数据湖能够很好地满足需求。其灵活的数据摄入和存储能力，使得企业能够快速响应业务变化，进行探索性数据分析。
但是，随着数据量的激增和业务复杂度的提升，数据湖的非结构化存储和缺乏数据治理开始暴露出问题。所以，特定规模前，数据湖灵活性占优，之后，数仓成长性占优。在数据湖时代，我们无法做到数据湖和数据仓库的成本和灵活性的平衡，各自都有非常大的问题。但是在湖仓一体时代，随着数据读取效率的变高，这个曲线的规律将会被打破，我们可以通过技术的优化与迭代逐渐去取得性能与成本的平衡。后续我们将介绍从数据湖到湖仓一体到大数据AI融合一体的演进。
数据湖的概念自提出以来，旨在创建一个统一的数据存储空间，以原始格式存储各类数据，供不同计算引擎访问和处理。然而，随着技术的发展，数据湖的局限性逐渐显现，尤其是在数据格式、数据治理和跨引擎共享方面，这促使了从数据湖到湖仓一体（Lakehouse），再到大数据AI一体架构的演进。
最初，数据湖设想中包含结构化、半结构化数据的统一存储，但缺乏统一的数据格式标准，导致计算引擎访问数据时效率低下。引擎往往需要自行解析数据，这不仅限制了数据的共享，还可能造成数据孤岛，即数据虽然存储在公共存储上，但实际上只对特定引擎可用。
为了解决这些问题，Lakehouse架构应运而生。Lakehouse在数据湖的基础上，引入了统一的表格式标准，如Delta、Hudi、Iceberg等，以及统一的SDK，使得数据在湖上能够被多个引擎以标准方式访问，从而实现了真正的湖仓一体。阿里云的Paimon、File Cache和Table Cache等技术，进一步优化了湖仓性能，使其接近本地数仓的水平。
随着大数据与AI的深度融合，对数据的统一管理提出了更高要求。大数据AI一体架构不仅关注结构化和半结构化数据，还需考虑AI引擎特有的数据格式，如特征向量等。这要求构建统一的元数据管理，以实现跨引擎的数据访问和处理。元数据管理成为连接不同数据源、引擎的关键，确保了数据的统一视图和高效利用。
然而，从数据湖到大数据AI一体的演进并非没有挑战。公共存储相比私有存储，在性能优化上存在天然劣势，因为私有存储可以针对特定引擎进行深度优化。但随着网络、存储I/O等技术的不断进步，这一差距有望缩小，甚至消失。正如神经网络的发展历程所示，技术进步最终克服了算力限制，推动了AI的广泛应用。
综上所述，大数据与AI的融合是一个持续演进的过程，从数据湖到大数据AI一体架构，不仅解决了数据格式、数据治理和跨引擎共享的挑战，还推动了数据管理技术的创新。尽管在性能优化上仍面临难题，但随着技术的不断进步，这些问题将逐渐得到解决，为大数据与AI的深度融合铺平道路。
2. 阿里云自研大数据产品 （1）MaxCompute 首先，MaxCompute，作为阿里云的旗舰级大数据处理平台，自诞生之日起便与阿里云的崛起紧密相连。MaxCompute的架构设计体现了阿里云在数据存储、计算、调度与服务层面的深厚积累。其核心层包括私有存储与公共存储，通过开放的存储API和SDK，实现了数据的灵活访问与管理。之上，弹性计算和调度层确保了资源的高效利用，能够根据业务需求动态调整计算能力。更进一步，MaxCompute集成了增量计算、元数据管理和开放API等高级功能，为用户提供了一站式的开发与服务体验。这些都属于标配的能力。
在功能与性能上，MaxCompute展现出了企业级安全、大规模数据处理和高可用性等关键优势。由于其早期服务于阿里巴巴集团内部高并发的淘宝、天猫等场景，MaxCompute在安全体系、数据规模处理和故障恢复机制上做了大量优化，确保了数据的完整性和系统的稳定性。此外，MaxCompute与算法的深度融合，使其在机器学习、数据挖掘等领域展现出了强大的应用潜力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/917c8f7605c6bbf61c18d7ca3181a21e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d592f5adbf0004e9b6e56f9570ff116/" rel="bookmark">
			Java面试题———Spring篇①
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一，谈谈你对SpringIOC的理解
二，Spring中有哪些依赖注入方式
三，你用过哪些Spring注解
四，SpringBean的作用域有几种
五，Spring中的bean线程安全吗
六，谈谈你对SpringAOP的理解
七，AOP的代理有几种方式
一，谈谈你对SpringIOC的理解 IOC，也叫控制反转，是Spring用来解耦的一种设计思想，它的做法就是将对象的控制权由程序员手中反转到Spring手中。具体来说呢就是，在没有IOC之前，对象都是程序员在类中主动去创建，需要哪个创建哪个；有了IOC之后，对象会交给Spring容器创建和管理，如果哪个对象中需要其它对象属性，Spring也会自动完成依赖注入。
总之一句话，IOC可以将对象的创建和对象之间依赖关系的维护交给Spring自动完成。
二，Spring中有哪些依赖注入方式 依赖注入指的是Spring给对象中属性进行赋值的过程，主要包括两种方式：
构造器依赖注入：构造器注入是指容器调用一个类的构造器创建对象时，直接传入给属性赋值
Setter方法注入：Setter方法注入是指容器在创建对象完成后，通过调用属性的Setter 方法，可以属性赋值
三，你用过哪些Spring注解 我们常用的Spring注解主要分类下面几大类：
1、创建对象：@Component、@Controller、@Service、@Repository
它们都可以标注在自己开发的类上，Spring会使用注解标注的类创建出对象，然后放入容器
2、依赖注入：@Autowired
标注在属性或者属性对应的set方法上，Spring会根据被标注属性的类型自动对属性进行赋值
3、依赖注入：@Qualifier和@Autowired
一块使用，在同一类型的bean有多个的情况下Spring会根据name进行选择注入
4、配置类：@Configuration、@Bean
主要标注在配置类中，用于声明配置类和向Spring容器中放入一些配置有关的对象
5、当然还有一些平时用的不是特别多的
比如：声明注解扫描的@ComponentScan，声明Bean的作用域的@Scope，用于切面编程的@Around，@Pointcut等等
四，SpringBean的作用域有几种 在Spring中作用域是用来对象的存活范围的，它支持5种作用域
第一种是单例，配置为单例的对象会跟随Spring容器创建而创建，跟随Spring容器销毁而销毁，在Spring容器中无论获取多少次单例对象，得到的都是同一个，这也是Spring中的对象的默认作用域
第二种是多例，配置为多例的对象在每次获取的时候才会创建，而且每次获取到的都不一样
还有三种分别是request、session和application，目前已经基本不再使用
其实，在我们平时的开发过程中，对象基本上都是配为单例的，这样可以有效的节省资源，只有单例对象存在线程安全问题时，才考虑调整为多例。
五，Spring中的bean线程安全吗 Spring中的Bean主要分为单例和多例
多例对象每次获取都会创建新实例，也就是说线程之间不存在Bean共享问题，也就不存在线程安全问题
单例对象是所有线程共享一个实例，因此就可能会存在线程安全问题。但是单例对象又分为无状态和有状态。
无状态Bean是指只对对象的成员变量进行查询操作，不会修改成员变量的值，因此不存在线程安全问题
有状态Bean需要对Bean中的成员变量进行数据更新操作，因此就可能存在线程安全问题
所以，最终我们得出结论，在Spring中，只有有状态的单例Bean才会存在线程安全问题
处理有状态单例Bean的线程安全问题有以下两种方法：
将Bean的作用域由单例改为多例
将需要的可变成员变量保存在ThreadLocal中， ThreadLocal本身就具备线程隔离的特性，这就相当于为每个线程提供了一个独立的变量副本，每个线程只需要操作自己的线程副本变量，从而解决线程安全问题。
六，谈谈你对SpringAOP的理解 AOP，又叫面向切面编程，核心思想是将那些与业务无关，却为业务模块所共同调用的逻辑（例如事务处理、日志管理）封装起来，然后再动态插入到业务中的功能
使用AOP可以减少系统的重复代码，降低模块间的耦合度，并有利于扩展和维护，Spring AOP是基于动态代理的，它底层同时支持JDK和CGLIB的代理方式，并且会根据被代理类是否有接口自动选择最合适的代理方式我们在开发中用到AOP的主要使用场景有：事务管理、日志、性能监视、安全检查
七，AOP的代理有几种方式 AOP思想的实现一般都是基于代理模式，在Java中一般采用JDK动态代理模式和CGLIB动态代理模式
JDK动态代理模式只能对有接口的类进行代理，而且效率较高
CGLIB可以对任意的类进行动态代理，但是效率上不如JDK
因此在进行代理时，如果被代理类有接口，就用JDK；如果没有接口，就用CGLIB
使用Spring的AOP，底层会自动按照这个规则进行选择，开发者也无需关心
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8338c8554702207a4c4700a6dfba1a7/" rel="bookmark">
			Uniapp之微信小程序计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UI仿的iOS手机计算器，基本功能已经实现，如下效果图
具体使用可以参考微信小程序：日常记一记--我的---计算器
第一步：UI界面设计
1，strClass模块是计算过程代码展示
2，result-view模块是结果展示
3，btns-view模块是计算器按钮模块
&lt;view class="content"&gt; &lt;view class="strClass"&gt;{{str}}&lt;/view&gt; &lt;view class="result-view"&gt; &lt;input class="result-box" type="text" v-model="number" disabled="true" :style="{fontSize: curFontSize}" /&gt; &lt;/view&gt; &lt;view class="btns-view"&gt; &lt;view v-for="(item,index) in buttons" :key="item.text" :class="[item.flag==false ? item.class:(item.class +' active')]" @click="jsqButton(item)"&gt;{{item.text}}&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; 4，js赋初始值
export default { data() { return { number: '0', //计算器显示区域值 str:"0",//计算过程初始值 buttons: [{//按键集合 text: 'AC', type: 'clear', class: 'ft-color bg-gray ml-zero btn-radius', params: 'clear', flag: false, }, { text: '+/-', type: 'operator', class: 'ft-color bg-gray btn-radius', params: 'opposite', flag: false, }, { text: '%', type: 'operator', class: 'ft-color bg-gray btn-radius', params: 'percent', flag: false, }, { text: '÷', type: 'operator', class: 'bg-orange btn-radius', params: 'divide', flag: false, }, { text: '7', type: 'num', class: 'bg-darkgray ml-zero btn-radius', params: '7', flag: false, }, { text: '8', type: 'num', class: 'bg-darkgray btn-radius', params: '8', flag: false, }, { text: '9', type: 'num', class: 'bg-darkgray btn-radius', params: '9', flag: false, }, { text: '×', type: 'operator', class: 'bg-orange btn-radius', params: 'multiply', flag: false, }, { text: '4', type: 'num', class: 'bg-darkgray ml-zero btn-radius', params: '4', flag: false, }, { text: '5', type: 'num', class: 'bg-darkgray btn-radius', params: '5', flag: false, }, { text: '6', type: 'num', class: 'bg-darkgray btn-radius', params: '6', flag: false, }, { text: '-', type: 'operator', class: 'bg-orange btn-radius', params: 'minus', flag: false, }, { text: '1', type: 'num', class: 'bg-darkgray ml-zero btn-radius', params: '1', flag: false, }, { text: '2', type: 'num', class: ' bg-darkgray btn-radius', params: '2', flag: false, }, { text: '3', type: 'num', class: ' bg-darkgray btn-radius', params: '3', flag: false, }, { text: '+', type: 'operator', class: 'bg-orange btn-radius', params: 'plus', flag: false, }, { text: '0', type: 'num', class: 'btn-size2 bg-darkgray ml-zero', params: '0', flag: false, }, { text: '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8338c8554702207a4c4700a6dfba1a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b94ff2e4b93af598ba1afc9349ea461c/" rel="bookmark">
			Eureka 原理与实践详解：深入理解与代码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Eureka 是 Netflix 开源的一个服务发现与注册中心，广泛应用于微服务架构中。它为微服务提供了一个简单、健壮的服务注册与发现机制，保证了服务之间的通信与协调。本文将深入探讨 Eureka 的工作原理，并通过实际代码示例分析其核心实现，帮助你更好地理解和使用 Eureka。
一、Eureka 的基本概念 1. 什么是 Eureka？
Eureka 是一个 RESTful 服务，用于在云环境中定位服务，以实现负载均衡和故障转移。它由两个核心组件组成：
Eureka Server：服务注册中心，负责服务的注册和管理。Eureka Client：服务实例，在启动时将自己注册到 Eureka Server，并定期发送心跳以保持其注册信息的最新状态。 2. Eureka 的基本流程
服务注册：每个微服务实例在启动时，将其自身信息（如 IP 地址、端口、状态）注册到 Eureka Server。服务续约：为了维持服务的可用状态，Eureka Client 定期向 Eureka Server 发送心跳（默认每30秒一次）。服务下线：当服务实例关闭时，它会向 Eureka Server 发送下线请求，将自己从注册表中移除。服务发现：客户端可以通过 Eureka Server 查询注册表，以获取其他服务的实例信息，实现服务调用。 二、Eureka 的工作原理 1. 服务注册与发现
Eureka 采用了客户端的缓存机制。Eureka Client 会从 Eureka Server 拉取注册表信息并缓存本地，从而减少对 Eureka Server 的依赖。客户端的服务调用不直接通过 Eureka Server，而是通过本地缓存的注册表进行负载均衡和服务发现。
2. 健康检查与剔除机制
Eureka Server 定期检查服务实例的健康状态。如果某个实例未能在指定时间内发送心跳（默认90秒），Eureka Server 会将其标记为不可用，并从注册表中剔除。
3. 高可用与集群模式
Eureka Server 可以配置为集群模式，多个 Eureka Server 之间会同步注册表数据，确保注册信息的一致性和高可用性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b94ff2e4b93af598ba1afc9349ea461c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/53/">«</a>
	<span class="pagination__item pagination__item--current">54/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/55/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>