<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62d340b76ed4749b13530f029ca74cef/" rel="bookmark">
			AI软件有哪些？知道这10款就够够的了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数字化时代，人工智能（AI）的崛起为各个领域带来了革命性的变革。越来越多的AI软件免费下载涌现，为我们的工作、创造和生活带来了新的可能性。而其中许多软件提供了免费下载，为个人和团队提供了强大的工具，彻底解放了生产力。l1m0_今天就为大家分享非常实用的10款！ 1.Pixso AI 作为国内知名产品设计一体化协作平台，AI软件免费Pixso AI集成白板、原型、设计、交付、管理等功能，覆盖产品设计全流程。在产品设计的各个环节都可以唤醒AI助手，完成产品设计各个阶段的内容创作，获取更多设计灵感和解决方案，节省设计师的时间和精力，彻底释放产品设计团队的生产力。
AI一键生图：在设计的探索阶段，AI软件免费Pixso AI集成强大的AI生图能力，只需要输入简单的文本内容，即可根据需求生成对应内容的图片。5种风格样式、6大通用尺寸、9类提示词，帮助产品设计团队完成视觉探索、素材配图、元素生成等工作。
AI生成设计规范：只需要输入具体的设计需求，并提供品牌的设计规范主色号，Pixso AI就能轻松生成完整的设计规范，无需任何设计基础也可以快速搭建设计系统，满足商业级别的设计需求。
AI语言大师：AI软件免费Pixso AI语言大师支持中文、英文、西班牙语、法语、韩语、日语、俄语、葡萄牙语、印度尼西亚与等9国家的语言，也可以选择自定义、100字符以内，口语化、专业化，古风化等5种风格语言，赋予产品设计生动的语言，让设计师更加专注设计本身。
AI灵感专家：面对设计过程中的创作瓶颈，AI软件免费Pixso AI下载开放了9大灵感生成工具，包括UI知识问答、随机人名、论坛评论、彩虹屁、生成需求文档框架、用户画像、用户旅程地图以及生成代码等，帮助产设研团队打破思维定式，满足用户在不同领域的创意需求。
2.Jasper Jasper是一款AI软件免费下载的人工智能写作助手，专注于协助用户高效创作优质内容。它的目标是生成引人入胜的长文本，吸引读者并提升流量。Jasper被广泛应用于内容创作者、营销人员和企业，帮助他们实现内容创作的自动化与提升。与其他平台相比，Jasper独具特色之处在于它的声音和记忆功能，能够把输入的内容从通用转化得具体且实用。
保存品牌声音指引和重要企业信息，确保内容与品牌紧密相关。提供多样化的写作模板，满足短期任务和长篇内容的需求。引入Jasper Chat，一款强大的AI聊天机器人，为ChatGPT的有效替代品。Chrome浏览器扩展程序将人工智能生成引入互联网上的各个文本框。 3.Copy.ai AI软件免费下载Copy.ai是一款适用于各种写作任务的全能人工智能写作助手。它旨在帮助用户生成高质量的文本，可用于各种用途，包括博客文章、社交媒体内容和销售邮件等。无论是作家、营销人员还是企业，都可以利用Copy.ai提升内容创作和营销工作的效率。
人工智能聊天机器人可实时访问互联网数据，提供更准确的回应。内联文档编辑器能轻松创建和编辑内容。预先构建的提示有助于引导内容生成过程。支持多种语言，满足不同用户的需求。 4.​​​​​​​WriteSonic AI软件免费下载WriteSonic是一款功能齐全的综合人工智能内容创作平台。它涵盖了人工智能写作的核心要点，同时提供100多个写作技巧和模板，适用于各类应用场景。它能在瞬间生成完整的博客文章，阐述所选文本，编写产品描述，甚至帮助撰写Google Ads文案等多种用途。
使用Photosonic进行人工智能艺术创作，提供出色的创作效果。ChatSonic支持GPT-4的AI聊天机器人助手，为交互提供更多可能性。提供易于使用的内容创建界面，简化内容创作的流程。 5.​​​​​​​Hoppy Copy AI软件免费下载Hoppy Copy是一个以人工智能为驱动的平台，旨在革新营销人员和销售人员在电子邮件活动方面的创作方式。它不仅仅提供人工智能文案，更是一个全面的工具，助你从起草到编辑，甚至监测竞争对手策略的每个步骤。Hoppy Copy能够帮助你省去大量时间，让你能在短短几秒钟内为数百个电子邮件营销活动、滴滴、时事通讯等生成引人注目的内容。
自动生成独特的活动创意、巧妙的标题、引人注目的主题行以及具有强烈号召力的用语等。实时追踪竞争对手的电子邮件策略，深入学习他们的举措。自动识别并替换可能会使你的电子邮件被识别为垃圾邮件的关键词。 6.Google Assistant AI软件免费下载Google Assistant是由谷歌开发的人工智能虚拟助手，致力于双向对话，可协助用户设置提醒事项、解答疑问并操控智能家居设备。Google Assistant可在绝大多数Android、Google Home和Wear OS设备上使用。Google Assistant作为一款人工智能虚拟助手，为用户提供了更加智能便捷的操作体验，有效地辅助日常任务和需求。
支持通过语音和文本指令来启动各项任务。帮助用户完成设定提醒、更新联系人、回答问题等多种任务。可操控智能家居设备，提升生活便捷度。只需说出“嘿 Google”，即可轻松地调用助理功能。 7.Tykr AI软件免费下载Tykr是一款人工智能财务助手，旨在帮助用户做出明智的投资决策。它为用户提供了清晰、可行的股票市场洞察力，帮助发现最佳的投资机会。虽然Tykr不会自动执行股票市场操作，但它极大地改善了研究工作，因此你可以更加自信地进行买卖操作。
提供股票市场的明晰、可行的洞察力，包括特价、观察和定价过高的标签/分数。利用开源模型分析股票、ETF和加密货币。提供有益的投资基础知识课程，帮助用户学习投资知识。 8.​​​​​​​Wally Wally是一款AI软件免费下载的人工智能财务助手，专注于协助用户有效管理个人财务。其个性化的帮助方式致力于为用户提供最优的支持。该应用的目标是提供消费习惯的洞察，帮助用户更有效地制定预算，实现理财目标并积累财富。用户只需将银行账户与Wally连接，然后与助手进行对话，即可了解财务前景和银行对账单的评估。
提供关于消费习惯的深入见解，帮助用户更好地了解个人支出状况。助力用户有效规划预算，实现理财目标并节省资金。轻松连接银行账户，轨迹每个关键数据点，为用户提供准确的财务数据。 9.​​​​​​​Amazon Code Whisperer AI软件免费下载Amazon Code Whisperer是一项由人工智能驱动的服务，专注于辅助开发人员进行代码审查并优化应用程序性能。该服务的目标是为开发人员提供智能建议，帮助他们快速识别和解决代码问题，从而提升代码质量和应用程序效能。
主要特点：
支持多个集成开发环境（IDE），跨越多种编程语言，从而满足不同开发项目的需求。提供智能建议，协助开发人员快速发现并修复代码问题，促进代码质量的提升。跨代码库的引用跟踪，有助于开发人员更准确地了解和管理不同代码库之间的关系。 10.​​​​​​​SurferSEO
AI软件免费下载SurferSEO是一款强大的人工智能SEO助手，旨在帮助用户优化网站内容，以提升搜索引擎的排名。通过分析关键词在搜索引擎结果页面（SERP）中的排名，它能够揭示哪些因素影响热门文章的排名，助你了解如何最佳优化文章，以提高竞争力。此外，它还能借助人工智能生成大纲和完整文章，为你提供全方位的SEO改进方案。
提供基于数据的见解，涵盖SERP和每个关键词的热门文章情况。帮助用户对内容进行搜索引擎优化，从而提升网站在搜索结果中的排名。与Jasper、Writesonic、WordPress和Google Docs等工具集成，提供更便捷的操作体验。 免费AI软件的出现为我们带来了更多的机会和可能性。无论是个人创作还是团队合作，这些软件都可以帮助我们更高效地实现目标。随着技术的不断发展，我们可以期待更多优秀的免费AI软件涌现，为我们的工作和生活带来更多的便利与创新。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d1b0582d2b65be8886209f0723ebdb0/" rel="bookmark">
			解决Github copilot访问速度慢、资源加载问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		github 是全世界最流行的开源项目托管平台，其代表的开源文化从根本上改变了软件开发的方式。
基本上所有的需求都能从 github 上或多或少找到现成的实现方案，再也不用重头开始造轮子而是自定义轮子！
然而，有时候国内访问 GitHub 速度太慢,如何加速访问 github.com 网站就成了刚需。
我们可以 通过 国外在线检测网站: 链接: ip检测 查找域名对应的真实 ip 地址，然后加到自己本机Hosts中。
亲测有效hosts # github 140.82.114.4	github.com 199.232.5.194	github.global.ssl.fastly.net 199.232.68.133	githubusercontent.com 199.232.68.133	user-images.githubusercontent.com 199.232.4.133	raw.githubusercontent.com 修改hosts 、刷新dns缓存 不同的操作系统具体文件存放的地址可能有些不同，下面我们以 Windows 和 Mac 举例说明。
Windows 映射文件存放于: C:\Windows\System32\drivers\etc\hosts
打开修改后，运行ipconfig /flushdns 刷新 dns 缓存。
Mac 映射文件存放于 /etc/hosts。
打开修改后，运行 sudo dscacheutil -flushcache 刷新 dns 缓存。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dd9264501e3a2c7bc505065061918ee/" rel="bookmark">
			【数据结构】单链表OJ题（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥博客主页：小王又困了
📚系列专栏：数据结构
🌟人之为学，不日近则日退 ❤️感谢大家点赞👍收藏⭐评论✍️
目录
一、移除链表元素
💡方法一：
💡方法二：
二、链表的中间节点
💡方法一：
三、链表中倒数第k个结点
💡方法一：
四、反转链表
💡方法一：
💡方法二：
五、合并两个有序链表
💡方法一： 🗒️前言：
在上一期中我们给大家介绍了单链表，也了解了单链表的实现。接下来就让我们进入实践，练习一些经典题目，让我们对单链表的理解更加深入。
一、移除链表元素 题目：
💡方法一： 我们使用两个指针遍历数组，遇到与 val 相同的数据域，就删除这个节点。我们在思考问题时要想全面，当要删除头节点时，常规方法就无法实现，对于删除头节点要做单独处理。
🍩常规删除： 🍩头节点删除
struct ListNode* removeElements(struct ListNode* head, int val) { struct ListNode* prev=NULL; struct ListNode* cur=head; while(cur!=NULL) { //删除 if(val==cur-&gt;val) { //头删 if(cur==head) { head=cur-&gt;next; free(cur); cur=head; } //常规 else { prev-&gt;next=cur-&gt;next; free(cur); cur=prev-&gt;next; } } //遍历 else { prev=cur; cur=cur-&gt;next; } } return head; } 💡方法二： 我们通过遍历，把节点的数据域不等于val的节点尾接到新的链表中。我们要考虑第一个节点是不是要删除的。最后一个节点的指针域置空要放在循环结束后，判断tail是否为空指针。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dd9264501e3a2c7bc505065061918ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c47ea7a17597a415d934a80f3c93480/" rel="bookmark">
			走进人工智能|深度学习 算法的创世纪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
深度学习通过训练深层神经网络模型，可以自动学习和提取数据的特征，包括更准确的图像识别、自然语言处理、医学诊断等方面的应用。
文章目录 序言背景算法的创世纪技术支持应用领域程序员如何学总结 序言 深度学习是一种机器学习方法，其目标是通过模拟人脑神经网络的结构和功能，让机器能够从大量的数据中自动学习和提取特征，从而实现智能化的数据处理和决策。深度学习的核心思想是建立多层次的神经网络，通过层与层之间的连接和信息传递，对输入数据进行逐层的特征提取和抽象，最终实现对复杂任务的准确预测和分类。
背景 深度学习的基本概念包括神经网络、前向传播、反向传播和深度学习框架等。神经网络模仿人脑神经系统中的结构和功能，由多个神经元连接组成。
起源和早期探索（1943-1956年）： 深度学习的起源可以追溯到1943年，当时神经生理学家Warren McCulloch和逻辑学家Walter Pitts合作提出了第一个人工神经元模型。随后，1956年举行的达特茅斯会议被视为人工智能领域的里程碑事件，启发了深度学习等领域的研究。
进入冬眠期（1960-1980年）： 在20世纪60年代至80年代，深度学习进入了一个相对低谷的时期。由于当时计算能力的限制和缺乏有效的训练算法，深度神经网络的研究受到了限制，人工智能研究的重心转向了符号推理和专家系统等领域。
重新崛起（1980-2010年）： 随着计算能力的提升和新的理论突破，深度学习在20世纪80年代和90年代重新崛起。其中，1986年，Rumelhart、Hinton和Williams提出的反向传播算法为深度学习的训练提供了一种有效的方法。此外，1998年，Yann LeCun等人的工作展示了卷积神经网络在图像识别方面的潜力，为深度学习的应用提供了重要的突破。
深度学习的复兴（2010年至今）： 2010年以后，深度学习开始进入新的黄金时代。这得益于大规模数据集的可用性、计算能力的飞速提升以及新的神经网络架构的出现。其中，Hinton等人的工作在ImageNet竞赛中展示了深度卷积神经网络的卓越性能，引发了对深度学习的广泛关注。此后，深度学习在计算机视觉、自然语言处理、语音识别等领域取得了重大突破。
算法的创世纪 深度学习是一种革命性的人工智能技术，为算法带来了巨大的革新，同时也开创了一个全新的时代。 其强大的特征提取能力和端到端学习方法使得深度学习在图像识别、语音处理、自然语言处理等领域取得了惊人的成果。本文将详细讲解深度学习对算法带来的革新以及创世纪的过程。
深度学习的革新体现在表征学习与特征提取方面 传统的机器学习方法通常需要人工设计和选择特征，但随着问题复杂性的增加，手工设计特征变得困难且耗时。而深度学习通过多层神经网络模型自动学习和提取数据的特征，无需依赖人工特征设计。这种自动化的特征提取能力使得深度学习在图像、语音和文本等领域表现出色，为算法的发展带来了巨大的推动力。 深度学习引领了算法的创世纪 过去，神经网络作为一种模拟人脑神经元连接的模型已经存在多年，但由于计算能力和数据规模的限制，神经网络的发展相对缓慢。然而，随着计算机硬件和大规模数据的可用性提升，深度学习算法在2006年至2012年期间取得了突破性进展。重要的里程碑包括深度信念网络（DBN）的提出和卷积神经网络（CNN）在图像识别竞赛中的惊人表现。这些里程碑推动了深度学习的快速发展，使其成为当今人工智能领域最具影响力的技术之一。
深度学习的创世纪得益于硬件和软件的支持 图形处理器（GPU）的发展为深度学习计算提供了强大的计算能力，使得大规模的神经网络训练成为可能。同时，深度学习框架（如TensorFlow、PyTorch）的出现使得模型训练和部署更加简单和灵活。这些硬件和软件的进步为深度学习的广泛应用提供了基础，推动了其在各个领域的成功应用。 技术支持 深度学习作为一种强大的人工智能技术，背后依赖着多个关键技术支持，这些技术支持是深度学习能够取得巨大成功的基础。在本文中，笔者将详细讲解深度学习背后的技术支持，使读者更好地了解其原理和实现方式。
神经网络架构： 神经网络是深度学习的核心组成部分。深度学习采用多层神经网络模型，其中包含输入层、多个隐藏层和输出层。这些层之间的神经元通过权重连接，并通过激活函数进行非线性变换。这种层级结构使得神经网络可以从数据中学习更高级别的特征和模式。 反向传播算法： 反向传播是深度学习中用于训练神经网络的核心算法。它通过计算损失函数对网络参数的梯度，并将梯度从输出层传播到输入层，从而更新网络的权重和偏置。反向传播算法实现了误差的反向传递和参数的优化，使得神经网络能够逐步调整自身以更好地拟合数据。 优化算法： 深度学习中的优化算法用于最小化损失函数并寻找最优的网络参数。常用的优化算法包括梯度下降、随机梯度下降（SGD）、Adam等。这些算法通过不断调整网络参数，使得神经网络在训练过程中逐渐逼近最优解。 计算加速硬件` 深度学习的训练和推理过程对计算资源的需求非常高。为了加快深度学习模型的训练速度，研究人员提出了各种计算加速硬件，如图形处理器（GPU）和专用的深度学习加速器（如Tensor Processing Unit）。这些硬件可以并行执行矩阵运算和张量操作，大幅提升深度学习的计算效率。
大规模数据集和云计算： 深度学习模型通常需要大量的数据进行训练，而随着互联网的发展，我们可以轻松地收集和存储海量数据。大规模数据集为深度学习提供了更多的训练样本，使得模型能够更好地学习数据的分布特征。同时，云计算平台的出现为深度学习提供了强大的计算和存储资源，使得大规模模型的训练和部署变得更加可行和高效。
开源框架和工具： 为了方便研究人员和开发者使用深度学习技术，许多开源的深度学习框架和工具被开发出来，如TensorFlow、PyTorch、Keras等。这些框架提供了丰富的函数库和API，简化了深度学习模型的构建、训练和部署过程。
应用领域 作为一位笔者，我将详细阐述深度学习在几个实体应用领域的重要性和突破。深度学习作为一种强大的人工智能技术，以其出色的模式识别和特征提取能力，在各个行业中都发挥着重要作用。
医疗保健： 深度学习在医疗保健领域具有巨大潜力。它可以用于医学影像分析，如肿瘤检测、疾病诊断和脑部扫描等。深度学习还可以用于生物信息学，分析大规模的基因组数据，帮助研究人员了解疾病的发病机制和个体化治疗。此外，深度学习还可以应用于医疗记录的自动化处理和医疗咨询系统的开发，提高医疗保健的效率和准确性。 金融服务： 深度学习在金融服务领域的应用越来越广泛。它可以用于信用评分和风险管理，通过分析大量的金融数据，帮助银行和金融机构识别潜在的欺诈行为和风险因素。深度学习还可以应用于股票市场的预测和交易策略的优化，帮助投资者做出更明智的投资决策。此外，深度学习在高频交易、智能客服和虚拟助理等金融应用中也发挥着重要作用。 交通和智能交通： 深度学习在交通领域有着广泛的应用。它可以用于交通流量预测和拥堵监测，帮助城市规划者优化交通流动和减少交通拥堵。深度学习还可以用于智能驾驶和自动驾驶技术，通过对传感器数据的实时分析，实现车辆的自主导航和智能决策。此外，深度学习还可以应用于智能交通信号控制和交通事故预测，提高交通安全性和效率。 零售和电子商务： 深度学习在零售和电子商务领域的应用也越来越重要。它可以用于商品推荐和个性化营销，通过分析用户的购买历史和行为模式，向用户提供个性化的推荐和购物建议。深度学习还可以应用于商品图像识别和视觉搜索，使用户可以通过图片搜索相关的商品。此外，深度学习还可以用于供应链管理和库存优化，帮助企业提高运营效率和客户满意度。 媒体和娱乐：
深度学习在媒体和娱乐领域有着广泛的应用。它可以用于视频内容分析和标记，实现自动视频标签和内容搜索。深度学习还可以应用于音乐生成和推荐，帮助用户发现新的音乐和艺术家。此外，深度学习还可以用于虚拟现实和增强现实技术，提供更沉浸式和交互式的娱乐体验。 程序员如何学 作为一个程序员，理解和应用深度学习技术需要坚实的基础知识、实践的经验和持续的学习。通过系统学习基础知识、参与实践项目和追踪最新技术，你将能够在深度学习领域取得更好的发展，并为实现各种创新和应用提供强有力的支持。
要理解和应用计算机视觉技术，你需要采取一系列有针对性的学习和实践步骤。下面我将分成三个自然段，为你详细讲解。
1. 建立坚实的数学和统计基础：深度学习是建立在数学和统计学的基础上的。作为程序员，需要掌握线性代数、微积分和概率论等数学知识，并理解它们在深度学习中的应用。这将帮助理解深度学习的原理和算法，并能够更好地进行模型调整和优化。
你可以通过参加在线课程、阅读相关书籍和论文，以及参与深度学习社区来学习这些基础知识。建议学习一门编程语言，如Python，因为它在计算机视觉领域应用广泛，并且有许多优秀的开源库和工具可供使用。
2. 深入学习深度学习的理论知识： 学习深度学习的理论知识是必不可少的。可以通过阅读经典的深度学习教材和论文，掌握深度学习的基本概念、模型架构和训练算法。了解不同类型的神经网络（如卷积神经网络、循环神经网络和生成对抗网络）以及它们的应用场景和特点。
此外，参与开源社区和团队合作也是提高实践能力的好方法。与其他深度学习开发者分享经验和交流，可以加速你的学习和成长。
3. ·持续学习和实践：深度学习是一个快速发展的领域，不断更新的技术和算法需要保持学习的状态。定期阅读最新的研究成果和论文，关注深度学习领域的新兴技术和趋势。同时，通过不断实践和解决实际问题，提升自己的深度学习
实践项目和编程实验：深度学习的实践是提高技能的关键。可以选择一些经典的深度学习项目，如图像分类、目标检测或自然语言处理，尝试使用深度学习框架（如TensorFlow或PyTorch）实现这些项目。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c47ea7a17597a415d934a80f3c93480/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7054fac5e0b0ffa7fbde0dfbea602f67/" rel="bookmark">
			Java中if判断语句的使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：if判断语句是Java中最基本也是最常用的流程控制语句之一。本文将详细介绍Java中if语句的用法和常见的应用场景，帮助读者深入理解并正确使用if语句。
正文：
一、if语句的基本语法
//在Java中，if语句的基本语法如下： if (condition) { // 如果条件为真执行的代码块 } else { // 如果条件为假执行的代码块 } 其中，condition为一个布尔表达式，即返回true或false的表达式。如果condition为true，就执行if后面的代码块；如果condition为false，就执行else后面的代码块。
二、if语句的嵌套使用
if语句还可以进行嵌套使用，即在if或else代码块中再包含if语句。嵌套的if语句可以根据多个条件进行判断，例如：
if (condition1) { // 如果条件1为真执行的代码块 if (condition2) { // 如果条件2为真执行的代码块 } else { // 如果条件2为假执行的代码块 } } else { // 如果条件1为假执行的代码块 } 通过嵌套使用if语句，我们可以根据不同的条件执行不同的代码块，从而实现更复杂的逻辑控制。
三、if语句的应用场景
1条件判断 if语句最常见的应用场景就是进行条件判断。我们可以根据不同的条件来执行不同的操作。例如：
int num = 10; if (num &gt; 0) { System.out.println("num是正数"); } else if (num &lt; 0) { System.out.println("num是负数"); } else { System.out.println("num是零"); } 2循环控制 在循环中，我们可以使用if语句来控制循环的执行。例如，我们要在数组中查找某个特定的元素，可以使用如下代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7054fac5e0b0ffa7fbde0dfbea602f67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de2ab62a697fb533857e067ad3e142c8/" rel="bookmark">
			十种Webpack的优化方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Webpack是一个现代化的前端构建工具，用于打包和构建项目中的各种资源文件。在使用Webpack时，可以采取以下一些方法对其性能进行优化： 1、减少入口文件大小： 将入口文件拆分为多个较小的模块，使用动态导入（dynamic imports）按需加载，减少初始加载的文件大小。
2、代码分割（Code Splitting）： 通过配置Webpack的代码分割功能，将项目代码分割成多个块（chunks），并且在需要的时候按需加载。
3、使用Tree Shaking： 通过配置Webpack的Tree Shaking功能，只保留项目中实际使用到的代码，剔除未使用的代码，减少打包后的文件大小。
4、优化加载速度： 使用Webpack的插件如MiniCssExtractPlugin来提取CSS代码，使用babel-loader的缓存机制等，以减少构建时间和加载时间。
5、并行构建： 使用Webpack的thread-loader或happypack插件将任务分发给多个子进程并行处理，提高构建速度。
6、优化文件体积： 使用Webpack的压缩插件如terser-webpack-plugin来压缩JavaScript代码，使用cssnano等工具压缩CSS代码，减小文件体积。
7、使用缓存： 配置Webpack的缓存功能，使得构建过程中只重新构建发生更改的部分，而不是每次都重新构建整个项目。
8、懒加载与预加载： 对于大型应用，使用Webpack的懒加载（Dynamic Import）功能，按需加载非关键性资源；同时可以使用预加载（Preload）和预解析（Prefetch）机制提前加载关键资源。
9、优化图片资源： 对于图片资源，可以使用Webpack的url-loader或file-loader来压缩和处理图片，并根据需要进行懒加载或响应式加载。
10、配置合理的模块解析规则： 通过配置Webpack的resolve选项，设置合适的模块解析规则，避免过多的文件查找和解析过程。
通过以上这些优化策略，可以显著提升Webpack的构建性能，减少打包后文件的体积，加快项目的加载速度，从而提升用户体验。需要根据具体项目需求和场景灵活应用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7af77ed07dad210f41b139e2d694e350/" rel="bookmark">
			stable diffusion中webui-user.bat配置后无法开启的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般来说，安装sd的webui都是git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui
然后就会将这个webui组件下载下来。
但是我下载后，并且将电脑中python的路径复制进去后，webui-user.bat打开没反应。
然后我尝试直接从github的项目页上手动下载：
再配置一下python路径，就顺利打开了。
希望对你有帮助
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fe7b5779d00e6d840f58b0fae03f226/" rel="bookmark">
			Oracle连接数据库提示 ORA-12638:身份证明检索失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ORA-12638 是一个 Oracle 数据库的错误代码，它表示身份验证（认证）检索失败。这通常与数据库连接相关，可能由于以下几个原因之一引起：
错误的用户名或密码： 提供的数据库用户名或密码不正确，导致身份验证失败。
配置问题： 数据库配置文件（如 sqlnet.ora 或 listener.ora）中的一些配置可能导致连接问题。
网络问题： 连接数据库时遇到网络问题，可能导致无法正确地进行身份验证。
安全设置： 数据库的安全设置可能导致身份验证失败，例如密码策略、用户锁定等。
要解决这个问题，你可以尝试以下步骤：
确认用户名和密码： 确保你提供的用户名和密码是正确的。可能是输入错误，或者账户已被禁用或锁定。
检查网络连接： 确保你的网络连接正常，可以尝试使用 ping 命令来测试数据库服务器的可访问性。
查看配置文件： 检查 sqlnet.ora 和 listener.ora 等配置文件，确保其中的设置正确。
密码策略： 如果你的数据库有密码策略，确保你的密码符合要求。
检查账户状态： 如果账户被锁定或者过期，尝试解锁或者重置密码。
尝试其他工具： 如果问题持续存在，可以尝试使用其他 Oracle 连接工具，如 SQL*Plus 或 SQL Developer，看看是否仍然遇到相同的问题。
如果你无法解决问题，建议与你的数据库管理员或支持团队联系，以获取更详细的帮助和解决方案。
如下图所示：
这是由于Oracle的认证方式导致的，使用了本地操作系统认证（NTS），修改为口令文件认证（NONE）即可，修改方法如下：
1、找到sqlnet.ora文件，我们先不登陆看下sqlnet.ora的文件路径：
我们重新打开PL/SQL Developer 输入用户名密码 登陆即可，如果不行，可以重启下Oracle服务试下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/458cf1369ec97fc337a0f7b05f9d44c5/" rel="bookmark">
			《Linux从练气到飞升》No.07 Linux第一个小程序－进度条的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🕺作者： 主页
我的专栏C语言从0到1探秘C++数据结构从0到1探秘Linux菜鸟刷题集 😘欢迎关注：👍点赞🙌收藏✍️留言
🏇码字不易，你的👍点赞🙌收藏❤️关注对我真的很重要，有问题可在评论区提出，感谢阅读！！！
前言 前面几章我们讲述了Linux指令、权限管理、编辑器、编译器、软件包管理器、自动化管理工具，也写了简单的”Hello World“程序，但是没有实现过复杂一点的程序，光说不练假把式，今天就带大家来做一个小项目–进度条。
搭建框架 在写代码之前，我们先把文件先建好。
vim main.c vim process.c vim process.h vim makefile 书写代码 在写代码要先讲一个知识点。
1.回车换行
在我们日常使用回车键时，是否注意到，当我们按下回车键，也就是\n，光标就会换到第二行的开始，其实这里面有两个动作，换行和把光标设置到行开始，在C语言中可用\r来把光标换到开始位置
我们来借此写个小demo：倒计时
void download() { int cnt=10; while(cnt!=0) { printf("%-2d\r",cnt); fflush(stdout); cnt--; sleep(1); } printf("\n"); } 效果如下：
第一版 我们最终要实现这个效果：
我们前面讲了\r可以把光标移到行始，所以在我们输出缓存字符的时候，每一次都移到一开始的位置，随着缓存字符的增多，来实现进度条的效果。
代码如下：
process.c
#include"process.h" const char *lable="|/-\\";//通过循环实现一个转动的效果 char bar[NUM]; void download(int speed) { char bar[NUM];//使用数组来存储”缓存字符“ memset(bar,'\0',sizeof(bar));//初始化 int len =strlen(lable); int cnt=0; while(cnt&lt;=TOP)//设置终止条件 { printf("[%-100s][%d%%][%c]\r", bar, cnt, lable[cnt%len]); //%-100s：预留100个空间左对齐 //%%：输出%，也可以使用\% //\r：把光标移到开始位置 fflush(stdout);//清空缓存区 bar[cnt++]=BODY;//将cnt所在位置设置为”BODY"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/458cf1369ec97fc337a0f7b05f9d44c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5acd5567b8bdef93bb893280620e86cb/" rel="bookmark">
			10.Eclipse配置Tomcat详细教程、如何使用Eclipse&#43;tomcat创建并运行web项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Tomcat的下载官网 -&gt; 进入官网显示如图所示的界面，在下下载的是Tomcat9.0版本，你可以自己选一款
点击然后进入下面这个界面
最好是在你的D盘建立一个文件夹，把它解压在里面，文件夹名自己来吧，自己能知道里面装的是什么就行。在下的解压文件大概如图所示：
记住解压的这个路径后面会用到！！！ 接下来就是怎么把它搞进Eclipse里面了~~
二、在eclipse中配置Tomcat相关设置
1、点击左上角的【Window】（窗口）→点击【Preferences】（首选项）
2、点击【Server】（服务器）→点击【Runtime Environments】（运行时环境）→点击【Add】添加Tomcat
3、双击【Apache】文件展开
4、找到你所下载的Tomcat版本，然后单击【Next】下一步。（因为我下载的是Tomcat8.5.87版本，所以选择了Apache Tomcat v8.5版本）
5、点击【Browse】找到你的apache-tomcat文件所在位置
6、找到tomcat安装位置后，点击【Installed JRES】添加JRE文件，（注：如果你不想想配置JRE,可直接默认选择"Workbench default JRE"，然后直接单击【Finsh】完成）
7、点击【Add】
8、选择"Standard VM"，然后单击【Next】下一步
9、点击【Directory】找到JRE文件，如果你没有安装JRE文件，那么也可以像我一样找到你所下载的JDK文件，JDK文件里也有自带的jre文件，然后单击【Finsh】完成。（请记住【JRE name】这一栏的名字，等下用的的上，这个名字可以随便取，我的名字叫JDK1.8）
10、勾选你刚刚配置好的JRE文件路径，然后点击【Apply and Close】（应用并关闭）
11、选择你刚刚配置好的jre文件（我设置的名字叫JDK1.8），点击【Finsh】完成
12、点击“Apache Tomcat v8.5”，然后再点击【Apply and Close】应用并关闭
13、点击【Window】（窗口）→点击【Show View】（显示视图）→点击【Other】（另外）
14、向下滑找到Server文件双击展开，点击Servers，然后再点击【open】启动服务器
15、点击Servers，然后点击“No servers availaable. Click this link to create a new server”。
16、双击Apache文件展开，选择你所下载的tomcat版本，然后点击【Finsh】完成
三、检验Tomcat是否配置成功
1、鼠标右键点击"Tomcat v8.5 Server at localhost [Stopped]",点击【Start】启动Tomcat
2、正在启动
3、启动完后，不要关闭eclipse，直接去浏览器的地址栏中输入 "http://localhost:8080"看是否会出现如图以下的界面，如果有则表明你Tomcat在eclipse中配置成功了！
四、Eclipse+tomcat创建并运行web项目
首先建立一个web项目（FIle==》New==》Dynamic Web Project)
接着创建项目名字如图，Target runtime 选择我们的服务器，我的就是Apache Tomcat v 9.0，接着点击下一步就行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5acd5567b8bdef93bb893280620e86cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b3452041d8e1c88f739e0c3354bd100/" rel="bookmark">
			RabbitMQ清除积压消息/管理界面出现 Unacked 消息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题：
rabbitmq的生产者端循环产生了多条消息给消费者，而消费者无法及时将消息处理掉，在消费端积压了多条消息（消费失败的时候，消息队列会一直重复的发送消息，导致程序死循环）需要清理项目因为错误而产生的积压消息队列。
2.原因：
消息接收方因退出企业，账号已注销，企业微信报错81013，导致无法处理消息，消息积压。
3.处理办法（问题已处理，截图为示例）：
（1）登录rabbitmq管理面板，点击queues标签。
（2）查看unacked列，如果&gt;0,消息积压。
（3）点进name列消息积压的行。
（4）往下拉，先点击“purge message”清除队列。
（5）如果消息还在，点击“delete queue”删除队列。
4.附：rabbitmq 管理面板 Queues 中 features 各参数释义指南https://blog.ytso.com/251403.html
Features 功能
D：d 是 durable 的缩写，代表这个队列中的消息支持持久化。
AD：ad 是 autoDelete 的缩写。代表当前队列的最后一个消费者退订时被自动删除。注意：此时不管队列中是否还存在消息，队列都会删除。
excl：是 exclusive 的缩写。代表这是一个排他队列。如果一个队列被声明为排他队列，该队列仅对首次声明它的连接可见，并在连接断开时自动删除。这里需要注意三点：其一，排他队列是基于连接可见的，同一连接的不同信道是可以同时访问同一个连接创建的排他队列的。其二，“首次”，如果一个连接已经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同。其三，即使该队列是持久化的，一旦连接关闭或者客户端退出，该排他队列都会被自动删除的。这种队列适用于只限于一个客户端发送读取消息的应用场景。
Args：是 arguments 的缩写。代表该队列配置了 arguments 参数。
TTL：是 x-message-ttl 的缩写。设置队列中的所有消息的生存周期(统一为整个队列的所有消息设置生命周期), 也可以在发布消息的时候单独为某个消息指定剩余生存时间，单位毫秒。
Exp：Auto Expire，是 x-expires 配置的缩写。当队列在指定的时间没有被访问(consume, basicGet, queueDeclare…)就会被删除，Features=Exp。注意这里是删除队列，不是队列中的消息。
Lim：说明该队列配置了 x-max-length。限定队列的消息的最大值长度，超过指定长度将会把最早的几条删除掉。
Lim B：说明队列配置了 x-max-length-bytes。限定队列最大占用的空间大小， 一般受限于内存、磁盘的大小。
DLX：说明该队列配置了 x-dead-letter-exchange。当队列消息长度大于最大长度、或者过期的等，将从队列中删除的消息推送到指定的交换机中去而不是丢弃掉。
DLK：x-dead-letter-routing-key 的缩写，将删除的消息推送到指定交换机的指定路由键的队列中去。
Pri：x-max-priority 的缩写，优先级队列。表明该队列支持优先级，先定义最大优先级值(定义最大值一般不要太大)，在发布消息的时候指定该消息的优先级， 优先级更高（数值更大的）的消息先被消费。
Ovfl：x-overflow 的缩写。队列中的消息溢出时，如何处理这些消息。要么丢弃队列头部的消息，要么拒绝接收后面生产者发送过来的所有消息。有两个配置项：drop-head，代表丢弃队列头部的消息，默认行为；reject-publish 设置队列中的消息溢出后,该队列的行为:”拒绝接收”(所有消息)。
ha-all：镜像队列。all 表示镜像到集群上的所有节点，ha-params 参数忽略。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0e9b408d4e41dfb749ef294bf0fef2f/" rel="bookmark">
			数据结构和算法——哈希查找冲突处理方法（开放地址法-线性探测、平方探测、双散列探测、再散列，分离链接法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
开放地址法（Open Addressing）
线性探测（Linear Probing）
散列表查找性能分析
平方探测（Quadratic Probing） 定理
平方探测法的查找与插入
双散列探测法（Double Hashing） 再散列（Rehashing）
分离链接法（Separate Chaining）
平均查找次数
分离链接法的散列表实现
常用处理冲突的思路：
换个位置：开放定址法同一位置的冲突对象组织在一起：链地址法 开放地址法（Open Addressing） 一旦产生了冲突（该地址已有其它元素），就按某种规则去寻找另一空地址。
若发生了第次冲突，试探的下一个地址将增加，基本公式是：
的不同决定了不同的解决冲突方案：线性探测、平方探测、双散列。
线性探测：平方探测：双散列： 线性探测（Linear Probing） 线性探测法：以增量序列1,2，......，（TableSize-1）循环试探下一个存储地址。
通俗地来讲，就是当发生冲突时，将关键词+1；检测地址是否为空，如果不为空，就继续+1；如果为空，则表明不冲突了。
【例】设关键词序列为{47,7,29,11,9,84,54,20,30}，散列表表长TableSize = 13（装填因子）;散列函数为：.
用线性探测法处理冲突，列出依次插入后的散列表，并估算查找性能。
为了方便演示，我们先在不考虑冲突的情况下，把所有关键词的散列地址算出来：
关键词（key）4772911984542030散列地址h（key）3770971098 发现很多地方是冲突的，这次用线性探测法来试着解决冲突。
操作/地址0123456789101112说明插入4747无冲突插入7477无冲突插入2947729插入111147729无冲突插入911477299无冲突插入841147729984插入54114772998454插入2011477299845420插入301130477299845420 最终我们整理得到：
H（key）0123456789101112key1130477299845420冲突次数060010313 散列表查找性能分析 成功平均查找长度(ASLs)不成功平均查找长度(ASLu) ASLs：查找表中关键词的平均查找比较次数（等于其冲突次数加1） 即将所有元素的查找次数加起来，最后除以元素的个数
ASLu：不在散列表中的关键词的平均查找次数（不成功）
因为取余数的计算方式，所以所有不在散列表的关键词至多有p-1中情况（表不为空），例如例题中的散列函数，假设其表只有一个元素，那么其不在表中的情况就会有10种，我们一样考虑其需要比较几次。
余数为0的情况，表中位置[0]和[1]都不为空，所以需要比较3次；
余数为1的情况，表中位置[1]不为空，所以需要比较2次；
余数为2的情况，表中位置[2]为空，所以只需要比较1次；
余数为3的情况，表中位置[3]不为空，所以需要比较2次；
......
以此类推。
平方探测（Quadratic Probing） 平方探测法：以增量序列且循环试探下一个存储地址。
【例】设关键词序列为{47,7,29,11,9,84,54,20,30}，散列表表长TableSize = 11，散列函数为：.用平方探测法处理冲突，列出依次插入后的散列表，并估算ASLs。
关键词（key）4772911984542030散列地址h（key）3770971098 操作/地址012345678910说明插入4747无冲突插入7477无冲突插入2947729插入111147729无冲突插入911477299无冲突插入841147847299插入54114784729954无冲突插入2011204784729954插入301130204784729954 注意：用平方探测法，并不是有空间就一定能检测到的。
定理 如果散列表长度TableSize是某个4k+3（k是正整数）形式的素数时，平方探测法就可以探查到整个散列表空间。
平方探测法的查找与插入 #define MAXTABLESIZE 100000 /* 允许开辟的最大散列表长度 */ typedef int ElementType; /* 关键词类型用整型 */ typedef int Index; /* 散列地址类型 */ typedef Index Position; /* 数据所在位置与散列地址是同一类型 */ /* 散列单元状态类型，分别对应：有合法元素、空单元、有已删除元素 */ typedef enum { Legitimate, Empty, Deleted } EntryType; typedef struct HashEntry Cell; /* 散列表单元类型 */ struct HashEntry{ ElementType Data; /* 存放元素 */ EntryType Info; /* 单元状态 */ }; typedef struct TblNode *HashTable; /* 散列表类型 */ struct TblNode { /* 散列表结点定义 */ int TableSize; /* 表的最大长度 */ Cell *Cells; /* 存放散列单元数据的数组 */ }; int NextPrime( int N ) { /* 返回大于N且不超过MAXTABLESIZE的最小素数 */ int i, p = (N%2)?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0e9b408d4e41dfb749ef294bf0fef2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edb284b670045fc671f01a1ea41c6a54/" rel="bookmark">
			OpenAI开发系列（一）：一文搞懂大模型、GPT、ChatGPT等AI概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全文共5000余字，预计阅读时间约10~20分钟 | 满满干货，建议收藏！
本文目标：详细解释大型语言模型（LLM）和OpenAI的GPT系列的基本概念。
一、什么是大模型 大型语言模型，也称大语言模型、大模型（Large Language Model，LLM；Large Language Models，LLMs)。
大语言模型是一种深度学习模型，特别是属于自然语言处理（NLP）的领域，一般是指包含数干亿（或更多）参数的语言模型，这些参数是在大量文本数据上训练的，例如模型GPT-3，PaLM，LLaMA等，大语言模型的目的是理解和生成自然语言，通过学习大量的文本数据来预测下一个词或生成与给定文本相关的内容。
参数可以被理解为模型学习任务所需要记住的信息，参数的数量通常与模型的复杂性和学习能力直接相关，更多的参数意味着模型可能具有更强的学习能力。
OpenAI 的 GPT (Generative Pre-trained Transformer) 系列是大语言模型的典型代表，作为目前为止公认最强的 GPT-4 架构，它已经被训练在数十亿的单词上。从实际应用表现来看，大语言模型具备回答各种问题、编写文章、编程、翻译等能力，如果深究其原理，LLM建立在Transformers架构之上，并在很大程度上扩展了模型的大小、预训练数据和总计算量。
可以这么通俗的理解：如果一个模型"足够大"，那它就可以称为大模型。
二、什么是GPT GPT，全称"Generative Pre-training Transformer"，是一个由OpenAI开发的自然语言处理（NLP）的模型。它的主要目标是理解和生成人类的自然语言。通过对大规模文本数据进行预训练，GPT模型能学习到语言的各种模式，如语法、句法、一词多义等，以及一些基础的世界知识。
总的来说，它通过预训练和生成技术，以及Transformer的自注意力机制，来理解和生成人类的自然语言。
2.1 GPT与大模型的关系 GPT-3 是一个具体的大模型的例子。当提到“大模型”时，通常是指具有大量参数的机器学习模型。
GPT-3是一个特别的大模型，因为它有1750亿个参数。这些参数使得GPT-3在处理语言任务时表现出强大的能力，例如：理解和生成自然语言文本、进行有深度和上下文的对话等。所以，可以说GPT-3是大模型的一个具体应用，显示了大模型的强大能力和可能性。
三、什么是ChatGPT ChatGPT是基于GPT模型构建的基于Web端的“聊天机器人”，对于每一个对话提问，由后端已训练好的GPT3.5或GPT4模型进行预测，并实时返回文字预测的结果，从而实现对话任务。
总的来说，ChatGPT是一个能够生成文本，回答问题和进行自然语言对话的 AI 模型。它可以帮助我们完成各种任务，例如聊天，写作，信息检索和问题回答等。
如需了解更多关于ChatGPT的内容，如发展历程、ChatGPT能做什么等内容，可以看文章：轻松学习ChatGPT：告诉你为什么它能改变你的生活
目前ChatGPT可以使用免费的GPT-3.5和付费的Plus版GPT-4，一张图说明GPT-3.5和GPT-4的区别：
3.1 ChatGPT、GPT与大模型三者的关系 ChatGPT是一种特定的GPT应用，GPT是一种大模型，而大模型是一类具有大量参数的深度学习模型。
四、什么是人工智能 人工智能真正进入公众视野的事件是：2017年5月27日阿尔法围棋在与世界排名第一的围棋冠军柯洁进行的人机大战中以3比0的总比分胜出，随后宣布退役。这不仅象征着人工智能在特定领域已经超越了人类的能力，也标志着我们正式步入了人工智能时代。
人工智能，借助机器学习和海量计算能力的强大推动，正逐步提升其复杂性和应用广度。它已经成为推动我们进入新的智能时代的关键力量。全球各地的产业界深谙人工智能技术引领新一轮产业变革的重大意义，都在积极进行转型并提前布局，以适应这个全新的人工智能创新生态。
我们来问一问ChatGPT是怎么描述人工智能的。
Prompt：您好，请帮我解释一下什么是人工智能？
Prompt：您这样解释太专业了，很多人看不懂，能不能更通俗一点、更 生活化一点 ，甚至让儿童都能理解呢？？
如同蒸汽时代的蒸汽机、电气时代的发电机、信息时代的计算机和互联网，人工智能（AI）正赋能各个产业，推动看人类进入智能时代。
一个经典的人工智能定义是：智能主体可以理解数据及从中学习，并利用知识实现特定目标和任务的能力。
4.1 人工智能的发展 人工智能，被誉为第四次科技革命的核心驱动力，现已步入其2.0时代。我们来回溯一下这个重要的发展轨迹。
在1956年，人工智能这一概念被提出，然而真正的爆发期始于2012年，标志着人工智能1.0时代的启动（2012年-2018年）。此时期的关键里程碑是AlexNet模型的问世，它开启了卷积神经网络（CNN）在图像识别领域的应用。2015年，机器在图像识别的准确率首次超过人类（错误率低于4%），这为计算机视觉技术在各个领域的应用奠定了基础。然而，这个时期的人工智能还面临一些挑战，如模型碎片化和泛化能力不足。
紧接着，人工智能进入了2.0时代（2017年至今）。在这个阶段，Google Brain团队于2017年提出了Transformer架构，这种架构在大模型领域奠定了主流算法基础。自2018年开始，大模型快速崛起，模型参数量呈现指数级增长。比如，2018年谷歌的模型参数首次超过一亿，而到了2022年，模型参数量已经达到了5400亿。这种“预训练+微调”的大模型策略有效地解决了1.0时代人工智能的泛化能力不足问题。伴随着新一代AI技术的不断发展，我们有望迎来全新一轮的技术创新周期。
4.2 人工智能的产能结构 人工智能产业链主要可划分为基础层、技术层以及应用层这三大部分：
首先，基础层关注基础支持平台的建设，包括传感器、AI芯片、数据服务和计算平台。目前，以约16%的市场份额，浪潮已经成为全球AI基础设施领域的龙头企业，其后分别是戴尔和HPE。
其次，技术层着重于核心技术的研发，主要涵盖算法模型、基础框架以及通用技术。
最后，应用层侧重于行业应用的发展，主要包含行业解决方案服务、硬件产品和软件产品。目前，人工智能在金融、家居、交通、医疗等领域已有重大进展，同时，自动驾驶汽车、无人机、智能机器人、智能语音助手等人工智能产品也在迅速发展。
资料来源：36氪研究院、国信证券经纪研究所
关于市场规模，随着模型参数的不断增加，算力需求也在快速增长。全球AI市场预计在2024年将超过6000亿美元，复合增速为27%。另一方面，中国AI市场预计在2024年将接近八千亿人民币，复合增速达44%，这显然高于全球整体增长速度。
目前，中国人工智能行业的主要竞争者包括浪潮、字节跳动、百度、腾讯、华为、阿里等公司。此外，商汤、旷视、科大讯飞等科技公司也已加入人工智能行业的竞争中。
4.3 人工智能对工作生活带来什么影响 人工智能已经广泛融入经济发展的各个领域，成为推动科技跨越发展、产业优化升级、生产力整体跃升的重要驱动力量，为新旧动能转换和经济高质量发展提供了有力支撑。具体来说，人工智能的影响主要体现在以下三个方面：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edb284b670045fc671f01a1ea41c6a54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e59ef2245289ad25d31c4f87a24fe95/" rel="bookmark">
			windows安装stable-diffusion-webui教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整合包对非技术出身的同学比较友好，因为秋叶大佬把相关的东西已经都整合好了，只需要点点点就行了。当然懂编程的同学就更没有问题了。
准备 为了保证AI绘画的效率，建议在本机安装Nvidia独立显卡，也就是俗称的N卡，并且显存要达到6G以上，6G只能出图，如果要做训练建议12G以上。推荐选择RTX40系列及以上的显卡型号，最低也要选择RTX30系列。如果你没有N卡，可以使用CPU进行图形计算，但是性价比较低，出图速度较慢。此外，还需要确保CPU性能足够高，并且搭配至少16G的内存。总的来说，如果只是进行简单的图形处理或者体验，可以使用CPU，但不适合搞AI绘画。
看到这里，有的同学可能会有点失望了，没有这么好的机器就玩不了AI绘画吗？别担心，我们还可以使用云主机，下一篇我会分享使用云主机的姿势。
安装前看自己显卡型号的方法：
1、电脑左下角点击WIndows窗口图标，然后点击“设置”。
2、在打开的窗口中，搜索“设备管理器”，找到后点击打开。
3、找到“显示适配器”，就可以看自己的显卡了。如果是Nvidia的显卡，就会有这几个字。我这个演示的电脑是不是N卡，所以只能以CPU的方式运行。
下载 所有需要的东西都放到盘盘里边了，大家自行下载即可：
pan.baidu.com/s/1Hvw8ptSv… 提取码: bmm1
为了方便大家搞AI绘画，这里边不仅包含了秋叶大佬的整合包，还有很多的大模型、Lora模型、ControlNet模型等等，总计大约有100多G，全部下载下来会很慢。
但是没必要都下载下来再安装，先把最后两个文件下载下来就行了，鉴于百度限速，可能也需要几个小时，大家耐心等待，磨刀不误砍柴工！
启动 下载完上边说的两个文件就可以启动。
1、安装驱动。这个整合包是由 .NET6 (就是一个软件基础平台）驱动的， 大家需要先安装“启动器运行依赖-dotnet-6.0.11.exe”这个文件。
安装过.NET6的同学可以跳过这一步，不懂的再安装一遍也没问题。
2、解压“sd-webui-aki-v4.zip”。自己选择一个磁盘，比如D盘，直接解压到D盘根目录就行了。然后进入解压后的文件夹 sd-webui-aki-v4 。
双击“A启动器.exe”，它会自动下载一些最新的程序文件。我这里还弹出了“设置Windows支持长路径”，确定就可以了。
启动成功后，会打开下边这个界面。如果啥都做完了，也没打开这个界面，就再次双击这个文件，一般就打开了，还打不开的找我。
在这个启动界面中点击右下角的“一键启动”按钮。
然后会弹出一个控制台窗口，做一些初始化的操作，出现“Startup time ...”的提示就代表启动成功了。
然后这个工具会自动在浏览器中打开SD WebUI的窗口。不小心关了的时候，也可以用 http://127.0.0.1:7860 再次打开。打开的界面如下图所示：
出图 只需要简单5步：
1、Stable Diffusion 模型：anything-v5，这个是整合包自带的默认大模型，不用选就是它。
2、外挂VAE模型：选择 840000 这个，这东西就像个滤镜，用它出图的颜色比较丰富。
3、提示词：想要画个什么，就在这里写，需要是英文。
4、反向提示词：不想要在图片中出现什么，就把它写在这里，这里填写的“EasyNegative”是整合包附带的一个通用反向提示词的代号。
5、其它参数先不管，点击“生成”按钮。
6、生成速度取决于你的计算机性能，等一会就会出图了。点击可以放大，右键可以下载。
除了在这个WebUI上直接下载图片，我们还可以通过启动工具下载，如下图所示，红框圈出的就是各种生成方式保存图片的位置，单击就可以打开本机目录。
进阶 为了更好的绘图，这里介绍几个基础并且常用的概念：
模型：可以理解成一个函数，输入一些参数，得到一些返回值。只不过这里谈到的模型的参数特别多，几十亿、上百亿、上千亿。在Stable Diffusion中，我们可以简单的认为参数就是提示词、反向提示词、图片尺寸、提示词引导系数、随机数种子等等，返回值就是图片数据。
大模型：有时也称为基础模型，文件一般很大，常见的都在2G-5G。这是因为它们使用了很多的图片进行训练，累积了大量的数据。SD官方发布了一个基础模型，但是因为比较通用，兼顾的方面比较多，特点不足，所以大家一般很少使用。比如有的人喜欢二次元、有的人喜欢真实、有的人喜欢3D，用官方模型出图的效果不是最优的，所以很多组织或者个人就专门训练某方面的模型，并发布到社区给大家使用。
盘盘中提供了一些大模型，大家可以去下载：
然后放到整合包的这个目录下：sd-webui-aki-v4\models\Stable-diffusion，从盘盘下载的整合包中已经默认有一个大模型。
VAE模型：这个东西有点类似手机中编辑照片时的滤镜，可以处理图片的颜色和线条，让图片看起来色彩更丰富饱满。很多大模型会自带VAE模型，这时候我们就不需要再给它搭配一个VAE，当然也有不自带的，这时就需要搭配一个。上图选择的 840000 是一个常用的的VAE模型，如果你生成的图片比较灰暗，可以试试这个VAE。其实秋叶整合包提供了四个选项，如下图所示，我一般都选“自动识别”，除了 840000，animevae 是专门优化二次元图片的。一般这两个VAE模型就够了。
Lora模型：这是一种基于大模型的风格模型，比如我们画小姐姐的时候，可以用一些Lora模型来控制人物的服装、头饰；生成机械四肢的时候，可以用一些Lora模型来强化肢体上覆盖的机甲样式；画风景图的时候，可以用一些Lora模型来控制绘画的风格。
可以从盘盘中的这两个目录下载：
下载后放到整合包的这个目录下：sd-webui-aki-v4\models\Lora，初始状态下里边是空的。
提示词：对图像的描述，也就是想画一幅什么样的画。比如我上边使用的：a girl，但是这个提示词过于简单，AI虽然画出了一个女孩，但是他不知道你脑子里的女孩长什么样子，如果要画的更符合你的需求，你还要告诉他更多细节才好，比如女孩的头发是什么颜色、穿着什么衣服、站着还是坐着、在户外还是室内等等。提示词在AI绘画中特别重要，后边我会专门分享如何写好提示词。
反向提示词：不想在图片中出现的东西，比如树、桌子、6根手指、缺胳膊断腿等等，在上边的示例中我使用了“EasyNegative”，这是一个嵌入模型的代号，可以认为它代表了很多常见的反向提示词，使用它就不用一个个输入了，也不占用过多的提示词。
随机数种子：上边没有演示这个参数，但是它是AI绘画的魅力之一。即使其它的参数都相同，只要随机数不同，每次生成就会出来不同的图片，创意几乎无穷无尽。
先说这么多吧，学习重在持之以恒，不要撑着，后边我们慢慢再讲。
更新 Stable Diffusion WebUI 经常会修复一些BUG和增加新功能，在这里可以把它更新到最新版本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e59ef2245289ad25d31c4f87a24fe95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00e3916d49a541bd65707315f97e99a4/" rel="bookmark">
			链表基础知识详解（非常详细简单易懂）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述： 链表作为 C 语言中一种基础的数据结构，在平时写程序的时候用的并不多，但在操作系统里面使用的非常多。不管是RTOS还是Linux等使用非常广泛，所以必须要搞懂链表，链表分为单向链表和双向链表，单向链表很少用，使用最多的还是双向链表。单向链表懂了双向链表自然就会了。
文章目录
一、链表的概念
链表的构成：
链表的操作:
双向链表
链表与数组的对比
二、链表的创建
三、链表的遍历
四、链表的释放
五、链表节点的查找
六、链表节点的删除
七、链表中插入一个节点
八、链表排序
九、双向链表的创建和遍历
十、双向链表插入节点
一、链表的概念 定义：
链表是一种物理存储上非连续，数据元素的逻辑顺序通过链表中的指针链接次序，实现的一种线性存储结构。
特点：
链表由一系列节点（链表中每一个元素称为节点）组成，节点在运行时动态生成 （malloc），每个节点包括两个部分：
一个是存储数据元素的数据域
另一个是存储下一个节点地址的指针域
图1 单向链表
链表的构成： 链表由一个个节点构成，每个节点一般采用结构体的形式组织，例如：
typedef struct student｛ int num； char name[20]； struct student *next； }STU; 链表节点分为两个域
数据域：存放各种实际的数据，如：num、score等
指针域：存放下一节点的首地址，如：next等.
图2 节点内嵌在一个数据结构中
链表的操作: 链表最大的作用是通过节点把离散的数据链接在一起，组成一个表，这大概就是链表 的字面解释了吧。 链表常规的操作就是节点的插入和删除，为了顺利的插入，通常一条链 表我们会人为地规定一个根节点，这个根节点称为生产者。通常根节点还会有一个节点计 数器，用于统计整条链表的节点个数，具体见图3中的 root_node。
图3带根节点的链表
双向链表 双向链表与单向链表的区别就是节点中有两个节点指针，分别指向前后两个节点，其 它完全一样。有关双向链表的文字描述参考单向链表小节即可，有关双向链表的示意图具体见图4
图4双向链表
链表与数组的对比 在很多公司的嵌入式面试中，通常会问到链表和数组的区别。在 C 语言中，链表与数 组确实很像，两者的示意图具体见图5，这里以双向链表为例。
图5 链表与数组的对比
链表是通过节点把离散的数据链接成一个表，通过对节点的插入和删除操作从而实现 对数据的存取。而数组是通过开辟一段连续的内存来存储数据，这是数组和链表最大的区 别。数组的每个成员对应链表的节点，成员和节点的数据类型可以是标准的 C 类型或者是 用户自定义的结构体。数组有起始地址和结束地址，而链表是一个圈，没有头和尾之分， 但是为了方便节点的插入和删除操作会人为的规定一个根节点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00e3916d49a541bd65707315f97e99a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6562332d2973fee16ff7a0c83a87dc29/" rel="bookmark">
			vue使用printJs实现前端打印,以及打印分页实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在web端可以直接使用原生调用方法调用打印,但是往往需要单独把需要打印的东西拎出来画一个单独的html,而使用printJs则可选中你需要打印的代码块,进行页面局部打印
我的需求为将表格打印出来,并且超过分页数进行分页展示
以下内容参考了其他博主的实现方法,仅供参考
实现打印 1.可以直接使用以下代码,在项目中生成一个js文件,并在main.js中全局引用,以下代码为Vue使用PrintJS实现页面打印功能_this.$print_呆小杰的博客-CSDN博客
呆小杰博主修改后的代码,也可以使用npm下载引用
/** * 打印类属性、方法定义,需要先在插件中引入 * 使用示例: 1. 先在mian.js中引入 * 2. 函数中调用this.$print(this.$refs.xxxx) */ /* eslint-disable */ const Print = function (dom, options) { if (!(this instanceof Print)) return new Print(dom, options); this.options = this.extend({ 'noPrint': '.no-print' }, options); if ((typeof dom) === "string") { this.dom = document.querySelector(dom); } else { this.isDOM(dom) this.dom = this.isDOM(dom) ? dom : dom.$el; } this.init(); }; Print.prototype = { init: function () { var content = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6562332d2973fee16ff7a0c83a87dc29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f55cebc13985bf95c0d4f08b5f21ae89/" rel="bookmark">
			当编程遇上AI，纵享丝滑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、提出需求
二、检查代码
三、进一步提出需求
总结 前言 自从CHATGPT火了以后，我发现我身边的人再也不怕写报告了，什么个人总结，汇报材料，年度总结，伸手就来（反正哪些报告也没人看），除了一些针对性很强的文章（这里说的是针对性，不是技术性）基本上人工智能都能说个一二三，以前是天下文章一大抄，看你会抄不会抄，现在是看你会问不会问，只要问的准，答案应该都是准确的。下面根据我之前记的一个爬虫笔记，我们用人工智能来寻找答案，当时还有一些小错误，我们看人工智能能不能解决。
一、提出需求 在“编程小白的自学笔记十二（python爬虫入门四Selenium的使用实例二）”中，我们是找到了百度贴吧的广告子页面，然后点击了第一个广告，我们尝试这样问下：
请用python代码编写爬虫，实现找到百度贴吧的广告子页面，点击第一个广告
我们发现好像不能提爬虫这个关键字，那么我们修改问题：请用python代码编写代码，实现找到百度贴吧的广告子页面，点击第一个广告。这次可以了
二、检查代码 我们来看看人工智能的全部回答内容：
这里提供一个Python+Selenium的示例代码：
from selenium import webdriver # 打开chrome浏览器 driver = webdriver.Chrome() # 打开百度贴吧 driver.get('https://tieba.baidu.com/') # 等待页面加载完成 driver.implicitly_wait(10) # 找到广告iframe并切换到它 iframe = driver.find_element_by_xpath('//iframe[@class="iframe_wrapper"]') driver.switch_to.frame(iframe) # 找到第一个广告并点击 ad = driver.find_element_by_xpath('//div[@class="ad-list"]//a') ad.click() 这段代码会先打开Chrome浏览器，并进入百度贴吧首页。然后，它会等待页面加载完成，找到广告的iframe并切换到它。接着，它会找到第一个广告并点击它。注意，这段代码假设第一个广告是在一个类名为ad-list的div里，如果实际情况不同，需要修改xpath表达式。
我们查看代码，在逻辑上没有任何问题，而且注释什么的写的很详细，我是做不到这样的，唯一有可能出问题的地方就是xpath可能出错，本着严谨的原则，我们运行一下试试看。
不出意外出意外了，报错了。 AttributeError: 'WebDriver' object has no attribute 'find_element_by_xpath'，这个错误是因为版本的原因，新的Selenium已经不用这种格式了，我们稍稍修改下代码试试：
from selenium import webdriver from selenium.webdriver.common.by import By # 打开chrome浏览器 driver = webdriver.Chrome() # 打开百度贴吧 driver.get('https://tieba.baidu.com/') # 等待页面加载完成 driver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f55cebc13985bf95c0d4f08b5f21ae89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/277f36738aa64b3ead6329937fbf249a/" rel="bookmark">
			Oracle以逗号分隔的字符串拆分为多行数据实例详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 近期在工作中遇到某表某字段是可扩展数据内容，信息以逗号分隔生成的，现需求要根据此字段数据在其它表查询相关的内容展现出来，第一想法是切割数据，以逗号作为切割符，以下为总结的实现方法，以供大家参考、指教。
1、regexp_substr函数，通过正则来拆分字符串，函数用法为:(必须是oracle 10g+的版本才支持） REGEXP_SUBSTR函数格式如下：
function REGEXP_SUBSTR(String, pattern, position, occurrence, modifier)
__srcstr ：需要进行正则处理的字符串
__pattern ：进行匹配的正则表达式
__position ：起始位置，从第几个字符开始正则表达式匹配（默认为1）
__occurrence ：获取第几个分割出来的组（分割后最初的字符串会按分割的顺序排列成组），默认为1
__modifier ：模式（'i'不区分大小写进行检索；'c'区分大小写进行检索。默认为'c'。）针对的是正则表达式里字符大小写的匹配
-------------------------------------------------------------------------------------------------------------------
此函数只能每次取一个字符串出来，有点鸡肋，字符串中逗号的数量是不确定的，如果有2个逗号，需要提取的字段就是3个。为了确定有多少个需要提取的字段，需要用到connect by命令实现动态参数构造连续的值，通过原字符串长度和被替换后字符串长度相减，可以得到原字符串中的逗号数量，加1后得到需要提取的匹配字段数量。
SQL:
select bs from cs1_0 where slid='201804100038' --正则分割后的第一个值 SELECT REGEXP_SUBSTR((select bs from cs1_0 where slid='201804100038'),'[^,]+',1,1,'i') as 分割后结果 FROM DUAL; --获取一个多个数值的列，从而能够让结果以多行的形式展示出来 SELECT LEVEL FROM DUAL CONNECT BY LEVEL &lt;=5; --将上面REGEXP_SUBSTR的occurrence（标识第几个匹配组）实现动态参数，使用 connect by组合起来 SELECT REGEXP_SUBSTR((select bs from cs1_0 where slid='201804100038'),'[^,]+',1,LEVEL,'i') as 分割后结果 FROM DUAL CONNECT BY LEVEL &lt;=5; --优化一下（动态获匹配组标识行数） select regexp_substr((select bs from cs1_0 where slid='201804100038'),'[^,]+',1,LEVEL,'i') as 分割后结果 from dual connect by level &lt;= length((select bs from cs1_0 where slid='201804100038'))-length(regexp_replace((select bs from cs1_0 where slid='201804100038'),',',''))+1; 2、以Type类型和function函数的方式实现 1）建立TYPE类型 CREATE OR REPLACE TYPE strsplit_type_12 IS TABLE OF VARCHAR2 (4000) 2）建立function存储函数 create or replace function strsplit_66(p_value varchar2,p_split varchar2 ) --字符串，切割符 --根据特定字符来切割字符串 return strsplit_type_12 pipelined is v_idx integer; v_str varchar2(500); v_strs_last varchar2(4000) := p_value; begin loop v_idx := instr(v_strs_last, p_split); exit when v_idx = 0; v_str := substr(v_strs_last, 1, v_idx - 1); v_strs_last := substr(v_strs_last, v_idx + 1); pipe row(v_str); end loop; pipe row(v_strs_last); return; end strsplit_66; SELECT ROWNUM 序号, a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/277f36738aa64b3ead6329937fbf249a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0735ff34aaf9ca0450d0347dc7ecf5b/" rel="bookmark">
			SQL常用语法( WITH 语句)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这里插入代码片—
个人笔记： 努力奋斗-Li亚Q
文章目录 1.WITH语法1.1 创建临时表1.2 用WITH语句递归查询1.3在WITH语句中使用多个查询 个人笔记： 努力奋斗-Li亚Q
1.WITH语法 WITH语句是一种在SQL中常用的语法，用于创建临时表或视图，以便在后续的查询中使用。它可以简化复杂查询的编写，并提高查询性能。以下是一些WITH语句的示例：
1.1 创建临时表 WITH temp_table AS ( SELECT column1, column2 FROM some_table WHERE column3 = 'value' ) SELECT * FROM temp_table 这个WITH语句创建了一个名为temp_table的临时表，其中包含符合条件column3 = 'value’的some_table表中的column1和column2列。在后续的查询中，可以使用temp_table来引用这些数据。
1.2 用WITH语句递归查询 WITH recursive_query AS ( SELECT start_id, end_id, distance FROM some_table WHERE start_id = 1 UNION ALL SELECT r.start_id, t.end_id, r.distance + t.distance FROM recursive_query r JOIN some_table t ON r.end_id = t.start_id ) SELECT * FROM recursive_query 这个WITH语句使用递归查询来查找从start_id = 1开始的所有路径，并计算它们的距离。在第一部分中，查询从some_table表中选择所有起点为1的路径。在第二部分中，使用UNION ALL操作符来将递归查询的结果与some_table表中的记录连接起来，以查找从起点到终点的路径，并计算它们的距离。这样，可以使用WITH语句来创建一个递归查询，从而简化代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0735ff34aaf9ca0450d0347dc7ecf5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89a0301dd886d25220790d136cee7fc8/" rel="bookmark">
			【链表OJ 3】链表的中间结点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言: 本文收录于http://t.csdn.cn/n6UEP数据结构刷题的博客中,首先欢迎大家的来访，其次如有错误，非常欢迎大家的指正！我会及时更正错误！
目录
一.链表的中间结点 1.1原理:快慢指针的使用
链表元素个数为奇数时
链表元素个数为偶数时
1.2循环条件问题?
一.链表的中间结点 来源:876. 链表的中间结点 - 力扣（LeetCode）
题目:
1.1原理:快慢指针的使用 这个算法之所以有效，是因为fast指针的移动速度是slow指针的两倍。
快慢指针的精妙之处在于,当快指针移动到链表尾部时,慢指针就刚好移动了链表长度的一半,从而找到中间节点。因此当,fast指针到达链表尾部时，slow指针将正好指向链表的中间节点。无论链表长度奇偶,这个方法都可以在一次遍历正确找到中间节点。
时间复杂度:O(n),因为只遍历链表一次。
空间复杂度:O(1),因为没有使用额外的空间。
整体思路:
函数以指向链表头部的指针作为参数。
初始化两个指针 slow 和 fast，它们都指向链表的头部。
进入一个循环，只要fast不为NULL且fast-&gt;next不为NULL，循环会继续执行。这个循环用于通过链表前进指针。
每次循环迭代中,slow 指针向前移动一步，通过赋值slow = slow-&gt; next。
fast指针向前移动两步，通过赋值fast = fast -&gt; next -&gt; next。
当循环结束时，slow 指针将指向链表的中间节点。这是因为fast指针的移动速度是slow指针的两倍，当 fast指针到达链表尾部时，slow指针刚好在链表的中间。
最后，函数返回slow指针，即链表的中间节点。
链表元素个数为奇数时 动图演示:
链表元素个数为偶数时 返回第二个中间结点的原因是题目要求:
动图演示:
1.2循环条件问题? 循环条件不能调换顺序:
while 循环条件 fast &amp;&amp; fast-&gt;next 不能写成 fast-&gt;next &amp;&amp; fast 的目的是为了确保在遍历链表时不会出现空指针异常。
如果将循环条件调换为fast-&gt;next&amp;&amp; fast ，在链表长度为奇数时，当快指针 fast指向最后一个节点时，fast-&gt;next仍然不为NULL，但此时fast已经为NULL，这样会导致在访问fast的next指针时出现错误。
通过保持条件为fast &amp;&amp; fast-&gt;next ，可以确保在fast 和 fast-&gt;next 每次迭代中，快指针都不为NULL，从而避免了空指针的访问错误。这是正确处理快慢指针遍历的关键。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89a0301dd886d25220790d136cee7fc8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/592/">«</a>
	<span class="pagination__item pagination__item--current">593/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/594/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>