<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e4e1fff186d04602eeaa9373a151e57/" rel="bookmark">
			String在Java中是基本数据类型吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 String在Java中是基本数据类型吗？ 1、基本数据类型2、String类型3、String的不可变性4、StringBuffer和StringBuilder5、总结 💖The Begin💖点点关注，收藏不迷路💖 在Java中，数据类型分为两大类：基本数据类型（Primitive Data Types）和引用数据类型（Reference Data Types）。而String不是基本数据类型，它是Java中的一个引用数据类型，是java.lang.String类的实例。
1、基本数据类型 Java的基本数据类型包括：
byte：8位带符号二进制整数short：16位带符号二进制整数int：32位带符号二进制整数long：64位带符号二进制整数float：32位IEEE 754单精度浮点数double：64位IEEE 754双精度浮点数char：16位Unicode字符boolean：表示一个逻辑值（true 或 false） 2、String类型 String类在Java中是一个特殊的类，用于表示字符序列（即文本）。因为它是引用类型，所以当我们创建一个String对象时，我们实际上是在堆内存中为其分配空间，并且变量（引用）指向这个对象。
示例：
String str = "Hello, World!"; 在上面的示例中，"Hello, World!"是一个字符串字面量，它在编译时被存储在字符串常量池中。变量str是一个引用，它指向这个字符串常量池中的对象。
3、String的不可变性 String类在Java中是不可变的（immutable），这意味着一旦一个String对象被创建，它的内容就不能被改变。每次对String对象进行修改操作（如substring(), concat(), replace()等），实际上都会创建一个新的String对象。
4、StringBuffer和StringBuilder 由于String的不可变性，在进行大量的字符串操作时，使用String可能会导致大量的临时对象被创建，从而影响性能。
为了解决这个问题，Java提供了 StringBuffer和StringBuilder类，它们都是可变字符序列，可以在原有基础上进行修改，而不需要创建新的对象。
StringBuffer：线程安全的可变字符序列。由于它的线程安全性，它通常比StringBuilder慢。StringBuilder：非线程安全的可变字符序列。在单线程环境中，它通常比StringBuffer快。 注意： 在现代Java应用中，除非你有明确的线程安全需求，否则通常建议使用StringBuilder而不是StringBuffer。
5、总结 String不是基本数据类型，而是引用数据类型。String是不可变的。在需要频繁修改字符串的情况下，可以使用StringBuffer或StringBuilder来提高性能。在单线程环境中，StringBuilder通常比StringBuffer更快。 💖The End💖点点关注，收藏不迷路💖 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/798007989b831449952de18c2e431f04/" rel="bookmark">
			电脑录制视频的软件，电脑录制，4款免费软件推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数字化时代，电脑录制视频的软件已成为我们日常生活和工作中的得力助手，这些软件可以帮助我们轻松捕获到屏幕上的精彩瞬间。但同时市面上的录制视频软件也层出不穷，让人不知该如何选择。到底怎样才能选择到一款适合自己的录屏软件呢？
一款专业的电脑录屏软件应该具备多种录制功能，以满足不同用户的需求。首先，需要支持高清录制，能够捕捉屏幕上的每一个细节。其次，支持全屏录制和区域录制两种模式，用户可以自由选择录制范围。此外，一些高级的录屏软件还支持多种录制模式，丰富录屏内容。基于以上的要求，本文将为您推荐4款简单好用的录屏软件。
录制视频软件推荐1：数 据 蛙录屏软件 想要一款专业的电脑版录屏软件，选择这款数 据 蛙录屏软件一定不错！这是一款专业的录屏软件，录制视频时能够同时录制声音（包括电脑内部声音、外部声音），并且视频画质清晰。软件还支持多种录制模式，有视频录制、音频录制、游戏录制、摄像头录制等供您选择；免费版即可无水印录制视频，且不限时长。录制完成之后，还可以对文件进行后期处理，进行压缩、合并、格式转换等功能的操作。使用数 据 蛙录制电脑的步骤如下：
操作环境： 演示机型：华为MateBook 系统版本：Windows 10 软件版本：数 据 蛙录屏软件1.1.12 第一步：需要在您的电脑上安装数 据 蛙录屏软件。
第二步：点进软件的主界面，可以看到有多种模式供您选择，可以根据您的需求选择合适的录制模式。这里将以【视频录制】示范操作过程。
第三步：在录制前。可以自定义录制区域，也可对摄像头、麦克风等进行调节。调节完毕点击【REC】进入录制。
备注：电脑内部扬声器和外部麦克风，可以自定义选择是否开启，以及自行预调声音大小。
第四步：录制结束后，预览直接保存，或者进入【高级剪辑】可以进行给视频分段、剪辑、添加特效等操作，点击【完成】按钮后，还可以继续对视频进行后期处理（压缩、合并、格式转化等）。
录制视频软件推荐2：Xbox Game Bar 其实电脑上也有自带的不用付费的录屏软件，只要您的电脑是win10或win11系统，您就可以使用它自带的录屏工具Xbox Game Bar录制视频。​使用方法：在键盘上按下【Win+G】，点击录制按钮即可录制。但需要注意的是Xbox Game Bar虽然简洁易用，但其不能录制桌面，录制视频过程中，不能任意切换到电脑桌面，否则会自动停止录制。录制的文件体积也偏大不易储存与分享。
录制视频软件推荐3：步骤记录器 步骤记录器也是电脑自带的录制视频工具之一，步骤记录器主要能记录下您在电脑上操作的所有步骤。但它无法为您录制出声画同步的视频。其使用方法是：使用快捷键【Win+R】打开电脑【运行】页面。​在输入框中输入【psr.exe】，点击【确定】即可帮您记录操作步骤。
录制视频软件推荐4：QQ录屏 QQ是我们常用的聊天软件，但同时它也是一个电脑录制视频的软件，使用QQ进行录屏的操作是先要登录好电脑QQ，再使用热键【Ctrl+Alt+S】打开录屏功能，您可以框选好录制的范围，点击【开始录制】即可。
但QQ录制同样存在一定的弊端，经常因为网络不稳定问题，其录制的画面模糊，声音有底噪，很多小伙伴反馈录制后保存不知道在哪里，或者保存不到的问题。
电脑录制视频软件结论 总之，电脑录制视频的软件以其强大的功能和广泛的应用场景，成为现代影像创作的得力助手。选择一款专业的录屏软件不仅可以丰富我们的视觉体验，还能激发出我们的创作热情。所以，在上述4款的录屏软件中，小编还是推荐您使用简洁易用、功能强大的数 据 蛙录屏软件。相信这款软件会带领您继续探索创新，为您带来更多的惊喜和可能性。
往期推荐：
OPPO手机如何录屏？分享3个方法，快速解决https://mp.csdn.net/mp_blog/creation/editor/140127394Windows10录屏，教你3个方法，简单快速录屏https://mp.csdn.net/mp_blog/creation/editor/140128744为什么录屏没有声音？2个小技巧快速解决https://mp.csdn.net/mp_blog/creation/editor/140117304
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edcb8004b95e704220e3a9c1d5eb0e15/" rel="bookmark">
			Java 中创建对象的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 中创建对象的几种方式 1、使用 new 关键字创建对象2、通过反射机制创建对象3、采用 clone 机制创建对象4、通过序列化机制创建对象 💖The Begin💖点点关注，收藏不迷路💖 在 Java 中，有多种方式可以创建对象。这些方式包括使用 new 关键字直接实例化、通过反射机制、采用 clone 机制以及通过序列化机制。下面我们将详细讨论这些方式。
1、使用 new 关键字创建对象 这是 Java 中最常用也是最基本的创建对象的方式。通过 new 关键字调用类的构造函数，可以创建一个新的对象实例。
MyClass obj = new MyClass(); 2、通过反射机制创建对象 Java 反射机制允许程序在运行时检查和修改类、接口、字段和方法的信息。通过反射，我们可以在运行时动态地创建对象实例。
Class&lt;?&gt; clazz = MyClass.class; MyClass obj = (MyClass) clazz.getDeclaredConstructor().newInstance(); 注意，这里需要进行类型转换，因为 clazz 实际上表示的是 MyClass 类。
3、采用 clone 机制创建对象 Java 中的 clone 方法用于创建并返回此对象的一个拷贝。 默认情况下，Object 类的 clone() 方法是保护的，因此只有实现了 Cloneable 接口的类才能被拷贝。
public class MyClass implements Cloneable { // ... @Override protected Object clone() throws CloneNotSupportedException { return super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edcb8004b95e704220e3a9c1d5eb0e15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ddae591da6386a0fe6b153c86de028c/" rel="bookmark">
			Java中new与clone操作对象的比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Java中new与clone操作对象的比较 1、new操作符创建对象的过程2、clone方法创建对象的过程3、总结 💖The Begin💖点点关注，收藏不迷路💖 1、new操作符创建对象的过程 new操作符在Java中用于创建对象，并执行以下步骤：
分配内存空间： 根据类型确定所需内存大小。调用构造函数： 初始化对象的各个域。返回对象引用： 可以将引用发布到外部，使得对象可以被使用。 示例代码：
MyClass obj = new MyClass(); new MyClass()创建了一个MyClass类型的对象并分配了内存空间。
2、clone方法创建对象的过程 分配内存与初始化： clone方法和new操作符都会分配内存。但是，clone方法分配的内存大小与原对象相同。不同于new操作符，clone方法不会调用构造函数来初始化对象的域。而是使用原对象的值填充新对象的域。这称为 浅拷贝（shallow copy）。 浅拷贝与深拷贝的区别： 如果对象的域中引用了其他对象（例如数组或其他类的实例），clone方法只会复制引用，而不会复制引用指向的对象本身。这就是浅拷贝和深拷贝的区别：浅拷贝复制引用，深拷贝则会递归复制引用的对象。 返回新对象： 当clone方法执行完毕后，将会创建一个新的对象，其值与原对象相同（但内存地址不同）。我们可以将新对象的引用用于外部。 示例代码:
MyClass original = new MyClass(); MyClass cloned = (MyClass) original.clone(); 3、总结 1、new操作符：分配内存并调用构造函数初始化对象。
2、clone方法：分配内存并使用原对象的值来填充新对象的域（浅拷贝）。
虽然new和clone都可以用来创建对象，但它们的使用场景和原理是不同的。在实际编程中，我们需要根据具体的需求来选择使用哪种方式。
💖The End💖点点关注，收藏不迷路💖 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d26ca8bb18eb3b5a9fe669f64234700/" rel="bookmark">
			Java中==和equals()的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中==和equals（）的区别 1、==操作符2、equals()方法3、总结 💖The Begin💖点点关注，收藏不迷路💖 在Java中，==和equals()是两个常用的比较操作符和方法，但它们之间的用法和含义却有着本质的区别。本文将详细解释这两个操作符/方法之间的区别。
1、==操作符 ==操作符 在Java中 主要用于比较两个变量的值是否相等。但是，这个“值”的含义取决于变量的类型：
1、于基本数据类型（如int, char, boolean等）：== 比较的是两个变量的值是否相等。
2、对于引用类型（如对象、数组等）：== 比较的是两个引用是否指向内存中的同一个对象（即地址是否相同）。
示例：
int a = 5; int b = 5; System.out.println(a == b); // 输出true，因为a和b的值相等 Integer c = new Integer(5); Integer d = new Integer(5); System.out.println(c == d); // 输出false，因为c和d指向的是不同的对象 2、equals()方法 equals()方法是Java Object 类的一个方法，用于比较两个对象的内容是否相等。
需要注意的是，默认的 equals() 方法 实现其实就是 == 操作符对于引用类型的比较，即比较的是两个引用是否指向同一个对象。
但是，很多Java类（如String, Integer等）都重写了 equals() 方法，以提供基于内容的比较。
示例：
String str1 = new String("hello"); String str2 = new String("hello"); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d26ca8bb18eb3b5a9fe669f64234700/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0109a4fa46f75f120f0280814af8fe99/" rel="bookmark">
			SQL中count(*)、count(1)和count(column)的区别与用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SQL中count（*）、count（1）和count（column）的区别与用法 1、count(*)2、count(1)3、count(column) 💖The Begin💖点点关注，收藏不迷路💖 在SQL中，count()函数被广泛用于统计行数或某列中非NULL值的数量。然而，对于count(*)、count(1)和count(column)这几种不同的使用方式，很多开发者可能存在一些困惑。本篇博客将深入探讨这三种用法之间的区别及各自的适用场景。
1、count(*) 首先，我们来看一下count()这种用法。count()会统计查询结果集中的行数，包括所有行，即使某些列的值为NULL也会计算在内。这种写法通常用于计算表中的总行数，因为它会忽略任何列中的NULL值，只关注行数。
例如：
SELECT COUNT(*) FROM table_name; 2、count(1) 接下来是count(1)这种写法，其实质和count(*)是一样的。count(1)会统计查询结果集中的行数，同样包括所有行，不受NULL值的影响。这种用法更像是在告诉数据库“只要计算行数就好，不需要关注具体的列值”。
例如：
SELECT COUNT(1) FROM table_name; 3、count(column) 最后是count(column)，这种写法则是针对某特定列进行计数。它会统计指定列中非NULL值的数量，忽略NULL值所在的行。 这种用法适用于需要统计某列中有效数值的情况。
例如：
SELECT COUNT(column_name) FROM table_name; 通过上述例子，我们可以看出count(*)、count(1)和count(column)这三种用法的区别和适用场景。
在实际的SQL查询中，根据具体需求选择合适的count()用法可以更有效地对数据进行统计和分析。
💖The End💖点点关注，收藏不迷路💖 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e9ac35b1e972b90e535b2e3d43d5eda/" rel="bookmark">
			非关系型数据库（NoSQL）与 关系型数据库（RDBMS）的比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 非关系型数据库（NoSQL）与 关系型数据库（RDBMS）的比较 一、引言二、非关系型数据库（NoSQL）2.1 优势 三、关系型数据库（RDBMS）3.1 优势 四、结论 💖The Begin💖点点关注，收藏不迷路💖 一、引言 在数据库技术中，关系型数据库（RDBMS）长期占据主导地位，但随着大数据和云计算的兴起，非关系型数据库（NoSQL）逐渐崭露头角。本文将探讨这两种数据库的区别及其各自的优势。
二、非关系型数据库（NoSQL） 2.1 优势 高性能
NoSQL 数据库通常基于键值对（Key-Value Pair）存储，这种结构使得数据查询更加直接，无需经过复杂的 SQL 层解析，从而 大大提高了性能。 可扩展性
由于 NoSQL 数据库中的数据之间没有严格的耦合性，因此可以非常方便地进行水平扩展。无论是通过添加更多的服务器节点还是通过数据分片（Sharding）技术，都可以实现 数据库性能的提升。 灵活性
NoSQL 数据库支持多种数据模型，如文档型（Document-Oriented）、列式（Column-Oriented）、图形（Graph）等，这使得开发者可以根据实际需求选择合适的数据模型，从而更加灵活地处理数据。 三、关系型数据库（RDBMS） 3.1 优势 复杂查询
关系型数据库支持 SQL 语言，通过 SQL 语句可以方便地在单个表或多个表之间进行非常复杂的数据查询。这种查询能力使得关系型数据库在处理结构化数据方面具有天然的优势。 事务支持
关系型数据库支持 ACID 特性（原子性、一致性、隔离性、持久性），这使得对于安全性能要求很高的数据访问得以实现。同时，事务的支持也使得在多个操作之间保持数据的一致性成为可能。 成熟稳定
关系型数据库经过数十年的发展，已经形成了成熟的理论体系和技术标准。许多知名的关系型数据库（如 Oracle、MySQL、PostgreSQL 等）都经过了大量的实践验证，具有良好的稳定性和可靠性。 四、结论 非关系型数据库和关系型数据库各有其优势和适用场景。
1、非关系型数据库在性能、可扩展性和灵活性方面具有优势，适用于处理大量非结构化数据或需要高性能读写的场景；
2、而关系型数据库则在复杂查询、事务支持和成熟稳定性方面具有优势，适用于处理结构化数据或需要保证数据一致性和安全性的场景。
在选择数据库时，应根据实际需求进行权衡和选择。
💖The End💖点点关注，收藏不迷路💖 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/182a60e0219300e90d72aa12cd55ae39/" rel="bookmark">
			离线运行Llama3：本地部署终极指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4月18日，Meta在官方博客官宣了Llama3，标志着人工智能领域迈向了一个重要的飞跃。经过笔者的个人体验，Llama3 8B效果已经超越GPT-3.5，最为重要的是，Llama3是开源的，我们可以自己部署！
本文和大家分享一下如何在个人电脑上部署Llama3，拥有你自己的GPT-3.5+!
很多读者担心本地部署时个人电脑的硬件配置不够，实际上这种担心是多余的，笔者使用的是MacBook M2 Pro (2023款), 主要硬件配置如下：
10核CPU16G内存 部署步骤大致如下：
安装Ollama下载Llama3安装Node.js部署WebUI 安装Ollama Ollama可以简单理解为客户端，实现和大模型的交互，读者可以前往[ollama.com/download，根据…]
下载之后打开，直接点击Next以及Install安装ollama到命令行。安装完成后界面上会提示ollama run llama2，不需要执行这条命令，因为我们要安装llama3。
下载Llama3 打开新的终端/命令行窗口，执行以下命令：
ollama run llama3 程序会自动下载Llama3的模型文件，默认是8B，也就80亿参数版本，个人电脑完全可以运行。
成功下载模型后会进入交互界面，我们可以直接在终端进行提问，比如笔者问的Who are you?，Llama3几乎是秒回答。
➜ Projects ollama run llama3 &gt;&gt;&gt; who are you? I'm LLaMA, a large language model trained by a team of researcher at Meta AI. I'm here to chat with you and answer any questions you may have. I've been trained on a massive dataset of text from the internet and can generate human-like responses to a wide range of topics and questions.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/182a60e0219300e90d72aa12cd55ae39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e36b0cebf1f198c613b41fdad6268586/" rel="bookmark">
			Mac/Linux安装JMeter压测工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mac安装JMeter压测工具 介绍 Apache JMeter™应用程序是开源软件，是一个100%纯的Java应用程序，旨在加载测试功能行为和衡量性能。它最初是为测试Web应用程序而设计的，但后来扩展到其他测试功能。
我能用它做什么？ Apache JMeter可用于测试静态和动态资源、Web动态应用程序的性能。
它可用于模拟服务器、服务器组、网络或对象上的重负载，以测试其强度或分析不同负载类型下的整体性能。
Apache JMeter的功能包括：
能够加载和性能测试许多不同的应用程序/服务器/协议类型： Web - HTTP、HTTPS（Java、NodeJS、PHP、ASP.NET、…）SOAP/REST网络服务FTP通过JDBC的数据库LDAP通过JMS的面向消息的中间件（MOM）邮件 - SMTP（S）、POP3（S）和IMAP（S）本机命令或shell脚本TCPJava对象 功能齐全的测试IDE，允许快速测试计划记录（来自浏览器或本机应用程序）、构建和调试。**CLI模式（命令行模式（以前称为非GUI）/无头模式）**从任何Java兼容的操作系统（Linux，Windows，Mac OSX，…）加载测试一个完整且**随时可以呈现的动态HTML报告**通过从最流行的响应格式、**HTML、JSON、XML或任何文本格式**中提取数据的能力轻松关联完整的便携性和100%的Java纯度。完整的多线程框架允许许多线程的并发采样，以及通过单独的线程组同时采样不同的功能。缓存和离线分析/重播测试结果。高度可扩展的核心： 可插拔采样器允许无限的测试功能。可脚本采样器（与JSR223兼容的语言，如Groovy和BeanShell）可以使用可插拔计时器选择几种负载统计信息。数据分析和可视化插件允许极大的可扩展性和个性化。函数可用于为测试提供动态输入或提供数据操作。通过Maven、Gradle和Jenkins的第三方开源库轻松持续集成。 下载安装 下载地址 JMeter官方下载
linux或者mac选择tgz，Windows选择zip
前置条件：需要安装JDK1.8,因为运行需要jdk
Mac版本 终端进入安装目录下的/bin目录
执行命令
sh jmeter.sh 自动打开jmeter界面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7df3b45b8c84c82c2c7bcf08f64ebae2/" rel="bookmark">
			数据库安全：MySQL权限体系划分与实战操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		「作者简介」：冬奥会网络安全中国代表队，CSDN Top100，就职奇安信多年，以实战工作为基础著作 《网络安全自学教程》，适合基础薄弱的同学系统化的学习网络安全，用最短的时间掌握最核心的技术。
这一章节我们需要知道MySQL的用户权限是如何划分的，怎么修改用户权限。
实际生产环境中，应按照软件安全设计的最小特权原则配置用户权限。
查看权限 show grants for root@localhost;查看权限 select * from mysql.user where user='root'\G设置权限 grant select on *.* to test@localhost;删除权限 revoke select on *.* from test@localhost; MySQL权限体系 1、权限级别划分2、权限列表3、查看用户权限4、设置用户权限5、删除用户权限6、新用户的默认权限7、实战操作 1、权限级别划分 MySQL用户的权限分为5个级别：全局、库、表、字段、程序和函数。
全局级别：对整个MySQL服务器的权限。存储在 mysql.user 表中，xx.priv字段表示具体的权限，Y表示有权限，N表示没权限。数据库级别：对某个数据库的权限。存储在 mysql.db 表中，xx.priv字段表示具体的权限，Y表示有权限，N表示没权限。表级别：对某个表的权限。存储在 mysql.priv 表中，xx.priv字段表示具体的权限，这里不再用YN表示，而是具体的Select、Delete这种。字段级别：对某个字段的权限。存储在 columns_priv 表中。程序和函数级别：对某个程序或函数的权限。存储在 procs_priv 表中。 权限看起来很复杂，但实际分配权限时却很简单：
设置全局权限，就写成 *.* 。设置某个数据库的权限，就写成 database.* 。设置某个表的权限，就写成 database.table 。设置某个字段的权限，就写成 database.table.column 。 2、权限列表 ALL：所有权限ALTER：可以使用 alter 修改表结构ALTER TOUTINE：可以使用 alter toutine 修改存储过程和函数CREATE：可以使用 create 创建表CREATE ROUTINE：可以使用 create routine 创建存储过程和函数CREATE TEMPORARY TABLES：可以使用 create temporary tables 创建临时表CREATE USER：可以使用 create user、drop user、rename user、revoke all privileges 创建、删除、修改用户。CREATE VIEW：可以使用 create view 创建视图DELETE：可以使用 delete 删除数据DROP：可以使用 drop 删除数据库和表EXECUTE：可以使用 execute 执行存储过程FILE：可以使用 select into outfile 和 load data infile 读写文件INDEX：可以使用 create index 和 drop index 创建和删除索引INSERT：可以使用 insert 插入数据LOCK TABLES：可以对拥有 SELECT 权限的表 使用 lock tables 锁表PROCESS：可以使用 show full processlist 查看服务器的进程信息RELOAD：可以使用 flush 刷新表和日志REPLICATION CLIENT：可以查询主从服务器信息REPLICATION SLAVE：可以从主服务器中读取日志SELECT：可以使用 select 查询数据SHOW DATABASE：可以使用 show database 显示所有数据库SHOW VIEW：可以使用 show create view 显示视图信息SHUTDOWN：可以使用 mysqladmin shutdown 关闭MySQL服务器SUPER：可以使用超级用户操作，包括change master，kill，purge master logs，set global，mysqladmin debugUPDATE：可以使用 update 修改数据USAGE：无权限GRANT OPTION：可以使用 grant 将自己的权限授权给其他用户 3、查看用户权限 方式一：以权限设置记录的形式展示用户权限，多条权限配置可叠加生效。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7df3b45b8c84c82c2c7bcf08f64ebae2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f06c81e9bce39123de33ee32239bb42/" rel="bookmark">
			Element中的选择器组件Select （一级选择组件el-select）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简述：在 Element UI 中，ElSelect（或简称为 Select）是一个非常常用的选择器组件，它提供了丰富的功能来帮助用户从一组预定义的选项中选择一个或多个值。这里来简单记录一下 一. 组件和属性配置 &lt;el-select v-model="policeValue" placeholder="请选择" clearable multiple @change="handleSelectChange" &gt; &lt;el-option v-for="item in options" :key="item.value" :label="item.label" :value="item.value" &gt; &lt;/el-option&gt; &lt;/el-select&gt; clearable 清空图标 multiple 选项多选 v-model="policeValue" 绑定报警类型的值到`policeValue`数据属性上 placeholder="请选择" 设置默认提示信息为"请选择" @change="handleSelectChange" 当选项发生变化时，触发`handleSelectChange`方法 :key="item.value" 为每个选项分配唯一键，基于`item.value` :label="item.label" 显示的标签文本，来源于`item.label` :value="item.value" 选项的实际值，绑定到`item.value` 二. 定义参数 // loading状态 tableLoading: false, // 报警类型的参数 policeValue: "", // 报警类型的选项参数 options: [ { value: 1, label: "错误报警", }, { value: 2, label: "正确报警", }, { value: 3, label: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f06c81e9bce39123de33ee32239bb42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dfe97c4f348682a0d8dcd762ab6af0e/" rel="bookmark">
			这么精彩的排序算法，确定不来看一下？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.交换函数：
2.三数取中：
一.插入排序：
二.希尔排序：
三.选择排序：
四.快速排序：
1.霍尔法（递归版）：
2.挖坑法（递归版）：
3.双指针法（递归版）：
4.非递归版：
五.归并排序：
1.递归版：
2.非递归版：
六.冒泡排序：
七.堆排序：
八.计数排序：
Hello，各位未来的高级程序员们，大家好，今天我就来为大家讲解一下有关排序的内容，我们常见的排序就是我们接下来要讲的这八个排序，我们平常所说的排序有十大排序，我们这里的八大排序是我们生活中最为常见的八大排序，而剩下的两个排序是桶排序和基数排序，这两个排序我们不做具体的精彩讲解，因为这两个排序属于是又复杂又没用的排序，因此，我们在这里不做具体的介绍，只介绍剩余的八大排序，OK，话不多说，我们现在开讲。
首先，我们这里先写一下八大排序中可能会用到的一些辅助函数：
1.交换函数： 这个函数的功能就是交换两个数据。
void Swap(int* p1, int* p2) { int tmp = 0; tmp = *p1; *p1 = *p2; *p2 = tmp; } 2.三数取中： 这个函数主要是用于在写快速排序的优化操作时会使用到，是为了得到某个数组中第一个，最后一个和最中间这三个数中不大不小的那个数据。
int GetMid(int* arr, int left, int right) { int mid = (left + right) / 2;//这里是为了找到最中间的那个数据。 if (arr[left] &lt; arr[mid]) { if (arr[left] &gt; arr[right])//arr[right] &lt; arr[left] &lt; arr[mid] { return left; } else if(arr[mid] &lt; arr[right])//arr[left] &lt; arr[mid] &lt; arr[right] { return mid; } else//arr[left] &lt; arr[right] &lt; arr[mid] { return right; } } else { if (arr[left] &lt; arr[right])//arr[mid] &lt; arr[left] &lt; arr[right] { return left; } else if (arr[mid] &gt; arr[right])//arr[right] &lt; arr[mid] &lt; arr[left] { return mid; } else//arr[mid] &lt; arr[right] &lt; arr[lreft] { return right; } } } 那么，接下来，我们就要开始正式的讲解有关排序的内容了：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dfe97c4f348682a0d8dcd762ab6af0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/613190ff66a7ab5f816a8018ca046512/" rel="bookmark">
			FlinkSQL 开发经验分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：汤包
最近做了几个实时数据开发需求，也不可避免地在使用 Flink 的过程中遇到了一些问题，比如数据倾斜导致的反压、interval join、开窗导致的水位线失效等问题，通过思考并解决这些问题，加深了我对 Flink 原理与机制的理解，因此将这些开发经验分享出来，希望可以帮助到有需要的同学。
下文会介绍 3 个 case 案例，每个 case 都会划分为背景、原因分析和解决方法三部分来进行介绍。
一、Case1: 数据倾斜 数据倾斜无论是在离线还是实时中都会遇到，其定义是：在并行进行数据处理的时候，按照某些 key 划分的数据显著多余其他部分，分布不均匀，导致大量数据集中分布到一台或者某几台计算节点上，使得该部分的处理速度远低于平均计算速度，成为整个数据集处理的瓶颈，从而影响整体计算性能。造成数据倾斜的原因有很多种，如 group by 时的 key 分布不均匀，空值过多、count distinct 等，本文将只介绍 group by + count distinct 这种情况。
1.1 背景 对实时曝光流，实时统计近 24 小时创意的曝光 UV 和 PV。且每分钟更新一次数据。通用的方法就是使用 hop 滑动窗口来进行统计，代码如下：
select Hselect HOP_START( ts ,interval '1' minute ,interval '24' hour ) as window_start ,HOP_END( ts ,interval '1' minute ,interval '24' hour ) as window_end ,creative_id ,count(distinct uid) as exp_uv -- 计算曝光UV ,count(uid) as exp_pv --计算曝光PVfrom dwd_expos_detailgroup by hop( ts ,interval '1' minute ,interval '24' hour ) -- 滑动窗口开窗，窗口范围：近24小时，滑动间隔：每1分钟 ,creative_idOP_START( ts ,interval '1' minute ,interval '24' hour ) as window_start ,HOP_END( ts ,interval '1' minute ,interval '24' hour ) as window_end ,creative_id ,count(distinct uid) as exp_uv -- 计算曝光UV ,count(uid) as exp_pv --计算曝光PVfrom dwd_expos_detailgroup by hop( ts ,interval '1' minute ,interval '24' hour ) -- 滑动窗口开窗，窗口范围：近24小时，滑动间隔：每1分钟 ,creative_id 复制代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/613190ff66a7ab5f816a8018ca046512/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/557d52442596a589080a39bc9d863040/" rel="bookmark">
			Python深度理解系列之【排序算法——冒泡排序】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		读者大大们好呀！！!☀️☀️☀️
👀期待大大的关注哦❗️❗️❗️ 🚀欢迎收看我的主页文章➡️木道寻的主页 文章目录 🔥前言🚀冒泡排序python实现算法实现图形化算法展示 ⭐️⭐️⭐️总结 🔥前言 冒泡排序算法的基本思想是通过重复遍历待排序的数列，比较每对相邻元素，如果它们的顺序错误(根据元素排序规则来说)就把它们交换过来。这个过程中，较小的元素会像气泡一样逐渐“浮”到数列的顶端，也就是数列的前端。这个过程会重复进行，直到数列被排序完成
🚀冒泡排序python实现 历史：
关于冒泡排序算法的创造历史，据称在1960年，英国计算机科学家霍尔（Tony Hoare）在参加英国国家物理实验室的俄文机械翻译项目时，为了提高翻译效率而提出了冒泡排序算法。这个算法以其稳定性和简单性而著称，尽管这个说法存在，但没有确凿的实证来支持这一点。
算法实现 1、冒泡排序代码python实现
def bubble_sort(arr): n = len(arr) # 遍历所有数组元素 for i in range(n): # Last i elements are already in place for j in range(0, n-i-1): # 遍历数组从0到n-i-1 # 交换如果元素大于下一个元素 if arr[j] &gt; arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] 2、运行结果
图形化算法展示 1、matplotlib图形化展示
代码如下：
import matplotlib.pyplot as plt def bubble_sort(arr): n = len(arr) plt.ion() # 开启交互模式 for i in range(n): for j in range(1, n-i): if arr[j-1] &gt; arr[j]: arr[j-1], arr[j] = arr[j], arr[j-1] # 交换元素 plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/557d52442596a589080a39bc9d863040/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93ded04fb95bedf709394b9ea8a3226f/" rel="bookmark">
			【AIGC自动化编程技巧笔记】一、起步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本专栏参考了CSDN高级讲师李宁的《AIGC自动化编程技巧》，是学习过程中记录的笔记。
一、ChatGPT的实质 尽管ChatGPT的功能非常强大，看似无所不能，但是ChatGPT毕竟只是基于很多算法和
数据并运行在强大GPU上的大量代码而已。ChatGPT甚至并不智能，其实ChatGPT根本不知
道自己做了什么。ChatGPT 的基本原理就是利用大量的数据以及神经网络，以及千亿规模的参数的微调，计算要产生的每一个字符到底是什么。也就是说，ChatGPT顶多算人工智算，而不是人工智能。尽管CharGPT并没有真正的智慧，但是ChatGPT仍然能帮人类不少忙。虽然不能完全取代人类，但是CharGPT至少可以大幅度提高人类的工作效率，或者说，做同样的工作，不再需要那么多人了。
二、免费在国内使用的方法 为啥非要用ChatGPT？直接用KimiChat不就得了吗？
这样的问题是不专业的。因为可以和ChatGPT的参数数量极其庞大，以中国目前的技术水平，是无法与之匹敌的，所以在技术上KimiChat必然没有ChatGPT好。所以在搞一些专业的东西时，还是优先使用ChatGPT比较好。
但是有一说一，KimiChat几乎可以说已经发挥到极致了，最关键的是在中国可以免费使用。而且性能也是广受好评。所以当查询一些不是那么重要的信息时，我一般使用的都是KimiChat。而在查询至关重要的信息时，则会将KimiChat和ChatGPT交叉使用。因为国内镜像一般只会让你免费用十几次（看来搞镜像也是要花钱的）。
每一个镜像都不同，我们可以同时注册多个镜像网站，这样就有很多次数了[手动狗头]。缺点就是要注册和管理，但是和好处一对比，这也不算什么。
第一步，打开Edge浏览器的插件商城。点击上方导航栏中的拼图图标，然后点击获取拓展。
搜索ChatGPT，可以看到目前一共有575个拓展，还是非常多的。
我最喜欢的就是第一个，侧边栏和插件特性都不错。
当30次的次数用光后，可以查看其他插件或网站。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ab34c768f15af62ed608d3a24ed8987/" rel="bookmark">
			ElasticSearch 8.x 弃用了 High Level REST Client，移除了 Java Transport Client，推荐使用 Elasticsearch Java API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ElasticSearch 1、ElasticSearch学习随笔之基础介绍
2、ElasticSearch学习随笔之简单操作
3、ElasticSearch学习随笔之java api 操作
4、ElasticSearch学习随笔之SpringBoot Starter 操作
5、ElasticSearch学习随笔之嵌套操作
6、ElasticSearch学习随笔之分词算法
7、ElasticSearch学习随笔之高级检索
8、ELK技术栈介绍
9、Logstash部署与使用
10、ElasticSearch 7.x 版本使用 BulkProcessor 实现批量添加数据
11、ElasticSearch 8.x 弃用了 High Level REST Client，移除了 Java Transport Client，推荐使用 Elasticsearch Java API
12、ElasticSearch 8.x 使用 snapshot（快照）进行数据迁移
13、ElasticSearch 8.x 版本如何使用 SearchRequestBuilder 检索
14、ElasticSearch 8.x 使用 High Level Client 以 HTTPS 方式链接，SSL 证书、主机名验证器 各是什么，如何忽略
15、ElasticSearch 8.x 创建父子文档，用Join类型字段以及用has_child、has_parent 检索
16、ElasticSearch如何提高写入效率【面试题，面道既学到】
ElasticSearch，创始人 Shay Banon（谢巴农）
本文主要讲解ElasticSearch 高级搜索实战，来满足复杂的业务场景，还是用 Kibana 来操作。
文章目录 ElasticSearch前言一、ElasticSearch 先后弃用另个客户端一、为什么要弃用 TransportClient 呢？二、为什么要弃用 High Level REST Client 呢？三、Elasticsearch Java API 如何使用3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ab34c768f15af62ed608d3a24ed8987/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc6e483f81d0b264c5ef166ba11fc994/" rel="bookmark">
			Spark性能优化（第22天）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Spark性能优化概述
二、Spark性能优化策略
三、理论分析
四、实践案例分析
五、监控与诊断
六、持续优化与改进
文章目录 引言一、Spark性能优化概述二、Spark性能优化策略1.1 开发调优2.1资源调优3.1 数据倾斜调优4.1 Shuffle调优 三、理论分析四、实践案例分析五、监控与诊断六、持续优化与改进 引言 随着大数据和云计算技术的迅猛发展，数据处理和分析已成为现代企业和研究机构不可或缺的一部分。Apache Spark作为一个强大的大规模数据处理引擎，已经成为众多组织和开发者处理大数据的首选工具。然而，随着数据量的不断增加和计算复杂度的提高，Spark作业的性能问题也逐渐显现。因此，对Spark进行性能优化显得尤为重要。本文将深入探讨Spark性能优化的策略，结合理论分析和实践案例，为开发者提供有价值的参考。
一、Spark性能优化概述 Spark性能优化是一个系统工程，涉及多个方面，包括开发调优、资源调优、数据倾斜调优、shuffle调优等。在Spark作业的执行过程中，任何一个环节的不足都可能导致性能瓶颈。因此，我们需要从多个角度出发，对Spark作业进行全面的优化。
二、Spark性能优化策略 1.1 开发调优 开发调优是Spark性能优化的基础，主要包括RDD Lineage设计、算子的合理使用、特殊操作的优化等方面。在开发过程中，我们应尽量避免对同一份数据创建多个RDD，以减少不必要的计算和存储开销。同时，我们还应根据具体的业务场景选择合适的算子进行操作，避免不必要的转换和聚合。对于特殊操作，如join操作，我们应尽可能减少shuffle的数据量，以提高性能。
2.1资源调优 资源调优是Spark性能优化的重要环节，主要包括Executor数量与配置、Shuffle并行度、JVM调优等方面。首先，我们需要根据集群的资源情况和作业的特性，合理设置Executor的数量和内存。其次，增加shuffle的并行度可以减少单个task处理的数据量，提高性能。最后，对JVM进行调优，包括设置合适的堆大小、调整GC策略等，以提高Spark作业的运行效率。
3.1 数据倾斜调优 数据倾斜是Spark作业中常见的性能问题之一，它会导致部分task处理的数据量过大，从而影响整个作业的执行效率。为了解决数据倾斜问题，我们可以采用多种策略，如预聚合、Salting技术、自定义分区等。预聚合是指在数据进入Spark之前，先进行局部聚合处理，减少进入Spark的数据量。Salting技术则是给倾斜的key添加随机前缀或后缀，使其分散到多个task中处理。自定义分区则是根据数据的分布情况，自定义分区策略，使得数据更加均衡地分布到各个task中。
4.1 Shuffle调优 Shuffle是Spark作业中不可避免的一个环节，但也是导致性能瓶颈的重要原因之一。为了优化shuffle过程，我们可以采用多种策略，如增加shuffle的并行度、使用map-side join代替reduce-side join、调整shuffle的存储级别等。增加shuffle的并行度可以减少单个task处理的数据量；使用map-side join可以避免shuffle过程中的数据传输；调整shuffle的存储级别则可以减少内存占用和磁盘IO开销。
三、理论分析 Spark性能优化的理论基础主要来源于分布式计算、内存管理和数据通信等领域。首先，分布式计算理论告诉我们，通过将大数据集分散到多个节点上进行并行处理，可以显著提高计算效率。然而，这也带来了数据倾斜和shuffle开销等问题。因此，我们需要通过合理的分区策略和shuffle优化来减少这些问题的影响。
其次，内存管理对于Spark性能至关重要。由于Spark将数据存储在内存中，因此内存的有效管理和利用对于提高Spark作业的执行效率至关重要。我们需要根据作业的特点和集群的资源情况，合理设置JVM参数和内存分配策略，以确保Spark作业能够充分利用内存资源。
最后，数据通信也是影响Spark性能的重要因素之一。在分布式计算环境中，节点之间的数据通信是不可避免的。然而，过多的数据传输会导致网络带宽和磁盘IO成为性能瓶颈。因此，我们需要通过优化shuffle过程、减少数据传输量等方式来降低数据通信对性能的影响。
四、实践案例分析 以下是一个具体的Spark性能优化案例，该案例涉及到了数据倾斜和shuffle调优两个方面。
某电商公司需要对大量用户的购物数据进行分析，以找出用户的购买偏好和商品推荐策略。原始数据存储在HDFS中，每个文件包含一段时间内的用户购物记录。为了提高分析效率，该公司使用Spark对原始数据进行处理和分析。然而，在实际执行过程中，他们发现作业的执行速度非常慢，远远达不到预期的效果。
经过分析，他们发现导致性能瓶颈的主要原因是数据倾斜和shuffle开销过大。具体来说，由于某些热门商品的购买记录非常频繁，导致在join操作中出现了严重的数据倾斜。同时，由于shuffle过程中需要传输大量的数据，导致磁盘IO和网络传输成为了性能瓶颈。
针对这些问题，他们采取了以下优化措施：
对于数据倾斜问题，他们采用了Salting技术和自定义分区策略。具体来说，他们给倾斜的key添加了随机前缀或后缀，使得原本属于一个task的大量数据分散到多个task中进行处理。同时，他们还根据数据的分布情况自定义了分区策略，使得数据更加均衡地分布到各个task中。
对于shuffle开销过大的问题，他们采用了增加shuffle并行度和使用map-side join的策略。具体来说，他们增加了shuffle的并行度，以减少单个task处理的数据量。同时，
他们还使用了map-side join代替reduce-side join，通过在map阶段直接进行join操作，避免了shuffle过程中的数据传输。这样，不仅减少了磁盘IO和网络传输的开销，还提高了整体的计算效率。
在实施了这些优化措施后，该电商公司的Spark作业执行速度得到了显著提升。原本需要数小时才能完成的作业，现在只需几分钟就能完成，大大提高了数据分析的效率和准确性。这一成功案例充分证明了Spark性能优化策略的有效性和实用性。
当然，让我们进一步补充Spark性能优化的内容。
五、监控与诊断 在进行Spark性能优化时，监控和诊断是非常重要的环节。通过实时监控Spark作业的执行情况，我们可以及时发现性能瓶颈，并对其进行针对性的优化。以下是一些常用的Spark监控和诊断工具和方法：
Spark UI：Spark提供了丰富的Web UI界面，用于展示作业的执行情况、各个阶段的耗时、任务状态等信息。通过查看Spark UI，我们可以快速定位到性能瓶颈，并找到需要优化的环节。
日志分析：Spark在执行过程中会生成大量的日志信息，包括任务的执行日志、错误日志等。通过对日志进行分析，我们可以深入了解任务的执行细节，找到潜在的性能问题。
第三方监控工具：除了Spark自带的监控工具外，我们还可以使用第三方监控工具，如Prometheus、Grafana等，对Spark作业进行更全面的监控和诊断。这些工具可以提供更丰富的监控指标和可视化界面，帮助我们更好地了解Spark作业的性能状况。
在监控和诊断过程中，我们需要关注以下几个方面：
资源使用情况：关注Executor的内存和CPU使用情况，确保资源得到了充分利用。
数据倾斜情况：关注join、groupBy等操作中是否存在数据倾斜现象，及时采取优化措施。
Shuffle情况：关注shuffle过程中的数据传输和磁盘IO情况，避免过多的数据传输和磁盘读写操作。
通过监控和诊断，我们可以更准确地找到性能瓶颈，并为其制定针对性的优化策略。
六、持续优化与改进 Spark性能优化是一个持续的过程，需要不断地进行迭代和改进。在实际应用中，我们可能会遇到各种各样的问题和挑战，需要不断地学习和探索新的优化技术和方法。
因此，我们需要保持对新技术和新方法的关注，积极参加相关的技术交流和培训活动，不断提升自己的技术水平。同时，我们还需要建立一套完善的优化流程和机制，将优化工作纳入到日常工作中，确保Spark作业能够持续保持高效稳定的运行状态。
综上所述，Spark性能优化是一个复杂而重要的工作，需要我们从多个角度出发进行全面的优化。通过合理的优化策略、监控与诊断以及持续优化与改进，我们可以提高Spark作业的执行效率，为企业和组织提供更快速、更准确的数据分析和决策支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ea27239fbf3f2195dd0489002fda79c/" rel="bookmark">
			通过升级tomcat完美解决服务器的tomcat漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 引言1 安全评估报告服务器漏洞的说明1.1 tomcat漏洞概况1.2 部分tomcat漏洞详情 2 针对漏洞的分析3 Tomcat 升级步骤步骤 1：下载最新的 Tomcat 版本步骤 2：解压 Tomcat 文件步骤 3：停止旧版本的 Tomcat步骤 4：备份旧的 Tomcat 配置（可选）步骤 5：替换文件夹步骤 6：启动新版本的 Tomcat步骤 7：查看 Tomcat 版本步骤 8：完成 Tomcat 升级 总结 引言 软件开发完成并交付给客户，过了一段时间，客户的上级部门要求对服务器进行安全检测，通过漏洞扫描，对服务器的漏洞情况进行通报，要求限期完成漏洞修补。客户一般没有技术能力，就找到软件开发公司，帮助其解决服务器的安全问题。我们做为软件开发人员，也会帮忙解决一些服务器安全方面的问题。
1 安全评估报告服务器漏洞的说明 首先看一下安全评估报告，报告中对服务器的漏洞，漏洞概况是一个所有漏洞的列表，这里仅选取tomcat漏洞。
1.1 tomcat漏洞概况 端口协议服务漏洞2201TCPwwwApache Tomcat 信息泄露漏洞(CVE-2020-17527) Apache Tomcat 输入验证错误漏洞(CVE-2023-46589) Apache Tomcat 环境问题漏洞(CVE-2022-42252) Apache Tomcat 拒绝服务漏洞(CVE-2023-24998) Apache Tomcat 安全漏洞(CVE-2021-25122) HTTP/2拒绝服务漏洞（CVE-2023-44487） Apache Tomcat 安全漏洞(CVE-2021-25329) Apache Tomcat 拒绝服务漏洞(CVE-2021-41079) Apache Tomcat 权限许可和访问控制问题漏洞(CVE-2022-23181) Apache Tomcat 代码问题漏洞(CVE-2022-29885) Apache Tomcat 代码问题漏洞(CVE-2022-25762) Alibaba Druid 未授权访问【原理扫描】 Apache Tomcat 信息泄露漏洞(CVE-2021-24122) Apache Tomcat 环境问题漏洞(CVE-2021-33037) Apache Tomcat 访问控制错误漏洞(CVE-2021-30640) Apache Tomcat 跨站脚本漏洞(CVE-2022-34305) Apache Tomcat文件包含漏洞(CVE-2023-28708) Apache Tomcat 输入验证错误漏洞(CVE-2023-41080) Apache Tomcat 安全漏洞(CVE-2023-42795) Apache Tomcat 输入验证错误漏洞(CVE-2023-45648) Apache Tomcat 安全漏洞(CVE-2024-23672) Apache Tomcat信息泄露漏洞(CVE-2024-21733) Apache Tomcat 输入验证错误漏洞(CVE-2024-24549)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ea27239fbf3f2195dd0489002fda79c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f854e4959eafb6125c03c75d9e5a8458/" rel="bookmark">
			Oracle HTTP Server（OHS）与Oracle数据库的紧密绑定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle HTTP Server（OHS）与Oracle数据库的紧密绑定通常是通过一系列的配置和集成步骤来实现的。以下是这些步骤的详细归纳，包括必要的分点表示和参考信息：
一、安装和配置Oracle HTTP Server
安装OHS：
在安装Oracle Fusion Middleware或Oracle EPM System时，可以选择安装Oracle HTTP Server组件。
或者，可以从Oracle官网单独下载OHS的安装包进行安装。
配置OHS：
设置OHS的监听端口、虚拟主机等基本参数。
如果需要支持HTTPS，还需要配置SSL证书和私钥，通常这些会存储在Oracle Wallet中。
二、配置Oracle Wallet
创建Wallet：
使用Oracle Wallet Manager或命令行工具（如orapki）创建一个新的Wallet。
将SSL证书和私钥导入到Wallet中。
配置自动登录（可选）：
在Wallet中设置自动登录选项，以便OHS在启动时能够自动访问Wallet中的证书。
三、集成Oracle数据库
配置mod_plsql（如果适用）：
对于需要直接通过HTTP请求访问Oracle数据库的场景，可以配置mod_plsql模块。
mod_plsql是一个Apache模块，它允许通过HTTP协议直接执行PL/SQL代码。
在OHS中配置mod_plsql需要指定数据库的连接信息、用户权限等。
使用其他集成技术：
如果不使用mod_plsql，也可以通过Web应用程序（如Java EE应用、PHP应用等）与Oracle数据库进行交互。
这些应用程序可以部署在OHS上，并通过JDBC、OCI等数据库连接技术访问Oracle数据库。
四、配置OHS以代理数据库请求
设置反向代理：
在OHS中配置反向代理规则，将特定的HTTP请求转发到Oracle数据库（通常是通过后端的应用程序服务器）。
这可以通过OHS的配置文件（如httpd.conf）中的ProxyPass和ProxyPassReverse指令来实现。
优化性能和安全性：
根据需要配置连接池、会话管理等高级功能，以优化性能和安全性。
确保OHS和Oracle数据库之间的网络连接是安全的，并配置适当的防火墙和安全组规则。
五、测试和验证
测试配置：
使用浏览器或HTTP客户端工具测试OHS的配置是否正确。
验证是否能够成功访问Oracle数据库，并处理HTTP请求。
监控和维护：
部署后，定期监控OHS和Oracle数据库的性能和日志，以便及时发现并解决问题。
根据需要进行配置调整和优化。
通过以上步骤，Oracle HTTP Server可以与Oracle数据库紧密绑定，为Web应用程序提供稳定、高效、安全的数据库访问服务。
OHS（Oracle HTTP Server）通过mod_plsql访问Oracle数据库是一个特定的配置过程，它允许HTTP请求直接执行PL/SQL代码。下面是一个清晰的例子，展示了如何配置OHS和mod_plsql以访问Oracle数据库：
一、准备工作
确认环境：
确保Oracle HTTP Server（OHS）已经安装并运行在你的系统上。
确保Oracle数据库也已安装并配置好监听器，能够接受连接。
下载并安装mod_plsql（如果尚未安装）：
mod_plsql可能不是OHS安装包的一部分，需要从Oracle官网或第三方源下载。
安装mod_plsql，并按照其文档进行配置。
二、配置mod_plsql
编辑OHS配置文件（通常是httpd.conf或类似的文件）：
加载mod_plsql模块。在配置文件中添加类似LoadModule plsql_module modules/mod_plsql.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f854e4959eafb6125c03c75d9e5a8458/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/303a42132042e597514d994a1b66aff4/" rel="bookmark">
			毕设开源 基于图像识别的跌倒检测算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 前言1 实现方法传统机器视觉算法基于机器学习的跌倒检测SVM简介SVM跌倒检测原理算法流程算法效果实现代码 深度学习跌倒检测最终效果网络原理 最后 前言 背景和意义
在美国，每年在65岁以上老人中，平均每3人中就有1人发生意外跌倒，每年大约有9500位老年人死于旅行途中或跌倒；而平均年龄在65岁至69岁之间的人每200次跌倒中就有一次髋关节骨折。更严重的是，20%到30%的患者会出现中度到严重的并发症，很可能导致残疾。
而在中国，老年人口已经突破2.5亿，按照30%概览推算，每年有7500万人次的老年人摔倒。
🧿 **选题指导, 项目分享：见文末** 1 实现方法 实现方法有两种，一种是基于计算机视觉的，一种是基于惯性传感器器件的。
这次主要还是介绍基于计算机视觉的，想了解或学习基于惯性传感器器件跌倒检测的同学联系学长，学长安排博客。
传统机器视觉算法 传统背景差分法，结合OpenCV中的图像高斯平滑预处理以及腐蚀、膨胀图像形态学处理方法，实现一个更符合实际场景需要的运动目标检测方法。实验效果比较分析表明，该目标检测算法较传统目标检测算法能够提取更加准确和完整的运动目标轮廓。
检测效果如下：
背景差分法利用当前待处理视频帧图像与已经建模好的背景图像进行差分运算，利用阈值处理减少图像中的噪声干扰。优点是计算简单，且可以解决帧间差分法检测空洞的问题，得到的轮廓比较完整； 缺点是对于动态场景的适应能力不强， 对光照变化、 外来无关事物影响比较敏感。
需要源码联系学长—点我查看
基于机器学习的跌倒检测 人体行为辨识属于模式识别的分类决策的阶段，主要通过提取表征人体运动行为的特征向量，进而对人体的行为进行分析分类，最终用自然语言对其进行描述。有两种比较常见的方法：
（1） 基于模型的方法
基于模板的方法主要以人体模板作为主要的使用依据，可以通过对包含特定行为的视频帧序列进行转换的方法得到人体的模板，然后将被检测的人体行为与已经归类的人体行为模板进行匹配分类，从而得到行为识别的结果。基于模型的方法具有计算简单的优点，一般通过模型之间的距离比较完成人体行为的分类识别。缺点是需要大量足够的训练样本。
（2） 基于聚类的方法
基于聚类的方法把视频帧序列按照某种规则分类，在每一段进行特征的提取组成表示该段的特征矢量，进而通过聚类和相似度量等方法，将其中类别较少的段归为异常。常在处理离线状态下大量数据的异常检测问题时使用基于聚类的行为辨识方法。
SVM简介 支持向量机即常说的 SVM，全称是Support Vector Machine。支持向量机是建立在统计学的VC维理论与结构化最小风险原理的基础上的，通过将向量映射到一个更高维的空间里，在这个空间建立一个最大间隔超平面，这个超平面被称为最优分类面，是支持向量机方法的理论基础。
SVM跌倒检测原理 我设计了一种运动物体行为辨识中采用基于两级SVM分类器的方法。
第一级SVM分类器用于判决运动物体是否处于非直立（下蹲、跌倒等）状态，提取物体的宽高比、最小包含物体矩形框面积、最小包含物体矩形框周长、运动物体高度等特征进行分类器的训练和分类判决。对于第一级分类器判决为非直立状态的图像帧，将它送入第二级SVM分类器进行分类判决。
第二级SVM分类器用于区分运动物体处于跌倒或其他的非直立状态，提取Zernike矩特征、运动物体的高度、运动物体的宽度、运动物体轮廓面积、运动物体轮廓周长等特征进行分类器的训练和分类判决。如果第二级 SVM 分类器判决为属于跌倒姿势状态类， 系统自动发出报警信息。
算法流程 算法效果 实现代码 联系学长获取帮助—点我查看
深度学习跌倒检测 介绍一个效果非常不错的网络，使用数据集在该网络下训练后得到的跌倒检测效果粉肠不错。
最终效果 网络原理 最后 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/200/">«</a>
	<span class="pagination__item pagination__item--current">201/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/202/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>