<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4a2632ad0dc1b1afc72e54b22244e62/" rel="bookmark">
			WD1.4标签器：Stable Diffusion的提示词反推神器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在AI绘画领域，Stable Diffusion（SD）因其强大的生成能力而备受关注。然而，如何精准地控制和优化生成效果，常常是许多用户面临的问题。今天，我们将详细介绍一款实用的插件——WD1.4标签器，它可以帮助我们反推出图片背后的提示词，从而提升我们的AI绘画体验。
首先，访问好易智算平台，在这里可以直接选择“扩展”功能。在拓展列表中，您会发现WD 1.4标记器已经内置，无需额外下载安装。选择该标记器，点击“安装”，系统将自动完成安装过程。安装成功后，点击“应用”按钮，然后重启UI或WebUI，即可开始使用。
WD1.4标签器简介 WD1.4标签器是一款专为Stable Diffusion设计的插件，用于分析上传的图片并提取出其背后的提示词。通过这个工具，我们可以更深入地理解图片的元素和风格，并为二次创作提供有力的支持。此外，该插件还支持多种替代模型查询，类似于deepdanbooru查询。
例如：我们将这张图片放到插件中 参数 预设： 在Stable Diffusion的上下文中，预设是指一系列预先定义的设置，包括模型参数、生成图像的风格、尺寸等。这些预设可以帮助用户快速开始生成特定风格的图像，而无需从头开始调整所有参数。 反推： 在图像生成的语境中，“反推”通常指的是根据生成的图像推断出原始的文本提示（prompt）或参数。这可以用于分析模型如何响应特定的输入，或者帮助用户理解如何修改提示以获得期望的输出。 卸载反推所有模型： 这意味着允许用户从插件中移除所有用于反推功能的模型。这样做可以释放内存，或者是在不需要反推功能时优化性能。 阈值： 在图像生成中，阈值用于确定何时停止迭代过程，例如，当生成的图像质量达到某个预定水平时。它也可以用于过滤模型生成的结果，只保留那些超过特定置信度或质量标准的图像。 附件标签： 在插件的上下文中，附件标签是指与主要生成任务相关的额外标签或元数据。这些标签可以用于对生成的图像进行分类，或者提供额外的信息，帮助用户在浏览或筛选图像时找到特定的内容。 排除标签： 排除标签是一组关键词或主题，用户希望在生成图像时避免出现。例如，如果用户不希望生成的图像包含某些敏感内容，他们可以将这些内容作为排除标签，以指示模型在生成图像时避开这些元素。 生成效果：
solo, 1boy, male focus, shirt, looking at viewer, black hair, collared shirt, realistic, upper body, indoors, black eyes, short hair, closed mouth, window, white shirt, lips, buttons 我们看到这个翻译后的内容很不错的
我们将负面提示词输入进去，点击生成
我们其实可以发现，原图的内容已经较好的还原了，发型，纽克等关键内容，但似乎并没有达到想要的效果
我们这里可以选择ControlNet v1.1.445
并且更新了社区功能，可以社区镜像，心愿墙，晒作品进行分享
并且无论是从便捷性、资源优势、社区支持，还是持续更新和专业服务，好易智慧算平台都是我们使用的理想选择。
下面我们进行选择:
ControlNet ControlNet v1.1.445 是一款先进的神经网络插件，旨在提升图像生成过程中的控制和一致性，尤其针对 Stable Diffusion 模型。以下是对您提供的内容的优化版本：
专注于提升图像生成的质量和一致性。通过引入额外的控制条件，用户能够更精准地操控图像生成过程，不再需要依赖于不断尝试不同的提示词。这一创新使得基于单一提示词生成统一风格的高质量图像成为现实。
我们可以看到这样之后效果就好了很多，统一了风格
我们可以来了解一下ControlNet 的原理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4a2632ad0dc1b1afc72e54b22244e62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43838d5179695e9ffe5ab0fd78a66ba1/" rel="bookmark">
			C语言：扫雷游戏实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、扫雷游戏的分析和设计 扫雷游戏想必大家都玩过吧，初级的玩法是在一个9*9的棋盘上找到没有雷的格子，而今天我们就要做的就是9*9扫雷游戏的实现。
1、游戏功能和规则 使用控制台实现经典的扫雷游戏游戏可以通过菜单实现继续玩或者退出游戏扫雷的棋盘是9*9的格⼦默认随机布置10个雷（可随意）可以排查雷 如果位置不是雷，就显示周围有几个雷
如果位置是雷，就炸死游戏结束
把除10个雷之外的所有非雷都找出来，排雷成功，游戏结束
2、游戏实现思路 首先，创建一个主函数用于判断是否进行游戏，并设计一个菜单。创建用于存放雷的棋盘，并进行棋盘的初始化。设计棋盘的打印。放入雷，并实现有雷棋盘的打印。输入坐标进行排查，并返回排查结果。进行循环直到排查成功或被炸死。 在布置雷的过程中我们将雷设置为'1',不是雷设置为'0'; 二、代码实现 在实现代码前，我们可以用多文件的方式，对我们的函数进行声明和定义，这样可以简化和简洁直观的设计和表达代码。
game.h:我们可以在game.h文件中包含我们所有需要用到的头文件，常量的定义和函数的声明，其他文件只需要声明game.h 即可。game.c:写入游戏所需要的功能函数。test.c:代码的整合 1、主函数的实现 在主函数中我们先创建一个input值，用于输入我们的选择，根据 do while 循环判断我们是否进行游戏，并且每次循环都打印菜单，在接着使用switch语句根据玩家输入进行判断，如果输入为1就开始游戏执行game(),如果为0，游戏结束并跳出循环，如果输入错误就继续进行循环直到主动退出。
int main() { int input = 0; srand((unsigned int)time(NULL)); do { menu(); printf("请输入选项："); scanf("%d", &amp;input); switch (input) { case 1: printf("开始游戏\n"); game(); break; case 0: printf("游戏结束\n"); break; default: printf("选择错误，请重新选择：\n"); break; } } while (input); return 0; } 2、菜单的实现 不需要返回所以用void
void menu() { printf("****************\n"); printf("**** 1.play ****\n"); printf("**** 0.exit ****\n"); printf("****************\n"); } 3、游戏函数的实现 1、棋盘的设计 在排雷的过程中如果我们选择的位置不是雷就会看它周围的8个坐标中是否有雷，如果有雷就会显示雷的个数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43838d5179695e9ffe5ab0fd78a66ba1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fc778b395b22e5a2473088bdf73b1d0/" rel="bookmark">
			Llama 3.1：Meta迄今为止规模最大、质量最高的开源模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		早在今年4月，Meta就曾透露正在为AI行业开发一项首创技术：一种性能足以与OpenAI等厂商的最强私有模型相媲美的开源模型。
现如今，这套模型已经问世。Meta发布了有史以来体量最大的开源AI模型Llama 3.1。该公司声称该模型在多项基准测试中优于GPT-4o和Anthropic的Claude 3.5 Sonnet。新版本还为基于Llama的Meta AI助手带来更多国家和语种支持，同时绞架了一项可以根据特定人物肖像生成图像的新功能。公司CEO马克·扎克伯格更是大胆做出预测，称到今年年底，Meta AI将超越ChatGPT成为使用范围最广的AI助手。
Llama 3.1比几个月前发布的小型Llama 3模型复杂得多。其最大的版本拥有4050亿个参数，且使用超过1.6万张英伟达旗舰级H100 GPU训练而成。Meta没有透露Llama 3.1的开发成本，但单纯计算英伟达芯片的采购成本，就可以肯定资金投入不会低于数亿美元。
那么考虑到如此高昂的成本投入，Meta为何执意让Llama模型家族保持开源，将如此重量级的成果免费交付至众多用户手中？在Meta公司通过官博发表的公开信中，扎克伯格宣称开源AI模型终将超越专有模型——而且目前已经展现出优于专有模型的改进速度。这就如同开源Linux系统，如今成为大多数手机、服务器和小装置上的主导操作系统一样。
他还将Meta对于开源AI的投入，与公司早期的开放计算项目（OCP）进行了比较。他表示在Meta规划自己的基础设施容量时，惠普等其他厂商帮助Meta对数据中心设计进行了改进了标准化，帮助其成功节约下“数十亿美元”。展望未来，他预计同样的情况也将在AI领域上演。他在信中写道：“我相信Llama 3.1的发布将成为行业中的又一个转折点，大多数开发人员开始主要依赖开源成果。”
为了帮助将Llama 3.1推向世界，Meta正在与微软、亚马逊、谷歌、英伟达和Databricks等二十多家公司合作，帮助开发人员部署适合自身需求的版本。Meta声称，Llama 3.1在生产环境中的运行成本大约只相当于OpenAI GPT-4o的一半。他们还一并发布了模型权重，以便企业客户能够立足自身数据以模型进行训练，并根据实际偏好做出调整。
根据Meta公司发言人Jon Carvill的介绍，Gemini未被纳入此番基准比较，因为Meta难以使用谷歌提供的AIP来重现其先前声明的结果。
Meta主要合作伙伴清单及其为Llama 3.1部署提供的功能方案。
不出所料，Meta并没有透露太多关于用于训练Llama 3.1模型的数据信息。先后已经有多位曾经在AI企业工作过的雇员表示，由于涉及商业机密，他们无法透露这部分信息。但批评人士则认为，这是一种通过拖延来对抗版权诉讼纠纷的消极策略。
但Meta强调，他们使用的是合成数据，也就是由模型生成、而非来自真实人类的数据。此外，他们还利用4050亿参数版本的Llama 3.1，对原有小型700亿及80亿参数版本模型做出了改进。Meta公司生成式AI副总裁Ahmad Al-Dahle预计，Llama 3.1将在开发者群体当中受到欢迎，因为它堪称“小模型的老师，能够在提升前者性能之后以更具成本效益的方式实现AI部署”。
在被问及Meta是否认可业界日益增长的普遍共识，即可供模型使用的高质量训练数据即将耗尽时，Al-Dahle表示上限确实即将到来，只不过具体期限可能比部分人想象中的更远。“我们相信目前的数据应该还能再支撑几个训练周期，但具体情况也很难说。”
Meta还首次对Llama 3.1进行了红队测试（即对抗性测试），包括借此寻求潜在的网络安全与生物化学用例。而对模型开展严格测试的另一个理由，在于Meta提到的新兴“代理”行为。
例如，Al-Dahle告诉我们Llama 3.1能够与搜索引擎API相集成，以“通过复杂的查询从互联网上检索信息，并连续调用多种工具以完成用户提交的任务。”他还给出另一个例子，就是要求模型绘制过去五年来全美售出的房屋数量。“它可以检索网络结果，生成Python代码并加以执行。”
Meta自己的Llama实现方案是一款AI助手，其功能定位属于类似ChatGPT的通用型聊天机器人，且几乎能够在Instagram、Facebook和WhatsApp的各个功能模块上发挥作用。从本周开始，Llama 3.1将率先通过WhatsApp和美国Meta AI网站对外开放，并在随后几周内正式登陆Instagram与Facebook。此番更新将让Meta AI助手支持更多 新语种，包括法语、德语、印地语、意大利语和西班牙语。
虽然Llama 3.1最先进的4050亿参数模型已经在Meta AI中免费开放，但助手会在一周内提示词超过指定数量后将用户切换至体量更小的700亿参数模型。由此看来，4050亿参数模型对于Meta来说还是太过昂贵，仍无法全面运行。公司发言人Jon Carvil告诉我们，Metra将在评估早期使用情况之后提供关于提示词阈值的更多信息。
Meta AI还提供一项新的“Imagine Me”功能，可以通过手机摄像头扫描用户面部，进而将用户的肖像插入到其生成的图像当中。通过这种方式、而非直接从个人资料照片中捕捉人脸，Meta希望避免其AI功能被deepfakes滥用。该公司意识到越来越多的用户希望创建多种AI媒体，并将结果分享到自己的个人动态之内，尽管这有可能进一步模糊真实与虚假之间的判断边界。
Meta AI也将在未来几周内登陆Quest头显设备，取代其语音命令界面。与Meta Ray-Ban眼镜中的实现效果类似，用户可以在Quest上使用Meta AI来识别并理解头显直通模式下看到的内容，进而通过显示屏解读现实世界。
除了扎克伯格预计Meta AI将在今年年底成为使用率最高的聊天机器人（作为比较，ChatGPT目前拥有超过1亿用户）之外，Meta并未分享其AI助手的任何市场普及度数据。Al-Dahle表示：“我认为整个行业在产品的市场匹配方面仍处于早期探索阶段。”尽管AI科技存在严重的过度炒作之嫌，但Meta及其他参与厂商显然对未来抱有信心，并坚定认为新一轮竞争才刚刚开始。
如何系统的去学习大模型LLM ？ 作为一名热心肠的互联网老兵，我意识到有很多经验和知识值得分享给大家，也可以通过我们的能力和经验解答大家在人工智能学习中的很多困惑，所以在工作繁忙的情况下还是坚持各种整理和分享。
但苦于知识传播途径有限，很多互联网行业朋友无法获得正确的资料得到学习提升，故此将并将重要的 AI大模型资料 包括AI大模型入门学习思维导图、精品AI大模型学习书籍手册、视频教程、实战学习等录播视频免费分享出来。
所有资料 ⚡️ ，朋友们如果有需要全套 《LLM大模型入门+进阶学习资源包》，扫码获取~
👉[CSDN大礼包🎁：全网最全《LLM大模型入门+进阶学习资源包》免费分享]👈
​
一、全套AGI大模型学习路线 AI大模型时代的学习之旅：从基础到前沿，掌握人工智能的核心技能！
二、640套AI大模型报告合集 这套包含640份报告的合集，涵盖了AI大模型的理论研究、技术实现、行业应用等多个方面。无论您是科研人员、工程师，还是对AI大模型感兴趣的爱好者，这套报告合集都将为您提供宝贵的信息和启示。
三、AI大模型经典PDF籍 随着人工智能技术的飞速发展，AI大模型已经成为了当今科技领域的一大热点。这些大型预训练模型，如GPT-3、BERT、XLNet等，以其强大的语言理解和生成能力，正在改变我们对人工智能的认识。 那以下这些PDF籍就是非常不错的学习资源。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fc778b395b22e5a2473088bdf73b1d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17747c9bb46ccb4f5b128e77b7ef98e1/" rel="bookmark">
			C&#43;&#43;中的依赖注入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.概述
2.构造函数注入
3.setter方法注入
4.接口注入
5.依赖注入框架
6.依赖注入容器
7.依赖注入框架的工作原理
8.依赖注入的优势
9.总结
1.概述 依赖注入是一种设计模式，它允许我们在不直接创建对象的情况下为对象提供其依赖项；它通过将对象的依赖关系从内部实现转移到外部配置，以此来实现松耦合；这使得我们的代码更易于测试、维护和扩展。
然而，在C++中实现依赖注入（Dependency Injection, DI）通常比在一些其他语言（如Java或.NET）中更具挑战性，因为C++是一种静态类型语言，且没有内建的依赖注入框架。不过，通过一些设计模式和技术，我们可以在C++项目中实现依赖注入。
依赖注入主要有以下三种方式：
构造函数注入：将被依赖对象通过构造函数的参数传递依赖对象，并且在初始化对象的时候注入。
属性注入：通过属性（成员变量）来传递依赖对象。
接口注入：通过接口方法传递依赖对象。
在C++中，构造函数注入和属性注入是最常用的两种方式。
2.构造函数注入 构造函数注入是一种最简单且最常用的依赖注入方式，通过构造函数参数来传递依赖对象。示例代入如下：
class Dependency { public: void doSomething() { // 实现 } }; class MyClass { private: Dependency* dep; public: MyClass(Dependency* dep) : dep(dep) {} void someMethod() { dep-&gt;doSomething(); } }; // 使用 Dependency dep; MyClass myClass(&amp;dep); myClass.someMethod(); 在上述代码中，MyClass类通过构造函数接收Dependency对象的引用，从而实现了依赖注入。
3.setter方法注入 通过类的成员函数（通常是setter）来注入依赖项。这种方式提供了更多的灵活性，但也可能导致类在使用前未正确配置的风险。示例代码如下：
class MyClass { private: Dependency* dep = nullptr; public: void setDependency(Dependency* dep) { this-&gt;dep = dep; } void useDependency() { if (dep) { dep-&gt;doSomething(); } } }; // 使用 Dependency dep; MyClass myClass; myClass.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17747c9bb46ccb4f5b128e77b7ef98e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4832d311e9240cc246fab782cb9d44d3/" rel="bookmark">
			【C&#43;&#43;】：AVL树的深度解析及其实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 🚀前言一，AVL树的概念二，AVL树节点的定义三，AVL树的插入3.1 第一步3.2 第二步 四，AVL树的旋转4.1 右单旋4.2 左单旋4.3 右左双旋4.4 左右双旋4.5 插入代码的完整实现4.6 旋转总结 五，AVL树的验证六，AVL树的性能七，实现AVL树的完整代码 点击跳转至文章： 【C++/STL】：set和map的介绍及基本使用】 点击跳转至文章：【C++】：二叉树进阶 — 搜索二叉树 🚀前言 上一篇文章对map/multimap/set/multiset进行了简单的介绍，在其文档介绍中发现，这几个容器有个共同点是：其底层都是按照二叉搜索树来实现的，但是二叉搜索树有其自身的缺陷，假如往树中插入的元素有序或者接近有序，二叉搜索树就会退化成单支树，时间复杂度会退化成O(N)，因此map、set等关联式容器的底层结构是对二叉树进行了平衡处理，即采用平衡树来实现。
本篇文章介绍的就是平衡树之一的：AVL树。
注意：本篇文章AVL树实现的 key_value 模型。因为实际上 map/set 的底层并不是用AVL树封装的，而是用红黑树（下一篇文章），在红黑树的部分我们再对 key 和 key_value 模型进行更深层次的封装。
一，AVL树的概念 对于二叉搜索树极端情况下查找效率低下的问题，有大佬提出了这样的解决方法：
当向二叉搜索树中插入新结点后，如果能保证每个结点的左右子树高度之差的绝对值不超过1(需要对树中的结点进行调整)，即可降低树的高度，从而减少平均搜索长度。
一棵AVL树或者是空树，或者是具有以下性质的二叉搜索树：
(1) 它的左右子树都是AVL树；
(2) 左右子树高度之差(简称平衡因子)的绝对值不超过1(-1/0/1)
如果一棵二叉搜索树是高度平衡的，它就是AVL树。如果它有n个结点，其高度可保持在
O ( l o g 2 n ) O(log_2 n) O(log2​n)，搜索时间复杂度O( l o g 2 n log_2 n log2​n)。
二，AVL树节点的定义 AVL树节点的定义：
(1) 三叉链：左子树，右子树，父亲。
(2) 平衡因子：一般情况下是，右子树高度 - 左子树高度。
(3) key_value 模型的 pair 类型的数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4832d311e9240cc246fab782cb9d44d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e650e1f528c8207ee323d31b99baadc/" rel="bookmark">
			anaconda&#43;tensorflow&#43;keras&#43;jupyter notebook搭建过程（CPU版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Anaconda+TensorFlow+Keras 环境搭建教程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2efe586bd60a93c9fd75ce9acf331b86/" rel="bookmark">
			让数组有序的最少交换次数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Trick : 让数组有序的最少交换次数 Problem One 1224. 交换瓶子 - AcWing题库
有 N 个瓶子，编号 1∼N，放在架子上。
比如有 5 个瓶子：
2 1 3 5 4 要求每次拿起 2 个瓶子，交换它们的位置。
经过若干次后，使得瓶子的序号为：
1 2 3 4 5 对于这么简单的情况，显然，至少需要交换 2 次就可以复位。
如果瓶子更多呢？你可以通过编程来解决。
记录每个位置的元素应该去的位置，会形成若干环。对于每个环，内部交换即可，交换次数即为 : 环的长度 - 1 。因为每次交换都会让一个位置有序，环的长度会减 -1。
int const N = 11000; int n, a[N], to[N], vis[N]; void solve(){ cin &gt;&gt; n; for(int i = 1; i &lt;= n; i ++){ cin &gt;&gt; a[i]; to[i] = a[i]; } int res = 0; for(int i = 1; i &lt;= n; i ++){ if(vis[i]) continue ; int len = 0, now = i; while(vis[now] == false){ vis[now] = true; len ++; now = to[now]; } res += len - 1; } cout &lt;&lt; res &lt;&lt; '\n'; } Problem Two C-Sort4_2024牛客暑期多校训练营4 (nowcoder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2efe586bd60a93c9fd75ce9acf331b86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/151fca34f5a8d68d789885a87f5dedd3/" rel="bookmark">
			Java多线线程-----等待唤醒机制(wait notify)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.等待唤醒机制简介：
二.synchronized,wait(),notify():
三.等待唤醒机制案例:
例题一：
例题二：
四.什么时候释放锁—wait（）、notify（）
一.等待唤醒机制简介： 由于线程之间是抢占式执行的，因此线程的执行顺序难以预知。但是实际开发中有时候我们希望合理的协调多个线程之间的执行先后顺序。为了完成协调的工作，这里主要设计三个方法：
wait() / wait(long timeout) : 让当前线程进入等待状态
notify() / notifyAll(): 唤醒在当前对象上等待的线程
注意：wait,notify,notifyAll都是Object类的方法
二.synchronized,wait(),notify(): synchronized 的含义： Java中每一个对象都可以成为一个监视器（Monitor）, 该Monitor由一个锁（lock）, 一个等待队列（waiting queue ）, 一个入口队列( entry queue).
对于一个对象的方法， 如果没有synchronized关键字， 该方法可以被任意数量的线程，在任意时刻调用。
对于添加了synchronized关键字的方法，任意时刻只能被唯一的一个获得了对象实例锁的线程调用。
synchronized用于实现多线程的同步操作
wait()功能： wait(), notify(), notifyAll() 和 synchonized 需要搭配使用， 用于线程同步
wait()总是在一个循;环中被调用，挂起当前线程来等待一个条件的成立。 Wait调用会一直等到其他线程调用notifyAll()时才返回。
当一个线程在执行synchronized 的方法内部，调用了wait()后， 该线程会释放该对象的锁， 然后该线程会被添加到该对象的等待队列中（waiting queue）, 只要该线程在等待队列中， 就会一直处于闲置状态， 不会被调度执行。 要注意wait()方法会强迫线程先进行释放锁操作，所以在调用wait()时， 该线程必须已经获得锁，否则会抛出异常。由于wait()在synchonized的方法内部被执行， 锁一定已经获得， 就不会抛出异常了。
notify()的功能： wait(), notify(), notifyAll() 和 synchonized 需要搭配使用， 用于线程同步
当一个线程调用一个对象的notify()方法时， 调度器会从所有处于该对象等待队列（waiting queue）的线程中取出任意一个线程， 将其添加到入口队列( entry queue) 中.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/151fca34f5a8d68d789885a87f5dedd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd9e2332d40a37a20ccd098afc30cc7a/" rel="bookmark">
			数据结构——单链表OJ题（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、链表的回文结构
思路一：数组法
（1）注意
（2）解题
思路二：反转链表法
（1） 注意
（2）解题
二、相交链表
（1）思路：快慢指针
（2）注意
（3）解题
三、环形链表1
（1）思路：快慢指针
（2）解释
（3）注意
（4）解题
①快指针走两步
② 快指针走三步
四、环形链表2
（1）思路：快慢指针
（2）解释
（3）注意
（4）解题
五、随机链表的复制
（1）思路
（2）解题
六、写在最后 一、链表的回文结构 思路一：数组法 将链表中结点的数据存储在数组中，创建两个指针分别从左右两边遍历并比较，如果左右对称则说明是回文结构。
（1）注意 ①为什么要创建数组存储数据？因为链表的结点不是连续的，不能进行逆向访问；
②从左右两端进行遍历时，需满足left&lt;right的条件；
③该方法只适用于链表长度小于等于900的条件下，因为数组的长度最大为900。
（2）解题 typedef struct ListNode ListNode; bool chkPalindrome(ListNode* A) { //创建数组存储数据 int arr[900] = {0}; //数据的个数为i int i = 0; ListNode* pcur = A; //遍历链表，将数据存储在数组中 while(pcur) { arr[i++] = pcur-&gt;val; pcur = pcur-&gt;next; } int left = 0; int right = i - 1; while(left &lt; right) { //若有不相等，说明不是回文结构 if(arr[left] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd9e2332d40a37a20ccd098afc30cc7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/811dc30571ad5fb5e0afc9bf4d385f50/" rel="bookmark">
			第三周DAY04---git
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、git的主要功能
二、安装git
[root@git ~]# yum -y install git
[root@git ~]# rpm -ql git 查看版本信息
[root@git ~]# git
[root@git ~]# mkdir /yy000 创建目录
使用git指令，一定要cd到初始化之后的目录
cd到yy000目录中使用init指令促使初始化
[root@git ~]# cd /yy000/
[root@git yy000]# ls
[root@git yy000]# git init
初始化空的 Git 版本库于 /yy000/.git/
[root@git yy000]# ls -a
. .. .git
[root@git yy000]# cd ./git
-bash: cd: ./git: 没有那个文件或目录
[root@git yy000]# cd .git/
[root@git .git]# ls
branches config description HEAD hooks info objects refs
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/811dc30571ad5fb5e0afc9bf4d385f50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30d711ff66915ce023a0bae83fd942e8/" rel="bookmark">
			手撕数据结构---------顺序表和链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.线性表 线性表（linear list）是n个具有相同特性的数据元素的有限序列。 线性表是⼀种在实际中⼴泛使 ⽤的数据结构，常⻅的线性表：顺序表、链表、栈、队列、字符串…
线性表在逻辑上是线性结构，也就说是连续的⼀条直线。但是在物理结构上并不⼀定是连续的， 线性表在物理上存储时，通常以数组和链式结构的形式存储。
具有一类相同特性的数据结构的集合
水果：苹果、香蕉、梨
蔬菜：青菜、黄瓜、冬瓜、丝瓜
线性表：顺序表、链表
具有一类相同特性的数据结构的集合
想用特征指的是两个方面：逻辑结构、物理结构
那么物理结构指的是数据在内存上的存储形式
逻辑结构：人为想象出来的数据的组织形式
线性表中的成员在逻辑结构上都是线性的
对于一个数组1 2 3 4 5 6
下标i进行++操作依次访问，这个可以看得出数组在物理结构上是线性的
因为这个数组的排列顺序我们能知道数组在逻辑结构上面的话是线性的
而对于顺序表来说，逻辑结构是线性的，但是物理结构是不是线性的呢
所以顺序表在逻辑结构上一定是线性表，但是在物理结构上我们不知道是不是线性的
我们需要对顺序表的底层结构进行探究
2.顺序表 顺序表的基础概念 顺序表的概念:顺序表是⽤⼀段物理地址连续的存储单元依次存储数据元素的线性结构，⼀般情况下采⽤数组存储
所以顺序表的底层结构就是数组
我们在上一章节说道：顺序表在逻辑结构上一定是线性表，但是在物理结构上我们不知道是不是线性的
但是这里我们知道顺序表的底层结构是数组，因为数组在物理结构上是线性的，那么顺序表在物理结构上也是线性的
那么数组和顺序表的区别是什么呢？
将数组进封装一下，提供一些对数据管理的操作，比如说增加删除修改查找
那么数组就变成了顺序表，所以说顺序表的底层结构是数组
顺序表是对数组进行封装：结构体
顺序表的定义 定义之前已经知道数组大小的数组
int arr[3]={1,2,3}
定义之前不知道数组大小的数组---动态内存管理
int *arr---定义一个指针
sequence:流畅的 List:表
那么对顺序表的定义
静态顺序表的定义 1.已知顺序表的大小:
静态顺序表：
struct SeqList
{
int arr[1000];
int size;//顺序表中有效数据的个数
}；
如果我们一开始不知道顺序表的大小的话，在后面代码生成的时候申请了大小，这就是动态顺序表
对于顺序表，我们不一定是整型数组，可能是字符数组，那么这个时候我们就要用到typedef了，将数据类型重命名，因为这样会很方便的，如果一个个改的话就很麻烦
我们在不确定用什么类型的数据的时候，我们将数据类型重命名就行了，到时候我们要进行更改的时候仅仅只需要更改这里的数据类型，没必要一个个进行更改
那么上面的顺序表就改成这个样子了
typedef int SLDataType
define N 7 我们在这里将数组的大小进行宏定义，随时可以进行修改的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30d711ff66915ce023a0bae83fd942e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85d4018116d0e659e9b25808b9877f87/" rel="bookmark">
			文件系统中元数据的隐患——缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 热点文件（尤其是大文件）在查询或下载过程中，涉及大量的元信息访问。如果元信息较大且访问 QPS 较大时，就会导致实例网卡打满、CPU爆表，造成缓存失效（缓存击穿）；流量直接打到 DB 上，造成大量读请求超时、连接打满、机器挂掉（服务雪崩）。直接对服务可用性造成打击，一般都是重大事故。
造成这种结果的本质原因是缓存设计和使用不合理。直接原因是缓存对象指向的文件是热门资源。一般文件系统很少关心文件或者文件对象指向的内容，所以在这类热点发生时往往很被动。需要告警阈值提醒，人工及时介入处理和止损（封禁、扩容）。
理想的方式是对文件粒度的读访问限流，但是很少这么做，就像普通用户 Windows 系统装防火墙一样...代价大价值很难凸显。比较常用的方法是对缓存下手，业务侵入小，普适性高。
前提是需要梳理业务逻辑，对目标对象的缓存本身进行分析，哪些情况QPS 达到多少就会有隐患。然后再分析一下可用的方案，一般有三种处理方式：
本地缓存
在合适的业务节点实例上，申请一定大小的空间用于本地缓存。将需要被缓存的一定大小以上的元数据作为缓存对象。需要自行实现淘汰算法，支持过期时间，支持内容校验。由于流量的负载均衡和随机性，需要埋点查看缓存命中率，估计效果。
这种方式可以解决集中热点问题，但是无法根治。命中率随着流量随机性的降低而升高，这取决于流量分发层策略和设计。
缓存数据压缩
一般压缩率可观，但是遇到超大文件仍然无法根本解决问题。
大 key 拆解
这种需要对缓存数据中的作用和业务需求有全面的分析，分类讨论。抽象出基本信息，多 key信息存储。直接影响是原来获取一次，现在需要获取多次，极端情况下，有长尾请求的 bad case，可以根据具体情况优化逻辑，全局考虑下一般可接受。由于大 key 拆分，需要先改校验规则，再上线新逻辑。
综上，正对业务使用的大 key缓存需求，本质要求设计者和编程者懂业务，对缓存目标有一定的认知，了解缓存的利弊，使用时根据情况取舍粒度，全面思考和逻辑闭环。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0401e0128ae34f1b54de484feebecd3/" rel="bookmark">
			特斯拉财报看点：FSD拳打华为，Robotaxi 脚踢百度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大数据产业创新服务媒体
——聚焦数据 · 改变商业
特斯拉发最新财报了，这不仅是一份财务报告，更是一张未来发展的蓝图。在这份蓝图中，两个关键词格外耀眼——FSD（全自动驾驶系统）和Robotaxi（无人驾驶出租车）。
特斯拉，这个名字早已成为电动汽车和创新科技的代名词。然而，随着2024年第二季度财报的发布，我们发现，这家公司的野心远不止于此。它正以FSD和Robotaxi为先锋，准备在全球自动驾驶领域掀起一场革命。
特斯拉，实力在变弱？
当特斯拉的财报公之于众，我们看到了一家在电动汽车浪潮中乘风破浪的公司，同时也窥见了其背后隐藏的挑战和隐忧。
营收达到了255亿美元，同比增长2%，这一数字虽然在增长，但增速明显放缓。汽车总收入为198.78亿美元，却比去年同期下降了7%。产量和交付量分别下降了14%和5%，这在特斯拉的历史上是罕见的。这些数字背后，是市场竞争加剧和生产成本上升的双重压力。
将目光投向2023年，特斯拉全年总营收高达967.73亿美元，同比增长18.79%，全年GAAP净利润为79亿美元，但这一增长背后，现金流和研发费用的增长同样值得关注。年度现金流952亿元，研发费用近284亿元，这些投入为特斯拉的技术创新和市场扩张提供了动力，但也增加了其财务负担。
毛利率的下降至18%，运营利润同比减少了33%，净利润更是大幅下降了45%。这些数据的波动，不仅仅是数字游戏，它们反映了特斯拉在原材料成本上升、供应链挑战、以及市场策略调整等方面的实际困境。
特斯拉的实力真的在变弱吗？或许这只是一个暂时的低谷。但不可否认的是，特斯拉正面临着前所未有的挑战。从生产端的效率优化到市场需求的精准把握，从技术创新的持续投入到达成本控制的严格管理，特斯拉需要在多个方面进行自我革新和战略调整。
在自动驾驶技术日益成熟的今天，特斯拉的FSD和Robotaxi无疑将成为其突破重围的关键。但这些技术的商业化道路并非一帆风顺，特斯拉能否凭借这些创新再次证明自己的实力，值得我们持续关注。
FSD入华在即，华为、比亚迪们准备好了么？
随着特斯拉FSD技术的不断演进，其入华的脚步声愈发清晰。FSD，作为特斯拉自动驾驶技术的集大成者，以端到端自动驾驶和大模型机器学习为核心，正准备在中国这个全球最大的汽车市场掀起波澜。
FSD技术之所以备受瞩目，在于其端到端的自动驾驶能力，它通过神经网络实现从环境感知到决策控制的全过程，大幅减少了对传统编程代码的依赖。这种技术路径不仅提高了系统的适应性和灵活性，也更接近人类驾驶员的决策过程。
FSD的另一个显著优势是其通过海量真实驾驶数据进行自我优化的能力，这得益于特斯拉在全球范围内庞大的用户基础和车辆行驶数据，为其算法的迭代提供了源源不断的“燃料”。
中国作为全球最大的汽车市场和新能源汽车的领军者，对于任何一家有志于全球扩张的汽车制造商而言，都是一个不可忽视的战略要地。中国政府在自动驾驶领域的政策逐渐明朗，为FSD的入华提供了政策支持。然而，FSD入华也面临着数据合规、技术适配等挑战，这些问题的解决是FSD能否在中国市场上顺利落地的关键因素。
在中国，自动驾驶技术的发展同样迅猛。华为通过其强大的研发实力，不断推出新的自动驾驶解决方案；小鹏、理想、蔚来等造车新势力也在自动驾驶技术上取得了显著进展。
具体来看：
华为在自动驾驶技术上持续取得新进展，包括公布三项基础专利，涉及自动驾驶终端设备、控制智能汽车行驶方向的方法和装置，以及交通信号灯的识别方法等 。此外，华为还计划将激光雷达的成本降低至200美元甚至100美元，推动自动驾驶汽车的商业化进程 。
小鹏汽车以其XPILOT系统为核心，实现高速和城市全场景的智能辅助驾驶 。小鹏汽车首发停车场记忆泊车功能，并与滴滴出行达成战略合作 。
理想汽车在自动驾驶领域追赶智能化及自动驾驶技术，补齐短板，并计划在2025年实现高速及封闭道路的L4级自动驾驶 。
蔚来汽车的自动驾驶研发经历了从自研到合作，再到重回自研的过程。基于蔚来全栈自研的自动驾驶技术平台NT2.0，包含NIO Aquila超感系统、NIO Adam超算平台 。
与FSD相比，中国厂商的自动驾驶技术在某些方面可能更具地域适应性。例如，百度Apollo的自动驾驶系统就是针对中国复杂的路况进行了特别优化。然而，FSD的技术积累和数据优势同样不容小觑。在技术路线上，虽然存在纯视觉路线和融合感知路线的分歧，但FSD的纯视觉方案已经在国际上证明了其有效性。
FSD在中国市场的潜在挑战，主要包括技术适配、政策监管和消费者接受度。技术适配方面，FSD需要适应中国特有的交通环境和驾驶习惯。政策监管上，中国对于自动驾驶数据的合规性有严格的要求，FSD需要符合这些规定才能顺利推广。
随着FSD入华的脚步越来越近，中国自动驾驶市场将迎来新的变数。
Robotaxi也来了，百度慌不慌？
随着科技的飞速发展，Robotaxi这一概念逐渐从科幻走进现实，成为自动驾驶领域的又一风口。特斯拉的加入，无疑给这个领域带来了新的活力和竞争。
Robotaxi，即无人驾驶出租车，它通过集成先进的自动驾驶技术，提供无需人工干预的出行服务。特斯拉的Robotaxi计划，是其在自动驾驶领域野心的延伸。埃隆·马斯克曾宣布，特斯拉计划在2024年推出自己的Robotaxi服务，使用其FSD技术，实现车辆的全天候运营，并为车主带来收益分享。
这意味着车辆可以在不需要休息的情况下连续提供服务，同时车主可以通过共享车辆获得收益。
百度作为中国自动驾驶领域的先行者，其萝卜快跑项目已经在国内多个城市进行测试和运营。百度的萝卜快跑使用Apollo平台的自动驾驶技术，提供出行服务。百度在自动驾驶技术上的持续投入和萝卜快跑的运营经验，为其在Robotaxi领域的发展奠定了基础。
特斯拉的Robotaxi，和百度的萝卜快跑在技术路线和商业模式上存在差异。特斯拉依赖其自主研发的FSD技术，强调车辆的全自动驾驶能力，而百度则通过Apollo平台，整合了多种传感器和算法，实现自动驾驶。在商业模式上，特斯拉更侧重于车主的参与和收益分享，而百度则更注重平台的运营和服务提供。
此外，中国和美国在自动驾驶政策上的差异显著。美国部分州已经允许无人驾驶汽车在特定条件下进行测试和商业化运营，而中国则更加注重安全和合规性，对自动驾驶汽车的测试和商业化有严格的监管和审批流程。
这些政策差异直接影响了自动驾驶技术的商业化进程，企业需要在技术、安全和合规性上投入更多的资源和精力，以满足政策的要求。
特斯拉，这艘在电动汽车和清洁能源领域破浪前行的巨轮，正将其视野投向更远的海域——FSD和Robotaxi的推出，不仅是技术的革新，更是对未来出行方式的重新定义。在全球自动驾驶的版图上，特斯拉正以其独特的方式，绘制属于自己的宏伟蓝图。
然而，这条道路并非没有挑战。特斯拉财报所透露的增长放缓，以及FSD和Robotaxi面临的技术适配、政策监管和消费者接受度等问题，都是其必须面对和解决的课题。与此同时，华为、百度以及其他中国厂商的迅速崛起，也使得这场自动驾驶领域的竞争愈发激烈。
文：一蓑烟雨 / 数据猿
责编：凝视深空 / 数据猿
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cd87f56af97913efa54fae1c52d50d3/" rel="bookmark">
			C&#43;&#43; 《类与对象》（中下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ 《类与对象》（下） 赋值运算符重运算符定义 取地址运算符重载const成员函数 初始化列表格式练习 类型转换结束！！！！ 赋值运算符重 • 当运算符被⽤于类类型的对象时，C++语⾔允许我们通过运算符重载的形式指定新的含义。C++规
定类类型对象使⽤运算符时，必须转换成调⽤对应运算符重载，若没有对应的运算符重载，则会编
译报错。
运算符定义 运算符重载是具有特名字的函数，他的名字是由operator和后⾯要定义的运算符共同构成。和其他函数⼀样，它也具有其返回类型和参数列表以及函数体。
int operator+（int x,int y）;//声明 int operator+（int x,int y）//定义 { return x+y; } 但是关于运算符重载函数的声明与定义一定的要求：
// 重载为全局的⾯临对象访问私有成员变量的问题
// 有⼏种⽅法可以解决：
// 1、成员放公有
// 2、Date提供getxxx函数
// 3、友元函数
// 4、重载为成员函数
1.成员公有
#include&lt;iostream&gt; using namespace std; class Date { public: Date(int year = 1, int month = 1, int day = 1) { _year = year; _month = month; _day = day; } void Print() { cout &lt;&lt; _year &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cd87f56af97913efa54fae1c52d50d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b6eaed1380cc4110bf9fa0be2f791e3/" rel="bookmark">
			【C&#43;&#43;BFS算法】2192. 有向无环图中一个节点的所有祖先
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文涉及知识点 C++BFS算法
LeetCode2192. 有向无环图中一个节点的所有祖先 给你一个正整数 n ，它表示一个 有向无环图 中节点的数目，节点编号为 0 到 n - 1 （包括两者）。
给你一个二维整数数组 edges ，其中 edges[i] = [fromi, toi] 表示图中一条从 fromi 到 toi 的单向边。
请你返回一个数组 answer，其中 answer[i]是第 i 个节点的所有 祖先 ，这些祖先节点 升序 排序。
如果 u 通过一系列边，能够到达 v ，那么我们称节点 u 是节点 v 的 祖先 节点。
示例 1：
输入：n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]
输出：[[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]
解释：
上图为输入所对应的图。
节点 0 ，1 和 2 没有任何祖先。节点 3 有 2 个祖先 0 和 1 。节点 4 有 2 个祖先 0 和 2 。节点 5 有 3 个祖先 0 ，1 和 3 。节点 6 有 5 个祖先 0 ，1 ，2 ，3 和 4 。节点 7 有 4 个祖先 0 ，1 ，2 和 3 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b6eaed1380cc4110bf9fa0be2f791e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88ee4c9375c79e7f4e0d7c5133fd3504/" rel="bookmark">
			BUUCTF [MRCTF2020]Ezpop
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这道题对于刚接触到pop链的我直接把我整懵了，一边看着魔术方法一边分析
魔术方法可以看这里PHP 魔术方法 - 简介 - PHP 魔术方法 - 简单教程，简单编程 (twle.cn)
代码解析
经过以上的分析我们可以理一下解题思路：接收参数反序列化之前先触发wakeup方法，进行一些过滤防止ssrf，我们可以将source赋值为实例对象触发tostring方法
如果我们将str赋值为Test类的一个对象，因为读取不到source触发get魔术方法
再将Test类中的p赋值为Modify类的一个对象，对象被当作函数使用直接触发invoke
方法，从而包含文件用伪协议读取出来
链子大概就是这样:show-&gt;__wakeup-&gt;__tostring-&gt;Test-&gt;__get-&gt;Modify-&gt;__invoke-&gt;append-&gt;include
因为var是protect属性无法在类外进行访问，所以我们直接进行复赋值
直接上我的脚本了，先将三个类实例化出三个对象a,b,c 通过这三个对象来访问类内部的变量
$c-&gt;p = $a将Test中的p赋值为一个Modify对象，用来触发invoke方法 $b-&gt;source = new Show()因为通过$b这个对象进行访问的，所以需要source赋值一个新的Show对象，用来触发__toString方法 $b-&gt;source-&gt;str = $c中$b-&gt;source已经成为一个新的Show实例对象，通过该对象访问str，为其赋值为$c(Test类的对象),又因为Test类中访问不到source资源从而触发get方法 最后进行url编码是因为protected属性的变量会输出一些不可见的字符，直接复制显示就是乱码无法构成成功攻击，进行一次url编码即可，浏览器会自动解码的
class Modifier { protected $var="php://filter/read=convert.base64-encode/resource=flag.php"; public function append($value){ include($value);	//包含flag.php } public function __invoke(){ $this-&gt;append($this-&gt;var); } } class Show{ public $source; public $str; public function __toString(){ return $this-&gt;str-&gt;source;	//将Test实例化的对象给str，在Test中不存在source，此处调用__toString时触发__get方法 } public function __wakeup(){ if(preg_match("/gopher|http|file|ftp|https|dict|\.\./i", $this-&gt;source)) { echo "hacker"; $this-&gt;source = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88ee4c9375c79e7f4e0d7c5133fd3504/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a75f06e3e5bc5a754ad9f67f23f8a7b/" rel="bookmark">
			JavaSE--基础语法--继承和多态(第三期)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.继承 1.1我们为什么需要继承? 首先，Java中使用类对现实世界中实体来进行描述，类经过实例化之后的产物对象，则可以用来表示现实中的实体，但是 现实世界错综复杂，事物之间可能会存在一些关联，那在设计程序是就需要考虑。
例如猫和狗：
public class Dog { String name; int age; float weight; public void eat(){ System.out.println(name+"正在吃饭！"); } public void sleep(){ System.out.println(name+"正在睡觉！"); } public void bark(){ System.out.println(name+"正在汪汪汪！"); } } public class Cat { String name; int age; float weight; public void eat(){ System.out.println(name+"正在吃饭！"); } public void sleep(){ System.out.println(name+"正在睡觉！"); } public void bark(){ System.out.println(name+"正在喵喵喵！"); } } 我们可以看到上面的代码我们可以知道，猫和狗他们有一些共性代码例如eat和sleep,这时我们就可以想到它们都是动物我们是否有什么方法可以将使用一个类方法它们放在一起。确实我们这就就可以用到我们的继承方法，因为它们都是动物这时我们就可以定义一个Animal作为父类用于存放相同共性的代码，之后我们Dog和Cat就只需要继承Animal这时就达到了简便，从而实现代码的复用。
1.2继承的概念 继承(inheritance)机制：是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加新功能，这样产生新的类，称派生类。继承呈现了面向对象程序设计的层次结构， 体现了 由简单到复杂的认知过程。继承主要解决的问题是：共性的抽取，实现代码复用。
继承关系如图所示：
这里我们可以看出继承其实就是父类和子类的关系，当我们父类中有的代码时子类可以继承，子类只需要关心自已特有的特性。
继承的意义：实现代码的复用。
1.3继承的语法 在Java中类之间的继承需要我们用到extends关键字。
例如：上面的猫和狗我们就可以用继承关系进行eat和sleep方法的复用。
public class Animal { String name; int age; public void eat(){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a75f06e3e5bc5a754ad9f67f23f8a7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e26f4949778c358e4d18ad2e43872aae/" rel="bookmark">
			软件测试中的压力测试和性能测试区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		压力测试和性能测试是软件测试中两种重要的测试类型，它们都旨在评估软件在不同条件下的表现，但侧重点和目的有所不同。
压力测试（Stress Testing）定义：
压力测试是一种测试方法，用于确定软件在极端条件下的行为。这种测试通常在软件系统运行在或接近其最大操作限制时进行，目的是发现软件在高负载下可能出现的问题。
主要用途：
1. 确定极限：通过模拟高负载条件，确定软件能够处理的最大用户数或数据量。
2. 发现性能瓶颈：识别在高负载下可能导致性能下降的系统组件。
3. 评估稳定性：测试软件在持续高负载下是否能够稳定运行，不出现崩溃或数据丢失。
4. 安全测试：模拟攻击或异常流量，评估软件的安全性和抵御攻击的能力。
5. 资源消耗分析：分析在高负载下系统资源（如CPU、内存、磁盘I/O）的消耗情况。
6. 故障恢复测试：测试软件在压力条件下的故障恢复能力，确保系统能够从异常状态中恢复。
性能测试（Performance Testing）定义：
性能测试是一种测试方法，用于评估软件在正常和峰值负载条件下的性能。它关注的是软件的响应时间、吞吐量、资源利用率等性能指标。
主要用途：
1. 性能基准：建立软件在不同负载下的性能基准，用于后续的性能比较和优化。
2. 用户体验评估：确保软件在用户可接受的响应时间内运行，提升用户体验。
3.系统优化：识别影响性能的关键因素，为系统优化提供依据。
4. 资源规划：评估系统资源（如服务器、网络带宽）的需求，为系统扩展提供参考。
5. 负载预测：预测软件在不同负载水平下的表现，为系统设计和扩展提供数据支持。
6. 可靠性测试：评估软件在长时间运行或高负载条件下的可靠性和稳定性。
7. 容量规划：确定软件系统的最大处理能力，为未来的扩展和升级提供决策依据。
8. 合规性测试：确保软件满足行业标准或法规要求的性能标准。
区别与联系
测试目的：压力测试更关注软件在极端条件下的表现和稳定性，而性能测试则关注软件在正常和峰值负载下的表现。
测试条件：压力测试通常模拟超出正常操作范围的高负载条件，性能测试则模拟正常和预期的负载条件。
测试结果：压力测试的结果可能包括系统崩溃、性能急剧下降等极端情况，而性能测试的结果则更关注响应时间、吞吐量等性能指标。
通过结合压力测试和性能测试，可以全面评估软件在不同负载条件下的表现，确保软件在实际运行中能够满足用户需求和系统要求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21713924f76104571d26fa217a2c1681/" rel="bookmark">
			godot新建项目及设置外部编辑器为vscode
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、新建项目 初次打开界面如下所示，点击取消按钮先关闭掉默认弹出的框
点击①新建弹出中间的弹窗②中填入项目的名称 ③中设置项目的存储路径，点击箭头所指浏览按钮，会弹出如下所示窗口 根据图中所示可以选择或新建自己的游戏存储路径，最后点击选择此文件夹将保存选择！
点击④箭头所指的创建并编辑，看到如下图所示的界面则代表项目创建成功！ 二、链接外部代码编辑器VScode 首先请自行下载并安装vscode编辑器，这个不在本教程的范围！
开发游戏我们免不了要编写代码，俗活说：“工欲善其事必先利其器”，godot默认自带的代码编辑器没有代码高亮及代码提示功能，那么这里我就需要借助外部代码编辑器VScode！
选择菜单中的编辑器，点击下拉菜单中的第一项编辑器设置，会弹出如下界面
在左侧菜单中找到文本编辑器大类，再找到其中的二级菜单外部，点击选中，会看到右侧内容。
①处的启用勾选
②处是VScode的编辑器的完整路径，vscode的完整路径可以在桌面找到快捷方式，鼠标右键属性即可看到如下图所示，把目标中的路径复制到这里即可！记得开始和结束的位置不需要双引号！
③处的值我们不需要做任何更改
至此，点击最底部的关闭按钮即可设置成功！
左侧文件系统箭头所指的空白处点击鼠标右键会看见所示菜单，选择新建脚本，我们新建一个脚本文件测试是否可以正常链接到外部编辑器！
弹出如上图所示的窗口我们暂时不做任何修改，直接点击创建，项目根目录即可出现一个new_script.gd的文件！
鼠标右键在新建的文件上点击，弹出菜单栏，选择打开，这里不出意外则可以成功启动vscode编辑器！
但是，要实现代码高亮还需要安装godot-tools插件，可以直接在vscode的插件中心中搜索安装！
至此，我们本节内容就全部完成了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7a7425be1ac0b079470ea63b7f379e1/" rel="bookmark">
			Java-根据前缀-日期-数字-生成流水号（不重复）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎈边走、边悟🎈迟早会好
小伙伴们在日常开发时可能会遇到的业务-生成流水号，在企业中可以说是比较常见的需求，
可以采用"前缀+日期+数字"的方式（ps:此方式是需要用到缓存的）
前缀：为了更好的标识这个流水号是属于哪种类型；
日期：为了防止重复；
数字：为了表示当前的流水所处序号。
SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd"); //todo 替换自己想要的前缀 String code = "xicui-" + df.format(new Date()); //模糊查询当前最大的编号 String maxCode = baseMapper.maxRoundCode(code); String newCode = null; if (StringUtils.isEmpty(maxCode)) { newCode = code + "-01"; } else { //切割字符串，取查到编号的最后两位 String getMaxCode = maxCode.substring(maxCode.length()-2,maxCode.length()); newCode = code + "-"+getNum(getMaxCode); } 编号生成的方法-直接复制即可 //编号生成 public static String getNum(String code) { String roundCode = "-01"; if (code != null &amp;&amp; !code.isEmpty()) { int intCode = Integer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7a7425be1ac0b079470ea63b7f379e1/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/108/">«</a>
	<span class="pagination__item pagination__item--current">109/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/110/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>