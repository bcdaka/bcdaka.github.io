<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b42787e58e3d7e655b79b949faffcefa/" rel="bookmark">
			java web 项目结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java Web项目的基本结构通常如下所示：
核心目录结构： Web Root (也称为 Web Content 或者直接作为项目根目录):
这个目录是Web应用对外暴露的部分，其中的内容可以直接被客户端浏览器访问。 *.html, *.jsp, .jspx 等动态或静态网页文件。静态资源，如：*.css, .js, 图片文件 (.png, *.jpg, *.gif) 等。 WEB-INF:
WEB-INF 目录位于Web应用的根目录下，但其内部的内容不能被客户端直接访问。 classes: 存放编译后的Java类文件 (.class)，这些是项目中所有Java源代码经过编译后产生的字节码文件。lib: 存放项目所需的第三方库文件（.jar 和 .war 文件）。web.xml: Java Web应用程序的部署描述符文件，定义Servlet、Filter、Listener等组件的配置以及初始化参数、安全约束等内容。 IDE特定结构（如 IntelliJ IDEA 或 Eclipse）: .idea: IntelliJ IDEA项目相关配置文件目录。out: IntelliJ IDEA的编译输出目录，对应Eclipse中的bin或build/classes目录。src: 源代码目录，包含Java源代码文件及可能的资源文件。.iml: IntelliJ IDEA的模块文件，记录模块配置信息。pom.xml: 如果是Maven项目，则会有此文件来管理项目依赖、构建过程等。 Maven项目结构： 对于使用Maven构建工具的Java Web项目，除了上述核心Web目录结构外，还有：
src/main/java: 存放Java源代码。src/main/resources: 存放资源配置文件，如.properties, .xml等。src/main/webapp: 对应Web应用的Web Root目录。pom.xml: Maven项目的核心配置文件。 构建产物： 当项目被打包成.war文件时，最终的结构会将所有必需的资源和类文件整合在一起，并按照上述结构组织，以便于部署到Web容器（如Tomcat、Jetty等）上运行。
总结来说，Java Web项目的结构是一个层次分明的布局，它确保了开发、编译、部署和运行的有序进行，同时也方便了开发者对项目进行管理和维护。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ddfa62e6b65a449d1ea0350b54d5713/" rel="bookmark">
			国内AI领域的新星：Kimi与GPT的较量，谁主沉浮？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期，国产大型人工智能模型Kimi频繁成为众多行业领袖讨论的焦点。这些来自不同领域的专家和领袖们，似乎都在对Kimi的性能和能力给予高度评价。在这两年国产AI模型的快速发展中，尽管市场上涌现出了许多新面孔，但真正能够在技术和应用上达到顶尖水平的模型并不多见。今天，我们就来深入探讨一下Kimi与GPT之间的竞争优势和独特之处。
Kimi官网：Kimi -帮你看更大的世界
1. Kimi的核心功能 1.1 阅读文件 根据Kimi Chat的官方资料，该智能助手拥有高达20万字的上下文输入处理能力。这意味着您可以轻松地将整部PDF格式的小说或书籍导入其中，无需担心篇幅限制。
从Kimi返回的结果来看还是相当准确的，而且处理速度相当的快，点个赞！
1.2 找资料 Kimi在资料查找方面的能力同样令人瞩目，它能够高效地结合搜索结果，为用户提供更为全面和详尽的回答。
比如我想知道汽车发展史的历史，它就会去搜索资料出来，再总结好给我。
2. Kimi与GPT的比较 Kimi的设计灵感汲取了GPT-3.5和GPT-4.0等先进语言模型的精髓，但在功能与应用层面，它有着自己独到的创新之处。
GPT-3.5：作为OpenAI在自然语言处理领域的一座里程碑，其能力卓越，能生成连贯的文本，回答问题，撰写文章，甚至创作诗歌。它在语言理解方面表现尤为出色，然而，它并不具备直接解析文件或网页内容的能力，也缺乏搜索功能。
GPT-4.0：作为OpenAI最新一代的语言模型，它代表着深度学习在自然语言处理领域的最新高度。作为GPT系列的一员，GPT-4.0不仅继承并发展了前代模型的核心特性，更在多个方面进行了创新和改进，使其在处理复杂问题和创造性任务时表现出更加卓越的能力。
Kimi：则结合了GPT系列模型的语言处理能力，并在此基础上增加了文件解析和网页内容提取的功能。更为出色的是，Kimi还具备搜索能力，使其在回答用户问题时能够提供更为丰富和全面的信息。Kimi的设计更加注重用户交互和信息处理，而不仅仅是文本生成。值得一提的是，Kimi还能够处理用户上传的文件，这在处理特定任务时显得尤为实用。
鉴于GPT-3.5无法联网，我们在此不将其纳入比较范围。接下来，我们将通过测试来展示Kimi与GPT-4.0在读取网页方面的表现，看看它们各自的优势所在。
2.1 Kimi 速度很快，表现的也很好！
2.2 GPT-4 未使用插件：
使用插件后：
未使用插件增强的GPT-4在文章阅读方面显得力不从心。然而，只要插件运用得当，GPT-4便拥有无尽的潜力和可能性，能够在各种任务中发挥出令人瞩目的表现。
3. 三个大模型的优劣 3.1 Kimi 优点 文件和网页解析：Kimi具备出色的文件解析和网页内容理解能力，这是GPT系列模型所不具备的独特能力。
搜索能力：Kimi具备实时搜索功能，能够迅速为用户提供最新、最准确的信息和数据。
多语言对话：Kimi精通中文和英文对话，能够轻松满足不同语言用户的需求。
缺点 通用性有限：与GPT-3.5或GPT-4等通用性更强的模型相比，Kimi在处理广泛主题时的能力可能相对有限。
适应性：由于Kimi可能不像更大、更复杂的模型那样灵活，因此在适应新任务或未知问题时可能会面临一定的挑战。
知识更新：相较于GPT-3.5和GPT-4等模型，Kimi的知识库可能相对较小且更新频率较低，这可能会影响其提供最新信息的能力。
3.2 GPT-3.5 优点 广泛的知识覆盖：GPT-3.5拥有庞大的知识库，能够轻松应对多种主题和问题，展现出强大的知识广度。
卓越的语言理解能力：它在理解和生成自然语言方面表现出色，能够精准捕捉文本中的含义和语境。
多样的应用场景：GPT-3.5的适用性广泛，无论是文本生成、对话系统还是内容创作，都能发挥出其强大的潜力。
缺点 信息时效性：由于GPT-3.5的训练数据只涵盖到特定时间点，因此它无法获取到最新的信息，这在某些场景下可能会受到限制。
误解和错误：在处理复杂或模棱两可的问题时，GPT-3.5可能会产生误解或错误，需要用户在使用时加以留意和判断。
资源消耗：作为一个大型模型，GPT-3.5在运行时可能需要较多的计算资源，这可能会对系统性能造成一定影响。
3.3 GPT-4 优点 更先进的算法：作为更新的模型，GPT-4在理解和生成语言方面展现出更加精准和高效的能力，为用户带来更为出色的体验。
更广泛的知识与深入理解：GPT-4不仅拥有更广泛的知识覆盖，还具备更深入的理解能力，能够更准确地回答各种问题，为用户提供更全面的信息。
更出色的上下文理解：GPT-4擅长于理解长篇的上下文，能够提供更连贯和准确的回答，使用户在交流过程中更加顺畅自如。
丰富的插件支持：GPT-4可以通过集成的插件来进一步扩展其功能，满足用户多样化的需求。这些插件为GPT-4赋予了更多的可能性，使其能够执行一些原本无法直接进行的操作。目前，插件商店已经拥有上千款插件供用户选择和使用。
这些插件赋予了GPT-4多样化的功能，使其具备以下显著优点：
实时访问最新信息：插件使得GPT-4能够间接访问互联网，从而迅速获取最新的信息和数据。这对于回答关于近期事件或当前趋势的问题尤为关键，确保用户得到的是最新、最准确的答案。
功能范围的大幅扩展：通过集成各种插件，GPT-4能够执行原本无法胜任的任务，如网页内容摘要生成、特定信息搜索以及数据提取等。这不仅极大地拓宽了它的应用范围，还为用户提供了更多元化的服务选择。
回答相关性与准确性的提升：由于插件能够实时获取信息，GPT-4在回答用户查询时能够提供更相关、更准确的答案。特别是在处理特定查询或需要最新数据的情况下，这一优势尤为突出。
用户体验的显著改善：插件的引入使得GPT-4能够为用户提供更加全面、便捷的服务。用户无需在多个平台之间切换，即可在一个平台上获得多样化的帮助，从而大大提高了用户体验。
查询处理能力的多样化：借助插件，GPT-4能够处理更多类型的问题，包括那些需要外部数据支持或特定格式回答的查询。这使得它在处理复杂问题时更具灵活性和适应性。
学习与研究能力的增强：对于学术研究或深入学习而言，插件为GPT-4提供了强大的支持。它能够快速提供最新的研究资料、统计数据和其他相关信息，帮助用户高效地进行学习和研究工作。
正如上述测试中展示的阅读文章功能，未使用插件前GPT-4无法胜任此任务，但加入插件后却能轻松完成。这一实例充分展示了插件在增强GPT-4功能方面的巨大潜力。
缺点 信息更新限制：与GPT-3.5相似，GPT-4的知识库也受限于特定时间点的数据，这可能导致其在处理涉及最新信息的问题时存在局限性。
潜在的偏见问题：尽管GPT-4在算法和数据处理方面进行了诸多改进，但仍然存在数据偏见的风险，这可能影响其在某些情况下的准确性和公正性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ddfa62e6b65a449d1ea0350b54d5713/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b36a93ecf6efd2b6eb58130ebd205abd/" rel="bookmark">
			前端流程图框架11个：开发组态图、思维导图、拓扑图必备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、流程图的前端开发都是如何实现的 在前端开发中，实现流程图通常涉及以下几个方面：
HTML 结构：使用 HTML 标签来定义流程图的结构，如使用 &lt;div&gt; 元素表示节点，使用 &lt;svg&gt; 元素表示连接线等。CSS 样式：使用 CSS 样式来定义流程图的外观，包括节点的样式、连接线的样式、文本的样式等。可以使用 CSS 属性来设置颜色、大小、边框等样式属性。JavaScript 交互：使用 JavaScript 来实现流程图的交互功能，如节点的拖拽、连接线的绘制、文字编辑等。可以使用原生 JavaScript 或者流程图框架提供的 API 来实现这些功能。 数据绑定：将流程图的数据与界面进行绑定，可以使用 JavaScript 对象或者 JSON 格式来表示流程图的数据结构，并通过 JavaScript 代码将数据与界面元素进行关联。事件处理：处理用户交互事件，如节点的点击、连接线的拖动等。可以使用 JavaScript 的事件监听机制来处理这些事件，并根据事件触发的情况进行相应的操作。 具体实现流程图的方式和工具可以根据具体需求选择，可以使用原生的 HTML、CSS 和 JavaScript 进行开发，也可以使用流程图框架来简化开发过程。流程图框架通常会提供一些封装好的组件和 API，使开发者可以更方便地创建和操作流程图。
这里面最核心的还是JavaScript，网上有很多开源的js框架，我们拿来即用就可以，无需从头开始。
二、前端流程图框架举例 以下是一些常用的前端流程图框架：
Mermaid：Mermaid 是一个用于绘制流程图、时序图、甘特图等的纯 JavaScript 库。它使用简单的文本语法来定义图表结构，支持多种类型的流程图，易于集成到网页中。Draw.io：Draw.io 是一个在线的流程图绘制工具，提供了丰富的图形元素和布局选项，支持导入和导出多种文件格式，可以直接在浏览器中创建和编辑流程图。 bpmn-js：bpmn-js 是一个基于 JavaScript 的 BPMN 2.0 流程图渲染和编辑工具，可以在浏览器中显示和编辑 BPMN 流程图，支持拖拽、缩放、导入和导出等功能。JointJS：JointJS 是一个基于 JavaScript 的图形框架，可以用于创建各种类型的图表，包括流程图、组织结构图、网络拓扑图等。它提供了丰富的图形元素和交互功能，支持自定义样式和事件处理。mxGraph：mxGraph 是一个用于绘制图表和图形界面的 JavaScript 库，支持流程图、组织结构图、网络拓扑图等多种类型的图表。它提供了丰富的图形元素和布局选项，支持拖拽、缩放、导入和导出等功能。 GoJS：GoJS 是一个功能强大的 JavaScript 流程图和图表库，提供了丰富的图形元素和交互功能，支持自定义样式和事件处理，可用于创建各种类型的流程图和图表。D3.js：D3.js 是一个用于创建数据可视化的 JavaScript 库，可以用于绘制各种类型的图表，包括流程图。它提供了强大的数据绑定和转换功能，可以根据数据动态生成流程图。meta2d.js：国产开源的web可视化绘图引擎，可以用在支持mqtt协议的iot物联网平台的scada场景–还支持设备工艺流程组态、大屏、流程图、拓扑图、脑图、动画、echarts、websocket，http通信等。 Vis.js：Vis.js 是一个基于 JavaScript 的可视化库，提供了多种类型的图表和网络可视化组件，包括流程图。它支持交互功能和自定义样式，可以用于创建复杂的流程图和图表。Cytoscape.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b36a93ecf6efd2b6eb58130ebd205abd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/915501e70edbeddb3ca166f99273a2b0/" rel="bookmark">
			基于Python的车牌识别系统的实现 毕业论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Python的车牌识别系统的实现
摘要
随着我国经济的飞速发展，越来越多的家庭拥有私家车，甚至一个家庭有多台私家车，这也为我国的交通增添了许多压力。车牌识别系统在我国有着十分广泛的应用。在我国交警部门，车牌识别技术的使用尤为广泛，各个路口和高速公路上的探头不仅仅是简单的监控探头还有很多的测速探头，而一旦发现违章就要通过车牌识别技术来对违章车辆的车牌进行捕捉，这大大降低了交警的工作量。而目前我国在车牌识别系统方面还存在一些缺陷。例如，在一些恶劣天气下会使得车牌识别不准确。并且，由于我国车牌有汉字的部分，而汉字一些文字较为繁琐，例如：赣字车牌；在对其进行二值化处理后容易造成笔画模糊。因此，本文将会进一步对基于Python的车牌识别系统的实现做进一步的研究。
本文基于Python 语言设计了一套车牌识别系统,在本系统中充分利用了计算机视觉类库Opencv对图像的处理功能。在本文中按照对车牌图像的预处理、车牌定位、字符分割以及字符识别的顺序进行处理。在图像预处理方面采用了图像灰度化，在对图像进行边缘检测采用了Sobel算子，使用了图像二值化对图像进行分割，并采用了高斯模糊方法对图像进行模糊处理。同时使用水平分割，垂直分割和车牌大小归一化技术对预处理后的图像进行定位。最后，本文对已经完成的车牌识别系统进行了实验，实验结果表明该系统可以正确对车牌号码进行识别。
Abstract
With the rapid development of China's economy, more and more families own private cars, and even a family has multiple private cars, which also adds a lot of pressure to China's transportation. License plate recognition system has a very wide range of applications in China. In China's traffic police department, the use of license plate recognition technology is particularly extensive, the probes on each intersection and highway are not only simple monitoring probes and many speed probes, and once the violation is found, it is necessary to capture the license plate of the illegal vehicle through the license plate recognition technology, which greatly reduces the workload of the traffic police.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/915501e70edbeddb3ca166f99273a2b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfd66e5cdec31e8ee4db446ec20113b6/" rel="bookmark">
			GitHub Copilot 支持 IntelliJ IDEA啦，插件装起来！，蚂蚁金服产品岗面试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装重启之后就可以在工具栏看到安装好的Copilot
然后登陆GitHub账号，同意相关条款
那说了那么久，这款号称可以自动编码的插件具体使用效果如何呢？就让TJ君带你领略一下或许是未来的编码趋势与潮流：
例如在项目里新建了test类，Copilot马上就会给一个建议生成的主体
此时只需要轻按一下tab键，就可以接受建议自动生成，无需手打这段代码。
同样的如果输入了一个函数标题，也会自动出现推荐的函数主体内容，一样是用tab键接受。
当然，Copilot不止会给出单一的自动编码推荐，用户可以使用Alt+]或者Alt+[来逐个切换不同的推荐，就像逐个挑选一件件商品一般，选中之后轻按一下tab键使用即可。
而通过Alt+Enter可以直接打开各种推荐的列表，便于查找。
至于TJ君之前梦想的根据注释自动生成代码，有一个前提就是必须输入的注释能让机器看懂，也就是说，需要英文注释。当输入中文注释，Copilot不一定看得懂含义，毕竟中文可是博大精深滴。。。
那如果小伙伴的英语水平不错，Copilot还真的能节省不少时间，例如当用户写了如下一段关于给图像增加边框的注释：
// find all images without alternate text
// and give them a red border
void process() {
Copilot会自动生成相应的功能代码，感觉比自己写的还顺畅：
除了上述Alt+]、Alt+[、Alt+Enter，最常见的操作还包括使用Esc拒绝推荐和Alt + \触发关联建议。这里TJ君提到的操作模式都是基于windows操作，如果使用MAC的小伙伴要注意将ALT键换成Option键就可以了。
小编13年上海交大毕业，曾经在小公司待过，也去过华为、OPPO等大厂，18年进入阿里一直到现在。
深知大多数初中级Java工程师，想要提升技能，往往是自己摸索成长，但自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年最新Java开发全套学习资料》送给大家，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友，同时减轻大家的负担。
由于文件比较大，这里只是将部分目录截图出来，每个节点里面都包含大厂面经、学习笔记、源码讲义、实战项目、讲解视频
如果你觉得这些内容对你有帮助，可以添加下面V无偿领取！（备注Java）
总结 我个人认为，如果你想靠着背面试题来获得心仪的offer，用癞蛤蟆想吃天鹅肉形容完全不过分。想必大家能感受到面试越来越难，想找到心仪的工作也是越来越难，高薪工作羡慕不来，却又对自己目前的薪资不太满意，工作几年甚至连一个应届生的薪资都比不上，终究是错付了，错付了自己没有去提升技术。
这些面试题分享给大家的目的，其实是希望大家通过大厂面试题分析自己的技术栈，给自己梳理一个更加明确的学习方向，当你准备好去面试大厂，你心里有底，大概知道面试官会问多广，多深，避免面试的时候一问三不知。
大家可以把Java基础，JVM，并发编程，MySQL，Redis，Spring，Spring cloud等等做一个知识总结以及延伸，再去进行操作，不然光记是学不会的，这里我也提供一些脑图分享给大家：
希望你看完这篇文章后，不要犹豫，抓紧学习，复习知识，准备在明年的金三银四拿到心仪的offer，加油，打工人！
-1711133556864)]
[外链图片转存中…(img-4x4hsv6h-1711133556865)]
希望你看完这篇文章后，不要犹豫，抓紧学习，复习知识，准备在明年的金三银四拿到心仪的offer，加油，打工人！
本文已被CODING开源项目：【一线大厂Java面试题解析+核心总结学习笔记+最新讲解视频+实战项目源码】收录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff576495249f94ab10c805a64340996d/" rel="bookmark">
			前端HTML进阶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML进阶 【一】表格标签的使用方法 &lt;table&gt;标签定义了HTML表格 一个HTML表格由一个&lt;table&gt;元素和一个或多个&lt;tr&gt;、&lt;th&gt;和&lt;td&gt;元素组成 &lt;tr&gt;：定义表格行 &lt;th&gt;：定义表格标题 &lt;td&gt;：定义表格单元格 ​属性 ​ width：表格的宽度 固定值或者百分比
height：高度
align：表格水平对齐方向 取值：left，center，right
border：边框粗细
bordercolor：边框颜色
bgColor：表格背景色
background：背景图片 URL
cellpadding：单元格边线到内容间的距离（填充距离）
cellspacing：单元格与单元格之间的距离（间距）
rules：合并单元格边框线 取值：all
注意：rules 兼容行不好，用 CSS 取代
&lt;tr&gt; 属性，行标记
bgcolor：行的背景色
height：行高
align：行中的文字水平居中 left center rught
valign：行中的文字垂直居中 top（上） moddle（中） bottom（下）
&lt;td&gt; &lt;th&gt;
&lt;td&gt; 普通单元格
&lt;th&gt; 标题单元格，居中加粗显示
widgh：宽度
height：高
bgcolor：背景色
background：背景图片
align：水平对齐
valign：水质对齐
rowspan：上下单元格合并， 合并的属性放在第一个单元格中
colspan：左右单元格合并， 合并时，有增有减
【二】创建表格 【1】创建表格的基本语法： &lt;table&gt; &lt;tr&gt; &lt;td&gt;..&lt;/td&gt; &lt;td&gt;...&lt;/td&gt; &lt;td&gt;...&lt;/td&gt; .... &lt;/tr&gt; ... &lt;/table&gt; table 用于定义一个表格标签。
tr 标签用于定义表格中的行， 必须嵌套在 table标签中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff576495249f94ab10c805a64340996d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9d687fbb877521f538144103ecc5215/" rel="bookmark">
			（MATLAB）第二十一章 Simulink仿真设计初步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Simulink是MATLAB的重要组成部分，可以非常容易地实现可视化建模，并把理论研究和工程实践有机地结合在一起，不需要书写大量程序，只需要使用鼠标和键盘对已有模块进行简单的操作和设置。
21.1 Simulink简介 Simulink是MATLAB软件的扩展，它提供了集动态系统建模、仿真和综合分析于一体的图形用户环境，是实现动态系统建模和仿真的一个软件包。它与MATLAB的主要区别在于，其与用户的交互接口是基于Windows的模型化图形输入，其结果是用户可以把更多的精力投入到系统模型的构建，而非语言的编程上。
Simulink 提供了大量的系统模块，包括信号、运算、显示和系统等多方面的功能，可以创建各种类型的仿真系统，实现丰富的仿真功能。用户也可以定义自己的模块，进一步扩展模型的范围和功能，以满足不同的需求。为了创建大型系统，Simulink 提供了系统分层排列的功能的设计，在Simulink中可以将系统分为从高级到低级的几个层次，每层又可以细分几个部分，每层系统构建完成后，将各层连接起来构成一个完整的系统。模型创建完成之后，可以启动系统的仿真功能分析系统的动态特性，Simulink内置的分析工具包括各种仿真算法、系统线性化、寻求平衡点等，仿真结果可以以图形的方式显示在示波器窗口，以便于用户观察系统的输出结果；Simulink也可以将输出结果以变量的形式保存起来，并输入到MATLAB工作空间中以完成进一步的分析。
Simulink 可以支持多采样频率系统，即不同的系统能够以不同的采样频率进行组合，可以仿真较大、较复杂的系统
1．图形化模型与数学模型间的关系 现实中每个系统都有输入、输出和状态3个基本要素，它们之间随时间变化的数学函数关系即数学模型。图形化模型也体现了输入、输出和状态随时间变化的某种关系。只要这两种关系在数学上是等价的，就可以用图形化模型代替数学模型。
2．图形化模型的仿真过程 Simulink的仿真过程包括以下几个阶段。
(1）模型编译阶段 Simulink 引擎调用模型编译器，将模型翻译成可执行文件。其中编译器主要完成以下任务。
→计算模块参数的表达式，以确定它们的值。
→ 确定信号属性（如名称、数据类型等）。
→传递信号属性，以确定未定义信号的属性。
→优化模块。
→展开模型的继承关系（如子系统）。
→确定模块运行的优先级。
→确定模块的采样时间。
(2）连接阶段 Simulink 引擎按执行次序创建运行列表，初始化每个模块的运行信息。
(3）仿真阶段 Simulink 引擎从仿真的开始到结束，在每一个采样点按运行列表计算各模块的状态和输出。该阶段又分成以下两个子阶段。
→初始化阶段：该阶段只运行一次，用于初始化系统的状态和输出。
→迭代阶段：该阶段在定义的时间段内按采样点间的步长重复运行，并将每次的运算结果用于更新模型。在仿真结束时获得最终的输入、输出和状态值。
21.1.1 Simulink模型的特点 （1）仿真结果的可视化 （2）模型的层次性 （3）可封装子系统 21.1.2 Simulink模型的数据类型 Simulink在仿真开始之前和运行过程中会自动确认模型的类型安全性，以确保该模型产生的代码不会上溢或者下溢。
1. Simulink支持的数据类型 Simulink支持所有的MATLAB内置的数据类型，除此之外，Simulink还支持布尔类型，绝大多数模块都默认double类型的数据，但有些模块需要布尔类型和复数类型。
2. 数据类型的统一 若模块的输入输出支持的数据类型不相同，则在仿真时会弹出错误提示对话框，告知冲突的信号和端口，此时可以尝试在冲突的模块间插入DataTypeConversion（数据类型转换）模块来解决。示例如下：
3. 复数类型 Simulink默认的信号值都是复数，但在实际问题中需要处理复数信号。在Simulink中通常用Real-Image to Complex模块和Magnitude-Angle to Complex模块来建立处理复数信号的模型。如下图示例所示：
21.2 Simulink模块库 21.2.1 常用模块库 1.Commonly Used Blocks库（常用模块库） 模块名
功能
Bus Creator
将输入信号合并成向量信号
Bus Selector
将输入向量分解成多个信号，输入只接收从Mux和BusCreator输出的信号
Constant
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9d687fbb877521f538144103ecc5215/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5521324c165597bedd4666eb3dbeafe4/" rel="bookmark">
			Kafka批量消费
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Spring Kafka中，使用@KafkaListener注解处理批量信息时，首先需要开启批量监听模式，并配置相应的consumer参数来控制批量消费行为。以下是配置和处理批量消息的基本步骤：
配置Kafka消费者工厂：
设置batchListener属性为true，使@KafkaListener支持批量消费。
@Bean public ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; kafkaListenerContainerFactory() { ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; factory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConsumerFactory(consumerFactory()); // 开启批量监听模式 factory.setBatchListener(true); // 其他相关配置，比如并发度、错误处理等 return factory; } 配置消费者参数：
设置ConsumerConfig.MAX_POLL_RECORDS_CONFIG，指定每次poll请求从Kafka服务器获取的最大记录数。并且关闭offset自动提交enable-auto-commit: false
# application.properties 或 application.yml spring: kafka: consumer: bootstrap-servers: localhost:9092 group-id: my-group max-poll-records: 100 # 其他配置项，如enable-auto-commit, auto-offset-reset等 编写批量处理方法：
定义一个方法，其参数是一个包含多条消息的列表，@KafkaListener注解下的方法将会接收到批量的消息。
@KafkaListener(topics = "my-topic") public void processMessages(List&lt;ConsumerRecord&lt;String, String&gt;&gt; records, Acknowledgment acknowledgment) { try { // 处理批量消息 for (ConsumerRecord&lt;String, String&gt; record : records) { // 对每条消息进行处理 } // 成功处理后手动提交偏移量 acknowledgment.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5521324c165597bedd4666eb3dbeafe4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5751ef89573911fb1497c6e2f5721306/" rel="bookmark">
			QT学习之路——Qt QMySQL driver not loaded问题（笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题：qt连接数据库时出现以下情况： QSqlDatabase: QMYSQL driver not loaded（mysql驱动不能加载）
QSqlDatabase: available drivers: QSQLITE QMYSQL QMYSQL3 QODBC QODBC3 QPSQL QPSQL7
这是有可用的mysql驱动，但是不能加载
二、分析问题原因 2.1、 若Mysql数据库的位数与Qt开发软件的位数都是64位（或者32位），这种情况一般不会出现连接不上数据库 2.2、若Mysql数据库的位数与Qt软件的位数不一致时，MySQL数据库是64位，qt开发软件是32位的，这种MySQL数据库与Qt开发软件的位数不一致就容易出现mysql驱动不能加载问题。 三、解决问题：回到最初问题，有驱动但不能加载 MySQL数据库64位，qt开发软件为32位。需要下载32位的libmysql.dll动态库。链接：https://downloads.mysql.com/archives/c-c/
​
将压缩包解压，将lib文件夹下的libmysql.dll和libmysql.lib文件拷贝到Qt的安装目录的bin文件夹下即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1776c2ba610d0ae04754b78b68f50260/" rel="bookmark">
			【MySQL】MySQL用户管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、用户1.用户信息2.创建用户3.删除用户4.修改用户密码 二、数据库的权限1.给用户授权2.回收权限 一、用户 如果我们只能使用root用户，这样存在安全隐患。这时，就需要使用MySQL的用户管理。
1.用户信息 我们安装mysql之后，会自动创建一个mysql的数据库。MySQL中的用户，都存储在系统数据库mysql的user表中
我们可以查询如下信息：
select host,user,authentication_string from user; mysql&gt; select host,user,authentication_string from user; +-----------+---------------+-------------------------------------------+ | host | user | authentication_string | +-----------+---------------+-------------------------------------------+ | localhost | root | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B | | localhost | mysql.session | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | | localhost | mysql.sys | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | +-----------+---------------+-------------------------------------------+ --可以通过desc user初步查看一下表结构 字段解释：
host： 表示这个用户可以从哪个主机登陆，如果是localhost，表示只能从本机登陆
user： 用户名
authentication_string： 用户密码通过password函数加密后的
*_priv： 用户拥有的权限
2.创建用户 语法：
create user '用户名'@'登陆主机/ip' identified by '密码'; 案例：
mysql&gt; create user 'hdp'@'localhost' identified by '123456'; Query OK, 0 rows affected (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1776c2ba610d0ae04754b78b68f50260/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc6891759085ab038ee7b92172db29af/" rel="bookmark">
			数据结构——单向链表（C语言版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数据结构和算法中，链表是一种常见的数据结构，它由一系列节点组成，每个节点包含数据和指向下一个节点的指针。在C语言中，我们可以使用指针来实现单向链表。下面将详细介绍如何用C语言实现单向链表。
目录
1. 定义节点结构体
2. 初始化链表
3. 插入节点
4. 删除节点
5. 遍历链表
6. 主函数
1. 定义节点结构体 首先，我们需要定义表示链表节点的结构体。每个节点包含一个数据域和一个指向下一个节点的指针域。
typedef struct Node { int data; struct Node* next; } Node; 2. 初始化链表 接下来，我们需要编写函数来初始化链表。初始化链表时，我们将头指针指向NULL，表示链表为空。
Node* head = NULL; 3. 插入节点 实现在链表的头部插入节点的函数：
Node* insertNode(Node* head, int data) { Node* newNode = (Node*)malloc(sizeof(Node)); newNode-&gt;data = data; newNode-&gt;next = head; return newNode; } 4. 删除节点 实现删除指定数值节点的函数：
Node* deleteNode(Node* head, int data) { Node* current = head; Node* prev = NULL; while (current !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc6891759085ab038ee7b92172db29af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80f7fc5951792ec365dbb546a1e55c44/" rel="bookmark">
			秋叶大佬24年最新的Stable Diffusion整合包V4.6.7来了～
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		！
「 无套路！文末提供下载方式 」
要说今年绘画圈最大的新秀
那妥妥的就Stable Diffution
V4升级版无需安装**，直接解压就能用
（在此要感谢秋葉aaaki大佬的分享！）
比之前推送的更加智能、快速和简单
有多简单呢？这么说吧
之前的版本需要初中生级别
现在的V4加强版小学生也能上手！
1、Stable Diffusion 是什么？
Stable Diffusion（简称SD）是一种生成式人工智能，于2022年发布，主要用于根据文本描述生成详细图像，也可用于其他任务，如图像的修补、扩展和通过文本提示指导图像到图像的转换。除图像外，您还可以使用该模型创建视频和动画。
这是AI绘画第一次能在可以在消费级显卡上运行，任何人都可以下载模型并生成自己的图像。另外，SD高质量的成图以及强大的自由度（自定义、个性化）受到诸多网友的追捧。Stable
Diffusion XL 1.0 (SDXL 1.0) 是Stable Diffusion的一个更为高级和优化的版本，它在模型规模、图像质量、语言理解和模型架构等方面都有显著的改进。
Stable Diffusion 能做什么？
首先，大家在入坑SD前，务必要清楚现阶段的SD到底能做什么？能否满足自己的需求？
Stable Diffusion 功能包括文本转图像、图像转图像、图形插图、图像编辑和视频创作。
**文本转图像生成：**最常见和最基础的功能。Stable Diffusion 会根据文本提示生成图像。
图像转图像生成使用输入图像和文本提示，您可以根据输入图像创建新图像。典型的案例是使用草图和合适的提示。
创作图形、插图和徽标使用一系列提示，可以创建各种风格的插图、图形和徽标。
图像编辑和修正可以使用 Stable Diffusion 来编辑和修正照片。例如，可以修复旧照片、移除图片中的对象、更改主体特征以及向图片添加新元素。
视频创作使用 GitHub 中的 Deforum 等功能，可以借助 Stable Diffusion 创作短视频片段和动画。另一种应用是为电影添加不同的风格。 还可以通过营造运动印象（例如流水）来为照片制作动画。
2、安装和部署Stable Diffusion** 介绍如何安装和部署Stable Diffusion。我使用的是秋葉aaaki的整合包，文章末尾提供180G整合包～‍‍‍‍
电脑系统：Windows10及以上/macOS Monterey (12.5)。
显卡：RTX3060及以上。
显存：8G及以上。
内存：16G及以上。
磁盘空间：500 SSD及以上
操作步骤
步骤一：右键解压Stable Diffusion安装包。
步骤二：双击Stable Diffusion安装包进入文件夹中，解压sd-webui-aki-v4.2。
步骤三：双击启动器运行依赖-dotnet-6.0.11，安装所需依赖。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80f7fc5951792ec365dbb546a1e55c44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/485fc4fe983fad44cad0287129a8aa77/" rel="bookmark">
			这5款国内可用的宝藏AI绘画工具，不允许有人还不知道！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末扫码可领AI及副业资料
分享 5 个国内热门的 AI 绘画工具。
目前国内的 AI 创作工具已经非常多了。今天单就 AI 在线图片创作这个方向，挖一下国内有哪些热门的 AI 绘画工具。
通过整理，发现有一些 AI 工具，还真的挺好用的，分享给大家。
一、奇域AI 奇域AI，是一个专注于中国文化和中式审美的 AI 绘画创作社区。
有各种绘画风格，比如像水墨风格、国漫系列、刺绣风格，还有皮影戏、京剧花旦、扎染风格等等。
这些风格在奇域AI里都可以非常容易地画出，而且也都非常符合中式审美。
奇域AI官网：
https://www.qiyuai.net/apps/met/login?invitationCode=OREGM6
下面这些都是用奇域AI画的：
【刺绣风格】
【水墨风格】
【扎染风格】
【京剧花旦】
【战国小人书】
支持：电脑端（网页版）、手机端（小程序）
二、Dreamina Dreamina 是剪映旗下的一个 AI 创作平台，目前支持「图片生成」功能，也即将上线「视频生成」功能。
Dreamina 官网：
https://dreamina.jianying.com/s/iFQhyUSm/
直接打开网址，简单输入几个中文词汇，就可以生成质量很高的图片。
目前还**「完全免费」，可「无限出图」**。
不过，我看现在已经推出了会员计划，后续应该也是积分制的了，每天会有一些免费额度。
这些图都是用 Dreamina 生成的。
关于 Dreamina 更多介绍，可以看之前写的这篇文章：
居然才发现！字节跳动旗下国产AI绘画工具Dreamina，这么好用居然还免费！（强烈推荐）
三、文心一格 文心一格，大家应该不陌生，百度旗下的 AI 绘画工具。
文心一格是依托飞桨、文心大模型的技术创新推出的AI作画产品，可轻松驾驭多种风格，人人皆可「一语成画」。
文心一格官网：
yige.baidu.com/
文心一格除了有「AI 创作」功能，还有「AI 编辑」功能：
支持商品一键换背景、画面扩展、一键消除修复画面瑕疵、涂抹编辑、图片叠加、增强画质等功能。
支持：电脑端（网页版）、手机端（文心一言 APP 中可作画）。
四、无界AI 无界AI，是国内领先的AIGC内容创作平台，致力于为国内用户提供更加简洁易用、模型更加丰富的 AIGC 绘画工具。
无界AI官网：
https://www.wujieai.com/register?inviteCode=5GIWEY
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/485fc4fe983fad44cad0287129a8aa77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0db7c0e57263634892e5f79946bb0700/" rel="bookmark">
			JS获取本机IP地址的2种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.获取本机IP地址方法1：2.获取本机IP地址方法2解决方案： 1.获取本机IP地址方法1： if(typeof window != 'undefined'){ var RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection; if (RTCPeerConnection) (()=&gt;{ var rtc = new RTCPeerConnection() rtc.createDataChannel(''); //创建一个可以发送任意数据的数据通道 rtc.createOffer( offerDesc =&gt; { //创建并存储一个sdp数据 rtc.setLocalDescription(offerDesc) }, e =&gt; { console.log(e)}) rtc.onicecandidate =(evt) =&gt; { //监听candidate事件 if (evt.candidate) { console.log('evt:',evt.candidate) let ip_rule = /([0-9]{1,3}(\.[0-9]{1,3}){3}|[a-f0-9]{1,4}(:[a-f0-9]{1,4}){7})/ var ip_addr = ip_rule.exec(evt.candidate.candidate)[1] console.log('ip_addr:',ip_addr) //打印获取的IP地址 }} })() else{console.log("没有找到")} } 2.获取本机IP地址方法2 //获取用户本地ip的方法 const getUserIP= (onNewIP)=&gt; { let MyPeerConnection = window.RTCPeerConnection || window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0db7c0e57263634892e5f79946bb0700/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6d20d7dd8d6ef99e1d041f5ce0e653c/" rel="bookmark">
			Matlab App Designer 【05】Appdesigner和Simulink实时交互
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Simulink二、Appdesigner三、画图函数四、运行示意五、其余案例六、免费下载链接 摘要：simulink的数据实时显示在appdesigner上，matlab2024a版本更新的appdesigner这部分功能已经集成，如果更新到2024a了，可直接自带的功能.
注：仅记录学习，如有侵权，联系删除。
1、所写内容只是个人理解，如有错误，还请包涵2、所用主题为slandarer提供的墨滴模板3、CSDN：勉为其难免免4、微信公众号：飘散在人间的一缕青丝 一、Simulink 为了简单介绍，simulink里面只放Sine Wave、Scope、Out三个模块。
右键模型空白处，模型属性，设置initfcn初始化函数和startfcn函数。
二、Appdesigner 非常简单的示意，只有一个坐标区控件。
三、画图函数 函数名和你在simulinl里面设置的函数名要保持一致，关键地方就是拿到数值，当前时间和坐标区。然后画图。
function PlotOnApp(varargin) % varargin = (block,eventdata) 输入的两个参数是模块和事件 rto1 = get_param('sineexample/Out1','RuntimeObject'); % 获取界面中的绘图句柄 all_tag_objects = findall(0, '-property', 'tag'); all_tags = get(all_tag_objects, 'tag'); [tf, idx] = ismember('UIAxes', all_tags);% 找到坐标区 if tf app_plot = all_tag_objects(idx); end XData = get_param('sineexample','SimulationTime');%获取当前simulink运行时间 YData = rto1.InputPort(1).Data; plot(app_plot,XData,YData,'.','Color','r'); hold(app_plot, 'on' ); end 四、运行示意 直接运行simulink模型，即可看到app里面会实时显示sine波形。
五、其余案例 参考案例
自己在参考案例上修改了一部分，下面贴出代码。
主要功能代码
startupFcn
clc; movegui(app.UIFigure,'center');% 整个APP居中 app.Out1.Tag = 'Out1'; % 设置输出1的标签 app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6d20d7dd8d6ef99e1d041f5ce0e653c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e003851e554b5b6496cbc78ab5b1a4a/" rel="bookmark">
			JSqlParser的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 JSqlParse是一款很精简的sql解析工具，它可以将常用的sql文本解析成具有层级结构的语法树，我们可以针对解析后的节点进行处理(增加、移除、修改等操作),从而生成符合我们业务要求的sql，比如添加过滤条件等等
JSqlParse采用访问者模式
项目简介 项目结构非常简单，从截图上看就5个包。如果对源码感兴趣的可以直接从github上下载源码包调试。其中expression包包含了所有的sql表达式的抽象对象：
statement包含了所有sql语句的类型，比如：增删改查，ddl语句,rollback语句等等
schema包是对数据库基本单元的抽象：服务器、数据库、表、列等等
parser包是整个解析的核心逻辑，感兴趣的可以自行源码调试
使用示例 上面已经做了关于该解析工具的简单介绍，对于工具类，最重要的使用。以下举例关于增、删、改、查的sql语句中，均增加一列为例介绍该工具的简单使用
依赖引入 &lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;4.5&lt;/version&gt; &lt;/dependency&gt; 新增add 原始sql：insert into t_user_info(id,user_name,address) values('123','zhangsan','龙华')
期望在执行该sql时，能增加一列STATUS作为插入
都是一些api的运用，相关代码如下：
package com.lyc.boot.client.test.insert; import com.lyc.boot.client.test.insert.visitor.InsertStatementVisitor; import lombok.extern.slf4j.Slf4j; import net.sf.jsqlparser.JSQLParserException; import net.sf.jsqlparser.expression.Expression; import net.sf.jsqlparser.expression.RowConstructor; import net.sf.jsqlparser.expression.StringValue; import net.sf.jsqlparser.expression.operators.relational.ExpressionList; import net.sf.jsqlparser.expression.operators.relational.ItemsList; import net.sf.jsqlparser.parser.CCJSqlParserUtil; import net.sf.jsqlparser.schema.Column; import net.sf.jsqlparser.statement.Statement; import net.sf.jsqlparser.statement.insert.Insert; import net.sf.jsqlparser.statement.select.Select; import net.sf.jsqlparser.statement.select.SelectBody; import net.sf.jsqlparser.statement.select.SetOperationList; import net.sf.jsqlparser.statement.values.ValuesStatement; import java.util.List; import static com.lyc.boot.client.test.CommonUtil.printStatement; import static com.lyc.boot.client.test.CommonUtil.printTableName; @Slf4j public class InsertCommonTest { private static final String INSERT_COMMON = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e003851e554b5b6496cbc78ab5b1a4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a72cc90ab42ba98e87e0a5e3fcbacd4e/" rel="bookmark">
			LabVIEW调用Matlab脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 概述 LabVIEW调用Matlab脚本通常有两种方式，使用公式节点或者COM组件。
2. Matlab公式节点方式 推荐指数：⭐⭐⭐
是否需要安装matlab完全版：需要
使用公式节点是最常用的调用matlab节点的方式，对于代码相对简单，没有子函数的matlab脚本比较适用。 2.1 使用说明 按照如下路径找到 MATLAB script 程序面板控件，放置在程序面板框图中。在matlab脚本控件中填写代码，直接填写函数体内容，不用包含函数名称。
2.1 优缺点说明 优点：
操作简单，直接使用labview自带的控件进行文本编程。 缺点：
语法与matlab不是完全兼容，对于复杂的函数，排查语法问题很难； 不能调用包含嵌套函数的脚本需要安装matlab完全体，对电脑配置要求较高；运行时会自动出现matlab命令行窗口。 2.3 官方范例 按照如下官方文档中提供的路径，打开其中一个范例程序。
如下所示，打开了范例程序，程序功能为调用了一个matlab脚本，生成了一个二位数组，并用强度图显示出来。可以看到，matlab脚本控件中直接就是函数体，没有函数名称声明等信息，还添加了一个输出数组M。
此外，使用此种方法调用matlab时，会自动调起MATLAB Command Window。如下所示。 3. COM组件方式 推荐指数：⭐⭐⭐⭐⭐
是否需要安装matlab完全版：不需要，安装matlab引擎即可 将matlab脚本封装成dll进行调用，是很实用的方式，无论是简单还是复杂代码，嵌套了多少子函数，都是可以适用的，也是我个人比较推荐的。
3.1 使用说明 3.1.1 在matlab中生成dll 首先用maltab打开一个m文件脚本，如下所示
点击工具栏切换到APP页面，点击右侧显示更多。
找到如下“Application Compiler” ，点击打开
在弹出的页面点击新建，选择"Library Compiler Project"
在弹出的页面中点击选择"Generic COM Component"
选择要封装的matlab脚本 点击"Package"，选择打包文件夹路径 等待打包完成
打开"for_testing"文件夹，找以函数命名的dll文件，就是最终生成好的dll。
3.1.2 注册dll 管理员权限打开cmd窗口，输入如下
regsvr32 + dll文件路径
实际如下图所示 输入完成后，回车运行，提示成功就可以了，如下图所示
3.1.3 程序调用dll 新建vi，找到自动化打开句柄，添加到程序面板
右键自动化句柄，选择ActiveX类，浏览找到刚才注册的 "sintest"
选择之后，如下图勾选，选择Class1，点击OK 右键选择添加调用节点，如下图所示 选择sintest函数
给参数赋值，并且增加关闭句柄，在句柄关闭前，增加了一个延时，这样是可以在调用脚本运行后观察到matlab生成的figure，验证调用成功的效果，figure不会立刻消失，在延时之后会消失。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a72cc90ab42ba98e87e0a5e3fcbacd4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26a980433ce53e6bcaf155172347a0f1/" rel="bookmark">
			打包部署若依SpringBoot后端和Vue前端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）、打包若依SpringBoot后端 打开若依，点击右侧的Maven展开Maven管理，选择ruoyi&gt;Lifecycle 先双击clean清除原本启动项目时生成的文件。然后点击package等待项目打包
打包完成后会在ruoyi-admin&gt;src&gt;target里面看到.jar后缀的文件，就代表打包成功（可以把这个文件复制出来存放到其他地方，方便后面启动）
（2）、部署若依SpringBoot后端 把刚刚打包好的文件存放到自己的文件位置
然后在路径栏里输入cmd，回车会打开一个命令框
在命令框里输入java -jar ruoyi-admin.jar回车启动打包好的jar包。
这个窗口不要关闭！！！！关闭就是结束运行了
（3）、打包若依Vue前端 使用Visual Studio Code打开ruoyi-ui文件夹
打开终端：左上角任务栏选择终端&gt;新建终端
在新建终端中输入命令npm run build:prod，回车等待打包完成
打包完成后查看文件目录，有一个叫dist的文件夹就是打包成功了，dist的文件夹介绍打包的Vue项目了
（4）、部署若依Vue前端 前端部署需要使用nginx 下载地址（https://nginx.org/en/download.html）下载
下载完成解压到任意地方
然后进入nginx-1.22.1&gt;html 把刚刚打包好的Vue前端dist文件复制进来
然后返回上一层 进入conf文件夹
用Visual Studio Code打开nginx.conf
更改以下代码（改完ctrl+s保存就可以关闭Visual Studio Code）
location / { root html/dist; // 打包好的文件路径 try_files $uri $uri/ /index.html; # 将所有路由请求重定向到index.html } location /prod-api/{ proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://localhost:8080/; #后台项目的运行端口 } 启动ngxin 首先回到nginx-1.22.1文件夹里
在路径栏里输入cmd，回车会打开一个命令框
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26a980433ce53e6bcaf155172347a0f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e48936582c51122d54b8bc1535005f5/" rel="bookmark">
			什么？你还不知道这几款免费又好用的 MySQL 客户端吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要说 MySQL 最好用的客户端是 Navicat，但是人家不免费啊，一看价格，对于个人开发者来说还挺贵，完全没必要。
当然，互联网上啥都有免费版，你要说你从没用过 xx 版的软件，可能连你自己都不信。私下里用用倒是没啥，可哪天碰上正版的玩家，也确实有点不好意思拿出手。
不慌，下面这几款正版而且免费的 MySQL 客户端保证你拿的出手。
MySQL WorkBench
===============
MySQL WorkBench 是官方出品的客户端，支持 Mac、Windows、Linux。因为是官方出品，所以功能比较全。我之前有做 .NET 开发的经历，那会儿天天和 Microsoft SQL Server 打交道，所以看到 MySQL WorkBench 的这个界面风格非常熟悉，风格和 Microsoft SQL Server 非常相似，甚至和宇宙第一 IDE Visual Studio 的风格也是相似的。所以，我怀疑它是借鉴了微软的风格。
image-20200707100643416
风格不要紧，好用才重要。
这么说吧，你肯定用过 Navicat 对吧，Navicat 有的功能它全都有。
支持数据库结构管理，包括数据库、表结构、数据管理；
支持 ER 模型管理，包括正向逆向工程；
支持视觉效果仪表板； image-20200707101718124
支持数据迁移，比如从 Microsoft SQL Server 迁移到 MySQL;
官网地址：www.mysql.com/products/wo…
Sequel Pro
==========
只支持 Mac ，但功能也算比较全了。
支持数据库管理，可对数据库进行增加、修改等操作。支持对表结构、内容、关联关系等进行界面版管理。
还有两个方便的操作，可以列出所有的 Server Variables 。
可列出 Server Processes
官网地址：sequelpro.com/
小编13年上海交大毕业，曾经在小公司待过，也去过华为、OPPO等大厂，18年进入阿里一直到现在。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e48936582c51122d54b8bc1535005f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0af04c2c766e26d42c65ba9a59cce069/" rel="bookmark">
			[Flutter]运行到Android报错You are applying Flutter‘s app_plugin_loader Gradle plugin imperatively using..
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错： flutter run到Android模拟器报错如下：
Launching lib/main.dart on Android SDK built for x86 in debug mode...
You are applying Flutter's app_plugin_loader Gradle plugin imperatively using the apply script method, which is deprecated and will be removed in a future release. Migrate to applying Gradle plugins with the declarative plugins block: https://flutter.dev/go/flutter-gradle-plugin-apply
修复: 手动修复 https://docs.flutter.dev/release/breaking-changes/flutter-gradle-plugin-apply
自动修复 应该在项目搭建时就这样操作，不然等项目开发后，自定义配置比较多时就比较麻烦了。 不过自动修复的优势也比较明显，对新手比较友好，比如我手动修复了一半天，运行时还是各种报错。
1.将flutter项目备份
在删除 android目录之前，确保备份任何重要的更改，如 AndroidManifest.xml 的更改、Gradle 配置更改、本地依赖等。
2.将flutter升级到最新版本
从 Flutter 3.16 开始，使用 flutter create 使用 Plugin DSL 应用 Gradle 插件。创建的项目 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0af04c2c766e26d42c65ba9a59cce069/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/460/">«</a>
	<span class="pagination__item pagination__item--current">461/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/462/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>