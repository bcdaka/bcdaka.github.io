<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ecd793e4c0e4a2440134e4a85678b63/" rel="bookmark">
			12 款在手，前端无忧——Vue UI 组件库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Code Is Never Die !
今日分享下同事推荐的十二款VUE UI组件库，方便前端开发的伙伴们参考
Element UI Element UI 是一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库。它是一个用于 Web 的 UI 组件库 ，除了 Vue 之外，它还具有React 和 Angular的版本。
官网：https://element.eleme.cn/
Element Plus - 经典中的经典，全面支持 Vue 3
官网：https://element-plus.org/
Ant Design of Vue Ant Design Vue 是 Ant Design 的 Vue 实现，Ant Design 作为一门设计语言已经经历了多年的迭代和积累，它对 UI 的设计思想已经成为一套标准，也是 React 开发者手中的神器，Ant Design Vue 的组件风格与 Ant Design 保持同步，组件的 html 结构和 css 样式也保持一致，真正做到了样式 0 修改，组件 API 也尽量保持了一致。
官网：https://tdesign.tencent.com/
Vuetify 3 Vuetify 老牌 Vue UI 组件库，它提供了丰富的常用组件（有超过 100 个组件），适用于多数场景下的使用情况。Vuetify 基于谷歌的 Material Design 样式开发，无需写一行 CSS 就能生成相当整洁清爽的界面功能。Vuetify 支持 PC 端和移动端，对移动端有特别棒的优化，响应式，配置简单，带有响应式网络系统，支持事件处理，支持多种浏览器，甚至连 IE 11 也支持。Vuetify 已经发布支持 Vue 3 的版本，如果正在考虑未来的迁移问题，可放心使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ecd793e4c0e4a2440134e4a85678b63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92e3011ecaf8f637d43e227674cc74f9/" rel="bookmark">
			Python中计算圆周率的n种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python中计算圆周率的n种方法
使用math库中的pi常量 import math pi = math.pi print(pi) 使用π的计算公式：4*arctan(1) import math pi = 4 * math.atan(1) print(pi) 使用级数展开公式计算π def calculate_pi(n): sum = 0 for k in range(n): sum += 4 * ((-1) ** k) / (2 * k + 1) return sum print(calculate_pi(1000)) 使用蒙特卡洛方法计算π import random def calculate_pi(n): num_points_circle = 0 num_points_total = 0 for _ in range(n): x = random.uniform(0, 1) y = random.uniform(0, 1) distance = x ** 2 + y ** 2 if distance &lt;= 1: num_points_circle += 1 num_points_total += 1 return 4 * num_points_circle / num_points_total print(calculate_pi(1000000)) 使用高斯公式计算π（仅适用于偶数n） def calculate_pi(n): return n * (2 / (n + 1) - 2 / (n + 2)) * (1 + (-1) ** (n // 2)) / 4 print(calculate_pi(100)) # 仅适用于偶数n，这里取n=100为例 使用Python的内置库mpmath进行高精度计算 from mpmath import pi print(pi) 使用无限级数进行π的近似计算 def calculate_pi(n): sum = 0 for k in range(1, n + 1): sum += 4 * ((-1) ** k) / (2 * k + 1) return sum print(calculate_pi(1000000)) # 计算结果为3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92e3011ecaf8f637d43e227674cc74f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b79398b420e7497556fc830879aac16/" rel="bookmark">
			npm安装心得（依赖库Python及node-sass依赖环境）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用vue的开发环境过程中，总会遇到这样哪样的安装或者打包错误，
vue运行或打包常见错误如下：
1. npm install时 node-sass npm ERR command failed （可能是node.js的版本和node-sass的版本不符，就是卸掉原来的node.js，下载一个符合node-sass版本的node.js）
2. npm run build无法打包的可能原因 npm ERR! missing script: build （package.json中scripts参数为"build:prod": "vue-cli-service build"，所以换命令打包：npm rum build:prod）
3. npm WARN npm Supported releases of Node.js are the latest release of 6, 8, 9, 10, 11. (据自己的node版本来更新npm 版本npm -g install npm@6.14.8 ,如果仍然报错，依旧显示npm 不支持这个版本 ，这说明npm存在旧的npm缓存，还是旧的npm 环境
此时需要到C:\Users\administrator\AppData\Roaming 根目录下删除npm和npm-cache两个文件夹)
4. npm install时 node-sass npm ERR command failed问题解决 （卸载当前版本的node-sass和sass-loader,因为版本和当前的不兼容,安装对应版本的包即可。）
5. Syntax Error: Error: PostCSS received undefined instead of CSS string （卸载当前版本的node-sass和sass-loader,因为版本和当前的不兼容,安装对应版本的包即可。）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b79398b420e7497556fc830879aac16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af2b1369c5dbd1251186a276225b93af/" rel="bookmark">
			Java中java.lang.ClassCastException异常原因及解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中java.lang.ClassCastException异常原因及解决方法 大家好，我是免费搭建查券返利机器人赚佣金就用微赚淘客系统3.0的小编，也是冬天不穿秋裤，天冷也要风度的程序猿！在Java编程的世界中，我们经常会遇到各种异常，其中之一就是java.lang.ClassCastException异常。这个异常通常发生在类型转换的过程中，引起程序运行时的错误。今天，让我们深入探讨ClassCastException异常的产生原因以及解决方法，为你揭示在Java项目中如何避免这一常见陷阱。
1. java.lang.ClassCastException异常简介 ClassCastException异常是Java中的一种运行时异常，它表明程序在试图将对象强制转换为不是其实际类型的类时发生了错误。这通常发生在类之间存在继承或实现关系的情况下。
2. 异常产生的原因 ClassCastException异常通常发生在以下情况：
尝试将一个对象强制转换为其子类，而实际上该对象并非该子类的实例。尝试将一个对象强制转换为没有任何关系的类。使用泛型时，由于类型擦除，导致无法在运行时获得泛型的实际类型。 // 示例代码 public class Animal { // ... } public class Dog extends Animal { // ... } public class Cat extends Animal { // ... } public class Main { public static void main(String[] args) { Animal animal = new Cat(); Dog dog = (Dog) animal; // ClassCastException } } 在上述示例中，animal实际上是Cat类的实例，但是在强制转换时却试图将其转换为Dog类，因此抛出了ClassCastException异常。
3. 解决方法 3.1 使用instanceof进行类型检查 在进行类型转换之前，可以使用instanceof运算符进行类型检查，避免发生ClassCastException异常。
// 示例代码 public class Main { public static void main(String[] args) { Animal animal = new Cat(); if (animal instanceof Dog) { Dog dog = (Dog) animal; // 执行与Dog相关的操作 } else { // 处理类型不匹配的情况 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af2b1369c5dbd1251186a276225b93af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/811502429d0c9d9baf442454060d14c6/" rel="bookmark">
			Python tkinter控件全集之组合选择框 ttk.ComboBox
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tkinter标准库 Tkinter是Python的标准GUI库，也是最常用的Python GUI库之一，提供了丰富的组件和功能，包括窗口、按钮、标签、文本框、列表框、滚动条、画布、菜单等，方便开发者进行图形界面的开发。Tkinter库基于Tk for Unix/Windows/macOS，由Tcl语言编写。使用Tkinter，可以快速创建桌面应用程序，并支持多平台Windows、macOS、Linux等。
tkinter控件全集 在python中导入tkinter库后，有18种控件(也称组件)：
导入方式：import tkinter as tk
Button、Canvas、Checkbutton、Entry、Frame、Label、LabelFrame、Listbox、Menu、Menubutton、Message、OptionMenu、PanedWindow、Radiobutton、Scale、Scrollbar、Spinbox、Text
最学见的按钮、文本框、标签、列表框等都在里边，唯独没看到组合框ComboBox。查过资料后才知道，tkinter库中还有一子模块tkinter.ttk，它包含有包括Combobox在内的20种控件：
导入方式：from tkinter import ttk
Button、Checkbutton、Combobox、Entry、Frame、Label、LabelFrame、LabeledScale、Labelframe、Menubutton、Notebook、OptionMenu、PanedWindow、Progressbar、Radiobutton、Scale、Scrollbar、Separator、Sizegrip、Spinbox、Treeview
请注意，某些控件在两个模块中都存在（如Button, Checkbutton, Entry等），但它们在外观和行为上可能会有所不同，ttk模块中的控件可以提供更加现代和可定制的外观。以Button为例，都以简单的方式表达，运行后的外观和行为都有些不同。
import tkinter as tk from tkinter import ttk
button1 = tk.Button(root, text="Click Me", command=button_click)
button2 = ttk.Button(root, text="Click Me", command=button_click)
如图所示：
完整代码如下：
import tkinter as tk from tkinter import ttk def button_click(): print("Button clicked!") if __name__=='__main__': root = tk.Tk() root.title("Button vs ttk.Button") root.geometry("400x300") button1 = tk.Button(root, text="Click Me", command=button_click) button1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/811502429d0c9d9baf442454060d14c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/871e22072282ad1a787fe609942dbb62/" rel="bookmark">
			【MySQL】数据库的数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据类型 一、数据类型分类二、数值类型1. tinyint2. bit3. 小数类型（1）float（2）decimal 三、字符串类型1. char2. varchar3. varchar 和 char 比较 四、日期和时间类型五、 enum 和 set 一、数据类型分类 mysql 中的数据类型分类如下，其中红色字体的为常用的类型：
二、数值类型 mysql 中表的建立属性列：列名称 数据类型，例如 num int，它与我们平时写的语言数据类型是倒过来的！
1. tinyint 接下来我们创建一个只有 tinyint 类型的表，然后分别插入 1 和 128，会发现 128 插入失败，因为越界插入了，超出类型范围：
说明:
在 MySQL 中，整型可以指定是有符号的和无符号的，默认是有符号的；可以通过 unsigned 来说明某个字段是无符号的； 例如下图例子，我们创建一个无符号的表，插入 -1 会失败，因为 tinyint 的无符号范围是 0~255：
其他类型大家可以自己推导，注意：尽量不使用 unsigned，对于 int 类型可能存放不下的数据，int unsigned 同样可能存放不下，与其如此，还不如设计时，将 int 类型提升为 bigint 类型。
2. bit 基本语法：bit[(M)] : 位字段类型。M表示每个值的位数，范围从1到64。如果M被忽略，默认为1.
接下来我们创建一个 t3 表，数据类型分别为 int 和 八位的 bit 位：create table t3(id int, a bit(8));
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/871e22072282ad1a787fe609942dbb62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12e37005d8c84051484e525f9cdfce6e/" rel="bookmark">
			redisTemplate.opsForValue() 懂这些就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redisTemplate.opsForValue() 是 Spring Data Redis 提供的一个操作字符串类型数据的工具方法。通过这个方法，你可以获取一个 ValueOperations 对象，然后使用该对象进行对 Redis 中字符串类型数据的操作，比如存储、读取、删除等。
下是 ValueOperations 的一些常用方法哈
set(key, value)： 设置指定 key 的值为指定的 value。 redisTemplate.opsForValue().set(“myKey”, “myValue”);
get(key)： 获取指定 key 的值。 String value = redisTemplate.opsForValue().get(“myKey”);
increment(key, delta)： 将 key 的值增加指定的 delta（可以为负数）。 redisTemplate.opsForValue().increment(“myCounter”, 1);
decrement(key, delta)： 将 key 的值减少指定的 delta（可以为负数）。 redisTemplate.opsForValue().decrement(“myCounter”, 1);
setIfAbsent(key, value)： 当 key 不存在时，设置 key 的值为指定的 value。 redisTemplate.opsForValue().setIfAbsent(“myKey”, “myValue”);
getAndSet(key, value)： 获取指定 key 的值，并设置新值。 String oldValue = redisTemplate.opsForValue().getAndSet(“myKey”, “newValue”);
multiSet(Map&lt;String, String&gt; map)： 批量设置多个 key 的值。 Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12e37005d8c84051484e525f9cdfce6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc14a86d58973ffd28f8dc0c34904e5c/" rel="bookmark">
			Java 数据结构篇-实现堆的核心方法与堆的应用（实现 TOP-K 问题：最小 k 个数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥博客主页： 【小扳_-CSDN博客】
❤感谢大家点赞👍收藏⭐评论✍ 文章目录
1.0 堆的说明
2.0 堆的成员变量及其构造方法 3.0 实现堆的核心方法
3.1 实现堆的核心方法 - 获取堆顶元素 peek()
3.2 实现堆的核心方法 - 下潜 down(int i)
3.3 实现堆的核心方法 - 交换元素 swap(int i,int j)
3.4 实现堆核心方法 - 删除堆顶元素 poll()
3.5 实现堆的核心方法 - 替换堆顶元素 replace(int i)
3.6 实现堆的核心方法 - 添加元素 offer(int value)
3.7 实现堆的核心方法 - 建堆 heapify()
3.8 实现堆的核心方法完整代码
4.0 TOP - K 问题：最小的 K 个数
4.1 实现最小 k 个数的思路
4.2 代码实现最小 k 个数
1.0 堆的说明 堆（Heap）是一种基于树的数据结构，通常用于动态分配内存空间。堆可以被看作是一棵完全二叉树，其中每个节点都满足堆的性质，即父节点的值大于或等于子节点的值（大根堆），或父节点的值小于或等于子节点的值（小根堆）。在堆中，根节点的值是最大或最小的，因此也被称为最大堆或最小堆。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc14a86d58973ffd28f8dc0c34904e5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06b4853c0eec41970a130dbf4da7b697/" rel="bookmark">
			宽带信号处理实现DOA估计（ISM算法、MUSIC、MVDR、CBF）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%% 宽带信号DOA估计算法：ISM 算法%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%% Developed by HHU's Boya (河海大学_信息与通信工程_李蓉) %%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%% EMAIL:15006120517@163.com %%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%% MUSIC \ CBF \ MVDR %%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% clc; clear all; close all; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 参数定义 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% M=12; %阵元数 N=200; %快拍数 X=2; %信源数 ts=0.01; %时域采样间隔 fl=80; %入射信号最低频率 fh=120; %入射信号最高频率 fm=(fl+fh)/2; %入射信号中心频率 c=1500; %声速 lambda=c/fm; %波长 d=lambda/2; %阵元间距 SNR=15; %信噪比 ang2rad = pi/180; %角度转弧度系数 theta1=30*ang2rad; %入射信号波束角1 theta2=-45*ang2rad; %入射信号波束角2 n=ts:ts:N*ts; %采样时间矢量 theta=[theta1,theta2]; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% produce signal %%%%%%%%%%%%%%%%%%%%%%%%%%%% s1=chirp(n,fl,1,fh); %生成线性调频信号1； s1=awgn(s1,SNR,'measured'); %在信号中添加高斯噪声 s1_fft=fft(s1); %进行FFT变换;Y = fft(X,n) 返回 n 点 DFT。如果未指定任何值，则 Y 的大小与 X 相同 s2=chirp(n+0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06b4853c0eec41970a130dbf4da7b697/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b1d337fd10eb1e1692c6dc3aa5d8aab/" rel="bookmark">
			JDK21 WARNING: A Java agent has been loaded dynamically
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDK21 WARNING: A Java agent has been loaded dynamically 背景解决经过OpenJDK's JEP 451: Balancing Serviceability and Integrity in JVM 参考文章 背景 在做企业微信消息通知的时候，运行项目，出现该警告。
WARNING: A Java agent has been loaded dynamically (D:\maven-repository\net\bytebuddy\byte-buddy-agent\1.14.9\byte-buddy-agent-1.14.9.jar) WARNING: If a serviceability tool is in use, please run with -XX:+EnableDynamicAgentLoading to hide this warning WARNING: If a serviceability tool is not in use, please run with -Djdk.instrument.traceUsage for more information WARNING: Dynamic loading of agents will be disallowed by default in a future release 解决 经过 查了一些资料，找到一篇英文的介绍，有想深入的小伙伴可以自己研究下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b1d337fd10eb1e1692c6dc3aa5d8aab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d116537cce2965d7b48ec56ff27bce4d/" rel="bookmark">
			【前端】语法高亮 Prism.js 使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
介绍
示例
主题
插件
1、show-language
2、line-numbers
3、normalize-whitespace
4、unescaped-markup
5、copy-to-clipboard
6、show-invisibles
使用
1、直接下载
2、CDN 方式
3、Vue3 中使用
补充
API
按钮样式调节
Vue3 代码高亮组件（仅供参考）
高亮 script 标签
介绍 最近项目有代码高亮的需求，这边是选用 Prism.js 来进行代码高亮。
Prism 是一款轻量级、可扩展的语法高亮器，根据现代 Web 标准构建，应用广泛。
官网：https://prismjs.com/
文档：https://prismjs.com/docs/index.html
示例 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;!-- 可以通过 CDN 的方式导入 --&gt; &lt;meta charset="utf-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt; &lt;title&gt;Prism Test&lt;/title&gt; &lt;link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.css" rel="stylesheet" /&gt; &lt;/head&gt; &lt;body&gt; &lt;pre class="line-numbers"&gt; &lt;code class="language-cpp"&gt; #include &amp;lt;iostream&gt; using namespace std; struct ListNode { int val; ListNode *next; ListNode() : val(0), next(nullptr) {} ListNode(int x) : val(x), next(nullptr) {} ListNode(int x, ListNode *next) : val(x), next(next) {} }; &lt;/code&gt; &lt;/pre&gt; &lt;script src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d116537cce2965d7b48ec56ff27bce4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75c390335b101881c4251a71f46c1d44/" rel="bookmark">
			如何在安卓手机Termux上安装MariaDB（MySQL）并实现远程连接数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1.安装MariaDB2.安装cpolar内网穿透工具3. 创建安全隧道映射mysql4. 公网远程连接5. 固定远程连接地址 前言 Android作为移动设备，尽管最初并非设计为服务器，但是随着技术的进步我们可以将Android配置为生产力工具，变成一个随身Linux。
MariaDB是MySQL关系数据库管理系统的一个复刻，由社区开发，有商业支持，旨在继续保持在 GNU GPL 下开源。开发这个分支的原因之一是：甲骨文公司收购了MySQL后，有将MySQL闭源的潜在风险，因此社区采用分支的方式来避开这个风险。
接下来我们通过简单几步操作，在安卓手机termux上安装MariaDB(mysql) 数据库，并结合cpolar内网穿透，来实现公网环境下的远程连接访问。
1.安装MariaDB Termux 官方也封装了 MariaDB，所以安装起来很方便：
pkg install mariadb 验证是否安装成功,查看一下版本信息
mysql --version 出现版本信息表示安装成功
启动数据库,使用 Linux 自带的 nohup 命令将其放到后台启动
nohup mysqld &amp; 启动后可以看到进程PID号
如果想要关闭mysql,可以执行:
kill -9 PID 2.安装cpolar内网穿透工具 在Android termux上成功安装MySQL数据库后，我们继续在termux上安装cpolar，做内网穿透创建安全隧道将MySQL暴露到公网上，实现在不同网络下也可以远程连接termux上的MySQL数据库。
cpolar使用不需要公网IP，也不用设置路由器，亦不需要买云服务器。它支持http/https/tcp协议，可以免费使用也不限制流量。
cpolar官网：https://www.cpolar.com/
创建一个sources.list.d的文件夹:
mkdir -p $PREFIX/etc/apt/sources.list.d 添加cpolar下载源文件
echo "deb [trusted=yes] http://termux.cpolar.com termux extras" &gt;&gt; $PREFIX/etc/apt/sources.list.d/cpolar.list 更新仓库
pkg update 安装cpolar
pkg install cpolar 安装termux服务,注意: 安装完成后记得关闭重启一下termux 才生效!!
pkg install termux-services 重启完termux后,然后启动cpolar内网穿透
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75c390335b101881c4251a71f46c1d44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e638ddf7ef53ce6ecbc7749655bde29c/" rel="bookmark">
			C#中HttpWebRequest的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 HttpWebRequest是一个常用的类，用于发送和接收HTTP请求。在C#中使用HttpWebRequest可以实现各种功能，包括发送GET和POST请求、处理Cookie、设置请求头、添加参数等。本文将深入介绍HttpWebRequest的用法，并给出一些常见的示例。
目录 前言1. 发送GET请求2. 发送POST请求3. 设置请求头和处理Cookie4. 添加参数和处理响应结论 1. 发送GET请求 使用HttpWebRequest发送GET请求非常简单，只需指定目标URL即可。以下是发送GET请求的示例代码：
using System; using System.IO; using System.Net; class Program { static void Main() { string url = "https://www.example.com/api/data"; HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url); request.Method = "GET"; HttpWebResponse response = (HttpWebResponse)request.GetResponse(); using (StreamReader streamReader = new StreamReader(response.GetResponseStream())) { string responseData = streamReader.ReadToEnd(); Console.WriteLine(responseData); } } } 上述代码中，首先通过WebRequest.Create方法创建一个HttpWebRequest实例，并指定目标URL。然后设置请求方法为GET，通过GetResponse方法发送请求并获取响应。最后通过StreamReader对象读取响应数据。
2. 发送POST请求 发送POST请求与发送GET请求类似，只需将请求方法设置为POST，并设置请求体的数据。以下是发送POST请求的示例代码：
using System; using System.IO; using System.Net; using System.Text; class Program { static void Main() { string url = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e638ddf7ef53ce6ecbc7749655bde29c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87701b21bd1e6667a316f3c7afdfa720/" rel="bookmark">
			完成一个有趣的Web期末大作业（html、css、javascript、MySQL、Node.js）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：学校老师的要求很开放，要自己做一个感兴趣的网页，要求使用基础的html、css和javascript，后端要使用数据库。 网上都是各种管理系统，看多了觉得没啥意思，要做一个自己感兴趣的网站。近几年沉迷犬夜叉这部动漫，就花了两天的时间创建了一个犬夜叉的网站，对于期末大作业来说足够了。
需要源码可以联系我的邮箱 1329690093@qq.com
一、实验工具 运行系统：Windows11
编程语言：html+css+javascript+node.js
IDE：VsCode
安装：Node.js v18.18.0 （网上有安装教程）
数据库：mysql 18.0.3.0
vscode插件:
- MySQL v6.8.9
- Live Server v5.7.9 - open in browser - HTML CSS Support v1.13.1 二、设计过程 前端要求 在进行设计的时候，采用html和css相结合，对网页进行布局规划，形成适合动漫网站风格的页面，具体要求如下：
色彩：登录界面用清新的绿色按钮，首页则用深绿色导航栏搭配浅绿色按钮，配合动漫风格。布局：两个界面均采用简洁的卡片布局，信息分区清楚。字体：简单易读的字体，如微软雅黑，确保文字在各种设备上都清晰。元素：圆角的输入框和按钮，简洁的图标和图片。交互：明确的交互反馈，如点击按钮后的视觉效果。适应性：界面要适应不同设备和屏幕。兼容性：在多种浏览器和操作系统上都能保持一致表现。 页面布局 具体布局模块 首页模块 用户欢迎信息 ：显示 “ 欢迎 ‘用户名’ + 登录 ”。导航栏：包括首页、介绍、图片、视频&amp;音频、论坛等链接。页脚：展示作者信息及邮箱联系方式。 内容展示模块 介绍页面：展示犬夜叉动漫介绍。图片页面：展示四张犬夜叉相关图片。视频&amp;音频页面：展示一个视频和五首音乐。论坛页面：提供评论区，用户可以发表并存储评论。 Node.js 服务器搭建：利用Node.js搭建网站服务器，处理请求。提供静态文件服务，如HTML页面、CSS样式表、客户端JavaScript文件等。 script.js 前端逻辑处理：控制注册和登录表单的提交，与服务器端进行异步交互；
实现客户端表单验证，确保数据的准确性在发送到服务器之前进行校验；
负责处理用户在导航栏的页面跳转逻辑。 comment.js 评论区域功能：管理评论的提交，通过AJAX与服务器进行数据交换。在页面上动态显示用户评论。确保用户提交的评论实时更新并正确存储到数据库。 以上模块协同工作，共同提供一个交互式的用户体验，允许用户在一个安全和友好的环境中进行注册、登录、内容查看、以及社区交流。
项目工程：
三、界面&amp;代码 登陆界面 设计的很草率，能实现注册和登录的功能
登陆界面代码
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87701b21bd1e6667a316f3c7afdfa720/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56ad44a7169959b02b39ce38ea89cafd/" rel="bookmark">
			oracle与gbase8s迁移数据类型对照
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明：以下为笔者阅读gbase官方文档和oracle官方文档的理解，如有错误，敬请指正。 oracle与gbase8s迁移数据类型对照及举例说明 最终结论：oracle与gbase8s数据类型对应关系关于单精度与双精度的区别关于定点与浮点定义的区别精度的定义 Oracle 分为NUMBER和浮点数NUMBER浮点数BINARY_FLOAT 数据类型BINARY_DOUBLE 数据类型 gbase 8s 分精确数值数据类型，近似数值数据类型精确数值数据类型近似数值数据类型 最终结论：oracle与gbase8s数据类型对应关系 边界范围使用数据类型oraclegbase最大精度126位FLOAT/NUMBERDECIMAL单精度浮点数数据类型BINARY_FLOATsmallfloat双精度浮点数数据类型BINARY_DOUBLEFLOAT 下面首先回忆一下精度、定点、浮点的定义，然后再来看oracle、gbase的官方文档。
关于单精度与双精度的区别 单精度和双精度是计算机中用于表示浮点数的两种不同精度的格式。
单精度（Single Precision）：单精度浮点数使用32位（4个字节）来存储一个浮点数。它包括一个符号位（用于表示正负）、8位指数和23位尾数。单精度提供大约7位有效数字的精度。
双精度（Double Precision）：双精度浮点数使用64位（8个字节）来存储一个浮点数。它包括一个符号位、11位指数和52位尾数。双精度提供大约15-16位有效数字的精度，比单精度更高。
主要区别：
精度： 双精度提供比单精度更高的精度，因为它使用更多的位来表示数字。这使得双精度能够处理更大范围的数值，并提供更高的精确度。
存储需求： 双精度使用的存储空间是单精度的两倍，因此在存储大量数据时，双精度需要更多的内存空间。
计算速度： 在某些情况下，单精度计算可能比双精度计算速度更快，因为它涉及更少的位数和更简单的计算。
选择使用单精度还是双精度通常取决于对精度和内存使用的要求。如果需要更高的精度或者处理非常大或非常小的数值范围，双精度可能更适合。而如果对精度要求不高，但需要节省内存，那么单精度可能更合适。
关于定点与浮点定义的区别 定点数和浮点数是计算机表示数据的两种不同方式。定点数的小数点位置在计算机的存储中是约定好的，这意味着小数位为固定十进制数，而浮点数的小数位则随2的几次幂的大小而浮动。例如，8位定点数可以表示的范围是-16.00~15.875，其最大精度为0.125。
将浮点数转换为定点数的操作包括：首先计算 b = a * 2^F（a为浮点数，F为小数部分字长），然后将b化为整数，最后用二进制将b表示成c。这种转换方法在可以接受精度损失的前提下，有可能提高运算效率。然而，一般而言，定点数的数值范围有限，要求的处理硬件比较简单。
精度的定义 精度是一个衡量测量结果与真实值接近程度的概念，它反映的是误差的大小。如果误差小，则精度高；反之，如果误差大，则精度低。在计算机科学中，精度也用于表示数值的最小度量单位，例如，GPS的精度为0.1m，表示这个GPS最小能识别0.1m的位置差异。同时，精度还被用来描述计算机中小数点前后的总位数，如单精度和双精度分别表示精确到小数点后几位。然而，需要注意的是，仪器的精度并不能完全反映其准确度。
Oracle 分为NUMBER和浮点数 NUMBER NUMBER数据类型用于存储可能为负值或正值的数值。
数据类型存储定点数和浮点数。精度 38 位有效数字。
NUMBER(p, s)：
用于存储数字值，其中p表示精度（最多38位），s表示小数位数取值范围为[-84~127]，当s取负数时，将小数点左边的s位置为0，并四舍五入。当小数位数大于s时，采用四舍五入的方式。当整数部分的长度大于p-s时，报错。需要22个字节的存储空间。 Oracle FLOAT数据类型是NUMBER数据类型的子类型。FLOAT(b)：用于存储浮点数，范围从-1.79E+308到1.79E+308。FLOAT的最大精度是126。二进制精度的最大126位数，大致等于十进制数位数的38位数。
浮点数 BINARY_FLOAT 数据类型 BINARY_FLOAT是 32 位单精度浮点数数据类型。每个值需要 5 个字节，包括一个长度字节。BINARY_FLOAT
BINARY_DOUBLE 数据类型 BINARY_DOUBLE是 64 位双精度浮点数数据类型。每个值需要 9 个字节，包括一个长度字节。BINARY_DOUBLE
create table t2 (a binary_float,b binary_double); insert into t2 values (3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56ad44a7169959b02b39ce38ea89cafd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e843eef7751ba885e1a7415891a8c0a8/" rel="bookmark">
			Kafka事务是怎么实现的？Kafka事务消息原理详解（文末送书）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、Kafka事务性消息1.1 介绍Kafka事务性消息1.2 事务性消息的应用场景1.3 Kafka事务性消息的优势 二、Kafka事务性消息的使用2.1 配置Kafka以支持事务性消息生产者配置消费者配置 2.2 生产者：发送事务性消息创建Kafka生产者开始事务发送消息提交或中止事务 2.3 消费者：处理事务性消息创建 Kafka 消费者订阅主题处理消息提交位移 三、事务性消息的最佳实践3.1 保障消息的一次交付3.1.1 生产者幂等性3.1.2 消费者去重 3.2 事务性消息的监控和故障排查3.2.1 监控工具3.2.2 故障排查 3.3 事务性消息的性能考量3.3.1 性能调整3.3.2 吞吐量优化 四、示例：生产和消费Kafka事务性消息4.1 示例1：生产事务性消息示例1代码：生产者代码说明: 4.2 示例2：消费事务性消息示例2代码：消费者代码说明: 五、总结六、Spring Boot 3核心技术与最佳实践1、内容介绍2、作者简介3、参与方式 大家好，我是哪吒。
前两天，有个朋友去面试，被问到Kafka事务的问题。
她的第一反应是：
我是来面试Java的，怎么问我大数据的Kafka？
文末送5本《Spring Boot 3核心技术与最佳实践》
不过Kafka确实是Java程序员必备的中间件技术了，这点是毋庸置疑的。
Kafka几乎是当今时代背景下数据管道的首选，无论你是做后端开发、还是大数据开发，对它可能都不陌生。开源软件Kafka的应用越来越广泛。
面对Kafka的普及和学习热潮，哪吒想分享一下自己多年的开发经验，带领读者比较轻松地掌握Kafka的相关知识
上一节我们说到了解密Kafka主题的分区策略：提升实时数据处理的关键，今天系统的说一下Kafka的事务，实现步步为营，逐个击破，拿下Kafka。
在当今大数据时代，数据的可靠性和一致性变得至关重要。Kafka作为一个分布式流数据平台，强调了实时数据的高吞吐量传输，而Kafka事务性消息则在这个过程中发挥了至关重要的作用。
本文将详细介绍Kafka事务性消息，探究它们如何确保数据一致性，以及在各种应用场景中的应用。
一、Kafka事务性消息 1.1 介绍Kafka事务性消息 Kafka事务性消息是一项关键的功能，为确保数据一致性提供了重要的支持。在本部分，我们将深入了解Kafka事务性消息的基本概念。
Kafka事务性消息的概念
Kafka事务性消息是一种机制，用于确保消息的可靠性传递和处理。与非事务性消息相比，它们在数据处理中提供了额外的保证。一旦消息被写入Kafka集群，它们将被认为是已经处理，无论发生了什么。
为什么需要事务性消息？
事务性消息对于确保数据一致性至关重要。在某些应用程序中，消息的完整性和可靠性至关重要。如果在消息处理期间发生故障，如何保证消息不会丢失或重复是一个复杂的问题。Kafka事务性消息提供了解决这些问题的方式，使得消息处理更加可控和可靠。
事务性消息的特性
Kafka事务性消息具有以下关键特性：
原子性：事务性消息要么完全成功，要么完全失败。这确保了消息不会被部分处理。
可靠性：一旦消息被写入Kafka，它们将被视为已经处理，即使发生了应用程序或系统故障。
顺序性：事务性消息在单个分区内保持顺序。这对于需要按顺序处理的应用程序至关重要。 幂等性：Kafka生产者可以配置为幂等，确保相同的消息不会被重复发送。
Exactly Once语义：事务性消息支持"仅一次"语义，即消息要么完全到达一次，要么不到达。
本节的目标是帮助您理解Kafka事务性消息的核心概念。接下来，我们将探讨它们的应用场景以及相对于非事务性消息的优势。
1.2 事务性消息的应用场景 事务性消息在多种应用场景中发挥着关键作用。以下是一些常见的应用场景，其中事务性消息特别有用：
金融交易处理：在金融领域，每笔交易都必须具备原子性，确保不发生不一致或重复的交易。事务性消息可用于记录和处理金融交易，保证交易的完整性。
订单处理：在电子商务平台上，订单处理必须是可靠的，以确保订单的创建、支付和发货不会出现问题。事务性消息可用于跟踪和处理订单的不同阶段，从而确保订单流程的一致性。
库存管理：对于企业，库存管理是至关重要的。事务性消息可用于跟踪库存的变化，以确保库存的准确性和可靠性。
日志记录：在大数据和日志记录应用中，日志的完整性是至关重要的。事务性消息可用于确保日志的完整性，即使在日志处理集群发生故障时也能保持一致性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e843eef7751ba885e1a7415891a8c0a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cb92918d31cc43ed9ed7ef3f9404d5d/" rel="bookmark">
			DDSP-SVC-3.0完全指南：一步步教你用AI声音开启音乐之旅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本教程教你怎么使用工具训练数据集推理出你想要转换的声音音频，并且教你处理剪辑伴奏和训练后的音频合并一起，在文章的最后有用我自己声音处理的歌曲，哎哟，还怪不好意思的~，哈哈，快来试试看把！
DDSP-SVC3.0训练推理克隆声音，超物有所值，训练完毕有伴奏处理教程哦
1.使用的工具 要想训练ai声音，首先需要有各种工具，还需要我们提供你需要训练的声音，当然声音需要没有噪音存干声，如果要是歌曲就需要分离歌曲的背景和声音，然后将音频文件切分，切分的目的是为了保证训练不卡，否则音频文件太大，所以你知道我们需要什么工具了把！以下揭晓
Adobe Audition ：我主要用这个提取mp4的音频文件，后期可以用这个剪辑将伴奏和音频合起来
UVR5：这个是专门背景与人生分离的软件，一键安装就可以
Audio Slicer（音频切分）：这个可以不用专门下软件自己操作了，大神在webui里集成了，按一下自动切分。
DDSP-SVC-3.0：最重要的工具，启动后是个webui界面，然后呢我们需要在里边训练自己的声音，转换声音等操作。
整合包使用b站大佬羽毛布团提供的包-地址： https://pan.baidu.com/s/1DWqVpJ7b6ueoUv6h4yF1-A?pwd=ddsp
处理音频的工具可以去羽毛布团的这个整合包下载，注意不要下载so-svc文件哦： https://pan.baidu.com/s/12u_LDyb5KSOfvjJ9LVwCIQ?pwd=g8n4
2.素材准备 2.1 AU提取音频 将mp4提取音频文件，用AU操作，操作如下：
我是要把我在bilibili录制的视频下载下来的，需要借助bilibili的一些工具才能下载下来视频，我用的是这个在线解析bilibili视频的还是蛮方便的，链接在这里。
哔哩哔哩(bilibili)视频解析下载 - 保存B站视频到手机、电脑
然后得到的视频可以拖到如下的位置，
然后点击这个文件右键将音频提取到文件，然后点击新出的音频文件再点击最上面的菜单文件保存或另存为然后就得到音频文件了。
2.2 UVR5提取干声 下面提取说明按需去取。
音频如果比较纯的声音无噪音则直接可以切分音频了，如果不纯的化可以处理下，打开url5，
这个是处理伴奏和人声分离的。
伴奏人声分离以后可以去听听纯声，发现其实会有一些和声和混响的，我们要去去掉这个和声混响，根据下面操作。
如果不是唱歌而是干声去噪也可以使用如下这种方式处理看看效果，我是纯的背景有点噪音，然后用了去和声混响处理的，也是有点效果的。
3.启动DDSP-SVC 声音部分都处理完了，就可以启动webui了，进入DDSP-SVC-3.0目录，双击启动启动WebUI，然后弹出来一个cmd弹框，
复制这个路径打开webui webui的界面是这样的
3.1 音频切分 这时就可以音频切分了，按照下面的说明去处理。
切分后的文件。 找到切分后的输出目录然后全部将块音频全部复制到此目录下：DDSP-SVC-3.0\data\train\audio
然后就需要到webui界面下，这时需将DDSP-SVC-3.0\data\train里的音频以100:1的比例放入到此目录下：DDSP-SVC-3.0\data\val\audio，100:1就是100个文件里取一个这样的比例，也可以不用你自己挑，程序帮你挑完自己放入对应的校验集里也就是val目录下，程序操作如下：
3.2 数据预处理 数据预处理，这里也很快，按下面的说明进行填写，填写哪些都有注释，点击数据预处理就可以了。
3,3 训练前的参数设置 设置要训练的参数，其实都默认就行，但是配置低的要进行相应的更改，否则训练过程中会失败。然后点击写入配置文件就可以了，此时输出信息说写入配置完成就OK了。
3.4 开始训练 3.4.1 DDSP模型训练 然后就开始训练了， 一般是先训DDSP这个是比较重要的，第一次训练的化需要选择从头开始训练，如果训练过程中取消了，那么想要继续训练就选择继续上一次的训练进度，然后取消模型训练时一定要按照这个倍数取消“每隔多少步(steps)验证并保存一次模型（2000步）”,否则可能没保存上，
然后弹出cmd，一直在迭代步数中，代表训练中
观察loss值，无明显趋势觉得不需要训练就可以按取消了,ctrl+c就会取消训练
训练完了就可以训练扩散模型了，报如下错需要修改fp16需要改成fp32了。
可以看训练趋势图，启动Tensorboard，按下面这个操作就可以了，倒时会告诉你地址。
就会出现这样的界面
3.4.2 扩展模型训练 DDSP训练完毕，我们开始训练扩散模型。如下方式这样就可以了，cmd和上面的ddsp是一样的，感觉差不多了就取消训练。都训练完毕了就到推理环节了。
训练好的模型在这里会出现，此目录：DDSP-SVC-3.0\exp
DDSP的在这个目录下，可以看到模型训练的步数
扩散训练的在这个地方
4.模型推理 兄弟们最后一步了，坚持住啊！
推理就选择我们自己训练的模型，选择音频，按下面的图片的步骤走，按顺序来就行。
4.1 音频转换 重点来了，开始声音替换 ，我第一次处理时间巨长，也看不到日志后来关掉重启，重试关掉重启几次，突然出现了日志，以及处理过程，然后很快就推理完成了，听了下，效果还行，我的数据集还行，40分钟差不多，训练步数7500步也不多，然后我的声音全部是说话，没有唱歌声音，最后出现的这个效果还行，有一点点感觉到ai的感觉，不知道是不是这个哥以及歌手唱腔的原因。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cb92918d31cc43ed9ed7ef3f9404d5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1d8eaa80b86be47e19e81a88e52d516/" rel="bookmark">
			Python中的定时器用法：Timer定时器和schedule库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、引言
二、Timer定时器
1、Timer定时器的原理
2、Timer定时器的使用方法
3、Timer定时器的实际应用案例
三、schedule库
1、schedule库的原理
2、schedule库的使用方法
3、schedule库的实际应用案例
四、Timer定时器和schedule库的比较
1、功能差异
2、适用场景
五、实际应用案例
六、总结
一、引言 在Python中，定时器是一种常用的工具，用于在指定的时间间隔内执行特定的任务。Timer定时器和schedule库是Python中两种常用的定时器实现方式。本文将分别介绍它们的原理、使用方法和实际应用案例。
二、Timer定时器 1、Timer定时器的原理 Timer定时器是一种基于线程的定时器，它通过在指定的时间间隔内启动一个线程来执行特定的任务。当时间间隔到达时，线程将自动执行任务，并在任务完成后自动退出。
2、Timer定时器的使用方法 使用Timer定时器需要先导入threading模块，然后创建一个Timer对象，指定要执行的任务和时间间隔。下面是一个简单的示例：
import threading def my_task(): print("Task executed!") timer = threading.Timer(10.0, my_task) # 创建一个10秒后执行的Timer对象 timer.start() # 启动Timer对象 在这个示例中，我们首先定义了一个名为my_task的函数，它将在Timer对象执行时被调用。然后，我们创建了一个10秒后执行的Timer对象，并调用start()方法启动它。当10秒时间间隔到达时，my_task函数将被自动执行。
3、Timer定时器的实际应用案例 Timer定时器在实际应用中可以用于各种场景，例如：
定时发送邮件：可以在特定的时间间隔内发送邮件提醒。
定时备份数据：可以在每天固定的时间点备份数据库数据。
定时执行清理任务：可以在每天晚上固定时间清理临时文件。
三、schedule库 1、schedule库的原理 schedule库是一种基于时间的任务调度库，它可以根据指定的时间间隔和时间点来执行特定的任务。与Timer定时器不同的是，schedule库支持同时执行多个任务，并且可以根据任务的优先级进行调度。
2、schedule库的使用方法 使用schedule库需要先安装它（可以使用pip install schedule命令进行安装），然后定义要执行的任务和时间间隔。下面是一个简单的示例：
import schedule import time def my_task(): print("Task executed!") schedule.every(10.0).seconds.do(my_task) # 每10秒执行一次my_task函数 while True: schedule.run_pending() # 运行待执行的任务队列 time.sleep(1) # 暂停1秒钟，等待下一个任务执行 在这个示例中，我们首先定义了一个名为my_task的函数，它将在schedule库执行时被调用。然后，我们使用schedule.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1d8eaa80b86be47e19e81a88e52d516/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2872d8d8b8f2bc569a1ac865662ed2ab/" rel="bookmark">
			【MySQL】窗口函数详解（概念&#43;练习&#43;实战）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. SQL窗口函数1.1 窗口函数概念1.2 窗口函数语法1.3 常见窗口函数1.3.1 聚合窗口函数1.3.2 专用窗口函数 1.4 窗口函数性能比较 2. LeetCode 例题2.1 LeetCode SQL 178：分数排名2.2 LeetCode SQL 184：最高工资2.3 LeetCode SQL 185：前三工资 3. 项目实战3.1 需求描述3.2 SQL 实战 4. 补充与总结4.1 `ROWS BETWEEN`子句常见关键字含义4.2 如何理解窗口函数的“窗口”？4.3 总结 参考资料 牛逼的兄弟两个月前教了我一招...... 前言 2023年12月下旬，广东终于冷了！回想直到12月15那天，依然穿着短袖上班，吹着风扇空调睡觉… 哈哈，这是截至发文时的一些感受与题外话。天气是冷了，但心中依然热情似火，一是工作业务上又有稍微复杂的业务，有挑战；二是虽然有挑战，但想起牛逼的兄弟@CaptinKoo两个月前教了我一招：SQL窗口函数，业务难题迎刃而解！趁着这次解决难题的热度，将本次学到的窗口函数知识点以及项目实战记录下来，供各位分享。
我个人学习窗口函数主要有两个用处：一是对现有SQL知识的拓展，二是能使用窗口函数对一些特定场景做SQL简化，解决复杂问题。
但在正式开始之前，得事先说明一个前提：
前提
窗口函数是 Mysql 8 的新特性。本文的学习与演示，都基于Mysql 8学习窗口函数，建议有一定的SQL基础 学习目标
学习并了解SQL窗口函数相关概念能使用SQL窗口函数解决部分业务场景题目，项目实战若实际业务用得少，那上述知识了解一下即可，建议收藏本文，用到的时候可以翻出来参考 下面我们开始！
1. SQL窗口函数 这一小节我们介绍窗口函数的一些概念。
1.1 窗口函数概念 概念
窗口函数，也叫OLAP函数（Online Anallytical Processing，联机分析处理），可以对数据库数据进行实时分析处理。
窗口函数在MySQL 8中引入，是Mysql 8的新特性。是一种主要用于数据分析、特定字段分组等的一种特殊的函数。
常见使用场景
数据分析，如排名、排序、分组统计、计算、前后值比较等对某些分组场景简化SQL，提升效率常用于子查询，将一些复杂条件简化 1.2 窗口函数语法 窗口函数的语法如下：
窗口函数([参数]) OVER ( [PARTITION BY &lt;分组列&gt;] [ORDER BY &lt;排序列 ASC/DESC&gt;] [ROWS BETWEEN 开始行 AND 结束行] ) PARTITION BY 子句用于指定分组列，关键字：PARTITION BY 。ORDER BY 子句用于指定排序列，关键字ORDER BY 。ROWS BETWEEN 子句用于指定窗口的范围，关键字ROWS BETWEEN 即[开始行]、[结束行]（这部分在“补充与总结”小节中作补充详细说明）。 其中，ROWS BETWEEN 子句在实际中可能用得相对少一些，因此有部分参考资料的语法描述省略了ROWS BETWEEN 子句，主要侧重于PARTITION BY分组与ORDER BY排序：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2872d8d8b8f2bc569a1ac865662ed2ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10db253c81ea390b738363e8b0f84c21/" rel="bookmark">
			Hadoop3.x完全分布式模式下slaveDataNode节点未启动调整
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、问题重现
1、查询Hadoop版本
2、集群启动Hadoop
二、问题分析
三、Hadoop3.x的集群配置
1、停止Hadoop服务
2、配置workers
3、从节点检测
4、WebUI监控
总结
前言 在大数据的世界里，Hadoop绝对是一个值得学习的框架。关于Hadoop的知识，有很多博主和视频博主都做了很详细的教程，感兴趣的朋友甚至可以去官网看看。比如其分布式架构的实现，在这里都不在赘述，大家可以通过多种途径进行学习。
这篇博客出现得场景缘由是最近基于Hbase2.4.11搭建完全分布式集群，集群的节点是3。至于为什么是3，主要是机器有限，而且是同一台物理主机上进行虚拟搭建的。Hbase的底层存储是存放在Hdfs中的，由此必须要安装Hadoop。
众所周知，在完全分布式环境下，我们可以只在Master节点上直接运行start-all.sh命令，整个集群都会自动启动。本文描述的是在Hadoop3.1.3的完全分布式环境下，slave节点的DataNode节点未能成功启动的问题以及通过修改配置来解决的办法，希望能帮助到遇到这个问题的朋友。请注意，由于不同的版本，可能解决办法不一致，请谨慎参考。博主就遇到过，在Hadoop2.x的配置和Hadoop3.x的配置不一致的问题。博文的参考仅限于Hadoop3.x，如果您使用的不是这个系列的版本，那么您可以去别的地方寻找答案。
一、问题重现 1、查询Hadoop版本 使用管理账号登录到系统，使用hadoop version可以查看版本。
[root@master bin]# hadoop version 可以看到输出如下：
Hadoop 3.1.3 Source code repository https://gitbox.apache.org/repos/asf/hadoop.git -r ba631c436b806728f8ec2f54ab1e289526c90579 Compiled by ztang on 2019-09-12T02:47Z Compiled with protoc 2.5.0 From source with checksum ec785077c385118ac91aadde5ec9799 This command was run using /software/hadoop/share/hadoop/common/hadoop-common-3.1.3.jar 2、集群启动Hadoop 登录master节点，进入hadoop的sbin目录，启动集群，参考命令如下：
[root@master bin]# cd /software/hadoop/sbin [root@master sbin]# ./start-all.sh 这里请注意，hadoop的安装目录，请根据实际目录进行修改，否则会影响运行。通常以上命令后会有以下输出。输出以下姓名就表示已经完成了hadoop的启动。
Starting namenodes on [master] 上一次登录：三 12月 13 11:31:20 CST 2023pts/0 上 Starting datanodes 上一次登录：三 12月 13 11:31:39 CST 2023pts/0 上 Starting secondary namenodes [master] 上一次登录：三 12月 13 11:31:41 CST 2023pts/0 上 Starting resourcemanager 上一次登录：三 12月 13 11:31:44 CST 2023pts/0 上 Starting nodemanagers 上一次登录：三 12月 13 11:31:48 CST 2023pts/0 上 如果是正常的集群启动，那么master、slave1、slave2三台机器上都会有DataNode进程。可以分别在三台机器上进行进程查询，这里使用jps命令。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10db253c81ea390b738363e8b0f84c21/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/548/">«</a>
	<span class="pagination__item pagination__item--current">549/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/550/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>