<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b637bbd80fc471e893016ce713906c62/" rel="bookmark">
			Flink SQL 实时读取 kafka 数据写入 Clickhouse —— 日志处理（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言Clickhouse 表设计adlp_log_local 本地表adlp_log 分布式表 Flink SQL 说明创建 Source Table (Kafka) 连接器表创建 Sink Table (Clickhouse) 连接器解析 Message 写入 Sink 日志查询演示总结 前言 在之前的文章中，我们总结了如何在 Django 项目中进行日志配置，以及如何在 k8s 上部署 Filebeat 采集 PVC 中的日志发送至 Kafka：
Django 日志控制台输出、文件写入按天拆分文件，自定义 Filter 增加 trace_id 以及过滤——日志处理（一）Filebeat k8s 部署（Deployment）采集 PVC 日志发送至 Kafka——日志处理（二） 本文将总结如何使用 Flink SQL 实时将 kafka 中的日志消息发送至 Clickhouse 表中。
说明
限于文章主题和篇幅，本文不会将如何部署和使用 Flink SQL, 关于这些内容过多而且网上资料也很多，就不再赘述。
本文的核心是说明如何设计 Clickhouse 表结构，以及对应的 Flink SQL 说明。
Clickhouse 表设计 上图中的JSON 内容是kafka 中的日志消息，我们需要读取该消息中的 message 字段（我们的日志信息），然后将该字段中的 time, level, func, trace_id, message 保存至 clickhouse 中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b637bbd80fc471e893016ce713906c62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c900484b0083c8617819bde125e946c/" rel="bookmark">
			【深入C&#43;&#43;】二叉搜索树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是二叉搜索树二叉搜索树的接口1.查找操作2.插入操作3.中序遍历4.删除操作 所有代码总结 什么是二叉搜索树 二叉搜索树（Binary Search Tree, BST）是一种特殊的二叉树，其每个节点最多有两个子节点，分别称为左子节点和右子节点。BST具有以下性质：
左子树的所有节点值都小于根节点的值：即对于每一个节点，其左子树上所有节点的值都比该节点的值小。右子树的所有节点值都大于根节点的值：即对于每一个节点，其右子树上所有节点的值都比该节点的值大。每个子树也是二叉搜索树：这意味着BST的定义在每个节点的子树上都成立。 形如下面这棵树就是一颗二叉搜索树：
8 / \ 3 10 / \ \ 1 6 14 / \ / 4 7 13 二叉搜索树的接口 要写二叉搜索树的接口，我们先得定义一颗二叉搜索树：
定义二叉搜索树的节点：
template&lt;class K&gt; struct BSTreeNode { K _key; BSTreeNode&lt;K&gt;* _left; BSTreeNode&lt;K&gt;* _right; BSTreeNode(const K&amp; key):_key(key), _left(nullptr), _right(nullptr){} }; 定义二叉搜索树：
template&lt;class K&gt; class BSTree { typedef BSTreeNode&lt;K&gt; Node; public: private: Node* _root = nullptr; }; 1.查找操作 由于二叉搜索树的性质，所以这里我们可以直接用while循环来查找，不需要进行递归来查找：
bool Find(const K&amp; key) { Node* cur = _root; while (cur) { //小于当前节点，在左子树 if (cur-&gt;_key &gt; key)cur = cur-&gt;_left; //大于当前节点，在右子树 else if (cur-&gt;_key &lt; key) cur = cur-&gt;_right; //等于当前节点，返回true else return true; } return false; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c900484b0083c8617819bde125e946c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f58b96941a24f39a03b49ac225c0c1cd/" rel="bookmark">
			嵌入式C&#43;&#43;、InfluxDB、Spark、MQTT协议、和Dash：树莓派集群物联网数据中心设计与实现（代码示例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 项目概述 随着物联网技术的快速发展,如何高效地收集、存储和分析海量IoT设备数据成为一个重要课题。本文介绍了一个基于树莓派集群搭建的小型物联网数据中心,实现了从数据采集到分析可视化的完整流程。
该系统采用轻量级组件,适合资源受限的边缘计算环境。主要功能包括:
通过MQTT协议采集传感器数据使用Kafka进行数据传输InfluxDB存储时序数据Spark进行数据处理Grafana可视化展示Flask提供Web API接口 2. 系统设计 2.1 硬件架构 3个树莓派4B作为工作节点1个树莓派4B作为主节点1个外接硬盘用于数据存储 2.2 软件架构 数据采集:Mosquitto MQTT Broker数据传输:Apache Kafka数据存储:InfluxDB数据处理:Apache Spark数据分析:Jupyter Notebook, Pandas可视化:Grafana应用层:Flask 3. 代码实现 3.1 数据采集层 在数据采集层，我们使用MQTT协议来收集传感器数据。MQTT是一种轻量级的发布/订阅消息传输协议，非常适合物联网应用。
import paho.mqtt.client as mqtt import json import logging class IoTDataCollector: def __init__(self, broker_address, broker_port=1883): self.client = mqtt.Client() self.client.on_connect = self._on_connect self.client.on_message = self._on_message self.broker_address = broker_address self.broker_port = broker_port self.logger = logging.getLogger(__name__) def _on_connect(self, client, userdata, flags, rc): """ 当客户端连接到MQTT代理时调用此函数。 它订阅了所有传感器主题。 """ self.logger.info(f"Connected with result code {rc}"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f58b96941a24f39a03b49ac225c0c1cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48ccb29b8979f3679527e76787a383db/" rel="bookmark">
			Java 集合框架：Java 中的优先级队列 PriorityQueue 的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是栗筝i，这篇文章是我的 “栗筝i 的 Java 技术栈” 专栏的第 018 篇文章，在 “栗筝i 的 Java 技术栈” 这个专栏中我会持续为大家更新 Java 技术相关全套技术栈内容。专栏的主要目标是已经有一定 Java 开发经验，并希望进一步完善自己对整个 Java 技术体系来充实自己的技术栈的同学。与此同时，本专栏的所有文章，也都会准备充足的代码示例和完善的知识点梳理，因此也十分适合零基础的小白和要准备工作面试的同学学习。当然，我也会在必要的时候进行相关技术深度的技术解读，相信即使是拥有多年 Java 开发经验的从业者和大佬们也会有所收获并找到乐趣。
–
在许多应用程序中，数据的优先级排序对于实现高效的数据处理和任务调度至关重要。Java 中的 PriorityQueue 是一种基于堆的数据结构，广泛用于需要优先级排序的场景。与传统的队列不同，优先级队列可以确保在队列中的元素按照其优先级顺序进行处理，而不是按照插入顺序。本文将深入探讨 PriorityQueue 的实现，包括其基本概念、底层数据结构、各种操作的实现细节，并展示一些实际应用场景和简单用例，帮助你更好地理解和使用这一强大的数据结构。
文章目录 1、PriorityQueue 概述1.1、优先级队列 介绍1.2、堆排序与最小堆 2、PriorityQueue 底层实现2.1、PriorityQueue 数据结构2.2、插入操作2.3、删除操作2.4、搜索操作 3、PriorityQueue 的使用3.1、PriorityQueue 的使用场景3.2、PriorityQueue 的简单用例 1、PriorityQueue 概述 1.1、优先级队列 介绍 PriorityQueue 在 Java 中是一种基于堆（Heap）数据结构实现的优先级队列。堆是一种特殊的完全二叉树，分为最小堆和最大堆。
在最小堆中，每个节点的值都小于或等于其子节点的值；在最大堆中，每个节点的值都大于或等于其子节点的值。 Java 的 PriorityQueue 使用最小堆实现，因此队列头部总是优先级最高（值最小）的元素。
1.2、堆排序与最小堆 堆排序（Heapsort）是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树（树的所有级别都被完全填充，除了最低级别的节点从尽可能左侧填充之外）。
大根堆的要求是每个节点的值都不大于其父节点的值，即 A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。
最小堆是一棵完全二叉树，非叶子结点的值不大于左孩子和右孩子的值。
2、PriorityQueue 底层实现 2.1、PriorityQueue 数据结构 在 Java 中 PriorityQueue 用数组来表示堆，i 结点的父结点下标就为 (i – 1) / 2。它的左右子结点下标分别为 2 * i + 1 和 2 * i + 2。如第 0 个结点左右子结点下标分别为 1 和2。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48ccb29b8979f3679527e76787a383db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9bc2edbf172c627e61226883a107a1e/" rel="bookmark">
			学生成绩管理系统(C语言)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统分析 1. 主菜单的实现 2. 增加人员功能的实现 3. 删除数据功能的实现 4. 编辑人员功能的实现 5. 排序功能的实现 6. 输出功能 7. 查找信息功能 具体代码 #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #define SIZE 100000 typedef struct tagStudent { int n; /*顺序号*/ int nNum; /*学号*/ char name[10]; /*姓名*/ int iCn; /*语文成绩*/ int iMaths; /*数学成绩*/ int iEn; /*英语成绩*/ int iPhy; /*物理成绩*/ int iCom; /*计算机成绩*/ float fAvage; /*平均成绩*/ } Student; Student stu[SIZE]; /*录入数据*/ void Student_Input() { int i,p; FILE *fp; fp=fopen("studentfile.dat","wb"); for(i=0;i&lt;SIZE;i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9bc2edbf172c627e61226883a107a1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b01820078f7ef4f0df88552915cc9827/" rel="bookmark">
			数据结构：单调栈、单调队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		迈向光明之路，注定荆棘丛生
单调队列、单调栈 一、单调队列：（一）概念及作用：（二）维护演示：（三）代码演示：（四）例题剖析：剖析：代码演示： 二、单调栈：（一）概念及作用：（二）维护演示：（三）代码演示：（四）例题剖析：代码演示： 三、结束语： 一、单调队列： （一）概念及作用： 维护区间的最大值（最小值），单调队列本质上是一个单调递减（单调递增）序列。
（二）维护演示： 下面，在一个数组中以区间为三，我们维护一个单调递减的单调队列。
（三）代码演示： int main() { int n, k; scanf("%d%d", &amp;n, &amp;k); vector&lt;int&gt; arr; deque&lt;int&gt; q; for (int i = 0, a; i &lt; n; i++) { scanf("%d", &amp;a); arr.push_back(a); } output(arr); for (int i = 0; i &lt; n; i++) { while (!empty(q) &amp;&amp; arr[q.back()] &gt; arr[i]) { q.pop_back(); } q.push_back(i); if (i - q.front() == k) q.pop_front(); printf("[%d, %d] : min = %d\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b01820078f7ef4f0df88552915cc9827/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91dde02a64982077a5387533fdb2f176/" rel="bookmark">
			【轻松拿捏】java中为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝区别是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java中为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝区别是什么？
一、如何在Java中实现对象克隆
1.1 浅拷贝
1.2 深拷贝
1.3 区别总结
二、面试回答技巧
1. 定义克隆及其用途
2. 解释浅拷贝和深拷贝
3. 具体实现浅拷贝和深拷贝
浅拷贝示例：
深拷贝示例：
4. 举例说明
5. 总结
🎈边走、边悟🎈迟早会好
在Java中，使用克隆的原因与其他编程语言类似，主要包括以下几点：
避免修改原对象：在需要修改对象但又不希望改变原对象时，通过克隆可以操作副本而不影响原对象。节省时间和资源：创建一个新对象的代价较高时，克隆可以节省时间和资源。实现历史记录和回滚：保存对象的克隆可以实现历史记录和回滚功能。 一、如何在Java中实现对象克隆 在Java中，对象克隆主要通过实现 Cloneable 接口并覆盖clone() 方法来实现。Java中的克隆也有浅拷贝和深拷贝两种方式。
1.1 浅拷贝 浅拷贝创建一个新对象，但只复制对象的引用而不复制实际的对象数据。也就是说，浅拷贝的对象和原对象共享引用类型的成员变量。
实现浅拷贝的方式：
实现 Cloneable 接口。覆盖 clone() 方法。 class Person implements Cloneable { String name; int age; public Person(String name, int age) { this.name = name; this.age = age; } @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); // 调用 Object 类的 clone 方法 } @Override public String toString() { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91dde02a64982077a5387533fdb2f176/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/615cda55fd930830dc4fee677bc1f228/" rel="bookmark">
			【云原生】Prometheus 服务自动发现使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、Prometheus常规服务监控使用现状​​​​​​​
2.1 Prometheus监控架构图
2.2 Prometheus服务自动发现的解决方案
三、Prometheus服务自动发现介绍
3.1 什么是Prometheus服务自动发现
3.2 Prometheus自动服务发现策略
3.3 Prometheus自动服务发现应用场景
3.4 Prometheus自动服务发现原理
四、Prometheus 基于文件的服务发现​​​​​​​
4.1 Prometheus基于文件服务发现介绍
4.2 Prometheus基于文件服务发现使用场景
4.3 基于文件服务发现配置说明
4.3.1 核心配置文件模板
4.3.2 核心配置文件支持格式
4.3.3 基于文件服务发现动态更新机制
4.4 基于文件服务发现操作实践
4.4.1 环境准备
4.4.2 添加Prometheus配置信息
4.4.3 编辑自动发现文档
4.4.4 重新加载Prometheus服务
4.4.5 自动发现文件添加新的监控指标
五、Prometheus基于Consul的服务自动发现
5.1 Prometheus基于Consul的服务发现介绍
5.2 Prometheus基于Consul的服务发现工作原理
5.3 基于Consul的服务发现使用场景
5.4 基于Consul的服务发现操作实践
5.4.1 安装Consul服务
5.4.2 访问Consul控制台
5.4.3 注册服务到Consul
5.4.4 配置Prometheus文件
5.4.5 重新加载Prometheus服务
5.4.6 注册consul服务实现自动发现
六、写在文末
一、前言 在之前分享的文章中，详细介绍了Prometheus的使用，以及使用Prometheus结合各类exporter监控不同的服务，但是细心的同学可能会发现，每次接入一种新的待监控的组件时，需要在Prometheus的配置文件中添加新的配置信息，然后重启Prometheus的服务，这个过程多少显得有点繁琐，针对这个问题有没有什么解决办法呢？答案是肯定的，这就是Prometheus的服务自动发现机制。
二、Prometheus常规服务监控使用现状 2.1 Prometheus监控架构图 如下是一张在日常使用Prometheus进行服务的配置监控的架构图，通常来说，为了监控某种服务指标，需要做如下几步操作：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/615cda55fd930830dc4fee677bc1f228/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed8827ff672aa13c0bc9429a00e3a7ba/" rel="bookmark">
			【数据结构进阶】二叉搜索树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥个人主页： Forcible Bug Maker
🔥专栏： C++ || 数据结构
目录 🌈前言🔥二叉搜索树🔥 二叉搜索树的实现==Insert（插入）====find（查找）====erase(删除)====destroy（析构）====InOrder（中序遍历）====拷贝构造== 🔥二叉搜索树的应用🔥二叉搜索树的性能🌈结语 🌈前言 本篇博客主要内容：二叉搜索树的介绍及自实现。
基础的二叉树在前面的C数据结构阶段已经讲过（初阶数据结构之—二叉树链式结构）。之前因为用C语言的话，实现更高级数据结构比较困难，所以并没有往后展开。到了现在，已经有了一定的C++功底，就可以开启我们数据结构进阶部分的内容了。对于二叉搜索树的特性了解，有助于后续更好的理解map和set的特性。本节课作为学习更高阶数据结构的基础，对后续学习来说至关重要。
🔥二叉搜索树 二叉搜索树的概念：
二叉搜索树又称二叉排序树，它或者是一颗空树，或者具有以下三种性质：
若它的左子树不为空，则左子树上的所有结点都小于根节点的值若它的右子树不为空，则右子树上的所有结点都大于根节点的值它的左右子树也分别为二叉搜索树 二叉搜索树的中序遍历是有序的。
🔥 二叉搜索树的实现 以下是需要实现的二叉搜索树的头文件内容
#pragma once #include&lt;iostream&gt; namespace ForcibleBugMaker { template&lt;class K&gt; struct BSTreeNode { BSTreeNode&lt;K&gt;(const K&amp; k = K()) :_key(k) , _left(nullptr) , _right(nullptr) {} K _key; BSTreeNode&lt;K&gt;* _left; BSTreeNode&lt;K&gt;* _right; }; template&lt;class K&gt; class BSTree { typedef BSTreeNode&lt;K&gt; Node; public: BSTree() = default; BSTree(const BSTree&lt;K&gt;&amp; t); bool Insert(const K&amp; key); Node* Find(const K&amp; key); bool Erase(const K&amp; key); ~BSTree(); void InOrder(); private: Node* _root = nullptr; }; } 二叉搜索树的结点中有三个成员变量，分别是
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed8827ff672aa13c0bc9429a00e3a7ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98b86513cdb65d928998631d359a1db2/" rel="bookmark">
			【07】LLaMA-Factory微调大模型——微调模型导出与微调参数分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上文介绍了如何对微调后的模型进行使用与简单评估。本文将介绍对微调后的模型进行导出的过程。
一、llama-3微调后的模型导出 首先进入虚拟环境，打开LLaMA-Factory的webui页面
conda activate GLM cd LLaMA-Factory llamafactory-cli webui 之后，选择微调后模型对应的检查点路径文件，设置最大分块的大小，建议2-5GB，选择导出设备的类型并对导出目录进行指定。
完成配置后开始导出模型
模型导出后，可在对应的路径下查看其参数详细情况
二、调用导出后的模型 在LLaMA-Factory的webui页面中选择chat标签，模型路径输入导出后模型的绝对路径，从而加载模型机械能对话
模型成功加载后，即可使用问答框进行应用，至此导出后的模型可应用于实际的生成环境之中
使用测试用例进行分析，可发现与模型微调评估的效果一致，模型导出与应用完成
三、模型微调参数分析 模型微调应用，参数的选择极为关键，具体参数分析可见以下这篇博客
LLaMA-Factory参数的解答（命令，单卡，预训练）_llama-factory 增量预训练-CSDN博客https://blog.csdn.net/m0_69655483/article/details/138229566?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-138229566-blog-139495955.235%5Ev43%5Epc_blog_bottom_relevance_base2&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-138229566-blog-139495955.235%5Ev43%5Epc_blog_bottom_relevance_base2&amp;utm_relevant_index=1现对关键的几个参数进行分析
（1）finetuning_type lora
使用LoRA（Low-Rank Adaptation）作为微调类型。
其他参数
​ 1.Full：这种方式就是从头到尾完全训练一个模型。想象一下，你有一块白纸，你要在上面画出一幅完整的画作，这就是Full Training。你从零开始，逐步训练模型，直到它能够完成你想要的任务。
​ 2.Freeze：这种方式有点像是在一幅半完成的画上继续作画。在模型中，有些部分（通常是模型的初级部分，如输入层或底层特征提取部分）是已经训练好的，这部分会被“冻结”，不再在训练过程中更新。你只更新模型的其他部分，这样可以节省训练时间和资源。
​ 3.LoRA：这是一种比较新的技术，全称是“Low-Rank Adaptation”。可以理解为一种轻量级的模型调整方式。它主要是在模型的某些核心部分插入小的、低秩的矩阵，通过调整这些小矩阵来实现对整个模型的微调。这种方法不需要对原始模型的大部分参数进行重训练，从而可以在不牺牲太多性能的情况下，快速适应新的任务或数据。
​ 4.QLoRA：这是在LoRA的基础上进一步发展的一种方法。它使用量化技术（也就是用更少的比特来表示每个数字），来进一步减少模型调整过程中需要的计算资源和存储空间。这样做可以使得模型更加高效，尤其是在资源有限的设备上运行时。
（2）gradient_accumulation_steps 梯度累积步数，用于在更新模型前累积更多的梯度，有助于使用较小的批次大小训练大模型。选择多少步骤进行梯度累积取决于你的具体需求和硬件限制。一般来说，步数越多，模拟的批量大小就越大，但同时每次更新权重的间隔也更长，可能会影响训练速度和效率。
（3）lr_scheduler_type
学习率调度器类型
linear（线性）: 描述：学习率从一个较高的初始值开始，然后随着时间线性地减少到一个较低的值。 使用场景：当你想要让模型在训练早期快速学习，然后逐渐减慢学习速度以稳定收敛时使用。 cosine（余弦）: 描述：学习率按照余弦曲线的形状进行周期性调整，这种周期性的起伏有助于模型在不同的训练阶段探索参数空间。 使用场景：在需要模型在训练过程中不断找到新解的复杂任务中使用，比如大规模的图像或文本处理。 cosine_with_restarts（带重启的余弦）: 描述：这是余弦调整的一种变体，每当学习率达到一个周期的最低点时，会突然重置到最高点，然后再次减少。 使用场景：适用于需要模型从局部最优解中跳出来，尝试寻找更好全局解的情况。 polynomial（多项式）: 描述：学习率按照一个多项式函数减少，通常是一个幂次递减的形式。 使用场景：当你需要更精细控制学习率减少速度时使用，适用于任务比较复杂，需要精细调优的模型。 constant（常数）: 描述：学习率保持不变。 使用场景：简单任务或者小数据集，模型容易训练到足够好的性能时使用。 constant_with_warmup（带预热的常数）: 描述：开始时使用较低的学习率“预热”模型，然后切换到一个固定的较高学习率。 使用场景：在训练大型模型或复杂任务时，帮助模型稳定地开始学习，避免一开始就进行大的权重调整。 inverse_sqrt（逆平方根）: 描述：学习率随训练步数的增加按逆平方根递减。 使用场景：常用于自然语言处理中，特别是在训练Transformer模型时，帮助模型在训练后期进行细微的调整。 reduce_lr_on_plateau（在平台期降低学习率）: 描述：当模型的验证性能不再提升时，自动减少学习率。 使用场景：适用于几乎所有类型的任务，特别是当模型很难进一步提高性能时，可以帮助模型继续优化和提升。 （4）warmup_steps
学习率预热步数。
预热步数（Warmup Steps）：
这是模型训练初期用于逐渐增加学习率的步骤数。在这个阶段，学习率从一个很小的值（或者接近于零）开始，逐渐增加到设定的初始学习率。这个过程可以帮助模型在训练初期避免因为学习率过高而导致的不稳定，比如参数更新过大，从而有助于模型更平滑地适应训练数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98b86513cdb65d928998631d359a1db2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c0f275ee1bc76ee9da5067fed4a4c22/" rel="bookmark">
			【Linux】编辑器vscode与linux的联动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.vscode简单学习 vscode是编辑器，可以写各种语言的程序
下载链接：Download Visual Studio Code - Mac, Linux, Windows
来用一下vscode 我们保存了就能在我们的那个文件夹里面看到这个
这个就是编辑器，跟我们的文本文件好像差不多！！！
接下来我们要使用vscode和我们的linux云服务器进行联动
这个时候我们需要安装一个插件
我们下载插件就得选左边这个
我们搜索一个插件
然后安装
我们往下翻
这个时候我们按F1
要不要记录这个远端机的账户密码
搞好了之后我们左边就多了一个这个
有点慢，没有显示我们的主机，我们可以退出重进
进去就看到了
我们右键
接下来我们打开Xshell
我们使用vscode打开一个文件夹
我们按确定，又要输入密码
创建一个main.c的文件
我们按下ctrl+s，我们去xshell下面看看
怎么样 ，还需要编译，我们在vscode下面按ctrl+波浪号，就能打开vscode下面的终端
跟我的xshell的好像一样啊
这里就能直接编译
vscode为什么能连接上我们的云服务器，主要是因为在我们的家目录有下面这个文件
2.插件推荐 vscode非常强大，主要是它的插件太厉害了
这个在登录云服务器的时候装，就会把这个东西安装到云服务器里面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad5419df6476a0855d2342a4c61070c4/" rel="bookmark">
			lua 实现 函数 判断两个时间戳是否在同一天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数用于判断两个时间戳是否在同一天。下面是对代码的详细解释：
### 函数参数
- `stampA` 和 `stampB`：两个时间戳，用于比较。- `resetInfo`：一个可选参数，包含小时、分钟和秒数，用于调整时间戳。 ### 函数实现步骤
1. **参数校验**：使用 `assert` 函数确保 `stampA` 和 `stampB` 都不为 `nil`。如果任一参数为 `nil`，则抛出错误信息。2. **时间戳转换**：调用 `TimeUtil:toInt` 方法将时间戳转换为整数。3. **时间戳排序**：确保 `stampA` 小于等于 `stampB`，如果不是则交换它们的值。4. **时间戳调整**：如果 `resetInfo` 参数存在，则根据 `resetInfo` 中的小时、分钟和秒数调整 `stampA` 和 `stampB`。5. **时间戳转换为日期**：调用 `TimeUtil:fixTimeZoneFor_LUA_OS_DATE` 方法将时间戳转换为日期表（`*t` 格式），分别得到 `dateA` 和 `dateB`。6. **日期比较**：检查 `dateA` 和 `dateB` 是否在同一天，即它们的 `day`、`month` 和 `year` 是否相同。如果相同则返回 `true`，否则返回 `false`。 --[[ @desc 是否是同一天 @param stampA 时间戳A @param stampB 时间戳B @param resetInfo[optional] 重置时间。比如12点重置，那么11点和13点就不是同一天，而23点和第二天11点是同一天。默认为hour=0,min=0,sec=0 ]] function TimeUtil:isSameDay(stampA, stampB, resetInfo) assert(stampA ~= nil, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad5419df6476a0855d2342a4c61070c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/526180d5dbf2786eddca5ebb91a8b814/" rel="bookmark">
			爬虫自己做的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.urllib 1.1基本使用 1.2 下载（图片，页面，视频） 1.3 get 1.3.1 quote 中文变成对应uncode编码 当url 的wd='中文时' quote是将中文变成对应uncode编码 然后拼接成完整的url
1.3.2urlencode方法 wd有多个参数 1.3.3ajas get实例 爬取豆瓣电影单页 1.因为是get所以才可以用get请求方式，找到含有所有信息的接口
总结: 1.导包
2.url 因为是get所以才可以用get请求方式，找到含有所有信息的接口
3.headers
4.请求对象的设置
5.获取请求相应 6.读要注意编码格式 7.书写，在书写时应该提前查看html是什么格式
1.3.4 多页 写代码需要什么就导入什么包 思路：
1.有十个url ，每个url形成，过程一样所以写入函数
2.，每个ur都要l获取相应，相应中步骤也一样
3.书写，每个url也都要创建一个文件来书写
post一样的思路，重点 url
1.4 post 如果html是josn格式，那么还要
1.5异常一般 try catch 1.5.1 http.error
1.5.2 url.error
1.6 爬取有登录的网站（cookie） 五步骤一样只有headers有改变
①：里面有自己登陆过的信息 重点 但每次登录这个值都会不一样
②：这是从哪个地址访问进来的，图片的反爬会用到
1.6 handler 防止ip禁止封住 1.7 代理 ip+端口号 1.8 代理池 多个代理组成的数组，利用随机数
总结：用代理的时候首先写代理ip，然后才是爬虫的步骤，关键是request后面是代理的三步
2解析 2.1 xpath 不用安装插件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/526180d5dbf2786eddca5ebb91a8b814/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d186fc6cc7361279347a78c6658b312/" rel="bookmark">
			c语言——运算符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.运算符的简介 1.运算符的定义：运算符就是在c语言中程序执行运算的逻辑符号。
优先级
运算符
名称或含义
使用形式
结合方向
说明
1
[]
数组下标
数组名[常量表达式]
左到右
--
()
圆括号
(表达式）/函数名(形参表)
--
.
成员选择（对象）
对象.成员名
--
-&gt;
成员选择（指针）
对象指针-&gt;成员名
--
2
-
负号运算符
-表达式
右到左
单目运算符
~
按位取反运算符
~表达式
++
自增运算符
++变量名/变量名++
--
自减运算符
--变量名/变量名--
*
取值运算符
*指针变量
&amp;
取地址运算符
&amp;变量名
!
逻辑非运算符
!表达式
(类型)
强制类型转换
(数据类型)表达式
--
sizeof
长度运算符
sizeof(表达式)
--
3
/
除
表达式/表达式
左到右
双目运算符
*
乘
表达式*表达式
%
余数（取模）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d186fc6cc7361279347a78c6658b312/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c1c839458c86d127cb2881c2a541248/" rel="bookmark">
			C&#43;&#43;图论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法可以发掘本质，如：
一，若干师傅和徒弟互有好感，有好感的师徒可以结对学习。师傅和徒弟都只能参加一个对子。如何让对子最多。
二，有无限多1X2和2X1的骨牌，某个棋盘若干格子坏了，如何在没有坏的格子放足够多骨牌。
三，某个单色图，1表示前前景，0表示后景色。每次操作可以将一个1，变成0。如何在最少得操作情况下，使得没有两个1相邻（四连通）。
四，若干路人，有些人是熟人，如何选出最多的人参加实验。为了避免熟人影响实验的效果，参加的人不能是熟人。
一二是二分图的最大匹配，三是二分图的最小点覆盖，四是二分图最大独立集。 而这三者是等效问题。
子分类 深度优先搜索汇总
广度（宽度）优先搜索 C++算法：广度优先搜索(BFS)的原理和实现
并集查找 C++二分查找或并集查找：交换得到字典序最小的数组
【图论】【并集查找】【C++算法】928. 尽量减少恶意软件的传播 II
【广度优先搜索】【图论】【并集查找】2493. 将节点分成尽可能多的组
最短路径 C++算法：多源最短路径的原理及实现
C++算法：存在负权边的单源最短路径的原理和实现
动态规划 多源路径 字典树 LeetCode2977:转换字符串的最小成本
【单源最短路 图论】882. 细分图中的可到达节点
暂无题解：
2203
最小生成树 【图轮】【 最小生成树】【 并集查找】1489. 找到最小生成树里的关键边和伪关键边
拓扑排序 【图论】【拓扑排序】1857. 有向图中最大颜色值
【拓扑排序】【 图论】1203. 项目管理
【图论】【树】 【拓扑排序】2603. 收集树中金币
【逆向思考 】【拓扑排序】1591. 奇怪的打印机 II
暂无题解：2050 2392
树 【图论 深度优先搜索】树的直径
换根法
【深度优先搜索】【C++算法】834 树中距离之和
【图论】【深度优先搜索】【换根法】2858. 可以到达每一个节点的最少边反转次数
【树上倍增】【割点】 【换根法】3067. 在带权树网络中统计可连接服务器对数目
树的路径
【深度优先搜索】【树】【状态压缩】2791. 树中可以形成回文的路径数
欧拉路径、欧拉环 【深度优先搜索】【图论】【推荐】332. 重新安排行程
【数学】【深度优先搜索】【图论】【欧拉环路】753. 破解保险箱
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c1c839458c86d127cb2881c2a541248/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89ee5b27f14a8d10887dfc60fbf17cc2/" rel="bookmark">
			C&#43;&#43;背包问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文涉及知识点 动态规划汇总
状态机dp
01背包 有n件物品，体积分别是v[i]，价值分别是w[i]，有个包的容积是bv。如何选择物品使得，在总体积不超过vb的前提下，让总价值最大。
动态规划的状态表示 dp[i][j] 表示处理完前i件物品，占用体积是j的最大价值。
如果不用滚动向量，空间复杂度是O(n × \times ×bv)
动态规划的状态方程 如果选择选择标为i的物品：
MaxSelf(dp[i+1][j+v[i]] ,dp[i][j]+w[i])
如果不选择下标为i的物品：
MaxSelf(dp[i+1][j],dp[i][j])
转移方程的时间复杂度为O(1)
故总时间复杂度为：O(n × \times ×bv)
动态规划的初始状态 全为0。
动态规划的填表顺序 依次枚举各物品。
动态规划的返回值 dp.back()的最大值。
多重背包、完全背包转化成01背包 多重背包：每件物品有多件n[i]。
完全背包：每件物品无限。
完全背包：我们可以把物品拆分1 + 2 + 4+ 8 + ⋯ \cdots ⋯ 这样时间复杂是O(n × \times ×bv × \times × logmax)
多重背包假定某个物品有x件：
拆分成：1+2+4+8 + ⋯ \cdots ⋯ + y
y = x - (1 + 2+4+8 ⋯ \cdots ⋯) ,y &gt; 0，y尽可能得小 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89ee5b27f14a8d10887dfc60fbf17cc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d146eba844e44151e4a782119cbab374/" rel="bookmark">
			【超详细】Python datetime（当前日期、时间戳转换、前一天日期等）【附：时区原理详解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 相关文献当前时间前一天日期、后一天日期东八区（北京）时间时间戳转换datetime -&gt; strstr -&gt; datetimedatetime -&gt; timestamp(时间戳)timestamp -&gt; datetime 获取日期中的年、季度、月、周、日、小时、分、秒等时区原理时区问题复杂性的来源深入理解 datetime 的坑不同函数时区标准不同timezone 时区偏移以西为正，以东为负，和ISO标准相反笔者建议 datetime 源码解读pytz 源码解读 作者：小猪快跑 基础数学&amp;计算数学，从事优化领域6年+，主要研究方向：MIP求解器、整数规划、随机规划、智能优化算法
python3 的时区是一个很容易出错的地方。本篇将从原理层面剖析时区概念，让读者真正学懂时区，不踩坑。
如有错误，欢迎指正。如有更好的算法，也欢迎交流！！！——@小猪快跑
相关文献 datetime — Basic date and time types — Python 3.12.4 documentation简述时区问题复杂性来源（Python 版） - 知乎 (zhihu.com) 当前时间 from datetime import datetime print(datetime.now()) # 2024-07-12 14:39:59.531525 前一天日期、后一天日期 from datetime import datetime, timedelta dt = datetime(2024, 1, 1) dt + timedelta(1) # datetime.datetime(2024, 1, 2, 0, 0) dt - timedelta(1) # datetime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d146eba844e44151e4a782119cbab374/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e2ab281302759e1e512f5c5c7c61b1e/" rel="bookmark">
			mybatis-config.xml中的environments是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 MyBatis 的配置文件 mybatis-config.xml 中，environments 元素用于配置 MyBatis 应用程序的环境信息，主要包括数据源和事务管理器的配置。
功能和作用 数据源配置：在 environments 中可以配置一个或多个数据库环境（例如开发环境、测试环境、生产环境），每个环境可以指定一个数据源（如连接池），用于与数据库进行交互。
事务管理器配置：每个环境可以配置一个事务管理器，用于管理 MyBatis 的事务。事务管理器负责管理事务的开始、提交、回滚等操作，确保数据库操作的一致性和可靠性。
配置示例 以下是一个简单的 environments 配置示例：
&lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mydatabase"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="password"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;environments&gt; 元素指定了默认的环境为 development，可以定义多个环境，每个环境有一个唯一的 id。&lt;transactionManager&gt; 元素指定了事务管理器的类型，这里使用的是 JDBC 事务管理器。&lt;dataSource&gt; 元素指定了数据源的类型为 POOLED（连接池），并提供了连接数据库所需的相关属性。 使用方法 在 MyBatis 的映射器（Mapper）文件中，可以通过指定 environment 属性来选择使用的环境，例如：
&lt;mapper namespace="com.example.mapper.UserMapper" environment="development"&gt; &lt;!-- mapper configuration here --&gt; &lt;/mapper&gt; 这样配置之后，MyBatis 将会使用 development 环境中配置的数据源和事务管理器来执行 SQL 语句。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e2ab281302759e1e512f5c5c7c61b1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5684f59c7472f52d1373fe2446e2e81b/" rel="bookmark">
			【C&#43;&#43;】stack与queue的使用以及模拟实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		stack与queue的使用以及模拟实现 stack的使用与模拟实现stack的介绍stack的使用Member functions（成员函数）构造函数emptypushsizetoppop Non-member function overloads（非成员函数重载）relational operators (stack) stack的模拟实现 queue的使用与模拟实现queue的介绍queue的使用Member functions（成员函数）构造函数emptypushpopsizefrontback Non-member function overloads（非成员函数） queue的模拟实现 stack的使用与模拟实现 stack的介绍 std::stacktemplate &lt;class T, class Container = deque &gt; class stack;LIFO stack（后进先出的栈） 【说明】
1.stack是一种容器适配器，专门用在具有后进先出操作的上下文环境中，其删除只能从容器的一端进行元素的插入与提取操作。
2.stack是作为容器适配器被实现的，容器适配器即使对特定类封装作为其底层的容器，并提供一组特定的成员函数来访问其元素，将特定类作为其底层的，元素特定容器的尾部（即栈顶）被压入和弹出。
3.stack的底层容器可以使任何标准的容器类模板或者一些其他的容器类，这些容器类应该支持以下操作：
empty：判空操作 back：获取尾部元素操作 push_back：尾部插入元素操作 pop_back：尾部删除元素操作 标准容器vector、deque、list均符合这些需求，默认情况下，如果没有stack指定特定的底层容器，默认情况下使用deque。 stack的使用 Member functions（成员函数） 构造函数 std::stack::stackexplicit stack (const container_type&amp; ctnr = container_type());栈的构造 stack&lt;int&gt; st1; empty std::stack::emptybool empty() const;检测stack是否为空 stack&lt;int&gt; st1; if (st1.empty()) { cout &lt;&lt; " true" &lt;&lt; endl; } push std::stack::pushvoid push (const value_type&amp; val);将元素val压入stack中 stack&lt;int&gt; st1; st1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5684f59c7472f52d1373fe2446e2e81b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc02cf1d78a285caa6ceed303fe0e2b9/" rel="bookmark">
			macbook配置adb环境和用adb操作安卓手机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（参考：ADB工具包的安装与使用_adb工具箱-CSDN博客）
第一步：从Android开发者网站下载Android SDK（软件开发工具包）。下载地址为：
第二步：解压下载的SDK压缩文件到某个目录中。 进入解压后的目录，找到其中的"platform-tools"文件夹。记录"platform-tools"文件夹路径：
第三步：将"platform-tools"文件夹的路径添加到系统环境变量中
1)打开终端。输入以下命令打开bash配置文件：
sudo nano ~/.bash_profile (命令解释：
sudo 表示以超级用户（管理员）权限执行后续的命令
nano 是一个简单的文本编辑器
~ 表示当前用户的主目录
.bash_profile 是一个配置文件，通常用于设置用户的环境变量和启动时执行的命令等
您可以在编辑器中对文件的内容进行编辑，完成后按 Ctrl + X 组合键，然后根据提示保存修改)
2) 在文件末尾，添加以下行：
export PATH=$PATH:/path/to/android/sdk/platform-tools (命令解释：
a，“export”是一个在类 Unix 操作系统（如 Linux、Mac OS）中的命令，用于将一个变量或函数导出到当前 shell 进程及其子进程的环境中，使得这些进程能够访问和使用该变量或函数。
例如，export VAR="value" 会将变量 VAR 及其值 "value" 导出到环境中，其他进程或脚本在运行时可以获取到这个变量的值。
b，这条命令的作用是将指定的路径 /path/to/android/sdk/platform-tools 添加到系统的环境变量 PATH 中。
环境变量 PATH 用于指定操作系统在执行命令时搜索可执行文件的目录列表。通过将新的路径添加到 PATH 中，您可以在任何位置直接运行位于该路径下的可执行文件，而无需指定完整的文件路径。
例如，如果在 /path/to/android/sdk/platform-tools 路径下有一个名为 adb 的可执行文件，在添加上述路径到 PATH 后，您可以在终端的任何位置直接输入 adb 命令来运行它，而无需输入完整的路径 /path/to/android/sdk/platform-tools/adb 。
)
将"/path/to/android/sdk/platform-tools"替换为第二步记录的"platform-tools"文件夹路径。
第四步：按Ctrl + X，然后按Y键保存更改。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc02cf1d78a285caa6ceed303fe0e2b9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/130/">«</a>
	<span class="pagination__item pagination__item--current">131/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/132/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>