<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eb35dc4734f85f127b539812097c641/" rel="bookmark">
			【Linux 文件读写&amp;描述符&amp;重定向&amp; Linux 一切皆文件&amp;缓冲区】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、文件的读写操作二、文件描述符三、文件重定向四、理解 Linux 一切皆文件五、文件缓冲区 一、文件的读写操作 文件=内容+属性
当文件没有被操作的时候，一般文件还是在磁盘当中
文件操作=文件内容的操作+文件属性的操作，文件操作有可能即改变内容，又改变属性
文件操作其实就是把内容和属性加载到内存当中
文件的系统调用函数一般有以下几个参数，pathname（对应文件路径），flags（文件打开方式），mode（指定文件的权限）。这里的 flags 不能简单当作一个整型来看，而且应该把它当作一个位图，32个 bit 位对应32种状态。打开文件时，可以传入多个参数选项，用下面的一个或者多个宏进行 “或” 运算，构成flags，调用类似下面的 show(ONE | TWO | THREE)
int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
flags参数:
O_RDONLY: 只读打开
O_WRONLY: 只写打开
O_RDWR : 读，写打开
这三个常量，必须指定一个且只能指定一个
O_CREAT : 若文件不存在，则创建它。需要使用mode选项，来指明新文件的访问权限
O_TRUNC：初始化清空文件
O_APPEND: 追加写
#define ONE (1&lt;&lt;0) // 1 #define TWO (1&lt;&lt;1) // 2 #define THREE (1&lt;&lt;2) // 4 #define FOUR (1&lt;&lt;3) // 8 void show(int flags) { if(flags&amp;ONE) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8eb35dc4734f85f127b539812097c641/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5042cb9b9fed2fdb2803b0ab53d50e6a/" rel="bookmark">
			多表联合的查询（实例）、对于前端返回数据有很多表，可以分开操作、debug调试教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024.7.13 一、 对于多表的更深层的认识1. 认识2. 多表联合查询的列子：3. 对于多表查询的进一步认识4. 在实现功能的时候，原本对于省市县这样的表，对于项目的要求，是直接全部查询出来，然后开始使用，但我想着能不能直接用树形结构来操作，然后通过递归的形式来实现，让我们看看我的成果！！4.1 其他的都不看了，直接看service：4.2 解释 for (addDistrictDTO area : allDistrict)4.3 成果！ 二、 新增1. 先看需求！2. 新增的分析（查询和上面大差不差，直接返回就行，就不提了）3. 开始开发！！4. 对于不分开，直接进行插入，我没弄出来，一直报错，有机会我会写在这，如果真有人看，能指点我一下！！！5. 优化我的代码（递归，以及两个sql操作） 三、debug调试1. 第二步，debug启动！2. 第一步，对于错误的方法和地方打断点，查看当时的值和状态。（不用像我这样，哈哈哈，我这太夸张了）3. 第三步，通过这些按钮进行控制4. 查看数据 四、感谢大佬们的文章给我的提示，也感谢该死的GPT！！五、感悟 一、 对于多表的更深层的认识 1. 认识 我今天早上，基本上一直都在进行查询的书写，写了四五个查询的接口吧，根据着页面和F12进行推断，我需要哪些表，一开始很慢，因为要去找对应的字段，需要自己写xml。后面结合gpt就快很多了（不要依赖gpt，我就是因为太依赖gpt，导致于我在一个逻辑上，没有仔细想，出错了，就问他，他给我建议，离我最初的逻辑越来越偏！！！gpt只是工具。）
2. 多表联合查询的列子： &lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="com.hengyin.ship.mapper.AddMapper"&gt; &lt;!-- Result Map 定义 --&gt; &lt;resultMap id="MaterialsResultMap" type="com.hengyin.ship.domain.Materials"&gt; &lt;result property="outTermShipBomNo" column="out_term_ship_bom_no" /&gt; &lt;result property="outTermShipBomName" column="out_term_ship_bom_name" /&gt; &lt;result property="outTermTypeName" column="out_term_type_name" /&gt; &lt;result property="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5042cb9b9fed2fdb2803b0ab53d50e6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba0509b6e16362550f65f62b49297524/" rel="bookmark">
			深入解析【C&#43;&#43; list 容器】：高效数据管理的秘密武器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. list 的介绍及使用
1.1 list 的介绍
知识点：
小李的理解：
1.2 list 的使用
1.2.1 list 的构造
知识点：
小李的理解：
代码示例：
1.2.2 list 迭代器的使用
知识点：
小李的理解：
代码示例：
1.2.3 list 的容量
知识点：
小李的理解：
代码示例：
1.2.4 list 的元素访问
知识点：
小李的理解：
代码示例：
1.2.5 list 的修改操作
知识点：
小李的理解：
代码示例：
1.2.6 list 迭代器失效
知识点：
小李的理解：
代码示例：
2. list 的模拟实现
知识点：
小李的理解：
代码示例：
3. list 与 vector 的对比
知识点：
小李的理解：
总结
专栏：C++学习笔记 上一卷：【C++ 】-vector：新时代动态数组的革新与未来
C++ 中的 list 是一个强大的容器，特别适用于需要频繁插入和删除元素的场景。本文将详细介绍 list 容器，包括其介绍、使用方法、实现原理以及与 vector 容器的对比。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba0509b6e16362550f65f62b49297524/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b42ae483ec9860adf8b1c0513b736d49/" rel="bookmark">
			小程序自学教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从0开始搭建微信小程序前后台 0、准备 如何安装？去CSDN搜索“xxx安装教程”即可。
（1）工具 IntelliJ IDEA（必选）——Java开发集成环境，可以前后端同时使用
Web Storm——web开发集成环境，主要用于前端开发
Visual studio Code——轻量级代码编辑器，配置环境后可以编写任意语言，但主要用于前端开发
HbuildX、微信开发者工具（必选）——两者结合使用，主要用于小程序前端编写，需要配置环境变量。
HBuilderX 连接 微信开发者工具 Navicat（推荐）——数据库管理工具
（2）环境 合集·手把手教你搭建JavaWeb开发环境（保姆级教程）
Redis 5.0.14.1——一种NoSQL，持久化数据库，可以理解为分布式缓存。
JEnv——jdk管理工具，jdk1.8（Java开发工具包，也就是JavaWeb环境），也可不安装JEnv，单独配置jdk。
【配置】JDK8的安装与配置_jdk8安装教程和配置 nvm——node.js管理工具（JavaScript运行环境）。NVM使用教程
OpenOffice——开源的办公软件处理工具，如：文档预览、上传下载等。
Git——分布式版本控制系统，可以通过它下载拉去GitHub或GitLab上的开源项目。
Git教程 - 廖雪峰的官方网站
【狂神说Java】Git最新教程通俗易懂
Git使用详解
Maven 3.6.2——约定大于配置，一个Java项目管理工具，帮你解决依赖冲突等问题。
Maven Repository 仓库
【配置】Maven3.6.2的安装与配置
Mysql 5.7.19——关系型数据库管理系统，也就是数据库环境。
1、后台管理的前端开发 前端三件套（HTML、CSS、JavaScript）——3小时前端入门教程（HTML+CSS+JS
Vue——Vue.js (vuejs.org)——Vue3从入门到精通
ElementUI——组件 | Element
Element Plus——Overview 组件总览 | Element Plus (element-plus.org)
Echarts——Apache ECharts
2、小程序的前端开发 Uniapp——uni-app官网 (dcloud.net.cn)
U-View——介绍 | uView - 多平台快速开发的UI框架 - uni-app UI框架 (uviewui.com)
微信小程序官方开发文档——developers.weixin.qq.com/miniprogram/dev/framework/
微信公众平台——微信公众平台 (qq.com)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b42ae483ec9860adf8b1c0513b736d49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2717c9b1bc85aa6e15acc8ac998870cf/" rel="bookmark">
			【模块化与包管理】：解锁【Python】编程的高效之道
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.什么是模块？
2. 模块的导入过程
3. 理解命名空间
4. import语句的多种形式
5. 模块的执行与重新导入
6. 包（Package）
7. sys模块和os模块
sys模块
常用属性
示例：使用sys模块
os模块
常用功能
示例：使用os模块获取环境变量
总结
专栏：python学习笔记 上一篇：python异常处理
1.什么是模块？ 模块的定义与基本概念 模块是包含一组相关功能的Python代码文件。将代码拆分为多个模块，可以提高代码的可读性和可维护性。模块通常以.py文件形式存在，并通过import语句在其他Python文件中使用。
模块的优点 模块化编程具有以下几个优点：
代码复用：通过模块，可以在不同项目中重复使用相同的代码，提高开发效率。结构清晰：将代码拆分为模块，可以使项目结构更加清晰，便于管理和维护。命名空间隔离：每个模块都有独立的命名空间，避免命名冲突。 示例：创建和使用模块 下面我们通过一个简单的例子来创建和使用模块。
创建一个名为add.py的模块文件，其中包含一个用于加法运算的函数。 # add.py - 模块文件 def add(a, b): return a + b 创建一个名为main.py的文件，导入并使用add模块。 # main.py - 使用模块 import add result = add.add(1, 2) print(result) # 输出：3 小李的理解 如果把所有的代码都写在一个文件里，不仅代码看起来杂乱无章，还很难找到具体的功能。把相关功能的代码放到一个模块里，就像把工具分门别类地放在不同的盒子里，想用的时候直接去对应的盒子拿，既方便又整洁。”
2. 模块的导入过程 模块的搜索路径 Python解释器在导入模块时，会按照特定的搜索路径查找模块文件。这些路径存储在sys.path中，可以根据需要进行修改。
查看默认搜索路径
修改搜索路径 我们可以通过sys.path.append()方法动态添加新的搜索路径。
import sys sys.path.append('/path/to/module') import my_module 小李的理解 Python就像一个人需要去不同的地方找东西一样，默认情况下，它会去一些常用的地方找模块。我们可以告诉Python去其他地方找，这样就能灵活地使用不同位置的代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2717c9b1bc85aa6e15acc8ac998870cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4597bdcc671181cbbf5a95fa87592ca1/" rel="bookmark">
			【C&#43;&#43;深度探索】全面解析多态性机制(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥 个人主页：大耳朵土土垚 🔥 所属专栏：C++从入门至进阶 这里将会不定期更新有关C/C++的内容，欢迎大家点赞，收藏，评论🥳🥳🎉🎉🎉 前言 我们知道C++多态实现有两个条件——一是基类的指针或引用调用虚函数，另一个是基类中有虚函数并且在派生类中实现虚函数重写；这两个条件缺一不可，这与多态实现的底层原理有关，今天我们就来学习一下多态实现的原理🥳🥳
目录 前言1.虚函数表2.派生类中的虚表情况一：只有基类有虚函数，派生类没有情况二：基类和派生类中都有虚函数，并且虚函数没有被重写情况三：基类中定义虚函数，并且派生类中对该虚函数进行了重写综合这三种情况 3.多态原理动态绑定与静态绑定 4.多继承中的虚函数表5.结语 1.虚函数表 虚函数表（Virtual Function Table，VTable）是C++中实现动态多态性的一种机制。每个包含虚函数的类都有一个对应的虚函数表，用于存储该类的虚函数地址。
虚函数表是一个包含函数指针的数组，每个函数指针指向相应虚函数的实现。
也就是说在类中定义了虚函数，那么该类就会包含一个虚函数表来存放虚函数的函数指针，注意这里是指类中会存储虚函数表的指针来达到效果，因为如果虚函数很多，直接存储虚函数表可能会占用很多空间。
例如：
class Base { public: virtual void Func1() { cout &lt;&lt; "Func1()" &lt;&lt; endl; } private: int _b = 1; }; int main() { cout &lt;&lt; sizeof(Base) &lt;&lt; endl; return 0; } 当我们计算Base类的大小时，发现只有一个int类型的成员变量_b，所以应该是4个字节，但是我们可以看一下结果：
这里显示的是8字节，这是因为Base类中创建了虚函数，而每个包含虚函数的类都有一个对应的虚函数表，虚函数的地址要被放到虚函数表中，所以需要多余的空间来存储虚函数表的指针，这个指针我们叫做虚函数表指针。
如下图所示：
Base对象b中除了_b成员，还多一个__vfptr指针放在对象的前面(注意有些平台可能会放到对象的最后面，这个跟平台有关)，这个指针我们叫做虚函数表指针(v代表virtual，f代表function)。
注意是虚函数表的指针，而不是直接存储虚函数表。
因为上述例子是在32位操作系统下执行的，所以指针的大小是4字节，Base类大小是8字节；如果是64位那么指针的大小是8字节，Base类的大小就应该参考结构体内存对齐规则，应该是16字节。
2.派生类中的虚表 如果基类中没有虚函数，派生类中有虚函数，那么它的虚函数表和上面的一致。
例如：
class Base { private: int _b = 1; }; class Derive :public Base { public: virtual void Func2() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4597bdcc671181cbbf5a95fa87592ca1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d432a780c63e853f70a6f3287e505879/" rel="bookmark">
			视频播放器的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;div class="app-container"&gt; &lt;el-form :model="queryParam" ref="queryForm" :inline="true"&gt; &lt;el-form-item label="题目ID："&gt; &lt;el-input v-model="queryParam.id" clearable&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="题目内容："&gt; &lt;el-input v-model="queryParam.content" clearable&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="年级："&gt; &lt;el-select v-model="queryParam.level" placeholder="年级" @change="levelChange" clearable&gt; &lt;el-option v-for="item in levelEnum" :key="item.key" :value="item.key" :label="item.value"&gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;el-form-item label="学科："&gt; &lt;el-select v-model="queryParam.subjectId" clearable&gt; &lt;el-option v-for="item in subjectFilter" :key="item.id" :value="item.id" :label="item.name + ' ( ' + item.levelName + ' )'"&gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;el-form-item label="题型："&gt; &lt;el-select v-model="queryParam.questionType" clearable&gt; &lt;el-option v-for="item in questionType" :key="item.key" :value="item.key" :label="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d432a780c63e853f70a6f3287e505879/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cd361b8220d38f4c16b08fa69c91b77/" rel="bookmark">
			【深入浅出 】——【Python 字典】——【详解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 什么是 Python 字典？
1.1 字典的基本概念
1.2 字典的用途
1.3 字典的优势
2. 字典的基本特点
2.1 键的唯一性
2.2 可变性
2.3 无序性
3. 如何创建字典？
3.1 使用 {} 符号
3.2 使用 dict() 工厂方法
3.3 使用 fromkeys() 方法
4. 字典的键和值的类型可以不同
注意事项:
5. 如何访问字典中的元素？
注意事项:
6. 遍历字典
注意事项:
7. 修改字典中的元素
7.1 新增元素
7.2 修改元素
注意事项:
8. 删除字典中的元素
8.1 使用 del 删除某个键值对
8.2 使用 clear() 方法清空整个字典
8.3 使用 pop() 函数删除键值对并获取到对应的值
注意事项:
9. 查找元素是否在字典中
注意事项:
10. 字典的比较
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cd361b8220d38f4c16b08fa69c91b77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c237bd4c1625dfe0ba7679aaa8091e57/" rel="bookmark">
			让AI语言模型自由飞翔：LangChain框架的奇妙世界
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天，我将为大家揭开一项令人激动的技术——LangChain。想象一下，如果能将人工智能的强大能力与我们日常使用的数据和工具无缝连接，那将开启怎样崭新且无限的可能！
LangChain，一个专为大型语言模型设计的框架，扮演着连接技术与实际应用间的桥梁角色。想一下，它就像是一个魔法盒子，将LLM、数据源以及实用工具汇聚在一起，赋予你的AI模型超凡脱俗的能力。
这个框架的核心魅力在于它的多样性和高度可定制化。借助LangChain，你可以轻松地将各种LLM模型与你的数据库、API或其他数据服务进行链接。无论是GPT-3、ChatGPT还是BERT，都能通过这个框架实现更加深度的数据交互与利用。
而在LangChain的工具箱中，Model、Indexes、Chains、Memory以及Agent这些核心组件构成了其强大的驱动力。想象一下，只需几行代码，你就可以构建出一个能够自主理解、学习并执行任务的智能体，这在以前是难以想象的！
LangChain的设计哲学不仅止步于此，它的真正目标是简化开发者的工作，同时提升AI的应用效率和质量。通过模块化的组件，开发者可以快速集成和部署，大大节省了开发时间，提高了生产效率。
在LangChain的帮助下，我们可以构建出能够自动执行复杂工作流程的系统，比如自动化内容创作、数据分析、甚至是进行科学研究。这些系统能够利用大量的数据源，通过深度学习和自然语言处理技术，提供精准的信息检索和决策支持。
而且，LangChain社区的活跃也证明了这项技术的潜力。来自全球的开发者、研究人员和技术爱好者在这个平台上分享他们的创新成果，相互学习，共同进步。这种开放和协作的精神，为LangChain的发展注入了源源不断的动力。
未来，随着更多的企业和开发者加入到LangChain的生态中，我们有理由相信，这个框架将会成为推动人工智能应用落地的重要力量。它不仅仅是连接技术与实际应用的桥梁，更是激发创新、促进合作、推动社会进步的平台。
因此，对于那些对AI充满热情的朋友们，现在是时候深入了解LangChain，探索其背后的原理，以及如何将其应用到自己的项目中去。无论你是想解决具体的业务问题，还是想探索AI的最前沿，LangChain都能为你提供强大的支持。
最后，让我们一起期待LangChain带来的更多创新和突破，同时也不忘积极参与其中，为构建一个更加智能、高效和互联的世界贡献自己的力量。感谢大家的阅读，希望在LangChain的旅程中，我们能够共同成长，共创辉煌！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6fb60c0fdd898d606524b26a04c3139/" rel="bookmark">
			单例模式Singleton
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计模式 23种设计模式
Singleton 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。
饿汉式 public class BankTest { public static void main(String[] args) { Bank instance = Bank.getInstance(); Bank instance1 = Bank.getInstance(); System.out.println(instance == instance1); // true } } // 创建bank类 class Bank{ // 1.类的构造器私有化 private Bank(){ } // 2.在类内部创建当前类的实例 private static Bank instance = new Bank(); // 实例私有化了不能调用，使用静态方法提供调用 public static Bank getInstance(){ return instance; // 静态方法只能调用静态属性等，实例也要静态化 } } 懒汉式 package com.atguigu02.singleton; /** * @author by hongdou * @date 2024/7/13.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6fb60c0fdd898d606524b26a04c3139/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9f963823546fb33431f45d54d86f914/" rel="bookmark">
			Linux概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux概述 我们一般说的linux一词，指的是linux内核(最核心部分)，但既然是内核许多功能肯定用不了，所以不方便使用。
linux发行版，就是在linux内核的基础上，预先集成了一些软件，使得用户更加方便使用,有的发行版是付费的
Linux特点： 1.免费/开源/确定
2.支持多线程/多用户/处理高并发
3.安全性好
4.对内存和文件管理优越
用途： 1.Linux作为作为服务器操作系统，用来部署java程序及运行环境
2.嵌入式开发
如何获得一个Linux操作系统？
1.在我们自己的电脑上安装两个系统(一个windows，一个linux)
2.在我们电脑上安装一个虚拟机(系统虚拟机)，在虚拟机中安装linux
3.购买云服务器
Linux环境搭建(虚拟机版本) 1.VMware虚拟机安装 VMware Workstation Pro是VMware(威睿公司)发布的一代虚拟机软件，中文名称一般称为"VMware工作站"。主要功能是可以给用户在单一的桌面上同时运行不同的操作系统，也是可进行开发，测试，部署新的应用程序的最佳解决方案。
VM可在一部实体机器上模拟完整的网络环境，以及可便于携带的虚拟机器。对于企业的IT开发人员和系统管理员而言，VMware在虚拟网络，实时快照，拖曳共享文件夹等方面的特点使它成为必不可少的工具
2.在虚拟机中安装CentOS8操作系统 2.1 CentOS8是Linux的先行版
2.2 新建虚拟机向导 选择Linux(L)操作系统，版本选择CentOS 8 64位
3.配置虚拟机 3.1 编辑虚拟机设置：内存硬盘处理器都配置大一些，内存4GB，硬盘20GB
3.2 CD/DVD(IDE) 配置镜像为自己电脑上的iso文件
3.3 网络适配器选择NAT模式
3.4 然后开启虚拟机
3.5 配置密码
3.6 安装目的地
3.7 网络配置选择开启网络功能(以太网打开)
其他的配置暂时不用考虑，然后选择开始安装
4.进入虚拟机 启动虚拟机选择第一项
然后输入账号和密码
注意：输入密码时，密码不显示，输入完后回车就行
5. 远程连接 在 vmware 中通过命令操作不是很方便,不能进行复制粘贴等操作,所以需要安装 一款客户端工具(finalshell),用来远程连接 linux 操作系统,方便操作.
在FinalShell中创建远程连接：选择SSH连接，在虚拟机中输入ifconfig命令查看ip后输入到SSH连接中的主机，用户名默认root，再输入密码，自定义名称即可。
6.Linux常用命令 cd 目录名 : 选中 进入到指定的目录中
cd / 进入到根目录
cd … 返回到上一次
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9f963823546fb33431f45d54d86f914/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b595ceeb30b76f612ffd2cf9033954e/" rel="bookmark">
			埋点系统如何统计用户的平均停留时长？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hello，大家好，欢迎使用Webfunny前端监控和埋点系统。
今天，我们将介绍webfunny的埋点系统如何统计用户的平均停留时长
一、页面beforeLeave事件
当你页面离开的时候，会触发一个心跳检测，但是这个可能不是100%触发，因为beforeLeave这个事件的触发好像不是100%， 但是可以通过这个点位计算平均停留的数据。
二、心跳检测
我们会为每一个项目的sdk探针自动生成一个心跳检测的点位，这个点位包括停留时长stayTime字段，当引入我们的sdk探针代码后，默认会自动上报这个点位的数据，采集每个页面的停留时长
每15s上报一次，一个页面停留时间如果超过15s的话，就分多次来上报这个停留时长。
在点位细查中可以查看上报的数据
三、计算用户平均停留时长
新建一个卡片，用来计算用户平均停留时长，可以知道趋势图
选择心跳检测点位，利用停留时长字段，来求和，然后勾选计算数据，添加用户数据，来计算
以上是webfunny&lt;埋点系统统计用户平均时长&gt;操作介绍, ps： 如果你是前端工程师的相关技术同学，欢迎试用体验【webfunny前端监控和埋点系统】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a78e75d66abf1aef5ee9dd0be2b0cc2d/" rel="bookmark">
			【数据结构】初探数据结构面纱：栈和队列全面剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【数据结构】初探数据结构面纱：栈和队列全面剖析 🔥个人主页：大白的编程日记
🔥专栏：数据结构
文章目录 【数据结构】初探数据结构面纱：栈和队列全面剖析前言一.栈1.1栈的概念及结构1.2栈的结构选择1.3栈的实现1.4栈OJ 二. 队列2.1队列的概念及结构2.2队列的应用2.3队列的选择2.4队列的实现2.5队列OJ 后言 前言 哈喽，各位小伙伴大家好！今天咱们就正式开始学习数据结构了。我们今天要学习的数据结构分别是栈和队列。话不多说，咱们进入正题！向大厂冲锋！
一.栈 1.1栈的概念及结构 栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则。
压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。
出栈：栈的删除操作叫做出栈。出数据也在栈顶。
栈是一种遵循后进先出的结构。类似生活中我们生活中的弹夹，羽毛球桶等等。
入栈
入栈就是往栈顶增添数据
出栈
出栈就是在栈顶删除元素
1.2栈的结构选择 数组 我们可以用数组实现栈用下标控制栈顶元素的入栈和出栈
单链表
单链表其实不好实现栈，因为出栈时会修改上一个节点的指针。但单链表无法找到上一个节点。
所以我们把栈顶放在左边，栈顶是头节点，这样入栈出栈都可以。不需要修改上一个节点。
双向链表
为了解决单链表找上一个节点的问题，我们可以用双向链表来解决。
那这三个我们改选择那里一个呢？
首先我们可以先排除双向链表，因为它单链表还多了一个指针，多浪费了空间而且还要多维护一个指针。那单链表和数组我们选哪一个呢？其实都差不多。顺序表有扩容的问题。但是顺序表的缓存利用率高（文章有解释）。所以我们就选择数组吧。
1.3栈的实现 栈的定义
我们先定义一个栈结构体，里面放有栈数组的指针。top是栈顶元素的下标。capacity则是栈数组现在的空间大小。 typedef int STDataType; typedef struct Stack { STDataType* a; int top; int capacity; }ST; 栈的初始化
我们先断言一下。然后把空间大小和top都初始化为0。
top的初始化有两种方式 void STInit(ST* pst) { assert(pst); pst-&gt;a = NULL; pst-&gt;capacity = pst-&gt;top = 0;//指向栈顶元素的下一个 } 一种是初始化为-1，代表top指向栈顶元素。为什么要给-1呢？
因为如果给0的话，当栈为空时，0既能表示栈为空也能代表栈有一个元素，下标为0。所以初始化要给-1。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a78e75d66abf1aef5ee9dd0be2b0cc2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ed9523cec7dda6a1ad723ab33d2ed4e/" rel="bookmark">
			[Spring] Spring Web MVC基础理论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌸个人主页:https://blog.csdn.net/2301_80050796?spm=1000.2115.3001.5343
🏵️热门专栏:
🧊 Java基本语法(97平均质量分)https://blog.csdn.net/2301_80050796/category_12615970.html?spm=1001.2014.3001.5482
🍕 Collection与数据结构 (92平均质量分)https://blog.csdn.net/2301_80050796/category_12621348.html?spm=1001.2014.3001.5482
🧀Java EE(96平均质量分) https://blog.csdn.net/2301_80050796/category_12643370.html?spm=1001.2014.3001.5482
🍭MySql数据库(93平均质量分)https://blog.csdn.net/2301_80050796/category_12629890.html?spm=1001.2014.3001.5482
🍬算法(97平均质量分)https://blog.csdn.net/2301_80050796/category_12676091.html?spm=1001.2014.3001.5482
🍃 Spring(97平均质量分)https://blog.csdn.net/2301_80050796/category_12724152.html?spm=1001.2014.3001.5482
感谢点赞与关注~~~
目录 1. 什么是Spring Web MVC1.1 什么是MVC1.2 什么是Spring MVC 2. Spring MVC深入学习2.1 建立连接2.2.1 @RequsetMapping注解介绍2.2.2 @RequsetMapping的使用2.2.3 @RequsetMapping支持哪些方法类型的请求 2.3 请求2.3.1 传递单个参数2.3.2 传递多个参数2.3.3 传递对象2.3.4 后端参数重命名2.3.5 传递数组2.3.6 传递集合2.3.7 传递json数据2.3.8 获取URL中的参数@PathVariable2.3.9 上传文件@RequestPart2.3.10 获取Cookie/Session2.3.11 获取Header 2.4 响应2.4.1 返回静态页面2.4.2 返回数据@ResponseBody2.4.3 返回html代码片段2.4.4 返回json2.4.5 设置状态码2.4.6 设置header 1. 什么是Spring Web MVC Spring Web MVC是基于Servlet API构建的原始Web框架，从⼀开始就包在Spring框架中。它的正式名称“Spring Web MVC”来自其源模块的名称(Spring-webmvc)，但它通常被称为"Spring MVC".
总结来说,Spring Web MVC是一个Web框架.
想要理解什么是Spring MVC我们首先先要理解什么是MVC
1.1 什么是MVC MVC是Model View Controller的缩写,是软件工程中共的一种软件架构的设计模式.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ed9523cec7dda6a1ad723ab33d2ed4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40149d26da5347bad2d1d66cc09d519b/" rel="bookmark">
			# Redis 入门到精通（二）通用指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis 入门到精通（二）通用指令 一、redis 通用指令-key 基本操作 1、key 特征 key是一个字符串，通过key获取redis中保存的数据。
2、key 应该设计哪些操作? 对于 key 自身状态的相关操作，例如:删除，判定存在，获取类型等。
对于 key 有效性控制相关操作，例如:有效期设定，判定是否有效，有效状态的切换等。
对于 key 快速查询操作，例如:按指定策略查询 key。
…
3、key 基本操作 # 删除指定key del key #获取key是否存在（返回1是存在此key值，返回0是不存在此key） exists key # 获取key的类型 type key 4、redis 实际操作–key 基本操作 # 先创建5种类型的数据 127.0.0.1:6379&gt; set str str OK 127.0.0.1:6379&gt; hset hash1 hash1 hash1 (integer) 1 127.0.0.1:6379&gt; lpush list1 list1 (integer) 1 127.0.0.1:6379&gt; sadd set1 set1 (integer) 1 127.0.0.1:6379&gt; zadd zset1 1 zset1 (integer) 1 # 获取key的类型 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40149d26da5347bad2d1d66cc09d519b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/925946abfd6f63ca9f9034804281f2bb/" rel="bookmark">
			网络安全概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
信息安全现状及挑战
信息安全概述介绍
信息安全的脆弱性及常见安全攻击
缺乏自动化防御手段
网络环境的开发性
操作系统的脆弱性及常见攻击
协议栈的脆弱性及常见攻击
勒索病毒的特点
其他常见攻击
信息安全要素
特点
信息安全的五要素
信息安全现状及挑战 信息安全概述介绍 勒索病毒、网络空间安全、个人信息外泄、数据泄露、APT攻击（高级持续性威胁）
防火墙本质的手段就是包过滤(ACL)
零日漏洞0-day就是开发人员自己也没有发现了漏洞
水坑攻击：攻击者首先通过猜测（或观察）确定特定目标经常访问的网站，并入侵其中一个或多个网站，植入恶意软件。最后，达到感染目标的目的。
手段：1.在浏览器或其他软件上，通常会通过零日漏洞感染网站。2.针对已知漏洞的防御措施是应用最新的软件修补程序来消除允许该网站受到感染的漏洞。用户监控可以帮助确保他们的所有软件都运行最新版本。3.如果恶意内容被检测到，运维人员可以监控他们的网站和网络，然后阻止流量。
信息安全的脆弱性及常见安全攻击 缺乏自动化防御手段 现如今就是缺乏自动化防御的手段，绝大多数的小厂都时间长短取决于事件本身。
哪些相关法律了解以下两个即可：
2017.06 &lt;&lt;网络安全法&gt;&gt;
2019.05 &lt;&lt;信息安全技术网络等级保护基本要求&gt;&gt;
信息安全都是保护数据安全。
网络安全就是计算机网络环境下的信息安全。
网络环境的开发性 INTERNET的美妙之处在于你和每个人都能互相连接, INTERNET的可怕之处在于每个人都能和你互相连接
操作系统的脆弱性及常见攻击 原因
常见攻击
协议栈的脆弱性及常见攻击 Tcp/ip协议栈的脆弱性:
缺乏认证(啥都接收)，缺乏加密(明文)，缺乏完整性(发出跟接收到的不一致)
二层三层四层都有校验和但是效果体现不出来，可以伪造的。
还有自然灾害
处理方法：采用异地备份。
让Mac地址表装满了，后面的消息发到装满的交换机就进行洪泛，可以去监听目标地址的信息
攻击者使用虚假 MAC 地址洪泛网络交换机以损害其安全。交换机不会向整个网络广播网络数据包，而是通过隔离数据和利用 VLAN（虚拟局域网） 来维护网络完整性。 MAC 洪泛攻击背后的动机是从受害者系统中窃取正在传输到网络中的数据。
在每台主机都有一个ARP缓存表，缓存表中记录了IP地址与MAC地址的对应关系，而局域网数据传输依靠的是MAC地址。
不知道mac地址，然后广播去询问，因为不知道谁会正确回答，谁说就信谁的。
解决办法：静态写死mac地址
Arp协议：ARP（Address Resolution Protocol）地址转换协议，工作在OSI模型的数据链路层，在以太网中，网络设备之间互相通信是用MAC地址而不是IP地址，ARP协议就是用来把IP地址转换为MAC地址的。而RARP和ARP相反，它是反向地址转换协议，把MAC地址转换为IP地址。
ICMP:就是控制报文协议，就是用来报告主机是否可达，路由是否可用。
LCMP攻击又叫ICMP的不可达攻击，无非就是给除了受害机以外的其他用户一直发送受害机不可达的信息
见到Flood的攻击都是dos（拒绝服务）攻击
办法：禁ping，修改注册表拒绝接受icmp的重定向
什么是面向连接：确保建立点到点的连接（三次握手）双向的绘话建立好SYN、ACK
发送syn时对方建立一个存储空间，目的就是让Server的服务器空间占满，但是这是一个杀敌一千自损八百的做法。 修改办法是：原ip目标ip原端口目标端口改一个就可以再发
如何防御：1.使用代理防火墙---每目标ip代理阈值，每目标ip丢包阈值。太高可能都没发现攻击者太低的话可能正常包也被丢掉（冒充服务器观察有没有问题，看下对方回不回ACK）2.首包丢包。3.SYN cookie将状态信息记录下来，不造成混乱
它可以将分布在不同地方的多台计算机联合起来形成攻击平台，对一个或多个目标发动攻击，从而产生成倍的拒绝服务攻击的威力。
DNS服务器防御不够，通信之间可以进行数据加密。
勒索病毒的特点 其他常见攻击 信息安全要素 特点 恶意程序---一般会具备以下多个或全部特点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/925946abfd6f63ca9f9034804281f2bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dbd7ccccdb483f1de28209b55e39f32/" rel="bookmark">
			WPF学习(6) -- WPF命令和通知
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 、WPF命令 1.ICommand代码 创建一个文件夹和文件
using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Input; namespace 学习.Command { public class MyCommand : ICommand { Action executeAction; public MyCommand(Action action) { executeAction = action; } public event EventHandler CanExecuteChanged; public bool CanExecute(object parameter) { return true; } public void Execute(object parameter) { executeAction(); } } } 2.view model代码 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dbd7ccccdb483f1de28209b55e39f32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60fda887aa6c87edbe529c40983ebbfb/" rel="bookmark">
			火遍全网的15个Python的实战项目，你该不会还不知道怎么用吧！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经常听到有朋友说，学习编程是一件非常枯燥无味的事情。其实，大家有没有认真想过，可能是我们的学习方法不对？
比方说，你有没有想过，可以通过打游戏来学编程？
今天我想跟大家分享几个Python小游戏，教你如何通过边打游戏边学编程！
今天给大家带来15个Py小游戏，一定要收藏！
飞扬的小鸟
Python简易时钟
Python中国象棋
Python吃豆豆小游戏
Python幸运大转盘
Python简易植物大战僵尸
Python2048小游戏
Python俄罗斯方块
Python 烟花
Python 贪吃蛇
Python 数字游戏
拼图游戏
滑雪小游戏
数独游戏
飞机大战
1.飞扬的小鸟
①游戏介绍：
《flappy bird》是一款由来自越南的独立游戏开发者Dong Nguyen所开发的作品，游戏于2013年5月24日上线，并在2014年2月突然暴红。
游戏规则：
游戏玩法非常简单，通过点击屏幕，使小鸟一直飞并穿过水管的空隙。虽然玩法简单，但是却具有一定的难度，因为要一直控制小鸟飞在适合的高度，以避开障碍。
这篇文章呢，就来分析这个游戏的原理，以及用python做一个简易版的FlappyBird。
②源码分享：
#itbaizhan import pygame import sys import random class Bird(object): """定义一个鸟类""" def __init__(self): """定义初始化方法""" self.birdRect = pygame.Rect(65, 50, 50, 50) # 鸟的矩形 # 定义鸟的3种状态列表 self.birdStatus = [pygame.image.load("images/0.png"), pygame.image.load("images/2.png"), pygame.image.load("images/dead.png")] self.status = 0 # 默认飞行状态 self.birdX = 120 # 鸟所在X轴坐标,即是向右飞行的速度 self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60fda887aa6c87edbe529c40983ebbfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fc62bfc7af8823571e2371ee56e1961/" rel="bookmark">
			完美解决MYSQL8.4.1 MySQL84 -- ERROR 1524 (HY000): Plugin ‘msql_native_password‘ is not loaded.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 安装了mysql8.4.1，使用sqlyog、navicat无法连接，报错：Plugin caching_sha2_password could not be loaded:乱码
原因：
出现这个原因是MySQL8之前的版本中加密规则是mysql_native_password，而在MySQL8之后，加密规则是caching_sha2_password。解决问题方法有两种，第一种是升级图形界面工具版本，第二种是把MySQL8用户登录密码加密规则还原成mysql_native_password。
按照网上教程尝试第二种方式解决
登录mysql依次执行如下命令：
#使用mysql数据库 USE mysql; #修改'root'@'localhost'用户的密码规则和密码 ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'abc123'; #刷新权限 FLUSH PRIVILEGES; 新问题 按照如上方法操作到第二条命令的时候出现了报错：Plugin ‘msql_native_password‘ is not loaded.
#查询mysql插件信息 show show plugins; 结果发现
mysql_native_password 插件是DISABLED状态。
解决
1、在my.ini文件中加入该插件启动命令，在[mysqld]段添加mysql_native_password=ON。
2、重启MySQL服务。然后登录mysql再show plugins;可以看到mysql_native_password是ACTIVE状态
3、再次执行前面的命令，这里需要注意执行第二条命令之后root的密码会被修改成新的：abc123，根据自己的情况修改。
#使用mysql数据库 USE mysql; #修改'root'@'localhost'用户的密码规则和密码 ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'abc123'; #刷新权限 FLUSH PRIVILEGES; 此时命令都可以正常执行，使用sqlyog也可以登录了，完美解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34325f3dcd22c85385410c032e67e5f5/" rel="bookmark">
			TypeError: Cannot read properties of null (reading ‘isCE‘)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 TypeError: Cannot read properties of null (reading ‘isCE’)
problem 控制台报错 TypeError: Cannot read properties of null (reading ‘isCE’)
reason vue包重复
solution 修改vite.config.js
resolve: { dedupe: [ 'vue' ] }, resolve.dedupe 用于防止项目中的依赖包被重复打包。
dedupe（去重）确保项目中vue不会被多次加载，这对单例模式的库（如 Vue、React 等）尤为重要。当项目中使用了多个依赖（或插件），这些依赖可能各自引用了同一个包（例如 vue）。如果没有去重处理，可能会导致该包被加载多次，从而引起一些难以调试的问题，例如不同实例之间的数据不一致。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/158/">«</a>
	<span class="pagination__item pagination__item--current">159/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/160/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>