<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7f39d3191410073271517cc249c32bb/" rel="bookmark">
			【SpringBoot3】Spring Boot 3.0 集成 Redis 缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、什么是redis缓存二、SpringBoot3 如何集成 Redis三、spring-boot-starter-cache 结合 Redis 使用1、什么是 spring-boot-starter-cache2、Redis 集成步骤3、使用示例 参考 一、什么是redis缓存 Redis缓存是一个开源的使用ANSIC语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。它主要用于作为数据库、缓存和消息中间件，以快速读写和丰富的数据结构支持而著称。
在应用程序和数据库之间，Redis缓存作为一个中间层起着关键作用。通过将常用的数据存储在Redis内存中，可以快速读取，从而避免了从数据库进行复杂的查询操作，减轻了数据库服务器的压力，并提高了应用程序的性能和响应速度。
此外，为了优化热门查询的性能，可以确定希望缓存的查询结果，特别是最常用和最耗时的查询。这样可以进一步提高应用程序的性能和吞吐量。
spring-boot-starter-data-redis默认的Redis客户端是Lettuce。这是因为Lettuce是一个线程安全的、基于Netty通信的Redis客户端，相比之下，Jedis在多线程环境下存在线程安全问题，因此需要增加连接池来解决线程安全的问题，同时可以限制redis客户端的数量。
而Lettuce在多线程环境下不存在线程安全问题，一个连接实例就可以满足多线程环境下的并发访问，当然实例不够的情况下也可以按需增加实例，保证伸缩性。因此，Spring Boot在后续版本中选择了Lettuce作为默认的Redis客户端。
二、SpringBoot3 如何集成 Redis 1）添加依赖
在pom.xml文件中添加Spring Boot Starter Data Redis依赖：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 2）配置Redis连接
在application.properties或application.yml文件中配置Redis连接信息：
spring.data.redis.host=127.0.0.1 spring.data.redis.port=6379 spring.data.redis.database=0 spring.data.redis.password= 3）配置 RedisTemplate Bean
@Configuration public class RedisConfig { @Bean public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) { RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(connectionFactory); // 使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式） Jackson2JsonRedisSerializer&lt;Object&gt; serializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class); template.setValueSerializer(serializer); template.setKeySerializer(new StringRedisSerializer()); template.setHashKeySerializer(new StringRedisSerializer()); template.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7f39d3191410073271517cc249c32bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d2cd4d937d97c94d53888d3736c7b15/" rel="bookmark">
			【Java】IDEA集成开发环境工具切换JDK和设置环境变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到《小5讲堂》
大家好，我是全栈小5。
这是《Java》序列文章，每篇文章将以博主理解的角度展开讲解，
特别是针对知识点的概念进行叙说，大部分文章将会对这些概念进行实际例子验证，以此达到加深对知识点的理解和掌握。
温馨提示：博主能力有限，理解水平有限，若有不对之处望指正！
目录 前言JDK切换环境变量疑问 前言 在《Java序列》的前一篇文章，已经开始入门编码输出了Hello World，
本篇文章主要是在IDEA开发工具进行JDK切换以及在IDEA下载安装的Java路径设置windows环境变量。
JDK切换 在IntelliJ IDEA中，可以在以下位置切换JDK版本
1.打开IntelliJ IDEA，并打开项目
2.在菜单栏中，选择「File（文件）」&gt;「Project Structure（项目结构）」。
3.在打开的窗口中，找到并选择「Project」「SDK」选项。
4.在右侧的窗格中，会看到已配置的SDK。如果想切换JDK版本，可以点击Download JDK重新选择。
5.在弹出的窗口中，可以选择新的JDK版本，包括已安装的JDK或手动指定JDK路径。
环境变量 在Windows上设置IntelliJ IDEA下载的Java JDK的环境变量路径
可以按照以下步骤进行
1.打开控制面板（Control Panel）。
2.点击「系统和安全」（System and Security）。
3.点击「系统」（System）。
4.点击「高级系统设置」（Advanced system settings）。
5.在弹出的窗口中，点击「高级」（Advanced）选项卡。
6.点击「环境变量」（Environment Variables）按钮。
7.在「系统变量」（System variables）下方的列表中，找到名为「Path」的变量，并双击它。
8.在「编辑环境变量」（Edit Environment Variable）窗口中，点击「新建」（New）按钮。
9.输入JDK的安装路径。例如，如果JDK安装在「C:\Users\Administrator.jdks\corretto-11.0.22\bin」，则应该在Path变量中添加「C:\Users\Administrator.jdks\corretto-11.0.22\bin\bin」并点击「确定」（OK）。
10.再次点击「确定」（OK）关闭所有打开的对话框。查看自己jdk安装路径
新建变量，并输入上一步找到的路径，记得是要到bin文件夹
查看版本
cmd ‘java’ 不是内部或外部命令，也不是可运行的程序或批处理文件。
疑问 为什么jdk最新版本已经是21，但是大部分开发者还是用jdk 11和jdk 8
在2024年1月，JDK的最新版本是21，而JDK 11已经发布了很长时间。
以下是一些原因解释为什么许多开发者仍然使用JDK 11
1.长期支持（Long-Term Support，LTS）
JDK 11是一个长期支持版本，它提供了更长的维护期限和稳定性保证。这对于大型企业和项目来说非常重要。许多公司和项目团队更倾向于使用LTS版本，因为他们可以获得长期支持和稳定性，而不需要频繁地升级和适应新版本。
2.兼容性
许多项目仍然依赖于旧版本的Java库和框架，并且可能需要一些时间来适应新版本。此外，一些旧的或第三方工具可能不完全兼容较新的JDK版本，因此开发者可能选择继续使用较老的JDK，以确保他们的应用程序能够正常运行。
3.生态系统
对于一些特定的开发者群体，例如Android开发者，他们仍然使用JDK 8或JDK 11，因为这些版本与他们的开发环境和工具链更加兼容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d2cd4d937d97c94d53888d3736c7b15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49712fd24e2aba87472c55c848c7fac8/" rel="bookmark">
			android 基于FRP实现内网穿透
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于gradle 7.0+实现内网穿透功能 第一步，导入libs资源文件第二步、配置app-build.gradle与settings.gradle第三步、编写frp连接服务第四步、在AndroidManifest.xml种定义FrpcService第五步、开启与关闭frp服务器连接有关于APK Release打包报错的问题。[解决方案借鉴于该作者](https://www.jianshu.com/p/78964265a0b6)第一步第二步第三步 第一步，导入libs资源文件 frpclib.aar
frpclib-sources.jar
第二步、配置app-build.gradle与settings.gradle 1、引用资源文件，配置app-build.gradle
implementation fileTree(dir: 'libs', include: ['*.aar','*.jar']) implementation files('libs\\frpclib-sources.jar') 2、配置settings.gradle
第三步、编写frp连接服务 import android.app.Service import android.content.Context import android.content.Intent import android.os.IBinder import android.util.Log import frpclib.Frpclib import kotlinx.coroutines.* import java.util.* import kotlin.coroutines.EmptyCoroutineContext /** @des:基于frp实现内网穿透 @author: bubian @time: 2024/1/18 15:30 */ class FrpcService : Service() { lateinit var mCoroutineScope: CoroutineScope private val SN = "AF7855654"//设备的唯一标识 private val IP = "192.168.124.48"//设备的本地IP地址 private var UUID = java.util.UUID.randomUUID().toString()//获取设备UUID override fun onBind(p0: Intent?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49712fd24e2aba87472c55c848c7fac8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/680149a4d94fde588125c1e3ddc2823b/" rel="bookmark">
			一招解决微软copilot提示:该服务在您所在的地区不可用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着windows 11的推出很多网友都开始注意到了微软copilot AI助手。科技快速发展当前AI已经是一个家喻户晓的名词了, 尤其是一些之前体验过ai强大功能的用户，对AI更加是爱不释手。虽然win 11 版本已经将copilot集成到系统当中，然后不少网友在想要体验时却发现微软copilot提示:该服务在您所在的地区不可用。这一度难倒了很多网友。
接下来我们重点看这个问题。
要真正体验到微软copilot需要着重解决3个问题。
1.有效浏览器 目前微软copilot只支持微软浏览器也就是dege浏览器，另外一个是支持谷歌浏览器，如果使用其他的浏览器就会出现提示报错。笔者建议大家使用dege浏览器，使用体验感觉还是很不错的。
2.微软邮箱账号 微软copilot必须登录您的账号才可以使用，这个就很简单了，只需要注册一个微软邮箱就可以了。注册这个是免费的，分分钟就可以搞定的事情。
3.网络工具 由于国内具有严格的网络审核，copilot和其他国外应用一样被防火墙拦截，因此国内使用的话需要借助网络工具，对于办公学习场景下需要使用到copilot的网友，小编推荐使用国际专线：usip.top 可以轻松解决：该服务在您所在的地区不可用的问题。
总结：出现微软copilot提示:该服务在您所在的地区不可用，其实就是网络限制问题，通过使用网络工具 usip.top 就可以轻松的解决这个问题！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/331c5c8dd0f9df1fdad70bb699b8d7b9/" rel="bookmark">
			解决常见 Python 报错：SciPy 和 NumPy 版本冲突
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在使用 Python 的科学计算库时，经常会遇到各种依赖问题。最近，在使用 SciPy 和 NumPy 这两个流行的 Python 包时，我遇到了一个版本兼容性的报错。在本文中，将分享下个人些浅见。
报错描述 当我尝试运行一段涉及 SciPy 和 NumPy 的代码时，我遇到了以下警告信息：
UserWarning: A NumPy version &gt;=1.16.5 and &lt;1.23.0 is required for this version of SciPy (detected version 1.26.2) warnings.warn(f"A NumPy version &gt;={np_minversion} and &lt;{np_maxversion}" 这个警告提示我当前的 SciPy 版本需要一个 NumPy 版本在 1.16.5 到 1.23.0 之间，但检测到的 NumPy 版本是 1.26.2。
解决步骤 1. 分析问题 首先，我们需要明白问题的本质：SciPy 和 NumPy 的版本不兼容。SciPy 依赖于特定版本范围内的 NumPy，而当前环境中的 NumPy 版本超出了这个范围。
2. 确定版本 在尝试解决这个问题之前，重要的是要确定你当前使用的 SciPy 和 NumPy 的版本。可以通过以下命令查看：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/331c5c8dd0f9df1fdad70bb699b8d7b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d5aef518326de344a8cfa0e430d3d87/" rel="bookmark">
			（2）(2.1) Andruav Android Cellular（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
前言
5 Andruav Web Client
6 Andruav Telemetry
7 Andruav高级功能
8 将Andruav与SITL配合使用
9 FAQ
10 术语表
前言 Andruav 是一个基于安卓的互联系统，它将安卓手机作为公司计算机，为你的无人机和遥控车增添先进功能。
5 Andruav Web Client Web-Client 是一个网站，你可以通过它跟踪和控制无人机。
网络客户端 URL：https://cloud.ardupilot.org:8001/webclient.html。
主要功能
1. 能够同时控制多架无人机。
2. 能同时串流多架无人机的视频。
3. 可根据手机功能进行变焦拍照。
4. 可将游戏手柄直接与网络连接，流畅地驾驶无人机。
5. 能够使用网络 UDP 遥测技术(Web UDP Telemetry)连接 QGroundControl 或任务计划器。
6 Andruav Telemetry 目录：
Andruav Web PluginAndruav GCS Telemetry Andruav 与基于 Ardupilot 的飞行控制板集成(Ardupilot-based flight control boards)。Andruav 可以通过蓝牙、USB、TCP 和 UDP 连接到这些控制板。
下面这段视频可能是遥控遥测距离的破纪录之作。在下面的视频中，你可以看到一辆汽车在埃及开罗被控制，驾驶员在美国洛杉矶。Andruav 12,193 km 遥控汽车演示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d5aef518326de344a8cfa0e430d3d87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8da9f4c48d40be216e04a5c15db35077/" rel="bookmark">
			GitHub Copilot 与 OpenAI ChatGPT 的区别及应用领域比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitHub Copilot 和 OpenAI ChatGPT 都是近年来颇受关注的人工智能项目，它们在不同领域中的应用继续引发热议。本文旨在分析和比较这两个项目的区别，从技术原理、应用场景、能力和限制、输出结果、能力与限制和发展前景等方面进行综合评估，帮助读者更好地了解这两个项目的特点和适用性。
目录
一、简介
二、技术原理
三、应用场景
四、功能特性
五、输出结果
六、能力和限制
七、优劣势比较
八、发展前景
九、结论
一、简介 GitHub Copilot：
GitHub Copilot 是一款由 GitHub 和 OpenAI 合作推出的人工智能编程助手工具。它使用了来自 OpenAI 的 Codex 模型，可以在集成开发环境（IDE）中为开发者提供智能代码自动补全和建议。Copilot 能够从大规模的开源代码库中学习并产生各种代码片段，从而加快编程过程并提高开发效率。
通过整合到流行的集成开发环境，如 Visual Studio Code、Visual Studio 和 JetBrains 系列等，Copilot 能够根据用户输入的上下文情境、代码结构和功能需求，智能地生成代码补全建议，避免开发者重复编写常见的代码片段，提供了实时的代码提示和自动生成功能。
GitHub Copilot 受益于 OpenAI 的 Codex 模型，在大规模的代码库中进行学习，并能够支持多种编程语言。它使用机器学习技术，能够根据用户的代码需求和上下文，生成与当前代码相关的智能补全建议。
总之，GitHub Copilot 的推出标志着人工智能技术在软件开发领域的应用进一步深化，为开发者提供了更高效和智能的编程辅助工具，有望在提高开发效率、减少重复劳动和改善编程体验方面发挥重要作用。
OpenAI ChatGPT：
ChatGPT是由OpenAI开发的一种基于GPT（Generative Pre-trained Transformer）架构的语言生成模型，旨在模拟人类对话和交流。该模型是经过大规模预训练并具有出色语言理解和生成能力的深度学习模型。
ChatGPT的核心原理是使用Transformer架构处理来自用户的输入，并生成自然流畅的文本作为回复。ChatGPT可以理解上下文、掌握语义关系，从而生成具有逻辑连贯性和自然性的对话。它可以用于智能对话系统、聊天机器人、文本生成和自然语言处理等多个领域。
与其他对话模型相比，ChatGPT在语言理解和生成方面具有较高的水平，能够结合历史对话上下文来进行响应生成，从而产生更加智能和贴近人类表达的对话。同时，由于GPT模型的通用性和可扩展性，ChatGPT在多种领域和应用场景中都展现了强大的表现。
总的来说，ChatGPT是一种在自然语言处理领域具备卓越表现的语言生成模型，能够模拟人类对话和交流，并且在实际应用中有着广泛的潜力。
二、技术原理 GitHub Copilot：
GitHub Copilot 是一个代码自动补全工具，它的核心技术原理是基于深度学习和大规模代码训练的模型。
语言模型：Copilot 使用了基于深度学习的语言模型，通常是基于循环神经网络（RNN）、长短期记忆网络（LSTM）或变种的Transformer模型。这些模型能够理解代码的语法结构、上下文和意图，从而可以生成合适的代码补全建议。
预训练和微调：Copilot 的模型在大规模的代码库上进行预训练，通过学习代码的语法、结构和惯用法，从而能够拟合代码的特性和风格。此外，针对特定的编程语言和领域，还可以进行微调，以进一步提高模型在特定领域的表现。
上下文理解：Copilot 能够理解代码输入的上下文信息，包括已有代码的结构、注释、变量命名等，从而可以生成与当前代码逻辑和语义相符的自动补全建议。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8da9f4c48d40be216e04a5c15db35077/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4d5035fcf0246dd0848e57e0b6db74e/" rel="bookmark">
			.Net接入AzureOpenAI、OpenAI、通义千问、智谱AI、讯飞星火、文心一言大语言模型。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 现在在网上搜索.NET接入大模型的帖子很少，有些官方案例只提供java和python的SDK，所以有了这篇.Net的接入大模型文章，目前仅实现对话模型的调用。
这里仅举例通义千问，其他模型实现可以参考Gi他Hub 对您有帮助的话帮忙点个star
个人博客：FaceMan’ Blog 。
Github：FaceMan’ GitHub 。
实现方式 创建IModelExtensionsChatCompletionService对话服务，规范对话服务应实现的接口。
public interface IModelExtensionsChatCompletionService { /// &lt;summary&gt; /// 对话 /// &lt;/summary&gt; /// &lt;param name="chatHistory"&gt;对话历史&lt;/param&gt; /// &lt;param name="settings"&gt;参数配置&lt;/param&gt; /// &lt;param name="kernel"&gt;SK的kernel&lt;/param&gt; /// &lt;param name="cancellationToken"&gt;是否取消&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; Task&lt;ChatMessageContent&gt; GetChatMessageContentsAsync(ChatHistory chatHistory, OpenAIPromptExecutionSettings settings = null, Kernel kernel = null, CancellationToken cancellationToken = default); /// &lt;summary&gt; /// 流式对话 /// &lt;/summary&gt; /// &lt;param name="chatHistory"&gt;对话历史&lt;/param&gt; /// &lt;param name="settings"&gt;参数配置&lt;/param&gt; /// &lt;param name="kernel"&gt;SK的kernel&lt;/param&gt; /// &lt;param name="cancellationToken"&gt;是否取消&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; IAsyncEnumerable&lt;string&gt; GetStreamingChatMessageContentsAsync(ChatHistory chatHistory, OpenAIPromptExecutionSettings settings = null, Kernel kernel = null, CancellationToken cancellationToken = default); } 创建ModelClient类做数据解析
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4d5035fcf0246dd0848e57e0b6db74e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df28a7ee92582700ebc90394a0e91947/" rel="bookmark">
			HiveSQL常用函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.字符串函数 1.1 split()函数 用于切割字符串
格式: split('参数1','参数2'),这里的参数1为数据,参数2为切割方式
细节:参数二可以用正则表达式
举例
select split('abcd','c'); --结果为["ab","d"] select split('asd11mcd22', '11'); --结果为["asd","mcd22"] select split('asd11mc22dd', '\\d+'); --结果为["asd","mc","dd"] 1.2 concat()函数 用于拼接字符串
格式: concat('数据1','数据2'......)
细节:该函数拼接没有拼接符,直接拼接在一起
举例
select concat('asd123','ff'); --结果为asd123ff 1.3 concat_ws()函数 也是用于拼接字符串
格式: concat_ws('拼接符','数据1','数据2',......)
举例
select concat_ws('-','abcfs','mm','cc'); --结果为abcfs-mm-cc 1.4 substr()函数 用于截取字符串
格式: substr('数据',起始位置,截取多少位)
细节:空格也算一位
举例
select substr('2001-07-09 00:00:00',1,10); --获取年月日 2001-07-09 select substr('2001-07-09 00:00:00',12,8); --获取时间 00:00:00 select substr('2001-07-09 00:00:00',1,4); --获取年 2001 select substr('2001-07-09 00:00:00',6,2); --获取月 07 2.时间函数 2.1 current_timestamp()函数 返回当前日期及时间
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df28a7ee92582700ebc90394a0e91947/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/603329ae3996fa6009df9f17873ac7dc/" rel="bookmark">
			动态规划-背包问题详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、动态规划问题说明1.题目问题2.Dp解题思路 二、01背包问题1.问题描述输入格式输出格式数据范围输入样例输出样例 2.朴素算法代码 3.优化算法代码 三、完全背包问题1.问题描述输入格式输出格式数据范围输入样例输出样例 2.朴素算法代码 3.优化算法代码 四、多重背包问题1.问题描述输入格式输出格式数据范围输入样例输出样例 2.朴素算法代码 3.优化算法代码 五、分组背包问题1.问题描述输入格式输出格式数据范围输入样例输出样例 2.优化算法代码 六、总结 一、动态规划问题说明 1.题目问题 首先给出背包的容量，接着：
01背包问题：给出每个物品的体积和质量，每个物品最多只能使用一次完全背包问题：给出每个物品的体积和质量，每个物品可以无限次使用多重背包问题：给出每个物品的体积、质量和数量，每个物品使用量必须在每个物品给定的数量之类分组背包问题：给出每个物品的体积、质量和它们的分组，每个组中最多只能取一件物品 在背包的限制之内，做出抉择，选择物品填充背包，使得最终背包的质量最大。
2.Dp解题思路 Dp由于变化较多，没有固定模板，可以从两个方面入手分析，即：状态表示和状态计算，我们把状态设为f[i][j]
状态表示f[i][j]:它表示在前i种物品种选取，使得容量不超过j，满足该情况的所有情况集合，在集合中选取最优解，该最优解的质量即为f[i][j]的值状态计算：即如何计算f[i][j]，每种情况有所不同，且可以优化，优化方式也有所不同，在下面实例分析中进行详细讲解 二、01背包问题 1.问题描述 有 N 件物品和一个容量是 V的背包。每件物品只能使用一次。
第 i件物品的体积是 vi，价值是 wi。
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。
输入格式 第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。
接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。
输出格式 输出一个整数，表示最大价值。
数据范围 0&lt;N,V≤1000
0&lt;vi,wi≤1000
输入样例 4 5 1 2 2 4 3 4 4 5 输出样例 8 2.朴素算法 我们可以把f[i][j]的状态计算下分，分为对两种情况的取最大值：不包括第i种物品和包括第i种物品不包括第i种物品：f[i-1][j]包括第i种物品：f[i-1][j-v[i]]+w[i]，即已经含有了第i种物品 代码 #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; const int N = 1010; //物品的最大数量 int n,m; //n是物品数量，m是背包的容量 int v[N], w[N]; //v[i]是第i件物品的体积，w[i]是第i件物品的质量 int f[N][N]; //状态表示,全局变量初始化为0 int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1;i &lt;= n;i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i]; for(int i = 1;i &lt;= n;i ++ ) for(int j = 0;j &lt;= m;j ++ ) { f[i][j] = f[i - 1][j]; //只有在给定的j容量大于第i个物品的体积时，才可以放第i个物品，不然程序会错误 if(j &gt;= v[i]) f[i][j] = max(f[i][j],f[i - 1][j - v[i]] + w[i]); } cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0; } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/603329ae3996fa6009df9f17873ac7dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54d427cd89f11a5b27622966da0c6892/" rel="bookmark">
			Python MD5加密的三种方法（可加盐）/base64加解密 /RSA加解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实现MD5加密 方法一：MD5直接加密 import hashlib # 定义用户名和密码 username = 'admin' password = '123' # 计算用户名的MD5哈希值 md = hashlib.md5(username.encode()) md5username = md.hexdigest() print(md5username) # 计算密码的MD5哈希值 md = hashlib.md5(password.encode()) md5password = md.hexdigest() print(md5password) 运行看结果：
21232f297a57a5a743894a0e4a801fc3
202cb962ac59075b964b07152d234b70
建议加密是否正确：
方法二：MD5+盐加密，将盐拼接在原密码后 import hashlib text1='123456' print(text1) SALE=text1[:4]	# 设置盐值 print(str(text1)+SALE) md_sale=hashlib.md5((text1+SALE).encode()) # MD5加盐加密方法一：将盐拼接在原密码后 md5salepwd=md_sale.hexdigest() print(md5salepwd) 输出结果：
方法三：MD5+盐加密，将password整体插入SALE的每个元素之间 import hashlib text1='123456' print(text1) SALE=text1[:4]	# 设置盐值 print(str(text1).join(SALE)) md_sale=hashlib.md5((str(text1).join(SALE)).encode()) # MD5加盐加密方法二：将password整体插入SALE的每个元素之间 md5salepwd=md_sale.hexdigest() print(md5salepwd) 输出结果：
二、实现base64加密解密 1、Python实现base64加密，可以使用base64库。 代码如下：
import base64 # 加密 username = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54d427cd89f11a5b27622966da0c6892/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f37da18cbecd2cd9e8f50ae11591dcb6/" rel="bookmark">
			Mac NTFS 磁盘读写工具选哪个好？Tuxera 还是 Paragon？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用 Mac 电脑时，我们经常需要读写 NTFS 格式的硬盘或 U 盘。然而，由于 Mac 系统不支持 NTFS 格式的读写，因此我们需要借助第三方工具来实现这个功能。而在市场上，Tuxera 和 Paragon 是两款备受推崇的 Mac NTFS 磁盘读写工具。那么，到底该选择哪一款呢？
首先，让我们来看看 Tuxera。Tuxera NTFS for Mac 是一款高效稳定的软件，具有快速的读写速度和完整的文件系统支持。它支持所有的 NTFS 版本，并能够自动修复文件系统错误，确保您的数据安全。此外，Tuxera 还具有良好的兼容性和易用性，可以无缝地与 Mac 系统集成。
Tuxera Ntfs For Mac 2023 下载：https://souurl.cn/GaQ2qJ
Tuxera NTFS for Mac 2022下载：https://souurl.cn/fIerPb
与之相比，Paragon NTFS for Mac 是另一款优秀的 Mac NTFS 磁盘读写工具。它具有快速的读写速度和高效的数据传输能力，能够实现与 Mac 系统的完美兼容。此外，Paragon 还具有出色的文件系统支持和自动修复功能，能够帮助用户轻松地管理和维护硬盘文件系统。
Paragon Ntfs For Mac 15下载：https://souurl.cn/s84CCB
虽然 Tuxera 和 Paragon 都是优秀的 Mac NTFS 磁盘读写工具，但它们在一些方面还是存在差异。例如，Tuxera 的读写速度相对较慢，但是它具有更好的文件系统支持和易用性。而 Paragon 则具有更快的读写速度和高效的数据传输能力，但是它的文件系统支持相对较弱。
如果你是 Mac 用户，有时候借用朋友的 U 盘可能会出现这种情况：明明 U 盘里的文件一目了然，却没法把自己的文件拖进去。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f37da18cbecd2cd9e8f50ae11591dcb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/113c60a1a9768d54dd29f757d4187a98/" rel="bookmark">
			Tuxera NTFS for Mac 2023破解版百度云下载和2024最新激活图文教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tuxera NTFS for Mac 2023破解版是一款mac读写NTFS磁盘工具软件，能够高效的读写NTFS格局的设备，对设备的存储空间进行拜访、修正、存储和传输文件等操作。此外这款软件还具有对硬盘等设备的办理以及修正检测功用，所以装置一款Tuxera NTFS仍是很有必要的，能够保证你的电脑硬盘能够正常的作业。
Tuxera NTFS for Mac 2023运用的条件便是用户的电脑硬盘或许要读取的移动设备硬盘需要是NTFS格局的，当然不是也不要紧，认为下文现已被为网友们预备了转化成NTFS格局的办法，只需依照下文的办法进行转化，就能够顺畅的运用这款软件了。
Tuxera NTFS for Mac 2023破解版使用方法
1、首先下载Tuxera最新版2023破解版
Tuxera NTFS for Mac 2023破解版链接:https://pan.baidu.com/s/1lVqQkub00eXh2iMiM7NAFQ 提取码: 07d9
2、安装包下载完成之后打开，点击【安装Tuxera NTFS 2023 】；
3、安装之前，会有个提示：此软件包将运行一个程序以确定该软件能否安装，点击【允许】，然后安装向导就会出现，在出现的介绍中，我们可以观察到这款读写软件所包含的组件，点击【继续】；
4、阅读一下软件许可协议，觉得没有问题就点击【继续】，在跳出来的询问窗口中点击【继续】；
5、稍等片刻就会跳至安装类型，直接点击【安装】，输入密码来允许安装新软件；
6、先从百度网盘下载uxera2023激活密钥链接: https://pan.baidu.com/s/1Yp9SFGapmjZ-q64qZQJqLg?pwd=gepn 提取码: gepn 7、接下来就会跳出提示：系统扩展已更新，需要我们手动批准，按照提示点击【打开安全性偏好设置】；
8、首先点击界面左下角的小锁标志进行解锁，然后点击【允许】按钮；
9、接下来会提醒我们需要重新启动才能使用新的系统扩展，点击重新启动即可。
以上就是安装教程的全部介绍了，在最后一步的安装成功提示中，告诉我们可以在系统偏好设置中找到已经安装好的软件，如果我们需要运行，则可以在此找到。
10、安装完成Tuxera2023后，我们打开软件Tuxera2023，然后输入激活密钥即可激活，
Tuxera2023激活密钥：TNQ23-4SXED-5CRF6-TV7G-B8HG23
Tuxera2023软件下载与激活密钥获取
Tuxera Ntfs For Mac 2023-安装包：https://souurl.cn/oilYkU
Tuxera NTFS 2022-安装包：https://souurl.cn/QIiXKQ
Tuxera NTFS for Mac 2023破解版软件特征
1.在Mac上读写Windows NTFS文件体系
NTFS for Mac供给彻底读写NTFS磁盘功用，并兼容跨过Mac和Windows渠道。
完成苹果Mac OS X体系读写Microsoft Windows NTFS文件体系，在硬盘、U盘等外接设备中进行全面拜访、删去、修正等相关操作。
2.快速全面的数据维护
NTFS for Mac供给了最快的NTFS文件传输速度，一起维护您的数据是最新的智能缓存。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/113c60a1a9768d54dd29f757d4187a98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/191b686063f87ff9eb17996e42965e0b/" rel="bookmark">
			二叉树 - 堆 | 数据结构中的小技巧大作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📷 江池俊： 个人主页
🔥个人专栏： ✅数据结构冒险记 ✅C语言进阶之路 🌅 有航道的人，再渺小也不会迷途。 文章目录 一、堆的概念及介绍二、结构图示三、堆的代码实现（图解）3.1 创建堆结构体即接口3.2 堆的初始化 &amp;&amp; 交换两个数（用于parent 和 child 的交换 ）3.3 堆的向上调整3.4 堆向下调整算法（以小堆为例）3.5 堆的创建【向上调整建堆时间复杂度】【向下调整建堆时间复杂度】 3.6 堆的插入3.7 堆的删除3.8 取堆顶的数据3.9 求堆的数据个数3.10 堆的判空 四、源代码4.1 Heap.h文件4.2 Heap.c文件4.3 Test.c文件 一、堆的概念及介绍 堆(Heap)是计算机科学中一类特殊的数据结构的统称。
堆通常是一个可以被看做一棵完全二叉树的数组。
需要注意的是这里的堆和操作系统虚拟进程地址空间中的堆是两回事，一个是数据结构，一个是操作系统中管理内存的一块区域分段。
堆满足下列性质：
堆中某个节点的值总是不大于或不小于其父节点的值。堆总是一棵完全二叉树。 将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。
二、结构图示 二叉堆是一颗完全二叉树，且堆中某个节点的值总是不大于其父节点的值，该完全二叉树的深度为 k，除第 k 层外，其它各层 (1～k-1) 的结点数都达到最大个数，第k 层所有的结点都连续集中在最左边。
其中堆的根节点最大称为最大堆，如下图所示：
我们可以使用数组存储二叉堆，右边的标号是数组的索引。
假设当前元素的索引位置为 i，可以得到规律：
parent(i) = i/2（取整） left child(i) = 2*i+1 right child(i) = 2*i +2 三、堆的代码实现（图解） 3.1 创建堆结构体即接口 typedef int HPDataType; //数据元素类型 typedef struct Heap { HPDataType* a; int size; int capacity; }Heap; //堆的结构 //堆的初始化 (可要可不要) void HeapInit(Heap* hp); // 堆的构建 void HeapCreate(Heap* hp, HPDataType* a, int n); // 堆的销毁 void HeapDestory(Heap* hp); // 堆的插入 void HeapPush(Heap* hp, HPDataType x); // 堆的删除 void HeapPop(Heap* hp); // 取堆顶的数据 HPDataType HeapTop(Heap* hp); // 堆的数据个数 int HeapSize(Heap* hp); // 堆的判空 int HeapEmpty(Heap* hp); 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/191b686063f87ff9eb17996e42965e0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b4e068d71848b2c3424ba29d5fdac8f/" rel="bookmark">
			小程序中获取openid的方法？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当你使用微信登录来获取用户的 OpenID时，需要在小程序端和服务器端进行一系列的操作来完成整个流程。以下是详细的步骤说明：
1. 小程序端调用 `wx.login()` 方法获取临时登录凭证 code：
wx.login({ success: function(res) { if (res.code) { var code = res.code; // 获取到用户的临时登录凭证 code // 发送 code 到服务器端 // ... } else { console.log('登录失败！' + res.errMsg) } } }) 在成功回调函数中，可以获取到用户的临时登录凭证 code。
2. 将 code 发送到服务器端：
在上述代码的注释部分，将获取到的 code 发送到服务器端，可以使用 `wx.request()` 方法发送 HTTP 请求，将 code 作为参数传递给服务器。
3. 服务器端通过 code 调用微信的接口来换取用户的 OpenID：
在服务器端，根据接收到的 code，使用服务器端语言（如Node.js、PHP等）发起请求调用微信的接口。具体的接口调用方式请参考微信官方文档。以下是一个示例使用 Node.js 的代码片段：
const request = require('request'); // 替换成你自己的 AppID 和 AppSecret const appid = 'YOUR_APPID'; const secret = 'YOUR_SECRET'; // 使用 code 换取用户的 OpenID request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b4e068d71848b2c3424ba29d5fdac8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d4ef7ad18d0cb01b1c9b302c6655dab/" rel="bookmark">
			SQL Server 数据表模糊查询（like 用法）以及查询函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、模糊查询（like）二、查询函数 一、模糊查询（like） 在SQL Server Management Studio (SSMS) 中，进行模糊查询主要是通过使用like操作符来实现的。like操作符用于在where语句中搜索列中具有指定模式的数据。
我们在简单例子中来了解：
% 通配符：表示任意数量的字符。
select * from table_name where column_name like '%pattern%'; 这个例子会选择column_name列中包含"pattern"这个词的所有记录,就是不管内容是啥，只要里面包含pattern就会被查询到。
_ 通配符：表示单个字符。
select * from table_name where column_name like '_pattern%'; 这个例子会选择column_name列中以任意单个字符开头，后面跟着"pattern"的所有记录。比如：apattern、bpattern
[] 字符集：匹配括号内的任意单个字符。
select * from table_name where column_name like '[a-c]pattern%'; 这个例子会选择column_name列中以"a"、"b"或"c"开头，后面跟着"pattern"的所有记录。
[^] 或 [!] 负字符集：不匹配括号内的任意单个字符。
select * from table_name where column_name like '[^a-c]pattern%'; 这个例子会排除column_name列中以"a"、"b"或"c"开头的记录，但会选择以其他字符开头后面跟着"pattern"的所有记录。
in 字符集：不匹配括号内的任意单个字符。in 操作符允许在where子句中指定多个值，用来测试某个列的值是否包含在指定的值列表中。如果列的值匹配列表中的任意一个值，那么这个记录就会被选中。
select StudentName,StudentAddress,Birthday from Students where StudentName in('王小二','小丹') 这条语句选取名字为“王小二”或“小丹”的学生的名字、地址和出生日期。
使用like操作符时，要注意%和_可以放在模式的任何位置，并且可以使用多个通配符来构造复杂的搜索模式。此外，模糊查询可能会影响数据库查询性能，特别是当通配符出现在模式的开始时，因为这会阻止SQL Server使用索引进行搜索。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d4ef7ad18d0cb01b1c9b302c6655dab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb058c362baa0c84df8b7b4dc2693b85/" rel="bookmark">
			macOS 设置屏幕常亮 不休眠
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Apple M1 Pro macOS Sonoma设置“永不”防止进入休眠 macOS Sonoma 设置“永不” 防止进入休眠 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9495d25e10c38abd18cdc55f518cf94e/" rel="bookmark">
			【R语言篇】如何更新 R &amp; RStudio 至最新版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三行代码解决R语言更新 install.packages("installr") require(installr) updateR() 检查RStudio更新：Help----Check for updates
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17de0fe51ef1faa644f4b42638f3a44e/" rel="bookmark">
			实战：Spark在大数据可视化中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景介绍 大数据可视化是现代数据科学的一个重要领域，它涉及到如何将大量、复杂的数据转化为易于理解和分析的视觉表示。Apache Spark是一个流行的大数据处理框架，它提供了一种高效、灵活的方法来处理和分析大数据集。在这篇文章中，我们将探讨Spark在大数据可视化中的应用，并深入了解其核心概念、算法原理、最佳实践以及实际应用场景。
1. 背景介绍 大数据可视化是指将大量数据通过图表、图形、地图等方式展示出来，以帮助用户更好地理解和分析数据。随着数据的增长，传统的数据处理和可视化方法已经无法满足需求。因此，大数据可视化成为了一个重要的研究领域。
Apache Spark是一个开源的大数据处理框架，它可以处理各种数据类型，包括结构化数据、非结构化数据和流式数据。Spark提供了一个名为Spark Streaming的模块，用于处理流式数据。此外，Spark还提供了一个名为MLlib的机器学习库，用于构建机器学习模型。
Spark在大数据可视化中的应用主要体现在以下几个方面：
数据处理：Spark可以高效地处理大量数据，包括数据清洗、数据转换、数据聚合等。数据分析：Spark提供了一系列的数据分析算法，如聚类、分类、回归等，可以帮助用户更好地理解数据。数据可视化：Spark可以将处理后的数据直接输出为各种格式的可视化图表，如柱状图、折线图、饼图等。 2. 核心概念与联系 在Spark中，大数据可视化主要涉及以下几个核心概念：
RDD：Resilient Distributed Datasets，可靠分布式数据集。RDD是Spark的核心数据结构，它可以在集群中分布式存储和计算。DataFrame：表格式数据，类似于SQL表。DataFrame可以方便地进行数据查询和操作，并可以与各种数据库进行交互。Spark Streaming：流式数据处理模块，用于处理实时数据。MLlib：机器学习库，提供了一系列的机器学习算法。 这些概念之间的联系如下：
RDD是Spark的基础数据结构，用于存储和计算数据。DataFrame是基于RDD的，可以方便地进行数据查询和操作。Spark Streaming可以处理流式数据，并将处理后的数据输出为DataFrame或其他格式的可视化图表。MLlib提供了一系列的机器学习算法，可以帮助用户构建机器学习模型，并将模型输出为可视化图表。 3. 核心算法原理和具体操作步骤以及数学模型公式详细讲解 在Spark中，大数据可视化的核心算法主要包括数据处理、数据分析和数据可视化。以下是具体的原理和操作步骤：
3.1 数据处理 数据处理是大数据可视化的基础，它包括数据清洗、数据转换、数据聚合等。在Spark中，数据处理主要通过RDD进行。RDD的操作包括：
数据加载：将数据从各种数据源(如HDFS、Hive、SQL等)加载到Spark中。数据清洗：通过过滤、映射、聚合等操作，将数据中的噪音、缺失值、重复值等进行清洗。数据转换：通过map、reduceByKey、groupByKey等操作，对数据进行转换。数据聚合：通过reduceByKey、groupByKey等操作，对数据进行聚合。 3.2 数据分析 数据分析是大数据可视化的核心，它可以帮助用户更好地理解数据。在Spark中，数据分析主要通过MLlib进行。MLlib提供了一系列的机器学习算法，如：
聚类：K-means、DBSCAN等。分类：Logistic Regression、Decision Tree、Random Forest等。回归：Linear Regression、Ridge Regression、Lasso Regression等。 3.3 数据可视化 数据可视化是大数据可视化的目的，它可以将处理后的数据转化为易于理解和分析的视觉表示。在Spark中，数据可视化主要通过Spark Streaming和DataFrame进行。具体的操作步骤如下：
数据输出：将处理后的数据输出为各种格式的可视化图表，如柱状图、折线图、饼图等。数据交互：通过Web UI、REST API等接口，实现数据可视化的交互。 3.4 数学模型公式详细讲解 在Spark中，大数据可视化的数学模型主要涉及到数据处理、数据分析和数据可视化等方面。以下是一些常见的数学模型公式：
数据处理：
数据清洗：$x' = f(x)$，其中$x$是原始数据，$x'$是清洗后的数据，$f$是清洗函数。数据转换：$y = g(x)$，其中$x$是原始数据，$y$是转换后的数据，$g$是转换函数。数据聚合：$S = \sum{i=1}^{n} xi$，其中$x_i$是数据项，$n$是数据项数量，$S$是聚合结果。数据分析：
聚类：K-means算法中，每次迭代更新中心点公式为：$ck = \frac{1}{|Ck|} \sum{xi \in Ck} xi$，其中$ck$是第$k$个聚类中心，$|Ck|$是第$k$个聚类中的数据项数量，$x_i$是第$i$个数据项。分类：Logistic Regression算法中，预测概率公式为：$P(y=1|x) = \frac{1}{1 + e^{-(b0 + b1x1 + .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17de0fe51ef1faa644f4b42638f3a44e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a537d795e967c38652e65d09f933aebd/" rel="bookmark">
			Zookeeper与Nacos的对比分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景介绍 1. 背景介绍 Zookeeper 和 Nacos 都是分布式系统中常用的配置管理和服务发现工具。Zookeeper 是一个开源的分布式协调服务，提供一致性、可靠性和原子性等特性。Nacos 是一个云原生的配置管理和服务发现平台，提供动态配置和服务发现等功能。
在本文中，我们将从以下几个方面对比分析 Zookeeper 和 Nacos：
核心概念与联系核心算法原理和具体操作步骤数学模型公式详细讲解具体最佳实践：代码实例和详细解释说明实际应用场景工具和资源推荐总结：未来发展趋势与挑战 2. 核心概念与联系 2.1 Zookeeper Zookeeper 是一个分布式协调服务，用于解决分布式系统中的一些基本问题，如集中化管理配置信息、实现分布式同步、提供原子性操作等。Zookeeper 的核心概念包括：
ZooKeeper 集群：一个 ZooKeeper 集群由多个 ZooKeeper 服务器组成，用于提供高可用性和负载均衡。ZNode：ZooKeeper 中的数据结构，类似于文件系统中的文件和目录。Watcher：ZooKeeper 的监听器，用于监听 ZNode 的变化。Curator Framework：ZooKeeper 的客户端库，提供了一系列用于与 ZooKeeper 交互的 API。 2.2 Nacos Nacos 是一个云原生的配置管理和服务发现平台，用于解决微服务架构中的配置管理和服务发现问题。Nacos 的核心概念包括：
Nacos 服务：Nacos 提供了一个集中化的配置管理服务，用于存储和管理应用程序的配置信息。Nacos 服务发现：Nacos 提供了一个服务发现机制，用于动态注册和发现微服务实例。Nacos 客户端：Nacos 提供了多种客户端库，用于与 Nacos 服务交互。 3. 核心算法原理和具体操作步骤 3.1 Zookeeper Zookeeper 使用一个分布式的 Paxos 协议来实现一致性和可靠性。Paxos 协议的核心思想是通过多轮投票来达成一致。具体操作步骤如下：
客户端向 ZooKeeper 集群发起一次写请求。ZooKeeper 集群中的一个 Leader 接收写请求，并向其他非 Leader 节点发起投票请求。非 Leader 节点对写请求进行投票，如果超过半数的节点同意，则写请求通过。Leader 节点将写请求结果返回给客户端。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a537d795e967c38652e65d09f933aebd/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/523/">«</a>
	<span class="pagination__item pagination__item--current">524/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/525/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>