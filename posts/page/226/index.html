<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/285f23c5fd918283727823762e87adf7/" rel="bookmark">
			什么是前端开发？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端开发是什么一种工作？这里以修房子举例： jquery根据数据去生成对应的html代码。首先得有一个html代码的“房屋构造”，然后根据数据去填充“房屋构造”的“血肉”，最后JavaScript通过事件等方法给一砖一瓦修好的房屋添加“灵魂”、“思想”。
这就是前端工作涉及到的三大组成部分：HTML、css、javaScript；对应分别是：“骨架”、“血肉”、“灵魂”。在写代码的过程中，一砖一瓦就是一个键盘一个键盘敲击出来的“王国”，首先搭建地基，修建房梁，使其有个大概得轮廓，而后用白粉、水泥装饰它，写到这儿是不是就结束了呢？答案是：不是的，前面两步是静态的，房子感觉修好了，但是静态的，这需要源源不断的灵魂、活力注入，所以里面需要住一家人，人可以在里面做各种事情。
说得或许不对，仅代表个人观点。。。 前端开发需要不断的学习知识 前端变化快，年年变，月月变。你看前端框架都变了好多了？从原生的html、css、javaScript三者分离；到jquery操作dom节点+layui组件的使用；到Vue前端框架、React前端框架、(市面上常用的是这两种)，还有其它：Angular、Svelte、Ember.js、Backbone.js等
不同前端框架的介绍 ，以及特点介绍 React:
简介: 由 Facebook 开发和维护的 JavaScript 库，用于构建用户界面，特别是单页应用。特点: 组件化: UI 被分割成独立的、可复用的组件。虚拟DOM: 提高性能，通过在内存中维护虚拟DOM来最小化实际DOM操作。单向数据流: 数据流动方向明确，有利于调试和理解应用。主要使用场景: 单页应用（SPA），需要高交互性的用户界面。 Vue.js:
简介: 由 Evan You 开发的渐进式 JavaScript 框架，用于构建用户界面。特点: 渐进式框架: 可以根据需求选择性使用框架功能。双向数据绑定: 提供类似 Angular 的数据绑定机制。组件化: 支持组件化开发，简化 UI 组件的开发和管理。主要使用场景: 中小型项目、需要快速上手的项目。 Angular:
简介: 由 Google 开发和维护的前端框架，用于构建复杂的大型应用。特点: 完整框架: 提供了从数据绑定、表单处理到路由、依赖注入等一系列功能。双向数据绑定: 模型和视图自动同步。TypeScript: 使用 TypeScript 编写，提供了静态类型检查和现代 JavaScript 特性。主要使用场景: 企业级应用，大型复杂项目。 Svelte:
简介: 一种新型的前端框架，区别于其他框架，它在构建时而不是运行时执行大部分工作。特点: 无虚拟DOM: 编译时转换为高效的原生 JavaScript 代码，直接操作 DOM。性能优越: 因为编译时完成了大部分工作，运行时性能优于虚拟DOM框架。更少的代码: 语法简洁，需要编写的代码量少。主要使用场景: 性能要求高、需要轻量级解决方案的项目。 Ember.js:
简介: 用于构建复杂的单页应用的前端框架。特点: 约定优于配置: 采用大量的约定，减少开发者的配置和决策。强大的路由系统: 支持嵌套路由和异步数据加载。稳定性: 框架的 API 和功能稳定，适合长期维护的项目。主要使用场景: 需要快速开发、维护成本低的复杂应用。 Backbone.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/285f23c5fd918283727823762e87adf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e29e077c5a5b57a8c8403fd06522204/" rel="bookmark">
			图像亮度和对比度的调整
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在网上找了很多图像亮度的调整算法，下面是其中一种，可以通过条形框进行调整，并实时的查看对应参数值后的效果。
图像亮度处理公式:
y = [x - 127.5 * (1 - B)] * k + 127.5 * (1 + B);
x 是输入像素值
y 是输出像素值
B 是亮度值， 范围在[-1,1]之间
对比度处理公式：
k是调节对比度
k = tan( (45 + 44 * c) / 180 * PI );
c 是对比度值, 范围在[-1,1]之间
下面是具体实现代码
#include &lt;iostream&gt; #include "opencv2/core.hpp" #include "opencv2/imgproc.hpp" #include "opencv2/highgui.hpp" using namespace std; using namespace cv; #define SWAP(a, b, t) do { t = a; a = b; b = t; } while(0) #define CLIP_RANGE(value, min, max) ( (value) &gt; (max) ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e29e077c5a5b57a8c8403fd06522204/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f2987d76f95c6f9003f15698c7db8dc/" rel="bookmark">
			nvm安装详细教程（卸载旧的nodejs，安装nvm、node、npm、cnpm、yarn及环境变量配置）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、完全卸载旧的nodejs1、打开系统的控制面板，点击卸载程序，卸载nodejs（1）打开系统的控制面板，点击程序下的卸载程序（2）找到node.js，鼠标右击出现下拉框，点卸载（3）确认卸载弹窗，点击是，等待卸载完成。 2、删除node的安装目录3、查找.npmrc文件是否存在，有就删除4、逐一查看以下文件是否存在，存在就删除5、打开系统设置，检查系统环境变量，将node相关的配置都删掉6、查看是否卸载成功7、最后，建议重启电脑 二、安装nvm1、下载NVM2、双击下载好的文件，开始安装3、选择我接受，然后点击next4、选择NVM安装路径，路径名称不要有空格，然后点击next5、node.js安装路径，然后点击next6、点击Install7、点击Finish,完成安装 三、nvm修改镜像源四、nvm常用命令五、nvm配置环境变量六、安装nodejs及环境变量配置1、通过nvm安装node2、node环境变量配置（1） 配置全局安装的模块路径和缓存路径（2）设置用户变量（3）设置系统变量 3、测试4、设置淘宝的镜像并查看 七、全局安装cnpm八、全局安装yarn九、笔者的安装目录结构 注意：
1、安装nvm之前需要卸载之前的nodejs，并且还要删除之前的环境变量配置，否则会出现一些奇怪的问题
2、nvm的安装路径不能有中文或者空格，否则后面在cmd中切换node版本会出现乱码
一、完全卸载旧的nodejs 参考文章《Node卸载超详细步骤》
1、打开系统的控制面板，点击卸载程序，卸载nodejs （1）打开系统的控制面板，点击程序下的卸载程序 （2）找到node.js，鼠标右击出现下拉框，点卸载 （3）确认卸载弹窗，点击是，等待卸载完成。 2、删除node的安装目录 安装目录默认是C:\Program Files\nodejs，我的在安装时选择的安装位置在D:\Program Files\nodejs。
查看该路径下是否有node文件，在控制面板卸载node后一般会自动删除node文件，如果文件还在的话就手动删除，没有的话就忽略。
3、查找.npmrc文件是否存在，有就删除 .npmrc默认在C:\User\用户名。
.node_repl_history如果存在也删除，没有请忽略。
4、逐一查看以下文件是否存在，存在就删除 C:\Program Files (x86)\NodejsC:\Program Files\NodejsC:\Users\用户名\AppData\Roaming\npmC:\Users\用户名\AppData\Roaming\npm-cacheC:\Users\用户名\AppData\Local\npm-cache 5、打开系统设置，检查系统环境变量，将node相关的配置都删掉 一般系统会自动把node环境变量删掉了，可以不用管这步环境变量打开方式：我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;删掉用户变量和系统变量的NODE_PATH 及Path 里的相关的node（注意，不要把整个path删掉，点击编辑，只删除node相关的即可；如果手误，依次点击取消关闭弹窗就不会保存成功，若是手误删掉了，还点击的是确定按钮，那笔者也没有办法了）确认删除无误之后，依次点击确定关闭，否则可能存在删除失败问题
6、查看是否卸载成功 在键盘上按下win + R ，输入cmd ，然后点击回车键，在命令行中输入node -v npm -v，如下图所示表示卸载成功。
,
7、最后，建议重启电脑 二、安装nvm 参考文章《nvm-下载、安装、使用（2023/07/12更新）》 《安装nvm，并使用nvm安装nodejs及配置环境变量》
1、下载NVM 地址：https://github.com/coreybutler/nvm-windows/releases点击nvm-setup.exe进行下载 2、双击下载好的文件，开始安装 3、选择我接受，然后点击next 4、选择NVM安装路径，路径名称不要有空格，然后点击next 5、node.js安装路径，然后点击next 6、点击Install 7、点击Finish,完成安装 三、nvm修改镜像源 参考文章《nvm下载、nvm安装、nvm修改镜像源、nvm使用》
win + R ，输入cmd ，回车后，在命令行输入nvm root 命令，可以查看nvm的安装根路径在那个文件夹 在文件管理器地址栏输入root地址，找到setting.txt文件并打开 复制粘贴以下代码，如图所示。保存完成nvm源修改。 node_mirror: https://npmmirror.com/mirrors/node/ npm_mirror: https://npmmirror.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f2987d76f95c6f9003f15698c7db8dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59029adfa1eb43075efb16cdf55e3dc6/" rel="bookmark">
			原来链表如此简单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于顺序表（数组）的插入、删除操作需要移动大量的元素，影响了运行效率，因此引入了线性表的链式存储——单链表。单链表通过一组任意的存储单元来存储线性表中的数据元素，不需要使用地址连续的存储单元，因此它不要求在逻辑上相邻的两个元素在物理位置上也相邻，所以单链表是非随机存取结构，不能直接找到表中某个特定的结点。查找某个特定的结点时，需要从第一个结点开始遍历，依次查找。
单链表的基本构成 其中：data表示数据域，用于存放该结点的数据信息；next表示指针域，用于存放相邻下一结点的地址。
单链表中结点类型的描述如下： struct LNode { int data; LNode* next; }; 单链表的基本操作 单链表的查找-按值进行查找 查找值x在单链表L中的结点指针（指针即地址）。
算法思想：从单链表的第一个结点开始，依次比较表中各个结点的数据域的值，若某结点数据域的值等于num，则返回该结点的指针；若整个单链表中没有这样的结点，则返回空。
按值查找结点值的算法如下： LNode *LocateElem(LNode *L, int num) { LNode *p = L-&gt;next; while (p != NULL &amp;&amp; p-&gt;data != num) { p = p-&gt;next; } return p; } 单链表的查找-按位置进行查找 查找单链表L中第 i（i&gt;0）个位置的结点指针。
算法思想：从单链表的第一个结点开始，顺着指针域逐个往下搜索，直到找到第 i 个结点为止，否则返回最后一个结点的指针域NULL。
按位查找结点值的算法如下： LNode *GetElem(LNode *L, int i) { LNode *p = L-&gt;next; if (p == NULL) { return NULL; } int j = 1; while (p !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59029adfa1eb43075efb16cdf55e3dc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/701d71d728f3cd7cf7f8b0b630c574dd/" rel="bookmark">
			高效安全的IPXProxy代理服务：摆脱免费代理的烦恼
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​在现代互联网环境中，IP代理的使用变得越来越普遍。无论是企业级用户还是个人用户，都需要借助IP代理来实现隐私保护、网络加速和跨区域访问。然而，面对市场上众多的代理服务，有些用户会因为成本考虑而选择免费代理。然而，免费代理虽然不花钱，但在使用过程中往往会带来各种问题和风险。那么，为什么我们应该选择像IPXProxy这样的付费代理服务呢？
免费代理的陷阱
免费代理看似是一种便捷且经济的选择，但实际使用中却常常问题重重：
1. 资源有限：免费代理的IP资源往往有限，企业用户需要大量有效的IP来进行日常业务，但免费代理提供的IP数量少且重复率高，远远不能满足需求。
不稳定：由于缺乏维护和升级，免费代理服务器经常出现故障和网络延迟，影响用户的正常使用。
2. 安全隐患：免费代理缺乏安全保护措施，用户容易受到恶意软件、间谍软件和黑客攻击的威胁，敏感信息面临泄露风险。
速度慢：免费代理服务器的质量和速度难以保证，网络连接不稳定，常常导致访问速度缓慢。
为什么选择IPXProxy代理服务？
相比之下，IPXProxy代理服务以其稳定性、安全性和高效性脱颖而出，是解决上述问题的理想选择。
1. 丰富的IP资源：IPXProxy提供大量高质量的IP资源，能够满足企业级用户的需求。其IP代理池庞大，用户可以自由切换IP，确保业务连续性和灵活性。
2. 高稳定性：IPXProxy拥有专业的技术团队和先进的基础设施，确保代理服务器的高稳定性和低延迟，用户无需担心频繁的网络故障。
3. 卓越的安全性：IPXProxy重视用户的隐私和数据安全，采用先进的加密技术保护用户信息，防止恶意软件和黑客攻击，保障用户的安全使用环境。
4. 快速连接：IPXProxy的代理服务器经过精心优化，提供高速稳定的网络连接，让用户享受流畅的上网体验。
结语
虽然免费代理看似经济，但在实际使用中会遇到各种问题，难以保障业务的安全和稳定。相比之下，IPXProxy代理服务以其丰富的IP资源、高稳定性、卓越的安全性和快速的连接速度，为用户提供了更优质的选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/507aaf4d8e42d60de9f3bce24122e72e/" rel="bookmark">
			万字详解Kafka并附带go操作Kafka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要学习https://blog.csdn.net/cao1315020626/article/details/112590786?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171886470616800197016195%2522%252C%2522scm%2522%253A%252220140713.130102334…%2522%257D&amp;request_id=171886470616800197016195&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2alltop_positive~default-1-112590786-null-null.142v100pc_search_result_base3&amp;utm_term=Kafka&amp;spm=1018.2226.3001.4187
基于上文加上上文博主没讲到的地方和自己的一些理解
1 Kafka基本概念 Kafka是一种消息队列，同样具有消息队列的好处
解耦合
耦合的状态表示当你实现某个功能的时候，是直接接入当前接口，而利用消息队列，可以将相应的消息发送到消息队列，这样的话，如果接口出了问题，将不会影响到当前的功能。
异步处理
异步处理替代了之前的同步处理，异步处理不需要让流程走完就返回结果，可以将消息发送到消息队列中，然后返回结果，剩下让其他业务处理接口从消息队列中拉取消费处理即可。
流量削峰
高流量的时候，使用消息队列作为中间件可以将流量的高峰保存在消息队列中，从而防止了系统的高请求，减轻服务器的请求处理压力。
1.1 Kafka消费模式 主要有两种一对一和一对多，一般来说，都是用一对多模式（至少我目前没用过一对一）
一对一模式：
生产者将消息发送到生产队列，消费者进行消费，消费完毕后该消息删除，整个生产消费过程是非阻塞的，类似与我们go中有缓冲区的channel
一对多模式：
一个生产者对应多个消费者，生产者将消息生产到生产队列的Topic中，消费者订阅某一个或者多个Topic进行消费，消费后并不会删除消息，默认保存一段时间，具体消费方式设计到分区等，后面会说。
1.2Kafka基础架构 Producer：消息生产者，向Kafka中发布消息的角色。
Consumer：消息消费者，即从Kafka中拉取消息消费的客户端。
Consumer Group：消费者组，消费者组则是一组中存在多个消费者，消费者消费Broker中当前Topic的不同分区中的消息，消费者组之间互不影响，所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。某一个分区中的消息只能够一个消费者组中的一个消费者所消费
Broker：经纪人，一台Kafka服务器就是一个Broker，一个集群由多个Broker组成，一个Broker可以容纳多个Topic。
Topic：主题，可以理解为一个队列，生产者和消费者都是面向一个Topic
Partition：分区，为了实现扩展性，一个非常大的Topic可以分布到多个Broker上，一个Topic可以分为多个Partition，每个Partition是一个有序的队列(分区有序，不能保证全局有序)，一个分区只能被同一个消费者组中的一个消费者消费，这确保了每条消息只能被消费者组中的一个消费者处理。不同消费者组中的消费者可以独立消费不同的分区，但一个分区只能被同一消费者组中的一个消费者消费。
Replica：副本Replication，为保证集群中某个节点发生故障，节点上的Partition数据不丢失，Kafka可以正常的工作，Kafka提供了副本机制，一个Topic的每个分区有若干个副本，一个Leader和多个Follower
Leader：每个分区多个副本的主角色，生产者发送数据的对象，以及消费者消费数据的对象都是Leader。
Follower：每个分区多个副本的从角色，实时的从Leader中同步数据，保持和Leader数据的同步，Leader发生故障的时候，某个Follower会成为新的Leader。
Offset：Kafka的分区中的每一个消息的位置都由offset来表示
1.3 Kafka工作流程 Kafka中，Topic可以视为一个逻辑地址，实际上topic是分布到多个partition上的，partition通常有一个log文件，消息一般是直接新加到log文件的末端，消费者每次消费都会更新offset，以便清楚自己下次消费的位置，所以一个topic通常对应多个partition，然后一个partition通常对应一个log（有可能分裂）
1.4 Kafka的文件存储（这个用到的比较少） Kafka中一般是一个topic对应多个partition，一个partition对应多个segment，一个segment对应两个文件，一个index，一个log，log就是用来存储我们的消息的，index是用于大量数据情况下快速定位的
.index文件存储的消息的offset+真实的起始偏移量。.log中存放的是真实的数据。
1.5 Kafka生产者分区 分区的原因
1.方便在集群中扩展：每个partition通过调整以适应它所在的机器，而一个Topic又可以有多个partition组成，因此整个集群可以适应适合的数据
2。可以提高并发：以Partition为单位进行读写。类似于多路。
分区的原则
1.指明partition（这里的指明是指第几个分区）的情况下，直接将指明的值作为partition的值
2.没有指明partition的情况下，但是存在值key，此时将key的hash值与topic的partition总数进行取余得到partition值
3.值与partition均无的情况下，第一次调用时随机生成一个整数，后面每次调用在这个整数上自增，将这个值与topic可用的partition总数取余得到partition值，即round-robin算法。
1.6 Kafka的ack机制 为了确保数据能落盘，producer发送消息后，需要收到相应leader的ack，收到后再进行下一轮发送
1.61 何时发送ack leader发送ack一般是有两种方式，一种是半数follower同步完成，还有一种是全部follower同步完成，Kafka采用的是第二种，主要是因为网络对Kafka影响较小，所以等一半还是等全部差距不大。
关于故障处理一般是通过维护一个isr，如果leader发现某一follower长时间未回应，则将其提出isr，如果leader掉线，则再isr中重新选举
1.62 三种ack ack 0 ： producer不需要等到leader的ack直接进行下一轮发送，速度非常快，但存在数据丢失的风险
ack 1 ： producer仅需要等待leader的ack，可能会出现follower未同步消息的情况
ack -1 ： producer需要等到leader和follower的ack，可能会出现数据重复的情况
1.63 数据一致性 LEO ： 每个副本的最后一个offset（即最后一个消息）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/507aaf4d8e42d60de9f3bce24122e72e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae687a2cd4c9182995c4e980c01dd626/" rel="bookmark">
			秋招Java后端开发冲刺——非关系型数据库篇（MongoDB）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MongoDB 本文介绍非关系型数据库MongoDB的基础知识和常见面试题。
（一）基础知识 1. 介绍：MongoDB是一个基于分布式文件存储的数据库，由C++语言编写，旨在为WEB应用提供可扩展的高性能数据存储解决方案。
2.特点
特点说明文档存储使用 BSON（二进制 JSON）格式存储文档，支持嵌套结构和数组。灵活的模式（Schema-less）支持动态模式设计，文档结构可以不固定，适合快速迭代开发。高性能通过内存映射文件和高效的索引机制，提供高性能读写操作。高可用性支持复制集（Replica Set），提供自动故障转移和数据冗余。横向扩展支持分片（Sharding）功能，通过分布式架构实现数据的水平扩展。强一致性默认提供强一致性保证，通过复制集配置可以调整一致性级别。丰富的查询语言提供丰富的查询语言，支持字段、范围、正则表达式查询以及聚合框架。原子操作支持单文档级别的原子操作，确保数据修改的一致性和完整性。支持事务4.0 版本开始支持多文档 ACID 事务，增强数据操作的可靠性。跨平台支持多种操作系统，包括 Windows、Linux 和 macOS。易于集成提供多种官方驱动程序，支持多种编程语言，如 JavaScript、Python、Java、C# 等。强大的社区支持拥有活跃的社区和丰富的文档资料，便于开发者学习和使用。灵活的索引支持多种类型的索引，如单字段索引、复合索引、地理空间索引和全文索引。聚合框架提供强大的聚合框架，支持数据处理和分析操作，如过滤、排序、分组、投影等。文件存储通过 GridFS 实现大文件存储，适用于存储图片、视频等大文件数据。安全性提供认证和授权机制，支持基于角色的访问控制（RBAC），确保数据安全。备份与恢复提供多种备份与恢复机制，包括快照备份、导入导出工具和云备份服务。可视化工具提供官方的 MongoDB Compass 可视化工具，便于管理和分析数据库。 3. 存储结构
（1）文档
文档是 MongoDB 的基本数据单位，使用 BSON 格式存储。每个文档包含键值对，类似于 JSON 对象.
注：BSON文档是JSON 文档的二进制表示
（2）集合
集合是一组文档的容器，相当于关系型数据库中的表。集合中的文档可以具有不同的结构。
（3）数据库
数据库是集合的命名空间，相当于关系型数据库中的数据库，每个数据库包含集合、索引和一些元数据。
4. 存储引擎
MangoDB的默认存储引擎是 WiredTiger，支持文档级别的并发控制和压缩。除此之外，MangoDB还支持 MMAPv1（旧版本）和其他第三方存储引擎。
（1）WiredTiger存储引擎
① WiredTiger是MongoDB 3.2 版本开始默认的存储引擎，提供了更高的并发性、压缩和高效的内存使用。
② 特点
文档级锁定：WiredTiger 使用文档级锁定，提高了并发写操作的性能数据压缩：支持数据和索引压缩，减少磁盘空间的使用缓存管理：WiredTiger 使用自适应缓存管理，优化内存使用事务支持：提供多文档 ACID 事务支持，保证数据一致性（与InnoDB事务不相同）
③ 配置 storage: dbPath: /var/lib/mongodb engine: wiredTiger wiredTiger: engineConfig: cacheSizeGB: 1 statisticsLogDelaySecs: 0 journalCompressor: snappy collectionConfig: blockCompressor: snappy indexConfig: prefixCompression: true （2）MMAPv1 存储引擎
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae687a2cd4c9182995c4e980c01dd626/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6fcf84e2c3a7cd66f923d3d113512da/" rel="bookmark">
			CMakeList整理大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0. CMake应用示例 之前我们也整理过cmake 引入第三方库（头文件目录、库目录、库文件）。但是这里面整理的内容其实是不全的。所以我们需要进一步将CMake的使用整理好。以供后面的学习的工程师来检索查询。
cmake-template ├── CMakeLists.txt └── build └── include └── src └── main.cpp 1. CMakeList基础15例 # 设置CMake的最低版本要求 cmake_minimum_required(VERSION 3.15) # 设置项目名称和版本 project(MyProject VERSION 1.0 DESCRIPTION "An example project with CMake") # 选项，可以通过-D在命令行定义 option(USE_CUSTOM_LIBRARY "Use a custom library" ON) # 定义条件预处理器宏 if(USE_CUSTOM_LIBRARY) add_definitions(-DUSE_CUSTOM_LIB) endif() # 寻找外部依赖包 find_package(Threads REQUIRED) # 指定头文件的搜索路径 include_directories(${PROJECT_SOURCE_DIR}/include) # 指定库文件搜索路径 link_directories(${PROJECT_SOURCE_DIR}/libs) # 添加子目录，这些目录下也应该有自己的CMakeLists.txt add_subdirectory(src) add_subdirectory(libs) # 添加一个可执行文件 add_executable(myExecutable src/main.cpp) # 添加一个静态库 add_library(myStaticLib STATIC src/myStaticLib.cpp) # 添加一个动态库 add_library(mySharedLib SHARED src/mySharedLib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6fcf84e2c3a7cd66f923d3d113512da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0ad5c1147ab7abf3fd2b4776f6a6333/" rel="bookmark">
			pd虚拟机 Parallels Desktop 19 for Mac 破解版小白安装使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Parallels Desktop 19 for Mac 乃是一款适配于 Mac 的虚拟化软件。它能让您在 Mac 计算机上同时运行多个操作系统。您可借此创建虚拟机，并于其中装设不同的操作系统，如 Windows、Linux 或 macOS。使用 Parallels Desktop 19 mac 版时，您可在 Mac 和虚拟机之间无缝切换，同步运行两个操作系统。如此，您便能直接从 Mac 访问 Windows 应用程序和文件，无需重启或切换设备。苹果电脑用户偶尔会遇到需要使用Windows软件的情况，大多人选择再准备一台Windows电脑，方便同时使用。Parallels Desktop虚拟机的出现，彻底解决了“双电脑办公的窘境”。为了解决部分苹果用户无法正常使用虚拟机的麻烦，下面为大家解答Parallels Desktop 19 for mac(pd虚拟机)v19.4.0安装激活图文教程含2024最新激活秘钥
一、准备工作
下载软件
Parallels Desktop 19是一款功能丰富、性能强大且易于使用的虚拟机软件，它可以让您在Mac上同时运行多个操作系统，为您提供更大的灵活性和兼容性。
Parallels Desktop是一款广受好评的Mac虚拟机软件，本文来讲述一下Parallels Desktop是如何下载、安装、激活与换机的。
Parallels Desktop 下载 超过 700 万 Mac 用户信赖Mac虚拟机，唯一微软认证在 Mac 上运行 Windows 11 的解决方案，彻底改变您的 Mac 使用体验。
Parallels Desktop 19破解版下载链接: https://pan.baidu.com/s/19ifG2X6bbJyVHUK7pKZVhw 提取码: 2wva Parallels Desktop 下载地址: https://souurl.cn/o2NLc8
安装Parallels Desktop 直接点击安装包，软件就会自动安装。
安装完成Parallels Desktop后，需要准备安装一个Windows系统的安装镜像文件。接下来，按照Parallels Desktop的界面指引，创建一个新的虚拟机，并在其中安装Windows操作系统。
安装完成Windows操作系统后，可以根据自己的需求对虚拟机进行一些配置调整，例如分配给虚拟机的内存大小、磁盘空间大小以及其他硬件配置等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0ad5c1147ab7abf3fd2b4776f6a6333/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9417a8da9be00ad31ef9df2310d5502/" rel="bookmark">
			数据处理神器Elasticsearch_Pipeline：原理、配置与实战指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 📑引言一、Elasticsearch Pipeline的原理二、Elasticsearch Pipeline的使用2.1 创建 Pipeline2.2 使用 Pipeline 进行索引2.3 常用的 Processor 三、实际应用场景3.1 日志数据处理3.2 数据清洗和标准化3.3 数据增强 四、最佳实践4.1 性能优化4.2 错误处理4.3 测试和调试 五、尾言 📑引言 Elasticsearch是一个强大的分布式搜索引擎，它不仅支持全文搜索，还能够进行结构化搜索、分析和数据处理。在处理数据时，Elasticsearch提供了多种方式进行数据处理和转换，其中 Pipeline 是一个重要的工具。本文将详细介绍 Elasticsearch Pipeline的原理、使用方法以及一些实际应用场景。
一、Elasticsearch Pipeline的原理 Pipeline 是 Elasticsearch 中的一种数据处理机制，用于在数据被索引之前对其进行处理。它主要由 Processor 组成，每个 Processor 执行一个特定的操作。通过将多个 Processor 组合在一起，可以形成一个数据处理的管道（Pipeline）。
Pipeline 的工作流程如下：
接收数据：当数据通过索引请求发送到 Elasticsearch 时，Pipeline 开始工作。处理数据：数据经过 Pipeline 中定义的一系列 Processor，每个 Processor 对数据进行特定的处理，如修改字段、添加字段、删除字段等。输出数据：处理完成后，数据被发送到指定的索引中进行存储。 这种处理方式允许我们在数据存储之前对其进行清洗、转换和增强，使得存储在 Elasticsearch 中的数据更加规范和有用。
二、Elasticsearch Pipeline的使用 2.1 创建 Pipeline 创建一个 Pipeline 需要使用 _ingest/pipeline API。以下是一个示例，创建一个简单的 Pipeline，将字段 message 的内容转换为大写：
PUT _ingest/pipeline/my_pipeline { "description": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9417a8da9be00ad31ef9df2310d5502/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a6582486b1d12d2e50cbd6c898d06c7/" rel="bookmark">
			LeNet网络的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LeNet网络的实现 import torch from torch import nn from d2l import torch as d2l x = 28 net = nn.Sequential( nn.Conv2d(1, 6, kernel_size=5, padding=2), nn.Sigmoid(), nn.AvgPool2d(kernel_size=2, stride=2), nn.Conv2d(6, 16, kernel_size=5), nn.Sigmoid(), nn.AvgPool2d(kernel_size=2, stride=2), nn.Flatten(), nn.Linear(16 * (x/4 - 2) * (x/4 - 2), 120), nn.Sigmoid(), nn.Linear(120, 84), nn.Sigmoid(), nn.Linear(84, 10)) 输入图像是单通道 x*x大小
卷积层。
输入一个通道，输出六个通道，卷积核大小5*5，填充2，步幅1,因此输出图像大小不变。平均汇聚层。
核大小2*2，步幅2，因此输出图像大小减半。（x/2)(x/2）卷积层。
输入6通道，输出16通道，核大小5，输出图像大小减4.(x/2-4) (x/2 - 4)平均汇聚层。
核大小2*2，步幅2，输出大小减半。(x/4-2)(x/4-2)全连接层。
输入大小： 16 * (x/4 - 2) * (x/4 - 2)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a6582486b1d12d2e50cbd6c898d06c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35b22c652e2a59ce3caa04cde6b2ad82/" rel="bookmark">
			ChatGPT的Mac客户端正式发布了！Mac用户有福了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ChatGPT的Mac客户端正式发布了！Mac用户有福了 🎉 大家好，我是猫头虎，科技自媒体博主。今天我带来了一个超级重磅的消息 📢，就是 ChatGPT 的客户端终于来了！这对我们所有 Mac 用户，尤其是使用 MacBook Pro 的朋友来说，绝对是个福音 🎉。无论你是使用 M1、M2 还是最新的 M3 芯片，只要你的系统是 macOS 14 或以上版本，就可以尽情享受这一强大工具。注意：低于 macOS 14 的系统以及非 Apple Silicon M 系列芯片的设备暂不支持哦。 📢 ChatGPT 的客户端终于来了！这对我们所有 Mac 用户来说绝对是个福音。🎉
猫头虎是谁？ 大家好，我是 猫头虎，别名猫头虎博主，擅长的技术领域包括云原生、前端、后端、运维和AI。我的博客主要分享技术教程、bug解决思路、开发工具教程、前沿科技资讯、产品评测图文、产品使用体验图文、产品优点推广文稿、产品横测对比文稿，以及线下技术沙龙活动参会体验文稿。内容涵盖云服务产品评测、AI产品横测对比、开发板性能测试和技术报告评测等。
目前，我活跃在CSDN、51CTO、腾讯云开发者社区、阿里云开发者社区、知乎、微信公众号、视频号、抖音、B站和小红书等平台，全网拥有超过30万的粉丝，统一IP名称为 猫头虎 或者 猫头虎博主。希望通过我的分享，帮助大家更好地了解和使用各类技术产品。
原创作者 ✍️ 博主：猫头虎 全网搜索关键词：猫头虎作者微信号：Libin9iOak作者公众号：猫头虎技术团队更新日期：2024年6月16日🌟 欢迎来到猫头虎的博客 — 探索技术的无限可能！ 专栏链接 🔗 精选专栏： 《面试题大全》 — 面试准备的宝典！《IDEA开发秘籍》 — 提升你的IDEA技能！《100天精通鸿蒙》 — 从Web/安卓到鸿蒙大师！《100天精通Golang（基础入门篇）》 — 踏入Go语言世界的第一步！《100天精通Go语言（精品VIP版）》 — 踏入Go语言世界的第二步！ 领域矩阵 🌐 猫头虎技术领域矩阵： 猫头虎技术矩阵新矩阵备用链接 加入猫头虎的技术圈，一起探索编程世界的无限可能！ 🚀 文章目录 ChatGPT的Mac客户端正式发布了！Mac用户有福了 🎉猫头虎是谁？原创作者 ✍️专栏链接 🔗领域矩阵 🌐加入猫头虎的技术圈，一起探索编程世界的无限可能！ 🚀ChatGPT on your desktop 📱现在可以在 macOS 上使用 🌟无缝集成，让工作更高效 🚀更快捷地访问 ChatGPT 🏃‍♂️ 截屏 📸上传文件 📂提问 ❓分享图片 🖼️搜索对话内容 🔍 用 ChatGPT 在桌面上做更多事情 💪总结 📋联系与版权声明 📩 ChatGPT on your desktop 📱 你有没有想过能在桌面上与 ChatGPT 进行无缝对话？从现在开始，这个梦想已经实现了！无论是处理邮件、截图、文件，还是屏幕上的任何内容，你都可以直接在桌面上与 ChatGPT 互动。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35b22c652e2a59ce3caa04cde6b2ad82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6af3affa7b412da8e94abeaf28c67fba/" rel="bookmark">
			1.k8s：架构，组件，基础概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、k8s了解
1.什么是k8s
2.为什么要k8s
（1）部署方式演变
（2）k8s作用
（3）Mesos，Swarm，K8S三大平台对比
二、k8s架构、组件
1.k8s架构
2.k8s基础组件
3.k8s附加组件
三、k8s基础概念
1.服务的分类
（1）无状态
（2）有状态
2.资源的分类
（1）元数据型
*1）Horizontal Pod Autoscaler（HPA）
*2）Pod Template
*3）LimitRange
（2）集群级
*1）Namespace
*2）Node
*3）ClusterRole
*4）ClusterRoleBinding
（3）命名空间级pod型资源
*1）适用于无状态服务的pod型资源
^1） 副本
^2）Replication Controller （RC）
^3）ReplicaSet（RS）
^4）Deployment controller
*2）适用于有状态服务的pod型资源（StatefulSet ）
^1） 主要特点
^2） Headless Service
^3）volumeClaimTemplate
^4）注意事项
*3）守护进程（DaemonSet）
*4）任务/定时任务
3.服务发现
（1）service
（2）Ingress
4.存储
（1）Volume
（2）CSI
5.特殊类型配置
（1）ConfigMap
（2）Secret
（3）DownwardAPI
（4）Role
（5）RoleBinding
6.规约（spec）
7.状态（Status）
四、感谢支持
前面我们有了解过一些k8s，但是那个版本比较老，因此会产生很多的bug和不兼容的问题以及依赖或者链接丢失的问题，我们用比较新的版本重头学一遍k8s。
一、k8s了解 1.什么是k8s k8s是管理容器化应用的平台，且能够管理云平台多主机，能让我们容器化部署更高效更容易。
2.为什么要k8s （1）部署方式演变 传统服务：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6af3affa7b412da8e94abeaf28c67fba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26fa01e417c4960b4630d2058a66bf89/" rel="bookmark">
			Python pyinstaller打包exe最完整教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 简介 python提供了多种方法用于将普通的*.py程序文件编译成exe文件（有时这里的“编译”也称作“打包”）。exe文件即可执行文件，打包后的*.exe应用不用依赖python环境，可以在他人的电脑上运行。
pyinstaller是一个第三方模块，专用于python程序的exe打包。此外python还有一些别的方法进行打包，但是pyinstaller打包最强大而且好用。
pyinstaller的官网是：https://pyinstaller.org/
2 安装 可以通过pip进行安装。首先启动cmd，输入以下内容后回车：
pip install pyinstaller 安装完成后，验证是否成功安装：
pyinstaller --version 如果显示找不到“pyinstaller”，请转到最后一章“常见问题”
3 原理和打包效果 3.1 原理概述 在开始打包前，读者有必要先了解pyinstaller的打包原理。
如果你只在乎打包结果而不在乎细节，你可以跳过第3章，直接进入下面的打包环节。但是，当你打包时遇到问题时，还是建议你先把打包原理看完，可能你的问题会得到解决。
pyinstaller先读取你需要打包的python文件，然后搜索其中使用的模块，然后将所需的模块以及Python解释器放到一起，并通过一些操作构建exe，最终形成你的应用程序。
3.2 搜索模块 当然，在搜索模块的时候必然会遇到一些问题。
pyinstaller只会搜索import语句，然后根据import得到的模块再进行搜索。如果编程者使用了一些特殊的导入方式，比如使用__import__()函数，使用importlib里面的导入函数，那么pyinstaller很可能找不到你所需要的模块。
这时，你可以通过参数来指定你所需要的模块，也可以使用“钩子”等等（这是后话）。
3.3 打包效果概述 pyinstaller打包后会形成一个文件夹或单个的exe（可以用参数指定）。但不论是哪一种情况，都会包含一个exe文件，用户可以双击它运行该应用程序。
假如你要打包myscript.py，那么打包完成后运行这个myscript.exe，效果就是运行myscript.py后的效果。
默认情况下，打包会形成一个黑色的控制台（cmd的样子），也可以设置隐藏这个控制台。
这个控制台用于为python提供标准输入(stdin)，标准输出(stdout)，标准错误(stderr)。也就是说，这个控制台上显示了print函数的输出，用于接收input函数的输入，还会输出python的异常。
如果你隐藏了这个控制台，程序中的print就无法显示（但是不会报错），报错信息也无法被用户直接看到（pyinstaller有一些选项来控制显示异常，后文详解）；需要注意的是，此时不能使用input，否则会报错：
RuntimeError: input(): lost sys.stdin python文件有一种后缀名*.pyw，这样的程序执行时默认会隐藏控制台。如果将文件后缀命名为pyw，那么pyinstaller也会认为它隐藏了控制台，不需要通过额外的选项来指定。
当你制作GUI程序的时候，最好选择隐藏控制台，来提升用户体验。 打包后的文件可能会被反编译（即通过exe文件得到原来的代码），可以通过一些方法进行加密（后文详解）。
3.4 打包成单个文件夹 下面介绍一下打包完成后形成的文件夹。
这个文件夹的名字是你提供的，一般是你要求打包的python文件的名称。文件夹中包含一个exe文件，以及其他一些依赖文件（比如一些dll文件，可能还有你的应用所需要的图片等素材）。你只需要将该文件夹压缩就能发给别人运行了。
当你运行里面的exe文件后，pyinstaller其实只是启动了解释器，然后通过解释器运行你的主程序。
优点 打包成单个文件夹的形式便于调试，因为你可以清楚地看到pyinstaller将哪些模块文件放到了文件夹中。
当你更改代码，需要用户更新应用时，只需要让用户对于部分内容进行修改。如果你只修改了主程序，没有使用多余的模块，那么就只需要让用户替换里面的exe文件，而不用全部替换（因为更新前后使用的模块是一致的，它们都以多文件的形式放到了文件夹中）。
单个文件夹的状态下，程序的启动速度和打包前差不多。
缺点 打包成单个的文件夹后，文件大小可能会更大一些，因为大部分依赖文件没有进行压缩。
3.5 打包成单个exe 单个exe模式下，pyinstaller只会生成一个单独的exe文件，所有的依赖文件都会被压缩到exe文件中。
和上面的文件夹模式类似，exe启动后，pyinstaller也是通过调用python解释器来运行主程序的。
优点 启动单个exe非常简单，用户只需要点击exe文件就能运行，而无需在一大堆的依赖文件中找到exe文件。并且在经过压缩后，这个exe文件的文件大小会大大减小。
缺点 单个exe的启动速度比较慢（通常会慢几秒，且只是启动时的速度，不是运行后的速度），这是因为pyinstaller会在这一段时间中将一些依赖文件写入到一个临时的文件夹（后文介绍该文件夹的调用方式）。
如果你希望添加一些附带文件（比如使用说明README），你还需要额外新建文件夹并将其放进去。
4 打包 在了解相关原理后，下面正式进入打包环节。
本章介绍通过命令行参数进行打包，这种方式比较初级，适用于一般的打包方式。
4.1 基本语法 打包需要通过cmd进行，语法和大多数工具一样。pyinstaller最简单的打包方式是：
pyinstaller myscript.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26fa01e417c4960b4630d2058a66bf89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/093acce6b426d0102ee5248ec348b5e7/" rel="bookmark">
			【从0实现React18】 (四) 如何触发更新 带你了解react触发更新的流程以及更新后如何触发render
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见的触发更新的方式 创建 React 应用的根对象 ReactDOM.creatRoot().render()；类组件 this.setState()；函数组件 useState useEffect； 我们希望实现一套统一的更新机制，他的特点是：
兼容上述触发更新的方式方便后续拓展（优先级机制） 更新机制的组成部分 代表更新的数据结构 Update消费update的数据结构——UpdateQueue 实现 Update 和 UpdateQueue 在 packages/react-reconciler/src/ 目录下新建 updateQueue.ts 文件：
// packages/react-reconciler/src/updateQueue.ts import { Action } from '@/shared/ReactTypes' import { Update } from './fiberFlags' export interface Update&lt;State&gt; { action: Action&lt;State&gt; } export interface UpdateQueue&lt;State&gt; { shared: { pending: Update&lt;State&gt; | null } } /** 创建 Update */ export const createUpdate = &lt;State&gt;(action: Action&lt;State&gt;): Update&lt;State&gt; =&gt; { return { action, } } /** 创建 UpdateQueue */ export const createUpdateQueue = &lt;Action&gt;() =&gt; { return { shared: { pending: null, }, } as UpdateQueue&lt;Action&gt; } /** updateQueue添加update */ export const enqueueUpdate = &lt;Action&gt;( updateQueue: UpdateQueue&lt;Action&gt;, update: Update&lt;Action&gt; ) =&gt; { updateQueue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/093acce6b426d0102ee5248ec348b5e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49b0596622f9e8e1f12b759d28279805/" rel="bookmark">
			[深度学习] 生成对抗网络GAN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生成对抗网络（Generative Adversarial Networks，GANs）是一种由 Ian Goodfellow 等人在2014年提出的深度学习模型Generative Adversarial Networks。GANs的基本思想是通过两个神经网络（生成器和判别器）的对抗过程，生成与真实数据分布相似的新数据。以下是对GANs的详细介绍。
1. 基本结构 GANs由两个主要组件构成：
1.1 生成器（Generator） 生成器的任务是从一个随机噪声（通常是高斯噪声）中生成逼真的数据样本。生成器是一个神经网络，它接受一个随机向量作为输入，并输出一个与真实数据分布相似的样本。目标是欺骗判别器，使其认为生成的数据是真实的。
1.2 判别器（Discriminator） 判别器是另一个神经网络，用于区分真实数据和生成器生成的假数据。它的输入是一个数据样本，输出是一个标量值，表示输入数据是真实的概率。判别器的目标是最大化区分真实数据和生成数据的准确性。
2. 工作原理 GANs通过生成器和判别器的对抗训练来实现目标。训练过程中，两者的目标是相反的：
生成器试图最大限度地欺骗判别器，使其无法区分生成数据和真实数据。判别器则尽量提高区分真实数据和生成数据的能力。 这种对抗训练可以形式化为一个极小极大（minimax）问题：
其中，D(x) 是判别器对真实数据 x 的输出， G(z) 是生成器对随机噪声 z 的输出。
3. 训练过程 初始化：随机初始化生成器和判别器的参数。训练判别器：在固定生成器的情况下，用一批真实数据和生成数据训练判别器，更新判别器的参数。训练生成器：在固定判别器的情况下，用生成器生成的假数据训练生成器，更新生成器的参数。循环：重复上述步骤，直到生成器生成的数据足够逼真。 下面是一个使用TensorFlow和Keras实现简单生成对抗网络（GAN）的示例代码。该代码使用MNIST手写数字数据集来训练生成器生成类似手写数字的图像。
import tensorflow as tf from tensorflow.keras import layers, models import numpy as np import matplotlib.pyplot as plt # 加载MNIST数据集 (train_images, _), (_, _) = tf.keras.datasets.mnist.load_data() train_images = train_images.reshape(train_images.shape[0], 28, 28, 1).astype('float32') train_images = (train_images - 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49b0596622f9e8e1f12b759d28279805/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/526bff6371cffa13156496e6e330c1e9/" rel="bookmark">
			Docker三分钟部署ElasticSearch平替MeiliSearch轻量级搜索引擎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👩🏽‍💻个人主页：阿木木AEcru (更多精彩内容可进入主页观看)
🔥 系列专栏：《Docker容器化部署系列》 《Java每日面筋》
💹每一次技术突破，都是对自我能力的挑战和超越。
目录 一、 什么是MeiliSearch？二、对比ElasticSearch有什么好处？三、使用场景有哪些？四、docker部署MeiliSearch4.1 创建数据持久化文件夹4.2 拉取镜像4.3 运行容器 五、访问测试5.1 访问5.2 下载测试文件5.3 导入测试文件 六、结尾 一、 什么是MeiliSearch？ MeiliSearch作为轻量级搜索引擎的解决方案，相比于Elasticsearch，它更适用于中小型项目，提供快速、高精度、易用且支持中文搜索的特点。MeiliSearch拥有定制化API和多语言支持，尤其适合数据量不大但对速度和易用性有要求的场景。
二、对比ElasticSearch有什么好处？ Meilisearch以其轻量级和高性能的特点，为需要快速、简单搜索解决方案的开发者和中小型项目提供了理想选择。与Elasticsearch相比，Meilisearch的资源占用更少，部署过程更为简便，无需复杂的集群配置即可快速启动服务。
Meilisearch的搜索响应时间极短，通常在50毫秒以内，为用户提供了接近即时的搜索体验。它内置了智能搜索功能，如错字容忍和同义词识别，这些功能开箱即用，无需额外配置，大大简化了开发流程。
支持多语言SDK是Meilisearch的另一大优势，无论是在Python、Java还是Go等流行编程语言中，开发者都能轻松集成Meilisearch，享受到它带来的便利。Meilisearch的API设计直观易用，即便是编程新手也能快速掌握。
Meilisearch的社区活跃，文档详尽，为用户在使用过程中遇到的问题提供了丰富的解答和指导。此外，Meilisearch对中文搜索的原生支持，为中文内容的搜索提供了极大的便利，无需额外的语言处理配置。
尽管Meilisearch在处理大规模数据集和复杂查询方面可能不如Elasticsearch强大，但其在成本效益、易用性和快速响应方面的优势，使其成为许多现代应用的理想搜索解决方案。随着技术的不断发展，Meilisearch有望在搜索引擎领域扮演更加重要的角色，为用户带来更加高效和智能的搜索体验。
三、使用场景有哪些？ 电子商务网站：通过实时搜索建议和个性化搜索结果来提升用户体验。内容管理系统：快速检索文档、博客文章、新闻等，提高内容查找效率。企业内部搜索：为员工提供快速访问公司内部数据和知识库的能力。初创公司和小型项目：由于资源和成本限制，需要一个易于部署和维护的搜索解决方案。个人开发者：为个人项目提供快速、简单的搜索功能，无需复杂的设置。管理后台搜索：在管理后台提供高效的数据检索，简化操作流程。小程序搜索：为小程序用户提供快速响应的搜索体验。网站搜索功能：为各种网站提供站内搜索能力，增强用户交互。文档搜索：在大量文档中快速定位所需信息。商品搜索：在电商平台上提供商品搜索，提升购物体验。 四、docker部署MeiliSearch 4.1 创建数据持久化文件夹 sudo mkdir -p /usr/local/meiliData 4.2 拉取镜像 docker pull getmeili/meilisearch:v1.8 这里需要注意的是，我在服务器是是拉不到的（需要魔法上网），我就在本地安装了DockerDesktop ，再使用魔法上网然后拉取下来的镜像，然后再打包成tar包上传到服务器运行。
4.3 运行容器 sudo docker run -it \ --privileged=true \ -d --restart=always \ -p 7700:7700 \ -e MEILI_MASTER_KEY='V24oN6ZyG810XEvczp' \ -v /usr/local/meiliData:/meili_data \ --name meilisearch \ getmeili/meilisearch:v1.8 1. `sudo docker run -it`：以管理员权限启动一个新的Docker容器，并与它交互。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/526bff6371cffa13156496e6e330c1e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8049d0511e14f8333edc2c1d7c0bcf21/" rel="bookmark">
			Kafka topic消息清理几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kafka清理Topic消息 参考链接：https://cloud.tencent.com/developer/article/1590094
快速配置删除法 kafka启动之前，在server.properties配置delete.topic.enable=true
执行命令bin/kafka-topics.sh --delete --topic test --zookeeper zk:2181或者使用kafka-manage集群管理工具删除。如果kafka启动之前没有配置delete.topic.enable=true，topic只会标记为marked for deletion，并且在Zookeeper中的/admin/delete_topics下创建对应的子节点,加上配置，重启kafka，之前的topic就真正删除了
优点：由Kafka来完成Topic的相关删除，只需要修改server.properties配置文件的delete.topic.enable为true就可以了
缺点：需要重启Kafka来完成配置文件的生效
# 默认是false，注意等号前后一定不能有空格，否则配置会不生效 delete.topic.enable=true # Bitnami Chart环境变量设置(涉及重启了) KAFKA_CFG_DELETE_TOPIC_ENABLE=true # 创建新的Topic logstash_test（拥有3个副本） kafka-topics.sh --create --bootstrap-server ape-kafka-0.ape-kafka-headless:9092,ape-kafka-1.ape-kafka-headless:9092,ape-kafka-2.ape-kafka-headless:9092 --topic logstash_test --partitions 1 --replication-factor 3 # 查看Topic logstash_test的状态，发现Leader是1（broker.id=0）,有三个备份分别是0，1，2 I have no name!@ape-kafka-0:/$ kafka-topics.sh --describe --bootstrap-server ape-kafka-0.ape-kafka-headless:9092,ape-kafka-1.ape-kafka-headless:9092,ape-kafka-2.ape-kafka-headless:9092 --topic logstash_test Topic: logstash_test TopicId: 1j9d-WGVTzKTpGdTtO0YFQ PartitionCount: 1 ReplicationFactor: 3 Configs: flush.ms=1000,segment.bytes=1073741824,flush.messages=10000,max.message.bytes=1000012,retention.bytes=1073741824 Topic: logstash_test Partition: 0 Leader: 0 Replicas: 0,2,1 Isr: 0,2,1 # 查看Zookeeper上的Topic $ zkCli.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8049d0511e14f8333edc2c1d7c0bcf21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/074b6ff09f533e1a028b8446907ab2c2/" rel="bookmark">
			竞赛选题 python&#43;深度学习&#43;opencv实现植物识别算法系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 前言 🔥 优质竞赛项目系列，今天要分享的是
🚩 基于深度学习的植物识别算法研究与实现
🥇学长这里给一个题目综合评分(每项满分5分)
难度系数：4分工作量：4分创新点：4分 🧿 更多资料, 项目分享：
https://gitee.com/dancheng-senior/postgraduate
2 相关技术 2.1 VGG-Net模型 Google DeepMind公司研究员与牛津大学计算机视觉组在2014年共同研发出了一种全新的卷积神经网络–VGG-
Net。在同年举办的ILSVRC比赛中，该网络结构模型在分类项目中取得了十分出色的成绩，由于其简洁性和实用性，使得其在当时迅速，飞快地成为了最受欢迎的卷积神经网络模型。VGG-
Net卷积神经网络在近年来衍生出了A-
E七种不同的层次结构，本次研究使用其中的D结构，也就是VGG-16Net结构，该结构中包含了13个卷积层，5个池化层和3个全连接层。针对所有的卷积层，使用相同的5x5大小的卷积核，针对所有的池化层，使用相同的3x3大小的池化核。VGG-
Net结构如图所示。
2.2 VGG-Net在植物识别的优势 在针对植物识别问题上，VGG-Net有着一些相较于其他神经网络的优势，主要包括以下几点：
(1) 卷积核，池化核大小固定 网络中所有的卷积核大小固定为3x3,所有的池化核大小固定为5x5。这样在进行卷积和池化操作的时候，从数据中提取到的特征更加明显，同时在层与层的连接时，信息的丢失会更少，更加方便后续对于重要特征的提取和处理。
(2) 特征提取更全面 VGG-
Net网络模型中包含了13个卷积层。卷积层数目越多，对于特征的提取更加的全面。由于需要对于植物的姿态、颜色等进行判定，植物的特征较多，需要在提取时更加的全面，细致，才有可能得到一个更加准确的判定。VGG-
Net符合条件。
(3) 网络训练误差收敛速度较快 VGG-
Net网络在训练时收敛速度相对较快，能够较快地得到预期的结果。具有这一特点的原因有两个，一个是网络中每一个卷积层和池化层中的卷积核大小与池化核大小固定，另一个就是对于各个隐藏层的参数初始化方法使用专门针对ReLU激活函数的Kaiming正态初始化方法。
3 VGG-Net的搭建 本次研究基于Pytorch深度学习框架进行网络的搭建，利用模块化的设计思想，构建一个类，来对于整个的网络进行结构上的封装。这样搭建的好处是可以隐藏实现的内部细节，提高代码的安全性，增强代码的复用效率，并且对于一些方法，通过在内部集成，可以方便之后对于其中方法的调用，提升代码的简洁性。
在网络搭建完成后，将数据集传入网络中进行训练，经过一段时间后即可得到植物识别的分类识别结果。
3.1 Tornado简介 Tornado全称Tornado Web
Server，是一个用Python语言写成的Web服务器兼Web应用框架，由FriendFeed公司在自己的网站FriendFeed中使用，被Facebook收购以后框架在2009年9月以开源软件形式开放给大众。
(1) 优势 轻量级web框架异步非阻塞IO处理方式出色的抗负载能力优异的处理性能，不依赖多进程/多线程，一定程度上解决C10K问题WSGI全栈替代产品，推荐同时使用其web框架和HTTP服务器 (2) 关键代码 ​ class MainHandler(tornado.web.RequestHandler): ​ def get(self): ​ self.render("index.html") ​ def post(self): keras.backend.clear_session() img = Image.open(BytesIO(self.request.files['image'][0]['body'])) img = img b_img = Image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/074b6ff09f533e1a028b8446907ab2c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83e86d455f3e21b7d945fc4ed986a278/" rel="bookmark">
			GPT-5对普通人有何影响
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章对ChatGPT的使用方法和提问技巧进行了讨论，重点强调了背景信息和具体提问的重要性。文章清晰地传达了如何提高ChatGPT回答的质量，以及个人在使用ChatGPT时的体会和建议。然而，文章在逻辑组织和表达方面还有一些可以改进的地方，以增强说服力和可读性。
修改建议
自从ChatGPT发布以来，它在许多方面对我们有了极大的帮助，尤其是在对话、写作和灵感方面。ChatGPT逐渐融入了我们的日常生活，进一步的应用甚至包括医疗、人工智能等复杂领域，帮助我们进行数据分析和处理。
我们要做的，就是提出问题。那么，如何让ChatGPT回答得更好呢？我曾经研究过许多向ChatGPT提问的技巧，比如让它模拟一个具有十年工作经验的工程师，或者给它制定一些规则，让它按照这些规则来回复。但我发现，它的回答有时太官方，缺乏深度。
有时，我会使用它写文章，或者让它修饰我写的文章，比如这篇文章。因此，提问的方式非常重要。我认为最好的方式是问ChatGPT如何更好地向它提问。
根据ChatGPT的回复，我们需要知道，首先，你需要提供你所处的场景和背景，这点非常重要，否则它会进行猜测，回答也会不准确。其次，你要针对性地进行提问，你问得越详细，它回复得也越详细。
我觉得这两点非常重要，其他的可以慢慢摸索。因此，在写文章时，可以整理一些类似提问的脚本，这样可以更快地获得我们需要的信息。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/225/">«</a>
	<span class="pagination__item pagination__item--current">226/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/227/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>