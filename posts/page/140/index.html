<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85010a86f66e29ed5c4c4ed0a5348e11/" rel="bookmark">
			Java 8的变革：函数式编程和Lambda表达式探索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、函数接口二、Lambda表达式简介三、Lambda表达式外部参数四、Lambda范例五、Runnable Lambda表达式 一、函数接口 函数接口是一个具有单个抽象方法的接口，接口设计主要是为了支持 Lambda 表达式和方法引用，使得 Java 能更方便地实现函数式编程风格。
特点和用途：
单一抽象方法： 函数接口只能有一个抽象方法，但可以有多个默认方法（default）或静态方法（static）。Lambda 表达式： 可以使用函数接口创建 Lambda 表达式，从而简洁地表示匿名函数，例如在集合操作、线程处理等场景中。方法引用： 可以通过函数接口的类型来引用一个已存在的方法，使代码更简洁和可读性更高。 Java 8 提供了几个标准的函数接口，接口通常位于 java.util.function 包中。
常见的函数接口：
Consumer： 接收一个输入参数并且不返回结果的操作。
Consumer&lt;String&gt; printConsumer = str -&gt; System.out.println(str); printConsumer.accept("Hello World!"); Supplier： 不接收参数但是返回结果的提供型接口。
Supplier&lt;Double&gt; randomSupplier = () -&gt; Math.random(); System.out.println(randomSupplier.get()); Function： 接收一个输入参数，并返回结果。
Function&lt;Integer, String&gt; intToString = num -&gt; String.valueOf(num); System.out.println(intToString.apply(123)); Predicate： 接收一个输入参数，并返回一个布尔值结果。
Predicate&lt;Integer&gt; isEven = num -&gt; num % 2 == 0; System.out.println(isEven.test(5)); // false UnaryOperator： 继承自 Function&lt;T, T&gt;，表示一元操作符。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85010a86f66e29ed5c4c4ed0a5348e11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3ee840096af8afa308bf94917bda2ac/" rel="bookmark">
			【Oracle】Oracle中的LISTAGG函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 解释与其他聚合函数的区别 使用场景语法分析函数用法聚合函数用法对比 示例分析函数使用案例聚合函数使用案例 优缺点LISTAGG函数的优点：LISTAGG函数的缺点： 注意事项 解释 LISTAGG函数是一种用于字符串连接的聚合函数，可以将多行的值进行字符串拼接，并以指定的分隔符分隔。它的作用是将多个值合并成一个字符串，常用于将多行数据合并成一个字符串，方便数据展示和分析。类似于 wm_concat 函数， 将数据分组后， 把指定列的数据再通过指定符号合并。LISTAGG 函数既是分析函数，也是聚合函数 与其他聚合函数的区别 LISTAGG函数与其他聚合函数的区别有以下几点：
返回值类型不同：LISTAGG函数返回一个字符串，而其他聚合函数（如SUM、COUNT、AVG等）返回一个数字或其他聚合结果。处理的数据类型不同：LISTAGG函数可以处理字符型、数字型和日期型的数据，而其他聚合函数通常用于处理数值型的数据。用途不同：LISTAGG函数主要用于将多个值合并为一个字符串，常用于数据展示和生成动态SQL语句；而其他聚合函数主要用于计算和统计数据，如求和、计数、平均值等。分组方式不同：LISTAGG函数通常结合GROUP BY子句一起使用，按照分组字段将数据进行分组和合并；而其他聚合函数通常直接对整个数据集进行聚合计算。 虽然LISTAGG函数和其他聚合函数有一些区别，但它们可以互补使用，根据实际需要来选择使用哪种函数。
使用场景 LISTAGG函数适用于以下场景：
将多个值合并为一个字符串：当需要将多个值按照一定的规则合并为一个字符串时，可以使用LISTAGG函数。例如，将某个字段的值以逗号分隔合并为一个字符串。分组字段的值合并：当需要对某个字段进行分组，并将每个分组下的值合并为一个字符串时，可以使用LISTAGG函数。例如，将某个分组下的所有员工姓名合并为一个字符串。生成逗号分隔的列表：当需要生成逗号分隔的列表时，可以使用LISTAGG函数。例如，将某个字段的值以逗号分隔合并为一个列表。生成拼接的SQL语句：当需要生成动态的SQL语句或查询条件时，可以使用LISTAGG函数。例如，将多个查询条件合并为一个完整的SQL语句。 总之，LISTAGG函数适用于需要将多个值合并为一个字符串或生成逗号分隔的列表的场景，方便进行数据展示和处理。
语法 LISTAGG函数的语法如下：
LISTAGG (expression, delimiter) WITHIN GROUP (order by clause) 其中，
expression表示要合并的列或表达式。delimiter表示合并后的值之间的分隔符。order by clause表示以哪个列来排序合并后的结果。 分析函数用法 listagg(合并字段, 连接符) within group(order by 合并的字段的排序) over(partition by 分组字段) 聚合函数用法 listagg(合并字段, 连接符) within group(order by 合并字段排序)	group by 分组字段 对比 对数据进行分组分组之后，聚合函数只会每组返回一条数据， 而分析函数会针对每条记录都返回，一部分分析函数还会对同一组中的数据进行一些处理（比如：rank() 函数对每组中的数据进行编号）；还有一部分分析函数不会对同一组中的数据进行处理（比如：sum()、listagg()），这种情况下，分析函数返回的数据会有重复的，distinct 处理之后的结果与对应的聚合函数返回的结果一致。 示例 首先，我们来创建一个表，并向表中插入一些数据：
CREATE TABLE employee ( emp_id INT, emp_name VARCHAR(50), emp_dept VARCHAR(50) ); INSERT INTO employee (emp_id, emp_name, emp_dept) VALUES (1, 'John', 'HR'); INSERT INTO employee (emp_id, emp_name, emp_dept) VALUES (2, 'Sarah', 'Finance'); INSERT INTO employee (emp_id, emp_name, emp_dept) VALUES (3, 'Mike', 'IT'); INSERT INTO employee (emp_id, emp_name, emp_dept) VALUES (4, 'Linda', 'Finance'); INSERT INTO employee (emp_id, emp_name, emp_dept) VALUES (5, 'Tom', 'IT'); -- 继续插入更多数据.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3ee840096af8afa308bf94917bda2ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d65e67e5736de692271d83d49a5cc9c/" rel="bookmark">
			【初阶数据结构】掌握二叉树遍历技巧与信息求解：深入解析四种遍历方法及树的结构与统计分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初阶数据结构相关知识点可以通过点击以下链接进行学习一起加油！时间与空间复杂度的深度剖析深入解析顺序表:探索底层逻辑深入解析单链表:探索底层逻辑深入解析带头双向循环链表:探索底层逻辑深入解析栈:探索底层逻辑深入解析队列:探索底层逻辑深入解析循环队列:探索底层逻辑树与二叉树：从零开始的奇幻之旅理解堆的特性与应用：深入探索完全二叉树的独特魅力 本篇将介绍掌握二叉树的遍历和信息获取方法，有助于我们更好地理解树的结构与统计分析，为接下来学习AVL树与红黑树等高阶数据结构打下基础。对于最后面关于二叉树的特性，需要理解掌握在遇到相关题目可以直接套用。
🌈个人主页：是店小二呀
🌈C语言笔记专栏：C语言笔记
🌈C++笔记专栏： C++笔记
🌈初阶数据结构笔记专栏： 初阶数据结构笔记
🌈喜欢的诗句:无人扶我青云志 我自踏雪至山巅
文章目录 一、快速搭建二叉树二、二叉树组成结构三、二叉树的遍历3.1 三种常见遍历（前序/中序/后序遍历）3.2 层序遍历 四、求二叉树相关信息4.1 二叉树节点个数4.2 二叉树叶子节点个数4.3 求这个棵树的高度4.4 二叉树第k层节点个数 4.5 二叉树查找值为x的节点4.5 单值二叉树4.6 相同的树4.7 树的销毁(后序) 五、二叉树的性质 一、快速搭建二叉树 为了方便我们更快地学习二叉的基本操作，这里直接手动搭建一颗二叉树。不仅如此，在做二叉树相关题目时，由于部分原因做题平台不支持普通用户使用调试功能，可以快速搭建二叉树在本地编译器上进行调试相关操作
typedef int BTDataType; typedef struct BinaryTreeNode { BTDataType _data; struct BinaryTreeNode* _left; struct BinaryTreeNode* _right; }BTNode; BTNode* BuyNode(BTDataType x) { BTNode* tmp = (BTNode*)malloc(sizeof(BTNode)); if (tmp == NULL) { // 处理内存分配失败的情况 // 可以选择报错、退出程序或者其他适当的处理方式 exit(EXIT_FAILURE) }; // 举例：退出程序 tmp-&gt;_data = x; tmp-&gt;_left = NULL; tmp-&gt;_right = NULL; return tmp; } BTNode* CreatBinaryTree() { BTNode* node1 = BuyNode(1); BTNode* node2 = BuyNode(2); BTNode* node3 = BuyNode(3); BTNode* node4 = BuyNode(4); BTNode* node5 = BuyNode(5); BTNode* node6 = BuyNode(6); node1-&gt;_left = node2; node1-&gt;_right = node4; node2-&gt;_left = node3; node4-&gt;_left = node5; node4-&gt;_right = node6; return node1; } 二、二叉树组成结构 二叉树大致分为两种
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d65e67e5736de692271d83d49a5cc9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee1ebeebdfe5ce50f9c5a7088332e6d8/" rel="bookmark">
			SpringCloud教程 | 第九篇: 使用API Gateway
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、参考资料
SpringCloud基础篇-10-服务网关-Gateway_springcloud gateway-CSDN博客
2、先学习路由，参考了5.1
2.1、建了一个cloudGatewayDemo，这是用来配置网关的工程，配置如下：
http://localhost:18080/aaa/name
该接口代码如下：
2.2、另外建了一个服务providerDemo，用来被路由过来的。
要验证的接口内容如下：
2.3、启动了这2个服务，然后访问http://localhost:18080/aaa/name
发现只在cloudGatewayDemo的控制台打印了日志，并未在另外一个服务providerDemo中有日志打印。
这就说明路由没生效。怎么解决这个问题呢？使路由生效，访问http://localhost:18080/aaa/name
然后路由到http://localhost:18082/aaa/name
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ea61db3ab4545c8c0f586a386cb4d52/" rel="bookmark">
			RabbitMQ-最常用的消息队列MQ安装详解！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RabbitMQ-最常用的消息队列MQ安装详解！！ RabbitMQ-简介
RabbitMQ 是采用 Erlang 语言实现的高级消息队列协议（AMQP）的消息中间件。它最初起源于金融系统，用于在分布式系统中存储和转发消息。
在 RabbitMQ 中，消息传递的过程可以想象成厨师做好饭菜放到服务台，服务台会暂存并最终将饭菜通过服务员送到客人的餐桌。RabbitMQ 就好比由服务台和服务员组成的一个系统。
文档内安装包下载不到或找不到者可找Me拿！！！！！ RabbitMQ-最常用的消息队列MQ安装详解！！一、使用RabbitMQ消息队列的优点二、使用RabbitMQ消息队列的缺点三、Linux操作系统环境规划四、安装 erlang五、安装 RabbitMQ详解5.1 安装socat5.2 RabbitMQ 安装5.3 启动 RabbitMQ5.4 启动完成后检查5.5 常用命令 六、图形化管理界面及授权操作6.1 安装图形化管理界面6.2 访问地址（ip+端口15672）6.3 创建授权账户密码6.4 登录界面访问 七、RabbitMQ 界面简介7.1 Overview7.2 Connections7.3 Channels7.4 Exchanges7.5 Queues and Streams7.5 Admin 一、使用RabbitMQ消息队列的优点 异步：提升系统的响应速度，吞吐量。解耦：服务之间进行解耦，才可以减少服务之间的影响，提高系统整体的稳定性以及可扩展性。另外解耦后可以实现数据分发。生产者发送一个消息后，可以由一个或者多个消费者进行消费，并且消费者的增加或者减少对生产者没有影响。削峰：以稳定的系统资源应对突发的流量冲击。 二、使用RabbitMQ消息队列的缺点 系统可用性降低：系统引入的外部依赖增多，稳定性就会变差。一旦MQ宕机，就会对业务产生影响。（可考虑通过高可用模式解决）系统的复杂度提高：引入MQ后系统的复杂度会大大提高。以前服务之间可以进行同步的服务调用，引入MQ后，会变成异步调用，数据链路会变得更复杂。并且还会带来一系列的问题。（如何保证消息不会丢失？不会被重复调用？怎么保证消息的顺序性？）消息一致性问题：A系统处理完业务，通过MQ发送消息给B、C系统进行后续的业务处理。如果B系统成功，C系统失败，这就需要考虑消息的一致性。 三、Linux操作系统环境规划 ip地址hostname操作系统版本服务器类别10.0.0.*appcentos 7(或者麒麟V10)虚拟机VMware 四、安装 erlang RabbitMQ是用Erlang语言编写的，所以在安装RabbitMQ之前需要安装Erlang。在构建RabbitMQ环境的过程中，RabbitMQ和Erlang的版本要对应关系，官网上可以查看RabbitMQ和Erlang的版本问题：Erlang Version Requirements！可点击跳转！Erlang官网地址：Erlang official website！可点击跳转！ 下载安装包。 [root@app RabbitMQ]# ll 总用量 39584 -rw-r--r-- 1 root root 21846184 7月 18 10:50 erlang-26.2.5.2-1.el8.x86_64.rpm 执行rpm命令安装 Erlang [root@app RabbitMQ]# rpm -Uvh erlang-26.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ea61db3ab4545c8c0f586a386cb4d52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98785b0608820b79499b3edbc4ef1325/" rel="bookmark">
			同时安装多个nodejs版本可切换使用，或者用nvm管理、切换nodejs版本（两个详细方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.使用nvm的方法：
1.卸载nodejs
2.前往官网下载nvm
3.安装nvm
4.查看安装是否完成
5.配置路径和淘宝镜像
6.查看和安装各个版本的nodejs
7.nvm的常用命令
二.不使用nvm，安装多个版本：
1.安装不同版本的nodejs
2.解压到你想放到的路径，可以不放在C盘
3.在存放nodejs的文件夹里，复制一下路径，准备配置环境变量
4.配置环境变量，每个版本都单独配置
5.切换nodejs版本
前言：我们在工作和学习中，常常会接触不同的项目，而有些项目因为使用nodejs版本不同，在开发人员使用了不合适的nodejs版本时会出现各种报错或警告，甚至连项目都无法正常跑起来。下面本人介绍两个自己也在用的方法，希望能解决你的问题。
一.使用nvm的方法： 1.卸载nodejs 如果你的电脑有安装nodejs，需要先卸载掉；若没有请直接下一步。
2.前往官网下载nvm nvm文档手册 - nvm是一个nodejs版本管理工具 - nvm中文网 (uihtm.com)
点击下载后，会看到有不同版本的网盘地址，选择一个下载即可
也可以在git里下载：项目首页 - nvm-windows - GitCode
3.安装nvm 下载解压后，得到一个 .exe 文件，双击运行安装。
同意协议
选择安装路径，可以不装在C盘
点击 Install 安装，等待进度条跑完
4.查看安装是否完成 任意位置打开 cmd ，输入命令：nvm version，显示nvm的版本号即表示安装成功
5.配置路径和淘宝镜像 打开安装目录，找到settings.txt文件，双击打开它
原始文件：
增加以下配置后保存：
node_mirror:https://npmmirror.com/mirrors/node/ npm_mirror:https://npmmirror.com/mirrors/npm/ 6.查看和安装各个版本的nodejs 1.重新打开cmd
2.查看可安装版本，输入命令：nvm list available
3.安装想要的版本，命令：nvm install + 版本号，例如：nvm install 14.14.0
4.使用要用的nodejs版本，命令：nvm use + 版本号，例如：nvm use 14.14.0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98785b0608820b79499b3edbc4ef1325/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdb4a6ad3f98e20703abf0886f3f2efd/" rel="bookmark">
			HBase数据访问的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Python访问HBase RestServer HBase RestServer HBase RESTServer是Apache HBase提供的一个RESTful接口，用于通过HTTP协议与HBase进行交互。通过RESTServer，用户可以方便地通过发送HTTP请求来进行数据的读取、写入和查询操作，无需直接使用HBase的Java API。
首先，我们需要启动HBase RESTServer。在HBase的安装目录下，执行以下命令来启动RESTServer：
./bin/hbase-daemon.sh start rest HBase RestServer的示例 启动后，我们可以通过访问http://localhost:8080来访问RESTServer的Web UI，查看API文档和进行交互。
下面是一个简单的Python代码示例，演示如何通过HBase RESTServer来读取HBase中的数据：
http://localhost:8080/table_name/row_key [GET]
import requests url = "http://localhost:8080/example/table_name/row_key" response = requests.get(url) if response.status_code == 200: data = response.json() print(data) else: print("Failed to retrieve data") 或者安装Python三方包: hbase-rest-py
pip install hbase-rest-py from hbase.rest_client import HBaseRESTClient from hbase.scan import Scan from hbase.scan_filter_helper import ( build_base_scanner, build_prefix_filter, build_row_filter, build_value_filter, build_single_column_value_filter ) client = HBaseRESTClient(['http://localhost:8080']) scanner_def = build_base_scanner(startRow="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdb4a6ad3f98e20703abf0886f3f2efd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10b7c90dedf59301fc73e570325a729b/" rel="bookmark">
			XLua原理（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中活动都是用xlua开发的，项目周更热修也是用xlua的hotfix特性来做的。现研究底层原理，对于项目性能有个更好的把控。
本文认为看到该文章的人已具备使用xlua开发的能力，只研究介绍下xlua的底层实现原理。
一.lua和c#交互原理 概括： 通过栈来实现。lua调用c#就是将lua层的参数和c#导出函数入栈，然后执行函数。c#调用lua就是将c#层的参数和lua函数入栈，然后执行函数
1.1 C#访问lua 直接上代码：
private void Demo1() { IntPtr L = LuaAPI.luaL_newstate(); if (LuaAPI.luaL_loadbuffer(L, @"function addandsub(x,y) return x+y , x-y end", "selfTagChunk") != 0) { Debug.LogError(LuaAPI.lua_tostring(L,-1)); } //LuaAPI.lua_pushnumber(L,20); //LuaAPI.lua_pushnumber(L,21); LuaAPI.lua_pcall(L, 0, 0, 0); LuaAPI.xlua_getglobal(L, "addandsub"); LuaAPI.lua_pushnumber(L,10); LuaAPI.lua_pushnumber(L,7); int valueB = LuaAPI.xlua_tointeger(L, -1);//7 int valueB2 = LuaAPI.xlua_tointeger(L, -2);//10 LuaTypes luaTypeB3 = LuaAPI.lua_type(L, -3);//function int valueC4 = LuaAPI.xlua_tointeger(L, 3);//7 int valueC3 = LuaAPI.xlua_tointeger(L, 2);//10 LuaTypes luaTypeC2 = LuaAPI.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10b7c90dedf59301fc73e570325a729b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a6a94119369a792334da6464ef9519f/" rel="bookmark">
			html2canvas &#43; jspdf 纯前端HTML导出PDF的实现与问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 这几天接到一个需求，富文本编辑器的内容不仅要展示出来，还要实现展示的内容导出pdf文件。一开始导出pdf的功能是由后端来做的，然后发现对于宽度太大的图片，导出的pdf文件里部分图片内容被遮盖了，但在前端是正常显示的，只因为class样式后端无法解析。然后，后端开发人员就嫌麻烦，让前端来实现导出pdf的功能。。。
html2canvas（V1.4.1） html2canvas 用于将 html 元素渲染成图像，可以将整个页面或特定区域以图像形式进行捕获。这对于将复杂的 html 结构转换为 PDF 格式非常有用，因为它可以捕获 html 中的样式、布局和图像等细节。
官网：https://html2canvas.hertzen.com/
引用 npm install html2canvas@1.4.1 --save 或 yarn add html2canvas@1.4.1 或 &lt;script src="https://html2canvas.hertzen.com/dist/html2canvas.js"&gt;&lt;/script&gt; 示例 &lt;template&gt; &lt;div id="pdfBody" style="margin: 30px;"&gt; &lt;input class="test_input" type="text" autocomplete="off" placeholder="输入框111"/&gt; &lt;input class="test_btn" id="testBtn" type="button" value="按钮"/&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import html2canvas from "@/utils/htmlToPdf/html2canvas.min"; export default { name: "Test", mounted() { document.getElementById('testBtn').addEventListener('click', () =&gt; { this.canvasTest(); }); }, methods: { createCanvas(dom) { html2canvas(dom, { useCORS: true, //允许跨域 scale: 2, //按比例增加分辨率 dpi: 200, //将分辨率提高到特定的DPI（每英寸点数） ignoreElements: (e) =&gt; { //过滤head、body等无用的标签元素 return !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a6a94119369a792334da6464ef9519f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af51d9c3717527615c7acc019c2b4ed2/" rel="bookmark">
			Java中的XML生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生成高效XML：Java开发者必须掌握的技能！ 大家好，我是城南。在这个信息化飞速发展的时代，XML作为一种常见的数据交换格式，已经深入到我们的开发工作中。今天，我们来聊聊如何在Java中生成XML，深度探讨这个话题的技术细节和实现方法。准备好你的脑细胞，我们要开始了！
XML与Java：一场技术的邂逅 在Java中生成XML，可以通过多种方式实现。其中，常用的方法包括DOM（Document Object Model）、SAX（Simple API for XML）、StAX（Streaming API for XML）以及JAXB（Java Architecture for XML Binding）。每种方法各有优缺点，我们将一一介绍，并且结合实例，带你深入理解每种方法的具体应用场景。
DOM解析器：全面掌控XML结构 DOM解析器是一种将XML文档加载到内存中，并将其作为一个树结构进行操作的方法。这种方法非常适合需要频繁读取和修改XML内容的场景。下面，我们来看一个简单的例子，演示如何使用DOM解析器生成一个XML文档。
import org.w3c.dom.Document; import org.w3c.dom.Element; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerException; import javax.xml.transform.TransformerFactory; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult; import java.io.StringWriter; public class DomExample { public static void main(String[] args) { try { // 创建DocumentBuilderFactory对象 DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); // 创建DocumentBuilder对象 DocumentBuilder builder = factory.newDocumentBuilder(); // 创建Document对象 Document doc = builder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af51d9c3717527615c7acc019c2b4ed2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88e4017577da29c95be884b662ceab1b/" rel="bookmark">
			[arxiv论文解读]LlamaFactory：100&#43;语言模型统一高效微调
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该文档是一篇关于LLAMAFACTORY的学术论文，这是一个用于高效微调大型语言模型（LLMs）的统一框架。这篇论文详细介绍了LLAMAFACTORY的设计、实现和评估，以及它在语言建模和文本生成任务中的应用。下面是对文档内容的详细解释：
摘要（Abstract） 背景：大型语言模型（LLMs）在多种应用中展现了卓越的推理能力，但需要有效的微调方法来适应下游任务。问题：现有的高效微调方法缺乏一个系统化的框架，无法统一适应不同的LLMs，并提供友好的用户定制界面。解决方案：LLAMAFACTORY提供了一个统一的框架，通过可扩展的模块整合了多种高效的微调方法，允许用户通过内置的Web UI（LLAMABOARD）灵活定制100多个LLMs的微调，无需编码。验证：通过实验验证了框架在语言建模和文本生成任务中的效率和有效性。开源：LLAMAFACTORY在GitHub上开源，并已获得超过13,000个星标和1,600个分支。 引言（Introduction） LLMs的重要性：介绍了LLMs在问答、机器翻译和信息提取等应用中的作用。微调挑战：指出了在有限资源下对大量参数进行微调的主要挑战。现有方法的局限性：社区贡献了多种高效微调方法，但缺乏一个统一的框架。 LLAMAFACTORY框架（LLAMAFACTORY Framework） 模块组成：由Model Loader、Data Worker和Trainer三个主要模块组成。功能：支持100多个预训练模型和50多个NLP数据集，提供了命令行和Web界面，用户可以轻松定制和微调LLMs。 高效微调技术（Efficient Fine-Tuning Techniques） 优化技术：包括冻结部分参数的freeze-tuning方法，梯度低秩投影（GaLore），低秩适应（LoRA）等。计算技术：包括混合精度训练、激活检查点、Flash Attention等。 LLAMAFACTORY架构（LLAMAFACTORY Architecture） Model Loader：准备各种架构进行微调，支持超过100个LLMs。Data Worker：通过设计良好的管道处理不同任务的数据，支持50多个数据集。Trainer：统一高效的微调方法，适应不同任务和数据集的模型。 实验研究（Empirical Study） 训练效率：使用PubMed数据集，比较了不同微调方法在内存使用、吞吐量和困惑度方面的效率。下游任务微调：在CNN/DM、XSum和AdGen等文本生成任务上评估了不同模型的性能。 结论和未来工作（Conclusion and Future Work） 贡献：LLAMAFACTORY作为一个统一框架，通过模块化设计，最小化了模型、数据集和训练方法之间的依赖，提供了超过100个LLMs的多样化高效微调技术。未来方向：将持续更新LLAMAFACTORY以保持与最先进的模型和微调技术的同步，并探索更先进的并行训练策略和多模态高效微调。 更广泛的影响和负责任的使用（Broader Impact and Responsible Use） 社区贡献：LLAMAFACTORY吸引了许多对LLMs感兴趣的个人，促进了开源社区的成长。许可证遵守：使用LLAMAFACTORY进行微调时，必须遵守模型许可证，以防止潜在的滥用。 附录和表格 表格1：LLAMAFACTORY中支持的高效微调技术及其兼容性。表格2：LLAMAFACTORY中的数据集结构。表格3：使用LLAMAFACTORY不同微调方法的训练效率比较。表格4：在特定任务上使用不同微调方法的性能比较。表格5：LLAMAFACTORY与现有LLM微调框架的比较。表格6：LLAMAFACTORY支持的模型列表。表格7：LLAMAFACTORY中函数调用的提示示例。 实验细节（Experiment Details） 训练效率实验：描述了实验设置，包括学习率、批次大小、优化器和硬件配置。下游任务微调实验：简要描述了用于评估不同微调方法有效性的CNN/DM、XSum和AdGen数据集。 这篇论文提供了LLAMAFACTORY框架的全面介绍，包括其设计理念、实现细节、实验验证以及与现有技术的比较。此外，它还讨论了框架的社会影响和负责任使用的重要性。
LlamaFactory：100+语言模型统一高效微调 Yaowei Zheng1, Richong Zhang1, Junhao Zhang1, Yanhan Ye1, Zheyan Luo1, Yongqiang Ma2
1School of Computer Science and Engineering, Beihang University, China
2School of Software and Microelectronics, Peking University, China
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88e4017577da29c95be884b662ceab1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02ddca8b374c7079ee5a018ae257eae0/" rel="bookmark">
			若依（ruoyi）分离版 纯前端教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在此之前已经使用若依分离版vue2、vue3开发过两次大型项目，也使用过若依的移动版。相对来说这种开箱即用的框架我们只需稍微修改下就可以运用到我们的项目里面，那就以我的经验给大家分享下、有描述不足的，欢迎大家多多指导！废话不多说~
1.若依简介 若依官网地址：点击跳转 演示地址：点击跳转
代码下载：点击跳转
包含六大点：
前后端分离：提供前后端分离的版本：使用的前端技术Vue、Element后端SpringBoot &amp; Security完全分离的权限管理系统。
微服务版本：提供微服务架构的版本：使用的前端技术Vue、Element、后端Spring Cloud &amp; Alibaba微服务的权限管理系统。
移动端版本：提供移动端架构的版本，支持H5、APP、微信小程序、支付宝小程序等，实现了与RuoYi-Vue后台完美对接。
代码生成器：在线配置表信息生成对应的代码，一键生成模块，包含增删改查/排序/导出/权限控制等操作，编译即可使用。
功能完善：内置完整的权限架构，包括：菜单、角色、用户、字典、参数、监控、代码生成等一系列系统常规模块。
完全响应式布局：提供多终端适配：电脑、平板、手机等所有主流设备，提供多种不同风格的皮肤。页面美观，高端大气上档次。
项目简介 RuoYi 是一个 Java EE 企业级快速开发平台，基于经典技术组合（Spring Boot、Apache Shiro、MyBatis、Thymeleaf、Bootstrap），内置模块如：部门管理、角色用户、菜单及按钮授权、数据权限、系统参数、日志管理、通知公告等。在线定时任务配置；支持集群，支持多数据源，支持分布式事务。
主要特性 完全响应式布局（支持电脑、平板、手机等所有主流设备）强大的一键生成功能（包括控制器、模型、视图、菜单等）支持多数据源，简单配置即可实现切换。支持按钮及数据权限，可自定义部门数据权限。对常用js插件进行二次封装，使js代码变得简洁，更加易维护完善的XSS防范及脚本过滤，彻底杜绝XSS攻击Maven多项目依赖，模块及插件分项目，尽量松耦合，方便模块升级、增减模块。国际化支持，服务端及客户端支持完善的日志记录体系简单注解即可实现支持服务监控，数据监控，缓存监控功能。 内置功能 用户管理：用户是系统操作者，该功能主要完成系统用户配置。部门管理：配置系统组织机构（公司、部门、小组），树结构展现支持数据权限。岗位管理：配置系统用户所属担任职务。菜单管理：配置系统菜单，操作权限，按钮权限标识等。角色管理：角色菜单权限分配、设置角色按机构进行数据范围权限划分。字典管理：对系统中经常使用的一些较为固定的数据进行维护。参数管理：对系统动态配置常用参数。通知公告：系统通知公告信息发布维护。操作日志：系统正常操作日志记录和查询；系统异常信息日志记录和查询。登录日志：系统登录日志记录查询包含登录异常。在线用户：当前系统中活跃用户状态监控。定时任务：在线（添加、修改、删除)任务调度包含执行结果日志。代码生成：前后端代码的生成（java、html、xml、sql)支持CRUD下载 。系统接口：根据业务代码自动生成相关的api接口文档。服务监控：监视当前系统CPU、内存、磁盘、堆栈等相关信息。缓存监控：对系统的缓存查询，查看、清理等操作。在线构建器：拖动表单元素生成相应的HTML代码。连接池监视：监视当期系统数据库连接池状态，可进行分析SQL找出系统性能瓶颈。 环境部署 1、前往Gitee下载页面(https://gitee.com/y_project/RuoYi (opens new window))下载解压到工作目录
2.打开项目运行npm install 或 npm i安装node_modules，运行npm install dev 出现如下图表示启动成功。
左边导航栏在菜单管理去配置，导航栏下的二级页面是在项目router下index.js进行修改
配置好相关的数据字典信息即可正常使用
代码生成
文件结构 ├── build // 构建相关 ├── bin // 执行脚本 ├── public // 公共文件 │ ├── favicon.ico // favicon图标 │ └── index.html // html模板 ├── src // 源代码 │ ├── api // 所有请求 │ ├── assets // 主题 字体等静态资源 │ ├── components // 全局公用组件 │ ├── directive // 全局指令 │ ├── layout // 布局 │ ├── router // 路由 │ ├── store // 全局 store管理 │ ├── utils // 全局公用方法 │ ├── views // view │ ├── App.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02ddca8b374c7079ee5a018ae257eae0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88c4bc2aed6feb0fa4802cda80c96e94/" rel="bookmark">
			C# 关于 PaddleOCRSharp OCR识别的疲劳测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
关于 PaddleOCRSharp
应用范例演示
​范例运行环境
疲劳测试
添加组件库
方法设计 调用示例 小结
关于 PaddleOCRSharp PaddleOCRSharp 是百度飞桨封装的.NET版本 OCR dll 类库，OCR（Optical Character Recognition）工具可以将图像文件中的文本内容进行识别，转换成可编辑的文本格式。从而进一步进行编辑、存储和分析。
在实际的使用中，这款工具类库的确很优秀，无论从识别时间还是识别率来说，比较平衡比较令人满意。
应用范例演示 这是我们在实际应用中开发的一款工具，基于 Windows WinForm 模式，用于识别客户提供的电子档案中的文字，并进行文字识别存储及后续的管理。其主界面运行如下：
如图，工具程序在导入前提供了一些选项，包括：
（1）导入类型为图片数据和个人信息（这包括了导入文本到数据库的选项）
（2）跳过OCR识别功能，是为了直接导入图片到数据库，这里我们需要勾选掉以进行测试
（3）对已导入数据执行更新操作，这个选项是纯数据库更新操作
（4）不输出导出报告，是为了减少内存占用量，提升性能
快捷设置可以提供自动设置4个选项的目的。
工具程序提供了全目录全文件分析和单目录分析，全目录会遍历该目录下所有的电子图片进行识别操作，这里我们选择的是单目录文件分析（即选择一个目录，只查找该目录下所有的图片文件），并将最终的分析结果显示在报告框中。
在实际的运行应用中，我们的档案有共计几千万份图片，由于环境及硬件要求，仅提供了三台配置雷人的台式机，发现运行几小时后，PaddleOCRSharp.dll 运行崩溃报错，如下图：
因此需要对程序进行一些改进。
​范例运行环境 操作系统： Windows Server 2019 DataCenter
PaddleOCRSharp版本：2.2.0.0
数据库：Microsoft SQL Server 2016
.net版本： .netFramework4.0 或以上
开发工具：VS2019 C#
疲劳测试 添加组件库 打 VS2019 创建 WinForm 应用，在解决方案资源管理器中添加引用，成功后如下图：
添加 using PaddleOCRSharp; 引用，示例如下：
using System; using System.Collections.Generic; using System.ComponentModel; using System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88c4bc2aed6feb0fa4802cda80c96e94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5b0729018ccc8f0d900ac56f18c8117/" rel="bookmark">
			【C&#43;&#43;深度探索】二叉搜索树的全面解析与高效实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥 个人主页：大耳朵土土垚 🔥 所属专栏：C++从入门至进阶 这里将会不定期更新有关C/C++的内容，欢迎大家点赞，收藏，评论🥳🥳🎉🎉🎉 文章目录 1.二叉搜索树2.二叉搜索树的功能3.二叉搜索树的实现✨二叉搜索树的结构✨插入函数Insert()✨查找函数Find()✨删除函数Erase()✨中序遍历InOrder()✨析构函数 4.二叉搜索树的应用5.二叉搜索树的性能分析6.结语 1.二叉搜索树 二叉搜索树(BST,Binary Search Tree)又称二叉排序树，是一种特殊的二叉树，它或者是一棵空树，或者是具有以下性质的二叉树:
若它的左子树不为空，则左子树上所有节点的值都小于根节点的值若它的右子树不为空，则右子树上所有节点的值都大于根节点的值它的左右子树也分别为二叉搜索树
二叉搜索树（Binary Search Tree）的每个节点的左子树中的所有节点都比该节点小，右子树中的所有节点都比该节点大。这个特性使得二叉搜索树可以用来实现非常高效的查找、插入和删除操作。
2.二叉搜索树的功能 二叉搜索树是一种特殊的二叉树，它具有以下功能：
插入节点：可以将一个新节点插入到二叉搜索树中。 void TestBSTree() { //插入节点 BSTree&lt;string, string&gt; dict; dict.Insert("insert", "插入"); dict.Insert("erase", "删除"); dict.Insert("select", "查找"); dict.Insert("sort", "排序"); } 这里实现的二叉搜索树每次插入的是两个值，模拟键值对，二叉搜索树的节点除了左右子节点指针也不再只存储一个值，而是两个。也就是说当我们知道一个值时，就可以利用它来查找另外一个值。
键值对（key-value pair）是指在计算机科学中用来存储和表示数据的一种结构。它由两部分组成：键（key）和值（value）。键是一个唯一的标识符，用来定位和访问值；值是与键相关联的数据。例如，一个简单的键值对可以表示一个人的姓名和年龄：键是“姓名”，值是“张三”；键是“年龄”，值是“25”。
删除节点：可以删除二叉搜索树中的一个节点。 void TestBSTree() { BSTree&lt;string, string&gt; dict; dict.Insert("insert", "插入"); dict.Insert("erase", "删除"); dict.Insert("select", "查找"); dict.Insert("sort", "排序"); //删除节点 dict.Erase("insert"); } 查找节点：可以根据给定的值，在二叉搜索树中查找对应的节点。 void TestBSTree() { BSTree&lt;string, string&gt; dict; dict.Insert("insert", "插入"); dict.Insert("erase", "删除"); dict.Insert("select", "查找"); dict.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5b0729018ccc8f0d900ac56f18c8117/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e24b63f599d7bd264a8a7e2a60d73068/" rel="bookmark">
			安装anaconda后jupyter notebook打不开 闪退
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，通过清华源安装了最新的anaconda（安装在了D盘）
尝试打开jupyter，发现小黑框1s后自己关了，根本不打开浏览器
之后尝试按照这个做了一遍https://blog.csdn.net/gary101818/article/details/123560304还是不行。。。
之后通过在anaconda powershell prompt里输入jupyter notebook尝试再次打开，发现报错：
ermissionError: [Errno 13] Permission denied:
‘C:\Users\DELL\AppData\Roaming\jupyter\runtime\jpserver-3416-open.html’
通过搜索得知：
没有找到appdata，于是：
之后找到了appdata里面的runtime文件，删掉，重新打开jupyter noptebook，发现可以了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d1dd2e445a9bb1ca48a60e3e79413f9/" rel="bookmark">
			PYQT按键长按机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 长按按键不松开也会触发 keyReleaseEvent 事件，是由于操作系统的键盘事件处理机制。大多数操作系统在检测到键盘按键被长按时，会重复生成按键按下 (keyPressEvent) 和按键释放 (keyReleaseEvent) 事件。这种行为通常被称为“键盘自动重复”。
通过检测 event.isAutoRepeat()，判断按键是否长按未松开
def keyPressEvent(self, event): if event.key() == Qt.Key_Up: self.variable += 0.1 def keyReleaseEvent(self, event): if not event.isAutoRepeat(): if event.key() == Qt.Key_Up: self.variable = 0.0 # 松开键后变量归零 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10942756f7e897aae3c2d4d3b1ec615f/" rel="bookmark">
			AI写作工具怎样让文案创作更顺畅？它们是你的得力助手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AIGC，即人工智能生成内容，是一种新兴的内容生产方式，它利用人工智能技术来自动生成文本、图像、音频、视频等多种形式的内容即进入实际应用层面。
所以AI不再是高深的、让人望尘莫及的算力算法，而是真实地贴近了我们的生活，人人都能使用AI。以前的UGC（人工生成内容）费力费时、质量低下，现在有了AIGC，谁都能用上AI帮助自己提升内容生产。未来，我们可以预见AIGC将在内容创作中扮演越来越重要的角色，甚至可能成为主流的内容生产形态。
别把AI看做洪水猛兽，应该利用好它，那么它就能为你的工作学习锦上添花。普通人想成为「AIGC入局者」，那么我建议你立马迅速体验一下AI工具并真实应用它们。你想想你要产出一份工作总结，AI 30s写好了，你不就比别人领先了一大截？下面给大家分享几个我实践下来觉得好用的ai工具（国产的，AI早就不局限于gpt4.0咯）
一、笔灵AI写作
官网链接：https://ibiling.cn/?from=csdn18
话说UGC最常见的形式就是写文案了，那么AI生成文案可是AI最底层的能力呀！
笔灵AI写作就是一款功能强大的AI写作工具，用了它，就不用自己费时费力写文了，它能输出任何文章，简直是打工人摸鱼福星。它基于国内最新的人工智能技术，能够AI一键生成高质量的写作内容，也能AI一键润色美化文章。
产品特色：
极速出稿，质量上乘：它能在短短半分钟孕育出整篇文章，大大提高写作效率。其提供的写作内容，也读来流畅，符合各种写作的风格特色。
多样化模版：笔灵精心打造200余款创作模版，适合人人挑选。无论写作风格如何，在这里面都能找到想要的模板。工作总结、心得体会、公文写作、论文这些模版都特别热门。
操作简便，轻松上手：操作界面简洁明了，无需专业技能，我相信你会识个字都能轻松驾驭了。选择心仪的模版，填入所需信息，一键生成，静待佳作诞生，让写作变得如此简单。
二、文心一言
百度倾心打造的文心一言，是一款前沿的AI聊天机器人，致力于为用户带来轻松愉快的互动体验。无论是解答疑惑还是携手创作，它都能迅速响应，是得力的助手。
里面还集成了众多实用插件，如内容创作的得力助手“笔灵”，能够精准捕捉您的创作灵感；还有“树图”与“知犀”两大内容总结神器，轻松提炼信息精华；更有“aippt”为PPT编辑工作注入智能动力。依托强大的大模型技术，文心一言为您提供更智能、更个性化的文档服务，让办公与学习变得更加高效便捷。
产品特色：
它基于百度的ERNIE大模型，具备强大的理解和生成能力，能够提供精准的文本生成和问答服务（国内gpt平替了属于是）
文心一言能够进行跨模态理解和生成，不仅能处理文本，还能根据文本生成图片，拓宽了AI在创作领域的应用
三、TreeMind树图
官网链接：https://shutu.cn/?from=csdn03
面对脑海中纷繁复杂的想法，总是梳理不来，尤其对于p人难如登天...在这个关键时刻，若有一款神器能够助你轻松将这一切梳理得有条不紊，岂不是美事一桩？
TreeMind树图就是一款专业的AI思维导图神器，能把各种想法梳理的井井有条。而且根本不需要你手动添加思维导图的节点，AI一键生成了。
比如，你渴望拥有一张清晰展示中国历史朝代的思维导图，直接输入你的需求，它便会迅速为你绘制出一幅既详尽又美观的导图。
产品特色：
支持所有导图类型：包括逻辑图、树形图、鱼骨图、组织架构图、时间轴等多种类型的思维导图。
丰富的思维导图模版：多达 100w+ 模板，覆盖各个领域。
四、天工
百度搜不到的来用天工！
天工AI是一个基于天工大模型的先进人工智能搜索引擎，它不仅能够智能地解析和回应各种查询，提供精准的搜索结果，还能够对大量信息进行深度聚合和分析，以更全面和系统的方式解答问题。
这个平台通过其高效的信息处理能力，显著提升了用户获取和理解信息的效率，同时支持多模态内容，包括文本、图像、音频和视频等，使其成为一个强大的知识获取工具。
天工AI还具备个性化推荐功能，能够根据你的搜索历史和偏好提供定制化的搜索体验，同时又非常注重用户隐私保护，确保信息安全，特别周到。
产品特色：
优秀的搜索功能：天工深度融合AI大模型能力，在数据搜集、算法设计、数据检索、答案生成等众多环节中都引入了AI大模型技术，能够为用户提供快速、智能、可靠的一站式智能搜索服务。
免费！！！天工的搜索功能是完全免费的（划重点）
五、islide
去年一整年，或许大家已经饱和式体验了各种 AI 工具产品，对于各种特色鲜明的产品，大家有多少深刻的印象呢？
如果你看过 iSlide AI，或许会为你今年的 AI 体验之旅开启一个不一样的旅程！
产品特色：
1、AI一键生成PPT将想法变为 PPT，从输入一句话开始
只需要输入一个主题即可生成你想要的专业 PPT，例如：输入新媒体行业年终总结，一套专业的 PPT 即刻诞生。
2、插件端体验更多插件端解锁更多功能，效率专业感通通拉满
如果网页端的 AI 你还没看够，那么下载islide的插件端 AI 还有更多功能与资源的补充，帮助你更专注于内容和创意，而不是被繁琐的排版工作所困扰。用上黑科技，PPT 效率立马开挂，AI 帮你打工，又是准时下班的一天！
随着本文的结束，希望能够为你提供一些启发和指导，让AIGC融入自己的生活。不要犹豫，现在就去体验使用！
相信AIGC的未来一定是一片坦途大道，UGC已成为过去，AIGC才是未来！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c79fc61cfdcac5f1b502bd9bb415508/" rel="bookmark">
			jupyter notebook连接linux
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要介绍智星云主机windows系统、Ubuntu系统下如何配置jupyter密码和启动jupyter，部分软件执行位置可能有所不同，请自行修改至合适位置。
windows系统 第一步：设置Jupyterlab密码
打开桌面Anaconda Prompt 终端
# 执行如下命令，并根据提示设置密码 jupyter notebook password 第二步：启动Jupyterlab服务
打开桌面Anaconda Prompt 终端，执行以下命令,云主机内网端口是5901启动
python -m jupyterlab --no-browser --ip 0.0.0.0 --port 5901 --config="C:\\Users\\vipuser\\.jupyter\\jupyter_notebook_config.py" --notebook-dir="C:\\" 第三步：访问Jupyterlab服务
访问地址为 VNC地址，端口为VNC端口加2
例如：VNC地址：sdly.blockelite.cn 端口：25436
云主机外访问 Jupyterlab访问地址为：sdly.blockelite.cn:25438
Linux系统 Linux系统默认已经开机启动Jupyterlab服务，访问地址为 VNC地址，端口为VNC端口减1
例如：VNC地址：sdly.blockelite.cn 端口：25436
云主机外访问，Jupyterlab访问地址为：sdly.blockelite.cn:25435
密码是vnc密码
如果密码不对，或者无法访问，请按如下步骤处理
第一步：重置密码
以root用户身份登录到系统，执行如下命令：
# 执行命令，根据提示输入密码和确认密码 jupyter-notebook password # stdout: Wrote hashed password to /root/.jupyter/jupyter_notebook_config.json 第二步： 杀掉jupyter进程
kill `ps aux | grep jupyter | awk '{print $2}' | head -n 1` &amp;&gt; /dev/null mv /root/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c79fc61cfdcac5f1b502bd9bb415508/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f914e155de2797d9da3b37b194eb549f/" rel="bookmark">
			50个JAVA常见代码大全：学完这篇从Java小白到架构师
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		50个JAVA常见代码大全：学完这篇从Java小白到架构师 Java，作为一门流行多年的编程语言，始终占据着软件开发领域的重要位置。无论是初学者还是经验丰富的程序员，掌握Java中常见的代码和概念都是至关重要的。本文将列出50个Java常用代码示例，并提供相应解释，助力你从Java小白成长为架构师。
基础语法 1. Hello World public class HelloWorld { public static void main(String[] args) { System.out.println("Hello, World!"); } } 2. 数据类型 int a = 100; float b = 5.25f; double c = 5.25; boolean d = true; char e = 'A'; String f = "Hello"; 3. 条件判断 if (a &gt; b) { // 条件成立时执行 } else if (a == b) { // 另一个条件 } else { // 条件都不成立时执行 } 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f914e155de2797d9da3b37b194eb549f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/364f11ded0e2dd668809d5ecf5e6f270/" rel="bookmark">
			一文详解数据仓库、数据湖、湖仓一体和数据网格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着数字化时代的到来，近几年数据领域的新技术概念不断涌现，数据湖、湖仓一体、流批一体、存算一体、数据编织抑或数据网格等新概念层出不穷，成为数据管理领域的新宠。本文将探讨主要探讨数据仓库、数据湖、湖仓一体以及数据网格的优势和局限性，并分析它们在未来数据管理中的角色。 一、数据仓库 数据仓库是传统的数据存储方式，其核心概念是将不同来源的数据抽取、转化和加载到一个中心化的存储系统中，供企业进行决策分析使用。数据仓库通过预定义的模式和结构化的数据模型，使得数据易于理解和查询分析。如果企业有明确的分析要求，并且数据结构稳定且易于理解，数据仓库是一个不错的选择。
优势 1.面向主题 数据仓库中的数据是按照主题进行组织的，每个主题都对应一个分析领域，如销售、库存、客户等。这种组织方式使得数据仓库能够更好地支持决策分析，用户可以根据需要快速获取所需的数据。
2.非易失性 数据仓库中的数据是静态的，一旦存储到数据仓库中，就不会轻易改变。这使得数据仓库能够长期保存企业的历史数据，方便决策者进行趋势分析和历史数据分析。
3.高性能查询 数据仓库支持高速查询和高数据吞吐量，能够凭借出色的灵活性帮助用户细分数据或降低数据量，进而执行更加细致的数据检查。
局限 1.数据类型限制 数据仓库主要处理结构化数据，难以应对非结构化或半结构化数据。
2.数据处理延迟 数据仓库需要将数据进行清洗、整合和优化，这导致数据处理存在延迟，难以满足实时分析的需求。
3.扩展性问题 随着数据量的增加，数据仓库的扩展性和维护成本不断上升。
二、数据湖 数据湖是近年来兴起的一种新兴数据存储模式，它以原始、未处理的大量数据为基础，存储在云端或本地存储系统中。数据湖无需事先定义数据结构，可以灵活存储各种类型的数据，包括结构化、半结构化和非结构化数据。
优势 1.数据多样性 数据湖可以存储各种类型的数据，包括文本、图片、视频等，支持更广泛的分析类型。
2.处理实时性 数据湖允许数据在原始形式下存储，减少了数据预处理的时间，支持实时分析。
3.成本效益 数据湖通常使用廉价的存储设备，降低了存储成本。
局限 1.数据治理 数据湖中的数据可能缺乏统一的治理和质量控制，导致数据的一致性和可靠性问题，且存在管理和维护复杂度较高。
2.查询性能 由于数据湖中数据的多样性和复杂性，查询性能可能不如数据仓库。
三、湖仓一体 湖仓一体则是数据仓库和数据湖的结合，旨在兼顾传统数据仓库的结构化查询和数据湖的灵活性。在湖仓一体模式中，数据被原样加载到数据湖中，同时进行一定程度的模式定义和质量控制，以便更好地支持企业的数据分析和决策。湖仓一体的模式适用于数据量较大、多种数据类型混合存储的场景，提供了更好的查询性能和数据探索能力。
优势 1.统一存储 湖仓一体将数据仓库和数据湖的功能集成在一个系统中，实现了数据的统一存储和管理。
2.高性能分析 通过优化数据存储和查询引擎，湖仓一体支持高性能的分析和查询。
3.数据治理 湖仓一体提供了更好的数据治理和质量控制机制，确保数据的一致性和可靠性。
局限 1.数据一致性问题 湖仓一体架构需要解决湖和仓的数据/元数据无缝打通的问题，但实际操作中可能会遇到数据一致性的问题，尤其是在数据湖和数据仓库之间进行数据同步时。
2.管理复杂性 湖仓一体虽然提供了统一的数据平台，但管理任务依然复杂。用户需要在湖和仓之间进行数据的合理分层和存储，以最大化湖和仓的优势，这增加了管理的复杂性。
3.性能瓶颈 尽管湖仓一体架构通过计算层去查询存储层中的数据，拥有类似传统数据仓库的查询性能，但对象存储不适合进行大数据查询和分析，可能会遇到性能瓶颈。
四、数据网格 数据网格是一种分布式数据管理系统，它能够处理大规模的数据并提供高性能的数据访问能力。它通过将数据分散存储在多个节点上，实现了数据的并行处理和快速响应。数据网格适用于需要实时分析和决策的场景，可以满足高并发和低延迟的需求。
优势 1.去中心化 数据网格将数据分散存储在不同的节点上，每个节点可以独立管理和维护其数据，提高了系统的可扩展性和灵活性。
2.数据自治 每个节点可以自主决定如何存储、处理和共享数据，减少了对中央管理的依赖。
3.灵活性 数据网格支持多种数据类型和处理方式，适应不同的业务需求。
局限 1.数据一致性 去中心化的架构可能导致数据一致性问题，需要更复杂的同步和一致性机制。
2.安全和隐私 数据网格需要更严格的安全和隐私保护措施，以防止数据泄露和滥用。
五、企业应该如何选择？ 在当今的大数据时代，企业需要处理和分析越来越多的数据，以便更好地了解客户需求、优化业务流程、提高生产效率等。为了实现这些目标，企业需要选择适合自己的数据存储技术。在选择之前，企业需要考虑以下几个因素：
1. 数据类型和来源。如果大部分数据都是结构化的，并且来自于内部系统或外部供应商，使用数据仓库更为合适。通常使用数据仓库ETL工具将多个源中的异构数据集成到一个统一的存储中进行多维分析。如果企业处理的数据类型和来源多样化，包括结构化、半结构化和非结构化数据，并且需要进行实时分析，则使用数据湖可能更为合适。数据湖可以存储各种类型和格式的原始或未处理的数据，并且可以在需要时进行灵活地查询和分析。
2. 数据量和增长速度。如果企业处理的数据量较小，增长速度较慢，则使用传统数据库可能足够。但是，如果企业处理的数据量非常大，并且增长速度很快，则使用数据仓库或者数据湖可能更为合适。
3. 分析需求。如果企业需要进行复杂的多维分析，并且需要频繁地查询和报告，则使用数据仓库可能更为合适。但是，如果企业需要进行实时分析，并且需要快速地探索新型分析模型，则使用数据湖可能更为合适。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/364f11ded0e2dd668809d5ecf5e6f270/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/139/">«</a>
	<span class="pagination__item pagination__item--current">140/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/141/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>