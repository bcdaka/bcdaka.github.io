<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec070b528ce8cdb09622d886063d9011/" rel="bookmark">
			NLP:spacy库安装与zh_core_web_sm配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		到公司来第一个项目竟然是偏文本信息抽取与结构化的，（也太高看我了┭┮﹏┭┮）
反正给机会了就上吧，我就一臭实习的，怕个啥。配置了两天的环境，也踩了不少坑，我把我的经历给大家分享一下：
首先确定zh_core_web_sm版本： 安装路径
（当然你可以换一个模型，我这里是以zh_core_web_sm为例，因为它下载容量小一些，不过精确率也稍微差一点，想追求效果好的可以试试zh_core_web_trf-3.7.0他是基于特征抽取器Tranformer，有想了解这方面背景故事的小伙伴可以看看这位大佬的博客：NLP12篇核心文章）
这一步非常重要，因为只有确定了他的版本号，才可以往后面去下载spacy,因为你如果后面两个版本对不上，执行代码的时候就会显示找不到zh_core_web_sm。记录你的版本号，之后按照这个博主的流程下载：下载流程。
而且注意版本最好不要太低，我一开始安装的是3.1.0的，但是后面安装spacy的时候就安装不上了(会报下面的错)，最后换成3.7.0的就好了
如果后续有报错的话可以尝试加上下一步的镜像去下载，虽然不知道为什么，但是加上了确实可以解决我的问题 之后安装spacy,先在终端输入下面四行指令 （这里最好使用anconda创建一个新的虚拟环境，防止串包，因为下载的东西有点多。anconda创建切换环境）
pip install -U pip setuptools wheel pip install -U spacy==之前记录下来的版本号 pip install spacy-transformers python3 -m spacy download zh_core_web_trf 这里直接用的话就会很慢，最好后面补充镜像去下载：
pip install 库名 -i https://pypi.tuna.tsinghua.edu.cn/simple 如果加上了还显示连接超时的话，可能就是公司的网络太慢了，可以连一下自己的热点试试
最后应该就好了，给一段测试代码自己试试叭： # # coding=utf-8 import spacy nlp = spacy.load("zh_core_web_sm") doc = nlp("庆祝祖国生日快乐") print(doc.text) for token in doc: print(token.text, token.pos_, token.dep_) 环境到此配置的差不多了，下篇论文我们将讲解如何训练专属于我们的模型：下一篇
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f42211bcb5faf6a0ad8de6411be44fe/" rel="bookmark">
			数据结构奇妙旅程之二叉平衡树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		꒰˃͈꒵˂͈꒱ write in front ꒰˃͈꒵˂͈꒱
ʕ̯•͡˔•̯᷅ʔ大家好，我是xiaoxie.希望你看完之后,有不足之处请多多谅解，让我们一起共同进步૮₍❀ᴗ͈ . ᴗ͈ აxiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客
本文由xiaoxieʕ̯•͡˔•̯᷅ʔ 原创 CSDN 如需转载还请通知˶⍤⃝˶
个人主页：xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客
系列专栏：xiaoxie的JAVA系列专栏——CSDN博客●'ᴗ'σσணღ*
我的目标:"团团等我💪( ◡̀_◡́ ҂)" ( ⸝⸝⸝›ᴥ‹⸝⸝⸝ )欢迎各位→点赞👍 + 收藏⭐️ + 留言📝​+关注（互三必回）!
一.二叉平衡树 1.二叉平衡树的概念 二叉搜索树又称二叉排序树，它或者是一棵空树，或者是具有以下性质的二叉树:
若它的左子树不为空，则左子树上所有节点的值都小于根节点的值
若它的右子树不为空，则右子树上所有节点的值都大于根节点的值
它的左右子树也分别为二叉搜索树
从上述概念以及图中可以看出，二叉搜索树具有以下特性：
1. 二叉搜索树中最左侧的节点是树中最小的节点，最右侧节点一定是树中最大的节点
2. 采用中序遍历遍历二叉搜索树，可以得到一个有序的序列 2.二叉搜索树的主要操作 1. 查询 2.插入 1.插入的为一颗空树 直接插入即可
2.. 如果树不是空树，按照查找逻辑确定插入位置，插入新结点 根据二叉搜索树的性质插入节点,"左小右大"
对于树中的任意节点 n，其左子树中的所有节点的值都小于 n 的值，其右子树中的所有节点的值都大于 n 的值。在插入新节点时，需要按照二叉搜索树的性质找到合适的位置插入，保持树的有序性。插入节点后，需要调整树的结构，保证树仍然是一个二叉搜索树。 3.删除 假设删除节点cur那么cur有以下几种情况
1.cur 的左孩子为空,右孩子不为空,
2.cur 的右孩子为空,左孩子不为空.
3.cur 的左右孩子均为空.
4.cur 的左右孩子均不为空.
接下来博主将会通过画图的形式来演示这四种情况该如何删除节点
1.cur 的左孩子为空,右孩子不为空 2.cur 的右孩子为空,左孩子不为空. 3. cur 的左右孩子均为空. 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f42211bcb5faf6a0ad8de6411be44fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cd6e032caec46f8de594dc30d6b374a/" rel="bookmark">
			Android Studio下载安装及完全卸载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Android Studio简介
二、Android Studio的下载
三、AS的安装
四、修改配置
五、AS的完全卸载
一、Android Studio简介 Android Studio是Google官方推荐的Android应用开发集成环境，它提供了集成的开发工具，支持Java、Kotlin等编程语言进行Android应用的开发。Android Studio基于IntelliJ IDEA，具有强大的代码编辑、调试、测试和性能优化等功能。此外，它还集成了模拟器、布局编辑器、APK分析器等多种工具，帮助开发者高效地构建高质量的Android应用 在移动终端开发课程中，Android Studio通常被用作主要的开发工具。通过学习移动终端开发课程，学生可以掌握使用Android Studio进行Android应用开发的基本技能。这些课程通常会涵盖Android应用的基本概念、UI设计、数据存储、网络通信、多线程处理等方面的知识，而Android Studio则是实现这些功能的主要工具 那么下面来演示Android Studio的下载，安装，以及第一次打开所需要的配置
二、Android Studio的下载 前情提要：Android Studio需要JDK11，如果是JDK8的AS安装会报错如下图，建议重新安装JDK
如需JDK11下面链接也有提供
下面提供一个百度网盘文件的下载链接，点击此处，也可以复制下方文本
链接：https://pan.baidu.com/s/1y9H_YG2MXVrOZ_O6ZlJ8rQ 提取码：nxfc
下载完成后有四个文件
dist文件夹是安装后修改配置时用到的
第二个就是安装的Android Studio了
第三个是JDK11
第四个是夜神模拟器，本文不涉及，但以后会用到
三、AS的安装 双击第二个文件，运行如图所示，点击Next
Next(此处的Android Virtual Device默认勾选，如没勾选请勾选上)
选择你的安装路径（全英文），Next
直接install
双击运行AS，选择如下，点击ok
如果遇到这个页面直接叉掉或者cancel就可以
Dont send ,Next
Custom（Custom可以自行选择SDK安装路径，standard自动装C盘，如嫌麻烦直接选Standard版，可节约后续很多步骤），Next
选择你的JDK包（如Standard版，没有此步骤）
选择适合你的黑/白页面，next
选择SDK安装路径（如Standard版，没有此步骤）
这是需要下载的配置，next就好
accept（有几个选几个，全部accept），Finish，等待下载（有点慢，需要等一会）
Finish
安装完成
四、创建工程以及修改配置 点击new Project，选择空文件
选择修改文件名，存储路径，语言（自行选择），Finish
此处也需要等一会
下载完成后会自动打开文件，此时自动导包，不过速度十分缓慢
下面需要修改配置，类似于修改maven的导包地址，用到网盘里的第一个文件夹dists
dists文件夹中文件拷贝至C:\Users\lhy（每个人不同）\.gradle\wrapper\dists下，覆盖(需先关闭AS)
完成后打开AS，此时可以看见文件以肉眼可见的速度下载了（虽然说还是需要好久），如没有下载，点击右上角同步工程如图（这一步是最慢的，需要大量时间以及优质网速）
等待导完包即可（第一次需要好久，笔记本请在有电源的情况下导包）
导不完包关闭AS下次打开项目会自动下载，如没有下载，点击右上角同步工程
下载完毕后部分字体会变色，类似于这样
五、AS的完全卸载 当你配置时不小心点错，卸载AS重新安装发现不会再弹出一些配置，那是因为AS在配置时创建了一些文件，只是卸载AS，配置文件仍会保留，下次安装AS的时候会自动读取未删除的配置，下面介绍如何把文件全部删除，让你重新配置AS
首先到设置-&gt;应用里去搜索Android Studio，点击卸载进行常规卸载
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cd6e032caec46f8de594dc30d6b374a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/592cf208c525495ba4a31c743369c9e5/" rel="bookmark">
			【网络原理】使用Java基于TCP搭建简单客户端与服务器通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 🎄API介绍🌸ServerSocket API🌸Socket API 🍀TCP中的长短连接🌳建立TCP回显客户端与服务器🌸TCP搭建服务器🌸TCP搭建客户端 ⭕总结 TCP服务器与客户端的搭建需要借助以下API 🎄API介绍 🌸ServerSocket API ServerSocket 是创建TCP服务端Socket的API。
ServerSocket 构造方法：
方法签名方法说明ServerSocket(int port)创建一个服务端流套接字Socket，并绑定到指定端口 ServerSocket 方法：
方法签名方法说明Socket accept()开始监听指定端口（创建时绑定的端口），有客户端连接后，返回一个服务端Socket对象，并基于该Socket建立与客户端的连接，否则阻塞等待void close()关闭此套接字 🌸Socket API Socket 是客户端Socket，或服务端中接收到客户端建立连接（accept方法）的请求后，返回的服务端Socket。
不管是客户端还是服务端Socket，都是双方建立连接以后，保存的对端信息，及用来与对方收发数据的。
Socket 构造方法：
方法签名方法说明Socket(String host, intport)创建一个客户端流套接字Socket，并与对应IP的主机上，对应端口的进程建立连接 Socket 方法：
方法签名方法说明InetAddress getInetAddress()返回套接字所连接的地址InputStream getInputStream()返回此套接字的输入流OutputStream getOutputStream()返回此套接字的输出流 🍀TCP中的长短连接 博主在前面的博文里面说到，TCP是面向连接的通信方式，TCP发送数据时，需要先建立连接，而这个连接又分为长短连接：
短连接：每次接收到数据并返回响应后，都关闭连接，即是短连接。也就是说，短连接只能一次收发数据。
长连接：不关闭连接，一直保持连接状态，双方不停的收发数据，即是长连接。也就是说，长连接可以多次收发数据
对比以上长短连接，两者区别如下：
建立连接、关闭连接的耗时：短连接每次请求、响应都需要建立连接，关闭连接；而长连接只需要第一次建立连接，之后的请求、响应都可以直接传输。相对来说建立连接，关闭连接也是要耗时的，长连接效率更高。
主动发送请求不同：短连接一般是客户端主动向服务端发送请求；而长连接可以是客户端主动发送请求，也可以是服务端主动发。
两者的使用场景有不同：短连接适用于客户端请求频率不高的场景，如浏览网页等。长连接适用于客户端与服务端通信频繁的场景，如聊天室，实时游戏等
拓展：
基于BIO（同步阻塞IO）的长连接会一直占用系统资源。对于并发要求很高的服务端系统来说，这样的消耗是不能承受的。
由于每个连接都需要不停的阻塞等待接收数据，所以每个连接都会在一个线程中运行。一次阻塞等待对应着一次请求、响应，不停处理也就是长连接的特性：一直不关闭连接，不停的处理请求
实际应用时，服务端一般是基于NIO（即同步非阻塞IO）来实现长连接，性能可以极大的提升。
🌳建立TCP回显客户端与服务器 🌸TCP搭建服务器 我们分为以下几步来实现：
创建TcpEchoServer类来表示我们的服务器，并创建ServerSocket对象，初始值为null在TcpEchoServer的构造方法里进行ServerSocket对象的实例化用一个start()方法表示启动程序在该方法内我们首先要使用accept()进行连接，并用Socket对象进行接收我们再用一个processConnection(Socket clientSocket)方法处理我们的连接 由于我们的TCP传输是以流的形式传播的，所以我们这里用到了读写数据流的方法来进行书写，不会这一部分的小伙伴，可以去看看博主所写【Java EE】文件内容的读写⸺数据流进行查看学习
接下来我们书写这个processConnection(Socket clientSocket)方法
读取请求，构造输入流的Scanner，并判断后面如果没有数据就关闭连接然后我们将读取的数据交给我们的 response()构造响应响应后的数据写入该套接字的输出流中，最后flush()，进行刷新，确保写入 为了释放资源，我们每一次交互完毕都需要对我们的套接字进行关闭，这里我们使用fially来进行处理
代码如下：
import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/592cf208c525495ba4a31c743369c9e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/577159e078dafd6c5161c2d5d9b1e941/" rel="bookmark">
			TimescaleDB 开源时序数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.TimescaleDB介绍2.Hypertable 和 chunk3.Hypertable4.Hypertable操作 开源中间件 # TimescaleDB https://iothub.org.cn/docs/middleware/ https://iothub.org.cn/docs/middleware/timescale/timescale-summary/ 1.TimescaleDB介绍 TimescaleDB是基于PostgreSQL数据库打造的一款时序数据库，插件化的形式，随着PostgreSQL的版本升级而升级。
TimescaleDB具备以下特点
基于时序优化自动分片（按时间、空间自动分片(chunk)）全SQL接口支持垂直于横向扩展支持时间维度、空间维度自动分区。空间维度指属性字段（例如传感器ID，用户ID等）支持多个SERVER，多个CHUNK的并行查询。分区在TimescaleDB中被称为chunk自动调整CHUNK的大小内部写优化（批量提交、内存索引、事务支持、数据倒灌）
内存索引，因为chunk size比较适中，所以索引基本上都不会被交换出去，写性能比较好
数据倒灌，因为有些传感器的数据可能写入延迟，导致需要写以前的chunk，timescaleDB允许这样的事情发生(可配置)复杂查询优化（根据查询条件自动选择chunk，最近值获取优化(最小化的扫描,类似递归收敛)，limit子句pushdown到不同的server,chunks，并行的聚合操作）
《时序数据合并场景加速分析和实现 - 复合索引，窗口分组查询加速，变态递归加速》利用已有的PostgreSQL特性（支持GIS，JOIN等），方便的管理（流复制、PITR）支持自动的按时间保留策略（自动删除过旧数据） # 官网地址 https://www.timescale.com/ # 文档 https://docs.timescale.com/latest/main # 安装 https://docs.timescale.com/latest/getting-started/installation/rhel-centos/installation-yum # github https://github.com/timescale/timescaledb # docker https://hub.docker.com/r/timescale/timescaledb 2.Hypertable 和 chunk TimescaleDB作为PostgreSQL的扩展实现，这意味着Timescale数据库在整个PostgreSQL实例中运行。 该扩展模型允许数据库利用PostgreSQL的许多属性，如可靠性，安全性以及与各种第三方工具的连接性。 同时，TimescaleDB通过在PostgreSQL的查询规划器，数据模型和执行引擎中添加钩子，充分利用扩展可用的高度自定义。
从用户的角度来看，TimescaleDB公开了一些看起来像单数表的称为hypertable的表，它们实际上是一个抽象或许多单独表的虚拟视图，这些表包含称为块的数据。
通过将hypertable的数据划分为一个或多个维度来创建块：所有可编程元素按时间间隔进行分区，并且可以通过诸如设备ID，位置，用户ID等的关键字进行分区。我们有时将此称为分区 横跨“时间和空间”。
Hypertable 与数据交互的主要点是一个可以抽象化的跨越所有空间和时间间隔的单个连续表，从而可以通过标准SQL查询它。
实际上，所有与TimescaleDB的用户交互都是使用可调整的。 创建表格和索引，修改表格，插入数据，选择数据等都可以（也应该）在hypertable上执行。
在TimescaleDB中创建一个超表需要两个简单的SQL命令：创建表（使用标准SQL语法），然后选择CLEATEYHYTABLE（）。
chunk 在内部，TimescaleDB自动将每个可分区块分割成块，每个块对应于特定的时间间隔和分区键空间的一个区域（使用散列）。 这些分区是不相交的（非重叠的），这有助于查询计划人员最小化它必须接触以解决查询的组块集合。
每个块都使用标准数据库表来实现。 （在PostgreSQL内部，这个块实际上是一个“父”可变的“子表”。）
块是正确的大小，确保表的索引的所有B树可以在插入期间驻留在内存中。 这可以避免在修改这些树中的任意位置时发生颠簸。
SELECT show_chunks('conditions'); SELECT show_chunks('conditions', older_than =&gt; INTERVAL '3 months'); SELECT show_chunks('conditions', older_than =&gt; DATE '2017-01-01'); 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/577159e078dafd6c5161c2d5d9b1e941/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e787c017df9022322c418474ae5d70f4/" rel="bookmark">
			【人工智能】本地搭建AI模型Gemma
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、安装条件二、安装ollama优化存储路径(不用优化也行)ollama命令详解：模型命令详解： 三、安装WebUiwindows安装不了docker解决测试 前言 最近看到google的gemma模型很火，因为模型较小对于但功能强大，大模型虽然很好但对于我们普通人来说过于遥远，不管是训练的token来说还是模型的复杂度，小模型都比不上，但是小模型的对于我们的训练成本没有那么高但是可以体验到不一样的感觉。
一、安装条件 最低条件：
2B版本需要2G显存
7B版本需要4G显存
7B的其他版本需要更大
7B我这里使用3050 Laptop测试可以运行但生成速度很慢
二、安装ollama 下载ollama：
https://ollama.com/download
直接安装
安装完成后启动：
使用windows键+R打开运行窗口：
ollama 或者ollama help 优化存储路径(不用优化也行) ollama有个问题是没有选择路径，导致我们如果使用windows下载会下载到c盘中容易c盘爆满，现在来优化这个问题：设置》系统》高级系统设置》环境变量》新建系统变量
名称OLLAMA_MODELS路径给到自己创建新建文件夹：
如果打开了程序重新启动即可生效
ollama命令详解： 命令注释：
serve: 启动 ollama，用于提供模型服务。 create: 从模型文件创建一个模型。 show: 显示模型的信息。 run: 运行一个模型。 pull: 从注册表中拉取一个模型。 push: 将一个模型推送到注册中心 list: 列出模型。 cp: 复制一个模型。 rm: 删除一个模型。 help: 获取有关任何命令的帮助。 常用命令：
ollama run 模型名称:版本 ollama run gemma:2b 模型lib：https://ollama.com/library/
这里选择版本copy命令直接粘贴命令即可下载：
如果优化了存储路径直接可以在文件夹下看到下载的模型
完成后直接可以对话了：
这里运行的2b（版本来看应该是3B）的模型，因为我显卡比较垃圾返回速度比较慢：
模型命令详解： /set: 设置会话变量。
/show: 显示模型信息。
/load : 加载一个会话或模型。
/save : 保存当前会话。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e787c017df9022322c418474ae5d70f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b2ca371e7308d055db11dbc864b4d5f/" rel="bookmark">
			GPT-SoVITS-WebUI可以中文声音克隆开源AI工具简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言： 近年来，随着人工智能技术的不断发展，语音技术已经成为了热门领域。尽管已有不少技术实现了一定程度的成功，但传统语音合成技术的问题依然存在。传统方法对于训练数据的需求量大、效果受到声音质量和口音差异的影响。因此，在语音技术领域中，一种受到广泛关注的新技术GPT-SoVITS-WebUI应运而生。GPT-SoVITS是花儿不哭大佬研发的低成本AI音色克隆软件，作为一种新兴的网络界面工具，具有自主学习、高效合成、支持多语言等特点，在语音领域中受到极高的关注和重视。它不仅能够迅速训练高质量的文本到语音模型，更能够克服声音质量和口音差异的影响，在语音合成中发挥既有的功效。同时，GPT-SoVITS-WebUI具有零次学习和少量次学习的TTS功能，可以实现自然语言转换，进一步提高了语音合成的性能。这一特性可为语音技术的开发者和爱好者带来更多的机会，实现多样化的语音应用，创造更加便捷的用户体验。综上所述，GPT-SoVITS-WebUI是一种非常先进的语音技术，具有广泛的应用前景和潜力。创作不易，要是对您有用请加个关注或点个赞，非常感谢了！
开源地址： https://github.com/RVC-Boss/GPT-SoVITS
以下依据官方文档整理而得：
特点： 零样本 TTS：输入 5 秒的人声样本，体验即时文本到语音转换。
小镜头 TTS：只需 1 分钟的训练数据即可微调模型，以提高语音相似度和真实感。
跨语言支持：使用与训练数据集不同的语言进行推理，目前支持英语、日语和中文。
WebUI工具：集成工具包括语音伴奏分离、自动训练集分割、中文ASR和文本标注，帮助初学者创建训练数据集和GPT/SoVITS模型。
详细说明：教程中文版 User guide （EN）
安装 对于中国地区的用户，您可以点击此处使用AutoDL Cloud Docker在线体验全部功能。
经测试的环境 Python 3.9、PyTorch 2.0.1、CUDA 11Python 3.10.13、PyTorch 2.1.2、CUDA 12.3Python 3.9、PyTorch 2.3.0.dev20240122、macOS 14.3（Apple 芯片） 注意：numba==0.56.4 需要 py&lt;3.11
window系统 如果你是 Windows 用户（使用 win&gt;=10 测试），你可以直接下载预打包的发行版，双击 go-webui.bat 启动 GPT-SoVITS-WebUI。
Linux操作系统 conda create -n GPTSoVits python=3.9 conda activate GPTSoVits bash install.sh macOS操作系统 只有满足以下条件的 Mac 才能训练模型：
搭载 Apple 芯片的 Mac 电脑macOS 12.3 或更高版本通过运行xcode-select --install 所有 Mac 都可以使用 CPU 进行推理，这已被证明优于 GPU 推理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b2ca371e7308d055db11dbc864b4d5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd781bd936d47103502a039b7cc6dd04/" rel="bookmark">
			下载pycharm后还要python吗,用python必须下载pycharm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，本文将围绕下载了python后第一步该做什么展开说明，python安装后还需要安装什么是一个很多人都想弄明白的事情，想搞清楚下载完python就可以编程了吗需要先了解以下几个事情。
目录 一、Python 和 PyCharm 区别二、Python 安装三、PyCharm 安装四、PyCharm 安装汉化语言包五、新建项目 一、Python 和 PyCharm 区别 1、下载地址和安装的方式不同。
2、Python 是一种基本编译环境，就像 java 和 jar 一样python自动化运维效果。PyCharm 是一种集成开发环境，为了能够让你快速编写代码，便于调试。
3、Python 是个解释器。PyCharm 是为 Python 编程语言专门打造的一款 IDE（集成开发环境）。在 PyCharm 中编写 Python 程序，最终还是要有 Python 解释器的支持，两者配合工作。
4、单独下载一个 PyCharm 是不行的，同时还要下载一个 Python 解释器。
二、Python 安装 点击下载 Python-3.6.3-64位 安装包
1、先选中 Add Python 3.6 to PATH，再点击 Customize installation；
2、点击 Next；
3、选中 Install for all users，选择安装路径（尽量避免安装在 C 盘），点击 Install；
4、点击 Close，安装完成。
三、PyCharm 安装 点击下载 PyCharm-community-2021.2.3 安装包
1、点击 Next；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd781bd936d47103502a039b7cc6dd04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25510b71273b9c4a20468710563a19c0/" rel="bookmark">
			华为OD机试 - 矩阵匹配（Java &amp; JS &amp; Python &amp; C &amp; C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 从一个 N * M（N ≤ M）的矩阵中选出 N 个数，任意两个数字不能在同一行或同一列，求选出来的 N 个数中第 K 大的数字的最小值是多少。
输入描述 输入矩阵要求：1 ≤ K ≤ N ≤ M ≤ 150
输入格式：
N M K
N*M矩阵
输出描述 N*M 的矩阵中可以选出 M! / N! 种组合数组，每个组合数组种第 K 大的数中的最小值。无需考虑重复数字，直接取字典排序结果即可。
备注 注意：结果是第 K 大的数字的最小值
用例 输入3 4 2
1 5 6 6
8 3 4 3
6 8 6 3输出3说明 N*M的矩阵中可以选出 M！/ N！种组合数组，每个组合数组种第 K 大的数中的最小值；
上述输入中选出数组组合为：
1,3,6;
1,3,3;
1,4,8;
1,4,3;
......
上述输入样例中选出的组合数组有24种，最小数组为1,3,3，则第2大的最小值为3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25510b71273b9c4a20468710563a19c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79e4240d1dff3b3eebffa10533168fb0/" rel="bookmark">
			代码训练LeetCode(6)编辑距离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码训练(6)LeetCode之编辑距离 Author: Once Day Date: 2024年3月9日
漫漫长路，才刚刚开始…
全系列文章可参考专栏: 十年代码训练_Once-Day的博客-CSDN博客
参考文章:
72. 编辑距离 - 力扣（LeetCode）力扣 (LeetCode) 全球极客挚爱的技术成长平台 文章目录 代码训练(6)LeetCode之编辑距离1. 原题2. 分析3. 代码实现4. 总结 1. 原题 给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数 。
你可以对一个单词进行如下三种操作：
插入一个字符删除一个字符替换一个字符 例如对于horse和ros两个单词，其最少操作数为3，即如下三步:
horse -&gt; rorse (将 'h' 替换为 'r') rorse -&gt; rose (删除 'r') rose -&gt; ros (删除 'e') 2. 分析 这种表面一看，似乎是个字符串问题，但是如果按照分类匹配去做，怕是很难得出合理的方法。求两个字符串的编辑距离实际是个动态规划入门题目，动态规划算法是解决这个问题的标准方法。
我们先从逻辑分析一下，对于两个字符串，如horse和ros，在三种操作下，其最小操作数有下述四种情况:
已知字符串hors和ros的最小操作数，然后再删除一个字母e，即: MinOperation["hors"]["ros"] + 1。已知字符串horse和ro的最小操作数，然后再增加一个字母s，即: MinOperation["horse"]["ro"] + 1。已知字符串hors和ro的最小操作数，然后再替换一个字母e -&gt; s，即: MinOperation["hors"]["ro"] + 1。已知字符串hors和ros的最小操作数，如果最后一个字母相同，则不变，即: MinOperation["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79e4240d1dff3b3eebffa10533168fb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/723b7208399d0ac0e318f54babc86fb1/" rel="bookmark">
			3分钟学会写文心一言指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 码到三十五 ： 个人主页 心中有诗画，指尖舞代码，目光览世界，步履越千山，人间尽值得 ! 文心一言是百度研发的 人工智能大语言模型产品，能够通过上一句话，预测生成下一段话。
任何人都可以通过输入【指令】和文心一言进行对话互动、提出问题或要求，让文心一言高效地帮助人们获取信息、知识和灵感。
指令（prompt）其实就是文字，它可以是你向文心一言提的问题（如： 帮我解释一下什么是芯片 ），可以是你希望文心一言帮你完成的任务（如： 帮我写一首诗/画一幅画 ）
一条指令的背后也许是工作中被省掉的N个小时；是学习中多学到的N条知识；是生活中解答的N条疑问；无聊郁闷时的N份正能量。如果你仍苦于不知如何跟AI交互，不妨直接看看这里，三分钟带你快速上手文心一言指令，帮你在不同应用场景找到属于你的宝藏指令！
目录 一、文心一言基础指令技巧1.1 指令（Prompt）基本格式1.2 指令词构造示例1.2.1 什么是不好的指令词1.2.2 什么是好的指令词 二、文心一言入门指令应用实例巧用文心一言，提效工作职场 一、文心一言基础指令技巧 1.1 指令（Prompt）基本格式 参考信息：包含文心一言完成任务时需要知道的必要背景和材料，如：报告、知识、数据库、对话上下文等
动作：需要文心一言帮你解决的事情，如：撰写、生成、总结、回答等
目标：需要文心一言生成的目标内容，如：答案、方案、文本、图片、视频、图表等
要求：需要文心一言遵循的任务细节要求，如：按XX格式输出、按XX语言风格撰写等
1.2 指令词构造示例 一条优秀的指令词应清晰明确且具有针对性，能够准确引导模型理解并回应你的问题。下面，让我们看一下什么是不好的指令词，什么是优秀的指令词：
1.2.1 什么是不好的指令词 写一首山和树林的诗。
下面的题帮我讲一下。
撰写一篇有关大语言模型可信性的论文。
1.2.2 什么是好的指令词 恭喜你，已经学会了一条优质指令词的基本构造形式。光说不练假把式！接下来我们将使用真实的实践案例，带你一同挖掘文心一言更多的宝藏能力。
二、文心一言入门指令应用实例 了解文心一言的入门指令（Prompt）方法论之后，本篇章将从职场提效、学习成长、生活助手、情感陪伴、休闲娱乐五个方面，围绕具体的使用人群和真实的使用场景展现对应的方法论。
巧用文心一言，提效工作职场 职场人的一天难免身陷灵感荒漠，为一条创意想破脑袋；亦或是，面对重复却耗时的任务，被冗长的材料消磨了自己的热情。快来运用刚才学到的指令公式，让灵感涌现，跟重复、机械、低效Say No！
无论你是程序员、设计师、教师、影视编导，还是需要兼具创意和执行力的广告人、自媒体、作家、写手，你都可以让文心一言成为你的专属打工人。
如果你是一个每天都需要打造爆款的广告人、自媒体、主播
灵感匮乏、创意枯竭怎么办？莫慌！文心一言能够为你快速脑暴想点子，也能为你一步到位直接生成创意文字/图片/视频。
以创作陈年老酒这款商品的广告文案为例，10s内一行短句轻松让你灵感爆发，超额达成工作任务！
如果你是一位每天都要写一沓文书、材料、方案、总结的职场“苦命人”
我一定要向你推荐文心一言！你只需要输出关键信息点，文心一言可以帮你把内容进行扩写和分段，保证有逻辑、有条理、有文化、有品质，堪称材料写作界的一把好手！
以写一封在大会上的公开表扬稿为例，你只需要告诉文心一言被表扬者的几大优点，然后要求文心一言进行扩写，且需要表达流畅、书面、有条理、有逻辑即可！文心一言就可以帮你私人订制一篇独一无二又具有文化内涵的表扬稿，一起来看看！
如果你是经常需要处理大量数据的“公式代码小白”
想用Excel函数公式处理数据，却觉得公式繁多记不住、操作复杂不会用、数据量大难处理。莫慌！文心一言用10秒帮你轻松扫除障碍！你只需要输入想实现的数据效果，文心一言可以帮你制作表格、编写公式、构建代码，确保高效、简单、易懂！ 设想这样一个场景：你手头有一堆零散的数据，需要逐个复制粘贴到Excel表格中，是不是觉得非常繁琐？文心一言可以化身数据小能手，直接帮你数据变表格。如果还想添加新列并进行计算，只需向文心一言提供计算公式，便可迅速生成所需表格。
你可以在文心一言对话框输入 ：
请将以下数据以表格形式呈现，并且增加一列百分比（显示格式为“运算结果数值”＋“％”）百分比运算公式＝重量／（10＋10＋20＋30＋30）*100 名称 重量 价格 盐 10 1 糖 10 2 味精 20 3 鸡精 30 4 花椒 30 5 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6155b3706366cab48c276c218ca93ee/" rel="bookmark">
			macOS上实现「灵动岛」效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自从Apple iPhone推出了「灵动岛」功能后，用户们就被其优雅的设计和强大的功能所吸引。然而，作为macOS用户，我们一直在等待这一功能能够在我们的设备上实现。现在，随着新的应用程序的推出，我们终于可以在我们的Mac上体验到这一令人兴奋的功能了。让我们一起来探索全新的macOS版「灵动岛」，感受其带来的惊喜和便利。
MediaMate 下载 MediaMate 3.0.7 macOS上实现「灵动岛」-苹果软件盒子MediaMate是一款专注于优化macOS系统HUD（Heads-Up Display，悬浮显示）的应用程序，旨在为用户提供更加直观、美观和高效的音量、显示和键盘亮度控制体验。https://www.macappbox.com/a/mediamate.html
新推出的应用程序名为MediaMate，它的设计目标是为音量、显示和键盘亮度HUD带来全新的视觉效果，并引入了全新的「正在播放」HUD功能。让我们逐一来看看它的特色功能：
「正在播放」HUD：这一功能是MediaMate的亮点之一。它能够显示当前正在播放的媒体，并提供了播放/暂停和滑动等快速控制选项。不仅如此，它还可以选择显示在凹口内部，或者单独显示在气泡中，为用户带来更加灵活的操作体验。
优化的HUD设计：音频、亮度和键盘亮度HUD替代了系统原生的HUD，呈现出更加美观和直观的界面。用户可以根据自己的喜好选择iOS风格主题、圆形主题、刘海主题和经典主题，定制属于自己的HUD风格。
音频输出图标：用户可以在音频HUD中快速查看输出设备，轻松切换音频输出源，提升了音频操作的便利性和效率。
自定义设置：MediaMate提供了丰富的自定义设置，用户可以根据个人需求调整应用程序的各项功能，从控制键盘亮度的快捷键到焦点过滤器的启用，都可以根据用户的喜好进行个性化设置。
全面支持：MediaMate适用于所有的Mac设备，并且对Touch Bar Mac也提供了支持，虽然在Touch Bar上的表现可能略有不同，但这并不影响其在功能上的强大和稳定性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34e797455eae7e12912ba2ca75f248eb/" rel="bookmark">
			Python-AST语法树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、抽象语法树 1、什么是抽象语法树 在计算机科学中，抽象语法树（abstract syntax tree ，AST），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。AST是编译器或解释器在处理源代码时所使用的一种中间表示形式，在编译和代码生成过程中起着关键作用。
之所以说语法是「抽象」的，是因为这里的语法并不会表示出真实语法中出现的每个细节。
AST中的每个节点表示源代码中的一个语法构造，如变量声明、表达式、函数调用、控制结构等。树的根节点通常表示整个源代码文件，而子节点表示具体的语法元素及其关系。例如，一个函数声明的AST节点可能包含多个子节点，如函数名、参数列表和函数体等。
2、使用场景 python 和 Java 类似，解释器实际上分为两部分：编译器和虚拟机，先将代码编译成字节码，然后再由虚拟机执行。
编译器的编译过程,书中分为了6步：扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化。
词法分析：源代码可以看成字符序列，词法分析就是将源代码的字符序列分割成一系列的记号（Token，如关键字、标识符、字面量、特殊符号）。过程就是源代码程序被输入扫描器(Scanner，这里扫描器也是一个程序)，然后扫描器运用算法（如有限状态机）将字符序列分割成记号。同时扫描器会将这些记号放入一些表中。语法分析：使用语法分析器对词法分析阶段产生的记号进行语法分析，产生一棵语法树（采用上下文无关语法分析）。语法分析同时会确定符号优先级和含义，报告表达式不合法的错误等。语义分析：使用语义分析器来确定语句的语义，分为两种。静态语义：在编译期可以确定的语义，包括声明、类型匹配、类型转换。动态语义：在运行期才能确定的语义。中间语言生成（源代码优化）：编译器有很多层次的优化，对源代码级别有一个优化，使用源码级优化器。目标代码生成和优化：代码生成器将中间代码转换成目标机器代码，这个过程依赖目标机器。目标代码优化器对目标代码进行优化，如选择合适寻址方式、删除多余指令、使用位移代替乘法运算。 在编译时，AST主要用途包括：
语法检查：编译器可以通过遍历AST来检查源代码中是否存在语法错误。语义分析：编译器可以使用AST来分析源代码的语义，例如识别类型错误、作用域错误等。优化：编译器可以通过对AST进行变换和简化，实现源代码的优化。代码生成：编译器可以根据AST生成目标代码，例如汇编语言或机器代码。 在实际应用中，AST除了用于编译器或解释器，还被用于诸如代码重构、静态分析和代码格式化等工具和技术中。
编译器和解释器的核心：AST是编译器和解释器处理源代码的关键数据结构。在对源代码进行语法分析之后，编译器或解释器会生成AST。接下来，它们可以在AST上进行进一步的分析、优化和代码生成。这使得编译器和解释器能够更高效地处理源代码，为生成可执行程序或执行脚本提供基础。
代码分析：AST在静态代码分析和静态类型检查中起着重要作用。通过分析AST，我们可以检测代码中的潜在错误、不良实践和安全漏洞，从而提高代码质量。
代码转换和优化：编译器、解释器和其他工具（如Babel或Webpack）可以使用AST来进行代码转换和优化。这些工具可以在AST上执行各种操作，如语法转换（例如将ES6+语法转换为ES5语法）、代码压缩、代码拆分和常量传播等。这有助于提高程序的性能和兼容性。
代码生成：基于AST，编译器和解释器可以生成目标代码（例如机器代码、字节码或其他编程语言的代码）。这使得跨平台编译和运行成为可能，例如：将C++代码编译为WebAssembly，以便在Web浏览器中运行。
代码重构和编辑器支持：AST在代码重构和编辑器支持中也起着重要作用。通过分析和操作AST，我们可以实现自动化的代码重构、代码补全、语法高亮、错误检查等功能，从而提高开发者的生产力。
3、AST还能做什么 抽象语法树（AST）在编程语言处理、软件工程和开发工具中发挥着关键作用。除了前面讨论过的用途之外，AST还可以用于以下方面：
代码生成器：可以根据AST生成代码模板和脚手架工具。例如，根据类和方法定义生成REST API的客户端和服务器端实现。
语言转换：通过分析源语言的AST，然后将其转换为目标语言的AST，可以实现源代码到目标代码的转换。例如，将TypeScript代码转换为JavaScript代码。
代码覆盖率分析：通过分析AST，我们可以检测测试用例覆盖的代码范围，从而衡量测试质量和查找潜在的漏洞。
文档生成：AST可以用于提取源代码中的注释、类、方法和属性等信息，从而自动生成API文档。
代码安全性分析：通过分析AST，可以识别不安全的代码模式和潜在的安全漏洞，从而提高软件安全性。
代码审查：AST可以帮助自动化检查代码是否符合团队的编程规范和约定，从而提高代码质量和一致性。
依赖关系分析：通过分析AST，可以识别源代码中的模块、类和函数之间的依赖关系，从而理解代码结构和优化代码组织。
自动补全和代码导航：通过分析AST，集成开发环境（IDE）和代码编辑器可以提供自动补全、代码导航、变量重命名等智能功能，从而提高开发者的生产力。
语言扩展和领域特定语言（DSL）：AST可以用于设计和实现领域特定语言，这些语言可以更简洁地表示特定领域的问题和解决方案。例如，通过将DSL转换为目标编程语言的AST，可以生成可执行代码。
三、Python AST Python AST是Python源代码的抽象语法树表示形式。它是Python编译器在解析源代码时生成的一种数据结构，用于表示源代码的语法结构。
Python官方提供的CPython解释器对python源码的处理过程如下：
Parse source code into a parse tree (Parser/pgen.c)Transform parse tree into an Abstract Syntax Tree (Python/ast.c)Transform AST into a Control Flow Graph (Python/compile.c)Emit bytecode based on the Control Flow Graph (Python/compile.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34e797455eae7e12912ba2ca75f248eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58401db4a6c2391416a8ae791055d9dd/" rel="bookmark">
			人工智能如何发展到AIGC？解密一份我四年前写的机器学习分享材料
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正文共：777 字 26 图，预估阅读时间：2 分钟
我第一次参与到人工智能中，还是在H3C的时候，当时H3C搞领航者峰会，准备了一个智能问答机器人——吱吱答。当时的吱吱答，是真的“人工”智能，实现机制就是传统的关键词识别、系统问题匹配等，问了提高准确率，全公司加班加点在知识库录了几千个问题，在某种场景下，准确率比现在的文心一言可能要高一点。
从领域上讲，现在的ChatGPT、文心一言、通义千问、Gemini等，都属于AIGC（Artificial Intelligence Generated Content，人工智能生成内容）领域，而AIGC则属于NLP（Natural Language Processing，自然语言处理）的对话系统分支，通过上下文理解和生成技术，实现了与用户进行智能、连贯和有逻辑的对话交互。再往上翻，自然语言处理和计算机视觉（Computer Vision，CV）都是深度学习（Deep Learning，DL）的重要方向，而深度学习又属于机器学习（Machine Learning，ML），机器学习是人工智能的一个重要分支和实现手段。至此，这个层级关系才算结束。
如果往前回顾一下，我在2020年还简单研究过机器学习，过了4年，可以把当时不成熟的研究成果跟大家分享一下了。
机器学习的思维导图之机器学习的问题。
机器学习项目中的步骤。
机器学习的工作。
机器学习中的数学。
机器学习的资源。
机器学习的定义。
机器学习的基本结构。
机器学习的学科领域。
机器学习的发展过程。
机器学习的发展趋势。
机器学习在互联网搜索。
美国在20世纪80年代就开始研究基于机器学习的汽车自动驾驶技术。
机器学习在画作鉴别。
机器学习在网络安全。
机器学习的分类。
机器学习的常见算法。
常用算法：贝叶斯推理算法。
常用算法：神经网络。
其他常用算法。
机器学习算法的评估与比较。
机器学习算法评估与比较的举例。
机器学习的操作流程。
机器学习的流行开源框架，目前好像是PyTorch、TensorFlow和Keras。
其余的听说的比较少了。
机器学习在SASE自适应微分段的应用。
毕竟大学和研究生要学习好几年的知识，不可能几个月就整明白，期待我接下来的精彩表现吧，争取达到人工智能专业普通本科毕业生的能力水平。
加油！
长按二维码
关注我们吧
成了！Tesla M4+Windows 10+Anaconda+CUDA 11.8+cuDNN+Python 3.11
MX250笔记本安装Pytorch、CUDA和cuDNN
复制成功！GTX1050Ti换版本安装Pytorch、CUDA和cuDNN
CentOS 7.9安装Tesla M4驱动、CUDA和cuDNN
网络之路28：二层链路聚合
Windows Server 2019配置多用户远程桌面登录服务器
Windows Server调整策略实现999999个远程用户用时登录
RDP授权119天不够用？给你的Windows Server续个命吧！
将Juniper虚拟防火墙vSRX导入EVE-NG
配置Juniper虚墙vSRX基于策略的IPsec VPN（CLI方式）
配置Juniper虚墙vSRX基于路由的IPsec VPN（WEB方式）
使用vSRX测试一下IPsec VPN各加密算法的性能差异
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba26a761c7053f5f75164c5d2d0c1047/" rel="bookmark">
			一文掌握android小组件（AppWidget）开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在学习android小组件开发，记之以便日后温习。桌面小组件可以方便使用app的隐藏功能，实现一键触达，提升用户体验。这样可以极大便捷家里的老人使用应用，享受到互联网带来的便捷。最近给家里的老人添加了追剧的小组件，这样她不需要学习怎么搜索、怎么选择，通过桌面小组件便可以快速触达。下面将分别介绍基础小组件开发、列表小组件开发、开发小组件的注意事项。
一、基础小组件的开发 实现android的小组件需要按照一定的范式，主要包括四步，下面将以扫一扫的小组件入口为例分别介绍：
第一步：创建ScanWidgetProvider.java类，继承自android的AppWidgetProvider。小组件的核心逻辑包括点击、展示都在此处。后文会详细介绍。目前此类可以保持空实现。
第二步：在AndroidManifest中配置小组件的receiver，了解android的都知道receiver配置的是广播接收器，难道小组件是一个广播接收器？通过查看AppWidgetProvider的继承类发现，其继承了BroadcastReceiver，所以小组件实际上就是一个广播接收器。
&lt;receiver android:name="com.demo.widget.ScanWidgetProvider" //第一步中创建的小组件类名称 android:exported="true" //此处需要配置true android:label="扫一扫"&gt; //添加引导处展示的标签名称 &lt;meta-data android:name="android.appwidget.provider" //固定格式 android:resource="@xml/widget_scan_resource" /&gt; //配置文件 &lt;intent-filter&gt; &lt;action android:name="android.appwidget.action.APPWIDGET_UPDATE" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 第三步：创建第二步中用到的resource文件widget_scan_resource.xml，创建在res/xml文件下，示例如下。
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android" android:initialLayout="@layout/scan_widget_layout" //布局文件 android:minHeight="110dp" //最小高度 android:minWidth="110dp" //最小宽度 android:previewImage="@drawable/scan_demo_image" //示例图，往往为我们组件的样式图 android:updatePeriodMillis="3600000" /&gt; //更新时间间隔，单位是毫秒， 上述代码需重点介绍minHeight和minWidth。手机将桌面划分成了一个个独立网格，然后桌面内容都展示在网格中，一个应用图标就占一格。小组件在桌面同样展示在网格中，当占一个网格时就是1X1的组件；横向两个网格就是2X1的组件，那么横纵各两个网格自然就是2X2的组件。此处的minHeight和minWidth是指需要占用的网格的总长和宽，常用经验公式计算：（m为横向网格数，n为竖向网格数）
minWidth = 70 x m - 30（dp）
minWidth = 70 x n - 30（dp）
此时你可能不禁会问，如果设置的最小宽高和手机网格的宽高不匹配怎么办。没关系，系统会帮取整找到最近的网格倍数设置给小组件。这也是为什么此参数需要加上min（最小）了。
第四步：创建小组件的布局文件scan_widget_layout.xml
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/ll_widget_scan_guide" android:layout_width="148dp" android:layout_height="148dp"&gt; &lt;RelativeLayout android:layout_width="match_parent" android:layout_height="match_parent" android:background="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba26a761c7053f5f75164c5d2d0c1047/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58ff1a000447612053f5753a801403f5/" rel="bookmark">
			机器学习实战：决策树与随机森林预测心脏病分类问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		决策树是一种流行的机器学习算法，用于分类和回归任务。它通过从数据特征中学习简单的决策规则来构建模型。决策树的核心思想是根据数据特征的不同值将数据集分割成较小的子集，并在每个分割点选择最优的特征。这一过程递归进行，直到达到预设的停止条件，如树达到最大深度或节点中的样本数量低于最小阈值。决策树的可视化非常直观，易于理解，这使得它不仅在机器学习领域受到欢迎，也能够让非专业人士理解模型的决策过程。
随机森林是一种集成学习方法，它通过构建多个决策树并汇总它们的预测结果来提高模型的准确性和鲁棒性。每棵树在训练时使用的是随机选择的数据样本和特征，这种随机性有助于减少模型的过拟合，提高对新数据的泛化能力。随机森林在处理大型数据集时表现出色，且能够有效处理具有高维特征的数据。由于其优异的性能和易用性，随机森林被广泛应用于各种机器学习任务中，包括但不限于分类、回归和特征选择。
本项目的数据集来自UCI机器学习库中的心脏病数据集，它包含了患者的医疗指标以及是否患有心脏病的标签，是研究二分类问题的一个典型例子。这些工具和数据集的结合为心脏病的预测提供了一个实际应用场景，展示了机器学习在医疗健康领域的潜力。（如果需要数据集可以私信我）
在这个项目中，我们使用了几个关键的Python包来处理数据、构建模型以及评估模型性能。首先，pandas库被用于读取数据集、探索数据以及进行数据清洗。matplotlib和seaborn库则用于数据可视化，它们帮助我们通过图表和热力图等形式来理解数据特征之间的关系和分布。scikit-learn是机器学习中使用最广泛的库之一，提供了大量的算法实现和数据处理方法。在本项目中，scikit-learn被用于分割数据集、决策树和随机森林模型的构建、参数优化以及性能评估。使用GridSearchCV，我们能够自动化地搜索模型的最优参数，大大提高了模型调优的效率和准确性。
下面是各个模块的代码：
1. 数据加载与初步探索： 通过pandas库加载心脏病数据集，并使用.info()方法获取数据的基本信息，如列名、数据类型及非空值计数，为后续的数据处理和分析提供初步概览。 import pandas as pd import matplotlib.pyplot as plt import seaborn as sns from sklearn.model_selection import train_test_split, GridSearchCV from sklearn.tree import DecisionTreeClassifier, plot_tree from sklearn.ensemble import RandomForestClassifier from sklearn.metrics import accuracy_score # 加载数据集 df = pd.read_csv('UCI_Heart_Disease_Dataset.csv') # 基本信息 print("\ndf set info:") df.info() 2. 数据可视化： 利用matplotlib和seaborn库绘制相关性热力图和特征分布图，识别不同特征之间的关联性以及单个特征的分布情况，为特征选择和模型建立提供视觉证据。
# 查看不同特征之间的相关关系 plt.figure(figsize=(12,10)) corr = df.corr() sns.heatmap(data=corr, annot=True, square=True, fmt='.2f') plt.show() # 为每个特征绘制分布图 for column in df.columns[:-1]: # 排除目标列 plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58ff1a000447612053f5753a801403f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fddfb81a4de181ccff54fdb7df6e4800/" rel="bookmark">
			用小程序中的uni方法实现uView中的upload组件并将图片上传到腾讯云
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、uni中选择图片的方法与uview中的upload组件选择的不同 功能差异：
uni.chooseImage是uni-app框架提供的原生API，用于选择本地相册或拍照获取图片。uview中的upload组件是一个UI组件，用于上传图片或文件到服务器。 调用方式：
uni.chooseImage需要在代码中主动调用API来触发选择图片的操作。uview的upload组件是一个UI组件，需要在页面中引入并配置参数，然后通过用户交互来触发选择图片的操作。 上传功能：
uni.chooseImage只能选择图片，需要额外编写代码来实现图片上传功能。uview中的upload组件集成了上传功能，可以直接上传选择的图片或文件到服务器。 二、upload的简单使用（详细看uView的官网Upload 上传 | uView - 多平台快速开发的UI框架 - uni-app UI框架 (gitee.io)） &lt;template&gt; &lt;u-upload :action="action" :file-list="fileList" &gt;&lt;/u-upload&gt; &lt;/template&gt; &lt;script&gt; export default { data() { // 演示地址，请勿直接使用 action: 'http://www.example.com/upload', fileList: [ { url: 'http://pics.sc.chinaz.com/files/pic/pic9/201912/hpic1886.jpg', } ] } } &lt;/script&gt; 也可以设置手动上传 &lt;template&gt; &lt;view&gt; &lt;u-upload ref="uUpload" :action="action" :auto-upload="false" &gt;&lt;/u-upload&gt; &lt;u-button @click="submit"&gt;提交&lt;/u-button&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { // 非真实地址 action: 'http://www.example.com/upload', }, methods: { submit() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fddfb81a4de181ccff54fdb7df6e4800/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33cb5ef968ad9d4e97f35b6dd0e7e9d5/" rel="bookmark">
			Python一元和多元线性回归模型的原理及评估【附代码】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.一元线性回归
（1）线性回归模型的定义
（2）一元线性回归的数学原理
（3）一元线性回归的代码实现
1.绘制散点图
2. 引入Scikit-learn库搭建模型
3.模型预测
4.模型可视化
5.线性回归方程构造
（4）案例：不同行业工作年限与收入的线性回归模型
1.案例背景
2.读取数据
3.模型搭建
4.模型可视化
5.线性回归方程构造
6.补充：一元多线性回归
2.线性回归模型评估
（1）模型评估的编程实现
（2）模型评估的数学原理
1.R-squared的理解
2.Adj. R-squared的理解（过拟合与欠拟合）
3.P值的理解
3.多元线性回归
（1）多元线性回归的数学原理和代码实现
（2）案例：客户价值预测模型
1.案例背景
2.读取数据
3.模型搭建
4.线性回归方程构造
5.模型评估
1.一元线性回归 （1）线性回归模型的定义 线性回归模型是利用线性拟合的方式来探寻数据背后的规律，如下图所示，就是通过搭建线性回归模型来寻找这些散点（也称样本点）背后的趋势线（也称回归曲线），而通过这个回归曲线我们就能进行一些简单的预测分析或因果关系分析。
线性回归中，我们根据特征变量（也称自变量）来对反应变量（也称因变量）进行预测，根据特征变量的个数可将线性回归模型分为一元线性回归和多元线性回归。通过一个特征变量：工作年限对收入进行预测，就属于一元线性回归；通过多个特征变量：工作年限、行业、所在城市等对收入进行预测，就属于多元线性回归。这一小节主要先讲解下一元线性回归模型。
（2）一元线性回归的数学原理 一元线性回归模型也称为简单线性回归模型，其形式可以通过如下公式表达：
其中y为因变量，x为自变量，a表示回归系数，b表示截距。其中为实际值，为预测值，一元线性回归的目的就是拟合出一条线来使得预测值和实际值尽可能的接近，如果大部分点都落在拟合出来的线上，那么该线性回归模型则拟合较好。
我们通过两者差值的平方和（该和也称为残差平方和）来进行衡量，公式如下，其中为∑为求和符号。此外，补充说明一句，在机器学习领域，该残差平方和也被称之为回归模型的损失函数。
显然我们希望这个和越小越好，这样实际值和预测值就更加接近，而数学上求最小值的方法为求导数，当导数为0时，该残差平方和最小。那么通过对残差平方和进行求导，然后令其导数为0便可以求得一元线性回归模型的系数a和截距b，这个便是一元线性回归的数学原理，学术上称其为最小二乘法。而在Python中就有专门的库来求解这里的系数a和截距b，而不需要我们去计算复杂的数学公式。
（3）一元线性回归的代码实现 1.绘制散点图 首先通过Matplotlib库先绘制几个散点，代码如下：
X=[[1],[2],[3],[4],[5]] Y=[2,4,6,8] 其中自变量集合X需要写成二维结构形式，也即大列表里包含着小列表，这个其实是符合之后多元回归的逻辑，因为多元回归，一个因变量y可能对应着多个自变量x，比如对于三元线性回归(即有三个特征变量)，此时的自变量集合X就需要写成类似如下形式：
X=[[1,2,3],[2,4,5],[4,6,8],[5,7,9]] 此时的散点如下图所示（附代码）：
import matplotlib.pyplot as plt X = [[1], [2], [4], [5]] Y = [2, 4, 6, 8] plt.scatter(X, Y) plt.show() 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33cb5ef968ad9d4e97f35b6dd0e7e9d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30eda2ae20e81867770bbd45e9f822a3/" rel="bookmark">
			[MySQL报错]关于发生net start mysql 服务无法启动，服务没有报告任何错误的五种解决方案。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		咋直接进入主题。
我遇到的问题是net start mysql 服务无法启动，服务没有报告任何错误
其问题出在哪里呢
一.ini文件配置问题 在于你没有给你下载好的mysql文件中配置.ini文件。
该如何配置呢。那就是先在文件夹中创建一个文本文件，把下面内容复制进去（根据自身下载的mysql文件夹位置改一下）
[mysqld] # 设置3306端口 port=3306 # 设置mysql的安装目录 ----------是你的文件路径------------- basedir=D:\SCHOOLWORK\JavaEE\mysql-8.0.36-winx64 （这里填你的路径） # 设置mysql数据库的数据的存放目录 ---------是你的文件路径data文件夹自行创建 datadir=D:\SCHOOLWORK\JavaEE\mysql-8.0.36-winx64\data （这也是，data不用自己创建） # 允许最大连接数 max_connections=200 # 允许连接失败的次数。 max_connect_errors=10 # 服务端使用的字符集默认为utf8mb4 character-set-server=utf8mb4 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB # 默认使用“mysql_native_password”插件认证 #mysql_native_password authentication_policy=caching_sha2_password [mysql] # 设置mysql客户端默认字符集 default-character-set=utf8mb4 [client] # 设置mysql客户端连接服务端时默认使用的端口 port=3306 default-character-set=utf8mb4 这就是我的存放mysql的路径。（供参考），这里的data文件，刚开始是没有的，不用担心。别自己创建。
如此之后打开命令提示符（用管理员身份打开）
打开后 默认在C盘 （例如我在d:盘）
咱们这么操作
重点流程1：在bin目录下执行命令行 mysqld --initialize --console（出现下面错误就是data包好像有点问题，删了，重试）
箭头指的是你的mysql初始密码。
如果已安装mysql服务，需要先删除该服务 sc delete mysql
安装MySQL服务 mysqld --install mysql
再次尝试启动MySQL服务 net start mysql
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30eda2ae20e81867770bbd45e9f822a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e4505e5c823dea72a6bffa0e7f1c4f1/" rel="bookmark">
			Mac M1电脑使用Homebrew 安装OpenCV
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明：我的 Mac 是 M1 芯片，MacOS Sonoma 14.2.1 版本。
从官网安装 OpenCV Mac 电脑使用 opencv 只能先从官网下载源码，然后手动编译，不像 windows 那样给你一个编译好的版本。新版本只有图标，因此在这里附上图片说明。特别一提，下图中的苹果图标是 IOS 开发环境，不是 MacOS 的。
手动编译还需要下载很多依赖才能顺利完成，根据 opencv 官网的 mac 配置教程，至少得安装 Cmake、python3 等环境。而且下载之后如果使用 Java （我是使用 Java），还得修改配置文件，才能让编译出来的 opencv 中有 jar 包，非常麻烦。
我最后没有使用源码编译的方式，因为官网推荐的教程中也用到了 Homebrew 这个工具。所以我采用 Homebrew 来安装 OpenCV-Java 环境。
这里提一下，正常的用 Idea 加载 OpenCV-Java 环境的思路：
在官网下载源码并且编译完成后，你会在一个特定的文件夹下面找到编译好的 jar 包。比如 windows 版本，你可以提取 exe 文件，在其 opencv/build/java 目录中找到。然后在 Idea 中的 File-&gt;ProjectStructure-&gt;Libraries 中点击+号，选择 Java 并添加这个 jar 包，然后就可以使用 opencv 了。
在 mac 中，cmd + shift + .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e4505e5c823dea72a6bffa0e7f1c4f1/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/479/">«</a>
	<span class="pagination__item pagination__item--current">480/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/481/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>