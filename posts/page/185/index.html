<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f458c6e18b66575301407831d63e9eff/" rel="bookmark">
			数据库课设---酒店管理系统（MySQL、VBNet）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. 知识技术
二. 需求分析
2.1 功能需求
2.2 数据需求
三. 数据流图与数据字典
3.1 数据流图
3.1.1 业务流图
3.1.2 数据流图
3.1.3 关系图
3.2 数据字典
四. 数据库设计 4.1 概念模型设计
4.2 逻辑模型设计
4.3 数据库实现
4.4 导入数据
4.5 视图创建与展示
五. 利用VBNET语言进行页面设计
一. 知识技术 数据库管理系统（DBMS）基础：数据库管理系统是酒店客房管理系统的核心，负责存储、检索、更新和管理客房信息。它提供了数据定义、数据操作和数据控制等功能，确保数据的完整性、安全性和可靠性。关系型数据库理论：关系型数据库是当前应用最广泛的数据库类型之一，它通过表、行和列来组织数据，并使用SQL（结构化查询语言）进行数据操作。关系型数据库具有数据结构化、数据共享性高、数据独立性好等优点，非常适合用于酒店客房管理系统的数据存储。数据库设计原则：数据库设计是酒店客房管理系统开发的关键环节，它涉及到数据的逻辑结构、物理结构以及数据的安全性和完整性等方面。在设计过程中，需要遵循规范化设计原则，确保数据的合理组织和有效存储。 二. 需求分析 2.1 功能需求 本系统实现的功能具体如下：
1、信息管理：可以对于各种信息的查询，个人信息可以查看自己的私人信息，还可以对自己的私人信息进行修改。用户信息查看用户的个人信息，对用户的信息进行增删改查。2、客户信息管理：可以新建客户，输入客户的身份证号码、姓名、性别、和手机号等信息，可以对于客户的信息进行相应的修改。3、客房信息管理：可以在相应的房间类型下面进行添加相应的房间，对相应的房间进行删除， 查看空房以及客房的情况。4、入住和退房管理：客户可以入住相应的类型房型下的空房，然后可以退房，系统自动将相应的订单状态置为失效，入住状态置为己退房，将相应房间的状态置为空房。5、费用管理：管理员、工作人员都可以查看相应的费用信息，管理员有需要时可以对宾馆的收入与支出进行查询或修改。6、价目信息管理：可以查看客房的收费标准，管理员可以对客房价格进行查询与修改，工作人员可以查看客房的价目信息。7、物品信息管理：可以查看客房的物品名称，物品状态是否使用，对物品进行查询。 2.2 数据需求 酒店客房管理系统的数据需求包括如下几点：
1）数据录入和处理的准确性和实时性 数据的输入是否准确是数据处理的前提，错误的输入会导致系统无法正常识别进而导致输出的不正确，从而是系统的工作失去意义。数据的输入来源是手工输入。手工输入要通过系统界面上的安排系统具有容错性。。2）数据的一致性与完整性由于系统的数据是共享的，在不同的客户端中，客房信息是共享数据，所以如何保证这些数据的一致性，是系统必须解决的问题。要解决这一问题，要有后台数据库的支持。 三. 数据流图与数据字典 3.1 数据流图 3.1.1 业务流图 3.1.2 数据流图 3.1.3 关系图 3.2 数据字典 客户表
字段
中文解释
类型
约束
备注
cno
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f458c6e18b66575301407831d63e9eff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/727ebe16a4b4133933e2606bed2f05e7/" rel="bookmark">
			java算法day8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现 strStr() 459.重复的子字符串 实现strStr() 可以说是暴力解。但是里面的处理比一开始自己写的冗余逻辑要好
class Solution { public int strStr(String haystack, String needle) { char[] strh = haystack.toCharArray(); char[] strn = needle.toCharArray(); //优化1.没必要全部扫描完。因为最后一部分如果没有子串长那没有比较的意义，所以用字符串的长度减子串的长度。 //模拟：abcdef , cde //这里取不取等是要自己算一下的。上例看来，i=3是有意义的，所以取等 for (int i = 0; i &lt;= strh.length - strn.length; i++) { int j = 0; //这个条件优化，就是我当时没想到的一个思维，我直接在i的基础上开始用j逐渐+1就可以了。并且两个字符串比较的过程我也包含在里面。这里用while比用if更省事，这是我一开始也没想到的。 while (j &lt; strn.length &amp;&amp; i + j &lt; strh.length &amp;&amp; strh[i + j] == strn[j]) { j++; } //如果这里判断通过了，说明找到子串了。 if (j == strn.length) { return i; } } return -1; } } 重复的子字符串 首先题意是：给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/727ebe16a4b4133933e2606bed2f05e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e8ab6617e3fa3fd69f07677705f7ecf/" rel="bookmark">
			【Java】了解异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初始异常 我们平时应该已经接触过一些 “异常” 了，这里列举一些例子。
算术异常：
数组下标越界异常：
访问空指针异常：
所谓异常指的就是程序在 运行时 出现错误时通知调用者的一种机制。
异常的基本用法 捕获异常 try{
有可能出现异常的语句 ;
}[catch (异常类型 异常对象) {
} ... ]
[finally {
异常的出口
}]
try 代码块中放的是可能出现异常的代码.catch 代码块中放的是出现异常后的处理行为.ﬁnally 代码块中的代码用于处理善后工作, 会在最后执行.其中 catch 和 ﬁnally 都可以根据情况选择加或者不加. 使用处理异常的好处 不处理异常：
我们能够发现若是不处理异常的话程序遇到异常时候就会终止进程。
如果我们想要使程序遇到异常之后还能运行下去就得处理异常。
处理异常：
我们发现, 一旦 try 中出现异常, 那么 try 代码块中的程序就不会继续执行, 而是交给 catch 中的代码来执行. catch 执行完毕会继续往下执行 。
catch 也可以有多个
public class Test1 { public static void main(String[] args) { int[] array = {1,2,3,4}; try{ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e8ab6617e3fa3fd69f07677705f7ecf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8e5ab573ed245f422cacf8d4c8cac46/" rel="bookmark">
			【植物大战僵尸杂交版】获取&#43;存档插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、还记得《植物大战僵尸》吗？二、在哪下载，怎么安装？三、杂交版如何进行存档功能概述 一、还记得《植物大战僵尸》吗？ 最近，一款曾经在15年前风靡一时的经典游戏《植物大战僵尸》似乎迎来了它的"文艺复兴"。这款游戏不仅在玩家群体中重新掀起了热潮，还在社交媒体上引发了广泛的讨论。从微博到小红书，再到虎扑等平台，玩家们分享着他们的游戏经历和心得，让这款游戏再次成为了热点话题。甚至那些曾经沉寂的《植物大战僵尸》相关的社区，如贴吧，也因为这波复兴而变得活跃起来。
然而，这次复兴的并不是玩家们记忆中的官方原版游戏，而是出自一位名叫"潜艇伟伟迷"的游戏博主之手，他自创了一个独特的"杂交版"。这个版本的游戏，通过将《植物大战僵尸》中的不同角色进行重新组合，创造出了全新的物种，并且这些新物种还拥有双重叠加的技能。这种创新不仅让植物和僵尸都获得了新形态和新技能，而且它们的攻击力相比原版有了显著的提升。
尽管杂交版在角色和技能上进行了创新，但它仍然保留了原版游戏的核心玩法机制，这让新老玩家都能够迅速上手，享受到游戏带来的乐趣。这种平衡的创新和保留，使得游戏的吸引力和玩家的游戏体验都得到了极大的提升。
“潜艇伟伟迷"凭借他的创新和才华，被网友们戏称为"当代孟德尔”，这位生物学家以研究植物杂交而闻名。随着杂交版游戏的流行，他的社交媒体账号也迎来了粉丝数量的快速增长，成为了游戏界的一个新星。
二、在哪下载，怎么安装？ 杂交版也出官方下载地址啦https://pvzgame.net/，不用去找什么百度网盘链接，一键直接下载！
安装和游戏中可能遇到的问题作者也在这里详细说明啦。大家遇到直接解决即可。
三、杂交版如何进行存档 在《植物大战僵尸杂交版》的无尽模式中，我们经常会遇到这样的挑战：精心策划并搭配出了一套强大的植物阵容，正准备在战场上一展身手，却突然因为现实生活中的紧急事务需要暂时离开。在这种情况下，如果游戏没有提供存档功能，我们的心血和努力就可能付之东流。
幸运的是，我发现了一个非常实用的插件，可以完美解决这个问题。
功能概述 本软件适用于植物大战僵尸杂交版的【游戏自动存档+存档管理】，
可以在退出游戏返回主菜单时保存游戏进度，
也可以自动在无尽模式进入下一个关卡时自动保存， 并在历史任意关卡的任何时间节点重新切入。
还有备注功能便于管理归档。
觉得不错的可以给作者点个star支持一下。
地址：https://github.com/HNRobert/pvzHE-Archiver
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4602d6ce813a372ad93dfbde3300573/" rel="bookmark">
			数据库的学习（4）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目 1、创建数据表qrade: CREATE TABLE grade( id INT NOT NULL, sex CHAR(1), firstname VARCHAR(20)NOT NULL, lastname VARCHAR(20)NOT NULL, english FLOAT, math FLOAT, chinese FLOAT ); 2、向数据表grade中插入几条数据: (3,'m''Allen''wiiliam',88.0,92.0 95.0), (4,'m','George'，'William"62.058.0,72.0), (5."f''Alice''Davis',89.0,94.0,98.0), (6,'m','Kevin','Miller',77.0,88.0,99.0), (7,'f','Helen','Davis',79.0,83.0,91.0), (8,'m','Andrew','Johnson',81.0,86.0,88.0) 3、查询grade表中的id,firstname,lastname字段 4、查询grade表中id大于4的学生姓名 5、查询grade表中女生的记录 6、查询grade表中english在80到90之间的记录 7、查询grade表中math大于90或者chinese大于90的记录 8、查询grade表中id不是1、3、5、7的记录 9、查询grade表中的性别有哪些 10、查询grade表中的lastname有哪几种 11、求出表中所有记录的条数 12、求出表中英语成绩的80的记录的条数 13、计算所有学生的数学成绩的和 14、计算女生的数学成绩的和 15、计算英语成绩平均分 16、计算男生的英语成绩平均分 17、求出数学成绩的最高分 18、求出男生中的数学最高分 19、按照math成绩的升序进行排列 20、按照sex字段的升序和chinese字段的降序排列 21、查询数据表qrade中的记录，按照sex字段进行分组 22、将grade表按照lastname字段值分组，并计算每个分组中的学生数 23、对grade表按照lastname字段分组，查出math字段和小于100的组 24、查询grade表中的第3到第6条记录 25、查询grade表中男生平均成绩(三科)大于85的记录 二、MySQL语句操作 1、创建数据表qrade:
2、向数据表grade中插入几条数据: (3,'m''Allen''wiiliam',88.0,92.0 95.0)
3、查询grade表中的id,firstname,lastname字段
4、查询grade表中id大于4的学生姓名
5、查询grade表中女生的记录
6、查询grade表中english在80到90之间的记录
7、查询grade表中math大于90或者chinese大于90的记录
8、查询grade表中id不是1、3、5、7的记录
9、查询grade表中的性别有哪些
10、查询grade表中的lastname有哪几种
11、求出表中所有记录的条数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4602d6ce813a372ad93dfbde3300573/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8269d49f38a00d0beb1491abf7833eb8/" rel="bookmark">
			Spark_05 SparkSQL进阶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 本章主要介绍df的高级用法，session对象，数据源和格式。
DataFrame的高级DSL方法 join关联方法 内连接：df1.join(df2,on='关联条件'，how=‘inner’)
左外连接：df1.join(df2,on='关联条件'，how=‘left’)
右外连接：df1.join(df2,on='关联条件'，how=‘right’)
满外连接：df1.join(df2,on='关联条件'，how=‘full’)
示例代码
from pyspark.sql import SparkSession from pyspark.sql.types import * ss=SparkSessio.buider.getOrCreate() sc=ss.sparkContext() rdd1 = sc.parallelize([ [1, 'zhangsan', 20], [2, 'lisi', 20], [3, 'wangwu', 22] ]) rdd2 = sc.parallelize([ [3, 'zhaoliu', 20], [4, 'xiaoming', 21], [5, 'itcast', 22] ]) schema_type = StructType(). \ add('id', IntegerType()). \ add('name', StringType()). \ add('age', IntegerType(), False) # toDF 将二维rdd数据转为dataframe数据 df1 = rdd1.toDF(schema_type) df2 = rdd2.toDF(schema_type) df1.show() df2.show() # 内关联 找关联字段相同的数据 默认join方法时内关联 df_join = df1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8269d49f38a00d0beb1491abf7833eb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7295d852720963ecd19a9e2eefb33a93/" rel="bookmark">
			day01：项目概述，环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 软件开发整体介绍软件开发流程角色分工软件环境 外卖平台项目介绍项目介绍定位功能架构 产品原型技术选型 开发环境搭建整体结构：前后端分离开发前后端混合开发缺点前后端分离开发 前端环境搭建Nginx 后端环境搭建熟悉项目结构使用Git进行版本控制数据库环境搭建 登录功能分析代码特点Nginx反向代理和负载均衡会话跟踪技术方案JWT介绍JWT生成测试JWT校验测试应用jwt令牌登录和校验密码加密 导入接口文档前后端开发流程操作步骤 Swagger介绍使用方式常用注解 软件开发整体介绍 软件开发流程 需求分析：需求规格说明书、产品原型设计：UI设计、数据库设计、接口设计编码：项目代码、单元测试测试：测试用例、测试报告上线运维：软件环境安装、配置
角色分工 项目经理：对整个项目负责，任务分配，把控进度产品经理：进行需求调研，输出需求调研文档、产品原型等UI设计师：根据产品原型输出界面效果图架构师：项目整体架构设计、技术选型等开发工程师：代码实现测试工程师：编写测试用例，输出测试报告运维工程师：软件环境搭建、项目上线
软件环境 开发环境(development)：开发人员在开发阶段使用的环境，一般外部用户无法访问测试环境(testing)：专门给测试人员使用的环境，用于测试项目，一般外部用户无法访问生成环境(production)：即线上环境，正式提供对外服务的环境
外卖平台项目介绍 项目介绍 定位 专门为餐饮企业（餐厅、饭店）定制的一款软件产品
管理端–外卖商家使用
用户端–点餐用户使用
功能架构 体现项目中的业务功能模块
产品原型 用于展示项目的业务功能，一般由产品经理进行设计
管理端
用户端
技术选型 展示项目中使用到的技术框架和中间件等
开发环境搭建 整体结构：前后端分离开发 前后端混合开发缺点 沟通成本高分工不明确不便管理不便维护扩展
前后端分离开发 当前最为主流的开发模式：前后端开发 分开部署运行
特点：解耦，便于管理、维护和扩展
前端环境搭建 前端工程基于Nginx运行
Nginx 介绍：Nginx是一款轻量级的Web服务器/反向代理服务器及电子邮件(IMAP/POP3)代理服务器。
特点：占有内存少，并发能力强，在各大型互联网公司都有非常广泛的使用
官网：https://nginx.org/
启动Nginx：双击nginx.exe即可启动nginx服务，访问端口号为80
注意事项：
Nginx默认占用80端口号，如果80端口号被占用，可以在nginx.conf中修改默认端口号(netstat -ano | findStr 80)修改了nginx.conf配置文件，需要重启nginx服务器(关闭然后再开，可以通过kill nginx.bat结束nginx，然后再次双击nginx.exe) 后端环境搭建 后端工程基于maven进行项目构建，并且进行分模块开发
熟悉项目结构 sky-common子模块存放的是一些公共类，可以供其他模块使用 sky-pojo子模块中存放的是一些entity、dto、vo pojo：plain old java object
sky-server子模块中存放的是 配置文件、配置类、拦截器、controller、service、mapper、启动类等 使用Git进行版本控制 创建Git本地仓库创建Git远程仓库将本地文件推送到Git远程仓库
数据库环境搭建 通过数据库建表语句创建数据库表结构
登录功能 分析代码特点 后端的初始工程中已经实现了登录功能，直接进行前后端联调测试即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7295d852720963ecd19a9e2eefb33a93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f085bc96e43abed7175b51faa886d34/" rel="bookmark">
			【数据结构】链表带环问题分析及顺序表链表对比分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【C语言】链表带环问题分析及顺序表链表对比分析 🔥个人主页：大白的编程日记
🔥专栏：C语言学习之路
文章目录 【C语言】链表带环问题分析及顺序表链表对比分析前言一.顺序表和链表对比1.1顺序表和链表的区别1.2缓存利用率（缓存命中率） 二.链表的带环问题2.1快慢指针2.2证明快慢指针相遇问题2.3快指针的步长2.4环的入口 后言 前言 哈喽，各位小伙伴大家好！由于考试周很久没有更新博客了。今天给大家带来的是链表的带环问题和顺序表链表的对比分析。话不多说，进入正题。向大厂冲锋！
一.顺序表和链表对比 1.1顺序表和链表的区别 顺序表和链表是两种不同的数据结构。他们各有各的优劣。我们就来对比分析一下他们的区别。我们这里用带头双向循环链表和顺序表做对比。
存储空间
顺序表：物理上是连续的。
链表：因为链表是由节点组成，每个节点由指针连接。 所以在逻辑上是连续的，但每个节点都是malloc动态开辟的，在物理空间上不一定连续。
随机访问
顺序表：顺序表可以通过下标来进行随机访问。
链表：链表不支持随机访问，只能从头节点开始遍历寻找节点。
任意位置插入删除
顺序表：如果不是尾插尾删，需要挪动数据。
链表：链表由节点组成，插入或删除只需要修改前后节点的指针指向即可。
扩容
顺序表：空间不够需要扩容。
扩容realloc本身会有消耗且异地扩容消耗不小，2倍扩容可能存在空间浪费。
链表：按需申请释放，需要一个申请一个，不存在扩容，不会浪费空间。 #define _CRT_SECURE_NO_WARNINGS 1 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int main() { int* p = (int*)malloc(4); printf("%p\n", p); int* p1 = (int*)realloc(p, 40); printf("%p", p1); } 异地扩容：
只要空间大一点，基本都是异地扩容。
原地扩容：
应用场景 顺序表和链表的优劣是互补的。
顺序表适合随机访问，不适合中间位置的插入删除。
链表适合任意位置的插入删除，但无法随机访问。
所以如果经常随机访问，但只需要尾插尾删就选择顺序表。
如果不经常随机访问，在中间位置插入删除就选择链表。
具体根据他们的优劣进行选择。
1.2缓存利用率（缓存命中率） 顺序表和链表的区别还有一个就是
顺序表的缓存命中率高。
链表的缓存命中率低。
为什么呢?什么是缓存命中率呢?
内存和硬盘
这是我们计算机的内部的存储结构。
主存也就是我们的内存和硬盘的区别就是
内存的存储空间更小，通常为8G和16G,但速度快。需要带电存储
硬盘存储空间更大，速度慢，但不需要带电存储。
他们的本质是带不带电。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f085bc96e43abed7175b51faa886d34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a726d694fec9a34a90bfbe3c3e78af7/" rel="bookmark">
			【C语言】 —— 编译和链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【C语言】 —— 编译和链接 一、编译环境和运行环境二、翻译环境2.1、 预处理2.2、 编译（1）词法分析（2）语法分析（3）语义分析 2.3、 汇编2.4、链接 三、运行环境 一、编译环境和运行环境 平时我们说写 C语言 代码，写程序，不难发现：其实写出来的都是 t e s t test test. c c c、 t e s t test test. h h h 等源文件和头文件。我们直接打开他们，是可以直接看懂的，这也就说明了他们其实是文本文件。但是计算机是看不懂他们的，计算机只能识别二进制指令，无法对文件中的代码直接执行。这时就需要将 C语言 代码进行处理变成二进制的指令。
而将代码处理成二进制指令正是编译器需要做的事情。
在 ANCI C 的任何一种实现中，存在两个不同的环境:
翻译环境：在这个环境中源代码被转换成可执行的机器指令（二进制指令）执行环境：它用于实际执行代码 二、翻译环境 那翻译环境是怎么将源代码转换为可执行的机器指令的呢？这里我们就得展开讲解一下翻译环境所做的事情
其实翻译环境是由编译和链接两大过程组成，而编译又可以分解成：预处理（有些书也叫预编译）、编译、汇编三个过程。
一个C语言的项目中可能由多个 . c c c 文件一起构建，那多个 . c c c 文件如何生成可执行程序呢？
多个 . c c c 文件单独经过编译器，编译处理生成对应的目标文件。在 W i n d o w s Windows Windows 环境下的目标文件的后缀是 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a726d694fec9a34a90bfbe3c3e78af7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44a1d3727e0e65314961f6722effce0d/" rel="bookmark">
			Tarjan 算法（超详细！！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐在 cnblogs 上阅读
Tarjan 算法 前言 说来惭愧，这个模板仅是绿的算法至今我才学会。
我还记得去年 CSP2023 坐大巴路上拿着书背 Tarjan 的模板。虽然那年没有考连通分量类似的题目。
现在做题遇到了 Tarjan，那么，重学，开写！
另，要想学好此算法的第一件事——膜拜 Tarjan 爷爷。
Tarjan 算法到底是什么 其实广义上有许多算法都是 Tarjan 发明的（大名鼎鼎的 Link-Cut-Tree 正是出自他手），而本文介绍的是可以解决图中强连通分量的算法。
也就是狭义的 Tarjan 算法。
什么是强连通分量 对于一个图 G G G 来说，一个字图中，任意两点都可以彼此到达（存在路径），这个子图就称为图 G G G 的强连通分量。特别地，一个点也是一个强连通分量。
算法思路 Tarjan 是基于 DFS 实现的，走过的边会形成一棵搜索树。可以看作是原图删去一些边留下来而形成的。
看个图吧：
如果我们把抛弃的边分为三个大类，可以分为：
横叉边（红）前向边（蓝）后向边（黄） 上图把抛弃的边画出来就是这样了：
容易发现，能够构成环的只有前向边。而我们所需要得到的连通分量，正需要环。
我们怎么知道 DFS 到什么时候是一条前向边呢？
我们可以在 DFS 过程中给每个点打一个时间戳（实际上就是 DFS 序， dfn[x]=++cnt），如此，当我们遍历某节点的儿子 v v v 时， v v v 是一个已访问过的节点，那么我们找到了后向边。
如何维护？——用两个数组
dfn[i]：储存时间戳。low[i]：储存 i i i 点可以访问到的最高祖先的 dfn 值（因为 DFS 序由小到大，所以储存的数越小、表示 i i i 点访问祖先能力越强）。 特殊地，一个点访问祖先的能力再差，也可以访问到自己。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44a1d3727e0e65314961f6722effce0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3152ce124f75bef2f6cc454766200adf/" rel="bookmark">
			鸿蒙NEXT不再支持安卓这条路真的走的通吗?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 看到高赞又是一片嘲讽，“apk换种打包方式”等等轻松拿几百赞，我也是无语。
国内多家互联网大厂都已经启动HarmonyOS Next应用开发，预计明年正式上线，如今业内很多人都已经知道了。
网络上相关报道也有很多，新浪科技、界面新闻、第一财经等等媒体都报道了：
很多对于鸿蒙乃至菊厂的嘲讽都是拿自媒体当靶子，因为官方和主流媒体的表述一般比较贴近事实
实际上不止美团京东等大厂，据我所知最关键的那几个巨头也都加入了鸿蒙生态开发。
至于题目中问的“鸿蒙5.0不兼容安卓的道路能否走通”，我个人的看法是：
“鸿蒙5.0不再支持安卓”的表述可能不严谨，我个人猜测HarmonyOS Next会有将AOSP放入容器的过渡期。
但就目前态势来看，HarmonyOS Next已经基本确定可以走通，预计明年会见到阶段性成果。
知乎上连篇累牍复读“套壳”、“连哄带蒙”的时候，我一直在关注相关进展。
正好借着这个机会，再梳理一遍我眼中鸿蒙/OpenHarmony的发展历程：
四千字长文，有错漏欢迎指出：
1、鸿蒙/OpenHarmony 1.0——一切的源点 2020年菊厂开源了OpenHarmony 1.0的代码，其中包含了菊厂自研的liteos系统。
一方面，最极端的黑子也得承认，Liteos是菊厂自研的操作系统；
另一方面，liteos终究是面向手表等穿戴产品的轻量级物联网操作系统，支持设备能力和技术复杂度与手机系统有不小的差距。
所谓“菊厂故意混淆概念”、“连哄带蒙”等争议和嘲讽，也基本就从这开始。
但在我看来，Liteos未必是OpenHarmony 1.0最重要的核心，真正关键的点在于：
OpenHarmony 1.0具备与HarmonyOS跨设备通信的能力，并且架构上部分屏蔽了不同系统不同设备的接口。
就我个人观点，就是这看似不起眼的liteos以及跨设备通信能力，是后续一切的起点。
2、鸿蒙2.0/OpenHarmony 2.0——开发工具的起步和“套壳”的尾声 就我个人观察，OpenHarmony 2.0相比1.0上了一个台阶。
OpenHarmony 2.0支持Linux内核，API版本更新到6.0，勉强可以说有一个复杂系统的架子了。
更重要的是，鸿蒙2.0/OpenHarmony 2.0时期，菊厂就已经掏出了自家的开发者套件。
虽然此时OpenHarmony很多工具（尤其是测试调试方面）还不太全，但毫无疑问是迈出了关键的一步。
这件事的重要性，大家想想也都明白：
如果连开发套件都没有，第三方开发者谁会给你开发应用？生态建设也就无从谈起了。
从代码实现的角度看，客观来说OpenHarmony 2.0仍有许多不足：
因为没有沙箱机制、不支持64位Arm、没有硬件GPU渲染……这使得纯血OpenHarmony 2.0主要停留在开发板上，难以成为真正商用的手机系统。
没记错的话，也正是这段时期应用商店上架了一批鸿蒙版应用（汽车之家鸿蒙版等）
这些应用的确是基于鸿蒙的API 6.0代码实现的，理论上可以脱离安卓在其他操作系统独立运行，（实现方式有些类似于微信小程序）。
但就实际层面而言，这些应用在搭载鸿蒙2.0的手机上运行时，应该并没有完全脱离AOSP。
对于什么是“套壳”，不同人有不同定义。
如果以“能否脱离AOSP独立运行复杂应用”作为标准，那么鸿蒙2.0/OpenHarmony 2.0恐怕是最后一个“套壳”的大版本。
可以说，鸿蒙2.0/OpenHarmony 2.0即是开发工具的起步，也是“套壳”的尾声。
3、鸿蒙3.0/OpenHarmony3.0——技术层面的质变 如果说市场层面鸿蒙生态取得质变的关键节点，我认为大概率是预计明年铺开的HarmonyOS Next；
但如果要说技术层面鸿蒙系统的最关键突破，我认为是OpenHarmony3.0。
而且OpenHarmony3.X一直在逐步完善，3.0、3.1、3.2几个版本实际变化都不小。
OpenHarmony3.0时期，鸿蒙系统在代码层面迎来了一系列关键突破：
支持arm64平台, 具备GPU硬件渲染引擎，引入沙箱机制，完善安全补丁……
可以说从这一刻开始，OpenHarmony框架就已经基本完整，具备了复杂操作系统的主要能力，不考虑生态的话已经能满足手机端的需求。
到OpenHarmony3.1时期，不仅开发者套件大幅完善，还带来一个比较显著的变化：
原生应用可以一次开发编译，安装到鸿蒙3.0和openharmony 3.1的开发板上。
开发层面打通后，“一次开发、多端部署”的坑填了不少，我认为长期来看对构建生态意义重大。
奈何当时舆论不怎么关注这事，所以之前我还在知乎发想法，专门提了一句：
我倒是一直在关注这块，openharmony光我…​www.zhihu.com/pin/1631256719857696768
相比之下，这一时期OpenHarmony有一个比较直观的变化更加吸引眼球：
据我了解可能是搞定了很多驱动，OpenHarmony从此可以跑在小米6、一加6T等手机上。
可能是因为比较直观，贴近消费者，B站相关视频一大堆，关注度反而提升了不少……
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3152ce124f75bef2f6cc454766200adf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f56e582963e31b59c10635db4f249fdb/" rel="bookmark">
			MybatisPlus实现插入/修改数据自动设置时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 插入数据时自动设置当前时间，更新数据时自动修改日期为修改时的日期。
使用MybatisPlus的扩展接口MetaObjectHandler
步骤 实现接口
实体类加注解
实现接口 package com.example.vueelementson.common; import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler; import org.apache.ibatis.reflection.MetaObject; import org.springframework.stereotype.Component; import java.util.Date; /** * @BelongsProject: blog-springboot * @BelongsPackage: com.example.vueelementson.common * @Author: Zww * @CreateTime: 2024-07-07 16:38 * @Description: TODO * @Version: 1.0 */ @Component public class ExtraDataHandle implements MetaObjectHandler { @Override public void insertFill(MetaObject metaObject) { // 第一个值填入你要设置的字段名,第二个值为每次自动填充的值 metaObject.setValue("publishTime", new Date()); metaObject.setValue("updateTime", new Date()); } @Override public void updateFill(MetaObject metaObject) { this.setFieldValByName("updateTime", new Date(), metaObject); } } 添加注解 不过这里的Date给到前端是时间戳格式的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f56e582963e31b59c10635db4f249fdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e4fdf00a76e124e4a4d0c769572daea/" rel="bookmark">
			基于springboot &#43; vue3 &#43;遗传算法的智能组卷在线考试系统的设计与开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、项目介绍
1 、项目简介
二、项目实现
1、数据库设计E-R图
2、数据库级联思路
3、Spring Security的认证思路 💡：
三、 页面展示
1. 管理员端
1.1. 登陆页面：
1.2. 管理员主页：
1.3 用戶管理
2. 用户端
2.1. 登陆页面： 2.2. 教师角色：
2.2.1. 主页：
2.2.2. 管理可盲目下属知识点框架：
2.2.3. 管理题目信息：
2.2.4. 发布测验：
2.2.5. 测验结果总览：
2.2.6. 测验结果客观题可视化：
2.2.7. 测验结果主观题相似度对比查看：
2.3. 学生角色：
2.3.1. 主页：
2.3.2. 查看测验信息：
2.3.3. 测验作答页面：
2.3.4. 查看测验历史记录：
2.3.5. 查看历史测验具体作答情况：
四、资源获取
一、项目介绍 1 、项目简介 📖 项目介绍：
本项目以在线考试系统为实现基础，将基于遗传算法的智能组卷模块作为核心内容，展开研究，简单阐述用户管理、科目管理、知识点管理、题库管理、考试管理等基础模块的实现，着重讨论基于遗传算法的智能组卷方式与考试结果可视化分析的设计与实现。
本系统基于Spring Boot框架与MySQL数据库进行实现，适用于大多数浏览器。投入使用后，在一定程度上能提高教师的工作效率，减轻教师在考试组织和安排方面的工作压力，同时全面、直观地了解学生的学习情况，高效评估教学效果，有望实现教考分离，推进教学改革。
【功能】：
- 管理员端🚴：登录地址 💻︎：http://localhost:8080/admin/login
1. 可在首页查看系统统计数据以及近七天登录系统的人次
2. 专业、班级、用户、科目以及问题类型的增删改查
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e4fdf00a76e124e4a4d0c769572daea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4273f1fe8fe215c138278ca3ea459c6/" rel="bookmark">
			时间处理的未来：Java 8全新日期与时间API完全解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、改进背景二、本地日期时间三、时区日期时间四、格式化 一、改进背景 Java 8针对时间处理进行了全面的改进，重新设计了所有日期时间、日历及时区相关的 API。并把它们都统一放置在 java.time 包和子包下。
Java5的不足之处：
非线程安全：java.util.Date 并不是线程安全的，在使用这个类时必须自己处理多线程并发问题。设计不佳 ：日期和日期格式化分布在多个包中，java.util.Date 的默认日期，年是从1900开始，月从 1 开始，日从 0 开始，没有统一性。而且 Date 类也缺少直接操作日期的相关方法。时区处理困难：因为设计不佳，不得不编写大量代码来处理时区问题。 Java8的改进方案：
线程安全：新的日期时间API是线程安全的不仅没有setter方法，而且任何对实例的变更都会返回一个新的实例而保证原来的实例不变。日期修改：新的日期时间API提供了大量的方法，用于修改日期时间的各个部分，并返回一个新的实例。域： 在时区方面，新的日期时间API引入了域这个概念。组合拆分：针对原来复杂的 API 进行重新组合和拆分，分成了好多个类。 二、本地日期时间 LocalDate: 用于表示不含时区的日期，例如：2024-07-06。
import java.time.LocalDate; import java.time.Month; public class LocalDateExample { public static void main(String[] args) { // 获取当前日期 LocalDate today = LocalDate.now(); System.out.println("当前日期: " + today); // 创建指定日期 LocalDate specificDate = LocalDate.of(2024, Month.JULY, 6); System.out.println("指定日期: " + specificDate); // 日期操作示例 LocalDate tomorrow = today.plusDays(1); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4273f1fe8fe215c138278ca3ea459c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/450d55c3aadd0ee11214c0c8b4bc6039/" rel="bookmark">
			基于AOP的数据字典实现：实现前端下拉框的可配置更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：后端小肥肠
创作不易，未经允许严禁转载。
目录
1. 前言
2. 数据字典
2.1. 数据字典简介
2.2. 数据字典如何管理各模块的下拉框
3. 数据字典核心内容解读
3.1. 表结构
3.2. 核心代码 3.2.1. 根据实体类名称获取下属数据字典
3.2.2. 数据字典AOP切面
3.2.2.1. 场景模拟
3.2.2.2. 数据字典交互流程
3.2.2.3. AOP代码
4. 数据字典使用
4.1. 新增Student类对应数据字典值
4.2. 新增学生数据
4.3. 根据id查询学生数据详细信息
5. 结语
6. 参考链接
1. 前言 在现代软件开发中，数据字典作为管理系统常量和配置项的重要工具，其灵活性和可维护性对系统的健壮性起着至关重要的作用。然而，传统的数据字典与业务模块的整合方式往往存在着严重的耦合问题。通常情况下，为了在业务模块中使用数据字典的标签（label），我们不得不在VO类中添加字段，并通过查询数据字典来获取对应的标签值，这种做法不仅增加了代码的复杂性，还使得业务模块与数据字典的耦合度过高，不利于系统的模块化和扩展。
本文将探讨如何利用面向切面编程（AOP）的思想，通过注解的方式实现数据字典与其他业务模块的无侵入性整合。我们将重点关注如何通过AOP技术，使数据字典的值（value）在业务模块中自动转换为其对应的标签（label），从而实现业务逻辑与数据字典的松耦合，为系统的可维护性和拓展性提供新的解决方案。
2. 数据字典 2.1. 数据字典简介 数据字典是软件系统中用于管理常量、配置项或者枚举值的集合。它通常包括标签（label）和值（value）两部分，标签用于展示给用户或者其他系统模块，而值则是实际的业务逻辑中使用的数据标识。我举个例子吧，比如前端下拉框的渲染：
我们来看一下前端代码：
&lt;template&gt; &lt;el-select v-model="value" placeholder="请选择"&gt; &lt;el-option v-for="item in options" :key="item.value" :label="item.label" :value="item.value"&gt; &lt;/el-option&gt; &lt;/el-select&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { options: [{ value: '选项1', label: '黄金糕' }, { value: '选项2', label: '双皮奶' }, { value: '选项3', label: '蚵仔煎' }, { value: '选项4', label: '龙须面' }, { value: '选项5', label: '北京烤鸭' }], value: '' } } } &lt;/script&gt; 从前端代码可看出 下拉框的渲染主要依靠value和label，常规的做法有枚举，或者后端建表后从表中获取，这两种方法都有许多弊端，枚举的话需要开发人员写死在代码中，再来看建表，如果每个下拉框都建表，那就会浪费大量后端资源，采用数据字典，统一管理各个功能模块的下拉框是较优的选择。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/450d55c3aadd0ee11214c0c8b4bc6039/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d0cc1830dbc6ba5774fd030c4db1368/" rel="bookmark">
			【Linux详解】进程等待 | 非阻塞轮询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引入：
为什么？是什么？怎么办
是什么？ 进程等待是指父进程暂停自己的执行，直到某个特定的子进程结束或发生某些特定的事件。
为什么？ 僵尸进程刀枪不入，不可被杀死，存在内存泄露获取进程的执行情况，知道我布置给子进程的任务，它完成的怎么样了–可选 怎么办 wait 函数
#include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; pid_t wait(int* status); 测试：
#include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; int main ( void ) { pid_t id = fork(); if (id == 0) { // child while (1) { printf("我是子进程，我正在运行... Pid: %d\n", getpid()); sleep(1); } } else { printf("我是父进程: pid: %d，我将耐心地等待子进程！\n", getpid()); sleep(20); // 为了便于观察，我们让父进程休眠20s // 苏醒后，父进程执行 wait，耐心地等待子进程 pid_t ret = wait(NULL); // 暂且将status参数设置为NULL if (ret &lt; 0) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d0cc1830dbc6ba5774fd030c4db1368/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2831b694fc3e4d0cc534875719f209fc/" rel="bookmark">
			Spring Boot的无缝衔接：深入解析与实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到 破晓的历程的 博客 ⛺️不负时光，不负己✈️ 🚀The begin🚗点点关注，收藏不迷路🚩 引言 在快速迭代的软件开发环境中，无缝衔接是提升开发效率、降低维护成本、增强系统稳定性的关键。Spring Boot通过其独特的“约定优于配置”原则和丰富的生态系统，为开发者提供了一个高效、简洁的开发平台。本文将深入解析Spring Boot无缝衔接的几大优势，并通过实际案例和深入分析，展示这些优势如何在项目中发挥作用。
1. 简化配置的深度解析 优势细化：
自动配置：Spring Boot通过@SpringBootApplication注解启动自动配置机制，该机制会扫描项目中的依赖和类路径，并根据预设的条件自动配置Bean。例如，当检测到spring-boot-starter-web依赖时，会自动配置Tomcat服务器和Spring MVC。starter POMs：Spring Boot提供了大量的starter POMs，这些POMs已经包含了项目所需的所有依赖和配置。开发者只需在项目中添加相应的starter POM，即可快速集成所需的功能。外部化配置：Spring Boot支持将配置信息存储在外部化配置文件中（如application.properties或application.yml），这使得配置信息更加灵活和易于管理。此外，Spring Boot还提供了多种配置文件的加载顺序和优先级规则，以满足不同场景下的配置需求。 实践案例：
假设你正在开发一个需要连接数据库的Web应用。你可以通过添加spring-boot-starter-data-jpa和数据库驱动的starter POMs来快速集成JPA和数据库连接。Spring Boot会自动配置数据源、JPA供应商（如Hibernate）和事务管理器等Bean，你只需在application.properties或application.yml中配置数据库连接信息即可。
2. 提高开发效率的深入剖析 优势细化：
快速启动：Spring Boot应用启动速度非常快，因为它减少了大量的配置和初始化工作。这使得开发者可以更快地启动和测试应用，从而提高开发效率。热部署：Spring Boot支持热部署（Hot Swap）功能，这意味着开发者可以在不重启应用的情况下，实时更新代码并查看效果。这极大地提高了开发过程中的迭代速度。集成开发环境（IDE）支持：Spring Boot与主流的IDE（如IntelliJ IDEA、Eclipse等）无缝集成，提供了丰富的插件和工具，帮助开发者更加高效地编写、调试和部署应用。 实践案例：
使用Spring Boot DevTools插件，开发者可以在开发过程中享受到热部署的便利。只需在pom.xml中添加spring-boot-devtools依赖，并配置IDE以支持热部署，即可在保存代码更改后自动重新加载应用，无需手动重启。
3. 易于维护的深入解读 优势细化：
清晰的项目结构：Spring Boot鼓励使用标准的项目结构（如Maven或Gradle的标准目录结构），这使得项目更加规范、易于理解和维护。统一的配置管理：通过外部化配置文件和Spring Boot的自动配置机制，项目的配置信息被集中管理，降低了配置错误的风险，并使得配置信息的修改和同步变得更加容易。丰富的监控和诊断工具：Spring Boot提供了Actuator等监控和诊断工具，帮助开发者实时监控应用的运行状态、性能指标和健康状况，从而及时发现并解决问题。 实践案例：
使用Spring Boot Actuator，开发者可以通过暴露的端点（如/health、/info、/metrics等）来查看应用的健康状态、环境信息和性能指标。这些端点提供了丰富的运行时数据，有助于开发者进行故障排查和性能优化。
4. 丰富的生态支持的全面解析 优势细化：
庞大的社区支持：Spring Boot拥有庞大的用户群体和活跃的社区支持。开发者可以在社区中获取最新的技术动态、解决方案和最佳实践。丰富的第三方库和框架集成：Spring Boot与大量的第三方库和框架无缝集成，如MyBatis、Redis、Elasticsearch等。这些集成工作已经由Spring Boot社区完成，并提供了相应的starter POMs和自动配置支持。持续更新和迭代：Spring Boot团队不断更新和迭代产品，引入新的功能和改进，以支持更广泛的应用场景和开发需求。 实践案例：
当你需要在Spring Boot项目中集成Redis作为缓存解决方案时，只需添加spring-boot-starter-data-redis依赖，并遵循Spring Boot的约定进行配置。Spring Boot会自动配置Redis连接工厂、Redis模板等Bean，你只需编写业务代码即可使用Redis进行缓存操作。
1. 简化配置的代码示例 pom.xml中添加依赖
&lt;!-- Spring Boot Web Starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2831b694fc3e4d0cc534875719f209fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7499ece6507b9dd8c6c88d51762f36db/" rel="bookmark">
			为什么要设计DTO类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要使用DTO类，下面以新增员工接口为例来介绍。
新增员工 1.1 需求分析和设计 1.1.1 产品原型 一般在做需求分析时，往往都是对照着产品原型进行分析，因为产品原型比较直观，便于我们理解业务。
后台系统中可以管理员工信息，通过新增员工来添加后台系统用户。
新增员工原型：
当填写完表单信息, 点击"保存"按钮后, 会提交该表单的数据到服务端, 在服务端中需要接受数据, 然后将数据保存至数据库中。
注意事项：
账号必须是唯一的
手机号为合法的11位手机号码
身份证号为合法的18位身份证号码
员工的密码默认为123456
1.1.2 接口设计 1.1.3 表设计 新增员工，其实就是将我们新增页面录入的员工数据插入到employee表。
employee表的结构：
字段名数据类型说明备注idbigint主键自增namevarchar(32)姓名usernamevarchar(32)用户名唯一passwordvarchar(64)密码phonevarchar(11)手机号sexvarchar(2)性别id_numbervarchar(18)身份证号statusInt账号状态1正常 0锁定create_timeDatetime创建时间update_timedatetime最后修改时间create_userbigint创建人idupdate_userbigint最后修改人id 其中，employee表中的status字段已经设置了默认值1，表示状态正常。
1.2 代码开发 1.2.1 设计DTO类 根据新增员工接口设计对应的DTO
前端传递参数列表：
是否可以使用对应的实体类来接收呢？
答案：当 前端提交的数据 和 实体类中对应的属性 差别比较大时，建议 定义DTO来封装前端提交的数据。
由于上述传入参数和实体类有较大差别，所以自定义DTO类。
package com.sky.dto; import lombok.Data; import java.io.Serializable; @Data public class EmployeeDTO implements Serializable { private Long id; private String username; private String name; private String phone; private String sex; private String idNumber; } 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7499ece6507b9dd8c6c88d51762f36db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a30a077d27e85a732f71d297d12c825/" rel="bookmark">
			useImperativeHandle浅谈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		useImperativeHandle 是 React Hooks 提供的一个高级功能，它允许你在函数式组件中自定义并暴露特定的实例值或方法给父组件。主要的作用是：
自定义对外暴露的实例值或方法: 通常情况下，函数式组件内部的实例值或方法对外是不可见的，而 useImperativeHandle 可以让你选择性地暴露一些特定的实例值或方法给外部使用。
优化子组件对外暴露的接口: 通过 useImperativeHandle 可以控制子组件对外暴露的接口，避免过多或不必要的暴露，从而更好地封装组件内部逻辑。
使用方法 在使用 useImperativeHandle 时，通常需要配合 React.forwardRef 使用，因为 useImperativeHandle 是用来定制 ref 对象上暴露的内容。
示例代码如下：
import React, { useRef, useImperativeHandle, forwardRef } from 'react'; // 子组件 const ChildComponent = forwardRef((props, ref) =&gt; { const internalRef = useRef(); // 使用 useImperativeHandle 定制对外暴露的内容 useImperativeHandle(ref, () =&gt; ({ // 这里定义了暴露给父组件的方法或属性 // 例如，暴露一个方法 focus: () =&gt; { internalRef.current.focus(); }, // 或者暴露一个属性 value: internalRef.current.value, })); return &lt;input ref={internalRef} /&gt;; }); // 父组件 const ParentComponent = () =&gt; { const childRef = useRef(); const handleClick = () =&gt; { // 使用子组件暴露的方法 childRef.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a30a077d27e85a732f71d297d12c825/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb6799795da7d85315d5861393afad29/" rel="bookmark">
			工欲善其事必先利其器——Anaconda安装教程（2024版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在数据科学、机器学习、科学计算等领域，Python 因其简洁的语法和强大的库支持而广受欢迎。Anaconda 是一个流行的Python发行版，它包含了大量的科学计算和数据分析库，极大地方便了开发者和研究者的工作。本文将为您提供2024版本的Anaconda安装教程，帮助您快速搭建起Python开发环境。
一、什么是Anaconda？ Anaconda 是一个开源的Python发行版，它预装了许多常用的科学计算和数据分析库，如NumPy、Pandas、SciPy、Matplotlib等。用户也可以通过conda命令轻松地安装、更新和卸载其他库，使得Python的安装和库管理变得简单高效。
Anaconda 集成了Jupyter、Spyder等开发环境，其中jupyter是一个流行的交互式开发环境，非常适合数据分析和可视化。
二、为什么用Anaconda？ 环境管理：Anaconda 允许用户创建隔离的环境，方便不同项目使用不同版本的库。库管理：通过conda，可以轻松安装、更新和管理Python库。社区支持：Anaconda 拥有庞大的用户社区，遇到问题时可以快速获得帮助。跨平台：支持Windows、macOS和Linux系统。 三、如何下载和安装Anaconda? 3.1 下载Anaconda 访问 Anaconda 的官方网站，选择适合您操作系统的版本进行下载，除此之外，您还可以选择通过直接点击Download按钮的方式自动为您的计算机选择适当的安装程序下载。
如果进不去官网，或者下载太慢，您可以在清华大学开源软件镜像站下载：清华大学开源软件镜像站
镜像站页面如下，使用CTRL+F组合键搜索，从中选择适合自己的版本进行下载：
下载完成后的安装包如下图所示
3.2 安装Anaconda 对于Windows用户，下载完成后双击安装程序，按照提示进行安装。对于macOS和Linux用户，下载.sh文件后，在终端运行安装命令。 下面以Win10为例演示安装过程。
在安装过程中，您可以按照默认选项一直点击（next）下一步按钮完成安装，也可以根据需要自定义安装。
第一步，直接点击next即可。
直接点击I Agree。
选择安装的用户对象，这里选择Just Me，然后点击next即可。
选择安装目录，这里为了演示，选择默认安装位置，您也可以点击Browse选择其他目录，这里需要记住安装目录位置，后面配置环境会用到，然后点击next。
到安装选项这一步，全选即可，也可以根据自己的需求勾选，
然后点击Install开始安装。
如果您的电脑已安装Anaconda环境或者python环境，请取消勾选第二个选项。
如果您未安装Anaconda环境，并且忘记勾选第二个选项，请安装完成后移步至环境配置章节。
1.Create shortcuts (supported packages only).
创建快捷方式(仅支持包)。
2.Add Anaconda3 to my PATH environment variable
将Anaconda3添加到我的PATH环境变量
NOT recommended.This can lead to conficts with other applications.
Instead,use the Commmand Prompt and Powershell menus added to the Windows Start Menu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb6799795da7d85315d5861393afad29/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/184/">«</a>
	<span class="pagination__item pagination__item--current">185/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/186/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>