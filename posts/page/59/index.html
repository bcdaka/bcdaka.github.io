<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca7fc54aa6c1432bd88b5f0a962795cb/" rel="bookmark">
			【Java数据结构】---List（ArrayList）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		乐观学习，乐观生活，才能不断前进啊！！！
我的主页：optimistic_chen
我的专栏：c语言 ，Java
欢迎大家访问~
创作不易，大佬们点赞鼓励下吧~
文章目录 前言线性表顺序表（MyArrayList）具体功能代码 ArrayList简介ArrayList的使用ArrayList的遍历ArrayList扩容 练习（洗牌算法）完结 前言 在集合框架中，List是一个接口，继承自Collection
这些方法都是List接口下的方法：
这些是Collection下的方法：
根据这些方法数量我们可以推断，List接口扩展了Collection接口。
由集合框架，直接告知了我们正确的学习顺序，整体由下到上学习。今天先开始我们熟悉的顺序表(ArrayList)的具体内容。
线性表 之前C语言部分也学习过顺序表，我们这里就简单说明。
线性表（linear list）是n个具有相同特性的数据元素的有限序列。 线性表是一种在实际中广泛使用的数据结构，常见的线性表：顺序表、链表、栈、队列…（之后都会学习到）
线性表在逻辑上是线性结构，也就说是连续的一条直线。但是在物理结构上并不一定是连续的，线性表在物理上存储时，通常以数组和链式结构的形式存储。
顺序表（MyArrayList） 顺序表是**用一段物理地址连续的存储单元依次存储数据元素的线性结构**，一般情况下采用数组存储。在数组上完成数据的增删查改
因为ArrayList是集合框架下的一个普通的类，他的增删查改可以由编译器实现。我们要做的就是自主实现这些功能，增强对代码的理解。我们可以把这些功能先定义在一个接口IList中，再通过我们自己的MyArrayList类完成具体代码。
//接口 public interface IList { public void add(int data); public void add(int pos,int data); public boolean contains(int toFind); public int indexOf(int toFind); public int get(int pos); public void set (int pos,int value); public void remove(int toRemove); public int size(); public void clear(); public void display(); } 具体功能代码 增加元素
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca7fc54aa6c1432bd88b5f0a962795cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/199399e2f425503eaeeee2005eaf9d69/" rel="bookmark">
			java之局部内部类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 java中，局部内部类也称为方法内部类，指定义在某个局部范围中的类，它和局部变量都是在方法中定义的，有效范围只限于方法内部。局部内部类可以访问外部类的所有成员和成员方法，在外部类中无法访问局部内部类的变量和方法。
如果外部类要访问内部类的成员，只能在局部内部类的所属方法中创建局部内部类的对象，通过对象访问局部内部类的变量和方法。
示例代码如下
class Waibu{ int m=0; void test1() { System.out.println("外部类成员方法test1()"); } void test2() { class Neibu{ int n=1; void show() { System.out.println("外部类成员变量m="+m); test1(); } } Neibu inner=new Neibu(); System.out.println("局部内部类变量n="+inner.n); inner.show(); } } public class Jubuneibulei { public static void main(String[] args) { // 局部内部类 Waibu outer=new Waibu(); outer.test2(); } } 在这段代码中，首先创建了外部类Waibu，在方法test2中，定义了一个局部内部类
class Neibu{ int n=1; void show() { System.out.println("外部类成员变量m="+m); test1(); } } 通过在类中创建内部类的对象访问局部内部类的变量和方法
Neibu inner=new Neibu(); System.out.println("局部内部类变量n="+inner.n); inner.show(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfe2a3bbacab219e6d01c0e836e8518c/" rel="bookmark">
			Datawhale AI夏令营第四期魔搭- AIGC文生图方向 task01笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
分任务1：跑通baseline
第一步——搭建代码环境
第二步——报名赛事
第三步——在魔搭社区创建PAI实例
分任务2：相关知识学习以及赛题理解
赛题理解：
文生图基本认识：
1. Diffusion Model(扩散模型)
2. LDMs（潜空间扩散模型）
3.基础文生图模型优化的三大方向
4.LORA（Low-Rank Adaptation） ——轻量级大模型微调方法
附：
DataWhale开源组织网站主页：Datawhale
DataWhaleAI夏令营第四期AIGC方向学习手册：Doc
赛事链接：可图Kolors-LoRA风格故事挑战赛_创新应用大赛_天池大赛-阿里云天池的赛制
分任务1：跑通baseline 第一步——搭建代码环境 1. 进入阿里云免费试用区，免费使用算力时：
阿里云社区https://free.aliyun.com/?spm=5176.14066474.J_4683019720.1.8646754cugXKWo&amp;scm=20140722.M_988563._.V_1&amp;productCode=learn
2. 登录or注册自己的阿里云账号：
3. 点击立即试用
领取成功之后关闭页面即可
4 .进入魔搭社区授权
魔搭社区https://www.modelscope.cn/my/mynotebook/authorization
第二步——报名赛事 可图Kolors-LoRA风格故事挑战赛https://tianchi.aliyun.com/competition/entrance/532254
第三步——在魔搭社区创建PAI实例 创建完成之后返回魔搭社区，如下图所示，就已经绑定好实例了：
点击打开，因为我这里点击打开没有反应，索性就使用了第二种方法——魔搭的免费notebook
那么实际上，可能是因为魔搭社区的流量限制，使得访问速度很慢，那么我们也可以通过阿里云官网进入实例，
step1:进入阿里云官网
Step2：进入控制台
step3:左侧栏中有DSW这个选择
step4:在这里点击打开，进入实例，速度比魔搭社区要快
总之，无论是从A,B还是C进入，都是为了进入我们的notebook实例中。
进入notebook之后，要先git下来我们的baseline文件,在哪git呢？？
需要进入我们的终端Terminal
git lfs install git clone https://www.modelscope.cn/datasets/maochase/kolors.git 然后就可以跟着教程一步一步进行baseline的运行了，注意，如果出现运行不成功的情况，可以restart一下。
至于运行，有两种方式，可以选中一个代码块，同时按下ctrl+enter,或者是点击左边的运行键。
运行成功之后左边会出现绿色的小对号，即代表我们运行成功了这个代码块。
这是我运行完全部代码块后，最终的部分效果：
在赛事官网提交相关信息：
魔搭社区-创建模型
分任务2：相关知识学习以及赛题理解 赛题理解： 事实上，我们的赛题作出了以下几点要求：
1 要求基于LoRA模型生成 8 张图片组成连贯故事，故事内容可自定义；基于8图故事，评估LoRA风格的美感度及连贯性
2参赛者可以根据自己审美，任意选择自己喜欢的文生图风格，例如水墨风、国风、日漫风等。3 要求参赛者在赛事官网提交微调后的LoRA 模型文件、LORA 模型的介绍、以及使用该模型生成的至少8张图片和对应 prompt
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfe2a3bbacab219e6d01c0e836e8518c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/490055d5be637c7003277f96435f6d59/" rel="bookmark">
			轻松上手MYSQL：精通正则表达式，数据匹配不再难！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈 个人主页：danci_
🔥 系列专栏：《设计模式》《MYSQL》
💪🏻 制定明确可量化的目标，坚持默默的做事。
✨欢迎加入探索MYSQL正则表达式函数之旅✨
👋 大家好！文本学习和探索MYSQL正则表达式函数。👋 正则表达式，作为数据库查询的利器，在处理复杂数据匹配时无疑是MySQL用户的得力助手。《MySQL正则表达式》将为您揭开这一强大工具的面纱，带您从基础入门，逐步掌握高级技巧。无论是文本搜索、数据筛选还是复杂模式匹配，正则表达式都能为您的查询增添无限可能。准备好探索这一神奇语言了吗？让我们一起进入MySQL正则表达式的世界，发现数据操作的新维度。
目录
一、REGEXP操作符
二、NOT REGEXP操作符
三、RLIKE操作符
四、NOT RLIKE操作符
五、REGEXP_LIKE函数
六、REGEXP_REPLACE函数
七、REGEXP_INSTR函数
八、REGEXP_SUBSTR函数
一、REGEXP操作符 在 MySQL 中， REGEXP 操作符检查一个字符串和一个正则表达式是否匹配。
REGEXP 操作符等同于 RLIKE 操作符和 REGEXP_LIKE() 函数。REGEXP 不区分大小写。
NOT REGEXP 操作符是 REGEXP 操作符的否定操作。
语法：
str REGEXP regexp 参数说明：
str：必需的。一个字符串。regexp：必需的。正则表达式。 返回值：
若字符串 str 和正则表达式 regexp 匹配，返回 1，否则返回 0。若任意一个参数为 NULL，返回 NULL。 这里列出了几个常见的 REGEXP示例：
SELECT 'hello' REGEXP '^[a-z]+$', 'hello' REGEXP '^[A-Z]+$', '12345' REGEXP '[0-9]+$', '12345' REGEXP '^\\d+$', '123ab' REGEXP '^\\d*$', '123ab' REGEXP '^.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/490055d5be637c7003277f96435f6d59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc7ea1b2675e49c999da993c00516c78/" rel="bookmark">
			面试官：MongoDB是什么，它有什么特性与使用场景？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈喽！大家好，我是小奇，一个专给面试官添堵的撑序员
小奇打算以轻松幽默的对话方式来分享一些技术，如果你觉得通过小奇的文章学到了东西，那就给小奇一个赞吧
文章持续更新，可以微信搜索【小奇JAVA面试】第一时间阅读，回复【资料】更有我为大家准备的福利哟！
文章目录 一、前言二、面试三、总结 一、前言 最近在“某奴直聘”上找了一份工作，虽然工资低，但是工作也累啊。但好歹可以提现我的价值了，我的价值就是让老板早日买车买房。。。
人事小姐姐说是日不落工作模式，我想着应该是一种很潮流的工作模式吧。。。
二、面试 面试官：我看你简历上写的精通MongoDB？（面试官鄙夷的看了我一眼）
我：准确来说不是精通，而是登峰造极。
面试官：呵呵、那你先说一说MongoDB是什么吧
我：Mongodb是一款非关系型数据库，它区别于关系型数据库最显著的特征就是没有SQL语句，所存储的数据也没有固定的数据类型
面试官：MongoDB有什么特性呢？
我：MongoDB存储的数据类似于json文档格式。如下。
面试官：MongoDB如何安装使用呢？
1、获取安装包
wget https://fastdl.mongodb.org/linux/mongodb‐linux‐x86_64‐rhel70‐4.4.2.tgz
进行解压 tar ‐xvzf mongodb‐linux‐x86_64‐rhel70‐4.4.2.tgz
添加到系统执行路径下面( ~/.bashrc) export PATH=$PATH:&lt;你机器MongoDB bin目录，如：/usr/local/mongodb/mongodb‐linux‐x86_
64‐rhel70‐4.4.2/bin&gt;
执行 source ~/.bashrc
创建数据目录 mkdir ‐p /data/db # 这个路径是MongoDB默认的数据存放路径
启动MongoDB服务 mongod # 如果你不希望使用的默认数据目录可以通过 添加 ‐‐dbpath 参数指定路径
或者从后台启动
mongod --logpath /data/db/logpath/output --fork
需要指定 --logpath , 或者–syslog
客户端使用( mongo shell, 用来操作MongoDB的javascript客户端界面 )：
6. 连接服务
1 mongo ‐‐host ‐‐port 2 # 如果在本机使用的都是默认参数，也可以直接忽略所有参数
面试官：MongoDB有哪些语法呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc7ea1b2675e49c999da993c00516c78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76e745a8e4119bfd6fef05efff86feaf/" rel="bookmark">
			【MySQL】详解数据库约束、聚合查询和联合查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库约束 约束类型 数据库的约束类型主要包括以下几种：
主键约束（Primary Key Constraint）：确保表中的每一行都有唯一的标识，且不能为NULL。
外键约束（Foreign Key Constraint）：确保表中的数据与另一个表中的数据保持一致性，维护数据之间的关系。
唯一约束（Unique Constraint）：确保字段中的所有值都是唯一的，不允许重复。
检查约束（Check Constraint）：限制某一列中的值符合特定条件，如数值范围、字符串格式等。
非空约束（NOT NULL Constraint）：确保某一列不能包含NULL值，必须有实际数据。
默认约束（Default Constraint）：为字段设置默认值，在插入记录时若未提供该字段的值，则会使用默认值。
这些约束保证了数据库中的数据完整性和一致性，是设计数据库时的重要组成部分。
使用案例 主键约束（Primary Key Constraint）
主键约束用于唯一标识表中的每一行，并确保其值不为NULL。
CREATE TABLE Students ( StudentID INT PRIMARY KEY, StudentName VARCHAR(20) ); 对于整数类型的主键，常配搭自增长auto_increment来使用。插入数据对应字段不给值时，使用最大值+1。
StudentID INT PRIMARY KEY auto_increment,
外键约束（Foreign Key Constraint）
外键约束用于维护不同表之间的关系，确保引用的数据存在。
CREATE TABLE Courses ( CourseID INT PRIMARY KEY, CourseName VARCHAR(100) ); CREATE TABLE Enrollments ( EnrollmentID INT PRIMARY KEY, StudentID INT, CourseID INT, FOREIGN KEY (StudentID) REFERENCES Students(StudentID), FOREIGN KEY (CourseID) REFERENCES Courses(CourseID) ); 唯一约束（Unique Constraint）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76e745a8e4119bfd6fef05efff86feaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14f9c57ae8995fb3f36233003ed4a884/" rel="bookmark">
			JQuery实现地图坐标拾取和地址模糊查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文详细讲解了如何使用 JQuery+HTML+JavaScript 实现移动端页面中的地图位置选取功能。本文逐步展示了如何构建基本的地图页面，如何通过点击地图获取经纬度和地理信息，以及如何实现模糊查询地址并在地图上标注。最后，提供了完整的代码示例，并总结了基于地图API进行地图位置选点的开发过程，帮助开发者快速上手并应用到实际项目中。
一、百度地图API介绍 百度地图API为开发者提供了强大的地理信息服务，可以轻松实现地图显示、位置选取、路线规划等功能。这里主要介绍2.0版本和3.0版本的功能示例，以及路书的介绍。
2.0 API
2.0版本的API功能相对较少，主要用于简单的地图展示和位置标注，以下是一个基本的示例：
var map = new BMap.Map("container"); var point = new BMap.Point(116.404, 39.915); map.centerAndZoom(point, 15); 3.0 API
3.0版本增加了更多的功能和优化，提升了地图加载速度和交互体验，以下是一个展示地图和标注的示例：
var map = new BMap.Map("container"); var point = new BMap.Point(116.404, 39.915); map.centerAndZoom(point, 15); var marker = new BMap.Marker(point); map.addOverlay(marker); 百度路书
路书是百度地图API提供的一种记录和展示路线的功能，可以用来展示旅游路线、出行规划等，以下是一个基本示例：
var driving = new BMap.DrivingRoute(map, { renderOptions: { map: map, autoViewport: true } }); driving.search("起点", "终点"); 本文将采用百度地图3.0 API来实现地图位置选点的功能，包括地图展示、点击地图选点、地理信息转经纬度、位置的模糊查询等。
二、初始化地图页面 首先，创建一个基本的HTML页面，并引入百度地图API：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;点击地图获取地址和经纬度&lt;/title&gt; &lt;meta http-equiv="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14f9c57ae8995fb3f36233003ed4a884/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e15fdb3b4c8f2ea8f58d30d8c1ffa47/" rel="bookmark">
			选择结构程序设计（1/3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
if语句(分支语句)
if语句的基本形式
if...else语句形式
1.基本形式：
2.if...else执行流程图如图
3.存在多个if和else问题
else if语句形式
1.基本形式
2.基本流程图
3.根据时间输出问候语
4.计算分段函数
if的嵌套形式
1.基本形式
2.if嵌套应用
选择性结构设计需要用到一些些条件判断语句，可实现程序功能更加复杂，程序的逻辑性和选择性问题也更加强大。
if语句(分支语句) if语句的基本形式 if语句的一般形式如下：
if（表达式）语句 括号内的表达式就是要进行判断的条件，语句则是执行的对应操作。括号内的表达式为真，就执行后面的语句；括号内的表达式为假，则不会执行后面的语句。例如下面的代码：
if（iNum）printf（“The turevalue”）; 上述代码中，如果iNum的值为真，则执行后面printf语句；反之，则不执行 。
if（age&gt;18）printf("成年"); 上述代码中，首先判断表达式“age&gt;18”是否成立，如果条件成立，那么判断结果是真，执行后面输出语句;反之，不执行。
前面两段代码，if后执行的语句只有一条，如果有两条语句或多条语句，可以使用大括号，使之成为语句块
if (age &gt; 18) { printf("成年\n"); printf("自力更生\n"); } 误区：if语句的括号后一定不要添加英文分号（;）。 if语句的执行流程图如下所示
if...else语句形式 1.基本形式： if (表达式) { 语句块1; } else { 语句块2; } 2.if...else执行流程图如图 注意：注意if 与else的配对情况。else总是与其前面未配对的if进行配对
在if后的括号中判断表达式的结果，如果判断的结果为真值，则执行if后面语句块的内容；如果判断的结果为假值，则执行else后语句块的内容
if（value） { printf("the value is ture"); } else { printf("the value is false"); 下面我们来制作一段程序来判断条件真假
#include&lt;stdio.h&gt; int main() { int iNum; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e15fdb3b4c8f2ea8f58d30d8c1ffa47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7524500c6b248ee6c835ad7278787fb9/" rel="bookmark">
			C:每日一题：字符串左旋
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：实现一个函数，可以实现字符串的左旋
例如：ABCD左旋一个字符就是BCDA；ABCD左旋两个字符就是CDAB；
1、解题思路： 1.确定目标旋转k个字符，我们要获取字符串的长度 len，目的是根据长度来处理 k 可能超出字符串长度的情况；
2.创建一个函数 left 来实现字符串左旋；
3.对k进行取模运算：k%=len，该表达式目的是计算实际旋转次数。假设字符串长度是 5，而要左旋 7 个字符，实际上相当于左旋 7 % 5 = 2 个字符。
4.创建一个临时数组 temp 来存放要左旋的 k 个字符，防止后续移动字符串时数据丢失。
5.使用 strncpy 将字符串前 k 个字符复制到 temp 中，使用 memmove 函数移动字符串，把从第 k 个字符开始的部分向前移动 k 个位置。（等会简单介绍一下函数的使用）
6.使用 strncat 函数将保存在 temp 中的前 k 个字符拼接到移动后的字符串后面，完成左旋操作。
2、知识补充： 注：这里就简单介绍一下用法，能让大家读懂我后面写的代码，后面会专门出一篇文章来介绍这些函数。以下介绍的函数使用都需要加上头文件&lt;string.h&gt;
1、strncpy strncpy是字符串复制函数，作用是将指定数量的字符从源字符串复制到目标字符串。
函数原型：char *strncpy(char *dest, const char *src, size_t n)
dest：目标字符串。src ：源字符串。n ：要复制的最大字符数。 使用：
#include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { char dest[10]; char src[] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7524500c6b248ee6c835ad7278787fb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7022e767b17419e2f6b5783ea05795db/" rel="bookmark">
			DataWhaleX魔搭夏令营第四期AIGC方向task01笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从零入门AI生图原理&amp;实践是Datawhale AI 夏令营（第四期）“AIGC”方向的学习活动，基于魔搭社区“可图Kolors-LoRA风格故事挑战赛”开展的实践学习。
在task01中，我们主要在魔搭社区搭建PAI实例并体验一下baseline~
学习链接：https://linklearner.com/activity/14/10/24
赛题任务 参赛者需在可图Kolors 模型的基础上训练LoRA 模型，生成无限风格，如水墨画风格、水彩风格、赛博朋克风格、日漫风格......
基于LoRA模型生成 8 张图片组成连贯故事，故事内容可自定义；基于8图故事，评估LoRA风格的美感度及连贯性 样例：偶像少女养成日记
速通指南 开通阿里云PAI-DSW试用 链接：https://free.aliyun.com/?productCode=learn
在魔搭社区进行授权 链接：https://www.modelscope.cn/my/mynotebook/authorization
（以上图例来自Datawhale AI 夏令营（第四期）“AIGC”方向的“从零入门AI生图原理&amp;实践”）
报名赛事 赛事链接：https://tianchi.aliyun.com/competition/entrance/532254
在魔搭社区创建PAI实例 链接：https://www.modelscope.cn/my/mynotebook/authorization
（以上图例来自Datawhale AI 夏令营（第四期）“AIGC”方向的“从零入门AI生图原理&amp;实践”）
体验Baseline！ 打开实例
下载文件
在终端中运行以下代码
git lfs install git clone https://www.modelscope.cn/datasets/maochase/kolors.git 进入得到的kolors文件夹，打开baseline文件
安装环境，然后重启kernel
如果想要不同的图片风格，可以依次调整8段prompt来修改图片的描述
依次运行剩余代码
生成的图像在这里
微调结果上传魔搭 移动结果文件 打开terminal（终端）并运行以下代码
mkdir /mnt/workspace/kolors/output &amp; cd cp /mnt/workspace/kolors/models/lightning_logs/version_0/checkpoints/epoch\=0-step\=500.ckpt /mnt/workspace/kolors/output/ cp /mnt/workspace/kolors/1.jpg /mnt/workspace/kolors/output/ 下载结果文件 进入output文件夹，分别下载两个文件到本地
创建并上传模型所需内容 链接：https://www.modelscope.cn/models/create
流程如下：
（以上图例来自Datawhale AI 夏令营（第四期）“AIGC”方向的“从零入门AI生图原理&amp;实践”）
最后记得关闭PAI实例，不然会一直消耗试用额度的
链接：https://www.modelscope.cn/my/mynotebook/authorization
代码详情 以下是Baseline中的代码解释
环境安装 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7022e767b17419e2f6b5783ea05795db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8df5902433952d899a1d4ccaf0f45041/" rel="bookmark">
			MySQL：表的设计原则和聚合函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		所属专栏：MySQL学习
💎1. 表的设计原则 1. 从需求中找到类，类对应到数据库中的实体，实体在数据库中表现为一张一张的表，类中的属性对应着表中的字段
2. 确定类与类的对应关系
3. 使用SQL去创建具体的表
范式：范式描述的是数据关系的模型（一对一关系，一对多关系，多对多关系）
分类：第一范式（1NF），第二范式（2NF），第三范式(3NF)，BC范式（BCNF）
💎2. 三大范式 💎2.1 第一范式 规定：表中的数据不能再分，在定义表的时候，对照数据中的数据类型，每一个字段都可以用一个数据类型标识，那么当前这个表就满足第一范式
例如：定义一个学生表，其中的字段有：学号，姓名，年龄，班级名，学校名，学校地址，这就符合了第一范式，但是如果是：学号，姓名，年龄，班级名，学校，这就不符合第一范式，因为无法找到一个数据类型来表示学校这个对象
关系型数据库的一个最基本的要求，不满足第一范式就不能称为关系型数据库
💎2.2 第二范式 在满足第一范式的基础上，不存在非关键字段（非主键字段）对任意候选键（主键，外键，没有主键时的唯一键）的部分函数依赖（存在与复合主键的情况下），就满足第二范式，复合主键在上一篇文章中已经介绍过，一个表中不能有两个主键，但是一个主键中可以包含多个列，这时的主键就是复合主键
也就是说，如果这个表不含复合主键，那么这个表就满足第二范式
先来看一个表中存在复合主键的情况下，存在非关键字段对候选键的部分函数依赖的不符合第二范式的反例：
学生选修课成绩表 学号姓名年龄课程名称学分成绩202201张三19MySQL3100 其中，年龄和姓名依赖学号（对应唯一学号），学分依赖课程名称，成绩通过学生和课程共同区分，也就是这个表中可以用学生和课程作为复合主键来确定学生当前的课程成绩，对与其他的，学分和学号，学生姓名等没有关系，学生的姓名和课程名等也没有关系
像这样的，对于由两个或多个关键字段共同决定一条记录（存在复合主键）的情况，如果一行数据中有些字段只与关键字段中的一个有关系，那么就称为只存在部分函数依赖，对于这样的情况就不满足第二范式
接下来看一个正面例子：
对于这样的设计，每张表都有非主键字段，都强依赖与主键，第三个表存在的复合主键，非主键依赖于两个主键的字段，不存在部分函数依赖，满足第二范式
不符合第二范式的时候的弊端：
学生选修课成绩表 学号姓名年龄课程名称学分成绩202201张三19MySQL3100202202李四19MySQL3100202203王五20Java2 95
202204赵六19Java296 1. 数据冗余
学生的年龄和学分大量出现，造成数据冗余
2. 更新异常
如果需要修改MySQL的学分，那么就需要修改表中所有关于MySQL的记录，如果说只有部分数据修改成功，剩余的还是原来的数据，就会出现数据不一致，造成数据混乱
3. 插入异常
当前表格在有学生录入成绩后才能查看课程的学分信息，例如：如果说这时学校加入一门新课，但学生都没有考过试，那么这门新课在数据库就就没有记录
4. 删除异常
同插入异常一样，如果需要删除学生成绩，例如，把选Java的两位同学成绩删除，那么此时在数据库中就又没有Java这门课程的学分信息了
💎2.3 第三范式 在第二范式的基础上，不存在非关键字段对任意候选键的传递依赖
学生表 学号姓名年龄所在学院学院地址 在这个表中，描述的主要对象是学生，所以学号可以作为主键，此时，姓名和年龄与学号是强相关的，学院地址与所在学院是强相关的，描述学生所在学院，只需要把学生和学院建立一个关联关系即可，这两个强相关关系存在传递现象 学号-&gt;所在学院-&gt;学院地址 ，这种传递关系就称为传递依赖，所以说这种设计不满足第三范式
根据学生与学院的关系，拆分为两张表就满足了第三范式：
学院表 学院编号学院名称学院地址 学生表 学号姓名年龄学院编号 这样设计，两张表都依赖与自己表中的主键，学生表可以通过外键与学院之间建立关联关系 💎3. 三种关系 💎3.1 一对一关系 例如设计一个登录界面，输入用户名和密码登录成功之后，显示欢迎用户，这样的场景一般对应两个实体，用户和账号，并且一个用户只对应一个账号，就是一对一的关系
针对一对一关系设计表时有两种方式
第一种就是把两个实体所有的信息放在一张表中
use_idnamephone_numberusernamepassword 第二种就是设计两张表，分别记录用户信息和账号信息，再把两张表关联起来
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8df5902433952d899a1d4ccaf0f45041/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dff640293639c2fe2e647c4a981d186/" rel="bookmark">
			【海贼王航海日志：前端技术探索】CSS你了解多少？(三)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 -&gt; 浏览器调试工具——查看CSS属性
1.1 -&gt; 打开浏览器
1.2 -&gt; 标签页含义
1.3 -&gt; elements标签页使用
2 -&gt; 元素的显示模式
2.1 -&gt; 块级元素
2.2 -&gt; 行内元素/内联元素
2.3 -&gt; 改变显示模式
3 -&gt; 盒模型
3.1 -&gt; 边框
3.2 -&gt; 内边距
3.2.1 -&gt; 复合写法
3.3 -&gt; 外边距
3.3.1 -&gt; 复合写法
3.4 -&gt; 块级元素水平居中
4 -&gt; 去除浏览器默认样式
5 -&gt; 弹性布局
6 -&gt; flex布局基本概念
6.1 -&gt; 常用属性
6.1.1 -&gt; justify-content
6.1.2 -&gt; align-items
1 -&gt; 浏览器调试工具——查看CSS属性 1.1 -&gt; 打开浏览器 有两种方式可以打开浏览器调试工具。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dff640293639c2fe2e647c4a981d186/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01c4881ccf831696279344e9c189359f/" rel="bookmark">
			[C&#43;&#43;] 深入理解面向对象编程特性 : 继承
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 继承的概念与定义继承的定义定义格式不同继承方式与继承的基类中访问限定符间的影响C++中的继承和访问控制总结父类的`private`成员在子类中的访问限制`protected`成员的使用场景成员访问方式总结继承方式的默认值实际应用中的继承方式 示例代码 OOP中类之间的关系“is a” 关系“has a” 关系 类模板的继承类模板继承的基本语法访问控制和作用域解析名称查找和依赖名称名称查找和作用域解析示例 父类和子类对象赋值兼容转换子类对象可以赋值给父类对象、父类指针或父类引用父类对象不能赋值给子类对象父类的指针或引用可以通过强制类型转换赋值给子类的指针或引用安全的类型转换强制类型转换 总结 继承中的作⽤域隐藏规则作⽤域相关知识考察 ⼦类的默认成员函数子类的构造函数子类的拷贝构造函数子类的赋值运算符子类的析构函数子类的赋值运算符重载不能被继承的类 继承：友元&amp;静态成员继承与友元继承与静态成员 多继承与菱形继承继承模型单继承多继承多继承中指针偏移问题： 菱形继承 虚继承虚继承的原理虚继承的内存分布注意事项 继承和组合继承（Inheritance）组合（Composition）继承与组合的比较继承与组合的使用原则实例分析示例 1：组合（has-a 关系）示例 2：继承（is-a 关系） 组合与继承的实际应用综合示例 继承的概念与定义 面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。
当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。
继承的定义 定义格式 继承格式：class derived-class: access-specifier base-class
Person是⽗类，也称作基类。Student是⼦类，也称作派⽣类 ：
不同继承方式与继承的基类中访问限定符间的影响 类的继承有三种类型：公有继承（public）、保护继承（protected）和私有继承（private）。C++中的访问限定符有public、protected和private，它们分别控制成员的可访问性。 具体的继承后访问权限如下:
类成员/继承方式public继承protected继承private继承父类的public成员子类的public成员子类的protected成员子类的private成员父类的protected成员子类的protected成员子类的protected成员子类的private成员父类的private成员在子类中不可见在子类中不可见在子类中不可见 C++中的继承和访问控制总结 父类的private成员在子类中的访问限制 父类的private成员在子类中是不可见的。这意味着，虽然子类对象中仍然包含父类的private成员，但语法上子类无法访问这些成员，无论是在子类的内部还是外部。
protected成员的使用场景 父类的private成员在子类中不能被访问。如果需要父类成员在类外不能直接访问，但在子类中能够访问，那么应该将这些成员定义为protected。protected成员限定符主要是为了解决继承中的访问控制问题而出现的。
成员访问方式总结 通过继承方式和父类成员的访问限定符，可以总结出父类的其他成员在子类中的访问方式：
public &gt; protected &gt; private 子类对父类成员的访问权限是取父类成员的访问限定符与继承方式的最小值。
继承方式的默认值 在使用关键字class时，默认的继承方式是private。而使用关键字struct时，默认的继承方式是public。尽管如此，最好显式地写出继承方式以提高代码的可读性。
class Base { private: int privateMember; protected: int protectedMember; public: int publicMember; }; class Derived : public Base { // 继承方式为public，访问权限如下： // privateMember：不可见 // protectedMember：protected // publicMember：public }; 实际应用中的继承方式 在实际应用中，通常使用public继承，很少使用protected或private继承。原因在于protected或private继承的成员只能在子类内部使用，限制了代码的扩展性和可维护性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01c4881ccf831696279344e9c189359f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33f88781dadcfad9759bfef4e8eff719/" rel="bookmark">
			Java语言程序设计——篇十三（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌿🌿🌿跟随博主脚步，从这里开始→博主主页🌿🌿🌿
欢迎大家：这里是我的学习笔记、总结知识的地方，喜欢的话请三连，有问题可以私信🌳🌳🌳
您的点赞👍、关注➕、收藏⭐️、评论📝、私信📧是我最大的支持与鼓舞！！！🌻🌻🌻 输入输出 主要内容Java I/O概述二进制I/O流主要内容1️⃣java.io.File类File类常用方法 2️⃣二进制I/O与文本I/O3️⃣InputStream类和OutputStream类4️⃣常用二进制I/O流文件字节流的应用数据I/O流PrintStream类标准I/O流综合实例 主要内容 1️⃣二进制I/O流
2️⃣ 文本I/O流
3️⃣ 对象序列化：对象I/O流
4️⃣ NIO 和NIO.2：new I/O
5️⃣Files类操作：读写和操作目录和文件。
Java I/O概述 目前Java支持文件I/O和流式I/O。流式I/O分为输入流和输出流。
按照处理数据的类型分，数据流又可分为:
二进制流,也称为字节流。 单位：字节
文本流，也称为字符流。 单位：字符
二进制I/O流 主要内容 ①java.io.File类应用
②二进制I/O与文本I/O
③InputStream类和OutputStream类
④常用二进制I/O流
⑤标准输入/输出流
1️⃣java.io.File类 java.io.File类用来表示物理磁盘上的实际文件或目录，但它不表示文件中数据。绝对文件名是由驱动器字母、完整的路径以及文件名组成，如D:\study\Hello.txt是Windows系统下的一个绝对文件名。相对文件名是相对于当前工作目录的。例如，Hello.txt是一个相对文件名。如果当前工作目录是D:\study，绝对文件名是D:\study\Hello.txt。 File类常用方法 public boolean exists() public long length() public boolean createNewFile() public boolean renameTo(File newName) public boolean delete() public long lastModified() 2️⃣二进制I/O与文本I/O 文件通常可以分为文本文件和二进制文件。使用文本I/O将字符串“123”写入文件，那么每个字符的二进制编码都会写入到文件。
使用二进制I/O向文件写入一个数据，就是将内存中的值复制到文件中。例如，一个byte类型的数值123在内存中表示为0111 1011，将它写入文件也是0111 1011。
3️⃣InputStream类和OutputStream类 InputStream类是二进制输入流的根类，它有多个子类。
public int read() public int read(byte[] b) public void close() OutputStream类是二进制输出流的根类，它有多个子类。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33f88781dadcfad9759bfef4e8eff719/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75613d206e55c9923b8efb2a942482cf/" rel="bookmark">
			Datawhale X 魔搭 AI夏令营第四期 魔搭-AIGC方向 task01笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		赛题内容 参赛者需在可图Kolors 模型的基础上训练LoRA 模型，生成无限风格，如水墨画风格、水彩风格、赛博朋克风格、日漫风格......
基于LoRA模型生成 8 张图片组成连贯故事，故事内容可自定义；基于8图故事，评估LoRA风格的美感度及连贯性
目录
赛题内容
1 OpenAI DALL·E：起于文本，潜入图像，2021.01
1.1 GPT-3 (2020)：基于 transformer 架构的多模态大语言模型
1.2 DALL·E (2021.01)：transformer 架构扩展到计算机视觉领域
1.3 量化“文本-图像”匹配程度：CLIP 模型
1.4 小结
2 Diffusion：高斯去噪，扩散称王，2021.12
2.1 几种图像生成模型：GAN/VAE/Flow-based/Diffusion
2.2 正向图像扩散（forward image diffusion）
2.2.1 基本原理
2.2.2 数学描述
2.3 反向图像扩散（reverse image diffusion）
2.3.1 基本原理
2.3.2 数学表示
2.4 引导扩散（guiding the diffusion）
3 GLIDE：文本引导，定向扩散，2022.04
3.1 架构
3.2 工作原理
3.3 小结
4 DALL·E 2：取长补短，先验称奇，2022.04
4.1 架构：unCLIP = prior + decoder
4.2 The prior
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75613d206e55c9923b8efb2a942482cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dffe689f7771bb6798406094e58dab3d/" rel="bookmark">
			【C&#43;&#43;高阶】：特殊类设计和四种类型转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨ 人生如梦，朝露夕花，宛若泡影 🌏
📃个人主页：island1314
🔥个人专栏：C++学习
⛺️ 欢迎关注：👍点赞 👂🏽留言 😍收藏 💞 💞 💞
特殊类设计和四种类型转换：
1. 特殊类设计
1.1 无法被拷贝的类
1.1.1 C++98的做法：
1.1.2 C++11的做法：
1.2 只能在堆上创建对象的类
1.3 只能在栈上创建对象的类
🍉1.3.1 实现一：
🥝1.3.2 实现二：
1.4 无法被继承的类
1.4.1 C++98的做法：
1.4.2 C++11的做法：
1.5 只能创建一个对象(单例模式)
🍍1.5.1 设计模式：
🍎1.5.2 单例模式：
🌈饿汉模式
🌈懒汉模式
2. 类型转换
2.1 C语言中的类型转换
2.2 C++中的类型转换
🌱2.2.1 static_cast
☘️ 2.2.2 reinterpret_cast
🍀2.2.3 const_cast
🌿2.2.4 dynamic_cast
2.3 为什么C++需要四种类型转换
2.4 RTTI
2.5 扩展
2.5.1 内置类型和自定义类型之间
2.5.2 自定义类型与自定义类型之间
2.6 建议
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dffe689f7771bb6798406094e58dab3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32cfb2ea70b1df2be606d25a17e8f1ad/" rel="bookmark">
			【MySQL基础】非常全面！一文掌握MySQL常用语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 基础命令MYSQL注释方式数据库连接连接数据库退出数据库连接 修改用户密码查询MYSQL版本查看所有数据库使用数据库查看所选择数据库的所有表查看表的具体信息创建数据库查看创建数据库的语句数据表管理创建数据表字段类型数据约束 查看创建数据表的语句查看表的结构修改表修改表名给指定表增加字段修改指定表的字段删除指定表的字段 删除表给表添加外键创建表的时候增加外键给已有表添加外键外键使用建议 INSERT 数据插入语句数据插入一次性插入多条数据把其他表查询到数据插入当前表案例 UPDATE 数据更新语句没有指定匹配条件的话，会所有表的所有记录根据条件来修改记录一次性修改多个字段的值稍微高级一点的使用 WHERE条件常用操作符判空and和or的使用 DELETE 数据删除TRUNCATE 数据表清空SELECT 数据查询语句SELECT语法完整结构查询一个表中的所有数据查询指定字段的数据给字段取别名给表取别名字符串拼接查询结果数据去重查询时增加计算模糊查询连接查询七种连接方式自连接 分页排序子查询（嵌套查询）innot inexistsnot existsin 和 exists 怎么选？ 查询常用函数【数学运算】【字符串函数】【时间和日期函数】【数据库相关】【统计相关】注意事项 分组、过滤集合操作Union（并集）Except（差集）Intersect（交集） 连接查询 索引视图例子创建视图查询视图更新视图 数据加密 source命令执行`.sql`文件的sql语句使用命令行的原因命令行使用流程1、启动mysql2、连接mysql3、看一下有啥数据库4、要sql文件导入到那个数据库，就使用哪个5、导入sql文件6、看我完整操作一遍 Docker安装的MySQL容器如何使用Source 基础命令 MYSQL注释方式 -- 单行注释 /* 多行注释 哈哈哈哈哈 哈哈哈哈 */ 数据库连接 连接数据库 mysql -u root -p12345678 退出数据库连接 使用exit;命令可以退出连接
修改用户密码 查询MYSQL版本 mysql&gt; select version(); +-----------+ | version() | +-----------+ | 8.0.27 | +-----------+ 1 row in set (0.00 sec) 查看所有数据库 show databases; 使用数据库 如果想要操作数据库，需要使用use 数据库名;来选择要操作的数据库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32cfb2ea70b1df2be606d25a17e8f1ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ef5408780739b0482d43c7fce124200/" rel="bookmark">
			模板初阶（详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、泛型编程 为了引出模板，我们来看下面代码，比如要实现不同类型的交换函数，如下：
void Swap(int&amp; a, int&amp; b) { int c = a; a = b; b = c; } void Swap(char&amp; a, char&amp; b) { char c = a; a = b; b = c; } void Swap(double&amp; a, double&amp; b) { double c = a; a = b; b = c; } 这样每个类型交换都需要写一个函数重载，其中代码的重复率很高，只有类型不同而逻辑都一样，写起来也非常的繁琐，那我们能不能写一个通用的函数告诉编译器一个模版让编译器根据不同的类型利用该模版来生成代码呢？这就是本章的主题——模板。
泛型编程：编写与类型无关的通用代码，是代码复用的一种手段。模板是泛型编程的基础。
模板分为函数模板和类模板，接下来我们分别来详细学习。
二、函数模版 函数模板的格式：
template&lt;typename T1, typename T2 , ... ... ,typename Tn&gt;
返回类型 函数名(参数列表){}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ef5408780739b0482d43c7fce124200/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf8dc79b8537ba5382a1e4d8dfb5824e/" rel="bookmark">
			HAProxy理论&#43;实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、基于cookie的会话保持
1、配置选项
2、配置示例
3、验证cookie信息 二、IP透传
1、layer4 与 layer7
（1）四层:IP+PORT转发
（2）七层:协议+内容交换
三、haproxy的ACL应用
1、ACL配置选项
（1）名称
（2）匹配规范
（3）匹配模式
（4）具体操作符
（5）操作对象
2、多个ACL的组合调用方式
（1）多个ACL的逻辑处理
（2）多个ACL调用方式 四、自定义HAProxy错误界面
五、基于HTTP重定向错误页面
六、HAProxy四层负载
七、HAPRoxy https实现
1、证书制作
2、https配置
一、基于cookie的会话保持 cookie value:为当前server指定cookie值，实现基于cookie的会话黏性，相对于基于 source 地址hash 调度算法对客户端的粒度更精准，但同时也加大了haproxy负载，目前此模式使用较少，已经被session共享服务器代替
注意:不支持 tcp mode，使用 http mode
1、配置选项 cookie name [rewrite | insert l prefix ][ indirect ][ nocache ][ postonly ] [preserve ][httponly][secure ][ domain ]*[ maxidle &lt;idle&gt; ][ maxlife ] name cookie的key名称，用于实现持久连接
insert 插入新的cookie,默认不插入cookie
indirect 如果客户端已经有cookie,则不会再发送cookie信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf8dc79b8537ba5382a1e4d8dfb5824e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1615250c280255bea4c84a721ca161e2/" rel="bookmark">
			「MyBatis」数据库相关操作2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎇个人主页
🎇所属专栏：Spring
🎇欢迎点赞收藏加关注哦！
#{} 和 ${} 我们前面都是采用 #{} 对参数进行赋值，实际上也可以用 ${}
客户端发送⼀条 SQL 给服务器后，大致流程如下： 1. 解析语法和语义, 校验SQL语句是否正确 2. 优化SQL语句, 制定执⾏计划 3. 执行并返回结果 一条 SQL如果走上述流程处理, 我们称为即时 SQL #{} 用的是预编译SQL，通过 ? 占位的方式提前编译 SQL（类似 C 语言的 printf 的占位符），然后把参数填充到 SQL 语句中，它还 会根据参数类型自动拼接引号 而 ${} 则是即时 SQL，它直接替换字符，⼀起编译 SQL。如果参数为字符串，需要加上引号 @Mapper public interface UserInfoMapper { @Select("select password from userinfo where username = #{name}") UserInfo queryByName1(String name); @Select("select password from userinfo where username = '${name}'") UserInfo queryByName2(String name); } @SpringBootTest class UserInfoMapperTest { @Autowired private UserInfoMapper userInfoMapper; @Test void queryByName1() { userInfoMapper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1615250c280255bea4c84a721ca161e2/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/58/">«</a>
	<span class="pagination__item pagination__item--current">59/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/60/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>