<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/587c0e522a633ecf98442a38010cf3a5/" rel="bookmark">
			[MySQL] MySQL中的数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在MySQL中，数据类型用于定义表中列的数据的类型。在前面的几篇文章中，我们也会看到有很多的数据类型，例如：char、varchar、date、int等等。本篇文章会对常见的数据类型进行详细讲解。希望会对你有所帮助！
文章目录
一、常见的数据类型及分类
二、数值类型
2、1 整型
2、1、1 tinyint
2、1、2 bit
2、2 浮点型
2、2、1 float
2、2、2 decimal
三、字符串类型
3、1 char
3、2 varchar
3、3 char 和 varchar 比较
四、日期与时间类型
五、枚举与集合类型
5、1 enum
5、2 set
5、3 查找
🙋‍♂️ 作者：@Ggggggtm 🙋‍♂️
👀 专栏：MySQL 👀
💥 标题：MySQL中的数据类型💥
❣️ 寄语：与其忙着诉苦，不如低头赶路，奋路前行，终将遇到一番好风景 ❣️
一、常见的数据类型及分类 我们先来看一下MySQL中大体上都会有哪些数据类型。具体如下图：
其中上述的是值类型包含了整型和浮点型，文本、二进制类型主要是字符串类型。下面我们在具体分类描述一下：
整数类型（Integer Types）：
TINYINT：范围为-128到127或0到255（无符号），用于存储较小的整数值，如存储性别或状态信息。SMALLINT：范围为-32768到32767或0到65535（无符号），用于存储较小的整数值，如存储年龄或计数值。MEDIUMINT：范围为-8388608到8388607或0到16777215（无符号），适用于中等大小的整数值存储。INT：范围为-2147483648到2147483647或0到4294967295（无符号），适用于一般整数值存储。BIGINT：范围为-9223372036854775808到9223372036854775807或0到18446744073709551615（无符号），用于存储大整数值，如存储ID或计数值。 浮点数类型（Floating-Point Types）：
FLOAT：用于存储单精度浮点数，约占用4个字节的空间。DOUBLE：用于存储双精度浮点数，约占用8个字节的空间。DECIMAL：用于精确的十进制数值存储，适用于货币或其他需要精确计算的场景。 日期与时间类型（Date and Time Types）：
DATE：用于存储日期，格式为'YYYY-MM-DD'，如'2023-11-13'。TIME：用于存储时间，格式为'HH:MM:SS'，如'12:30:00'。DATETIME：用于存储日期和时间，格式为'YYYY-MM-DD HH:MM:SS'，如'2023-11-13 12:30:00'。 字符串类型（String Types）：
CHAR：用于存储固定长度的字符串，如CHAR(10)可以存储长度为10的字符串。VARCHAR：用于存储可变长度的字符串，如VARCHAR(255)可以存储长度最大为255的字符串。TEXT：用于存储较长的文本数据，例如文章内容或备注信息。 枚举和集合类型：
枚举（ENUM）类型： 枚举类型允许您从一组预定义的选项中选择一个单独的值。在创建表结构时，你可以指定枚举类型的字段允许的值列表集合（SET）类型： 集合类型允许您从一组预定义的选项中选择多个值，这些值之间使用逗号分隔。与枚举类型不同，集合类型允许您选择多个选项，而不仅限于一项。 其他类型：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/587c0e522a633ecf98442a38010cf3a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afc8eeaf7f10fe786c5fbca35feea1d1/" rel="bookmark">
			Unity与原生交互之AndroidStudio篇——Unity导出Android工程，导入AndroidStudio打包APK全流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.Unity导出Android工程: unityLibrary: unity的功能库模块 , android工程用到的重要文件夹
launcher: unity的启动器模块，包含很少的java代码
二.AS打开unity android工程 直接Open unity导出的整个android项目，Launcher模块作为app启动模块
三.AS集成unityLibrary(推荐) 方式：Import Library Module 1.AS先New一个空项目： Empty Activity 不能选择Language,默认为Kotlin语言
Empty Views Activity 可以选择Language （新版本推荐）
包名不用跟Unity的包名相同
删除多余的Test库
2.导入 unityLibriry模块 2.1 Import unityLibriry模块
*等待编译后会出现报错：
解决方式：在工程级的gradle.properties文件中添加 unityStreamingAssets=.unity3d 后点右上角Try Again
*若出现如下错误
解决方式：打开unityLibrary下的build.gradle文件，添加如下代码，点击Try Again
android { namespace 'com.android.library' } 2.2 将unityLibrary模块加入到主工程app模块的module依赖 然后打开file/Project Structure - Dependencies - 选择app - 点击右侧的+号 -
选择Module Dependency 勾选unityLibrary - 点击OK
2.3 修改unityLibrary下的build.gradle文件内容： 把 implementation 改为 api ，点击sync
2.4 修改主工程级的setting.gradle文件内容，点击sync project(':unityLibrary').
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afc8eeaf7f10fe786c5fbca35feea1d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00ac99344688011a7d3c24fc368f1367/" rel="bookmark">
			【工程实践】np.loadtxt()读取数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 机器学习中可使用np.loadtxt()可以高效的导入数据，np.loadtxt()适合.txt文件和.csv文件。但是它默认读取float类型的值。
1.np.loadtxt()读取txt文件 1-1 基础参数 numpy.loadtxt( fname, dtype=, comments='#', delimiter=None, converters=None, skiprows=0, usecols=None, unpack=False, ndmin=0) 1-2 参数详解 fname要读取的文件、文件名、或生成器。
dtype数据类型，默认float。
comments注释。
delimiter分隔符，默认是空格。
skiprows跳过前几行读取，默认是0，必须是int整型。
usecols要读取哪些列，0是第一列。例如，usecols = （1,4,5）将提取第2，第5和第6列。默认读取所有列。
unpack如果为True，将分列读取。
1-3 应用示例 文件的存储路径为:'./data.txt'， 文件内容如下：
1-3-1 fname fname可以是文件的路径也可以是要读取的文件。 #根据文件名直接读取 data = np.loadtxt('./data/data.csv') 1-3-2 dtype dtype默认为np.float32类型，也可以设置为其他类型，比如int。设置为其他dtype时需要考虑数据本身的类型。
#设置dtype data = np.loadtxt('./data/data.csv',dtype=np.float32) #设置dtype data = np.loadtxt('./data/data.csv',dtype=int) 1-3-3 comments comment的是指, 如果行的开头为comment的值，那在读取时就会跳过该行。示例代码中comment = '1',则在读取数据时，会跳过开头为1的行。
data = np.loadtxt('./data.txt',dtype = int,comments='1') 1-3-4 delimiter delimiter是分隔符，默认是空格。
data = np.loadtxt('./data.txt',dtype = int,comments='1',delimiter=' ') 我们改变一下数据，将数据中的分隔符改为','之后再重新读取。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00ac99344688011a7d3c24fc368f1367/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a23fb9949a703dc585efbc21b599acf1/" rel="bookmark">
			Java 算法篇-深入了解单链表的反转（实现：用 5 种方式来具体实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥博客主页： 小扳_-CSDN博客
❤感谢大家点赞👍收藏⭐评论✍ 文章目录
1.0 单链表的反转说明
2.0 单链表的创建
3.0 实现单链表反转的五种方法
3.1 实现单链表反转 - 循环复制（迭代法）
3.2 实现单链表反转 - 头插法
3.3 实现单链表反转 - 递归法
3.4 实现单链表反转 - 三指针法
3.5 实现单链表反转 - 第二种头插法
4.0 实现单链表反转的五种完整代码
1.0 单链表的反转说明 单链表的反转是指将链表中的节点顺序逆转，即原先的链表尾部变成了头部，头部变成了尾部。比如，[1,2,3,4,5,6,7] 将这个链表的值反转得到的结果为：[7,6,5,4,3,2,1]，需要注意的是，可以用值打印出来会更好观察链表反转后的结果。
2.0 单链表的创建 具体的创建思路：首先要把节点进行封装成单独的类，该类中的成员包括：int value 存放值，Node next 引用下一个节点。由于该节点类为链表中的一个组成部分，因此，将该类设为静态内部类，外部类的成员为哨兵节点。
代码如下：
import java.util.Iterator; public class Linked implements Iterable&lt;Integer&gt;{ private final Node hand; private int size; static class Node { public int value; public Node next; public Node(int value, Node next) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a23fb9949a703dc585efbc21b599acf1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e52c27a21296c60979006551a8ee022/" rel="bookmark">
			Java的XWPFTemplate工具类导出word.docx的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		依赖 &lt;!-- word导出 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.deepoove&lt;/groupId&gt; &lt;artifactId&gt;poi-tl&lt;/artifactId&gt; &lt;version&gt;1.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 上面需要的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;4.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml-schemas&lt;/artifactId&gt; &lt;version&gt;4.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;4.1.2&lt;/version&gt; &lt;/dependency&gt; 代码
基础语法 public void aaa() { String filePath = "D:\\test\\巡查日志.docx"; XWPFTemplate template = XWPFTemplate.compile(filePath); // 填充数据 Map&lt;String, Object&gt; data = new HashMap&lt;&gt;(); data.put("inspectionTime", "(1)第一行\n(2)第二行"); data.put("deptName", 123); // 读取本地磁盘图片 data.put("weChatPicture", new PictureRenderData(100, 100, "C:\\Users\\Administrator\\Pictures\\16194037861239194.jpg")); // 通过url读取网络图片 data.put("picture", new PictureRenderData(200, 400, ".png", BytePictureUtils.getUrlByteArray("https://res.wx.qq.com/a/wx_fed/weixin_portal/res/static/img/1EtCRvm.png"))); template.render(data); File file = new File("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e52c27a21296c60979006551a8ee022/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d4fdff5f2edf3974f5da6f066099afc/" rel="bookmark">
			Flink SQL -- CheckPoint
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、开启CheckPoint checkpoint可以定时将flink任务的状态持久化到hdfs中，任务执行失败重启可以保证中间结果不丢失
# 修改flink配置文件 vim flink-conf.yaml # checkppint 间隔时间 execution.checkpointing.interval: 1min # 任务手动取消时保存checkpoint execution.checkpointing.externalized-checkpoint-retention: RETAIN_ON_CANCELLATION # 同时允许1个checkpoint执行 execution.checkpointing.max-concurrent-checkpoints: 1 execution.checkpointing.min-pause: 0 # 数据处理的语义 execution.checkpointing.mode: EXACTLY_ONCE # checkpoint超时时间 execution.checkpointing.timeout: 10min execution.checkpointing.tolerable-failed-checkpoints: 0 execution.checkpointing.unaligned: false # 状态后端（保存状态的位置，hashmap：内存） state.backend: hashmap # checkpoint路径 state.checkpoints.dir: hdfs://master:9000/flink/checkpoint 2、编写一个Flnik SQL 脚本： vim word_count.sql -- 实时从kafka中读取单词，统计单词的数量，将结果保存到mysql中 -- 1、创建source表 CREATE TABLE words ( word STRING ) WITH ( 'connector' = 'kafka', 'topic' = 'words', -- 数据的topic 'properties.bootstrap.servers' = 'master:9092,node1:9092,node2:9092', -- broker 列表 'properties.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d4fdff5f2edf3974f5da6f066099afc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2607b035cbb0b8da739583e5cbd45e5/" rel="bookmark">
			【MySQL】事务(中)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 事务异常与产出结论手动提交 和自动提交 对 回滚的区别 事务隔离性理论如何理解隔离性？MySQL的隔离级别事务隔离级别的查看设置隔离级别 事务异常与产出结论 在没有启动事务之前，account表中存在孙权和刘备的数据
在启动事务后， 向 account表中 插入 曹操数据
输入 CTRL \ 终端1中的客户端 崩溃掉
此时在终端2中 查看 表中数据，发现启动事务后插入的曹操数据没有了
说明客户端崩溃，MySQL会自动回滚
手动提交 和自动提交 对 回滚的区别 输入 set autocommit=0 将提交方式改变
再输入 show variables like ‘autocommit’ 查询当前提交方式
OFF 表示 将 自动提交关闭
启动事务之前，account表中 有两个数据
启动事务之后，删除表中曹操的数据
在客户端崩溃后，再次查询 发现 数据会 进行了回滚，将曹操的数据恢复回来了
输入 show variables like ‘autocommit’ 查询提交方式
ON 表示 将 自动提交打开
在启动事务之前，account表中 存在 孙权 刘备 赵六 三个数据
在启动事务之后，删除 对应的赵六的数据
若此时客户端崩溃，则 刘备数据直接丢失了
所以 autocommit 的 提交方式 是会 影响 单个sql的(由于单个sql 也可看作事务，所以就会可以看作影响事务)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2607b035cbb0b8da739583e5cbd45e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50d3aa2e9e36699a9382c2be57a24d73/" rel="bookmark">
			StableDiffusion(四)——高清修复与放大算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、高清修复与放大算法
1.高清修复
①文生图
②图生图
2.SD放大（SD Upscale）
3.附加功能放大
4.总结
一、高清修复与放大算法 1.高清修复 概念：分两步，第一步生成低分辨率的图画，第二步使用它指定的高清算法，生成一个高分辨率的版本，在不改变构图的情况下丰富细节
①文生图 高清修复参数：
放大倍数：是指放大到原图的多少倍，也可以按照参数后面手动设置新图像的宽和高重绘幅度：是和原图的差异度，一般推荐0.5，安全放大区间0.3-0.5，具有自由度区间0.5-0.7高清采样次数：和采样迭代数一样，不用选择，保持默认0的迭代次数放大算法：概念比较复杂，几乎所有的算法出来的结果都是一致的，网上推荐无脑选择R-ESRGAN 4x+ 的，二次元的选择R-ESRGAN4x+ Anime6B,效果相较于其他算法是好一点的 ②图生图 在图库浏览器里，浏览已经做好的图片，选择信息栏的图生图，他会把你这个图片的所有信息同步到图生图里面，你只需要改变分辨率，控制重绘幅度就可以啦（PS：图片浏览器需要自己下载，我后面内容会有写到）在设置选项的放大功能下可以自行定义用于放大图像的算法，选择完之后记得保存，这里选择的算法还是我们文生图推荐的那两个算法 2.SD放大（SD Upscale） 概念：根据指定的放大倍数，将图生图的图像拆解成若干小块按照固定逻辑重绘，再合并成一张大图，可以实现在低显存的条件下生成大尺寸的图片
选择”脚本“选项的SD放大脚本
缩放系数：相当于放大倍数，设置为2的意思是放大为原来的两倍
放大算法：我们还是默认选择R-ESRGAN 4x+ 的，二次元的选择R-ESRGAN4x+ Anime6B
图块重叠的像素：维持默认的64像素不变，是为了避免图片分块重画拼合的割裂的感觉（如下图），64是一个缓冲带的作用，为了分块画的画，画的更好，如果你觉得图片还是拼接的生硬，你可以把重叠像素改成128
注意：这时候要手动更改图片的尺寸，本身你的尺寸是600*600这时候要加上图块重叠像素，你要改成664*664（同理，重叠像素是128的话图片尺寸就要改成728*728）
对于缺点解决方法：增加缓冲带，重绘幅度降低为0.4
3.附加功能放大 概念：利用各种放大算法啊，在图像生成后再对它进行单独处理，使之拥有更高的分辨率尺寸
可以把已经绘制好的图片上传在附加功能下，也可以在图片浏览器显示的图片信息下面直接选择”附加功能”选项
在附加功能里面，可以看到以下设置，特点是有两个放大算法选择，可以给第二个算法选择权重，当然也可以不选择第二个算法，其他参数默认不变
4.总结 文生图：高清修复
图生图：SD放大
生成后处理：附加功能
“打回重画，再来一幅”
”分几块画，拼在一起“
”简单放大，随时可用“
分两步，第一步生成低分辨率的图画，第二步使用它指定的高清算法，生成一个高分辨率的版本，在不改变构图的情况下丰富细节
根据指定的放大倍数，将图生图的图像拆解成若干小块按照固定逻辑重绘，再合并成一张大图，可以实现在低显存的条件下生成大尺寸的图片
利用各种放大算法啊，在图像生成后再对它进行单独处理，使之拥有更高的分辨率尺寸
优势：
不会改变画面的构图（因为随机种子固定）稳定克服多人、多头有分辨率产生的问题操作简便、清晰、直观 优势：
可以突破内存限制获得更大分辨率画面精细度更高，对于细节的丰富更加出色 优势：
使用方便，操作简单，随时可以调用计算速度快，没有重绘压力完全不改变图片内容 缺点：
仍然受到最大显存的影响计算速度相对较慢偶尔”加戏“，出现莫名其妙的额外元素 缺点：
分割重乎的过程不可控（语义误导格分界线割裂）操作繁琐且相对不直观偶尔加戏，出现莫名的额外元素对于缺点解决方法：增加缓冲带，重绘幅度降低为0.4
缺点：
放大功能的效果不太显著
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40d44ea825504fbd97c8561fac810777/" rel="bookmark">
			Java、SpringBoot实现对Excel内容的读取并将Excel内容导入到数据库中（后端篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、需要读取的Excel表格格式相对完整工整，且只需要写入一张表中 在读取Excel表格的需求中，有像下图的这么一种表格，它的格式工整，且表格中的列名和数据库表中的列名一一对应，如下图：
Excel表：
数据库表：
此时就需要用到下面的方法。
1、引入依赖 &lt;!--解析excel--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.13.0&lt;/version&gt; &lt;!-- 请根据你的需求使用合适的版本 --&gt; &lt;/dependency&gt; 2、创建实体类 @Data @TableName("test") public class TestDto { @ExcelImport("id") private String id; @ExcelImport("username") private String username; @ExcelImport("password") private String password; } 3、导入Excel相关的工具类 创建exceIUtil包，并导入ExcelClassField、ExcelExport、ExcelImport和ExcelUtils工具类。
4、创建Mapper接口 public interface TestMapper extends BaseMapper&lt;TestDto&gt; { } 5、创建Service接口及它的实现类 public interface TestService extends IService&lt;TestDto&gt; { void add(TestDto testDto); } public class TestServiceImpl extends ServiceImpl&lt;TestMapper, TestDto&gt; implements TestService { public void add(TestDto testDto) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40d44ea825504fbd97c8561fac810777/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/824b515c293a3d58f03241450d25d475/" rel="bookmark">
			No toolchains found in the NDK toolchains folder for ABI with prefix: arm-linux-androideabi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.我们在跑新工程的时候，在编译的时候，会有一下fail错误提示：
No toolchains found in the NDK toolchains folder for ABI with prefix: arm-linux-androideabi 参数这个问题是因为ndk的版本和build不匹配导致的。
常见的就是要动态指定ndk的版本即可，配置如下：
1.该错误是因为NDK工具导致的。我们可以在build的文件中指定配置一下即可。
No toolchains found in the NDK toolchains folder for ABI with prefix: arm-linux-androideabi_linux 新增： ndkVersion ‘22.1.7171670’
2.另外也可以在sdk-&gt;ndk-bundle-&gt;toolchains下增加缺少的插件。
首先从https://developer.android.google.cn/ndk/downloads?hl=zh-cn下载最新的ndk版本，解压后从中找到缺少的文件夹，然后复制到本地的目录下即可。
推荐使用第一种方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63c69bb5a0e56a20e821d6f8062827b3/" rel="bookmark">
			编译版本问题androidx.appcompat:appcompat-resources 引用错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据错误消息的内容，可以看出这个错误是由于你的项目依赖库中的 androidx.appcompat:appcompat-resources 版本与你的 compileSdkVersion 不兼容引起的。
错误信息显示，依赖库 androidx.appcompat:appcompat-resources 的 AAR metadata 文件中指定的最小编译版本（minCompileSdk）为 33，而你的项目的 compileSdkVersion 为 android-30。由于两者不匹配，导致构建失败。
要解决这个问题，有几种可能的方法：
更新你的项目的 compileSdkVersion 至 33，以与依赖库的要求保持一致。你可以在项目的 build.gradle 文件中修改如下配置：
android { compileSdkVersion 33 // 其他配置... } 更新 androidx.appcompat:appcompat-resources 的版本，选择一个与你项目的 compileSdkVersion 兼容的版本。你可以在项目的 dependencies 中指定更低版本的依赖库，例如： dependencies { implementation 'androidx.appcompat:appcompat-resources:1.4.0' // 其他依赖... } 如果你确实需要使用 androidx.appcompat:appcompat-resources 的最新版本，那么你可能需要等待该库更新，并提供对较低 compileSdkVersion 的兼容性。在等待期间，你可以暂时选择其他可行的库或等待官方修复。
2023/11/13 14:58:43 &gt; Task :app:checkDebugAarMetadata FAILED Execution failed for task ':app:checkDebugAarMetadata'. &gt; A failure occurred while executing com.android.build.gradle.internal.tasks.CheckAarMetadataWorkAction &gt; The minCompileSdk (33) specified in a dependency's AAR metadata (META-INF/com/android/build/gradle/aar-metadata.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63c69bb5a0e56a20e821d6f8062827b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f3c12134718a8678b6cde38506d69f7/" rel="bookmark">
			mac配置双网卡 mac同时使用内网和外网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在公司办公通常都会连内网，而连内网最大的限制就是不可以使用外网，那遇到问题也就不能google，而当连接无线的时候，内网的东西就不可以访问，也就不能正常办公，对于我这种小白来说，工作中遇到的问题数不胜数，又不能什么事都请教同事，这可真是让人头大~~~~
那我们是不是可以内外网同时访问呢，答案当然是可以的，解决方法本质上就是 由于内网网段的个数是有限个的，所以内网网段设置本地静态路由，即添加内网网段指向对应内网的网关，让内网网段全部走对应内网路由，默认网段全部走默认外网路由
简单说就是 访问内网网站使用内网，其余所有网站默认使用外网，这样你的电脑就可以内外网均可访问了。
这边总结一下关于mac怎么配置同时使用内网和外网，以下双网卡配置方法是针对外网用WIFI，内网用有线，但是要注意的是双网卡也可以都是有线或者都是无线，其配置思路本质也是一样的。
话不多说，请严格按照以下步骤设置：
第一步：设置正确的网卡服务顺序 进入 系统偏好设置 - 网络 - 设定服务顺序，拖动来进行网络优先级设置。使连接外网的网卡位于内网网卡之上。此时可以正常访问外网
第二步：查看内网网卡的网关地址 路由器IP即为下一步设置需要用到的网关地址
子网掩码下一步设置也需要用到
第三步：设置本地静态路由，添加内网网段指向对应内网的网关 （这一步需要在MacOS的终端内执行命令，打开终端的方式参考 MacOS如何打开终端）
先介绍2条关于添加和删除的命令，下面有具体例子
添加：
sudo route add -net 10.0.0.0 -netmask 255.0.0.0 10.0.2.1 sudo route add -net 30.1.0.0 -netmask 255.255.0.0 10.0.2.1 删除：
sudo route delete -net 10.0.0.0 -netmask 255.0.0.0 10.0.2.1 sudo route delete -net 30.1.0.0 -netmask 255.255.0.0 10.0.2.1 net参数对应网段IP，netmask是子网掩码。最后的IP是内网网关，即上一步看到的路由器IP地址
比如内网想访问的网址是 http://10.90.20.27/fh，内网网关也就是刚才看到的路由器IP地址为 172.16.84.254，则使用以下命令添加和删除
添加
sudo route add -net 10.90.20.0 -netmask 255.255.255.0 172.16.84.254 删除
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f3c12134718a8678b6cde38506d69f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75fb54ee889fdb516f4f46c5493a326a/" rel="bookmark">
			【springboot】Failed to start bean ‘webServerStartStop‘；
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新同事新建了一个项目springboot项目，启动时候报错。
具体错误如下：
Failed to start bean 'webServerStartStop'; nested exception is org.springframework.boot.web.server.WebServerException: Unable to start embedded Tomcat server
未能启动bean“webServerStartStop”；嵌套异常为org.springframework.boot.web.server.WebServer异常：无法启动嵌入式Tomcat服务器
出现这个问题：
常规逻辑检查端口是否被占用。
我后来发现了一个狠人：居然没有配置端口。
在 application.properties 中配置
#服务器端口 server.port=7021 配置好了就可以启动了。呵呵 不要做一个狠人。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f009be36904a1e4a90cf65324f56cc7b/" rel="bookmark">
			Nginx：Windows详细安装部署教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Nginx简介 Nginx (engine x) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的。
它也是一种轻量级的Web服务器，可以作为独立的服务器部署网站（类似Tomcat）。它高性能和低消耗内存的结构受到很多大公司青睐，如淘宝网站架设。
先下载直接去官网nginx.org
分别有Linux和Windows两个版本，网站地址：http://nginx.org/en/download.html
点击后就会下载，下载完成后开始安装，其实官网已经告诉了如何安装，右侧documentation -&gt; nginx windows就有详细的说明，只是英文而已。
二、安装部署 1、下载完成后，解压缩，运行cmd，使用命令进行操作，不要直接双击nginx.exe，不要直接双击nginx.exe，不要直接双击nginx.exe
一定要在dos窗口启动，不要直接双击nginx.exe，这样会导致修改配置后重启、停止nginx无效，需要手动关闭任务管理器内的所有nginx进程，再启动才可以。
2、使用命令到达nginx的加压缩后的目录。
cd c:\nginx-1.15.2 3、启动nginx服务，启动时会一闪而过是正常的。
start nginx 4、查看任务进程是否存在，dos或打开任务管理器都行。
tasklist /fi "imagename eq nginx.exe" 打开任务管理器在进程中看不到nginx.exe的进程（双击nginx.exe时会显示在这里），需要打开详细信息里面能看到隐藏的nginx.exe进程。
如果都没有可能是启动报错了查看一下日志，在nginx目录中的logs文件夹下error.log是日志文件。
常见的错误：
(1) 端口号被占用
(2) nginx文件夹路径含中文
其他错误就详细看log中的描述
5、修改配置文件，进入解压缩目录，直接文件夹点击进去即可，不需要从dos操作。
在conf目录下找到nginx.conf使用txt文本打开即可，找到server这个节点，修改端口号，如果有需求可以修改主页目录没有就不用修改。
修改完成后保存，使用以下命令检查一下配置文件是否正确，后面是nginx.conf文件的路径，successful就说明正确了。
nginx -t -c /nginx-1.15.2/conf/nginx.conf 如果程序没启动就直接start nginx启动，如果已经启动了就使用以下命令重新加载配置文件并重启
nginx -s reload 之后就打开浏览器访问刚才的域名及端口http://localhost:8800，出现欢迎页就说明部署成功了
6、关闭nginx服务使用以下命令，同样也是一闪而过是正常的，看一下是否进程已消失即可。
快速停止
nginx -s stop 完整有序的关闭
nginx -s quit 三、优化配置 打开nginx.conf按照自己需求进行配置，下面列出简单的一些常规调优配置：
#user nobody; #==工作进程数，一般设置为cpu核心数 worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f009be36904a1e4a90cf65324f56cc7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6a9401ae0a7d4dff288c50a556752eb/" rel="bookmark">
			HBase高级特性：过滤器（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1关：使用过滤器查询指定行的数据 知识点 1.使用过滤器的步骤：
（1）创建过滤器：RowFilter(CompareOperator op,ByteArrayComparable rowComparator)，第一个参数接收的是比较操作对象，第二个参数接收的是条件。
第一个参数有很多种取值以匹配多种场景，取值表格如下：
操作描述CompareOperator.LESS匹配小于设定值的值CompareOperator.LESS_OR_EQUAL匹配小于或等于设定值的值CompareOperator.EQUAL匹配等于设定值的值CompareOperator.NOT_EQUAL匹配与设定值不相等的值CompareOperator.GREATER_OR_EQUAL匹配大于或等于设定值的值CompareOperator.GREATER匹配大于设定值的值CompareOperator.NO_OP排除一切值 （2）设置过滤器。
编程要求 请补全函数query(String tName)，需要你查询的数据如下，表名会作为方法的参数传入：
查询basic_info列族gender列，且行键为2018的值；
查询school_info列族college列，且行键大于2018的值；
查询basic_info列族name列，且行键小于等于2020的值。
package step1; import java.io.IOException; import org.apache.hadoop.cli.util.*; import org.apache.hadoop.conf.*; import org.apache.hadoop.hbase.*; import org.apache.hadoop.hbase.client.*; import org.apache.hadoop.hbase.filter.*; import org.apache.hadoop.hbase.util.*; public class Task { public void query(String tName) throws Exception { /********* Begin *********/ Configuration config = new Configuration(); Connection conn = ConnectionFactory.createConnection(config); TableName tableName = TableName.valueOf(tName); Table table = conn.getTable(tableName); Scan scan1=new Scan(); scan1.addColumn(Bytes.toBytes("basic_info"), Bytes.toBytes("gender")); Filter filter1 = new RowFilter(CompareOperator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6a9401ae0a7d4dff288c50a556752eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a115f70d26b012a1ec723cd61ed23a6/" rel="bookmark">
			KataGO（引擎安装及解释）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个没有用户界面。这是一个引擎！！！
这个没有用户界面。这是一个引擎！！！
这个没有用户界面。这是一个引擎！！！
目录 1、[原网站链接](https://github.com/lightvector/katago/releases)2、安装对应的cudaa和cuda【[参考链接](http://t.csdnimg.cn/RxfUU)】3、Readme.软件介绍【机器翻译】一、【概述】Overview二、【训练和研究过程】 Training History and Research三、【在哪下载】Where To Download Stuff四、【设置和运行KataGO】Setting Up and Running KataGo五、【用户界面】GUIs六、【Windows和Linux】 Windows and Linux七、【MacOS】 MacOS八、【OpenCL vs CUDA vs TensorRT vs Eigen】九、【 如何使用】How To Use十、【其他问题】Other Commands:十一、【优化性能】Tuning for Performance十二、【常见疑难问题】Common Questions and Issues十三、【特定GPU或GPU驱动程序问题】 Issues with specific GPUs or GPU drivers十四、【常见问题】 Common Problems十五、【其他的问题】Other Questions十六、【面向开发者的功能】Features for Developers十七、【 分析引擎】 Analysis Engine十八、【编译KataGO】 Compiling KataGo十九、【源代码概述】Source Code Overview:二十、【自我训练】Selfplay Training:贡献者许可证 4、安装教程下载链接 1、原网站链接 2、安装对应的cudaa和cuda【参考链接】 由于版本问题，我下载的是当时最新的KataGo-1.13.2-kata9x9
3、Readme.软件介绍【机器翻译】 一、【概述】Overview KataGo的公开分布式训练正在进行中!请访问katago了解更多细节，下载最新和最强的神经网络，或者学习如何帮助KataGo进一步改进!也可以查看电脑Go不和谐频道!
截至2023年，KataGo仍然是网上最强大的开源围棋机器人之一。KataGo是使用类似alphazero的过程进行训练的，经过许多增强和改进，能够迅速达到顶级水平，完全从零开始，不需要外部数据，只通过自我游戏来提高。其中一些改进利用了游戏特定功能和训练目标，但也有许多技术是通用的，可以应用于其他游戏。因此，早期训练比其他自我训练的机器人要快得多——只需要几个强大的gpu几天，任何研究人员/爱好者都应该能够在完整的19x19棋盘上训练一个神经网络，从无到有到高业余水平。如果调整得好，只使用一个高端消费级GPU进行训练，可能会在几个月内将一个机器人从零开始训练到超人的力量。
在实验上，KataGo在2020年6月运行结束时也尝试了一些有限的使用外部数据的方法，并在其最近的公开分发运行中继续这样做，“kata1”在https://katagotraining.org/上。外部数据并不是达到顶级水平的必要条件，但在对抗某些对手时仍然能够提供一些轻微的好处，并且能够作为一种有用的分析工具，用于分析各种情境(游戏邦注:这些情境不会出现在自我游戏中，但会出现在人类游戏和用户希望分析的游戏中)。
关于KataGo中使用的主要新思想和技术的论文:加速围棋的自我学习(arXiv)。
从那时起，我们发现了一些重大的进一步改进，这些改进已被纳入KataGo最近的运行中。这些和一些研究笔记可以在这里找到(docs/ katagomemethods .md)。
非常感谢Jane Street支持KataGo早期发布的主要运行训练，以及许多小型测试运行和实验。关于初始版本和一些有趣的后续实验的博客文章:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a115f70d26b012a1ec723cd61ed23a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a636304ef00967749a6ea398c651de6/" rel="bookmark">
			毕业设计：基于java的宠物领养系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于java的宠物领养系统设计与实现
I. 引言 A.研究背景和动机 研究背景：
随着互联网的发展和普及，线上服务的种类和数量不断增多，用户体验和服务质量的要求也在不断提高。在这个背景下，许多领域开始探索如何利用信息技术和网络化优势来改善服务和管理。其中，宠物领养服务作为一个重要的社会服务领域，面临着信息交流不畅、管理效率低下、用户体验不佳等问题。因此，基于Java的宠物领养系统设计与实现的研究背景在于如何利用信息技术来改善宠物领养服务的管理效率和用户体验。
近年来，国内外许多宠物领养服务机构开始关注线上服务的发展，推出了一系列基于Web或移动端的领养平台和服务。这些服务主要集中在提供宠物领养信息发布、搜索、匹配和交流等功能，旨在解决传统领养服务中信息交流不畅、管理效率低下等问题。但是，这些服务在用户体验、信息安全性、服务质量等方面仍存在许多问题，如信息虚假、用户隐私泄露、搜索结果不准确等。因此，基于Java的宠物领养系统设计与实现的研究背景还在于如何优化现有领养服务的问题和不足，提高服务质量和用户满意度。
动机：
基于以上研究背景和问题现状，进行基于Java的宠物领养系统设计与实现的毕业设计具有以下动机：
解决传统领养服务的不足：传统的宠物领养服务存在着信息交流不畅、管理效率低下等问题，而基于Java的宠物领养系统设计与实现可以充分利用信息技术和网络化优势，提供更加便捷、高效、安全的领养服务。提高服务质量和用户体验：通过设计和实现一个功能完善、界面友好的宠物领养系统，可以提供更加优质、便捷的领养服务，提高用户体验和满意度。实践软件开发技术：设计和实现一个宠物领养系统需要涉及Java语言、数据库技术、网络技术、软件工程等相关知识和技术，通过这个毕业设计可以深入学习和实践这些技术，提高软件开发能力。为社会提供更好的公共服务：设计和实现一个宠物领养系统不仅可以提供更好的领养服务，还可以促进社会公共服务的升级和发展，满足人民群众对高质量公共服务的需求。 因此，基于Java的宠物领养系统设计与实现的毕业设计具有重要的研究意义和实践价值。通过解决传统领养服务的不足、提高服务质量和用户体验、实践软件开发技术、为社会提供更好的公共服务等方面的需求，可以设计和实现一个功能完善、界面友好的宠物领养系统，推动宠物领养服务的升级和发展。
B.目标和意义 基于Java的宠物领养系统设计与实现的目标是建立一个在线的宠物领养平台，旨在方便人们寻找合适的宠物并领养，同时提高宠物救助效率和领养成功率。具体而言，目标包括：
用户注册与登录：提供用户注册与登录功能，确保用户可以安全地使用该系统。宠物信息展示：设计一个宠物信息展示模块，包括宠物的照片、品种、年龄、性别、性格特征、健康状况、领养要求等信息，方便用户查找和了解宠物。领养申请与审核：实现领养申请与审核功能，用户可以选择自己喜欢的宠物并提交领养申请，系统审核领养资格并通知申请人审核结果。宠物管理：设计并实现一个宠物管理模块，包括宠物的信息更新、删除、添加等操作，以及宠物的领养状态管理。用户交流与反馈：提供用户之间的交流功能，如评论、私信等，方便用户分享养宠经验和感受，同时收集用户反馈，不断改进系统功能。数据统计与分析：通过系统自动生成的报表和统计图表，为宠物救助组织和管理人员提供准确的数据分析，以优化资源配置和决策制定。 基于Java的宠物领养系统设计与实现具有重要的实际意义和社会价值。
提高宠物救助效率：通过系统的设计与实现，提高了宠物的曝光度和领养成功率，加速了宠物的救助进程，为需要帮助的宠物提供了更多的机会。促进宠物领养：通过系统的宠物信息展示和领养申请功能，方便用户查找和了解宠物，提高了宠物的领养率，为更多的人提供了一个领养宠物的机会。加强用户互动与交流：通过系统的用户交流功能，用户之间可以分享养宠经验和感受，增进了彼此之间的了解和互动，形成了一个互助的养宠社区。提高管理水平：通过系统的数据统计与分析功能，为宠物救助组织和管理人员提供了准确的数据支持，有助于优化资源配置和决策制定，提高了管理水平。推动数字化宠物救助发展：随着数字化宠物救助的发展，基于Java的宠物领养系统设计与实现支持数字化宠物救助的在线平台建设，有助于推动数字化宠物救助的发展进程。学习和实践软件开发技术：基于Java的宠物领养系统设计与实现是学习和实践Java语言、数据库技术、网络技术、软件工程等相关知识和技术的好平台。通过该毕业设计，可以深入学习和应用相关技术和知识，提高软件开发和系统设计的能力。 总之，基于Java的宠物领养系统设计与实现的目标是建立一个方便、快捷、高效的在线宠物领养平台，提高宠物救助效率和领养成功率。同时，通过该项目的学习和实践，能够提高软件开发能力和系统设计能力，为未来的职业发展奠定基础。因此，该项目具有深远的实际意义和社会价值。
II. 相关技术和工具 A.Java语言 Java语言是一种面向对象的高级编程语言，由Sun Microsystems（现在是Oracle公司）于1995年发布。它被设计成可移植、可靠、安全和简单易学的语言，以及具有优秀的性能和高效的垃圾回收机制。
Java语言具有许多特点和优势，下面是一些主要特点的介绍：
简单易学：Java语言借鉴了C++语法，但摒弃了C++中的复杂和容易出错的部分。它具有清晰、简洁的语法，易于学习和理解。跨平台性：Java程序是一次编写，到处运行。Java程序在编译后生成的字节码可以在任何支持Java虚拟机（JVM）的平台上运行，而不需要重新编译。面向对象：Java语言是一种真正的面向对象编程语言，具有封装、继承和多态等面向对象的概念和特征。这使得Java具有更好的结构化、可读性和可维护性。内存管理：Java具有自动垃圾回收机制，程序员无需手动管理内存。通过垃圾回收器，Java可以自动识别并回收不再使用的内存资源，避免了内存泄漏和野指针等问题。多线程支持：Java提供了强大的多线程支持，使得程序能够同时执行多个任务。多线程可以提高程序的性能和响应能力。丰富的类库和API：Java拥有众多的类库和应用程序接口（API），包括各种功能和领域所需的类和方法。这些类库和API极大地简化了程序开发工作，提高了开发效率。安全性：Java对安全性有着很高的重视，在设计上考虑了各种安全因素，如通过字节码验证、安全管理器等机制来防止恶意代码的执行。分布式计算：Java提供了强大的网络编程功能，使其成为构建分布式计算应用和网络服务的理想语言。 总的来说，Java语言是一种通用的、高效的、可移植的编程语言，具有强大的功能和良好的安全性。它在各个领域得到广泛应用，特别在Web开发、移动应用开发和企业应用开发领域占据主导地位。同时，Java语言还是学习编程和软件开发的理想选择，因为它的易学性和广泛的应用使得学习资源丰富且机会多样。
Java语言的应用范围非常广泛，以下是一些主要应用领域的介绍：
Web开发：Java在Web开发领域占据重要地位，许多大型的电子商务网站和Web应用都是使用Java开发的。Java的跨平台性和丰富的类库使得Java成为构建高性能、高并发、高稳定性的Web应用的理想选择。企业应用开发：Java在企业应用开发领域也具有广泛的应用，许多大型企业和机构都使用Java作为主要的开发语言。Java的高效性、可移植性和安全性等特点使得它成为构建企业级应用的首选语言之一。移动应用开发：Java是Android平台的主要开发语言之一，开发者可以使用Java和Android SDK开发各种类型的Android应用。大数据技术：Java在大数据技术领域也有广泛的应用，如Hadoop和Spark等大数据处理框架都是使用Java开发的。游戏开发：Java在游戏开发领域也有一定的应用，虽然现在更多的游戏开发选择使用C++或Unity等其他语言和工具，但Java仍然有一定的市场份额。 总之，Java语言是一种非常流行的编程语言，具有广泛的应用领域和良好的发展前景。无论是在学术研究、工程实践还是商业应用中，Java都扮演着重要的角色。
B.数据库技术 数据库技术是一种用于存储、管理和操作数据的软件系统。它包括数据库管理系统（DBMS）、数据模型、数据库设计、数据库查询语言、数据库索引、数据库事务、数据库安全性、数据库备份与恢复以及数据库性能优化等内容。
数据库管理系统（DBMS）是一种软件工具，用于管理和操作数据库。它提供了定义、创建、修改和访问数据库的功能。DBMS可以实现数据的添加、删除、查询和更新操作，还可以提供数据安全性保护、事务管理、并发控制等功能。
数据模型是描述和组织数据的形式化表示。常见的数据模型包括层次模型、网状模型、关系模型和对象模型等。关系模型是最常用的数据模型，它将数据组织成表格形式，通过定义表格之间的关系来表示数据之间的联系。
数据库设计是指在数据库系统中创建数据库的过程。它涉及到确定数据的结构、属性、关系和约束等。良好的数据库设计可以提高数据查询和操作的效率，减少数据冗余和不一致性。
数据库查询语言是用于查询和操作数据库的语言。常见的查询语言包括结构化查询语言（SQL）和面向对象的查询语言（OQL）。通过查询语言，用户可以方便地对数据库进行查询、过滤、排序等操作。
数据库索引是一种用于加速查询操作的数据结构。它可以帮助数据库系统快速定位需要查询的数据。常见的索引结构包括B树索引、哈希索引和全文索引等。
数据库事务是一系列对数据库的操作，它要么全部执行成功，要么全部回滚。事务可以确保数据库操作的原子性、一致性、隔离性和持久性。
数据库安全性是指保护数据库免受非法访问、损坏和数据泄露的能力。数据库系统提供了用户身份验证、权限管理和数据加密等安全机制，以确保数据的完整性和机密性。
数据库备份与恢复是保护数据库免受数据丢失和系统故障的措施。数据库备份可以将数据库的副本保存到其他存储设备中，以防止数据损坏。当数据库出现故障时，可以通过恢复机制还原数据库到之前的状态。
数据库性能优化是提高数据库系统的查询和操作效率的过程。通过设计良好的数据库结构、优化查询语句和配置合理的索引，可以提高数据库的响应速度和吞吐量。
数据库技术在各个领域都得到广泛应用。在企业中，数据库技术被广泛应用于企业资源计划（ERP）系统、客户关系管理（CRM）系统和供应链管理系统等。在互联网领域，数据库技术被用于支持大规模的数据存储和管理，如社交网络、电子商务和大数据分析等。在科研和教育领域，数据库技术被用于创建和管理科学数据和图书馆资源。
随着互联网的发展和大数据时代的到来，数据库技术也在不断发展和创新。云数据库技术、分布式数据库技术和NoSQL数据库技术等新兴技术不断涌现，适应了大规模数据存储和处理的需求。云数据库技术提供了云端数据存储和处理的服务，分布式数据库技术则提高了数据库系统的可扩展性和容错性，NoSQL数据库技术则适应了非结构化和半结构化数据处理的需求。
总之，数据库技术是一种重要的信息技术，它包括了DBMS、数据模型、数据库设计、查询语言、索引、事务、安全性、备份与恢复以及性能优化等内容。数据库技术在企业、互联网、科研和教育等领域都有广泛的应用，是信息化和数字化发展的重要支撑。同时，随着大数据时代的发展，数据库技术也在不断发展和创新，为数据处理和分析提供了更多的选择和支持。
C.GUI技术 GUI技术是指图形用户界面（Graphical User Interface，简称GUI）技术。GUI是一种基于图形的用户界面，使用图形化方式展示信息和用户交互。与命令行界面（CLI）不同，GUI通过点击、拖放、选择等操作，使用图形元素（如按钮、菜单、文本框等）来实现交互。
以下是GUI技术的详细介绍：
图形化界面 GUI使用图形化方式展示信息，将复杂的命令和功能以直观的图形方式呈现给用户。这种方式的优点是用户不需要记忆大量的命令和参数，可以通过视觉感知快速理解和操作。
事件驱动系统 GUI采用事件驱动系统，即用户的每个操作（如点击、拖放、键盘输入等）都会触发一个事件。程序通过监听这些事件，执行相应的操作，响应用户的操作。这种方式使得程序的运行更加灵活，可以同时处理多个事件。
组件化的设计 GUI采用组件化的设计方式，将界面元素封装成一个个组件。组件是GUI的基本构建块，具有特定的功能和外观。常见的组件包括按钮、文本框、标签、列表框等。这些组件可以通过组合和排列，构建出各种复杂的界面。
人机交互 GUI的设计需要考虑用户的使用习惯和心理预期。良好的GUI设计应该符合用户的认知和操作习惯，提供清晰的反馈和指示，帮助用户快速理解和完成任务。此外，GUI还需要考虑跨平台和多语言支持，以满足不同用户的需求。
发展历程 GUI的发展可以追溯到20世纪60年代。早期的GUI系统有SAGE、SMAC和OS-9等。到了70年代，Xerox公司推出了第一个成熟的GUI系统—— Alto。Alto引入了许多现代GUI的特性和组件，如窗口、图标、菜单和鼠标等。随后，Apple公司借鉴了Alto的设计，推出了Macintosh系列计算机，进一步推动了GUI的普及和发展。
主要特点 GUI的主要特点包括：
图形化界面：使用图形元素展示信息，直观易懂。事件驱动：响应用户操作，实现程序的灵活运行。组件化设计：组合和排列组件构建复杂的界面。人机交互：符合用户习惯和认知，提供清晰反馈。多任务支持：同时处理多个任务和事件。跨平台支持：适应不同操作系统和设备。 应用领域 GUI广泛应用于各种领域，包括操作系统、桌面应用、移动应用、网站、游戏等。GUI对于提高用户体验和改善人机交互至关重要。优秀的GUI设计可以提高用户的满意度和工作效率，同时降低错误操作和用户疲劳。
未来趋势 随着技术的发展，GUI也在不断演进。未来的GUI将更加智能化、个性化和多元化。例如，AI技术将被引入GUI设计，实现更加智能的交互和推荐；VR/AR技术将带来全新的三维交互体验；多模态输入将进一步丰富用户的交互方式；同时，GUI也将更好地适应不同的屏幕尺寸和分辨率，满足不同设备的需求。
总之，GUI技术是一种重要的用户界面设计方式，具有广泛的应用前景。随着技术的进步，GUI将不断演进和发展，为用户提供更加便捷、高效和愉悦的交互体验。
III. 系统需求分析与设计 A.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a636304ef00967749a6ea398c651de6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb8aaa2cc5e28c6511a6bdf67f989401/" rel="bookmark">
			日志平台--graylog-web配置、接入微服务日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 第一章 搭建es集群
第二章 mongodb搭建
第三章 graylog搭建与反向代理
文章目录 系列文章目录前言一、graylog-web界面操作二、分流操作三、分流示例四、graylog查看某个服务的日志五、graylog创建不同用户的流程及权限分类总结 前言 通过第三章内容，已成功搭建完成graylog,并且使用nginx实现了反向代理。因此在本章中，主要是针对graylog-web界面的熟悉、配置、微服务日志接入为目标，展开详细说明。
一、graylog-web界面操作 1、配置graylog 首先在Web管理界面进入System/Inputs，进行如下操作：选择Beats类型,点击 Launch new input。如下图所示 接着填入参数，端口根据需要进行修改，然后保存即可： 2、页面配置:创建sidecar采集器 Web界面进入System/Sidecars Collector根据需要这里选择了：filebeat on Linux paths处填写你Nginx服务器上日志所在位置 hosts处填写Graylog服务器的IP+端口（上面System/Inputs时候填入的端口）： 3、详细的configuration配置说明 #该文件适用于日志目录统一的情况 fields_under_root: true #自定义字段将直接位于输出文档的最外层，而不是嵌套在 fields 子字典中。 fields.collector_node_id: ${sidecar.nodeName} #当 Graylog 集群中有多个 Collector 节点时，这个字段可以用来追踪每个日志事件的来源。 fields.gl2_source_collector: ${sidecar.nodeId} #指定消息的来源采集器，其值为 Sidecar 节点 ID fields.localIp: ${sidecar.nodeName} #指定消息的本地 IP 地址，其值为 Sidecar节点名称 fields.inputType: agent #指定消息的输入类型，其值为“agent”，表示该消息是来自 Agent 的日志数据。 filebeat.registry.flush: 60s #指定 Filebeat 注册表的刷新时间 filebeat.shutdown_timeout: 10s #指定 Filebeat 的关闭超时时间 max_procs: 2 #指定 Filebeat 的最大进程数，默认值为逻辑 CPU 数量的两倍 该参数用于限制 Filebeat 运行时的并发度，防止系统资源被占用过多 filebeat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb8aaa2cc5e28c6511a6bdf67f989401/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a5be6ade746b793b5d76aaac86bca1f/" rel="bookmark">
			【How to learn AI】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为刚刚研一的同学，从研0开始就在导师、师兄师姐的帮助下学习机器学习、深度学习和强化学习，也算是有了一些感悟和收获可以与大家分享。如果有不对的地方欢迎批评指正~ 我发现很多同学跳过了学习机器学习基础的阶段，一上来就搭建一个数字手写体识别的网络，运行成功之后就感到特别快乐（曾是我哈哈哈~）但是过一会儿就有点怅然若失，why? 这玩意儿怎么运行的？
网络上那些说零基础学习人工智能或者速成班的，一看就很假好吧。我认为想要学好人工智能，首先要掌握扎实的数学分析、线性代数（含部分矩阵论）、概率论与数理统计的知识，而这些是大一大二的必修课程！！~~
接下来抛出一些观点和经验：
（补充：学习学一些Git Linux的使用方法 浙大竺可桢学院 计算机那些没教的知识 不是本人哈，就是碰巧看到了觉得讲得很好~）
机器学习基础和深度学习要一起学，最好先学机器学习基础再开始深度学习 nndl · GitHub 复旦团队的这本书非常不错，从机器学习基础—深度学习—深度学习高阶知识，可以说学完这本书的前两个部分，应对机器学习八股文考核就没有什么问题~~ （同时结合面试反向学习的思路，能够更好的拓展自己的知识面） 西瓜书+南瓜书可以非常好的学习机器学习基础的内容~ But 说实话机器学习基础的课程一直没有找到好的，现在在上软件学院龙明盛老师的机器学习课程，感觉是目前讲得最好的！！！
2. 深度学习不仅要学习搭积木，还要学习基本理论，甚至学习如何调参
台湾大学 - 李宏毅 - 机器学习深度学习（2021/2022公开教程汇总）_哔哩哔哩_bilibili
听2021/2022的版本有很不错的收获~ 一定要完成其中的作业！！ 学习pytorch的使用方法，transformer手写一个之类的~
3. 强化学习最近非常火，如何用强化学习做控制的内容是非常热门的方向之一
伯克利CS285的强化学习教程真的太棒了！！！ CS285-哔哩哔哩_Bilibili
当然啦李宏毅老师的强化学习很好入门（但是讲得不是很具体）
此外我还喜欢蘑菇书EasyRL
初探强化学习 上面这两本书也非常棒，很适合入门呀！！！
但是你要从控制方面更加理论的学习强化学习，那么我很推荐组里的这本书（先学一学上面入门的课程，就可以畅游在我们组里的教材啦~）
Reinforcement Learning for Sequential Decision and Optimal Control | SpringerLink
下载链接上边~~
（如果你学校买了Spring库，电子版可以免费下载啦~）
RL英文教材简介 | RL for Sequential Decision and Optimal Control
全书总共包括11章。第1章介绍强化学习（Reinforcement Learning, RL）概况，包括发展历史、知名学者、典型应用以及主要挑战等。第2章介绍RL的基础知识，包括定义概念、自洽条件、最优性原理与问题架构等。第3章介绍免模型RL的蒙特卡洛法，包括Monte Carlo估计、On-policy/Off-policy、重要性采样等。第4章介绍免模型RL的时序差分法，包括它衍生的Sarsa、Q-learning、Expected Sarsa等算法。第5章介绍带模型RL的动态规划法，包括策略迭代、值迭代、通用迭代架构与收敛性证明等。第6章介绍间接型RL的函数近似法，包括常用近似函数、值函数近似、策略函数近似以及所衍生的Actor-critic架构等。第7章介绍直接型RL的策略梯度法，包括On-policy gradient、Off-policy gradient、它们的代价函数与优化算法等。第8章介绍带模型的近似动态规划（ADP）方法，包括无穷时域的ADP、有限时域的ADP、ADP与MPC的联系与区别等。第9章探讨了状态约束的处理手段，它与求解可行性、策略安全性之间的关系，以及Actor-Critic-Scenery三要素求解架构等。第10章介绍深度强化学习（DRL），即以神经网络为载体的RL，包括神经网络的原理与训练，深度化挑战以及DQN、DDPG、TD3、TRPO、PPO、DSAC等典型深度化算法。第11章介绍RL的各类拾遗，包括鲁棒性、POMDP、多智能体、元学习、逆强化学习、离线强化学习以及训练框架与平台等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dbdab9449d99a28846105ce0401f20c/" rel="bookmark">
			2024（20届）数据科学与大数据专业毕业设计选题合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
大数据选题
选题迷茫
选题的重要性
更多选题指导
最后 前言 大四是整个大学期间最忙碌的时光,一边要忙着准备考研,考公,考教资或者实习为毕业后面临的就业升学做准备,一边要为毕业设计耗费大量精力。大四的同学马上要开始毕业设计,对选题有疑问可以问学长哦（见文末）!
以下整理了适合不同方向的计算机专业的毕业设计选题
🚀对毕设有任何疑问都可以问学长哦!
更多选题指导:
最新最全计算机专业毕设选题精选推荐汇总
大家好,这里是海浪学长毕设选题专场,本次分享的是
🎯 2024（20届）数据科学与大数据专业毕业设计选题合集
大数据选题 数据科学与大数据专业毕业设计可供选择的有大数据处理与分析，数据可视化与可视分析，数据挖掘与机器学习，预测与预测建模，数据隐私与安全等方向。下面的选题示例提供了广泛的研究领域和技术方向，供数据科学与大数据专业的同学作为毕业设计选题参考。对选题有疑问可以问学长哦！
基于Python的学生网购数据可视化系统 基于Python的智能档案管理系统 基于python的学生奖学金评定系统 基于大数据的个性化图书推荐系统 基于用户兴趣的音乐智能推荐系统 基于Python的动漫电影推荐系统设计 基于大数据的学生课堂行为分析系统 基于大数据的灾情预警信息发布系统 基于Python的豆瓣影视评论的数据采集与分析 基于python的招聘网站数据可视化分析系统 基于大数据挖掘的智能评测和辅导系统 基于大数据的图书馆个性化服务研究 基于Python的高考志愿辅助填报系统 基于阿里巴巴大数据的购物行为分析 基于疾控大数据的可视化分析与应用 智联招聘数据分析与可视化系统设计 基于大数据的景区快捷酒店运营系统 旅游酒店大数据分析平台的设计与实现 大数据背景下数据分析服务的市场分析 大数据技术背景下舆情收集与监测分析 基于社交软件的高校校园网络舆情分析 基于大数据的二次元社交网站体验设计 基于消费者购物记录的商品推荐去重方案 基于知识图谱的微博数据可视化管理研究 基于大数据的徽州古建筑群游客热度研究 大数据技术在商业分析中的实践应用研究 基于广播电视受众大数据的分析方法研究 基于互联网大数据的事件智能抓取和画像 基于大数据的定制旅游网站创新设计研究 基于华为大数据平台的电商网站建设优化 基于无线网络的智慧公交停靠系统方案设计 基于运营商大数据的终端产品运营系统设计 基于大数据的大学生就业创业指导系统探究 基于大数据的生鲜农产品配送监测预警系统 基于大数据的电子商务个性化商品推荐方法 基于大数据技术的高校图书馆服务优化研究 基于大数据技术的航天数据可视化系统设计 健康中国——基于大数据的可视化分析平台 面向城市大数据的分布式并行获取方法研究 基于物联网的校园疫情监控系统设计与实现 大数据背景下的Java知识地图构建研究 基于大数据的多群体用户画像构建系统设计 基于Python的数据脱敏与可视化分析 网络评价对水产品线上销量影响的实证分析 基于Web数据挖掘的网站知识获取及应用 基于大数据分析的钓鱼网站监测研究与应用 购物网站基于大数据的个性化广告推送分析 基于超星LSP系统的教参资源数据库设计 基于三大招聘网站数据词频统计分析的结果 基于大数据的高校学生分析与服务平台的研究 基于Spark的电商智能推荐云平台的研究 基于大数据的图书管理系统移动端APP研究 基于微服务的疫情可视化分析系统设计与实现 基于Python的反反爬虫技术分析与应用 基于Hadoop的网站大数据分析系统设计 基于大数据的2020年中医药网络舆情研究 基于大数据技术的房产中介信息管理系统设计 基于大数据分析的人才在线自动测评系统设计 基于大数据挖掘的职业院校官方网站安全对策 基于大数据分析的数码产品价格预测网站设计 基于大数据的在线学习内容个性化精准推荐分析 基于大数据的旅游信息智慧服务云平台构建研究 基于网络爬虫的招聘信息可视化系统设计与实现 基于网络文本大数据的商洛市康养旅游市场分析 大数据视域下贵州茶叶销售数据分析及策略研究 基于python的微信公众号关注者数据分析 基于大数据的高校信息网用户行为分析系统研究 利用Python实现知识标引系统开发与应用 基于Python平台的金融数据分析技术研究 基于大数据与网络态势感知的网站安全管理研究 基于铁路出行数据的旅客常住地智能识别算法研究 基于大数据和机器学习的大学生选课推荐模型研究 基于大数据技术的房价数据采集及可视化分析应用 基于Scrapy的电商数据分析系统设计与实现 基于Python的Moodle平台数据可视化 基于大数据分析的新疆智慧旅游网站的设计与实现 基于大数据分析的天津广播音视频 网站优化改造 基于大数据的高校官方网站信息安全防护预警机制 基于云平台与一卡通大数据的图书推荐的研究与应用 基于 Python 的招聘数据采集与可视化平台 基于51Job网站求职招聘信息的大数据爬虫分析 基于大数据时代下电子商务个性化推荐的研究与应用 基于Hadoop平台的大数据可视化分析实现与应用 基于大数据的西藏热门景点数据分析及可视化应用研究 造血干细胞移植术后随访系统的设计与数据可视化实现 基于Python的求职信息采集分析系统设计与实现 基于大数据挖掘技术的机动车驾驶人智能培训系统的研究 大数据时代基于CMS的高校网站群平台特点分析与研究 大数据环境下基于高校图书馆网站的数据可视化揭示实践 基于大数据的东南亚地区"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dbdab9449d99a28846105ce0401f20c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/567/">«</a>
	<span class="pagination__item pagination__item--current">568/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/569/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>