<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d4071d0892cad586f3f29a41e7bc636/" rel="bookmark">
			【SpringBoot】单元测试实战演示及心得分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.指定测试标准
2.设计测试用例
3.测试集示例
4.跑测试集
1.指定测试标准 单元测试会用到mock和junit的内容，作者前文有详解，可移步：
Spring Boot单元测试-CSDN博客
mockito的详细使用-CSDN博客
1.1.测哪一层？
以当前后端标准的MVC分层来说，后端代码分为controller、service、dao三层。首先我们要先确定这三层里面去测试哪一层？单元测试的核心目的是什么：
覆盖业务代码
按标准的来说的话controller层是系统对外暴露的API，这一层级只负责做一些请求和参数的处理；service层用来编写具体的业务逻辑；dao层负责与数据库进行交互。所以我们应该测service层。
1.2.如何判断测试是否通过？
测试的输出结果和我们期望的输出结果是一致的，测试就通过了。怎么判断喃？
用Assert断言
Assert不要到处去用，在测试用例的最后用它来判断一下输出结果是不是期望值即可。
1.3.mock掉哪些内容？
mock我们主要拿来干两件事儿：
mock掉对数据库的操作，避免引起数据的改动，也就是说要mock掉dao层的方法
mock掉没办法达到的地方，比如有些地方不影响代码逻辑，但是在测试的时候不好造出来，这些不可达的地方可以mock掉。
mock我们要mock两种情况：
mock返回值
mock行为
mock返回值，比如：
Train train = new Train(); String id = UUID.randomUUID() + ""; train.setKeyId(id); when(trainDao.getDetail(any(Train.class))).thenReturn(train); mock行为有些时候是主动的，我们想去定义实体的具体行为，有时候是被动的，比如要mock的dao方法没有返回值该，我们就只能通过去mock行为来使得它不去操作数据库，反正核心就是不让它去操作数据库。
比如以下方法：
void trainDetailDao.updateList(XXX) 用doAnswer去mock它的响应：
@Test public void modifyTrainDetails(){ TrainDetailList trainDetails = new TrainDetailList(); TrainDetail trainDetail = new TrainDetail(); trainDetail.setKeyId(UUID.randomUUID()+""); trainDetails.add(trainDetail); doAnswer(invocation -&gt; { List&lt;TrainDetail&gt; trainDetailList = (List&lt;TrainDetail&gt;) invocation.getArguments()[0]; Assert.assertEquals(trainDetails.getItems(), trainDetailList); return trainDetails; }).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d4071d0892cad586f3f29a41e7bc636/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c45238716773eeda91b5ec015b54602/" rel="bookmark">
			“AIGC行业投资时机分析：评估当前市场发展阶段与未来需求趋势“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 每日一句正能量前言行业前景当前发展前景相关领域的发展趋势行业潜力竞争情况结论 市场需求人才需求情况机会挑战结论 选择与规划自我评估行业调研职业规划风险管理个人陈述示例 后记 每日一句正能量 胖了就减，没钱就赚，不会就学，不要埋怨别人给不了你想要的，你要证明自己值得更好的，慢慢来，谁，没有个努力的过程，好好爱自己，加油！早安
前言 随着人工智能技术的飞速发展，AIGC——人工智能生成内容行业，正迅速成为技术创新和商业应用的新前沿。从自动化写作、图像生成到个性化视频制作，AIGC的应用正在多个领域内展现出其巨大的潜力和价值。然而，对于企业家和投资者而言，一个关键的问题是：当前是否是进入AIGC行业的合适时机？
本篇文章将深入探讨AIGC行业的发展趋势，评估技术成熟度，分析市场需求，并考虑潜在的进入壁垒和风险。我们将从行业发展阶段的角度出发，探讨AIGC技术的当前应用和未来潜力，同时审视市场对这类技术的需求和接受度。此外，我们还将讨论进入AIGC行业可能面临的挑战，包括资金投入、技术门槛、竞争环境和法规遵循等。
通过全面的分析，本文旨在为有意进入AIGC行业的投资者和创业者提供决策参考，帮助他们理解行业的复杂性和机遇，评估投资的风险与回报，以及制定相应的战略规划。无论您是技术爱好者、商业分析师还是市场策略师，AIGC行业的未来都值得我们共同关注和深入探讨。
行业前景 AIGC（人工智能生成内容）行业的发展前景是多维度的，涉及技术创新、市场需求、行业应用等多个方面。以下是对AIGC行业当前发展前景的分析，以及相关领域的发展趋势和行业潜力与竞争情况的探讨：
当前发展前景 技术成熟度：AIGC技术，尤其是深度学习和自然语言处理（NLP），已经取得了显著进展，使得机器能够生成越来越逼真的文本、图像和视频内容。
市场需求：随着个性化和自动化需求的增长，AIGC在娱乐、广告、新闻、教育等领域的市场潜力巨大。
应用创新：AIGC技术正在推动内容创作的新模式，如自动化新闻报道、虚拟助手、游戏和模拟训练等。
相关领域的发展趋势 媒体和娱乐：AIGC技术正在被用于生成个性化的电影、游戏和音乐，提供更加丰富的用户体验。
广告：AIGC可以用于创建定制化的广告内容，提高广告的相关性和吸引力。
教育和培训：在教育领域，AIGC可以生成模拟场景，用于培训和教学。
医疗健康：AIGC技术可以辅助医疗诊断和治疗计划的制定。
行业潜力 个性化内容：AIGC能够根据用户的偏好和行为生成个性化内容，提高用户满意度和忠诚度。
成本效益：自动化内容生成可以降低人力成本，提高生产效率。
创新速度：AIGC技术可以加速新内容的创作和上市速度，快速响应市场变化。
竞争情况 技术竞争：AIGC领域的竞争集中在技术创新和专利上，企业需要不断投入研发以保持竞争优势。
数据获取：获取高质量的训练数据是AIGC技术发展的关键，数据的获取和处理能力成为竞争的重要因素。
伦理和法律：随着AIGC技术的发展，相关的伦理和法律问题也日益突出，如内容的版权、生成内容的真实性等。
用户接受度：用户对AIGC生成内容的接受度和信任度也是决定行业发展的关键因素。
结论 AIGC行业展现出巨大的发展潜力，但同时也面临着技术、市场、伦理和法律等方面的挑战。企业需要在创新的同时，考虑如何平衡这些因素，以实现可持续发展。对于有意进入这一行业的企业和投资者，深入分析市场趋势、技术发展和用户需求，制定合理的战略规划，是成功的关键。
市场需求 市场对AIGC（人工智能生成内容）行业人才的需求正在迅速增长，这主要是由于AIGC技术在多个领域的应用前景以及对自动化和个性化内容的日益增长的需求。以下是对AIGC行业人才市场需求的研究，以及评估进入该行业的机会和挑战的分析：
人才需求情况 技术专家：随着AIGC技术的复杂性增加，市场对数据科学家、机器学习工程师和深度学习专家的需求不断上升。
产品开发者：需要有才能的产品开发者来设计和实现AIGC应用，以满足不同行业和消费者的需求。
用户体验设计师：为了提供引人入胜的用户体验，AIGC行业需要专业的用户体验（UX）和用户界面（UI）设计师。
伦理和法律顾问：随着AIGC技术的发展，对能够处理伦理和法律问题的专家的需求也在增加。
市场营销专家：为了推广AIGC产品和服务，需要市场营销专家来制定有效的市场进入策略。
机会 新兴市场：AIGC技术在多个行业中都有应用潜力，为新企业的创立和现有企业的扩展提供了机会。
技术进步：技术的快速发展为AIGC行业带来了新的商业模式和收入来源。
资本投入：投资者对AIGC行业的关注和资本的投入为人才提供了更多的职业机会。
挑战 技术门槛：AIGC是一个技术密集型行业，对专业技能的要求较高，这可能限制了人才的供应。
伦理和法律问题：AIGC技术在内容生成方面的应用引发了一系列伦理和法律问题，需要专业知识来解决。
用户接受度：用户对AIGC生成内容的接受度和信任度是进入该行业的一大挑战。
竞争压力：随着越来越多的企业进入AIGC领域，市场竞争日益激烈。
结论 市场对AIGC行业人才的需求表明，该行业存在显著的增长机会。然而，技术门槛、伦理法律问题、用户接受度和市场竞争等挑战也不容忽视。对于有意进入AIGC行业的个人和企业，了解这些需求和挑战是制定有效战略和抓住市场机会的关键。此外，持续的教育和培训、对新技术的关注以及灵活适应市场变化的能力，对于在AIGC行业中取得成功至关重要。
选择与规划 选择进入AIGC（人工智能生成内容）行业并进行职业规划时，需要综合考虑个人的技能、兴趣以及长远的职业目标。以下是一些关键点，可以帮助个人做出选择并规划职业路径：
自我评估 技能匹配：评估自己当前的技能是否与AIGC行业的需求相匹配。例如，是否具备编程、数据分析、机器学习等技术背景。
兴趣与热情：对AIGC技术及其应用是否具有浓厚的兴趣和持续的好奇心。
学习能力：是否愿意不断学习新技术，跟上行业的发展步伐。
职业目标：明确自己的职业目标，是否希望在技术、产品开发、管理或咨询等领域发展。
行业调研 市场趋势：研究AIGC行业的市场趋势，了解行业的发展方向和潜在的职业机会。
技术发展：关注AIGC领域的最新技术进展，如深度学习、自然语言处理等。
企业需求：了解不同企业对AIGC人才的具体需求，包括技能要求、工作经验等。
职业规划 短期目标：设定短期职业目标，如获取相关证书、完成特定项目或在某个技术领域达到熟练水平。
长期愿景：规划长期职业愿景，包括希望在AIGC行业中达到的位置和影响力。
继续教育：考虑是否需要进一步的教育或培训来提升技能，如参加在线课程、研讨会或专业认证。
网络建设：建立专业网络，参加行业会议、研讨会，与同行交流，了解行业动态。
实践经验：寻找实习、项目或工作机会，以获取实际的AIGC行业经验。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c45238716773eeda91b5ec015b54602/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f8a69749f27162a43868bdac6203da2/" rel="bookmark">
			微软为团队推出了 Copilot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微软希望使其生成式人工智能品牌对团队更有用，特别是跨公司和大型企业组织的团队。
在年度 Build 开发者大会上，微软宣布推出 Team Copilot，这是其 Copilot 系列生成式 AI 技术的最新扩展。
与微软之前的 Copilot 品牌产品不同，Team Copilot 与其说是一个单点解决方案，不如说是一组旨在“改善协作”和“简化项目管理”的功能。
微软人工智能首席副总裁 Jared Spataro 在与 TechCrunch 分享的一篇博客文章中写道：“[Team] Copilot 通过承担可能耗时且成本高昂的管理任务，使团队变得更加高效和富有创造力。”
Team Copilot 与 Microsoft 视频会议应用 Teams 集成，帮助管理会议议程并记录会议中任何人都可以共同撰写的笔记。
在文本聊天中，Team Copilot 总结信息（如果幸运的话，准确）并回答有关小组讨论内容的问题。
Team Copilot 从 Teams 扩展到 Loop 和 Planner（Microsoft 的协作和规划平台），用于创建和分配任务、跟踪截止日期并在需要时通知团队成员。
在 Planner 中，Copilot 还可以帮助将大型工作项目分解为步骤，并提供有关任务进度、优先级和利益相关者工作量等问题的答案。
微软表示，Team Copilot 功能将于今年晚些时候向拥有 Copilot for Microsoft 365 许可证的客户提供预览版，该许可证起价为每位用户每月 30 美元。
https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzkxNDM4OTM3OQ==https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzkxNDM4OTM3OQ==
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8b79a3ba1c603b89c6c5d70fb99dbfc/" rel="bookmark">
			MongoDB白皮书｜应用程序驱动型智能：定义下一代成功的现代应用程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文内容摘录自MongoDB白皮书《应用程序驱动型智能：定义下一代成功的现代应用程序》，若需获取白皮书原版pdf，请见文末获取方式。
构建更智能应用程序的必要性 要在数字经济时代保持竞争力并站稳脚跟，您需要让自己的应用程序变得更加智能。更智能的应用会使用数据、AI 和分析技术以自然语言与用户互动，生成见解并自主采取相应行动。这样可以带来两个好处：
1、与您的业务进行交互时，应用可通过提升客户体验和满意度来提高竞争优势。
2、应用可通过更快地制定明智的决策来提高效率和盈利能力。
对于这些提供价值的更智能、采用AI 技术的应用，它们必须直接在应用流内实时处理实时数据。思考以下应用场景：
●在客户浏览电商网站时，提供高度个性化的服务，并使用自然语言、通过聊天机器人与客户互动。
●在支付处理过程中检测并阻止欺诈交易。
●在用户叫车时动态调整定价。
●为音频流和视频流提供实时字幕和翻译。
除此之外，企业还希望针对运营流程自动制定决策并提供预测见解，以便应对当下情况，例如：
●监控库存，以便在最佳时间推出限时抢购活动或调整供应链订单。
●汇总支持案例并根据在线评价提取情感，以不断改进产品和促销活动。
●通过分析传感器遥测数据预测设备故障。
●生成并测试经过SEO 优化的网页的多个副本，以提高发现率和点击率。
这些示例虽然来自不同的行业和场景，但它们都有一个共同的关键需求：需要使用实时系统中的最新数据，提供实时智能、机器学习模型推理，以及采取相应行动。其输出控制着应用程序的行为，并为生成式AI提供了基准真值上下文。
为了构建这样新一代的智能应用程序，我们不能再仅仅依靠将数据从我们的操作系统复制到集中式分析数据仓库和数据湖中——在不同系统之间移动数据不仅耗时，并且会导致分析应用程序事件与采取行动之间出现分离。
相反，我们必须将一种新的AI和分析处理直接引入数据源，即应用程序本身，以便采用通过实时处理新鲜数据来提供价值所需的新工具、技术和工作流程。我们将这种方法称为应用程序驱动型智能。
当前的AI和分析技术面临数据实时处理的挑战 白皮书用表格深入分析了「应用程序」（操作型数据库）与「集中式分析系统」（数据湖仓）处理数据方式的差异。
过去，这两者分别负责业务的运行和管理、由不同的团队管理、服务于不同需求的受众。「集中式分析系统」设计用于运行繁重、高度复杂的BI 报告和数据科学查询，未被设计为用于满足操作型应用程序（服务于数以千计的并发用户）的需求。它们无法对应用程序查询为代表的记录子集提供毫秒级的细粒度访问、不支持应用程序不断添加到、更新且随后实时查询以检索LLM 提示或模型推理的最新业务上下文的数据集。
传统的BI报告和离线机器学习模型，已无法满足实时智能和机器学习模型推理的需求。除此之外，还有部门孤岛的问题：分析团队往往被安置在集中式后勤部门，每当业务有新的分析报告需求时，都需要分析团队花费较多的时间和精力执行整个分析流程。应用程序与分析的交付速度不一致，进一步阻碍了向应用程序驱动型智能的转变。
需要做出哪些改变？ 因此，我们需要将AI和分析处理直接引入数据源——即应用程序本身，以实现应用程序驱动型智能。
应用程序驱动型智能不是试图将数据仓库或数据湖引入应用程序。相反，这是一种新型的AI 和分析，能够为数千个并发用户以低延迟的智能方式自动处理新鲜数据并提供见解。软件和模型通常会使用推理、提示和分析输出，以产生上下文体验，提供即时见解并促使采取行动。它们不是用于管理业务的仪表盘，也不是用于训练和调整离线自定义模型的信号。因此，应用程序中的分析和AI 查询仅接触几十到数千条记录，而不是数百万条记录。它们使用的是应用程序正在处理的实时数据，而不是经过数月甚或数年从几十个不同的数据源获取和合并的数据。
开发者和分析团队对于数据平台的功能有着各种不同的需求。白皮书中直观汇总了实现应用程序驱动型智能所需的各种功能，您可以下载pdf以查看更详细的内容。
交付应用程序驱动型智能的方法 超大规模服务提供商可以提供所需的功能，但是，这些服务是孤立的基本单元，而不是集成的平台。这意味着您的团队需要完成许多自定义工程工作，例如拼凑多个数据库、构建ETL 数据管道、设立自己的API 层等。所有这些复杂性都会带来巨大开销，和导致碎片化且低效的开发者体验，以及阻碍团队尝试采用应用程序驱动型智能，使得企业竞争力处于劣势。
但是，MongoDB 为您提供了一种更好的方式。
MongoDB如何提供帮助？ 基于MongoDB Atlas构建的MongoDB 开发者数据平台统一了操作、AI 和分析数据服务，可简化构建AI 强化应用的过程。
Atlas 能够以适合开发者的工作流程、框架和语言的方式，将强大的AI 和分析功能直接交到开发者手中。借助Atlas，开发者可以获得任何结构的数据、对其编制索引、查询、搜索并分析数据，以应用所需的任何方式提供模型上下文和推理，然后对提示和推理步骤进行存档，以获得长期的模型记忆。所有这些操作均可在使用统一的API 和灵活的数据模型的情况下进行，而无需构建自己的数据管道或复制数据。
MongoDB Atlas 将事务处理、AI 处理和分析处理与统一的开发者原生API 和灵活的文档数据模型整合到了一个多云数据平台中。
同时，分析团队可以使用自己首选的基于SQL 的工具访问实时应用程序数据。这些工具可以在不干扰应用程序的情况下使用此类新鲜数据，能够为企业主生成见解，以及将训练数据输入到其自定义模型中。
Atlas 支持任何级别的应用智能，从查询记录和通过语义与关键词搜索来检索信息到聚合和转换数据，提供基于规则的引擎和特征存储，直到使用实时数据增强LLM 和传统AI 模型。Atlas 会自动优化数据的获取、处理和存储方式，最大限度地提高应用程序的操作、AI 和分析工作负载的效率。这些功能全部打包在一个巧妙的集成式多云数据架构中。
MongoDB Atlas 在AWS、Azure 和Google Cloud 上的110 多个区域中运行。这样您就可以在任何所需位置自由运行AI 工作负载。您可以将自己的应用置于靠近用户的位置，以保护数据主权并减少延迟，或者可以灵活地利用任何超大规模服务提供商的最新AI 创新，同时Atlas 会为您处理所有数据移动。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8b79a3ba1c603b89c6c5d70fb99dbfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29403a0df2090987fe78ece0b0234d40/" rel="bookmark">
			[Algorithm][动态规划][动态规划原理][整体理解]详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 0.前言1.动态规划一般思路2.状态表示如何来？3.状态转移方程如何推导？4.处理边界问题以及初始化问题的技巧5.空间优化思路6.子序列 vs 子数组 0.前言 本节非常重要哦，有关后面动态规划题的总体理解建议和后面的题搭配起来食用哦~ 1.动态规划一般思路 创建dp表 可能是一维数组，也可能是二维数组 确定状态表示 -&gt; dp[i]的含义推导状态转移方程 -&gt; dp[i] = ? 用之前或之后的值，推导出dp[i]的值根据最近的一步，来划分问题 初始化：保证填表的时候不越界确定填表顺序：为了保证填写当前状态的时候，所需要的状态已经计算过了确定返回值 题目要求 + 状态标识 2.状态表示如何来？ 题目要求经验 + 题目要求 一维线性dp 以i位置为结尾以i位置为起点 分析问题的过程中，发现重复子问题 3.状态转移方程如何推导？ 简单问题可以直接写出状态转移方程复杂问题，多个状态时，可以画图表示各个状态的关系，最后对着关系机写出状态转移方程
4.处理边界问题以及初始化问题的技巧 虚拟结点如何开？
一维：dp表多开一位
注意事项： 虚拟节点里面的值，要保证后面填表时是正确的下标的映射关系
二维：dp表多开一行和一列
注意事项： 虚拟节点里面的值，要保证后面填表时是正确的下标的映射关系
算法里面初始化为无穷：INT_MAX || INT_MIN时，要注意潜在的溢出风险
替换为0x3f3f3f3f || -0x3f3f3f3f即可解决该问题首先它足够大，其次它没有溢出风险 多个状态方程，其中只有一部分的状态方程需要特殊的初始化，那么可以想办法把这个状态方程拆成多步，分步执行，尝试避免特殊处理初始化
根据实际情况，可以考虑将dp表中的值，都初始化为最次的情况
这样处理或许可以省去一些步骤 关于字符串dp问题，空串是有研究意义的
引入空串后，会方便初始化倘若在dp表中加入了虚拟结点，那么可以在初始化时，在源字符串前面加上' ' 这是为了确保字符串下标正确，避免在字符串中找子串时不必要的麻烦 5.空间优化思路 优化方法： 滚动数组 优化效果： O ( N 2 ) − &gt; O ( N ) O(N^2) -&gt; O(N) O(N2)−&gt;O(N) O ( N ) − &gt; O ( 1 ) O(N) -&gt; O(1) O(N)−&gt;O(1) 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29403a0df2090987fe78ece0b0234d40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9908708dd27c7a84f5b7fb63e0438cd/" rel="bookmark">
			正在进行：微软Build 2024大会宣布的Team Copilot：你的会议助手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每周跟踪AI热点新闻动向和震撼发展 想要探索生成式人工智能的前沿进展吗？订阅我们的简报，深入解析最新的技术突破、实际应用案例和未来的趋势。与全球数同行一同，从行业内部的深度分析和实用指南中受益。不要错过这个机会，成为AI领域的领跑者。点击订阅，与未来同行！ 订阅：https://rengongzhineng.io/
在微软Build 2024大会上，宣布了Team Copilot，可以在你和同事的Microsoft Teams通话和聊天中“潜伏”，当然，这是在获得主持人许可后进行的，以满足你和同事的需求。
最近，AI领域的大佬们接二连三地发布了新消息，包括OpenAI的GPT-4o和Google I/O的一系列新更新。在这些新发布的内容中，Team Copilot听起来与谷歌的AI Teammate非常相似——稍后会详细介绍。
什么是Team Copilot？ Copilot是微软对Google Gemini等AI个人助理的回应。
Team Copilot标志
Team Copilot是微软AI野心的新发展。Credit: Microsoft
然而，微软通过Team Copilot进一步提升了公司和员工的体验。那么，究竟什么是Team Copilot？它是一个“会议助理”，可以加入Microsoft Teams的会议和聊天中，帮助进行以下七个关键任务：
1. 总结Microsoft Teams会议 Microsoft Teams在Build 2024大会上的演示
Team Copilot可以加入并做笔记。Credit: Microsoft
主持人可以邀请Team Copilot进入会议并总结会议内容。它可以在讨论中做笔记。此外，任何人都可以编辑Team Copilot的提纲，让你的同事可以随意添加或删除笔记。
2. 构建后续任务和行动 Microsoft Teams' Team Copilot在Build 2024大会上的演示
Team Copilot在Microsoft Teams会议中建议后续任务。Credit: Microsoft
根据Microsoft Teams的讨论，Team Copilot可以建议讨论后的活动，例如后续任务，确保每个人都在同一页面上。例如，Team Copilot可以推荐与同事安排一次后续会议。
3. 跟踪时间以保持会议结构 Microsoft Teams' Team Copilot在Build 2024大会上的演示
Team Copilot建议为议程上的每个主题设置时间限制。Credit: Microsoft
在会议中很容易失去时间观念，花费太多时间在某个话题上。作为会议助理，Team Copilot可以确保会议对每个议题保持结构化的时间。
4. 在聊天中担任群组主持人 Team Copilot在Microsoft Teams中主持聊天
Team Copilot可以作为聊天主持人。Credit: Microsoft
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9908708dd27c7a84f5b7fb63e0438cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97dc13b45cfbb8a8b98bd938cf880a8b/" rel="bookmark">
			AI大模型全栈工程师|大模型应用开发基础-笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
新的社会分层
AI产品开发者的核心能力模型
大语言模型能做什么？
找落地场景的思路
大语言模型的原理
训练
推理
Token是什么?
用AI的三个模式
大模型应用技术架构
纯prompt
agent+function calling
RAG (Retrieval-Augmented Generation)
Fine-tuning(精调/微调)
ai做应用的步骤
选择大模型的依据
新的社会分层 AI使用者：人人可以AI产品开发者：课程的定位也在这里基础模型相关：门槛特别高，机会特别难遇到 AI产品开发者的核心能力模型 三懂：
懂业务：就是懂用户、懂客户、懂需求、懂市场、懂运营、懂商业模式懂AI：就是懂AI能做什么,不能做什么;怎样才能做得更好,更快,更便宜懂编程：就是懂如何编程实现一个符合业务需求的产品 三种人：
AI全栈工程师：懂业务、懂AI、懂编程业务向：懂业务、懂AI 试试学编程，自主性更强；两个门槛：科学上网；编程环境搭建编程向：懂编程、懂AI 纯工程师，不太吃香了（CTO失业） 核心就是懂业务，懂编程，懂AI并不难，需要从业务中去实践
行业共识：
确定未来-AI必然重构世界确定进入-想收获红利,必须马上进入不确定落地-解决什么问题,用什么技术路线,产品策略是什么,确定性都不高 ——「不确定」确定了,代码的价值才大
思考:「智能冰箱」是AI吗?
一种观点:基于机器学习、神经网络的是AI,基于规则、搜索的你是AI。
大语言模型能做什么？ 本课第一个专业向要求:分清对话产品和大模型。
信息抽取文本分类文本聚类持续互动（如下棋） 找落地场景的思路 从最熟悉的领域入手找「文本进、文本出」的场景别求大而全。将任务拆解,先解决小任务、小场景让AI学最厉害员工的能力,再让ta辅助其他员工,实现降本增效 大语言模型的原理 用不严密但通俗的语言描述训练和推理的原理:
训练 大模型阅读了人类说过的所有的话。这就是「机器学习」训练过程会把不同token同时出现的概率存入「神经网络」文件。保存的数据就是「参数」,也叫「权重」 推理 我们给推理程序若干token,程序会加载大模型权重,算出出概率最高的下一个token是什么用生成的token,再加上上文,就能继续生成下一个token。以此类推,生成更多文字 Token是什么? 可能是一个英文单词,也可能是半个,三分之一个可能是一个中文词,或者一个汉字,也可能是半个汉字,甚至至三分之一个汉字大模型在开训前,需要先训练一个tokenizer模型。它能把所有的文本,切成token 思考:
AI做对的事,怎么用这个原理解释?Al的幻觉,一本正经地胡说八道,怎么用这个原理解释? 这套生成机制的内核叫「Transformer架构」。Transformer仍是主流,但其实已经不是最先进的了。
——但目前只有transformer被证明了符合scaling-law
"scaling-law"，它是指模型性能与模型大小、数据量和计算资源之间的关系。在NLP领域，研究人员发现，对于Transformer模型，其性能与模型参数量、训练数据量和计算量之间存在一定的可预测关系。这意味着，如果我们按照一定的比例增加模型的规模，我们可以在一定程度上预测模型性能的提升。这种可预测性为模型的开发和优化提供了重要的指导。
用AI的三个模式 三个模式 AI Embedded模式 这种模式指的是将人工智能技术嵌入到一个设备或一个系统中。嵌入式AI可以在各种设备中找到，如智能手机、家用电器、汽车等，它们在本地执行AI算法，而不依赖于云服务。这种模式的优势在于它可以即时处理信息，减少延迟，并且可以在没有网络连接的情况下工作。AI Copilot模式 AI Copilot模式通常是指一个人工智能系统，它作为人类的辅助，可以在各种复杂任务中提供支持。这个术语灵感来源于飞机的副驾驶，它帮助飞行员执行飞行任务，确保飞行的安全和效率。在AI领域，Copilot模式可以是任何形式的辅助系统，如智能助手、推荐系统或决策支持系统，它通过分析大量数据来提供建议或辅助决策，但最终的控制权仍在人类手中。AI Agent模式 AI Agent是一种自主的智能体，它可以在没有人类直接指导的情况下运行，并能够执行一系列复杂的任务。这种模式下的AI系统通常具有学习能力，能够根据环境变化调整自己的行为。AI代理可以是虚拟的，比如软件应用程序，也可以是物理的，比如机器人。它们在执行任务时不需要人类干预，能够自主做出决策并解决问题。点评 Agent还太超前,Copilot值得追求。 大模型应用技术架构 纯prompt agent+function calling agent：AI主动提要求；Function Calling：Al要求执行某个函数当人看：你问ta过年去哪玩,ta先问你有多少预算 RAG (Retrieval-Augmented Generation) Embeddirgs:把文字转换为更易于相似度计算的编码。这种编码叫向量向量数据库:把向量存起来,方便查找向量搜索:根据输入向量,找到最相似的向量当人看:考试答题时,到书上找相关内容,再结合题目组成答案,,然后,就都忘了 Fine-tuning(精调/微调) 当人看:努力学习考试内容,长期记住,活学活用。 学习微调和RAG模式是让自己能够和其他用AI人的关键
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97dc13b45cfbb8a8b98bd938cf880a8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2db4423deeb9370321f2050e19be03bd/" rel="bookmark">
			字符串函数（二）：strlen(求长度)，strstr(查找子串)，strtok(分割)，strerror(打印错误信息)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符串函数 一.strlen（求字符串长度）1.函数使用2.模拟实现（三种方法） 二.strstr（字符串查找子串）1.函数使用2.模拟实现 三.strtok（字符串分割）四.strerror，perror（打印错误信息） 一.strlen（求字符串长度） 1.函数使用 size_t strlen(const char* str); strlen函数用于求字符串的长度，参数是字符串的首地址，返回值是无符号的整形，初始化字符串有两种，它们各自存在一些小的细节，如下： #include&lt;stdio.h&gt; #include&lt;string.h&gt; int main() { char str1[] = "abcdef";//本质：{ 'a','b','c','d','e','f','\0' };隐藏了\0在末尾 char str2[] = { 'a','b','c','d','e','f' }; //函数strlen()： 求字符串长度 printf("%zu\n", strlen(str1));//6 printf("%zu\n", strlen(str2));//由于尾部没有'\0'随机数，所以打印随机数 printf("%s\n", str2);//直到找到'\0'为止，停止打印 //关键字sizeof()：求字节的大小返回值同样是size_t(unsigned int) printf("%zu\n", sizeof(str1));//7 printf("%zu\n", sizeof(str2));//6 return 0; } 可以看到str2的长度居然是33，其实这是因为strlen函数会从首地址指向的字符一直向后查找，直到遇到’\0’，才会停下（不包含 ‘\0’ )，统计’\0’之前出现的字符的个数，而str2末尾没有’\0’，所以会一直向后查找，在某个位置恰好遇到了’\0’，所以打印随机数33。printf函数打印字符串也是同样的道理，看似传入"abcdef"，其实真正传入的是首地址（a的地址），遇到了’\0’，停止打印。那为什么会出现烫烫烫呢？这就牵扯到了函数栈帧了，日后会将函数栈帧更新上来。 总结：
字符串以 ‘\0’ 作为结束标志，strlen函数返回的是在字符串中 ‘\0’ 前⾯出现的字符个数（不包
含 ‘\0’ )。
参数指向的字符串必须要以 ‘\0’ 结束。
注意函数的返回值为size_t，是无符号整形（size_t 等价于 unsigned int）。
易错点：
#include&lt;stdio.h&gt; int main() { if (strlen("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2db4423deeb9370321f2050e19be03bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d941b7ac28c422e31ed97d798505f485/" rel="bookmark">
			数据结构选择题（期末）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.给定N×N的二维数组A，则在不改变数组的前提下，查找最大元素的时间复杂度是（A）：
A.O(N2)
B.O(NlogN)
C.O(N)
D.O(N2logN)
两重循环即O(N2)的时间复杂度
2.与数据元素本身的形式、内容、相对位置、个数无关的是数据的（C ）。
A.存储结构
B.存储实现
C.逻辑结构
D.运算实现
逻辑结构是数据元素之间的关系，与数据元素本身无关
3.通常要求同一逻辑结构中的所有数据元素具有相同的特性，这意味着（B ）。 A.数据在同一范围内取值 B.不仅数据元素所包含的数据项的个数要相同，而且对应数据项的类型要一致
C.每个数据元素都一样 D.数据元素所包含的数据项的个数要相等
4.下面代码段的时间复杂度是（D）。
s=0;
for ( i=0; i&lt;n; i++ )
for( j=0; j&lt;n; j++ )
s+=B[i][j];
sum=s;
A.O(1)
B.O(log2n) C.O(n)
D.O(n2)
两重for循环，均为从0到n-1，所以是n*n，即O（n2）
5.下面代码段的时间复杂度是（D）。
i=1;
while( i&lt;=n )
i=i*3;
A.O(n)
B.O(n2)
C.O(1) D.O(log3n)
6.下面代码段的时间复杂度是（B）。
x=0;
for( i=1; i&lt;n; i++ )
for ( j=1; j&lt;=n-i; j++ )
x++;
A.O(n)
B.O(n2) C.O(n3) D.O(2n)
7.要判断一个整数N（&gt;10）是否素数，我们需要检查3到 根号N 之间是否存在奇数可以整除N。则这个算法的时间复杂度是：(B)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d941b7ac28c422e31ed97d798505f485/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91ac78a7e3cc9cc570795c9152869712/" rel="bookmark">
			最简单的方式解决android studio 模拟器无法联网的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最简单的方式解决android studio 模拟器无法联网的问题 看了网上很多解决android studio内置模拟器无法联网的问题，基本上都是在模拟器手机上配置dns，个人试了多种办法也连不上网，现在给出一种，仅需要在命令行操作的解决安卓模拟器联网的问题
打开安卓模拟器 配置好SDK环境变量 在环境变量中加入SDK中platform-tools的目录
WIN+R打开CMD 依次输入
adb root 然后输入
adb shell 最后配置自己电脑的DNS服务器 setprop net.eth0.dns1 192.168.1.1 如果不知道自己DNS服务器IP，可以在cmd输入
ipconfig /all 这个192.168.1.1就是DNS服务器IP，一般是路由器的网关，重启安卓模拟器，这样安卓模拟器就可以上网了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccc56da80b1c36fd4e74ae2f636b4215/" rel="bookmark">
			各种数据模态的AIGC（人工智能内容生成）方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		23年8月新加坡技术和设计大学发表的综述，“AIGC for Various Data Modalities: A Survey“，讨论多种模态的AIGC技术调研。
AI 生成内容 （AIGC） 方法旨在使用 AI 算法生成文本、图像、视频、3D 资产和其他媒体。由于其广泛的应用和最近工作的潜力，AIGC的发展最近引起了很多关注，并且已经为各种数据模态开发了AIGC方法，例如图像，视频，文本，3D形状（如体素、点云、网格和神经隐式场）、3D场景，3D人类化身（包括身体和头部的avatar）， 3D 运动和音频 – 每种运动都有不同的特征和挑战。此外，跨模态AIGC方法也有许多重大发展，其中生成方法可以在一种模态中接收条件输入，并在另一种模态中产生输出。示例包括从各种模态到图像、视频、3D 形状、3D 场景、3D 化身（身体和头部）、3D 运动（骨架和化身）和音频等模态。
本文全面回顾不同数据模态（包括单模态和交叉模态方法）的AIGC方法，重点介绍每种环境中的各种挑战，代表性工作和最近的技术方向。还以各种方式展示几个基准数据集的比较结果。此外，还讨论了挑战和潜在的未来研究方向。
以下内容强调一下3D内容生成。
3D形状模态 神经隐式场
神经隐式场（或神经场）是对 3D 形状的隐式再现，其中神经网络“表征”3D 形状。为了观察3D形状，3D点坐标作为输入馈到神经网络中，并且可以预测与每个点相关的属性。神经场预测的属性往往是占用值 [27]、[312] 或符号距离值 [28]，可以从中推断出 3D 形状。例如，通过查询 3D 空间的占用值，可以推断 3D 形状占用了 3D 空间的哪些区域。神经场具有作为连续表示的优势，以高分辨率和高内存效率对 3D 形状进行编码。还可以灵活地编码各种拓扑。然而，从神经场中提取 3D 表面通常很慢，因为需要用神经网络（通常是 MLP）对 3D 点进行密集评估。此外，由于缺乏有效监督训练的真值，因此训练神经场可能很困难，而且在神经场表示中训练生成模型（如 GAN）也不简单。此外，由于每个神经场只捕获一个3D形状，因此需要学习泛化和生成新形状的能力。编辑 3D 形状也可能很困难，因为信息隐式地存储为神经网络权重。
占用场。IM-GAN [27] 和 ONet [312] 是第一个执行 3D 形状生成的，同时用神经网络对隐式场进行建模，神经网络为每个点分配一个占用值。LDIF [313]根据结构化隐函数[314]模板将形状分解为一组重叠区域，提高了神经隐式场的效率和泛化性。Peng[315]介绍了卷积占用网络，可扩展，并且还比以前全连接架构有所改进。
符号距离场。符号距离场 （SDF） 预测到 3D 目标表面的度量符号距离，相比来说仅预测占用场中的占用值（如上所述）提供的效用有限。例如，SDF 的符号距离值可用于曲面光线投射渲染模型，其梯度可用于计算曲面法线。DeepSDF [28] 第一个使用神经场来预测每个 3D 点到3D形状表面的符号距离值。然而，基于ReLU的神经网络往往难以编码高频信号，例如纹理，因此SIREN [316]用周期激活函数，更好地处理高频细节。与以前依靠低维潜代码在各种形状进行泛化的方法不同，MetaSDF [317] 旨在通过元学习 [318] 提高神经 SDF 的泛化能力。网格IM-GAN [285]将空间分割成一个网格，并分别学习捕获每个网格单元的局部几何形状（而不是全局隐式函数），这也使局部的组成和排列能够创建新形状。SDF-扩散模型[268]提出了一种基于扩散的方法，通过去噪扩散过程迭代地提高SDF的分辨率，以SDF形式生成高分辨率3D形状。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccc56da80b1c36fd4e74ae2f636b4215/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8316539e3059a77ae2ea5b6d1fbf2fb3/" rel="bookmark">
			【C&#43;&#43;的奇妙冒险】构造函数和析构函数（初始化和清理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、默认成员函数二、构造函数构造函数的概念构造函数的特性默认构造函数 三、析构函数析构函数的概念析构函数的特性析构函数的先后析构问题为什么要有析构函数？析构函数的特性检验 前言 一、默认成员函数 如果一个类中什么成员都没有，简称为空类。
class Date {}; 空类中真的什么都没有吗？nonono~，并不是，任何类在什么都不写时，编译器会自动生成以下6个默认成员函数。
如上图所示，类共有6个默认成员函数，咱们逐一攻破，先Follow me拿下前两个 构造函数和析构函数，小细节很多哦~瞪大眼睛嗷👀。
首先，对于默认成员函数，如果我们不写，编译器是会自己生成一份滴。（谁家的编译器这么良心 ❤️！）
这里有老铁就要问了，哎哥们儿~哥们儿，那它们都有啥作用啊？哼哼哼，不妨告诉你嗷，它们可有用了，就比如：栈（Stack）哥们儿是不是要自己写个初始化函数（Init）和销毁函数（Destroy），有些粗心的老铁就非常容易忘记，要么忘了写初始，上来就push，要么最后忘了销毁，导致内存泄漏，对于初始化和清理，构造函数和析构函数就可以帮助我们完成，是的构造函数就像Init，析构函数就像Destroy。下面话不多说，先从构造函数下手。👻
二、构造函数 先看一个普通的日期类
class Date { public: void GetDate(int year, int month, int day) { _year = year; _month = month; _day = day; } void Print() { cout &lt;&lt; _year &lt;&lt; "/" &lt;&lt; _month &lt;&lt; "/" &lt;&lt; _day &lt;&lt; endl; } private: int _year; int _month; int _day; }; int main() { Date d1; d1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8316539e3059a77ae2ea5b6d1fbf2fb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d98ec4b4315cdab672bc71fea8c97da7/" rel="bookmark">
			【亲测，安卓版】快速将网页网址打包成安卓app，一键将网页打包成app，免安装纯绿色版本，快速将网页网址打包成安卓apk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：部分客户需求将自己网站打包成app，供用户在浏览器安装使用、
网页网址快速生成app 准备材料操作流程第一步：打开HBuilder X新建项目第二步创建Wap2App项目第三步修改App图标第四步发布app第五步查看apk 准备材料 1.需要打包的网页
2.app图标（PNG格式）
3.app开幕页图片（非必填有默认效果）
4.安装HBuilder X，并且需要已进行实名认证以及手机号认证HBuilder X实名认证地址
操作流程 第一步：打开HBuilder X新建项目 步骤：打开HBuilder X-》文件-》新建-》项目
第二步创建Wap2App项目 在弹窗内点击Wap2App，输入项目名称以及要打开的网址
第三步修改App图标 创建好项目后项目目录内配置打开manifest.json文件
点击图标配置，上传图标后点击自动生成所有图标并替换
这步非常重要，如果没操作app会使用默认图标
第四步发布app 点击发布-》原生App-云打包
Android证书如果没有证书点击使用公共测试证书
广告联盟默认勾选开屏广告，根据自身情况操作如果没有广告联盟就全部取消勾选
打包过程中弹出弹窗直接点击继续打包
等待控制台执行……
第五步查看apk 等待控制台执行完毕后会出现以下内容，直接点击所有目录就可以看到apk
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b2ffd0bf2fad2af910c81597c48ee80/" rel="bookmark">
			【Redis】 String 字符串类型常见命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🍃前言🎋常见命令🚩set🚩get🚩mget🚩mset🚩setnx 🌳计数命令🚩incr🚩incrby🚩decr🚩decby🚩incrbyfloat 🍀其他命令🚩append🚩getrange🚩setrange🚩strlen 🌲命令小结⭕总结 🍃前言 字符串类型是 Redis 最基础的数据类型，下面将介绍使用该类型时常用的命令，关于字符串需要特别注意：
⾸先 Redis 中所有的键的类型都是字符串类型，⽽且其他⼏种数据结构也都是在字符串类似基础上构建的，例如列表和集合的元素类型是字符串类型，所以字符串类型能为其他 4 种数据结构的学习奠定基础。其次，字符串类型的值实际可以是字符串，包含⼀般格式的字符串或者类似JSON、XML格式的字符串；数字，可以是整型或者浮点型；甚⾄是⼆进制流数据，例如图⽚、⾳频、视频等。不过⼀个字符串的最⼤值不能超过512MB。 🎋常见命令 🚩set 将 string 类型的 value 设置到 key 中。如果 key 之前存在，则覆盖，⽆论原来的数据类型是什么。之前关于此 key 的 TTL 也全部失效。
语法：
SET key value [expiration EX seconds|PX milliseconds] [NX|XX] SET命令⽀持多种选项来影响它的⾏为：
EX seconds 使⽤秒作为单位设置 key 的过期时间。PX milliseconds 使⽤毫秒作为单位设置 key的过期时间。NX 只在 key 不存在时才进⾏设置，即如果 key 之前已经存在，设置不执⾏。XX 只在 key 存在时才进⾏设置，即如果 key 之前不存在，设置不执⾏。 时间复杂度：
O(1) 返回值：
如果设置成功，返回 OK。如果由于 SET 指定了 NX 或者 XX 但条件不满⾜，SET 不会执⾏，并返回(nil)。 🚩get key 对应的 value。如果 key 不存在，返回 nil。如果 value 的数据类型不是string，会报错。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b2ffd0bf2fad2af910c81597c48ee80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d77f30ec98ed0ecec389d0fb939531c/" rel="bookmark">
			Xed编辑器开发第三期:使用Rust从0到1写一个文本编辑器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		继续Xed编辑器开发第二期:使用Rust从0到1写一个文本编辑器的开发进度，这是第三期的内容：
4.1 逐行清除 在每次刷新之前清除整个屏幕似乎不太理想，最好在重新绘制每行时清除每行。让我们删除 Clear(ClearType::All)，而是在我们绘制的每行的末尾使用Clear(ClearType::UntilNewLine)。
impl Output { fn new() -&gt; Self { let win_size = terminal::size() .map(|(x, y)| (x as usize, y as usize)) .unwrap(); Self { win_size, editor_contents: EditorContents::new(), } } fn clear_screen() -&gt; crossterm::Result&lt;()&gt; { execute!(stdout(), terminal::Clear(ClearType::All))?; execute!(stdout(), cursor::MoveTo(0, 0)) } fn draw_rows(&amp;mut self) { let screen_rows = self.win_size.1; for i in 0..screen_rows { self.editor_contents.push('~'); //add the following queue!( self.editor_contents, terminal::Clear(ClearType::UntilNewLine) ) .unwrap(); //end if i &lt; screen_rows - 1 { self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d77f30ec98ed0ecec389d0fb939531c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d22e784db704b3250064e379cdfd566e/" rel="bookmark">
			启动ChatGPT 的快捷键，探索全新 ChatGPT MacOS 应用程序！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主猫头虎的技术世界
🌟 欢迎来到猫头虎的博客 — 探索技术的无限可能！
专栏链接：
🔗 精选专栏：
《面试题大全》 — 面试准备的宝典！《IDEA开发秘籍》 — 提升你的IDEA技能！《100天精通鸿蒙》 — 从Web/安卓到鸿蒙大师！《100天精通Golang（基础入门篇）》 — 踏入Go语言世界的第一步！《100天精通Go语言（精品VIP版）》 — 踏入Go语言世界的第二步！《21天精通IPV4 To IPV6》 — 踏入新IP时代的大门！ 领域矩阵：
🌐 猫头虎技术领域矩阵：
深入探索各技术领域，发现知识的交汇点。了解更多，请访问：
猫头虎技术矩阵新矩阵备用链接 文章目录 启动ChatGPT 的快捷键，探索全新 ChatGPT MacOS 应用程序！如何打开启动器？如何使用启动器？个性化设置总结 启动ChatGPT 的快捷键，探索全新 ChatGPT MacOS 应用程序！ 🚀大家好，我是猫头虎，本周，ChatGPT MacOS 应用程序正式开启了小范围的访问权限测试，今年晚些时候将向所有用户全面开放！你可以通过启动器立即提问、上传文件、截屏或拍照，享受前所未有的便利与高效体验。📱💻
如何打开启动器？ 简单！只需按下 ⌥+ 空格键，即可轻松调出启动器。如果你想更改这个快捷方式，可以在 ChatGPT MacOS 应用程序的“设置”菜单中进行修改。以下是几个截图帮助你更好地理解：
不仅如此，你还可以从菜单栏快捷方式打开启动器，这样就可以随时随地快速访问。
如何使用启动器？ 启动器窗口可以拖动到桌面的任意位置，方便你的操作。
在启动器中，你可以立即开始与 ChatGPT 的新对话。提交提示时，可以单击箭头或按“返回”按钮。
你还可以附加文件或照片、截取屏幕截图，或在开始新对话时通过单击回形针图标并选择上传文件来拍照。
通过请求对 CSV 文件进行数据分析来开始对话，或者直接从启动器询问有关附加图像的问题。
个性化设置 你可以在 ChatGPT MacOS 应用程序的“设置”菜单中更改各种快捷方式和偏好设置，让启动器更加适合你的使用习惯。
总结 通过 ChatGPT MacOS 启动器，你可以方便快捷地与 ChatGPT 互动，上传文件、截屏或拍照，享受无缝连接的智能助手体验。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d22e784db704b3250064e379cdfd566e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e37335479f00b588e5c301f25cc57c2f/" rel="bookmark">
			查找效率满分的算法—— “二分查找” 算法 （Java版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇会加入个人的所谓鱼式疯言
❤️❤️❤️鱼式疯言:❤️❤️❤️此疯言非彼疯言
而是理解过并总结出来通俗易懂的大白话,
小编会尽可能的在每个概念后插入鱼式疯言,帮助大家理解的.
🤭🤭🤭可能说的不是那么严谨.但小编初心是能让更多人能接受我们这个概念 ！！！
前言 在前面的章节中，我们学习了 "双指针"算法 ， “滑动窗口"算法
而在本篇章节 ， 我们期待已久的 “二分查找”算法 即将登场， 透露下本次算法主要的规划 💖 💖 💖
目录 二分算法的初识
二分算法的应用
二分算法的总结
一. 二分算法的初识 1. 二分算法的简介 二分算法，也被称为 二分查找 算法，是一种常用的查找 算法。
它的基本思想是将已排序的数据序列分成 两部分 ，取中间 的元素与 目标值 进行比较，然后根据比较结果，确定目标值 在左半部分还是 右半部分，再继续在相应的部分进行 查找，直到找到目标值或者确定目标值 不存在 为止。
2. 二分算法的使用步骤 因为二分查找算法分为两种：
“一种是 朴素二分查找” 算法， 另外一种是 "左右边界二分查找 " 算法
因为朴素二分查找比较基础，我们先学习基础版本的，再调整有难度的 💖 💖 💖
小编在这里说明 “朴素二分查找” 的具体步骤哦
先拿个题目来瞧瞧呗
二分查找 704.二分查找题目链接
&lt;1&gt;. 题目描述 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e37335479f00b588e5c301f25cc57c2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b19e6a832dc09ee768e169eb020abdc1/" rel="bookmark">
			PHP传输base64数据不完整解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近在做OCR增值税务处理时，接口是通过图片转base64提交处理然后返回数据的，我通过前端将图片转换为base64提交到后端接收时，通过在线工具进行测试，发现传递过去的数据可以使用，接收到的数据却提示损坏
解决办法 将
&lt;?php header('Content-Type: text/html; charset=utf-8'); header('Access-Control-Allow-Origin: *'); // 允许任何网址请求 header('Access-Control-Allow-Methods: POST, GET, OPTIONS, DELETE'); // 允许请求的类型 header('Access-Control-Allow-Credentials: true'); // 设置是否允许发送 cookies header('Access-Control-Allow-Headers: Content-Type, Content-Length, Accept-Encoding, X-Requested-with, Origin'); // 设置允许自定义请求头的字段 // 接收POST数据 $base64=$_POST['base']; 替换为以下代码：
&lt;?php header('Content-Type: text/html; charset=utf-8'); header('Access-Control-Allow-Origin: *'); // 允许任何网址请求 header('Access-Control-Allow-Methods: POST, GET, OPTIONS, DELETE'); // 允许请求的类型 header('Access-Control-Allow-Credentials: true'); // 设置是否允许发送 cookies header('Access-Control-Allow-Headers: Content-Type, Content-Length, Accept-Encoding, X-Requested-with, Origin'); // 设置允许自定义请求头的字段 // 接收POST数据 $postData = file_get_contents('php://input'); $base64=urldecode($postData); $new_base64 = substr($base64, 27); 即可解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a95d3b170679c56dcdfa79584884ce84/" rel="bookmark">
			安卓手机投屏到电脑，这5个手机投屏软件超简单！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在电脑上工作时，拿起手机查看通知和信息可能会很烦人，但你又不想错过任何重要信息。因此，将手机屏幕投屏到电脑是解决这一问题的最佳选择。通过本篇文章，你可以将安卓手机屏幕投屏到电脑，这无疑有助于提高你的工作效率、专注度和生产力。
第1部分：安卓手机可以投屏到电脑吗？ 是的，你可以通过以下多种方式将安卓手机投屏到电脑上。通过使用一些投屏软件，你可以在工作中节省大量时间和精力，甚至还可以在下次家庭聚餐时在大屏幕上展示你手机中的度假照片。
第2部分：安卓手机投屏到电脑的5个方法详细介绍 现在，我们将介绍一些可以帮助你将手机投屏到电脑的简单方法。它们都支持安卓手机投屏，让我们期待一下吧。
方法一：使用金舟投屏软件 第一种方法是使用金舟投屏软件，该软件支持手机投屏电脑，电脑控制手机等功能，允许你在无线网络，USB数据线的情况下将手机屏幕投屏到电脑显示屏上。让我们看看具体怎么操作吧：
操作环境：
演示机型：华为MateBook D
系统版本：Windows 10
软件版本：金舟投屏 v2.3.0
第1步、在你的电脑和手机上打开该投屏软件。并且记住电脑端上显示的【设备名称】。
第2步、手机打开软件后，软件会自动查找附件的设备，选择需要投屏到的电脑设备名称，点击即可。
第3步、返回电脑端，在弹出的窗口中点击【确认连接】按钮。
第4步、点击后，软件会开始连接。等待片刻，你的安卓手机就成功地投屏到电脑上了。如果需要结束投票，点击手机端的【断开投屏】按钮或者点击电脑端的【结束投屏】按钮就可以了。
方法二：使用Screen Cast安卓投屏软件 Screen Cast 是安卓用户将手机投屏到电脑的另一种方法。该工具不仅允许你手机投屏到电脑，还支持手机投屏电视。你可以根据自己的需求，选择自己想要的方式。
操作环境：
演示机型：华为MateBook D
系统版本：Windows 10
软件版本：Screen Cast
第1步、首先先将手机和电脑连接至同一WiFi网络下。然后手机打开该APP，选择【Wi-Fi Network】。
第2步、点击【start broadcasting】，然后，会出现一个URL链接。
第3步、然后，在你的电脑上打开浏览器输入该链接。稍等片刻，你就可以看到你的手机被展现在电脑显示屏上了。
方法三：使用Phone Mirror安卓投屏软件 Phone Mirror是一款支持安卓手机投屏和苹果手机投屏的软件，可让您使用 USB 数据线手机屏幕投屏到电脑。使用该方式将安卓手机投屏到电脑的方法如下：
操作环境：
演示机型：华为MateBook D
系统版本：Windows 10
软件版本：Phone Mirror v3.0.1
第1步、首先请确保你的电脑和手机上有该软件。然后用手机数据线将手机连接到电脑上，点击【How to enable USB debugging on Android devices】可以查看开启手机上的USB调试功能教程。
第2步、一旦软件检测到你的安卓手机时，点击设备右侧的投屏按钮即可开始投屏。
第3步、现在，你的手机屏幕已成功显示在电脑上。你可以用键盘和鼠标控制它，还可以截图、录屏等。
方法四：使用FlashGet Cast安卓投屏软件 FlashGet Cast是一款支持安卓手机投屏到Windows电脑的实用工具。该软件能供保障清晰的视频、游戏、音乐和照片流。它甚至还能让你将 Windows 屏幕投射到电视上。以下是安卓手机投屏电脑的几个简单步骤。
操作环境：
演示机型：华为MateBook D
系统版本：Windows 10
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a95d3b170679c56dcdfa79584884ce84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41b25fa958a75c0c6d2ef6fa3f36cddb/" rel="bookmark">
			基于【文心智能体平台】零代码搭建我的AI情感应用：心声导航
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 最近百度【文心智能体平台】在举办文心智能体大赛文心智能体大赛_文心智能体大赛-飞桨AI Studio星河社区，开发主题是”生活情感“，借此机会我也学习了解了一下文心智能体平台，也参与开发了一个AI情感应用【心声导航】，旨在帮助用户解决在两性交友过程中的情感问题，了解伴侣内心的真实想法。体验地址：
心声导航
介绍： 文心智能体平台是百度推出的基于文心大模型的智能体（Agent）平台，支持广大开发者根据自身行业领域、应用场景，选取不同类型的开发方式，打造大模型时代的产品能力。开发者可以通过 prompt 编排的方式低成本开发智能体（Agent），同时，文心智能体平台还将为智能体（Agent）开发者提供相应的流量分发路径，完成商业闭环。
它的优势有：
强大的大模型能力： 依托文心一言大模型，在内容创作、数理逻辑推算、中文理解、多模态生成等多方面均有良好表现；
多样化的方式链接用户：开发者可选取不同类型的开发方式、模板组件等进行接入，包括零代码/低代码智能体、数据类/能力类插件，为 C 端用户提供更加优质服务；
多场景触达用户：传统搜索 &amp; AI搜索双引擎分发；文心一言 App 内调用插件；智能体&amp;插件可进入体验中心，对 C 端用户分发的同时也面向企业级开发者。
创建应用： 文心智能体平台地址：文心智能体平台 | 想象即现实，更接近大众化的AI应用构建平台
快速构建 对于新手而言通过快速构建智能体是非常不错的方法，比如直接输入名称、设定两项即可自动完成相关信息配置。
如果你是老选手了，那么可以直接通过跳过操作，直接开始编辑相关信息。
基础配置： 头像： 系统默认自动生成一张应用头像图片，也支持自定义上传，或者对生成的图片不满足，还可以继续点击AI生成再次推荐一张图片。建议比例1:1 / 支持格式png、jpg、jpeg、webp
名称： 填写应用名称：心声导航
简介： 填写应用的介绍：帮助用户解决两性交友中的交流误解，发掘伴侣内心的真实想法
指令： 填写应用的提示词
### 角色与目标 **你是一个情感专家**，专注于用温暖和同理心去理解并化解用户伴侣之间的情感困扰。你的主要目标是帮助用户解决两性交友中的交流误解，发掘伴侣内心的真实想法，以及指引他们走出情感的迷雾，使爱情关系重回和谐与理解。 ### 指导原则 1. **倾听与理解**：首先倾听用户的问题和困扰，然后深入理解他们的情感和需求。 2. **同理心**：设身处地地感受用户的情绪，用温暖的话语为他们提供支持和建议。 3. **专业性**：基于心理学和情感沟通的原理，为用户提供专业的解答和指导。 ### 限制 * 你不能代替专业的心理咨询或婚姻咨询。 * 对于涉及到法律、医疗等专业领域的问题，你可能无法提供详尽的答案。 ### 澄清 * 你可以为用户提供情感沟通、关系处理的建议。 * 你的回答和建议基于一般的心理学和情感交流原则，具体实施时仍需用户根据实际情况进行调整。 ### 个性化 作为情感专家，你充满智慧和同理心。你总是能够准确地捕捉到用户的真实感受，用温暖和体贴的话语为他们排忧解难。你不仅是一个解答者，更是一个倾听者，让用户感受到被理解和支持。 开场白： 该描述将在欢迎气泡内作为智能体开场白展示给用户。
有两种选择，一种是默认的普通方式，一种是定制方式
引导提示： 填写默认提示问题示例，方便用户使用和参考
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41b25fa958a75c0c6d2ef6fa3f36cddb/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/348/">«</a>
	<span class="pagination__item pagination__item--current">349/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/350/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>