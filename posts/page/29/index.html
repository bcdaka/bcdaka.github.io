<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41f249d5bc77cc8114cd599433e6a250/" rel="bookmark">
			外包干了8天，技术退步明显。。。。。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先说一下自己的情况，本科生，19年通过校招进入杭州某软件公司，干了接近3年的功能测试，今年年初，感觉自己不能够在这样下去了，长时间呆在一个舒适的环境会让一个人堕落!而我已经在一个企业干了四年的功能测试，已经让我变得不思进取，谈了2年的女朋友也因为我的心态和工资和我分手了。于是，我决定要改变现状，冲击下大厂。
刚开始准备时，自己都蒙了，四年的功能测试让我的技术没有一丝的进步，提升的只有我的年龄…
没办法，我找到了我在腾讯的老哥，作为他的小老表，在他了解了我的情况后(几乎就是软件测试基础开始)，直接甩给我一个网盘，说到：“去吧，这里有你需要的所有东西，不要来找我了，我都嫌丢人!”。
盘里头是一整套软件测试面试必备文档PDF，和完整学习路线视频教程，看完之后直接给我老哥给跪了…这下面试稳了
内容涵盖：包括测试理论、Linux基础、MySQL基础、Web测试、接口测试、App测试、管理工具、Python基础、Selenium相关、性能测试、LordRunner相关等… 质量非常高，需要的可自行领取！！
第一部分，测试理论（测试基础+需求分析+测试模型+测试计划+测试策略+测试案例等等）
第二部分，Linux（ Linux基础+Linux练习题）
第三部分，MySQL（基础知识+查询练习+万年学生表经典面试题汇总+数据库企业真题）
第四部分，Web测试
第五部分，API测试
第六部分，App测试
第七部分，管理工具
第八部分，Python基础（Python基础+编程题+集合+函数+Python特性等等）
第九部分，Selenium相关
第十部分，性能测试
第十一部分，LordRunner相关
第十二部分，计算机网络
第十三部分，组成原理
第十四部分，数据结构与算法
第十五部分，逻辑题
第十六部分，人力资源
软件测试基础
软件测试的步骤是什么?
如何录制测试脚本?
应该考虑进行如何测试的测试方法
怎样估计测试工作量?
测试设计的问题
当测试过程发生错误时，有哪几种解决办法?
测试执行的问题
测试评估的目标
如何提高测试?
C/S模式的优点和缺点
B/S模式的优点和缺点
…
Linux
grep和find的区别? grep 都有哪些用法?
查看IP地址?
创建和删除一个多级目录?
在当前用户家目录中查找haha.txt文件?
如何查询出tomcat的进程并杀掉这个进程，写出linux命令?
动态查看日志文件?
查看系統硬盘空间的命令?
查看当前机器listen 的所有端口?
…
Python
统计python源代码文件中代码行数，去除注释，空行，进行输出?
python调用cmd并返回结果?
冒泡排序
1,2,3,4 这4个数字，能组成多少个互不相同的且无重复的三位数，都是多少?
请用 python 打印出 10000 以内的对称数（对称数特点：数字左右对称，如：1,2,11,121,1221 等）
给定一个整数 N，和一个 0-9 的数 K，要求返回 0-N 中数字 K 出现的次数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41f249d5bc77cc8114cd599433e6a250/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6532de1ec31bef0b04686b397e40bb02/" rel="bookmark">
			[000-01-022].第03节：RabbitMQ环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的后端学习大纲
RabbitMQ学习大纲
1.rpm包方式搭建： 1.1.搭建RabbitMQ单体架构： 1.MQ下载地址2.这里是提前下载好后上传安装包到服务器得opt目录下：
3.安装MQ需要先有Erlang语言环境，安装文件的Linux命令(分别按照以下顺序安装) rpm -ivh erlang-21.3-1.el7.x86_64.rpm # i的意思就是安装的意思，vh意思就是显示安装进度 yum install socat -y #（这个是安装需要的依赖，需要在连接网络下进行安装） rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm 4.常用的命令
添加开机启动 RabbitMQ 服务：chkconfig rabbitmq-server on启动RabbitMQ服务：/sbin/service rabbitmq-server start查看服务状态：/sbin/service rabbitmq-server status停止服务(选择执行)：/sbin/service rabbitmq-server stop 5.给Rabbitmq安装Web界面插件:
rabbitmq-plugins enable rabbitmq_management 6.插件安装完毕后，可以登录管理平台MQ管理平台，
7.在登录之前一定要再重启服务，且关闭防火墙
查看防火墙状态：systemctl status firewalld关闭防火墙：systemctl stop firewalld开机不自动启动防火墙：systemctl enable firewalld
8.浏览器访问MQ管理平台：http://192.168.148.3:15672
9.Rabbitmq添加一个用户
添加一个新的用户以便登录后台管理系统创建账号：rabbitmqctl add_user admin 123 账号和密码是：admin和密码123设置用户角色：rabbitmqctl set_user_tags admin administrator设置用户权限：set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;； 比如： rabbitmqctl set_permissions -p "/" admin ".*" ".*" ".*" 用户 user_admin 具有/vhost1 这个 virtual host 中所有资源的配置、写、读权限当前用户和角色：rabbitmqctl list_users
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6532de1ec31bef0b04686b397e40bb02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad6218bb7d91baae866bd2b9acb2928d/" rel="bookmark">
			天龙八部万象归一第8版单机安装教程&#43;GM工具&#43;虚拟机一键端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给大家带来一款单机游戏的架设：天龙八部万象归一第8版。
另外：本人承接各种游戏架设（单机+联网）
本人为了学习和研究软件内含的设计思想和原理，带了架设教程仅供娱乐。
教程是本人亲自搭建成功的，绝对是完整可运行的，踩过的坑都给你们填上了。
如果你是小白也没问题，跟着教程走也是可以搭建成功的，但是一定要有耐心。。。
视频演示 天龙八部万象归一第8版单机安装教程+GM工具+虚拟机一键端
服务器架设 此游戏架设需要虚拟机，没有虚拟机的移步
虚拟机设置IP 打开虚拟机，左上角编辑-&gt; 虚拟网络编辑器 , 选择VMnet8 ，更改设置
选中v8首先我们还原一下
再次选择 VMnet8 ，子网ip改成 192.168.9.0 然后点击确定。
找到本地电脑的网络连接， 修改v8网卡的属性，修改成如下图:
修改后记得禁用在启用设置一下。到此网络设置完毕！
切换到到虚拟机，选择虚拟机上面的文件 --&gt; 打开 找到我们的服务端 加载镜像vmx。
游戏文件我已经准备好了，移步下载处: gitee典康姆/lz-code/game_01.git (注意修改典康姆)
打开后，虚拟机会多一个系统，点击开启虚拟机，弹窗选择 "我已移动改虚拟机"
同理打开xp镜像，并且启动
进到xp系统里面， 运行第一步，然后连接
连接成功后，点击下面的一
等待日志出现 start completely
然后双击启动第二步
客户端 找到万象7单机登录器.exe双击进入游戏即可
账号登陆即注册，注意账号的长度必须在6位以上，输错了的话要重新解压客户端。
GM工具 工具在xp系统里面，需要自己研究
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6197d85dd1c75857defccb8c8983c900/" rel="bookmark">
			KT来袭，打造沉浸式体验的聚合性web3应用平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着步入 2024，漫长的区块链熊市即将接近尾声。纵观产业发展，逆流而上往往会是彰显品牌市场影响力和技术实力的最佳证明。在这次周期中，一个名为KT的web3.0聚合平台吸引了市场关注，无论在市场层面还是技术层面，都广泛赢得了 Web3 众多生态伙伴的认可和赞誉。
KT是一个采用区块链技术和智能合约设计的开创性的全球加密货币生态系统，拥有最大的web3社区之一，拥有超过200万成员。该平台提供一系列基础设施和营销解决方案，包括专有的元宇宙互动、游戏化的NFT。目前，KT正在打造一个为用户提供流畅且沉浸式娱乐体验的聚合性Web3应用平台。
目标是建立一站式枢纽，用户在一个平台内即可以快速、安全、无需许可的、具有激励的和去中心化的方式获得各种娱乐资源，包括但不限于多款链游、流媒体直播、社交Dapp、元宇宙和AR/VR。
在加密金融市场上，KT凭借几大优势脱颖而出：
1） 实力强劲，项目天使轮融资估值1000万美金；
2） 团队经验丰富。技术上优先开发自己可控品质的游戏而脱颖而出，市场营销方面则有圈内多年的运营资源；
3） 平台操作简单，主要迎合Web2用户，特别是在东南亚、东亚、中东和北美等成熟的游戏地区，未来用户量将爆发性增长；
4） 为优质NFT赋能，通过和圈内知名优质项目合作，打造品牌口碑，且为平台持续吸引Web3用户；
5） 平台的盈利策略围绕用户通过完成任务赚取利润，用户还可参与流通代币挖矿。这种方法有机地引入了 Web3 概念，有助于经济高效地获取新用户，并鼓励其过渡到Web3。
Web3 的引人入胜之处在于其日新月异，KT作为新时代的顶级AI聚合服务平台，焕新起航，将定位于 Web3 新兴生态的安全服务和基础设施建设，未来，KT将欢迎更多开发者与投资者探索智能经济。通过帮助用户利用智能合约实现资产管理的数字化和自动化，共同进入未来繁荣的数字世界。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d681ee54a6ad811a3488d4de99447367/" rel="bookmark">
			C:每日一练：单身狗（2.0版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 今天在刷题的时候突然看到一道题，疑似一位故题。仔细一看，欸！这不是就是单身狗的升级版吗？我想那必须再安排一篇，不过由于本篇文章与上一篇单身狗文章所涉及的知识点基本相同，所以还请大家见谅！
我写的开心，大家也看个乐呵！不过还请单身的人不要介意，单纯觉得比较有意思，无意冒犯！毕竟连小编自己都是单身狗。
后续小编也会尽快更新完指针相关知识点！
一、题目： 在一场专为情侣们策划的盛宴中，竟然有两名单身者悄然混入。宴会的主人感到十分不悦，并寻求你的帮助，希望你能运用你敏锐的洞察力，协助她识破并找出这两名不合规矩的单身者。
（无意冒犯，只是提供一个题目的背景）
例如：
有数组的元素是：1，2，3，4，5，6，1，2，3，4，5，7
只有6和7只出现1次，要找出6和7.
二、代码展示（无注释的） 如果有想先自己思考的可以先看一看这个代码，后面也会有解析
#include &lt;stdio.h&gt; int find(int num) { int index = 0; while ((num &amp; 1) == 0 &amp;&amp; index &lt; 32) { num &gt;&gt;= 1; index++; } return index; } void single(int arr[], int sz, int* n1, int* n2) { int Re = 0; for (int i = 0; i &lt; sz; i++) { Re ^= arr[i]; } int index = find(Re); *n1 = *n2 = 0; for (int i = 0; i &lt; sz; i++) { if (((arr[i] &gt;&gt; index) &amp; 1) == 1) *n1 ^= arr[i]; else *n2 ^= arr[i]; } int main() { int arr[] = {1,2,3,4,5,6,1,2,3,4,5,7}; int n1, n2; int sz = sizeof(arr) / sizeof(arr[0]); single(arr, sz, &amp;n1, &amp;n2); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d681ee54a6ad811a3488d4de99447367/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/505b44d54af84112c8bc1c9e578a8c90/" rel="bookmark">
			Kafka之RecordAccumulator
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章将主要介绍 Kafka 生产者中的 RecordAccumulator。RecordAccumlator 负责对生产者将要发送的消息进行分组缓存，其内部对每个 topic 维持了一个 TopicInfo 来存储缓存的消息，TopicInfo 内部对该 topic 的每个 partition 维持了一个队列，消息被聚合成 ProducerBatch 存储在队列中。sender 线程每次对队列中聚合的 ProducerBatch 进行发送，从而减少网络传输的资源消耗，提升性能。
1. 计算 Partition 在将消息放入 RecordAccumulator 之前，首先要计算分区 partition。在 doSend() 方法中通过调用 partition() 来计算消息的分区。
private Future&lt;RecordMetadata&gt; doSend(ProducerRecord&lt;K, V&gt; record, Callback callback) { // Try to calculate partition, but note that after this call it can be RecordMetadata.UNKNOWN_PARTITION, // which means that the RecordAccumulator would pick a partition using built-in logic (which may // take into account broker load, the amount of data produced to each partition, etc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/505b44d54af84112c8bc1c9e578a8c90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94b61dd98b1429a8954a34f41738ddb5/" rel="bookmark">
			AutoGPT开源项目解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AutoGPT开源项目解读 (qq.com)
AutoGPT旨在创建一个自动化的自我改进系统，能够自主执行和学习各种任务
项目基本信息 首先阅读项目的README.md，下述代理和智能体两个名词可互换
项目简介：一个创建和运行智能体的工具，这些智能体可以自动执行各种任务，简化生活。
入门指南：该项目由两部分组成，前端（AutoGPT Builder）和后端（AutoGPT Server ），在rnd目录下。前端用于设计代理，流程图的方式连接操作块。后端运行代理，一经触发持续运行。举例，youtube内容再利用代理，发布新视频后转录并编写搜索引擎优化的博客文章，发到其他账户。
项目目标：构建、测试、委托。有一个想法，构建去实现，测试变完美，委托让AI为你工作。
AutoGPT经典版
简介：提供了构建和管理代理的工具
Forge：提供智能体应用模板，用于创建智能体
Benchmark：创建测试环境，衡量智能体性能
UI：前端界面
CLI：命令行界面
姊妹项目：Agent Protocol，采用AI工程师基金会的代理协议标准，规范代理到前端和基准的通信路径，及与其他程序的兼容
项目后端架构综述 项目后端架构的核心是AutoGPT Server，它负责运行和管理智能体（代理）。使用Python和FastAPI构建，支持异步操作和面向对象设计。关键组件包括：
Agent Factory：创建和管理AI代理。
Agent：智能代理系统，负责行为决策和执行。
App：包含配置管理、命令行界面、遥测设置等。
部署需要Node.js和Python 3.10，通过.env文件配置API密钥，使用pip和poetry管理依赖。数据管理采用Prisma ORM，支持异步数据库操作。任务调度使用APScheduler库，优化并发执行。
通信基于WebSocket，包括用户认证和数据库交互。自动化框架涵盖语言模型调用、HTTP请求等。图计算框架处理图的创建和调度。任务执行系统使用asyncio和ProcessPoolExecutor。
项目还包括CLI工具和脚本，简化开发流程。前端基于Flutter，后端服务通过FastAPI提供。整体架构设计为模块化，易于扩展，支持自动化任务的创建、测试和执行
官方文档解读 官方文档网址：AutoGPT Documentation (agpt.co)
项目组成：五个主要组件，Server、Agent、Benchmark、Forge、Frontend，另有一个CLI串联这些组件
Forge，官方文档显示不再使用。
部署运行
1.前置条件：安装node，python3.10
2.配置环境.env，主要是openai api key
3.后端项目部署运行：rnd/autogpt_server/readme.md中的命令，主要是用pip、 poetry安装依赖、prisma数据库，及启动（pip包安装器，不安装子依赖；poetry提供了更全的项目管理功能，包括子依赖）
4.前端项目部署运行：rnd/autogpt_builder/readme.md，npm安装对应依赖及启动
主要文件夹功能 autogpt
autogpt/agent_factory:
构成了AutoGPT框架中用于创建和管理AI代理的核心组件。configurators.py负责配置代理，generators.py异步生成代理，而profile_generator.py与语言模型交互以获取代理配置。系统通过动态配置文件和指令集，实现了高度灵活性和自动化的代理生成流程。
autogpt/agent:
组成了一个智能代理系统，包括代理行为决策、执行、历史记录和状态管理。agent.py 定义了核心代理逻辑，agent_manager.py 负责代理的创建和管理，而 one_shot.py 处理一次性行动提案和提示策略。系统采用异步编程和面向对象设计，具备日志记录和错误处理功能
autogpt/app:
构成了AutoGPT应用程序的核心组件，一个基于人工智能的自动化工具。它们包括配置管理（config.py和configurator.py）、命令行界面（cli.py）、初始化脚本（__init__.py）、加载动画（spinner.py）、遥测设置（telemetry.py）、实用工具函数（utils.py）、主程序入口（main.py）、用户输入处理（input.py）、服务器协议实现（agent_protocol_server.py）以及AI设置交互式配置（setup.py）。这些模块协同工作，允许用户通过CLI与AutoGPT交互，配置和执行自动化任务，同时提供遥测和日志记录功能，确保了应用程序的灵活性和可扩展性
./_init_.py
./_main_.py
_init__.py文件负责在测试或CI环境中设置随机种子，以确保结果的可重复性。__main__.py文件定义了程序的入口点，通过调用autogpt.app.cli.cli()函数来启动命令行界面，允许用户与AutoGPT进行交互。整体上，这些文件为AutoGPT的运行和测试提供了必要的配置和启动机制
script:
依赖检查工具check_requirements.py，自动验证项目依赖；基于Git日志生成发布说明的工具git_log_to_release_notes.py，简化文档编写；以及模型服务部署脚本serve.py，用于快速部署和提供AI模型服务。它们共同支持自动化和简化软件开发流程
rnd
market：开放的AI代理平台，AI解决方案，提供多种功能，如代理搜索、详细列表、用户资料和数据保护
autogpt_builder：前端项目包，基于flutter框架，dart语言，可使用移动和web终端
autogpt_server：后端项目启动
autogpt_server
./setup.py
./linter.py
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94b61dd98b1429a8954a34f41738ddb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55015070a6ee51ff755e0be6be1a64fe/" rel="bookmark">
			使用maven快速生成打包文件2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面介绍了使用Maven打包基于SpringBoot开发的微服务，打出的JAR包包含所有的依赖，因此一般包比较大，可能会有几百M，但是有时候在调试阶段，经常需要更新程序，每更新一次就要上传几百M的JAR包，特别不方便，因此这里提供一种方法将依赖的JAR包统一放到lib目录中，这样打出的微服务包就很小了，更新起来也方便很多。先上pom.xml文件
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;kafka-roma&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;name&gt;kafka-roma&lt;/name&gt; &lt;description&gt;kafka-roma&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;spring-boot.version&gt;2.6.13&lt;/spring-boot.version&gt; &lt;maven.test.skip&gt;true&lt;/maven.test.skip&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt; &lt;version&gt;2.7.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;2.0.52&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-boot.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;finalName&gt;${project.artifactId}&lt;/finalName&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;excludes&gt; &lt;exclude&gt;*.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55015070a6ee51ff755e0be6be1a64fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b50ccac906902b7b8dc9491f5ca1a91b/" rel="bookmark">
			Apache CloudStack Official Document 翻译节选（八）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于 Apache CloudStack 的 最佳实践 （二）
防火墙的设定
Hardware Firewall
部署Apache CloudStack时，建议部署一套防火墙系统已保护Apache CloudStack的云管理服务。在防火墙的选用方面，既可以使用通用防火墙、也可以使用诸如Juniper SRX一类的专用防火墙。
硬件防火墙的选用要能满实现以下两个目的：
保护好Apache CloudStack的云管理服务。配置网络地址转换和端口转发后，应该能管控来自公网的对Apache CloudStack的云管理服务访问流量。在多个专职地带间路由云内管理网流量，多个专职地带间的点对点VPN也需要被配置。 要实现上述目的，你必须为硬件防火墙设置固定的配置项。硬件防火墙的规则策略不能像Apache CloudStack云内的软件防火墙那样可变。任何支持网络地址转换和点对点VPN的硬件防火墙都可使用。
对Juniper SRX系列防火墙集成云外的客户机网路防火墙：
【仅适用于使用了高级网络模型的虚拟机实例】
Apache CloudStack提供了直接管理Juniper SRX系列防火墙的服务，这允许Apache CloudStack建立公网IP到虚拟机实例的静态NAT映射、并用Juniper SRX系列防火墙取代服务于云内防火墙服务的虚拟路由器。在每个专职地带中可以使用一个或多个Juniper SRX系列防火墙。如果Juniper SRX系列防火墙中没有提供一体化功能，Apache CloudStack仍会使用服务于云内防火墙服务的虚拟路由器。
Juniper SRX系列防火墙可以和云外负载均衡器协同使用。云外的网路元素可以以并联配置或串联配置的形式部署。
在Apache CloudStack和Juniper SRX系列防火墙联用是应当这样配置：
根据Juniper SRX系列防火墙使用说明安装SRX应用程序。把一个网口连接到Apache CloudStack的云内管理网路、一个网口连接到公网。或者，你也可以把同一个网口接入到Apache CloudStack的云内管理网路和公网中（需要用VLAN区分出公网流量）。确保在对云内的网口上启用了VLAN的TAG标记。记录对公网和对云内网的网口名称。如果你在对公网的网口上使用了VLAN ，那就在此网口之后添加VLA-TAG标签。例如，假定你使用网口ge-0/0/3 作为对公网的网口、且计划使用的VLAN-TAG是301，那么这个网口应该被配置为“ge-0/0/3.301”、此时对云内网的网口应当保持无VLAN-TAG状态。Apache CloudStack会自动创建打了VLAN-TAG的逻辑网口。创建一个公网的安全地带和云内网的安全地带。默认情况下他们是已经创建好的，安全地带内外分别被称作可信区和不可信区。把对公网的网口放入到公网安全地带、把对云内网的网口放入到云内网的安全地带，并记下安全带带的名称。确保在公网安全地带和云内网安全地带之间有允许网路流量通过的安全策略。当Apache CloudStack组件是编程规则时，请记下你希望它登录的账户的用户名和密码。确保 “ssh”和“xnm-clear-text”服务处于启用状态。如果你期望网络流量可被测量： 可以创建一条入栈防火墙规则和出栈防火墙规则，他们应分别和公网的安全地带及云内网的安全地带名称相同、且设定为“特定接口”。例如当公网的安全地带为不可信区、云内网的安全地带为可信区时，应配置成如下防火墙规则： 把防火墙规则添加到你的对公网网口上。例如，对公网的网口是 ge-0/0/3.0、公网的安全地带为不可信区、云内网的安全地带为可信区时应配置成如下防火墙规则： 确保所有的VLAN 都可被带到对云内网的网口。Apache CloudStack云管理服务比安装后，要以“administrator”登录到Apache CloudStack的web-Portal。在Apache CloudStack的web-Portal的左侧导航栏中点击“基础设施”。浏览安全地带中的更多内容。选中你计划使用的安全地带。点击“网络”标签。在“网络服务提供者”的图标中点击“配置”。点击“SRX”。填写如下信息： ·IP地址：SRX的IP地址
·用户名：SRX上供Apache CloudStack账户使用的用户名
·密码：SRX上供Apache CloudStack账户使用的用户密码
·对公网网口：SRX上对公网的网口，参考格式为 ge-0/0/2.VLAN-ID
·对云内网网口：SRX上对公网的网口，参考格式为 ge-0/0/1
·网路流量测定网口：用于测定网路流量的网口，默认为对公网网口
·尝试次数：在SRX上执行命令的尝试次数，默认为2次
·超时时间：在SRX上执行命令后的等待时长，默认为300秒
·公网名称：在SRX上的对公网名称，例如“trust”
·云内网名称：在SRX上的对云内网名称，例如“untrust”
·网路容量：SRX设备能够处理的网路数量
·专注性：当SRX设备被标记为“专注”后，它将被分配给某单一账户。此时上述“网路容量”中设定的值将无意义、这个值实际上会成为“1”。
点击“O.K.”。 点击“全局设定”，给“external.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b50ccac906902b7b8dc9491f5ca1a91b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66e4258a2fee862c0e0c168097357c49/" rel="bookmark">
			javaEE——过滤器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.过滤器简述 Filter 也称之为过滤器，它是Servlet技术中最实用的技术，WEB开发人员通过Filter技术，对web服务器管理的所有web资源： 例如Servlet, 从而实现一些特殊的功能。 例如实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。 2.过滤器的作用 对服务器web资源进行拦截 （权限控制，通过拦截资源进行权限控制，是否可以访问） 3.过滤器怎么创建？ Servlet API中提供了一个 Filter接口 ，开发web应用时，如果编写的Java类 实现了这个接口 ，则把这个java类称之为 过滤器Filter 。通过Filter技术，开发人员可以实现用户在访问某个目标资源之前，对访问的请求和响应 进行拦截 4.过滤器接口 Servlet API 中，与过滤器有关的API共有三个接口，分别是 ● Filter ● FilterChain ● FilterConfig 5.Filter接口 Filter接口是过滤器类必须实现的接口，该接口中有三个方法:
● init(FilterConfig filterConfig)： 该方法是对filter对象进行初始化的方法，仅在容器初始化filter对象结束后被调用一次。参数 FilterConfig可以获得filter的初始化参数。 ● doFilter(ServletRequest request, ServletResponse response, FilterChain chain)： 该方法是filter进行过滤操作的方法，是最重要的方法。过滤器实现类必须实现该方法。方法体中可以对request和response进行预处理。其中FilterChain可以将处理后的request和response对象传递到过滤链上的下一个资源。 ● destroy()： 该方法在容器销毁过滤器对象前被调用 6.过滤器的特点 ● 过滤器用来实现通用的功能， 减少代码冗余 ，提高可维护性 ● 一个过滤器 可以配置给 多个资源 使用 ● 一个资源 也可以配置 多个过滤器 ，按照配置顺序调用 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e4565188b6b3714186d76ffd21fd334/" rel="bookmark">
			汉服推广网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@TOC
springboot0790汉服推广网站 绪论 1.1研究背景 随着网络不断的普及发展，汉服文化平台网站依靠网络技术的支持得到了快速的发展，首先要从用户的实际需求出发，通过了解用户的需求开发出具有针对性首页、汉服知识、服装展示、用户相册、论坛交流、个人中心、后台管理、购物车、在线客服的功能，利用目前网络给用户带来的方便快捷这一特点对系统进行调整，设计的系统让用户的使用起来更加方便，本系统的主要目的就是给用户带来快捷与高效、安全，用户只要在家中就可以进行操作[1]。同时随着电子商务的发展汉服文化平台网站已经受到广大用户的关注。
互联网发展至今，已经解决了很多我们解决不了的难题，使得我们工作更加便捷，提高了我们的工作效率。目前各行各业都在运用网络信息管理程序，不同的用户也都接触到信息管理，特别是在各大电商行业广泛的应运起来。通过对当前网络环境发展的分析与总结，开发汉服文化平台网站可以改变以往的汉服文化平台网站方式，改变传统线下汉服文化平台网站的状态，由于汉服的不断增多，使用传统的线下手工模式已经远远不能满足于用户需求了，而且越来越多的商家也在开通线上进行汉服文化平台网站，所以开发一个汉服文化平台网站可以解决用户不利于线下汉服文化平台网站的问题，同时管理员可以利用网络对汉服文化平台网站信息进行管理，设计的网站保证信息的完整安全，这样才能提高工作效率，保证系统安全正常的运行[2]。
1.2研究现状 在国外他们的信息技术的发展是我国的许多倍，从1946年诞生在美国的世界上第一台计算机开始，国外的信息技术就一直在飞速地发展，一些计算机应用软件也纷纷出现，软件技术也一直在不断完善和更新[3]。软件行业早已遍布各个地方。
在国内，我国信息技术发展起步比较晚，后期慢慢的不断地进行优化和改革，才让我们的信息技术上升到新的阶段。在现在软件开发的技术经过大量研究和生活实践基本能够达到独立开发系统应用的水平，生活中的各个行业也把软件操作替换成传统的记录模式。软件行业正是现在比较热门的行业[4]。
社会主义进入新时代，经济实力越来越强。我们也变得越来越忙碌、对生活的要求也变得更加严格，对快速和方便的服务的需求也在逐渐增加，所以汉服文化平台网站的开发给用户带来了足够的便利，用户通过系统来满足生活中的需求，因此，由于信息的增加，信息处理系统也随之增加，通过网络来满足现代用户需求[5]。此次开发设计主要是实现汉服文化平台网站 ，结合java技术以及MYSQL数据库进行设计，弥补目前在线汉服文化平台网站中的不足，来开发出一款即方便又实用的汉服文化平台网站 ，并且设计的程序具有界面整洁、功能强大等特性，从全局来说，汉服文化平台网站的设计解决了信息零散，该系统实现，可以投入到真实环境中，这样不仅能解决以上提及的问题，让信息管理更准则。
1.3研究内容 该汉服文化平台网站的开发和设计根据用户的实际情况出发，对系统的需求进行了详细的分析，然后进行系统的整体设计，最后通过测试使得系统设计的更加完整，可以实现系统中所有的功能，在开始编写论文之前亲自到图书馆借阅SSM 框架书籍，MYSQL数据库书籍等编程书籍，然后针对开发的汉服文化平台网站 ，去网上查找了很多别人做好的系统，参照他们的设计结果，来对自己的系统进行更加详细的系统的设计，将系统中所有的功能结果一一列举出来，然后进行需求分析，最后对所有的功能模块进行编码，最后完成系统的整体测试，实现系统的正常运行[6]。
这次编写的论文包含了6个部分的内容，具体内容如下：
第一部分绪论：文章主要从课题背景以及研究现状综合阐述了开发此系统的必要性。
第二部分相关技术：系统开发用到的各种技术都大致做出了简介。
第三部分系统分析：对系统的可行性分析以及对所有功能需求进行详细的分析，来查看该系统是否具有开发的可能。
第四部分系统设计：功能模块设计和数据库设计这两部分内容都有专门的表格和图片表示。
第五部分系统实现：进行系统主要功能模块的界面展示。
第六部分系统测试：测试系统的每一个功能是否能够正常运行，是否可以满足用户的需求。
2 系统关键技术 2.1 SSM框架 当今流行的“SSM组合框架”是Spring + SpringMVC + MyBatis的缩写，受到很多的追捧，“组合SSM框架”是强强联手、各司其职、协调互补的团队精神。web项目的框架，通常更简单的数据源。Spring属于一个轻量级的反转控制框架(IoC)，但它也是一个面向表面的容器(AOP)。SpringMVC常常用于控制器的分类工作模式，与模型对象分开，程序对象的作用与自动取款机进行处理。这种解耦治疗使整个系统的个性化变得更加容易。MyBatis是一个良好的可持续性框架，支持普通SQL查询，同时允许对存储过程的高级映射进行数据的优化处理。大型Java Web应用程序的由于开发成本太高，开发后难以维护和开发过程中一些难以解决的问题，而采用“SSM组合框架”，它允许建立业务层次结构，并为这个问题提供良好的解决方案。
2.2 JAVA技术 JAVA语言是目前软件市场上应用最广泛的语言开发程序。可以在多种平台上运用的，兼容性比较强，适应市面上大多数操作系统，不会出现乱码的现像，其扩展性和维护性都更好，具有分析问题和解决问题的能力，是面向过程的程序设计方便我们编写的代码更强壮。
JAVA相对其它语言来说，比较简单，编译起来更方便一些，安全可靠性高。不完全统计，现在全世界大约有2000多万人在使用它，JAVA既可以镶嵌使用又可以独力的使用。JAVA大致可以分成两个部分，一种部分是JAVA负责的编译，另一种是JAVA负责的运行。JAVA和C++语言很相像，但JAVA在编程时是一种以对象为导向的方式来进行编译的，使得编出来的软件可以单机使用，也可以在互联网上使用，检查出错更为方便。JAVA分布式、体系结构中立的特点也使得其存储更快，编议更简单。面向对象包括四个特点，一是封装，就是说在定义类的时候可以实现一定的功能和属性。二是抽象，属于类的一种，可以把一个具有共同属性的类封装在一个抽象里，便于简单编议。三是继承，顾名思义就是带有前者的特性。还有一个就是多态的特点，可以多种一起运用，表现了它可扩展性好[8]。
2.3 MYSQL数据库 网站的开发必须配套相应数据库，数据库具有一定的组织结构，能够存放和管理数据信息，在以前数据库的功能仅仅是数据保存和管理操作，但是时代的变迁和发展，现在的数据库演变成了数据处理的方式，数据库从最开始的简单存放数据表格信息到现在的能够存放成千上万数据的大型数据库，期间还是经历了许多的改革。
本次开发的汉服文化平台网站 使用的数据库是MYSQL数据库，该数据库运行速度快，安全性能也很高，而且对使用的平台没有任何的限制，所以被广泛应运到系统的开发中。MySQL是一个开源和多线程的关系管理数据库系统，MySQL是开放源代码的数据库，具有跨平台性，虽然功能未必强大，导致很多人都了解这个数据库的基本应用，在数据库中，总共建立了10几个表，这里面每个表都是相对应的，都各自有各自的联系，数据库意义重大，如果没有数据库的链接，就没办法运行程序，这显然可以看见数据库与程序的重要性，是紧密相连接的[9]。
2.4 B/S结构 B/S（浏览器/服务器）结构是目前主流的网络化的结构模式，它能够把系统核心功能集中在服务器上面，可以帮助系统开发人员简化操作，便于维护和使用。只需要用户在用户端安装360浏览器、谷歌浏览器、QQ浏览器等当前大众浏览器，在电脑里面安装sqlserver、mysql数据库等数据库[10]。安装好的浏览器与服务器端的数据库进行信息数据的交互。很多专门软件能够做到的事情，采用B/S结构模式也能实现，它能够结合Web浏览器技术，ActiveX技术以及多种脚本语言等技术。帮助程序开发者节约了不少开发成本。目前B/S结构成为程序开发主流结构，它最好的地方就是没有地点限制还不用专门安装软件，笔记本或者电脑能够上网就能访问系统。系统使用B/S进行开发在后期系统维护上面就会很省事，不用什么问题都在服务器上面操作，简单的用户端处理就解决部分问题，开发出来的程序跟用户交互性上面也会增强，还可以实时刷新浏览器进行程序局部的数据信息更新。
图2-1 B/S模式三层结构图
3 系统分析 3.1 可行性分析 在系统开发之初要进行系统可行分析，这样做的目的就是使用最小成本解决最大问题，一旦程序开发满足用户需要，带来的好处也是很多的。下面我们将从技术上、操作上、经济上等方面来考虑这个系统到底值不值得开发。
3.1.1 技术可行性 本汉服文化平台网站采用SSM 框架、JAVA编程语言和MYSQL数据库进行开发设计，作为计算机专业学生，在学校期间就接触到许多关于编程方面的知识，当然也包括各种编程软件，对他们的了解度也比较熟悉，所以技术开发上面还是有一定把握。
3.1.2经济可行性 我在设计该系统的时候主要是从节约成本出发，然后进行具体的系统的设计，在系统的设计过程中由于采用的所有工具以及技术支持全部都是免费的，因此不需要有任何的成本就可以进行该系统的设计。所用到的所有资源都是免费的，只要有网络就可以进行下载使用，不需要支付相应的费用，因此该项目在经济方面是完全可以实行的。
3.1.3操作可行性 本人自己就是学生，程序开发经验不足，在界面设计上面不会设计太复杂，要讲究简单好看，操作上要方便，不能让用户觉得不流畅。用户一旦进入操作界面，界面上就会有相应提示，跟着操作提示就可以找到对应的功能操作模块，对于用户来说免培训就能使用。
从上面几个部分的可行性分析得出，这次开发的汉服文化平台网站在开发上面没有什么大问题，值得开发。
3.2 系统性能分析 （1）系统响应效率：页面响应时问应该在3秒以内，最长不能超过4秒，并支持至少10000人同时在线所有系统。
（2）界面简洁清晰：系统界面要求简单明了，容易操作，符合用户操作习惯。
（3）储存性高：因为汉服文化平台网站中有很多的信息需要存储，因此对于系统的存储量有很大的要求，需要有一个强大的数据库的支持才能确保所有的信息都能安全稳定的进行存储。
（4）易学性：该系统在操作上必须简单好上手，没有很多复杂的操作，只需要简单的进行学习就能操作该系统。
（5）稳定性需求：开发的汉服文化平台网站要求运行稳定，运行过程中无界面不清楚、字体模糊等现象。
3.3 系统功能分析 本汉服文化平台网站主要包括二大功能模块，即用户功能模块和管理员功能模块。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e4565188b6b3714186d76ffd21fd334/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d50abadc8b0512bd14f799a77ca7281/" rel="bookmark">
			Ciallo～(∠・ω・ )⌒☆第二十五篇 Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis 是一个高性能的键值存储数据库，它能够在内存中快速读写数据，并且支持持久化到磁盘。它被广泛应用于缓存、队列、实时分析等场景。
一、启动redis服务器 要打开redis服务器，需要在终端中输入redis-server命令。确保已经安装了redis，并且路径已经正确配置。打开终端，输入redis-server命令并按下回车键，即可启动redis服务器。
在控制台输入:
redis-cli
来连接redis服务器: 二、redis 数据类型对应的操作 主要使用python来实现redis的相关操作
（一）、使用pip命令安装redis-py库： pip install redis 安装完成后，可以在Python代码中导入redis库：
import redis （二）、接下来，连接到Redis服务器： # 创建Redis连接 client = redis.Redis(host='localhost', port=6379, db=0) 这里的host是Redis服务器的主机名，port是Redis服务器的端口号（默认为6379），db是使用的数据库编号（默认为0）。
(三)、键的操作 # 获取键的类型 print(client.type("key_string")) # 设置有效期 client.set("key_string", 101) client.expire("key_string", 100) # 剩余时间 print(client.ttl("key_string")) # 移除有效期 client.persist("key_string") # 删除键 client.delete("key_string") # 打印键 print(client.keys()) (四)、字符串的操作 # 添加字符串 client.set("id", 101) # 获取字符串 print(client.get("id").decode()) # 连续添加字符串 client.mset({"name": "kurumi", "address": "youkohama"}) # 连续获取字符串 print(client.mget(["name", "address", "id"])) # 获取字符串长度 print(client.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d50abadc8b0512bd14f799a77ca7281/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9489cfd128022c998f4945c3a3df4d38/" rel="bookmark">
			【数据结构初阶】单链表接口实现超详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 顺序表问题与思考2.单链表2. 1 概念与结构2.1.1 结点2.1.2 链表的性质 3. 单链表实现3. 1 单链表初始化3. 2 单链表的打印3. 3 头插3. 4 创建新节点3. 5 尾插3. 6 头删和尾删3. 7 查找3. 8 在指定位置之后插入或删除3. 9 在指定位置前面插入或删除指定位置3. 10 销毁 1. 顺序表问题与思考 上一篇博客中我们介绍了顺序表，那么顺序表有什么缺点呢？
中间 / 头部的插入删除，时间复杂度为O(N)增容需要申请新空间，拷贝数据，释放旧空间。会有不小的消耗。增容一般是呈2倍的增长，势必会有一定的空间浪费。例如当前容量为100，满了以后增容到200，我们再继续插入了5个数据，后面没有数据插入了，那么就浪费了95个数据空间。 如何解决以上问题呢?
我们可以使用单链表。
2.单链表 2. 1 概念与结构 概念：链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。
链表就像一个火车：
淡季时车次的车厢会相应减少，旺季时车次的车厢会额外增加几节。只需要将火车里的某节车厢去掉加上，不会影响其他车厢，每节车厢都是独立存在的。
在链表里，每节“车厢”是什么样的呢?
2.1.1 结点 与顺序表不同的是，链表里的每节"车厢"都是独立申请下来的空间，我们称之为“结点”。
结点的组成主要有两个部分：当前结点要保存的数据和保存下一个结点的地址(指针变量)。
图中指针变量 plist保存的是第一个结点的地址，我们称plist此时指向第一个结点，如果我们希望plist指向第二个结点时，只需要修改plist保存的内容为0x0012FFA0。
链表中每个结点都是独立申请的(即需要插入数据时才去申请一块结点的空间)，我们需要通过指针变量来保存下一个结点位置才能从当前结点找到下一个结点。
2.1.2 链表的性质 链式机构在逻辑上是连续的，在物理结构上不一定连续结点一般是从堆上申请的从堆上申请来的空间，是按照一定策略分配出来的，每次申请的空间可能连续，可能不连续 结合前面学到的结构体和顺序表知识，我们可以给出每个结点对应的结构体代码：
typedef int SLTDataType; typedef struct SListNode { SLTDataType data;	//用于存储数据 struct SListNode* next;	//指向下一个节点 }SLTNode; 当我们想要保存一个整型数据时，实际是向操作系统申请了一块内存**，这块内存不仅要保存整型数据，也需要保存下一个结点的地址**(当下一个结点为空时保存的地址为空)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9489cfd128022c998f4945c3a3df4d38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2371a53517e2adfb68d35e96b3f6b57e/" rel="bookmark">
			Mysql高级 [Linux版] 性能优化 数据库系统配置优化 和 MySQL的执行顺序 以及 Mysql执行引擎介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库系统配置优化 1、定义
数据库是基于操作系统的，目前大多数MySQL都是安装在linux系统之上，所以对于操作系统的一些参数配置也会影响到MySQL的性能，下面就列出一些常用的系统配置。
2、优化配置参数-操作系统
优化包括操作系统的优化及MySQL的优化
1、操作系统的优化 网络方面的配置，要修改/etc/sysctl.conf 1、 增加tcp支持的队列数 net.ipv4.tcp_max_syn_backlog = 65535// 2、 减少断开连接时，资源回收(tcp有连接状态) net.ipv4.tcp_max_tw_buckets = 8000 // net.ipv4.tcp_tw_reuse = 1 net.ipv4.tcp_tw_recycle = 1 net.ipv4.tcp_fin_timeout = 10 说明： TCP是有连接状态，通过netstat查看连接状态，经常会看到timeout状态或者timewait状态连接，为了加快timewait状态的连接回收，就需要调整上面的四个参数，保持TCP连接数在一个适当的状态。
2、打开文件数的限制 打开文件数的限制，可以使用ulimit –a查看目录的各个限制，可以修改/etc/security/limits.conf文件，增加以下内容以修改打开文件数量的限制（永久生效）
*Soft nofile 65535 *Hard nofile 65535 如果一次有效，就要使用ulimit –n 65535即可。（默认情况是1024）
除此之外最好在MySQL服务器上关闭iptables，selinux等防火墙软件。
3、优化配置参数- MySQL配置文件优化 1、MySQL配置文件修改
Mysql可以通过启动时指定参数和使用配置文件两种方法进行配置，在大多数情况下配置文件位于/etc/my.cnf 或者是 /etc/mysql/my.cnf在Windows系统配置文件可以是位于C://windows//my.ini文件，MySQL查找配置文件的顺序可以通过以下方法获得。
根据不同的安装 位置也不一样 /usr/sbin/mysqld --verbose --help | grep -A 1 'default options' 注意：如果存在多个位置存在配置文件，则后面的会覆盖前面的。
2、MySQL配置文件-常用参数说明
1、连接请求的变量
1、max_connections
MySQL的最大连接数，增加该值增加mysqld 要求的文件描述符的数量。如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量，当然这建立在机器能支撑的情况下，因为如果连接数越多，介于MySQL会为每个连接提供连接缓冲区，就会开销越多的内存，所以要适当调整该值，不能盲目提高设值。
数值过小会经常出现ERROR 1040: Too many connections错误，可以过’conn%’通配符查看当前状态的连接数量，以定夺该值的大小。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2371a53517e2adfb68d35e96b3f6b57e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fa994384839272ce9a05dc3c98f11d5/" rel="bookmark">
			怎么解决小程序的异步请求问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决小程序的异步请求问题通常涉及对异步操作的有效管理，以确保数据的正确加载和显示。在小程序中，最常见的异步操作包括网络请求、文件操作等。以下是一些解决小程序异步请求问题的方法：
使用Promise： 小程序中的wx.request接口本身是基于Promise实现的，可以直接使用.then()和.catch()来处理成功和失败的情况。使用async/await： 在需要顺序执行多个异步操作的情况下，可以使用async/await语法来简化代码，使其更加易于理解和维护。在小程序的生命周期函数中处理异步请求： 在onLoad或onShow等生命周期函数中发起异步请求，确保页面加载时能够获取到所需的数据。数据绑定和更新： 使用小程序的数据绑定机制，将异步请求的结果绑定到页面的data对象上，自动更新视图。错误处理： 对异步请求进行错误处理，比如使用.catch()捕获错误，并给用户相应的提示。使用全局状态管理： 对于复杂的应用，可以考虑使用全局状态管理（如Redux、Vuex等在小程序中的实现），以更好地管理异步请求和数据状态。避免不必要的重复请求： 通过设置标志位或使用缓存机制，避免在相同条件下重复发起异步请求。优化网络请求： 合并多个请求，减少请求次数。使用合适的缓存策略，减少网络请求的频率。调试和测试： 使用开发者工具的网络请求面板来监控和调试网络请求。对异步请求进行充分的测试，确保其在各种网络环境下都能正常工作。 通过上述方法，可以有效地解决小程序中的异步请求问题，提高应用的性能和用户体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ae147faf8e6fa7ee2dc89cdbd92760d/" rel="bookmark">
			前端音视频以及（关于收集用户信息的标签）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		音频标签（audio）
基本介绍
HTML5 中的 &lt;audio&gt; 标签用于在网页中嵌入音频内容。它提供了一种简单的方式来播放音频文件，无需依赖第三方插件。常见的音频格式包括 MP3、WAV、OGG 等。不同的浏览器对音频格式的支持可能会有所不同，为了确保在各种浏览器中都能正常播放，建议提供多种格式的音频文件。 属性详解
controls：当添加这个属性时，会在浏览器中显示音频播放器的控制条，包括播放 / 暂停按钮、进度条、音量控制等。这使得用户可以手动控制音频的播放。autoplay：如果设置了这个属性，音频会在页面加载完成后自动播放。然而，由于一些用户体验和可访问性的考虑，许多浏览器默认会阻止自动播放，特别是在没有用户交互的情况下。要实现自动播放，可能需要满足一些特定的条件，比如用户已经与页面进行了交互。loop：这个属性使音频在播放结束后自动重新开始播放，实现循环播放的效果。 示例代码
&lt;audio controls autoplay loop&gt; &lt;source src="audio.mp3" type="audio/mpeg"&gt; &lt;source src="audio.ogg" type="audio/ogg"&gt; Your browser does not support the audio element. &lt;/audio&gt; 注意事项 考虑用户体验：自动播放音频可能会打扰用户，特别是在没有明确提示的情况下。在使用 autoplay 属性时，要谨慎考虑用户的感受。提供多种格式：为了确保音频在不同的浏览器中都能播放，最好提供多种音频格式，并使用 &lt;source&gt; 标签来指定不同的音频文件。可访问性：确保音频内容对于有视觉或听觉障碍的用户也是可访问的。可以提供音频的文字描述或字幕。 二、视频标签（video）
基本介绍
&lt;video&gt; 标签用于在网页中嵌入视频内容。它允许开发者在网页上直接播放视频，而无需依赖外部插件。常见的视频格式包括 MP4、WebM、Ogg Theora 等。同样，不同的浏览器对视频格式的支持也有所不同。 属性详解
src：指定视频文件的路径。可以是相对路径或绝对路径。controls：显示视频播放器的控制条，包括播放 / 暂停按钮、进度条、音量控制等。用户可以通过这些控制条手动播放视频。autoplay：使视频在页面加载完成后自动播放。和音频的自动播放一样，浏览器可能会阻止自动播放，尤其是在没有用户交互的情况下。loop：使视频在播放结束后自动重新开始播放，实现循环播放。 示例代码
&lt;video controls autoplay loop&gt; &lt;source src="video.mp4" type="video/mp4"&gt; &lt;source src="video.webm" type="video/webm"&gt; Your browser does not support the video element. &lt;/video&gt; 注意事项 视频格式支持：了解不同浏览器对视频格式的支持情况，并提供多种格式的视频文件，以确保在不同的浏览器中都能正常播放。视频大小和质量：考虑视频的大小和质量对页面加载速度和用户体验的影响。可以使用适当的视频压缩工具来减小视频文件的大小，同时保持较好的质量。可访问性：为视频提供字幕或文字描述，以便有听觉障碍的用户也能理解视频内容。同时，确保视频播放器的控制条易于使用，对于使用辅助技术的用户也能进行操作。 收集用户信息的标签 input 标签
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ae147faf8e6fa7ee2dc89cdbd92760d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0340ed2c537c5387449a7b6ac89ebe80/" rel="bookmark">
			系统架构师学习笔记 （一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习目标 了解系统架构的基本概念。掌握系统架构设计的原则。学习如何评估和选择合适的技术栈。了解云服务的基础知识及其在架构中的应用。 系统架构的基本概念 定义：系统架构是指一个系统的设计蓝图，它定义了系统的各个组成部分及其相互之间的关系。要素： 组件：系统的组成部分，如数据库、API 服务器等。接口：组件间通信的方式。数据流：数据如何在系统中流动。约束：性能、安全性、可用性等要求。 系统架构设计原则 模块化：将系统划分为独立的、可重用的模块。松耦合：减少各部分之间的依赖，以便于维护和扩展。高可用性：确保系统即使在部分故障的情况下也能继续运行。安全性：保护数据和资源免受未授权访问和攻击。可扩展性：随着需求的增长，系统应能轻松扩展。性能：确保系统响应速度快、延迟低。 技术栈的选择 前端：React / Vue.js后端：Spring Boot数据库：MySQL / MongoDB缓存：Redis消息队列：RocketMQ / Kafka容器化：Docker微服务架构：Kubernetes 云服务基础 IaaS (Infrastructure as a Service)：提供基础设施服务，如 AWS EC2、Google Compute Engine。PaaS (Platform as a Service)：提供平台服务，如 Heroku、Google App Engine。SaaS (Software as a Service)：提供软件服务，如 Salesforce、Office 365。容器服务：AWS EKS、Azure AKS、GKE。 设计模式 单体架构：所有功能都在一个进程中运行。微服务架构：将应用分解为一组小型服务，每个服务实现特定的功能。事件驱动架构：通过事件触发系统中的操作。服务网格：管理服务间的通信，如 Istio。 实践案例 假设我们要为一个电子商务网站设计一个系统架构，主要考虑以下几个方面：
用户界面：使用 Vue构建动态前端。购物车服务：使用 vue.js 和 Express 构建 RESTful API。支付服务：集成第三方支付网关，如 Stripe。库存管理：使用 Spring Boot 构建后端服务，与 MySQL 数据库交互。订单处理：使用 RocketMQ 处理订单状态更新。日志和监控：使用 ELK Stack (Elasticsearch, Logstash, Kibana)。 参考资料 Clean Architecture by Robert C.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0340ed2c537c5387449a7b6ac89ebe80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efe6482c64569496f60449e772bd3dbc/" rel="bookmark">
			docker的安装&#43;docker镜像的基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一．docker的介绍
1、Docker 是什么？ Docker 是⼀个开源的应⽤容器引擎，可以实现虚拟化，完全采⽤“沙 盒”机制，容器之间不会存在任何接⼝。 Docker 通过 Linux Container（容器）技术将任意类型的应⽤进⾏包 装，变成⼀种轻量级、标准化、可移植、⾃管理的组件。在包装应 ⽤的同时，可连带该应⽤的依赖和环境⼀并进⾏打包，所以可以将 这种“包”移植到任意环境去运⾏，省去兼容性的问题。
Docker 的优缺点 （1）优点 1. 体积⼩：减⼩系统的开销值，⼀台主机可以运⾏上千个容器。 2. 启动迅捷：更快速的交付和部署，docker容器 ，⽐传统虚拟机 要快很多，docker核⼼解决的问题就是利⽤容器实现VM类似的 功能。3. 操作⽅便：通过配置 dockerfile 便⽀持灵活的⾃动化创建和部 署。 4. 更轻松的扩展：可以实现更简单的、更可靠的迁移，避免了兼容 性等问题。 5. 更强的可扩展性和可移植性。 （2）缺点 1. 安全问题：如果没有正确配置，⼀个容器中的恶意代码可能会影 响到主机上的其他容器以及主机本身的安全。 2. 存储问题：当使⽤⼤量容器时，存储和管理容器映像可以变得⾮ 常困难。这可能需要使⽤分布式存储或其他解决⽅案来管理⼤量 容器的存储。 3. 性能问题：在某些情况下，容器和虚拟机相⽐会导致性能损失。 这些性能问题越来越少，但是仍然需要考虑。 4. ⽹络问题：Docker 可能会在⽹络配置上存在⼀些问题，这可能 需要更多的时间来诊断和解决。 5. 复杂性：Docker 是⼀个⾮常灵活的系统，但这同时也让它更加 复杂。⻓时间使⽤ Docker 会产⽣⼤量的脚本和配置⽂件，这些 可能变得难以维护。 6. 资源消耗：使⽤ Docker 必须占⽤⼀些资源，包括 CPU、内 存、磁盘等等。如果运⾏容器的主机资源不⾜，可能会导致性能 问题。7. 学习曲线：Docker 是⼀个相对新的技术，相⽐传统环境需要⼀ 定的学习曲线。需要了解Docker 基本概念、命令和配置⽂件 等。 8. 需要花费时间配置和管理：使⽤ Docker 需要花时间配置和管理 容器集群和应⽤程序。需要配置每个容器，管理 Jenkins、 Kubernetes 等运⾏ Docker 容器的⼯具。 9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efe6482c64569496f60449e772bd3dbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edfc3419b6cc0e0e59c29ef79c284fe2/" rel="bookmark">
			122-域信息收集&amp;应用网络凭据&amp;CS插件&amp;Adfind&amp;BloodHound
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：【内网安全】域信息收集&amp;应用网络凭据&amp;CS插件&amp;Adfind&amp;BloodHound_ladon adfinder bloodhound-CSDN博客
工作组和域环境 我的理解：
工作组就是还是局域网一样只是大一点里面的电脑很多，每个电脑还是都是单独的电脑没有受人控制。然后域就是有很多电脑，这些电脑由一台域控主机控制，只有他可以对域里面的电脑做任何事情，而且使用电脑的人的账号可以在这个域里面的任何一个电脑进行登录，但是他的权限由域控赋予。在我们自己的电脑上面的登录使用whoami查看看到了就是我们的电脑的版本和用户名，但是在域里面登录了一台主机使用whoami查看到的是域名和用户名
域渗透的思路就是：
通过域成员主机，定位出域控制器IP及域管理员账号，利用域成员主机作为跳板，扩大渗透范围，利用域管理员可以登陆域中任何成员主机的特性，定位出域管理员登陆过的主机IP，设法从域成员主机内存中dump出域管理员密码，进而拿下域控制器、渗透整个内网。
域成员主机——&gt;定位出域控制器IP及域管理员账号——&gt;域成员主机作为跳板——&gt;域管理员登陆过的主机IP——&gt;从域成员主机内存中dump出域管理员密码——&gt;拿下域控制器、渗透整个内网
当前机器角色的判断（个人|文件服务器|邮件服务器等）当前机器网络环境判断（局域网|工作组|域环境）当前机器角色功能判断（任务|端口|服务|密码|漏洞|配置等） 信息收集：
常用命令
systeminfo 详细信息 netstat -ano 端口列表 route print 路由表 net start 启动服务 tasklist 进程列表 schtasks 计划任务 ipconfig /all 判断存在域 net view /domain 判断存在域 net time /domain 判断主域 netstat -ano 当前网络端口开放 nslookup 域名 追踪来源地址 wmic service list brief 查询本机服务 net config workstation 查询当前登录域及登录用户信息 wmic startup get command,caption 查看已启动的程序信息 信息类收集-网络&amp;用户&amp;域控等 使用命令net view /domain 查看是否有域 或者使用net time domain 查看域的时间，如果有域就会返回时间使用 net user /domain 查看域的用户 net view /domain 查询域列表 net time /domain 从域控查询时间，若当前用户是域用户会从域控返回当前时间，亦用来判 断主域，主域一般用做时间服务器 net localgroup administrators 本机管理员【通常含有域用户】 net user /domain 查询域用户(当前域) net group /domain 查询域工作组 net group “domain computers” /domain 查看加入域的所有计算机名 net group “domain admins” /domain 查询域管理员用户组和域管用户 net localgroup administrators /domain 查看域管理员 net group “domain controllers” /domain 查看域控 net accounts /domain 查看域密码策略 ping 得到域控计算机名可以得到域控ip 关键信息类收集-密码&amp;凭据&amp;口令等 旨在收集各种密文，明文，口令等，为后续横向渗透做好测试准备
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edfc3419b6cc0e0e59c29ef79c284fe2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7027bf3babc8ba58acd696f3ae06dd6/" rel="bookmark">
			c&#43;&#43; nanoMQ 发布和订阅消息，代码优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c++ nanoMQ 发布和订阅消息，代码优化，实现了发布消息和订阅消息的打印输出监听。
nanomq.h
#ifndef NANOMQ_H #define NANOMQ_H #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;iostream&gt; #include &lt;stdio.h&gt; #include &lt;MQTTClient.h&gt; #define ADDRESS "tcp://broker.emqx.io:1883" #define USERNAME "xgdd" #define PASSWORD "xgdd" #define CLIENTID "mqttx_47b97142" #define QOS 0 #define TIMEOUT 10000L class NanoMQ { public: NanoMQ(); /// /// \brief init 连接nanomq /// \return -1-连接失败 0-连接成功 /// int init(); /// /// \brief quit 断开连接 /// void quit(); /// /// \brief sendInfo 发送信息 /// \param topic 节点 /// \param data 数据 /// void sendInfo(char *topic, char *data); private: MQTTClient client; void publish(MQTTClient client, char *topic, char *payload); }; /// /// \brief on_message 接收消息 /// \param context /// \param topicName 节点 用于区分不同节点 /// \param topicLen /// \param message 数据 结构中的message-&gt;payload /// \return /// int on_message(void *context, char *topicName, int topicLen, MQTTClient_message *message); #endif // NANOMQ_H nanomq.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7027bf3babc8ba58acd696f3ae06dd6/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/28/">«</a>
	<span class="pagination__item pagination__item--current">29/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/30/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>