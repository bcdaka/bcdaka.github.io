<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ad4fe52e7683314095da05a2dc3279d/" rel="bookmark">
			llama-factory训练RLHF-PPO模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		理论上RLHF（强化学习）效果比sft好，也更难训练。ppo有采样阶段,步骤比较多,训练速度很慢.
记录下工作中使用llama-factory调试rlhf-ppo算法流程及参数配置,希望对大家有所帮助.
llama-factory版本: 0.8.2
一 rlhf流程 ppo训练流程图如下, 会用到多个模型, 但初始化阶段, 只需提供sft和reward模型就行.
四个子模型用途：
Actor Model：演员模型，这就是我们想要训练的目标语言模型Reference Model：参考模型，它的作用是在RLHF阶段给语言模型增加一些“约束”，防止语言模型训歪。我们希望训练出来的Actor模型既能达到符合人类喜好的目的，又尽量让它和SFT模型不要差异太大。即希望两个模型的输出分布尽量相似，通过与Actor Model之间的KL散度控制。Critic Model：评论家模型，它的作用是预估总收益V-&gt;(t)，在RLHF中，我们不仅要训练模型生成符合人类喜好的内容的能力（Actor），也要提升模型对人类喜好量化判断的能力（Critic）。这就是Critic模型存在的意义。Reward Model：奖励模型，它的作用是计算即时收益R-&gt;(t) Actor/Critic Model. 在RLHF阶段是需要训练的；而Reward/Reference Model是参数冻结的。 整体算法流程如下：
训练sft模型
训练reward奖励模型
以sft模型初始化Reference和Actor模型，以奖励模型初始化Critic模型。其中，Actor与Critic模型权重可训练，Reference与Reward冻结权重，全程不更新。
rlhf-ppo执行过程分析(对应上图的step 3)：
第一步，我们准备一个batch的prompts
第二步，我们将这个batch的prompts喂给Actor模型，让它生成对应的responses
第三步，我们把prompt+responses喂给我们的Critic/Reward/Reference模型，让它生成用于计算actor/critic loss的数据，按照强化学习的术语，我们称这些数据为经验（experiences）。
第四步，我们根据这些经验，实际计算出actor/critic loss，然后更新Actor和Critic模型。
涉及的损失函数：
至此, 我们对RLHF-PPO工作原理已经有了清晰的认知. 若觉得上述文字不过瘾, 可以看我列出的几篇参考文献, 对ppo复杂的原理有深刻解读.
二 代码实践 2.1 数据准备: 需要准备sft指令微调和reward奖励模型的数据.
sft数据格式 [ { "instruction": "&lt;question&gt;:查看备案有效期在今天之后的委托信息\nCREATE TABLE 委托备案信息 (序号 FLOAT,\n委托企业名称 VARCHAR(255),\n公司地址 VARCHAR(255),\n被委托企业名称 VARCHAR(255),\n委托产品名称 VARCHAR(255),\n备案日期 VARCHAR(255),\n备案有效期 VARCHAR(255));", "input": "", "output": "\nSELECT * FROM 委托备案信息 WHERE TO_DATE(备案有效期, 'YYYY-MM-DD') &gt; NOW();\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ad4fe52e7683314095da05a2dc3279d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2bec6b73b6239423e7165d1a4aadfa2/" rel="bookmark">
			【网络】socket套接字基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&gt; 作者：დ旧言~
&gt; 座右铭：松树千年终是朽，槿花一日自为荣。
&gt; 目标：理解并掌握socket套接字。
&gt; 毒鸡汤：有些事情，总是不明白，所以我不会坚持。早安!
&gt; 专栏选自：网络
&gt; 望小伙伴们点赞👍收藏✨加关注哟💕💕
​​
🌟前言 前面我们已经学习了网络的基础知识，对网络的基本框架已有认识，算是初步认识到网络了，如果上期我们的学习网络是步入基础知识，那么这次学习的板块就是基础知识的实践，我们今天的板块是学习网络重要之一，学习完这个板块对虚幻的网络就不再迷茫，那话不多说进入今天的主题【网络】socket套接字基础知识
⭐主体 学习【网络】网络基础入门咱们按照下面的图解：
​🌙 前导知识 💫 IP与端口号 IP：
每台主机都有自己的IP地址，所以当数据从一台主机传输到另一台主机就需要IP地址。报头中就会包含源IP和目的IP。
源IP地址：发送数据报那个主机的IP地址。目的IP地址：想发送到的那个主机的IP地址。 我们把数据从一台主机传递到另一台主机不是真正目的，真正通信的不是这两个机器，其实是这两台机器上面的软件，而这个软便网络的应用层中，我们知道应用层不止一个软件，公网IP标识了一台唯一的主机，那么数据就可以由一台主机传递到另一台主机。但是有这么多的软件（进程），怎么保证软件A发送的被软件B接收呢？也就是说用什么来标识主机上客户或者服务进程的唯一性呢？最好的解释就是下面这段内容：
为了更好的表示一台主机上服务进程的唯一性，用端口号port标识服务进程、客户端进程的唯一性。
端口号：
端口号是一个2字节16位的整数。端口号用来标识一个进程，告诉操作系统要把数据交给哪一个进程。一个端口号只能被一个进程占用（同一个主机）。 总结：
IP地址（标识主机全网唯一主机）+ 端口号（标识服务器上唯一的进程）能够标识网络上的某一台主机的某一个进程（全网唯一进程）。网络通信的本质就是进程间通信。而我们之前说过进程间通信的本质是看到同一份资源，现在这个资源就是网络。通信的本质就是IO，因为我们上网的行为就两种情况：1.把数据发送出去 2.接收到数据。 两个问题：
标识一个进程有pid，那么为什么还需要端口号port呢？
解耦：首先pid是系统规定的，而port是网络规定的，这样就可以把系统和网络解耦。port标识服务器的唯一性不能做任何改变，要让客户端能找到服务器，就像110，120样不能被改变。而每次启动进程pid就会改变。不是所有的进程都需要提供网络服务或请求（不需要port），但每个进程都需要pid。 一个端口号只能被一个进程占用，但是一个进程可以绑定多个端口号？（对）
底层OS如何根据port找到指定的进程——uint16（端口号）——task_struct——哈希我们在网络通信的过程中，IP+port标识唯一性，IP有源IP和目的IP，port也有源端口号和目的端口号。所以我们在发送数据的时候也要把自己的IP和端口号发送过去，因为数据还要被发送回来。所以发送数据的时候一定会多出一部分数据（以协议的形式呈现） 💫 源MAC地址和目的MAC地址 概念分析：
MAC地址（Media Access Control Address， 局域网地址）在OSI模型的第二层数据链路层发挥作用，标识本地网络上的设备物理地址。
总结分析：
对于处于同一局域网的多台主机，它们直接向局域网发送的数据是被所有主机共享的（包括发送的主机自己），也就相当于广播，但是只有特定的主机才会处理它（虽然所有主机都收到了信息）。这是因为主机发送的数据中包含了指定主机的MAC地址，除此之外，为了校验数据的完整性，还包含了发生数据的主机本身的MAC地址，以供主机在发送信息后再接收校验。其中，发送信息的主机的MAC地址叫做源MAC地址，接收信息的主机的MAC地址叫做目的MAC地址。
💫 源IP地址和目的IP地址 在IP与端口号中我们初步了解，这里我们再单独拿出来讲解。
概念分析：
IP地址（Internet Protocol， 互联网协议）在OSI模型的第三层网络层发挥作用，它是一个逻辑地址，用于唯一标识互联网连接设备。
总结分析：
MAC地址标识着设备的全球唯一性，但是仅靠MAC地址无法完成不同网络中数据的传输。我们知道，数据传输是通过网络协议栈传输的，数据自上而下传输时会被每一层协议封装一个报头信息，当数据自下而上传输时，每一层协议会解封装，直到应用层取到数据本身。但是不同的网络可能在某些层的协议有所区别，因此报头的封装和解封装的过程就不像局域网那样对称，因此需要配合IP地址在不同的网络中跳转。
💫 MAC地址和IP地址的配合 基础概念：
在不同网络中，路由器起着“指路人”的作用，实际上数据在传输过程中可能会经过多个不同网络，那么报头信息中的两个MAC地址一直在随着路由器（路由器也是硬件）的变化而变化，但是源IP地址和目的IP地址不会改变。这就像唐僧每到一个地方都会说“自东土大唐而来，去西天取经”，出发点和目的地是不应该被改变的（在某些特殊情况源IP可能会被改变，但是目的IP绝对不会被改变），但是遇到的好心人听到这句话以后都会告诉唐僧下一个地方应该怎么走，这就是MAC地址和IP地址在不同网络中配合数据传输的过程。
💫 源端口号和目的端口号 什么是端口号？
端口号（PORT）的主要作用是表示一台计算机中的特定（特指网络服务）进程所提供的服务，它在传输层发挥作用，标识主机上进程的唯一性。言外之意是一个端口号只能被一个进程使用，而一个进程可以使用多个端口号。端口号是一个16位的无符号整数，范围从0到65535。在Internet上，端口号用于识别不同的网络服务。例如，Web服务器通常使用端口号80，SMTP服务器使用端口号25等 。 总结分析：
结合进程相关知识，数据本身是被运行起来的进程处理的，因此数据通过网络传输到不同主机中只是一个搬运的过程。因此可以认为数据是在不同主机中的不同进程之间传输，也就是网络层面上的进程间通信。端口号的名字很形象，现实中的港口（port）也是类似的。主机中各种不同的进程就好像一个个蓄势待发的货船，它们在不同编号的位置等待货物，一旦货物就绪，一个个进程就会对其处理。
IP地址标识了公网中主机的唯一性，端口号标识主机上进程的唯一性，那么IP地址+端口号就标识了网络上某台主机中的进程的唯一性。和IP地址类似，端口号会在传输层被封装进报头信息中。
既然PID和端口号都能表示主机上进程的唯一性，为什么不用PID进行网络传输？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2bec6b73b6239423e7165d1a4aadfa2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eec7fc1c7183cd7486491bb28bd72ec7/" rel="bookmark">
			关联查询（xml）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多对多：数据库中需要有中间表，在两个实体类中都加入对方的List集合，在写查询语句时写三张表
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/936c5b19ebb9b25a5ef2023b8ef408f6/" rel="bookmark">
			Python中高效处理大数据的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着数据量的爆炸性增长，如何在Python中高效地处理大数据成为了许多开发者和数据科学家的关注焦点。Python以其简洁的语法和丰富的库支持，在数据处理领域占据了重要地位。本文将介绍几种在Python中高效处理大数据的常用方法。
目录
1. 使用Pandas进行数据分析
简介
高效处理策略
2. 利用NumPy进行大规模数值计算
简介
高效处理策略
3. 分布式计算框架：Apache Spark
简介
Python支持
高效处理策略
4. 异步IO和并发处理
简介
高效处理策略
示例 1: 使用Pandas处理大数据（结合Dask）
示例 2: 使用NumPy进行大规模数值计算
示例 3: Apache Spark（PySpark）
1. 使用Pandas进行数据分析 简介 Pandas是Python中一个强大的数据分析库，提供了快速、灵活和表达式丰富的数据结构，旨在使“关系”或“标签”数据的处理既简单又直观。Pandas非常适合于处理表格数据，如CSV、Excel等。
高效处理策略 使用Dask DataFrame：对于超过内存限制的大型数据集，可以使用Dask DataFrame，它是Pandas的并行计算扩展，可以在多核CPU上并行处理数据。优化内存使用：通过减少数据类型的大小（如使用int32代替int64），或者仅在需要时加载数据的子集，可以有效减少内存占用。使用向量化操作：Pandas的许多操作都是向量化的，这意味着它们会自动应用于数据框（DataFrame）或序列（Series）的每一行或列，比手动循环要快得多。 2. 利用NumPy进行大规模数值计算 简介 NumPy是Python的一个库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。NumPy是Pandas等高级数据分析工具的基础。
高效处理策略 避免Python循环：NumPy的数组操作是高度优化的，尽量使用NumPy提供的函数来代替Python的循环，可以显著提高计算效率。利用广播机制：NumPy的广播机制允许对数组进行高效的逐元素操作，无需编写显式循环。使用内存映射文件：对于非常大的数组，可以使用NumPy的memmap功能将数组存储在磁盘上，仅将部分数据加载到内存中，以节省内存并处理大数据。 3. 分布式计算框架：Apache Spark 简介 Apache Spark是一个快速、通用的大规模数据处理引擎，它提供了比Hadoop MapReduce更高的抽象级别，并且具有内置模块用于流处理、SQL查询、机器学习和图形处理。
Python支持 通过PySpark，Python开发者可以利用Spark的强大功能进行大规模数据处理。PySpark是Spark的Python API，允许你使用Python代码来编写Spark应用程序。
高效处理策略 数据分区：Spark通过数据分区来并行处理数据，合理设置分区数可以显著提高处理效率。缓存和持久化：将中间结果缓存或持久化到磁盘/内存中，可以避免重复计算，加速后续操作。使用DataFrame API：Spark DataFrame API提供了类似于Pandas的DataFrame操作，但支持在分布式环境中运行。 4. 异步IO和并发处理 简介 在处理I/O密集型任务（如网络请求、文件读写）时，使用异步IO和并发处理可以显著提高程序的运行效率。
高效处理策略 使用asyncio库：Python的asyncio库提供了编写单线程并发代码的能力，通过协程（coroutines）和事件循环（event loop）来实现非阻塞I/O操作。结合使用ThreadPoolExecutor和ProcessPoolExecutor：对于CPU密集型任务，可以使用concurrent.futures模块中的ThreadPoolExecutor和ProcessPoolExecutor来并行执行多个任务。 示例 1: 使用Pandas处理大数据（结合Dask） 这里不直接展示Dask代码，因为Dask的使用通常更复杂，但我会给出一个Pandas的示例，并简要说明如何转向Dask。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/936c5b19ebb9b25a5ef2023b8ef408f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47c15f0604a2e4d0cff25842425776c1/" rel="bookmark">
			Python本地安装whl文件详解与高级pip命令技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有些情况我们pip一下包的时候会报错，可能因为延时或许其他不兼容的情况，这时候我们可以通过去网上下载该包的原文件，进行本地物理pip ，在安装网上下载的whl之前，先明白不同后缀的差异；whl下载网址：清华大学开源软件镜像站 | Tsinghua Open Source Mirror
在Python的生态环境中，.whl文件（全称为wheel文件）是一种预编译的二进制包，用于分发和安装Python库。
whl的不同后缀 win32 .whl：这是为32位Windows操作系统编译的Python包。由于它专门针对32位系统进行了优化和编译，因此只能在32位Windows上安装和使用，其他.whl：包括为64位Windows（如win_amd64）、Linux（如manylinux）、MacOS（如macosx）等不同操作系统和架构编译的Python包。每个.whl文件都明确指定了它所支持的操作系统和Python版本，对于所有.whl文件，都可以使用pip命令进行安装。
举例：
32位Windows：如numpy-1.20.3-cp38-cp38-win_amd32.whl，这是为32位Windows系统编译的；
64位Windows：如numpy-1.20.3-cp38-cp38-win_amd64.whl，这是为64位Windows系统编译的；
Linux：如matplotlib-3.4.3-cp38-cp38-manylinux1_x86_64.whl，这是为manylinux1兼容的Linux发行版上的64位系统编译的；
MacOS：如pandas-1.2.4-cp38-cp38-macosx_10_9_x86_64.whl，这是为MacOS上的64位系统编译的；
以下图为例详细说明：
文件名：numpy-1.20.3-cp38-cp38-win_amd64.whl类型：Python Wheel文件（.whl），这是一种预编译的Python包格式，便于跨平台安装。库名：numpy版本：1.20.3Python版本：cp8，即Python 3.8平台：win_arm64，表示这是为Windows操作系统下的ARM64架构编译的。 本地安装 pip install 包whl的物理路径；
pip install D:\data\basemap-1.4.1-cp310-cp310-win32.whl #输入你的下载路径 安装包的特定版本 如果你想要安装特定版本的包，可以在包的源文件路径后加上==和版本号；
pip install numpy==1.20.3 # 注意等号前后不能有空格 卸载本地Python包 如果你想要卸载已经安装的本地包，可以使用pip命令的卸载选项。在命令提示符或终端中，执行以下命令：
pip uninstall numpy 大多数时候，即使你是通过wheel文件手动安装的包，pip也会将其添加到其管理的列表中。因此，你可以尝试使用pip的uninstall命令来卸载它，就像卸载任何其他通过pip安装的包一样。
但是，如果你确定pip不知道这个包（可能是因为某种原因没有正确注册），或者你想要确保卸载过程更加直接，你可以尝试以下步骤：
检查包是否通过pip安装：
pip show numpy 首先，尝试使用pip的list或show命令来查看包是否已安装，并获取其信息，如果这个命令返回了包的信息，那么你可以使用uninstall命令来卸载它。
如果pip show numpy没有返回任何信息，那么pip可能不知道这个包。这通常不太可能，因为通过wheel文件安装的包通常会被pip注册。不过，如果确实发生了这种情况，你可以尝试手动删除包文件，找到包文件所在的目录。对于Windows，这通常是Python的Lib\site-packages目录，但如果你使用了虚拟环境，它将在你的虚拟环境目录中的相应位置，导航到该目录，并查找与basemap相关的文件和文件夹会有一个名为numpy的文件夹和/或一些以numpy开头的.pyd、.pyc、.pyo等文件，删除这些文件和文件夹；
更多安装选项 pip install --pre package 这个命令用于安装指定包的“预发布”版本。预发布版本通常包括alpha、beta、rc（候选发布）等版本，这些版本可能包含新功能，但也可能存在未修复的错误或不稳定的问题。使用--pre选项，pip会搜索并安装最新版本的包，包括预发布版本。
pip install --no-deps package 这个命令用于安装指定的包，但不安装其依赖项。默认情况下，pip会安装你指定的包以及它依赖的所有其他包。然而，如果你只想安装这个包而不关心它的依赖项，可以使用--no-deps选项。这通常不推荐，因为缺少依赖项可能会导致包无法正常工作。
pip install -r requirements.txt 这个命令用于从requirements.txt文件中读取并安装所有指定的Python包及其依赖项。requirements.txt文件是一个文本文件，列出了项目所需的所有Python包及其版本号（可选）。这个文件通常用于项目依赖管理，确保项目的环境在不同开发者和生产环境中保持一致。使用-r选项，pip会读取该文件中的每一行，将其视为pip安装命令的输入，并安装所有指定的包及其依赖项。
文章仅用于分享个人学习成果与个人存档之用，分享知识，如有侵权，请联系作者进行删除。所有信息均基于作者的个人理解和经验，不代表任何官方立场或权威解读。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70068b7f4fe853cafb8b65c099baa91f/" rel="bookmark">
			【C&#43;&#43;】哈希
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
unordered系列关联式容器
unordered_set
unordered_map
底层结构
什么是哈希
哈希冲突
哈希桶的迭代器
HashTable的封装
unordered_set封装
unordered_set封装
在哈希提出之前，stl的设计者认为有红黑树就足够了，但是的确在有些场景下，哈希的性能要优于红黑树，红黑树和哈希的功能相似度大约是90%，主要区别有几点：
1.有序 无序：哈希实现的map和set在C++的STL中叫做unordered map和unordered set，从名字上就能看出unordered map和unordered set是无序的，而红黑树实现的map和set是有序的。
2.性能，map和set的时间复杂度是O（logN），unordered map和unordered set的时间复杂度是O（1）。
3.底层角度区分适合场景
unordered系列关联式容器 unordered_set unordered_set和set的功能类似，接口也很类似
1.unordered_set的构造
函数声明功能介绍unordered_set构造不同格式的unordered_set对象 2.unordered_set的容量
函数声明功能介绍bool empty() const检测unordered_set是否为空size_t size() const获取unordered_set的有效元素个数 3.unordered_set的迭代器
函数声明功能介绍begin返回unordered_set第一个元素的迭代器end返回unordered_set最后一个元素的迭代器 和set不同的是，unordered_set的迭代器是单向的。
4.unordered_set的查询
函数声明功能介绍iterator find(const K&amp; key) 返回key在哈希桶位置的迭代器
size_t count(const K&amp; key)返回哈希桶中关键码为key的元素的个数 5.unordered_set的修改操作
函数声明功能介绍insert向容器中插入元素erase删除容器元素clear清空容器元素 6.unordered_set的桶操作
函数声明功能介绍size_t bucket_count()const返回哈希桶中通的个数size_t bucket_size(size_t n)const返回第n个哈希桶元素的个数size_t bucket(const K&amp; key)返回元素key所在的桶号 unordered_map 参考unordered_map说明文档
底层结构 什么是哈希 哈希是一种映射，是值和值进行1对1或者1对多的映射，哈希表是哈希思想实现的数据结构，是值和存储位置建立映射关系。 但是，值和存储位置建立映射关系也会存在问题：
1.值很分散（如1,5,1000,52,18），这样就需要很多的存储位置，很多存储位置没有被使用，会被浪费
2.有些值不好映射，如string、结构体对象
为了解决第一个问题，提出了除留余数法，i=key%空间的大小，这样就做到空间和值的范围无关，
但是这样就会引入另外一个问题--哈希冲突，
哈希冲突 也叫哈希碰撞，不同的值可能会映射到相同位置（如上面的10001和1），
为了解决互哈希冲突的问题，提出了两种解决方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70068b7f4fe853cafb8b65c099baa91f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4358a48a5c4124d1146cd13ea568f37/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(036)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
111、pandas.Series.item方法
111-1、语法
111-2、参数
111-3、功能
111-4、返回值
111-5、说明
111-6、用法
111-6-1、数据准备
111-6-2、代码示例
111-6-3、结果输出
112、pandas.Series.xs方法
112-1、语法
112-2、参数
112-3、功能
112-4、返回值
112-5、说明
112-6、用法
112-6-1、数据准备
112-6-2、代码示例
112-6-3、结果输出
113、pandas.Series.add方法
113-1、语法
113-2、参数
113-3、功能
113-4、返回值
113-5、说明
113-6、用法
113-6-1、数据准备
113-6-2、代码示例
113-6-3、结果输出
114、pandas.Series.sub方法
114-1、语法
114-2、参数
114-3、功能
114-4、返回值
114-5、说明
114-6、用法
114-6-1、数据准备
114-6-2、代码示例
114-6-3、结果输出
115、pandas.Series.mul方法
115-1、语法
115-2、参数
115-3、功能
115-4、返回值
115-5、说明
115-6、用法
115-6-1、数据准备
115-6-2、代码示例
115-6-3、结果输出
二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 111、pandas.Series.item方法 111-1、语法 # 111、pandas.Series.item方法 pandas.Series.item() Return the first element of the underlying data as a Python scalar.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4358a48a5c4124d1146cd13ea568f37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a863bed17046cdc3b0ec8b7bd291e61d/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(035)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
106、pandas.Series.iloc方法
106-1、语法
106-2、参数
106-3、功能
106-4、返回值
106-5、说明
106-6、用法
106-6-1、数据准备
106-6-2、代码示例
106-6-3、结果输出
107、pandas.Series.__iter__魔法方法
107-1、语法
107-2、参数
107-3、功能
107-4、返回值
107-5、说明
107-6、用法
107-6-1、数据准备
107-6-2、代码示例
107-6-3、结果输出
108、pandas.Series.items方法
108-1、语法
108-2、参数
108-3、功能
108-4、返回值
108-5、说明
108-6、用法
108-6-1、数据准备
108-6-2、代码示例
108-6-3、结果输出
109、pandas.Series.keys方法
109-1、语法
109-2、参数
109-3、功能
109-4、返回值
109-5、说明
109-6、用法
109-6-1、数据准备
109-6-2、代码示例
109-6-3、结果输出
110、pandas.Series.pop方法
110-1、语法
110-2、参数
110-3、功能
110-4、返回值
110-5、说明
110-6、用法
110-6-1、数据准备
110-6-2、代码示例
110-6-3、结果输出
二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 106、pandas.Series.iloc方法 106-1、语法 # 106、pandas.Series.iloc方法 pandas.Series.iloc Purely integer-location based indexing for selection by position.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a863bed17046cdc3b0ec8b7bd291e61d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16e08288d1f69da4f0532fa71aaa9cfd/" rel="bookmark">
			电力需求预测挑战赛｜Datawhale AI夏令营第二期｜代码及笔记分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最新分数：215.14567（13/1605）
赛题简介 赛事链接：电力需求预测挑战赛（科大讯飞xDatawhale）
给定多个房屋对应电力消耗历史N天的相关序列数据等信息，预测房屋对应电力的消耗。主要特征包括房屋id，日标识dt（1为数据集最近1天），房屋类型type，预测目标电力消耗target。本赛题是一个典型的多变量时间序列问题。当下时间序列预测的方法主要有三种：
1.传统的时间序列预测方法，ARIMA和指数平滑法
2.基于机器学习的方法，lightgbm、xgboost、catboost
3.基于深度学习的方法，RNN、LSTM、Wavenet
数据读取 导入必要的库，pandas、numpy、scipy等用于数据读取和计算，sklearn、lightgbm、xgboost、catboost等用于模型训练，tqdm用于处理进程的可视化展示，joblib用于模型的保存和加载，以及其他涉及系统变量的库。
训练集共有2877305行数据，时间范围为11-506不等。
测试集共有58320行数据，时间范围为1-10。
探索性数据分析 基本信息
定义data_stats函数展示数据集的基本信息情况，包括属性个数、最大属性占比、特征类型。
def data_stats(data): stats = [] for col in data.columns: stats.append((col, data[col].nunique(), round(data[col].value_counts(normalize = True, dropna = False).values[0] * 100, 3), data[col].dtype)) stats_df = pd.DataFrame(stats, columns = ['特征','属性个数','最大属性占比','特征类型']) return stats_df data_stats(train) 特征属性个数最大属性占比特征类型0id58320.017object1dt4960.203int642type1920.722int643target1813040.004float64 data_stats(test) 特征属性个数最大属性占比特征类型0id58320.017object1dt1010.000int642type1920.645int64 不同type类型对应target的柱状图
可以发现不同type对应的电力需求存在比较大的差异，因此type应该是模型训练中的一个重要特征，可以根据type构建多个特征。
type_target_df = train.groupby('type')['target'].mean().reset_index() plt.figure(figsize=(8, 4)) plt.bar(type_target_df['type'], type_target_df['target'], color=['#5ba2e6', '#f89732']) plt.xlabel('Type') plt.ylabel('Average Target Value') plt.title('Bar Chart of Target by Type') plt.show() 不同id的target变化趋势折线图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16e08288d1f69da4f0532fa71aaa9cfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61074dfd49f6dfceeb50a8ab40a427b8/" rel="bookmark">
			Flink调优详解：案例解析（第42天）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 一、Flink-任务参数配置
二、Flink-SQL调优
三、阿里云Flink调优
文章目录 系列文章目录前言一、Flink-任务参数配置1.1 运行时参数1.2 优化器参数1.3 表参数 二、Flink-SQL调优2.1 mini-batch聚合2.2 两阶段聚合2.3 分桶2.4 filter去重（了解） 三、阿里云Flink调优3.1 智能调优3.2 定时调优 前言 本文主要详解常见的Flink优化策略。
官网地址：https://nightlies.apache.org/flink/flink-docs-release-1.15/docs/dev/table/config/ 一、Flink-任务参数配置 1.1 运行时参数 异步维度join # 默认值：100 # 值类型：Integer # 流批任务：流、批任务都支持 # 用处：异步 lookup join 中最大的异步 IO 执行数目 table.exec.async-lookup.buffer-capacity: 100 开启微批 # 默认值：false # 值类型：Boolean # 流批任务：流任务支持 # 用处：MiniBatch 优化是一种专门针对 unbounded 流任务的优化（即非窗口类应用），其机制是在 `允许的延迟时间间隔内` 以及 `达到最大缓冲记录数` 时触发以减少 `状态访问` 的优化，从而节约处理时间。下面两个参数一个代表 `允许的延迟时间间隔`，另一个代表 `达到最大缓冲记录数`。 table.exec.mini-batch.enabled: false # 默认值：0 ms # 值类型：Duration # 流批任务：流任务支持 # 用处：此参数设置为多少就代表 MiniBatch 机制最大允许的延迟时间。注意这个参数要配合 `table.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61074dfd49f6dfceeb50a8ab40a427b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38370e857358628c92d14a5fcf0e3700/" rel="bookmark">
			科普文：百度交易中台之系统对账篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		百度交易中台作为集团移动生态战略的基础设施，面向收银交易与清分结算场景，赋能业务、提供高效交易生态搭建。目前支持百度体系内多个产品线，主要包括：度小店、小程序、地图打车、文心一言等。本文主要介绍了百度交易中台的交易链路系统数据一致性的对账系统，主要从准实时对账和大数据离线对账两个方向进行介绍。
01前言 交易中台为百度小程序、百度地图打车、百度健康、百度文库、百度电商等业务提供了支付、订单、结算等交易服务能力，随着交易业务的飞速发展，交易订单量逐日增加，同时每日产生的交易GMV和清结算资金也是一个很大的体量。主要涉及交易订单、支付通道账单、交易营销、交易履约、数据中心、结算中心、商家资金池、银行打款、数据账房以及百信银行等交易内部10+的链路系统的交易数据，本篇的系统对账主要介绍了如何去实现和保障交易数据的准确性和一致性。
02系统介绍 交易系统链路核心包括收银台、交易订单、交易营销、交易履约、数据中心、结算中心、资金池及数据账房：
收银台：提供聚合支付能力，支持微信、支付宝、银联对公、银联对私、度小满支付、百度闪付、汇付天下和京东支付等通道，产生收银台支付单和收银台退款单；
交易订单：打通用户、商家、商品、库存、售后等关键业务，是驱动交易全流程运转的核心。而订单系统承上启下，作为入口，涵盖了订单流程管理、库存与营销管理、算价引擎、履约子流程、售后以及退款信息管理等，产生交易订单和退款订单；
交易营销：提供了营销预算、营销库存以及营销活动的能力，旨在通过促销活动和特定的交易条件来吸引顾客并推动销售增长，产生营销订单；
交易履约：按照商家签约商品的约束关系，兑现或取消已兑换交易商品提供的对应服务，产生履约订单和取消履约订单；
数据中心：收拢交易订单、退款订单、履约订单和取消履约订单，补充结算协议及商家供应商等结算中心依赖的关键数据，产生凭证订单；
结算中心：依据结算协议规则将凭证订单的货款结算至对应的商家供应商。产生结算账单，最终汇入商家资金池；
资金池：提供商家资金余额、商家资金流水以及商家打款的能力。提供商家资金池交易流水、商家资金池余额和商家付款凭证；
数据账房：交易中台数据的统一出口，涵盖订单、结算账单和资金池流水等，商家通过该系统可直接查询收入/其他款项/支出等流水信息，提供按天/月/年的财务对账。
整体概括如下图：
交易中台链接外部核心系统有百信银行和聚合支付渠道：
百信银行：承接了交易中台交易的收单、清分以及清算，从而实现了"一清"。提供“一清成交”、“一清核销”、“一清收入”以及“一清打款”的指令账单；
“一清成交”：交易中台与百信银行交互的收款账单和退款账单的指令。
“一清核销”：交易中台与百信银行交互的核销资金流水账单的指令。
“一清收入”：交易中台与百信银行交互的收取结算服务通道费用的指令。
“一清打款”：交易中台与百信银行交互的商家资金池自动打款至银行卡的指令。
聚合支付渠道：包括微信、支付宝、银联对公、银联对私、中行数币支付、度小满支付、百度闪付、汇付天下和京东支付等，提供渠道支付账单。
03背景&amp;问题 随着交易中台支付业务的多元化，交易订单量迅速增长且蓬勃发展，交易支付及结算业务的复杂性也在不断的提高，总结下来，有以下几个特点：
1.交易场景多：有带货场景（分销带货和自带货）、购物车场景、多方分账场景、宿主营销场景以及跨境支付业务场景等，每种场景都有独特的交易和结算模式。
2.交易链路长：从支付到清算，需要跨收银台—&gt;交易—&gt;履约—&gt;数据中心—&gt;结算中心—&gt;资金池—&gt;账房，需要保障链路系统的数据一致性。
3.单量大：日订单量，月结算金额等快速增长，月交易数据体量也在不断扩张，达到了TB级别。
在这样的交易背景下，我们要保障交易数据的准确性和时效性，同时还需要保障履约、结算、资金账单以及商家付款的时效性和数据一致性，这就给我们的对账系统带来了巨大的挑战。简单介绍下交易系统运行过程中出现过的问题，如下图：
从上边的问题可以看出，基本上都是系统间数据不一致导致的，当然不仅限于这些场景。凡是有系统交互，数据交互的场景，都会出现此类问题，也就是“数据一致性”的问题。
“数据不一致”的原因有很多，如下：
1.高并发处理不当，接口幂等问题。
2.网络环境故障：机房网络抖动、数据库网络异常、消息中间件服务异常等。
3.线上代码bug, 业务方接入流程不完善等。
“数据不一致”带来的影响，如下：
1.影响用户支付下单，进而给业务方带来用户和订单的损失。
2.结算不及时，带来高客诉，更严重的可能带来资损。
3.影响财务结账，需投入大量人力来解决不一致的数据问题。
关于一致性问题，业内的解决方案已经非常成熟，从百度搜索“一致性问题”，随处都是此类问题的阐述、概念的定义、解决思路以及解决方案，比如：
1.强一致性协议: 两阶段提交、三阶段提交、TCC (Try-Confirm-Cancel)等。
2.最终一致性: 主动轮询、异步确保、可靠消息、消息事务等。
这些方案的目标都是在事中避免问题的发生，但是在现实交易的场景中，无论是系统内部，还是系统与外部环境的交互都是复杂多变、不可预知，很难完全避免“数据不一致”问题的发生。因此在事后对数据问题的发现并及时修复也非常重要。这也是本篇文章要讲述的“对账系统”的核心功能。
本篇介绍的对账系统涵盖了“准实时”对账和“T+1”离线对账两种能力：
1.“准实时”对账系统：监听交易链路系统数据库的binlog文件，上游系统针对下游系统会有数据推送，下游系统会针对上游系统推送的数据进行处理，处理结束之后进行回调或通知。
2.“T+1”离线对账系统：使用大数据计算完成对账，依托ETL工具进行数据同步，SPARK、SPAKR-SQL、AFS等大数据技术完成系统间数据的对账，及时发现数据差异、差异数据预警以及差异数据的自动修复能力。
04对账系统 4.1 “准实时”对账系统 4.1.1 系统概况 “准实时”旨在提供一套可以及时发现数据问题并及时对问题进行修复的自动化对账系统，开发专用平台，实时针对系统间的数据同步问题进行追溯和处理。设计思路如下图：
4.1.2 系统实现 通过DTS平台监听交易链路系统中数据库的binlog文件，将binlog消息发送至BP。
消费BP数据，采集上下游系统的数据集，抽象上下游系统间的数据结构，一次上游系统的推送和下游系统的接收作为一对元信息，进行存储。
依据监控配置信息，定时监控未成对出现的对账元信息，自动调用修复接口并完成异常对账元信息的预警。
对账结果可视化，依托自助化sugar报表平台，完成对账结果的可视化分析报表。
整体架构图如下：
对账服务：
对账配置：实现上下游系统间对账的自动化接入；
生产者服务：完成BP消息上游系统生产数据的解析和处理；
消费者服务：完成BP消息下游系统生产数据的解析和处理；
对账元数据：生成者和消费者产生的成对数据，每一对元数据代表上下游系统之间的一次交互；
对账服务：完成元数据的对账，依据监控配置信息，定时监控未成对出现的对账元信息，自动调用修复接口并完成异常元信息的预警；
可视化报表：基于Sugar报表平台，提供对账结果的可视化分析报表，包括差异数据统计，对账差异率及自动修复结果等。
4.2 “T+1”离线对账系统 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38370e857358628c92d14a5fcf0e3700/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6698299447ea497cae0ecb99d499129/" rel="bookmark">
			基于springboot&#43;vue&#43;uniapp的流浪动物救助小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发语言：Java框架：springboot+uniappJDK版本：JDK1.8服务器：tomcat7数据库：mysql 5.7（一定要5.7版本）数据库工具：Navicat11开发软件：eclipse/myeclipse/ideaMaven包：Maven3.3.9 系统展示
用户信息管理
寻宠信息管理
动物求助管理
论坛信息管理
摘要
流浪动物救助小程序使用Java语言进行编码，使用Mysql创建数据表保存本系统产生的数据。系统可以提供信息显示和相应服务，其管理流浪动物救助小程序信息，查看流浪动物救助小程序信息，管理流浪动物救助小程序。
总之，流浪动物救助小程序集中管理信息，有着保密性强，效率高，存储空间大，成本低等诸多优点。它可以降低信息管理成本，实现信息管理计算机化。
研究背景
互联网发展至今，无论是其理论还是技术都已经成熟，而且它广泛参与在社会中的方方面面。它让信息都可以通过网络传播，搭配信息管理工具可以很好地为人们提供服务。所以各行业，尤其是规模较大的企业和学校等都开始借助互联网和软件工具管理信息，传播信息，共享信息等等，以此可以增强自身实力，提高在同行业当中的竞争能力，并从各种激烈的竞争中获取发展的机会。针对高校教师成果信息管理混乱，出错率高，信息安全性差，劳动强度大，费时费力等问题，经过分析和考虑，在目前的情况下，可以引进一款流浪动物救助小程序这样的现代化管理工具，这个工具就是解决上述问题的最好的解决方案。它不仅可以实时完成信息处理，还缩短高校教师成果信息管理流程，使其系统化和规范化。同时还可以减少工作量，节约高校教师成果信息管理需要的人力和资金。所以流浪动物救助小程序是信息管理环节中不可缺少的工具，它对管理者来说非常重要。
关键技术
SpringBoot是一个全新开源的轻量级框架。基于Spring4.0设计，其不仅继承了Spring框架原来有的优秀特性，而且还通过简化配置文件来进一步简化了Spring应用的整个搭建以及开发过程。另外在原本的Spring中由于随着项目的扩大导入的jar包数量越来越大，随之出现了jar包版本之间的兼容性问题，而此时SpringBoot通过集成大量的框架使得依赖包的版本冲突，以及引用的不稳定性问题得到了很好的解决。
JS-SDK是对之前的 WeixinJSBrige 的一个包装，以及新能力的释放，并且由对内开放转为了对所有开发者开放，在很短的时间内获得了极大的关注。从数据监控来看，绝大部分在微信内传播的移动网页都使用到了相关的接口。
JS-SDK 解决了移动网页能力不足的问题，通过暴露微信的接口使得 微信小程序 开发者能够拥有更多的能力，然而在更多的能力之外，JS-SDK 的模式并没有解决使用移动网页遇到的体验不良的问题。用户在访问网页的时候，在浏览器开始显示之前都会有一个的白屏过程，在移动端，受限于设备性能和网络速度，白屏会更加明显。我们团队把很多技术精力放置在如何帮助平台上的微信小程序开发者解决这个问题。因此我们设计了一个 JS-SDK 的增强版本，其中有一个重要的功能，称之为“微信 微信小程序 资源离线存储”。
JAVA语言是目前软件市场上应用最广泛的语言开发程序。可以在多种平台上运用的，兼容性比较强，适应市面上大多数操作系统，不会出现乱码的现象，其扩展性和维护性都更好，具有分析问题和解决问题的能力，是面向过程的程序设计方便我们编写的代码更强壮。
Vue是一款流行的开源JavaScript框架，用于构建用户界面和单页面应用程序。Vue的核心库只关注视图层，易于上手并且可以与其他库或现有项目轻松整合。
MYSQL数据库运行速度快，安全性能也很高，而且对使用的平台没有任何的限制，所以被广泛应运到系统的开发中。MySQL是一个开源和多线程的关系管理数据库系统，MySQL是开放源代码的数据库，具有跨平台性。
B/S（浏览器/服务器）结构是目前主流的网络化的结构模式，它能够把系统核心功能集中在服务器上面，可以帮助系统开发人员简化操作，便于维护和使用。
系统分析
对系统的可行性分析以及对所有功能需求进行详细的分析，来查看该系统是否具有开发的可能。
系统设计
功能模块设计和数据库设计这两部分内容都有专门的表格和图片表示。
系统实现
用户信息管理页面，此页面提供给管理员的功能有：用户信息的查询管理，可以删除用户信息、修改用户信息、新增用户信息，还进行了对用户名称的模糊查询的条件。寻宠信息管理页面，此页面提供给管理员的功能有：查看已发布的寻宠信息数据，修改寻宠信息，寻宠信息作废，即可删除，还进行了对寻宠信息名称的模糊查询 寻宠信息的类型查询等等一些条件。动物求助管理页面，此页面提供给管理员的功能有：根据动物求助进行条件查询，还可以对动物求助进行新增、修改、查询操作等等。论坛信息管理页面，此页面提供给管理员的功能有：根据论坛信息进行新增、修改、查询操作等等。
系统测试
在系统编码完成之后，完成对本系统的测试工作，其主要的任务还是找出本系统可能出现的错误，而且是发现的错误越多越好，因为每发现一个程序错误，都需要进行文档记载，然后根据这些记载程序错误的文档，采取各种措施去解决这些程序问题，逐渐完善程序。所以，测试并不是去证明开发的系统是正确的，而是通过各种各样的方式去寻找系统中的缺陷，并针对性的完善系统。这样才能保证系统在实际运行中，可以保质保量的进行工作。
结论
采用Java+Mysql的方式设计制作的流浪动物救助小程序，在功能上可以满足管理人员对于信息的管理需求；在界面的设计上，尽最大努力用自身的美工知识做到界面美观简洁。在操作方面上，让系统可以方便操作，同时对用户常见的误操作行为进行分析总结，并尽力在系统中避免同样的由于用户的误操作所带来的错误现象。
（可运行源码+sql文件+文档）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f580a372cfa02905302adf2307afa44/" rel="bookmark">
			python-快速上手爬虫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
道路千万条，安全第一条
爬虫不谨慎，亲人两行泪
一点小小的准备工作
直接上手爬取网页
1.获取UA伪装
2.获取url
3.发送请求
4.获取响应数据进行解析并保存
总结
前言 道路千万条，安全第一条 爬虫不谨慎，亲人两行泪 一点小小的准备工作 对pip进行换源：win+r 打开命令提示符，输入cmd ，回车，将此串代码复制粘贴，将pip换成清华大学的镜像源
pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 换好了之后：再次win+r 打开命令提示符，输入cmd ，回车，输入下列代码，安装requests库用以爬虫
pip install requests 直接上手爬取网页 爬虫的本质就是模拟浏览器上网的过程
记住爬虫的四个步骤，UA伪装--&gt;获取网站url--&gt;发送请求--&gt;获取数据并保存
import requests if __name__ == '__main__': # UA伪装 head = { "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36 Edg/126.0.0.0" } # 获取网址 url = "https://baike.baidu.com/item/%E5%91%A8%E6%9D%B0%E4%BC%A6/129156" # 发送请求 response = requests.get(url, headers=head) # 获取数据并保存 with open("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f580a372cfa02905302adf2307afa44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6e61c67558df1b5970e957d5164d058/" rel="bookmark">
			[MySQL][事务管理][中][事务常见操作方式]详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 0.准备工作1.操作演示2.总结3.事务操作注意事项 0.准备工作 # 为了便于演示，将mysql的默认隔离级别设置成读未提交。 mysql&gt; set global transaction isolation level READ UNCOMMITTED; # 需要重启终端，进行查看 mysql&gt; select @@tx_isolation; +------------------+ | @@tx_isolation | +------------------+ | READ-UNCOMMITTED | +------------------+ 简单银行用户表create table if not exists account( id int primary key, name varchar(50) not null default '', blance decimal(10,2) not null default 0.0 )ENGINE=InnoDB DEFAULT CHARSET=UTF8; 1.操作演示 正常演示 - 证明事务的开始与回滚-- 查看事务是否自动提交。故意设置成自动提交，看看该选项是否影响begin mysql&gt; show variables like 'autocommit'; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | autocommit | ON | +---------------+-------+ mysql&gt; start transaction; -- 开始一个事务begin也可以，推荐begin mysql&gt; savepoint save1; -- 创建一个保存点save1 mysql&gt; insert into account values (1, '张三', 100); -- 插入一条记录 mysql&gt; savepoint save2; -- 创建一个保存点save2 mysql&gt; insert into account values (2, '李四', 10000); -- 再插入一条记录 mysql&gt; select * from account; -- 两条记录都在了 +----+--------+----------+ | id | name | blance | +----+--------+----------+ | 1 | 张三 | 100.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6e61c67558df1b5970e957d5164d058/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/433a5156d2cfc946c2252c0195d7f4e0/" rel="bookmark">
			react入门到实战-day1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这react门课我是学习b站黑马的课程，不是打公告哈，我只是过一遍，让自己对学过的知识有印象，所以笔记是有很大部分直接复制总结过来的，方便后面的我进行复习。如有冒犯，联系必删
React介绍以及创建方式 React由Meta公司研发，是一个用于 构建Web和原生交互界面的库 react优势： 相较于传统基于DOM开发的优势-组件化开发方式、不错的性能 相较于其它前端框架的优势-丰富的生态、跨平台的支持 create-react-app是一个快速 创建React开发环境的工具， 底层由Webpack构建， 封装了配置细节 ，开箱即用 执行命令： npx create-react-app react-basic 1. npx Node.js工具命令，查找并执行后续的包命令 2. create-react-app 核心包（固定写法），用于创建React项目 3. react-basic React项目的名称（可以自定义） 创建React项目的更多方式 https://zh-hans.react.dev/learn/start-a-new-react-project 两大核心包：react、react-dom src中保留index.js、App.js文件，其他创建文件删掉 index.js // 项目的根组件 // APP=&gt;index.js-&gt;public/index.html(root) function App() { return ( &lt;div className="App"&gt; this is &lt;/div&gt; ); } export default App; App.js
// 项目的根组件 // APP=&gt;index.js-&gt;public/index.html(root) function App() { return ( &lt;div className="App"&gt; this is &lt;/div&gt; ); } export default App; JSX基础 JSX是JavaScript和XMl(HTML)的缩写，表示在JS代码中编写HTML模版结构，它是React中构建UI的方式 优势： 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/433a5156d2cfc946c2252c0195d7f4e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f17bb534029d333eb743eabf0fe89062/" rel="bookmark">
			Java GC（垃圾回收）机制详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Java GC（垃圾回收）机制详解 1、GC触发的条件2、GCRoots的对象类型 💖The Begin💖点点关注，收藏不迷路💖 在Java的世界里，内存管理是自动进行的，其中垃圾回收（Garbage Collection, GC）是核心的一环。
1、GC触发的条件 Java中，GC的触发主要有两种方式：
显式触发：通过程序调用System.gc()或Runtime.getRuntime().gc()方法，向JVM发出建议进行垃圾回收的请求。但请注意，这仅仅是建议，JVM可以忽略这个请求。
隐式触发：由JVM根据内部算法和内存使用情况自动决定。当堆内存中的对象空间不足以满足新对象分配时，JVM会自动触发GC以尝试回收内存。
2、GCRoots的对象类型 在Java中，GC Roots是对象图遍历的起始点，它们是在垃圾回收过程中，被JVM视为存活的对象。GC Roots主要包括以下几种：
虚拟机栈中引用的对象：包括局部变量和参数等。方法区中类静态属性引用的对象：类的静态变量引用的对象。方法区中常量引用的对象：如字符串常量池中的对象。本地方法栈中JNI（Java Native Interface）引用的对象：由JNI调用本地方法时，本地方法栈中引用的对象。 💖The End💖点点关注，收藏不迷路💖 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f295a21218f79ab6b446221e28397aa/" rel="bookmark">
			【系统架构设计 每日一问】一 在单表查询的情况下，ES快还是mysql快
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在单表查询的情况下，Elasticsearch（ES）和MySQL的查询速度对比并非绝对，而是取决于多个因素，包括查询类型、数据量大小、索引策略、系统配置等。以下是对两者在单表查询速度方面的详细分析：
一、查询类型 Elasticsearch（ES）：
ES是一个分布式搜索和分析引擎，专为全文搜索和实时分析设计。它使用倒排索引来加速搜索，对于包含大量文本字段的查询非常高效。ES特别擅长处理复杂查询，如全文搜索、范围查询、聚合查询等。对于简单的单表等值查询（如ID查询），ES的响应速度可能不如经过优化的MySQL，因为ES需要额外的解析和索引查询开销。 MySQL：
MySQL是一个关系型数据库管理系统，以表的形式存储数据，并通过SQL语言进行数据操作。MySQL在数据一致性和事务管理方面表现良好，适用于需要强一致性和事务支持的场景。对于简单的单表等值查询（如主键查询），MySQL的响应速度通常非常快，因为MySQL可以直接通过主键索引快速定位到数据。 二、数据量大小 当数据量较小时，MySQL和ES在单表查询上的性能差异可能并不明显。然而，随着数据量的增加，ES的分布式架构和倒排索引的优势将逐渐显现。ES能够扩展到数百台服务器，支持海量数据的存储和检索。在大数据量下，ES的查询性能通常优于MySQL。 三、索引策略 ES默认会对写入的数据建立索引，并常驻内存，这使得ES在查询时能够迅速定位到数据。然而，这也意味着ES在写入数据时需要额外的索引构建时间。MySQL也支持索引，但索引的构建和维护需要数据库管理员根据查询模式进行优化。在适当的索引策略下，MySQL的查询性能可以得到显著提升。 四、系统配置 系统配置（如硬件资源、网络带宽等）也会对查询速度产生影响。在相同的系统配置下进行比较更为公平。 五、总结 对于简单的单表等值查询，且数据量不大时，MySQL的查询速度可能更快。对于包含大量文本字段的复杂查询或大数据量下的查询，ES的查询速度通常优于MySQL。 因此，在单表查询的情况下，ES和MySQL哪个更快并没有绝对的答案。它取决于具体的查询类型、数据量大小、索引策略和系统配置等多个因素。在实际应用中，应根据具体需求选择合适的数据库系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b87279d01864fc55178ecea7c48b7313/" rel="bookmark">
			【C&#43;&#43;】深入探索vector，让你一次性学懂！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
⭐了解vector类
⭐vector的使用
✨vector的定义
✨vector iterator 的使用
✨ vector 容量空间
✨vector 增删查改
⭐了解vector类 vector是表示可变大小数组的序列容器。就像数组一样，vector也采用的连续存储空间来存储元素。也就是意味着可以采用下标对vector的元素 进行访问，和数组一样高效。但是又不像数组，它的大小是可以动态改变的，而且它的大小会被容器自动处理。本质讲，vector使用动态分配数组来存储它的元素。当新元素插入时候，这个数组需要被重新分配大小 为了增加存储空间。其做法是，分配一个新的数组，然后将全部元素移到这个数组。就时间而言，这是一个相对代价高的任务，因为每当一个新的元素加入到容器的时候，vector并不会每次都重新分配大 小。vector分配空间策略：vector会分配一些额外的空间以适应可能的增长，因为存储空间比实际需要的存 储空间更大。不同的库采用不同的策略权衡空间的使用和重新分配。但是无论如何，重新分配都应该是对数增长的间隔大小，以至于在末尾插入一个元素的时候是在常数时间的复杂度完成的。因此，vector占用了更多的存储空间，为了获得管理存储空间的能力，并且以一种有效的方式动态增 长。与其它动态序列容器相比（deque, list and forward_list）， vector在访问元素的时候更加高效，在末 尾添加和删除元素相对高效。对于其它不在末尾的删除和插入操作，效率更低。比起list和forward_list 统一的迭代器和引用更好。 在使用vector类时，必须包含#include&lt;vector&gt;头文件以及using namespace std;
⭐vector的使用 首先要学会查看文档：vector的文档介绍。
更详细的使用介绍，可以转至：STL—vector详解
✨vector的定义 (constructor)构造函数声明接口说明vector();无参构造vector(size_type n,const value_type&amp; val = val_type);构造并初始化n个valvector (const vector&amp; x);拷贝构造vector (InputIterator first, InputIterator last);使用迭代器进行初始化构造 // constructors used in the same order as described above: vector&lt;int&gt; first; // empty vector of ints vector&lt;int&gt; second(4, 100); // four ints with value 100 vector&lt;int&gt; third(second.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b87279d01864fc55178ecea7c48b7313/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c2a8d5c64288d9915a6262ba111848e/" rel="bookmark">
			Datawhale AI夏令营-多模态Task3学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Task3学习笔记 这是结束，亦或是新的开始。
学习任务 数据增强，提升模型表现。
Faster, faster, faster!
基础知识 为什么需要数据增强 先看一下Datawhale教研人员给出的解释：
数据增强是一种在机器学习和深度学习领域常用的技术，尤其是在处理图像和视频数据时。数据增强的目的是通过人工方式增加训练数据的多样性，从而提高模型的泛化能力，使其能够在未见过的数据上表现得更好。数据增强涉及对原始数据进行一系列的变换操作，生成新的训练样本。这些变换模拟了真实世界中的变化，对于图像而言，数据增强包括例如视角、光照、遮挡等情况，使得模型能够学习到更加鲁棒的特征表示。
如何解读呢？
数据自然是越多越好，但现实中，这可能会起反作用。
首先，随着人们进入信息时代，需要处理的数据呈爆炸式增长，现有的设备很难一次性存储或者使分批处理的速度和数据增长的速度同步。
再者，计算机不是0就是1，认死理，那些数据只要哪怕结构上有一点变化，那就会变成新数据，不像人类可以通过反向操作进行真正意义上的归一化。比如一张照片的不同分辨率结果在计算机看来就是不同的样本。
其次，如果神经网络没有跟随数据完善结构，极有可能在现有的规模上造成“过拟合”现象，那神经网络将不再具有思考能力，而是变成形如复读机的存在。
假设我要训练一个模型，让它可以检测出一只鸽子大不大。很明显，这个”大不大“不是计算机的物理电路规定的，是人规定的。因此得使用监督学习思路。
那我将使用下列思路：
图像根据RGB分割成三个矩阵，按行拼接形成新的列向量。
使用监督学习思路，给每一张照片进行标签分类，并投入神经网络进行计算。
那大概就是这样的
如果这些数据都是像下方Datawhale提供的样张那样规范，那就好说了。
可这种图片并不代表日常的生活情景啊！这不，挑战者就来了。
这只鸽子大不大？很明显，不大，这是因为透视原理所以显得它大。可惜计算机不知道什么是透视原理，它只知道0和1。
可是，我们的数据中只有图片的RGB特征这种十分泛的特征，之前并没有将照片的透视原理量化并投入训练。所以，此时的神经网络就不会去想为什么透视原理会影响对物体大小的判定，那它就只能为了逻辑回归的成功生凑参数了，此时模型将进入过拟合状态，一般在准确率测试下，精度可以达到100%。
可这样的参数并不符合人类的逻辑，对于解决人类日常生活中的问题是没有意义的。
想尝试对计算机进行新的监督学习以修正结果？那它估计也只会用那不太够用的神经网络问道:
道理我都懂，可是为什么鸽子这么大？然后你又说它是小的？
计算机此时说的道理是一坨人类觉得不可理喻的东西。
这个模型的判断就离谱，你老刷那B三色干什么玩意啊？
可我们人类命令它在训练时，也没教它什么是透视原理啊？
看吧，深度学习的神经网络终究还是得让人手把手一步步扣好它数据生涯的第一粒扣子。可我要是能完全解释这一切我要这神经网络有何用？
数据增强，本身也是得告诉神经网络得做点人该干的事。
2.数据获取可能会受阻
深度学习在影像分类方面是一个热闹研究方向，所以，有兴趣在医学影像方向进行研究吗？医生可以以他们的职业生涯作为担保，所有的数据都是真实的。
我的大创有幸接触到了相关领域，需要使用相关的技术对病人的心脏进行3D建模，然后利用训练得出的模型将疑似病灶处的模型分离出来。
有前景吗？有，将病人从物理检测的痛苦中解放出来——传统的方法中，病人需要被人工植入一根压力导丝，随着心脏的跳动，将物理量转化为电信号，最终转化成我们需要的数据流。想象一下鼻腔镜检查时，医生为了消毒将两根棉签直接插入鼻孔深处的经历——正常人受这刺激会当场喷出大量的鼻涕，这不好受，那心脏被这样对待了能好受吗？
能迅速投入使用吗？不可能，所有的模型都不可能有100%准确率，万一结果导致医生误判了怎么办？谁负责？所以，这样的模型训练过程中要经过严格的医学实验阶段，也就是说，要用病人的隐私数据作为训练集投入训练的同时，还得给他/她埋压力导丝，最后结果要作比对，这简直是双重折磨。
这样的数据一是大医院才有设备能采集，二是病人的隐私数据能随意的被挪用，被收集吗？肯定要经过病人同意啊。那对于医生，不尊重病人的隐私是违反希波克拉底誓言的典型行为，对于研究人员，将活人作为实验，不尊重人的尊严，更是对人类伦理的挑战。
所以，总会有一些研究领域因为这样那样的原因，光是数据获取的过程就已经十分艰难了。那能怎么办呢？总得有人做点什么来证明那些幻想，那些深邃的黑暗幻想。
所以，帮帮我，数据增强！
数据增强要怎么做 如果数据增强的变换操作与目标任务的实际场景不符，比如在不需要旋转的图像任务中过度使用旋转，那么这些变换可能会引入无关的噪音。此外过度的数据增强，比如极端的亮度调整、对比度变化或大量的噪声添加，可能会导致图像失真，使得模型难以学习到有效的特征。
总之，我们希望深度学习能像人一样思考，就别把自己整得像个似人。
实际优化实践 Talk is useless, show me the code.
在之前的代码中我们使用PyTorch框架来加载和增强图像数据：
图像大小调整：使用transforms.Resize((256, 256))将所有图像调整到256x256像素的尺寸，这有助于确保输入数据的一致性。
随机水平翻转：transforms.RandomHorizontalFlip()随机地水平翻转图像，这种变换可以模拟物体在不同方向上的观察，从而增强模型的泛化能力。
随机垂直翻转：transforms.RandomVerticalFlip()随机地垂直翻转图像，这同样是为了增加数据多样性，让模型能够学习到不同视角下的特征。
转换为张量：transforms.ToTensor()将图像数据转换为PyTorch的Tensor格式，这是在深度学习中处理图像数据的常用格式。
归一化：transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])对图像进行归一化处理，这里的均值和标准差是根据ImageNet数据集计算得出的，用于将图像像素值标准化，这有助于模型的训练稳定性和收敛速度。
train_loader = torch.utils.data.DataLoader( FFDIDataset(train_label['path'].head(1000), train_label['target'].head(1000), transforms.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c2a8d5c64288d9915a6262ba111848e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/699c92201064ece94e2247579c2e9a4a/" rel="bookmark">
			SpringBoot中fastjson扩展: 自定义序列化和反序列化方法实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		❃博主首页 ： 「码到三十五」 ，同名公众号 :「码到三十五」，wx号 : 「liwu0213」 ☠博主专栏 ： &lt;mysql高手&gt; &lt;elasticsearch高手&gt; &lt;源码解读&gt; &lt;java核心&gt; &lt;面试攻关&gt; ♝博主的话 ： 搬的每块砖，皆为峰峦之基；公众号搜索「码到三十五」关注这个爱发技术干货的coder，一起筑基 目录 1. 扩展点的用途2. 序列化扩展点2.1. SerializeFilter2.2. SerializerFeature2.3. SerializeConfig2.4. 自定义序列化器（Serializer）2.5. 序列化过滤器（SerializeFilter）2.6. 自定义日期格式化 2. 反序列化扩展点2.1. ParseProcess2.2. ParserConfig2.3. 自定义反序列化器（Deserializer）2.4. 解析过程（ParseProcess） 在fastjson库中，为了提供灵活的序列化和反序列化机制，设计了一系列的扩展点。以下是在SpringBoot和SpringClould环境中对这些扩展点的详细介绍及其实战使用：
1. 扩展点的用途 fastjson提供的这些扩展点为用户提供了极大的灵活性，可以根据实际需求定制序列化和反序列化的行为。SpringBoot和SpringClould环境中,可以通过SerializeFilter和ParserProcess定制复杂的序列化和反序列化逻辑，通过SerializerFeature和ParserFeature控制序列化和反序列化的输出格式和特性，以及通过SerializeConfig和ParserConfig进行全局配置。这些扩展点不仅简化了用户代码，也提高了系统的可维护性和可扩展性。
2. 序列化扩展点 2.1. SerializeFilter 用途：用于在序列化过程中定制输出，如过滤某些字段、修改字段值等。使用方法： 实现SerializeFilter接口或其子接口（如SimplePropertyPreFilter、PropertyFilter等）。在序列化时，通过JSON.toJSONString等方法的重载版本传入自定义的SerializeFilter实例。 SerializeFilter filter = new SimplePropertyPreFilter() { @Override public boolean accept(int index, JavaBeanSerializer beanSer, Object object, Object fieldName, Object fieldVal) { // 定制序列化逻辑 return true; // 返回true表示保留该字段，false表示过滤 } }; String jsonStr = JSON.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/699c92201064ece94e2247579c2e9a4a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/131/">«</a>
	<span class="pagination__item pagination__item--current">132/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/133/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>