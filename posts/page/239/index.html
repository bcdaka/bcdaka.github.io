<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d79aff98373a123b39a44fd6bf79f5f6/" rel="bookmark">
			原生鸿蒙AI浓度要爆表了：鸿蒙原生智能加持，华为小艺进化成系统级智能体...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		明敏 白交 发自 凹非寺
量子位 | 公众号 QbitAI “鸿蒙原生智能”Harmony Intelligence来了！
一年一度华为开发者大会上，余承东首次揭秘。
而在Harmony Intelligence革新下，华为小艺也迎来了重大升级——
现在，它不仅仅是AI助手，而是系统级智能体。
基于盘古大模型5.0，目前华为小艺现在已掌握万亿级Tokens知识量、支持23类TOP场景、任务成功率达90%。
只需一句话，它就可以实现跨多个应用的规划和任务执行；而要在第三方APP上想要处理文字图表信息，也通通不在话下。
对屏幕上的内容，小艺应对自如。比如有地址信息的情况，就能直接询问导航到这里的时间/距离，询问附近停车场/地铁站等信息。
现在，HarmonyOS NEXT已启动面向开发者和先锋用户的Beta升级，余承东喊话：
星河璀璨，加入鸿蒙正当时！
而小艺作为HarmonyOS NEXT的一部分，它的这次全面升级也透露出，正式版HarmonyOS NEXT的AI浓度要爆表。
所以，小艺到底完成了哪些能力大升级？
小艺全面升级：系统级智能体 如果说去年留给大家的印象是首个大模型加持的智慧语音助手，那么今年小艺已经成长为一个智能体，系统级别那种。
换言之，就是AI与OS紧密融合，能力升级也将更为彻底，同时也可以直接触达用户侧的需求。
那么基于盘古大模型的升级迭代，小艺能力可以说来了个大升级，在记忆、推理、知识问答等方面的能力大幅提升。
除此之外，还更开放，多达300+的服务通过意图框架接入，这样一来，可以更高效地满足用户需求。
最直观的，就是交互设计——真正意义上操作系统级别的超级入口。
小艺位于手机屏幕底部导航条，长按导航条就可以随时唤醒小艺；此外还新增拖拽方式，支持全局拖拽文字、图片、文档等内容给小艺，随时让小艺为你智能处理信息。
一个具体在办公场景中的例子，比如一则开会通知文本拖拽给小艺，它就能根据通知内容，拉起日历创建行程；再给他一个带表格的图片，他能帮你转成表格文件处理数据……
除此之外，还可以随时根据屏幕内容跟小艺进行问答、发出指令。
手机真就变成了你的一个办公助手，你不需要在多个应用直接反复横跳操作，更加专注的在手上的任务，这样零门槛地就感受到大模型所赋予的能力。
而更深层次的升级，是跨设备跨应用的感知规划，完全是个专业又能干的助手了。
一方面，基于融合系统感知的意图能力以及专业知识解析能力，小艺化身华为产品专家，跨各种设别终端来为用户答疑解惑。目前覆盖华为终端1+8设备产品知识，一整个格局打开。
比如购车前辅助决策，你可以问：问界M7和M5的车型对比；购买之后，也可以提供专业全面的解答。
另一方面在系统内部它能实现跨应用的任务规划与调度，以此来实现更复杂的应用。
要实现这一点，对智能体的挑战并不小。首先它需要有感知和理解能力要精准，不管是对设备、对应用的感知，还是对与用户这边意图、需求的理解，然后再进行多步骤的任务规划、工具调度和执行能力。
而在发布会上，小艺为我们展现了这样一个场景。
要跟小伙伴一起踢足球，只需要跟小艺说，“发条短信给吴双，告诉他后天下午足球赛的比赛地点”。
接下来全部交给小艺，首先它从日程找到相关的时间地点，然后找到联系人，并编辑好一条短信内容进行发送。这个过程中，小艺完成了日历、联系人、短信三个应用的协作。
最后，面对用户更多个性化的场景和需求，小艺还搞了一波大的——
更多生态应用和服务，可以通过意图框架，接入小艺智能体，提供更加自然高效的用户体验。
换言之，它联合开发者以及生态伙伴一起，人多力量大，就不信这样还不够懂你。
比如出行类APP接入意图框架之后，小艺就能帮助规划行程，自动订机票，到出发时实时信息同步，以及之后本地“衣食住行”服务。
以往智能体最多可能只停留在打开APP这一步骤，但现在同生态伙伴合作，小艺能贯穿整个出行场景全流程，「最后一公里」也全部打通。
接下来小艺还将会接入更多行业知识和应用功能，与更多开发者一起打造出行、运动、娱乐、生活、办公等行业智能体，一起为消费者提供各个专业领域的服务，实现精准推荐和服务闭环。
小艺如何做到？ 一系列能力升级背后，关键问题是，小艺如何在短短1年时间内升级成为智能体？
目前，业内已经逐渐达成一个共识：大模型重塑终端，智能体必不可少。
这是因为在实际应用场景中，如果仅依靠大模型自身的智力水平，其能力一定十分有限。比如在知识领域，知识增强方法已经成为一个研究热点，这是让大模型更高效拓展知识水平的方法之一。
除了知识拓展外，智能体构建还需要考虑对物理世界的感知与理解、对复杂任务的拆解与执行等。
具体来看小艺的技术升级路线，其实主要关注了四个方面：
底层模型
智能原生系统深度整合
端云协作
开放生态
首先在模型层面，它依托的盘古大模型在本次HDC上已完成全新升级。
在盘古大模型加持下，小艺在多模态理解生成上变得更强，并能完成复杂逻辑推理。
其次，HarmonyOS本身也更加原生智能化。
在最新发布中，华为宣布通过软硬芯云整合，HarmonyOS NEXT构建了全新鸿蒙原生智能架构。它基于华为自研的全栈硬件与基础设施，构建了端云协同的算力调度系统和推理框架，让AI大模型运行地更加高效，支持更安全的隐私保护。
该架构中，统一的AI系统底座为原生智能应用和小艺智能体持续输入AI能力。
它能在OS层提供统一的AI基础模型、数据接入等，同时为OS其他子系统（如媒体子系统、文件子系统等）提供协调一致的智能化改造。
由此，小艺可以具备四方面能力：
感知和记忆
自主规划
工具
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d79aff98373a123b39a44fd6bf79f5f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/544166ee1da71087b4bae093b8f6b2bb/" rel="bookmark">
			Hadoop 2.0 大家族（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 五、Hive（一）Hive简介（二）Hive入门 六、Oozie（一）Oozie简介（二）Oozie入门 五、Hive Hive是一个构建在Hadoop上的数据仓库框架，它起源于Facebook内部信息处理平台。Hive是一个构建在Hadoop上的数据仓库框架，它起源于Facebook内部信息处理平台。
（一）Hive简介 1、Hive基本框架
Hive包含Shell环境、元数据库、解析器和数据仓库等组件，其体系结构如图所示：
（1）用户接口：包括Hive Shell、Thrift客户端、Web接口。
（2）Thrift服务器：当Hive以服务器模式运行时，作为Thrift服务器，供客户端连接。
（3）元数据库：Hive元数据（如表信息）的集中存放地。
（4）解析器：将Hive语句翻译成MapReduce操作。
（5）Hadoop：底层分布式存储和计算引擎。
2、Hive语法
Hive的SQL称为HiveQL，它与大部分的SQL语法兼容，但是并不完全类似SQL。
（1）数据类型
基本类型：数值型、布尔型和字符串；
复杂类型：ARRAY、MAP和STRUCT。
（2）操作和函数
HiveQL操作符类似于SQL操作符，Hive提供了数理统计、字符串操作、条件操作等大量的内置函数，用户还可以自己编写函数。
（二）Hive入门 1、Hive部署
（1）内嵌模式
此模式是安装时的默认部署模式，此时元数据存储在一个内存数据库Derby中，并且所有组件（如数据库、元数据服务）都运行在同一个进程内。这种模式下，一段时间内只支持一个活动用户。但这种模式配置简单，所需机器较少，限于集群规模，本节Hive部署即采用这种模式。
（2）本地模式
此模式是Hive元数据服务依旧运行在Hive服务主进程中，但元数据存储在独立数据库中（可以是远程机器），当涉及元数据操作时，Hive服务中的元数据服务模块会通过JDBC和存储于DB里的元数据数据库交互。
（3）完全远程模式
元数据服务以独立进程运行，并且元数据存储在一个独立的数据库里。
下面讲解内嵌模式部署。
① 下载并安装Hive。
[root@iClient ~]# sudo yum install hive ② HDFS里新建Hive存储目录。
[root@iClient ~]# sudo –u hdfs hdfs dfs –mkdir /user/hive #HDFS里新建Hive存储目录 [root@iClient ~]# sudo –u hdfs hdfs dfs –chmod –R 1777 /user/hive #为目录设置适当权限 只需上述两步就可以直接使用Hive了，当然，也可以使用jps命令查看Hive进程。
2、Hive接口
Hive提供了强大的访问接口，从下图中即可看出Hive提供的诸多接口，此外也可以通过Hcatalog、Pig、BeeLine等访问Hive。
【例4】 按要求完成问题：
① 进入Hive命令行接口，获取Hive函数列表并单独查询count函数用法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/544166ee1da71087b4bae093b8f6b2bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4f95a6e9bdfcc5a43afbd83d482985f/" rel="bookmark">
			Stable Diffusion部署教程，开启你的AI绘图之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文环境 系统：Ubuntu 20.04 64位
内存：32G
环境安装 2.1 安装GPU驱动 在英伟达官网根据显卡型号、操作系统、CUDA等查询驱动版本。官网查询链接https://www.nvidia.com/Download/index.aspx?lang=en-us
注意这里的CUDA版本，如未安装CUDA可以先选择一个版本，稍后再安装CUDA.
点击Search
如上图，查询到合适的版本为510. 然后可以使用apt安装对应驱动版本，使用apt安装更方便一些。
# 安装510版本驱动 sudo apt install nvidia-driver-510 # 查看驱动信息 nvidia-smi 当然你也可以使用官网下载的run文件进行安装
sudo chmod +x NVIDIA-Linux-x86_64-510.108.03.run 安装
sudo ./NVIDIA-Linux-x86_64-510.108.03.run 安装步骤操作之后就可以完成安装了
输入nvidia-smi查看显卡
chen@chen:~$ nvidia-smi Sat Jun 22 08:50:27 2024 +-----------------------------------------------------------------------------+ | NVIDIA-SMI 510.39.01 Driver Version: 510.39.01 CUDA Version: 11.6 | |-------------------------------+----------------------+----------------------+ | GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4f95a6e9bdfcc5a43afbd83d482985f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea988d0610b11e941728fe983ccfd877/" rel="bookmark">
			仓颉编程语言入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为在 2024 年 6 月 21 日的华为开发者大会上，华为终端 BG 软件部总裁龚体正式官宣了华为自研仓颉编程语言，并发布了 HarmonyOS NEXT 仓颉语言开发者预览版。
仓颉编程语言文件后缀名为 .cj, 以下是第一个入门代码输出：你好，仓颉。
仓颉编程语言的名字来自 “仓颉造字”。
仓颉（约公元前2650年）是中国古代传说中的人物，据说是黄帝的史官，他被认为是汉字的创造者。
仓颉造字是中国古代传说中的一个重要故事，讲述的是仓颉创造汉字的过程。
《荀子・解蔽》称：“好书者众矣，而仓颉独传者壹也”，该名字也是代表了团队成员对于仓颉编程语言的寄托，希望该语言能够被广大开发者喜爱，并且广为流传。
这是华为首次公开发布仓颉编程语言。
龚体表示：“2019 年，仓颉编程语言项目在华为诞生，历经 5 年研发沉淀，大量研发投入，今日终于和全球开发者见面。仓颉编程语言通过现代语言特性的集成、全方位的编译优化和运行时实现、以及开箱即用的 IDE 工具链支持，为开发者打造友好开发体验和卓越程序性能。”
仓颉编程语言是一款面向全场景智能的新一代编程语言，主打原生智能化、天生全场景、高性能、强安全。
仓颉编程语言以其 “原生智能化、天生全场景、高性能、强安全”的特点，重新定义了智能编程的新标准。内嵌AgentDSL的编程框架，实现了自然语言与编程语言的有机融合，为智能应用开发提供了无限可能。
仓颉编程语言的发布，标志着其正式融入鸿蒙生态，为开发者提供了一个全新的编程平台。在这里，开发者可以享受到更加友好的开发体验和卓越的程序性能，共同推动鸿蒙生态的繁荣发展。
一、基本概念 1.1 标识符 1.2 变量 变量将一个名字和一个特定类型的值关联起来。
变量估算圆周率
1.3 类型 类型就像一份协议，规定了一块数据的组织结构及相应的解析/操作方式。
1.4 基础数据类型 1.5 表达式 1.5.1 if 表达式 1.5.2 while 表达式 1.5.3 for-in表达式 1.6 程序结构 二、函数 2.1 定义函数 2.2 调用函数 2.3 lambda 表达式 lambda表达式可以让函数的创建和使用更加灵活，lambda表达式的值就是一个匿名函数。
应用实例遍历目录
三、枚举 3.1 定义与实例化 3.2 成员访问规则 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea988d0610b11e941728fe983ccfd877/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c0ae3f226d517f1a0db668e52cbf203/" rel="bookmark">
			【数据结构】线性表之《带头双向循环链表》超详细实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双向循环链表 一.带头双向循环链表与无头单向非循环链表的区别二.顺序表和双向链表的优缺点分析三.带头双向循环链表实现1.创建双链表2.初始化双链表3.购买节点4.打印双链表5.插入操作1.头插2.尾插3.给定位置之前插入 6.删除操作1.头删2.尾删3.删除给定位置的结点 7.查找数据8.修改数据9.求双链表长度10.清空双链表11.销毁双链表 四.模块化源代码1.DoubleLinkList.h2.DoubleLinkList.c3.test.c 五.链表必做OJ题 前言：虽然笔试常考无头单链表，但是实际上存储数据时，常用带头双向循环链表。这带头双向循环链表相比于无头单链表，不仅在存储数据时更为高效，而且在插入、删除等操作中也表现出更优的性能。
一.带头双向循环链表与无头单向非循环链表的区别 无头单向非循环链表（简称：单链表）：
结构简单，一般不会单独用来存数据。实际中更多是作为其他数据结构的子结构，如哈希桶、图的邻接表等等。另外这种结构在笔试面试中出现很多。尾删，插入与删除，由于需要从头开始找前一个节点，时间复杂度为O(N)，效率较低。 带头双向循环链表（简称：双向链表）：
结构最复杂，一般用在单独存储数据。实际中使用的链表数据结构，都是带头双向循环链表。另外这个结构虽然结构复杂，但是使用代码实现以后会发现结构会带来很多优势，实现反而简单了，后面我们代码实现了就知道了。带头节点，不需要改变传过来的指针，也就意味着不需要传二级指针。带哨兵位的头节点不存储有效数据。若存储链表的长度，当节点中的数据类型是char时，最大只能为255这是不合理的。查找数据时，时间复杂度为O(N)，一般不用这个，而用平衡搜索树（AVL树，红黑树），哈希表，B树，B+树系列，跳表，布隆过滤器，位图。 二.顺序表和双向链表的优缺点分析 三.带头双向循环链表实现 1.创建双链表 双链表由节点组成，每个节点要存放数据，上一个节点的地址与下一个节点的地址。
双链表：指向该节点的指针。
typedef int LTDataType; //增强程序的可维护性 typedef struct ListNode { LTDataType data; //数据域 struct ListNode* next; //前驱指针 struct ListNode* prev; //后继指针 }ListNode; ListNode* plist;//双链表 2.初始化双链表 将双链表初始化为带哨兵位的头节点，并实现循环结构。
ListNode* ListInit() { //创建头节点 ListNode* phead = BuyNode(0); //实现循环结构 phead-&gt;next = phead; phead-&gt;prev = phead; return phead;//返回节点指针 } 3.购买节点 由于头插，尾插，按位置插入链表，都要先准备一个节点。为了减少代码的重复，直接对其进行封装，创建新节点的时候直接调用该接口就行。
ListNode* BuyNode(LTDataType x) { //开辟节点空间 ListNode* newnode = (ListNode*)malloc(sizeof(ListNode)); //开辟失败 if (newnode == NULL) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c0ae3f226d517f1a0db668e52cbf203/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3720c2393aa42efc5759437bbf817c4/" rel="bookmark">
			论文阅读03（基于人类偏好微调语言模型）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.主题 基于人类偏好微调语言模型（Fine-Tuning Language Models from Human Preferences）
出处： Fine-Tuning Language Models from Human Preferences、
2.摘要 奖励学习使得强化学习（RL）可以应用于那些通过人类判断来定义奖励【1. 关键词是什么】 的任务，通过向人类提问来建立奖励模型。大多数关于奖励学习的研究使用了模拟环境，但复杂的价值信息通常以自然语言表达【2. 对比】，我们认为将奖励学习应用于语言是使RL在实际任务中实用且安全的关键。在本文中，我们基于生成预训练语言模型的进展，将奖励学习应用于四个自然语言任务：继续生成正面情感文本或物理描述性语言，以及TL;DR和CNN/Daily Mail数据集上的摘要任务【3. 任务】。对于风格化续写任务，我们仅通过5000次人类比较就取得了良好结果。对于摘要任务，通过60,000次人类比较训练的模型能够复制整句话但跳过不相关的前言；这导致合理的ROUGE分数和人类标签者的优异表现，但可能利用了标签者依赖简单启发式的事实 【4. 实验结果】。
1. 奖励学习： 通过人类的反馈来定义奖励，从而指导强化学习（RL）。
2. 模拟环境： 之前的研究主要在虚拟环境中进行，但这些环境往往过于简单，无法反映现实世界的复杂性。【比如选择最短的路径通关游戏，相比于自然语言，复杂度相差甚远】
4. 主要任务： 奖励模型使得强化学习在处理任务更有效【指的是自然语言那类任务】
5. 实验结果：
风格化续写：仅通过5000次人类比较就取得了良好结果，这表明人类反馈在指导模型生成方面非常有效。摘要任务：通过60,000次人类比较训练的模型能够生成合理的摘要，尽管这种方法可能依赖了人类标签者使用简单启发式的事实。 3.引言 我们希望将强化学习应用于那些仅通过人类判断来定义的复杂任务，在这些任务中，只有通过询问人类才能判断结果的好坏【1. 目的】。为此，我们可以首先使用人类标签来训练一个奖励模型，然后优化该模型。尽管有大量通过与人类互动来学习此类模型的研究，但这些研究直到最近才被应用于现代深度学习，并且即便如此，也仅应用于相对简单的模拟环境（Christiano等，2017；Ibarz等，2018；Bahdanau等，2018）。相比之下，在现实世界中，人类需要向AI代理指定复杂目标，这可能涉及并需要自然语言，这是表达价值观念的丰富媒介。当代理必须与人类进行交流以提供更准确的监督信号时，自然语言尤为重要（Irving等，2018；Christiano等，2018；Leike等，2018）。
自然语言处理最近取得了显著进展。一种成功的方法是先在无监督数据集上预训练一个大型生成语言模型，然后对该模型进行监督任务的微调【2.做法与对比】（Dai和Le，2015；Peters等，2018；Radford等，2018；Khandelwal等，2019）。这种方法通常显著优于从头开始训练监督数据集，并且一个单一的预训练语言模型通常可以通过微调在许多不同的监督数据集上达到最先进的性能【3. 做法的优势】（Howard和Ruder，2018）。在某些情况下，不需要微调：Radford等（2019）发现，经过生成训练的模型在无需额外训练的情况下（零样本）在NLP任务上表现良好。
将强化学习应用于自然语言任务有着悠久的历史。许多这方面的工作使用算法定义的奖励函数，例如翻译的BLEU（Ranzato等，2015；Wu等，2016）、摘要的ROUGE（Ranzato等，2015；Paulus等，2017；Wu和Hu，2018；Gao等，2019b）、基于音乐理论的奖励（Jaques等，2017）或故事生成的事件检测器（Tambwekar等，2018）。Nguyen等（2017）在BLEU上使用了RL，但应用了几个错误模型来模拟人类行为。Wu和Hu（2018）和Cho等（2019）从现有文本中学习连贯性模型，并将其用作摘要和长文生成的RL奖励。Gao等（2019a）通过将奖励学习应用于一篇文章一次构建了一个交互式摘要工具。使用人类评价作为奖励的实验包括Kreutzer等（2018），他们使用离线策略奖励学习进行翻译，以及Jaques等（2019），他们将Jaques等（2017）的修改版Q学习方法应用于对话中的隐式人类偏好。Yi等（2019）从人类那里学习奖励以微调对话模型，但对奖励进行了平滑处理以允许监督学习。我们参考Luketina等（2019）对涉及语言作为组件的RL任务和使用迁移学习进行RL结果的调查。
在本文中，我们结合了自然语言处理中的预训练进展和人类偏好学习。我们使用从人类偏好中训练的奖励模型，通过强化学习而不是监督学习来微调预训练的语言模型。根据Jaques等（2017；2019）的研究，我们使用KL约束来防止微调模型偏离预训练模型。我们将我们的方法应用于两类任务：以匹配目标风格（如正面情感或生动描述性语言）的方式继续文本，以及对CNN/Daily Mail或TL;DR数据集（Hermann等，2015；Völske等，2017）中的文本进行摘要。我们的动机是处理那些没有或不足的监督数据集的NLP任务，以及那些程序化奖励函数是我们真实目标的糟糕代理的任务。
对于风格化续写任务，我们使用5,000个人类比较（每次选择4个续写中的最佳一个）进行微调，使得微调后的模型在86%的情况下被人类更喜欢，而对比零样本学习为77%，对比监督学习的情感网络为77%【体现出无监督预训练+微调的效果更好】。对于摘要任务，我们使用60,000个人类样本来训练模型，这些模型可以大致描述为“智能复制器”：它们通常从输入中复制整句话，但会跳过不相关的开头。这种复制行为自然地从数据收集和训练过程中出现；我们没有使用任何显式的复制机制（如See等，2017；Gehrmann等，2018）。一种解释是，复制是一种容易准确的方式，因为我们没有指示标签者惩罚复制，而是指示他们惩罚不准确。它还可能反映了一些标签者检查复制作为快速确保摘要准确性的一种启发式方法。确实，人类标签者显著更喜欢我们的模型而不是监督微调的基线，甚至比人类编写的参考摘要还要喜欢，但不如复制前三句话的基线 【好处：这种行为（跳过不相干部分）并不是通过显式的复制机制实现的，而是在数据收集和训练过程中自然出现的】。
对于摘要任务，我们继续收集额外数据，并在策略改进时重新训练我们的奖励模型（在线数据收集）。我们还测试了离线数据收集，使用原始语言模型的数据来训练奖励模型；离线数据收集显著降低了训练过程的复杂性。对于TL;DR数据集，人类标签者71%的时间更喜欢在线数据收集训练的策略，而在定性评估中，离线模型通常提供不准确的摘要。相比之下，对于风格化续写任务，我们发现离线数据收集效果同样好。这可能与风格任务所需的数据非常少有关；Radford等（2017）显示，生成训练的模型可以从很少的标签样本中学习分类情感。
在并行工作中，Böhm等（2019）也使用人类评估来学习摘要的奖励函数，并使用RL优化该奖励函数。他们的工作更详细地调查了CNN/Daily
Mail数据集上学习的策略和奖励函数，而我们更广泛地探索了从人类反馈中学习，并在更大的计算规模上进行探索。因此，我们考虑了几个额外的任务，探索了在线奖励模型训练和更多数据的效果，并对大规模语言模型进行了奖励建模和RL微调。
1. 奖励模型增强强化学习对任务处理的过程：
奖励模型训练
1.Context（上下文）： 从上下文开始，这里指输入的一段文字或语境。
2. Policy（策略）：基于上下文生成多个（例如四个）可能的续写（continuation）。
3. Human Labeler（人类标签者）： 这些生成的续写被送给人类标签者，人类根据自己的判断对这些续写进行评分或选择最好的续写。
4. Reward Model（奖励模型）： 人类标签者的选择结果被用于训练奖励模型。奖励模型根据人类的反馈生成对应的奖励信号。
5. Loss（损失）： 奖励模型根据生成的奖励信号计算损失，并通过优化过程不断改进自身。
策略训练
1. Context（上下文）： 同样从上下文开始。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3720c2393aa42efc5759437bbf817c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31040ceb1bc8d747fa8b2d3dc6905627/" rel="bookmark">
			空间域和频域的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		空间域和频域的理解 在信号处理、图像处理和其他工程领域，信号和数据可以在不同的域中表示和处理。两种常见的表示方式是空间域和频域。它们提供了不同的视角和工具来分析和处理数据。
空间域（Spatial Domain） 定义：
空间域表示信号或图像在其原始形式中的域。例如，对于图像处理，空间域中的数据是像素值的直接表示。 理解：
在空间域中，我们处理信号或图像的每个数据点。例如，在图像处理中，我们直接操作图像的像素值，如调整亮度、对比度、应用滤波器等。 操作：
常见的空间域操作包括卷积、加法、乘法等。例如，应用一个空间域滤波器（如模糊或锐化）涉及将滤波器核与图像像素值进行卷积。 示例：
对于一幅灰度图像，其空间域表示就是每个像素的亮度值组成的二维矩阵。直接调整图像的亮度或对比度，是空间域操作。 频域（Frequency Domain） 定义：
频域表示信号或图像在频率成分中的域。信号或图像可以通过傅里叶变换从空间域转换到频域。 理解：
在频域中，信号或图像被表示为不同频率成分的组合。频域分析帮助我们理解信号的周期性特征和高频或低频成分。对于图像，高频分量对应于图像中的快速变化（如边缘和细节），低频分量对应于图像中的缓慢变化（如大面积的平滑区域）。 操作：
常见的频域操作包括滤波（如低通滤波器、带通滤波器和高通滤波器）和信号分析。应用频域滤波器通常涉及将信号转换到频域、应用滤波器，然后将结果转换回空间域。 示例：
使用快速傅里叶变换（FFT）将图像从空间域转换到频域。通过在频域中应用低通滤波器去除图像中的高频噪声，然后将图像转换回空间域。 空间域和频域的关系 转换工具：傅里叶变换是将信号从空间域转换到频域的常用工具。逆傅里叶变换可以将信号从频域转换回空间域。互补性：空间域和频域提供了互补的信息。在空间域中容易理解和处理的操作，在频域中可能更加复杂，反之亦然。频域分析有助于理解信号的频率特性，而空间域操作直接应用于信号或图像的每个数据点。 应用实例 图像处理：
空间域：直接应用图像滤波器，如模糊滤波器（平均滤波）、边缘检测（Sobel滤波）等。频域：通过傅里叶变换，将图像转换到频域，应用频域滤波器（如低通滤波器），然后逆傅里叶变换回空间域。 音频处理：
空间域：直接处理音频信号的样本值，如音量调整、混音等。频域：通过傅里叶变换分析音频信号的频谱，应用频域滤波器去除噪声或增强特定频段，然后逆变换回时间域。 总结 空间域：信号或图像的直接表示，每个数据点的值表示特定的物理量（如像素值）。频域：信号或图像的频率成分表示，帮助分析和处理信号的周期性特征和频率成分。 理解空间域和频域的关系和操作，有助于在信号处理和图像处理中选择合适的工具和方法来实现特定的目标。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7e0c23549179064c75b750781d4815e/" rel="bookmark">
			若以框架学习（3），echarts结合后端数据展示，暂时完结。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前三天，参加毕业典礼，领毕业证，顿时感到空落落的失去感，没有工作，啥也没有，总感觉一辈子白活了。晚上ktv了一晚上，由于我不咋个唱歌，没心情，听哥几个唱了一晚上周杰伦，回来的时候，还下大雨，躺在床上满满的失败感。
导入echartss
npm install echarts
然后在main.js中配置
import * as echarts from 'echarts'; //导入echats Vue.prototype.$echarts = echarts; 对了，不要一味粘贴复制，因为我用的ruoyi框架的apis发送的请求，不是axios哦，还有我data中的参数，很多都是没用过的，是我中间思考，测试中没用的变量。
自己的界面先用一个案例
&lt;template&gt; &lt;div id="app"&gt; &lt;div id="myChart" :style="{width: '800px', height: '600px'}"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import * as echarts from "echarts"; import {listCar} from "@/api/shopcar/car"; import {listSchool, qryName} from "@/api/shool/school"; export default { data() { return { // 遮罩层 loading: true, // 选中数组 ids: [], // 非单个禁用 single: true, // 非多个禁用 multiple: true, // 显示搜索条件 showSearch: true, // 总条数 total: 0, // 【请填写功能名称】表格数据 carList: [], //测试数组 demoList:[], // 弹出层标题 title: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7e0c23549179064c75b750781d4815e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35ca6fc2c895b40276f7957bd5c2e235/" rel="bookmark">
			2024最新版Node.js下载安装及环境配置教程（非常详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、进入官网地址下载安装包 官网：Node.js — Run JavaScript Everywhere 其他版本下载：Node.js — Download Node.js® (nodejs.org)
选择对应你系统的Node.js版本
二、安装程序 （1）下载完成后，双击安装包，开始安装Node.js
(2)直接点【Next】按钮，此处可根据个人需求修改安装路径，我这里路径改为了D:\Program Files\nodejs\，修改完毕后继续点击【Next】按钮
（3）可根据自身需求进行，此处我选择默认安装，继续点击【Next】按钮
（4）不选中，直接点击【Next】按钮
（5）点击【Install】按钮进行安装
（6）安装完毕，点击【Finish】按钮
（7）测试安装是否成功，按下【win+R】键，输入cmd，打开cmd窗口 ，输入：
node -v // 显示node.js版本 npm -v // 显示npm版本 成功显示版本说明安装成功 三、环境配置 （1）找到安装的目录 D:\Program Files\nodejs，在安装目录下新建两个文件夹【node_global】和【node_cache】
（2）创建完毕后，使用管理员身份打开cmd命令窗口，这里以win11打开cmd为例，搜索框搜索cmd
（3）命令窗口输入以下命令
①npm config set prefix “你的路径\node_global” （复制你刚刚创建的“node_global”文件夹路径）
npm config set prefix "D:\Program Files\nodejs\node_global" ②npm config set cache “你的路径\node_cache” （复制你刚刚创建的“node_cache”文件夹路径）
npm config set cache "D:\Program Files\nodejs\node_cache" （4）配置环境变量
①【此电脑】-单击右键-【属性】-【高级系统设置】-【环境变量】
② 在【系统变量】中点击【新建】
变量名：NODE_PATH
变量值：D:\Program Files\nodejs\node_global\node_modules
然后你就会发现【node_global】里多出了一个【node_modules】文件夹
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35ca6fc2c895b40276f7957bd5c2e235/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0c5ded5d01bba909e2b40e9002df2ed/" rel="bookmark">
			MySQL5.7在Windows环境下安装出现初始化数据库（lnitializing database）失败，并无法启动服务的最终解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前段时间在服务器上安装一个MySQL数据库，结果在安装界面就显示初始化数据库错误
点击Execute之后，MySQL服务也无法启动，在服务界面里显示本地计算机上的本地计算机上的Mysql57服务启动后停止，某些服务在未由其他服务或程序使用时将自动停止。
通过查看log，我们会发现，是my.ini文件的mysqlx_port=0.0这个参数出现了问题
根据查阅资料，我们发现，这个参数是为MySQL8配置的，但是我们的MySQL5.7却无法识别这个参数，所以会导致报错。
知道原因了我们也就知道如何解决了，使用VScode编辑my.ini文件，这个文件的路径通常是在C:\ProgramData\MySQL\MySQL Server 5.7底下。
注意！请不要用记事本打开编辑保存，否则MySQL会无法正确读取本文件！！！
将这段注释掉后，将C:\ProgramData\MySQL\MySQL Server 5.7\Data这个文件夹删除，打开命令行，输入
"C:\Program Files\MySQL\MySQL Server 5.7\bin\mysqld.exe" --defaults-file="C:\ProgramData\MySQL\MySQL Server 5.7\my.ini" --console --initialize-insecure=on --lower-case-table-names=1 如果控制台显示这个，则说明已经成功了。再次启动MySQL服务则会发现启动成功。
但是有些朋友可能就要讲了，这样配置一是并非完全通过官方安装程序进行配置，有些人有强迫症，而且如果下次再次通过官方程序安装或者修改配置时，安装程序会覆盖一个默认的my.ini文件，这样就会又报错。二是这样创建的MySQL的root的密码是空，会有安全隐患。那么该如何彻底解决这个问题呢？
进入C:\ProgramData\MySQL\MySQL Installer for Windows\Manifest\Templates这个路径，将里面的my-template-5.7.ini文件里的mysqlx_port=0.0给注释掉（不要用记事本编辑！！！）。这样就完美解决问题了！
总结，这就是MySQL安装程序的锅，不知道Oracle的程序员是怎么想的。。。
而且2024年了，怎么还有单位用MySQL5.7啊！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/478535c2d325516438fd66b8e8ea577f/" rel="bookmark">
			git-worktree详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作用 git-worktree - Manage multiple working trees
语法 git worktree add [-f] [--detach] [--checkout] [--lock [--reason &lt;string&gt;]] [--orphan] [(-b | -B) &lt;new-branch&gt;] &lt;path&gt; [&lt;commit-ish&gt;] git worktree list [-v | --porcelain [-z]] git worktree lock [--reason &lt;string&gt;] &lt;worktree&gt; git worktree move &lt;worktree&gt; &lt;new-path&gt; git worktree prune [-n] [-v] [--expire &lt;expire&gt;] git worktree remove [-f] &lt;worktree&gt; git worktree repair [&lt;path&gt;…​] git worktree unlock &lt;worktree&gt; 功能描述 Manage multiple working trees attached to the same repository.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/478535c2d325516438fd66b8e8ea577f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c185702f5bf23c974a88dbb26f1421d7/" rel="bookmark">
			Windows C&#43;&#43; 应用软件开发从入门到精通详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、引言
2、IDE 开发环境介绍
2.1、Visual Studio 2.2、Qt Creator 3、 C++语言特性
3.1、熟悉泛型编程
3.2、了解C/C++异常处理
3.3、熟练使用STL容器
3.4、熟悉C++11新特性
4、Windows 平台的编程技术与调试技能
4.1、需要掌握的若干编程技术和基础知识
4.2、需要掌握的软件调试技能
5、开发 Windows 应用软件需要具备的其他技能
6、客户端 UI 编程技术
6.1、MFC 库
6.2、duilib 库
6.3、QT 库
6.4、Chromium 开源浏览器的 UI 库
6.5、Electron 界面框架
7、项目中常用的 C/C++ 开源库介绍
8、Windows 平台实用小工具介绍
8.1、代码编辑器 VSCode
8.2、代码查看编辑器 Source Insight
8.3、文本编辑器 Notepad++
8.4、文件搜索工具 Everything
9、最后
C++软件异常排查从入门到精通系列教程（专栏文章列表，欢迎订阅，持续更新...）https://blog.csdn.net/chenlycly/article/details/125529931C/C++基础与进阶（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/category_11931267.htmlVC++常用功能开发汇总（专栏文章列表，欢迎订阅，持续更新...）https://blog.csdn.net/chenlycly/article/details/124272585Windows C++ 软件开发从入门到精通（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/category_12695902.htmlC++软件分析工具从入门到精通案例集锦（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/article/details/131405795开源组件及数据库技术（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/category_12458859.html网络编程与网络问题分享（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/category_2276111.html Windows下用C++开发软件，主要包含两大类，一类是工具软件与客户端软件的开发，一类是服务器程序的开发（运行在Windows Server服务器上）。我们日常工作学习使用的都是Windows桌面系统，会频繁地使用到各式各样的工具与客户端软件。本文详细介绍一下Windows平台下用C++开发应用软件的诸多内容，以供大家借鉴或参考。
1、引言 在Windows系统中，大多数客户端软件都是用C++开发的，当然也有少部分软件是用C#等语言实现的。我们日常使用的Windows桌面版的QQ、微信、腾讯会议、企业微信、字节飞书、阿里钉钉、百度网盘、迅雷、Chrome浏览器、Foxmail邮箱、远程软件向日葵/ToDesk等客户端软件，都是用C++开发实现的，C++是当前Windows平台开发应用软件的主流开发语言。本文详细介绍一下Windows平台下用C++开发客户端软件的相关内容。
2、IDE 开发环境介绍 Windows中常用的C/C++ IDE开发工具主要有微软的Visual Studio和QT公司的QT Creator。当然也可以使用微软的VSCode、JetBrains公司的CLion，甚至使用代码编辑查看工具Source Insight（只能查看编辑，不能编译）去开发代码。这里我们重点介绍一下Visual Studio和QT Creator这两个IDE。
2.1、Visual Studio 微软的Visual Studio是Windows平台上最强大的IDE软件开发工具，支持开发C/C++、C#、F#、JavaScript、Python、TypeScript、Visual Basic、.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c185702f5bf23c974a88dbb26f1421d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c57f3eea3cde25213f577b0117eef3a/" rel="bookmark">
			AI与音乐：共创未来乐章还是终结艺术的颂歌？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引言
AI在音乐创作中的创新应用
1. 数据分析与智能作曲
示例代码：使用Magenta库生成音乐
2. 实时创作与交互
3. 辅助创作与灵感激发
AI对音乐艺术的潜在威胁
1. 标准化与同质化
2. 版权与伦理问题
3. 替代人类音乐家
平衡与共存
1. 个性化与定制化的音乐体验
2. 跨领域融合与创新
3. 教育与普及的推进
4. 社会与文化的反思
5. 伦理与法律的完善
结论
引言 在数字化和人工智能（AI）技术日新月异的今天，音乐创作领域也迎来了前所未有的变革。AI技术的引入，让音乐创作变得更为高效、多样，但同时也引发了一系列关于音乐本质、创作权属以及艺术价值的讨论。本文将深入探讨AI在音乐创作和毁灭两方面的作用，分析其对音乐产业和音乐艺术的潜在影响，并尝试提出一个平衡的观点。
AI在音乐创作中的创新应用 1. 数据分析与智能作曲 AI通过深度学习和机器学习技术，能够分析海量的音乐数据，识别出音乐中的模式、结构和风格。这种能力使得AI能够模拟不同音乐家的创作风格，甚至创造出全新的音乐形式。例如，Google的Magenta项目就是一个利用AI技术进行音乐创作的平台，它可以根据用户输入的旋律、节奏和风格参数，生成符合要求的音乐作品。
示例代码：使用Magenta库生成音乐 # 假设已经安装了Magenta库 from magenta.models.melody_rnn import melody_rnn_generate from magenta.models.melody_rnn import melody_rnn_model from magenta.music import sequences_lib from magenta.protobuf import generator_pb2 # 加载预训练的Melody RNN模型 bundle = melody_rnn_model.get_configuration('basic_rnn') bundle.initialize() # 设定生成音乐的参数 num_bars = 4 # 生成的乐句数 prime_melody = [[60, -1, 0, 0, 0, 0, 0]] # 初始音符（例如C4） temperature = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c57f3eea3cde25213f577b0117eef3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/341bb97390186b84947946b2b0802a30/" rel="bookmark">
			DVWA 靶场 JavaScript 通关解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 DVWA代表Damn Vulnerable Web Application，是一个用于学习和练习Web应用程序漏洞的开源漏洞应用程序。它被设计成一个易于安装和配置的漏洞应用程序，旨在帮助安全专业人员和爱好者了解和熟悉不同类型的Web应用程序漏洞。
DVWA提供了一系列的漏洞场景和练习环境，用户可以通过攻击这些漏洞场景来学习和实践漏洞利用技术。这些漏洞包括常见的安全问题，如SQL注入、跨站脚本攻击（XSS）、文件包含漏洞等。通过攻击这些漏洞，用户可以了解漏洞的原理、影响和防御方法。
DVWA提供了不同的安全级别，从低到高，以满足不同技能水平的用户需求。用户可以根据自己的能力选择适当的安全级别，并进行相应的练习和挑战。
DVWA还提供了一些额外的功能和工具，如Web代理、密码破解、弱密码检测等，以帮助用户更好地理解和处理漏洞问题。
总之，DVWA是一个用于学习和练习Web应用程序漏洞的开源应用程序。它提供了一系列的漏洞场景和练习环境，帮助安全专业人员和爱好者提高对Web应用程序安全的理解和实践能力。通过使用DVWA，用户可以加深对Web应用程序漏洞的认识，并学习如何有效地保护Web应用程序免受攻击。
介绍 JavaScript 攻击是一类通过利用 JavaScript 代码执行漏洞或滥用其特性来进行的网络攻击。这些攻击可以用来窃取敏感信息、劫持用户会话、执行恶意操作等。以下是几种常见的 JavaScript 攻击及其防御方法的详细介绍：
一、跨站脚本攻击 (Cross-Site Scripting, XSS)
1. 存储型 XSS（Stored XSS）
攻击者将恶意 JavaScript 代码存储在目标网站的数据库中。当其他用户访问包含这些恶意代码的页面时，代码会在用户的浏览器中执行，从而窃取用户信息或执行其他恶意操作。
2. 反射型 XSS（Reflected XSS）
恶意 JavaScript 代码通过 URL 参数传递给服务器，服务器在响应中包含这些代码并发送给用户。当用户点击恶意链接时，代码在用户的浏览器中执行。
3. 基于 DOM 的 XSS（DOM-based XSS）
恶意 JavaScript 代码直接修改网页的 DOM 结构，不通过服务器端处理。通常通过修改 URL 或其他客户端输入来实现。
防御措施：
输入验证和输出编码：对用户输入进行严格验证，并在输出到 HTML、JavaScript、CSS 或 URL 时进行正确的编码。内容安全策略 (Content Security Policy, CSP)：使用 CSP 限制浏览器加载和执行的内容，防止执行未授权的脚本。安全框架和库：使用安全的框架和库，自动处理编码和验证（如 Angular、React 等）。 二、跨站请求伪造 (Cross-Site Request Forgery, CSRF)
攻击者诱使受害者在已认证的情况下执行非预期的操作，例如提交表单、发送请求等，从而执行未经授权的操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/341bb97390186b84947946b2b0802a30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/938032afc0c124142facae73c19480c2/" rel="bookmark">
			力扣随机一题 模拟&#43;字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博客主页：誓则盟约系列专栏：IT竞赛 专栏关注博主，后期持续更新系列文章如果有错误感谢请大家批评指出，及时修改感谢大家点赞👍收藏⭐评论✍ 1910.删除一个字符串中所有出现的给定子字符串【中等】 题目： 给你两个字符串 s 和 part ，请你对 s 反复执行以下操作直到 所有 子字符串 part 都被删除：
找到 s 中 最左边 的子字符串 part ，并将它从 s 中删除。 请你返回从 s 中删除所有 part 子字符串以后得到的剩余字符串。
一个 子字符串 是一个字符串中连续的字符序列。
示例 1：
输入：s = "daabcbaabcbc", part = "abc" 输出："dab" 解释：以下操作按顺序执行： - s = "daabcbaabcbc" ，删除下标从 2 开始的 "abc" ，得到 s = "dabaabcbc" 。 - s = "dabaabcbc" ，删除下标从 4 开始的 "abc" ，得到 s = "dababc" 。 - s = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/938032afc0c124142facae73c19480c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/801b2b37bbb325c195244c79acb2f3a7/" rel="bookmark">
			前端路线指导（4）：前端春招秋招经验分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		春招/秋招经验分享(前端)
哈喽大家好，我是小粉，双一流本科，自学前端一年，收获腾讯，字节等多家大厂offer，一半以上ssp~
今天给大家分享一下我的春招（暑期实习）、秋招经历，希望能给大家一些帮助！
本文主要为分为两个部分：
1. 个人经历
2. 做好哪些准备才能够在春招 / 秋招中脱颖而出
我的经历
我从大二下学期结束开始学习前端，自学了两个多月的时间之后，决定找个实习工作，于是海投了一些公司，最终收获了一些中小厂offer，于是去到了其中一家公司实习。
实习期间我一直兢兢业业做需求，切切图写写逻辑，没有去主动挑战 / 挖掘一些难点，一直实习了好几个月的时间。
在暑期实习之前，我意识到自己可能简历上的内容并不丰富，实习期间也没有主动学习一些其他的技术，这么短的时间我前端技术并不扎实，甚至很多技术栈压根不会，于是我选择辞职，沉淀一下自己~
在23年1月份开始我就开始学习node、webpack，了解一点react的原理源码，同时刷手写题和算法题，并且绞尽脑汁去挖掘自己的实习难点，以备暑期实习的面试。
在暑期实习（3-4月）期间，我最早一批开始投递，即便我没准备好哈哈，由于我简历写的还算可以，很快就收到了不少面试，但是面试过程中发现自己很多基础还是不太扎实，边面试边补八股，深入学习八股，最终很开心收获了几家大厂的暑期实习offer！
当时还发现一个问题：早投递可能面试难度会比较大，后来（4-5月）投递的同学面试通常会更简单一些，但是也可能有些公司就没有面试机会了，有好有坏，大家可以根据自己的情况去选择投递时间。
后来复盘我的暑期实习面试，总结出了自己的劣势：
——项目经历过于简单
于是在暑期实习期间，我晚上努力去做一个自己有深度，又新颖的前端项目，同时我意识到实习过程中需要去挑战一些难点，于是我刻意关注了这一部分，尽可能把日常需求中一些可以抽象的内容抽象出来，就这样我一直坚持到了7月底。
在七月底八月初的时候我就开始投递秋招（也是最早的一批），开始了边秋招边实习的过程，最终也是很顺利地通过了转正答辩，秋招也很顺利，在九月初到中旬的时间我就基本结束了秋招，开始躺平生活！
后来发现秋招投递晚的同学，基本没什么机会啦，需要一直等到11月、12月谈薪，鸽子不断出现的时候，大厂才会开始补录！所以大家投递时间一定要注意，秋招一定要尽早投递，争取第一批投递！
做好哪些准备才能在春招 / 秋招 脱颖而出
1. 优秀的简历
什么样才算优秀的简历？我认为大家需要站在面试官的角度去评审自己的简历，比如个人介绍，说自己多努力，多热爱技术，每个人都这么说，面试官怎么相信？是不是相当于没有意义的介绍，还占用自己简历的空间。项目 / 实习描述要足够深刻，突出一些重难点，要让面试官能够一看就知道想问你一些什么，而不要流水账地描述自己的工作~
2. 良好的八股文基础
这一块没什么好说的啦，就是常见的八股文得背扎实咯，如果大家不知道需要背哪些，可以后台点击编程资料领取
3. 扎实的计算机基础
（计算机网络最重要，操作系统和数据结构只需要背一些常见的题目）
同上~前端最重要的就是计算机网络，这个最常考。其他的只需要背常见的那几个面试题就好啦
4. 对常见的八股有自己深刻的理解
（一定要足够深刻，和别人拉开差距）
在一些常见的面试题，比如原型链、闭包、TCP等等，尽可能融入自己的理解，并且把这些内容研究透彻，最好加入底层原理的理解和目前有哪些应用场景等等~
5. 算法 &amp; 手写题一定要过关
（写不出来基本就挂了）
很重要！一定不能写不出来！！！算法题最好二刷，不要到时候发现是自己写过的，但是忘了哈哈哈，所以二刷其实性价比还是挺高的！建议大家二刷
6. 优秀的项目（不一定需要多）
项目尽可能不要烂大街，推荐大家去慕课网上做一些项目，还是比较不错的！挑选一些有技术难度的项目可能会好一些，比如低代码
7. 尽可能有一段以上的实习经历
有条件的同学尽可能先去找一些日常实习，有实习经历和没实习经历在春秋招差距太大啦，特别是找暑期实习的时候，如果有实习经历真是乱杀！秋招没有实习经历，并且学校不是很好的情况下可能就难搞了！
8. 合适的投递时间
（暑期实习3-5月份，秋招7-8月份）
如上文说，从23年的暑期实习来看，早投递面试难度比较大，晚投递可能机会少，但是面试难度简单一些。秋招必须得早投递，不能投晚了，如果晚了就得等11-12月份的补录，甚至是明年春招咯！
其他精品文章：
→六年级的妹妹问我怎么学前端
→前端基础版学习路线
→前端进阶版学习路线
希望以上内容对大家有所帮助！有问题可以多多私信交流呀！
后台点击编程资料有小粉的前端学习资料，大家可以看看！
感兴趣的小伙伴可以关注公众号
接收后续的最新资料
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea231a40b0c5cbfb9c167cd7abb433e3/" rel="bookmark">
			c&#43;&#43; 设计模式 的课本范例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1） 框架设计模式 model mode ： 算法的框架不变，算法的细节可以改变。主要依赖多态。
class Player { protected: int life; int magic; int attack; virtual void effect_self() {} virtual void effect_enemy() {} virtual bool can_burn() = 0; public: Player(int life, int magic, int attack) : life(life), magic(magic), attack(attack) {} virtual Player(){} void play_effect_burn() { cout &lt;&lt; "play_effect_burn\n"; } void burn() // 模板模式：算法的框架不变，细节可以变 { if (can_burn()) { effect_enemy(); effect_self(); play_effect_burn(); } } }; class Fighter : public Player { public: Fighter() : Player(100, 100, 50) {} void effect_self() override { this-&gt;life -= 30; } void effect_enemy() override { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea231a40b0c5cbfb9c167cd7abb433e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/843fe5d105971ffb1f1c6c71dd915c7e/" rel="bookmark">
			【数据结构】第十九弹---C语言实现冒泡排序算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨个人主页： 熬夜学编程的小林
💗系列专栏： 【C语言详解】 【数据结构详解】【C++详解】
目录
1、冒泡排序基本思想
2、代码的初步实现
3、代码的优化
4、代码的测试
5、时空复杂度分析
6、模拟实现qsort
6.1、冒泡排序函数
6.2、交换数据函数
6.3、比较函数
总结
1、冒泡排序基本思想 冒泡排序法：（Bubble sort）是一种基础的交换排序。对数组进行遍历，每次对相邻两个进行比较大小，若大的数值在前面则交换位置（升序），完成一趟遍历后数组中最大的数值到了数组的末尾位置，再对前面n-1个数值进行相同的遍历，完成n-1次遍历则排序完成。
1. 第一趟对0~n-1遍历，依次对比前后的大小，若是不满足前小后大就交换，此时最大的数就被挪到了最后一个位置。
2. 对0~n-2遍历，继续比较前后大小，此时前n-2个数中最大的数就到了倒数第二个位置。
3. 重复上述动作继续遍历，每一次都将最大的数向后挤，直到遍历完毕排序成功。
2、代码的初步实现 对int 类型的数进行升序排序。
//交换函数 void Swap(int* p1, int* p2) { int tmp = *p1; *p1 = *p2; *p2 = tmp; } void BubbleSort(int* a, int n) { for (int i = 0; i &lt; n - 1; i++)//遍历n-1次 { for (int j = 0; j &lt; n - 1 - i; j++)//相邻两个数进行比较 { if (a[j] &gt; a[j + 1])//前面的值大于后面的值则交换 { Swap(&amp;a[j], &amp;a[j + 1]); } } } } 3、代码的优化 如果一次遍历，没有数据进行交换，则证明数组已经排好了顺序，不需要继续遍历，则引入exchange变量标志记录第一次遍历是否有数据交换。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/843fe5d105971ffb1f1c6c71dd915c7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6af5bee93469b5be26c0298d0423585/" rel="bookmark">
			某程序员：30岁了，老婆管钱，背着我买了50万股票，亏了20w，强制她清仓后又买了36万
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“辛辛苦苦攒了几年钱，本想买房买车，结果全被老婆炒股亏掉了！” 近日，一位30岁的程序员大哥在网上吐苦水，引发了网友们的热议。
这位程序员大哥和妻子结婚后，一直秉持着“男主外，女主内”的传统模式，工资收入全数上交给妻子打理，自己则专心工作，一心想着早日实现买房买车的梦想。
然而，天有不测风云。去年，妻子背着他在股市“杀”进杀出，短短几个月时间，就亏掉了20万！
面对丈夫的质问，妻子非但没有悔改之意，反而信誓旦旦地保证会把亏掉的钱赚回来。然而，炒股就像一个无底洞，亏得越多，越想翻本，最终，在不到一年的时间里，妻子陆续投入了36万，最终还是打了水漂。
56万！这对于一个普通家庭来说，可不是一笔小数目。眼看着辛苦攒下的积蓄化为乌有，程序员大哥心急如焚，却又无可奈何。
“我跟她吵过，也好好谈过，但她就是不听劝，好像着了魔一样，每天就盯着手机看股票，茶不思饭不想的。” 程序员大哥无奈地说道。
这件事也引发了网友们的广泛讨论，不少人对程序员大哥的遭遇表示同情，但也有人认为，夫妻之间应该坦诚沟通，共同管理家庭财务，才能避免类似悲剧的发生。
“这已经不是简单的投资，是赌博！再不刹车，后果不堪设想！”
“人只能赚自己认知范围内的钱，不懂底层逻辑，就算一时赚了，迟早也会还回去的。”
“投资有风险，入市需谨慎！希望这位妻子能够早日醒悟，不要再执迷不悟了。”
也有网友分享了自己的亲身经历，建议程序员大哥及早采取措施，避免更大的损失：
“我家也是我管钱，我和老公约定好了，风险投资不能超过家庭总资产的10%，而且必须提前告知对方。”
“我们家是各自管各自的钱，互不干涉，这样也挺好的，避免了很多矛盾。”
“建议这位大哥和妻子好好谈谈，重新规划家庭财务，如果实在不行，就只能自己接管财权了。”
的确，婚姻是两个人的事，财务更是夫妻共同的责任。如何管理好家庭财产，不仅考验着夫妻之间的信任和理解，更需要双方的智慧和理性。
对于这位程序员大哥来说，或许现在是时候和妻子进行一次深度对话，重新审视彼此对金钱的态度，以及对未来的规划。
如果妻子执迷不悟，他也需要勇敢地站出来，承担起管理家庭财务的责任，毕竟，婚姻不仅是爱情的结合，更是责任的担当。
生活里，你是否也有过类似的财务烦恼或困惑？欢迎在评论区留言，分享你的故事和观点，让我们一起探讨，一起成长！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30d2597f39f19601104a2c9fc7fea7cd/" rel="bookmark">
			maven:中央仓库验证方式改变：401 Content access is protected by token
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天向maven中央仓库发布版本，执行上传命令mvn release:perform时报错了：
[ERROR] Failed to execute goal org.sonatype.plugins:nexus-staging-maven-plugin:1.6.13:deploy (injected-nexus-deploy) on project xxxxx: Failed to deploy artifacts: Could not transfer artifact xxxxx:pom:6.0.7-20240619.183701-1 from/to ossrh (https://oss.sonatype.org/content/repositories/snapshots): authentication failed for https://oss.sonatype.org/content/repositories/snapshots/xxxxxx.pom, status: 401 Content access is protected by token -&gt; [Help 1]
[ERROR]
[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.
[ERROR] Re-run Maven using the -X switch to enable full debug logging.
[ERROR]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30d2597f39f19601104a2c9fc7fea7cd/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/238/">«</a>
	<span class="pagination__item pagination__item--current">239/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/240/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>