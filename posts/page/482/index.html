<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22e9692bc0a98f0cd9f39f588f9a2677/" rel="bookmark">
			AVL树&amp;红黑树&amp;位图&amp;布隆过滤器&amp;并查集&amp;B树&amp;图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AVL树 二叉树在数据有序时,会变成单链表,使得搜索效率极大的降低,为了维持二叉树的搜索特性,使得整体保持平衡,从而诞生二叉搜索树
AVL树的插入&amp;旋转&amp;验证 public class AVLTree { public static void main(String[] args) { AVLTree avlTree = new AVLTree(); int[] arr = {4, 2, 6, 1, 3, 5, 15, 7, 16,14}; for (int i = 0; i &lt; arr.length; i++) { avlTree.insert(arr[i]); } System.out.println(isBalanced(root)); } public class TreeNode { public int val; public TreeNode left; public TreeNode right; public TreeNode parent; public int balanceFactor; public TreeNode(int val) { this.val = val; } } public static TreeNode root; public boolean insert(int val) { TreeNode nTreeNode = new TreeNode(val); //前部分是二叉树的插入 if (root == null) { root = nTreeNode; return true; } TreeNode curNode = nTreeNode; TreeNode prevNode = null; while (curNode !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22e9692bc0a98f0cd9f39f588f9a2677/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f24bc49d6dc28699c5f44fce151198c3/" rel="bookmark">
			C语言—求最大公约数（4种算法思路）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.穷举法 如果大数可以整除小数，那么最大公约数为小数。如果不能整除小数，那么这两个数就按大到小依次对比小数小的数求余，遇到都能够整除的，就是最大公约数。
int gcd(int a, int b) { int i; int min = a &lt; b ? a : b; for (i = min; i &gt;= 1; i--) { if (a % i == 0 &amp;&amp; b % i == 0) break; } return i; } 2.辗转相除法 用a对b求余，若余数为0，则除数b为最大公约数。若余数不为0，将此余数r作为新的除数，b作为新的被除数，重新求余，直到余数为0为止。此时的最大公约数为除数。
a.常规辗转 int gcd(int a, int b) { int t; while(a % b)//当a%b为0时，跳出循环，最大公约数为b { r = a % b; a = b; b = t; } return b; } b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f24bc49d6dc28699c5f44fce151198c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e224d0d41d4629fbfa8c2c0d82a6626d/" rel="bookmark">
			llama factory学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模型 模型名模型大小默认模块TemplateBaichuan27B/13BW_packbaichuan2BLOOM560M/1.1B/1.7B/3B/7.1B/176Bquery_key_value-BLOOMZ560M/1.1B/1.7B/3B/7.1B/176Bquery_key_value-ChatGLM36Bquery_key_valuechatglm3DeepSeek (MoE)7B/16B/67Bq_proj,v_projdeepseekFalcon7B/40B/180Bquery_key_valuefalconGemma2B/7Bq_proj,v_projgemmaInternLM27B/20Bwqkvintern2LLaMA7B/13B/33B/65Bq_proj,v_proj-LLaMA-27B/13B/70Bq_proj,v_projllama2Mistral7Bq_proj,v_projmistralMixtral8x7Bq_proj,v_projmistralPhi-1.5/21.3B/2.7Bq_proj,v_proj-Qwen1.8B/7B/14B/72Bc_attnqwenQwen1.50.5B/1.8B/4B/7B/14B/72Bq_proj,v_projqwenXVERSE7B/13B/65Bq_proj,v_projxverseYi6B/34Bq_proj,v_projyiYuan2B/51B/102Bq_proj,v_projyuan 单 GPU 训练 [!IMPORTANT]
如果您使用多张 GPU 训练模型，请移步多 GPU 分布式训练部分。
预训练 CUDA_VISIBLE_DEVICES=0 python src/train_bash.py \ --stage pt \ --do_train \ --model_name_or_path path_to_llama_model \ --dataset wiki_demo \ --finetuning_type lora \ --lora_target q_proj,v_proj \ --output_dir path_to_pt_checkpoint \ --overwrite_cache \ --per_device_train_batch_size 4 \ --gradient_accumulation_steps 4 \ --lr_scheduler_type cosine \ --logging_steps 10 \ --save_steps 1000 \ --learning_rate 5e-5 \ --num_train_epochs 3.0 \ --plot_loss \ --fp16 指令监督微调 CUDA_VISIBLE_DEVICES=0 python src/train_bash.py \ --stage sft \ --do_train \ --model_name_or_path path_to_llama_model \ --dataset alpaca_gpt4_zh \ --template default \ --finetuning_type lora \ --lora_target q_proj,v_proj \ --output_dir path_to_sft_checkpoint \ --overwrite_cache \ --per_device_train_batch_size 4 \ --gradient_accumulation_steps 4 \ --lr_scheduler_type cosine \ --logging_steps 10 \ --save_steps 1000 \ --learning_rate 5e-5 \ --num_train_epochs 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e224d0d41d4629fbfa8c2c0d82a6626d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6911d6d1598935b02222dec5c594b28/" rel="bookmark">
			阿里云DSW做AI绘画时的显卡选择A10?V100?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		V100是Volta架构，A10是Ampere架构，架构上讲A10先进点，其实只是制程区别，用起来没区别。
V100是HBM的内存读取，带宽大，但是DDR5的。
二块卡都是全精度为主的算力卡，半精度优势不明显。
需要用大内存的，选A10, 24G用起来舒服。核心也多。
需要用复杂运算的，选V100tensorrt多出不少，而且现在的AI都支持tensorrt了。如果玩双精度，就优势很明显了。
如果是人民币玩家，当生产力工具的，肯定是选择A10了，毕竟性价比优势摆着。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70a2e288b4c6afab37f29b01d919542e/" rel="bookmark">
			Javascript中的事件循环机制详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
概述
一、进程和线程
1.进程(Process)：
2.线程(Thread)：
二、Javascript单线程解释
三、JavaScript事件循环(Event Loop)
列举以下几种(非全部)
总结
概述 事件循环负责执行代码、收集和处理事件以及执行队列中的子任务。
JavaScript中的事件循环是一种异步执行机制，作用是协调和管理各种异步任务的执行顺序，以确保JavaScript代码执行的顺序和预期一致。
代码在执行时会先执行同步任务，而异步任务则被放入任务队列中等待执行。事件的循环机制会不断地检查任务队列中是否有任务需要执行，如果有，则将任务取出并执行。在执行异步任务时，引擎会挂起当前任务的执行，去执行异步任务，等到异步任务执行完成后，再回到之前的任务继续执行。
事件循环的组成：调用栈、任务队列和事件循环线程。调用栈用来管理代码的执行顺序，任务队列用来存放异步任务，事件循环线程则是一个循环，不断地从任务队列中取出任务执行。
一、进程和线程 在将JavaScript事件循环前先简单了解一下进程和线程
1.进程(Process)： 在系统中程序运行需要有它自身的独立内存空间，可以把分配给程序运行的这块内存空间理解为进程。进程是系统进行资源分配和调度的基本单位，是操作系统结构的基础。
每个应用最少需要一个进程，进程与进程之间是独立的存在，即使需要通讯，也需要双方建立关系(同意相互之间通讯)
2.线程(Thread)： 线程是系统中能够进行运算的最小单位，一个进程最少有一个线程，所以在进程开启后会主动创建一个线程来运行代码程序，该线程称之为主线程，如果程序代码中需要同时执行多个代码块的话，主线程就会同时开启多个线程来执行，因此一个进程中是可以包含多个线程的。
简单常见的示例，启动浏览器后就会开启多个进程，如浏览器、网络进程、渲染进程等，且浏览器的每一个新的标签页都是独立的进程，而每个进程下都有一个线程，所以说浏览器是一个多进程和多线程的应用。
二、Javascript单线程解释 单线程就意味着，所有任务需要排队，前面的任务结束，才会执行后面的任务。假如一个任务耗时很长，后面的一直等着，就会造成阻塞，不得不等着结果出来，再往下执行。
因为，在设计之初，JavaScript就是单线程，这是Javascript这门语言的核心特征。
为了解决这一问题，Javascript把任务分成两种，一种是同步任务，一种是异步任务。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入任务队列中的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。
所以Javascript是单线程代码执行不阻塞主进程一种机制。
Javascript作为浏览器脚本语言，它的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。如果JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器就无法确定以哪个线程为准了。
在HTML5中提出Web Worker标准
Web Worker 是一种浏览器提供的 JavaScript API，它允许在后台线程中运行脚本，而不会阻塞主线程。这意味着，即使脚本执行了很长时间，Web 应用程序的 UI 仍然可以保持响应。
Web Worker 有两种类型：Dedicated Worker 和 Shared Worker。Dedicated Worker 是指与一个页面绑定的 Worker，它仅能由该页面的脚本使用。而 Shared Worker 则可以被多个页面共享使用，这使得多个页面可以同时访问同一个后台线程
即使HTML5中允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。
三、JavaScript事件循环(Event Loop) Javascript开始执行的时候，会分为两部分进行执行，同步和异步
1、同步任务会直接进入主线程依次执行；
2、异步任务会再分为宏任务和微任务。
当在JavaScript代码执行时，如果遇到一个异步任务，如 setTimeout()、Promise，则会将任务添加到任务队列中，等待执行。在JavaScript引擎空闲时，事件循环线程会不断地从任务队列中取出任务，放入调用栈中执行，直到任务队列为空为止。
当主线程内的任务执行完毕，优先检查微任务的任务队列，如果有任务，就进入主线程进行依次执行，没有就从宏任务队列读取下一个宏任务执行；
每执行完一个宏任务就清空一次微任务队列，不断重复，这就是事件的循环；
来看一个实例
function bobEventLoop(){ console.log("1"); setTimeout(()=&gt;{ console.log("2"); },0); console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70a2e288b4c6afab37f29b01d919542e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9ef19f28bc3d3e6df6ee77547e5512c/" rel="bookmark">
			SpringCloud-SpringBoot读取Nacos上的配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Spring Boot 应用程序中，可以使用 Spring Cloud Nacos 来实现从 Nacos 服务注册中心和配置中心读取配置信息。以下是如何在 Spring Boot 中读取 Nacos 上的配置文件的步骤：
1. 引入依赖
首先，在 Spring Boot 项目的 pom.xml 文件中添加 Spring Cloud Nacos 的依赖：
&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; 2. 配置 Nacos 连接信息
将 Nacos 服务注册中心和配置中心的地址、命名空间等相关信息添加到 application.properties 或 application.yml 配置文件中：
spring.cloud.nacos.config.server-addr=localhost:8848 spring.cloud.nacos.config.namespace= 3. 编写配置文件 在 Nacos 配置中心创建配置文件（例如 ​application.properties​），并添加一些键值对，如：
user.name=John Doe user.age=30 4. 读取配置信息
在 Spring Boot 的任何配置类或组件类中，可以使用 ​@Value​ 注解或 ​@ConfigurationProperties​ 注解来读取配置项：
import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class ConfigController { @Value("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9ef19f28bc3d3e6df6ee77547e5512c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2696db1ac73e948e9591e24c089ee0d9/" rel="bookmark">
			java try catch 异常后还会继续执行吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、有 try-catch 语句块，并且 throw 在 catch 语句块里，那么 try 语句块中引发异常（报错）的那一行代码的后续代码都不执行并且 catch 语句块后的代码也都不执行（遇到 finally 除外）。（见情形一和情形二）
2、有 try-catch 语句块，并且 throw 在 try 语句块里，那么 try 语句块中引发异常（报错）的那一行代码的后续代码都不执行，但是 catch 语句块后的代码会继续执行。（见情形三）
3、有 try-catch 语句块，但是没有 throw 语句，那么 try 语句块中引发异常（报错）的那一行代码的后续代码都不执行，但是 catch 语句块后的代码会继续执行。（见情形四）
4、有 try-catch 语句块，但是没有 throw 语句，如果这个异常对象与catch中声明的异常类型不匹配，程序会中断。（见情形五）
5、没有 try-catch 语句块，单纯只有 throw 抛出异常的语句块，那么 throw 后面的代码都不执行。（见情形六）
情景一 public class ExceptionTest { public static void main(String[] args) { String a = null; int c = 0, d = 0; try { int b = a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2696db1ac73e948e9591e24c089ee0d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a77283fc45d5d0d0187e3e8fe52c6a80/" rel="bookmark">
			App上传90725问题SDK version issue. This app was built with the iOS 16.4 SDK. Starting April 29, 2024...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		9072报错 SDK version issue. This app was built with the iOS 16.4 SDK. Starting April 29, 2024, all iOS and iPadOS apps must be built with the iOS 17 SDK or later, included in Xcode 15 or later, in order to be uploaded to App Store Connect or submitted for distribution. (90725)。
SDK版本问题。这个应用程序是用iOS 16.4 SDK构建的。从2024年4月29日开始，所有iOS和ipad应用必须使用iOS 17 SDK或更高版本构建，包含在Xcode 15或更高版本中，才能上传到App Store Connect或提交分发。(90725)
问题描述的很清晰。2024年4月29日开始打包上传需要升级mac系统和Xcode版本。Xcode需要高于 15。目前虽然有提示可以正常的上传到AppStore审核分发。2024年4月29日以后应该是不升级无法上传审核。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcb3e456624ade6b39215dffa0bb3e97/" rel="bookmark">
			【SD大模型分享】之前做小说推文花钱买来的，各种3D、2.5D、真实系、动画系、古风系lora，AI绘画小模型分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 写在前面 因为之前自己做小说推文，为了画风更精致一点，当时找遍了各种资源，也花钱买了一些模型，现在不做了，就跟大家分享一下吧。
想做推文的，直接下载就行了。
地址我放在文章最底部了，真实有效，不骗人，放心！
应用介绍 这个是stable diffusion （以下简称“SD”）AI智能绘画的大模型，比如咱们常见的一些文字生成动漫风格的，都是通过将这个大模型导入到SD里后生成出来对应的图片。
功能特色 1.真实3D
2. 手绘画风
3. 动漫画风（2.5D）
4. 二次元
5. 万能系
6. tag描述词
7. lora小模型
案例演示 这里，我随便用自己电脑给大家生成一张演示看看吧。
原文地址：SD大模型全套打包下载地址 | 晒应用导航 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bfa4c1de9ef293e60e4e4ca96102d85/" rel="bookmark">
			Graphpad Prism10.2.1（395） 安装教程 (含Win/Mac版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GraphPad Prism GraphPad Prism是一款非常专业强大的科研医学生物数据处理绘图软件，它可以将科学图形、综合曲线拟合（非线性回归）、可理解的统计数据、数据组织结合在一起，除了最基本的数据统计分析外，还能自动生成统计图。
安装教程 注意
如果你是首次使用该工具的话 请先移步至文章 Graphpad Prism9.5.1 科学绘图软件 下载安装教程(含Win/Mac) 进行安装 之后再查看文章
Graphpad Prism10.2.1 (win/mac) 科学绘图软件安装教程 安装最新版本的工具
之前有安装过的直接查看文章 Graphpad Prism10.2.1 (win/mac) 科学绘图软件安装教程 安装最新版本的工具
win安装 （以前安装过的安装最新版的教程） 1.首先解压文件该
2.打开解压文件 GraphPad Prism 10.2.0.392 文件夹后点击 installer.msi程序
3.进入选择安装位置，默认是C盘 为了不占据主盘 建议安装至其它盘中 选择完成后 选择Install进行安装
4.等待安装完成
5.安装完成后 会进入软件界面 会显示下图提示 直接点击Quit进行关闭
6.找到下载的位置 打开crack文件夹 复制prism.exe程序
7.找到选择安装软件的根目录 粘贴并替换prism.exe文件即可
8.重新打开软件 直接享受即可
以上就是关于Win版的安装教程 后续还会添加Mac版资源及安装教程 尽情期待。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a89d8388c09116c69a0ddc87724eb090/" rel="bookmark">
			5款免费且出色的ai智能ppt制作软件，值得拥有！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果说2023是AI崛起的元年，那2024无疑是AI应用的真正元年，人们对AI技术逐渐回归理性，关注的焦点也从产品层转向应用层，探索AI如何更好地赋能业务，或是重塑工作流程，让AI真正为自己所用。
在数字化盛兴的当下，PPT演示文稿成为了我们生活学习和工作中的重要角色。但是，制作一份专业且引人入胜的PPT费时又费力。幸运的是，随着AI技术的蓬勃发展，如今市面上有越来越多的AI智能PPT制作工具，可以帮助我们轻松地完成这项工作。
这些AI制作PPT工具不只是提供丰富的模板和设计元素，更能根据我们提供的内容自动构建演示文稿，极大地提升了我们的工作效率。在接下来的文章中，我们会介绍5款免费且功能出众的一键生成PPT软件，它们分别是Gamma、Tome、SlidesAI、Beautiful.ai以及国内领先的boardmix AI PPT。
*ai智能ppt制作工具合集
ai智能ppt制作是什么？ ai智能PPT制作是指使用AI人工智能技术来创建演示文稿的过程，这种技术可以根据用户输入的信息自动生成PPT，包括布局设计，颜色选择，图表创建等。这种方式大大提高了制作效率，同时也能产生专业且吸引人的演示文稿。
ai智能ppt制作的工作原理 AI智能PPT制作，是一种模拟人类智能制作PPT的先进技术。在PPT制作中，AI可以通过学习大量的PPT设计样本，理解并模拟人类的设计思维和审美观，从而自动完成PPT的设计工作。
具体来说，AI智能PPT制作工具包含以下几个步骤：
用户输入内容：用户将需要展示的内容输入到AI智能PPT制作工具中。AI分析内容：AI会对用户输入的内容进行深度分析，包括主题识别、关键词提取等。AI生成设计方案：根据分析结果，AI会从预设的设计库中选择合适的模板和元素，生成初步的PPT设计方案。用户调整和优化：用户可以根据需要对AI生成的设计方案进行调整和优化。AI学习和进化：通过用户的反馈和调整，AI会不断学习和进化，提高其设计能力。 ai智能ppt制作软件推荐 目前市面上可用来快速制作PPT的ai智能软件非常多，导致很多人在选择时不知从何下手，鉴于这种情况，笔者逐一体验了几十款ai智能ppt制作软件，经过深度使用，从中选出了最具代表性的5款ai智能ppt制作软件：
① ai智能ppt制作软件boardmix AI PPT boardmix，是新一代的在线PPT幻灯片软件，提供了制作PPT常用的各种工具，如：形状、文本、图片、便签、表格、思维导图等，用户可以基于内置的工具在线制作PPT幻灯片，且借助自带的分享功能，可实现多人在线协同编辑PPT内容。
与此同时，boardmix也推出了一键生成PPT的AI功能——boardmix AI，在使用这一功能时，只需输入PPT主题，AI就会自动生成相应的PPT。boardmix AI生成的PPT非常完整，接近于我们日常手动制作的PPT，包含PPT封面页、目录页、过渡页、内容页和结束页，生成之前可选定一种PPT主题，生成后依旧可以随意更改主题，从内置的主题库中重选主题，PPT所有页面也会随之自动更改。
*AI生成PPT免费boardmix
AI生成PPT软件boardmix AI-功能特点 AI快速生成PPT：用户只需输入主题，boardmix AI就能自动生成PPT，大大提高了制作效率，节省了用户的时间。AI提炼本地文档生成PPT：支持导入本地TXT和Markdown文件，经由boardmix AI提炼一键自动生成PPT。自定义主题和风格：boardmix提供了12种风格的PPT模板，包括经典、沉稳、学术、自然、工业、文艺、小清新、简约、商务、扁平、卡通、卡通2，用户可以根据自己的需求选择合适的风格，以适应不同的业务场景。自动文稿内容生成：boardmix AI能够根据用户输入的PPT主题自动生成文稿内容，并允许用户进行自定义编辑和修改。自动排版和美化：软件自动进行配色和字体排版，无需用户具备设计技能，即可轻松制作出高颜值的PPT演示文稿。内置图表工具：boardmix AI内置了折线图、条形图等多种图表工具，帮助用户直观地呈现数据和信息。AI润色和优化：AI技术用于润色和优化内容，确保PPT内容的质量和专业性。多人在线协作：支持一键分享和多人在线协作，团队成员可以实时共同工作，提高团队效率。精细化权限管理：软件提供精细化的权限管理功能，确保团队成员可以安全地共享和编辑文档。演示互动功能：包括在线投票、计时器、演示者模式等，增强了演示的互动性和参与感。多格式导出：支持将PPT导出为PNG、JPG、SVG和PDF等多种格式，方便用户在不同场合使用。AI助手创作能力：除了一键生成PPT，boardmix AI还具备AI生成图片（AI绘画）、实用模板、写作助手、流程图、思维导图和代码等多样化的创作能力。 除了基于输入的PPT主题自动生成PPT，boardmix还提供了其他一键生成PPT的选项，包括——
AI提炼文本内容生成PPT，选中boardmix画布上的任意文本（支持多选），调出boardmix AI助手，基于AI提炼自动生成PPTAI提炼文档内容生成PPT，它支持导入本地的Markdown、TXT文件，经由AI提炼自动生成PPT思维导图一键生成PPT，单击选中boardmix思维导图的主节点，选择上方工具栏的「生成」，即可将选中的思维导图一键转换为PPT 优点：
本地化支持：boardmix AI PPT 支持中文界面和内容，适合国内用户使用。无限画布：内置无限画布，用户可同时创建多个PPT，或是自由添加各类内容，让创意不受限。实时协作：多人协作功能使得团队成员可以同时工作，提高了工作效率。一站式办公应用：boardmix不仅支持一键生成PPT，它还提供了办公常用的各项工具，包括文档、表格、思维导图、流程图、看板、以及多款主流的第三方应用等，一款软件囊括多款办公应用，纵享一站式办公体验。免费使用：boardmix AI给每位用户提供了500个AI点数，非常适合初次接触ai智能ppt制作的用户使用。 缺点：
目前暂不支持离线编辑，只能在联网环境下使用。
boardmix AI PPT使用场景
国内企业团队：适合国内企业团队进行PPT制作和协作。团队协同提效：支持多人在线协作，不限时间地点，可以高效地进行协同办公。头脑风暴：boardmix提供多种可视化工具和演示功能，团队成员可在无限大的白板上自由讨论想法，同时借助boardmix的可视化工具进行呈现和演示。创意灵感可视化：通过内置的工具，可以自定义文本、图片、颜色、字体等，帮助用户将创意以视觉化的方式呈现出来。敏捷精益看板：适用于敏捷开发流程中，帮助团队跟踪进度和任务。互动白板教学：可以在教学过程中使用，支持在线演示和互动，提高教学效果。在线流程图和思维导图：用于规划和组织思路，帮助用户清晰地展示流程和思维结构。个人笔记和灵感收集：个人用户可以用它来整理笔记和收集灵感，便于后续的回顾和使用。在线研讨会和头脑风暴：支持在线投票、计时器等功能，适合进行远程会议和团队创意讨论。 下面演示基于boardmix AI生成大纲，最终一键生成PPT的过程：
点击boardmix画布左上角的「生成演示文稿」，打开右侧的「AI生成演示文稿」面板，点击底部的「按照大纲生成」，切换到AI生成PPT大纲的模式，在下方输入PPT主题，如「2024最新设计趋势介绍」，boardmix AI会基于我们输入的主题自动生成大纲。
我们可以对boardmix AI生成的PPT大纲进行调整，包括编辑大纲内容、更改大纲的位置或缩进，完成编辑之后，从内置的12种PPT主题中选择一个模板，点击「生成」按钮，boardmix AI就会生成一份完整的PPT，如下图所示。
② ai智能ppt制作软件Gamma Gamma是一款新兴的AI PPT制作工具，它通过智能算法帮助用户快速生成演示文稿。Gamma的设计理念是简化设计流程，让用户专注于内容的传达。
特色功能：
智能内容分析：Gamma能够分析用户输入的文本内容，自动推荐合适的布局和设计元素。
一键生成：用户只需提供基本的信息，Gamma就能一键生成完整的PPT。
优点：
高效便捷：Gamma的一键生成功能极大地节省了用户制作PPT的时间。
智能推荐：AI算法的智能推荐减少了用户在设计选择上的犹豫和尝试。
缺点：
个性化限制：虽然提供了一键生成的便利，但可能在某些情况下限制了用户的个性化定制需求。
新工具的挑战：作为新工具，Gamma可能在用户基础和知名度上不如市场上的成熟产品。
使用场景：
快速演示制作：适合需要在短时间内制作演示文稿的用户，如商务演讲、项目汇报等。
非设计专业人士：适合那些希望快速制作专业演示但不具备设计背景的用户。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a89d8388c09116c69a0ddc87724eb090/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a78f13962c90da3669f2280454d8a38/" rel="bookmark">
			Red Hat 系统 Nginx下载、编译和安装（详细步骤）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx的相关介绍：
Nginx是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like协议下发行。它具有很多显著的特点和优势，下面将对Nginx的相关介绍和作用进行详细阐述：
Nginx的特点：
高性能、内存占用少、跨平台
Nginx的作用：
静态代理：Nginx擅长处理静态文件，可以作为图片、文件等静态资源的服务器。
反向代理：这是Nginx服务器作为Web服务器的主要功能之一。这种机制可以提高系统的安全性和灵活性。
负载均衡：Nginx通过反向代理可以实现服务的负载均衡。这种负载均衡机制可以大幅度提高网络系统的处理能力，并减少后端服务器处理压力。
Web缓存：Nginx还可以作为前置缓存服务器，用于缓存前端请求，从而提高Web服务器的性能。
综上所述，Nginx是一款功能强大、性能卓越的Web服务器和反向代理服务器，具有广泛的应用场景和重要的作用。（本篇博客由小组成员易彦君，阎婉欣完成）
一.Nginx源码下载、编译和安装 1.Nginx下载地址： http:// http://nginx.org/en/download.html
进入网址后可直接选择好版本进行下载
或者在终端可以选择命令下载：
自行选择版本下载（1.20以上的都可以，此处选择的是1.20.1版本）
wget http://nginx.org/download/nginx-1.20.1.tar.gz 下载完成后查看文件
2.进行解压
tar -zxvf nginx-1.20.1.tar.gz 解压完成后查看文件如图所示
进入到nginx目录可以查看nginx目录下的文件
3.安装依赖包
yum -y install gcc make gcc-c++ libtool pcre pcre-devel zlib zlib-devel openssl openssl-devel perl-ExtUtils-Embed 4.进入/usr/local/nginx目录下开始安装nginx
./configure --prefix=/usr/local/nginx 安装命令也可用以下命令替代：
./configure --user-nginx --group= nginx --prefix=/usr/local/nginx --with-http_stub_ status_module --with-http_ssl_ module --with-http_gzip_static_module
其中 --user=nginx指定运行权限的用户;--group=nginx指定运行权限的用户组; --prefix=/usr/local/nginx指定安装路径;--with-http_stub_status_module 表示支持Nginx状态查询;
--with-http_ssl_module表示启用SSL 支持;--with-http_gzip_static_mod ule 表示启用 GZIP功能。
5.执行以下命令进行编译和安装nginx
make &amp; make install 安装完成后查看该目录下的文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a78f13962c90da3669f2280454d8a38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57808631247281e508cf7e1dfb5efabe/" rel="bookmark">
			16款Stable Diffusion插件推荐，让SD小白快速上手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着 Stable Diffusion 的不断进化，越来越多的开发者加入到插件开发的行列中。大家都知道网上虽然教程多，但非常碎片，一个个学习和查阅真的非常耗时，感觉每天都在烧脑。如果你是SD小白或者是小懒猫，又想快速上手使用 Stable Diffusion 插件，那么这篇文章就非常适合你了！因为这是以设计师日常应用的角度出发，从推荐指数、易上手程度、使用频率三个维度来测评。下面会附赠下载地址！
希望这篇文章能够帮助大家更好地了解 Stable Diffusion 插件。
1.prompt-all-in-one提示词翻译补全(自动翻译)
推荐指数： ⭐️⭐️⭐️⭐️⭐️
易上手程度： ⭐️⭐️⭐️⭐️⭐️
使用频率： ⭐️⭐️⭐️⭐️⭐️
能做什么：prompt-all-in-one提示词翻译补全可以帮助英文不好的用户，快速弥补英文短板。其中包含，中文输入自动转英文、自动保存使用描述词、描述词历史记录、快速修改权重、收藏常用描述词、翻译接口可以多种选择、一键粘贴删除描述词等。
扩展地址：https://github.com/Physton/sd-webui-prompt-all-in-one 或者请看文末获取
2. SixGod提示词插件
推荐指数： ⭐️⭐️⭐️⭐️
易上手程度： ⭐️⭐️⭐️⭐️⭐️
使用频率： ⭐️⭐️⭐️⭐️
能做什么：SixGod提示词插件可以帮助用户快速生成逼真、有创意的图像。其中包含，清空正向提示词”和“清空负向提示词、提示词起手式包含人物、服饰、人物发型等各个维度的提示词、一键清除正面提示词与负面提示词、随机灵感关键词、提示词分类组合随机、动态随机语法等。
扩展地址：https://github.com/thisjam/sd-webui-oldsix-prompt 或者请看文末获取
3. After Detailer人脸及手部修复插件
推荐指数： ⭐️⭐️⭐️⭐️⭐️ 易上手程度： ⭐️⭐️⭐️⭐️⭐️
使用频率： ⭐️⭐️⭐️⭐️
能做什么：After Detailer 是一款强大的图像编辑工具，可用于修复和编辑图像。自动修复图像中的瑕疵 ，无论是2D还是真实的人脸及手部都可以通过识别面部/人物/手部并自动对其进行mask和重绘的工具，可以通过调整参数去改变识别的对象和识别区域的大小及位置等。
扩展地址：https://github.com/Bing-su/adetailer 或者请看文末获取
4. Tagger提示词反推
推荐指数： ⭐️⭐️⭐️ 易上手程度： ⭐️⭐️⭐️⭐️⭐️
使用频率： ⭐️⭐️
能做什么：Tagger 提示词反推可以从任意图片中提取。帮助理解图像的内容、创建创意图像、分析图像数据。
扩展地址：https://github.com/pythongosssComfyUI-WD14-Tagger?tab=readme-ov-file 或者请看文末获取
5. Inpaint Anything蒙版换装换脸
推荐指数： ⭐️⭐️⭐️⭐️
易上手程度： ⭐️⭐️⭐️
使用频率： ⭐️⭐️
能做什么：Inpaint Anything 是一款强大的图像编辑工具，可用于删除和替换图像中的任何内容。它使用人工智能来自动识别和修复图像中的缺陷，无需使用遮罩。删除图像中的不需要的对象或瑕疵、修复图像中的损坏或损坏、替换图像中的对象或背景、创建创意图像效果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57808631247281e508cf7e1dfb5efabe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d16abd1a7c4d5840c73754b1e419b681/" rel="bookmark">
			redis最新版本在Windows系统上的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、说明 这次安装操作主要是根据redis官网说明，一步步安装下来的，英语比较好的同学，可以直接看文章底部的超链接1，跳到官网按步操作即可。
目前redis的最新稳定版本为redis7.2。
二、Windows环境改造 Redis在Windows上不被官方支持。但是，您可以按照以下说明在Windows上安装Redis进行开发。
要在Windows上安装Redis，首先需要启用WSL2(Linux的Windows子系统)。WSL2允许您在Windows上本机运行Linux二进制文件。要使用这种方法，你需要运行Windows10 2004及更高版本或Windows 11。
2.1 安装wsl（微软linux子系统） 【Windows】+ R键，打开运行窗口，输入【cmd】命令，确定，操作如下：
输入wsl --install命令即可，回车执行。更多操作可以参见官网：https://learn.microsoft.com/en-us/windows/wsl/install
2.2 安装完成后，你的Windows电脑上会多出下面两个项目，点击Ubuntu，在Ubuntu页面里你很大可能会遇到下面记录的异常 异常提示信息：
wsl: 检测到 localhost 代理配置，但未镜像到 WSL 2.3 解决办法 打开系统的网络设置，进行局域网配置即可，将局域网设置为【自动检测设置】
2.4 上述配置完成后，重启电脑 重新打开Ubuntu应用，进行用户和密码设置。
https://learn.microsoft.com/en-us/windows/wsl/setup/environment#set-up-your-linux-username-and-password
三、安装redis7.2 3.1 进入电脑上的刚刚安装的Ubuntu应用 一旦你在Windows上运行Ubuntu，你可以按照安装在Ubuntu/Debian上的详细步骤，从官方的package . Redis .io APT存储库中安装最新稳定版本的Redis。将存储库添加到apt索引，更新它，然后安装，具体命令如下：
curl -fsSL https://packages.redis.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg echo "deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/redis.list sudo apt-get update sudo apt-get install redis 最后，启动你的redis应用：
sudo service redis-server start 命令验证
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d16abd1a7c4d5840c73754b1e419b681/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/698fed5d8c90a435b28aaaba80ede97d/" rel="bookmark">
			【AI面试】目标检测中one-stage、two-stage算法的内容和优缺点对比汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在深度学习领域中，图像分类，目标检测和目标分割是三个相对来说较为基础的任务了。再加上图像生成（GAN，VAE，扩散模型），keypoints关键点检测等等，基本上涵盖了图像领域大部分场景了。
尤其是在目标检测，一直是各大比赛（Pascal VOC, COCO, ImageNet）的主要任务。与此同时，检测任务中的两大流派：one-stage、two-stage一直是热议的话题。同时，也是面试官最喜欢问的话题。
早期的物体检测多使用滑动窗口与分类器配合行动。在两步方案中，R-CNN首先在第二阶段使用卷积神经网络极大的提升了准确率，开启了物体检测的新纪元。RPN的出现则将两步方案统一在一个神经网络中，得名Faster R-CNN。单步检测器的出现极大的提升了检测速度，但是却以准确率下降为代价。
单步检测器面临的最大问题：在于训练过程中正负（positive and negative）样本的极端不均衡。每张图像成千上万个待检对象中，只有数个包含了有效物体（positive）。这造成两个不利后果：
训练的效率下降。大部分位置极易被归为负样本，对有效的学习没有帮助。大量的容易负样本主导了训练过程，造成模型退化。 稳健的损失函数一直是研究的热点之一。例如Huber loss降低异常样本（困难样本）的权重。而Focal loss则注重降低常规样本（简单样本）的权重，集中精力在困难样本上。
针对本文的这个问题，我也帮你们提前问了chatGPT，也给出了一个较为总结性的回答，如下所示。你们觉得它回答的如何呢？
chatGPT已经对本节的内容，给出了一个大体的概括，总结下，包括
算法模型呢：
one stage的算法包括SSD、yolo、Retina Net等等two stage的算法包括fast RCNN系列，和用于分割的Mask RCNN系列 优点呢：
1. one stage的算法速度非常快，适合做实时检测的任务，比如视频；
2. two stage的算法速度慢，但是检测效果更佳；
缺点呢？
one stage的算法通常相比于two stage的算法，效果不太好two stage的算法经过了一步初筛，通常效果会更好，更准确 目标检测算法综述截图，展示了随时间发展，one- stage和two- stage的发展分枝。从2014年RCNN开始，再到后来SSD和YOLO的横空出世，基本上奠定了两条路的主基调。
一、two stage two stage的代表faster RCNN的模型结构图。稍微简述下：
特征提取模块backbone，主要用于对输入图像进行特征抽取，输出特征图Feature Map，一般会采用resnet、VGG，GoogLeNet的主干部分（去掉全连接层）作为backbone.第一阶段的RPN（region proposal network）区域推荐网络，主要就是基于backbone输出的Feature Map，筛选目标候选框，给出进一步判断的Proposal在RPN完成后，得到的候选框还只是区分出它是前景positive和背景negative，还不能区分是猫，还是狗于是，就有了第二阶段，对第一阶段提议的阳性positive候选框Proposal，与backbone输出的Feature Map，裁剪出区域，经过ROI Pooling，统一到一致的尺寸，进入到ROI Head阶段。经过卷积和全连接层，区分出具体的类别cls和bbox coor(cx, cy, pw, ph)的偏移量（tx, ty, tw, th），进一步修正目标框，得到最终的位置（bx=σ(tx)+cx, by=σ(ty)+cy, bw=pw*tw, bh=ph*th）。 如下图所示，这样看，是不是真的把预测目标检测的任务，给拆分成两个阶段分段的来进行预测的呢？更多内容推荐阅读这里：一文读懂Faster RCNN
1.1、训练和验证阶段 其实，要理解faster RCNN的整理工作方式，需要区分成训练阶段train 和推理阶段inference，区别对待。
先说简单的推理阶段inference。
推理阶段与训练阶段最大的不同，就是推理阶段没有金标准target， 也就没有计算损失，更没有办法更新网络模型：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/698fed5d8c90a435b28aaaba80ede97d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ec74aedde616d4c63e872dec4a4d55b/" rel="bookmark">
			StarCoder 2：GitHub Copilot本地开源LLM替代方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitHub CoPilot拥有超过130万付费用户，部署在5万多个组织中，是世界上部署最广泛的人工智能开发工具。使用LLM进行编程辅助工作不仅提高了生产力，而且正在永久性地改变数字原住民开发软件的方式，我也是它的付费用户之一。
低代码/无代码平台将使应用程序创建、工作流自动化和数据分析更加广泛的应用，这种变革潜力支撑着人们对开源替代方案的极大兴趣，我们今天将要介绍的这个令人兴奋的发展。最近BigCode与NVIDIA合作推出了StarCoder2，这是一系列专为编码而设计的开放式LLM，我认为在大小和性能方面是目前最好的开源LLM。
在本文中，我们将介绍StarCoder2的一些基本信息，然后建立一个本地环境，搭建StarCoder2-15B模型并用Python, JavaScript, SQL, c++和Java测试其编码能力。
StarCoder2简介 StarCoder2模型有三种不同大小可供选择，包括3B、7B和15B参数，并且支持广泛的编程语言。每个模型都是在The Stack v2上进行训练的，这是当前最广泛的用于LLM预训练的开源代码数据集。模型的主要特点如下：
3B（由ServiceNow提供）、7B（由Hugging Face提供）和15B参数版本（由NVIDIA使用NVIDIA NeMo）所有模型使用分组查询注意力（Grouped Query Attention）上下文窗口为16,384个标记，滑动窗口注意力为4,096个标记模型是使用填空目标（Fill-in-the-Middle objective）进行训练的训练时使用了3+ T（3B）、3.5+ T（7B）、4+ T（15B）标记以及600多种编程语言StarCoder2–15B在StarCoder2模型中是最佳的，并在许多评估中与其他33B+模型相匹配。StarCoder2–3B的性能与StarCoder1–15B相当训练时使用了1024 x H100 NVIDIA GPU所有模型均具有商业友好的许可证 StarCoder2的能力（特别是15B模型）在性能指标中明显优于其他相同尺寸的模型，并且与CodeLlama-34B相匹配。
在具有16K标记的上下文长度下，模型处理广泛的代码库和指令，确保了全面的代码理解和生成能力。
StarCoder2安装 为了简单起见，我们使用venv创建虚拟环境，然后安装相应的包
# Create a virtual environment mkdirstarcoder2&amp;&amp;cdstarcoder2 python3-mvenvstarcoder2-env sourcestarcoder2-env/bin/activate # Install dependencies pip3installtorch pip3installgit+https://github.com/huggingface/transformers.git pip3installdatasets pip3installipykerneljupyter pip3install--upgradehuggingface_hub pip3installaccelerate# to run the model on a single / multi GPU pip3installbitsandbytes # Loging to Huggingface Hub huggingface-clilogin # Optionally, fire up VSCode or your favorite IDE and let's get rolling!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ec74aedde616d4c63e872dec4a4d55b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f16068a0671e06ffdf7ca32f02f9e9e/" rel="bookmark">
			JavaScript 空数组的 every() 方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript 语言的核心足够大，以至于很容易误解其某些部分的工作方式。我最近在重构一些使用 every() 方法的代码时发现，我实际上并没有完全理解其背后的逻辑。在我的脑海中，我假设回调函数必须被调用并返回 true，every() 才会返回 true，但实际情况并非如此。对于一个空数组，every() 无论回调函数是什么都会返回 true，因为那个回调函数从未被调用。考虑以下情况：
function isNumber(value) { return typeof value === "number"; } [1].every(isNumber); // true ["1"].every(isNumber); // false [1, 2, 3].every(isNumber); // true [1, "2", 3].every(isNumber); // false [].every(isNumber); // true 在这个例子的每种情况下，调用 every() 都是为了检查数组中的每一项是否为数字。前四个调用相当直接，every() 产生了预期的结果。现在考虑这些例子：
[].every(() =&gt; true); // true [].every(() =&gt; false); // true 这可能更令人惊讶：无论是返回 true 还是 false 的回调，结果都是一样的。唯一的原因是如果回调没有被调用，every() 的默认值是 true。但是，为什么一个空数组会对 every() 返回 true，当没有值去执行回调函数时呢？
要理解原因，重要的是要看看规范是如何描述这个方法的。
实现 every() ECMA-262 定义了一个 Array.prototype.every() 算法，大致可以翻译成以下的 JavaScript 代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f16068a0671e06ffdf7ca32f02f9e9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34b2cdae9beb9a5b6cbb85e1d30259e9/" rel="bookmark">
			贪心算法（greedy algorithm，又称贪婪算法）详解（附例题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 基本思想一）概念二）找出全局最优解的要求三）求解时应考虑的问题四）基本步骤五）贪心策略选择六）实际应用 1.零钱找回问题2.背包问题3.哈夫曼编码4.单源路径中的Djikstra算法5.最小生成树Prim算法 基本思想 贪心算法（Greedy Algorithm）是一种在求解问题时，每一步都选择当前最优解，以期望最终得到全局最优解的算法思想。贪心算法的基本思想可以总结为“每一步都做出一个局部最优的选择，最终就能得到全局最优解”。 贪心算法通常包含以下关键步骤：
找到可选的子问题： 首先，将原问题拆分成一系列可选的子问题或决策。
找到局部最优解： 对每个子问题，找到一个局部最优解。这个局部最优解应该是一个贪心选择，即在当前状态下选择最优的方式。
合并子问题的解： 将各个子问题的局部最优解合并起来，得到原问题的解。
检查解的有效性： 最后，检查得到的解是否满足问题的约束和要求。如果满足，就认为得到了问题的解。
贪心算法适用于一些特定类型的问题，通常要求问题具有贪心选择性质（即每一步的选择都是最优的），以及最优子结构性质（即问题的最优解可以通过子问题的最优解推导得出）。然而，贪心算法不一定能够求解所有问题，有些问题可能需要更复杂的算法来解决。
经典的贪心算法问题有找零钱问题、活动选择问题、背包问题中的部分背包等。贪心算法在求解这些问题时，通常能够得到接近最优解的结果，但并不保证一定能够得到全局最优解。
总之，贪心算法是一种基于每一步的局部最优选择来求解问题的思想，适用于一些满足贪心选择性质和最优子结构性质的问题。
一）概念 贪心算法（Greedy Alogorithm）又叫登山算法，它的根本思想是逐步到达山顶，即逐步获得最优解，是解决最优化问题时的一种简单但是适用范围有限的策略。
贪心算法没有固定的框架，算法设计的关键是贪婪策略的选择。贪心策略要无后向性，也就是说某状态以后的过程不会影响以前的状态，只与当前状态有关。
贪心算法是对某些求解最优解问题的最简单、最迅速的技术。某些问题的最优解可以通过一系列的最优的选择即贪心选择来达到。但局部最优并不总能获得整体最优解，但通常能获得近似最优解。
在每一步贪心选择中，只考虑当前对自己最有利的选择，而不去考虑在后面看来这种选择是否合理。
二）找出全局最优解的要求 在遇见问题时如何确定是否可以使用贪心算法解决问题，那么决定一个贪心算法是否能找到全局最优解的条件是什么呢？其实就是以下两点：
最优子结构（optimal subproblem structure,和动态规划中的是一个概念）最优贪心选择属性（optimal greedy choice property） 三）求解时应考虑的问题 1.候选集合S
为了构造问题的解决方案，有一个候选集合C作为问题的可能解，问题的最终解均取自于候选集合C。
2.解集合S
随着贪心选择的进行，解集合不断扩展，直到构成一个满足问题的完整解。
3.解决函数solution
检查解集合是否构成问题的完整解。
4.选择函数select
即贪心策略，这是贪心算法的关键，它指出哪个候选对象有希望构成成问题的解。
5.可行函数feasible
检查解集合中加入一个候选对象是否可行，即解集合扩展后是否满足约束条件。
四）基本步骤 贪心算法使用基本步骤：
1.从问题的某个初始解出发
2.采用循环语句，当可以向求解目标前进一步时，就根据局部最优策略，得到一个部分解，缩小问题的范围或规模。
3.将所有的部分解综合起来，得到问题的最终解。
五）贪心策略选择 贪心算法的原理是通过局部最优来达到全局最优，采用的是逐步构造最优解的方法。在每个阶段，都做出一个看上去最优的，决策一旦做出，就不再更改。
要选出最优解可不是一件容易的事，要证明局部最优为全局最优，要进行数学证明，否则就不能说明为全局最优。
很多问题表面上看来用贪心算法可以找到最优解，实际上却把最优解给漏掉了。这就像现实生活中的“贪小便宜吃大亏”。所以我们在解决问题的时候，一定要谨慎使用贪心算法，一定要注意这个问题适不适合采用贪心算法。
贪心算法很多时候并不能达到全局最优，为什么我们还要使用它呢？
因为在很多大规模问题中，寻找最优解是一件相当费时耗力的事情，有时候付出大量人力物力财力后，回报并不与投入成正比。在这个时候选择相对最优的贪心算法就比较经济可行了。有的问题对最优的要求不是很高，在充分衡量付出和回报后，选择贪心算法未尝不是一种不错的选择呢。
六）实际应用 1.零钱找回问题 这个问题在我们的日常生活中就更加普遍了。假设1元、2元、5元、10元、20元、50元、100元的纸币分别有c0, c1, c2, c3, c4, c5, c6张。现在要用这些钱来支付K元，至少要用多少张纸币？用贪心算法的思想，很显然，每一步尽可能用面值大的纸币即可。在日常生活中我们自然而然也是这么做的。在程序中已经事先将Value按照从小到大的顺序排好。
下面展示一些 内联代码片。 #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; const int N=7; int Count[N]={3,0,2,1,0,3,5}; int Value[N]={1,2,5,10,20,50,100}; int solve(int money) { int num=0; for(int i=N-1;i&gt;=0;i--) { int c=min(money/Value[i],Count[i]); money=money-c*Value[i]; num+=c; } if(money&gt;0) num=-1; return num; } int main() { int money; cin&gt;&gt;money; int res=solve(money); if(res!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34b2cdae9beb9a5b6cbb85e1d30259e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49a4eeb8378244c3c4ca144a54e993e6/" rel="bookmark">
			吊炸天的 Kafka 图形化工具 Eagle，必须推荐给你！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 Kafka是当下非常流行的消息中间件，据官网透露，已有成千上万的公司在使用它。最近实践了一波Kafka，确实很好很强大。今天我们来从三个方面学习下Kafka：Kafaka在Linux下的安装，Kafka的可视化工具，Kafka和SpringBoot结合使用。希望大家看完后能快速入门Kafka，掌握这个流行的消息中间件！
Kafka简介 Kafka是由LinkedIn公司开发的一款开源分布式消息流平台，由Scala和Java编写。主要作用是为处理实时数据提供一个统一、高吞吐、低延迟的平台，其本质是基于发布订阅模式的消息引擎系统。
Kafka具有以下特性：
高吞吐、低延迟：Kafka收发消息非常快，使用集群处理消息延迟可低至2ms。高扩展性：Kafka可以弹性地扩展和收缩，可以扩展到上千个broker，数十万个partition，每天处理数万亿条消息。永久存储：Kafka可以将数据安全地存储在分布式的，持久的，容错的群集中。高可用性：Kafka在可用区上可以有效地扩展群集，某个节点宕机，集群照样能够正常工作。 Kafka安装 我们将采用Linux下的安装方式，安装环境为CentOS 7.6。此处没有采用Docker来安装部署，个人感觉直接安装更简单（主要是官方没提供Docker镜像）！
首先我们需要下载Kafka的安装包，下载地址：mirrors.bfsu.edu.cn/apache/kafk… 下载完成后将Kafka解压到指定目录： bash复制代码cd /mydata/kafka/ tar -xzf kafka_2.13-2.8.0.tgz 解压完成后进入到解压目录： bash 复制代码cd kafka_2.13-2.8.0 虽然有消息称Kafka即将移除Zookeeper，但是在Kafka最新版本中尚未移除，所以启动Kafka前还是需要先启动Zookeeper； 启动Zookeeper服务，服务将运行在2181端口； bash复制代码# 后台运行服务，并把日志输出到当前文件夹下的zookeeper-out.file文件中 nohup bin/zookeeper-server-start.sh config/zookeeper.properties &gt; zookeeper-out.file 2&gt;&amp;1 &amp; 由于目前Kafka是部署在Linux服务器上的，外网如果想要访问，需要修改Kafka的配置文件config/server.properties，修改下Kafka的监听地址，否则会无法连接； properties复制代码############################# Socket Server Settings ############################# # The address the socket server listens on. It will get the value returned from # java.net.InetAddress.getCanonicalHostName() if not configured. # FORMAT: # listeners = listener_name://host_name:port # EXAMPLE: # listeners = PLAINTEXT://your.host.name:9092 listeners=PLAINTEXT://192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49a4eeb8378244c3c4ca144a54e993e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f72a3807f95e09fc3c7bc7c0da9bb94a/" rel="bookmark">
			R语言系列1——R语言基础：入门篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 写在开头：1. R语言的基本语法1.1 变量与数据类型1.2 基本操作符与表达式 2. 数据结构简介2.1 向量(Vector)2.2 矩阵(Matrix)2.3 数组(Array)2.4 数据框(Data Frame)2.5 列表(List) 3. 基础函数与包的使用3.1 常用内置函数3.2 安装与加载R包3.2.1 安装R包3.2.2 加载R包 写在最后 写在开头： R语言，作为一种统计分析和图形表示的强大工具，自20世纪90年代初问世以来，已广泛应用于数据分析、生物信息学、统计学习以及金融领域等多个方面。它不仅拥有强大的数据处理能力，还拥有丰富的包库支持，能够满足各种统计分析的需求。
安装R及RStudio的基础教程
安装R语言环境的第一步是前往R官方网站下载适合您操作系统的R版本并安装。接下来，为了提高编程效率，安装RStudio，这是一个优秀的R语言集成开发环境（IDE）。RStudio的安装包可在RStudio官方网站下载。
1. R语言的基本语法 1.1 变量与数据类型 变量与数据类型详解
在R语言中，变量就像是用来存储信息的小盒子。你可以在这些小盒子里放入数字、文字或者其他类型的数据，然后在需要的时候取出来使用。给变量赋值，就是把数据放进这个小盒子里。在R语言中，我们通常使用&lt;-这个符号来赋值，比如x &lt;- 10，就是把数字10放入名为x的盒子里。
数据类型
在R语言的世界里，数据有多种不同的形态，我们称之为数据类型。了解这些数据类型对于使用R语言进行有效的数据分析至关重要。主要的数据类型包括：
数值型：这是最常见的数据类型，用来存储数字。比如，age &lt;- 30就是将30这个数字，作为年龄存储在age变量中。
字符串：用于存储文本或字符序列。如果你想在R语言中存储一个人的名字，你可以使用字符串类型，如name &lt;- "张三"。
逻辑型：这种类型只有两个可能的值，TRUE（真）或FALSE（假）。逻辑型变量非常适合用来存储判断结果，比如is_student &lt;- TRUE表示某人是学生。
复数型：用于存储复数，即包含实部和虚部的数。在R中，可以用z &lt;- 1+4i来创建一个复数。
因子类型：因子是处理分类数据的专用类型，非常适合表示有限数量的类别，如性别、评级等。如果你有一个变量记录人们的血型，你可以用因子类型来存储，比如blood_type &lt;- factor(c("A", "B", "O", "AB"))。因子类型对于进行统计分析尤其重要，因为它们让R知道数据是分类的，从而选择合适的分析方法。
日期和时间：R语言通过Date和POSIXt类处理日期和时间数据。这对于时间序列分析、事件历史分析等领域至关重要。例如，Sys.Date()函数返回当前日期，而as.Date("2023-01-01")将字符串转换为日期对象。
为什么要区分数据类型？
你可能会好奇，为什么我们不能简单地把所有的数据都当作同一类型来处理呢？这是因为不同类型的数据在计算和分析时，背后的逻辑是完全不同的。例如，你可以对数值型数据进行加减乘除等数学运算，但是对于字符串来说，"+"可能意味着将两个字符串拼接在一起。同时，知道数据的类型可以帮助R语言更高效地存储和处理数据，以及做出正确的数据处理决策。
1.2 基本操作符与表达式 在R语言中，操作符和表达式是用来处理和操作数据的基本工具。想象一下，如果变量是盛放数据的容器，那么操作符就像是用来加工数据的工具，而表达式则是具体的加工过程。
基本操作符
操作符在R语言中扮演着重要的角色，主要分为以下几类：
算术操作符：这些操作符用于执行基本的数学运算，比如加(+)、减(-)、乘(*)、除(/)、求余数(%%)、整除(%/%)和幂(^)。例如，3 + 4的结果是7，8 / 2的结果是4。
比较操作符：这类操作符用来比较两个值的大小或相等性，包括小于(&lt;)、大于(&gt;)、小于等于(&lt;=)、大于等于(&gt;=)、等于(==)和不等于(!=)。比如，表达式5 &gt; 3的结果是TRUE，因为5确实大于3。
逻辑操作符：用于逻辑运算，主要有逻辑与(&amp;)、逻辑或(|)和逻辑非(!)。逻辑操作符经常用在条件测试中，比如TRUE &amp; FALSE的结果是FALSE，!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f72a3807f95e09fc3c7bc7c0da9bb94a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/481/">«</a>
	<span class="pagination__item pagination__item--current">482/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/483/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>