<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4773f6b334b72565487b0a34aef9f96/" rel="bookmark">
			Stable Diffusion1.5网络结构-超详细原创
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 Unet
1.0 介绍　1.1详细整体结构
1.2 缩小版整体结构
1.3 时间步编码
1.4 CrossAttnDownBlock2D
1.4.1 ResnetBlock2D
1.4.2 Transformer2DModel
1.4.2.1 BasicTransformerBlock
1.4.2.1.1 SelfAttention
1.4.2.1.2 CrossAttention
1.4.2.1.3 FeedForward
1.4.3 DownSample2D
1.5 DownBlock2D
1.6 UnetMidBlock2DCrossAttn
1.7 UpBlock2D
1.7.1 UpSample2D
1.8 CrossAttnUpBlock2D
2 VAE
2.0 介绍
2.1 AE
2.2 VAE
2.3 整体结构 2.4 DownEncoderBlock2D
2.4.1 ResnetBlock2D
2.4.2 UpSample2D
2.5 UnetMidBlock2D
2.6 Sample
2.7 UpDecoderBlock2D
2.7.1 UpSample2D
3 CLIP
3.1 CLIPTextEmbeddings
3.2 CLIPEncoderLayer
绘制软件：ProcessOn，以下图片保存可高清查看
1 Unet 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4773f6b334b72565487b0a34aef9f96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/817e6627271658dd71149a1c25b7b6ba/" rel="bookmark">
			【腾讯云 HAI域探秘】——即时职场生存指南小游戏以及【自行搭建Stable Diffusion图片AI绘制 | ChatGLM2-6B AI进行智能对话 | Pytorch2.0 AI框架视频处理】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用HAI的ChatGLM2 6B做一个即时对话小游戏 ChatGLM2-6B 是开源中英双语对话模型 ChatGLM-6B 的第二代版本，在保留了初代模型对话流畅、部署门槛较低等众多优秀特性的基础之上，ChatGLM2-6B 引入了更强大的性能、更长的上下文、更高效的推理，所以用来做个小游戏非常的合适了。
我基本没有做什么语句优化，直接给了，并且能看到回复的情况，相当可以的呢。接下来我们使用ChatGLM2 6B返回的结果来做个适合大学生们学习的职场即时对话类游戏。 游戏框架概述 在大学中，我们能学到有限的知识，但是我们要步入社会，想要在短时间内能站稳跟脚绝对是一件很难的事情，那么，我们就可以通过我们这款小游戏来历练我们的对话能力。
【腾讯云 HAI域探秘】——即时职场生存指南小游戏
游戏接口的用语，可以自己尝试，挺好的。
目标：生成领导与员工的对话语句，来考验员工的职场适应能力。
1、信息1领导提问员工一个问题；
2、信息2是普通员工的回答方式；
3、信息3是优秀员工的回答方式；
4、信息4是领导对信息2普通员工的回复并告知回错误，给予一定的错误惩罚；
5、信息5是领导对信息3优秀员工的回复并告知回正确，给予一定的奖励话语。
6、仅生成以上5条信息，每条信息长度不超过50个字。
7、对话中不能有不文明用语。
这里用到了Stable Diffusion来创建AI图片使游戏变得更加有意思。
例如，下图就是游戏页面，老板生成的时候我写的：
翻译完成后到【Stable Diffusion】里面生成就行，注意反向用语我写的：【(semi-realistic, cgi, 3d, render, sketch, cartoon, drawing, anime:1.1)close up】，反向用词很多我再下面的SD中有说明。
开启ChatGLM2 6B的服务，下面有对应操作。这里建议选用高性能的服务。不然可能起不来。
成功示例： 有了这个就代表我们有接口了。
先返回到腾讯云，搜索一下Cloud Studio创建一个空项目
创建空项目
编码：
编码完成后就能运行了哦，网页单独的使用【python -m http.server】来启动，不启动无法访问的哦。
自带的内置浏览器访问不效果不如单独打开的，我们可以进行测试以下。
目录
利用HAI的ChatGLM2 6B做一个即时对话小游戏
游戏框架概述
自行搭建Stable Diffusion模型服务用于生成AI图片
一、服务创建
1、服务地址：
2、等待审核(大概24小时)
二、创建服务
1、新建服务
2、选择AI模型：Stable Diffusion
3、等待创建(5~8分钟）
三、操作面板介绍
1、webui操作
2、jupyter_lab操作
四、webui操作步骤
1、中文插件安装
2、配置中文插件操作步骤
3、Reload UI后效果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/817e6627271658dd71149a1c25b7b6ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/743afd159ea91b09d497a431b94a9b61/" rel="bookmark">
			数据结构之双向带头循环链表函数功能实现与详细解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人主页：点我进入主页
专栏分类：C语言初阶 C语言程序设计————KTV C语言小游戏 C语言进阶
C语言刷题 数据结构初阶
欢迎大家点赞，评论，收藏。
一起努力，一起奔赴大厂。
目录
1.前言
2.带头双向循环链表函数实现
3.总结
1.前言 在前面我们写过单链表，循环链表的博客，今天我主要给大家来带关于双向带头循环链表函数的功能与实现，双向带头循环链表相对于单链表，循环链表非常的容易实现，他的函数的功能和 单链表，循环链表一样，如果你想要快速实现一个链表的所有功能，带头双向循环链表非常的容易，接下来让我们看看带头双向链表的奥妙把，看完你绝对会佩服写出这种结构的人。
2.带头双向循环链表函数实现 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include &lt;assert.h&gt; typedef struct ListNode { int data; struct ListNode* prev, * next; }ListNode; ListNode* ListCreate(int x) { ListNode* newnode = (ListNode*)malloc(sizeof(ListNode)); if (newnode == NULL) { perror("malloc"); return NULL; } newnode-&gt;next = NULL; newnode-&gt;prev = NULL; newnode-&gt;data = x; return newnode; } ListNode* LInit() { ListNode* head = ListCreate(-1); head-&gt;next = head; head-&gt;prev = head; return head; } void ListDestory(ListNode* phead) { assert(phead); ListNode* cur = phead-&gt;next, * prev = phead; while (prev !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/743afd159ea91b09d497a431b94a9b61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce45b7d0637825a44bc4f6db5b32dff5/" rel="bookmark">
			消灭前端闪烁魔鬼：Vue中的防抖术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		消灭前端闪烁魔鬼：Vue中的防抖术 前言什么是防抖动防抖的基本原理：防抖的应用场景：a. 输入框输入事件：b. 窗口大小调整事件：c. 按钮点击事件：d. 页面滚动事件： 为什么需要让函数“冷静”一下？ vue防抖动原理如何在vue中防止抖动防抖动的应用场景1. 输入框搜索：2. 窗口大小调整事件：3. 按钮点击事件：4. 滚动事件：5. 用户输入验证： 防抖动vs节流防抖动（Debouncing）：实现示例 节流（Throttling）：区别对比：如何选择： 最佳实践和注意事项 前言 在前端的世界里，用户操作如同一场狂风骤雨，而我们的页面则要顶住这些波澜汹涌的输入。有时候，我们希望页面在用户输入停止后再作出响应，以避免频繁触发操作。这时，Vue的防抖动技术就如同时光隧道一样，将我们带回到宁静的过去。
本篇博客将带你穿越时空，揭开Vue中防抖动的神秘面纱。让我们一同探索这项黑科技，如何让页面更灵敏，用户体验更舒适。
什么是防抖动 防抖（Debouncing） 是一种前端开发中用于控制函数执行频率的技术。它通过将多次连续触发的函数调用合并成一次来减少函数的执行次数。防抖的核心思想是在某个时间段内，只执行一次函数，而忽略在此时间段内的其他触发。
防抖的基本原理： 设置一个定时器： 当函数被调用时，不立即执行，而是等待一段时间。重复调用时重置定时器： 如果在等待时间内再次调用该函数，则取消前一个定时器，并重新设置一个新的定时器。函数执行： 当等待时间结束后，执行函数。 防抖的应用场景： a. 输入框输入事件： 问题： 用户在输入框中连续输入，每次输入都触发搜索请求。解决方案： 使用防抖，等待用户停止输入一段时间后再触发搜索请求，减少不必要的请求次数。 b. 窗口大小调整事件： 问题： 窗口大小调整时，resize事件频繁触发。解决方案： 使用防抖，等待窗口大小稳定后再执行相关操作，提高性能。 c. 按钮点击事件： 问题： 按钮被多次点击，触发频繁的操作。解决方案： 使用防抖，确保在一段时间内只执行一次按钮点击事件的处理函数。 d. 页面滚动事件： 问题： 页面滚动时，scroll事件触发频繁。解决方案： 使用防抖，等待滚动停止后再执行相关操作，提高性能。 为什么需要让函数“冷静”一下？ 性能优化： 防抖可以减少函数的执行次数，从而提高性能。特别是在一些频繁触发的事件中，通过减少函数执行次数，可以降低资源消耗。
减少不必要的网络请求： 在涉及到网络请求的场景，如输入框搜索建议，防抖可以减少不必要的请求，提高用户体验。
避免重复操作： 防抖可以避免用户在短时间内多次触发相同操作，确保只有在合适的时机才执行相应的逻辑。
解决抖动问题： 一些设备或浏览器存在触摸或鼠标的抖动问题，防抖可以用来平滑处理这些抖动输入，使得最终触发的操作更加稳定。
总体来说，防抖是一种有效的策略，通过在一定时间内只执行一次函数，可以更好地控制函数的执行频率，从而在性能和用户体验方面都带来一些优势。
vue防抖动原理 在Vue中，实现防抖的基本原理是利用setTimeout和clearTimeout来控制函数的执行。以下是一个简单的Vue中防抖的实现示例：
// 在Vue组件的methods中定义一个需要防抖的函数 methods: { // 防抖函数 debounceFunction: function() { // 清除之前的定时器 clearTimeout(this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce45b7d0637825a44bc4f6db5b32dff5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d748707b00c89aea3a76d68778089cbc/" rel="bookmark">
			IDEA 搭建 SpringCloud 项目【超详细步骤】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言二、项目搭建1. 数据库准备2. 创建父工程3. 创建注册中心4. 服务注册5. 编写业务代码6. 服务拉取 一、前言 所谓微服务，就是要把整个业务模块拆分成多个各司其职的小模块，做到单一职责原则，不会重复开发相同的业务代码，实现真正意义上的高内聚、低耦合。同时，微服务可以对外暴露接口，供其它微服务使用。
如果我们在 A 服务中发起一个 http 请求到 B 服务，那么就可以实现微服务的远程调用。（restTemplate 的 getForObject 方法可以向浏览器发起请求）
这种方法看起来是可行的，但是把 url 路径和 Java 代码耦合到一起，是不符合开闭原则的。于是就出现了 Eureka 注册中心。
每一个微服务在启动的那一刻都需要做一件事情，就是把自己的服务信息注册给 Eureka，比如服务名称、服务端口等，其它微服务想要调用另一个服务的时候，直接去 Eureka 里面拉取信息就可以了。
同时，为了避免拉取的服务已经挂掉了，我们的服务每隔 30 秒就会向 Eureka 发起一次心跳，来证明自己还活着，如果有一天不跳了，Eureka 就会把它从注册列表中剔除。
如果存在多个服务提供者，服务消费者就会利用负载均衡算法，从服务列表中挑选一个！
二、项目搭建 1. 数据库准备 此处我们要准备两个数据库，user 服务和 order 服务各自拥有自己的数据库。
CREATE TABLE USER ( id INT NOT NULL PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) NOT NULL, phone VARCHAR(15) NOT NULL, address VARCHAR(50) NOT NULL ); INSERT INTO USER VALUES (1, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d748707b00c89aea3a76d68778089cbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8c6116344c77667b5237ee31780a889/" rel="bookmark">
			【算法】最小生成树——普利姆 (Prim) 算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.概述2.代码实现2.1.邻接矩阵存储图2.2.邻接表存储图2.3.测试 3.应用 1.概述 （1）在一给定的无向图 G = (V, E) 中，(u, v) 代表连接顶点 u 与顶点 v 的边，而 w(u, v) 代表此边的权重，若存在 T 为 E 的子集且为无循环图，使得联通所有结点的 w(T) 最小，则此 T 为 G 的最小生成树 (minimal spanning tree)。
（2）普利姆 (Prim) 算法是一种用于解决最小生成树问题的贪心算法，其主要思路如下：
① 选择任意一个顶点作为起始点，将其加入最小生成树中。② 从已选择的顶点集合中选取一个顶点，该顶点与未选择的顶点构成的边权重最小，并且该边的另一端顶点未被选择，将该顶点和边加入最小生成树中。③ 重复步骤 ②，直到最小生成树包含了图中的所有顶点。 （3）例如，对带权连通无向图 G 使用普利姆 (Prim) 算法构造最小生成树的过程如下：
另外一种生成最小生成树的克鲁斯卡尔 (Kruskal) 算法可参考【算法】最小生成树——克鲁斯卡尔 (Kruskal) 算法这篇文章。
2.代码实现 2.1.邻接矩阵存储图 class Solution { // INF 表示两点之间没有连接，即无穷大 int INF = Integer.MAX_VALUE; /* graph: 用于表示图的邻接矩阵 返回值: 路径矩阵 */ public int prim(int[][] graph) { //图中的顶点数 int V = graph.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8c6116344c77667b5237ee31780a889/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/950332c1b6da3862c82f1399241e379e/" rel="bookmark">
			小程序绑定跳转视频号的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、跳转方式
小程序绑定视频号需要用户打开视频号助手channels.weixin.qq.com，复制视频号ID username，和需要绑定的视频ID feedId，两者缺一不可。
关键代码：
wx.openChannelsActivity({ finderUserName: this.data.finderUserName, feedId: this.data.feedId, fail(error) { console.log(error) } }) 二、内嵌视频号视频
从基础库版本2.25.1至2.31.1，小程序需与视频号视频相同主体或关联主体从基础库版本2.31.1开始，非个人主体小程序可内嵌非同主体/关联主体视频号视频 //需要视频id和视频号id，使用wx:if是因为不做组件销毁的话，会先报该视频无法加载在正常显示 //item--是我们需要的视频数据，根据个人情况来定 &lt;channel-video style="width:100%;height:100vh;" wx:if="{{ item }}" muted="{{ false }}" object-fit="{{ contain }}" autoplay="{{ true }}" feed-id="{{ item.videoId }}" finder-user-name="{{ item.videoAccountsId }}"&gt;&lt;/channel-video&gt; 获取feed-token步骤如下：
登陆MP平台，在「设置-基本设置-隐私与安全」找到「获取视频号视频ID权限」，并将开关打开（24小时后自动关闭）
移动端找到想要内嵌的视频号视频，并复制该视频的feed-token，图示如下：
三、跳转到视频号主页（必须是同主体）
wx.openChannelsUserProfile({ finderUserName: '' //视频号id }) 但是笔者认为这三种方式用户体验都还是有点欠缺，最好是可以让用户自己来绑定跳转到视频号并选择单个视频绑定，操作上更为简单人性化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e6d978d654508abb062e01fe2b4f30f/" rel="bookmark">
			mac菜单栏无法显示cla*sh*x
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载图标管理工具batender5
官网进行下载
bartender
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c220befb487f2d2c4d42a2a4286a5509/" rel="bookmark">
			【入门篇】1.4 redis 客户端 之 Lettuce 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 简介1. 什么是Lettuce2. Lettuce与其他Redis客户端的比较3. Lettuce的特性和优势 2. 安装和配置3. 连接池配置1. 什么是连接池2. Lettuce的连接池使用与配置3. 连接池配置项 4. 基本操作1. 如何创建Lettuce连接2. Lettuce的基本操作如增删改查3. Lettuce的事务操作4. Lettuce的管道操作5. Lettuce的发布订阅操作6. Lettuce的脚本执行 5. 错误处理和重试6. Lettuce vs Jedis7. 参考资料 1. 简介 1. 什么是Lettuce Lettuce是一个高级Redis客户端，用于线程安全的同步、异步和反应式访问。它支持高级的Redis特性，如Sentinel、集群、流水线、自动重新连接和redis数据模型等。Lettuce是完全非阻塞的，基于Netty事件驱动的通信层，其方法将返回具有可观察的类型，可在流或异步编程环境中使用。
2. Lettuce与其他Redis客户端的比较 与Jedis这种阻塞的Java Redis客户端相比，Lettuce的主要优势在于其完全非阻塞的IO和线程安全。使用Jedis，在多线程环境中，需要使用连接池以避免线程安全问题，但是对于Lettuce来说，可以避免这种复杂的设置，因为一个Lettuce连接实例（StatefulRedisConnection）就是线程安全的。另一个重要的区别是，Lettuce支持Redis的高级特性，如集群、流水线、发布订阅、和Lua脚本。
3. Lettuce的特性和优势 完全非阻塞IO和线程安全：Lettuce使用Netty进行网络通信，采用了异步和事件驱动的模型。一个Lettuce连接实例（StatefulRedisConnection）是线程安全的，可以在多个线程间共享。支持Redis的高级特性：Lettuce支持Redis的高级特性，如Sentinel、集群、流水线、发布订阅、Lua脚本等。自动重连：Lettuce支持自动重连，当Redis服务器重新启动或断开连接时，Lettuce可以自动恢复连接。可观察的数据类型：Lettuce的所有操作都返回Observable，这可以让在流或异步编程环境中使用。 2. 安装和配置 在Java项目中，可以使用Maven或者Gradle来引入Lettuce的依赖。
使用Maven引入依赖 &lt;dependency&gt; &lt;groupId&gt;io.lettuce&lt;/groupId&gt; &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt; &lt;version&gt;6.1.5.RELEASE&lt;/version&gt; &lt;!-- 请将此版本号替换为所需要的版本 --&gt; &lt;/dependency&gt; 使用Gradle引入依赖 dependencies { implementation 'io.lettuce:lettuce-core:6.1.5.RELEASE' } 配置Lettuce非常简单
创建一个新的RedisClient实例，使用redis://password@localhost:6379/0作为Redis服务器的URL。然后我们打开一个新的连接，并通过此连接获取同步命令来执行Redis命令。执行完命令后，我们关闭了连接并关闭了Redis客户端。
import io.lettuce.core.RedisClient; import io.lettuce.core.api.StatefulRedisConnection; import io.lettuce.core.api.sync.RedisCommands; public class Example { public static void main(String[] args) { // 初始化Redis客户端 RedisClient redisClient = RedisClient.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c220befb487f2d2c4d42a2a4286a5509/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d79fd46354b152cce31c9e21ae028c6/" rel="bookmark">
			JavaScript-实现图片的下载(本地图片，远程图片，多个下载)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、主要步骤
二、本地下载
三、远程下载
四、多个下载
一、主要步骤 主要通过&lt;a/&gt;标签来实现，将要下载的文件链接设置为href属性，将文件名设置为download属性，然后模拟点击这个链接即可触发下载。
本文简单例举了几种下载方式，只是完成下载的任务，具体细节和精确控制还请查看官方文档。
二、本地下载 1.本地比较简单，可以直接使用 a 标签
最简单的方式是： herf为图片路径，download为设置下载文件名字
&lt;a href="图片的路径" download="img.jpg"&gt;下载&lt;/a&gt; 如果不想让 a 标签显示出来，可以创建隐藏的a标签，通过其他点击事件去触发下载： (这里 download() 函数 return 一个function是因为需要在 addEventListener 的回调函数里传递参数)
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;点击下载&lt;/button&gt; &lt;script&gt; // 获取button标签 const bt = document.querySelector('button') // 给button添加点击事件 注意这里换成自己的路径 bt.addEventListener('click',download('/1695208099339.jpg','img.jpg')) function download(url,fileName){ return function(){ // 创建a标签 var link = document.createElement('a'); // 设置a标签为不可见 link.style.display = 'none'; // 将a标签添加到body document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d79fd46354b152cce31c9e21ae028c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2b961edaebc8513d1e4c19cf692de36/" rel="bookmark">
			JDK21下载&#43;安装&#43;环境配置教程(Windows系统)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：甲骨文公司与2023.9发布JDK21,JDK21将是一个长期支持（LTS）版本，JDK20目前可以从官网下载使用。
1，搜索Oracle官网找到JDK21
Java Downloads | Oracle
2，切换Windows系统，然后点击下载（初学者下载X64 Installer就可）
3，下载完成后点击安装向导（本贴选择放在D盘目录下）
4，配置JDK的环境变量，开始-&gt;设置-&gt;系统-&gt;关于-&gt;高级系统设置-&gt;环境变量（本帖以win10为例）
5，点击新建系统变量名为"JAVA_HOME"，变量值为"%JDK-21%"，此处可以配置多个JDK版本用于以后的开发需求，切换JDK版本时更改"JAVA_HOME"的变量值即可快速切换。
6，再次新建系统变量名为"JDK-21"，变量值指定路径为"D:\jdk-21"(第三步中解压后存放jdk-21的路径)
设置成功后点击确定
7，点击新建系统变量名为"CLASSPATH"，变量值为".;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;%JAVA_HOME%\lib;"
设置成功后点击确定
8，在系统变量中找到Path变量点击进行编辑
9，点击新建输入"%JAVA_HOME%\bin"，并将其上移到最上方后确定保存（操作如下）
10，开始测试JDK21是否安装成功，打开jdk-21的安装目录，选中资源路径并输入"cmd"打开命令窗口，
11，输入"java"，点击回车，输入"java -version"，点击回车出现JDK20的版本信息则表示JDK已经安装成功，如下：
11，（有基础的可以试试）用记事本编辑一个简单的java文件进行编译输出
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63dc3eec8534bf8cb0e00e35063fb7f2/" rel="bookmark">
			Java 算法篇-链表的经典算法：有序链表去重、合并多个有序链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥博客主页： 【小扳_-CSDN博客】
❤感谢大家点赞👍收藏⭐评论✍ 文章目录
1.0 链表的说明
2.0 有序链表去重的实现方式
2.1 有序链表去重(保留重复的节点) - 使用递归来实现
2.2 有序链表去重(保留重复的节点) - 使用双指针来实现
2.3 有序链表去重(不保留重复的节点) - 使用递归来实现
2.4 有序链表去重(不保留重复的节点) - 使用三指针来实现
3.0 合并升序链表
3.1 合并升序链表(两个链表) - 迭代法
3.2 合并升序链表(两个链表) - 递归法
3.3 合并多个升序链表
4.0 实现有序链表去重、合并升序链表的完整代码
1.0 链表的说明 为了更好的讲解本篇当中的两种经典算法，先创建一个带哨兵的链表。链表是一种常见的数据结构，用于存储一系列元素。链表由一系列节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针。
代码如下：
import java.util.Iterator; public class List implements Iterable&lt;Integer&gt;{ private Node sentry; static class Node { public int value; public Node next; public Node(int value, Node next) { this.value = value; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63dc3eec8534bf8cb0e00e35063fb7f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d2d9d398160fddf4ea06f08bec2f1e4/" rel="bookmark">
			【cpolar】Ubuntu本地快速搭建web小游戏网站，公网用户远程访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎥 个人主页：深鱼~🔥收录专栏：cpolar🌄欢迎 👍点赞✍评论⭐收藏 目录
前言
1. 本地环境服务搭建
2. 局域网测试访问
3. 内网穿透
3.1 ubuntu本地安装cpolar
3.2 创建隧道
3.3 测试公网访问
4. 配置固定二级子域名
4.1 保留一个二级子域名
4.2 配置二级子域名
4.3 测试访问公网固定二级子域名
前言 网：我们通常说的是互联网；站：可以理解成在互联网上的一个房子。把互联网看做一个城市，城市里面的每一个房子就是一个站点，房子里面放着你的资源，那如果有人想要访问你房子里面的东西怎么办？
在现实生活中，去别人家首先要知道别人的地址，某某区某某街道，几号，在互联网中也有地址的概念，就是ip。通过ip我们就能找到在互联网上面的站点，端口可以看做是这个房子的入口，不同的入口所看到的东西也就不一样，如从大门(80端口)进是客厅，从窗户(8080端口)进是书房。
接下来我们将通过简单几步来在ubuntu搭建一个web站点 html小游戏，并使用cpolar内网穿透将其发布到公网上，使得公网用户也可以正常访问到本地web站点的小游戏。
1. 本地环境服务搭建 apach2是一个服务,也可以看做一个容器,也就是上面说的房子,运行在ubuntu里,这个服务可以帮助我们把我们自己的网站页面通过相应的端口让除本机以外的其他电脑访问。
下载apach2
sudo apt install apache2 php -y 下载好后启动apache2
sudo service apache2 restart 然后打开Ubuntu 浏览器,输入:http://localhost 即可看到我们apache 默认的页面,此时说明本地站点已经搭建好了。
然后打开Ubuntu 浏览器,输入:http://localhost 即可看到我们apache 默认的页面,此时说明本地站点已经搭建好了。
进入Apache默认服务器主目录路径,这个目录放的是想要让别人看到的资源,如一张图片,一个html页面等
cd /var/www/html 进入后删掉index.html这个文件,由于apache默认页面并不是我们自己想要的页面,我们想要换成自己喜欢的页面,所以需要删掉.执行以下命令:
sudo rm -rf index.html 为了达到测试效果,我们设置一个html页面小游戏,创建名称为game.html的页面
sudo vim game.html 按i键 进入编辑模式,复制以下html代码进去(复制全部)
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;&lt;h4&gt;Take it Easy!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d2d9d398160fddf4ea06f08bec2f1e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc5e8f0e38f0f6c06ab597f552a32866/" rel="bookmark">
			选择最好的 Python 开发环境？15个Python IDE推荐！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1\. PyCharm2\. Visual Studio Code3\. Sublime Text4\. VI/Vim5\. GNU Emacs6\. IDLE7\. Atom8\. Spyder9\. JuPyter/IPython Notebook10\. Eclipse + PyDev11\. Eric Python12\. Wing13\. PyScripter14\. Pyzo15\. Thonny结论关于Python技术储备一、Python所有方向的学习路线二、Python基础学习视频三、精品Python学习书籍四、Python工具包+项目源码合集①Python工具包②Python实战案例③Python小游戏源码五、面试资料六、Python兼职渠道 前言 本文介绍了多个 Python IDE，并评价其优缺点。读者可以参考此文列举的 Python IDE 列表，选择适合自己的编辑器。
写 Python 代码最好的方式莫过于使用集成开发环境（IDE）了。它们不仅能使你的工作更加简单、更具逻辑性，还能够提升编程体验和效率。
每个人都知道这一点。而问题在于，如何从众多选项中选择最好的 Python 开发环境。初级开发者往往面临这个问题。
本文将概述最受程序员欢迎的 Python IDE，以及其他值得考虑的选项。在此之前，我们先来看看 IDE 是什么。
什么是 IDE？IDE 有什么用？
IDE 是开发者创建程序时使用的软件包。它通过简单的用户界面集成多个高度关联的组件，从而最大化程序员的生产效率。本质上，IDE 是一种改进代码创建、测试和 debug 流程的工具，它使这些工作更加简单。
IDE 使用的工具包括：
文本编辑器编译器和/或解释器装配自动化工具（assembly automation tool）调试器（debugger） 有一个与 IDE 相似的术语——代码编辑器（code editor）。我们先来探讨二者的异同。
什么是代码编辑器？
代码编辑器是一个能够突出显示语法和安排代码版式的文本编辑器。高级代码编辑器可以开发和修改代码。
IDE 和代码编辑器的显著特征
IDE 和代码编辑器有哪些共同优点？它们均可帮助开发者：
存储和重新打开脚本运行代码debug突出显示语法 最受 Python 开发者欢迎的 IDE
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc5e8f0e38f0f6c06ab597f552a32866/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2d51513e747d9a0ea64c4525ba55ec7/" rel="bookmark">
			Java SpringBoot项目 &#43; GraphHopper 实现地图多途径点离线路径规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关键词：高德地图、离线地图、离线路径规划、多途径点、JAVA、SpringBoot、GraphHopper、OpenStreetMap
目录
效果预览
使用OpenStreetMap（OSM）下载地图路网资源
使用GraphHopper实现多途径点路径规划
具体实现代码
高德地图内网部署请参考我之前的文章，传送门：高德地图离线加载解决方案（内网部署）+本地地图瓦片加载_高德地图离线瓦片_深海的鲸同学 luvi的博客-CSDN博客
完整项目Demo已提交至Gitee仓库，传送门：离线路径规划: Java SpringBoot项目使用GraphHopper实现多途径点路径规划
效果预览 使用OpenStreetMap（OSM）下载地图路网资源 https://www.openstreetmap.org/进入osm官网：https://www.openstreetmap.org/
数据下载窗口如下所示，其中上半部分为研究区域选择界面，下半部分则为多种数据下载方式的选择界面。
我们可以通过拉动屏幕所显示的地图范围或直接在下图所示框内修改经、纬度的方式，对研究区域加以选择，此外，还可以点击经、纬度框下方的蓝色文字，通过手动划定矩形区域的方式选择研究区域范围
范围选定后，我们可以直接点击屏幕左侧的“Export”按钮导出数据；但需要注意，在研究区域过大时，这一方法将会失效，需要自行探索最大范围进行下载。
此处下载的地图路网资源后缀为 .oem 的文件
如果需要全国路网图，你们又找不到在哪下载的话评论区留下邮箱，我发过去，文件1g。路网资源过大，对电脑的性能要求也是非常高的，所以小项目或指定区域内不建议使用全国路网
使用GraphHopper实现多途径点路径规划 SpringBoot项目，首先安装如下依赖
&lt;dependency&gt; &lt;groupId&gt;com.graphhopper&lt;/groupId&gt; &lt;artifactId&gt;graphhopper-core&lt;/artifactId&gt; &lt;version&gt;4.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.fastjson2&lt;/groupId&gt; &lt;artifactId&gt;fastjson2&lt;/artifactId&gt; &lt;version&gt;2.0.34&lt;/version&gt; &lt;/dependency&gt; GraphHopper我没有进行太多了解，与这个相关的文章较少，未发现多途径点路径规划的相关介绍（如有相关的实践经验希望在评论区留下相关使用方式或文档），但是可以通过其他方式实现多途径点问题
[[94.88686342315677,36.408548095275435],[94.91853494720462,36.40633760017791],[94.90291376190189,36.40088017112323]] 多途径点的格式如上，二维数组，我们可以将数组中每每两项组合作为 起点 与 终点 分别进行路径规划，并对所有的规划结果利用JSONArray保存，最终返回多点的规划结果。
具体实现代码如下： @PostMapping("/way") public static JSONObject list(@RequestBody Point point) throws FileNotFoundException { GraphHopper hopper = new GraphHopper(); // OSM 文件路径 hopper.setOSMFile("E:\\osm\\gem.osm"); // 读取完OSM数据之后会构建路线图，此处配置图的存储路径 hopper.setGraphHopperLocation("resources"); // 支持car、bike、foot三种交通方式的导航 hopper.setProfiles(new Profile("car").setWeighting("fastest").setTurnCosts(false)); //设置汽车 hopper.getCHPreparationHandler().setCHProfiles(new CHProfile("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2d51513e747d9a0ea64c4525ba55ec7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26dadc6dbf823e16775e303d23fa257e/" rel="bookmark">
			DOA估计算法——Capon算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.波速形成基本思想 在理解Capon算法之前，我们有必要先了解波束形成的基本思想以及原理到底是什么。这有助于我们更好的理解Capon算法的思想。
图 1 如图1展示了均匀阵列波束导向的示意图。图中wm表示加权值，波速形成(DBF)的基本思想就是将各阵元输出进行加权求和，在一定时间内将天线阵列“导向”到一个方向上，对期望信号得到最大输出功率的导向位置，同时这个位置也表征了目标或波达方向。
此外，DBF的基本原理简单来说，就是利用阵元直接相干叠加而获得输出，其缺点在于只有垂直于阵列平面方向的入射波在阵列输出端才能同相叠加，从而形成方向图中主瓣的极大值。反过来说，如果阵列可以围绕它的中心轴旋转，那么当阵列输出最大时，空间波必然由垂直于阵列平面的方向入射而来。但有些天线阵列是很庞大的，且是不能转动的。因此，设法设计一种相控天线法(或称常规波束形成法)，这是最早出现的阵列信号处理方法。这种方法中，阵列输出选取一个合适的加权向量以补偿各个阵元的传播延时，从而使在某一期望方向上阵列输出可以同相叠加，进而使阵列在该方向上产生一个主瓣波束，而对其他方向上产生较小的响应，用这种方法对整个空间进行波束扫描就可确定空中待测信号的方位。因此，计算权值wm是波束形成这类方法的关键，目前DBF权重主要基于以下准则进行计算：
最大信噪比准则(MSNR)：使期望信号分量功率与噪声分量功率之比最大，但是必须知道噪声的统计量和期望信号的波达方向。最大信干噪比准则(MSINR)：使期望信号功率与干扰功率及噪声分量功率之和的比最大。最小均方误差准则(MMSE)：在非雷达应用中，阵列协方差矩阵中通常都含有期望信号，基于此种情况提出的准则。使得阵列输出与某期望响应的均方误差最小，不需要知道期望信号的波达方向。最大似然比准则(MLH)：在对有用信号完全先验未知的情况下，参考信号无法设置，因此，在干扰噪声背景下，首先要取得对有用信号的最大似然估计。线性约束最小方差准则(LCMV)：对有用信号形式和来向完全已知，在某种约束条件下使阵列输出的方差最小。 2.Capon算法 Capon算法属于一种在线性约束最小方差准则(LCMV)下的波束形成算法，所谓波束形成即在某些准则约束下，求解阵列输出的最优权。实质上波束形成属于一种空域滤波器。波束形成的“导向”作用是通过调整加权系数完成的,阵列的输出是对各阵元的接收信号量x(n)在 各阵元上的加权和，令权向量为w,则输出可写作为：
可见对不同的权向量，上式对来自不同方向的信号有不同的响应从而形成不同方向的空间波束。假设空间远场有一个感兴趣的信号d(t) (其波达方向为θd)和J个干扰信号,1,..J((其波达方向为θi),令每个阵元上的加性白噪声为nk(t),它们具有相同的方差。在这些假定的条件下，第k个阵元上的接收信号可以表示为
等式右边的三项分别表示信号，干扰和噪声。假设有M个阵元如果用矩阵的形式表示式(2),则有
其中 ，分别为M个阵元上接收的数据；
表示波达方向来自的方向向量。假设接收端得到了N个快拍数据，则根据式(1)可得到波形形成器的输出的平均功率为：
当式(4)可以表示为：
如上式子所示，输出功率关于波达角的函数通常被称为空间谱。为了保证来自 方向的信号正常接收，同时完全抑制掉其它J个干扰，很容易根据式子(5)得到权向量的约束条件为：
综上所述，我们可以得出Capon算法所要求解的优化问题可以表述为：
可以采用拉格朗日乘子法求解。求解过程如下：
令：
L分别对w和λ求偏导并使各自的偏导数为零，由此可得：
将式(9)中的第二个式子左乘并将第一个式子代入可得 式(10)右乘，可得 于是得
式(12)右乘可得 于是得
将式(14)代入式(12)并取复共轭转置可得：
将式(15)代入式(5)即可得到Capon的空间谱为:
根据式(16)进行谱峰搜索，峰值所在的索引表征了目标波达方向(DOA)。
3.Capon算法仿真 仿真环境：Matlab2021b；
波达方向分别为：10°、-15°、21°；
信源快拍数、阵元个数：1024、32;
分别对信噪比为:-10dB、20dB、30dB
仿真代码如下：
%% Author：Poulen %% Data：2023.5.29 %% Capon算法仿真 clear close all; clc; %% 产生信号 M=32; %阵元单元 c=3e8; %光速 f0=77e9; %初始频率 lambda=c/f0; %波长 slope=30e12; %调频斜率 time=60e-6; %60us d=0:lambda/2:(M-1)*lambda/2;%阵列天线 thita=[-15,21,10]; %波达方向 K = length(thita); N=1024; %信号长度 t=linspace(0,time,N); A=zeros(M,K); %导向向量空间 M*K S=zeros(K,N); %信号空间 f = 100+f0; for i = 1:K A(:,i) = exp(-1j*2*pi/lambda*d(:)*sind(thita(i))); S(i,:) = exp(1j*2*pi*f*t(:)); f = 1000+f; end S = A*S; %产生阵列接收数据 %% 向数据添加白噪声 SNR = 60; %单位dB S = S +(randn(size(S)).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26dadc6dbf823e16775e303d23fa257e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b12d08fdba69d64da56d88d913bd5352/" rel="bookmark">
			【动态规划】动态规划算法基本概念，原理应用和示例代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 动态规划概述 动态规划（Dynamic Programming，简称DP）是一种解决多阶段决策问题的数学优化方法。它将原问题分解成若干个子问题，通过解决子问题只需解决一次并将结果保存下来，从而避免了重复计算，提高了算法效率。
通俗来讲，动态规划算法是解决一类具有重叠子问题和最优子结构性质的问题的有效方法。其基本原理是将大问题分解为小问题，通过保存中间结果来避免重复计算，从而提高算法的效率。
动态规划主要包括两个要素：最优子结构和重叠子问题。
2 基本概念 最优子结构（Optimal Substructure）： 问题的最优解可以由其子问题的最优解递归地构建而成。
重叠子问题（Overlapping Subproblems）： 问题可以被分解成若干个相同的子问题，这些子问题会被反复解决。
状态转移方程（State Transition Equation）： 用于描述问题的状态和状态之间的关系，通过状态的转移得到最终问题的解。
3 动态规划算法步骤 定义状态：确定问题的状态，将大问题分解为子问题，并确定子问题所对应的状态。
建立状态转移方程：根据题目要求或者问题的定义，建立子问题之间的递推关系。
初始化：确定初始状态的值。
递推求解：根据状态转移方程，自底向上地求解问题，直到得到最终的结果。
输出结果：根据最终的状态求解结果。
4 应用 动态规划广泛应用于解决一些优化问题，如最短路径问题、最长公共子序列、背包问题等。以下是一些常见的应用场景：
最短路径问题： 比如 Dijkstra 算法和 Floyd-Warshall 算法。
背包问题： 包括 0/1 背包问题和背包问题的变种。
最长公共子序列： 求解两个序列的最长公共子序列的长度。
字符串编辑距离： 计算两个字符串之间的最小编辑操作次数，包括插入、删除和替换。
最大子数组和： 求解数组中连续子数组的最大和。
详解与示例：
让我们以一个简单的问题为例，来详细解释动态规划的应用。
示例1： 假设有一个数组 nums，求解其连续子数组的最大和 动态规划解法：
定义状态： 设 dp[i] 为以 nums[i] 结尾的连续子数组的最大和。
状态转移方程： dp[i] = max(dp[i-1] + nums[i], nums[i])，即当前位置的最大和要么是之前的最大和加上当前元素，要么是当前元素本身。
初始化： dp[0] = nums[0]，数组的第一个元素作为初始值。
遍历： 从数组的第二个元素开始遍历，更新 dp[i]。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b12d08fdba69d64da56d88d913bd5352/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a9a606e745207899a823b08916beba9/" rel="bookmark">
			若依(ruoyi)前端Vue3 Element Plus Vite版样式修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 导航栏样式1.1 背景色1.2 右侧图标（全屏等）1.3 右侧下拉菜单样式1.4 左侧面包屑文字样式1.5 左侧面包屑旁边的显示/隐藏侧边栏SVG样式 2. sidebar字体样式3. 全局tags标签按钮等背景色4. tags标签页样式5. 表格样式6. 树形菜单选中样式 1. 导航栏样式 1.1 背景色 位置：src/layout/components/Navbar.vue
类名：.navbar
// 比如背景色等 background: #1b2535; 这里主要是修改导航栏的背景色，在修改颜色值时，你可以使用其他十六进制颜色代码，也可以尝试使用RGB、RGBA或HSL等其他表示颜色的方式。这取决于你的设计需求和个人喜好。
1.2 右侧图标（全屏等） 这段主要是修改右侧的图标，隐藏、全屏等方法：
.right-menu-item { display: inline-block; padding: 0 8px; height: 100%; font-size: 18px; color: #5a5e66; vertical-align: text-bottom; &amp;.hover-effect { cursor: pointer; transition: background 0.3s; &amp;:hover { background: rgba(0, 0, 0, 0.025); } } } 以下是对这段代码的解释：
.right-menu-item: 这是一个类选择器，用于选择HTML中具有class="right-menu-item"的元素。
display: inline-block;: 设置元素的显示类型为inline-block，使其既具有块级元素的特性，又可以在水平方向上排列，类似于行内元素。
padding: 0 8px;: 设置元素的内边距，上下边距为0，左右边距为8像素。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a9a606e745207899a823b08916beba9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2ea61ce325ed7341bd8fd444a795e59/" rel="bookmark">
			AIGC：使用bert_vits2实现栩栩如生的个性化语音克隆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 VITS2模型 1.1 摘要 单阶段文本到语音模型最近被积极研究，其结果优于两阶段管道系统。以往的单阶段模型虽然取得了较大的进展，但在间歇性非自然性、计算效率、对音素转换依赖性强等方面仍有改进的空间。本文提出VITS2，一种单阶段的文本到语音模型，通过改进之前工作的几个方面，有效地合成了更自然的语音。本文提出了改进的结构和训练机制，所提出的方法在提高多说话人模型中语音特征的自然度、相似性以及训练和推理效率方面是有效的。证明了所提出方法可以显著减少以前工作中对音素转换的强依赖，允许完全端到端单阶段方法。
论文地址：https://arxiv.org/pdf/2307.16430.pdf
演示地址：https://vits-2.github.io/demo/
VITS1讲解详见：https://mp.csdn.net/mp_blog/creation/editor/130904876
1.2 介绍 最近，基于深度神经网络的文本到语音的发展取得了重大进展。基于深度神经网络的文本到语音转换是一种从输入文本生成相应原始波形的方法；它有几个有趣的特性，通常使文本到语音任务具有挑战性。通过对特征的快速回顾，可以发现文本到语音任务涉及到将不连续的文本特征转换为连续的波形。输入和输出具有数百倍的时间步长差异，它们之间的对齐必须非常精确才能合成高质量的语音音频。此外，输入文本中不存在的韵律和说话人特征需要自然地表达，文本输入可以有多种说话方式，这是一个一对多的问题。合成高质量语音具有挑战性的另一个因素是，人们在听音频时专注于单个组件；因此，即使构成整个音频的数十万个信号中只有一小部分是非自然的，人类也可以很容易地感知它们。效率是导致任务困难的另一个因素。合成的音频具有很高的时间分辨率，通常每秒包含超过20,000个数据，需要高效的采样方法。
由于文本到语音的任务特点，解决方案也可以是复杂的。之前的工作通过将从输入文本生成波形的过程分为两个级联阶段来解决这些问题。一种流行的方法涉及从第一阶段的输入文本中生成中间语音表示，如梅尔语谱图或语言特征，然后以第二阶段的这些中间表示为条件生成原始波形。两级管道系统具有简化每个模型和便于训练的优点；然而，它们也有以下限制。
错误从第一阶段传播到第二阶段。它不是利用模型内部学习到的表示，而是通过人类定义的特征(如梅尔语谱图或语言特征)进行中介。生成中间特征所需的计算量。最近，为了解决这些限制，直接从输入文本中生成波形的单阶段模型已被积极研究。单阶段模型不仅优于两阶段管道系统，而且显示了生成与人类几乎不可区分的高质量语音的能力。 虽然之前的工作使用单阶段方法取得了巨大的成功，但模型vits存在以下问题：间歇性不自然、时长预测器效率低、输入格式复杂以缓解对齐和时长建模的局限性(使用空白标记)、多说话人模型中说话人相似性不足、训练速度慢以及对音素转换的依赖性强。本文提供了解决这些问题的方法。本文提出一种通过对抗性学习训练的随机时长预测器，利用transformer块和说话人条件文本编码器改进的归一化流，以更好地对多个说话人特征进行建模。实验结果表明，所提出的方法提高了质量和效率。此外，通过使用规范化文本作为模型输入的实验表明，该方法减少了对音素转换的依赖。因此，该方法更接近于完全的端到端单阶段方法。
1.3 模型 在本节中，我们描述了四个小节的改进：时长预测（duration prediction）、具有归一化流的增广变分自编码器（augmented variational autoencoder with normalizing flows）、对齐搜索（alignment search）和以说话人为条件的文本编码器（and speaker-conditioned text encoder）。本文提出一种使用对抗性学习来训练时长预测器的方法，以在训练和合成方面都具有较高的效率来合成自然语音。该模型本质上是使用上一项工作[4,17]中提出的单调对齐搜索(MAS)来学习对齐，并进一步建议进行修改以提高质量。提出了一种通过将transformer块引入到规范化流程中来提高自然性的方法，能在转换分布时捕获长期依赖。此外，本文还改进了多说话人模型中的说话人条件，以提高说话人相似度。
1.3.1 基于时间步进条件判别的随机时长预测器 之前的工作表明，基于流的随机时长预测器比确定性方法更有效地提高了合成语音的自然度。结果很好;然而，基于流的方法需要相对更多的计算和一些复杂的技术。本文提出一种具有对抗性学习的随机时长预测器，以合成更自然的语音，在训练和合成方面的效率都比之前的工作更高。建议的持续时间预测器和鉴别器的概述如图1a所示。我们应用对抗性学习来训练时间预测器，使用与生成器相同的输入条件判别器来适当区分预测的时间。我们使用文本的隐藏表示htext和高斯噪声zd作为生成器G的输入；使用MAS获得的对数尺度的htext和持续时间(以d表示)或从持续时间预测器(以dˆ表示)中预测的htext和持续时间(以d表示)作为鉴别器d的输入。一般生成对抗网络的鉴别器被输入固定长度的输入，而预测每个输入token的持续时间，并且输入序列的长度随每个训练实例而变化。为正确区分可变长度的输入，本文提出一种时间逐步判别器，可区分所有token的每个预测持续时间。我们使用两种类型的损失;对抗学习的最小二乘损失函数和均方误差损失函数：
提出的时长预测器和训练机制允许在较短的步骤中学习时长，并且时长预测器被单独训练作为最后的训练步骤，从而减少了训练的整体计算时间。
1.3.2 带高斯噪声的单调对齐搜索 在之前的工作之后，我们将MAS引入到我们的模型中来学习对齐。该算法产生了在所有可能的单调对齐中具有最高概率的文本和音频之间的对齐，并训练模型以最大化其概率。该方法是有效的;然而，在搜索和优化特定的对齐之后，搜索其他更合适的对齐会受到限制。为了缓解这个问题，我们在计算的概率中添加了一个小的高斯噪声。这为模型提供了额外的机会来搜索其他对齐。我们只在训练开始时添加这种噪声，因为MAS使模型能够快速学习对齐。参考之前的工作[4]，该工作详细描述了算法，正向操作中所有可能位置的Q值都计算出最大对数似然。我们在操作中计算的Q值上添加了小的高斯噪声。
其中i和j分别表示输入序列和后验序列上的特定位置，z表示来自标准化流的转换潜变量。是从标准正态分布中采样的噪声、P的标准差和从0.01开始并每步递减2×10^−6的噪声尺度的乘积。
1.3.3 使用Transformer块的归一化流 之前的工作展示了用归一化流增强的变分自编码器合成高质量语音音频的能力。归一化流包含卷积块，卷积块是捕获相邻数据模式的有效结构，使模型能够合成高质量的语音。在转换分布时，捕捉长期依赖关系的能力至关重要，因为语音的每个部分都与不相邻的其他部分相关。虽然卷积块可以有效捕获相邻模式，但由于其感受野的限制，在捕获长期依赖关系方面存在不足。因此，我们在归一化流中添加了一个带有残差连接的小transformer块，以捕获长期依赖关系，如图1b所示。图2显示了实际的注意力得分图和卷积块的感受野。可以确定，transformer块在变换分布时在不同位置收集信息，这是感受野不可能做到的。
1.3.4 说话人条件文本编码器 由于多说话人模型是根据说话人条件用单一模型合成多种特征的语音，表达每个说话人的个人语音特征是一个重要的质量因素，也是自然度的一个重要因素。已有工作表明，单阶段模型可以高质量地对多个说话人进行建模。考虑到说话人的特定发音和语调等特征会显著影响每个说话人的语音特征的表达，但输入文本中不包含这些特征，设计了一个以说话人信息为条件的文本编码器，通过在编码输入文本的同时学习这些特征来更好地模仿每个说话人的各种语音特征。我们将说话人向量设置在文本编码器的第三个transformer块上，如图1c所示。
1.4 实验 我们在两个不同的数据集上进行了实验。使用LJ语音数据集[20]验证自然度的提升，使用VCTK数据集[21]验证模型是否能更好地再现说话人特征。LJ语音数据集由单个说话者的13100个短音频片段组成，总长度约为24小时。音频格式是16位PCM，采样率为22.05 kHz，我们使用它没有任何操作。我们将数据集随机分为训练集(12,500个样本)、验证集(100个样本)和测试集(500个样本)。
VCTK数据集由109个具有不同口音的英语母语者发出的约44,000个短音频片段组成。音频剪辑的总长度约为44小时。音频格式为16位PCM，采样率为44.1 kHz。我们将采样率降低到22.05 kHz。我们将数据集随机分为训练集(43,470个样本)、验证集(100个样本)和测试集(500个样本)。采用80波段mel尺度谱图计算重建损失。与之前的工作[17]相比，我们使用相同的语谱图作为后验编码器的输入。快速傅里叶变换、窗口和跳数分别设置为1024、1024和256。
我们使用音素序列和规范化文本作为模型的输入进行了实验。我们使用开源软件[22]将文本序列转换为国际音标序列，并将该序列输入文本编码器。与之前的工作[17]相比，我们没有使用空白标记。对于规范化文本的实验，我们使用开源软件[23]用简单的规则规范化输入文本，并将其提供给文本编码器。
使用AdamW[24]优化器训练网络，β1 = 0.8， β2 = 0.99，权重衰减λ = 0.01。学习率衰减在每轮中以0.9991/8因子进行调度，初始学习率为2 × 10^−4。我们每一步为网络提供256个训练实例。继之前的工作[17]之后，应用带窗口的生成器训练。我们在四个NVIDIA V100 gpu上使用混合精度训练。生成波形的网络和持续时间预测器分别训练了800k和30k步。
1.5 结果 1.5.1 自然度评估 为了验证所提模型能够合成自然语音，进行了众包平均意见得分(MOS)测试。在听了从测试集中随机选择的音频样本后，打分者对他们的自然程度进行了从1到5的5分评分。考虑到之前的工作[17]已经显示出与人工记录相似的质量，我们还进行了比较平均意见分数(CMOS)测试，该测试适合通过直接比较来评估高质量样本。评价者在听了从测试集中随机选择的音频样本后，对他们相对偏好的自然程度进行了评分，总分为7分，从3到3分不等评价者被允许对每个音频样本进行一次评估。对所有音频样本进行归一化处理，以避免幅度差异对得分的影响。我们使用官方实现和之前工作[17]的预训练权重作为比较模型。评价结果见表1和表2a。该方法与已有工作[17]的MOS值差为0.09,CMOS值和置信区间分别为0.201和±0.105。实验结果表明，该方法显著提高了合成语音的质量。此外，我们使用[18]方法对CMOS进行了评估，该方法在不同的结构和训练机制下表现出良好的性能。为了评估，我们使用官方实现和预训练权重生成样本。实验结果的CMOS和置信区间分别为0.176和±0.125，表明该方法明显优于传统方法。
1.5.2 消融研究 为验证所提方法的有效性，进行了消融研究。为验证对抗学习训练的随机时间预测器的有效性，将其替换为具有相同结构的确定性时间预测器，并使用L2损失进行训练。确定性时间预测器的训练步骤与之前的工作[17]相同。为验证对齐搜索中使用的噪声调度的有效性，对模型进行无噪声训练。为了验证模型的有效性，在归一化流程中没有transformer模块的情况下对模型进行训练。评价结果如表1所示。确定性持续时间预测器、无噪声的对准搜索和无变压器块的归一化流的消融研究的MOS差值分别为0.14、0.15和0.06。由于不使用空白标记和线性语谱图，计算效率将得到提高，删除一些所提出的方法与之前的工作[17]相比，性能较低。实验结果表明，所提方法在提高图像质量方面是有效的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2ea61ce325ed7341bd8fd444a795e59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/051183a0104dedc592f3b67c34e33529/" rel="bookmark">
			路规算法详细解读（一）—— FAST-Planner重要部分代码解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于最近的研究需要，需要对Fast-planner和Ego-planner的代码了解，所以写出这篇代码解读文章，本文持续更新。废话不多说了，上干货！
本文基于以下大佬的代码解析基础上去阅读、理解、总结而成，对我的帮助真的特别大。觉得有帮助的朋友记得给大佬点赞！
Fast-Planner代码阅读-1. Robust and Efficient Quadrotor Trajectory Generation for Fast Autonomous Flight_fast planner b样条_养生少年小余的博客-CSDN博客
本文之所以成就之高，原因在于其框架的完整性，代码主要解读包含三大板块：kinodynamic a_star 路径搜索、non_uniform_bspline均匀B样条轨迹优化、非均匀B样条轨迹优化三大主要部分。
一、kinodynamic a_star 路径搜索 实现该功能的文件为/fast_planner/path_searching/src/kinodynamic_astar.cpp，将围绕其主要循环函数展开。
int KinodynamicAstar::search(Eigen::Vector3d start_pt, Eigen::Vector3d start_v, Eigen::Vector3d start_a, Eigen::Vector3d end_pt, Eigen::Vector3d end_v, bool init, bool dynamic, double time_start) 该函数传入参数为分别为start_pt（起点位置）、start_v（起点速度）、start_a（起点加速度）、end_pt（终点位置）、end_v（终点速度）、init（初始化成功标志位）、dynamic（动静规划标志位）、time_start（起始时间）。
1. 读取并初始化参数、计算起点代价、优化时间，将起点加入到openlist中： 该步骤是为了将传入的vector转化为可带入运算的状态矩阵
//函数传入参数为起始点的位置、速度、加速度、终点位置、速度、初始化标志位、动态（可行）标志位？、起始时间 start_vel_ = start_v;//取出传入的起始点的速度 start_acc_ = start_a;//传入起始点的加速度 //path_node_pool_ 可能在初始化时被分配一定数量的节点，这些节点在运行时被重复使用，而不是每次需要节点时都动态地分配内存。这有助于提高性能，避免频繁的内存分配和释放。 PathNodePtr cur_node = path_node_pool_[0];//取出第一个路径点赋给当前节点 cur_node-&gt;parent = NULL;//父节点 cur_node-&gt;state.head(3) = start_pt;//state矩阵前3列记录位置 cur_node-&gt;state.tail(3) = start_v;//state矩阵后三列记录速度 cur_node-&gt;index = posToIndex(start_pt);//获取全剧坐标系下的位置索引 cur_node-&gt;g_score = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/051183a0104dedc592f3b67c34e33529/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/565/">«</a>
	<span class="pagination__item pagination__item--current">566/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/567/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>