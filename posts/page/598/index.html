<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bfa53d0defa57ee20491616e9f55aaa/" rel="bookmark">
			MySQL的下载、安装和配置（图文详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、MySQL的4大版本
二、软件的下载
1. 下载地址
2. 打开官网，点击DOWNLOADS
3. 点击 MySQL Community Server
三、MySQL8.0 版本的安装
四、配置MySQL8.0
五、配置MySQL8.0 环境变量
六、MySQL5.7 版本的安装、配置
一、MySQL的4大版本 MySQL Community Server 社区版本，开源免费，自由下载，但不提供官方技术支持，适用于大多数普通用户。
MySQL Enterprise Edition 企业版本，需付费，不能在线下载，可以试用30天。提供了更多的功能和更完备的技术支持，更适合于对数据库的功能和可靠性要求较高的企业客户。
MySQL Cluster 集群版，开源免费。用于架设集群服务器，可将几个MySQL Server封装成一个Server。需要在社区版或企业版的基础上使用。
MySQL Cluster CGE 高级集群版，需付费。
目前最新版本为8.0.33，发布时间2023年4月18日。
此外，官方还提供了MySQL Workbench（GUITOOL）一款专为MySQL设计的图形界面管理工具。MySQLWorkbench又分为两个版本，分别是社区版（MySQL Workbench OSS）、商用版（MySQL WorkbenchSE）。
二、软件的下载 1. 下载地址 官网： https://www.mysql.com
2. 打开官网，点击DOWNLOADS 然后，点击MySQL Community(GPL) Downloads
3. 点击 MySQL Community Server 4. 在General Availability(GA) Releases中选择适合的版本
Windows平台下提供两种安装文件：MySQL二进制分发版（.msi安装文件）和免安装版（.zip压缩文件）。一般来讲，应当使用二进制分发版，因为该版本提供了图形化的安装向导过程，比其他的分发版使用起来要简单，不再需要其他工具启动就可以运行MySQL。
这里在Windows 系统下推荐下载MSI安装程序；点击Go to Download Page进行下载即可
Windows下的MySQL8.0安装有两种安装程序
mysql-installer-web-community-8.0.33.0.msi 下载程序大小：2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bfa53d0defa57ee20491616e9f55aaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95908317b4eea6c98b049f83b58969ec/" rel="bookmark">
			Zookeeper概述及部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Zookeeper概述及部署 一、Zookeeper 定义二、Zookeeper 特点三、Zookeeper 数据结构四、Zookeeper 应用场景五、Zookeeper选举机制● 第一次启动选举机制● 非第一次启动选举机制 六、部署 Zookeeper 集群1.安装前准备2.安装 Zookeeper 一、Zookeeper 定义 Zookeeper是一个开源的分布式的，为分布式框架提供协调服务的Apache项目。
Zookeeper的工作机制：从设计模式角度来理解:是一个基于观察者模式设计的分布式服务管理框架，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper就将负责通知已经在Zookeeper上注册的那些观察者做出相应的反应。也就是说 Zookeeper=文件系统+通知机制。
二、Zookeeper 特点 Zookeeper: 一个领导者(Leader) ，多个跟随者(Follower) 组成的集群。Zokeepe集群中只要有半数以上节点存活，Zookeeper集群就能正常服务。所以zookeeper适合安装奇数台服务器。全局数据一致:每个Server保存一份相同的数据副本，Client无论连接到哪个Server,数据都是一致的。更新请求顺序执行，来自同一个client的更新请求按其发送顺序依次执行，即先进先出。数据更新原子性，一次数据更新要么成功，要么失败。实时性，在一定时间范围内，Client能读到最新数据。 三、Zookeeper 数据结构 ZooKeeper数据模型的结构与Linux文件系统很类似，整体上可以看作是一棵树，每个节点称做一 个ZNode。每一个ZNode默认能够存储1MB的数据，每个ZNode都可以通过其路径唯一标识。 四、Zookeeper 应用场景 提供的服务包括:统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等。 ● 统一命名服务
在分布式环境下，经常需要对应用/服务进行统一命名，便于识别。例如:IP不容易记住，而域名容易记住。 ● 统一配置管理
分布式环境下，配置文件同步非常常见。一 般要求一- 个集群中，所有节点的配置信息是一致的， 比如Kafka集群。对配置文件修改后，希望能够快速同步到各个节点上
配置管理可交由ZooKeeper实现。可将配置信息写入ZooKeeper.上的一个Znode。各个客户端服务器监听这个Znode。一旦
Znode中的数据被修改，ZooKeeper将 通知各个客户端服务器。
● 统一集群管理
分布式环境中，实时掌握每个节点的状态是必要的。可根据节点实时状态做出一些调整。ZooKeeper可以实现实时监控节点状态变化。可将节点信息写入ZooKeeper上的一个ZNode。监听这个ZNode可获取它的实时状态变化。 ● 服务器动态上下线
客户端能实时洞察到服务器上下线的变化。 ● 软负载均衡
在Zookeeper中记录每台服务器的访问数，让访问数最少的服务器去处理最新的客户端请求。 五、Zookeeper选举机制 ● 第一次启动选举机制 (1)服务器1启动，发起一次选举。服务器1投自己一票。此时服务器1票数一票，不够半数以上(3票)，选举无法完成，服务器1状态保持为LOOKING;(2)服务器2启动，再发起一次选举。服务器1和2分别投自己一票并交换选票信息：此时服务器1发现服务器2的myid比自己目前投票推举的(服务器1)大，更改选票为推举服务器2。此时服务器1票数0票，服务器2票数2票，没有半数以上结果，选举无法完成，服务器1，2状态保持LOOKING(3)服务器3启动，发起一次选举。此时服务器1和2都会更改选票为服务器3。此次投票结果:服务器1为0票，服务器2为0票，服务器3为3票。此时服务器3的票数已经超过半数，服务器3当选Leader。 服务器1，2更改状态为FOLLOWING，服务器3更改状态为LEADING;(4) 服务器4启动，发起一次选举。此时服务器1，2，3已经不是L00KING状态，不会更改选票信息。交换选票信息结果：服务器3为3票，服务器4为1票。此时服务器4服从多数，更改选票信息为服务器3，并更改状态为FOLLOWING。(5) 服务器5启动，同4一样当小弟。 ● 非第一次启动选举机制 当ZooKeeper 集群中的一台服务器出现以下两种情况之-一时，就会开始进入Leader选举： 服务器初始化启动。服务器运行期间无法和Leader保持连接。 而当一台机器进入leader选举流程时，当前集群也可能会处于以下两种状态： 1）集群中本来就已经存在
对于已经存在Leader的情况，机器试图去选举Leader时，会被告知当前服务器的Leader信息，对于该机器来说，仅仅需要和Leader机器建立连接，并进行状态同步即可。 2）集群中确实不存在Leader
假设ZooKeeper由5台服务器组成，SID分别为1、2、3、4、5，ZXID分别为8、8、8、7、7，并且此时SID为3的服务器是Leader。某一时刻，3和5服务器出现故障，因此开始进行Leader选举。 选举Leader规则：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95908317b4eea6c98b049f83b58969ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e07f15a06b784a7b6d443539ca670782/" rel="bookmark">
			60题学会动态规划系列：动态规划算法第五讲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		子数组系列题目
文章目录 1.最大子数组和2.环形子数组的最大和3.乘积最大数组4.乘积为正数的最长子数组长度5.等差数列划分6.最长湍流子数组7.单词拆分8.环绕字符串中唯一的子字符串 1.最⼤⼦数组和 力扣链接：力扣
给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
子数组 是数组中的一个连续部分。
这道题是子数组问题中的经典问题，同时也非常简单，题目告诉子数组可以是一个元素，在这里要注意子数组和子序列的区别（子数组是连续的，子序列可以连续可以不连续，子序列包含了子数组）
1.状态表示
根据经验我们就以常用的以某一个位置为结尾来定义状态表示，如果可以推出状态转移方程，那么我们的状态表示就是没有问题的，如果推不出来状态转移方程，那么就需要重新状态表示。
dp[i]表示以i位置为结尾的连续子数组的最大和
2.状态转移方程
我们要求状态转移方程，首先要看如何求i位置的最大和，这里其实只有两种情况1.我们的i位置的数比前面的所有子数组的最大和加上我们i位置的数都要大，那么i位置的最大和就是nums[i]。如果i位置前面的所有连续子数组的最大和加上i位置的值是小于前面的所有连续子数组的最大和的，那么i位置的最大和就是前面的所有连续子数组的最大和。我们的状态表示是以i位置为结尾的连续子数组的最大和，那么i位置前面的i-1不就是前面的所有子数组的最大和吗，所以状态转移方程为：
dp[i] = max(dp[i-1]+nums[i],nums[i])
3.初始化
从状态转移方程中我们可以看到只有第一个位置会越界，所以我们初始化dp[0]即可，一个元素的最大和就是这个元素本身，所以dp[0] = nums[0]
4.填表
从左向右
5.返回值
我们dp表中存放的是从0~n-1每一个位置为结尾的连续子数组的最大和，所以返回的是表中最大的值。
class Solution { public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; dp(n,0); dp[0] = nums[0]; int ret = dp[0]; for (int i = 1;i&lt;n;i++) { dp[i] = max(dp[i-1]+nums[i],nums[i]); ret = max(dp[i],ret); } return ret; } }; 2.环形子数组的最大和 力扣链接：力扣
给定一个长度为 n 的环形整数数组 nums ，返回 nums 的非空 子数组 的最大可能和 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e07f15a06b784a7b6d443539ca670782/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/646491164331f2550adff0eb8b7c4a1f/" rel="bookmark">
			JAVA中的GUI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.GUI的概念
1.1基本概念
1.2GUI的特点
1.3Swing的概念
1.4GUI中的容器组件
二.常用容器
2.1JFrame
2.2JFrame中常用的方法
2.3JPanel
三.GUI面板的布局
3.1流式布局
3.2边界布局
3.3网格布局
四.文本框
4.1JLabe
4.2JTextField
4.4 多行文本框(JTextArea)
4.5按钮
五.菜单
六.事件处理
一.GUI的概念 1.1基本概念 GUI是Graphical User Interface（图形用户界面）的缩写，指的是通过图形方式显示和操作的用户界面。它提供了一种直观、可视化的方式，让用户可以通过鼠标、键盘或触摸等输入设备与计算机进行交互。
GUI的设计目的是简化用户与计算机系统之间的交互过程，使用户能够更轻松、高效地完成各种任务。传统的命令行界面（CLI）需要用户记忆和输入命令，而GUI则通过图形元素如窗口、按钮、菜单、对话框等来呈现信息和提供操作选项，使用户可以通过直接点击、拖拽、输入等方式与计算机进行交互。
1.2GUI的特点 视觉化：GUI使用图形元素和视觉效果来代表应用程序的功能、数据和操作，以便用户能够直观地理解和操作。
交互性：GUI允许用户通过鼠标、键盘或触摸等输入设备进行交互操作，包括点击、拖拽、输入等，使用户能够主动地与计算机进行沟通和反馈。
易用性：GUI设计注重用户体验，追求简洁、易于理解和操作的界面，减少用户的学习成本和操作困难。
多任务支持：GUI允许多个应用程序同时运行在屏幕上的不同窗口中，并提供了任务切换和管理的功能，方便用户在不同应用程序之间进行切换和操作。
可视化编程：基于GUI的开发工具和框架使开发人员能够使用可视化方式设计和构建应用程序界面，简化开发流程。
1.3Swing的概念 Swing是纯Java组件，使得应用程序在不同的平台上运行时具有相同外观和相同 的行为。
Swing中的大部分组件类位于javax.swing包中.
Swing中的组件非常丰富，支持很多功能强大的组件。
1.4GUI中的容器组件 Java的图形用户界面的基本组成部分是组件，组件是一个以图形化的方式 显示在屏幕上并能与用户进行交互的对象； 组件不能独立地显示出来，必须将组件放在一定的容器(container)中才 可以显示出来。
容器可以容纳多个组件，通过调用容器的add(Component comp)方法 向容器中添加组件。
窗口(Frame)和面板(Panel)是最常用的两个容器。
二.常用容器 2.1JFrame JFrame是一个用于创建窗口和应用程序框架的类。它是javax.swing包中的一部分，提供了一些基本功能，如窗口管理、布局管理和事件处理等。
JFrame类代表了一个顶级窗口，可以包含其他GUI组件，如按钮、文本框、标签等。通过使用JFrame，可以创建具有标题栏、最大化、最小化、关闭按钮等标准窗口功能的应用程序。
创建了一个继承自JFrame的自定义类MyFrame。在构造函数中，设置了窗口的标题、大小、默认的关闭操作，并将窗口设置为可见。最后，在main方法中创建了MyFrame对象，即实例化了窗口并显示出来。
除了基本的窗口和应用程序框架功能外，JFrame还提供了许多方法用于添加和管理其他GUI组件、设置窗口属性和处理事件等。通过灵活运用JFrame以及其他Swing组件，可以构建出功能强大、交互友好的Java图形界面应用程序。
下面是GUI窗口的简单创建：
import javax.swing.*; import java.awt.*; public class MyJFrame extends JFrame { public MyJFrame() throws HeadlessException { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/646491164331f2550adff0eb8b7c4a1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e927a38a6f7e421bebe9a2719def45dd/" rel="bookmark">
			【学会动态规划】第 N 个泰波那契数（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
动态规划怎么学？
1. 题目解析
2. 算法原理
1. 状态表示
2. 状态转移方程
3. 初始化
4. 填表顺序
5. 返回值
3. 代码编写
4. 空间优化
写在最后
动态规划怎么学？ 学习一个算法没有捷径，更何况是学习动态规划，
跟我一起刷动态规划算法题，一起学会动态规划！
1. 题目解析 题目链接：1137. 第 N 个泰波那契数 - 力扣（Leetcode）
我们根据题目给的条件：
Tn+3 = Tn + Tn+1 + Tn + 2，也就是：Tn = Tn - 1 + Tn - 2 + Tn - 3
可以知道，第n个泰波那契数实际上就是他前三个数的和。 2. 算法原理 1. 状态表示 一般来说，我们会先创建一个数组作为dp表，
将这个dp表填满，而答案就在这个表上的某一个位置，
而状态表示的意思就是，表上的一个值表示的含义。
不说这些虚的，那我们该怎么得出状态表示呢？
1. 根据题目要求
2. 根据我们的经验 + 题目要求
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e927a38a6f7e421bebe9a2719def45dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac103adb19908586e6cbf00172732a77/" rel="bookmark">
			Python之map()函数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、map() 函数简介1.1 map() 函数基本语法1.2 map() 函数+ lambda表达式1.3 map() 函数输入多个可迭代对象iterable1.4 查看返回的迭代器内容 二、map() 函数示例示例一：使用 map() 函数操作字符串列表示例二：使用 map() 函数操作元组列表 参考资料 一、map() 函数简介 当我们使用列表或者元组时，经常需要对列表元素进行数学变换操作并返回一个新的列表。例如，我们想要将列表 bonuses 中的每个元素都乘以 2：
bonuses = [100, 200, 300] 为此，我们可以使用一个 for 循环遍历列表，将每个元素乘以 2，然后将结果添加到一个新的列表中：
bonuses = [100, 200, 300] new_bonuses = [] for x in bonuses: new_bonuses.append(x*2) print(new_bonuses) # 输出：[200, 400, 600] 1.1 map() 函数基本语法 Python 提供了一个内置的 map() 函数，可以更加方便地执行这类操作。
以下是 map() 函数的基本语法：
map(function, iterable) 参数解释如下：
function：一个函数或方法iterable：一个或多个序列（可迭代对象） map() 函数的作用是：对序列 iterable 中每一个元素调用 function 函数，返回一个map对象实例。这个map对象本质上来讲是一个迭代器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac103adb19908586e6cbf00172732a77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb754942e7bca381dd457229faa176b9/" rel="bookmark">
			【Java】Lambda表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Lambda表达式1.1 相关背景1.2 函数式编程1.3 匿名内部类和Lambda表达式 二、Lambda表达式的使用2.1 基本语法2.2 使用案例 三、变量捕获3.1 匿名内部类的变量捕获3.2 Lambda表达式的变量捕获 四、Lambda表达式在集合中的使用4.1 Collection接口4.2 List接口4.3 Map接口 五、Lambda表达式的优缺点 一、Lambda表达式 1.1 相关背景 Lambda表达式是Java 8引入的一个重要特性，它是函数式编程在Java中的一种体现。在Java之前的版本中，Java主要采用面向对象的编程风格，而Lambda表达式的引入使得Java具备了函数式编程的能力。
1.2 函数式编程 函数式编程是一种编程范式，它将计算过程视为函数应用的连续组合。函数式编程强调使用纯函数（Pure Function），避免使用可变状态和副作用，倡导将计算过程抽象为函数，便于代码的理解、测试和并行化。
Lambda表达式允许将函数作为方法的参数，或者将代码块作为数据进行传递。它的引入主要解决了以下几个问题：
匿名内部类的冗余代码：在Java之前的版本中，为了实现函数的传递，常常需要使用匿名内部类来定义一个函数接口的实现。这导致代码冗长、可读性较差。Lambda表达式的引入简化了匿名内部类的语法，让代码更加简洁明了。
函数式编程的支持：函数式编程强调将函数作为第一类对象进行传递和操作。Lambda表达式提供了一种便捷的语法形式，使得函数可以作为参数传递给方法，或者作为返回值返回。
并行编程的支持：函数式编程中的纯函数天然具备无副作用的特性，这使得在并行编程中更容易实现可靠的多线程和并行处理。Lambda表达式的引入使得Java在并行编程方面具备了更好的支持。
1.3 匿名内部类和Lambda表达式 匿名内部类和Lambda表达式都是在Java中用于实现函数式编程的机制，它们可以用来传递行为（函数）作为参数或返回值。
匿名内部类：
匿名内部类是在Java早期引入的一种机制，用于创建一个没有命名的、实现了某个接口或抽象类的类的实例。通过匿名内部类，可以在使用某个接口或抽象类的地方，直接定义一个实现该接口或抽象类的实例。匿名内部类通常通过创建一个子类来实现，并且在实例化的同时定义实现的方法。例如，以下是使用匿名内部类实现Runnable接口的例子：
Thread thread = new Thread(new Runnable() { public void run() { System.out.println("Hello from anonymous inner class"); } }); thread.start(); Lambda表达式：
Lambda表达式是Java 8中引入的一种更简洁、更直观的方式来表示函数式接口（只有一个抽象方法的接口）的实例。Lambda表达式提供了一种更简洁的语法，使得可以以更紧凑的方式传递行为。使用Lambda表达式，可以直接定义一个函数式接口的实例，而无需创建匿名内部类。以下是使用Lambda表达式实现相同功能的例子：
Thread thread = new Thread(() -&gt; { System.out.println("Hello from Lambda expression"); }); thread.start(); Lambda表达式使用箭头-&gt;将参数和函数体分隔开，参数可以有零个或多个，函数体可以是一个表达式或一段代码块。Lambda表达式的引入让Java代码更具表达力和简洁性，提高了代码的可读性和可维护性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb754942e7bca381dd457229faa176b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20692a321715eef40729d67bfbe275f7/" rel="bookmark">
			031基于java&#43;springboot&#43;mybatis&#43;vue&#43;elementui的箱包销售商城网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目介绍 箱包销售商城网站的开发背景可以追溯到人们对箱包产品需求的增长和购物习惯的变化。随着时尚、旅游和商务等领域的发展，箱包作为重要配件和出行必备品，受到了越来越多人的关注和需求。
传统的箱包实体店面存在空间有限、商品种类有限和购物时间限制的问题。消费者需要花费时间去逐个店面寻找心仪的箱包，并且可能无法满足对于多样化选择的需求。而箱包销售商城网站的出现，解决了这些问题，为消费者提供了更加便捷、多样化的购物体验。
箱包销售商城网站的兴起得益于以下因素：
多样化产品选择：箱包销售商城网站汇集了各种品牌、款式和功能多样的箱包产品，包括旅行箱、背包、公文包、手提包等，满足了消费者对于多样化选择的需求。
专业化信息和购买指导：箱包销售商城网站提供了详细的产品信息、图片和用户评价，帮助消费者了解产品特点、材质、大小等，并提供购买指导，如选购指南、搭配推荐等，提升了消费者的购物体验。
价格竞争力和促销活动：箱包销售商城网站通常会提供有竞争力的价格，并不定期推出促销活动，如打折、满减、赠品等，吸引消费者购买。
安全的在线支付和配送服务：箱包销售商城网站提供安全可靠的在线支付系统和快速可靠的物流配送服务，保障了消费者的权益和购物安全。
通过箱包销售商城网站，消费者可以方便地浏览、选择和购买所需的箱包产品，满足个人、旅行和商务等不同需求。对于箱包品牌和销售商而言，箱包销售商城网站也为其提供了更广阔的市场机会，扩大了产品的曝光度和销售渠道。因此，箱包销售商城网站在满足消费者需求的同时，也推动了箱包市场的发展和壮大。
技术介绍 1、管理员账号：abo 密码：abo
2、开发环境为Eclipse/idea，数据库为mysql 使用java语言开发。
3.配置好Tomcat并点击启动按钮即可运行
4.数据库连接src\main\resources\application.yml中修改
5.maven包版本apache-maven-3.3.9.
开发语言：Java
框架：SSM
前端框架:vue.js
JDK版本：JDK1.8+
服务器：tomcat8+
数据库工具：Navicat
开发软件：idea 支持eclipse
Springboot是当前最流向的一个框架，它的配置更加的简单，使开发变得更加的简单迅速。
Springboot的基础结构共三个文件，具体如下：
src/main/java：程序开发以及主程序入口；
src/main/resources：配置文件；
src/test/java：测试程序。
ssm的数据库配置默认支持两种格式的配置文件
1,application.properties
2,application.yaml
项目界面 关键代码 package com.controller; import java.util.Arrays; import java.util.Calendar; import java.util.Date; import java.util.Map; import javax.servlet.http.HttpServletRequest; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.bind.annotation.RestController; import com.annotation.IgnoreAuth; import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20692a321715eef40729d67bfbe275f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1836ecadd1f165f0b991c0c7640f687d/" rel="bookmark">
			前端报错：“Uncaught SyntaxError: missing ) after argument list“只是参数列表后面缺少 “)”？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错"Uncaught SyntaxError: missing ) after argument list"，字面翻译过来的意思：语法错误: 参数列表后面缺少 )。 一直以为是少了 一个小括号找了好久 发现并不是
据提示是参数列表的问题，找到文件中存在参数列表的地方。如下图所示
真正的元凶找到了，参数少了一个对'' ”，
错误代码 r = `&lt;img src=${res.data} style="width:100%" οnclick="getClick(${res.data})"&gt;&lt;/img&gt;` 修改后
r = `&lt;img src=${res.data} style="width:100%" οnclick="getClick('${res.data}')"&gt;&lt;/img&gt;` tips： 这只是其中一种引发“Uncaught SyntaxError: missing ) after argument list”错误的场景。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ee1ec319fa55d464e536b4c7cf7d14f/" rel="bookmark">
			安卓14适配编译问题和坑总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改对应sdk版本 将targetSdkVersion改为34，minSdkVersion大于23，compileSdkVersion改为34
需注意以下几点
Gradle版本最低需要升级至7.4.2，否则会报错Caused by: java.io.IOException: AAPT2 process unexpectedly exit. Error output:
aapt2 W 06-26 09:56:23 8280 8280 LoadedArsc.cpp:682] Unknown chunk type ‘200’.
建议将Gradle版本升级至8.0.1以上，否则项目中xml文件需要全部整改，可以参考https://code-examples.net/zh-TW/q/2e3f77 不然会报错Task :app:shrinkReleaseRes FAILED
Execution failed for task ‘:app:shrinkReleaseRes’.
A failure occurred while executing com.android.build.gradle.internal.transforms.ShrinkProtoResourcesAction
ParseError at [row,col]:[1,1]
Message: Content is not allowed in prolog.
如果Gradle升级到8.0以上，jdk需要升级至17以上，建议使用Tools-AGP Upgrade Assistant自动升级，会自动对项目下需要变更的文件进行升级否则需要手动添加很多配置，升级时需要注意将所有Maven仓的Http改为Https，不允许使用Http拉库了
如果使用了R8混淆，Java17默认会开启R8 fullMode混淆模式，在网络请求序列化数据结构时会出现崩溃，可以关闭fullMode混淆，在gradle.properties中配置
android.enableR8.fullMode = false
以上为适配安卓14时遇到的编译问题和坑
具体适配方式都是参考官方文档
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c30f23b35c79406e7589a8cb2811c055/" rel="bookmark">
			Spring Security Oauth2.1 最新版 1.1.0 整合 （基于 springboot 3.1.0）gateway 完成授权认证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
背景
demo地址
版本
Spring Boot 3.1
Spring Authorization Server 1.1.0
基础
spring security
OAuth2
模块构成
授权方式
认证方式
集成过程
官方demo
代码集成
依赖
授权服务AuthorizationServerConfig配置
重要组件
测试
查看授权服务配置
访问授权服务
授权
回调
获取 access_token
获取用户信息
个性化改造
目标
基础知识
Spring Security OAuth2 Client
改造过程
auth-server改造
POM
持久化改造
AuthorizationServerConfig改造
sql脚本
DefaultSecurityConfig修改
UserService配置
异常处理
测试
根据刷新码 refresh_token 换token
自定义用户信息
userService新增方法
定义用户信息格式返回handler
SecurityFilterChain改造
测试
auth-client客户端添加
配置
controller
测试
控制台
集成GateWay
代办事项 sql脚本
背景 基于 Spring Cloud Alibaba 架构下，需要一个统一授权中心，与 gateway 配合使用实现微服务的授权与认证，下面主要介绍整个集成过程，基于springboot3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c30f23b35c79406e7589a8cb2811c055/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a872b2cca20886f263922089175bceb/" rel="bookmark">
			【Python】Python实现串口通信（Python&#43;Stm32）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎉欢迎来到Python专栏~Python实现串口通信
☆* o(≧▽≦)o *☆嗨~我是小夏与酒🍹 ✨博客主页：小夏与酒的博客 🎈该系列文章专栏：Python学习专栏
文章作者技术和水平有限，如果文中出现错误，希望大家能指正🙏📜 欢迎大家关注！ ❤️
🎉 目录-Python实现串口通信 一、实现效果二、说明三、Python串口通信代码详解3.1 包下载3.2 代码详解 四、Stm32串口通信4.1 硬件部分4.2 代码部分 五、参考文章 一、实现效果 🥝视频演示：
Python和Stm32实现串口通信演示
🥝图片展示：
PyCharm端发送数据：
stm32接收数据并回传：
二、说明 Python技能树：Python入门技能树。
版本：Python 3.10。
IDE：PyCharm。
自制Stm32f103原理图与PCB：【stm32开发】stm32+oled最小系统板资料（原理图、PCB、示例代码）【六一】
需要本文章完整项目文件的话（Python串口通信代码+stm32-oled最小系统板资料+stm32串口通信完整项目），可以从该链接下载：【Python+Stm32串口通信】完整项目资料，或者三连本文章之后私聊我免费领取哦~
三、Python串口通信代码详解 3.1 包下载 直接：
pip install pyserial 然后等待包的下载和安装完成。
3.2 代码详解 先上本次文章的完整代码：
import serial from time import sleep def recv(serial): while True: data = serial.read_all() if data == '': continue else: break sleep(0.02) return data def send(send_data): if (serial.isOpen()): serial.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a872b2cca20886f263922089175bceb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1218a9847fbc4e4e4a03967ff47c275/" rel="bookmark">
			【数据结构常见七大排序（一）】—插入排序篇【直接插入排序】And【希尔排序】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.排序的概念及其运用
1.1排序的概念
1.2排序运用
1.3常见的七大排序
2.直接插入排序
2.1基本思想
2.2直接插入排序
2.3动图助解
2.4直接插入排序源码
2.5直接插入排序的特性总结
3.希尔排序( 缩小增量排序 )
3.1希尔排序概念及思想
3.2希尔排序图解
3.3希尔排序源码
3.4希尔排序的两种预排序图解
3.5希尔排序的特性总结
1.排序的概念及其运用 1.1排序的概念 排序： 所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。 稳定性： 假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次 序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。 内部排序： 数据元素全部放在内存中的排序。 外部排序： 数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。 1.2排序运用 1.3常见的七大排序 后面的排序博客也是围绕下面这些排序来讲解的哦，对排序感兴趣的可以关注下喔！！！
2.直接插入排序 从1.3的图中我们也可以发现插入排序有两种类型—【直接插入排序】、【希尔排序】 它们都属于插入排序，希尔排序是直接插入排序的优化形式。 2.1基本思想 直接插入排序是一种简单的插入排序法，其基本思想是： 把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为 止，得到一个新的有序序列 。 实际中我们玩扑克牌时，就用了插入排序的思想 2.2直接插入排序 当插入第 i(i&gt;=1) 个元素时，前面的 array[0],array[1],…,array[i-1] 已经排好序，此时用 array[i] 的排序码与array[i-1],array[i-2],…的排序码顺序进行比较，找到插入位置即将 array[i] 插入，原来位置上的元素顺序后移。 2.3动图助解 插入排序动图
2.4直接插入排序源码 void InsertSort(int* a, int n) { for (int i = 0; i &lt; n - 1; ++i) { // [0,end]有序，把end+1位置的值插入，保持有序 int end = i; int tmp = a[end + 1];//插入的值和前面[0,end]的值进行比较 while (end &gt;= 0) { if (tmp &lt; a[end])//插入的值小，就往前挪一下 { a[end + 1] = a[end]; --end; } else//到这里就是数组中的值&lt;插入的值 || 整个[0,end]的值都&gt;插入的值 { break; } } a[end + 1] = tmp;//放入插入值 } } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1218a9847fbc4e4e4a03967ff47c275/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b870aa5eb3c9d8792a45ea9830d962e/" rel="bookmark">
			在java中将inputStream对象转换为File对象（不生成本地文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 需求说明 在后端中通过POI生成Excel文件流，将输出流（outputStream）转为输入流（inputStream）后又需要将输入流（inputStream）转为File对象
问题：如果需要将输入流（inputStream）转为File对象，则必须要根据本地路径去生成一个File对象才行，也就是说不管怎样本地都必须要生成出来一个文件
问题解决 在经过一系列的资料查询后，发现如下方式可以大致满足需求
import org.apache.commons.io.IOUtils; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; public class StreamUtil { static final String PREFIX = "stream2file";//前缀字符串定义文件名；必须至少三个字符 static final String SUFFIX = ".tmp";//后缀字符串定义文件的扩展名；如果为null，则将使用后缀".tmp" public static File stream2file (InputStream in) throws IOException { final File tempFile = File.createTempFile(PREFIX, SUFFIX); tempFile.deleteOnExit(); try (FileOutputStream out = new FileOutputStream(tempFile)) { IOUtils.copy(in, out); } return tempFile; } } 我们运行以上程序后tempFile即为我们需要的File对象。
看到这里你可能会好奇，这不是也在本地生成了个文件吗？但是它生成的文件位置是存储在以下的（计算机的临时文件目录中），所以可以看成没有在本地生成文件：
C:\Users\TP\AppData\Local\Temp\tmp2447618135336474361.txt 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edf251ab4f832e9b65dd850038cd13c5/" rel="bookmark">
			二叉树OJ题：LeetCode--101.对称二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		朋友们、伙计们，我们又见面了，本期来给大家解读一下LeetCode中第144道二叉树OJ题，如果看完之后对你有一定的启发，那么请留下你的三连，祝大家心想事成！
数据结构与算法专栏：数据结构与算法
个 人 主 页 ：stackY、
C 语 言 专 栏：C语言：从入门到精通
LeetCode--101.对称二叉树： https://leetcode.cn/problems/symmetric-tree/
目录
1.题目介绍
2.实例演示
3.解题思路
题目分析：
代码演示：
1.题目介绍 给你一个二叉树的根节点 root ， 检查它是否轴对称。
2.实例演示 3.解题思路 题目分析： 判断一颗二叉树是否为轴对称二叉树，在这里就要注意一个比较类似的点--判断一个二叉树的左右子树是否相等，这两个问题有很多相似的地方，我们可以画图来看一看：
可以看到二者大同小异，轴对称问题转换到二叉树中就是一个根节点的左右子树中左子树的左根节点等有右子树的右根节点，然后将都转化为根、左子树、右子树的子问题。
根据提示二叉树的结点个数至少有一个，因此我们可以直接来访问左右子树，因此为了方便，我们可以设置一个子函数，这个判断的过程在这个子函数中完成，所以只需要将左右子树传递给子函数即可，那么在子函数里面我们首先就要判断传过来的左右子树是否为空，若都为空，则满足轴对称条件，若只有一个为空，那么则不满足，如果都不为空，那么就需要判断它们两个结点是否相等，如果不相等，那么则不满足条件，如果相等，就继续递归遍历它的左右子树，直到遍历完整颗二叉树。
代码演示： /** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ bool _isSymmetric(struct TreeNode* left_root, struct TreeNode* right_root) { //左右子树都为空，则表示对称 if(left_root == NULL &amp;&amp; right_root == NULL) { return true; } //若有一个不为空，则不对称 if(left_root == NULL || right_root == NULL) { return false; } //都不为空则判断是否满足轴对称的特点 if(left_root-&gt;val !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edf251ab4f832e9b65dd850038cd13c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8115592ca65a683044a377bcc6df275/" rel="bookmark">
			【近场社交项目】数据库系统期末设计——需求分析部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【近场社交项目】数据库系统设计——需求分析😎 前言🙌1.需求求分析(用户部分为例）1.2用户数据字典1.2.1用户信息表（数据结构）：数据项间的关系和结构定义： 1.2.2.个人资料表（数据结构）：1.2.3.标签信息表（数据结构）：3.2.4.用户-标签关系表（数据结构）：1.2.5. 文化内容详情表：（数据结构）：1.2.6订单（基础结构）1.2.7用户预定社交场所的订单细节（基础结构）1.2.8 会员信息表1.2.9用户预定社交场所的订单（审核）二、处理过程要求：3.2.10用户可以进行下单业务操作： 总结撒花💞 😎博客昵称：博客小梦
😊最喜欢的座右铭：全神贯注的上吧！！！
😊作者简介：一名热爱C/C++，算法等技术、喜爱运动、热爱K歌、敢于追梦的小博主！
😘博主小留言：哈喽！😄各位CSDN的uu们，我是你的博客好友小梦，希望我的文章可以给您带来一定的帮助，话不多说，文章推上！欢迎大家在评论区唠嗑指正，觉得好的话别忘了一键三连哦！😘
前言🙌 哈喽各位友友们😊，我今天又学到了很多有趣的知识，现在迫不及待的想和大家分享一下！😘我仅已此文，分享数据库系统期末设计——需求分析部分*~ 都是精华内容，可不要错过哟！！！😍😍😍
1.需求求分析(用户部分为例） 1.2用户数据字典 1.2.1用户信息表（数据结构）： 属性名：用户ID、用户名、密码、手机号（账号）、邮箱。
数据项：用户的ID、用户名、密码、手机号（账号）、邮箱。
数据结构：用户信息表
数据流：通过两种途径获得用户数据：
1）由用户通过我们平台的注册页面、用户个人页面通过完善信息，填写上述信息，完成数据的收集；
2）通过用户个人的微信授权获取用户的上述必要信息。
数据项间的关系和结构定义： 1）用户ID、用户名、密码、手机号（账号）、邮箱都是可以唯一对应一个用户的，其中设置用户ID为这张表的主码。
2）约束条件：在定义的时候，各个属性都是设置 NOT NULL(非空约束)。UNIQUE（唯一） 的约束条件，从而保证数据的完整性。
3）各个属性的域：
用户ID：varchar类型 设置为00001~99999（考虑到自身平台大小，以及用户的预期最大数量进行考量）；
用户名：v varchar 类型， 4到12字节长度。根据我国《姓名登记条例》，对于姓名的规定是2~6个汉字的。
密码：varchar类型 6~32个字符长度；
手机号：char 类型 固定为11个字符长度，其还可以是用户的登陆的账号
邮箱：char类型，长度不超过35个字符（最长的电子邮件是35个字符长度）。
1.2.2.个人资料表（数据结构）： 属性名：用户ID（主码）、姓名、性别、出生日期、职业。
数据项：用户ID、姓名、性别、出生日期、职业。
数据结构：个人资料表。
数据流：通过两种途径获得用户数据：
1）用户个人页面通过完善信息，填写上述信息，完成数据的收集；
2）通过用户个人微信授权获取用户的上述必要信息。
数据项间的关系和结构定义：
1）将个人资料表的用户ID设置为个人资料表的主码。用户信息表和个人资料表通过主键进行关联。
2）约束条件：在定义的时候，各个属性都是设置 NOT NULL(非空约束)，不必设置UNIQUE约束条件，因为姓名、性别、出生日期、职业、内容都是可以重复的。用户ID是主码，已经设置了非空唯一的约束了。
3）各个属性的域：
用户ID：varchar类型 设置为00001~99999（考虑到自身平台大小，以及用户的预期最大数量进行考量）；
用户名：varchar 类型， 412字节长度。根据我国《姓名登记条例》，对于姓名的规定是26个汉字的。
性别：char 类型 ，2个字节长度。
出生日期：char 类型， yyyy-mm-dd的格式，长度为10个字节长度。
职业：varchar 类型 ，0~255字节长度。
1.2.3.标签信息表（数据结构）： 属性名：标签ID、标签类别，标签描述
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8115592ca65a683044a377bcc6df275/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63c2b3846f55615e29d7c1d791dd1840/" rel="bookmark">
			前端篇（第二节）-使用npm安装pnpm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pnpm安装 一、安装教程1、npm全局安装pnpm 二、查看镜像地址三、其他命令1、设置镜像地址2、设置包存放地址3、查询包存放地址 一、安装教程 1、npm全局安装pnpm 执行下面命令安装pnpm
npm install -g pnpm
提示npm版本过低
执行下面命令升级npm
npm install -g npm@9.8.0
重新执行下面命令安装pnpm
npm install -g pnpm
执行下面命令查询pnpm是否安装成功
pnpm -v
二、查看镜像地址 执行下面命令
pnpm config get registry
访问https://registry.npm.taobao.org 会跳转到 https://registry.npmmirror.com/ 镜像（中国镜像地址）
三、其他命令 1、设置镜像地址 pnpm set registry https://registry.npmmirror.com/
2、设置包存放地址 pnpm config set store-dir C:/pnpmStore
3、查询包存放地址 pnpm store path
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/516bdd2e0490e2daeb997c8cc68e3816/" rel="bookmark">
			【数据结构与算法】最小生成树之普里姆(Prim)算法和克鲁斯卡尔(Kruskal)算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌱博客主页：大寄一场.
🌱系列专栏：数据结构与算法
😘博客制作不易欢迎各位👍点赞+⭐收藏+➕关注
目录
前言
一、最小生成树的概念
二、最小生成树的求解方法
三、练习题
四、最小生成树在实际应用中的例子
前言 最近非科班的同学学到了最小生成树并询问我，于是想趁热打火，来总结顺便复习一下~
最小生成树(Minimum Spanning Tree,简称MST)是一个无向连通图中包含所有顶点的最短边集。在许多实际问题中，找到一个最小生成树对于理解和解决这些问题至关重要。本文将介绍最小生成树的概念、求解方法以及其在实际应用中的一些例子。
一、最小生成树的概念 假设我们有一个无向连通图G=(V,E),其中V是顶点集合，E是边集合。我们需要找到一个最小生成树，使得每个顶点都至少与一条边相连。这个最小生成树就是MST。
二、最小生成树的求解方法 1.Prim算法 Prim算法是一种贪心算法，用于在具有有向边的加权图中寻找最小生成树。算法的基本思想是从任意一个顶点开始，沿着权重最小的边进行扩展，直到找到整个MST
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #define INF INT_MAX // 邻接矩阵表示的无向图 typedef struct { int V; // 顶点数 int E; // 边数 int G[100][100]; // 邻接矩阵 } Graph; // 获取边的权重 int getWeight(Graph G, int u, int v) { return G[u][v]; } // Kruskal算法求最小生成树 Graph primMST(Graph G) { int V = G.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/516bdd2e0490e2daeb997c8cc68e3816/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42d67a0f1892fc157939adf091e10869/" rel="bookmark">
			【自学笔记】在SQL Server中创建用户角色及授权(使用SQL语句)更新2023.07.06
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		--&lt;在SQL Server中创建用户角色及授权(使用SQL语句)&gt;更新2023.07.06 --1. 首先在 SQL Server 服务器级别，创建登陆帐户（create login） --2. 创建数据库用户（create user）： --3. 通过加入数据库角色，赋予数据库用户“dba”权限： --创建登陆帐户（create login） create login dba with password='abcd1234@', default_database=AliSysDB --这时候，dba 帐户就可以连接到 SQL Server 服务器上了。但是此时还不能 访问数据库中的对象 --（严格的说，此时 dba 帐户默认是 guest 数据库用户身份， 可以访问 guest 能够访问的数据库对象）。 --要使 dba 帐户能够在 AliSysDB 数据库中访问自己需要的对象， 需要在数据库 AliSysDB 中建立一个“数据库用户”， --赋予这个“数据库用户” 某些访问权限，并且把登陆帐户“dba” 和这个“数据库用户” 映射起来。 --创建“数据库用户”和建立映射关系只需要一步即可完成 --为登陆账户创建数据库用户（create user）,在AliSysDB数据库中的security中的user下可以找到新创建的dba create user dba for login dba with default_schema=dbo --通过加入数据库角色，赋予数据库用户“db_owner”权限 exec sp_addrolemember 'db_owner', 'dba' ----让 SQL Server 登陆帐户“dba”访问多个数据库 use DBErp create user dba for login dba with default_schema=dbo exec sp_addrolemember 'db_owner', 'dba' --&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --删除数据库用户： drop user dba --删除 SQL Server登陆帐户： drop login dba --禁用登陆帐户 alter login dba disable --启用登陆帐户 alter login dba enable --登陆帐户改名 alter login dba with name=dba_tom --登陆帐户改密码： alter login dba with password='aabb@ccdd' --数据库用户改名： alter user dba with name=dba_tom --更改数据库用户 defult_schema： alter user dba with default_schema=sales --使用T-SQL创建用户 --添加角色 use AliSysDB go sp_addlogin 'test_db','123456','AliSysDB' go sp_addsrvrolemember 'test_db','sysadmin' go sp_adduser 'test_db','test_db','db_owner' go --使用存储过程来完成用户创建 --下面一个实例来说明在sqlserver中如何使用存储过程创建角色，重建登录，以及如何为登录授权等问题 USE DBErp --创建角色 r_test EXEC sp_addrole 'r_test' --添加登录 l_test,设置密码为pwd,默认数据库为pubs EXEC sp_addlogin 'l_test','a@cd123','DBErp' --为登录 l_test 在数据库 pubs 中添加安全账户 u_test EXEC sp_grantdbaccess 'l_test','u_test' --添加 u_test 为角色 r_test 的成员 EXEC sp_addrolemember 'r_test','u_test' --授予角色 r_test 对 效期查询 表的所有权限 GRANT ALL ON 效期查询 TO r_test --ALL 权限已不再推荐使用，并且只保留用于兼容性目的。它并不表示对实体定义了 ALL 权限。 --如果要收回权限，可以使用如下语句。（可选择执行） revoke all on 效期查询 from r_test --授予角色 r_test 对 实时库存查询 表的 SELECT 权限 GRANT SELECT ON 实时库存查询 TO r_test --用l_test登陆,发现可以查询Sales.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42d67a0f1892fc157939adf091e10869/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9edbe99ca60b3d951e53d048d6af403b/" rel="bookmark">
			【Java系列】Java虚拟机—类加载器介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Java虚拟机 Java虚拟机（Java Virtual Machine，JVM）是一个能够执行 Java 字节码的虚拟计算机。它是 Java 技术的核心部分，是 Java 应用程序运行的基础。
Java 程序在编译后会生成字节码（bytecode），这种字节码是一种中间代码，它不依赖于具体的操作系统和硬件平台。
JVM 就是在特定的操作系统和硬件平台上执行这种字节码的虚拟计算机。
JVM 负责解释和执行 Java 字节码，还提供了垃圾回收、内存管理、安全检查等功能，使得 Java 程序具有跨平台的特性。
Java 字节码介绍 Java字节码是一种中间代码，是Java程序编译后的产物，它并不是机器码，而是一种与平台无关的二进制码。Java字节码可以被JVM所解释和执行，JVM会将字节码转化为机器码并执行。
Java字节码是由Java源代码编译而来，经过Java编译器编译后，生成相应的.class文件，其中包含了Java字节码。
Java字节码采用的是一种栈式架构，在执行时，操作数和指令都是基于栈操作的，这与基于寄存器的机器码有所不同。
Java字节码具有与平台无关的特性，这是因为Java虚拟机的存在，它可以在不同的平台上执行Java字节码，而不需要修改代码。因此，Java字节码是Java语言实现跨平台的基础。
2 JVM子系统 Java虚拟机（Java Virtual Machine，JVM）是一个能够执行Java字节码的虚拟计算机。它是Java技术的核心部分，是Java应用程序运行的基础。
JVM主要由三个子系统组成：
类加载器运行时数据区执行引擎 今天主要介绍一下类加载器。
2.1 类加载器 类加载器是Java虚拟机（JVM）的一个重要组成部分，它的主要任务是将编译后的Java类文件加载到内存中，并转换为可以被JVM执行的代码。类加载器是实现Java语言跨平台的基础，也是Java程序运行的关键。
Java类加载器的主要任务是将编译后的Java类文件加载到JVM中，并将其转换为可以执行的形式。Java类加载器可以分为三个层次：
引导类加载器扩展类加载器应用程序类加载器自定义类加载器 Java类加载器的种类 Java类加载器按照加载类的位置和方式可以分为以下几种：
引导类加载器 引导类加载器是JVM自带的类加载器，它负责加载JVM自带的核心类库，如java.lang包中的类等。
它是JVM的内置部分，在JVM启动时就已经存在。
扩展类加载器 扩展类加载器负责加载Java的扩展类库，如JAVA_HOME/lib/ext目录下的类库、JAVA_HOME/lib/ext目录下的类库。
它是由Java虚拟机实现的一个类加载器。
应用程序类加载器 系统类加载器也称为应用程序类加载器（Application ClassLoader），负责加载应用程序中的类库。
是JVM默认的类加载器。它是由Java虚拟机实现的一个类加载器。
自定义类加载器 自定义类加载器是Java程序员根据自身的需求自己实现的类加载器。Java虚拟机提供了ClassLoader类，程序员可以继承ClassLoader类，实现自己的类加载器。
Java类加载器的工作原理 Java类加载器的工作原理是按照“双亲委派”模型来实现的。当一个类需要被加载时，首先会委托给父类加载器进行加载，如果父类加载器无法加载该类，则会依次向上委托给其父类加载器，直到到达引导类加载器，如果引导类加载器也无法加载该类，则会委托给自定义类加载器来进行加载。
双亲委派模型可以保证类的唯一性和安全性，避免重复加载和恶意篡改。
例如，如果一个应用程序中已经有了一个java.lang.String类，如果再次尝试加载java.lang.String类，就会委托给系统类加载器进行加载，而不是重新定义一个类。
Java类加载器的优化 Java类加载器的性能优化可以从以下几个方面入手：
缓存机制类的预加载Class文件的优化 缓存机制 Java类加载器在加载类时会进行缓存，可以通过设置缓存大小和缓存策略来优化类加载器的性能。
类的预加载 可以通过在程序启动时预加载一些常用的类，减少类加载器的工作量，提高程序的启动速度。
Class文件的优化 可以通过优化Class文件中的代码结构和字节码格式，减少类加载器的解析和转换时间，提高类的加载速度。
总结 Java类加载器是Java虚拟机的一个重要组成部分，它负责将编译后的Java类文件加载到内存中，并转换为可以被JVM执行的代码。
Java类加载器按照加载类的位置和方式可以分为引导类加载器、扩展类加载器、系统类加载器和自定义类加载器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9edbe99ca60b3d951e53d048d6af403b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/597/">«</a>
	<span class="pagination__item pagination__item--current">598/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/599/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>