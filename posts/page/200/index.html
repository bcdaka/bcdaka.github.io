<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d668121eb47716775e3919f026d047f9/" rel="bookmark">
			大数据基础知识【大数据导论】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各位大佬好 ，这里是阿川的博客，祝您变得更强 个人主页：在线OJ的阿川
大佬的支持和鼓励，将是我成长路上最大的动力
阿川水平有限，如有错误，欢迎大佬指正
大数据基础知识前 必看
【大数据导论】—大数据序言
【大数据导论】—大数据、人工智能、云计算、物联网、区块链序言
目录 大数据素养大数据基本知识 大数据素养 技术性内容
采集处理储存分析技术工具
非技术性内容
大数据安全大数据伦理大数据思维
大数据基本知识 其中大数据交易
买卖数据的活动，是以货币为媒介 获取数据商品的过程
数据商品三大特征
处理后的数据才能交易
数据交易主体涉及众多
交易过程涉及多个产业链
大数据交易形式 大数据交易公司
提供个人数据场所的公司
数据交易所
API模式
向用户提供接口，允许用户对平台数据进行访问
大数据交易技术支撑
大数据交易发展现状
大数据数据来源 政府公开数据企业内部数据数据供应方数据网页爬虫数据
大数据数据产品类型 API数据包云服务解决方案数据产品数据定制服务
大数据交易平台类型 综合数据服务平台
为用户提供定制化的服务，涉及数据的处理和加工第三方数据交易平台
对交易过程进行监管，并提供数据出售、数据购买、数据供应方查询、数据需求发布等一系列服务
从运行角度划分： 政府主导的大数据交易平台企业以市场需求为导向建立的大数据交易平台产业联盟性质的大数据交易平台
大数据交易平台的运营模式
数据中介和数据处理加工功能的交易平台
只具备中介功能的交易平台
其中大数据思维
大数据思维主要指
全样而非抽样
因为有了分布式储存和处理技术，从而可以对全部的数据进行分析，而不是只能对小样本处理效率而非精确
处理数据时往往要"秒级"响应，所以效率往往是被关注的重点，分析的精确度达到一定的程度即可。相关而非因果
解释事物背后发展的机理
预测未来可能发生的事件以数据为中心
以海量的数据进行计算，从而推测结果我为人人，人人为我
其中涉及 数据采集数据处理信息发布
其中大数据安全
重点关注数据的
保密性完整性可用性
大数据安全的隐患 大数据成为网络攻击的显著目标
大数据加大隐私泄露风险
大数据技术被应用到攻击手段中
大数据成为高级可持续攻击的一个载体
大数据安全的变化
从静态安全到动态安全
大数据安全范围 隐私和个人信息安全
其中包含个人的
其中大数据伦理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d668121eb47716775e3919f026d047f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb7a0749becaa46ee8c18c96e754a11d/" rel="bookmark">
			MySQL——索引介绍及索引的分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 官方介绍索引是帮助MySQL高效获取数据的数据结构。
提取句子主干，就可以得到索引的本质：索引是数据结构。
索引的分类 在一个表中，主键索引只能有一个，唯一索引可以有多个
· 主键索引（PRIMARY KEY）：唯一的标识，主键不可重复，只能有一个列作为主键
· 唯一索引（UNIQUE KEY）：避免重复的列出现，唯一索引可以重复（多个列都可以标识为唯一索引）
· 常规索引（KEY/INDEX）：默认的，可以用key、index关键字进行设置
· 全文索引（FULLTEXT）：只能在文本类型CHAR,VARCHAR,TEXT类型字段上创建全文索引。快速定位数据。
基础语法：
-- 1.在创建表的时候，给字段增加索引 -- 2.创建完毕后，增加索引 -- 显示所有的索引信息 SHOW INDEX FROM student -- 增加一个索引 ALTER TABLE school.student ADD FULLTEXT INDEX `studentname`(`studentname`); -- EXPLAIN 分析SQL语句执行的状况 EXPLAIN SELECT * FROM student -- 非全文索引 EXPLAIN SELECT * FROM student WHERE MATCH(studentname) AGAINST('张'); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2e75229ea00df8f733c1369edb29145/" rel="bookmark">
			AI是在帮助开发者还是取代他们
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.概述
1.1.AI助力开发者
1.2.AI对开发者的挑战
2.AI工具现状
2.1. GitHub Copilot
2.2. TabNine
2.3.小结
3.AI对开发者的影响
3.1.对开发者的影响
3.2.开发者需要掌握的新技能
3.3.在AI辅助的环境中保持竞争力的策略
4.AI开发的未来
5.总结
1.概述 生成式人工智能（AIGC）在软件开发领域确实带来了显著的变化，包括自动化常规任务、提升开发效率、辅助代码编写与调试等方面。这种技术的引入对开发者的影响是双面的，即既有积极的一面也有潜在的挑战。
1.1.AI助力开发者 1. 提高生产效率：AI工具可以通过自动生成代码框架、完成重复性工作或者修复简单的错误来减轻开发者的负担，使其能够将注意力集中在更复杂的任务上。
2. 错误检测和代码优化：AI的引入提高了错误检测的准确性，使得代码的质量得到了提升。同时，AI还能够建议性能优化方案，帮助开发者改善现有代码。
3. 学习和成长：借助AI工具，开发者可以快速学习新技能，掌握新的编程语言或框架，从而不断增强自己的竞争力。
1.2.AI对开发者的挑战 1. 技能需求的变化：随着AI工具承担更多的编码任务，对基础编程技能的直接需求可能会下降，而对于能够设计、监督并优化AI系统的高级技能的需求会增加。
2. 职业不确定性：一些简单、重复性的编程工作可能会被AI自动化取代，导致对这类岗位的需求减少。
3. 工作方式的改变：在一个由AI辅助的环境中，开发者需要学会与AI合作，而不是仅仅依赖于自己的编程技巧。这意味着开发者需要适应在人机协作模式下工作。
2.AI工具现状 在当前市场上，有多种AI开发工具可以帮助开发者提高效率，其中包括GitHub Copilot、TabNine等。主要通过代码补全、智能提示、代码审查等功能来协助开发者更快地编写代码和解决问题。下面将分别介绍这些工具的功能、局限性以及如何帮助开发者提高效率。
2.1. GitHub Copilot GitHub Copilot是GitHub推出的一款AI编程助手，可以通过分析代码上下文来提供智能代码补全建议。
GitHub Copilot的功能包括：
代码补全：根据开发者正在编写代码的上下文，Copilot可以提供建议，从而加快编码速度。项目感知：Copilot能够学习开发者所在项目的代码风格和架构，从而提出更符合项目规范的建议。代码审查：Copilot可以识别潜在的代码问题，并提供改进建议。 GitHub Copilot的局限性主要在于：
依赖网络：Copilot需要连接到互联网才能正常工作，在某些环境下可能受限。代码质量：尽管Copilot可以提供代码补全建议，但可能不会总是生成最优质的代码。 2.2. TabNine TabNine是一款基于深度学习的代码补全工具，可以在多种编程环境中工作，包括Visual Studio Code、IntelliJ IDEA等。
TabNine的功能包括：
代码补全：TabNine可以根据开发者正在编写代码的上下文提供智能补全建议。跨平台：TabNine支持多个编程环境和操作系统，方便开发者在不同平台间切换。自定义模型：用户可以训练自己的模型来适应特定的代码风格和需求。 TabNine的局限性主要在于：
本地化：TabNine需要将代码传输到服务器进行处理，可能引发关于数据隐私和安全的担忧。学习曲线：对于一些开发者来说，使用TabNine可能需要一定的学习和适应时间。 2.3.小结 AI开发工具如GitHub Copilot和TabNine可以帮助开发者提高效率，通过代码补全、智能提示等功能减少编程工作量。然而，也存在一定的局限性，如依赖网络、可能产生的数据隐私问题等。开发者应根据自己的需求和环境选择合适的工具。
3.AI对开发者的影响 AI工具对开发者的日常工作产生了深远的影响，使得开发流程更加自动化和高效。随着AI技术的快速发展，开发者需要掌握一系列新技能，并采取相应策略以保持在行业中的竞争力。
3.1.对开发者的影响 1. 代码自动生成与优化：利用AI工具，如GitHub Copilot等，开发者可以通过自然语言描述来生成代码，极大提高编码效率。
2. 错误检测与修复：AI可以帮助检测代码中的潜在错误，并提供修复建议，从而减少调试时间。
3. 软件测试：AI可以自动运行测试用例，并根据用户行为和历史数据预测潜在问题，提高测试的全面性与效率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2e75229ea00df8f733c1369edb29145/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d31ac9dbe705a70c623f4acca3573c0c/" rel="bookmark">
			【设计模式】策略模式（定义 | 特点 | Demo入门讲解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 定义策略模式的结构 QuickStart | DemoStep1 | 策略接口Step2 | 策略实现Step3 | 上下文服务类Step4 | 客户端 策略模式的特点优点缺点 定义 策略模式Strategy是一种行为模式，它能定义一系列算法，并将每种算法分别放入到独立的类中，以使算法的对象能够相互替换。
比如，你去机场，可以有三种策略：
自行车公共汽车出租车 这三种交通方案，自行车不要钱，能欣赏风景；公共汽车便宜速度快；出租车方便速度快，节省时间。这三种方案代表了三种策略，算法。
将上面三种出行方案封装，我们可以灵活选用！
策略模式的结构 通过上图我们知道，策略模式分为四个结构：
策略接口【核心】策略实现类上下文Context 具体要实现的业务代码，业务逻辑。 客户端Client 决定使用哪种策略。 QuickStart | Demo 接下来用一个非常容易理解的案例让大家掌握策略模式。
项目结构如下：
├─.idea
├─src
│ ├─main
│ │ ├─java
│ │ │ └─com
│ │ │ └─linghu
│ │ │ └─designer
│ │ │ ├─dao
│ │ │ │ └─impl
│ │ │ └─service
│ │ └─resources
│ └─test
│ └─java
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d31ac9dbe705a70c623f4acca3573c0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8f3347907d69e580accaffa485198be/" rel="bookmark">
			华为路由器静态路由配置（eNSP模拟实验）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验目标 如图下所示，让PC1ping通PC2
具体操作 配置PC设备ip 先配置PC1的ip、掩码、网关。PC2也做这样的配置
配置路由器ip 配置G0/0/0的ip信息
#进入系统 &lt;Huawei&gt;system-view #进入GigabitEthernet0/0/0接口 [Huawei]int G0/0/0 #设置接口的ip和掩码 [Huawei-GigabitEthernet0/0/0]ip add 192.168.1.254 24 配置G0/0/1的ip信息
#进入GigabitEthernet0/0/1接口 [Huawei-GigabitEthernet0/0/0]int G0/0/1 #配置接口ip地址和掩码 [Huawei-GigabitEthernet0/0/1]ip add 1.1.1.1 24 查看接口摘要
#查看接口摘要（简写） [Huawei-GigabitEthernet0/0/1]dis ip int br #查看接口摘要（完整） [Huawei-GigabitEthernet0/0/1]display ip interface brief 另外一个路由器也按照这样配置好接口的ip
ping测试 此时PC1可以ping通网关192.168.1.254和1.1.1.1
但是无法ping通1.1.1.2和192.168.2.1
配置静态路由 在AR2路由器上设置静态路由，目标网段是192.168.2.0，下一跳是1.1.1.2
#静态路由目标网段、下一跳 [Huawei]ip route-static 192.168.2.0 24 1.1.1.2 查看路由表
#查看路由表 [Huawei]display ip routing-table 在路由表中可以查到刚刚设置的静态路由信息
另外一个路由器也按照这样配置好静态路由
ping测试 PC1可以ping通PC2
删除一条静态路由测试 这里我们可以删除掉AR3的静态路由，试试
#删除一条静态路由 [Huawei]undo ip route-static 192.168.1.0 24 1.1.1.1 查看AR3路由表，已经没有那条静态路由了
此时，PC1已经无法ping通PC2。说明光有去的静态路由不行，回来的静态路由也要写上才能通
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a03631ef33a64b8e6b5ed65d332af3f8/" rel="bookmark">
			桥接模式与适配器模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、共性和区别 桥接设计模式和适配器设计模式的共同点和明显，它们都是使两种不同的类配合工。
二者的区别在于，适配器模式是将已有的两个不同接口接口组合到一起，使得适配器同时拥有两个不同接口的功能，其目的是使两个不兼容的接口协调工作；桥接模式目的是抽象和实现分离，实现的改变不影响抽象，抽象的变化不影响实现，可以有效的应对具体业务的变化，以及业务实现的横向扩展。
二、桥接模式 1、函数类声明 #ifndef BRIDGE_H #define BRIDGE_H #include &lt;iostream&gt; using namespace std; ///定义抽象业务类 class AbstractObj{ public: virtual void abstractOpt()=0; }; /// 定义具体业务实现类A class ObjImplA: public AbstractObj{ public: ObjImplA(); ~ObjImplA(); void abstractOpt() override; }; /// 定义具体的业务实现了B class ObjImplB: public AbstractObj{ public: ObjImplB(); ~ObjImplB(); void abstractOpt() override; }; /// 定义桥器 class IBridge{ public: virtual void bridgeOpt()=0; }; /// 桥接器具体实现 class BridgeImpl: public IBridge{ /// 桥接器持有对抽象业务类的引用，不考虑具体实现，这样不管具体的业务怎么处理，都不会影响到接口，随着业务的扩张，业务横向增加，对于用户是无感的，用户只需要通过桥接器动态调用即可 private: AbstractObj* abstractObj; public: BridgeImpl(AbstractObj* abstractObj); ~BridgeImpl(); void bridgeOpt() override; }; #endif 2、函数定义 #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a03631ef33a64b8e6b5ed65d332af3f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c82b2110f5f094e070ce13a790ec816/" rel="bookmark">
			使用androidx.appcompat:appcompat:1.7.0无法运行的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： 使用 implementation ‘androidx.appcompat:appcompat:1.7.0’
出现无法运行的问题，编译都没有问题
AGPBI: {“kind”:“error”,“text”:“java.lang.NullPointerException”,“sources”:[{“file”:“C:\Users\10557\.gradle\caches\transforms-4\1edd4499edd7eb0b525a2dccf436f680\transformed\appcompat-resources-1.7.0-runtime.jar”}],“tool”:“D8”}
AGPBI: {“kind”:“error”,“text”:“java.lang.NullPointerException”,“sources”:[{“file”:“C:\Users\10557\.gradle\caches\transforms-4\15b33227282e2c4d2dffa561de8fe63f\transformed\appcompat-1.7.0-runtime.jar”}],“tool”:“D8”}
Execution failed for task ‘:app:mergeExtDexDebug’.
Could not resolve all files for configuration ‘:app:debugRuntimeClasspath’.
Failed to transform appcompat-resources-1.7.0.aar (androidx.appcompat:appcompat-resources:1.7.0) to match attributes {artifactType=android-dex, asm-transformed-variant=NONE, dexing-enable-desugaring=true, dexing-enable-jacoco-instrumentation=false, dexing-is-debuggable=true, dexing-min-sdk=21, org.gradle.category=library, org.gradle.dependency.bundling=external, org.gradle.libraryelements=aar, org.gradle.status=release, org.gradle.usage=java-runtime}.
Execution failed for DexingWithClasspathTransform: C:\Users\10557.gradle\caches\transforms-4\1edd4499edd7eb0b525a2dccf436f680\transformed\appcompat-resources-1.7.0-runtime.jar.
Error while dexing.
Failed to transform appcompat-1.7.0.aar (androidx.appcompat:appcompat:1.7.0) to match attributes {artifactType=android-dex, asm-transformed-variant=NONE, dexing-enable-desugaring=true, dexing-enable-jacoco-instrumentation=false, dexing-is-debuggable=true, dexing-min-sdk=21, org.gradle.category=library, org.gradle.dependency.bundling=external, org.gradle.libraryelements=aar, org.gradle.status=release, org.gradle.usage=java-runtime}.
Execution failed for DexingWithClasspathTransform: C:\Users\10557.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c82b2110f5f094e070ce13a790ec816/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68b43fdc5855f6d35b9637e2ca09023c/" rel="bookmark">
			Java返回前端Bigdecimal类型数据时“0E-8“及小数点多余0的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
问题描述:
解决方法:
重要代码：
问题描述: 项目中oracle数据库需要转换为mysql，Oracle中的表字段定义为number(36,16)类型的工具自动转换为mysql的decimal(36,16)。在Oracle数据库中，number(36,16)类型的字段，使用BigDecimal类型进行映射字段，能够正常获取到去除后缀0的值。MySQL数据库中存储为decimal(36,16)对应的字段，使用BigDecimal进行映射，会得到加后缀0的数值。例如在oracle中实际精度是16位的数值0.000345344，使用BigDecimal接收，会得到0.000345344，而mysql会得到的值为0.0003453440000000，这样返回给前端，就会有问题。这
解决方法: 1、按照业务需求，在mysql数据库下，修改每一个字段对应的精度。然后在代码中手动对BigDecimal类型的字段进行手动去0后缀处理。
2、在vo层进行json格式化中，进行去除0后缀。（这种方案不推荐，但要是想快速修改，可以采取）
重要代码： package com.xiayu.config; import com.fasterxml.jackson.core.JsonGenerator; import com.fasterxml.jackson.databind.JsonSerializer; import com.fasterxml.jackson.databind.SerializerProvider; import java.io.IOException; import java.math.BigDecimal; import java.util.Objects; public class CustomerBigDecimalSerialize extends JsonSerializer&lt;BigDecimal&gt; { @Override public void serialize(BigDecimal value, JsonGenerator gen, SerializerProvider serializers) throws IOException { if(Objects.nonNull(value)) { gen.writeNumber(value.stripTrailingZeros().doubleValue()); //去除0后缀,如果想统一进行保留精度，也可以采用类似处理 }else {//如果为null的话，就写null gen.writeNull(); } } } //在vo类字段中对字段加上@JsonSerialize注解 @JsonSerialize(using = CustomerBigDecimalSerialize.class) private BigDecimal totalExchangeBtc; //抵扣电费的usdt兑换的btc总量 @JsonSerialize(using = CustomerBigDecimalSerialize.class) private BigDecimal perTotalExchangeBtc; //兑换的btc总量对应每份的btc @JsonSerialize(using = CustomerBigDecimalSerialize.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68b43fdc5855f6d35b9637e2ca09023c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3c51f20a5d6fc0e954df8077bb4c6f4/" rel="bookmark">
			JavaScript之深入对象，详细讲讲构造函数与常见内置构造函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：哈喽，大家好，我是前端菜鸟的自我修养！今天给大家详细讲讲构造函数与常见内置构造函数，并提供具体代码帮助大家深入理解，彻底掌握！原创不易，如果能帮助到带大家，欢迎收藏+关注哦 💕
🌈🌈文章目录
一、深入对象与构造函数
1.构造函数
2.实例成员
3.静态成员
二、内置构造函数
1.Object
2.Array
3.包装类型
3.1 String
3.2 Number
一、深入对象与构造函数 目标：了解面向对象的基础概念，能够利用构造函数创建对象。
1.构造函数 构造函数是专门用于创建对象的函数，如果一个函数使用 new 关键字调用，那么这个函数就是构造函数。
&lt;script&gt; // 定义函数 function foo() { console.log('通过 new 也能调用函数...'); } // 调用函数 new foo; &lt;/script&gt; 总结：
使用 new 关键字调用函数的行为被称为实例化
实例化构造函数时没有参数时可以省略 ()
构造函数的返回值即为新创建的对象
构造函数内部的 return 返回的值无效！
注：实践中为了从视觉上区分构造函数和普通函数，习惯将构造函数的首字母大写。
2.实例成员 通过构造函数创建的对象称为实例对象，实例对象中的属性和方法称为实例成员。
&lt;script&gt; // 构造函数 function Person() { // 构造函数内部的 this 就是实例对象 // 实例对象中动态添加属性 this.name = '小明' // 实例对象动态添加方法 this.sayHi = function () { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3c51f20a5d6fc0e954df8077bb4c6f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/301bb8026c50caf836f36bc53863a903/" rel="bookmark">
			2024 热门前端 UI 组件库超全汇总！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文作者：试者才子酒中仙 前端充电宝
Radix UI 是一个开源的UI组件库，专为快速开发、易于维护和可访问性优化而设计。它是一个无样式的组件库，允许开发者完全控制组件的样式，同时提供了一套全面的UI组件和工具，帮助开发者构建美观、易于访问且具有高性能的应用。
在前端开发的过程中，UI 组件库扮演着至关重要的角色。它们不仅助力开发者迅速构建页面原型，还能确保页面风格的统一性，从而显著提升开发效率。本文就来盘点那些前端领域广泛认可且常用的 UI 组件库，为开发者提供参考。
图片
Web React Ant Design Ant Design是一个基于 React 的企业级UI设计语言和组件库，旨在统一中台项目的前端UI设计，提高设计和开发效率。它提供了一系列高质量的组件，支持自定义主题和国际化，注重无障碍设计，拥有活跃的社区支持，特别适合于构建高度定制化的企业级中后台系统。
图片
Github：GitHub - ant-design/ant-design: An enterprise-class UI design language and React UI library
Material UI Material UI是一款遵循Google Material Design规范的React UI组件库，提供了丰富、高质量的UI组件和样式，支持高度定制，并拥有庞大的社区支持，帮助开发者快速创建现代化、美观的Web应用。
图片
Github：https://github.com/mui/material-ui
Chakra UI Chakra UI是一个基于React的开源UI组件库，以其易用性、可访问性、响应式设计和灵活性著称，旨在帮助开发者快速构建现代且可访问的用户界面。它提供了丰富的可定制组件，支持暗黑模式，并拥有完善的文档和活跃的社区支持。
图片
Github：https://github.com/chakra-ui/chakra-ui
Mantine Mantine是一个基于React的开源UI框架，它提供了一套现代化、可定制且易于使用的组件库，旨在帮助开发者高效构建美观且功能丰富的Web应用。Mantine注重简洁的API设计、良好的可访问性以及灵活的主题定制。
图片
Github：https://github.com/mantinedev/mantine
NextUI NextUI是一个漂亮、快速、现代化的基于 React UI 组件库，专为简化开发流程和提升用户体验而设计。它基于Tailwind CSS和React Aria开发，提供了丰富的组件和工具，以帮助开发者构建美观、易用和可访问的用户界面。
图片
Github：https://github.com/nextui-org/nextui
Vue Element UI Element UI 是一套基于 Vue 2.0 的桌面端组件库，由饿了么前端团队开发和维护。它为开发者提供了一套丰富、高质量的UI组件，旨在帮助开发者快速构建美观、易用的 Web 应用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/301bb8026c50caf836f36bc53863a903/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ef0ee3450970e3782e9c50365ed10b3/" rel="bookmark">
			Stable Diffusion教程：如何实现人脸一致
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在AI绘画中，一直都有一个比较困难的问题，就是如何保证每次出图都是同一个人。今天就这个问题分享一些个人实践，大家和我一起来看看吧。
一. 有哪些实现方式
方式1：固定Seed种子值。
固定Seed种子值出来的图片人物确实可以做到一致，但Seed种子值是相对整个画面的，导致这种方式生成的新图片效果差别太小，可能除了人物的脸保存了一致，人物的姿势也保持了一致，甚至画面的背景也保持了一致，出来的图片太过单调。
此时我们虽然可以通过ContolNet来控制人物的姿势，但是效果并不可控。
方式2：使用roop插件
roop插件是我们常见的换脸插件，将生成的图片中人物都使用一张人脸图片去替换，可以很好地做到图片中人脸一致。关于使用roop插件实现换脸可以参考我之前的文章
方式3：针对多张真人照片训练LORA模型
LORA模型可以固定人物特征、动作特征和照片风格。同一个人物的多张真人照片去炼丹训练LORA模型需要一定的技术基础，而且调优费事费力，对很多人来说也不太现实。
方式4：直接利用已有的人物LORA模型
直接使用C站提供的LORA模型，我们也可以生成人脸基本一致的图片。这里的基本一致，不能百分百一致。因为每个人物Lora的训练数据集不一定很全面，主要包括数量、质量、角度等因素不同，出的图很难保证人脸完全一致。
方式5：使用ControlNet预处理Reference only
下面我们重点看一下方式4和方式5，尤其是方式5，是目前实现人脸一致效果的最好方式，不仅适用于人，而且还适用于动物，二次元。
二. LORA模型实现人脸一致的效果
01、LORA模型cuteGirlMix4
我们先通过一个实例看看如何通过LORA实现人脸一致效果。
大模型：majicmixRealistic_v6.safetensors
正向提示词：a beautiful girl, very delicate features, very detailed eyes and mouth, long hair, delicate skin, big eyes,red sweater, necklace,standing in the classroom, upper body photos,best quality, ultra-detailed, masterpiece, finely detail, highres, 8k wallpaper,lora:cuteGirlMix4\_v10:1
反向提示词：(worst quality:2), (low quality:2), (normal quality:2), lowres, ((monochrome)), ((grayscale)), bad anatomy,DeepNegative, skin spots, acnes, skin blemishes,(fat:1.2),facing away, looking away,tilted head, lowres,bad anatomy,bad hands, missing fingers,extra digit, fewer digits,bad feet,poorly drawn hands,poorly drawn face,mutation,deformed,extra fingers,extra limbs,extra arms,extra legs,malformed limbs,fused fingers,too many fingers,long neck,cross-eyed,mutated hands,polar lowres,bad body,bad proportions,gross proportions,missing arms,missing legs,extra digit, extra arms, extra leg, extra foot,teethcroppe,signature, watermark, username,blurry,cropped,jpeg artifacts,text,error
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ef0ee3450970e3782e9c50365ed10b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8106e2de45ba9c0862fedf33144237c3/" rel="bookmark">
			全网最全提示词教程—手把手教你用Stable Diffusion写好提示词！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 导语 Stable Diffusion 技术把 AI 图像生成提高到了一个全新高度，文生图 Text to image 生成质量很大程度上取决于你的提示词 Prompt 好不好。本文从“如何写好提示词”出发，从提示词构成、调整规则和 chatGPT 辅助工具等角度，对文生图的提示词输入进行归纳总结。
一 背景介绍 Stable Diffusion 是一种文生图 AI 模型，由互联网上数百万图像和文本描述对训练而来，通过理解文本描述与图像信息的内在关联，不断利用扩散过程进而得到满意的生成图片[1]。
比如，通过一串提示词，midjourney 会输出这样的情侣合照：
A pair of young Chinese lovers, wearing jackets and jeans, sitting on the roof, the background is Beijing in the 1990s, and the opposite building can be seen —v 5 —s 250 —q 2. 一对年轻的中国情侣，穿着夹克和牛仔裤，坐在屋顶上，背景是20世纪90年代的北京，可以看到对面的建筑 图1 用midjourney v5生成的情侣图
没错，这两位并不是真人，而是由 AI 一键生成的，毫无违和感！你可能会想这有什么了不起的，随手一搜就有好几 G 嘛。这项技术的有趣之处在于，还可以让模型生成一些先前不存在具有组合元素的高质量图像。比如说，你可以生成不同画家风格的明星照片，下面以 19 世纪印象派画家 Vincent van Gogh 和 19 世纪美国画家画家 John Sargent 风格来画下 Emma Watson 肖像画（Emma Watson 是《哈利波特》中赫敏的饰演者）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8106e2de45ba9c0862fedf33144237c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5ecee3b068127471b54176dc0335750/" rel="bookmark">
			Python 学习之常用第三方库（五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 常用第三方库 Python 是一门功能强大的编程语言，其生态系统中包含了许多优秀的第三方库，这些库极大地扩展了 Python 的功能。以下是一些常用的 Python 第三方库：
1. NumPy：
a. 用于数值计算的库，提供了大量的多维数组和矩阵运算的功能，以及相应的数学函数。
2. Pandas：
a. 数据处理和分析的库，提供了 DataFrame 和 Series 两种数据结构，支持数据的导入、清洗、转换、统计等操作。
3. Matplotlib：
a. 数据可视化库，可以绘制各种静态、动态、交互式的图表，包括线图、散点图、柱状图、饼图等。
4. Seaborn：
a. 基于 Matplotlib 的数据可视化库，提供了更高级别的接口，用于绘制统计图形，如热力图、箱线图、小提琴图等。
5. SciPy：
a. 用于数学、科学和工程的库，包含了许多用于优化、线性代数、积分、插值、特殊函数、快速傅里叶变换、信号处理、图像处理、常微分方程求解等的函数。
6. Scikit-learn：
a. 机器学习库，提供了各种机器学习算法的实现，包括分类、回归、聚类、降维等。
7. TensorFlow / PyTorch：
a. 深度学习库，用于构建和训练神经网络模型。TensorFlow 由 Google 开发，PyTorch 则由 Facebook 开发。
8. Requests：
a. HTTP 请求库，简化了发送 HTTP 请求的过程，并提供了简单易用的 API。
9. BeautifulSoup：
a. 用于从 HTML 和 XML 文件中提取数据的库，常与 Requests 库一起使用来爬取网页数据。
10. Flask / Django：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5ecee3b068127471b54176dc0335750/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f72748bb4a67c972d5c09856bf1d7e57/" rel="bookmark">
			2024最新Stable Diffusion【插件篇】：SD提示词智能生成插件教程!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 今天我们介绍几款可以自动生成提示词的插件。所谓智能生成提示词，就是我们只需要输入非常少量的关键字，插件就会根据关键词提示信息帮助我们生成一系列关键字或者句子作为提示词。下面来和我一起看看吧。
一. SD智能提示词工具
之前的文章中和大家分享过【Stable Diffusion：一个自动生成SD提示词的网站】，可以根据关键词一次生成4组提示词。 2. 网易的AI创意工坊SD Web UI界面正向提示词中提供了智能生词功能。
可以根据输入的关键词，一次具备画面性的5组提示词。
随机选择其中一组（比如第三组）智能生成的提示词看一下效果。
虽然网易AI创意工坊SD工具每天只能生成图片20次，但是智能生词功能可以无限使用。
二. SD Web UI扩展插件promptgen
插件地址：https://github.com/AUTOMATIC1111/stable-diffusion-webui-promptgen
安装完成后，重启SD Web UI。在功能菜单栏多了一个"Promptgen"菜单。
关于插件里面的参数，我们重点关注一下模型参数即可，其他的参数采用默认设置即可。
默认安装的模型有3个。
AUTOMATIC/promptgen-lexart：根据从 lexica.art 抓取的提示对 distilgpt2 进行了 100 轮的微调
AUTOMATIC/promptgen-majinai-safe：根据从 majinai.art 抓取的安全提示对 distilgpt2 进行了 40 轮的微调。
AUTOMATIC/promptgen-majinai-unsafe：针对从 majinai.art 中抓取的不安全提示，对 distilgpt2 进行了 40 轮的微调。
如果我们直接通过扩展插件的安装方式进行安装，可能模型并不会安装到我们的目录下面。在离线状态就无法使用了，我们可以在网站上面下载对应的模型文件到本地，然后上传到插件对应的models目录下。
以promptgen-lexart为例。
模型文件下载地址：https://huggingface.co/AUTOMATIC/promptgen-lexart/tree/main
下载完成后上传到插件对应的模型文件夹下面。
下面我们来体验一下。
输入一个基础关键词：a beautiful girl
选择模型：promptgen-lexart，其他参数我们保持不变。
点击【生成】按钮，最终插件会为我们生成了10组提示词。10组提示词通常对应着不同的风格。
我们挑选其中几组提示词看一下生成图片的效果
第一组提示词：a beautiful girl in the city, hyperrealistic photo, octane render, photo realistic, cinematic, hyperrealism, 8k, highly detailed, high contrast, masterpiece, high quality, vivid, beautiful, trending in artstation, deviantart featured, backlit, smooth, sharp focus, no blur, no dof
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f72748bb4a67c972d5c09856bf1d7e57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36f30f0c722442fae0fadc4654240105/" rel="bookmark">
			Spring Boot 整合 Spring AI 实现项目接入ChatGPT(OpenAl的调用，开发属于你自己Al，体验Al的乐趣)本文仅讲解聊天方式的实现，关于gpt的其他东西，参考接下来的文章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
Spring Al与Springboot整合的步骤（本文仅讲解聊天方式的实现，关于gpt的其他东西，参考接下来的文章）
第一步：建项目：创建一个Spring Boot项目(JDK17起步)；
第二步：加依赖
2.1 加入spring-ai-openai-spring-boot-starter依赖； 2.3 配置项目依赖下载的仓库：(因为spring ai在中心仓库还没有依赖，所以需要去网站下载)
第三步：配文件(这个的api -key就是你自己的，如果没有私信我即可)
第四步： 聊天功能写具体的代码实现
4.1 因为所有的接口的父接口都继承与Model，可以看到聊天方式的实现就是注入OpenAiChatModel 因为这个springboot自动装配的功能，只需要注入即可
第一种： 聊天的第一种实现方式（调用call方法，直接传入msg，这个叫做同步API）
5.1 运行程序结果
第二种 聊天的程序的第二种实现方式（调用call方法，new一个Prompt对象再传入msg）
6.1 运行程序结果​编辑
第三种：聊天的程序的第三种实现方式（比上一个方法多了一个关于gpt参数的设置）
7.1 运行程序结果
第四种：聊天的程序的第三种实现方式（调用stream方法，用法和call一样，只不过返回值不一样,Stream返回的是Fiux，叫做数据的序列一序列的数据，一个一个的数据返回，调用Stream叫做流式API）
前言 随着人工智能技术的迅猛发展，越来越多的应用程序开始集成人工智能功能，从而提供更智能、更个性化的体验。诸如ChatGPT等开放性大型语言模型的出现，使得自然语言处理和对话系统的开发变得更加便捷和普及。这些技术已经在社交媒体、客户服务、教育等领域展示出巨大的潜力，对于提升用户体验和提高工作效率起到了关键作用。
Spring Al的官网：Spring | Home
Spring AI提供的API支持跨人工智能提供商的 聊天，文本到图像，和嵌入模型等，同时支持同步和流API选项；
开发springAl程序的前期准备准备工作
本机电脑要可以访问OpenAI网站 https://openai.com/；要有OpenAI的API Key；（注册账号或者购买，如果没有可以私信联系我） Spring Al与Springboot整合的步骤（本文仅讲解聊天方式的实现，关于gpt的其他东西，参考接下来的文章） 第一步：建项目：创建一个Spring Boot项目(JDK17起步)； 第二步：加依赖 2.1 加入spring-ai-openai-spring-boot-starter依赖； &lt;dependency&gt; &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt; &lt;artifactId&gt;spring-ai-openai-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; 2.2 继承父项目：
&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt; &lt;artifactId&gt;spring-ai-bom&lt;/artifactId&gt; &lt;version&gt;${spring-ai.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 2.3 配置项目依赖下载的仓库：(因为spring ai在中心仓库还没有依赖，所以需要去网站下载) &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36f30f0c722442fae0fadc4654240105/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf7a47b73464bd49177124b839462f1b/" rel="bookmark">
			差异基因富集分析（R语言——GO&amp;KEGG&amp;GSEA）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接着上次的内容，上篇内容给大家分享了基因表达量怎么做分组差异分析，从而获得差异基因集，想了解的可以去看一下，这篇主要给大家分享一下得到显著差异基因集后怎么做一下通路富集。
1.准备差异基因集 我就直接把上次分享的拿到这边了。我们一般都把差异基因分为上调基因和下调基因分别做通路富集分析。下面上代码，可能包含我的一些个人习惯，勿怪。显著差异基因的筛选条件根据个人需求设置哈。
##载入所需R包 library(readxl) library(DOSE) library(org.Hs.eg.db) library(topGO) library(pathview) library(ggplot2) library(GSEABase) library(limma) library(clusterProfiler) library(enrichplot) ##edger edger_diff &lt;- diff_gene_Group edger_diff_up &lt;- rownames(edger_diff[which(edger_diff$logFC &gt; 0.584962501),]) edger_diff_down &lt;- rownames(edger_diff[which(edger_diff$logFC &lt; -0.584962501),]) ##deseq2 deseq2_diff &lt;- diff_gene_Group2 deseq2_diff_up &lt;- rownames(deseq2_diff[which(deseq2_diff$log2FoldChange &gt; 0.584962501),]) deseq2_diff_down &lt;- rownames(deseq2_diff[which(deseq2_diff$log2FoldChange &lt; -0.584962501),]) ##将差异基因集保存为一个list gene_diff_edger_deseq2 &lt;- list() gene_diff_edger_deseq2[["edger_diff_up"]] &lt;- edger_diff_up gene_diff_edger_deseq2[["edger_diff_down"]] &lt;- edger_diff_down gene_diff_edger_deseq2[["deseq2_diff_up"]] &lt;- deseq2_diff_up gene_diff_edger_deseq2[["deseq2_diff_down"]] &lt;- deseq2_diff_down 2.进行通路富集分析 这里主要介绍普通的GO&amp;KEGG&amp;GSEA的简单富集。筛选显著富集通路的筛选条件也是根据自己的需求决定，一般是矫正后P值小于0.05。我这里是省事，写了各list循环。
for (i in 1:length(gene_diff_edger_deseq2)){ keytypes(org.Hs.eg.db) entrezid_all = mapIds(x = org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf7a47b73464bd49177124b839462f1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c598ed9915799c51797d20bd938b9e68/" rel="bookmark">
			解决adb connect连接Android设备报错：由于目标计算机积极拒绝，无法连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【原因排查】
在使用adb（Android Debug Bridge）工具连接Android设备时，有时候会出现“由于目标计算机积极拒绝，无法连接”的错误。这通常是因为设备没有正确地连接到计算机，或者设备的防火墙或安全设置阻止了adb的连接。
【解决办法1】（此方法针对设备支持USB连接）
1、打开开发者模式和USB调试
在Android设备上，进入“设置”菜单，然后滚动到“关于手机”部分。连续点击“版本号”或“软件版本”几次（通常是7次），直到看到“你现在是开发者！”的提示。返回到设置菜单，打开“开发者选项”，然后启用“USB调试”。
2、使用USB数据线连接手机和电脑
使用USB数据线将Android设备连接到计算机。确保设备与计算机建立稳定的物理连接。
3、在PC端打开cmd命令窗口
在计算机上打开命令提示符（Windows）或终端（macOS/Linux）。
4、输入adb devices查看已连接设备
在命令提示符或终端中输入“adb devices”，然后按回车键。如果一切正常，你将看到已连接设备的列表。如果你的设备没有出现在列表中，请检查设备是否正确连接，并确保已经启用了USB调试。
5、输入adb tcpip 5555设置端口号为5555
在命令提示符或终端中输入“adb tcpip 5555”，然后按回车键。这将将adb切换到TCP/IP模式，并将端口号设置为5555。
6、断开手机和电脑的连接
通过断开USB数据线断开Android设备和计算机的连接。现在你的设备应该通过Wi-Fi与计算机建立连接。
7、adb connect IP
最后，在命令提示符或终端中输入“adb connect [设备的IP地址]”，然后按回车键。如果一切顺利，你应该能够成功连接到你的Android设备。请注意，设备的IP地址可以在“设置”菜单中的“关于手机”部分找到。
【解决办法2】（此方法针对设备不支持USB连接但支持telnet连接）
1、Android设备与PC端处于同一局域网
通过WiFi或者网线直连方式，使Android设备与PC端两者处于同一局域网。
2、在PC端打开cmd命令窗口
在计算机上打开命令提示符（Windows）或终端（macOS/Linux）。
3、输入 telnet ip 端口号
在命令提示符或终端中输入“adb telnet ip 端口号”，然后按回车键，成功进入telnet登录界面。
4、输入 setprop service.adb.tcp.port 5555 设置adb服务端口
设置adb服务端口为5555， 打开adb网络调试功能。
5、输入 start adbd
重启adb服务，可以重复输入 start adbd、stop adbd来启用。
这些步骤应该能够帮助你解决使用adb connect连接Android设备时出现的“由于目标计算机积极拒绝，无法连接”的错误。如果问题仍然存在，请确保你的设备和计算机都已连接到同一Wi-Fi网络，并检查设备的防火墙和安全设置是否允许adb的连接。
如果您看完，还有疑问的话，可以评论区提出，看到了会及时回复！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1033e43cd4f19cbfbebc31f6a6745722/" rel="bookmark">
			zabbix 配置企业微信告警
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、申请一个企业微信， 官网链接 2、群内申请一个机器人 下载电脑版企业微信，登录后，在要接收群消息的群里，点击右上角三个点，添加机器人后，保存机器人的webhook地址
上传应用logo，填写应用名称，选择可见范围
3.创建发送消息的脚本 在zabbix-server 机器上，/usr/local/share/zabbix/alertscripts 目录下创建一个wechat-webhook.py
#!/usr/bin/env python3 #-*- coding: utf-8 -*- import requests import json import sys import os headers={'Content-Type': 'application/json;charset=utf-8'} api_url="https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=****************" def msg(text): json_text={ "msgtype": "text", "text": { "content": text } } requests.post(api_url,json.dumps(json_text),headers=headers) if __name__ == '__main__': text = sys.argv[1] msg(text) 脚本编写完成之后需要为脚本添加执行权限
[root@zabbix alertscripts]# chmod +x wechat-webhook.py
4、测试 yum -y install python3 phthon3-pip
pip3 install requests
命令行测试脚本能否成功执行
]# ./wechat-webhook.py "测试"
会在微信企业号中收到我们创建的应用所发出的消息
5.在zabbix web页面上添加告警媒介 问题 模板配置如下 主题: 故障发生 {EVENT.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1033e43cd4f19cbfbebc31f6a6745722/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa23fa9cbbeacfc5a7586c7f712f7d28/" rel="bookmark">
			《梦醒蝶飞：释放Excel函数与公式的力量》8.3 COUNTBLANK函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		8.3 COUNTBLANK函数
在数据处理和分析中，我们经常需要识别和统计数据集中的空白单元格。COUNTBLANK函数是Excel中用于统计某个范围内空白单元格数量的强大工具。
8.3.1 函数简介
COUNTBLANK函数用于统计指定范围内的空白单元格数量。这在数据清洗、数据完整性检查和缺失值处理等场景中非常有用。通过使用COUNTBLANK函数，我们可以快速识别数据中的空白区域，从而采取相应的措施。
8.3.2 语法
COUNTBLANK函数的语法如下：
COUNTBLANK(range)
range：需要统计空白单元格数量的单元格区域。
8.3.3 基本用法
COUNTBLANK函数的基本用法非常简单。下面通过一个具体的例子来说明如何使用这个函数。
假设我们有一个包含学生考试成绩的表格，如下所示：
我们希望统计数学成绩和英语成绩中空白单元格的数量。
1）统计数学成绩中的空白单元格数量
在一个空白单元格中输入以下公式：
=COUNTBLANK(B2:B5)
这个公式会返回 1，因为在B2:B5区域内有一个空白单元格。
2）统计英语成绩中的空白单元格数量
在另一个空白单元格中输入以下公式：
=COUNTBLANK(C2:C5)
这个公式会返回 1，因为在C2:C5区域内也有一个空白单元格。
8.3.4 注意事项
在使用COUNTBLANK函数时，有几个注意事项需要记住：
1）空白单元格的定义：COUNTBLANK函数将完全空白的单元格视为空白单元格，但如果单元格中包含空格字符或其他不可见字符，则不会被视为空白。
2）范围内的公式：如果单元格中包含返回空白值的公式（如 `=""` ），这些单元格也会被COUNTBLANK函数计为空白。
3）与其他函数的结合使用：COUNTBLANK函数可以与其他统计和数据处理函数结合使用，以实现更复杂的数据分析。
8.3.5 高级应用
COUNTBLANK函数不仅可以用于简单的空白单元格统计，还可以与其他函数结合使用，执行更高级的数据分析任务。例如：
1）结合IF函数统计特定条件下的空白单元格
我们希望统计在某些特定条件下空白单元格的数量，例如，仅当数学成绩高于80分时，统计英语成绩为空白的单元格数量。
我们需要统计数学成绩高于80且英语成绩为空白的单元格数量。
使用IF函数和COUNTBLANK函数
为了实现这一点，可以使用数组公式（在旧版本Excel中需要按Ctrl+Shift+Enter来输入数组公式）：
=COUNTBLANK(IF(B2:B5&gt;80, C2:C5)) 公式解析
IF(B2:B5&gt;80, C2:C5)：该部分创建了一个数组，其中仅包含数学成绩大于80的相应英语成绩值。如果数学成绩不满足条件，对应位置会返回FALSE。
COUNTBLANK(...)：COUNTBLANK函数统计数组中空白单元格的数量。
步骤说明
（1）选择一个空白单元格：在表格中选择一个空白单元格。
输入公式：
（2）在空白单元格中输入以下公式：
=COUNTBLANK(IF(B2:B5&gt;80, C2:C5))
（3）输入数组公式：
在旧版本Excel中按Ctrl+Shift+Enter，如果你使用的是Office 365或Excel 2019及更新版本，直接按Enter即可。
查看结果：
公式会返回满足条件的空白单元格数量。在这个示例中，结果将是1，因为只有李四的数学成绩大于80且英语成绩为空。
8.3.6 实战练习
为了巩固对COUNTBLANK函数的理解，下面提供一个实战练习：
练习：假设我们有一个产品库存表，如下所示：
请回答以下问题：
1. 库存数量中有多少个空白单元格？
公式：=COUNTBLANK(IF(B2:B5&gt;18, C2:C5))
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa23fa9cbbeacfc5a7586c7f712f7d28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b405c98e4546f11b58afa41266786896/" rel="bookmark">
			Perplexity CEO 最新四万字访谈：杀死谷歌，成为 AI 时代的搜索皇帝！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		理想中的 AI 应该和爱因斯坦一样，每当你提出了一个棘手的问题，它可能会说，“我暂时不知道答案。”但一周后，它经过深入研究，带着全新的见解回来，让你惊叹不已。
如果我们能够实现这种深度的推理计算，随着算力的增加，得到的答案质量也会显著提升，这将是推理能力真正突破的起点。
文 | 王启隆
出品 | AI 科技大本营（ID：rgznai100）
来源 | https://www.youtube.com/watch?v=e-gwvmhyU7A
谁是 Perplexity？对于经常关注 AI 圈的开发者来说，这个名字已经不再陌生。英伟达黄仁勋称它为“自己每天都在用的 AI 工具”，而这家公司也成为 AI 应用浪潮的第一先锋，在年初拿下了超 7000 万的融资。
此前，我们以《靠一个 AI 搜索框颠覆谷歌命脉的奇兵》为题，简单介绍过这款产品的前世今生。最近，知名播客主播、MIT 科学家莱克斯·弗里德曼（Lex Fridman）邀请到了 Perplexity 的 CEO 埃拉文德·斯里尼瓦斯（Aravind Srinivas）进行了一场三小时的采访，内容极长，横跨了几大话题：
AI 搜索（RAG 架构大解密）；
谷歌往事（埃拉文德作为谷歌前科学家，亲历了 Transformer 前生今世）；
名人点评（从马斯克、贝索斯、杨立昆、扎克伯格，聊到了科学家、作家、艺术家，甚至梅西和罗纳尔多两位运动员）；
算力危机（AGI 究竟“值多少钱”？）
畅想未来（埃拉文德为 AI 描绘的图景非常具有想象力，这将是你从未见过的角度！）
埃拉文德·斯里尼瓦斯
Perplexity 的诞生，恰逢信息过载与个性化需求激增的交汇点。它不像传统搜索引擎那样被动等待指令，而是面对提问时迅速锁定核心，给出的答案不仅直接击中要害，还一一附带权威来源链接，确保每条信息可靠，每个知识点都有据可查。
此外，Perplexity 最独特的地方在于其创新的“相关问题”功能，每次答完问题就会用 AI 智能推荐一系列相关问题，引导你探索未知领域，层层深入学习，营造出一个持续进化、自我强化的知识探索旅程。
由于采访长达四万字，因此我们先以目录形式总结了接下来每个小标题下涵盖的内容以及亮点，尽可能优化您的阅读体验：
1. 开发 Perplexity，是因为在 Google 搜到了一堆广告
开门见山，埃拉文德将在第一段对话中介绍 Perplexity 的两大本质：答案引擎 &amp; 知识发现引擎。由于埃拉文德有学术背景，所以他对待 Perplexity 的方式就像博导对学生一样，让搜索答案的每一句话都有准确的引用出处，这份“铁则”成就了这款应用，并从根本上区分了 Perplexity 和 Google。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b405c98e4546f11b58afa41266786896/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/199/">«</a>
	<span class="pagination__item pagination__item--current">200/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/201/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>