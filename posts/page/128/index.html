<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39a1f7efb43103207d0c2c644086c6e2/" rel="bookmark">
			图片转pdf的软件有哪些？这几种转换工具了解下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常的办公学习中，图片转PDF的需求愈发普遍。不论是工作汇报、学习笔记还是生活点滴，我们都希望将重要的图片内容整理成易于查阅的PDF格式。那么，有哪些软件可以做到将图片转换成PDF格式呢？给大家介绍5种简单好用的转换方法，一起来学习下吧。
软件一：嗨动PDF编辑器
这不仅是一款强大的PDF编辑工具，还具备图片转PDF的功能。它的操作界面简洁明了，支持批量转换，能够一次性处理多张图片。转换后的PDF文件保持原图片的高质量，同时支持添加水印，步骤如下：
1、将软件在电脑中打开，点击左侧的“文件转PDF”，在这里面选择“图片转PDF”功能，然后将需要转换的图片给添加进来。
2、图片添加进来后，可以在下方选择图片是否压缩、PDF纸张大小以及水印设置，最后点击“开始转换”，图片就会被转换成PDF文件啦。
软件二：迅捷PDF转换器
这是一款专注于PDF格式转换的软件，当然也包括图片转PDF。同时，支持多种图片格式的转换，如JPG、PNG、BMP等，满足不同需求。此外，还提供了丰富的PDF编辑功能，如合并、分割、压缩等，下面给大家演示下它的图片转PDF功能。
1、将软件在电脑中打开，在PDF转换功能选项中，在左侧点击“其他转PDF”，选择“图片转PDF”，接着就可以将图片给添加进来。
2、将图片添加进来后，可以在下方设置PDF设置，如纸张大小、纸张方向、页边距、水印等参数，最后点击“开始转换”，图片就会被转换成PDF啦。
软件三：Zamzar
这是一款在线的图片转PDF工具，无需下载安装即可使用。它支持多种文件格式的转换，包括图片转PDF。只需将需要转换的图片上传进来，选择转换格式并输入邮箱地址，稍等片刻即可收到转换后的PDF文件。虽然它是在线工具，但它的转换质量和速度都非常不错，是一个值得尝试的选择。
软件四：全能PDF转换助手
这是一款功能全面的PDF处理软件。可以对PDF文件进行格式转换、文件编辑，以及其他诸多文件处理功能，在图片转PDF方面，它支持多种图片格式的转换，并且支持批量转换，操作简单，下面给大家演示下：
1、将软件打开，在页面的左侧点击“其他转PDF”，然后选择“图片转PDF”选项，接着将图片给添加进来。
2、将图片添加进来后，可以在下方设置PDF的相关设置，纸张大小、方向、页边距、水印等，最后点击“开始转换”，图片就会转换成PDF啦。
软件五：PDF24 tools
这是一款在线文档处理网站，它的图片转PDF功能强大而便捷，可轻松将多张图片转换为高质量的PDF文件。支持多种图片格式，操作界面简洁直观，转换速度快且保持图片原质量。无论是工作还是学习，都能快速满足图片整合需求，是图片管理的得力助手。
总之，以上介绍的5款图片转PDF软件各有特色，无论你是需要快速转换还是追求高质量输出，都能在这些软件中找到合适的选择。希望这些软件能够帮助你轻松搞定图片转换问题，提升工作和学习效率！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57311ad3a799d9d86ecb34e67ca12b86/" rel="bookmark">
			Dubbo SPI 之负载均衡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 背景介绍 在分布式系统中，负载均衡是一项核心技术，旨在将请求合理地分配到多个服务实例上，以提高系统的性能和可靠性。Dubbo 作为一个高性能的 Java RPC 框架，提供了多种负载均衡策略来满足不同的业务需求。本文将深入探讨 Dubbo SPI（Service Provider Interface）中的负载均衡策略，包括其工作原理、实现机制以及如何自定义负载均衡策略。
2. SPI 和负载均衡的关系 Dubbo 的 SPI 机制允许在运行时动态加载不同的服务实现。负载均衡策略作为 Dubbo 的一部分，使用 SPI 机制进行扩展和配置。通过 SPI，开发者可以轻松地添加或修改负载均衡策略，而无需修改 Dubbo 的核心代码。
3. Dubbo 中的负载均衡策略 Dubbo 提供了几种内置的负载均衡策略，每种策略适用于不同的场景。主要的负载均衡策略包括：
随机负载均衡（Random Load Balancing）：
原理：随机选择一个可用的服务实例进行请求处理。适用于服务实例性能相近、请求量波动较大的场景。实现：使用随机数生成器从可用服务实例列表中选择一个实例。 轮询负载均衡（Round Robin Load Balancing）：
原理：按照轮询的方式依次选择服务实例，保证请求的公平分配。适用于服务实例性能相近的场景。实现：维护一个索引指针，每次请求按照顺序分配到下一个服务实例。 加权轮询负载均衡（Weighted Round Robin Load Balancing）：
原理：在轮询的基础上，根据服务实例的权重进行请求分配。权重高的实例将获得更多的请求。适用于服务实例性能不均的场景。实现：在轮询的基础上，根据权重值调整分配比例。 最少活动请求负载均衡（Least Active Load Balancing）：
原理：选择当前活动请求数最少的服务实例进行请求处理。适用于请求量波动较大的场景。实现：维护每个服务实例的活动请求计数，选择活动请求最少的实例。 一致性哈希负载均衡（Consistent Hashing Load Balancing）：
原理：基于一致性哈希算法将请求分配到特定的服务实例，确保相同的请求（例如相同的用户）总是被路由到同一个实例。适用于需要保持请求会话的场景。实现：使用一致性哈希算法计算请求的哈希值，并选择对应的服务实例。 4. Dubbo SPI 负载均衡策略的工作原理 Dubbo 使用 SPI 机制来实现负载均衡策略的扩展和定制。以下是 Dubbo SPI 负载均衡策略的工作原理：
SPI 加载：Dubbo 使用 Java 的 SPI 机制加载所有注册的负载均衡策略。SPI 配置文件通常位于 META-INF/dubbo/loadbalance 目录下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57311ad3a799d9d86ecb34e67ca12b86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fce87a18f725c5248b9f89b00d413734/" rel="bookmark">
			Text Control 控件教程：使用 .NET C# 中的二维码和条形码增强文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QR 码和条形码非常适合为文档和 PDF 文件增加价值，因为它们提供轻松的信息访问、验证信息、跟踪项目和提高交互性。条形码可以弥补纸质或数字人类可读文档与网络门户或网络应用程序中的数字信息之间的差距。大多数用户都熟悉 QR 码和条形码，它们在许多过程中无处不在，例如：
产品包装发票库存管理活动票务登机证支付系统 在某些行业中，如果没有条形码，流程将无法进行。这包括医疗保健，可以通过扫描患者佩戴的腕带直接访问患者数据，或跟踪每日药物剂量。或物流，只需扫描装箱单或其他文件上的商品代码即可跟踪订单或在仓库中找到订单。在零售业，条形码用于跟踪库存、管理库存水平和加快结账流程。
TX Text Control 是一款功能类似于 MS Word 的文字处理控件，包括文档创建、编辑、打印、邮件合并、格式转换、拆分合并、导入导出、批量生成等功能。广泛应用于企业文档管理，网站内容发布，电子病历中病案模板创建、病历书写、修改历史、连续打印、病案归档等功能的实现。
TX Text Control 最新下载https://www.evget.com/vendor/118
什么是条形码？ 条形码是一种以视觉格式呈现数据的机器可读表示。它由不同宽度和间距的线条组成，可通过条形码扫描仪读取。QR 码是一种条形码，可以存储比传统条形码更多的信息。它是一种二维码，可以存储文本、URL、联系信息和其他数据。
最典型的条形码是：
二维码
QR 码是一种二维条形码，可以存储比传统条形码更多的信息。它通常用于营销、广告和其他需要在小空间中存储更多信息的应用。
UPC（通用产品代码）
UPC 代码是一种条形码，常用于零售店跟踪库存和销售情况。它由 12 位数字组成，可通过条形码扫描仪读取。
EAN（欧洲商品编号）
EAN 码是一种条形码，在欧洲常用于跟踪库存和销售情况。它由 13 位数字组成，可通过条形码扫描仪读取。
代码 39
Code 39 是一种常用于物流和库存管理的条形码。它由不同宽度和间距的线条组成，可通过条形码扫描仪读取。
例如：装箱单
假设您有一张装箱单，其中包含要运送给客户的物品清单。为了在仓库或运输过程中跟踪物品，每件物品都有一个可以扫描的条形码。可以使用条形码扫描仪或带有条形码扫描应用程序的移动设备扫描条形码。条形码包含有关物品的信息，例如物品编号、说明和数量。
请看以下使用 TX Text Control 生成的包含各处条形码的装箱单的屏幕截图。TX Text Control 为所有行业标准的 1D 和 2D 条形码提供开箱即用的支持。
生成装箱单 使用 TX Text Control 的邮件合并 引擎创建此装箱单非常容易。首先，如下所示，我们需要一个数据源，例如 JSON 对象。
[ { "packing_slip_guid": "12345678-1234-1234-1234-123456789012", "dispatch_date": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fce87a18f725c5248b9f89b00d413734/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86f30fc005791ae4a18a7f327bd60072/" rel="bookmark">
			英伟达、Mistral AI 开源企业级大模型，120亿参数、可商用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全球AI领导者英伟达（Nvidia）和著名开源大模型平台Mistral.ai联合开源了，企业级大模型Mistral NeMo 12B。（以下简称“MN 12B”）
据悉，MN 12B一共有基础和指令微调两种模型，支持128K上下文长度，能生成文本、代码、摘要等，其性能比最新开源的Gemma 2更好。
基础模型开源地址：https://huggingface.co/mistralai/Mistral-Nemo-Base-2407
指令微调模型：https://huggingface.co/mistralai/Mistral-Nemo-Instruct-2407
MN 12B在多轮对话、数学、常识推理、世界知识以及编码方面表现出色，比谷歌开源的Gemma 2 9B、Meta开源的Llama 3 8B 性能更好。支持128K的上下文长度，能够更连贯、更准确地处理大量复杂信息。
MN 12B以Apache 2.0许可证发布，允许企业、个人开发者进行商业化基础训练和微调。此外，模型采用FP8数据格式进行模型推理，极大减少了内存大小并加快了部署速度，同时没有任何准确性的降低。这意味着模型可以更好地学习任务，更有效地处理多样化的场景，使其非常适合企业级业务用例。
MN 12B作为NVIDIA NIM推理微服务的一部分，使用了NVIDIA TensorRT-LLM引擎的优化推理性能。这种容器化格式允许在任何地方轻松部署，为各种应用提供了增强的灵活性，模型可以在几分钟内部署在任何地方，无需耗费几天的时间。
在多语言方面，MN 12B支持英语、中文、法语、德语、西班牙语、意大利语、葡萄牙语、日语、韩语、阿拉伯语等主流语言，在MMLU等多语言基准测试中超过了同类开源模型。
此外，MN 12B使用了一种基于Tiktoken的更高效分词器Tekken。该分词器经过100多种语言的训练，比之前Mistral模型中使用的 SentencePiece 分词器更有效地压缩自然语言文本和源代码。
尤其是在压缩源代码、中文、意大利语、法语、德语、西班牙语和俄语时，效率提升了大约30%。在压缩韩语和阿拉伯语时效率相比之前，分别提升了2倍和3倍。
Mistral AI的创始人兼首席科学家Guillaume Lample表示，Mistral NeMo结合了Mistral AI在训练数据方面的专长与NVIDIA优化的硬件和软件生态系统为各种应用场景提供了高性能。
本次与NVIDIA团队的合作，借助其顶级的硬件和软件，共同开发出了具有前所未有的准确度、灵活性、高效性的企业级大模型。
本文素材来源英伟达官网，如有侵权请联系删除
END
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23c2e569d32fefdb63bf41b966ea0afe/" rel="bookmark">
			Zookeeper入门篇，了解ZK存储特点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Zookeeper入门篇，了解ZK存储特点 前言一、为什么要用 Zookeeper？二、Zookeeper存储特色1. 树状结构2. 节点类型 三、存储位置1. 内存存储1. DataTree2. DataNode 2. 硬盘存储1. 事务日志2. 快照 前言 继上次说完 Zookeeper 的安装后，已经过去半年多了，一直没有后续，本次得空就更新一下入门篇，给同学们介绍一下 Zookeeper ，并着重说一下其存储原理
📕作者简介：战斧，从事金融IT行业，有着多年一线开发、架构经验；爱好广泛，乐于分享，致力于创作更多高质量内容
📗本文收录于 Zookeeper 专栏，有需要者，可直接订阅专栏实时获取更新
📘高质量专栏 云原生、RabbitMQ、Spring全家桶 等仍在更新，欢迎指导
📙 mysql Redis dubbo docker netty等诸多框架，以及架构与分布式专题即将上线，敬请期待
一、为什么要用 Zookeeper？ 我们先看 Zookeeper 官方自己的定义
ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services. All of these kinds of services are used in some form or another by distributed applications.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23c2e569d32fefdb63bf41b966ea0afe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/092400b8a5cf85d812fda1cd5a6f5803/" rel="bookmark">
			【MySQL调优】如何进行MySQL调优？从参数、数据建模、索引、SQL语句等方向，三万字详细解读MySQL的性能优化方案（2024版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导航：
本文一些内容需要聚簇索引、非聚簇索引、B+树、覆盖索引、索引下推等前置概念，虽然本文有简单回顾，但详细可以参考下文的【MySQL高级篇】
【Java笔记+踩坑汇总】Java基础+JavaWeb+SSM+SpringBoot+SpringCloud+瑞吉外卖/谷粒商城/学成在线+设计模式+面试题汇总+性能调优/架构设计+源码解析
目录
一、监控报警 二、排查慢SQL
2.1 开启慢查询日志 2.2 找出最慢的几条SQL
2.3 分析查询计划 2.3.1 EXPLAIN命令
2.3.2 EXPLAIN ANALYZE命令
三、MySQL调优
3.1 基础优化
3.1.1 缓存优化 3.1.1.0 简介
3.1.1.1 缓冲池优化
3.1.1.2 Redis优化
3.1.2 硬件优化
3.1.3 参数优化
3.1.4 定期清理垃圾
3.1.4.1.清理不再使用的表
3.1.4.2.清理过期数据
3.1.4.3.清理日志
3.1.4.4.清理缓存池
3.1.4.5.优化表：OPTIMIZE TABLE
3.1.4.6.分析表：ANALYZE TABLE
3.1.4.7.计划任务清理数据、日志、优化表
3.1.5 使用合适的存储引擎
3.1.5.1 各存储引擎使用场景
3.1.5.2 回顾各存储引擎和B+树
3.1.6 读写分离
3.1.7 分库分表
3.2 表设计优化
3.2.1 混合业务分表、冷热数据分表
3.2.2 联合查询改为中间关系表
3.2.3 遵循三个范式
3.2.4 字段建议非空约束
3.2.5 反范式：使用冗余字段
3.2.6 数据类型优化
3.3 索引优化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/092400b8a5cf85d812fda1cd5a6f5803/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/989a5bc12f629c38ea1f190eed25a12a/" rel="bookmark">
			C&#43;&#43;：从C到C&#43;&#43;的飞跃之旅（C&#43;&#43;基础知识）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本期博客是一篇C++基础知识，对后续C++的深入学习，都是有着相当重要的地位❤，内容包含了以下知识：命名空间、C++的输入&amp;输出流、缺省参数、重载函数、引用、inline（内联函数）、nullptr（主要解决C语言NULL类型混淆的问题）
如果这篇博客对大家有帮助，还请点赞收藏❤，感觉大家的支持~，我会更加努力的❤
一、命名空间 1.问题导向 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int rand = 1314; int main() { printf("%d\n", rand); return 0; } /* *这组代码中，就存在了一个不可避免的 会存在编译错误： *error C2365: “rand”: 重定义；以前的定义是“函数” *warning C4477: “printf”: 格式字符串“%d”需要类型“int”的参数，但可变参数 1 *拥有了类型“int (__cdecl *)(void)” */ 不难理解，rand是生成随机数的函数名，其函数的声明存放于头文件&lt;stdlib.h&gt;中，而我们又定义了一个全局变量rand；这就导致了上面的错误，我们称为命名冲突；
问：自己写代码的时候，命名稍加注意一下，不就可以了吗？回：虽然你自己写代码的时候，不会发生命名冲突的问题，但你不能保证，多人协作写一个项目的时候，不会出现命名冲突的问题，毕竟每个人的想法都是参差不齐的。 为了解决命名冲突的问题，C++引入了一个新的关键字——namespace，namespace后跟一对{}，中间用于变量的定义，函数的声明与定义，类的声明与定义等等；可以为我们在全局域生成一个命名空间域；主要用于解决命名冲突、组织代码、提高代码的可读性和可维护性。
下面的代码，是在域中定义一个malloc为函数名的交换函数，和以rand为变量名的变量。包含头文件&lt;stdlib.h&gt;后，编译器不会报上面的错误。
2.namespace的定义 namespace的本质，在用途方面，可以类似于电脑分盘(新建文件夹)，在不同的盘符(文件夹)中可以定义相同的文件标识；不同的域可以使用相同的标识符，如局部域和作用域，都可以定义变量a；在同一域中，不能出现两个或两个以上的相同的标识符多文件中，存在相同的命名空间域名的时候，编译的时候，会形成同一个域；namespace可嵌套使用；namespace只可在全局域中使用；C++的作用域主要有四种，函数局部域、全局域、命名空间域、类域。函数局部域、全局域会改变变量或函数的作用域和生命周期，而命名空间域、类域只改变其作用域，不改变其生命周期；C++的标准域，定义在 std 域中；编译器找变量、函数、或类的出处，默认是局部域和全局域(先局部域，后全局域)；若找不到，则编译器报错；——由此更能体现命名空间对命名冲突问题的解决；下面将对上面所说的某些现象，进行验证与反馈~，若无问题可直接跳转命名空间的使用 //.h文件 #include&lt;stdio.h&gt; namespace zmh { void Print(); } //.cpp文件 #include"zmh.h" namespace zmh { void Print() { printf("残风也想永存：第一个C++代码\n"); } } //.main文件 #include"zmh.h" using namespace zmh; // 这里是对命名空间的一种使用方法 int main() { //验证：多文件中，存在相同的命名空间域名的时候，编译的时候，会形成同一个域； //若成功调用Print(),则验证成功！！！ Print(); return 0; } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/989a5bc12f629c38ea1f190eed25a12a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f450ec4f637da73f026170be0425358e/" rel="bookmark">
			【北京迅为】《i.MX8MM嵌入式Linux开发指南》-第三篇 嵌入式Linux驱动开发篇-第三十九章 Linux MISC驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		i.MX8MM处理器采用了先进的14LPCFinFET工艺，提供更快的速度和更高的电源效率;四核Cortex-A53，单核Cortex-M4，多达五个内核 ，主频高达1.8GHz，2G DDR4内存、8G EMMC存储。千兆工业级以太网、MIPI-DSI、USB HOST、WIFI/BT、4G模块、CAN、RS485等接口一应俱全。H264、VP8视频硬编码，H.264、H.265、VP8、VP9视频硬解码，并提供相关历程,支持8路PDM接口、5路SAI接口、2路Speaker。系统支持Android9.0(支持获取root限)Linux4.14.78+Qt5.10.1、Yocto、Ubuntu20、Debian9系统。适用于智能充电桩，物联网，工业控制，医疗，智能交通等，可用于任何通用工业和物联网应用、
【公众号】迅为电子
【粉丝群】258811263（加群获取驱动文档+例程）
第三部分 Linux驱动基础 第三十九章 Linux MISC驱动 本章导读
Linux MISC驱动是最简单的字符设备驱动，学习MISC驱动将会为学习字符设备驱动奠定基础。
39.1 章节讲解了misc设备驱动的基本概念及函数使用方法
39.2 章节讲解了编写最简单的杂项设备驱动，并将其编译为驱动模块，在iTOP-3399开发板上运行测试。
本章内容对应视频讲解链接（在线观看）：
杂项设备驱动讲解 → 杂项设备驱动讲解_哔哩哔哩_bilibili
编写一个杂项设备驱动 → https://www.bilibili.com/video/BV1Vy4y1B7ta?p=10
程序源码在网盘资料“iTOP-i.MX8MM开发板\02-i.MX8MM开发板网盘资料汇总(不含光盘内容)\嵌入式Linux开发指南(iTOP-i.MX8MM)手册配套资料\2.驱动程序例程\02-杂项设备驱动实验”路径下。
39.1 misc设备驱动简介 本章节我们讲解杂项设备驱动，那么杂项设备驱动是属于我们linux三大设备驱动的哪一项呢？由于linux驱动倾向于分层设计，所以每个具体的设备都可以找到它归属的类型，从而可以套到它相应的架构里面去，我们只需要实现它最底层的那部分。但是也有部分字符设备，确实不知道它属于哪种类型，我们一般推荐大家采用miscdevice的框架结构。misc 的意思是混合的杂项的，所以 misc 设备驱动也叫做杂项设备驱动，当我们板子上的某个设备没有办法分类时，就可以用 misc 设备驱动。它的注册跟使用比较的简单，所以比较适用于功能简单的设备。正因为简单，所以它通常嵌套在 platform 总线驱动中，配合总线驱动达到更复杂，多功能的效果。杂项设备是字符设备的一种，杂项设备可以自动生成设备节点。
在学习misc设备驱动之前，先来了解几个基础概念。
概念1设备节点
我们可以启动我们的开发板，进入到dev目录下，dev目录下全部都是生成的设备节点，如下图所示：
我们的系统里面有很多杂项设备。我们可以输入以下命令来查看，如下图所示：
cat /proc/misc
概念2 杂项设备的优点
杂项设备除了比字符设备代码简单，还有别的区别吗？所有的 misc 设备驱动的主设备号都为 10，不同的设备使用不同的从设备号。主设设备号相同就可以节省内核的资源，在内核中大概可以找到200多处使用miscdevice框架结构的驱动。
概念3主设备号和次设备号的概念
设备号包含主设备号和次设备号，设备号是计算机识别设备的一种方式，主设备号相同的就被视为同一类设备，主设备号在Linux系统里面是唯一的，次设备号不一定唯一。主设备号可以比做成电话号码的区号。比如北京的区号是010，次设备号可以比作成电话号码。
主设备号可以通过以下命令来查看，前面的数字就是主设备号，如下图所示：
cat /proc/devices
misc 设备用 miscdevice 结构体表示，miscdevice结构体的定义在内核源码具体定义/home/topeet/linux/linux-imx/include/linux/miscdevice.h中，内容如下：
struct miscdevice { int minor; //次设备号 const char *name; //设备节点的名字 const struct file_operations *fops; //文件操作集 struct list_head list; struct device *parent; struct device *this_device; const struct attribute_group **groups; const char *nodename; umode_t mode; }; 当我们创建一个 misc 设备的 miscdevice 结构体时，需要我们指定 minor、name 和 fops 这三个成员变量。minor 表示次设备号，需要用户设置，在 Linux 内核中有一些预定义的 misc 设备的次设备号，定义在/home/topeet/linux/linux-imx/include/linux/miscdevice.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f450ec4f637da73f026170be0425358e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae119b72e7cdf59b95d85d105af5e0bd/" rel="bookmark">
			[css3] 如何设置边框颜色渐变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		div { border: 4px solid; border-image: linear-gradient(to right, #8f41e9, #578aef) 1; } 参考：
5种CSS实现渐变色边框（Gradient borders方法的汇总
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ace481cd5cfa693b6b4a3ffec030c2d/" rel="bookmark">
			Java实现随机题库-全站最呆瓜思想，保证你能学会
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Blue留言 ：
学本篇文章之前所需掌握技能 推荐视频： 代码逻辑思想
步骤： 1、引入依赖
2、做一个excel表格 3、java实现从excel表中取数据
第一步：根据excel上面的字段名（如下图），我们创建一个类，该成员变量和字段名一一对应
第二步：利用Easyexcel取excel中的数据 第三步：利用Random与for循环从list1集合中随机抽出来几条数据再放进其他集合中 第四步：按照举例的步骤（步骤3的前三步）自己动手实现一下吧
第五步：写接口传递给前端（这步将会把前三部的所有代码展示出来）
第六步：前端渲染（并非重点）
Blue留言 ： 🎉🎉🎉Hello,Hello！这里是Blue,一位发誓要成为很厉害的全栈的博主，今天俺带来的文章是利用Excel表格结合Java去实现类似出题软件的效果。在这篇文章中，我将会通过图文形式，会把所有的代码全给列举出来，保证看完这篇文章的各位宝子们能学会。那么，废话不多说我们开始接下来的编程之旅吧！！！🎉🎉🎉
学本篇文章之前所需掌握技能 1、会java语言基础2、会代建springboot框架 推荐视频： http://【使用Java语言操作Excel表格全攻略】https://www.bilibili.com/video/BV1Ff4y1U7Qc?p=18&amp;vd_source=bb412cc25ca27e171f8e17085daad038
视频主要讲解如何实现用java去对excel进行读写，实际上我们做简单的题库，并不需要去进行写操作，能够从excel读便就达到我们的目的了。
代码逻辑思想 代码逻辑很简单，搭建springboot框架，利用Easyexcel这个开源的库，对Excel表格里面的数据取出来，存储在一个集合中，再利用随机数Random和for循环对该集合进行二次开发（利用随机数生成索引，从集合里面取出来数据再组合成另一个集合），最后将该集合转成json格式传递给前端进行渲染。
步骤： 1、引入依赖 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;2.2.3&lt;/version&gt; &lt;/dependency&gt; 注意：若做项目时候所使用过poi依赖，请导入的下面依赖
&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel-core&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml-schemas&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 2、做一个excel表格 如图：
接下来我分析一下该excel需要形成的样子如下图：
3、java实现从excel表中取数据 利用Easyexcel这个开源库，我们很容易就能实现该功能，废话不多说，直接上教程！！！！
第一步：根据excel上面的字段名（如下图），我们创建一个类，该成员变量和字段名一一对应 画红线的则为字段名，拿选择题、题目1、答案11、答案12、答案14、答案14、正确答案举例 我们创建一个类，类名为selectquestion
mport com.alibaba.excel.annotation.ExcelProperty; public class selectquestion { @ExcelProperty("选择题") private int num; @ExcelProperty("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ace481cd5cfa693b6b4a3ffec030c2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a06646c64d9f20f491b40a7e19529f63/" rel="bookmark">
			.NET下支持多框架的托盘功能NotifyIconEx（WPF / WinForms / Avalonia / WinUI / MAUI / Wice）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		支持 WPF / WinForms / Avalonia / WinUI / MAUI / Wice 应用。
先看效果：
using NotifyIconEx; var notifyIcon = new NotifyIcon() { Text = "NotifyIcon", Icon = Icon.ExtractAssociatedIcon(Process.GetCurrentProcess().MainModule?.FileName!)! }; notifyIcon.AddMenu("MenuItem1", new Bitmap(ResourceHelper.GetStream("pack://application:,,,/Assets/Images/Lock.png"))); var toDisableItem = notifyIcon.AddMenu("MenuItem2", new Bitmap(ResourceHelper.GetStream("pack://application:,,,/Assets/Images/Lock.png"))); notifyIcon.AddMenu("-"); notifyIcon.AddMenu("MenuItem3"); notifyIcon.AddMenu("MenuItem4", true); notifyIcon.AddMenu("MenuItem5", OnClick); notifyIcon.AddMenu("-"); notifyIcon.AddMenu("SubMenu", null!, [ new ToolStripMenuItem("SubMenuItem1"), new ToolStripMenuItem("SubMenuItem2"), new ToolStripMenuItem("SubMenuItem3"), new ToolStripMenuItem("SubSubMenu", null!, [ new ToolStripMenuItem("SubSubMenuItem1"), new ToolStripMenuItem("SubSubMenuItem2"), new ToolStripMenuItem("SubSubMenuItem3") ]) ]); notifyIcon.AddMenu("-"); notifyIcon.AddMenu("Exit", (_, _) =&gt; Current.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a06646c64d9f20f491b40a7e19529f63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37b994f88015d5a076c818c144030d30/" rel="bookmark">
			【AI大模型】生成式AI的未来——CHAT还是AGENT？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【AI大模型】CHAt还是AGENt？
最近，许多人工智能公司或者部门都在针对Agent——人工智能体有所动作。
例如：
文心一言智能体
Gnomic智能体
英伟达视觉AI代理
那么人工智能概念中的智能体Agent到底是什么呢？它又为何会突然在人工智能市场掀起一阵猛烈的风波呢？它会对将来的人工智能走向带来怎样的影响吗？
AI Agent的定义 AI Agent是**人工智能代理（Artificial Intelligence Agent）**的概念，它是一种能够感知环境、进行决策和执行动作的智能实体，通常基于机器学习和人工智能技术，具备自主性和自适应性，在特定任务或领域中能够自主地进行学习和改进。一个更完整的Agent，一定是与环境充分交互的，它包括两部分——一是Agent的部分，二是环境的部分。此刻的Agent就如同物理世界中的「人类」，物理世界就是人类的「外部环境」。
"AI agent"通常指的是人工智能代理程序，它是一个能够执行特定任务或完成特定目标的计算机程序或系统。这些代理程序通过收集和分析环境信息，并作出相应的决策或执行操作来达到其预定的目标。它们可以是简单的规则系统，也可以是复杂的机器学习模型或深度学习网络。AI agent在自动化、智能系统和人工智能应用中广泛使用，例如自动驾驶汽车、智能家居系统、游戏中的虚拟角色等。
例如以下几个方面：
AI Agent的用途 1. 自动化与效率提升 机器人过程自动化（RPA）：在业务流程中，通过模拟人类操作来自动化重复性任务，提高工作效率。智能文档处理：通过自然语言处理（NLP）技术，自动化处理和分析大量文档，如发票、合同等。 2. 数据分析与决策支持 预测分析：通过机器学习算法对历史数据进行分析，预测未来趋势，如销售预测、市场分析。实时分析：在金融、物流等领域，实时处理和分析大量数据，支持即时决策。 3. 客户服务与用户体验 聊天机器人：通过自然语言处理技术，为客户提供实时的问答服务，提高客户满意度。个性化推荐：在电商平台、流媒体服务等领域，根据用户行为和偏好，提供个性化推荐，提升用户体验。 4. 医疗健康 疾病诊断：利用深度学习和图像处理技术，辅助医生进行疾病诊断，如癌症筛查、心脏病检测。个性化治疗：根据患者的基因数据和病历信息，提供个性化的治疗方案。 5. 金融服务 欺诈检测：通过机器学习算法，实时监控和分析交易数据，检测和防止欺诈行为。自动化交易：利用算法进行自动化交易，提高交易效率和收益。 6. 制造业与工业4.0 预测性维护：通过传感器数据和机器学习模型，预测设备故障，提前进行维护，减少停机时间。智能制造：通过自动化和智能控制系统，优化生产流程，提高生产效率和产品质量。 7. 交通与物流 自动驾驶：通过计算机视觉、传感器融合和深度学习，实现车辆自动驾驶，提升交通安全和效率。智能物流：优化物流路径和仓储管理，提高物流效率和准确性。 8. 教育 个性化学习：根据学生的学习行为和成绩，提供个性化的学习方案和建议，提升学习效果。智能评估：自动化评估学生作业和考试，减少教师工作量，提高评估效率和准确性。 不难看出，Agent主要的目的是用于创建个性化、自动化、智能化的人工智能代理，从而提高办事效率并且减少繁琐的工作。
在去年十一月份的OpenAI开发者大会上，OpenAI官方宣布了GPTs，也就是用户可以创建专属于自己的GPT智能体，无需输入代码，或者只需要低代码，即可生成一个人工智能管家，用以帮助你解决生活上的琐事。
针对化、个性化、高效化、区别化是类似GPTs智能体的主要特点，它将主动权和创造权力全部交给了消费者自己；商人的头脑往往是极度清晰和高速运转的——这样做的目的既可以减小开发者的开发成本，同时还能降低由于自主开发带来的某些消费者评论弊端——好似自助餐或者火锅，你可以自制属于你自己的那道菜，但至于菜好不好吃就是你自己的事了，提供食材的人只需要负食品品质好坏与否的责任了。
如此看来，Agent的发展前景确实广阔并且丰富；随着AI的发展，减少低效工作是必要并且符合时代的，那么Agent就是必不可少的帮手。
那么再转过头来看我们的AI老朋友——Chat，语言大模型，它是否会逐渐淹没于时代的洪流，地位逐渐被Agent取代呢？
我们来看Chat目前的发展趋势和发展程度。
人工智能中的聊天技术（Chat AI）的发展历程和趋势如下：
Chat发展历程 早期聊天机器人（20世纪60年代-80年代）:
ELIZA (1966): 由Joseph Weizenbaum开发的早期聊天机器人，模拟了一个Rogerian心理治疗师，通过模式匹配技术对用户输入进行简单回应。PARRY (1972): 模拟偏执型精神分裂症患者的聊天机器人，由Kenneth Colby开发，使用更多的规则和更复杂的状态机。 基于规则的聊天机器人（1980年代-2000年代初）:
这些机器人依赖于手工编写的规则和脚本，对特定类型的用户输入进行预定义响应。A.L.I.C.E (1995): 使用AIML（人工智能标记语言）编写的聊天机器人，通过大量的规则实现对话。 统计模型与机器学习（2000年代中期-2010年代初）:
Watson (2011): IBM开发的用于Jeopardy!比赛的系统，结合了自然语言处理、信息检索和机器学习技术，标志着聊天机器人的一个重要里程碑。 神经网络和深度学习（2010年代中期-至今）:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37b994f88015d5a076c818c144030d30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17b4eaccffdbc9791c2024f011c1d08c/" rel="bookmark">
			java实战项目-学生管理系统（附带全套源代码）--《基础篇》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 第一个java小型学生管理系统，思路和其他语言都一样，因为有C语言的基础，写这个并不是太难，不过，进阶篇的就难太多了。明天晚上更新进阶篇，因为目前代码还没有完善，保守估计需要500行代码左右。基础篇适合大家练习，没什么特别的注意事项，都是面向对象那部分的知识点。
如果感兴趣的话，可以将小编用C语言编写的那几个系统用java进行改写一下。
C语言实战项目--图书管理系统（附带全套源代码）
C语言项目--企业员工管理系统（附带全套源代码）
C语言实战项目-学生成绩管理系统（附带全套源代码）
明天又是周一了，写完这个系统就要开始进阶篇的学习了。
同时，c++系列也开始更新了。有兴趣的小伙伴们可以看一下，链接放下面了。这个是全套通关系列，预计28篇文章，目前才有一篇文章了，想要学习c++的小伙伴们可以订阅专栏欧Thanks♪(･ω･)
http://t.csdnimg.cn/n5eUnhttp://t.csdnimg.cn/n5eUn
二、系统设计思路 针对每一个功能都应设计相应的方法
1. 添加学生 2. 删除学生 3. 修改学生 4. 查询学生 三、效果展示 添加学生信息 删除学生信息 修改学生信息 四、方法实现 javabeen部分 public class Student { private String id; private String name; private int age; private String gender; private String address; public Student() { } public Student(String id, String name, int age, String gender, String address) { this.id = id; this.name = name; this.age = age; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17b4eaccffdbc9791c2024f011c1d08c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e8542025e28e7fb91122c981ed0d8d1/" rel="bookmark">
			【人工智能】使用Python的dlib库实现人脸识别技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥 个人主页：空白诗 文章目录 一、引言二、传统人脸识别技术1. 基于几何特征的方法2. 基于模板匹配的方法3. 基于统计学习的方法 三、深度学习在脸识别中的应用1. 卷积神经网络（CNN）2. FaceNet和ArcFace 四、使用Python和dlib库实现人脸识别1. 安装必要的库2. 下载模型文件3. 人脸检测与识别代码4. 实现效果 五、总结 一、引言 人脸识别技术已经成为现代技术的重要组成部分，被广泛应用于安全监控、身份验证、智能门禁等领域。
随着机器学习和深度学习技术的发展，人脸识别的准确性和应用范围得到了极大提升。本文将介绍人脸识别技术的发展历程，并展示如何使用Python和dlib库实现简单的人脸识别。
二、传统人脸识别技术 1. 基于几何特征的方法 传统的人脸识别方法主要依赖于几何特征，如眼距、鼻长等，通过分析这些特征进行人脸识别。这些方法受限于光线、角度等外界因素的影响，识别精度较低。 2. 基于模板匹配的方法 模板匹配方法通过预先存储的人脸模板与待识别的人脸图像进行匹配。虽然实现简单，但对表情、姿态变化不够鲁棒。 3. 基于统计学习的方法 主成分分析（PCA）和线性判别分析（LDA）是早期常用的统计学习方法，通过降低图像的维度来实现人脸识别。这些方法提高了识别精度，但仍无法应对复杂的场景变化。 三、深度学习在脸识别中的应用 随着深度学习的兴起，人脸识别技术取得了突破性进展。卷积神经网络（CNN）成为了人脸识别的主要工具。
1. 卷积神经网络（CNN） CNN通过层层卷积操作，从图像中提取出高层次的特征，使得人脸识别更加准确和鲁棒。经典模型如LeNet、AlexNet、VGG、ResNet等在图像识别任务中表现优异。 2. FaceNet和ArcFace FaceNet通过深度神经网络将人脸图像嵌入到一个欧氏空间中，使得同一人的人脸特征距离更近。ArcFace进一步优化了损失函数，使得人脸识别的准确性得到了显著提升。 四、使用Python和dlib库实现人脸识别 接下来，我们将展示如何使用Python和dlib库实现简单的人脸识别。
1. 安装必要的库 pip install opencv-python dlib 2. 下载模型文件 下载 shape_predictor_68_face_landmarks.dat：下载链接下载 dlib_face_recognition_resnet_model_v1.dat：下载链接 下载并解压这两个文件并放置到项目文件目录
3. 人脸检测与识别代码 import cv2 import dlib # 加载dlib人脸检测器 detector = dlib.get_frontal_face_detector() # 加载dlib人脸特征提取器 predictor = dlib.shape_predictor("shape_predictor_68_face_landmarks.dat") # 加载人脸识别模型 face_rec_model = dlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e8542025e28e7fb91122c981ed0d8d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5e57803a4fa3e723bbb89b099501553/" rel="bookmark">
			为什么Spring不推荐@Autowired用于字段注入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 背景 Spring是Java程序员常用的框架之一。官方从Spring 4.0开始不推荐使用@Autowired进行字段注入。 Spring注入方式 基于构造器注入：在构造器上使用@Autowired。
优点：可以声明字段为final，确保字段在构造时被初始化。 基于setter方法注入：在setter方法上使用@Autowired。
优点：在无参数构造器或工厂方法实例化Bean时，Spring会调用setter方法注入依赖。 基于字段注入：在字段上使用@Autowired。
优点：最简洁，无需getter和setter代码，无需声明构造函数。 基于字段注入的缺点 容易引发NPE：Spring不会对依赖的bean是否为null进行判断，可能导致运行时的空指针异常。缓解单一职责原则的违反：字段注入隐藏了依赖关系，可能导致代码质量降低。 Spring官方推荐 推荐使用基于构造器注入的方式。 循环依赖问题 构造器注入可能存在循环依赖问题。解决方案： 重构代码：消除循环依赖，可能成本较高。使用@Lazy注解：延迟初始化bean，解决循环依赖。 总结 Spring提供三种注入方式：字段注入、setter方法注入、构造器注入。官方不推荐使用@Autowired进行字段注入，主要原因是容易引发NPE，且无法在编译时期发现。构造器注入因其在单元测试和不可变性方面的优势，被视为最佳实践。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cf20055c74067e90c45e86d0de906a0/" rel="bookmark">
			JDK 安装及配置教程（Windows）【安装】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、 下载1. 官网下载2. 其它渠道 二、 安装三、 配置四、 验证五、 双 JDK 环境 软件 / 环境安装及配置目录
一、 下载 1. 官网下载 安装地址：https://www.oracle.com/
打开浏览器输入网址 https://www.oracle.com/index.html，进入 Oracle 官网在官网首页菜单栏，点击 Products，在 Hardware and Software 中找到 Java，点击该选项页面往下滑，可以看到如下界面，在该界面中选择 Java SE，找到 Oracle JDK，点击进入 JDK 下载界面
选择需要的 JDK 版本，操作系统，进行下载即可
假如不确定电脑类型，可按 Win + R 打开运行，输入 msinfo32，回车确定后即可查看电脑配置信息
2. 其它渠道 （1）百度网盘（1.8 版本）
链接：https://pan.baidu.com/s/1YJwDMltvczK8FZAwF2dHug?pwd=36m0
提取码：36m0
（2）百度网盘（17 版本）
链接：https://pan.baidu.com/s/1_jslZYt_8A2440gbnhOaXQ?pwd=fs40
提取码：fs40
二、 安装 双击安装程序，一直点击 下一步，直到出现 安装
选择安装路径，这里要注意一点不要有中文路径
JDK 安装成功
1.8 版本还需要单独安装 JRE，创建一个文件夹为 JRE 安装目录
点击 下一步 等待安装
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cf20055c74067e90c45e86d0de906a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb6b807dfef4ba0ad7edc7fc1df9805a/" rel="bookmark">
			Spring AOP（2）原理(代理模式和源码解析)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、代理模式
二、静态代理
三、动态代理
1、JDK动态代理
（1）JDK动态代理实现步骤
（2）定义JDK动态代理类
（3）代码简单讲解
2、CGLIB动态代理
（1）CGLIB 动态代理类实现步骤
（2）添加依赖
（3）自定义MethodInterceptor（方法拦截器）
（4）创建代理类，并使用
（5）代码简单讲解
四、Spring AOP 源码剖析（了解）
五、常见面试题
1、什么是 AOP？
2、Spring AOP的实现方式有哪些？
3、Spring AOP 的实现原理？
4、Spring 使用的是哪种代理方式？
5、JDK 和 CGLIB 的区别？
六、总结
上篇文章学习了 Spring AOP 的应用，接下来我们来学习 Spring AOP 的原理，也就是 Spring 是如何实现 AOP 的。
Spring AOP 是基于动态代理来实现 AOP 的，咱门学习内容主要分以下两部分：
1、代理模式
2、Spring AOP 源码 剖析
一、代理模式 代理模式，也叫 委托模式。
定义：为其他对象提供一种代理以控制这个对象的访问。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用。
某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介作用。
使用代理前：
使用代理后：
生活中的代理：
艺人经纪人：广告商找艺人拍广告，需要经过经纪人，由经纪人来和艺人沟通。
房屋中介：房屋进行租赁时，卖方会把房屋授权给中介，由中介来代理看房，房屋咨询等服务。
经销商：厂商不直接对外销售产品，由经销商负责代理销售。
秘书/助理：合作伙伴找老板谈合作，需要先经过秘书/助理预约。
代理模式的主要角色：
1、Subject：业务接口类。可以是抽象类或者接口（不一定有）。
2、RealSubject：业务实现类。具体的业务执行，也就是被代理对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb6b807dfef4ba0ad7edc7fc1df9805a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62c67af088aa562295a24a2b2c0708da/" rel="bookmark">
			服务韧性工程（SRE）论坛演讲实录 | 雅菲奥朗： 人工智能的未来之路引领智能运维新纪元
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024年5月24日，第二届服务韧性工程（SRE）论坛在杭州成功举办。本次会议由中关村人才协会作为指导单位，中国移动通信集团浙江有限公司和SRE创新联合体（中关村人才协会SRE专委会）联合主办,中移动信息技术有限公司，PeopleCert，雅菲奥朗、观测云等单位协办。会议邀请了来自通信、金融、制造、互联网行业等150余位SRE领域专业人士，共同探讨在数字经济时代下，如何通过技术创新和最佳实践提升企业的服务韧性和运维效率，以及SRE和人工智能领域的最新发展、创新和未来趋势。
在数字化转型的浪潮中，人工智能技术的飞速发展为运维领域带来了革命性的变化。雅菲奥朗作为SRE培训与咨询的引领者，雅菲奥朗的刘峰老师凭借其在AIOps和AI领域的深厚背景和国际视野，发起了主题为《人工智能的未来之路：引领智能运维新纪元》的演讲。刘峰的演讲不仅聚焦于人工智能如何推动运维领域的创新，更深入探讨了大模型技术在提升系统稳定性、可靠性和安全性方面的应用，为SRE领域带来了全新的技术实践趋势。
SRE创新联合体发起人、雅菲奥朗总监 刘峰
SRE创新联合体发起人、雅菲奥朗总监刘峰，带来了一场主题为《人工智能的未来之路：引领智能运维新纪元》的精彩演讲。他深入探讨了新一代人工智能技术，特别是大模型与大语言模型、AIGC等结合，如何在运维研发领域带来创新。这些技术在SRE领域提升了系统的稳定性、可靠性和安全性，成为技术实践的新趋势。与传统AIOps相比，大模型提供了迅速生成解决方案，提供故障修复的代码，从而提升系统的自我修复能力。作为国际认证课程AIOps的授权讲师，刘峰在本次演讲中分享了如何利用大型模型赋能SRE和智能运维的见解，并与SRE专家和爱好者们交流了最新的实践成果。
一、人工智能运维的起源与新发展 ​AIOps是人工智能在IT运维领域的应用，它通过大数据和机器学习技术，解决云计算设施的运维难题，实现自动化和系统的高效稳定运行。与传统的ITOA（IT 运维分析）不同，AIOps更侧重于机器学习和AI算法的运用。
OEA闭环是AIOps的核心，包括观测、介入和自动化三个阶段。观测阶段，通过监控和数据采集建立可观测性；介入阶段，利用自动化措施如Chatbox机器人或脚本处理故障，同时保留人工介入的选项；自动化阶段，通过脚本、自愈和人工处理形成闭环，实现问题的快速解决。AIOps的实践，特别是在最近五年的云计算环境中，推动了一系列新技术的发展，为IT运维带来了创新和变革。
人工智能发展分为三个阶段：狭义AI，依赖监督学习，任务单一；广义AI，通过自监督和端对端模型实现多任务处理；AGI作为终极目标，追求超越人类智能的自主学习与不断进步，同时需加强治理与监管。
大模型作为通用人工智能技术变革的驱动力，通过在海量数据上的预训练，展现出涌现能力、大规模参数和通用性。自2005年以来，从CNN到Transformer架构，大模型发展迅速，参数规模从数亿到万亿级别。代表性模型如Google的BERT、OpenAI的GPT系列，推动了自然语言处理和多模态大模型的进步。2024第二届SRE服务韧性工程论坛强调了大模型在服务韧性工程中的重要性，标志着技术路线优势的显现和"百模大战"态势的形成。
全面可观测性结合大模型和OEA（Observe, Engage, Act）框架，为AIOps带来革新。观测阶段，利用大数据平台收集和监控实时信息。介入阶段，通过机器学习算法分析数据，实现自动化决策支持。行动阶段，执行自动化脚本和措施，形成闭环，提升运维效率和系统稳定性。这一整合框架推动了运维向智能化、自动化的转型，优化了IT服务管理。
二、SRE发展和AI技能要求 在现代IT组织中，运维团队、开发团队和DevOps团队各自扮演着关键角色，共同推动着企业的技术发展和服务质量的提升。运维团队专注于系统的稳定运行和维护，确保服务的可靠性和安全性。开发团队则致力于新功能的开发和现有应用的改进，推动产品的创新和迭代。而DevOps团队则是连接开发与运维的桥梁，通过自动化流程和持续集成/持续部署（CI/CD）实践，加速软件交付周期，提高团队协作效率。这三个团队的紧密合作，是实现高效、敏捷和高质量IT服务的基石。
在2024年第二届运维体系服务韧性工程（SRE）论坛上，AIOps岗位技能要求被明确提出。这些要求包括精通机器学习和数据科学，熟悉云计算技术，掌握自动化和容器化技术如Ansible、Docker、Kubernetes。同时，岗位还要求具备监控和可观测性知识、应急事件处理能力、问题根源分析、AI算法和大模型实操经验、大数据知识、持续实验和优化、自动化运维以及生产环境管理。此外，敏捷和DevOps知识、结构化决策能力、学习和创新能力也是必不可少的行为技巧。
对比传统IT技能与AIOps工程师的新要求。AIOps工程师需掌握基于AIGC的运维研发，结合大模型与大数据技术，强化信息安全与数据安全，同时注重个人隐私保护。职场软技能也需适应云时代的技术发展，包括自动化、智能化生产环境管理，以及持续的学习和创新能力。这标志着IT运维领域正朝着智能化和数据驱动的方向快速演进。
三、大模型引导智能运维的未来 大模型技术正成为智能运维领域的领航者，引领着运维实践的未来发展。这些先进的模型利用AIGC技术，不仅能够自动生成内容，还能通过机器学习深入分析故障，从而实现更加精准的故障预测和快速响应。在数据治理方面，大模型通过智能决策支持系统，优化数据管理和信息流，确保运维过程中的数据安全和合规性。
开源和商业大模型的结合使用，为运维团队提供了丰富的工具和资源，这些模型在处理大规模数据集时展现出卓越的性能，帮助运维人员从繁杂的数据中提取有价值的洞察。随着人工智能算法的不断演进，智能运维系统变得更加自动化和智能化，能够自主执行复杂的任务，减少人为错误，提高运维效率。
智能运维的未来，将是一个高度集成、自我优化的生态系统，大模型技术在其中扮演着核心角色，推动着运维工作向更高层次的智能化发展，为企业的稳定运营和持续创新提供坚实的技术支撑。
四、SRE结合AIGC实现智能运维 SRE（Site Reliability Engineering）领导的自动化，即AI能力的“左移”，是当前IT运维领域的一大趋势。这种趋势强调在软件开发生命周期的早期阶段引入人工智能和机器学习技术，以提高系统的可靠性和稳定性。通过将AI能力前置，SRE能够更早地识别和解决潜在问题，从而减少生产环境中的故障和中断。
SRE领导的自动化不仅仅是技术的引入，更是一种文化和流程的变革。通过“左移”AI能力，SRE团队能够在软件开发的早期阶段就开始优化系统设计，实现更加精细化的故障预防和管理。这种自动化不仅提高了系统的稳定性，还提升了开发和运维团队的协作效率。
此外，AIGC技术的发展为SRE带来了新的机遇和挑战。在代码生成、图像生成、机器人客服等领域，AIGC已经展现出其强大的能力。然而，如何确保AIGC生成内容的准确性和可靠性，如何平衡自动化与人工干预的关系，是SRE领域需要深入探讨的问题。
SRE领导的自动化是IT运维向智能化、自动化转型的关键一步。通过引入大模型和AIGC技术，SRE团队能够更早地介入问题解决过程，实现更高效、更可靠的系统运维。同时，这也要求SRE团队不断学习和适应新技术，以确保在快速变化的技术环境中保持领先地位。
结语：
在雅菲奥朗刘峰老师的精彩演讲中，我们得以一窥人工智能如何塑造智能运维的未来。他不仅展示了大模型技术在SRE领域的创新应用，更激发了我们对智能运维新纪元的无限憧憬。随着大模型和AIGC技术的不断进步，系统的自我修复能力将得到前所未有的提升。刘峰老师的分享和交流，为SRE专家和爱好者们提供了宝贵的知识财富，也为智能运维的发展指明了方向。让我们共同期待，在人工智能的引领下，智能运维将迎来更加辉煌的明天。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/148ba57ebdf4322831aa5ac54b8509db/" rel="bookmark">
			map/multimap容器及STL案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.map概念：map中所有元素都是pair
pair中的第一个元素为key（键值）起到索引作用，第二个为value（实值）
所有元素都会根据key值自动排序
本质：map/multimap属于关联式容器，底层结构是用二叉树实现
优点：可以根据key值快速找到value值
map和/multimap区别：是否允许有相同的key值（都允许有重复的value值）
2.map的构造和赋值
void PrintMap(map&lt;int, int&gt;&amp; m) { for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++) { cout &lt;&lt; "key值= " &lt;&lt; it-&gt;first &lt;&lt; " value值=" &lt;&lt; (*it).second &lt;&lt; endl; } cout &lt;&lt; endl; } void test01() { map&lt;int, int&gt; m1; m1.insert(pair&lt;int, int&gt;(1, 10));//匿名队组实现插入 m1.insert(pair&lt;int, int&gt;(2, 20));//插入按照key值自动排序 m1.insert(pair&lt;int, int&gt;(4, 40)); m1.insert(pair&lt;int, int&gt;(3, 30)); m1.insert(pair&lt;int, int&gt;(5, 50)); PrintMap(m1); map&lt;int, int&gt; m2(m1);//拷贝构造 PrintMap(m2); map&lt;int, int&gt; m3; m3 = m1; PrintMap(m3);//operator=赋值 } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/148ba57ebdf4322831aa5ac54b8509db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/846e7b5517a819d31966719a0548a9a3/" rel="bookmark">
			【爱上C&#43;&#43;】list用法详解、模拟实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一：list介绍以及使用1.list介绍2.基本用法①list构造方式②list迭代器的使用③容量④元素访问⑤插入和删除⑥其他操作image.png 3.list与vector对比 二：list模拟实现1.基本框架2.节点结构体模板3.__list_iterator 结构体模板①模板参数说明②构造函数③迭代器类：拷贝构造、赋值操作、析构函数的说明④++运算符和--运算符⑤==和!=⑥*运算符⑦-&gt;运算符 4.list结构体模板①默认成员函数为什么不能传引用？ ②迭代器③增删查改④其他操作 5.完整代码展示以及详细注释 一：list介绍以及使用 1.list介绍 文档在这里→官方文档←
list是可以在常数范围内（ 时间复杂度为O(1) ）在任意位置进行插入和删除的序列式容器，并且该容器可以前后双向迭代(双向迭代器)。list的底层是双向链表结构，双向链表中每个元素存储在互不相关的独立节点中，在节点中通过指针指向其前一个元素和后一个元素。list与forward_list非常相似：最主要的不同在于forward_list是单链表，只能朝前迭代，已让其更简单高效。与其他的序列式容器相比(array，vector，deque)，list通常在任意位置进行插入、移除元素的执行效率更好。与其他序列式容器相比，list和forward_list最大的缺陷是不支持任意位置的随机访问，比如：要访问list的第6个元素，必须从已知的位置(比如头部或者尾部)迭代到该位置，在这段位置上迭代需要线性的时间开销；list还需要一些额外的空间，以保存每个节点的相关联信息(对于存储类型较小元素的大list来说这可能是一个重要的因素) 2.基本用法 ①list构造方式 list&lt;int&gt; l1; // 构造空的l1 list&lt;int&gt; l2(4, 100); // l2中放4个值为100的元素 list&lt;int&gt; l3(l2.begin(), l2.end()); // 用l2的[begin(), end()）左闭右开的区间构造l3 list&lt;int&gt; l4(l3); // 用l3拷贝构造l4 // 以数组为迭代器区间构造l5 int array[] = { 16,2,77,29 }; list&lt;int&gt; l5(array, array + sizeof(array) / sizeof(int)); // 列表格式初始化C++11 list&lt;int&gt; l6{ 1,2,3,4,5 }; ②list迭代器的使用 此处，大家可暂时将迭代器理解成一个指针，该指针指向list中的某个节点。
【注意】
begin与end为正向迭代器，对迭代器执行++操作，迭代器向后移动rbegin(end)与rend(begin)为反向迭代器，对迭代器执行++操作，迭代器向前移动
int main() { // 创建一个整数列表，并初始化列表 list&lt;int&gt; mylist = {1, 2, 3, 4, 5}; // 使用 begin() 和 end() 迭代器遍历列表 cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/846e7b5517a819d31966719a0548a9a3/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/127/">«</a>
	<span class="pagination__item pagination__item--current">128/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/129/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>