<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eecd6ac20a3a927dda2534aa6f59995/" rel="bookmark">
			Flink-StarRocks详解:第四部分StarRocks分区管理，数据压缩(第54天)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言2.3.3 管理分区2.3.3.1 增加分区2.3.3.2 删除分区2.3.3.3 恢复分区2.3.3.4 查看分区 2.3.4 设置分桶2.3.4.1 随机分桶（自 v3.1）2.3.4.2 哈希分桶2.3.4.2.1 优点2.3.4.2.2 如何选择分桶键2.3.4.2.3 注意事项 2.3.4.3 确定分桶数量 2.3.5 最佳实践 2.4 数据压缩2.4.1 选择数据压缩算法2.4.2 设置数据压缩算法 2.5 排序键和前缀索引2.5.1 排序原理2.5.2 排序效果2.5.3 选择排序列 3. 导入导出数据 前言 本文为Flink-StarRocks详解后续章节：主要详解StarRocks分区分桶管理，数据压缩，
由于篇幅过长，后续接着下面进行详解：
 StarRocks查询数据湖
 实现即席查询案例
2.3.3 管理分区 2.3.3.1 增加分区 对于 Range 分区和 List 分区，可以手动增加新的分区，用于存储新的数据，而表达式分区可以实现导入新数据时自动创建分区，无需手动新增分区。 新增分区的默认分桶数量和原分区相同。也可以根据新分区的数据规模调整分桶数量。
如下示例中，在 site_access5 表添加新的分区，用于存储新月份的数据：
ALTER TABLE test.site_access5 ADD PARTITION p4 VALUES LESS THAN ("2020-04-30") DISTRIBUTED BY HASH(site_id); 2.3.3.2 删除分区 执行如下语句，删除 site_access5 表中分区 p1 及数据：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2eecd6ac20a3a927dda2534aa6f59995/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3391fa669b02930c068d92f56c9a7c2b/" rel="bookmark">
			从Excel高手到SQL大师-解锁数据分析的无限潜力 -10分钟读懂职场必备技能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Excel 和 SQL：看似相似却大不相同的数据处理利器Excel vs SQL：表面相似，本质迥异Excel：直观但受限的电子表格SQL：强大而灵活的数据库查询语言 从 Excel 到 SQL：跨越鸿沟Excel 数据筛选SQL 数据筛选 结语：各有所长，相辅相成 深入浅出：从 Excel 函数到 SQL 查询的进阶之路Excel 函数与 SQL 语句的对应关系1. 求和函数2. 条件统计3. 数据查找 从 Excel 思维转向 SQL 思维实战案例：销售数据分析Excel 分析步骤SQL 分析查询 结语：学习 SQL 的收益 SQL 进阶：超越基础，成为数据分析高手1. 窗口函数：数据分析的神器实例：计算移动平均 2. 公共表表达式（CTE）：提高查询可读性实例：分析销售增长 3. 递归查询：处理层级数据实例：展开员工层级 4. 高级聚合：复杂的数据汇总实例：计算中位数和四分位数 5. 全文搜索：处理非结构化数据实例：在产品描述中搜索关键词 结语：SQL 的无限可能 Excel 和 SQL：看似相似却大不相同的数据处理利器 你是否曾经想过，精通 Excel 就等同于掌握 SQL？这个问题可能困扰着许多数据分析初学者。让我们深入探讨这两个强大工具的异同，揭示它们各自的独特之处。
Excel vs SQL：表面相似，本质迥异 乍看之下，Excel 和 SQL 似乎在处理表格数据方面有许多共同点。但实际上，它们的工作方式和适用场景大相径庭。
Excel：直观但受限的电子表格 Excel 作为一款广泛使用的电子表格软件，其优势在于：
直观的图形界面简单的公式和函数适合小型数据集处理 然而，当面对大规模数据时，Excel 往往力不从心：
行数限制（最多 1,048,576 行）处理速度随数据量增加而显著下降难以处理复杂的多表关联查询 SQL：强大而灵活的数据库查询语言 SQL（Structured Query Language）则是专为大规模数据处理而生：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3391fa669b02930c068d92f56c9a7c2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/345d504432025952bff5911a84a5e316/" rel="bookmark">
			【React】探讨className的正确使用方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、`className`的正确用法二、常见错误解析三、实例解析四、错误分析与解决五、注意事项六、总结 在React开发中，正确使用className属性对组件进行样式设置至关重要。然而，由于JavaScript和JSX的特殊性，开发者常常会犯一些小错误，例如将类名用单引号包裹。这些细微的错误可能会导致组件样式无法正确应用。本文将详细介绍className的正确用法，并深入探讨一个常见的错误：错误地将JavaScript表达式用单引号包裹成字符串。通过理解这个错误的本质，我们可以更高效地编写React代码。
一、className的正确用法 什么是className？ 在HTML中，我们使用class属性为元素指定一个或多个CSS类名，以便应用对应的样式。在React中，由于class是JavaScript的保留字，我们使用className来代替class。通过className属性，我们可以为React组件添加一个或多个CSS类名，从而控制组件的外观和风格。
在JSX中使用className 在JSX中，我们通常有两种方式为className赋值：使用大括号{}和使用单引号''。这两种方式的区别在于它们处理的是JavaScript表达式还是字符串。
二、常见错误解析 错误地使用单引号 在使用React时，可能会犯一个常见错误：将className的值用单引号包裹成字符串。这个错误通常发生在动态类名的使用场景中。
&lt;Chip key={name} size='small' label={name} className='classes.chip' /&gt; 在上述代码中，className='classes.chip'实际上将整个字符串'classes.chip'作为类名，而不是JavaScript表达式classes.chip的结果。这样会导致组件无法正确应用预期的样式。
正确的用法：使用大括号 正确的做法是使用大括号来包裹JavaScript表达式，以便动态获取类名。
&lt;Chip key={name} size='small' label={name} className={classes.chip} /&gt; 在这个例子中，className={classes.chip}中classes.chip是一个JavaScript表达式，表示从classes对象中获取chip属性的值。这种方式确保了组件能够正确地应用CSS样式。
三、实例解析 静态类名 对于固定的类名，可以使用字符串：
&lt;div className="static-class-name"&gt;Content&lt;/div&gt; 此时，static-class-name是一个固定的字符串。
动态类名 对于动态生成的类名，需要使用大括号包裹JavaScript表达式：
&lt;div className={condition ? "class-true" : "class-false"}&gt;Content&lt;/div&gt; 在这个例子中，className的值根据condition的布尔值动态变化。
四、错误分析与解决 错误的用法 &lt;Chip key={name} size='small' label={name} className='classes.chip' /&gt; 这种错误的用法会导致样式无法应用，因为'classes.chip'只是一个字符串，而不是对象的属性。
正确的改法 &lt;Chip key={name} size='small' label={name} className={classes.chip} /&gt; 通过使用大括号，className属性将正确地应用classes.chip的值。
五、注意事项 使用大括号的语义 大括号内的内容表示JavaScript表达式，这点在JSX中非常重要。开发者需要理解大括号的使用语法，以避免类似的错误。
调试和测试 在开发过程中，及时调试和测试是非常重要的。如果发现样式没有应用，可以通过检查className属性的值来确认是否有错误。
团队协作与代码审查 在团队开发中，代码审查是避免此类错误的重要环节。确保团队成员了解正确的用法，并在代码审查中检查类似的错误，可以提高代码质量。
六、总结 通过本文的讨论，我们深入探讨了React中className属性的正确用法和常见错误。理解这些基础概念和错误原因，不仅有助于编写高质量的React代码，还能提高开发效率和用户体验。
静态和动态类名的用法：了解如何在JSX中正确使用静态和动态类名。常见错误及其解决方法：识别并修复因错误使用单引号而导致的样式问题。开发中的最佳实践：通过调试、测试和代码审查，确保代码的正确性和可维护性。 推荐：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/345d504432025952bff5911a84a5e316/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0d67995c8e19a15dc14bd11b5b268e3/" rel="bookmark">
			Meta最新SAM2模型开源直接封神
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024年7月29日，Meta在官网发布SAM2开源消息：segment-anything-2
开源地址：https://github.com/facebookresearch/segment-anything-2paper：sam-2-segment-anything-in-images-and-videosdemo体验：https://ai.meta.com/sam2/ 要点：
继图像元分割模型(SAM) 取得成功之后，最新发布SAM 2，这是一个用于在图像和视频中实时提示对象分割的统一模型，可实现最先进的性能。开源SA-V 数据集，其中包括大约51,000 个真实世界视频和超过 600,000 个 masklet（时空掩模）。SAM 2 可以分割任何视频或图像中的任何对象即使对于以前从未见过的对象和视觉域也是如此，从而无需进行自定义调整即可实现多种使用案例。SAM 2 具有许多潜在的实际应用。例如，SAM2 的输出可与生成视频模型一起使用，以创建新的视频效果并解锁新的创意应用。SAM 2还可以帮助更快地注释视觉数据，以构建更好的计算机视觉系统。SAM 2 网络演示的预览，允许分割和跟踪视频中的对象并应用效果。
如何打造 SAM 2
SAM 能够学习图像中物体的一般概念。然而，图像只是动态现实世界的静态快照，其中视觉片段可以表现出复杂的运动。许多重要的现实世界用例需要在视频数据中进行准确的对象分割，例如在混合现实、机器人、自动驾驶汽车和视频编辑中。相信通用分割模型应该适用于图像和视频。
图像可以看作是一段只有一帧的非常短的视频。采用这种观点来开发一个统一的模型，无缝支持图像和视频输入。处理视频的唯一区别是，模型需要依靠内存来回忆该视频之前处理过的信息，以便在当前时间步准确分割对象。
成功分割视频中的对象需要了解实体在空间和时间中的位置。与图像中的分割相比，视频带来了重大的新挑战。物体运动、变形、遮挡、光线变化和其他因素可能会在每一帧之间发生巨大变化。由于相机运动、模糊和分辨率较低，视频质量通常低于图像，这增加了难度。因此，现有的视频分割模型和数据集无法为视频提供类似的“分割任何内容”功能。在构建 SAM 2 和新 SA-V 数据集的工作中解决了许多这些挑战。
与用于 SAM 的方法类似，在实现视频分割功能方面的研究涉及设计新任务、模型和数据集。首先开发可提示的视觉分割任务，并设计一个能够执行此任务的模型 (SAM 2)。使用 SAM 2 来帮助创建视频对象分割数据集 (SA-V)，该数据集比目前存在的任何数据集都要大一个数量级，并用它来训练 SAM 2 以实现最先进的性能。
可提示的视觉分割
SAM 2 支持选择和细化任何视频帧中的对象。
设计了一个可提示的视觉分割任务，将图像分割任务推广到视频领域。SAM 经过训练，可以将图像中的点、框或蒙版作为输入，以定义目标对象并预测分割蒙版。借助 SAM 2，训练它接受视频任意帧中的输入提示，以定义要预测的时空蒙版（即“蒙版小片”）。SAM 2 根据输入提示立即预测当前帧上的蒙版，并将其在时间上传播以生成所有视频帧中的目标对象的蒙版小片。一旦预测了初始蒙版小片，就可以通过在任意帧中向 SAM 2 提供额外提示来迭代细化它。这可以根据需要重复多次，直到获得所需的蒙版小片。
从SAM 到 SAM 2 的架构演变：
SAM 2 架构可视为 SAM 从图像到视频领域的推广。SAM 2 可通过点击（正或负）、边界框或掩码来提示，以定义给定帧中对象的范围。轻量级掩码解码器采用当前帧的图像嵌入和编码提示来输出该帧的分割掩码。在视频设置中，SAM 2 将此掩码预测传播到所有视频帧以生成掩码。然后可以在任何后续帧上迭代添加提示以优化掩码预测。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0d67995c8e19a15dc14bd11b5b268e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e1ee90b7e85b65c615f06bb45f750aa/" rel="bookmark">
			[SA8155] 探索QNX Hypervisor如何管理Android系统的AB分区（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文建议在对高通8155车机系统有一定的了解下进行阅读
文章目录
前言
一、VMM中的关键LOG
二、VMM中的关键CODES
1.VMM状态机管理
2.QNX的slot状态
3.Android的slot状态
总结
参考
前言 高通SA8155的基建默认采用的是A/B系统升级作为OTA升级方案。
而在虚拟化系统中，如何保证Host QNX和Guest Android两个不同系统的AB分区一致是个值得探究的问题。
本文探索了，Host QNX中的资源管理模块VMM(Virtual Machine Manager)在启动Android虚拟机的时候是如何获取Android系统的AB分区信息。
一、VMM中的关键LOG 关于高通的虚拟机资源管理器VMM见文末参考，这里以该模块打印的log作为引子。
在启动Android虚拟机的log中，一行来自vmm_service的关键log提示了Host QNX和Guest Android的slot状态(A/B升级系统中用slots表示ab分区集合状态，参考Android OTA A/B system update)：
Jan 01 00:00:07.830 vmm.868420 default 16130 vmm_service[vmm_fsm.c:762]:
guest target slot : a host current slot: b Config slot:@/mnt/vm/images/la_dp_enabled_a.config
根据这行log中，我们可以获取以下信息：
打印来自VMM模块的vmm_fsm.c文件guest指的是Android系统，目标slot为ahost指的是QNX系统，当前slot为bguest slot配置文件名为/mnt/vm/images/la_dp_enabled_a.config 从中可以推测出以下信息：
QNX和Android可以处于不同的AB分区状态下运行根据配置文件名，可以推断此配置的两个使用条件： 动态分区被使能slot为a的分区配置被采用 二、VMM中的关键CODES 通过以上分析可以发现，在Android虚拟机启动的过程中，VMM模块参与了安卓AB分区的管理。
让我们进一步进行探索：
1.VMM状态机管理 由获取的信息定位到这行关键的log在vmm_fsm.c文件的位置：
static int launch_gvm(struct gvm_context *ctx) { ... if (ctx-&gt;vm_avb_version == 2) { pthread_barrier_wait(&amp;ctx-&gt;config_barrier); if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e1ee90b7e85b65c615f06bb45f750aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce6470157c4e5073347531df7f596ba9/" rel="bookmark">
			【前端素材】推荐优质多用途水果外卖电商手机系统GoFruit平台模板（附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、需求分析 1、功能分析 多用途水果外卖电商手机系统是一个专门为水果销售和配送设计的移动应用程序，旨在连接水果供应商与消费者，提供便捷的购物和配送体验。该系统不仅支持在线选购水果，还可以实现多种功能，如订单管理、支付处理、物流追踪等。以下是对该系统的详细分析，包括其主要功能、实现步骤和未来发展趋势。
多用途水果外卖电商手机系统的主要功能 用户注册与登录：支持用户通过手机号、邮箱或社交媒体账户注册和登录，提供用户信息管理和账户安全。
商品浏览与搜索：分类展示：按水果种类（如苹果、香蕉、橙子等）进行分类展示搜索功能：用户可以通过关键词快速找到所需水果。
商品详情页：提供每种水果的详细信息，包括价格、重量、产地、保质期、营养成分等支持用户评价和评分，帮助其他消费者做出购买决策。
购物车管理：用户可以将选中的水果添加到购物车，方便一次性结算支持购物车内商品的增减、删除和数量调整。
在线支付：支持多种支付方式，包括信用卡、借记卡、支付宝、微信支付等。确保支付过程安全、快捷。
订单管理：用户可以查看订单历史，跟踪订单状态（如待发货、配送中、已完成等）。支持订单取消和退款申请。
配送管理：提供实时物流追踪，用户可以查看配送员的位置和预计到达时间。支持选择配送时间和地址，提供灵活的配送选项。
用户反馈与客服支持：提供在线客服功能，帮助用户解决问题。用户可以提交反馈和建议，帮助平台改进服务。
促销与优惠活动：定期推出优惠券、满减活动、会员折扣等，吸引用户购买。推送通知提醒用户参加活动。
数据分析与报告：管理员可以获取销售数据、用户行为分析等，帮助制定运营策略。
2、前端游戏的实现： 技术栈选择：根据游戏的需求和目标平台，选择合适的前端技术栈。常用的技术包括HTML5、CSS3、JavaScript（及其框架和库，如React、Vue等）、Canvas、WebGL等。游戏引擎：为了简化开发过程和提高效率，许多开发者会选择使用现有的游戏引擎，如Phaser、Three.js、Babylon.js等。这些引擎提供了丰富的功能和工具，可以帮助开发者更快地创建游戏。资源加载和管理：前端游戏需要加载和管理各种资源，如图像、音频、字体等。开发者需要确保这些资源能够在需要时快速加载，并在不再需要时进行适当的释放。性能优化：为了提高游戏的性能和响应速度，开发者需要进行一系列的性能优化措施，如减少DOM操作、使用请求动画帧（requestAnimationFrame）进行动画渲染、进行代码压缩和合并等。测试和调试：在开发过程中，开发者需要对游戏进行充分的测试和调试，以确保游戏在各种情况下都能正常运行，并修复可能存在的错误和问题。发布和部署：完成开发后，开发者需要将游戏发布到Web服务器上，以便玩家可以通过浏览器进行访问。这通常涉及到将游戏文件上传到服务器、配置服务器环境以及设置域名和HTTPS等步骤。 总的来说，前端游戏是利用Web前端技术创建的一种互动娱乐形式。它们具有丰富的功能和多样的实现方式，为玩家提供了便捷且有趣的娱乐体验。
3、设计思路 用户友好性：界面简洁直观，易于操作，减少用户的学习成本。模块化设计：将系统功能模块化，每个模块负责一类功能，方便扩展和维护。权限控制：根据用户角色设定不同的权限，确保用户只能访问其权限范围内的功能。数据安全：对用户数据进行加密存储、访问控制等措施，保护用户隐私和系统安全。Responsiveness：后台管理系统应当是响应式设计，能够适配不同设备屏幕大小，包括电脑、平板和手机等。日志功能：记录关键操作日志，保留操作痕迹，便于审计和追踪问题。系统性能：考虑系统的性能优化，包括减少不必要的数据读写、合理利用缓存等，提高系统响应速度。 二、界面展示 1、系统首页
2、商品广告
3、商品详情
4、用户评论
4、购物车
5、历史订单
6、购物分析
7、个人主页
8、心愿单
9、个人设置
10、登录页
三、资源获取 多用途水果外卖电商手机模板.zip资源-CSDN文库
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dfe86b031cad4464fee3bff604fcfd7/" rel="bookmark">
			C&amp;C&#43;&#43;:贪吃蛇小游戏教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		❀创作不易，关注作者不迷路❀😀😀 目录
😀贪吃蛇简介
😃贪吃蛇的实现
🐍生成地图
🐍生成蛇模块
❀定义蛇的结构体
❀初始化蛇的相关信息
❀初始化食物的相关信息
🐍光标定位和隐藏
❀如何隐藏光标
❀如何定位光标
🐍蛇的移动
❀Sleep()函数：一个让程序暂停的函数
❀删除轨迹
🐍控制键盘改变蛇的移动方向
🐍吃食物获得积分
🐍蛇死亡，结束游戏
😀完整代码
😀拓展 😀贪吃蛇简介 贪吃蛇是一款经典的小游戏，通过控制蛇头方向吃食物，使得蛇🐍变长，从而获得积分，通过上下左右键控制蛇的移动方向，寻找吃的东西，每吃到一口就能得到一定的积分，而且蛇的身子会越来越长，难度也越来越大，不能碰墙，也不能咬到自己的身体和尾巴，否则游戏结束，总体来说这款小游戏既简单又耐玩，至今仍是一款风靡全球的小游戏，也是编程入门学习的热门小游戏，今天将带领大家实现这款小游戏
😃贪吃蛇的实现 🐍生成地图 首先生成一张长为60，宽为20的地图
生成地图，只有在边界时输出“+”，其余地方输出“ ”
#define H 20 #define W 60 void show_wall() { for (int i = 0; i &lt;= H; i++) { for (int j = 0; j &lt;= W; j++) { if (i == H || j == W)printf("+"); else printf(" "); } puts(""); } } 🐍生成蛇模块 ❀定义蛇的结构体 typedef struct body {//记录坐标 int x; int y; }BODY; typedef struct snake { int size;//蛇的长度 BODY list[W * H];//蛇的位置,最大可以铺满整个墙	BODY food;//定义BODY类型的food变量，存储食物的位置信息 COORD coord;//光标相关的结构体，不需要自己写，是本来就有的 int dx;//x轴移动方向 int dy;//y轴移动方向 int score;//分数 BODY tail;//记录尾巴的位置，后续蛇的移动需要 }SNAKE; ❀初始化蛇的相关信息 初始化时蛇的长度为2，并且在地图最中间生成蛇🐍
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dfe86b031cad4464fee3bff604fcfd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/286e9a6bc2ad64237426d60c0228a9ef/" rel="bookmark">
			将 HuggingFace 模型转换为 GGUF 及使用 ollama 运行 —— 以 Qwen2-0.5B 为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近，阿里发布了Qwen2的系列模型，包括0.5B, 1.5B, 7B, 57B-A14B 和 72B，中英文效果都很好。
因为模型太新，目前还没有 GGUF 版本可以下载，于是转下GGUF，并分享转换教程。
什么是 GGUF？ GGUF 格式的全名为（GPT-Generated Unified Format），提到 GGUF 就不得不提到它的前身 GGML（GPT-Generated Model Language）。GGML 是专门为了机器学习设计的张量库，最早可以追溯到 2022/10。其目的是为了有一个单文件共享的格式，并且易于在不同架构的 GPU 和 CPU 上进行推理。但在后续的开发中，遇到了灵活性不足、相容性及难以维护的问题。
为什么要转换 GGUF 格式 在传统的 Deep Learning Model 开发中大多使用 PyTorch 来进行开发，但因为在部署时会面临相依 Lirbrary 太多、版本管理的问题于才有了 GGML、GGMF、GGJT 等格式，而在开源社群不停的迭代后 GGUF 就诞生了。
GGUF 实际上是基于 GGJT 的格式进行优化的，并解决了 GGML 当初面临的问题，包括：
可扩展性：轻松为 GGML 架构下的工具添加新功能，或者向 GGUF 模型添加新 Feature，不会破坏与现有模型的兼容性。对 mmap（内存映射）的兼容性：该模型可以使用 mmap 进行加载（原理解析可见参考），实现快速载入和存储。（从 GGJT 开始导入，可参考 GitHub）易于使用：模型可以使用少量代码轻松加载和存储，无需依赖的 Library，同时对于不同编程语言支持程度也高。模型信息完整：加载模型所需的所有信息都包含在模型文件中，不需要额外编写设置文件。有利于模型量化：GGUF 支持模型量化（4 位、8 位、F16），在 GPU 变得越来越昂贵的情况下，节省 vRAM 成本也非常重要。 动手来转档、量化和上传 整个转档的步骤如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/286e9a6bc2ad64237426d60c0228a9ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ab9f421a3fdb62cfe31b5a41d48f1e5/" rel="bookmark">
			《LeetCode热题100》---＜5.①普通数组篇五道＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇博客讲解LeetCode热题100道普通数组篇中的五道题
第一道：最大子数组和（中等）
第二道：合并区间（中等）
第一道：最大子数组和（中等） 法一：贪心算法 class Solution { public int maxSubArray(int[] nums) { int len = nums.length; int cur_sum = nums[0]; int max_sum = cur_sum; for(int i = 1; i &lt;len; i++){ cur_sum = Math.max(nums[i],cur_sum+nums[i]); max_sum = Math.max(cur_sum,max_sum); } return max_sum; } } 1.将当前和与最大和设置为数组第一个元素 2.从第二个元素开始遍历数组元素。
令当前和等于 当前元素 和 当前和+当前元素 的最大值令最大和等于 当前和 与 最大和 的最大值 3.返回最大和，即为答案。
法二：动态规划 class Solution { public int maxSubArray(int[] nums) { int pre = 0, maxAns = nums[0]; for (int x : nums) { pre = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ab9f421a3fdb62cfe31b5a41d48f1e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae70056738a48e9e32e5ae7f8178413e/" rel="bookmark">
			linux 常用的命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、文件和目录操作 ls：列出目录内容。cd：切换当前工作目录。pwd：显示当前工作目录的绝对路径。mkdir：创建新目录。rmdir：删除空目录。rm：删除文件或目录（使用-r选项递归删除目录）。cp：复制文件或目录。mv：移动或重命名文件或目录。touch：创建空文件或修改文件时间戳。find：在目录树中搜索文件，并执行指定的操作。 二、文本查看和处理 cat：查看文件内容，并可以将多个文件内容合并后输出。more：分页显示文件内容。less：与more类似，但支持向前和向后翻页。head：显示文件的开头部分。tail：显示文件的末尾部分，常用于查看日志文件。grep：在文件中搜索符合模式的字符串。sed：流编辑器，用于对文本进行过滤和转换。awk：强大的文本分析工具，用于处理和分析文本数据。 三、系统管理和监控 ps：显示当前进程的快照。top：实时显示系统中各个进程的资源占用情况。htop：top的增强版，提供了更丰富的界面和更多的功能。kill：发送信号到进程，通常用于终止进程。free：显示系统的内存使用情况。df：显示磁盘空间的使用情况。du：显示目录或文件的磁盘使用情况。uptime：显示系统运行时间及负载。dmesg：显示或控制内核环形缓冲区的消息。 四、网络配置和监控 ifconfig（或ip addr）：查看和配置网络接口。ping：测试主机之间的网络连通性。netstat：显示网络连接、路由表、接口统计等信息（注意：在某些新版本的Linux中，netstat可能被ss命令取代）。ss：用于显示套接字统计信息，可以看作是netstat的现代替代品。scp：安全地复制文件或目录到远程主机或从远程主机复制文件或目录。ssh：安全地登录到远程主机并执行命令。 五、压缩和解压 tar：打包和解包文件。gzip：压缩或解压缩文件。bzip2：另一种压缩工具，压缩率高于gzip。zip/unzip：用于压缩和解压ZIP格式的文件。 六、用户管理 useradd：添加新用户。usermod：修改用户账户。userdel：删除用户账户。passwd：更改用户密码。groups：显示用户所属的组。groupadd：添加新组。groupdel：删除组。 七、系统启动和关闭 reboot：重启系统。shutdown：关闭系统。 八、其他常用命令 echo：在终端输出字符串或变量。man：查看命令的手册页。history：查看命令历史记录。chmod：更改文件或目录的权限。chown：更改文件或目录的所有者和所属组。 查找特定文件：find / -name "file_name"
打开指定目录：cd /path/to/directory
列出当前目录下的内容：ls
设置环境变量：export VARIABLE_NAME=value
显示网络接口：ifconfig
显示内存使用情况：free -m
显示磁盘使用情况：df -h
添加新用户：adduser username
查看系统日志：tail /var/log/syslog
显示当前登录用户：whoami
关闭防火墙：systemctl stop firewalld
升级系统软件包：yum update
启动特定服务：systemctl start service_name
停止特定服务：systemctl stop service_name
重启计算机：reboot
关机：shutdown now
列出正在运行的进程：ps -ef
杀死进程：kill process_id
重命名文件或目录：mv old_name new_name
复制文件或目录：cp source_file destination
删除文件或目录：rm file_name
使用 tar 打包文件：tar -czvf archive_name.tar.gz directory_to_archive
解压 tar 文件：tar -xzvf archive_name.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae70056738a48e9e32e5ae7f8178413e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f4e0ff8e05bd15da4baadaf1d29d514/" rel="bookmark">
			PHP中如何声明数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组是一种数据结构，用于存储一系列的值或对象，这些值或对象可以通过索引（或键）来访问。在PHP中，数组是一种复合类型的数据结构，可以存储多个值，这些值可以是整型、字符串、布尔值，甚至是数组或其他对象类型。
PHP中如何声明数组 在PHP中，声明数组的方式非常简单，主要有两种方式：
使用array()函数
php复制代码
$array = array("apple", "banana", "cherry"); 使用简短的数组语法
php复制代码
$array = ["apple", "banana", "cherry"]; 数组索引的类型 在PHP中，数组的索引可以是整数或字符串。这意味着PHP支持两种类型的数组：
索引数组（或数值数组）：使用整数作为索引。
php复制代码
$array = [0 =&gt; "apple", 1 =&gt; "banana", 2 =&gt; "cherry"]; // 或者 $array = ["apple", "banana", "cherry"]; 关联数组：使用字符串作为键（索引）。
php复制代码
$array = ["fruit1" =&gt; "apple", "fruit2" =&gt; "banana", "fruit3" =&gt; "cherry"]; PHP数组是非常灵活的，同一个数组中可以同时使用整数和字符串作为索引，但是为了保持代码的可读性和一致性，建议在一个数组中使用统一的索引类型。
什么是字符串索引数组和数值索引数组之间的区别
字符串索引数组和数值索引数组之间的主要区别在于它们使用不同类型的索引来访问数组中的元素。
数值索引数组 索引类型：数值索引数组使用整数作为索引。这些索引通常从0开始，并连续递增。特点： 索引必须是整数。数组通常是有序的，元素的顺序与其索引相关。在大多数编程语言中，数值索引数组是最常见的数组类型。用途：适用于需要按照特定顺序访问或存储数据元素的场景，如列表、集合等。 字符串索引数组（关联数组） 索引类型：字符串索引数组（也称为关联数组）使用字符串作为索引（或键）。这些索引可以是任何有效的字符串值。特点： 索引可以是任何字符串，提供了更灵活的键值对映射关系。数组的顺序通常不与索引的顺序相对应，因为索引是任意的字符串。在一些编程语言中，关联数组也被称为字典（Dictionary）或映射（Map）。用途：适用于需要根据关键字（如名称、标识符等）快速访问数据元素的场景，如数据库查询结果、配置文件等。 区别总结 数值索引数组字符串索引数组（关联数组）索引类型整数字符串有序性通常有序，元素顺序与索引相关元素顺序通常不与索引顺序相对应用途适用于需要按特定顺序访问或存储数据元素的场景适用于需要根据关键字快速访问数据元素的场景示例$array = [0 =&gt; "apple", 1 =&gt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f4e0ff8e05bd15da4baadaf1d29d514/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7543f302c978e6c9496c652bd0872905/" rel="bookmark">
			CSP-J 复赛 模拟题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.生产计划： 样例 #1 样例输入 #1
2 4 5 6 12 1 3 6 15 8 1 3 100 3 200 4 300 6 100 样例输出 #1
YES NO 2.分组和为3： 样 例 # 1
样 例 输 入 # 1 5 1 1 1 2 1 样 例 输 出 # 1 2 样 例 # 2
样 例 输 入 # 2 7 2 2 1 1 2 1 1 样 例 输 出 # 2 3 样 例 # 3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7543f302c978e6c9496c652bd0872905/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/429fbc5f7be162d7a479390eac522dc4/" rel="bookmark">
			【Java】解决如何将Http转为Https加密输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 HTTP转HTTPS一、 获取 SSL/TLS 证书二、 安装证书2.1 Apache2.2 Nginx 三、更新网站配置四. 更新网站链接五. 检查并测试六. 自动续期（针对 Let's Encrypt） HTTP转HTTPS 将网站从 HTTP 转换为 HTTPS 能够加密数据传输，还能提高搜索引擎排名
一、 获取 SSL/TLS 证书 首先，你需要获得一个 SSL/TLS 证书。你可以从以下来源之一获取证书：
免费证书：
Let’s Encrypt：一个免费的、自动化的证书颁发机构（CA），广泛使用且受信任。
付费证书：
著名的 CA：如 DigiCert、GlobalSign、Comodo、Symantec 等提供的付费证书，通常提供更高的信任级别和支持。
二、 安装证书 安装证书的步骤因服务器和托管服务提供商的不同而有所不同。以下是一些常见的 Web 服务器的安装步骤：
2.1 Apache 安装 Certbot（用于 Let’s Encrypt）： sudo apt update sudo apt install certbot python3-certbot-apache 获取并安装证书： sudo certbot --apache 配置 Apache： Certbot 通常会自动配置 Apache。如果需要手动配置，编辑 Apache 配置文件：
sudo nano /etc/apache2/sites-available/your_site.conf 确保包含以下指令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/429fbc5f7be162d7a479390eac522dc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/007e6894498d66a9b021b87f416c6ff9/" rel="bookmark">
			死锁的概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 死锁的概念 在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是死锁发生死锁后若无外力干涉，这些进程都将无法向前推进 死锁、饥饿、死循环的区别 死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先(SPF)算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程饥饿死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的 死锁产生的4个必要条件 互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁不剥夺条件：进程所获得的资源在未使用完成之前，不能由其他进程强行夺走，只能主动释放请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占用，此时请求进程被阻塞，但又对自己已有的资源保持不放循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求 什么时候发生死锁 对不可剥夺资源的不合理分配，可能导致死锁对系统资源的竞争进程推进顺序非法信号量的使用不当 死锁的处理策略 预防死锁：破坏死锁产生的四个必要条件中的一个或几个避免死锁：用某种方法防止系统进入不安全状态，从而避免死锁(银行家算法)死锁的检测和解除：允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4565bf7682d66cc2677e195be8294143/" rel="bookmark">
			C&#43;&#43;初阶学习第五弹——类与对象（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类与对象（上）：C++初阶学习第三弹——类与对象（上）-CSDN博客
类和对象（中）：C++初阶学习第四弹——类与对象（中）-CSDN博客
一.赋值运算符重载 目录
一.赋值运算符重载
1.1 运算符重载
1.2 赋值运算符重载
二.构造函数进阶 2.1构造函数体赋值
1.2 初始化列表
1.3 explicit关键字
三.static成员
四.友元
1.1友元函数
1.2 友元类
1.3 内部类
1.1 运算符重载 C++为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数，也具有其 返回值类型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。
函数名字为：关键字operator后面接需要重载的运算符符号。
函数原型：返回值类型 operator操作符(参数列表)
注意：
1.不能通过连接其他符号来创建新的操作符：比如operator@ 2.重载操作符必须有一个类类型参数
3.用于内置类型的运算符,其含义不能改变，例如：内置的整型+，不 能改变其含义作为类
4.成员函数重载时，其形参看起来比操作数数目少1，因为成员函数的第一个参数为隐藏的this 5. .* :: sizeof ?: . 注意以上5个运算符不能重载。这个经常在笔试选择题中出现。
1.2 赋值运算符重载 1. 赋值运算符重载格式 参数类型：const T&amp;，传递引用可以提高传参效率 2.返回值类型：T&amp;，返回引用可以提高返回的效率，有返回值目的是为了支持连续赋值
3.检测是否自己给自己赋值 4.返回*this ：要复合连续赋值的含义
二.构造函数进阶 2.1构造函数体赋值 在创建对象时，编译器通过调用构造函数，给对象中各个成员变量一个合适的初始值。
class Date { public: Date(int year, int month, int day) { _year = year; _month = month; _day = day; } private: int _year; int _month; int _day; }; int main() { Date d1(); return 0; } 虽然上述构造函数调用之后，对象中已经有了一个初始值，但是不能将其称为对对象中成员变量 的初始化，构造函数体中的语句只能将其称为赋初值，而不能称作初始化。因为初始化只能初始 化一次，而构造函数体内可以多次赋值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4565bf7682d66cc2677e195be8294143/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70ff578656b7af1618fb737006a918d5/" rel="bookmark">
			IDEA常用设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全局project jdk版本设置 1. file-&gt; new project setup -&gt;structure
2.project setting-&gt; project -&gt; sdk选择jdk版本-&gt; aplly -&gt; ok
全局maven仓库设置 1.file-&gt; new project setup -&gt; settings for new projects
2.build,execution,deployment-&gt; buld tools -&gt; maven
3.apply -&gt; ok
自动导包 1.settings-&gt; editor -&gt; general -&gt; auto improt
2.勾选完 -&gt; apply -&gt; ok
自动删除没有用到的包 鼠标滚轮调整字体大小 字体大小和样式行高 设置类注释（作者、日期、注释等） 模板：
/** *@Author: Author *@CreateTime: ${YEAR}-${MONTH}-${DAY} *@Description: ${description} */ 以上可以自定义，但是如果填了${description}的话，在每次创建类的时候都会弹窗提示你输入类注释
修改git提交的账号名称或者邮箱 1. 打开终端terminal查询当前git账号名称
输入：
git config user.name 2. 修改git账号名称
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70ff578656b7af1618fb737006a918d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b834a30f71275c5c4a39c999417c2c5/" rel="bookmark">
			模板进阶【C&#43;&#43;】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 模板的特殊化函数模板特化的作用 函数模板的的特殊化语法：函数模板特化的要求 类模板的特殊化类模板的特殊化的要求类模板的特殊化的语法全特化偏特化实例化部分模板参数对基本类模板（母板）的模板参数进行限制 非类型模板参数非类型模板参数的特点（注意点） 模板的特殊化 模板的特化是对已经存在的模板进行的特殊处理
通常情况下，使用模板可以实现一些与类型无关的代码，但对于一些特殊类型的可能会得到一些我们不想要的结果需要特殊处理
例如
写一个比较函数，如果是直接写成下图的函数模板，我们就只能按照规定好的大小比较方式进行比较
上图的比较虽然按照语法来说是正确的
但是如果我们想写一个当传入的参数的类型是int*的时候，比较的方式是指针解引用之后再比较的话，如果只有上图中的模板就做不到了
这个时候就可以对特殊化出一个模板，专门处理我们的特殊要求
可以看到，这样就完成了我们的对int*类型特殊处理的要求
函数模板特化的作用 作用很简单：
传入的具体类型如果拥有对应的特化模板函数，就会优先调用那个特化的模板函数
例如上面举例的比较大小的模板函数Greater，如果传给Greater的参数类型是int*，那就会优先调用int*特化的模板函数
因为函数模板特化的作用基本只有这个，所以其实函数模板的特化是有替代的，那就是普通的函数没错就是普通的函数，模板初阶【模板初阶【C++】】中就说过，如果既有函数模板又有普通函数时，在传递参数都不会类型转换的情况下，编译器就会优先调用普通函数
例
所以其实函数模板的特化其实挺鸡肋的，因为直接写成普通函数还更好
因为它的语法限制比普通函数多在函数模板特化和普通函数共存时，甚至还会优先调用普通函数 但是类模板的特化就有用得多了
函数模板的的特殊化 语法： template&lt;&gt; 返回值 函数名&lt;具体类型，具体类型，……&gt;（参数表） { 函数体 } 例
具体类型就是要特殊处理的类型【特化类型】
函数模板特化的要求 因为模板的特化是对已经存在的模板进行的特殊处理
所以必须要先有一个基础的函数模板（母板），才能对这个模板进行特殊化关键字template后面的尖括号&lt;&gt;里面一定得是空的，这是语法规定，不是空的就报错
特化的模板函数的参数表: 必须要和基础的函数模板（母板）的参数完全相同
人话：写出来的特化的模板函数的参数表，与把特化类型传给基础的函数模板（母板）后实例化出来的模板函数的参数表一样
不然可能会出现很多奇怪的错误，此时要是实在解决不了，就直接实现成全局函数就行了
类模板的特殊化 类模板的特殊化的要求 因为：模板的特化是对已经存在的模板进行的特殊处理
和函数模板一样，必须要先有一个基础的类模板（母板），才能对这个类模板进行特殊化
类模板的特殊化的语法 template&lt;空 或者 模板参数，模板参数，……&gt; class 类名&lt;具体类型/加上限制的模板参数&gt; { 类体 } 全特化 全特化就是把基本类模板（母板）的模板参数全部实例化
例
全特化了之后，当传给类模板的参数和全特化的模板实例化的参数完全相同的时候，就会调用全特化的类模板实例化对象
如下图：
偏特化 偏特化分两种：
实例化部分模板参数 这样偏特化了之后，传给类模板的参数和偏特化的类模板部分实例化的参数完全相同的时候，就会调用偏特化的类模板进行实例化对象
例
如下图，当传给A类的模板参数，第一个是int时将会调研偏特化的类模板实例化对象
第一个模板参数不是int的时候，才会调用基本类模板（母板）进行实例化对象
对基本类模板（母板）的模板参数进行限制 不实例化基本类模板（母板）的模板参数，而是对它加上限制【加const，*{指针限制}，&amp;（引用限制）等】
这样偏特化了之后，传给类模板的参数和偏特化的限制的参数完全相同的时候，就会调用偏特化的类模板进行实例化对象
例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b834a30f71275c5c4a39c999417c2c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aca8c2f2ebc6f1f8f5b263c58ff633c/" rel="bookmark">
			C&#43;&#43;11深度剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 🚀 前言：C++11简介 一： 🔥 统一的列表初始化💫 2.1 ｛｝初始化 二： 🔥 std::initializer_list 💫 2.1 std::initializer_list是什么类型💫 2.2 std::initializer_list使用场景 三： 🔥 声明 💫 3.1 auto💫 3.2 decltype💫 3.3 nullptr 四： 🔥 范围for循环 五： 🔥 智能指针 六： 🔥 STL中一些变化 七： 🔥 右值引用和移动语义 💫 7.1 左值引用和右值引用💫 7.2 左值引用与右值引用比较💫 7.3 右值引用使用场景和意义💫 7.4 右值引用引用左值及其一些更深入的使用场景分析💫 7.5 完美转发7.5.1 模板中的 &amp;&amp; 万能引用7.5.2 完美转发 八： 🔥 新的类功能 九： 🔥 可变参数模板 💫 9.1 递归函数展开参数包💫 9.2 逗号表达式展开参数包💫 9.3 可变参数包结合完美转发的好处 十： 🔥 lambda表达式 💫 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2aca8c2f2ebc6f1f8f5b263c58ff633c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/990e9aa9afeb9f32d47a0715deb4b6af/" rel="bookmark">
			动态规划，蒙特卡洛，TD,Qlearing,Sars,DQN,REINFORCE算法对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动态规划（Dynamic Programming, DP）通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。
动态规划的步骤 识别子问题：定义问题的递归解法，识别状态和选择。确定DP数组：确定存储子问题解的数据结构，通常是数组或矩阵。确定状态转移方程：找出状态之间的关系，即状态转移方程。边界条件：确定DP数组的初始值或边界条件。填表：按照顺序填入DP表，通常是从最小的子问题开始。构造最优解：根据DP表构造问题的最优解。 动态规划与贪心算法的区别 贪心算法：在每一步选择局部最优解，希望这能导致全局最优解，但不保证总是得到最优解。动态规划：通过考虑所有子问题的解来构建原问题的最优解，通常能保证得到最优解。 动态规划的局限性 时间复杂度：对于某些问题，动态规划的时间复杂度可能很高。空间复杂度：DP算法可能需要大量的存储空间来保存子问题的解。 蒙特卡洛方法用于通过随机模拟来估计和优化策略。
蒙特卡洛方法的关键步骤 初始化：初始化价值函数或策略，通常从零或随机值开始。抽样：进行多次实验，每次实验都遵循当前策略进行随机抽样。收集数据：在每次实验中，记录状态、动作、奖励和新状态。更新估计：根据收集的数据更新价值函数或策略的估计。收敛检查：检查估计是否收敛到稳定值，如果是，则停止迭代。 蒙特卡洛方法的特点 无需模型：不需要环境的模型信息，适用于模型未知的环境。简单直观：基于随机抽样，方法简单直观。样本效率：随着样本数量的增加，估计的准确性提高。方差问题：由于随机性，估计可能具有较高的方差。 蒙特卡洛方法的局限性 计算成本：对于某些问题，可能需要大量的样本才能获得准确的估计。收敛速度：在某些情况下，收敛速度可能较慢。高方差：随机抽样可能导致估计结果的方差较大。 蒙特卡洛方法的变体 蒙特卡洛树搜索（MCTS）：结合了蒙特卡洛模拟和树搜索的方法，用于决策制定，特别是在游戏AI中。蒙特卡洛梯度策略：结合了蒙特卡洛方法和梯度下降，用于优化策略。 TD（Temporal Difference，时序差分）算法是强化学习中的一种重要算法，它用于估计或学习代理（agent）在环境中采取行动时的价值函数（value function）和策略（policy）。TD学习是一种结合了蒙特卡洛方法和动态规划特点的算法，它不需要模型信息，也不需要完整的episodes来更新其估计。
TD学习的基本思想 TD学习的核心思想是利用时间上相邻的状态-奖励对来估计价值函数。它通过以下步骤实现：
初始化：随机或根据某种策略初始化价值函数 V(s)V(s) 和/或动作价值函数 Q(s,a)Q(s,a)。
迭代更新：在每个时间步 tt，根据当前状态 stst​ 采取行动 atat​，观察奖励 rt+1rt+1​ 和新状态 st+1st+1​，然后根据TD更新规则更新价值函数或动作价值函数。
TD更新公式：
对于状态价值函数 VV 的TD(0)更新公式： V(St)←V(St)+α[Rt+1+γV(St+1)−V(St)]V(St​)←V(St​)+α[Rt+1​+γV(St+1​)−V(St​)]对于动作价值函数 QQ 的TD(0)更新公式： Q(St,At)←Q(St,At)+α[Rt+1+γmax⁡aQ(St+1,a)−Q(St,At)]Q(St​,At​)←Q(St​,At​)+α[Rt+1​+γmaxa​Q(St+1​,a)−Q(St​,At​)]其中：
αα 是学习率。γγ 是折扣因子，决定了未来奖励相对于当前奖励的重要性。max⁡aQ(St+1,a)maxa​Q(St+1​,a) 是新状态 St+1St+1​ 下所有可能动作的最大动作价值函数估计。 TD学习的局限性 稳定性：TD学习可能在某些情况下不稳定，特别是当学习率较高或折扣因子较大时。收敛性：TD学习可能不会总是收敛到最优解，特别是当策略不是最优的时候。 Q学习（Q-Learning）是一种无模型的强化学习算法，用于学习代理在环境中采取行动时的最优策略。Q学习的核心思想是通过迭代更新来估计每个状态-动作对的价值，即所谓的Q值（Q-values）。Q值代表了在给定状态下采取特定动作的预期回报。
Q学习的关键概念 Q值（Q(s,a)Q(s,a)）：在状态 ss 下采取动作 aa 的预期回报。折扣因子（γγ）：一个介于 0 和 1 之间的值，用于平衡即时奖励和未来奖励的重要性。探索（Exploration）和利用（Exploitation）：在探索阶段，代理尝试未知的动作以发现更好的策略；在利用阶段，代理使用已知的最佳策略来获得奖励。 Q学习算法的步骤 初始化：为所有状态-动作对 (s,a)(s,a) 初始化 Q 值，通常设置为 0 或小的随机数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/990e9aa9afeb9f32d47a0715deb4b6af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6eb22efed107eecc1284d3bdac38bb1/" rel="bookmark">
			【人工智能】边缘计算与 AI：实时智能的未来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💎 我的主页：2的n次方_ 💎1. 引言 随着物联网设备数量的爆炸性增长和对实时处理需求的增加，边缘计算与人工智能（Edge AI）成为一个热门话题。Edge AI 通过在本地设备上运行 AI 算法，减少对云计算的依赖，实现低延迟、高效能的智能应用。这在自动驾驶、智能家居、工业自动化等领域有着广泛的应用前景。
💎2. 什么是边缘计算与 AI？ 边缘计算是一种分布式计算范式，旨在将计算和数据存储资源移动到数据生成的边缘设备上，而不是依赖于集中式的数据中心。Edge AI 则是在边缘计算架构中部署 AI 模型，使其能够在本地设备上进行实时数据处理和决策。
💎3. 边缘计算与 AI 的优势 低延迟：由于数据处理在本地进行，边缘计算显著减少了数据传输的延迟，满足实时应用的需求。
节省带宽：通过在本地处理数据，只传输必要的信息到云端，大大减少了带宽消耗。
增强隐私：本地数据处理有助于保护用户隐私，减少数据泄露的风险。
高可靠性：即使没有网络连接，本地设备仍然可以继续工作，提高系统的可靠性和稳定性。
💎4. 边缘计算与 AI 的应用场景 1. 自动驾驶：自动驾驶车辆需要实时处理大量传感器数据，如摄像头、雷达和激光雷达。Edge AI 能够在本地进行快速决策，确保行车安全。
2. 智能家居：智能音箱、安防摄像头等设备通过 Edge AI 实现本地语音识别、图像处理等功能，提升用户体验。
3. 工业自动化：在制造业中，Edge AI 可以在生产线本地进行质量检测、设备监控和故障预测，提升生产效率和产品质量。
💎5. 边缘计算与 AI 的技术实现 💎5.1 边缘设备 边缘设备可以是各种类型的硬件，包括单板计算机（如 Raspberry Pi）、嵌入式系统、智能摄像头和工业控制器等。这些设备通常具有有限的计算资源和电源约束，因此需要高效的 AI 模型。
💎5.2 边缘 AI 框架 有多种框架和工具可以帮助开发和部署 Edge AI 模型：
TensorFlow Lite：适用于移动设备和嵌入式设备的轻量级深度学习框架。OpenVINO：由英特尔开发的工具包，用于优化和部署深度学习推理。NVIDIA Jetson：适用于机器人、无人机和智能摄像头的 AI 计算平台。 💎6. 实战：使用 TensorFlow Lite 实现图像分类 以下是一个使用 TensorFlow Lite 在 Raspberry Pi 上实现图像分类的示例。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6eb22efed107eecc1284d3bdac38bb1/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/87/">«</a>
	<span class="pagination__item pagination__item--current">88/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/89/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>