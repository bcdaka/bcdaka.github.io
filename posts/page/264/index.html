<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb09b264d53a12ad3cfe0ba11682c30b/" rel="bookmark">
			配置 SSH 管理多个 Git 仓库和以及多个 Github 账号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在工作中，我们可能需要将代码推送到公司内部的自建 Git 代码托管平台（如 GithLab）。与此同时，日常开发过程中，我们也常常需要将代码提交到社区的 Git 代码托管平台（如 Github 等）。提交到 github 又需要管理多个 github 账号
解决 用过~/.ssh/config配置多个不同的 SSH 认证
# 公司github ssh-keygen -t rsa -C "YourCompanyEmailAdress" # 输入密钥的名称: id_rsa_company Enter file in which to save the key (/Users/username/.ssh/id_rsa): id_rsa_company # github1 ssh-keygen -t rsa -C "GithubEmail1" # 输入密钥的名称: id_rsa_github Enter file in which to save the key (/Users/username/.ssh/id_rsa): id_rsa_github_1 # github12 ssh-keygen -t rsa -C "GithubEmail2" # 输入密钥的名称: id_rsa_github Enter file in which to save the key (/Users/username/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb09b264d53a12ad3cfe0ba11682c30b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/452865ffb6bd4060c61dada38cae4bad/" rel="bookmark">
			深入分析 Android BroadcastReceiver (三)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 深入分析 Android BroadcastReceiver (三)1. 广播消息的优缺点及使用场景1.1 优点1.2 缺点 2. 广播的使用场景及代码示例2.1. 系统广播示例：监听网络状态变化 2.2. 自定义广播示例：发送自定义广播 2.3. 有序广播示例：有序广播 2.4. 本地广播示例：发送本地广播 3. 优化策略4. 总结 深入分析 Android BroadcastReceiver (三) 1. 广播消息的优缺点及使用场景 1.1 优点 松耦合：广播机制允许应用组件之间以松散耦合的方式进行通信，而不需要彼此了解具体实现。灵活性：广播可以在应用的各个部分之间传递消息，甚至跨进程传递。系统广播：系统广播可以通知应用系统事件（如网络变化、电量低等），使得应用能及时响应系统状态变化。 1.2 缺点 性能问题：在主线程中处理广播消息，如果操作耗时，会导致应用卡顿。安全性：公开广播可能被其他应用接收和发送，可能带来安全隐患，需要合理使用权限管理。电量消耗：频繁的广播通信会增加设备的电量消耗，尤其是在后台频繁接收广播时。 2. 广播的使用场景及代码示例 2.1. 系统广播 系统广播是 Android 系统在特定事件发生时发出的广播，比如设备启动完成、网络状态变化等。
示例：监听网络状态变化 在 AndroidManifest.xml 中声明接收器：
&lt;receiver android:name=".NetworkChangeReceiver"&gt; &lt;intent-filter&gt; &lt;action android:name="android.net.conn.CONNECTIVITY_CHANGE"/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 接收器实现：
public class NetworkChangeReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { ConnectivityManager connectivityManager = (ConnectivityManager) context.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/452865ffb6bd4060c61dada38cae4bad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d91000aad52bf1cdca263135cf53f83/" rel="bookmark">
			【C&#43;&#43;】【期末考】【基本概念和语法】概括总结——期末速成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. C++简介
C++的历史与发展
C++的特点与优势
2. 基本语法
注释
数据类型与变量
常量
运算符
输入与输出
3. 控制结构
条件语句
循环语句
4. 函数
函数定义与声明
参数传递
返回值
函数重载
5. 数组与字符串
一维数组
多维数组
字符串处理
6. 指针
指针的定义与使用
指针运算
指针与数组
函数指针
7. 引用
引用的定义与用法
引用与指针的区别
8. 结构体与联合体
结构体定义与使用
联合体定义与使用
枚举类型
9. 类与对象
类的定义与成员
对象的创建与使用
构造函数与析构函数
类的继承
多态与虚函数
运算符重载
10. 模板
函数模板
类模板
11. STL（标准模板库）
容器
算法
迭代器
12. 文件操作
文件读写
文件流
13. 异常处理
1. C++简介 C++的历史与发展 C++是一种面向对象的编程语言，由Bjarne Stroustrup在20世纪80年代初开发。它是在C语言的基础上增加了面向对象的特性，从而既具有C语言的高效性，又提供了高级的编程抽象。C++已经成为许多系统级软件、游戏、嵌入式系统以及高性能计算应用程序的主要编程语言。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d91000aad52bf1cdca263135cf53f83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1d7820f4d7f98ca80cd63389c436cb6/" rel="bookmark">
			SQLite 日期 &amp; 时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQLite 日期 &amp; 时间 SQLite 是一种轻量级的数据库管理系统，广泛用于各种应用程序中。它支持标准的 SQL 语法，包括对日期和时间的处理。在 SQLite 中，日期和时间可以通过几种不同的方式来存储和操作。
日期和时间数据类型 SQLite 使用 DATE、TIME 和 DATETIME 数据类型来存储日期和时间信息。DATE 类型用于存储日期，TIME 类型用于存储时间，而 DATETIME 类型用于存储日期和时间。
日期和时间函数 SQLite 提供了一系列的日期和时间函数，用于处理和格式化日期和时间数据。这些函数包括：
CURRENT_DATE：返回当前日期。CURRENT_TIME：返回当前时间。CURRENT_TIMESTAMP：返回当前日期和时间。DATE()：提取日期部分。TIME()：提取时间部分。DATETIME()：组合日期和时间。strftime()：格式化日期和时间。 示例 以下是一些使用日期和时间函数的示例：
-- 创建一个表，包含日期和时间字段 CREATE TABLE example (id INTEGER PRIMARY KEY, date_field DATE, time_field TIME, datetime_field DATETIME); -- 插入当前日期和时间 INSERT INTO example (date_field, time_field, datetime_field) VALUES (CURRENT_DATE, CURRENT_TIME, CURRENT_TIMESTAMP); -- 提取日期部分 SELECT DATE(datetime_field) FROM example; -- 提取时间部分 SELECT TIME(datetime_field) FROM example; -- 格式化日期和时间 SELECT strftime('%Y-%m-%d %H:%M:%S', datetime_field) FROM example; 注意事项 SQLite 的日期和时间函数可能与其他数据库系统（如 MySQL 或 PostgreSQL）的函数有所不同，因此在进行数据库迁移时需要注意。在使用日期和时间函数时，确保输入的日期和时间格式正确，以避免出现错误。 总结 SQLite 提供了丰富的日期和时间处理功能，使得在应用程序中处理日期和时间数据变得简单和高效。通过使用适当的日期和时间函数，可以轻松地格式化、提取和计算日期和时间数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b10224b89c1b78fab1843fe9312ca6ca/" rel="bookmark">
			我的物联网笔记1——Python&#43;MQTT利用阿里云物联网平台实现图传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近实验有需要用到MQTT传输图像的需求，本人也不太会写除Python以外的代码，恰好今天读到嵌入式圈内的大佬@DS小龙哥的文章：基于阿里云物联网平台设计的实时图传系统 _ 采用 MQTT 协议传输图像
受大佬启发，今天利用Python写一个简单的MQTT图传程序。
软件：
Pycharm
MQTTX
Wireshark
手机端APP：IoT MQTT Panel
由于大佬在文章中已经写了关于在阿里云创建产品、设备及消息转发的相关设置，本文将不再赘述，添加设备后如下图所示：
我们利用Python脚本发送随机数检查设备接收信息的情况：
import time import json import random import paho.mqtt.client as mqtt #username和password #可直接在设备页面一键复制 client_id = f"client_id" timestamp = str(int(time.time())) username = f"username" password = f"password" # MQTT连接地址 broker = f"mqtthosturl" port = 1883 # 回调函数 def on_connect(client, userdata, flags, rc): print("Connected with result code " + str(rc)) client.subscribe(f"/sys/${ProductKey}/${deviceName}/thing/event/property/post") #注意把自己的设备信息更换 def on_message(client, userdata, msg): print(msg.topic + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b10224b89c1b78fab1843fe9312ca6ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cba02119fe6daab2f0cb16d470a3ce21/" rel="bookmark">
			MyBatis/mybatis_plus的项目 如何优雅地打印SQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用MyBatis或者MyBatis-Plus作为ORM框架的时候，会发现默认的日志输出是下面这样的
在参数少并且SQL简单的情况下，这样的SQL我们能通过手动去替换占位符，来获取到真正执行的SQL。但是如果是比较复杂的SQL，或者查询参数比较多的话，一个个替换就比较费时费力了。
MyBatis Plugin
于是我们就可以使用MyBatis对外暴露出的Interceptor接口，来手动实现一个能优雅地打印日志的插件。平常像用的比较多的PageHelper，就是一个MyBatis的插件，实现原理和我们这次要做的功能十分相似。
MyBatis插件的原理
MyBatis插件的实现原理基于Java的动态代理机制。当MyBatis框架在初始化时检测到有插件配置，它会为目标对象（如Executor、StatementHandler等）创建一个代理对象。这个代理对象会包装原始对象，并在方法调用时执行自定义的拦截逻辑。
拦截过程中，如果存在拦截器，且方法的签名与拦截器配置的方法签名匹配，则调用拦截器的intercept方法。在intercept方法中，开发者可以实现自定义的拦截逻辑，通常这里会包含对原始方法调用的修改或增强
MyBatis 插件的几个重点模块
@Intercepts 注解：
这是 MyBatis 提供的一个注解，用于定义一个拦截器。一个拦截器可以拦截一个或多个方法。
@Signature 注解：
这是 @Intercepts 注解的子注解，用于指定要拦截的目标方法。
@Signature 注解的参数分别是：
type：指定要拦截的接口类型。 method：指定要拦截的方法名。 args：指定要拦截的方法的参数类型列表。 实现一个优雅打日志的功能
首先编写一个Interceptor的实现类，具体代码如下，所有的注释都放在代码上了：
其中类上的Intercepts注解含义为：在 Executor 的 query、update 方法执行前后进行自定义的处理，其中Executor 是最底层的执行器，负责与数据库进行通信。它的职责包括创建和缓存 Statement 对象、执行 SQL 语句、处理结果集等。
package com.xa.demo1.config; import lombok.extern.slf4j.Slf4j; import org.apache.ibatis.cache.CacheKey; import org.apache.ibatis.executor.Executor; import org.apache.ibatis.mapping.BoundSql; import org.apache.ibatis.mapping.MappedStatement; import org.apache.ibatis.mapping.ParameterMapping; import org.apache.ibatis.plugin.Interceptor; import org.apache.ibatis.plugin.Intercepts; import org.apache.ibatis.plugin.Invocation; import org.apache.ibatis.plugin.Plugin; import org.apache.ibatis.plugin.Signature; import org.apache.ibatis.reflection.MetaObject; import org.apache.ibatis.session.Configuration; import org.apache.ibatis.session.ResultHandler; import org.apache.ibatis.session.RowBounds; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cba02119fe6daab2f0cb16d470a3ce21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c11d5ebf727c7d6562ce28782b506504/" rel="bookmark">
			01-Qt WebEngine模块开发环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Qt WebEngine Qt WebEngine_hitzsf的博客-CSDN博客
Qt WebEngine模块提供了一个Web浏览器引擎，可以轻松地将万维网上的内容嵌入到没有本机Web引擎的平台上的Qt应用程序中。Qt WebEngine提供了用于渲染HTML，XHTML和SVG文档的C ++类和QML类型，它们使用级联样式表（CSS）进行样式设置并使用JavaScript编写脚本。 用户可以通过使用HTML元素上的contenteditable属性，使HTML文档完全可编辑。
1、Qt WebEngine架构 Qt WebEngine中的功能分为以下模块：
Qt WebEngine Widgets，用于创建基于Widget的Web应用程序Qt WebEngine，用于创建基于Qt Quick的Web应用程序Qt WebEngine Core，用于与Chromium交互Qt WebEngine Process模块，页面渲染和JavaScript执行从GUI流程分离到Qt WebEngine Process中。 如果将Qt库捆绑到应用程序中，则该库必须随应用程序一起提供。 2、瑞芯微带Qt WebEngine的SDK编译 详见如下链接
有道云笔记
3、Qt WebEngine 类介绍 Qt QWebEngine 加载网页及交互，实现C++与JS 相互调用_qt5 加载网页-CSDN博客
Qt WebEngine（04）：QWebEngineView 类【官翻】-CSDN博客
4、官方demo程序 下面这两个是比较好的学习示例，simplebrowser是使用的QT Widget，quicknanobrowser是使用的 QT Quick
D:\QT5.12.10\install\Examples\Qt-5.12.10\webenginewidgets\simplebrowser
D:\QT5.12.10\install\Examples\Qt-5.12.10\webengine\quicknanobrowser
二、开发环境安装 QtWebengine模块作为Qt的子模块同样支持跨平台，可以安装在Windows、Linux、MacOS系统上，我这里安装在了windows和Ubuntu下。为了在RK3568平台上运行QT Web程序，所以还需要安装ARM64的交叉编译环境（只支持在Ubuntu下编译）
1、Windows桌面版本 在Windows上，Qt5.12.10版本中的Qt WebEngine仅在MSVC 2017或MSVC2019下可用，所以在按照QT之前，需要先安装VS2017。
注：我这里想选用的5.12.10版本，可以下载安装其他版本的也可以，比如5.12.2，在ubuntu下就是安装的这个版本
1、VS2017环境安装
Visual Studio 2017下载及安装_vs2017下载_枫蓝驿的博客-CSDN博客
2、QT Creator安装
QT下载链接：Index of /archive/qt/5.12/5.12.10
选择安装组件，需要勾选上MSVC2017 和 Qt WebEngine
2、Ubuntu桌面版本 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c11d5ebf727c7d6562ce28782b506504/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3173704a7150475eafefe128cbdd900/" rel="bookmark">
			Linux 文件的权限信息解读 chmod修改权限 数字序号表示权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ls -l #列出当前文件 显示详细信息 drwxr-xr-x. 2 dpc test 6 Jun 15 07:45 test.txt 共分为三部分
drwxr-xr-x.：表示文件和文件夹的权限信息dpc ：文件，文件夹所属的用户test ： 文件和文件夹所属的用户组 drwxr-xr-x 解读 d表示为文件夹
r w x 表示dpc的权限
r-x 所属用户组的权限
r-x 其他用户拥有的权限
chmod修改权限 只有文件或文件夹归属用户或root才可以操作权限
chmod [-R] 权限 文件或者文件夹 #-R 对文件夹农全部内容应用同样的操作 d rwx r-x r-x
权限分为3组，d表示文件或文件夹
chmod u=rwx,g=rx,o=x test.txt u (user)：修改所属用户权限g (group)：修改组权限o (other)：修改其他用户权限test.txt：修改的文件名字 数字权限 权限也可以使用数字来表示
chmod 7 5 1 #d rwx r-x r-x #对应 7表示用户 5表示组 1表示其他用户
0 ：没用任何权限 –1：x权限 --x2：w权限 -w-3：r权限 -wx4：r权限 r–5：r和x权限 r–6：r和w权限 rw-7：全部权限 rwx 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60ff71a4848fa2b5e370e77ae78f5008/" rel="bookmark">
			【AI学习】LLaMA 系列模型的进化（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一直对LLaMA 名下的各个模型关系搞不清楚，什么羊驼、考拉的，不知所以。幸好看到两篇综述，有个大致了解，以及SEBASTIAN RASCHKA对LLaMa 3的介绍。做一个记录。
一、文章《Large Language Models: A Survey》中对LLaMa的介绍 论文：Large Language Models: A Survey
https://arxiv.org/html/2402.06196v2
LLaMA家族 LLaMA 是 Meta 发布的基础语言模型集合。 与 GPT 模型不同，LLaMA 模型是开源的，即模型权重在非商业许可下发布给研究社区。 因此，LLaMA 系列迅速发展，因为这些模型被许多研究小组广泛使用，以开发更好的开源 LLM 以竞争闭源 LLM，或为关键任务应用程序开发特定任务的 LLM。
LLaMA的第一组模型于2023年2月发布，参数范围从7B到65B。这些模型是在公开可用数据集收集的数万亿个token上预训练的。LLaMA使用GPT-3的Transformer架构，但有一些小的架构修改，包括(1)使用SwiGLU激活函数代替ReLU，(2)使用旋转位置嵌入代替绝对位置嵌入，以及(3)使用均方根层归一化（root-mean-squared layer-normalization ）代替标准层归一化。
开源 LLaMA-13B 模型在大多数基准测试中优于专有的 GPT-3 （175B） 模型，使其成为 LLM 研究的良好基线。
2023年7月，Meta与Microsoft合作发布了LLaMA-2系列，其中包括基础语言模型和针对对话进行微调的Chat模型，称为LLaMA-2 Chat。LLaMA-2 Chat模型在许多公共基准测试中的表现超过了其他开源模型。图12展示了LLaMA-2 Chat的训练过程。该过程首先使用公开可用的在线数据预训练LLaMA-2。然后，通过监督微调构建LLaMA-2 Chat的初始版本。随后，模型使用RLHF、拒绝采样和近端策略优化（rejection
sampling and proximal policy optimization）进行迭代细化。在RLHF阶段，积累人类反馈以修订奖励模型至关重要，以防止奖励模型发生太大变化，这可能会损害LLaMA模型训练的稳定性。
Alpaca是从LLaMA-7B模型微调而来，使用了52K条遵循指令的示例，这些示例以自我指导(self-instruct)的方式使用GPT-3.5(text-davinci-003)生成。Alpaca在训练上非常划算，特别是对于学术研究。在自我指导评估集上，Alpaca的表现与GPT-3.5相似，尽管Alpaca要小得多。
Vicuna团队通过在ShareGPT上收集的用户共享对话对LLaMA进行微调，开发了一个13B的聊天模型，Vicuna-13B。使用GPT-4作为评估者进行初步评估表明，Vicuna-13B在超过90%的情况下实现了与OpenAI的ChatGPT和Google的Bard相似的质量，并且在超过90%的情况下优于其他模型，如LLaMA和Stanford Alpaca。图13通过GPT-4展示了Vicuna和其他一些知名模型的相对响应质量。Vicuna-13B的另一个优势是其相对有限的模型训练计算需求。Vicuna-13B的训练成本仅为300美元。
像Alpaca和Vicuna一样，Guanaco模型也是使用指令跟随数据对LLaMA进行微调的模型。但是，微调是通过QLoRA非常高效地完成的，以至于可以在单个48GB GPU上微调一个65B参数的模型。QLoRA通过冻结的4位量化预训练语言模型将梯度反向传播到低秩适配器(LoRA)中。最佳Guanaco模型在Vicuna基准测试上的表现超过了所有以前发布的模型，达到了ChatGPT性能水平的99.3%，同时仅需要在单个GPU上微调24小时。
Koala是另一个建立在LLaMA上的指令跟随语言模型，但专注于交互数据，包括用户输入和由高度能力的封闭源聊天模型（如ChatGPT）生成的响应。根据基于真实用户提示的人工评估，Koala-13B模型与最先进的聊天模型具有竞争力。
Mistral-7B是一个为卓越性能和效率而设计的7B参数语言模型。Mistral-7B在所有评估的基准测试中都优于最佳的开源13B模型(LLaMA-2-13B)，在推理、数学和代码生成方面优于最佳的开源34B模型(LLaMA-34B)。该模型利用分组查询注意力实现更快的推理，结合滑动窗口注意力以有效处理任意长度的序列，降低推理成本。
LLaMA家族正在迅速发展，因为更多的指令跟随模型已经建立在LLaMA或LLaMA-2之上，包括Code LLaMA、Gorilla、Giraffe、Vigogne、Tulu 65B、Long LLaMA和Stable Beluga2，仅举几例。
二、《大语言模型》中对LLaMa的介绍 来自《大语言模型》一书（赵鑫 李军毅 周昆 唐天一 文继荣 著），
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60ff71a4848fa2b5e370e77ae78f5008/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa5af2cd25cd23474b22e272ea8997bd/" rel="bookmark">
			系统编程:管道
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无名管道 pipe()创建管道,半双工,所以在使用时候close()另外一个;
适合在有血缘关系的进程中使用,如 父子进程;
1.简单应用:
fork()函数创建子进程
pipe()函数创建管道
read()和write()函数完成读写
#include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; int main() { int fd[2]; if(pipe(fd)==-1)return -1; //创建管道,返回-1表示失败 if(fork()==0){ //子进程,写入 close(fd[0]); while(1) { char buf[128]; ssize_t len=read(0,buf,128); //read默认会阻塞,等待输入 buf[len]=0; printf("子进程写入数据%s\n",buf); write(fd[1],buf,128); } _exit(0); } //父进程 close(fd[1]); for (int i = 0; i &lt; 3; i++) { char buf[128]; ssize_t len=read(fd[0],buf,128); buf[len]=0; printf("主进程收到的内容:%s\n",buf); } close(fd[0]); //关闭读后,子进程会 收到信号,会退出; printf("main over\n"); return 0; } 2.父子进程实现命令中管道的功能，如：ps -A | grep bash
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa5af2cd25cd23474b22e272ea8997bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0eead1974e33d4005a4ca16dc963cd60/" rel="bookmark">
			面向对象设计模式准则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，简介 罗伯特·C·马丁在 21 世纪早期引入了名为「SOLID」的设计原则，指代了面向对象编程和面向对象设计的五个基本原则（也有说六个的），即为 SOLIDD.
单一职责原则（Single Responsibility Principle）开放封闭原则（Open Closed Principle）里氏替换原则（Liskov Substitution Principle）接口隔离原则（Interface Segregation Principle）依赖反转原则（Dependency Inversion Principle）迪米特法则（最少知道原则）（Demeter Principle） 二，解释 1. 单一职责原则 一个类或者一个方法只负责一项职责，尽量做到类的只有一个行为原因引起变化。换句话说，一个类的职责和边界是及其集中且狭窄的，在类的职责上，无知是福，知道的越少越好。一个类应当做它该做的事，并且不应当被它的任何依赖的变化所影响。单一职责原则告诉我们实现类要职责单一。
2.开放封闭原则 类的对扩展是开开放的，对修改是封闭的。通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。
3.里氏替换原则 应用程序中任何父类对象出现的地方，我们都可以用其子类的对象来替换，并且可以保证原有程序的逻辑行为和正确性。不遵守里氏替换原则，那么开放封闭原则一定也会被打破。因为如果调用者必须检查实例属于哪个子类，则一旦有了新的子类，调用者就得做出改变。
4.接口隔离原则 接口中不应该存在子类用不到却必须要实现的方法，如果有，就要将接口拆分，使用多个隔离的接口。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。
5.依赖反转原则 面向接口编程，依赖于抽象而不依赖于具体。高层次的代码应该依赖抽象接口，抽象接口就像是「中间人」一样，负责连接着高层次和低层次代码。通俗点说，调用端不应该依赖具体的实现类，调用端和实现类都要依赖于抽象类。通过抽象类使各个实现类彼此独立，互不影响，实现模块间的松耦合。
6.迪米特法则 一个类对自己依赖的类知道的越少越好，也就是对于被依赖的类的方法和属性尽量私有化。高内聚，低耦合。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66b5769d8b7403017a79a5e9b975c43f/" rel="bookmark">
			【Linux内核】伙伴系统算法和slab分配器（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Linux内核】伙伴系统算法和slab分配器（1） 目录 【Linux内核】伙伴系统算法和slab分配器（1）伙伴系统（buddy）算法伙伴系统算法基本原理内存申请内存回收 接口函数源码分析内存分配接口物理内存释放接口规范物理内存分配行为的掩码 gfp_mask(了解即可) 作者：爱写代码的刚子
时间：2024.5.24
前言：本篇博客将会介绍Linux系统中伙伴系统算法
伙伴系统（buddy）算法 系统需要一种能够高效分配内存，同时又能减少产生碎片的算法——伙伴系统算法
大致结构：
node划分：
现代服务器上，内存和CPU都是所谓的NUMA架构（有多个CPU）
dmidecode命令可以查看主板上插着的CPU的详细信息 在NUMA架构中node：
numactl --hardware指令查看每个node情况 zone划分
每个zone又会划分成若干个的zone(区域)，zone表示内存中的一块范围。
ZONE_DMA：地址段最低的一块内存区域，供I/O设备DMA访问。ZONE_DMA32：用于支持32位地址总线的DMA设备，只在64位系统里才有效。ZONE_NORMAL：在X86-64架构下，DMA和DMA32之外的内存全部都在NORMAL的zone管理 其实还有一个ZONE_HIGHMEM,但是这是32位机时代的产物，现在用的不多
cat /proc/zoneinfo查看zone的划分 伙伴系统算法基本原理 伙伴系统算法把所有的空闲页框分为11个块链表，每块链表中分布包含特定的连续页框地址空间，例：第0个块链表包含大小为2^0个连续的页框（4kb）， 第1个块链表包含大小为2^1个连续的页框（8kb）
伙伴算法每次只能分配2的幂次页的空间，比如一次分配1页，2页，4页，8页，…，1024页(2^10)等等，每页大小一般为4K，因此，伙伴算法最多一次能够分配4M的内存空间。
伙伴算法在内核中通常用free_area结构体表示，free_list链表数组，nr_free就是当前链表中空闲页框块数量。例：free_area[2]中nr_free值为3，就是3个大小为4的页框块（16kb），总的空闲页就是3*4=12个（48kb）
#define MAX_ORDER 11 struct free_area {//链表 struct list_head free_list[MIGRATE_TYPES];//页属性 unsigned long nr_free;//空闲页框块数目 }; #define MAX_ORDER 11 struct zone{ struct free_area freearea[MAX_ORDER]; }; 内存申请 举例：需要分配16k的内存空间，算法会先从free_area[2]中查看nr_free是否为空，如果有空闲块，则从中分配，如果没有空闲块，就从它的上一级free_area[3]（每块32K）中分配出16K，并将多余的内存（16K）加入到free_area[2]中去。如果free_area[3]也没有空闲，则从更上一级申请空间，依次递推，直到free_area[max_order]，如果顶级都没有空间，那么就报告分配失败。
“伙伴关系”定义：
所谓“伙伴”，就是指在空闲块被分裂时，由同一个大块内存分裂出来的两个小块内存就互称“伙伴”。“伙伴”应当满足以下三个条件：
两个块大小相同两个块地址连续两个块必须是同一个大块中分离出来的 如何判断是同一块大块内存分配出来的？
具体的操作步骤如下：
确定块大小：假设块大小为 2^k。
检查地址对齐：分别计算内存块 A 和 B 的起始地址对 2^k的对齐情况。
计算父节点地址：
设两个内存块地址分别为 A 和 B，计算父节点地址。 父节点地址为 min(A,B)向下取整到2^(k+1) 的倍数。 验证共同父节点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66b5769d8b7403017a79a5e9b975c43f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faf89116afb3e532831e51953e498191/" rel="bookmark">
			【MySQL】聊聊数据库是如何保证数据不丢的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于一个存储系统来说，其中比较关键的核心组件包含，网络、存储模型、持久化、数据结构等。而数据如何保证不丢失，对于不同的存储系统来说，比如Redis采用AOF和RDB的方式进行混合使用，而MySQL采用日志进行保证。也就是redo\undo\bin log。本篇就聊聊数据库是如何进行不丢失的。
总体流程 对于数据不丢失，其实就是针对更新语句（update\delete\insert）的操作流程，其中主要靠redo log保证恢复事务，undo log 回滚事务。
bin log的写入机制 binlog在事务执行过程中，把日志写到binlog cache中，等事务提交的时候，再把binlog cache写到binlog中。而操作的维度就是一个事务。
系统给binlog cache分配了一片内存，每个线程一个。binlog_cache_size 控制单个线程内binlog cache所占内存的大小，超过之后，就暂存到磁盘中。
事务提交的时候，执行器把binlog cache里的完整事务写入到binlog中。并清空binlog cache
每个线程都有自己的binlog cache，但是对于bin log来说共用的。
write：把日志文件binlog cache写入到binlog files中，也就是paeg cache中，因为是内存操作，所以速度比较快。fsync: 将数据从page cache写入到本次磁盘中，这个比较费时，所以可能是影响IOPS的一个因素。 决定执行write和fsync由sync_binlog参数决定。
sync_binlog=0 每次提交事务只write，不fsyncsync_binlog=1 提交事务的时候都fsyncsync_binlog&gt;1 提交事务的只write ,但是积累到N个事务才fsync。其实就是批处理。 其实就是在性能和可用性之间进行权衡，在时机中，一般都是设置成100-1000中的某个值。但是当系统发生宕机的时候，可能丢失N个事务的binlog 日志。
redo log的写入机制 redo log是先写入redo log buffer-&gt; page cache -&gt; 磁盘
从而就对应三种写入状态
写入时机 存储在redo log buffer中，其实就是MySQL进程内存中。红色部分写到磁盘write，但是没有持久化(fsync) 文件系统的page cache里面，黄色部分持久化到磁盘里，就是hard disk，绿色部分。 InnoDB 提供了 innodb_flush_log_at_trx_commit 参数，控制写入策略。
0 ： 事务提交时，只把redo log留在redo log buffer中。1 ： 事务提交时，redo log 持久化到磁盘2 ： 事务提交时，redo log 写到page cache中。 如图5就是将定时将脏页进行刷新操作。而对于bin log来说，是依靠每次事务提交的时候进行刷盘。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/faf89116afb3e532831e51953e498191/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/064d6e746c06a11b6a93b7c1b2e4f8af/" rel="bookmark">
			Oracle的这些BUG你要遇到,说明你是一个DBA老鸟...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：IT邦德
中国DBA联盟(ACDU)成员，10余年DBA工作经验，
Oracle、PostgreSQL ACE
CSDN博客专家及B站知名UP主，全网粉丝10万+
擅长主流Oracle、MySQL、PG、高斯及Greenplum备份恢复，
安装迁移，性能优化、故障应急处理
文章目录 前言1 创建本地数据文件bug1.1 现象1.2 隐患1.3 解决办法 2.数据字典Bug2.1 现象2.2 隐患2.3 解决办法 3.OGG的bug3.1 现象3.2 解决办法 4.lag延迟4.1现象4.2 处理办法 5.总结 前言 本文总结了一些Oracle隐藏的很深的的BUG分享给大家,一起来探讨
1 创建本地数据文件bug 1.1 现象 RAC集群创建表空间的时候，由于数据文件路径写错
竟然自动创建到了本地$ORACLE_HOME/dbs目录下
既然RAC一直强调ASM共享的理念，
那么核心的表空间是共享的
为什么能自动创建到本地呢？
这样就会造成另外一个实例无法访问
而此时我们通过过实例1 查询dba_data_files正常
sql rac1&gt;select file_id,
tablespace_name,file_name,
status
from dba_data_files;
通过查询发现，新建的一个表空间建到了本地磁盘，
但是通过实例2去查询，发现错误，
select file_id,tablespace_name,
file_name,status
from dba_data_files;
ERROR at line 1:
ORA-01157: cannot identify/lock data file 34 - see DBWR trace file
ORA-01110: data file 34: '/u01/app/oracle/product/19.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/064d6e746c06a11b6a93b7c1b2e4f8af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f58726b21f9bd845b0997c4a9a4de8e6/" rel="bookmark">
			CVPR2024｜AIGC(图像生成，视频生成，3D生成等)相关论文汇总（附论文链接/开源代码/解析）【持续更新】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CVPR2024｜AIGC相关论文汇总（如果觉得有帮助，欢迎点赞和收藏） Awesome-CVPR2024-AIGC1.图像生成(Image Generation/Image Synthesis)Accelerating Diffusion Sampling with Optimized Time StepsAdversarial Text to Continuous Image GenerationAmodal Completion via Progressive Mixed Context DiffusionArbitrary-Scale Image Generation and Upsampling using Latent Diffusion Model and Implicit Neural DecoderAtlantis: Enabling Underwater Depth Estimation with Stable DiffusionAttention Calibration for Disentangled Text-to-Image PersonalizationAttention-Driven Training-Free Efficiency Enhancement of Diffusion ModelsCapHuman: Capture Your Moments in Parallel UniversesCHAIN: Enhancing Generalization in Data-Efficient GANs via lipsCHitz continuity constrAIned NormalizationCheck, Locate, Rectify: A Training-Free Layout Calibration System for Text-to-Image GenerationCoarse-to-Fine Latent Diffusion for Pose-Guided Person Image SynthesisCoDi: Conditional Diffusion Distillation for Higher-Fidelity and Faster Image GenerationCondition-Aware Neural Network for Controlled Image GenerationCosmicMan: A Text-to-Image Foundation Model for HumansCountering Personalized Text-to-Image Generation with Influence WatermarksCross Initialization for Face Personalization of Text-to-Image ModelsCustomization Assistant for Text-to-image GenerationDeepCache: Accelerating Diffusion Models for FreeDemoFusion: Democratising High-Resolution Image Generation With No $Desigen: A Pipeline for Controllable Design Template GenerationDiffAgent: Fast and Accurate Text-to-Image API Selection with Large Language ModelDiffusion-driven GAN Inversion for Multi-Modal Face Image GenerationDistriFusion: Distributed Parallel Inference for High-Resolution Diffusion ModelsDiversity-aware Channel Pruning for StyleGAN CompressionDiscriminative Probing and Tuning for Text-to-Image GenerationDon’t drop your samples!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f58726b21f9bd845b0997c4a9a4de8e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e960d07a5bfce020d7b0dce2f5db2ff5/" rel="bookmark">
			【C#】图形图像编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验目标和要求： 掌握C#图形绘制基本概念；掌握C#字体处理；能进行C#图形图像综合设计。 运行效果如下所示：
1.功能说明与核心代码 使用panel为画板，完成以下设计内容：
使用pen绘制基础图形；使用LinearGradientBrush实现渐变色字体；使用GraphicsPath实现艺术字，部分核心代码如下所示； GraphicsPath gp = new GraphicsPath(FillMode.Winding); gp.AddString( "字体轮廓",new FontFamily("方正舒体"),(int)FontStyle.Regular, 80,new PointF(10, 20),new StringFormat()); Brush brush = XXXXXXXXXXXXXXXXXXXXXX; XXX．DrawPath(Pens.Green, gp); XXX．FillPath(brush, gp); 实现： 1.在vs中开一个c#的窗体应用：
2 .在设计界面中拉取两个button，一个textbox（用于输出自己想输出的内容（艺术字））以及一个panel（输出在panel上显示）
3.代码
（1）button1：
private void button1_Click(object sender, EventArgs e) { drawBasicShapes = true; drawArtText = false; DrawBasicShapes(); panel1.Invalidate(); // 触发重绘 } （2）button2:
private void button2_Click(object sender, EventArgs e) { drawBasicShapes = false; drawArtText = true; DrawArtText(); panel1.Invalidate(); // 触发重绘 } (3)button1调用的函数DrawBasicShapes()：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e960d07a5bfce020d7b0dce2f5db2ff5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd15febffca5bc7ae75690ffa6723350/" rel="bookmark">
			贪心算法学习四
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例题一 解法（暴⼒解法 -&gt; 贪⼼）： 暴⼒解法： a. 依次枚举所有的起点； b. 从起点开始，模拟⼀遍加油的流程 贪⼼优化： 我们发现，当从 i 位置出发，⾛了 step 步之后，如果失败了。那么 [i, i + step] 这个区间内任意⼀个位置作为起点，都不可能环绕⼀圈。因此我们枚举的下⼀个起点，应该是 i + step + 1 。 例题二 解法（贪⼼）： 假设我们有⼀个数 n，它有m位数字，每⼀位数字分别是 d1,d2,......,dm 。 我们想要修改这个数字，使得修改后的结果既⼩于原数字 n ，⼜满⾜单调递增和最⼤化。为了实现这个⽬标，我们需要将不满⾜递增的⾼位数字尽可能地减⼩。 ⾸先，我们需要找到⼀个位置 k，使得 d 1 ≤ d 2 ≤...≤ d k &gt; d k +1...（例如：12335412，k=4，d k=5）。这个位置 k 表⽰从⾼到低，第⼀个不满⾜单调递增的数字的位置。我们需要将这个数字减1，因为这是最⼩的减⼩量。 接下来，我们需要将低位数字都修改为9，这样可以保证修改后的数字是最⼤的，并且还能保证单调递增。修改后存在以下两种情况： 1. 如果d k −1 &lt; dk ，则修改后的数字满⾜d 1 ≤ d 2 ≤ ... ≤ ( d k − 1) ≤ 9 ≤ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd15febffca5bc7ae75690ffa6723350/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07c0be7416eb411b32fe9075ae7e59dc/" rel="bookmark">
			如何通过抖音自动评论精准获客实现业务增长？这些方法值得一试！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今竞争激烈的商业环境中，企业若想脱颖而出，就必须掌握精准获客的艺术。精准获客，即通过精确的市场定位和营销策略，吸引并保留最有可能成为客户的目标群体。它不仅能提高转化率，还能有效降低营销成本，是推动业务增长的关键所在。以下是一些经过验证的方法，它们可以帮助企业实现精准获客，从而促进业务的稳健增长。
首先，了解目标客户是精准获客的基石。企业需要通过市场调研、数据分析等手段深入了解潜在客户的需求、偏好和行为模式。例如，一家专注于年轻人时尚穿搭的电商品牌，可以通过社交媒体分析工具追踪流行趋势，了解目标客户的穿搭喜好，从而推送个性化的搭配建议和产品。
其次，利用技术手段进行精准营销。随着大数据和人工智能技术的发展，企业可以利用这些技术对客户数据进行深度挖掘，实现精细化管理。比如，通过CRM系统对客户进行分层管理，根据不同层次的客户特征设计差异化的营销策略。同时，结合机器学习算法优化广告投放，确保广告内容能够触达最合适的用户群体。
再者，内容营销是精准获客的有效途径。高质量的内容能够吸引目标客户的注意，提升品牌形象，增强客户的信任感。例如，一家健康食品公司可以通过撰写关于营养健康的专业文章，或者制作健康食谱视频来吸引对健康生活感兴趣的消费者。
此外，社交媒体营销在精准获客中扮演着重要角色。企业可以通过社交平台与目标客户建立互动，通过定期发布有价值的内容，回应用户的评论和询问，逐步建立起品牌的忠实粉丝群。例如，一家旅游公司可以在Instagram上分享旅行照片和旅行小贴士，吸引热爱旅行的用户关注。
最后，口碑营销也是不可忽视的获客方式。满意的客户是最好的品牌代言人。企业可以通过提供优质的产品和服务，激励客户分享自己的正面体验。例如，提供推荐奖励计划，鼓励现有客户向朋友和家人推荐产品或服务。
综上所述，精准获客是一项系统工程，它需要企业从了解目标客户出发，运用技术手段进行精细化管理，同时通过内容营销、社交媒体营销和口碑营销等多种方式与客户建立深度联系。这些方法的实施并非一蹴而就，而是需要企业持续优化和创新。然而，一旦掌握了精准获客的策略，企业就能够以较低的成本获得更高的转化率，实现业务的可持续增长。在数字化时代，精准获客已经成为企业竞争的新高地，对于那些渴望在市场中占据一席之地的企业来说，这些方法绝对值得一试。
文章来源-赢销侠：https://www.yingxiaoxia.cn/gongnengjieshao/
点击下方 应用交流卡片，领取软件试用资格把↓↓↓↓↓
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82a370d48d52f6c986556822925721fd/" rel="bookmark">
			200. 岛屿数量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给你一个由 ‘1’（陆地）和 ‘0’（水）组成的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。
示例 1：
输入：
grid = [
[“1”,“1”,“1”,“1”,“0”],
[“1”,“1”,“0”,“1”,“0”],
[“1”,“1”,“0”,“0”,“0”],
[“0”,“0”,“0”,“0”,“0”]
]
输出：1
示例 2：
输入：
grid = [
[“1”,“1”,“0”,“0”,“0”],
[“1”,“1”,“0”,“0”,“0”],
[“0”,“0”,“1”,“0”,“0”],
[“0”,“0”,“0”,“1”,“1”]
]
输出：3
提示：
m == grid.lengthn == grid[i].length1 &lt;= m, n &lt;= 300grid[i][j] 的值为 ‘0’ 或 ‘1’ 方法：深度优先遍历（递归）
思路：
顺序遍历每一个网格，如果是0，跳过；如果是1，则为岛屿，岛屿总数+1。
考虑到陆地可能相连的情况，因此需要将相连接的陆地识别为一块岛屿。由于如果是陆地的话，我们的遍历的过程中即跳过。因此我们以当前遍历到的陆地为起点，递归遍历该陆地的上下左右（所有连在一起的节点），并将遍历到的陆地置为0。依次递归每一个网格遍历所有网格 代码
class Solution { public: int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) { int rows = grid.size(); int cols = grid[0].size(); int islandCount = 0; for(int i=0;i&lt;rows;i++){ for(int j=0;j&lt;cols;j++){ if(grid[i][j]=='1'){ ++islandCount; dfs(grid,i,j); } } } return islandCount; } private: void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int i,int j){ int rows = grid.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82a370d48d52f6c986556822925721fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15d4868f1ebdb82244529e1ed4cfcb7f/" rel="bookmark">
			Elasticsearch机器学习初探：智能数据洞察
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今数据驱动的时代，企业越来越依赖于数据来做出明智的决策。然而，随着数据量的不断增长和复杂性的增加，传统的数据分析方法已经无法满足快速、准确洞察数据的需求。为了应对这一挑战，Elasticsearch引入了机器学习功能，使得用户能够更智能地处理和分析数据。本文将带您初步探索Elasticsearch的机器学习功能，并了解它如何帮助我们实现智能数据洞察。
一、Elasticsearch与机器学习 Elasticsearch是一个基于Lucene的开源搜索引擎和分析引擎，它提供了全文搜索、结构化搜索、分析以及三者结合的能力。Elasticsearch不仅适用于文本搜索，还能用于分析大量数据。随着Elastic Stack（包括Elasticsearch、Logstash、Kibana和Beats）的不断发展，Elasticsearch已经扩展了其功能集，包括机器学习功能。
Elasticsearch的机器学习功能旨在为用户提供实时的、自动化的数据分析。它可以帮助用户发现数据中的模式、预测未来趋势、检测异常行为等。这些功能使得用户能够更快速地获取数据洞察，从而做出更明智的决策。
二、Elasticsearch机器学习功能概览 Elasticsearch提供了多种机器学习功能，以下是一些关键功能的概述：
1. 数据框架（Data Frames） 数据框架是Elasticsearch机器学习功能的核心组件，它允许用户定义和训练机器学习模型。通过数据框架，用户可以轻松地将数据转换为适合机器学习的格式，并选择适当的算法进行训练。
2. 预测（Forecasting） 预测是Elasticsearch机器学习功能的一个重要方面。它允许用户根据历史数据预测未来的趋势或行为。通过预测，用户可以提前了解业务的变化趋势，从而做出更准确的决策。
3. 异常检测（Outlier Detection） 异常检测是另一个重要的机器学习功能。它可以帮助用户发现数据中的异常值或模式，这些异常可能代表潜在的问题或机会。通过异常检测，用户可以更快速地发现潜在问题，并采取相应的措施。
4. 分类和聚类（Classification and Clustering） Elasticsearch还提供了分类和聚类功能。分类可以帮助用户将数据划分为不同的类别，而聚类则可以根据数据的相似性将数据分组。这些功能可以帮助用户更好地理解数据的结构和关系。
三、如何使用Elasticsearch机器学习功能 要使用Elasticsearch的机器学习功能，您需要遵循以下步骤：
1. 准备数据 首先，您需要准备用于机器学习训练的数据。这些数据应该包含您需要分析的特征和标签（如果有的话）。您可以使用Logstash或Beats将数据导入Elasticsearch中。
2. 创建数据框架 在Elasticsearch中创建一个数据框架，并指定要使用的数据和算法。您可以使用Kibana的机器学习应用程序来创建和管理数据框架。
3. 训练模型 使用数据框架中的数据训练机器学习模型。在训练过程中，您可以调整模型的参数以优化性能。
4. 评估模型 评估模型的性能，并查看其预测结果。您可以使用Kibana的机器学习应用程序来查看模型的评估结果和预测结果。
5. 部署模型 一旦您对模型的性能感到满意，就可以将其部署到生产环境中。在部署过程中，您需要将模型集成到您的应用程序中，并配置适当的参数和设置。
四、总结 Elasticsearch的机器学习功能为用户提供了强大的数据分析工具，可以帮助他们更智能地处理和分析数据。通过预测、异常检测、分类和聚类等功能，用户可以更快速地获取数据洞察，并做出更明智的决策。尽管Elasticsearch的机器学习功能仍处于不断发展的阶段，但它已经为用户带来了显著的收益。随着Elastic Stack的不断发展，我们期待看到更多强大的机器学习功能被引入到Elasticsearch中。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/263/">«</a>
	<span class="pagination__item pagination__item--current">264/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/265/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>