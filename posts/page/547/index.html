<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ec789f7a9216121cdec0d80425e496c/" rel="bookmark">
			前端从零搭建自己的脚手架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、什么是脚手架
二、项目的创建
1、包管理工具
2、初始化
3、构建项目的基本结构
4、引入react
5、引入typescript
6、webpack配置
7、文件别名
8、引入less、sass、stylus
三、webpack构建速度优化
1、webpack进度条
2、构建耗时
3、开启持久化存储缓存：
4、开启多线程loader
四、webpack构建产物优化
1、bundle体积分析工具
2、样式提取
3、tree-shaking清理未引用的js
4、tree-shaking清理未引用的css
5、资源懒加载
6、资源预加载
7、gzip压缩
总结：
一、什么是脚手架 Webpack脚手架是一个工具，用于快速搭建基于Webpack的项目结构。它通常包括了一些预设的配置和插件，以便用户可以快速开始一个新的项目，而不必从头开始配置Webpack。这些脚手架可以帮助开发人员自动处理诸如打包、代码转译、资源管理等繁琐的任务，从而让他们更专注于项目的逻辑实现。
二、项目的创建 1、包管理工具 npm（Node Package Manager）是 Node.js 的默认包管理器，可以用于安装、更新和删除 JavaScript 包。
yarn 是另一个流行的包管理器，由 Facebook 开发。它旨在解决 npm 的一些限制和一些性能安全问题，并且通常比 npm 更快速、稳定。
pnpm 是另一个包管理器，它通过重用文件系统硬链接以及共享依赖来显著减少磁盘空间占用。相比于传统的 npm 和 yarn，pnpm 在安装包时只保存一个拷贝，因此在大型项目中能够节省大量的磁盘空间。
此次项目中我们使用pnpm。
相关资料：pnpm基本使用
2、初始化 新建一个文件夹，然后在根目录打开终端并输入以下命令：
pnpm - v # 初始化 package . json 文件 pnpm init 初始化后会在根目录生成一个package.json 文件：
package.json文件在Webpack中扮演了重要的角色。它用于描述项目的依赖项信息和定义的依赖项，并且可以利用package.json中的脚本命令来执行构建任务。
3、构建项目的基本结构 ├── build | ├── webpack.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ec789f7a9216121cdec0d80425e496c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24a6a57548beb678b5ae880f67a9e78a/" rel="bookmark">
			OCR--基于Tesseract详细教程（python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.介绍
2. 准备工作
2.1 安装Tesseract
2.2 安装pytesseract
3. Tesseract的基础应用
3.1 翻译图像文字——image_to_string
3.2 获取单个字符的外框——image_to_boxes
3.3 输出区域、置信度 文字内容以及其他——image_to_data
3.4 设定配置实现过滤功能 3.4.1 OEM
3.4.2 PEM
3.4.3 示例：只检测数字
1.介绍 Tesseract 的开发始于 2006 年，由惠普公司的 Mike J. Bradbury 带领团队进行。当时，他们希望开发一款能够识别印刷体和手写体的 OCR（Optical Character Recognition，光学字符识别） 引擎。2009 年，Tesseract 被移植到 C++，并成为 Google 的开源项目。随着时间的推移，Tesseract 逐渐成为最受欢迎的 OCR 引擎之一，被广泛应用于各种场景。它可以将图像中的文字提取出来，并将其转化为机器可读的文本。Tesseract 不仅支持多种语言，还可以进行多种格式的图像处理，包括常见的 PDF、JPG、PNG 等。
2. 准备工作 2.1 安装Tesseract Tesseract下载地址为：
Tesseract User Manual | tessdocTesseract documentationhttps://tesseract-ocr.github.io/tessdoc/
↓↓↓ 按照如下步骤进行安装 勾选下面的选项下载一些语言包，可以翻译中文和一些其他语言 下载不成功的朋友可以点击下面的链接进行下载
https://github.com/tesseract-ocr/tessdatahttps://github.com/tesseract-ocr/tessdata
选择下载路径 点击Finish下载完毕 2.2 安装pytesseract 执行命令安装pytesseract库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24a6a57548beb678b5ae880f67a9e78a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce52eb55258ca31d93eda4126b1eb681/" rel="bookmark">
			大数据专业求职简历（11篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导语：如何在简历中脱颖而出，吸引招聘者的目光，可以参考我们整理的11篇大数据专业求职简历案例，帮助大家打造一份令人印象深刻的大数据专业求职简历。
圈个重点，幻主简历网：可下载大数据专业简历模板（支持线编辑制作）
大数据专业求职简历篇1：
求职意向
求职类型：全职&amp;nbsp;&amp;nbsp;&amp;nbsp;
意向岗位：大数据开发&amp;nbsp;&amp;nbsp;&amp;nbsp;
意向城市：广东广州&amp;nbsp;&amp;nbsp;&amp;nbsp;
薪资要求：面议&amp;nbsp;&amp;nbsp;&amp;nbsp;
求职状态：随时到岗&amp;nbsp;&amp;nbsp;&amp;nbsp;
教育背景
时间：20xx.9-20xx.6&amp;nbsp;&amp;nbsp;&amp;nbsp;学校名称：幻主简历大学1&amp;nbsp;&amp;nbsp;&amp;nbsp;专业名称：网络工程&amp;nbsp;&amp;nbsp;&amp;nbsp;学校描述：1. 专业主修计算机网络、软件编程、期间学习操作系统，计算机网络原 理、计算机组成原理时间：20xx.1-20xx.6&amp;nbsp;&amp;nbsp;&amp;nbsp;学校名称：幻主简历大学2&amp;nbsp;&amp;nbsp;&amp;nbsp;专业名称：大数据&amp;nbsp;&amp;nbsp;&amp;nbsp;学校描述：1. 对Hadoop的大数据体系有深入认识
工作经历
时间：20xx.6-20xx.6&amp;nbsp;&amp;nbsp;&amp;nbsp;公司名称：幻主简历公司1&amp;nbsp;&amp;nbsp;&amp;nbsp;职位名称：数据处理、可视化&amp;nbsp;&amp;nbsp;&amp;nbsp;时间：20xx.3-20xx.5&amp;nbsp;&amp;nbsp;&amp;nbsp;公司名称：幻主简历公司2&amp;nbsp;&amp;nbsp;&amp;nbsp;职位名称：后台数据处理，web前端展现&amp;nbsp;&amp;nbsp;&amp;nbsp;1.基于大数据实现电影推荐，将在豆瓣上爬取的电影数据时间：20xx.5-20xx.9&amp;nbsp;&amp;nbsp;&amp;nbsp;公司名称：幻主简历公司3&amp;nbsp;&amp;nbsp;&amp;nbsp;职位名称：在MOOC网提取学习者的相关数据&amp;nbsp;&amp;nbsp;&amp;nbsp;1.由于项目需要自学Python做爬虫,在MOOC网上按照项目 需求爬取学生的学习课程、课程评分，学生评论。
自我评价
坚持自己的IT梦想，热爱IT行业；快速学习，自主学习能力，责任感强， 坚持守时原则，做事富有激情，不失耐心细致。 在生活上积极乐观，充满活力；在工作上，上进心强、认真投入、严肃、 灵活，善于交流，有很好的团队精神 籍
个人技能
1.计算机网络：路由交换2.JavaEE：熟练常用的 ssm 架构、、aop 编程，springMVC 开发，熟练 eclipse,idea开发工具3.大数据：hadoop生态系统，HDFS数据的存储和读取，spark数据处理， flume、hive数据仓库、 &amp;nbsp; zookeeper搭建hadoopHA4. Linux：熟练linux操作，shell编程，熟悉Redhat的centOS系统5. Mysql：数据库的事务特性、数据的操作、备份，数据的 DDL,DML,DCL 操作。
在校荣誉
1.国家英语四级证书 2.优秀学生干部 3.道德风尚奖学金 4.慧与“互联网、大数据”比赛第一名
大数据专业求职简历篇2：
求职意向
求职类型：全职&amp;nbsp;&amp;nbsp;&amp;nbsp;
意向岗位：大数据开发，java后端开发&amp;nbsp;&amp;nbsp;&amp;nbsp;
意向城市：广东广州&amp;nbsp;&amp;nbsp;&amp;nbsp;
薪资要求：面议&amp;nbsp;&amp;nbsp;&amp;nbsp;
求职状态：随时到岗&amp;nbsp;&amp;nbsp;&amp;nbsp;
教育背景
时间：20xx.9-20xx.6&amp;nbsp;&amp;nbsp;&amp;nbsp;学校名称：幻主简历大学1&amp;nbsp;&amp;nbsp;&amp;nbsp;专业名称：医学信息工程&amp;nbsp;&amp;nbsp;&amp;nbsp;
工作经历
时间：20xx.8-至今&amp;nbsp;&amp;nbsp;&amp;nbsp;公司名称：幻主简历公司1&amp;nbsp;&amp;nbsp;&amp;nbsp;职位名称：java、大数据开发&amp;nbsp;&amp;nbsp;&amp;nbsp;在审计团队工作，工作中主要做java web接口开发和大数据预研及开发，从头参与并完成了日志审计系统的搭建及开发；日志审计系统主要用到的后端框架及技术主要有：SpringDataJPA、Hadoop、Kafa、Flume、Presto、Hive、Flink、ES等；我在团队中主要负责Cloudera版本的Hadoop环境搭建，使用flume+kafka接收日志，对日志进行清洗、格式化，将格式化后的日志存入hive；使用presto跨数据库查询统计，生成报表数据；报表查询接口的开发等，在项目完成后还参与了项目部署工作。
项目经验
时间：20xx.5-20xx.8&amp;nbsp;&amp;nbsp;&amp;nbsp;项目名称：幻主简历项目1&amp;nbsp;&amp;nbsp;&amp;nbsp;项目角色：java后端开发&amp;nbsp;&amp;nbsp;&amp;nbsp;项目描述： 该系统是用于配置企业员工部门等信息的项目，用户可以通过此系统配置出一套企业管理系统。项目中使用到的技术框架有：Spring Boot，Spring Data JPA，Mybatis。时间：20xx.8-至今&amp;nbsp;&amp;nbsp;&amp;nbsp;项目名称：幻主简历项目2&amp;nbsp;&amp;nbsp;&amp;nbsp;项目角色：大数据开发&amp;nbsp;&amp;nbsp;&amp;nbsp;项目描述：使用Flume统一接收公司各个部门的日志，输出到 kafka中，在 kafka中对日志进行清洗，将清洗后的数据分两个方向，一是存储到 hive中，供报表服务使用，二是存储到Elasticsearch中，供日志查看功能使用。在入库的同时监控日志内容，通过内容的变更实现预警管理；使用 presto对 hive和 mysql中的数据进行联合计算，生成报表数据，存入 hive中，同时提供报表服务的查询接口。后续版本去除hive部分，报表相关的计算直接使用Flink SQL流处理系统进行计算，框架更加简单，数据处理的实时性也有明显的提高。
自我评价
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce52eb55258ca31d93eda4126b1eb681/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51cb3ee02172ebfe2b916389a5881067/" rel="bookmark">
			C&#43;&#43; Qt开发：Charts折线图绘制详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt 是一个跨平台C++图形界面开发库，利用Qt可以快速开发跨平台窗体应用程序，在Qt中我们可以通过拖拽的方式将不同组件放到指定的位置，实现图形化开发极大的方便了开发效率，本章将重点介绍QCharts折线图的常用方法及灵活运用。
折线图（Line Chart）是一种常用的数据可视化图表，用于展示随着时间、类别或其他有序变量而变化的趋势。折线图通过将数据点连接起来形成折线，直观地展示了变量之间的趋势和关系。
折线图通常用于以下环境：
时间序列数据： 显示随时间变化的数据趋势，例如股票价格、气温变化等。比较趋势： 可以比较不同组之间的趋势，例如不同产品的销售趋势。展示模式或关联关系： 用于显示变量之间的相关性或模式，例如销售额和广告投入之间的关系。 折线图的基本结构包括：
横轴（X轴）： 通常表示时间或类别。纵轴（Y轴）： 表示变量的值。可以是数值，也可以是百分比或其他度量。数据点： 在图表上表示具体的数据值的点。折线： 将数据点连接起来的线，形成变化趋势。 在Qt中，可以使用图表库来创建折线图。通过在程序中添加相应的数据点，并设置合适的轴和样式，你可以轻松创建出漂亮且具有信息表达能力的折线图。
在之前的文章中笔者简单创建了一个折线图，由于之前的文章只是一个概述其目的是用于让读者理解绘图组件是如何被引用到项目中的，以及如何实际使用，本章我们将具体分析折线图的绘制功能，详细介绍图表各个部分的设置和操作，包括图标的标题、图例、边距等属性的设置，QLineSeries序列的属性设置，QValueAxis坐标轴的属性设置等，通过本章的学习读者可以掌握QChart绘图的核心方法。
1.1 图表设置 1.1.1 设置标题 首先我们来实现对图表的设置，通常情况下图表中的标题可以通过setTitle来设置，而通过setTitleFont可以设置标题字体，通常设置字体需要使用QFont类，以下是 QFont 类中常用的方法的说明和概述：
方法描述QFont()默认构造函数，创建一个默认字体。QFont(const QString &amp;family, int pointSize = -1, int weight = -1, bool italic = false)带参数的构造函数，创建一个具有指定族、大小、粗细和斜体属性的字体。QString family() const返回字体的族（family）。void setFamily(const QString &amp;family)设置字体的族。int pointSize() const返回字体的大小（以点为单位）。void setPointSize(int pointSize)设置字体的大小。int weight() const返回字体的粗细。void setWeight(int weight)设置字体的粗细。bool italic() const返回字体是否为斜体。void setItalic(bool italic)设置字体是否为斜体。QString styleName() const返回字体的样式名称。void setStyleName(const QString &amp;styleName)设置字体的样式名称。bool bold() const返回字体是否为粗体。void setBold(bool enable)设置字体是否为粗体。bool exactMatch() const检查字体是否与指定的字体精确匹配。QFontMetrics metrics() const返回字体的度量信息，如字符高度、宽度等。bool operator==(const QFont &amp;other) const比较两个字体是否相等。bool operator!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51cb3ee02172ebfe2b916389a5881067/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e426fd0589bc66f1da6327e4e7c1cc5/" rel="bookmark">
			vue前端上传图片到阿里云OSS，超详细上传图片与视频教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue前端直传图片与视频到阿里云OSS 1. 简介与日常使用2. 为什么要这么干？是因为我司后端不行吗？？？（确实！）3. vue前端直传的操作4. 如何上传到阿里OSS指定文件夹呢? 1. 简介与日常使用 阿里云OSS是一款由阿里巴巴云计算有限公司开发的基于云端的对象存储服务。它为企业和个人存储海量数据提供了完美的解决方案。简单来说就是一台服务器，可以把静态资源放进去存储，比如图片，视频，各种库，然后会给你一个链接，访问数据。日常使用的话，一般用这个工具，很方便，要存什么东西，直接拖进去就行。选择对应资源，右键便可以看到信息 =&gt; 链接啥的，详细信息。
2. 为什么要这么干？是因为我司后端不行吗？？？（确实！） 这种场景是提供给用户使用的，他们在各种系统里面，点击上传图片的操作，我们需要让文件直接传入阿里oss服务器。总不能给每个用户都提供一个OSS工具吧，怕麻烦，也怕骂娘。其实后端也能做，文件通过接口传入后端，他们来操作，那只怕是展示不了咱们前端的牛逼了！再说一句：咱前端天下第一！！！
3. vue前端直传的操作 安装依赖 —— npm方式 npm install ali-oss 或者 —— yarn方式 yarn add ali-oss 如果很多地方都会用到，那么你可以封装到全局中去，比如这样：
const OSS = require('ali-oss'); const client = new OSS({ // yourregion填写Bucket所在地域。以华东1（杭州）为例，Region填写为oss-cn-hangzhou。 region: 'yourregion', // 从环境变量中获取访问凭证 // 当然，以下两个也可以直接写死 accessKeyId: process.env.OSS_ACCESS_KEY_ID, accessKeySecret: process.env.OSS_ACCESS_KEY_SECRET, // 填写Bucket名称。 bucket: 'examplebucket' }); 常用的就这么四个参数，如果你要更多，可以看文档
上面的参数如果不知道，问运维或者后端就行，一般是他们去处理，咱不干这破事。
接下来就是哪里用到，哪里引入就行。你的文件路径肯定跟我的不一样，别乱来啊，兄弟！
import { client } from "@/utils/alioss.js"; template 部分，这里没啥特别，用element ui的就行 &lt;el-upload class="avatar-uploader" :on-preview="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e426fd0589bc66f1da6327e4e7c1cc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36e34eac84ecdff76061928a0431696b/" rel="bookmark">
			高级数据结构 ＜二叉搜索树＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文已收录至《数据结构(C/C++语言)》专栏！
作者：ARMCSKGT 目录 前言正文二叉搜索树的概念二叉搜索树的基本功能实现二叉搜索树的基本框架插入节点删除节点查找函数中序遍历函数析构函数和销毁函数(后序遍历销毁)拷贝构造和赋值重载(前序遍历创建)其他函数 二叉搜索树的应用场景key模型key-value模型 关于二叉搜索树 最后 前言 前面我们学习了二叉树，但仅仅只是简单的二叉树并没有很大的用处，而本节的二叉搜索树是对二叉树的升级，其查找效率相对于简单二叉树来说有一定提升，二叉搜索树是学习AVL树和红黑树的基础，所以我们必须先了解二叉搜索树。
正文 二叉搜索树的概念 二叉搜索树（Binary search tree）也称二叉排序树或二叉查找树，是在普通二叉树基础上的升级版本，普通二叉树的利用价值不大，而二叉搜索树要求 左节点比根小，右节点比根大，二叉搜索树将数据按二分性质插入在树中，所以将数据存入 二叉搜索树 中进行查找时，理想情况下只需要花费 logN 的时间（二分思想），此时使用中序遍历可以得到一列有序序列，因此 二叉搜索树 的查找效率极高，具有一定的实际价值。
二叉搜索树名字的由来就是因为搜索（查找）速度很快！
二叉搜索树基本特点
一棵二叉树，可以为空；如果不为空则：
如果左子树存在，则左子树根节点一定比根节点值要小如果右子树存在，则右子树根节点一定比根节点值要大左子树中的所有节点比根节点小，右子树中的所有节点比根节点大所有的节点值都不相同，不会出现重复值的节点所有子树都遵循这些性质 在这种性质下，使用中序遍历可以得到升序序列，如果将性质反转，即左比根大右比根小，则中序遍历可得到降序序列。
如上图的中树，中序遍历序列为：1 3 4 6 7 8 10 13 14
二叉搜索树的基本功能实现 二叉搜索树的基本框架 二叉搜索树的节点同样需要单独使用模板封装，且因为会用到比较函数，所以需要一个模板参数充当比较函数。
//节点类 template&lt;class T&gt; struct TreeNode { T _key; TreeNode&lt;T&gt;* _left; TreeNode&lt;T&gt;* _right; TreeNode() :_key(T()) , _left(nullptr) , _right(nullptr) {} TreeNode(const T&amp; key) :_key(key) , _left(nullptr) , _right(nullptr) {} }; //默认比较函数 template&lt;class T&gt; struct Compare { bool operator()(const T&amp; left, const T&amp; right) { return left &gt; right; } }; //二叉搜索树 template&lt;class T, class Com = Compare&lt;T&gt;&gt; class BSTree { //对节点类型 和 树类型 的重命名 方便使用 using NodeType = TreeNode&lt;T&gt;; //相对于 typedef TreeNode&lt;T&gt; NodeType; using TreeType = BSTree&lt;T, Com&gt;; public: BSTree() :_root(nullptr) , _size(0) {} private: NodeType* _root; //根节点 size_t _size; //节点数量 Com _com; //比较函数 }; 插入节点 对于插入函数，我们的目标是要找到合适的插入位置！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36e34eac84ecdff76061928a0431696b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ed1c69fbfbf71b9ca01d81033e7be43/" rel="bookmark">
			Oracle中decode函数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle中decode函数详解 大家好，我是免费搭建查券返利机器人赚佣金就用微赚淘客系统3.0的小编，也是冬天不穿秋裤，天冷也要风度的程序猿！在数据库的世界里，我们经常需要处理各种复杂的查询和条件判断。今天，让我们深入探讨Oracle数据库中的DECODE函数，解析其强大的条件判断和数据转换能力，为你打开更多数据库查询的可能性。
1. 什么是DECODE函数？ DECODE函数是Oracle数据库中的一种条件判断函数，它提供了一种简洁而强大的方式来实现基于条件的数据转换。通过DECODE函数，我们可以根据指定的条件进行值的比较，然后返回符合条件的结果值。
2. DECODE函数的基本语法 DECODE函数的基本语法如下：
DECODE(expr, search1, result1, search2, result2, ..., default) 其中：
expr：需要进行比较的表达式。search1, search2, ...：一系列要比较的值。result1, result2, ...：与每个搜索值相对应的结果值。default：可选，如果没有匹配到任何搜索值，则返回的默认结果值。 3. DECODE函数的应用示例 3.1 基本条件判断 SELECT DECODE(grade, 'A', 'Excellent', 'B', 'Good', 'C', 'Average', 'Fail') AS result FROM student; 在上述示例中，根据学生的成绩等级，DECODE函数将其转换为相应的评价，如果没有匹配到任何条件，则返回默认值。
3.2 数值范围判断 SELECT DECODE(SIGN(score - 90), 1, 'A', 0, 'B', -1, 'C') AS result FROM exam_results; 通过比较分数与90的大小关系，DECODE函数将其转换为相应的等级。
3.3 多条件判断 SELECT DECODE(subject, 'Math', score * 1.5, 'English', score * 1.2, score) AS weighted_score FROM exam_results; 在此示例中，DECODE函数根据科目的不同，给分数进行了不同的加权，以得到加权后的分数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ed1c69fbfbf71b9ca01d81033e7be43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d0a92c653d2237abb18f841187c3ee7/" rel="bookmark">
			IDEA连接HBase集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#环境介绍# 本地电脑window10
IntelliJ IDEA Community Edition 2023.2.3
虚拟机集群Hadoop3.1.4：master/slave1/slave2/slave3
HBase2.2.2
一、在IDEA中创建工程
file-&gt;new-&gt;New Project 设置项目名和存储路径，选择Archetype
2.选择项目，创建目录结构。
项目名右击-&gt;new-&gt;directory(下图的前两个)
得到如下目录结构：
将core-site.xml和hbase-site.xml放入resources目录下
core-site.xml在虚拟机master节点下的/usr/local/hadoop-3.1.4/etc/hadoop/
hbase-site.xml在虚拟机master节点下的/opt/hbase-2.2.2/conf/
在项目中导入jar包（hadoop解压后的jar包和hbase解压后的jar包）
先将hadoop和hbase的压缩包解压到本地
file-&gt;project structure-&gt;libraries-&gt; “+”
导入hadoop解压后（C:\hadoop-3.1.4\share\hadoop\client）路径下所有包
hbase解压后（C:\hbase-2.2.2\lib）路径下所有包
hbase解压后（C:\hbase-2.2.2\lib\client-facing-thirdparty）路径下所有包
导完之后的效果：
二、配置Windows系统环境变量
我的电脑右击属性-&gt;高级系统设置-&gt;环境变量
在系统变量中新建，添加HADOOP_HOME的变量名和对应的路径
在系统变量的Path变量中添加HADOOP_HOME变量
三、配置Windows系统hosts文件
查看虚拟机中/etc/hosts文件 将ip与主机名映射复制，粘贴到windows系统的hosts文件中，hosts文件路径为（C:\Windows\System32\drivers\etc），用记事本打开。
四、hadoop.dll文件导入
将hadoop.dll文件放入C:\Windows\System32\路径下。
五、启动HBase集群
master节点start-dfs.sh 和start-yarn.sh
slave1、slave2和slave3依次启动zookeeper：zkServer.sh start
master节点start-hbase.sh
master节点hbase shell进行hbase，输入list_namespace测试 六、在IDEA中编写程序，测试连接
在src\main\java下创建com.zx.hbase包，在包下创建HBaseTest文件。
将以下代码放入其中 package com.zx.hbase; import org.apache.hadoop.conf.Configuration; import org.apache.hadoop.hbase.*; import org.apache.hadoop.hbase.client.*; import org.apache.hadoop.hbase.util.Bytes; import java.io.IOException; public class HBaseTest { public static Configuration configuration; //管理HBase的配置信息 public static Connection connection; //管理HBase的连接 public static Admin admin; //管理HBase数据库表信息 public static void main(String[] args)throws IOException{ init(); createTable("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d0a92c653d2237abb18f841187c3ee7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59df86eb2c9765a79ff1a8c779db6c8c/" rel="bookmark">
			【MATLAB】史上最全的13种数据拟合算法全家桶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有意向获取代码，请转文末观看代码获取方式~
1 【MATLAB】傅里叶级数拟合算法 傅里叶级数拟合算法是一种强大而灵活的数学方法，可以将复杂的函数拆解成多个简单的正弦和余弦函数的和。通过求解函数中的系数，我们可以用有限项傅里叶级数来拟合函数，从而实现信号处理、图像处理和系统辨识等应用。
傅里叶级数的复数表达形式为：f(t)=∑a_ke^(jkwt)，其中w=2π/T，a_k = (1/T)∫f(t)e^(-jkwt)dt。这个公式表明，一个周期函数可以被表示为一组正弦和余弦函数的和，每个函数都有一个特定的频率和幅度。通过计算这些系数，我们可以用有限项傅里叶级数来逼近原函数。
在拟合过程中，需要注意封闭图形的条件。如果给出离散的数据点，傅里叶级数会将其自动首尾闭合。离散点必须是有序的xy坐标对，x对应复数z的实部，y对应复数z的虚部。用t表达成z的函数，就是傅里叶级数的复指数形式。
总的来说，傅里叶级数拟合算法的本质是基于初始点（也就是离散图像坐标的重心），对多个旋转向量进行矢量求和，向量和的末端轨迹即为傅里叶级数拟合的轨迹。这个算法在理论上具有重要意义，而且在实际应用中也具有广泛的价值。
拟合算法示意图
2【MATLAB】sin和函数拟合算法 sin和函数拟合算法是一种基于正弦函数的拟合方法，可以用来逼近一组离散数据或连续函数。该算法的基本思想是利用正弦函数的特性，通过调整正弦函数的振幅、频率和相位等参数，使得拟合函数与原始数据的误差最小。
sin和函数拟合算法通常采用最小二乘法来估计参数，即通过最小化拟合函数与原始数据之间的平方误差和来求解最优参数。具体实现步骤如下：
确定sin函数的形式，即y=Asin(ωx+φ)+B，其中A是振幅，ω是角频率，φ是相位差，B是y轴偏移量。
利用最小二乘法来确定参数A、ω、φ和B的值，使得拟合函数与原始数据的平方误差和最小。
使用拟合得到的sin函数来预测未知数据点的值。
需要注意的是，sin和函数拟合算法只适用于具有周期性或近似周期性的数据，对于非周期性的数据可能会出现较大的拟合误差。此外，对于具有多个频率成分的数据，可能需要使用多个sin函数进行拟合。
拟合算法示意图
3【MATLAB】高阶多项式拟合算法 高阶多项式拟合算法是一种通过多项式函数来逼近数据点的方法，使得拟合函数与实际数据点的误差最小化。其基本思想是通过不断增加多项式的阶数，来提高对数据的拟合精度。
高阶多项式拟合的一般形式为：y = a0 + a1x + a2x^2 + … + anxn，其中y表示因变量，x表示自变量，a0、a1、a2、…、an表示多项式系数，n表示多项式的阶数。通过最小二乘法等数学统计方法，可以求解出多项式系数的最优值，从而得到一个最优的拟合函数。
需要注意的是，高阶多项式拟合容易出现过拟合的问题，即拟合函数过于复杂，对噪声数据过于敏感，导致拟合效果不佳。为了避免过拟合的问题，可以采用正则化方法对高阶多项式拟合进行优化。常见的正则化方法包括L1正则化和L2正则化。
在实际应用中，需要根据数据的复杂程度来选择合适的多项式阶数。如果数据比较简单，可以选择低阶多项式进行拟合；如果数据比较复杂，需要选择高阶多项式进行拟合。同时，也需要对拟合结果进行评估和检验，以确保拟合函数的有效性和可靠性。
拟合算法示意图
4【MATLAB】smooth平滑拟合算法 Smooth平滑拟合算法是一种常用的数据平滑方法，可以用来减少数据中的噪声和异常值，提高数据的可靠性和稳定性。其基本思想是通过计算数据点的局部平均值来平滑数据，使得每个数据点都被替换为其邻近数据点的加权平均值。
Smooth平滑拟合算法的实现方式有多种，其中最常用的是移动平均滤波器和拉普拉斯平滑。
移动平均滤波器是一种简单的平滑方法，其基本原理是在一个滑动窗口内计算数据点的平均值，并用该平均值替换窗口中心点的值。移动平均滤波器的平滑效果取决于窗口的大小和形状，可以通过调整窗口参数来控制平滑的程度。
拉普拉斯平滑是一种基于概率模型的平滑方法，其基本原理是假设数据点之间的变化是平滑的，并用一个概率模型来描述这种变化。拉普拉斯平滑通过计算每个数据点的概率分布，并用其邻近数据点的概率分布来平滑数据。拉普拉斯平滑的效果取决于概率模型的选择和参数的设置。
需要注意的是，Smooth平滑拟合算法虽然可以减少噪声和异常值的影响，但也可能会丢失数据的一些细节信息。因此，在选择平滑方法时需要权衡平滑程度和细节保留之间的平衡。同时，也需要对平滑后的数据进行评估和检验，以确保平滑算法的有效性和可靠性。
拟合算法示意图
5【MATLAB】部分空间约束的最小二乘学习法拟合算法 部分空间约束的最小二乘学习法是一种通过限制参数空间范围来防止过拟合现象的算法。该算法的基本思想是在最小二乘法的基础上，对参数附加一个约束条件，使得参数只能在设定的值域内变化。这样做可以减少参数的自由度，降低模型的复杂度，从而避免过拟合问题。
部分空间约束的最小二乘学习法的具体实现步骤如下：
设定参数的值域范围，即确定约束条件。
在最小二乘法的基础上，添加约束条件，构造带约束的优化问题。
使用优化算法求解带约束的优化问题，得到最优解。
用最优解来预测未知数据点的值。
需要注意的是，部分空间约束的最小二乘学习法的约束条件需要根据具体情况进行调整，不同的约束条件会对拟合结果产生不同的影响。同时，该算法的效果也取决于优化算法的选择和参数的设置。在实际应用中，需要根据具体情况进行选择和调整，以确保算法的有效性和可靠性。
拟合算法示意图
6【MATLAB】高斯核模型L2约束的最小二乘学习法拟合算法 高斯核模型 L2 约束的最小二乘学习法是一种基于核函数和L2约束的最小二乘法拟合算法。该算法的基本思想是通过引入高斯核函数来将原始数据映射到高维特征空间，然后在该特征空间中使用L2约束的最小二乘法进行拟合。
具体实现步骤如下：
引入高斯核函数K(x, y) = exp(-‖x-y‖^2/2σ^2)，其中x和y表示原始数据点，σ是高斯核函数的宽度参数。
通过高斯核函数将原始数据映射到高维特征空间，得到新的数据表示。
在特征空间中使用L2约束的最小二乘法进行拟合，即求解如下优化问题：min‖w‖^2 + C∑(yi - w^Tφ(xi))^2，其中w是拟合参数，φ(x)表示将x映射到特征空间的函数，C是正则化参数。
使用求解得到的拟合参数w来预测未知数据点的值。
需要注意的是，高斯核模型 L2 约束的最小二乘学习法的性能取决于高斯核函数的参数设置和正则化参数的选择。同时，该算法也需要选择合适的特征空间映射函数φ(x)，这需要根据具体情况进行调整。在实际应用中，需要根据具体情况进行选择和调整，以确保算法的有效性和可靠性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59df86eb2c9765a79ff1a8c779db6c8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8aa786e72587c502eb81364b79bf23bc/" rel="bookmark">
			【MATLAB】史上最全的25种信号分解算法全家桶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有意向获取代码，请转文末观看代码获取方式~
1 【MATLAB】EMD 信号分解算法 EMD 是一种信号分解方法，它将一个信号分解成有限个本质模态函数 (EMD) 的和，每个 EMD 都是具有局部特征的振动模式。EMD 分解的主要步骤如下：
将信号的局部极大值和极小值连接起来，形成一些局部极值包络线。
对于每个局部极值包络线，通过线性插值得到一条平滑的包络线。然后将原信号减去该包络线，得到一条局部振荡的残差信号。
对于该残差信号，重复步骤1和2，直到无法再分解出新的局部振荡模式为止。
将所有的局部振荡模式相加，得到原始信号的EMD分解。 EMD分解的优点是能够很好地处理非线性和非平稳信号，并且不需要预先设定基函数。因此，EMD分解在信号处理、图像处理和模式识别等领域得到了广泛的应用。
原始数据分解各分量示意图
2【MATLAB】EEMD信号分解算法 EEMD是对EMD的改进，可以克服EMD的一些缺点。EEMD的主要思想是通过对原始数据集进行多次噪声扰动，获得多个EMD分解的集合，然后将这些EMD集合求平均，得到最终的EEMD分解结果。EEMD的主要步骤如下：
对原始信号进行若干次随机噪声扰动，得到多个噪声扰动数据集。
对每个噪声扰动数据集进行EMD分解，得到多个EMD分解集合。
将每个 EMD 分解集合的对应分量进行平均，得到最终的 EEMD 分解结果。 EEMD 分解的优点是能够克服 EMD 的局限性，如基函数的选择和模态重叠等问题。同时，EEMD 还可以提供更好的信噪比和更高的分解精度。因此，EEMD 在信号处理、图像处理和模式识别等领域也得到了广泛的应用。
原始数据分解各分量示意图
原始数据分解各分量的箱型图
3【MATLAB】CEEMD信号分解算法 CEEMD是对EEMD的改进，它在EEMD的基础上引入了一个自适应的扩展方法，可以更好地解决EMD/EEMD中存在的模态混叠问题。CEEMD的主要步骤如下：
对原始信号进行若干次随机噪声扰动，得到多个噪声扰动数据集。
对每个噪声扰动数据集进行EMD分解，得到多个EMD分解集合。
对于每个EMD分解集合，通过一个自适应的扩展方法，将每个局部模态函数分配到它所属的固有模态函数上，消除模态混叠的影响。
将每个扩展后的 EMD 分解集合的对应分量进行平均，得到最终的 CEEMD 分解结果。 CEEMD 分解具有良好的局部性和自适应性，能够更准确地分解信号，同时避免了 EEMD 中的模态混叠问题。因此，CEEMD 在信号处理、图像处理和模式识别等领域也得到了广泛的应用。
原始数据分解各分量示意图
4【MATLAB】CEEMDAN信号分解算法 CEEMDAN是对CEEMD的进一步改进，它引入了一种自适应噪声辅助方法，可以更好地处理信号中的高频噪声。CEEMDAN的主要步骤如下：
对原始信号进行若干次随机噪声扰动，得到多个噪声扰动数据集。
对每个噪声扰动数据集进行CEEMD分解，得到多个CEEMD分解集合。
对于每个CEEMD分解集合，引入自适应噪声辅助方法，通过将噪声信号添加到每个局部模态函数中，增强信号的边缘和高频部分。
将每个自适应噪声辅助后的 CEEMD 分解集合的对应分量进行平均，得到最终的 CEEMDAN 分解结果。 CEEMDAN 分解具有更好的对高频噪声的适应性，能够更准确地分解信号。因此，CEEMDAN 在信号处理、图像处理和模式识别等领域也得到了广泛的应用。
原始数据分解各分量示意图
原始数据分解各分量的箱型图
5【MATLAB】ICEEMDAN信号分解算法 ICEEMDAN (Improved Complete Ensemble EMD with Adaptive Noise) 是一种基于经验模态分解（Empirical Mode Decomposition, EMD）的信号分解方法。与传统的 EMD 方法不同，ICEEMDAN 引入了自适应噪声和完整集成策略，以提高分解的稳定性和准确性。在 ICEEMDAN 方法中，首先采用 EMD 将原始信号分解成多个固有模态函数（Intrinsic Mode Functions, IMF），然后通过自适应噪声算法去除每个 IMF 中的噪声，最后将去噪后的 IMFs 进行完整集成，得到分解后的信号。相比于传统的 EMD 方法，ICEEMDAN 采用自适应噪声算法去除噪声，可以减少分解过程中的模态混叠问题。此外，完整集成策略可以保证分解后的信号保留了原始信号的全部信息，提高了分解的准确性。 ICEEMDAN 分解方法在信号处理、图像处理、语音处理等领域得到了广泛应用，具有较高的分解效果和可靠性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8aa786e72587c502eb81364b79bf23bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e6b5dba9b4219c9e4561d96c3c5d8f8/" rel="bookmark">
			初级数据结构（七）——二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文中代码源文件已上传：数据结构源码
&lt;-上一篇 初级数据结构（六）——堆 | NULL 下一篇-&gt;
1、写在前面 二叉树的基本概念在《初级数据结构（五）——树和二叉树的概念》中已经介绍得足够详细了。上一篇也演示了利用顺序表模拟二叉树。但链表形式的二叉树在逻辑上相对于顺序表尤其复杂，当然也比顺序表更为灵活。
链表形式的二叉树任何操作，本质都是有条件地遍历各个节点。而熟练掌握递归算法对遍历链表形式二叉树尤为重要。如果你对递归还犯迷糊可先翻阅《轻松搞懂递归算法》一文，其中对递归有较为详细的介绍。
2、建立 链表形式的二叉树的创建操作已经属于遍历操作了，本部分将通过边创建边说明的方式演示如何遍历二叉树。
2.1、前期工作 老样子，先建文件。
binaryTree.h ：用于创建项目的结构体类型以及声明函数；
binaryTree.c ：用于创建二叉树各种操作功能的函数；
main.c ：仅创建 main 函数，用作测试。
这次演示是通过字符串创建二叉树，空节点以“ ? ”表示，所以在 binaryTree.h 中先写下如下代码：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef char DATATYPE; #define NULL_SYMBOL '?' #define DATA_END '\0' #define DATAPRT "%c" //创建二叉树节点 typedef struct Node { DATATYPE data; struct Node* left; struct Node* right; }Node; //函数声明------------------------------------- //创建二叉树 extern Node* BinaryTreeCreate(DATATYPE*); //销毁二叉树 extern void BinaryTreeDestroy(Node*); 然后在 binaryTree.c 中 include 一下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e6b5dba9b4219c9e4561d96c3c5d8f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/691c5b121376f9dd7c883aaab720a502/" rel="bookmark">
			2023 英特尔On技术创新大会直播 |让更多人了解AI魅力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023 英特尔On技术创新大会直播 |让更多人了解AI魅力 前言：主要领域:人工智能：使用 OpenVINO™ 落地边缘端生成式 AIOpenVINO™学习总结： 新一代 AI PC计算平台：新一代至强平台：英特尔® 至强® 以机密计算赋能云数据安全 边云协同：先进技术： Intel·on创新技术大会直播观看总结： 前言： 本次2023 英特尔On技术创新大会12月19日|中国站|
助力开发者，让 AI 无处不在，大会面向智算时代的开发者，由中国专家深度讲解英特尔最新一代加速 AI 能力的计算平台，支持开放、多架构的软件方案和工具，塑造未来的技术和应用创新。
主要领域: 人工智能： 加速 GenAI 在 IA 平台上的部署与优化在包括客户端、边缘计算和数据中心的英特尔平台上，可以针对不同业务场景，选用各种英特尔® CPU、GPU 和 NPU 等深度学习计算引擎，配以 OpenVINO™ , IPEX, ITEX, ITREX, BigDL-LLM, SynapseAI®, Optimum 等开发及优化工具链，加速生成式人工智能的持续调参优化和快速部署，让开发者能够灵活便捷地开发和交付面向消费者和企业级的 LLM/AIGC 业务软件。
这里我随便挑一个展开说一下。
使用 OpenVINO™ 落地边缘端生成式 AI OpenVINO作为Intel AI 软件开发工具，提供了全国的AI生态及技术集成支持包括行业最流行的AI框架模型PyTorch、TensorFlow、OBBXRuntime、PaddlePaddle等。同时支持自定义华模型，开发者在使用OpenVINO的同时只需要关注上层AI应用的构建，OpenVINO将提供基于因特尔各类硬件平台的底层指令集和硬件优化的技术接口实现跨多异构平台统一上层开发指令。
第二部分叠加于Diffusion模型的微调效果增加的部分
还有图像转文本的模型 Pix2sturct 可以用于提取图像中的基本信息 对截图内容做文本理解。
关于语音相关的模型 ：
SoftVC是一个结合RNN 和Transforner模型 可以用来做AI歌曲生成、声音克隆、欢声等应用音效。BArc 则是常见的TTS,也就是Text to Speech模型 可以模拟音乐、噪声、音效等各类声音且逼真度较高的一个模型（大约提供100多种人声模型）在AI领域也是一种比较广泛的模型Distil Whisper 是当下比较流行的一个模型 主要是用于语音识别输入的一个模型 OpenVINO™学习总结： OpenVINO™ 是开源跨各类行业AI应用，提供高效模型的开发工具套件通过案例来部署生成式、文本生成式的应用 可以帮助开发者去进行模型的调试和控制模型的精度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/691c5b121376f9dd7c883aaab720a502/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7904ba506923d0bec48d538eebdde978/" rel="bookmark">
			Copilot 使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitHub Copilot 是一个 AI 驱动的编程助手，能够在许多编辑器中提供代码建议和自动补全功能。以下是 Copilot 的一些基本使用方法：
安装和配置 安装： 首先，确保你有一个有效的 GitHub 账号并且安装了支持 Copilot 的代码编辑器，如 Visual Studio Code。
插件安装： 在你的代码编辑器中，搜索并安装 GitHub Copilot 插件。例如，在 VS Code 中，你可以在扩展市场中找到并安装它。
登录和授权： 安装插件后，根据提示登录你的 GitHub 账号并授权 Copilot。
基本使用 编写代码： 开始编写代码时，Copilot 会自动提供代码建议。这些建议会出现在编辑器中，通常显示为灰色文本。
接受建议： 如果你想接受 Copilot 的建议，可以使用快捷键（通常是 Tab 键）来接受当前的建议。
忽略建议： 如果你不想使用 Copilot 的建议，可以继续输入你自己的代码，或者使用快捷键（如 Esc 键）忽略建议。
触发建议： 有时，你可能需要手动触发 Copilot 的建议。在 VS Code 中，可以使用快捷键 Ctrl + Enter（或 Cmd + Enter 在 Mac 上）来实现。
进阶技巧 注释驱动编程： 你可以通过写下注释来告诉 Copilot 你想要实现的功能，Copilot 会根据注释提供代码建议。
探索不同的建议： Copilot 可能会提供多个建议。在 VS Code 中，你可以使用快捷键 Alt + [ 和 Alt + ] 在不同的建议之间切换。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7904ba506923d0bec48d538eebdde978/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef011e6f7e028b83622fcee42b53d4cd/" rel="bookmark">
			Flask解决接口跨域问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是跨域CROS CORS（Cross-Origin Resource Sharing，跨域资源共享）是一种浏览器安全策略，用于控制在一个网页应用中如何让一个域的Web页面能够请求另一个域的资源。在Web开发中，由于同源策略（Same-Origin Policy）的限制，一个网页只能请求同一域下的资源，而不能直接请求其他域下的资源。
同源策略是浏览器为了增强安全性而采取的一项重要措施。然而，由于现代Web应用的发展，需要在不同域之间进行数据交互的情况也变得非常普遍。CORS机制被引入，以在一定程度上解除同源策略的限制，允许服务器指定哪些域可以访问其资源。
CORS 的核心思想是在HTTP头中使用一些新的字段，告诉浏览器是否允许跨域请求。当浏览器发起一个跨域请求时，它会首先发送一个预检请求（preflight request）给服务器，以获取服务器是否允许实际的请求。如果服务器允许，浏览器会继续发送实际的请求。
以下是一些常见的CORS相关的HTTP头字段：
Origin： 表示发起请求的域，用于标识请求的来源。Access-Control-Allow-Origin： 服务器响应中包含这个头，表示允许访问的域，可以是一个具体的域或使用通配符（*）表示允许任意域。Access-Control-Allow-Methods： 服务器响应中包含这个头，表示允许的HTTP方法，如GET、POST等。Access-Control-Allow-Headers： 服务器响应中包含这个头，表示允许的自定义请求头。Access-Control-Expose-Headers： 服务器响应中包含这个头，表示允许暴露给浏览器的响应头，使得客户端能够访问。 通过配置这些头信息，服务器可以细粒度地控制是否允许跨域请求以及允许的跨域行为。
2、Flask接口支持跨域的方法 2.1 安装相应的包 pip install flask-cors 2.2 引用flask-cors from flask_cors import CORS app = Flask(__name__) CORS(app) 这种情况下，CORS扩展将允许所有的跨域请求。 但也可以通过配置选项来限制允许的来源、方法等。
CORS(app, origins='http://example.com') 3、单个接口的跨域设置 @app.route('/crosset', methods=["POST"]) @cross_origin() def set1(): print("我设置跨域了，可以访问了") 还可以通过cross_origin装饰器的参数来进一步自定义跨域请求的行为。例如，你可以指定允许的来源、方法等：
@app.route('/corsset2') @cross_origin(origins='http://example.com', methods=['GET', 'POST']) def set2(): print("我设置跨域了，可以访问了") 4、如何判断接口是否支持跨域 打开浏览器，找到Headers，如果接口不支持跨域请求，你将不会看到Access-Control-Allow-Origin字段，或者该字段的值为其他来源。
如果接口支持跨域请求，你会在响应的头部信息中看到Access-Control-Allow-Origin字段，该字段指定了允许跨域请求的来源。如果该字段的值为*，表示允许所有来源的跨域请求。
例如，如果你的接口允许来自http://localhost.8080的跨域请求，那么你会在响应的头部信息中看到类似如下的字段：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/036b27f3697fad5d5dfbc1cc4b38af19/" rel="bookmark">
			前端XSS攻击场景与Vue.js处理XSS的方法：vue-xss
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端XSS攻击场景与Vue.js处理XSS的方法 在前端开发中，跨站脚本攻击（XSS）是一种常见的安全威胁。本文将介绍前端跨站脚本攻击（XSS）的场景以及在Vue.js框架中如何处理XSS的方法。通过了解这些内容，我们可以更好地保护前端应用程序的安全性，防止恶意攻击。
一、前端XSS攻击场景 输入框注入：用户在输入框中输入恶意内容，这些内容会被提交到服务器端并被其他用户查看，攻击者可以通过注入恶意脚本获取其他用户的敏感信息。响应注入：攻击者通过注入恶意脚本到服务器的响应中，当其他用户访问该页面时，恶意脚本会被执行，从而盗取用户数据或篡改页面内容。URL参数注入：攻击者通过修改URL参数注入恶意脚本，当其他用户访问该页面时，恶意脚本会被执行。跨站请求伪造（CSRF）：攻击者通过伪造其他用户的请求，在用户不知情的情况下执行恶意操作，如修改密码、转账等。 二、Vue.js处理XSS的方法 数据绑定：在Vue.js中，我们通常使用双大括号语法（{{}}）来绑定数据。为了防止XSS攻击，我们需要对用户输入的数据进行过滤和转义。可以使用Vue XSS库提供的xss方法进行转义，确保用户输入的数据不会被恶意代码利用。输入验证：在接收用户输入的数据之前，需要进行严格的验证。确保输入的数据符合预期的格式和规则，以减少XSS攻击的可能性。使用CSP（内容安全策略）：CSP是一种安全机制，可以限制网页中可以执行的脚本和加载的资源。通过配置CSP策略，我们可以限制网页中可以执行的脚本和加载的资源，从而防止XSS攻击。使用HTTPOnly Cookie：HTTPOnly Cookie是一种安全机制，可以防止通过JavaScript访问Cookie数据。将Cookie设置为HTTPOnly，可以防止XSS攻击者通过JavaScript访问Cookie数据。使用HTTPS：HTTPS是一种加密协议，可以保护数据在传输过程中的安全性。使用HTTPS可以防止中间人攻击和数据窃取，从而减少XSS攻击的可能性。 三、vue-xss插件过滤xss语句 一个开箱即用的Vue.js插件，可通过简单的方式防止XSS攻击
安装 npm i vue-xss 或 yarn add vue-xss 使用 // main.js import VueXss from 'vue-xss' Vue.use(VueXss) &lt;!-- *.vue --&gt; &lt;div v-html="$xss(content)"&gt;&lt;/div&gt; 自定义配置项
支持 js-xss 的自定义规则，可通过 options 对象形式传入实例， 具体请点击 js-xss 查看
示例： // mani.js var options = { // 默认白名单参考 xss.whiteList whiteList: { a: ['href', 'style'], img: ['src', 'alt'], ... }, stripIgnoreTag: true, // 去掉不在白名单上的标签 true：去掉不在白名单上的标签 stripIgnoreTagBody: ['script', 'style'] // 去掉不在白名单上的标签及标签体 ['tag1', 'tag2']：仅去掉指定的不在白名单上的标签 onTagAttr: function () { // todo }, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/036b27f3697fad5d5dfbc1cc4b38af19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60d9851b7fac58fdc2ddd8c01ca0d530/" rel="bookmark">
			【hadoop】解决浏览器不能访问Hadoop的50070、8088等端口？！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【hadoop】解决浏览器不能访问Hadoop的50070、8088等端口？！😎 前言🙌【hadoop】解决浏览器不能访问Hadoop的50070、8088等端口？！查看自己的配置文件：最终成功访问如图所示： 总结撒花💞 😎博客昵称：博客小梦
😊最喜欢的座右铭：全神贯注的上吧！！！
😊作者简介：一名热爱C/C++，算法等技术、喜爱运动、热爱K歌、敢于追梦的小博主！
😘博主小留言：哈喽！😄各位CSDN的uu们，我是你的博客好友小梦，希望我的文章可以给您带来一定的帮助，话不多说，文章推上！欢迎大家在评论区唠嗑指正，觉得好的话别忘了一键三连哦！😘
前言🙌 哈喽各位友友们😊，我今天又学到了很多有趣的知识，现在迫不及待的想和大家分享一下！😘 都是精华内容，可不要错过哟！！！😍😍😍
【hadoop】解决浏览器不能访问Hadoop的50070、8088等端口？！ 我不知道为什么网上查到的都是说解决浏览器不能访问Hadoop的50070、8088等端口？！然后我按照网上的说法就行访问，一直访问不了网页，最后觉着是不是根我们的配置文件数据有关，然后尝试了一下果然可以。其实我们的端口设计可能就不是通过这两个端口号来访问的。
访问解决办法：
1、首先确保自己能够在虚拟机命令行正常启动而且，jps指令等运行都可以。
2、保证将防火墙关闭
3、端口号访问要具体根据自己的配置文件来看，根据自己设置的端口号来进行访问Hadoop页面就可以了。
查看自己的配置文件： vim yarn-site.xml #查看yarn-site.xml文件
选红色这段的配置端口号进行访问即可vi hdfs-site.xml #查看hdfs-site.xml文件
选红色这段的配置端口号进行访问即可 最终成功访问如图所示： 总结撒花💞 希望大家通过阅读此文有所收获！
😘如果我写的有什么不好之处，请在文章下方给出你宝贵的意见😊。如果觉得我写的好的话请点个赞赞和关注哦~😘😘😘
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e59ddb1df2c4ac39416a0f6724e394d/" rel="bookmark">
			Python importlib模块详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更多资料获取 📚 个人网站：ipengtao.com
importlib模块是Python标准库中用于动态导入模块的工具。它提供了一系列函数，允许以编程方式加载、检查和操作模块。本文将深入探讨importlib的各种用法，并通过丰富的示例代码帮助你更好地理解和应用这个强大的模块。
基本导入 首先，从importlib的基础用法开始。它提供了import_module函数，可以用来动态导入模块。
import importlib # 动态导入模块 math_module = importlib.import_module("math") # 使用导入的模块 result = math_module.sqrt(25) print(result) 动态导入类和函数 importlib不仅可以导入整个模块，还可以选择性地导入模块中的特定类或函数。
import importlib # 动态导入模块中的类和函数 random_module = importlib.import_module("random") random_function = importlib.import_module("random.choice", package="random") # 使用导入的类和函数 my_list = [1, 2, 3, 4, 5] random_element = random_function(my_list) print(random_element) 模块的重载和重新加载 importlib还提供了reload函数，可以在运行时重新加载先前导入的模块，这对于调试和开发非常有用。
import importlib # 动态导入模块 my_module = importlib.import_module("my_module") # ... 在这里对my_module进行修改 ... # 重新加载模块 my_module = importlib.reload(my_module) 动态创建模块 通过importlib，可以动态创建模块，这对于一些特殊场景非常有用。
import importlib # 创建一个新模块 new_module = importlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e59ddb1df2c4ac39416a0f6724e394d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/588c284bb9aac95bf327299a7375bd79/" rel="bookmark">
			SQL Error：1064，SQLState：42000
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SQL Error 1064 是一个常见的 SQL 错误，通常表示 SQL 语句存在语法错误或不符合数据库的规范。SQLState 42000 是表示通用语法错误的 SQL 状态码。要解决 SQL Error 1064，需要检查的 SQL 语句，确保它们符合数据库管理系统的语法规则。
引起错误的原因和解决方法：
语法错误：最常见的原因是SQL语句中存在语法错误，如拼写错误、不正确的关键字或不正确的语法结构。检查你的SQL语句并确保语法正确。缺少引号：如果你在SQL语句中使用字符串值，确保字符串被正确地引用。字符串应该用单引号或双引号括起来，具体取决于你的数据库系统。数据表或列名错误：检查你的SQL语句中引用的表名和列名是否正确。可能是拼写错误或大小写错误。保留字冲突：有时候使用了数据库系统的保留字作为表名、列名或别名会导致错误。确保不使用保留字作为标识符，并使用反引号（`）来引用它们，以防止冲突。分号缺失： SQL 语句应该以分号（;）结尾。如果你忘记了添加分号，可能会导致错误。数据类型不匹配：如果你正在插入或更新数据，确保值的数据类型与列的数据类型匹配。SQL语句片段错误：有时候错误可能在SQL语句的其他部分引起，因此需要仔细检查整个 SQL 语句。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a297090cf647b9d61f4ea7800b8583e/" rel="bookmark">
			Hive-分区与分桶详解（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Hive分区1. 什么是分区2. 分区的优势3. 如何创建分区表4. 如何插入分区数据5. 如何查询分区数据6. 分区因素 二、Hive分桶1. 什么是分桶2. 分桶的优势3. 如何创建分桶表4. 如何插入分桶数据5. 如何查询分桶数据6. 分桶因素7. 分区和分桶的综合应用 总结 前言 本文将介绍Hive中的两个重要概念：分区和分桶。在大数据处理场景下，通过合理地使用分区和分桶可以提高查询性能、管理灵活性以及支持更多的数据操作。
一、Hive分区 1. 什么是分区 在Hive中，分区是将表的数据按照某个列的值进行划分和存储的一种方式。通过分区，可以将数据按照特定的维度进行组织，提高查询效率和数据管理的灵活性。
2. 分区的优势 提高查询性能：通过分区，可以将数据按照特定的列值进行划分，使得查询只需要扫描特定分区的数据，减少了全表扫描的开销。管理数据更加灵活：可以根据业务需求对数据进行分区，方便数据的管理和维护。支持数据生命周期管理：可以根据数据的时间或其他维度进行分区，方便数据的归档和清理。 3. 如何创建分区表 在Hive中，可以使用PARTITIONED BY关键字来创建分区表。以下是创建分区表的示例：
CREATE TABLE my_table ( col1 INT, col2 STRING ) PARTITIONED BY (dt STRING, country STRING); 上述示例中，my_table表按照dt和country两个列进行分区。
4. 如何插入分区数据 在向分区表中插入数据时，需要指定分区列的值。以下是向分区表插入数据的示例：
INSERT INTO my_table PARTITION (dt='2023-01-01', country='China') VALUES (1, 'data1'), (2, 'data2'); 上述示例中，将数据插入到my_table表的dt='2023-01-01'、country='China'的分区中。
5. 如何查询分区数据 查询分区表的语法与普通表类似，可以使用SELECT语句查询特定分区的数据。以下是查询分区表数据的示例：
SELECT col1, col2 FROM my_table WHERE dt='2023-01-01' AND country='China'; 上述示例中，查询my_table表中dt='2023-01-01'、country='China'的分区数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a297090cf647b9d61f4ea7800b8583e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4989c0315cab9953d345f3e21fc6c492/" rel="bookmark">
			数据仓库命名规范详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数仓中为什么要在数据开发过程中强调遵守数仓开发命名规范呢？ 养成良好的编程习惯写出清楚、易懂、易维护的程序代码提高代码质量与沟通效率减少编码中的不必要的错误 二、数仓开发命名规范主要分为以下几个方面 （1）数据仓库命名规范
（2）表命名规范
（3）字段命名规范
（4）字段类型规范
三、规范详解 （1）数据仓库命名规范
（2）表命名规范
命名全部采用小写字母和数字构成，只能以字母开头，并且尽量避免使用数字。命名应采用能够准确反映其中文含义的英文单词或英文单词缩写构成，避免出现英文单词和汉语拼音混用的局面。命名长度尽量控制在30个字符以内，考虑可读性、易懂性、规范性；如果超过30个字符，尽量把长单词转换成缩略词。名称的各部分之间以"_"(下划线)拼接。数据域、主题域命名统一管理 ODS层表命名规范:
表名规范：ods_来源类型[业务|系统]_业务表名_装载策略_装载周期
表名示例：ods.ods_db_logs_gold_logs_i_d
规范说明：
-- 存储库名：ods
-- 来源类型：区分不同来源及系统，含结构化、半结构及非结构化数据。
-- 类型分类：DataBase（db）、Http（api）、Rsync Log（rsync）、MQ（topicName）、hive（layerName）。
-- 业务表名：与数据来源系统一致，以避免造成其二义性。有分表则去除分表规则，目标添加source_table字段区分来源表名。
-- 装载策略：增量（i）、全量（f）、快照（s）、 拉链（h）、
-- 装载周期：根据实际装载周期确定。实时（rt）、小时（h）、天（d）、周（w）、月（m）、季（q）、年（y）、一次性任务（o）、无周期（n）
DWD层表命名规范:
表名规范：dwd_一级数据域_二级数据域[_业务过程]_业务描述_装载策略_装载周期
表名示例：dwd.dwd_log_app_click_info_i_d
规范说明：
-- 存储库名：dwd
-- 一级数据域：用户域、内容域、日志域、财务域、互动域、服务域等等
-- 二级数据域：移动端、Web端、会员、金币等等，统一定义
-- 业务过程：曝光、浏览、点击、注册、登录、注销等等，统一定义
-- 业务描述：描述业务内容
-- 装载策略：增量（i）、全量（f）、快照（s）、 拉链（h）
-- 装载周期：根据实际装载周期确定。实时（rt）、小时（h）、天（d）、周（w）、月（m）、季（q）、年（y）、一次性任务（o）、无周期（n）
DWS层表命名规范:
表名规范：dws_一级数据域_二级数据域_数据粒度_业务描述_统计周期
表名示例：dws.dws_log_mbr_event_info_1d
规范说明：
-- 存储库名：dws
-- 一级数据域：用户域、内容域、日志域、财务域、互动域、服务域等等
-- 二级数据域：流量、渠道、会员、留存、事件等等
-- 数据粒度：描述业务数据粒度
-- 业务描述：描述业务内容
-- 统计周期：统计实际周期范围，缺省情况下，离线计算应该包括最近一天（_1[h|d|w|m|q|y]），最近N天（_n[h|d|w|m|q|y]）和历史截至当天（_t[h|d|w|m|q|y]）三个表。小时(h)、天（d）、周(w)、月（m）、季（q）、年（y）。
ADS层表命名规范:
表名规范：ads_应用类型_业务主题_业务描述_统计周期_装载周期
表名示例：ads.ads_rpt_channel_user_1d_d
规范说明：
-- 存储库名：ads
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4989c0315cab9953d345f3e21fc6c492/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/546/">«</a>
	<span class="pagination__item pagination__item--current">547/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/548/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>