<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d80fe4de99d3284cb83003f4a662faef/" rel="bookmark">
			移动硬盘接入mac无法复制文件进去怎么办，mac里的文件如何存进移动硬盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果要传输的文件数据量比较大，相比于使用U盘，移动硬盘是更多的选择。移动硬盘可存储量大、传输速度快，是实用性比较强的储存设备。不仅是Windows设备，Mac电脑也经常使用到移动硬盘。但有时候，移动硬盘在Mac上不能传文件，本文会一一解答以上问题。
一、移动硬盘在Mac上不能传文件的原因 移动硬盘是一种外接设备，可通过数据线与Mac电脑相连接。如果移动硬盘与Mac连接后不能传文件，可能是由以下问题引起的：
1.硬件损坏
移动硬盘、USB接口、数据线等硬件损坏均会导致移动硬盘无法读取与传文件。如果不清楚是哪个硬件出问题，可以逐个排查。比如可以将移动硬盘与其他电脑连接，测试其是否损坏；或者使用其他的数据线、接口进行测试。
2.移动硬盘格式与Mac系统不兼容
Mac系统需使用APFS或Mac OS等扩展格式的移动硬盘。如果使用适用于Windows系统的NTFS移动硬盘，Mac电脑无法与其兼容，可能会出现仅能读取但不能传文件的问题。
如果要解决问题，可使用Mac完全读写工具如Tuxera NTFS for Mac，或者进行格式转换。
图1：NTFS格式
3.读写权限设置有误
Mac电脑的读写权限可能设置有误，一般而言，移动硬盘会设置为可读写。如果误将其设置为仅读取，就无法进行文件传输。
对于以上问题，可将移动硬盘的权限（右击磁盘，选择“显示简介”）都设置为“读与写”。
图2：读写权限
二、Mac文件如何储存到硬盘 从上述学习到，外接硬盘如果连接到Mac，需要注意其扩展格式是否与Mac兼容。因此，如果要将Mac文件储存到硬盘，可通过以下两种方式实现：
1.如果硬盘是APFS或Mac OS扩展格式，可以直接储存
Mac电脑兼容APFS或Mac OS扩展格式的硬盘。如果硬盘格式符合，可以直接与Mac连接并进行文件的传输，无需进行其他的设置。
图3：硬盘
2.如果是NTFS硬盘，需要使用Mac完全读写软件或转格式
如果是NTFS格式硬盘，因其无法与Mac电脑兼容，需要借助其他软件的帮助或进行格式转换方可进行文件储存。
如果是使用Mac完全读写软件，推荐Tuxera NTFS for Mac，一款专为Mac电脑设计的读写软件，可自动挂载NTFS格式磁盘，并进行磁盘格式的转换。Tuxera自带的Disk Manager还可以进行电脑的磁盘管理，查看其文件系统等信息。
Tuxera NTFS for Mac 2023中文免费安装包：https://souurl.cn/IE35lO
图4：Tuxera Disk Manager
Tuxera NTFS for Mac的使用操作很简单，只需将其安装到Mac系统中，Tuxera会自动挂载NTFS文件格式的磁盘，使其可在Mac系统中进行读写操作。
图5：Tuxera NTFS for Mac
挂载后的NTFS格式磁盘怎么打开？如图6所示，可点击Mac系统右上角的Tuxera NTFS for Mac图标，在其展开的菜单中选择目标磁盘进行浏览、读取与文件传输。
图6：打开硬盘
在特殊情况下，比如Mac设置了修改权限，未授权的软件无法更改磁盘属性。在这种情况下，可使用Tuxera NTFS for Mac的手动挂载功能进行操作，
打开Tuxera NTFS for Mac的偏好设置窗口，如图7所示，切换到“卷”选项卡，即可在列表中手动挂载NTFS格式的磁盘。
图7：手动挂载
另一种读写NTFS硬盘的方法是将其格式转换为Mac电脑兼容的文件格式，Tuxera NTFS for Mac同样提供了相关的功能。在Tuxera Disk Manager工具中，可对所选磁盘进行文件系统的格式转换，但需要注意格式化会删除磁盘所有数据，因此需要谨慎使用。
图8：格式化磁盘
对于NTFS硬盘无法在Mac系统正常读写的问题，可通过Tuxera NTFS for Mac的功能解决。Tuxera NTFS for Mac可自动挂载NTFS磁盘，使其与Mac系统兼容并可读写，另外也能通过Tuxera NTFS for Mac的格式转换功能，将硬盘格式转换为Mac系统兼容的文件系统。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d80fe4de99d3284cb83003f4a662faef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1c614da9a60fbd456533d0514b322a1/" rel="bookmark">
			数据仓库和数据库有什么区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是数据仓库二、什么是数据库三、数据仓库和数据库有什么区别 一、什么是数据仓库 数据仓库（Data Warehouse）是一种专门用于存储和管理大量结构化数据的信息系统。它通过整合来自不同来源的数据，为企业提供统一、一致的数据视图，以支持决策制定和业务分析。数据仓库的核心特点包括数据的集成性、时变性、非易失性和面向主题的组织方式。
数据仓库的构建通常遵循数据抽取、清洗、转换和加载（ETL）的过程。首先，从各种业务系统中抽取数据，然后对数据进行清洗，消除不一致性和错误。接下来，对数据进行转换，将其转换成适合分析的格式。最后，将转换后的数据加载到数据仓库中。
数据仓库的设计通常采用星型模型或雪花模型。星型模型由一个中心的事实表和多个维度表组成，事实表存储度量数据，维度表存储描述性信息。雪花模型是星型模型的变体，维度表可以进一步细分为更小的表。这两种模型都有助于提高查询性能和简化数据组织。
数据仓库在企业中的应用非常广泛，包括销售分析、客户关系管理、库存管理、财务报告等。通过数据仓库，企业可以更好地了解业务状况，发现潜在问题，制定有效的策略，提高竞争力。
随着大数据技术的发展，数据仓库也在不断演进。现代数据仓库不仅支持传统的关系型数据库，还支持非关系型数据库和分布式计算框架，如Hadoop和Spark。这使得数据仓库能够处理更大规模的数据，满足实时分析和高级分析的需求。
总之，数据仓库是一种关键的信息技术，它通过整合和组织大量数据，帮助企业实现数据驱动的决策制定。随着技术的不断进步，数据仓库将继续发展，为企业提供更强大的数据分析能力。
二、什么是数据库 数据库是一种用于存储、检索和管理大量数据的系统。它允许用户以结构化的方式存储数据，并通过查询语言（如SQL）来检索和操作数据。数据库的核心是数据模型，它定义了数据的组织方式和数据之间的关系。常见的数据模型有关系型数据库、非关系型数据库（NoSQL）等。
关系型数据库是一种基于关系模型的数据库，它使用表格来组织数据，并通过主键和外键来建立表之间的关系。关系型数据库具有高度的结构化和规范化，适用于处理复杂的数据关系和事务处理。常见的关系型数据库管理系统有MySQL、PostgreSQL、Oracle和SQL Server等。
非关系型数据库（NoSQL）是一种不依赖于关系模型的数据库，它使用不同的数据模型来存储和组织数据，如键值对、文档、列族和图形等。NoSQL数据库具有更高的可扩展性和灵活性，适用于处理大规模数据和高并发访问。常见的NoSQL数据库有MongoDB、Cassandra、Redis和Neo4j等。
数据库管理系统（DBMS）是用于创建、维护和管理数据库的软件。它提供了数据定义语言（DDL）、数据操纵语言（DML）和数据控制语言（DCL）等工具，以支持用户对数据库进行操作。DBMS还负责数据的安全性、完整性和并发控制。
数据库的应用非常广泛，包括企业管理、电子商务、社交网络、物联网、大数据分析等领域。通过数据库，企业和组织可以高效地存储、检索和分析数据，从而提高决策效率和业务竞争力。随着技术的发展，数据库技术也在不断创新，如分布式数据库、云数据库、时序数据库等新型数据库技术，以满足不同场景和需求。
三、数据仓库和数据库有什么区别 数据仓库和数据库是两种不同类型的数据存储解决方案，它们在设计、用途和功能上存在显著差异。首先，数据库主要用于事务处理系统，它们支持日常操作，如数据的插入、更新和删除。数据库通常具有高度规范化的结构，以减少数据冗余并确保数据一致性。而数据仓库则主要用于数据分析和报告，它们存储大量历史数据，以支持企业决策制定。数据仓库通常具有较低的规范化程度，以优化查询性能。
在数据模型方面，数据库采用关系模型，通过表、行和列来组织数据。这种模型便于实现复杂的事务处理和数据完整性约束。而数据仓库则采用多维数据模型，通过维度和度量来组织数据。这种模型便于进行数据分析和聚合计算。此外，数据仓库通常使用星型模式或雪花模式等特定的数据模型，以提高查询性能。
在数据更新方面，数据库支持实时数据更新，以满足事务处理的需求。而数据仓库则采用批量加载的方式，定期从源系统中抽取数据并进行处理。这种处理方式可以减少对源系统的影响，并提高数据仓库的查询性能。
在数据规模方面，数据库通常用于存储相对较小的数据集，而数据仓库则需要处理大规模数据。数据仓库通常使用分布式存储和计算技术，以支持大规模数据的存储和分析。
在查询性能方面，数据库优化了事务处理性能，而数据仓库则优化了查询性能。数据仓库使用索引、分区和物化视图等技术，以提高查询速度和响应时间。
总之，数据仓库和数据库在设计、用途和功能上存在显著差异。数据库主要用于事务处理，而数据仓库主要用于数据分析和报告。选择合适的数据存储解决方案取决于企业的具体需求和应用场景。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35b9c28813d984da9d6f998889fe457c/" rel="bookmark">
			vitepress搭建的博客系统cdn引入github discussions评论系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		github仓库必须是公开的。
按照CDN的方式引入
打开discussions模块 安装giscus app 配置giscus 就是刚安装了giscus app的仓库
页面往下走，生成了代码：
配置vitepress 采用了CDN的方式引入
使用web component 随便找个地方试试组件
效果 有了
优化 那么多页面，一个一个的添加评论组件不现实。封装个评论组件覆盖原来的vitepress layout
在.vitepress目录下的theme目录下创建组件 &lt;!-- Layout.vue --&gt; &lt;template&gt; &lt;Layout&gt; &lt;template #doc-after&gt; &lt;giscus-widget id="comments" repo="chergn/questions" repoid="" category="Announcements" categoryid="" mapping="title" term="Welcome to giscus!" reactionsenabled="1" emitmetadata="0" inputposition="top" theme="light" lang="en" loading="lazy" &gt;&lt;/giscus-widget&gt; &lt;/template&gt; &lt;/Layout&gt; &lt;/template&gt; &lt;script lang="ts" setup&gt; import DefaultTheme from "vitepress/theme"; const { Layout } = DefaultTheme; &lt;/script&gt; 在.vitepress目录下的theme目录下的index.js文件配置layout import DefaultTheme from 'vitepress/theme' import CommentLayout from '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35b9c28813d984da9d6f998889fe457c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0f9bace51be86faf24e2bacc9156027/" rel="bookmark">
			【数据库编程-SQLite3（一）】sqlite3数据库在Windows下的配置及测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 学习分析 1、资源准备2、环境配置2.1、将资源包下载解压缩保存。2.2、在QT中创建工程,配置环境 3、测试配置3.1、 sqlite3_open函数3.2、sqlite3_close函数3.3、代码测试 1、资源准备 资源包
2、环境配置 2.1、将资源包下载解压缩保存。 解压缩得到以下文件
2.2、在QT中创建工程,配置环境 在工程目录下，创建bin文件夹，存放sqlite3.dll
在工程文件夹下创建lib文件，存放sqlite3.lib
在项目根目录下，放sqllite3.h
在pro文件末尾添加并保存：
DESTDIR=bin
LIBS+=$$PWD/lib/sqlite3.lib
将创建好的数据库文件拷贝到工程目录下的bin文件夹中。
3、测试配置 3.1、 sqlite3_open函数 3.2、sqlite3_close函数 3.3、代码测试 #include &lt;QApplication&gt; #include "sqlite3.h" #include &lt;QDebug&gt; #include &lt;QString&gt; int main(int argc, char *argv[]) { QApplication a(argc, argv); sqlite3 * dbconnect=nullptr; //1、打开数据库 int res=sqlite3_open("./xxxxx.db",&amp;dbconnect); if(res ==SQLITE_OK) { qDebug()&lt;&lt;"数据打开成功！"; }else { qDebug()&lt;&lt;"数据库打开失败！"; qDebug()&lt;&lt;sqlite3_errmsg(dbconnect);//打印错误信息 qDebug()&lt;&lt;sqlite3_errcode(dbconnect);//打印错误的代码 } //2、关闭数据库 sqlite3_close(dbconnect); return a.exec(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7584403e3b5042578f356c2f4dc36784/" rel="bookmark">
			C&#43;&#43; 算法教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		归并排序 #include&lt;iostream&gt; using namespace std; template &lt;class T&gt; void Merge(T data[],int start,int mid,int end) { int len1 = mid - start + 1, len2 = end - mid; int i, j, k; T* left = new int[len1]; T* right = new int[len2]; for (i = 0; i &lt; len1; i++) left[i] = data[i + start]; for (i = 0; i &lt; len2; i++) right[i] = data[i + mid + 1]; i = 0, j = 0; for (k = start; k &lt; end; k++) { if (i == len1 || j == len2) break; if (left[i] &lt;= right[j]) data[k] = left[i++]; else data[k] = right[j++]; } while (i &lt; len1) data[k++] = left[i++]; while (j &lt; len2) data[k++] = right[j++]; delete[] left; delete[] right; } template &lt;class T&gt; void MergeSort(T data[], int start, int end) { if (start &lt; end) { int mid = (start + end) / 2; MergeSort(data, start,mid); MergeSort(data, mid + 1, end); Merge(data, start, mid, end); } } void show(int*temp,int n) { for (int i = 0; i &lt; n; i++) cout &lt;&lt; temp[i] &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7584403e3b5042578f356c2f4dc36784/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6141b69e4ff485d59ee27546cd9f8518/" rel="bookmark">
			力扣每日一题 6/16 字符串 &#43; 随机一题 动态规划/数学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博客主页：誓则盟约系列专栏：IT竞赛 专栏关注博主，后期持续更新系列文章如果有错误感谢请大家批评指出，及时修改感谢大家点赞👍收藏⭐评论✍ 521.最长特殊序列 I【简单】 题目： 给你两个字符串 a 和 b，请返回 这两个字符串中 最长的特殊序列 的长度。如果不存在，则返回 -1 。
「最长特殊序列」 定义如下：该序列为 某字符串独有的最长
子序列
（即不能是其他字符串的子序列） 。
字符串 s 的子序列是在从 s 中删除任意数量的字符后可以获得的字符串。
例如，"abc" 是 "aebdc" 的子序列，因为删除 "aebdc" 中斜体加粗的字符可以得到 "abc" 。 "aebdc" 的子序列还包括 "aebdc" 、 "aeb" 和 "" (空字符串)。 示例 1：
输入: a = "aba", b = "cdc" 输出: 3 解释: 最长特殊序列可为 "aba" (或 "cdc")，两者均为自身的子序列且不是对方的子序列。 示例 2：
输入：a = "aaa", b = "bbb" 输出：3 解释: 最长特殊序列是 "aaa" 和 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6141b69e4ff485d59ee27546cd9f8518/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29e20ae92a3c8f294f412104f1eff3a1/" rel="bookmark">
			Python WordCloud库：词云图制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更多Python学习内容：ipengtao.com
WordCloud是一个用于生成词云图的Python库。词云图是一种数据可视化方法，通过将词语的频率或权重用不同的字体大小和颜色展示，使得信息更加直观和易于理解。WordCloud库能够根据文本内容生成美观的词云图，并提供了丰富的自定义选项。本文将详细介绍WordCloud库的安装、主要功能、基本操作、高级功能及其实践应用，并提供丰富的示例代码。
安装 WordCloud可以通过pip进行安装。确保Python环境已激活，然后在终端或命令提示符中运行以下命令：
pip install wordcloud 此外，为了生成和展示词云图，还需要安装Matplotlib库：
pip install matplotlib 主要功能 生成词云图：根据文本内容生成词云图。
自定义形状：支持自定义形状的词云图。
颜色配置：支持多种颜色配置和颜色映射。
词频统计：支持从文本中统计词频并进行可视化。
导出图像：支持将生成的词云图导出为图片文件。
基本操作 生成基础词云图 以下示例展示了如何使用WordCloud库生成一个基础词云图：
from wordcloud import WordCloud import matplotlib.pyplot as plt # 示例文本 text = "Python is a powerful programming language that is widely used for web development, data analysis, artificial intelligence, and scientific computing." # 生成词云图 wordcloud = WordCloud().generate(text) # 展示词云图 plt.imshow(wordcloud, interpolation='bilinear') plt.axis('off') plt.show() 自定义词云图参数 以下示例展示了如何自定义词云图的参数，如字体、背景颜色和图像尺寸：
from wordcloud import WordCloud import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29e20ae92a3c8f294f412104f1eff3a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/258257993cf038fb173d606b48e33894/" rel="bookmark">
			论文阅读笔记（通道注意力）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文阅读笔记（通道注意力） 摘要Abstract1. SENet1.1 研究背景1.2 创新点1.3 SE块的构建过程1.3.1 注意力和门机制1.3.2 SE块具体运行过程1.3.3 通道间依赖关系的提取1.3.4 自适应重新校正(Excitation) 1.4 SE结合先进架构的灵活应用1.5 实验1.6 模型的实现1.7 结论 2. SE-Resnet50 代码实现总结 摘要 本周阅读了 Squeeze-and-Excitation Networks 这篇文献，该文献提出了SENet架构，SENet（Squeeze-and-Excitation Networks）是一种深度学习架构，它通过引入注意力机制来增强卷积神经网络（CNN）的特征学习能力。其核心是SE模块，它通过显式地建模特征通道之间的相互依赖关系，使网络能够自适应地调整每个通道的响应。SE模块通过学习每个特征通道的重要性权重，然后根据这些权重对特征进行重标定，从而提升有用的特征并抑制无关的特征。本文将详细介绍SENet架构。
Abstract This week read the paper Squeeze-and-Excitation Networks, which proposes the SENet architecture, a deep learning architecture that enhances the feature learning of Convolutional Neural Networks (CNNs) by introducing an attention mechanism to enhance their feature learning capability. At its core is the SE module, which enables the network to adaptively adjust the response of each channel by explicitly modeling the interdependencies between feature channels.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/258257993cf038fb173d606b48e33894/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f48ce811cecf7aae729661e2cd68970/" rel="bookmark">
			函数(上)(C语言)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数(上） 一. 函数的概念二. 函数的使用1. 库函数和自定义函数(1) 库函数(2) 自定义函数的形式 2. 形参和实参3. return语句4. 数组做函数参数 一. 函数的概念 数学中我们其实就见过函数的概念，比如：一次函数y=kx+b，k和b都是常数，给⼀个任意的x，得到⼀个y值。
其实在C语言也引入函数（function）的概念，有些翻译为：子程序，子程序这种翻译更加准确⼀些。C语言中的函数就是⼀个完成某项特定的任务的⼀小段代码。这段代码是有特殊的写法和调用方法的。也就是说C语言的程序其实是由无数个小的函数组合而成的，也可以说：⼀个大的计算任务可以分解成若干个较小的函数（对应较小的任务）完成。
二. 函数的使用 1. 库函数和自定义函数 C语言中的函数也分为两种，一种是库函数，我们称它为C语言中已经实现的函数，比如像printf、scanf等函数，已经不需要程序员自己编写而是直接使用的函数。另一种是自定义函数，也就是需要程序员自己创造，自定义函数其实更加重要，也能给程序员写代码更多的创造性。
(1) 库函数 在这里要说明一下，我们使用库函数并不是简单的直接使用，每一个库函数都有它自己相应的头文件，我们只有调用出了这个头文件才能使用对应的库函数，比如我们使用printf函数，我们要在开头加上#include &lt;stdio.h&gt;；再者我们如果使用strlen函数，我们也要加上#include &lt;string.h&gt;，所以后面我们也要了解函数所对应的头文件。
(2) 自定义函数的形式 首先来讲函数的语法形式，下面给大家一张图了解清楚：
也就说自定义函数也是有一个规范使用的格式，我们是照着这样的格式一步步去写属于我们自己的代码，比如说现在我要实现一个加法的代码，我应该怎么去写这个函数，下面给大家举一个简单的例子说明：下面展示一些 内联代码片。
int Add(int x,int y) { int z=0; z=x+y; return z; } 上面的代码就是一个很简单的加法运算，int就代表我们的函数返回的类型是整形，而Add就是我们的函数名，如果后期要使用，我们就直接可以调用这个函数的名字进行使用，(int x,int y)就代表了我们要传入的形式参数，后面也会再详细教大家如何使用。
2. 形参和实参 在函数使用的过程中，把函数的参数分为，实参和形参。也就是我们在使用函数的时候，函数体本身和需要调用函数的那部分是分开的，我们也可以通过一个简单的例子向大家说明，我们还使用一个简单的加法的运算：下面展示一些 内联代码片。
1 int Add(int x, int y) 2 { 3 int z = 0; 4 z = x + y; 5 return z; 6 } 7 int main() 8 { 9	int a = 0; 10	int b = 0; 11	scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f48ce811cecf7aae729661e2cd68970/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64515a5e8f4bd785a7c2b065c2ffd6be/" rel="bookmark">
			【Perl】与【Excel】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 perl脚本语言对于文本的处理、转换很强大。对于一些信息量庞大的文本文件，看起来不直观，可以将信息提取至excel表格中，增加数据分析的可视化。perl语言的cpan提供了大量模块。对于excel文件的操作主要用到模块：
Spreadsheet::ParseXLSX
Excel::Writer::XLSX
第一个用于对现有excel 表格的解析，第二个用于创建新的excel文件。如果单纯是将文本信息提取到excel表格中其实第二个模块用的更多。看自己需求吧。
参考 &amp; 鸣谢：
perl处理Excel(跨平台) - 潘高的小站 (pangao.vip)
模块安装 首先确保你的linux系统有perl。
安装模块的指令 sudo perl -MCPAN -e "install '模块名'"
sudo perl -MCPAN -e "install 'Spreadsheet::ParseXLSX'"
sudo perl -MCPAN -e "install 'Excel::Writer::XLSX'"
安装成功的标志：
示例 纯粹为了练习而写的脚本，统计学生信息，名字是随机生成的字符串。
#!/usr/bin/perl =pod ========================================== Purpose : Excel Witer Example Author : On the way , running Date : 2024-06-16 ========================================== =cut use warnings; use Excel::Writer::XLSX; # -------------------Create a new Excel workbook my $xlsx_file_name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64515a5e8f4bd785a7c2b065c2ffd6be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/301c99bb9517bf29886200a8f841d1f6/" rel="bookmark">
			sqlite3模块的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. SQLite数据库 SQLite是一个轻量级的, 基于磁盘的, 关系型的数据库管理系统(RDBMS). 它不需要一个独立的服务器进程或操作系统级别的配置. SQLite是D.Richard Hipp在2000年创建的, 并且由于其小巧, 快速, 可靠和易于使用的特性, 它在全球范围内得到了广泛的应用. 以下是 SQLite 的一些主要特点和优势： * 1. 轻量级: SQLite的整个数据库就是一个单一的磁盘文件, 可以很容易地在不同的设备之间移动和复制. * 2. 零配置: 不需要安装或配置, 只需要将SQLite库与你的应用程序一起编译即可. * 3. 跨平台: 支持Windows, Linux, macOS, Android, iOS等多种操作系统. * 4. 支持SQL92标准: 虽然SQLite是一个轻量级的数据库, 但它支持大部分SQL92标准的功能. * 5. 事务完整: SQLite支持ACID事务, 这意味着数据库操作是原子性, 一致性, 隔离性和持久性的. * 6. 零服务器: SQLite不需要像MySQL, PostgreSQL或Oracle这样的中央服务器. 它直接从磁盘文件读取和写入数据. * 7. 可扩展性: 虽然SQLite本身是一个简单的数据库引擎, 但它允许用户通过创建虚拟表 (如全文搜索, R-Tree, 用户定义的函数等)来扩展其功能. * 8. 内存效率: SQLite使用了一种独特的B-Tree数据结构来存储数据, 这使得它在处理大量数据时非常高效. * 9. 安全性: SQLite支持加密和完整性检查, 以确保数据的安全性和一致性. 虽然它的功能不如一些更复杂的关系型数据库强大, 但SQLite提供了足够的功能来满足许多常见的数据存储和检索需求.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/301c99bb9517bf29886200a8f841d1f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acca15245d1644fef130d0fd74c899ec/" rel="bookmark">
			【靶场搭建】-02- 搭建OWASP靶机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.OWASP靶机介绍 相比较其他靶机，OWASP提供的环境更多，且包含了许多其他靶机的环境，属于性价比比较高的靶机了。
2.下载OWASP 访问以下地址进行下载：
https://sourceforge.net/projects/owaspbwa/
因为OWASP是虚拟机文件，所以可以直接使用虚拟机进行打开。
下载服务器在国外，所以速度大家懂的。
下载完成后进行解压，如下图所示：
3.启动OWASP靶机 使用VMWare打开虚拟机文件
进入系统界面：
OWASP的默认用户密码为：
用户名：root
密码：owaspbwa
然后在浏览器中输入OWASP靶机的系统地址就可以进入OWASP的web界面了。
此处我需要登录的地址是：http://192.168.8.130/
注意：在使用OWASP的时候，登录里面的其他环境时，默认的用户名密码不一定和OWASP的一致，可能是admin/admin，使用时可以自行进行尝试。
至此，OWASP的靶机环境也已经配置好了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ba3d0236684d93070fde53b37445d31/" rel="bookmark">
			【AI大模型】在测试中的深度应用与实践案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 示例项目背景2. 环境准备3. 代码实现3.1. 自动生成测试用例3.2. 自动化测试脚本3.3. 性能测试3.4. 结果分析 4. 进一步深入4.1. 集成CI/CD管道4.1.1 Jenkins示例 4.2. 详细的负载测试和性能监控4.2.1 Locust示例 4.3. 测试结果分析与报告 5. 进一步集成和优化5.1. 完善测试用例生成和管理5.1.1 配置文件管理测试用例 5.2. 高级性能监控和分析5.2.1 使用Grafana和Prometheus进行性能监控5.2.2 使用Jaeger进行分布式跟踪 5.3. 持续反馈与改进5.3.1 生成测试报告并通知 6. 总结 1. 示例项目背景 我们有一个简单的电商平台，主要功能包括用户注册、登录、商品搜索、加入购物车、下单和支付。我们将使用大模型来自动生成测试用例，并进行一些基本的测试结果分析。
2. 环境准备 首先，我们需要安装OpenAI的API客户端和其他必要的库：
pip install openai pip install pytest pip install requests 3. 代码实现 3.1. 自动生成测试用例 使用GPT-4自动生成测试用例，涵盖主要功能。
import openai # 设置API密钥 openai.api_key = "YOUR_API_KEY" def generate_test_cases(prompt): response = openai.Completion.create( engine="text-davinci-003", prompt=prompt, max_tokens=500 ) return response.choices[0].text.strip() # 定义测试用例生成的提示 prompt = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ba3d0236684d93070fde53b37445d31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d26ed66803dc4f5f39ea11096d0df7e0/" rel="bookmark">
			植物大战僵尸杂交版全新版v2.1解决全屏问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🚋一、植物大战僵尸杂交版❤️1. 游戏介绍💥2. 如何下载《植物大战僵尸杂交版》 🚀二、解决最新2.1版的全屏问题🌈三、画质增强以及减少闪退 🚋一、植物大战僵尸杂交版 《植物大战僵尸杂交版》是一款在原版《植物大战僵尸》基础上进行了创新的塔防策略游戏，特别引入了植物杂交系统。在这个版本中，玩家可以将不同的植物进行杂交，创造出具备特殊能力的新植物，比如将向日葵和豌豆射手结合成既可生产阳光又能进行攻击的植物，或将坚果与火炬相结合形成兼具防御与攻击的火炬坚果。
❤️1. 游戏介绍 植物大战僵尸杂交版是由B站UP主“潜艇伟伟迷”制作的一款结合了《植物大战僵尸》原有元素与创新玩法的游戏。这款游戏以其独特的“杂交”植物概念在B站上迅速走红，吸引了大量玩家的关注和讨论。在杂交版中，每个植物都有专属的特点以及玩法，玩家只需选择合适的植物布置战斗就能轻松击败所有的僵尸。例如，豌豆向日葵每25秒可以生产25点阳光，阳光豆90秒后长大，每25秒生产25点阳光。此外，还有如阳光炸弹、火炬坚果、寒冰香蒲等多种具有特殊能力的植物。 游戏还提供了休闲模式、正常模式和困难模式等多种难度选择，以及后台运行、自动收集、游戏加速和僵尸血量显示等控制台功能。玩家可以通过启动器创建容器，选择屏幕分辨率和显存大小，然后在模拟器中找到游戏安装程序开始安装。如果遇到游戏安装器黑屏或游戏闪退的问题，可以选择对应的文件进行修复。 此外，还有详细的植物图鉴大全，包括了各种植物的韧性、威力、攻击范围和特点等信息，帮助玩家更好地了解和使用这些植物。还有玩家对杂交版植物进行个人向的评分，分享他们对游戏的体验和看法。同时，网络上也有攻略大全，提供下载地址、闪退解决方法、冒险模式攻略等，帮助玩家更好地游玩这款游戏。
游戏特色：
植物杂交系统：游戏中最突出的特点是允许玩家将不同植物进行杂交，创造出具有新特性和攻击方式的植物。例如，向日葵豌豆射手结合了生产阳光和直接攻击的能力，猫蒲寒冰豌豆射手则同时具备减速和攻击的功能，这样的设计大大扩展了防守策略的多样性和深度。
全新植物与关卡：除了植物杂交外，游戏还加入了众多全新植物形象和关卡设计，每一种新植物都有其独特的造型和强大的技能，为玩家提供了更多样化的选择和挑战。
优化体验与本地化：潜艇伟伟迷的版本支持简体中文，方便中国玩家无障碍体验。同时，游戏在画面、音效上也有所优化，确保了流畅的游戏体验。
社区互动：作为B站UP主推出的版本，游戏背后有着活跃的社区支持，玩家可以在评论区分享攻略、交流心得，甚至参与到由潜艇伟伟迷组织的各种活动之中，增强了游戏的社交互动性。
游戏特色与亮点：
创新的植物杂交系统：《植物大战僵尸杂交版》的最大亮点在于其植物杂交机制，玩家可以将两种不同植物结合，创造出具有独特能力和攻击方式的新植物。这种机制大大丰富了游戏策略，让每一场战斗都充满变数和惊喜。
全新关卡与挑战：游戏不仅保留了经典的塔防玩法，还加入了大量新关卡和特殊事件，挑战玩家的策略布局和反应速度。每个关卡都精心设计，确保游戏的趣味性和挑战性并存。
优化的网络体验：借助加速器的支持，玩家可以告别游戏过程中的卡顿和延迟，享受流畅的游戏体验。这对于在线对战和合作模式尤为重要，确保每一次植物与僵尸的大战都行云流水。
视觉与音效升级：除了玩法上的革新，游戏在视觉效果和音效上也做了显著提升，为玩家带来更加生动、细腻的游戏世界。
💥2. 如何下载《植物大战僵尸杂交版》 第一步：进入B站搜索潜艇伟伟迷
B站UP主潜艇伟伟迷制作的《植物大战僵尸杂交版》是一款基于经典《植物大战僵尸》游戏的同人修改版，该游戏在原作基础上添加了创新的植物杂交元素，大大增加了游戏的策略性和可玩性。潜艇伟伟迷的这个版本因其独特的创意和丰富的游戏内容，在玩家群体中颇受欢迎。
第二步：
点击up主进入主页，再点击动态。
第三步：
复制链接进入网盘进行保存和下载安装。
网盘链接：https://pan.quark.cn/s/c1a75e93ecb5【点击直达】
🚀二、解决最新2.1版的全屏问题 下载好游戏之后，进入游戏后发现游戏显示界面很小，而且无法全屏显示，非常影响游戏体验感，下面是解决游戏无法全屏的步骤。
第一步：
右键桌面的植物大战僵尸启动程序，点击属性。
第二步：
点击兼容性。
第三步：
点击更改更高dpi设置，把下面的替代高DPI缩放行为打勾，并把下面的换成应用程序，然后游戏重启就可以全屏了。
最后一步：
进入游戏后，点击选项，点击全屏，点击3D加速(一定不要忘了，全屏上取消3D加速游戏可能会崩溃)，弄完之后，就可以进入快乐的游戏时光啦。
❶打完3d补丁之后，在游戏的安装文件夹pvzHE中会新生成一个PlantsVsZombies-XXX-XXX.exe的新文件，记得按照作者在补丁文件里给的使用说明将原先的PlantsVsZombies.exe删掉，将新生成的PlantsVsZombies-XXX-XXX.exe重命名为PlantsVsZombies.exe。(也就是将新生成文件“-”后面的多余字母去掉[打call])
❷在游戏选项中设置全屏无效后，我先按作者给的方法在系统显示里面将缩放与布局改为100%后还是无法全屏，重新按视频中提到的右键快捷方式更改属性后，不用Magpie这些工具软件也可以直接在游戏选项中设置全屏成功。
❸如果使用Magpie全屏放大后，四周都有黑边(主要是指上下，原版全屏左右也有黑边)，可以在Magpie中进行如下设置:
打开Magpie软件→点击最左侧“主页”下面的“缩放模式”→找到右侧Anime4K，点击最右侧的下三角按钮展开→点击展开后的“添加效果”→找到效果里的“Lanczos”，完成添加。最后重启游戏，重新按快捷键全屏放大即可去除上下黑边。
🌈三、画质增强以及减少闪退 这里其实可以借助Magpie工具，去github上https://github.com/Blinue/Magpie【点击跳转】或者releases下https://github.com/Blinue/Magpie/releases【点击跳转】
根据自己的电脑去进行下载安装。
结语
《植物大战僵尸杂交版》不仅仅是一款游戏的更新，它是对原作的一次致敬与超越。无论是老玩家还是新面孔，都能在这场植物与僵尸的智慧较量中找到属于自己的乐趣。现在就按照上述步骤下载游戏，开始你的新版本冒险吧！准备好，展现你的策略头脑，与那些奇异的植物战士们并肩作战，守护家园免受僵尸侵袭！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/215a0e32b08804281b9990e8eee63a71/" rel="bookmark">
			Apache网页优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网页压缩与缓存 在使用Apache作为Web服务器的过程中，只有对Apache服务器进行适当的优化配置，才能让Apache发挥出更好的性能。反过来说，如果Apache的配置非常糟糕，Apache可能无法正常为我们服务。因此，针对各种企业应用需求对Apache服务器的配置进行一定的优化是必不可少的。
网页压缩 网站的访问速度是由多个因素所共同决定的，这些因素包括应用程序的响应速度、网络带宽、服务器性能、与客户端之间的网络传输速度等等。其中最重要的一个因素是Apache本身的响应速度。因此当为网站性能所苦恼时，第一个需要着手进行处理的便是尽可能的提升Apache的执行速度，可以使用网页压缩提升应用程序的速度。更重要的是，它完全不需要任何的成本，只不过是会让服务器CPU占用率稍微提升一两个百分点或者更少。
1.gzip介绍 gzip是一种流行的文件压缩算法，目前应用非常广泛，尤其是在Liux平台。当使用gzip压缩一个纯文本文件时，效果是非常明显的，大约可以减少70%以上的文件大小。利用Apache中的gzip模块，可以使用gzip压缩算法来对Apache服务器发布的网页内容进行压缩后再传输到客户端浏览器。经过压缩后，实际上降低了网络传输的字节数，最明显的好处就是可以加快网页加载的速度。
网页加载速度加快的好处不言而喻。除了节省流量，改善用户的浏览体验外，另一个潜在的好处是gzip与搜索引擎的抓取工具有着更好的关系。
2.HTTP压缩的过程 Web服务器接收到浏览器的HTTP请求后，检查浏览器是否支持HTTP压缩(Accept--Encoding信息)。如果浏览器支持HTTP压缩，Web服务器检查请求文件的后缀名。如果请求文件是HTML、CSS等静态文件，Web服务器到压缩缓冲目录中检查是否已经存在请求文件的最新压缩文件。如果请求文件的压缩文件不存在，Wb服务器向浏览器返回未压缩的请求文件，并在压缩缓冲目录中存放请求文件的压缩文件。如果请求文件的最新压缩文件已经存在，则直接返回请求文件的压缩文件。如果请求文件是动态文件，Web服务器动态压缩内容并返回浏览器，压缩内容不存放到压缩缓存目录中。
3.Apache的压缩模块 Apache1.X系列没有内建网页压缩技术，使用的是额外的第三方mod_gzip模块来执行压缩。而Apache2.X官方在开发的时候，就把网页压缩考虑进去，内建了mod_deflate这个模块，用以取代mod_gzip。两者都是使用的gzip压缩算法，它们的运作原理是类似的。
mod_deflate压缩速度略快而mod_gzip的压缩比略高。一般默认情况下，mod_gzip会比mod_deflate多出4%~6%的压缩量。
一般来说，mod gzip对服务器CPU的占用要高一些。mod deflate是专门为确保服务器的性能而使用的一个压缩模块，mod deflate需要较少的资源来压缩文件。这意味着在高流量的服务器，使用mod_deflate可能会比mod_gzip加载速度更快。
简而言之，如果网站访问量较小，想要加快网页的加载速度，就使用mod gzip。虽然会额外耗费一些服务器资源，但也是值得的。如果网站访问量较大，并且使用的是共享的虚拟主机，所分配系统资源有限的话，使用mod_deflate将会是更好的选择。
Apache2.4.25版本中mod_deflate模块，可使用DeflateCompressionLevel指令设置压缩级别。该指令的值可为1（压缩速度最快，最低的压缩质量）至9（最慢的压缩速度，压缩率最高)之间的整数，其默认值为6（压缩速度和压缩质量较为平衡的值）。这个简单的变化更是使得mod_deflate可以轻松媲美mod_gzip的压缩。
4.mod_deflate模块 检查是否安装mod deflate模块。
(1)重新编译Apache添加mod_deflate模块 (2)配置mod deflate模块启用 在httpd.conf文件，开启LoadModule deflate_module modules./mod deflate.so配置项，在文本末尾添加一下参数。
(3)检查安装情况
检测httpd.conf语法，然后重新启动Apache服务器，并检查mod_deflate模块安装情况。
(4)测试mod_deflate压缩是否生效
使用火狐浏览器访问Apache服务器的URL地址，在浏览器中选择“查看元素”可以看到有“Accept--Encoding:gzip”表示压缩已经生效，如图4.1所示。
网页缓存 网页缓存是将一部分经常不会改变和变动很少的页面缓存，下次浏览器再次访问这些页面时，不需要再次去下载这些页面，从而提高了用户的访问速度。
Apache的mod_expires模块会自动生成页面头部信息中的Expires标签和Cache-Control标签，客户端浏览器根据标签决定下次访问是在本地机器的缓存中获取页面，不需要向服务器再次发出请求，从而降低客户端的访问频率和次数，达到减少不必要的流量和增加访问速度的目的。
配置mod expires模块的步骤与mod deflate模块相似。
(1)配置mod expires模块启用 启用mod_expires模块之前，可以用浏览器先抓取数据包，然后修改httpd.conf文件再抓取数据包进行对比。在httpd.conf去掉LoadModule expires_modulemodules/.mod_expires.so前面的#注释，末尾加入以下内容。
(2)检测htpd.conf语法 (3)重启Apache服务 使用火狐浏览器访问Apache服务器的URL地址，在浏览器中选择“查看元素”可以查看到响应头中包含了Expires项如图4.2所示，说明缓存已经工作。
隐藏版本信息 一般情况下，软件的漏洞信息和特定版本是相关的。因此，软件的版本号对攻击者来说是很有价值的，在浏览器中选择“查看元素”可以看到Apache的版本2.4.25，如图4.3所示。
如果黑客或别有用心的人得到Apache的版本信息，就会有针对性的进行攻击，给网站造成很大的损失。所以实际生产环境中要隐藏Apache的版本号，减少受攻击的风险，保护服务器安全运行。
修改htpd.conf配置文件，使htpd-default.conf文件生效，它里面包含了是否返回版本信息的内容。
然后，修改htpd-default.conf文件。
重新启动Apache服务，使用火狐浏览器访问Apache服务器的URL地址，在浏览器中选择“查看元素”可以查看到Apache的版本号已隐藏，如图4.4所示。
显示Server:Apache,版本信息已经被隐藏。ServerTokens表示Server回送给客户端的回应头域是否包含关于服务器OS类型和编译进的模块描述信息，这里设置的是Prod。
表4-1列出ServerTokens的选项以及输出格式。
Apache防盗链 Apache的默认配置除了性能可以优化外，还需要对安全性进行相应的配置。默认配置能保证服务器正常提供服务，但Apache作为一个软件，必然也会存在一些漏洞，尽可能的降低潜在的风险，是管理员必须掌握的内容。
一般来说，用户浏览一个完整的页面并不是一次性全部传送到客户端的。如果所请求的页面带有图片或其他信息，那么第一个HTTP请求传送的是这个页面的文本，然后通过客户端的浏览器对这段文本进行解释执行。如果发现其中还有图片，那么客户端的浏览器会再次发送一条HTTP请求，当这个请求被处理后这个图片文件才会被传送到客户端，最后浏览器会将图片安放到页面的正确位置，就这样一个完整的页面要经过多次发送HTTP请求才能够被完整的显示。
基于这样的机制，就会产生盗链问题：如果一个网站中没有其页面中所说图片信息，那么它完全可以链接到其他网站的图片信息上。这样，没有任何资源的网站利用了其他网站的资源来展示给浏览者，提高了自己的访问量，而大部分浏览者又不会很容易地发现。一些不良网站为了不增加成本而扩充自己站点内容，经常盗用其他网站的链接。一方面损害了原网站的合法利益，另一方面又加重了服务器的负担。
HTTP标准协议中有专门的Referer字段记录，它的作用如下。
可以追溯上一个入站地址是什么。对于资源文件，可以跟踪到包含显示它的网页地址是什么，因此所有防盗链方法都是基于这个Referer字段。 配置防盗链 准备两台服务器、一台客户端，且两台服务器上己分别部署完Apache服务。具体实验环境如表4-2)所示。
(1)在Windows系统中访问www.kxr.com和w.dt.com,确保Apache工作正常，如图4.5所示。
(2)准备图片
把图片复制到主服务器(www.kxr.com)的Apache工作目录usr/local/httpd/htdocs,确保图片存在。
修改index.html网页文件，加入图片显示代码。
再次访问网页，图片可以显示，如图4.6所示。
鼠标右键点选图片，选择“查看图像信息”，可以看到图片的网址是www.kxr.com/logo.jpg,如图4.7所示。
(3)模拟盗取图片链接
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/215a0e32b08804281b9990e8eee63a71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20b7ddbb111ae25df16d1d20a476abfc/" rel="bookmark">
			macbook pro 鼠标键 导致键盘失灵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题 关闭鼠标键之后 所有键盘还是不可用（开关机键除外）
解决 开机按住command+s进入单用户模式exit重启电脑 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d95f6e99bf9824b7be5ee92c38cfc58/" rel="bookmark">
			趣味C语言——【关机代码】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🥰欢迎关注 轻松拿捏C语言系列，来和 小哇 一起进步！✊
🎉创作不易，请多多支持🎉
🌈感谢大家的阅读、点赞、收藏和关注💕
🌹如有问题，欢迎指正
我们可以通过写一个简单代码来让电脑关机，这里需要用到system库函数，它可以执行系统命令。它需要头文件stdlib.h
shutdown
-s 关机
-t 设置时间关机
例：shutdown -s -t 60 倒计时一分钟关机
shutdown -a 取消关机
再结合一下strcmp函数就能写出以下有趣的关机代码：
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; int main() { char input[20] = { 0 }; system("shutdown -s -t 60"); again: printf("请注意，您的电脑在1分钟内会关机，输入以下内容可取消关机：\n我是猪\n"); scanf("%s", input); if (strcmp("我是猪", input) == 0) system("shutdown -a"); else goto again; return 0; } 代码运行后电脑就会弹出关机提醒，如果正确输入内容即strcmp函数返回值等于0，那么就能取消关机，否则倒计时结束电脑关机。 （strcmp函数在这篇文中有详细介绍http://t.csdnimg.cn/f85ol）
这里运用了goto语句 ，它可以实现在同⼀个函数内跳转到设置好的标号处。（曾在这篇文中讲过goto语句http://t.csdnimg.cn/hHXGu）
我们也可以不用goto语句，用循环来写：
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; int main() { system("shutdown -s -t 60 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d95f6e99bf9824b7be5ee92c38cfc58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f87dcc320ee58d62ae775b61d5306372/" rel="bookmark">
			【C&#43;&#43;提高编程-07】----C&#43;&#43; STL常用算法之遍历算法和算术生成算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎩 欢迎来到技术探索的奇幻世界👨‍💻
📜 个人主页：@一伦明悦-CSDN博客
✍🏻 作者简介： C++软件开发、Python机器学习爱好者
🗣️ 互动与支持：💬评论 👍🏻点赞 📂收藏 👀关注+
如果文章有所帮助，欢迎留下您宝贵的评论，
点赞加收藏支持我，点击关注，一起进步！
前言 STL（Standard Template Library）是C++标准库的一部分，提供了丰富的数据结构和算法，用于处理数据和实现常见的计算任务。STL中的算法分为几类，包括遍历算法、修改算法、排序算法、查找算法、数值算法等，每类算法都有其特定的应用场景和功能。
正文 01-遍历算法之for_each用法 for_each 是一种遍历算法，用于对指定范围内的每个元素执行特定操作。它的使用方式相对简单，但需要传入一个函数或函数对象作为操作的执行体。以下是关于 for_each 的详细介绍和用法示例：
for_each 用法详解
语法
template &lt;class InputIterator, class Function&gt; Function for_each(InputIterator first, InputIterator last, Function f); InputIterator：表示容器或范围的起始位置的迭代器。Function：表示执行的操作，可以是函数或函数对象（仿函数）。 参数
first：表示要处理的范围的起始位置。last：表示要处理的范围的结束位置，不包含在范围内。f：表示要执行的操作，可以是函数或函数对象。 功能
for_each 对 [first, last) 范围内的每个元素执行 f 操作。
返回值
返回值类型为 Function，通常是传入的函数或函数对象 f。
示例
假设有一个整数数组 numbers，我们想要将每个元素加倍并输出结果。可以这样使用 for_each：
#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; void doubleAndPrint(int x) { std::cout &lt;&lt; x * 2 &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f87dcc320ee58d62ae775b61d5306372/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7a641162274ed7c5c528d863c035ef3/" rel="bookmark">
			Flutter 实现StackAllocator简化FFI局部变量的内存管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、为何简化？1、通常做法2、简化 二、完整代码三、使用示例1、局部内存管理2、支持嵌套 总结 前言 使用Flutter通过FFI调用c库的时候，经常需要传字符串或者一些指针变量，这里变量通常都是局部变量，在一个代码块运行完成后就不需要了，我们通常用calloc进行内存申请和释放，但这也带来了一个麻烦，每个变量都需要单独释放，且字符串必须用变量进行释放，不能直接使用字面量作为参数，否则就内存泄漏了。本文提供一种针对上述问题的简化操作。
一、为何简化？ 1、通常做法 错误用法，下列用法会导致内存泄漏，在此表述用于明确简化的意义。
av_dict_set(opts, "rtsp_transport".toNativeUtf8().cast(),"tcp".toNativeUtf8().cast(), 0); 正确用法如下，变量多的时候，每个都要去释放是很麻的。
//对需要的变量进行内存申请 final key = "rtsp_transport".toNativeUtf8(allocator: calloc); final value = "tcp".toNativeUtf8(allocator: calloc); final a=calloc.allocate&lt;A&gt;(sizeOf&lt;A&gt;()); final b=calloc.allocate&lt;B&gt;(sizeOf&lt;B&gt;()); final c=calloc.allocate&lt;C&gt;(sizeOf&lt;C&gt;()); ffiTestA(a.ref); ffiTestB(b.ref); ffiTestC(c.ref); av_dict_set(opts, key.cast(), value.cast(), 0); //每个变量都需要变量进行内存释放 calloc.free(key); calloc.free(value); calloc.free(a); calloc.free(b); calloc.free(c); 2、简化 我们实现一个Allocator，用于局部的内存管理，就可以省去每个变量内存释放这个步骤。salloc是一个用于管理局部变量的Allocator。
//push表明入栈，可以理解为栈内存开始 salloc.push(); final a=salloc.allocate(sizeOf&lt;A&gt;()); final b=salloc.allocate(sizeOf&lt;B&gt;()); final c=salloc.allocate&lt;C&gt;(sizeOf&lt;C&gt;()); av_dict_set(opts, "rtsp_transport".toNativeUtf8(allocator: salloc).cast(),"tcp".toNativeUtf8(allocator: salloc).cast(), 0); ffiTestA(a.ref); ffiTestB(a.ref); ffiTestC(a.ref); //pop表明出栈，可以理解为栈内存结束（释放） salloc.pop(); 二、完整代码 stack_allocator.dart
import 'dart:ffi'; // For FFI import 'package:ffi/ffi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7a641162274ed7c5c528d863c035ef3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9999ff15583194f29125f79e1336b8df/" rel="bookmark">
			spring boot3登录开发-邮箱登录/注册接口实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		⛰️个人主页: 蒾酒
🔥系列专栏：《spring boot实战》
🌊山高路远，行路漫漫，终有归途
目录
写在前面
上文衔接
内容简介 功能分析
所需依赖
邮箱验证登录/注册实现
1.创建交互对象 2.登录注册业务逻辑实现 最近发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。
点击跳转到学习网站
写在前面 本文介绍了springboot开发后端服务中，邮箱验证码登录/注册功能的设计与实现，坚持看完相信对你有帮助。
同时欢迎订阅springboot系列专栏，持续分享spring boot的使用经验。
上文衔接 本文衔接上文，可以看一下：
spring boot3登录开发-邮件验证码接口实现-CSDN博客
用户表设计如下：
create table user ( id bigint auto_increment comment '主键' primary key, user_name varchar(32) null comment '用户昵称', password varchar(255) null comment '密码', account varchar(64) null comment '账号', user_role varchar(252) default 'user' null comment '用户角色：user / admin', avatar varchar(1024) null comment '头像', create_time datetime default (now()) null comment '创建时间', update_time datetime default CURRENT_TIMESTAMP null comment '更新时间', is_delete tinyint(1) default 0 null comment '逻辑删除：1删除/0存在', gender tinyint(1) null comment '性别', user_signature varchar(255) null comment '个性签名', status tinyint(1) default 1 not null comment '状态：1正常0禁用', phone varchar(11) null comment '手机号', email varchar(100) null comment '邮箱' ) comment '用户表'; 内容简介 上文我们已经实现了邮件验证码的发送接口，本文我们来实现这个邮箱验证登录/注册逻辑。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9999ff15583194f29125f79e1336b8df/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/261/">«</a>
	<span class="pagination__item pagination__item--current">262/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/263/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>