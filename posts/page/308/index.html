<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c060429b1942a4f17915e1c21e422806/" rel="bookmark">
			如何评价GPT-4o?【模板】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何评价GPT-4o? 简介：最近，GPT-4o横空出世。对GPT-4o这一人工智能技术进行评价，包括版本间的对比分析、GPT-4o的技术能力以及个人感受等。
提醒：在发布作品前，请把不需要的内容删掉。
方向一：对比分析
提示：梳理GPT各版本之间的内容，探讨GPT-4o和GPT-4之间的区别。
方向二：技术能力
提示：探讨GPT-4o在语言生成和理解方面的技术能力。
方向三：个人感受
提示：分享您个人对GPT-4o以及各大语言模型的整体感受。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53f4b0d75d3243d88328d64854a03bcd/" rel="bookmark">
			浅析Vue3基础知识(vue3笔记之入门篇)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是结合实践中和学习技术文章总结出来的笔记(个人使用),如有雷同纯属正常((✿◠‿◠))
喜欢的话点个赞,谢谢!
时下Vue框架都是使用Vue3版本来开发项目了,为了加深对Vue3基本知识的了解,特写了这个笔记
1. 生命周期 1.1. vue3生命周期 一个组件从开始到结束,正常的生命周期流程应该是这样:
//1.开始创建组件，在 beforeCreate 和 created 之前执行，创建的是 data 和 method setup() //2.在组件挂载之前执行 onBeforeMount() //3.在组件挂载之后执行 onMount() //4.在组件更新之前执行 onBeforeUpdate() //5.在组件更新之后执行 onUpdated() //6.在组件卸载之前执行 onBeforeUnmount() //7.在组件卸载之后执行 onUnmounted() 还有三个函数是特殊情况执行的:
onErrorCaptured
当捕获一个来自一个来自子孙组件的异常时触发的钩子函数
&lt;keep-alive&gt;: 被包含在&lt;keep-alive&gt;中的组件,会多出2个生命周期钩子函数:
onActivated
每次进入该组件页面都会触发
onDeactivated
比如从A组件切换到B组件,A组件消失时执行(等于是离开组件时触发)
1.2. vue2生命周期 vue2生命周期对比vue3生命周期,主要是beforeCreate和created被setup取代,还有一些方法名的变化:
//1.开始创建组件，在 beforeCreate 和 created 之前执行，创建的是 data 和 method beforeCreate + created = setup() //2.在组件挂载之前执行 beforeMount() =&gt; onBeforeMount() //3.在组件挂载之后执行 mounted() =&gt; onMount() //4.在组件更新之前执行 beforUpdated() =&gt; onBeforeUpdate() //5.在组件更新之后执行 Updated() =&gt; onUpdated() //6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53f4b0d75d3243d88328d64854a03bcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a70330f352d23d7a235c5f101ac2bb6/" rel="bookmark">
			初识JAVA中的包装类，时间复杂度及空间复杂度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录： 一.包装类 二.时间复杂度 三.空间复杂度 一.包装类： 在Java中，由于基本类型不是继承自Object，为了在泛型代码中可以支持基本类型，Java 给每个基本类型都对应了一个包装类型。 1 基本数据类型和对应的包装类 ： 注：除了 Integer 和 Character， 其余基本类型的包装类都是首字母大写 2.装箱和拆箱：装箱和 拆 箱，有 自动拆（装）箱 和 手动拆（装）箱 ，也就是（隐式和显示），具体如下： public class Test { public static void main(String[] args) { /** * 装箱 */ int a = 2; a = Integer.valueOf(a);//手动 or 显示装箱 Integer b = 1;//(自动)隐式装箱，实则调用了Integer.valueOf方法 System.out.println(a); System.out.println(b); // Integer c = 10; /** * 拆箱 */ /*int a = c.intValue(); //手动拆箱 System.out.println(a); int d = c; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a70330f352d23d7a235c5f101ac2bb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcc490f901433ceb4a89395cd6b64b3a/" rel="bookmark">
			重学java 63.IO流 字节流 ④ 文件复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 身处泥泞，看满山花开
—— 24.6.4
图片复制 分析 1.创建两个对象 FilelnputStream —&gt;读取指定的文件
FileOutputStream —&gt; 将读到的字节写到指定的位置
2.边读边写 import java.io.FileInputStream; import java.io.FileOutputStream; public class Demo268PhotoCopy { public static void main(String[] args) throws Exception { // 1.创建FileInputStream FileInputStream fis = new FileInputStream("D:\\2LFE\\Desktop\\前端三剑客\\css\\CSS.day3\\头像.jpg"); // 2.创建一个FileOutputStream，将读取的图片写到指定的位置 FileOutputStream fos = new FileOutputStream("AllWillBest_Java\\头像.jpg"); // 3.定义一个数组，new一个byte byte[] bytes = new byte[1024]; // 4.边读边写,len代表读取的个数 int len; while ((len = fis.read(bytes)) != -1) { fos.write(bytes, 0, len); } // 5.关闭文件，先开后关 fos.close(); fis.close(); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5dc8541c8c434c3db1ba83b691213ca/" rel="bookmark">
			MySQL Hints：控制查询优化器的选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		码到三十五 ： 个人主页 MySQL Hints是优化数据库查询性能的一种强大工具。它们允许开发者在SQL查询中嵌入指令，以影响MySQL优化器的决策过程。在某些情况下，优化器可能无法选择最佳的查询执行计划，这时我们可以使用Hints来引导优化器做出更好的选择。
目录 一、什么是MySQL Hints二、为什么需要使用Hints三、如何使用Hints1. 确定需要使用的Hint2. 编写Hint注释3. 将Hint注释与SQL语句结合4. 测试和验证语法说明 四、常用的MySQL Hints1. `USE INDEX` 和 `FORCE INDEX`2. `IGNORE INDEX`3. `STRAIGHT_JOIN`4. `SQL_NO_CACHE`5. `INDEX_MERGE` 和 `NO_INDEX_MERGE`6. **`JOIN_FIXED_ORDER`**7. **`BLOCK_NESTED_LOOP`**, **`BATCHED_KEY_ACCESS`**, **`NO_BNL`**, 和 **`NO_BKA`**8. **`MRR`** 和 **`NO_MRR`**9. **`FILESORT`** 和 **`NO_FILESORT`**10. **`SUBQUERY`** 和 **`NO_SUBQUERY`**11. **`DERIVED_MERGE`** 和 **`NO_DERIVED_MERGE`** 五、优化器Hints与`optimizer_switch`的区别六、使用Hints的注意事项七、结语 一、什么是MySQL Hints MySQL Hints是一组特殊的注释或指令，可以直接嵌入到SQL查询中，以改变MySQL优化器的默认行为。这些Hints通常被用于解决性能问题，或者当开发者比优化器更了解数据分布和查询特性时，来指导优化器选择更好的查询计划。
二、为什么需要使用Hints 性能调优：在某些复杂的查询场景下，优化器可能无法自动选择最优的执行计划。通过Hints，我们可以手动指定一些执行策略，从而提升查询性能。
控制执行计划：当数据库中的数据分布或表结构发生变化时，优化器可能会选择不同的执行计划。使用Hints可以确保查询的稳定性，即使在数据或表结构发生变化时，也能保持相同的执行计划。
解决特定问题：有时，我们可能会遇到一些特定的问题，如索引选择不当、连接顺序不佳等。Hints提供了一种快速解决问题的方法，而无需更改表结构或重写查询。
三、如何使用Hints Hints是通过在SQL语句前添加特殊格式的注释来使用的。通常的格式是/*+ HintName(parameters) */。这些Hints只对紧跟其后的SQL语句有效，并且不会影响其他查询。以下是如何在SQL语句中使用Hints的详细步骤：
1. 确定需要使用的Hint 首先，你需要确定你想要使用的Hint。这通常基于你对查询性能的分析和对MySQL优化器行为的理解。例如，如果你发现优化器没有选择你认为最优的索引，你可能会想要使用FORCE INDEX或IGNORE INDEX等Hints。
2. 编写Hint注释 在SQL语句之前，你需要添加一个特殊格式的注释来包含你的Hint。这个注释的格式是/*+ HintName(parameters) */，其中HintName是你想要使用的Hint的名称，parameters是该Hint所需的任何参数。
例如，如果你想要强制优化器使用特定的索引，可以这样写：
/*+ FORCE INDEX(table_name idx_name) */ 在这里，table_name是你想要应用Hint的表的名称，而idx_name是你想要强制优化器使用的索引的名称。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5dc8541c8c434c3db1ba83b691213ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b20d9d1284d49b41bb8b786d3c160027/" rel="bookmark">
			使用wheelnav.js构建酷炫的动态导航菜单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、WheelNav是什么
1、项目地址
2、关于开源协议
3、相关目录介绍
二、如何使用wheelnav.js
1、新建html页面
2、设置style样式
3、创建展示元素实现动态导航
三、参数即方法介绍
1、参数列表
2、运行方法
3、实际成果
四、总结 前言 用户体验永远是一个值得探讨的问题，同时也是应该在平时的研发工作工作中作为重点关注的地方。使用习惯，界面的布局，用户点击操作的系统反应情况，都会给使用者带来很大的冲击。关于用户体验的设计，尤其以吸引用户，在应用上做更多的停留。需要我们的界面设计者花更多的心思。本文无意于过多的讲解如何进行用户体验的设计。用户体验只是我们所有的工程师共同去努力提升。
上图是一个非常有趣的百科历史类的网站全历史，这里的关系图谱是动态支持旋转的，非常有意思。根据人物不同的维度，比如以上述的历史人物詹天佑为例，从人物的7个方面去描述，分别包括成就、友情、工作、地点、影响、经历、归属。这相当于人物的7个方面，就像知识图谱中的一些关系，更妙的是，在功能界面上，用户可以在选择不同的维度之后，右边的界面会跟随左边的维度来自动切换，完全是一种动态的导航菜单。
本文即在上述的场景中，主要介绍一种基于SVG的web动态导航组件。通过这个组件可以实现很多丰富酷炫的效果。首先介绍这款wheelnav.js的相关知识，然后结合代码讲解如何在html页面中创建其对象，接着讲解wheelnav的一些属性和方法，最后给出基于wheelnav的实际成果。如果您目前也有类似的需求，不妨来这里看看，或许能提供一些参考。
一、WheelNav是什么 wheelnav.js 是一个基于 SVG 的动态导航菜单组件。它可以是一个派菜单（径向菜单，循环菜单），选项卡导航，自菜单，选项按钮，复选框等等。
使用wheelnav可以实现以下效果：
（1）创建圆形导航：轻松地创建一个基于圆形的导航菜单，其中每个菜单项都是圆形上的一个点或扇区。
（2）高度可定制：自定义每个菜单项的颜色、形状、大小、位置、标签、工具提示等。
（3）交互性：添加点击、悬停和拖动事件，以便用户与导航菜单进行交互。
（4）动画效果：为菜单项添加动画效果，如渐变、旋转、缩放等，以增强用户体验。
（5）响应式设计：调整导航菜单以适应不同屏幕尺寸和设备类型，确保在各种设备上都能良好地显示和工作。
（6）集成应用：由于 wheelnav.js 是一个轻量级的库，因此可以轻松地集成到现有的 HTML、CSS 和 JavaScript 项目中。
1、项目地址 本节将介绍这个库的开源地址。如果大家可以正常访问到github的话，可以在github中找到其源码，github源码地址。如果访问不是很流程，大家在国内的gitee上访问也是可以的。也有技术人员在上面会自动同步相应的库。相关资源可以问问度娘。下面以github为例，说明：
2、关于开源协议 开源协议是用于规范使用开源项目的一种协议，因此我们在使用开源项目的时候一定要非常注意，作为一个技术人，要尊重作者，尊重开源，把生态圈共同维护好。wheelnav采用的是宽松的MIT协议，对使用方没有任何限制。
﻿The MIT License (MIT) Copyright (c) 2014-2021 Gábor Berkesi (https://softwaretailoring.net) Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b20d9d1284d49b41bb8b786d3c160027/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c829f7e46b927faa2741aa56ae24929/" rel="bookmark">
			OJ题目【栈和队列】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目导入 栈：
题目一：有效的括号题目二：用栈实现队列 队列
题目：实现循环队列 栈 题目一 有效的括号 题目要求
给定一个只包括 ‘(’，‘)’，‘{’，‘}’，‘[’，‘]’ 的字符串 s ，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。每个右括号都有一个对应的相同类型的左括号。 下图为力扣的示例
题目代码原型
bool isValid(char* s) { //The code is written here } 这题就很适合用栈来实现，当是左括号的时候就入栈，如果是右括号就与栈顶的左括号进行对比，如果匹配成功就将栈顶的左括号给Pop掉
创建栈
Stack st; StackInit(&amp;st); 入栈函数：
if (*s == '(' || *s == '[' || *s == '{') { StackPush(&amp;st, *s); } 但是匹配了没有意义，因为栈内可能还有多个元素，所以我们要判断不匹配的情况（不匹配可以直接出结果）
代码如下：
else { STDataType tmp = StackTop(&amp;st); StackPop(&amp;st); if ((tmp == '(' &amp;&amp; *s != ')') || (tmp == '[' &amp;&amp; *s !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c829f7e46b927faa2741aa56ae24929/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1484318d3ea3f4e1e3e85a437e51ac8e/" rel="bookmark">
			python的sql解析库-sqlparse
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容目录 一、基本方法:1.parse(sql)2.format(sql)3.split()4.parsestream() 二、Token三、其他类型四、案例: 提取所有查询的字段和表名 sqlparse 是一个 Python 库，是一个用于 Python 的非验证 SQL 解析器, 用于解析 SQL 语句并提供一个简单的 API 来访问解析后的 SQL 结构。可以帮助解析复杂的 SQL 查询，提取信息，或者对 SQL 语句进行一些基本的分析和操作。
一、基本方法: sqlparse的__init__方法中提供了四个基础方法
1.parse(sql) 用于将一个或多个 SQL 语句的字符串解析成 Python 对象，这些对象构成了一个抽象语法树（AST）
源码
def parse(sql, encoding=None): """Parse sql and return a list of statements. :param sql: A string containing one or more SQL statements. :param encoding: The encoding of the statement (optional). :returns: A tuple of :class:`~sqlparse.sql.Statement` instances. """ return tuple(parsestream(sql, encoding)) 按照符号分割sql后返回一个元组, 可以递归获取所有的值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1484318d3ea3f4e1e3e85a437e51ac8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11361a2b3dfeeb81e97d23e3441b5cb2/" rel="bookmark">
			【香橙派 AIpro 开发板】AI 应用部署测评：视频目标检测&#43;Linux镜像&#43;vscode远程连接&#43;全细节试用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		香橙派 AIpro 开发板 AI 应用部署测评 写在最前面一、开发板概述官方资料试用印象适用场景 二、详细开发前准备步骤1. 环境准备2. 环境搭建3. vscode安装ssh插件4. 香橙派 AIpro 添加连接配置5. 连接香橙派 AIpro6. SSH配置 二、详细开发步骤1. 登录 juypter lab2. 样例运行3. 观察与调整4. 运行目标检测样例 小结试用感受 🌈你好呀！我是 是Yu欸 🌌 2024每日百字篆刻时光，感谢你的陪伴与支持 ~ 🚀 欢迎一起踏上探险之旅，挖掘无限可能，共同成长！ 写在最前面 在人工智能和物联网技术日益成熟的今天，边缘计算设备因其在数据处理和实时性方面的优势而受到广泛关注。香橙派 AIpro（OrangePi AIpro）开发板以其出色的性能和丰富的应用场景，成为开发者探索 AI 应用部署的理想选择。
有幸获得了邀请，并有幸邀请到了闪电@shandainchengzi，和我一起对这款备受瞩目的开发板进行一次体验测评。下面将从新手个人开发经验出发，对香橙派 AIpro 开发板进行测评，并分享我的试用感受。
一、开发板概述 香橙派 AIpro 是一款集成了华为 Ascend 系列 AI 处理器的开发板，专为 AI 应用和边缘计算设计。它不仅具备强大的计算能力，还拥有丰富的接口和扩展性，使其能够满足多样化的 AI 应用场景需求。
官方资料 首先进入官网http://www.orangepi.cn/
进入香橙派 AIpro的相关栏目，可以发现有很多官方资料，以及官方镜像。http://www.orangepi.cn/html/hardWare/computerAndMicrocontrollers/details/Orange-Pi-AIpro.html
有两种镜像可以选择，本文以Linux为例进行说明。
试用印象 对香橙派 AIpro 的第一印象是其简洁而高效的开发环境。开发板预装的 Jupyter Lab 软件，为 AI 应用的编写、测试和部署提供了极大的便利。通过 Jupyter Lab，可以在一个统一的界面中完成代码编写、模型训练和结果展示。
适用场景 香橙派 AIpro 适用于多种 AI 应用场景，包括但不限于目标检测、图像分类、语音识别等。它的轻量化设计使其尤其适合于需要实时处理和低延迟的应用，如智能监控、自动驾驶辅助系统等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11361a2b3dfeeb81e97d23e3441b5cb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1136d1a1780bc0c5df26a1c1b42e1a61/" rel="bookmark">
			新架构Mamba-2正式发布！！真实版“man, what can i say”！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mamba 面世以来，社区反应热烈，获得了广泛关注。
遗憾的是，Mamba 的论文竟然被 ICLR 拒稿，这让许多研究者颇感意外。
仅仅六个月之后，原作者团队带来更加改进和强大的 Mamba 2 正式发布啦！！
Mamba-2，其状态空间扩大了8倍，训练速度提升了50%！
——Transformer的新挑战者，最新架构Mamba刚刚推出了其第二代版本！
论文地址： Transformers are SSMs: Generalized Models and Efficient Algorithms Through Structured State Space Duality GitHub 地址： https://github.com/state-spaces/mamba 更令人惊讶的是，团队的研究发现Transformer和状态空间模型（SSM）实际上是亲近关系。
这两大主流的序列建模架构，终于在此实现了统一。
OpenAI发布GPT-4o一夜创历史，超越所有AIhttps://www.zhihu.com/pin/1773645611381747712
没体验过OpenAI最新版GPT-4o？快戳最详细升级教程，几分钟搞定：
手把手升级ChatGPT-4o Turbo详细步骤教程https://www.zhihu.com/pin/1768399982598909952
01 状态空间模型SSM 没错，这篇论文揭示了一个重大的发现：Transformer中的注意力机制与状态空间模型（SSM）之间存在着非常紧密的数学联系。
团队通过提出一个名为结构化状态空间二元性（Structured State Space Duality, SSD）的理论框架，将这两大模型家族统一了起来。
值得一提的是，Mamba一代论文在年初被ICLR拒稿，曾引发学术界广泛热议，许多学者因此纷纷表态。
此次推出的二代论文在理论和实验上都有了更丰富的内容，并成功入选ICML 2024。
论文的作者依然是Albert Gu和Tri Dao两位。
他们透露，论文题目中的“Transformers are SSMs”是向四年前那篇经典的线性注意力论文“Transformers are RNNs”致敬。
Transformer的核心组件是注意力机制，而SSM模型的核心则是一个线性时变系统。
乍看之下，两者似乎毫无关联，但论文指出：它们都可以表示成可半分离矩阵（Semiseparable Matrices）的变换。
让我们先从SSM的角度来看。
SSM本身定义了一个线性映射，恰好可对应于一个半可分离矩阵。
半可分离矩阵具有特殊的低秩结构，而这种结构恰好与SSM模型中的状态变量相对应。
因此，矩阵乘法就相当于SSM的线性时变系统。带选择性的SSM实际上是一种广义线性注意力机制。
从注意力的角度来看，又会有什么发现呢？
团队试图通过更抽象的方式来描述注意力机制的本质，毕竟“Softmax自注意力”只是其中的一种形式。
更一般地说，任何带有掩码的注意力机制，都可以表示为4个张量的缩并（Contraction）。
其中，QKV分别对应注意力中的query、key、value，L则对应掩码矩阵。 借助这一联系，团队在线性注意力的基础上提出了结构化掩码注意力（Structured Masked Attention，SMA）。
当注意力的掩码矩阵是半可分离的，就与SSM等价。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1136d1a1780bc0c5df26a1c1b42e1a61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bdc7a90f8328e6f6c2ff9961657530a/" rel="bookmark">
			Mac M1安装编译FFmpeg教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇介绍的是Mac安装FFmpeg的教程，该教程是为进行音视频的开发学习作准备的，很多时候需要看源码调试学习，若只为了熟悉使用ffmpeg、ffplay、ffprobe等命令，建议直接使用brew install ffmpeg安装稳定版本。
目录 一、安装Homebrew二、安装FFmpeg1.官网下载2.使用git安装3. 编译4.全局配置5.检验 一、安装Homebrew Homebrew是MacOS（或 Linux）的软件包管理器，可以说是神器了。用于软件包的安装、更新、卸载、搜索等等。
#需要梯子 /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" 没有梯子的使用国内，可以参考一下其他博客的方法，由于要编译ffmpeg会装比较多的库,推荐用国内镜像
#使用检验 brew -v 二、安装FFmpeg 这里并没有直接使用brew install ffmpeg 安装是因为后续想用源码调试。
1.官网下载 最新稳定版本
其他版本
2.使用git安装 使用git安装源码比较方便版本切换，推荐此方法
git clone https://git.ffmpeg.org/ffmpeg.git ffmpeg 查看远端的分支
cd ffmpeg &amp;&amp; git branch -r 拉取远端分支到本地 - 将来想要切换分支比较方便
git checkout -b release/7.0 origin/release/7.0 接下来使用brew进行安装编译需要的库，建议一个一个下
brew install automake brew install fdk-aac brew install lame brew install libass brew install libtool brew install libvorbis brew install libvpx brew install libvo-aacenc brew install opencore-amr brew install openjpeg brew install opus brew install speex brew install texi2html brew install x264 brew install x265 brew install xvid brew install yasm brew install freetype brew install pkg-config brew install shtool brew install theora brew install sdl2 brew install aom brew install aribb24 brew install dav1d brew install fontconfig brew install libbluray brew install libgsm brew install openh264 brew install libmodplug brew install snappy brew install libsoxr brew install two-lame brew install libvidstab brew install zimg brew install zmq 配置编译信息 - 可以参考官网这部分的编译
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bdc7a90f8328e6f6c2ff9961657530a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab6b889e8513bcbee96ba7e7766e3290/" rel="bookmark">
			c语言：自定义类型（枚举、联合体）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：
1.位段
1.1什么是位段
1.2 位段的内存分配 1.3 位段的跨平台问题
2.枚举
2.1枚举类型的定义
2.2枚举类型的优点 3.联合体（共用体）
3.1联合类型的定义
3.2联合体的特点 3.3联合大小的计算
3.4联合体的实际应用 前言： c语言中中自定义类型不仅有结构体，还有枚举、联合体等类型，上一期我们详细讲解了结构体的初始化，使用，传参和内存对齐等知识，这一期我们来介绍c语言中的其他自定义类型枚举和联合体的知识。
1.位段 在讲枚举，联合体之前，我们补充上一期结构体剩下的一点知识——位段。
1.1什么是位段 位段的声明和结构是类似的，有两个不同：
1.位段的成员必须是 int、unsigned int 或signed int 。
2.位段的成员名后边有一个冒号和一个数字。
比如：
struct A { int _a:2; int _b:5; int _c:10; int _d:30; }; A就是一个位段类型。
那位段A的大小是多少？ printf("%d\n", sizeof(struct A)); 这就不得不介绍以上的代码是什么意思了，_a后面的2表示我们只给_a 变量分配两个比特位的空间，以此类推，后面的5、10、30都是给各自变量分配了该数量的比特位的空间，这是为什么呢？为什么要给一个变量这么小的空间呢？因为有时我们发现有的变量只固定表示一些很小的数值，如_a变量，我们如果只需要它表示0-3的值，给它分配两个比特位是完全够的，所以使用位段是为了节省空间的做法，在某些变量只表示固定范围的数值时，我们就用位段限制它的空间，尽可能去节省空间，那么我们来看这个结构体的空间大小吧：
四个int类型占8个字节，平均占2个字节，在不超出数值表示范围的情况下，我们用位段省下了一半的空间。
1.2 位段的内存分配 既然位段能节省空间，我们就不得不解释位段是如何分配内存的：
1. 位段的成员可以是 int unsigned int signed int 或者是 char （属于整形家族）类型
2. 位段的空间上是按照需要以4个字节（ int ）或者1个字节（ char ）的方式来开辟的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab6b889e8513bcbee96ba7e7766e3290/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0266e9219abc88cfb126e0577007c8a/" rel="bookmark">
			[JAVASE] 异常 与 SE阶段知识点补充
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. 异常
1.1 什么是异常?
1.2 异常的本质
1.3 异常的分类 1.4 如何处理异常?
1.5 自定义异常
1.6 受查异常 与 非受查异常 与 Error(重要) 二. Object类
三. 内部类 2.1 什么是内部类?
2.2 内部类的分类
2.3 常用内部类的使用 四. 总结
一. 异常 1.1 什么是异常? 异常就是程序出现了不正常的情况.
1.2 异常的本质 异常本质上就是一个类.
1.3 异常的分类 Throwable: 所有异常 和 错误的父类. (顶格父类)
Error: 严重问题, 如栈溢出.
Exception: 异常. (运行时异常和编译时异常的父类)
RuntimeException: 运行时异常 (非受查异常).
非RuntimeException: 编译时异常 (受查异常)
1.4 如何处理异常? 处理异常5个必备关键字:
try: 代码块中写可能抛出异常的代码.
catch: 捕获特定的异常.
throw: 抛出异常.
throws: 声明异常, 表示当前方法没有处理异常, 提醒这个方法的调用者去处理异常.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0266e9219abc88cfb126e0577007c8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c598bc0f0cd29e6a6a96c1b1eb672a7b/" rel="bookmark">
			C#-if判断语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作用: 让代码执行的 顺序产生分支if语句 是第一个 可以让我们的程序 产生逻辑变化的语句
满足条件时执行的一些代码
单分支: if.... if后面跟判断条件
if (bool类型值) { 满足条件时需要执行的代码 }
双分支：if....else... if后面跟判断条件
当判断条件不满足时执行else里面的代码
用法:
if (bool类型值)
{ 满足条件时需要执行的代码
}
else
{
当条件不满足时执行
}
多分支：if.... else if ....else if后面跟判断条件
当执行完if时，继续判断执行else if。
判断条件不满足时执行else里面的代码
用法:
if (bool类型值)
{ 满足条件时需要执行的代码}
else if (bool类型值){ 满足条件时需要执行的代码 }
else { 不满足条件时需要执行的代码 }
嵌套使用 if(判断语句)
{
if (判断语句)
{
执行语句
}
}
else{
执行语句
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0d42cc265a8a60d7fbf4a52909680ce/" rel="bookmark">
			【MySQL】在CentOS7环境下----手把手教你安装MySQL详细教程(附带图例详解！！)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、安装前的环境检查
三、下载官方的 MySQL 安装包
四、开始安装 MySQL 五、尝试初次启动 MySQL
六、给MySQL 做一些简单的小配置
七、共勉
一、前言 本次专题将带大家进入一个新的专题 ---- MySQL。作为本次专题的第一篇博客，肯定是带大家一起在Linux环境下安装、配置和使用MySQL。整个过程肯定是手把手的带着大家一起完成，排除掉一切在安装过程中出现的问题，让大家有一个顺利的安装过程。
文中使用的Linux系统为 CentOS7.6版本（只要是CentOS7 就可以哦）
二、安装前的环境检查 1. 确保自己在 root 用户 下进行
作用：在 root 用户下 安装的 MySQL ,在其它普通用户下，也是可以正常使用的，不用再单独安装！ 2. 检查自己的 Linux 上有没有安装过 MySQL
（1） 首先检查 是否有 MySQL -------------- 正在运行 ps ajx | grep mysql // 检查 是否有 mysql 的进程 ps ajx | grep mariabd // 检查 是否有 mariabd 的进程 如果没有发现任何 进程存在 说明 没有MySQL 正在运行注意：mariabd 是 mysql 的一种分支，是需要检查的哦！ 如果发现 有进程在 运行 需要关闭 进程 systemctl stop mysqld // 关闭进程 （2） 首先检查 是否有 MySQL -------------- 的安装包 rpm -qa | grep mysql // 检查是否有安装包 若有安装包出现，并且我们之前没有用过 MySQL ,那就将这些安装包删除。 rpm -qa | grep mysql | xargs yum -y remove // 批量化 删除安装包 （3） 首先检查 是否有 MySQL -------------- 的残留和配置文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0d42cc265a8a60d7fbf4a52909680ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeacd63eda4847ea258a6fdc458f56d1/" rel="bookmark">
			移动设备上的深度学习：利用TensorFlow Lite、ML Kit和Flutter的高效开发实践【文末送书】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 面向移动设备的深度学习——基于TensorFlow Lite, ML Kit和FlutterTensorFlow LiteML KitFlutter 面向移动设备的深度学习——基于TensorFlow Lite,ML Kit 和Flutter【文末送书】 面向移动设备的深度学习——基于TensorFlow Lite, ML Kit和Flutter 随着智能手机的普及和移动互联网的快速发展，移动设备上的应用程序需求日益增多。深度学习作为人工智能的重要分支，在图像识别、自然语言处理和语音识别等领域取得了显著成果。然而，传统深度学习模型往往需要大量计算资源，如何在资源有限的移动设备上高效运行深度学习模型成为一个关键问题。本文将探讨如何基于TensorFlow Lite、ML Kit和Flutter来实现面向移动设备的深度学习应用。
TensorFlow Lite TensorFlow Lite是谷歌推出的一款轻量级深度学习框架，专为移动和嵌入式设备设计。它支持多种硬件加速，包括CPU、GPU和专用的AI加速芯片，使得深度学习模型在移动设备上能够以低延迟和高效率运行。
主要特点
模型转换与优化：TensorFlow Lite提供了模型转换工具，可以将标准的TensorFlow模型转换为适合移动设备的轻量级模型。这些模型经过量化和优化，显著降低了模型大小和计算复杂度。
跨平台支持：TensorFlow Lite支持Android和iOS平台，并且可以与多种编程语言和框架（如Java、Kotlin、Swift等）集成，方便开发者在不同平台上进行开发。
硬件加速：通过集成TensorFlow Lite的GPU Delegate和NNAPI，开发者可以利用设备的硬件加速器，进一步提高模型推理的速度和效率。
示例应用
通过TensorFlow Lite，可以在移动设备上实现实时图像识别、语音识别等应用。例如，利用预训练的MobileNet模型，可以开发一个实时物体检测应用，帮助用户识别摄像头中的物体。
ML Kit ML Kit是谷歌为移动开发者提供的一套机器学习工具包，集成了多种预训练模型和API，方便开发者快速在移动应用中实现复杂的机器学习功能。ML Kit支持通过Firebase提供的云端模型和本地模型运行。
主要功能
预训练模型：ML Kit内置了多种预训练模型，如文本识别、面部检测、条码扫描、图像标签等。开发者可以直接调用这些API，无需自行训练模型，极大地简化了开发流程。
自定义模型：对于有特定需求的应用，ML Kit支持加载自定义的TensorFlow Lite模型。开发者可以在TensorFlow中训练自己的模型，然后导入到ML Kit中进行推理。
跨平台支持：ML Kit同时支持Android和iOS平台，并且可以与Firebase深度集成，提供实时数据分析和云端存储等功能。
示例应用
使用ML Kit，开发者可以快速实现文本识别功能。例如，利用ML Kit的文本识别API，可以开发一个扫描名片并自动识别和保存联系人信息的应用。
Flutter Flutter是谷歌推出的一款跨平台UI框架，允许开发者使用单一代码库创建高性能的Android和iOS应用。Flutter的高效渲染引擎和丰富的插件生态，使其成为移动应用开发的理想选择。
主要特点
跨平台开发：Flutter通过单一代码库同时支持Android和iOS，减少了开发和维护的成本。开发者可以使用Dart语言编写代码，并通过Flutter的widget系统快速构建复杂的UI界面。
高性能：Flutter的渲染引擎基于Skia，能够提供原生级别的高性能体验。其热重载功能允许开发者在不重启应用的情况下快速预览UI的变化，提高了开发效率。
丰富的插件生态：Flutter拥有大量社区维护的插件，支持与各种第三方服务和库集成，包括TensorFlow Lite和ML Kit等机器学习工具。
通过Flutter，开发者可以将TensorFlow Lite或ML Kit集成到应用中，实现丰富的深度学习功能。例如，开发一个实时翻译应用，利用ML Kit的文本识别和翻译API，结合Flutter的UI构建能力，为用户提供流畅的实时翻译体验。
面向移动设备的深度学习应用开发是一项充满挑战但充满前景的任务。通过使用TensorFlow Lite、ML Kit和Flutter，开发者可以在移动设备上实现高效的深度学习模型推理，并提供丰富的用户体验。这些工具的结合不仅简化了开发流程，还提升了应用的性能和可维护性，推动了移动人工智能技术的发展。
面向移动设备的深度学习——基于TensorFlow Lite,ML Kit 和Flutter【文末送书】 深度学习正迅速成为业界最热门的话题。《面向移动设备的深度学习—基于TensorFlow Lite，ML Kit和Flutter》采用以工业和移动应用为中心的方法介绍深度学习的概念及其用例。本书将讨论一系列项目，涵盖移动视觉、面部识别、智能AI助手和增强现实等任务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aeacd63eda4847ea258a6fdc458f56d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/addfaaad1b9274f337a9d9a340a57dba/" rel="bookmark">
			一篇文章讲透排序算法之归并排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.前言 本篇文章将详细解释归并排序的原理，以及递归和非递归的代码原理。
一.概念 归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。
二.具体思想 根据上述所说，我们应当首先将序列不断分为子序列，也就是说将下面的数组分为左右两个部分，然后想办法让左数组有序，右数组有序，之后将这两个数组合并，即可让数组有序。而原数组的左右两部分又可以不断的分割为新的左右数组，那么我们就可以不断的将这个数组分割，直到左右数组内只有一个元素停止。如下图所示：
由于现在的左右数组都只有一个元素，那它们各自自然都是有序的，我们就可以将其合并，得到一个有序数组。并不断的进行这个操作，我们即可让原数组有序。以原数组的左子数组为例，我们可做出这些行为：
三.做法 现在我们已经理解了他的原理，那么我们应该怎么做呢？
方法1：递归 我们发现，它每次都是将序列分为左右两部分，然后每次都是分为两部分继续遍历，分到不可分割后，我们便不再进行分割，而是进行归并。
而我们二叉树的遍历也是一直分左右子树；而二叉树的后序遍历中则是先将左右都遍历完再进行打印的，我们会发现它们极其类似。
既然如此，我们就可以使用处理二叉树的后序遍历的递归思路来处理这个问题。
根据上述思路，我们可以写出如下代码：
void MergeSort(int* a, int begin,int end) { //递归的终止条件 if(begin&gt;=end) { return; } //分割 int mid = (begin + end) / 2; MergeSort(a, begin, mid); MergeSort(a, mid+1, end); //合并 //...... } 那么，我们下面的工作就是进行合并了。
我们发现，在合并的过程中，在原数组上操作会出现问题，因此我们需要开辟一块空间来保存合并后的数组，因此我们刚刚的函数体的参数列表则不可满足我们的需求。因此我们还应传入一个地址指向一块我们开辟的空间。
void MergeSort(int* a, int begin, int end, int* temp) { //递归的终止条件 if (begin &gt;= end) { return; } //分割 int mid = (begin + end) / 2; MergeSort(a, begin, mid, temp); MergeSort(a, mid+1,end, temp); //合并 } 我们写出的函数是想要拿来就可以直接用的，而不是还需要做一些准备工作才能用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/addfaaad1b9274f337a9d9a340a57dba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9acbf982e30e667321a095e9fd9501d4/" rel="bookmark">
			Floyd判圈算法 leetcode
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		龟兔赛跑 / Floyd判圈算法应用 判断一个链表是否存在环画图演示两个指针相遇的情况:力扣141. 环形链表I 题解 ( C ) 查找链表中环的首个节点在这里插入图片描述数学公式表示为:力扣142. 环形链表II 题解 (c++) (对应力扣142. 环形链表 II,141. 环形链表 I)
判断一个链表是否存在环 龟兔赛跑 / Floyd判圈算法 转换成判断链表是否存在 “环” 的问题可以总结以下三点:
定义两个指针，初始时都指向链表的头节点。两个指针以不同速度移动(一个快一个慢).如果链表中存在环，快指针和慢指针最终会相遇（指向同一个节点），否则快指针或快指针的下一个节点会到达链表的末尾（指向NULL）。 满足这三个条件之后,只要链表存在"环",那么快指针和慢指针一定会相遇(指向同一处节点即为相遇),并且被两个指针所指向的这个节点一定是在链表中的"环"的起点以及"环"的起点之后中的位置!
注释 :可能有人会疑问：快指针有可能会跳过慢指针，以致两个指针不会相遇(指向同一个节点)。这种情况确实存在.
但在实际操作中（判断链表是否存在环），我们通常定义快指针每次移动两个节点，慢指针每次移动一个节点。这样，即使快指针会跳过某些节点，慢指针会遍历到所有节点，最终快指针和慢指针一定会在某处相遇。
画图演示两个指针相遇的情况: 快指针为蓝色三角形慢指针为紫色三角形 //p 为慢指针, q 为快指针 while(q != NULL &amp;&amp; q-&gt;next!=NULL){ p = p-&gt;next; q = q-&gt;next-&gt;next; if(p == q) { //后续操作处理..... } } 开始两个指针都指向头节点(head)
后面每一次循环,快指针移动两个距离,慢指针移动一个距离
循环继续
到这里两个指针指向的节点相同,就可以做后续的处理了
力扣141. 环形链表I 题解 ( C ) bool hasCycle(struct ListNode *head) { struct ListNode *p = head,*q = head; while(q &amp;&amp; q-&gt;next){ //不为空 p = p-&gt;next; q = q-&gt;next-&gt;next; if(p == q) return true; } return false; } 查找链表中环的首个节点 我们可以通过上面的方法判断链表中是否存在环
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9acbf982e30e667321a095e9fd9501d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78ce5c474359b721e8c71729140f1b21/" rel="bookmark">
			AIGC降重：学姐教你如何免费检测并降低AIGC率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		确保学术论文的独立性与诚信性，对于学业的成就及学位的获取至关重要，其中，论文的人工智能查重与降低AIGC相似度扮演着核心角色。
常规的查重手段主要围绕查重软件的运用和个体的自行审查；而降重则通常通过语句重组、同义替换、内容丰富化以及精准引注等手段来提升文章的独创性。
但这些传统方法往往效率低下、劳动强度大，且难以确保达到预期的降重成效。在这种背景下，我们自然会思考：能否借助人工智能工具实现高效降重？
下面我将分享一款免费检测AIGC的工具，Master Al率检测系统，这款工具的检测严格程度比相较于知网、维普等众多检测工具有过之而不及，非常适合初稿使用，关键是从弹窗中扫码领取免费券后，每个人可以免费检测一次，这个羊毛不薅白不薅！
论文AIGC率检测: pass.checkvip.top 如果检测的AIGC率很高怎么办，没事！教你手动降AIGC方法。
对抗性生成网络：利用对抗性生成网络（GAN）进行AIGC生成，通过不断迭代和优化，生成对抗检测的内容。GAN可以生成具有高度逼真度和多样性的内容，从而降低被检测出的风险。
迁移学习：利用迁移学习技术，将其他领域的生成模型应用于AIGC生成。通过迁移学习，可以利用已有模型的知识和经验，提高生成内容的质量和多样性。
自适应生成：根据检测算法的变化和更新，自适应地调整生成策略，以应对不断变化的检测环境。这需要建立一个反馈机制，实时监测生成内容的检测情况，并根据反馈信息进行相应的调整。
如果还是降不下来，那就试一试专业的AIGC去痕工具吧，用魔法打败魔法！这里给大家推荐早降重智能降AIGC去痕工具，关键是又有羊毛可薅！
一样的从弹窗中扫码领取免费券，然后就可以在2000字以内免费降AIGC啦！
论文降AIGC: check.checkvip.top 祝大家毕业顺利！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d024c4a86f222679ab70f3c971cc4961/" rel="bookmark">
			【C&#43;&#43;】STL：栈和队列模拟实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💞💞 前言 hello hello~ ，这里是大耳朵土土垚~💖💖 ，欢迎大家点赞🥳🥳关注💥💥收藏🌹🌹🌹
💥个人主页：大耳朵土土垚的博客
💥 所属专栏：C++入门至进阶
这里将会不定期更新有关C++的内容，希望大家多多点赞关注收藏💖💖
目录 💞💞 前言1.stack和queue简介2.stack模拟实现✨stack实现代码✨stack测试代码 3.queue模拟实现✨queue实现代码✨queue测试代码 4.结语 1.stack和queue简介 C++中的stack（栈）和queue（队列）是两种常见的数据结构，用于存储和管理数据。
栈是一种先进后出（LIFO）的数据结构，类似于我们平时堆叠的一摞书，只能在顶部进行操作。在C++中，可以使用std::stack模板类来创建栈。栈的主要操作包括压入（push）元素到栈顶、弹出（pop）栈顶元素以及获取栈顶元素等。
队列是一种先进先出（FIFO）的数据结构，类似于排队等候的人群，新元素插入队尾，最早插入的元素在队头。在C++中，可以使用std::queue模板类来创建队列。队列的主要操作包括插入（push）元素到队尾、删除（pop）队头元素以及获取队头元素等。
如下图所示：
stack和queue都有自己的特点和适用场景。栈常用于实现递归算法、表达式求值和括号匹配等问题，而队列常用于实现广度优先搜索（BFS）算法、任务调度和缓冲区管理等问题。
在C++中，stack和queue都是基于deque（双端队列）实现的，默认使用deque容器作为底层数据结构。此外，C++还提供了其他数据结构，如priority_queue（优先队列）和deque（双端队列），可以根据具体需求选择合适的数据结构来解决问题。
2.stack模拟实现 stack函数作用push尾插（栈顶入栈）pop尾删（栈顶出栈）top获取栈顶元素(也就是尾部元素)const top给const对象使用size栈中元素个数empty判断栈是否为空 stack模拟实现我们就可以使用之前学习过的vector或者list容器来实现，可以创建一个类模板，除了数据的类型可以改变，其使用的容器也可以改变，代码如下：
template&lt;class T, class Con = deque&lt;T&gt;&gt; 这样我们只需要传入数据类型以及使用的容器类型就可以确定stack是使用什么容器来实现存储和管理数据了🥳🥳，默认传入的是deque容器(给的是缺省值)
deque（双端队列）是C++标准库中的一种容器，它可以在两端进行插入和删除操作。deque的全称是double-ended queue，它融合了向量（vector）和双向链表（doubly linked list）的特性。
使用deque记得包含头文件#include&lt;deque&gt;
✨stack实现代码 #pragma once using namespace std; #include&lt;iostream&gt; #include&lt;deque&gt; #include&lt;vector&gt; namespace tutu_stack { template&lt;class T, class Con = deque&lt;T&gt;&gt; class stack { public: stack() { //使用自定义类型默认的构造函数即可 } //尾插 void push(const T&amp; x) { _c.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d024c4a86f222679ab70f3c971cc4961/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/307/">«</a>
	<span class="pagination__item pagination__item--current">308/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/309/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>