<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/310a052273fc86cf41bc202c198dec21/" rel="bookmark">
			深度学习疆界：探索基本原理与算法，揭秘应用力量，展望未来发展与智能交互的新纪元
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是深度学习
深度学习的基本原理和算法
深度学习的应用实例
深度学习的挑战和未来发展方向
挑战
未来发展方向
深度学习与机器学习的关系
深度学习与人类的智能交互
什么是深度学习 深度学习是一种基于神经网络的机器学习方法，旨在模仿人类大脑分析和学习数据的方式。
深度学习的核心在于能够自动学习和提取数据中的复杂特征，它通过构建深层的神经网络结构来实现对数据的高层次抽象和理解。这种方法在图像识别、语音识别、自然语言处理等领域取得了显著的成果。以下是关于深度学习的详细介绍：
基本原理：深度学习模型通常由多个隐藏层组成，每个隐藏层都负责从输入数据中提取不同层次的特征。这些特征随后被用于分类、回归或其他机器学习任务。
技术方法：深度学习中使用的技术包括但不限于卷积神经网络（CNN）、循环神经网络（RNN）、长短期记忆网络（LSTM）和生成对抗网络（GAN）。
应用范围：深度学习已广泛应用于多个领域，如医疗诊断、自动驾驶汽车、语音助手、机器翻译和游戏AI等。
发展趋势：随着计算能力的提升和数据量的增加，深度学习模型变得更加复杂和强大，其性能也在不断提高。
与其他关系：深度学习是机器学习的一个子集，而机器学习又是人工智能的一个分支。深度学习与传统机器学习的主要区别在于它能自动提取特征，而不需要人工设计特征。
挑战与未来：尽管深度学习在很多方面取得了成功，但它也面临着一些挑战，如对大量标注数据的依赖、模型的可解释性问题以及计算资源的需求。未来的研究可能会集中在提高模型的泛化能力、减少对数据的依赖以及提高模型的可解释性等方面。
总的来说，深度学习是一种强大的机器学习方法，它通过模拟人类大脑的学习过程，使计算机能够处理和理解复杂的数据。随着技术的不断进步，深度学习有望在未来解决更多复杂的问题，并在人工智能领域发挥更大的作用。
深度学习的基本原理和算法 深度学习的基本原理和算法涉及多个关键概念和技术，这些构成了深度学习的核心。以下是一些详细的说明：
反向传播（Backpropagation）：
原理：这是一种优化算法，用于神经网络中权重的迭代更新。
过程：它首先计算损失函数（例如交叉熵损失）关于每个权重的梯度，然后通过梯度下降更新网络中的权重以最小化损失函数。
重要性：反向传播是监督学习中训练深度神经网络的标准方法。
卷积神经网络（Convolutional Neural Networks, CNN）：
特点：CNN 包含卷积层、池化层和全连接层，特别适合处理具有网格结构的数据，如图像。
应用：图像分类、目标检测、图像分割等。
优势：能够捕捉局部特征并通过共享权重减少模型复杂性。
循环神经网络（Recurrent Neural Networks, RNN）：
设计：RNN 具有循环连接，允许信息在序列的时间步之间持续传递。
适用性：非常适合处理序列数据，如时间序列分析、自然语言处理等。
挑战：长期依赖问题，即网络难以学习到长距离的依赖关系。
长短期记忆网络（Long Short-Term Memory, LSTM）：
创新：LSTM 是 RNN 的一种改进，通过引入门控机制来解决长期依赖问题。
结构：包含输入门、遗忘门和输出门，这些门控制信息的存储、更新和读取。
应用：广泛应用于复杂的序列任务，如机器翻译、语音识别等。
生成对抗网络（Generative Adversarial Networks, GAN）：
概念：由一个生成器和一个判别器组成，它们在训练过程中相互竞争。
目的：生成器试图生成逼真的假数据，而判别器试图区分真实数据和生成数据。
应用：图像生成、数据增强、风格迁移等。
除了上述算法，深度学习还包括其他重要的概念和技术，如激活函数（如ReLU、Sigmoid、Tanh）、正则化方法（如Dropout、L2正则化）、优化器（如Adam、SGD）、注意力机制、transformer模型等。这些构建块共同推动了深度学习的发展，使其在多个领域取得了突破性的进展。
深度学习的应用实例 深度学习的应用实例非常广泛，涉及许多行业和领域。以下是一些具体的应用示例，展示了深度学习如何在不同领域中发挥作用：
自然语言处理（NLP）：
机器翻译：使用序列到序列（seq2seq）模型和注意力机制，深度学习能够实现高质量的文本翻译，如Google Translate。
情感分析：通过分析用户评论或社交媒体帖子中的文本，深度学习模型可以预测用户的情感倾向，广泛应用于市场分析和品牌监控。
聊天机器人和智能助手：利用RNN、LSTM和Transformer等模型，可以实现流畅的对话系统，如Siri、Google Assistant和Amazon Alexa。
计算机视觉：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/310a052273fc86cf41bc202c198dec21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a1d8542f8083d5e45f9507ea9abd8fb/" rel="bookmark">
			C&#43;&#43;字符串的常用操作函数全总结（包含c）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.string、string.h和cstring的区别2.字符串定义3.求长度size()或length()4.输入字符串（四种）5.分割截取substr()4.查找指定子字符串find()5.替换字符串中的一部分replace()6.在指定位置插入字符串insert()7.复制字符串(两种方法)8.排序sort()9.删除erase()10.在字符串中添加字符push_bach()以下是C语言中字符串的操作函数:C中字符数组操作函数在C++中使用的操作方法（1）复制字符串strcpy()（2）连接字符串strcat()（3）返回字符串长度strlen()（4）比较字符串strcmp()（5）查找字符strstr() 2024.2.4最新更新
→ 10.在字符串中添加字符
1.string、string.h和cstring的区别 #include &lt;string.h&gt; string.h是c语言的库，用于处理char *类型的字符串。
#include &lt;string&gt; string是C++标准库的一个重要的部分-类，主要用于字符串处理。
可以使用输入输出流方式直接进行操作，也可以通过文件等手段进行操作。
#include &lt;cstring&gt; cstring兼容了过去string.h的函数，但是采用了c++的写法。
2.字符串定义 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() { string str;//定义字符串变量 char s1[100];//定义字符数组 } 3.求长度size()或length() str.length(); str.size(); length()函数返回字符串的长度. 和size()返回的数字相同.
4.输入字符串（四种） string str; getline(cin,str);//可以读入一行字符串，可以包含空格，遇到回车结束 char str[100];//输入字符数组 cin.getline(str,sizeof(str));//需要提前固定好输入的字符串的长度，避免输入的字符超出界限 string str; cin&gt;&gt;str;//可以读入一连串的字符，遇到空格或换行（回车）结束 string str; scanf("%s",&amp;str);//遇到空格结束（C++中不推荐使用） 5.分割截取substr() str.substr(7,3); // 从下标7开始截取子字符串，截取长度为3的字符串 4.查找指定子字符串find() 在字符串中查找指定子字符串,并返回其第一次出现的位置
size_t pos = str.find("World"); // 查找子字符串"World"的位置 5.替换字符串中的一部分replace() str.replace(7, 5, "Universe"); // 替换从下标7开始的5个字符为"Universe" 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a1d8542f8083d5e45f9507ea9abd8fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58b9d9cc9d58701ac9cc549be6f4392a/" rel="bookmark">
			详解tomcat中的jmx监控
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.概述
2.如何开启tomcat的JMX
3.tomcat如何实现JMX的源码分析
1.概述 本文是博主JAVA监控技术系列文章的第二篇，前面一篇文章中我们介绍了JAVA监控技术的基石——jmx：
【JMX】JAVA监控的基石-CSDN博客
本文我们将从使用和源码实现两个方面聊一下jmx的落地实现范例——tomcat中的jmx。
tomcat作为一个web server，其选用jmx来实现监控功能。之所以选择jmx是因为jmx是java se原生的能力，不需要第三方依赖，在web server这种基础组件中，选用原生的技术可以避免很多三方依赖带来的不便。
2.如何开启tomcat的JMX jmx是由JVM来支持实现的标准，所以开启jmx本质上就是通过配置启动参数的方式来实现的，例如，以下是一个简单的 Java 命令，启用了 JMX 监听，并配置了 JMX 服务器的地址和端口：
java -Dcom.sun.management.jmxremote \
-Dcom.sun.management.jmxremote.port=9999 \
-Dcom.sun.management.jmxremote.authenticate=false \
-Dcom.sun.management.jmxremote.ssl=false \
-jar myapplication.jar
tomcat本质也是个Java程序，所以也是通过配置启动参数来开启jmx的。本文是基于Windows环境来配置的，Linux环境其实也大差不差。配置Catalina.bat，在Execute The Requested Command下面加上下面的配置：
set JAVA_OPTS=%JAVA_OPTS% -Djava.rmi.server.hostname=192.168.56.1 -Dcom.sun.management.jmxremote.port=9999 -Dcom.sun.management.jmxremote.rmi.port=9999 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false
然后启动tomcat，打开jconsole：
连接上我们启动的这个tomcat，MBean列表里面可以看到tomcat的所有MBean，对tomcat源码熟悉的读者会发现，tomcat的核心组件都以MBean的方式被注册进JMX Server中了。
3.tomcat如何实现JMX的源码分析 首先博主去github上下载了tomcat7.0.105版本的源码。前面我们聊过jmx，要使用jmx，就要先注册相关的MBean。tomcat里面有一个jmxEnabled接口，这个接口就是用来实现MBean的注册的。它定义了两个方法，一个用来注册MBean，一个用来卸载MBean。
这个接口的实现类是LifecycleMBeanBase，这个类里实现了注册和卸载MBean的方法。对tomcat源码有了解的读者对这个类会很熟悉（当然不了解也别怕），LifecycleMBeanBase这个类是tomcat中用来管理各个组件的生命周期的，也就是说这个组件里会实现一些在各个组件初始化或者销毁的时候要做的额外动作。
来我们好好读一下这里的源码：
protected void initInternal() throws LifecycleException { // If oname is not null then registration has already happened via // preRegister(). if (oname == null) { 获取MBeanServer mserver = Registry.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58b9d9cc9d58701ac9cc549be6f4392a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a1079250a669ad0aefae8111f9d0385/" rel="bookmark">
			夸克AI写作神器，轻松搞定各种文章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		夸克AI写作文笔细腻优美，作为人工智能写作工具的代表，能满足用户对于测评对比风格的需求。接下来，我会从多个方面深入浅出地介绍并评价此产品。
1.界面简洁直观
夸克AI的写作界面设计简洁明了，用户能轻易地上手使用。左方为编辑区，右方为预览区，便捷性极强。
2.功能强大多样
夸克AI写作工具拥有许多实用功能，可自动生成段落，快速分析关键词，并进行语法检测等。无论您在写新闻稿件，还是学术论文，都能得到满意的结果。
3.文字优化精准
夸克AI的文本优化功能极为出色，可自动调整句式与词汇搭配，使文章阅读起来更为流畅；同时能防止重复用词。
4.内容生成快速高效
夸克AI写稿，运用智能算法及大规模数据分析，迅速且精准地创作出高品质文字。无论长短文章，总能在短暂时间中呈现。
5.文风多样自由切换
夸克AI写作功能支持多款文风切换（如新闻报道、散文随笔、科技领域），让您根据自身需求选择适合的文章表达形式，使之更趋丰富多样。
6.语法纠错准确可靠
夸克AI的语法纠错功能准确无误，能助您及时找出并修正文中语法问题，令文章品质更上一层楼。
7.数据安全可靠
请放心，我们的夸克AI文章编辑器，会严格保护您的所有数据安全。先进的加密技术和严密的安全措施已全面投入使用，以确保护航您的个人信息隐私安全无虞。
8.反馈及时响应
尊敬的用户们，感谢您对夸克AI写作团队提出的宝贵意见和问题，我方将全力以赴，尽可能快地为您解决问题或改善我们的服务质量。
9.价格合理实惠
我们的夸克AI文章创作服务提供多种价格选项，用户可按需决定最合适的订阅方案哦！无论是个人玩家还是群体用户，都能以合理优惠的价格享受优质服务。
总的来说，夸克AI写文章真是个强大且易用的人工智能写作工具呢！无论您是新手写作者还是专业撰稿人，不论是从界面美观程度还是功能实用性来看，它都展现出优秀的性能以及卓越的用户满意度。如果您想提高自身的写作水平与效率，不妨去试试这款来自夸克的写作神器吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f1d342d484bf77685486617da43f0d2/" rel="bookmark">
			JavaScript中的querySelector()方法是什么，它是如何工作的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在JavaScript中，有时您需要访问HTML元素。querySelector方法是一个Web API，它选择与传入的指定CSS选择器匹配的第一个元素。
但是，更详细地说，这是如何工作的呢？在本文中，我们将看一些如何使用querySelector方法以及querySelectorAll方法的示例。
（本文内容参考：java567.com）
querySelector()方法的基本语法 querySelector方法在document对象上调用，并接受一个参数，表示要选择的元素的CSS选择器。
document.querySelector(selector); 如果选择器在文档中匹配到一个元素，则该方法将返回第一个匹配的元素。如果没有匹配项，则该方法将返回null。
如何使用querySelector()方法与类型选择器 CSS中的类型选择器是指HTML元素的名称。例如，button、div、p等。
在第一个示例中，我们在HTML文档中有一个button元素。
&lt;button&gt;Show Alert&lt;/button&gt; 如果我们想在JavaScript文件中访问该元素，我们可以像这样使用querySelector方法：
const buttonElement = document.querySelector("button"); 这行代码选择页面上看到的第一个按钮，并将结果赋给一个名为buttonElement的const变量。
如果我们将这个buttonElement变量记录到控制台，输出将会是：
console.log(buttonElement); 我们可以使用buttonElement变量，并为按钮添加事件监听器，以便在单击按钮时显示警报。
buttonElement.addEventListener("click", () =&gt; { alert("Button was clicked!"); }); 这是完整的代码和交互示例。
如何使用querySelector()方法与类选择器 CSS中的类选择器是指用于HTML元素的类名。例如.container、.button等。
假设我们想要构建一个纸牌游戏，并且希望在单击按钮时隐藏/显示游戏规则。我们可以使用querySelector方法选择按钮和规则容器。
这是初始HTML：
&lt;h1&gt;Let's play solitaire!&lt;/h1&gt; &lt;main&gt; &lt;button class="rules-btn"&gt;Show Rules&lt;/button&gt; &lt;section class="rules-container"&gt; &lt;h2&gt;Rules to the game&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;There are 7 columns of cards&lt;/li&gt; &lt;li&gt;First column has 1 card, second has 2, third has 3, and so on&lt;/li&gt; &lt;li&gt;First card in each column is face up, rest are face down&lt;/li&gt; &lt;li&gt;Move cards to build 4 stacks of cards in ascending order&lt;/li&gt; &lt;li&gt;Start with aces and build up to kings&lt;/li&gt; &lt;li&gt;Move cards by dragging and dropping&lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;/main&gt; 在JavaScript文件中，我们可以使用querySelector方法选择规则按钮和规则容器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f1d342d484bf77685486617da43f0d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5c1ce62a3ffa376b92689a94aaf2456/" rel="bookmark">
			如何使用 Python 通过代码创建图表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 Diagram as Code 工具允许您创建基础架构的架构图。您可以重复使用代码、测试、集成和自动化绘制图表的过程，这将使您能够将文档视为代码，并构建用于映射基础架构的流水线。您可以使用 diagrams 脚本与许多云提供商和自定义基础架构。
在本教程中，您将使用 Python 创建一个基本的图表，并将其上传到对象存储桶。完成后，您将了解 diagrams 脚本的工作原理，从而能够创建新的集成。
步骤 1 — 安装 Graphviz 在这一步中，您将安装 Graphviz 工具。Graphviz 是 diagrams 模块的引擎，它生成图表本身。
首先，更新服务器的软件包：
sudo apt update 然后，使用以下命令安装 Graphviz：
sudo apt install -y graphviz -y 选项会自动回答安装过程中的任何额外提示。您也可以下载其他发行版的 Graphviz。
安装完成后，您将拥有安装的 Graphviz。
因为您将在本教程后面使用 Pip3 安装 Python 依赖项，您可以检查您是否有正确的版本：
pip3 --version 您应该会看到类似以下的内容：
pip 20.0.2 from /usr/lib/python3/dist-packages/pip (python 3.8) 在这一步中，您更新了服务器，安装了 Graphviz，并检查了 Pip 的版本。接下来，您将构建 diagrams 脚本。
步骤 2 — 构建 Python 脚本 在这一步中，您将在 Python 中编写一个示例图表脚本。
首先，创建一个工作文件夹：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5c1ce62a3ffa376b92689a94aaf2456/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a67d9e97bd48f653096a1c84b1fb6fa/" rel="bookmark">
			文心一言4.0 VS ChatGPT4.0哪家强？！每月60块的文心一言4.0值得开吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是木易，一个持续关注AI领域的互联网技术产品经理，国内Top2本科，美国Top10 CS研究生，MBA。我坚信AI是普通人变强的“外挂”，所以创建了“AI信息Gap”这个公众号，专注于分享AI全维度知识，包括但不限于AI科普，AI工具测评，AI效率提升，AI行业洞察。关注我，AI之路不迷路，2024我们一起变强。
一些结论 综合结论：ChatGPT4.0 &gt; 文心一言4.0 &gt;= ChatGPT3.5 &gt; 文心一言3.5。ChatGPT4.0表现地一如既往的稳。根据测试结果，文心一言4.0比文心3.5的逻辑推理能力有了较大幅度的提升，甚至在解释的详细程度上，已经超过了ChatGPT3.5。
逻辑测试一：ChatGPT4.0 &gt; ChatGPT3.5 &gt; 文心一言4.0 = 文心一言3.5
逻辑测试二：ChatGPT4.0 &gt; 文心一言4.0 &gt;= ChatGPT3.5 &gt; 文心一言3.5
文心一言4.0连续包月40元/月，非连续包月60元/月，年付会便宜一点。ChatGPT Plus会员20美元/月，折合人民币约140元/月，暂无年费优惠。
文心一言4.0使用数量限制为100条/3小时。ChatGPT4.0是40条/3小时。
文心一言4.0 VS ChatGPT Plus横向对比 文心一言4.0价格 文心一言4.0使用数量限制 文心一言4.0 VS 文心一言3.5（官方宣传版） 文心一言4.0会员专属插件 ChatGPT Plus价格 翻译为中文：
ChatGPT Plus使用数量限制 逻辑测试一 提示词：有三名囚犯A、B、C被告知他们将被分别戴上红色或蓝色的帽子，这三个帽子中包含两种颜色，即可能是两红一蓝或两蓝一红。囚犯们按照A、B、C的顺序站成一列，A站在最前面，看不见任何人的帽子；B站在中间，只能看见A的帽子；C站在最后，能看见A和B的帽子。如果他们中的任何一个能够确切地知道自己的帽子颜色，他就可以获得自由。在他们都足够聪明的情况下，谁最先能够确定自己帽子的颜色并如何做到？
文心一言4.0的回答： 根据题意，已知：
有三名囚犯A、B、C，他们被安排戴上红色或蓝色的帽子。
共有三顶帽子，可能是两红一蓝或两蓝一红。
A站在最前面，看不见任何人的帽子；B站在中间，只能看见A的帽子；C站在最后，能看见A和B的帽子。
如果任何一个囚犯能够确切地知道自己的帽子颜色，他就可以获得自由。
从A的角度分析： A看不见任何人的帽子，无法直接判断自己的帽子颜色。由于存在两种可能的帽子组合（两红一蓝或两蓝一红），A不能确定自己戴的是哪种颜色的帽子。
从B的角度分析： B只能看见A的帽子。如果A戴的是红色帽子，B无法确定自己的帽子颜色，因为可能存在两红一蓝或两蓝一红的情况。同样，如果A戴的是蓝色帽子，B也无法确定自己的帽子颜色。
从C的角度分析： C能看见A和B的帽子。如果C看到A和B都戴的是同一种颜色的帽子（两红或两蓝），那么C可以迅速判断出自己戴的是另一种颜色的帽子，从而获得自由。
然而，问题中并没有明确A和B是否都戴同一种颜色的帽子，因此C无法直接确定自己的帽子颜色。
综合以上分析，根据已知条件，三名囚犯都无法确定自己的帽子颜色。因此，在这个特定的问题设定下，没有人能够最先确定自己帽子的颜色并获得自由。题目描述中可能存在一些逻辑上的不完整或错误，导致无法得出确定的答案。
请注意，这个问题不同于常见的帽子谜题，通常那些谜题中会有额外的信息（如帽子的数量、颜色分布等）来帮助囚犯做出判断。在这个问题中，缺乏这样的额外信息，导致无法确定任何人的帽子颜色。
文心一言3.5的回答： 根据题意，已知：
有三名囚犯A、B、C。
他们将被戴上三顶红或蓝色的帽子，帽子的颜色组合是两红一蓝或两蓝一红。
A站在最前面，看不见任何人的帽子；B站在中间，只能看见A的帽子；C站在最后，能看见A和B的帽子。
任何一个囚犯如果能确定自己的帽子颜色，他就能获得自由。
首先考虑A，A看不见任何人的帽子，所以A无法直接确定自己的帽子颜色。
接着考虑B，B只能看见A的帽子。但由于B不知道C的帽子颜色，所以B也不能确定自己的帽子颜色。例如，如果B看到A戴红帽，B无法确定自己是戴红帽还是蓝帽，因为可能是两红一蓝或两蓝一红。
最后考虑C，C能看见A和B的帽子。对于C来说，存在以下可能的情况：
如果C看到A和B都戴红帽，那么C可以确定自己戴的是蓝帽，因为帽子的颜色组合中不可能有三个红帽。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a67d9e97bd48f653096a1c84b1fb6fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a08fe73a9a874f3913bd9c9d76014648/" rel="bookmark">
			【AI大模型应用开发】0.1 百度文心一言 API接入详细步骤和简单应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是【同学小张】。持续学习，持续干货输出，关注我，跟我一起学AI大模型技能。
最近我的OpenAI的API key由于调用次数太多被封了… 不知道下个月能不能解封。而为了尽可能地不花钱，先来看下国内的大模型API怎么用。
本文是 百度文心一言API的使用。
文章目录 0. 接入流程1. 注册百度千帆账号，创建应用2. 获取Access Token3. 调用文心大模型接口4. API在线调试5. 其它 0. 接入流程 整体流程图如下：
1. 注册百度千帆账号，创建应用 （1）首先注册千帆账号并登录千帆平台
官网地址：https://console.bce.baidu.com/qianfan/ais/console/applicationConsole/application
（2）根据实际需求创建千帆应用，创建成功后，获取AppID、API Key、Secret Key 等信息。如果已有千帆应用，可以查看已有应用的API Key、Secret Key 等信息。
2. 获取Access Token （1）将百度千帆的API Key和Secret Key放到环境变量中，加载
BAIDU_QIANFAN_CLINE_AK = "xxxxx" BAIDU_QIANFAN_CLINE_SK = "xxxxx" （2）获取Access Token的Python代码
import requests import json import os # 加载 .env 到环境变量 from dotenv import load_dotenv, find_dotenv _ = load_dotenv(find_dotenv()) client_id = os.getenv('BAIDU_QIANFAN_CLINE_AK') # 设置百度千帆AK: API Key client_secret = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a08fe73a9a874f3913bd9c9d76014648/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24e483cb92ef5db75a0bfe9f19f8c0f2/" rel="bookmark">
			Android studio报错：Can‘t determine type for tag ‘＜macro name=“m3_comp_assist_chip_container_shape“＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错信息：
Can't determine type for tag '&lt;macro name="m3_comp_assist_chip_container_shape"&gt;?attr/shapeAppearanceCornerSmall&lt;/macro&gt;' new的新project默认的build.gradle：
plugins { id 'com.android.application' } android { compileSdkVersion 34 buildToolsVersion "34.0.0" defaultConfig { applicationId "com.anxko.backend.app" minSdkVersion 24 targetSdkVersion 34 versionCode 1 versionName "1.0" testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner" } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' } } compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } } dependencies { implementation 'androidx.appcompat:appcompat:1.6.1' implementation 'com.google.android.material:material:1.11.0' implementation 'androidx.constraintlayout:constraintlayout:2.1.4' testImplementation 'junit:junit:4.+' androidTestImplementation 'androidx.test.ext:junit:1.1.5' androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1' } 网上查找了一下解决方案有两种：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24e483cb92ef5db75a0bfe9f19f8c0f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ea70f453f2072f8fc0bfb718c02ff88/" rel="bookmark">
			Stable Diffusion之最全详解图解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Stable Diffusion之最全详解图解 1. Stable Diffusion介绍1.1 研究背景1.2 学术名词 2.Stable Diffusion原理解析2.1 技术架构2.2 原理介绍扩散过程 3.1 Diffusion前向过程3.2 Diffusion逆向（推断）过程 1. Stable Diffusion介绍 Stable Diffusion是2022年发布的深度学习文本到图像生成模型。它主要用于根据文本的描述产生详细图像，尽管它也可以应用于其他任务，如内补绘制、外补绘制，以及在提示词指导下产生图生图的转变。
它是一种潜在扩散模型，由慕尼黑大学的CompVis研究团体开发的各种生成性人工神经网络之一。它是由初创公司StabilityAI、CompVis与Runway合作开发，并得到EleutherAI和LAION的支持。 截至2022年10月，StabilityAI筹集了1.01亿美元的资金。
Stable Diffusion的源代码和模型权重已分别公开发布在GitHub和Hugging Face，可以在大多数配备有适度GPU的电脑硬件上运行。而以前的专有文生图模型（如DALL-E和Midjourney）只能通过云计算服务访问。
1.1 研究背景 AI 绘画作为 AIGC（人工智能创作内容）的一个应用方向，它绝对是 2022 年以来 AI 领域最热门的话题之一。AI 绘画凭借着其独特创意和便捷创作工具迅速走红，广受关注。举两个简单例子，左边是利用 controlnet 新魔法把一张四个闺蜜在沙滩边上的普通合影照改成唯美动漫风，右边是 midjourney v5 最新版本解锁的逆天神技， 只需输入文字“旧厂街风格，带着浓浓 90 年代氛围感”即可由 AI 一键生成超逼真图片！
Stable Diffusion，是一个 2022 年发布的文本到图像潜在扩散模型，由 CompVis、Stability AI 和 LAION 的研究人员创建的。要提到的是，Stable Diffusion 技术提出者 StabilityAI 公司在 2022 年 10 月完成了 1.01 亿美元的融资，估值目前已经超过 10 亿美元。
1.2 学术名词 学术名词相关解释Diffusion Model扩散模型，一款支持文本生成图像的算法模型，目前市面上主流的 DALL E、Midjourney、Stable Diffusion 等 AI 绘画工具都是基于此底层模型开发的Latent Diffusion Model即潜在扩散模型，基于上面扩散模型基础上研制出的更高级模型，升级点在于图像图形生成速度更快，而且对计算资源和内存消耗需求更低Stable Diffusion简称SD模型，其底层模型就是上面的潜在扩散模型，之所以叫这个名字是因为其研发公司名叫Stability AI，相当于品牌冠名了Stable Diffusion Web Ul简称SD WebUI，用于操作上面Stable Diffusion模型的网页端界面，通过该操作系统就能控制模型出图，而无需学习代码 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ea70f453f2072f8fc0bfb718c02ff88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/876b003b6373d3d13cbbec07c6aacd96/" rel="bookmark">
			【Android】使用Android Studio打包APK文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 新建项目2. 打包生成APK3. 安装APK 1. 新建项目 打包APK之前，首先需要新建项目，有基础的可以跳过。
无基础的可以参考：使用Android Studio运行Hello World项目
2. 打包生成APK 1.找到Build -&gt; Generate Signed Bundle or APK -&gt; 勾选APK
2.首次需要创建证书，后续可以使用已创建好的证书
3.填写证书信息
选择密钥库存放路径，并填写密码填写密钥名称、密码和有效期填写证书信息（选填，不用全部填写） 为了方便，此处我的密码都填写为123456
4.填写刚刚的密钥库密码和密钥密码，并勾选记住密码
5.选择release版本，点击create创建APK文件
debug版本和release版本的区别：debug版本主要用于开发过程中的调试和测试，而release版本则用于最终用户的使用。
debug版本（调试版本）：
主要用于开发过程中的调试和测试。包含完整的调试信息，允许开发者在程序上设置断点、单步执行以及使用TRACE/ASSERT等调试输出语句。不进行代码优化，以便为开发者提供强大的调试能力。相对于Release版本，Debug版本通常更大，并且运行速度较慢。开发者在Debug模式下可以更容易地发现和修复程序中的错误和问题。 release版本（发布版本）：
主要用于最终用户的使用。不包含任何调试信息，以减小程序的大小并提高运行效率。进行了各种优化，包括代码最小化和速度优化，以提供最佳的用户体验。Release版本不包含Debug版本中的调试功能，如设置断点或单步执行。相对于Debug版本，Release版本通常更小、更快，并且更稳定。 6.APK存放路径：
切换左上角的 Android 为 Project，此时可以发现app项目下多了个release文件夹，文件夹下有apk文件点击该apk文件，右键 Open In -&gt; Explorer，就能打开到该apk所在的文件夹 3. 安装APK 1.下载夜神模拟器：https://www.yeshen.com/
2.下载完成后得到文件 nox_setup_v7.0.3.5_full.exe，双击安装
3.夜神模拟器默认是平板机型，点击右上角设置图标，可以修改设置，调整机型和分辨率
4.将刚刚打包好的apk拖到夜神模拟器中：E:\workspace\MyApplication\app\release\app-release.apk
5.此时相当于将apk装到了手机里，点击该应用，打开即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de2d37b031f9c468516315f5d1535bd4/" rel="bookmark">
			Redis的三种限流方法以及代码详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、为什么我们选择使用Redis来实现限流机制？二、限流实战方案1.令牌桶算法策略2.漏桶算法策略3.Redis计数器策略 总结 前言 在当今互联网时代，随着用户数量和请求量的急剧增加，保护系统的稳定性和可用性变得尤为重要。对于一些关键业务接口或资源，我们需要对访问进行限制，以防止恶意攻击、滥用或过度消耗资源。这就引入了限流机制，即控制请求的速率，确保系统能够按照预期的方式运行。
Redis作为一个高性能的缓存数据库，不仅可以提供快速读写操作，还具备灵活的数据结构和强大的功能。其中，Redis的限流功能非常适合应对高并发请求场景，通过使用Redis的计数器和时间窗口等特性，我们可以轻松实现有效的流量控制。
本文将探讨如何利用Redis实现简单而可靠的限流策略。我们将介绍Redis中的计数器和常用算法，并演示如何使用这些工具来限制请求的频率。通过合理设置限流规则，我们可以保护系统免受过载、拒绝服务和其他潜在风险的影响，提高系统的稳定性和响应能力。
无论您是开发者、系统管理员还是架构师，本文将为您提供详细的指导和示例代码，帮助您了解并应用Redis的限流功能。通过掌握这一重要的技术，您将能够构建更可靠、高效且具有弹性的系统，为用户提供卓越的体验。
让我们深入研究，学习如何利用Redis进行限流，并为我们的系统保驾护航！
一、为什么我们选择使用Redis来实现限流机制？ 在高并发的网络应用中，保护系统的稳定性和可用性是至关重要的。如果没有有效地限制请求的速率，系统可能会面临以下问题：
恶意攻击：恶意用户可以通过发送大量请求或者频繁访问敏感接口来占用服务器资源，导致其他合法用户无法正常使用服务。
资源耗尽：某些接口或资源可能具有较高的计算或存储成本，在无限制的情况下，过多的请求可能会导致服务器资源耗尽，从而使整个系统崩溃。
不公平竞争：当某些用户滥用资源或请求过于频繁时，会导致其他用户无法公平地获得系统的响应，影响到整体用户体验。
因此，我们需要一种有效的方式来控制请求的速率，以保护系统免受这些问题的影响。而Redis正是一个理想的工具，具备以下特点使其成为限流的首选：
高性能：Redis是一个内存数据库，读写速度非常快，能够处理大量的请求并返回及时响应，适合在高并发场景下进行限流操作。
灵活的数据结构：Redis提供了丰富的数据结构，如字符串、哈希表、有序集合等。这些数据结构可以帮助我们实现不同类型的限流策略，满足各种业务需求。
原子操作：Redis支持原子操作，保证限流算法的准确性和一致性。通过使用Redis的计数器和时间窗口等特性，我们可以快速、安全地进行限流操作。
分布式支持：Redis可以进行分布式部署，多个节点之间可以共享和协调限流信息，从而实现对整个系统的全局限流。
综上所述，使用Redis来实现限流机制能够有效地防止恶意攻击、资源耗尽和不公平竞争等问题，提高系统的稳定性和可用性。它是一种强大而灵活的工具，为我们提供了一种简单而可靠的方式来控制请求的速率，确保系统能够按照预期的方式运行。
二、限流实战方案 1.令牌桶算法策略 （1）算法原理：
令牌桶初始化时，设置一个固定的容量和速率。
每个时间间隔（例如1秒），向令牌桶中添加一个令牌，直到达到容量上限。
当有请求到达时，首先检查令牌桶中是否有足够的令牌可用。
如果有足够的令牌，则从令牌桶中取一个令牌，并处理请求。
如果没有足够的令牌，则拒绝请求或进入排队等待。
请求处理完毕后，返回结果并释放令牌，使其再次可用。
（2）代码示例：
@Component public class TokenBucketRateLimiter { private final RedisTemplate&lt;String, Object&gt; redisTemplate; private final String key; private final int capacity; private final int rate; public TokenBucketRateLimiter(RedisTemplate&lt;String, Object&gt; redisTemplate, @Value("${rate.limit.key}") String key, @Value("${rate.limit.capacity}") int capacity, @Value("${rate.limit.rate}") int rate) { this.redisTemplate = redisTemplate; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de2d37b031f9c468516315f5d1535bd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d10d524eec1c3d7b590b14a2455ce27d/" rel="bookmark">
			Stable Diffusion主流UI详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Stable Diffusion目前主流的操作界面有WebUI、ComfyUI以及Fooocus
这里webui和fooocus在人机交互上的逻辑是一样的，fooocus界面更加简洁。
comfyui是在人机交互上是采用流程节点的交互逻辑，和上面略有区别。
界面分别如下：
WebUI界面如下
webUI一般推荐 秋葉aaaki 版本的一键安装包，部署比较方便。WebUI生态相对完善，插件比较多多，玩法众多，人群受众广。
Fooocus界面如下
原作者是lllyasviel，也是WebUI的 ControlNet插件的作者，操作简单，因推出的晚一些，受众目前少一些，插件和玩法相对webui要少。
ComfyUI界面如下
相对于webui,其显存使用效率会更高，启动及图像生成速度较快；
支持个性化工作流构建，流程可导出与分享，出现异常方便快速定位是哪一个阶段的问题；
导入生成图片能自动重现工作流程，并自动选择合适的模型；
总之，三者选择哪一种深入学习均可，也可都选择，因为不同的ui有不同的插件，可以学习一种webui和fooocus中的一种，加上comfyui；comfyui属于工作流控制，能控制的更加精细，也方便理解出图的原理与过程。
三者模型均可共享，也可以三个均安装，不会占用模型本身的空间。
另外，最新的秋叶大神的一键整合包对这三个ui均提供了一键安装，小白得福音，不方便下载的小伙伴，后面我会分享出来。
可以看到安装界面不仅支持了webui，也支持comfyui和fooocus啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/046a3f2e5002e10479f5e0f12e118dd1/" rel="bookmark">
			如何在 JavaScript 中比较两个日期 – 技术、方法和最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 JavaScript 中，您可以使用 date 对象有效地处理应用程序中的日期、时间和时区。
Date 对象可帮助您有效地操作数据、处理各种与日期相关的任务，并在创建实际应用程序时执行一些计算。
（本文内容参考：java567.com）
在本文中，我们将了解以下主题：
日期比较概述日期比较在 JavaScript 中的重要性JavaScript 中的日期对象如何创建日期对象日期比较的基础知识如何使用比较运算符比较日期如何使用 getTime（） 方法比较日期如何使用 valueOf（） 方法如何使用 toISOString（） 方法在 JavaScript 中比较日期的挑战结束语 日期比较概述 在 JavaScript 中，日期比较涉及评估两个日期，以确定一个日期是早于、晚于另一个日期还是与另一个日期相同。
有多种方法可以比较日期，包括（但不限于）比较运算符 （ ， ， ， ） 和 和 等方法。&lt;``&gt;``&lt;=``&gt;=``getTime()``valueOf()
日期比较在 JavaScript 中的重要性 JavaScript 中的日期比较对于处理和组织与时间相关的数据以及 Web 应用程序中的时间敏感功能非常重要。在应用程序中，它对于处理基于时间的数据过滤、调度和事件处理至关重要。
在 JavaScript 中，了解日期比较技术可以构建能够承受各种与时间相关的场景的可靠且无缝的应用程序。
首先，以下是日期比较是 JavaScript 中需要了解的关键概念的一些原因：
数据过滤：在交易记录和日志等时间敏感数据、过滤和检索信息是应用程序不可或缺的一部分的应用程序中，日期比较至关重要。事件调度：通过日期比较可以轻松确定事件的状态。它有助于组织事件、提醒和任务。算术：在 JavaScript 中，日期比较有助于简单的算术，例如添加和减去时间间隔、执行日期操作以及计算两个日期之间的持续时间。条件逻辑：通过日期比较，您可以使用基于时间相关条件的条件逻辑，在某个事件发生时触发动作。用户体验：日期比较通过确保与时间相关的功能完美运行来增强应用程序的可靠性。 JavaScript 中的日期对象 在 JavaScript 中，日期对象是一个非常重要的概念。您可以使用它们来处理时间和日期，并提供以多种格式操作、格式化和表示日期和时间的方法。
如何创建 Date 对象 有几种方法可以在 JavaScript 中创建日期对象。部分方法如下：
使用关键字new let currentDate = new Date(); console.log(currentDate) //OUTPUT.. Tue Feb 06 2024 00:28:59 GMT-0800 (Pacific Standard Time) 在上面的代码中，调用了 Date 构造函数，但没有传递任何参数。这意味着它返回一个日期对象，其中当前日期和时间作为值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/046a3f2e5002e10479f5e0f12e118dd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a49cacf7d1108532fd93dfa92bbd7e47/" rel="bookmark">
			Java：什么是向上转型与向下转型（详细图解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、什么是向上转型
1、概念
2、代码示例
3、向上转型的优缺点
二、什么是向下转型
1、向下转型的概念
​编辑
2、代码示例
三、向下转型的缺点及 instanceof 的使用
1、向下转型的缺点
2、instanceof的使用
一、什么是向上转型 1、概念 向上转型就是创建一个子类对象，将其当成父类对象来使用。
语法格式：父类类型 对象名 = new 子类类型()
Animal animal = new Cat ()；
Animal 是父类类型，但可以引用 Cat这个子类类型，因为是从小范围到大范围的转换。
2、代码示例 class Aminal { public void display() { System.out.println("Animal"); } } class Cat extends Aminal { public void display() { System.out.println("Cat"); } } class Dog extends Aminal { } public class Main{ public static void main(String[] args) { Aminal aminal1 = new Aminal(); Aminal aminal2 = new Cat(); Aminal aminal3 = new Dog(); aminal1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a49cacf7d1108532fd93dfa92bbd7e47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2843b71ea7e9cb3958c1bd625fdefd7/" rel="bookmark">
			【JAVA】可视化窗口制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.概括 今天我具体来分析一下JAVA可视化窗口的制作；其中包括窗口标题，窗口大小尺寸，窗体中标签，输入框，按键等插件的添加以及我们窗体中的插件改如何布局，排放位置等，这里我们使用的是设置坐标来进行部件布局。
2.步骤分析 1.我们先试着创建一个可视化窗口；
2.试着把窗口的标题，尺寸大小设置成合适的；
3.调整面板布局，试着在面板中添加输入框，按键等；
2.1.创建可视化窗口 我们看一个例子:
package com.hm.ui; import javax.swing.JFrame; public class TextFrame extends JFrame { public TextFrame() { this.setTitle("测试窗口"); //窗口标题 this.setSize(630, 420); //窗口尺寸 this.setLocationRelativeTo(null); //设置窗口位置居中 this.setDefaultCloseOperation(3); // 关闭窗口选项 this.setResizable(true); //用户可以手动改变窗体大小 this.setVisible(true); //窗体可视，注意：不加窗体可视是不能看到窗口的 } public static void main(String[] args) { new TextFrame(); } } 我们看一下测试效果：可以看到我们这个可视化窗口就创建出来了； 2.2.添加插件（标签，输入框，按键） 我们要明白在添加插件之前，我们要先创建一个JFrame对象以及JPanel面板，之后我们创建的像JLabel标签，JTextField输入框，JButton按钮等都是需要先一步步添加到JPanel面板中，最后再把JPanel面板添加到我们创建的JFrame对象中，我们才算插件添加成功了。
1.定义组件
// 定义组件 JFrame frame = new JFrame(); JPanel jp,jp1, jp2, jp3;// 面板 JLabel jl,jl1,jl2,jl3;// 标签 JTextField jt1, jt2, jt3;// 文本框 JButton jb1, jb2;// 按钮 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2843b71ea7e9cb3958c1bd625fdefd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53bca7474f3f616c967e3830496a402d/" rel="bookmark">
			AIGC报告：大模型改变开发及交互环境，处于高速迭代创新周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天分享的是AIGC系列深度研究报告：《AIGC报告：大模型改变开发及交互环境，处于高速迭代创新周期》。
（报告出品方：华安证券）
报告共计：64页
LLM大模型爆发的关键节点: 2017年“Transformer”模型的出现 • 在“Transformer”模型还未出现时，NLP（自然语言处理）领域的主流架构基本采用RNN（循环神经网络），RNN 的痛点可以总结为两点： ①由于递归性质，训练过程中通常无法并行计算； RNN在工作过程中将会对内容按顺序逐字处理，每一步的输出取决于先前的隐藏状态和当前的输入，需要等到上一 个步骤完成后才能进行当前计算，因此无法进行并行计算，训练效率较低。 ②不擅长处理长序列、长文本； 当 RNN 处理长序列时，由于信息的不断累积，时间步长增加时，梯度会不断变小，这会导致梯度消失或梯度爆炸 问题，使得网络难以学习长期依赖（long-term dependency）的关系。当梯度消失时，前面的信息无法有效地传递 到后面，也就导致词之间距离越远，前面对后面的影响越弱，所以RNN难以有效的捕获长距离的语义关系，当梯度 爆炸时，网络的权重会变得极大，导致网络不稳定。
• 虽然之后也出现了如LSTM（Long Short-Term Memory）和GRU（Gated Recurrent Unit）等的RNN变体，但解决长 期依赖问题的能力也有限，也依旧无法解决无法并行计算的痛点。
• “Transformer”是谷歌的研究团队在2017年6月在论文《Attention is All You Need》中首次发布的。该论文提 出了一种全新的序列转换架构，完全基于自注意力机制，摒弃了循环神经网络（RNN）在处理序列数据时的局限性。 “Transformer”有能力学习输入序列里所有词的相关性，不会受到短时记忆的影响。
• 我们可以将“Transformer”的创新总结为两点：①自注意力机制；②位置编码。其中，“Transformer”的自注 意力机制简单来说就是“Transformer”在处理每个词的时候，不仅会关注这个词本身以及附近的词，还会去注意 输入序列里所有其他的词，然后给予每个词不一样的注意力权重（权重是模型通过大量文本训练习得的）。
• 例：“The animal didn't cross the street because it was too tired”，其中“it”可以代指任何东西，“Transformer”中 的注意力机制可以关注到输入序列里所有词，并给予不同权重，而像这样的自注意力机制有很多个，每个自注意力机制都有自己的注 意力权重，用来关注文本里不同特征，每个权重互不影响，也就意味着可以实现并行计算。
• Transformer模型抛弃了RNN、CNN作为序列学习的基本模型，循环神经网络本身就是一种顺序结构，天生就包含了 词在序列中的位置信息。当抛弃循环神经网络结构，完全采用Attention取而代之，这些词序信息就会丢失，模型就没有办法知道每个词在句子中的相对和绝对的位置信息。因此，有必要把词序信号加到词向量上帮助模型学习这 些信息，位置编码（Positional Encoding）就是用来解决这种问题的方法。
• 例：当接收到输入内容后，“Transformer”与其他NLP模型一样， 会将词转化为词向量（这里举例维度为4个，但在Transformer中词 向量维度为512个，每个维度都代表不同特征），此外还会根据每个 词所在文中的不同位置，给予位置向量。这样就可以实现让模型既 理解每个词的意义，又能够捕获每个词在文中的位置，从而理解不 同词之间的顺序关系。借助位置编码，词可以不按顺序输入给神经 网络，模型可以同时处理输入序列里的所有位置，不需要像RNN那 样依次处理。
基于Transformer架构的LLM发展图谱：Decoder-only成为主流 ①粉色枝：Encoder-Only（仅用解 码器）。代表LLM为BERT，该类模型 主要用于处理输入数据，专注于理 解和编码信息，而不是生成新的文本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53bca7474f3f616c967e3830496a402d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a4ebbcfa1dc0ca994886a5b3286ecb1/" rel="bookmark">
			AI大模型优缺点比较分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要： AI大模型在不同领域的应用不断推进着人工智能技术的发展。本论文将对八个不同的AI大模型进行综合分析，分别是Chat GPT 4、文心一言、通易千问、360智脑、智源“悟道”、商量、天工和清华OpenBMB。我们将从模型性能、语义理解、交互能力等多个方面对它们的优缺点进行比较。通过综合分析，可以为不同领域的AI应用提供参考和指导。
1. 引言 近年来，AI大模型在人工智能领域取得了巨大的突破，为各行各业带来了巨大的影响。本论文将对八个不同的AI大模型进行分析，探讨它们的优缺点。
2. Chat GPT 4 Chat GPT 4是OpenAI推出的一款强大的对话AI模型。其优点在于优秀的模型性能和语义理解能力，能够准确理解用户的问题，并提供相关回答。然而，该模型的缺点在于缺乏一定的实时性，对于一些实时性要求高的场景可能有响应时间较长的问题,有时还会胡说八道（自编自创）。
3. 文心一言 文心一言是一款基于大规模数据训练的中文自然语言处理模型。该模型在语义理解和问答能力方面表现出色。它的优点在于提供准确的回答，特别适合处理复杂问题。然而，该模型在交互体验上有待提高，有时候对于一些复杂问题的处理可能会出现不准确的情况。
4. 通义千问 通义千问是阿里开发的AI大模型，为对话领域提供了强大的能力。该模型在语义理解和问答能力上表现出色，能够迅速准确地回答用户问题。然而，它的缺点在于训练数据的限制，对于一些特殊领域的问题可能无法提供满意的答案。
5. 360智脑 360智脑是由360公司开发的AI大模型，旨在应对多领域复杂任务。它在模型性能和准确度方面表现突出，并具备较高的语义理解能力。该模型在处理长文本方面优秀，但在实时性要求高的场景中可能会存在响应时间较长的问题。
6. 智源“悟道” 智源“悟道”是一款全球首个知识全图谱的AI大模型，能够与人进行语义理解和深入的对话。该模型的优点在于准确的语义理解和较强的知识图谱查询能力。然而，由于知识图谱的不完善，该模型在处理一些复杂的问题时可能存在回答不准确的情况。
7.天工 天工是由昆仑万维和奇点智源合作自研的大语言模型，专注于图像处理和语言任务。该模型在图像识别、语义理解、文本生成和机器翻译等方面表现出色，具备高度的准确性和处理能力。天工模型的优点在于其深度学习算法和大规模数据训练，能够处理复杂的自然语言任务。同时，模型还具备较高的灵活性和实时性能。然而，该模型在一些特定领域和任务上可能需要更多的训练和优化。
8.商量（SenseChat） 商量是商汤科技旗下的中文语言大模型应用平台。该模型在语义理解、问答、情感分析等方面具备出色的能力。商量模型的优点在于它能够实现高性能的中文自然语言处理，并提供良好的交互体验。此外，该模型还具备较高的可扩展性和自定义性，可根据不同领域和需求进行定制化开发。然而，模型可能在一些特定领域的深度和广度上有待进一步提升。
9. 清华OpenBMB 清华OpenBMB是清华大学开发的基于多模态大规模预训练模型，能够处理图像、语音和文本等多种数据。该模型在模态融合和跨模态任务上表现出色，具备较高的语义理解和交互能力。其优点在于在多模态任务中能够有效结合不同数据源的信息，并取得优秀的效果。然而，由于模型复杂性较高，其计算资源和存储开销也相应较大。
10. 总结与展望 本论文对八个不同的AI大模型进行了综合分析，包括Chat GPT 4、文心一言、通易千问、360智脑、智源“悟道”、商量、天工和清华OpenBMB。通过比较它们的优缺点，可以看到每个模型在不同领域和任务中具备独特的特点。未来，AI大模型的发展趋势应该是追求更高的模型性能、更好的交互体验，并进一步完善对于复杂问题和特定领域的处理能力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2796b9f3171d924ca978bc83f1131d73/" rel="bookmark">
			解决python setup.py egg_info did not run successfully.问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在安装pycurl库时遇到了这个问题：
pip install pycurl Collecting pycurl Using cached pycurl-7.45.2.tar.gz (234 kB) Preparing metadata (setup.py) ... error error: subprocess-exited-with-error × python setup.py egg_info did not run successfully. │ exit code: 10 ╰─&gt; [1 lines of output] Please specify --curl-dir=/path/to/built/libcurl [end of output] note: This error originates from a subprocess, and is likely not a problem with pip. error: metadata-generation-failed × Encountered error while generating package metadata. ╰─&gt; See above for output.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2796b9f3171d924ca978bc83f1131d73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20b9c5de08f98b3381e343b89f5cd1d6/" rel="bookmark">
			Spark编程实验五：Spark Structured Streaming编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、目的与要求
二、实验内容
三、实验步骤
1、Syslog介绍
2、通过Socket传送Syslog到Spark
3、Syslog日志拆分为DateFrame
4、对Syslog进行查询
四、结果分析与实验体会
一、目的与要求 1、通过实验掌握Structured Streaming的基本编程方法；
2、掌握日志分析的常规操作，包括拆分日志方法和分析场景。
二、实验内容 1、通过Socket传送Syslog到Spark
日志分析是一个大数据分析中较为常见的场景。在Unix类操作系统里，Syslog广泛被应用于系统或者应用的日志记录中。Syslog通常被记录在本地文件内，也可以被发送给远程Syslog服务器。Syslog日志内一般包括产生日志的时间、主机名、程序模块、进程名、进程ID、严重性和日志内容。
日志一般会通过Kafka等有容错保障的源发送，本实验为了简化，直接将Syslog通过Socket源发送。新建一个终端，执行如下命令：
$ tail -n+1 -f /var/log/syslog | nc -lk 9988 “tail -n+1 -f /var/log/syslog”表示从第一行开始打印文件syslog的内容。“-f”表示如果文件有增加则持续输出最新的内容。然后，通过管道把文件内容发送到nc程序（nc程序可以进一步把数据发送给Spark）。
如果/var/log/syslog内的内容增长速度较慢，可以再新开一个终端（计作“手动发送日志终端”），手动在终端输入如下内容来增加日志信息到/var/log/syslog内：
$ logger ‘I am a test error log message.’ 2、对Syslog进行查询
由Spark接收nc程序发送过来的日志信息，然后完成以下任务：
（1）统计CRON这个进程每小时生成的日志数，并以时间顺序排列，水印设置为1分钟。
（2）统计每小时的每个进程或者服务分别产生的日志总数，水印设置为1分钟。
（3）输出所有日志内容带error的日志。
三、实验步骤 1、Syslog介绍 分析日志是一个大数据分析中较为常见的场景。在Unix类操作系统里，Syslog广泛被应用于系统或者应用的日志记录中。Syslog通常被记录在本地文件内，也可以被发送给远程Syslog服务器。Syslog日志内一般包括产生日志的时间、主机名、程序模块、进程名、进程ID、严重性和日志内容。
2、通过Socket传送Syslog到Spark 日志一般会通过kafka等有容错保障的源发送，本实验为了简化，直接将syslog通过Socket源发送。新开一个终端，命令为“tail终端”，输入
tail -n+1 -f /var/log/syslog | nc -lk 9988 tail命令加-n+1代表从第一行开始打印文件内容。-f代表如果文件有增加则持续输出最新的内容。通过管道发送到nc命令起的在本地9988上的服务上。
如果/var/log/syslog内的内容增长速度较慢，可以再新开一个终端，命名为“手动发送log终端”，手动在终端输入
logger ‘I am a test error log message.’ 来增加日志信息到/var/log/syslog内。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20b9c5de08f98b3381e343b89f5cd1d6/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/506/">«</a>
	<span class="pagination__item pagination__item--current">507/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/508/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>