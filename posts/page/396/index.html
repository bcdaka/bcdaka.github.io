<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e32c7a70cf9d114045f81ec8f0eb6f0c/" rel="bookmark">
			java.lang.reflect.InvocationTargetException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java.lang.reflect.InvocationTargetException 是 Java 反射 API 中的一个异常类，它包装了由 Method.invoke() 或构造函数 Constructor.newInstance() 抛出的异常。当你使用 Java 的反射机制动态地调用一个方法或构造一个新的对象时，如果被调用的方法或构造函数内部抛出了异常，那么这个异常不会被直接抛出，而是被封装在一个 InvocationTargetException 中。
InvocationTargetException 的主要作用是提供一种机制，使得通过反射调用方法或构造对象时抛出的异常可以被捕获和处理。当你捕获到 InvocationTargetException 时，可以通过调用其 getCause() 方法来获取实际的异常，这样就可以像处理普通异常一样来处理它。
下面是一个简单的示例，展示了如何使用反射调用方法并处理 InvocationTargetException：
import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class Example { public static void main(String[] args) { try { // 获取 String 类的 "substring" 方法 Method substringMethod = String.class.getMethod("substring", int.class, int.class); // 创建一个 String 对象 String str = "Hello, World!"; // 使用反射调用 substring 方法 Object result = substringMethod.invoke(str, 0, 5); // 输出结果 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e32c7a70cf9d114045f81ec8f0eb6f0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f168cb3a6c187f4e5f644faab92261c/" rel="bookmark">
			RocketMQ与Kafka深度对比：消息中间件的选择之战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在当今日益复杂和高速的信息化时代，消息中间件已成为构建高可用、高扩展性系统的核心组件之一。它们为分布式系统提供了异步通信机制，允许各个微服务、组件或应用程序之间以可靠和高效的方式进行数据交换。简单来说，消息中间件就像是企业级应用的“邮递员”，负责确保数据包的安全、快速和准确地从一个端点传递到另一个端点。
在众多消息中间件中，RocketMQ和Kafka无疑是最受关注和广泛应用的两大巨头。RocketMQ作为阿里巴巴集团的开源项目，以其稳定性和高吞吐量受到了广大企业的青睐。而Kafka则因其高吞吐量、可扩展性以及丰富的社区支持而成为了大数据和实时数据处理领域的宠儿。
本文旨在深入探讨RocketMQ与Kafka的各项特性和差异，帮助读者更好地理解两者的优缺点，从而在实际应用中做出明智的选择。我们将从基本概念和架构对比开始，逐步深入到性能、可靠性、易用性、扩展性、事务消息支持、部署与运维等多个方面进行全面的对比分析。最后，我们还将通过实战案例和经验总结，为读者提供更加实用和具体的参考，希望能够为大家在消息中间件的选择之路上提供有力的支持和指导。
一、基本概念与架构对比 RocketMQ简介 RocketMQ是由阿里巴巴集团开源的分布式消息中间件，主要用于支持大规模分布式系统的高并发、低延迟消息传递。它的基本架构主要包括NameServer、Broker、Producer和Consumer这几个核心组件。
基本架构：RocketMQ的架构采用了分布式的Broker模式，其中NameServer负责维护路由信息，Broker负责存储消息，Producer负责发送消息，Consumer负责接收和处理消息。
核心组件：
NameServer：负责维护整个RocketMQ集群的元数据信息，包括Topic和Broker的路由信息。Broker：消息存储的核心组件，负责接收、存储和传递消息。Producer：消息的生产者，负责产生并发送消息到Broker。Consumer：消息的消费者，负责从Broker拉取消息并进行处理。 Kafka简介 Kafka是由LinkedIn开发的分布式流处理平台，也是一个高吞吐量的分布式发布-订阅消息系统。它的基本架构与RocketMQ有所不同，主要包括Broker、Zookeeper、Producer、Consumer、Topic和Partition几个核心组件。
基本架构：Kafka采用了分布式的发布-订阅模式，其中Zookeeper负责集群管理和协调，Broker负责消息的存储和传递，Producer负责生产消息，Consumer负责消费消息，Topic用于消息的分类和管理，Partition用于消息的分片存储。
核心组件：
Broker：消息的存储和传递中心。Zookeeper：负责集群的管理和协调。Producer：生产消息的组件。Consumer：消费消息的组件。Topic：消息的分类和管理单元。Partition：消息分片的存储单位。 架构差异点评 RocketMQ和Kafka在架构设计上有明显的差异，这也决定了它们在不同场景下的适用性和优劣势。
对比两者的架构设计：
RocketMQ采用了Broker模式，更注重的是分布式的消息存储和传递能力，适用于高并发、低延迟的消息场景。Kafka则采用了发布-订阅模式，并依赖Zookeeper进行集群管理，其设计更为灵活，支持大规模数据的流处理和分析。 分析各自的设计哲学及适用场景：
RocketMQ的设计更加简洁和直接，适用于对消息传递速度和可靠性有较高要求的场景，例如电商交易、实时日志处理等。Kafka的设计更注重数据的流处理和分析能力，适用于大数据分析、实时监控、日志聚合等复杂场景。 总体而言，RocketMQ和Kafka在架构设计上都有各自的特点和优势，选择哪一个取决于具体的业务需求和场景。如果你需要高并发、低延迟的消息传递，RocketMQ可能更适合你；而如果你需要大规模数据的流处理和分析，Kafka则可能更为合适。
二、性能与可靠性比较 RocketMQ的性能特点 RocketMQ在性能方面有其独特的优势，以下几点是它的主要性能特点：
顺序消息处理能力：RocketMQ提供了强大的顺序消息处理能力，确保消息按照发送的顺序被消费，这对于某些业务场景如订单处理、事务管理等尤为重要。
同步双写机制：RocketMQ采用同步双写机制来提高数据的可靠性和持久性。这意味着每一条消息都会被同步写入主节点和备份节点，从而大大降低了数据丢失的风险。
Kafka的性能特点 Kafka在性能方面也表现出色，以下是其主要性能特点：
高吞吐量：Kafka以其出色的I/O性能和分布式架构设计，能够实现极高的吞吐量，每秒数百万的消息处理能力使其成为大数据领域的首选。
日志压缩特性：Kafka支持消息的压缩存储，能够有效地减少存储成本和网络带宽使用，特别是在处理大量日志数据时，这一特性尤为有用。
可靠性比较 性能只是评价消息中间件的一个方面，可靠性同样重要。下面是RocketMQ和Kafka在可靠性方面的比较：
消息丢失风险对比：
RocketMQ：由于其同步双写机制，RocketMQ的数据持久性和可靠性较高，消息丢失的风险相对较低。Kafka：Kafka通过数据的多副本备份和ISR机制提供了高可靠性，但在某些异常情况下（例如网络故障或硬件故障）可能会出现消息丢失。 高可用策略分析：
RocketMQ：RocketMQ支持主从架构和故障切换，能够在节点故障时自动切换到备用节点，提供高可用性。Kafka：Kafka的分布式设计和副本机制保证了系统的高可用性，可以容忍单个或多个节点的故障，但需要Zookeeper进行集群管理和故障检测。 综上所述，RocketMQ和Kafka在性能和可靠性方面都有各自的优势。RocketMQ在顺序消息处理和数据持久性方面表现出色，适用于对消息顺序和数据可靠性有高要求的场景；而Kafka在高吞吐量和日志压缩方面具有明显优势，适用于大数据处理和实时分析等场景。选择哪一个取决于你的具体业务需求和对性能与可靠性的重视程度。
三、易用性与扩展性分析 RocketMQ的易用性 RocketMQ在易用性方面做了不少努力，以减少开发和维护的复杂性：
配置管理：RocketMQ提供了直观的配置管理工具，使得用户可以轻松地进行配置调整，包括主题（Topic）、队列（Queue）、消费者组（Consumer Group）等，这使得RocketMQ在使用和管理上变得相对简单。
控制台管理：RocketMQ提供了Web控制台，用户可以通过图形化界面轻松管理和监控消息队列、主题和消费者组的状态，实时查看各种性能指标和日志，大大提高了运维效率。
Kafka的易用性 Kafka在易用性方面也有其独特的优势：
API丰富性：Kafka提供了丰富的客户端API，包括Java、Python、Go等多种语言，使得开发者可以选择最适合自己的编程语言来进行开发。
社区支持与生态：Kafka有一个非常活跃的社区，提供了大量的文档、教程和示例代码，同时还有丰富的第三方插件和工具，这些都大大降低了学习和使用Kafka的难度。
扩展性对比 扩展性是衡量消息中间件的另一个重要指标，下面我们来对比RocketMQ和Kafka的扩展性：
插件系统：
RocketMQ：RocketMQ提供了丰富的插件系统，允许用户扩展其功能，如消息过滤、事务支持、消息路由等，满足各种特定需求。Kafka：Kafka同样支持插件扩展，有大量的第三方插件可供选择，如监控、告警、数据清洗等，增强了其在大数据处理和实时分析方面的功能。 消息过滤与转换能力：
RocketMQ：RocketMQ支持灵活的消息过滤机制，可以根据消息的属性或内容进行过滤，同时还提供了消息转换功能，方便数据的格式转换。Kafka：Kafka也提供了消息过滤和转换的功能，通过使用Kafka Streams或KSQL等工具，可以实现复杂的数据处理和转换操作，使其在流处理和数据分析方面更加强大。 总结来说，RocketMQ和Kafka在易用性和扩展性方面都有各自的优势。RocketMQ在配置管理和控制台管理上相对更为简单直接，适合快速部署和使用；而Kafka则在API丰富性和生态支持上有所突出，适合更复杂和定制化的应用场景。对于需要快速上手和低门槛的应用，RocketMQ可能更为合适；而对于需要高度定制和强大扩展能力的应用，Kafka可能是更好的选择。
四、事务消息支持 RocketMQ的事务消息 RocketMQ在事务消息支持方面表现得相当出色，其事务消息设计旨在保证消息的原子性操作：
事务消息原理：RocketMQ的事务消息主要依赖于两阶段提交协议。在发送事务消息时，首先会发送一个预备消息（Prepare Message），然后等待应用程序发送确认消息（Commit/Rollback Message）。只有当收到确认消息时，RocketMQ才会将预备消息提交，否则会回滚。
使用场景与限制：事务消息适用于涉及多个业务系统交互的场景，例如订单支付、库存扣减等。然而，RocketMQ的事务消息在设计上有一些限制，如事务参与者需要实现特定的接口，消息的生产和消费必须在同一个RocketMQ集群中。
Kafka的事务消息 Kafka的事务消息支持经历了一段时间的发展，现在已经相当成熟，主要特点是精确一次语义：
事务支持的发展历程：Kafka的事务支持最初是在Kafka 0.11版本中引入的，经过几个版本的迭代和优化，现在已经相当稳定。Kafka事务主要依赖于两阶段提交协议，与RocketMQ类似。
精确一次语义（Exactly Once Semantics）：Kafka强调精确一次语义，这意味着在生产和消费过程中，每条消息都只会被处理一次，从而避免了重复消费和消息丢失的问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f168cb3a6c187f4e5f644faab92261c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03746eaedd9bd20f1804c75f490522e7/" rel="bookmark">
			MATLAB 2024a软件下载安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1-首先下载Matlab，以下迅雷云链接，里面有全版本的matlab，根据自己的需要下载即可，建议下载最新版的，功能会更多，当然内存也会更大。
迅雷云盘迅雷云盘https://pan.xunlei.com/s/VNgH_6VFav8Kas-tRfxAb3XOA1?pwd=tb74#
2-根据以下B站的安装教程安装即可，非常简单，基本就是傻瓜式的。
1​​​​​​MATLAB 2024a软件下载安装教程_哔哩哔哩_bilibiliMATLAB 2024a软件下载安装教程, 视频播放量 1171、弹幕量 0、点赞数 9、投硬币枚数 10、收藏人数 11、转发人数 6, 视频作者 自学不孤单, 作者简介 软件下载公众号，自学不孤单，相关视频：68讲全！【MATLAB神经网络和四大优化算法】教程全解！从放弃到精通！人工智能|神经网络|MATLAB|优化算法，MATLAB R2024a v24.1最新中文版安装教程！，冒死上传！花12800买来的【MATLAB全套】教程，我居然只花4个小时就学懂了MATLAB基础版全套视频教程，涵盖核心知识点，全程干货，无废话！-函数绘图|速，冒死上传！花12800买来的【MATLAB全套】教程，我居然只花4个小时就学懂了MATLAB基础版全套视频教程，涵盖核心知识点，全程干货，无废话！-函数绘图|速，【评论区下载】卡尔曼滤波原理及应用-MATLAB仿真（PDF书和配合的程序），【机械臂建模仿真】六轴机械臂MATLAB数学建模_直播回放，封神之作！【2024年最好的MATLAB入门教程】听懂人话就能学会！从入门到秃头，小白轻松学会！——MATLAB 教程|MATLAB 机器学习，B站强推！这绝对是目前最完整系统的MATLAB教程，花3小时就能从入门到精通，草履虫听了都得点头，看完你还不会来锤爆我！人工智能|神经网络|机器学习，从放弃到精通！卡尔曼滤波从入门到实践~，吹爆！B站公认最系统的MATLAB终极版教程及案例应用，MATLAB神经网络、优化算法、遗传算法一口气学到饱！这绝对是全B站最用心（没有之一）的MATLAB终极https://www.bilibili.com/video/BV16F4m1F7bP/?spm_id_from=333.999.0.0&amp;vd_source=26c98ad55c90893ac9fbc14aa34276ee 亲测是可以使用的。
----------2024/4/26 上海 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18889bf5bba926b2df0d40d430d35c24/" rel="bookmark">
			C# GetField 方法应用实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
关于 C# Type 类
GetField 方法应用
应用举例
心理CT设计题
类设计
DPCT类实现代码
小结
关于 C# Type 类 Type表示类型声明：类类型、接口类型、数组类型、值类型、枚举类型、类型参数、泛型类型定义，以及开放或封闭构造的泛型类型。调用 this.GetType() 方法得到Type对象，可获取成员信息，如方法名、变量名。更多学习请参照以下链接：
Type 类 (System) | Microsoft Learn
本文以数据采集应用实例介绍 Type.GetField 方法的实际应用。
GetField 方法应用 GetField 是获取当前 Type 的特定方法，我们在这里介绍 GetField(String, BindingFlags) 即使用指定的绑定约束搜索指定的字段变量。
其中 string name 表示要搜索的方法名称，System.Reflection.BindingFlags 枚举可见下表：
序号筛选器标志说明1BindingFlags.Instance 或 BindingFlags.Static 必须指定实例或静态方可有效返回2BindingFlags.Public搜索当前 Type 中包含的公共方法3BindingFlags.NonPublic搜索当前 Type 中包含的非公共方法 、私有方法、内部方法和保护方法4BindingFlags.FlattenHierarchy在层次结构中的包括 public 和 protected 静态成员; private 继承类中的静态成员不包括在层次结构中5BindingFlags.IgnoreCase忽略方法name的大小写进行搜索6BindingFlags.DeclaredOnly如果只搜索 Type 声明的方法，则搜索只是继承的方法 应用举例 心理CT设计题 假设我们有一组心理测评题目，共计10题，每题有 A、B、C、D、E、F 共计六个单选项，分六个维度进行计分，各初始维度得分均为0，如果符合条件则+1分，该维度如下表：
序号变量名类型说明1轻躁狂int其特征包括：气质昂扬，爱说、精力充沛、易怒、思维奔逸、抑郁气短等。 初始值为02妄想狂int为了区分那些被判断为具有关系妄想、被害妄想、夸大自我概念、猜疑心、过度地敏感、意见和态度生硬等偏执性人格而制定。初始值为03抑郁int抑郁的特征是缺乏干劲，对未来没有希望，一般对自己的生活状况极其不满。 初始值为04癔病int癔病的特征是心因性的不随意肌体机能丧失和机能障碍。 初始值为05疑病int其特征是对自己的身体健康的一种过度的关心，担心自己有病或不健康。初始值为06精神分裂int其特征包括：思维、感情和行为混乱。初始值为0 初始化代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18889bf5bba926b2df0d40d430d35c24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef0c62f790ca4a258f52294daf4ce360/" rel="bookmark">
			RabbitMQ最全使用教程-小白也能看懂
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、队列: 点对点的通信(point - to - point): 消息发送者发送消息,消息代理将其放入到一个队列中，消息接收者从队列中获取消息内容,消息读取后被移除出队列。
2、主题: 发布publish/订阅subscribe 消息通信: 发布者发送消息到主题，多个接收者(订阅者)订阅这个主题,那么就会在消息到达时同时收到消息
(三) RabbitMQ的核心概念
1、Message(消息): 不具名，由消息头和消息体租出，消息体是不透明的。消息头是由一系列的可选属性组成如,routing-key路由键,priority-相对其他消息的优先权,delivery-mode-指出该消息是否需要永久存储等。
2、Publicsher(消息的生产者): 是向交换器发布消息的客户端应用程序。
3、Exchange(交换器): 用来接受消息并且消息路由给服务器中的队列,有四种类型,即决定消息发布到那个队列,具体有以下的类型:
(1)、Direct：消息中的路由键(routingkey)，如果和Binding中的binding key 一致,那么就将消息发到对应的队列中。
(2)、Fanout类型: 即广播模式,每个发送到fanout类型的交换器消息，交换器会将消息发送到它绑定的所有队列中,它转发消息是最快的。
(3)、Topic：主题,可以设置模糊匹配,会识别"#“和”*"号,#表示匹配0个或者多个单词,*匹配一个单词,单词之间使用:逗号隔开。
(4)、headers：实现发布订阅模型(基本不使用了)。
4、Queue(消息队列): 消息的容器,一个消息可以放在一个或者多个队列中。
5、Binding(绑定): 用于消息队列和交换器之间的关联,一个绑定就是基于路由键将交换机和消息队列连接起来的路由规则,交换器跟队列的绑定可以是多对多的关系
6、Connection(网络连接): 如一个Tcp连接。
7、Channel(信道): 多路复用连接中的一条独立的双向数据流通道,信道是建立在真实的TCP连接内的虚拟通道,AMQP命令都是通过信道发出去的,不管是发布消息,订阅队列,还是接收消息，都是通过信道完成,因为对于操作系统来说创建和销毁一个TCP连接都是很昂贵的开销,所以使用信道以实现复用一条TCP连接。
8、Consumer(消费者)： 接受和消费消息。
9、Virtaul Hos(虚拟主机): 即小型的RabbitMQ服务器，它表示一批交换器，消息队列和相关对象,连接时必须指定，默认是:/(以路径区分)。
10、Broker: 消息队列服务器实体。
五: Spring如何整合rabbitMQ？ (一) 添加依赖
org.springframework.boot
spring-boot-starter-amqp
2.2.1.RELEASE
(二) 设置配置信息
spring:
application:
name: RabbitMQ-Test # 应用名称
rabbitmq:
host: localhost #rabbitServer的地址
port: 5672 # 端口
username: guest # 用户名称
password: guest # 连接密码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef0c62f790ca4a258f52294daf4ce360/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/562662a048c61381728c38432179692a/" rel="bookmark">
			YOLOv5部署到web端（flask&#43;js简单易懂）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言最终实现效果图后端实现主界面检测函数+检测结果显示 前端实现主界面(index.html）+显示图片界面 总结 前言 最近，老板让写一个程序把yolov5检测模型部署到web端，在网页直接进行目标检测。经过1个星期的努力，终于实现基本功能👻（累晕了）。网上查阅了很多资料，发现很多的技术比较复杂，当然他们的页面都比较漂亮，然后我打算自己写一篇简单记录一下哈哈。进入正题，该项目完全由Python的轻量级web框架flask完成，其实有一点js代码，简单易懂👍
最终实现效果图 先看项目的效果图吧哈哈，比较辣鸡，但是功能实现了！
检测结果显示：
哈哈 可以看到检测结果还是可以的🤞
后端实现 首先，写了二个路由函数，分别是主界面、检测函数结果显示。如下所示
主界面 # 定义路由 @app.route('/', methods=['GET', 'POST']) def upload(): if request.method == 'POST': #post是一种请求方式 # 从表单中获取上传的文件 f = request.files['file'] #request.files 函数作用就是获取前端名为 'file'的文件信息 global filename # 定义全局变量，方便其他地方调用filename，如果不定义全局变量，其他地方无法调用 filename = f.filename # 获取前端上传图片名字 global file_path #同理，定义全局变量 # 将文件保存到服务器本地 file_path = os.path.join(os.getcwd(), filename) #本地路径+图片名字= 文件路径（file-path) print(file_path) # 当时只是为了测试程序 f.save(file_path) # 保存上传的图片到本地目录下，方便后续推理，直接找到图片 # 返回文件路径 # return file_path #进行检测 opt = parse_opt() main(opt) return render_template('index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/562662a048c61381728c38432179692a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/814a4cbeae6a9676cbc503ff1f268689/" rel="bookmark">
			保姆级银河麒麟V10高级服务器离线安装mysql5.7数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		离线在银河麒麟高级操作系统v10安装mysql5.7 下载mysql5.7 MySQL :: Download MySQL Community Server (Archived Versions)
2、把下载好的包上传到服务器
3、解压
[root@1-0001 ~]# cd /data/mysql [root@1-0001 mysql]# tar -zxvf mysql-5.7.44-linux-glibc2.12-x86_64.tar.gz 4、卸载系统的mariadb数据库
查询安装的mariadb数据库
rpm -qa | grep mariadb
[root@1-0001 ~]# rpm -qa | grep mariadb mariadb-common-10.3.9-12.p01.ky10.x86_64 mariadb-10.3.9-12.p01.ky10.x86_64 mariadb-errmessage-10.3.9-12.p01.ky10.x86_64 mariadb-connector-c-3.0.6-8.ky10.x86_64 mariadb-server-10.3.9-12.p01.ky10.x86_64 5、使用命令 rpm -e --nodeps卸载
[root@1-0001 ~]# rpm -e --nodeps mariadb-common-10.3.9-12.p01.ky10.x86_64 [root@1-0001 ~]# rpm -e --nodeps mariadb-10.3.9-12.p01.ky10.x86_64 [root@1-0001 ~]# rpm -e --nodeps mariadb-errmessage-10.3.9-12.p01.ky10.x86_64 [root@1-0001 ~]# rpm -e --nodeps mariadb-connector-c-3.0.6-8.ky10.x86_64 [root@1-0001 ~]# rpm -e --nodeps mariadb-server-10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/814a4cbeae6a9676cbc503ff1f268689/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e668a55f2ded3f05f331eccf755d2fd9/" rel="bookmark">
			【Android】apk安装报错：包含病毒: a.gray.BulimiaTGen.f
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
有时候apk安装或者更新时，显示：[高风险]包含病毒: a.gray.BulimiaTGen.f这种bug；
原因：这是手机管家误报病毒。
处理方法：我看网上其他资料可以进行申诉，也可以进行apk加固，我这边尝试用360加固apk；
360加固下载
温馨提示：apk通过免费的360加固之后的apk是没有签名证书的；需要再一次加固的apk进行签名，可以使用命令进行签名，也可以通过360加固-&gt;工具包-&gt;签名APK 功能进行签名。指定签名路径文件要与以前签名过的路径文件要相同。
————————————————————————————————————————————————————————
后续：
刚开始可以，后面一段时间还是显示病毒 a.gray.BulimiaTGen.f。
360加固没啥屁用。
分析原因：implementation api调用用户权限的依赖插件未被调用，引发的。
处理：排查多余的且功能需要调用用户权限的依赖插件，并删除。sync之后重新运行，打包。
暂时解决。
————————————————————————————————————————————————————————
再后续：
一个个插件、第三方插件也排查了，app下载量达到一定的量之后也会报错病毒。
现在尝试进行腾讯申诉，看最后的结果。
也有看到其他方法是换key、换包名；但是这种也只是解决一时的，而且已经有一定的用户量，不可能通知全部的用户删除再下载另一个app吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab2f0c6aceadb01aa23677f045d49c62/" rel="bookmark">
			Java连接FTP服务器，并使用ftp连接池进行文件操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Java连接FTP服务器进行文件相关操作，并且使用FTP连接池降低资源消耗，提高响应速率。
1、导入Pom依赖 &lt;!-- https://mvnrepository.com/artifact/commons-net/commons-net --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-net&lt;/groupId&gt; &lt;artifactId&gt;commons-net&lt;/artifactId&gt; &lt;version&gt;3.9.0&lt;/version&gt; &lt;/dependency&gt; 2、创建FTP的配置 ftp: # 服务器地址 host: xx.xxx.xx.xxx # 端口号 port: 21 # 用户名 userName: xxx # 密码 password: xxxxxxx # 工作目录 workingDirectory: /ftpTest # 编码 encoding: utf-8 #被动模式 passiveMode: true #连接超时时间 clientTimeout: 30000 # 线程数 threaNum: 1 # 0=ASCII_FILE_TYPE(ASCII格式)，1=EBCDIC_FILE_TYPE，2=LOCAL_FILE_TYPE(二进制文件) transferFileType: 2 # 是否重命名 renameUploaded: true # 重新连接时间 retryTimes: 1200 # 缓存大小 bufferSize: 8192 # 最大数 maxTotal: 50 # 最小空闲 minldle: 10 # 最大空闲 maxldle: 50 # 最大等待时间 maxWait: 30000 # 池对象耗尽之后是否阻塞，maxWait &lt; 0 时一直等待 blockWhenExhausted: true # 取对象时验证 testOnBorrow: true # 回收验证 testOnReturn: true # 创建时验证 testOnCreate: true # 空闲验证 testWhileldle: false # 后进先出 lifo: false 3、创建FTP配置类 import lombok.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab2f0c6aceadb01aa23677f045d49c62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebe5e84a0deb8d65b994be746cb4567e/" rel="bookmark">
			Rust并发编程实践：10分钟入门系统级编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
学前一问：Rust为何而出现？
摘要
引言
正文解析：
一、Rust中的并发编程基础
1.1 线程
1.2 协程
二、Rust并发编程的高级特性
2.1 通道
2.2 原子操作
2.3 锁
三、实例展示：优化并发编程性能
1. 并行计算
2. 异步IO
3. 数据并行
四、并发编程的挑战与最佳实践
结论：
参考文献：
学前一问：Rust为何而出现？ Rust是一门现代的系统编程语言，它的设计目标是提供安全性、并发性和高性能。Rust的出现是为了解决其他编程语言在这些方面存在的一些问题和挑战。下面是一些导致Rust出现的主要原因：
内存安全问题：传统的系统编程语言（如C和C++）给程序员提供了灵活性和低级控制能力，但也容易导致内存安全问题，如空指针引用、缓冲区溢出和数据竞争。这些问题可能导致程序崩溃、安全漏洞甚至恶意攻击。Rust通过引入所有权、借用和生命周期的概念，以及静态内存管理和线程安全性的保证，解决了这些问题，使得编写安全、可靠的系统级代码更加容易。
并发编程挑战：随着计算机系统的发展，多核处理器和并发编程变得越来越普遍。然而，传统的并发编程在处理共享数据和线程同步时存在困难，如数据竞争、死锁和饥饿等问题。Rust通过引入所有权和借用的概念，以及内置的线程安全性保证，使得编写并发程序更加安全和简单。
性能要求：系统级编程通常需要高性能和低级别的控制能力。然而，一些高级语言在性能方面存在一些限制，如垃圾回收开销、运行时开销等。Rust通过在编译时执行内存管理、零成本抽象和强大的优化能力，提供了与C/C++相媲美的性能，同时保持了高级语言的安全性和开发效率。
综上，Rust的出现是为了解决传统系统编程语言的安全性、并发性和性能方面的问题。它致力于成为一门现代化、安全性保证的系统编程语言，适用于各种应用领域，包括操作系统、嵌入式系统、网络服务和大规模分布式系统等。
摘要 Rust作为一门现代的系统级编程语言，提供了强大的并发编程能力。本文将介绍Rust中的并发编程概念，包括线程、协程和通道等核心概念，以及Rust提供的丰富的并发原语和工具。通过实例展示，我们将深入探讨如何在Rust中实现高效的并发编程，以提升程序的性能和响应速度。
引言 在当今多核处理器和分布式系统的时代，充分利用计算资源和实现高性能的并发编程成为了软件开发中的重要课题。Rust作为一门内存安全且具有高性能的编程语言，为开发者提供了丰富的并发编程工具和原语。通过正确地使用Rust的并发编程特性，我们能够编写出高效、安全且易于维护的并发代码。
正文解析： 一、Rust中的并发编程基础 1.1 线程 Rust通过标准库提供了对线程的支持，使得开发者能够创建和管理多线程程序。本节将介绍如何创建线程、线程间的通信和共享数据的安全性问题。
在Rust中，你可以使用标准库提供的 std::thread 模块来创建和管理线程。要创建一个新线程，你可以使用 std::thread::spawn 函数，并传递一个闭包作为新线程的入口点。下面是一个简单的例子：
use std::thread; fn main() { // 创建一个新线程 let handle = thread::spawn(|| { // 在新线程中运行的代码 println!("Hello from the new thread!"); }); // 在主线程中继续执行其他操作 // 等待新线程结束 handle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebe5e84a0deb8d65b994be746cb4567e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a8690e856b7885cf2228c444b1d14bc/" rel="bookmark">
			微信公众号使用wx.config前端如何配置参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需引用 jweixin-1.6.0.js 文件
npm install weixin-js-sdk 概述 | 微信开放文档
wx.config({ debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来 appId: '', // 必填，公众号的唯一标识 timestamp: , // 必填，生成签名的时间戳 nonceStr: '', // 必填，生成签名的随机串 signature: '',// 必填，签名 jsApiList: [] // 必填，需要使用的JS接口列表 }); 1.获取第一个参数生成签名的时间戳（其实就是获取当前时间）
// 时间戳
String timestamp = Long.toString((new Date().getTime()) / 1000);
2.获取第二个签名随机串
// 随机串 (java实现方法，前端可忽略)
String nonceStr = UUID.randomUUID().toString();
3.获取第三个参数签名
签名 = 随机串 + ticket + 时间戳 + URL（当前页面），但是随机串和时间戳我们在上边已经获取到了，下边我们只获取 ticket和当前页面的 URL 就好了，最后把他们拼到一起（后端实现）
公众号H5中wx.config()踩坑 微信公众号H5在配置微信参数的时候提示config:fail,Error: 系统错误错误码63002,invalid signature，表示签名有问题。签名的影响因素很多，但对于前端，最大的影响因素就是url参数要给对。url参数需要注意的两个点： 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a8690e856b7885cf2228c444b1d14bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed5520daac2c69c158c432df7a15e061/" rel="bookmark">
			CVE-2024-21006-weblogic远程命令执行漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、漏洞利用原理
二、影响范围
三、环境搭建及漏洞复现
四、检测与修复
前言 Oracle WebLogic Server 存在远程命令执行漏洞（CVE-2024-21006）,该漏洞源于T3/IIOP协议存在缺陷，未经身份验证的攻击者可通过T3/IIOP协议受影响的服务器发送恶意的请求，利用LDAP工具执行任意代码。
一、漏洞利用原理 该漏洞存在于在weblogic.application.naming中。MessageDestination引用实例会调用weblogic.application.naming，可以控制MessageDestinationObjectFactory#getObjectInstance方法的obj参数，最终在MessageDestinationReference#lookupMessageDestination方法中进行JNDI攻击。攻击者通过ldap服务向weblogic注入经过base64编码恶意代码，后续对context.lookup（“xxx”）进行调用，此操作将触发在 JNDI 上下文中查找绑定对象 （messageDestinationReference），该查找操作经由恶意LDAP服务器处理则会触发任意代码执行。
二、影响范围 Weblogic 12.2.1.4.0,14.1.1.0.0
三、环境搭建及漏洞复现 构建weblogic漏洞环境 准备java环境,所需java版本为&lt;=jdk 1.8_191 （版本过高无法利用成功） 官网下载weblogic 14.1.1.0.0/12.2.1.4.0安装文件或拉取docker镜像（部署过程参考Weblogic部署项目三种方式 - 疯子110 - 博客园 (cnblogs.com)）
下载IDEA，构建环境，用于运行exp 将运行该exp需要weblogic源码的jar包，若单独将weblogic.jar添加为依赖执行不成功，需要下载整个weblogic源码。
exp下载链接：https://pan.baidu.com/s/1gaP2SK-b9pJ5AT7XWuhk_w?pwd=68tg 提取码：68tg
打开exp项目，将weblogic.jar添加为项目依赖
修改攻击目标
可修改需要执行的命令，当前命令为calc.exe，base64编码。修改LDAP恶意服务器IP
下载LDAP恶意服务器工具（链接：https://github.com/WhiteHSBG/JNDIExploit） 运行工具，同时在IDEA启动exp项目
java -jar JNDIExploit-1.4-SNAPSHOT.jar -i &lt;监听IP&gt; 成功在目标机器弹出计算器，攻击结果如下：
四、检测与修复 本地检测：
使用如下命令对 WebLogic 版本和补丁安装的情况进行排查：
$ cd /Oracle/Middleware/wlserver_10.3/server/lib $ java -cp weblogic.jar weblogic.version 在显示结果中，如果没有补丁安装的信息，则说明存在风险。
升级系统，参考官网：https://www.oracle.com/security-alerts/cpuapr2024.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4498e7af8a487ba5b5e9d6f8eee2045/" rel="bookmark">
			百度 | 如何白嫖文心一言4.0，偷偷的用！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文心一言4.0
官方价一个月 59.9，贵不贵，很贵啊
现在有个白嫖文心一言4.0的方法
分享给大家
效果比3.0好用
如何使用 这里用到文心智能体平台，也是百度出的，和字节跳动的coze很像
这里打开文心智能体平台，自行百度
或者公众号回复：文心智能体平台
登录好，进入右上角管理中心
创建智能体
零代码，立即创建
随便写个名字，设定也随意
点击创建
创建需要大概30s
创建好后，右上角可以看到，是可以已使用文心大模型4.0
你可以在预览调优直接使用了
或者填好相关的信息
保存并发布，后面也可以直接打开使用文心一言大模型4
注意 名称内容不要使用与百度相关的名称，不然审核不通过
如果觉得文章有用的话，欢迎大家点赞评论转发！
关于我：https://vlink.cc/jixn
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00d1e8571420ef216b9eef42fe4cf0e5/" rel="bookmark">
			【javaSE】抽象类和接口（2）（接口部分）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		❤️❤️前言~🥳🎉🎉🎉 hellohello~，大家好💕💕，这里是E绵绵呀✋✋ ，如果觉得这篇文章还不错的话还请点赞❤️❤️收藏💞 💞 关注💥💥，如果发现这篇文章有问题的话，欢迎各位评论留言指正，大家一起加油！一起chin up！👍👍 💥个人主页：E绵绵的博客
💥 所属专栏：JAVASE题目练习 JAVASE知识点专栏 c语言知识点专栏 c语言题目练习
那现在我们就开始接口的学习吧。（接口这部分作者打算两篇文章介绍完）
接口的概念 接口就是公共的行为规范标准，大家在实现时，只要符合规范标准，就可以通用。
在Java中，接口可以看成是：多个类的公共规范，它是一种引用数据类型。
接口的语法规则 接口的定义格式与定义类的格式基本相同，将class关键字换成interface 关键字，就定义了一个接口。 ​ public interface 接口名称{ // 抽象方法 public abstract void method1(); // public abstract 是固定搭配，可以不写 public void method2(); abstract void method3(); void method4(); // 注意：在接口中上述写法都是抽象方法，更推荐方式4，代码更简洁 } ​ ❤️❤️提示: 1. 创建接口时, 接口的命名一般以大写字母开头. 2. 阿里编码规范中约定, 接口中的方法和属性一般不要加任何修饰符号（除default，static）, 保持代码的简洁性. 接口的使用 💥💥接口不能直接使用，必须要有一个"实现类"来"实现"该接口，实现接口中的所有抽象方法。 注意：子类和父类之间是extends 继承关系，类与接口之间是 implements 实现关系。
// USB接口 public interface USB { void openDevice(); void closeDevice(); } // 鼠标类，实现USB接口 public class Mouse implements USB { @Override public void openDevice() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00d1e8571420ef216b9eef42fe4cf0e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c23f455485b90fb42031a035b9439a2/" rel="bookmark">
			【javaSE】抽象类与接口（3）（接口部分）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		❤️❤️前言~🥳🎉🎉🎉 hellohello~，大家好💕💕，这里是E绵绵呀✋✋ ，如果觉得这篇文章还不错的话还请点赞❤️❤️收藏💞 💞 关注💥💥，如果发现这篇文章有问题的话，欢迎各位评论留言指正，大家一起加油！一起chin up！👍👍 💥个人主页：E绵绵的博客
💥 所属专栏：JAVASE题目练习 JAVASE知识点专栏 c语言知识点专栏 c语言题目练习 这篇文章就是关于抽象类与接口的最后一篇了，我们接下来将会给大家主要介绍接口的实例使用，这部分也是最难的，还请各位认真观看，不要错过每一处细节。💕💕 接口使用实例 给对象数组排序 首先在了解它之前我们一些接口以及其他知识点。
comparable ❤️❤️观察其内部结构我们可以知道在Comparable后面还有个&lt;T&gt;，在语法上这是泛型，之后会讲，这并不影响我们现在的思路，这个&lt;T&gt;中的T你写student类，后面的compareTo方法中的第一个参数就是student类，如上图。
对于comparable接口中只有一个compareTo方法，所以我们使用该接口时只需要重写该compareTo方法就行。
比较大小时可以用comparable该接口。
关于其comprable使用如下：
class Student implements Comparable&lt;Student&gt; { public String name; public int age; public Student(String name, int age) { this.name = name; this.age = age; } @Override public int compareTo(Student o) { //System.out.println("===fdsfsafdsafdsafdsafdsafdsafsafdsafa"); return this.age - o.age; } @Override public String toString() { return "Student{" + "name='" + name + '\'' + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c23f455485b90fb42031a035b9439a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7fba4474d4bac46831855adecbe0a21/" rel="bookmark">
			【javaSE】String类（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		❤️❤️前言~🥳🎉🎉🎉 hellohello~，大家好💕💕，这里是E绵绵呀✋✋ ，如果觉得这篇文章还不错的话还请点赞❤️❤️收藏💞 💞 关注💥💥，如果发现这篇文章有问题的话，欢迎各位评论留言指正，大家一起加油！一起chin up！👍👍 💥个人主页：E绵绵的博客
💥所属专栏：JAVASE题目练习 JAVASE知识点专栏 c语言知识点专栏 c语言题目练习
在String类的第二部分中我们将给大家介绍如何真正修改字符串内容以及讲解一些题目。
那么开始吧！
字符串修改 ❤️❤️注意：尽量避免直接对String类型对象进行修改，因为String类是不能修改的，我们对其修改都会创建新对象，导致效率非常低下。 所以我们这就出现了StringBuilder类或者StringBuffer类。
下面我们拿StringBuilder类举例：
如上图其类内部也包含着数组，但其修饰并不是用private以及final修饰，所以其内部可以被修改，当我们修改该类对象时，不会创建新对象而是修改原本的对象的值。所以用它修改字符串时效率较高。
下面请看实例
public class Main { public static void main(String[] args) { long start = System.currentTimeMillis(); String s = ""; for(int i = 0; i &lt; 10000; ++i){ s += i; } long end = System.currentTimeMillis(); System.out.println(end - start); //直接修改String类对象所用时间 start = System.currentTimeMillis(); StringBuffer sbf = new StringBuffer(""); for(int i = 0; i &lt; 10000; ++i){ sbf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7fba4474d4bac46831855adecbe0a21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ab8233100711492b18629c6074cf1d9/" rel="bookmark">
			文心一言4.0、智谱清言、MoonshotAI实测对比（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
前两天看到这张图，又刚好拿到了文心一言的4.0内测号，就想着把新版国内御三家横向对比测评一下。
文末领取免费领取AI学习基地 +AI交流群 前一段时间也一直在研究复杂提示词（结构化提示词）向国内大模型迁移适配的问题，索性一起做了。
第一部分：测评机制
一、测评目标
测评三家国产大模型，以同组提示词下ChatGPT 4.0生成的内容做对标参照
智谱清言
文心一言 4.0
Kimi Chat
二、能力考量
复杂提示词理解和执行（结构化提示词）
推理能力（CoT表现）
文本生成能力（写作要求执行）
提示词设计能力（让模型设计提示词）
长文本归纳总结能力（论文阅读）
三、测评轮次
第一轮：复杂提示词理解和执行
任务一：Markdown+英文title 提示词测试，1个任务4个模型（4次）
任务二：Markdown+中文title 提示词测试，1个任务4个模型（4次）
任务三：中文title+自然段落 提示词测试，1个任务4个模型（4次）
第二轮：推理能力（CoT表现）
逐步推理任务，遍历3个不同类型任务+4个大模型（12次）
第三轮：文本生成能力（写作要求执行）
根据提示词生成文本任务，遍历3个不同类型任务+4个大模型（12次）
第四轮：提示词设计能力（让模型设计提示词）
按提示词要求生成提示词，逐步推理任务，遍历3个不同类型任务+4个大模型（12次）
第五轮：长文本归纳总结能力（论文阅读）
按提供的长文本（上传或在线）进行归纳总结，逐步推理任务，遍历3个不同类型任务+4个大模型（12次）
四、结果评估
根据模型能力考量维度和每轮测试目的主观评价，仅供参考。
在对每个环节生成内容的评价当中，我会统一使用绿色来表现模型执行优秀的部分，用红色来表现模型执行度较差的部分。
个人认为在这里设置所谓客观的权重和分值没有太大参考意义，对模型表现感兴趣的话，各位还是看具体测试内容和细节评价吧。
第二部分：测评过程
下面的内容会比较冗长、繁琐。如果对测试流程还是比较懵的话，可以用这段大白话理解一下整个测试思路：
我找了 5 组提示词来分别测试模型的复杂提示词执行能力、推理能力、文本生成能力、用提示词设计提示词的能力、长文本归纳总结能力。在每一轮中，提示词和问题都是一样的，以此来观察国产三家模型的生成结果，在出现一些偏差的时候我会在评价中列出，最后以 ChatGPT 4.0 生成的内容来做一个对照参考。（把 ChatGPT4.0 做为标杆应该大家都没什么异议吧，何况很多国产模型也宣布过已经超越了它，可以具体看看。）
迭个护甲：本测评是主观需求主观视角。不具有权威性、不具有权威性、不具有权威性。
第一轮：复杂提示词理解和执行
任务一：Markdown+英文模块标题撰写的结构化提示词
这是一个要求用逐步推理的结构化提示词推理一个逻辑题的任务
测试提示词
Markdown
# Role : 逐步推理思考者
## Profile :
- **author**: 小七姐
- **version**: 1.3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ab8233100711492b18629c6074cf1d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b16b96a6a39fba466262cae6293bcbb4/" rel="bookmark">
			【java数据结构】泛型的初步认识（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言~🥳🎉🎉🎉 hellohello~，大家好💕💕，这里是E绵绵呀✋✋ ，如果觉得这篇文章还不错的话还请点赞❤️❤️收藏💞 💞 关注💥💥，如果发现这篇文章有问题的话，欢迎各位评论留言指正，大家一起加油！一起chin up！👍👍 💥个人主页：E绵绵的博客
💥所属专栏：JAVA知识点专栏 JAVA题目练习 c语言知识点专栏 c语言题目练习
这篇文章我们将继续介绍泛型，相比于上一篇文章，这篇文章内容更深，更难理解。还请好好阅读消化。
参考文章：Java 中的泛型（两万字超全详解）_java 泛型-CSDN博客 🎯🎯泛型绝对要注意的一点 🎯🎯在java中，我们无法直接实例化泛型的类型参数对象. 如存在&lt;T&gt;，我们就不能new T（）或者new T[]等等，凡是牵扯到创建T相关的对象都会报错。
而之所以该行为会报错是因为它牵扯了类型擦除这个很深层的知识点，那么我们来看下类型擦除是什么吧。
类型擦除 类型擦除的定义 在Java中，类型擦除是指在编译时期对泛型类型进行擦除，将泛型类型转换为原始类型。（原始类型大部分情况下都是Object类）
❤️❤️换而言之，泛型信息只存在于代码编译阶段，在代码编译结束后，与泛型相关的信息会被擦除掉替换为原始类型，专业术语叫做类型擦除。也就是说，成功编译过后的 class 文件中不包含任何泛型信息，泛型信息不会进入到运行时阶段。这样做的目的是为了保持与旧版本的Java代码的兼容性。
这有一个例子能验证编译时泛型会进行类型擦除，假如我们给 ArrayList 集合传入两种不同的数据类型，并比较它们的类信息:
public class GenericType { public static void main(String[] args) { ArrayList&lt;String&gt; arrayString = new ArrayList&lt;String&gt;(); ArrayList&lt;Integer&gt; arrayInteger = new ArrayList&lt;Integer&gt;(); System.out.println(arrayString.getClass() == arrayInteger.getClass());// true } } 在这个例子中，我们定义了两个 ArrayList 集合，不过一个是 ArrayList&lt; String&gt;，只能存储字符串。一个是 ArrayList&lt; Integer&gt;，只能存储整型对象。我们通过 arrayString 对象和 arrayInteger 对象的 getClass() 方法获取它们的对象信息并比较，发现结果为true。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b16b96a6a39fba466262cae6293bcbb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71b6d46afacf084a6ac18d670be0f0ac/" rel="bookmark">
			【坑】Android Studio占用CPU过高问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 终端直接输入top回车：
如图所示，打开Android Studio后没多久，CPU占用飙到了1281%，CPU表示干麻了，同时Android Studio卡成一坨了，勉强弹出个提示框大概意思就是堆heap空间爆满了。
看了下配的堆大小，只配了1G，完全不够用，不够用了就会疯狂占用CPU，所以只需要把堆改大点就OK了。
首先Ctrl+Shift+A ，搜索Memory Settings，然后点击进去堆内存大小设置界面
把IDE max heap size 改大点，默认是1280MB，根据电脑情况改，我是直接改成了4096MB
点击OK，大功告成，又可以愉快的掉头发了！
如果解决了您的问题，点赞+关注是对我最大的支持，谢谢！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1aff76424614a601387d2de0fb5a156c/" rel="bookmark">
			如何看待AIGC技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言如何看待AIGC技术AIGC可以应用到哪些领域 欢迎来到 请回答1024 的博客 🍓🍓🍓欢迎来到 请回答1024的博客
关于博主： 我是 请回答1024，一个追求数学与计算的边界、时间与空间的平衡，0与1的延伸的后端开发者。
博客特色： 在我的博客中，开设了如下专栏(点击可以进入专栏奥~): Java、MySQL、Redis、Spring、SpringBoot、SpringCloud、RabbitMQ、微服务、分布式 等相关技术专栏。期待与您一起，探索编程世界中的发现和创新之旅。
🍎🍎🍎我的主页 : https://reply1024.blog.csdn.net
敬请期待定期更新、见解和教程！让我们一起踏上这段编码冒险之旅！
数学与计算的边界 时间与空间的平衡 0与1的延伸 前言 AIGC（人工智能增强智能控制）技术是指将人工智能与传统的智能控制技术相结合，以提高系统的智能化水平和性能。这种技术通常应用于自动化领域，如工业控制、智能制造、智能交通等。
AIGC 技术的主要特点包括：
智能化决策： AIGC 技术利用人工智能算法对系统进行建模和预测，从而实现智能化的决策和控制。通过对大量数据的学习和分析，系统能够做出更加准确和智能的决策。
适应性和灵活性： AIGC 技术能够根据环境的变化和需求的不同进行自适应调整，具有较强的灵活性。它可以根据实时数据和反馈信息进行调整，以满足不同的控制要求。
优化性能： AIGC 技术能够通过优化算法和控制策略，提高系统的性能和效率。它可以在保证系统稳定性的前提下，最大程度地提升系统的输出性能。
智能化监控与维护： AIGC 技术还可以实现对系统的智能化监控和维护。通过对系统状态的实时监测和分析，可以及时发现问题并采取措施进行修复，从而提高系统的可靠性和可用性。
AIGC 技术通过将人工智能与传统的智能控制技术相结合，实现了智能化、适应性强、性能优化等特点，为各种自动化系统的控制和管理带来了新的可能性和机遇。
如何看待AIGC技术 AIGC 技术的出现为自动化系统带来了新的可能性和机遇，但也需要在实际应用中进行全面的评估和考量。以下是一些可以考虑的方面：
潜在优势： AIGC 技术能够结合人工智能的算法和传统智能控制技术，实现智能化决策、适应性调整和性能优化等功能，有望提高系统的效率、稳定性和可靠性。
应用领域： 需要根据具体的应用场景和需求来评估 AIGC 技术的适用性。它可能更适用于需要复杂决策和灵活性的领域，如智能制造、智能交通、智能能源管理等。
技术挑战： AIGC 技术在实际应用中可能面临一些挑战，如算法的复杂性、数据的质量和实时性、系统的可扩展性等。需要克服这些挑战才能实现技术的有效应用。
安全和可靠性： 在引入 AIGC 技术时，需要重视系统的安全性和可靠性。智能决策可能会受到数据质量、算法错误等因素的影响，需要采取措施确保系统的稳定运行和数据的安全性。
人机协同： AIGC 技术通常是人机协同的一部分，需要在人类专业知识和经验的指导下进行决策和控制。因此，需要考虑人机协同的方式和机制，确保人类和机器能够有效地合作。
AIGC 技术有着广阔的应用前景，但也需要认真评估其优势、挑战和安全性等方面，以确保其在实际应用中能够发挥出最大的效益。
AIGC可以应用到哪些领域 AIGC 技术可以应用于许多领域，其中包括但不限于以下几个方面：
智能制造： 在制造业中，AIGC 技术可以用于优化生产过程、提高生产效率和质量，实现智能化的生产调度和设备控制，以及实现智能物流和供应链管理。
智能交通： 在交通领域，AIGC 技术可以应用于交通流量优化、智能交通信号灯控制、交通拥堵预测和管理、智能驾驶等方面，以提高交通系统的效率和安全性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1aff76424614a601387d2de0fb5a156c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/395/">«</a>
	<span class="pagination__item pagination__item--current">396/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/397/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>