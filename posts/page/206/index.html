<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7dc5a057879033638eaeb5097bf4e44/" rel="bookmark">
			Android中的适配器，你知道是做什么的吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😄作者简介： 小曾同学.com,一个致力于测试开发的博主⛽️，主要职责：测试开发、CI/CD，日常还会涉及Android开发工作。
如果文章知识点有错误的地方，还请大家指正，让我们一起学习，一起进步。 😊 座右铭：不想当开发的测试，不是一个好测试✌️。
热衷分享，喜欢原创，如果觉得博主的文章还不错的话，还请点赞、收藏哦！👍
番外
对了，如果你需要算力，那么这篇文章一定对你有用哦！东方国信“幕僚智算”算力云。
文章目录 一 收获二 适配器简介三 适配器的主要职责四 Android中适配器的实现类五 适配器的简单使用 一 收获 通过本篇文章您将了解到 Android 中适配器（Adapter）的作用、常见适配器实例及适配器的简单使用。
二 适配器简介 适配器是一种用于提供数据和管理视图展示的组件，适配器充当数据源与显示视图之间的桥梁，它负责将数据转换为适合显示在用户界面上的视图，并将用户界面上的操作反馈回数据源。
适配器在许多 UI 组件中起到重要的作用，最常见的是在 ListView、RecyclerView、Spinner 等控件中使用。
三 适配器的主要职责 适配器的主要职责包括以下几个方面：
数据绑定：适配器负责将数据源中的数据与视图进行绑定。它将数据源中的每个项（例如，列表中的一项）与视图的子项进行关联。创建视图：适配器负责根据定义的布局文件创建视图。它会根据数据源的项数动态创建视图，并为每个视图设置相应的数据。视图重用：为了提高性能和节省内存，适配器会利用视图的重用机制。当滚动列表或回收视图时，适配器会重用之前创建的视图，而不是每次都创建新的视图。提供数据数量：适配器会告知 UI 组件有多少个数据项需要展示。这个信息用于确定 UI 组件的大小和滚动范围。事件处理：适配器可以处理用户与视图的交互事件，例如点击列表项或选择下拉列表中的项，并在事件发生时更新数据源。 四 Android中适配器的实现类 ArrayAdapter：用于将数据与 ListView 或 Spinner 组件进行绑定的适配器。它使用数组或列表作为数据源，并将每个数据项与系统提供的默认布局（例如 android.R.layout.simple_list_item_1）进行绑定。BaseAdapter：这是一个抽象类，提供了实现自定义适配器的基本骨架。继承 BaseAdapter 可以实现更灵活和自定义的适配器。它需要开发人员自行实现一些方法，如 getView、getCount、getItem 和 getItemId 等。RecyclerView.Adapter：用于将数据与 RecyclerView 组件进行绑定的适配器。RecyclerView 是一个更灵活和高度可定制的列表视图，适配器是实现 RecyclerView 的关键组件。RecyclerView.Adapter 需要开发人员自行实现一些方法，如 onCreateViewHolder、onBindViewHolder 和 getItemCount 等。PagerAdapter：用于将数据与 ViewPager 组件进行绑定的适配器。ViewPager 是一个可滑动的视图容器，PagerAdapter 用于提供 ViewPager 的页面内容。PagerAdapter 需要开发人员自行实现一些方法，如 instantiateItem、destroyItem 和 getCount 等。 五 适配器的简单使用 根据不同的 UI 组件和需求，Android 提供了各种类型的适配器的实现类，，例如 ArrayAdapter、BaseAdapter、RecyclerView.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7dc5a057879033638eaeb5097bf4e44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2a51c8fa86c29197ed20fe4374c7dc9/" rel="bookmark">
			人工智能--目标检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到 Papicatch的博客
文章目录
🍉引言
🍉概述
🍈目标检测的主要流程通常包括以下几个步骤
🍍数据采集
🍍数据预处理
🍍特征提取
🍍目标定位
🍍目标分类
🍈目标检测在许多领域都有广泛的应用
🍍自动驾驶
🍍安防监控
🍍工业检测
🍈目标检测技术仍面临一些挑战
🍉 区域卷积神经网络
🍈介绍
🍈R-CNN 的详细工作原理
🍍工作流程
🍌候选区域生成
🍌特征提取 🍈关键技术要点
🍈R-CNN 的优点详细分析 🍍高精度检测
🍍 灵活性和通用性
🍍推动技术发展
🍈R-CNN 的局限性
🍍计算效率低下
🍍训练流程复杂
🍍候选区域质量依赖
🍍检测速度慢
🍈R-CNN 的影响和发展
🍍影响
🍌检测效果好
🍌奠定研究基础
🍍发展
🍉YOLO 卷积神经网络
🍈YOLO 的主要工作原理如下
🍈YOLO 系列算法在不断发展和改进。例如，YOLO v3 相比之前的版本有一些改进和特点
🍈YOLO 算法的优点包括
🍈YOLO 算法的局限性包括 🍉 单发多框架检测SSD
🍈其主要流程如下
🍍特征提取
🍍生成锚框
🍍类别和边界框预测
🍍筛选和调整
🍈SSD 算法的一些优点包括
🍈SSD 算法的一些局限性包括
🍉 示例
🍈代码分析
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2a51c8fa86c29197ed20fe4374c7dc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f173c7360ee5203d0f4f73a4bb742df6/" rel="bookmark">
			安卓实现微信聊天气泡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一搜没一个能用的，我来：
布局文件：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;TextView android:id="@+id/history_time" app:layout_constraintTop_toTopOf="parent" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" android:text="05月25日 22:14" android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt; &lt;com.xmkjsoft.xhgh.self.CircularImageView android:src="@color/main_color" android:id="@+id/head_img" app:layout_constraintTop_toBottomOf="@id/history_time" app:layout_constraintLeft_toLeftOf="parent" android:layout_width="40dp" android:layout_height="40dp"/&gt; &lt;!-- 聊天气泡中的内容，如文本、图片等 --&gt; &lt;TextView app:layout_constraintTop_toTopOf="@id/head_img" app:layout_constraintLeft_toRightOf="@id/head_img" app:layout_constraintRight_toRightOf="parent" android:background="@drawable/left_chat_bubble" android:layout_marginRight="20dp" android:id="@+id/message_text_left" android:layout_width="0dp" android:paddingLeft="20dp" android:paddingTop="5dp" android:paddingBottom="5dp" android:layout_height="wrap_content" android:text="这是一个左这是一个左这是一个左这是一个这是一个左这是一个左这是一个一个这是一个左这是一个左" android:textColor="@color/white" android:textSize="16sp" /&gt; &lt;!--右消息--&gt; &lt;com.xmkjsoft.xhgh.self.CircularImageView android:layout_marginTop="20dp" android:src="@color/main_color" android:id="@+id/head_img_right" app:layout_constraintTop_toBottomOf="@id/message_text_left" app:layout_constraintRight_toRightOf="parent" android:layout_width="40dp" android:layout_height="40dp"/&gt; &lt;!-- 聊天气泡中的内容，如文本、图片等 --&gt; &lt;TextView app:layout_constraintTop_toTopOf="@id/head_img_right" app:layout_constraintRight_toLeftOf="@id/head_img_right" app:layout_constraintLeft_toLeftOf="parent" android:background="@drawable/right_chat_bubble" android:layout_marginLeft="20dp" android:id="@+id/message_text_right" android:layout_width="0dp" android:paddingRight="10dp" android:paddingLeft="10dp" android:paddingTop="5dp" android:paddingBottom="5dp" android:layout_height="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f173c7360ee5203d0f4f73a4bb742df6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cee0295d05cdb05b67f887b3b31eb67/" rel="bookmark">
			分享12个免费AI一键生成PPT的网站【2024年最新】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 PPT（PowerPoint 演示文稿）在商务、教育和各种演讲中都是不可或缺的工具，但要设计出既吸引人又能有效传达信息的PPT却并非易事。在这个过程中，选择合适的工具能够大大提高效率。随着AI技术的进步，制作PPT变得更加简便和有趣。今天，小编就给大家推荐几款免费AI一键生成PPT的网站。
二、一键生成PPT的网站 1. ChatGAI 传送入口：ChatGAi
推荐指数：⭐⭐⭐⭐⭐
每天2次免费生成和下载，不仅能生成ppt大纲，模板也不少，还能在线编辑
根据自己的需要生成ppt大纲，接着挑选喜欢的PPT风格一键生成
生成之后可以直接在线编辑（这个功能真的太棒了）
下载后如下：
2. 轻竹AIPPT 传送入口：http://u6v.cn/6hq9Fs
推荐指数：⭐⭐⭐⭐⭐
免费不限次数生成PPT模板
例如：写一份Python答辩PPT
如果对模板不满意，还可以切换其他PPT模板
3. ChatPPT 传送入口：chat-ppt
推荐指数：⭐⭐⭐⭐⭐
通过上面的“传送入口”参与活动就有3天SVIP，相当于免费使用，并且普通用户每天也可以免费生成20张ppt
输入你的PPT主题即可快速一键生成文档，或下载官方插件，体验更丰富的创作功能
4. AIPPT 传送入口：AiPPT - 全智能 AI 一键生成 PPT
推荐指数：⭐⭐⭐⭐⭐
每天有2次可以免费生成
简单输入自己想要的PPT主题或内容大纲，AI助手会快速生成PPT下详细大纲
接着挑选喜欢的PPT风格一键生成
5. Kimi PPT助手 传送入口：https://chat.tomyres.com/#/pages/web/index?n=kimi
推荐指数：⭐⭐⭐⭐⭐
kimi是一款国产的AI问答产品，支持生成PPT大纲在内等多种场景，并且完全免费
6. 笔灵PPT 传送入口：PPT AI生成工具- 免费在线AI PPT生成器-笔灵AI写作
推荐指数：⭐⭐⭐⭐
笔灵PPT专注于AI毕业论文写作、AI毕业设计和生成AI答辩PPT，1分钟快速生成精美PPT+千字自述稿件。免费生成PPT大纲
7. 讯飞智文 传送入口：讯飞智文 - AI在线生成PPT、Word (xfyun.cn)
推荐指数：⭐⭐⭐⭐⭐
讯飞智文是由科大讯飞推出的一键生成ppt/word产品。根据一句话、长文本、音视频等指令智能生成文档，同时支持在线编辑、美化、排版、导出、一键动效、自动生成演讲稿等功能。目前这个工具是完全免费使用的。
例如：生成一份IT行业年终总结汇报
选择想要的模板并生成PPT
8. iSlide PPT 传送入口：iSlide- 让PPT设计简单起来 | PPT模板下载平台
推荐指数：⭐⭐⭐⭐⭐
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cee0295d05cdb05b67f887b3b31eb67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e68a18bcd72819b45ba6c1a095d18e0/" rel="bookmark">
			【C&#43;&#43;】string基本用法（常用接口介绍）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、string介绍二、string类对象的创建（常见构造）三、string类对象的容量操作1.size()和length()2.capacity()3.empty()4.clear()5.reserve()6.resize() 四、string类对象的遍历与访问1.operator[ ]2.正向迭代器begin()和end()3.反向迭代器rbegin()和rend()4.const正向和反向迭代器5.范围for6.at() 五、string类对象的查找与修改字符串查找1.find()与npos2.rfind()3.find_first_of()和find_last_of()4.substr() 字符串修改1.operator+=2.push_back()与pop_back()3.append()4.insert()5.erase()6.replace() 六、string类非成员函数operator+输入getline 一、string介绍 string是表示字符串的字符串类。它提供了一系列成员函数和操作符，使得字符串的操作更加方便和灵活。它位于标准命名空间std下，因此通常需要使用using namespace std;语句或者前缀std::来引用。
string是C++的STL(standard template libaray-标准模板库)的容器之一。本篇，我们主要介绍string的基本用法。所有接口用法都可以在cplusplus参考手册中查阅。下面我们主要介绍string的一些常用接口。
string底层实际是basic_string类模板的实例化，是表示字符串类型的模板类。
二、string类对象的创建（常见构造） string重载了很多构造和拷贝构造函数，其实常用的也就4种。
//常用构造方式 string s1;//无参构造 string s2("interesting");//构造 string s3(s2);//拷贝构造 string s4 = "hello world";//构造 不常用的初始化方式
//函数原型 string (size_t n, char c); string s5(10, 'x');//10个字符x //函数原型 string (const string&amp; str, size_t pos, size_t len = npos); string s6(s2, 8, 3);//打印ing 第8个位置开始拷贝3个字符 string s7(s2, 8);//打印ing 第8个位置开始拷贝后面所有字符 三、string类对象的容量操作 1.size()和length() 计算有效字符串长度，不包括\0。 size()与length()的底层实现原理完全相同，引入size()的原因是为了与其他容器的接口保持一致，一般情况下基本都是用size()。
int main() { string s("abcde"); cout &lt;&lt; s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e68a18bcd72819b45ba6c1a095d18e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b48b261b408d340d0cfb186a309fb53/" rel="bookmark">
			4PCS点云配准算法实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4PCS点云配准算法的C++实现如下：
#include &lt;iostream&gt; #include &lt;pcl/io/pcd_io.h&gt; #include &lt;pcl/point_types.h&gt; #include &lt;pcl/common/common.h&gt; #include &lt;pcl/common/distances.h&gt; #include &lt;pcl/common/transforms.h&gt; #include &lt;pcl/search/kdtree.h&gt; struct Points4 { pcl::PointXYZ p1; pcl::PointXYZ p2; pcl::PointXYZ p3; pcl::PointXYZ p4; }; int compute_LCP(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; cloud, pcl::search::KdTree&lt;pcl::PointXYZ&gt;::Ptr kdtree, float radius) { std::vector&lt;int&gt;index(1); std::vector&lt;float&gt;distance(1); int count = 0; for (size_t i = 0; i &lt; cloud.size(); i++) { kdtree-&gt;nearestKSearch(cloud.points[i], 1, index, distance); if (distance[0] &lt; radius) count = count + 1; } return count; } int main(int argc, char** argv) { pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr source_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;); pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr target_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;); pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr pcs_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;); pcl::io::loadPCDFile("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b48b261b408d340d0cfb186a309fb53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ce0196c0aef1ba1ab95a222b39454f1/" rel="bookmark">
			【LLM教程-llama】如何Fine Tuning大语言模型？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给大家带来了一篇超级详细的教程,手把手教你如何对大语言模型进行微调(Fine Tuning)！（代码和详细解释放在后文）
目录
大语言模型进行微调(Fine Tuning)需要哪些步骤？
大语言模型进行微调(Fine Tuning)训练过程及代码
大语言模型进行微调(Fine Tuning)需要哪些步骤？ 大语言模型进行微调(Fine Tuning)的主要步骤🤩
📚 准备训练数据集
首先你需要准备一个高质量的训练数据集,最好是与你的应用场景相关的数据。可以是文本数据、对话数据等,格式一般为JSON/TXT等。
📦 选择合适的基础模型
接下来需要选择一个合适的基础预训练模型,作为微调的起点。常见的有GPT、BERT、T5等大模型,可根据任务场景进行选择。
⚙️ 设置训练超参数
然后是设置训练的各种超参数,比如学习率、批量大小、训练步数等等。选择合理的超参数对模型效果影响很大哦。
🧑‍💻 加载模型和数据集
使用HuggingFace等库,把选定的基础模型和训练数据集加载进来。记得对数据集进行必要的前处理和划分。
⚡ 开始模型微调训练
有了模型、数据集和超参数后,就可以开始模型微调训练了!可以使用PyTorch/TensorFlow等框架进行训练。
💾 保存微调后的模型
训练结束后,别忘了把微调好的模型保存下来,方便后续加载使用哦。
🧪 在测试集上评估模型
最后在准备好的测试集上评估一下微调后模型的效果。看看与之前的基础模型相比,是否有明显提升?
大语言模型进行微调(Fine Tuning)训练过程及代码 那如何使用 Lamini 库加载数据、设置模型和训练超参数、定义推理函数、微调基础模型、评估模型效果呢？
首先，导入必要的库 import os import lamini import datasets import tempfile import logging import random import config import os import yaml import time import torch import transformers import pandas as pd import jsonlines from utilities import * from transformers import AutoTokenizer from transformers import AutoModelForCausalLM from transformers import TrainingArguments from transformers import AutoModelForCausalLM from llama import BasicModelRunner 这部分导入了一些必需的Python库,包括Lamini、Hugging Face的Datasets、Transformers等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ce0196c0aef1ba1ab95a222b39454f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26368f4b5bee1942881b84c26b2233dc/" rel="bookmark">
			C语言之线程的学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程属于某一个进程
共同点：都能并发
线程共享变量，进程不共享。
多线程任务中，其中某一个线程调用了exit了，其他线程会跟着一起退出
如果是特定的线程就调用pthread_exit
失败返回的是错误号
下面也是
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75991fe33085af10ca6d8f5c8a772ac0/" rel="bookmark">
			【Llama 2的使用方法】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Llama 2是Meta AI（Facebook的母公司Meta的AI部门）开发并开源的大型语言模型系列之一。Llama 2是在其前身Llama模型的基础上进行改进和扩展的，旨在提供更强大的自然语言处理能力和更广泛的应用场景。
以下是Llama 2的一些关键特性和更新点：
模型规模：
Llama 2提供了三种不同规模的模型：7B、13B和70B参数版本，以适应不同计算资源和应用需求。 训练数据量：
Llama 2的训练数据集比前一代模型更加庞大，包含了大约2万亿个token，这使得模型能够理解更复杂的语言模式和更长的文本序列。 上下文长度：
上下文长度从2048增加到了4096，这意味着模型可以处理更长的文本输入，这对于长文档的理解和生成尤为重要。 模型架构：
Llama 2的架构基于标准的Transformer解码器，但有一些特定的优化，比如使用RMSNorm代替LayerNorm，以及在Q与K相乘前使用RoPE（Rotary Positional Embedding）进行位置编码，以增强模型对位置信息的敏感度。 许可和使用：
Llama 2具有商业许可，允许企业和个人在研究和商业项目中使用该模型。 安全性与伦理考量：
Meta AI在设计和训练Llama 2时考虑了模型的安全性和伦理问题，以减少有害输出的可能性。 性能：
在多种基准测试上，Llama 2表现出色，能够处理广泛的自然语言处理任务，包括但不限于问答、文本生成、翻译等。 使用Llama 2模型涉及几个步骤，从获取模型到将其部署并整合到你的应用程序中。下面是一个基本的流程：
1. 获取模型权重 首先，你需要下载Llama 2的模型权重。这些权重文件通常很大，因此请确保你有足够的存储空间。你可以从Meta AI的官方GitHub仓库或者通过他们提供的链接下载模型。
2. 准备环境 确保你的开发环境配置正确，这可能包括安装必要的Python库，如transformers和torch。例如，你可以使用pip来安装transformers：
pip install transformers torch 3. 加载模型 使用transformers库中的AutoModelForCausalLM和AutoTokenizer来加载模型和相应的分词器。下面是一个示例代码片段：
from transformers import AutoModelForCausalLM, AutoTokenizer model_name = "meta-llama/Llama-2-7b-hf" tokenizer = AutoTokenizer.from_pretrained(model_name) model = AutoModelForCausalLM.from_pretrained(model_name) 4. 文本生成 一旦模型加载完成，你可以使用它来进行文本生成。下面是如何使用模型生成文本的代码示例：
input_text = "Hello, how are you today?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75991fe33085af10ca6d8f5c8a772ac0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99c772023130e505d048faf1631357a7/" rel="bookmark">
			【机器学习】FFmpeg&#43;Whisper：二阶段法视频理解（video-to-text）大模型实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、引言
二、FFmpeg工具介绍
2.1 什么是FFmpeg
2.2 FFmpeg核心原理
2.3 FFmpeg使用示例
三、FFmpeg+Whisper二阶段法视频理解实战
3.1 FFmpeg安装
3.2 Whisper模型下载
3.3 FFmpeg抽取视频的音频
3.3.1 方案一：命令行方式使用ffmpeg
3.3.2 方案二：ffmpeg-python库使用ffmpeg
3.4 Whisper将音频转为文本
3.5 视频理解完整代码
3.6 视频理解模型部署 四、总结
一、引言 上一篇对Whisper原理和实战进行了讲解，第7次拿到了热榜第一🏆。今天，我们在Whisper的基础上，引入ffmpeg工具对视频的音频进行抽取，再使用Whisper将音频转为文本，通过二阶段法实现视频内容的理解。
二、FFmpeg工具介绍 2.1 什么是FFmpeg FFmpeg是一个开源的跨平台多媒体处理工具，它可以处理音频/视频数据，包括转码、转换格式、分割、合并等操作。
2.2 FFmpeg核心原理 多媒体流的解析：FFmpeg能够解析各种常见的多媒体格式，包括MP4, MKV, AVI, MP3, OGG等，并将其转换为FFmpeg内部的统一表示格式，也就是所谓的复用格式（Container Format）和编码格式（Codec）。多媒体流的编码和解码：FFmpeg可以使用不同的编解码器来编码和解码音频/视频数据。例如，它可以使用H.264编码来压缩视频数据，使用AAC编码来压缩音频数据。过滤器（Filters）：FFmpeg提供了一个强大的过滤器系统，可以用来处理视频和音频的各种效果，例如裁剪、裁切、旋转、缩放等。流的复用和解复用：FFmpeg可以将多个音频/视频流合并为一个文件，也可以将一个文件分离成多个音频/视频流。并行处理：FFmpeg利用多线程技术，可以并行处理多个任务，比如同时进行多个转码操作。 2.3 FFmpeg使用示例 ffmpeg -i input.mp4 -vn -ar 44100 -ac 2 -ab 192k -f mp3 output.mp3 -i input.mp4 指定输入文件。-vn 表示禁用视频录制。-ar 44100 设置采样率为44.1kHz。-ac 2 设置声道数为2（立体声）。-ab 192k 设置比特率为192k。-f mp3 设置输出格式为MP3。output.mp3 是输出文件的名称。 三、FFmpeg+Whisper二阶段法视频理解实战 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99c772023130e505d048faf1631357a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/955157d72d038f8ecce95c5dcb59bd0b/" rel="bookmark">
			AI在创造还是毁掉音乐？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI在创造还是毁掉音乐？ AI对音乐的影响是一个有争议的话题。一方面，AI技术可以用来创造音乐，为音乐创作带来新的可能性。通过使用机器学习算法，AI可以分析大量的音乐数据，并生成新的音乐作品，这些作品可能会有创造性和惊喜性。
另一方面，一些人认为，AI生成的音乐缺乏人类的情感和灵感，可能缺乏原创性。他们担心AI会把音乐变成一个简单的算法和模式的组合，失去了音乐艺术的真正精髓。此外，一些人还担心AI可能导致音乐产业的集中化，使得少数人能够掌控整个音乐市场。
因此，AI对音乐的影响可以说既有积极的一面，也有负面的一面。虽然AI能够帮助音乐创作变得更加高效和创新，但也需要考虑到人类艺术和创造力的核心价值。最重要的是，无论是人类还是AI，都应该致力于保护和发展音乐的美妙和独特之处。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7603e36dd55673f51f2bfefa14b462c1/" rel="bookmark">
			美团外卖异地点餐怎么更改定位位置信息？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		美团外卖异地点餐怎么更改定位位置信息？
1、打开「词令」关键词口令直达工具，输入词令「外卖红包88」，搜索直达该词令关联的目标，获得外卖红包天天领入口；
2、成功领取后，打开美团外卖APP，切换异地位置，并新增异地地址；
3、添加好异地收货地址后，开始点餐选择可用的美团外卖红包；
4、使用美团外卖红包后，提交订单即可享受券后价优惠点餐成功；
原文来源：https://www.caochai.com/article-5921.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50d80acff61e1938d1d697373b13f2a8/" rel="bookmark">
			SpringBoot中整合ONLYOFFICE在线编辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot整合OnlyOffice SpringBoot整合OnlyOffice实现在线编辑1. 搭建私有的OnlyOffice的服务2. SpringBoot进行交互2.1 环境2.2 我们的流程2.3 接口规划2.3.1 获取编辑器配置的接口2.3.2 文件下载地址2.3.3 文件下载地址 3. 总结4. 注意4.1 你的项目的地址一定一定要和onlyoffice可以正常通讯，如果不行则一直不可能成功。4.2 TOKEN是可以可选项，建议一开始不要使用，后面有需要的时候再去添加。4.3 一定要看一下官网文档，文档真的很全很重要4.4 协同的话只要参数就是一个KEY，如果需要超过20个的限制直接重新编译即可，大神一大堆，很容易就可以找到。 SpringBoot整合OnlyOffice实现在线编辑 公司有一个需求，就是实现 *Word* , *Excel* ,等文件的在线编辑，市场上面进行了多方面的选型，考虑了 *[OpenOffice](https://openoffice.apache.org/)* , *[Office Online](https://www.microsoft.com/zh-cn/microsoft-365/free-office-online-for-the-web?legRedir=true&amp;CorrelationId=13c8a865-b9b0-48ff-b3ed-3ea9ec31cd55)*, 但是最终还是选择了 *[OnlyOffice](https://www.onlyoffice.com/zh/)* 这个产品。 他的一个很大的优势在于开源，支持协同，社区比较活跃。api比较全面，还有中文的文档。还有一点比较好的就是支持协同，并且支持协同，虽然协同在社区版中存在限制，但是支持代码修改，可以重新编译。社区的大佬很多，很赞。唯一遗憾的就是效率比较低，在使用私有对象存储的时候存在延迟。其他的没有使用到，所以不进行评论。中文文档：[https://api.onlyoffice.com/zh/editors/basic](https://api.onlyoffice.com/zh/editors/basic) 1. 搭建私有的OnlyOffice的服务 搭建过程这里就不进行涉猎了，建议使用docker进行搭建，下载官方镜像包即可,（现在dockerhub被墙，自行解决，不建议自己再次打包，因为我在尝试的时候总是出现莫名奇妙的问题可能是我的问题。推荐使用官网原版镜像）。根据官方文档一步步操作即可。搭建过程中，如果是自己玩建议不要开启 **JWT** ，生产环境建议开一下。但是开的成本就是你对接的时候需要获取token然后在进行交互。 2. SpringBoot进行交互 2.1 环境 java： 17
boot: 3.0.5
页面：一个h5页面即可
需要的其他依赖
&lt;!-- ... 其他的依赖自行添加即可，不重要，比如 fastjson2,jackson 等 --&gt; &lt;!-- 这个JAR 主要的作用是与OnlyOffice交互的时候生成token使用的 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.inversoft&lt;/groupId&gt; &lt;artifactId&gt;prime-jwt&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; 2.2 我们的流程 我们使用一个 H5 页面即可，页面通过加载一个 app.js 。然后通过一个 config 进行渲染，就可以实现一个编辑。app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50d80acff61e1938d1d697373b13f2a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fb8a3ae8123fc8af9add3230785d27d/" rel="bookmark">
			怎样把热门抖音短视频下载保存到手机相册?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		怎样把热门抖音短视频下载保存到手机相册?
1、在手机上打开抖音短视频APP；
2、打开后搜索或找到要下载保存的抖音短视频；
3、打开短视频后，点击右则的分享，并滑动找到保存到相册；
4、点击后等待完成下载，即可保存到手机相册，快去手机相册看看吧！
原文来源：https://www.caochai.com/article-5920.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e4bbdf10b48403e3883ec34a9e74d6f/" rel="bookmark">
			MySQL主从复制与读写分离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL 主从复制（Master-Slave Replication） 概念 MySQL 主从复制是一种将一台 MySQL 服务器（主服务器，Master）的变更自动复制到另一台或多台 MySQL 服务器（从服务器，Slave）的机制。主服务器负责处理写操作，从服务器主要用于处理读操作。
工作原理 主服务器记录变更：
主服务器在执行写操作（如 INSERT、UPDATE、DELETE）时，将这些操作记录到二进制日志（binlog）中。binlog 是一种记录所有更改数据库内容的日志文件。 从服务器读取日志：
从服务器有一个 I/O 线程，负责连接到主服务器并读取主服务器的 binlog，然后将其保存到从服务器的中继日志（relay log）中。 从服务器重放日志：
从服务器有一个 SQL 线程，负责读取中继日志并执行日志中的变更操作。这使得从服务器的数据与主服务器保持一致。 配置步骤 在主服务器上启用二进制日志：
[mysqld] log-bin=mysql-bin server-id=1 在从服务器上配置复制参数：
[mysqld] server-id=2 relay-log=relay-log 创建复制用户并授予权限：
CREATE USER 'replica'@'%' IDENTIFIED BY 'password'; GRANT REPLICATION SLAVE ON *.* TO 'replica'@'%'; FLUSH PRIVILEGES; 在从服务器上启动复制：
CHANGE MASTER TO MASTER_HOST='master_host', MASTER_USER='replica', MASTER_PASSWORD='password', MASTER_LOG_FILE='mysql-bin.000001', MASTER_LOG_POS= 4; START SLAVE; 优缺点 优点：
提高读性能：通过增加从服务器，可以分担主服务器的读负载。数据备份：从服务器可以作为数据的实时备份，提高数据的可用性。 缺点：
数据延迟：由于复制过程需要时间，从服务器的数据可能会比主服务器稍有延迟。单点故障：如果主服务器出现故障，需要手动或自动将其中一台从服务器提升为主服务器。 MySQL 读写分离（Read-Write Splitting） 概念 读写分离是将数据库的读操作和写操作分离到不同的数据库实例上进行的策略。通常结合主从复制使用，即主服务器处理写操作，从服务器处理读操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e4bbdf10b48403e3883ec34a9e74d6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cec4cba8b36b0838e2d493de78b79c9/" rel="bookmark">
			ollama，springAi实现自然语言处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ollama安装使用： https://ollama.com/
下载速度比较慢的可以直接使用以下版本0.1.41
https://pan.baidu.com/s/1hCCkYvFjWqxvPyYA2-YElA?pwd=otap 直接管理员身份双击安装，安装成功后会在任务栏里出现这个小图标：
打开cmd，输入ollama --version能够显示ollama版本则证明已经安装完成
输入ollama命令，能够列出帮助命令：
其中常用的有
serve表示后台启动model
create表示从本地medelFile中创建model
run表示启动model，并打开对话框
list表示列出当前所有的model
ps表示列出当前运行的model
rm表示删除model
down Model 在ollama官网中有model仓，我们可以挑选自己需要的model进行下载使用
以阿里通义千问模型为例，我们搜索到qwen2进入到该模型的仓库中。
上面的tag表示不同参数的千问大模型，7b，72b表示大模型版本，后面4.4GB，41GB表示模型大小，即运行时需要占用的GPU/CPU的大小。
右侧ollama run qwen2表示启动命令，如果我们需要拉取并使用7b模型，则只需要在cmd中执行ollama run qwen2:7b 命令，等待下载安装即可（使用的模型越大表示训练的参数越大，精准度越高。同时需要的GPU/CPU就越大，运行反应速度会越慢，需要根据自身需求选择合适的模型进行使用）
使用SpringAi对接ollamahttps://spring.io/projects/spring-ai 首先需要强调的时SpringAi依赖的jdk&gt;=17，springboot版本&gt;=3.0
接下来介绍构建简单的springboot项目，使用springAi调用ollama进行对话
构建一个maven项目，修改pom文件如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;url/&gt; &lt;properties&gt; &lt;java.version&gt;17&lt;/java.version&gt; &lt;spring-ai.version&gt;1.0.0-M1&lt;/spring-ai.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cec4cba8b36b0838e2d493de78b79c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1da4359f07411c79cd84303e70133ed2/" rel="bookmark">
			为什么网络爬虫广泛使用HTTP代理？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言
网络爬虫作为自动抓取互联网信息的重要工具，在现代社会中发挥着不可或缺的作用。然而随着网络环境的日益复杂，网站反爬虫技术的不断进步，网络爬虫在获取数据的过程中面临着越来越多的挑战。为了应对这些挑战，HTTP 代理成为了网络爬虫不可或缺的一部分。本文将从多个角度详细分析网络爬虫为何大量使用 HTTP 代理。
2. HTTP代理在网络爬虫中的作用
HTTP代理在网络爬虫中扮演着多种关键角色，其中最突出的就是其匿名访问和数据传输功能。首先，HTTP代理可以隐藏网络爬虫的真实IP地址，使其以代理服务器的IP地址进行访问。这样，网络爬虫就可以避免被目标网站识别和屏蔽，从而实现对网站的持续访问和数据抓取。其次，HTTP代理还可以中转网络爬虫与目标网站之间的通信数据，使爬虫可以绕过某些限制和防火墙，直接访问原本无法访问的资源。这些特性使得HTTP代理成为网络爬虫应对反爬虫策略的重要工具。
3. 网络爬虫使用HTTP代理的原因分析
应对反爬虫策略
随着网络爬虫技术的不断发展，越来越多的网站开始采用反爬虫策略来限制网络爬虫的访问。这些反爬虫策略包括但不限于IP封锁、验证码验证、用户行为分析等。为了应对这些策略，网络爬虫需要使用HTTP代理来隐藏真实IP地址、模拟用户行为等。通过不断更换代理IP地址，网络爬虫可以规避IP封锁的限制；通过模拟用户行为，网络爬虫可以绕过验证码验证等限制。因此，HTTP代理成为了网络爬虫应对反爬虫策略的重要手段。
实现匿名访问
在数据抓取过程中，网络爬虫需要访问大量的网站和页面，但部分网站可能会对频繁访问的 IP 地址进行限制或屏蔽，导致网络爬虫无法继续访问。为了解决这个问题，网络爬虫需要使用 HTTP 代理来实现匿名访问。通过隐藏真实 IP 地址，使用代理服务器的 IP 地址进行访问，网络爬虫可以避免被目标网站识别和屏蔽，从而实现持续访问网站并抓取数据。
提高数据收集效率
使用HTTP代理后，网络爬虫可以同时通过多个代理IP地址访问并抓取数据，这样网络爬虫就可以实现并发访问和并行处理，从而提高数据采集的效率。同时，由于HTTP代理可以中转通信数据，绕过一定的限制和防火墙，网络爬虫还可以直接访问原本无法访问的资源，从而进一步扩大了数据采集的范围。因此，使用HTTP代理可以大大提高网络爬虫的数据采集效率。
降低运营成本
在某些情况下，网络爬虫需要访问需要付费或特定权限才能访问的资源。如果直接使用真实 IP 地址访问，可能需要购买大量账号或权限才能满足需求。通过使用 HTTP 代理，网络爬虫可以共享代理服务器的账号和权限进行访问，从而降低运营成本。此外，一些优质的 HTTP 代理提供商还提供专业的技术支持和服务保障，可以进一步降低网络爬虫在运营过程中的风险和成本。
4。结论
综上所述，网络爬虫之所以大量使用HTTP代理，主要是因为HTTP代理可以帮助网络爬虫应对反爬虫策略、实现匿名访问、提高数据采集效率、降低运营成本。随着网络环境的不断发展变化，网络爬虫在使用HTTP代理时也需要不断适应新的环境和挑战。因此，对于网络爬虫开发者来说，了解和掌握HTTP代理的原理和使用方法非常重要。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfb2706842072538b47157b255f172e5/" rel="bookmark">
			华为OCR识别技术 [C#]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		了解华为OCR识别技术 光学字符识别（OCR，Optical Character Recognition）是一种将印刷或手写的文本字符转换为机器可读文本的技术。华为的OCR技术在业界以其高精度和高效率而著称，广泛应用于金融、教育、政府等多个领域。
OCR技术原理 OCR技术主要包括以下几个步骤：
图像预处理：对输入的图像进行处理，包括去噪、二值化、倾斜校正等，以提高识别的准确性。文字区域检测：检测并定位图像中的文本区域。字符切分：将检测到的文本区域分割成单个字符。字符识别：将分割后的字符与预先训练好的字符模型进行匹配，识别出字符的具体内容。后处理：对识别结果进行纠错和格式化处理。 华为OCR技术的优势 高识别率：华为OCR技术采用先进的深度学习算法，在多种复杂场景下都能保持高识别率。支持多语言：支持中文、英文、日文等多种语言的文本识别。丰富的API接口：华为OCR提供丰富的API接口，方便开发者集成到自己的应用中。安全可靠：华为OCR技术基于华为云，提供高可靠性和安全性保障。 应用场景 华为OCR技术可以应用于以下场景：
文档数字化：将纸质文档转换为电子文本，方便存储和检索。证件识别：识别身份证、护照、驾照等证件信息，广泛应用于金融、交通等行业。票据识别：识别发票、火车票、机票等票据信息，提高数据录入效率。车牌识别：识别车辆车牌号码，应用于停车场管理、交通监控等场景。 使用华为OCR API进行文本识别 下面，我们将通过一个示例，演示如何使用华为OCR API进行文本识别。我们将使用C#语言进行编程。
准备工作 注册华为云账号：访问华为云官网，注册一个账号。开通OCR服务：在华为云控制台开通OCR服务，获取API密钥。 C#代码示例 下面是一个简单的C#代码示例，演示如何调用华为OCR API进行文本识别。
using System; using System.Net.Http; using System.Net.Http.Headers; using System.Text; using System.Threading.Tasks; using Newtonsoft.Json.Linq; class Program { private static async Task&lt;string&gt; GetOCRResult(string imageBase64, string apiKey, string apiSecret) { string url = "https://ocr.cn-north-4.myhuaweicloud.com/v2/{project_id}/ocr/general-text"; using (var client = new HttpClient()) { client.DefaultRequestHeaders.Add("X-Auth-Token", apiKey); client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json")); var requestBody = new { image = imageBase64 }; var content = new StringContent(JObject.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfb2706842072538b47157b255f172e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2be944ee2ed0dc5765f612e29a1d7d4/" rel="bookmark">
			企业级-工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：fyupeng
技术专栏：☞ https://github.com/fyupeng
项目地址：☞ https://github.com/fyupeng/distributed-blog-system-api
留给读者
相信大家在工作中都会遇到各种各种繁琐、简单但耗时的问题，那么可能有以下的工具可以解决你存在的问题。
一、介绍 推荐排行： 1、PostMan ：
为什么提供这款浏览器，主要方面解决登录cookiee在其他比如PostMan和ApiPost遇到请求不方便的情况；
2、划词翻译：
对于能编写可读性较强的代码，很考验程序员的英语能力，所以我比较喜欢使用快捷键直接翻译；
3、XmlView：
这是一款能将xml字符串转成智能缩进、可读性比较高的页面，而且能检测是否是有效的XML字符串；
4、tampermonkey:
油猴，根据自己需要添加更多浏览器插件；
5、json-lite: json格式化工具，也能检查字符串是否为有效json。
6、老馒头修图网： http://www.laomantou.net/
7、iconfont： https://www.iconfont.cn//
8、Pixabay： https://pixabay.com/
9、在线简历编辑： https://new.polebrief.com/edit
10、GUID生成器： https://www.guidgen.com/
11、开发者搜索： https://kaifa.baidu.com/
12、草料二维码生成器： https://cli.im/url
12、草料二维码生成器： https://cli.im/url
13、在线插件下载： https://www.youxiaohou.com/download.html
14、在线Cerno生成： http://sfz.fatcarter.cn/
15、摸鱼导航： https://moyu.games/
16、在线Unicode编码转换： http://www.jsons.cn/unicode/
17、Base64转Pdf： https://www.ipvoid.com/base64-to-pdf/
18、编程平台激活： https://www.exception.site/
19、WebSock在线调试： http://www.websocket-test.com/
20、在线Html格式化： https://www.wetools.com/html-formatter
21、在线Html格式化： https://www.uugai.com/
22、免费Logo在线设计： https://www.uugai.com/
23、SQL格式化： https://1024tools.com/sqlformat
23、Maven 仓库： https://mvnrepository.com/
24、Maven Central 仓库： https://search.maven.org/
二、附 浏览器插件工具链接：https://pan.baidu.com/s/1CxIMTLVvIZxK7dWyDl594g?pwd=gxau
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f742bdfba2e7db80b0b01f7bb16686d8/" rel="bookmark">
			分享10个很酷、简单且有趣的 Python 项目及其源代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无论我们当前的技能水平如何，学习构建 Python 项目都是提高个人技能和增强作品集的必由之路。没有什么比亲自动手进行一些实际编码和构建 Python 项目更好的了！在本文中，我们收录了 10 个有趣的 Python 项目，从适合初学者的简单 Python 项目到中级和高级 Python 项目，我们可以利用它们来挑战自己或提高 Python 编程技能。
适合初学者的 Python 项目 让我们开始为初学者提供一系列项目，如果您刚刚开始并且想要学习 Python，那么这是理想的选择。换言之，如果您渴望从事更具挑战性的事情，请阅读本文后面内容以查看更高级的项目。
1.Dice Roll Generator Dice Roll Generator（本文译为掷骰子生成器）作为与代码初学者最相关的 Python 项目之一，该程序模拟掷一两个骰子。这也是巩固对用户定义函数、循环和条件语句的理解的好方法。这些是 Python 初学者的基本技能，并且可能是您首先要学习的一些东西，无论是从在线课程还是Python 书籍中。
作为简单的 Python 项目之一，它是一个相当简单的程序，使用 Python random 模块来复制掷骰子的随机性质。您可能还会注意到，在掷骰子后，使用 os 模块来清除屏幕。请注意，可以将最大骰子值更改为任意数字，从而允许模拟许多棋盘游戏和角色扮演游戏中常用的多面体骰子。
源代码：
''' Dice Roll Generator ------------------------------------------------------------- ''' import random import os def num_die(): while True: try: num_dice = input('Number of dice: ') valid_responses = ['1', 'one', 'two', '2'] if num_dice not in valid_responses: raise ValueError('1 or 2 only') else: return num_dice except ValueError as err: print(err) def roll_dice(): min_val = 1 max_val = 6 roll_again = 'y' while roll_again.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f742bdfba2e7db80b0b01f7bb16686d8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/205/">«</a>
	<span class="pagination__item pagination__item--current">206/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/207/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>