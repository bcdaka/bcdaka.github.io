<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d54470caf4fed9c5c2f6d9014bcf051f/" rel="bookmark">
			【数学建模】介绍论文书写格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页：Yui_
🌈Linux专栏：Linux
🌈C语言笔记专栏：C语言笔记
🌈数据结构专栏：数据结构
文章目录 1.论文整体排版2. 标题书写3.摘要书写4.参考文献5.公式编辑5.1 常用公式编辑方法5.2 公式编辑技巧 6.三线表的制作与编号7. 图片的绘制8.分页符的使用 1.论文整体排版 各级标题与正文层次分明
一般标题级别不超过三级正文中字体设置宋体、英文times new roman
正文排版紧凑，看起来充实，没有大片空白避免图片图片过大导致出现大片空白，且不要留有空行
表格与图片表格用标准的三线表表的标题放在表的上面，图名放在图的下面
公式编辑
推荐mathpix，或者使用word的公式编辑器公式需要解释清楚每个变量的意义；重要的公式后面带有编号。 2. 标题书写 格式：基于xxx模型的xxx问题研究
要求：
读完标题，就能知道文本建立的是什么模型。 简明扼要、符合规范、便于检索尽量使用大家都了解的词语 避免出现公式、非公知公用的缩写字数限制再一行内基于xxx模型的xxx问题研究 xxx模型就是正文里的核心模型xxx问题就是赛题的中心词不要使用过多的修饰词 3.摘要书写 摘要是文章的重点
基本要求：
摘要是对论文的概括总结让评阅老师读完摘要，就知道1本文要解决的问题，建立的模型和求解结果。
注意事项：不要加图或者表格内容控制在3/4页到1页，字数大概在800到1100.
大致模板：
开头段：本文针对xxx问题，通过建立了xxx模型，实现了xxx的求解。
针对问题一，考虑到xxx，…，建立xxx模型/利用xxx方法，…，求解出xxx。
针对问题二，考虑到xxx，…，建立xxx模型/利用xxx方法，…，求解出xxx。
针对问题三，考虑到xxx，…，建立xxx模型/利用xxx方法，…，求解出xxx。
总结：总结全文，然后分析一下本文所用模型的优点，自夸一下所写的模型。
关键词：主要模型/算法，或出现频率高的、体现论文针对的问题的词
开头模板：本文主要研究了xxx问题。根据xxx，利用xxx模型/方法，求解出了xxx第一句话：说清研究的问题第二句话：说清全文采用的模型/算法、采用的操作注意：开头段不要写详细的求解结果。
中间段模板：针对问题一，考虑到xxx，…，建立xxx模型/利用xxx方法，…，求解出xxx。一定要写清楚结果优化类、预测类和物理类的题目，要明确写清数值要求提供建议或评价的题目，要明确写清楚结论和数据依据，但不要有表格；数据过多可说明数据见附录。
总结（可不写）：如果写完后摘要超过一页了，可以不写。不要重复前面写过的内容。写一些特色，本文模型/方法的优点。
关键词：关键词一般4到6个。写使用的模型和算法，大家都知道的专业名词，问题的关键词。中间以空格分开。 4.参考文献 引用文献或已经公开资料都必须按规范列出参考文献并在正文对应处标注
参考文献不用自己写
在知网搜索文献后，点击最右侧的导出。直接复制粘贴即可。
如果需要用到博客等网站上公开的内容，可以借鉴，但不要照抄。
用自己的话复述，不必加入参考文献。 5.公式编辑 5.1 常用公式编辑方法 word自带的公式编辑 word顶部功能区"插入-公式"，或者快捷键：ALT和=操作简单，所见即所得 mathpix（付费软件） 截图得到公式，快捷键：ctrl+alt+m启动截图复制后可粘贴到word AxMath（付费软件） 支持快捷键+Tex代码+按钮三者混合输入可自由设置快捷键排版和编号方便 5.2 公式编辑技巧 巧用表格
word中插入一行两列的表格表格左端插入公式，右端插入域代码，最后隐藏表格的网格线设计好后，下一个公式就把该表格复制粘贴，改掉公式即可，编码会自动更新。
具体步骤：
word内插入一个一行两列的表格，完成第二步和第三步后，点击word功能区的表格设计-边框-选择无框线，以及表格布局-对齐方式-水平居中。
在表格第一列插入公式，该公式可以用word自带的编辑写，也可以用mathpix生成
在表格第二列自动编号，点击word功能区的插入-文档部件-域域名选择autonum，格式选择(1)(2)(3),点击确定。
6.三线表的制作与编号 三线表就是总共三条线的表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d54470caf4fed9c5c2f6d9014bcf051f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb4f41af9cb62e7a471b7cc89a97e4b8/" rel="bookmark">
			WPF TabControl使用时遇到的一些问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期遇到的不少问题都是由于TabControl以及DataGrid导致的，不能单独说这两个控件有BUG，但是组合使用时，确实会遇到不少奇怪的问题
框架版本依然是.NET472
切换TabItem导致光标自动被设置到了某个TextBox中去了 解决了上一篇遇到的DataGrid的问题之后，但是我的界面布局是TabControl–&gt;TabItem–&gt;DataGrid–&gt;TextBox的结构，而我的TextBox则是DataGrid的最后一列，也是唯一一列可编辑列，
当我把所有的其他列都设置为ReadOnly之后，结果切换TabItem会导致焦点自动被最后一列的TextBox捕获，切换Tab后，TextBox自动进入编辑状态，而这是我不期望的情况
我判断这个是因为ReadOnly导致原本前面的单元格不再能够停靠焦点，因此尝试强制为前面的元素设置Focusable=True，发现能够解决这个问题了
第二种情况 解决了上面的问题之后，我了解导致TabItem的自动切换焦点机制，我发现我有很多其他地方也有类似问题，于是我都设置了一下Focusable，但是我在某个地方发现，这样的设置没有生效。
在一个TabItem–&gt;(StackPanel1 , StackPanel2–&gt;TextBox) 的这样的结构中，为第一个元素添加Focusable后，焦点依然被TextBox自动捕获了，
查询了一下，发现原来是TabIndex被设置成了3，TabIndex决定了用Tab进行焦点切换时的优先级，数字越小，优先级越高，默认是INT32_MAX，
于是，我将TabIndex相关设定删除后，发现果然解决了问题
TabItem的自动切换焦点也会按照TabIndex的属性来搜索当前子节点中优先级最高的节点来设置焦点
堆栈调试 我加入了GotFocus事件处理函数，来进行堆栈跟踪，下面就是截取的切换Tabitem时发生的函数调用，从中可以看到，发生了两次Focus操作，第一次Focus就是我从当前面板，点击了TabItem之后，焦点从当前位置切换到了TabItem之上
而当TabItem获得焦点之后，就立刻触发了它的默认处理函数，处理函数之中就会调用MoveFocus将焦点转移，而转移对象就是归属于目标TabItem的优先级最高的子元素
在 System.Windows.EventRoute.InvokeHandlersImpl(Object source, RoutedEventArgs args, Boolean reRaised) 在 System.Windows.UIElement.RaiseEventImpl(DependencyObject sender, RoutedEventArgs args) 在 System.Windows.FrameworkElement.OnGotFocus(RoutedEventArgs e) 在 System.Windows.UIElement.IsFocused_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e) 在 System.Windows.DependencyObject.OnPropertyChanged(DependencyPropertyChangedEventArgs e) 在 System.Windows.FrameworkElement.OnPropertyChanged(DependencyPropertyChangedEventArgs e) 在 System.Windows.Controls.TextBox.OnPropertyChanged(DependencyPropertyChangedEventArgs e) 在 System.Windows.DependencyObject.NotifyPropertyChange(DependencyPropertyChangedEventArgs args) 在 System.Windows.DependencyObject.UpdateEffectiveValue(EntryIndex entryIndex, DependencyProperty dp, PropertyMetadata metadata, EffectiveValueEntry oldEntry, EffectiveValueEntry&amp; newEntry, Boolean coerceWithDeferredReference, Boolean coerceWithCurrentValue, OperationType operationType) 在 System.Windows.DependencyObject.SetValueCommon(DependencyProperty dp, Object value, PropertyMetadata metadata, Boolean coerceWithDeferredReference, Boolean coerceWithCurrentValue, OperationType operationType, Boolean isInternal) 在 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb4f41af9cb62e7a471b7cc89a97e4b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/978854eb71d8c21809b9e5b23b697fe9/" rel="bookmark">
			学习记录——day30 网络编程 端口号port 套接字socket TCP实现网络通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、端口号 port
二、套接字 socket
1、原理
2、socket函数介绍
三、TCP实现网络通信
1、原理
2、TCP通信原理图
3、TCP相关函数
1）bind 绑定
2）listen 监听
3）accept 接收连接请求
4）recv 接收
5）send 发送
6）connect 连接请求
4、TCP服务器端代码实现
5、TCP客服端代码实现
四、UDP实现网络通信
1、UDP网络通信模型
2、UDP相关函数　recvfrom　sendto
3、UDP服务器端代码实现
4、UDP客服端端代码实现
五、TCP和UDP基础通信模型注意事项
一、端口号 port 1、为了区分同一主机上的多个进程，使用端口号来进行处理
2、端口号是一个2字节的无符号整数存储，取值范围【0,65535】
3、网络通信中两个“地址”，主机的地址——IP，进程的地址——端口号；
4、特殊的端口号：0-1023 由系统默认应用程序占用，编程不可使用
TCP 21端口:FTP文件传输服务
TCP 23端口:TELNET终端仿真服务
TCP 25端口:SMTP简单邮件传输服务
TCP 110端口:POP3邮局协议版本3
TCP 80端口:HTTP超文本传输服务
TCP 443端口:HTTPS加密超文本传输服务
UDP 53端口:DNS域名解析服务
UDP 69端口:TFTP文件传输服务
特殊的端口函数，存储在linux中的 /etc/services文件中
5、编程可使用的：1024-49151 编程可使用的端口号
6、临时端口号：49152-65535
客服端运行时动态选择的，编程时若未指定端口号，会分配临时端口号
二、套接字 socket 相关帮助指令 man 2 socket man 7 socket
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/978854eb71d8c21809b9e5b23b697fe9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40bf41b6ec2bb0173cbb80e71ad0ac30/" rel="bookmark">
			【Kubernetes】身份认证与鉴权
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，认证 所有 Kubernetes 集群有两类用户：由Kubernetes管理的ServiceAccounts(服务账户)和(Users Accounts)普通账户。
两种账户的区别：
普通帐户是针对(人)用户的，服务账户针对Pod进程普通帐户是全局性。在集群所有namespaces中，名称具有唯一性。通常，群集的普通帐户可以与企业数据库同步，新的普通帐户创建需要特殊权限。服务账户创建目的是更轻量化，允许集群用户为特定任务创建服务账户普通帐户和服务账户的审核注意事项不同。对于复杂系统的配置包，可以包括对该系统的各种组件的服务账户的定义。 1，User Accounts 普通账户是假定被外部或独立服务管理的，由管理员分配 keys用户像使用 Keystone 或 google 账号一样，被存储在包含Usernames和Passwords的list 的文件里.
需要注意:在Kubernetes 中不能通过API调用将普通用户添加到焦群中。
2，Service Accounts # 获取Service Accounts kubectl get serviceaccount 或者 [sa] 自动化的三种控制器：
2.1 Service Account Admission Controller 通过 Admission Controller 插件来实现对 pod 修改，它是apiserver 的一部分。创建或更新 pod 时会同步进行修改 pod。当插件处于激活状态(在大多数发行版中都默认情况)创建或修改 pod 时，会按以下操作执行:
如果 pod 没有设置 serviceAccount，则将 ServiceAccount设置为 default。确保 pod 引用的 ServiceAccount 存在，否则将会拒绝请求。如果 pod 不包含任何 ImagePullsecrets，则将ServiceAccount的 lmagePullsecrets 会添加到 pod 中。为包含 API访问的 Token 的 pod 添加了一个 volume。把 volumesource 添加到安装在 pod 的每个容器中，挂载在/var/run/secrets/kubernetes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40bf41b6ec2bb0173cbb80e71ad0ac30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6f6e5b818cbfb53f4702b06e3c5756e/" rel="bookmark">
			Layui——隐藏表单项后不再进行验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
修改后的部分代码
修改后的完整代码 我编辑用户信息和添加新用户用的是同一个表单，不同的是编辑用户信息里没有密码项和确认密码项，但是把它们隐藏后仍然要进行验证，也就是说它们俩的验证并没有随着表单项的隐藏而关闭。原因：关闭不彻底，一共有两步。隐藏表单项的同时，需要把表单项里的 lay-verify 属性改为空 修改后的部分代码 修改后的完整代码 &lt;!DOCTYPE html&gt; &lt;%@ page language="java" pageEncoding="UTF-8" contentType="text/html;charset=utf-8" %&gt; &lt;%@ include file="../common/taglibs.jsp" %&gt; &lt;html lang="zh"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"&gt; &lt;%@ include file="../common/meta.jsp" %&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="layui-btn-group layui-row" id="btn_group"&gt; &lt;button type="button" class="layui-btn" data-method="addUser"&gt;添加账号&lt;/button&gt; &lt;/div&gt; &lt;table class="layui-hide" id="userTable"&gt;&lt;/table&gt; &lt;/body&gt; &lt;div hidden id="addUser"&gt; &lt;form class="layui-form" action="" lay-filter="addUserForm" id="addUserForm"&gt; &lt;div class="layui-form-item"&gt; &lt;label class="layui-form-label"&gt;真实姓名&lt;/label&gt; &lt;div class="layui-input-block"&gt; &lt;input type="text" name="realname" required lay-verify="required" autocomplete="off" class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6f6e5b818cbfb53f4702b06e3c5756e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51e99d325c91606b2ece581c1660fca2/" rel="bookmark">
			【Qt】QSS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QSS 一、QSS1. QSS2. QSS 设置方式（1）指定控件样式设置（2）全局样式设置（3）从文件加载样式表（4）使用 Qt Designer 编辑样式 3. 选择器（1）选择器介绍（2）子控件选择器 (Sub-Controls)（3）伪类选择器 (Pseudo-States) 4. 样式属性盒模型 (Box Model) 5. 控件样式示例（1）按钮（2）复选框（3）单选框（4）输入框（5）列表（6）菜单栏（7）登录界面 二、绘图1. 基本概念2. 绘制各种形状（1）绘制线段（2）绘制矩形（3）绘制圆形（4）设置画笔 一、QSS 1. QSS 对于 QSS 来说, 基本的语法结构非常简单：
选择器 { 属性名: 属性值; } 其中:
选择器 描述了 “哪个 widget 要应⽤样式规则”.属性 则是⼀个键值对, 属性名表⽰要设置哪种样式, 属性值表⽰了设置的样式的值. 例如：
QPushButton { color: red; } 上述代码的含义表示，针对界⾯上所有的 QPushButton , 都把⽂本颜⾊设置为红色。
代码示例: QSS 基本使用：
1 Widget::Widget(QWidget *parent) 2 : QWidget(parent) 3 , ui(new Ui::Widget) 4 { 5 ui-&gt;setupUi(this); 6 7 ui-&gt;pushButton-&gt;setStyleSheet("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51e99d325c91606b2ece581c1660fca2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62907ad3bc40f658d297c5a3f95a2579/" rel="bookmark">
			react最好用的swiper插件和拖动插件 react-tiny-slider react-draggable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		react移动端项目，其实有挺多的ui框架的，但是我们公司的项目，都是自己封装的ui库，又不可能为了一个轮播图就去再安装一个ui库
所以找了很多的轮播插件，都是不能满足需求
最后找到了它，react-tiny-slider，简直太好用了，而且还有官方各种demo
好了，其实按照上面两个链接，你也可以完成你的轮播需求了，但是我还是想记录一下我的代码
第一步：安装依赖 yarn add react-tiny-slider
第二步：引入插件 import Carousel from "react-tiny-slider"
第三步：开始你的代码啦 const carousel = useRef(null) &lt;Carousel edgePadding={24} swipeAngle={false} items={1} mouseDrag ref={carousel} controls={false} nav={false}&gt;
{SWIPER_ITEM.map((item) =&gt; (
&lt;div key={item.title}&gt;
&lt;SwipterItem {...item} /&gt; /** 这是你自己的组件 */
&lt;/div&gt;
))}
&lt;/Carousel&gt;
好了，这样就大功告成了！！！
react-draggable
好用的react拖动组件
react-draggable
最后编辑于：2021-12-09 18:32 © 著作权归作者所有,转载或内容合作请联系作者 喜欢的朋友记得点赞、收藏、关注哦！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24a542870af4a45e742bba9186d7e87e/" rel="bookmark">
			50&#43;个AI大模型在不同领域的应用案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👉目录
1 前言
2 AIGC应用案例
3 ChatBot应用案例
4 Copilot应用案例
5 Insight应用案例
6 Agent应用案例
7 ToB行业应用案例
8 开源人工智能应用案例
1.前言
随着大模型的横空出世，AI大模型在不同领域有着广泛的应用，包括内容生成、聊天机器人、智能助手等方向。这些大模型在ToB、ToG、ToC等不同客户维度下都有着各自的应用场景和挑战。微调是AI大模型发展的关键，商业模式上也出现了行业化应用与模型即服务（MaaS）的趋势。
本文对AI大模型的应用案例做了梳理，希望能为读者呈现AI大模型在不同领域的广泛应用以及商业模式创新的全貌
2.AIGC应用案例
1、LinkedIn：为会员提供优质生成式产品
LinkedIn 聘请 LLM 向用户推荐相关的高级产品。LinkedIn 的推荐系统可以通过分析用户数据（包括职业历史、兴趣和活动模式）为会员匹配最适合其需求的高级服务和产品。
这种有针对性的方法有助于 LinkedIn 提高用户满意度并推动其高级产品的订阅。
2、Discord：生成式人工智能用例
流行的通信平台 Discord 探索了各种生成式 AI 用例，以提高用户参与度。
Discord 可以通过快速开发和集成生成式 AI 功能，为用户提供创意工具，例如 AI 生成的头像、内容审核和自动回复。这些功能利用 LLM 来改善用户体验并培养更具互动性的社区
3、格莱美奖：定制见解和内容
IBM 还宣布了一项协议，为格莱美奖的所有者录音学院提供一项名为 AI stories 的服务。该服务利用在 IBM Wastonx.ai 工作室上运行的 Llama 2，帮助定制见解和内容。这项服务将围绕艺术家及其作品的相关数据集的数据矢量化，LLM 可以通过 RAG 数据库检索这些数据，粉丝们也可以与这些内容进行互动。
4、Shopify：生成产品描述
Shopify Sidekick 是一个 AI 驱动的工具，利用 Llama 2 帮助小企业主自动完成管理其商务网站的各种任务，如生成产品描述、回应客户查询和创建营销内容。
5、Waymark＆OpenAI，集成GPT－3增强和扩展视频创建
Waymark集成GPT－3后，使用微调的GPT－3模型来创建不同脚本编写体验，使得用户可以在几秒钟内收到其业务的原始自定义脚本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24a542870af4a45e742bba9186d7e87e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f38c348166199aa44cb939986ea708e5/" rel="bookmark">
			【MySQL】什么是事务？在高并发场景使用事务会出现什么问题，该如何解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事务的概念 在MySQL中，事务是一组操作的集合，这些操作要么全部执行成功，要么全部不执行。这种特性确保了数据库操作的可靠性和一致性。事务的主要概念包括以下几个方面：
原子性（Atomicity）：事务中的操作要么全部完成，要么全部不执行。这意味着在事务执行过程中，如果发生错误，所有已执行的操作会被撤销，数据库将返回到事务开始前的状态。
一致性（Consistency）：事务必须使数据库从一个一致性状态转变到另一个一致性状态。在事务执行前和执行后，数据库的完整性约束必须得到满足。
隔离性（Isolation）：多个事务同时执行时，彼此之间不会干扰。每个事务都有其独立的执行环境，防止了事务间的数据干扰。
持久性（Durability）：一旦事务提交，其结果就会永久保存到数据库中，即使发生系统崩溃也不会丢失。
在MySQL中，可以通过使用START TRANSACTION或BEGIN来开始一个事务，通过COMMIT来提交事务，通过ROLLBACK来撤销事务。事务的正确使用能够确保数据的完整性和一致性，是数据库管理的重要机制。
使用事务的原因 使用事务的原因主要体现在以下几个方面：
确保数据一致性：事务能够保证数据库在多用户环境下的一致性，确保在一个事务中所做的所有操作要么全部完成，要么全部不执行，从而防止数据处于不一致的状态。
提高数据安全性：通过原子性，事务确保了一系列操作的完整性。当事务中的某一操作失败时，所有的操作都会被撤销，这样可以避免部分操作成功而导致的数据错误或不一致。
支持并发控制：在多用户环境中，事务提供了一种机制来管理并发访问。通过隔离性，事务能够确保多个用户在同时访问和修改数据时不会发生冲突，提升了系统的稳定性和可用性。
维护数据完整性：事务在执行时可以确保所有的完整性约束（如主键、外键约束等）被满足，从而维护数据的逻辑合理性。
提高可恢复性：持久性确保了一旦事务提交，数据就会安全地保存在数据库中，即使出现系统崩溃，用户也不必担心数据丢失，提高了系统的可靠性。
总而言之，事务是保障数据库操作安全性和有效性的重要机制，通过使用事务，可以有效避免数据问题，增强数据库管理的可靠性和稳定性。
事务的使用 开启事务：start transaction; 执行多条SQL语句;
回滚或提交：rollback/commit; 下面是一个使用事务的示例，演示如何在MySQL中处理一个简单的银行转账操作。这个操作包括从一个账户扣款并将款项存入另一个账户。在这个过程中，我们使用事务来确保万一任何一个步骤失败，整个过程都可以回滚，保证数据的一致性。
示例：银行转账操作 需求：从账户A转账100元到账户B。
代码示例 -- 假设有一个账户表 CREATE TABLE accounts ( id INT PRIMARY KEY, balance DECIMAL(10, 2) NOT NULL ); -- 插入示例账户 INSERT INTO accounts (id, balance) VALUES (1, 1000.00), (2, 500.00); -- 开始事务 START TRANSACTION; -- 从账户A（id = 1）扣款100 UPDATE accounts SET balance = balance - 100 WHERE id = 1; -- 将100元存入账户B（id = 2） UPDATE accounts SET balance = balance + 100 WHERE id = 2; -- 提交事务 COMMIT; -- 为了检查结果，你可以查询账户余额 SELECT * FROM accounts; 代码说明 创建账户表：首先我们创建了一个名为accounts的表，包含账户ID（id）和余额（balance）两个字段。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f38c348166199aa44cb939986ea708e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fa3f42eee1c2bde0e487c19ddd71d37/" rel="bookmark">
			socket和websocket 有什么区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Socket 和 WebSocket 都用于网络通信，但它们的用途、协议、以及使用方式有所不同。以下是两者的主要区别：
### 1. **基础协议**
- **Socket**:
- Socket 是网络通信的一个抽象概念，通常基于传输层协议，如 TCP（传输控制协议）或 UDP（用户数据报协议）。
- 它用于建立客户端和服务器之间的连接，进行数据的发送和接收。通常，Socket 是一个底层的通信接口，支持各种应用协议（如 HTTP、FTP 等）。
- **WebSocket**:
- WebSocket 是一个应用层协议，建立在 TCP 之上。它用于在客户端和服务器之间创建持久的、双向通信通道。
- WebSocket 的初始握手是基于 HTTP/HTTPS 协议的，但一旦连接建立，它就切换到 WebSocket 协议，从而允许全双工通信。
### 2. **通信模式**
- **Socket**:
- 通常，基于 Socket 的通信是半双工的，这意味着客户端和服务器之间的消息传递是相互阻塞的：一方发送消息，另一方接收消息。
- Socket 通信需要开发者手动处理数据的发送、接收、连接维护、错误处理等。
- **WebSocket**:
- WebSocket 提供全双工通信，即客户端和服务器可以在同一连接上同时发送和接收消息。
- WebSocket 的通信是事件驱动的，数据可以以消息的形式实时地从服务器推送到客户端，适用于需要频繁更新或实时交互的应用场景。
### 3. **使用场景**
- **Socket**:
- Socket 是一种更通用的通信工具，适用于各种类型的网络编程，如文件传输、流媒体、即时通讯等。
- 开发者可以基于 Socket 构建任何定制的协议，满足特定应用需求。
- **WebSocket**:
- WebSocket 特别适合需要实时通信的 Web 应用，如实时聊天、在线游戏、股票交易平台、协作工具等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fa3f42eee1c2bde0e487c19ddd71d37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e18c9f0ee86fdb0723153e80460f531/" rel="bookmark">
			数学建模——评价决策类算法（熵权法、模糊综合评价）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、熵权法（求解权重） 概念原理 代码 import numpy as np # 导入numpy库，并简称为np # 定义一个自定义的对数函数mylog，用于处理输入数组中的零元素 def mylog(p): n = len(p) # 获取输入向量p的长度 lnp = np.zeros(n) # 创建一个长度为n，元素都为0的新数组lnp for i in range(n): # 对向量p的每一个元素进行循环 if p[i] == 0: # 如果当前元素的值为0 lnp[i] = 0 # 则在lnp中对应位置也设置为0，因为log(0)是未定义的，这里我们规定为0 else: lnp[i] = np.log(p[i]) # 如果p[i]不为0，则计算其自然对数并赋值给lnp的对应位置 return lnp # 返回计算后的对数数组 # 定义一个指标矩阵X X = np.array([[9, 0, 0, 0], [8, 3, 0.9, 0.5], [6, 7, 0.2, 1]]) # 对矩阵X进行标准化处理，得到标准化矩阵Z Z = X / np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e18c9f0ee86fdb0723153e80460f531/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b7522ac48262ff07ba64680327a3a94/" rel="bookmark">
			【CentOS 】DHCP 更改为静态 IP 地址并且遇到无法联网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引言解决方式标题1. **编辑网络配置文件**：标题2. **确保配置文件包含以下内容**：特别注意 标题3. **重启网络服务**：标题4. **检查配置是否生效**：标题5. **测试网络连接**：标题6. **检查路由表**：标题7. **检查防火墙设置**：标题8. **检查 SELinux 状态**：标题9. **检查系统日志**：标题10. **重新启用 NetworkManager**：标题11. **使用 nmcli 工具**： 引言 在 CentOS 7 中，如果你将网络配置从 DHCP 更改为静态 IP 地址并且遇到无法联网的问题，以下是一些步骤和建议来帮助你解决这个问题：
解决方式 标题1. 编辑网络配置文件： CentOS 7 使用 NetworkManager 管理网络，但底层配置文件仍然位于 /etc/sysconfig/network-scripts/ 目录下。对于特定的网络接口，比如 eth0，配置文件可能是 ifcfg-eth0。
vim /etc/sysconfig/network-scripts/ifcfg-ens33 标题2. 确保配置文件包含以下内容： BOOTPROTO=static 表示使用静态IP配置。IPADDR 设置为你想要的静态IP地址。NETMASK 设置为子网掩码。GATEWAY 设置为默认网关的IP地址。DNS1 和 DNS2 设置为首选和备用DNS服务器的IP地址。 例如：
DEVICE="ens33" TYPE=Ethernet ONBOOT=yes BOOTPROTO=static IPADDR=192.168.1.100 NETMASK=255.255.255.0 GATEWAY=192.168.1.2 DNS1=8.8.8.8 DNS2=8.8.4.4 参考我的
特别注意 网关注意最后一位不要是1
IPADDR=192.168.148.133 GATEWAY=192.168.148.2 标题3. 重启网络服务： 在 CentOS 7 中，你可以使用以下命令来重启网络服务：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b7522ac48262ff07ba64680327a3a94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1e8b60e75dc327bb792c53c057ca279/" rel="bookmark">
			Android悬浮窗功能实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.使用悬浮窗功能的原因:
二.悬浮窗的具体实现步骤:
一.添加权限:
二.动态申请权限:
三.WindowManager.LayoutParams的TYPE类型:
四.编写代码:
1.XML代码:
2.Activity相关代码:
3.WindowManager相关代码 一.使用悬浮窗功能的原因: 在Android开发中我们想要做到提醒用户关键信息的作用的时候.例如App更新信息之类的,有很多种方式去实现,主要的话还是三种方式Dialog,AlertDialog,PopupWindow,但是他们都有一个共同的缺点那就是依赖于Activity,而悬浮窗是不依赖Activity的,甚至,App在后台运行,悬浮窗依旧会弹出来,只要App进程不被杀死,但是悬浮窗也有缺点,那就是权限问题
二.悬浮窗的具体实现步骤: 一.添加权限: &lt;!-- 悬浮窗需要添加该权限--&gt; &lt;uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" /&gt; 二.动态申请权限: private fun initFloatWindow() { // 权限判断 if (!Settings.canDrawOverlays(applicationContext)) { // 启动Activity让用户授权 val mIntent = Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION, Uri.parse("package:${packageName}")) startActivityForResult(mIntent, 10) } else { // 已经有权限了,就去初始化对应的视图或者悬浮窗弹窗的初始化 initView() } } override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { super.onActivityResult(requestCode, resultCode, data) if (resultCode == 10) { if (Settings.canDrawOverlays(applicationContext)) { initView() } else { ToastUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1e8b60e75dc327bb792c53c057ca279/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec6636b58552e612c3143a5cd68dc177/" rel="bookmark">
			贪心算法---分发饼干
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目：
假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。
思路：
将胃口，饼干尺寸都由小到大排序，最大的胃口优先得到满足。
代码：
public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int count=0;//喂饱的孩子数量 int start=s.length-1;//先满足大胃口的孩子 for(int index=g.length-1;index&gt;=0;index--){ if(start&gt;=0&amp;&amp;g[index]&lt;=s[start]){ count++; start--; } } return count; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/895377a035211dc90fb78e9e5d055c5a/" rel="bookmark">
			Visual Studio 和 VSCode 哪个好？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选择Visual Studio还是VSCode取决于您的具体需求‌
Visual Studio (VS) 是一款功能全面的集成开发环境（‌IDE）‌，‌提供了从代码编辑、‌编译、‌调试到版本控制、‌团队协作等一整套开发工具。‌它对微软自家的技术栈（‌如.NET、‌C#、‌VB.NET等）‌有深度集成，‌提供了丰富的内置工具和特性，‌如即时代码分析、‌性能分析器、‌单元测试工具等。‌VS适合处理大型企业项目，‌特别是那些需要复杂功能支持的大型企业和团队项目，‌尤其是基于微软技术栈的项目1。‌VS的深度集成的调试工具提供了全面的调试功能，‌包括断点设置、‌变量监视、‌调用堆栈查看、‌性能分析以及内存管理等2。‌此外，‌VS通过扩展进行高度定制，‌允许添加自定义功能和集成工具，‌适合需要高级功能和强大IDE的专业开发人员。‌
Visual Studio Code (VSCode) 是一款轻量级的代码编辑器，‌通过插件支持多种编程语言，‌包括JavaScript、‌TypeScript、‌Python、‌C#等，‌提供了先进的IntelliSense代码完成功能，‌减少开发者的输入错误。‌VSCode的设计初衷是提供一个简洁、‌快速且易于使用的代码编辑环境，‌以其轻量级和高效著称，‌占用的系统资源相对较少，‌启动速度快，‌响应灵敏，‌能够迅速打开和编辑文件，‌极大地提升了开发效率。‌VSCode适合入门级开发者和小型项目开发，‌是快速开发、‌原型制作以及小型项目开发的理想选择。‌
总的来说，‌如果您是初学者或者需要处理小型项目，‌VSCode因其轻量级和易用性是一个很好的选择。‌如果您是专业开发者，‌需要处理大型企业项目或需要深度集成和强大的调试工具，‌Visual Studio会是更好的选择。‌最终的选择应基于您的个人需求和项目要求。‌
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10d6dcf2da042a3cd507910a462d596e/" rel="bookmark">
			[Megagon Labs] Annotating Columns with Pre-trained Language Models
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Annotating Columns with Pre-trained Language Models 任务定义 输入：一张数据表，但没有表头，只有表中的数据。
输出：每一列数据的数据类型，以及两列数据之间的关系。
数据类型和数据关系都是由训练数据决定的固定集合，可以视作多分类任务。
模型架构 整个模型的back bone依然是transformer，利用attention机制获取整表的语境信息。具体来说，DODUO将整个表格序列化，化二维为一维，每个column首尾相接连接成一个序列，而每个column用一个特殊token[CLS]隔开，整个序列以[SEP]结尾。
与BERT的做法类似，[CLS]这个特殊token被用来表示整个column的信息，同时这个column由于attention机制，除了自己所在的column信息也会聚合到其他column的context，这就是DODUO的核心思想。
同时，DODUO是一个多任务模型，两个分类任务：数据类别和数据关系。所以在共享transformer层作为编码器后，使用两个不同的Dense Layer来对应两个任务。数据类别任务直接取[CLS]作为输入，输出分类结果；而数据关系任务将两个[CLS]连接在一起作为输入，输出分类结果。这两个任务会在每个epoch中依次进行训练。
由于DODUO需要将序列化后的表中的token编码为embedding作为第一层transformer层的输入，所以对embedding模型同样做了微调，在反向传播过程中更新了12层BERT-base的参数。
*论文中好像没有提到中间的transformer layer到底有几层
整个结构的灵活性较强，核心的transformer back bone令知识在多任务之间共享，增加了泛化能力。而embedding模型和对应不同任务的dense layer都是可以灵活替换的。包括文章中也提到，使用更大更强的LM作为embedding模型可能会进一步提升效果。针对特殊数据（如数字、日期），采用对应的LM作为embedding模型也会提升性能。
实验结果 在不包含表头信息（即图中的metadata）的情况下，DODUO的性能超过了其他baseline，为SOTA。而TURL本身设计是需要表头的，此时TURL和DODUO的表现相近，甚至在数据关系任务上TURL优于DODUO。因此DODUO的优势还是在于表头信息缺失的情况，利用整表context，能得到信息更充分的编码。
消融实验的结果也说明了这个问题，DOSOLO是DODUO在单个任务上的版本，而DOSOLOscol则是只考虑单个任务单个column的版本，明显看到DOSOLO的性能知识略有下降，但DOSOLOscol的性能则是暴降。
另一方面，由于使用了pre-trained model和多任务训练，DODUO可以仅用少量数据训练达到较好的性能，图4和表8分别展示了在缩减训练集数量以及每个column token数量的情况下的性能变化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b4d1113a697cd6f5387ef11cf8a7186/" rel="bookmark">
			Linux下安装Mysql数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.版本说明和引用 Linux版本Centos7
[root@localhost ~]# cat /proc/version Linux version 3.10.0-1160.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) ) #1 SMP Mon Oct 19 16:18:59 UTC 2020 Mysql版本8.4.0
安装方式手动rpm包安装
官方安装指导文档，其它系统和版本可参考文档MySQL :: MySQL 8.4 Reference Manual :: 2.5.4 Installing MySQL on Linux Using RPM Packages from Oracle
下载Mysql rpm包 MySQL :: Download MySQL Community Server (Archived Versions)
同时支持Linux8/9 选择相应版本下载
Bundle版本意思为合集，ARM和X86为系统架构，正常情况下是X86系统（Inter使用这个)
导入虚拟机 [root@localhost opt]# pwd /opt [root@localhost opt]# ls mysql-8.4.0-1.el7.x86_64.rpm-bundle.tar 解压压缩包
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b4d1113a697cd6f5387ef11cf8a7186/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e4f3475099f1680559f3ba20eff21d6/" rel="bookmark">
			C# 结合 Javascript 测试获取天气信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
测试效果
范例运行环境
关键代码
C#获取网页数据
前端代码
JavaScript 实现 总结
测试效果 获取一些简单的天气信息，可以丰富我们的应用系统，比如开发一个小桌面，小组件，增加一些实用性的系统功能，本文将介绍如何使用 C# 并结合 JavaScript 获取天气信息，获取的数据来源于 360 浏览器首页数据，成功的测试效果如下图：
实现这样的效果主要通过如下步骤：
1、通过C#服务端获360欢迎页网页数据。
2、通过JavaScript 截取天气数据片段。
3、通过截取的天气数据片段，放置需要显示的 DOM 容器当中。
范例运行环境 操作系统： Windows Server 2019 DataCenter
.net版本： .netFramework4.7.1 或以上
开发工具：VS2019 C#
关键代码 C#获取网页数据 获取远程地址需要使用到关键方法 GetResponseResult ，具体可以参考我的文章
《C# 实现访问 Web API Url 提交数据并获取处理结果》
关键代码如下：
&lt;%@ Page Language="C#" AutoEventWireup="true" ValidateRequest="FALSE" %&gt; &lt;script language="C#" runat="server"&gt; void Page_load(Object sender, EventArgs e) { if (Page.IsPostBack) { return; } WebService ws = new WebService(); string rv = ws.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e4f3475099f1680559f3ba20eff21d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ab798cc6aabe4dab48aac217e95dd7a/" rel="bookmark">
			html&#43;css&#43;js网页制作 自定义电商10个页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 html+css+js网页制作 自定义电商10个页面 网页作品代码简单，可使用任意HTML编辑软件（如：Dreamweaver、HBuilder、Vscode 、Sublime 、Webstorm、Text 、Notepad++ 等任意html编辑软件进行运行及修改编辑等操作）。 获取源码 1，访问该网站 https://download.csdn.net/download/qq_42431718/89635486
2，点击上方下载
目录1 项目视频 html+css+js网页制作 自定义电商10个页面
页面1 页面2 页面3 页面4 页面5 页面6 页面7 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37ff02077c98ca6776c5f39529fdc7ff/" rel="bookmark">
			LVS原理及相关配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 描述以及工作原理 1. 什么是 LVS linux virtural server 的简称，也就是 linxu 虚拟机服务器，这是一个 由章文嵩博士发起的开源项目，官网是 http://www.linuxvirtualserver.org,现在 lvs 已经是 linux 内核标 准的一部分，使用lvs 可以达到的技术目标是：通过 linux 达到负载均衡技术和linux 操作系统实现一个高性能高可用的 linux 服务器集群，他具有良好的可靠性，可延展性和可操作性，从而以低廉的成本实现最优的性能，Lvs 是一个实现负载均衡集群开源软件项目，lvs 从逻辑上可以分为调度层，server集群层，和共享存储 免费，开源，四层负载均衡 2. LVS 调度算法 1. 静态调度算法 Fixed Scheduling Method 1. 轮询 RR 轮询 ** 调度器通过 " 轮叫 " 调度算法将外部请求按顺序轮流分配到集群中的真 实服务器上，它均等地对待每一台服务器，而不管服务器上实际的连接数和系统负载。 2. 加权轮询 WRR 加权轮询 ** 调度器通过 " 加权轮叫 " 调度算法根据真实服务器的不同处理能力来调度访问请求。 这样可以保证处理能力强的服务器处理更多的访问流量。调度器 可以自动问询真实服务器的负载情况，并动态地调整其权值 3. 目标地址 hash DH 目标地址 hash** 算法也是针对目标 IP 地址的负载均衡，但它是一种静态映射算法，通过一个散列（Hash ）函数将一个目标 IP 地址映射到一台服务器。目标地址散列调度算法先根据请求的目标IP 地址，作为散列键 （Hash Key ）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37ff02077c98ca6776c5f39529fdc7ff/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/51/">«</a>
	<span class="pagination__item pagination__item--current">52/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/53/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>