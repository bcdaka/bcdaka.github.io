<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa4d9495d646774aa734ddfb2e51e0c2/" rel="bookmark">
			内网穿透 篇五：通过 ddns-go 动态域名解析 实现公网访问内网服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文首发于只抄博客，欢迎点击原文链接了解更多内容。
前言 如今 IPv6 的普及度越来越高，与 IPv4 不同的是，大部分人获取到的 IPv6 是公网 IP 并且每一个设备都有一个属于自己的公网 IPv6，因此我们无需再进行内网穿透、端口转发等操作，直接通过设备的公网 IPv6 就可以成功访问到内网服务。
但是直接记住这么长 IPv6 的地址来访问显然不现实，我们可以将域名通过 AAAA 解析到我们的 IPv6 地址上，这样访问时，只需要输入域名，DNS 就会帮我们解析到响应的 IP 地址了。
即便如此，几天之后你就会发现域名又无法访问了，这是因为运营商分配的 IPv6 地址是动态的，过几天 IPv6 就会变动一次，所以就需要 DDNS 了，它可以定时获取我们当前的 IPv6 地址，并将该地址同步到 DNS 服务商。
安装 ddns-go ddns-go 是一个使用 Go 语言编写的 DDNS 客户端，支持多种 DNS 服务商，通过 Docker 可以直接安装
docker run -d --name ddns-go --restart=always --net=host -v /opt/ddns-go:/root jeessy/ddns-go 使用 ddns-go 在使用 DDNS 之前，需要确保正常获取到 IPv6，并能正常访问 IPv6，通过 http://[ipv6]:port 的形式，能够访问即可。若访问失败，则需要检查光猫或路由器的 IPv6 防火墙配置是否正确。
在浏览器中打开 http://ip:9876 即可进入到 ddns-go 的管理界面，按照以下步骤依次配置：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa4d9495d646774aa734ddfb2e51e0c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39d8ad530719f4b2b9bb9ac8eda0bdcb/" rel="bookmark">
			MySQL的创建用户以及用户权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用语言 MySQL
使用工具 Navicat Premium 16
代码能力快速提升小方法，看完代码自己敲一遍，十分有用
拖动表名到查询文件中就可以直接把名字拉进来中括号，就代表可写可不写 目录
1.创建用户
1.1 工具创建用户
1.2 脚本创建用户
1.2.1 脚本创建用户介绍
1.2.2 脚本创建用户示例
1.3 远程连接 1.4 删除用户
2.设置权限
2.1 MySQL5.7或以下版本设置权限
2.2 MySQL8.0或以上版本设置权限 2.2.1 示例 1.创建用户 1.1 工具创建用户 打开以后是这个界面，照着填就行了，插件一般不用选择，会有默认的； 想要修改密码就直接在以上图片的用户中选中要修改密码的用户然后双击点进去然后修改即可。注:这两次都要输入; 1.2 脚本创建用户 1.2.1 脚本创建用户介绍 在开发过程中，记得要创建用于登录数据库的用户。如果使用默认提供的root用户，因为拥有超级用户权限，所以很容易因误操作而使数据不安全。在实际开发中，一般不建议使用root用户登录MySQL服务器。数据库管理员(Database Administartor,DBA)负责为不同的数据库使用者创建一系列普通用户账户，赋予不同的权限，以保证数据的安全。创建新用户的语法如下: create user `username`@'host' [identiried by [PASSWORD] 'password'] username: 创建的用户名
host: 指定用户登录的主机名。如果是本地用户，可使用"localhost"。如果想让用户可以从远程主机登录，可使用通配符"%"；
identified by: 用来设置密码，缺省时密码为空
PASSWORD: 使用哈希值设置密码，可选
password: 用户登录时使用的密码
实际开发中，远程连接使用的比较多，远程连接的意思就是在其他的主机可以连接这个拥有远程连接权限的用户;
1.2.2 脚本创建用户示例 需求: 在数据库创建一个用户名为root4且密码为123456并且支持远程连接的账户 创建用户之后，可通过系统数据库mysql的user表，查看已存在的用户；SQL语句如下: SQL语句
运行结果
由以上图可以看出，user表中的Host、User、authentication_string分别对应创建用户时指定的主机名、用户名、密码的哈希值。除此之外，还有一系列以'_priv'字符串结尾的字段，这些字段决定了用户的权限，这些字段的值只有Y和N，Y代表用户有对应的权限，N代表用户没有对应的权限，这些字段的默认值是N。使用create user语句创建的用户是未授权的 1.3 远程连接 远程连接的主机就写创建这个用户的主机IP地址，IP地址可以win+R进入cmd中的dos命令中输入ipconfig即可，然后其他就照着填就行了，端口不用改，用户名就是要连接的用户名，密码就是创建用户时创建的密码；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39d8ad530719f4b2b9bb9ac8eda0bdcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/033401541e98968196f2beceec031265/" rel="bookmark">
			如何在Java中计算两个日期之间的天数差
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java开发过程中，我们常常需要处理与日期相关的计算，例如计算两个特定日期之间相隔的天数。Java 8及其后续版本引入了强大的java.time包，提供了丰富的日期时间类和工具，使得这类操作变得简单且精准。本文将详细介绍如何使用java.time包中的LocalDate类和ChronoUnit枚举类来计算两个日期之间的天数差。
步骤一：导入所需库
首先，确保在您的Java项目中已导入必要的java.time包。这通常通过在代码顶部添加以下导入语句完成：
import java.time.LocalDate; import java.time.temporal.ChronoUnit; 步骤二：创建LocalDate对象
LocalDate类代表了一个不含时区信息的日期，只包含年、月、日三个部分。要计算两个日期之间的天数差，我们需要为这两个日期创建LocalDate对象。以下是如何创建表示特定日期的LocalDate实例：
LocalDate startDate = LocalDate.of(2022, 6, 1); // 创建起始日期（年份、月份、日期） LocalDate endDate = LocalDate.of(2022, 7, 31); // 创建结束日期（年份、月份、日期） 在这里，我们创建了两个LocalDate对象：startDate表示2022年6月1日，endDate表示2022年7月31日。
步骤三：使用ChronoUnit计算天数差
Java 8的java.time.temporal.ChronoUnit枚举类提供了一系列预定义的时间单位，包括DAYS。我们可以使用between()方法，传入两个LocalDate对象，轻松计算它们之间的天数差：
long daysBetween = ChronoUnit.DAYS.between(startDate, endDate); 上述代码中，ChronoUnit.DAYS.between(startDate, endDate)返回的是一个long类型的整数，表示startDate和endDate之间相隔的完整天数。在这个示例中，它将计算2022年6月1日至2022年7月31日之间的天数。
完整代码示例
将以上步骤整合到一起，完整的Java代码如下：
import java.time.LocalDate; import java.time.temporal.ChronoUnit; public class DateDifferenceCalculator { public static void main(String[] args) { LocalDate startDate = LocalDate.of(2022, 6, 1); LocalDate endDate = LocalDate.of(2022, 7, 31); long daysBetween = ChronoUnit.DAYS.between(startDate, endDate); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/033401541e98968196f2beceec031265/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1f97f04b050d41f75bd4a15eff02d15/" rel="bookmark">
			difflib 标准库详解：Python 文本对比的利器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍀 前言 博客地址：
CSDN：https://blog.csdn.net/powerbiubiu 👋 简介 difflib 模块是 Python 标准库中的一个模块，用于比较文本之间的差异。它提供了一些函数和类，可以帮助你找到两个字符串或列表之间的相似性和差异性。
📖 正文 1 匹配最大相似内容 语法：difflib.get_close_matches(word, possibilities, n=3, cutoff=0.6)
参数说明：
word：要匹配的目标字符串；possibilities：包含可能匹配项的列表；n：可选参数，指定返回的最大匹配项数，默认为 3；cutoff：可选参数，表示匹配度的阈值，只返回匹配度大于等于该阈值的项，默认为 0.6。 函数会返回一个列表，其中包含了与目标字符串最相似的项。它会基于 difflib 库中的模糊匹配算法，找到给定字符串在候选列表中的可能匹配项。
import difflib colors = ['red', 'blue', 'green', 'yellow', 'black', 'white'] wrong_color = "grren" result = difflib.get_close_matches(wrong_color, colors) print(result) # ['green'] 2 两个文本之间的差异 2.1 context_diff 语法：difflib.context_diff(a, b, fromfile='', tofile='', fromfiledate='', tofiledate='', n=3, lineterm='\n')
参数说明：
a：第一个文本内容（通常为列表形式，每行作为一个元素）；b：第二个文本内容（同样通常为列表形式）；fromfile：可选参数，用于指定第一个文件名；tofile：可选参数，用于指定第二个文件名；fromfiledate：可选参数，用于指定第一个文件的日期；tofiledate：可选参数，用于指定第二个文件的日期；n：可选参数，用于指定上下文的行数；lineterm：可选参数，用于指定行终止符，默认为 \n。 函数会返回一个生成器，可以逐行输出表示差异的文本。该差异文本遵循标准的 Unix 上下文 diff 格式，显示出两个文本之间的差异以及周围的上下文信息。
import difflib text1 = ['Hello', 'World', 'Python'] text2 = ['Hello', 'There', 'Python'] diff = difflib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1f97f04b050d41f75bd4a15eff02d15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42c3dfe73d2edf3394c2d4b3fa6f2f95/" rel="bookmark">
			基于MATLAB的高阶传递函数降阶算法及其在控制器设计中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		matlab模型降级算法，传递函数降阶算法。
电机控制，并网控制，四旋翼控制等。
高阶传递函数进行降级阶处理，逼近传递函数n阶矩阵的距，实现模型降级，操作简单。
（有arnolid算法、lanczos算法、pade算法，自己选择其中一个买）。
可用于控制器设计，将模型降阶后，控制器设计更简单，使用的人少，创新点足，发表lunwen可用。
图片为降级前的传递函数，降阶后的传递函数和bode图，可见在低频区域，具有很好的相似性，当系统频率比较低时，两个传递函数可以完全等价。
ID:6722675952736363
菲利斯特啊啊 标题：基于Matlab的模型降级算法及其在控制器设计中的应用
摘要：本文介绍了一种基于Matlab的模型降级算法，该算法可以对高阶传递函数进行降级处理，以逼近传递函数的n阶矩阵的距。通过模型降阶，可以简化控制器设计，降低系统的复杂性。本文还提供了降级前后的传递函数和Bode图对比分析，证明了降级算法在低频区域具有很好的相似性。该算法具有操作简单、创新点足等特点，适用于控制领域的研究与应用。
一、引言
在控制系统设计过程中，经常需要对高阶传递函数进行降级处理，以简化系统的分析和控制。目前，针对传递函数的降级算法有多种，如Arnoldi算法、Lanczos算法和Pade算法等。本文将介绍一种基于Matlab的模型降级算法，并探讨其在控制器设计中的应用。
二、模型降级算法原理
模型降级算法基于高阶传递函数的降阶处理，通过逼近传递函数的n阶矩阵的距来实现降级。具体操作可以在Matlab中进行，使用简单便捷。
三、模型降级在控制器设计中的应用
模型降级在控制器设计中具有重要的应用价值。通过降低系统的阶数，可以使控制器的设计更加简单，减少计算量和复杂性。此外，模型降级还可以提供更多的创新点，为控制器设计领域的研究和发表论文提供新的思路。
四、实验验证
为了证明模型降级算法的有效性，本文提供了降级前后的传递函数和Bode图对比分析。从图中可以观察到，在低频区域，两个传递函数具有很好的相似性，当系统频率较低时，两个传递函数可以完全等价。这证明了模型降级算法的可行性和有效性。
五、结论
本文介绍了一种基于Matlab的模型降级算法，该算法通过降低高阶传递函数的阶数，逼近传递函数矩阵的距，实现模型降级的目的。模型降级算法在控制器设计中具有重要的应用价值，可简化控制器设计，减少计算量和复杂性。该算法操作简单，创新点足，适用于控制领域的研究与应用。
六、致谢
感谢Matlab提供了强大的工具，使得模型降级算法的实现和控制器设计更加简便。同时，感谢社区的博客平台，为我们提供了一个交流与分享的空间。
参考文献：
[1] Zhang A, Li B, Chen C, et al. Model reduction via balanced realizations for linear neutral delay differential-algebraic equations. International Journal of Control, Automation and Systems, 2019, 17(7): 1668-1677.
[2] Liu Y, Shi J. Controller Reduction via Projection Based Low Rank Approximation. IEEE Transactions on Automatic Control, 2018, 63(3): 852-859.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42c3dfe73d2edf3394c2d4b3fa6f2f95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e5f56c5cdb4049ae967bc5d6e57a3dd/" rel="bookmark">
			PHPstudy中使用自带MySQL数据库的连接方法和配置环境（超详细实用分享）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一.连接方法
1.使用MySQL命令行进行连接
2.使用MySQL-front连接 二，配置环境 1.目的
2.配置操作 如果觉得本文对你有帮助的话，请点上一个免费的赞吧，之后还会继续分享更多干货 一.连接方法 1.使用MySQL命令行进行连接 首先启动phpstudy 然后点击其他选项菜单---&gt;网站根目录 进入PHPTutorial 点击MySQL文件，再点击bin文件 空白处右键在点击在终端中打开 输入mysql -uroot -p ，password一般默认密码是root 连接成功 2.使用MySQL-front连接 点击MySQL管理器，再点击MySQL-front 进去后，如果可以打开就直接点打开，没有就自己创一个用户 创建用户方法 点击确定连接成功 二，配置环境 1.目的 为了能随时在任意文件位置使用cmd进入命令面板连接数据库（没看懂这句话的可以自己尝试一下再其他文件里的命令面板可以连接MySQL数据库吗）
2.配置操作 首先先复制进入bin的路径 然后再右键点击此电脑，再点击属性 再然后点击高级系统设置，再点击环境变量 最后点击系统变量里的path，然后点击新建把你复制的路径粘贴上去，一直点确定就配置成功了 如果觉得本文对你有帮助的话，请点上一个免费的赞吧，之后还会继续分享更多干货 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04fd7876dfe4dadbe7c5028a4a6b507a/" rel="bookmark">
			ChromaDB教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 Chroma DB，管理文本文档、将文本嵌入以及进行相似度搜索。
随着大型语言模型 （LLM） 及其应用的兴起，我们看到向量数据库越来越受欢迎。这是因为使用 LLM 需要一种与传统机器学习模型不同的方法。
LLM 的核心支持技术之一是向量嵌入。虽然计算机不能直接理解文本，但嵌入以数字表示文本。所有用户提供的文本都将转换为嵌入，用于生成响应。
将文本转换为嵌入是一个耗时的过程。为了避免这种情况，我们使用专门设计的矢量数据库，用于有效存储和检索矢量嵌入。在本教程中，我们将了解矢量存储和 Chroma DB，这是一个用于存储和管理嵌入的开源数据库。此外，我们将学习如何添加和删除文档、执行相似性搜索以及将文本转换为嵌入。
什么是矢量存储？ 向量存储是专门为有效地存储和检索向量嵌入而设计的数据库。之所以需要它们，是因为像 SQL 这样的传统数据库没有针对存储和查询大型向量数据进行优化。
嵌入在高维空间中以数字向量格式表示数据（通常是非结构化数据，如文本）。传统的关系数据库不太适合存储和搜索这些向量表示。
向量存储可以使用相似性算法对相似的向量进行索引和快速搜索。它允许应用程序在给定目标向量查询的情况下查找相关向量。
在个性化聊天机器人的情况下，用户输入生成式 AI 模型的提示。然后，该模型使用相似性搜索算法在文档集合中搜索相似文本。然后，由此产生的信息用于生成高度个性化和准确的响应。这是通过在向量存储中嵌入和向量索引来实现的。
什么是ChromaDB？ Chroma DBhttps://docs.trychroma.com/ChromaDB是一个开源矢量存储，用于存储和检索矢量嵌入。它的主要用途是保存嵌入和元数据，以便以后由大型语言模型使用。此外，它还可用于文本数据的语义搜索引擎。
Chroma DB主要特点：
支持不同的底层存储选项，例如用于独立的 DuckDB 或用于可扩展性的 ClickHouse。提供 Python 和 JavaScript/TypeScript 的 SDK。专注于简单性、速度和支持性分析。 ChromaDB是如何工作的？ 首先，必须创建一个类似于关系数据库中的表的集合。默认情况下，Chroma 使用 将文本转换为嵌入，但您可以修改集合以使用其他嵌入模型。all-MiniLM-L6-v2将具有元数据和唯一 ID 的文本文档添加到新创建的集合中。当您的收藏收到文本时，它会自动将其转换为嵌入。通过文本或嵌入查询集合以接收相似的文档。您还可以根据元数据筛选出结果。 在下一部分中，我们将使用 Chroma 和 OpenAI API 来创建我们自己的矢量数据库。
ChromaDB入门 在本节中，将创建一个向量数据库，添加集合，向集合添加文本，并执行查询搜索。
首先，我们将为向量数据库和更好的嵌入模型安装。确保您已设置 OpenAI API 密钥。
注意：Chroma 需要 SQLite 3.35 或更高版本。如果遇到问题，请升级到 Python 3.11 或安装旧版本的Chroma # 环境安装 !pip install chromadb openai 您可以通过创建不带设置的 Chroma DB 客户端来创建用于测试的内存数据库。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04fd7876dfe4dadbe7c5028a4a6b507a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b58cd4ed2b99e869d85408190223ce76/" rel="bookmark">
			AI大模型日报#0422：深扒「全球TOP 10大模型团队」、扎克伯格 Llama 3访谈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导读： 欢迎阅读《AI大模型日报》，内容基于Python爬虫和LLM自动生成。目前采用“文心一言”生成了每条资讯的摘要。
标题: 文本生成8K、360度全景世界！Model 3重磅发布
摘要: Blockade Labs发布了新模型Model 3，相比Model 2，其生成效果大幅提升，支持更高清分辨率，减少灰度值，使生成内容更细腻。目前可免费体验，但部分自定义功能暂不可用。该平台适合大型模拟世界开发人员，可节省开发时间。非技术人员未来也可通过自定义功能使用。
网址: 文本生成8K、360度全景世界！Model 3重磅发布|录屏|视频文件|model 3_网易订阅
标题: 深扒「全球 10 大顶尖大模型团队」，167 位华人榜上有名
摘要: 要点提炼： 中国在大模型领域注重培养青年力量，青年成员占比高达84%。国外大模型团队中华人占比18.7%，其中86位曾在中国高校就读。大模型核心成员的学术影响力集中在H-index35以内。除了数据、算力和算法，技术、工程人才储备也是OpenAI领先的关键。大模型人才是实现通用人工智能和超级智能的重要力量。
网址: 深扒「全球 10 大顶尖大模型团队」，167 位华人榜上有名|学术|人工智能技术_网易订阅
标题: Sora之后，OpenAI Lilian Weng亲自撰文教你从头设计视频生成扩散模型
摘要: 扩散模型已证明在图像合成上的强大能力，研究社区正转向更复杂的视频生成任务。视频生成需要保持不同帧间的时间一致性，编码更多世界知识，且高质量视频数据收集更为困难。OpenAI安全系统负责人Lilian Weng撰写了关于视频生成扩散模型的博客，介绍了该任务的挑战和从头建模视频生成的方法。如需了解扩散模型在图像生成方面的应用，可参考作者之前的博文。
网址: Sora之后，OpenAI Lilian Weng亲自撰文教你从头设计视频生成扩散模型 | 机器之心
标题: 首个基于Mamba的MLLM来了！模型权重、训练代码等已全部开源
摘要: 多模态大型语言模型MLLM应用广泛，但基于低效的Transformer网络。Cobra模型展现高效性能，线性建模更快，且在视觉错觉和空间关系判断上表现良好，参数较少但性能与先进模型相当。
网址: 首个基于Mamba的MLLM来了！模型权重、训练代码等已全部开源 | 机器之心
标题: Llama 3超大杯有何惊喜？Meta会一直开源吗？当初为何笃信元宇宙？扎克伯格新访谈回应一切
摘要: Meta宣布推出Llama 3，包括8B、70B和405B三个版本，其中405B版本性能逼近GPT-4。这可能促使OpenAI加速推出新模型。Meta CEO扎克伯格表示，Llama 3 405B将是密集模型，年底前发布，并计划年底拥有约35万块GPU。此外，Meta也在扩大GPU规模，目前已建立由数万块GPU构成的集群，以支持其AI研究。关于未来模型方向和元宇宙动力等问题，扎克伯格在访谈中进行了回应。
网址: Llama 3超大杯有何惊喜？Meta会一直开源吗？当初为何笃信元宇宙？扎克伯格新访谈回应一切 | 机器之心
标题: 亚马逊云科技王晓野：八成CEO认为生成式AI在18个月内颠覆所有行业丨中国AIGC产业峰会
摘要: 在中国AIGC产业峰会上，亚马逊云科技大中华区产品部技术总监王晓野指出，80%的企业CEO认为生成式AI将在18个月内颠覆所有行业。为应对这一趋势，企业需要关注数据这一核心竞争力，并遵循关键步骤。亚马逊云科技通过三层能力助力企业抓住生成式AI的机遇。此次峰会引发了广泛关注，凸显了生成式AI在业界的重要性和影响力。
网址: 亚马逊云科技王晓野：八成CEO认为生成式AI在18个月内颠覆所有行业丨中国AIGC产业峰会 | 量子位
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b58cd4ed2b99e869d85408190223ce76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bb9d27a39fe040dc4b935c96ad7bc0e/" rel="bookmark">
			Java List集合取交集的五种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java中，List 集合是用于存储一系列对象的数据结构。当我们要获取两个 List 集合的交集时，有多种方法可以实现。下面将介绍几种常见的方式。
1. 使用Java 8的Stream API Java 8引入了Stream API，它提供了一种声明式的方式来处理数据。
import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class ListIntersection { public static void main(String[] args) { List&lt;Integer&gt; list1 = Arrays.asList(1, 2, 3, 4, 5); List&lt;Integer&gt; list2 = Arrays.asList(4, 5, 6, 7, 8); List&lt;Integer&gt; intersection = list1.stream() .filter(list2::contains) .collect(Collectors.toList()); System.out.println("Intersection: " + intersection); } } 这段代码首先创建了两个 List 对象 list1 和 list2。然后，通过 list1.stream() 获取 list1 的Stream对象，并使用 filter 方法筛选出同时存在于 list2 中的元素。最后，使用 collect 方法将结果转换回 List 对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bb9d27a39fe040dc4b935c96ad7bc0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d10a0f6edd678d01f9b917b0d3235de6/" rel="bookmark">
			前端基于VUE&#43;ElementUI实现table行上移或下移(支持跨页移动)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做后台管理遇见了一个这样的需求：table列表需要支持上下移动数据，并且也需要满足跨页移动，前端把数据移动整理之后，提交给后端进行保存（平常这种数据移动都是调用后端的接口，然后在查询数据就可以完成了，但是这次显然不能这么做，因为后端只有一个保存数据的接口，所以这就需要前端自己处理数据了，废话少说，上效果图和源码！
静态效果图 动态效果图
实现源码（HTML） &lt;el-table :data="paginatedData"&gt; &lt;el-table-column label="操作" prop="operate"&gt; &lt;template slot-scope="scope"&gt; &lt;el-button-group&gt; &lt;el-button title="下移" :disabled="isDown(scope.row)" @click="moveupOrmovedown(scope.row, scope.$index, 'down')" &gt; &lt;/el-button&gt; &lt;el-button title="上移" :disabled="scope.$index === 0 &amp;&amp; currentPage === 1" @click="moveupOrmovedown(scope.row, scope.$index, 'up')" &gt; &lt;/el-button&gt; &lt;/el-button-group&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;!-- 页码参考（此处不涉及该功能的任何逻辑，可忽略 --&gt; &lt;el-pagination background :page-size="pageSize" :current-page="currentPage" layout="total, prev, pager, next, jumper" :total="totalSize" @current-change="(val) =&gt; (currentPage = val)" &gt; &lt;/el-pagination&gt; 实现源码（JS） moveupOrmovedown(row, index, type) { let arr = this.filteredData const findIndex = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d10a0f6edd678d01f9b917b0d3235de6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7077a8ab97cb65fc08cefebab5766b72/" rel="bookmark">
			微信小程序：基于MySQL&#43;Nodejs的汽车品牌管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各位好，接上期，今天分享一个通过本地MySQL+Nodejs服务器实现CRUD功能的微信小程序，一起来看看吧~
干货！微信小程序通过NodeJs连接MySQL数据库https://jslhyh32.blog.csdn.net/article/details/137890154?spm=1001.2014.3001.5502
目录
前言 一.Mysql数据库准备
二.新建项目
三.CRUD分别对应的前端
四.Nodejs后端代码
五.功能测试
前言 前端：原生微信小程序后端：Nodejs服务器数据库：MySQL8.0.35 本帖只是一个在技术角度攻坚克难的整理总结，并不是可以直接拿出手的高大上项目，不过只要底层原理清楚，修改前端还是很容易的——即本帖提供一个微信小程序版CRUD系统的框架，大家可以自行改善！博主最近忙着冲毕设，之后要是有时间，回来分享一个升级版。
一.Mysql数据库准备 没什么好说的，先建一张表：
use db2; create table car( id int comment '序号', name char(5) comment '品牌', country varchar(5) comment '国籍', description text comment '英文名' ); 然后直接用可视化工具录入如下数据：
二.新建项目 新建一个项目，删除掉模版的全部代码，分别定义4个页面：select、add、update、drop。此外，记得创建名为Server的文件夹~ 另外，本项目没有设置跳转函数、tabbar等功能，大家自行改变编译路径即可跳转~
三.CRUD分别对应的前端 1.查（select） 结构及样式如下：
&lt;view&gt; &lt;view id="look"&gt; &lt;text style="font-size: 55rpx;"&gt;查询功能实现：&lt;/text&gt; &lt;/view&gt; &lt;form bindsubmit="submit"&gt; &lt;view class="select"&gt; &lt;input id="input" name="name" type="text" placeholder="请输入品牌名"/&gt; &lt;button form-type="submit" id="btn"&gt;搜索&lt;/button&gt; &lt;/view&gt; &lt;/form&gt; &lt;view id="result"&gt; &lt;text&gt;国籍：&lt;/text&gt; &lt;textarea name="" id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7077a8ab97cb65fc08cefebab5766b72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a92c638ed9f1f8df383ed8139d1ab655/" rel="bookmark">
			使用 ollama 部署最新的Llama 3 70B本地模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、ollama是什么? 在本地启动并运行大型语言模型。运行Llama 3，Mistral, Gemma, Code Llama和其他模型。自定义并创建您自己的。 综合优点： 快速下载+容器自动运行大模型，现在下载，马上上手。本地利用 cpu 运行大模型，本地安全可靠。ollama 命令，管理大模型相对方便，也可以多个大模型中切换。终端直接开始聊天。社区提供了支持 web api 方式访问 WebUI。 官方网站： Ollama github ： ollama/ollama: Get up and running with Llama 3, Mistral, Gemma, and other large language models. (github.com) 二、准备和安装工作 设备需求和辅助软件：
Ollama自带docker ，为了方便部署软件。良好的网络环境，大模型还是要先下载下来的。配置要求：一般来说参数越大，需要配置越好。存储空间：确保硬盘空间充足，并且学会设置环境变量来调整保存model的地址，别再下载到C盘了！ model地址和环境变量设置 win10输入path或者环境变量
增加系统环境变量
变量名（不能变）：OLLAMA_MODELS
（盘符和地址自主选择，建议先创建好文件夹）D:\Ollama
下载ollama 进入 ollama 下载页面，选择自己的系统版本的下载并安装即可。
检验是否安装成功 输入 ollama 命令，正常的得出命令行输出，表示已经安装成功，下面有 ollama 的常用命令：
ollama Usage: ollama [flags] ollama [command] Available Commands: serve Start ollama create Create a model from a Modelfile show Show information for a model run Run a model pull Pull a model from a registry push Push a model to a registry list List models cp Copy a model rm Remove a model help Help about any command Flags: -h, --help help for ollama -v, --version Show version information Use "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a92c638ed9f1f8df383ed8139d1ab655/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa77503b4cd4575567054660965b0c6f/" rel="bookmark">
			【数据结构】时间复杂度的例题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎁个人主页：我们的五年
🔍系列专栏：数据结构
🌷追光的人，终会万丈光芒
目录
🌷例题1：
🌷例题2：
🌷例题3：
🌷例题4：
🌷例题5：
模拟实现可以看成这样：
🌷例题6：
🌷例题7：
🌷例题8：
🌷例题9：
前言：
这篇文章是关于时间复杂度的一些例题，关于时间复杂度和空间复杂度和算法的计算效率的基本知识点我放在这篇文章。
数据结构：时间复杂度
最后喜欢的铁子可以点点关注，互关私信，感谢大家的支持，祝大家天天开心！
🌷例题1： // 请计算一下Func1中++count语句总共执行了多少次？ void Func1(int N) { int count = 0; for (int i = 0; i &lt; N ; ++ i) { for (int j = 0; j &lt; N ; ++ j) { ++count; } } for (int k = 0; k &lt; 2 * N ; ++ k) { ++count; } int M = 10; while (M--) { ++count; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa77503b4cd4575567054660965b0c6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f579a81aaccc60928ac704253a657729/" rel="bookmark">
			Hive 中常用的函数以及数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据类型 1.基本数据类型: 数据类型大小范围示例TINYINT1byte-128 ~ 127100YSMALLINT2byte-32768 ~ 32767100SINT4byte-2^32~ 2^32-1100BIGINT8byte-2^64~ 2^64-1100LFLOAT4byte单精度浮点数5.21DOUBLE8byte双精度浮点数5.21DECIMAL-高精度浮点数DECIMAL(9,8)BOOLEAN-布尔型true/falseBINARY-字节数组- 2.字符串类型: 数据类型长度示例STRING-'abc'VARCHAR1-65535'abc'CHAR1-255'abc' 对于VARCHAR创建时需指定长度，如果插入的字符串超过了指定的长度，则会被截断，尾部的空格也会作为字符串的一部分，影响字符串的比较。
对于CHAR类型来说，它是固定长度的，如果插入的字符串长度不如指定的长度，则会用空格补齐。但是尾部的空格不影响字符串的比较。
3.日期与时间戳类型:(格式很重要,格式不对加载数据为空值) 数据类型格式示例DATEyyyy-MM-dd2020-07-04TIMESTAMPSyyyy-MM-dd HH:mm:ss.fffffffff2020-07-04 12:36:25.111 4.集合类型: ARRAY：ARRAY 类型是由一系列相同数据类型的元素组成，这些元素可以通过下标来访问。 比如有一个 ARRAY 类型的变量 fruits，它是由['apple','orange','mango']组成，可以由下标fruits[1]来访问元素orange。hive中经过split拆分后为ARRAY类型；
MAP：MAP 包含 key-&gt;value 键值对，可以通过 key 来访问元素。比如变量userlist是一个 map类型：username:password，需要通过userlist['username']来得到这个用户对应的 password。
STRUCT：STRUCT 可以包含不同数据类型的元素。这些元素可以通过点语法的方式来得到所需要的元素，比如 user 是一个 STRUCT 类型：15,北京。可以通过 user.address 得到这个用户的地址。
存储格式 Hive会为每个创建的数据库在HDFS上创建一个目录，该数据库的表会以子目录形式存储，表中的数据会以表目录下的文件形式存储。对于default数据库，默认的缺省数据库没有自己的目录，default数据库下的表默认存放在/user/hive/warehouse目录下。
textfile为默认格式，存储方式为行存储。数据不做压缩，磁盘开销大，数据解析开销大。 SequenceFile是Hadoop API提供的一种二进制文件支持，具有使用方便、可分割、可压缩的特点。 SequenceFile支持三种压缩选择：NONE, RECORD, BLOCK。 Record压缩率低，一般建议使用BLOCK压缩。 RCFile 一种行列存储相结合的存储方式。 ORCFile 数据按照行分块，每个块按照列存储，其中每个块都存储有一个索引。hive给出的新格式，属于RCFILE的升级版,性能有大幅度提升,而且数据可以压缩存储,压缩快 快速列存取。 Parquet Parquet也是一种行式存储，同时具有很好的压缩性能；同时可以减少大量的表扫描和反序列化的时间。
数据格式 当数据存储在文本文件中，必须按照一定格式区别行和列，并且在Hive中指明这些区分符。Hive默认使用了几个平时很少出现的字符，这些字符一般不会作为内容出现在记录中。
\n 对于文本文件来说，每行是一条记录，所以\n 来分割记录
^A (Ctrl+A) 分割字段，也可以用\001 来表示
^B (Ctrl+B) 用于分割 Arrary 或者 Struct 中的元素，或者用于 map 中键值之间的分割，也可以用\002 分割。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f579a81aaccc60928ac704253a657729/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c55c431f1002bfd953e106ec3dff799d/" rel="bookmark">
			【MySQL | 第七篇】一文读懂MySQL存储引擎（InnoDB、MyISAM、Memory）、MVCC（易懂、明白）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 7.一文读懂MySQL存储引擎7.1InnoDB存储引擎7.1.1概述7.1.2体系架构7.1.3存储结构（1）表空间①系统表空间②独立表空间③通用表空间④undo表空间⑤临时表空间 （2）段（3）区（4）页（5）行 7.1.4 MVCC（多版本并发控制）（1）相关概念（2）实现原理①三个隐藏字段②undo log 日志③undo log 版本链④ReadView 快照 （3）RC（读已提交）隔离级别：举例①事务1-4过程如下：②分析ReadViw，提取数据③总结 （4）RR（可重复读）隔离级别：举例（5）扩展：RR能解决幻读问题吗？ 7.2MyISAM存储引擎7.2.1概述7.2.2应用场景 7.3Memory存储引擎7.3.1概述7.3.2应用场景 7.一文读懂MySQL存储引擎 MySQL存储引擎一共有InnoDB、MyISAM、Memory等常见的存储引擎；下面将从存储结果、事务支持、行/表级锁、外键支持、以及关键特性 共五个角度阐述上面的存储引起； 7.1InnoDB存储引擎 7.1.1概述 InnoDB 是 MySQL数据库系统中最常用的存储引擎之一，尤其在事务处理、并发控制及数据可靠性方面表现突出。以下是对 InnoDB 存储引擎的主要特点和功能的概述：
存储结构：InnoDB 存储引擎将数据按照页（Page）的方式组织在磁盘上，并且采用B+树作为索引结构，使得数据检索效率相对较高。
事务支持：InnoDB 提供完全的 ACID（原子性、一致性、隔离性、持久性）事务支持，适用于需要高可靠性和数据一致性的应用场景，如银行交易、电子商务等。
行级锁定：InnoDB 实现了行级锁定机制，这意味着在执行事务时只锁定受影响的行，而非整个表，这大大提高了并发环境下多用户读写数据的性能。
外键约束：支持外键约束，确保数据的一致性和参照完整性，防止非法的数据操作。
缓冲池：内存管理中，InnoDB 使用了一个称为缓冲池的内存区域，用于缓存表数据和索引，减少磁盘 I/O 操作，提高数据读写的效率。
崩溃恢复：提供完善的崩溃恢复机制，包括 redo 日志（重做日志）和 undo 日志（撤销日志），保证即使在系统崩溃后也能恢复到崩溃前的一致状态。
内存结构：InnoDB 内部有多个内存区域，如redo log buffer、undo logs、buffer pool manager等，用于管理事务、缓存数据以及辅助事务处理过程。
关键特性：
多版本并发控制（MVCC）：InnoDB 采用 MVCC 来实现高并发下的读写操作，允许在不阻塞读操作的情况下进行写操作，提升了并发性能，降低了死锁概率。
插入缓冲（Insert Buffer）：优化对非唯一二级索引插入操作的性能。
两次写（Double Write）：用于保护数据页免受意外宕机造成的数据损坏。
自适应哈希索引（Adaptive Hash Index）：自动为经常使用的查询创建哈希索引，提高查询速度。
异步IO（Async I/O）：提高磁盘I/O性能，减少等待时间。
7.1.2体系架构 InnoDB存储引擎的体系架构主要由内存结构、磁盘存储、线程与并发控制、数据阻止结构、以及外部接口共五个方面组成内存结构： Buffer Pool (缓冲池)：它是 InnoDB 的核心组件之一，用于缓存表的数据页和索引页，减少对磁盘 I/O 的访问次数。缓冲池中的数据页在事务提交时会根据需要刷新到磁盘。Change Buffer（变更缓冲区）：对于非唯一二级索引的插入操作，如果所在的数据页尚未加载到缓冲池中，InnoDB 会将这部分修改暂存在变更缓冲区中，待后续数据页加载到缓冲池时再合并写入。Adaptive Hash Index（自适应哈希索引）：InnoDB 会根据查询模式自动生成哈希索引，加快某些查询的性能。Log Buffer（日志缓冲区）：存储待写入重做日志文件（redo log）的事务日志记录，以确保事务的持久性和崩溃恢复能力。 磁盘存储： 表空间（Tablespaces）：InnoDB 使用表空间作为逻辑上的数据容器，每个表空间可以包含多个数据文件。系统表空间存放全局数据，用户表空间存放用户数据和索引。重做日志文件（Redo Log）：记录了对数据的更改操作，以支持事务的持久性和崩溃恢复。回滚段（Undo Logs）：用于实现事务的原子性和一致性，存储了事务回滚所需的历史版本数据。 线程与并发控制： 后台线程：包括 master thread、IO thread（用于处理redo log刷盘）、purge thread（用于清理不再需要的undo日志）等，共同维护数据库的正常运行和数据一致性。行级锁定（Row-level Locking）：InnoDB 支持行级锁定，有效减少并发事务之间的冲突，提高并发性能。多版本并发控制（MVCC）：InnoDB 通过 MVCC 实现了非锁定读（Read Committed 或 Repeatable Read 隔离级别下），减少了事务之间的阻塞。 数据组织结构： 页（Page）：InnoDB 使用页作为基本的存储单位，每个页通常为16KB，存储表数据和索引。B+树索引：InnoDB 表的数据和二级索引都采用 B+树结构组织，保证高效的数据检索和范围查询。 外部接口： InnoDB 通过与 MySQL Server 的交互接口，响应来自客户端的 SQL 请求，执行事务处理、查询优化和数据检索等功能。 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c55c431f1002bfd953e106ec3dff799d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ce8204d5498cde41b123a7017131a00/" rel="bookmark">
			【Python】serial库的介绍及用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、应用场景
2、serial-三方库
1、应用场景 serial库，也被称为pySerial，主要用于串行通信，它在以下几个场景中被广泛应用：
嵌入式系统通信：许多嵌入式系统（如Arduino、Raspberry Pi等）都使用串行通信进行数据传输。pySerial可以帮助Python程序与这些设备进行通信。硬件设备控制：许多硬件设备（如机器人、传感器、GPS模块等）都使用串行接口进行控制。pySerial可以帮助Python程序发送控制命令到这些设备。调试和测试：在硬件和嵌入式系统开发中，串行通信常常被用于调试和测试。pySerial可以帮助开发者从设备接收调试信息，或向设备发送测试命令。数据采集：许多科学仪器（如光谱仪、示波器等）都使用串行接口进行数据输出。pySerial可以帮助Python程序从这些设备采集数据。模拟串行通信：pySerial还可以创建虚拟的串行端口，用于在没有实际硬件设备的情况下模拟串行通信。 2、serial-三方库 serial库（pySerial）提供了一系列的方法来处理串行通信，以下是一些主要的方法：
Serial()：这是pySerial库的主要类，用于创建一个串行端口的实例。它的参数包括端口名、波特率、字节大小、奇偶校验位、停止位等。open()：打开一个先前创建但未打开的串行端口。close()：关闭一个打开的串行端口。read()：从串行端口读取指定数量的字节。write()：向串行端口写入字节数据。readline()：从串行端口读取一行，行结束符为'\'。readlines()：从串行端口读取所有行，返回一个列表，每一行作为列表的一个元素。flush()：清空写缓冲区，确保所有输出都被发送。in_waiting：返回输入缓冲区中的字节数。out_waiting：返回输出缓冲区中的字节数。 以上是一些基本的方法，pySerial还提供了其他更多的方法和属性，可以参考其官方文档进行了解。
以下是一些pySerial库中常用方法的介绍和使用例子：
Serial()：创建一个串行端口的实例。例如： import serial ser = serial.Serial('/dev/ttyUSB0', 9600) 这将打开名为'/dev/ttyUSB0'的串行端口，并设置波特率为9600。
open()：打开一个先前创建但未打开的串行端口。例如： ser = serial.Serial() ser.port = '/dev/ttyUSB0' ser.baudrate = 9600 ser.open() close()：关闭一个打开的串行端口。例如： ser.close() read()：从串行端口读取指定数量的字节。例如： data = ser.read(10) # 读取10个字节 write()：向串行端口写入字节数据。例如： ser.write(b'Hello World') # 写入字节字符串 readline()：从串行端口读取一行，行结束符为'\'。例如： line = ser.readline() # 读取一行 readlines()：从串行端口读取所有行，返回一个列表，每一行作为列表的一个元素。例如： lines = ser.readlines() # 读取所有行 flush()：清空写缓冲区，确保所有输出都被发送。例如： ser.flush() # 清空写缓冲区 in_waiting：返回输入缓冲区中的字节数。例如： bytes_in_buffer = ser.in_waiting # 获取输入缓冲区中的字节数 out_waiting：返回输出缓冲区中的字节数。例如： bytes_to_be_sent = ser.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ce8204d5498cde41b123a7017131a00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb457c8f7a8b41677828ca0c38b5c165/" rel="bookmark">
			【Flutter】The binary version of its metadata is 1.8.0, expected version is 1.6.0.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 Module was compiled with an incompatible version of Kotlin. The binary version of its metadata is 1.8.0, expected version is 1.6.0. 原因分析： The binary version of its metadata is 1.8.0, expected version is 1.6.0.
jetified-kotlin-stdlib-1.8.22.jar这两个就是关键信息；需要将kotlin的版本升级到1.8.22或以上都可以。
解决方案： build.gradle (android)里修改kotlin的版本为1.8.22，然后Sync Now。
ext.kotlin_version = '1.8.22'
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8bc8a48d177ec91991e8e2bedf39892/" rel="bookmark">
			AI绘画Stable Diffusion模型推荐，为什么我建议你使用DreamShaper XL！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DreamShaper XL 是一款通用型 SD 模型，旨在擅长处理各种类型的图像生成，包括照片、艺术、动漫和漫画。它被设计用来与其他模型竞争，例如 SDXL 1.0。
DreamShaper XL 是一个功能强大且多用途的模型，适用于各种创作需求。当前在civitai属于最受欢迎的优秀模型之一。
模型下载地址：https://civitai.com/models/112902/dreamshaper-xl
如无法下载，请看文末扫描获取
DreamShaper XL 在多个方面表现出色，包括：
能够生成高质量的图像，即使在面对复杂的描述时也能保持细节和清晰度。
擅长处理各种风格和主题，从照片写实到抽象艺术。
拥有较高的速度和效率，能够快速生成图像。
最近，SDXL Turbo和Lightning 合并模型2个版本已经发布。DreamShaper XL 的特点包括：
多样性：它可以生成写实、原画、2.5D 等多种类型的图片。
人像和风景图：DreamShaper 能够生成出色的人像和风景图。
模型适配：在最新发布了2个极速出图合并版本，分别是SDXL Turbo版本和字节Lightning版本。它们都是目前优秀的扩散模型蒸馏技术应用，能够实现4到8步迭代快速出图，特别针对低显存消费级GPU用户，是一个不错的选择。特别字节跳动公司推出的Lightning模型，已经有不少的知名SD模型跟进完成了Lightning版本的更新。
SDXL-Lightning是一个极速的文本到图像生成模型。它能够在几步之内生成高品质的1024px图像。SDXL-Lightning模型采用渐进式对抗蒸馏技术，实现仅需少量几步(2步、4步、8步)，就可以快速的秒级出图效果。相比传统的Diffusion模型的20到40次步迭代，SDXL-Lightning出图速度提升了数十倍。
SDXL-Lightning模型是从stabilityai/stable-diffusion-xl-base-1.0 蒸馏而来。huggingface开源模型库中包含了1步、2步、4步和8步蒸馏模型的检查点。官方指出其中的2步、4步和8步模型的生成质量令人惊叹，而1步模型则属于实验性模型。SDXL-Lightning模型使用4步生产迭代，已经能够生成高度逼真和细节清晰（如任务微笑、纹理效果效果）的图像，同时能够保持与用户输入的文本提示语Prompt的高度匹配度。
SDXL-Lightning采用的方法属于模型蒸馏范畴，并与现有方法相比实现了极大的质量提升。SDXL-Lightning的方法结合了渐进式和对抗性蒸馏的优势。渐进式蒸馏确保了蒸馏模型遵循与原始模型相同的ODE流动，并具有相同的模式覆盖。然而，使用均方误差（MSE）损失的渐进式蒸馏在少于8个推理步骤下会产生模糊的结果。为缓解这个问题，SDXL-Lightning在蒸馏的每个阶段使用对抗性损失来平衡质量和模式覆盖。渐进式蒸馏还带来了额外的好处，即对于多步采样，模型预测ODE轨迹上的下一个位置，而不是每次都跳到ODE终点，这是由蒸馏方法完成。这样更好地保留了原始模型的行为，并且更容易与LoRA模块和ControlNet控制插件兼容。
SDXL-Lightning模型提供了完整的 UNet 和 LoRA 检查点。完整的 UNet 模型拥有最佳质量，而 LoRA 模型则可以应用于其他基础模型。
chinese girl, 18yo, A close-up of an Asian lady with sunglasses
A dog with soft fur and bright eyes jumping after a toy, in a cozy living room
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8bc8a48d177ec91991e8e2bedf39892/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0b8eef0fbb6968d6396468edefe215d/" rel="bookmark">
			解决 Tomcat 跨域问题 - Tomcat 配置静态文件和 Java Web 服务（Spring MVC Springboot）同时允许跨域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决 Tomcat 跨域问题 - Tomcat 配置静态文件和 Java Web 服务（Spring MVC Springboot）同时允许跨域 Tomcat 配置允许跨域Web 项目配置允许跨域Tomcat 同时允许静态文件和 Web 服务跨域 偶尔遇到一个 Tomcat 部署项目跨域问题，因为已经处理过太多跨域了，觉得很简单 。
结果尝试多次均不能达到想要的结果，又经过 Nginx、Tomcat 以及项目配置才完全搞定。
另外，之前总结了篇 Web 项目跨域问题（Geoserver），也可以综合参考。
本文包含 Tomcat 配置允许跨域、Web 项目配置允许跨域以及同时允许跨域三部分。
Tomcat 配置允许跨域 使用 Tomcat 作为静态文件服务还是比较简单和常用的，而跨域问题也比较容易解决。
Tomcat 静态文件允许跨域，设置比较简单，百度一搜一堆，这里简单贴一下。
1.Tomcat web.xml 配置允许所有跨域
设置之后，所有静态文件以及服务均被允许跨域。
（1） 当未配置允许跨域时，报跨域错误
浏览器直接访问是正常的：
（2）Tomcat conf/web.xml 文件配置允许跨域
&lt;filter&gt; &lt;filter-name&gt;CorsFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.catalina.filters.CorsFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;cors.allowed.origins&lt;/param-name&gt; &lt;param-value&gt;*&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.allowed.methods&lt;/param-name&gt; &lt;param-value&gt;GET,POST,HEAD,OPTIONS,PUT&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.allowed.headers&lt;/param-name&gt; &lt;param-value&gt;*&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.exposed.headers&lt;/param-name&gt; &lt;param-value&gt;Access-Control-Allow-Origin,Access-Control-Allow-Credentials&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.support.credentials&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CorsFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 配置之后，重启 Tomcat，再次访问则正常：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0b8eef0fbb6968d6396468edefe215d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a767dcce2f50474cd2760c74b8d1f44/" rel="bookmark">
			一文掌握：数据湖是什么？可不是数据仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是数据湖 数据湖（Data Lake）是指一个大型数据存储和处理系统，它能够存储各种类型和格式的数据，包括结构化数据、半结构化数据和非结构化数据。数据湖的目的是为了让企业可以更好地管理和利用大量的数据，以便进行数据分析、机器学习等工作。
数据湖通常采用分布式计算和存储技术，如Hadoop、Spark等，能够处理海量的数据并提供高可靠性和高可扩展性。与传统的数据仓库不同，数据湖不需要对数据进行预处理和格式化，而是将所有数据存储在原始状态下，以便后续的数据分析和挖掘。
数据湖的优势在于能够存储和处理各种类型和格式的数据，同时可以快速响应企业的数据需求，提供实时的数据分析和挖掘服务。但也存在一些挑战，如数据管理、数据安全性和数据质量等问题，需要企业进行有效的管理和监控。
二、数据湖和数据仓库的区别 数据湖（Data Lake）和数据仓库（Data Warehouse）是两种不同的数据存储和处理架构。
1. 数据结构：数据仓库通常采用结构化的数据模型，需要对数据进行预处理、清洗和转换，以适应特定的数据模式和业务需求。而数据湖则可以存储各种类型和格式的数据，包括结构化数据、半结构化数据和非结构化数据，不需要对数据进行预处理和格式化。
2. 数据存储：数据仓库通常采用集中式的数据存储方式，将数据存储在关系数据库中。而数据湖则可以采用分布式存储系统，如Hadoop、Spark等，能够处理海量的数据并提供高可靠性和高可扩展性。
3. 数据处理：数据仓库通常采用批量处理的方式，将数据定期导入到数据仓库中进行分析和挖掘。而数据湖则支持实时数据处理和流式数据分析，能够快速响应企业的数据需求。
4. 数据访问：数据仓库通常采用预定义的查询和报表工具来访问数据，并提供事先定义好的数据视图和维度模型。而数据湖则提供更灵活的数据访问方式，可以使用各种数据处理工具和编程语言进行数据分析和挖掘。
5. 数据治理：数据仓库通常有严格的数据治理和数据管理规范，包括数据质量控制、数据安全性和数据一致性等。而数据湖则更加灵活，需要企业进行有效的数据管理和监控，以保证数据的质量和安全性。
总的来说，数据仓库更适用于结构化数据和预定义的分析需求，而数据湖更适用于各种类型和格式的数据以及实时的数据分析和挖掘需求。在实际应用中，数据湖和数据仓库可以相互补充，形成一个完整的数据架构。
三、数据湖存储数据的优劣势 数据湖存储数据的优势和劣势如下：
优势：
1. 存储各种类型和格式的数据：数据湖能够存储结构化数据、半结构化数据和非结构化数据，包括文本、图像、音频等各种形式的数据。这使得企业可以将所有数据集中存储在一个地方，方便后续的数据分析和挖掘。
2. 高可扩展性：数据湖采用分布式存储和计算技术，如Hadoop、Spark等，能够处理海量的数据并提供高可靠性和高可扩展性。企业可以根据需要随时扩展存储和计算资源，以适应不断增长的数据量和分析需求。
3. 灵活的数据访问：数据湖提供了灵活的数据访问方式，可以使用各种数据处理工具和编程语言进行数据分析和挖掘。企业可以根据具体需求选择合适的工具和技术，以便更好地利用数据湖中的数据。
4. 实时数据处理：数据湖支持实时数据处理和流式数据分析，能够快速响应企业的数据需求。企业可以实时监控和分析数据，及时做出决策和调整。
劣势：
1. 数据管理和治理：数据湖存储了大量的原始数据，需要企业进行有效的数据管理和治理，以保证数据的质量和安全性。企业需要建立数据分类、命名、版本控制等规范，同时加强数据安全和隐私保护措施。
2. 数据质量控制：由于数据湖存储了各种类型和格式的数据，数据质量控制变得更加复杂。企业需要进行数据清洗、去重、标准化等处理，以确保数据的准确性和一致性。
3. 数据获取和分析复杂性：数据湖中的数据通常是以原始状态存储的，需要进行适当的数据处理和分析才能得到有用的信息。这可能需要专业的数据科学家和分析师来进行复杂的数据处理和分析工作。
总的来说，数据湖存储数据的优势在于能够存储各种类型和格式的数据，提供高可扩展性和灵活的数据访问方式。然而，数据湖也需要企业进行有效的数据管理和治理，并面临数据质量控制和数据分析复杂性等挑战。
四、数据湖服务商 目前市场上的云服务商提供了各种数据湖服务，以下是一些主要的云服务商和他们提供的数据湖服务：
1. 亚马逊AWS：AWS提供了Amazon S3作为数据湖的存储服务，可以存储各种类型和格式的数据。此外，AWS还提供了Amazon Glue用于数据清洗和转换，Amazon Athena用于查询和分析数据，以及Amazon Redshift用于数据仓库和分析。
2. 微软Azure：Azure提供了Azure Data Lake Storage作为数据湖的存储服务，可以存储大规模的结构化和非结构化数据。此外，Azure还提供了Azure Data Factory用于数据集成和转换，Azure Databricks用于数据分析和挖掘，以及Azure Synapse Analytics用于数据仓库和分析。
3. 谷歌云GCP：GCP提供了Google Cloud Storage作为数据湖的存储服务，可以存储各种类型和格式的数据。此外，GCP还提供了Google BigQuery用于数据分析和挖掘，以及Google Dataflow用于数据流处理和转换。
4. 阿里云：阿里云提供了阿里云对象存储OSS作为数据湖的存储服务，可以存储各种类型和格式的数据。此外，阿里云还提供了MaxCompute用于数据分析和挖掘，以及DataWorks用于数据集成和转换。
以上只是一些主要的云服务商提供的数据湖服务，实际上还有其他云服务商也提供了类似的服务。选择适合自己需求的云服务商需要综合考虑存储能力、计算能力、数据处理工具和服务支持等因素。
五、数据湖与数据可视化、数字孪生 数据湖、数据可视化和数字孪生是数据领域中的三个不同概念，它们之间存在一定的关系。
数据湖是一个存储大规模结构化和非结构化数据的存储系统，它可以存储各种类型和格式的数据，包括原始数据和派生数据。数据湖提供了灵活的数据访问方式，可以使用各种数据处理工具和编程语言进行数据分析和挖掘。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a767dcce2f50474cd2760c74b8d1f44/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/402/">«</a>
	<span class="pagination__item pagination__item--current">403/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/404/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>