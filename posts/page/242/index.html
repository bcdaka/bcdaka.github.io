<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5820c6d10271eabf2dad5214c792e3f/" rel="bookmark">
			ansible file模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		file模块 管理文件和目录的属性，如状态（是否存在）、权限、所有权等。
1、创建文件： 使用file模块的state参数设置为touch可以创建文件。例如：
ansible 组名 -m file -a "path=/csdn/jingyu state=touch" - name: 创建一个文件 file: path: /csdn/jingyu state: touch mode: '0755' 在/csdn目录下创建一个jingyu文件。（如果不存在，则创建，如果已存在则不会创建。） mode是设置文件的权限0755给予所有者读写执行权限，组用户和其他用户只有读和执行权限。
2、创建目录 使用file模块的state参数设置为directory可以创建文件。例如：
ansible 组名 -m file -a "path=/csdn/jingyu state=directory mode=0755" - name: Ensure the directory exists file: path: /csdn/jingyu state: directory mode: '0755' 在/csdn目录下创建一个jingyu目录。（如果不存在，则创建，如果已存在则不会创建。） mode是设置文件的权限0755给予所有者读写执行权限，组用户和其他用户只有读和执行权限。
3、修改文件权限： owner: 设置文件的所有者用户名。group: 设置文件的所属组名。mode: 设置文件的权限。 - name: Change file permissions and ownership file: path: /csdn/jingyu owner: jingyu group: root mode: '0644' 修改/csdn/jingyu文件属性属主是jingyu；属组是root，文件权限是0644.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5820c6d10271eabf2dad5214c792e3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8133b9ca5d0d0ac1919233a18a78e696/" rel="bookmark">
			Spring Boot如何集成WebSocket
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Spring Boot中集成WebSocket，你通常可以使用Spring框架提供的WebSocket支持，包括STOMP（Simple Text Orientated Messaging Protocol）和SockJS（用于浏览器和WebSocket服务器之间的通信的库，提供了多种传输方式）。以下是一个基本的步骤来在Spring Boot应用程序中集成WebSocket：
添加依赖
在你的pom.xml（Maven）或build.gradle（Gradle）中添加Spring Boot的WebSocket和STOMP支持的相关依赖。
对于Maven，你可能需要添加spring-boot-starter-websocket和spring-messaging（如果它没有被包含在starter中）：
xml
org.springframework.boot
spring-boot-starter-websocket
对于Gradle，在build.gradle中添加：
gradle
implementation ‘org.springframework.boot:spring-boot-starter-websocket’
配置WebSocket
在你的配置类上添加@EnableWebSocketMessageBroker注解，并配置消息代理（message broker）和消息前缀（prefix）。
java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {
@Override public void registerStompEndpoints(StompEndpointRegistry registry) { registry.addEndpoint("/ws").withSockJS(); // 设置WebSocket端点并启用SockJS } @Override public void configureMessageBroker(MessageBrokerRegistry registry) { registry.enableSimpleBroker("/topic"); // 设置消息代理前缀 registry.setApplicationDestinationPrefixes("/app"); // 设置应用端点前缀 } // 其他配置... }
创建WebSocket控制器
使用@Controller和@MessageMapping注解来创建WebSocket控制器，处理来自客户端的消息。
java
@Controller
public class WebSocketController {
@MessageMapping("/hello") // 监听客户端发送到"/app/hello"的消息 @SendTo("/topic/greetings") // 将响应发送到"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8133b9ca5d0d0ac1919233a18a78e696/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f61f91d1abe3aa67dd65d52ba94ec188/" rel="bookmark">
			Spark向量化计算在美团生产环境的实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache Spark是一个优秀的计算引擎，广泛应用于数据工程、机器学习等领域。向量化执行技术在不升级硬件的情况下，既可获得资源节省和加速作业执行。Gluten+Velox解决方案为Spark换上了向量化执行引擎，本文将阐述美团在这一方向的实践和思考，希望对大家有所帮助或启发。
1 什么是向量化计算 1.1 并行数据处理：SIMD指令 让我们从一个简单问题开始：假设要实现“数组a+b存入c”，设三个整型数组的长度都是100，那么只需将“c[i] = a[i] + b[i]”置于一个100次的循环内，代码如下：
void addArrays(const int* a, const int* b, int* c, int num) { for (int i = 0; i &lt; num; ++i) { c[i] = a[i] + b[i]; } } 我们知道：计算在CPU内完成，逻辑计算单元操作寄存器中的数据，算术运算的源操作数要先放置到CPU的寄存器中，哪怕简单的内存拷贝也需要过CPU寄存器。所以，完成“c[i] = a[i] + b[i]”需经三步：
加载（Load），从内存加载2个源操作数（a[i]和b[i]）到2个寄存器。计算（Compute），执行加法指令，作用于2个寄存器里的源操作数副本，结果产生到目标寄存器。存储（Store），将目标寄存器的数据存入（拷贝）到目标内存位置（c[i]）。 其中，加载和存储对应访存指令（Memory Instruction），计算是算术加指令，循环执行100次上述三步骤，就完成了“数组a + 数组b =&gt; 数组c”。该流程即对应传统的计算架构：单指令单数据（SISD）顺序架构，任意时间点只有一条指令作用于一条数据流。如果有更宽的寄存器（超机器字长，比如256位16字节），一次性从源内存同时加载更多的数据到寄存器，一条指令作用于寄存器x和y，在x和y的每个分量（比如32位4字节）上并行进行加，并将结果存入寄存器z的各对应分量，最后一次性将寄存器z里的内容存入目标内存，那么就能实现单指令并行处理数据的效果，这就是单指令多数据（SIMD）。
单指令多数据对应一类并行架构（现代CPU一般都支持SIMD执行），单条指令同时作用于多条数据流，可成倍的提升单核计算能力。SIMD非常适合计算密集型任务，它能加速的根本原因是“从一次一个跨越到一次一组，从而实现用更少的指令数完成同样的计算任务。”
1996年，Intel推出的X86 MMX（MultiMedia eXtension）指令集扩展可视为SIMD的起点，随后演进出SSE（1999年）SSE2/3/4/5、AVX（2008）/AVX2（2013）、AVX512（2017）等扩展指令集。在linux系统中可以通过lscpu或cpuid命令查询CPU对向量化指令的支持情况。
1.2 向量化执行框架：数据局部性与运行时开销 执行引擎常规按行处理的方式，存在以下三个问题：
CPU Cache命中率差。一行的多列（字段）数据的内存紧挨在一起，哪怕只对其中的一个字段做操作，其他字段所占的内存也需要加载进来，这会抢占稀缺的Cache资源。Cache命失会导致被请求的数据从内存加载进Cache，等待内存操作完成会导致CPU执行指令暂停（Memory Stall），这会增加延时，还可能浪费内存带宽。变长字段影响计算效率。假设一行包括int、string、int三列，其中int类型是固定长度，而string是变长的（一般表示为int len + bytes content），变长列的存在会导致无法通过行号算offset做快速定位。虚函数调用带来额外开销。对一行的多列进行处理通常会封装在一个循环里，会抽象出一个类似handle的接口（C++虚函数）用于处理某类型数据，各字段类型会override该handle接口。虚函数的调用多一步查表，且无法被内联，循环内高频调用虚函数的性能影响不可忽视。 因此，要让向量化计算发挥威力，只使用SIMD指令还不够，还需要对执行框架层面进行改造，变Row By Row为Block By Block：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f61f91d1abe3aa67dd65d52ba94ec188/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a63bf955b71b96266b25ecae90b80f1a/" rel="bookmark">
			通用大模型VS垂直大模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通用大模型VS垂直大模型，你更青睐哪一方？ 在当前AI大模型的竞争环境中，通用大模型和垂直大模型各有其独特的优势和挑战，选择哪一方更有前景需要考虑多方面因素。
通用大模型的优势与挑战
通用大模型如GPT-3、BERT等在自然语言处理、机器翻译等领域展现了强大的能力。它们的优势包括：
1.广泛的适用性： 能够应用于多种任务和场景，具有很强的通用性。
2.大规模的数据和资源支持： 通用大模型通常由大型公司或组织支持，拥有庞大的数据集和计算资源，能够不断优化和更新模型。
然而，通用大模型也面临以下挑战：
3.资源消耗大： 训练和维护通用大模型需要巨大的计算和存储资源。
4.泛化能力限制： 尽管在许多任务上表现出色，但在某些特定领域可能无法达到垂直大模型的精准性和效果。
垂直大模型的优势与挑战
垂直大模型专注于特定领域或任务，例如医疗、金融、法律等，其优势包括：
5.精准度高： 针对特定领域进行优化，能够提供更精确的预测和建议。
6.快速落地： 针对行业需求进行定制，更容易被企业接受和应用。
垂直大模型的挑战包括：
7.数据稀缺： 在特定领域的数据获取和标记可能更加困难。
8.技术积累和资源限制： 开发和维护垂直大模型需要深入的行业专业知识和大量的技术积累。
选择的依据与前景展望
对于哪一方更有前景，需要考虑到应用场景、市场需求、技术发展趋势等多方面因素。通用大模型在广泛的应用场景和技术基础上具有较强的竞争优势，但垂直大模型则在特定行业应用中能够更快速地实现落地和普及。
从长远来看，通用大模型可能会持续发展并逐步扩展其应用范围，尤其是随着更先进的算法和更强大的计算基础设施的支持。然而，对于一些垂直领域而言，定制化的垂直大模型可能会更具竞争力，因为它们能够更精确地满足特定行业和用户的需求。
因此，大模型的第一个赛点，个人更倾向于看好通用大模型，因其技术的普遍性和可扩展性，但在特定行业和领域，垂直大模型可能会更快地实现落地和深化应用。最终的胜出者可能是那些能够在技术创新、市场适应和资源管理方面找到最佳平衡的解决方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cade047ddc1338c2a405a353537d571/" rel="bookmark">
			泽众云真机-平台即将升级支持华为机型HarmonyOS NEXT系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具小编了解，泽众云真机即将升级支持华为机型HarmonyOS NEXT系统。有些人可能对HarmonyOS NEXT系统了解不多。
之前我们有个银行项目，客户要求测试华为HarmonyOS NEXT系统环境，当时我们云真机尚未有该系统的机型，然后技术人员向华为开发者平台申请升级几台机型。后面问题来了，云真机平台无法支持新系统环境，经过技术团队研发努力，平台即将升级支持HarmonyOS NEXT系统，大家可以第一时间测试自己应用在华为新系统上面运行情况。
目前平台上有华为 mate 60、华为 mate60 pro、华为 mate x5三款机型，机型系统提前升级到HarmonyOS NEXT版本，机型数量有限，大家手速要快，先到先测试。
什么HarmonyOS NEXT系统？
HarmonyOS NEXT是华为公司自研操作系统，该系统是鸿蒙抛弃Linux内核及安卓开放源代码项目（AOSP）等代码的首个大版本，该系统仅支持鸿蒙内核和鸿蒙系统的应用，不再兼容安卓应用。
2023年8月4日，华为推出HarmonyOS NEXT开发者预览版 [1]；2024年1月18日，HarmonyOS NEXT星河版正式面向开发者开放申请 。 HarmonyOS NEXT减少40%冗余代码，提升系统流畅度、能效、安全性。 该系统从编程语言到编译器都是全栈自研，华为称其为“真正的操作系统” ，系统底座采用“盘古”AI大模型、“MindSpore”AI框架、“DevEco Studio”等集成开发环境、“HarmonyOS Design”设计系统、“ArkUI”等编程框架、“方舟编译器”“毕昇编译器”等编译器、“ArkTS”“仓颉”等编程语言、“EROFS”“HMDFS”等分布式文件系统以及鸿蒙内核 。
国内科技信创国产化逐渐加速中，可能2024年下半年，华为机型要全面升级到HarmonyOS NEXT系统，现在我们应该提前准备，做好兼容性测试，务必适配新的操作系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c95120347719b85dbcf68aa461ca0c2c/" rel="bookmark">
			【SpringCloud】借助Redis手动更新Ribbon缓存来解决Eureka微服务架构中服务下线感知的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1.第一次尝试1.1服务被调用方更新1.2压测第一次尝试1.3 问题分析1.4 同步的不是最新列表 2.第二次尝试2.1调用方过滤下线服务2.2压测第二次尝试2.3优化 写到最后 前言 在上文的基础上，通过压测的结果可以看出，使用DiscoveryManager下线服务之后进行压测是不会出现异常情况的，但唯一缺点就是下线服务的方式是取消注册与续约，之后并没有结束进程。也就使得在调用api下线后的服务其实是还存在处理请求的能力的。加之eureka三种级别的缓存同步需要一定时间，Eureka-Client从三级缓存中拉取的并不是实时的服务列表，进而使得Ribbon从Eureka-Client拉取的也不是实时的服务列表。最终导致Ribbon负载均衡到了已经下线的服务实例，并且此时该实例（进程还未关闭）刚好能处理请求！就造成了下线了两个端口的服务实例，但是却还是被负载均衡到来处理请求！
按照这个思路，再去看这张图：
可不可以通过某种手段，当服务下线后去越过三级缓存直接去更新Ribbon缓存来缩短感知时间？
我先说答案——是可以的
1.第一次尝试 1.1服务被调用方更新 手动从Eureka-Client同步服务缓存信息：
在之前分析Ribbon源码的时候，说到了接口路径从http://服务名称/接口路径——&gt;http://服务地址/接口路径，这个过程中调用方的请求被Ribbon拦截器拦截，并且通过负载均衡最终被改写成为了一个准确的服务地址，其中有一个非常重要的方法，getLoadBalancer(“服务名称”)
可见，他通过服务名称就拿到了该服务名称下的所有服务列表（allServerList）和可用服务列表(upServerList)，我们通过这个操作可不可以直接获取到最新一手的可用服务列表并且手动去set进Ribbon的可用服务列表缓存里，让他不再去每过30S同步？
Tips:在我们的SpringCloud项目中有一个非常重要的组件SpringClientFactory是Spring Cloud中用于管理和获取客户端实例的工厂类。在这里面可以获取特定服务的负载均衡器（即ILoadBalancer）
于是，便有了下面的操作，专门配置一个Bean去更新Ribbon缓存，每当调用服务下线接口去下线指定服务后就去自动同步Ribbon缓存，不用再Ribbon每隔30S去自动同步：
@Configuration @Slf4j public class ClearRibbonCache { public void clearRibbonCache(SpringClientFactory clientFactory, List&lt;Integer&gt; portParams) { // 获取指定服务的负载均衡器 ILoadBalancer loadBalancer = clientFactory.getLoadBalancer("user-service"); //在主动拉取可用列表，而不是走拦截器被动的方式——这里 List&lt;Server&gt; reachableServers = loadBalancer.getReachableServers();//这里从客户端获取，会等待客户端同步三级缓存 // 在某个时机需要清除Ribbon缓存 ((BaseLoadBalancer) loadBalancer).setServersList(ableServers); // 清除Ribbon负载均衡器的缓存 } } 于是在下线服务的接口中，就多了一步自动更新缓存的操作（不熟悉这个接口的可以去看上一篇文章）：
@GetMapping(value = "/service-down-list") public String offLine(@RequestParam List&lt;Integer&gt; portParams) { List&lt;Integer&gt; successList = new ArrayList&lt;&gt;(); //得到服务信息 List&lt;InstanceInfo&gt; instances = eurekaClient.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c95120347719b85dbcf68aa461ca0c2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d0b45a6746c15ca40c6702576e3b27a/" rel="bookmark">
			万字长文慎入！AI 智能体架构在推理、规划和工具调用方面的现状揭秘！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.引言 自 ChatGPT 问世以来，首批生成式AI 应用程序主要是采用了文档检索增强生成（RAG）技术构建的聊天应用。尽管在增强RAG系统的稳定性方面已取得显著进展，但众多研究团队正致力于开发新一代AI 应用程序，它们共同聚焦于一个核心议题：agents（智能体）。
学术界在探索最新的基础模型，如 GPT-4，并通过诸如 AutoGPT 和 BabyAGI 等开源项目，致力于开发自主智能智能体系统【19,1】。与仅提供零样本提示（zero-shot prompting）的大型语言模型相比，AI 智能体系统支持更为复杂的交互和任务编排。AI 智能体系统借助规划、循环、反思等控制结构，能够充分利用其内在的推理能力，实现端到端的任务执行。此外，通过整合工具、插件和函数调用，AI 智能体系统能够执行更广泛的任务。
学术界关于单智能体与多智能体系统在解决复杂任务时的适用性讨论仍在进行。单一智能体架构在问题定义明确且无需其他智能体角色或用户反馈的情况下表现突出，而多智能体架构则在需要协作和探索多种执行途径时显示出其优势。
1.1 分类法 **（Agents）：**AI 智能体是能够规划和采取行动以多次迭代执行目标的语言模型驱动实体。AI 智能体架构由单个智能体或多个智能体协同工作解决问题。
通常，每个智能体都有一个角色和可以帮助他们独立或作为团队一部分完成任务的各种工具。有些智能体还包含记忆组件，可以在消息和提示之外保存和加载信息。在本文中，我们遵循由“大脑、感知和行动”组成的智能体定义【31】。这些组件满足智能体理解、推理和对环境采取行动的最低要求。
**智能体人格（Agent Persona）：**智能体人格描述了智能体应扮演的角色或个性，包括对该智能体的任何其他具体指示。人格还包含智能体可以访问的任何工具的描述。研究发现，“塑造的人格会显著影响大型语言模型（LLM）在常见下游任务（如撰写社交媒体帖子）中的行为”【21】。使用多个智能体人格解决问题的解决方案与要求模型逐步分解计划的思维链（CoT）提示相比，显示出显著的改进【28, 29】。
**工具（Tools）：**在 AI 智能体的背景下，工具代表模型可以调用的任何函数。它们允许智能体通过拉取或推送信息与外部数据源交互。例如，一个专业合同撰写人的智能体人格及其相关工具。撰写人有一个解释其角色和任务类型的人格，并配备了添加文档注释、阅读现有文档或发送最终草案电子邮件的工具。
**单智能体架构（Single Agent Architectures）：**这些架构由一个语言模型驱动，将独立进行所有的推理、规划和工具执行。智能体被赋予系统提示和完成任务所需的任何工具。在单智能体模式中，没有其他 AI 智能体的反馈机制，但可能有选项供人类提供反馈以引导智能体。
多智能体架构（Multi-Agent Architectures）：这些架构涉及两个或更多智能体，每个智能体可以利用相同的语言模型或一组不同的语言模型。智能体可能访问相同的工具或不同的工具。每个智能体通常都有自己的角色。多智能体架构可以在任何复杂度水平上有多种组织形式。在本文中，我们将它们分为两类：垂直架构和水平架构。这些类别代表一个光谱的两端，大多数现有架构介于这两者之间。
垂直架构（Vertical Architectures）：在这种结构中，一个智能体充当领导者，其他智能体直接向其报告。根据架构，报告智能体可能只与领导智能体通信。或者，也可能定义一个领导者，并在所有智能体之间共享对话。垂直架构的定义特征包括有一个领导智能体和在协作智能体之间明确的劳动分工。** 水平架构（Horizontal Architectures）**：在这种结构中，所有智能体被视为平等，并参与关于任务的一组讨论。智能体之间的通信在共享线程中进行，每个智能体都可以看到其他智能体的所有消息。智能体还可以自愿完成某些任务或调用工具，这意味着它们不需要由领导智能体分配。水平架构通常用于协作、反馈和小组讨论对任务成功至关重要的任务【2】。
2. 有效智能体的关键考虑因素 2.1 概述 智能体旨在扩展语言模型的能力以解决现实世界的挑战。成功的实现需要强大的问题解决能力，使智能体能够在新任务上表现出色。为了有效地解决现实世界的问题，智能体需要具备推理和规划能力，以及调用工具与外部环境互动的能力。在本节中，我们探讨为什么推理、规划和工具调用对智能体成功至关重要。
2.2 推理和规划的重要性 推理是构成人类认知的基础，使人们能够做出决定、解决问题并理解周围的世界。如果 AI 智能体要有效地与复杂环境互动、做出自主决策并协助人类完成广泛任务，他们需要强大的推理能力。这种“行动”和“推理”之间的紧密协同使得能够迅速学习新任务，并在之前未见过的情况下或信息不确定时实现稳健的决策或推理【32】。此外，智能体需要推理来根据新的反馈或学到的信息调整他们的计划。如果没有推理能力的智能体在执行直接任务时，可能会误解指令、仅基于字面意思做出响应，或未能考虑多步骤的影响。
规划，要求强大的推理能力，通常分为五种主要方法：任务分解、多计划选择、外部模块辅助规划、反思和改进以及记忆增强规划【12】。这些方法允许模型能够将任务分解为子任务，从多个生成的选项中选择一个计划，利用预先存在的外部计划，根据新信息修正先前的计划，或者利用外部信息改进计划。
大多数智能体模式有一个专门的规划步骤，在执行任何行动之前调用一个或多个这些技术来创建计划。例如，“像图一样计划”（PLaG）是一种将计划表示为有向图的方法，其中多个步骤并行执行【15, 33】。与其他方法相比，在包含许多独立子任务的任务上，这种方法能显著提高性能，并从异步执行中获益。
2.3 有效工具调用的重要性 与提示基本语言模型相比，智能体抽象的一个关键好处是智能体能够通过调用多个工具来解决复杂问题。这些工具使智能体能够与外部数据源交互，从现有API发送或检索信息等等。需要大量工具调用的问题往往与需要复杂推理的问题密切相关。
单智能体和多智能体架构都可以通过推理和工具调用步骤来解决具有挑战性的任务。许多方法使用多个推理、记忆和反思的迭代来有效准确地完成问题【16, 23, 32】。它们通常通过将一个更大的问题分解为更小的子问题，然后按顺序使用适当的工具解决每个子问题来实现这一点。
其他致力于推进智能体模式的工作强调，虽然将一个更大的问题分解为更小的子问题可以有效解决复杂任务，但单智能体模式常常难以完成所需的长序列【22, 6】。
多智能体模式可以解决并行任务和鲁棒性问题，因为各个智能体可以独立处理各自的子问题。许多多智能体模式从将复杂问题分解为几个较小的任务开始，然后每个智能体独立解决每个任务，使用他们各自独立的一组工具。
3. 单智能体架构 3.1 概述 在本节中，我们重点介绍一些显著的单智能体方法，如 ReAct、RAISE、Reflexion、AutoGPT + P 和 LATS。每种方法都包含在采取任何行动之前专门用于推理问题的阶段。我们选择这些方法是基于它们对智能体推理和工具调用能力的贡献。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d0b45a6746c15ca40c6702576e3b27a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8752fed5f4c831ce4d5d7ce1b4db9f7/" rel="bookmark">
			前端新手小白的Vue3入坑指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天有同学说想暑假在家学一学Vue3，问我有没有什么好的文档，我给他找了一些，然后顺带着，自己也写一篇吧，希望可以给新手小白们一些指引，Vue3欢迎你。
目录
1 项目安装
1.1 初始化项目
1.2 安装初始化依赖
1.3 启动项目 2 一定会用的第三方库
2.1 js-tool-big-box
2.2 less或者sass预处理器
2.3 axios请求库
2.4 UI库
1 项目安装 这里我们推荐Vite安装，Vite 是一个 web 开发构建工具，由于其原生 ES 模块导入方式，可以实现闪电般的冷服务器启动。通过在终端中运行以下命令，可以使用 Vite 快速构建 Vue 项目：
1.1 初始化项目 npm init vite-app js-tool-big-box-webiste
上面的命令是说呢，我们想通过vite创建一个名为 js-tool-big-box-webiste 的项目。在控制台终端输入命令后，有提示，我们输入 “y” 即可。
如上图安装完成后，你所执行的电脑目录下面会有对应的项目文件，如下图：
1.2 安装初始化依赖 我们刚才创建了新项目（ js-tool-big-box-website ），那么项目中就生成了以这个项目名为名字的文件夹，通过终端，进入到这个目录的环境下，执行以下命令：
cd js-tool-big-box-website
然后安装初始化依赖
npm install
如下图所示，已经安装完成：
而我们的文件夹下也生成了 node_modules 依赖目录，如下图所示：
1.3 启动项目 使用vite创建项目后，启动项目是非常快速的，如闪电般的速度，执行下面的命令：
npm run dev
启动成功后，可以在终端看见如下界面： 如上图所示，可以使用其中任意一个url，然后复制，粘贴到浏览器，就可以打开项目了：
2 一定会用的第三方库 项目安装完成以后呢，就要着手项目开发了。正所谓工欲善其事，必先利其气。在项目开发之前，我们先说几个，前端项目开发中，一定会用到的第三方库。用了这几个第三方库呢，可以帮我们开发更高效。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8752fed5f4c831ce4d5d7ce1b4db9f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bf211638a14d9d84d4a79b4b8b1841c/" rel="bookmark">
			【JSqlParser】Java使用JSqlParser解析SQL语句总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简述 Java解析SQL语句有很多工具都可以做到，比如Mybatis、Druid、目前用来用去最全面的仍然是Jsqlparser，它是一个Github上的开源项目，JSqlParser是一个用于解析SQL语句的Java库，它可以帮助开发者分析和操作SQL语句的结构。无论是从事数据库开发、SQL性能优化，还是需要解析SQL语句以进行其他操作，JSqlParser都能提供强大的支持
特点 支持多种SQL方言：JSqlParser支持多种数据库的SQL方言，包括MySQL、Oracle、PostgreSQL等，这使得在不同数据库之间进行SQL语句解析变得更加方便。
灵活的操作：JSqlParser以多种方式操作SQL语句，例如修改查询条件、提取表名、列名等，甚至整个SQL语句中使用到的函数，从而满足各种需求。
易于集成：JSqlParser可以轻松集成到您的Java项目中，只需将其作为依赖项添加到项目中即可。
社区支持：JSqlParser拥有一个活跃的社区，许多开发者为其提供贡献，使得这个工具不断得到改进和优化，它的主要操刀人manticore-projects (github.com) 也非常负责并愿意解答各种问题和参与讨论
环境准备 将Jsqlparser直接添加到项目中
Maven：
&lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;/dependency&gt; Gradle：
implementation("com.github.jsqlparser:jsqlparser:4.9") 快速使用 使用原则 假设现在有一条简单的SQL语句需要拿来解析，首先应该保证这个SQL在结构上是没有问题的，最好是放在数据库中可以直接运行的，不夹杂不应该的标点符号，那样解析起来才不会出错
使用案例：
以下是一个简单的SQL语句，并且这句SQL没有违反原则，是一条基本可以正常运行的SQL语句
SELECT id,name,nickname,age,job,department FROM staff_member WHERE nickname= "刘" 解析SQL语句 接下来使用Jsqlparser去解析语句，其中第二行则是最基本的，将SQL语句字符串拿来解析，如果这句SQL语句违反了原则，例如存在特殊标点符号或者不符合SQL语句，那么在第二行就会产生异常
String sql = "SELECT id,name,nickname,age,job,department FROM staff_member WHERE nickname= '刘'"; // Parse SQL Statement statement = CCJSqlParserUtil.parse(sql); Select selectStatement = (Select) statement; log.info("==&gt; JsqlParser SQL: {}", selectStatement.toString()); 正常情况下，将得到一个包含各种属性的statement，这意味着一条SQL成功被解析，并被赋予到一个对象的各个属性中
认识Statement 熟悉JDBC的程序员一般都知道Statement，其实就是语句的意思，不过在Jsqlparser中Statement已经面向对象，被设计成了一个interface，之所以设计成interface大概都可以猜到，因为Jsqlparser既然要去解析SQL，那必然要对SQL语句做区分，到底是Select、还是Insert、还是Delete、甚至是Create，而Jsqlparser对每种语句都做了一个封装，它们都继承了Statement
所以一条SQL语句，根据不同情况，都有适配的对象，例如Select语句对应着 net.sf.jsqlparser.statement.select.Select对象，而Insert也有自己的对象，所以我们都可以通过将Statement强转为它所对应的对象来获取或改变其中的属性，这也是解析SQL的一大目的
其实在Jsqlparser成功解析SQL语句之后，statement就已经有了它的类型
String sql = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bf211638a14d9d84d4a79b4b8b1841c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c708cb048c8e396c77791482464b564/" rel="bookmark">
			Linux CentoS安装RabbitMQ：一键安装指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有两种安装方法，官方推荐使用 docker安装RabbitMQ
一、Docker安装RabbitMQ 1、安装docker 参考我之前的文章：Centos7.5搭建docker并且部署Lnmp环境（小白入门docoker）_centos7.5安装docker和docker-compose-CSDN博客
2、安装RabbitMQ # 首先拉取RabbitMQ镜像 ，可以在官网选择不同版本的镜像 docker pull rabbitmq:management # 查看镜像 docker images # 然后直接创建RabbitMQ容器、启动响应的端口号 docker run -di --name myrabbit -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 15672:15672 -p 5672:5672 -p 25672:25672 -p 61613:61613 -p 1883:1883 rabbitmq:management # 如果你是阿里云服务器，记得安全组开放一下响应端口，然后就可以通过访问 http://ip:15672 来访问 RabbitMQ 的管理界面，并使用 admin/admin 进行登录 # 查看容器，获取到rabbitmq容器ID docker ps -a # 启动容器 docker start 容器ID # 如果之前手动安装了，就需要关闭手动安装的RabbitMQ服务 # 查看服务状态 systemctl status rabbitmq-server # 停止服务 systemctl stop rabbitmq-server # 查看日志 docker logs -f myrabbit 二、手动安装Erlang 1、安装Erlang 步骤 1: 下载 Erlang 安装包 访问Erlang官方网站：Erlang Download在下载页面中找到适用于Linux的安装包，并下载到CentOS系统中。 注意： 由于在 Erlang 27 上运行 RabbitMQ 时，性能会显著下降，所以不选择Erlang 27； 其次25.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c708cb048c8e396c77791482464b564/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e90a111748be7c9a2f3347221ffb9909/" rel="bookmark">
			ES全文检索支持繁简和IK分词检索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ES全文检索支持繁简和IK分词检索 1. 前言2. 引入繁简转换插件analysis-stconvert2.1 下载已有作者编译后的包文件2.2 下载源码进行编译2.3 复制解压插件到es安装目录的plugins文件夹下 3. 引入ik分词器插件3.1 已有作者编译后的包文件3.2 只有源代码的版本3.3 安装ik分词插件 4. 建立IK和繁简集成的es索引5. 新增数据测试检索 1. 前言 在现代信息检索中，处理不同语言的变体和实现高效的全文检索是一个重要的需求。对于中文，特别是需要处理简体和繁体的转换，以及高效的分词处理，这就显得尤为重要。ElasticSearch（ES）作为一个分布式全文搜索引擎，提供了强大的文本搜索和分析能力，但默认情况下并不支持简繁转换和高级的中文分词。因此，我们需要通过一些插件和自定义设置来实现这一功能。
本教程旨在展示如何在ES中引入繁简转换和IK分词插件，使得在检索时无论输入简体还是繁体都能够被检索到。无论用户输入“語法”还是“语法”，检索结果中都能命中包含简体和繁体的相关文档。这种处理方式不仅提升了用户体验，还增强了检索的准确性和全面性。
通过引入分析插件analysis-stconvert和分词插件analysis-ik，并结合自定义的ES配置，我们可以实现这一目标。以下将详细介绍如何下载、编译、安装这些插件，并通过示例展示如何建立支持繁简转换和IK分词的ES索引，最后通过实际数据插入和检索验证配置的效果。
2. 引入繁简转换插件analysis-stconvert 插件地址： https://github.com/infinilabs/analysis-stconvert/releases
2.1 下载已有作者编译后的包文件 如果存在可直接使用的zip文件，选择与自己版本一致的版本
2.2 下载源码进行编译 如果没有下载即可使用的安装包，需要自己下载源码进行编译。下载打开后使用mvn clean install进行打包
如果报错信息如下：
[ERROR] COMPILATION ERROR : [INFO] ------------------------------------------------------------- [ERROR] /E:/project/PersonalProjects/analysis-stconvert-7.17.11/analysis-stconvert-7.17.11/src/main/java/org/elasticsearch/index/analysis/STConvertAnalyzerProvider.java:[28,9] 无法将类 org.elasticsearch.index.analysis.AbstractIndexA nalyzerProvider&lt;T&gt;中的构造器 AbstractIndexAnalyzerProvider应用到给定类型; 需要: org.elasticsearch.index.IndexSettings,java.lang.String,org.elasticsearch.common.settings.Settings 找到: java.lang.String,org.elasticsearch.common.settings.Settings 原因: 实际参数列表和形式参数列表长度不同 [ERROR] /E:/project/PersonalProjects/analysis-stconvert-7.17.11/analysis-stconvert-7.17.11/src/main/java/org/elasticsearch/index/analysis/STConvertTokenFilterFactory.java:[31,9] 无法将类 org.elasticsearch.index.analysis.AbstractToke nFilterFactory中的构造器 AbstractTokenFilterFactory应用到给定类型; 需要: org.elasticsearch.index.IndexSettings,java.lang.String,org.elasticsearch.common.settings.Settings 找到: java.lang.String,org.elasticsearch.common.settings.Settings 原因: 实际参数列表和形式参数列表长度不同 [ERROR] /E:/project/PersonalProjects/analysis-stconvert-7.17.11/analysis-stconvert-7.17.11/src/main/java/org/elasticsearch/index/analysis/STConvertCharFilterFactory.java:[34,9] 无法将类 org.elasticsearch.index.analysis.AbstractCharF ilterFactory中的构造器 AbstractCharFilterFactory应用到给定类型; 需要: org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e90a111748be7c9a2f3347221ffb9909/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87f61a928e3f439e3cbea70b50df0e97/" rel="bookmark">
			采用创芯科技canfd实现ros-can通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：七、ROS-CAN通信_ros can-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/299150882aa7a1ce7be80ca1f4f0b18b/" rel="bookmark">
			如何用 Midjourney 绘画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编者按：和传统的设计灵感积累一样，使用 Midjourney 生成作品同样需要日常的题材和风格的积累，这篇出自设计师 Henrique Centieiro 的文章搜集整理了 55 个单独的风格和材质，可以作为 AI 生成的灵感，文章附带了对应的关键词和范例的提示词。
如果你也是 Midjourney 用户，相信你在日常生成图片内容的时候，也会遭遇缺乏灵感的情况，脑子里面蹦不出新的想法，构思不出新的画面，那就更不用说怎么写提示词了，生成的图也了然无趣。
不过不用担心，只要找对风格和关键词，Midjourney 就能给你令人兴奋的设计！总会有一些充满惊喜的题材/风格/关键词，能够让你再次产生思路！
这篇文章当中，我将会与你分享 50+ 值得使用的提示词，并且将其划分为 3 个类别：
艺术风格🖼️绘画媒介🎨纹理背景🧱 本身这三个类别的关键词就能互相搭配，你可以在脑补之后，尝试组合，创造出有趣的内容。
艺术风格🖼️ 不同的艺术风格可以适配不同的需求，有时候对的风格能够让普通的元素显得特色突出。
1、剪纸风 关键词：Paper Cutting
提示词：Paper cutting art of a jungle
2、「摆摊图」 关键词： Knolling
提示词：Knolling of gardening tools
说明：Knolling 风格好像没有非常准确的中文描述，大概就是非常整齐地将产品/部件规整平铺俯拍的一种呈现形式。
3、日漫风格 --Niji Midjourney 本身单独衍生出来的日漫风格引擎，可以在 /setting 设置当中直接设置调用。
提示词：Wonder woman — — Niji
4、 32-Bit 等轴测风格 关键词：32-Bit Isometric
提示词： A messy office, 32-Bit Isometric
5、色块 风格关键词： Color-blocking/ Color Block
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/299150882aa7a1ce7be80ca1f4f0b18b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a2a34954ba5baca87338fd36afaba7d/" rel="bookmark">
			中国信通院专访镜舟科技：开源商业化走了多远？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		据《2023 中国开源发展蓝皮书》显示，随着数字化转型的深入，开源生态在去年快速发展，开源商业化的模式也逐渐成型。镜舟科技作为开源商业化的先行者，也在技术创新和商业拓展中稳步增长。
日前，中国信息通信研究院（以下简称中国信通院）一行到访镜舟科技，进行中国开源商业化企业专项调研，并与镜舟科技 CEO 孙文现就这一话题展开深入交流。现将访谈情况整理成文字，欢迎阅读了解。
镜舟科技CEO孙文现与中国信通院到访人员进行交流 1. 开源筑基，推动商业化落地生根
镜舟科技的商业起源可追溯至企业数字化转型中对数据分析的迫切需求。
随着数字化的深入，企业的用户数据和业务数据的爆发增长，迫切需要具备领先的数据架构来满足越来越实时的数据分析和查询需求。基于对领先技术的追求、对好产品打造的初心，镜舟科技开始专注于 StarRocks 的贡献和发展。
数据库产品是一个“需要被用出来”的基础软件。每当 StarRocks 发布新版本，会在腾讯、阿里、携程、滴滴等互联网公司中进行测试，这些企业业务场景复杂、数据量大，更容易在自身业务实践中发现产品存在的问题。经过社区用户的实践和验证和功能优化， StarRocks 在更多企业中得以推广和应用。
在谈及商业模式时，孙文现提到，镜舟商业化的成功离不开其对开源社区的深度投入和对企业用户需求的深入理解，这是其从开源到商业化的初衷。
开源社区不仅是最新技术和功能的试炼场，也是企业版产品优化的重要来源。由于核心业务场景对产品稳定性和安全性的高要求，企业在选型时更倾向能对开源兜底的企业版服务和产品，镜舟科技正是在这一过程中获取商业回报。
2. 商业化持续发力，双擎稳步驱动
谈及开源到商业化的过程，孙文现强调到，开源的本质目的是商业化，企业只有实现盈利、持续经营和自我造血，才能确保开源社区的成功和持久发展。
镜舟科技作为社区主要贡献力量，在运营开源社区时选择与运营客户相同的逻辑。
一方面，与社区内其他参与贡献的企业深度合作，在行业和场景适配上打磨，使得 StarRocks 被更多企业引入业务和生产环境，让社区覆盖更多有相同数字化需求的企业用户，促进社区不断壮大。
另一方面，镜舟科技会将经过海量数据和复杂应用场景验证的开源产品，在可靠性、稳定性、安全性、易用性上进一步优化。
例如，加快周边工具的开发以增强兼容性，开发 Manager 管理控制台、可视化运维管理工具等，不仅能确保企业数据的安全和资源隔离，也让产品变得更加适配生态、更加易用，成为能满足行业需求的企业级产品。
随着镜舟科技的企业级产品逐渐在市场上覆盖，其商业化收入也能用于开源社区的运营和推广。开源社区和商业化形成稳定的双引擎模型，至今仍源源不断地推动着开源产品的进步和商业化公司的发展。
3. 能力再进化，做好企业级保障
商业化过程并非一帆风顺，孙文现提到，镜舟科技在成立初期遇到了许多挑战和困难。由于早期面临的用户以互联网居多，在进入金融、制造、零售等行业时，会面临多业务部门应用的冲突和挑战。
举个例子，传统企业的 IT 架构往往基于过去的参考模型构建，在落地产品过程中，由于传统企业的业务部门规范性不足，不同部门的需求匹配和集群划分不合理，这常常导致资源冗余、数据应用权限划分不清。
针对这个问题，镜舟科技开始在资源管理和湖仓架构上进行针对性开发和优化企业产品，将所有的数据仓库和数据湖整合到统一的大集群中。
在大集群的基础上，企业可以实现精细化的资源管理和权益控制，对不同业务系统进行有效划分，为包括金融在内的企业用户提供更加灵活、高效的数据处理平台。
除此之外，镜舟科技以客户价值为核心，专注于企业级能力的提升，以确保产品和服务的高质量，帮助客户收获业务价值。
仅 2024 上半年，镜舟科技接连签约中信银行、某头部股份制银行、某头部民营银行，还有包括南京银行在内的多家城商行金融企业，其商业化产品和服务正在被更多企业认可。
结语
通过开源+商业化的双擎驱动方式，镜舟科技不仅推动开源产品更快创新迭代，也收获越来越多的企业用户认可。未来，镜舟科技将借助开源商业化的模式高速发展，在更多行业发挥其独特的价值，不断进化，利用先进的技术和架构，为企业的数字化转型提供更好的数据分析解决方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11f41f95705c7c142b56afb73c697915/" rel="bookmark">
			AI创作音乐引发的深思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在最近一个月中，音乐大模型的迅速崛起让素人生产音乐的门槛降到了最低。这一变革引发了关于AI能否彻底颠覆音乐行业的广泛讨论。在初期的兴奋过后，人们开始更加理性地审视AI在音乐领域的应用，从版权归属、原创性、创作质量、道德层面以及法律层面等多个角度分析这一现象。
版权归属 版权问题的核心 AI生成音乐作品的版权归属问题一直是争议的焦点。传统上，音乐版权归属于创作者，而在AI生成的作品中，AI只是工具，其背后的开发者、使用者以及AI本身的角色定义并不明确。
法律现状 目前，大多数国家的版权法并未对AI生成内容的版权归属做出明确规定。例如，在美国，版权必须由人类创作才能得到保护，因此AI生成的音乐作品可能不具备版权。而在中国，虽然《著作权法》未明确提及AI创作，但依然倾向于人类创作的版权保护。
实践中的挑战 在实践中，AI生成音乐的版权归属可能会引发多方利益纠葛。例如，开发AI的公司是否可以对生成的作品主张版权？使用AI的用户是否有权将生成的作品商业化？这些问题的答案在不同的司法管辖区可能会有所不同，需要进一步的法律解释和案例实践来明确。
原创性 AI生成作品的原创性 AI生成音乐的过程通常是基于大量已有音乐数据进行训练，然后生成新作品。因此，AI作品的原创性常常受到质疑。有人认为，AI生成的作品只是对已有作品的重新组合，缺乏真正的创意。
与人类创作的比较 与人类创作相比，AI缺乏情感和主观意识，难以产生真正独特和具有深度的作品。然而，AI可以通过分析和模仿大量风格和模式，生成在技术上和表面上都令人满意的音乐作品。这种技术能力虽高，但在情感表达和艺术深度上仍有局限。
未来展望 尽管如此，随着技术的发展，AI在创意性和独特性方面可能会有所突破。未来，AI或许能够生成更具独特性和情感深度的音乐作品，但这依然需要时间和技术的不断进步。
创作质量 质量标准的变化 随着AI生成音乐的普及，创作质量的标准也在发生变化。传统上，音乐的质量由创作者的才华和情感表达决定，而AI生成的音乐更多依赖于算法和数据。因此，评判音乐质量的标准可能会从情感和表达转向技术和复杂性。
市场接受度 市场对AI生成音乐的接受度也在逐渐提升。许多听众对音乐的来源并不敏感，只要作品本身质量过关，他们并不会在意是由AI生成还是由人类创作。这一现象表明，AI生成音乐在市场上的竞争力正在增强。
对人类创作的影响 AI生成音乐的质量提升也对人类创作提出了新的挑战。创作者需要在情感表达和技术复杂性上超越AI，以保持竞争力。这将推动音乐创作的不断进步和多样化。
道德层面 道德伦理的挑战 AI生成音乐的兴起带来了诸多道德伦理问题。例如，AI生成的音乐是否应当标明其生成方式？使用AI生成音乐是否会导致人类音乐家失业？这些问题需要在道德伦理层面进行深入探讨。
艺术价值的讨论 有人认为，艺术的价值在于其背后的情感和思想，而AI生成的音乐缺乏这种内在价值。尽管AI可以模仿人类创作，但其作品是否具备真正的艺术价值仍然存在争议。这一讨论涉及到对艺术本质的理解和定义。
社会责任 开发和使用AI生成音乐的企业和个人也应当承担相应的社会责任。他们需要考虑到AI技术对音乐产业和社会的影响，并采取措施避免负面影响。例如，通过培训和支持人类音乐家，帮助他们适应和利用AI技术，提高创作水平。
法律层面 法律框架的缺失 目前，全球范围内尚无统一的法律框架对AI生成内容的版权、责任和使用进行规范。这种法律框架的缺失使得AI生成音乐的法律问题变得复杂和不确定。各国需要根据自身的法律体系和社会需求，制定相应的法律法规。
司法实践 在司法实践中，关于AI生成音乐的案件逐渐增多。这些案件的判决将对未来法律的发展产生重要影响。例如，法院如何认定AI生成作品的原创性和版权归属？这些判决不仅影响个案的结果，也将为未来类似案件提供法律依据。
国际合作 AI技术的发展和应用具有全球性，各国需要加强合作，建立国际性的法律和道德标准。这种合作可以通过国际组织和多边协议实现，确保AI技术在全球范围内的规范使用和健康发展。
结论 AI生成音乐的兴起为音乐产业带来了前所未有的变革，从版权归属、原创性、创作质量、道德层面和法律层面都引发了深刻的讨论和反思。尽管AI技术在提升音乐创作效率和多样性方面具有巨大潜力，但其带来的挑战和问题也不容忽视。未来，音乐产业需要在法律、道德和技术层面不断探索和创新，以应对AI技术带来的变革，确保音乐创作的健康发展和艺术价值的传承。
//python 因为爱，所以学 print("Hello, Python!") 关注我，不迷路，共学习，同进步 关注我，不迷路，共学习，同进步
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d449b6a21d162ef7264f53529b62b92/" rel="bookmark">
			数据结构经典面试之链表——C#和C&#43;&#43;篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、链表的基本概念二、链表的操作三、定义链表的节点结构体（C#）四、定义链表的基本操作类（C#）五、创建一个链表实例并进行基本操作演示（C#）六、编写一个自定义链表操作函数（C++）七、在C++中演示创建和操作一个链表实例（C++）八、总结并对比C#和C++实现链表数据结构的不同点总结 链表是一种常见的基础数据结构，它由一系列节点组成，每个节点包含数据域和指向下一个节点的指针。链表与数组不同，它不要求节点在内存中连续存储，这使得链表在插入和删除操作时具有较高的效率。
本文将介绍链表的基本概念、操作以及在C#和C++语言中的实现。
一、链表的基本概念 节点（Node）
节点是链表的基本单元，它包含两个部分：数据域和指针域。数据域用于存储节点的数据，指针域用于存储下一个节点的地址。
单链表（Singly Linked List）
单链表是一种每个节点只有一个指针指向下一个节点的链表。它是链表的最基本形式。
双向链表（Doubly Linked List）
双向链表是一种每个节点有两个指针，一个指向前一个节点，另一个指向下一个节点的链表。这使得双向链表可以方便地访问节点的前驱和后继。
循环链表（Circular Linked List）
循环链表是一种最后一个节点的指针指向第一个节点的链表。这使得循环链表在末尾追加节点时更为方便。
二、链表的操作 插入操作 插入操作包括在链表的头部、中间和尾部插入节点。
（1）在链表头部插入节点
在链表头部插入节点时，新节点的指针指向原头节点，然后将新节点设置为头节点。
（2）在链表中间插入节点
在链表中间插入节点时，需要找到插入位置的前一个节点，将新节点的指针指向原中间节点，然后将原中间节点的指针指向新节点。
（3）在链表尾部插入节点
在链表尾部插入节点时，需要找到链表的最后一个节点，将最后一个节点的指针指向新节点，然后将新节点设置为最后一个节点。
删除操作 删除操作包括删除链表的头部、中间和尾部节点。
（1）删除链表头部节点
删除链表头部节点时，需要将头节点的指针指向下一个节点，然后将原头节点从链表中释放。
（2）删除链表中间节点
删除链表中间节点时，需要找到删除节点的前一个节点，将前一个节点的指针指向删除节点的下一个节点。
（3）删除链表尾部节点
删除链表尾部节点时，需要找到链表的最后一个节点的前一个节点，将最后一个节点的前一个节点的指针指向null。
三、定义链表的节点结构体（C#） 在C#中，我们首先定义链表的节点结构体，它包含数据域和指向下一个节点的指针。
public struct Node { public int Data { get; set; } public Node Next { get; set; } public Node(int data) { Data = data; Next = null; } } 四、定义链表的基本操作类（C#） 在C#中，我们定义一个链表类，包含基本操作方法，如插入、删除等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d449b6a21d162ef7264f53529b62b92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0415f29fd27856fa1bb7c9aab1d0512/" rel="bookmark">
			案例分享：同为科技与军工项目合作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		国防数字化建设发展，同为科技提供智能PDU电源管理器系列产品与服务
项目要求描述：
竖装智能PDU电源管理器
63A输入
2P空气开关
SNMP协议智能型表头
3米3×10平方阻燃A级线缆
监测总输入电压、总负载电流、总负载视在功率、有功功率、无功功率、总负载功率因数、总电能级量
每位插座单元分监控
包括：每位负载电流、每位插座单元负载有功功率、每位插座单元负载功率因数、每位插座单元的开关状态、每位插座单元的电能计量
同为科技（TOWE）作为我国PDU行业的开拓者和领导者，曾率先提出了模块化、可定制的机柜PDU产品结构理念，开创了行业先河，迄今已是行业标准。TOWE新一代机柜PDU产品秉承北京同为23年电源安全联接专业积淀，独创了多项领先的安全性能技术与结构，并获得了国家专利。
其中，模块化X-PDU系列产品充分体现了“X”随心的特性，任意输入、输出接口，任意附加功能，任意场合的适用性都可根据客户的现场需求来量身定制。其产品结构小巧，占用空间小，模块之间采用榫卯结构，两端采用加强端盖专利结构，保证整条PDU产品优良的机械强度和内部电气安全性，提高PDU的稳固性、安全性、可靠性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/557b8d522abbf31832a636f6adff2313/" rel="bookmark">
			拿下PostgreSQL中级认证PCP，现在它是我简历上的亮点了!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：IT邦德
中国DBA联盟(ACDU)成员，10余年DBA工作经验，
Oracle、PostgreSQL ACE
CSDN博客专家及B站知名UP主，全网粉丝10万+
擅长主流Oracle、MySQL、PG、高斯及Greenplum备份恢复，
安装迁移，性能优化、故障应急处理
微信:jem_db
QQ交流群:587159446
公众号：IT邦德
文章目录 前言1.PostgreSQL为何这么火？2.PostgreSQL认证3.PGCCC认证优势4.未来计划5.结束语 前言 非常激动，经过半年的辛苦付出，终于拿下了PostgreSQL中级认证PCP，这里分享一下自己的体会。
1.PostgreSQL为何这么火？ PostgreSQL在需求率、使用率、喜爱率上都拔得头筹，天时地利人和齐备，动能势能潜能都有，足以称得上是最成功的数据库，号称世界上最先进的开源关系型数据库。
PostgreSQL性能到底有多强？
1.点查QPS 60万+，最高达200万。读写TPS每秒7万+，最高达14万。
2.极限条件下，PgSQL点查性能显著压倒MySQL，其他性能基本与MySQL持平。
3.“分布式数据库”在相同硬件规格下的性能表现显著落后于经典数据库。
4.PostgreSQL 原生作为一个HATP数据库，有比较亮眼的分析表现。
截止至2024年6月，DB-engines排名，PostgreSQL仍在第4位，热度持续飙升。
国际新形势、国内新政策下，有多家知名公司已经基于PG研发自主可控的数据库产品，其中主要包括：阿里POLARDB、亚信ANTDB、腾讯TBase、华为GaussDB、瀚高HGDB等。其中势必蕴含了大量的技术人才需求，值得大家投入到学习PG的队伍中，同时社区非常活跃，技能资源获取渠道非常宽，加入PG一起推动国产的数据库产品健康、蓬勃发展吧。
PostgreSQL可以说是各种关系型数据库中性价比最高的选择，它不仅可以用来做传统的OLTP业务，数据分析OLAP更是它的拿手好戏。可以说，PG是真正一专多长的全栈数据库,各种插件即插即用，完全的开源！
2.PostgreSQL认证 中国PG培训认证体系旨在为PG生态企业发展提供PG专业技术人才，为有志于从事PG相
关工作的人员，提供高效的培训指导、权威的等级认证。
关于PostgreSQL培训认证，目前国内有三家在做,我选择的PGCCC认证，是由北京太阳塔科技发布，授予工业和信息化部教育与考试中心颁发证书，分为PCA(初级)、PCP(中级)、PCM(高级)。
证书可以在工业和信息化部教育与考试中心查询
证书查询地址为：
https://www.miiteec.org.cn/certificate_search?type=1
当然拿到这个PostgreSQL证书后还可以申报个税退税，我也是成功退税了2次！
3.PGCCC认证优势 PGCCC认证由讲师进行线上培训，老师都是业内非常有经验的，大多数都在行业超过10年运维经验。
通过视频录播的形式提提供给学员学习，定期的在周末直播答疑，并有作业供学员实践，
以训练营的形式开班，课堂氛围非常的活跃，直播均需要实名制签到，一次也不能缺，我觉得这是对学员的负责任，理论和上机的考试都需要学员认真的学习，认证前老师们都组织考前答疑，自主学习要求很高，这样大家学习了技能的同时还能拿到证书，的确是学以致用！这里给大家看看我拿到的证书。
整个考试非常的严谨，在线考试摄像监控，考试全过程监考很严格，而且考试题目也是非常的贴近实战运维，其实还是有难度，有难度这个认证才有含金量嘛！同时培训中会对优秀学员设置了奖励机制，这样极大促进了大家学习的激情，我也是非常有幸的拿到了第51营的PCP最佳学员。
4.未来计划 也是工作需要，2021年我就开始接触了PostgreSQL，平时主要负责数据库架构、部署、运维、排除故障、性能优化等工作内容。国内新政策下，有多家知名公司已经基于PG研发自主可控的数据库产品，所以自己也相应的考取了PostgreSQL一些证书，撰写一些博客和B站技术分享。
同时PG社区内还有一个类似于Oracle ACE的体系，PostgreSQL ACE提名由PostgreSQL ACE计划经理和相关产品团队成员（根据候选人的专长领域）每月审查一次，于是提交了审核，大约1个月左右，2024年4月中旬我在官网看到了我的信息。
通过考证的过程，鼓励我们不断学习和提升自己，我们会深入学习和掌握特定领域的知识和技能，不断更新自己的知识和眼界，跟上行业的最新发展趋势，为自己的专业发展打下坚实基础，提高自己的专业水平，也能获得客户的认可！下一站我继续奋战PCM,这将是PG的最高认证，继续努力！
5.结束语 人在职场飘，哪能不挨刀，如今的职场江湖竞争激烈，多一个权威的技能证书，就多一条路！最重要的是入行了，进圈子了，也认识了大佬们。国产化推进的潮流下，PG将是最有竞争力的一个关系型数据库，拿下这个认证，很值得！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fc97787fd1ec62e5ad2b1a75d72e0f0/" rel="bookmark">
			uniapp 打包 H5 实现在 uniapp 打包 APP 的 webview 通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 遇到 uniapp 打包的 APP 在 webview 内嵌入 uniapp 打包的 H5 页面的需求，并实现通信。本篇主要总结了如何实现并总结遇到的问题，希望可以帮助大家减少负担。
实现需求主要有三个地方需要处理：
index.html 的打包配置导入 uni.webview.js使用 myUni.getEnv() 导入和 myUni.webView.postMessage() 导出 二、index.html 的打包配置 直接拷贝覆盖 index.html 即可
&lt;!DOCTYPE html&gt; &lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt; &lt;%= htmlWebpackPlugin.options.title %&gt; &lt;/title&gt; &lt;!-- Open Graph data --&gt; &lt;!-- &lt;meta property="og:title" content="Title Here" /&gt; --&gt; &lt;!-- &lt;meta property="og:url" content="http://www.example.com/" /&gt; --&gt; &lt;!-- &lt;meta property="og:image" content="http://example.com/image.jpg" /&gt; --&gt; &lt;!-- &lt;meta property="og:description" content="Description Here" /&gt; --&gt; &lt;script&gt; var coverSupport = 'CSS' in window &amp;&amp; typeof CSS.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fc97787fd1ec62e5ad2b1a75d72e0f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/719468cb6448a4fc7ab780eae83dc54a/" rel="bookmark">
			河北机械元宇宙：探索未来科技的新篇章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着科技的不断发展，虚拟现实、增强现实等技术逐渐走进人们的生活。在这个背景下，河北机械元宇宙应运而生，成为探索未来科技的新篇章。河北机械元宇宙是一个集合了虚拟现实、增强现实、人工智能等多种技术的综合性平台，旨在为用户提供一个全新的虚拟世界体验。
一、河北机械元宇宙的构建
河北机械元宇宙的构建离不开多种先进技术的支持。首先，虚拟现实技术为用户打造了一个沉浸式的三维虚拟环境，让用户仿佛置身于一个真实的世界中。其次，增强现实技术将虚拟世界与现实世界相结合，让用户在现实世界中感受到虚拟世界的奇妙。此外，人工智能技术为虚拟世界提供了智能交互的能力，让虚拟世界中的角色和物体能够根据用户的行为做出相应的反应。
二、河北机械元宇宙的应用
河北机械元宇宙的应用场景非常广泛。在教育领域，河北机械元宇宙可以为学生提供一个沉浸式的学习环境，让学生在虚拟世界中亲身体验知识，提高学习效果。在娱乐领域，河北机械元宇宙可以为用户打造一个充满奇幻色彩的虚拟世界，让用户在虚拟世界中尽情游玩。在工业领域，河北机械元宇宙可以为工程师提供一个模拟实验的平台，让工程师在虚拟世界中进行产品设计和测试，降低实际生产的风险。
三、河北机械元宇宙的未来展望
随着科技的不断进步，河北机械元宇宙将会有更多的可能性。在未来，河北机械元宇宙可能会与物联网、大数据等技术相结合，实现更加智能化、个性化的虚拟世界体验。同时，河北机械元宇宙也可能会与生物科技、神经科学等领域相结合，为用户提供更加真实的虚拟世界体验。
总之，河北机械元宇宙作为一个集合了多种先进技术的综合性平台，为人们提供了一个全新的虚拟世界体验。在未来，河北机械元宇宙将会在各个领域发挥更大的作用，为人类的生活带来更多便利和乐趣。
河北机械元宇宙hbjxyyz.top
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/241/">«</a>
	<span class="pagination__item pagination__item--current">242/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/243/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>