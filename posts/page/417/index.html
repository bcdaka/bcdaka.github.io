<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a66778e333b7be11e4290f274524051e/" rel="bookmark">
			技术爆炸！AI一图换脸新王者，Instant ID保姆级安装与使用教程！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 大家好，我是画画的小强
在AI绘画Stable DIffusion中有很多人物换脸的新技术，比如像之前的Roop还有ReActor，它们都可以实现仅凭一张图进行人物换脸，后来又出现了EasyPhoto，可以通过快速炼制的小模型来对人物进行模仿。而最近，controlnet中又加入了一个新成员——Instant ID。
它可以仅通过一张图片进行完美换脸，可能是目前最强的脸部迁移模型。
与现有的免调谐先进技术进行比较。InstantID 实现了更好的保真度，并保留了良好的文本可编辑性（面孔和样式融合得更好）。
可以用于特定人物生成广告大片和艺术照，或者是进行视频中的人物换脸。
01、一键部署启动
接下来，我们来讲一下如何使用这个功能。
首先将controlnet升级到最新的版本，目前我的是V1.1.440，可以看到在控制选项中多了一个Instant_ID，这就是我们今天的主角了。
点开预处理器选项，可以看到有两个新的选项——instant_id_face_embedding 和 instant_id_face_keypoints。
与此配套的，我们还需要下载一下最新的controlnet模型。这里我已经给大家整理好了，只需要到我的云盘里就可以直接下载了，然后将下载好的模型放入到以下路径中——E:\sd-webui-aki-v4.4\extensions\sd-webui-controlnet\models
除此之外，我们还需要下载5个insightface的模型，我也在云盘里给大家准备好了，看文末直接获取哦。
将模型放到如下的路径当中，如果没有此文件夹可以新建一下——E:\sd-webui-aki-v4.4\extensions\sd-webui-controlnet\annotator\downloads\insightface\models\antelopev2
重启软件，这样，我们的Instant_ID就安装好了。
02、使用方法
Instant ID 使用 ControlNet 和 IP-Adapter 的组合来控制扩散过程中的面部特征。
要使用Instant_ID，我们需要开启两个controlnet进行控制。
在第一个单元中，我们主要进行的是人脸的参考，放入一张人物的正脸照片，因为 ControlNet 模型从 ipadapter 模型获取输出。
预处理器选择instant_id_face_embedding，模型选择ip-adapter_instant_id_sdxl 。
第二个单元是进行人物面部朝向的参考，可以放入一张动作的照片，这个模块参考的主要是头的朝向，脸部是谁并不重要，至于人物的姿态动作会随机生成。
预处理器选择instant_id_face_keypoints，模型选择control_instant_id_sdxl 。
03、生图测试
目前Instant_ID只适用于sdxl大模型，经过我的测试，并不所有的sdxl模型都能产生很好的效果，这里我先选择一个turboDiffusion大模型，并将vae切换为自动。
我输入一段油画风格的提示词内容。
提示词引导系数这里不能设置为太高，一般在2-4之间效果会比较好。
看一下出图效果，还是挺不错的，脸部也很像。
由于sdxl拥有很多种不同的风格，我们可以试试其他的提示词控制和参考图片，以下是我的一些测试。
赛博朋克风格。
日常生活照。
影楼写真照。
素描绘画风格。
古装造型。简直太像了！她果然还是非常适合这个造型。
关于Instant ID模型的使用方法就介绍到这里，总体测试下来感觉，人物的相似度还是非常高的，比起之前的一图换脸插件roop的效果提升了不止一点点，甚至可以与lora模型不相上下。不过缺点是，需要使用sdxl模型，对电脑配置有一定的要求，并且大模型的选择和图片选择也会对图片质量产生很大的影响，所以要出好图还是需要多多地尝试。
需要配套模型的话，可以看下方扫描获取哦
写在最后 感兴趣的小伙伴，赠送全套AIGC学习资料，包含AI绘画、AI人工智能等前沿科技教程和软件工具，具体看这里。
AIGC技术的未来发展前景广阔，随着人工智能技术的不断发展，AIGC技术也将不断提高。未来，AIGC技术将在游戏和计算领域得到更广泛的应用，使游戏和计算系统具有更高效、更智能、更灵活的特性。同时，AIGC技术也将与人工智能技术紧密结合，在更多的领域得到广泛应用，对程序员来说影响至关重要。未来，AIGC技术将继续得到提高，同时也将与人工智能技术紧密结合，在更多的领域得到广泛应用。
一、AIGC所有方向的学习路线
AIGC所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照下面的知识点去找对应的学习资源，保证自己学得较为全面。
二、AIGC必备工具
工具都帮大家整理好了，安装就可直接上手！
三、最新AIGC学习笔记
当我学到一定基础，有自己的理解能力的时候，会去阅读一些前辈整理的书籍或者手写的笔记资料，这些笔记详细记载了他们对一些技术点的理解，这些理解是比较独到，可以学到不一样的思路。
四、AIGC视频教程合集
观看全面零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
五、实战案例
纸上得来终觉浅，要学会跟着视频一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
若有侵权，请联系删除 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8399ae3c50e206b8efdf807bf1b7e661/" rel="bookmark">
			轻松上手MYSQL：MYSQL初识（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​🌈 个人主页：danci_
🔥 系列专栏：《MYSQL入门》
💪🏻 制定明确可量化的目标，坚持默默的做事。
轻松上手MYSQL：从零开始构建你的数据库世界 🚀
🚀欢迎来到MySQL世界的探索之旅🚀
大家好👋！今天，我们要深入探讨的，是MYSQL这颗在数据库宇宙中耀眼的星星✨。作为技术探索者，我们会发现MYSQL不仅是一款功能强大的数据库管理系统，它还拥有着令人着迷的核心特性，让无数开发者和公司为之倾倒。接下来，就让我们一一揭开MYSQL的秘密面纱，深入其核心特性的奥秘吧！🔍
文章目录 一、数据库深度对比：MYSQL、Oracle与PostgreSQL哪个更适合？ 🌟`🛠️ MySQL vs Oracle 🛠️``🥂 MySQL vs. PostgreSQL 🥂` 二、探索MYSQL未来的无界之旅 🚀`🌈 技术趋势与创新 🌈``🎭 社区与生态 🎭` 三、🎉💼 开启数据管理大门 —— 学习MYSQL的旅程起航 🚀`👍 学习资源推荐 🔍``👍 实践建议 🛠️` 🌟 最后的小贴士📢 轻松上手MYSQL：MYSQL初识（上） MySQL以其开源、灵活、高效、安全、可扩展的特性，赢得了广大用户的青睐，成为数据库领域的佼佼者。无论是初学者还是资深开发者，MySQL都是一个值得深入学习和掌握的技术。 https://boutique.blog.csdn.net/article/details/137790528 一、数据库深度对比：MYSQL、Oracle与PostgreSQL哪个更适合？ 🌟 🛠️ MySQL vs Oracle 🛠️ 功能对比
MySQL是一个开源关系型数据库管理系统，广泛用于Web应用，特别是小型到中型的项目。Oracle数据库则是一个多功能的商业数据库管理系统，提供企业级的复杂功能，如高级安全性、复制、分析性能等。
Oracle数据库提供了更为强大且复杂的事务控制，它支持更广泛的SQL特性，比如PL/SQL、全局事务等。MySQL的事务由InnoDB存储引擎支持，虽较Oracle简单，但对于大多数应用已经足够。
性能对比
MySQL性能在Web应用和小型事务处理系统中十分出色，尤其是读密集型应用，常用于LAMP（Linux, Apache, MySQL, PHP/Perl/Python）栈。
Oracle数据库在并发处理、大数据集、复杂查询优化方面通常表现更好。它的设计更多是针对多用户环境、高事务量、以及需要集成各种数据类型的大规模应用。
成本对比
MySQL作为开源软件，社区版是免费的。虽然企业版提供额外的特性和支持，但开销相对Oracle来说较低。
Oracle数据库的许可和维护成本显著地高于MySQL。此外，由于其复杂性，可能需要更专业的DBA进行管理，进一步提高了使用成本。
适用场景
MYSQL是初创企业和中小型应用的理想选择，尤其是在Web开发和轻量级应用中表现出色。
Oracle适合那些需要高事务吞吐量、强大数据分析和处理能力的大型企业和金融机构。
🥂 MySQL vs. PostgreSQL 🥂 特性对比✨ MySQL以其易用性和高性能在简单操作方面而闻名。虽然较新版本的MySQL增加了对JSON数据类型等特性的支持，但PostgreSQL在功能方面通常被视为更先进。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8399ae3c50e206b8efdf807bf1b7e661/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f705b139853ab436773c4afb79be4a0/" rel="bookmark">
			pytesseract，一个超强的 Python 库！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，今天为大家分享一个超强的 Python 库 - pytesseract。
在当今数字化时代，文字识别技术扮演着越来越重要的角色。Python pytesseract 库是一个强大的工具，能够帮助开发者轻松实现图像中文字的识别。本文将深入探讨 pytesseract 库的原理、功能、使用方法以及实际应用场景，并提供丰富的示例代码，让读者更全面地了解这个工具库。
什么是 Python pytesseract 库？ Python pytesseract 库是 Tesseract OCR 引擎的 Python 封装，它能够实现图像中文字的识别。Tesseract OCR 是一个开源的光学字符识别引擎，由 Google 开发并维护。通过 pytesseract 库，开发者可以轻松地将图像中的文字转换为文本，从而实现文字识别的自动化处理。
核心功能 文字识别：pytesseract 可以对图像中的文字进行识别，并将其转换为文本格式。多语言支持：pytesseract 支持多种语言的文字识别，包括中文、英文、日文等。图像处理：pytesseract 提供了丰富的图像处理功能，可以优化识别结果的准确性和可靠性。简单易用：pytesseract 的接口简单明了，易于上手，即使是初学者也能够快速掌握。 使用方法 1. 安装 pytesseract 库 首先，需要安装 pytesseract 库及其依赖：
pip install pytesseract 2. 运行文字识别 接下来，可以使用 pytesseract 库对图像中的文字进行识别：
import pytesseract from PIL import Image # 打开图像文件 image = Image.open('image.png') # 进行文字识别 text = pytesseract.image_to_string(image) # 打印识别结果 print(text) 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f705b139853ab436773c4afb79be4a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd9c04259dadb7bcc23191ca0a45d4dc/" rel="bookmark">
			深入了解：Java中BigDecimal比较大小的方法_bigdecimal compareto
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Java中BigDecimal比较大小的方法
1. ​​compareTo()​​
2. ​​equals()​​
3. ​​compareTo()​​
Java中BigDecimal比较大小的方法 大家好，今天我想和大家讨论一下Java中BigDecimal类的比较大小的方法。在实际开发中，我们经常会遇到需要比较两个BigDecimal对象的大小的情况，比如排序、判断大小等。但是由于BigDecimal是一个不可变的、精确的、任意精度的有符号十进制数，所以不能直接使用比较运算符（如&gt;、&lt;）来比较大小。那么我们应该如何比较BigDecimal的大小呢？ 在Java中，BigDecimal类提供了三种比较大小的方法，分别是​​compareTo()​​、​​equals()​​和​​compareTo()​​。下面我将分别介绍这三种方法的使用。
1. ​​compareTo()​​ ​​compareTo()​​方法是BigDecimal类中最常用的比较大小的方法。它的语法如下：
javaCopy codepublic int compareTo(BigDecimal val) ​​compareTo()​​方法返回一个int类型的值，表示当前BigDecimal对象与参数val的大小关系。如果当前对象小于val，则返回负整数；如果当前对象等于val，则返回0；如果当前对象大于val，则返回正整数。 下面是一个示例：
javaCopy codeBigDecimal num1 = new BigDecimal("10.5"); BigDecimal num2 = new BigDecimal("5.5"); int result = num1.compareTo(num2); if (result &lt; 0) { System.out.println("num1 &lt; num2"); } else if (result == 0) { System.out.println("num1 = num2"); } else { System.out.println("num1 &gt; num2"); } 输出结果为：
plaintextCopy codenum1 &gt; num2 在Java中，​​compareTo()​​​ 是 ​​Comparable​​​ 接口中定义的一个方法。它用于比较当前对象与另一个对象的顺序。 ​​​compareTo()​​ 方法的语法如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd9c04259dadb7bcc23191ca0a45d4dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b4d7addad713b78009591e5264cfb32/" rel="bookmark">
			k-means聚类算法的MATLAB实现及可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		K-means算法是一种无监督学习算法，主要用于数据聚类。其工作原理基于迭代优化，将数据点划分为K个集群，使得每个数据点都属于最近的集群，并且每个集群的中心（质心）是所有属于该集群的数据点的平均值。以下是K-means算法的基本工作步骤： 初始化： 选择要将数据集分成的集群数量K。随机选择K个数据点作为初始质心（即集群中心）。这些质心可以是从样本中随机选取的，也可以根据先验知识或经验来选择。分配数据点到集群： 对于数据集中的每个数据点，计算其与每个质心的距离（通常使用欧氏距离）。将每个数据点分配到距离其最近的质心所在的集群。更新质心： 对于每个集群，计算属于该集群的所有数据点的平均值（坐标的均值）。将计算出的均值作为新的质心。迭代： 重复步骤2和3，直到满足停止条件。停止条件可以包括质心不再显著变化（即新旧质心之间的差异很小），或者算法达到了预定的最大迭代次数。输出： 输出最终的K个集群以及每个集群的质心。 K-means算法的目标是最小化每个数据点到其所属集群质心的平方距离之和，即最小化集群内的平方误差。由于初始质心是随机选择的，因此不同的初始质心可能会导致不同的聚类结果。为了获得更稳定和更好的聚类效果，有时会多次运行K-means算法，并选择最佳的聚类结果。
在K-means算法中，K值（即要形成的集群数量）的确定是一个重要但具有挑战性的问题，因为不同的K值可能会导致不同的聚类结果。没有一种通用的方法可以直接确定最佳的K值，但可以通过以下一些策略来帮助你选择和评估不同的K值：
肘部法则（Elbow Method）：
这种方法通过绘制不同K值对应的聚类内误差和（Sum of Squared Errors, SSE）或畸变（Distortion）的曲线来工作。随着K值的增加，SSE通常会减小，因为更多的集群意味着每个集群中的数据点更紧密。但是，当K值增加到一定程度时，SSE的减少会变得不那么显著，形成一个类似于“肘部”的转折点。这个转折点通常被认为是最佳的K值。
轮廓系数（Silhouette Analysis）：
轮廓系数是评估聚类效果的一种方法，它结合了凝聚度和分离度两种度量。对于每个数据点，轮廓系数计算其到同一集群内其他点的平均距离（凝聚度）与其到最近邻集群内点的平均距离（分离度）的比值。整个数据集的轮廓系数是所有数据点轮廓系数的平均值。较高的轮廓系数值通常表示较好的聚类效果。你可以通过绘制不同K值的轮廓系数来找到最佳的K值。
间隙统计量（Gap Statistic）：
间隙统计量是一种通过比较实际数据的聚类结果与随机数据（具有相同分布）的聚类结果来评估最佳K值的方法。当实际数据的聚类结果显著好于随机数据的聚类结果时，可以认为找到了一个合适的K值。
层次聚类（Hierarchical Clustering）：
你可以首先使用层次聚类来确定大致的集群数量，然后再使用K-means算法进行细化。层次聚类可以提供一个关于数据集中可能存在多少自然集群的直观感受。
基于业务或先验知识：
在某些情况下，你可能已经知道数据集中应该有多少个集群，这通常基于业务逻辑或先验知识。例如，你可能正在分析一个包含三个不同产品类别的数据集，因此自然会选择K=3。
稳定性方法：
通过多次运行K-means算法并评估结果的稳定性来确定K值。如果对于不同的初始条件，算法都能产生相似的聚类结果，那么可以认为这个K值是稳定的。
请注意，没有一种方法是绝对正确的，每种方法都有其优点和局限性。在实际应用中，你可能需要结合多种方法来确定最佳的K值。同时，还需要考虑算法的计算复杂度和数据的特性。
clear;clc;clf; % 假设你有一个名为data的数据集，它是一个n×d的矩阵，其中n是数据点的数量，d是每个数据点的维度。 % 你想将数据点划分为k个集群。 rng(1314);%固定随机数种子 % 生成一些随机数据作为示例 data = rand(100, 3); % 100个2维数据点 %绘图 figure(1); scatter3(data(:,1),data(:,2),data(:,3),'filled'); % 定义要测试的K值范围 K_values = 1:9; % 例如，测试从1到9的K值 % 初始化一个用于存储SSE的数组 SSE = zeros(size(K_values)); % 对每个K值运行K-means算法并计算SSE for i = 1:length(K_values) k = K_values(i); [C,idx] = mykmeans(data, k); % 计算SSE SSE(i) = sum(sum((data - C(idx,:)).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b4d7addad713b78009591e5264cfb32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/880413c152de8f193aff00e31fd9a615/" rel="bookmark">
			拒绝低质量！一个技巧，搞定Stable Diffusion高清图片生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生成高清图片看起来是一件很简单的事情，似乎我们只要给AI设定一个足够高的分辨率，要求就能够达到。
但实际的操作，比我们设想复杂一些。会涉及到一些技术的问题，需要了解背后的逻辑，然后按照用AI绘图的逻辑来解决。
1. Mj与SD在生成高清图片上的差别 首先我们来看一下Mj和SD在生成高清图片上的一些差别。
Mj：默认生成的图像，单张图就是1024x1024，单张图就是1M像素的图片。Mj本身不提供更大分辨率放大的功能。 Mj：默认生成4张1024x1024子图
SD：基础模型默认生成的图片都是512x512，画面幅度明显偏小。但是提供了更高清图片的增强功能。 SD:默认512x512，子图数量可设置
SD:图片效果
512x512的像素，在我们日常使用中，属于非常低清晰度的画面、完全无法展示出清晰的细节，发朋友圈都不够用，更不用说业务上使用。因此图片的放大增强，是非常必要的操作。
2、SD中直接设置高分辨率的绘图问题 在SD中直接设置高分辨率的绘图会出现一系列的问题。这是一个SD特有的问题，其实关键的原因就在于它默认的模型是适配于512x512的图片大小的，按照这样的一个尺寸来训练的。
那在这种情况下我们直接要求它生成一个1024x1024，甚至2048x2048的图像，一方面会带来一个非常大的GPU计算资源的压力，另外一方面由于画面设置的过大，对原来的模型来说，它可能会认为你这个画面对应的是多张图片，它会拥有类似于拼接或者生成多个物体的方式来进行绘制。
具体来看，绘制的图片出现了严重的缺陷：
图2：一只猫双尾巴，一只猫没身体只露头
图3：两只猫（绘图要求是a cat）
图4：双头猫
要解决这个问题，我们就需要用到一个关键技巧——高清修复。
3. 高清修复功能：小图定轮廓，大图出高清 设置方式 高清修复（Highres-fix）——这个技术看起来是比较复杂，但是其实逻辑很简单。
在它绘制的过程中，实际上分了两步:
第一步，按照一个小图来绘制，比如512x512。
第二步，将小图按照一定的倍数放大成一个大图，比如说我们将放大倍数设置为2，它就可以将512的图放大到1024。（设置方式也可以是直接指定尺寸）
值得注意的是，【放大】的过程，实际上是【重绘】的操作，但是在这个过程中，它会尽可能的遵循原来图像画面，然后通过重绘的技术，将在更大的像素上，把我们画制出更加清晰的细节。
基本的设定非常简单：
高清修复：需要开启√
重绘幅度：也就是参考小图画面的程度，经验值03~0.7之间是较为稳妥的参数
放大倍率：取决于最终想要的输出质量，比如，从512到1024对应的放大比例是2。经验：最终出图尺寸，避免超过2k x 2，放大幅度过大，画面可能出现变形。
SD文生图：高清修复
关于放大算法，这一块其实我们可以不用投入太多的精力，因为我看了很多网上教程，不动设置哪一种，基本上都可以得到一个比较好的结果，按系统的默认设置即可。
放大算法选项
3. 实操效果 2倍放大 看整体，放大后的图像，猫脖子处毛发有明显变化。
看局部，放大后的图片，猫脸细节纹理明显更加细腻：
3倍放大 看整体：3倍放大后，图像有一些明显的变异，猫鼻子、耳朵、眼睛变红，整体脸型变得突出。
看细节：大图上，猫眼的细节神态非常清晰，炯炯有神。
4倍放大 计算资源受限，GPU爆显存：
报错的含义是：OutOfMemoryError：CUDA内存不足。尝试分配4.00 GiB（GPU 0；总容量15.74 GiB；已分配10.21 GiB；剩余3.91 GiB；PyTorch总共保留了10.22 GiB）如果保留的内存远大于分配的内存，请尝试设置max_split_size_mb以避免碎片化。
工作流小结 从爆显存的例子可以看出，AI绘图对计算资源消耗很大，即使硬件可以承担，更大的画面要求也意味着更长等待时间。
比较高效的工作流思路是：
第一步：用小图快速迭代
先用小图（512x512）开始绘制，快速迭代多个版本，在生成的系列图中，找到画面布置符合要求的。这是一个海选的过程。
设置批次数量，可以一次生成大量的底图，供筛选:4x4，就是一次输出16个效果。
第二步：放大生成高清
文章使用的AI绘画SD整合包、各种模型插件、提示词、AI人工智能学习资料都已经打包好放在网盘中了，有需要的小伙伴文末扫码自行获取。
写在最后 AIGC技术的未来发展前景广阔，随着人工智能技术的不断发展，AIGC技术也将不断提高。未来，AIGC技术将在游戏和计算领域得到更广泛的应用，使游戏和计算系统具有更高效、更智能、更灵活的特性。同时，AIGC技术也将与人工智能技术紧密结合，在更多的领域得到广泛应用，对程序员来说影响至关重要。未来，AIGC技术将继续得到提高，同时也将与人工智能技术紧密结合，在更多的领域得到广泛应用。
感兴趣的小伙伴，赠送全套AIGC学习资料和安装工具，包含AI绘画、AI人工智能等前沿科技教程，模型插件，具体看下方。
一、AIGC所有方向的学习路线
AIGC所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照下面的知识点去找对应的学习资源，保证自己学得较为全面。
二、AIGC必备工具
工具都帮大家整理好了，安装就可直接上手！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/880413c152de8f193aff00e31fd9a615/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9487d7a062315af71b0f86020f5ffd4d/" rel="bookmark">
			用stable diffusion做服装设计-线稿图上色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：大模型
majicMIX realistic 麦橘写实（文末扫码可获取模型）
二：提示词
SD的关键词分为正面的和负面的
正面提示词：
best quality, masterpiece, detailed, highres, simple background, studio photography, extremely detailed, 1girl, updo, detailed face, face, closeup，HDR,UHD,8K,realistic,Highlydetailed,simplebackground,
Studio lighting,ultra-fine painting,sharp focus,physically-based rendering,extreme detail description,Professional,Vivid Colors,
负面提示词：
lowres,bad anatomy,bad hands,text,error,missing fingers,extra digit,fewer digits,cropped,worst quality,low quality,normal quality,jpeg artifacts,signature,watermark,username,blurry,
三：参数设置
高分辨率修复和Adetailer一起开一下，
效果会会更好，可根据图片修改参数设置，
四：contronet 设置
可以开一个，也可以两个一起使用，效果会更好
把图片上传到这里，勾选启用
预处理器选择：invert / tile resample
模型选择：scribble / control_v11fle_sd15_tile
控制权重：1(自行调整)
权重越高，字越明显；权重越低，字越不明显
引导介入步数：0.2
代表第几步介入对画面的影响，如，现在是一个生成步幅为30步的图像，现在介入时机为0.2，则从30x0.2=6，第六步的时候ControlNet开始介入。（出自hello小尹）
引导终止步数：0.9
代表第几步退出对画面的影响，如，现在是一个生成步幅为30步的图像，现在退出时机为0.8，则从30x0.8=24，第二十四步的时候ControlNet退出对输出的介入。（出自hello小尹）
ps：更改部分关键词，面料材质，颜色，细节等等，
就可以批量抽卡啦，来看看大图吧！！
好了，本次分享结束了。文章中所有的AI设计工具，模型和插件，都已经整理好了，文末扫码即可免费获取噢~
写在最后 AIGC技术的未来发展前景广阔，随着人工智能技术的不断发展，AIGC技术也将不断提高。未来，AIGC技术将在游戏和计算领域得到更广泛的应用，使游戏和计算系统具有更高效、更智能、更灵活的特性。同时，AIGC技术也将与人工智能技术紧密结合，在更多的领域得到广泛应用，对程序员来说影响至关重要。未来，AIGC技术将继续得到提高，同时也将与人工智能技术紧密结合，在更多的领域得到广泛应用。
感兴趣的小伙伴，赠送全套AIGC学习资料和安装工具，包含AI绘画、AI人工智能等前沿科技教程，模型插件，具体看下方。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9487d7a062315af71b0f86020f5ffd4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80daf95364cb513287415686a0d7085e/" rel="bookmark">
			最早截止时间优先算法（EDF）-思考与编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最早截止时间优先（earliest deadline first，EDF）算法是根据任务的优先级，任务的截止时间越早，其优先级越高，具有最早截止时间的任务排在队列的前面。调度程序在选择任务时，总是选择就绪队列中的第一个任务，并为之分配处理机。EDF算法即可用于抢占式调度方式中，也可用于非抢占式调度方式中。
1.非抢占式调度方式用于非周期实时任务（参考《计算机操作系统慕课版》）
大家可通过以上图片了解非抢占式，本次主要以抢占式为主。
2.抢占式调度方式用于周期实时任务
我们先从《计算机操作系统慕课版》一个实例出发：现有两个周期实时任务A、B，其周期时间分别为20ms和50ms，每次周期的处理时间分别为10ms和25ms。
首先我们得先思考这个实例是否可行？
思考：任务A、B能否实现实时调度？为什么？
一个小知识点：假定系统中有m个周期性的HRT任务，它们一个周期内的处理时间为Ci，周期时间表示为Pi，则在单处理情况下，必须满足：C1/P1+C2/P2+……+Cm/Pm&lt;=1 即每个任务的处理时间与周期时间比的和不超过1。我是这么理解：Ci/Pi是指i任务时间占用率，如果所有任务占用率小于等于100%，说明有机会按照一定的次序分配，如果超过100%肯定不会实现。
对本上面的实例 CA/PA+CB/PB=1 &lt;=1，满足C1/P1+C2/P2+……+Cm/Pm&lt;=1，所以可以实现。
思考：如果采用EDF算法实现？（参考《计算机操作系统慕课版》p88图3-8，即下图）
第一行是两个任务到达时间、执行时间和最晚截止时间图。
第二、三行是为了说明通常的优先级调度不能适用于实时系统，如果按照固定优先级调度下去（第二行A优先、第三行B优先），你会发现都会失败。
第四行则是采用EDF算法的时间图，根据截止时间决定优先级，截止时间越早，越优先。
那么你可能会问：如果截止时间相同怎么办？
如果截止时间相同先来的先执行，能不换就不换。
思考：EDF算法调度时机是什么？
在我看来：1.当前任务结束；2.新任务到达。（如果有错，欢迎大家批评指正）
思考：如何编写程序实现EDF算法？
代码思路：
首先确定好最后的截止时间我在代码中称之为大周期t，也就是所有任务的周期的最小公倍数；
其次就是利用公式判断可行性，前面已经提到过这个知识点；
最后就是利用结构体+sort+cmp确定调度顺序，然后不断地更新，使用结构体可以记录更多的信息。由于实例中任务数是n，我这里代码第6行n赋值为2，可根据实际需求更改。
欢迎各位大佬批评指正！
#include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;bits/stdc++.h&gt; using namespace std; const int n=2;//n表示任务数目，可以按照进程数目来更改n int id;//该目的是为不重复输出某一个任务 int ztime=0;//当前时间 int t=1;//t表示大周期 //EDF调度时机：1.当前任务结束（判断剩余的）2.新任务到达 /大周期得算出各个任务周期时间的最小公倍数 int gcd(int x,int y) { //最大公约数 return y?gcd(y,x%y):x; } int lcm(int x, int y) { //最小公倍数 return x*y/gcd(x,y); } struct Task { int id;//序列号 double ctime;//执行时间 double ptime;//周期时间 double atime;//到达时间 double deadline;//截止时间 double stime;//剩余时间 }; Task a[n]; bool cmp2(Task a,Task b)//排序规则 { if((a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80daf95364cb513287415686a0d7085e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9f53a77a2752173eef4e1ab2d76080a/" rel="bookmark">
			Docker图形用户界面Web UI portainer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker图形用户界面Web UI portainer 除了使用终端以命令的方式管理和部署Docker容器和服务，还可以使用图形用户界面，Docker Desktop 是适用于 MacOS 和 Windows 计算机的应用程序，用于构建和共享容器化应用程序和微服务。Docker Desktop 提供在桌面上设计和交付容器化应用程序所需的速度、选择和安全性。
在Linux桌面和服务器上，没有Docker Desktop应用程序。portainer是Docker的Web图形管理界面，部署portainer后，可以通过浏览器来管理。
01 部署portainer 通过SSH连接上服务器，创建并编辑portainer-stack.yml文件。执行如下命令：
nano portainer-stack.yml 在打开的窗口输入如下代码：
version: '3.2' services: # tag:2.11.1; 2.18.3; 2.19.4;2.20.1 agent: image: portainer/agent:2.20.1 volumes: - /var/run/docker.sock:/var/run/docker.sock - /var/lib/docker/volumes:/var/lib/docker/volumes networks: - azh deploy: mode: global placement: constraints: [node.platform.os == linux] # tag:2.11.1; 2.18.3 ; 2.19.4; 2.20.1 portainer: image: portainer/portainer-ce:2.20.1 command: -H tcp://tasks.agent:9001 --tlsskipverify ports: - "9443:9443" - "9000:9000" - "8000:8000" volumes: - portainer_data:/data networks: - azh deploy: mode: replicated replicas: 1 placement: constraints: [node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9f53a77a2752173eef4e1ab2d76080a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a6b69a03f8645e3e75548fef2f144d4/" rel="bookmark">
			解决python调用matplotlib绘制图像只弹出空白无响应窗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在调用matplotlib绘制图像时，弹出绘制窗口，但没有响应并且很快程序结束
查找资料发现两种解决方案：
1.修改导入包代码
import matplotlib matplotlib.use('Qt5Agg') import matplotlib.pyplot as plt 2.修改显示代码
plt.show(block = True) 以上两种方法均没有奏效，考虑python版本与matplotlib版本不适配
解决方案：
1.创建新环境python=3.10
2.下载相应版本安装包
成功解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6434d358dff03feb88111e5001134006/" rel="bookmark">
			Android使用MQTT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
MQTT
MQTT通信流程
第三方MQTT服务
使用步骤
使用注意事项
使用MQTT问题
前言
本文是一个学习过程记录。
MQTT MQTT（Message Queuing Telemetry Transport）是一种轻量级的、基于发布/订阅模式的消息传输协议，常用于物联网（IoT）应用中。
MQTT协议中有三种身份：发布者（Publish）、代理（Broker）（服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。
MQTT传输的消息分为：主题（Topic）和载荷（payload）两部分：
Topic（主题）：消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）；它是消息的标识符，用于指定消息的类型或者位置。主题是一个由层级结构组成的字符串，使用斜杠（/）作为分隔符。例如，home/bedroom/temperature 是一个主题，用于表示卧室的温度数据。在MQTT中，发布者发布消息到特定的主题，而订阅者通过订阅主题来接收相关消息。Payload（载荷）：是实际的消息内容。它可以是任何类型的数据，例如文本、JSON、二进制数据等。发布者将消息发送到特定的主题时，将携带一个载荷，订阅者接收到消息后，可以从载荷中提取所需的数据。 当应用数据通过MQTT网络发送时，MQTT会把与之相关的服务质量（QoS）和主题名（Topic）相关连。
QoS（服务质量）：QoS定义了消息传递的可靠性级别。MQTT支持三个QoS级别：
QoS 0（最多一次）：消息尽最多一次传递。消息不会进行确认，也不会重传。适用于实时性要求不高的数据，可能会丢失消息。QoS 1（至少一次）：消息至少传递一次，确保消息至少被接收一次。如果消息未收到确认，会进行重传。适用于需要确保消息不丢失，但可以重复传输的情况。QoS 2（仅一次）：消息只传递一次，确保消息仅被接收一次。会进行两阶段确认，确保消息的准确传递。适用于要求非常高的数据完整性的情况。 使用MQTT参考SDK，一步一步操作来也可以完成，EMQX SDK使用指南：Android 使用 Kotlin 连接 MQTT | EMQ
这篇文章讲的非常清楚：
Android使用MQTT订阅及发布消息（（一）初步了解Mqtt以及实现Android操作mqtt服务）_android mqtt-CSDN博客 ​​​​​​
MQTT通信流程 Publisher发布消息到Broker。Broker接收消息并根据主题将消息路由给相应的Subscriber。Subscriber接收到消息并处理。 第三方MQTT服务 使用EMQX，15天免费，网站：EMQXEMQX SDK使用指南：Android 使用 Kotlin 连接 MQTT | EMQ这里使用 专有版，如果使用 serverless，进行测试连接会报错 Unregister alarmreceiver to 使用步骤 引入依赖先连接订阅发布取消订阅取消连接 使用注意事项 在连接的时候，千万别忘记tcp://，否则会连接失败。
val serverURI = "tcp://b601afc1.ala.dedicated.aliyun.emqxcloud.cn:1883" 使用只需要创建一个【客户端认证】，当作连接账号和密码。其他一概不用操作
使用MQTT问题 这个播客已经解决：Android——Failed resolution of: Landroid/support/v4/content/LocalBroadcastManager-CSDN博客
问题1、java.lang.NoClassDefFoundError: Failed resolution of:Landroid/support/v4/content/LocalBroadcastManager;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6434d358dff03feb88111e5001134006/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/213028a5cc4084f8ad9ab70a1a204087/" rel="bookmark">
			【C&#43;&#43;】explicit关键字详解（explicit关键字是什么? 为什么需要explicit关键字? 如何使用explicit 关键字）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、explicit关键字是什么？ 三、构造函数还具有类型转换的作用
🍎单参构造函数
✨引出 explicit 关键字 🍍多参构造函数
✨为什么需要explicit关键字？ ✨怎么使用explicit关键字？
四、总结 五、共勉
一、前言 在我们自己平时写 C++ 代码的时候，较少会用到 explicit关键字 。但是在C++相关的标准类库中，看到explicit关键字的频率还是很高的。既然出现的频率这么高，那么我们就来看看explicit关键字的作用到底是干什么的。
二、explicit关键字是什么？ explicit是C++中的一个关键字，它用来修饰只有一个参数的类构造函数，以表明该构造函数是显式的，而非隐式的。当使用explicit修饰构造函数时，它将禁止类对象之间的隐式转换，以及禁止隐式调用拷贝构造函数。 这能这么说，大家不太好理解，既然解释中提到了 类的构造函数 那么下面我将从构造函数中详细的给大家，讲解explicit其中的含义。
三、构造函数还具有类型转换的作用 在理解 explicit 关键字 之前，我们必须要了解构造函数的类型转换作用，以便于我们更好的理解 explicit 关键字 ，如果有不懂构造函数的老铁，可以来看看这篇文章：构造函数
🍎单参构造函数 还是来说说老朋友日期类，我们通过下面这个日期类进行讲解
class Date { public: // 构造函数 Date(int year) :_year(year) // 初始化列表 {} private: int _year; int _month = 3; int _day = 31; }; 对于下面的 d1 很清楚一定是调用了有参构造进行初始化，不过对于 d2 来说，也是一种构造方式 int main() { // d1 和 d2 都会调用构造函数 Date d1(2022); Date d2 = 2023; return 0; } 我们依旧通过调试来看就会非常清晰，这种 【Date d2 = 2023】 写法也会去调用构造函数 此时，大家可能会产生疑问，这种构造方式从来没有见过，为什么 【Date d2 = 2023】会调用 构造函数呢？ 其实这都是因为有【隐式类型转换】的存在，下面我将从一个简单的例子来为大家讲解。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/213028a5cc4084f8ad9ab70a1a204087/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ad056674b460b23da4364f4b41e6dab/" rel="bookmark">
			深入详解使用 RabbitMQ 过程中涉及到的多个细节问题（面试可用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、基础类问题
2、cluster 相关问题
3、综合性问题
4、参考资料
C++软件异常排查从入门到精通系列教程（专栏文章列表，欢迎订阅，持续更新...）https://blog.csdn.net/chenlycly/article/details/125529931C/C++基础与进阶（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/category_11931267.htmlVC++常用功能开发汇总（专栏文章列表，欢迎订阅，持续更新...）https://blog.csdn.net/chenlycly/article/details/124272585C++软件分析工具从入门到精通案例集锦（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/article/details/131405795开源组件及数据库技术（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/category_12458859.html网络编程与网络问题分享（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/category_2276111.html 本文主要解答一些在 RabbitMQ 使用过程中经常被问到的细节问题。本文面向的是对 RabbitMQ 有一定研究的、对使用中的细节问题有一定思考、对各种模型背后的机制有强烈的探究欲望的人。很多问题的答案都可以在各类文档里找到，可以多翻阅参考资料。
AMQP，即Advanced Message Queuing Protocol（高级消息队列协议），是一个提供统一消息服务的应用层标准高级消息队列协议。AMQP是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件传递消息，不受客户端/中间件不同产品、不同开发语言等条件的限制。该协议是一种二进制协议，提供客户端应用于消息中间件之间异步、安全、高效的交互。相对于我们常见的REST API，AMQP更容易实现，可以降低开销，同时灵活性高，可以轻松的添加负载平衡和高可用性的功能，并保证消息传递，在性能上AMQP协议也相对更好一些。
AMQP通过典型的生产者和消费者模型,生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，轻松的实现系统间解耦。通过利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。
RabbitMQ是AMQP的一个开源实现，服务器端用Erlang语言编写，用于在分布式系统中存储转发消息，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、 ActionScript、XMPP、STOMP等，支持AJAX。 RabbitMQ使用了生产者与消费者的模式，消息发送端（生产者）将消息写入消息队列，消息接收端（消费者）从消息队列中取出消息、消费消息；而消息的发送端无需知道消息接受端的存在。RabbitMQ具有良好的性能和时效性，同时支持集群部署，非常适合在较大规模的分布式系统中使用。
1、基础类问题 问题1：RabbitMQ 中的 broker 是指什么？cluster 又是指什么？
broker 是指一个或多个 erlang node 的逻辑分组，且 node 上运行着 RabbitMQ 应用程序。cluster 是在 broker 的基础之上，增加了 node 之间共享元数据的约束。
问题2：什么是元数据？元数据分为哪些类型？包括哪些内容？与 cluster 相关的元数据有哪些？元数据是如何保存的？元数据在 cluster 中是如何分布的？
下图所示为 queue 的元数据在单 node 和 cluster 两种模式下的分布图： 在非 cluster 模式下，元数据主要分为 Queue 元数据（queue 名字和属性等）、Exchange 元数据（exchange 名字、类型和属性等）、Binding 元数据（存放路由关系的查找表）、Vhost 元数据（vhost 范围内针对前三者的名字空间约束和安全属性设置）。在 cluster 模式下，还包括 cluster 中 node 位置信息和 node 关系信息。元数据按照 erlang node 的类型确定是仅保存于 RAM 中，还是同时保存在 RAM 和 disk 上。元数据在 cluster 中是全 node 分布的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ad056674b460b23da4364f4b41e6dab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fab91bab3810b20292d97b0bc507e250/" rel="bookmark">
			HCL进行总部与分支建立IPsec VPN的web配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#实验目标：H3C防火墙在基于ACL的接口NAT下进行IPsec VPN总部分支互联的（web）配置案例
（文末上传了一个HCL的实验环境,感兴趣的可以试试）
通过HCL进行总部与分支建立IPsec VPN的web配置
总干部防火墙同时代理站内上网所有配置有基于ACL的接口NAT代理访问公网
防火墙通过web管理口端口为GE1/0/0，安全域为Management。
主站防火墙管理IP：192.168.188.141
分站防火墙管理IP：192.168.188.142
使用HOST_1用于直连本地网卡
进行防火墙web配置前使用命令行配置管理口地址为本地网卡同段IP，以便进行后续实验。
两台防火墙分别通过模拟的公网地址1.1.1.2、2.1.1.2访问公网以及进行IPsec VPN的互联。
主站172.16.0.1/24代表主站内网PC通过IPsec VPN与分站192.168.0.1网段互通
由于节约计算资源目的，分站使用loopback 口代替内网段，实际操作中只需要注意将对local安全域
改为Trust安全域即可。
交换机
GE1/0/1、GE1/0/2、GE1/0/5 归属vlan2（管理vlan）
GE1/0/3归属vlan3，IP地址1.1.1.1（主站外网）
GE1/0/4归属vlan4，IP地址2.1.1.1（分站外网）
实验步骤：
1、命令行配置防火墙管理地址及登录限制(两台防火墙均需配置)
①配置口地址
interface GigabitEthernet1/0/0
ip address 192.168.188.XXX 255.255.255.0 ##两台防火墙的管理IP不同
②将1/0/0口加入管理域
security-zone name Management
import interface GigabitEthernet1/0/0
③配置acl用于放行管理数据流
acl basic 2000
rule 0 permit
④引用acl2000配置local与management安全域之间的管理放行
zone-pair security source Local destination Management
packet-filter 2000
zone-pair security source Management destination Local
packet-filter 2000
2、登录管理界面
下面在本机已经可以ping通防火墙管理地址了，打开浏览器，默认账号密码均为admin初次登录需要修改密码
①、基本网络
不再赘述上截图
主站防火墙网络接口IP与安全域设置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fab91bab3810b20292d97b0bc507e250/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e7f6eca04ba5a81dc5f75a7391467c3/" rel="bookmark">
			Sql Server、Oracle、MySQL如何备份表数据的多种方法？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、SQL Server 在 SQL Server 中，备份表通常指的是创建一个表的副本，或者导出表的数据和结构到某个位置以便以后恢复。SQL Server 没有直接的 “备份表” 的命令,但有以下几种方式可以用来实现这一目的。
1.创建表的副本 使用 SELECT INTO 语句来创建一个新表，并将旧表的数据复制到新表中。
SELECT * INTO productstemp FROM products; 上面方法只会复制数据，不会复制任何索引、触发器、约束或存储过程。
2. 使用生成脚本向导 SQL Server Management Studio (SSMS) 提供了一个“生成脚本”向导，可以使用它来导出表的结构、数据或两者都导出。
详细步骤：
在 SSMS 中，连接到你的数据库。 展开“数据库”文件夹，找到并右键点击想要备份的表所在的数据库。 选择“任务” &gt; “生成脚本”。 在“生成脚本”向导中，选择想要备份的表。 选择输出选项（例如，输出到新查询窗口、文件或剪贴板）。 完成向导并生成脚本。 3. 使用第三方工具 除了 SQL Server 自带的工具外，还有许多第三方备份和恢复工具可以备份表。
二、MySQL 在 MySQL 中，备份表数据通常意味着将表中的数据导出到一个文件或另一种存储格式，以便以后能够恢复或迁移这些数据。MySQL 提供了多种工具和命令来备份表数据，下面是几种常用的方法：
1. 使用 mysqldump 工具 mysqldump 是 MySQL 提供的用于备份数据库或表的命令行工具。
备份单个表的数据：
mysqldump -u [username] -p[password] [database_name] [table_name] &gt; [backup_file.sql] [username] 是 MySQL 用户名，[password] 是密码（注意 -p 和密码之间没有空格），[database_name] 是数据库名，[table_name] 是想要备份的表名，[backup_file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e7f6eca04ba5a81dc5f75a7391467c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efb588273f835dcaaa2439a967fd86c1/" rel="bookmark">
			使用Flutter的image_picker插件实现设备的相册的访问和拍照
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先自我介绍一下，小编浙江大学毕业，去过华为、字节跳动等大厂，目前阿里P7
深知大多数程序员，想要提升技能，往往是自己摸索成长，但自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年最新Linux运维全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友。
既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，涵盖了95%以上运维知识点，真正体系化！
由于文件比较多，这里只是将部分目录截图出来，全套包含大厂面经、学习笔记、源码讲义、实战项目、大纲路线、讲解视频，并且后续会持续更新
如果你需要这些资料，可以添加V获取：vip1024b （备注运维）
正文 ), ], ), ), 在上面的示例中，我们使用 ImagePicker 类中的 pickImage 方法来从相册中选择一张图片或者选择相机。如果用户选择了一张图片，我们将通过 pickedFile.path 获取到图片的文件路径，然后将其转换为 File 对象。 ImagePicker().pickImage(source: ImageSource.gallery);
如果用户选择了从相机拍照，通过调用 pickImage 方法时指定 ImageSource.camera 来实现。 await ImagePicker().pickImage(source: ImageSource.camera);
### 完整的代码 完整的代码如下： import ‘package:flutter/material.dart’;
import ‘dart:io’;
import ‘package:image_picker/image_picker.dart’;
import ‘package:shared_preferences/shared_preferences.dart’;
class SettingsPage extends StatefulWidget {
const SettingsPage({Key? key}) : super(key: key);
@override
_SettingsPageState createState() =&gt; _SettingsPageState();
}
class _SettingsPageState extends State {
late File _selectedImage;
late SharedPreferences _prefs;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efb588273f835dcaaa2439a967fd86c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0726b089d46247a7a800e33fe5ac89bc/" rel="bookmark">
			告诉世界，前端也能做 AI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		性能方面，WebGL和WebGL2是tfjs和onnxjs的性能担当，就现阶段而言，比JavaScript和WebAssembly都要快上许多。
▐ WebAssembly 覆盖率方面，WASM在浏览器上为91%，但微信、淘宝、支付宝小程序则都支持WASM。
性能方面，参考mozilla的规划介绍，由于当前缺少多线程、SIMD、64位等的支持，WASM的性能还很难与Native看齐。Android V8引擎下，可以通过JIT找回一些场子；但iOS下，就回天乏术了。
▐ WebGPU 覆盖率一片红…性能再好也指望不上哎。
小结一下，结合WebGL和WebAssembly，可以实现对大部分浏览器和主流小程序的覆盖，也可以实现相对较好的性能。
磨一把更快的刀
我们结合了我们在小程序上的优化经验和MNN GPU优化经验，基于MNN模型基础设施，实现了全新的MNN.js。性能上有相当明显的提升，视频场景下的帧率抖动基本消失，内存上也有一定的节省。
▐ 效果 测试版本：tfjs@1.7.0 + mnn.js@0.0.3。
测试方法：Warm Up 1次，后续推理50次。MBP直接测试，iOS/Android重启测试（避免Shader缓存）。
测试环境：
Desktop：MBP 18年中款，GPU = Radeon Pro 555X + Intel UHD Graphics 630 iOS：iPhone X Android：小米9 上数据。性能部分，首次推理上，相较于tfjs节约约70%的耗时；后50次平均上，则节约了35%以上的耗时。兼容性部分，浏览器上，我们测试了Chrome、Safari和众多手机的自带浏览器；小程序上，我们测试了淘宝、支付宝、钉钉、微信小程序。具体测试的数据就不再陈列，WebGL性能表现上与上述基本相近。
MNN.js当前支持了38个算子，除了MobileNet这样的简单模型，在多达数百个算子的内部模型上，我们也有近似的性能领先。
▐ 框架 在设计上，我们复用了MNN的模型格式。一来，可以实现对Caffe、TensorFlow、PyTorch模型的转换支持；二来，MNN的算子替换、层融合等模型优化，也可以延续到MNN.js上。
模型加载后，有WebGL、WebAssembly、JavaScript三种计算后端可供选择。JavaScript一般不单独使用，WebAssembly一般在WebGL不支持的情况下使用。
▐ 示例 async function loadModel() { let compiled = await MNN.WasmBuilder.compile(fetch(‘/path/to/mnn.wasm’)); let wasm = await MNN.WasmBuilder.create(compiled); let js = MNN.JSBuilder.create();
let builders = [webgl, wasm, js]; let result = await fetch(url) let model = await result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0726b089d46247a7a800e33fe5ac89bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/888b342b3bbd091c388a91c7fdba2ff4/" rel="bookmark">
			各种主流数据库Docker镜像下载，快速部署测试环境，赶快收藏吧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先自我介绍一下，小编浙江大学毕业，去过华为、字节跳动等大厂，目前阿里P7
深知大多数程序员，想要提升技能，往往是自己摸索成长，但自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！
因此收集整理了一份《2024年最新软件测试全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友。
既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，涵盖了95%以上软件测试知识点，真正体系化！
由于文件比较多，这里只是将部分目录截图出来，全套包含大厂面经、学习笔记、源码讲义、实战项目、大纲路线、讲解视频，并且后续会持续更新
如果你需要这些资料，可以添加V获取：vip1024b （备注软件测试）
正文 1.Docker Hub主页 2.阿里Docker主页
1.Docker Hub主页
https://hub.docker.com/u/techerwang
#安装部署
–oracle:ora11g11203
docker run -itd --name jemora11203 -h jemora11203 \
–privileged=true -p 11521:1521 -p 122:22 -p 11158:1158 \
jemora11g:11203 init
–ora11g11204
docker run -itd --name jemora11204 -h jemora11204 \
–privileged=true -p 21521:1521 -p 222:22 -p 21158:1158 \
jemora11g:11204 init
–ora10g_10205
docker run -itd --name jemora10205 -h jemora10g -p 3380:3389 \
-p 31521:1521 -p 312:22 \
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/888b342b3bbd091c388a91c7fdba2ff4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62c7748bb59fa64a241bc1f172931039/" rel="bookmark">
			git常见问题记录：【git clone后报错】 warning: remote HEAD refers to nonexistent ref, unable to checkout.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、概述2、原因3、解决方法 1、概述 比如我从服务器上获取 DPDK 的代码：
git clone 【地址】 发现看似代码下载下来了，但是 ls 命令后项目文件夹里的内容都是空的！！
可以看到最后有个 warning ：warning: remote HEAD refers to nonexistent ref, unable to checkout.
2、原因 git clone 代码时会默认拉取远程服务器 master 主分支下的代码，可是我创建的主分支没有用 master 命名，里面是 origin/20.11 分支，目录下 .git/refs/heads 不存在 HEAD 指向的文件，因此产生了警告。
remotes/m/master -&gt; origin/master //其余工程代码有master分支
上下对比：
remotes/m/master -&gt; origin/20.11 //本工程代码分支没有master分支导致警告
如下图显示：
ls .git/refs/heads/ 3、解决方法 1、进入git clone 操作后，生成的项目文件夹内，使用 git branch -a 查看所有的分支
hwc@hwc:~/dpdk$ git branch -a remotes/origin/18.11.11 remotes/origin/19.11.14 remotes/origin/20.11 remotes/origin/default 2、选择自己需要的分支，比如我需要获取 origin/20.11 分支上的代码，那么执行操作git checkout remotes/origin/20.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62c7748bb59fa64a241bc1f172931039/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/386c53df572cf9b15df28c3b056e22d0/" rel="bookmark">
			Hadoop HDFS：海量数据的存储解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在大数据时代，数据的存储与处理成为了业界面临的一大挑战。Hadoop的分布式文件系统（Hadoop Distributed File System，简称HDFS）作为一个高可靠性、高扩展性的文件系统，提供了处理海量数据的有效解决方案。本文将深入探讨HDFS的设计原理、架构组成、核心功能以及实际应用场景，以期为读者尽量提供一个全面的科普视角。
HDFS的设计与架构 设计目标 HDFS是专为大规模分布式数据处理设计的，它在设计时考虑了硬件故障的常态性、对大数据集的高吞吐率访问需求以及流式数据访问模式等特点。这些设计目标直接影响了HDFS的架构和实现。
核心组件 HDFS的架构主要由两种类型的节点组成：名称节点（NameNode）和数据节点（DataNode）。名称节点作为中心服务器，负责管理文件系统的命名空间以及客户端对文件的访问。数据节点则在本地文件系统存储数据，处理名称节点分派的数据块（block）操作请求。
名称节点 名称节点维护着整个文件系统的目录树及所有文件和目录的元数据。这些信息包括文件的权限、修改和访问时间以及文件的块列表等。重要的是，名称节点还记录每个文件各个块所在的数据节点信息。
数据节点 数据节点负责处理文件系统客户端的读写请求，在名称节点的调度下存储和检索数据块。数据节点在启动时和定期地会向名称节点发送它们所存储的数据块列表，以便名称节点维护全局的数据块位置视图。
高可用性和容错性 HDFS通过多种机制实现高可用性和容错性。首先，它将每个文件的数据块复制多份存储在不同的数据节点上，这种机制称为副本机制。默认情况下，HDFS为每个数据块创建三个副本。其次，HDFS支持热备份的名称节点配置，可以在主名称节点出现故障时无缝切换到备份节点。
HDFS的工作原理 数据读写流程 当客户端要写入数据时，它首先向名称节点发送请求，名称节点会返回一组数据节点列表，客户端随后与这些数据节点直接通信，按顺序将数据块写入。读取数据时，客户端同样会先询问名称节点数据块所在的数据节点，然后直接从其中一个数据节点读取数据块。
数据组织与块管理 HDFS将每个文件分割成一系列的块，这些块存储在不同的数据节点上。块的大小默认为128MB，这种大块策略能减少寻址开销，并优化大规模数据处理的性能。数据节点负责块的创建、删除和复制等操作，其操作均由名称节点进行调度。
HDFS的应用场景 大数据分析 HDFS是Apache Hadoop生态系统中的基础组件，它为上层的大数据处理工具（如Apache Hive和Apache HBase）提供了强大的数据存储能力。这些工具能够进行结构化数据分析和存储，广泛应用于互联网搜索、日志分析、数据仓库等领域。
云存储解决方案 HDFS也常被用作云计算环境中的存储层。通过与其他Hadoop生态组件的集成，例如YARN和MapReduce，HDFS能够提供可扩展的存储服务，支持从小型企业到大型数据中心的各种需求。
备份和灾难恢复 在数据安全和灾难恢复方面，HDFS的副本策略保证了数据的可靠性和可访问性，即使在部分硬件故障的情况下也能保持服务的连续性。此外，HDFS还可以与其他数据备份和同步工具配合使用，以实现跨数据中心的数据恢复解决方案。
HDFS的优势与挑战 优势 扩展性：HDFS支持水平扩展，只需增加更多的数据节点即可扩展系统的存储容量。成本效率：由于HDFS设计用于运行在普通的商用硬件上，相比传统的高成本存储解决方案，HDFS可以大幅降低存储成本。高容错性：自动的数据副本机制确保了数据在硬件失败时的持久性和可用性。优化的数据吞吐率：HDFS的架构优化确保了高吞吐率的数据访问，非常适合大规模数据集的处理。 挑战 元数据集中存储问题：名称节点成为了系统的瓶颈和单点故障风险点。尽管有高可用配置，但名称节点的压力和故障风险依旧是设计上的挑战。小文件问题：HDFS更适合存储大文件。对于有大量小文件的应用场景，HDFS的性能和效率会受到影响，因为每个文件、每个块的元数据都需要由名称节点维护，可能会导致名称节点的内存消耗过大。实时数据访问：HDFS主要设计为批处理系统，对于需要低延迟访问的实时应用来说，可能不是最佳选择。 展望未来 随着技术的进步和市场需求的变化，HDFS也在不断进化。例如，引入了联邦名称节点来解决单个名称节点的扩展问题，增强了对存储策略的支持，如存储池的概念，允许管理员指定不同类型的存储介质（如SSD和HDD）用于不同的数据块。
同时，开源社区也在积极探索新的架构和技术，如利用NVMe存储和RDMA网络技术来提升性能，以及通过集成更多的AI和机器学习功能来增强HDFS的数据处理能力。
结语 作为处理大规模数据集的强大工具，HDFS已经成为了很多组织在大数据时代的基石。虽然存在一些设计和性能挑战，但其开源的本质和持续的技术进步保证了HDFS在未来数据技术领域的重要位置。无论是数据存储、大数据分析还是云服务，HDFS都将继续发挥其独特的价值和功能。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/416/">«</a>
	<span class="pagination__item pagination__item--current">417/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/418/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>