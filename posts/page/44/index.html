<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa0c3df58315bc656a4aa5ca5d71018c/" rel="bookmark">
			秋叶V4.9整合包发布！什么是Stable Diffusion？如何安装Stable Diffusion？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Stable Diffusion秋叶整合包，一键安装Stable Diffusion，门槛极低，完全免费，支持Nvidia全系列显卡。
来自B站up主秋葉aaaki近期推出的Stable Diffusion整合包v4.9版本，能够让零基础用户轻松在本地部署Stable Diffusion，适合希望使用AI绘画的朋友。
Stable Diffusion（SD）是什么?
Stable Diffusion是一款2022年发布的文本到图像生成模型，由Stability AI公司与多个学术研究者和非营利组织合作开发。其源代码和模型已经开源，由AUTOMATIC1111在Github上维护一个完整项目，得到全球开发者的共同维护。开源社区对Stable Diffusion的普及做出了重大贡献。
该模型最大特点是开源，可在电脑本地离线运行，适用于大部分配备至少8GB显存的中等性能GPU。推荐的显存为12G。
AI训练与输出结合了深度学习的软硬件原理，常用到Nvidia显卡及相关的CUDA、CUDNN技术，以及xformer、pytorch等深度学习组件。对于希望深入学习AI的用户来说，这些技术需要大量额外的编程学习，可能会感到困难。而秋叶整合包则大大简化了部署过程，使其更易于理解和实施。
Stable Diffusion的基本概念：
大模型：结合素材与SD低模（如SD1.5/SD1.4/SD2.1）经深度学习炼制而成的高级模型，直接用于生成图片。大模型是决定出图大方向的基础底料，主要扩展名为CKPT/SAFETENSORS。
VAE：类似于滤镜，对大模型进行补充，稳定画面色彩范围，常见扩展名同样为CKPT/SAFETENSORS。
LoRA：基于特定大模型深度学习炼制的模型插件，需配合大模型使用，能在中小范围内调整出图风格或补充大模型缺失的元素。根据SD底模炼制的LoRA在不同大模型间切换时具有较好的通用性，而基于特定大模型炼制的LoRA可能在配合时展现出更佳的效果。ControlNet：高级模型插件，赋予SD“视觉”，能基于现有图片获取线条或景深信息，进而用于图片处理。
Stable Diffusion Web-UI（SD-WEBUI）：由开源大师AUTOMATIC1111基于Stability AI算法开发的软件，支持通过图形界面在浏览器中操作SD。
秋叶包：中国开发者秋叶制作的整合包，考虑到WEBUI基于GitHub的部署通常需高网络和Python环境支持，秋叶包内置隔离的Python环境和Git，无需深入了解这两软件即可运行，极大降低了使用门槛，使更多人能享受AI绘图乐趣。
如何安装Stable Diffusion秋叶整合包？
确认配置要求： 系统：需运行Windows 10或更高版本的操作系统。显卡：推荐使用Nvidia品牌的独立显卡，并确保显存容量达到6GB以上。若仅用于生成图像，6GB显存足够；若计划进行模型训练，则建议显存容量为12GB以上。 查看显卡型号的步骤：
在电脑左下角的Windows图标上右键点击；选择“设备管理器”；在设备管理器中找到“显示适配器”，即可查看显卡型号信息。 文件下载与解压： 可从指定来源免费下载文件至本地电脑，并将文件解压至D盘。注意，解压路径最好不包含中文目录，以避免可能的兼容性问题。
SD秋叶V4.9整合包给大家准备好了,扫描下方,即可免费获取
一、打开下载好的安装包（文末获取） 1、安装 *2、安装中* 二、解压启动AI绘画 1、解压 2、启动 三、开始使用 四、 下载模型和安装模型路径 1.安装路径 \2. 模型下载地址根据需求下载
3.放进对应的目录后刷新后，就可以在左边选择对应的模型。
五、 Controlnet插件安装（后台回复的文件已经自带该插件） 1.打开webui复制下方链接到图片中的指示位置点击安装
https://jihulab.com/hanamizuki/sd-webui-controlnet 2. Controlnet模型安装（文章末下载） 根据图片路径移动模型文件过去
**
**
*3. 回到webui重启*
六、 配置跟不上，推荐云电脑 最近，我发现有一个全新的解决方案来解决Stable-Diffusion的部署问题，这就是使用青椒云远程服务。通过这种方式，你无需自行部署Stable-Diffusion，不需要担心硬件要求，也不用担心兼容性问题。
青椒云远程服务的使用体验类似于远程控制一台Windows电脑，远程服务器上预装了各种常用大模型，甚至可以提供高达300G的系统盘空间。你只需打开远程服务，即可开始使用Stable-Diffusion，无需繁琐的安装过程。
这对于那些由于部署难度而无法使用Stable-Diffusion的小伙伴来说是一个很好的解决方案。通过使用青椒云远程服务，你可以更方便地体验Stable-Diffusion的魅力。
这里直接将该软件分享出来给大家吧~
1.stable diffusion安装包 随着技术的迭代，目前 Stable Diffusion 已经能够生成非常艺术化的图片了，完全有赶超人类的架势，已经有不少工作被这类服务替代，比如制作一个 logo 图片，画一张虚拟老婆照片，画质堪比相机。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa0c3df58315bc656a4aa5ca5d71018c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bed4a90407d9e21712a317e948862f92/" rel="bookmark">
			手机设备IP地址切换：方法、应用与注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今数字化时代，手机已成为我们日常生活中不可或缺的一部分。无论是工作、学习还是娱乐，手机都扮演着重要角色。然而，随着网络环境的日益复杂，有时我们需要切换手机设备的IP地址以满足特定的需求，如保护隐私、绕过地域限制等。本文将详细介绍手机设备IP地址切换的多种方法、应用场景以及需要注意的事项，帮助读者更好地理解和应用这一技术。
一、手机设备IP地址切换的方法 更换Wi-Fi网络
更换手机连接的Wi-Fi网络是较为直接的方法之一。当您连接到不同的Wi-Fi网络时，手机会自动获取该网络分配的IP地址。只需在手机设置中找到Wi-Fi选项，断开当前连接，然后选择并连接到另一个Wi-Fi网络，即可实现IP地址的更换。
切换网络数据
对于使用手机数据流量的用户，可以通过切换网络数据来实现IP地址的更换。在手机设置中找到“移动网络”或“蜂窝数据”选项，关闭当前使用的数据连接，然后重新开启或切换到另一个运营商的数据连接。这样，手机就会获取新的IP地址。
使用代理IP
代理IP是一种更为灵活和高效的更换IP地址的方法。通过下载并安装支持动态IP的代理服务应用，如支持免费试用的虎观代理IP软件，用户可以轻松实现IP地址的更改。在应用内注册账号并登录后，选择或设置自动切换IP功能，应用将连接到不同的服务器节点，每次连接时手机将通过这些节点获取新的IP地址。
修改网络设置（高级方法）
对于高级用户来说，通过修改手机的网络设置也可以实现IP地址的更换。在安卓设备中，用户可以打开设置菜单，进入“网络和互联网”选项，选择“Wi-Fi”或“移动网络”，然后长按当前连接的网络名称并选择“修改网络”选项。在弹出的菜单中，选择“显示高级选项”并将“IP设置”更改为“静态”，然后输入新的IP地址、子网掩码和网关即可。但需要注意的是，这种方法较为复杂，且可能导致无法正常联网，因此建议谨慎操作。
二、应用场景 1、保护隐私
在公共Wi-Fi环境下，切换IP地址可以有效保护个人隐私，防止被恶意追踪或攻击。
2、绕过地域限制
某些网站或应用可能根据IP地址限制访问。通过切换IP地址，用户可以绕过这些地域限制，访问更多内容。
3、网络测试与优化
在进行网络测试或优化时，切换IP地址可以帮助用户模拟不同网络环境下的表现，从而更准确地评估网络性能。
三、注意事项 1、合法合规
在切换IP地址时，务必遵守相关法律法规和规定，不得用于非法活动或侵犯他人权益。
2、稳定性与安全性
使用代理IP等第三方服务时，需关注其稳定性和安全性。避免使用不可靠的服务导致信息泄露或网络中断。
3、操作风险
修改网络设置等高级方法存在一定风险，可能导致手机无法正常联网。在尝试前，请确保已备份重要数据并了解相关风险。
文章结尾： 通过本文的介绍，我们了解了手机设备IP地址切换的多种方法、应用场景以及需要注意的事项。无论是出于保护隐私、绕过地域限制还是进行网络测试与优化的目的，掌握这些技巧都将为我们带来便利。然而，在享受技术带来的便利的同时，我们也应时刻牢记合法合规的原则，确保网络安全和个人隐私的安全。
推荐阅读： 手机在不同地方ip地址一样吗
手机IP地址：是根据网络还是设备决定的？
手机卡换了上网的ip会改变吗
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86ea837eeab9ba0db0a55ae4c9b41dd5/" rel="bookmark">
			比肩GPT4，没有显卡也能用Llama-3.1-405B
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（题图由SiliconCloud平台的Flux.1模型生成）
近日，Meta发布了备受瞩目的Llama-3.1系列模型，包括405B “超大杯”模型傲视群雄，成为首个比肩最强大模型的开源模型。
Llama-3.1系列包括8B、70B、405B参数三个版本模型，上下文长度扩展至128k，支持八种语言，具有良好的代码生成能力、复杂推理能力以及工具使用能力。更长的上下文让模型能够处理更复杂和深入的对话场景，以及更自然的交互体验。
其中，Llama-3.1-405B模型是目前最大规模的开源大模型，根据官方提供的各项测评数据，多项评测指标超越了最强闭源大模型GPT-4o和Claude 3.5 Sonnet，并在这些指标中全面超越了GPT-4。
Llama-3.1-405B的面世不仅将开源LLM带到了新高度，也鼓舞了开源社区，更重要的是，它为开源社区的开发者提供了更智能、高效的服务。
不过，与其他各类开源大模型一样，由于Llama-3.1系列模型尺寸极大，开发者在本地开发部署的难度极高，阻碍了开发者使用先进模型，以及生成式AI应用的创新。
SiliconCloud上线Llama-3.1，8B版本免费用
为此，硅基流动推出的大模型API服务平台SiliconCloud已上线Llama-3.1全系列模型，免去了开发者自己开发部署的门槛，可以轻松调用相应的API服务到自己的实际应用中。用户在实名认证后可用，值得一提的是，Llama-3.1-8B可免费使用。
API调用文档：
https://docs.siliconflow.cn/reference/chat-completions-1
SiliconCloud平台对Llama-3.1模型做了推理加速，输出速度极快、价格极其亲民（Llama-3.1-405B也只需￥21.00/1M tokens），支持开发者自由对比体验更类大模型，从而为自己的生成式AI应用选择最佳实践。
Token工厂SiliconCloud Llama-3.1（8B）、Qwen2（7B）等免费用 除了Llama-3.1，SiliconCloud已上架包括FLUX.1、BAAI/bge-large、DeepSeek-V2-Chat、DeepSeek-Coder-V2、SD3 Medium、Qwen2、GLM-4-9B-Chat、SDXL、InstantID在内的多种开源大语言模型、图片生成模型与代码生成模型。
其中，Llama-3.1（8B）、GLM4（9B）等多个大模型API免费使用，让开发者与产品经理无需担心研发阶段和大规模推广所带来的算力成本，实现“Token 自由”。
作为集合顶尖大模型的一站式云服务平台，SiliconCloud为开发者提供更快、更便宜、更全面、体验更丝滑的模型API。
SiliconCloud支持用户自由切换符合不同应用场景的模型，同时提供开箱即用的大模型推理加速服务，为生成式AI应用带来更高效的用户体验。
其他人都在看
800+页免费“大模型”电子书
AI Scaling的神话
AI搜索Perplexity的产品构建之道
John Schulman：大模型的升级秘诀
大模型产品化第一年：战术、运营与战略
生成式AI推理企业的市场机遇、竞争与未来
超越SD3，比肩MJ v6，生图模型FLUX.1开源
SiliconCloud，让超级产品开发者实现“Token自由”
邀请新用户体验SiliconCloud，奖励2000万Token/人
邀请越多，Token奖励越多：
siliconflow.cn/zh-cn/siliconcloud
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0ebba8969940962ed751ea96659d15e/" rel="bookmark">
			使用flask遇到的问题及解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		flask在客户端接收到的中文显示乱码 解决：
flask版本2.3.0以上：JSON_AS_ASCII 属性被废弃
app = Flask(__name__)
app.json.ensure_ascii = False # 解决中文乱码问题
flask版本2.2.5以下：
app = Flask(__name__)
app.config['JSON_AS_ASCII'] = False # 解决中文乱码问题
RuntimeError: The current Flask app is not registered with this 'SQLAlchemy' instance. Did you forget to call 'init_app', or did you create multiple 'SQLAlchemy' instances? 使用SQLAlchemy将自定义的model类通过flask写入数据库时遇到上述错误；
解决：
排查启动的客户端程序，在启动的manager.py中，引入了app = Flask(__name__)，而在写入数据库中用的db.session()，引用的是之前统一定义的app文件__init__文件的db = SQLAlchemy(app)，这样导致声明了两个实例，引发了报错，将manager中的app = Flask(__name__)替换为app的__init__中的db即可。
url中的转义问题 使用flask框架连接数据库，遇到密码中含有特殊字符‘@’，在做url解析时会将密码和host切分错误，导致连接失败；
解决：
对‘@’做url的转义，变为‘%40’，问题解决；在使用GET等方法发送请求时也会遇到类似问题，可将特殊符号做 url 转义；
%2C：',' %40：'@' %3A：':' %20：space %5B：'[' %5D：']'
启动flask debug模式报错问题 调试flask时使用debug模式启动报错，但正常启动没问题；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0ebba8969940962ed751ea96659d15e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/305f3b83c08d64a1dd53add810666ee1/" rel="bookmark">
			flink车联网项目前篇：数据开发（第66天）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 03_数据仓库开发
开发规范
1.1 数据库划分规范
1.2 表命名规范
1.3 表字段类型规范开发前准备
3.1 业务系统表
3.2 数据导入
04_维度主题相关表结构
1.1 dim_area - 城市字典表
1.2 dim_car_info - 车辆信息表
1.3 dim_car_vendor - 车队信息表
1.4 dim_date_work_type -节假日期类型表
1.5 dim_driver_info - 司机信息
1.6 dim_user_info -乘客维度信息表设计思路 文章目录 系列文章目录前言03_数据仓库开发1. 开发规范1.1 数据库划分规范1.2 表命名规范1.3 表字段类型规范 3. 开发前准备3.1 业务系统表3.2 数据导入 04_维度主题1. 相关表结构1.1 dim_area - 城市字典表1.2 dim_car_info - 车辆信息表1.3 dim_car_vendor - 车队信息表1.4 dim_date_work_type -节假日期类型表1.5 dim_driver_info - 司机信息1.6 dim_user_info -乘客维度信息表 2. 设计思路 前言 本文为flink车联网项目前期准备：数据仓库开发。由于篇幅过长，后续章节：业务实现
03_数据仓库开发 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/305f3b83c08d64a1dd53add810666ee1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1fb325e359066e6c84e123a4b63e4bd/" rel="bookmark">
			灵办AI免费ChatGPT4人工智能浏览器插件快速便捷(多功能)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		灵办AI就是您所需的最佳助手！我们为您带来了一款多功能AI工具，不仅能为您提供精准翻译，还能满足您的对话需求、智能续写、AI搜索、文档阅读、代码生成与修正等多种需求。灵办 AI，真正让工作和学习变得轻松高效！
推荐使用浏览器插件端！！！
推荐使用浏览器插件端！！！
推荐使用浏览器插件端！！！
打开方式：点击跳转官网！https://ilingban.com/browser_extension?from=smqnz
(点击添加到Edge浏览器)
以下内容均在浏览器插件端介绍：
主页信息
主要功能 网页全能AI助手：可随时在网页中使用，支持多种操作。
划词翻译：通过简单的划词操作，实现外语单词和段落的瞬间翻译，并提供清晰的解释和补充知识。
对话问答：用户可以与灵办AI进行对话，获取学习和工作方面的解答、文案灵感和信息收集。
翻译功能：支持网页翻译、双语对照和原文展示，覆盖超过60种语言，帮助用户打破语言障碍。
AI续写：灵办AI能够高效生成各类内容，包括文章、标题、短文等，适用于不同场景，保证高质量输出。
平台互通：用户可以通过一个账户在多个平台上使用灵办AI，支持云端储存，随时查看。
无缝对接：支持所有网页，无论您在哪里，都能随时随地使用这个强大的全能AI助手。
高效操作：在网页上任意划词，快速翻译、解释，并立刻获取相关信息，效率提升不再等待！
实时翻译：外语不再是障碍，我们提供超越60种语言的流畅翻译，助您突破信息壁垒。
适用场景：
办公/学习：效率总结、工作报告、阅读笔记，一键生成，事半功倍。
社交媒体：小红书/抖音文案，轻松应对，爆款内容轻松出炉。
代码助手：编程问题轻松解决，从代码修正到生成，我们全程支持。
1.GPT对话功能 灵办AI的GPT聊天实时对话功能为用户提供了一个智能、便捷的交流平台。用户可以与灵办AI进行自然流畅的对话，获取即时的帮助和灵感。
主要特点 即时响应
灵办AI能够快速理解用户的问题，并提供实时的回答，帮助用户解决各种疑问。
2.多领域支持
无论是学习、工作还是日常生活中的问题，灵办AI都能提供相关的信息和建议，覆盖广泛的主题。
3.文案灵感
用户可以通过对话获得创作灵感，灵办AI能够根据用户的需求生成多样化的文案建议。
4.思路讨论
用户可以与灵办AI共同探讨想法，激发新的思路，提升创造力。
5.信息收集
灵办AI能够快速收集和整理信息，帮助用户在短时间内获取所需资料。
6.友好的互动体验
通过自然语言的交流方式，灵办AI提供友好且易于使用的互动体验，让用户感到如同与朋友对话。
自我介绍 接下来我们让AI进行自我介绍(插件端)
可以看出小灵和文心一言大模型”、“讯飞星火大模型”还有“chatgpt”，都是一起学习和进步的伙伴呢！
实时对话 接下来我们让他生成一本书的内容概要以表格的形式展现出来
问题:帮我生成《人人都是产品经理》这本书的表格
回答：
《人人都是产品经理》这本书的内容丰富，涵盖了产品经理的多个方面。由于书籍内容较为广泛，我将尝试为您生成一个概括性的表格，以展示书中的主要章节和关键内容。请注意，这个表格是基于书籍的大致框架和核心内容构建的，并非直接摘自书籍的原文表格。
章节序号章节标题主要内容概述1写给-1到3岁的产品经理介绍产品经理的角色、入行建议及成长路径2一个需求的奋斗史详细探讨需求的采集、分析、验证和管理过程2.1从用户中来到用户中去强调用户是需求之源，介绍了解用户的方法2.2需求采集的大生产运动介绍多种需求采集方法，如用户访谈、调查问卷等2.3听用户的但不要照着做分析如何筛选和验证需求，避免盲目跟从用户2.4活下来的永远是少数讨论需求筛选的标准和过程2.5心急吃不了热豆腐强调需求管理的耐心和细致3项目的坎坷一生讲述项目管理过程中的挑战和应对策略3.1从产品到项目介绍产品如何转化为项目的过程3.2一切从KICK OFF开始阐述项目启动阶段的重要事项3.3关键的青春期,又见需求分析项目执行过程中需求的变化和应对3.4成长,一步一个脚印强调项目管理中的持续改进和成长3.5山寨级项目管理介绍实用的项目管理方法和工具3.6物竞天择适者生存讨论项目成功的关键因素4我的产品,我的团队讲述产品经理如何构建和管理团队4.1大产品,大设计,大团队强调团队在产品开发中的重要性4.2游走于商业与技术之间分析产品经理在商业与技术之间的角色4.3商业团队,冲锋陷阵介绍商业团队在产品推广中的作用4.4技术团队,坚强后盾强调技术团队对产品开发的支持4.5容易被遗忘的角落讨论团队管理中容易忽视的问题4.6大家好才是真的好强调团队协作和团队文化的重要性5别让灵魂跟不上脚步探讨产品经理的自我修养和职业发展5.1触及产品的灵魂强调产品经理对产品理念的深入理解5.2可行性分析三步曲介绍产品可行性分析的方法5.3做吧,准备出发!鼓励产品经理勇于实践，不断前行 这个AI总结的内容结构清晰、逻辑严谨，准确捕捉了《人人都是产品经理》的核心要点，为读者提供了极具价值的学习参考，展现了出色的信息提炼能力。
可以看出它回答的十分详细，把全文的章节 和章节的概述 清楚的列出来 客观清晰。
上下文能力 我们让他根据上文总结的文章章节和章节的简单介绍，写成一篇篇的故事来以此表达励志。
多的就不说了，大家看回答的问题，懂得都懂。
其他的对话功能也是如此，以上只是简单的举例子。
2.翻译功能 实时翻译,支持网页翻译、双语对照和原文展示，覆盖超过60种语言，帮助用户打破语言障碍。
可以看到相应的速度也是相当的迅速，最大支持上传1000字。
但是也可以支持上传其他语言的文档来进行文档解析
网页翻译 灵办AI的网页实时翻译功能为用户提供了便捷的翻译体验，特别适用于浏览英文页面时。用户只需轻松点击翻译按钮，即可将整个网页内容即时翻译为中文，帮助用户快速理解信息。
包括后续的智能翻译功能
3.搜索功能 问题：Centos中如何下载apache网站
回答：
功能介绍 灵办AI的搜索功能非常实用，能够高效地帮助用户找到所需的信息。以下是对其功能的详细介绍：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1fb325e359066e6c84e123a4b63e4bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42ae6082c445599672906a1be352c7d0/" rel="bookmark">
			【爬虫新手村】零基础入门到实战：解锁互联网数据收集的密钥，爬虫技术全攻略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、爬虫1.基本概念2.常用库3.基本步骤4.注意事项 二、爬虫示例代码1.案例一：requests 的基本使用2.案例二：爬取古诗文（requests+BeautifulSoup）3.案例三：爬取美食（requests+BeautifulSoup）4.案例四：爬取美食Video（requests+BeautifulSoup）5.案例五：爬取图片并以二进制形式写入（requests）6.案例六：反爬-伪装请求头-IP代理（requests+fake_useragent）7.案例七：爬取网易汽车图片以二进制写入（requests）8.案例八：selenium的基本使用9.案例九：通过爬虫查看QwenToken余额（selenium+BeautifulSoup）10.案例十：selenium 设置无头浏览器 前言 在当今信息爆炸的时代，爬虫技术成为高效获取互联网数据的关键工具。本文为初学者精心打造了一份入门级爬虫指南，从基础概念、常用库介绍到实战案例分享，全方位覆盖爬虫技术的核心要点。通过学习本文，你将掌握爬虫的基本步骤、requests、BeautifulSoup、selenium等工具的使用及实战技巧，并了解在爬虫过程中应遵守的法律法规和道德准则。无论你是编程爱好者还是数据分析师，本文都能助你快速入门爬虫技术，开启数据收集与分析的新篇章。
一、爬虫 Python 爬虫（Web Scraping 或 Web Crawling）是一种自动化程序，用于从互联网上抓取或提取数据。Python 由于其简洁的语法、丰富的库支持以及强大的社区，成为了实现爬虫功能的热门选择。下面将简要介绍Python爬虫的基本概念、常用库以及一些基本步骤。
1.基本概念 爬取（Scraping）： 从网页中提取信息的过程。爬虫（Crawler）： 自动浏览互联网（特别是万维网）的机器人程序，它可以按照设定的规则自动抓取网页上的信息。反爬虫（Anti-Scraping）： 网站为防止爬虫抓取数据而采取的技术措施，如设置验证码、限制请求频率等。解析（Parsing）： 从HTML或XML等格式的网页中提取结构化数据的过程。 2.常用库 requests： 用于发送HTTP请求，是爬虫中常用的库之一。
BeautifulSoup： 用于从HTML或XML文件中提取数据，通过解析文档为用户提供需要抓取的数据。
Scrapy： 一个快速高级的Web抓取和网页抓取框架，用于爬取网站并从页面中提取结构化的数据。Scrapy使用Twisted异步网络框架来处理网络通讯。
Selenium： 一个用于Web应用程序测试的工具，支持多种浏览器和平台。它可以直接模拟用户操作浏览器，非常适合需要JavaScript渲染的网页。
lxml： 一个高效的HTML和XML解析库，支持XPath和XSLT。
3.基本步骤 确定目标： 明确你要抓取的数据和来源网站。分析网页： 查看网页的源代码，了解数据是如何嵌入在HTML中的。编写爬虫： 使用requests发送HTTP请求获取网页内容。使用BeautifulSoup、lxml或Scrapy解析网页，提取所需数据。如果有JavaScript渲染，可能需要使用Selenium。 存储数据： 将提取的数据保存到文件（如CSV、JSON）、数据库或进行进一步处理。处理异常： 添加错误处理机制，如重试机制、超时设置等，以提高爬虫的健壮性。遵守法律与道德： 确保你的爬虫行为符合目标网站的robots.txt文件规定，尊重版权和隐私。 4.注意事项 尊重版权： 在爬取网站数据时，要尊重网站的版权和隐私政策，避免侵犯他人的合法权益。避免过度请求： 合理设置请求频率，避免给目标网站服务器带来不必要的负担。反爬虫策略： 针对网站的反爬虫措施，可能需要采取如设置请求头、使用代理IP、模拟用户行为等策略。 二、爬虫示例代码 1.案例一：requests 的基本使用 requests-get请求：
import requests # 发送GET请求 url = 'https://www.baidu.com' response = requests.get(url) response.encoding = response.apparent_encoding # 使用其自动检测到的最合适的编码方式来解码响应内容 # 处理响应 print(response.status_code) # 获取响应状态码 print(response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42ae6082c445599672906a1be352c7d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55f1f68c96d04f931b5127389cffb591/" rel="bookmark">
			贪心算法总结（4）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、跳跃游戏I 55. 跳跃游戏 - 力扣（LeetCode）
class Solution { public: bool canJump(vector&lt;int&gt;&amp; nums) { //贪心+双指针 用left和right指向两个区间 然后maxpos表示下一层的最右端点 int left=0,right=0,maxpos=0,n=nums.size(); while(left&lt;=right) //有可能会跳不到n-1的位置 比如说出现了很多个0 { if(maxpos&gt;=n-1) return true; for(int i=left;i&lt;=right;++i) maxpos=max(maxpos,nums[i]+i); //找到之后更新区间 left=right+1; right=maxpos; } return false; } }; 二、跳跃游戏II 45. 跳跃游戏 II - 力扣（LeetCode）
解法1 ：动态规划
class Solution { public: int jump(vector&lt;int&gt;&amp; nums) { //动态规划的思想 dp[i]表示以i位置为结尾时的最小步数 int n=nums.size(); vector&lt;int&gt; dp(n,INT_MAX); dp[0]=0; for(int i=1;i&lt;n;++i) for(int j=0;j&lt;i;++j) if(nums[j]+j&gt;=i) dp[i]=min(dp[i],dp[j]+1); return dp[n-1]; } }; 解法2：贪心 +双指针
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55f1f68c96d04f931b5127389cffb591/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5af0012a89d7ad78df0eae44034ff48/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(082)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
341、pandas.Series.str.startswith方法
341-1、语法
341-2、参数
341-3、功能
341-4、返回值
341-5、说明
341-6、用法
341-6-1、数据准备
341-6-2、代码示例
341-6-3、结果输出
342、pandas.Series.str.strip方法
342-1、语法
342-2、参数
342-3、功能
342-4、返回值
342-5、说明
342-6、用法
342-6-1、数据准备
342-6-2、代码示例
342-6-3、结果输出
343、pandas.Series.str.swapcase方法
343-1、语法
343-2、参数
343-3、功能
343-4、返回值
343-5、说明
343-6、用法
343-6-1、数据准备
343-6-2、代码示例
343-6-3、结果输出
344、pandas.Series.str.title方法
344-1、语法
344-2、参数
344-3、功能
344-4、返回值
344-5、说明
344-6、用法
344-6-1、数据准备
344-6-2、代码示例
344-6-3、结果输出
345、pandas.Series.str.translate方法
345-1、语法
345-2、参数
345-3、功能
345-4、返回值
345-5、说明
345-6、用法
345-6-1、数据准备
345-6-2、代码示例
345-6-3、结果输出
二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 341、pandas.Series.str.startswith方法 341-1、语法 # 341、pandas.Series.str.startswith方法 pandas.Series.str.startswith(pat, na=None) Test if the start of each string element matches a pattern.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5af0012a89d7ad78df0eae44034ff48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34eea215fd881f977c3714b84e54a9bf/" rel="bookmark">
			Whisper Android 项目使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Whisper Android 项目使用教程 whisper_androidOffline Speech Recognition with OpenAI Whisper and TensorFlow Lite for Android项目地址:https://gitcode.com/gh_mirrors/wh/whisper_android 项目介绍 Whisper Android 是一个基于 OpenAI Whisper 和 TensorFlow Lite 的离线语音识别项目。该项目允许用户在 Android 设备上进行离线语音转文字操作，提供了高效的语音识别功能。通过使用量化后的模型，项目在保持性能的同时，减少了模型的大小，使其更适合移动设备。
项目快速启动 环境准备 Android Studio: 确保你已经安装了最新版本的 Android Studio。TensorFlow Lite: 项目依赖于 TensorFlow Lite，确保你的开发环境中已经配置好 TensorFlow Lite。 克隆项目 首先，克隆项目到本地：
git clone https://github.com/vilassn/whisper_android.git 导入项目 打开 Android Studio。选择 File -&gt; New -&gt; Import Project，然后选择你刚刚克隆的目录。 配置模型 项目中已经包含了一个量化的 Whisper 模型，但如果你需要使用其他模型，可以替换 assets 目录中的模型文件。
运行项目 连接你的 Android 设备或启动模拟器。点击 Android Studio 中的 Run 按钮，编译并运行项目。 应用案例和最佳实践 应用案例 语音笔记: 用户可以通过语音输入快速记录笔记，无需手动输入。实时字幕: 在会议或讲座中，实时将演讲者的语音转换为文字，方便记录和理解。 最佳实践 优化模型: 根据具体需求，选择合适的模型大小和精度，以平衡性能和准确性。错误处理: 在应用中加入适当的错误处理机制，确保在语音识别失败时，用户可以得到友好的提示。 典型生态项目 TensorFlow Lite: 作为 Whisper Android 的核心依赖，TensorFlow Lite 提供了高效的机器学习模型部署方案。OpenAI Whisper: Whisper 模型本身是由 OpenAI 开发的，提供了强大的语音识别能力。 通过以上步骤，你可以快速启动并使用 Whisper Android 项目，实现高效的离线语音识别功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34eea215fd881f977c3714b84e54a9bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0c8b5e3d0e42ed0566ffe628b2f134f/" rel="bookmark">
			Web 开发安全与最佳实践：MVC、会话管理与常见攻击防御
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MVC模式 MVC（Model-View-Controller）是一种广泛使用的软件设计模式，用于简化应用程序的开发过程。它通过分离数据访问、用户界面和业务逻辑，使得应用程序的结构更加清晰。
MVC的组成部分 1. Model（模型） 定义：代表应用程序的数据和业务逻辑。职责： 与数据库进行交互处理数据的逻辑操作在JavaWeb中的实现： 使用POJO（Plain Old Java Object）类，通常与数据库表一一对应DAO（Data Access Object）负责数据库交互Service层实现业务逻辑可使用ORM（Object-Relational Mapping）框架如Hibernate来简化数据库操作 2. View（视图） 定义：负责将模型的数据呈现给用户。职责：展示数据，提供用户界面。在JavaWeb中的实现： 常用JSP（JavaServer Pages）也可使用现代模板引擎如Thymeleaf 3. Controller（控制器） 定义：处理用户请求，协调模型和视图。职责： 接收用户输入调用模型的业务逻辑更新视图在JavaWeb中的实现： 传统方式使用Servlet在Spring框架中使用@Controller注解的类 JSP内置对象 JSP提供了几个内置对象，极大地简化了Web开发过程。以下是主要内置对象的概述：
request (HttpServletRequest) 传递客户端发送给服务端的请求包含参数、URL、头信息等response (HttpServletResponse) 承载服务端向客户端发送的响应可设置响应头、状态码等pageContext (PageContext) 提供对其他内置对象的访问包含页面范围的方法，如属性的获取、设置和删除session (HttpSession) 存储会话期间的状态信息application (ServletContext) 在整个应用程序范围内共享数据out (JspWriter) 向客户端发送HTML内容config (ServletConfig) 包含初始化Servlet的参数page (Object) 表示当前Servlet对象exception (Throwable) 仅在错误页面（isErrorPage=true）中使用包含异常信息 这些内置对象极大地便利了HTTP请求的处理过程。例如：
使用request获取用户的请求内容使用session获取会话的状态信息使用out发送HTML给客户端 JSP 和 Servlet 比较 JSP（JavaServer Pages）和Servlet都是JavaWeb开发中常用的技术，主要用于生成动态网页内容。虽然它们的目标相似，但在使用方式和适用场景上有明显区别。
1. 语法和易用性 JSP 基于HTML，允许在HTML中嵌入Java代码支持表达式语言（EL）和JSTL，简化了数据访问和常见操作更适合于生成和展示视图（View） Servlet 纯Java代码在生成HTML时相对繁琐更适合处理复杂的业务逻辑 2. 编译方式 JSP 首次请求时编译代码变更后自动重新编译，无需重启服务器 Servlet 服务器启动或首次请求时编译编译一次后不再重新编译，代码更改需重启服务器 3. 主要用途 JSP 生成和展示视图（HTML页面）适合处理简单的展示逻辑 Servlet 处理业务逻辑处理表单提交、数据库查询等后端操作 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0c8b5e3d0e42ed0566ffe628b2f134f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e503bbe8795f54543f761ab154832d6/" rel="bookmark">
			【MySQL进阶之路】MySQL基础——从零认识MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
主流数据库
什么是MySQL
MySQL服务
从文件系统角度理解数据库
MySQL架构
SQL语句分类
存储引擎
个人主页：东洛的克莱斯韦克-CSDN博客
主流数据库 数据库开发商特点适用场景SQL Server微软.NET程序员的最爱，适合中大型项目企业级应用，中大型数据库解决方案Oracle甲骨文适合大型项目，复杂的业务逻辑，但并发性一般企业级应用，复杂业务逻辑处理MySQL甲骨文（通过收购Sun Microsystems）世界上最受欢迎的数据库，并发性好，不适合复杂业务电商，SNS，论坛，简单SQL处理PostgreSQL加州大学伯克利分校计算机系免费使用、修改和分发，适用于私用、商用和学术研究多种应用场景，包括企业级应用SQLite公开源代码社区轻型数据库，遵守ACID，嵌入式设计，资源占用低嵌入式设备，移动应用，小型项目H2Java社区用Java开发的嵌入式数据库，可直接嵌入到应用项目中测试环境，小型应用，嵌入式数据库需求 什么是MySQL MySQL是一种网络服务，有客户端和服务端。可以用 which 命令查看路径。
客户端一般在/usr/bin/mysql 路径下，服务端一般在/usr/sbin/mysqld （以d结尾的进程一般都是守护进程）路径下。
而数据存放的路径可以在/etc/my.cnf配置文件中配置，默认是/var/lib/mysql
MySQL是在文件系统的基础上搭建的一套完整的网络服务，用于高效的存储，管理数据。那存储数据用文件就可以了，为什么还要弄个数据库?
单纯用文件管理数据有如下缺点
文件的安全性并不是很可靠文件不利于数据查询和管理文件不利于存储海量数据文件在程序中控制不方便 可以说，文件系统只是提供了最基础的数据保存，数据的读写功能。
MySQL服务 所谓安装数据库服务器，只是在机器上安装了一个数据库管理系统程序，这个管理程序可以管理多 个数据库，一般开发人员会针对每一个应用创建一个数据库。 为保存应用中实体的数据，一般会在数据库中创建多个表，以保存程序中实体的数据。 数据库服务器、数据库和表的关系如下：
上图中的Client是数据库的客户端。MySQL就是数据库的服务端，一般会以守护进程的方式一直在服务器上监听外来请求。客户端用SQL语句向服务端发起请求，而服务端解析SQL语句，然后对数据进行管理相关的工作。
我们平常所说的数据库既不是指的客户端，也不是指的服务端，而是上图中的DB。而DB中的表结构存的就是数据。
从文件系统角度理解数据库 所谓的所谓的数据库（DB）和表结构到底是什么呢？
前文已经提到数据存放的路径在/var/lib/mysql。那么我们创建一个数据库，再创建一张表，/var/lib/mysql路径下会有什么变化呢？
创建数据库的SQL语句
create database helloworld; 使用数据库的SQL语句
use helloworld; 创建数据库表的SQL语句
create table student( id int, name varchar(32), gender varchar(2) ); 我们用上述语句创建一个helloworld的数据库，再向helloworld数据库中建一张student表
先创建数据库，看看/var/lib/mysql目录下的变化
创建数据库后多了一个helloworld目录，进入到helloworld目录，再创建student表看看变化
创建student表之后，在helloworld目录下多了一些student表相关的文件。
从文件系统角度讲，创建数据库就是在系统中创建目录，创建表结构就是在该目录下创建相关文的件。
MySQL架构 文件系统对MySQL来说只是最底层的东西，或者说是基石。现在来谈一谈MySQL的架构。
MySQL 是一个可移植的数据库，几乎能在当前所有的操作系统上运行，如 Unix/Linux、Windows、 Mac 和 Solaris。各种系统在底层实现方面各有不同，但是 MySQL 基本上能保证在各个平台上的物理体 系结构的一致性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e503bbe8795f54543f761ab154832d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deb4621d8d4a2d410313d25fce6afbf2/" rel="bookmark">
			新手常见错误：java.lang.NumberFormatException: For input string: “xxxx“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
​编辑
故事背景 文言一心解答：
思考：
文心一言总结：
报错总结：
解决方案：
结语： 故事背景 写代码的时候遇到的报错
文言一心解答： 这个错误 `java.lang.NumberFormatException: For input string: "王"` 表明在尝试将一个字符串（在这种情况下是汉字 "王"）解析为一个数字时发生了异常。这通常发生在代码期望接收一个数字字符串但实际上接收到了一个非数字字符串时。
在你的堆栈跟踪中，错误发生在 MyBatis 的 OGNL 表达式求值过程中，特别是在执行比较操作或类型转换时。具体来说，MyBatis 试图将某个值（在这个例子中是 "王"）转换为 `double` 类型，但因为这个值不是有效的数字字符串，所以抛出了 `NumberFormatException`。
这个问题可能由以下几个原因引起：
MyBatis 映射文件或注解中的错误：在 MyBatis 的映射文件（XML）或注解中，可能有一个表达式错误地将一个应该包含数字的字段与 "王" 这样的字符串进行了比较或类型转换。数据库查询结果错误：查询返回的结果集中可能包含了不应该出现的数据，或者某个字段的数据类型与预期不符。前端或中间件错误：在将数据发送到后端之前，前端或中间件可能已经错误地处理了数据，或者发送了错误的数据。 为了解决这个问题，你可以采取以下步骤：
- 检查 MyBatis 映射文件：查看是否有任何表达式错误地将非数字字段与数字进行了比较或转换。- 审查数据库查询：检查触发异常的查询，确保所有涉及的字段都是预期的数据类型。- 增加日志记录：在 MyBatis 的查询执行前后增加日志记录，以便更清楚地了解查询结果和数据的处理过程。- 验证前端数据：确保前端发送的数据是正确的，并且符合预期的数据类型。- 使用类型安全的比较：在 MyBatis 表达式中，尽量使用类型安全的比较和转换方法，以避免此类异常。 最后，由于 "王" 是一个汉字，通常不会用于数值计算或比较，因此你需要仔细检查代码和数据流，以确保没有错误地将这种类型的数据用于数值操作。
思考： 根据文心一言给我的提示，MyBatis 试图将某个值（在这个例子中是 "王"）转换为 `double` 类型，MyBatis 映射文件或注解中的错误，很显然映射文件sql写的有问题，大概调试了一下看了看mybatis映射文件，发现多了个空格。这就很烦。
文心一言总结： java.lang.NumberFormatException 是 Java 中的一个常见异常，它通常在尝试将一个字符串转换成数值类型（如 int, long, float, double 等）时，如果字符串的格式不正确，无法被解析为有效的数值，就会抛出这个异常。对于你提到的错误信息 java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/deb4621d8d4a2d410313d25fce6afbf2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/194690977d8b35572b7b34bf7324a820/" rel="bookmark">
			MySQL：查询（万字超详细版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💎所属专栏： MySQL
💎1. 单表查询 💎1.1 全列查询和指定列查询 全列查询：
select * from exam; 在实际开发中不要使用 * 来进行查询，因为数据库会很大，影响效率 指定列查询：
select id,name,math from exam; 查询的结果是一个表达式，例如，在查询命令中添加一个数值，每一列都会有这个数值
select id ,name ,10 from exam; 之后，可以通过as关键字来为查询结果中的列指定别名，as和引号可以省略，但如果别名中存在空格就不能省略引号了
select id as '编号' ,name as '姓名' from exam; 列与列之间还可以进行运算：
select chinese + math + english as '总分' from exam; 还可以直接加上指定的数字
select math + 10 from exam; 💎1.2 去重查询 去重查询是通过关键字 distinct 来实现的，在之前的math中，是存在一个重复的98的，我们来试验一下去重查询操作：
select distinct math from exam; 有一点需要注意的是，在查询结果中，每一列都相同才认为是重复数据，刚刚只查询的是math这一列，这次加上id试试：
可以看到，这一次重复的98并没有被去掉，因为id不同
💎1.3 排序查询 对于多字段，按照字段的前后顺序，如果第一个字段相同，按照第二个字段进行排序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/194690977d8b35572b7b34bf7324a820/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94469cfac8f41fe69d386973c23b61db/" rel="bookmark">
			初阶数据结构排序之插入排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		排序01 插⼊排序 基本思想
直接插⼊排序是⼀种简单的插⼊排序法，其基本思想是：把待排序的记录按其关键码值的⼤⼩逐个插 ⼊到⼀个已经排好序的有序序列中，直到所有的记录插⼊完为⽌，得到⼀个新的有序序列 。
实际中我们玩扑克牌时，就⽤了插⼊排序的思想
直接插⼊排序 当插⼊第 i(i&gt;=1) 个元素时，前⾯的 array[0],array[1],…,array[i-1] 已经排好序，此时 ⽤ array[i] 的排序码与 array[i-1],array[i-2],… 的排序码顺序进⾏⽐较，找到插⼊位置 即将 array[i] 插⼊，原来位置上的元素顺序后移
InsertSort.h
#pragma once #include &lt;stdio.h&gt; void InsertSort(int* arr, int n); void Print(int* arr, int n); InsertSort.c
#define _CRT_SECURE_NO_WARNINGS 1 #include "InsertSort.h" void InsertSort(int* arr, int n) { //外层循环控制内部要进行多少次 //n-1是因为end+1的时候，end=n的话，会造成越界 for (int i = 0; i &lt; n - 1; i++) { //end表示有序数组的最后一位 int end = i; //tmp表示有序数组的下一位 int tmp = arr[end + 1]; while (end &gt;= 0) { if (arr[end] &gt; tmp) { arr[end + 1] = arr[end]; //这是从后往前进行比较 end--; } //如果顺序不用变动，就跳出循环 else { break; } } //最后循环出来得到的结果 arr[end + 1] = tmp; } } void Print(int* arr, int n) { for (int i = 0; i &lt; n; i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94469cfac8f41fe69d386973c23b61db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df952db57d39d6284af1e78ca1285903/" rel="bookmark">
			【机器学习】探索数据矿藏：Python中的AI大模型与数据挖掘创新实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💖 前言：探索数据矿藏1. 📊数据获取与预处理：AI大模型的燃料1.1 🌐数据获取：多样性与规模并重1.2 🧹数据清洗与处理：提升数据质量1.3 🔍特征工程：挖掘数据的深层次信息1.4 🧠自动化特征工程：AI与特征工程的结合 2. 🤖模型训练与优化：构建智能的大脑2.1 🎯模型选择：大模型的基础构建2.2 🔧模型训练：从数据到智能的转化2.3 ⚙️模型优化：精益求精的智能化提升2.4 🛠模型解释与可视化：揭示黑盒的内部 3 🚀实际应用案例：AI大模型赋能数据挖掘3.1 📈文本分类与情感分析：商业情报的利器3.2 🖼图像识别与目标检测：智能监控与安全防护3.3 📝自然语言生成：自动化内容创作的未来3.4 🔍强化学习与推荐系统：智能决策的关键 🌐 结语：创新与未来 个人主页：C_GUIQU
💖 前言：探索数据矿藏 随着人工智能技术的迅猛发展，AI大模型（如GPT、BERT等）在各类任务中展现了强大的能力。然而，这些大模型的背后是海量数据和复杂的算法支撑。在这篇博客中，我们将深入探讨如何利用Python进行数据挖掘，并结合AI大模型实现更高效、更精准的智能应用。本文将从数据获取与预处理、模型训练与优化、实际应用案例等多个方面展开，带您进入一个创新的AI与数据挖掘世界。
1. 📊数据获取与预处理：AI大模型的燃料 数据是AI大模型的基础，而数据的质量直接影响模型的性能。在数据挖掘过程中，如何有效获取并预处理数据成为了关键步骤。
1.1 🌐数据获取：多样性与规模并重 在数据挖掘中，获取多样化和大规模的数据是至关重要的。无论是文本、图像、语音，还是传感器数据，不同数据类型带来了不同的挑战和机会。通过Python中的requests、BeautifulSoup等库，可以轻松实现网络爬虫，从各大网站中提取有价值的数据。
import requests from bs4 import BeautifulSoup import pandas as pd url = "https://example.com/data" response = requests.get(url) soup = BeautifulSoup(response.text, 'html.parser') # 假设页面上有一个表格数据 table = soup.find('table') data = pd.read_html(str(table))[0] 同时，面对庞大的数据集，可以利用分布式计算框架如Apache Spark，并借助pyspark库来进行高效的数据处理。Spark能够处理海量数据集，并提供强大的数据处理工具。
from pyspark.sql import SparkSession spark = SparkSession.builder.appName("Data Processing").getOrCreate() df = spark.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df952db57d39d6284af1e78ca1285903/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/997097e8de91ffbedcf2bf3606e9ed63/" rel="bookmark">
			mysql 物理备份 MySQL 全量备份 增量备份 差异备份 日志备份万字长文 1.3万字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版权声明：本文为博主原创文章，遵循版权协议，转载请附上原文出处链接和本声明
注意，通常 完备增备，日志（binlog)备，结合使用 差异则根据具体情况选用。
此备份过程 属于公司 常用的单个数据库备份技术中的
mysql 物理备份 MySQL 全量备份 增量备份 差异备份 日志备份
至于单个数据库备份技术中的逻辑备份 和
混合数据库及其备份技术，本人会另外开文章再进行说明
MySQL备份工具的安装 逻辑备份工具 mysqldump 自带
物理备份工具 percona-xtrabackup 需安装
MySQL数据备份方式 主要有四种：
完整备份、增量备份、差异备份和逻辑备份。它们的区别在于备份的范围和备份方式不同。
MySQL物理备份的种类及其特点 MySQL物理备份主要有三种：完整备份、增量备份和差异备份。每种备份方式都有其独特的特点和适用场景。
1. 完整备份 特点： 备份整个数据库的所有数据和结构。备份文件较大，占用较多存储空间。恢复速度最快，因为只需要恢复一个备份文件。适用场景： 数据量较小的数据库。需要快速恢复的场景。 2. 增量备份 特点： 备份自上次完整备份或增量备份以来发生变化的数据。备份文件较小，节省存储空间。恢复速度较慢，因为需要先恢复完整备份，然后应用所有增量备份。适用场景： 数据量较大且变化频繁的数据库。需要节省存储空间的场景。 3. 差异备份 特点： 备份自上次完整备份以来发生变化的数据。备份文件大小介于完整备份和增量备份之间。恢复速度较快，因为只需要恢复完整备份和一个差异备份。适用场景： 数据量较大且变化频繁，但希望恢复过程不太复杂。需要快速恢复且节省存储空间的场景。 总结 选择哪种备份方式取决于具体需求：
完整备份适用于数据量较小且需要快速恢复的场景。增量备份适用于数据量较大且变化频繁，需要节省存储空间的场景。差异备份适用于数据量较大且变化频繁，但希望恢复过程不太复杂的场景。 Percona XtraBackup 是一个开源的 MySQL 和 InnoDB 备份工具，广泛用于物理数据备份和恢复。
MySQL安装percona-xtrabackup 逻辑备份工具 mysqldump 自带
percona-xtrabackup版本这里有必要说明 参考官网如下：
Aligning Percona XtraBackup Versions with Percona Server for MySQLWe are excited to let you know about two upcoming changes to Percona XtraBackup which will align Percona XtraBackup Versions with Percona Server for MySQL.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/997097e8de91ffbedcf2bf3606e9ed63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccfc7250b71145e56e847584ea1cb993/" rel="bookmark">
			Vue自我总结面试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.vue-router中有哪些模式？有什么区别？ Vue Router 提供了三种路由模式：‌Hash 模式、‌History 模式和 Abstract 模式。‌
Hash 模式（默认）：
URL中带有 # ，兼容较老的浏览器。例如：http://xxxx.com/#/path。当 URL 的哈希值发生变化时，浏览器不会向服务器发送请求，而是通过监听 hashchange 事件来进行路由导航。 History 模式：
使用 HTML5 的 History API 来管理路由。可使用正常的 URL 地址。例如：http://xxxx.com/path。通过pushState方法+popstate事件来实现的，监听popstate事件是为了响应浏览器的前进后退功能。当 URL 发生变化时，浏览器会向服务器发送请求，服务器需要配置相应的路由规则，以确保在刷新页面或直接访问 URL 时能正确响应路由。 history模式开发的SPA项目，需要服务器端做额外的配置，否则会出现刷新白屏（链接分享失效）。原因是页面刷新时，浏览器会向服务器真的发出对这个地址的请求，而这个文件资源又不存在，所以就报404。处理方式就由后端做一个保底映射:所有的请求全部拦截到index.html上。这样的话，后端就无法判断404了，前端就需要在路由最后自己增加一个匹配‘*’，匹配所有其他路由，自定义自己的notFound.vue组件。
Abstract 模式：
主要用于非浏览器环境，比如在服务器端渲染（Server-Side Rendering）时使用。Vue Router 不会对 URL 进行任何处理，而是将路由信息保存在内存中，需要手动管理路由的变化 动态路由：动态路由允许你在运行时根据不同的条件添加或删除路由。方法：addRoute和removeRoute。这种灵活性对于构建复杂的单页应用尤为重要，尤其是在需要根据不同用户角色或权限动态显示或隐藏路由的情况下。
例如：.在导航守卫中添加路由后，如果立即导航到新添加的路由，需要使用 next 函数的参数来指定新路由：
router.beforeEach((to, from, next) =&gt; { // 添加路由逻辑 router.addRoute('newRoute', { path: '/new-path', component: () =&gt; import('@/components/NewComponent.vue') }); // 如果目标路由是新添加的路由，则直接导航到新路由 if (to.path === '/new-path') { next({ ...to, name: 'newRoute' }); } else { next(); } }); 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccfc7250b71145e56e847584ea1cb993/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45e512b2e96f77547d8cfa250c27b963/" rel="bookmark">
			【数据结构】位图与布隆过滤器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 位图1.1 位图的设计与实现1.2 C++库中的位图1.3 位图相关考察题目 2. 布隆过滤器2.1 什么是布隆过滤器2.2 布隆过滤器的实现2.3 布隆过滤器的应用 在前面我们已经学习过了哈希表，但有些时候使用常规的哈希表并不能解决某些问题，我们需要对普通哈希表进行变种，例如： 题目： 给40亿个不重复的⽆符号整数，没排过序。给⼀个⽆符号整数，如何快速判断⼀个数是否在这40亿个数中。
对于该题目，有几种解法：
暴力求解：直接遍历查找，时间复杂度为O(N)，太慢排序+二分查找：时间复杂度为O(N*logN) + O(logN) 但是解法2是否可行呢？我们先算算40亿个数据⼤概需要多少内存。
40亿个整型，就是4*40亿 = 160亿个字节。1G = 1024MB = 1024 * 1024KB = 1024 * 1024 *1024byte，1G大约10亿多字节。那40亿个整型就是16G内存，说明40亿个数是⽆法直接放到内存中的，只能放到硬盘⽂件中。⽽⼆分查找只能对内存数组中的有序数据进⾏查找，所以方法2不可行。 使用哈希的变种：位图。 数据是否在给定的整形数据中，结果是在或者不在，刚好是两种状态，那么可以使⽤⼀个⼆进制⽐特位来代表数据是否存在的信息，如果⼆进制⽐特位为1，代表存在，为0代表不存在。那么我们设计⼀个⽤位表⽰数据是否存在的数据结构，这个数据结构就叫位图。
我们来算一下使位图需要多少内存呢？
40亿个整数，每个比特位对应一个整数，也就需要40亿个比特位。一个字节是8个比特位，40亿 / 8 = 5亿字节；1MB大约是100万字节，那5亿字节大约就才500MB，能开1.25亿个int。
1. 位图 1.1 位图的设计与实现 位图本质是⼀个直接定址法的哈希表，每个整型值映射⼀个bit位，位图提供控制这个bit的相关接⼝。
由于C/C++没有对应位的类型，只能看int/char这样整形类型，我们再通过位运算去控制对应的⽐特位。
比如我们数据存到 vector&lt; int &gt;中，相当于每个int值映射对应的32个值，⽐如第⼀个整形映射0-31对应的位，第⼆个整形映射32-63对应的位，后⾯的以此类推，那么来了⼀个整形值x，i=x/32；j=x%32；计算出x映射的值在vector的第i个整形数据的第j位。
解决给40亿个不重复的⽆符号整数，查找⼀个数据的问题，我们要给位图开232(无符号整型的最大值)个位，注意不能开40亿个位，因为映射是按⼤⼩映射的，我们要按数据⼤⼩范围开空间，范围是是0-232-1，所以需要开2^32个位。
下面我们就需要实现位图的插入与删除功能了
对于插入一个数据x时，我们首先要知道x应该对应在哪一个比特位上，然后将该比特位设置为1。 void set(size_t x) { size_t i = x / 32;//在第几个字节 size_t j = x % 32;//在一个字节中的哪一个比特位上 vt[i] |= (1 &lt;&lt; j);//将"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45e512b2e96f77547d8cfa250c27b963/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b70839c112106eaa239ac069058f45cb/" rel="bookmark">
			C语言内存函数超详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. memcpy1. 1 memcpy 的使用1. 2 memcpy 的模拟实现 2. memmove2. 1 memmove 使用 3. memset3. 1 memset 函数的使用3. 2 memset 的模拟实现 4. memcmp4. 1 memcmp 函数的使用4. 2 memcmp 的模拟实现 前言 C语言为我们提供了字符串的一些函数，比如复制，比较等等，但是这些函数只能用在字符串上，而C语言的数据类型显然不止字符串一种，那应该怎么办？难道要把每一种数据类型都包装几个函数供我们使用吗？显然这太过臃肿。
为了解决这个问题，C语言在string.h库中提供了内存函数供我们使用。
1. memcpy void * memcpy ( void * destination, const void * source, size_t num ); 函数memcpy从source的位置开始向后复制num个字节的数据到destination指向的内存位置。这个函数在遇到'\0'的时候并不会停下来。如果source和destination有任何的重叠，复制的结果都是未定义的。也就是说，source和destination后面的num个字节之间不能有重叠的部分！ 1. 1 memcpy 的使用 #include&lt;stdio.h&gt; #include&lt;string.h&gt; int main() { int arr1[10] = { 0,1,2,3,4,5,6,7,8,9 }; int arr2[10] = { 0 }; memcpy(arr2, arr1, sizeof(arr1));//sizeof(arr)是40个字节，也就是10个 int 类型的变量 for (int i = 0; i &lt; 10; i++) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b70839c112106eaa239ac069058f45cb/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/43/">«</a>
	<span class="pagination__item pagination__item--current">44/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/45/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>