<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdeb46b04ef8fd350688553b5ca29a94/" rel="bookmark">
			R语言贝叶斯方法在生态环境领域技术教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：R语言贝叶斯方法在生态环境领域技术教程https://mp.weixin.qq.com/s?__biz=MzUzNTczMDMxMg==&amp;mid=2247612056&amp;idx=5&amp;sn=b170122cf5052cc7cb2d858606b9f158&amp;chksm=fa82777fcdf5fe69eec092410530e2900c98bcbb84e3d33c823705c948b4db96545bf282747a&amp;token=1390438349&amp;lang=zh_CN#rd
一：资料
1.1复杂数据回归（混合效应）模型的选择策略
1）科学研究中数据及其复杂性
2）回归分析历史、理论基础
3）回归分析基本假设和常见问题
4）复杂数据回归模型选择策略
1.2 结构方程模型（SEM）生态领域应用
1)SEM的定义、生态学领域应用及历史回顾
2)SEM的基本结构
3)SEM的估计方法
4)SEM的路径规则
5)SEM路径参数的含义
6)SEM分析样本量及模型可识别规则
7)SEM构建基本流程
1.3如何通过数据探索避免常见统计问题
1)数据缺失（missing value）
2)零值（zero trouble）
3)奇异值/离群值（outliers）
4)异质性（heterogeneity）
5)数据分布正态性（normality）
6)响应变量与预测变量间关系（relationships）
7)交互作用项（interaction）
8)共线性（collinearity）
9)样本独立性（independence）
二：R和Rstudio入门和绘图（含ggplot）
1）R及Rstudio：背景、软件及程序包安装、基本设置等
2）R语言基本操作，包括向量、矩阵、数据框及数据列表等生成和数据提取等
3）R语言数据文件读取、整理、结果存储等
4）R语言基础绘图（含ggplot）：基本绘图、排版、发表质量绘图输出存储
三：R语言数据清洗-tidyverse包应用
1）tidyvese：tidyr、dplyr、readr、%&gt;%等
2）文件操作：不同格式文件读取、多文件同时读取等
3）数据筛选：行筛选、列筛选、条件筛选（字符操作）等
4）数据生成：数据合并、数据拆分、新数据生成（字符操作）等
5）长宽数据转换、空值（NA）等填充及删除、分组、排序及汇总等
四：贝叶斯回归模型-回归、方差及协防差分析1）贝叶斯统计
2）贝叶斯回归分析建模、模型诊断、交叉验证、预测和绘图
3）贝叶斯回归分析多预测变量：回归、方差、协方差及交互作用
4）贝叶斯回归模型的过度拟合、共线性、分类变量等
五：贝叶斯混合效应模型-数据分层和嵌套
1）混合效应模型基本原理
2）贝叶斯效混合应模型建模步骤及实现
3）贝叶斯的预测和模型诊断
4）贝叶斯混合效应模型的多重比较
5）贝叶斯混合效应模型的方差分解
六：贝叶斯计数数据分析
1）贝叶斯0，1数据分析：二项分布及伯努利分布
2）贝叶斯泊松分布数据分析
3）贝叶斯过度离散数据分析
4）贝叶斯零膨胀数据分析
5）贝叶斯截断数据分析
七：贝叶斯相关数据分析：时间、空间、系统发育相关数据
1）贝叶斯回归模型方差异质性问题及解决途径
2）贝叶斯时间自相关分析：线性及混合效应模型及时间自相关+方差异质性
3）贝叶斯空间自相关分析：空间距离矩阵、空间邻接关系及矩阵
4）贝叶斯系统发育相关分
八：贝叶斯非线性关系数据分析：广义可加（混合）模型（BGAM/BGAMM）和非线性（混合）（BNLM/BNLMM）模型
1）“线性”回归的含义及非线性关系的判定
2）贝叶斯广义可加（混合效应）（GAM/GAMM）模型
3）贝叶斯非线性（混合效应）（NLM/NLMM）模型
九：贝叶斯结构方程模型（BSEM）
(1)R语言贝叶斯SEM实现程序包blavaan和brms
(2)气候及生态位重叠程度对田鼠物种丰富度影响：模型比较、直接和间接效应计算（blavaan&amp;brms）
(3)火烧后对植被恢复影响因素-模型拟合、模型比较和评估（brms）
(4)生物地理历史因素对北半球森林的初级生产力的影响（brms）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdeb46b04ef8fd350688553b5ca29a94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de8817f35d62a3176165bcbd15dc93f6/" rel="bookmark">
			element plus el-select修改后缀图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 element plus 提供的api 默认为：
修改后为：
方法：
&lt;el-select v-model="value" placeholder="Select" size="large" style="width: 120px;" :teleported="false" :suffix-icon="CaretBottom"&gt; &lt;el-option label="2022年" value="2022" /&gt; &lt;el-option label="2023年" value="2023" /&gt; &lt;el-option label="2024年" value="2024" /&gt; &lt;/el-select&gt; import { CaretBottom } from '@element-plus/icons-vue' 使用element plus自带的组件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6f7e8f1df1c282ff4afffb7c57dcf17/" rel="bookmark">
			Kotlin 和 Java区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kotlin 和 Java 是两种主要用于 Android 开发的编程语言，它们之间有一些关键的区别：
1. 语法简洁性：
Kotlin：具有更简洁的语法，减少了冗余代码。例如，Kotlin 支持类型推断，避免了大量的样板代码。它还引入了扩展函数、数据类等功能来简化代码。
Java：语法相对冗长，需要更多的样板代码。Java 在设计上比较传统，更新慢。
2. 空指针安全：
Kotlin：通过内置的空安全机制来防止空指针异常（`NullPointerException`）。Kotlin 的类型系统区分了可为空和不可为空的类型。
Java：没有内建的空安全机制，开发者需要手动进行空值检查，容易导致空指针异常。
3. 扩展函数：
Kotlin：支持扩展函数，可以向已有的类添加新的功能而无需修改原有代码。
Java：不支持扩展函数，需要通过继承或者其他设计模式来实现类似功能。
4. 数据类：
Kotlin：提供了数据类（`data class`），用于简化 POJO（Plain Old Java Object）类的创建，自动生成常用方法如 `equals`、`hashCode` 和 `toString`。
Java：没有内建的数据类，需要手动实现这些方法或使用工具生成。
5. 协程：
Kotlin：支持协程（`Coroutines`）来处理异步编程和并发任务，提供了更高效、更易读的异步代码处理方式。
Java：使用传统的线程和回调处理异步编程，代码通常较为复杂且难以维护。
6. 编译器和互操作性：
Kotlin：完全兼容 Java，Kotlin 代码可以与 Java 代码无缝集成。Kotlin 编译器将代码编译为 JVM 字节码，可以运行在 Java 虚拟机上。
Java：也可以与 Kotlin 代码兼容，但 Kotlin 的一些新特性在 Java 中没有对应的实现。
7. 默认参数和命名参数：
Kotlin：支持函数的默认参数和命名参数，可以使函数调用更加灵活和简洁。
Java：不支持默认参数和命名参数，需要通过重载函数来实现类似功能。
Kotlin 的设计目的是提高开发效率和代码安全性，而 Java 则更为成熟和广泛使用。两者各有优缺点，选择使用哪一种语言通常取决于项目需求和个人喜好。
下面是一个简单的 Kotlin 示例，演示如何实现一个基本的增、删、改、查（CRUD）操作。这个例子使用一个简单的 Person 数据类和一个管理 Person 对象的 PersonRepository 类。为了简化示例，我们将数据保存在内存中。 kotlin // 数据类 data class Person(val id: Int, val name: String, val age: Int) // 仓库类 class PersonRepository { private val people = mutableListOf&lt;Person&gt;() private var nextId = 1 // 创建 fun create(name: String, age: Int): Person { val person = Person(nextId++, name, age) people.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6f7e8f1df1c282ff4afffb7c57dcf17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd58f51ec71d52cbb5db1ceb08d4df7a/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(072)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
291、pandas.Series.dt.round函数
291-1、语法
291-2、参数
291-3、功能
291-4、返回值
291-5、说明
291-6、用法
291-6-1、数据准备
291-6-2、代码示例
291-6-3、结果输出
292、pandas.Series.dt.floor函数
292-1、语法
292-2、参数
292-3、功能
292-4、返回值
292-5、说明
292-6、用法
292-6-1、数据准备
292-6-2、代码示例
292-6-3、结果输出
293、pandas.Series.dt.ceil函数
293-1、语法
293-2、参数
293-3、功能
293-4、返回值
293-5、说明
293-6、用法
293-6-1、数据准备
293-6-2、代码示例
293-6-3、结果输出
294、pandas.Series.dt.month_name方法
294-1、语法
294-2、参数
294-3、功能
294-4、返回值
294-5、说明
294-6、用法
294-6-1、数据准备
294-6-2、代码示例
294-6-3、结果输出
295、pandas.Series.dt.day_name方法
295-1、语法
295-2、参数
295-3、功能
295-4、返回值
295-5、说明
295-6、用法
295-6-1、数据准备
295-6-2、代码示例
295-6-3、结果输出
二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 291、pandas.Series.dt.round函数 291-1、语法 # 291、pandas.Series.dt.round函数 pandas.Series.dt.round(*args, **kwargs) Perform round operation on the data to the specified freq.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd58f51ec71d52cbb5db1ceb08d4df7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89b352bcdd9335edac2d4a274910b783/" rel="bookmark">
			iOS 18（macOS 15）Vision 中新增的任意图片智能评分功能试玩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 在 WWDC 24 中库克“大厨”除了为 iOS 18 等平台重磅新增了 Apple Intelligence 以外，苹果也利用愈发成熟的机器学习引擎扩展了诸多内置框架，其中就包括 Vision。
想用本机人工智能自动为我们心仪的图片打一个“观赏分”吗？“如意如意，就如你心意吧”。
在本篇博文中，您将学到如下内容： 概述1. Vision 框架简介2. 图片“令人愉悦”的美学属性3. 拒绝临渊羡鱼，撸起袖子上手实验！总结 Apple Intelligence 的大幕正徐徐拉开，那小伙伴们还等什么呢？
让我们先来品尝点 AI 甜点吧！Let’s go！！！😉
1. Vision 框架简介 Vision 是苹果在 iOS 11（macOS 10.13）引入的一款将计算机视觉算法应用在图片和视频上以便完成各种任务的框架。
Vision 框架结合了机器学习（ML，Machine Learning）技术和 Swift 新并发特性，可以出色的在应用程序中执行计算机视觉任务。
Vision 特别擅长下面几种任务：
跟踪人和动物的身体姿势或对象的轨迹；识别 18 种不同语言的文本；检测人脸和人脸标志，如眼睛、鼻子和嘴巴等；执行手动跟踪以启用新设备交互；计算图片的美学评分以确定它们到底有多么让人“流连忘返”； 要开始使用 Vision 框架，一般的流程是：
为对应的分析类型创建一个请求（有 25 个以上的请求可供选择），每个请求都符合 VisionRequest 协议；执行请求以获得观察结果或观察结果数组，以及请求的详细分析信息；将定制的 Core ML 模型用于分类或对象检测等任务； 从 iOS 18（macOS 15）开始，苹果利用最新的 Swift 6 编译器大大简化了 Vision 的调用方式并且开始全面支持 Swift 现代化并发模型。
接下来，我们就从 Vision 众多 Request 中挑一个来看看它到底有多么强大、使用起来又是多么的方便吧！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89b352bcdd9335edac2d4a274910b783/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5151a7070d4fd4f00846e7d3b52ae495/" rel="bookmark">
			Huatuo Llama Med Chinese 教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Huatuo Llama Med Chinese 教程 Huatuo-Llama-Med-ChineseRepo for BenTsao [original name: HuaTuo (华驼)], Instruction-tuning Large Language Models with Chinese Medical Knowledge. 本草（原名：华驼）模型仓库，基于中文医学知识的大语言模型指令微调项目地址:https://gitcode.com/gh_mirrors/hu/Huatuo-Llama-Med-Chinese 1. 项目目录结构及介绍 以下是对Huatuo-Llama-Med-Chinese项目的基本目录结构及其作用的概述：
Huatuo-Llama-Med-Chinese/ ├── README.md # 项目简介和指南 ├── config.yml # 默认配置文件 ├── requirements.txt # 依赖项列表 ├── src/ │ ├── model.py # 模型定义和加载 │ ├── tokenizer.py # 词法分析器 │ ├── trainer.py # 训练脚本 │ └── inference.py # 推断脚本 └── scripts/ ├── train.sh # 训练脚本bash文件 └── infer.sh # 推断脚本bash文件 README.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5151a7070d4fd4f00846e7d3b52ae495/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b6d1dad91a2afca99f3567c38a7bd1a/" rel="bookmark">
			开源AI智能名片商城系统：重塑大零售生态的创新实践与深度分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：在数字经济浪潮的推动下，零售行业正经历着前所未有的变革。传统零售模式面临消费者需求多样化、市场竞争加剧等多重挑战，而开源AI智能名片商城系统的出现，为零售行业的转型升级提供了新的思路和技术支持。本文深入探讨了开源AI智能名片商城系统的核心功能、技术架构、应用实践及其对大零售生态的重塑作用，旨在为该领域的研究与实践提供参考。
一、引言 随着人工智能、大数据、云计算等技术的快速发展，零售行业正逐步向智能化、个性化、全渠道化方向演进。在这一背景下，开源AI智能名片商城系统凭借其灵活性、可扩展性和智能化特性，成为推动零售行业转型升级的重要力量。该系统通过整合线上线下资源，优化消费者体验，提升运营效率，为零售企业提供了全新的发展路径。
二、开源AI智能名片商城系统的核心功能与技术架构 （一）核心功能
1.智能推荐系统：基于深度学习等AI算法，该系统能够分析消费者的历史行为、偏好等数据，实现个性化商品推荐。通过精准匹配消费者需求与商品信息，提高购物转化率，增强用户粘性。
2.全渠道融合：支持线上线下无缝对接，实现商品信息、库存状态、订单处理等多渠道同步。消费者可以在任何时间、任何地点享受一致且便捷的购物体验，提升品牌满意度和忠诚度。
3.智能客服与售后服务：集成AI客服系统，提供24小时不间断的在线咨询服务。通过自然语言处理技术，智能客服能够准确理解消费者需求，提供快速有效的解决方案。同时，系统还能自动收集用户反馈，为产品改进和服务优化提供数据支持。
4.大数据分析与决策支持：利用大数据技术，对海量消费者行为数据进行深度挖掘和分析，揭示市场趋势和消费者偏好。为企业管理层提供科学的数据支持，帮助制定更加精准的市场策略和经营决策。
（二）技术架构
开源AI智能名片商城系统采用微服务架构，将系统拆分为多个独立的服务模块，每个模块负责特定的业务功能。这种架构方式不仅提高了系统的可扩展性和可维护性，还便于根据业务需求进行灵活调整和优化。同时，系统采用开源技术栈，降低了开发成本和门槛，促进了技术创新和生态发展。
三、应用实践：开源AI智能名片商城系统在大零售中的转型案例 （一）案例背景
某传统零售企业长期面临市场饱和、消费者需求多样化等挑战，传统营销手段难以有效触达目标客群，导致销售业绩下滑。为寻求突破，该企业决定引入开源AI智能名片商城系统进行转型升级。
（二）实施过程
1.需求分析：首先，企业进行了全面的市场调研和需求分析，明确了系统建设的目标和需求。包括智能推荐、全渠道融合、智能客服、大数据分析等功能模块。
2.系统选型与定制开发：基于开源技术栈，企业选择了适合自身业务需求的AI智能名片商城系统框架，并进行了定制开发。通过集成第三方API、优化算法模型等方式，实现了系统功能的个性化定制。
3.数据迁移与整合：将原有系统的数据迁移至新系统，并进行数据清洗和整合。确保新系统能够准确反映企业业务现状，为后续的数据分析和决策支持提供可靠的数据基础。
4.培训与上线：对企业员工进行系统操作培训，确保他们能够熟练掌握新系统的使用方法。同时，制定详细的上线计划和应急预案，确保系统平稳上线并顺利运行。
（三）成效分析
1.提升用户体验：通过智能推荐系统和全渠道融合功能，消费者能够享受到更加个性化、便捷的购物体验。购物转化率显著提升，用户满意度和忠诚度也随之提高。
2.优化运营效率：智能客服系统减轻了人工客服的工作压力，提高了客服响应速度和问题解决效率。同时，大数据分析功能为企业管理层提供了科学的数据支持，帮助制定更加精准的市场策略和经营决策。
3.促进业务增长：通过数字化转型和智能化升级，企业成功吸引了更多年轻消费者和高端客户群体的关注。销售业绩稳步增长，市场份额逐步扩大。
四、开源AI智能名片商城系统对大零售生态的重塑作用 （一）推动零售模式创新
开源AI智能名片商城系统的出现打破了传统零售模式的界限和壁垒，推动了零售模式的创新和发展。通过整合线上线下资源、优化消费者体验、提升运营效率等方式，该系统为零售企业提供了全新的发展路径和商业模式。
（二）促进产业链协同发展
该系统不仅关注零售企业自身的数字化转型和智能化升级，还注重与产业链上下游企业的协同发展。通过数据共享、资源整合等方式，促进产业链各环节之间的紧密合作和互利共赢。这有助于形成更加完善、高效的零售生态系统。
（三）加速行业变革与升级
开源AI智能名片商城系统的广泛应用将加速零售行业的变革与升级。随着技术的不断进步和应用场景的持续拓展，该系统将逐渐渗透到零售行业的各个领域和环节。这将推动整个行业向更加智能化、个性化、全渠道化的方向发展，
（四）引领技术创新潮流
开源AI智能名片商城系统作为技术创新的先锋，不断推动着零售行业技术边界的拓展。该系统集成了最前沿的人工智能、大数据、云计算等技术，为零售企业提供了强大的技术支持和动力。通过不断优化算法模型、提升数据处理能力、拓展应用场景等方式，该系统将引领零售行业技术创新潮流，推动整个行业的技术进步和升级。
（五）促进零售业态多元化
开源AI智能名片商城系统的应用不仅限于传统零售业，还逐步渗透到新零售、社交电商、无人零售等新兴业态中。该系统通过提供个性化推荐、智能客服、大数据分析等功能，帮助新兴业态更好地满足消费者需求，提升运营效率，降低运营成本。同时，通过与其他新兴技术的融合应用，如物联网、区块链等，该系统将进一步促进零售业态的多元化发展，为消费者提供更加丰富多样的购物体验。
（六）深化消费者洞察与关系管理
在数字经济时代，消费者成为零售行业的核心资源。开源AI智能名片商城系统通过深度挖掘消费者行为数据，实现精准的用户画像构建和消费者洞察。这有助于零售企业更好地理解消费者需求、预测消费趋势，从而制定更加精准的市场策略和产品规划。同时，该系统还提供了智能化的客户关系管理工具，帮助零售企业建立长期稳定的客户关系，提升客户忠诚度和复购率。
（七）强化数据驱动决策能力
大数据是数字经济时代的重要资源，也是零售企业实现智能化决策的关键。开源AI智能名片商城系统通过整合线上线下数据资源，构建全面的数据分析体系，为企业管理层提供科学的数据支持和决策依据。通过实时监测市场动态、分析消费者行为、评估营销活动效果等方式，该系统帮助企业管理层快速响应市场变化，做出更加精准的决策。这种数据驱动的决策模式将极大地提升零售企业的市场竞争力和运营效率。
（八）面临的挑战与对策
尽管开源AI智能名片商城系统为零售行业的转型升级带来了诸多机遇和优势，但在实际应用过程中仍面临一些挑战。例如，数据安全与隐私保护问题、技术门槛与人才短缺问题、标准化与规范化问题等。针对这些挑战，可以采取以下对策：
1.加强数据安全与隐私保护：建立健全的数据安全管理体系和隐私保护机制，确保消费者数据的安全性和合法性。同时，加强数据加密、访问控制等技术手段的应用，防止数据泄露和非法使用。
2.降低技术门槛与培养专业人才：通过提供开源技术文档、培训教程等资源，降低技术门槛，吸引更多企业和开发者参与系统建设和应用。同时，加强与高校、研究机构等的合作，培养具备跨学科背景的专业人才，为系统的发展提供人才保障。
3.推动标准化与规范化发展：积极参与制定相关标准和规范，推动系统的标准化和规范化发展。通过统一的数据格式、接口协议等标准，促进不同系统之间的互联互通和数据共享。同时，加强行业自律和监管力度，确保系统的健康有序发展。
五、结论与展望 开源AI智能名片商城系统作为推动零售行业转型升级的重要力量，正逐步改变着传统零售的面貌和格局。通过智能推荐、全渠道融合、智能客服、大数据分析等功能模块的集成应用，该系统为零售企业提供了全新的发展路径和商业模式。未来，随着技术的不断进步和应用场景的持续拓展，开源AI智能名片商城系统将在零售行业中发挥更加重要的作用。我们期待看到更多创新的应用案例和成功的实践经验涌现出来，共同推动零售行业的繁荣与发展。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30cd1d99da1a27b7af06cd6d2591da78/" rel="bookmark">
			FLUX.1 实测，堪比 Midjourney 的开源 AI 绘画模型，无需本地显卡，带你免费实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要列举 AI 绘画开源界的几个关键贡献，一定少不了 Stable Diffusion。
还记否前不久刚推出的 Stable Diffusion 3？
其背后的团队 Stability AI，真的是一波三折，其核心成员出走，成立了一个新公司：Black Forest Labs - 黑暗森林。
这不，刚刚开源了一款 AI 绘画模型，直接踢馆老东家，其生成效果，完全可以媲美闭源的 Midjourney。
今日分享，就带大家来体验一番，并在本地部署起来。
之前我的 AI 绘画，都是来自本地部署的 sd-webui。终于，我的 Stable Diffusion 2 该下线 - 光荣退休了？
No！No！No！
尽管 Flux.1 的表现可圈可点，不过要说能完全替代 sd，至少现阶段，还不至于。
我们先来实测体验一番~
目录 1. Flux.1 简介2. 在线体验3. 本地部署3.1 模型下载地址3.2 ModelScope 实战Step1：下载 ComfyUIStep2：下载模型Step3：启动 ComfyUIStep4：cloudflared 安装和使用Step5：愉快玩耍 写在最后 1. Flux.1 简介 FLUX.1 AI 号称的优势有:
• 卓越的视觉质量: 生成具有出色细节和清晰度的图像。
• 精确的提示词遵循: 准确地将文本提示转化为图片，一次生成，无需抽卡。
• 多样化的风格: 支持广泛的艺术风格。
• 复杂场景生成: 创建精细详尽的场景。
真的有吹的那么神么？我们来实测体验一番👇
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30cd1d99da1a27b7af06cd6d2591da78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6299a8f50adc86312d72db33cdc0f6a/" rel="bookmark">
			SpringMVC 的 拦截器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring MVC 提供了一套拦截器（Interceptor）机制，主要用于处理 Web 请求到达控制器之前或响应离开控制器之后执行一些操作。拦截器可以用于执行预处理（如验证用户身份）和后处理（如清理资源或修改响应）。拦截器可以用来执行一系列的任务，如身份验证、权限检查、请求/响应处理、日志记录等。
1.Handler 拦截器 Handler 拦截器是 Spring MVC 中最常见的拦截器类型。 Handler 拦截器实现 HandlerInterceptor 接口。
该接口定义了三个方法：
preHandle:
方法签名: boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;用途: 在控制器方法调用之前执行。返回值: 如果返回 true，则控制器方法将被调用；如果返回 false，则控制器方法不会被调用，并且后续的拦截器也不会被调用。 postHandle:
方法签名: void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception;用途: 在控制器方法调用之后执行，但在视图渲染之前。参数: request: 当前请求。response: 当前响应。handler: 被调用的控制器实例。modelAndView: 控制器方法返回的模型和视图。 afterCompletion:
方法签名: void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception;用途: 在整个请求完成后执行，无论是否出现异常。参数: request: 当前请求。response: 当前响应。handler: 被调用的控制器实例。ex: 如果在请求处理过程中出现了异常，则此参数为异常对象；否则为 null。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6299a8f50adc86312d72db33cdc0f6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e546e7084d350bb5dff59fbffafdd65/" rel="bookmark">
			DataX-Web UI 项目指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DataX-Web UI 项目指南 datax-web-uiDataX Web UI项目地址:https://gitcode.com/gh_mirrors/da/datax-web-ui 1、项目的目录结构及介绍 当你克隆或下载 datax-web-ui 仓库后, 你会看到如下的主要目录和文件结构:
datax-web-ui/ ├── src/ │ ├── main/ │ │ ├── java/ │ │ │ └── com/ │ │ │ └── weiyeye/ │ │ │ └── dataxwebui/ │ │ │ └── controllers/ │ │ │ └── DataXController.java │ │ ├── resources/ │ │ │ └── application.properties │ │ └── webapp/ │ │ └── index.html │ └── test/ │ └── java/ ├── .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e546e7084d350bb5dff59fbffafdd65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c4ae056cd7589764f8826e99381aaa0/" rel="bookmark">
			k8s 四种Service类型(ClusterIP、NodePort、LoadBalancer、ExternalName)详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🐇明明跟你说过：个人主页
🏅个人专栏：《Kubernetes航线图：从船长到K8s掌舵者》 🏅
🔖行路有良友，便是天堂🔖
目录
一、引言
1、k8s概述
2、Service在Kubernetes中的作用
二、ClusterIP类型
1、ClusterIP 类型的特点和用途
2、ClusterIP 的工作机制
3、创建示例
4、ClusterIP 使用场景 三、NodePort类型
1、NodePort 类型的特点和用途
2、NodePort 的工作机制
3、创建示例
4、NodePort 使用场景
5、注意事项
四、LoadBalancer类型
1、LoadBalancer 类型的特点和用途
2、LoadBalancer 的工作机制
3、创建示例
4、使用场景
5、注意事项
五、ExternalName类型
1、ExternalName 类型的特点和用途
2、ExternalName 的工作机制
3、创建示例
4、使用场景
5、注意事项
一、引言 1、k8s概述 Kubernetes（简称K8s）是一个开源的容器编排平台，用于自动化应用程序的部署、扩展和管理。它最初由谷歌开发，并在2014年捐赠给云原生计算基金会（CNCF）。Kubernetes为容器化应用提供了一个灵活、可扩展和高效的管理平台。
2、Service在Kubernetes中的作用 在 Kubernetes 中，Service 是一种抽象方式，用于定义一组逻辑上的 Pod 以及访问这些 Pod 的策略。Service 解决了 Pod 的生命周期管理和通信问题，提供了稳定的网络端点和负载均衡机制，确保应用程序的高可用性和可扩展性。
主要作用
1. 稳定的访问入口：
每个 Pod 都有自己的 IP 地址，但是这些地址是动态分配的，当 Pod 被删除或重新创建时，IP 地址会发生变化。Service 为一组 Pod 提供一个稳定的 IP 地址和 DNS 名称，使得应用程序可以通过固定的端点进行访问。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c4ae056cd7589764f8826e99381aaa0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bde9600e0587c224a0e21e15d10e710/" rel="bookmark">
			Android沉浸式状态栏库ImmersionBar使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android沉浸式状态栏库ImmersionBar使用教程 ImmersionBarandroid 4.4以上沉浸式状态栏和沉浸式导航栏管理，适配横竖屏切换、刘海屏、软键盘弹出等问题，可以修改状态栏字体颜色和导航栏图标颜色，以及不可修改字体颜色手机的适配，适用于Activity、Fragment、DialogFragment、Dialog，PopupWindow，一句代码轻松实现，以及对bar的其他设置，详见README。简书请参考：http://www.jianshu.com/p/2a884e211a62项目地址:https://gitcode.com/gh_mirrors/im/ImmersionBar 1. 项目介绍 ImmersionBar 是由geyifeng开发的一款Android库，用于简化状态栏和导航栏的沉浸式设计。它兼容Android 4.4及以上版本，支持横竖屏切换、刘海屏、软键盘弹出等场景，并允许开发者定制状态栏和导航栏的颜色、透明度等样式。
2. 项目快速启动 首先，在你的build.gradle文件中添加ImmersionBar的依赖：
dependencies { implementation 'com.gyf.immersionbar:immersionbar:3.2.2' } 然后在需要沉浸式状态栏的Activity中初始化ImmersionBar：
import com.gyf.immersionbar.ImmersionBar; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ImmersionBar.with(this) .transparentStatusBar() .init(); } 这段代码会让状态栏变得透明。如果你想设置特定颜色，可以使用statusBarColor()函数：
.statusBarColor(R.color.myStatusBarColor) 别忘了在onDestroy()中释放资源：
@Override protected void onDestroy() { super.onDestroy(); ImmersionBar.destroy(this); } 3. 应用案例和最佳实践 示例1：全屏模式 如果你想要实现全屏模式并隐藏导航栏，可以这样配置：
ImmersionBar.with(this) .fullScreen(true) .navigationBarColor(Color.TRANSPARENT) .init(); 示例2：横竖屏切换保持状态 在横竖屏切换时，确保onConfigurationChanged()里重新初始化ImmersionBar：
@Override public void onConfigurationChanged(Configuration newConfig) { super.onConfigurationChanged(newConfig); ImmersionBar.with(this).init(); } 最佳实践 对于不同的Activity和Fragment，推荐使用各自独立的ImmersionBar实例。当使用DialogFragment或Dialog时，也需要单独初始化ImmersionBar。 4. 典型生态项目 虽然官方仓库没有明确列出典型的生态项目，但鉴于该项目在GitHub上有较高的star数量和活跃的更新记录，我们可以推断它被广泛应用于许多Android应用中，包括但不限于个人项目、开源App和商业产品。
如果你想要看到实际应用例子，可以在GitHub上的相关issue和pull requests中找到开发者们集成ImmersionBar的实际代码片段，或者搜索网络上的Android应用教程，很多都可能包含了使用ImmersionBar的示例。
通过以上步骤，你应该能够快速地在你的Android项目中集成并使用ImmersionBar来实现沉浸式状态栏和导航栏的效果。更多详细的API和功能，建议参考项目文档和源码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bde9600e0587c224a0e21e15d10e710/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e02456a1aaf818c07e2d3a8e711bb3f/" rel="bookmark">
			【C&#43;&#43;】初识面向对象：类与对象详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++语法相关知识点可以通过点击以下链接进行学习一起加油！命名空间缺省参数与函数重载C++相关特性 本章将介绍C++中一个重要的概念——类。通过类，我们可以类中定义成员变量和成员函数，实现模块化封装，从而构建更加抽象和复杂的工程。
🌈个人主页：是店小二呀
🌈C语言笔记专栏：C语言笔记
🌈C++笔记专栏： C++笔记
🌈初阶数据结构笔记专栏： 初阶数据结构笔记
🌈Linux笔记专栏： Linux笔记
🌈喜欢的诗句:无人扶我青云志 我自踏雪至山巅 文章目录 一、面向过程与面向对象初步认识二、类的引入2.1 定义概念2.2 类的定义2.3 成员变量命令规则 三、类的访问限定符及封装3.1 访问限定符3.1.1 class与struct区别 3.2 封装 四、类的作用域(类域)五、类的实例化六、类对象模型6.1 计算类对象的大小6.2 类对象的存储方式猜测 七、this指针7.1 this指针的引入7.2 this指针的特性 八、面试题 一、面向过程与面向对象初步认识 C语言是面向过程的，关注的是过程，分析出求解问题的步骤，通过函数调用逐步解决问题C++是基于面向对象的，关注的是对象，将一件事情拆分成不同的对象，依靠对象之间的交互完成
二、类的引入 2.1 定义概念 定义是编程中的一项基础操作，涉及到为特定数据分配到一个名称和存储位置。不能通过是否赋值去判断是否存在定义，而是通过是否为其开辟空间。
C语言结构体中只能定义变量struct S s1 ={"Alice", c}； 在C++中结构体内不仅可以定义变量，也可也定义函数。现在以C++方式实现 ，struct可以定义变量及其函数，但是更喜欢使用class代替struct(类替代结构体)
struct Stack { void Init(size_tt capacity) { //一系列操作 } new_capacity=capacity; size=10; }; 2.2 类的定义 class className { //类体:一般由成员函数和成员变量组成 };//同结构体一般，需要添加分号 class为定义类的关键字，ClassName为类的名字，{}中为类的主体，注意类定义结束时后面分号不能省略。
类体中内容称为类的成员，其中类的成员:1.类中的变量称为类的属性或成员变量2.类中的函称为类的方法或者成员函数
类的两种定义方式:
声明和定义全部放在类体中，需注意：成员函数如果在类中定义，编译器可能会将其当成内联函数处理。 类声明放在.h文件中，成员函数定义放在.cpp文件中，注意：成员函数名前需要加类名:: 一般情况下，更加期望采用第二种方式。为了方便演示将采用第一种，大家在后序工作中尽量使用第二种方式，体现了面对对象编程的封装特性，提高代码的可维护性。
2.3 成员变量命令规则 由于在使用类过程中，难免会遇到成员变量与函数参数名称相同导致混淆。比如:这里如何去区分year属于成员变量还是函数参数呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e02456a1aaf818c07e2d3a8e711bb3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3555138822b2add8c8bb806d4f1ad01f/" rel="bookmark">
			代码规范 —— 数据库规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优质博文：IT-BLOG-CN
一、建表规范 【1】表达是与否概率的字段，必须使用is_xxx的方式命令，数据类型是tinyint（1表示是，0表示否）
正例：表达逻辑删除的字段名is_active，0表示删除，1表示未删除。
【2】表名、字段名必须使用小写字母或数字，禁止数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。
MySQL在Windows下不区分大小写，但在Linux下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。
正例：aliyun_admin，rdc_config，level3_name；
反例：AliyunAdmin，rdcConfig，level_3_name；
【3】表名不使用复数名词：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于DO类名也是单数形式，符合表达习惯。
正例：store；
反例：stores；
【4】禁用保留字，如desc、range、match、delayed等，请参考MySQL官方保留字。
【5】主键索引名为pk_字段名；唯一索引名为uk_字段名；普通索引名则为idx_字段名。
主键索引自动生成，名：PRIMARY
正例：uk_storeIdidx_storeId_vehicldId；
【6】小数类型为decimal，禁止使用float和double。
【7】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。
【8】varchar是可变长字符串，不预先分配存储空间，长度不要超过5000，如果存储长度大于此值，定义字段类型为text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。
由于公司规范不允许使用text,推荐超过5000使用多条记录拼接。
【9】表必备四字段：id, (BigInt)datachange_createtime,（Timestamp）catachange_lasttime, （Timestamp）is_active (TinyInt)。
【10】表的命名最好是遵循“业务名称_表的作用”：比如订单相关:表全部以订单开头。
【11】库名与应用名称尽量一致。
【12】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：1.不是频繁修改的字段。2.不是唯一索引的字段。3.不是varchar超长字段，更不能是text字段。
【13】单表行数超过500万行或者单表容量超过2GB，才推荐进行分库分表。
如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表
【14】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。
【15】如果存储的字符串长度几乎相等，使用char定长字符串类型。
二、索引规约 【1】业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。不要因为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。
【2】超过二个表禁止join。需要join的字段，数据类型保持绝对一致；多表关联查询时，保证被关联的字段需要有索引。即使双表join也要注意表索引、SQL性能。
【3】在varchar字段上建立索引时，必须指定索引长度（推荐20），没必要对全字段建立索引，根据实际文本区分度决定索引长度。 索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为20的索引，区分度会高达90%以上，可以使用count(distinct left(列名, 索引长度))/count(*)的区分度来确定。
【4】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。索引文件具有B-Tree的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引.
【5】如果有order by的场景，请注意利用索引的有序性。order by最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort的情况，影响查询性能。
正例：where a=? and b=? order by c;索引：a_b_c。索引如果存在范围查询，那么索引有序性无法利用，如：WHERE a&gt;10 ORDER BY b;索引a_b无法排序。
【6】利用覆盖索引来进行查询操作，避免回表。如果一本书需要知道第11章是什么标题，会翻开第11章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效果，用explain的结果，extra列会出现：using index。
【7】利用延迟关联或者子查询优化超多分页场景：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。
正例：先快速定位需要获取的id段，然后再关联SELECT t1.* FROM 表1 as t1, (select id from 表1 where 条件 LIMIT 100000,20 ) as t2 where t1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3555138822b2add8c8bb806d4f1ad01f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc55627f21bb2c15e69d57b239c23acd/" rel="bookmark">
			Self-study Python Fish-C Note15 P52to53
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数 (part 5) 本节主要讲函数文档、类型注释、内省、高阶函数
函数文档、类型注释、内省 (P52) 函数文档 函数是一种代码封装的方法，对于一个程序来说，函数就是一个结构组件。在函数的外部是不需要关心函数内部的执行细节的，更需要关注的是函数的接口以及执行后的结果。要学会去阅读开发手册和函数文档，以快速的融入一个项目
在 python 中，我们可以使用 help() 函数，快速的查看到一个函数的使用文档：
help(print) Help on built-in function print in module builtins: print(...) print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False) Prints the values to a stream, or to sys.stdout by default. Optional keyword arguments: file: a file-like object (stream); defaults to the current sys.stdout. sep: string inserted between values, default a space. end: string appended after the last value, default a newline.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc55627f21bb2c15e69d57b239c23acd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53cffa878fba9d0034882de20309d93a/" rel="bookmark">
			FPGA面试问题整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 逻辑设计中竞争与冒险概念，如何识别和消除？
竞争：在组合逻辑电路中，信号经过多条路径到达输出端，每条路径经过的逻辑门不同存在时差，在信号变化的瞬间存在先后顺序。这种现象叫竞争。
冒险：由于竞争而引起电路输出信号中出现了非预期信号，产生瞬间错误的现象称为冒险。表现为输出端出现了原设计中没有的窄脉冲，即毛刺。
常见的逻辑代数法判断是否有竞争冒险存在：只要输出逻辑表达式中含有某个信号的原变量A和反变量/A之间的“与”或者“或”关系，且A和/A经过不同的传播路径，则存在竞争。解决办法一是修改逻辑表达式避免以上情况，二是采样时序逻辑，仅在时钟边沿采样，三是在芯片外部并联电容消除窄脉冲。
2. 亚稳态的产生原因及消除方式？
在异步系统中，寄存器建立保持时间不满足引起亚稳态。典型的场合为数据跨时钟域传输和异步复位电路。在异步传输过程中，通过单比特信号双寄存器同步，多比特信号FIFO桥接的方式消除亚稳态（实际上异步信号同步方式即为异步传输过程中亚稳态的消除方式）。通过异步复位，同步释放可消除异步复位引起的亚稳态。
3. FPGA中有哪些资源？
可编程输入/输出单元 (I/O 单元)： 用于与其他设备和系统进行通信和数据交换。支持多种电气标准，如LVCMOS, LVDS, PCI Express等。可配置匹配阻抗、上下拉电阻、输出驱动电流等。
可编程逻辑单元： 包括查找表（LUT）和寄存器（Register）。
查找表用于实现组合逻辑功能。寄存器用于实现同步时序逻辑，可以配置为带有同步/异步复位和置位、时钟使能等功能的触发器。
存储资源： 可配置为单端口RAM、双端口RAM、内容地址存储器（CAM）、FIFO等。
有些FPGA还提供更高级的存储资源，例如UltraRAM。
丰富的布线资源： 用于连接FPGA内部的各种资源。包括高速布线、全局布线、局部布线等。
底层嵌入功能单元： 如数字时钟管理模块（DCM）、锁相环（PLL）、延迟锁定环（DLL）等，用于时钟管理和信号同步。
内嵌专用硬核： 包括乘法器、数字信号处理（DSP）模块、微处理器内核等。
4. 为什么触发器要满足建立时间和保持时间？
因为触发器内部数据的形成是需要一定的时间的，如果不满足建立和保持时间，触发器将进入亚稳态，进入亚稳态后触发器的输出将不稳定，在0和1之间变化，这时需要经过一个恢复时间，其输出才能稳定，但稳定后的值并不一定是你的输入值。这就是为什么要用两级触发器来同步异步输入信号。这样做可以防止由于异步输入信号对于本级时钟可能不满足建立保持时间而使本级触发器产生的亚稳态传播到后面逻辑中，导致亚稳态的传播。
5. FPGA设计中，有哪几种功耗？有哪些低功耗设计方法？
有三种功耗：
芯片静态功耗（Chip Static Power）：
这是指FPGA在上电但未配置时的功耗，主要是由晶体管的泄漏电流所消耗的功耗。
设计静态功耗（Design Static Power）：
当FPGA配置完成后，但在设计还未启动时，需要维持I/O的静态电流、时钟管理和其它部分电路的静态功耗。
设计动态功耗（Design Dynamic Power）：
这是在FPGA内设计正常启动后产生的功耗，这部分功耗的多少主要取决于芯片所用电平、FPGA内部逻辑和布线资源的占用情况。
低功耗设计方法：
逻辑优化：
通过高级综合工具优化逻辑，减少逻辑门的数量。
使用多级流水线设计，减少每个阶段的复杂度。
时钟管理：
使用时钟门控技术来关闭不活动模块的时钟信号。
采用动态时钟调整，在满足性能要求的前提下降低时钟频率。
物理布局与布线：
优化布局布线，减少信号传输距离，从而降低布线电容和功耗。
软件辅助：
在FPGA中集成微控制器或软核处理器，通过软件控制硬件行为，实现更精细的功耗管理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/babf08faa144bed7969b52f3ab0405fc/" rel="bookmark">
			C语言：文件处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件处理 一、文件的类型（一）文本文件和二进制文件 （二）程序文件和数据文件数据文件按照二进制储存 二、文件的打开和关闭（一）文件指针（二）文件的打开和关闭1、fopen2、fclose （三）文件的打开方式 三、文件读写函数（一）fgetc（二）fputc（三）fgets（四）fputs（五）fscanf（六）fprintf（七）fwrite（八）fread（九）sscanf（十）sprintf（十一）fseek（十二）ftell（十三）rewind 四、文件缓冲区结束语 一、文件的类型 （一）文本文件和二进制文件 按照文本的组织信息来分，文件可以分成二进制文件和文本文件
（二）程序文件和数据文件 按照文件功能来分，可以分成程序文件和数据文件
数据文件按照二进制储存 二、文件的打开和关闭 （一）文件指针 每个被使用的文件都在内存中开辟了一个相应的文件信息区，用来存放文件的相关信息（如文件的名字，文件状态及文件当前的位置等）。这些信息是保存在一个结构体变量中的。该结构体类型是由系统声明的，取名FILE.
struct _iobuf { char *_ptr; int _cnt; char *_base; int _flag; int _file; int _charbuf; int _bufsiz; char *_tmpfname; }; typedef struct _iobuf FILE; 不同的C编译器的FILE类型包含的内容不完全相同，但是大同小异。
每当打开一个文件的时候，系统会根据文件的情况自动创建一个FILE结构的变量，并填充其中的信息
（二）文件的打开和关闭 1、fopen FILE * fopen ( const char * filename, const char * mode ); 用来打开文件。打开成功的同时，函数会返回一个文件指针类型，相当于文件和指针之间建立联系。
int main() { FILE* pf = fopen("test.txt", "w"); if (pf != NULL) { fputs("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/babf08faa144bed7969b52f3ab0405fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05aea56c465dcf3807d238dc43819d4d/" rel="bookmark">
			性能测试基础概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言👀~ 上一章我们介绍了单元测试Junit的使用，今天我们来讲解一下性能测试的一些基础概念为后面我们进行性能测试做铺垫
什么是性能测试？
性能测试和功能测试有什么区别？
影响一个软件性能因素有哪些？
为什么要进行性能测试？
如何衡量性能好坏？
性能测试常见术语以及性能测试衡量标准（重要）
1.并发用户数
2.响应时间/平均响应时间
3.事务响应时间
4.点击率
5.吞吐量
6.思考时间
7.资源利用率
性能测试分类
1.一般性能测试
2.负载性能测试
3.压力性能测试
4.可靠性测试
性能测试执行流程
如果各位对文章的内容感兴趣的话，请点点小赞，关注一手不迷路，讲解的内容我会搭配我的理解用我自己的话去解释如果有什么问题的话，欢迎各位评论纠正 🤞🤞🤞
个人主页：N_0050-CSDN博客
相关专栏：java SE_N_0050的博客-CSDN博客 java数据结构_N_0050的博客-CSDN博客 java EE_N_0050的博客-CSDN博客
什么是性能测试？ 测试人员借助性能测试工具，模拟系统在不同场景下，对应的性能指标是否符合预期
软件的性能问题：资源泄漏，包括内存泄漏，线程死锁，阻塞等造成系统越来越慢，查询速度慢，或者列表的效率低等
例子：常见的就是在双11和618这种节日或学校网站选课的时候，在这种情况下，对于一些购物网站来说就会出现性能问题，短时间内同时有大量支付和创建订单等操作产生的并发量巨大导致服务器崩了，衡量一个软件性能好不好在这种极端情况下也可以看出
性能测试和功能测试有什么区别？ 功能测试：简单点说就是在不同的场景下，软件只要能够正常运行且各功能正常即可，可以简单的理解为验证产品功能有没有做到
性能测试：简单点说就是在极端情况下，软件是否能够正常运行各项指标是否达到标准（性能需求），可以简单的理解为验证产品有没有做好
在性能测试中，我们测试人员首先要了解哪些业务功能是用户最常使用的，以此来确定性能测试的关键业务功能，更准确的应该是确定性能测试的关键业务要从业务功能的使用评率和功能的计算量，资源的消耗程度来决定，针对关键业务进行测试用例的设计
影响一个软件性能因素有哪些？ 硬件：服务器CPU利用率、内存、CPU核心数等
软件：代码、编程语言等
用户：用户数、用户使用时长、用户访问频率等
为什么要进行性能测试？ 1.获取系统性能的指标，作为性能指标的基准
2.验证系统的性能指标是否达到性能需求
3.发现系统的性能瓶颈，内存泄漏等问题
4.系统正常工作的情况下的最大容量
例子：1可以理解为你的标准在哪，2可以理解为你是否符合男人的标准，3可以理解为你的瓶颈在哪例如你卧推的极限是多少，4可以理解为一个人在正常工作状态下能够接收和处理信息的最大能力
如何衡量性能好坏？ 通过数据来进行展示，借助性能测试工具所监控和收集的各项指标来分析系统的性能
性能测试常见术语以及性能测试衡量标准（重要） 性能测试是一项综合性的工作，致力于暴露性能问题，评估系统性能趋势。性能测试工作实质上是利用测试工具去模拟大量用户操作来验证系统能够承受的负载情况，找出潜在的性能问题分析并解决；找出系统性能变化趋势，为后续的扩展做准备。一般地，它主要是针对系统的性能指标制定性能测试方案，执行测试用例，得出测试结果来验证系统的性能指标是否满足预期值或性能需求
并发：同一时间大量用户的请求，注意要满足同一时间和大量
系统用户数：就是系统的注册用户数
在线用户数：就是成功登录系统的用户数
1.并发用户数 业务层面的并发用户数：同一时间向服务器发送请求的用户数
后端服务器层面的并发用户数：同一时间向服务器发送请求的请求数
2.响应时间/平均响应时间 用户响应时间：在用户角度就是发送请求到接收到响应的这段时间称为用户响应时间，下图中红色圈起来的就是用户响应时间
请求响应时间：就是服务器收到请求到发出响应的这段时间称为请求响应时间，下图中红色圈起来的就是请求响应时间
注意：如果响应时间比较平均，那么平均响应时间就有参考意义，如果波动较大，则没有参考意义影响一个软件响应时间的因素：网络带宽、服务器性能、用户设备、数据库、缓存等
3.事务响应时间 就是指用户发起一个事务请求到系统处理该事务并返回结果给用户所需的全部时间
358定律：每一个程序而言，收到请求并返回响应需要等待的平均时间为3.58毫秒，简单点说就是用户发送一个请求到收到响应在3秒钟内，则用户比较满意，如果系统在5秒内得到应答，则用户能够忍受；如果系统在8秒后得到应答，则用户不能忍受
每秒事务通过数（Transaction Per Second）：TPS 是指每秒系统能够处理的事务数，通常指每秒成功的事务数，它是衡量系统处理能力的重要指标，也可以说是一个衡量系统吞吐量的指标。每秒事务通过数=处理的事务数量/处理事务的时间，每秒事务通过数越高，性能越好
4.点击率 表示每秒用户向web服务器发送的http请求数。注意不是鼠标的一次点击，一次点击可能带有多个http请求。点击率=点击量/时间
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05aea56c465dcf3807d238dc43819d4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0d4129ba1c75b490b0c0392f0b9f24d/" rel="bookmark">
			速盾：cdn缓存的文件是无法被篡改的吧？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CDN（Content Delivery Network）是一种用于提供高效内容分发的网络架构。它通过在全球各地部署服务器，将网站的静态资源缓存在就近的边缘节点上，以提供更快的访问速度和较低的延迟。CDN的缓存机制确实可以提高网站的性能，但并不是完全无法被篡改。
首先，CDN的缓存机制是在边缘节点上进行的，这些节点在全球范围内分布，但与源服务器的同步可能会有一定的延迟。因此，在更新源服务器上的内容后，CDN节点可能需要一些时间来获取最新的内容。在这个时间窗口内，用户可能仍然访问到过期的缓存内容。如果攻击者在此期间篡改源服务器上的内容，那么CDN节点将会缓存被篡改的内容，并将其分发给用户。这种情况下，CDN缓存的文件就遭到了篡改。
其次，虽然CDN本身会采取一些安全措施来保护缓存的文件，如使用HTTPS协议进行加密传输，但它并不能完全消除被篡改的风险。即使使用了HTTPS，攻击者仍然有可能通过某些手段来中间人攻击，劫持用户的请求，并返回被篡改的响应。这样，用户就会接收到攻击者篡改的内容，而不是源服务器上的原始内容。
此外，尽管CDN通常会对文件进行签名或校验和等安全机制，以保证缓存的文件的完整性，但这些机制并不是绝对安全的。在复杂的网络环境中，攻击者可能会找到一些漏洞或利用未经注意的情况来绕过这些校验机制，从而篡改缓存的文件。
总的来说，尽管CDN缓存机制可以提高网站的访问速度和性能，但它并不能完全保证缓存的文件不被篡改。在安全性要求较高的情况下，建议采取其他更加可靠的安全措施，如使用数字签名、加密等来保护文件的完整性和安全性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/173a6aee0a397c4be2687e2fee677661/" rel="bookmark">
			【AI学习】[2024北京智源大会]具身智能：具身智能关键技术研究：操纵、决策、导航
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具身智能关键技术研究：操纵、决策、导航
董 豪 | 北京大学助理教授
依然是边看边做些记录
这张图的重点是在说，我们的大脑，也是不同的部分处理不同的功能。这里面有些功能，比如视觉、听觉理解等功能，LLM已经具备，而有些功能没有具备，这些就是具身智能的重点
这就是具身智能的三个关键研究点。
仿真是方便的数据来源。通过已有的3D数据，合成数据。
通过数据，训练抓取功能。还有目标姿态估计，这样才能放置物体，这也是可以通过仿真获得海量数据进行训练的。
有了抓取和姿态估计，就可以完成很多任务。
灵巧手也可以通过合成数据训练。这里先要回答，灵巧手和二指等有什么区别？区别在于人的手有一个预抓取动作。
具体的训练，通过强化学习。因为这不是一个静态的抓取，是连续的动作
抓取之后，然后是操纵。这里是通过强化学习训练。
探索仿真的边界。通过探索，仿真是有边界的。
然后这里是探索双手的操作。
准备开源的平台：OmniSim
实现仿真到仿真。比如一个开门，不可能在真实环境去开一千个门吧，需要利用仿真
那仿真的边界在哪呢？目前最好的是视觉。
对于一个门，没有把手，即使是人，也需要尝试。这里就是交互式的尝试，这些都需要机器人在真实世界，交互后，才能提升。
我们也希望机器人能在真实世界学习提升，而不是固化了。
这个就是在真实世界里学习。
柔性物体的操作，是比较难的！通过强化学习，一个方法解决多种任务
这是机械臂的操作
这是通过在大淘宝买的东西做的机械臂。虽然误差大，但是通过视觉的闭环，依然可以工作。
如果仿真中没有的物体这么办？通过借助大模型，因为大模型见多识广，可以举一反三。
将仿真的操作能力，注入大模型，最后部署的是大模型。
具体的方式，就是通过问大模型，让大模型告诉如何操作。
然后发现，即使比较差的仿真，加上大模型，也可以比较好的工作。大模型可以做到新类别的泛化。
那接下来，就需要把长长的动作，进行任务分解。
上面这个图，就是大模型把一个任务，分解为一系统API。
接下来，是通过视觉的问题任务，经过数据集、微调环节，解决机器人的视觉问答任务。
任务编排不是瓶颈，大模型都可以实现。难点还是机械臂的操作。
然后是收纳，这个需要机器人自动完成。方法是从网络上获取大量图片，比如获取什么是整洁的样子，通过网上的几千张样例图片，获得分布的知识。
最后是具身导航，这个现在提的不多，但是未来可能有大用处。
物体导航。比如在屋里找，相应的东西。
这个也可以通过多模态的视觉语言大模型完成。
这是另外一个导航任务。视觉语言导航，跟随人的指令
这是一个真实世界部署的大模型，而不是仿真。方法是通过多专家讨论的方式，并不需要训练什么模型。
这是提出的第三种导航范式，需求驱动导航，因为前两种对人并不友好。
这个是把之前的所有导航方式进行集成。前面的三种导航范式可以覆盖所有的各种任务。
最后总结一下具身智能的关键点。过去是通过仿真实现基本的操作和导航技能，包括自监督的学习；现在是通过大模型，解决仿真到真实世界的gap，利用大模型的知识；那接下来，还是要利用真实世界的数据。
备： 下面视频链接的第3个演讲，大约在视频的1小时25分钟开始
https://www.bilibili.com/video/BV1Zx4y147os/?spm_id_from=333.1007.tianma.2-3-6.click&amp;vd_source=986224b0c4e79ec28556778dc7d42405
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/68/">«</a>
	<span class="pagination__item pagination__item--current">69/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/70/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>