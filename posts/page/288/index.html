<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60bc46b66395cdf14700c8914ab48e9d/" rel="bookmark">
			【wiki知识库】06.文档管理页面的添加--前端Vue部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📝个人主页：哈__
期待您的关注 目录
一、🔥今日目标
二、🐻前端Vue模块的改造
BUG修改
1.wangeditor无法展示问题
2.弹窗无法正常关闭问题
2.1 添加admin-doc.vue
2.1.1 点击admin-ebook中的路由跳转到admin-doc
2.2.2 进入到admin-doc中调用初始化查询方法
2.2.3 文档编辑中的一些细节
2.2.4 文档的删除
2.2.5 admin-doc.vue全部代码
2.2 添加DocView.vue
2.3 添加新的路由规则
一、🔥今日目标 上一次带大家把前端的分类管理模块做了出来，我们可以实现网站的分类功能，以及分类的树形结构展示功能。到此为止已经带大家做了电子书管理模块、分类模块，那么只要再把文档管理模块也做出来，我们就可以初步实现电子书这整个一套流程了。我们可以编辑添加电子书，实现分类，并且真正的往电子书的文档模块中添加内容。【wiki知识库】05.分类管理实现--前端Vue模块-CSDN博客
我们今天就要实现下方图片中箭头指向的功能
除此之外，还有主页的展示功能。
二、🐻前端Vue模块的改造 在此之前我要要说一件事情，我在做这个模块的时候出现了问题，一个是我们之后要使用的文本编辑器wangeditor无法正常展示，还有一个是弹窗无法关闭的问题。这里我把解决方法告诉大家。
BUG修改 1.wangeditor无法展示问题 出现这个问题可能是版本的问题，进入到我们的web目录中，打开终端窗口然后输入下方指令。重新安装wangeditor。
npm i wangeditor@4.6.3 --save 2.弹窗无法正常关闭问题 这个问题是wangeditor和vue版本兼容的问题。我们需要修改一下package.json。将vue版本改成下方图中所示，注意前边的符号。
2.1 添加admin-doc.vue 2.1.1 点击admin-ebook中的路由跳转到admin-doc 还记得我当初在admin-ebook.vue中写的一个router吗？在我们点击文档管理跳转到对应的组件的时候，我们是有传一个ebookId进来的，我们这里使用的是路由传参。
2.2.2 进入到admin-doc中调用初始化查询方法 进入到这个页面呢调用了两个方法，一个是editor.create()，用于加载我们的文本编辑器，另外一个方法调用的是handleQuery()方法，向后端发送查询请求。
onMounted(() =&gt; { editor.create(); handleQuery(); }); 这个方法进入的时候，修改了一个变量loading，我们在进行信息查询的时候会给用户一个反馈，告诉用户稍等，我们修改为true之后就会有页面数据加载的效果。
level1变量我们之前也说过，用于保存树形结构的数据。之后呢就会发送一个ajax请求，等我们的数据返回来之后就要把loading改为false了。
至于下边的treeSelectData，在我们修改一个文档的父文档的时候，如果我们要把这个文档作为根文档，也就是一级文档，我们需要把这个文档的父文档设置为无，但是我们的level中存储的是数据库中查出来的数据，没有无这个选项，所以我们新加一个变量来存储level1的结果和无，这样不会影响我们查出来的数据。
const handleQuery = () =&gt; { loading.value = true; // 如果不清空现有数据，则编辑保存重新加载数据后，再点编辑，则列表显示的还是编辑前的数据 level1.value = []; axios.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60bc46b66395cdf14700c8914ab48e9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f99dfc8a85e8007e1c3aecdc54df4160/" rel="bookmark">
			SQL Server中的CTE和临时表优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在SQL Server中，优化查询性能是数据库管理的核心任务之一。使用公用表表达式（CTE）和临时表是两种重要的技术手段。本文将深入探讨CTE如何简化代码，以及临时表如何优化查询性能。通过实例和详尽解释，我们将展示这两种技术在实际应用中的优点和注意事项。
第一部分：公用表表达式（CTE） 公用表表达式（CTE）是SQL Server 2005引入的一项功能。CTE通过将复杂查询分解成多个可读性高的部分，使代码更加简洁明了。CTE主要有两种类型：递归CTE和非递归CTE。
1.1 非递归CTE 非递归CTE主要用于简化查询，提高代码可读性。以下是一个典型的非递归CTE示例：
WITH SalesCTE AS ( SELECT SalesPersonID, SUM(TotalDue) AS TotalSales FROM Sales.SalesOrderHeader GROUP BY SalesPersonID ) SELECT sp.FirstName, sp.LastName, sc.TotalSales FROM SalesCTE sc JOIN Sales.SalesPerson sp ON sc.SalesPersonID = sp.SalesPersonID; 在这个示例中，我们使用CTE将总销售额的计算与人员信息的查询分开，从而提高了代码的清晰度。
1.2 递归CTE 递归CTE用于处理层次结构数据，如组织结构或目录树。以下是一个递归CTE示例：
WITH OrgCTE AS ( SELECT EmployeeID, ManagerID, Title FROM HumanResources.Employee WHERE ManagerID IS NULL UNION ALL SELECT e.EmployeeID, e.ManagerID, e.Title FROM HumanResources.Employee e INNER JOIN OrgCTE o ON e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f99dfc8a85e8007e1c3aecdc54df4160/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0e2ad98ef1de55b761cf165fa1d5bf8/" rel="bookmark">
			结构体＜C语言＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导言 结构体是C语言中的一种自定义类型，它的值（成员变量）可以是多个，且这些值可以为不同类型，这也是和数组的主要区别，下面将介绍它的一些基本用法，包括：结构体的创建、结构体变量的声明、初始化、结构体的访问、结构体的内存对齐等。
目录
导言
结构体的创建
结构体变量的声明
结构体成员的初始化、访问
结构体的内存对齐
结构体的创建 struct stu {//比如描述一个学生 char name[10];//名字 int age;//年龄 int score；// 得分 }; 结构体变量的声明 常用的有以下3种：
1.在结构体创建时同时声明结构体变量：
struct stu {//比如描述一个学生 char name[10];//名字 int age;//年龄 int score;// 得分 }stu1,stu2;//声明了stu1和stu2 2.先创建结构体，后声明（包括在函数内部声明）：
//2.先创建结构体，后初始化： struct stu {//比如描述一个学生 char name[10];//名字 int age;//年龄 int score;// 得分 }; struct stu stu1, stu2; 3.使用typedef先重命名，再声明： //3.使用typedef先重命名，再声明： typedef struct stu {//比如描述一个学生 char name[10];//名字 int age;//年龄 int score;// 得分 }stu;//当前面使用typedef时，分号前不再是变量声明，而是重命名后的类型 stu stu1, stu2;//声明了stu1和stu2 关于typedef重命名结构体，也可先创建结构体，再重命名：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0e2ad98ef1de55b761cf165fa1d5bf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65d86c0d4e71352beaeb14f4a89844ed/" rel="bookmark">
			美团大规模KV存储挑战与架构实践--图文分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		美团大规模KV存储挑战与架构实践–图文分析 原作者：美团技术团队
原文链接：https://tech.meituan.com/2024/03/15/kv-squirrel-cellar.html
1 美团 KV 存储发展历程 第一代：使用Memcached
什么是一致性哈希？
哈希：hash,可以通过Key存储Value，也可以通过Key取得Value. 简单说就是Value存储的位置是通过Hash算法计算出来的
(实现，如HashMap)。
随着客户端发起的请求数量越来越高，为了加快响应速度，在客户端与数据库之间增加了缓存层，把数据库中的热点数据存入缓存，这样客户端可以直接从缓存取得热点数据，无需每次都访问数据库，即加快了响应时间，又降低了数据库层的压力。
hash取模运算
随着业务规模不断扩大，数据量也跟着增大，缓存数量飙增，这样就需要考据搭建缓存集群，把大量的缓存分散到多台缓存服务器中进行存储。
取模算法hash（key）%N，即：对缓存数据的key进行hash运算后取模，N是机器的数量；运算后的结果映射对应集群中的节点。具体如下图所示：
![外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传](https://img-home.csdnimg.cn/images/20230724024159.png?origin_url=F%3A%2FBaiduNetdiskDownload%2FDevOps%E7%AC%94%E8%AE%B0-MarkDown%E5%8E%9F%E7%89%88%2FDevOps%2FPictures%2Fimage-20240607182832191.png&amp;pos_id=img-VgEmEbVn-1717929022871
问题，如上图，三个node，所以N为3，此时key通过公式hash(key)%3存入指定节点，之后扩容成4个节点，N为4，公式也变成了hash(key)%4，之前n为3的值取不出来了。
一致性哈希
一致性哈希算法将整个哈希值空间映射成一个虚拟的圆环。整个哈希空间的取值范围为02^32-1，按顺时针方向开始从0232-1排列，最后的节点232-1在0开始位置重合，形成一个虚拟的圆环。
对服务器IP地址进行哈希计算，哈希计算后的结果对232取模，结果一定是一个0到232-1之间的整数。最后将这个整数映射在哈希环上，整数的值就代表了一个服务器节点的在哈希环上的位置。即：hash（服务器ip）% 2^32。
当服务器接收到数据请求时，首先需要计算请求Key的哈希值；然后将计算的哈希值映射到哈希环上的具体位置；接下来，从这个位置沿着哈希环顺时针查找，遇到的第一个节点就是key对应的节点
服务器扩容
D数据本来应该会落在node1中，由于扩容节点node4,D数据落在了node4中
服务器缩容
node4节点宕机或者移除后，数据D继续顺时针找到node1节点存储。
数据倾斜与虚拟节点
数据abcd都落在node1中，node2,node3没事干，node1压力山大。
解决方案，使用虚拟节点
hash（服务器ip）% 2^32 变更为 hash（服务器ip+随机数）% 2^32
例如：Hash(“114.211.11.141”);
变更为:
Hash(“114.211.11.141#1”);
Hash(“114.211.11.141#2”);
注意，虚拟节点只是帮助真实节点扩大获取数据的范围，并不会保存数据，所获取的数据最终还是要存储在真实节点中。
memcached的问题
传统的memcached是不支持内存数据的持久化操作,因为它将数据存储在内存当中的,当服务器宕机重启,数据会丢失。
不适合存储1M以上的数据。
适用场景：缓存一些很小但是被频繁访问的，即便你丢失也不会影响系统以及系统业务正常执行的数据。如：新闻热点缓存，即便日后数据丢失，热点已经降温，数据不重要。
第二代：使用Redis
优点：支持持久化，服务宕机后数据不会丢失，可以通过哨兵机制进行故障恢复(failover)
宕机数据不丢失策略：
RDB每5分钟一次生成快照，AOF每秒通过一个后台的线程持久化操作，最多丢一秒的数据。单独用RDB会丢失很多数据，单独用AOF数据恢复没RDB快，所以解决方案是第一时间用RDB恢复，然后AOF做数据补全
缺点：扩缩容丢失数据。
一致性hash只是用来减少扩缩容时数据迁移量，无法对整个集群进行统一管理(缺乏类似提供心跳检测等服务的中心管理层，数据迁徙的时候，节点无法感知整个集群的状态，数据从A节点中迁徙出去了，但接收的B节点处于网络卡顿状态导致无法接受全部迁徙数据等问题)
第三代：阿里巴巴的 Tair
Tair 开源版本的架构主要是三部分：最下边的是存储节点，存储节点会上报心跳到它的中心节点，中心节点内部设有两个配置管理节点，会监控所有的存储节点。如果有任何存储节点宕机或者扩容之类的行为，它会做集群拓扑的重新构建，拥有数据迁移机制来保证数据的完整性。
缺点：
1.中心节点是高可用的，但是会发生脑裂。
脑裂：选举bug,多个leader，多个从节点被选举成了主节点，不干从节点的活了导致数据丢失。
2.和redis的数据类型不兼容
第四代：
基于Tair的Cellar ，基于Redis Cluster的Squirrel
这两个存储其实都是 KV 存储领域的解决方案。实际应用上，如果业务的数据量小，对延迟敏感，建议用 Squirrel ；如果数据量大，对延迟不是特别敏感，我们建议用成本更低的 Cellar 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65d86c0d4e71352beaeb14f4a89844ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61e08a97548e3d358e9843e62fe7880a/" rel="bookmark">
			文心一言使用技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
文心一言是一款基于人工智能技术的自然语言处理工具，它可以帮助用户生成、编辑和优化各种类型的文本。无论是写作、翻译、总结，还是进行信息提取和数据分析，文心一言都能提供强大的支持。本文将详细介绍文心一言的使用技巧，帮助用户充分发挥这款工具的潜力。
一、文心一言的基本功能 在深入使用技巧之前，我们首先了解文心一言的基本功能。文心一言主要包括以下几个核心功能：
1.1 文本生成 文心一言可以根据用户提供的提示词或主题生成高质量的文本内容。无论是写作文章、博客、演讲稿，还是创作故事和诗歌，文心一言都能帮助用户快速完成。
1.2 文本编辑 文心一言提供强大的文本编辑功能，可以对已有文本进行优化和润色。用户可以让文心一言对文本进行修改、扩展、缩写，或者纠正语法和拼写错误。
1.3 翻译与总结 文心一言支持多种语言的互译，并能对长篇文章进行摘要和总结。通过这些功能，用户可以方便地获取多语言信息，并快速理解长篇内容的核心要点。
1.4 信息提取与数据分析 文心一言能够从文本中提取关键信息，并进行简单的数据分析。用户可以提取出文本中的人名、地名、时间等信息，或对文本进行情感分析和主题识别。
二、文本生成的使用技巧 文本生成是文心一言最基础也是最强大的功能之一。通过合理的提示词和主题设置，用户可以生成高质量的文本内容。以下是一些使用技巧：
2.1 提供明确的提示词 为了生成符合预期的文本内容，用户需要提供明确且具体的提示词或主题。例如，如果用户想生成一篇关于“环保”的文章，可以使用以下提示词：
写一篇关于环保的重要性和如何进行有效环保的文章。 明确的提示词可以帮助文心一言更好地理解用户需求，生成的内容也会更加贴近主题。
2.2 设置文本结构 用户可以在提示词中设置文本的结构，帮助文心一言生成逻辑清晰的文章。例如，可以指定文章的段落或章节：
写一篇关于环保的重要性的文章，包括以下几个部分：1. 引言，2. 环保的重要性，3. 常见的环保措施，4. 结论。 这种方式可以确保生成的文本有明确的逻辑结构，内容更加丰富和全面。
2.3 控制文本长度 用户可以通过提示词控制生成文本的长度。例如，如果需要生成一篇短文，可以在提示词中明确说明：
写一篇关于环保的重要性的短文，大约300字。 通过这种方式，用户可以灵活控制生成文本的长度，满足不同场景的需求。
三、文本编辑的使用技巧 文本编辑功能可以帮助用户优化和润色已有文本，使其更加流畅和易读。以下是一些使用技巧：
3.1 语法和拼写检查 文心一言可以对文本进行语法和拼写检查，帮助用户发现并纠正错误。用户只需将文本输入文心一言，并请求进行语法和拼写检查：
请检查以下文本的语法和拼写错误： …… 这种方式可以确保文本的准确性和专业性，特别适用于学术论文、正式报告等需要高准确性的文档。
3.2 扩展和缩写文本 文心一言可以根据用户需求对文本进行扩展或缩写。例如，如果用户希望扩展某一段文字，可以使用以下提示：
请将以下段落扩展为两倍长度： …… 同样，如果需要将长段落缩写为简洁的版本，可以使用类似的提示：
请将以下段落缩写为一半长度： …… 通过这种方式，用户可以根据实际需求灵活调整文本长度，适应不同的使用场景。
3.3 风格和语气调整 文心一言可以根据用户需求调整文本的风格和语气。例如，如果用户希望将正式文档转换为更加口语化的风格，可以使用以下提示：
请将以下正式文档转换为口语化的风格： …… 反之，如果需要将口语化的文本调整为正式文档，可以使用类似的提示：
请将以下口语化文本转换为正式文档： …… 通过这种方式，用户可以轻松适应不同的写作风格和语境需求。
四、翻译与总结的使用技巧 文心一言的翻译与总结功能可以帮助用户处理多语言信息，并快速获取长篇内容的核心要点。以下是一些使用技巧：
4.1 多语言翻译 文心一言支持多种语言的互译，用户可以输入原文并指定目标语言。例如：
请将以下英文文本翻译为中文： …… 通过这种方式，用户可以方便地获取多语言内容，特别适用于国际交流和跨文化沟通。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61e08a97548e3d358e9843e62fe7880a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/533022123f88f98657df1c94b806d161/" rel="bookmark">
			MATLAB数学建模——数据拟合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一、简介二、多项式拟合（一）指令介绍（二）代码 三、指定函数拟合（一）指令介绍（二）代码 一、简介 曲线拟合也叫曲线逼近，主要要求拟合的曲线能合理反映数据的基本趋势，而不一定要求曲线一定通过数据点。常见的判别准则即是使偏差的平方和最小（即最小二乘法）。
二、多项式拟合 （一）指令介绍 P=polyfit(X,Y,N) ；
%多项式拟合函数，返回降幂排列的多项式系数P，X，Y是拟合的数据横纵坐标值，N是拟合的最高次幂
polyval(P,Xi);
%计算多项式函数的值
（二）代码 多项式拟合：
%matlab clc; clear all; close all; [data,name]=xlsread('1.xlsx'); x=data(1,:); y=data(2,:); P=polyfit(x,y,3);%最高次幂为3 X=1:0.1:9; Y=polyval(P,X); plot(X,Y,x,y,'r*') 三、指定函数拟合 （一）指令介绍 f=fittype(‘自定义函数’,‘independent’,‘自变量名’,‘coefficients’,{‘待定参数1’,‘待定参数2’，……});
%自定义拟合函数
Y=fit(x,y,f);
%根据自定义拟合函数来拟合数据x,y
注意：x,y都是列向量的形式
（二）代码 指定函数
%matlab clc; clear all; close all; [data,name]=xlsread('1.xlsx'); x=data(1,:); y=data(2,:); %自定义函数 syms t %定义符号变量 f= fittype('a*cos(b*t)*exp(c*t)','independent','t','coefficients',{'a','b','c'}); %计算拟合函数 Y=fit(x',y',f); %注意x,y都是列向量的形式 xi=0:0.1:20; yi=Y(xi); plot(x,y,'r*',xi,yi,'b-') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f5405ebd185d11342bf7302af5239c6/" rel="bookmark">
			C&#43;&#43;【STL】改造红黑树简单模拟实现set map（带你了解set map的底层实现结构）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、学前铺垫（泛型编程）
二、改造红黑树
1.红黑树节点的改造
2.insert的改造
3.迭代器的实现
4.完整改造代码
三、set的模拟实现封装
四、map的模拟实现封装
五、完结撒❀
前言：
下面为了简单模拟实现set map所出现的代码是以C++中STL源码库中的代码逻辑基础进行的简化代码，本片博客目的是带你简单深入底层，了解set map底层的实现逻辑，对泛型编程有更加深刻的认识。
一、学前铺垫（泛型编程） 本篇博客我们通过对一个红黑树进行改造，使其可以让set和map的模拟实现都使用这一个红黑树结构，因为set map所存储的数据类型不一样,set底层存储的是pair&lt;key,key&gt;,map底层存储的是pair&lt;key,value&gt;,所以这里就一定会用上多个模板对红黑树进行改造，形成泛型编程，之后再对set map使用改造后的红黑树进行封装，达到模拟STL库中set map的效果。（有能力的可以直接去看STL中set map所实现的源码，逻辑与我所讲述的相同）
二、改造红黑树 1.红黑树节点的改造 这里节点的构造基本与二叉搜索树的节点构造相同，但是因为要同时兼顾set map两中类型，所以存储数据的类型不可以写死，要用到模板，节点代码如下：
template &lt;class T&gt; struct RBTreeNode { RBTreeNode&lt;T&gt;* _left; RBTreeNode&lt;T&gt;* _right; RBTreeNode&lt;T&gt;* _parent; Color _col; T _data; RBTreeNode(const T&amp; data) :_left(nullptr) , _right(nullptr) , _parent(nullptr) , _data(data) , _col(RED) {} }; 2.insert的改造 需要改造的地方：
1) 根据STL库中的set和map的insert的功能，插入成功返回插入位置所在的迭代器以及true，插入失败说明树中已存在改值，返回该值所在的位置的迭代器以及false，所以返回类型应为pair&lt;iterator,bool&gt;，所以返回类型需要进行改造。
2) 在insert中大小值的比较，因为要兼容set和map，而在set中的模板类型只需要一个就可以进行初始化，因为set中底层数据类型是一样的，而map不同，map底层类型其实是pair&lt;key,pair&lt;key,value&gt;&gt;实现，因为在实现find函数时需要用到key的值并且与set保持一致，所以将value类型定义为pair&lt;key,value&gt;，那么在后续的比较大小中就不能那么随意了，因为set直接拿其节点指向的_data进行比较即可，而map中的_data为pair&lt;key,pair&lt;key,value&gt;&gt;,不可以直接拿来进行比较,所以我们将代码进行改造。
下面是模拟实现set，map的简单封装。SetKeyOFT，MapKeyOFT就是解决大小比较所定义的内部类。
Mymap.h:
template &lt;class K,class V&gt; class map { public: struct MapKeyOFT { const K&amp; operator()(const pair&lt;K, V&gt;&amp; kv) { return kv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f5405ebd185d11342bf7302af5239c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad445b77d97d5d48de1cfe9ec7f8af4c/" rel="bookmark">
			数据结构：旋转数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法1 （三次逆置法）：
void reverse(int* nums, int start, int end) { while (start &lt; end) { int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; start++; end--; } } void rotate(int* nums, int numsSize, int k) { k = k % numsSize; // 防止 k 大于数组长度 if (k == 0) return; // 如果 k 为 0，则无需旋转 reverse(nums, 0, numsSize - 1); // 逆置整个数组 reverse(nums, 0, k - 1); // 逆置前 k 个元素 reverse(nums, k, numsSize - 1); // 逆置剩余的元素 } 时间复杂度：O（N），空间复杂度：O（1）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad445b77d97d5d48de1cfe9ec7f8af4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5f7b7ceaa3a5c33e6c0ba9d2ab0a242/" rel="bookmark">
			C# WPF入门学习主线篇（十九）—— 布局管理实战『混合布局案例』
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C# WPF入门学习主线篇（十九）—— 布局管理实战『混合布局案例』 欢迎来到C# WPF入门学习系列的第十九篇。在前几篇文章中，我们详细介绍了各个布局容器的基本概念和使用方法。本篇博客将通过一个综合的实战案例，展示如何在WPF中使用多种布局容器进行混合布局，创建一个功能齐全且美观的用户界面。
案例概述 在这个实战案例中，我们将创建一个简单的登录界面。该界面将包含以下元素：
标题区域用户名和密码输入区域登录按钮和取消按钮底部版权信息 我们将使用 Grid、StackPanel、Border、UniformGrid 和其他布局容器来实现这个混合布局。
XAML布局代码 首先，我们在XAML中定义整个布局结构：
&lt;Window x:Class="WpfApp.MainWindow" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" Title="Login Screen" Height="400" Width="300"&gt; &lt;Grid&gt; &lt;!-- 定义整体布局的行和列 --&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height="Auto"/&gt; &lt;RowDefinition Height="*"/&gt; &lt;RowDefinition Height="Auto"/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition Width="*"/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;!-- 标题区域 --&gt; &lt;Border Grid.Row="0" Background="LightBlue" Padding="10"&gt; &lt;TextBlock Text="Login" FontSize="24" FontWeight="Bold" HorizontalAlignment="Center"/&gt; &lt;/Border&gt; &lt;!-- 用户名和密码输入区域 --&gt; &lt;StackPanel Grid.Row="1" Margin="20"&gt; &lt;TextBlock Text="Username" Margin="0,0,0,5"/&gt; &lt;TextBox x:Name="usernameTextBox" Height="25" Margin="0,0,0,10"/&gt; &lt;TextBlock Text="Password" Margin="0,10,0,5"/&gt; &lt;PasswordBox x:Name="passwordBox" Height="25"/&gt; &lt;/StackPanel&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5f7b7ceaa3a5c33e6c0ba9d2ab0a242/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c4de4e0c5ef4c0bd169da09bb956999/" rel="bookmark">
			【深度学习】深度学习之巅：在 CentOS 7 上打造完美Python 3.10 与 PyTorch 2.3.0 环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【深度学习】深度学习之巅：在 CentOS 7 上打造完美Python 3.10 与 PyTorch 2.3.0 环境 大家好 我是寸铁👊
总结了一篇【深度学习】深度学习之巅：在 CentOS 7 上打造完美Python 3.10 与 PyTorch 2.3.0 环境✨
喜欢的小伙伴可以点点关注 💝
引言 🍎 在当今快速发展的深度学习领域，构建一个稳定、高效的开发环境是每个研究人员和开发者的必备条件。而在 CentOS 7 这样的操作系统上，如何将最新的Python 3.10和PyTorch 2.3.0焕发出最佳性能，是一项需要技巧和专业知识的挑战。本文将引导您通过一系列高级步骤和最佳实践，打造一个完美无缺的深度学习环境，让您的项目在技术之巅驰骋!
前言🍐 本文是笔者踩过无数坑后亲测出来的安装教程，按照这个教程走下来，可以正常使用pip3 install XX安装第三方包，笔者在安装过程看过近30篇安装教程博客，很多的安装步骤走下来经常会报错。例如:大家用pip3 install XX发现报错ssl ，然后你开始查找配置ssl证书，发现无论是选择任何的信任源都发现不行，最后发现是ssl版本过旧，所以，本文优先更新openssl，确保pip3 install XX成功！
如果你也是深度学习新手，正苦恼如何搭建环境，跟着笔者一步步走，过程非常丝滑！
安装场景🌈 Centos7操作系统 虚拟机、服务器常见安装场景
容器内的Centos7操作系统 容器内部安装Centos7镜像后，也是一个Linux，安装操作教程相同，笔者亲测有效。
使用dockerfile+requirements.txt安装 本质上是docker帮助我们一行行执行命令，其实也是一样的，需要注意dockerfile的编写规范，详情见下方的dockerfile文件，dockerfile也是笔者跑通安装环境的一个范本，笔者亲测有效。
在虚拟机、服务器安装🗽 一、升级openssl🍉 下载必要的依赖包，使用root权限： sudo yum install -y gcc gcc-c++ autoconf automake zlib zlib-devel pcre-devel 进入到opt目录，到OpenSSL官方网站下载源码，解压并进入软件包目录： cd /opt sudo wget https://www.openssl.org/source/openssl-1.1.1q.tar.gz --no-check-certificate sudo tar -zxvf openssl-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c4de4e0c5ef4c0bd169da09bb956999/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3750d0e69151be6ff9fe3962cbea3ca0/" rel="bookmark">
			【C&#43;&#43;】 详解 lower_bound 和 upper_bound 函数（看不懂来捶我！！！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、函数详解 🥝 lower_bound
⚡无自定义比较函数
⚡使用自定义比较函数
✨ 自己写--自定义比较函数
✨ 官方的--自定义比较函数
🍍upper_bound
⚡无自定义比较函数
⚡使用自定义比较函数 ✨ 自己写--自定义比较函数
✨ 官方的--自定义比较函数
🍇 upper_bound 和 lower_bound 的区别
三、常考面试题
四、共勉
一、前言 这两个函数是我在 LeetCode 上做题见到，看到不熟悉的函数 lower_bound 和 upper_bound让我感觉很难受，于是在 C++ 官网去学习，例子就一个是最基础的，我看明白了。虽然是两个函数的接口就两个，但是有时候看别人使用的时候，里面参数还可以放不同的仿函数，我懵逼了。就去网上搜，但是大家讲解的都是它的第一个接口。我只能再把文档一遍一遍过，代码一遍遍的尝试，调试。最终通过查阅资料将其总结如下。
二、函数详解 首先，大家都说用这两个函数之前必须是在有序的数组中，但是都没有说明为什么是在有序的数组，因为他们的底层实现是二分查找（这个也是我在别人的题解的时候知道的）。如果对二分查找有不清楚的伙伴可以看看这篇文章：详解二分查找
函数的头文件： #include &lt;algorithm&gt;
🥝 lower_bound 函数原型：
原型1：
template &lt;class ForwardIterator, class T&gt; ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T&amp; val); 原型2：
template &lt;class ForwardIterator, class T, class Compare&gt; ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T&amp; val, Compare comp); 模板参数解释：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3750d0e69151be6ff9fe3962cbea3ca0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/846a599adb0db729825d854269c13167/" rel="bookmark">
			C# WPF入门学习主线篇（十六）—— Grid布局容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C# WPF入门学习主线篇（十六）—— Grid布局容器 欢迎来到C# WPF入门学习系列的第十六篇。在前几篇文章中，我们已经探讨了 Canvas、StackPanel、WrapPanel 和 DockPanel 布局容器及其使用方法。本篇博客将介绍另一种功能强大且灵活的布局容器——Grid。通过本文，您将学习如何使用 Grid 来创建复杂且灵活的用户界面布局，并了解 Grid 的常见属性和应用场景。
什么是Grid布局容器？ Grid 是WPF中最常用的布局容器之一，用于创建基于行和列的布局。Grid 允许开发者定义任意数量的行和列，并将子控件放置在这些行列的交点上。它非常适合用于创建复杂的用户界面布局，因为它提供了对控件位置和大小的精确控制。
Grid的常见属性 Grid 有几个重要的属性和附加属性，可以帮助开发者灵活地控制子控件的排列方式：
RowDefinitions: 定义 Grid 的行集合。ColumnDefinitions: 定义 Grid 的列集合。Grid.Row: 附加属性，指定子控件所在的行。Grid.Column: 附加属性，指定子控件所在的列。Grid.RowSpan: 附加属性，指定子控件跨越的行数。Grid.ColumnSpan: 附加属性，指定子控件跨越的列数。 使用Grid布局容器的示例 基本使用示例 以下是一个简单的XAML代码示例，展示了如何使用 Grid 创建一个包含三行两列的布局：
&lt;Window x:Class="WpfApp.MainWindow" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" Title="Grid Example" Height="350" Width="525"&gt; &lt;Grid&gt; &lt;!-- 定义三行两列的 Grid 布局 --&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height="Auto"/&gt; &lt;RowDefinition Height="*"/&gt; &lt;RowDefinition Height="Auto"/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition Width="Auto"/&gt; &lt;ColumnDefinition Width="*"/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;!-- 将控件放置在 Grid 的特定行和列中 --&gt; &lt;TextBlock Text="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/846a599adb0db729825d854269c13167/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bcb02f0c05e8d572bec1e8eb4366bd8/" rel="bookmark">
			【数据结构】二叉树专题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
本篇博客我们来看一些二叉树的经典题型，也是对上篇博客的补充
💓 个人主页：小张同学zkf
⏩ 文章专栏：数据结构
若有问题 评论区见📝 🎉欢迎大家点赞👍收藏⭐文章 ​
目录
1.单值二叉树
2.检查两棵树是否相同
3.对称二叉树
​编辑 4.二叉树的前序遍历
5.另一棵树的子树
1.单值二叉树 这道题有两种思路，一种是最简单的也是最常见的思路，遍历，就是把每个节点遍历一遍，看是否值相等（代码过于简单就不写了），还有一种思路就是递归，通过递归，判断孩子与父亲是否相等，若相等进行下次递归，直到节点为空，就代表是单值二叉树，我们写下递归方式的代码
代码如下
2.检查两棵树是否相同 这道题我们可以让两颗子树分别遍历，直到双方节点同时都为空，就相等若是一方节点先为空则两棵树不相等，若遍历的同时值不相等，那两棵树也不相等，代码如下
3.对称二叉树 这个对称二叉树就判断左子树与右子树是否相等就行了，也就是说把根节点的左右子树放到上面那道题函数里判断就行了
/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ bool isSameTree(struct TreeNode* p, struct TreeNode* q) { if(p==NULL&amp;&amp;q==NULL) return true; if(p==NULL||q==NULL) return false; if(p-&gt;val!=q-&gt;val) return false; return isSameTree(p-&gt;left,q-&gt;right)&amp;&amp;isSameTree(p-&gt;right,q-&gt;left); } bool isSymmetric(struct TreeNode* root) { return isSameTree(root-&gt;left,root-&gt;right); } 注意一下，这里要看左子树与右子树比较是否相等 ，所以传参的时候注意下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bcb02f0c05e8d572bec1e8eb4366bd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69e6137542a32ec15e220c0b5ce26f1f/" rel="bookmark">
			Java----抽象类和接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎大家来这次博客-----抽象类和接口。 1.抽象类 1.1 抽象类概念 在Java中我们都是通过类来描述对象，但反过来并不是所有的类都是用来描述对象的。当一个类中没有足够的信息来描述一个具体对象，我们就将该类称为抽象类。
如上图中的Shape类，我们想通过Shape类中的draw()方法来实现画各种图形，但由于Shape类不是具体的图形，所以Shape类中的draw()方法也无法实现画各种图形，所以我们将Shape类设置成抽象类。
代码演示
abstract class Shape{ public abstract void draw(); } class Triangle extends Shape{ @Override public void draw() { System.out.println("画一个三角形"); } } class Cycle extends Shape{ @Override public void draw() { System.out.println("画一个圆"); } } class Rect extends Shape{ @Override public void draw() { System.out.println("画一个矩形"); } } public class Test { public static void main(String[] args) { Shape[] shapes={new Triangle(), new Cycle(), new Rect()}; for(Shape shape:shapes){ shape.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69e6137542a32ec15e220c0b5ce26f1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3679791e95d431c0acf04e3bf6faec6/" rel="bookmark">
			浅议Flink中算子间的八种数据传输策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、知识铺垫
a. Flink数据传输分类
Flink数据传输分为 组件之间的通信消息传输 和 算子之间的流数据传输。
(1)组件之间
组件（即Client、JobManager、TaskManager）之间的通信消息传输采用Akka框架。常见的通信包括心跳检测、状态上报、指标统计、作业提交和部署等。
(2)算子之间
(2.1)本地线程内(同一个SubTask内的两个Operator)：数据传输通过方法调用进行，即上游算子处理完数据后，直接调用下游算子的processElement方法。
(2.2)本地线程间(同一个TaskManager的不同SubTask中)：数据传输通过本地内存进行，需要进行数据的序列化和反序列化。
(2.3)跨网络(不同TaskManager的SubTask中)：采用Netty框架，通过Socket进行数据传输，也需要进行数据的序列化和反序列化。
Flink中为上下游subtask之间数据传输(即上述2.2&amp;2.3)提供了九种传输策略。
其中BinaryHashPartitioner位于Blink的Table API的org.apache.flink.table.runtime.partitioner包中，是一种针对BinaryRowData的哈希分区器。
本文讨论上图中绿色框圈中的八种策略。
在Flink WebUI中，可看到算子之间的传输策略会在箭头上标注出来。
b. Flink中分发模式(Distribution Pattern) Flink 中的执行图可以分成四层：StreamGraph -&gt; JobGraph -&gt; ExecutionGraph -&gt; 物理执行图。
在StreamGraph -&gt; JobGraph的过程中,上下游subtask之间的数据传输涉及分发模式。
分发模式描述了上游节点与下游节点连接的方式，Flink 中有两种分发模式：点对点 (Pointwise) 和全连接 (All-to-all)。
All-to-all模式: 简单的全连接。
Pointwise模式：上下游节点的并行度会影响连接方式。当上下游并行度相同时会一对一连接；当上游并行度小于下游时,下游subTask只会连接一个上游分区;当上游并行度大于下游时,下游subTask会连接多个上游分区。
RescalePartitioner和ForwardPartitioner 采用了 Pointwise模式。
在RescalePartitioner&amp;RebalancePartitioner，ForwardPartitioner&amp;GlobalPartitioner 这两组策略中,由于分发模式的不同，每组的两种分区策略会产生不同的效果。 二、八种传输策略
StreamPartitioner继承自ChannelSelector接口。这里的Channel可以认为它就是下游算子的并发实例(即物理分区)。所有StreamPartitioner的子类都要实现selectChannel()方法，用来选择分区号。
1. ForwardPartitioner
ForwardPartitioner是Flink默认的传输策略。
这种策略的前提是上下游并行度相同。
ForwardPartitioner会将数据发到下游的对应分区（在pointwise模式下下游的0号分区也对应着上游相关分区）。
2. RebalancePartitioner
当上下游算子不符合ForwardPartitioner使用条件时，Flink会默认选择RebalancePartitioner。
（ForwardPartitioner &amp; RebalancePartitioner 是Flink根据上下游并行度设置等因素设置的默认策略，其他几类传输策略则需要用户代码指定 ）。
RebalancePartitioner会先随机选一个下游分区，之后轮询(round-robin)遍历下游所有分区进行数据传输。
3. RescalePartitioner
RescalePartitioner在pointwise模式下会先根据上下游并行度进行匹配，再从匹配后的下游中从0号分区轮询传输数据。
4. ShufflePartitioner
ShufflePartitioner会随机选取下游分区进行数据传输。由于Random生成的随机数符合均匀分布，因此能够大致保证下发的平均效果，类似于RebalancePartitioner。
5. KeyGroupStreamPartitioner
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3679791e95d431c0acf04e3bf6faec6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa5fca71d568486fd27b0e1f1e081d3c/" rel="bookmark">
			Java 编译报错：找不到符号？ 手把手教你排查解决！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 编译报错：找不到符号？ 手把手教你排查解决！ 在 Java 开发过程中，我们经常会遇到编译器抛出 "找不到符号" 错误。这个错误提示意味着编译器无法在它所理解的范围内找到你所引用的类、变量或方法。这篇文章将带你一步一步排查并解决这个常见问题。
1. 理解 "找不到符号" 错误 在深入解决方法之前，我们先来理解一下为什么会出现 "找不到符号" 错误。Java 编译器需要明确知道每个变量、方法和类的定义，才能成功编译代码。当编译器遇到一个它不认识的标识符时，就会抛出 "找不到符号" 错误。
以下是一些可能导致此错误的常见原因：
拼写错误：这是最常见的原因之一。仔细检查你的代码，确保类名、变量名和方法名都拼写正确，并且大小写一致。缺少依赖：如果你正在使用外部库或框架，你需要确保这些库已正确添加到你的项目依赖中。类路径问题：编译器需要知道在哪里查找你项目中使用的所有类。如果你的类路径设置不正确，编译器就找不到它需要的类。作用域问题：Java 中的变量和方法都有其作用域。如果你试图在声明范围之外访问变量或方法，就会出现 "找不到符号" 错误。版本不兼容：如果你使用的库版本与你的项目不兼容，也可能导致此错误。 2. 排查步骤 遇到 "找不到符号" 错误时，不要慌张！按照以下步骤逐一排查，就能快速找到问题所在：
2.1 检查拼写和大小写
首先，仔细检查你的代码，确保所有标识符的拼写和大小写都正确无误。Java 是一种区分大小写的语言，因此​MyClass​和​myclass​是不同的。
2.2 检查类是否在正确的包中
确保你正在使用的类位于正确的包中。如果一个类不在正确的包中，编译器就无法找到它。
2.3 检查依赖项
如果你正在使用外部库或框架，请确保已将它们正确添加到你的项目依赖项中。你可以使用 Maven 或 Gradle 等构建工具来管理依赖项。
2.4 检查类路径
确保你的类路径设置正确，以便编译器可以找到所有需要的类。你可以在编译时使用​-cp​或​-classpath​选项来指定类路径。
2.5 检查作用域
确保你正在尝试访问的变量或方法在当前作用域内可见。例如，你不能在静态方法中访问非静态变量。
2.6 检查版本兼容性
如果你使用的库版本与你的项目不兼容，请尝试更新或降级库版本，以解决兼容性问题。
3. 解决方法 找到问题根源后，就可以采取相应的解决方法了：
修正拼写错误：更正代码中所有拼写错误，确保大小写一致。添加缺少的依赖项：使用构建工具添加缺少的库或框架。配置类路径：正确设置类路径，确保编译器可以找到所有需要的类。调整代码结构：调整代码结构，确保变量和方法在正确的作用域内使用。解决版本冲突：更新或降级库版本，以解决版本不兼容问题。 4. 一些额外的提示 善用 IDE：大多数 IDE 都能帮助你自动检查拼写错误、管理依赖项和设置类路径。阅读错误信息：编译器提供的错误信息通常包含解决问题的线索。仔细阅读错误信息，并尝试理解其含义。使用搜索引擎：如果遇到无法解决的问题，可以尝试使用搜索引擎查找解决方案。 5. 总结 "找不到符号" 错误是 Java 开发中常见的编译错误，但通过仔细排查和解决，你可以轻松克服它。 记住要仔细检查代码、管理好依赖项、设置正确的类路径，并确保代码结构合理。 相信通过这篇文章，你已经掌握了排查和解决 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa5fca71d568486fd27b0e1f1e081d3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f073fa1583bd561ea64f045fc4a5a4f/" rel="bookmark">
			Java 环境配置 -- Java 语言的安装、配置、编译与运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是栗筝i，这篇文章是我的 “栗筝i 的 Java 技术栈” 专栏的第 002 篇文章，在 “栗筝i 的 Java 技术栈” 这个专栏中我会持续为大家更新 Java 技术相关全套技术栈内容。专栏的主要目标是已经有一定 Java 开发经验，并希望进一步完善自己对整个 Java 技术体系来充实自己的技术栈的同学。与此同时，本专栏的所有文章，也都会准备充足的代码示例和完善的知识点梳理，因此也十分适合零基础的小白和要准备工作面试的同学学习。当然，我也会在必要的时候进行相关技术深度的技术解读，相信即使是拥有多年 Java 开发经验的从业者和大佬们也会有所收获并找到乐趣。
–
上一篇的内容中我们介绍了 Java 语言的概述，明白了它是什么，有什么特点，并且有着怎样的过去和会有怎样的未来。而在这篇文章中，首先，我们将会先聊一聊 Java 的体系、环境、和版本，因为如果是刚入门的小伙伴，没有去特意了解的话，确实会存在相关的困惑（现在网上大多数文章对相关内容的介绍已经过时了）；然后，我们会进行真正的开始，即 Java 语言的安装、配置、编译与运行；在最后，我们再了解一下，当下最为流行的 Java 开发 IDE 工具 – IntelliJ IDEA!
最后在前言的末尾我补充一下，如果这篇文章，对大家有所帮助或收获一定的乐趣和想法，那么非常欢迎大家能够，点赞、评论、收藏、订阅。这些也将是我持续更新的最大动力。
文章目录 1、Java 体系&amp;环境1.1、Java 三大体系1.2、Java 三大环境1.3、Java 两大版本 2、Java安装&amp;配置2.1、Java下载2.2、Java 安装2.3、Java 配置2.4、Java 验证 3、Java 编译&amp;运行3.1、Java 的运行过程3.2、Java 编译/解释型语言3.3、Java 编译执行 Demo 4、Java 开发工具：IDEA4.1、IDEA 简介4.2、IDEA 下载和安装 1、Java 体系&amp;环境 1.1、Java 三大体系 1999 年 Sun 公司根据应用的领域不同把 Java 技术划归为三个平台，当时分别称为 J2SE、J2EE 和 J2SE，后改名为 Java SE、Java EE 和 Java ME。近些年来，对于新接触 Java 这门语言的同学们来说，Java 三大体系平台，总是会在入门的时候提及到，但是在后续的应用使用时却没发现需要根据不同场景进行细分，这是为什么呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f073fa1583bd561ea64f045fc4a5a4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26cc906c575194c9c489f4f4550faa81/" rel="bookmark">
			《精通ChatGPT：从入门到大师的Prompt指南》第7章：创意写作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第7章：创意写作 7.1 角色设定 角色设定是创意写作中最关键的环节之一。成功的角色设定能够让读者对故事产生共鸣，使故事更加生动有趣。角色不仅仅是情节发展的载体，更是读者情感的投射对象。因此，深入了解如何设定一个生动而有深度的角色，对于创意写作来说至关重要。
7.1.1 角色背景 角色背景是角色设定的基础，它包括角色的历史、家庭、教育、职业、以及成长经历等方面。这些背景信息不仅能帮助作者理解角色的行为动机，还能为角色的行动和选择提供合理的解释。
例如，一个在贫困家庭长大的角色可能会展现出强烈的生存欲望和对金钱的敏感，而一个在富裕家庭中成长的角色则可能表现出对物质生活的无所谓和对精神生活的追求。因此，详细的背景设定不仅能使角色更加立体，还能使读者更容易理解角色的动机和行为。
7.1.2 角色性格 性格是角色的核心，它决定了角色在各种情境下的反应和行为。性格设定要尽量丰富和复杂，因为真实的人类性格本身就具有多面性。
在设定角色性格时，可以考虑以下几个方面：
内向还是外向：角色是喜欢独处还是喜欢社交？内向的角色可能更倾向于内省和思考，而外向的角色则更喜欢与人交往，表现得更为外向和积极。
情绪稳定性：角色的情绪是否容易波动？情绪稳定的角色通常表现得更加理性和冷静，而情绪不稳定的角色则可能表现出更大的情绪起伏和冲动行为。
道德观：角色的道德观念是怎样的？他们是否有明确的是非观？道德观念强烈的角色可能会有更坚定的原则和行为准则，而道德观念模糊的角色则可能在利益面前表现出更大的灵活性。
兴趣爱好：角色的兴趣爱好是什么？这些兴趣爱好不仅可以丰富角色的性格，还可以为故事的发展提供有趣的情节。例如，一个喜欢园艺的角色可能会在故事中展现出对植物的特别关怀，这种细节可以增加角色的魅力。
7.1.3 角色动机 动机是推动角色行动的内在驱动力，它通常是由角色的需求、愿望或恐惧所决定的。了解角色的动机对于塑造一个可信的角色至关重要。
角色的动机可以是显性的，也可以是隐性的。显性动机通常是直接表达出来的，例如一个角色想要成为公司的CEO，这是一种明确的动机。隐性动机则可能是潜藏在角色内心深处的，例如由于童年时期受到的创伤，一个角色可能会表现出对安全感的极度渴望。
在创作过程中，作者需要深入挖掘角色的动机，因为这不仅能使角色的行为更加合理，也能使读者更深入地理解角色。例如，一个看似冷酷无情的反派角色，如果他的动机是为了保护家人，读者就会对他产生更复杂的情感。
7.1.4 角色关系 角色之间的关系是推动情节发展的重要因素。角色关系可以是亲密的，也可以是敌对的，还可以是复杂而多变的。在设定角色关系时，作者需要考虑以下几个方面：
亲情关系：亲情关系通常是角色之间最为深厚的关系，它可以是支持的力量，也可以是冲突的来源。例如，一个角色与父母之间的关系如何，他们是否有未解的矛盾，这些都可以成为故事的重要情节。
友情关系：友情关系在故事中常常起到支持和缓解紧张情绪的作用。一个好的朋友可以在关键时刻提供帮助和支持，也可以在角色迷失方向时给予指引。
爱情关系：爱情关系通常是情节发展的重要线索。爱情不仅可以带来甜蜜和温暖，也可以带来冲突和挑战。如何处理角色之间的爱情关系，可以大大影响故事的走向。
敌对关系：敌对关系通常是冲突的主要来源。角色之间的敌对关系可以是由于利益冲突、理念不同，或者是过去的恩怨。通过刻画敌对关系，可以增加故事的张力和戏剧性。
7.1.5 角色成长 角色成长是指角色在故事发展过程中经历的变化和发展。这种变化可以是性格上的，也可以是价值观和行为上的。角色成长通常是一个角色从不成熟到成熟、从困惑到明了、从失败到成功的过程。
通过描写角色的成长过程，可以使故事更加引人入胜，也可以让读者从中获得启发。例如，一个在故事开始时胆小懦弱的角色，经过一系列的挑战和磨练，最终变得勇敢和坚定，这样的成长过程不仅能使角色更加立体，也能使故事更加感人。
角色设定是创意写作中至关重要的一环，通过详细的背景、性格、动机、关系和成长设定，作者可以创作出丰富多彩、引人入胜的角色，为故事的成功奠定坚实的基础。
7.2 情节发展 在创意写作中，情节发展是讲述一个引人入胜的故事的核心。一个精心设计的情节不仅能吸引读者的注意力，还能确保故事的连贯性和逻辑性。以下是关于如何使用ChatGPT来发展故事情节的详细指南。
7.2.1 情节的基本构成 情节是故事的骨架，它包括一系列有因果关系的事件。这些事件推动故事向前发展，塑造角色，揭示主题。情节通常由以下几个部分组成：
开端：介绍故事的背景、主要人物和初始冲突。
发展：逐步引入新的情节元素和冲突，推动故事向高潮发展。
高潮：故事的转折点，最紧张、最激动人心的部分。
结局：解决冲突，揭示故事的结局。
7.2.2 使用ChatGPT进行情节构思 在使用ChatGPT构思情节时，可以通过以下步骤来确保情节的完整性和吸引力：
设定初始情节：输入一个基本情节设定，比如：“在一个遥远的未来，人类与智能机器人共同生活，但和平即将被打破。”
text复制代码Prompt: 在一个遥远的未来，人类与智能机器人共同生活，但和平即将被打破。设定一个初始冲突，并引出主要人物。 扩展情节发展：根据初始情节，逐步引入新元素和次要冲突。可以询问ChatGPT关于可能的发展方向。
text复制代码Prompt: 初始冲突是一个机器人意外失控，攻击了一名人类。接下来会发生什么？ 设计高潮：询问ChatGPT关于如何设计故事的高潮部分，使之充满戏剧性和张力。
text复制代码Prompt: 故事的高潮应该如何设计，才能最大限度地引起读者的兴趣？ 解决冲突：通过询问ChatGPT，确定故事的结局，确保所有的冲突都得到合理的解决。
text复制代码Prompt: 如何设计一个令人满意的结局，既解决主要冲突，又给读者留下深刻印象？ 7.2.3 利用ChatGPT进行情节细化 情节的细化包括填充故事的细节，使故事更加生动和真实。以下
是一些利用ChatGPT细化情节的方法：
7.2.3.1 增加细节描述 在情节发展的各个阶段，细节描述能让读者更好地沉浸在故事中。通过向ChatGPT提出具体的问题，可以获得丰富的细节。
Prompt: 详细描述一下机器人失控的场景，包括周围环境和人物反应。 ChatGPT的回答可能会包括：
环境描写，如实验室的布置、机器人工作的背景音。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26cc906c575194c9c489f4f4550faa81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c49295718c90afb940354bf951722734/" rel="bookmark">
			C/C&#43;&#43;内存管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
​编辑
一、C/C++内存分布
二、C语言中动态内存管理方式
【面试题】
三、C++中动态内存管理
3.1 new、delete操作内置类型
3.2 new和delete操作自定义类型
四、operator new与operator delete函数
五、new和delete的实现原理
5.1 内置类型
5.2 自定义类型
六、定位new表达式(placement-new)
七、常见面试题
7.1 malloc/free和new/delete的区别
7.2 内存泄漏
7.2.1 什么是内存泄漏，内存泄漏的危害
7.2.2 内存泄漏分类
7.2.3 如何检测内存泄漏
7.2.4如何避免内存泄漏
一、C/C++内存分布 我们先来看看下面的一段代码和相关问题：
int globalVar = 1; static int staticGlobalVar = 1; void Test() { static int staticVar = 1; int localVar = 1; int num1[10] = { 1, 2, 3, 4 }; char char2[] = "abcd"; const char* pChar3 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c49295718c90afb940354bf951722734/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8056f0a7798ece8e8ac6173908b911a4/" rel="bookmark">
			社区版/专业版pycharm利用python对MySQL数据库操作：配置数据库、创建自己的数据库、导入数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第一步 找到并配置MySQL数据库第二步 建立数据库并导入数据文件==这是社区版创建数据库步骤：==打开终端，进入mysql命令窗，创建数据库更改路径 ==这是专业版创建数据库步骤==查询控制台，创建数据库并命名 导入数据文件[如果你已经创建好了数据库,社区版/专业版都可按照如下步骤导入数据文件] 第一步 找到并配置MySQL数据库 [默认已下好了MySQL，如果没下好请查阅其他教程下载，这里不会展示]
两种方式找pycharm中数据库：
第一种：在右边侧栏处
第二种：“View” 菜单，选择 “Tool Windows”，然后选择 “Database”
这里我用的是专业版pycharm，如果是社区版推荐看看以下网址：
pycharm（社区版）如何添加database工具_pycharm怎么加载已经手动database navigator-CSDN博客
专业版和社区版链接数据库步骤如下：
社区版会有些许不同，但步骤几乎一致，故本篇不做展示
如图：
进入以下界面：
这里第一步就完成了。
不知道user那里该填什么的看这个网址：
只需三步—教你如何查看自己的mysql的用户名和密码_查看mysql账号密码-CSDN博客
第二步 建立数据库并导入数据文件 这是社区版创建数据库步骤： 如果是社区版pycharm推荐网址:
Pycharm + python + sqlite3 创建数据库，并实现增删改查
社区版前期步骤：
上面这个网址是基于sqlite3，而我这里用的是Mysql，所以我也做一下社区版的步骤，专业版请看点击跳转
打开终端，进入mysql命令窗，创建数据库 如图
输入：
mysql -uroot -p 如上图，输入你设定的MySQL密码，接着创建你要创建的数据库名，例如我是mydatabase
create database mydatabase 更改路径 [上面流程没有问题的请略过这步→点击跳转]
这里提一下有些人的MySQL路径存在问题，所以在终端输入MySQL会报错，这里提供更改路径的方法[仅限Windows]：
跟着步骤没找到系统属性的，请自行网上查阅，且以上仅供参考，确实不会的话跟老师或身边其他人请教。
路径配置好后回到终端输入上诉代码即可创建数据库点击跳转
这是专业版创建数据库步骤 查询控制台，创建数据库并命名 建好之后看回数据库，右键刷新，看看是否有创建的数据库文件了
导入数据文件[如果你已经创建好了数据库,社区版/专业版都可按照如下步骤导入数据文件] 接着创建一个.py文件，这里是我导入数据的展示代码：
#导入数据到数据库 import pandas as pd import mysql.connector mydb = mysql.connector.connect( host="localhost", user="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8056f0a7798ece8e8ac6173908b911a4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/287/">«</a>
	<span class="pagination__item pagination__item--current">288/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/289/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>