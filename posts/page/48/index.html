<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61a64edf835c17c7ccec270545df226e/" rel="bookmark">
			Codeforces Round 966 (Div. 3)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A. Primary Task 简单的模拟题，按照题意模拟即可
#include "bits/stdc++.h" using namespace std; #define int long long #define endl '\n' #define IOS ios::sync_with_stdio(0),cin.tie(0); #define all(x) x.begin(),x.end() #define all2(x) x.begin()+1,x.end() #define pi pair&lt;int,int&gt; #define vi vector&lt;int&gt; #define vc vector&lt;char&gt; #define si set&lt;int&gt; #define mi map&lt;int,int&gt; #define mc map&lt;char,int&gt; #define YES cout&lt;&lt;"Yes"&lt;&lt;endl; #define NO cout&lt;&lt;"No"&lt;&lt;endl; #define pb(x) push_back(x) #define fi first #define sc second #define is insert template&lt;class T&gt;bool chmin(T &amp;a, const T &amp;b) { if (b&lt;a) { a=b; return true; } return false; } template&lt;class T&gt;bool chmax(T &amp;a, const T &amp;b) { if (a&lt;b) { a=b; return true; } return false; } const int INF =1e18; void solve() { string s; cin&gt;&gt;s; int n=s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61a64edf835c17c7ccec270545df226e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a23971eb3975fc2f771b6788f4fb705/" rel="bookmark">
			拒绝内卷：利用4P营销理论打造汇报PPT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当下的职场文化里，越来越激烈的“内卷”现象普遍存在。随着不得已的竞争压力、加班文化、以及技能和学历的通货膨胀，越来越多职场人不惜加大工作负荷和劳动投入。但这种过度的付出往往并未带来成比例的回报，有时还会因为过度工作而导致生产力的降低和资源的不必要浪费。
在职场多方面压力的挑战下，打工人们迫切需要掌握更系统的思维方法，以便高效、精准地定位工作中的难题和关键点。此外，他们同样寻求智能化的工作辅助工具来增强生产力。在不懈努力地充实自我和提升能力的同时，他们也在探索如何在职业发展与个人生活之间找到一个和谐的平衡点。
一、思维模型：4P营销理论 4P营销理论，作为20世纪60年代美国营销领域的创新成果，以其四个基本策略的组合——产品（Product）、价格（Price）、推广（Promotion）、渠道（Place）——构成了一个全面而精炼的营销策略模型。这四个要素的英文首字母均为"P"，因此被简称为"4P's"，它们共同支撑起一个强有力的营销策略体系。该理论的起源可追溯至1953年，当时尼尔·博登（Neil Borden）在美国市场营销学会的就职演讲中首次提出了"市场营销组合"（Marketing Mix）这一术语。
4Ps营销理论为打工人提供了一个全面的市场营销分析框架，从老板的角度出发，将影响市场营销活动的因素分精准、快速聚到工作汇报中。具体表现为：
产品策略（Product Strategy）：在工作汇报中，管理者需重点介绍企业如何通过产品策略满足目标市场需求。这包括对产品的品种、规格、设计、质量、包装、特色、商标、品牌，以及相关的服务措施等元素的精心组合与运用，确保产品能够吸引并满足消费者。定价策略（Pricing Strategy）：在定价策略的工作汇报中，应详细说明企业如何依据市场规律来制定和调整价格，以实现营销目标。这涉及到基本价格设定、折扣、津贴、付款条件、商业信用政策，以及各种定价方法和技巧的运用。分销策略（Placing Strategy）：在分销策略的工作汇报中，管理者需要阐述企业如何选择和优化分销渠道，组织商品流通，以高效地将产品送达消费者手中。这包括渠道选择、商品流转、中间商管理、销售网点布局，以及储存和运输等可控因素的策略运用。宣传策略（Promoting Strategy）：在宣传策略的工作汇报中，要展示企业如何运用各种信息传播工具来激发消费者的购买意愿，推动产品销售。这包括广告、人员推销、营业推广和公共关系等促销手段的综合运用。 通过这四个策略的综合运用，企业能够在工作汇报中清晰地展示其市场营销活动的全貌，评估当前的营销成效，并为未来的市场策略调整提供决策支持。这种结构化的工作汇报方式有助于管理层深入理解市场动态，优化资源配置，提升企业的市场竞争力。
二、AI一键生成汇报PPT 即便手头掌握了构建汇报PPT的思维框架，职场人员在实际工作中，若想输出一份既条理分明又逻辑严谨、精致美观的演示文档，依然需要耗费巨大的时间和精力进行撰写和细节打磨。不少在业务执行和沟通协调上表现卓越的员工，常常发现自己深陷于持续的文案工作中，PPT的编制过程不仅占据了他们大量的工作时间，有时还不得不因此加班到深夜。
采用人工智能技术的AI一键生成PPT工具，为演示文稿的快速制作提供了强有力的支持。这种工具通过深度学习和复杂的算法训练，能够迅速洞察并响应用户需求，自动设计出与汇报主题完美融合的幻灯片模板。它整合了文本、图像、数据图表等多种相关的元素，使得汇报内容的呈现更加生动、直观。通过AI的辅助，汇报准备工作变得更加高效，同时保证了汇报材料的专业度和吸引力，大大缩短了从构思到完成的周期。这里就为您推荐两款实用的AI一键生成PPT工具：
1）轻竹PPT 点击链接直达官网&gt;&gt;https://qzoffice.com/
轻竹PPT是一款面向国内用户群体的智能演示文稿制作工具，它能够通过用户简短的指令，在短短10秒内快速生成多种风格、设计精美的PPT。无论是进行行业分析、撰写工作总结还是制作教育课件，轻竹PPT都能提供高效的解决方案。
通过PPTAI一键生成技术，轻竹AI PPT生成器提供了一个革命性的三步流程，迅速自动创建演示文稿。用户只需输入演示的核心主题，该工具就能在几秒钟内智能制定PPT提纲和文案，并实现自动化的精美排版。
轻竹PPT的一键生成PPT功能，允许用户通过文本输入或上传Word/PDF文档，利用AI技术将文档内容转化为演示文稿格式。
轻竹PPT的文档转PPT服务具有以下特色：
智能PPT生成：快速根据主题生成PPT，简化了传统PPT制作的复杂性。简化工作流程：用户界面友好，操作直观，加速了PPT的制作和下载过程。合规内容生成：结合清华AI技术，确保所有生成内容都符合国内市场的规范和法规要求。AI辅助演讲稿：智能撰写演讲稿，助力用户提升公开演讲的流畅度和影响力。格式广泛兼容：生成的PPT支持.pptx格式，确保了与主流办公软件的兼容性，并允许用户进行进一步的编辑和定制。 2）Gamma Gamma产品的一系列特色使其成为市场上的佼佼者：
独到的设计理念：Gamma的设计美学别具一格，对细节的精心打磨为用户呈现了一场视觉盛宴。素材库的深度与广度：提供了一系列多样化的Block素材，Gamma在素材的丰富度和排版的灵活性上超越了Notion，满足了不同用户的需求。高效的协作机制：Gamma的多人协作功能让团队成员能够同时编辑和共享文档，极大提高了团队的工作效率。直观的目录导航：Gamma的PPT目录结构设计直观易懂，与普通文档的融合使用户的操作体验更加流畅。追求卓越的精神：Gamma超越了传统工具的范畴，它代表了对设计和用户体验的持续追求，为用户提供了一种前所未有的演示文稿创作体验。 在当下的职场文化里，越来越激烈的“内卷”现象普遍存在。随着不得已的竞争压力、加班文化、以及技能和学历的通货膨胀，越来越多职场人不惜加大工作负荷和劳动投入。但这种过度的付出往往并未带来成比例的回报，有时还会因为过度工作而导致生产力的降低和资源的不必要浪费。
在职场多方面压力的挑战下，打工人们迫切需要掌握更系统的思维方法，以便高效、精准地定位工作中的难题和关键点。此外，他们同样寻求智能化的工作辅助工具来增强生产力。在不懈努力地充实自我和提升能力的同时，他们也在探索如何在职业发展与个人生活之间找到一个和谐的平衡点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ac92ea85436cbccbdc5d0145dd4c62e/" rel="bookmark">
			Linux云计算 |【第二阶段】OPERATION-DAY2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要内容： 部署LNMP架构（linux、Nginx、MariaDB、PHP）、Nginx+FastCGI动静分离、Nginx地址重写
环境准备：还原配置文件
[root@proxy ~]# cd /usr/local/nginx/ [root@proxy nginx]# sbin/nginx [root@proxy nginx]# cp conf/nginx.conf.default conf/nginx.conf cp：是否覆盖"conf/nginx.conf"？ y [root@proxy nginx]# sbin/nginx -s reload [root@proxy nginx]# sbin/nginx -V configure arguments: --prefix=/usr/local/nginx --user=nginx --with-http_ssl_module 环境准备：如果Nginx异常，需要按照以下方式重新创建
[root@proxy nginx]# /usr/local/nginx/sbin/nginx -s stop [root@proxy nginx]# cd ~/lnmp_soft/nginx-1.17.6/ [root@proxy nginx-1.17.6]# killall nginx [root@proxy nginx-1.17.6]# rm -rf /usr/local/nginx/ [root@proxy nginx-1.17.6]# make install [root@proxy nginx-1.17.6]# cd /usr/local/nginx/ [root@proxy nginx]# ls conf html logs sbin [root@proxy nginx]# sbin/nginx -V configure arguments: --prefix=/usr/local/nginx --user=nginx --with-http_ssl_module 一、LNMP概述 前言：目前的网站一般都会有动态和静态数据，默认nginx 仅可以处理静态数据，用户访问任何数据都是直接返回对应的文件，如果访问的是一个脚本的话，就会导致直接返回一个脚本给用户，而用户没有脚本解释器，因此需要整合LNMP（Linux、Nginx、MySQL、PHP）实现动态网站效果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ac92ea85436cbccbdc5d0145dd4c62e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2fdf92f239506541ecc0403b2972cc8/" rel="bookmark">
			2024年电赛H题全开源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当题目出来的的那一刻，看到了M0芯片，我们实验室只有一块板子，并且我没有接触过M0，电赛只准备了TI的MSP430f5529。但是我并没有放弃，决然的选择了H题。基本上将四问全做出来，可是测试由于使用了感为科技的寻迹模块，因此只测试了题目的第一问。
一、元器件选择 小车底盘我们选择了轮趣科技的MG310电机，加48mm的轮子。
控制MCU选择M0G3507
寻迹感为科技的寻迹
角度传感器采用JY61P
PCB开源地址：
代码开源链接：Gitee
三、题目规划与思路 题目主要就是小车需要再没有黑线的地方固定一个角度走直线，在黑线部分进行寻迹，因此我们使用角度传感器获取角度数据，采用PID控制让小车走直线到达黑线七点，再采用寻迹PID使小车寻到黑线末端。
OLED负责显示菜单，便于我们控制小车执行任务
角度传感器和MCU之间采用串口通讯获取角度数据
四、问题分析与解决 由于角度采用PID控制，但是角度传感的值是从-180到+180,这虽然是线性数据，但是当小车在运动旋转180度之后角度会从-180直接变为180，这使得我们无法进行PID控制。解决的方法就是，将角度值转化弧度值，因为sin-180=sin180,这样角度数据就连续起来了。
小车停止位置采用距离控制停止不准确的问题，最终方案是当小车寻不到黑线时我们就认为到达A,B,C,D四个点。
五、总结 在制作小车过程中虽然遇到了很多困难与挫折但是我们要坚持下来，解决问题才是根本，有错误必有源头，顺着错误找源头才是正解！
代码地址：empty_LP_MSPM0G3507_nortos_ticlang · fighter/电子设计大赛 - 码云 - 开源中国 (gitee.com)
视频链接：【fighter】视频已打包，欢迎围观！_哔哩哔哩_bilibili
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a838faf28e32218f4ea4b88264e93f20/" rel="bookmark">
			【安卓】Service的基本用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Service简介启动和停止ServiceActivity和Service进行通信 Service简介 新建一个ServiceTest项目，然后右击com.example.servicetest→New→Service→Service。
每个Service中最常用到onCreate()、onStartCommand()和onDestroy()这3个方法其中onCreate()方法会在Service创建的时候调用，onStartCommand()方法会在每次Service启动的时候调用，onDestroy()方法会在Service销毁的时候调用。
另外需要注意，每一个Service都需要在AndroidManifest.xml文件中进行注册才能生效。
启动和停止Service 修改activity_main.xml中的代码。
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;Button android:id="@+id/startServiceBtn" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="Start Service" /&gt; &lt;Button android:id="@+id/stopServiceBtn" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="Stop Service" /&gt; &lt;/LinearLayout&gt; 修改MainActivity中的代码。
public class MainActivity extends AppCompatActivity implements View.OnClickListener { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button startService = (Button) findViewById(R.id.startServiceBtn); Button stopService = (Button) findViewById(R.id.stopServiceBtn); startService.setOnClickListener(this); stopService.setOnClickListener(this); } @Override public void onClick(View v) { switch (v.getId()) { case R.id.startServiceBtn: Intent startIntent = new Intent(this, MyService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a838faf28e32218f4ea4b88264e93f20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce27da054836f4fa77e2ba1ae2742a04/" rel="bookmark">
			【C语言篇】C语言常考及易错题整理DAY1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 C语言常考及易错题整理选择题全局、局部和静态变量#define与typedef转义字符操作符循环其他 编程题计算日期到天数转换柯尼希定理旋转数组的最小数字描述错误的集合整数转换密码检查 C语言常考及易错题整理 选择题 全局、局部和静态变量 执行下面程序，正确的输出是： int x=5,y=7; void swap() { int z; z=x; x=y; y=z; } int main() { int x=3,y=8; swap(); printf("%d,%d\n"，x, y); return 0; } 答案解析：
正确答案：3,8
swap函数调用时用的是全局变量，主函数中定义的变量只在主函数中有效，因为主函数也是一个函数，它与其他函数是平 行关系；输出语句这里，考虑局部优先的原则
如下函数的f(1)的值为： int f(int n) { static int i = 1; if(n &gt;= 5) return n; n = n + i; i++; return f(n); } 答案解析：
正确答案： 7
此题注意静态局部变量的使用，static改变了i的生命周期，第一次调用函数：i初值是1，递归第二次调用函数时，i还是第一 次那个变量，值已经变成了2，再一次调用函数时i就是3，依次类推
以下程序的输出结果为： #include &lt;stdio.h&gt; int i; void prt() { for (i = 5; i &lt; 8; i++) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce27da054836f4fa77e2ba1ae2742a04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caaadd23bacae4c301e0f82b8f927dd1/" rel="bookmark">
			ubuntu 24.04 安装 Nvidia 显卡驱动 &#43; CUDA &#43; cuDNN，配置 AI 深度学习训练环境，简单易懂，一看就会！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu 24.04 安装 Nvidia 显卡驱动 + CUDA + cuDNN，配置 AI 深度学习训练环境，简单易懂，一看就会！ 1.查看本机显卡型号 lspci | grep -i nvidia 输出如下：
01:00.0 3D controller: NVIDIA Corporation GM108M [GeForce 920MX] (rev a2)
其中，GeForce 920MX就是我们的显卡型号。
2.下载 Nvidia 显卡驱动 官网：点击此处下载NVIDIA驱动
根据显卡型号搜索驱动：
选择查找
下载最新版驱动
3.安装显卡驱动 安装编译环境
sudo apt update sudo apt install gcc make 运行安装程序
chmod +x NVIDIA-Linux-x86_64-560.31.02.run sudo ./NVIDIA-Linux-x86_64-560.31.02.run 选择“Continue installation”，回车
进入编译中…
注意：在这里编译时会出现编译错误而中断，原因是下载的显卡驱动是最新的，需要用较高的 gcc 版本编译器来编译，默认 gcc 的版本是 11，小于编译所需要的 12 版本。因此需要安装 12 版本的，并调整 gcc 链接。
sudo apt install gcc-12 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/x86_64-linux-gnu-gcc-12 20 重新运行安装程序：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/caaadd23bacae4c301e0f82b8f927dd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/131e867c2b7400fcecd7ceadf2056e94/" rel="bookmark">
			用Python实现9大回归算法详解——02. Lasso 回归算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Lasso 回归的基本概念 Lasso 回归（Least Absolute Shrinkage and Selection Operator）是一种线性回归模型，通过引入 正则化（也称为 Lasso 正则化），在训练模型的同时对系数进行约束。Lasso 回归不仅能够避免过拟合，还能够自动进行特征选择，通过将一些不重要的特征的系数缩减为零，从而简化模型。
Lasso 回归的目标是最小化以下损失函数：
其中：
是第个样本的实际值。 是第个样本的预测值。是模型的回归系数。是样本数。 是特征数。 是正则化参数，用于控制 正则化项的强度。 2. Lasso 回归的数学表达 Lasso 回归的损失函数可以分为两部分：
最小化残差平方和（即最小二乘项）： 2. 正则化项：用于惩罚模型的复杂度，具体为范数：
因此，Lasso 回归的目标是找到一组回归系数 ，使得上述损失函数最小化。
3. Lasso 回归的作用 Lasso 回归的主要作用包括：
减少模型复杂度：通过正则化，Lasso 回归能够控制模型的复杂度，减少过拟合的风险。特征选择：Lasso 回归会自动将不重要的特征的系数缩减为零，从而实现特征选择。 4. Lasso 回归的优化问题 Lasso 回归的优化问题可以表示为：
该优化问题通常通过坐标下降法（Coordinate Descent）来求解。
5. Lasso 回归案例 接下来，我们通过一个具体的案例来展示如何使用 Lasso 回归进行建模，并对结果进行详细分析。
5.1 数据准备 我们将使用一个模拟的数据集，其中包含多个特征和目标变量。我们会人为地加入一些噪声，增加特征选择的难度。
import numpy as np import pandas as pd from sklearn.model_selection import train_test_split from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/131e867c2b7400fcecd7ceadf2056e94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d854b322328022317d467bcfd14f173f/" rel="bookmark">
			WPF Border 妙用，切图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;Window x:Class="WpfDemo.MainWindow" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:d="http://schemas.microsoft.com/expression/blend/2008" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:local="clr-namespace:WpfDemo" mc:Ignorable="d" Title="Window1" Height="650" Width="650"&gt; &lt;WindowChrome.WindowChrome&gt; &lt;WindowChrome NonClientFrameEdges="None" UseAeroCaptionButtons="False"/&gt; &lt;/WindowChrome.WindowChrome&gt; &lt;Grid &gt; &lt;Grid.Background&gt; &lt;RadialGradientBrush GradientOrigin="0.8,0.8" Center="0.8,0.8" RadiusX="0.7" RadiusY="1"&gt; &lt;GradientStop Color="#103156" Offset="0"&gt;&lt;/GradientStop&gt; &lt;GradientStop Color="#141627" Offset="1.5"&gt;&lt;/GradientStop&gt; &lt;/RadialGradientBrush&gt; &lt;/Grid.Background&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height="50"&gt;&lt;/RowDefinition&gt; &lt;RowDefinition&gt;&lt;/RowDefinition&gt; &lt;/Grid.RowDefinitions&gt; &lt;Path Data="M0 0 0 35 200 35 C 210 35 210 35 218 38 C 226 46 226 46 236 46 L406 46 C414 46 414 46 422 38 C430 35 430 35 440 35 L640 35 640 0"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d854b322328022317d467bcfd14f173f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37b265cc8b4fe67c2cf81c67cf1e2a08/" rel="bookmark">
			docker数据卷和资源控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
数据卷
实现数据卷
宿主机和容器之间进行数据共享
容器与容器之间进行数据共享
容器互联
docker容器的资源控制
cpu
1.设置cpu资源控制（比重）
2. 设置cpu的资源占用比（权重）
3.设置容器绑定cpu
内存
1.内存限制
磁盘
1.磁盘读写速度的限制
2.磁盘的读写次数限制
清理docker的磁盘空间的命令
练习
数据卷 数据卷的目的：
1. 实现容器和宿主机之间数据共享：数据卷又叫挂载卷，就是把容器内的目录和宿主机的目录进行挂载，实现数据文件共享
2. 为了保证数据的持久化：容器的生命周期有限，一旦重启，所有对容器内部文件数据的修改以及保存的数据都会被初始化，所以为了防止数据修饰，重要的组件一定会做数据卷。
实现数据卷 宿主机和容器之间进行数据共享 创建宿主机与容器之间的数据卷
docker run -itd --name test1 -v /opt/test1:/opt/test2 centos:7 /bin/bash
-v 指定
注意点：
1. 左边的test1是宿主机目录 ，右边的test2是容器内的目录
2. 加不加 / ，都是目录，而不是文件。如果不存在，宿主机和容器都会自动创建目录
3. 以宿主机的目录为标准，同步的是宿主机目录的内容到容器内
4. 挂载之后，容器内的目录的权限默认是读写权限都有
设置容器内的数据卷目录只读权限
docker run -itd --name test1 -v /opt/test1:/opt/test2:ro centos:7 /bin/bash
容器与容器之间进行数据共享 容器之间会需要共享数据，最简单的方法就是使用数据卷容器。可以提供容器内的一个目录，专门用来供其他容器进行挂载。
docker run -itd --name test1 -v /opt/test1 -v /opt/test2 centos:7 /bin/bash 在容器内部创建两个目录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37b265cc8b4fe67c2cf81c67cf1e2a08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d969a0ac93796f5de7023a1c227941de/" rel="bookmark">
			IOS 03 纯代码封装自定义View控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本节将通过纯代码进行封装自定义View控件，以常用的设置页的item为例，实现UI效果如下：
1、创建SettingView继承自UIView import UIKit class SettingView: UIView { } 2、重写 init() 和 required init?(coder: NSCoder) 方法 纯代码创建SettingView会执行到init()，而required init?(coder: NSCoder)则是用于可视化布局时，所以两个方法都必须重写。
import UIKit class SettingView: UIView { init() { super.init(frame: CGRect.zero) innerInit() } required init?(coder: NSCoder) { super.init(coder: coder) innerInit() } func innerInit() { } } 3、约束设置 当视图加入父视图时，才能进行约束设置，故需要重写 didMoveToSuperview()，并在didMoveToSuperview()方法里面编写约束设置。
import UIKit class SettingView: UIView { init() { super.init(frame: CGRect.zero) innerInit() } required init?(coder: NSCoder) { super.init(coder: coder) innerInit() } func innerInit() { } /// 当视图加入父视图时 / 当视图从父视图移除时调用 override func didMoveToSuperview() { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d969a0ac93796f5de7023a1c227941de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b202958dc4493241254be8f4a816685/" rel="bookmark">
			贪心算法介绍（Greedy Algorithm）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		贪心算法介绍（Greedy Algorithm） 1. 贪心算法概念简介 ​ 贪心算法Greedy Algorithm是一种在每一步选择中都采取当前状态下最优（或最有利）决策的算法策略，以期望通过这样的局部最优决策达到全局最优解。它适用于那些具有最优子结构的问题，即问题的最优解包含其子问题的最优解。贪心算法的关键在于它做出的选择是不可逆的，一旦选择了某个选项，就不会再回溯考虑其他选项。
通过示例来感受贪心算法的思想 有一堆不同大小的饼干，大小分别为 1, 3, 2, 4, 5。而面前有一群孩子，胃口也不一样。每个孩子的胃口代表了他们最小能接受的饼干大小，比如说，有的孩子最少要吃一个大小为 3 的饼干才能满足。
目标是尽可能多地满足孩子们的胃口。
饼干大小：3, 2, 1, 4, 5
孩子胃口：3, 2, 4
贪心算法的过程 排序：将饼干和孩子的胃口从小到大排序。
饼干：1, 2, 3, 4, 5孩子：2, 3, 4 逐步计算选择最小的满足：
第一个孩子胃口为 2，直接选择大小为 2 的饼干满足他。第二个孩子胃口为 3，直接选择大小为 3 的饼干满足他。第三个孩子胃口为 4，直接选择大小为 4 的饼干满足他。 结果：你成功地满足了 3 个孩子。贪心算法通过每一步都做出当前看起来最好的选择（用最小的饼干去满足最小的胃口），得出了一个不错的结果。
使用非贪心算法的思维来解决的方式
动态规划的过程（非贪心算法） 状态定义：
创建一个二维数组 dp[i][j]，表示用前 i 个饼干去满足前 j 个孩子能达到的最大满足数。 初始化：
dp[0][0] = 0 表示没有饼干和没有孩子时，满足的孩子数为 0。 状态转移：
当不使用当前饼干：dp[i][j] = dp[i-1][j]当使用当前饼干（前提是饼干大小满足孩子的胃口）：dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + 1) 逐步计算：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b202958dc4493241254be8f4a816685/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5849b6ba2f0af9da3d571c93459fdcc/" rel="bookmark">
			MTF-SFR总结/探讨
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		空间频率响应（SFR）定义 在iso12233:2000中，空间频率响应（SFR）测量被定义为通过分析倾斜黑白边缘附近的相机数据而测量的值。
SFR概念理解 SFR算法的计算具体流程：
可以看到，SFR的具体步骤就是上面的九大步骤，箭头中对应的是每一步执行前后对应的输入和输出。
总结如下：
0、获取垂直斜边的ROI：这里水平和垂直的Edge只是为了计算图像在水平方向和垂直方向的解析力，与算法本身无关，因为水平的Edge会被进行90°旋转后作为输入，然后计算SFR的值。
1、进行数据的归一化：一般sensor会对raw图像进行一个2.2的gamma变换，若我们想恢复原始图像时，我们只需要进行一个1/2.2的gamma变换即可。
2、计算图像每一行的像素矩心：这一步的操作其实是为了计算出边缘的位置。具体讲来就是，我们会将图片中的每一行像素都计算具体的矩心位置。可以看到，其实每一行像素的矩心计算出来的结果，其实就是在黑白分界线的附近。
3、对每行的矩心使用最小二乘法进行线性拟合，获得一条关于矩心的直线：根据你计算出来的那么多个矩心的点，然后获取分界边缘的直线表达式。最后获得的其实就是上面的图中那条红色的线，略微有差距，可是基本上可以说是完全一致的了。
4、重新定位ROI，获得ESF：转换坐标轴，将坐标轴转换到计算出来的矩心直线上
5、对获得的ESF进行四倍超采样：然后将每一行中X轴坐标相等的像素值累加起来，然后求均值后得到下面第一行的数组。
6、通过差分运算获得LSF：得到的ESF数组元素进行差分，获得LSF
7、对LSF应用汉明窗：对上面的LSF数组进行汉明窗处理，这一步主要也是看公式，如下：
8、进行DFT运算：图是具体的DFT公式表达，下图是代码中的计算过程，最后的到的SFR数组就是空间频域响应的值。
图像清晰度测试方法 通过ISO12233测试图像清晰度的方法，一般有 TVline测试和SFR测试两种。
当使用SFR测试时，也就是测试斜边（刀口），需要 选择黑色和白色交界的区域，一共需要测10次，中间横向，中间纵向，四角的横向纵向。
MTF调制传递函数定义 MTF算法是分析镜头解像能力的算法，其全称是Modulation Transfer Function(调制传递函数)。为了理解这个，首先需要知道什么是调制Modulation。
如何计算一台相机的调制传递函数：(就是根据分析同一相机在不同空间频率下的成像效果(MTF值)得到一个函数)
MTF的计算就是计算线对间最亮和最暗线对的对比度。(计算过程：相机在空间频率A下成像的图片,读取其最亮值和最暗值)
计算公式为:
MTF = (最大亮度 - 最小亮度) / (最大亮度 + 最小亮度)
得到的MTF值就是该相机位于空间频率A的解析力.---- 多个不同的空间频率下的MTF值组成一组曲线就能得到该相机的MTF曲线,
经过数学处理就能得到该相机的MTF函数(调制传递函数)
这样的话就是说我们计算MTF需要计算不同的空间频率下的响应值,对应的是不是你该拍多张图片呢?这样是不是很不方便呢?
------接着就推出了SFR(空间频率响应)
SFR(空间频率响应)：根据数学理论推导,人们发现只需要一个黑白的斜边（刀口）即可换算出约略相等于所有空间频率下的MTF。
如何从MTF曲线中读取镜头分辨率： 人眼最低能识别的反差是0.05，一般选定MTF=0.05时的空间频率值为目视分辨率；如下紫色曲线的镜头分辨率是70lp/mm,红色曲线镜头分辨率是100lp/mm；
分辨率单位、换算及镜头与感光器像素的匹配 总结：
线对每毫米(lp/mm)，
L/mm：lines per millimetre。每毫米线数，和LP/mm类似，但仅表示线。
周期每毫米（cycles/mm）,
周期每像素（cycles/pixel），
线宽每图像高（LW/PH Line Widths per Picture Height），
线对每图像高（lp/ph）
其中lp/mm是目前使用最多的单位。cycles/pixel是在数码相机中的成像系统的。数码相机下一个像素就是1 cycles/pixel，两个像素就是0.5 cycles/pixel，4个像素是0.25 cycles/pixel.
1、分辨率单位：
1-1、lp/mm（line-pairs/mm）：每毫米线对，表示黑白两条线；
常用于 表示镜头分辨率的单位， 指成像平面1mm间距内能分辨开的黑白相间的线条对数；
l/mm：每毫米线数，表示1条线，lp/mm=2 x l/mm；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5849b6ba2f0af9da3d571c93459fdcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70fa692d6692121df16c5f71f17e4528/" rel="bookmark">
			python从入门到精通：基础语法讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、字面量 字面量：在代码中，被写下来的固定的值，称之为字面量。
python中常用的几种数据类型：
类型描述说明数字（Number） 整数（int）
浮点数（float）
复数（complex）
布尔（bool）
整数（int）：10，-10
浮点数（float）：3.14
复数（complex）：3+4j，以j结尾表示复数
布尔（bool）表达现实生活中的逻辑，即真和假；
TRUE本质上是一个数字记作1，FALSE记作0
字符串（string）描述文本的一种数据类型字符串有任意数量的字符组成列表（List）有序的可变列表python中使用最频繁的数据类型，可有序记录一堆数据元组（Tuple）有序的不可变序列可有序记录一堆不可变的python数据集合集合（Set）无序不重复集合可无序记录一堆不重复的数据集合字典（Dictionary）无序Key-Value集合可无需记录一堆Key-Value型的python数据集合 字符串（string），又称文本，是由任意数量的字符如中文、英文、各类符号、数字组成。
比如："你好！"、"python"；字符串中，字符串需要用双引号(")包围起来，也就是说被引号包围的，都是字符串。
类型程序中写法说明整数10、-10与现实无异浮点数3.14、-5.2与现实无异字符串"你好！"程序中需要加上双引号以表示字符串 2、注释 在程序代码中对程序代码进行解释说明的文字；注释不是程序，不能被执行，只是对程序代码进行解释说明，让别人可以看懂代码的执行作用，能够大大增强程序的可读性。
· 单行注释：以#开头，#右边的所有文字当作说明，而不是真正要执行的程序，只是辅助说明。
# 在屏幕上打印出hello print("hello") # #与注释内容之间最好以一个空格隔开 · 多行注释：以一对三个引号引起来的("""注释内容""")来解释这一段代码的作用使用方法。
多行注释主要用于解释：1、整个python文件 2、类 3、方法。 3、变量 在程序运行时，能储存计算结果或能表示值的抽象概念，简单地说，变量就是在程序运行时，记录数据用的。
定义格式：
变量名称=变量的值
# 定义一个变量，用来记录钱包余额 money=100; # 输出变量记录的内容 print("余额还有:",money) # 花费10元买冰淇淋 money = money-10; print("余额还有:",money); 4、数据类型 主要接触的数据类型有三种：
类型描述说明int整型（有符号）数字类型，存放整数float浮点型（有符号）数字类型，存放小数string字符串类型用引号括起来的数据都是字符串 可以通过type( )来得到数据的类型。
# 通过print语句，直接输出类型信息 print(type(10)) print(type(3.14)) print(type("你好")); # str就是string的缩写 # 用变量存储type()的结果（返回值）： int_type = type(10) float_type = type(3.14) str_type = type("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70fa692d6692121df16c5f71f17e4528/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85a530d823d15ef47c6e872c96e7e349/" rel="bookmark">
			【C&#43;&#43;】使用哈希表封装unordered_map与unordered_set
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. unordered系列关联式容器1.1 unordered_set1.2 unordered_map 2. unordered_set/map的封装2.1 基本接口2.2 迭代器2.2.1 迭代器的结构2.2.2 set迭代器的封装2.2.3 map迭代器的封装 3.完整代码3.1HashTable3.2unordered_set3.3unordered_map 1. unordered系列关联式容器 在C++98中，STL提供了底层为红黑树结构的一系列关联式容器，在查询时效率可达到 l o g 2 N log_2 N log2​N，即最差情况下需要比较红黑树的高度次，当树中的节点非常多时，查询效率也不理想。最好的查询是，进行很少的比较次数就能够将元素找到，因此在C++11中，STL又提供了4个unordered系列的关联式容器，这四个容器与红黑树结构的关联式容器使用方式基本类似，只是其底层结构不同，本文中只对unordered_map和unordered_set进行介绍，
1.1 unordered_set unordered_set是以不特定顺序存储唯一元素的容器，并允许根据其值快速检索单个元素。在unordered_set中，元素的值同时是其键，它唯一地标识它。键是不可变的，因此，unordered_set中的元素在容器中不能被修改，但是它们可以入和删除。在内部，unordered_set中的元素不按任何特定顺序排序，而是根据其哈希值放到桶中，以便直接通过其值快速访问各个元素（平均平均时间复杂度恒定）。unordered_set容器通过其键访问单个元素的速度比set容器更快，尽管它们在通过其元素子集进行范围迭代时通常效率较低。 1.2 unordered_map unordered_map是存储&lt;key, value&gt;键值对的关联式容器，其允许通过key快速的索引到与其对应的value。在unordered_map中，键值通常用于唯一地标识元素，而映射值是一个对象，其内容与此键关联。键和映射值的类型可能不同。在内部，unordered_map没有对&lt;kye, value&gt;按照任何特定的顺序排序, 为了能在常数范围内找到key所对应的value，unordered_map将相同哈希值的键值对放在相同的桶中。unordered_map容器通过key访问单个元素要比map快，但它通常在遍历元素子集的范围迭代方面效率较低。unordered_maps实现了直接访问操作符(operator[])，它允许使用key作为参数直接访问value。 2. unordered_set/map的封装 2.1 基本接口 上一篇文章我们模拟实现了哈希表，在这里我们直接对其进行改造，将其封装为unordered_set/map。
由于我们的unordered_map与unordered_set使用的是一个哈希表，所以我们首先对哈希表的模板参数进行改造。
由于map是k、v模型，set是k，所以在哈希表那一层我们统一处理成T。
在哈希表内部使用key进行比较时，需要使用一个函数获得map与set的key。
所以，在哈希表中所有涉及使用T类型的data计算位置与比较的地方都得改。
unordered_map与unordered_set框架对比
由于一般key都是不允许修改的，所以这里set传递的是const K；map传的是pair&lt;const K,V&gt;
2.2 迭代器 2.2.1 迭代器的结构 对于哈希表而言，迭代器++应该指向当前桶的下一个元素，当前桶走完了就应该到下一个桶。
那如何弄清下一个桶在什么位置呢？
迭代器内部除了要有一个节点的指针，还应该有一个表的指针，在该表中可以找到桶的位置。
此时编译我们的代码，发现找不到node和table
Node和HashTable找不到是因为我们把它们的定义放在了HTIterator的后面，编译器只会向上找，所以我们可以把Node的定义放在它上面，但是HashTable的定义能放在它上面吗？
由于我们后期会在HashTable中使用HTIterator，它们两个是相互依赖的，谁定义在谁上面都不行。所以我们可以前置声明一下，同时注意声明与定义处的缺省参数不能同时有
operator++ 迭代器++时，要知道当前桶中还有没有元素，如果有元素，则指向下一个元素；如果没有元素，则指向下一个桶的第一个元素。
由于HtIterator内部要访问哈希表成员_table，但由于哈希表的成员_table是私有的，在外部无法访问。所以我们可将HTIterator设置为HahTable的友元类
Self&amp; operator++() { if (_node-&gt;_next)//当前桶还有元素 { _node = _node-&gt;_next; } else { KeyOfT kot; Hash hs; size_t hashi = hs(kot(_node-&gt;_data)) % _pt-&gt;_table.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85a530d823d15ef47c6e872c96e7e349/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e80b9c4261a45adc36e418ea68ec8498/" rel="bookmark">
			【现代通信技术】第四章 电路交换技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 电路交换系统的硬件功能结构 电路交换系统通俗来说就是电话交换机。可以大致分为人工交换系统和自动交换系统。
下面是最早的人工交换系统。 电路交换机控制呼叫有以下基本要求（接线员的工作流程）：
及时发现有呼叫请求的用户记录被叫用户话机的号码判别被叫用户当前的忙闲状态被叫空闲时，选择一条空闲的链路将主叫、被叫用户话机接通，使双方进入通话状态。通话结束时及时进行拆线释放处理。 由于这些工作相对机械，适合用计算机来代替，所以就有了自动交换系统——程序控制数字交换系统。
这里我们要结合电话交换机的特点，讲述用户电路模块以及数字交换网络模块。用户电路模块实现的是模拟话机与交换网络的接口电路，其功能可以总结为以下七项（BORSCHT）：
馈电 B（Battery Feeding）：在十年前，我们的家电里面肯定会有一个固定电话。电话机和其他用到的家用电器，如电冰箱等这些设备比较起来，不需要有一个插线将其插在插座上。因为它有个信号线，提供电流电压（外部供电）。过压保护 O （Over Voltage Protection）：既然能量是通过外面的交换机进行提供多个，因此，我们就需要防止外面的高电压进入话机——过压保护，常用的是一个二极管的前馈电路。振铃 R （Ringing）：如果我们现在有来电呼叫，我们需要有一个振铃信号进行提醒。监视 S（Supervision）：能够判定现在的用户话机是否有挂机等。编译码和滤波 C （CODEC &amp; Filters）：这个功能完成的是数模转换。混合电路 （二/四线转换） H （Hybrid Circuit）：混合电路的模拟信号，我们可以用两线进行双向传输。而对于数字信号PCM编码，我们所说的64kb/s的PCM编码，在去话上需要进行编码操作，在来话上需要进行译码操作。因此，用两线的传输不能完成这个操作，因此需要变成四线传输。测试 T （Test） 二、 电路交换系统的呼叫处理程序 我们都使用过固定电话，公用电话借助公共电话交换网（PSTN：public switched phone network）。我们在前面的时候讨论过电话交换的知识：
在PSTN网络中，固定电话的终端安装在用户处，通过有线电缆连接到电话端局的程控交换机上，电话端局之间听过高速中继线连接。程控交换机在用户侧连接了许多用户终端，程序交换机需要支持呼叫控制的基本功能。我们下面看一下程控交换机控制呼叫有哪些基本要求：
上述功能的实现，除了必要的硬件之外，还需要软件支持。软件支持可以划分为运行软件系统和支援软件系统。其中，运行软件系统又称为在线软件或联机软件，主要包括操作系统、呼叫处理和维护管理。
那么，固定电话是如何打通的呢？拨打电话的用户被称为主叫用户，接电话的用户被称为被叫用户。
当我们作为主叫用户时，会有怎样的动作。首先，我们要拿下电话的听筒，此时听筒下的插簧弹起，电话终端上的相应电路发生变化，导致电话终端和交换机连接的用户线上的电平发生变化。程控交换机周期性地扫描所有与之相连的用户线的电平状态，一旦有用户摘机，检测到有拨打电话的需求。然后会首先检查用户类型和状态，并随之准备合适的收号器，以便接收主叫用户播出的被叫用户号码。
当上述都准备好了之后， 交换机给主叫用户送拨号音，此时主叫用户就知道交换机准备好了，就可以进行拨号。
我们逐位进行拨号，在收到第一位拨号码之后，停止对用户送拨号音。 在收号的过程中就可以对被叫号码进行号码分析，根据号码的编号的规律，可以知道此次呼叫是长途、局内呼叫等不同类型。如果出现号码位数错误的情况，电话是无法接通的。当收到全部的号码之后。程控交换机进行完整的号码分析，检查是否允许接通或是否空闲。
如果被叫用户正在通话中，向主叫用户送忙音。如果被叫用户空闲，确定一条从主叫用户到被叫用户的完整路由，建立一条物理连接，预留足够资源接至被叫用户。在这个例子中，主叫用户和被叫用户都连接在一个程控交换机上，仅需要寻找程控交换机上内部的空闲通路即可。如果主叫用户和被叫用户连接在不同的程控交换机上，还需确定沿途转接的节点、出入用户线的路由信息。
接下来向被叫用户送振铃，电话机终端发出振铃响声，提示用户有被接电话；同时向主叫用户送回铃音，提示网络路由已接通，等待被叫用户接电话。
当被叫用户听到铃声听到铃音，摘机应答通话时，被叫用户的用户线电平也发生变化。被程控交换机发现，停止向被叫用户送振铃，也停止向主叫用户送回铃音。双方开始正常的通话过程，按照预留的时隙资源传输语音信息，网络运营商的计费模块开始相关程序。通话过程中，程控交换机负责监视主叫用户和被叫用户的状态。
在通话结束后，双方某一方先挂机。比如主叫用户先挂机，其用户线上的电平状态发生变化，与之相连的程控交换机不停的周期性扫描用户线，此时发现主叫用户已挂机，向被叫用户提示提示音及催挂音，停止计费，拆除之前建立的路由；被叫用户听到提示音之后，判断主叫用户已挂机，被叫用户随之挂机，用户线电平也发生变化，程控交换机据此发现被叫用户也已挂机。此次通信正式结束。
三、 智能网技术 听到 “ 智能网 ” 这个名词，我们首先想到的是“人工智能 ”，大家普遍认为人工智能将引领新一代的革命，从信息时代步入智能时代，而 “智能网” 中的智能并非 “人工智能”。
在呼叫处理程序中，我们普遍将计费管理固化在主叫用户流程中。
然而随着电话业务的不断发展，出现了一些新兴的业务类型，导致上述固化操作出现了问题。要想实现被叫方付费，需要修改计费管理模块。由于传统交换机中，呼叫处理流程和计费管理模块紧密绑定在一起，因此我们需要将整个网络需要改进。
我们发现，要想支持这些新的业务，最主要的改动都是要涉及到业务管理、用户管理和计费管理这些控制有关的模块。而对于呼叫过程中，传统的呼叫处理，例如通路选择、路由选择等这些功能其实改动不大。由于传统的交换机，把这些过程都固化在一起，导致网络改动困难。如果我们将两个模块分开，网络改动会相对简单，因此我们提出了 “智能网” 。
智能网（Intelligent Network）中的 “智能” 是相对于传统网，智能网能够快速、灵活、经济、有效地提供新业务。它依靠先进的七号信令协议和集中数据库实现，将传统交换机中呼叫处理和业务控制功能分离。
智能网中的功能模块
业务控制点 SCP信令转接点 STP智能外设点 IP业务管理系统 SMS业务生成环境 SCE业务数据库完成呼叫处理的设备称为业务交换点 SSP 上述功能模块，就可以组成一个典型智能网体系结构： 下面，我们以典型的800业务为例，完成一次呼叫。通过业务交换点SSP，通过用户扫描程序发现用户摘机，检查用户相关属性，一切正常后，给用户发送拨号音。用户收到拨号音后，开始拨号，交换机启动数字分析程序，发现本次用户拨打的是一个800业务。800-.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e80b9c4261a45adc36e418ea68ec8498/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bfc168075adff10ec653bc0b79fe772/" rel="bookmark">
			Java版分布式微服务云开发架构 Spring Cloud&#43;Spring Boot&#43;Mybatis 电子招标采购系统功能清单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目说明
随着公司的快速发展，企业人员和经营规模不断壮大，公司对内部招采管理的提升提出了更高的要求。在企业里建立一个公平、公开、公正的采购环境，最大限度控制采购成本至关重要。符合国家电子招投标法律法规及相关规范，以及审计监督要求；通过电子化平台提高招投标工作的公开性和透明性；通过电子化招投标，使得招标采购的质量更高、速度更快。过招投标文件电子化，节约招标成本，提升企业的资金节约率。
开发类型
电子招标采购软件
解决方案
招标面向的对象为供应商库中所有符合招标要求的供应商，当库中的供应商有一定积累的时候，会节省大量引入新供应商的时间。系统自动从供应商库中筛选符合招标要求的供应商，改变以往邀标的业务模式。招采工作完成对供应商进行评分，对不合格供应商进行拉黑；供应商报名、缴费以及投标、答疑等过程通过系统自助完成。以往线下存档资料管理困难，回溯项目过程不清晰，回溯过程复杂，现在通过线上存档的方式，存档方便，可以快捷高效的对以往招采项目进行回溯。
一、立项管理
1、招标立项申请
功能点：招标类项目立项申请入口，用户可以保存为草稿，提交。
2、非招标立项申请
功能点：非招标立项申请入口、用户可以保存为草稿、提交。
3、采购立项列表
功能点：对草稿进行编辑，驳回的立项编辑，在途流程查看。
二、项目管理
1、采购计划管理
功能点：采购计划新增、编辑、删除
2、采购过程管理
功能点：查询、维护基准价、组建评审小组、项目答疑澄清、文件费保证金审核、供应商报价维护、查看评审明细。
3、招标代理机构抽取
功能点：招标代理机构抽取
4、造价机构抽取
功能点：造价机构抽取
5、线下项目管理
功能点：新增、导入、删除、编辑。
三、采购公告管理
1、项目公告查询
功能点：招标类公告创建、非招标类公告创建、查看、编辑、提交审核、停用。
四、评审管理
1、项目评审
功能点：查询、评审人员提交评分。
五、考核管理
1、项目考核分派
功能点：查询、查看详情、发布考核、指派考核负责人。
2、项目考核查询
功能点：查询、查看详情、分配考核人。
3、项目考核
功能点：查询、查看详情、提交考核评分。
六、供应商企业中心
1、投诉建议
功能点：提交投诉建议
2、企业信息
功能点：修改企业信息
3、项目管理
功能点：查看公告、查看项目、下载标书、缴纳文件费、缴纳保证金、上传标书文件。
七、招标代理机构企业中心
1、基本信息
功能点：修改企业信息
2、项目管理
功能点：查看项目详情及状态
3、公告管理
功能点：招标类公告创建、非招标类公告创建、查看、编辑、提交审核、停用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/703d14e1b1978e12e572ce45badb93b6/" rel="bookmark">
			如何做好小程序评论优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用户在决定要不要用一个小程序时，往往会参考其他用户的评分和评论。因此小程序评论优化是提升用户互动和口碑传播的关键环节。以下是一些针对小程序评论优化的具体策略：
1. 优化评论区设计
确保用户能够轻松找到并访问评论区。可以在小程序的显眼位置设置评论入口，如页面底部或侧边栏。
优化评论输入框的用户体验，提供语音输入、表情符号、@提及等功能，使评论过程更加流畅和有趣。
展示清晰的评论列表，包括评论内容、时间戳、点赞数等信息，让用户能够方便地浏览和回复评论。
2. 提供高质量内容
发布有价值、有趣或引人入胜的内容，激发用户的评论欲望。这可以包括最新的活动信息、优惠折扣、使用教程等。
在内容发布时，可以通过提问或话题讨论的方式引导用户发表评论。例如，发布一篇关于新功能的介绍文章时，可以询问用户的使用感受或建议。
3. 激励机制
为发表评论的用户提供奖励，如积分、优惠券或抽奖机会。这可以激发用户的参与热情，提高评论数量和质量。
提供多种排序选项，如按照评分高低、时间、热度等。方便用户查看。
4. 及时回应和处理
对于用户的评论和反馈，应尽快给予回应。这可以展现商家的专业和责任心，提高用户的满意度和忠诚度。
对于负面评论或反馈，应保持冷静和礼貌的态度，积极与用户沟通并解决问题。这可以减少负面影响，并展示商家的诚意和担当。
5. 利用数据分析
利用数据分析工具跟踪用户评论的趋势和热点话题。这有助于了解用户需求和市场变化，从而调整内容和服务策略。
根据用户评论的反馈和建议，不断优化小程序的产品和服务。这可以提高用户满意度和留存率，从而带动更多用户发表正面评论。
6. 社交化推广
鼓励用户将自己的评论分享到社交媒体或好友群组中。这可以扩大小程序的曝光度和影响力，吸引更多潜在用户参与评论。
建立小程序的社群或粉丝群，定期举办线上活动或话题讨论。这可以增强用户之间的互动和归属感，提高用户的评论积极性。
综上所述，小程序评论优化需要从多个方面入手。通过综合运用这些策略和方法，可以提升用户互动和口碑传播效果，从而增强小程序的竞争力和市场地位。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92bb6e3f4923c4c538e7764c9d9b6bc3/" rel="bookmark">
			python爬虫爬取某图书网页实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 导入相应的库正确地设置代码的基础部分设置循环遍历遍历URL保存图片和文档全部代码即详细注释 下面是通过requests库来对ajax页面进行爬取的案例，与正常页面不同，这里我们获取url的方式也会不同，这里我们通过爬取一个简单的ajax小说页面来为大家讲解。（注：结尾附赠全部代码与详细注释） 导入相应的库 爬取数据必须有相应的库，这里我们使用爬虫脚本中常用的几个Python库：os.path、fake_useragent 和 requests。
1.os.path：
这个模块主要用于处理文件和目录的路径。它提供了一系列的功能来进行路径的拼接、拆分、查询等操作，以确保路径的跨平台兼容性（比如Windows和Unix/Linux系统的路径分隔符不同）。在爬虫中，os.path 通常用于构建本地文件系统的路径，以便保存从网络上下载的图片、文本数据等。 2.fake_useragent：
这个库用于生成随机的、看起来像是真实浏览器的User-Agent字符串。User-Agent是一个在HTTP请求中发送给服务器的头部信息，它告诉服务器发起请求的客户端（通常是浏览器）的类型、版本和操作系统等信息。在爬虫中，由于许多网站会检查User-Agent来识别爬虫请求并阻止它们，因此使用fake_useragent可以帮助爬虫绕过这种简单的反爬虫机制。 3.requests：
requests是Python中非常流行的HTTP库，用于发送HTTP/1.1请求。它提供了一个简单易用的API，用于处理各种HTTP请求，如GET、POST、PUT、DELETE等。在爬虫中，requests库是发送网络请求并获取响应的主要工具。它支持会话（Session）对象、HTTPS请求、文件上传、Cookie处理、重定向、连接池等功能，非常适合用于构建复杂的爬虫系统。 import os.path import fake_useragent import requests 正确地设置代码的基础部分 这里我们生成一个随机的User-Agent、检查并创建目录以便储存爬取的图片、以及打开（或创建）一个文本文件来保存数据。
import os.path import fake_useragent import requests # 判断是否是直接运行该脚本 if __name__ == '__main__': head = {"User-Agent": fake_useragent.UserAgent().random} if not os.path.exists("./biqugePic"): os.mkdir("./biqugePic") f = open("./biquge.txt", 'w', encoding='utf8') 设置循环遍历 循环遍历URL（这里为大家提供具体url的获取方法，并循环了1至9页的数据为大家做案例），并发送了带有随机User-Agent的GET请求。这是爬虫中常见的做法，用于从网站的不同页面获取数据。
for i in range(1, 10): url = f"https://www.bqgui.cc/json?sortid=1&amp;page={i}" resp = requests.get(url, headers=head) 首先进入网页，点击F12打开自定义与控制工具，点击fecth/XHR，此时显示部分为空白。
这个时候我们滚动鼠标滚轮，就会出现相应的url，这里的https://www.bqgui.cc/json?sortid=1&amp;page=2，其中尾部2表示滚轮页面第二页，想要获取1至9我们只需要进行一个简单的循环遍历即可。
遍历URL 遍历从URL获取的JSON响应，该响应包含多个项目。对于每个项目，您都提取了图片URL、文章名、作者和简介，并计划将这些信息打印到控制台以及下载图片和保存文本信息到文件。
for item in resp.json(): # 从每个JSON对象中提取所需的信息 img_url = item['url_img'] articlename = item['articlename'] author = item['author'] intro = item["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92bb6e3f4923c4c538e7764c9d9b6bc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba34e2055d3946da86bf0427c61db915/" rel="bookmark">
			相机光学（三十四）——色差仪颜色观察者视角
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.为什么会有观察者视角 颜色观察角度主要涉及到人眼观察物体时，‌视角的大小以及屏幕显示颜色的方向性对颜色感知的影响。‌
人眼观察物体的视角：‌在黑暗条件下，‌人眼主要依靠杆体细胞来分辨物体的轮廓，‌而杆体细胞分布在视网膜的中央凹的外围，‌这使得在黑暗条件下观察物体时形成了较大的张角。‌相比之下，‌在明亮条件下观察物体相当于观察远处的物体，‌形成了较小的张角，‌这主要由椎体细胞主导，‌它们主要分布在视网膜的中央凹附近。‌屏幕显示颜色的方向性：‌屏幕显示的颜色会随观看角度而改变，‌当颜色变化导致色差达到0.015时的角度被称为色视角。‌这意味着，‌从不同的角度观看同一屏幕时，‌可能会观察到颜色的变化，‌从而影响图像的整体质量。‌例如，‌当观看电视或液晶显示屏时，‌如果色视角性能较差，‌可能会导致色彩不鲜艳、‌画面模糊失真等问题。‌多角度测色色差仪：‌在工业领域，‌尤其是对颜色要求非常严格的行业（‌如汽车、‌家电、‌五金等）‌，‌多角度测色色差仪的研发尤为重要。‌这些仪器通常至少需要从3个不同的角度来测量颜色，‌而5个角度被认为是最佳实践。‌这有助于更准确地测量颜色，‌尤其是在金属漆等需要精确颜色匹配的应用中。‌ 综上所述，‌颜色的观察角度不仅受到人眼生理结构的影响，‌还与屏幕显示技术的色视角性能密切相关。‌在选购平板电视或理解色视角指标时，‌从不同角度观察画面色彩的变化可以帮助评估其色视角性能的高低。‌
2.色差仪的观察者角度 色差仪的观察者角度2°或10°什么区别？色差仪是一种模拟人眼看色的工具，其测量视角与人眼观察物体的视角具有一致性。为了统一颜色测量的观察者角度，CIE规定了两种视场角2°或10°。
颜色作为一个心理物理量，不仅与物体表面反射、透射或吸收，照明光源的相对光谱功率分布相关，也依赖于人眼对光的响应特性。为了精确定量的描述颜色，CIE提出了CIE1931标准色度学系统和CIE1964补充标准色度系统。我国的国家标准GB3977-19974也参照上述两个色度系统对颜色的表述和计算进行了规定。
CIE1931标准色度系统，规定了CIE1931标准色度观察者2°视场色匹配函数（或称 CIE1931光谱三刺激值），适用于1-4°视场范围，如下图所示的x（λ）、y（λ）、z（λ）。CIE1964补充标准色度系统，规定了CIE1964标准色度观察者色匹配函数，又称10°视场色匹配函数（或称CIE1964光谱三刺激值），适用于大于4°视场范围，如下图所示x10（λ）、y10（λ）、z10（λ）。
物体的大小会对人眼对颜色的识别产生影响，视角是一种张角，它是通过被观察对象的大小对人眼形成的。与人眼距离一定的物体，若物体的面积较大，则眼睛形成的张角也较大，物体在视网膜上的像就大，反之像就小。但是，我们用眼睛直接对纺织品的颜色进行评价时，通常观察的距离（约33cm）是固定的，此时视角的大小由试样的大小决定。颜色是由人眼的视觉系统的结构所决定的，视角的大小对颜色视觉也有重要的影响。
实验研究表明：在明亮的条件下，人眼观察物体时，主要起作用的人眼细胞是椎体细胞，它可以分辨物体的细节，不能分辨物体的轮廓，称为明视觉。在黑暗条件下，人眼观察物体时，主要起作用的细胞是杆体细胞，它可以分辨物体的轮廓，不能分辨物体的细节，称为暗视觉。椎体细胞主要分布在视网膜的中央凹附近，明亮的条件下观察物体相当于观察远处的物体，形成了较小的张角。杆体细胞分布在中央凹的外围，黑暗的条件下观察物体相当于观察近处的物体，形成了较大的张角。
当视场角为2°时，物体的像恰好落在视网膜的中心椎体细胞最密集的区域。如下图所示，观察者的不同视场角，观察远处和近处物体时，人眼不同功能细胞起到相对应的作用，在视网膜上得以成像。
CIE1931-XYZ标准观察者的各个参数，都是适用于 2°视场的中央观察条件（适用10-4°视场），此视场角下观察物体，主要是人眼的中央凹椎体细胞起作用。故小于 1°的极小视场的颜色观察和大于40的视场颜色观察条件，CIE1931-XYZ标准色度观察者不适用。因此，为了适应大视场的颜色观察，人们在大量实验的基础上，又建立了“CIE1964-XYZ 色度学系统”。
在“CIE1964-XYZ补色色度学系统”中观察被测物体，既覆盖了视网膜中心的椎体细胞，也覆盖了视网膜中央凹周围的杆体细胞，它适合于10°大视场。人的眼睛在2°的视场条件下，识别物体颜色的能力较低，在10°的视场条件下，判断颜色的精度和重现性较高。目前颜色测量大多采用，10°的视场。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/47/">«</a>
	<span class="pagination__item pagination__item--current">48/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/49/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>