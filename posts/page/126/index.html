<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fca6aaed56bfd7cdeda2dc563d1e499f/" rel="bookmark">
			集训 Day 3 总结 虚树 &#43; dfs tree &#43; 基环树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚树 虚树，顾名思义是 只关注原树上的某些 关键点，在保留原树祖孙关系的前提下建出的一棵边数、点数大大减少的树
适用于优化某些在整棵树上进行 d p dp dp、 d f s dfs dfs 的问题
通常是题目中出现多次询问，每次给出树上的一些关键点，同时保证 ∑ 关键点数 ≤ n \sum关键点数 \leq n ∑关键点数≤n ，很大可能就是建出虚树来处理
概括来说，虚树只进行两步操作 剪掉无用树枝 和 压缩树上路径
Warning 有一个常见误区：压缩树上路径 的含义
如图 ，只有红色是关键点，黑色加粗为虚树上的点
若是只压缩路径，那么完全可以 1 − &gt; 4 ， 1 − &gt; 6 1-&gt;4，1-&gt;6 1−&gt;4，1−&gt;6 连边 ，而不需要保留 4 , 6 4,6 4,6 的 lca 3 3 3 号点
为什么要这样保留呢？实际上，这保证了 虚树上的边对应原树上的路径是不交的
这个性质在后面题目中有大用
思想懂了，来看具体实现
build 建树 通常有两种建树方式，两次 s o r t sort sort 和 单调栈
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fca6aaed56bfd7cdeda2dc563d1e499f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d907b7c8abfbd43ff69bf07862255b9/" rel="bookmark">
			【2】Spring Cloud 工程搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎥 个人主页：Dikz12🔥个人专栏：Spring Cloud实战📕格言：吾愚多不敏，而愿加学欢迎大家👍点赞✍评论⭐收藏 目录
1.声明项目依赖和项目构建插件
2.完善子项目订单服务 2.1完善启动类和配置文件
2.2 业务代码
3.远程调用
3.1需求 ​3.2 实现
1.声明项目依赖和项目构建插件 把下面代码分别引入到两个子项目的pom.xml中. &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;includes&gt; &lt;include&gt;**/**&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 2.完善子项目订单服务 2.1完善启动类和配置文件 启动类 @SpringBootApplication public class OrderApplication { public static void main(String[] args) { SpringApplication.run(OrderApplication.class,args); } } 配置文件
在resource文件夹中建立,application.yml 文件.
server: port: 8080 spring: datasource: url: jdbc:mysql://127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d907b7c8abfbd43ff69bf07862255b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a37f0d85b45956865b2f2671e91e58d5/" rel="bookmark">
			Python爬虫实战案例（爬取图片）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爬取图片的信息 爬取图片与爬取文本内容相似，只是需要加上图片的url，并且在查找图片位置的时候需要带上图片的属性。
这里选取了一个4K高清的壁纸网站（彼岸壁纸https://pic.netbian.com）进行爬取。
具体步骤如下：
第一步依然是进入这个页面，这个壁纸网站分为好几种类型的壁纸图片，点击一个你想要爬取的类型，然后按F12，从中获取URL和请求方式（复制URL，会用到），这次就不用网页的"User-Agent’'了，用pycharm包中别人写好的。
然后发送我们的请求并获取这个网页的数据
# url url = "https://pic.netbian.com/4kmeinv/" # UA伪装 用下载好的库中别人写好的UA head = {"User-Agent": fake_useragent.UserAgent().random} # 发送请求 response = requests.get(url, headers=head) # 获取想要的数据 res_text = response.text 第二步打开元素栏，用左上角的寻找工具放在图片上，定位到元素栏中对应的标签，用数据分析的方法获取到图片信息。
其实每一张图片的排放就好像是一个个列表，其所有的信息都粗存在元素栏中的li标签中，我们想要获取多张照片，首先需要先将这些li标签都获取下来。
# 数据解析 获取所有的li标签，并存放在li_list中 tree = etree.HTML(res_text) li_list = tree.xpath("//div[@class='slist']/ul/li") 第三步获取图片与获取文本内容不同的是，需要再获取图片的url，图片的url就在上图箭头所指的位置，但是这个仅仅只是图片在这个板块的位置，所以前面需要在前面加上这个壁纸网站的地址，这样获取的图片信息才是完整的，可以被打开。
因为先前已经将存放图片信息的li标签都存放在了li_list中，所以我们就用for循环遍历这个列表，以便获取更多的图片信息。 for li in li_list: # 图片的url img_url = "https://pic.netbian.com" + "".join(li.xpath("./a/img/@src")) # 发送请求 img_response = requests.get(img_url, headers=head) # 获取想要的数据 img_content = img_response.content 第四步将获取到的图片存放在文件夹中 # pic_name = 0 这次的代码封装在函数中，将这个变量放在了函数外面，给获取的图片编号 # 将pic_name定义为全局变量，方便调用 global pic_name with open(f"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a37f0d85b45956865b2f2671e91e58d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9983189946d3c65fec2b6060d502e0a5/" rel="bookmark">
			生成式 AI 的发展方向，是 Chat 还是 Agent？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从社会需求角度 以及 chat 和 agent 长处 来讲 我的观点 未来 ai 的 chat 和 agent 的 其实都会大肆发展，只是未来大展身手的阶段不同，首先虽然 chat 各方面能力比 agent 弱 (很明显的就是 chat 是短记忆 ，agent是长记忆)，但是优点的 chat 的整体成本 比 agent 低
Ai 前期 阶段 chat 会更适合普通民众 使用消费，前期 阶段 chat 会大肆分布，完整的 agent 可能基本在实验继续研发中，但是可能会发布 agent 的部分功能出来给 民众 试用测试 ，
Ai 中期 阶段 发展 chat 的使用群体可能依然较为庞大，这个阶段可能 agent 完整版出来了参与商业应用了，agent 可能的主要商业应用：企业定制、私人定制、通用非定制，但是毕竟成本高，价格上可能是无法普及了，可能这个阶段的 非定制售卖价格可能都只高不低 Ai 后期 阶段 这个阶段 AI 发展比较成熟了，可能已经 推出 便宜 可 普及 的 agent ，这个时候 agent 会大面积取代掉 chat，chat 虽然前中期普及很高 用户群体庞大 ，但是如果 chat 不爆改优化 后续 完全 被 agent 取代 是必然的结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9983189946d3c65fec2b6060d502e0a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab1223db435bc98d082a995fa62480fe/" rel="bookmark">
			05 HTTP &amp; Tomcat &amp; Servlet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 HTTP1、简介2、请求数据格式3、响应数据格式 Tomcat1、简介2、基本使用3、Maven创建Web项目4、IDEA使用Tomcat Servlet1、简介2、方法介绍3、体系结构4、urlPattern配置5、XML配置 HTTP 1、简介 HTTP概念 HyperText Transfer Protocol，超文本传输协议，规定了浏览器和服务器之间数据传输的规则 数据传输的规则指的是请求数据和响应数据需要按照指定的格式进行传输如果想知道具体的格式，可以打开浏览器，点击F12打开开发者工具，点击Network来查看某一次请求的请求数据和响数据具体的格式内容在浏览器中如果看不到上述内容，需要清除浏览器的浏览数据。chrome浏览器可以使用ctrl+shift+Del进行清除所以学习HTTP主要就是学习请求和响应数据的具体格式内容 HTTP协议特点 基于TCP协议: 面向连接，安全
TCP是一种面向连接的(建立连接之前是需要经过三次握手)、可靠的、基于字节流的传输层通信协议，在数据传输方面更安全基于请求-响应模型:一次请求对应一次响应HTTP协议是无状态协议:对于事物处理没有记忆能力。每次请求-响应都是独立的
无状态指的是客户端发送HTTP请求给服务端之后，服务端根据请求响应数据，响应完后，不会记录任何信息 优点:速度快缺点：多次请求间不能共享数据
可以使用会话技术(Cookie、Session)来解决这个问题 2、请求数据格式 格式介绍
请求数据总共分为三部分内容，分别是请求行、请求头、请求体 请求行: HTTP请求中的第一行数据 请求行包含三块内容分别是 GET[请求方式] /[请求URL路径] HTTP/1.1[HTTP协议及版本]请求方式有七种,最常用的是GET和POST 请求头: 第二行开始，格式为key: value形式 服务端可以根据请求头中的内容来获取客户端的相关信息有了这些信息服务端就可以处理不同的业务需求请求头中会包含若干个属性，常见的HTTP请求头有:Host: 表示请求的主机名 User-Agent: 浏览器版本,例如Chrome浏览器的标识类似Mozilla/5.0 ...Chrome/79，IE浏览器的标识类似Mozilla/5.0 (Windows NT ...)like Gecko； Accept：表示浏览器能接收的资源类型，如text/*，image/*或者*/*表示所有； Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页； Accept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate等。 请求体: POST请求的最后一部分，存储请求参数
GET请求请求参数在请求行中，没有请求体，POST请求请求参数在请求体中GET请求请求参数大小有限制，POST没有 3、响应数据格式 格式介绍
响应数据总共分为三部分内容，分别是响应行、响应头、响应体
响应行：响应数据的第一行
（1）响应行包含三块内容
（2）分别是 HTTP/1.1[HTTP协议及版本] 200[响应状态码] ok[状态码的描述]响应头：第二行开始，格式为key：value形式
（1）响应头中会包含若干个属性响应体： 最后一部分。存放响应数据
（1）响应体和响应头之间有一个空行隔开 响应状态码
状态码大全：https://cloud.tencent.com/developer/chapter/13553 Tomcat 1、简介 Web服务器
Web服务器是一个应用程序（软件）
（1）对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让Web开发更加便捷
（2）主要功能是"提供网上信息浏览服务" Web服务器软件使用步骤
准备静态资源下载安装Web服务器软件将静态资源部署到Web服务器上启动Web服务器使用浏览器访问对应的资源 Tomcat
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab1223db435bc98d082a995fa62480fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fa5217edd47c4df82f5886f7bb7a2e2/" rel="bookmark">
			数据结构之初始二叉树（4）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找往期文章包括但不限于本期文章中不懂的知识点：
个人主页：我要学编程(ಥ_ಥ)-CSDN博客
所属专栏：数据结构（Java版）
二叉树的基本操作
二叉树的相关刷题（上）通过上篇文章的学习，我们简单的了解了二叉树的相关操作。接下来就是有关二叉树的经典题型练习。
二叉树的相关刷题（上）
上一篇也是有关二叉树的经典题型。沿着上篇接着开始学习。
目录
二叉树的前序遍历
二叉树的层序遍历
二叉树的层序遍历 II
从前序与中序遍历序列构造二叉树
二叉树的最近公共祖先
根据二叉树创建字符串
二叉树的前序遍历 题目：
给你二叉树的根节点 root ，返回它节点值的 前序 遍历。
示例 1：
输入：root = [1,null,2,3] 输出：[1,2,3] 示例 2：
输入：root = [] 输出：[] 示例 3：
输入：root = [1] 输出：[1] 示例 4：
输入：root = [1,2] 输出：[1,2] 示例 5：
输入：root = [1,null,2] 输出：[1,2] 提示：
树中节点数目在范围 [0, 100] 内-100 &lt;= Node.val &lt;= 100 这个题目如果用递归去做那就比较简单了，但是现在我们要采用非递归的方法来写。
思路：利用栈，将遍历到的所有根结点都入栈（以前序遍历的路线去走） ，并且将这些节点都放入List当中。当遇到 null 时，就开始出栈顶的元素，并且以栈顶元素的 right 指针来重新遍历这棵树，直至栈为空即可。
代码实现：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fa5217edd47c4df82f5886f7bb7a2e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa6e87a29943ee1c403a5ee9f40eeb9a/" rel="bookmark">
			5.波士顿房价预测（KNN，决策树，线性回归）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		波士顿房价预测 1. 机器学习中的任务分类2. 波士顿房价预测2.1 分析数据2.2 比较 MAE 和 MSE2.2 代码 1. 机器学习中的任务分类 有监督学习（supervised）：有特征也有标签 分类问题 classification预测离散量 回归问题 regression预测连续量 无监督学习（unsupervised）：无监督学习 聚类算法 KMeans 降维算法 PCA 自监督学习： 大模型预训练，使用自监督输入文本，自己挖空填空 2. 波士顿房价预测 2.1 分析数据 观察数据，最后一列代表房价，是连续量，所以房价预测是一个回归问题。
24.00
21.60
34.70
33.40
36.20
28.70
22.90
27.10 2.2 比较 MAE 和 MSE 这里模型的评估与分类问题不同，此处采用的是平均方差误差；MAE 平均绝对误差 指的是计算 （预测值-真实值） 的 平均值 ，这种方法可以直观地感受到误差的大小，也有实际的物理意义，更便于理解。但是绝对值会导致函数出现 不可导点 ，这将会给后续的计算带来很大麻烦；MSE 平均平方误差 就是 计算 （预测值-真实值） 的 平方 的 平均值， 这样得到的结果并无实际意义，但是解决了不可导点的问题，从计算角度来讲，更容易求导，简化了计算。虽然我们无法从 MSE 的数值上直接得到有效信息，但是却可以通过比较来评估模型的好坏，信息是在比较中产生的。 2.2 代码 加载和拆分数据 X=[] y=[] with open('housing.data',mode='r',encoding='utf8') as f: for line in f: line = line.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa6e87a29943ee1c403a5ee9f40eeb9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5b4037974583761c74a3da44cccf7a3/" rel="bookmark">
			人工智能学习笔记 - 初级篇Ⅱ - 图形可视化 - 第2节-简单的正弦图和余弦图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信公众号：御风研墨
关注可了解更多。问题或建议，请公众号留言
文章目录 步骤1: 导入必要的库步骤2: 生成数据点步骤3: 绘制正弦图和余弦图步骤4: 添加图表元素步骤5: 显示图表 最后 为了创建一个既适合初学者也对中高级用户有价值的介绍文档，我们将通过一个示例来展示如何使用 matplotlib库在Python中绘制简单的正弦图和余弦图。这个示例将包含详细的代码解析，包括中英文注释，以帮助理解每一步的作用。 步骤1: 导入必要的库 首先，我们需要导入绘图所需的库。matplotlib.pyplot是一个非常流行的绘图库，它提供了一个类似于MATLAB的绘图框架。numpy是一个科学计算库，我们将使用它来生成数据点。
import matplotlib.pyplot as plt # 导入matplotlib.pyplot用于绘图 import numpy as np # 导入numpy用于数学运算 步骤2: 生成数据点 接下来，我们将生成x轴的数据点，以及对应的正弦和余弦值作为y轴的数据点。
x = np.linspace(0, 2 * np.pi, 100) # 生成从0到2π的100个点 y_sin = np.sin(x) # 计算每个点的正弦值 y_cos = np.cos(x) # 计算每个点的余弦值 步骤3: 绘制正弦图和余弦图 现在，我们使用plt.plot函数来绘制正弦和余弦曲线。
plt.plot(x, y_sin, label='Sine') # 绘制正弦曲线，并添加图例标签'Sine' plt.plot(x, y_cos, label='Cosine') # 绘制余弦曲线，并添加图例标签'Cosine' 步骤4: 添加图表元素 为了使图表更加易于理解，我们添加标题、图例和轴标签。
plt.title('Sine and Cosine Graphs') # 添加图表标题 plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5b4037974583761c74a3da44cccf7a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5f0215783e7785916531243560f03c6/" rel="bookmark">
			数据结构之栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		栈 首先宏观上是在干什么？ 概念 栈：⼀种特殊的线性表，其只允许在固定的⼀端进⾏插⼊和删除元素操作。进⾏数据插⼊和删除操作 的⼀端称为栈顶，另⼀端称为栈底。栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则。
压栈：栈的插⼊操作叫做进栈/压栈/⼊栈，⼊数据在栈顶。
出栈：栈的删除操作叫做出栈。出数据也在栈顶。
栈底层结构选型
核心原则：后来者居上
其次有哪些假设？ 栈的实现可以用哪个数据结构实现？ 栈的实现⼀般可以使⽤数组或者链表实现，相对⽽⾔数组的结构实现更优⼀些。因为数组在尾上插⼊ 数据的代价⽐较⼩。
栈的实现 入栈 代码如下：
// ⼊栈 void STPush(ST* ps, STDataType x) { assert(ps); //1.判断空间是否足够 if (ps-&gt;capacity == ps-&gt;top) { int newCapacity = ps-&gt;capacity == 0 ? 4 : 2 * ps-&gt;capacity; STDataType* tmp = (STDataType*)realloc(ps-&gt;arr, newCapacity * sizeof(STDataType)); if (tmp == NULL) { perror("realloc fail!"); exit(1); } ps-&gt;arr = tmp; ps-&gt;capacity = newCapacity; } //空间足够 ps-&gt;arr[ps-&gt;top++] = x; } 和写顺序表进行插入数据的操作非常的相似
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5f0215783e7785916531243560f03c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4915619c39851f77ace7a6efb0fb5ee2/" rel="bookmark">
			详解数据结构之二叉树(堆)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		详解数据结构之二叉树(堆) 树 树的概念 树是一个非线性结构的数据结构，它是由 n(n&gt;=0)个有限节点组成的一个具有层次关系的集合，它的外观形似一颗倒挂着的树，根朝上，叶朝下，所以称呼为树。每颗子树的根节点有且只有一个前驱，可以0个有多个后继。
如图：这两颗树就不是树形结构，子树是不会相交的，除根节点外每个节点有且只有一个父节点，一颗有n个节点的树有n - 1条边。
根节点
根节点没有前驱节点，如图：9为根节点。 父节点：若一个节点含有子节点，则称这个节点为字节的的父节点，如图9为12个父节点。
子节点/孩子节点：一个节点含有父节点那这个节点就为孩子节点，如图12.
节点的度：一个节点右多少个孩子节点那他的度就为多少。
树的度，为最大节点的度，如上图，12这个节点的度为3，它是最大的，那他就为树的度。 树的层次：从根开始定义为第一层，根节点的子节点为第二层，以此类推。
树的深度、高度：树的最大层次，如图，树最大有4层，那树的深度为4。
叶子节点：度为0的节点为叶子节点。
分支节点：度不为0的节点。
兄弟节点：具有相同父节点的节点互称为兄弟节点。
节点的祖先：从根到该结点所经分⽀上的所有结点
所有节点的祖先为根节点 节点的子孙：以某结点为根的⼦树中任⼀结点都称为该结点的⼦孙
除根节点外所有节点是根节点的子孙。 森林：由m颗不相加的树的集合（m &gt; 0）。
二叉树 在树形结构里最常用的就是二叉树，一颗二叉树是节点的有限集合，该集合右一个根节点加上两颗左子树和右字树组成或者为空。
二叉树形态：
空二叉树只有一个根节点根节点只有左子树根节点只有右子树根节点有左右子树 二叉树的特点： 二叉树不存在度大于2的节点二叉树的节点有左右之分，次序不能颠倒，而二叉树又是有序树 特殊二叉树： 满二叉树 满二叉树是节点总数满足 2^k - 1（k为树的最大层数）的树，每一层的节点个数都达到最大值。
完全二叉树： 完全二叉树：对于一颗具有n个节点的二叉树按层序编号，如果编号为i（1 &lt;= i &lt;= n）的节点与同样深度的满二叉树中编号为i的节点在二叉树中的位置完全相同，这颗二叉树称为完全二叉树。
例如：
序号为2的节点没有右节点而序号为3的节点先有了序号为5、6的节点此时它们的序号与上图的完全二叉树序号并不相同，那它就不是完全二叉树。
正确的完全二叉树：
判断完全二叉树时，可以先按照当前二叉树的层次画一个或着心里想一个满二叉树，判断对应位置上的序号大小是否一致。
完全二叉树的性质：
叶子节点只能出现在最后两层最下层的叶子节点一定集中在左部连续的位置倒数第二层有叶子节点那他一定在右部连续位置 二叉树的性质 二叉树总节点个数：深度为k的二叉树具有，n = 2^k - 1个节点
二叉树第i层的节点个数：第i层的节点有，2^(i-1) 个。
对应具有n个节点个数的二叉树对应的深度为：k = logn + 1，底数为2
堆 堆，将一个元素集合k里，所有数据按照完成二叉树的存储方式存储。
这里的堆是基于顺序存储结构实现，因为堆是一种要求严格的二叉树，在节点的顺序上，必须是从左孩子节点开始放数据，不会允许一个节点先有右孩子节点，而没有左孩子节点。
有了这种特殊的限制，在数组里就可以利用节点所对应的下标来寻找对于的父亲节点，孩子节点。‘
对于具有 n 个结点的完全⼆叉树，如果按照从上到下从左到右的数组顺序对所有结点从 0 开始编号，则对于序号为 i 的结点有：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4915619c39851f77ace7a6efb0fb5ee2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54d5e67cc71671b62bbeec514802e050/" rel="bookmark">
			【Spring Boot】网页五子棋项目中遇到的困难及解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、HikariPool-1 - Starting异常二、Invalid bound statement (not found)异常三、The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary异常四、The server time zone value时区报错异常五、补充知识点：component注入的默认单例 问题现象：数据库连接正常，但是返回数据为空，并出现以下日值，但是多试几次又能查询数据库了，那时候没注意到日志中的没出现sql的查询字段以为是HikariPool-1 - Starting…1搞得鬼就上网去查，发现依然没有结果返回，然后把日志全看了一遍，压根就没有出现数据库连接的字段，我就知道应该是数据库连接出问题了，然后通过test测试数据库连接，结果爆红显示Invalid bound statement (not found)springboot错误，又上网去查，一一对比以后发现我的数据库映射并没有问题，然后提示我文件可能被过滤掉了等一系列问题… 一、HikariPool-1 - Starting异常 问题描述：
服务启动正常，但是使用功能要访问数据库时，控制台出现如下情况，一直 Startingcom.zaxxer.hikari.HikariDataSource : HikariPool-1 - Starting…1
问题排查
通过客户端连接数据库，访问正常。
网上搜索说是加个 useSSL=false ，但是还是不行。
url: jdbc:mysql://127.0.0.1:3306/java_gobang?characterEncoding=utf8&amp;useSSL=false 然后也让我学习到了SSL(Secure Sockets Layer)，安全套接字协议。在连接Mysql时,
如果MySQL的版本为5.7以上时，必须加上useSSL=false，直接通过用户账号和密码进行连接MySQL数据库；当MySQL的版本是5.7以下则不进行要求，默认使用useSSL=false。
useSSL=false:使用用户账号密码进行连接。
useSSL=true:y一般通过证书或者令牌进行安全验证。
不在yml配置中添加就默认的为true，则无法连接数据库成功。
二、Invalid bound statement (not found)异常 Invalid bound statement (not found)springboot或者Mybatis下找不到的几种情况
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54d5e67cc71671b62bbeec514802e050/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d99be161b95c30b8354ca31bdafa3ad2/" rel="bookmark">
			【Spring Boot】网页五子棋项目实现，手把手带你全盘解析（长达两万3千字的干货，坐好了，要发车了......）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 网页五子棋项目一、项目核心流程二、 登录模块2.1 前端输入用户信息2.2 后端进行数据库查询用户信息 三、 游戏大厅模块3.1 前端通过Ajax请求用户数据，后端从Session中拿取并从数据库中查询后返回3.2 前后端建立WebSocket连接，并进行判断，同时后端进行用户在线处理3.3 前端利用WebSocket发送按钮信息，后端进行等级队列的处理和维护游戏房间 四、游戏对局模块4.1 前端构造新的WebSocket连接,后端在等待两名玩家同时连接上服务器后开始游戏4.2 前端通过监听用户落子的下标返回给后端,后端维护一个二维数组来进行判断胜负并返回给前端 网页五子棋项目 一、项目核心流程 用户管理：使用服务器实现用户注册、登录功能，以及用户信息的管理，包括用户的天梯分数记录和比赛场次记录；
实时游戏互动：利用WebSocket技术实现客户端和服务器之间的实时通信，确保玩家的移动可以立即被对方看到，并由服务器进行处理；
匹配对战系统：设计一个机制以匹配具有相似技能水平的玩家进行对战。涉及到用户评分系统和等待室的实现，以便玩家可以根据自己的排名找到合适的对手；
游戏逻辑：使用服务器处理用户请求、维护游戏状态、执行匹配算法、管理用户会话以及提供必要的游戏逻辑支持，包括棋盘的初始化、落子规则的执行、胜负条件的判断以及棋局的更新显示；
界面设计：使用HTML、CSS和JavaScript技术构建用户友好的游戏界面，包括棋盘的可视化、棋子的放置和游戏状态的反馈；
数据库交互：使用数据库管理系统存储用户信息、游戏记录和其他相关数据，并提供数据的增删改查功能；
在接下来的流程中,我将项目分为了三个板块进行讲解,这样有利于大家的理解,分别是:
登录模块游戏大厅模块游戏对局模块 在这三个模块中以第一个模块最为简单，大家可以先提前适应一下，在2和3模块将会给大家上难度了
二、 登录模块 这个最为简单，只需要前端进行输入用户信息，后端进行数据处理并返回用户信息，前端以后端返回的数据为基础来判断是否要进行跳转进入游戏大厅界面。
前端输入用户信息，并判断数据正确性进行跳转后端进行数据库查询用户信息 2.1 前端输入用户信息 进行前端的界面构建，并提示用户输入信息
前端代码如下
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;登录&lt;/title&gt; &lt;link rel="stylesheet" href="css/common.css"&gt; &lt;link rel="stylesheet" href="css/login.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="nav"&gt; &lt;h3 class="pa"&gt;五子棋对战&lt;/h3&gt; &lt;/div&gt; &lt;div class="login-container"&gt; &lt;!-- 登录界面的对话框 --&gt; &lt;div class="login-dialog"&gt; &lt;!-- 提示信息 --&gt; &lt;h3&gt;登录&lt;/h3&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d99be161b95c30b8354ca31bdafa3ad2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c25791d1f81f6e2a1630a77f8dd3aabd/" rel="bookmark">
			nfs和web服务器的搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（一）web服务器的搭建 1.配置基本环境 要点有，yum源，包含nginx和阿里云（或者腾讯云或者华为云），这里的相关知识可以参考之前的yum配置笔记
2.安装nginx yum -y install nginx
3.验证并且开启服务 查看我们是否安装成功了，如果成功了就打开服务
4.验证nginx服务界面 5.修改nginx配置文件 找到配置文件并且修改
配置文件存放于/usr/share/nginx/html/中
首先进入到该目录
其中的index.html 就是我们看到的网页文件
然后从物理机下载几个图片和视频做一个测试，看能否显示
这里采用直接从物理机向我们虚拟机拖拽的方法，比较快速
但是需要软件包，需要先下载
yum -y install lrzsz
然后直接拖拽
就有了这两个文件
然后进入到配置文件当中，修改我们的文件内容
加入选中部分的内容就可以了
此时再到物理机中的浏览器访问：192.168.1.120
就可以看到新的页面了
如果看不到页面是因为防火墙和selinux的关系，需要对其进行关闭
systemctl stop firewalld setenforce 0
还可以进行单点访问资源
（二）配置nfs服务器 1.环境的配置 需要的yum源，ip地址，dns都可以按照之前的去配置
然后记得关闭防火墙以及selinux
systemctl stop firewalld
setenforce 0
2.下载与安装 yum -y install nfs-utils.x86_64 rpcbind.x86_64 3.验证 查看一下安装的是否合适
4.创建一个目录文件，然后从web服务器里面拉取文件 scp root@192.168.1.120:/usr/share/nginx/html/1.png /share
scp root@192.168.1.120:/usr/share/nginx/html/2.mp4 /share
拉取完成之后再用tree查看一下
也没有任何问题
5.编辑/etc/exports文件 6.启动服务 7.查看端口服务 发现rpc端口号是111
8.去web机器挂载文件 首先创建一个挂载目录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c25791d1f81f6e2a1630a77f8dd3aabd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58001f37ad36f2b30f227c67a40360d3/" rel="bookmark">
			【算法/学习】前缀和&amp;&amp;差分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前缀和&amp;&amp;差分目录
1. 前缀和的概念及作用
🌈概念
🌈用途
🌙一维前缀和
🌙二维前缀和
2. 差分的概念及用途
🌈概念：
🌈用途
🌙一维差分
🌙二维差分
1. 前缀和的概念及作用 🌈概念 前缀和：
🎈对于一个给定的数列a，他的前缀和数中 s 中 s[ i ] 表示从第一个元素到第 i 个元素的总和。即s[ i ] = s[ i - 1 ] + a[ i ];
比如： s[ 1 ] = s[ 0 ] + a[ 1 ]。 注意：在使用前缀和和差分的时候，一般下标 0 不参与的运算，统一的将下表设置为从1开始，具体是要考虑到我们的边界问题，也就是S[1]的求法问题，为了保证我们循环的统一性，我们要将S[0]设置为0，所以我们索性就将下标从1开始设置起，这样也有利于我们后面的初始化。
🌈用途 可以用于一维前缀和和二维前缀和。
模板如下：
🌙一维前缀和 核心代码如下：
s[i] = s[i-1] + a[i] s[i] = a[1] + a[2] + .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58001f37ad36f2b30f227c67a40360d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6348c287d9c61da4f68f38e2ef5bdbe/" rel="bookmark">
			python-爬虫实例（2）：获取豆瓣小说分类界面的文本信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
道路千万条，安全第一条
爬虫不谨慎，亲人两行泪
获取豆瓣小说分类界面的文本信息 一、老规矩，先上代码和结果
二、爬虫四步走
1.进行UA伪装
2.获取url
3.发送请求
4.获取响应数据进行解析并保存
前言 道路千万条，安全第一条 爬虫不谨慎，亲人两行泪 获取豆瓣小说分类界面的文本信息 一、老规矩，先上代码和结果 import requests import fake_useragent from lxml import etree import time head = { "User-Agent": fake_useragent.UserAgent().random # 随机生成一个User-Agent } def pa(): for j in range(0, 100, 20): time.sleep(3) url = f"https://book.douban.com/tag/%E5%B0%8F%E8%AF%B4?start={j}&amp;type=T" response = requests.get(url, headers=head) douban_text = response.text tree = etree.HTML(douban_text) li_novel = tree.xpath("//ul[@class='subject-list']/li") # 获取所有ul标签下的li标签内容 for i in li_novel: # 遍历所获取的所有li标签 novel_name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6348c287d9c61da4f68f38e2ef5bdbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf94e036c6e29d735b760f62bb5570ca/" rel="bookmark">
			【MySQL进阶篇】存储对象：视图、存储过程及触发器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、视图 1、介绍 视图（view）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来定义视图的查询中使用的表（基表），并且是在使用视图时动态生成的。
通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。
2、操作语法 2.1、创建 CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT [WITH[CASCADED | LOCAL] CHECK OPTION]
2.2、查询 查看创建视图语句：SHOW CREATE VIEW 视图名称;
查看视图数据：SELECT * FROM 视图名称.....; 2.3、修改 方式一：CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT [WITH[CASCADED | LOCAL] CHECK OPTION]
方式二：ALTER VIEW 视图名称[(列名列表)] AS SELECT [WITH[CASCADED | LOCAL] CHECK OPTION]
2.4、删除 DROP VIEW [IF EXISTS] 视图名称; #创建视图 create or replace view stu_v as select id,name from student where id&lt;=10; #查询视图 show create view stu_v; select * from stu_v; select * from stu_v where id&lt;3; #修改视图 create or replace view stu_v as select id,name,no from student where id&lt;=10; alter view stu_v as select id,name from student where id&lt;=10; #删除视图 drop view if exists stu_v; 3、检查选项 create or replace view stu_v as select id,name from student where id&lt;=10; select * from stu_v; insert into stu_v values(5,'tom'); #视图并不存储数据，数据在基表当中存储，也就意味着我们插入的数据实际上是插入到student表当中了 insert into stu_v values(15,'tom'); #基表当中会包含这条数据，但是在查询视图时并不包含这条数据，这是因为在创建视图时指定了id&lt;=10，为了避免这种情况的发生可以加上检查选项 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf94e036c6e29d735b760f62bb5570ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/349f098d1498aa53cf10fb0e79b0e149/" rel="bookmark">
			【 C 】链表相关的项目（2.0）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备工作
首先弄几个可能会需要的头文件：
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; typedef int ADT; //定义自定义数据类型 ​ ​ 因为写的是关于链表的项目需要定义一个结构体：
//定义结构体 typedef struct N { ADT data; struct N *next;	}Node; ​ 定义有关链表的结构体：
​ //定义链表结构体 typedef struct { Node *head, *tail;//定义头尾指针 unsigned size;//定义变量 }List; ​ 初始化操作：
//初始化链表函数 List *init_list(List *lp) { lp -&gt; head = lp -&gt; tail = (void*)0; //头尾指针为空 lp -&gt; size = 0;//链表个数为0 return lp; } ​ 制作节点（这部分仅仅跟后面的几个操作有关）：
​//制作节点 Node *make_node(ADT d) { Node *np = malloc(sizeof(Node));//申请空间 if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/349f098d1498aa53cf10fb0e79b0e149/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b7c82e3191b5ab706a80664eaad8da9/" rel="bookmark">
			从报名到领证：软考中级系统集成项目管理工程师考试全流程指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文共计11564字，预计阅读38分钟。包括七个篇章：报名、准考证打印、备考、考试、成绩查询、证书领取及常见问题。
一、报名篇 报名条件要求： 1.凡遵守中华人民共和国宪法和各项法律，恪守职业道德，具有一定计算机技术应用能力的人员，均可根据情况报名参加相应专业类别、级别的考试。
2.获准在中华人民共和国境内就业的外籍人员及港、澳、台地区专业技术人员，可报名参加考试。
3.报考人员不受学历、资历、年龄的限制。
软考系统集成项目管理工程师报名不设学历与资历条件、年龄以及专业等要求限制，只要达到相应的技术水平就可以报考软考相应的级别，考生可根据自己的技术水平选择软考合适的级别与资格进行报考。
根据《计算机技术与软件专业技术资格考试暂行规定》第八条相关规定：凡遵守中华人民共和国宪法和各项法律，恪守职业道德，具有一定计算机技术应用能力的人员，均可根据本人情况，报名参加相应专业类别、级别的考试。考生可根据自己的技术水平选择合适的级别合适的资格进行报考，但一次考试只允许报考一种资格。
通过考试获得证书的人员，表明其已具备从事相应专业岗位工作的水平和能力，用人单位可根据工作需要从获得证书的人员中择优聘任相应专业技术职务（技术员、助理工程师、工程师、高级工程师）。
报名入口： 软考系统集成项目管理工程师报名入口：中国计算机技术职业资格网（http://www.ruankao.org.cn/）
报名流程： 软考系统集成项目管理工程师报名一般采用网络报名方式，部分地区还可以现场报名。采用网络报名方式地区的考生在报名期间进入中国计算机技术职业资格网，点击页面右下角的报名入口，进入计算机技术与软件专业技术资格（水平）考试网上报名平台，选择对应地区的报名入口，注册登录后即可报名。
1.进入报名入口
大部分地区报名入口为全国计算机技术与软件专业技术资格（水平）考试网上报名平台，少数地区为当地软考办网站，具体请按照各地报名通知为准。
2.选择对应地区
选择机构名称，也就是对应地区，于报名有效时间内，进入对应地区的报名入口。
3.注册登录
进入对应报名入口后，会显示考生登录界面，注册过的考生可以直接登录，没有注册过的考生请进行注册。登录成功后，选择立即报名。
4.报名系统流程
考生进入报名系统后，菜单栏会显示报名的各个流程。考生仔细阅读考生须知以及考试计划后，进行报名。请按系统要求填写报名信息以及个人电子照片，报名信息提交后，等待审核。
5.进行缴费
审核通过后，即可进行缴费；审核未通过，请根据提示修改信息再次提交。大部分地区可以网上缴费，少数地区需要现场缴费。
6.准考证打印
缴费成功后，请确认自己的报名状态是否成功。然后等待准考证打印时间即可，准考证一般在考前一周打印，请及时留意准考证打印动态，及时打印自己的准考证，届时查看自己的考场安排情况。
报名费用： 注：因各地考试政策时有变化，因此下表所列的报名价格仅供参考，大家需要以当地当年通知说明为准。
二、准考证打印 打印时间： 一般在考前一周内进行
打印入口： 中国计算机技术职业资格网，网站网址：http://www.ruankao.org.cn/。
打印流程： 1.登录中国计算机技术职业资格网网上报名系统（https://www.ruankao.org.cn/）；
2.点击网上报名系统下方的“准考证打印”栏目，进入准考证打印入口；
3.选择证件类型，填写姓名、证件号码、验证码查询打印。
打印要求： 准考证打印用A4纸进行，必须打印出照片。准考证照片颜色黑白或者彩色均可，无照片或自贴照片无效。
准考证是参加软考系统集成项目管理工程师考试的必须材料之一，参考人员在每场考试前20分钟凭本人纸质准考证和本人有效期内的身份证原件进入指定的考场参加考试，人员应如实在“考场签到表”上签到，经监考人员同意后进入考场，人员必须对号入座，并将准考证和有效证件放在考桌右上角，以备核对。人员应服从考场工作人员的管理，积极配合考场工作人员的各项监督和检查。
打印问题处理办法： 当无法打印出照片时，请尝试按下面步骤处理：
1.还原高级设置（在Internet Explorer浏览器的“工具”—“Internet Explorer选项”—“高级”—“还原高级设置”按钮）。
2.重置InternetExplorer设置（在Internet Explorer浏览器的“工具”—“Internet Explorer选项”—“高级”—“重置InternetExplorer设置”—右下角的“重置”按钮—“删除个性化设置”—“重置”）。
3.关闭所有浏览器页面，重新启动浏览器。
以上方法如还是无法打印出照片请更新浏览器版本，或更换电脑环境进行打印。
三、备考篇 首先分享一些我积累的学习资料，无偿，需要的进。
备考注意事项： 1.社会家庭压力；
为孩子树立学习榜样，创造家庭学习氛围；挖掘自身潜力，熟悉岗位专业职责，避免工作失误。
2.为升迁准备；
机会往往都是留给有准备的人！应该挣取的，就不要轻易放弃！先人一步，人生才能步步为赢！
3.系统学习；
认识新的知识领域，扩展思路，运用到实际工作中，提高生产效率。
4.个人兴趣
兴趣是我学习动力的源泉。
经验技巧： 做题时，看清楚否定词，谨防低级错误出现!
1.休息好，准备好。防止笔误！借用OFFICE工具进行计验证。
2.上午题最多60分钟内可以考完，剩余时间少量修改。一般马上会有题目及答案出来，可以再做一次题进行估分。
3.下午答完后，一定要检查，一定要检查，一定要检查！避免遗漏。
4.计算题一定做对!关键路径一定找对！PV＝？,AC＝？,EV=？一定要写清楚！一定要写清楚！一定要写清楚！
答题技巧： 1.将题解，全部电子化索引（方便搜索）
2.存在于选择题中的答案，也有可能是案例分析的知识点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b7c82e3191b5ab706a80664eaad8da9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dbfd3eb0056e1bcb262c151fa0efd90/" rel="bookmark">
			Java初识总结（java程序结构组成、代码运行、注释、关键字、标识符）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🥰欢迎关注，来和 小哇 一起进步！✊
🎉创作不易，请多多支持🎉
🌈感谢大家的阅读、点赞、收藏和关注💕
🌹如有问题，欢迎指正
程序结构组成 JAVA程序结构由以下三部分组成：
源文件：（*.java)
类：类中带有一个或多个方法，方法必须在函数内部声明
方法 ：在类中定义的函数
类存在于源文件中，方法存在于类中，语句存在于方法中。
在一个源文件中，只能有一个public修饰的类，源文件名字必须和public修饰的类的名字相同。
一个简单的main()方法：
public class HelloWorld{ public static void main(String[] args){ System.out.println("Hello,world");//Java中的标准输出 } } 运行后控制台就会打印 Hello,world。
main方法是java程序的入口方法，格式固定。 Java代码的运行 Java是一门半编译型半解释型语言。
编写好源程序后，先通过javac.exe编译程序把源文件进行编译，编译生成.class字节码文件(平台无关、面向JVM） 最后启动Java虚拟机来运行.class文件，此时JVM会将字节码转换为平台能够理解的形式来运行。
注释 Java中共有3种注释方法
单行注释 //……
多行注释 /*……*/
文档注释/**@version v1.0.0 @author will*/
文档注释可用来描述类、方法、接口的作用，可以被javadoc工具解析，生成一套以网页文件形式体现的程序说明文档。
关键字 具有特殊含义的标识符
标识符 用户给类名、方法名、变量名所取的名字
标识符不能是关键字，区分大小写。标识符中可以包含字母、数字、下划线_和$符号，但标识符不能以数字开头。
为了规范取名，类名最好采用大驼峰形式（每个单词首字母大写）、方法名和变量名采用小驼峰形式（首字母小写，后面单词首字母大写）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ba6f1c15d17c53cbefe6fe36275d044/" rel="bookmark">
			H3C与VPN高级应用（三）深入解析H3C与VPN高级应用：全面指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 深入解析H3C与VPN高级应用：全面指南引言一、VPN基本概念与原理1.1 VPN概述1.2 IPSec VPN与SSL VPN 二、H3C VPN解决方案2.1 H3C VPN简介2.2 H3C VPN设备类型 三、远程访问VPN——Easy VPN3.1 理论部分3.1.1 远程访问VPN原理3.1.2 IPSec VPN中的NAT豁免 3.2 实现部分3.2.1 ASA防火墙上的配置 四、应用案例解析4.1 应用案例一：路由器上实现远程VPN4.2 应用案例二：防火墙实现远程VPN 五、配置步骤详解5.1 路由器配置步骤5.2 防火墙配置步骤 六、总结 👍 个人网站：【洛秋资源小站】
深入解析H3C与VPN高级应用：全面指南 引言 随着企业信息化建设的不断深入，VPN（虚拟专用网络）技术已经成为连接分支机构、远程办公的重要工具。H3C作为网络设备领域的领导者，提供了丰富的VPN解决方案和应用案例。本篇博客将详细探讨H3C与VPN的高级应用，涵盖理论部分和实际配置步骤，力求为读者提供一份全面且实用的参考指南。
一、VPN基本概念与原理 1.1 VPN概述 VPN（虚拟专用网络）是一种通过公共网络（如互联网）为远程用户和分支机构提供安全连接的技术。VPN通过加密和隧道技术，确保数据在传输过程中的安全性和完整性。
1.2 IPSec VPN与SSL VPN IPSec（Internet Protocol Security）和SSL（Secure Sockets Layer）是两种常见的VPN协议。IPSec VPN主要用于站点间连接，适合需要高安全性的应用场景；SSL VPN则更适合远程访问，用户可以通过浏览器方便地进行连接。
二、H3C VPN解决方案 2.1 H3C VPN简介 H3C提供了丰富的VPN解决方案，包括IPSec VPN、SSL VPN、GRE VPN等，能够满足企业不同的网络需求。H3C VPN设备具有高性能、高可靠性和易于管理的特点。
2.2 H3C VPN设备类型 H3C的VPN设备包括防火墙、路由器和专用VPN网关等。这些设备能够灵活配置，支持多种VPN协议和应用场景。
三、远程访问VPN——Easy VPN 3.1 理论部分 3.1.1 远程访问VPN原理 远程访问VPN通过在客户端和VPN网关之间建立加密隧道，实现远程用户对企业内部资源的安全访问。其基本流程包括管理连接的建立、数据连接的建立、用户验证（如XAUTH）、组策略的应用等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ba6f1c15d17c53cbefe6fe36275d044/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/125/">«</a>
	<span class="pagination__item pagination__item--current">126/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/127/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>