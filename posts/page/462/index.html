<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d86b7e57c1882ceef7d681da5e0c8e5/" rel="bookmark">
			【前端】Web Audio API接口介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简言 记录下Web Audio API接口的介绍。
Web Audio API 提供了在 Web 上控制音频的一个非常有效通用的系统，允许开发者来自选音频源，对音频添加特效，使音频可视化，添加空间效果（如平移），等等。
Web Audio API Web Audio API 使用户可以在音频上下文（AudioContext）中进行音频操作。
基本音频操作通过音频节点执行，这些节点连接在一起形成音频路由图。即使在单个上下文中，也可支持多个具有不同类型通道布局的音源。这种模块化设计为创建具有动态效果的复杂音频功能提供了灵活性。这种模块化设计提供了灵活创建动态效果的复合音频的方法。
音频节点（audio node）通过它们的输入输出相互连接，形成一个链或者一个简单的网。一般来说，这个链或网起始于一个或多个音频源。
音频源可以提供一个片段一个片段的音频采样数据（以数组的方式）,也可以是音频或视频的文件读出来的，又或者是音频流（MediaStreamAudioSourceNode）。
这些节点的输出可以连接到其他节点的输入上，然后新节点可以对接收到的采样数据再进行其他的处理，再形成一个结果流。
声音处理完成之后，可以连接到一个目的地（AudioContext.destination），这个目的地负责把声音数据传输给扬声器或者耳机。注意，只有当用户期望听到声音时，才需要进行最后一个这个连接。
web audio流程如下：
使用 AudioContext 创建音频上下文。在音频上下文里创建音频源，音频源可以是上面说的那三种情况。对音频进行处理（当然也可以不处理），处理需要创建效果节点，例如混响、双二阶滤波器、平移、压缩等。为音频选择一个目的地，例如你的系统扬声器连接源到效果器，对目的地进行效果输出。 Web Audio API 接口 Web Audio API 共有一系列接口和相关的事件。
AudioContext — AudioContext 接口代表由音频模块构成的音频处理图。音频上下文控制其所包含节点的创建和音频处理、解码。使用其他接口前你必需创建一个音频上下文，一切操作都在这个环境里进行。AudioNode — 音频节点 接口是一个音频处理模块，包含了音频源节点、音频输出、音量控制节点等。AudioParam — AudioParam 接口代表音频相关的参数，比如一个 AudioNode的参数。它可以设置为特定值或值的变化，并且可以在指定的时间之后以指定模式变更。ended结束事件 — 当媒体播放停止时，会触发ended事件。OscillatorNode — OscillatorNode 接口代表一种随时间变化的波形，比如正弦波形或三角波形。类型是AudioNode，功能是音频处理模块，可以产生指定频率的波形。AudioBuffer — AudioBuffer 代表内存中的一段音频数据，可以通过AudioContext.decodeAudioData()方法从音频文件创建，也可以通过AudioContext.createBuffer()方法从原始数据创建。当音频数据被解码成这种格式之后，就可以被放入一个AudioBufferSourceNode中使用。AudioBufferSourceNode — AudioBufferSourceNode 表示由内存音频数据组成的音频源，音频数据存储在AudioBuffer中。这是一个作为音频源的AudioNode。MediaElementAudioSourceNode — MediaElementAudioSourceNode 接口表示由 HTML5 &lt;audio&gt;或&lt;video&gt;元素生成的音频源。这是一个作为音频源的AudioNode。MediaStreamAudioSourceNode — MediaStreamAudioSourceNode 接口表示由 WebRTC MediaStream（如网络摄像头或麦克风）生成的音频源。这是一个作为音频源的AudioNode。BiquadFilterNode — BiquadFilterNode 接口表示一个简单的低阶滤波器。它是一个AudioNode，可以表示不同种类的滤波器、调音器或图形均衡器。BiquadFilterNode 总是只有一个输入和一个输出。ConvolverNode — ConvolverNode 接口是一个AudioNode，对给定的 AudioBuffer 执行线性卷积，通常用于实现混响效果。DelayNode — DelayNode 接口表示延迟线；是AudioNode 类型的音频处理模块，使输入的数据延时输出。DynamicsCompressorNode — DynamicsCompressorNode 提供了一个压缩效果，当多个音频在同时播放并且混合的时候，可以通过它降低音量最大的部分的音量来帮助避免发生削波和失真。GainNode — GainNode 接口用于音量变化。它是一个 AudioNode 类型的音频处理模块，输入后应用增益 效果，然后输出。StereoPannerNode — StereoPannerNode 接口表示一个简单立体声控制节点，用来左右移动音频流(左右声道处理)。WaveShaperNode — WaveShaperNode 接口表示一个非线性的扭曲。它是AudioNode类型，可以利用曲线来对信号进行扭曲。除了一些效果明显的扭曲，还常被用来给声音添加温暖的感觉(暖调处理)。PeriodicWave — 用来定义周期性的波形，可被用来重塑 OscillatorNode的输出。AudioDestinationNode — AudioDestinationNode 定义了最后音频要输出到哪里，通常是输出到你的扬声器。MediaStreamAudioDestinationNode — MediaStreamAudioDestinationNode 定义了使用 WebRTC 的MediaStream（只包含单个 AudioMediaStreamTrack）应该连接的目的地，AudioMediaStreamTrack 的使用方式和从getUserMedia()中得到MediaStream相似。这个接口是AudioNode类型的音频目的地。AnalyserNode — AnalyserNode 表示一个可以提供实时频率分析与时域分析的切点，这些分析数据可以用做数据分析和可视化。如果你想从音频里提取时间、频率或者其他数据，你需要 AnalyserNodeChannelSplitterNode — ChannelSplitterNode 可以把输入流的每个声道输出到一个独立的输出流（通道分离）。ChannelMergerNode — ChannelMergerNode 用于把一组输入流合成到一个输出流。输出流的每一个声道对应一个输入流（通道合并）。AudioListener — 代表场景中正在听声音的人的位置和朝向。PannerNode — PannerNode 用于表示场景是声音的空间行为。它是AudioNode类型的音频处理模块，这个节点用于表示右手笛卡尔坐标系里声源的位置信息，运动信息（通过一个速度向量表示），方向信息（通过一个方向圆锥表示）。ScriptProcessorNode — ScriptProcessorNode 接口用于通过 JavaScript 代码生成，处理，分析音频。它是一个AudioNode类型的音频处理模块，但是它与两个缓冲区相连接，一个缓冲区里包含当前的输入数据，另一个缓冲区里包含着输出数据。每当新的音频数据被放入输入缓冲区，就会产生一个AudioProcessingEvent 事件，当这个事件处理结束时，输出缓冲区里应该写好了新数据。audioprocess事件 — 当一个 Web Audio API ScriptProcessorNode已经准备好进行处理时，这个事件回调会被调用。AudioProcessingEvent 事件 — 当ScriptProcessorNode的输入流数据准备好了时，AudioProcessingEvent事件会产生。OfflineAudioContext — OfflineAudioContext 离线音频上下文也是音频上下文AudioContext，也表示把AudioNode连接到一起的一个音频处理图。但是，与一个标准的音频上下文相比，离线上下文不能把音频渲染到扬声器，仅仅是把音频渲染到一个缓冲区。complete — Complete 事件，当离线音频上下文被终止时产生。OfflineAudioCompletionEvent 事件 — OfflineAudioCompletionEvent表示上下文被终止时的事件。 示例 音频可视化:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d86b7e57c1882ceef7d681da5e0c8e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/947d56b31e3b31c3df73b401306f7a85/" rel="bookmark">
			Mac 电脑中怎么查看和修改环境变量，Mac中设置python的环境变量（小白必看）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 什么是环境变量 环境变量（environment variables）一般是指在操作系统中用来指定操作系统运行环境的一些参数，如：临时文件夹位置和系统文件夹位置等。
简单通俗的来说，就是设置一条路，在运行程序的时候，可以到环境变量中去找这条路，沿着这条路去走，程序就会更好地运行。
正文： 在mac中怎么设置环境变量呢 一、mac中怎么查看环境变量 1、打开终端
路径：可以直接使用“启动台”打开终端。点击屏幕右上角的放大镜图标或按下Command+空格键，在搜索栏输入“终端”，然后点击搜索结果中的“终端”应用
步骤：在终端中输入
open ~/.bash_profile
就会自动打开mac的环境变量的文件，在里面可以对环境变量进行查看
二、怎么配置python的环境变量 1、下载python 访问官网下载python：https://www.python.org/
2、获取python的安装路径 下载安装完成之后，打开终端之后在终端中输入下面命令（注意：我下载的是python3，版本 不同，python3找不到可以换成python）
which python3
结果如下图：我输入python就找不到
3、配置环境变量 如果之前从来没有配置过环境变量，就先创建一个配置文件，创建好了之后再打开配置文件，复制上面which python3打印出来的结果，也就是python的路径
创建配置文件命令：touch .bash_profile
打开配置文件命令：open ~/.bash_profile（这个时候就会弹窗出你的环境变量的配置文件）
然后输入下面命令：
PATH="/Library/Frameworks/Python.framework/Versions/3.11/bin:${PATH}"
export PATH
alias python="/Library/Frameworks/Python.framework/Versions/3.11/bin/python3"
最后command +S 保存配置文件，在终端中输入source ~/.bash_profile命令让配置文件立即生效
最后在终端中输入 ：source ~/.bash_profile
以上就是mac配置python环境变量的所有步骤啦，感觉有帮助的兄弟姐妹们麻烦点点赞哦～我会和你们一起努力💪的～加油我陌生又熟悉的朋友！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79636d26252870f76a4f27f43ebfc419/" rel="bookmark">
			​Edge-TTS：微软推出的，免费、开源、支持多种中文语音语色的AI工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Edge-TTS是由微软推出的文本转语音Python库，通过微软Azure Cognitive Services转化文本为自然语音。适合需要语音功能的开发者，GitHub上超3000星。作为国内付费TTS服务的替代品，Edge-TTS支持40多种语言和300种声音，提供优质的语音输出，满足不同开发需求。
Edge-TTS 项目地址：
https://github.com/rany2/edge-tts
1.安装部署
首先，你需要通过Python包管理工具pip来安装Edge-TTS库。只需在命令行中输入以下命令（没有python环境的自行配置一下）：
pip install edge-tts
如果只想使用edge-tts和edge-playback命令，最好使用 pipx：
pipx install edge-tts
安装完成后，你就可以开始使用Edge-TTS来将文本转换为语音了。Edge-TTS支持多种语言和不同的声音选项，你可以根据需要选择合适的声音。
2.文本转语音
我们先来个hello world，只需要一行代码！
edge-tts --text "hello world" --write-media hello.mp3
执行完毕之后，会在你执行的目录下，生成hello.mp3文件，直接双击播放查看效果：
如果你想立即播放带有字幕的内容，可以使用以下edge-playback命令：
edge-playback --text "Hello, world!"
注意以上需要安装mpv命令行播放器。所有命令也都edge-tts可以工作。edge-playback
3.支持的语言和音色
edge-tts支持英语、汉语、日语、韩语、法语等40多种语言，共300多种可选声音，执行以下命令查询：
edge-tts --list-voices
如下图所示：
查询结果中的Gender为声音的性别，Name为声音的名字，如zh-CN-YunjianNeural，其中zh表示语言，CN表示国家或地区，可以根据需求选择不同的声音。
使用--voice参数来指定声音名称，下面我使用zh-CN-YunyangNeural声音来合成一个中文音频。
edge-tts --voice zh-CN-YunyangNeural --text "大家好，欢迎关注语音之家，语音之家是一个助理AI语音开发者的社区。" --write-media hello_in_cn.mp3
4.调整语速、音量和音调
可以对生成的语音进行细微修改。
$ edge-tts --rate=-50% --text "Hello, world!" --write-media hello_with_rate_halved.mp3 --write-subtitles hello_with_rate_halved.vtt$ edge-tts --volume=-50% --text "Hello, world!" --write-media hello_with_volume_halved.mp3 --write-subtitles hello_with_volume_halved.vtt$ edge-tts --pitch=-50Hz --text "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79636d26252870f76a4f27f43ebfc419/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2604ebf7e63dea1a10e442a3d5c2d3d0/" rel="bookmark">
			python 之单星号（*）与双星号（**）详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本章将详细介绍python中*与**操作符的使用场景以及注意事项，并给出示例demo。
1.作为运算符 *表示乘法运算
**表示乘方运算
代码 示例：
#1.* ** 作为运算符 print('\n------运算符测试------') a = 3*2 #乘法 b = 3**2 #乘方 print("a = ", a) #输出6 print("b = ", b) #输出9 执行结果：
2.作为函数形参 *在python中做函数形参，表示的是一个可变长度的序列，类型为tuple，即将所有参数放入一个元组（tuple）中，被函数使用。
**在python中做函数形参，表示的是一个可变长度的序列，类型为dict,即将所有的关键字参数，放入一个字典（dict）中， 被函数使用。
*与**作为形参同时出现时，**必须在最后面.
代码示例：
#2.作为形参 print('\n------形参测试------') def printx(*arg1, **arg2): print("arg1={0}, type:{1}".format(arg1, type(arg1))) print("arg2={0}, type:{1}".format(arg2, type(arg2))) #调用 P1 = printx(1,2, key1=1, key2=2) 代码执行结果：
3.作为函数实参 在list/tuple/set前加*，会把序列中的所有元素解包成位置参数
在dict前加*，会把dict的键变成位置参数；加**，把字典的键值对变成关键字参数。
A = (a,b,c)
B = {“key1” :1, “key2”:2}
P3 = Printx(*A) # 等同于printx(a,b,c)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2604ebf7e63dea1a10e442a3d5c2d3d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5747050f2c1c47328b225c20ee668373/" rel="bookmark">
			运算放大器-放大倍数的表示方法：增益(Gain) 和 分贝(dB)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运算放大器的增益（Gain）可以用分贝（dB）表示，也可以用放大倍数表示。这两种表示方法之间的转换关系是基于对数的定义。
目录
1. 电压（电流）放大倍数分贝数定义：
2. 运放的增益（Gain）和分贝（dB）之间的关系可以通过以下公式进行转换：
3. 功率放大倍数分贝数定义：
4. 其中， &gt; 0 说明信号被放大， = 0 信号直通， &lt; 0 说明信号被衰减。
附表1.
附表2.
严文年 -- 记于苏州 1. 电压（电流）放大倍数分贝数定义： 其中 为放大倍数的分贝数， 为放大信号输出， 为信号输入。
2. 运放的增益（Gain）和分贝（dB）之间的关系可以通过以下公式进行转换： 如果你知道放大倍数（Gain），那么可以通过以下公式计算分贝（dB）： 其中，​ 是分贝值， 是放大倍数。
如果你知道分贝（dB），那么可以通过以下公式计算放大倍数（Gain）： 其中， 是放大倍数， 是分贝值。
3. 功率放大倍数分贝数定义： 其中 为放大倍数的分贝数， ​为放大信号输出功率， 为信号输入功率。
4. 其中， &gt; 0 说明信号被放大， = 0 信号直通， &lt; 0 说明信号被衰减。 附表1. 下面是一个简单的对照表，列出了一些常见的电压（电流）增益dB值和对应的放大倍数：
增益 (dB)电压 / 电流 放大倍数（Gain）0 dB120 dB1040 dB10060 dB100080 dB10000 增益 (dB)电压 / 电流 放大倍数（Gain）0 dB11 dB1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5747050f2c1c47328b225c20ee668373/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/271d1d95abd528b3d9f604093966357d/" rel="bookmark">
			MAC本安装telnet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Linux运维工具-ywtool
目录 1.打开终端1.先安装brew命令2.写入环境变量4.安装telnet 1.打开终端 访达 - 应用程序(左侧) - 实用工具(右侧) - 终端 #注意:登入终端用普通用户,不要用MAC的root用户 1.先安装brew命令 /bin/zsh -c "$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)" 输入"1" #选择"中科大下载源";会先安装git #需要输入密码,是用户的密码 再输入"1" #安装完brew后会让选择配置国内源,选择"中科大下载源" 2.写入环境变量 source /Users/xxx/.zprofile #xxx为登录MAC的用户 4.安装telnet brew install telnet 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c7fe39f3000cd22fc57a713511a05f7/" rel="bookmark">
			AI绘画大模型：国内外『文生图』效果对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着人工智能（AI）技术的不断突破，AI绘画作为其中的一项重要应用，逐渐成为了艺术领域的新宠。『文生图』（Text-to-Image）是AI绘画中的一种重要技术，它能够通过自然语言描述生成对应的图像。本文将对国内外具有代表性的『文生图』大模型进行效果对比，并分析其在实际应用中的优劣。
一、技术原理简介
『文生图』技术主要基于深度学习算法，特别是生成对抗网络（GAN）和扩散模型（Diffusion Model）等。这些模型通过大量数据的训练，使得AI能够理解和生成与文本描述相对应的图像。国内外的研究团队纷纷投入巨资研发AI绘画大模型，以期在图像生成的质量和速度上取得突破。
二、国内外代表性模型对比
国内模型：
（1）文心知识增强大模型
文心知识增强大模型是百度研发的一款基于Transformer结构的AI绘画模型。该模型在训练过程中充分考虑了文本与图像之间的关联性，使得生成的图像在细节和整体风格上均能与文本描述保持高度一致。在实际应用中，文心知识增强大模型表现出了较强的生成能力和稳定性，得到了广大用户的好评。
（2）其他国内模型
除了百度之外，国内还有许多研究团队和企业投入到了AI绘画大模型的研发中。这些模型在算法、数据等方面各有千秋，但在实际应用中普遍面临着生成图像质量不稳定、速度较慢等问题。
国外模型：
（1）DALL-E 2
DALL-E 2是由OpenAI研发的一款强大的『文生图』模型。该模型在训练过程中采用了大量的图像和文本数据，使得生成的图像在分辨率、色彩和细节等方面均表现出色。在实际应用中，DALL-E 2能够快速地将自然语言描述转化为高质量的图像，得到了广泛的关注和认可。
（2）其他国外模型
除了DALL-E 2之外，国外还有许多知名的AI绘画大模型，如Midjourney、Stable Diffusion等。这些模型在算法、数据等方面各有特色，但在实际应用中普遍具有较高的生成质量和速度。
三、实际应用优劣分析
从实际应用的角度来看，国外模型如DALL-E 2在生成图像的质量和速度上普遍优于国内模型。这主要得益于国外模型在算法、数据等方面的成熟度和丰富度。然而，国内模型在近年来也取得了显著的进步，如文心知识增强大模型等，其在实际应用中表现出了较强的生成能力和稳定性。
四、结论与展望
通过对国内外AI绘画『文生图』大模型的效果对比，我们可以发现，尽管国内模型在某些方面仍有待提高，但其在整体性能和实际应用中已经取得了一定的成就。未来，随着AI技术的不断发展，我们有理由相信，国内AI绘画大模型将在生成质量、速度等方面取得更大的突破，为艺术领域带来更多的创新和惊喜。
同时，我们也期待国内外的研究团队能够加强交流与合作，共同推动AI绘画技术的发展，为人类社会创造更多的价值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4128beb70bef8ed06d828b0902f062fd/" rel="bookmark">
			Redis-Manager：一款强大的Redis管理工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis-Manager：一款强大的Redis管理工具 是一个开源的Web应用，旨在提供便捷、高效的Redis数据库管理和监控解决方案。它采用了现代前端框架和后端服务相结合的方式，为开发者带来了直观的界面和丰富的功能，让Redis管理变得更加轻松。
技术分析 前端 Redis-Manager 使用 Vue.js 框架构建前端部分，这是一种流行的、轻量级的JavaScript库，以组件化开发和易上手著称。配合 Element UI 这样的成熟UI库，使得界面上的操作直观且易于理解。
后端 后端采用 Spring Boot 构建，这是一个广泛使用的Java开发框架，用于快速开发微服务和独立应用程序。结合 Jedis —— 一个知名的Java Redis客户端，提供了稳定的数据操作支持。
数据可视化 项目利用 ECharts 实现数据可视化，通过图表形式展示Redis的性能指标，如内存占用、命令执行频率等，帮助用户实时了解系统状态。
容器化部署 为了适应现代化的开发环境，Redis-Manager 提供了 Docker 镜像，方便用户在容器环境中快速部署。
功能亮点 多实例管理：可以添加并管理多个Redis实例，不同实例的配置和数据独立。数据浏览与操作：支持键值的查看、修改、删除以及批量操作，还有键的扫描功能。监控告警：实时监控Redis的状态，包括CPU使用率、内存占用、网络IO等，并可设置阈值告警。图形化备份恢复：提供一键备份和恢复功能，支持下载和上传RDB文件。安全控制：支持角色权限管理和登录验证，确保数据安全性。 特点 易用性：简洁的用户界面，直观的操作流程，降低学习成本。灵活性：支持多种部署方式，满足不同场景需求。社区活跃：持续更新维护，积极解决用户问题，不断优化产品体验。开放源码：遵循Apache 2.0许可证，自由定制，鼓励贡献。 结语 无论你是个人开发者还是企业团队， 都是一个值得尝试的Redis管理工具。其强大的功能和友好的用户体验，将极大地提升你的Redis运维效率。立即开始探索，让它成为你日常开发中的得力助手吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9dfc536998abf6252cdd664b95158ed/" rel="bookmark">
			uniapp 获取微信网页授权并且实现微信公众号跳转小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uniapp 获取微信网页授权并且实现微信公众号跳转小程序 一、获取网页授权1、申请测试号2、发起授权请求 二、微信公众号跳转小程序1、引入微信js-sdk2、通过config接口注入权限验证配置并申请所需开放标签3、开放标签 一、获取网页授权 1、申请测试号 配置网页授权地址
注意不需要加htpp！
2、发起授权请求 document.location.replace( `https://open.weixin.qq.com/connect/oauth2/authorize?appid=${this.appid}&amp;redirect_uri=${this.redirect_uri}&amp;response_type=code&amp;scope=${this.scope}&amp;state=STATE#wechat_redirect` ); 截取url中的code
getUrlCode() { // 截取url中的code方法 var url = location.href; //获取打开的公众号的路径 console.log(url); let winUrl = url; var theRequest = new Object(); if (url.indexOf('?') != -1) { var str = url.substr(url.indexOf('?') + 1); var strs = str.split('&amp;'); for (var i = 0; i &lt; strs.length; i++) { var items = strs[i].split('='); theRequest[strs[i].split('=')[0]] = strs[i].split('=')[1]; } } return theRequest; }, appid是公众号的唯一标识。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9dfc536998abf6252cdd664b95158ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1ed16223636ad46662d45559cda5798/" rel="bookmark">
			RabbitMQ之“延时队列”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		延时队列 RabbitMQ是目前最为流行的消息队列之一，它的高可靠性、高可用性和高性能使得它成为众多应用场景下的首选。在实际应用中，我们经常需要实现延时队列来解决一些业务问题，比如订单超时未支付自动取消等。本文将介绍如何使用RabbitMQ实现延时队列
下面先来解释一下
延时队列(也可以称为延迟队列，其实都是一个意思)：
延迟队列存储的对象是对应的延迟消息，所谓“延迟消息”是指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。
延时消息：生产者发送消息时指定一个时间，消费者不会立刻收到消息，而是在指定时间之后才收到消息
延时任务：设置在一定时间之后才执行的任务
死信：
当一个队列中的消息满足下列情况之一时，就会成为死信(dead letter):
1、消费者使用basic.reject或basic.nack声明消息消费失败，并且消息的requeue参数设置为false
2、消息是一个过期消息(达到了队列或消息本身设置的过期时间)，超时无人消费
3、要投递的队列消息堆积满了，最早的消息可能成为死信
延时队列可以用于以下场景：
订单处理：在电商网站中，订单处理是一个常见的业务流程。如果订单需要立即处理，可以使用RabbitMQ的延时队列来实现延迟处理。例如，可以将订单发送到一个延时队列中，并设置一个延迟时间(例如30分钟),然后在延迟时间到达后，将订单从队列中取出并进行处理。消息推送：在移动应用或Web应用程序中，可以使用RabbitMQ的延时队列来实现消息推送。例如，可以将用户订阅的消息发送到一个延时队列中，并设置一个延迟时间(例如1小时),然后在延迟时间到达后，将消息从队列中取出并推送给用户。定时任务：在分布式系统中，可以使用RabbitMQ的延时队列来实现定时任务。例如，可以将需要定期执行的任务发送到一个延时队列中，并设置一个延迟时间(例如每天),然后在延迟时间到达后，将任务从队列中取出并执行。数据备份：在数据库中，可以使用RabbitMQ的延时队列来实现数据备份。例如，可以将需要备份的数据发送到一个延时队列中，并设置一个延迟时间(例如每天),然后在延迟时间到达后，将数据从队列中取出并进行备份。优惠券发放：您可以设置一个延时队列，将优惠券发放任务添加到队列中，设置一定的延时时间，以保证优惠券在特定时间后才能被消费。动态路由：您可以使用延时队列来实现动态路由的功能，将消息发送到延时队列中，并设置一定的路由规则，以实现消息在特定时间后被路由到不同的目标队列中。 业务场景：
我们通常会在电商网站中(或者app比如：京东，淘宝)进行下单，购买商品，但是我们由于没哟及时支付，会出现订单超时未支付自动取消的情况
下面用一张简单的图片来设计一下业务场景：
那我们该如何去实现延时队列呢，下面用一张图片给大家解释一下
话不多说，上代码！！！
作者在这里只创建了一个交换机，这个交换机可以同时绑定两个队列(有两个队列，一个队列设置了它的ttl(消息过期时间)，同时设置了消息过期后的路由交换机和路由的routeKey，如果不设置过期策略那么消息过期之后就会进入死信队列,另外一个队列是普通队列，监听的时候只用去监听普通队列，达到延迟队列的效果。跟上图效果一样，消息通过这个交换机到达设置了过期时间的的队列，这个延迟队列没有消费者进行消费，当消息过期之后，会通过这个交换机路由到正常的队列，然后进行消费)
导入依赖
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.8.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 配置类
package com.atguigu.gulimall.auth.config; import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.DirectExchange; import org.springframework.amqp.core.Exchange; import org.springframework.amqp.core.Queue; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import java.util.HashMap; import java.util.Map; /** * @Author YanShuLing * @Package:com.atguigu.gulimall.auth.config * @Project: brook * @Description TODO * @name:RabbitMQConfig * @Date 2024/3/8:9:56 */ @Configuration public class RabbitMqConfig { //创建了一个简单的队列 @Bean public Queue createOrderReleaseQueue(){ return new Queue("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1ed16223636ad46662d45559cda5798/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f6952deae3bfff39c6bb62162dd22d2/" rel="bookmark">
			如何使用Android平板公网访问本地Linux code-server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.ubuntu本地安装code-server2. 安装cpolar内网穿透3. 创建隧道映射本地端口4. 安卓平板测试访问5.固定域名公网地址6.结语 1.ubuntu本地安装code-server 准备一台虚拟机,Ubuntu或者centos都可以，这里以VMwhere ubuntu系统为例
下载code server服务,浏览器访问:https://github.com/coder/code-server,复制下载链接
打开ubuntu命令行下载
出现需要输入ubuntu的登录账户密码,输入密码即可,然后等待安装完成
以下信息表示安装成功
接着输入以下命令设置code-server的登录密码
export PASSWORD=”000000” 查看IP地址,作局域网访问使用
code-server服务默认为8080端口号, 为了防止8080端口冲突,我们修改一下code-server端口号,输入以下命令,编辑配置文件
sudo vim ~/.config/code-server/config.yaml 把127.0.0.1改为0.0.0.0,8080端口改成自己喜欢的端口,本例子改为8077,修改完成保存
设置好密码后启动code-server服务,输入以下命令:
code-server 出现地址和端口号信息表示启动成功
接着打开浏览器通过局域网ip地址访问http://192.168.191.129:8077/,出现welcone code-server表示成功,输入我们设置的密码,登录即可.
2. 安装cpolar内网穿透 接着使用cpolar穿透本地code-server服务,使得android设备可以远程进行访问,随时随地写代码。cpolar支持http/https/tcp协议，不限制流量，操作简单，无需公网IP，也无需路由器。
cpolar官网：https://www.cpolar.com/
安装cpolar内网穿透(支持一键自动安装脚本)
cpolar 安装（国内使用） curl -L https://www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash 或 cpolar短链接安装方式：(国外使用） curl -sL https://git.io/cpolar | sudo bash 查看版本号 cpolar version token认证 登录cpolar官网后台，点击左侧的验证，查看自己的认证token，之后将token贴在命令行里
cpolar authtoken xxxxxxx 向系统添加服务 sudo systemctl enable cpolar 启动cpolar服务 sudo systemctl start cpolar 查看服务状态 sudo systemctl status cpolar 正常显示为active则表示服务为正常在线启动状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f6952deae3bfff39c6bb62162dd22d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bd71e0bf210acb62ddef99d3c6239c8/" rel="bookmark">
			Python 下载的9种方法，不愧是Alibaba技术官
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import requests
url = ‘xxxxxxxx’ # 目标下载链接
r = requests.get(url) # 发送请求
保存 with open (‘r.txt’, ‘rb’) as f:
f.write(r.content)
f.close
二、使用 wget
安装 wget 库
pip install wget
示例代码
import wget
url = ‘https://pic.cnblogs.com/avatar/1197773/20170712160655.png’ # 目标路由，下载的资源是图片
path = ‘D:/x.png’ # 保存的路径
wget.download(url, path) # 下载
三、下载重定向资源
有些 URL 会被重定向到另一个 URL，后者是真正的下载链接。很多软件的下载其实都是这样的形式。URL看起来如下
https://readthedocs.org/projects/python-guide/downloads/pdf/latest
重定向的 URL 也可以用 requests 库进行下载，只需加一个参数就可以
‘’’
遇到问题没人解答？小编创建了一个Python学习交流QQ群：778463939
寻找有志同道合的小伙伴，互帮互助,群里还有不错的视频学习教程和PDF电子书！
‘’’
import requests
url = ‘https://readthedocs.org/projects/python-guide/downloads/pdf/latest’
allow_redirect参数True表示允许重定向 r = requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bd71e0bf210acb62ddef99d3c6239c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e65eefb7c0b30f18fe21dfab37627e7/" rel="bookmark">
			Java中的类与对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面向对象 设计对象并使用 类: 是共同特征的描述(设计图)
对象: 是真实存在的具体实例
Javabean类: 用来描述一类事物的类,在Javabean类里是不写main方法的
注意: 类名首字母要大写,见名知意,(驼峰模式)
注意: 在实际开发中,建议一个文件定义一个class类
代码:
package com.xiaonan.Demo01; public class GirlFriend { //属性 String name; int age; String gender; //行为 public void eat(){ System.out.println("在吃饭"); } public void sleep(){ System.out.println("在睡觉"); } } package com.xiaonan.Demo01; public class GirlFriendTest { public static void main(String[] args) { //创建一个女朋友对象 GirlFriend gf1 = new GirlFriend(); //赋值 gf1.age = 18; gf1.gender = "女"; gf1.name = "小琪"; //输出 System.out.println(gf1.age); System.out.println(gf1.gender); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e65eefb7c0b30f18fe21dfab37627e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68ba9b88a4fc818ff2b8814a4fab8c25/" rel="bookmark">
			解决The following method did not exist:net.sf.jsqlparser.statement.select.SelectExpressionItem报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在启动一个新的项目的时候，遇到了以下报错：
*************************** APPLICATION FAILED TO START *************************** Description: An attempt was made to call a method that does not exist. The attempt was made from the following location: com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor.defaultCountSelectItem(PaginationInnerInterceptor.java:79) The following method did not exist: net.sf.jsqlparser.statement.select.SelectExpressionItem.withAlias(Lnet/sf/jsqlparser/expression/Alias;)Lnet/sf/jsqlparser/statement/select/SelectExpressionItem; The method's class, net.sf.jsqlparser.statement.select.SelectExpressionItem, is available from the following locations: jar:file:/D:/SoftWare/dev/maven/apache-maven-3.6.3/repository/com/github/jsqlparser/jsqlparser/3.2/jsqlparser-3.2.jar!/net/sf/jsqlparser/statement/select/SelectExpressionItem.class The class hierarchy was loaded from the following locations: net.sf.jsqlparser.statement.select.SelectExpressionItem: file:/D:/SoftWare/dev/maven/apache-maven-3.6.3/repository/com/github/jsqlparser/jsqlparser/3.2/jsqlparser-3.2.jar net.sf.jsqlparser.parser.ASTNodeAccessImpl: file:/D:/SoftWare/dev/maven/apache-maven-3.6.3/repository/com/github/jsqlparser/jsqlparser/3.2/jsqlparser-3.2.jar Action: Correct the classpath of your application so that it contains a single, compatible version of net.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68ba9b88a4fc818ff2b8814a4fab8c25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e728138426a24da9590a367d9450aa34/" rel="bookmark">
			四、C语言中的数组：如何输入与输出二维数组（数组，完）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本章的学习内容如下 四、C语言中的数组：数组的创建与初始化
四、C语言中的数组：数组的输入与元素个数
C语言—第6次作业—十道代码题掌握一维数组
四、C语言中的数组：二维数组
1.二维数组的输入与输出 当我们输入一维数组时需要一个循环来遍历下标，二维数组有两个下标 ，所以我们需要两个循环嵌套使用来遍历下标。
# include &lt;stdio.h&gt; int main() { int arr[3][4] = { 1,2,3,4,5,6,7,8,9,1,2,3 };//完全初始化 int i = 0; int j = 0; for (i = 0; i &lt; 3; i++) { for (j = 0; j &lt; 4; j++) { scanf("%d", &amp;arr[i][j]);//输入 } } for (i = 0; i &lt; 3; i++) { for (j = 0; j &lt; 4; j++) { printf("% d"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e728138426a24da9590a367d9450aa34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c15d67fefbfe4379e269aa2c99344f05/" rel="bookmark">
			探索数据结构：顺序栈与链式栈的原理、实现与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨✨ 欢迎大家来到贝蒂大讲堂✨✨
🎈🎈养成好习惯，先赞后看哦~🎈🎈
所属专栏：数据结构与算法
贝蒂的主页：Betty’s blog
1. 栈的定义 栈简单来说就是一种只允许在一端进行操作(插入与删除）的线性表。即栈是严格遵守后进先出（Last In First Out）的数据结构，简称LIFO结构
栈顶（Top）：线性表允许进行插入删除的那一端。栈底（Bottom）：固定的，不允许进行插入和删除的另一端。 2. 栈的分类 当我们了解栈的定义之后，我们就能大概知晓其实现方式无非就是顺序表或者单链表。根据其实现方式，我们又能将栈分为顺序栈与链式栈。
因为单链表头插的效率O(1)明显比尾差O(N)更高，所以我们用单链表实现栈时最好以链表的头为栈顶。如果一定要以尾节点作为栈顶的话，最好以双向链表来实现。本章实现链表栈时以头节点作为栈顶。 3. 栈的功能 栈的初始化。判断栈是否为空。。返回栈顶元素。返回栈的大小。入栈与出栈。打印栈的元素。销毁栈。 4. 栈的声明 4.1. 顺序栈 顺序栈的声明需要一个指向一块空间的指针a，指向栈顶下一个元素的top，以及标志栈大小的capacity。
typedef int STDataType; typedef struct Stack { STDataType* a; int top;	//栈顶指针 int capacity;	//容量 }Stack; 当然也有实现top指向当前栈顶元素的，只不过这时top初始化要为-1，这样才能在填入元素时刚好指向栈顶元素。 4.2. 链式栈 链式栈的声明只需要一个top指针，以及栈的容量capacity。
typedef struct SListNode { STDataType data; struct SListNode* next; }SListNode; typedef struct Stack { SListNode* top; int size; }Stack; 5. 栈的功能的具体实现 5.1. 栈的初始化 顺序栈与链式栈的初始化分别与顺序表，链表的初始化大致相同。顺序栈先预先分配一块空间，而链式栈可以先初始为NULL。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c15d67fefbfe4379e269aa2c99344f05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00456ad86eff03f299f72d1f0996c3df/" rel="bookmark">
			若依vue（前后端分离版本）前端使用字典
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 开发环境 IDEA软件前端 vue2 + element ui 准备工作 1、启动若依系统前后端
2、使用默认账号，超级管理员账户进入系统
3、进入字典管理
添加自己需要的字典和字典数据（标签和键值），这里我的是，名称和类型由自己取名，类型使用英文加下划线，在后面前端代码中需要使用类型。
切换到开发工具IDEA 在需要使用字典的页面中，一般使用字典分为下拉框和数据列表展示
1、下拉框 1）、样式代码
&lt;el-select&gt; &lt;el-option v-for="dict in dict.type.transport_order_status" :key="dict.value" :label="dict.label" :value="dict.value" &gt;&lt;/el-option&gt; &lt;/el-select&gt; 2)、js代码
在export default内容中，一定要添加如下属性
export default { //数组中为你的字典类型，多个在[]中用逗号分隔如dicts:['a_b','b_c'] dicts:['transport_order_status'],//一定要用dicts命名属性 data(){}, methods:{} } 效果如图 2、数据列表 1）、样式代码
在dict-tag标签中
options属性dict.type.{你在字典管理页面中添加的字典类型}
value属性绑定对应的键值，从我这个项目中说是从后端拿到的数据，在数据库中存储的是state字段，值为1、2、3这个值对应的字典标签就通过dict-tag标签展示
&lt;el-table-column label="订单状态" align="center" prop="state" &gt; &lt;template slot-scope="scope"&gt; &lt;dict-tag :options="dict.type.transport_order_status" :value="scope.row.state"&gt;&lt;/dict-tag&gt; &lt;/template&gt; &lt;/el-table-column&gt; 2）、js代码
在export default内容中，一定要添加如下属性
export default { //数组中为你的字典类型，多个在[]中用逗号分隔如dicts:['a_b','b_c'] dicts:['transport_order_status'],//一定要用dicts命名属性 data(){}, methods:{} } 效果如图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f79242c46190dd656062e85b30642fb9/" rel="bookmark">
			前端心目中的最佳富文本编辑器 之 Quill ，你用过那些呢？收藏备用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		===
===
Quill 的使用
=============
快速开始
开始构建一个quill编辑项目包括引入文件、创建自定义工具栏、创建编辑容器以及初始化这几部分。
Bold
Italic
Hello World!
quill主要资源介绍
以上就是quill的库文件了，但要实现代码高亮的话需要自己引入highlight.js库，只需要引入就可以了，不需要额外的配置，所以完整的引入，以我的项目为参考：
// 代码高亮采用dracula主题，可去highlight官网配置
// 采用snow主题
// highlight.js的主要js文件
// quill的主要js文件
创建编辑器
quill的使用也很简单，引入上面的资源之后就可以开始创建编辑器了。
首先需要定义编辑器的工具栏，有两种方式，一种是直接html创建，一种是通过js创建，相对来说html更加直观一些，这里就简单的放两个示例介绍一下。
通过一个js数组来配置初始化容器：
var toolbarOptions = [
[‘bold’, ‘italic’, ‘underline’, ‘strike’], // 切换按钮
[‘blockquote’, ‘code-block’],
[{ ‘header’: 1 }, { ‘header’: 2 }], // 用户自定义按钮值
[{ ‘list’: ‘ordered’}, { ‘list’: ‘bullet’ }],
[{ ‘script’: ‘sub’}, { ‘script’: ‘super’ }], // 上标/下标
[{ ‘indent’: ‘-1’}, { ‘indent’: ‘+1’ }], // 减少缩进/缩进
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f79242c46190dd656062e85b30642fb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19c6fba79a1fba8f0afc9a1ebfc831b2/" rel="bookmark">
			MySQL--分组查询获取每组最新的一条数据（group by）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		业务场景：
最近项目中迭代一个旧的功能，再原有的设计上进行功能拓展（因成本等原因，不考虑项目重构），其中设计到了这么一个场景，同一个业务 ID 在同一张表中有 N 条数据，需要查询出最新的那一条数据。
解决方案：
使用 group by id， 再按时间或者 id 降序，理论上就可以获取最新的数据。每个业务 id 都去数据库查询一次，再按时间降序，最后 limit 1，就可以获取到最新的数据（这个方案一般在项目中是不考虑的）。使用 group by id。。。这里先卖个关子。 group by id 方案验证：
test 表是主键自增的。
先查看数据：
select id,kpa_id,progress from test where kpa_id=10; 执行结果：
可知同一个业务 ID 查询结果有22条数据。
group by id 获取最新的一条数据，SQL如下：
select id,kpa_id,progress from test where kpa_id=10 group by kpa_id order by id desc; 执行结果：
很明显没有获取到最新的一条数据，该方案不可行。
再次换一种SQL语法，如下：
select id,kpa_id,progress from (select * from test order by id desc)t where kpa_id=10 group by kpa_id; 执行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19c6fba79a1fba8f0afc9a1ebfc831b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f63cd8ac00f2acebc71b496be7ed2957/" rel="bookmark">
			大数据开发（Spark面试真题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大数据开发（Spark面试真题） 一、Spark基础和核心概念1、什么是Spark Streaming？简要描述其工作原理。2、什么是Spark内存管理机制？请解释其中的主要概念，并说明其作用。3、请解释一下Spark中的shuffle是什么，以及为什么shuffle操作开销较大？4、请解释一下Spark中的RDD持久化（Caching）是什么以及为什么要使用持久化？5、请解释一下Spark中Resilient Distributed Datasets(RDD)是什么以及其优势是什么？6、解释一下Spark Streaming中的窗口操作（Window Operations）是如何工作的？7、请描述一下Spark和MapReduce之间有何不同？8、Spark RDD宽窄依赖是什么？9、Spark的阶段划分？10、Spark的任务执行流程？11、Spark作业调度？12、Spark提交job的流程？13、Spark的内存模型？14、Spark的stage如何划分？在源码中是怎么判断属于Shuffle Map Stage或Result Stage的？15、Spark的内存模型？ 二、Spark Streaming 和数据处理1、Spark Streaming和Kafka如何结合使用以实时处理流式数据？2、Kafka连接Spark Streaming的几种方式？3、Spark Streaming的双流join的过程，怎么做的？ 三、Spark 调度器和作业优化1、请解释一下Spark作业调度器中FIFO、Fair和Capacity调度器之间有何区别？2、你如何优化一个Spark作业，使其在处理大数据集时更加高效？ 四、Spark 数据处理算子和概念1、Spark RDD算子有哪些？2、Spark有什么算子？3、Spark中的persist是什么原理？4、Spark为什么适合迭代处理？5、Spark广播变量的实现和原理？6、Spark reduceByKey和groupByKey的区别和作用？7、Spark reduceByKey和reduce的区别？ 五、Spark SQL 和数据结构1、Spark分哪几个部分（模块）？分别有什么作用？2、Spark SQL的GroupBy会造成窄依赖吗？3、Spark GroupBy是行动算子吗？4、为什么要划分宽依赖和窄依赖？5、Spark有了RDD，为什么还要有DataFrame和DataSet？6、Spark的RDD、DataFrame、DataSet、DataStream区别？7、Spark的Spark Application、Job、Stage、Task分别介绍下，如何划分？8、Spark Stage内部逻辑？9、Spark为什么要划分Stage？ 六、Spark 高级特性和优化1、Spark DAGScheduler如何划分？干了什么活？2、Spark RDD的容错？3、Spark Executor内存分配？4、Spark的batchsize，怎么解决小文件合并问题？5、说下什么是Spark RDD？RDD有哪些特点？说下知道的RDD算子？6、说下 Spark checkpoint？7、Spark SQL的优化？8、Spark的cache和persist的区别？它们是transformation算子还是action算子？ 七、Spark 与其他框架的对比1、Flink和Spark Streaming的区别是什么？2、Spark为什么比Hadoop速度快？ 八、Spark 数据倾斜和Partitioner1、Spark数据倾斜问题，如何定位，解决方案？2、Spark HashPartitioner和RangePartitioner的实现？ 九、Spark Shuffle 和 Join1、介绍下Spark Shuffle及其优缺点？2、什么情况下产生Spark Shuffle？3、Sparkjoin的分类 一、Spark基础和核心概念 1、什么是Spark Streaming？简要描述其工作原理。 Spark Streaming是Spark提供用于实时流式数据处理和分析的库。它基于离散时间间隔将原始流式数据划分为小的批处理，然后将这些批次数据提供给Spark引擎进行处理。
2、什么是Spark内存管理机制？请解释其中的主要概念，并说明其作用。 Spark内存管理机制通过动态划分内存空间为执行引擎和缓存两个部分来优化计算和访问速度。以下是主要概念及其作用：
Executor Memory（执行内存）：执行内存用于保存RDD转换操作生成的执行结果及相关遍历。它直接影响了并行处理任务时可利用的资源量。Storage Memory（缓存内存）：缓存部分被称为Storage Memory，并且用于缓冲磁盘读写操作中频繁访问的数据块。Off-Heap Memory（堆外内存）：堆外内存在Executor进程之外管理。它用于存储Spark的元数据和缓冲数据，可以减少Java堆内存的压力。Memory Fraction（内存分配比例）：内存分配比例是指Executor可使用的堆内存在执行和缓冲之间划分的比例。该参数根据任务性质来优化计算与缓冲之间的平衡关系。 3、请解释一下Spark中的shuffle是什么，以及为什么shuffle操作开销较大？ 在Spark中，Shuffle是将RDD（Resilient Distributed Dataset）的中间结果进行重新排序和混洗的过程。它通常发生在需要对数据进行跨节点迁移、合并、整合操作时，如groupByKey()、reduceByKey()和sortByKey()等操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f63cd8ac00f2acebc71b496be7ed2957/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/461/">«</a>
	<span class="pagination__item pagination__item--current">462/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/463/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>