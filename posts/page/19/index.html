<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d47e0c7c1e6463f8a0618ff5410a6868/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(104)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
451、pandas.DataFrame.pow方法
451-1、语法
451-2、参数
451-3、功能
451-4、返回值
451-5、说明
451-6、用法
451-6-1、数据准备
451-6-2、代码示例
451-6-3、结果输出
452、pandas.DataFrame.dot方法
452-1、语法
452-2、参数
452-3、功能
452-4、返回值
452-5、说明
452-6、用法
452-6-1、数据准备
452-6-2、代码示例
452-6-3、结果输出
453、pandas.DataFrame.radd方法
453-1、语法
453-2、参数
453-3、功能
453-4、返回值
453-5、说明
453-6、用法
453-6-1、数据准备
453-6-2、代码示例
453-6-3、结果输出
454、pandas.DataFrame.rsub方法
454-1、语法
454-2、参数
454-3、功能
454-4、返回值
454-5、说明
454-6、用法
454-6-1、数据准备
454-6-2、代码示例
454-6-3、结果输出
455、pandas.DataFrame.rmul方法
455-1、语法
455-2、参数
455-3、功能
455-4、返回值
455-5、说明
455-6、用法
455-6-1、数据准备
455-6-2、代码示例
455-6-3、结果输出
二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 451、pandas.DataFrame.pow方法 451-1、语法 # 456、pandas.DataFrame.pow方法 pandas.DataFrame.pow(other, axis='columns', level=None, fill_value=None) Get Exponential power of dataframe and other, element-wise (binary operator pow).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d47e0c7c1e6463f8a0618ff5410a6868/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d14161535bf4ddc1dbb0178c06952c1/" rel="bookmark">
			Python知识点：如何使用Elasticsearch与Elasticsearch-py进行全文检索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Elasticsearch与elasticsearch-py库进行全文检索可以分为以下几个步骤：
1. 安装elasticsearch-py 首先，确保你已经安装了elasticsearch-py库。你可以使用pip来安装它：
pip install elasticsearch 2. 连接到Elasticsearch实例 使用elasticsearch-py库，你需要先连接到你的Elasticsearch实例。假设你在本地运行了Elasticsearch，你可以使用如下代码：
from elasticsearch import Elasticsearch # 连接到Elasticsearch es = Elasticsearch([{'host': 'localhost', 'port': 9200}]) 3. 创建索引（如果需要） 在进行全文检索之前，你需要一个索引。在索引中，你可以定义文档的结构及其映射（mappings）。下面是一个简单的例子：
# 创建一个索引并定义映射 index_name = 'my_index' mapping = { "mappings": { "properties": { "title": {"type": "text"}, "content": {"type": "text"}, "timestamp": {"type": "date"} } } } # 创建索引 es.indices.create(index=index_name, body=mapping) 4. 索引文档 你可以将文档索引到Elasticsearch中，以便后续的全文检索。每个文档都以JSON格式存储：
# 索引文档 doc = { "title": "My First Document", "content": "This is the content of the document"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d14161535bf4ddc1dbb0178c06952c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36fef12873571e7f50bf0f8d3cf995ea/" rel="bookmark">
			【C&#43;&#43;】单元测试覆盖率工具lcov的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文首发于 ❄️慕雪的寒舍
本文讲述了如何在C++代码中使用单元测试覆盖率工具lcov，以及gcov命令的使用。版本是lcov 2.0和gcov 11.4.0。
写在前面：lcov是我在实习期间初次接触到的工具，当时在配置的时候就遇到了大量中文互联网没有任何记录的问题。绝大部分博客对lcov工具的介绍仅停留在安装，并没有对它的使用和报告分析做出更进一步的详解，这也是慕雪撰写本文的原因。希望这篇文章能对需要使用lcov工具却又苦于没有引导教程的老哥提供一丝丝帮助。
1. 安装 安装lcov的方式比较简单，去github上下载官方的安装包就可以了。
# ubuntu安装依赖项 sudo apt-get install -y perl libcapture-tiny-perl libdatetime-perl libdatetime-format-dateparse-perl wget # 下载 wget https://github.com/linux-test-project/lcov/releases/download/v2.0/lcov-2.0.tar.gz # 解压 tar -zxvf lcov-2.0.tar.gz cd lcov-2.0 # 安装 sudo make install 安装完毕后查看版本号，成功出现版本号则代表安装成功。
❯ lcov --version lcov: LCOV version 2.0-1 更详细的lcov安装教程详见本站【Linux】lcov2.0安装和perl修改镜像源一文。另外，本文演示所用的单元测试框架Gtest也建议安装一下。需要说明的是，lcov的报告并不依赖于Gtest或任何测试框架，只要函数被调用、代码被运行了，它就可以生成覆盖率报告。
2. 基本命令 2.1. 手工执行 lcov的基本使用方式如下：
首先我们需要用g++命令编译gtest写出来的单元测试代码，使用-lgtest -lgtest_main -pthread链接gtest库和pthread库。选项-ftest-coverage可以让g++编译器在代码中插入额外的指令，来确认某部分的代码是否执行了，一般要和-fprofile-arcs连用才能产生完整的覆盖率报告。
程序运行后会产生.gcda、.gcov和.gcno文件，记录了覆盖率信息，lcov依赖于这些文件产生最终的html覆盖率报告。
g++ -std=c++17 test.cpp -o test \ -lgtest -lgtest_main -pthread \ -fprofile-arcs -ftest-coverage -fprofile-update=atomic g++命令最后的-fprofile-update=atomic是lcov 2.0中需要新增的一个编译选项，否则运行lcov的时候会有告警（具体记不清了，最初的记录里面忘记写这一块的内容了）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36fef12873571e7f50bf0f8d3cf995ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92df7c52be1749001814d85d2db96c60/" rel="bookmark">
			数据仓库系列10：如何处理维度表中的变化类型?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想象一下,你正在管理一个电商平台的数据仓库。突然,你发现一个重要客户的地址发生了变化。这个简单的变更可能会对你的分析产生巨大影响。如何确保你的数据仓库能够准确地反映这种变化,同时又不丢失历史信息?欢迎来到数据仓库中最具挑战性的问题之一:维度表变化的处理。
目录 什么是维度表?维度表变化的类型类型0:保持原样类型1:覆盖类型2:添加新行类型3:添加新属性类型4:添加微型维度类型5:微型维度与迷你维度类型6:混合处理方式 如何选择合适的变化类型实现维度表变化处理的最佳实践案例研究:电商平台客户维度表需求分析:解决方案:实现: 常见陷阱和解决方案总结与展望未来的发展趋势 在这篇文章中,我们将深入探讨维度表中的变化类型,以及如何有效地处理这些变化。无论你是经验丰富的数据工程师,还是刚刚踏入大数据领域的新手,这篇文章都将为你提供宝贵的见解和实用技巧。
什么是维度表? 在深入探讨维度表的变化类型之前,我们需要先明确维度表的定义和作用。维度表是数据仓库中的一种重要表类型,它用于存储与事实表中的数值度量相关的描述性信息。
例如,在一个电商数据仓库中:
事实表可能包含销售金额、数量等数值信息维度表则可能包含客户信息、产品详情、时间等描述性数据 维度表的主要特点包括:
包含描述性属性通常数据量相对较小与事实表形成星型或雪花模型用于数据分析和报表生成时的分组和筛选 以下是一个简单的客户维度表示例:
CREATE TABLE dim_customer ( customer_key INT PRIMARY KEY, customer_id VARCHAR(20), first_name VARCHAR(50), last_name VARCHAR(50), email VARCHAR(100), phone VARCHAR(20), address VARCHAR(200), city VARCHAR(50), state VARCHAR(50), country VARCHAR(50), postal_code VARCHAR(20), create_date DATE, update_date DATE ); 这个表包含了客户的各种属性,如姓名、联系方式、地址等。这些信息可能会随时间发生变化,而如何处理这些变化就是我们今天要讨论的核心问题。
维度表变化的类型 维度表中的数据并非总是静态的。随着时间的推移,客户可能会搬家,产品可能会更新描述,甚至公司的组织结构可能会发生变化。数据仓库需要能够反映这些变化,同时又要保持历史数据的完整性。为了应对不同的业务需求,Ralph Kimball定义了几种不同的维度表变化类型。
类型0:保持原样 定义:类型0变化实际上意味着不进行任何变化。一旦数据被加载到维度表中,就永远不会被修改。
适用场景:
永久不变的属性,如出生日期、原始交易ID等历史快照,如"首次购买日期" 优点:
实现简单保证数据的原始性 缺点:
无法反映实际变化可能导致数据不一致 示例代码:
对于类型0,我们实际上不需要执行任何特殊的操作。数据只在首次插入时被记录:
INSERT INTO dim_customer (customer_key, customer_id, first_name, last_name, birth_date) VALUES (1, 'C001', 'John', 'Doe', '1990-01-01'); -- 即使John的姓名发生变化,我们也不会更新这条记录 类型1:覆盖 定义:类型1变化是最简单的变化处理方式,它直接用新值覆盖旧值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92df7c52be1749001814d85d2db96c60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c1259838190747f92ce3a52c1884945/" rel="bookmark">
			SQLite Insert 语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQLite Insert 语句 SQLite 是一种轻量级的数据库管理系统，广泛用于各种应用程序中。它是一种嵌入式数据库，意味着它不需要独立的服务器进程或系统，可以直接在应用程序中运行。SQLite 支持标准的 SQL 语法，包括用于插入数据的 INSERT 语句。
SQLite Insert 语句的基本语法 INSERT 语句用于向 SQLite 数据库中的表添加新行。基本语法如下：
INSERT INTO 表名称 (列1, 列2, 列3, ..., 列N) VALUES (值1, 值2, 值3, ..., 值N); 表名称：指定要插入数据的表名。列1, 列2, ..., 列N：指定要插入数据的列名。列的顺序应与 VALUES 子句中值的顺序相匹配。值1, 值2, ..., 值N：指定要插入的具体数据。 示例 假设有一个名为 students 的表，包含 id, name, 和 age 三列。以下是一个插入新行的示例：
INSERT INTO students (id, name, age) VALUES (1, 'Alice', 20); 这个语句将在 students 表中插入一个新行，其中 id 为 1，name 为 'Alice'，age 为 20。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c1259838190747f92ce3a52c1884945/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a95241cc77e2e418b062f4c7f7cb9ae8/" rel="bookmark">
			喜羊羊做Python二级（模拟考试--易错点）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天距离Python二级考试，还有28天左右。坚持每天做几套试卷，保持记忆和手感。
个人在做题的过程中是先不断练习选择题。当你选择题不达标的时候，系统不会看大题（大概是觉得选择题都做的那么差，大题也不会那么好）。所以我们要先不断地去练习选择题，保持选择题的正确率，做后面的大题时，也得心应手一些。
准备的东西：打印的准考证（最好多打印几份，别问我为什么知道），身份证（如果是去别的学校，门口警卫要检查一下）。记得要带草稿纸和笔（我第一次吃亏了，不知道。遇到循环结构的时候，脑子都要想炸了，特别是循环+判断）。自己的手机也带着，放好，别被别人拿错了。
好，废话不多说，看今天遇到的易错题目好吧
第一题 考点： 这道题考察时组合数据类型有哪些。组合数据类型有3大类，集合类型、序列类型、字典类型。序列类型包括3个（字符串、列表、元组）。所以这道题选浮点数类型，其实浮点数也就是一个简单的小数点的数字，并不是什么组合数据。想想也很简单，不需要强记忆
第二题 考点： Python中有3中基本控制逻辑。顺序结构、选择结构（有多种选择，所以又叫分支结构）、循环结构。基于分支结构，Python增加了try-except异常处理。
第三题 考点：外存储器容量比较大，而且大部分可以移动，便于不同计算机之间交流。外存储器被读到内存储器后，才能被CPU读取。为什么？因为CPU不能直接访问外存储器。
这个过程就像，我拿U盘插入电脑，U盘还要等待读取。
第四题 考点： 机器数有原码、补码、反码三种表示。补码简单来说就是在原有的原码上加1。我个人是这样想的，计算机采用二进制数值表示数据，那么+1，则可以改变数值，表达别的数据
今天的分享就到这里，最近感觉身体上不佳，创作的激情也少了许多。但是人生总有这样的过程，也许低迷、也许迷茫、也许力不从心。别勉强自己，我相信我们能做的更好，挺过这段时间。加油！！！！谢谢羊粉的支持和关注。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcc6c44b96c83177fa0e232a80f02a62/" rel="bookmark">
			linux下一切皆文件，如何理解？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 linux下一切皆文件，不管你有没有学过linux，都应该听过这句话，就像java的一切皆对象一样。
今天就来看看它的真面目。
你记住了，只要一个竞争退出它的PCB要被释放文件名，客服表也要被释放。那么，指向这个文件的指针就少了啊，那么可以理解成，如果一个文件只被这一进程打开，这个文件也自动就被关掉了啊。
以前的文章说计算机体系结构的时候，说过最底最底下呢，我们是有一堆的硬件。不知道的可以看一下这个这篇文章花钱买不到系列—linux 冯诺依曼体系结构-CSDN博客
在我们的冯诺伊曼体结构里，这些设备都属于外设。还记得吗啊，属于外设的话，那么不管是键盘显示器磁盘还是网卡外部或外围设备？那么，它任何的数据处理都必须把数据先读到内存，然后处理完毕之后再将内存当中的数据刷新到外设当中。这叫做IO 。
对于我们来讲呢，键盘它也一定要有键盘所对应的一套读写方法。那么，因为我们曾经说过，操作系统为了管理所有的软硬件，那软硬件很多，所以操作系统它就必须得对所有的软硬件资源呢进行先描述，再组织。
所以不管是键盘、显示器、硬盘、网卡，都要有我们对应的结构体，那么它这些结构体里包含了这些设备，每一个设备对应的所有的属性信息。
那么这些设备呢，那么它对应的一定要有自己的对应的IO函数。那么你要输入输出嘛，所以我们也一定要有对应的这些方法，当然除了这些，它肯定还有其他方法啊。今天重点聊这个。
比如说键盘呢，它也一定要有对应的keyboardread()方法。也一定要有int keyboardwrite()方法，那你说我们经常键盘作为输入设备，那它有数据了，我主要是读取它，那么这里呢，读取它我可以理解。那么，其中呢？我什么时候会往键盘去写呢啊？我们从来没有往键盘里写。事实呢，我们也确实不会往键盘去写，但并不妨碍他有个写方法，这个写方法我们可以就是一个null。
那么我们允许你可以那么每一个硬件设备。都要有自己的读写方法，那么你如果天然不支持读或者写，那很好啊，不影响你的方法，为NULL就行了
具体的这些我们硬件的读写方法，一定是在自己的在各种硬件匹配的驱动程序里。
因为不同的硬件，那么它都有自己的读写方法。所以呢，那么每一个文件，它的驱动程序，那么都有自己的读写方法，这个肯定是不一样的。
学了一些这么多概念之后呢，也知道每一种我们对应的硬件，那么它的访问方法啊，方法是一定不一样的。肯定是不一样的，读磁盘怎么能跟读网卡一样呢？读我们的显示器怎么能跟读键盘一样呢？一定是不一样的啊，那么但是你怎么来表示这里的我们的键盘显示器磁盘或者网卡呢？
那么其中我们的linux呢？它做了一个设计，比如说呢，那么只要你进行读写。那么我可以抽象出，比如说键盘读写的时候，我可以认为你的那么目标写入的那个，你的存键盘的存储空间为零。那么你的数据，我在读的时候，那么你也有自己的状态啊，那么包括是被打开的还是被关闭的？那么键盘显示器它的所有的属性呢？我们都可以把它抽象出来啊
所以呢，那么我们linux当中呢，它是这么设计的啊，那么在我们的操作系统内部呢？一切皆文件体现的就是struct file，任何一个被打开的文件在内核里，我们的内核结构的对象就叫做struct feel类型的对象，包括了各种文件的属性啊。虽然底层的这些硬件呢，大家是有差别的读写方法一定不一样，但是属性呢？那么我们是可以通过数据层面上去把它统一下的。
比如说type表示什么类型的文件，status表示打开还是关闭，每一个虽然它打开方式不一样，但你有没有被打开我是知道的啊，所有属性呢？我们其实是可以公共性的抽取出来，只不过大家。属性的个数和具体属性的值写的不一样，但并不影响啊，那么这是其一。
其二呢，将来啊，一切皆文件对于操作系统来讲，操作系统会说啊，不同的文件呢，那么对应的读写方法是不一样的，那么file里面一定充满大量的函数指针。
那么其中呢？当我们打开我们对应的键盘时。把键盘的对应给它创建一个struct filel对象，然后怎么办呢？然后我们把那么read方法数属性初始化之后，让我们的函数指针。指向具体的我们键盘的读方法和键盘的写方法。
多来几个，就变成这个样子
而这个struck file对象里面的所有属性呢？可以根据硬件的不同去填充就可以。我在初始化这里的每一个不同的设备的时候，我们让它的函数指针指向我们，那么具体某一种硬件的读写方法啊，我们给它啊，比如说是我们的显示器的啊，比如说磁盘的读方法，磁盘的写方法，那么网卡的读方法，网卡的写方法。当然中间还有一对软件，只是简单一下，当然每个struct中还有一个指针，指向他们。这就是先描述后组织。
所以站在操作系统，站用户之上，压根不关心你你底层的差异。他要读文件的时候，他压根就不关心你底层。文件的所有的不同，对我看来上层我们无论是操作系统内部要读写这个文件，还是用户。那么，他们看到的只有struct filel读写方法时，他们直接调用对应的函数指针，指向具体方法，但用户不关心。所以在用户级下看到的就是一切皆文件。
所以这是什么？这就是多态，我们只需要使用我们对应的统一文件，那么我们就使用我们就可以访问同样的文件，那么底层的那么差异呢，其实就可以那么体现出来了，这是用C语言来实现的多态的特征啊，那么我们这里的s结构体就相当于是基类。上下下面的所有东西也称为子类，然后呢，这就是一种多态的实现啊。所以为什么现在很多语言都是支持面向对象或者说是多态，这都是经过工程师们的大量软件工程的结果。
到内核里里面看看是不是如我所说struct task_struct {}是进程的pcb
就是这里 struct files_struct，屏蔽底层差异化，在上层看来就是open打开文件close关闭文件 但是转到定义，会发现这里有一个指针数组，是指向被打开的文件
数组的大小是32，默认的 这里有一个二级指针，扩展打开的文件 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bbe14bd99a2fc9db95b2c0dd80debfa/" rel="bookmark">
			nextjs&#43;supabase判断是否登录核心代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import { NextRequest, NextResponse } from "next/server"; import { createClient } from '@/utils/supabase/server'; export async function middleware(request: NextRequest) { const { pathname } = request.nextUrl; // 允许未认证用户访问 /login 页面 if (pathname === '/login') { return NextResponse.next(); } const supabase = createClient(); const { data } = await supabase.auth.getSession(); // 如果用户未认证，重定向到 /login 页面 if (!data?.session?.user) { return NextResponse.redirect(new URL('/login', request.url)); } // 如果用户访问根路径或 /home，重定向到 /dashboard if (pathname === "/" || pathname.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bbe14bd99a2fc9db95b2c0dd80debfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1428d62e1ac30b468f4b898b06c8f3b3/" rel="bookmark">
			TCP并发服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单循环服务器：同一时刻，只能处理一个客户端的任务
并发服务器：同一时刻，只能处理多个客户端的任务
UDP 是具备并发性的，是因为UDP是无连接的，所以处理器可以处理过来
TCP实际上是单循环的服务器，只能建立一对一连接，其他人不能再与其建立连接，之前只有一个套接字
现状为了实现并发，我们给每一个连接都给予一个套接字
多进程流程：socket()---bind(）---listen()---accept() ---fork(）
IO多路复用：多个读写复用一个进程（在Linux里面就是文件读写）
阻塞IO：fgets,scanf,read,recv,getchar（用来实现多个IO同步的效果）
同步：具有先后顺序的效果（CPU占用率低，执行效率低）
非阻塞IO：非阻塞就是访问内核，有数据带着数据返回，没有数据也带着返回
（使用轮询方式实现，CPU占用率高）
获取方法： 1.获取原文件描述符的属性
2、增加非阻塞属性
3、设置新属性
信号驱动IO：实现：（当终端有输入的时候应该会触发，发射信号，才会执行）
1、增加异步属性 O_ASYNC（异步）,O_SYNC(同步）
2、关联信号和当前的进程
3、注册信号
特点： 1、异步通知io的方式，节省CPU
2、只能检测少量io
3、效率高
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1ea81c474c39e5a81d42c9e503a036e/" rel="bookmark">
			黑神话悟空用什么编程语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《黑神话：悟空》作为一款备受瞩目的国产单机动作游戏，其背后的开发涉及了多种编程语言和技术。根据公开信息和游戏开发行业的普遍做法，可以推测该游戏主要使用了以下几种编程语言：
C++：
核心编程语言：作为《黑神话：悟空》开发过程中的核心编程语言，C++在游戏的底层架构、引擎优化以及高性能计算方面发挥了关键作用。这是因为C++具有极高的性能和灵活性，能够实现复杂的内存管理、精细的操作系统控制，以及对硬件的高效调用，这些都是高质量3A游戏所必需的。
引擎底层：该游戏使用的是虚幻引擎（Unreal Engine），而虚幻引擎的底层源码主要就是用C++编写的。虚幻引擎由Epic Games公司开发，是一个广泛应用于游戏开发领域的强大工具。
C#：
辅助编程语言：虽然C++是主要的开发语言，但《黑神话：悟空》的开发过程中也可能用到了C#。这主要是因为虚幻引擎（尽管其底层是C++）同时也支持C#作为脚本语言，特别是在游戏逻辑的实现和UI界面的开发上，C#的丰富库和强大的面向对象特性能够为开发者提供便利。
Unity引擎的可能性：虽然官方确认使用的是虚幻引擎，但有分析提到Unity引擎在国内市场的流行度以及它支持C#作为脚本语言的特点，使得《黑神话：悟空》也有可能基于Unity引擎进行部分开发或测试。然而，这并非官方信息，仅作为可能性存在。
其他语言和技术：
Shader语言：在游戏开发中，用于图形渲染的Shader语言也是必不可少的。这些语言（如GLSL、HLSL等）允许开发者直接控制GPU的渲染过程，实现各种复杂的视觉效果。
音频编辑软件：音效处理方面，开发团队可能使用了专业的音频编辑软件，这些软件通常支持多种编程语言或脚本语言用于音频的编辑、合成和效果处理。
其他工具和插件：为了提升开发效率和游戏质量，开发团队还可能采用了各种第三方工具和插件，这些工具和插件可能支持多种编程语言。
综上所述，《黑神话：悟空》的开发过程中主要使用了C++作为核心编程语言，并可能辅以C#等其他语言和技术。这些编程语言的运用不仅提高了游戏的制作效率和质量，也为玩家带来了更加逼真和沉浸式的游戏体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59d35a497df2f677d6ec4555c0276ee1/" rel="bookmark">
			DNS劫持问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
DNS劫持概述
定义
图示
​编辑图示说明
DNS劫持的原理
1. DNS请求与响应过程
图示
​编辑2. 劫持发生点
本地劫持
路由器劫持
中间人攻击
图示
​编辑图示说明
DNS劫持的影响
1. 对个人用户的影响
图示
​编辑图示说明
2. 对企业的影响
图示
​编辑图示说明
DNS劫持的检测方法
1. 使用特定命令或工具检测DNS响应
图示
​编辑2. 检查路由器设置
图示
​编辑3. 使用在线服务检测DNS服务器
图示
​编辑预防DNS劫持的措施
1. 避免点击可疑链接
图示
​编辑2. 使用可靠的反病毒软件
图示
​编辑3. 使用VPN
图示
​编辑4. 更改路由器密码
图示
​编辑5. 启用DNSSEC
图示
​编辑结论
DNS劫持的常见问题
定义
原理
图示
图示
​编辑结论
DNS劫持概述 定义 DNS劫持是一种网络攻击方式，攻击者通过篡改DNS查询结果，将用户流量重定向到恶意网站。用户可能在不知情的情况下访问了伪装成合法网站的恶意网站，从而泄露个人信息或遭受其他形式的网络攻击。
图示 为了帮助理解DNS劫持的定义，我们可以绘制一个简单的示意图：
图示说明 用户设备：发起DNS查询的终端设备。
DNS服务器：处理DNS查询的服务器。
合法网站：用户本来希望访问的网站。
恶意网站：攻击者创建的伪装成合法网站的网站。
在正常情况下，DNS服务器应返回合法网站的IP地址。但在DNS劫持情况下，DNS服务器被篡改，返回恶意网站的IP地址，从而将用户流量重定向到伪装成合法网站的恶意网站。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59d35a497df2f677d6ec4555c0276ee1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4ddef85293e7a8ea8a94e4fe85ecb21/" rel="bookmark">
			Spark on YARN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache Spark 和 Apache Hadoop YARN 是两个紧密相关的项目，它们经常一起使用来处理大规模数据集。下面我将解释 Spark 如何与 YARN 配合工作，以及如何在 YARN 上运行 Spark 应用程序。
Apache Spark Apache Spark 是一个快速通用的大规模数据处理引擎，支持多种计算模式，如批处理、流处理、机器学习和图形处理。Spark 提供了一个统一的编程模型，可以在单个集群上运行各种类型的应用程序。
Apache Hadoop YARN Apache Hadoop YARN (Yet Another Resource Negotiator) 是 Hadoop 的资源管理系统，它负责管理和调度集群上的资源（如 CPU、内存）。YARN 使 Hadoop 能够支持多种计算框架，而不仅仅是 MapReduce。
Spark on YARN Spark 可以在 YARN 上运行，这允许 Spark 应用程序利用 YARN 的资源管理和调度能力。以下是 Spark 在 YARN 上运行的一般流程：
提交 Spark 应用程序:
使用 spark-submit 命令提交 Spark 应用程序到 YARN。spark-submit 命令可以指定 --master yarn 来指示 Spark 应用程序将在 YARN 上运行。 YARN 资源管理:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4ddef85293e7a8ea8a94e4fe85ecb21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43e9091c82b3660249526f82e2acb27f/" rel="bookmark">
			二十个案例入门CSS3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知识点总结： 1. 基础样式与选择器 颜色与背景：通过 background-color 设置背景颜色，color 设置文本颜色。字体与文本：使用 font-family 设置字体，font-size 设置字体大小，text-align 控制文本对齐。内外边距：使用 padding 设置内边距，margin 设置外边距。 2. CSS 盒模型 了解元素的 width、height、border、padding、margin 以及盒模型的布局机制。 3. 定位与布局 浮动布局 (Float)：通过 float 实现元素的左右浮动布局，搭配 clear 属性清除浮动。弹性布局 (Flexbox)：使用 display: flex 创建弹性布局，配合 flex-direction、justify-content、align-items 等属性实现灵活的布局方式。网格布局 (CSS Grid)：通过 display: grid 创建网格布局，使用 grid-template-columns、gap 等属性定义网格结构。 4. 响应式设计 使用 媒体查询 (Media Queries) 实现根据屏幕宽度动态调整布局。弹性网格布局：利用 auto-fit 和 minmax 创建可自动适应屏幕宽度的网格布局。 5. CSS3 视觉效果 渐变 (Gradient)：通过 linear-gradient 和 radial-gradient 创建线性与径向渐变效果。边框与阴影：使用 border-radius 实现圆角效果，使用 box-shadow 添加阴影效果。透明与滤镜：通过 opacity 设置元素透明度，使用 filter 实现灰度、模糊等滤镜效果。背景图像：使用 background-image 设置背景图像，并配合 background-size、background-position、background-attachment 实现固定背景、覆盖背景等效果。 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43e9091c82b3660249526f82e2acb27f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/146a22c07fcd56d60ea4f7d406595070/" rel="bookmark">
			缓存&amp;Mybatis一级缓存与二级缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 缓存 为什么使用缓存 缓存(cache)的作用是为了减去数据库的压力,提高查询性能,缓存实现原理是从数据库中查询出来的对象在使用完后不销毁,而是存储在内存(缓存)中,当再次需要获取对象时,直接从内存(缓存)中提取,不再向数据库执行select语句,从而减少了对数据库的查询次数,因此提高了数据库的性能.
数据缓存 让数据离我们的执行程序更近,让程序能快速获取数据
Mybatis缓存 有缓存时查询流程 有缓存,先从缓存中查询,缓存中如果没有,就从数据库查询,查询到后把数据
mybatis一级缓存 开始于sqlsession创建
结束于sqlsession关闭,如果期间执行了新增,删除,修改操作也会清空当前sqlsession对象中缓存数据
调用sqlSession.clearCache();强制清空一级缓存的数据
Mybatis二级缓存 二级缓存时sqlSessionFactory级别,可以让多个sqlsession共享数据
mybatis默认没有开启二级缓存,使用时需要配置开启
如果开启了二级缓存,当sqlsession关闭时,会将一级缓存中的数据存储到二级缓存中
其他的sqlsession就可以从二级缓存中查询到之前sqlsession查询的数据
配置二级缓存配置
第一步：启用二级缓存
在 SqlMapperConfig.xml 中启用二级缓存，如下代码所示，当cacheEnabled 设置为 true 时启用二级缓存，设置为 false 时禁用二级缓存。
第二步：对象序列化
将所有的 POJO 类实现序列化接口 Java.io. Serializable。
第三步：配置映射文件
在 Mapper 映射文件中添加，表示此 mapper 开启二级缓存。
当 SqlSeesion 关闭时,会将数据存入到二级缓存.
Mybatis架构 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53182545d36ef1544fb170705c51603e/" rel="bookmark">
			外包干了两年，快要废了。。。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍅 点击文末小卡片，免费获取软件测试全套资料，资料在手，涨薪更快 简单的说下，我大学的一个同学，毕业后我自己去了自研的公司，他去了外包，快两年了我薪资、技术各个方面都有了很大的提升，他在外包干的这两年人都要废了，技术没一点提升，学不到任何东西，一直都在点点点，其实感觉挺可惜的，毕竟我和他关系还算不错！
前段时间他和我说了下，说不能在废下去了，要想办法自救了，干了近两年的功能测试，他一个00后的小伙子都要变成50岁的保安大爷了，完全不思进取，我问他为啥想到要自救，前面进取心不是被磨灭的差不多了吗？他开玩笑似的说，主要自己身边有个卷王，两年不到就跳槽涨薪了，有点小嫉妒。我一听，这不是我吗？人还是得比较才会有前进的动力，最近他也开始自学起来，也卷了起来，我自己也把从字节大牛学长那里弄到的《软件测试资源》给了他，也算是为他的自学之路添一把火吧！ 也和他说了有啥问题可以找我，能帮的就帮了，帮不到那你自求多福吧！顺便还打趣他，说你再这么混下去，你女朋友都要跑了，哈哈哈哈......
同时，我这里也简单的介绍一下这份大牛分享的《软件测试资源》【免费领取的啊】，包括测试理论、Linux基础、MySQL基础、Web测试、接口测试、App测试、Python基础、Selenium相关、性能测试相关等，希望可以帮助到各位！
软件测试基础 软件测试的步骤是什么?如何录制测试脚本?应该考虑进行如何测试的测试方法怎样估计测试工作量?测试设计的问题当测试过程发生错误时，有哪几种解决办法?测试执行的问题测试评估的目标如何提高测试?C/S模式的优点和缺点B/S模式的优点和缺点… Linux grep和find的区别? grep 都有哪些用法?查看IP地址?创建和删除一个多级目录?在当前用户家目录中查找haha.txt文件?如何查询出tomcat的进程并杀掉这个进程，写出linux命令?动态查看日志文件?查看系統硬盘空间的命令?查看当前机器listen 的所有端口?… Python编程 统计python源代码文件中代码行数，去除注释，空行，进行输出?python调用cmd并返回结果?冒泡排序1,2,3,4 这4个数字，能组成多少个互不相同的且无重复的三位数，都是多少?请用 python 打印出 10000 以内的对称数（对称数特点：数字左右对称，如：1,2,11,121,1221 等）给定一个整数 N，和一个 0-9 的数 K，要求返回 0-N 中数字 K 出现的次数判断 101-200 之间有多少个素数，并输出所有的素数一个输入三角形的函数，输入后输出是否能组成三角形，三角形类型，请用等价类- 划分法设计测试用例… MySQL 你用的Mysql是哪个引擎，各引擎之间有什么区别?如何对查询命令进行优化?数据库的优化?Sql注入是如何产“生的，如何防止?NoSQL和关系数据库的区别?MySQL与MongoDB本质之间最基本的差别是什么Mysql数据库中怎么实现分页?Mysql数据库的操作?优化数据库?提高数据库的性能?什么是数据的完整性?… Web测试 Web测试和app测试区别？WEB测试环境搭建和测试方法WEB测试教程WEB测试要点及基本方法Web测试页面总结… 接口测试 什么是接口如果模块请求http改为了https,测试方案应该如何制定，修改?常用HTTP 协议调试代理I具有什么?详细说明抓取HTTPS协议的设置过程?描述TCP/IP协议的层次结构，以及每一-层中重要协议jmeter,一个接口的响应结果如下:接口产生的垃圾数据如何清理依赖第三方的接口如何处理测试的数据你放在哪?什么是数据驱动，如何参数化?… 性能测试 你认为性能测试的目的是什么?做好性能测试的工作的关键是什么?服务端性能分析都从哪些角度来进行?如何理解压力测试，负裁测试以及性能测试?如何判断是否有内存泄漏及关注的指标?描述软件产“生内存泄露的原因以及检查方式。(可以结合- 种开发语言进行描述)简述什么是值传递，什么是地址传递，两者区别是什么?什么是系统瓶颈?… selenium 如何开展自动化测试框架的构建?如何设计自动化测试用例:webdriver如何开启和退出一个浏览器?什么是自动化测试框架?Selenium是什么，流行的版本有哪些?你如何从命令行启动Selenium RC?在我的机器端口4444不是免费的。我怎样才能使用另一个端口?什么是Selenium Server,它与Selenium Hub有什么不同?你如何从Selenium连接到数据库?你如何验证多个页面上存在的一个对象?XPath中使用单斜杠和双斜杠有什么区别?如何编写SeleniumIDE/ RC的用户扩展?如何在页面加载成功后验证元素的存在?你对Selenium Grid有什么了解?它提供了什么功能?如何从你的Java Class启动Selenium服务器?Selenium中有哪些验证点?什么是XPath?什么时候应该在Selenium中使用XPath? …
计算机与网络 一台计算机的IP是192.168.10.71子网掩码255.255.255.64与192.168.10.201 …请简述DNS、活动目录、域的概念。10M兆宽带是什么意思?理论下载速度是多少?什么是IP地址?OSI七层网络模型的划分?TCP和UDP有什么不同?HTTP属于哪一层的协议?HTTP和HTTPS的区别?cookies和session的区别?HTTP的get请求和post请求的区别?HTTP1.0和HTTP1.1有什么区别TCP的连接建立过程，以及断开过程?客户端使用DHCP获取IP的过程?写出某个网段的网络地址和广播地址?… 人力资源 你的测试职业发展是什么？你自认为做测试的优势在哪里？你找工作时，最重要的考虑因素为何？为什么我们应该录取你？请谈谈你个人的最大特色。一个测试工程师应具备那些素质和技能？还有问一下你是怎样保证软件质量的，也就是说你觉得怎样才能最大限度地保证软件质量？为什么选择测试这行？如果我雇用你，你能给部门带来什么贡献？… 整份文档一共有208 页，全部为大家展示出来肯定是不太现实的，为了不影响大家的阅读体验就只展示了部分内容，还望大家海涵，希望能帮助到您面试前的复习且找到一个好的工作，也节省大家在网上搜索资料的时间来学习！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e04cf0c147d69500fc5e36c117948780/" rel="bookmark">
			Ubuntu 16.04下Firefox版本更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Ubuntu 16.04系统下更新Firefox浏览器到最新版本是一个相对直接但需要注意细节的过程。由于Ubuntu 16.04是一个较旧的操作系统版本，其默认的软件包管理器apt可能无法提供最新版本的Firefox。因此，用户通常需要手动下载Firefox的最新版本并进行安装。以下是一个详细的步骤指南，帮助您在Ubuntu 16.04系统下更新Firefox浏览器。
一、准备工作 备份当前Firefox设置（可选）：
在更新Firefox之前，建议备份当前的浏览器设置、书签、密码等。虽然手动更新Firefox通常不会覆盖这些设置，但备份总是一个好习惯。
查看当前Firefox版本：
打开终端（Terminal），输入firefox --version命令查看当前安装的Firefox版本。了解当前版本有助于您确定需要更新的版本范围。
确定需要的Firefox版本：
根据需求（如特定软件的兼容性要求），确定您需要的Firefox版本。通常，最新版本的Firefox提供了更好的性能、安全性和功能。
二、下载Firefox新版本 访问Firefox官方网站：
使用浏览器访问Mozilla Firefox的官方网站或Firefox的下载页面。
下载最新版本的Firefox：
在Firefox下载页面上，选择适合您操作系统的版本。对于Ubuntu 16.04，您可能需要下载Linux版本（通常是.tar.bz2格式的压缩包）。
保存下载文件：
将下载的Firefox压缩包保存到您的Ubuntu系统的某个目录下，例如/Downloads或/home/您的用户名/Downloads。
三、卸载旧版本的Firefox（可选） 如果您想完全替换旧版本的Firefox，可以首先卸载它。打开终端，输入以下命令：
sudo apt-get remove firefox 请注意，这个命令只会卸载Firefox软件包，不会删除您的个人数据（如书签、历史记录等），这些数据通常存储在用户的主目录下。
四、安装新版本的Firefox 解压下载的Firefox压缩包：
打开终端，导航到包含Firefox压缩包的目录。使用tar命令解压压缩包。例如，如果您的压缩包名为firefox-xxx.tar.bz2（其中xxx是版本号），则可以使用以下命令解压：
cd /path/to/your/download/directory sudo tar xvf firefox-xxx.tar.bz2 -C /opt/ 这里-C /opt/参数指定了解压目录，但您也可以根据需要选择其他目录。
创建符号链接：
为了方便在终端中启动Firefox，您可以在/usr/bin/目录下创建一个指向Firefox可执行文件的符号链接。首先，确保您知道Firefox可执行文件的确切路径（通常位于您解压的目录中）。然后，使用ln命令创建链接：
sudo ln -s /opt/firefox/firefox /usr/bin/firefox 注意：这里的/opt/firefox/firefox是假设的Firefox可执行文件路径，您需要根据实际情况进行修改。
（可选）创建桌面快捷方式：
如果您想从图形界面快速启动Firefox，可以创建一个桌面快捷方式。使用文本编辑器（如gedit或nano）在/usr/share/applications/目录下创建一个新的.desktop文件，并填写相应的内容。例如：
sudo nano /usr/share/applications/firefox.desktop 然后，在文件中输入以下内容（请根据实际情况修改路径和图标）：
[Desktop Entry] Version=1.0 Type=Application Name=Firefox Comment=Browse the Web Exec=/opt/firefox/firefox Icon=/opt/firefox/browser/chrome/icons/default/default128.png Terminal=false Categories=Application;Network;WebBrowser; StartupWMClass=Firefox 保存并关闭文件。现在，您应该可以在应用程序菜单中找到Firefox的快捷方式了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e04cf0c147d69500fc5e36c117948780/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6019a80f6991f355215c8daccad61d60/" rel="bookmark">
			AI文案新纪元：用ChatGPT构建你的文案创作系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、ChatGPT在文案创作中的独特优势1. 高效生成，快速响应市场2. 个性化定制，精准触达受众3. 创新表达，提升内容吸引力 二、构建文案创作系统的详细步骤1. 需求分析与系统规划2. 接入ChatGPT API与集成开发3. 设计用户友好的交互界面4. 制定指令模板与参数设置5. 持续优化与迭代 三、应用实例与前景展望应用实例 《ChatGPT+AI文案写作实战108招》内容简介作者简介目录前言/序言内页插图 在数字化时代，文案作为品牌与消费者之间的桥梁，其重要性不言而喻。然而，面对日益增长的内容需求和激烈的市场竞争，如何高效、精准地创作出吸引人的文案成为了众多内容创作者面临的挑战。幸运的是，随着人工智能技术的飞速发展，ChatGPT等生成式AI模型为我们提供了一种全新的解决方案——构建智能化的文案创作系统。
一、ChatGPT在文案创作中的独特优势 1. 高效生成，快速响应市场 在快节奏的商业环境中，时间就是金钱。ChatGPT以其强大的语言生成能力，能够在极短的时间内生成大量文案草稿，极大地缩短了创作周期。例如，在电商大促期间，商家可以利用ChatGPT快速生成各类促销文案，确保活动信息的及时传达，吸引更多消费者关注。
2. 个性化定制，精准触达受众 每个品牌都有其独特的定位和受众群体。ChatGPT通过理解用户输入的指令和参数，能够生成符合品牌风格和受众喜好的个性化文案。比如，一家面向年轻消费者的时尚品牌，可以要求ChatGPT生成具有潮流元素和年轻语态的社交媒体文案，以此吸引目标受众的注意。
3. 创新表达，提升内容吸引力 创新是文案的灵魂。ChatGPT在生成文案时，能够融合多种语言风格和表达方式，创造出新颖独特的文案内容。这种创新性不仅有助于提升品牌形象，还能在众多信息中脱颖而出，吸引用户的点击和阅读。例如，在广告创意中，ChatGPT可以生成一系列富有创意和趣味性的广告语，让产品更加引人入胜。
二、构建文案创作系统的详细步骤 1. 需求分析与系统规划 在构建文案创作系统之前，首先需要明确系统的具体需求和目标。这包括确定文案的类型（如产品描述、新闻稿、社交媒体文案等）、目标受众、风格偏好以及预期效果等。同时，还需要对ChatGPT的能力进行评估，以确保其能够满足系统需求。在此基础上，制定系统的整体规划和实施计划。
2. 接入ChatGPT API与集成开发 选择一家可靠的AI服务提供商，接入ChatGPT的API接口。通过API接口，系统可以实时调用ChatGPT的生成能力。在集成开发过程中，需要设计合理的系统架构和数据流程，确保系统能够稳定运行并高效地与ChatGPT进行交互。
3. 设计用户友好的交互界面 为了方便用户操作，需要为文案创作系统设计一个直观易用的交互界面。界面应包含清晰的输入区域（用于输入指令和参数）、输出区域（用于展示生成的文案）以及必要的控制按钮（如生成、修改、保存等）。同时，还可以提供预览功能，让用户能够实时查看文案效果并进行调整。
4. 制定指令模板与参数设置 为了提高ChatGPT生成文案的准确性和效率，可以制定一系列指令模板。这些模板应涵盖常见的文案类型和场景，并包含明确的指令和参数设置。例如，对于产品描述文案，可以设定产品名称、特点、优势等参数；对于社交媒体文案，则可以设定话题、情感倾向、受众群体等参数。用户在使用系统时，只需选择相应的模板并填写必要的信息，即可快速生成高质量的文案。
5. 持续优化与迭代 文案创作系统是一个不断优化和迭代的过程。在使用过程中，需要不断收集用户反馈和数据指标（如点击率、转化率等），分析系统的性能和效果。根据分析结果，对系统进行调整和优化。例如，可以优化指令模板以提高生成文案的准确度；可以引入更多样化的语言风格和表达方式以增加文案的吸引力；还可以开发更多的功能模块以满足用户的不同需求。
三、应用实例与前景展望 应用实例 品牌营销：某知名化妆品品牌利用ChatGPT构建了一套智能化的品牌宣传文案创作系统。该系统能够根据产品特性和目标受众生成个性化的宣传文案，并通过社交媒体等渠道进行广泛传播。结果显示，该品牌的品牌知名度和用户粘性均得到了显著提升。广告推广：一家电商平台在双十一大促期间利用ChatGPT生成了大量创意独特的广告文案。这些文案不仅吸引了消费者的眼球，还成功引导了大量用户进行购买。最终，该电商平台的销售额实现了大幅增长。自媒体内容创作：一位自媒体博主利用ChatGPT辅助自己的内容创作工作。他通过输入关键词和主题要求，让ChatGPT生成文章的大纲和初稿。然后，他再根据初稿进行修改和完善，最终创作出高质量的内容。这种方式极大地提高了他的创作效率和内容质量。 随着人工智能技术的不断发展和完善，ChatGPT等生成式AI模型在文案创作领域的应用前景将更加广阔。未来，我们有望看到更多智能化的文案创作系统涌现出来，为内容创作者提供更加便捷、高效、个性化的创作工具。同时，随着技术的不断进步和成本的降低，这些智能创作系统也将逐渐普及到更多的行业和领域中去。无论是品牌营销、广告推广还是自媒体内容
《ChatGPT+AI文案写作实战108招》 获取方式： https://item.jd.com/14157043.html
内容简介 《ChatGPT+AI文案写作实战108招》通过10个专题内容、108个实用技巧、240多分钟教学视频，讲解了以ChatGPT平台为代表的AI生成文案的方法，具体内容按以下两条线展开。
一是技能线：前3章内容详细讲解了ChatGPT平台的运用、向ChatGP提问的方法和高效提问的使用技巧，让读者从宏观上把握ChatGPT生成文案的技巧。
二是案例线：后7章内容包括6个文案场景和1个综合案例的AI文案生成技巧，分别为办公类文案写作、艺术类文案写作、学术类文案写作、娱乐类文案写作、媒体类文案写作、营销类文案写作和AI写作全流程案例，让读者结合具体的文案场景掌握ChatGPT生成文案的技巧。
本书案例丰富，实战性强，适合对AI文案感兴趣的读者，特别是文案策划者、文案写作人员、电商商家、新媒体编辑、广告策划者、短视频编导、作家和艺术工作者等，也可作为文学、语言、计算机等相关专业的教材。
作者简介 苏海，资深互联网人士，ChatGPT、文心一言等数据大模型首批使用者；对ChatGPT提问经验丰富，超过10000+组人机互动提问词研究和实战应用；运用ChatGPT进行过各类文案的写作，如办公类文案、艺术类文案、学术类文案、营销类文案等；著有畅销书《活动策划实战宝典：品牌推广+人气打造+实战案例》。
目录 第1 章 技能入门：熟悉ChatGPT 平台的运用 001 ◎ 1.1 掌握ChatGPT 的基本用法002 001 让ChatGPT 生成文案002 002 让ChatGPT 停止生成文案003 003 让ChatGPT 重新生成文案003 004 移动鼠标选择复制文案004 005 单击相应按钮复制文案005 006 输入提示词时进行换行 006 007 改写发送的指令或提示词008 ◎ 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6019a80f6991f355215c8daccad61d60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97e1152dc76871984c344b526f315f75/" rel="bookmark">
			Python编写BC260Y TCP数据收发压力测试脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python编写BC260Y TCP数据收发压力测试脚本 使用BC260Y的TCP AT命令发送数据时，能够在数据中带有’\r\n’（回车换行），而其他模组会将’\r\n’当做AT命令处理的结束符，例如EC800E，为了验证TCP数据中带有’\r\n’时数据发收的稳定性，决定进行压力测试。
编写一个Python脚本周期向TCP服务器发送1024字节数据（数据中带有不止一个’\r\n’），在超时时间内判断是否发送成功和接收成功。TCP服务器同样以’\r\n’为结束符，收到结束符后将收到的所有数据原封不动回发。所有的数据收发log保存到文件，便于出错后分析。
使用串口工具测试步骤如下：
编写Python脚本：
######################################### ## AT测试脚本：根据BC260Y模组TCP模块编写TCP压力测试脚本，模组使用直吐模式连接TCP服务器，每隔5s向服务器发送1024字节数据，服务器以'\r\n'（回车换行）作为数据接结束标志，将接收到的数据返回 ## pyhton版本：3.6.5 ## 需要安装的第三方库：pip install pyserial ######################################### ## -- coding: utf-8 -- import os import sys import threading import time import datetime import msvcrt import serial import logging import signal import json import hmac import base64 from hashlib import sha256 ############# 宏定义(开始) #################### ATCOM = 'COM38' ATBaud = 9600 LOGNamePrefix = 'LOG-NAME' g_ExitFlag = 0 ## 0--未退出；1--退出 g_RecvResult = 0 ## 0--未接收；1--接收成功 g_RecvData = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97e1152dc76871984c344b526f315f75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d936b84882ec5c449d4367016c5ae87/" rel="bookmark">
			python自动化脚本：让工作自动化起来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python是一种流行的编程语言，以其简洁和易读性而闻名。它提供了大量的库和模块，使其成为自动化各种任务的绝佳选择。
我们将探讨9个Python脚本及其代码，可以帮助您自动化各种任务并提高工作效率。无论您是开发人员、数据分析师还是只是想简化工作流程的人，这些脚本都能满足您的需求。
以下是9个最佳Python脚本，这些脚本可以帮助您自动化各种工作任务，提高工作效率：
1. 自动化文件管理 1.1 文件排序
功能：按文件扩展名对目录中的文件进行排序，并将它们移动到相应的子目录中。示例代码：import os from shutil import move def sort_files(directory_path): for filename in os.listdir(directory_path): if os.path.isfile(os.path.join(directory_path, filename)): file_extension = filename.split('.')[-1] destination_directory = os.path.join(directory_path, file_extension) if not os.path.exists(destination_directory): os.makedirs(destination_directory) move(os.path.join(directory_path, filename), os.path.join(destination_directory, filename)) 1.2 删除空文件夹
功能：删除指定目录中的空文件夹。示例代码：import os def remove_empty_folders(directory_path): for root, dirs, files in os.walk(directory_path, topdown=False): for folder in dirs: folder_path = os.path.join(root, folder) if not os.listdir(folder_path): os.rmdir(folder_path) 1.3 重命名多个文件
功能：根据提供的旧名称和新名称，批量重命名目录中的文件。示例代码：import os def rename_files(directory_path, old_name, new_name): for filename in os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d936b84882ec5c449d4367016c5ae87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fefafe336020db9b1cbb0ecbd87fd85/" rel="bookmark">
			.NET8 Web 利用BAT命令 一键部署 IIS - CI-CD基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Windows Server 前置准备 1.1 IIS安装好 1.2 .NET8 Sdk 运行时 安装 官方下载地址：https://dotnet.microsoft.com/zh-cn/download/dotnet/8.0
1.3 创建一个.NET8 WebMvc项目 生成发布包 微软MVC这个项目模板直接创建，发布
2. 利用 BAT 来一键部署 Web站点 2.1 发布前 - IIS 和 应用程序池（没有东西） 2.2 编辑一个 AutoDeployNET8Web.bat，放在发布目录中 2.3 右键管理员权限运行 AutoDeployNET8Web.bat 2.4 查看 Web站点和 应用程序池 创建成功 2.5 根据控制台 提示 打开 http://127.0.0.1:8080/ 2.6 恭喜，Success！ 如果日常工作是手动发布的方式，可以慢慢修改为一键发布。
================ 分割线 ================
附录 AutoDeployNET8Web.bat 内容参照 :: 防止中文输出乱码(虚拟目录存在中文时会出现乱码，把这句话放出来) :: chcp 65001 :: 切换到当前bat所在的目录 cd /d %~dp0 :: 设置当前bat所在目录为站点所在目录 @set "sitePath=%cd%\" :: 设置IISWeb站点名称 @set WebSiteName="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fefafe336020db9b1cbb0ecbd87fd85/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/18/">«</a>
	<span class="pagination__item pagination__item--current">19/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/20/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>