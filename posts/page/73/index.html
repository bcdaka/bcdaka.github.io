<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9cc34866b2c169079ac831cb304cbe5/" rel="bookmark">
			Kafka &#43; Kraft 集群搭建教程，附详细配置及自动化安装脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要介绍 kafka + kraft 搭建过程，主要用途是为了日志采集，所以搭建相对比较简单暴力，不过也可以作为一个参考供大家学习，主打一个能用管跑（调优啊，参数解释啊，原理啊，太枯燥了，你自己搜吧）。
我们的日志采集架构比较传统，基于 filebeat -&gt; kafka -&gt; logstash -&gt; local file -&gt; nfs. 没有引入 ES 之类的流行的玩法，因为成本有限，人手有限，精力有限，哈哈，我是不会告诉你是因为研发习惯了 grep 日志文件的，咱也没啥动力去改变人家的习惯哈。
废话不多说，欢迎关注公&amp;号：新质程序猿，可以获取到最新的资源哟。
kraft 协议是 kafka 自研的用于替代 zk 的分布式协调方案，因为可以少安装一个 zk，管理起来肯定方便不少，拥抱新东西呗！
机器规划 准备3台机器，我这里准备了 3 台 centos 系统，其他系统也可以，反正 java 是跨平台的。
10.100.8.201 nodeId=1 broker=9092 controller=9093
10.100.8.202 nodeId=2 broker=9092 controller=9093
10.100.8.203 nodeId=3 broker=9092 controller=9093
备注：controller 取代了之前的 zookeeper
内核优化 主要就是文件句柄啥的，不知道为啥操作系统把 ulimit 搞成 1024 那么小。
sysctl -a -r "^net.(ipv4|core)" &gt; /tmp/sysctl_output.txt cat &lt;&lt; EOF &gt; /etc/sysctl.d/custom.conf net.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9cc34866b2c169079ac831cb304cbe5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9646d12eaae63924f4273da7bcb27e17/" rel="bookmark">
			未来已来：全方位掌握【人工智能】的系统学习路线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
第一部分：基础知识
1. 数学基础
1.线性代数
2.微积分
3.概率与统计
4.离散数学
2. 计算机基础
1.编程语言
2.数据结构和算法
3.计算机体系结构
第二部分：核心技术
1. 机器学习
1.监督学习
2.无监督学习
3.强化学习
2. 深度学习
1.基础知识
2.卷积神经网络（CNN）
3.循环神经网络（RNN）
4.生成对抗网络（GAN）
3. 自然语言处理（NLP）
1.文本预处理
2.语言模型
3.应用
第三部分：实践应用
1. 数据采集与处理
1.数据采集
2.数据清洗
3.数据增强
2. 模型训练与优化
1.模型训练
2.模型优化
3.模型部署
3. 实战项目
1.图像分类
2.自然语言处理
3.强化学习
第四部分：进阶学习
1. 前沿技术
1.联邦学习
2.自监督学习
3.解释性AI
2. 领域知识
1.医学影像分析
2.金融风控
3.智能制造
第五部分：资源与工具
结语
前几天偶然发现了一个超棒的人工智能学习网站，内容通俗易懂，讲解风趣幽默，简直让人欲罢不能。忍不住分享给大家，点击这里立刻跳转，开启你的AI学习之旅吧！
前言 – 人工智能教程​编辑https://www.captainbed.cn/lzxhttps://www.captainbed.cn/lzx
前言 人工智能（Artificial Intelligence, AI）是当前科技发展的前沿领域，广泛应用于各行各业。学习AI需要系统的知识体系和丰富的实践经验。本文将详细介绍AI的学习路线，分点讲解各个部分的具体实例，帮助学习者全面掌握AI技术。
第一部分：基础知识 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9646d12eaae63924f4273da7bcb27e17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57d27a9de919eadc6420c3004e71999f/" rel="bookmark">
			SignalR 服务端/SignalR C#客户端/SignalR js客户端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SignalR 服务端/SignalR C#客户端/SignalR js客户端 服务端Program.csSignalRUsers 客户端列表SignalRHub从`QueryString`取值的方法 服务端在其它业务类中调用`SignalRHub`中的方法，实现操控客户端 C#客户端Program.csClientSClient js客户端 服务端 Program.cs SignalRHub 是自定义的操作类，/chathub 是客户端访问的路由
builder.Services.AddSignalR(); builder.Services.AddSingleton&lt;SignalRUsers&gt;(); app.MapHub&lt;SignalRHub&gt;("/chathub"); SignalRUsers 客户端列表 public class SignalRUsers { // 保存客户端的列表 public ConcurrentDictionary&lt;string, string&gt; list { get; set; } public SignalRUsers() { list = new System.Collections.Concurrent.ConcurrentDictionary&lt;string, string&gt;(); } } SignalRHub public class SignalRHub : Hub { readonly SignalRUsers users; public SignalRHub(SignalRUsers _users) { users = _users; } /// &lt;summary&gt; /// 连接事件 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public override Task OnConnectedAsync() { // 获取客户端自定义id var userid = Context.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57d27a9de919eadc6420c3004e71999f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c20abeed36ecf5994109370e5a488d50/" rel="bookmark">
			stable diffusion深度解析｜sd1.5、sdxl、checkpoint、lora 含义与原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 大家好，我是Lison，接触AI绘画以来，发现很多时候对一些基础词汇理解地很模糊，然后在搭建comfyui工作流时，只能知其然，不知其所以然的感觉，也不知搭选哪个模型，很多时候都是照猫画虎地模仿，很难受。而且，很多时候，网上找不到详细地教程来详细解释这些含义。
好在我周围有很多算法同学，在跟他们交流中，对一些基础词汇有了比较深刻的了解，在这里做了个分享。
今天给大家分享的是 stable diffusion中的一些基础问题，主要分三块：
SDXL、SD1.5是什么意思
checkpoint、lora是什么意思
checkpoint和lora的区别
放轻松，我会通过设计师的视角帮大家更好地理解。
问题1：SDXL、SD1.5这些版本有什么区别，到底有多少版本？
为什么会出现这个问题，是因为每次在浏览网站时，左上角的xl，lora等搞得我莫名其妙，云里雾里。一会儿1.0，一会儿1.5，一会儿XL，不明所以。
经过我一番研究，发现是这么回事：sd是stable diffusion的缩写，后面的后缀其实是各个版本的称号；
Stable Diffusion (SD) 自发布以来经历了多个版本的迭代。以下是SD主要版本的概览：
Stable Diffusion v1.0 (2022年8月)首次公开发布
Stable Diffusion v1.1 - v1.4 (2022年8月-10月)陆续发布的小版本更新，主要改进模型性能和质量
Stable Diffusion v1.5 (2022年10月)在1.4基础上的进一步改进
Stable Diffusion v2.0 (2022年11月)重大更新，改进了文本理解和图像质量
Stable Diffusion v2.1 (2022年12月)对2.0的改进，增强了生成能力
Stable Diffusion XL 0.9 (2023年6月)SDXL的预览版本
Stable Diffusion XL 1.0 (2023年7月)目前最新的主要版本，大幅提升了模型能力
每个版本都比之前的版本生图质量更好，学习的图片数量也更多。接下来就给大家简单做个区分：
SD v1.1-1.5：训练的图片基本上都是 512*512 大小；
SD v2.0-2.1: 训练的图片大小是768*768；
SD XL：分别以600000步256*256 和200000步 512*512 大小的图片进行训练，适合生成1024*1024大小的图片，生成质量大大提高，非常受欢迎。
简单理解就是SD的每一个版本都比之前的版本 训练的步数更多，出图的质量更好。
那这么多版本，我应该下载哪个版本最合适呢？这里我推荐大家下载sd1.5和sdXL这两个版本，因为1.5版本生态最繁荣，sdXL 出图质量最好，画面表现高，但是占用显存略高，训练速度慢。
如果大家现在手里还没有这两个模型，可以去我微信公众号：体验设计，或者
底部评论来联系我获取。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c20abeed36ecf5994109370e5a488d50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/882af75ccf73a5b48947ec64a48c059a/" rel="bookmark">
			大数据-70 Kafka 高级特性 物理存储 日志存储 日志清理: 日志删除与日志压缩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点一下关注吧！！！非常感谢！！持续更新！！！ 目前已经更新到了：
Hadoop（已更完）HDFS（已更完）MapReduce（已更完）Hive（已更完）Flume（已更完）Sqoop（已更完）Zookeeper（已更完）HBase（已更完）Redis （已更完）Kafka（正在更新…） 章节内容 上节我们完成了如下内容：
日志索引文件查看物理存储、查看详细的索引文件消息偏移偏移量的存储 日志清理 Kafka提供两种日志清理策略：
日志删除：按照一定的删除策略，将不满足条件的数据进行数据删除日志压缩：针对每个消息的Key进行整合，对于有相同的Key的不同Value值，只保留最后一个版本。Kafka提供 log.cleanup.policy 参数进行相应设置，默认值：delete。还可以选择compact。主题级别的配置是：cleanup.policy 日志删除 基于时间 日志删除任务会根据 log.retention.hours / log.retention.minutes / log.retention.ms 设定日志保留的时间节点。如果超过该设定值，就需要进行删除。默认是7天，log.retention.ms 优先级最高。
Kafka依据日志分段中最大的时间戳进行定位。首先要查询日志分段所对应的时间戳文件，查找时间索引文件中最后一个索引项，若最后一条索引项的时间戳字段大于0，则取该值，否则取最近修改时间。
为什么不直接选最近修改时间？ 因为日志文件可以有意无意的被修改，并不能真实的反应日志分段的最大时间消息。
删除过程 从日志对象中所维护日志分段的跳跃表中移除待删除的日志分段，保证没有现成对这些日志分段进行读取操作。这些日志分段上所有文件添加上 .delete 后缀。交由一个 delete-file 命名的延迟任务来删除这些 .delete 为后缀的文件，延迟执行时间可以通过 file.delete.delay.ms 进行设置。 如果活跃日志分段中存在需要删除的数据？ Kafka会切分出一个新的日志分段作为活跃的日志分段，该日志分段不删除，删除原来的日志分段。先腾出地方，再删除。 基于日志大小 日志删除任务会检查当前日志的大小是否超过设定值，设定项为：log.retention.bytes。单个日志分段的大小由 log.segement.bytes 进行设定。
删除过程 计算需要被删除的日志总大小（当前日志大小（所有分段）减去retention值）从日志文件第一个LogSegment开始查找可删除的日志分段的文件集合执行删除 基于偏移量 根据日志分段的下一个日志分段的起始偏移量是否大于等于日志文件的起始偏移量，若是，则可以删除日志分段。
删除过程 从头开始遍历每个日志分段，日志分段1的下一个日志分段的起始偏移量为21，小于LogStartOffset，将日志分段1加入到删除队列中日志分段2的下一个日志分段的起始偏移量35，小于LogStartOffset，将日志分段2加入到删除队列中日志分段3的下一个日志分段的起始偏移量57，小于LogStartOffset，将日志分段3加入到删除队列中日志分段4的下一个日志分段的起始偏移量71，大于LogStartOffset，则不进行删除。 日志压缩 基础概念 日志压缩是Kafka的一种机制，可以提供较为细粒度的记录保留，而不是基于粗粒度的基于时间保留。
对于具有相同Key，而数据不同，只保留最后一条数据，前面的数据在适合情况下删除。
应用场景 日志压缩特性，就实时计算来说，可以在异常容灾方面有很好的用途。
比如，我们在Spark、Flink中做实时计算时，需要在内存中维护一些数据，这些数据可能是通过聚合了一天或者一周的日志得到的，这些数据一旦由于异常（内存、网络、硬盘）崩溃了，从头开始计算是需要很长时间的。
一个比较可行的方案就是定时将内存里的数据备份到外部存储介质中，当出现崩溃时，再从外部存介质中恢复并继续计算。
使用日志压缩来替代这些外部存储有哪些优势和好处？ Kafka即是数据源又是存储工具，可以简化技术栈，降低维护成本使用外部存储介质的话，需要将存储的Key记录下来，恢复的时候再使用这些Key将数据取回，实现起来有一定的工程难度和复杂度。使用Kafka的日志压缩特性，只需要把数据写入Kafka，等异常出现恢复任务再读回内存就可以了Kafka对于磁盘的读写做了大量的优化工作，比如磁盘顺序读写。相对于外部存储介质没有索引查询等工作量负担，可以实现高性能。同时，Kafka的日志压缩机制可以充分利用廉价的磁盘，不用依赖昂贵的内存来处理，在性能相似的情况下，实现非常高的性价比（仅针对异常处理和容灾的场景）。 日志压缩实现细节 主题的 cleanup.policy 需要设置为：compact
Kafka后台线程会定时将Topic遍历两次：
记录每个Key的Hash值最后一次出现的偏移量第二次检查每个Offset对应的Key是否在后面的日志中出现过，如果出现了就删除对应的日志。 日志压缩允许删除，除最后一个key外，删除先前出现的所有该Key对应的记录，在一段时间后从日志中清理以释放空间。
注意：日志压缩与Key有关，确保每个消息的Key不为Null。
压缩是在Kafka后台通过定时重新打开Segment来完成的，Segment压缩细节如下图所示：
日志压缩可以确保：
任何保持在日志头部以内的使用者都将看到所写的每条消息，这些消息将具有顺序偏移量。可以使用Topic的min.compation.lag.ms属性来保证消息在被压缩之前必须经过的最短时间，也就是说，它为每个消息（未压缩）头部停留的时间提供下一个下限。可以使用Topic的max.compactiton.lag.ms属性来保证从收到消息符合压缩条件之间的最大延时消息始终保证顺序，压缩永远不会重新排序消息，只是删除一些而已消息的偏移量永远不会改变，它是日志中位置的永久标识从日志开始的任何使用者将至少看到所有记录的最终状态，按记录的顺序写入。另外，如果使用者在比Topic的log.cleaner.delete.retention.ms短的时间内到达日志的头部，则会看到已删除的所有的delete标记， 保留时间默认是24小时。 默认情况下，启动日志清理器，若需要启动特定Topic的日志清理，请添加特定的属性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/882af75ccf73a5b48947ec64a48c059a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7547b03c492244782f01a588e0efd3f/" rel="bookmark">
			【链表OJ】常见面试题 2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.[链表分割](https://www.nowcoder.com/practice/0e27e0b064de4eacac178676ef9c9d70?tpId=8&amp;&amp;tqId=11004&amp;rp=2&amp;ru=/activity/oj&amp;qru=/ta/cracking-the-coding-interview/question-ranking)1.1 题目要求1.2 哨兵位法 2.[链表的回文结构](https://www.nowcoder.com/practice/d281619e4b3e4a60a2cc66ea32855bfa?tpId=49&amp;&amp;tqId=29370&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/2016test/question-ranking)2.1 题目要求2.2 快慢指针加反转链表 3.[相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/description/)3.1 题目要求3.2 双指针消除长度差3.3 哈希法 4.[环形链表](https://leetcode.cn/problems/linked-list-cycle/description/)4.1 题目要求4.2 快慢指针 1.链表分割 1.1 题目要求 现有一链表的头指针 ListNode* pHead，给一定值x，编写一段代码将所有小于x的结点排在其余结点之前，且不能改变原来的数据顺序，返回重新排列后的链表的头指针。
1.2 哨兵位法 创建两个哨兵位节点，一个用来存放val小于x的节点，一个存放val大于等于x的节点。
因为我们是顺序遍历，不会打乱原来的数据顺序，满足条件直接按要求放就可以了。最后再把存放val大于等于x的链表接到val小于x的链表后面就可以了。
但是最后会有一个坑！
当我们把两个链表连接后，可不能忘了head2（存放val大于等于x的节点）的最后一个节点可能不是指向NULL，就可能构成一个环，导致程序出错。
为什么会造成这种情况呢？
因为我们把节点链接到相应链表时没有除了节点的next，虽然后面会通过tail来处理next链接的问题，但是最后一个节点是做不到的。解决方法就是在最后处理一下，把tail2的next置为NULL就解决问题了。
class Partition { public: ListNode* partition(ListNode* pHead, int x) { // write code here ListNode* head1 = (ListNode*)malloc(sizeof(ListNode)); ListNode* head2 = (ListNode*)malloc(sizeof(ListNode)); ListNode* tail1 = head1; ListNode* tail2 = head2; ListNode* cur = pHead; while(cur) { if(cur-&gt;val&lt;x) { tail1-&gt;next = cur; tail1 = tail1-&gt;next; } else { tail2-&gt;next = cur; tail2 = tail2-&gt;next; } cur = cur-&gt;next; } tail1-&gt;next = head2-&gt;next; tail2-&gt;next = NULL; return head1-&gt;next; } }; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7547b03c492244782f01a588e0efd3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/196654d328d95c079883e95bab5ba454/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(070)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
281、pandas.Series.dt.daysinmonth属性
281-1、语法
281-2、参数
281-3、功能
281-4、返回值
281-5、说明
281-6、用法
281-6-1、数据准备
281-6-2、代码示例
281-6-3、结果输出
282、pandas.Series.dt.tz属性
282-1、语法
282-2、参数
282-3、功能
282-4、返回值
282-5、说明
282-6、用法
282-6-1、数据准备
282-6-2、代码示例
282-6-3、结果输出
283、pandas.Series.dt.freq属性
283-1、语法
283-2、参数
283-3、功能
283-4、返回值
283-5、说明
283-6、用法
283-6-1、数据准备
283-6-2、代码示例
283-6-3、结果输出
284、pandas.Series.dt.isocalendar属性
284-1、语法
284-2、参数
284-3、功能
284-4、返回值
284-5、说明
284-6、用法
284-6-1、数据准备
284-6-2、代码示例
284-6-3、结果输出
285、pandas.Series.dt.to_period方法
285-1、语法
285-2、参数
285-3、功能
285-4、返回值
285-5、说明
285-6、用法
285-6-1、数据准备
285-6-2、代码示例
285-6-3、结果输出
二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 281、pandas.Series.dt.daysinmonth属性 281-1、语法 # 281、pandas.Series.dt.daysinmonth属性 pandas.Series.dt.daysinmonth The number of days in the month.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/196654d328d95c079883e95bab5ba454/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a799d60ff6618696c6bd429b3ba5708e/" rel="bookmark">
			Redis 支持的数据类型、应用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis 支持的数据类型、应用详解 一、Redis基础数据类型1. String（字符串）2. Hash（哈希）3. List（列表）4. Set（集合）5. Zset（Sorted Set：有序集合） 二、进阶数据结构1. HyperLogLog2. Geo3. Pub/Sub（发布/订阅） 三、Redis Module 💖The Begin💖点点关注，收藏不迷路💖 本文将深入了解Redis的五种基础数据类型，并简要介绍一些进阶的数据结构和Redis Module。
一、Redis基础数据类型 1. String（字符串） String 是 Redis 最基本的数据类型，它不仅可以存储文本数据，还可以存储数字。Redis 的 String 类型是二进制安全的，意味着你可以用它来存储任何类型的数据，如图片、序列化对象等。
应用场景：缓存用户信息、计数器等。 2. Hash（哈希） Hash 类型允许你将多个字段-值对存储到同一个键下，非常适合存储对象信息。
应用场景：存储用户信息（如用户名、密码、邮箱等），避免使用多个键存储单个对象的属性。 3. List（列表） List 是一个简单的字符串列表，按照插入顺序排序。你可以从列表的两端添加或删除元素。
应用场景：消息队列、滑动窗口、最近访问列表等。 4. Set（集合） Set 是一个无序的字符串集合，自动去重。Redis 的 Set 类型提供了丰富的集合操作，如并集、交集、差集等。
应用场景：用户标签、好友关系、共同关注等。 5. Zset（Sorted Set：有序集合） Zset 是 Redis 中唯一一个既排序又可去重的类型。每个元素都会关联一个 double 类型的分数，Redis 通过这个分数来为集合中的成员进行从小到大的排序。
应用场景：排行榜、带权重的队列等。 二、进阶数据结构 1. HyperLogLog HyperLogLog 是一种用于基数估计的算法，在 Redis 中实现了非常节省内存的数据结构。它可以在有限的内存下，计算海量数据的近似基数（即不重复的元素数量）。
应用场景：UV统计、独立IP数统计等。 2. Geo Geo 是 Redis 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a799d60ff6618696c6bd429b3ba5708e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9db145eb8dda777e0cb6816753655a7b/" rel="bookmark">
			Python酷库之旅-第三方库Pandas(069)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、用法精讲
276、pandas.Series.dt.is_quarter_start属性
276-1、语法
276-2、参数
276-3、功能
276-4、返回值
276-5、说明
276-6、用法
276-6-1、数据准备
276-6-2、代码示例
276-6-3、结果输出
277、pandas.Series.dt.is_quarter_end属性
277-1、语法
277-2、参数
277-3、功能
277-4、返回值
277-5、说明
277-6、用法
277-6-1、数据准备
277-6-2、代码示例
277-6-3、结果输出
278、pandas.Series.dt.is_year_start属性
278-1、语法
278-2、参数
278-3、功能
278-4、返回值
278-5、说明
278-6、用法
278-6-1、数据准备
278-6-2、代码示例
278-6-3、结果输出
279、pandas.Series.dt.is_year_end属性
279-1、语法
279-2、参数
279-3、功能
279-4、返回值
279-5、说明
279-6、用法
279-6-1、数据准备
279-6-2、代码示例
279-6-3、结果输出
280、pandas.Series.dt.is_leap_year属性
280-1、语法
280-2、参数
280-3、功能
280-4、返回值
280-5、说明
280-6、用法
280-6-1、数据准备
280-6-2、代码示例
280-6-3、结果输出
二、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
一、用法精讲 276、pandas.Series.dt.is_quarter_start属性 276-1、语法 # 276、pandas.Series.dt.is_quarter_start属性 pandas.Series.dt.is_quarter_start Indicator for whether the date is the first day of a quarter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9db145eb8dda777e0cb6816753655a7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae8e1c6c1c90a57b037be1cf58665e82/" rel="bookmark">
			Flink-DataWorks第二部分：数据集成（第58天）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 数据集成
2.1 概述
2.1.1 离线（批量）同步简介
2.1.2 实时同步简介
2.1.3 全增量同步任务简介
2.2 支持的数据源及同步方案
2.3 创建和管理数据源 文章目录 系列文章目录前言2. 数据集成2.1 概述2.1.1 离线（批量）同步简介2.1.2 实时同步简介2.1.3 全增量同步任务简介 2.2 支持的数据源及同步方案2.3 创建和管理数据源 前言 本文主要详解了DataWorks的数据集成，为第二部分：
由于篇幅过长，分章节进行发布。
后续：
 数据集成的使用
 数据开发流程及操作
 运维中心的使用
2. 数据集成 2.1 概述 2.1.1 离线（批量）同步简介 数据集成主要用于离线（批量）数据同步。离线（批量）的数据通道通过定义数据来源和去向的数据源和数据集，提供一套抽象化的数据抽取插件（Reader）、数据写入插件（Writer），并基于此框架设计一套简化版的中间数据传输格式，从而实现任意结构化、半结构化数据源之间数据传输。
2.1.2 实时同步简介 数据集成的实时同步包括实时读取、转换和写入三种基础插件，各插件之间通过内部定义的中间数据格式进行交互。
一个实时同步任务支持多个转换插件进行数据清洗，并支持多个写入插件实现多路输出功能。同时针对某些场景，支持整库实时同步全增量同步任务，用户可以一次性实时同步多个表。
2.1.3 全增量同步任务简介 实际业务场景下，数据同步通常不能通过一个或多个简单离线同步或者实时同步任务完成，而是由多个离线同步、实时同步和数据处理等任务组合完成，这就会导致数据同步场景下的配置复杂度非常高。
为了解决上述问题，DataWorks提出了面向业务场景的同步任务配置化方案，支持不同数据源的一键同步功能，例如，“一键实时同步至Elasticsearch”、“一键实时同步至Hologres”和“一键实时同步至MaxCompute”功能等，通过此类功能，用户只需要进行简单的配置，就可以完成一个复杂业务场景。
全增量同步任务具有如下优势：
 全量数据初始化。
 增量数据实时写入。
 增量数据和全量数据定时自动合并写入新的全量表分区。
2.2 支持的数据源及同步方案 数据集成包括离线同步、实时同步和全增量同步任务三个功能模块，可以根据各模块对数据源的支持情况，选择对应的功能模块进行同步任务的配置。
支持的数据源及同步方案详见下表：
https://help.aliyun.com/zh/dataworks/user-guide/supported-data-source-types-and-read-and-write-operations?spm=a2c4g.11186623.0.0.6d9e7bca0fYAUx 2.3 创建和管理数据源 按照配置文档进行配置即可。下面以MySQL为例进行学习。
（1）数据同步前准备：MySQL环境准备
1）确认MySQL版本
登录数据库管理系统https://dms.aliyun.com/，打开SQL Console，运行以下命令：
select version(); 2）配置账号权限
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae8e1c6c1c90a57b037be1cf58665e82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e4d1e6bc7cceb9bce532018b92408d4/" rel="bookmark">
			SpringBoot基础(一)：快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot基础系列文章
SpringBoot基础(一)：快速入门
目录 一、SpringBoot简介二、快速入门三、SpringBoot核心组件1、parent1.1、spring-boot-starter-parent1.2、spring-boot-dependencies 2、starter2.1、spring-boot-starter-web2.2、spring-boot-starter2.3、parent和starter的区别 3、启动类4、内嵌Tomcat运行原理 一、SpringBoot简介 SpringBoot可以简单、快速地创建一个独立的、生产级别的Spring应用（说明：SpringBoot底层是Spring）大多数SpringBoot应用只需要编写少量配置即可快速整合Spring平台以及第三方技术 SpringBoot特性
快速创建独立Spring应用 以前的SSM框架，需要导包、写配置、启动运行 直接嵌入Tomcat、Jetty or Undertow，不再需要部署war包提供可选的场景启动器（starter），简化应用整合 为每一种场景准备一个依赖，如：spring-boot-starter-web、mybatis-plus-boot-starter以前需要导包，控制版本 按需自动配置Spring以及第三方库 约定大于配置：每个场景都有很多基本的默认配置 总结：简化整合、配置、开发、部署
二、快速入门 pom.xml
所有springboot项目pom文件都必须继承spring-boot-starter-parentweb场景启动器spring-boot-starter-web包含了web开发的所有依赖 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 所有springboot项目都必须继承自 spring-boot-starter-parent --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.11&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;artifactId&gt;springboot&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- web开发的场景启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- SpringBoot应用打包插件 mvn clean package把项目打成可执行的jar包 java -jar demo.jar启动项目 --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 核心启动类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e4d1e6bc7cceb9bce532018b92408d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4113d3923bf36f2b241d12ad7a3b4d4/" rel="bookmark">
			JavaEE: wait(等待) / notify (通知)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 wait(等待) / notify (通知)总结 wait(等待) / notify (通知) 线程在操作系统上的调度是随机的~
那么我们想要控制线程之间执行某个逻辑的先后顺序,那该咋办呢?
可以让后执行的逻辑,使用wait, 先执行的线程,在完成某些逻辑之后,通过notify来唤醒对应的wait.
另外,通过wait notify 也是为了解决"线程饥饿"问题.
举个例子:
有一个ATM机,滑稽1,进入ATM机,锁上房门后,结果发现ATM里面没钱了~
没钱了咋办,那就出来呗,于是这个老哥,就开锁出来了,但是这个老哥前脚刚迈出这个门半步,心里想:“我要不再进去看看”,于是这个老哥又把门锁上就又进去了,结果还是没钱,就出来了,走到门口,就又进去了.
就这样进进出出.他后面的滑稽也进不去~
把这些滑稽想象成一个个线程.第一个线程进进出出,后面的线程进不去,这就是"线程饥饿".
更准确的描述: 线程饥饿（Thread Starvation）是指在多线程程序中，某个线程无法获得所需的资源或执行所需的操作，导致其长时间等待或无法正常工作的情况。
针对上述问题,我们可以使用 wait / notify 来解决
让1号滑稽,拿到锁的时候进行判断
判断当前是否能执行"取钱"操作,如果能执行,就正常执行.
如果不能执行,那就主动释放锁,并且"阻塞等待"(通过调用wait),此时这个线程就不会在后续参与锁的竞争了.
一直阻塞到,"取钱"的条件具备了.
此时,再由其他线程通过机制(notify) 唤醒这个线程.
接着刚才的例子:
滑稽1,进入ATM之后,发现没钱,就要阻塞等待(wait)~
阻塞等待,一定是先释放锁,再等待,如果他抱着锁等待,别人就不能使用ATM机了.
wait 既然要释放锁,那么前提就是必须先加上锁.
public static void main(String[] args) throws InterruptedException { Object obj = new Object(); System.out.println("wait 之前"); // 使用 wait 必须先加上锁!! synchronized(obj) { obj.wait(); } System.out.println("wait 之后"); } 如果不先加锁,就会报异常:
加锁后:
由于代码中没有notify,所以wait将一直等待下去~
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4113d3923bf36f2b241d12ad7a3b4d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84780a6f0a99cb3dd26fd51d20a4e072/" rel="bookmark">
			跨域&amp;解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		b站视频链接
跨域&amp;解决方案 浏览器的同源策略 同源策略概述 浏览器为确保资源安全，而遵循的一种策略
什么是源 源的组成部分
源=协议+域名+端口号
下面表格中，只有最后一行的两个源是同源
同源请求与非同源请求
总结：【所处源】与【目标源】不一致，就是【非同源】，又称【异源】或【跨域】
跨域会受到哪些限制 备注：在上述限制中，浏览器限制a ja x获取数据的限制是影响最的的一个，且实际开发中经常遇到
限制DOM访问 &lt;body&gt; &lt;button onclick="showDOM()"&gt;showDOM&lt;/button&gt; &lt;!-- &lt;iframe id="framePage" src="./demo.html" frameborder="0"&gt;&lt;/iframe&gt; --&gt; &lt;iframe id="framePage" src="https://www.baidu.com"&gt;&lt;/iframe&gt; &lt;/body&gt; &lt;script type="text/javascript"&gt; function showDOM() { const framePage = document.getElementById('framePage') console.log(framePage.contentWindow.document) //同源的可以获取，非同源的无法获取 } &lt;/script&gt; 限制Cookie访问 &lt;body&gt; &lt;button onclick="showCookie()"&gt;showCookie&lt;/button&gt; &lt;iframe id="framePage" src="https://www.baidu.com"&gt;&lt;/iframe&gt; &lt;/body&gt; &lt;script type="text/javascript"&gt; function showCookie() { console.log(document.cookie) const framePage = document.getElementById('framePage') console.log(framePage.contentWindow.document.cookie) } &lt;/script&gt; 限制Ajax获取数据 &lt;body&gt; &lt;button onclick="getData()"&gt;getData&lt;/button&gt; &lt;/body&gt; &lt;script type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84780a6f0a99cb3dd26fd51d20a4e072/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c602a90abc53e2e010e3f129dc096f68/" rel="bookmark">
			基于springboot&#43;vue&#43;uniapp的“口腔助手”小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发语言：Java框架：springboot+uniappJDK版本：JDK1.8服务器：tomcat7数据库：mysql 5.7（一定要5.7版本）数据库工具：Navicat11开发软件：eclipse/myeclipse/ideaMaven包：Maven3.3.9 系统展示
管理员登录
管理员功能
用户管理
口腔历史管理
保健知识管理
系统管理
首页界面
保健知识详情
用户功能界面
医生功能界面
摘要
本文通过采用B/S架构，SpringBoot框架、MySQL数据库，结合国内“口腔助手”管理现状，开发了一个基于微信小程序的“口腔助手”小程序。系统分为：系统首页，个人中心，医生管理，用户管理，预约信息管理，口腔历史管理，用户反馈管理，在线问诊管理，保健知识管理，系统管理等功能模块。通过系统测试，本系统实现了系统设计目标，相对于人工管理方式，本系统有效的减少了“口腔助手”管理的经济投入，并且大幅度提升了“口腔助手”管理的效率。
研究背景
“口腔助手”小程序主要通过计算机网络，对“口腔助手”小程序所需的信息进行统一管理，方便用户随时随地进行增添、修改、查询、删除各类信息。本系统极大的促进了系统与数据库管理系统软件之间的配合，满足了绝大部分用户的需求，给用户带来了很大的便利。以现在计算机的技术的应用，使计算机成为人们使用现代发达技术的桥梁。计算机可以有效的解决信息，十分方便的获取信息，从而提高工作的效率。
关键技术
SpringBoot是一个全新开源的轻量级框架。基于Spring4.0设计，其不仅继承了Spring框架原来有的优秀特性，而且还通过简化配置文件来进一步简化了Spring应用的整个搭建以及开发过程。另外在原本的Spring中由于随着项目的扩大导入的jar包数量越来越大，随之出现了jar包版本之间的兼容性问题，而此时SpringBoot通过集成大量的框架使得依赖包的版本冲突，以及引用的不稳定性问题得到了很好的解决。
JS-SDK是对之前的 WeixinJSBrige 的一个包装，以及新能力的释放，并且由对内开放转为了对所有开发者开放，在很短的时间内获得了极大的关注。从数据监控来看，绝大部分在微信内传播的移动网页都使用到了相关的接口。
JS-SDK 解决了移动网页能力不足的问题，通过暴露微信的接口使得 微信小程序 开发者能够拥有更多的能力，然而在更多的能力之外，JS-SDK 的模式并没有解决使用移动网页遇到的体验不良的问题。用户在访问网页的时候，在浏览器开始显示之前都会有一个的白屏过程，在移动端，受限于设备性能和网络速度，白屏会更加明显。我们团队把很多技术精力放置在如何帮助平台上的微信小程序开发者解决这个问题。因此我们设计了一个 JS-SDK 的增强版本，其中有一个重要的功能，称之为“微信 微信小程序 资源离线存储”。
JAVA语言是目前软件市场上应用最广泛的语言开发程序。可以在多种平台上运用的，兼容性比较强，适应市面上大多数操作系统，不会出现乱码的现像，其扩展性和维护性都更好，具有分析问题和解决问题的能力，是面向过程的程序设计方便我们编写的代码更强壮。
Vue是一款流行的开源JavaScript框架，用于构建用户界面和单页面应用程序。Vue的核心库只关注视图层，易于上手并且可以与其他库或现有项目轻松整合。
MYSQL数据库运行速度快，安全性能也很高，而且对使用的平台没有任何的限制，所以被广泛应运到系统的开发中。MySQL是一个开源和多线程的关系管理数据库系统，MySQL是开放源代码的数据库，具有跨平台性。
B/S（浏览器/服务器）结构是目前主流的网络化的结构模式，它能够把系统核心功能集中在服务器上面，可以帮助系统开发人员简化操作，便于维护和使用。
系统分析
对系统的可行性分析以及对所有功能需求进行详细的分析，来查看该系统是否具有开发的可能。
系统设计
功能模块设计和数据库设计这两部分内容都有专门的表格和图片表示。
系统实现
管理员进入主页面，主要功能包括对系统首页，个人中心，医生管理，用户管理，预约信息管理，口腔历史管理，用户反馈管理，在线问诊管理，保健知识管理，系统管理等进行操作。进入用户页面输入用户名可以查询，新增或删除用户信息列表，并根据需要对用户详细信息进行详情，修改和删除等操作。进入口腔历史页面输入用户名可以查询或删除口腔历史列表，并根据需要对口腔历史详细信息进行详情，修改或删除操作。进入保健知识页面输入标题名称可以查询、新增或删除保健知识列表，并根据需要对保健知识详细信息进行详情，修改、查看评论或删除操作。进入医疗公告页面输入标题可以查询、新增或删除医疗公告列表，并根据需要对医疗公告详细信息进行详情、修改或删除操作，还可以对关于我们、系统简介和轮播图管理进行详细操作。
当人们打开微信小程序后，首先看到的就是首页界面。在这里，人们能够看到微信小程序的导航条，用户可以根据导航条进行查找想要的信息，并进行操作。在保健知识页面输入标题名称进行搜索，可以看到保健知识详细信息，按照提示即可完成评论或收藏操作。用户登录成功后，点击“我的”进入我的页面，在我的页面可以对预约信息，口腔历史，用户反馈，在线问诊等进行详细操作。医生登录成功后，点击“我的”进入我的页面，在我的页面可以对预约信息，口腔历史，用户反馈，在线问诊等进行详细操作。
系统测试
进行软件测试主要是为了验证产品或者系统是否完成了实现功能，测试能够防止系统出现错误，还能降低开发成本减少不必要的花销，其次测试的好处包括防止错误、降低开发成本和提高性能。其次，通过软件的检测可以对项目的安全性进行鉴别。向开发人员提供软件测试的反馈，并为项目的安全性评价提供必要的资料。此外，软件的检测保证在正式发布之前能够满足在线要求。在每一个开发过程中不断跟踪和对软件的测试。还有，软件测试还能保证系统到达预期的标准，从而能够尽快上线。
在本系统中，主要测试前端和后端，分别对系统的不同模块进行测试，比如用户主持、用户登录等功能是否实现，实现过程中是否出现问题等。是否能够处理不同的数据。前端主要测试：用户界面的实现和不同界面的交互情况，后端主要测试系统经过管理后前后端链接是否顺畅，前端界面是否及时更新，更新是有误。
结论
“口腔助手”小程序是一款公平、包容、易操作的系统，基本上能满足使用者的需求，也符合本人的初始发展目的与发展方向。本文主要研究了Java语言和MySQL等技术时的应用，它们都具有自己的优势，使其在实际应用中可以实现功能的稳定，同时也可以实现用户的各种需要。在具体的系统要求和功能模块的具体分析之后，进行了有针对性的设计，最终经过了测试，使整个系统可以正常工作，该“口腔助手”小程序设计完成。
（可运行源码+sql文件+文档）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/717f95121aeefe52861c1bab36926a94/" rel="bookmark">
			java之多线程篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本概念 1.什么是线程？
线程就是，操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。简单理解就是：应用软件中互相独立，可以同时运行的功能
2.什么是多线程？
有了多线程，我们就可以让程序同时做多件事情
3.多线程的作用？
提高效率
4.线程的应用场景？
只要你想让多个事情同时运行就需要用到多线程
比如：软件中的耗时操作、所有的聊天软件、所有的服务器
二、并发和并行的概念 1.什么是并发？
并发就是，同一时刻，有多个指令在单个CPU上交替执行。
2.什么是并行？
并行就是，同一时刻，有多个指令在多个CPU上同时执行
3.电脑不是只有一个CPU么，这个多个CPU同时执行的并行究竟是什么？
其实，CPU在市面有很多类型如下
比如2核4线程的CPU，就可以同时运行4个线程的任务。
三、多线程的实现方式（3种） 1.继承Thread类的方式进行实现 用法：
1.定义一个类继承Thread类
2.这个类重写run方法
3.在main方法里面创建定义的类的对象
4.通过该对象的.start()方法启动线程
示例代码
public class ThreadDemo1 { public static void main(String[] args) { MyThread myThread1 = new MyThread(); MyThread myThread2 = new MyThread(); myThread1.setName("线程1"); myThread2.setName("线程2"); myThread1.start(); myThread2.start(); } } class MyThread extends Thread{ @Override public void run(){ for(int i=0;i&lt;100;i++){ System.out.println(Thread.currentThread().getName()+" "+i); } } } 上面的两个线程的代码run方法是同时执行的，并不会等一个线程的循环走完。
注意：线程类开启后执行的是run方法的代码 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/717f95121aeefe52861c1bab36926a94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05cf75046705494ae47fc110cfcfde2e/" rel="bookmark">
			Java中的Set（如果想知道Java中有关Set的知识点，那么只看这一篇就足够了！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：在Java编程中，集合框架（Collections Framework）是处理数据结构和算法的基础工具之一。它提供了一套强大且灵活的接口和类，用于存储和操作不同类型的数据集合。在这其中，Set接口扮演着一个重要角色。与其他集合类型如List和Map不同，Set强调的是集合中元素的唯一性。这使得它在需要去重、快速查找等场景下显得尤为重要。
✨✨✨这里是秋刀鱼不做梦的BLOG
✨✨✨想要了解更多内容可以访问我的主页秋刀鱼不做梦-CSDN博客
先让我们看一下本文大致的讲解内容：
目录
1.Set概念的简介
（1）Set的定义
（2）Set类在Java集合类中的关系
2.Set接口中常用的API
（1）boolean add(E e)
（2）void clear()
（3）boolean contains(Object o)
（4）Iterator iterator()
（5）boolean remove(Object o)
（6）int size()
（7）boolean isEmpty()
（8）Object[] toArray()
（9）boolean containsAll(Collection c)
（10）boolean addAll(Collection c)
3.Set的常见实现类
（1）HashSet
（2）LinkedHashSet
（3）TreeSet
4.Set的实际案例
（1）去除重复元素
（2）查找集合的交集、并集和差集
（3）判断两个集合是否相等
5.总结
1.Set概念的简介 （1）Set的定义 在Java中，Set接口是Java集合框架的一部分，用于表示一组唯一的元素。与List不同，Set不允许包含重复的元素。这意味着即使尝试将相同的元素添加多次，Set中也只会保留一个实例。Set接口继承自Collection接口，因此它也拥有一些集合框架中通用的方法。
Set的主要特点：
无序性：Set中的元素没有特定的顺序，这意味着你不能通过索引来访问Set中的元素。唯一性：Set中的每个元素都是唯一的，即不能包含重复的元素。允许null值：大多数Set实现都允许包含一个null值，但不能有多个null值。 我相信读者如果初次学习Java中的Set类的话，可能对上面对Java中Set类的解释不能够很好的理解，不过没有关系，读者继续向下阅读即可。
（2）Set类在Java集合类中的关系 了解了Set类的基本定义之后，现在再让我们看看Set类在Java的集合框架中的的关系，如下图：
从上图我们可以得知，Java中的Set类也实现了Collection接口，那么Set类也就实现了Collection接口中的方法，即可以使用其中的方法。
——至此，通过上边的学习了解之后，这样我们就大致的了解了Java中的Set究竟是什么东西了。
2.Set接口中常用的API 在Java中，Set是继承自Collection的接口类，但是相较于Java中的Map类，Set中只存储了Key，所以对于Set而言，其方法大都是操作其中的Key的，以下是Set接口的主要方法：
方法解释boolean add(E e)添加元素，但重复元素不会被添加成功void clear()清空集合boolean contains(Object o)判断 o 是否在集合中Iterator&lt;E&gt; iterator()返回迭代器boolean remove(Object o)删除集合中的 oint size()返回set中元素的个数boolean isEmpty()检测set是否为空，空返回true，否则返回falseObject[] toArray()将set中的元素转换为数组返回boolean containsAll(Collection&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05cf75046705494ae47fc110cfcfde2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b422c1bf33a2f75522b0469928068f58/" rel="bookmark">
			常见中间件漏洞（四、Apache合集）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
四、Apache
4.1 CVE-2021-41773
漏洞简介
影响版本
环境搭建
漏洞复现
四、Apache 4.1 CVE-2021-41773 Apache HTTP Server 路径穿越漏洞
漏洞简介 该漏洞是由于Apache HTTP Server 2.4.49版本存在目录穿越漏洞,在路径穿越目录&lt;Directory/&gt;Require all granted&lt;/Directory&gt;允许被访问的的情况下(默认开启)，攻击者可利用该路径穿越漏洞读取到Web目录之外的其他文件，在服务端开启了gi或cgid这两个mod的情况下，这个路径穿越漏洞将可以执行任意cgi命令(RCE)。
影响版本 Apache HTTP Server 2.4.49
某些Apache HTTPd 2.4.50也存在此漏洞
环境搭建 docker pull blueteamsteve/cve-2021-41773:no-cgid 漏洞复现 1.使用poc
curl http://IP:PORT/cgi-bin/.%2e/.%2e/.%2e/.%2e/etc/passwd 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6fd7ab9cb5ac9a0f3b06798c81d32eb/" rel="bookmark">
			基于XxlCrawler的Java执行JS渲染方式实战-以获取商飞C919飞行照片为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、抓取目标解析
1、原始网站介绍
2、列表页面结构解析 二、XxlCrawler的常规配置
1、PageVo对象的定义
2、定义XxlCrawler并启动
三、使用HtmlUnit来执行动态渲染
1、在pom.xml中加入htmlunit的引用
2、设置PageLoader加载器
3、执行抓取
四、总结
前言 关于XxlCrawler的相关实例，无论是技术博客圈还是本文的历史博客，均有过多篇实践系列的讲解。但是在之前的博客当中，我们有的是直接采集后台返回的json的接口，或者是采集已经渲染好的html网页数据。这些采集的方式和方法是比较简单的。通过在XxlCrawler的官方示例和教程，我们都可以开发出满足业务需要的应用程序。
不管您是一个后端开发人员，或者是一个前端开发人员。对于Javascript动态渲染一定有所耳闻，界面在加载时，并不是直接就对数据进行了渲染，而是部分渲染。比如加载页面中的静态部分，如网页的主体的架构，要展示的信息要素的布局等等。而真正的数据并不是直接渲染的，而是通过ajax的方式或者其他axios等方式来进行请求接口。不论哪种请求，原理都是执行了某些接口，而这些接口还不一定是直接请求了后台的接口。而且这些数据的展示，必须要等上述的Javascript执行完成之后才能加载到页面中。因此就有了Java动态渲染的说法。与常规的接口抓取和静态页面抓取的方式不同，Javascript的动态渲染页面的抓取就稍微有点麻烦。
本文即在这样的场景中诞生。本文以获取商飞C919的飞机照片为例，重点讲解Javascript动态渲染的案例场景，怎么抓取这种Javascript动态渲染的网页，最后给出实际的程序代码。让你掌握如何正确的抓取这种Javascript的动态渲染页面，拿到我们需要的数据。本文修正了官网提供的例子无法运行的问题，告诉你正确的开发方式。如果正在阅读博客的你，当前也有这种需求，不妨来看看本文，或许有一定帮助。
一、抓取目标解析 在进行如何进行信息抓取之前，首先我们对要抓取的目标界面进行深度解析。看看通过Javascript动态渲染的界面跟静态界面有什么不同，如果通过常规的动态渲染的模式，能否正常的抓取数据。这都是本小节需要讲清楚的。
1、原始网站介绍 对于很多的飞行爱好者来说，飞行器也是一种非常值得观赏的事务。很多的飞行器设计得非常漂亮。在起飞或者降落的时候，是一种别样的美。本人曾将供职于某航空公司，记得当时的一大爱好就是站在办公楼旁边，看着停机坪外的飞机来来往往。曾经也保障过飞机的起飞和降落。对冲上云霄的美有一种特殊的感情。闲言少叙，这里以航班追踪网站为例，可以在它的官方网站上看到很多飞机的图片。这些都是图片都是一些爱好者或者喜欢飞行的朋友们在全世界各地搜集的飞机的飞行照片，很多飞机甚至是大家平时看不到的机型。
可以在浏览器中输入以下的连接：
https://www.flightaware.com/photos/aircrafttype/C919/sort/votes/page/1 如下图所示：
在上图的飞机飞行照片中，就是我们当前选择的目标飞机C919的一些照片。 是不是很酷，点击具体的照片还能看到这些飞机的朋友圈信息，比如全尺寸照片、飞行机型、飞机拍照时的位置信息等等，点赞的数量，浏览的数量等等信息。如下图所示：
2、列表页面结构解析 在前面的网页连接中，我们打开飞机的列表界面，按照常规的思路。我们首先来分析一下列表的网页结构，如果采用常规的网页，我们应该怎么做呢？在谷歌浏览器中打开列表界面后，我们可以看到以下的网页结构，通过页面元素检查，可以找到其页面展示结构信息。
其大致的网页结构源码如下,飞机的照片都是存放到一个id为gridderContainerFancy的一个div下面的，因此我们只要抓取这个div下面的页面元素即可：
&lt;div id="gridderContainerFancy" style="max-width: none;"&gt; &lt;div style="width: 1214px; overflow: hidden; white-space: nowrap;"&gt; xxx &lt;/div&gt; &lt;/div&gt; 在掌握了以上的相关信息之后，下面我们按照常规的方式，按照我们之前的经验，按照XxlCrawler的相关配置进行相关程序的配置开发。
二、XxlCrawler的常规配置 这里我们按照XxlCrawler的常规配置模式来介绍如何进行抓取程序的配置。就算后面要执行Javascript的动态渲染，也还是要进行相应的配置的。因此首先来讲讲基础的配置。
1、PageVo对象的定义 在XxlCrawler抓取信息是，pageVo是一个非常重要的对象。要使用它来进行页面的信息抓取，在下面的网页结构中，我们大概了解了如何抓取页面的请求地址。
直接抓取它的img标签的src信息，其实就是的访问地址。这个思路是没有问题的。 因此按照这个思路，我们来定义抓取页面的pageVo对象，关键代码如下：
@PageSelect(cssQuery = "#gridderContainerFancy") @Data public static class PageVo { @PageFieldSelect(cssQuery = "img", selectType = SelectType.ATTR, selectVal = "abs:src") private List&lt;String&gt; images; public List&lt;String&gt; getImages() { return images; } public void setImages(List&lt;String&gt; images) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6fd7ab9cb5ac9a0f3b06798c81d32eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f540835f7cdeccade9484447e25a321e/" rel="bookmark">
			【算法】贪心算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用场景——集合覆盖问题 假设存在下面需要付费的广播台，以及广播台信号可以覆盖的地区。如何选择最少的广播台，让所有的地区都可以接收到信号
贪心算法介绍 1.贪心算法是指在对问题进行求解时，在每一步选择中都采取最好或者最优的选择
2.贪心算法得到的结果不一定是最优的结果，但是都是相对近似最优解的结果
思路分析 使用贪心算法的效率非常高，选择策略上，由于需要覆盖全部小区的所有集合：
1.遍历所有的广播电台，找到一个覆盖了最多未覆盖地区的电台（此电台可能包含一些已覆盖的地区，但没有关系）
2.将这个电台加入到一个集合中（比如 ArrayList），想办法把该电台覆盖的地区在下次比较时去掉
3.重复第 1 步直到覆盖了全部的地区
用代码实现集合覆盖问题 public class GreedyAlgorithm { public static void main(String[] args) { //创建广播电台，放入到 Map HashMap&lt;String, HashSet&lt;String&gt;&gt; broadcasts = new HashMap&lt;&gt;(); //将各个电台放入到 broadcasts HashSet&lt;String&gt; hashSet1 = new HashSet&lt;&gt;(); hashSet1.add("北京"); hashSet1.add("上海"); hashSet1.add("天津"); HashSet&lt;String&gt; hashSet2 = new HashSet&lt;&gt;(); hashSet2.add("广州"); hashSet2.add("北京"); hashSet2.add("深圳"); HashSet&lt;String&gt; hashSet3 = new HashSet&lt;&gt;(); hashSet3.add("成都"); hashSet3.add("上海"); hashSet3.add("杭州"); HashSet&lt;String&gt; hashSet4 = new HashSet&lt;&gt;(); hashSet4.add("上海"); hashSet4.add("天津"); HashSet&lt;String&gt; hashSet5 = new HashSet&lt;&gt;(); hashSet5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f540835f7cdeccade9484447e25a321e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4baf717f3ad3a0f932f643bd7fae45e2/" rel="bookmark">
			著名人工智能新经济数字经济新能源新质生产力讲师培训师教授专家唐兴通分享人工智能社会学商业模式创新人工智能就业工作与教育学习出海跨境数字化转型数字营销数字销售
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加图片注释，不超过 140 字（可选）
2024 年是人工智能在工作中真正应用的一年。根据微软和领英进行的调查（2024年5月），在过去六个月中，生成式人工智能的使用量几乎翻了一番，全球75%的知识工作者都在使用它。
我们就一起看看海外生存式AI在企业应用实际情况，感受扑面而来的"AI风"
1.员工希望在工作中使用人工智能——而且他们不会等待公司赶上来。
目前，人工智能正以意想不到的规模融入工作场所。目前， 75%的知识型员工在工作中使用人工智能，46%的用户在不到六个月前开始使用人工智能。人工智能正在产生回报：
用户表示，人工智能帮助他们节省时间（90%）、专注于最重要的工作（85%）、更有创造力（84%）、更享受工作（83%）。
“我们处于整合人工智能的前沿，不仅可以提高工作速度，还可以提高工作效率。作为组织领导者，我们有责任确保这项技术能够提升我们团队的创造力并符合我们的道德价值观。”
— Karim R. Lakhani，哈佛大学数字数据设计学院院长、哈佛商学院 Dorothy &amp; Michael Hintze 工商管理教授
虽然大多数领导者都认为人工智能是必需的，但立即展示投资回报的压力使得领导者行动缓慢。
79%的领导者同意他们的公司需要采用人工智能来保持竞争力，但59% 的人担心量化人工智能带来的生产力提升。
添加图片注释，不超过 140 字（可选）
在没有高层指导或批准的情况下，员工们自行处理事情并对人工智能的使用秘而不宣：
78%的 AI 用户将自己的 AI 工具带到工作中——这在中小型公司中更为常见 ( 80% )。
52%在工作中使用人工智能的人不愿承认将其用于最重要的任务。
53%在工作中使用人工智能的人担心将其用于重要的工作任务会让他们看起来可以被取代。
2.对于员工来说，人工智能提高了职业标准，也打破了职业天花板。
虽然人工智能和失业是许多人最关心的问题，但数据提供了更微妙的观点——隐藏的人才短缺、渴望职业转变的员工以及愿意提高人工智能技能的人的巨大机会。
领导者正在招聘：大多数 ( 55% ) 的领导者表示，他们担心未来一年没有足够的人才来填补职位空缺。这些领导者来自不同部门，但对于网络安全、工程和创意设计领域来说，这一数字跃升至60%或更高。
专业人士正在寻找：虽然一些专业人士担心人工智能会取代他们的工作（45%），但大约同样比例（46%）的人表示他们正在考虑在未来一年辞职。
添加图片注释，不超过 140 字（可选）
企业已经开始抢占技术型 AI 人才，过去八年招聘人数增长了323% 。现在，他们将目光转向具有 AI 能力的非技术人才——使用 ChatGPT 和 Copilot 等生成式 AI 工具的技能：
66%的领导者表示，他们不会雇用不具备 AI 技能的人。
71% 的受访者表示，他们宁愿聘用具有 AI 技能但经验较少的候选人，也不愿聘用不具备 AI 技能但经验较丰富的候选人。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4baf717f3ad3a0f932f643bd7fae45e2/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/72/">«</a>
	<span class="pagination__item pagination__item--current">73/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/74/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>