<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/247c4a3b03923631e990b38253329b5d/" rel="bookmark">
			初识java——javaSE（7）String类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一 String类1. String类简介：String对象的字符串不能被修改 2.字符串的三种构造方法：字符串在内存中的存储： 3. 字符串的比较：关系运算符 ==：equals方法：compareTo方法：compareToIgnoreCase方法： 4.字符串的查找正序查找：逆序查找： 5 字符串的转化：5.1 valueof方法： 数字转化成字符串5.2 valueof方法，对象转化成字符串5.3 字符串大小写相互转换:5.4 字符串与数组之间相互转换：5.5 格式化format方法——是将数据以格式化的形式变为字符串 6 字符串的替换：7. 字符串的拆分 — split方法 ：8. 字符串的截取：另外一个方法：总结（重要）： 二 StringBuffer类2.1 StringBuffer类的声明：2.2 字符串的插入—insert方法2.3 StringBuffer类型转变成String类型： 三 StringBuilder类StringBuilder类与StringBuffer类的区别： 前言 一 String类 1. String类简介： 在c语言中字符串用字符数组来存储，并没有专门的字符串类型。
在java中，专门针对字符串创建了一个String类.
String对象的字符串不能被修改 String对象中存储的字符串是不能被修改的，是因为存储字符串的数组被private修饰！
只能在本类中被访问修改！而不能在其他类中被访问修改。
这是jdk17的数组，在jdk1.8中数组类型为：char[]
对于String对象中字符串不能被修改的原因，有些网上评论误解为是final关键字修饰导致的。
对于修饰String类的final关键字：
此final关键字的作用是设置String类不能够被继承！
对于修饰存储字符串数组的final关键字：
此final关键字的作用是让value引用的值不能够改变，即不能引用别的对象。但是所引用的对象中的内容是可以被改变的！ 所以这并不是String对象中的字符串不能被修改的原因！
举例：
2.字符串的三种构造方法： //常量字符串 String string1 = "hello world"; //通过实例化String对象 String string2 = new String("hello world"); //通过字符数组 char[] arr1 = {'a','b','c','d','e','f'}; String string3 = new String(arr1); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/247c4a3b03923631e990b38253329b5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e539254ee1c994f67d4ae1b1ebb6126/" rel="bookmark">
			基础—SQL—DQL（数据查询语言）排序查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 排序查询这里面涉及的关键字：ORDER BY。在我们日常的开发中，这个是很常见的，比如打开一个网购的商城，这里面可以找到一个销量的排序、综合的排序、价格的排序（升序、降序）等等。接下来就学习这一部分的SQL语句怎么去写
二、DQL—排序查询 1、语法 SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1,字段2 排序方式2;
注意：
SQL语句当中，支持多字段排序。首先排序的时候要指定字段名，第二个要指定排序方式。
排序方式：
1、ASC：升序（默认值）
2、DESC：降序
注意：
如果是多字段排序，先按照第一个字段排序，当第一个字段值相同时。才会根据第二个字段进行排序。
三、案例操作 接下来回到 DataGrip 工具进行数据的排序查询学习和操作。完成下面三个需求
0、emp 表的数据 1、根据年龄对公司的员工进行升序排序 SELECT * FROM emp ORDER BY age ASC; 也可以省略 ASC ，因为默认的排序方式是升序排序
SELECT * FROM emp ORDER BY age; 2、根据年龄对公司的员工进行降序排序 SELECT * FROM emp ORDER BY age DESC; 3、根据入职时间，对员工进行降序排序 SELECT * FROM emp ORDER BY entrydate DESC ; 4、 根据年龄对公司的员工进行升序排序，年龄相同，再按照入职时间进行降序排序 SELECT * FROM emp ORDER BY age ASC,entrydate DESC; 以上这篇博客就是这里面讲到的关于排序查询的操作和学习。，主要要注意多字段的排序情况。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4094c5d0f76e8fd39905251e210127f6/" rel="bookmark">
			植物大战僵尸杂交版全平台 PC MAC 安卓手机下载安装详细图文教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近植物大战僵尸杂交版非常的火，好多小伙伴都想玩一玩，但作者只分享了 win 版，像手机还有MAC电脑都没有办法安装，身为 MAC 党当然不能放弃，经过一番折腾，也是成功在所有平台包括手机和MAC电脑都成功安装上了游戏，嘿嘿！
这里跟大家分享一下如何安装，特别是 MAC 的，我这里 MAC 的解决方案就是将 win 的游戏程序包装转译然后在在 MAC 上运行，非常完成，能够正常游玩，感兴趣的朋友可以通过下方教程链接下载安装
植物大战僵尸杂交版下载安装详细教程：https://www.hereitis.cn/articleDetails/2553
PC、安卓安装都非常简单，直接安装运行就行，下载的包里也有说明（还有高清包还有各种插件的使用教程）
MAC 党也不用当心，已经将程序有包了一层安装程序，如上图直接打开 DMG 安装包拖拽一下就可以了，非常简单，如果打不开在运行一下软件修复引导就可以了
安装完直接运行就可以了，下方付两张游戏内截图：
感兴趣的朋友快来试试吧，真的蛮好玩的，停不下来哈哈
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03921ce26ac9121541e1e41153eb9985/" rel="bookmark">
			字符串转换为字节数组、16进制转换为base64、base64转换为字符串数组、base64转换为16进制（微信小程序）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、字符串转换为字节数组 // 字符串转为字节数组 function stringToByteArray(str) { var array = new Uint8Array(str.length); for (var i = 0; i &lt; str.length; i++) { array[i] = str.charCodeAt(i); } return array; } 2、16进制转换为base64 // 16进制转换为base64 function HexToBase64(sha1) { var digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" var base64_rep = "" var ascv var bit_arr = 0 var bit_num = 0 for (var n = 0; n &lt; sha1.length; ++n) { if (sha1[n] &gt;= 'A' &amp;&amp; sha1[n] &lt;= 'Z') { ascv = sha1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03921ce26ac9121541e1e41153eb9985/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcca9df4df57def2e684bc2e7b37c45d/" rel="bookmark">
			化学反应数据库合集！Reaxys、CAS SciFindern领衔
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		化学反应数据库对于实验人员设计合成路线具有很高的价值，尤其在有机化学领域中显得尤为重要。
化学反应数据库作为化学研究和工业应用中不可或缺的资源，不仅极大地提升了实验人员设计合成路线的效率，促进了化学知识的积累与传承，还激发了创新思维，推动了化学科学的进步，同时为教育工作者和学生提供了丰富的学习材料，帮助企业优化生产流程，开发新产品，并通过安全性评估减少了实验风险，促进了跨学科的研究与合作，支持了数据驱动的科学决策，加强了国际间的学术交流，鼓励了全球范围内的知识共享与合作，对化学及相关领域的研究和发展产生了深远的影响。
本文推荐以下几个反应数据库
1、Reaxys数据库 【网址】：https://www.reaxys.com
Reaxys数据库是目前最大的化学数据库，其收录的数据范围涵盖有机合成、药物化学、天然产物化学、无机化学和金属有机化学，并将化学反应，化合物物性数据，合成线路设计进行无缝对接，使科技检索工作更加高效、精准，并以其强大的检索功能和深入的核心信息摘录为化学研究注入新的生机。
Reaxys 将十多亿个化学数据点与人工智能相结合，为药物发现、化学研发和学术界的创新提供支持。化学家可以快速获取相关的专利、物质和生物活性见解以及屡获殊荣的逆合成工具。Reaxys在Beilstein基础上整合了盖墨林(Gmelin)和专利化学数据库(PCD)以及化学相关期刊的内容，能帮助科研人员快速全面地查询化合物的理化数据，设计经济、高效的合成路线，最大程度节省时间和资金成本。
其收录的数据范围涵盖有机合成、药物化学、天然产物化学、无机化学和金属有机化学，并将化学反应，化合物物性数据，合成线路设计进行无缝对接，使科技检索工作更加高效、精准，并以其强大的检索功能和深入的核心信息摘录为化学研究注入新的生机。在进行结构式检索时，Reaxys 提供了多种检索模式和工具，以帮助用户精确地找到所需的化合物和反应信息。
2、CAS SciFindern数据库 【网址】：https://scifinder-n.cas.org
CAS SciFindern由美国化学会（American Chemical Society, ACS）旗下的美国化学文摘社（Chemical Abstracts Service, CAS）出品，是一个研发应用平台，提供全球最大、最权威的化学及相关学科文献、物质和反应信息。综合了全球200多个国家和地区的60多种语言的1万多份期刊，内容丰富全面，用户可以通过主题、分子式、结构式和反应式等多种方式进行检索。
该平台汇集了180多个国家、50多种语言出版的文献及64家专利授权机构的专利，包含5900万化学及相关学科文献、2.04亿化学物质、1.5亿化学反应、139万来自专利的马库什结构、化学品商业信息及管控信息，最早回溯至1840年。
CAS SciFindern的一大特色是可以提供专利马库什结构的机构。平台从全球64家专利机构的公开专利中提取了超过139万个可检索的马库什结构，一个马库什结构可能涵盖数千甚至数万个化合物，这大大增强了研发和知识产权专业人士在进行化合物结构的新颖性和创造性搜索、发现相似专利以及评估潜在侵权风险的能力。并且其中的CAS PatentPak模块在定位和分析大量专利中的化学结构方面，采用人工标引，检索人员可以快速识别专利中难以发现的物质（例如，表格化合物和图形图像内的化合物）。
平台的另一特色是其含有7.2亿生物序列，可进行FTO检索、侵权检索，可以更好的服务与研发人员及知识产权相关行业人士。CAS SciFindern数据库中还包括一个反应信息数据库CASReact，收集了各种反应与制备信息。
3、ORD 【网址】：https://github.com/open-reaction-database
0RD(Open Research Dataset)是由亚马逊推出的一个免费开放的科学研究数据集。一种用于构建和共享有机反应数据的开放访问架构和基础设施（包括一个集中的数据存储库）。它包含超过2000万个科学论文摘要和全文的数据，覆盖了计算机科学、物理学、数学、生物学、医学、化学等多个学科领域。
ORD的目标是提供给研究人员一个大规模的数据集，以便他们进行深入的研究和分析。
ORD 搜索界面用于在数据库中搜索反应。可以通过输入或输出分子的 SMILES/SMARTS 子结构、反应 ID、出版物 DOI 等查询反应。每个反应都有一个摘要页面，其中显示了完整记录以及图形示意图。我们还编写了一个简单的Python API，使下游用户能够以编程方式轻松访问数据。客户端库支持基于Web的搜索界面中的所有搜索功能，以及下载完整数据集或反应列表的功能。
解析ORD数据集时，你可以按照不同的科学领域进行分类，选择你感兴趣的领域进行研究。你可以使用关键词功能，快速找到和你研究主题相关的论文。在使用ORD进行科学研究时，你可以使用机器学习和自然语言处理的技术对数据进行分析。除此之外，你还可以使用其他的数据分析方法进行研究。
4、MolAid 【网址】：MolAid-化合物智能检索一体化平台 | MolAid化学数据库
MolAid作为国内领先的多终端化合物检索及智能一体化数字合成平台，收录全球数以亿计的化合物数据，提供精准数据信息。MolAid打破化学数据垄断，让用户摆脱数据库不稳定、高查询成本等烦恼，为中国科研工作者提供专业的物质查询、反应检索，助力中国化学合成发展。
MolAid为用户提供多种查询化合物信息方式，包括通过名称、CAS、化学式或者SMILES等常用编码进行搜索，还支持绘制结构以及高级检索方法（比如：谱图反向查询化合物、晶体信息反向查询以及根据化合物物化性质等特征信息进行逻辑符连接）。
MolAid多样的化合物检索方式，确保用户每次一检索都能获取有价值的信息。为我们提供化合物作为反应物、产物、试剂、溶剂及催化剂的所有已发表文献和专利中的反应信息，使我们能够清楚快捷的查询到需要的反应信息及期刊信息。
考虑到每个实验室条件，设备及贮存的化合物不同，MolAid他们将反应物、产物、溶剂、试剂、催化剂、产率、年份、来源等数据均做了聚类处理，方便我们更快捷的找到反应中适用的化合物。
5、chemspider 【网址】：ChemSpider | Search and share chemistry
ChemSpider是由英国皇家化学会(RSC)提供的一个免费化学物质数据库，收录1亿多种化学品的信息，包括其结构、物理化学性质、生物学性质、2D和3D结构示意图、物质合成的路线、参考文献等多种信息，可下载mol格式的结构源文件等。 ChemSpider通过聚合多个来源的数据，提供了一个广泛的化学物质检索平台，对科研人员和教育工作者比较有用。现在，该数据库含有的信息包括海洋天然产物数据、ACD实验室化学数据库、EPA的DSSTox数据库以及来自不同供应商的一系列化学物质信息。数据库拥有多种搜索工具，而且大多数化合物都有计算物理化学性质值的。
ChemSpider中收录了数百万种有机、无机和生物分子的结构、属性和相关信息。用户可以通过搜索、浏览和互动来获取有关化合物的详细信息，包括分子结构、物理化学性质、光谱数据、毒性信息等。这个平台可以帮助研究人员在化学研究、药物开发、环境科学等领域找到所需的数据和信息。
数据库提供以下查询方式：标准查询方式包括系统名称、商业名称和同义词、登记号查询；高级查询方式提供互动式搜索，通过化合物结构、化合物子结构，分子式以及分子量、CAS编号搜索。
其他 查询合成路线/人名反应 还有以下网站：
https://www.nextmovesoftware.com/about.htmlhttp://www.stolaf.edu/depts/chemistry/courses/toolkits/247/practice/medialib/data/http://pubchem.ncbi.nlm.nih.gov/http://www.organic-chemistry.org/reactions.htmhttp://chemistrybydesign.oia.arizona.edu/https://organicchemistrydata.org/hansreich/resources/syntheses/https://www.masterorganicchemistry.com/reaction-guide/ 这些数据库专门收集和整理了化学反应信息的在线资源，通常包含反应物、生成物、反应条件、催化剂、反应机理、产率等详细信息，对于化学研究和教育具有重要价值。
希望以上推荐对你有所帮助~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3b9654bc91e7a46680ed0df72affc54/" rel="bookmark">
			【AIGC】大型语言模型在人工智能规划领域模型生成中的探索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大型语言模型在人工智能规划领域模型生成中的新应用 一、引言二、LLM在规划领域模型生成中的潜力三、实证分析：LLM在规划领域模型生成中的表现四、代码实例：LLM在规划领域模型生成中的应用五、结论与展望 一、引言 随着人工智能技术的迅猛发展，规划系统成为了智能决策和自动化任务执行的核心。然而，在人工智能规划领域中，开发领域模型一直是一项繁重且复杂的工作，需要专家级的人工劳动。如何降低这一过程的复杂性，提高规划实现的效率，成为了业界关注的焦点。近年来，大型语言模型（LLM）在自然语言处理领域取得了显著成果，其强大的文本生成和理解能力引发了人们对于其在人工智能规划领域应用的期待。
二、LLM在规划领域模型生成中的潜力 大型语言模型，尤其是那些具有高参数计数的模型，具有强大的文本生成能力。这些模型能够从大量的文本数据中学习到丰富的语言知识和语义信息，从而生成符合语法规则和语境要求的文本。在人工智能规划领域，如果能够将LLM应用于领域模型的生成，那么将有望大大降低人工劳动的成本，提高规划实现的效率。
为了实现这一目标，研究人员提出了一种新的框架，通过比较域实例的计划集来自动评估LLM生成的域。这一框架的核心思想是利用LLM从自然语言描述中生成规划领域模型，然后通过比较生成的模型与真实模型在计划集上的表现来评估其准确性。
三、实证分析：LLM在规划领域模型生成中的表现 为了验证LLM在规划领域模型生成中的表现，研究人员对7个大型语言模型进行了实证分析。这些模型包括9个不同规划领域的编码和聊天模型，以及三类自然语言领域描述。通过对这些模型进行训练和测试，研究人员得到了以下发现：
LLM在从自然语言描述生成规划领域模型方面表现出中等水平的熟练程度。这意味着，尽管LLM生成的模型在某些情况下可能存在误差，但整体而言，其生成的模型具有较高的准确性和可用性。
具有高参数计数的LLM在生成规划领域模型时表现更好。这可能是因为高参数计数的模型具有更强的文本生成能力和更高的语言理解能力，从而能够更好地从自然语言描述中提取出规划领域的信息。
不同的规划领域对LLM的性能有不同的影响。在某些领域中，LLM生成的模型表现较好，而在另一些领域中则表现较差。这可能是因为不同领域的语言描述和规划需求存在较大的差异，导致LLM在不同领域中的表现也不同。
四、代码实例：LLM在规划领域模型生成中的应用 为了更具体地展示LLM在规划领域模型生成中的应用，下面给出一个简单的代码实例。假设我们有一个自然语言描述“一个机器人需要在房间内找到并拿起一个红色的球”，我们可以使用LLM来生成相应的规划领域模型。
python # 假设我们有一个预训练好的大型语言模型LLM # 这里我们使用一个假想的LLM库作为示例 from llm_library import LargeLanguageModel # 加载LLM模型 llm = LargeLanguageModel.load('my_large_language_model') # 自然语言描述 natural_language_description = "一个机器人需要在房间内找到并拿起一个红色的球" # 使用LLM从自然语言描述中生成规划领域模型 # 这可能包括定义状态、动作、目标等 planning_domain = llm.generate_planning_domain(natural_language_description) # 输出生成的规划领域模型（这里仅为示意，实际输出会更复杂） print(planning_domain) 在上面的代码中，我们假设存在一个名为LargeLanguageModel的库，其中包含了加载和使用LLM模型的功能。我们使用这个库加载了一个预训练好的LLM模型，并调用其generate_planning_domain方法来从自然语言描述中生成规划领域模型。生成的模型将包含状态、动作、目标等规划所需的信息。
五、结论与展望 大型语言模型在人工智能规划领域模型生成中展现出了中等水平的熟练程度，这为降低规划实现的人工劳动成本和提高效率提供了新的可能性。未来，随着LLM技术的不断进步和应用场景的不断扩展，我们有理由相信LLM将在人工智能规划领域发挥更加重要的作用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b146baf10a1fab4eec7a88f3d2e07f3/" rel="bookmark">
			HPE Aruba Networking推出全新AI网络安全和可视化产品 高效应对生成式AI安全威胁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		●在RSA信息安全大会上，HPE Aruba Networking为应对不断增长的生成式人工智能(AI)安全威胁，宣布推出全新AI网络安全控制功能;
●HPE将在HPE Aruba Networking Central中纳入全新由AI驱动的安全可视与监控功能，以应对物联网(IoT)安全风险;
●HPE Aruba Networking安全服务边缘(SSE)将推出全新防火墙即服务(FWaaS)功能，无需部署实体设备即可扩展对数据和设备的保护;
●最新发布的产品阵容还包括集成至HPE Aruba Networking EdgeConnect系列的全新安全Web网关(SWG)功能，提供一站式解决方案，实现全方位安全防护。
生成式AI的兴起以及不断演变的安全威胁，正促使安全团队将网络视为零信任安全架构中的一大利器。在2024年度RSA 大会上，HPE Aruba Networking持续发挥在安全网络领域的优势，通过推出全新的AI网络安全控制特性，扩展内置零信任安全功能，赋能安全团队全面保护从边缘到云的AI 贵重资产。
HPE Aruba Networking通过整合AI驱动的身份信息分析、安全策略以及边缘到云的实施部署，可帮助企业大规模保护 AI 数据、模型和应用，尤其在企业AI资产面临日益严峻的威胁环境下，该举措变得至关重要。
此次RSA大会上，HPE Aruba Networking展示了集成Axis Security创新成果的单一供应商安全访问服务边缘(SASE)解决方案的优势。HPE首席执行官Antonio Neri将Axis Security与HPE Aruba Networking产品组合的结合称之为业界“最全面的边缘产品组合”，并表示，“我们正通过SASE集成统一的安全框架，该框架将包含防火墙功能，并与零信任网络访问(ZTNA)、云访问安全代理(CASB)和SWG进行集成。通过与Axis Security的整合，HPE Aruba Networking不仅能够为用户提供安全的防火墙能力，还可提供更全面的连接层，以及通过收购Athonet获得的私有5G网络和全新发布的Wi-Fi 7接入点等一系列安全网络产品。”
HPE Aruba Networking始终坚持在构建网络基础设施的同时保障安全性，并在收购 Axis Security后，持续专注于增强边缘到云的安全防护，同时致力于打造“AI赋能的安全融合网络”，为深度赋能安全与网络团队提供全方位支持。
在HPE Aruba Networking Central中增加全面的AI驱动可观测安全和行为分析功能
目前，大量AI训练数据来自于未经管理的IoT设备。当IoT设备与云服务通信进行更新、遥测或其他操作时，需要通过网络进行传输，因此容易受到网络威胁。此外，网络上的自带设备(BYOD)和业务部门的设备通常也在IT团队职权范围之外，且可能会在没有任何预警的情况下被入侵和损坏。HPE Aruba Networking Central内置的全新AI驱动型IoT发现和分类功能，通过提供增强的网络连接设备的可视性和识别能力以及持续监控异常或欺骗行为来帮助解决IoT安全风险。
依托于HPE Aruba Networking Central中Client Insights所提供的AI驱动分析功能，全新一代HPE Aruba Networking Central利用机器学习模型分析设备动态属性，例如流量特征和连接状态、网络驻留时间等行为特征，从而准确分类和识别IoT以及传统设备。HPE Aruba Networking Central AIOps在故障排除和修复方面，具有自动化构建网络活动基线的强大能力，现如今HPE Aruba Networking利用AI将该项功能扩展至每个设备。这不仅能实现更精准、自动化的设备指纹识别以支持零信任安全，还能利用行为基线识别可能表明设备被入侵或遭受攻击的异常行为。
此外，通过将 AI驱动的设备分析功能集成至其他AI 功能以全面增强安全性。例如，HPE Aruba Networking利用AIOps和机器学习模型在设备使用率较低时智能地将接入点(AP)调整至休眠状态，以消除潜在的恶意活动切入点并缩小攻击面。
利用HPE Aruba Networking SSE 扩展防火墙安全控制
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b146baf10a1fab4eec7a88f3d2e07f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e95bd857c5359f4921e36e7d5d06b86e/" rel="bookmark">
			pycharm终端无法使用activate激活conda环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.存在问题2.解决方案（配置系统环境变量）3.测试成功与否 1.存在问题 pycharm终端没法直接使用activate指令启动base环境
2.解决方案（配置系统环境变量） 1.win+r输入sysdm.cpl
2.点击高级–环境变量
3.找到系统变量下的Path，双击进去，点击右上角新建，加入anaconda安装目录下的Scripts目录，连续确定即可。如下图
3.测试成功与否 1.win+r输入cmd
2.输入activate,检查是否出现base
问题成功解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f571133a5d4a9520d61f0a10dd508895/" rel="bookmark">
			day23--单元测试-反射-注解-动态代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		day23-单元测试、反射 恭喜同学们，Java主要的知识我们其实已经学习得差不多了。今天同学们再把单元测试、反射、注解、动态代理学习完。Java的基础知识就算全齐活了。
首先，我们进入单元测试的学习。
一、单元测试 1.1 单元测试快速入门 所谓单元测试，就是针对最小的功能单元，编写测试代码对其进行正确性测试。
我们想想，咱们之前是怎么进行测试的呢？
比如说我们写了一个学生管理系统，有添加学生、修改学生、删除学生、查询学生等这些功能。要对这些功能这几个功能进行测试，我们是在main方法中编写代码来测试的。
但是在main方法中写测试代码有如下的几个问题，如下图所示：
为了测试更加方便，有一些第三方的公司或者组织提供了很好用的测试框架，给开发者使用。这里给同学们介绍一种Junit测试框架。
Junit是第三方公司开源出来的，用于对代码进行单元测试的工具（IDEA已经集成了junit框架）。相比于在main方法中测试有如下几个优点。
我们知道单元测试是什么之后，接下来带领同学们使用一下。由于Junit是第三方提供的，所以我们需要把jar包导入到我们的项目中，才能使用，具体步骤如下图所示：
接下来，我们就按照上面的步骤，来使用一下.
先准备一个类，假设写了一个StringUtil工具类，代码如下
public class StringUtil{ public static void printNumber(String name){ System.out.println("名字长度："+name.length()); } } 接下来，写一个测试类，测试StringUtil工具类中的方法能否正常使用。
public class StringUtilTest{ @Test public void testPrintNumber(){ StringUtil.printNumber("admin"); StringUtil.printNumber(null); } } 写完代码之后，我们会发现测试方法左边，会有一个绿色的三角形按钮。点击这个按钮，就可以运行测试方法。
1.2 单元测试断言 接下来，我们学习一个单元测试的断言机制。所谓断言：意思是程序员可以预测程序的运行结果，检查程序的运行结果是否与预期一致。
我们在StringUtil类中新增一个测试方法
public static int getMaxIndex(String data){ if(data == null){ return -1; } return data.length(); } 接下来，我们在StringUtilTest类中写一个测试方法
public class StringUtilTest{ @Test public void testGetMaxIndex(){ int index1 = StringUtil.getMaxIndex(null); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f571133a5d4a9520d61f0a10dd508895/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c3c5d1cc745e49b5e4967fc0c463b7c/" rel="bookmark">
			Hive环境配置以及安装步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hive环境配置及安装步骤可以归纳如下：
1. 安装前提 确保Hadoop全分布式集群已经搭建成功，并可以在各个节点上正常启动和关闭。 2. 卸载MariaDB（可选） 如果系统中安装了MariaDB，且计划使用MySQL作为Hive的元数据存储，则需要卸载MariaDB。 设置防火墙服务不启动（使用systemctl disable firewalld）。查看并卸载Linux自带的MariaDB数据库。 3. 安装MySQL 安装Hive通常需要一个关系型数据库来存储元数据，如MySQL。 上传MySQL安装包。解压安装包。安装依赖文件，注意安装顺序。 4. Hive安装 下载并解压Hive安装包 从Hive官网下载Hive安装包（如apache-hive-x.x.x-bin.tar.gz）。使用tar -zxvf命令解压到指定目录（如/usr/local）。配置环境变量 使用vim编辑器编辑/etc/profile或用户级别的.bashrc文件。添加Hive相关的环境变量，如HIVE_HOME、PATH等。使用source命令使配置立即生效。修改Hive组件配置文件 进入Hive安装目录下的conf文件夹。创建或修改配置文件，如hive-env.sh和hive-site.xml。 在hive-env.sh中设置Java、Hadoop、Hive等环境变量。在hive-site.xml中配置Hive的各种参数，如元数据存储位置、数据库连接信息等。创建临时文件夹 在Hive安装目录中创建临时文件夹tmp。初始化Hive元数据 将MySQL驱动移动到$HIVE_HOME/lib目录下。初始化Hive元数据，使用schematool工具将Hive的数据重新写入MySQL数据库中。启动Hive 启动Hive服务，并进行相关操作，如查看数据库、创建表、插入数据等。 5. 注意事项 确保Hadoop集群运行正常，且Hive配置中指定的Hadoop路径正确。根据实际需求选择合适的Hive版本和配置参数。备份重要数据，以防配置过程中出现问题导致数据丢失。 以上步骤仅供参考，具体安装和配置过程可能因环境和需求的不同而有所差异。在实际操作中，建议参考Hive官方文档和相关教程进行安装和配置。
若没安装hadoop集群则可采取以下步骤：
安装Hadoop集群的步骤可以大致分为以下几个部分：
一、安装前准备 选择合适的Hadoop版本：例如Hadoop 3.1.3。下载必要的软件包： Hadoop安装包（如hadoop-3.1.3.tar.gz）。JDK安装包（Hadoop运行需要Java环境）。虚拟机软件（如VMware Workstation 16 Pro）。CentOS或Ubuntu等Linux系统的镜像文件。 二、虚拟机安装与配置 安装虚拟机软件：确保使用的虚拟机软件版本与操作系统兼容（如VMware Workstation 16 Pro）。创建虚拟机： 使用虚拟机软件创建新的虚拟机。设置虚拟机名称、存储位置、磁盘大小等参数。安装Linux系统（如CentOS 7或Ubuntu）。配置网络： 为虚拟机分配静态IP地址，并确保各节点之间的网络连通性。配置hosts文件，实现主机名与IP地址的映射。关闭防火墙和SELinux：在Linux系统中关闭防火墙和SELinux，以确保Hadoop集群能够正常运行。 三、JDK安装与配置 上传JDK安装包：将JDK安装包上传到Linux系统的指定目录。解压并安装JDK：使用tar命令解压JDK安装包，并配置环境变量。 四、Hadoop安装与配置 上传Hadoop安装包：将Hadoop安装包上传到Linux系统的指定目录。解压Hadoop：使用tar命令解压Hadoop安装包。配置环境变量：编辑/etc/profile文件，添加Hadoop相关的环境变量。修改Hadoop配置文件： 修改hadoop-env.sh文件，设置Java环境变量。修改core-site.xml文件，配置Hadoop核心参数，如文件系统名称、NameNode地址等。修改hdfs-site.xml文件，配置HDFS相关参数，如数据块大小、副本数量等。修改mapred-site.xml文件（如果该文件不存在，可以从mapred-site.xml.template复制并改名），配置MapReduce相关参数。修改yarn-site.xml文件，配置YARN相关参数。格式化NameNode：在Hadoop主节点上运行hdfs namenode -format命令，格式化NameNode。 五、Hadoop集群配置 克隆虚拟机：使用虚拟机软件的克隆功能，创建多个具有相同配置的虚拟机节点。修改克隆节点的主机名和网络配置：确保每个节点具有唯一的主机名和网络配置。配置SSH免密登录：在Hadoop集群中配置SSH免密登录，以便于节点之间的通信。 六、启动Hadoop集群 启动HDFS：在NameNode节点上启动HDFS服务。启动YARN：在ResourceManager节点上启动YARN服务。验证Hadoop集群状态：通过Hadoop提供的命令行工具或Web界面，验证Hadoop集群的状态和运行情况。 以上步骤是一个基本的Hadoop集群安装和配置流程，具体细节可能因环境差异和版本不同而有所调整。在实际操作中，建议参考Hadoop官方文档和相关教程进行安装和配置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e17720c7043bee2a1f73c8f81017f84/" rel="bookmark">
			国内AIGC工具是否存在版权争议？（ 计育韬老师高校公益巡讲答疑实录2024）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是计育韬老师第 8 次开展面向全国高校的新媒体技术公益巡讲活动了。而在每场讲座尾声，互动答疑环节往往反映了高校师生当前最普遍的运营困境，特此计老师在现场即兴答疑之外，会尽量选择有较高价值的提问进行文字答疑梳理。
*本轮巡讲主题除了涉及 SVG 交互外，还包含了新媒体中 AI 人工智能工作流的详解，为高校师生带来包括与多家央媒的项目合作经验和复旦大学本校的案例分析，因此答疑梳理中也会出现与 AI 相关的知识点，如有任何偏颇之处也欢迎在评论区斧正。
第七期计育韬老师继续梳理了在西安高校的讲座中，关于「国内 AIGC 工具是否存在版权争议？」的问题，一起来看看计育韬老师的答复吧！
AIGC版权归属于谁？ 版权作为司法层面概念，其探讨离不开判例的参考，2023年11月，北京互联网法院作出国内第一例生成式人工智能（AIGC）作品著作权侵权纠纷的判决，案件审理情况简要归纳如下：
基本案情
2023年2月24日，原告李某使用AI图片生成软件“Stable Diffusion”通过输入提示词的方式生成古装少女的图片，后将该图片以“春风送来了温柔”为名发布在小红书平台，并标注为“AI插画”。但在2023年3月2日，原告发现被告刘某通过百家号账号发布了名为《三月的爱情，在桃花里》的文章，文章里使用了自己先前生成的图片作为插图，并且去除了该图片原有的水印。随后，李某以侵害作品署名权和信息网络传播权为由将刘某起诉到北京互联网法院，要求被告赔偿其经济损失5000元，并赔礼道歉。
裁判理由
焦点问题
法院观点
涉案图片是否构成作品，构成何种类型作品？
原告在Stable Diffusion输入提示词，设置参数，生成初始图片，又根据初步生成的图片，增加提示词、调整参数，最终选择了自己满意的图片即涉案图片，体现了原告的“智力投入”，图片具备了“智力成果”要件。涉案图片体现出与在先作品的可识别的差异性，原告通过提示词和参数的调整修正获得涉案图片，体现原告的审美和个性化表达，案涉图片具有“独创性”要件。综上，涉案图片属于作品，且属于美术作品，受到著作权法保护。
原告是否享有涉案图片的著作权？
涉案人工智能模型设计者仅是创作工具的生产者，不是涉案图片的作者，其亦不主张对输出内容的权利。原告是涉案图片的作者，享有涉案图片的著作权。
被诉行为是否构成侵权行为，被告是否应当承担法律责任？
被告未经许可，使用涉案图片作为配图并发布在自己的账号中，使公众可以在其选定的时间和地点获得涉案图片，侵害了原告就涉案图片享有的信息网络传播权。被告去除水印的行为，侵害了原告的署名权。被告应当承担赔礼道歉、赔偿损失等民事责任，根据涉案图片情况及侵权使用情节，确定赔偿金额500元。
判决结果
2023年11月27日，北京互联网法院对上述案件做出了一审判决，主要内容为被告刘某在涉案百家账号“我是***”上发布声明向原告赔礼道歉，赔偿原告李某经济损失500元。
尽管我们一般认为 AIGC 作为人类样本综合学习得到的产出结果，似乎天然「包含」了其他创作者的版权，但熟悉 SD 的同学会知道较之于 MJ 其提示词工程、参数调整的工作更为复杂和自定义。而在上述判例中，法院强调了 AIGC 工程师的「智力投入」与「智力结果」以及结果的「独创性」，可见所谓「版权争议」本身需要被解构进行分析。
应用建议 回到同学的提问中来——所以无论是使用了国产软件还是海外软件，应用时都建议积极做到充分的「智力投入」，发挥主观能动性在平台生成的基础上开展充分的调试、迭代和优化。
而在客观事实上，本身国产的 AIGC 工具相对水平不足，像即梦、天音等工具的自定义能力和海外同类 AIGC 工具相比还有较大差距，一定程度限制了使用者对生成内容的修改。那么参考判例中的场景，计育韬老师认为如果你转而采用 Stable Diffusion、Midjourney 等平台开展 AIGC 工具，本身就有助于更好地规避版权风险。
后续答疑预告 #AIGC创作过程中提示词Prompt有什么建议？
#配音方面目前可以用AIGC替代吗？
#在国内文案写作有哪些合适的AIGC工具？
#您如何看待AIGC中的美术版权争议问题？
#H5和SVG的最大区别和各自优势是什么？
#如果要基于交互设计创意应该做哪些准备？
#可以运用AI写SVG代码吗？
如有意向报名承办巡讲的高校站点，欢迎查看「报名须知」并在评论区留下你的联系方式和组织信息，助教老师将协助前期对接工作。
-END-
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d828bceeade0568df6f3f20dde9d79a/" rel="bookmark">
			【C&#43;&#43;】哈希(2万字)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
目录
前言
unordered系列关联式容器
unordered_map
unordered_map的文档介绍
unordered_map的接口说明
unordered_set
底层结构
哈希概念
哈希冲突
哈希函数
哈希冲突解决
闭散列
线性探测的实现并改造
二次探测
开散列
开散列概念
开散列实现并改造 + 迭代器的实现
开散列增容
开散列与闭散列比较
不同的类型转换成整型的操作
MyOrderedMap.h
MyOrderedSet.h
哈希的应用
位图
位图概念
位图的实现
位图应用
布隆过滤器
布隆过滤器提出
布隆过滤器概念
布隆过滤器的插入
布隆过滤器的查找
布隆过滤器删除
布隆过滤器优点
布隆过滤器缺陷
布隆过滤器的面试题
哈希切割
总结
前言 世上有两种耀眼的光芒，一种是正在升起的太阳，一种是正在努力学习编程的你!一个爱学编程的人。各位看官，我衷心的希望这篇博客能对你们有所帮助，同时也希望各位看官能对我的文章给与点评，希望我们能够携手共同促进进步，在编程的道路上越走越远！
提示：以下是本篇文章正文内容，下面案例可供参考
unordered系列关联式容器 在C++98中，STL提供了底层为红黑树结构的一系列关联式容器，在查询时效率可达到$log_2 N$，即最差情况下需要比较红黑树的高度次，当树中的节点非常多时，查询效率也不理想。最好 的查询是，进行很少的比较次数就能够将元素找到，因此在C++11中，STL又提供了4个 unordered系列的关联式容器，这四个容器与红黑树结构的关联式容器使用方式基本类似，只是其底层结构不同，本文中只对unordered_map和unordered_set进行介绍， unordered_multimap和unordered_multiset学生可查看文档介绍。
unordered_map unordered_map的文档介绍 unordered_map文档介绍
unordered_map是存储键值对的关联式容器，其允许通过keys快速的索引到与其对应的value。在unordered_map中，键值通常用于惟一地标识元素，而映射值是一个对象，其内容与此键关联。键和映射值的类型可能不同。在内部，unordered_map没有对按照任何特定的顺序排序，为了能在常数范围内找到key所对应的value，unordered_map将相同哈希值的键值对放在相同的桶中。unordered_map容器通过key访问单个元素要比map快，但它通常在遍历元素子集的范围迭 代方面效率较低。unordered_maps实现了直接访问操作符(operator[])，它允许使用key作为参数直接访问 value。它的迭代器至少是前向迭代器。 unordered_map的接口说明 1. unordered_map的构造
函数声明功能介绍unordered_map构造不同格式的unordered_map对象 2. unordered_map的容量
函数声明功能介绍bool empty() const检测unordered_map是否为空size_t size() const获取unordered_map的有效元素个数 3. unordered_map的迭代器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d828bceeade0568df6f3f20dde9d79a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc4d402dd4c4d1e608aac73c4cd732cf/" rel="bookmark">
			揭秘数据结构的魔力：用堆（Heap）打造高效排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人主页：一代... 个人专栏：数据结构
1. 定义： 堆通常是一个可以被看做一棵树的数组对象，在物理层面上表现为顺序存储结构，但在逻辑层面上是完全二叉树的形态，这意味着除了最后一层外，每一层都被完全填满，且最后一层从左到右填充。堆中某个结点的值总是不大于或不小于其父结点的值，这一性质使得堆成为最高效的优先级队列。 （注意：大堆和小堆的实现都是用数组来实现的，其物理结构是数组 但其逻辑结构是一颗完全二叉树）
用数组实现堆，假设其双亲节点的下标为i，则其左孩子节点的下标为2*i+1，右孩子节点的下标为2*i+2
若孩子节点的坐标为i（这里的孩子节点无论是左孩子还是右孩子），其双亲节点的坐标都为(i-1)/2;
如果想要一个数组变为堆，首先要把其看做完全二叉树的结构
如数组a[4]={2,1,3,4}
将其理解为树的结构就变为：（理解为树的结构后就可以对其进行操作，将其变为大堆或小堆）
2. 堆的分类 堆分为大堆和小堆
大堆：大堆的双亲节点都大于其孩子节点 小堆：小堆的双亲节点都小于其孩子节点 3. 堆的实现 a. 堆的结构体定义: typedef int HPDataType; typedef struct Heap { HPDataType* a; int size; int capacity; }HP; b. 堆的初始化 void HPInit(HP* php) { php-&gt;a = NULL; php-&gt;capacity = php-&gt;size = 0; } c. 堆的建立 ⅰ. 向上调整法 向上调整法要从第一个元素开始，向上调整法建小堆时，当孩子节点小于双亲节点时，孩子节点的值就和父亲节点的值交换，孩子节点坐标等于双亲节点的坐标，双亲节点的坐标变为（双亲节点的坐标-1）/ 2，当孩子节点==0时循环结束。
void Swap(HPDataType* a, HPDataType* b) { HPDataType tmp = *a; *a = *b; *b = tmp; } void AdjustUp(HPDataType* a, int child) //不传结构体，为了后面排序做准备，原因后面会解释 { assert(a); int parent = (child - 1) / 2; while (child &gt; 0) //parent&gt;=0可以作为结束条件，但是一个巧合， //因为到最后是依靠当child==0，parent=（child-1）/2=-1/2=0时 //a[parent]==a[child]结束的 { if (a[child] &lt; a[parent])//建小堆，若a[child]&gt;a[parent]就建大堆 { Swap(&amp;a[child], &amp;a[parent]); child = parent; parent = (parent - 1) / 2; } else { break; } } } 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc4d402dd4c4d1e608aac73c4cd732cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d3035bc0160aa9ef022f2a3d2ad853b/" rel="bookmark">
			【算法】哈希表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快乐的流畅：个人主页 个人专栏：《算法神殿》《数据结构世界》《进击的C++》 远方有一堆篝火，在为久候之人燃烧！ 文章目录 引言一、两数之和二、判断字符重排三、存在重复元素四、存在重复元素 ||五、字母异位词分组 引言 哈希表，其作用在于快速查找特定的值，从而优化时间复杂度，但会增加空间复杂度，典型以空间换时间。在做题的过程中，可以用数组模拟（数据范围小且数据为正），也可以用容器实现。
一、两数之和 思路：
暴力解法：我们每次先固定一个数，再查找该数之前的所有数（这里的思路和普通暴力略有不同）利用哈希表优化：每次遍历完一个数，将其存入哈希表，再次查找时就不用依次往前遍历为什么之前的暴力策略不好用了呢？因为按照之前的暴力策略，要事先将所有的数都存入哈希表中，再在哈希表中进行查找。同时，因为有可能查找到自身元素，所以还要额外判断排除这种情况。
class Solution { public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { unordered_map&lt;int, int&gt; hash;//&lt;nums[i], i&gt; for(int i=0; i&lt;nums.size(); i++) { int n = target - nums[i]; if(hash.count(n)) return {hash[n], i}; hash[nums[i]] = i; } return {}; } }; 二、判断字符重排 思路：
先判断两个字符串长度是否相等，若不相等则肯定不能重排利用哈希表，统计每个字母出现的个数遍历s1，增加字符个数，遍历s2，减少字符个数，当字符个数为负数，则不能重排（同时这样可以只使用一个哈希表）若最后没有字符个数为负数，则代表也没有字符个数为正（因为两个字符串长度相等，拥有的字符数相等），则代表对应的字符数相等 class Solution { public: bool CheckPermutation(string s1, string s2) { if(s1.size() != s2.size()) return false;//优化 int hash[26] = { 0 }; for(auto ch : s1) hash[ch - 'a']++; for(auto ch : s2) { hash[ch - 'a']--; if(hash[ch - 'a'] &lt; 0) return false;//优化 } return true; } }; 三、存在重复元素 思路：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d3035bc0160aa9ef022f2a3d2ad853b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92f7fb6726e6c35657ec786daf294e51/" rel="bookmark">
			【嵌入式硬件】DRV8874电机驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 芯片介绍
1.1 特性简介 1.2 引脚配置 1.3 最佳运行条件
2 详细说明
2.1 PMODE配置控制模式
2.1.1 PH/EN 控制模式
2.1.2 PWM 控制模式
2.1.3 独立半桥控制模式
2.2 电流感测和调节
2.2.1 IPROPI电流感测
2.2.2 IMODE电流调节 3.应用
3.1设计要求
3.2 设计过程 1 芯片介绍 1.1 特性简介 1）N沟道H桥电机驱动；
2）驱动1个双向有刷直流电机；
3）2个单向有刷直流电机；
4）4.5V-37V工作电压范围；
5）集成电流感测和调节；
6）成比例电流输出（IPROPI）；
7）可选电流调节（IMODE）:逐周期或固定关断时间；
8）支持1.8、3V、5V逻辑输入；
9）集成保护：欠压、电荷泵欠压、过流保护、输出关闭、热关断、自动故障恢复
1.2 引脚配置 1.3 最佳运行条件 2 详细说明 2.1 PMODE配置控制模式 2.1.1 PH/EN 控制模式 PMODE引脚加电时处于逻辑低电平。
2.1.2 PWM 控制模式 如果 PMODE 引脚在加电时处于逻辑高电平状态 ， 器件将锁存至 PWM 模式。 2.1.3 独立半桥控制模式 如果 PMODE 引脚在加电时处于高阻抗状态 ， 器件将锁存至独立半桥控制模式。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92f7fb6726e6c35657ec786daf294e51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf7090cb431cf0e5ee5fea4a8f5a4c3c/" rel="bookmark">
			redis 频繁报超时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		StackExchange.Redis.RedisTimeoutException:“Timeout performing SETEX HotelInfo, inst: 1, queue: 2, qu: 0, qs: 2, qc: 0, wr: 1, wq: 1, in: 0, ar: 0, clientName: CTExternalStandard.API, serverEndpoint: 192.168.1.1:6379, keyHashSlot: 2129 (Please take a look at this article for some common client-side issues that can cause timeouts:
如果redis 频繁报超时，StackExchange.Redis中的ConnectTimeout, ResponseTimeout, 和SyncTimeout 这三个时间显示的指定一下，
ConfigurationOptions redisConfigOption = new ConfigurationOptions(); redisConfigOption.EndPoints.Add(GetAppSetings.RedisServiceName); redisConfigOption.AllowAdmin = false; redisConfigOption.Password = GetAppSetings.RedisPassword; redisConfigOption.ClientName = GetAppSetings.RedisClientName; redisConfigOption.ConnectTimeout = 60000; redisConfigOption.ResponseTimeout = 60000; redisConfigOption.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf7090cb431cf0e5ee5fea4a8f5a4c3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/801cd3bc97c1c12360aced0714024922/" rel="bookmark">
			【OpenHarmony】OpenHarmony 简介 ( HarmonyOS / OpenHarmony - Android / AOSP 对比关联 | 鸿蒙开发者定位及使用的开发语言和开发工具)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、OpenHarmony 简介1、OpenHarmony 由来2、OpenHarmony 架构3、OpenHarmony 特点 二、HarmonyOS / OpenHarmony - Android / AOSP 对比关联1、HarmonyOS 与 Android 的关系2、HarmonyOS 与 OpenHarmony 的关系3、HarmonyOS 与 OpenHarmony 的版本迭代 三、鸿蒙开发者定位及使用的开发语言和开发工具 一、OpenHarmony 简介 1、OpenHarmony 由来 OpenHarmony 官方网址 http://www.openharmony.cn/mainPlay ;
OpenHarmony 是 开源的分布式操作系统 ,
由 华为公司 捐赠 智能终端操作系统 基础能力 相关代码 ,
由 开放原子开源基金会 ( OpenAtom Foundation ) 运营的开源项目 ,
其 目标 是 面向全场景 / 全连接 / 全智能时代 / 基于开源的方式 , 搭建一个 智能终端设备 操作系统 的框架和平台 ,
旨在实现全场景智能互联 , 可以应用于智能手机 / 平板电脑 / 智能手表 / 智能电视 / 智能家居等各种设备 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/801cd3bc97c1c12360aced0714024922/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e73413abec690f81af343b04488862a/" rel="bookmark">
			【React篇】简述React-Router 的实现原理及工作方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		React Router 路由的基础实现原理分为两种，如果是切换 Hash 的方式，那么依靠浏览器 Hash 变化即可；如果是切换网址中的 Path，就要用到 HTML5 History API 中的 pushState、replaceState 等。在使用这个方式时，还需要在服务端完成 historyApiFallback 配置。
在 React Router 内部主要依靠 history 库完成，这是由 React Router 自己封装的库，为了实现跨平台运行的特性，内部提供两套基础 history，一套是直接使用浏览器的 History API，用于支持 react-router-dom；另一套是基于内存实现的版本，这是自己做的一个数组，用于支持 react-router-native。
React Router 的工作方式可以分为设计模式与关键模块两个部分。从设计模式的角度出发，在架构上通过 Monorepo 进行库的管理。Monorepo 具有团队间透明、迭代便利的优点。其次在整体的数据通信上使用了 Context API 完成上下文传递。
在关键模块上，主要分为三类组件：第一类是 Context 容器，比如 Router 与 MemoryRouter；第二类是消费者组件，用以匹配路由，主要有 Route、Redirect、Switch 等；第三类是与平台关联的功能组件，比如 Link、NavLink、DeepLinking 等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/828575dadf88e4d5d81782ac598cac99/" rel="bookmark">
			鸿蒙工程目录介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鸿蒙构建完毕生成hhvp文件。
项目结构：
.hvigor : 是存储构建配置文件的
.idea : 是开发工具拥有的目录
AppScope : 是全局的公共资源存放位置
hvigor ：存放前端构建配置信息
oh_modules : 存放项目用到的第三方包
build-profile.json5 : 应用级别的构建配置信息
hvigorfile.ts : 执行编译构建任务的一个脚本
oh-package.json5 : 依赖的配置
oh-package-lock.json5 : 生成的一个树形的依赖树
模块结构：
ohosTest : 单元测试
build-profile.json5 : 模块级别的构建配置信息
hvigorfile.ts : 模块级别的执行编译构建任务的一个脚本
module.json5 : 当前模块的配置信息
module.json5:
{ "module": { "name": "entry", // 模块名字 "type": "entry", // "description": "$string:module_desc", "mainElement": "EntryAbility", // 当前模块入口 "deviceTypes": [ "phone", "tablet", "2in1" ], "deliveryWithInstall": true, "installationFree": false, "pages": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/828575dadf88e4d5d81782ac598cac99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/700ebecf105b70d2e13072b1c694cad7/" rel="bookmark">
			Python与Excel的完美结合：操作技巧与自动化应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文全面探讨了使用Python进行Excel操作的各种技巧和自动化应用，包括基础操作、高级数据处理、图表创建、自动化任务等。通过详细介绍Python在Excel中的应用，结合实际案例，帮助读者深入理解并掌握Python处理Excel文件的强大功能。
文章目录 Python与Excel的基础操作Python Excel库介绍安装Python Excel库读取和写入Excel文件读取Excel文件写入Excel文件 操作Excel单元格和范围使用openpyxl操作单元格使用pandas操作数据范围 处理Excel文件格式（xls和xlsx）读取xls文件写入xls文件 高级数据处理技巧使用pandas进行数据分析数据清洗和转换数据合并与重塑条件过滤与数据清洗缺失值处理和异常值检测 图表创建与数据可视化使用matplotlib和seaborn创建图表使用matplotlib创建图表使用seaborn创建图表 图表样式和布局设置样式设置布局设置 交互式数据可视化使用ipywidgets实现交互使用plotly实现交互 自动化Excel任务自动化报告生成实现步骤示例代码 宏和脚本自动化实现步骤示例代码 数据爬取与导入Excel实现步骤示例代码 集成Excel与其他应用程序实现步骤示例代码 Python在Excel中的实际应用案例销售数据分析财务报表自动化数据处理脚本自动化邮件发送 Python与Excel的未来趋势Python在Excel中的新功能增强的数据处理能力自动化和集成用户体验改进数据存储和处理协作和共享行业应用深化 Python与Excel的基础操作 Python Excel库介绍 Python提供了多种库来处理Excel文件，使得数据分析和处理变得更加高效和灵活。以下是几个常用的Python Excel库：
openpyxl: 主要用于读取和写入Excel 2010 xlsx/xlsm/xltx/xltm文件，支持多个工作表、图表等。xlrd 和 xlwt: 分别用于读取和写入Excel文件，支持多个工作表，但不支持Excel 2010 xlsx/xlsm/xltx/xltm格式。pandas: 虽然主要用于数据分析，但也提供了读写Excel文件的功能，支持多个工作表，但不支持Excel 2010 xlsx/xlsm/xltx/xltm格式。 安装Python Excel库 安装这些库通常使用pip工具，命令如下：
pip install openpyxl xlrd xlwt pandas 读取和写入Excel文件 读取Excel文件 使用pandas库读取Excel文件的示例代码如下：
import pandas as pd # 读取Excel文件 df = pd.read_excel('example.xlsx') 写入Excel文件 使用pandas库将数据写入Excel文件的示例代码如下：
import pandas as pd # 将数据写入Excel文件 df.to_excel('example.xlsx', index=False) 操作Excel单元格和范围 使用openpyxl操作单元格 import openpyxl # 打开Excel文件 workbook = openpyxl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/700ebecf105b70d2e13072b1c694cad7/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/327/">«</a>
	<span class="pagination__item pagination__item--current">328/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/329/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>