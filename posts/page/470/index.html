<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd0e50fb9dc1d84918d78dd310ad8f59/" rel="bookmark">
			Midjourney 重大更新！深度解析「角色一致性」命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Midjourney 重大更新！深度解析「角色一致性」命令 大家期待已久的 MJ 角色一致性功能终于来啦！全新的命令“–cref”现已推出，与之前的样式参考“–sref”功能相似，但不同的是，它不是匹配参考样式，而是试图让角色与“角色参考”图像相匹配。目前，“–cref”仅适用于 niji 6 和 v6 模型。如果不知道怎么使用Midjourney可以参考这篇文章：Midjourney最新注册、订阅教程（新手小白） - OpenAI-ChatGPT导航-ChatGPT账号注册、升级指南，最新资讯 让我们来看看官方文档的说明：
一、基础使用方法 只需在提示符后输入“–cref URL”，并输入角色图像的 URL 地址，然后使用“–cw”来修改参考强度。
默认强度为 100（–cw 100），包括脸部、头发和衣服。
当强度为 0（–cw 0）时，它只会关注脸部（适用于更换服装/头发等）。
二、提示词编写 官方指出，此功能并非针对真人/照片设计，可能会像普通图像提示一样使其变形，但经过体验后，效果还不错，至少对亚洲人脸孔的参考表现良好。使用“–cref”处理提示有三种主要方法：
1. 锚定重要角色详细信息的提示 可以锚定细节（姿势、表情、情感、服装、道具、场景、动作），以便能够控制它们，让“–cref”处理大部分工作，或者可以只提供角色的场景并让“–cref”完成所有工作。
2. 允许“–cref”完成工作不干涉提示 对于关键角色，可以不做任何描述，提示不会尝试强化参考图像中的任何细节，它只是“傀儡”或“摆出”角色的姿势。
3. 仅使用场景提示 如果“–cref”图像已包含想要的姿势和其他细节，可以仅描述设置、周围环境、上下文或背景，MJ 将努力将角色融入场景中，但可能会出现一些不连贯的结果，因此需要使用更高的样式值（–s）重试，以便让“–cref”图像更好地融入场景。例如，使用–s 800 之后的图片明显融合得更好。
“Cref”适用于 Niji 和普通 MJ 模型，并可与“–sref”结合使用。
我们可以拿刚生成的一组图，并加上“–sref”参考样式，生成的图片将保持参考角色不变，但风格会发生改变。
三、高级功能 1. 在一个画布上放置多个角色 想要在一个画面中出现多个角色，可以直接使用 pan 功能，并对提示词进行微调。例如，在已有图片上加上一个男性角色，这需要对男性角色进行描述。
2. 使用多个 URL 来混合多张图片中的信息/字符 可以使用多个 URL 来混合多张图片中的信息/字符，例如“–cref URL1 URL2”（类似于多张图片或样式提示）。
3. 与“–sref”结合使用 使用多个 URL 来混合图片，也可以同时与“–sref”结合使用，效果也是很不错的。
4. “–cw”参数的作用 Midjourney 能够从参考图像中识别的角色属性将与提示混合，从而创建出新的角色。
可以通过使用“–cw N”参数（cref 权重）来控制，其中 N 的值可以从 1 到 100。默认值为 100。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd0e50fb9dc1d84918d78dd310ad8f59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e70a8145ca398decdc0fe8f79125b3d9/" rel="bookmark">
			解决unbutu终端中/usr/bin/env: “python”: 没有那个文件或目录的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，创作灵感： 在网上找了很多方法发现并不尽然，很多方法都用不了，所以自己总结了一些能用的代码与解决方法。
二，错误原因与原理： 将我们运行的程序开头的声明 #! /usr/bin/env python 改为 #! /usr/bin/env python3 ，因为noetic的python版本是3
三，解决方法： sudo ln -s /usr/bin/python3 /usr/bin/python
这个方法可以创建一个链接符号到 python 命令 ,运行一句代码就可以了，现在Ubuntu 20.04以后都是python2，python3了，然后我们的问题就解决啦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a968d5bf70448bf77e4e05b02e32e01/" rel="bookmark">
			解决 Redis7.0远程连接及客户端连接报错：WRONGPASS invalid username-password pair or user is disabled.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、报错贴图：
二、报错说明：
在redis.conf文件设置bind 0.0.0.0 和protected-mode no以及密码之后，通过本地工具远程连接服务器的redis始终连接不上，且能够确认服务器上的redis是正常运行，本地也能telnt通服务器的6379端口，后来发现：redis7.0升级了一个东西：当设置密码后，用户名不再是root，会有一个默认的用户名：default，把用户名改成default 成功解决问题。
三、解决方式：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57825b3d8e676c363e6b021333d48263/" rel="bookmark">
			Mysql的root账户密码忘记了怎么办？百分百教会你如何重置！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天装mysql的时候登录密码死活登不上去，找了很多教程都没有用。看看我的！
（ps:一定记得用管理员身份打开命令行窗口）
一、重置root账户密码 1.输入失败 很明显此时我的账户密码不正确
2.退出mysql 千万不要忘记了，要不然后面的操作就打水漂了
3.开始操作 1.找mysql的bin目录 复制自己下载mysql存放bin目录的路径（这是我的）
2.命令行进入文件夹 在命令行中通过cd指令进入该文件夹
3.输入 mysqld --console --skip-grant-tables --shared-memory
4.重开一个命令行窗口（此时可以不用管理员身份） 我一般习惯直接在bin目录路径处输入cmd直接进入
输入：mysql（一次不成功可以多输入一次）
出现我用红色下划线的结果
5.重置密码 首先输入：flush privileges;
表示刷新一下
输入：set password for root@localhost='1';
表示将密码修改为 1（此处的密码可以自定义修改）
接着输入：exit;
表示退出mysql操作
6.尝试使用修改的密码进行登录 输入：mysql -u root -p
密码为刚刚所修改的 1
成功！！！嘿嘿
好了到此结束，多谢点赞！！！嘻嘻
有问题可以私聊哈！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/625da383cf55d421ddd352bae91478b9/" rel="bookmark">
			肝了三天，完成了AIGC工具网站大全，建议收藏再看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说是肝了三天，其实远远不止，前前后后，从资料搜集到最后整理成文，有近一个月了，大家看在整理不易的份上，给点个赞吧，不要光顾着收藏呀！
国内网站 AIGC 导航 https://www.aigc.cn
网站很全面，而且可以看出商业化也比较成功，无论是招商还是引流到微信
还有 AIGC 的行业咨询，挺棒的
潮点 AI 工具导航 https://aichaodian.com/
相对来说，这个网站就非常简洁了，除了 AI 工具站，你甚至看不到任何其他杂质
AI 工具集 https://ai-bot.cn/
该网站除了收集了比较全面的 AIGC 网站外，还提供提交网站的功能，且还有 AI 百科等栏目，对新手还是比较友好的
工具达人 https://toolsdar.com/ai
网站整体内容还可以，只不过已经接入了广告系统，介意的朋友绕行
Jay 的资源库 https://www.lovejay.top/
一个不仅限于收集 AIGC 工具的网站，虽然网站更全面了，但是也有分散注意力的问题存在
AI 导航 https://ai.tboxn.com/
貌似也接入了广告系统，不过整体内容还不错
AI 导航网 https://www.ainav.cn/
AIL https://www.ai-lib.club/
该网站访问较慢，资源加载速度感人
AIG123 https://www.aig123.com/
零沫 https://0mo.com/
为数不多的国内不同 UI 风格的网站
未来百科 https://nav.6aiq.com/
AI Way https://aiwaytools.com/
gptdemo https://www.gptdemo.net/cn
openai666 https://openai666.com/
AI 大师 https://www.aidashi.cn/
网站的 UI 风格好相似啊，感觉都是一个开源项目继承下来的
aiagc https://www.aiagc.com/
该网站还有代充业务，大家自行判断
ChatGPT 导航站 https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/625da383cf55d421ddd352bae91478b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0b11eb1448ea653ef9c3e1accf7450e/" rel="bookmark">
			前端React篇之React的生命周期有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 React的生命周期有哪些？挂载阶段（Mounting）更新阶段（Updating）卸载阶段（Unmounting）错误处理阶段（Error Handling） React常见的生命周期React主要生命周期 React的生命周期有哪些？ 在React中，组件的生命周期经历了不同阶段，每个阶段都有对应的生命周期方法。以下是React 16版本之后的组件生命周期方法：
挂载阶段（Mounting）：
constructor(props)：组件的构造函数，在创建组件时调用，用于初始化状态和绑定事件处理方法。static getDerivedStateFromProps(props, state)：在组件实例化时和接收新的props时调用，用于根据props更新state。render()：准备渲染组件的UI结构。componentDidMount()：组件第一次渲染完成后调用，通常用于执行一次性的操作，如数据获取、订阅事件等。 更新阶段（Updating）：
static getDerivedStateFromProps(props, state)：在组件接收新的props时调用，用于根据新的props更新state。shouldComponentUpdate(nextProps, nextState)：决定组件是否需要重新渲染，可以通过返回false来阻止不必要的渲染。render()：重新渲染组件的UI结构。getSnapshotBeforeUpdate(prevProps, prevState)：在最近一次渲染输出（提交到 DOM 上）之前调用，可以用于获取当前 DOM 的快照信息。componentDidUpdate(prevProps, prevState, snapshot)：组件更新完成后调用，通常用于处理更新后的操作，如数据同步、DOM 操作等。 卸载阶段（Unmounting）：
componentWillUnmount()：组件即将被卸载和销毁时调用，用于清理定时器、取消订阅等操作。 错误处理阶段（Error Handling）：
static getDerivedStateFromError(error)：当子组件抛出错误时调用，用于更新组件的state以渲染降级 UI。componentDidCatch(error, info)：用于捕获组件内部的 JavaScript 错误、网络请求失败等异常情况，并进行错误处理。 新的生命周期方法（可选）：
static getDerivedStateFromError(error) 和 componentDidCatch(error, info) 是 React 16 引入的新的错误处理生命周期方法。 这些生命周期方法在组件的不同阶段被调用，开发者可以利用这些方法来管理组件的状态、执行特定的操作或者处理错误。值得注意的是，随着React版本的更新，一些生命周期方法可能会被废弃或者替代，因此在使用时需要留意官方文档的更新。
挂载阶段（Mounting） 在React组件的挂载阶段（Mounting Phase）中会依次执行以下方法：
constructor(props)：
构造函数，在创建组件时调用，用于初始化状态和绑定事件处理方法。在构造函数中通常做两件事情：初始化组件的状态和绑定事件处理方法。如果不需要初始化state或绑定方法，则不需要显式定义构造函数。 static getDerivedStateFromProps(props, state)：
静态方法，用于根据props更新state。在组件实例化时和接收新props时调用，返回一个对象来更新当前state，如果不需要更新可以返回null。在React 16.4版本及以上，setState和forceUpdate也会触发该生命周期方法。 render()：
渲染方法，准备渲染组件的UI结构。根据状态state和属性props渲染组件，返回需要渲染的内容。只做一件事情：返回需要渲染的内容，不要在这个方法内部做其他业务逻辑。 componentDidMount()：
在组件第一次渲染完成后调用，通常用于执行一次性操作，如数据获取、订阅事件等。可以执行依赖于DOM的操作、发送网络请求、添加订阅消息等。避免在componentDidMount中直接调用setState，因为会触发额外的渲染。 下面是一个示例代码，展示了挂载阶段的一些典型使用方法：
import React, { Component } from 'react'; class SampleComponent extends Component { constructor(props) { super(props); this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0b11eb1448ea653ef9c3e1accf7450e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84e6cdf18810a30f812f26ee800741d7/" rel="bookmark">
			SpringAI——Java生态接入LLM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近，Spring官网发布了SpringAI，可点此查看https://spring.io/blog/2024/03/12/spring-ai-0-8-1-released，对于SpringAI的介绍，可看官方文档：https://spring.io/projects/spring-ai#overview。
本文将使用SpringAI配合Ollama完成SpringAI的体验，下面分别介绍SpringAI和Ollama。
一、Spring AI Spring AI是一个专为人工智能工程而设计的应用框架。它的目标是将Spring生态系统的设计原则，如可移植性和模块化设计，应用于人工智能领域，并推广使用纯Java对象（POJO）作为AI领域应用程序的构建块。
1.Spring AI的核心特性 跨AI提供商的API支持：Spring AI提供了一套可移植的API，支持与多个AI服务提供商的聊天、文本到图像和嵌入模型进行交云。同步和流式API选项：框架支持同步和流式API，为开发者提供了灵活的交互方式。模型特定功能访问：允许开发者通过配置参数访问特定模型的功能，提供了更细致的控制。 2.支持的模型 聊天模型：包括OpenAI、Azure Open AI、Amazon Bedrock、Cohere’s Command、AI21 Labs’ Jurassic-2、Meta’s LLama 2、Amazon’s Titan、Google Vertex AI Palm、Google Gemini、HuggingFace（包括Meta的Llama2等数千种模型）、Ollama（本地运行AI模型）、MistralAI等。文本到图像模型：如OpenAI的DALL-E、StabilityAI等。嵌入模型：包括OpenAI、Azure Open AI、Ollama、ONNX、PostgresML、Bedrock Cohere、Bedrock Titan、Google VertexAI、Mistal AI等。 3.向量存储API和向量数据库 Spring AI提供了跨不同提供商的向量存储API，具有类似SQL的元数据过滤API，保持了可移植性。支持的向量数据库包括Azure Vector Search、Chroma、Milvus、Neo4j、PostgreSQL/PGVector、PineCone、Redis、Weaviate、Qdrant等。
4.函数调用和ETL框架 Spring AI允许开发者声明java.util.Function实现，用于OpenAI模型的提示响应中。这一特性最小化了不必要的代码，并使AI模型能够请求更多信息以完成其响应。此外，框架还包括一个基于Java函数编程概念的ETL框架，帮助开发者将文档传输到模型提供商使用的向量存储中。
5.丰富的参考文档和示例应用 Spring AI配备了详尽的参考文档、示例应用程序和研讨会/课程材料，确保开发者拥有开始使用和充分利用框架所需的所有资源。
6.Spring AI的未来 Spring AI的未来版本将在当前基础上构建，计划提供对更多AI模型的访问，例如Google刚刚发布的Gemini多模态模型。框架还将引入评估AI应用程序效果的工具，更多的便利API和功能，以帮助解决查询/总结文档等常见用例。
7.Spring AI的使用 要开始使用Spring AI，只需几个简单的步骤：
安装Spring CLI。在shell中运行以下命令创建一个新应用程序：
spring boot new --from ai --name myai这将创建一个用于与ChatGPT进行基本交互的应用程序。按照生成的README文件中的说明获取您的API密钥。使用以下命令运行应用程序：
./mvw spring-boot:run使用curl测试端点：
curl localhost:8080/ai/simple 二、Ollama：本地运行大型语言模型的轻量级框架 Ollama是一个开源项目，旨在为用户提供一个简单、可扩展的框架，以便在本地机器上快速启动和运行大型语言模型。无论是研究人员、开发者还是对人工智能感兴趣的爱好者，Ollama都提供了一个便捷的途径来探索和利用最新的语言模型技术。
1.核心特性 多平台支持：Ollama支持macOS、Windows预览版和Linux操作系统，确保了广泛的用户基础能够使用该框架。Docker镜像：通过官方的Docker镜像ollama/ollama，用户可以轻松地在容器化环境中部署Ollama。丰富的模型库：项目支持包括Llama 2、Mistral、Gemma在内的多种大型语言模型，用户可以根据需要选择合适的模型。易于安装：Ollama提供了详细的安装指南，无论是通过下载压缩包还是使用命令行工具，用户都能轻松完成安装过程。模型自定义：用户可以通过创建Modelfile来导入GGUF模型，或者从PyTorch和Safetensors导入模型，实现模型的个性化定制。命令行界面（CLI）：Ollama提供了一系列的CLI命令，简化了模型的创建、管理和运行过程。REST API：通过REST API，用户可以编程方式运行和管理模型，为自动化和集成提供了便利。社区集成：Ollama与多个社区项目集成，包括Web和桌面应用程序、终端工具、数据库、包管理器和移动应用等，扩展了其应用范围。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84e6cdf18810a30f812f26ee800741d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e49b8a1964543cb0e4a6e00c871ab1aa/" rel="bookmark">
			zookeeper快速入门一：zookeeper安装与启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是zookeeper系列之快速入门中的第一篇，欢迎大家观看与指出不足。
写在前面：
不影响教程，笔者安装zookeeper用的是WSL(windows下的linux子系统），当然你想直接在windows上用zookeeper也是可以的。
如果你也想用wsl，可以参考这篇文章Windows10安装Linux系统(WSL)
目录
一、zookeeper下载
二、安装zookeeper
三、linux下启动zookeeper
四、windows下启动zookeeper
进入正题：
一、zookeeper下载 镜像站下载：http://mirrors.hust.edu.cn/apache/zookeeper/
记住选择带bin的。从版本3.5.5开始，带有bin名称的包才是我们想要的下载可以直接使用的里面有编译后的二进制的包，而之前的普通的tar.gz的包里面是只是源码的包无法直接使用。不然会爆：
错误: 找不到或无法加载主类 org.apache.zookeeper.server.quorum.QuorumPeerMain
下载后解压到自己的电脑位置，比如：D:\apache-zookeeper-3.5.8-bin
若用wsl，请将apache-zookeeper-3.5.8-bin.tar.gz拷贝到wsl下面后再解压，可以参考WSL访问windows下的文件
解压后目录结构：
bin目录
zk的可执行脚本目录，包括zk服务进程，zk客户端，等脚本。其中，.sh是Linux环境下的脚本，.cmd是Windows环境下的脚本。conf目录
配置文件目录。zoo_sample.cfg为样例配置文件，需要修改为自己的名称，一般为zoo.cfg。log4j.properties为日志配置文件。lib
zk依赖的包。contrib目录
一些用于操作zk的工具包。recipes目录
zk某些用法的代码示例 二、安装zookeeper ZooKeeper的安装包括单机模式安装，以及集群模式安装。
开发情况下由于资源有限一般用单机模式，我们先讲单机模式，让zookeeper跑起来。后面实践案例再讲集群模式。
在启动zookeeper之前，我们需要先修改zookeeper的配置信息，我们先进入zookeeper-3.5.8-bin/conf目录，修改zoo_sample.cfg文件为：
# The number of milliseconds of each tick
tickTime=2000
# The number of ticks that the initial
# synchronization phase can take
initLimit=10
# The number of ticks that can pass between
# sending a request and getting an acknowledgement
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e49b8a1964543cb0e4a6e00c871ab1aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f72f25f2335345290852a90c20133fd/" rel="bookmark">
			Java程序员的AI框架，它来了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要： 在本文中，我们将探索Spring AI——一个为Java开发者社区设计的革命性的人工智能框架。了解其核心功能、如何集成到现有的Spring应用中，以及它如何简化AI项目的开发。
前言： 在当今这个由数据和智能驱动的时代，人工智能（AI）已经成为推动业务创新和优化用户体验的关键力量。从个性化推荐系统到自然语言处理，AI技术正在以前所未有的速度渗透到我们生活的每一个角落。然而，尽管AI的承诺如此诱人，对于许多Java开发者来说，将AI集成到现有的应用和服务中仍然是一项挑战。这是因为大多数AI框架和工具往往要求开发者具备专门的知识，或者需要在使用不同的技术栈之间进行昂贵的转换。
Java一直是企业级应用开发的主力军，以其成熟的生态系统、强大的性能和跨平台的能力而受到广泛赞誉。但是，当涉及到AI时，Java社区似乎缺乏一个既能与Spring等现有框架无缝集成，又能为开发者提供易于上手的AI解决方案的平台。
那么，对于Java开发者来说，有没有一个易于上手且功能强大的AI框架呢？答案是肯定的。随着Spring AI的推出，Java开发者现在有了一个专为他们量身打造的AI框架。Spring AI不仅承诺将AI的力量带到Java开发者的指尖，而且还保证与Java开发者已经熟悉的Spring生态系统无缝集成。这无疑是Java和AI领域的一大进步。
在本文中，我们将深入探讨Spring AI，了解它如何为Java开发者提供一个平滑的AI集成路径，以及它如何帮助开发者快速构建和部署智能应用。无论您是AI新手还是有经验的开发者，Spring AI都旨在使您能够轻松地将AI的强大功能集成到您的Java应用中，从而开启新一代智能应用的篇章。
入门示例： 话不多说，先看示例：
@RestController @RequestMapping("/chat") public class SimpleAiController { private final ChatClient chatClient; @Autowired public SimpleAiController(ChatClient chatClient) { this.chatClient = chatClient; } @GetMapping("/ai/simple") public Map&lt;String, String&gt; completion(@RequestParam(value = "message", defaultValue = "Tell me a joke") String message) { return Map.of("generation", chatClient.call(message)); } } 调用Restful接口：
&gt;curl localhost:8080/ai/simple {"generation":"Why couldn't the bicycle stand up by itself? Because it was two tired!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f72f25f2335345290852a90c20133fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08bfb1df0179d4603900709fbedf989d/" rel="bookmark">
			【java数据结构】HashMap和HashSet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.认识哈希表：
1.1什么是哈希表？
1.2哈希表的表示： 1.3常见哈希函数：
二.认识HashMap和HashSet:
2.1关于Map.Entry的说明:,&gt;
2.2Map常用方法说明：
2.3HashMap的使用案例：
2.4Set常见方法说明：
2.5HashSet使用案例：
源码：
一.认识哈希表： 1.1什么是哈希表？ 之前的学习中，如果我们要查找一个元素，肯定是要经过比较的，那有没有一种办法，可以不用经过比较，直接就能拿到呢？
如果我们能构造一种存储结构，通过一种函数 (hashFunc) 使元素的存储位置与函数得出的关键码之间能够建立一一映射的关系，那么在查找某个元素的时候，就能通过这个函数来很快的找到该元素所在的位置。
🐻🐻🐻这种函数就叫做哈希(散列)函数，上述所说构造出来的结构，叫做哈希表或者称为散列表。
哈希表简介：
哈希表（Hash Table）：也叫做散列表。是根据关键码值（Key Value）直接进行访问的数据结构。哈希表通过「键 key 」和「映射函数 Hash(key) 」计算出对应的「值 value」，把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做「哈希函数（散列函数）」，存放记录的数组叫做「哈希表（散列表）」。
1.2哈希表的表示： 举个栗子：为了记录一个班的学生的信息，分别包括学号和姓名。我们就可以用哈希表（数组加链表）来记录，这里学号(关键值key)通过哈希函数得到一个数组下标，这个下标就是这个学生信息存放在对应数组中的位置，同时学生的信息（姓名和学号）叫做键值对，又称作Entry
使用方法：
🦉🦉🦉向哈希表中插入一个关键码值：哈希函数决定该关键字的对应值应该存放到表中的哪个区块，并将对应值存放到该区块中。🦉🦉🦉在哈希表中搜索一个关键码值：使用相同的哈希函数从哈希表中查找对应的区块，并在特定的区块搜索该关键字对应的值。🦉🦉🦉实现哈希表： 数组+链表 或者 数组+二叉树 1.3常见哈希函数： 🐞直接定值法--（常用）：取关键字的某个线性函数为散列地址：Hash（Key）= A*Key + B 优点：简单、均匀 缺点：需要事先知道关 键字的分布情况 使用场景：适合查找比较小且连续的情况. 🐞除留余数法--(常用) ： 设散列表中允许的 地址数为 m ，取一个不大于 m ，但最接近或者等于 m 的质数 p 作为除数，按照哈希函数： Hash(key) = key% p(p&lt;=m), 将关键码转换成哈希地址 例如： 二.认识HashMap和HashSet: HashMap和HashSet是Java集合框架中的两个常用类，它们都实现了Set接口，但在实现原理和用途上有一些区别。
HashMap:HashMap是基于哈希表的实现，它使用键值对（key-value）的方式存储数据。HashMap允许存储null键和null值，并且可以存储重复的值，但不允许重复的键。HashMap内部使用哈希函数将键映射到哈希表的索引位置，以实现快速的插入、删除和查找操作。HashMap的查找操作是通过键来进行的，因此可以根据键快速地获取对应的值。HashSet:HashSet也是基于哈希表的实现，它存储唯一的元素，不允许重复值。HashSet允许存储null值，但只能存储一个null元素。HashSet内部使用哈希函数将元素映射到哈希表的索引位置，以实现快速的插入、删除和查找操作。HashSet的查找操作是通过元素来进行的，因此可以根据元素快速地判断是否存在于集合中。 2.1关于Map.Entry&lt;K, V&gt;的说明: 🧐🧐🧐Map.Entry&lt;K, V&gt; 是 Map 内部实现的用来存放 &lt;key, value&gt; 键值对映射关系的内部类 ，该内部类中主要提供了 &lt;key, value&gt;的获取， value 的设置以及 Key 的比较方式。 方法解释 K getKey () 返回 entry 中的 key V getValue () 返回 entry 中的 value V setValue(V value) 将键值对中的 value 替换为指定 value 注意： Map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08bfb1df0179d4603900709fbedf989d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe0be4b080eb6aae96b62eb4dedc6c90/" rel="bookmark">
			Mac版Jmeter安装与使用&amp;模拟分布式环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mac版Jmeter安装与使用&amp;模拟分布式环境 1 安装Jmeter 1.1 安装Java环境 国内镜像地址：https://repo.huaweicloud.com/java/jdk/11.0.2+9/jdk-11.0.2_osx-x64_bin.dmg
下载dmg后，双击进行安装。
配置环境变量：
# 1 打开环境变量配置文件 open ~/.bash_profile # 2 在最后一行插入 export JAVA_11_HOME=`/usr/libexec/java_home -v 11` export JAVA_HOME=$JAVA_11_HOME alias jdk11="export JAVA_HOME=$JAVA_11_HOME" # 3 刷新配置文件 source ~/.bash_profile # 4 查看配置是否生效 java -version 1.2 下载安装Jmeter ①官网下载安装包：https://jmeter.apache.org/download_jmeter.cgi
②下载完成后，直接解压
bin：Jmeter可执行文件
docs：包含用户指南等文档。
extras：包含各种使用样例。
lib：该目录包含 Jmeter 所需的 JAR 包（也可以添加其他的 JAR 包）。
printable_docs：里面是一些可打印的文件。
③启动Jmeter
进入bin目录，执行sh jmeter
1.3 插件安装（可选） 插件地址：https://jmeter-plugins.org/wiki/Start/
TPS：Transactions Per Second 也就是事务数/秒QPS：QPS Queries Per Second 是每秒查询率,是一台服务器 每秒能够相应的查询次数，是对一个特定的查询服务器 在规定时间内 所处理流量多少的衡量标准, 即每秒的响应请求数，也即是最大吞吐能力。 Jmeter默认的图表比较简单。大家可根据需要自行安装插件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe0be4b080eb6aae96b62eb4dedc6c90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91c11d47b6bef9835e7ac94ab9fde36f/" rel="bookmark">
			【保姆级教程】SpringBoot后端项目在Linux服务器中使用宝塔面板进行Docker部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是为初入前端、后端的小伙伴们准备的保姆级教程，也是我在学习中慢慢摸索出的一套基本流程，内容可能会有不正确的地方，欢迎在评论区指正，作者会持续关注错误之处，并完善这份文档。
目录 前言服务器准备1.准备一个云服务器或者本地Linux服务器2.为服务器安装宝塔面板3.在服务器中安装Docker并下载镜像4.安装Redis5.配置数据库6.修改项目文件 开始部署1.创建docker_files文件夹2.上传jar包和创建镜像文件3.创建Docker镜像4.运行Docker容器5.部署完成 重新部署1.删除容器和镜像2.重新上传jar包并运行指令 附录1. 使用特殊的DNS名host.docker.internal2. 使用宿主机的网络3. 端口映射 前言 本文给出的是基于Linux服务器、SpringBoot后端技术栈和Java运行环境的Docker部署方案，这样的部署方案在第一次的配置之后，可以做到非常方便的重新部署，只需要将新的jar包上传到文件夹，并在终端执行四段运行代码即可，相较于传统的Java或Tomcat部署方案，其运行环境相对独立，不会干扰服务器本身的运行环境，并且理论上可以在同一台服务器上部署非常多的后端系统，而不会相互干扰。
服务器准备 1.准备一个云服务器或者本地Linux服务器 这是一些云服务器厂商的官网：腾讯云官网 阿里云官网 华为云官网，各位自行按需选择，并且给服务器安装好Linux系统，建议Linux系统版本选择Centos7.x，对宝塔面板的兼容性更好，如果自己在本地配置Linux服务器，则需要自行配置好各项硬件和软件。
2.为服务器安装宝塔面板 进入宝塔面板官网，按照其中的教程给服务器安装宝塔面板，建议使用在线安装，输入服务器的IP、账号和密码，直接一键安装，安装时建议勾选安装MySQL和Nginx，其余的可以自行选择安装与否。安装好宝塔面板后，需要确认各端口是否已开启，例如宝塔面板的默认端口、MySQL的默认端口等，并且别忘了把要部署的后端接口也打开，如果没有开启，需要先在服务器的控制台中开启，再在宝塔面板的安全中开启，也就是说服务器本身有一道防火墙，宝塔面板也提供了一道防火墙，两道防火墙都开启，才可以正常访问对应的服务。
3.在服务器中安装Docker并下载镜像 在宝塔面板中点击Docker菜单，如果没有安装过Docker，则会显示安装提示，可以直接点击一键安装（比较省心），也可以在Docker官网中使用脚本方法进行安装（更复杂）。Docker安装完成之后，点开Docker菜单可以看到类似下面这样的页面：
在镜像页面中，点击搜索镜像，输入java8，点击搜索，选择图中框选的镜像进行拉取，这个镜像是用来构建必要的Java环境。
4.安装Redis 由于RuoYi后端系统需要使用Redis，所以需要在软件商店菜单中搜索下载Redis，一般选择最新版本直接安装即可。安装好后的页面类似下面这样：
5.配置数据库 首先，配置MySQL数据库，点击数据库菜单，在MySQL面板中点击添加数据库，按照要求创建好数据库，再点击权限，将权限修改为所有人。之后使用数据库管理软件，例如Navicat等，分别运行RuoYi源代码中的sql文件夹下的两个数据库文件，向数据库中添加RuoYi系统运行时需要的表。
注意，这一步会增加服务器被攻击的风险，但是这样是为了在使用Docker部署RuoYi后端时，Docker中的后端系统可以正常访问到MySQL数据库，如果不这样设置，由于Docker类似于虚拟机，是独立运行在服务器中的，二者的网络环境是不直接相通的，Docker内的SpringBoot项目无法直接连接到宿主机上运行的MySQL数据库，最终导致项目无法启动。
虽然可以使用其他方式将Docker的网络环境直接与宿主机相通，但是这样会导致Docker的可移植性变差，且仍然会带来安全风险。
具体其他配置方式，可以在附录中参考由GPT4生成的其他方式。
接下来，配置Redis，点击软件商店，在Redis一行点击设置，在配置文件面板中对Redis配置进行修改，首先将第69行的bind 127.0.0.1改为：bind 0.0.0.0，之后将第508行的requirepass后面的单词删掉，改为自己的密码，一定要设置的复杂一些。
注意，这里同样会带来安全风险，这一步操作和MySQL一样，将Redis暴露在公网上了，但是不这样做，Docker中的项目就无法使用宿主机的Redis，所以密码一定要设置的足够复杂，尽量减少服务器被攻击的风险。
6.修改项目文件 由于要部署的项目为RuoYi后端系统，使用了MySQL和Redis，必须还要对后端程序做修改，修改Redis的连接地址和MySQL数据库的连接地址，找到ruoyi-admin\src\main\resources\application.yml这个文件，修改其中的Redis地址和密码：
# redis 配置 redis: # Redis地址 host: 服务器IP地址 # 端口，默认为6379 port: 6379 # 密码 password: 刚刚设置的密码 找到ruoyi-admin\src\main\resources\application-druid.yml这个文件，修改其中的MySQL地址和密码
# 主库数据源 master: url: 服务器数据库地址 username: 用户名 password: 密码 即便Redis、MySQL、RuoYi都运行在同一个服务器中，也不能使用localhost，而是完整写出服务器的地址，这样才可以让容器中运行的RuoYi连接到容器外的Redis和MySQL，原因请看第5点的提示。
开始部署 1.创建docker_files文件夹 在部署后端时，因为部署思路是以Java镜像为底，制作一个SpringBoot项目镜像，也就是Docker容器中运行Java，Java中运行jar包，所以首先在根目录中创建一个docker_files文件夹，用于放置jar包和镜像创建文件：
2.上传jar包和创建镜像文件 文件夹中上传打包好的jar包，即图中的ruoyi-admin.jar：
创建一个txt文件，文件中粘贴如下代码：
FROM openwhisk/java8action MAINTAINER psr &lt;13404802234@163.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91c11d47b6bef9835e7ac94ab9fde36f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eead160d11941d87ebcd32aea6108899/" rel="bookmark">
			SpringBoot的 ResponseEntity类讲解(具体讲解返回给前端的一些事情)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述：ResponseEntity是Spring框架中的一个类，用于封装HTTP响应的相关信息，包括状态码、响应头和响应体。它通常用于控制器方法中返回一个包含特定数据的HTTP响应。
ResponseEntity ResponseEntity类的主要特点如下：
可以自定义HTTP状态码：通过设置HttpStatus枚举值，可以指定不同的HTTP状态码，如200（OK）、404（Not Found）等。
可以设置响应头信息：可以通过headers()方法设置响应头信息，例如设置内容类型（Content-Type）或缓存控制（Cache-Control）等。
可以携带响应体数据：可以通过构造函数或body()方法设置响应体数据，支持各种数据类型，如字符串、对象、集合等。
比如说，想把图片从minio里面读取并反馈给前端
IOUtils用的是common那个包
@GetMapping("/user01/singer/img/{fileName:.+}") public ResponseEntity&lt;byte[]&gt; getImage(@PathVariable String fileName) throws Exception { InputStream stream = minioClient.getObject( GetObjectArgs.builder() .bucket(bucketName) .object("singer/img/"+fileName) .build() ); byte[] bytes = IOUtils.toByteArray(stream); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.IMAGE_JPEG); // 设置响应内容类型为图片类型，根据实际情况修改 return new ResponseEntity&lt;&gt;(bytes, headers, HttpStatus.OK); } 当然，人们大多可能会封装一个类，以json的形式返回给前端 这个形式一般包含：
private int code; private String message; private T data data一般是json信息，message一般就是成功，失败之类的，code就是那个码.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ac58e267b5271e6bfda15a98f807976/" rel="bookmark">
			AI赋能写作：AI大模型高效写作一本通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		❤️作者主页：小虚竹
❤️作者简介：大家好,我是小虚竹。2022年度博客之星评选TOP 10🏆，Java领域优质创作者🏆，CSDN博客专家🏆，华为云享专家🏆，掘金年度人气作者🏆，阿里云专家博主🏆，51CTO专家博主🏆
❤️技术活，该赏
❤️点赞 👍 收藏 ⭐再看，养成习惯
老规矩，文末有送书的规则~~
文章目录 零、前言一、AI时代的高效写作之道二、系统讲解AI大模型交互技巧三、凝聚作者丰富内容策划经验四、深入剖析关键场景与实战案例五、ChatGPT引领的创作革新六、提示词与个人品牌价值的塑造七、总结：AI赋能写作，开启高效创作新篇章八、粉丝福利福利0福利1 零、前言 在信息化时代的浪潮中，人工智能已经悄然改变了我们生活的方方面面。而在写作领域，AI大模型的应用更是为我们打开了一扇全新的大门。今天，我要为大家介绍一本关于AI赋能写作的实用指南——《AI赋能写作：AI大模型高效写作一本通》。这本书将带您领略AI大模型的魅力，助您轻松成为写作大师。
一、AI时代的高效写作之道 在这个AI时代，高效写作不再是遥不可及的梦想。本书提出的“AI时代高效写作之道：巧用AI大模型，教你一键搞定有灵魂的高质量文章，让你轻松成为写作大师”的理念，为我们指明了方向。通过掌握AI大模型的交互技巧，我们可以轻松驾驭文字，创作出有灵魂、有深度的作品。
二、系统讲解AI大模型交互技巧 本书的一大卖点在于其系统性。作者细致地讲解了AI大模型交互的9大核心技巧，帮助读者逐章击破使用难点。无论是初学者还是有一定基础的写作者，都能从中找到适合自己的学习路径，快速掌握AI大模型在写作中的应用技巧。
三、凝聚作者丰富内容策划经验 本书的作者凭借10万+的内容策划经验，为我们分享了爆款构思策略。这些宝贵的经验不仅让我们了解到如何创作出受欢迎的作品，更让我们深刻认识到内容创作的核心价值和意义。通过借鉴这些经验，我们可以更加精准地把握读者需求，创作出更具吸引力的文章。
四、深入剖析关键场景与实战案例 本书不仅提供了理论知识，还通过层层剥茧式分析8大关键场景，让我们知其然更知其所以然。同时，书中还剖析了100多个AI大模型交互案例，这些实战案例具有很强的指导意义，让我们能够拿来就用，快速提升自己的写作水平。
五、ChatGPT引领的创作革新 本书以ChatGPT为科技行业带来的颠覆性革新为起点，深入探讨了人工智能大模型如何为我们的创作提供强大支持。通过ChatGPT的帮助，我们可以突破写作瓶颈，建立稳固的创作基础，并掌握高效成稿能力。这种全新的创作方式将为我们带来更加广阔的创作空间和可能性。
六、提示词与个人品牌价值的塑造 本书还深入探讨了提示词在创作过程中的关键节点效应，以及如何利用ChatGPT塑造个人品牌价值。通过巧妙地运用提示词，我们可以更好地引导AI大模型进行创作，让作品更具个性和特色。同时，借助ChatGPT的帮助，我们可以提升自己的品牌影响力，为职场发展打下坚实基础。
七、总结：AI赋能写作，开启高效创作新篇章 《AI赋能写作：AI大模型高效写作一本通》不仅为我们提供了关于AI大模型在写作中的应用方法和技巧，更让我们看到了AI技术在创作领域的无限可能。在这个AI时代，让我们借助AI大模型的力量，开启高效创作的新篇章，用文字书写出更加精彩的人生。无论是专业写作者还是业余爱好者，都能从这本书中获益匪浅。
八、粉丝福利 回馈粉丝们的支持，送《AI赋能写作：AI大模型高效写作一本通》实体书给2位粉丝。一起学习！
福利0 虚竹哥直接送2本好书，参与好评送书~
参与好评送书：随机抽取2位幸运读者，各送一本《AI赋能写作：AI大模型高效写作一本通》实体书
统计截止时间：2024/03/18 19:00:00
请中奖的读者统计截止时间过后7天内私信虚竹哥收货地址，过期奖励作废哈！
福利1 购书传送门–》
我是宠粉的虚竹哥，请继续支持我，哈哈哈~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfba5b9cfd03c3046808f313d306ffa3/" rel="bookmark">
			Oracle 面试题及答案整理，最新面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle中的PL/SQL和SQL有什么区别？ PL/SQL和SQL在Oracle中的主要区别包括：
1、编程能力： PL/SQL是一种程序化语言，支持变量、条件语句和循环，而SQL主要用于数据查询和更新。
2、执行方式： PL/SQL可以执行一整块代码，而SQL语句逐条执行。
3、用途： PL/SQL适用于编写复杂的数据库应用程序，SQL用于简单的数据操作和查询。
Oracle数据库中的表分区是什么？它的优势在哪里？ 表分区是Oracle数据库中一种将表和索引分解为更小、更易管理的部分的技术。其优势包括：
1、性能提升： 可以提高查询性能，特别是对于大型表。
2、可管理性： 分区表更容易管理和维护。
3、高可用性： 分区有助于提高数据的可用性和恢复性能。
Oracle中的索引组织表和堆组织表的区别。 索引组织表（IOT）和堆组织表在Oracle中的区别主要包括：
1、存储结构： IOT是基于索引的表结构，数据按主键顺序存储；堆组织表则是数据在物理存储上无特定顺序。
2、性能： IOT在某些查询上性能更好，特别是主键查找。
3、使用场景： IOT适用于主键访问模式频繁的场景，而堆组织表适用于更广泛的场景。
Oracle数据库中的序列是什么？它的用途有哪些？ 序列（Sequence）在Oracle中是一个数据库对象，用于生成唯一的数值。用途包括：
1、生成唯一标识符： 用于自动生成唯一的行标识符。
2、自动编号： 在插入记录时自动产生编号。
Oracle中的触发器是什么？它有哪些类型？ 触发器是Oracle数据库中的一个特殊类型的存储过程，它在特定数据库操作发生时自动执行。类型包括：
1、行级触发器： 在修改某一行时触发。
2、语句级触发器： 在执行特定SQL语句时触发。
3、BEFORE和AFTER触发器： 分别在操作执行前后触发。
Oracle数据库的逻辑存储结构包括哪些部分？ Oracle数据库的逻辑存储结构主要包括：
1、数据块： 最小的存储单位。
2、段： 一组具有特定用途的数据块，如表段和索引段。
3、区（Extent）： 由连续数据块组成，用于存储特定的段。
4、表空间： 数据库中数据的最高逻辑级别，由一个或多个数据文件组成。
Oracle中的MVC（多版本并发控制）机制。 Oracle中的MVCC机制用于实现高效的并发控制，其核心原理包括：
1、数据版本化： 对每个事务提供数据的一个快照版本，以支持同时读取和写入操作。
2、非阻塞性读取： 读取操作不会阻塞写入操作，反之亦然。
3、隔离级别： 支持不同的事务隔离级别，确保数据一致性和并发性。
Oracle中的Explain Plan命令是用来做什么的？ Explain Plan命令在Oracle中用于显示SQL语句的执行计划。它的主要作用包括：
1、查询优化： 帮助开发者理解和优化SQL查询性能。
2、分析执行路径： 显示数据库如何执行特定的SQL查询，包括使用的索引和连接方法。
Oracle中，什么是V$视图和DBA_视图？ V$视图和DBA_视图在Oracle中用于提供数据库的动态和静态信息：
1、V$视图： 提供数据库的动态性能和统计信息，如V$SESSION和V$SQL。
2、DBA_视图： 提供数据库的全局静态信息，如DBA_TABLES和DBA_USERS。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfba5b9cfd03c3046808f313d306ffa3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/624ec0e836408795533a6d55ced4e1fc/" rel="bookmark">
			SignalR介绍以及C#使用SignalR实操
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SignalR简介 SignalR是一个开源的库，跨平台；让Web应用与其他应用通讯变得很简单，Web服务端可以实时的将内容推送给对应的客户端，客户端发送的信息也可以实时到其他客户端。
SignalR提供了一种远程过程调用(RPC)的方式，使得客户端可以调用服务器的方法，同样在服务器端的方法中也能调用客户端的方法。
SignalR的通信方式 SignalR支持如下的方式实现实时通信：
WebSockets：是一种在单个TCP连接上进行全双工通信的协议，使得服务器和浏览器的通信更加简单，服务端可以主动发送信息。Server-Sent Events：SSE 与 WebSocket 作用相似，都是建立浏览器与服务器之间的通信渠道，然后服务器向浏览器推送信息。WebSocket是双向的，而SSE是单向的。Long Polling(长轮询)：和传统的轮询原理一样，只是服务端不会每次都返回响应信息，只有有数据或超时了才会返回，从而减少了请求次数。 SignalR会依照下列顺序来判定使用那种传输方式，当然也可以手动指定：
1.如果浏览器是 Internet Explorer8 或更早版本，则使用长轮询。2.如果配置了 JSONP（即连接启动时 jsonp 参数设置为 true），则使用长轮询。3.如果要建立跨域连接（即 SignalR 终结点和宿主页不在相同的域中），并且满足以下条件，则会使用 WebSocket： 3.1客户端支持 CORS（跨域资源共享）3.2客户端支持 WebSocket3.3服务器支持 WebSocket如果这些条件中的任何一条不满足，将使用长轮询.4.如果未配置 JSONP 并且连接没有跨域，只要客户端和服务器都支持的话，将使用 WebSocket。5.如果客户端或服务器不支持 WebSocket，则尽量使用服务器发送事件。Forever Frame。7.如果 Forever Frame 失败，则使用长轮询。 案例演示 SignalR采用名为中心的处理方法去处理服务器和客户端之间的数据传输
Hub 是一种高级管道，允许客户端和服务器相互调用方法。 SignalR 自动处理跨计算机边界的调度，并允许客户端调用服务器上的方法，反之亦然。可以将强类型参数传递给方法，从而支持模型绑定。 SignalR 提供两种内置中心协议：基于 JSON 的文本协议和基于MessagePack的二进制协议。 与 JSON 相比，MessagePack 通常会创建更小的消息。 旧版浏览器必须支持XHR 级别 2才能提供 MessagePack 协议支持。
中心通过发送包含客户端方法的名称和参数的消息来调用客户端代码。 作为方法参数发送的对象使用配置的协议进行反序列化。 客户端尝试将名称与客户端代码中的方法匹配。 当客户端找到匹配项时，它会调用该方法并将反序列化的参数数据传递给它。
服务器触发所有连接的客户端上定义的相对应的接收数据的方法客户端需要发送消息给其他客户端时，调用服务器中心上的方法，让服务器去触发所有的客户端执行对应的方法 创建一个ASP.NET Core Web项目 1.ASP.NET Core项目下已经默认安装了包Microsoft.AspNetCore.SignalR
2.配置 SignalR，配置Program.cs下的文件配置，新增SignalR的依赖注入和配置终结点
using Microsoft.AspNetCore.Cors.Infrastructure; using SignalRChat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/624ec0e836408795533a6d55ced4e1fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dfd05b00fe798d488adbfadbc926a8d/" rel="bookmark">
			最详细数据仓库项目实现：从0到1的电商数仓建设（数仓部分）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、数仓 数据仓库是一个为数据分析而设计的企业级数据管理系统，它是一个系统，不是一个框架。可以独立运行的，不需要你参与，只要运行起来就可以自己运行。
数据仓库不是为了存储（但是能存），而是为了统计分析
数据仓库可集中、整合多个信息源的大量数据，借助数据仓库的分析能力，企业可从数据中获得宝贵的信息进而改进决策。
1、核心架构 其中维度层，就是用不同的角度去研究需求任务，也可以用同一个维度或角度研究不同需求，比如研究不同性别下登录量的区别，或者是和订单喜好的关系
另外这个数据仓库系统其实就是涉及不同的层，每一层会有一些表，这样避免之后会重复工作，直接用之前可能处理好的表，所以数仓的任务其实不是说就写一个sql任务，出一个结果，是写一系列的sql得出一系列中间过程的表，然后去处理任务需求，最后得到结果
但是，需要注意的是，不同公司的数仓会有不同的层数，但是基本都有上述的几层
2、建模方法论 // 主要见第四个数据仓库系统讲义的第2-6页 1）ER模型 （1）实体关系模型 实体关系模型将复杂的数据抽象为两个概念——实体和关系。实体表示一个对象，例如学生、班级，关系是指两个实体之间的关系，例如学生和班级之间的从属关系。
这个是说的比如一对多、多对一、一对一、多对多关系
其中强调一下一对一关系
（2） 数据库规范化 使用一系列范式设计数据库（通常是关系型数据库）的过程，其目的是减少数据冗余，增强数据的一致性。
这一系列范式就是指在设计关系型数据库时，需要遵从的不同的规范。关系型数据库的范式一共有六种，分别是第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF）。
遵循的范式级别越高，数据冗余性就越低。（也不能冗余性太低，太低的话性能也低，因为有时候重复性工作，就是前部分工作可能需要一些重复的表，这个工作用到了这个中间表，另外的工作也用到了这个中间表，所以还是需要一定的冗余性的）
基本上达到三范式即可
1、函数依赖 举几个例子
2、范式 第一范式：属性不可切割。【属性划分到最小，划分到不能再分割的地步】第二范式：不能存在部分函数依赖第三范式：不能存在传递函数依赖 3、分析优缺点（ER模型不适合用于数据仓库的建模和分析） 较为松散、零碎，物理表数量多。
这种建模方法的出发点是整合数据，其目的是将整个企业的数据进行组合和合并，并进行规范处理，减少数据冗余性，保证数据的一致性。这种模型并不适合直接用于分析统计。
2）维度模型 维度：分析数据的角度、一个角度一个表、还包括用于统计的数据，汇总起来就是一个表
维度模型将复杂的业务通过事实和维度两个概念进行呈现。事实通常对应业务过程，而维度通常对应业务过程发生时所处的环境。
​ eg：站在省份的角度研究订单销量、站在性别的角度研究订单销量
3、环境搭建 1）运行环境 Hive环境搭建：
​ Hive on Spark：Hive既作为存储元数据又负责SQL的解析优化，语法是HQL语法，执行引擎变成了Spark，Spark负责采用RDD执行。
​ Spark on Hive : Hive只作为存储元数据，Spark负责SQL解析优化，语法是Spark SQL语法，Spark负责采用RDD执行。
1. Hive on Spark =&gt; Hive解析SQL =&gt; Spark RDD =&gt; Jar =&gt; Yarn 2. Spark on Hive =&gt; （SparkSQL）Spark解析SQL =&gt; Spark RDD =&gt; Jar =&gt; Yarn //这是在Spark解析SQL后会有一些表，会存放在hive中，所以hive也可以当数据源 我们这里用的是Hive on Spark
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dfd05b00fe798d488adbfadbc926a8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7395c9d277cecc314318501a24f334e7/" rel="bookmark">
			Python lambda（匿名函数），一文详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面的文章里，我们讲了什么是函数（CSDN函数详解），并且简单讲了一下什么是lambda（匿名函数）。
现在我们详细讲讲什么是 lambda 函数？lambda 函数的特点已经lambda 函数的应用。也算是完善之前的内容。
1. 为什么要用lambda Lambda函数是一种匿名函数，也称为内联函数或者函数字面量。通常用于那些简单的、一次性的函数，这样可以避免定义一个完整的函数。例如，如果你只是想对一个列表的每个元素进行平方操作，你可以使用Lambda函数，而不需要定义一个单独的函数。既然Lambda作为函数，当然允许你将函数作为参数传递给其他函数，这样你就可以在需要的时候创建简单的、匿名的函数。
下面是Lambda函数的优点和限制的总结：
优点描述简洁性Lambda函数通常用于简单、一次性操作，使代码更简洁。匿名性Lambda函数是匿名的，适合作为参数传递给其他函数。功能性编程Lambda函数是函数式编程的强大工具，可进行函数组合、映射、过滤等操作。节省内存Lambda函数避免为一次性使用的简单函数占用额外空间，节省内存。 限制描述只能有一个表达式Lambda函数的主体只能是单个表达式，不能包含多个语句或复杂逻辑。可读性Lambda函数通常用于简单操作，复杂逻辑会降低代码可读性，不适合复杂函数。不支持类型注解Lambda函数不支持像普通函数那样的类型注解，可能降低代码的可维护性。 总之，Lambda函数为编程提供了一种灵活、简洁的方式来定义和使用函数，让对那些一次性的操作，更加得心应手。
2. Lambda函数的语法 Lambda函数的一般语法很简单，lambda关键字定义，后面跟着参数列表和一个表达式。
lambda arguments: expression 其中：
lambda是定义Lambda函数的关键字。arguments是Lambda函数的参数列表，可以有零个或多个参数，多个参数之间用逗号分隔。expression是Lambda函数的表达式，即函数的具体实现逻辑。 简单的用法：
# 定义一个简单的Lambda函数，对传入的参数求平方 square = lambda x: x * x # 调用Lambda函数 result = square(5) print(result) # 输出: 25 上面的内容就是计算一个平方运算，直接返回结果。一定要记住，表达式的结果一定是“运算后返回的”。
比如说：
str = lambda: "Hello, world!" print(str()) # 输出: Hello, world! 这里的运算就是简单的返回结果。
特别提醒：我们前面说过，函数变量加了括号就是执行函数，不加就是变量。不理解的可以看前面的文章。 3. Lambda函数与普通函数的区别 Lambda函数和传统的普通函数在定义和使用上有些许不同。
特性Lambda函数普通函数定义方式使用lambda关键字定义，语法简洁使用def关键字定义名称匿名，没有函数名有明确的函数名参数数量可以有零个或多个参数，但表达式中只能有一个表达式可以有零个或多个参数，函数体内可以有多个语句 4. Lambda函数的用法 4.1 作为参数传递给其他函数 Lambda函数常用于将简单的逻辑作为参数传递给高阶函数，如map()、filter()等。
# 使用Lambda函数和map()函数将列表中的每个元素都平方 numbers = [1, 2, 3, 4, 5] squared = list(map(lambda x: x * x, numbers)) print(squared) # 输出: [1, 4, 9, 16, 25] # 使用Lambda函数和filter()函数筛选出列表中的偶数 even_numbers = list(filter(lambda x: x % 2 == 0, numbers)) print(even_numbers) # 输出: [2, 4] 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7395c9d277cecc314318501a24f334e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db5234718b31c62a5232ed876039633c/" rel="bookmark">
			【数据结构】二叉树OJ题（C语言实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅
✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨
🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿
🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟
🌟🌟 追风赶月莫停留 🌟🌟
🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀🍀
🌟🌟 平芜尽处是春山🌟🌟
🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟🌟
🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿🌿
✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨
✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅
📝数据结构OJ题 ✏️单值二叉树✏️相同的树✏️二叉树前序遍历✏️二叉树中序遍历✏️二叉树后序遍历 ✏️单值二叉树 class Solution { public: bool isUnivalTree(TreeNode* root) { if (root == NULL) return true ; if (root-&gt;left != NULL &amp;&amp; root-&gt;val != root-&gt;left-&gt;val) return false ; if (root-&gt;right != NULL &amp;&amp; root-&gt;val != root-&gt;right-&gt;val) return false ; return isUnivalTree(root-&gt;left) &amp;&amp; isUnivalTree(root-&gt;right) ; } }; 本题写法中，我们主要利用递归的思想和等号的性质从反向入手，也就是说只要有不相等就返回false。
上面说的等号的性质就是a=b,b=c那么a就一定等于c了。
如果从正向入手就有点麻烦，你判断了他们相等还要一个个的递归。大家可以去试一试。
当然还有一个最终要的条件判断，比较是在左子树和右子树都存在的情况下，如果不存在就不用比较，所以我在比较前都加了一个判断，判断root-&gt;left和root-&gt;right都存在，才去比较。
✏️相同的树 class Solution { public: bool isSameTree(TreeNode* p, TreeNode* q) { //两个都为空 if (p == NULL &amp;&amp; q == NULL) return true ; //其中一个为空 if (p == NULL || q == NULL) return false ; if (p-&gt;val !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db5234718b31c62a5232ed876039633c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57d4c13ae79e3ce349fbcf265fd9e52a/" rel="bookmark">
			使用pdfjs报错：Failed to load module script: Expected a JavaScript module script but the server responded
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 错误原因 MIME 类型设置不正确： 服务器返回的文件 MIME 类型不正确。浏览器期望模块脚本的 MIME 类型为 application/javascript。如果服务器返回的 MIME 类型不是这个，浏览器会拒绝加载它，并显示这个错误
解决办法 nginx 在nginx的默认mime.types文件中没有为mjs扩展名设置条目，这意味着它将被作为application/octet-stream而不是application/javascript进行服务。可以通过在服务器、http或location块中显式包含mime.types并添加一个types块来设置mjs文件的MIME类型和文件扩展名：
server { include mime.types; types { application/javascript mjs; } ... } 当然，也可以直接修改mime.types
springboot 配置文件增加下面配置
spring.servlet.mime-mapping.mjs=application/javascript 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/469/">«</a>
	<span class="pagination__item pagination__item--current">470/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/471/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>