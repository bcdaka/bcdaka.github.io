<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bdd5de975fe69a03ff116e9dee1af97/" rel="bookmark">
			LLaMA 入门指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LLaMA 入门指南 LLaMA 入门指南LLaMA的简介LLaMA模型的主要结构Transformer架构多层自注意力层前馈神经网络Layer Normalization和残差连接 LLaMA模型的变体Base版本Large版本Extra-Large版本 LLaMA模型的特点大规模数据训练 LLaMA模型常用数据集介绍公共数据来源已知的数据集案例1. PubMedQA2. MedMCQA3. USMLE4. RedPajama强大的通用性优化的模型结构 如何快速入门LLaMA环境搭建 Hugging Face中Llama模型的快速入门准备工作安装`transformers`库使用Llama模型环境设置模型加载文本生成 LLaMA 入门指南 在近年来，随着人工智能领域的飞速发展，我们见证了深度学习技术的多变和突破，尤其是在自然语言处理（NLP）领域。LLaMA，作为最新的NLP模型之一，引起了广泛的关注。本文意在深入浅出地介绍LLaMA模型的基本概念、架构以及如何快速开始实验。
LLaMA的简介 LLaMA（Large Language Model – Meta AI）是一种由Facebook母公司Meta AI提出的大型语言模型。它是设计用来理解和生成自然语言文本的模型。LLaMA通过大规模数据集训练，可以在多种任务中表现出色，包括文本分类、文本生成、问答等。
LLaMA模型的主要结构 Transformer架构 LLaMA模型是基于Transformer架构构建的，这是一种被广泛使用在大多数现代NLP任务中的模型结构。它依赖于自注意力机制来捕获输入序列不同部分之间的关系。
多层自注意力层 LLaMA模型包括多个自注意力层，每一层都提取输入文本的不同特征。通过这些层的堆叠，模型能够学习到深层的语言表示。
前馈神经网络 除了自注意力层，LLaMA模型还包含前馈神经网络（FFNN），它们负责在每个自注意力层之后处理信息，增强模型的表达力。
Layer Normalization和残差连接 Layer Normalization和残差连接是Transformer架构的重要组成部分，LLaMA模型也在每个自注意力层和FFNN后使用了这些技巧，以稳定训练过程并加速收敛。
LLaMA模型的变体 LLaMA模型具有不同大小的变体，从小型模型到大型模型，它们拥有不同数量的参数，以满足不同计算能力和任务需求。
Base版本 Base版本适合大多数标准计算资源，提供了良好的性能和相对较低的资源需求。
Large版本 Large版本提供了更多的参数，适用于需要更深层次语言理解的复杂任务。
Extra-Large版本 Extra-Large版本是目前LLaMA最大的模型，它具有最高的参数数量，提供了最优秀的性能，但同时需要非常强大的计算资源。
LLaMA模型的特点 大规模数据训练 LLaMA在数十亿级别的数据集上进行训练，能够捕捉语言深层的语义和句法规律。
LLaMA模型常用数据集介绍 LLaMA（Large Language Model Meta AI）是近年来在自然语言处理和机器学习领域引起广泛关注的模型。其背后的数据集是模型训练成功的关键。以下是LLaMA模型训练中可能涉及到的一些常见数据集类型。
公共数据来源 网页内容: 从各大门户网站、论坛和博客等网页上抓取的文本内容。社交媒体: 社交平台上用户生成的文本信息，如推文和状态更新。公开论文与书籍: 科研文献、专业书籍等提供的数据。多语言文本: 多语言版的论坛帖子、新闻报道、维基百科文章等。 已知的数据集案例 基于Google Scholar和其他来源的信息整合，以下列表是LLaMA培训中可能用到的一些具体数据集案例。
1. PubMedQA LLaMA模型可以在医疗专业QA（问题回答）数据集，如PubMedQA上进行微调以提高其在医学领域内容的理解和生成能力。
2. MedMCQA 这是一个医学多选择问答数据集，PMC-LLaMA的微调在包括MedMCQA在内的生物医学QA数据集上进行，以测试其在特定领域的性能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bdd5de975fe69a03ff116e9dee1af97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc6c042226e5550d8dc7d117530b7345/" rel="bookmark">
			SQL拆分字段内容（含分隔符）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 在做数据迁移的过程中，我们希望对表中的某个字段根据分隔符进行拆分，得到多条数据，原代码有点意思，因此记录一下。
我们假设某条数据如下：
IDSTRS1公司名称不能小于四个字，行业类别不能为空，职务/岗位不能为空，公司电话不能小于8位且真是有效 针对这条数据，我们希望将其拆分成为四份或者五份，以便于后续的数据处理（这里是拆成四份，加上原来的那条数据一共是五条）。
希望得到的结果：
STEP1:
IDSTRS1公司名称不能小于四个字，行业类别不能为空，职务/岗位不能为空，公司电话不能小于8位且真是有效S1公司名称不能小于四个字，行业类别不能为空，职务/岗位不能为空，公司电话不能小于8位且真是有效S1公司名称不能小于四个字，行业类别不能为空，职务/岗位不能为空，公司电话不能小于8位且真是有效S1公司名称不能小于四个字，行业类别不能为空，职务/岗位不能为空，公司电话不能小于8位且真是有效S1公司名称不能小于四个字，行业类别不能为空，职务/岗位不能为空，公司电话不能小于8位且真是有效 原作者最后希望得到如下的数据：
STEP2:
IDSTRS1公司名称不能小于四个字，S1行业类别不能为空，S1职务/岗位不能为空，S1公司电话不能小于8位且真是有效 DB2原代码 针对STEP1:
原来的代码：
WITH N (STR,ORI,POS,ID) AS ( (SELECT CONCAT(STR,','), 1, POSSER(CONCAT(STR,','),','), ID FROM TABLE_NAME WHERE ID = 'S1') UNION ALL SELECT STR, POS+1, LOCATE(',',STR,POS+1), STR FROM N WHERE LOCATE(',',STR,POS+1)+1&gt;0) SELECT * FROM N 结果如下：
STRORIPOSID公司名称不能小于四个字，行业类别不能为空，职务/岗位不能为空，公司电话不能小于8位且真是有效122S1公司名称不能小于四个字，行业类别不能为空，职务/岗位不能为空，公司电话不能小于8位且真是有效2339S1公司名称不能小于四个字，行业类别不能为空，职务/岗位不能为空，公司电话不能小于8位且真是有效4057S1公司名称不能小于四个字，行业类别不能为空，职务/岗位不能为空，公司电话不能小于8位且真是有效5889S1公司名称不能小于四个字，行业类别不能为空，职务/岗位不能为空，公司电话不能小于8位且真是有效9090S1 关于代码中涉及到的函数说明 CONCAT() 拼接函数
组合两部分形成一个字符串表达。
（看官方文档，只包括两个参数）
CONCAT官方说明
POSSER() 函数返回查找字符串在被查找字符串中第一次出现的位置。
POSSTR官方文档
官网示例：
Example: Select the RECEIVED column, the SUBJECT column, and the starting position of the string ‘GOOD BEER’ within the NOTE_TEXT column for all rows in the IN_TRAY table that contain that string.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc6c042226e5550d8dc7d117530b7345/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b01a9616db6a390a132ad87d0dee2353/" rel="bookmark">
			linux系统 彻底卸载 安装部署Mysql数据库 详细步骤图文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、卸载MySQL数据库
1、检查mysql服务并关闭服务进程
(1)登录Linux后执行service mysqld status或者service mysql status命令查看MySQL服务状态，根据开机初始化目录下mysql脚本的文件名而定，我这里是mysqld
(2)如果正在运行则执行service mysqld stop或者service mysql stop命令停止MySQL服务，根据开机初始化目录下mysql脚本的文件名而定，我这里是mysqld
2、查找mysql的安装目录并彻底删除
(1)执行find / -name mysql查找跟mysql相关的目录
(2)执行rm -rf ‘目录’删除查找出来的目录
3、删除mysql配置文件
(1)执行rm -rf /etc/my.cnf命令删除/etc/my.cnf文件
(2)执行rm -rf /etc/init.d/mysqld命令删除/etc/init.d/下跟mysql有关的全部文件，一般包括mysql文件或mysqld文件,如果存在mysql文件则执行rm -rf/etc/init.d/mysql命令
4、删除mysql用户及用户组
(1)执行id mysql命令查看MySQL用户及用户组
(2)执行userdel mysql命令删除MySQL用户及用户组
到此mysql卸载完成！
—————————————————————
———————————————————————————————————————————
二、安装MySQL数据库
1、下载mysql安装包
(1)进入mysql官网下载编译好的二进制安装包，在下载页面选择需要的版本(如果进入下载列表后始终只有Windows版本的安装包，可以安装XSkyWalker浏览器进行下载，XSkyWalker下载地址：https://www.jb51.net/softs/192435.html)，如下图所示：
(2)把页面拉到底部，64位系统下载Linux - Generic (glibc 2.5)(x86, 64-bit)，32位系统下载Linux- Generic (glibc 2.5) (x86, 32-bit)
2、上传并解压mysql安装包
将下载的mysql安装包mysql-5.6.16-linux-glibc2.5-x86_64.tar.gz通过ftp工具上传到linux主机上(我这里上传到/usr/local/目录下)。进入安装包所在目录，执行命令：tar -zxvf mysql-5.6.16-linux-glibc2.5-x86_64.tar.gz解压安装包。
3、添加系统mysql用户组及用户
执行命令：groupadd mysql和useradd -r -g mysql mysql
4、安装mysql数据库
(1)执行命令： cd /usr/local进入安装MySQL软件目录
(2)执行命令：mv mysql-5.6.16-linux-glibc2.5-x86_64 mysql重命名解压后的文价夹为mysql
(3)执行命令：cd /usr/local/mysql进入mysql安装目录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b01a9616db6a390a132ad87d0dee2353/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cb6c320deba74f0115b8e378270f738/" rel="bookmark">
			Redis内存使用指南：maxmemory参数详解与配置建议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过redis-cli进入Redis命令行
redis权限认证命令：auth
查看redis内存使用情况的命令：info memory
查看最大内存命令：config get maxmemory
设置最大内存命令：config set maxmemory 也可以通过redis.conf配置文件修改最大内存
说明：
1、redis默认内存：如果不设置最大内存大小或者设置最大内存大小为0，在64位操作系统下不限制内存大小，在32位操作系统下最多使用3GB内存。
2、生产上内存设置：一般推荐redis设置内存为最大物理内存的四分之三。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a4edb6659b29e510c895db1b9e8ad41/" rel="bookmark">
			HiveSQL经典面试题（建议点赞收藏）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
经典面试系列
每科成绩都大于80分的学生信息
连续登录问题
行列转换问题
留存问题：看当天登录后第N天是否登录
TopN问题
累计计算问题
HSQL进阶版
直播间在线最大人数
SQL循环
计算中位数
产生连续数值
经典面试系列 每科成绩都大于80分的学生信息 建表+初始化 --创建表scdn_student_score_test 并且初始化三个学生成绩 create table hdw_tmp_dev.scdn_student_score_test as select '张三' as name,'数学' as subject ,'80' as score union all select '张三' as name,'语文' as subject ,'90' as score union all select '张三' as name,'英语' as subject ,'90' as score union all select '李四' as name,'数学' as subject ,'90' as score union all select '李四' as name,'语文' as subject ,'90' as score union all select '李四' as name,'英语' as subject ,'70' as score union all select '王五' as name,'数学' as subject ,'90' as score union all select '王五' as name,'语文' as subject ,'90' as score union all select '王五' as name,'英语' as subject ,'50' as score --查询结果显示 | scdn_student_score_test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a4edb6659b29e510c895db1b9e8ad41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cfcd540ade1eb71768894f87d653db0/" rel="bookmark">
			深入理解Spark BlockManager：定义、原理与实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深入理解Spark BlockManager：定义、原理与实践
1.定义 Spark是一个开源的大数据处理框架，其主要特点是高性能、易用性以及可扩展性。在Spark中，BlockManager是其核心组件之一，它负责管理内存和磁盘上的数据块，并确保这些数据块在集群中的各个节点上可以高效地共享和访问，其中包括存储、复制、序列化和反序列化数据块，并且负责将这些数据块分发到集群中的各个节点上，以便进行计算。BlockManager还处理数据块的缓存和回收，以及故障恢复和数据迁移等任务。
因为Spark是分布式的计算引擎，因此BlockManager也是一个分布式组件，各个节点（Executor）上都有一个BlockManger实例，管理着当前Executor的数据及元数据进行处理及维护，比如我们常说的block块的增删改的操作，都会在BlockManager上做相应的元素局的变更。而Executor上的BlockManager实例是由Driver端上的BlockManagerMaster统一管理，其关系类似于我们常说的NameNode和DataNode之间的关系。我们知道Spark本身有很多的模块，比如Scheduler调度模块，Standalone资源管理模块等，而BlockManager就是其中非常重要的模块，其源码量也是非常的巨大。总而言之，spark BlockManager是负责Spark上所有的数据的存储与管理的一个极其重要的组件。
2.原理分析 2.1 数据块的管理 在Spark中，每个数据块都有唯一的标识符，称为BlockId。BlockManager通过维护数据块的元数据来管理这些数据块，包括数据块的类型、大小、版本号、所在节点等信息。当一个节点需要访问一个数据块时，它会向BlockManager发送请求，BlockManager根据数据块的标识符和元数据来定位数据块所在的节点，并返回数据块的引用。
sealed abstract class BlockId { // 全局唯一的block的名字 def name: String // convenience methods def asRDDId: Option[RDDBlockId] = if (isRDD) Some(asInstanceOf[RDDBlockId]) else None // 一下判断不同类型的Block，可能是RDD、Shuffle、Broadcast之一 def isRDD: Boolean = isInstanceOf[RDDBlockId] def isShuffle: Boolean = { (isInstanceOf[ShuffleBlockId] || isInstanceOf[ShuffleBlockBatchId] || isInstanceOf[ShuffleDataBlockId] || isInstanceOf[ShuffleIndexBlockId]) } def isShuffleChunk: Boolean = isInstanceOf[ShuffleBlockChunkId] def isBroadcast: Boolean = isInstanceOf[BroadcastBlockId] override def toString: String = name } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cfcd540ade1eb71768894f87d653db0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb561757a7e13f41325881b65ba2e371/" rel="bookmark">
			Java——常用JSON解析库详解（fastjson2、gson、jackson）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 JSON解析1、概述2、fastjson22.1、Maven依赖2.2、API1)、常用API2)、序列化API3)、JSON字符串反序列化API 2.3、简单使用1)、JSON-&gt;JSONObject2)、JSON-&gt;JSONArray3)、JSON-&gt;Java Bean4)、Java Bean-&gt;JSON5)、JSONObject-&gt;Java Bean6)、Java Bean-&gt;JSONObject7)、JSONObject/JSONArray8)、嵌套对象 2.4、进阶使用1)、JSONB2)、JSONPath 2.5、注解1、JSONField定制序列化和反序列化时的属性名配置字段输出和反序列化的格式序列化/反序列化时忽略字段配置字段的序列化输出的的顺序配置序列化Features通过JSONField(value = true)配置JavaBean序列化字段和反序列化构造方式通过JSONField(value = true)配置Enum基于其中一个字段序列化和反序列化 2)、JSONType配置序列化和反序列化时忽略某些字段配置序列化时保持原生类字段顺序配置序列化时的JSONReader/JSONWriter的Features配置序列化时字段顺序 2.6、Features1)、JSONReader.Feature2)、JSONWriter.Feature 3、gson3.1、Maven依赖3.2、基本用法1)、创建Gson实例new Gson()GsonBuilder.build() 2)、Java对象-&gt;JSON3)、JSON-&gt;Java对象4)、美化输出5)、JSONArray -&gt; Java Array/List6)、Null值处理 3.3、注解1)、@Since2)、@SerializedName3)、@Expose 3.4、排除字段3.5、GsonBuilder1)、setPrettyPrinting2)、setFieldNamingPolicy3)、serializeNulls4)、setExclusionStrategies5)、setLenient 3.6、JsonReader1)、概述2)、Tokens3)、创建JsonReader4)、读取JSON流 3.7、JsonParser1)、创建JsonParser2)、转化JSON3)、JsonElement, JsonObject 和JsonArray4)、JsonParser 示例5)、使用fromJson() 获取JsonObject6)、迭代JSON树结构 3.8、自定义序列化1)、JsonSerializer接口2)、自定义序列化示例 3.9、自定义反序列化1)、JsonDeserializer接口2)、自定义反序列化示例 4、jackson4.1、Maven依赖4.2、简单使用1)、ObjectMapper2)、Java Bean-&gt;JSON3)、JSON-&gt;Java Bean4)、JSON-&gt;List/Map5)、字段忽略6)、日期格式化Date类型LocalDateTime类型 4.3、注解1)、序列化注解@JsonAnyGetter@JsonGetter@JsonPropertyOrder@JsonRawValue@JsonValue@JsonRootName@JsonSerialize 2)、反序列化注解@JsonCreator@JacksonInject@JsonAnySetter@JsonSetter@JsonDeserialize@JsonAlias 3)、属性注解@JsonIgnoreProperties@JsonIgnore@JsonIgnoreType@JsonInclude@JsonAutoDetect 4)、常用注解@JsonProperty@JsonFormat@JsonUnwrapped@JsonView@JsonManagedReference、@JsonBackReference@JsonIdentityInfo@JsonFilter 5)、其它注解@JacksonAnnotationsInside 4.4、配置属性 JSON解析 1、概述 JSON(JavaScript Object Notation)是一种轻量级的数据交换格式，相比xml数据交换格式来说，因为解析xml比较的复杂且需要编写大段的代码，所以客户端和服务器的数据交换格式往往通过JSON来进行交换。
JSON简单说就是javascript中的对象和数组，所以这两种结构就是对象和数组两种结构，通过这两种结构可以表示各种复杂的结构。
常用JSON解析库：
fastjson：阿里gson：谷歌jackson：SpringMVC自带 2、fastjson2 2.1、Maven依赖 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;2.0.15&lt;/version&gt; &lt;/dependency&gt; 2.2、API 1)、常用API //把JSON文本parse为JSONObject或者JSONArray public static final Object parse(String text); //把JSON文本parse成JSONObject public static final JSONObject parseObject(String text); //把JSON文本parse为JavaBean public static final &lt;T&gt; T parseObject(String text, Class&lt;T&gt; clazz); //把JSON文本parse成JSONArray public static final JSONArray parseArray(String text); //把JSON文本parse成JavaBean集合 public static final &lt;T&gt; List&lt;T&gt; parseArray(String text, Class&lt;T&gt; clazz); //将JavaBean序列化为JSON文本 public static final String toJSONString(Object object); //将JavaBean序列化为带格式的JSON文本 public static final String toJSONString(Object object, boolean prettyFormat); //将JavaBean转换为JSONObject或者JSONArray。 public static final Object toJSON(Object javaObject); 2)、序列化API package com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb561757a7e13f41325881b65ba2e371/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/768313c79bf7b76756a4e97bf70d015d/" rel="bookmark">
			物流|基于Springboot的物流管理系统设计与实现(源码&#43;数据库&#43;文档)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		物流管理系统目录
目录
基于Springboot的物流管理系统设计与实现
一、前言
二、系统功能设计
三、系统实现
1、管理员和管理员功能实现
（1）用户管理
（2）公告信息管理
（3）物流信息管理
（4）车辆信息管理
2、用户功能实现
（1）物流信息
（2）运单信息添加
（3）运单管理
（4）个人信息
四、数据库设计
1、实体ER图
2、具体的表设计如下所示：
五、核心代码 六、论文参考
七、最新计算机毕设选题推荐
八、源码获取：
博主介绍：✌️大厂码农|毕设布道师，阿里云开发社区乘风者计划专家博主，CSDN平台Java领域优质创作者，专注于大学生项目实战开发、讲解和毕业答疑辅导。✌️
主要项目：小程序、SpringBoot、SSM、Vue、Html、Jsp、Nodejs等设计与开发。
🍅文末获取源码联系🍅
👉 毕设答疑 👈
基于Springboot的物流管理系统设计与实现 一、前言 本次开发一套物流管理系统有管理员和用户两个角色。管理员功能有个人中心，用户管理，车辆信息管理，公告信息管理，司机管理，物流信息管理，运单信息管理，车辆类型管理，车辆状态管理，公告类型管理，物流状态管理，运单状态管理。用户可以注册登录，查看公告信息，查看物流信息，可以添加运单信息。物流管理系统服务端用Java开发，用Spring Boot框架开发的网站后台，数据库用到了MySQL数据库作为数据的存储。这样就让用户用着方便快捷，都通过同一个后台进行业务处理，而后台又可以根据并发量做好部署，用硬件和软件进行协作，满足于数据的交互式处理，让用户的数据存储更安全，得到数据更方便。
关键字：物流管理系统；Spring Boot框架；Java；MySQL
二、系统功能设计 绘制的管理员功能结构见下图。管理员可以管理所有，包含个人中心，用户管理，管理员管理，公告信息管理，咨询信息管理，车辆信息管理，物流信息管理，试题管理，系统管理，考试管理等。
三、系统实现 1、管理员和管理员功能实现 （1）用户管理 管理员可以对用户信息进行添加，修改，删除，查询操作。
图5-1 用户管理页面
（2）公告信息管理 管理员可以对公告信息信息进行添加，修改，删除，查询操作。
图5-2 公告信息管理页面
（3）物流信息管理 管理员可以对物流信息进行添加，修改，删除，查询操作。
图5-3 物流信息管理页面
（4）车辆信息管理 管理员可以对车辆信息进行添加，修改，删除操作。
图5-4 车辆信息管理页面
2、用户功能实现 （1）物流信息 用户登录后可以查看物流信息，可以看到物流信息状态和详情。
图5-5 物流信息页面
（2）运单信息添加 用户可以在运单信息管理里面添加运单信息。
图5-6 运单信息添加页面
（3）运单管理 用户可以对自己发布的运单信息进行添加修改删除查询操作。
图5-7 运单管理页面
（4）个人信息 用户可以在个人信息里面修改自己的资料。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/768313c79bf7b76756a4e97bf70d015d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/707d2523cc73ba7f7714bf2fef81d06d/" rel="bookmark">
			Matlab图像处理——基于小波变换的数字图像水印嵌入和提取算法（GUI界面）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.摘要 数字图像水印技术在信息安全领域中扮演着至关重要的角色，本文结合离散小波变换、Arnold置乱变换和奇异值分解，实现了对数字图像水印的高效嵌入和提取。结果表明：该算法能够准确实现水印的嵌入和提取功能；嵌入的水印具有良好的隐身性，人眼不能感觉出水印嵌入带来的变化；算法具有较强的鲁棒性，经过椒盐噪声、高斯噪声、JPEG压缩、高斯平滑和裁剪操作等污染及攻击后，都能较好地恢复水印信息。
2.研究方法 算法的主要流程包括Arnold置乱变换、二次离散小波变换以及奇异值分解。首先，对数字水印图像进行Arnold置乱变换，引入混沌因子以增强水印的安全性。接着，对原始图像进行二次离散小波变换，以获取更加丰富的频域信息。在接下来的步骤中，分别对置乱后的水印图像和原始图像小波变换的低频部分进行奇异值分解，并对两者的奇异值矩阵进行加性操作，从而实现水印的嵌入过程。
3.实验结果 1. 打开载体图像
首先，用户可以通过点击系统界面上的“打开载体图像”按钮选择一张图像作为载体图像。系统会将选定的图像显示在界面上。
2. 打开原始水印图像
用户同样可以通过点击“打开原始水印图像”按钮选择一张原始水印图像。系统会对该图像进行二值化处理，并在界面上显示。
3. 加密水印图像
在载入原始水印图像后，用户可以点击“加密水印图像”按钮，系统将对水印图像进行加密处理。加密过程采用了混沌序列和异或运算，增强了水印的安全性。加密后的水印图像将显示在系统界面上。
4. 将待隐藏水印嵌入载体图像
选择完载体图像和加密水印图像后，用户可以点击“将待隐藏水印嵌入载体图像”按钮，系统将对载体图像进行一系列处理，将加密后的水印嵌入载体图像的LH子带。嵌入后的图像将在系统界面上显示。
5. 攻击
为了验证水印的稳定性，系统还提供了攻击功能。用户可以通过下拉菜单选择不同的攻击类型，包括剪切、图像增亮、图像变暗、增加对比度、降低对比度、乘积性噪声、高斯噪声、旋转、直方图均衡化等。攻击后的图像将在系统界面上显示。
6. 提取的水印信息
用户可以点击“提取的水印信息”按钮，系统将尝试提取嵌入的水印信息。提取后的水印信息将在系统界面上显示。
7. 解密提取出的隐藏信息
最后，用户可以点击“解密提取出的隐藏信息”按钮，系统将对提取出的水印信息进行解密。解密后的水印图像将在系统界面上显示，并计算峰值信噪比（PSNR）和NC参数，用于评估水印的提取质量。
4.总结 该方法将离散小波变换、奇异值分解和Arnold置乱变换有机地结合在一起，利用Arnold置乱变换对水印图像进行变换，增加水印算法的安全性，通过二次离散小波变换得到原始图像的低频部分，然后对原始图像的低频部分和置乱后的水印图像进行奇异值分解，分解结果通过加性准则实现水印的嵌入.实验结果表明，该算法能够有效地实现水印的嵌入和提取操作，嵌入水印后不会影响人眼对图像的观察.在椒盐噪声、高斯噪声、JPEG压缩、高斯平滑和裁剪操作等各种污染和攻击措施下，算法的NC值均大于0.7，人眼能够轻松地辨别出提取的水印图像，表明该算法具有较强的鲁棒性。
参考文献：文献链接
5.代码资源获取 https://mp.weixin.qq.com/s/cwLk2ivg8kqZ4Se-9Ym1ZQ
最后：
如果你想要进一步了解更多的相关知识，可以关注下面公众号联系~会不定期发布相关设计内容包括但不限于如下内容:信号处理、通信仿真、算法设计、matlab appdesigner，gui设计、simulink仿真......希望能帮到你！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a129f409a21d96a07811b65d3bf26d8/" rel="bookmark">
			C语言：函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创作不易，友友们给个三连吧！！ 一、函数的概念 数学中我们见过函数的概念，例如y=kx+b，k和b都是常数，给任意一个x就可以得到y
而C语言也引入了函数（function）这个概念，C语言中的函数就是一个完成某项特定任务的一小段代码。而这段代码有自己的特殊写法和调用方法。
因为C语言的程序是由无数个小的函数组合而成的，所以我们也把函数叫做子程序。
也就是说：一个大的计算任务可以分解成若干个小任务（函数）来完成，而C语言作为一个面向过程的语言，每个函数的设置都是为了完成某些特定的任务，并且也可以在工程中是可以重复使用的，因此也提高了开发效率。
综上,我们可以简单总结出函数的两个好处：
1、可以将一个大型的任务拆分成多个小任务，也方便程序员之间的协作。
2、函数本身是为了实现工程中的某个特定功能的，而该功能有些时候可能会使用多次，所以函数封装之后的重复使用可以有效提高开发效率。
而在C语言中存在这样两种类型的函数：
库函数：现成的，可以直接使用的函数
自定义函数：根据实际需要自己设计的函数
二、库函数 2.1 标准库和头文件 1、C语言只是规定了使用的语法规则
2、但C语言不提供库函数的
3、不过C语言的国际标准ANSI C规定了一些库函数的各种信息
比如说scanf：名字，参数，返回类型，函数的功能…………
4、而C语言的编译器厂商根据这些规定来实现这些函数
比如微软——MSVC——微软的团队就实现对应的库函数
苹果——clang——苹果的团队就实现对应的库函数
5、库函数实现后，厂商们将这些库函数的具体实现隐藏起来，导入静态库，并将这些库函数根据功能的划分在不同的头文件中进行的声明，使得我们程序员可以通过对应的头文件去直接使用相应的库函数。
比如我们想要使用printf、scanf，就要通过头文件&lt;stdio.h&gt;（标准输入、标准输出有关库函数的头文件），这里面有这俩函数的声明。
6、库函数在编译器的标准库中，可以直接使用，所以不需要程序员自己去实现，大大提高了开发效率，同时库函数的实现往往是公司的一个团队一起完成的，所以基本上封装得很好，库函数的质量和执行效率都是更有保证的，所以我们能使用库函数的时候就尽量使用库函数，不能用库函数解决问题的时候才会去根据自己的需求创建自定义函数。
7、因为不同编译器的团队不同，所以不同编译器的库函数的实现细节可能略有差异，但因为都是根据国际标准去实现的，所以使用起来基本没有什么感觉，在有些编译器中可能会封装得更好，但是绝对不会低于国际标准。
比如memcpy函数在C语言标准中规定的是拷贝空间不重叠的内存，而memmove函数在C语言中规定的是拷贝空间重叠的内存。但是在vs2022中，memcpy也可以做到拷贝空间重叠的内存，但是在其他编译器可能就不一定了，所以我们使用的时候也要尽量根据标准去使用。
2.2 库函数的使用方法 库函数有非常多，要慢慢去学习，逐个击破。
库函数相关头⽂件：https://zh.cppreference.com/w/c/header
C/C++官⽅的链接：https://zh.cppreference.com/w/c/header
cplusplus.com：https://legacy.cplusplus.com/reference/clibrary/
比如sqrt
double sqrt (double x); sqrt是函数名
x是函数的参数，表示调用函数需要传递一个double类型的值
double是返回值类型，表示函数计算的结果是double类型的值
功能：Compute square root 计算平⽅根
square root of x 返回平方根
头文件：&lt;cmath&gt;/&lt;math.h&gt;
2.3 库函数文档的一般格式 1. 函数原型
2. 函数功能介绍
3. 参数和返回类型说明
4. 代码举例
5. 代码输出
6. 相关知识链接
三、自定义函数 相比库函数，其实自定义函数更加重要，因为库函数远远不能满足我们的需求，而自定义函数使得我们写代码更具有创造性。
ret_type fun_name(形式参数) { } ret_type是函数的返回类型：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a129f409a21d96a07811b65d3bf26d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5363bd97686d13eb058198301e025ff/" rel="bookmark">
			C语言：进制转换以及原码、反码、补码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、二进制 其实我们经常能听到2进制、8进制、10进制、16进制这样的讲法，那是什么意思呢？其实2进制、8进制、10进制、16进制是数值的不同表⽰形式⽽已。
比如：
数值15的各种进制的表⽰形式：
15的2进制：1111
15的8进制：17
15的10进制：15
15的16进制：F
我们重点介绍⼀下⼆进制：
⾸先我们还是得从10进制讲起，其实10进制是我们⽣活中经常使⽤的，我们已经形成了很多尝试：
• 10进制中满10进1
• 10进制的数字每⼀位都是0~9的数字组成
其实⼆进制也是⼀样的
• 2进制中满2进1
• 2进制的数字每⼀位都是0~1的数字组成
二、进制转换 10进制的123表示的值是123，那这个值究竟是怎么来的呢？其实10进制的每一位是有自己的权重的，10进制的数字从右向左是个位、十位、百位……，分别每一位的权重是 10^0, 10^1, 10^2 ...…… 而每每一位数乘以他的权重值再相加，得到的就是相应的数。
例如123=3*10^0+2*10^1+1*10^2
2.1 其他进制转10进制的方法 在此之前先讲讲2进制转10进制，2进制和10进制是类似的，只不过2进制的每⼀位的权重，从右向左是: 2^0, 2^1 , 2^2 ...
如果是2进制的1101，该怎么理解呢？
1*2^0+0*2^1+1*2^2+1* 2^3=13
所以2进制转10进制，只要将每一位的数乘以他对应的权重并相加就可以了！
同理，8进制和16进制转10进制也是通过这样的方法去实现！
结论：其他进制转10进制的方法就是每一位数乘以他的对应权重并相加！
2.2 10进制转其他进制的方法 先分析10进制转2进制的方法，比如125
所以10进制转2进制的方法就是，不断地除以2并记录每一次的余数，余数从下往上依次放在一起就是该数字的2进制形式。
同理，10进制转8进制或者16进制也是不断除以8或者16并记录每一次的余数。
结论：10进制转其他进制就是将该10进制数不断地除以要转化地进制，并记录每一次的余数，余数从下往上的数放在一起可以了！！
2.3 2进制转8/16进制 前面介绍了10进制和其他进制的相互转化，我们至少对于10进制非常了解，但如果是除了10进制以外的其他进制之间是如何相互转化的呢？？
2.3.1 2进制转8进制 8进制的数字每⼀位是0~7的，0~7的数字，假如各⾃写成2进制，最多有3个2进制位就⾜够了，⽐如7的2进制是111，所以在2进制转8进制数的时候，从2进制序列中右边低位开始向左每3个2进制位会换算⼀ 个8进制位，剩余不够3个2进制位的直接换算。
如：2进制的01101011 换成8换成8进制后，还要在前面加个0，因为0开头的数字会被当成是8进制。
所以2进制的01101011 转化成8进制就是0153！
结论：2进制转8进制时，从2进制序列中从右向左每3位为一组，剩余不够3位的直接为1组，每组的每个数都分别乘以他的权重值并相加，最后每组得到的数放在一起，就得到了该数8进制的表示形式，别忘记了8进制形式要以0开头！！
2.3.2 2进制转16进制 16进制的数字每⼀位是0~9,a ~f 的，0~9,a ~f的数字，各⾃写成2进制，最多有4个2进制位就⾜够了， ⽐如 f 的⼆进制是1111，所以在2进制转16进制数的时候，从2进制序列中右边低位开始向左每4个2进制位会换算⼀个16进制位，剩余不够4个⼆进制位的直接换算。
如：2进制的01101011
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5363bd97686d13eb058198301e025ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0c01ba1464fb955914607e34fce808e/" rel="bookmark">
			Windows 安装 MySQL 最新最简教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows 安装 MySQL 最新最简教程 官网地址 https://dev.mysql.com/downloads/mysql/ 下载 MySQL zip 文件
配置 MySQL1、解压文件
2、进入 bin 目录 搜索栏输入 cmd 回车进入命令行 C:\Users\zhong\Desktop\MySQL\mysql-8.3.0-winx64\mysql-8.3.0-winx64\bin 注意这里是你自己的解压路径的 bin 目录
3、初始化数据库初始化密码 mysqld --initialize --console 安装 MySQL 服务 mysqld --install mysql 我的已经装过了所以显示的 Install/Remove of the Service Denied!正常的是 Service successfully installed.
4、启动 MySQL 用管理员打开 bin 目录输入
net start mysql 5、登录 MySQL 用 3、 mysqld --initialize --console 初始化密码获得的密码进行登录
输入以下命令回车然后输入密码
mysql -uroot -p 我这里是因为已经有了数据库了我使用自己的密码登录
6、修改密码 ALTER USER 'root'@'localhost' IDENTIFIED BY '123456'; 7、刷新权限 FLUSH PRIVILEGES; 现在可以使用自己的密码登录 MySQL 了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0c01ba1464fb955914607e34fce808e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/320638ed3a85ee6073d3f010422d23d4/" rel="bookmark">
			Sqlserver 数据库出现 （可疑）情况处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在 SQL Server 中，如果某个数据库被标记为“可疑”（Suspect），这通常意味着该数据库的事务日志文件（.ldf）可能损坏或丢失。当一个数据库的日志文件不可用时，SQL Server 无法保证数据库的一致性，因此会将数据库状态设置为“可疑”。
USE master; ALTER DATABASE 你的数据库名 SET EMERGENCY; ---首先，你需要将数据库设置为单用户模式，然后修复数据库： ALTER DATABASE 你的数据库名 SET SINGLE_USER WITH ROLLBACK IMMEDIATE; DBCC CHECKDB('你的数据库名', REPAIR_ALLOW_DATA_LOSS); --重建日志文件: 完成上述步骤后，你可能需要重新创建日志文件。可以通过以下命令来执行此操作： USE master; ALTER DATABASE 你的数据库名 REBUILD; 恢复正常运行: 最后，将数据库恢复到正常模式，并允许多用户访问： ALTER DATABASE 你的数据库名 SET ONLINE; ALTER DATABASE 你的数据库名 SET MULTI_USER; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e4d522ae2fbcb704d8625f2ec93f3af/" rel="bookmark">
			保姆级教程 从零配置nodejs环境并用命令行创建基于vue3的uniapp项目&#43;Webstorm配置uniapp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本教程后面部分（用命令行创建基于vue3的uniapp项目+Webstorm配置uniapp）适合习惯使用vscode或Webstorm等（或者说不习惯HBuilder X）的人参考，如果习惯使用HBuilder X，还是建议使用HBuilder X来搭建uniapp项目，会方便很多。
目录
1. 配置node.js
1.1 下载并安装
1.2 配置环境变量
1.3 修改安装目录
2. 使用命令行创建Vue3/Vite版的uniapp项目
2.1 全局安装 vue-cli
2.2 创建uniapp项目模板
方法一：使用命令行创建模板
方法二：访问gitee下载模板
2.3 使用npm安装相关依赖
3. Webstorm相关配置
3.1 使用Webstorm打开项目并安装插件
3.2 配置运行程序（运行到浏览器）
3.3 配置运行程序（运行到微信小程序）
3.4 其他运行平台
相关补充
#1. 设置点击运行后自动打开浏览器
#2.安装scss模块
1. 配置node.js 1.1 下载并安装 进入官网下载node.js，我这里下载的是最新版本的nodejs
下载完成后打开，点击next
点击next
选择安装的目录（建议放在其他盘上，我这里只有c盘），然后点击next
继续点击next
继续点击next
点击install
完成后点击finish
1.2 配置环境变量 找到刚刚安装的nodejs的目录，ctrl+c复制路径，并分别创建名为node_global和node_cache的两个文件夹
win+r，然后输入sysdm.cpl，回车
点击高级→环境变量
选择系统变量中的Path，然后编辑
点击新建，然后ctrl+v粘贴刚刚复制的nodejs的路径，再点击新建，把node_global文件夹的路径也加进去，然后点击确定
按win键，然后搜索cmd，点击以管理员身份运行
输入 node -v 和 npm -v，没有报错则安装成功
1.3 修改安装目录 打开cmd，分别输入npm config set prefix &lt;你的node_global文件夹的路径&gt; 和 npm config set cache &lt;你的node_cache文件夹的路径&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e4d522ae2fbcb704d8625f2ec93f3af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/075ab05a39a2c438abee0d91a7fb6d19/" rel="bookmark">
			【ES数据可视化】kibana实现数据大屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.概述
2.绘制数据大屏
2.1.准备数据
2.2.绘制大屏
3.嵌入项目中
1.概述 再来重新认识一下kibana：
Kibana 是一个用于数据可视化和分析的开源工具，是 Elastic Stack（以前称为 ELK Stack）中的一部分，由 Elastic 公司提供。Kibana 提供了丰富的功能，使用户可以通过直观的图表、图形和仪表板来探索、分析和理解存储在 Elasticsearch 中的数据。
数据可视化： Kibana 提供了多种图表类型，如柱状图、线图、饼图、地图等，用户可以根据需要创建各种可视化图表来展示数据。操作ES：Kibana 紧密集成了 Elasticsearch，可以直接从 Elasticsearch 中读取数据，并将可视化图表和仪表板保存到 Elasticsearch 中，方便分享和重用。 之前我们只是粗略的用kibana来操作了一下ES，关于其图表还没有用到过，其实对比起操作es而言，kibana的图表功能才是最核心的，我们可以用配置和拖拽的方式在kibana中快速的实现一个数据大屏。
关于之前的ES相关文章，可以移步专栏：
https://blog.csdn.net/joker_zjn/category_12542755.html
2.绘制数据大屏 绘制数据大屏其实就是在一张画板（面板）上配置出一个个自己想要的组件，然后拖动布局，形成自己想要的效果。
2.1.准备数据 要做大屏肯定要现有数据，自己去做数据太麻烦了，kibana为我们提前准备好了几套示例数据。第一次登录kibana，初始化的时候会进入添加示例数据的界面，一共提供了三套数据，电商数据、飞行数据、web日志数据。
如果已经不是第一次登录kibana，kibana在之前就已经初始化过了，那么可以点击左上角的kibana图标，转跳到kibana的主页，主页中有转跳到添加示例数据的界面的快捷入口：
添加其中一套示例数据后，进入discover界面，可以看到有一个该类数据的索引，此处我添加的是电商数据：
2.2.绘制大屏 要画画当然先要有画布，仪表板就相当于一个画板，我们要在这个画板上创作出一幅幅我们想要的图表，组合成最后的可视化界面。
接下来就是创建仪表板：
建仪表板的时候，是不允许建空的仪表板的，所以要先叫我们选第一个图表，这里我们选择标签云图：
记得数据源不要选错了，要选之前生成的那个订单的索引：
点击后会进入新建的云图的配置界面：
在存储桶里面可以配置：
这里我们配置的关键字是商品名称，降序显示，也就是热度越高的字越大，点击update就可以生成图片。
做完就可以保存了，保存的时候千万不要点成下面那个保存图标了！
保存后，可以看到刚刚生成的面板，可以随意拖动、放大和缩小：
当然还可以修改这个面板：
光有一个图肯定还不够丰富，我们再来建一个表，在面板上添加新的组件：
仔细观察这个表，是不是显得还是太单调了？我们来将这个图配置的丰富一点：
两条指标，一个订单量，一个销售量。
保存后可以看到，面板上有新的组件了，这时候可以通过拖动来调整布局：
目前整个界面都是静态的，我们可以通过添加控制组件来让整个图表拥有动态的交互能力：
配置一个滑块：
再配置一个下拉框：
重新布局一下，然后保存：
再进仪表盘界面的时候，就可以看见我们自己定制的数据大屏了：
3.嵌入项目中 我们在kibana中定制了一个数据大屏，肯定是希望在项目中可以用，而不是每次都要打开kibana来展示这个数据大屏是吧，为此kibana也为我们准备了导出大屏的口子。
可以导出为一段链接，也可以导出为HTML代码，然后把他们嵌入项目中的HTML中即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25db95a0cd6bfd604b42b8bf1d350697/" rel="bookmark">
			银河麒麟v10安装前端环境（Node、vue、Electron&#43;vite）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此帖子所提到的所有依赖包都是基于银河麒麟v10真机的arm架构包，如果是在windows上的虚拟机上 把依赖包换成x64的包即可，方法步骤都是一样 一.node安装 原始方法安装（建议用第二种nvm方法，因为更简单）：
1.1nodejs官网下载基于arm架构的包 1.1.1或者打开终端使用wget方式安装 wget https://nodejs.org/download/release/v18.19.0/node-v18.19.0-linux-arm64.tar.gz 1.2解压node包，常规方式解压或者使用命令解压都可
命令解压：
tar -zxvf ./node-v18.19.0-linux-arm64.tar.gz 1.3将node包移动到路径usr/sbin 或者usr/bin下 可直接剪切过去或者使用命令
sudo mv ./node-v18.19.0-linux-arm64 /usr/sbin 1.4将解压后的包改名为nodejs 名字自己取 直接重命名可能会因权限不够无法修改这里需要用到指令
cd /usr/sbin/ sudo mv node-v18.19.0-linux-arm64/ nodejs 1.5对node和npm建立软链接 使之可以全局使用
sudo ln -s /usr/sbin/nodejs/bin/node /usr/sbin/ sudo ln -s /usr/sbin/nodejs/bin/npm /usr/sbin/ 这是已经ok了 node -v和npm -v查看版本出现版本号就成了
使用nvm方式安装 简单粗暴：
1.安装nvm
链接: https://pan.baidu.com/s/1gPLPxtSahQnMQDHs__5UKQ 提取码: ABC1
安装成功后使用nvm -v查看版本，有版本号就ok
终端输入nvm install +node版本就可直接下载
nvm ls可查看下载的版本
node -v npm-v 检查是否安装成功
二.安装vscode 需要下载基于arm架构的安装包 ，可去官网下载
这是我使用的包：https://pan.baidu.com/s/10sEREUuUgZQU7d2L27WhCw 提取码：ABC1
三.安装vue脚手架 npm install -g @vue/cli 四.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25db95a0cd6bfd604b42b8bf1d350697/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/effec4db58566137c165774a510095fa/" rel="bookmark">
			Mac怎么清理DNS缓存 如何清理Mac苹果电脑中DNS缓存 CleanMyMac有必要买吗 Mac电脑卡住了怎么办 苹果电脑清理 DNS缓存多久刷新一次 MAC电脑清理工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说到清理苹果电脑想必不少网友会说苹果电脑不需要清理，但事实情况是现在对于“苹果电脑清理”的这个话题一直在不断地热议中，虽说Mac OS X系统它的优化比较好，很多小的无效数据文件会自动归类清除，但很多时候一些稍大的数据文件仍然残留在了系统中，这其实就是可用空间变少的主要原因。
今天主要带大家了解一下如何清理DNS缓存，我们先对DNS缓存的形成先做一个简单的了解。
DNS缓存是指在正常访问ip之后，系统会将这个ip存储起来，当再次访问的时候，系统就会直接把本地的DNS缓存提取显示，等于是加速了网址的解析。
DNS记录存储在区域文件中，用于将域名转换为IP地址，还包括域名的服务器名称和邮件服务器信息，例如域名前面常用的“www”，则这些别名也将列在DNS记录中。
如何清除DNS缓存？
（1）常规手动清空DNS缓存
用户可以手动对浏览器的DNS缓存进行清空。首先：手动在访达中搜索终端，然后点击打开终端页面，如下图1。
第二步：根据用户自己的Mac的版本，从下图2中，选取合适的一条命令，输入到终端页面上，并敲击回车键执行命令，即可直接清除Mac上的DNS缓存。
不过这种手动常规清除DNS缓存的方式，有两个致命的缺陷：
第一，操作麻烦，手动输入命令容易出错，而且命令很长很难被记住；
第二，命令是和Mac的版本挂钩的，Mac升级版本，清除DNS缓存的命令也可能会跟着变化，而且网上搜索出来的的命令多种多样，难以分辨究竟哪个命令才是真实有效的。
所以基本上这种常规的方式是十分不实用且不方便的，可以直接淘汰PASS了。 （2）使用CleanMyMac来清除mac中DNS缓存
使用这样的软件来进行清理是再简单不过的，CleanMyMac X是一款专业的Mac清理软件，可智能清理mac磁盘垃圾和多余语言安装包，快速释放电脑内存。
启动CleanMyMac之后选择“维护”后我们会看到右边陈列出来的一些系统维护选项，其中就有“刷新DNS缓存”，我们可以随时做清除工作。
第一步：打开CleanMyMac软件，然后点击左侧的“维护”选项，打开维护操作界面。
第二步：勾选“刷新DNS缓存”，由下图3也可以看到，该项功能目的就是帮助用户刷新浏览器的DNS缓存，即清空缓存，致力于解决“无法连接某些网站”、“网站无规律变慢”等相关问题。
第三步：点击“运行”按钮，运行该功能即可，详细步骤如下图3红色箭头。
上述操作完成后，DNS缓存就被重置清空了，如果此时网站访问依旧有问题，还可以尝试CleanMyMac“维护”功能中的其他功能，具体功能列表如下图红框所示，这些功能能帮助用户一键自动维护优化你的Mac电脑，大家不妨尝试看看能否解决遇到的问题。
总而言之，不论你是Mac的老用户还是新手，当你遇到内存不足的问题时，不妨试试CleanMyMac X。它不仅能帮助Mac清理内存，可以从源头发掘原因，还能优化你的Mac性能，让你的电脑运行得像新的一样。别让你的Mac喘不过气来，用CleanMyMac X给它加加油吧！
你可以前往CleanMyMac中文官网了解更多信息。
CleanMyMac中文安装包下载：https://souurl.cn/Af2M7Z
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e630b93eef9560f72a4c4ef9c6827ef/" rel="bookmark">
			关于TDSQL(MySQL)的简单知识分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 0. 前言 最近在系统改造过程中，接触到了国产分布式数据库TDSQL，记录一下关于TDSQL的部分知识点。
1. TDSQL简介 TDSQL是腾讯推出的一款兼容MySQL的自主可控、高一致性分布式数据库产品。
1.1 TDSQL优点： 数据强一致性高性能低成本线性水平扩展金融级高可用企业级安全性便捷的运维 1.2 TDSQL系统总览 资源池：TDSQL部署的服务器资源。
存储节点：存储节点要强调的是TDSQL的两种存储形态，一种是Noshard数据库，一种是分布式数据库（也叫Shard版TDSQL）。简单来说，Noshard就是一个单机版的TDSQL，在MySQL的基础上做了一系列的改造和改良，让它支持TDSQL的一系列特性，包括高可用，数据强一致、7×24小时自动故障切换等。第二种是分布式数据库，具备水平伸缩能力。所以TDSQL对外其实呈现了两种形态，呈现一种非分布式形态，一种是分布式的形态。
计算节点：计算节点就是TDSQL的计算引擎，做到了计算层和存储层相分离。计算层主要是做一些SQL方面的处理，比如词法解析、语法解析、SQL改写等。如果是分布式数据库形态，还要做分布式事务相关的协调。
赤兔运营管理平台 ：通过这个平台，DBA可以操纵TDSQL后台黑盒，所以相当于是一套WEB管理系统。让所有DBA的操作都可以在用户界面上完成，而不需要登陆到后台，管理节点的操作可以通过界面化完成。
“扁鹊”智能DBA平台：扁鹊智能DBA平台还有一个智能诊断系统，可以定期由DBA发起对实例进行的诊断。
1.3 TDSQL架构模块及其特性 首先用户的请求通过负载均衡发往SQL引擎。然后，SQL引擎作为计算接入层，根据这个SQL的要求从后端的存储节点去取数据。当然，无论是SQL引擎还是后端的数据库实例都存在一个元数据来管理调度。举个例子，计算引擎需要拿到一个路由，路由告诉SQL引擎，这个SQL该发往哪一个后端的数据节点，到底是该发往主节点还是发往备节点。TDSQL引入了ZK（Zookeeper）来储存类似于路由这类元数据信息。当然ZK只是静态的存储元数据，维护和管理这些元数据信息，还需要有一套调度以及接口组件，这里是OSS、Manager/Schedule。这张图可以看到是TDSQL整体来说就分为三部分：管理节点、计算节点和存储节点。当然这里还有一个辅助模块，帮助完成一些个性化需求的，比如备份、消息队列，数据迁移工具等。另外，这里的负载均衡其实不是必需的，用户可以选用自身的硬件负载，也可以用LVS软负载，这个负载均衡根据实际的用户场景可自定义。
2. 模块划分 2.1 管理模块 作为一个集群只搭建一套的管理模块，一般可以复用一组机器。
首先，DBA用户在赤兔管理台——这一套WEB前台发起一个操作——点了一个按纽，这个按纽可能是对实例进行扩容，这个按纽会把这个https的请求转移到OSS模块，这个OSS模块有点像web服务器，它能接收web请求，但是它可以把这个转发到ZK。所以，OSS模块就是一个前端到后台的桥梁，有了OSS模块，整个后台的工作模块都可以跟前台、跟web界面绑定在一起。
捕捉到这个请求之后，在ZK上创建一个任务节点，这个任务节点被调度模块捕获，捕获之后就处理任务。处理完任务，再把它的处理结果返回到ZK上。ZK上的任务被OSS捕获，最后也是https的请求，去查询这个任务，最后得到一个结果，返回给前端。
这是一个纯异步的过程。
2.2 DB模块 DB模块，即数据节点，数据存取服务属于IO密集型的服务，因此，数据节点是TDSQL的存储节点，它对IO的要求比较高。
SET就是数据库实例，一个SET包含数据库的主从节点。
模块Agent，它来完成对所有集群对MySQL的操作，并且上报MySQL的状态。
2.3 SQL引擎模块 SQL引擎处于计算层的位置，本身属于CPU密集型，所以在选机型上尽量要求CPU高一些。其次是内存，作为计算接入层，它要管理链接，如果是大量的短链接或者长链接，非常占内存，所以它对CPU和内存的要求比较高。此外，它本身不存储数据，也没有主备之分。
SQL引擎要处理分布式事物，还要维护全局自增字段，保证多个数据、多个存储节点共享一个保证全局自增的序列；如果是分布式的话，要限制一些语法，包括词法和语法的解析；还有在一些复杂计算上，它还要做一些SQL下推，以及最后数据的聚合。
2.4 TDSQL主备数据复制 mysql主备数据复制实现方式：
异步复制：主机在不等从机应答直接返回客户端成功。半同步：主机在一定条件下等备机应答，如果等不到备机应答，它还是会返回业务成功，也就是说它最终还会退化成一个异步的方式。全同步机制：当主库提交事务之后，所有的从库节点必须收到，APPLY并且提交这些事务，然后主库线程才能继续做后续操作。 TDSQL引入了基于raft协议的强同步复制，主机接收到业务请求后，等待其中一个备机应答成功后才返回客户端成功。
有点类似把半同步的基础上把这个超时时间改成无限大同时应答的备机设置为1，但是TDSQL强同步复制的性能是在原生半同步的基础上做了大量的优化和改进，使得性能基本接近于异步。
2.5自动容灾切换 SQL引擎将请求发给主节点，主节点被两个备机所同步，每个节点上都有对应的Agent上报当前节点的状态。这时，主节点发生了故障被Agent觉察，上报到zk被Scheduler捕获，然后Scheduler首先会把这个主节点进行降级，把它变成Slave。也就是说此时其实整个集群里面全是Slave，没有主节点。这个时候另外两个存活的备机上报自己最新的binlog点，因为有了强同步的保障，另外两个备机其中之一一定有最新的binlog，那么两个备机分别上报自己最新的点后，Schedule就可以清楚的知道哪个节点的数据是最新的，并将这个最新的节点提升成主节点。
容灾切换需要建立在强同步的基础上。
2.6 数据强一致性 比如说A节点作为主节点，B、C是从，正常去同步A节点的数据，A+1、A+2，接下来该同步A+3。当A+3还没有同步到从节点的时候发生了故障，这个时候根据B、C节点的数据情况，C的数据是最新的，因此C被选成了主节点，进而C继续同步数据到B。过了一阵，A节点拉起了，可以重新加入集群。重新加入集群之后，发现它有一笔请求A+3还没有来得及被B、C节点应答，但已经写入到日志。这个时候其实A节点的数据是有问题的，我们需要把这个没有被备机确认的A+3的回滚掉，防止它将来再同步给其他的节点。
3. 分表 3.1 分表 shardkey——是TDSQL的分片关键字，也就是说TDSQL会根据shardkey字段将这个数据去分散。
3.2 水平拆分 对于分布式来说，可能最初我们所有的数据都在一个节点上。当一个节点出现了性能瓶颈，需要将数据拆分。
3.3 分布式事务 分布式事务也是根据shardkey来判断，具体来说，对于SQL引擎读发起一个事务，比如第一条SQL是改用户ID为A的用户信息表。第二条SQL是插入一个用户ID为A的流水表，这两张表都以用户ID作为shardkey。如果这两条SQL都是发往一个分片，虽然是一个开启的事务，但是发现它并没有走分布式事务，它实际还是限制在单个分片里面走了一个单节点的事务。当然如果涉及到转帐：比如从A帐户转到B帐户，正好A帐户在第一个分片，B帐户是第二个分片，这样就涉及到一个分布式事务，需要SQL引擎完成整个分布式事务处理。
TDSQL分布式事务优点：
3.4 分布式总结 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe4805cc57147eeefbabb76f25417877/" rel="bookmark">
			SpringCloud-生产者和消费者
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、生产者和消费者的定义 在 Spring Cloud 中，术语 "生产者" 和 "消费者" 用于描述微服务架构中的两种基本角色。
角色定义生产者
Provider生产者是提供具体服务或功能的模块。它将业务逻辑封装成服务，供其他模块调用。生产者向服务注册中心注册自己提供的服务，使其他模块可以通过服务注册中心发现并调用这些服务。消费者
Consumer消费者是通过调用生产者提供的服务来完成特定功能的模块。消费者从服务注册中心获取生产者的信息，然后调用生产者的服务接口。消费者在运行时动态发现并连接到可用的生产者。 示例：一个在线商城系统中，订单服务可以被视为生产者，提供创建订单、查询订单等服务。购物车服务可以是一个消费者，它调用订单服务的创建订单服务来完成用户购物车中商品的下单。
简单在线商城购物流程服务结构图：
稍微复杂一点的在线商城系统的购物流程服务结构图：
二、生产者和消费者代码演示 1、创建父工程 在构建微服务项目时，首先需要创建一个父工程，以便统一管理依赖版本和项目属性。
我们来新建项目 SpringCloudTest。
父工程不需要太多引入，勾选 spring web 这一项即可。 删除多余内容：
pom.xml 新增 packaging 标签
2、创建服务注册中心 微服务架构中，服务注册中心是整个系统的核心，负责服务的注册与发现。使用 Spring Cloud 的Eureka 组件，可以轻松搭建一个高可用的服务注册中心。在创建 Eureka 注册中心时，需要在项目中引入相应的依赖，并通过注解标记该服务为 Eureka Server。
新建模块 euraka-server。
勾选 eureka server。 创建完成后，我们修改 eureka-server 的 pom.xml，使它的 &lt;parent&gt;&lt;/parent&gt; 标签里的内容对应父工程。
父工程：
eureka-server 的 pom.xml：
&lt;parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;SpringCloudTest&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; 同时，我们需要在父工程的 pom.xml 里添加子模块的依赖关系。 &lt;modules&gt; &lt;module&gt;eureka-server&lt;/module&gt; &lt;/modules&gt; 创建 eureka-server 的 application.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe4805cc57147eeefbabb76f25417877/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85515c35a3f21fc2a4ec52ec0c39e9c0/" rel="bookmark">
			学生信息|基于Springboot的学生信息管理系统设计与实现(源码&#43;数据库&#43;文档)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学生信息管理系统目录
目录
基于Springboot的学生信息管理系统设计与实现
一、前言
二、系统功能设计
三、系统实现
1、管理员登录
2、课程管理
3、公告信息管理
4、公告类型管理
四、数据库设计
1、实体ER图
2、具体的表设计如下所示：
五、核心代码 六、论文参考
七、最新计算机毕设选题推荐
八、源码获取：
博主介绍：✌️大厂码农|毕设布道师，阿里云开发社区乘风者计划专家博主，CSDN平台Java领域优质创作者，专注于大学生项目实战开发、讲解和毕业答疑辅导。✌️
主要项目：小程序、SpringBoot、SSM、Vue、Html、Jsp、Nodejs等设计与开发。
🍅文末获取源码联系🍅
👉 毕设答疑 👈
基于Springboot的学生信息管理系统设计与实现 一、前言 使用旧方法对学生信息管理系统的信息进行系统化管理已经不再让人们信赖了，把现在的网络信息技术运用在学生信息管理系统的管理上面可以解决许多信息管理上面的难题，比如处理数据时间很长，数据存在错误不能及时纠正等问题。这次开发的学生信息管理系统对字典管理、公告管理、课程管理、老师管理、学生成绩管理、学生选课管理、学生管理、资料库管理、管理员管理等进行集中化处理。经过前面自己查阅的网络知识，加上自己在学校课堂上学习的知识，决定开发系统选择小程序模式这种高效率的模式完成系统功能开发。这种模式让操作员基于浏览器的方式进行网站访问，采用的主流的Java语言这种面向对象的语言进行学生信息管理系统程序的开发，在数据库的选择上面，选择功能强大的Mysql数据库进行数据的存放操作。学生信息管理系统的开发让用户查看课程信息变得容易，让管理员高效管理课程信息。
关键词：学生信息管理系统；课程信息；公告；自助资讯
二、系统功能设计 学生信息管理系统具有管理员角色，用户角色，这几个操作权限。
学生信息管理系统针对管理员设置的功能有：添加并管理各种类型信息，管理用户账户信息，管理课程信息，管理公告信息等内容。
学生信息管理系统针对用户设置的功能有：查看并修改个人信息，查看课程信息，查看公告信息等内容。
三、系统实现 1、管理员登录 系统登录功能是程序必不可少的功能，在登录页面必填的数据有两项，一项就是账号，另一项数据就是密码，当管理员正确填写并提交这二者数据之后，管理员就可以进入系统后台功能操作区。下图就是管理员登录页面。
图5.1 管理员登录页面
2、课程管理 项目管理页面提供的功能操作有：查看课程，删除课程操作，新增课程操作，修改课程操作。下图就是课程管理页面。
图5.2 课程管理页面
3、公告信息管理 公告信息管理页面提供的功能操作有：新增公告，修改公告，删除公告操作。下图就是公告信息管理页面。
图5.3 公告信息管理页面
4、公告类型管理 公告类型管理页面显示所有公告类型，在此页面既可以让管理员添加新的公告信息类型，也能对已有的公告类型信息执行编辑更新，失效的公告类型信息也能让管理员快速删除。下图就是公告类型管理页面。
图5.4 公告类型列表页面
四、数据库设计 1、实体ER图 学生信息管理系统的E-R图如下图所示：
（1）下图是资料库实体和其具备的属性。
资料库实体属性图
（2）下图是学生成绩实体和其具备的属性。
学生成绩实体属性图
（3）下图是学生实体和其具备的属性。
学生实体属性图
（4）下图是公告实体和其具备的属性。
公告实体属性图
（5）下图是老师实体和其具备的属性。
老师实体属性图
（6）下图是学生选课实体和其具备的属性。
学生选课实体属性图
（7）下图是课程实体和其具备的属性。
课程实体属性图
2、具体的表设计如下所示： 学生成绩表
序号
列名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85515c35a3f21fc2a4ec52ec0c39e9c0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/508/">«</a>
	<span class="pagination__item pagination__item--current">509/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/510/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>