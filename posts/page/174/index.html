<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c559a60cc7a54b9859ad65af02b1857e/" rel="bookmark">
			构建未来对话：从零开始实现基于Vue 3的AI聊天页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，今天我们将一起探索如何从零开始，使用Vue 3构建一个AI对话页面。这个过程不仅会让我们了解Vue 3的新特性，还会让我们对构建交互式Web应用有一个全新的认识。如果你是编程新手，别担心，我会用通俗易懂的语言，确保你能够跟上每一步。
第一步：搭建Vue 3工程 首先，我们需要搭建Vue 3的工程环境。假设你已经安装了Node.js和npm（Node包管理器）。如果还没有安装，去nodejs.org下载并安装它。
打开你的命令行工具，然后输入以下命令来创建一个新的Vue 3项目：
npm install -g @vue/cli vue create my-ai-chat-app 按照提示选择Vue 3的预设选项，等待项目创建完成。
第二步：项目结构概览 创建完成后，my-ai-chat-app项目的基本结构如下：
my-ai-chat-app
│ README.md
│ package.json
│
├───node_modules
├───public
└───src
│ App.vue
│ main.js
│
├───assets
├───components
│ ChatInput.vue
├───router
│ index.js
├───store
└───views
│ Chat.vue
第三步：编写AI对话页面 接下来，我们将编写AI对话页面的核心代码。首先，让我们打开src/App.vue文件，这是我们的入口组件文件。
&lt;template&gt; &lt;div id="app"&gt; &lt;router-view /&gt; &lt;/div&gt; &lt;/template&gt; 这个模板非常简单，它只包含了一个router-view，这是Vue Router的占位符，用于渲染匹配的路由组件。
ChatInput组件 现在，我们创建一个ChatInput.vue组件，用于发送消息。打开src/components/ChatInput.vue文件，并添加以下代码：
&lt;template&gt; &lt;div&gt; &lt;!-- 消息展示 --&gt; &lt;div&gt;{{ message.text }}&lt;/div&gt; &lt;!-- 输入框 --&gt; &lt;input v-model="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c559a60cc7a54b9859ad65af02b1857e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/370b1b20b27fbcb038eb07b3e3d4dbeb/" rel="bookmark">
			Shire 编码智能体语言：打造你的专属 AI 编程助手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TL;DR：
Shire 提供了一种简便 AI 编码智能体语言，能够让大型语言模型（LLM）与控制集成开发环境（IDE）之间自由对话，以实现自动化编程。
在 Intellij Marketplace 上搜索 Shire，或者在 GitHub 上下载与安装最新版本。
GitHub：https://github.com/phodal/shire
文档：https://shire.phodal.com/
PS：由于，当前版本（0.4.2）支持本地的自定义 RAG 能力，内置本地的 embedding 模型，因此还需要 Onnx Runtime、HF Tokenizer，因此在体积上会比较大。
为什么需要 Shire 智能体语言？ 在 AutoDev 中，我们提供了一系列丰富的自定义能力，以支持开发人员自定义自己的指令，但是受限于框架限制，开发人员的自定义能力还是不够。同时，我们还引入了 DevIns 语言，以支持开发人员更好地自定义自己的 AI 指令。而随后，我们会发现仅仅是这样， 还不足以满足开发人员的日常需求。
1. 辅助研发需求的多样性 AI 软件研发效能提升并不是一件容易的事情，在过去的一年多里，我们做了非常多的尝试。从端到端 AI 辅助研发的开源 Unit Mesh 方案，再到目前 国内最好的开源 AI 驱动编程插件 AutoDev。在这个过程中，我们发现了一些非常有意思的点，诸如于，开发人员需要一个适合自己合适的 AI IDE， 而不是一个通用的 AI IDE。
特别领域代码生成。你需要结合 RAG 来生成包含领域知识的代码，而非简单的补充。
文档实时更新。你需要 AI 来帮你更好生成整个项目的文档，而不仅仅是当前的代码片段注释。
辅助架构分析。你需要结合代码库的 AST 来生成更好的架构分析报告，而不是自己去分析。
还有大量的其它类似的需求，通过现有的 AI IDE 是无法满足的。
2. 文本数据的多样性 在完成自定义任务时，我们所需要的文本数据是丰富多样的。如在 AutoDev 中，用户可以从 IDE 中获取当前的文件、当前的代码片段、当前的选择、当前的光标位置等等。但是依旧存在一些问题：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/370b1b20b27fbcb038eb07b3e3d4dbeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13cf7a959c9f324ba7d8ea6126e834ca/" rel="bookmark">
			uniapp适配解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uni-app的专属强大自适应单位upx，rpx，不能动态赋值解决办法…
uni-app 使用 upx 作为默认尺寸单位， upx 是相对于基准宽度的单位，可以根据屏幕宽度进行自适应。uni-app 规定屏幕基准宽度750upx。
开发者可以通过设计稿基准宽度计算页面元素 upx 值，设计稿 1px 与框架样式 1upx 转换公式如下：
设计稿 1px / 设计稿基准宽度 = 框架样式 1upx / 750upx
举例说明：
若设计稿宽度为 640px，元素 A 在设计稿上的宽度为 100px，那么元素 A 在 uni-app 里面的宽度应该设为：750 *100 / 640，结果为：117upx。
若设计稿宽度为 375px，元素 B 在设计稿上的宽度为 200px，那么元素 B 在uni-app 里面的宽度应该设为：750 * 200 / 375，结果为：400upx。
如下图设计稿宽度为1920
------根据·公式设计稿宽度 / 750 = 比率 则1920/750=2.56 计算出1920宽度设计稿所占标准750百分比------
为了方便在Hbuilder X中 点击工具&gt;设置&gt;语言服务配置中拉到最下面有个px转rpx/upx,把上面计算的比率放进去
实际效果：
这样就根据自己输入的px尺寸自动转换为对应的upx尺寸了
选择upx就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c09de5366a2e69aac60b4868bbd7bc99/" rel="bookmark">
			解决数据库建表错误：ERROR 1064 (42000): You have an error in your SQL...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@[TOC](解决数据库建表错误：ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘desk tb_user’ at line 1)
运用MySQL命令运行sql语句进行建表时，会出现此报错：
自己编写的范例sql语句为：
这个问题其实是语法错误，在MySQL中为了区分关键字与普通字符，MySQL引入了一个反引号，出现此错误有我遇到的有以下几种解决方法：
注释不能用反引号 ` ，因为此处为普通字符串，不是MySQL关键字，即comment后用英文状态的引号 ’前面的id属于关键字符，应该用反引号 `一定要保证所有的符号均在英文状态下输入 最终正确版本为：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3fd1d0ddb3c25377bcd8f2dcdf2ecdc/" rel="bookmark">
			Java 内存管理：垃圾收集与性能优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 内存管理：垃圾收集与性能优化 在Java中，内存管理是一个重要的话题，尤其是垃圾收集（Garbage Collection, GC）对应用程序的性能有着直接的影响。本文将介绍Java的垃圾收集机制，以及如何对其进行优化以提升性能。
一、Java 垃圾收集基础 1. 垃圾收集器简介 Java 自动垃圾收集是其重要特性之一，它负责自动回收程序不再使用的内存。垃圾收集器通过找出不再被引用的对象，并释放它们所占用的内存，从而简化了内存管理。
2. 常见的垃圾收集器 Serial Collector: 适合单CPU机器，收集时会暂停所有应用线程。Parallel Collector: 适合多CPU机器，能并行执行，减少GC时间。CMS Collector: 以获取最短回收停顿时间为目标的收集器，使用标记-清除算法。G1 Collector: 面向服务端应用，将内存划分为多个区域，实现可预测的停顿。 二、监控和调优垃圾收集 1. 监控垃圾收集 要优化垃圾收集，首先需要监控其性能。可以使用Java自带的工具如 jstat, jmap, 或更先进的 VisualVM, JConsole 等进行监控。
# jstat - 监视堆内存用量 jstat -gcutil [process-id] 2. 优化垃圾收集 选择合适的垃圾收集器: 根据应用需求选择最合适的收集器。调整堆大小: 通过 -Xms 和 -Xmx 参数设置堆的初始大小和最大大小。使用并发收集: 对于读多写少的应用，使用CMS或G1收集器可以减少停顿时间。优化代码: 减少对象创建，避免不必要的对象引用，使用对象池等技术。 三、实践案例分析 1. 案例：优化高吞吐量应用 假设一个消息处理系统，需要处理大量短生命期的消息对象。在这种情况下，我们可能会选择 Parallel Collector，并调大年轻代的大小，以适应大量的短期对象。
-XX:+UseParallelGC -Xmn100M -Xmx1024M 2. 案例：减少垃圾收集停顿 对于需要低延迟的在线交易系统，我们可以使用 CMS Collector 来减少停顿时间，同时监控 Min Mark Sweep Pause 和 Concurrent Mode Failure 事件，以调整策略。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3fd1d0ddb3c25377bcd8f2dcdf2ecdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c040ddcde5c84ba0f9c88366d6e9393/" rel="bookmark">
			为什么使用 Lumion 3D 渲染软件进行建筑可视化?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如今，建筑可视化的需求量很大。一些报告指出，到 2025 年，建筑可视化作品的市场规模可能达到 57.2 亿美元。这只能说明 3D 渲染和建筑可视化在当今的重要性日益增加。如今，它已成为广告、营销、沟通等诸多领域前所未有的工具。
Lumion——最强大的建筑可视化 3D 渲染软件之一。它可以帮助渲染专家和专业人士将他们的作品提升到卓越的水平。Lumion 不仅是一款操作简单、用户体验良好的优秀工具，还具有许多优势。它适合任何工作流程，拥有庞大的项目库，渲染速度快，并且兼容大多数概念和照片级效果，包括实时渲染。
考虑到所有这些，让我们来看看您应该使用 Lumion 3D 渲染软件进行建筑可视化的一些主要原因。
1. 支持图像、视频和 360 全景可视化 在不断发展的建筑、工程和建筑设计领域，建筑可视化和 3D 渲染已迅速成为专家和专业人士的必备工具。它们受到那些需要有效方式向项目参与者（包括客户、同事和合作伙伴）传达自己想法的人的青睐。
Lumion 将创建建筑可视化和 3D 渲染的过程变成了一种令人愉快、满意且简单的体验。由于该软件支持图像、视频和 360 全景可视化工作，因此它允许您创建令人惊叹和震撼的视觉效果。
2. 允许你从其他工具导入项目 您应该开始使用 Lumion 的最大原因之一是它与大多数设计软件工具完全兼容。因此，它适合您的工作流程，并使创建令人惊叹的建筑可视化的过程更加轻松。
使用独特功能创建您自己的工作流程，使您当前的设计流程更加顺畅。无论您使用什么其他软件（CAD 或任何其他软件），Lumion 都允许您轻松地将模型导入软件并在几分钟内开始处理它们。
最棒的是，您不需要任何渲染知识或经验，该软件具有易于理解的学习曲线。使用所有功能开始塑造您设计的概念或现实环境。
3. 拥有庞大的内容库 Lumion 带有一个巨大的内容库，提供许多不同的项目，您可以使用它们来充分捕捉您想要重现的空间特征。Lumion 的内容库中有超过 6,000 个模型。从人物、汽车、室内外家具到精细的自然物体，您可以重现任何现实生活中的场景。Lumion 还附带 1,250 多种材料，让您可以创建客户可以理解的沉浸式设计。为他们提供各种感官体验。
4. 速度很快 加快 3D 可视化项目的速度并使其更加高效是每位 3D 艺术家的目标。Lumion 可让您的渲染工作流程更加简单，从而让您能够显著加快创建建筑可视化的过程。
由于您可以轻松地将 Lumion 融入您当前的建筑实践和工作流程，因此您可以快速创建令人惊叹的结果。如果您需要按计划创建 3D 渲染并在截止日期前交付结果，那么拥有一款速度极快且与各种其他有用工具兼容的软件工具对您的成功至关重要。
5. 提供许多可视化工具 除了速度快、项目丰富、易于使用以及与各种其他工具高度兼容之外，Lumion 最大的优势在于它提供了各种可视化工具。Lumion 的一些主要功能包括：
动画阶段——利用动画的力量来展示项目开发背后的过程。
正交视图——通过在渲染中嵌入纹理和颜色为您的项目添加真实的感觉。
体积火——体积火物体可让您在室内和室外的渲染中添加温暖和舒适的感觉。
雨纹——添加引人注目的细节，雨滴缓缓流淌并滑落于玻璃表面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c040ddcde5c84ba0f9c88366d6e9393/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9e06705edbf2b0e55c2bcba9d143243/" rel="bookmark">
			深入理解Python密码学：使用PyCrypto库进行加密和解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深入理解Python密码学：使用PyCrypto库进行加密和解密 引言 在现代计算领域，信息安全逐渐成为焦点话题。密码学，作为信息保护的关键技术之一，允许我们加密（保密）和解密（解密）数据。Python中有许多库可以帮助我们轻松实现这些功能，其中PyCrypto是一个强大且广泛使用的库。本篇文章旨在深入探讨PyCrypto库的使用，以及如何利用它执行常见的加密和解密任务。
一、PyCrypto库概述 1. PyCrypto介绍 PyCrypto是一个广泛使用的开源Python加密库，专为密码学和数据安全提供一系列强大的工具。这个项目旨在简化加密算法的实现，使得开发者能够专注于他们的应用逻辑，而不是底层的加密细节。以下将从多个方面介绍这个库：
主要功能：PyCrypto包含许多经典和现代的加密算法，如AES（高级加密标准）、RSA、DH（Diffie-Hellman）密钥交换，以及各种哈希函数（如MD5和SHA）。同时，它还提供了数字签名、随机数生成和其他一些有用的密码学操作。 性能特点：PyCrypto的核心是其对加密算法的实现，这些算法都是用C语言编写并封装成Python接口的，因此在性能上相对优秀。例如，Crypto.Cipher模块提供了多种加密模式，包括CBC（密文分组链接）、CFB（密文反馈模式）和ECB（电子密码本模式）等，这些都是加密中常见的工作模式。此外，PyCrypto中的Crypto.Random模块提供了符合FIPS 140-2标准的随机数生成器，这对安全敏感的应用来说至关重要。 应用场景：数据加密方面，如果需要保护存储或传输的数据不被未经授权的用户访问，PyCrypto可以轻松实现文件、数据库记录或网络通信的加密。身份验证方面，利用PyCrypto的非对称加密功能，可以创建和验证数字签名，确保信息来源的真实性。安全通信方面，结合SSL/TLS，PyCrypto可用于构建安全的网络服务，如HTTPS服务器。密码管理方面，对于生成和管理强密码，PyCrypto也能提供帮助。 2. 安装PyCrypto 在大多数情况下，可以通过pip直接安装PyCrypto：
pip install pycrypto 需要注意的是，由于安全和维护问题，原始的PyCrypto项目已被官方弃用。现在更推荐使用如pycryptodome这样的分支，它提供了更好的支持和更新：
pip install pycryptodome 二、基础加密算法 1. 对称加密 对称加密是一种使用相同的密钥进行加密和解密的方法。最常见的对称加密算法包括AES、DES和Blowfish。
a. AES加密 AES（高级加密标准）是目前最流行的对称加密算法之一。使用PyCrypto实现AES加密非常简单：
from Crypto.Cipher import AES import base64 # 加密 key = b'Sixteen byte key' cipher = AES.new(key, AES.MODE_ECB) plaintext = b'This is a secret message. Keep it safe!' enc = cipher.encrypt(plaintext) print(base64.b64encode(enc).decode('utf-8')) # 打印加密后的结果 # 解密 decipher = AES.new(key, AES.MODE_ECB) dec = decipher.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9e06705edbf2b0e55c2bcba9d143243/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03a52e49f6d546a434568bc6c21d0b4d/" rel="bookmark">
			华为OD机试真题最新题库 (B&#43;C&#43;D卷) &#43; 在线OJ在线刷题使用说明（C&#43;&#43;、Java、Python合集）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 2024年，华为目前已经启用D卷，目前D卷和C卷的题目一样，可以放心学习C卷的题目，一次订阅永久阅读，支持在线刷题，持续更新，有问题随时解答，本专栏题目数量已收录到484道。每篇文章的思路分析都非常详细，题目新增图解思路，问题解疑，多样例测试，超过百字的思路参考解析
如何获取在线OJ权限 订阅本专栏后即可解锁OJ权限，接着评论区评论留言即可
👉️OJ+最新华为OD机试 (C++ Java Py)
在线OJ刷题系统使用讲解 优点一：选择适合自己的刷题难度，由浅到深进行练习 优点二：针对性练习，针对自己较弱的算法进行练习 优点三：根据分数进行练习，可直接练习100分或200分题目 优点四：根据卷型进行练习，因为每次题库都会变换，可优先练习抽中卷型 优点五：随意切换代码语言进行测试 目前主流的语言都支持进行评测如： C语言、C++ Java、Python、Nodejs、Golang、R语言、PHP
优点六：在线进行编程，无需本地配置环境 优点七：查看每个题目的AC情况，用时情况，更好优化代码 🚀其他华为OD机试题清单 🔥2024华为OD机试真题(C语言) B+C+D卷🔥
🔥2024华为OD机试真题(Python语言) B+C+D卷🔥
🔥2024华为OD机试真题(Java 语言) B+C+D卷🔥
🔥2024华为OD机试真题(C++语言)B+C+D卷🔥
🔥2024华为OD机试真题(JS 语言) B+C+D卷🔥
🔥2024华为OD机试真题(Golang语言) B+C+D卷🔥
作者：KJ.JK 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/451576ec5a3dfcd65dabaa8b91d1fa33/" rel="bookmark">
			阿里云操作系统智能助手OS Copilot实验测评报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介：作为一名学生，阿里云操作系统智能助手OS Copilot对学生的帮助主要体现在提高学习效率、简化操作流程和优化系统管理等方面。通过其丰富的功能，从系统信息的快速获取到复杂的系统运维管理，OS Copilot都能为学生提供极大的便利和支持。无论是编程新手还是有一定经验的学生，都可以利用OS Copilot提升自己的技术能力和学习效果。
1、OS Copilot 产品体验测评 1）您的角色是什么？开发、运维、学生？如果使用OS Copilot，您的使用场景是什么？ 我是一名计算机的学生，通过OS Copilot 我会对不理解的代码进行翻译，并对代码诊断。
2）你觉得 OS Copilot 在新人上手方面是否简单、指引文档是否清晰、是否存在什么阻碍？ OS Copilot在新人上手方面表现良好，指引文档清晰，但存在一定的使用局限性构成了新用户上手的阻碍。阿里云推出的操作系统智能助手OS Copilot为新人提供了一个高效且易于上手的工具，但是在实际操作上仍有一些障碍需要克服。虽然OS Copilot在指引文档清晰度、操作便捷性等方面表现优异，但在新人上手方面仍面临多命令执行限制、错误处理不足等问题。这些问题或多或少增加了新用户的学习成本和使用难度。
3）OS Copilot 是否对您的工作有帮助？如果有帮助的话，帮助程度1-10分，能够打几分？ 帮助非常大，代码解释，让对这代码理解更加深刻，从帮助程度上一定时给上满分10分的。
4）您愿意向周边朋友/工作伙伴推荐OS Copilot吗？如果OS Copilot开源，是否有意愿共同参与开发？包括参与OS领域大模型的训练等。 非常愿意，在我的技术成熟后一定会共同参与开发并参与OS 领域的培训。
2、OS Copilot 产品功能反馈 1）您体验了哪些功能？对OS Copilot的哪些功能最感兴趣（知识问答、辅助编程、辅助命令执行等），为什么？ 我体验了知识问答、辅助编程、辅助命令等的功能。对以上功能都特别感兴趣，尤其是知识问答，因为实在是太有帮助了非常有趣。
知识问答 通过Copilot的chat对话功能来帮助给出一些想要的代码
辅助编程 以下是帮助python的实现还附有解释
辅助命令执行 2）您有体验过其他类型的产品吗？对比其他产品OS Copilot有什么优缺点？ 使用过序曲Tech的Jarvis、GitHub的Copilot等。
优点：使用简单， 集成度高。
缺点：新人上手方面面临多命令执行限制、错误处理不足等问题
3）您希望OS Copilot能够扩展其他哪些功能呢？比如，支持更多的操作系统、自动命令报错原因分析、系统错误排查，或其他任何您想到的功能。 希望OS Copilot支持更多的操作系统因为每个操作系统都有其独特的功能和优势。OS Copilot如果能充分利用这些特性，将为用户提供更为丰富和高效的使用体验。
4）OS Copilot与其他产品联动组合的体验以及可能，如ACK智能助手、ECS、Workbench等，您也可以展开列举组合的实际应用场景。 与ACK智能助手联动组合
监控和日志分析：在集群运行期间，OS Copilot可以借助ACK智能助手实时监控系统状态，自动分析日志文件，并在出现异常时提供报告和修复建议。这使得用户能够及时响应各种运维事件，提高系统的可靠性和稳定性。
总结 总体来看，OS Copilot在新人上手方面表现良好，但仍存在一些提升空间。清晰的指引文档是其最大的优点之一，但功能的扩展性和错误处理机制的改进也是刻不容缓的任务。随着技术的不断迭代和社区的共同努力，OS Copilot有望在未来支持更多的操作系统，加入更多的实用功能，进一步提升新用户的上手体验和满意度。期待看到它拓展到Debian、Ubuntu等其他Linux发行版，并提供更加详尽的系统优化建议和日志分析功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff93ab32ce3209787169957b46fd97a1/" rel="bookmark">
			大数据可视化——基于Python豆瓣电影数据可视化分析系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大数据可视化——基于Python豆瓣电影数据可视化分析系统 本项目旨在通过对豆瓣电影数据进行综合分析与可视化展示，构建一个基于Python的大数据可视化系统。通过数据爬取收集、清洗、分析豆瓣电影数据，我们提供了一个全面的电影信息平台，为用户提供深入了解电影产业趋势、影片评价与演员表现的工具。项目的关键步骤包括数据采集、数据清洗、数据分析与可视化展示。首先，我们使用爬虫技术从豆瓣电影网站获取丰富的电影数据，包括电影基本信息、评分、评论等存储到Mysql数据库。然后，通过数据清洗与预处理，确保数据的质量与一致性，以提高后续分析的准确性。数据分析阶段主要包括对电影评分分布、不同类型电影的数量分布、评分、演员的影响力等方面的深入研究。基于Echarts进行可视化展示，借助Python中的数据分析库（如Pandas、NumPy）和可视化库（如Matplotlib、Seaborn），我们能够以图表的形式清晰地展示电影数据的特征和趋势。最终，我们将分析结果以交互式的可视化界面呈现，用户可以通过系统自定义的查询与过滤功能，深入挖掘他们感兴趣的电影信息。这个项目不仅为电影爱好者提供了一个全面的数据参考平台，也为电影产业从业者提供了洞察行业动向的工具。
最后我们爬取到的字段信息：电影名，评分，封面图，详情url，上映时间，导演，类型，制作国家，语言，片长，电影简介，星星比例，多少人评价，预告片，前五条评论，五张详情图片
for i,moveInfomation in enumerate(moveisInfomation): try: resultData = {} # 详情 resultData['detailLink'] = detailUrls[i] # 导演（数组） resultData['directors'] = ','.join(moveInfomation['directors']) # 评分 resultData['rate'] = moveInfomation['rate'] # 影片名 resultData['title'] = moveInfomation['title'] # 主演（数组） resultData['casts'] = ','.join(moveInfomation['casts']) # 封面 resultData['cover'] = moveInfomation['cover'] # =================进入详情页==================== detailMovieRes = requests.get(detailUrls[i], headers=headers) soup = BeautifulSoup(detailMovieRes.text, 'lxml') # 上映年份 resultData['year'] = re.findall(r'[(](.*?)[)]',soup.find('span', class_='year').get_text())[0] types = soup.find_all('span',property='v:genre') for i,span in enumerate(types): types[i] = span.get_text() # 影片类型（数组） resultData['types'] = ','.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff93ab32ce3209787169957b46fd97a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6efcbe94caf00e02c0dafaeb822cb6a8/" rel="bookmark">
			二十年大数据到 AI，图灵奖得主眼中的数据库因果循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近，MIT 教授 Michael Stonebraker 和 CMU 教授 Andrew Pavlo (Andy) 教授联合发表了一篇数据库论文。Michael Stonebraker 80 高龄，是数据库行业唯一在世的图灵奖得主，Andy 则是业界少壮派里的最大 KOL。
一老一少，当今数据库届最王炸的组合，合作写的论文题目是
作为业界顶流，当然是不会刷「An Empirical Comparison of xxx」的水文。不过 What Goes Around Comes Around 的标题也着实特别，中文翻译过来是「种瓜得瓜，种豆得豆」，「因果报应」，而后面又跟了一个 Around。其实这是一篇续作，在差不多 20 年前，Stonebraker 教授和另一位教授，UC 伯克利的 Joseph M. Hellerstein 曾经合著了一篇
而 Andy 其实也是 Stonebraker 教授那篇文章的粉丝。
当年论文的起因是当时数据库界兴起了一股反关系型，反 SQL 的浪潮。而在两位教授眼里，其实是历史的倒退，于是忍不住写了一篇科普文，好心劝大家这些看着时髦的东西之前已经玩过一轮了。
而这次论文的时间点也刚好，站在云和 AI 交叉点之间。下面做一些论文的摘录。
介绍 首先呼应了一下当年的论文，列出了数据库到 2005 年的演进史。
然后列出了近 20 年的发展，分别从数据模型/查询语言（Data Models &amp; Query Languages)，以及系统架构（System Architectures) 两部分入手。
数据模型和查询语言 继续呼应当年的论文，事实证明当年的论文判断都没有错。NoSQL 只是一时狂热，当年的 NoSQL 要么都挂了，活下来的，也都老老实实地加上了类 SQL 的语法。
谈到被 AI 带起来的向量数据库，论文的观点是传统的关系型数据库和向量数据库，会和当年的 NoSQL 一样，双向奔赴。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6efcbe94caf00e02c0dafaeb822cb6a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf02cbec96b4e97c7906dce005a84cd3/" rel="bookmark">
			Outlook邮件提醒通知功能详解：设置教程！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Outlook邮件提醒通知使用指南？如何个性设计邮件通知？ 为了帮助用户更好地管理邮件，Outlook提供了强大的邮件提醒通知功能。AokSend将详细介绍如何设置和使用Outlook邮件提醒通知功能，以提高工作效率和管理时间的能力。
Outlook邮件提醒通知：基本含义 它允许用户及时收到关键邮件的提醒，无论用户当前是否在使用Outlook。这种提醒可以帮助用户避免错过重要的邮件，及时回复和处理，从而提高工作效率和响应速度。
Outlook邮件提醒通知：设置步骤 打开Outlook应用程序：无论您使用的是桌面版还是网页版的Outlook，您都可以轻松找到设置选项，确保您的Outlook应用程序已更新到最新版本。进入设置菜单：可以找到各种选项来定制您的Outlook体验。找到并点击“查看所有Outlook设置”，然后进入“邮件”部分。设置新邮件提醒：包括“桌面通知”和“声音通知”。启用这些选项可以确保您在新邮件到达时及时收到Outlook邮件提醒通知。 Outlook邮件提醒通知：高级设置 自定义提醒声音：可以选择系统提供的默认声音，也可以上传自己的音频文件。这样，当收到提醒时，您可以通过熟悉的声音立即识别。创建自定义规则：可以设置特定发件人的邮件在到达时立即提醒，或者为重要的项目任务设置独立的提醒通知。使用提醒标志：通过为邮件添加标志，您可以将其标记为待办事项，并设置相应的提醒时间。 Outlook邮件提醒通知功能不仅能提高工作效率，还能帮助你更好地管理时间和任务。AokSend，API与SMTP接口，实现Outlook邮件提醒通知，实时掌握邮件动态，提升工作效率，助力业务成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a68ff8be4068e6dc270b9e0595dbc13c/" rel="bookmark">
			数据库系统安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库安全威胁 数据库作为信息系统中的核心组成部分，存储和管理着大量敏感和关键的数据，成为网络攻击者的主要目标之一。以下是常见的数据库安全威胁及其详细描述：
一、常见数据库安全威胁 SQL注入攻击（SQL Injection）
描述：攻击者通过在输入字段中插入恶意SQL代码，欺骗数据库执行未经授权的操作。影响：可能导致数据泄露、数据篡改、权限提升或完全控制数据库。 未授权访问
描述：攻击者通过弱密码、默认账户或其他手段获取数据库访问权限。影响：可能导致数据泄露、数据篡改和系统破坏。 恶意内部人员
描述：内部用户利用其合法访问权限进行未经授权的操作。影响：可能导致数据泄露、数据篡改和系统破坏。 数据泄露
描述：敏感数据被未经授权的用户访问或获取。影响：可能导致隐私泄露、财务损失和声誉损害。 权限滥用
描述：用户权限设置不当，导致用户执行超出其职责范围的操作。影响：可能导致数据泄露、数据篡改和系统破坏。 拒绝服务攻击（DoS/DDoS）
描述：攻击者通过大量请求使数据库服务器资源耗尽，导致正常用户无法访问。影响：可能导致数据库服务中断，影响业务连续性。 缓冲区溢出攻击
描述：攻击者利用数据库软件的漏洞，通过发送超长输入数据，导致缓冲区溢出。影响：可能导致执行恶意代码、数据损坏和系统崩溃。 数据备份漏洞
描述：不安全的数据备份存储或传输导致备份数据泄露。影响：可能导致敏感数据泄露，影响数据恢复和业务连续性。 恶意软件感染
描述：恶意软件感染数据库服务器，执行恶意操作或窃取数据。影响：可能导致数据泄露、数据篡改和系统破坏。 社会工程攻击
描述：攻击者通过欺骗手段获取数据库访问权限或敏感信息。影响：可能导致数据泄露和系统破坏。 二、数据库安全防护措施 SQL注入防护
措施：使用预处理语句和参数化查询，避免直接拼接用户输入的SQL语句。工具：Web应用防火墙（WAF） 强化身份认证
措施：使用强密码策略，多因素认证（MFA），禁用默认账户。工具：数据库内置身份验证机制，外部认证服务（如LDAP、Kerberos） 权限管理
措施：实施最小权限原则，仅授予用户完成工作所需的最低权限。工具：数据库访问控制列表（ACL）、角色和权限管理 数据加密
措施：加密存储的数据和传输中的数据，保护敏感信息。工具：Transparent Data Encryption（TDE）、SSL/TLS 审计和监控
措施：启用数据库审计和日志记录，定期审查和分析日志。工具：数据库审计工具（如Oracle Audit Vault）、SIEM系统 安全更新
措施：及时应用数据库软件的安全补丁和更新，修补已知漏洞。工具：数据库供应商的更新和补丁管理系统 数据备份安全
措施：安全存储和传输备份数据，使用加密备份。工具：数据库备份工具，数据加密工具 网络安全
措施：配置防火墙规则，限制数据库服务器的网络访问，使用VPN保护远程访问。工具：防火墙、入侵检测系统（IDS）、虚拟专用网络（VPN） 恶意软件防护
措施：安装和更新防病毒软件，定期扫描数据库服务器。工具：防病毒软件、恶意软件检测工具 员工培训
措施：定期开展安全意识培训，提高员工防范社会工程攻击的能力。工具：安全培训平台，模拟攻击测试 三、数据库安全增强技术 数据库防火墙
描述：监控和控制数据库的网络流量，阻止恶意请求。工具：Imperva SecureSphere、DBProtect 数据脱敏
描述：在非生产环境中使用经过脱敏处理的数据，保护敏感信息。工具：Informatica Data Masking、IBM InfoSphere Optim 零信任安全模型
描述：始终验证用户和设备，不信任任何内部或外部网络。工具：零信任访问控制解决方案 行为分析
描述：通过分析用户行为模式，检测异常活动和潜在威胁。工具：Splunk UBA、Exabeam 数据库加固
描述：通过配置硬化、删除不必要的服务和功能，增强数据库安全性。工具：数据库安全基准（如CIS Benchmarks） 总结 数据库安全威胁多种多样，包括SQL注入、未授权访问、恶意内部人员、数据泄露、权限滥用、拒绝服务攻击、缓冲区溢出、数据备份漏洞、恶意软件感染和社会工程攻击。为应对这些威胁，组织应实施一系列防护措施，如SQL注入防护、强化身份认证、权限管理、数据加密、审计和监控、安全更新、数据备份安全、网络安全、恶意软件防护和员工培训。通过采用数据库防火墙、数据脱敏、零信任安全模型、行为分析和数据库加固等增强技术，可以进一步提高数据库的安全性，保护敏感数据和业务连续性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a68ff8be4068e6dc270b9e0595dbc13c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34f1b6b3c5fef4ee58c2e92b85f22c1d/" rel="bookmark">
			vector模拟实现【C&#43;&#43;】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 全部的实现代码放在了文章末尾准备工作包含头文件定义命名空间和类类的成员变量 迭代器迭代器获取函数 构造函数默认构造使用n个值构造迭代器区间构造解决迭代器区间构造 和 用n个值构造的冲突拷贝构造 析构函数swap【交换函数】赋值运算符重载emptysize和capacityoperator[]reserve【调整容量大小】resize【调整size大小】push_backassign【把所有数据替换成迭代器区间中的数据】insert为什么扩容会导致pos迭代器失效？为什么要返回pos-1？ erase为什么要返回pos？ 全部代码 全部的实现代码放在了文章末尾 准备工作 创建两个文件，一个头文件myvector.hpp，一个源文件 tesr.cpp
【因为模板的声明和定义不能分处于不同的文件中，所以把成员函数的声明和定义放在了同一个文件myvector.hpp中】
mystring.hpp：存放包含的头文件，命名空间的定义，成员函数和命名空间中的函数的定义
test.cpp：存放main函数，以及测试代码
包含头文件 iostream：用于输入输出
assert.h：用于使用报错函数assert
定义命名空间和类 在文件myvector.hpp中定义上一个命名空间myvector
把vector类和它的成员函数放进命名空间封装起来，防止与包含的头文件中的函数/变量重名的冲突问题
类的成员变量 参考了stl源码中的vector的实现
成员变量有3个，都是迭代器
画图理解一下
迭代器 迭代器
因为存放数据的空间是从堆区申请的连续的内存，且只是简单模拟
所以我用了指针T*作为普通迭代器，const T*作为const迭代器
【T是vector中存储的数据的类型】
直接把T*重命名为iterator，把const T*重命名为const_iterator就完成了迭代器的实现
迭代器获取函数 因为const修饰的对象只能调用const修饰的成员函数
所以如果是const修饰的对象调用begin()和end()的时候，就会自动调用到const修饰的begin和end.
构造函数 默认构造 因为stl库里实现的默认构造是没开空间的，所以默认构造直接让3个成员变量都为nullptr就行
直接在声明的时候给缺省值，缺省值会传给成员初始化列表
即
而成员初始化列表会比构造函数先调用
并且每个构造函数调用之前都会先调用成员初始化列表，这样不管调用哪一个构造函数初始化，都会先把3个成员变量初始化成nullptr
使用n个值构造 迭代器区间构造 解决迭代器区间构造 和 用n个值构造的冲突 当重载了迭代器区间构造和用n个值构造的时候
如果传入的两个参数都是int类型的话就会报错
为什么？
因为在模板函数构成重载时，编译器会调用更合适的那一个
什么叫更合适？
就是不会类型转
如果传入的两个参数都是int类型，那么调用的应该是使用n个值构造，因为没有int类型的迭代器
但是使用n个值构造的第一个参数是size_t,int传进去要隐式类型转换
而调用迭代器区间构造，两个int的实参传进去，就会直接把InputIterator推导成int，不会发生类型转换，所以编译器会调用迭代器区间构造
解决方法：
再重载一个使用n个值构造的函数，把第一个参数改成int，这样根据模板偏特化，就会在都不类型转换时优先调用第一个参数特化成int的那个构造函数
拷贝构造 因为成员申请了堆区空间，所以要深拷贝
【不知道什么是深拷贝的可以看我这篇文章：类和对象【三】析构函数和拷贝构造函数】
析构函数 swap【交换函数】 因为存放数据的空间是在堆区开辟的，用3个成员变量去指向的
所以直接交换两个对象的成员变量就可以了
不需要拷贝数据
赋值运算符重载 因为成员申请了堆区空间，所以要深拷贝
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34f1b6b3c5fef4ee58c2e92b85f22c1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8bc97eb615ee8bedfa87cdd01dd0d4a/" rel="bookmark">
			Objective-C 中的 isa 不再是简单的结构体指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		了解 Objective-C 中的 isa 指针内存结构 在 Objective-C 中，isa 指针是对象和类之间的重要桥梁。它不仅帮助运行时系统识别对象的类型，还参与了一些内存和性能优化。本文将深入讲解 isa 指针的内存结构，包括其在早期和现代实现中的演变。
什么是 isa 指针？ 每个 Objective-C 对象都有一个 isa 指针，它指向对象的类对象。类对象本身也是一个对象，它的 isa 指针指向一个元类对象（meta-class）。元类对象存储类方法，并且其 isa 指针最终指向根元类（通常是 NSObject 的元类）。
早期的 isa 指针结构 在早期的 Objective-C 实现中，isa 指针简单地指向类对象的结构体。以下是一个典型的早期实现示例：
struct objc_object { Class isa; // 指向类对象的指针 }; typedef struct objc_class *Class; // Class 的本质是 objc_class 类型的结构体指针 struct objc_class { Class isa; // 指向元类对象的指针 Class super_class; // 指向父类对象的指针 // 其他类相关的元数据 }; 在这种结构下：
对象的 isa 指针指向类对象。类对象的 isa 指针指向元类对象。元类对象的 isa 指针指向根元类对象。 现代 isa 指针结构 在 64 位系统和现代 Objective-C 运行时中，isa 指针被重新设计为一个更复杂的联合体（union isa_t），它不仅包含指向类对象的指针，还包含其他标志位和信息，以优化内存使用和性能。以下是 isa_t 结构的一个简化示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8bc97eb615ee8bedfa87cdd01dd0d4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3856c203a71828ea634b9173a88d782b/" rel="bookmark">
			解决python安装包“ERROR: Could not install packages due to an OSError”错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在使用pip install -r requirements.txt 命令安装 Python 项目依赖包时，命令行报错“ERROR: Could not install packages due to an OSError: [Errno 2] No such file or directory”，即路径错误。
已知OSError通常在文件或目录操作中发生，例如：
尝试打开一个不存在的文件或目录尝试在只读文件中写入数据尝试删除一个不存在的文件或目录尝试重命名一个不存在的文件或目录尝试在一个不支持该操作的文件系统上执行某些操作 结合后面的提示，说明报错原因是在目录里没有这个文件。但是经过查找，在目录下找到了requirements.txt:
那么有可能是文件的位置不对，查阅资料后发现requirements.txt需要在Script目录下，即：
ChatGLM-&gt;Scripts在这里打开命令行窗口：
再运行：
pip freeze &gt; requirements.txt
pip --default-timeout=100 download -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple -d /packages/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd944e8373c593c9ad650fed899fbc64/" rel="bookmark">
			【JavaScript】深入理解Promise：从基础概念到进阶用法、手写promise
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥 个人主页：空白诗 文章目录 一、引言二、Promise概述1. Promise的定义2. Promise的用途3. Promise的三种状态4. Promise的构造函数和基础结构5. Promise的优点6. Promise的实例方法7. Promise的静态方法 三、Promise的基本用法1. 创建一个Promise2. `then`方法3. `catch`方法4. `finally`方法5. 链式调用6. 示例代码 四、Promise的进阶用法1. `Promise.all`2. `Promise.race`3. `Promise.allSettled`4. `Promise.any`5. 使用示例 五、如何手写一个简单的Promise1. 实现Promise的基本结构2. 实现`then`方法3. 实现`catch`方法4. 实现`finally`方法5. 完整的Promise实现 六、Promise的实际应用示例1. 异步数据加载2. 多个异步任务的并行处理3. 顺序执行多个异步任务4. 处理并发的异步任务 七、总结 一、引言 在现代Web开发中，异步编程是不可避免的。无论是发起网络请求、读取文件、定时操作，还是处理事件，异步操作都无处不在。而在众多异步编程解决方案中，Promise因其简洁易用、链式调用和更好的错误处理机制，成为了开发者们的首选。
Promise是一种用于处理异步操作的JavaScript对象，它代表了一个在未来某个时间点才会完成（或失败）的操作及其结果。相比于传统的回调函数，Promise提供了一种更加优雅和便捷的方式来处理异步任务，从而避免了“回调地狱”的问题。
本文将详细讲解Promise的概念、基本用法和进阶用法，并最终手写一个简单的Promise实现。通过这篇文章，读者将不仅能够深入理解Promise的工作原理，还能学会如何在实际项目中有效地使用Promise处理异步操作。
二、Promise概述 1. Promise的定义 Promise是JavaScript中的一种对象，用于表示一个在未来某个时间点才会完成（或失败）的异步操作及其结果。它提供了一种处理异步操作的统一接口，使代码更加简洁和易于理解。与传统的回调函数相比，Promise能够更好地处理异步操作的结果和错误。
2. Promise的用途 Promise广泛用于处理各种异步操作，特别是在以下场景中：
网络请求：使用fetch或XMLHttpRequest进行Ajax调用。文件操作：读取文件、写入文件等I/O操作。定时操作：使用setTimeout或setInterval进行延时操作。事件处理：处理用户事件，如点击、输入等。数据库操作：执行数据库查询、插入、更新等操作。 通过使用Promise，开发者可以避免嵌套的回调函数（即“回调地狱”），从而使代码更加线性和易读。
3. Promise的三种状态 Promise有三种状态：
Pending（待定）：初始状态，操作尚未完成。Fulfilled（已完成）：操作成功完成，并有一个结果值。Rejected（已拒绝）：操作失败，并有一个失败原因。 一个Promise对象只能从Pending状态转变为Fulfilled状态或Rejected状态，并且状态一旦改变，就不能再改变。这种不可变性保证了Promise的可靠性和可预测性。
4. Promise的构造函数和基础结构 创建一个Promise实例需要传递一个执行函数，该函数接收两个参数：resolve和reject。这两个参数分别是函数，用于将Promise的状态从Pending变为Fulfilled或Rejected。
const promise = new Promise((resolve, reject) =&gt; { // 异步操作 if (操作成功) { resolve(成功的结果); } else { reject(失败的原因); } }); 在这个基础结构中，resolve和reject函数分别用于处理操作成功和失败的情况。当异步操作完成时，调用resolve将Promise的状态变为Fulfilled，调用reject将状态变为Rejected。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd944e8373c593c9ad650fed899fbc64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5710febe46f6b4499a681d00142f7e3/" rel="bookmark">
			最新Wireshark查看包中gzip内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虽然是很简单的事情，但是网上查到的查看gzip内容的方法基本都是保存成zip文件，然后进行二进制处理。
其实现在最新版本的Wireshark已经支持获取gzip内容了。
选中HTTP协议，右键选择[追踪流]-&gt;[HTTP Stream]
在弹出窗口中，已经可以看到gzip中内容被提取出来了。
TIPS 在非常规通信端口通信时，HTTP不能被准确识别出来，例如的HTTP使用的6041端口。
正常使用端口过滤，并不能识别出HTTP协议。
这种情况下最追踪，就没有HTTP Stream选型。想让Wireshark识别HTTP协议，需要将6041端口配置上。如下：
右键【Protocol】 ，选择列【首选项】
在【Protocols】中选择HTTP
在【TCP port(s)】框里面填入端口号：6041，点击【确定】保存。
HTTP就能正确识别了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b695e5948117835797d1b20f9930f1f/" rel="bookmark">
			配置Maven并使用IDEA新建一个简单的Springboot项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.maven的配置 1.查看电脑上是否配置了maven ①使用快捷键“Win+R”打开运行窗口，在窗口中输入cmd，点击确定进入黑色命令窗口 ②在命令行窗口中输入如下命令 mvn -version 如果出现下面的提示则表示该电脑已配置maven，否则需要进行maven配置【3.6.2为版本号】
③下载Maven（链接如下） 阿里云盘分享 提取码：71pt
百度网盘 请输入提取码
④配置Maven环境变量 解压到一个不包换中文的路径下【如：D:\soft】
进入到bin目录下，如下
复制路径
再次使用“Win+R”打开运行窗口，输入如下后进入高级系统设置，
SystemPropertiesAdvanced
点击环境变量
在系统变量中，点击path后点击编辑
点击新建，将复制的路径粘贴到这里
后一直点击确定即可
重新打开cmd（一定要重新打开一次）cmd窗口，再次输入
mvn -version
查询是否配置成功
2.设置Maven库的位置（里面放Maven的一些坐标依赖），以及更改maven镜像 1.新建一个文件夹作为Maven库 例如在D盘中新建一个maven文件夹
2.进入下面的路径 3.右击settings.xml文件，选择使用记事本打开 在大概第五十行的位置将&lt;localRepository&gt;D:\maven&lt;/localRepository&gt;中的D:\maven改成你刚才设置的maven库的位置，如果没有&lt;localRepository&gt;D:\maven&lt;/localRepository&gt;这一行，就加上然后设置maven库的位置就好了。
在大约165行的位置将上图红框位置内容，更改/添加为：（这里将镜像地址更改为了阿里云的，下载速度快）
&lt;mirrors&gt;
&lt;mirror&gt;
&lt;id&gt;alimaven&lt;/id&gt;
&lt;name&gt;aliyun maven&lt;/name&gt;
&lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;
&lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
&lt;/mirror&gt;
&lt;/mirrors&gt;
二、新建springboot项目 1.新建项目 2.选择Spring Initializr 3.点击完成 4.设置maven ①点击file
②点击setting
③搜索maven
④点击三个点 ，配置好后点击ok
⑤ 设置setting.xml文件
⑥点进apache-maven-3.6.2\conf\文件夹下选择settings.xml文件
⑦点击ok
⑧配置成功后的项目结构，以及会出现绿色小三角
三、配置pom.xml文件 ①3.2.5改为2.5.6 ②22改为1.8（或者你自己的java版本） ③点击小M ④运行springboot项目 ⑤配置成功界面 ⑥配置加载web的依赖 &lt;!--加载web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 配置完后点击小M
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b695e5948117835797d1b20f9930f1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52a4bf92635a491af41f209cfc9cef25/" rel="bookmark">
			sklearn 基础教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Scikit-learn 是一个用于机器学习的 Python 库，它提供了简单而高效的工具来进行数据挖掘和数据分析。以下是 Scikit-learn 的基础教程，包括安装、基本操作和一些常见的机器学习任务。
安装 Scikit-learn 在安装 Scikit-learn 之前，需要确保已经安装了 Python 和 pip。然后，可以通过以下命令安装 Scikit-learn：
pip install scikit-learn 导入 Scikit-learn 在使用 Scikit-learn 之前，需要导入相应的模块：
import numpy as np import pandas as pd from sklearn.model_selection import train_test_split from sklearn.preprocessing import StandardScaler from sklearn.linear_model import LinearRegression from sklearn.metrics import mean_squared_error, accuracy_score 数据准备 在进行机器学习任务之前，首先需要准备数据。以下是使用 Pandas 导入和处理数据的示例：
# 使用 Pandas 导入数据 data = pd.read_csv('data.csv') # 查看数据集的信息 print(data.head()) print(data.info()) # 分割特征和标签 X = data.iloc[:, :-1].values # 特征 y = data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52a4bf92635a491af41f209cfc9cef25/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/173/">«</a>
	<span class="pagination__item pagination__item--current">174/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/175/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>