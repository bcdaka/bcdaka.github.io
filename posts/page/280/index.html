<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a22f3de83cd2f5364f035fbc9ecf61b2/" rel="bookmark">
			我要成为算法高手-双指针篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 什么是双指针?问题1：移动零问题2：复写零问题3：快乐数问题4：盛最多水的容器问题5：有效三角形个数问题6：查找总价格和为目标值的两个商品(两数之和)问题7：三数之和问题8：四数之和总结 什么是双指针? 双指针算法是一种常见的解决问题的技巧，通常使用两个变量在链表或者数组中进行迭代、遍历，从而达到解决问题的目的。光说理论太抽象，我们来几道题目吧~~
问题1：移动零 力扣链接：移动零
分析一下题目要求： 将给定数组中所有的0移动到数组的末尾，也就是将数组分成两个区域，前半部分是非零元素，后半部分都是零，并且保持非零元素的相对顺序，如示例1，非零元素的顺序：1，3，12，处理之后非零元素的顺序也要是1，3，12，
解题思路：
既然是双指针算法，那我们就定义两个"指针"咯，这里的"指针"，我们是指数组下标
定义两个"指针"，dest，cur，
dest：已经处理好的区间内，非0元素的最后一个位置
cur：从左往右遍历数组
dest初始为-1，表示刚开始还没非0元素，cur初始为0
在扫描的过程中，一直让数组保持下面这个状态就好了
图解：
代码实现：
public void moveZeroes(int[] nums) { //双指针:定义dest和cur,dest初始值为-1 //dest的作用:非0元素的最后一个位置,也就是[0,dest]的区间是非0元素 //cur的作用:从左往右扫描数组,遍历数组 int dest = -1; for (int cur = 0; cur &lt; nums.length; cur++) { if (nums[cur] != 0) { //cur遇到非0元素,先交换dest+1位置和cur位置的元素,再dest++,cur++ int tmp = nums[dest + 1]; nums[dest + 1] = nums[cur]; nums[cur] = tmp; dest++; } } } 问题2：复写零 力扣链接：复写零
分析一下题目要求： 所谓复写，也就是让我们抄一遍数组的内容，遇到非零的直接抄这个数，遇到零抄两遍零，题目要求我们在原数组上进行操作，也就是说不能重新开辟一个新的数组
解题思路：
先找到最后一个需要被复写的数，然后从后往前进行复写，如果从前往后，后面的数会被覆盖掉。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a22f3de83cd2f5364f035fbc9ecf61b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b5ec9828dcdac4b0b99c252a81e30c6/" rel="bookmark">
			【Kafka专栏 09】Kafka消费者如何实现如何实现消息回溯与重放：谁说“覆水难收”？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者名称：夏之以寒
作者简介：专注于Java和大数据领域，致力于探索技术的边界，分享前沿的实践和洞见
文章专栏：夏之以寒-kafka专栏
专栏介绍：本专栏旨在以浅显易懂的方式介绍Kafka的基本概念、核心组件和使用场景，一步步构建起消息队列和流处理的知识体系，无论是对分布式系统感兴趣，还是准备在大数据领域迈出第一步，本专栏都提供所需的一切资源、指导，以及相关面试题，立刻免费订阅，开启Kafka学习之旅！
文章目录 Kafka消费者如何实现如何实现消息回溯与重放：谁说“覆水难收”？01 引言02 Kafka回溯消费的意义2.1 数据丢失或错误处理2.2 版本升级2.3 数据分析和测试2.4 容灾和故障恢复 03 Kafka回溯消费的实现原理3.1 基于消息偏移量的回溯3.2 基于时间点的回溯 04 Kafka回溯消费的实践建议05 总结 Kafka消费者如何实现如何实现消息回溯与重放：谁说“覆水难收”？ 01 引言 在分布式系统中，消息队列扮演着至关重要的角色，而Kafka作为其中的佼佼者，以其高吞吐量、低延迟和可扩展性赢得了广泛的应用。然而，在实际应用中，我们不可避免地会遇到数据丢失、错误处理、版本升级以及数据分析等场景，这时就需要消息回溯消费的能力。
02 Kafka回溯消费的意义 首先，我们需要明确Kafka回溯消费的意义。在实际应用中，回溯消费主要解决以下几个问题：
2.1 数据丢失或错误处理 当消费者处理消息时发生错误或者数据丢失，回溯机制可以让消费者重新读取之前的消息，以便进行错误处理或者重新处理数据。
2.2 版本升级 当Kafka集群进行版本升级时，可能会导致消费者与生产者之间的兼容性问题。回溯机制可以让消费者回到之前的版本，以便与新版本的Kafka集群进行兼容。
2.3 数据分析和测试 在数据分析和测试场景中，有时需要重新读取之前的消息进行分析或者测试。回溯机制可以方便地实现这一需求。
2.4 容灾和故障恢复 当Kafka集群发生故障或者出现数据丢失时，可以通过消息回溯来恢复数据，确保系统的可用性和数据的完整性。
03 Kafka回溯消费的实现原理 Kafka支持两种主要的回溯消费方式：基于消息偏移量（Offset）的回溯和基于时间点的回溯。下面将分别介绍这两种方式的实现原理。
3.1 基于消息偏移量的回溯 消息偏移量（Offset）是Kafka中的一个核心概念，它表示消息在分区（Partition）中的位置。Kafka的每个分区都是一个有序的日志，消息在分区中按照偏移量顺序存储。消费者每次消费了消息，都会把消费的此条消息的偏移量提交到Broker（消息节点），用于记录消费到分区中的位置，下条消息从这个位置之后开始消费。
基于消息偏移量的回溯消费很简单，只需要重置偏移量，然后消费者会从该偏移量之后开始消费。具体来说，消费者可以通过Kafka的API来设置或获取偏移量。当需要回溯消费时，消费者可以指定一个旧的偏移量，然后从该偏移量之后开始消费消息。
需要注意的是，基于消息偏移量的回溯消费需要消费者自己管理偏移量。如果消费者没有正确管理偏移量，可能会导致消息重复消费或漏消费。因此，在实际应用中，我们需要根据业务场景和需求来选择合适的偏移量管理策略。
查看消费者组的当前偏移量命令
这个命令将显示消费者组my-consumer-group中每个分区的当前偏移量、日志结束偏移量（即当前最新的消息）和消费者滞后量。
# 假设你的Kafka集群在localhost:9092，消费者组名为my-consumer-group ./bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --describe --group my-consumer-group 重置消费者组的偏移量命令
如果你想要将消费者组的偏移量重置到某个特定的值，你可以使用--reset-offsets选项。但是，请注意，直接通过命令行重置偏移量通常是一个敏感操作，因为它会影响到消费者组的消费状态。
# 重置到最早的偏移量（即从头开始消费） ./bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --reset-offsets --to-earliest --group my-consumer-group --topic my-topic --execute # 重置到最近的偏移量（即跳过所有未处理的消息） .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b5ec9828dcdac4b0b99c252a81e30c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ad81eb0b3468306858dca2e33bc7490/" rel="bookmark">
			Nginx&#43;Tomcat负载均衡、动静分离原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.Nginx负载均衡
1.负载均衡概念
2.负载均衡原理
3.Nginx反向代理
3.1.反向代理概念
3.2.Nginx实现负载均衡的主要配置项
二.Nginx动静分离
1.什么是动静分离
2.动态页面与静态页面区别
3.动静分离原理
三.Nginx+Tomcat负载均衡的实验设计
1.部署nginx负载均衡器
2.搭建tomcat服务器
2.1.Tomcat server（192.168.10.103） 配置
2.2.Tomcat server （192.168.80.102） 配置
3.Nginx进行负载均衡和动静分离设置
3.1.编写Nginx静态资源测试网页
3.2.进行负载均衡和动静分离配置
四.Nginx反向代理类型
1.七层反向代理设置
1.1.配置
2.四层反向代理设置
2.1.配置
3.Nginx的负载均衡模式（调度模式、调度算法、调度策略)
4.Nginx负载均衡会话保持
5.Nginx会话保持实现方式
5.1.ip_hash 或 一致性hash算法
5.2.sticky_cookie_insert
5.3.使用后端服务器自身通过相关机制保持session同步
一.Nginx负载均衡 1.负载均衡概念 服务端接受来自客户端的请求中，既有动态资源也有动态资源，静态资源由 Nginx 提供服务，动态
资源 Nginx 转发至后端
2.负载均衡原理 Nginx实现负载均衡是通过反向代理实现Nginx服务器作为前端，Tomcat服务器作为后端，web页
面请求由Nginx服务来进行转发。 但是不是把所有的web请求转发，而是将静态页面请求Nginx服
务器自己来处理，动态页面请求，转发给后端的Tomcat服务器来处理。据了解，Tomcat是属于轻
量级的应用服务器，可接受访问量可能会不足，所以我们需要多台Tomcat服务器。并且Tomcat并
发量处理能力弱（约Nginx的六分之一），所以需要Nginx方向代理时，进行合理的调用分配
3.Nginx反向代理 3.1.反向代理概念 将nginx接收到的请求转发给其他应用服务器处理
3.2.Nginx实现负载均衡的主要配置项 upstream 服务池名 { }
作用：配置后端服务器池，以提供响应数据 proxy_pass http:// 服务池名
作用：配置将访问请求转发给后端服务器池的服务器处理 upstream框架中，指令中涉及多个参数，各个参数含义说明如下
weight服务访问的权重，默认是1max_connsserver的最大并发连接数，仅作用于单worker进程，默认是0，表示没有限制max _fails在fail timeout时间段内，最大的失败次数，当达到最大失败时，会在failtimeout秒内这台server不允许再次被选择fail timeout单位为秒，默认10秒 proxy_pass http:// 服务池名作用：配置将访问请求转发给后端服务器池的服务器处理 二.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ad81eb0b3468306858dca2e33bc7490/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eac9c015a4c791eb3cd535a774a4a683/" rel="bookmark">
			2024050802-重学 Java 设计模式《实战模板模式》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重学 Java 设计模式：实战模版模式「模拟爬虫各类电商商品，生成营销推广海报场景」 一、前言 黎明前的坚守，的住吗？
有人举过这样一个例子，先给你张北大的录取通知书，但要求你每天5点起床，12点睡觉😪，刻苦学习，勤奋上进。只要你坚持三年，这张通知书就有效。如果是你，你能坚持吗？其实对于这个例子很难在我们的人生中出现，因为它目标明确，有准确的行军路线。就像你是土豪家庭，家里给你安排的明明白白一样，只要你按照这个方式走就不会有问题。可大多数时候我们并没有这样的路线，甚至不知道多久到达自己的黎明。但！谁又不渴望见到黎明呢，坚持吧！
不要轻易被洗脑
键盘侠⌨、网络喷壶，几乎当你努力坚持一件事的时候，在这条路上会遇到形形色色的人和事。有时候接收建议完善自己是有必要的，但不能放弃自己的初心和底线，有时候只坚持自己也是难能可贵的。子路之勇，子贡之辩，冉有之智，此三子者，皆天下之所谓难能而可贵者也。阳光和努力是这个世界最温暖的东西，加油坚持好自己的选的路。
有时还好坚持了
当你为自己的一个决定而感到万分开心😄时，是不是也非常感谢自己还好坚持了。坚持、努力、终身学习，似乎在程序员这个行业是离不开的，当你意愿于把这当做一份可以努力的爱好时，你就会愿意为此而努力。而我们很难说只在机会要来时准备，而是一直努力等待机会。也就是很多人说的别人抓住机会是因为一直在准备着。
二、开发环境 JDK 1.8Idea + Maven涉及工程三个，可以通过关注公众号：bugstack虫洞栈，回复源码下载获取(打开获取的链接，找到序号18) 工程描述itstack-demo-design-21-00场景模拟工程；模拟爬虫商品生成海报场景 三、模版模式介绍 图片来自：https://refactoringguru.cn/design-patterns/template-method 模板模式的核心设计思路是通过在，抽象类中定义抽象方法的执行顺序，并将抽象方法设定为只有子类实现，但不设计独立访问的方法。简单说也就是把你安排的明明白白的。
就像西游记的99八十一难，基本每一关都是；师傅被掳走、打妖怪、妖怪被收走，具体什么妖怪你自己定义，怎么打你想办法，最后收走还是弄死看你本事，我只定义执行顺序和基本策略，具体的每一难由观音来安排。
四、案例场景模拟 在本案例中我们模拟爬虫各类电商商品，生成营销推广海报场景
关于模版模式的核心点在于由抽象类定义抽象方法执行策略，也就是说父类规定了好一系列的执行标准，这些标准的串联成一整套业务流程。
在这个场景中我们模拟爬虫爬取各类商家的商品信息，生成推广海报(海报中含带个人的邀请码)赚取商品返利。声明，这里是模拟爬取，并没有真的爬取
而整个的爬取过程分为；模拟登录、爬取信息、生成海报，这三个步骤，另外；
因为有些商品只有登录后才可以爬取，并且登录可以看到一些特定的价格这与未登录用户看到的价格不同。不同的电商网站爬取方式不同，解析方式也不同，因此可以作为每一个实现类中的特定实现。生成海报的步骤基本一样，但会有特定的商品来源标识。所以这样三个步骤可以使用模版模式来设定，并有具体的场景做子类实现。 五、模版模式搭建工程 模版模式的业务场景可能在平时的开发中并不是很多，主要因为这个设计模式会在抽象类中定义逻辑行为的执行顺序。一般情况下，我们用的抽象类定义的逻辑行为都比较轻量级或者没有，只是提供一些基本方法公共调用和实现。
但如果遇到适合的场景使用这样的设计模式也是非常方便的，因为他可以控制整套逻辑的执行顺序和统一的输入、输出，而对于实现方只需要关心好自己的业务逻辑即可。
而在我们这个场景中，只需要记住这三步的实现即可；模拟登录、爬取信息、生成海报
1. 工程结构 itstack-demo-design-21-00 └── src ├── main │ └── java │ └── org.itstack.demo.design │ ├── group │ │	├── DangDangNetMall.java │ │	├── JDNetMall.java │ │	└── TaoBaoNetMall.java │ ├── HttpClient.java │ └── NetMall.java └── test └── java └── org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eac9c015a4c791eb3cd535a774a4a683/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cdc49e680b3e660b4333b38a7be0d44/" rel="bookmark">
			网络学习(13)｜Spring Boot中获取HTTP请求头（Header）内容的详细解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 方法一：使用`HttpServletRequest`实现原理代码示例优点缺点适用场景 方法二：使用`RequestContextHolder`实现原理代码示例优点缺点适用场景 方法三：使用`@RequestHeader`注解实现原理代码示例优点缺点适用场景 总结 在Spring Boot应用中，获取HTTP请求头（Header）信息是常见的需求，Spring提供了多种机制来实现这一功能。下面将详细解析每种方法的实现原理、优缺点及适用场景。 方法一：使用HttpServletRequest 实现原理 HttpServletRequest接口是Servlet API的一部分，它封装了客户端发送到服务器的请求信息。通过注入HttpServletRequest对象，可以直接调用其getHeader方法获取特定的请求头信息。
代码示例 import javax.servlet.http.HttpServletRequest; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class HeaderController { private final HttpServletRequest request; public HeaderController(HttpServletRequest request) { this.request = request; } @GetMapping("/headers") public String getHeader() { String headerValue = request.getHeader("My-Header"); return headerValue; } } 优点 全面性： 可以访问HttpServletRequest的所有功能，包括获取参数、Cookie、Session等。直观： 直接使用Servlet API，对于熟悉Servlet的开发者来说非常直接。 缺点 耦合性： 控制器类与HttpServletRequest耦合，增加了测试难度。代码冗余： 在多处需要获取相同的Header时，代码重复。 适用场景 当需要访问HttpServletRequest的其他功能时，如读取参数、Cookie等。对于复杂的应用逻辑，需要更精细的请求控制。 方法二：使用RequestContextHolder 实现原理 RequestContextHolder是Spring Web MVC提供的工具类，用于存储当前线程的请求信息。通过RequestContextHolder.getRequestAttributes()可以获取当前请求的ServletRequestAttributes，进而访问HttpServletRequest。
代码示例 import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cdc49e680b3e660b4333b38a7be0d44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d7110e32b67bd83b4a46a3afcbce620/" rel="bookmark">
			【深度学习】使用 LSTM 网络预测水位数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 LSTM 网络预测水位数据 在本文中，我们将介绍如何使用 LSTM（长短期记忆）神经网络来预测水位数据。我们将使用 Python 中的一些流行库，如 NumPy、Pandas 和 Keras。首先，我们将加载数据，然后预处理它以进行适当的训练。接着，我们将构建 LSTM 模型，并对其进行训练。最后，我们将使用训练好的模型进行预测，并将结果可视化。
准备数据 首先，我们需要准备数据。我们将使用 Pandas 加载水位数据，然后对数据进行归一化处理，以便更好地适应 LSTM 模型。
import numpy as np import pandas as pd from sklearn.preprocessing import MinMaxScaler # 加载数据 data = pd.read_csv('water_level_data.csv') # 数据预处理 scaler = MinMaxScaler(feature_range=(0, 1)) scaled_data = scaler.fit_transform(data['Water_Level'].values.reshape(-1, 1)) 接下来，我们将创建输入序列和对应的标签。这将帮助我们将数据转换为适用于 LSTM 的格式。
def create_sequences(data, seq_length): sequences = [] labels = [] for i in range(len(data)-seq_length): sequences.append(data[i:i+seq_length]) labels.append(data[i+seq_length]) return np.array(sequences), np.array(labels) sequence_length = 10 X, y = create_sequences(scaled_data, sequence_length) 构建 LSTM 模型 接下来，我们将构建 LSTM 模型。我们将使用 Keras 库来创建模型。在这个例子中，我们将堆叠两个 LSTM 层，并添加一个全连接层作为输出层。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d7110e32b67bd83b4a46a3afcbce620/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae0536a027953e75de24ea1aff33f110/" rel="bookmark">
			使用SQLite
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自学python如何成为大佬(目录):https://blog.csdn.net/weixin_67859959/article/details/139049996?spm=1001.2014.3001.5501
与许多其他数据库管理系统不同，SQLite不是一个客户端/服务器结构的数据库引擎，而是一种嵌入式数据库，它的数据库就是一个文件。SQLite将整个数据库，包括定义、表、索引以及数据本身，作为一个单独的、可跨平台使用的文件存储在主机中。由于SQLite本身是C写的，而且体积很小，所以，经常被集成到各种应用程序中。Python就内置了SQLite3，所以在Python中使用SQLite，不需要安装任何模块，直接使用。
1 创建数据库文件
由于Python中已经内置了SQLite3，所以可以直接使用import语句导入SQLite3模块。Python操作数据库的通用的流程如图1所示。
图1 操作数据库流程
实例01 创建SQLite数据库文件
创建一个mrsoft.db的数据库文件，然后执行SQL语句创建一个user（用户表），user表包含id和name两个字段。具体代码如下：
import sqlite3
# 连接到SQLite数据库
# 数据库文件是mrsoft.db，如果文件不存在，会自动在当前目录创建
conn = sqlite3.connect('mrsoft.db')
# 创建一个Cursor
cursor = conn.cursor()
# 执行一条SQL语句，创建user表 cursor.execute('create table user (id int(10) primary key, name varchar(20))')
# 关闭游标
cursor.close()
# 关闭Connection
conn.close()
上述代码中，使用sqlite3.connect()方法连接SQLite数据库文件mrsoft.db，由于mrsoft.db文件并不存在，所以会在本实例Python代码同级目录下创建mrsoft.db文件，该文件包含了user表的相关信息。mrsoft.db文件所在目录如图2所示。
图2 mrsoft.db文件所在目录
说明：再次运行实例01时，会提示错误信息：sqlite3.OperationalError:table user alread exists，这是因为user表已经存在。
2 操作SQLite
（1）新增用户数据信息
为了向数据表中新增数据，可以使用如下SQL语句：
insert into 表名(字段名1,字段名2,…,字段名n) values (字段值1,字段值2,…,字段值n)
在user表中，有2个字段，字段名分别为id和name。而字段值需要根据字段的数据类型来赋值，如id是一个长度为10的整型，name是长度为20的字符串型数据。向user表中插入3条用户信息记录，则SQL语句如下：
cursor.execute('insert into user (id, name) values ("1", "MRSOFT")')
cursor.execute('insert into user (id, name) values ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae0536a027953e75de24ea1aff33f110/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4752193c989970e6299cd9f6d7ba568/" rel="bookmark">
			2024年最佳AI大模型-LLM排名（非常详细）零基础入门到精通，收藏这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024年的技术趋势包括生成式AI和大型语言模型（LLMs）用于AI聊天机器人。OpenAI的GPT-4模型是最佳的大型语言模型，具有复杂推理理解、高级编码能力等特点。其他优秀的模型包括Google的PaLM 2和Anthropic的Claude v1。此外，开源模型如Falcon、LLaMA和Guanaco也展现出强大的性能。
几个关键的发展焦点：
OpenAI的GPT-4模型 GPT-4是当前最先进的大型语言模型之一，由OpenAI开发。它具有复杂的推理理解能力和高级编码功能，使其在自然语言处理任务中表现卓越，包括但不限于文本生成、摘要、翻译和对话系统。
Google的PaLM 2 Google的Pathways Language Model (PaLM) 2代表了其语言模型的最新进展，展示了在多任务学习和多模态任务中的强大能力。PaLM 2通过改进的训练技术和算法优化，提高了模型的效率和灵活性。
Anthropic的Claude v1 由Anthropic开发的Claude v1是另一个高性能的大型语言模型，它在保持响应质量的同时，优化了对话管理和情境适应能力，特别是在长对话中表现出良好的连贯性和一致性。
开源模型：Falcon、LLaMA和Guanaco 开源社区也不断推出具有竞争力的模型，如Falcon、LLaMA和Guanaco，这些模型在Hugging Face等平台上广受欢迎。它们提供了一个低成本且灵活的选择，使得研究人员和开发者可以在不受商业许可限制的情况下，探索和实验AI的各种可能性。
Cohere和GPT4All Cohere：一家AI初创公司，提供多种基于最新研究的模型，支持企业和开发者在自然语言处理任务中实现更精准的结果。
GPT4All：这是一个开源项目，旨在使用户能够在本地计算机上方便地运行大型语言模型，减少对云计算资源的依赖，增强数据隐私和安全性。
在 OpenAI 发布 ChatGPT 之后，打造最佳LLM产品的竞赛已经增长了数倍。大公司、小型创业公司和开源社区正在努力开发最先进的大型语言模型。到目前为止，已经发布了数百多个LLMs，但哪些是最有能力的？
1. GPT-4 OpenAI 的 GPT-4 模型是 2024 年最好的 AI 大型语言模型 （LLM）。GPT-4 模型于 2023 年 3 月发布，展示了具有复杂推理理解、高级编码能力、熟练参加多项学术考试、表现出人类水平表现的技能等的巨大能力
事实上，它是第一个可以同时接受文本和图像作为输入的多模态模型。尽管 ChatGPT 尚未添加多模态功能，但一些用户已经可以通过由 GPT-4 模型提供支持的 Bing Chat 进行访问。
除此之外，GPT-4 是为数不多的LLMs解决幻觉并将事实性提高一英里的产品之一。与 ChatGPT-3.5 相比，GPT-4 模型在多个类别的事实评估中得分接近 80%。OpenAI 还不遗余力地使用人类反馈强化学习 （RLHF） 和领域专家的对抗性测试，使 GPT-4 模型更符合人类价值观。
GPT-4 模型已经过 1+ 万亿个参数的训练，支持最大上下文长度为 32,768 个令牌。到目前为止，我们还没有太多关于 GPT-4 内部架构的信息，但最近 The Tiny Corp 的 George Hotz 透露，GPT-4 是一个混合模型，有 8 个不同的模型，每个模型有 2200 亿个参数。基本上，如前所述，它不是一个大的密集模型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4752193c989970e6299cd9f6d7ba568/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26d15bd8161d6a6dd0a462ca961db9e5/" rel="bookmark">
			Python网络爬虫4-实战爬取pdf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.需求背景 爬取松产品中心网站下的家电说明书。这里以冰箱为例：松下电器-冰箱网址
网站分析：
第一步：
点击一个具体的冰箱型号，点击了解更多，会打开此型号电器的详情页面。
第二步：在新打开的详情页面中说明书下载标识
第三步：点击说明书下载，将下载此说明书
2.实现思路与核心步骤 由以上操作，我们知道了模拟用户点击的具体步骤，大致得到了一个整体思路。
主要难点：
如何在整个页面中定位到某一个具体的电器型号，如何遍历依次得到此页面所有型号打开新页面，如何切换到新打开的窗口如何定位到新打开窗口的说明书下载按钮下载完成后如何切换回到原始的页面，进行下一个电器的点击多个页面，如何进行翻页 2.1 得到新页面的链接 依次解决：
1.按F12，打开开发者模式，点击如图所示的1，检查，点击了解详情2，会自动定位显示如图3所示。
发现3标识的href就是此型号的详情页面。所以可以编写函数得到此链接。
这里也有两种方式：
方式一：使用Selenium模拟用户点击，使用xpath定位得到此href
方式二：使用requests直接得到此页面中的所有href链接，发现具体型号的链接时带有product，依据此进行筛选。
本文使用方式二：
def get_allurl(url): ''' 得到url下，所有以.html结尾的href标签下的链接 :param url: :return: ''' result_link = [] html_content = requests.get(url).text soup = BeautifulSoup(html_content, "html.parser") # 由开发者模式下可以看出，我们需要的href标签时a，且时以.html为结尾 link_nodes = soup.find_all('a', href=lambda href: href and href.endswith('.html')) for node in link_nodes: tem_url=node.get("href") result_link.append(tem_url) return result_link 2.2 模拟用户进行点击下载 进入此页面，发现此网站下的链接并不是直接以.pdf为结尾的链接，而是有封装了一层，所以只能通过模拟用户点击的方式。
同时需要点击两次，首先第一次时说明书下载，出来具体型号，我们这里只选第一个NR-ZE391LG-W这个位置。
点击这些位置，得到其对应的XPATH
代码实现如下：
def clik_url(url): # 初始化WebDriver driver = webdriver.Chrome() # 导航到包含链接的网页 driver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26d15bd8161d6a6dd0a462ca961db9e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13d7ac4277aad29e2c35c31a4f6e27ab/" rel="bookmark">
			Jenkins的jdk和maven配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 传送门前言一、概念二、JDK的配置三、Maven配置四、环境变量配置五、坑 传送门 SpringMVC的源码解析（精品）
Spring6的源码解析（精品）
SpringBoot3框架（精品）
MyBatis框架（精品）
MyBatis-Plus
SpringDataJPA
SpringCloudNetflix
SpringCloudAlibaba（精品）
Shiro
SpringSecurity
java的LOG日志框架
Activiti（敬请期待）
JDK8新特性
JDK9新特性
JDK10新特性
JDK11新特性
JDK12新特性
JDK13新特性
JDK14新特性
JDK15新特性
JDK16新特性
JDK17新特性
JDK18新特性
JDK19新特性
JDK20新特性
JDK21新特性
其他技术文章传送门入口
前言 承接 Jenkins配置（插件/角色/凭证）一文，
以CentOS7上面的支持JDK8的Jenkins2.346-1的LTS版本和支持JDK17的Jenkins 2.440.1的LTS版本综合介绍Jenkins的jdk和maven配置，默认按照高版本Jenkins2.440.1讲解，有不一样的地方会特别指出低版本Jenkins。
下面文章不定期更新中。。。
Linux安装JDK17（精品）
Linux安装MySQL（精品）
Linux安装Nginx（精品）
Linux安装Maven（精品）
运行一个jar包（精品）
java -jar提示jar中没有主清单属性（no main manifest attribute）（精品）
Jenkins安装启动（JDK8/11/17）（精品）
Jenkins配置（插件/角色/凭证）（精品）
Jenkins的jdk和maven配置（精品）
Jenkins三种构建类型（精品）
一、概念 如同在win电脑上面，用idea开发，得配置好JDK和Maven，Jenkins同理，也需要单独配置好JDK和Maven。而且必须配置，否则在后面的自动化构建微服务等是无法自动化完成的。
二、JDK的配置 在Manage Jenkins -&gt; Tools 里面，点击进去
点击Add JDK
注意：
Name里面输入的是别名，可以随便起名字，但是为了避坑，最好是叫JDK17或者JDK8之类的（大小写随便）。笔者高版本Jenkins对应的是JDK17，这里配置别名为JDK17JAVA_HOME里面配置的是Linux服务器具体的JDK17路径，注意，路径一定是bin上一层目录，地址不要配置错了。笔者这边配置为/usr/local/jdk-17.0.10Install automatically是自动安装的意思，不打勾，建议没有安装的，先自己单独安装，不建议用Jenkins这边的自动安装，自己安装可以掌控安装目录等等，可以配置环境变量等等，Jenkins的自动安装不会给做这些配置的。 最后点击Save保存。
低版本Jenkins对应的JDK8，并且笔者的是汉化版本，新增JDK8截图如下：
系统管理-全局工具配置里面新增，先点应用，后点保存
三、Maven配置 同上，Name是别名，MAVEN_HOME配置Linux服务器里面的Maven软件路径，配置到bin上一层目录。自动安装不打勾。
低版本Jenkins对应的JDK8，并且笔者的是汉化版本，新增Maven截图如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13d7ac4277aad29e2c35c31a4f6e27ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9991f281b4f26c0538972e0524a85f51/" rel="bookmark">
			macOS Sequoia 开发者测试版下载和安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		macOS Sequoia 于 2024年6月10日在WWDC 2024 上发布，里面添加了AI、窗口排列、操控iPhone等功能，目前发布的为测试版本，可能很多人不知道怎么去下载安装，现在小编教一下大家怎么安装最新的 macOS Sequoia 开发者测试版。
下载 macOS Sequoia 测试版 macOS 15 beta (24A5264n) 1、PKG 格式 （打开根据提示自动安装到 “应用程序” 文件夹）
下载地址：https://www.macappbox.com/a/macos-sequoia-dev-install.html
2、 ISO 格式 (可引导镜像，可以在当前系统中安装或者升级，可以通过 USB 存储引导安装，也可以用于虚拟机安装。）
下载地址：https://www.macappbox.com/a/macos-sequoia-dev-install.html
3、IPSW 固件 (Apple 芯片Mac 专用)
下载地址：https://www.macappbox.com/a/macos-sequoia-dev-install.html
升级安装 升级安装前记得对数据进行备份，目前测试版本不建议在主力设备上进行安装。
双击安装后，在应用程序中 打开 Install macOS Sequoia.app 按提示进行安装即可。
全新安装 1、安装后，检查 应用程序中是否有 Install macOS Sequoia.app
2、将U盘或移动硬盘格式化，使用 “磁盘工具” 抹掉，要求如下：
（1）Mac OS X 扩展（日志式）；（2）GUID 分区图；（3）分区名称：sysin（这里为示例名称，可以自定义，和后面终端命令相关）。 ​
3、打开终端，输入下方代码命令，sysin 为刚才抹掉硬盘的名称。
sudo /Applications/Install\ macOS\ Sequoia\ beta.app/Contents/Resources/createinstallmedia --volume /Volumes/sysin
然后，按命令行的提示，进行确认。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9991f281b4f26c0538972e0524a85f51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad62e1050c09ca39b4ca8f9b2d2e4d1b/" rel="bookmark">
			web安全-前端层面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考资料引荐
https://blog.csdn.net/hack0919/article/details/130929154 XSS 简介 跨站脚本攻击(Cross-Site Scripting, 简称XSS)当用户将恶意代码注入网页时，其他用户在浏览网页时就会受到影响攻击主要方向主要用于盗取cookie凭据，钓鱼攻击，流量指向等 攻击类型 反射型xss 反射型xss又叫非持久型xss (一般具有一次性),交互的数据一般不会被存在数据库里面也就是一次性
攻击者可以将恶意的XSS代码包含在URL漏洞，然后发送给用户，诱导用户自己点开(一次性)
是通过URL参数直接注入，一般是使用alert来探测站点是否防御，直接攻击的使用src来引入自己的脚本
// 例如 http://localhost:1521/?from=&lt;script&gt;alert(1)&lt;/script&gt;bing DOM型xss DOM的全称为Document Object Model，即文档对象模型，DOM通常用于代表在HTML、XHTML和XML中的对象。使用DOM可以允许程序和脚本动态地访问和更新文档的内容、结构和样式。DOM型xss不基于后端，是修改属性，插入内容 document.write… 等改变前端DOM改变结构后，造成攻击 存储型xss 攻击脚本将永久储存到目标服务器的数据库或文件中，因此每次访问网页时都会触发xss漏洞，所有人访问时都会造成攻击漏洞一般存在于留言板，微博，论坛，博客等 // 例如在留言板提交的时候输入 &lt;script&gt;alert('hello')&lt;/script&gt; 防御方案 客户端传递给服务器的时候，需要校验先过滤一下，转义一下服务端入库存储在做一次过滤直接在输出的时候过滤 服务端返回转义 服务端解析返回的时候，把返回的数据进行encodeURIComponent 客户端转义 页面提交、回显均做处理
HTML处理 HTML节点 转义掉&lt;&lt;和&gt;&gt; 即转义掉&lt;&gt;即可，转义的时机有两种，一种是写入数据库的时候进行转义，另一种实在解析的时候进行转义。 var escapeHtml = function(str){ str = str.replace(/&gt;/g, '&amp;lt;'); str = str.replace(/&gt;/g, '&amp;gt;'); return str; } escapeHtml(content); HTML属性 转义”&amp;quto; 即转义掉双引号，'转义掉单引号，(另一个要注意的是实际上html的属性可以不包括引号，因此严格的说我们还需要对空格进行转义，但是这样会导致渲染的时候空格数不对，因此我们不转义空格，然后再写html属性的时候全部带上引号)这样属性就不会被提前关闭了 var escapeHtmlProperty = function(str){ str = str.replace(/"/g, '&amp;quto;'); str = str.replace(/'/g, '&amp;#39;'); str = str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad62e1050c09ca39b4ca8f9b2d2e4d1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8abddce0a78e7f6960cfbbaa0a468cb5/" rel="bookmark">
			【C/C&#43;&#43;】用C语言写一个数据仓库，存储和修改数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个代码实现了一个简单的数据仓库，其中数据被存储在一个3x3的二维数组中。用户可以通过控制台界面与这个数据仓库进行交互，可以选择查看数据或者修改数据。
基础版源码： #include &lt;stdio.h&gt; #define HOUSESIZE 3 int arr[HOUSESIZE][HOUSESIZE] = { 0 }; // 初始化所有元素为0 void printHouseData() { for (int x = 0; x &lt; HOUSESIZE; x++) { for (int y = 0; y &lt; HOUSESIZE; y++) { printf("%d ", arr[x][y]); } printf("\n"); } } void changeHouseData(int row, int column, int value) { if (row &gt;= 1 &amp;&amp; row &lt;= HOUSESIZE &amp;&amp; column &gt;= 1 &amp;&amp; column &lt;= HOUSESIZE) { arr[row - 1][column - 1] = value; } else { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8abddce0a78e7f6960cfbbaa0a468cb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2749387fba80c7ce92a27e2d391e0912/" rel="bookmark">
			【Mac】Premiere Pro 2024 for Mac v24.1软件介绍和安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件介绍 Premiere Pro是一款专业的视频编辑软件。它被广泛应用于电影、电视和网络视频的制作和编辑，具备强大的功能和灵活的工作流程，适用于从初学者到专业人士的各种需求。以下是对Premiere Pro的一些详细介绍：
主要特点 多轨道时间线编辑 支持多轨道编辑，用户可以在时间线上灵活地排列和剪辑视频、音频和图像素材。 高效的色彩校正和调色 提供强大的色彩校正工具，如Lumetri Color，可以对视频进行精细的色彩调整和调色。 高级音频编辑 内置音频混合器和效果处理器，支持多声道音频处理，使音频编辑更加专业。 丰富的转场和特效 包含大量的内置转场效果和视觉特效，还支持第三方插件扩展，以满足各种创意需求。 兼容性和集成性 与Creative Cloud中的其他应用如After Effects、Photoshop、Audition等无缝集成，提升工作效率。支持常见的视频格式，能够从几乎任何设备导入和导出媒体文件。 剪辑和组织工具 提供强大的剪辑工具如滚动编辑、滑动编辑和波纹编辑等，帮助用户快速有效地完成剪辑工作。媒体库可以有效地组织和管理项目素材，支持元数据标记和搜索。 多平台支持 Premiere Pro可以在Windows和MacOS操作系统上运行，便于跨平台协作。 团队项目 支持团队项目功能，多个用户可以同时在同一个项目中合作编辑，通过云服务进行实时协作和版本控制。 应用场景 影视制作 广泛用于电影和电视剧的剪辑与后期制作。 新闻和广播 是许多新闻机构和广播公司用来快速编辑新闻片段和节目的首选工具。 在线内容创作 YouTuber、Vlogger和内容创作者使用Premiere Pro来制作高质量的网络视频。 广告和商业视频 用于制作商业广告、宣传片和企业视频。 准备工作 重要的事情说三遍！
安装软件之前必须先按这篇文章操作：https://mac.shuiche.cc/info/312。
安装软件之前必须先按这篇文章操作：https://mac.shuiche.cc/info/312。
安装软件之前必须先按这篇文章操作：https://mac.shuiche.cc/info/312。
安装软件的前置条件完成后，我们就可以开始安装软件了。
安装教程 1.打开安装包。
2.选中脚本_1，鼠标右键点击，选择「打开」。
3.输入自己电脑的开机密码，输入密码时，密码是看不见的。
4.将镜像包中的「Install.app」拖放到桌面。
5.选中脚本_2_dt，鼠标右键点击，选择「打开」。
6.输入自己电脑的开机密码，输入密码时，密码是看不见的。
7.运行桌面上的Install安装包。
8.点击Install开始安装。
9.打开安装好的软件，如果提示试用，点击开始试用，如果弹出下图内容，直接关闭弹框，软件也会自动退出。
10.回到镜像包，运行pj补丁。
11.跟着提示默认安装即可。
这时候软件就安装成功了。
本站已收录Premiere 2022~2024版本，可根据自己的电脑系统按需安装。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1f1f71f96d311915de04c23e54cb8a3/" rel="bookmark">
			【C语言】编译与链接：深入理解程序构建过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥引言
本篇将深入理解程序构建过程，以便于我们在编写程序的过程同时，理解底层是如何从程序的创建到生成可执行程序的。
🌈个人主页：是店小二呀
🌈C语言笔记专栏：C语言笔记
🌈C++笔记专栏： C++笔记
🌈初阶数据结构笔记专栏： 初阶数据结构笔记
🌈喜欢的诗句:无人扶我青云志 我自踏雪至山巅
文章目录 一、翻译环境和运行环境二、翻译环境2.1 预处理(预编译)2.2 编译2.2.1 词法分析2.2.2 语法分析2.2.4 语义分析 2.3 汇编2.4 链接三、运行环境 一、翻译环境和运行环境 ANSI C是由美国国家标准协会（ANSI）及国际标准化组织（ISO）推出的关于-&gt;C语言的标准。在ANSI C的任何一种是实现中，存在两个不同的环境。
翻译环境:环境中源代码被转换为可执行的机器指令(二进制指令)执行环境:用于实际执行代码 二、翻译环境 翻译环境是由编译和链接两个大过程组成的，将源代码转换为可执行的机器指令，编译又可以分解成:预处理(预编译)、编译、汇编三个过程。
【说明】:
多个.c文件单独经历编译处理生产对应的目标文件多个目标文件和链接库一起经过链接器处理生成可执行程序链接库是指运行时库(支持程序运行的基本库函数集合)或者第三方库 (目标文件：windows环境下后缀为.obj，Linux环境下后缀为.o)
2.1 预处理(预编译) 在预处理阶段，源文件和头文件会被处理成为.i为后缀的文件
预处理阶段主要处理源文件中如下规则:
将所有的 #define 删除，并展开所有的宏定义。处理所有的条件编译指令，如： #if、#ifdef、#elif、#else、#endif 。处理#include预编译指令，将包含的头文件的内容插⼊到该预编译指令的位置。这个过程是递归进行的，也就是说被包含的头文件也可能包含其他文件。删除所有的注释添加行号和文件名标识，方便后续编译器生成调试信息等。或保留所有的#pragma的编译器指令，编译器后续会使用 【注意】:经过预处理后的.i文件中不再包含宏定义，因为宏已经被展开。并且包含的头文件都被插⼊到.i⽂件中。所以当我们无法知道宏定义或者头⽂件是否包含正确的时候，可以查看预处理后的.i⽂件来确认。
2.2 编译 编译过程：将预处理后的文件进行一系列词法分析、语法分析、语义分析以及优化，生成相应的汇编代码文件
编译过程命令:
gcc -S test.i -o test.s 比如:对下列表达式进行处理:
nums[index] = (index+4)*(2+6); 2.2.1 词法分析 将源代码程序被输入扫描器，扫描器的任务就是简单的进行词法分析，把代码的字符分割成一系列的记号(关键字、标识符、字面量、特殊字符等。)
2.2.2 语法分析 将对扫描产生的记号进行语法分析，从而产生语法树(以表达式为节点的树)。
2.2.4 语义分析 由语义分析器完成语义分析，即对表达式的语法层面分析。编译器所能做的分析是语义的静态分析。静态分析通常包括声明和类型的匹配，类型的转换等。这个阶段会报告错误的语法信息。
2.3 汇编 由汇编器将汇编代码转为机器指令(二进制指令)，每一句汇编语句几乎都对应一条机器指令。按照汇编指令和机器指令的对照表进行一一的进行翻译，不做指令优化。
汇编的命令如下:
gcc -c test.s -0 test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1f1f71f96d311915de04c23e54cb8a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f7f0783da433fa4da7884f4140ddac2/" rel="bookmark">
			【初阶数据结构】深入解析顺序表:探索底层逻辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥引言
本篇将深入解析顺序表:探索底层逻辑，理解底层是如何实现并了解该接口实现的优缺点，以便于我们在编写程序灵活地使用该数据结构。
🌈个人主页：是店小二呀
🌈C语言笔记专栏：C语言笔记
🌈C++笔记专栏： C++笔记
🌈初阶数据结构笔记专栏： 初阶数据结构笔记
🌈喜欢的诗句:无人扶我青云志 我自踏雪至山巅
文章目录 一、线性表的概念二、顺序表的概念三、顺序表的分类四、实现顺序表的相关接口(Seqlist.h)五、正式开始模拟实现顺序表5.1 顺序表的初始化5.2 顺序表的扩容(为插入数据提供保障)5.3 顺序表的插入数据5.3.1 顺序表的尾插5.3.2 顺序表的头插 5.4 顺序表的删除数据5.4.1 顺序表的尾删5.4.2 顺序表的头删 5.5 查找指定位置的下标5.5 顺序表的任意位置插入(pos是下标)5.6 顺序表的任意位置删除(pos是下标)5.7 顺序表的判空(主要是否存在有效元素)5.8 顺序表的打印5.9 顺序表的销毁 六、顺序表的优缺点七、顺序表和链表的区别 一、线性表的概念 线性表（linear list）n个具有相同特性的数据元素的有限序列。线性表是一种在实际中广泛使 用的数据结构，常见的线性表：顺序表、链表、栈、队列、字符串等。线性表在逻辑上是线性结构，也就说是连续的一条直线。但是在物理结构上并不一定是连续的， 线性表在物理上存储时，通常以数组和链式结构的形式存储
二、顺序表的概念 顺序表属于线性表的其中一种。顺序表在逻辑、物理结构上是连续，顺序表底层逻辑实现一般是数组。关于物理结构上连续是指一段物理地址连续的存储单元依次存储数据元素的结构
三、顺序表的分类 顺序表分为两种：静态顺序表和动态顺序表，每一种都属于它自己的价值，在实际中。一般使用动态顺序表做的，比如我们经常用的通讯录(因为静态顺序表只适合事前知道需要多少内存的情况下，不然会出现申请多少内存问题)
四、实现顺序表的相关接口(Seqlist.h) 五、正式开始模拟实现顺序表 提前说明下:每一个接口都需要断言下传过来的指针是否为空指针去判断是否是一个有效的结构体变量。如果是第一次接触数据结构，首先需要搞清楚size代表了有效元素个数，而capacity代表的是这块空间的大小或者容量，这里两个东西不是一个意思。
小技巧:在循环中如果不知道结束条件的话，带入临界值去尝试是否符合条件
5.1 顺序表的初始化 void SLInit(SL* phead) { assert(phead); phead-&gt;a = NULL; phead-&gt;size = phead-&gt;capacity = 0; } 这里需要注意的是:空间上没有硬性要求不开空间，可以适当开辟空间，当空间不足时，需向系统申请空间。
5.2 顺序表的扩容(为插入数据提供保障) void SLChekckCapacity(SL* phead) { assert(phead); if (phead-&gt;size == phead-&gt;capacity) { int newcapacity =phead-&gt;capacity==0?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f7f0783da433fa4da7884f4140ddac2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eca4e51b70da3268d40e141333448c22/" rel="bookmark">
			NOSQL -- MOGODB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mogodb简介: 是一个开源的, 高性能, 无模式的文档型数据库. NoSql数据库产品当中的一种, 也是最像关系型数据库的非关系型数据库
使用场景: 针对不同的应用场景, 以及其对应的修改对应数据的频率, 我们可以以此选择需要哪一种类型的数据库
Mongo的使用: 启动: 在解压完成之后, 我们可以进入到对应的bin目录当中, 跟Redis一样, 使用cmd启动
但是在这之前, 我们需要先将这个数据库内容设置一个存储位置
就可以放置在跟bin同一级别下, 设置data目录 再设置一个 db目录, 用来存放信息
之后我们就可以启动了, 并且指定我们当前设置的存储信心的存放位置
首先启动服务端: 如图, 就代表我们已经启动成功了对应的服务端
但是针对于我们的4.4版本之后的mongodb来说, 没有了对应了mongo这个启动程序, 也就是说, 如果我们想要启动客户端, 就不能够再使用这种方式了
新的客户端启动方式: 1&gt;下载对应的mongoshell的压缩包:
MongoDB Shell Download | MongoDB
2&gt;解压缩, 之后以管理员的身份进入到对应的 bin 目录下
输入:
mongosh --host localhost --port 27017
之后我们就可以进入到客户端进行操作了
自然, 前提是我们的服务端当前已经是启动了的
下载使用新的客户端使用方式: 但是, 那样的形式显然是不适合我们进行一些操作的, 所以我们可以换一个应用, 来使用这个应用从而简化操作,跟我们的Navicat一样, Navicat是针对于mysql的操作, 但是这里, Studion 3T 是针对于我们的 mongodb来使用的
下载安装完成之后, 我们连接对应的数据库, 创建新的数据库, 创建表, 之后点击
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eca4e51b70da3268d40e141333448c22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3c6ea695ef388dc445ae38812841677/" rel="bookmark">
			Error:Kotlin: Module was compiled with an incompatible version of Kotlin.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题：运行spring boot项目时，idea报出错误：时提示报错如下图： 错误代码：
Error:Kotlin: Module was compiled with an incompatible version of Kotlin. The binary version of its metadata is 1.6.0, expected version is 1.1.16.
二、产生原因： 这个报错大概意思：模块是用不兼容的Kotlin版本编译的。
原来是idea的kotlin插件版本比pom中的低。
三、解决思路： 把项目里面的版本降一下
一种是升级下idea插件的版本
四、解决办法: 升级Kotlin版本有两种方法步骤如下：
4.1、打开kotlin面板 Windows系统：File -&gt; settings -&gt; Languages &amp; Frameworks -&gt; Kotlin
mac系统：Preferences -&gt; Languages &amp; Frameworks -&gt; Kotlin
4.2、点击Check again，然后点击install即可 4.3、等待安装成功即可 4.4、注意：安装完成后一定要重启项目。 参考：Error:(34, 50) Kotlin: Class ‘kotlin.Unit‘ was compiled with an incompatible version of Kotlin. The_class 'kotlin.unit' was compiled with an incompati-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/414837479bb6834ae921ebd375d5477c/" rel="bookmark">
			数据结构---力扣225.用队列实现栈（C
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.链接：. - 力扣（LeetCode）【点击即可跳转】
思路：
栈 是 后进先出
队列 是 先进先出
（始终保持一个队列为空的思路）
入数据：
往 不为空的队列 中入
出数据：
把不为空的队列数据导出，直到剩最后一个
代码中 队列 的基本实现，不在以下展示，参考之前的文章。
以下为函数的具体实现：
typedef struct { Queue q1; Queue q2; } MyStack; MyStack* myStackCreate() { MyStack* ps = (MyStack*)malloc(sizeof(MyStack)); if (ps == NULL) { exit(-1); } QueueInit(&amp;ps-&gt;q1); QueueInit(&amp;ps-&gt;q2); return ps; } void myStackPush(MyStack* obj, int x)// 入 { if (!QueueEmpty(&amp;obj-&gt;q1))//不为空 { QueuePush(&amp;obj-&gt;q1, x); } else { QueuePush(&amp;obj-&gt;q2, x); } } //移除并返回栈顶元素 int myStackPop(MyStack* obj) //出 { //假设 Queue* emptyQ = &amp;obj-&gt;q1; Queue* nonemptyQ = &amp;obj-&gt;q2; if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/414837479bb6834ae921ebd375d5477c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ba231d49857b30eed5b219b6b659bd0/" rel="bookmark">
			【数据结构】二叉树顺序实现（大堆）--＞赋源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到我的Blog，点击关注哦💕
前言 在前面的顺序表、链表、都是线性表。今天的所介绍的二叉树是一种非线性数据结构。
树的概念以及介绍 定义 树是一种非线性的数据结构，它由n（n&gt;0）个有限结点组成一个具有层次关系的集合。
A B C D E F H DLeft... DRight... ELeft... FLeft... HLeft... 树的相关概念（类比人类血缘关系） 结点的度：一个结点含有的子树的个数称为该结点的度。
叶结点或终端结点：度为0的结点称为叶结点。
非终端结点或分支结点：度不为0的结点。
双亲结点或父结点：若一个结点含有子结点，则这个结点称为其子结点的父结点。
孩子结点或子结点：一个结点含有的子树的根结点称为该结点的子结点。
兄弟结点：具有相同父结点的结点互称为兄弟结点。
树的度：一棵树中，最大的结点的度称为树的度。
结点的层次：从根开始定义起，根为第1层，根的子结点为第2层，以此类推。
树的高度或深度：树中结点的最大层次。
堂兄弟结点：双亲在同一层的结点互为堂兄弟。
结点的祖先：从根到该结点所经分支上的所有结点。
子孙：以某结点为根的子树中任一结点都称为该结点的子孙。
森林：由m（m&gt;0）棵互不相交的树的集合称为森林
二叉树的概念 二叉树是树的一种特殊形式，其中每个节点最多有两个子节点，分别称为左子节点和右子节点。
满二叉树 满二叉树的定义 1.满二叉树是一种特殊的二叉树，它的特点是每一层的节点数都达到最大值，即每一层的节点数都恰好为2的幂次（除了最后一层以外）。
2.如果满二叉树的深度为k，那么它的节点总数为2^k - 1。在满二叉树中，除了最后一层的节点之外，其余每一层的节点都是完全填满的，而且最后一层的节点也是从左到右连续排列的
满二叉树性质 满二叉树的深度为k，节点总数为2^k - 1。满二叉树的每一层的节点数都达到最大值，即每一层的节点数为2^(i-1)，其中i是层数。满二叉树的叶子节点全部位于最后一层。满二叉树的节点要么是叶子节点（度为0），要么是度为2的节点，不存在度为1的节点 如下图：
A B C D E F H DLeft... DRight... ELeft... ERight... FLeft... FRihgt... HLeft... HRight... 完全二叉树 完全二叉树的定义 除了最后一层外，其他每一层的节点数都达到最大数量，即该层的节点数等于2的幂减去1。最后一层的节点都集中在最左边，并且右边的节点可以少，但不能有空位。 完全二叉树的性质 1.完全二叉树的节点编号从1开始，对于编号为i的节点，其左子节点的编号为2i，右子节点的编号为2i+1。
2.如果一棵完全二叉树有n个节点，那么它的深度大约为log2(n)+1。
3.完全二叉树的特点是叶子节点只能出现在最下层和次下层，且最下层的叶子节点集中在树的左部。
A B C D E F H DLeft.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ba231d49857b30eed5b219b6b659bd0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/279/">«</a>
	<span class="pagination__item pagination__item--current">280/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/281/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>