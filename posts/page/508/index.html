<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5095ef4ad2c3460ea09805157b869ccd/" rel="bookmark">
			宿舍报修|宿舍报修小程序|基于微信小程序的宿舍报修系统的设计与实现(源码&#43;数据库&#43;文档)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		宿舍报修小程序目录
目录
基于微信小程序的宿舍报修系统的设计与实现
一、前言
二、系统功能设计
三、系统实现 1、用户小程序功能模块
2、学生信息管理
3、维修人员管理
4、故障上报管理
5、论坛信息管理
四、数据库设计
1、实体ER图
2、具体的表设计如下所示：
五、核心代码 六、论文参考
七、最新计算机毕设选题推荐
八、源码获取：
博主介绍：✌️大厂码农|毕设布道师，阿里云开发社区乘风者计划专家博主，CSDN平台Java领域优质创作者，专注于大学生项目实战开发、讲解和毕业答疑辅导。✌️
主要项目：小程序、SpringBoot、SSM、Vue、Html、Jsp、Nodejs等设计与开发。
🍅文末获取源码联系🍅
基于微信小程序的宿舍报修系统的设计与实现 一、前言 采用基于微信小程序的宿舍报修系统可以有效管理，使信息管理能够更加科学和规范。
基于微信小程序的宿舍报修系统使用Java语言进行编码，使用Mysql创建数据表保存本系统产生的数据。系统可以提供信息显示和相应服务，总之，基于微信小程序的宿舍报修系统集中管理信息，有着保密性强，效率高，存储空间大，成本低等诸多优点。它可以降低信息管理成本，实现信息管理计算机化。
关键词：基于微信小程序的宿舍报修系统；Java语言；Mysql
二、系统功能设计 在前面分析的管理员功能的基础上，进行接下来的设计工作，最终展示设计的结构图（见下图）：
三、系统实现 1、用户小程序功能模块 2、学生信息管理 如图5.1显示的就是学生信息管理页面，此页面提供给管理员的功能有：学生信息的查询管理，可以删除学生信息、修改学生信息、新增学生信息，还进行了对用户名称的模糊查询的条件。
图5.1 学生信息管理页面
3、维修人员管理 如图5.2显示的就是维修人员管理页面，此页面提供给管理员的功能有：查看已发布的维修人员数据，修改维修人员，维修人员作废，即可删除，还进行了对维修人员名称的模糊查询 维修人员信息的类型查询等等一些条件。
图5.2 维修人员管理页面
4、故障上报管理 如图5.3显示的就是故障上报管理页面，此页面提供给管理员的功能有：根据故障上报进行条件查询，还可以对故障上报进行新增、修改、查询操作等等。
图5.3 故障上报管理页面
5、论坛信息管理 如图5.4显示的就是论坛信息管理页面，此页面提供给管理员的功能有：根据论坛信息进行新增、修改、查询操作等等。
图5.4 论坛信息管理页面
四、数据库设计 1、实体ER图 （1）下图是论坛实体和其具备的属性。
图4.1 论坛实体属性图
（2）下图是学生实体和其具备的属性。
图4.2 学生实体属性图
（3）下图是维修人员实体和其具备的属性。
图4.3 维修人员实体属性图
（4）下图是字典表实体和其具备的属性。
图4.4 字典表实体属性图
（5）下图是故障上报实体和其具备的属性。
图4.5 故障上报实体属性图
（6）下图是故障上报评价实体和其具备的属性。
图4.6 故障上报评价实体属性图
（7）下图是用户表实体和其具备的属性。
图4.7 用户表实体属性图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5095ef4ad2c3460ea09805157b869ccd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbea9750212892d8414434d65948d477/" rel="bookmark">
			3秒实现无痛基于Stable Diffusion WebUI安装ComfyUI！无需重复安装环境！无需重复下载模型！安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标题略有夸张哈哈哈哈，但想表达的是，相较于直接下载或者通过秋叶包更新而，接下来这一套方案确实很简单，而且能够 大大节省磁盘空间，和下载时间。
这篇教程不需要你有：
代码基础。都是复制粘贴就完事。魔法。 这篇教程默认你已经有：
1. 本地能够正常使用的sd webui。无论是自己源码安装的，还是使用的秋叶包。如果没有的话就不适合哈。2. git环境。能从github上拉源码下来。这个教程很多就不多赘述了。第一次接触的话，学到能拉取代码到本地就可以，其他复杂的代码内容不用看，因为用不到。3. windows环境。 以下是正文：
====
1. 首先你需要把ComfyUI的源码克隆到本地来。 step1：找到你要把ComfyUI放到哪里的位置
操作：右键--显示更多选项--Git bash here
step2：通过代理网站ghproxy.com把github上对应的comfyui的代码拉下来。不需要新建文件夹，重命名哈，git clone的时候会自动创建一个。
操作：在打开的git面板中复制粘贴（用shift+insert粘贴，不是ctrl+v）这段代码，回车。
git clone https://ghproxy.com/https://github.com/comfyanonymous/ComfyUI.git 这里应该正常网速也应该10s就能好。远比从官方代码库下一个1个多G的安装包要快很多。
2. 把ComfyUI中的模型文件夹指向sd webui的。 step1：进入 ComfyUI_windows_portable\ComfyUI文件夹，找到 extra_model_paths.yaml.example文件，进行修改，以便ComfyUI可以直接用WebUI下已经下好的模型。
操作：修改第七行 改为 sd webui所在的总路径。保存后关闭。
也就是这个路径
3. 最后一步，用sd webui的环境把ComfyUI跑起来。 这里有两种情况：
如果你是自己安装的那么你的sd webui的环境大概率是在这个路径下：
"G:\xxx\stable-diffusion-webui\venv\Scripts\activate.bat"
如果你是秋叶包的那么你的sd webui的环境大概率是在这个路径下：
"G:\xxx\sd-webui-aki\sd-webui-aki-v4.1\sd-webui-aki-v4.1\python\Scripts\activate.bat"
G:\xxx 这里换成你自己的上层目录即可。
step1：把这个环境启动起来，通过cmd（命令提示符）。
操作：按win键输入cmd回车。然后输入刚才找到的路径，包括引号回车。快捷操作可以通过选中那个.bat文件，按ctrl+shift+c复制到这个文件的路径，然后在cmd中用shift+insert粘贴。
回车之后应该就进入这个python环境中了。前面括号里是当时创建的环境名称， 秋叶版的就会显示为python。
step2：启动comfyui的脚本。
操作：找到comfyui中的main.py文件，也就是以后用来启动comfyui的文件。在刚才打开的环境中输入后回车：
python G:\ComfyUI\main.py PS： G:/替换为自己的路径。注意：区分/ \。
看到最后一行 http://127.0.0.2:8188 就说明启动成功了。按住ctrl鼠标点击这个地址就会打开comfyUI的界面。初次尝试记得替换这个位置的模型，不然会报错找不到默认的模型文件。
下次启动执行，重复第三步就可以。有人看，我再写一些怎么优化启动这里 。
就这样 Good Luck！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/882d14f360d8130a9839d3f7a31a185e/" rel="bookmark">
			Nacos、Eureka、Zookeeper、Consul对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发中，经常需要对微服务进行管理，所以需要引入一些服务治理的中间件，用于注册、发现服务，常见的服务治理中间件为
服务治理中间件 【1】Nacos
【2】Eureka
【3】Zookeeper
【4】Consul（Consul 所在的 HashiCorp 公司宣布，不允许中国境内使用该公司旗下的产品和软件。）
对比一览表 名称NacosEurekaZookeeperConsul开发语言JavaJavaCJava功能特性服务注册&amp;发现、配置管理、流量控制、DNS、动态DNS服务注册&amp;发现数据存储、协调服务注册&amp;发现、配置管理应用场景K8S、Service Mesh、SpringCloudSpringCloudHadoop分布式集群K8S、SpringCloudCAP理论CP/APAPCPCP运行模式自主部署、集群模式自主部署、集群模式需独立部署、启动集群其它OpenAPI标准、支持多语言Spring开发、易于集成开发者阿里巴巴NetFilxApache基金会 CAP理论 CP：Consistency and Partition tolerance 一致性与分区容错度
AP：Availability and Partition tolerance 可用性与分区容错度
一致性（C）：确保分布式系统中的所有数据备份在同一时刻具有相同的值，即所有节点访问同一份最新的数据副本。
~
可用性（A）：在集群中一部分节点发生故障后，集群整体仍然能够响应客户端的读写请求，保持服务的高可用性。
~
分区容错性（P）：在分布式系统中，由于网络分区等原因，系统可能会无法与部分节点通信，此时系统必须能够继续提供服务，即使是在部分节点不可用的情况下。
CAP三者是相互矛盾的！
一个分布式系统，不能同时将CAP都很好的满足，只能满足其中两者，所以可以使用AP策略、也可以用CP策略
功能特性 Nacos是一个全栈的解决方案，而支持服务发现、配置管理和流量管理等多个功能。
Eureka专注于服务注册和发现、适用于SpringCloud体系。
Zookeeper则是一个通用的分布式数据存储和协调系统，适用于大规模分布式系统的场景
Consul与Nacos基本相同
负载均衡 Nacos 本身具备负载均衡能力，可以提供服务端负载均衡与客户端负载均衡。
Zookeeper 不支持。
Eureka 本身不支持，通过Ribbon做负载均衡。
Consul 本身不支持，通过Fabio做负载均衡。
健康检查 服务端健康检查最常见的方式是 TCP 端口探测和 HTTP 接口返回码探测，这两种探测方式因为其协议的通用性可以支持绝大多数的健康检查场景。Zookeeper 和 Eureka 都实现了⼀种 TTL(Time To Live)机制，就是如果客户端在⼀定时间内没有向注册中心发送心跳，则会将这个客户端摘除。
Zookeeper 使用TCP的KeepAlive保持客户端和服务端的连接。
Eureka 通过客户端心跳来确定客户端是否启动。
Consul 通过check方法实现健康检查，check方法有五种：Script + Interval、HTTP + Interval、TCP+ Interval、Docker + interval、TTL。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/882d14f360d8130a9839d3f7a31a185e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef9dd16d3a353e5405ef1ea12501962e/" rel="bookmark">
			工业制造：分布式控制系统（DCS），一文掌握。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是DCS 在工业制造领域，DCS 是分布式控制系统（Distributed Control System）的缩写。DCS 是一种用于监控和控制工业生产过程的自动化系统，通常由一组分布在工厂各个位置的控制单元和计算机组成，用于实时监测和控制生产过程中的各种参数和设备。
二、DCS组件与功能 DCS 系统通常包括以下主要组件和功能：
1. 控制器：负责监测和控制生产过程中的各种设备和参数，如温度、压力、流量等。
2. 输入/输出模块：用于将传感器和执行器的信号输入到控制器中，并将控制器的指令传输给执行器。
3. 人机界面（HMI）：提供给操作人员的图形化界面，用于监视生产过程、设备状态和报警信息，并进行操作和控制。
4. 数据存储和处理：DCS 系统可以对生产过程中的数据进行采集、存储和处理，以便进行生产过程的分析和优化。
5. 网络通信：DCS 系统中的各个组件通过网络进行通信和数据交换，实现分布式的控制和监控。
DCS 系统通常用于工业制造领域的连续生产过程，如化工厂、电厂、制药厂、炼油厂等，能够实现对生产过程的高度自动化和集中控制，提高生产效率、降低成本、确保产品质量，并能够对生产过程进行实时监测和调整。
三、DCS的价值 分布式控制系统（DCS）在工业制造领域具有重要的价值，其主要体现在以下几个方面：
1. 自动化控制：DCS 可以实现对工业生产过程的高度自动化控制，通过实时监测和调节参数，提高生产效率，减少人为干预，降低人为操作误差，提高生产的稳定性和一致性。
2. 实时监测和报警：DCS 系统可以实时监测生产过程中的各种参数和设备状态，并能够及时发出报警信息，帮助操作人员快速发现和处理生产过程中的异常情况，确保生产安全和设备完整性。
3. 数据采集和分析：DCS 系统可以对生产过程中的数据进行采集、存储和分析，帮助企业实现对生产过程的数据化管理，为生产过程的优化和改进提供数据支持。
4. 降低成本和提高效率：通过自动化控制和实时监测，DCS 可以降低生产过程中的能耗、原材料消耗和人力成本，提高生产效率和产品质量，从而降低生产成本，提高企业竞争力。
5. 灵活性和可扩展性：DCS 系统具有较强的灵活性和可扩展性，可以根据生产过程的需求进行定制和调整，支持不同类型的生产设备和工艺流程，满足不同行业和企业的需求。
总之，DCS 系统在工业制造领域的价值主要体现在提高生产效率、降低成本、保证产品质量、实现自动化控制和实时监测等方面，对于企业的生产管理和经济效益具有重要意义。
贝格前端工场→10年前端开发和UI设计老司机了，持续为大家分享有价值、有见地的观点、作品、干活，欢迎评论、关注、点赞、帮助的老铁，可私信。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9837384ab386ff91b77a8cd713bb299c/" rel="bookmark">
			HiveSQL题——前后函数(lag/lead)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、窗口函数的知识点
1.1 窗户函数的定义
1.2 窗户函数的语法
1.3 窗口函数分类
1.4 前后函数:lag/lead
二、实际案例
2.1 股票的波峰波谷
0 问题描述
1 数据准备
2 数据分析
3 小结
2.2 前后列转换（面试题）
0 问题描述
1 数据准备
2 数据分析
3 小结
一、窗口函数的知识点 1.1 窗户函数的定义 窗口函数可以拆分为【窗口+函数】。窗口函数官网指路：LanguageManual WindowingAndAnalytics - Apache Hive - Apache Software Foundationhttps://cwiki.apache.org/confluence/display/Hive/LanguageManual+WindowingAndAnalytics
窗口：定义函数计算范围（窗口函数：针对分组后的数据，从逻辑角度指定计算的范围，并没有从物理上真正的切分，只有group by 是物理分组，真正意义上的分组）函数：定义函数计算逻辑sql 执行顺序： from -&gt; join -&gt; on -&gt; where -&gt; group by-&gt; with (可以在分组后面加上 with rollup,在分组之后对每个组进行全局汇总) -&gt; select 后面的普通字段，聚合函数-&gt; having(having中可以使用select 字段别名) -&gt; distinct -&gt; order by -&gt; limit 窗口函数执行顺序：窗口函数是作用于select后的结果集。select 的结果集作为窗口函数的输入，但是位于 distcint 之前。窗口函数的执行结果只是在原有的列中单独添加一列，形成新的列，它不会对已有的行或列做修改。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9837384ab386ff91b77a8cd713bb299c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3252fa0ee5a0eadccf308cdf95ce1720/" rel="bookmark">
			MongoDB聚合：分组统计$group的用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MongoDB不像关系型数据库，普通的查询不支持汇总，要进行复杂的分组汇总，需要使用聚合管道，$group可以说是MongoDB聚合管道进行数据分析最常用的一个阶段。该阶段根据分组键值（组键）把文档分成若干组，每个唯一的键值对应一个文档。组键通常是一个或多个字段，也可以是表达式的结果。$group阶段输出的结果中，_id字段的值就是组键的值，输出文档中还可以包含汇总表达式的字段，汇总表达式的功能非常丰富，下面的列表会简单介绍，具体的使用方法可以参考详细说明。
$group的语法 { $group: { _id: &lt;expression&gt;, // 组键，就是分组的键值字段或表达式 &lt;field1&gt;: { &lt;accumulator1&gt; : &lt;expression1&gt; }, ... } } 字段说明：
字段说明_id不可省略，通过_id表达式指定分组的依据，如果直接指定_id的值为null或常量，则把全部的输入文档汇总后返回一个文档field可选，汇总表达式计算的结果_id和field可以是任何合法的表达式。 分组汇总操作符 分组汇总操作符比较多，功能丰富且强大，这里简要介绍其用途，详细的用法后续再专文介绍。
操作符用途介绍$accumulator返回累加结果$addToSet把分组中不重复的表达式的值作为数组返回，注意数组的元素无序的，类似分组内的distinct$avg返回数值的平均值。非数值会被忽略$bottom按照指定的顺序返回分组中最后一个元素$bottomN按照指定的顺序返回分组中最后N个元素字段的集合，如果分组元素数量小于N，则返回全部$count返回分组内的元素数量$first返回分组内第一个元素表达式的结果$firstN返回分组内前n个元素的聚合。只有文档有序时才有意义$last返回分组中最后一个文档的表达式的结果$lastN返回分组内最后n个元素的聚合。只有文档有序时才有意义$max返回每个分组表达式值的最大值$maxN返回分组内最大的n个元素的集合$median返回分组中的中位数$mergeObjects返回分组合并后的文档$min返回分组内表达式的最小值$percentile返回与指定百分位数值相对应的值的数组$push返回每个分组表达式值的数组$stdDevPop返回标准差$stdDevSamp返回样本标准差$sum返回合计值，忽略空值$top根据指定的顺序返回组内最前面的元素$topN根据指定的顺序返回组内前N个元素的聚合 注意 $group使用内存不能超过100M，超过会报错。如果想要处理更多数据或者少用一些内存，可使用allowDiskUse选项把数据写入临时文件。当使用$first、$last等操作符时，可以考虑在参与排序的分组字段上添加索引，某些情况下，这些操作可以使用索引快速定位到相应的记录。 一些例子 统计数量 创建并插入数据：
db.sales.insertMany([ { "_id" : 1, "item" : "abc", "price" : Decimal128("10"), "quantity" : Int32("2"), "date" : ISODate("2014-03-01T08:00:00Z") }, { "_id" : 2, "item" : "jkl", "price" : Decimal128("20"), "quantity" : Int32("1"), "date" : ISODate("2014-03-01T09:00:00Z") }, { "_id" : 3, "item" : "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3252fa0ee5a0eadccf308cdf95ce1720/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eb83c6865e55cf156af3c59d4f78163/" rel="bookmark">
			java连接SQL Server（自用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.基础配件 SQL Server版本：2022
JDK版本：21
java编译器：IDEA
JDBC版本：12.6（x64版本）
2.准备工作 2.1 SQL Server的准备工作 打开SQL Server的配置管理器，将SQL Server的网络配置下的MSSQLSERVER中的TCP/IP以及Named Pipes打开，如图所示：
打开TCP/IP的属性，进入IP地址选项块，将IP1、IP10以及IP14的的IP的地址改为IPV4地址：127.0.0.1。然后将所有的TCP端口改为1433，如图所示：
进入SQL Server Management Studio，使用Windows验证登录后，选中数据库服务器，打开，选择 安全性-&gt;登录名-&gt;sa，右键点击属性，进入后设置密码。（密码：123456）
2.2 IDEA的准备工作 新建一个项目（我命名为learn），打开该项目，把对应版本的JDBC jar包拖入External Libraries中。
3.调试工作 在代码中import java.sql.*，然后进行代码调试，具体代码如下：
import java.sql.*; public class Main { public static void main(String[] args) { String url = "jdbc:sqlserver://192.168.0.131:1433;databaseName=test;integratedSecurity=false;encrypt=true;trustServerCertificate=true;"; Connection conn; try { conn = DriverManager.getConnection(url,"sa","123456"); Statement stat = conn.createStatement();//创建一个 Statement 对象来将 SQL 语句发送到数据库。 ResultSet resultSet=stat.executeQuery("select * from student"); while (resultSet.next()) { System.out.println(resultSet.getString("id")); } } catch (SQLException e) { // TODO Auto-generated catch block e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6eb83c6865e55cf156af3c59d4f78163/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f8f63ee7957937ba9c302851310a3c1/" rel="bookmark">
			C语言经典算法之k最近邻（K-Nearest Neighbor, KNN）算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
A.建议
B.简介
一 代码实现
二 时空复杂度
A.时间复杂度：
B.空间复杂度：
C.总结：
三 优缺点
A.优点：
B.缺点：
四 现实中的应用
前言 A.建议 1.学习算法最重要的是理解算法的每一步，而不是记住算法。
2.建议读者学习算法的时候，自己手动一步一步地运行算法。
B.简介 k最近邻（K-Nearest Neighbor, KNN）算法是一种基于实例的学习方法，主要用于分类和回归问题。在机器学习中，它不预先假设数据分布模型，而是直接存储训练样本，并在预测阶段根据新样本与已有训练样本之间的相似度进行决策。
一 代码实现 使用C语言实现K最近邻（K-Nearest Neighbor, KNN）算法通常涉及以下步骤：
定义数据结构： 首先，需要定义存储训练样本和测试样本的数据结构。这可能包括特征向量、类标签以及用于计算距离的函数指针等。
typedef struct { double *features; // 特征向量，例如double features[N_FEATURES]; int label; // 类别标签 } Sample; // 假设我们已经有了一个预处理好的样本集 Sample trainingSet[TRAINING_SET_SIZE]; 计算距离： 选择一种距离度量方法，如欧氏距离或曼哈顿距离，并编写函数来计算测试样本与每个训练样本之间的距离。
double euclideanDistance(Sample s1, Sample s2) { int i; double distance = 0.0; for (i = 0; i &lt; N_FEATURES; ++i) { distance += pow(s1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f8f63ee7957937ba9c302851310a3c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3703c66fd7f64ce172e31bea7e61b5b0/" rel="bookmark">
			毕业设计：基于Web的统一身份认证信息系统 python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
项目背景
设计思路
2.1 用户口令认证
2.2 基于智能卡的认证
2.3 统一身份认证
相关代码
更多帮助
前言 📅大四是整个大学期间最忙碌的时光,一边要忙着备考或实习为毕业后面临的就业升学做准备,一边要为毕业设计耗费大量精力。近几年各个学校要求的毕设项目越来越难,有不少课题是研究生级别难度的,对本科同学来说是充满挑战。为帮助大家顺利通过和节省时间与精力投入到更重要的就业和考试中去,学长分享优质的选题经验和毕设项目与技术思路。
🚀对毕设有任何疑问都可以问学长哦!
大家好,这里是海浪学长信息毕设专题,本次分享的课题是
🎯基于Web的统一身份认证信息系统
项目背景 随着互联网应用的广泛普及，多账号管理成为用户日常使用中的一大困扰。为解决这一问题，基于Web的统一身份认证信息系统成为了研究的焦点。该系统旨在为用户提供一个统一的登录入口，简化操作流程，提高账号安全。通过统一身份认证，不仅可以减少用户在不同平台重复注册、登录的繁琐操作，还可以增强账号的安全防护，降低因账号信息泄露带来的风险。对于企业和组织而言，统一身份认证信息系统可提高服务质量，增强用户忠诚度，进而提升市场竞争力。因此，本课题的研究具有重要的现实意义和应用价值。
设计思路 2.1 用户口令认证 基于口令的认证方法是一种简单实用的认证技术，用户通过输入用户名和口令进行验证。然而，它存在安全性问题，如口令容易泄露、网络传输风险、口令存储风险、口令复用风险和缺乏双向认证。尽管可以采取一些解决方案来增加安全性，但仍需要注意口令的保护和系统安全的强化。
2.2 基于智能卡的认证 基于智能卡的认证是一种通过内置 CPU 和存储器的智能卡技术来实现数据存储、运算和加密的认证方法。该方法将用户信息存储在智能卡中，并将事先选择的随机数存储在认证服务器中。用户在需要访问系统资源时，通过输入身份信息和密码，智能卡对用户身份进行认证，并将存储在智能卡中的随机数发送给认证服务器进行进一步认证。这种认证方案的安全性主要依赖于智能卡的物理安全性，因为用户很难伪造智能卡或直接读取其中的数据。即使用户丢失智能卡，入侵者也需要知道用户的密码才能访问系统资源。因此，基于智能卡的认证具有极高的安全性。
2.3 统一身份认证 身份认证组件模式是一种将身份认证的组件模块独立于应用系统中的模式。在这种模式下，该组件模块提供用户登录界面，并接收用户输入的用户名和密码。然后，它将接收到的用户信息传递给统一身份认证系统进行验证，而不对用户信息进行处理。应用系统本身不具备用户系统，因此输入的用户账号必须是统一身份认证服务器中注册的账号。
具体流程如下：
用户访问应用系统A的登录界面，输入在统一认证服务器中注册的用户名和密码，提交。应用系统A接收用户登录信息，并将用户信息和应用系统A的标识通过网络传送给统一认证服务（Service），请求对用户身份进行验证。统一认证服务接收应用系统A的请求，检查应用系统A是否已注册，并从用户注册数据库中检索用户信息，以验证传递过来的用户是否合法。如果验证通过，统一认证服务对应用系统A做出响应，用户完成登录操作。应用系统A为通过认证的用户创建一个系统会话（Session），并将代表用户在该应用系统A中拥有的权限的令牌返回给用户。用户可以在会话周期内使用该权限令牌访问应用系统A，直到退出系统或会话超时。 相关代码 ser_database = { "user1": { "password": "password1", "roles": ["admin", "user"] }, "user2": { "password": "password2", "roles": ["user"] } } def authenticate(username, password): if username in user_database: user = user_database[username] if password == user["password"]: return True return False @app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3703c66fd7f64ce172e31bea7e61b5b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3d561b1e1d45c026b402be4eae56bc9/" rel="bookmark">
			一文彻底搞懂Kafka如何保证消息不丢失
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. kafka 架构2. producer端是如何保证数据不丢失的2.1 同步发送2.2 异步发送2.3 批量发送 3. consumer端是如何保证数据不丢失的3.1 手动提交3.2 幂等性消费 4. broker端是如何保证数据不丢失的4.1 副本机制4.2 ISR机制4.3 刷盘机制 1. kafka 架构 Producer：生产者，发送消息的一方。生产者负责创建消息，然后将其发送到 Kafka。
Consumer：消费者，接受消息的一方。消费者连接到 Kafka 上并接收消息，进而进行相应的业务逻辑处理。
Consumer Group：将多个消费者组成一个消费者组，一个消费者组可以包含一个或多个消费者。使用多分区 + 多消费者方式可以极大提高数据下游的处理速度，同一消费组中的消费者不会重复消费消息，同一个消费者组的消费者可以消费同一个topic的不同分区的数据。Kafka 就是通过消费组的方式来实现消息 P2P 模式和广播模式。
Broker：服务代理节点。Broker 是 Kafka 的服务节点，是 kafka 一个实例，每个服务器上有一个或多个 kafka 的实例，简单的理解就是一台 kafka 服务器，kafka cluster表示集群的意思
Topic：消息的主题，可以理解为消息队列，kafka的数据就保存在topic。Kafka 中的消息以 Topic 为单位进行划分，生产者将消息发送到特定的 Topic，而消费者负责订阅 Topic 的消息并进行消费。
Partition：Topic 是一个逻辑的概念，它可以细分为多个分区，每个 topic 可以有多个分区，分区的作用是做负载，提高 kafka 的吞吐量。每个分区只属于单个主题，同一个主题下不同分区包含的消息是不同的，partition 的表现形式就是一个一个的文件夹，分区在存储层面可以看作一个可追加的日志（Log）文件，消息在被追加到分区日志文件的时候都会分配一个特定的偏移量（offset）。
Offset：offset 是消息在分区中的唯一标识，Kafka 通过它来保证消息在分区内的顺序性，不过 offset 并不跨越分区，也就是说，Kafka 保证的是分区有序性而不是主题有序性。
Replication：副本，是 Kafka 保证数据高可用的方式，Kafka 同一 Partition 的数据可以在多 Broker 上存在多个副本，通常只有主副本对外提供读写服务，当主副本所在 broker 崩溃或发生网络异常，Kafka 会在 Controller 的管理下会重新选择新的 Leader 副本对外提供读写服务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3d561b1e1d45c026b402be4eae56bc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee0c84d59714a36880a82e8ec6d9edf5/" rel="bookmark">
			Hadoop红色旅游景点分析系统设与实现-附源码 91858
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录 摘要 1 绪论 1.1研究背景 1.2研究内容 2
1.3Hadoop优点 3
1.4 Hadoop框架介绍 3
1.5论文结构与章节安排 4
2 红色旅游景点分析系统系统分析 5
2.1 可行性分析 5
2.2 系统流程分析 5
2.2.1数据增加流程 5
2.2.2数据修改流程 6
2.2.3数据删除流程 6
2.3 系统功能分析 7
2.3.1 功能性分析 7
2.3.2 非功能性分析 7
2.4 系统用例分析 8
2.5本章小结 8
3 红色旅游景点分析系统总体设计 3.1 系统架构设计 8
3.2 系统功能模块设计 9
3.2.1整体功能模块设计 3.2.2用户模块设计 3.2.3评论管理模块设计 3.2.4景点管理模块设计 3.3 数据库设计 3.3.1 数据库概念结构设计 3.3.2 数据库逻辑结构设计 3.4本章小结 20
4 红色旅游景点分析系统详细设计与实现 21
4.1用户功能模块 21
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee0c84d59714a36880a82e8ec6d9edf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a624fdb989665f841c42bf372596db5/" rel="bookmark">
			旅游|基于Springboot的旅游管理系统设计与实现(源码&#43;数据库&#43;文档)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		旅游管理系统目录
目录
基于Springboot的旅游管理系统设计与实现
一、前言
二、系统功能设计
三、系统实现 1、用户管理
2、景点分类管理
3、景点信息管理
4、酒店信息管理
5、景点信息
6、游记分享管理
四、数据库设计
1、实体ER图
2、具体的表设计如下所示：
五、核心代码 六、论文参考
七、最新计算机毕设选题推荐
八、源码获取：
博主介绍：✌️大厂码农|毕设布道师，阿里云开发社区乘风者计划专家博主，CSDN平台Java领域优质创作者，专注于大学生项目实战开发、讲解和毕业答疑辅导。✌️
主要项目：小程序、SpringBoot、SSM、Vue、Html、Jsp、Nodejs等设计与开发。
🍅文末获取源码联系🍅
👉 毕设答疑 👈
基于Springboot的旅游管理系统设计与实现 一、前言 此旅游管理系统利用当下成熟完善的Spring Boot框架，使用跨平台的可开发大型商业网站的Java语言，以及最受欢迎的RDBMS应用软件之一的MySQL数据库进行程序开发。旅游管理系统有管理员，用户两个角色。管理员功能有个人中心，用户管理，景点分类管理，景点信息管理，景点购票管理，酒店信息管理，酒店预定管理，游记分享管理，系统管理。用户可以注册登录，查看景点信息，并且可以进行景点购票操作和酒店预定操作，还可以发布游记分享。旅游管理系统的开发根据操作人员需要设计的界面简洁美观，在功能模块布局上跟同类型网站保持一致，程序在实现基本要求功能时，也为数据信息面临的安全问题提供了一些实用的解决方案。可以说该程序在帮助使用者高效率地处理工作事务的同时，也实现了数据信息的整体化，规范化与自动化。
关键词：旅游管理系统；Spring Boot框架；MySQL；自动化
二、系统功能设计 在分析并得出使用者对程序的功能要求时，就可以进行程序设计了。如图展示的就是管理员功能结构图。
三、系统实现 1、用户管理 如图5.1显示的就是用户管理页面，此页面提供给管理员的功能有：对用户信息进行查询，添加，删除以及批量删除操作。
图5.1 用户管理页面
2、景点分类管理 如图5.2显示的就是景点分类管理页面，管理员可以对景点分类进行添加，修改，删除，查询操作。
图5.2 景点分类管理页面
3、景点信息管理 如图5.3显示的就是景点信息管理页面，管理员可以对景点信息信息进行添加，修改，删除，查询操作。
图5.3 景点信息管理页面
4、酒店信息管理 如图5.4显示的就是酒店信息管理页面，管理员可以对酒店信息进行添加修改删除查询操作。
图5.4 酒店信息管理页面
5、景点信息 如图5.4显示的就是景点信息页面，用户注册登录后可以在景点信息里面点击购票。
图5.5 景点信息页面
6、游记分享管理 如图5.4显示的就是游记分享页面，用户登录后可以在自己的后台管理里面的游记分享对自己的游记分享信息进行添加，修改，删除，查询操作。
图5.6 游记分享页面
四、数据库设计 1、实体ER图 旅游管理系统的E-R图如下图所示：
（1）管理员实体属性图见图4.4。
图4.4 管理员实体属性图
（2）用户实体属性图见图4.5。
图4.5 用户实体属性图
（3）景点分类实体属性图见图4.6。
图4.6 景点分类实体属性图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a624fdb989665f841c42bf372596db5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21588556b5246c7046663656f5644dae/" rel="bookmark">
			macOS苹果系统怎么用vs code编译c&#43;&#43;？图文详解，很简单！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先从官网下载macOS版本vs code（因为系统应用商店没有vs code）点击这个链接：
下载 Visual Studio Code - Mac、Linux、Windowshttps://code.visualstudio.com/download下载这个“苹果版本”
然后运行
下载“Chinese”中文插件，然后重新加载。
再次打开就是中文界面了！
再下载C/C++和C/C++ Clang Command Adapter插件并重新加载
然后打开系统的终端
输入clang --version，如果没安装就选择安装，有的话应该会显示这个：
选择一个地方新建一个英文命名的文件夹，在vs code里选择打开文件夹，打开它
再点击新建文件，命名为“test.cpp”
在test里面输入一个测试代码，不要运行：
#include&lt;bits/stdc++.h&gt; using namespace std; int main(){ cout&lt;&lt;"hello!!! test.ok"&lt;&lt;endl; return 0; } 然后按下 command + shift + P 调出面板，输入C/C++，选择编辑配置(UI)，如下图示。
分别做如下更改：
改完后你的vscode 文件夹 c_cpp_properties.json 文件内容应该是这样的：
然后在 test.cpp 界面，按下 command + shift + P ，输入 tasks，选择“任务：配置默认生成任务”，然后选择“ C/C++: clang++ 生成活动文件”，如下图示。
选择这个：
这时vscode 文件夹中多出一个 tasks.json 文件，如下图示：
在 test.cpp 界面，按下 command + shift + P 调出面板，输入 debug，选择调试：开始调试，如下图示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21588556b5246c7046663656f5644dae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f328b417b3d3b1338c0597d1267638b/" rel="bookmark">
			前后端通讯：前端调用后端接口的五种方式，优劣势和场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hi，我是贝格前端工场，专注前端开发8年了，前端始终绕不开的一个话题就是如何和后端交换数据（通讯），本文先从最基础的通讯方式讲起。
一、什么是前后端通讯 前后端通讯（Frontend-Backend Communication）指的是前端和后端之间进行数据交互和通信的过程。在Web开发中，前端通常负责展示数据和用户交互，后端负责处理业务逻辑和数据存储。为了实现前后端的数据交互和通信，需要使用一些通信方式和协议。
前后端通讯的目的是实现数据的传输和交互，以满足前端的功能需求和后端的业务逻辑。通过合适的通讯方式和协议，可以实现高效的前后端协作和数据交互。
二、前端调用后端接口的五种方式 前端调用后端接口有以下几种常见的方式：
前后端不分离
Ajax：使用JavaScript的Ajax技术向后端发送HTTP请求并接收响应。可以使用原生的XMLHttpRequest对象或现代的Fetch API来实现Ajax请求。Ajax可以实现异步通信，无需刷新整个页面，可以在后台与服务器进行数据交互。Axios.js：Axios.js是一个基于Promise的HTTP客户端库，可以用于发送HTTP请求。它可以在浏览器和Node.js环境中使用，提供了简洁的API和丰富的功能，如请求拦截、响应拦截、取消请求等。Fetch API：Fetch API是浏览器原生提供的一组用于发送HTTP请求的API。它提供了更现代化和简洁的方式来发送请求，并返回一个Promise对象。Fetch API支持异步通信，可以设置请求头、发送不同类型的数据等。WebSocket：WebSocket是一种全双工通信协议，可以在浏览器和服务器之间建立持久的连接。通过WebSocket，前端可以与后端进行实时通信，而不需要通过轮询或长轮询来获取数据。RESTful API：RESTful API是一种基于HTTP协议的API设计规范，可以通过HTTP的GET、POST、PUT、DELETE等方法来访问后端资源。前端可以使用Ajax、Axios.js等工具来发送HTTP请求，调用后端的RESTful API进行数据交互。 以上是一些常见的前端调用后端接口的方式。具体使用哪种方式取决于项目需求和个人偏好。
三、他们之间有什么区别和优劣势 这些前端调用后端接口的方式各有优劣势，下面是它们之间的区别和一些常见的优劣势：
Ajax：
优势：使用广泛，兼容性好，可以实现异步通信，无需刷新整个页面，可以在后台与服务器进行数据交互。劣势：需要手动处理请求和响应，代码相对繁琐，不支持跨域请求（需要使用CORS或代理解决）。 Axios.js：
优势：基于Promise，使用简单，提供了丰富的功能，如请求拦截、响应拦截、取消请求等，支持浏览器和Node.js环境。劣势：需要引入第三方库，增加项目的依赖。 Fetch API：
优势：是浏览器原生提供的API，使用简洁，返回Promise对象，支持异步通信，支持设置请求头、发送不同类型的数据。劣势：兼容性不如Ajax，不支持取消请求。 WebSocket：
优势：支持实时通信，建立持久连接，可以双向通信，适用于需要实时更新数据的场景。劣势：相对复杂，需要服务器端支持WebSocket协议。 RESTful API：
优势：基于HTTP协议，使用简单，规范性强，易于理解和维护，适用于大多数Web应用。劣势：不适用于实时通信，需要服务器端提供相应的API支持。 综合考虑，选择合适的方式取决于具体的项目需求和开发环境。
四、分别使用什么场景 不同的前端调用后端接口方式适用于不同的场景，下面是它们常见的应用场景：
Ajax：
适用于需要在页面上实现异步交互的场景，如表单提交、数据加载等。可以用于实现无需刷新整个页面的局部更新，提升用户体验。适用于需要与后端进行数据交互，但不需要实时通信的场景。 Axios.js：
适用于需要在浏览器和Node.js环境中发送HTTP请求的场景。提供了更丰富的功能，如请求拦截、响应拦截、取消请求等，适用于复杂的数据交互需求。可以用于处理并发请求，提供更好的性能和用户体验。 Fetch API：
适用于现代化的浏览器环境，可以使用浏览器原生提供的API发送HTTP请求。提供了更简洁的方式来发送请求，并返回Promise对象，适用于简单的数据交互需求。支持设置请求头、发送不同类型的数据，适用于处理多种数据格式的场景。 WebSocket：
适用于需要实时通信的场景，如聊天应用、实时数据更新等。可以建立持久连接，支持双向通信，适用于需要频繁更新数据的场景。相对复杂，需要服务器端提供WebSocket协议的支持。 RESTful API：
适用于构建标准化的Web应用，通过HTTP的GET、POST、PUT、DELETE等方法来访问后端资源。可以实现前后端的数据交互和资源管理，适用于大多数Web应用。不适用于实时通信的场景，需要其他方式来实现实时数据更新。 需要根据具体的项目需求和开发环境选择合适的方式。一般来说，Ajax和Axios.js是常用的方式，适用于大多数场景。Fetch API是现代化的方式，适用于浏览器原生环境。WebSocket适用于需要实时通信的场景。RESTful API适用于构建标准化的Web应用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96bff700c0ba46d90e8e74baa6e87b4f/" rel="bookmark">
			Python SimpleHTTPServer - Python HTTP 服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python SimpleHTTPServer Python SimpleHTTPServer 模块是一个非常方便的工具。您可以使用 Python SimpleHTTPServer 将任何目录转换为简单的 HTTP web 服务器。
Python SimpleHTTPServer 仅支持两种 HTTP 方法 - GET 和 HEAD。因此，它是一个很好的工具，可以在网络上共享文件。Python SimpleHTTPServer 已经迁移到了 Python 3 中的 python http.server 模块，今天我们将学习这两个模块，并看看它们的使用是多么简单。假设您和您的朋友正在使用同一个本地网络。您有一些文件想要与您的朋友分享。但是你们两个都有便携式硬盘，这样你就可以将这些电影复制到便携式硬盘上并交给你的朋友。然后 Python SimpleHTTPServer 可以帮助您。通过使用 SimpleHTTPServer，您可以轻松地与在同一网络中的朋友分享文件。在本教程中，我们将学习 Python SimpleHTTPServer 的基础知识，以便您可以在日常生活中使用它。
Python Simple HTTP Server 如果您使用的是 Windows 操作系统，则转到您想要共享的文件夹或目录。现在，使用 shift+右键。您将找到在该目录中打开命令提示符的选项。只需单击它，在那里打开命令提示符。但是，如果您使用的是 Ubuntu，则只需右键单击该目录并打开终端。之后，执行以下命令。
$python -m SimpleHTTPServer 9000 您可以在任何端口上运行 python http 服务器，默认端口是 8000。尝试使用大于 1024 的端口号以避免冲突。然后打开您喜爱的浏览器，输入 localhost:9000。是的！你完成了！现在知道你的 IP 地址，然后用你的 IP 地址替换 localhost，然后与您的朋友分享。
Python SimpleHTTPServer 错误 - No module named SimpleHTTPServer 如果您正在运行 Python 3，您将收到错误消息 No module named SimpleHTTPServer。这是因为在 Python 3 中，SimpleHTTPServer 已经合并到 http.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96bff700c0ba46d90e8e74baa6e87b4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf33f82e51cd2af95477a825da7aeda5/" rel="bookmark">
			C语言：深入理解指针(3)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创作不易，友友们给个三连吧！！ 通过深入理解指针（1）和深入理解指针（2），我们对指针有了一个初步的了解，学会了一级指针、二级指针、指针数组……而深入理解指针（3），主要是为了学习不同数据类型的指针变量。
一、字符指针变量 字符串指针变量的指针类型为char*，下面我们通过这段代码来解析字符指针变量。
int main() { printf("指针接收字符\n"); char ch = 'w'; char* pc = &amp;ch; printf("\t*pc=%c\n", *pc); printf("----------------\n"); printf("指针接收字符串\n"); const char* pstr = "abcdef";//const 加了一层保护，使其变成常量字符串，被修改编译器会报错 printf("\t*pstr=%c\n", *pstr);//其实是把字符串的首字符地址放到pstr,字符串出现在表达式中时，他的值就是第一个字符的地址 printf("\tpstr=%s\n", pstr); //%s占位符的特点就是只要告诉他字符串的首地址, 就可以读取整个字符串 printf("\tpstr[3]=%c\n", pstr[3]);//[]是特殊的解引用操作符，等价于*（pstr+3），相当于得到第1个元素偏移3得到第四个元素 printf("\tabcdef[3] = % c\n", "abcdef"[3]);//可以把字符串想象成一个字符数组，可以通过下标去访问他 return 0; } 指针接收字符
*pc=w
----------------
指针接收字符串
*pstr=a
pstr=abcdef
pstr[3]=d
abcdef[3] = d 字符指针变量，顾名思义就是指向字符的指针变量，所以利用指针接收字符的地址（第31行代码），最后解引用该指针变量得到的是对应的字符，非常容易理解。 但字符指针变量还有一种方式，就是接收字符串的地址。
通过第35行代码，我们用字符指针变量pstr接收了字符串“abcdef”，那这是把整个字符串放到pstr指针变量里面了吗？
其实并不是的，我们通过第36行代码的运行结果，发现将指针变量pstr解引用后得到的是‘a’，这说明字符指针变量pstr接收字符串的本质是将字符串的首字符地址存放到pstr中，所以如果字符串出现在表达式中，他的值就是第一个字符的地址。
既然pstr存放的是字符串首字符的地址，那么我们打印出来的是一个地址，但我们在看向第37行代码，当我们用%s的占位符时，却可以直接将整个字符串打印出来，这说明了%s占位符的特点就是只要告诉他字符串首字符的地址，他就可以直接读取整个字符串。
那为什么，我们知道了字符串的首元素地址，就可以通过%s打印出字符串全体呢？这是因为其实我们可以把字符串理解成一个字符数组，他具有数组的特点，可以通过首元素地址找到后面的全部元素，并且也可以像数组一样通过下标去访问每个元素，比如我们想访问字符串下标为3的元素（d），那么通过第39行代码我们可以发现“abcdef”[3]是可行的，
既然可以通过下标去访问字符串，那么既然pstr是接收字符串的指针变量，那么我们同样可以通过首元素地址的指针偏移来找到下标为3的元素，第38行代码中的pstr[3]（等价“*（pstr+3）”）也是可行的。
下面是一道和字符串相关的面试题。
int main() { char str1[] = "hello bit."; char str2[] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf33f82e51cd2af95477a825da7aeda5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfa60cb93069c863b767cc1e56657ec2/" rel="bookmark">
			C语言：深入理解指针(2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创作不易，友友们给个三连吧！
通过深入理解指针（1），我们对指针有了一个初步的了解，还了解了指针变量类型的意义、指针的运算、assert断言、const修饰变量、野指针………………下面我们继续深入学习。
一、数组名的理解 通过深入理解指针（1），我们对于数组名arr的理解是数组首元素的地址,但其实这有两个例外。这里先引入结论，然后再去证实
· sizeof(数组名)，sizeof中单独放数组名，这⾥的数组名表⽰整个数组，计算的是整个数组的⼤⼩， 单位是字节。
· &amp;数组名，这⾥的数组名表⽰整个数组，取出的是整个数组的地址（整个数组的地址和数组⾸元素 的地址是有区别的）
下面观察这段代码
int main() { int arr[10]; for (int i = 0; i &lt; 10; i++) { arr[i] = i + 1;//赋给1 2 3 4 5 6 7 8 9 10 } printf("sizeof(arr)=%d\n\t", sizeof(arr)); printf("&amp;arr[0]=%d\n\t", &amp;arr[0]); printf("arr=%d\n\t", arr); printf("&amp;arr=%d\n\t", &amp;arr); } 运行结果第1行证实了sizeof（arr）传入的arr是整个arr数组的大小
sizeof(arr)=40
&amp;arr[0]=-488703448
arr=-488703448
&amp;arr=-488703448 在理解运行结果第2、3、4行时，要先区别&amp;arr[0]，arr，&amp;arr
·&amp;arr[0]:取arr数组第一个元素的地址
·arr：数组名代表数组首元素的地址
·&amp;arr：&amp;数组名表示取出整个数组的地址
为什么&amp;arr是取出整个数组的地址，打印出来的地址还是和&amp;arr[0]、arr一样呢？
原因是由于数组在内存中的连续存放的，所以&amp;arr的底层逻辑也是通过取得首元素地址，再顺腾摸瓜地找到其他元素的地址，所以直接打印的话结果是一样的。
那从哪里可以体现出&amp;arr传入的是整个数组的地址呢？？就需要指针运算来理解。
int main() { int arr[10]; for (int i = 0; i &lt; 10; i++) { arr[i] = i+1;//赋给1 2 3 4 5 6 7 8 9 10 } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfa60cb93069c863b767cc1e56657ec2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87757e18e79aa71515a5541c2e008753/" rel="bookmark">
			C语言：深入理解指针(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创作不易，友友们给个三连吧！！
大家好，今天来给大家分享一下我对指针的理解
一、内存和地址 1.1 内存 学习内存之前，引用一下生活中的一个案例
假设你知道你的一个朋友住在一个小区，这个小区有10栋楼，每栋楼10个楼层，每个楼层又有10个房间，你想找到他就得挨个挨个房间去找，这样效率是非常低的，但如果根据这些楼层和楼层房间的情况，给每个房间编上号，比如说1号楼1楼第1个房间，编上1#101，以此类推，那么你的朋友得到了房间号并告诉你，你就能迅速地根据信息找到他所在的房间。
所以在生活中，一些小区、酒店通过设置了房间号，方便客人快速找到房间。
类比到计算机，我们知道计算机上有CPU（中央处理器），CPU需要通过该内存的存储信息（地址）去读取相应的内存，处理完之后再放回到内存中去。
那计算机是如何高效处理内存空间的呢?
其实就是把内存划分为一个个的内存单元，每个内存单元的大小的1个字节
计算机的常见单位 计算机的常见单元换算 1个比特位可以存储一个2进制的1或者0，所以每个内存单元里面可以放8个比特位，而这8个比特位的信息就相当于是这个内存单元的编号，有了这个内存单元的编号，CPU就能快速找到这块内存空间，计算机中我们把内存单元的编号称为地址，C语言又起了个新名字叫指针，所以可以理解成 内存单元的编号==地址==指针
1.2 深入理解计算机编址 1.1提到，CPU想要访问某个字节空间，就必须知道这个字节空间在内存的什么位置，因为计算机的字节空间是非常多的，所以需要对每个字节空间进行编址，计算机中的编址实际上是通过硬件设计去实现的
比方说，吉他上面有“都瑞咪发嗖拉西多”这样的信息，但是演奏者可以寻找到每一个琴弦的每一个位置，原因就是制造商已经在乐器硬件层面设计好了，并且所有的演奏者都知道。所以本质上是一种约定出来的共识。
类比到计算机，我们知道计算机有非常多的硬件单元，硬件单元在设计的时候，我们希望他能够互相之间协同工作，所谓的协同，至少可以做到对数据进行传输。但是硬件本身又是相互独立的，所以必须通过“线”来连接。
CPU作为计算机的中央处理器，需要和内存之间建立大量的数据交互，也是通过“线”去实现的。
我们可以这样去理解，比方说我的电脑是64位，每根线有两态，表示0，1（电脉冲有无）那么一根线就代表着2个含义（电信号转换成数字信号），64跟地址线就代表2^64种含义，每一种含义都代表了一个地址，而这些地址信息的总和，就是计算机种的内存，在内存上，我们可以找到该地址对应的数据，再将数据通过数据总线传入CPU内寄存器中进行处理。
对于地址总线、数据总线、控制总线我是这样去理解的：
控制总线：相当于一个控制台，传递指令。
数据总线：相当于内存数据传输的通道。
地址总线：相当于一个内存仓库。
二、指针变量和地址 2.1 取地址操作符（&amp;） 理解了1中的内存和地址，在c语言中创建变量其实就是在向内存申请一块空间，如int a=10，他的实际意义就是向内存申请4个字节的空间来存储10这个数据，该变量的数据类型决定了具体需要申请几个字节的空间，如char类型就是申请1个字节的空间
对int a=10来说，创建了四个字节的空间，通过调试发现这四个字节都是有地址的，当我们通过&amp;取地址符来得到a的地址（%p是专门用来取地址的占位符）时，实际上取出的时a所占4个字节中地址较小的字节的地址。虽然整形变量占了4个字节，但是只要知道了第1个字节的地址，顺藤摸瓜就可以访问到4个字节的数据。
2.2 指针变量和解引用操作符 2.2.1 指针变量 通过2.1我们通过&amp;取地址符拿到了地址，这个地址是一个数值，而将这个数值存储起来方便后期使用，就需要我们把地址值存在指针变量里。
int main() { int a = 10; &amp;a; printf("%p\n", &amp;a); return 0; } int *p=&amp;a 本质上就是取出a的地址并存储到指针变量p中，指针变量本身也是一种变量，只不过是专门用来存放地址的，int*中的*相当于说明该变量是一个指针变量，而int对应的是该变量指向对象的数据类型是整形，如果要创建一个存放char类型变量a的指针变量，则书写方法char *p=&amp;a（指针变量p本身也是有自己的地址的，该地址存放的内容是a的地址，可以通过该地址访问a的数据）
2.2.2 解引用操作符 通过2.2.1，我们学会了怎么将地址保存起来，那未来我们也要有方法去取用他，就跟我们生活中我们找到一个房间，我们希望可以在这个房间里存放或者取走物品，同理，我们通过了指针变量存储的地址，通过地址找到了该地址指向的空间，这里就需要用到解引用操作符*，来取用空间里数据。
int main() { int a = 10; int* p = &amp;a; *p = 0; return 0; } *p的意思就是通过p中存放的地址，找到指向的空间，因为p存放的是a的地址，所以*p其实就是变量a，*p=0的操作，其实等价于通过指针间接改变了a的值，所以此时a=0，相比较于直接写a=0，相当于多了一种途径，写代码会更加灵活，在后面的传址调用可以体现出来。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87757e18e79aa71515a5541c2e008753/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c035205bcbedff1af74177db2d7a90d5/" rel="bookmark">
			停车场|基于Springboot的停车场管理系统设计与实现(源码&#43;数据库&#43;文档)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		停车场管理系统目录
目录
基于Springboot的停车场管理系统设计与实现
一、前言
二、系统功能设计
三、系统实现
1、管理员功能实现
（1）车位管理
（2）车位预订管理
（3）公告管理
（4）公告类型管理
2、用户功能实现
（1）车位
（2）车位预订
（3）公告
（4）公告类型
五、核心代码 六、论文参考
七、最新计算机毕设选题推荐
八、源码获取：
博主介绍：✌️大厂码农|毕设布道师，阿里云开发社区乘风者计划专家博主，CSDN平台Java领域优质创作者，专注于大学生项目实战开发、讲解和毕业答疑辅导。✌️
主要项目：小程序、SpringBoot、SSM、Vue、Html、Jsp、Nodejs等设计与开发。
🍅文末获取源码联系🍅
👉 毕设答疑 👈 基于Springboot的停车场管理系统设计与实现 一、前言 因为传统停车场管理系统信息管理难度大，容错率低，管理人员处理数据费工费时，所以专门为解决这个难题开发了一个停车场管理系统管理系统，可以解决许多问题。
停车场管理系统管理系统按照操作主体分为管理员和用户。管理员的功能包括车辆管理、车位管理、车位预订管理、字典管理、公告管理、违规管理、用户管理、员工管理、管理员管理。用户的功能等。该系统采用了Mysql数据库，Java语言，Spring Boot框架等技术进行编程实现。
停车场管理系统管理系统可以提高停车场管理系统信息管理问题的解决效率，优化停车场管理系统信息处理流程，保证停车场管理系统信息数据的安全，它是一个非常可靠，非常安全的应用程序。
关键词：停车场管理系统管理系统；车位,车位预订Mysql数据库；Java语言
二、系统功能设计 管理员权限操作的功能包括管理公告，管理停车场管理系统信息，包括车位管理，培训管理，车位预订管理，薪资管理等，可以管理公告。
图4.1 管理员功能结构
三、系统实现 1、管理员功能实现 （1）车位管理 图5.1 即为编码实现的车位管理界面，管理员在车位管理界面中可以对界面中显示，可以对车位信息的车位状态进行查看，可以添加新的车位信息等。
图5.1 车位管理界面
（2）车位预订管理 图5.2 即为编码实现的车位预订管理界面，管理员在车位预订管理界面中查看车位预订种类信息，车位预订描述信息，新增车位预订信息等。
图5.2 车位预订管理界面
（3）公告管理 图5.3 即为编码实现的公告管理界面，管理员在公告管理界面中新增公告，可以删除公告。
图5.3 公告管理界面
（4）公告类型管理 图5.4 即为编码实现的公告类型管理界面，管理员在公告类型管理界面查看公告的工作状态，可以对公告的数据进行导出，可以添加新公告的信息，可以编辑公告信息，删除公告信息。
图5.4 公告类型管理界面
2、用户功能实现 （1）车位 图5.2.1 即为编码实现的车位界面，
图5.2.1 车位管理界面
（2）车位预订 图5.2 即为编码实现的车位预订界面。
图5.2.2 车位预订管理界面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c035205bcbedff1af74177db2d7a90d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b189d51fa358a0ba6697e8a168ad738/" rel="bookmark">
			Nginx与history路由模式：刷新页面404问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用nginx部署前端项目，路由模式采用history模式时，刷新页面之后，显示404。
路由模式 前端路由的基本作用为：
①当浏览器地址变化时，切换页面；
②点击浏览器后退、前进按钮时，更新网页内容；
③刷新浏览器页面时，网页加载与当前路由相匹配的内容。
在前端项目开发中，主要使用到两种路由模式：
【1】hash模式：通过监听浏览器地址hash值，在回调函数中切换网页内容/部分内容；
【2】history模式：基于history API自定义url地址，实现url地址变化并保证网页内容的切换。
hash模式 基本原理 使用window.location.hash属性及窗口的onhashchange事件，可以实现监听浏览器地址hash值变化，执行相应的js切换网页。
Location：hash属性 hashchange事件 hash模式的特点如下：
①hash指的是地址中#号以及后面的字符，也称为散列值。hash也称作锚点，本身是用来做页面跳转定位的。如http://localhost/index.html#abc，这里的#abc就是hash；
②散列值是不会随请求发送到服务器端的，所以改变hash，不会重新加载页面；
③ window 的 hashchange 事件作用：当散列值改变时，可以通过 location.hash 来获取和设置hash值；
④location.hash值的变化会直接反应到浏览器地址栏。
hash路由触发条件 那么，如何触发hash路由呢？主要分为编程式触发（例如：通过a标签设置锚点、js代码级动态更新）和手动触发（例如：点击浏览器的前进/后退按钮），
①当浏览器地址栏的散列值/hash值变化时，会自动触发location..hash属性值的变化，从而触发onhashChange事件。
②当只改变浏览器地址栏URL的哈希值时，按下enter键不会导致浏览器向服务器发送请求，此时仅仅是设置hash值，并触发onhashChange事件。
③HTML提供的a标签，通过其href属性可以为页面设置锚点，当点击a标签时，可以跳转到对应元素所在区域，同时更新地址栏hash值（伴随着Location.hash属性值的更新），并触发onhashChange事件。
example-基础示例 代码示例：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;hash模式&lt;/title&gt; &lt;style&gt; .box{ margin:15px; min-height: 100vh; width: 100%; background-color: skyblue; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box" id="part_1"&gt;part_1&lt;/div&gt; &lt;div class="box" id="part_2"&gt;part_2&lt;/div&gt; &lt;a href="#part_1"&gt;to_part_1&lt;/a&gt; &lt;a href="#part_2"&gt;to_part_2&lt;/a&gt; &lt;script&gt; window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b189d51fa358a0ba6697e8a168ad738/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/507/">«</a>
	<span class="pagination__item pagination__item--current">508/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/509/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>