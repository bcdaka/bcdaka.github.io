<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/001bf3c9f6a3a8259b7b3635c90d0e55/" rel="bookmark">
			【微服务】SpringClound常用注解以及示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 强烈推荐引言常用注解1. @EnableEurekaServer2. @EnableEurekaClient3. @EnableDiscoveryClient4. @LoadBalanced5. @EnableFeignClients6. @FeignClient7. @HystrixCommand8. @EnableHystrix9. @EnableZuulProxy10. @EnableConfigServer 引用的包1. Eureka (服务注册与发现)2. Feign (声明式服务调用)3. Hystrix (断路器)4. Zuul (API 网关)5. Spring Cloud Config (配置管理)6. Ribbon (客户端负载均衡)7. Spring Cloud Commons (通用服务发现)8. Consul (服务注册与发现，Consul 方案)9. Zookeeper (服务注册与发现，Zookeeper 方案)10. Sleuth (分布式链路追踪)版本管理 结束语强烈推荐专栏集锦写在最后 强烈推荐 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站:人工智能
引言 Spring Cloud 作为一套完整的微服务解决方案，提供了丰富的工具和功能，帮助开发者轻松实现服务注册、负载均衡、服务调用、配置管理等核心需求。
在这篇文章中，我们将介绍 Spring Cloud 中常用的注解，帮助您更好地理解和应用这些注解，以简化微服务开发过程。
常用注解 Spring Cloud 是一个微服务框架，提供了许多用于构建分布式系统的工具。以下是 Spring Cloud 中一些常用的注解：
1. @EnableEurekaServer 作用: 开启 Eureka 服务端，用于服务注册和发现。使用场景: 当需要搭建服务注册中心时，在启动类上加此注解。 @SpringBootApplication @EnableEurekaServer public class EurekaServerApplication { public static void main(String[] args) { SpringApplication.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/001bf3c9f6a3a8259b7b3635c90d0e55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b5149b0891c4682ddaf6e281ed58eb2/" rel="bookmark">
			EmguCV学习笔记 C# 第4章 图像处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版权声明：本文为博主原创文章，转载请在显著位置标明本文出处以及作者网名，未经作者允许不得用于商业目的。
EmguCV是一个基于OpenCV的开源免费的跨平台计算机视觉库,它向C#和VB.NET开发者提供了OpenCV库的大部分功能。
教程VB.net版本请访问：EmguCV学习笔记 VB.Net 目录-CSDN博客
教程C#版本请访问：EmguCV学习笔记 C# 目录-CSDN博客
笔者的博客网址：https://blog.csdn.net/uruseibest
教程配套文件及相关说明以及如何获得pdf教程和代码，请移步：EmguCV学习笔记
学习VB.Net知识，请移步： vb.net 教程 目录_vb中如何用datagridview-CSDN博客
学习C#知识，请移步：C# 教程 目录_c#教程目录-CSDN博客
第4章 图像处理 本章主要讲述如何进行图像的处理，大多数采用cvinvoke类来进行处理，在第2章image和mat有部分处理方法与cvinvoke类提供的方法类似。
目录
第4章 图像处理
4.1 颜色变换
4.2 二值化
4.2.1 Threshold
4.2.2 AdaptiveThreshold
4.2.3 图像通道分离和合并
4.2.4 按颜色分离
4.3 卷积操作
4.3.1 BorderType
4.3.2 Blur
4.3.3 MedianBlur
4.3.4 GaussianBlur
4.3.5 BilateralFilter
4.3.6 BoxFilter
4.3.7 Filter2D
4.4 图像形态学
4.4.1 GetStructuringElement
4.4.2 Erode
4.4.3 Dilate
4.4.4 MorphologyEx
4.5 像素距离和连通区域
4.5.1 DistanceTransform 像素距离
4.5.2 connectedComponents 图像连通区域
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b5149b0891c4682ddaf6e281ed58eb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11f4d44081d4512d0a4a7d0d65146948/" rel="bookmark">
			【Hadoop】核心组件深度剖析：HDFS、YARN与MapReduce的奥秘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🐇明明跟你说过：个人主页
🏅个人专栏：《大数据前沿：技术与应用并进》🏅
🔖行路有良友，便是天堂🔖
目录
一、引言
1、Hadoop简介
2、Hadoop生态系统概览
二、Hadoop Distributed File System (HDFS) 深度解析
1、HDFS核心概念
2、HDFS工作机制
3、HDFS的优势与局限
三、Yet Another Resource Negotiator (YARN) 架构剖析
1、YARN诞生背景与意义
2、YARN架构概览
3、YARN工作流程
4、YARN应用场景
四、MapReduce编程模型与实现机制
1、MapReduce基本概念
2、MapReduce 工作流程
一、引言 1、Hadoop简介 Hadoop 是一个开源的分布式计算框架，主要用于处理和存储大量数据。它由 Apache 软件基金会开发，基于 Google 的 MapReduce 和 Google 文件系统 (GFS) 的理念设计。Hadoop 提供了一种可扩展、容错的方式来处理大规模数据集，使得用户能够在廉价的硬件上进行分布式计算。
2、Hadoop生态系统概览 Hadoop 生态系统是围绕 Hadoop 分布式计算框架所建立的一系列工具和技术的集合。这些工具涵盖了数据存储、数据处理、数据管理、数据分析等多个方面，旨在帮助用户处理和分析大规模数据集。
1. 数据存储与管理
HDFS (Hadoop Distributed File System):
Hadoop 分布式文件系统，用于存储大规模数据，具备高容错性和高吞吐量。 HBase:
一个基于列存储的分布式数据库，适合处理大规模结构化数据，支持实时读写。 Hive:
一个数据仓库工具，可以将结构化数据映射为表，支持使用类似 SQL 的查询语言 HiveQL 进行查询。 HCatalog:
Hive 的元数据管理服务，帮助不同 Hadoop 工具（如 Pig、MapReduce）之间共享数据元数据。 HCFS (Hadoop Compatible File System):
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11f4d44081d4512d0a4a7d0d65146948/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/557d8b11fc0bff4882206930bf76e549/" rel="bookmark">
			如何引入CSS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面的博客中已经讲到了HTML负责整合Internet资源，而CSS负责对页面的美化，那么CSS与HTML又是怎么联系起来的呢？
或者说，某个HTML文件又是怎么对应到相应的CSS的内容的呢？
这里给出了相应的三种方法。
内联样式 (inline) 内联样式就是直接在HTML元素的style属性中写CSS代码，通常用于对单个元素进行简单的样式设计。
例如：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;示例文档&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 style = "color:red;font-size:24px"&gt;标题&lt;/h3&gt; &lt;p style="color: red; font-weight: bold;"&gt;这是一个段落&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 内部样式 (internal) 内部样式就是将CSS文档写到&lt;head&gt;标签内的&lt;style&gt;内：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;示例文档&lt;/title&gt; &lt;style&gt; h3{ color:red; font-size:24px } p{ color: red; font-weight: bold; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;标题&lt;/h3&gt; &lt;p&gt;这是一个段落&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 外部样式表 (external) 外部样式表是将CSS代码写入单独的.css文件中，在HTML文档里通过&lt;link&gt;标签将.css文件引入进去。
使用外部样式表的优点是一是避免了臃肿的HTML文档，二是使得同样的CSS样式文档能够应用给多个HTML文档，从而提高了代码的复用性和可维护性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/557d8b11fc0bff4882206930bf76e549/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9390d301325c196940e5b6063d5e587/" rel="bookmark">
			SpringBoot中整合RabbitMQ（测试&#43;部署上线 最完整）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、RabbitMQ安装
二、启动RabbitMQ
三、编写Java代码\
1、引入依赖
2、配置yml
3、配置消息转换器
4、编写接收方接收消息
5、编写发送方发送消息
6、小程序验证
三、宝塔中安装RabbitMQ
1、下载erlang
（1）查看rabbitmq的版本
（2）查找erlang兼容版本
（3）安装RPM包
2、前往宝塔面板
3、安装RabbitMQ
四、docker中安装rabbitmq
1、安装docker
2、配置docker镜像加速
3、拉取RabbitMQ镜像
4、运行RabbitMQ
5、查看镜像和容器
6、开放客户端服务
7、登录RabbitMQ客户端
8、创建虚拟主机
五、部署项目验证
六、拓展使用
一、RabbitMQ安装 由于在测试环境中，我们现在虚拟机上基于docker安装mq
docker run \ -e RABBITMQ_DEFAULT_USER=quick \ -e RABBITMQ_DEFAULT_PASS=123 \ -v mq-plugins:/plugins \ --name mq \ --hostname mq \ -p 15672:15672 \ -p 5672:5672 \ --network your-net\ -d \ rabbitmq:3.8-management 在docker环境上运行改指令
前两个是登录的用户名密码
network是连接的网络，如果用默认网络的话就不需要写
最后一个是版本，这个是目前测试的版本
二、启动RabbitMQ 由于目前是测试阶段，这里我使用之前学习的时候的版本。
创建新用户后重新登陆，然后创建一个单独的 Virtual Hosts （虚拟主机）来进行隔离。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9390d301325c196940e5b6063d5e587/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a9372e61d9e6df56305682a26e7a325/" rel="bookmark">
			产品经理-​​实习中的自我迭代(41)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 实习中的自我迭代,优秀实习生必备素质
跟大家认识了之后，就要开始做事情了，那我们怎么做一个优秀的实习生呢？以下几点作为参考。
1. 目标明确
知道自己的工作为什么要做，要做到什么程度，目前存在什么问题，该怎么改进？
2. 学会提问
要大胆提问，学会提问题，学会分解问题，但要注意方式、时间、对象和场合
提问时应注意以下两点。
第一，少提“大而宽泛的问题”，应把一个大系统分解成很多个小问题。
第二，尽量少提“概念化的问题”。
3. 遇事多思考
不要事事请示领导，在工作中事事请示领导会让领导感觉你没有思想。
4. 对于工作要主动
不要等待领导分配任务。如果不知道应该干什么，或没有活儿干，要主动请缨，主动去思考哪些工作该做但是没人做，多数公司都有干不完的活儿，找出要紧的或者该做的，主动去做。
5. 遇到问题，不找借口
遇到问题时说清楚情况，该是自己的责任就自己扛下来，有所担当，认清错误后能够知道如何弥补、如何改正。
遇到问题不回避、不找借口。没有不犯错误的人，在错误面前
体现的性格、态度、成长才是最关键的。
6. 要学会正确看待和处理工作中遇到的困难
实习过程中，上级交代的任务可能很快地就答应了，因为当时并不知道会有哪些困难，因此中途遇到困难是正常现象
总之,在公司当中,作为职场新人,多观察,多学习,遇到问题,先思考,实在解决不了,及时问,有时,多问一句,并没有什么,在挫折中成长
点击左下角查看更多 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/235591bb21645b1712a15452da4bc708/" rel="bookmark">
			从回调地狱到Promise乐园：JavaScript异步编程的进化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
📫 大家好，我是南木元元，热爱技术和分享，欢迎大家交流，一起学习进步！
🍅 个人主页：南木元元
目录
什么是Promise
Promise的特点
Promise的基本用法
创建Promise对象
then
resolve/reject
catch
常用方法
Promise.all()
Promise.allSettled()
Promise.race() Promise.any() Promise.finally() 结语
什么是Promise Promise是一种异步编程的解决方案，它代表一个尚未完成但预期将来会完成的操作，并可以在这个操作完成或失败时处理相应的结果。Promise 提供了一种更清晰和结构化的方式来编写和管理异步代码，避免了“回调地狱”（callback hell）的出现。
简单来说，Promise就相当于一个容器，里面保存异步操作的结果，解决了回调地狱的问题。
回调地狱 Promise出现之前，JavaScript的异步机制主要通过回调函数来实现，但使用回调函数的方式有一个缺点：多个回调函数嵌套时会造成回调函数地狱，导致代码难以阅读和维护。
callback1(function(result1) { callback2(result1, function(result2) { callback3(result2, function(result3) { callback4(result3, function(result4) { // 最终结果处理 console.log(result4); }); }); }); }); 在上面示例中，每个异步操作的结果都被传递给下一个回调函数，随着异步操作的增加，这种嵌套会变得复杂和难以管理。
而使用 Promise 的方式可以将嵌套的回调函数作为链式调用，从而避免回调地狱。
Promise的特点 Promise实例有三种状态：
pending：进行中，是初始状态fulfilled：已成功rejected：已失败 Promise实例有两个过程：
pending -&gt; fulfilled pending -&gt; rejected 当把一件事情交给promise时，它的状态就是pending，任务完成了状态就变成了fulfilled，没有完成失败了就变成了rejected。状态的改变是通过 resolve() 和 reject() 函数来实现的。
Promise的两个特点：
特点1：只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。
特点2：实例的状态一经改变，就凝固了，无法再被改变了。
Promise的基本用法 创建Promise对象 ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/235591bb21645b1712a15452da4bc708/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecdd8189a2200decf14f002d3f5645dc/" rel="bookmark">
			深度学习基础—学习率衰减与局部最优问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.学习率衰减 下图中，蓝色的线是min-batch梯度下降法过程中较大学习率的的优化路径，绿线是较小学习率的优化路径。
如果使用min-batch梯度下降法，在模型的学习过程中，会有很多噪声，在靠近最小值的时候，由于学习率a不变，因此最终算法在最小值附近摆动。要解决这个问题，就需要减少学习率a，让靠近最小值的过程中，模型的步长小一点，这就需要学习率衰减来解决。
一个训练集被拆成多个min-batch，对一个训练集训练一遍成为1epoch，我们有如下相关的学习率衰减公式：
其中，decay_rate是衰减率，epoch_num是训练的代数，a0是初始学习率，k是小于1的参数。这些做法都可以让学习率随着训练代数的增加，逐渐衰减，从而让模型更加接近最小值。
2.局部最优问题 接下来看看局部最优问题，如下图所示，蓝点是局部最优解，红点是全局最优解。局部最优和全局最优都是梯度为0的点，也就是所有维度都是凹函数。
下图是鞍点，鞍点是部分维度为凸函数，部分维度为凹函数的点，该点的梯度也为0。
实际的神经网络中，尤其是大模型，参数非常多，损失函数的图像在高维空间难以画出，运行过程中，遇到的梯度为0的点很难是局部最优点（这需要所有维度都是凹函数，概率极低）。最容易遇到的是鞍点，遇到鞍点是让人头疼的问题：
因为马鞍面有一部分很平缓，这部分的梯度很小，使用梯度下降法时会经过很长时间才能走到鞍点附近，在鞍点附近扰动，直到找到梯度更大的方向，梯度下降法才能有更深的进展。这个平稳段需要更好的优化算法来加速训练，Adam算法就是很成熟的优化算法，可以帮助我们加速走出平稳段和鞍点，从而搜索到全局最优。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c5a68357398733c17f45992b94acd54/" rel="bookmark">
			基于Python的火车票售票系统/基于django的火车购票系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要 随着信息技术和网络技术的飞速发展，人类已进入全新信息化时代，传统管理技术已无法高效，便捷地管理信息。为了迎合时代需求，优化管理效率，各种各样的管理系统应运而生，各行各业相继进入信息管理时代，火车票售票就是信息时代变革中的产物之一。
任何系统都要遵循系统设计的基本流程，本系统也不例外，同样需要经过市场调研，需求分析，概要设计，详细设计，编码，测试这些步骤，基于Python语言、django框架、B/S架构、Mysql数据库设计并实现了火车票售票系统。系统主要包括用户、列车信息、票务信息、订单信息、订单退票、订单改签等功能模块。
本文首先介绍了火车票售票系统技术的发展背景与发展现状，然后遵循软件常规开发流程，首先针对系统选取适用的语言和开发平台，根据需求分析制定模块并设计数据库结构，再根据系统总体功能模块的设计绘制系统的功能模块图，流程图以及E-R图。然后，设计框架并根据设计的框架编写代码以实现系统的各个功能模块。最后，对初步完成的系统进行测试，主要是功能测试、单元测试和性能测试。测试结果表明，该系统能够实现所需的功能，运行状况尚可并无明显缺点。
关键字：火车票售票系统；django框架 ；Mysql数据库；Python语言
ABSTRACT With the rapid development of information technology and network technology, mankind has entered a new information age. Traditional management technology has been unable to manage information efficiently and conveniently. In order to meet the needs of the times and optimize management efficiency, a variety of management systems came into being. All walks of life have entered the era of information management. Train ticket selling is one of the products of the reform of the information age.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c5a68357398733c17f45992b94acd54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28aefee4694707a5a835148753a149ee/" rel="bookmark">
			代码随想录算法训练营第五天 |242.有效的字母异位词；349. 两个数组的交集；202. 快乐数；1. 两数之和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今日任务 ● 哈希表理论基础
● 242.有效的字母异位词
● 349. 两个数组的交集
● 202. 快乐数
● 1. 两数之和
详细布置 哈希表理论基础 建议：大家要了解哈希表的内部实现原理，哈希函数，哈希碰撞，以及常见哈希表的区别，数组，set 和map。
什么时候想到用哈希法，当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。 这句话很重要，大家在做哈希表题目都要思考这句话。
文章讲解：代码随想录 总结: 数据结构： Java 中 HashMap 主要由数组和链表（在 Java 8 后还有红黑树）组成。数组被称为哈希桶(hashTable)，用于存储键值对的链表或红黑树的头节点引用 哈希函数： 通过哈希函数计算键的哈希值，然后对数组长度取模，得到在数组中的索引位置，以此来决定键值对应该存储在哪个哈希桶中 扩容机制： 当 HashMap 中的元素数量超过负载因子（默认 0.75）与当前容量的乘积时，会触发扩容操作。扩容时会创建一个新的、更大的数组，并将原有数据重新哈希到新数组中 键值存储与查找： 存储键值对时，将其放入对应的哈希桶中，如果发生哈希冲突（多个键映射到同一个索引位置），则在链表中依次添加节点（在 Java 8 后，如果链表长度超过一定阈值会转换为红黑树）查找键值对时，通过相同的哈希函数计算键的索引位置，然后在对应的链表或红黑树中进行查找 线程不安全： HashMap 在并发环境下可能会出现数据丢失、数据覆盖等问题，不适合多线程环境下直接使用，如果需要在多线程环境中使用，可以使用 ConcurrentHashMap 等线程安全的类。 线程安全问题的本质原因: 1&gt;结构的并发修改问题
同时进行扩容操作：
HashMap 在进行扩容时，需要重新计算已有元素的哈希值，并将它们迁移到新的数组位置。如果多个线程同时进行扩容操作，可能会导致数据丢失或者迁移错误。
节点插入和链接的混乱：
在正常情况下，当向 HashMap 中插入一个新的键值对时，需要根据哈希值找到对应的链表位置，并将新节点插入到链表中。如果多个线程同时进行插入操作，可能会导致节点链接的顺序错误，或者出现循环链表的情况。
2&gt;数据不一致问题
读写冲突：
一个线程正在读取 HashMap 的数据，而另一个线程正在对其进行写入操作（例如添加、删除或修改键值对）。在没有适当的同步机制的情况下，读取线程可能会获取到不一致的数据状态。
哈希表状态的不一致：
HashMap 的内部状态包括哈希桶数组的大小、每个链表的结构以及元素的分布等。在多线程环境下，这些状态可能会被多个线程同时修改，导致哈希表的状态变得不可预测和不一致。
3&gt;没有同步机制来保证原子性和可见性
原子性操作的缺失：
许多对 HashMap 的操作，如 put ()、remove () 等，实际上是由多个步骤组成的复合操作。在多线程环境下，这些操作需要保证原子性，即要么全部完成，要么完全不做，以避免中间状态被其他线程看到。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28aefee4694707a5a835148753a149ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3425fe7831df6eb31867d4ce7cbbba7f/" rel="bookmark">
			Eureka故障排查指南：常见问题与解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 Eureka 是一个由 Netflix 开发的 REST-based 服务注册和发现框架，主要用于微服务架构中的服务发现和负载均衡。作为 Netflix 开源的服务发现工具，Eureka 被广泛应用于分布式系统中，尤其是在微服务环境中。然而，在实际使用过程中，Eureka 可能会遇到各种故障和问题。本文旨在提供一个详细的故障排查指南，涵盖常见的问题及其解决方案，帮助用户高效地解决在使用 Eureka 过程中可能遇到的各种问题。
一、Eureka 基础概述 在深入故障排查之前，有必要了解 Eureka 的基本架构和功能。
1.1 Eureka 架构 Eureka 的架构主要包括两个组件：Eureka Server 和 Eureka Client。
Eureka Server：作为服务注册中心，Eureka Server 负责接收和存储来自各个服务的注册信息。它维护一个服务注册表，服务可以通过 Eureka Server 发现彼此。Eureka Client：服务的客户端，负责向 Eureka Server 注册自身，并定期发送心跳以保持注册状态。客户端还可以通过 Eureka Server 查询其他服务的信息。 1.2 Eureka 工作原理 Eureka 的工作流程如下：
服务注册：服务启动时，将自身信息（如服务名称、地址、端口等）注册到 Eureka Server。服务心跳：已注册的服务定期向 Eureka Server 发送心跳，以表明其健康状态。服务发现：其他服务通过 Eureka Client 查询 Eureka Server 获取服务的地址信息，以实现服务间的调用。 二、常见问题与解决方案 2.1 服务无法注册到 Eureka Server 问题描述：服务启动后无法在 Eureka Server 中注册，通常表现为服务无法被发现或 Eureka Server 上没有显示注册信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3425fe7831df6eb31867d4ce7cbbba7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed49cb1c05129b0f478c60bc04d392e6/" rel="bookmark">
			Vue 3 实现网页全屏效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 在 Web 开发中，全屏模式可以提供沉浸式的用户体验，尤其是在观看视频、演示文稿或展示特定功能时。本文将介绍如何使用 Vue 3 和 Element Plus 来实现一个简单的网页全屏功能。
创建全屏按钮组件 模板部分 &lt;template&gt; &lt;el-button size="default" circle="false" @click="toggleFullscreen"&gt; &lt;el-icon&gt; &lt;FullScreen v-if="!isFullscreen" /&gt; &lt;ExitFullScreen v-else /&gt; &lt;/el-icon&gt; &lt;/el-button&gt; &lt;/template&gt; 元素按钮 (&lt;el-button&gt;)：
&lt;el-button&gt; 是 Element Plus 库提供的按钮组件。size="default" 设置按钮的大小为默认大小。circle="false" 设置按钮为非圆形样式。@click="toggleFullscreen" 绑定点击事件，当点击按钮时会触发 toggleFullscreen 方法。 元素图标 (&lt;el-icon&gt;)：
&lt;el-icon&gt; 组件用于显示图标。&lt;FullScreen&gt; 和 &lt;ExitFullScreen&gt; 分别表示全屏和退出全屏的图标。v-if="!isFullscreen" 和 v-else 控制显示哪个图标，根据 isFullscreen 的值来切换。 Script Setup 部分 &lt;script setup&gt; import { ref } from 'vue'; import { FullScreen, ExitFullScreen } from '@element-plus/icons-vue'; const isFullscreen = ref(false); function toggleFullscreen() { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed49cb1c05129b0f478c60bc04d392e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dec8e88b0d49ac2ad11037c436a5b50/" rel="bookmark">
			【数学建模】趣味数学模型——等额还款数学模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题
在银行贷款中，通常采用等额还款。假定银行贷款的年利率为 p，贷款 k 元，分 m 年采用每月等额还款方式还清。问每月还款多少钱？总共还的钱是多少？每月还款中还本金和利息各是多少元？
如果考虑每月等额还本金，结果如何？如贷款 160000 元，分 5 年还清，年利率为 4.032%。给出每种情况下每月的还款额，各自总共还款是多少？
方案一：每月等额还款
计算模型概述
在此方案中，每月还款金额相同，但还款中包含的本金和利息部分随着时间的推移逐渐变化。
Matlab 仿真程序
程序的主要步骤如下：
初始化各项参数：贷款金额 K = 160000 元，还款年限 m= 5 年，年利率 p=4.032%。计算月利率 r = 12p​。计算每月等额还款金额 a 。逐月计算还款中的利息部分 L(i) 、本金部分 x(i) 和剩余本金 y(i) 。输出结果，包括每月的还款金额、还本金、还利息以及剩余本金。 Matlab程序代码：
K = 160000; % 贷款金额 m = 5; % 还款年限 p = 0.04032; % 年利率 r = p / 12; % 月利率 n = m * 12; % 总月数 x = zeros(1, n); % 每月还本金 y = zeros(1, n); % 每月所剩本金 L = zeros(1, n); % 每月还利息 a = K * r * (1 + r)^n / ((1 + r)^n - 1); % 每月等额还款金额 % 初始还款 L(1) = K * r; % 第一个月的利息 x(1) = a - L(1); % 第一个月的本金 y(1) = K - x(1); % 第一个月剩余本金 % 逐月计算 for i = 2:n L(i) = y(i-1) * r; % 计算利息 x(i) = a - L(i); % 计算本金 y(i) = y(i-1) - x(i); % 更新剩余本金 end % 输出总还款金额及每月还款详情 fprintf('贷款%6d元, 总共还款%5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dec8e88b0d49ac2ad11037c436a5b50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/947403131fb08edb1e29be1455390028/" rel="bookmark">
			二叉树《数据结构》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉树 1. 树概念及结构1.1 树的概念1.2树的概念1.3 树的表示 2. 二叉树概念及结构2.1 二叉树概念2.4 二叉树的性质练习 3. 二叉树顺序结构及实现3.1 二叉树的顺序结构3.2堆的结构及概念练习3.3堆的实现3.3.1堆的向下调整算法3.3.2堆的创建3.3.3 堆的插入3.3.4 堆的删除3.3.5堆的代码实现 1. 树概念及结构 1.1 树的概念 树是一种非线性的数据结构，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的集合。把它叫做树是因
为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。
有一个特殊的结点，称为根结点，根结点没有前驱结点除根结点外，其余结点被分成M(M&gt;0)个互不相交的集合T1、T2、……、Tm，其中每一个集合Ti(1&lt;= i
&lt;= m)又是一棵结构与树类似的子树。每棵子树的根结点有且只有一个前驱，因此，树是递归定义的。
有一点需要注意：树形结构中，子树之间不能有交集，否则就不是树形结构。 1.2树的概念 结点的度：一个结点含有的子树的个数称为该结点的度；如上图：A的为6
叶结点或终端结点：度为0的结点称为叶结点；如上图：B、C、H、I…等结点为叶结点
非终端结点或分支结点：度不为0的结点；如上图：D、E、F、G…等结点为分支结点
双亲结点或父结点：若一个结点含有子结点，则这个结点称为其子结点的父结点；如上图：A是B的父结点
孩子结点或子结点：一个结点含有的子树的根结点称为该结点的子结点；如上图：B是A的孩子结点
兄弟结点：具有相同父结点的结点互称为兄弟结点；如上图：B、C是兄弟结点
树的度：一棵树中，最大的结点的度称为树的度；如上图：树的度为6
结点的层次：从根开始定义起，根为第1层，根的子结点为第2层，以此类推；
树的高度或深度：树中结点的最大层次；如上图：树的高度为4
堂兄弟结点：双亲在同一层的结点互为堂兄弟；如上图：H、I互为兄弟结点
结点的祖先：从根到该结点所经分支上的所有结点；如上图：A是所有结点的祖先
子孙：以某结点为根的子树中任一结点都称为该结点的子孙。如上图：所有结点都是A的子孙
森林：由m（m&gt;0）棵互不相交的树的集合称为森林；
1.3 树的表示 孩子兄弟表达法：
typedef int type struct Node { struct Node*firstChild;//第一个孩子节点 struct Node*NextBrother;//指向其下一个兄弟节点 type data;//数据 } 2. 二叉树概念及结构 2.1 二叉树概念 1.由一个根节点加上两颗子树称为左子树和右子树构成了二叉树
2. 二叉树不存在度大于2的结点
3.二叉树的子树有左右之分，次序不能颠倒，因此二叉树是有序的
2.2特殊的二叉树：
1.满二叉树：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是2^k-1，则它就是满二叉树。
2.完全二叉树：完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K
的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对
应时称之为完全二叉树。 要注意的是满二叉树是一种特殊的完全二叉树。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/947403131fb08edb1e29be1455390028/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/476b8581b0c54f04c88bd7f64c34e7e4/" rel="bookmark">
			使用Python进行数据分析的最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着大数据时代的到来，数据已经成为驱动业务增长的关键因素。Python作为一款强大的编程语言，在数据科学领域占据着重要的地位。本文将介绍如何使用Python进行高效的数据分析，并分享一些实用的技巧和最佳实践。
1. 引言 数据科学和机器学习正在改变世界，Python作为一种灵活且功能强大的语言，已经成为了数据科学家们的首选工具。它不仅易于学习，而且拥有丰富的生态系统，包括用于数据分析的强大工具包，如NumPy、Pandas、Matplotlib等。本文将重点介绍这些工具，并指导读者如何利用它们进行有效的数据分析。
2. 必备工具 为了进行数据分析，我们需要安装一些必要的Python库。以下是几个常用的数据科学工具包及其简要介绍：
2.1 NumPy NumPy是一个用于处理数组的Python库，它提供了大量的数学函数用于操作数组。NumPy的数组操作比传统的Python列表更快速和高效。
2.2 Pandas Pandas是一个提供高性能、易用的数据结构和数据分析工具的Python库。它特别适合用于数据清洗和准备。
2.3 Matplotlib Matplotlib是一个基于Python的2D绘图库，可以用来生成图表、直方图、功率谱、条形图、错误图、散点图等等。
2.4 安装这些库 可以通过Python的包管理器pip来安装这些库：
pip install numpy pandas matplotlib 3. 数据清洗 数据清洗是数据分析的第一步，也是最关键的步骤之一。数据通常存在缺失值、异常值等问题，需要进行适当的处理才能用于分析。
3.1 处理缺失值 Pandas提供了多种方法来处理缺失值，例如dropna()和fillna()等函数：
import pandas as pd df = pd.DataFrame({ 'A': [1, 2, np.nan, 4], 'B': [5, np.nan, np.nan, 8], 'C': [9, 10, 11, 12] }) # 删除含有缺失值的行 df.dropna(inplace=True) # 用均值填充缺失值 df.fillna(df.mean(), inplace=True) 3.2 处理异常值 异常值可能会对分析结果产生负面影响，因此也需要进行适当处理：
# 假设df['A']列中存在异常值 Q1 = df['A'].quantile(0.25) Q3 = df['A'].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/476b8581b0c54f04c88bd7f64c34e7e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7ac0fc7546804360003f0835eeb7f63/" rel="bookmark">
			【C&#43;&#43;】入门基础（为C语言填坑）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hi~！这里是奋斗的小羊，很荣幸您能阅读我的文章，诚请评论指点，欢迎欢迎 ~~
💥💥个人主页：奋斗的小羊
💥💥所属专栏：C++
🚀本系列文章为个人学习笔记，在这里撰写成文一为巩固知识，二为记录我的学习过程及理解。文笔、排版拙劣，望见谅。
目录 前言一、C++基础知识1、C++关键字（C++98）2、命名空间2.1命名空间的意义2.2命名空间的定义2.3命名空间的使用 3、C++输入&amp;输出4、缺省参数5、函数重载6、引用6.1引用概念6.2引用的特性6.3 引用的使用6.4 const引用6.5指针和引用的关系 7、inline8、nullptr 总结 前言 C语言是结构化和模块化的编程语言，适合处理较小规模的程序，对于复杂、规模较大的问题，需要高度的抽象和建模时，C++更加合适。
C++兼容C语言绝多数的语法，C++是在C语言的基础上，容纳进去了面向对象编程思想，并增加了许多有用的库，以及编程范式等。
C语言有一些语法的不足，C++对C语言设计不合理的地方进行了优化，C++既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行面向对象的程序设计。
一、C++基础知识 1、C++关键字（C++98） C语言有32个关键字，而C++有63个。
分类关键字控制语句相关if, else, switch, case, default, break, continue, goto, do, while, for, return数据类型相关int, char, float, double, void, bool, wchar_t, short, long, unsigned, signed存储类auto, register, static, extern, mutable, thread_local类型相关typedef, using, decltype, sizeof, alignas, alignof类和对象相关class, struct, union, enum, explicit, friend, this, virtual, override, final, public, protected, private, new, delete, const, volatile, constexpr, static_assert模板相关template, typename, class (在模板定义中)命名空间namespace, using异常处理try, catch, throw其他sizeof, nullptr, alignas, alignof预处理指令相关#define, #include, #if, #endif, #ifdef, #ifndef, #else, #elif, #pragma 2、命名空间 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7ac0fc7546804360003f0835eeb7f63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab25ea9bfcef8d1ba5814929c77d92ed/" rel="bookmark">
			【数据结构初阶】二叉树--基本概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hello！
目录
一、树
1.1 树的概念和结构
1.2 树的相关术语 1.3 树的表示
1.4 树形结构实际应用场景
二、二叉树
2.1 概念和结构
2.2 特殊的二叉树
2.2.1 满二叉树
2.2.2 完全二叉树
2.3 二叉树的存储结构
2.3.1 顺序结构
2.3.2 链式结构
Relaxing Time！
—————————— 爱的华尔兹 ——————————
一、树 1.1 树的概念和结构 树是一种非线性的数据结构，它是由n（n&gt;=0）个有限结点组成的一个具有层次关系的集合。树，顾名思义，因为它看起来像一个倒挂的树，也就是说它根朝上，叶朝下。
有一个特殊的结点，称为根节点，根节点没有前驱结点。除根结点外，其余结点被分成M（M&gt;0）个互不相交的集合T1、T2、...、Tm，其中每一个集合Ti（1&lt;=i&lt;=m）又是一棵结构与树类似的子树。每棵子树的结点有且只有一个前驱，可以有0个或多个后继。因此，树是递归定义的。子树是不能相交的。（如果相交就是图了）。除了根结点之外，每个结点有且只有一个父结点。一棵N个结点的树有N-1条边。 【注意】
树形结构中，子树之间不能有交集，否则就不是树形结构。
非树形结构：
1.2 树的相关术语 父结点/双亲结点：若一个结点含有子结点，则这个结点称为其子结点的父结点；如上图中的A是B的父结点。
子结点/孩子结点：一个结点含有的子树的根结点称为该结点的子结点,；B是A的子结点。
结点的度：一个结点有几个孩子，它的度就是多少；A的度为6，E的度为2。
树的度：一棵树中，最大的结点的度称为树的度；；该树的度为6。
叶子结点/终端结点：度为0的结点称为叶结点；B、C、O、P结点等都为叶子结点。
分支结点/非终端结点（非叶子结点）：度不为0的结点；A、D、E等结点。
兄弟结点：具有相同父结点的结点互称为兄弟结点（亲兄弟）；M和N为兄弟结点。
结点的层次：从根开始定义起，根为第一层，根的子结点为第二层，以此类推。
树的高度或深度：树中结点的最大层次；上图树的高度为4。
结点的祖先：从根到该结点所经分支上的所有结点；A是所有结点的祖先。
路径：一条从树中任意结点出发，沿父结点到子结点连接，达到任意结点的序列；如，从A到P的路径为：A-E-J-P，H到P：H-D-A-E-J-P。
子孙：以某结点为根的子树中任一结点都称为该结点的子孙。上图中，所有结点都为A的子孙。
森林：由m（m&gt;0）棵互不相交的集合称为森林。
1.3 树的表示 树结构相对线性表更复杂，要存储起来比较麻烦，既要保存值域，又要保存结点和结点之间的关系。实际中树有很多表示方法如：双亲表示法，孩子表示法，孩子双亲表示法以及孩子兄弟表示法等。我们先简单了解一下其中最常用的孩子兄弟表示法。
struct TreeNode { struct Node* child; //左边开始的第一个孩子结点 struct Node* brother;//指向其右边的下一个兄弟结点 int data; //结点中的数据域 } 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab25ea9bfcef8d1ba5814929c77d92ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2205c5938e4d4f8afe0a1d95aba5f98a/" rel="bookmark">
			数据结构之位图与布隆过滤器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找往期文章包括但不限于本期文章中不懂的知识点：
个人主页：我要学编程(ಥ_ಥ)-CSDN博客
所属专栏：数据结构（Java版） 位图概念 所谓位图，就是用每一位来存放某种状态，适用于海量数据，整数，数据无重复的场景。通常是用来判断某个数据存不存在的。
例如：现在有一组 int 类型的数据1~10，怎么判断是否全部被储存起来了？
按照正常的处理的话，应该是把这10个数据全部存储到数组中，然后再遍历数据即可知道。这其中用到的内存是40个字节；如果用位图来处理，就是这样：一个字节有8个比特位，用比特位来标识是否存在，那么就只需要用两个字节即可（12个比特位）。
位图的模拟实现 public class BitSet { public byte[] elem; public int usedSize; // 记录存放元素的个数 public BitSet() { elem = new byte[2]; // 默认给16个比特位 } public BitSet(int n) { elem = new byte[n]; // 给8n个比特位 } // 把数据对应的位置置为1 public boolean set(int val) { if (val &lt; 0) { System.out.println("插入元素坐标异常"); return false; } // 先找到对应的下标 和 下标对应的位置 int index = val / 8; int bitIndex = val % 8; if (index &gt;= elem.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2205c5938e4d4f8afe0a1d95aba5f98a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d683b568ff5ca95af42faaabf5b9a69/" rel="bookmark">
			鸿蒙 点击获取电话号拨打电话 @ohos.telephony.call (拨打电话)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1, 先看看效果 2, 直接CV 代码 import call from '@ohos.telephony.call' @Entry @Component struct Index { @State photo: string = '15517189270' build() { Column() { Row() { Text(this.photo) Image($r('app.media.ic_contacts_incoming_filled')) .width(30) .height(30) .fillColor(Color.Orange) } .onClick(() =&gt; { console.log('onClick', 1111) call.makeCall(this.photo) }) } .width('100%') .height('100%') .justifyContent(FlexAlign.Center) } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7a05c29d2e1d590866c440eacd11a86/" rel="bookmark">
			（普通用户）Cannot connect to the Docker daemon at unix:///var/run/docker.sock.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错： Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? #大概像以下的报错内容 MernyPierreMBP:~ merny24$ docker info Client: Version: 26.1.4 Context: default Debug Mode: false Server: ERROR: Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? errors pretty printing info MernyPierreMBP:~ merny24$ 环境：
在做某项配置时发现docker不能使用，检查了daemon.json文件是没有问题的。因为是另一个运维做的环境，就只有普通用户，docker的权限给不到
方法一 sudo groupadd docker #添加用户组
sudo gpasswd -a username docker #将当前用户添加至用户组
newgrp docker #更新用户组
#没效果再重启下试试
方法二 vim /lib/systemd/system/docker.service # Ubuntu的路径; /usr/lib/systemd/system/docker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7a05c29d2e1d590866c440eacd11a86/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/36/">«</a>
	<span class="pagination__item pagination__item--current">37/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/38/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>