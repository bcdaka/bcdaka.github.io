<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8a0db57843d8fc12a5fc3bb9647ec92/" rel="bookmark">
			科技与水利的完美融合：从数据采集到智能决策，全面解析智慧水利解决方案如何助力水利行业实现智能化管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文关键词：智慧水利、智慧水利工程、智慧水利发展前景、智慧水利技术、智慧水利信息化系统、智慧水利解决方案、数字水利和智慧水利、数字水利工程、数字水利建设、数字水利概念、人水和协、智慧水库、智慧水库管理平台、智慧水库建设方案、智慧水库解决方案、智慧水库管理系统、数字孪生流域、水库雨水情监测及大坝安全监测解决方案、智慧河道、智慧治水、数字孪生智慧水利、数字孪生流域及工程建设思路、智慧河湖可视化监管、水库监测预警系统、水利工程智能可视化管理系统、智慧水利信息化平台系统建设、水环境综合治理、水利数字化、智慧防汛
在21世纪的今天，随着信息技术的飞速发展，各行各业正经历着前所未有的变革，水利行业也不例外。智慧水利，作为传统水利与现代信息技术深度融合的产物，正以其强大的数据采集能力、高效的信息处理机制以及智能的决策支持系统，为水利行业的管理与运营带来了革命性的变化。本文将从数据采集、信息处理、智能决策等多个维度，全面解析智慧水利解决方案如何助力水利行业实现智能化管理，探索其背后的技术支撑与实践路径。
引言：水利行业的新篇章 自古以来，水利便是农业的命脉、城市的基石，关乎国计民生。然而，面对全球气候变化、水资源短缺、洪涝灾害频发等挑战，传统水利管理模式已难以满足现代社会的需求。智慧水利应运而生，它利用物联网、大数据、云计算、人工智能等先进技术，构建起一个集感知、分析、预测、决策、执行为一体的智能管理体系，实现了水利资源的精准管理、科学调度和高效利用。
一、数据采集：构建水利感知神经网络 智慧水利的第一步是建立全面的数据采集系统，这相当于为水利行业搭建了一套敏锐的感知神经网络。通过部署各类传感器、遥感设备、无人机、无人船等，实现对水位、水量、水质、土壤湿度、降雨量等水环境参数的实时监测。同时，结合GIS（地理信息系统）技术，将采集到的数据空间化，形成水利信息的“一张图”，为后续的数据处理与分析提供坚实基础。
1、传感器技术：高精度、低功耗的传感器被广泛应用于水文监测站、水质监测站、雨量站等，实时捕捉水文动态。
2、遥感技术：卫星遥感、无人机航拍等技术手段，拓宽了数据收集的范围和精度，尤其在难以到达或人力监测成本高昂的区域。
3、物联网技术：通过物联网平台，将各类传感器设备互联互通，实现数据的自动采集、传输与存储，构建起庞大的水利数据仓库。
二、信息处理：大数据赋能水利决策 数据采集之后，如何高效、准确地处理这些数据，成为智慧水利的核心挑战之一。大数据技术的应用，使得海量水利数据得以快速分析、挖掘和可视化展示，为水利管理者提供了丰富的决策依据。
1、数据清洗与整合：首先，对采集到的原始数据进行清洗，去除噪声和异常值，确保数据的准确性和可靠性。随后，通过数据整合技术，将不同来源、不同格式的数据统一到同一平台上，形成完整的数据集。
2、数据挖掘与分析：运用大数据分析技术，如关联规则挖掘、聚类分析、时间序列分析等，揭示水利数据背后的规律和趋势，如洪水预警、水资源优化配置等。
3、可视化展示：通过数据可视化工具，将分析结果以图表、地图等形式直观呈现，帮助决策者快速理解复杂的水利信息，提高决策效率。
三、智能决策：AI引领水利管理新高度 在数据处理的基础上，智慧水利进一步引入人工智能技术，构建智能决策支持系统，实现水利管理的自动化、智能化。
1、预测预警系统：利用机器学习算法，对历史数据进行训练，建立洪水、干旱等自然灾害的预测模型，提前发布预警信息，为防灾减灾争取宝贵时间。
2、智能调度系统：根据实时水情、雨情、工情等信息，结合水库、河道、泵站等水利工程的运行状况，智能计算最优调度方案，实现水资源的合理分配和高效利用。
3、自动化控制系统：通过远程控制技术和智能设备，实现水利工程的自动化操作，如闸门启闭、泵站启停等，减少人力成本，提高运行效率。
四、实践案例：智慧水利的生动实践 近年来，国内外已涌现出众多智慧水利的成功案例，展示了智慧水利解决方案在提升水利管理效能、保障水安全方面的巨大潜力。
1、中国太湖流域智慧水利：通过构建全流域的监测网络和智能决策平台，实现了对太湖流域水资源的全面监控和精准调度，有效缓解了流域内的水污染和洪涝灾害问题。
2、荷兰鹿特丹智慧水务：利用物联网和大数据分析技术，优化城市供排水系统，提高了水资源的回收利用率，同时降低了能耗和运营成本，成为全球智慧水务的典范。
五、未来展望：智慧水利的无限可能 展望未来，随着5G、区块链、量子计算等前沿技术的不断成熟和应用，智慧水利将迎来更加广阔的发展前景。一方面，更高速度、更低延迟的数据传输能力将进一步提升水利监测的实时性和准确性；另一方面，区块链技术有望在水资源管理、水权交易等领域发挥重要作用，增强数据的安全性和可信度。同时，量子计算的突破也将为复杂水利问题的求解提供更强大的计算能力支持。
六、面临的挑战与应对策略 尽管智慧水利前景广阔，但在实际推进过程中仍面临诸多挑战。
1、数据安全与隐私保护：随着大量水利数据的收集与处理，如何确保数据的安全性、防止数据泄露成为重要课题。需建立健全的数据安全管理体系，采用加密技术、访问控制等手段保障数据安全；同时，加强数据隐私保护意识教育，确保用户信息不被滥用。
2、技术融合与标准化：智慧水利涉及多个技术领域，如何实现不同技术之间的无缝融合、制定统一的技术标准和规范，是推进智慧水利建设的关键。应加强跨领域合作，推动技术标准的制定与实施；同时，鼓励技术创新与试点示范，加速技术成果的转化与应用。
3、资金投入与人才培养：智慧水利建设需要巨大的资金投入和专业人才支持。应加大政府财政投入，吸引社会资本参与；同时，加强水利信息化人才队伍建设，培养既懂水利又懂信息技术的复合型人才，为智慧水利的发展提供有力的人才保障。
4、公众参与与意识提升：智慧水利的建设和运营离不开公众的广泛参与和支持。应加强水利科普教育，提高公众的水资源保护意识；同时，通过公众参与平台，让公众了解水利信息、参与水利决策过程，形成全社会共同关注水利、支持水利的良好氛围。
“方案365”全新整理智慧水利、数据资产、乡村振兴规划设计、智慧文旅、智慧园区、数字乡村-智慧农业、智慧城市、数据治理、智慧应急、数字孪生、乡村振兴、智慧乡村、元宇宙、数据中台、智慧矿山、城市生命线、智慧校园、智慧工地、智慧农业、智慧旅游等300+行业全套解决方案。
结语 智慧水利是科技与水利完美融合的产物，它以其独特的魅力和无限的潜力正引领着水利行业迈向新的发展阶段。从数据采集到智能决策，智慧水利解决方案不仅提升了水利管理的效率和质量，更为实现水资源的可持续利用、保障国家水安全提供了有力保障。面对未来的挑战与机遇，我们应坚持创新驱动发展战略，加强技术创新与人才培养，推动智慧水利的深入发展与应用，共同绘制水利事业的美好蓝图。
在这个过程中，每一位水利工作者、每一位科技工作者都应肩负起历史赋予的使命和责任，以更加饱满的热情、更加坚定的信念、更加扎实的行动投身到智慧水利的建设中来。让我们携手并进、共同努力，为构建人水和谐共生的美好未来贡献智慧和力量！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/578cf2be1ef7f13bdadb38517d20f2ce/" rel="bookmark">
			PostgreSql中的JSON数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PostgreSQL 提供了两种 JSON 数据类型：JSON 以及 JSONB。这两种类型主要的区别在于数据存储格式，JSONB 使用二进制格式存储数据，更易于处理。
PostgreSQL 推荐优先选择 JSONB 数据类型。
两种数据类型之间的区别：
功能JSONJSONB存储格式字符串原文存储解析后的二进制全文索引不支持支持保留空白符保留不保留保留键的顺序保留不保留保留重复键保留不保留 由于存储格式的不同，JSONB 输入时稍微慢一些（需要转换），但是查询时快很多。
接下来的内容主要使用 JSONB 数据类型，但是大部分功能也可以使用 JSON 数据类型。
一、创建并插入数据 CREATE TABLE product ( id INTEGER NOT NULL PRIMARY KEY, name VARCHAR(100), attr1 JSONB, attr2 JSON ); 1. 插入数据： INSERT INTO product VALUES ( 1, '阿莫西林', '{ "code": "100011", "price": 18, "uom": "盒", "specification": "10粒/盒", "price": 18.00 }', '{ "code": "100011", "price": 18, "uom": "盒", "specification": "10粒/盒", "price": 18.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/578cf2be1ef7f13bdadb38517d20f2ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a87360d53024b2e2a88afcd16463bf17/" rel="bookmark">
			科技信息项目验收测试包括哪些内容?验收测试报告如何获取?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		科技信息项目验收测试是指在科技信息项目完成后，组织专业测评团队对项目开发过程和成果进行全面、系统、客观的评测和鉴定的过程。通过验收测试，可以评估项目的质量、功能完整性以及满足业务需求的程度，并为项目的成功上线提供依据。
为了进行科技信息项目验收测试，需要明确测试的目标和测试范围。测试的目标是指通过测试来验证项目的功能和性能是否达到预期目标，测试的范围是指要测试的项目模块、功能和性能方面的要求。
在进行科技信息项目验收测试时，需要进行多个测试内容，其中包括：
1、功能测试：各项功能是否能正常运行，包括用户界面、业务逻辑等方面。
2、性能测试：在各种负载和压力条件下的性能表现，包括响应速度、并发处理能力等。
3、安全测试：安全性能，包括数据加密、权限控制等方面。
4、兼容性测试：在不同操作系统、浏览器以及设备上的兼容性。
5、易用性测试：用户界面是否友好、易于操作。
如果需要获取科技信息项目验收测试报告，可以通过以下途径获取：
1、向科技信息项目的开发团队索要。开发团队通常会为项目提供详细的测试报告，包括测试目标、测试方案、测试结果等。
2、通过第三方测评机构获取。一些专业的测评机构，如卓码软件测评，会提供科技信息项目的验收测试服务，并输出相应的测试报告。
科技信息项目验收测试是项目完成后的重要环节，通过客观、全面的评估和鉴定，可以保证项目的质量和功能达到预期目标，并为项目的成功上线提供依据。
文章来源：科技信息项目验收测试包括哪些内容?验收测试报告如何获取?—卓码软件测评
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e064532205273a3864cccce515cb81a/" rel="bookmark">
			Ajax从零到实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💝💝💝欢迎来到我的博客，很高兴能够在这里和您见面！希望您在这里可以感受到一份轻松愉快的氛围，不仅可以获得有趣的内容和知识，也可以畅所欲言、分享您的想法和见解。
非常期待和您一起在这个小小的网络世界里共同探索、学习和成长。💝💝💝 ✨✨ 欢迎订阅本专栏 ✨✨
前言
本栏目是根据黑马程序员的网课来整理的笔记，也会结合我的一些个人见解，来记录自己学习Ajax的过程，俗话说，好记性不如烂笔头，小郑喜欢在学习的过程中记笔记，记下自己在学习过程中难以理解的知识点，反复练习，加深印象，小郑打算在这个暑假的第一个月学习完Ajax从0到1实现项目，希望广大网友一起监督学习，互相进步!
什么是 AJAX ? 使用浏览器的 XMLHttpRequest 对象 与服务器通信
浏览器网页中，使用 AJAX技术（XHR对象）发起获取省份列表数据的请求，服务器代码响应准备好的省份列表数据给前端，前端拿到数据数组以后，展示到网页
引入 axios.js 文件到自己的网页中 axios.js文件链接:https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js
axios函数的使用语法
axios({ url: '目标资源地址' }).then((result) =&gt; { // 对服务器返回的数据做后续处理 }) URL 查询参数 1. 查询参数的语法 在 url 网址后面用?拼接格式：XXXX?参数名1=值1&amp;参数名2=值2
参数名一般是后端规定的，值前端看情况传递即可
2. axios 如何携带查询参数? 查询城市列表的 url地址：http://hmajax.itheima.net/api/city
axios({ url: '目标资源地址', params: { 参数名: 值 } }).then(result =&gt; { // 对服务器返回的数据做后续处理 }) 查询地区列表案例 查询地区: http://hmajax.itheima.net/api/area
/* 获取地区列表: http://hmajax.itheima.net/api/area 查询参数: pname: 省份或直辖市名字 cname: 城市名字 */ // 目标: 根据省份和城市名字, 查询地区列表 // 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e064532205273a3864cccce515cb81a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a25e119d31d7a7389958ac135b81b49/" rel="bookmark">
			评价妙笔生词智能写歌词软件：助力与局限并存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在音乐创作的领域，科技的发展催生了各种创新工具，妙笔生词智能写歌词软件便是其中引人注目的一项。对于这款软件，我们需要以客观和全面的视角来进行评估，因为它既带来了显著的助力，同时也存在不可忽视的局限。
妙笔生词智能写歌词软件（veve522）的助力作用首先体现在它能够为创作者提供快速的灵感启发。当创作者面临思维卡顿或者缺乏创作方向时，软件可以在短时间内生成一系列的词句和主题建议，帮助打破僵局，开启创作的思路。
其丰富的词汇库和多样化的句式模板也为创作者节省了大量查找资料和构思基础结构的时间。创作者可以在此基础上进行修改和完善，提高创作效率。
然而，妙笔生词智能写歌词软件的局限也同样明显。由于其生成的歌词是基于算法和数据模型，往往缺乏人类情感的细腻度和深度。歌词可能在形式上完整，但在传达情感和引发共鸣方面显得较为薄弱。
此外，软件的创作模式相对固定，可能导致生成的歌词存在一定的重复性和模式化。这对于追求独特性和创新性的创作者来说，可能会限制他们的发挥空间，使作品难以脱颖而出。
再者，虽然软件能够遵循一定的韵律和节奏规则，但在把握音乐的整体氛围和与旋律的完美融合方面，仍无法与人类创作者的直觉和艺术感知相媲美。
妙笔生词智能写歌词软件在音乐创作中是一把双刃剑。它在提供便捷和启发的同时，也存在着情感表达不足和模式化的问题。创作者在使用时应充分认识到其助力和局限，将其作为辅助工具，结合自身的创意和情感，以创作出更具感染力和艺术价值的歌词作品。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a35fb2e2200d6af6bebdd0d14ca98d06/" rel="bookmark">
			gitee上传和下载idea项目的流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：idea2022 一、上传项目 1、在gitee中新建一个仓库。
2、打开所要上传的项目的文件夹，点击Git Bash，生成.git文件夹。
3、在idea中打开所要上传的项目，在控制台的Terminal菜单中，输入git add . (注意：add后面有一个点) 。这个时候所有文件的名字都是红色。
4、点击上方菜单栏中Git-&gt;Commit，就会出现下图左部分的内容。再随便添加一个注释，点击Commit and Push按钮。会弹出一个窗口，要求填写URL。我们暂时不管。
小tips：当点击Git-&gt;Commit之后，文件都会变成绿色。
5、点击新建的仓库，点击克隆/下载，复制HTTPS的地址
6、把复制的地址，放到弹窗的URL中。点击Push按钮，就上传成功了。
二、下载项目 1、点击克隆/下载—&gt;SSH，复制SSH。
2、打开Git Bash，输入：
git clone (将复制的SSH放到这里) 3、项目就在里面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a3d6044ea7a7ee02492b9e6b426422e/" rel="bookmark">
			谷粒商城实战笔记-27-分布式组件-SpringCloud-Gateway-创建&amp;测试API网关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本节的主要内容是创建网关模块，将网关注册到Nacos，并配置路由进行测试。
一，创建网关模块 右键工程New-&gt;Module，创建新模块，模块名称 gulimall-gateway。
填充各种信息。
选中Gateway依赖。
点击Create创建模块。
二，网关服务配置 1，依赖common模块 &lt;dependency&gt; &lt;groupId&gt;com.atguigu.gulimall&lt;/groupId&gt; &lt;artifactId&gt;gulimall-common&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; 因为网关服务也需要使用注册中心和配置中心，所以需要相关的包的依赖，通过依赖common模块得到。
2，启动服务发现 通过在启动类增加注解，让服务启动后注册到注册中心。
@EnableDiscoveryClient 3，创建配置文件 在resources目录下新建三个配置文件。
① application.properties
配置Nacos注册中心相关信息。
server.port=80 spring.cloud.nacos.discovery.server-addr=localhost:8848 spring.application.name=gulimall-gateway ② bootstrap.properties
配置Nacos配置中心的相关信息，注意，要事先在Nacos上创建一个名为gateway的命名空间，网关模块的所有配置文件都存放在这个命名空间下。
spring.application.name=gulimall-gateway spring.cloud.nacos.config.server-addr=localhost:8848 spring.cloud.nacos.config.namespace=405d2201-d62b-4203-80c8-800e9387ad40 ③ application.yml
这个文件中，编写网关路由配置，具体内容见下一部分。
三，网关路由配置 1，路由配置 这一部分，我们以两个实际的需求为例，练习如何配置网关。
网关的作用是根据网关配置的规则，将接收到的请求转发到相应的服务。
为了方便演示，假设有这样的需求，在浏览器输入如下url时，将请求转发到百度。
http://localhost/?url=baidu 在浏览器输入如下url时，将请求转发到腾讯。
http://localhost/?url=qq 该如何编写配置文件呢？
仓库Spring Cloud Gateway的官方文档，参考其格式。
因为我们需要根据url上的查询条件进行对应的转发，所以找到Gateway关于Query的断言配置文档。
参照这个文档进行配置。
application.yml
spring: cloud: gateway: routes: - id: baidu_test uri: https://www.baidu.com predicates: - Query=url,baidu - id: qq_test uri: https://www.qq.com predicates: - Query=url,qq 这里定义了两个路由规则，用于根据查询参数url的值来决定请求应该转发到哪个目标URI。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a3d6044ea7a7ee02492b9e6b426422e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb2501a4a34424b0d6d0166094cab3e0/" rel="bookmark">
			C&#43;&#43;：从C语言过渡到C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这篇博客中，我将会介绍从C语言过渡到C++的一些基础知识。
目录
C++起源
C++的关键字
输出hello，world
​编辑
命名空间
1.什么是命名空间
2.namespace的作用
3.域作用限定符
4.命名空间的使用
IO流
缺省参数
函数重载
引用
1.引用的定义
2.引用的特性
3.引用的使用
4.const引用
5.引用和指针
内联函数inline
nullptr
C++起源 在1979年，本贾尼·斯特劳斯特卢普在贝尔实验室中进行复杂的软件开发时，他感受到了C语言的局限性，于是他在此基础上设计了C++。
C++在C语言的基础上添加了面向对象编程的特性:封装、继承、多态。
随后几年，C++不断完善发展，在1998年推出了C++98，官方第一个较为完善的版本，引入了STL（标准模板库）。
在2011年，C++的一次革命性的更新，增加了大量特性和功能。
在2020年，C++又一次巨大更新，引入了模板（Modules）、概念（Concepts）、协程（Coroutines）等
在公司中，使用的比较多的都是C++98和C++11.
C++的关键字 输出hello，world #include&lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; "hello,world!" &lt;&lt; endl; return 0; } 命名空间 1.什么是命名空间 命名空间需要用一个关键字namespace，后跟命名空间的名字，然后用{}括起来，在里面可以定义变量、函数、自定义类型，即为命名空间的成员。
2.namespace的作用 在C/C++中，变量、函数、类是大量存在的，这些名称在全局域中可能会重复从而引发冲突。
#include&lt;stdlib.h&gt; int rand = 15; int main() { //这里会报编译错误，“rand” : 重定义；以前的定义是“函数”	printf("%d\n", rand); return 0; } C++中域有函数局部域，全局域，命名空间域，类域。局部域和全局域除了会影响编译查找逻辑，还会影响变量的生命周期，命名空间域和类域不影响变量生命周期。
namespace会定义一个域，也就是命名空间域，它与全局域独立，不同的域可以存在同名变量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb2501a4a34424b0d6d0166094cab3e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23aa80e2e46726df9f65008319fb30d9/" rel="bookmark">
			由于生成一个完整的App通常涉及前端界面设计、后端逻辑处理以及可能的数据库交互，这里我将以几个流行的技术栈为例，简要说明如何用不同的编程语言和技术来开始一个简单的App项目。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Flutter (Dart)jzsafe.com
Flutter是Google开发的一个开源UI工具包，允许开发者使用Dart语言快速在iOS和Android上构建高性能的原生应用。 示例代码（简单的Flutter应用）：
dart
import ‘package:flutter/material.dart’;
void main() {
runApp(MyApp());
}
class MyApp extends StatelessWidget {
@override
Widget build(BuildContext context) {
return MaterialApp(
title: ‘Flutter Demo’,
home: Scaffold(
appBar: AppBar(
title: Text(‘Hello World’),
),
body: Center(
child: Text(‘Hello, Flutter!’),
),
),
);
}
}
2. 使用React Native (JavaScript/TypeScript)
React Native允许开发者使用JavaScript（或TypeScript）来编写原生iOS和Android应用。
示例代码（简单的React Native应用）：
jsx
import React from ‘react’;
import { View, Text, StyleSheet, AppRegistry } from ‘react-native’;
const App = () =&gt; {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23aa80e2e46726df9f65008319fb30d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a5f4405d174dc925cf73dcd7f6ff136/" rel="bookmark">
			期货量化交易客户端开源教学第十节——行情列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		行情列表数据
行情列表数据接收 行情列表接收到的数据根据接收到的数据进行字符处理。为了方便查看行情数据针对每个字段进行显示控制，并可根据显示器自动适配列宽。
发送命令：2
数据接受返回的格式： 2;13;1720682964;000;12021.00;24;12020.00;12020.00;77;0;0;182560;912607;11908.00;12021.00;12059.00;11899.00;0;11911.00;167886;0;11911.00;
数据接受返回的格式：2;商品ID;更新时间;更新毫秒;卖1;卖1量;现价;买1;买1量;涨停板价;跌停板价;成交量;持仓量;今开盘;今收盘;最高价;最低价;当日均价;昨收盘;昨持仓量;成交金额;昨日结算价格;
行情列表数据接收处理代码 if strList.Strings[0] = '2' then begin try for I := 0 to Length(VGStocks) - 1 do begin if VGStocks[I].id = strList.Strings[1] then begin try strBodong := FloatToStr(VGStocks[I].smallest_fluctuation); except end; VGStocks[I].curr_unix_datetime := strList.Strings[2]; VGStocks[I].curr_time := FormatDateTime('YYYY-MM-DD hh:mm:ss ',UnixToDateTime(StrToInt(strList.Strings[2])+28800)) + strList.Strings[3]; if StrToFloat(strList.Strings[4]) &lt;= 0 then VGStocks[I].sell_price := '--' else VGStocks[I].sell_price := FormatDigital(strBodong,strList.Strings[4]); VGStocks[I].sell_num := FormatDigital('0',strList.Strings[5]); if StrToFloat(strList.Strings[6]) &lt;= 0 then VGStocks[I].curr_price := '--' else VGStocks[I].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a5f4405d174dc925cf73dcd7f6ff136/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dfb475573029b9a1f0773a4b03bb791/" rel="bookmark">
			【数据结构】单链表 双向链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 链表链表的分类单链表单链表接口的实现内部类头插法尾插法任意位置插入查找是否包含关键字key是否在单链表当中删除第一次出现关键字为key的节点删除所有值为key的节点得到单链表的长度清空链表单链表的优缺点 双向链表双向链表接口的实现内部类头插法尾插法任意位置插入查找是否包含关键字key是否在单链表当中删除第一次出现关键字为key的节点删除所有值为key的节点得到链表的长度清空链表 Java中的LinkedList实现的接口构造方法常用方法双向链表的优劣 ArrayList和LinkedList对比链表练习 链表 链表就是一种物理存储结构上非连续存储结构，数据元素的逻辑顺序是通过链表中的引用链接次序实现的 。
也是线性表。
数据域：存储数据元素信息的域。
指针域：存储直接后继的信息。
链表的分类 链表根据三个条件分类：
有头无头：有没有头结点，头结点的数据域是无用的。是否循环：尾结点又指回头。单向还是双向：指针域包不包含指向前面域的指针。 根据以上3个条件来分类（每一个条件选一），链表一共有8种。
单链表 单链表全称为：无头单向不循环链表。
单链表接口的实现 自己实现一个单链表（存储int数据类型），将单链表作为一个类，我们实现一些“接口”即成员方法来实现数据的增删查改。
// 1、无头单向非循环链表实现 public class SingleLinkedList { //头插法 public void addFirst(int data); //尾插法 public void addLast(int data); //任意位置插入,第一个数据节点为0号下标 public boolean addIndex(int index,int data); //查找是否包含关键字key是否在单链表当中 public boolean contains(int key); //删除第一次出现关键字为key的节点 public void remove(int key); //删除所有值为key的节点 public void removeAllKey(int key); //得到单链表的长度 public int size(); //清空链表 public void clear(); } 内部类 因为我们需要使用数据域，指针域，在链表中一个一个串起来。那我们就将数据域指针域使用一个静态内部类来封装。只将第一个节点用head来表示。
注意：此处的head不是链表分类时的头，因为分类的头的数据域的数据是无效的而此处是有效的。
public class SingleLinkedList { static class ListNode{ public int val; public ListNode next; public ListNode(int val) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dfb475573029b9a1f0773a4b03bb791/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40c3a49680d50aa1547bcfbb751e0601/" rel="bookmark">
			Docker Push Docker Hub
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先可以参考 Docker | 将自己的docker镜像推送到docker hub[图文详情]_如何将自己的docker镜像上传到dockerhub上-CSDN博客
将自己的镜像打标签 和 镜像推送到 docker hub上的图文注意一下
1.打标签之前 docker tag paddleocr_fast_api:1.0 hmgx/wlx:3.0
2.打标签之后
3.开始推送
docker push hmgx/wlx:3.0
4.推送完成就可以在 docker hub上查看到了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e5e5d0055a4e265d0e0efd82e9b7e36/" rel="bookmark">
			单链表面试题---移除链表元素和翻转链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.移除链表元素 题目链接：203. 移除链表元素 - 力扣（LeetCode）
解法一：定义两个指针 分别定义两个指针，分别为cur和prev，让cur=head.next，让prev=head。
如下图
cur指针是用来确定该节点的数据是否为要删除的数据，如果cur指向的节点的数据为要删除的数据，则我们让prev.next=cur.next，然后再让cur=cur.next。如果cur指向的节点中的数据不是要删除的，则让prev=cur，cur=cur.next。
过程图
假设11是我们要删除的数据，则观察图，看到cur指向的数据为11，则执行prev.next=cur.next，cur=cur.next
然后发现cur指向的节点中的数据不是要删除的数据，我们同时让prev=cur，cur=cur.next。
持续上面的步骤，一直到cur指向空。
但是以上这种写法，没有解决要删除的节点在头节点的问题，所以我们要将这一情况单独拿出来解决。
public ListNode removeElements(ListNode head, int val) { if(head==null){ return head; } ListNode cur=head.next; ListNode prev=head; while(cur!=null){ if(cur.val==val){ prev.next=cur.next; cur=cur.next; }else{ prev=cur; cur=cur.next; } } //解决头节点为删除节点的情况 if(head.val==val){ head=head.next; } return head; } 解法二：定义一个新链表 我们可以定义一个新链表，然后将不是要删除的节点放到新节点，最后放回newHead.next。 代码实现
public ListNode removeElements(ListNode head, int val) { if(head==null){ return null; } ListNode newHead=new ListNode(); ListNode cur=head; ListNode cur2=newHead; while(cur!=null){ if(cur.val!=val){ cur2.next=cur; //注意让cur2=cur cur2=cur; } cur=cur.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e5e5d0055a4e265d0e0efd82e9b7e36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97858b79b94fb6e39b7aae805518a6af/" rel="bookmark">
			Docker 使用基础（3）—容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎬慕斯主页：修仙—别有洞天
♈️今日夜电波：秒針を噛む—ずっと真夜中でいいのに。
0:34━━━━━━️💟──────── 4:20
🔄 ◀️ ⏸ ▶️ ☰ 💗关注👍点赞🙌收藏您的每一次鼓励都是对我莫大的支持😍
目录
首先理解几个概念
Docker容器（Container ）是什么？
为什么需要容器？
容器的生命周期
容器的命令详解
1. docker create
2. docker logs
3. docker attach
4. docker exec
5. docker start
6. docker stop
7. docker restart
8. docker kill
9. docker top
10. docker stats
11. docker container inspect
12. docker port
13. docker cp
14. docker diff
15. docker commit
16. docker pause
17. docker unpause
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97858b79b94fb6e39b7aae805518a6af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fdec31c988149fa72770c0c5bcb294e/" rel="bookmark">
			【AI大模型】从零开始运用LORA微调ChatGLM3-6B大模型并私有数据训练_chalm3进行lora训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录导航
1.什么是ChatGLM3-6B2.什么是LORA微调技术3.算力平台4.环境搭建 4.1 虚拟环境conda工具搭建并激活4.2 CUDA版本查看和torch版本匹配4.3 git lfs下载4.4 模型下载和代码拉取4.5 依赖下载 5 模型微调 5.1 数据准备5.2 LORA微调5.3 微调前后对比 6 总结 1.什么是ChatGLM3-6B ChatGLM3 是智谱AI和清华大学 KEG 实验室联合发布的对话预训练模型。ChatGLM3-6B 是 ChatGLM3 系列中的开源模型，在保留了前两代模型对话流畅、部署门槛低等众多优秀特性的基础上，ChatGLM3-6B 引入了如下特性：更强大的基础模型： ChatGLM3-6B 的基础模型 ChatGLM3-6B-Base 采用了更多样的训练数据、更充分的训练步数和更合理的训练策略。在语义、数学、推理、代码、知识等不同角度的数据集上测评显示，* ChatGLM3-6B-Base 具有在 10B 以下的基础模型中最强的性能*。更完整的功能支持： ChatGLM3-6B 采用了全新设计的 Prompt 格式 ，除正常的多轮对话外。同时原生支持工具调用（Function Call）、代码执行（Code Interpreter）和 Agent 任务等复杂场景。更全面的开源序列： 除了对话模型 ChatGLM3-6B 外，还开源了基础模型 ChatGLM3-6B-Base 、长文本对话模型 ChatGLM3-6B-32K 和进一步强化了对于长文本理解能力的 ChatGLM3-6B-128K。以上所有权重对学术研究完全开放 ，在填写 问卷 进行登记后亦允许免费商业使用。 2.什么是LORA微调技术 LoRA（Low-Rank Adaptation）微调技术是一种用于微调大型预训练语言模型的方法。这种技术的核心思想是通过在原有的模型中引入少量的额外参数来实现模型的微调，而不是改变模型的全部参数。这样做可以在保持预训练模型的大部分知识的同时，使模型适应特定的任务或数据集。LoRA主要通过在模型的每个变换器层中引入两个低秩矩阵（A 和 B）来实现。这些矩阵与原始的注意力矩阵或前馈网络权重矩阵相乘，以引入新的可训练参数。在实践中，通过这种方式添加的参数数量远少于原始模型的参数总量，从而大幅减少了微调过程中的计算和存储需求。LoRA技术特别适合于需要在资源受限环境下迅速部署模型的场景，例如在移动设备上或在云端服务中处理大量用户请求时。此外，这种方法也适用于那些需要对模型进行频繁更新的应用
😝有需要的小伙伴，可以V扫描下方二维码免费领取🆓
![](https://img-blog.csdnimg.cn/img_convert/6ddc5160bc725974998##### 3.算力平台
由于模型微调需要用到大量算力，对GPU要求较高，推荐小伙伴租借算力平台的服务器进行使用本文使用的环境：Ubantu + RTX4090 24G直接到算力平台租借即可 在这里插入图片描述
4.环境搭建 4.1 虚拟环境conda工具搭建并激活 安装conda 建议直接安装Anaconda即可本地 代码语言：javascript
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fdec31c988149fa72770c0c5bcb294e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bee5243ccab5cb0c2938aa3ae1acaabf/" rel="bookmark">
			阿里云调整全球布局关停澳洲云服务器，澳洲服务器市场如何选择稳定可靠的云服务？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日，阿里云宣布将关停澳大利亚地域的数据中心服务，这一决定引发了全球云计算行业的广泛关注。作为阿里云的重要海外市场之一，澳洲的数据中心下架对于当地的企业和个人用户来说无疑是一个不小的挑战。那么，在阿里云调整全球布局的背景下，澳洲服务器市场将如何演变？企业和个人用户又该如何选择稳定可靠的云服务呢？
一、阿里云全球布局调整与澳洲服务器市场的影响
阿里云此次调整全球布局，加大在东南亚、墨西哥等地域数据中心的投资，同时决定关停澳大利亚、印度两个地域的数据中心服务，是基于对全球基础设施投资布局规划的慎重评估和审视。这一决策背后反映了阿里云在全球云计算市场中的战略布局和对不同地域市场发展的考量。
对于澳洲服务器市场来说，阿里云的下架将带来一定的市场空缺。然而，这也为其他云服务提供商提供了机遇。澳洲作为一个发达国家，拥有发达的科技产业和互联网基础设施，对于企业和机构来说，在澳洲建立服务器仍然具有很大的优势。因此，澳洲服务器市场仍将继续保持活跃，各大云服务提供商将展开激烈的竞争。
二、澳洲服务器市场的新动向
随着阿里云的退出，澳洲服务器市场将迎来新的变化。一方面，本土的云服务提供商将加速发展，通过提供更加贴近用户需求的服务来抢占市场份额。另一方面，国际云服务巨头也将加大在澳洲市场的投入，通过提供更先进、更稳定、更可靠的云服务来满足用户的需求。
在这个过程中，用户选择云服务商的标准将更加注重稳定性、可靠性、安全性以及服务品质等方面。因此，对于企业和个人用户来说，选择一家合适的云服务商至关重要。
三、如何选择稳定可靠的澳洲服务器
在选择澳洲服务器时，用户可以从以下几个方面进行考虑：
1. 数据中心的地理位置：选择位于澳洲本土的数据中心，可以确保数据的本地存储和访问速度，提高用户体验。同时，也要考虑数据中心的地理位置是否安全、稳定，以及是否具备完善的备份和恢复机制。
2. 服务品质和技术支持：选择具有优质服务和专业技术支持的服务商，能够确保在遇到问题时能够得到及时的帮助和解决，确保业务的顺利运行。同时，拥有经验丰富的技术团队也能够提供专业的技术支持，确保用户的服务体验和数据安全。
3. 成本效益：在选择服务商时，用户还需要考虑成本效益。不同的服务商在价格、计费方式等方面可能存在差异，用户需要根据自己的需求和预算来选择最合适的方案。
总之，在选择澳洲服务器时，用户需要综合考虑多个因素，选择一家稳定可靠、服务优质、价格合理的服务商。只有这样，才能确保业务的稳定运行和数据的安全可靠。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1dd18ee33a9da9b5e2567d5acccf609/" rel="bookmark">
			【大数据】什么是数据清洗？（附应用场景及解决方案）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数据清洗的概念及应用场景 数据清洗是在数据处理和分析之前，对数据集进行清理和整理的过程。这个过程包括识别并纠正错误的、不完整的、不准确的、不相关的或者是重复的数据，以确保数据的质量和准确性。数据清洗的目的是提高数据的质量，使其更适合进行数据分析或数据挖掘。
应用场景 二、数据清洗的难点 数据清洗的难点主要包括：
1.数据质量问题
数据可能存在错误、缺失值、格式不一致等问题，这些都需要通过数据清洗来解决。
2.数据量大
随着数据量的增加，手动进行数据清洗变得越来越不现实，需要依赖自动化工具来提高效率。
3.数据来源多样
数据可能来自不同的来源，每个来源的数据格式和质量都可能不同，需要统一处理以保证数据的一致性。
4.时间成本
数据清洗是一个耗时的过程，尤其是在数据量大和数据质量差的情况下，需要投入大量的时间和资源。
通过使用专业的数据处理工具，如FineDataLink，可以有效地解决数据清洗的痛点，提高数据处理的效率和质量。FineDataLink提供了多种可视化算子和功能，如新增计算列、数据过滤、数据关联等，帮助用户快速完成数据清洗和处理，无需编写复杂的SQL语句，大大提升了开发效率。
三、解决方案 FineDataLink提供了丰富的数据清洗功能，帮助用户高效地进行数据处理。以下是FDL中可用于数据清洗的主要功能：
1. 数据过滤
当用户需要进行空值、重复值过滤，或是筛选出符合目标的值以进一步处理时，可以直接使用「数据转换」中的数据过滤功能进行数据处理。这是数据清洗中非常基础且常用的功能，有助于提高数据的质量和可用性。
2. 新增计算列
FDL提供了「新增计算列」功能，可以使用多种函数实现对数据的清洗计算。这个功能允许用户对数据进行各种计算操作，如字符串处理、数值计算等，非常适合对数据进行预处理和转换。
3. 数据关联
「数据关联」功能可以帮助用户将不同数据源中的数据进行关联，这在清洗数据时尤其有用，比如需要合并来自不同源的数据并进行一致性校验。
4. 列转行/行转列
「列转行」和「行转列」功能可以帮助用户调整数据的结构，使其更适合后续的分析和处理。这对于数据清洗和准备阶段来说是非常重要的，可以帮助用户解决数据结构不一致的问题。
5. Spark SQL
对于可视化算子不够丰富的情况，用户可以使用「Spark SQL」语法进行数据快速处理。这为数据清洗提供了极大的灵活性，用户可以编写SQL语句来执行复杂的数据清洗任务。
通过这些功能，FineDataLink为用户提供了强大的数据清洗能力，帮助用户提高数据质量，为数据分析和业务决策提供可靠的数据支持。
四、操作步骤 在FineDataLink中，我们可以通过以下步骤来实现数据的清洗和处理：
1.数据接入 首先，登录FineDataLink后，进入数据开发，新增数据转换节点，将数据表取出，为后续进行数据清洗做准备。
2.新增计算列 对需要清洗的字段进行处理。例如，如果需要清洗掉数据中的特殊字符（如货币符号、括号等），可以通过输入公式来实现。一个具体的例子是将带有特殊货币符号和括号的利润字段清洗成纯数字格式。
示例公式：TODOUBLE(if(left(利润,1)="(","-"+REPLACE(REPLACE(REPLACE(REPLACE(利润,"￥",""),",",""),"(",""),")",""),REPLACE(REPLACE(利润,"￥",""),",","")))
3.数据过滤 设置过滤条件，筛选出符合特定条件的数据。例如，筛选出「订购日期」为2023年，「运货费」大于100的数据。
4.数据输出 添加一个DB表输出算子，输出筛选后的数据，完成数据清洗的整个流程。
通过上述步骤，可以利用FineDataLink的可视化算子和功能，快速完成数据的清洗和处理，提高开发效率，无需编写复杂的SQL语句。
帆软FineDataLink——中国领先的低代码/高时效数据治理工具，能过为企业提供一站式的数据服务，通过快速连接、高时效融合多种数据，提供低代码Data API敏捷发布平台，帮助企业解决数据孤岛难题，有效提升企业数据价值。
了解更多数据仓库与数据集成关干货内容请关注&gt;&gt;&gt;FineDataLink官网
免费试用、获取更多信息，点击了解更多&gt;&gt;&gt;体验FDL功能
往期推荐：
一文详解DDL同步及其应用场景-CSDN博客
【大数据】什么是数据湖？一文揭示数据湖的本质-CSDN博客
业务场景中的数仓调度_kettle数仓各层调度-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f7875e343a04590ab44f607292a942b/" rel="bookmark">
			支付通道安全：应对黑客攻击的策略与实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数字化经济的今天，支付通道的安全性成为了企业和消费者共同关注的焦点。一旦支付通道遭到黑客攻击，不仅会导致资金损失，还会严重损害企业的声誉和客户信任。本文将介绍如何有效应对支付通道被黑客攻击的情况，包括预防措施、检测机制、应急响应流程以及恢复策略，旨在帮助企业构建稳固的支付安全体系。
1. 预防措施 1.1 强化身份验证 确保只有授权用户才能访问支付系统。使用多因素认证（MFA）、生物特征识别等技术，提高账户安全性。
示例代码（使用Django实现双因素认证）：
# settings.py 中启用Django的双因素认证 INSTALLED_APPS = [ ... 'django_otp', # Django Two-Factor Authentication 'django_otp.plugins.otp_totp', 'django_otp.plugins.otp_static', ] # urls.py 中添加双因素认证视图 from django.contrib.auth.views import LoginView from django_otp.decorators import otp_required urlpatterns = [ path('login/', LoginView.as_view(), name='login'), path('secure-view/', otp_required()(views.secure_view), name='secure_view'), ] 1.2 加密通信 采用SSL/TLS加密传输层数据，确保支付信息在传输过程中不被截获。
示例代码（使用Nginx配置HTTPS）：
server { listen 443 ssl; server_name example.com; ssl_certificate /path/to/cert.pem; ssl_certificate_key /path/to/key.pem; location / { proxy_pass http://your_payment_gateway; } } 1.3 定期审计 定期进行安全审计和漏洞扫描，及时发现并修复潜在的安全隐患。
示例代码（使用Nessus进行漏洞扫描）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f7875e343a04590ab44f607292a942b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bae0dc39b7dae71fdc07210160b6e711/" rel="bookmark">
			初阶数据结构（顺序表的实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 线性表 线性表是（linear list）n个具有相同特性的数据元素的有限队列。线性表是一种在实际广泛应用的的数据结构，常见的线性表：顺序表，链表，栈，队列，字符串。。。
线性表在逻辑结构上是连续的。但在物理结构上不一定连续，线性表在物理上存储时，通常以数组和链表的形式存储。
2. 顺序表 2.1 概念与结构 概念：顺序表是用一段物理地址连续的存储单元一次存储数据元素的线性结构，一般采用与数组类似的存储方式。
顺序表与数组的区别
顺序表的底层是数组，对数组进行封装，实现了增删查改等接口
2.2 分类 2.2.1 静态顺序表 概念：使用定长数组进行存储数据的结构
//静态顺序表
typedef int SLDataType;
#define N 7
typedef struct SeqList
{
SLDataType arr[N];// 定长数组
int size; //有效数据个数
}SL;
2.2.2 动态顺序表 //动态顺序表
typedef int SLDataType;
typedef struct SeqList
{
SLDataType* arr; //动态数组
int size; //有效数据个数
int capacity; //空间大小
}SL;
2.3 动态顺序表的实现 // 初始化和销毁 void SLInit(SL* ps); void SLDestroy(SL* ps); void SLPrint(SL* ps); // 扩容 void SLCheckCapacity(SL* ps); // 头部插⼊删除 / 尾部插⼊删除 void SLPushBack(SL* ps, SLDataType x); void SLPopBack(SL* ps); void SLPushFront(SL* ps, SLDataType x); void SLPopFront(SL* ps); // 指定位置之前插⼊ / 删除数据 void SLInsert(SL* ps, int pos, SLDataType x); void SLErase(SL* ps, int pos); //查找 int SLFind(SL* ps, SLDataType x); 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bae0dc39b7dae71fdc07210160b6e711/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d39e8ea10d318fb71152ec7f682b2ba/" rel="bookmark">
			Apache Doris &#43; Apache Hudi 快速搭建指南｜Lakehouse 使用手册（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：SelectDB 技术团队
导读：湖仓一体（Data Lakehouse）融合了数据仓库的高性能、实时性以及数据湖的低成本、灵活性等优势，帮助用户更加便捷地满足各种数据处理分析的需求。在过去多个版本中，Apache Doris 持续加深与数据湖的融合，已演进出一套成熟的湖仓一体解决方案。为便于用户快速入门，我们将通过系列文章介绍 Apache Doris 与各类主流数据湖格式及存储系统的湖仓一体架构搭建指南，包括 Hudi、Iceberg、Paimon、OSS、Delta Lake、Kudu、BigQuery 等，欢迎持续关注。
作为一种全新的开放式的数据管理架构，湖仓一体（Data Lakehouse）融合了数据仓库的高性能、实时性以及数据湖的低成本、灵活性等优势，帮助用户更加便捷地满足各种数据处理分析的需求，在企业的大数据体系中已经得到越来越多的应用。
在过去多个版本中，Apache Doris 持续加深与数据湖的融合，当前已演进出一套成熟的湖仓一体解决方案。
自 0.15 版本起，Apache Doris 引入 Hive 和 Iceberg 外部表，尝试在 Apache Iceberg 之上探索与数据湖的能力结合。自 1.2 版本起，Apache Doris 正式引入 Multi-Catalog 功能，实现了多种数据源的自动元数据映射和数据访问、并对外部数据读取和查询执行等方面做了诸多性能优化，完全具备了构建极速易用 Lakehouse 架构的能力。在 2.1 版本中，Apache Doris 湖仓一体架构得到全面加强，不仅增强了主流数据湖格式（Hudi、Iceberg、Paimon 等）的读取和写入能力，还引入了多 SQL 方言兼容、可从原有系统无缝切换至 Apache Doris。在数据科学及大规模数据读取场景上， Doris 集成了 Arrow Flight 高速读取接口，使得数据传输效率实现 100 倍的提升。 Apache Doris + Apache Hudi Apache Hudi 是目前最主流的开放数据湖格式之一，也是事务性的数据湖管理平台，支持包括 Apache Doris 在内的多种主流查询引擎。Apache Doris 同样对 Apache Hudi 数据表的读取能力进行了增强：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d39e8ea10d318fb71152ec7f682b2ba/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/167/">«</a>
	<span class="pagination__item pagination__item--current">168/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/169/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>