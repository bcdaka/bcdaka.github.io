<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b85cca1193dbfd0bd8a934e4c59bdb5/" rel="bookmark">
			数据结构-单链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 链表的概念及结构 概念：链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的 。
从以上图片可以看出：
1.链式结构在逻辑上是连续的，但在物理上不一定是连续的。
2.现实中的节点一般是在堆上申请出来的。
3.从堆上申请的空间，是按照一定的策略来分配的，两次申请的空间可能连续，可能不连续。
2 链表的分类 实际中链表的结构非常多样，以下情况组合起来就有8种链表结构：
2.1单向或双向 2.2带头或者不带头 2.3循环或者非循环 虽然有这么多的链表的结构，但是我们实际中最常用还是两种结构：
1. 无头单向非循环链表：结构简单，一般不会单独用来存数据。实际中更多是作为其他数据结构的子结构，如哈希桶、图的邻接表等等。另外这种结构在笔试面试中出现很多。
2. 带头双向循环链表：结构最复杂，一般用在单独存储数据。实际中使用的链表数据结构，都是带头双向循环链表。另外这个结构虽然结构复杂，但是使用代码实现以后会发现结构会带来很多优势，实现反而简单了，后面我们代码实现了就知道了。
3 单向无头链表的实现 在头文件中包含一些函数的声明。
因为每个节点都是一个结构体，所以每个节点都要存放一个结构体的指针，指向下一个节点。
typedef int SLTDataType; typedef struct SListNode { SLTDataType data; struct SListNode* next; }SLTNode; SLTNode* BuyListBNode(SLTDataType x); void PrintSList(SLTNode* phead); void SLTPushBcak(SLTNode** pphead,SLTDataType x);//尾插 void SLTPushFront(SLTNode** pphead, SLTDataType x);//头插 void SLTPopback(SLTNode** pphead);//尾删 void SLTPopFront(SLTNode** pphead,SLTDataType x);//头删 void SLTFind(SLTNode* pphead,SLTDataType x);//查找 //在pos之前插入x void SLTInsert(SLTNode** pphead, SLTNode* pos, SLTDataType x); //在pos之后插入x void SLTInsertAfter(SLTNode** pphead, SLTNode* pos, SLTDataType x); //删除pos位置 void SLTErase(SLTNode** pphead, SLTNode* pos); //删除pos的后一个位置 void SLTEraseAfter(SLTNode* pos); 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b85cca1193dbfd0bd8a934e4c59bdb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c65439434e0d860c02929aef398ce1d0/" rel="bookmark">
			【LeetCode力扣】42.接雨水（困难）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、题目介绍
2、解题
2.1、解题思路
2.2、图解说明
2.3、解题代码
1、题目介绍 原题链接：42. 接雨水 - 力扣（LeetCode）
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 示例 2：
输入：height = [4,2,0,3,2,5] 输出：9 提示：
n == height.length1 &lt;= n &lt;= 2 * 1040 &lt;= height[i] &lt;= 105 2、解题 2.1、解题思路 一个用木板围成的桶能装多少水取决于最短的那块木板，同理，这道题我们可以把它看做成是由若干块木板组成的一个桶，只是它们是以并排的方式组成的，这里我用left和right两个指针分别指向最左和最右的两块木板，用变量 sum 来记录总的装水量以及两个变量 leftMax和rightMax来记录左边最高的木板值和右边最高的木板值，哪一边的 (left / right)Max 更小就用哪边的 (left / right)Max 减去 (left / right)所指的值，这样就能求出指针移动一次的装水量了。初始时 left = 0; right = n-1 (n就是数组的长度)，leftMax = 0；rightMax = 0 。指针 left 只会向右移动，指针 right 只会向左移动，在移动指针的过程中决定两个变量 leftMax 和 rightMax 的值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c65439434e0d860c02929aef398ce1d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a505104f94293c42811d4489377e3de/" rel="bookmark">
			【微信公众号推送小程序消息通知】--下发统一消息接口被回收后新方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序言 由于微信小程序长期订阅的消息模板和下发统一消息推送接口全部失效以后，对于小程序的消息推送可以往公众号推可以使用本文章方案。在网上看了挺多方案，有用用户列表做匹配的等，最终觉得通过关注事件触发的方案是最省事。
准备 1、微信公众平台注册服务号（订阅号是不可以推送的）与小程序，两者都需要认证并且认证主体是一致
2、微信开放平台注册账号（该账号也需要认证），绑定小程序与公众号
3、公众号根据想要的模板消息绑定服务类目，去模板消息中先挑选你的模板消息。（如果是刚注册的公众号还需要去新的功能页面添加模板消息功能，需要微信审核，不过很快）
4、微信公众号绑定小程序
5、小程序与公众号配置服务器的ip地址白名单
6、公众号配置服务器地址
整体实现流程 通过在开放平台绑定的公众号与小程序后，我们在调用微信code2Session接口的时候会返回unionid，这个unionid就是推送的关键。
用到微信接口：
1、关注事件推送：用关注事件推送接口文档地址
2、查询用户基础信息：用户基础信息接口文档地址
3、获取accessToken：获取accessToken接口文档地址
4、消息模板推送：消息模板推送接口文档地址
实现代码（Java） 这里使用第三方工具包Wx-Java（非常方便），直接实现推送代码。具体源码可以浏览https://gitee.com/binary/weixin-java-tools
先在配置文件yml配置公众号信息 # 公众号配置 wx: mp: appId: xiaochengxuappid secret: xiaochengxusecrect token: xiaochengxutoken aesKey: xiaochengxuaes # token存储在redis config-storage: type: RedisTemplate 封装推送工具类 /** * 微信公众号推送模板消息 * * @param openid 用户openid * @param templateData 模板参数 */ public void sendTemplateMsg(String openid, List&lt;WxMpTemplateData&gt; templateData) { WxMpTemplateMessage templateMessage = WxMpTemplateMessage.builder() .toUser(openid) // 模板id .templateId(templateId) // 跳转小程序appid，跳转路径 .miniProgram(new WxMpTemplateMessage.MiniProgram(weAppAppId, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a505104f94293c42811d4489377e3de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83b16532f14dacdfe68b1df7aaaac0c6/" rel="bookmark">
			2023年下半年架构案例真题及答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		案例的考点：
大数据架构 Lambda架构和Kappa架构
jwt特点
数据持久层，Redis数据丢失，数据库读写分离方案
Hibernat架构
SysML七个关系，填需求图
大数据的必选题：
某网作为某电视台在互联网上的大型门户入口，某一年成为某奥运会中国大陆地区的特权转播商，独家全程直播了某奥运会全部的赛事，积累了庞大稳定的用户群，这些用户在使用各类服务过程中产生了大量数据，对这些海量数据进行分析与挖掘，将会对节目的传播及商业模式变现起到重要的作用。该奥运期间需要对增量数据在当日概览和赛事回顾两个层面上进行分析。
其中，当日概览模块需要秒级刷新直播在线人数、网站的综合浏览量、页面停留时间、视频的播放次数和平均播放时间等千万级数据量的实时信息，而传统的分布式架构采用重新计算的方式分析实时数据在不扩充以往集群规模的情况下，无法在几秒内分析出重要的信息。
赛事回顾模块需要展现自定义时间段内的历史最高在线人数、逐日播放走势、直播最高在线人数和点播视频排行等海量数据的统计信息，由于该奥运期间产生的数据通常不需要被经常索引、更新，因此要求采用不可变方式存储所有的历史数据，以保证历史数据的准确性。
[问题1] (8分)
请根据Lambda架构和Kappa架构特点，填写以下表格。
[问题2] (9分)
下图1给出了某网奥运的大数据架构图，请根据下面的 (a)~ (n) 的相关技术，判断这些技术属于架构图的哪个部分，补充完善下图1的 (1) - (9) 的空白处。
(a) Nginx;(b) Hbase;(c) Spark Streaming(d) Spark;(e) MapReduce;(f) ETL;(g) MemSQL; (h) HDFS; (i)Sqoop; (j) Flume ; (k)数据存储层; (I) kafka;（m）业务逻辑层；(n）数据采集层
[问题3] (8分，每空2分)
大数据的架构包括了Lambda架构和Kappa架构，Lambda架构分解为三层: 即(1)、 (2)和(3); Kappa架构不同于Lambda同时计算流计算和批计算并合并视图，Kappa只会通过流计算一条的数据链路计算并产生视图。
请问该系统的大数据架构是基于哪种架构搭建的大数据平台处理奥运会大规模视频网络观看数据。
JWT全称（JSON Web Token），教材没有的超纲内容。
Hibernate一个java现在都不怎么用的ORM，属实是没有想到！不过都是教材上的内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a493dd84bb0b96967c7cdefe180eb242/" rel="bookmark">
			前后端交互常见的几种数据传输格式 form表单&#43;get请求 form表单&#43;post请求 json键值对格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. get请求 query string
2.form表单+get请求
3..form表单+post请求
4..json格式
5.总结
1. get请求 query string 前端通过get请求携带 query string（键值对） ,后端通过req.getParameter(key)方法获取数据。如果key不存在，获取到的就是null。querystring 会被 Tomcat 处理成形如Map这样的结构，就可以通过key获取value了。这种是直接在地址栏里输入querystring: ?username=lisi&amp;password=123。
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String username = req.getParameter("username"); String password = req.getParameter("password"); resp.setContentType("text/html;charset=utf8"); resp.getWriter().write("username="+username+" password="+password); } 2.form表单+get请求 和上面差不多，一个是以get方式在地址栏手写querystring，这个是通过form表单构造get请求，同样也是在传querystring。可以看到get请求会将数据显示在地址栏上。
后端
@WebServlet("/test") public class test extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String username = req.getParameter("username"); String password = req.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a493dd84bb0b96967c7cdefe180eb242/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de350d1a14854604876a7786c2b9270d/" rel="bookmark">
			集合覆盖问题的模型与算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		集合覆盖问题的模型与算法 问题与模型近似算法LINGO解法案例近似算法求解 相关问题 集合覆盖问题是组合最优化和理论计算机科学中的一类典型问题，它要求以最小代价将某一集合利用其若干子集加以覆盖。在现实生产生活中，集合覆盖问题有着众多应用场合，如物流配送、道路定向、工程调度、设施选址、VLSI 设计、网络安全等。遗憾的是，集合覆盖问题在算法复杂性上属于 NP-困难问题，即它不存在多项式时间精确算法，除非P=NP。因此，近似算法成为求解集合覆盖问题的一个有效途径，其中以 Chvátal 的贪心算法最为简洁。
问题与模型 基集S={e1, e2, …, en}，S1,S2,…,Sm是S的一族子集，若J ⊆ \subseteq ⊆{1, 2, …, m}，且 ⋃ \bigcup ⋃Sj = S，则称{Sj}为S的一个集合覆盖。
问题：：求 S 的一个基数最小的集合覆盖，其中基数定义为集合中元素的数目。
近似算法 借鉴贪心算法来解决集合覆盖问题。贪心算法的思路为：每次选择最大长度的集合Sj来覆盖S中元素，直至S中所有元素都被覆盖。
LINGO解法 模型IP是一个0-1规划，可以利用LINGO来解决。
案例 如图所示，四个平面上的圆形区域是同种型号的传感器 S1-S4 的信号覆盖范围，e1~e9 是九个服务客户，问：设置传感器的最佳方案是什么?
将9个客户视为元素，各传感器的覆盖范围内的元素分别构成集合：
S1={e1,e2,e3,e4,e5}
S2={e3,e4,e5,e6,e7,e8}
S3={e2,e4,e5,e7,e8,e9}
S4={e1,e2,e3,e4,e8,e9}
则传感器的最佳设置方案应为集合S={e1-e9}的一个基数最小的集合覆盖。
近似算法求解 则最佳方案为设置传感器S2和S4。
相关问题 顶点覆盖问题是一个经典的图最优化问题，在算法复杂性上也属于 NP-困难问题。
设 G = (V, E) 是一个无向图，其中 V, E 分别为顶点集和边集，若存在 C ⊆ \subseteq ⊆V ，使 ∀ \forall ∀ij ∈ \in ∈E ，都有 i ∈ \in ∈C 或 j ∈ \in ∈C（即每一条边都至少有一个顶点含于 C 中），则称 C 为 G 的一个顶点覆盖。问题：求 G 的一个基数最小的顶点覆盖。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de350d1a14854604876a7786c2b9270d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/252fcba80506377bca5479bda6ba2d4a/" rel="bookmark">
			AI时代项目经理与架构师的成长之道：ChatGPT让你插上翅膀
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💂 个人网站:【工具大全】【游戏大全】【神级源码资源网】🤟 前端学习课程：👉【28个案例趣学前端】【400个JS面试题】💅 寻找学习交流、摸鱼划水的小伙伴，请点击【摸鱼学习交流群】 在AI时代，项目经理和架构师的角色变得越发关键，他们需要不断学习和适应新技术，以保持竞争力。本文将探讨AI时代下项目经理和架构师的成长之道，并为您提供一些实际的代码示例来帮助您更好地理解和应用AI技术。在本文的第一部分，我们将关注项目经理的成长之道，而在第二部分，我们将聚焦架构师的成长之道。
第一部分：AI时代项目经理的成长之道 1.1 深入理解AI 在AI时代，项目经理需要深入了解AI技术，以便更好地管理和领导团队。这包括了解常见的AI算法、工具和框架。下面是一个简单的Python示例，演示了如何使用Scikit-Learn库来创建一个简单的线性回归模型：
import numpy as np from sklearn.linear_model import LinearRegression # 创建一些示例数据 X = np.array([1, 2, 3, 4, 5]).reshape(-1, 1) y = np.array([2, 4, 5, 4, 5]) # 创建线性回归模型 model = LinearRegression() model.fit(X, y) # 预测新数据点 new_data = np.array([6]).reshape(-1, 1) predicted_value = model.predict(new_data) print(f"预测值: {predicted_value[0]}") 1.2 数据管理和分析 项目经理在AI项目中需要管理大量的数据，因此他们需要了解数据管理和分析的基础知识。使用Python和Pandas库，您可以轻松地对数据进行处理和分析，如下所示：
import pandas as pd # 创建一个示例数据框 data = pd.DataFrame({'姓名': ['张三', '李四', '王五'], '年龄': [25, 30, 28]}) # 打印数据框 print(data) # 计算年龄的平均值 average_age = data['年龄'].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/252fcba80506377bca5479bda6ba2d4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c53dc346f5ed23e162bf1c18c69e804e/" rel="bookmark">
			【JavaSE】基础笔记 - 类和对象（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、this引用
1.1、为什么要有this引用
1.2、什么是this引用
1.3、 this引用的特性
2、 对象的构造及初始化
2.1、 如何初始化对象
2.2、构造方法
2.2.1、概念 2.2.2、特性
2.3、默认初始化
2.4、就地初始化
上篇：【JavaSE】基础笔记 - 类和对象（上）-CSDN博客https://blog.csdn.net/zzzzzhxxx/article/details/134232584?spm=1001.2014.3001.5501
接上篇继续对类和对象的知识展开讲述。
1、this引用 1.1、为什么要有this引用 先看一个日期类的例子： public class Date { public int year; public int month; public int day; public void setDay(int y, int m, int d){ year = y; month = m; day = d; } public void printDate(){ System.out.println(year + "/" + month + "/" + day); } public static void main(String[] args) { // 构造三个日期类型的对象 d1 d2 d3 Date d1 = new Date(); Date d2 = new Date(); Date d3 = new Date(); // 对d1，d2，d3的日期设置 d1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c53dc346f5ed23e162bf1c18c69e804e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b69e7f7b52289aa4d957214a02e0925d/" rel="bookmark">
			21 个最佳 Javascript IDE 和代码编辑器 [CSS、HTML、JavaScript]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是我们挑选的 21 个最佳 JavaScript IDE 和源代码编辑器。
目录
什么是 IDE选择正确的开发环境时要寻找什么？免费的最佳 Javascript IDE最佳高级 Javascript IDE结论：最佳 JavaScript IDE是哪个？常见问题解答：最佳 Javascript IDE 如今，Javascript 在前端开发中越来越流行。您可以在常规的“记事本”中编写 JavaScript 代码——使用 .js 扩展名保存结果，它不仅可以连接到站点，甚至可以工作。但是，使用这种有限的编辑器会大大减慢开发速度。因此，最好采取一些专门的东西。我们的 最佳 Javascript IDE 列表应该可以帮助您做出决定。
许多编辑器满足所有必要的要求并且适合使用 JavaScript。编写代码是每个人的事，但许多人在选择正确的程序方面存在问题。这就是为什么我收集了 21 个最好的 Javascript IDE 及其优缺点。
让我们立即预订，这不是顶级列表，而是简单列表。 第一个并不意味着最好；最后不代表最坏。因此，您可以根据自己的需要和偏好选择任何工具。
但首先，让我为您澄清一下 IDE 是什么，以及与简单的代码编辑器有什么区别。
什么是 IDE IDE (Integrated Development Environment)(集成开发环境)一词是指扩展了许多“花里胡哨”的编辑器，并且知道如何使用诸如错误跟踪器、版本控制等辅助系统。
通常，IDE 会加载整个项目以提供 整个项目功能的自动完成、方便的文件导航等。
如果您还没有考虑过选择 IDE，请查看以下选项。
请根据您的喜好和您需要与 JavaScript 结合使用的其他技术做出选择。
大多数 IDE 都是付费的，可以免费下载和使用一段时间。但是与 Web 开发人员的薪水相比，他们的成本并不高，因此您可以专注于方便。
IDE 和编辑器有什么区别？ IDE 是一种软件应用程序，可为开发人员提供所有开发过程功能。它包含：
源代码编辑器，调试器，编译器，interpreter口译员，构建自动化。 许多 IDE 还为您提供类或对象浏览器、 从项目结构生成类图(在面向对象编程中)和 运行测试用例(如 Visual Studio)的能力。拥有所有这些特性，这就是它被称为集成开发环境的原因。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b69e7f7b52289aa4d957214a02e0925d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f8ea6341613e1750d81647de7b6f4c4/" rel="bookmark">
			相关性分析——Pearson相关系数&#43;热力图(附data和Python完整代码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关性分析：指对两个或多个具有相关性的变量元素进行分析
1.散点图和相关性热力图 2.相关系数 相关系数最早是由统计学家卡尔 皮尔逊设计的统计指标，是研究变量之间线性相关承兑的值，一般用字母 r 表示。
2.1Pearson相关系数 Pearson相关系数是衡量两个数据集合是否在一条线上面，用于衡量变量间的线性关系。
这里是引用如果有两个变量：X、Y，最终计算出的相关系数的含义可以有如下理解：
(1)、当相关系数为0时，X和Y两变量无关系。
(2)、当X的值增大（减小），Y值增大（减小），两个变量为正相关，相关系数在0.00与1.00之间。
(3)、当X的值增大（减小），Y值减小（增大），两个变量为负相关，相关系数在-1.00与0.00之间。
相关系数的绝对值越大，相关性越强，相关系数越接近于1或-1，相关度越强，相关系数越接近于0，相关度越弱。
通常情况下通过以下取值范围判断变量的相关强度： 相关系数 0.8-1.0 极强相关
0.6-0.8 强相关
0.4-0.6 中等程度相关
0.2-0.4 弱相关
0.0-0.2 极弱相关或无相关
2.2 Spearman相关系数 Spearman相关系数适用于不符合正态分布或者总体分布类型未知的数据，Spearman用于描述两个变量之间关联的程度与方向。
待补充
2.3Kendall等级相关系数 Kendall等级相关系数是用于反应分类相关变量的相关指标，适用于两个变量均为有序分类的情况，对相关的有序变量进行非参数性相关检验。
待补充
3.Python代码讲解 3.1 数据集 日期,蜜汁焗餐包,铁板酸菜豆腐,香煎韭菜饺,香煎罗卜糕,原汁原味菜心 2015/1/1,13,18,10,10,27 2015/1/2,9,19,13,14,13 2015/1/3,8,7,11,10,9 2015/1/4,10,9,13,14,13 2015/1/5,12,17,11,13,14 2015/1/6,8,12,11,5,9 2015/1/7,5,10,8,10,7 2015/1/8,7,6,12,11,5 2015/1/12,0,5,5,7,10 2015/1/13,8,6,9,8,9 2015/1/14,4,8,5,3,10 2015/1/15,8,15,9,13,9 2015/1/16,11,14,9,9,15 2015/1/17,14,16,9,4,14 2015/1/18,9,8,12,9,15 2015/1/19,9,10,6,11,11 2015/1/20,11,8,14,6,13 2015/1/21,7,1,5,12,8 2015/1/22,13,13,5,11,11 2015/1/23,5,8,7,8,11 2015/1/24,7,9,7,10,9 2015/1/25,7,14,7,6,8 2015/1/26,6,9,12,7,5 2015/1/27,12,6,12,9,4 2015/1/28,8,7,12,10,6 2015/1/29,7,8,10,10,11 2015/1/30,7,9,16,10,11 2015/1/31,8,8,10,10,9 2015/2/1,6,6,11,6,9 3.2代码讲解 3.2.1 读取excel文档，Pearson相关系数+热力图 import pandas as pd import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f8ea6341613e1750d81647de7b6f4c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b3dc7a34e83d9610c9bcde46457685a/" rel="bookmark">
			一文深入搞懂ARM处理器架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、嵌入式处理器基础 典型的微处理器由控制单元、程序计数器（PC）、指令寄存器（IR）、数据通道、存储器等组成 。
指令执行过程一般分为：
取指：
从存储器中获得下一条执行的指令读入指令寄存器；
PC: 程序计数器, 总是指向下一条将要执行的指令；
IR: 指令寄存器，用于保持已取得指令；如图：
译码：
解释指令，决定指令的执行意义；如图：
执行：
从存储器向数据通道寄存器移动数据；
通过算术逻辑单元ALU进行数据操作；如图：
存储：
从寄存器向存储器写数据。如图：
在一些微处理器上，如ARM系列处理器、DSP等，指令实现流水线作业，指令过程按流水线的数目来进行划分。如5级流水线的处理器将指令分5个阶段执行。
（1）按存储结构分：冯·诺依曼体系结构和哈佛体系结构
冯·诺伊曼结构也称普林斯顿结构，是一种将程序指令存储器和数据存储器合并在一起的存储器结构。
处理器，经由同一个总线传输来访问程序和数据存储器，程序指令和数据的宽度相同。如X86系列、ARM7等，如图：
哈佛结构是一种将程序指令存储和数据存储分开的存储器结构，目的是为了减轻程序运行时的访存瓶颈。哈佛结构的微处理器通常具有较高的执行效率。
Microchip公司的PIC系列芯片，摩托罗拉公司的MC68系列、Zilog公司的Z8系列、ATMEL公司的AVR系列和ARM公司的ARM9、ARM10和ARM11
等。如图：
按指令类型可分为：复杂指令集（CISC）处理器和精简指令集（RISC）处理器 。
CISC：复杂指令集（Complex Instru
ction Set Computer）；
具有大量的指令和寻址方式，那么就需要更多的解释器。
8/2原则：80%的程序只使用20%的指令；
大多数程序只使用少量的指令就能够运行。
CISC具有如下显著特点：
(1) 指令格式不固定，指令长度不一致，操作数可多可少；
(2) 寻址方式复杂多样，以利于程序的编写；
(3) 采用微程序结构，执行每条指令均需完成一个微指令序列；
(4) 每条指令需要若干个机器周期才能完成，指令越复杂，花费的机器周期越多。
RISC：精简指令集（Reduced Instruction Set Computer)：指令数目少，在通道中只包含最有用的指令；执行时间短，确保数据通道快速执行每一条指令；使CPU硬件结构设计变得更为简单；每条指令都采用标准字长。
资料直通车：Linux内核源码技术学习路线+视频教程内核源码
学习直通车：Linuxc/c++高级开发【直播公开课】
零声白金VIP体验卡：零声白金VIP体验卡（含基础架构/高性能存储/golang/QT/音视频/Linux内核）
2、ARM处理器体系架构 ARM即Advanced RISC Machines的缩写。
1985年4月26日，第一个ARM原型在英国剑桥的Acorn计算机有限公司诞生。
20世纪80年代后期，ARM很快开发成Acorn的台式机产品，形成英国的计算机教育基础。
1990年成立了Advanced RISC Machines Limited。
20世纪90年代，ARM32位嵌人式RISC（Reduced Instruction Set Computer）处理器扩展到世界范围，占据了低功耗、低成本和高性能的嵌入式系统应用领域的领先地位。
目前己经占有75%以上的32位嵌入式产品市场。
32位RISC处理器受到青睐，领先的是ARM嵌入式微处理器系列。
ARM公司虽然只成立20多年，但在1999年因移动电话火爆市场，其32位RISC处理器占市场份额超过了50%，2001年初，ARM公司的32位RISC处理器市场占有率超过了75%。ARM公司是知识产权供应商，是设计公司。由合作伙伴公司来生产各具特色的芯片。
ARM处理器特点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b3dc7a34e83d9610c9bcde46457685a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64f73145e5bd79c51dd61ae94ca56e34/" rel="bookmark">
			go引入自建包名报错 package XXX is not in std
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在写一个测试引入包名的测试案列中出现了下面的错误
D:\goworkspace\src\go_code\project_01\main&gt;go run main.go main.go:5:2: package go_code/project_01/calutils is not in std (G:\go_env\src\go_code\project_01\calutils) main.go:6:2: package go_code/project_01/dbutils is not in std (G:\go_env\src\go_code\project_01\dbutils) 这个错误消息表明Go代码尝试导入一个位于项目目录之外的包，并且Go无法找到这个包。首先看了我的包名对应的路径是没有问题的。 排除了路径错误原因，接下来检查配置环境变量
环境变量GOPATH的值即项目路径下的根目录，下面对应的是我的项目路径
当我配置好了以后再次运行还是报上面的错误。这时候就要查看go的环境变量了，输入下面命令进行查看
D:\goworkspace\src\go_code\project_01\main&gt;go env set GO111MODULE= set GOARCH=amd64 set GOBIN= set GOCACHE=C:\Users\wxq\AppData\Local\go-build set GOENV=C:\Users\wxq\AppData\Roaming\go\env set GOEXE=.exe set GOEXPERIMENT= set GOFLAGS= set GOHOSTARCH=amd64 set GOHOSTOS=windows set GOINSECURE= set GOMODCACHE=D:\goworkspace\pkg\mod set GONOPROXY= set GONOSUMDB= set GOOS=windows set GOPATH=D:\goworkspace set GOPRIVATE= set GOPROXY=https://proxy.golang.org,direct set GOROOT=G:\go_env set GOSUMDB=sum.golang.org set GOTMPDIR= set GOTOOLCHAIN=auto set GOTOOLDIR=G:\go_env\pkg\tool\windows_amd64 set GOVCS= set GOVERSION=go1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64f73145e5bd79c51dd61ae94ca56e34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/166717b7a00296e16d4bbf7f49832e45/" rel="bookmark">
			AI短视频制作一本通：文本生成视频、图片生成视频、视频生成视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💂 个人网站:【工具大全】【游戏大全】【神级源码资源网】🤟 前端学习课程：👉【28个案例趣学前端】【400个JS面试题】💅 寻找学习交流、摸鱼划水的小伙伴，请点击【摸鱼学习交流群】 第一部分：文本生成视频 1. 文本生成视频概述 随着人工智能（AI）技术的飞速发展，视频制作领域也迎来了创新的浪潮。文本生成视频是其中的一项令人激动的进展，它利用自然语言处理技术将文本内容转化为视频。这项技术在广告、教育、娱乐等领域有着广泛的应用，可以快速生成吸引人的视频内容。
2. 工作流程 文本生成视频的工作流程通常包括以下步骤：
步骤1：文本处理 首先，您需要准备要转化为视频的文本内容。这可以是广告宣传词、教育课程内容或任何您感兴趣的文本。然后，您可以使用自然语言处理（NLP）技术来处理文本，包括分词、情感分析和关键词提取。
步骤2：图像生成 文本生成视频通常伴随着图像的生成，这些图像可以是背景图片、文本框、图标等。您可以使用图像处理工具或库来生成这些图像，根据文本内容选择合适的图像元素。
步骤3：音频合成 为了增强视频的吸引力，您可以合成配音或背景音乐。音频合成可以使用文本转语音（TTS）技术来实现，将文本转化为声音。
步骤4：视频合成 最后，将生成的图像和音频合成为视频。您可以使用视频编辑工具或库来将图像序列和音频合并在一起。设置帧速率和视频分辨率以获得所需的输出效果。
3. 代码示例 以下是一个使用Python的示例代码，演示了如何使用一些常见的库和工具来创建文本生成视频：
# 导入必要的库 from moviepy.editor import * import gTTS # 步骤1：文本处理 text = "欢迎观看我们的新产品介绍视频。" # 进行情感分析、关键词提取等文本处理 # 步骤2：图像生成 background_image = ImageClip("background.jpg") text_clip = TextClip(text, fontsize=24, color='white') # 步骤3：音频合成 tts = gTTS(text, lang='zh') tts.save("audio.mp3") audio_clip = AudioFileClip("audio.mp3") # 步骤4：视频合成 video = CompositeVideoClip([background_image.set_duration(10), text_clip.set_duration(10).set_position('center'), audio_clip.set_duration(10)]) video.write_videofile("output_video.mp4", codec='libx264') 此示例中，我们使用MoviePy库来合成视频，使用gTTS库生成文本的语音，从而创建一个包含文本、图像和音频的视频。
请注意，这只是一个基本示例，您可以根据自己的需求和创意来扩展和改进代码。文本生成视频的应用非常广泛，可以根据不同场景和目的进行定制。
第二部分：图片生成视频 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/166717b7a00296e16d4bbf7f49832e45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ededc78df07ee85c5ab8a7d546d2eaa/" rel="bookmark">
			数据结构——循环队列详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、循环队列的定义
二、 循环队列的基本操作
三、循环队列的实现 1、循环队列的定义
2、循环队列的初始化 3、循环队列出队 4、循环队列入队 5、队列判空
6、 队列判满
7、取队头元素
8、输出队列 9、求队列长度 四、完整代码 五、小结 六、参考文献
一、循环队列的定义 定义：队列主要有顺序队列，循环队列，双端队列，优先队列。而当中循环队列是一种线性数据结构。它也被称为“环形缓冲器”。它只允许在一端进行插入操作，即队尾（rear），而在另一端进行删除操作，即队头 (front)，其操作表现基于FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。向队列中插入新的数据元素称为入队，新入队的元素就成为了队列的队尾元素。
特点：
循环队列允许元素在队尾插入，在队头删除，同时遵循先进先出原则。由于循环队列是基于数组实现的，所以它的访问速度很快，特别是在移动元素时。如果需要大量添加和删除元素，循环队列比链表更有效率，因为它不需要频繁地移动指针来访问元素。不支持随机访问元素，因此不能像数组那样直接访问特定位置的元素。 二、 循环队列的基本操作 1、初始化：这是创建一个空的顺序队列，需要设定队首指针front和队尾指针rear都指向同一个位置，一般初始都设置为0，即队列为空。
2、元素入队：也被称为插入操作，是将一个新元素添加到队列尾部的操作。
3、元素出队：也被称为删除操作，是将队列头部的元素移除的操作。
4、求队列长度：可以通过计算队尾指针和队首指针之差的值再加1来获取当前队列的长度。
5、判断是否为空：通过检查队首指针front和队尾指针rear是否相等来判断队列是否为空。
6、判断是否为满：当队尾指针指向数组的最后一个位置时，下一个要插入的位置就是队头指针。
7、取队头：头元素就是队列中的第一个元素，可以通过返回队首指针front的值来获取。
8、输出队列：将队列中元素通过while语句循环语句打印出来
三、循环队列的实现 1、循环队列的定义
用一个数组来存储队列中的元素，用front作为队头指针，指向队列的第一个元素，用rear作为队尾指针，即指向队列最后一个元素的下一个位置.
#define MAXSIZE 4 typedef int DataType; typedef struct { DataType data[MAXSIZE]; int front; int rear; }CirclesQueue; 2、循环队列的初始化 循环队列的初始化只需要将队头指针（front）和队尾指针（rear）都初始化为0.
/*循环队列初始化*/ int init(CirclesQueue *Q) { Q-&gt;front = Q-&gt;rear = 0; return 0; } 3、循环队列出队 出队前判断队列是否为空，如果为空，返回100002错误信息，如果队列不为空，将队列的队头指针向前移动一位，即将队头指针加1并对MAXSIZE取模，确保指针在数组范围内循环移动，当到达数组末尾时，会回到数组的开头。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ededc78df07ee85c5ab8a7d546d2eaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06ac066ae64b4a957fee19329e2ca5a5/" rel="bookmark">
			浏览器自动播放音视频-前端实现方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
浏览器自动播放策略
策略详情：
实现方案 方案1： 互动后播放
方案2： 互动后出声
总结
前言 在开发中可能有遇到这样的需求，当用户打开页面后，需要自动播放视频或音频，按理说那就打开页面时play()一下不就搞定了吗，但实际情况很明显不是，不然也没得这篇文章喽，要实现这个需求，我们得先了解一下浏览器自动播放策略。再给出相应解决方案。
浏览器自动播放策略 Chrome浏览器的自动播放策略自Chrome66起生效,动机是改善用户体验
策略详情： Chrome 的自动播放政策很简单：
始终允许静音自动播放。在以下情况下，带声音的自动播放会被允许： 用户已经与当前域进行了交互（click、tap）在桌面设备上，用户的==媒体参与度==指数阈值已超过，这意味着用户之前播放过有声视频。用户已将网站添加到移动设备上的主屏幕或在桌面上安装了 PWA。顶部帧可以将自动播放权限委派给其 iframe，以允许自动播放声音。 ==媒体参与度（MEI, Media Engagement Index）==
媒体参与度 （MEI） 是衡量个人在网站上使用多媒体的倾向。
它是一个数字，可通过 chrome://media-engagement/ 查看。
数值越高，用户对该站点的媒体参与度越高，就越有机会自动播放。
但对于开发者而言：
媒体参与度的计算规则无法通过技术手段更改
媒体参与度的计算规则不同版本的浏览器可能会有变动
实现方案 首先呢，我们直接在用户进入页面的时候play()，可以发现视频并没有播放，并且报错Uncaught (in promise) DOMException: play() failed because the user didn't interact with the document first
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06ac066ae64b4a957fee19329e2ca5a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be550537e61adab25b52933083767bc6/" rel="bookmark">
			三维变换矩阵实战——三维点云的旋转、缩放、镜像、错切、平移、正交投影
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、旋转矩阵（右手坐标系） 绕x轴旋转 旋转矩阵：右边矩阵是点云的原始坐标，左边的是旋转矩阵
可视化：绕x轴旋转90度
代码：
import vtk import numpy as np import math def pointPolydataCreate(pointCloud): points = vtk.vtkPoints() cells = vtk.vtkCellArray() i = 0 for point in pointCloud: points.InsertPoint(i, point[0], point[1], point[2]) cells.InsertNextCell(1) cells.InsertCellPoint(i) i += 1 PolyData = vtk.vtkPolyData() PolyData.SetPoints(points) PolyData.SetVerts(cells) mapper = vtk.vtkPolyDataMapper() mapper.SetInputData(PolyData) actor = vtk.vtkActor() actor.SetMapper(mapper) actor.GetProperty().SetColor(0.0, 0.1, 1.0) return actor def visiualize(pointCloud, pointCloud2): colors = vtk.vtkNamedColors() actor1 = pointPolydataCreate(pointCloud) actor2 = pointPolydataCreate(pointCloud2) Axes = vtk.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be550537e61adab25b52933083767bc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc47e6c6f464b1593d469cdea3a1b9a7/" rel="bookmark">
			Python Slice函数：数据处理利器详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言： 在Python编程中，处理数据是一个非常常见且重要的任务。为了更高效地处理数据，Python提供了许多内置函数和方法。其中，slice()函数是一个非常强大且常用的工具，它可以帮助我们轻松地提取、操作和处理数据。无论是字符串、列表还是元组，slice()函数都能够胜任。本文将详细介绍slice()函数的使用方法，帮助你更好地理解和应用它。
一、slice()函数的基本概念 slice()函数是Python内置的一个函数，用于生成一个切片对象。切片对象可以用来切片序列类型的数据，如字符串、列表和元组。它的基本语法如下：
slice(start, stop, step) 其中，start表示切片的起始位置，stop表示切片的结束位置，step表示切片的步长。这三个参数都是可选的，如果不提供，则默认为None。下面我们将详细介绍每个参数的含义和使用方法。
二、slice()函数的参数详解 1. 起始位置（start） 切片函数的起始位置参数start表示切片的起始位置。它可以是一个整数，也可以是None。如果start为整数，则表示从序列的start位置开始切片；如果start为None，则表示从序列的第一个位置开始切片。例如，我们有一个字符串s = "Hello, World!"，我们可以使用切片函数来提取其中的一部分内容：
s = "Hello, World!" print(s[slice(0, 5)]) # 输出 "Hello" print(s[slice(None, 5)]) # 输出 "Hello" 在上面的例子中，我们分别使用切片函数s[slice(0, 5)]和s[slice(None, 5)]来提取字符串s中索引为0到4的字符，即"Hello"。
2. 结束位置（stop） 切片函数的结束位置参数stop表示切片的结束位置。它可以是一个整数，也可以是None。如果stop为整数，则表示切片到序列的stop位置（不包括stop位置）；如果stop为None，则表示切片到序列的最后一个位置（包括最后一个位置）。例如，我们有一个列表nums = [1, 2, 3, 4, 5]，我们可以使用切片函数来提取其中的一部分内容：​​​​​​​
nums = [1, 2, 3, 4, 5] print(nums[slice(1, 4)]) # 输出 [2, 3, 4] print(nums[slice(1, None)]) # 输出 [2, 3, 4, 5] 在上面的例子中，我们分别使用切片函数nums[slice(1, 4)]和nums[slice(1, None)]来提取列表nums中索引为1到3的元素，即[2, 3, 4]。
3. 步长（step） 切片函数的步长参数step用于控制提取元素的间隔。它可以是一个整数，也可以是None。如果step为整数，则表示每隔step个元素提取一次；如果step为None，则表示提取所有元素。例如，我们有一个字符串s = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc47e6c6f464b1593d469cdea3a1b9a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0363397239065bcb92744e05d098e52/" rel="bookmark">
			Java 数据结构篇-实现单链表核心API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥博客主页： 小扳_-CSDN博客
❤感谢大家点赞👍收藏⭐评论✍ 文章目录
1.0 单链表的说明
2.0 单链表的创建
2.1 单链表 - 头插节点
2.2 单链表 - 遍历
2.2.1 使用简单的 for/while 循环
2.2.2 实现 forEach 方法
2.2.3 实现迭代器的方法
2.3 单链表 - 尾插节点
2.4 单链表 - 通过索引获取数据
2.5 单链表 - 通过索引插入数据
2.6 单链表 - 头删节点
2.7 单链表 - 根据节点来删除数据
3.0 实现单链表的完整代码
4.0 实现加 "哨兵" 的单链表 1.0 单链表的说明 单链表是一种数据结构。数据结构是指数据的组织、管理和存储的方式，而单链表是一种常见的线性数据结构，用于存储一系列具有相同类型的元素。它由一系列节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针。单链表可以通过指针的方式实现元素的插入、删除和查找等操作。
2.0 单链表的创建 把单链表封装成一个类，面向对象编程的思路。类中需要的成员变量为头节点、节点，又可以把节点封装成一个类，为更好把节点类封装起来，将其设置为静态内部类。
代码如下：
public class SingleLists{ //头节点 private Node hand = null; //节点 private static class Node { //数据 private int data; //指向下一个节点 private Node next; public Node() { } } 注意的是，这些成员都不会对外访问的，所以需要把成员变为私有成员。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0363397239065bcb92744e05d098e52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e41f4a7207140e48d8b3bb31e9ec39c6/" rel="bookmark">
			FastAPI 库（Python 的 Web 框架）基本使用指南（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FastAPI 概述 参考文档：
中文文档轻松上手Python的Web神器：FastAPI教程 介绍 FastAPI 是一个基于 Python 的现代 Web 框架，它具有快速构建高性能 API 的特点。
FastAPI 关键特性:
快速：可与 NodeJS 和 Go 并肩的极高性能（归功于 Starlette 和 Pydantic）。最快的 Python web 框架之一。高效编码：提高功能开发速度约 200％ 至 300％。更少 bug：减少约 40％ 的人为（开发者）导致错误。智能：极佳的编辑器支持。处处皆可自动补全，减少调试时间。简单：设计的易于使用和学习，阅读文档的时间更短。简短：使代码重复最小化。通过不同的参数声明实现丰富功能。bug 更少。健壮：生产可用级别的代码。还有自动生成的交互式文档。标准化：基于（并完全兼容）API 的相关开放标准：OpenAPI (以前被称为 Swagger) 和 JSON Schema。 常见 Python Web 框架的介绍与区别 性能：
Django：是一个全功能的框架，它提供了许多内置的功能和扩展。虽然它在性能方面相对较低，但它非常适合构建大型应用程序。
Flask：是一个轻量级的框架，它更加注重简洁和灵活性。相比于 Django，Flask 具有更好的性能表现，但它的功能相对较少。
FastAPI：是一个高性能的框架，它基于异步请求处理和类型注解。FastAPI 比 Django 和 Flask 在性能上更为出色，并且它使用 Python 的 asyncio 库来实现高效的并发请求处理。
开发难度：
Django：是一个全功能的框架，它提供了许多现成的功能和组件，使得开发更加快速和简单。但是，对于初学者来说，Django的学习曲线可能相对较陡。Flask：是一个简洁而灵活的框架，它更多地侧重于自定义和配置。相对于 Django，Flask 的学习曲线较为平缓，适合小型和简单的项目。FastAPI：使用了类型注解和自动生成文档的功能，使代码更易读和维护。它提供了基于标准的API模式和强大的验证工具，减少了开发过程中的错误。 推广程度：
Django：是最受欢迎和广泛使用的 Python Web 框架之一。它拥有庞大的社区支持和丰富的文档资源，可以轻松找到相关的教程、插件和解决方案。
Flask：是一个比较受欢迎的框架，拥有庞大的社区和丰富的扩展库。虽然它的用户群体相对较小，但在小型项目和快速原型开发中非常流行。
FastAPI：是一个相对较新的框架，但它正在迅速获得开发者的关注。它的高性能和现代特性吸引了许多开发者，并且社区正在逐渐扩大。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e41f4a7207140e48d8b3bb31e9ec39c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29cb2ecafa4009835748b6db4dc29631/" rel="bookmark">
			AI大模型在短视频处理和剪辑中的应用，文末送书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🏆作者简介，黑夜开发者，CSDN领军人物，全栈领域优质创作者✌，CSDN博客专家，阿里云社区专家博主，2023年6月CSDN上海赛道top4。
🏆数年电商行业从业经验，历任核心研发工程师，项目技术负责人。
🎉欢迎 👍点赞✍评论⭐收藏
文章目录 🚀一、背景🚀二、视频处理方向🔎2.1 视频分析与标注🔎2.2 视频剪辑与特效🔎2.3 视频内容生成与故事叙述🔎2.4 视频后期处理与发布 🚀三、AI视频处理书籍推荐🔎3.1 知识要点🔎3.2 如何领书 🚀四、结论 🚀一、背景 随着智能手机和社交媒体的普及，短视频成为了人们日常表达与娱乐的重要方式。然而，对于大多数用户来说，制作一部优质且吸引人的短视频依然是一项挑战。在这种背景下，人工智能（AI）的出现为短视频处理和剪辑带来了革命性的变化，在创作过程中发挥了重要作用。
🚀二、视频处理方向 🔎2.1 视频分析与标注 AI技术可以对视频内容进行自动分析和标注。对于短视频制作来说，这意味着用户可以快速找到想要的素材，并且更容易将不同的素材有机地组合在一起。AI可以识别视频中的对象、人物、场景、情绪等元素，并为每个元素添加关键字标签，使用户可以轻松地搜索和筛选素材，提高了创作效率。
例如，AI可以自动识别视频中的音频元素，如对话、音乐和噪音，并生成相应的字幕，使得短视频在没有声音的环境中依然能够传达信息。此外，AI还可以根据视频内容的情感色彩对素材进行分类，方便用户根据不同的情感需求寻找合适的素材。
🔎2.2 视频剪辑与特效 AI技术可以自动进行视频剪辑和添加特效。传统上，视频剪辑需要用户具备一定的专业知识和技能，而AI可以通过智能算法自动选择最佳的剪辑方式，大大降低了门槛。AI可以根据用户设定的要求，自动抽取关键帧、剪辑视频片段、调整视频的速度、镜头切换以及添加转场效果等，使得整个剪辑过程更加简单快捷。
此外，AI还可以为视频添加各种特效。例如，在运动相关短视频中，AI可以检测到人物的动作，并在运动高潮处自动生成慢动作效果。AI还可以根据音乐的节奏和情绪，自动为视频添加相应的滤镜、音效甚至是文字动画，提升视频的观赏性和趣味性。
🔎2.3 视频内容生成与故事叙述 AI技术能够基于输入的关键字和素材，自动生成完整的视频内容。这使得用户无需亲自拍摄或收集大量素材，只需提供关键信息，AI即可自动生成适合的短视频。这项技术在某些情况下可以节省用户的时间和努力，同时也为非专业创作者提供了实现自己创作想法的途径。
AI还可以帮助用户讲述故事。通过分析视频素材的情感色彩、场景等元素，AI可以自动生成整体故事线索，或者提供创意建议。这对于那些苦于故事构思的创作者来说是一个极大的助益，使得他们能够更好地表达自己的观点和情感。
🔎2.4 视频后期处理与发布 在视频剪辑完成后，AI技术还可以帮助用户进行后期处理和发布。 AI可以自动检测和修复视频中的噪点、抖动、曝光不足等问题，提高视频的质量。此外，AI还可以根据用户设定的要求进行视频的压缩和转码，以适应不同的平台和设备。
在视频发布方面， AI可以根据用户的需求，自动选择合适的发布平台和渠道，并进行智能推荐，以提高视频的曝光度。AI还可以根据用户的观看行为和反馈，对视频内容进行实时调整和优化，从而达到更好的用户体验。
🚀三、AI视频处理书籍推荐 书籍名称：
《AI短视频制作一本通：文本生成视频+图片生成视频+视频生成视频》
🔎3.1 知识要点 自学教程：
内容安排由浅入深、循序渐进，数十个生成案例助你零基础掌握AI文字生成视频、图片生成视频、视频生成视频
老师讲解：
赠送所有章节的同步视频教程和全书配套素材文件、效果文件，犹如专业老师手把手教学
技能精通：
一本书精通AI短视频生成，掌握未来最流行的短视频高效制作方法
职业跃迁：
深入掌握专业知识，快人一步制作更有专业视觉效果的短视频作品
🔎3.2 如何领书 ————————————————
本次本篇文章送书 🔥1-2本 评论区抽1-2位小伙伴送书
活动时间：截止到 2023-11-20 20:00:00
抽奖方式：利用网络公开的在线抽奖工具进行抽奖
参与方式：关注、点赞、收藏，评论“人生苦短，我用AI"
根据文章阅读量的多少来安排送书的本数。
————————————————
🔥 注：活动结束后，会私信中奖粉丝的，各位注意查看私信哦！
小伙伴也可以访问链接进行自主购买哦~
当当购买链接直达，京东购买链接
🚀四、结论 人工智能技术为短视频处理和剪辑带来了革命性的变化，从视频分析与标注、到视频剪辑与特效、再到视频内容生成与故事叙述，最后到视频后期处理与发布，AI的应用几乎贯穿了整个创作流程的各个环节。AI的出现使得短视频制作更加简单快捷，普通用户也能够轻松地制作出优质且吸引人的短视频作品。未来，随着AI技术的不断发展与创新，我们可以期待更多更强大的功能将会被引入，提升短视频创作的质量与效率。
今天的内容就到这里，我们下次见。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/569/">«</a>
	<span class="pagination__item pagination__item--current">570/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/571/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>