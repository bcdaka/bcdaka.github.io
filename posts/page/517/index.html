<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21353930a50cc7f378abf612514fadeb/" rel="bookmark">
			文心一言能降重吗 快码论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，今天来聊聊文心一言能降重吗 快码论文，希望能给大家提供一点参考。
以下是针对论文重复率高的情况，提供一些修改建议和技巧，可以借助此类工具：
文心一言能降重吗🔥✨
对于许多写作者来说，降重是一项必要的任务。在论文或文章的撰写过程中，我们经常需要确保内容的独特性和连贯性。那么，文心一言作为一个智能文本助手，是否能够帮助我们完成降重工作呢？下面是我的一些观点和体验。
1️⃣ 智能降重功能 💡
文心一言具备智能降重功能，它利用自然语言处理技术对文本进行分析和处理，从而识别和删除重复或相似的部分。在实际使用中，我发现文心一言能够快速地检测到重复内容并提出相应的修改建议。这些建议通常都是基于对上下文和语义的深入理解，因此相对准确。
2️⃣ 高效便捷 🖱️
使用文心一言进行降重非常方便。你只需要将需要降重的文本粘贴到指定的输入框中，然后点击“降重”按钮，系统就会自动为你处理。处理完成后，你可以直接查看修改后的文本。整个过程非常快速且易于操作。
3️⃣ 效果与准确性 🔥
对于一般的文本降重，文心一言的表现相当不错毕业论文如何用ai降重。它能准确地识别并处理重复内容，使文本更加简洁和连贯。然而，对于一些涉及特定领域或专业知识的文本，或者某些具有特殊语言风格的文本，文心一言可能无法完全准确地识别和处理重复内容。此时，人工审查和调整仍然非常重要。
4️⃣ 与其他工具的对比 📊
市场上有很多其他的文本降重工具，文心一言与其他工具相比具有一定的优势。它基于深度学习技术，能够更准确地识别和处理重复内容。同时，文心一言还提供了丰富的其他功能，如文本翻译、写作助手等，使它成为了一个全面的智能文本助手。
5️⃣ 局限性 ❌
尽管文心一言在文本降重方面表现出色，但它仍然存在一些局限性。例如，对于某些特定领域的专业术语或复杂的语言表达方式，文心一言可能无法准确识别和处理。此外，对于一些涉及到语义和语境的重复内容，文心一言也可能会出现误判或处理不当的情况。
6️⃣ 总结评价 🌟
总的来说，文心一言是一个非常有用的智能文本助手，能够帮助我们快速完成降重工作。它可以有效地识别和处理重复内容，使文本更加简洁和连贯。然而，我们仍需结合人工审查和调整，以确保降重后的文本准确性和学术价值。如果你需要快速处理大量文本或需要频繁进行降重工作，文心一言是一个值得考虑的选择。🔥✨
文心一言能降重吗相关文章：
毕业论文查重标红怎么修改
论文查重翻译成英文可以吗
计算机本科毕业论文降重降不下去
论文查重率是怎么算的sci
论文查重的时候怎样不算重复
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/980443924292033d18fb8505a00f4267/" rel="bookmark">
			AI创作之旅：探索提示工程的奇妙世界
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
推荐
1. 引言
2. 什么是提示工程？
3. 准备工作
3.1 安装必要的库
3.2 获取 OpenAI API 密钥
4 设置 OpenAI API 密钥
5. 提示工程实战
6. 探索更多可能性
6.1 尝试不同的提示
6.2 调整参数
结语
⭐️ 好书推荐
推荐 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站
在当今信息爆炸的时代，人工智能的发展为创作者们提供了全新的可能性。本文将引导你从零开始，利用提示工程（Prompt Engineering）学习并应用大语言模型，创作一篇超过2000字的文章。我们将深入探讨提示工程的基本概念，并通过实际代码演示如何发挥大语言模型的创作潜力。
1. 引言 随着数字化时代的来临，人工智能已经不再仅仅是科技的进步，更成为创作领域中不可或缺的有力助手。在这个信息爆炸的时代，创作者们面临着巨大的文本创作挑战，而人工智能通过其强大的语言生成能力，为他们提供了一种前所未有的创作思维方式。
提示工程作为人工智能技术的一种应用，通过给定简短的提示，能够生成丰富、连贯的文本内容。这种方法的兴起标志着创作者们在创作过程中迎来了一场革命，不再局限于传统的创作手段，而是可以借助机器智能的力量进行创意的探索和表达。
在以往，创作者们可能需要花费大量时间和精力进行调研、构思和编辑，但有了提示工程这一工具，他们可以更加聚焦于创作的核心思想，将人工智能作为创意的延伸。这种全新的思维方式使得创作者们能够更加高效地表达他们的想法，同时也为他们带来了更多样化的创作可能性。
2. 什么是提示工程？ 提示工程是指通过给定一个简短的提示（prompt），利用大语言模型生成相应的文本。这种方法在自然语言处理领域取得了巨大的成功，尤其是近年来GPT等大型语言模型的崛起，使得提示工程成为创作者们不可忽视的工具。
3. 准备工作 在进入实际的提示工程应用之前，我们需要进行一些准备工作，确保环境和依赖库都已经正确安装。以下是一些基本的准备步骤，以确保我们能够顺利地利用提示工程学习和应用大语言模型。.
3.1 安装必要的库 首先，我们需要安装与提示工程相关的 Python 库。在终端或命令提示符中执行以下命令：
pip install openai 这将安装 OpenAI 的 Python 客户端库，它是与 OpenAI GPT-3 大语言模型进行交互的必要工具。
3.2 获取 OpenAI API 密钥 在使用提示工程之前，您需要获得 OpenAI API 密钥。访问 OpenAI 官方网站 注册并获取您的 API 密钥。将密钥保存在安全的地方，我们将在后续的代码中使用它。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/980443924292033d18fb8505a00f4267/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f06d661fe386c5ceea4a857ac27edcd3/" rel="bookmark">
			Hive SQL中的列转行（lateral view与explode）、行转列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、列转行 1、相关函数 列转行：将某列一行中的数据拆分成多行
1）Explode炸裂函数 将hive某列一行中复杂的 array 或 map 结构拆分成多行（只能输入array或map）
语法： select explode(字段) as 字段命名 from 表名; 举例： explode(array)使得结果中将array列表里的每个元素生成一行
select(array('1','2','3')) explode(map)使得结果中将map里的每一对元素作为一行，key为一列，value为一列
select explode(map('A','1','B','2','C','3')) 局限性： 1、不能关联原有的表中的其他字段
2、不能与group by、cluster by、distribute by、sort by联用
3、不能进行UDTF嵌套
2）posexplode()函数 explode()：对一列进行炸裂可以使用
posexplode()：对两列都进行多行转换，可以将index和数据都取出来，使用两次posexplode并令两次取到的index相等即可
举例： select posexplode(collect_set('AA')) posval0AA collect_set：将某字段进行去重处理，返回array类型
3）Lateral View Lateral View配合 split, explode 等UDTF函数一起使用，它能够将一列数据拆成多行数据，并且对拆分后结果进行聚合，即将多行结果组合成一个支持别名的虚拟表。相当于拆出一张虚拟表，与原表进行关联。
语法： select o.*, table_view.new_col from table_origin o lateral view UDTF(expression) table_view as new_col_1, new_col_2 lateral view：表示将UDTF分裂的字段放在虚拟表中, 然后和主表table_origin进行关联。
UDTF(expression)：使用的UDTF函数，例如explode()
table_view : 对应的虚拟表的表名
new_col: 虚拟表里存放的有效字段（可多个）
注意：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f06d661fe386c5ceea4a857ac27edcd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21406c38c4eb5c57ddd10c8eb06bebe8/" rel="bookmark">
			Java中如何详细的打印出具体报错的堆栈信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在遇到日志打印的时候，当使用log.error("Exception==={}", e.toString()); 当使用这种方式打印，只会打印关键的信息，不会打印出栈堆信息，从而无法准确定位到具体某一行发生的错误
比如，在一个接口有方法对一个对象进行存储的时候，其中这个对象有一个属性叫errorNum 并且不能为空，当为空进行存储，就会报错。
先说解决方案
第一种打印方式(解决方案)： @ExceptionHandler({Exception.class}) public ResponseDTO exceptionHandler(Exception e) { log.error("Exception===", e); return ResponseDTO.onError("系统异常"); } 这种方式打印结果：
11:44:43.415 [http-nio-10008-exec-1] [user="" token=""] ERROR o.h.e.jdbc.spi.SqlExceptionHelper - Column 'error_num' cannot be null 11:44:43.449 [http-nio-10008-exec-1] [user="" token=""] ERROR c.a.y.e.ExceptionControllerAdvice - Exception=== org.springframework.dao.DataIntegrityViolationException: could not execute statement; SQL [n/a]; constraint [null]; nested exception is org.hibernate.exception.ConstraintViolationException: could not execute statement at org.springframework.orm.jpa.vendor.HibernateJpaDialect.convertHibernateAccessException(HibernateJpaDialect.java:276) at org.springframework.orm.jpa.vendor.HibernateJpaDialect.translateExceptionIfPossible(HibernateJpaDialect.java:233) at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.translateExceptionIfPossible(AbstractEntityManagerFactoryBean.java:551) at org.springframework.dao.support.ChainedPersistenceExceptionTranslator.translateExceptionIfPossible(ChainedPersistenceExceptionTranslator.java:61) at org.springframework.dao.support.DataAccessUtils.translateIfNecessary(DataAccessUtils.java:242) at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:152) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21406c38c4eb5c57ddd10c8eb06bebe8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/486b5d1a8d43103f7c6e5b59d4d2e1d5/" rel="bookmark">
			iOS17使用safari调试wkwebview
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		isInspectable配置 之前开发wkwebview的页面的时候一直使用safari调试，毕竟jssdk交互还是要用这个比较方便，虽说用一个脚本插件没问题。不过还是不太方便。
但是这个功能突然到了iOS17之后发现不能用了，还以为又是苹果搞得bug，每次升级都有一些问题，可能要过一段时间才能修复。但是过了一段时间还是老样子，查了一下发现这个又是为了安全做的一层限制。。。
先说配置方式。
let _webView = WKWebView(frame: self.bounds, configuration: .init()) if #available(iOS 16.4, *) { _webView.isInspectable = true } else { // Fallback on earlier versions } 增加了一个 isInspectable 这个配置。默认还是false。想要调试还必须把这个设置给打开，行吧行吧。改完了果然又能够愉快的调试了。
手机端safari的配置 顺便回顾一下手机端safari的配置。
首先打开设置，然后选择safari，在选择高级设置，打开网络检查器。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abb88ee6b094dbc349a1c15d7578a420/" rel="bookmark">
			Hive 排名函数ROW_NUMBER、RANK()、DENSE_RANK等功能介绍、对比和举例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. ROW_NUMBER()
2. RANK()
3. DENSE_RANK()
4. NTILE()
5. CUME_DIST()
6. PERCENT_RANK()
1. ROW_NUMBER() 功能：ROW_NUMBER() 函数为每个分组内的行提供唯一的序列号，从1开始。如果在 OVER() 子句中使用 ORDER BY 语句，它将根据指定的列值对行进行排序。
对比：
每个行都会获得一个唯一的排名数字。
即使两行的排序列值相同，它们也会获得连续的排名，不会有相同的排名值。
举例： SELECT name, score, ROW_NUMBER() OVER (ORDER BY score DESC) as rank FROM students; 说明：假设 students 表包含学生的名字和分数。上述查询将根据分数降序排列学生，并为每个学生分配一个唯一的序列号作为排名。如果两个学生分数相同，他们将获得连续的排名编号。
2. RANK() 功能：RANK() 函数在分组内为行提供排名，从1开始。如果两行或多行在 ORDER BY 子句中指定的排序列上的值相等，则它们将获得相同的排名，并且排名数字会跳过。
对比：
如果有相同值的行，它们将共享相同的排名。
在相同值的行之后的排名会跳过那些共享排名的行数。例如，如果有两行共享排名1，那么下一个排名将是3。
举例：
SELECT name, score, RANK() OVER (ORDER BY score DESC) as rank FROM students; 说明：使用与 ROW_NUMBER() 相同的数据，RANK() 函数将为分数相同的学生分配相同的排名。如果两个学生的分数相同，他们将共享排名，例如都是排名1，下一个学生的排名将是3（假设只有两个学生分数相同）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abb88ee6b094dbc349a1c15d7578a420/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1941948d6b2619020f0f96b8865faf1e/" rel="bookmark">
			阿里AI代码智能编辑插件通义灵码——对标GitHub Copilot、完爆讯飞iflycode
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本人亲测，阿里的通义灵码比讯飞的iflycode好用，好用不知道多少倍。
！！！！！声明，我没有收钱，亲身感受。
官网 通义灵码官网地址：https://tongyi.aliyun.com/lingma/
下载使用 按照官网给出的步骤，到各自的编辑器里面安装即可，兼容 Visual Studio Code、JetBrains IDEs 等主流编程工具， 为你提供高效、流畅、舒心的智能编码体验。
示例 这是一个在Pycharm中的例子，根据上下文来生成代码，而且就是自己想要的。
总结 我不管，就是好用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81a3bd374bb4030fb2651e7cff636d9b/" rel="bookmark">
			JAVA接入小程序微信支付
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、准备所需账号以及配置信息 1、在 微信公众平台 注册应用，并保存好appId和appSecret
2、在微信支付商户平台 注册一个商户，保存好mchId（商户id）、api_key(支付密钥)、以及商户证书序列号。还需要将支付商户密钥文件下载放到项目resources目录中
项目结构 （结构中包含的其他内容与支付无关）
二、开发环境 1、导入jar包
&lt;dependency&gt; &lt;groupId&gt;com.github.wechatpay-apiv3&lt;/groupId&gt; &lt;artifactId&gt;wechatpay-java&lt;/artifactId&gt; &lt;version&gt;0.2.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.wxpay&lt;/groupId&gt; &lt;artifactId&gt;wxpay-sdk&lt;/artifactId&gt; &lt;version&gt;0.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.fastjson2&lt;/groupId&gt; &lt;artifactId&gt;fastjson2&lt;/artifactId&gt; &lt;version&gt;2.0.26&lt;/version&gt; &lt;/dependency&gt; 2、在yaml文件中配置参数
wechatpay: #应用编号 正式号id appId: XXXXXX # 小程序密钥 appSecret: XXXXXX #商户号 mchId: XXXXXX # APIv3密钥（在微信支付平台中自己设置） apiV3Key: XXXXXX # 支付成功后微信官方会自动调用我们设定的接口：域名/接口名 # 支付通知回调, 本地测试内网穿透地址（仅用于做本地测试） # notifyUrl: http://84cd47.natappfree.cc/wechatPay/notify-pay # 支付通知回调, 线上域名地址（正常使用服务器配置的域名即可），小程序上线后前后端访问数据时只能用https不能用http，因此还需要为域名配置SSL证书，可根据使用的服务器查看如何配置 notifyUrl: XXXXXX # 密钥路径,resources根目录下 keyPemPath: src/main/resources/wechatPay/apiclient_key.pem certPath: src/main/resources/wechatPay/apiclient_cert.pem certP12Path: src/main/resources/wechatPay/apiclient_cert.p12 # 商户证书序列号（可在微信支付平台商户信息中查看） serialNo: XXXXXXXXXX 3、将参数注入到配置类中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81a3bd374bb4030fb2651e7cff636d9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69c4da4e69d57d939ea169515459141c/" rel="bookmark">
			纯前端 -- html转pdf插件总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、html2canvas+jsPDF（文字会被截断）： 将HTML元素呈现给添加到PDF中的画布对象，不能仅使用jsPDF，需要html2canvas或rasterizeHTML html2canvas+jsPDF的具体使用链接
二、html2pdf（内容显示不全+文字会被截断）： 下载或者安装html2pdf：官网 1、将文档放在本地，用原生js进行引用和使用。 ① 新建一个名为 html2pdf.js 的文件，并且将线上的内容进行复制。
② 引入 js 文件：
// js直接引入 -- 未尝试 &lt;script type="text/javascript" src="https://cdn.bootcdn.net/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.js"&gt;&lt;/script&gt; // layui使用 // 首先在html2pdf.js文件中添加exports layui.define([],function(exports){ // 复制的内容... exports('html2pdf',html2pdf); }) // 其次进行自定义插件的引入 layui.define(['appsmenu'],function (exports) { exports("conf", { // 第三方扩展 extend: { // 引入html2pdf html2pdf: "lay/extends/html2pdf", } } }) 2、使用 npm 进行安装使用： npm install --save html2pdf.js 3、在原生js中使用： // 点击下载按钮 document.getElementById("btn").onclick=function(){ let opt = { margin: 1, // pdf外边距 filename: 'pdf生成'+'.pdf', // 导出的pdf名称 image: { // 图片的类型和质量，详情： https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69c4da4e69d57d939ea169515459141c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9edd9b0032d22f65d68d33b08728f4a2/" rel="bookmark">
			前端Vue日常工作中--CSS变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue中简单使用：
CSS变量，也称为自定义属性（Custom Properties），是一种允许在CSS中定义和使用的变量。这种特性的引入使得在样式表中更容易维护和调整值，提高了代码的可读性和可维护性。
1. 定义变量：
在CSS中，变量以 -- 开头，其语法为：
:root {
--main-color: #3498db;
}
:root 表示文档根元素，通常是 &lt;html&gt; 元素。变量名为 --main-color，值为 #3498db。
2. 使用变量：
可以在样式规则中使用 var() 函数来引用变量的值：
body {
background-color: var(--main-color);
}
body 元素的背景颜色就会应用 --main-color 的值。
3. 作用域：
CSS变量的作用域是块级的。如果在一个元素中定义了变量，它只在该元素及其子元素中有效。这种作用域性质使得变量可以被限制在特定的区域使用。
4. 默认值
变量可以有默认值，如果没有为变量提供值，将使用默认值：
body {
background-color: var(--main-color, #fff); /* 使用变量，如果变量未定义则使用 #fff 作为默认值 */
}
5. 动态更新：
通过JavaScript，动态更改CSS变量的值，并且这些更改将立即反映在页面上：
document.documentElement.style.setProperty('--main-color', '#ff5733');
6. 优势：
重用性和可维护性： 变量允许你在整个样式表中轻松更改和重用值，提高了代码的可维护性。
动态性： 变量可以通过JavaScript进行动态更新，使得样式更具交互性和动态性。
可读性： 使用有意义的变量名可以提高代码的可读性和可理解性。
7. Vue中简单使用：
基础使用
:root {
--main-color: #3498db;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9edd9b0032d22f65d68d33b08728f4a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b2817baf0984ab4ffd23fbe06e1bfbf/" rel="bookmark">
			图灵之旅--ArrayList&amp;顺序表&amp;LinkedList&amp;链表&amp;&amp;栈&amp;&amp;Stack&amp;&amp;队列&amp;&amp;Queue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 线性表顺序表ArrayList简介ArrayList使用ArrayList的构造ArrayList常见操作ArrayList的遍历ArrayList的扩容机制利用ArrayList洗牌ArrayList的优缺点 链表链表的实现双向链表的实现 LinkedListLinkedList引入LinkedList的使用LinkedList的构造LinkedList的常用方法介绍LinkedList的遍历 ArrayList和LinkedList的区别栈概念栈的使用栈的模拟实现 概念区分队列概念队列使用队列模拟实现循环队列双端队列用队列实现栈用栈实现队列 线性表 线性表是n个具有相同特性的数据元素的有限序列.线性表是一种在实际中广泛应用的数据结构
线性表在逻辑层面是连续的,但在物理结构上不一定连续,线性表在物理结构中存储一般以数组或者链式结构的形式存在
顺序表 顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构,一般情况下是以数组来进行存储数据.在数组中进行增删改查
接口实现
public class List implements MyArrayList{ private int[] elements; private int usedSize; //顺序表的默认大小 private static final int DEFAULT_SIZE = 2; public List() { this.elements = new int[DEFAULT_SIZE]; } public List(int capacity) { this.elements = new int[capacity]; } @Override public void display() { for (int i = 0; i &lt; this.usedSize; i++) { System.out.print(this.elements[i]+" "); } System.out.println(); } @Override public boolean isFull() { /*if(this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b2817baf0984ab4ffd23fbe06e1bfbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31afa6b6cf60bb491d1b28f4377b0199/" rel="bookmark">
			数据结构奇妙旅程之七大排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		꒰˃͈꒵˂͈꒱ write in front ꒰˃͈꒵˂͈꒱
ʕ̯•͡˔•̯᷅ʔ大家好，我是xiaoxie.希望你看完之后,有不足之处请多多谅解，让我们一起共同进步૮₍❀ᴗ͈ . ᴗ͈ აxiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客
本文由xiaoxieʕ̯•͡˔•̯᷅ʔ 原创 CSDN 如需转载还请通知˶⍤⃝˶
个人主页：xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客
系列专栏：xiaoxie的JAVA系列专栏——CSDN博客●'ᴗ'σσணღ*
我的目标:"团团等我💪( ◡̀_◡́ ҂)" ( ⸝⸝⸝›ᴥ‹⸝⸝⸝ )欢迎各位→点赞👍 + 收藏⭐️ + 留言📝​+关注（互三必回）!
一.排序的概念 排序的概念 排序 ：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。 稳定性 ：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持 不变，即在原序列中， r[i]=r[j] ，且 r[i] 在 r[j] 之前，而在排序后的序列中， r[i] 仍在 r[j] 之前，则称这种排序算法是稳 定的；否则称为不稳定的。 内部排序 ：数据元素全部放在内存中的排序。 外部排序 ：数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。 二.插入排序 1.直接插入排序 直接插入排序是一种简单的插入排序法，其基本思想是： 把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到 一个新的有序序列 。实际中我们玩扑克牌时，就用了插入排序的思想。 1.过程 假设我们有一个数组array{15，87，63，5，98，23，1，82，10} ；我们如果使用直接插入排序的过程如下：
原始： 15 87 63 5 98 23 1 82 10
第一趟： 15 87 63 5 98 23 1 82 10
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31afa6b6cf60bb491d1b28f4377b0199/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6defee44c42344e7c6628db9e25a273f/" rel="bookmark">
			Python地理空间数据库之geopandas使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要 地理空间数据分析在许多领域中都有着广泛的应用，包括地理信息系统（GIS）、城市规划、环境科学、地质勘探等。Python GeoPandas是一个强大的库，旨在简化地理空间数据的处理和分析。本文将深入介绍GeoPandas库，包括其基本概念、功能特性、示例代码以及在实际应用中的应用场景。
什么是GeoPandas？ GeoPandas是一个开源的Python库，用于处理地理空间数据。它结合了两个其他流行的地理空间库，即Pandas和Shapely，提供了一个统一的数据结构来处理地理空间数据。GeoPandas的核心数据结构是GeoDataFrame，它是Pandas DataFrame的扩展，允许存储地理空间几何图形和属性数据。
GeoPandas的主要功能包括：
读取和写入多种地理空间数据格式，如Shapefile、GeoJSON、PostGIS、KML等。
支持地理空间几何图形的创建、编辑和分析，包括点、线、面等。
提供空间连接、缓冲区分析、几何运算等地理空间操作。
具备数据可视化能力，可以绘制地理空间数据的地图。
安装GeoPandas 要开始使用GeoPandas，首先需要安装它。
可以使用pip来安装GeoPandas及其依赖项：
pip install geopandas 安装完成后，可以在Python项目中引入GeoPandas并开始使用。
基本概念 GeoDataFrame GeoPandas的核心数据结构是GeoDataFrame，它类似于Pandas的DataFrame，但包括一个额外的"geometry"列，用于存储地理空间几何图形。一个GeoDataFrame可以包含多个地理要素，每个要素具有一个几何图形和一组属性。
以下是一个示例，展示了如何创建一个GeoDataFrame：
import geopandas as gpd from shapely.geometry import Point # 创建一个空的GeoDataFrame gdf = gpd.GeoDataFrame() # 添加一个Point几何对象和属性数据 gdf['geometry'] = [Point(0, 0), Point(1, 1)] gdf['name'] = ['Point A', 'Point B'] 在这个示例中，首先创建了一个空的GeoDataFrame，然后添加了两个Point几何对象和相应的属性数据。
几何图形 GeoPandas支持各种地理空间几何图形，包括点、线、面、多边形等。这些几何图形可以用来表示地理空间对象，如城市、河流、国家边界等。
以下是一个示例，展示了如何创建不同类型的几何图形：
from shapely.geometry import Point, LineString, Polygon # 创建Point几何对象 point = Point(0, 0) # 创建LineString几何对象 line = LineString([(0, 0), (1, 1), (2, 2)]) # 创建Polygon几何对象 polygon = Polygon([(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)]) 在这个示例中，使用Shapely库创建了Point、LineString和Polygon几何对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6defee44c42344e7c6628db9e25a273f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95dbfd0e228de40d27dd77e14394d959/" rel="bookmark">
			【算法专题】贪心算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		贪心算法 贪心算法介绍1. 柠檬水找零2. 将数组和减半的最少操作次数3. 最大数4. 摆动序列(贪心思路)5. 最长递增子序列(贪心算法)6. 递增的三元子序列7. 最长连续递增序列8. 买卖股票的最佳时机9. 买卖股票的最佳时机Ⅱ(贪心算法)10. K 次取反后最大化的数组和11. 按身高排序12. 优势洗牌13. 最长回文串14. 增减字符串匹配15. 分发饼干16. 最优除法17. 跳跃游戏Ⅱ18. 跳跃游戏19. 加油站20. 单调递增的数字 贪心算法介绍 什么是贪心算法呢？
首先，我们需要知道贪心策略，即解决问题的策略，将局部最优转变为全局最优；
把解决问题的过程分为若干步；解决每一步的时候，都选择当前看起来"最优的"解法；"希望"得到全局最优解 贪心算法的特点：
提出贪心策略，但是贪心策略的提出是没有标准和模板的，可能每一道题的贪心策略都是不同的；贪心策略的正确性没有保障，因为我们提出的"贪心策略"有可能是错误的，正确的贪心策略是需要"证明的"；常用的证明方法是我们学过的数学中见过的证明方法。 下面我们结合题目进行分析。
1. 柠檬水找零 题目链接 -&gt; Leetcode -860.柠檬水找零
Leetcode -860.柠檬水找零
题目：在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。
每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。
注意，一开始你手头没有任何零钱。
给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。
示例 1：
输入：bills = [5, 5, 5, 10, 20]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95dbfd0e228de40d27dd77e14394d959/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d38dd7312e8f0e9c0b45ea276d1cab7c/" rel="bookmark">
			AIGC 后视镜：过去这一年，大家都在哪搞钱？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是煎鱼。
由于 OpenAI 的 ChatGPT-3.5、GPT-4、GPT-4V 等产品的发布和传播。过去这一年多是 AIGC 爆发的元年，这是无容置疑的。
GPT 在许多方面都是较有帮助的。像是我们所在的 IT 行业来看。著名的 Stack Overflow 在 ChatGPT 发布后，流量基本也是断崖式下降的。
如下图所示：
GPT 功能上好的、差的地方，过去大家听的都多了。本文意不在于此。
今天主要分享，我有一个朋友过去一年看到大家在 AIGC 这块是怎么搞钱的。当然，这些都仅限于我的个人认知，可能是错误的。错了就图一乐吧。
都在哪搞钱 卖各种账号 这差不多是我知道的最早的一批人了。普遍走的是线上搭建商品站点售卖账号。批量注册、批量发号、批量补号，写了程序做流水线作业。
售卖的商品基本是：GPT-3.5 的基本账户、GPT-4、共享 GPT Plus 账号、代理充值等。
据我了解，圈内圈外的人都有一定的诉求，因为到个体来讲，价格普遍不是很贵，也算是一个刚需。
国内套壳站 类似 SaaS 产品，套壳国外 GPT，再做一些功能特性的迭代改进和 Prompt。按用户和使用量收费。也类似 tokens 数。
还有卖 API 调用的，有的价格比官方的还低。我有不少朋友为此付了费。
这块我倒没想明白，他们是怎么做到价格更低的，莫非是亏本买卖？还是套的 GPT3？
做独立站 赚国外流量钱，例如：Google 广告。最常见的是 GPT‘s 火热的那段时间。持续的有一批人在做，普遍是比较懂流量做 SEO 有相关经验的人在入场做。
也有人在教人做。也就是下一个类别了。
卖 AI 课、做圈子、分享资源 这块是比较多人涌入的一个区域，因为有一定的学习和交流需求。很多大 V 和付费教育类型的公司都做了课程、圈子，售卖一定的订阅价格。
更甚的在前期，里面都主要是分享资源。我有一个朋友在早期花钱进了个圈子，结果里面也只是提供 AI 资料交流。他也觉得还行。相当于花钱请人帮自己跟进和梳理时事了。
现在各知识付费的公司都有在跟进该品类。
卖产品/工具 结合 AIGC 做的一些产品，类似妙鸭相机、某某知识库等。也有在淘宝上接单用 GPT 出图或改写的。这种一般还稍微有些产品+技术实现的样子。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d38dd7312e8f0e9c0b45ea276d1cab7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bf35b92aa7dffd25ce0f5feb098bfff/" rel="bookmark">
			【前端 Uniapp】使用Vant打造Uniapp项目（避坑版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本介绍 Uniapp 是基于 Vue.js 的开发框架，通过一套代码可以同时发布到多个平台的应用框架。而 Vant 是针对移动端 Vue.js 的组件库。通过这样的组合，我们可以快速构建出一个跨平台的移动应用。Vant 已经支持多种小程序和 H5 平台，也对 Uniapp 实现了完美的支持。我们可以使用 Vant 提供的丰富的组件和功能，来快速开发一个漂亮、易用的移动应用。
二、安装 Vant 组件 1. HBuilder X中新建一个uni-app的项目 1、添加项目名称，选择文件路径
2、选择默认模板
3、Vue版本选择（若无其他需求，点击创建即可）
注意：
项目名不能有空格；不能出现开头大写；不能用中文命名
2. HBuilder X提示项目创建成功，在HBuilder X用命令行窗口打开创建的项目（或直接在创建的项目文件夹内用cmd指令打开） 3. 输入npm init -y 指令，创建项目配置文件（即package.json）； 4. 输入npm i @vant/weapp -S --production下载vant 安装完成后，项目中会多出一个依赖项，也代表安装成功
5. 在项目的根路径下，创建 wxcomponents 目录，并将依赖项（node_modules）中@vant文件夹下的dist复制到wxcomponents，并修改文件夹名为vant;（主要是为了方便查看和引用） 6. 在pages.json中注册并引入组件 7. 找到 App.vue ，引入公共组件样式 先运行一下：
报错：
这是因为引入 vant 组件的时候识别样式，vant-icon 发生了错误，改一下就可以。
这里发生错误的第一编号是 iv4v8nulyz. 可以自己仔细看看，每个人会有不同，如果查找到的话
/vant/wxcomponents/vant/icon/index.wxss
找到这个地方
然后再第二个和第三个URL前面加一个空格（英文状态下），关掉刷新一下，再重新打开 Hbuild.
以下为组件的全局注册，可根据需求按需导入组件：
"usingComponents": { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bf35b92aa7dffd25ce0f5feb098bfff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/251dda35953109bf0815ad519e547627/" rel="bookmark">
			2024年新算法-冠豪猪优化算法(CPO)-公式原理详解与性能测评 附赠Matlab代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
原理简介
一、种群初始化
二、循环种群减少技术
三、勘探阶段
（1）第一防御策略
（2）第二防御策略
四、开发阶段
（1）第三防御策略
（2）第四防御策略
算法流程图与伪代码
性能测评
Matlab核心代码
参考文献
今天为大家带来一期冠豪猪优化算法(CPO)-公式原理详解与性能测评，独家原创！适合作为创新点！具体代码已放在最后，需要代码的朋友可直接拉到最后~
冠豪猪优化器(Crested Porcupine Optimizer, CPO)是一种新型的元启发式算法（智能优化算法），该成果由Abdel-Basset等人于2024年1月发表在中科院1区SCI期刊Knowledge-Based Systems上。
由于发表时间较短，谷歌学术上还无人引用！你先用，你就是创新！
原理简介 冠豪猪（CP）是一种大型啮齿动物，生活在除南极洲以外的所有大陆，分布在森林、沙漠、岩石露头和山坡上。CP是仅次于水豚和海狸的第三大啮齿动物。大多数有冠豪猪大约有25-36英寸长，尾巴8-10英寸。它们的体重在12到35磅之间，呈圆形，体型较大，行动迟缓。大多数CP的身体覆盖着深棕色或黑色的刚毛，偶尔会有白色的斑点。它们最显著的特征是它们的羽毛很宽，沿着身体的后半部分延伸，长度可达14英寸。冠豪猪是夜间食草动物，以灌木和树叶等多种植物为食。尽管它们生活在小家庭中，但它们倾向于独自觅食，寻找长达九英里的食物。它们之所以如此命名，是因为它们的头、颈背、尾巴和身体后部都有长长的羽毛~
CPO模拟了冠豪猪的各种防御行为。冠豪猪的四种防御策略是视觉、声音、气味和身体攻击。这些策略从最不激进到最激进排序。在CPO中，我们可以可视化搜索空间，如下图所示；四个不同的区域模拟了防御CP区域。第一个区域（A），CP远离捕食者，代表第一个防御区域，用于实施第一个防御策略。第二区域（B）代表第二防御区域，用于在捕食者不害怕第一防御机制并向捕食者移动的情况下实施第二防御策略。第三区域（C）代表第三防御区，用于实施第三防御策略，当捕食者不害怕第二和第三防御机制，仍向CP移动时，该策略被激活。最后一个区域（D）代表最后一个防御区域，用于实施最后一个防守策略。在最后一个区域，在之前的所有防御机制失效后，CP会攻击捕食者，使其失去能力，甚至杀死它们以保护自己。
一、种群初始化 与其他基于元启发式群体的算法类似，CPO从初始个体集（候选解决方案）开始搜索过程：
其中N表示个体数量（种群大小N），Xi是搜索空间中的第i个候选解，L和U分别是搜索范围的下限和上限，r是在0和1之间随机数
二、循环种群减少技术 循环种群减少技术（CPR），除了加快收敛速度外，还可以保持种群多样性。这种策略模拟了这样一种想法，即并非所有CP都激活防御机制，而是只有那些受到威胁的CP才激活防御机制。因此，在该策略中，在优化过程中从种群中获得一些CP，以加快收敛速度，并将它们重新引入种群中，从而提高多样性，避免陷入局部极小值；该循环基于循环变量T，以确定优化过程中执行该过程的次数（图3）。循环减少人口规模的数学模型如下：
其中，T是确定循环数的变量，t是当前函数评估，Tmax是函数评估的最大数量，%表示余数或模运算符，Nmin是新生成的种群中个体的最小数量，因此种群大小不能小于Nmin。随着当前函数评估次数的增加，人口规模逐渐减少，甚至达到40人。这表示第一个循环。之后，种群规模再次最大化，然后逐渐减小，甚至达到优化过程的终点。这表示第二个也是最后一个周期，因为T被设置为2。由此可以看出，种群规模先是最大化，然后逐渐缩小，甚至达到Nmin。
三、勘探阶段 （1）第一防御策略 当CP意识到捕食者时，它开始举起并扇动羽毛笔，给人一种更深的印象。因此，捕食者有两种选择，要么向它移动，要么远离它。在第一种选择中，由于捕食者向CP移动，捕食者与CP之间的距离减小。这种选择鼓励探索捕食者与CP间的区域，以加快收敛速度。相反，在第二种选择中，捕食者和CP之间的距离最大化，因为捕食者选择离开。此选项鼓励探索遥远的地区，以确定未访问的地区，这可能涉及所需的解决方案。使用正态分布来生成随机值，以数学方式模拟这些选项。如果这些随机值小于1或大于−1，则鼓励向CP靠近。否则，捕食者将远离CP。通常，这种行为在数学上模拟如下：
其中xtCP是评估函数t的最佳解，yti是在当前CP和从种群中随机选择的CP之间生成的向量，用于表示捕食者在迭代t时的位置，τ1是基于正态分布的随机数，τ2是区间[0,1]中的随机值。生成yti的数学公式如下所示：
其中r是[1，N]之间的随机数。
（2）第二防御策略 在这种策略中，CP使用声音方法制造噪音并威胁捕食者。当捕食者靠近豪猪时，豪猪的声音会变得更大。为了从数学上模拟这种行为，提出了以下公式：
其中r1和r2是[1,N]之间的两个随机整数，τ3是0和1之间生成的随机值。
四、开发阶段 （1）第三防御策略 在这种策略中，CP会分泌恶臭，并在其周围区域传播，以防止捕食者靠近它。为了从数学上模拟这种行为，提出了以下公式：
其中r3是[1,N]之间的随机数，δ是用于控制搜索方向的参数，并使用等式（8）定义。xti是迭代t时第i个个体的位置，γt是使用等式（9）定义的防御因子。τ3是区间[0,1]内的随机值，Sti是使用（10）等式定义的气味扩散因子。如下所示：
其中，f(xit)表示迭代t时第i个个体的目标函数值，ε是避免被零除的小值，rand是包括在0和1之间随机生成的数值的矢量，rand是包括在1和0之间随机生成数字的变量，N是总体大小，t是当前迭代的次数，tmax是最大迭代次数。U1矢量用于模拟该策略中可能出现的三种情况：
(1)当U1 等于0，CP将停止气味扩散，因为捕食者会因为害怕CP而停止移动，因此捕食者与CP之间的距离保持不变；
(2)当U1等于1时，由于捕食者在附近，CP会显著散发气味；
(3) 当U1是0和1的组合，捕食者与CP保持安全距离，因此，没有必要广泛释放其气味。
（2）第四防御策略 最后一种策略是物理攻击。当捕食者离它很近并用短而厚的羽毛攻击它时，CP会采取物理攻击。在物理攻击过程中，两个物体强烈融合，代表一维的非弹性碰撞。为了用数学公式表达其物理攻击行为，提出了以下公式：
其中xtCP是获得的最佳解，表示xtiCP在迭代t时第i个个体的位置，表示该位置的捕食者，α是稍后在参数设置部分讨论的收敛速度因子，τ4是区间[0,1]内的随机值，Fti是影响第i个捕食者的CP的平均力。它由非弹性碰撞定律提供并由公式(12)定义：
其中mi是迭代t时第i个个体（捕食者）的质量，f(‧)表示目标函数，vi(t+1)是第i个个体在下一次迭代t+1时的最终速度，并基于从当前总体中选择随机解进行分配，vti是迭代t时第i个个体的初始速度，Δt是当前迭代的次数，τ6是包括在0和1之间生成的随机值的向量。在等式（12）中，基于分子除以当前迭代来计算CP的平均力，当前迭代在优化过程中线性增加。因此，CP的平均力的影响逐渐最小化。事实上，这个因素的小值对CPO的性能并不不利，因为它们可能无助于利用迄今为止最好的解决方案周围的各个区域来找到更好的解决方案。因此，通过删除分子并仅依赖于分母，如公式（13）所示。这种方法将有助于在搜索空间内创建广泛的值，从而对迄今为止最好的解决方案周围的区域进行更全面的检查。
算法流程图与伪代码 性能测评 原文作者采用CEC2014、CEC2017和CEC2020三个CEC基准对CPO进行了验证，这里我采用经典的23个标准测试函数进行测试，也方便大家与自己的算法进行比较~
这边用了5个函数，并与2023年新出的霜冰优化算法进行比较，方便看出好坏~
可以看出，CPO的效果还是非常不错的，值得一用~
Matlab核心代码 function [Gb_Fit,Gb_Sol,Conv_curve]=CPO(Pop_size,Tmax,lb,ub,dim,fobj) %%%%-------------------Definitions--------------------------%% %% Conv_curve=zeros(1,Tmax); ub=ub.*ones(1,dim); lb=lb.*ones(1,dim); %%-------------------Controlling parameters--------------------------%% %% N=Pop_size; %% Is the initial population size.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/251dda35953109bf0815ad519e547627/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fd219046e7d69b4cfaeca3952e9712b/" rel="bookmark">
			Android Studio 下载安装配置使用入门【2024年最新】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： Android Studio 是谷歌官方提供的主要集成开发环境（IDE），专为 Android 平台应用开发而设计。它基于 JetBrains 的 IntelliJ IDEA 软件，并在此基础上增加了大量针对 Android 开发的定制功能。Android Studio 通过提供一整套集成的开发工具，简化了 Android 应用的开发流程。
Android Studio 提供了一个内置的模拟器，即Android虚拟设备（Android Virtual Device，简称AVD），用于在开发过程中模拟Android设备。开发者可以在没有实际设备的情况下运行和测试应用程序。
对应用性能进行分析也是 Android Studio 的一大特色。它包含了用于评估应用性能的各种工具，如内存分析器、CPU使用情况监视器等，这有助于开发者发现和解决性能瓶颈问题。
版本控制工具也整合在 Android Studio 中，支持常见的版本控制系统如 Git，便于进行代码版本管理和团队合作。
下载： Android 开发者官网：https://developer.android.google.cn/?hl=zh-cn
点击下载 Android Studio 最新版（Hedgehog）：
安装： 下载完成后，直接双击打开：
Next -&gt;
这里我们先不选择虚拟机，Next -&gt;
这里我们自定义 Android studio 的安装路径（就是Android studio 安装到哪个位置），Next -&gt;
这里默认就行，点击 Install -&gt;
等待安装完成.......
安装完成！Next -&gt;
至此 Android Studio 已经安装完毕了，点击 Finish 打开 Android Studio
配置： 默认点击 OK -&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fd219046e7d69b4cfaeca3952e9712b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a57aba52fc8bb366e65b246341d2e6e2/" rel="bookmark">
			【Midjourney】聊聊五种常见的朋克风格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.赛博朋克(Cyberpunk) 赛博朋克（Cyberpunk）是一个科幻文学和艺术的亚流派，最初在20世纪80年代兴起。这个词汇结合了“赛博空间”（Cyberspace）和“庞克”（Punk）两个词，用来描述一种以高科技、网络化、未来主义为特征的科幻风格。
赛博朋克作品通常描绘了一个被大规模科技进步影响的未来社会。其中包含了虚拟现实、人工智能、网络黑客、生物工程等高度发展的科技元素。这些故事通常发生在一个充满矛盾、极端不平等的社会中，政府和大型企业对社会产生巨大的控制力。
比较有代表性的作品例如电影《银翼杀手》和游戏《赛博朋克2077》，事实上赛博朋克这一说法的普及与游戏《赛博朋克2077》本身的出现就有很大关系。
核心元素：黑客、人工智能、赛博空间、义体改造与生物改造、贫民窟、资本主义大企业。
标志符号：霓虹灯、药物、流水线工业生产、机械义体。
2.蒸汽朋克(Steampunk) 蒸汽朋克（Steampunk）是一种科幻和奇幻文学、艺术、电影以及时尚的次文化，其灵感来自19世纪末的维多利亚时代和工业革命时期。这个流派将当时的科技与蒸汽动力结合，创造出一种独特的风格，融合了古老的机械工艺和未来主义元素。
蒸汽朋克作品通常描绘了一个充满蒸汽机械、飞行器、时空机械、复杂的机械装置和奇异发明的世界。这个时期的技术水平被发展到了极致，但同时保留了古老的手工艺传统。蒸汽朋克的视觉元素包括黄铜、齿轮、蒸汽、古老的时钟和机械装置等。
代表作品例如电影《哈尔的移动城堡》中的城堡，和前几年爆火过一段时间的解密游戏游戏《机械迷城》
核心元素：蒸汽机、蒸汽义体、魔法。
标志符号：齿轮、钟表、压力阀、护目镜、礼服、热气球、发条。
3.柴油朋克(Dieselpunk) 柴油朋克（Dieselpunk）是一种次文化和艺术风格，灵感来自于20世纪20年代到40年代的柴油动力时代。这个流派与蒸汽朋克相似，都是以历史时期为基础，但柴油朋克更强调现代机械技术和石油动力(其实最大的区别就是蒸汽朋克用齿轮传动，而柴油朋克用管道)。这个术语通常用来形容那些设定在两次世界大战之间或类似时期的作品。
柴油朋克的特征包括使用柴油动力、内燃机、飞机、坦克等军事和工业元素，以及风格化的汽车、摩托车和服装。与蒸汽朋克不同，柴油朋克强调现代科技和工业化的影响，而不是蒸汽时代的蒸汽动力。
代表作品例如电影《疯狂的麦克斯》，以及游戏《德军总部》
核心元素：柴油机技术、世界大战。
标志符号：二战、神秘主义、柴油动力、钢铁、管道、废土场景与后启示录背景、炮塔。
4.原子朋克(Atompunk) 原子朋克（Atompunk）是一种次文化和艺术风格，灵感来自于20世纪40年代到60年代的原子时代，特别是核能的发展和科技乐观主义的兴起。这个流派强调科技的乐观展望，通常描绘了一个技术高度发达、拥有原子能驱动的飞行器、原子核动力的机器、以及高科技建筑的未来世界。
原子朋克与蒸汽朋克和柴油朋克类似，都是以历史时期为基础的次文化。然而，原子朋克更关注核能技术和原子科学的应用，反映了20世纪中叶对原子能的广泛应用和对未来科技的极大乐观信心。
说起原子朋克，大家第一个想到的应该是游戏《原子之心》，说实话这个词语也确实是随着这款游戏的爆火普及开的，不过《原子之心》其实严格意义上来讲并不完全是原子朋克，因为其世界观背景的基础并不是核能，而是“聚合物”。
核心元素：核能、集权社会、未知力量、无人区。
标志符号：一些苏联美学风格元素、原子武器。
5.真空管朋克(Transistorpunk) "真空管朋克"（Transistorpunk）是一个相对较新的次文化和艺术风格，灵感来源于20世纪中叶至末期，尤其是电子晶体管的发明和普及的时代。与蒸汽朋克、柴油朋克和原子朋克一样，真空管朋克将历史时期作为基础，但侧重于电子技术和信息时代的发展。
真空管朋克的特征包括对电子设备和信息技术的独特诠释，通常包括早期的计算机、电子器件、原始的计算机网络等。这个风格可能展现出对数字化革命的怀旧感，以及对当时对未来的科技发展的乐观主义。
由于这一风格还没发展几年真空管就被更为先进的晶体管取代了，新出现的计算机上也不再带有像灯泡一样的真空管，所以这一风格的作品较少，且风格范围也很难界定，比较有代表性的例如游戏《辐射》系列的终端机和BB小子，以及《红色警戒》系列中尤里的部分科技。
标志符号:特定的60年代美式审美风格、镀铬技术、真空管、二代计算机、原子能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a07b8202d0cb38a8e987c7a1787e523a/" rel="bookmark">
			springframework.web.servlet.resource.NoResourceFoundException: No static resource favicon.ico.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot 单体项目已请求接口就报这个错误，问题是spring boot没有找到favicon.ico图片资源，所以就抛出了这个异常，很鸡肋，不处理看着难受，处理的话又找不到原因。1、随便找一张图片，命名为favicon.ico
2、在项目resources创建static文件夹，把favicon.ico放到文件夹里面。
3、clear maven ，重新启动项目。这里有个小坑，需要彻底地重新加载资源，很多时候是放进去试一下，好像不不行，就认为这个方法不行（我就是这样）
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/516/">«</a>
	<span class="pagination__item pagination__item--current">517/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/518/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>