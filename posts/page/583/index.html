<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca1f07aad4ea38855270cd2dfc592d8d/" rel="bookmark">
			python做学生信息管理系统,python学生信息管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，小编来为大家解答以下问题，用python写学生信息管理系统包括数据保存和读取，python编写学生管理系统,用gui做ui，今天让我们一起来看看吧！
一、系统简介 实现一个学生信息的管理系统：主要功能有：
添加学生信息
删除学生信息
修改学生信息
查询学生信息
显示学生信息
退出当前系统
二、步骤分析 显示功能界面
用户输入功能序号
对不同序号的功能实现具体函数（3.1 定义函数、3.2 调用函数）
三、需求实现 显示功能界面 info_print()
用户输入功能序号 user_num = eval(input('请输入功能序号：'))
按照用户输入的功能序号，执行不同的功能(函数)
添加学生信息 add_info()
删除学生信息 del_info()
修改学生信息 modify_info()
查询学生信息 search_info()
显示学生信息 print_all()
四、具体实现 系统功能需要循环使用，直到用户输入6，才退出系统 功能界面部分：
# 定义一个函数 def info_print(): print('--------请选择功能-----') print('1、添加学生') print('2、删除学生') print('3、修改学生') print('4、查询学生') print('5、显示所有学生') print('6、退出系统') print('-' * 20) # 等待存储所有学生的信息 info = [] 主要部分代码：
while True: # 1、显示功能界面 info_print() # 2、用户输入功能序号 user_num = eval(input('请输入功能序号：')) # 3、按照用户输入的功能序号，执行不同的功能(函数) # 如果用户输入1，就执行添加学生的功能 if user_num == 1: # print('添加学生') elif user_num == 2: # print('删除学生') elif user_num == 3: # print('修改学生') elif user_num == 4: # print('查询学生') elif user_num == 5: # print('显示所有学生') elif user_num == 6: exit_flag = input("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca1f07aad4ea38855270cd2dfc592d8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b26efdac981972dcaa5ed38eb30d88b/" rel="bookmark">
			web播放rtsp流视频，使用webrtc毫秒级延迟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、zlmediakit环境搭建和编译
1)、下载zlmediakit
2)、安装依赖
3)、编译webrtc
4)、启动zlmediakit
二、播放webrtc视频
1)、动态添加拉流代理
2)、播放视频 三、嵌入到自己的vue项目中。
1)、拷贝demo到自己的vue项目中
2)、mkcert生成证书
背景：需要在web应用中播放摄像头的rtsp流视频，并且延迟需要做到1秒以内。试过网上很多方法，都不能做到1秒内的延迟，可能有这种方案，只是我还没找到。所以我尝试了使用zlmediakit的webrtc功能进行播放。效果不错，视频画面很实时，目前只做了初步尝试，实际应用还需要研究。下面是我的步骤：
系统：在ubuntu20.04和树莓派的raspberrypi系统都有尝试。
一、zlmediakit环境搭建和编译 1)、下载zlmediakit #下载代码 git clone https://github.com/ZLMediaKit/ZLMediaKit.git cd ZLMediaKit #千万不要忘记执行这句命令 git submodule update --init 2)、安装依赖 gcc #一般系统都会自带gcc,可以使用命令gcc -v 查看版本 #如果没有的话使用以下命令安装 sudo apt-get install build-essential cmake #先查看系统有没有已经安装 cmake --version #没安装就使用以下命令安装 sudo apt-get install cmake openssl #首先查看是否已经安装 openssl version #没安装使用以下命令安装 sudo apt-get install libssl-dev 3)、编译webrtc 编译libsrtp #依次执行以下命令 git clone https://gitee.com/mirrors/cisco-libsrtp.git cd cisco-libsrtp ./configure --enable-openssl make -j4 sudo make install 编译Zlmediakit 回到zlmediakit目录下 #依次执行以下命令 mkdir build cd build cmake -DENABLE_WEBRTC=on .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b26efdac981972dcaa5ed38eb30d88b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/378f744ac24b61417909b3284856187f/" rel="bookmark">
			推荐几款实用的Google浏览器插件（各种翻译）——AI时代 实现 无障碍阅读各种英文网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐几款实用的Google浏览器插件（各种翻译）——AI时代 实现 无障碍阅读各种英文网站 1. 阅读翻译插件1.1 Google 翻译1.2 DeepL翻译（适合大段落） 2. 视频字幕翻译插件2.1 YouTube™ 双字幕2.2 Dualsub——实现双字幕 3. 评论翻译插件3.1 油管评论翻译机 4. 更高级、更AI的翻译4.1 沉浸式翻译: 双语对照网页翻译 &amp; PDF文档翻译4.2 AI沉浸翻译和YouTube/Netflix双字幕 - Trancy4.2.1 安装插件 Trancy4.2.2 使用插件 Trancy4.2.2.1 Trancy 支持网页翻译4.2.2.2 Trancy支持视频双字幕 4.3 基于Chatgpt 的 Monica4.3.1 安装，简介4.3.2 简单使用4.3.2.1 简单翻译4.3.2.2 简单对话 5. Infinity 新标签页 (Pro)6. 附加其他6.1 Octotree - GitHub code tree 1. 阅读翻译插件 1.1 Google 翻译 下载：
体验如下，阅读即翻译：
1.2 DeepL翻译（适合大段落） 之前用Google 翻译，后来发现DeepL翻译挺不错的，主要是如果篇幅大的段落的话也可以不离开浏览器本页直接翻译。安装
体验
2. 视频字幕翻译插件 2.1 YouTube™ 双字幕 这个好像是针对原本支持双字幕的视频可以，反正我这边看的视频要么是自动英语，要么可以翻译，但是只能单字幕，双字幕按钮不可点，所以我选下面的 Dualsub插件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/378f744ac24b61417909b3284856187f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b79a233beb99bec5bef554b8025883e/" rel="bookmark">
			【SpringMVC】基于 Spring 的 Web 层MVC 框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎄欢迎来到@边境矢梦°的csdn博文🎄
🎄本文主要梳理SpringMVC : 基于 Spring 的 Web 层MVC 框架 🎄
🌈我是边境矢梦°，一个正在为秋招和算法竞赛做准备的学生🌈
🎆喜欢的朋友可以关注一下🫰🫰🫰，下次更新不迷路🎆
Ps: 月亮越亮说明知识点越重要 (重要性或者难度越大)🌑🌒🌓🌔🌕 目录
📢MVC模式
📌MVC 的工作流程
📌MVC 的优点
📌MVC 的不足
🎉Spring MVC：构建强大的Web应用程序
🎄什么是Spring MVC？
🎄SpringMVC的特征
🎄Spring MVC的工作原理
🌈SpringMVC工作流程
🎄Spring MVC 的常用组件
🌸@Controller和@RequestMapping注解
🌳@Controller 注解
🌳@RequestMapping 注解
🌻@RequestMapping 注解的使用方式
🌻@RequestMapping 注解的属性
🌻支持 Ant 风格的路径
C语言中文网：C语言程序设计门户网站(入门教程、编程软件) (biancheng.net) 学习笔记
📢MVC模式 MVC 模式，全称为 Model-View-Controller（模型-视图-控制器）模式，它是一种软件架构模式，其目标是将软件的用户界面（即前台页面）和业务逻辑分离，使代码具有更高的可扩展性、可复用性、可维护性以及灵活性。
MVC 模式将应用程序划分成模型（Model）、视图（View）、控制器（Controller）等三层，如下图所示。
分层描述Model（模型）它是应用程序的主体部分，主要由以下 2 部分组成： 实体类 Bean：专门用来存储业务数据的对象，它们通常与数据库中的某个表对应，例如 User、Student 等。业务处理 Bean：指 Service 或 Dao 的对象，专门用于处理业务逻辑、数据库访问。
一个模型可以为多个视图（View）提供数据，一套模型（Model）的代码只需写一次就可以被多个视图重用，有效地减少了代码的重复性，增加了代码的可复用性。View（视图）指在应用程序中专门用来与浏览器进行交互，展示数据的资源。在 Web 应用中，View 就是我们常说的前台页面，通常由 HTML、JSP、CSS、JavaScript 等组成。Controller（控制器）通常指的是，应用程序的 Servlet。它负责将用户的请求交给模型（Model）层进行处理，并将 Model 层处理完成的数据，返回给视图（View）渲染并展示给用户。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b79a233beb99bec5bef554b8025883e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36ec66fcb5f0b8c5f32005faa082f598/" rel="bookmark">
			数据结构之堆的结构与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、堆的概念及结构
1.1堆的概念
1.2堆的性质
1.3堆的结构
二、堆的实现
2.1堆向下调整算法（父亲与孩子做比较）
2.2堆的向上调整算法（孩子与父亲做比较）
2.3堆的创建（向下建堆）
2.4向下建堆的时间复杂度
2.5堆的插入
2.6堆的删除
2.7堆的完整代码实现
三、堆的应用
3.1堆排序
3.2TOP-K问题
一、堆的概念及结构 1.1堆的概念 1.2堆的性质 堆中某个节点的值总是不大于或不小于其父节点的值； 堆总是一棵完全二叉树。
1.3堆的结构 二、堆的实现 2.1堆向下调整算法（父亲与孩子做比较） 我们给出一个数组，逻辑上看做一颗完全二叉树。我们通过从根节点开始的向下调整算法可以把它调整成一个小堆。向下调整算法有一个前提：左右子树必须是一个堆，才能调整。 以下面图片为例：建小堆过程中父亲不断与较小的孩子交换 用代码来实现：
void AdjustDown(HPDataType* a, int n, int parent)//n是参与向下算法的元素的个数 { int child = parent * 2 + 1; while (child &lt; n) { //建小堆，找到两个孩子中较小的那一个 if (child + 1 &lt; n &amp;&amp; a[child + 1] &lt; a[child]) { child++; } //如果父亲不比孩子大，就证明已经是小堆了，直接跳出循环； //如果比孩子大就一直交换 if (a[child] &lt; a[parent]) { Swap(&amp;a[child], &amp;a[parent]); parent = child; child = parent * 2 + 1; } else break; } } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36ec66fcb5f0b8c5f32005faa082f598/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f0eba802389f32eb85f1f3db1a4d0eb/" rel="bookmark">
			stable diffusion model训练遇到的问题【No module named ‘triton‘】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一天早晨过来，发现昨天还能跑的diffusion代码，突然出现了【No module named ‘triton’】的问题，导致本就不富裕的显存和优化速度雪上加霜，因此好好探究了解决方案。
首先是原因，由于早晨过来发现【电脑重启】导致了【训练终止】（美好的心情从看到windows更新结束），基本可以判定是由于windows更新，以及所编译的triton的windows版本的原因，最终解决方案如下：
1、第一步，按顺序卸载triton、xformers、torch
pip uninstall triton pip uninstall xformers pip uninstall torch 2、第二步，利用huggingface上直接下载到本地的triton-2.0.0-cp310-cp310-win_amd64.whl进行pip安装，安装triton。具体的windows下编译好的triton的网址为 https://huggingface.co/datasets/ArrayCats/triton-2.0.0-cp310-cp310-win_amd64/resolve/main/triton-2.0.0-cp310-cp310-win_amd64.whl
pip install triton-2.0.0-cp310-cp310-win_amd64.whl 3、第三步，安装xformers
pip install xformers 4、第四步，在安装triton时，下载的torch为cpu版本，无法运用cuda和xformers，因此根据卸载前的版本或者xformers的报错，安装对应版本的torch，我个人所需要的是torch==2.0.1+cu118，所以在pytorch官网的安装命令上进行了修改，指定了torch版本
pip3 install torch==2.0.1+cu118 torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7f1010e967de1bd2a0718baa16fbd56/" rel="bookmark">
			Java之String类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者简介： zoro-1，目前大二，正在学习Java，数据结构等
作者主页： zoro-1的主页
欢迎大家点赞 👍 收藏 ⭐ 加关注哦！💖💖
Java之String类 String的构造String底层String之间的比较比较内容比较地址 字符串查找相关方法代码演示 字符串转化数值类和字符串转化字符串大小写转化字符串转数组字符串格式化 字符串替换字符串拆分字符串截取字符串的其他操作方法重点:为什么字符串是不可变的字符串的修改 String的构造 public static void main(String[] args) { // 使用常量串构造 String s1 = "hello bit"; System.out.println(s1); // 直接newString对象 String s2 = new String("hello bit"); System.out.println(s1); // 使用字符数组进行构造 char[] array = {'h','e','l','l','o','b','i','t'}; String s3 = new String(array); System.out.println(s1); } String底层 String是引用类型，内部并不存储字符串本身，在String类的实现源码中，String类实例变量如下
public static void main(String[] args) { // s1和s2引用的是不同对象 s1和s3引用的是同一对象 String s1 = new String("hello"); String s2 = new String("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7f1010e967de1bd2a0718baa16fbd56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e387dd5164a23e810d1b74477deb3aa/" rel="bookmark">
			如何在本地 Linux 主机上实现 Yearning SQL 审核平台的远程访问？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. Linux 部署Yearning2. 本地访问Yearning3. Linux 安装cpolar4. 配置Yearning公网访问地址5. 公网远程访问Yearning管理界面6. 固定Yearning公网地址 前言 Yearning 简单, 高效的MYSQL 审计平台 一款MYSQL SQL语句/查询审计工具，为DBA与开发人员使用.本地部署，注重隐私，简单高效的MYSQL审计平台。
下面介绍Linux 简单部署Yearning 并结合cpolar 内网穿透工具实现远程访问,破除访问限制,提高工作效率!!
1. Linux 部署Yearning 在Github上下载对应的Linux 安装包:https://github.com/cookieY/Yearning/releases/latest
下载后把安装包上传到Linux 中,这里上传到/usr/local文件夹下面
然后解压文件
unzip 文件名 解压后可以看到一个名叫Yearning 的文件夹,
进入Yearning文件夹,可以看到配置文件:conf.toml
接下来需要修改配置文件,配置mysql数据库连接,如未安装mysql 需提前安装好,然后登录mysql,创建一个名字叫,Yearning的数据库!
然后编辑配置文件:
vim conf.toml 设置连接mysql的信息,主要是设置连接mysql用户名和密码
设置完成保存配置文件,执行下面命令进行安装,注意,当前目录必须保持在解压的Yearning文件夹中.
./Yearning install 执行后,可以看到如下信息,登陆web 界面的用户名和密码,还有访问web 界面的端口:8000
然后运行Yearning,当然,这个命令我们可以使用nohup 在后台运行
nohup ./Yearning run &amp; 2. 本地访问Yearning 上面我们运行Yearning后,在外部浏览器或者Linux内部浏览器访问web 界面8000端口即可看到Yearning登录界面,本地访问成功了
输入上面我们看到的用户名密码即可登陆成功,本地访问确认无误后,接下来我们安装cpolar 内网穿透工具,配置实现远程访问Yearning.
3. Linux 安装cpolar 上面我们成功安装了Yearning,下面我们在Linux安装cpolar内网穿透工具,通过cpolar 转发本地端口映射的http公网地址,我们可以很容易实现远程访问,而无需自己注册域名购买云服务器.下面是安装cpolar步骤
cpolar官网地址: https://www.cpolar.com
使用一键脚本安装命令 curl -L https://www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash 向系统添加服务 sudo systemctl enable cpolar 启动cpolar服务 sudo systemctl start cpolar cpolar安装成功后，在外部浏览器上访问Linux 的9200端口即:【http://局域网ip:9200】，使用cpolar账号登录,登录后即可看到cpolar web 配置界面,结下来在web 管理界面配置即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e387dd5164a23e810d1b74477deb3aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4323ab3380fcb72981be18220811396a/" rel="bookmark">
			【Redis】Redis 的学习教程（十）之使用 Redis 实现消息队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		消息队列需要满足的要求：
顺序一致：要保证消息发送的顺序和消费的顺序是一致的，不一致的话可能会导致业务上的错误消息确认机制：对于一个已经被消费的消息(已经收到ACK)不能再次被消费消息持久化：要具有持久化的能力，避免消息丢失，这样当消费者异常宕机导致再次重启后需要重新消费消息时可以再次获取 Redis 提供了三种不同的方式来实现消息队列：
list 结构：基于 list 结构模拟消息队列pubsub：点对点消息模型stream：比较完善的消息队列模型 1. 基于 list 结构 因为 list 底层的实现就是一个「链表」，在头部和尾部操作元素，时间复杂度都是 O(1)，这意味着它非常符合消息队列的模型
如果你的业务需求足够简单，想把 Redis 当作队列来使用，肯定最先想到的就是使用 list 这个数据类型
常用的命令：
lpush：发布消息rpop：拉取消息brpop：阻塞拉取消息 生产者：
消费者：
这个模型非常简单，如下图：
当队列中已经没有消息了，消费者在执行 RPOP 时，会返回 NULL
我们在编写消费者逻辑时，一般是一个「死循环」，这个逻辑需要不断地从队列中拉取消息进行处理，伪代码一般会这么写：
while true: msg = redis.rpop("queue") // 没有消息，继续循环 if msg == null: continue // 处理消息 handle(msg) 问题 1：如果此时队列为空，那消费者依旧会频繁拉取消息，这会造成「CPU 空转」，不仅浪费 CPU 资源，还会对 Redis 造成压力
怎么解决这个问题呢？
当队列为空时，我们可以「休眠」一会，再去尝试拉取消息。代码可以修改成这样：
while true: msg = redis.rpop("queue") // 没有消息，休眠2s if msg == null: sleep(2) continue // 处理消息 handle(msg) 这就解决了 CPU 空转问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4323ab3380fcb72981be18220811396a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3b0340396594a6bf0e05e24ec50473b/" rel="bookmark">
			腾讯轻联：带你创造属于自己的AI小助手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		陈老老老板🤴 🧙‍♂️本文专栏：生活（主要讲一下自己生活相关的内容）生活就像海洋,只有意志坚强的人,才能到达彼岸。 🧙‍♂️本文简述：参加腾讯全球数字生态大会，了解到腾讯轻联企业级集成平台，很好玩的工具，给大家讲解一下 🧙‍♂️上一篇文章： 年度总结-你觉得什么叫生活？ 🦹有任何问题，都可以私聊我，在文章最后也可以加我的wx。感谢支持！ 🦹我认为人人都可以学好编程，我愿意成为你的领路人！ 文章目录 🎅前言一、腾讯轻联介绍二、3分钟带你实现营养分析AI小助手1.注册并登录轻联2.新建流程并配置腾讯问卷3.配置MiniMax4.配置腾讯邮箱 三、真正优势优势1.应用集成优势2.数据集成优势3.零/低代码实现API生命周期管理优势4.云环境部署 🤶总结 🎅前言 随着互联网的不断发展，AIGC技术的成熟，对于一家企业来说，如何更好地实现工作中与AI的融合是企业发展的关键，如何能将AI在工作中与员工实现相辅相成是企业值得思考的问题。随着AI引入到应用中，一切工作都变得高效、方便。AI智能应用可以极大地减少技术水平不高、重复性高的工作。比如，现在不用再像以前那样去浏览器中搜索资料，再逐条辨别，只需要与AI对话即可获得所有想知道的知识。再也不用因为找不到文案而发愁，向AI提问便有无数条新奇思路提供给我们。再也不会因为需要优化资料而苦恼，发送给AI，它会帮我们找出需要优化的部分，不再需要做这些繁琐的工作。
很荣幸能被邀请参加腾讯全球数字生态大会2023，作为国际性会议，此次会议以“智变加速,产业焕新”为主题，全方位展示腾讯数字孪生核心技术能力、产品矩阵升级、落地实践及生态合作建设。大会中所提及的众多产品，对于云计算、大数据、人工智能等信息技术的发展起到了推动作用，充分展示了互联网领域蓬勃发展的景象。而在这些产品之中，有一个眼前一亮并对并与AI结合这么轻便、高效的产品——🪐腾讯轻联🪐 ：可联万物，让万物成为专属的生态。
一、腾讯轻联介绍 介绍： 腾讯轻联是一款企业级云集成服务平台，通过无代码或低代码的方式将企业内外部间不同的系统或业务连接到一个统一的平台中，非常轻松实现应用间的交互，实现自动化办公，极大地提高工作效率，降低工作成本。同时还能通过监控统计实时查看运行情况，通过运行日志排查运行问题。满足客户轻量级、全方位、高灵活的一体化系统集成需求，真正做到省心、放心、舒心办公，将自动化办公做到极致，为企业打造一支现代化、信息化、数字化的工作团队。可联万物，一切皆有可能！
官方地址：腾讯轻联官方地址
二、3分钟带你实现营养分析AI小助手 说明： 腾讯轻联与国内大模型创业公司MiniMax的合作简直是一个创举，为使用者提供了更多的使用思路，发现原来连接AI实现办公这么简单，可谓：小母牛坐飞机-牛逼上天了。😀想问实现小助手需要几步，答三步：1.配置腾讯问卷，2.配置MiniMax，3.配置腾讯邮箱
3分钟带大家实现一个营养分析助手，再也不用担心吃的不健康，不知道吃什么，天天不重样，让营养分析小助手来帮你！！只需填问卷，就能发送到个人邮箱，一键到达！
实现目标：通过身高、体重、口味、忌口食物、特殊病例、过敏食物这几点，完成一份一日三餐的菜单，并展示卡路里；
实现准备：腾讯问卷、MiniMax、腾讯邮箱
1.注册并登录轻联 说明： 非常简洁的页面，大家直接通过微信注册就好，现在有90天享受pro版哦！！速来体验
有非常多的模板供大家使用，全方位、多领域、宽层次实现功能全覆盖，包括8大职能（市场、销售、HR、运营、运维、产研、财务、行政），6大场景（消息通知、数据收集、私域营销、工作效率、数据同步、定时任务）
2.新建流程并配置腾讯问卷 说明： ⌛第一步配置腾讯问卷，先添加腾讯问卷到触发事件，触发条件为新的文件提交时。
接着需要配置腾讯问卷账号，这里我展示是我配好的账号。
接下来设置腾讯问卷中问卷的问题与格式，需要时团队问卷，问卷内容为：身高、体重、忌口食物、口味、过敏食物、特殊疾病、收件人邮箱地址，除了邮箱地址外其他参数都会传递给MiniMax进行问答。
点左上角退出编辑，再分享问卷。自己填一下问卷，再点击测试并预览，可以发现测试结果显示成功，已经完成了第一步🌞
3.配置MiniMax 说明： ⌛第二步配置MiniMax，先将MiniMax添加到执行操作，并点击操作条件为对话。
再配置账号，这里需要开发者ID与接口密钥。
这两个参数我们去MiniMax中找，注册MiniMax点击右上角账户设置，再点击接口密钥，再点击创建新密钥，输入一个名字就可以了，记得保存密钥，之后就看不到了。
这里用户信息我设置的是：你是一个营养分析师，你的任务是分析和考虑这个人的身高、体重、口味、忌口食物，生成一个适当、详细的一日早中晚三餐菜单，展示每餐的具体卡路里数与总卡路里数与注意事项，最后提出健康建议，五次回答不一样的菜。
这个人的具体情况如下：身高，体重，忌口食物，食物过敏，特殊疾病。
参数是一对一的关系，点击参数就能进行设置，temperature我建议设置为0.01，token数为2000，用户输入可以自己更改，来调教大模型😁
再点击测试并浏览，发现测试成功，这就完成第二步了🌞
4.配置腾讯邮箱 说明： ⌛第三步配置腾讯邮箱，也超级简单，插入应用为腾讯邮箱，执行操作为发送邮件。
配置邮箱账号，这里需要找到邮箱的授权码
补充： 获取授权码方法：登录邮箱点击右上角设置，再常规中找到第三方服务，生成授权码即可
再进行参数配置，收件人邮箱地址选择为问卷中的收件地址，文本信息选择为MiniMax的返回Date内容，我们再点击测试并浏览，发现会给收件人发送邮件。营养分析Ai小助手就完成啦！大功告成，是不是超级简单！💥
再点击右上角的上线流程，所有的小伙伴就都可以体验，太有趣了！！我要给我的创意打100分！！
三、真正优势 优势1.应用集成 腾讯轻联最具优势的一点是提供超级丰富的应用集成环境，提供500+的应用资源，实现链接无障碍，使用超简单。涵盖15大应用场景供企业选择，实现场景的便捷转化，也为企业提供了更多的可选项，不再为找不到应用而发愁，进而实现全领域自动化办公。能够将企业内部以及企业之间的各种It支持系统集成起来，以便实现信息互通和资源共享，从而提高企业的办公效率，降低企业运营的操作成本。
优势2.数据集成 对于企业来说，如何有效整合数据对企业的发展至关重要。当然，要实现信息的汇集以及数据的组合，并非是一件容易的事情。因为我们生活在一个数据化的时代，生活和工作中的点点滴滴都会在网络上留下数据信息。如果一个企业不具备强大的数据集成能力，那么这会增加技术人员的工作量，以及企业的运营成本。而腾讯轻联具有多源异构数据采集、数据清洗和数据治理的功能，能够将企业内部甚至企业外部的诸多数据实现轻松整合，同时使用AES-128的对称加密算法，数据全链路加密传输，腾讯云高等级安全防护，多租户沙箱隔离机制，增加企业使用的安全性。
优势3.零/低代码实现API生命周期管理 “低代码”指的是企业开发人员可以使用标准化的低代码产品和服务，通过在界面化和可视化的配置操作完成应用构建。腾讯轻联零/低代码实现API生命周期管理，低代码能够极大地减少员工的工作量。同时具备分类、检索、关注、测试功能，支持应用维度或者业务维度统一管理，使企业使用更加轻松。支持API可视化管理，使用起来更加清晰，同时API的设计、发布、审核、运行、发布、下线等功能，使用起来更加灵活、高效。
优势4.云环境部署 可能很多小伙伴不太明白为什么现在很多东西都是再往“云”上发展，上云代表不再会有本地资源的束缚，无论什么时间、地点，只要有网就可以干你想干的事情。随着云技术的不断发展与优化，企业产品上云，已经成为了一种不可阻挡趋势，上“云”将会大大降低成本，减少硬件设备的采购，而且更加稳定不会出现断电等情况，而且整体的效率更高，无拘无束。腾讯轻联设计时就已经察觉到了这一点，直接实现公、私有云环境部署，架构扩展十分灵活，更加安全可靠。
🤶总结 腾讯全球数字生态大会2023作为全球性的盛会，开阔了我的眼界，增加了大众对于前沿领域技术的了解，这也是应用与数据集成平台市场的一大进步。同时对腾讯轻联的使用，让我第一次直观地感受到应用与数据集成平台市场的繁荣景象，这也为未来走向国际打下了坚实的基础，作为新一代的领军者，希望能继续创新，不断完善。愿国产软件越做越好！
总结：本篇讲的腾讯轻联的介绍与使用，希望对您有帮助
结束语：裸体一旦成为艺术，便是最圣洁的。道德一旦沦为虚伪，便是最下流的。
勇敢去做你认为正确的事，不要被世俗的流言蜚语所困扰。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0663cc3c5f27b6b3b79b710a4dbf70d/" rel="bookmark">
			多目标跟踪MOT技术总结（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：本人作为MOT领域新人，目前已经阅读一定量和质量的paper，尽可能的将这些MOT算法按照不同的技术路径进行分类（2016 SORT之后），并且只对论文的方法做一个大概的总结，具体细节请参照原文，如果有理解不到位的地方欢迎指出，同时也希望同方向的小伙伴一起学习交流~~
什么是MOT？ 为了完成目标跟踪任务，首先需要将目标定位在一帧中，给每个目标分配一个单独的唯一id，然后在连续帧中的同一个目标将生成一条轨迹。当跟踪多个目标时，称为多目标跟踪。
MOT在应用场景上分为二维多目标跟踪和三维多目标跟踪；其中，三维较二维多增加了深度信息和角度信息。在传感器方面，三维分为单目、双目（图像，伪点云）以及激光雷达（点云），二维为相机。在算法技术方面，多数三维MOT依赖于现有的二维MOT算法进行优化改进。
MOT 是一项关键的视觉感知任务，需要解决不同的问题，例如拥挤场景中的长短时遮挡、相似外观、小目标检测困难、ID切换、速度突变等。为了应对这些挑战，研究人员尝试利用transformer的注意力机制、利用图卷积神经网络获得轨迹的相关性、不同帧中目标与Siamese网络的外观相似性，还尝试了基于简单 IOU 匹配的 CNN 网络、运动预测的 LSTM等方法。
本篇技术总结主要是针对主流的CNN网络这一条脉络，对主流算法进行分类，并按照相关性顺序进行总结。由于大多数二维、三维MOT算法思想大同小异，且可以迁移使用，本文将一并做介绍，为后续研究提供发散性的参考思路。
一、评价指标（目前还没总结完，之后会补充） 1、二维评价指标 MT：Mostly Tracked trajectories，成功跟踪的帧数占总帧数的80%以上的GT轨迹数量
Fragments：碎片数，成功跟踪的帧数占总帧数的80%以下的预测轨迹数量
ML：Mostly Lost trajectories，成功跟踪的帧数占总帧数的20%以下的GT轨迹数量
False trajectories：预测出来的轨迹匹配不上GT轨迹，相当于跟踪了个寂寞
ID switches：因为跟踪的每个对象都是有ID的，一个对象在整个跟踪过程中ID应该不变，但是由于跟踪算法不强大，总会出现一个对象的ID发生切换，这个指标就说明了ID切换的次数，指前一帧和后一帧中对于相同GT轨迹的预测轨迹ID发生切换，跟丢的情况不计算在ID切换中。
FP：总的误报数量，即整个视频中的FP数量，即对每帧的FP数量求和
FN：总的漏报数量，即整个视频中的FN数量，即对每帧的FN数量求和
Fragm（FM）：总的fragmentation数量，every time a ground truth object tracking is interrupted and later resumed is counted as a fragmentation，注意这个指标和Fragments有点不一样
IDSW：总的ID Switch数量，即整个视频中的ID Switch数量，即对每帧发生的ID Switch数量求和，这个和Classical metrics中的ID switches基本一致
MOTA：注意MOTA最大为1，由于IDSW的存在，MOTA最小可以为负无穷。
MOTP：衡量跟踪的位置误差，其中t表示第t帧，Ct表示第t帧中预测轨迹和GT轨迹成功匹配上的数目，dt,i表示t帧中第i个匹配对的距离。这个距离可以用IOU或欧式距离来度量，IOU大于某阈值或欧氏距离小于某阈值视为匹配上了。可以看出来MOTP这个指标相比于评估跟踪效果，更注重检测质量。
IDP：识别精确度 (Identification Precision) 是指每个行人框中行人 ID 识别的精确度。
IDR：识别召回率 (Identification Recall) 是指每个行人框中行人 ID 识别的召回率
IDF1：Identification F1，是IDP和IDR的调和均值，表示的是一条轨迹正确跟踪的时间
FPS：Frames Per Second，每秒处理的帧数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0663cc3c5f27b6b3b79b710a4dbf70d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63b5901abc414f36c1216ebaeb3a329a/" rel="bookmark">
			【初阶数据结构】树结构与二叉树的基础概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		君兮_的个人主页 勤时当勉励 岁月不待人 C/C++ 游戏开发 Hello,米娜桑们，这里是君兮_，今天带来数据结构里的重点内容也是在笔试，面试中的常见考点——树与二叉树，其中二叉树又分为很多种，我们先来讲讲基础的内容带大家一步步入门
二叉树与其遍历 一 树的概念及其结构1. 树结构中的相关概念2. 树的表示 二 什么是二叉树？1 概念2 特殊的二叉树3 二叉树的性质4 二叉树在内存中的存储顺序存储链式存储 5 二叉树的遍历 总结 一 树的概念及其结构 在介绍二叉树之前，我们得先知道什么是树结构，以及几个常用的概念
树是一种非线性的数据结构，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的集合。把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。树有一个特殊的结点，称为根结点，根节点没有前驱结点
除根节点外，其余结点被分成M(M&gt;0)个互不相交的集合T1、T2、……、Tm，其中每一个集合Ti(1&lt;= i&lt;= m)又是一棵结构与树类似的子树。每棵子树的根结点有且只有一个前驱，可以有0个或多个后继因此，树是递归定义的
1. 树结构中的相关概念 节点的度：
一个节点含有的子树的个数称为该节点的度； 如上图：A的为6叶节点或终端节点：
度为0的节点称为叶节点； 如上图：B、C、H、I…等节点为叶节点非终端节点或分支节点：
度不为0的节点； 如上图：D、E、F、G…等节点为分支节点双亲节点或父节点：
若一个节点含有子节点，则这个节点称为其子节点的父节点； 如上图：A是B的父节点孩子节点或子节点：
一个节点含有的子树的根节点称为该节点的子节点； 如上图：B是A的孩子节点兄弟节点：
具有相同父节点的节点互称为兄弟节点； 如上图：B、C是兄弟节点树的度：
一棵树中，最大的节点的度称为树的度； 如上图：树的度为6节点的层次：
从根开始定义起，根为第1层，根的子节点为第2层，以此类推；树的高度或深度：
树中节点的最大层次； 如上图：树的高度为4堂兄弟节点：
双亲在同一层的节点互为堂兄弟；如上图：H、I互为兄弟节点节点的祖先：
从根到该节点所经分支上的所有节点；如上图：A是所有节点的祖先子孙：
以某节点为根的子树中任一节点都称为该节点的子孙。如上图：所有节点都是A的子孙森林：
由m（m&gt;0）棵互不相交的树的集合称为森林 2. 树的表示 这里不是本篇博客要讲的重点，就简单介绍一种常用的孩子兄弟表示法 typedef int DataType; struct Node { struct Node* _firstChild1; // 第一个孩子结点 struct Node* _pNextBrother; // 指向其下一个兄弟结点 DataType _data; // 结点中的数据域 }; 二 什么是二叉树？ 1 概念 一棵二叉树是结点的一个有限集合，该集合:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63b5901abc414f36c1216ebaeb3a329a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b8c6f4f18a189f03890bc3a9da3ffbb/" rel="bookmark">
			JSP web入门：servlet的简单部署、创建与运行（2023版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、环境配置
1、java环境（安装JDK）
2、Tomcat环境
下载Tomcat
Windows下启动Tomcat服务器
若出现中文乱码问题：
3、ide选择
二、使用各种ide创建web项目
1、eclipse
（一）创建Dynamic Web Project
（二）配置Tomcat服务器
（三）添加jar依赖包
（四）编写代码
（五）运行
2、IDEA
（一）新建项目，选择好JDK
（二）给项目添加框架支持
（三）配置Tomcat服务器
（四）添加jar依赖包（servlet-api.jar）
（五）编写类
（六）修改web.xml文件
（七）运行
一、环境配置 1、java环境（安装JDK） 前往官网下载jdk：oracle官网
2、Tomcat环境 下载Tomcat 前往官网下载tomcat：tomcat 10 下载
下载后解压即用。
Windows下启动Tomcat服务器 双击【startup.bat】（~\pache-tomcat-10.1.13\bin\startup.bat）
浏览器输入：http://localhost:8080/ 或 http://127.0.0.1:8080/
关闭服务器：关闭DOS窗口，或双击【shutdown.bat】
若出现中文乱码问题： 原因：tomcat默认【utf-8】编码
修改：
1、记事本打开：【~\apache-tomcat-10.1.13\conf\logging.properties】
把 【java.util.logging.ConsoleHandler.encoding = utf-8】 改为 【java.util.logging.ConsoleHandler.encoding = GB2312】，保存，重启服务器即可
3、ide选择 eclipse（建议）：官网下载地址
idea
vscode、记事本（不给出过程）
二、使用各种ide创建web项目 1、eclipse （一）创建Dynamic Web Project （二）配置Tomcat服务器 点击【new runtime】，选择对应的Tomcat服务器
（三）添加jar依赖包 Tomcat中提供了【servlet-api.ja】r，我们直接使用tomcat中的jar包
位置：~\apache-tomcat-10.1.13\lib\servlet-api.jar
下面我们在eclipse中添加jar包依赖：
在项目中创建【lib】文件夹。可使用【WEB-INF】中自动生成的【lib】文件夹。将jar包复制到该文件夹中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b8c6f4f18a189f03890bc3a9da3ffbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68fb5b182aeddf2c1ec6b2a2ca9fa75c/" rel="bookmark">
			解决stable diffusion webui1.6 wd1.4 tagger加载失败的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 由于webui源码的变化，需要修改两个地方的import
1.tagger/ui.py # 第十行 # from webui import wrap_gradio_gpu_call # 原代码 from modules.call_queue import wrap_gradio_gpu_call 2.preload.py # 第4行开始 # from modules.shared import models_path # 原代码 from modules import paths # default_ddp_path = Path(models_path, 'deepdanbooru') # 原代码 default_ddp_path = Path(paths.models_path, "deepdanbooru") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c6d1fcb63915f0ea5c7935cb9b3d445/" rel="bookmark">
			数据结构——二叉树提升
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉树题型练习 前言一、节点个数以及高度等二、二叉树OJ题二叉树的前序遍历二叉树的中序遍历二叉树的后序遍历单值二叉树二叉树最大深度检查两颗树是否相同.翻转二叉树对称二叉树另一颗树的子树 总结 前言 现在我们开始一轮新的自我提升吧！
二叉树的题目当然也更有难度！
没有什么是生来就会的，尤其是代码这一方面
更是讲究熟能生巧，现在的我们学习代码编程就像婴儿学习灵活使用双手一般
相信以后的我们也可以像使用双手一般毫无困难地编写程序！
一、节点个数以及高度等 // 二叉树节点个数 int BinaryTreeSize(BTNode* root); // 二叉树叶子节点个数 int BinaryTreeLeafSize(BTNode* root); // 二叉树第k层节点个数 int BinaryTreeLevelKSize(BTNode* root, int k); // 二叉树查找值为x的节点 BTNode* BinaryTreeFind(BTNode* root, BTDataType x); size保存的是代码执行到当前位置符合条件的节点个数
1.节点个数代码实现
int TreeSize(BTNode* root) { static int size = 0; if (root == NULL) return 0; else ++size; TreeSize(root-&gt;left); TreeSize(root-&gt;right); return size; } 思路解析：
2.叶子节点个数代码实现
int TreeLeafSize(BTNode* root) { if (root == NULL) return 0; if (root-&gt;left == NULL &amp;&amp; root-&gt;right) { return 1; } return TreeLeafSize(root-&gt;left) + TreeLeafSize(root-&gt;right); } 思路解析：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c6d1fcb63915f0ea5c7935cb9b3d445/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fae43e98521084641369e566f6acfce/" rel="bookmark">
			动态规划：子序列问题（C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动态规划：子序列问题 前言子序列问题1.最长递增子序列（中等）2.摆动序列（中等）3.最长递增子序列的个数（中等）4.最长数对链（中等）5.最长定差子序列（中等）6.最长的斐波那契子序列的长度（中等）7.最长等差序列（中等）8.等差数列划分II - 子序列（困难） 前言 动态规划往期文章:
动态规划入门：斐波那契数列模型以及多状态动态规划：路径和子数组问题 子序列问题 1.最长递增子序列（中等） 链接：最长递增子序列
题目描述
做题步骤
状态表示
对于线性dp，我们通常采用下面两种表示:
(1)以某个位置为结尾，……
(2)以某个位置为起点，……
这两种方式我们通常采用第一种，以某个位置为结尾，再结合题目要求，我们可以定义状态表示为dp[i]：以i位置为结尾的所有子序列中，最长递增子序列的长度。
状态转移方程
对于以i位置为结尾的子序列，一共有两种可能：
(1)不接在别人后面，就自己一个，dp[i] = 1
(2)接在[0，1，2，……，i - 1]这些位置后面，设0 &lt;= j &lt;= i - 1，能保持子序列递增（nums[j] &lt; nums[i]）就可以接在该位置后面。
从0~i - 1枚举j，看接在那个位置后面长度最大：
即dp[i] = max(dp[i], dp[j] + 1)
初始化
每个位置最小都为1，全都初始化为1。
填表顺序
保证填当前状态时，所需状态已经计算过，填表顺序为从左往右。
返回值
没法直接确定最长子序列的结尾位置，一边dp一边更新最大值。
代码实现 class Solution { public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { int n = nums.size(); //dp[i]表示以i位置为结尾的最长递增子序列 vector&lt;int&gt; dp(n, 1); int ret = 1; for(int i = 1; i &lt; n; i++) { //从[0, i-1]看一圈，找接在那个符合条件的位置后面可以让子序列最长 for(int j = 0; j &lt; i; j++) if(nums[j] &lt; nums[i]) dp[i] = max(dp[i], dp[j] + 1); //看看能不能更新最大 ret = max(ret, dp[i]); } return ret; //时间复杂度：O(N ^ 2) //空间复杂度：O(N) } }; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fae43e98521084641369e566f6acfce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d028a3c1350fed56182b2f45da25912/" rel="bookmark">
			Centos7安装RabbitMQ与使用（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Centos7安装RabbitMQ 第一步、安装任何软件包之前，建议使用以下命令更新软件包和存储库
yum -y update 第二步、Erlang在默认的YUM存储库中不可用，因此您将需要安装EPEL存储库
yum -y install epel-release yum -y update 也可以去Erlang官网下载Erlang存储库https://packagecloud.io/rabbitmq/erlang?page=1，将下载好的rpm包防至Centos上
第三步、RabbitMQ是基于Erlang（面向高并发的语言）语言开发，所以在安装RabbitMQ之前，需要先安装Erlang语言
yum -y install erlang socat 第四步、检查Erlang版本，默认是最新版本
erl -version 第五步、下载RabbitMQ
wget https://github.com/rabbitmq/rabbitmq-server/releases/download/rabbitmq_v3_6_16/rabbitmq-server-3.6.16-1.el7.noarch.rpm 也可以直接去GitHub上下载https://www.rabbitmq.com/download.html，将下载好的rpm包放至Centos上
第六步、安装RabbitMQ
rpm -ivh rabbitmq-server-3.6.16-1.el7.noarch.rpm # 或者 rpm -Uvh rabbitmq-server-3.6.16-1.el7.noarch.rpm # -U表升级 第七步、安装管理界面的插件(没有这个插件无法启动管理界面)
# 开启管理界面 rabbitmq-plugins enable rabbitmq_management 第八步、开放5672和15672端口
firewall-cmd --zone=public --add-port=5672/tcp --permanent &amp;&amp; firewall-cmd --reload firewall-cmd --zone=public --add-port=15672/tcp --permanent &amp;&amp; firewall-cmd --reload 恭喜你，RabbitMQ现已经安装在系统上！
第九步、启动RabbitMQ服务
systemctl start rabbitmq-server #启动服务 systemctl status rabbitmq-server #查看服务状态 systemctl stop rabbitmq-server #停止服务 systemctl enable rabbitmq-server #开启启动服务 第十步、默认的账号密码仅限于本机 localhost 进行访问，所以需要添加一个远程登录的用户
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d028a3c1350fed56182b2f45da25912/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a83c964f3dd9488376ac3709fba59754/" rel="bookmark">
			【数据结构】结构实现：顺序存储模式实现堆的相关操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚩纸上得来终觉浅， 绝知此事要躬行。
🌟主页：June-Frost
🚀专栏：数据结构
🔥该文章着重讲解了使用顺序结构实现堆的插入和删除等操作。
目录： 🌍二叉树的顺序结构🔭 堆 🌏 代码实现✉️ 堆的插入✉️ 堆的删除✉️ 其他部分 ❤️ 结语 🌍二叉树的顺序结构 二叉树的顺序存储是指将二叉树中的所有节点按照一定的顺序（一层一层）存储到一个数组中。
我们可以通过数组下标来表示节点之间的父子关系。
找左孩子节点：leftchild = parent * 2 + 1
找右孩子节点：rightchild = parent * 2 + 2
例如，找B的左孩子 : B的下标 * 2 + 1，得到3 ，即为D。
找父亲节点：parent = （ child -1 ）/ 2
例如，找G的父母：（G的下标-1）/ 2 得到 2 ，即为C 。
需要注意的是，二叉树的顺序存储适用于满二叉树或完全二叉树的情况，对于其他类型的二叉树，顺序存储可能会造成空间浪费或访问效率低下的问题。
例如：
这类二叉树不适合顺序存储，适合链式存储。
🔭 堆 数据结构中还衍生出了一个结构 —— 堆 ， 堆是非线性结构，也是一种完全二叉树。堆的两个常见类型是大堆和小堆。在大堆中，父节点的值总是大于或等于其子节点的值；而在小堆中，父节点的值总是小于或等于其子节点的值。堆通常用数组来实现。
所以，对于任意一个数组是可以看作一颗完全二叉树，但不一定是堆。
🌏 代码实现 这里将实现堆的插入和删除，以小堆为例。
堆的结构特点是：存储结构——数组，逻辑结构——完全二叉树。所以可以定义结构体为：
typedef int HPDataType; typedef struct Heap { HPDataType* a; int size; int capacity; }HP; ✉️ 堆的插入 插入的需求为：无论如何插入，都必须保持为堆。因为存储结构是数组，所以选择效率更快的尾插，然后再进行调整（插入的数据会影响它的祖先）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a83c964f3dd9488376ac3709fba59754/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d8289a218f756ac99bdc5e0d96611c8/" rel="bookmark">
			02 java ---- Android 基础app开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
相对布局
显示一个美女
显示两个美女
安卓APP启动过程
安卓布局控件
常用布局之相对布局
常用布局之相对布局
padding和margin
按键美化 常用布局之线性布局
安卓按键响应的几种方式
直接设置按键的onClick绑定的函数
自定义类实现按键监听事件的接口
匿名内部类实现按键响应
mainActivity实现了oclick接口
页面跳转
如何跳转 Intent 配合onclick
如何传参 方式一 直接putExtra传参数
如何传参 方式二 通过Bundle搭配putExtras
安卓线程
Activity（页面）的生命周期 面试常考点
安卓网络编程
javaSocket服务端开发
JavaSocket 客户端开发：
安卓app中创建客户端连接java服务器
不能通过除UI外的线程去改变UI的控件 public TextView textview;
倒计时 Handler 、TextView、Message、 handler.sendMessage(msg);
socket客户端和按键显示输入输出流
网页创建 注意权限问题
智能家居页面
asserts: 存放一些资源，配置文件，图片
bin: 编译后会生成的一些文件，包括我们关心的apk
lib: 依赖库
res:
drawable:存放app程序要用到的一些图片
layout: 存放局文件的文件夹一般一个activity(安卓页面)对应一个布局
values: 存放一些参数，或者自定义控件的文件
AndroidMainfirst.xml: APP的配置权限：网络访问权限，名片夹访问权限，相机访问权限
目标机器SDK版本：APP的名字APP的图标 配置第一个被加载，启动页面
Laucher-&gt;mainifirst(执行数据初始化）-&gt;lauch（当app被按下）标签的activity被加载-&gt;oncreat被调用-&gt;java关联xml布局页面-&gt;显示-&gt;等待用户触摸等操作
相对布局 除了布局容器，您还可以使用布局属性来控制视图的布局行为，例如：
显示一个美女 控件的宽度
android:layout_width="match_parent"
控件的高度
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d8289a218f756ac99bdc5e0d96611c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7630eb540ffb7a8dab2ee403a159f5f/" rel="bookmark">
			【数据结构】二叉树的层序遍历（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一，层序遍历概念
二，层序遍历的实现
1，层序遍历的实现思路
2，创建队列
Queue.h
Queue.c
3，创建二叉树
BTree.h
BTree.c
4，层序遍历的实现
一，层序遍历概念 层序遍历：除了先序遍历、中序遍历、后序遍历外，还可以对二叉树进行层序遍历；
设二叉树的根节点所在层数为1，层序遍历就是从所在二叉树的根节点出发，首先访问第一层的树根结点，然后从左到右访问第2层上的结点，接着是第三层的结点，以此类推，自上而下，自左至右逐层访问树的结点的过程就是层序遍历。
二，层序遍历的实现 1，层序遍历的实现思路 层序遍历：按照每一行从左到右对二叉树的各个结点进行访问
但是呢，对一层访问结束了该如何访问下一层呢？就拿上图举例，访问完（4）结点后该如何访问（3）结点呢？（4）结点中并没有（3）结点的信息；
算法思路：
可以借助一个队列，首先将二叉树的根结点入队，然后访问出队结点并出队，如果有左孩子结点，左孩子结点也入队；如果有右孩子结点，右孩子结点也入队。然后访问出队结点并出队，直到队列为空为止
过程演示： （1）入队列，访问队头结点（1），然后（1）出队列，此时（1）的左子树（2）右子树（4）相继入队列；此时队列： 头&lt;---- （2）（4） &lt;---尾
访问队头结点（2），然后（2）出队列，此时（2）的左子树（3）入队列，此时队列：（4）（3）
访问队头结点（4），然后（4）出队列，此时（4）的左子树（5）右子树（6）相继入队列；
此时队列：（3）（5）（6）
访问队头结点（3），然后（3）出队列，因为（3）没有左右子树，此时没有数据入队列，此时队列：（5）（6）
访问头结点（5），然后（5）出队列，此时队列：（6）
访问头结点（6），然后（6）出队列，此时队列：NULL，结束！
下面是另一棵二叉树的遍历来帮助我们理解；
2，创建队列 首先我们得创建一个队列，队列具体细节就不过多解释了，之前博客有专门的详细介绍过；
队列的性质：先进先出，也就是尾插，头删的单链表；
Queue.h #define _CRT_SECURE_NO_WARNINGS 1 #pragma once #include&lt;stdio.h&gt; #include&lt;assert.h&gt; #include&lt;stdlib.h&gt; #include"BTree.h" typedef BTNode* QDataType; //结点 typedef struct QListNode { struct QListNode* next; QDataType data; }QNode; // 队列 typedef struct Queue { QNode* front; // 队头 QNode* rear; //队尾 int size; }Queue; // 初始化队列 void QueueInit(Queue* q); // 队头入队列 void QueuePush(Queue* q, QDataType data); // 队尾出队列 void QueuePop(Queue* q); // 获取队列头部元素 QDataType QueueFront(Queue* q); // 获取队列队尾元素 QDataType QueueBack(Queue* q); // 获取队列中有效元素个数 int QueueSize(Queue* q); // 判空 int QueueEmpty(Queue* q); // 销毁队列 void QueueDestroy(Queue* q); Queue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7630eb540ffb7a8dab2ee403a159f5f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/582/">«</a>
	<span class="pagination__item pagination__item--current">583/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/584/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>