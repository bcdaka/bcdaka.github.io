<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80b29c207370b3c230bca55140e08e55/" rel="bookmark">
			vue3.0(十六)axios详解以及完整封装方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 axios简介1. promise2. axios特性3. 安装4. 请求方法5. 请求方法别名6. 浏览器支持情况7. 并发请求 Axios的config的配置信息1.浏览器控制台相关的请求信息：2.配置方法3.默认配置4.配置的优先级5.axios请求响应结果 Axios的拦截器1.请求拦截2.响应拦截3.移除拦截器4.给自定义的 axios 实例添加拦截器。 Axios取消请求Axios的封装 axios简介 axios与后台进行数据交互， Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中
axios的github
Axios 是一个基于 promise 的 HTTP 库，简单的讲就是可以发送get、post等请求，可以用在浏览器和 node.js 中。React等框架的出现，促使了Axios轻量级库的出现，因为Vue等，不需要操作Dom，所以不需要引入Jquery.js了。
1. promise 异步编程的一种解决方案
所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果Promise提供统一的API，各种异步操作都可以用同样的方法进行处理Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态 (英语意思就是“承诺”，表示其他手段无法改变)与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数 2. axios特性 从浏览器创建 XMLHttpRequests从 node.js 创建 http 请求支持 Promise API拦截请求和响应转换请求和响应数据取消请求超时处理查询参数序列化支持嵌套项处理自动将请求体序列化为： JSON (application/json)Multipart / FormData (multipart/form-data)URL encoded form (application/x-www-form-urlencoded) 将 HTML Form 转换成 JSON 进行请求自动转换JSON数据获取浏览器和 node.js 的请求进度，并提供额外的信息（速度、剩余时间）为 node.js 设置带宽限制兼容符合规范的 FormData 和 Blob（包括 node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80b29c207370b3c230bca55140e08e55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/086032c87c750666a51a30c282ddf1eb/" rel="bookmark">
			【python】PyQt5事件机制、定时器原理分析和实战演练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨✨ 欢迎大家来到景天科技苑✨✨
🎈🎈 养成好习惯，先赞后看哦~🎈🎈
🏆 作者简介：景天科技苑
🏆《头衔》：大厂架构师，华为云开发者社区专家博主，阿里云开发者社区专家博主，CSDN全栈领域优质创作者，掘金优秀博主，51CTO博客专家等。
🏆《博客》：Python全栈，前后端开发，小程序开发，云原生K8S，人工智能，js逆向，App逆向，网络系统安全，数据分析，PyQt5，tkinter，Django，fastapi，flask等框架，linux，shell脚本等实操经验，网站搭建，数据库等分享。
所属的专栏：PyQt5桌面应用开发，零基础到进阶应用实战
景天的主页：景天科技苑
文章目录 PyQt5事件机制PyQt5事件处理的APIPyQt5事件机制演练 PyQt5定时器定时器的操作方法有两种（1）利用每个对象包含的timerEvent函数（2）利用定时器模块QTimer PyQt5事件机制 PyQt为事件处理提供了两种机制：高级的信号与槽机制，以及低级的事件处理机制。信号与槽可以说是对事件处理机制的高级封装。事件机制更偏向于底层。
常见事件类型：
键盘事件：按键按下和松开。
鼠标事件：鼠标指针移动，鼠标按下和松开。
拖放事件：用鼠标进行拖放。
滚轮事件：鼠标滚轮滚动。
绘屏事件：重绘屏幕的某些部分。
定时事件：定时器到时。
焦点事件：键盘焦点移动。
进入/离开事件：鼠标指针移入Widget内，或者移出。
移动事件：Widget的位置改变。
大小改变事件：Widget的大小改变。
显示/隐藏事件：Widget显示和隐藏。
窗口事件：窗口是否为当前窗口。
PyQt提供了如下5种事件处理和过滤方法（有弱到强）：
重新实现事件函数，比如mousePressEvent(),keyPressEvent()等等。
重新实现QObject.event()。
安装时间过滤器。
在QApplication中安装事件过滤器。
重新实现QAppliction的notifiy()方法。
PyQt5事件处理的API PyQt5事件机制演练 import sys from PyQt5.Qt import * #通过继承，重新notify方法 #事件会分发给对象里面的notify方法 class App(QApplication): #notify第一个参数是控件类型（事件接收者），第二个是事件类型 def notify(self, recevier, evt): #notify会监控所有的事件，对事件进行分发。为了打印鼠标点击按钮产生的事件，我们进行了过滤 #过滤事件接收者是按钮，事件类型是鼠标按钮按下 #evt属于QEvent类型。QEvent类型里面有个type方法，用来判断事件类型 if recevier.inherits("QPushButton") and evt.type() == QEvent.MouseButtonPress: print(recevier, evt) #优先调用子类notify方法，由于我们没有写具体功能，什么也做不了，会报错，为了防止程序报错，需要将父类的notify方法返回 #这行代码就是负责分发的 return super().notify(recevier, evt) #写个子类，过滤event事件类型 class Btn(QPushButton): #事件会分发给按钮对象的event方法，event里面包含很多事件 def event(self, evt): if evt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/086032c87c750666a51a30c282ddf1eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c37cff045ef91a0e3d9236ffd210f97f/" rel="bookmark">
			一、安装Redis（win11环境下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.windows安装Redis 1.1下载redis https://github.com/tporadowski/redis/releases
图1-1 网页Redis版本选择 1.2解压redis 图1-2 redis目录下 1.3启动redis 在解压成功后，进入到redis文件下（如上图1-2），右键打开命令窗口，输入：
redis-server.exe redis.windows.conf 图1-3 命令窗口运行 1.4Redis设置环境变量 右键点击“此电脑”
点击“属性”按钮
点击“高级系统设置”
图1-4 电脑系统信息页面 点击“环境变量”
图1-5 系统属性页面 在用户变量或者系统变量中找到“Path”关键字，并点击添加redis路径
图1-6 图1-7 1.5Redis注册为服务 在redis目录下，打开命令窗口，输入下面bash代码：
redis-server.exe --service-install redis.windows.conf --loglevel verbose 1.6将Redis设置成自启动 打开任务管理器
点击“服务”一栏
搜索“Redis”
右键“打开服务”
找到“Redis”，右键“属性”
设置成“自动”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0f9eb16cda6e5f766c43050f1bad1c2/" rel="bookmark">
			使用 Clang-Tidy 进行静态代码分析：完整的配置与 CMake 集成实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 使用 Clang-Tidy 进行静态代码分析：完整的配置与 CMake 集成实例0. 概要1. 安装 Clang-Tidy2. 配置 `.clang-tidy`3. 检查项详解3.1 静态分析器（Static Analyzer）3.2 现代化（Modernize）3.3 Google 代码风格（Google）3.4 可读性（Readability）3.5 CERT 安全编码标准（CERT）3.6 Bug 检测（Bugprone）3.7 C++ 核心指南（CppCoreGuidelines）3.8 杂项（Miscellaneous） 4. 使用 Clang-Tidy4.1 生成 `compile_commands.json`4.2 运行检测4.3 执行结果4.4 如何屏蔽warnings?4.5 与 CMake 集成CMake 脚本详解脚本细节解析 5. 资源阅读 使用 Clang-Tidy 进行静态代码分析：完整的配置与 CMake 集成实例 关于Cppcheck 的使用请参考： 使用 Cppcheck 进行静态代码分析：完整的 shell 脚本与 CMake 集成实例
关于OCLint的使用请参考： 使用 OCLint进行静态代码分析：一个完整的配置示例
本文重点介绍与CMake 集成，如需shell脚本进行clang-tidy检测请参考: 使用多进程shell脚本进行clang-tidy静态代码分析 和 使用 shell 脚本进行 clang-tidy 静态代码分析
0. 概要 Clang-Tidy 是一款功能强大的静态代码分析工具。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0f9eb16cda6e5f766c43050f1bad1c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cd750637ac18f28c1b4e3aeaf2c1598/" rel="bookmark">
			提升办公效率的智能 AI 伙伴 -- ONLYOFFICE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.引言 在这个信息爆炸的时代，人工智能（AI）的快速崛起已经对各行各业产生了深远的影响，职场人士所面临的工作挑战也越来越多。为了提高工作效率，我们需要 AI 技术的融入，使得办公软件变得更加智能、高效，而 ONLYOFFICE 正是这样一款走在时代前沿的办公软件。
ONLYOFFICE 是一款开源免费、跨平台、集成AI、兼容性强和灵活部署的软件，与主流办公软件 Microsoft Office 和 WPS Office 高度兼容，可谓是升级版 OFFICE 软件，并且支持多用户在线编辑和评论各种文档。
主要的亮点功能有：
多用户在线协作：支持多人实时在线编辑和评论文档，提升团队协作效率。
灵活的部署选项：提供云端服务和本地部署两种方式，满足不同用户的需求，特别是在数据安全和隐私保护方面有更高要求的用户。
高度兼容性：开源免费，兼容 Microsoft Office 文档格式，用户可以轻松地在 ONLYOFFICE 和 Microsoft Office 之间切换，无需担心格式问题。
官方网站和GitHub地址如下，让我们了解 ONLYOFFICE 更多强大的功能：
GitHub 地址：https://github.com/ONLYOFFICE
2.ONLYOFFICE 功能介绍 2.1 多平台高度兼容 首先，我们可以点击官网，进入到获取 ONLYOFFICE，在这里我们可以注册协作空间云端版进行体验。
image
根据页面提示，注册登陆成功后，就可以看到以下界面：
image
从界面能够看出，ONLYOFFICE 不仅能够在云端使用，还能在 Windows、Linux、macOS、Android 以及 iOS 系统中下载对应的应用程序。这使得用户能够在任何系统和设备上达成无缝衔接的使用体验，而且其高度兼容微软 Office 格式，完全消除了用户对于兼容性方面的顾虑。
2.2 支持多文件格式 ONLYOFFICE 具备强大的功能，能够创建、查看和编辑任何规模以及复杂程度的文件。它兼容多种常见格式的文档，例如 DOCX、PDF、ODT、DOCXF、DOTX、OTT、RTF、TXT、FB2、EPUB、JPG、PNG 等等，办公所用软件均涵盖其中。
image
如果下载的是对应系统的应用程序，那么您能够在同一个窗口中轻松处理多个不同格式文件，那些 Office 无法给予您的高效智能体验，ONLYOFFICE 却可以为您完美呈现！
image
2.3 多样化连接器 ONLYOFFICE 支持多样化的连接器，允许用户将 ONLYOFFICE 集成到其他应用程序或服务中，如 Zoom、Nextcloud、Odoo、Box 等，通过这些连接器，ONLYOFFICE 的文档编辑和协作空间得以无缝融入用户现有的技术生态中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cd750637ac18f28c1b4e3aeaf2c1598/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4017ab73d9d5fccb28924bdce0f2d8c8/" rel="bookmark">
			【C语言】使用VSCode编译C语言程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 安装MinGW环境2.添加C/C++扩展3. 新建工程文件夹3.1 建立test文件夹3.2 建立.vscode文件夹3.3 建立test.c文件 4. 使用VSCode打开工程文件夹5. 编写JSON文件5.1 手动编写5.1.1 创建`tasks.json`文件。5.1.2 创建`launch.json`文件5.1.3.编写单个C语言程序5.1.4. 运行调试 5.2 自动生成5.2.1 安装C/C++ Runner插件5.2.2 创建test1文件夹并创建`.C`文件5.2.3 运行编译 这里简单记录一下使用VSCode编译C语言程序，目前初步使用VSCode进行简单编写，置于里面的json文件为什么要那样配置，后续再进行学习吧。 1. 安装MinGW环境 这里参考文章安装即可。
参考文章：
https://blog.csdn.net/didi_ya/article/details/111240502
2.添加C/C++扩展 下载安装好VSCode和MinGW64后，在左侧的活动栏中找到“扩展”按钮，或者直接按Ctrl+Shift+X打开扩展。
然后输入C/C++，搜索找到下面的扩展，点击进去，点击安装。
安装成功后如下。
3. 新建工程文件夹 在电脑本地磁盘的位置新建需要编译的C语言程序的文件夹，这里建立的文件夹为test文件夹，在test文件夹中再建立一个.vscode文件夹，和一个test.c文件。
3.1 建立test文件夹 test文件夹用来存放.vscode文件夹和需要编译的.c文件。
3.2 建立.vscode文件夹 如果想使用插件自动生成，就不需要创建这个文件夹了，在test文件夹下建立.vscode文件夹，用于存放后面需要手动编写的json文件。
3.3 建立test.c文件 在test文件夹下建立test.c文件。
4. 使用VSCode打开工程文件夹 这里建立的工程文件夹为test文件夹，直接将test文件夹拖拽至VSCode图标处打开，或者在VSCode中的文件→打开文件夹，这个方法选中test文件夹进行打开。
打开后如下图所示。
5. 编写JSON文件 JSON，即JavaScript Object Notation，是一种轻量级的数据交换格式，在VS Code中常被用作存储配置信息，这里编写JSON文件有两种方式：
手动编写。自动生成。 5.1 手动编写 要在VS Code上运行调试C语言程序，就需要创建两个json文件：
launch.json task.json
在使用“运行和调试”功能的时候，task.json文件负责定义编译任务，launch.json文件负责配置调试器。前面已经创建过.vscode文件夹了，因此在VS Code中对.vscode文件夹单击鼠标右键，然后点击新建文件，来创建json文件，这里防止自动生成.vscode文件夹，只安装了一个C语言的插件。
插件环境：C/C++
5.1.1 创建tasks.json文件。 点击新建文件后，输入tasks.json后按下回车，右侧就会出现编辑json文件的窗口。
输入以下代码。
{ "tasks": [ { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4017ab73d9d5fccb28924bdce0f2d8c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7f05db819ed1b8f95fbd440f6318645/" rel="bookmark">
			深⼊理解SpringCloud 相关组件Eureka、Ribbon、Feign、Hystrix、Nacos、Sentinel核心源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深入理解Spring Cloud相关组件的核心源码和详细原理是一个复杂的过程，需要对每个组件的内部工作机制有透彻的了解。下面是对这些组件的详细原理介绍：
### Eureka
- **原理**：Eureka是一个基于REST的服务，用于服务注册与发现。客户端使用轮询机制向Eureka服务器发送心跳（续约），Eureka服务器会维护一个服务注册表。当服务实例下线时，Eureka会从注册表中移除该实例。
- **源码分析**：关注`com.netflix.eureka`包中的`AbstractInstanceRegistry`和`PeerEurekaNode`类，它们负责服务注册信息的存储和节点之间的复制。
### Ribbon
- **原理**：Ribbon是一个客户端负载均衡器，与Eureka结合使用，可以在客户端进行服务调用时实现负载均衡。
- **源码分析**：查看`com.netflix.loadbalancer`包中的`Rule`接口及其实现类，了解不同的负载均衡策略。
### Feign
- **原理**：Feign是一个声明式的Web服务客户端，它使得编写Web服务客户端变得更加简单。Feign使用动态代理机制，根据注解自动生成HTTP请求。
- **源码分析**：研究`feign.Client`接口和`Feign.Builder`类，了解如何创建和使用Feign客户端。
### Hystrix
- **原理**：Hystrix是一个熔断器，用于防止服务雪崩效应。它通过线程池和信号量来实现资源隔离，并通过熔断机制来快速失败，避免系统过载。
- **源码分析**：深入`com.netflix.hystrix`包中的`HystrixCommand`和`HystrixThreadPoolKey`类，理解熔断逻辑和资源隔离机制。
### Nacos
- **原理**：Nacos是一个更易于构建云原生应用的服务发现、配置管理和服务管理平台。它支持服务的注册与发现，配置的统一管理，以及服务的动态管理。
- **源码分析**：研究`com.alibaba.nacos`包中的`NamingService`和`ConfigService`接口，了解服务注册发现和配置管理的实现。
### Sentinel
- **原理**：Sentinel是一个提供流量控制、熔断降级、系统自适应过载保护的微服务保护组件。它通过定义规则来控制流量，并通过熔断降级来保护系统。
- **源码分析**：查看`com.alibaba.csp.sentinel`包中的`Entry`和`RuleManager`类，了解流量控制和规则管理的实现。
### 源码阅读建议
- **理解架构**：首先理解每个组件的架构设计和它们在Spring Cloud体系中的作用。
- **逐步深入**：从高层的API开始，逐步深入到具体的实现细节。
- **代码调试**：通过调试源码来理解组件的行为，特别是在复杂场景下的表现。
- **社区参与**：加入Spring Cloud社区，参与讨论，获取最新的开发动态和最佳实践。
### 学习资源
- **官方文档**：阅读Spring Cloud和各个组件的官方文档，了解它们的设计理念和使用方法。
- **源码仓库**：访问GitHub上的Spring Cloud项目，阅读源码和提交记录，了解历史变更和最新进展。
- **社区论坛**：参与Stack Overflow、Reddit等社区的讨论，向其他开发者学习。
深入理解这些组件的源码和原理，可以帮助你更好地使用Spring Cloud构建微服务架构，解决实际开发中遇到的问题，并根据业务需求进行适当的定制和优化。如果你需要更具体的帮助或有特定的问题，随时可以提问。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7040e8655869d8c5f05f319f01624958/" rel="bookmark">
			大二暑假 &#43; 大三上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		希望，暑假能早睡早起，胸围达到 95，腰围保持 72，大臂 36，小臂 32，小腿 38🍭🍭
目录
🍈暑假计划
🌹每周进度
🤣寒假每日进度😂
🍈暑假计划 暑假：7月7日 ~ 8月27日 ≈ 52 天
🍭基础 + 八股 + 算法 + 项目🍭
-- 清华OS操作系统 -- 30个视频 (剩余)
-- 小林 coding 《图解网络》
-- 牛客 240 页八股
-- hot 100 二刷（一刷 76/100）
-- MIT 6.824 分布式
清华OS 75/100 牛客八股 0/240 hot100 80/100 -------- 《图解网络》 ------- 公众号， 0/3 一， 1/1 二， 0/3 三， 0/9 四， 0/23 五， 0/3 六， 2/2 -------- MIT 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7040e8655869d8c5f05f319f01624958/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2b5eb66e6718c01b3f6b6ed5a5e9119/" rel="bookmark">
			MySQL8.4设置密码规则为mysql_native_password
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql使用的时候会有报错：Plugin 'mysql_native_password' is not loaded
1)首先确认mysql_native_password插件是否已经安装
安装mysql_native_password插件
INSTALL PLUGIN mysql_native_password SONAME 'mysql_native_password';
如果已经安装，会显示该插件已经存在
2)查看插件状态
show plugins;
看看mysql_native_password插件的状态是不是ACTIVE,如果状态值为DISABLED则说明插件没有激活
3)修改my.cnf或my.ini配置文件
[mysqld]
mysql_native_password=ON #添加此行
不要添加default_authentication_plugin=mysql_native_password，否则mysql会无法启动。
4)重启mysql服务
5)mysql命令行查看用户使用的插件
select user,host,plugin from mysql.user;
6)修改密码认证方式
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'your password';
FLUSH PRIVILEGES; #刷新权限
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ada52f481bedb9ba270ba1d6b4adf82/" rel="bookmark">
			PHP实现登录和注册（附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本博客主要讲述利用php环境实现一个简单的前后端结合的用户登录和注册功能。phpstudy是PHP调试环境的集成包，该程序包集成了 Apache+PHP+MySQL+phpMyAdmin 等多个工具，是很好用的调试环境的程序集成包。
目录
前言
1. 准备工作
1.1 工具
1.2 phpstudy 介绍
2. 创建网站
2.1 搭建PHP环境
3. 用户登录和注册功能
3.1 思路
3.2 准备阶段
3.3 前端部分
3.3.1 登录的前端页面
3.3.2 注册的前端页面
3.4 验证注册的数据
3.4.1 设置验证规则
3.4.2 phpMyAdmin 管理数据库
3.4.3 PHP 连接数据库
3.4.4 保存注册的数据到数据库中
3.5 登录验证
3.5.1 连接数据库
1. 准备工作 1.1 工具 在phpstudy官网中下载即可，选择对应的电脑位数
链接：Windows版phpstudy下载 - 小皮面板(phpstudy)
下载好压缩包后，新建一个文件夹用来解压压缩包里面的文件。解压之后找打该文件夹，里面有如下文件，接着我们进行安装。选择自定义安装路径安装到你想安装的位置即可，这里不展开来说。
安装好以后就可以在桌面看到该软件了
1.2 phpstudy 介绍 在桌面找到该软件后双击打开它，就可以看到如下页面，然后我们需要在该集成包中下载一些软件
下载之后就回到主页去看，本次的案例我使用 Nginx 来启动 Web 服务，（这里选择可以多样）
启动MySQL时会出现启动不了的情况 （能正常启动则跳到 "2.创建网站"）
解决： window键 + R 输入 SERVICES.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ada52f481bedb9ba270ba1d6b4adf82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3756bbf156021d0ecdff84125090196a/" rel="bookmark">
			飞书文档转markdown 超级快捷方法。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接使用那个github的高赞官方的工具转换，需要设置什么小应用那种东西，还要审批，社恐人表示怕了怕了。而且文档我分享出去，是有权限的，反正无论如何生成不了
我的方法是
直接全选，然后粘贴进Arya - 在线 Markdown 编辑器 这个链接（地址：https://markdown.lovejade.cn/
因为其实你在飞书里写，是直接有markdown格式的，但是官方没有提供一个，可以直接转markdwon的接口，那么你直接copy下来实际上有格式的
那什么typra的 app还要钱
直接扔进在线的里面，把输入框的东西复制进来，得到markdown。
飞书官方只提供了转word，试了下word再转markdown效果并不好。但我这个网址，连ol，ul这些都支持
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5615fd50d925d328e379dea76679842/" rel="bookmark">
			[PyTorch]：加速Pytorch 模型训练的几种方法（几行代码），最快提升八倍（附实验记录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章转自：Some Techniques To Make Your PyTorch Models Train (Much) Faster
本篇博文概述了在不影响 PyTorch 模型准确性的情况下提高其训练性能的技术。为此，将 PyTorch 模型包装在 LightningModule 中，并使用 Trainer 类来实现各种训练优化。只需更改几行代码，就可以将单个 GPU 上的训练时间从 22.53 分钟缩短到 2.75 分钟，同时保持模型的预测准确性。
性能提升了 8 倍！
（本博文于 2023 年 3 月 17 日更新，现在使用 PyTorch 2.0 和 Lightning 2.0！）
实验汇总：
省流版（详细实验过程可参见下述实验训练记录）：
使用Pytorch与Pytorch Ligntning可以获得相同的训练时长（上图不一致在于加载checkpoint文件和log）
使用混合精度训练可将训练时间从 21.79 分钟缩短至 8.25 分钟！这几乎快了 3 倍！
测试集准确率为 93.2%——与之前的 92.6% 相比略有提高（可能是由于在不同精度模式之间切换时舍入引起的差异）。
在使用默认参数的情况下，似乎torch.compile不会在混合精度环境中提高 DistilBERT 模型的性能。
使用四块 A100 GPU，此代码运行时间为 3.07 分钟，测试准确率达到 93.1%
Trainer + 混合精度 + DeepSpeed + 多GPU运行花了 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5615fd50d925d328e379dea76679842/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/995b3663d6651ba635a131cb9b00d897/" rel="bookmark">
			全面了解机器学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、基本认识
1. 介绍
2. 机器学习位置
二、机器学习的类型
1. 监督学习
2. 无监督学习
3. 强化学习
三、机器学习术语
1. 训练样本
2. 训练
3. 特征
4. 目标
5. 损失函数
四、机器学习流程
五、机器学习算法
1. 分类算法
2. 聚类算法
3. 关联分析
4. 回归分析
① 线性回归
② 逻辑回归
③ 多项式回归
④ 岭回归
⑤ LASSO 回归
5. 深度学习
一、基本认识 1. 介绍 在当今的 科技时代，大量结构化 和 非结构化数据是我们的 丰富资源。机器学习在 20世纪 下半叶演变为 人工智能（Al）的 一个分支，它 通过 自学习算法 从数据中 获得知识来 进行预测。机器学习 并不需要 事先对 大量数据进行 人工分析，然后 提取规则 并建立模型，而是 提供了一种更为 有效的方法 来捕获 数据中的 知识，逐步提高 预测模型的性能，以 完成数据驱动的决策。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/995b3663d6651ba635a131cb9b00d897/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad2deb677ad12dfe53c0299ea0c3cc5d/" rel="bookmark">
			线程池666666
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 作用 线程池内部维护了多个工作线程，每个工作线程都会去任务队列中拿取任务并执行，当执行完一个任务后不是马上销毁，而是继续保留执行其它任务。显然，线程池提高了多线程的复用率，减少了创建和销毁线程的时间。
2. 实现原理 线程池内部由任务队列、工作线程和管理者线程组成。
任务队列：存储需要处理的任务。每个任务其实就是具体的函数，在任务队列中存储函数指针和对应的实参。当工作线程获取任务后，就能根据函数指针来调用指定的函数。其实现可以是数组、链表、STL容器等。
工作线程：有N个工作线程，每个工作线程会去任务队列中拿取任务，然后执行具体的任务。当任务被处理后，任务队列中就不再有该任务了。当任务队列中没有任务时，工作线程就会阻塞。
管理者线程：周期性检测忙碌的工作线程数量和任务数量。当任务较多线程不够用时，管理者线程就会多创建几个工作线程来加快处理（不会超过工作线程数量的上限）。当任务较少线程空闲多时，管理者线程就会销毁几个工作线程来减少内存占用（不会低于工作线程数量的下限）。
注意：线程池中没有维护“生产者线程”，所谓的“生产者线程”就是往任务队列中添加任务的线程。
3. 手撕线程池 参考来源：爱编程的大丙。
【1】threadpool.c:
#include "threadpool.h" #include &lt;pthread.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #define NUMBER	2	//管理者线程增加或减少的工作线程数量 //任务结构体 typedef struct Task { void (*func)(void* arg); void* arg; } Task; //线程池结构体 struct ThreadPool { //任务队列，视为环形队列 Task* taskQ; int queueCapacity;	//队列容量 int queueSize;	//当前任务个数 int queueFront;	//队头 -&gt; 取任务 int queueRear;	//队尾 -&gt; 加任务 //线程相关 pthread_t managerID;	//管理者线程ID pthread_t* threadIDs;	//工作线程ID int minNum;	//工作线程最小数量 int maxNum;	//工作线程最大数量 int busyNum;	//工作线程忙的数量 int liveNum;	//工作线程存活数量 int exitNum;	//要销毁的工作线程数量 pthread_mutex_t mutexPool;	//锁整个线程池 pthread_mutex_t mutexBusy;	//锁busyNum pthread_cond_t notFull;	//任务队列是否满 pthread_cond_t notEmpty;	//任务队列是否空 //线程池是否销毁 int shutdown;	//释放为1，否则为0 }; /*************************************************************** * 函 数: threadPoolCreate * 功 能: 创建线程池并初始化 * 参 数: min---工作线程的最小数量 * max---工作线程的最大数量 *	capacity---任务队列的最大容量 * 返回值: 创建的线程池的地址 **************************************************************/ ThreadPool* threadPoolCreate(int min, int max, int capacity) { //申请线程池空间 ThreadPool* pool = (ThreadPool*)malloc(sizeof(ThreadPool)); do {//此处循环只是为了便于失败释放空间，只会执行一次 if (pool == NULL) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad2deb677ad12dfe53c0299ea0c3cc5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36bfca994f9429d81db13353a22e107f/" rel="bookmark">
			详解反向传播（BP）算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 what（是什么）where（用在哪）How（原理&amp;&amp;怎么用）原理以及推导过程pytorch中的反向传播 what（是什么） 反向传播算法（Backpropagation）是一种用于训练人工神经网络的常见方法。它通过计算网络预测与实际结果之间的误差，然后反向传播这个误差来调整网络中每个权重的值，从而逐步优化网络的学习过程
where（用在哪） 绝大多数的神经网络都会使用反向传播算法进行网络权重以及阈值的更新，简单列举部分典型的使用场景如下
反向传播算法 前馈神经网络 多层感知机 卷积神经网络 循环神经网络 深度神经网络 How（原理&amp;&amp;怎么用） 原理以及推导过程 下面重点介绍反向传播算法的推导流程
假设有以上简单的神经网路模型，分为输入层、隐藏层、输出层。其中隐藏层包括4个神经元、输出层包括2个神经元。
假设输出层的两个神经元为 y 1 y_1 y1​， y 2 y_2 y2​，其激活阈值分别为 β \beta β， γ \gamma γ，两个神经元的输入分别为 y 1 i n y_{1in} y1in​， y 2 i n y_{2in} y2in​，输出分别为 y 1 ^ \hat{y_1} y1​^​和 y 2 ^ \hat{y_2} y2​^​。
假设隐藏层四个神经元为 h 1 h_1 h1​， h 2 h_2 h2​， h 3 h_3 h3​， h 4 h_4 h4​，其中 h 1 h_1 h1​的激活阈值为 δ \delta δ，神经元 h 1 h_1 h1​的输入值为 h i n h_{in} hin​，输出值为 h o u t h_{out} hout​。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36bfca994f9429d81db13353a22e107f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a7c4924998f0e1cda69bfccb2d8d674/" rel="bookmark">
			【C语言】分支（选择）和循环语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 简述选择语句简述if语句单if结构语法格式 if-else结构语法结构 语法结构 循环结构break和continuewhile循环语法结构 for循环语法结构 do while循环语法结构 简述 在c语言中分支和循环语句是极其重要的，就像生活中你难免要做一些判断和循环往复做一些事。
选择语句 简述 分支语句也叫判断语句，在c语言中有两种分支语句。
一种是if-else语句。另一种是Switch-case语句。 if语句 单if结构 单if结构就是没有else语句，只有一个if来判断进不进入代码块。
语法格式 单if语句语法格式如下：
if(表达式) { //代码块 } 符合 if 后面表达式就执行代码块中的内容，不符合就不执行。
if-else结构 if-else结构既有if也用else，有两种结构，看含不含else if语句
语法结构 不含else if if(表达式) { //代码块1 } else { //代码块2 } 符合 if 后面表达式就执行代码块1中的内容，不符合就执行代码块2中的内容。
含else if if(表达式1) { //代码块1 } else if(表达式2) { //代码块2 } else if(表达式3) { //代码块3 } else { //代码块4 } 符合 表达式几就执行代码块几中的内容，都不符合就执行代码块4中的内容。
要点：
在这种语法结构下else if可以无限多。最后的else可以没有。如果符合多个表达式，会由上至下开始匹配，执行最先的表达式下的代码块，只执行这一个，剩下的不会在执行。 ​## switch-case语句
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a7c4924998f0e1cda69bfccb2d8d674/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7a136f932d67ac53f037762d60501fc/" rel="bookmark">
			MySQL大小写敏感、MySQL设置字段大小写敏感
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、MySQL大小写敏感规则二、设置数据库及表名大小写敏感2.1、查询库名及表名是否大小写敏感2.2、修改库名及表名大小写敏感 三、MySQL列名大小写不敏感四、lower_case_table_name与校对规则4.1、验证校对规则影响大小写敏感4.1、验证校对规则影响排序 五、设置字段内容大小写敏感5.1、查看和修改某个表的编码集5.2、查看和修改某个字段的编码集5.3、设置字段大小写敏感5.4、查询时设置字段大小写敏感/不敏感 以下内容基于Mysql:8.0.20进行讲解。
所谓的大小写敏感指的是指的是大写与小写是两个两个值，而大小写不敏感指的是小写跟大写看做是一个值。
一、MySQL大小写敏感规则 Linux下：
数据库名与表名是严格区分大小写的；表的别名是严格区分大小写的；列名与列的别名在所有的情况下均是忽略大小写的；变量名也是严格区分大小写的； Windows下：
都不区分大小写。 Mac OS下，文件系统类型HFS+，非UFS卷：
都不区分大小写。 MySQL中控制数据库名和表名的大小写敏感由参数lower_case_table_names控制，为0时表示区分大小写，为1时，表示将名字转化为小写后存储，不区分大小写。在不同的操作系统上，这个参数的默认值不同：
Unix（包括Linux）下，默认值为0，表示对数据库名和表名的大小写是敏感的。Windows下，默认值为1，表示不敏感，即在存储和查找时会将名称转换为小写。macOS下，默认值为2，表示存储区分大小写，但在查询时会转换为小写。 官网介绍：https://dev.mysql.com/doc/refman/8.0/en/identifier-case-sensitivity.html
lower_case_table_names：
0： 使用CREATE TABLE或CREATE DATABASE语句指定的大小写字母在硬盘上保存表名和数据库名。名称比较对大小写敏感。在大小写不敏感的操作系统如windows或Mac OS x上我们不能将该参数设为0，如果在大小写不敏感的文件系统上将此参数强制设为0，并且使用不同的大小写访问MyISAM表名，可能会导致索引破坏。
1： 表名在硬盘上以小写保存，名称比较对大小写不敏感。MySQL将所有表名转换为小写在存储和查找表上。该行为也适合数据库名和表的别名。该值为Windows的默认值。
2： 表名和数据库名在硬盘上使用CREATE TABLE或CREATE DATABASE语句指定的大小写字母进行保存，但MySQL将它们转换为小写在查找表上。名称比较对大小写不敏感，即按照大小写来保存，按照小写来比较。注释：只在对大小写不敏感的文件系统上适用innodb表名用小写保存。
在大小写不敏感的操作系统（Windows和macOS）中，不能将lower_case_table_names设置为0。如果需要在这些系统中设置大小写敏感，可以通过修改配置文件my.ini来更改lower_case_table_names的值。例如，在Windows下，可以将lower_case_table_names设置为2，并重启MySQL服务。
在创建表时，可以通过设置字段属性binary或使用collate规则来控制字段内容的大小写敏感性。例如，将字段标记为binary或设置collate为utf8_bin可以实现二进制大小写敏感。如果建表时未指定collate规则，也可以通过修改字段的collate属性来实现大小写敏感。
总结如下：
在Unix系统中，数据库名和表名的大小写是敏感的。在Windows系统中，数据库名和表名的大小写不敏感，存储和查找时会转换为小写。在macOS系统中，数据库名和表名的大小写是敏感的，但在查询时会转换为小写。在大小写不敏感的系统中（Windows和macOS），不能将lower_case_table_names设置为0。可以通过修改配置文件或设置字段属性来控制大小写敏感性。 二、设置数据库及表名大小写敏感 2.1、查询库名及表名是否大小写敏感 可以通过 show variables like “%case%”; 查看当前Mysql关于大小写的设置,下面是我再Windows下执行的结果
根据上面对lower_case_table_names属性的讲解，我们发现windows中的值为1不区分大小写，而且创建的表名在数据库中是以小写存储的。
lower_case_file_system
该参数是用于描述mysql的数据目录data所在的操作系统是否为大小写敏感，该参数为boolean类型，但无法修改。
0 – 大小写敏感1 – 大小写不敏感 比如跑在linux上的都是OFF或者0。
Linux默认参数结果:
2.2、修改库名及表名大小写敏感 mysql8.0更改lower_case_table_names
mysql8.0安装初始化之后是不能更改lower_case_table_names的
下面是官方文档的一段话：
In MySQL 8.0, the lower_case_table_names variable can only be configured when the MySQL server is initialized.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7a136f932d67ac53f037762d60501fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48837ff3c3e9293079a7942e34caa15c/" rel="bookmark">
			力扣每日一题 7/2 数学、数论、数组/双指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博客主页：誓则盟约系列专栏：IT竞赛 专栏关注博主，后期持续更新系列文章如果有错误感谢请大家批评指出，及时修改感谢大家点赞👍收藏⭐评论✍ 3115.质数的最大距离【中等】 题目： 给你一个整数数组 nums。
返回两个（不一定不同的）质数在 nums 中 下标 的 最大距离。
示例 1：
输入： nums = [4,2,9,5,3]
输出： 3
解释： nums[1]、nums[3] 和 nums[4] 是质数。因此答案是 |4 - 1| = 3。
示例 2：
输入： nums = [4,8,2,8]
输出： 0
解释： nums[2] 是质数。因为只有一个质数，所以答案是 |2 - 2| = 0。
提示：
1 &lt;= nums.length &lt;= 3 * 10**51 &lt;= nums[i] &lt;= 100输入保证 nums 中至少有一个质数。 分析问题： 思路一： 题目难度适中，主要思路是利用双指针，头指针从下标0开始往后遍历，尾指针从下标n-1开始往前遍历，先走头指针，碰到质数时指针停下；尾指针开始运动，碰到质数时结束。
不知道要循环多少次所以用while循环来写，但是在写循环之前要先写判断是否是质数的函数pan。但是需要注意的是 1 不是质数。
如果头指针和尾指针重合，则说明只有一个质数。返回0即可。如果头指针和尾指针不重合，则直接返回 ed-st 即可。 思路二： 因为这道题的数据量只有1-100这个区间，所以我们可以直接写出来100以内的所有质数，这样可以直接取，大大减小复杂度，具体思路如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48837ff3c3e9293079a7942e34caa15c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4b45a03ddfe425de0a6880d62fe72da/" rel="bookmark">
			【MySQL】mysql访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql访问 1.引入MySQL 客户端库2.C/C++ 进行增删改3.查询的处理细节4.图形化界面访问数据库4.1下载MYSQL Workbench4.2MYSQL Workbench远程连接数据库 点赞👍👍收藏🌟🌟关注💖💖
你的支持是对我最大的鼓励，我们一起努力吧!😃😃
1.引入MySQL 客户端库 从开始到选择我们用的都是命令行式的mysql访问mysqld，向mysqld下达我们的指令，其实在数据库层面上，连接数据库的客户端除了现在命令行式的客户端，还有图形化界面、网页版的，当然也包括语言级别的库或者包帮我们去访问数据库。
下面我们就用C/C++访问数据库。关于访问数据库我们要做两个准备工作，一是创建一个远端或者本地访问的请求也就是创建一个专门用来进行用C/C++访问客户端的账号。
reate user 'connector'@'localhost' identified by 'xxx'; 然后创建一个数据库，赋予这个账号对数据库中表的所有权限。
二是安装C/C++要能访问的库，这个库有两种准备，第一种是从官网下载库，
下面这个是用不同语言连接MYSQL，官方提供的库。
下载推荐的8.0
我们用的是linux，所以选择linux系统x86 64位
下载好，上传到linux，然后解压一下，mysql-connector是解压后重命名的
这是解压后的文件，最重要的就是include 头文件，还有一个lib64 库
未来头文件给我们提供连接mysql的方法，库 提供连接mysql的库函数
我们就可以根据头文件，直接调用头文件的的方法，在编译连接的时候把库连入进来。如果忘记怎么引入，在Linux哪里基础IO动静态库就有对应的方法！
但是这种方式不推荐了！之间不是下载mysql，用yum源下载吗。yum源它会给我们找到合适的服务器，客户端，甚至是开发包。所以我们直接在yum哪里去找进行了。
没下载过mysql 可以下一下如果你安装过yum对应msyql源的话，如果不会下请移步于
【MySQL】MySQL在 Linux下环境安装
yum install -y mysql-community-server 如果你下载过，你就可以看到这里有对应的头文件，未来我们主要用的就是mysql.h
如果你下载过但是找不到头文件，执行下面的命令，就可以看到了
install -y mysql-devel mysql库在系统默认安装路径下
开发环境我们有已经准备好了，接下来我们学习具体的接口。不过我们通过 mysql_get_client_info() 函数，来验证我们的引入是否成功。
#include &lt;iostream&gt; #include &lt;mysql/mysql.h&gt; using namespace std; int main() { //获取当前客户端版本信息 cout&lt;&lt;"mysql client Version: "&lt;&lt;mysql_get_client_info()&lt;&lt;endl; return 0; } 如果直接编译肯定会报错，说的是未定义的引用，也就是这个mysql_get_client_info()找不到。
之前基础IO就说过，你要保证这个外来库能被正确连接，gcc/g++默认会选择C和C++的库，虽然你的mysql在系统中，系统也会默认会去/lib64路径下去找，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4b45a03ddfe425de0a6880d62fe72da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16cba50c38daacedfa8e315e05066ced/" rel="bookmark">
			【Spring Boot】Spring AOP中的环绕通知
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、什么是AOP?二、AOP 的环绕通知2.1 切点以及切点表达式2.2 连接点2.3 通知（Advice）2.4 切面(Aspect)2.5 不同通知类型的区别2.5.1 正常情况下2.5.2异常情况下 2.6 统一管理切点@PointCut 一、什么是AOP? Aspect Oriented Programming（面向切面编程）
AOP是Spring框架的第⼆⼤核⼼(第⼀⼤核⼼是IoC)
AOP是一种思想，是对某一类事情的集中处理。
其中在下面的学习中我们会学习到拦截器、统一异常处理，统一结果处理等，这些都是运用了AOP的统一思想来实现的。
拦截器实现AOP思想作用的维度是前端对后端进行的一次请求和一次响应，主要是检索前端传来的URL，如果检索后返回True，则可以进入Controller开始执行代码，如果返回的为False，则表示失败，直接被拦截在外面，无法执行代码。
统一结果处理则是使用注解@ControllerAdvice(通知类注解)，实现ResponseBodyAdvice接口，对响应的结果进行统一处理，对齐进行统一的包装后响应，其中如果数据类型为String类型的话要进行特殊处理，使用ObjectMapper的方法将String格式转为Json格式再次响应。
统一异常处理也是使用注解@ControllerAdvice(通知类注解)，以及在方法上使用@ExceptionHandler注解，在全部的程序中如果遇到运行时异常则会自动捕捉，进行抛出，注：编译时异常是写代码过程中出现的，不手动解决就无法运行程序。
接下来我们要学习的是运用了AOP思想，进行AOP的环绕处理
二、AOP 的环绕通知 2.1 切点以及切点表达式 切点=通知类型+切点表达式
切点表示了为该方法提供一组规则，来对程序进行功能增强
通知类型有以下5种：
@Around:环绕通知,此注解标注的通知方法在目标方法前,后都被执行
@Before:前置通知,此注解标注的通知方法在目标方法前被执行
@After:后置通知,此注解标注的通知方法在目标方法后被执行,⽆论是否有异常都会执行
@AfterReturning:返回后通知,此注解标注的通知方法在目标方法后被执行,有异常不会执行
@AfterThrowing:异常后通知,此注解标注的通知方法发⽣异常后执行
如下图所示：
在该方法上的@Around,表示的是环绕处理，是一种通知类型
其后面的execution(* com.example.demo.controller..(…)) 表示的是该通知类型作用的范围，是切点表达式
2.2 连接点 满足切点表达式规则的方法就是连接点
在该图中，public recordTime方法就是连接点
2.3 通知（Advice） 通知就是具体要做的内容，简单来说就是方法内执行的代码内容
如图所示：
该图中标红的位置就是通知内容，在AOP面向切面编程当中,我们把这部分重复的代码逻辑抽取出来单独定义,这部分代码就是通知的内容
2.4 切面(Aspect) 首先使用注解@Aspect来表示该类是一个切面类
然后使用不同的通知类型进行处理,如图表示的是环绕通知类型
在处理过程中ProceedingJoinPoint.proceed()让原始方法执行
切面(Aspect)=切点(Pointcut)+通知(Advice)
以下代码表示一个完整的切面类:
import lombok.extern.slf4j.Slf4j; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.springframework.stereotype.Component; @Slf4j @Aspect @Component public class TimeAspect { /** * 记录方法耗时 */ @Around("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16cba50c38daacedfa8e315e05066ced/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/201/">«</a>
	<span class="pagination__item pagination__item--current">202/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/203/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>