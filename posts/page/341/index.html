<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d427fb2e9fd5f64b9474c4009eff9c68/" rel="bookmark">
			Java中Comparable接口和Comparator接口的区别（如果想知道Java中Comparable接口和Comparator接口的区别，那么只看这一篇就足够了！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：在Java中，Comparable 接口和 Comparator 接口都用于对象之间的比较和排序，但它们在使用和设计上存在一些关键的区别。
✨✨✨这里是秋刀鱼不做梦的BLOG
✨✨✨想要了解更多内容可以访问我的主页秋刀鱼不做梦-CSDN博客
本篇文章主要讲解的是Java中Comparable接口和Comparator接口的区别，先让我们看一下本篇文章的主要内容有哪些：
目录
1.Comparable接口和Comparator接口回顾
（1）Comparable接口
（2）Comparator接口
2.Comparable接口和Comparator接口的区别
【1】基本概念与位置
【2】实现方式与耦合性
【3】扩展性与维护性
【4】性能
3.Comparable接口和Comparator接口的使用建议
4.总结
1.Comparable接口和Comparator接口回顾 （1）Comparable接口 定义位置：Comparable接口是Java的核心库（java.lang）中的一部分。自然排序：实现了Comparable接口的类定义了一个自然的排序规则。这意味着类本身（而不是类的外部）决定了如何比较它的实例。方法：Comparable接口只有一个方法需要实现：int compareTo(T o)。这个方法用于比较当前对象与参数对象o的顺序。使用场景：当你希望一个类有一个固定的、自然的排序方式时，使用Comparable接口。例如，String、Integer、Double等类都实现了Comparable接口。 以下是一个Comparable接口的例子：
以下是一个简单的Java Comparable接口的例子，假设我们有一个Person类，我们想根据年龄对Person对象进行排序：
// 导入必要的包 import java.util.Arrays; // Person类实现了Comparable接口 public class Person implements Comparable&lt;Person&gt; { private String name; private int age; // 构造器 public Person(String name, int age) { this.name = name; this.age = age; } // getter和setter方法 public String getName() { return name; } public void setName(String name) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d427fb2e9fd5f64b9474c4009eff9c68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f7e55b67028d16ce658016da4d19285/" rel="bookmark">
			结合Django和Vue.js构建现代Web应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 创建Django项目2. 配置Django后端3. 创建Vue.js前端4. 连接Django和Vue.js5. 构建和部署 在现代Web开发中，结合后端框架和前端框架是非常常见的，其中Django作为一种流行的Python后端框架，而Vue.js则是一种灵活强大的前端框架。本文将介绍如何结合Django和Vue.js来构建现代化的Web应用。
1. 创建Django项目 首先，我们需要创建一个Django项目作为后端服务。假设你已经安装了Python和Django，可以使用以下命令来创建一个新的Django项目：
django-admin startproject myproject 然后，进入项目目录并创建一个新的应用程序：
cd myproject python manage.py startapp myapp 2. 配置Django后端 在Django项目中，我们需要配置后端以提供API服务给Vue.js前端。在myapp应用中，可以创建视图和模型来定义数据和业务逻辑，并使用Django REST framework来构建API。
# views.py from rest_framework import viewsets from .models import MyModel from .serializers import MyModelSerializer class MyModelViewSet(viewsets.ModelViewSet): queryset = MyModel.objects.all() serializer_class = MyModelSerializer # urls.py from django.urls import include, path from rest_framework import routers from .views import MyModelViewSet router = routers.DefaultRouter() router.register(r'mymodels', MyModelViewSet) urlpatterns = [ path('', include(router.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f7e55b67028d16ce658016da4d19285/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7117dcf42d6fa8e31424446783205212/" rel="bookmark">
			python pymodbus库使用教程（以Modbus RTU为例）（read_holding_registers()、read_input_registers()）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文档：
https://pymodbus.readthedocs.io/en/latest/
源码：
https://github.com/riptideio/pymodbus/
文章目录 Python PyModbus库使用教程：以Modbus RTU为例介绍安装PyModbus配置串行连接导入必要的模块创建Modbus客户端实例 建立连接连接到Modbus设备 读取数据读取寄存器关于读取其他寄存器以及查找pymodbus函数源码 写入数据写入单个寄存器写入多个寄存器 处理异常断开连接高级主题异步客户端（使用Twisted或Asyncio框架）自定义消息日志记录 实例1. 使用RS485 modbus协议读取温度湿度传感器数据 Python PyModbus库使用教程：以Modbus RTU为例 介绍 Modbus是一种工业领域广泛使用的通信协议，而PyModbus是一个在Python中实现Modbus通信的库。它支持多种Modbus模式，包括RTU（通过串行线路），ASCII和TCP/IP。本教程将重点介绍如何使用PyModbus库进行Modbus RTU通信。
安装PyModbus 在开始编写代码之前，需要确保已经安装了PyModbus库。可以使用pip命令轻松地安装：
pip install pymodbus 配置串行连接 导入必要的模块 首先，需要从pymodbus库中导入必要的模块：
from pymodbus.client.sync import ModbusSerialClient as ModbusClient 不知道是不是改版了，我用上面导入报错，用下面的可以：
from pymodbus.client import ModbusSerialClient as ModbusClient 创建Modbus客户端实例 接下来，创建一个ModbusClient实例，用于建立与Modbus设备的RTU通信：
client = ModbusClient(method='rtu', port='/dev/ttyUSB0', baudrate=9600) 在这里，method参数设置为'rtu'以指定通信协议，port参数根据实际连接的串行端口进行设置（例如Linux系统中可能是'/dev/ttyUSB0'，Windows中可能是'COM3'），baudrate参数设置传输速率，这些参数应与设备文档或配置相匹配。
建立连接 连接到Modbus设备 在配置好客户端实例后，尝试连接到Modbus设备：
if client.connect(): print("Modbus RTU Client Connected") else: print("Failed to connect to Modbus RTU Client") 读取数据 读取寄存器 Modbus协议定义了几种类型的寄存器，最常见的是保持寄存器和输入寄存器。以下示例展示了如何读取保持寄存器：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7117dcf42d6fa8e31424446783205212/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d16974cd64f2ffe6bb9c1efd015b4f6a/" rel="bookmark">
			基于小波熵阈值的心电信号R波检测算法（MATLAB）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		心脏兴奋电活动过程可由心电信号(ECG)来反映，心电信号也是医学上对心血管疾病诊断的重要科学依据。心电信号具有一定的随机性且一般情况下十分微弱，在信号采集、放大及变换过程中，心电信号容易受到人体呼吸及检测仪器等因素影响，从而引入多种不同种类的噪声，如基线漂移、工频干扰、肌电干扰等。这些噪声引入会使心电信号发生某种程度的畸变，从而给病情分析及诊断带来一定的影响。因此，医学诊断中心电信号去噪是心脏智能诊断所要研究的重要课题。
为减小或最大限度消除心电信号中存在的噪声干扰，目前，国内外的研究学者已提出多种去噪方法。小波变换具有多分辨率分析的特点，且是时频域化的数学工具，小波变换通常适用于对时变非平稳信号分析。在小波变换处理信号的过程中，最为重要的就是阈值的选取，Donoho和Johnstone提出固定阈值、无偏风险阈值、极大极小阈值和启发式阈值。这些阈值在去噪处理中效果十分显著但也具有一些缺点，例如:无偏风险阈值通常在小波系数稀疏时处理效果不明显;固定阈值去噪处理时过度平滑信号;极大极小阈值及启发式阈值对去噪重构后的信号在时域上得不到较好的处理效果。
针对传统小波阈值去噪算法不能有效去除心电信号中所参杂的基线漂移及工频干扰，重构信号会产生伪吉布斯现象。小波熵阈值去噪新算法是根据不同分解尺度上信号和噪声能量分布不同的特点，滤除一部分的基线漂移及工频干扰。
鉴于此，提出一种基于小波熵阈值的心电信号R波检测算法，运行环境为MATLAB 2018。
clear all close all clc select=input('enter a no to select mat file \n Options \n 0 for advanced options\n 1 for ECGDATA\n 2 for ravi \n 3 for matlabnew\n \n\n\');%select data switch select case 1 load('ECGDATA'); ecg=ECG_1; v=ecg; tmax=max(Time_Adjusted); t=Time_Adjusted; case 2 load('ravidata'); ecg=v; tmax=max(t); case 3 load('matlabnew'); ecg=v; tmax=max(t); otherwise name=input('enter the name of mat file consisting \necg samples in variable ''v'' \n and \ntime in variable ''t''\n\n\n','s') load(name); ecg=v; tmax=max(t); end sr=numel(ecg)/max(tmax); srate=['sampeling rate is ' num2str(sr)]; disp(srate) rt=['recording_time=' num2str(tmax) 'sec']; %完整代码：mbd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d16974cd64f2ffe6bb9c1efd015b4f6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e914fd033321edd9947ab4d56e09c78/" rel="bookmark">
			数据结构的直接插入排序（C语言版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.直接插入排序的基本概念 1.直接插入排序的基本思想 将数组分为已排序和未排序两部分。
每次从未排序部分取出一个元素,将其插入到已排序部分的合适位置,使得已排序部分保持有序。
重复步骤2,直到整个数组有序。
2.排序的工作原理 假设前 i-1 个元素已经有序,现在要将第 i 个元素插入到前 i-1 个有序元素中,使得前 i 个元素也有序。
为了插入第 i 个元素,需要先找到它在前 i-1 个元素中的适当位置。可以从右到左依次与前面的元素比较,找到第一个小于第 i 个元素的位置。
找到合适的位置后,将第 i 个元素插入到该位置,同时需要将位置之后的元素都向后移动一位。
重复步骤 1-3, 直到整个数组有序。
3.排序的优点 实现简单,编码容易。
对于部分有序的数组,直接插入排序的效率很高。
是一种稳定的排序算法,即相等元素的相对位置不会改变。
在数组规模较小时,直接插入排序的性能优于其他更复杂的排序算法。
4.排序的缺点 时间复杂度为O(n^2),在数据量较大时效率较低。
需要在数组中进行大量的数据移动操作,效率较低。
不适合于元素数量较大的数组排序。如果待排序数组基本有序,直接插入排序的效率会很高,但如果数组越乱,排序效率就会越低。
无法利用cpu的缓存机制,对于大规模数据排序,其性能会明显低于其他排序算法。
5.直接插入排序的功能 将无序数组或部分有序数组排列成升序序列。
维护数组中元素的相对顺序,即相等元素的相对位置不会改变。这使得直接插入排序是一种稳定的排序算法。
适用于小规模数据的排序,当数组规模较小时它的性能比较优秀。
对于部分有序的数组,直接插入排序的效率会很高,因为需要移动的元素较少。
可以改写为降序排序,只需要在插入时改为从后向前比较并插入即可。
可以作为其他排序算法的基础,如希尔排序就是基于直接插入排序改进而来的。
二.直接插入排序的代码实现 void insertionSort(int arr[], int n) { int i, j, key; for (i = 1; i &lt; n; i++) { key = arr[i]; j = i - 1; /* 将key插入到已排序的数组中 */ while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) { arr[j + 1] = arr[j]; j = j - 1; } arr[j + 1] = key; } } 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e914fd033321edd9947ab4d56e09c78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e97488eb5ddf3a9f6e327bd240bf3599/" rel="bookmark">
			【vscode 怎么实现ctrl&#43;鼠标左键点击模组，能够进入PYTHONPATH(第三方)的模组里面】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：vscode 怎么实现ctrl+鼠标左键点击模组，能够进入PYTHONPATH(第三方)的模组里面 很多时候，用vscode进行python开发的时候，ctrl+鼠标左键点击模组包的时候，不能跳转进模组包的源代码中，这是因为这个模组可能不是你python解释器中自带的，而是你自定义的模组，或者是你从网上下的一个模组，这个模组也没有经过.whl轮子安装进python解释器中。下面就是解决了这个问题的方法。
解决方法： 这里我就不语言赘述了，直接上图，按照我给的图来做，就没有问题。
1.第一大步
2.第二大步
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/049ccaf5d4a8d36ffcc68139b85d920e/" rel="bookmark">
			【数据结构】红黑树——领略天才的想法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人主页：东洛的克莱斯韦克-CSDN博客 祝福语：愿你拥抱自由的风 目录
二叉搜索树
AVL树
红黑树概述
性质详解
效率对比
旋转操作
元素操作
代码实现
二叉搜索树 【数据结构】二叉搜索树-CSDN博客
AVL树 【数据结构】AVL树——平衡二叉搜索树-CSDN博客
红黑树概述 概念
在二叉搜索树的基础上符合一下性质便是红黑树
每一个节点不是红色就是黑色
根节点一定是黑色
空节点一定是黑色
父亲节点和孩子节点不能是连续的红色节点
每一条根节点至空节点路径上的黑色节点的数量一定相等
​
性质详解 理解路径
红黑树中，一条完整路径不是从叶子节点溯源至根节点，而是从空节点溯源至根节点
​
理解最长和最短路径
如果全是黑色节点，红黑树就是一颗满二叉树，因为每条路径的黑色节点数量相等
​
那么这颗树的每条完整路径都是最短路径，
如果在一条路径上红黑节点间隔（不允许连续的有红色节点），那么该路径为最长路径。
​
红黑树规则
那么最长路径是最短路径的两倍。这便是红黑树的平衡规则。
满二叉树的平衡条件是左右子树高度差为0，AVL树的平衡条件是左右子树高度差小于等于 1，相比于前两棵树平衡条件，红黑树是一种弱平衡。
红黑树和AVL树一样，只要保证自己的平衡规则不被打破，就能使自己不退化为类似于链表的结构。
退化成类似链表的结构——插入的数据接近有序或插入大量的数据不够随机或进行了一些插入删除等操作。
效率对比 查找效率
从直觉上讲，红黑树只是维持一种弱平衡，在最坏情况下，红黑树的高度是AVL树高度的两倍，那么红黑树查找数据的效率也应该比AVL树低两倍才对，为什么我们认为红黑树是一种更优的数据结构呢？下面小编带大家算笔账
2的40次方是一万亿，也就是说用满二叉树存一万亿个数据高度为40。AVL树是有高度差的，所以最坏情况下会查找40多次，而红黑树最坏情况下会找80多次。
那么对于cpu而言，找40多次和找80多次有区别吗？答案是没有的，现在的cpu每秒钟可以运算十亿次甚至几百亿。
可以理解为，在查找数据的效率上AVL树和红黑树是一样的。那么，红黑树的优势在哪里呢？
插入删除效率
不管是红黑树还是AVL树，如果打破平衡都需要旋转这一操作恢复平衡，旋转所付出的时间复杂度为。对于AVL树而言，需要溯源更新平衡因子，对于红黑树而言，需要溯源更新节点颜色，溯源更新最坏情况下是从叶子节点更新到根节点，所付出的时间复杂度为。
因为AVL树的高度差小于等于1，平衡很容易被打破，要维持平衡就需要不断地付出和来维持平衡。
那么红黑树维持弱平衡就不需要总是付出这样地代价，所以红黑树是一种更优的数据结构
旋转操作 旋转操作不是AVL树或红黑树特有的，旋转一次的本质是让二叉搜索树的某棵子树的高度减一。
对于红黑树而言，最长路径是最短路径的二倍加一，就意味着打破平衡，需要通过旋转让最长路径上的某棵子树高度减一来恢复平衡。旋转后需要更新节点的颜色，具体要怎么控制颜色下面细讲，现在看一下旋转操作吧
左单旋：新节点插入较高右子树的右侧——对fathernode
​
void RevolveLeft(node *&amp; fathernode)//左单旋 { node* cur = fathernode-&gt;_right; //父亲节点的右孩子 fathernode-&gt;_right = cur-&gt;_left; //更改指向关系 if (cur-&gt;_left !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/049ccaf5d4a8d36ffcc68139b85d920e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba563198fc5a0e7a8b427f7959c8d61e/" rel="bookmark">
			C&#43;&#43;系列——————类和对象（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、面向对象的三大特征二、类的引入2.1类的定义 三.类的访问限定符3.1访问限定符的介绍3.2.访问限定符的使用 四、类的作用域五、类的实例化六、类对象模型6.1 如何计算类对象的大小 总结 前言 在学习C语言你可能听到过，C语言是面向过程的语言，关注的是过程，分析出求解问题的步骤，通过函数调用逐步解决问题。
C++是基于面向对象的，关注的是对象，将一件事情拆分成不同的对象，靠对象之间的交互完成
一、面向对象的三大特征 c++面向对象的语言，同样的具备面向对象的特性：分装、继承、多态。
特性一：封装
将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进交互。(简单来说，就好比我们在学习c语言时使用的一些函数如：printf函数,我们在使用它的时候并不知道它的底层是怎么实现的)
特性二：继承
继承是一个进程，通过一个进程，一个对象可以获得另一个对象的属性(数据和函数)，且可以想起加入属于自己的方法和属性。用这种方法可以自动的对一个类中提供另一个类的成员和数据结构。当A类被另B类继承,A类可以称之为基类或者父类；B类被称之为派生类或者子类。
特性三：多态
如果几个相似而不完全相同的对象，当对他发出同一个消息时，他们的反映各不相同，执行不同的操作。这种现象叫做多态现象。在C++中多态是指由继承而产生的相关的不同的类，其对象会对同一消息做出不同的相应。他能增加程序的灵活性。
二、类的引入 C语言中，结构体中只能定义变量，在C++中，结构体内不仅可以定义变量 ，也可以定义函数 。 在学习C语言时，我们并没有听到类的概念，c++是以C语言为基础，对其进行完善和拓展的，而c++是兼容C语言的，所以在c++中定义类的方式有两种。
struct classname { //成员变量 //成员函数 }; class classname { //成员变量 //成员函数 }; 当然以上两种方式存在差别，等一下我们会展开介绍。 2.1类的定义 代码如下（示例）：
也可以将关键字struct替换为关键字class(可以将class看作struct的升级版)
struct为定义类的关键字，stack为类的名字，{}中为类的主体，注意类定义结束时后面分号不能省略。
类体中内容称为类的成员：类中的变量称为类的属性或成员变量; 类中的函数称为类的方法或者成员函数。
这里需要注意，如果类的成员函数声明和定义都在类的内部，可能会被编译器当作内敛函数来处理。
上面结构体的定义，在C++中更喜欢用class来代替 三.类的访问限定符 3.1访问限定符的介绍 成员访问修饰符: 描述了类成员的访问控制，即所能使用的一个范围
公有的public：没有访问限制，其他类可以访问公有成员变量和方法。
保护的protected：只能在当前类和继承该类的子类中访问，受保护成员变量和方法对于其他类不可见。
私有的private ：只能在当前类中访问，其他类无法直接访问。
在上面我们提到，虽然c++支持使用关键字struct和class来创建类，但是这两种方法还是会存在差异：
对于使用关键字class创建的类，其默认成员函数及成员变量是私有的（只允许该种类创建出来的对象访问），若是想进行访问，必须使用关键字public来修饰。
使用关键字struct创建的类，默认成员变量及成员函数是共有的，可以对它直接访问，这里就不演示了。
3.2.访问限定符的使用 访问限定符的作用域，是从使用第一个访问限定符开始，直到出现下一个访问限定符为止,若是此后未再出现访问限定符，则生效区域直到类的结束。
示例：
四、类的作用域 类定义了一个新的作用域，类的所有成员都在类的作用域中。在类体外定义成员时，需要使用 ::作用域操作符指明成员属于哪个类域。 示例：（声明定义分离）
class Person { public: void PrtPerson(); private: char _name[20]; char _gender[3]; int _age; }; // 这里需要指定PrtPerson是属于Person这个类域 void Person::PrtPersonInfo() { cout&lt;&lt;_name&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba563198fc5a0e7a8b427f7959c8d61e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f56471685b9d8b91b0fd7f302b67e19/" rel="bookmark">
			Java如何将Word转换成PDF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
java中word转换PDF的常用用法
documents4j用法
java中word转换PDF的常用用法 1、POI
POI是Apache下的一个Java类库，可以帮助我们实现Java与各种Office格式文件的互相转换。(不推荐，只能用于文字的文档，如果有图片和表格则会排版错误)
2、Aspose.Words
Aspose.Words for Java是一个原生库，为开发人员提供了丰富的功能来创建、编辑和转换 Word、PDF、Web 文档，而无需在系统上安装 Microsoft Word 环境。这个工具非常好用，maven上有对应的依赖和jar包，但是转换后会有水印，因为他是（收费的）
3、spire.doc.free
Spire.Doc for Java是一个专业的 Word API，它使 Java 应用程序能够创建、转换、操作和打印 Word文档，而无需依赖 Microsoft Word。通过使用这个多功能库，开发人员可以轻松处理大量任务，例如插入图像、超链接、 数字签名、书签和水印、设置页眉和页脚、创建表格、设置背景图像以及添加脚注和尾注。这个跟aspose功能感觉有点差不多，也很好用，但是收费比对还是aspose更好用，而且这个也是收费的
4、documents4j
官网:https://documents4j.com/#/
GitHub:https://github.com/documents4j/documents4j
documents4j 是一个跨平台的文档转换库，并且可以在 Linux 上进行 Word 转 PDF 的操作。这个比较推荐，开源而且转换后也不会有格式错误(推荐)
documents4j用法 注意Windows和linux系统的代码不一样
1.Windows系统用法 1.导入依赖，本地必须要有wps或者微软的office
&lt;!--word转换为PDF文档--&gt; &lt;dependency&gt; &lt;groupId&gt;com.documents4j&lt;/groupId&gt; &lt;artifactId&gt;documents4j-local&lt;/artifactId&gt; &lt;version&gt;1.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.documents4j&lt;/groupId&gt; &lt;artifactId&gt;documents4j-transformer-msoffice-word&lt;/artifactId&gt; &lt;version&gt;1.0.3&lt;/version&gt; &lt;/dependency&gt; 2.编写转换代码(这里我都是传入input输出output然后根据流自己操作)
package com.daysuns.dmas.module.testReportwd.util; import com.documents4j.api.DocumentType; import com.documents4j.api.IConverter; import com.documents4j.job.LocalConverter; import lombok.extern.slf4j.Slf4j; import java.io.*; import java.nio.file.Files; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f56471685b9d8b91b0fd7f302b67e19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c48a9b4bebbb96e29e96810765ccc29/" rel="bookmark">
			【前端】web移动端进行监控是否完播 | 视频完播率设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、整体设计 1、前端播放监控： 使用移动端的前端播放器，比如 HTML5 video 标签或者第三方播放器（如 Video.js 或者 H5Player）。
在播放器中添加事件监听器来监控播放状态，例如 timeupdate、ended 等事件。
2、记录播放状态： 通过 timeupdate 事件不断记录当前播放时间。
在 ended 事件触发时，记录视频播放完毕的状态。
3、数据上报： 将播放状态和相关数据（如视频ID、用户ID、播放时长等）上报到后端服务器。
可以使用 AJAX 或 Fetch API 进行数据上报。
4、后端处理： 后端服务器接收到上报的数据后，可以将这些数据存储到数据库中，以便后续分析和监控。
2、代码实现 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Video Monitoring&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;video id="myVideo" width="320" height="240" controls&gt; &lt;source src="https://your-cos-url.com/your-video-file.mp4" type="video/mp4"&gt; Your browser does not support the video tag. &lt;/video&gt; &lt;script&gt; const video = document.getElementById('myVideo'); let totalWatchTime = 0; let lastTime = 0; let isPlaying = false; video.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c48a9b4bebbb96e29e96810765ccc29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f529c13576767cb76f07bd43bd678c92/" rel="bookmark">
			Java sort用法详解（二维数组排序，List＜＞排序,lambada表达式，自定义类型排序）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：
一维数组降序：
方法1.Comparator接口：
代码实现：
方法2.Collections.reverseOrder()：
代码实现： 二维数组排序：
代码如下：
List&lt;&gt;排序：
代码如下：
自定义类型比较排序：
按照年龄逆序排序：
按照姓名升序排序：
lambada表达式简写：
一维数组逆序代码：
二维数组排序代码：
List&lt;&gt;排序代码：
自定义类型排序：
结语：
前言： 由于最近刷一些比赛真题时，发现有一些题要先排序一下后面才能用贪心之类的算法解决，在比赛上面自己实现一个排序算法有点浪费时间（当然不是指冒泡插入之类的简单排序，太慢了😭），考虑到java中Arrays类中有sort方法我们可以引用sort来排序，升序简单那降序呢，一维数组会排序那二维数组和List&lt;&gt;呢? 本文章就是为了解决这些问题，希望对友友有所帮助。💕💕💕
我相信来看这个的一般都是有急用吧😭😭😭（作者曾经也是），如果很急的话直接看代码实现，直接模仿着写即可，其他的都是一些知识点的讲解。
要想使用sort排序，排序的对象必须实现comparable接口才行，由于Comparable不太灵活故本文章不做详细介绍。
一位数组的基本类型sort方法都能排序（升序）。
可以说的是一维数组降序和二维数组排序都是通过如下sort的重载方法即传入一个比较器（参数是泛型的不能是基本类型）。
一维数组降序： 声明:为了方便叙述下面采用int和Integer进行叙述其他类似。
经过多次尝试和查阅许多资料得出：要想把一维数组逆序如果是基本类型的话要把它变成包装类，
基本类型实现不了。
方法1.Comparator接口： 实现Comparator接口可以说是最常用的一种自定义排序操作了，它比Comparable更加灵活，想要根据什么比较直接自己实现就行，下面我们就开始对它的介绍💕：
Comparator是一个接口，既然接口那么我们实现它必须要重写它的抽象方法compare，必须要重写这一个（这个接口只有这一个方法）。
如果不实现就是出现如下错误。 实现比较器Comparator接口，上面&lt; T &gt;代表这是一个泛型（如果对泛型还不是很了解的话也没关系我们可以先会用就行），注意：泛型只能接受类，所有的基本数据类型必须使用包装类！，这就代表了我们要实现一维数组的逆序必须要把基本类型换成其包装类才行。否则会报如下错误。
代码实现： import java.util.Arrays; import java.util.Comparator; class cmp implements Comparator&lt;Integer&gt;{ @Override public int compare(Integer o1,Integer o2){ return o2 - o1; } } public class Test1 { public static void main(String[] args) { Integer[] nums = {1,2,3,4,5}; Arrays.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f529c13576767cb76f07bd43bd678c92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9f6968c8b24f445cb0ecf057d350e15/" rel="bookmark">
			【C&#43;&#43;/STL】vector（常见接口、模拟实现、迭代器失效）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页：秦jh_-CSDN博客
🔥 系列专栏： https://blog.csdn.net/qinjh_/category_12575764.html?spm=1001.2014.3001.5482
目录
简单使用
常见接口
find insert
vector模板
模拟实现
尾插
构造
迭代器失效
使用memcpy拷贝问题
花括号列表初始化
完整代码
前言 💬 hello! 各位铁子们大家好哇。
今日更新了vector的相关内容
🎉 欢迎大家关注🔍点赞👍收藏⭐️留言📝
vector是表示可变大小数组的序列容器。
简单使用 vector接口的使用跟string差不多，功能很多都类似。 常见接口 注意end是指向最后一个数据的下一个位置。
find find的使用需要包 &lt;algorithm&gt; 头文件
注意上面if语句的判断条件，找不到时，返回值是自己给的last，即上面的v.end()。
insert insert还可以插入一段迭代区间 vector模板 vector&lt;&gt; 括号里可以是不同的类型，如上面的string，还可以是list，vector等。 如下图：
模拟实现 尾插 上方是错误的模拟。因为_start已经改变了，_finish-_start就不是原本的空间大小了。正确代码如下：
size_t size() { return _finish - _start; } T&amp; operator[](size_t pos) { assert(pos &lt; size()); return _start[pos]; } size_t capacity() { return _endofstorage - _start; } void push_back(const T&amp; val) //传引用效率高 { if (_finish == _endofstorage) { size_t old_size = size(); size_t newcapacity = capacity() == 0 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9f6968c8b24f445cb0ecf057d350e15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7cebdbd150b05dbb8a323767b74a1a9/" rel="bookmark">
			【iOS】Block总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Block如何捕获外界变量1.捕获自动变量2.捕获静态局部变量3.全局、全局静态变量 二、__block修饰符三、Block的类型四、判断block存储在哪里五、Block的copy操作六、源码分析Block_copy()七、__block 与 __forwarding八、block发生copy的时机总结 前言 之前的Block写的没啥重点，这一次总结一下重点，比如Block如何捕获外界变量，__block的使用
一、Block如何捕获外界变量 1.捕获自动变量 首先先上代码，我们在Block中添加了localA局部变量
int main() { int localA = 7; void(^block)(void) = ^{ NSLog(@"block - %d - %d", localA, globalB); }; block(); localA += 10; block(); return 0; } 发现在外部修改localA并没有影响到Block内部
编译成源码
struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; int localA; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _localA, int flags=0) : localA(_localA) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; 可以看到Block实现结构体中新增了localA变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7cebdbd150b05dbb8a323767b74a1a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d08d2910ba1e608765564a5050cebb4/" rel="bookmark">
			Go 如何通过 Kafka 客户端库 生产与消费消息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0.前置说明1. confluent-kafka-go2. sarama3. segmentio/kafka-go4. franz-go选择建议 1.启动 kafka 集群2.安装 confluent-kafka-go 库3.创建生产者特殊文件说明如何查看.log文件内容 4.创建消费者 0.前置说明 Go 语言中有一些流行的 Kafka 客户端库。以下是几个常用的库及其优劣与区别：
1. confluent-kafka-go 优点：
高性能：基于 librdkafka，性能非常高。功能全面：支持 Kafka 的所有高级功能，如事务、压缩、认证等。社区支持：由 Confluent 维护，社区活跃，文档丰富。稳定性：广泛使用于生产环境，经过大量测试和验证。 缺点：
依赖性：依赖于 librdkafka，需要额外安装该库。复杂性：配置和使用相对复杂，特别是对于新手。 2. sarama 优点：
纯 Go 实现：不依赖于任何 C 库，安装和使用非常方便。社区活跃：由 Shopify 维护，社区支持良好，文档齐全。灵活性：提供了丰富的配置选项，适用于各种使用场景。 缺点：
性能：相对于 confluent-kafka-go，性能稍逊一筹。功能：不支持 Kafka 的一些高级功能，如事务。 3. segmentio/kafka-go 优点：
纯 Go 实现：不依赖于任何 C 库，安装和使用非常方便。简洁易用：API 设计简洁，易于上手。灵活性：支持多种配置选项，适用于各种使用场景。 缺点：
性能：相对于 confluent-kafka-go，性能稍逊一筹。功能：不支持 Kafka 的一些高级功能，如事务。 4. franz-go 优点：
纯 Go 实现：不依赖于任何 C 库，安装和使用非常方便。高性能：在纯 Go 实现中性能较为优越。功能全面：支持 Kafka 的大部分功能，包括事务。 缺点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d08d2910ba1e608765564a5050cebb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd8068c732487e9f8ae2ade0d77a818f/" rel="bookmark">
			C# 实现腾讯云点播之媒体管理常用接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
关于腾讯云点播媒体管理
开发前准备
范例运行环境
常用媒体管理API
删除媒体
禁播媒体
获取媒体详细信息
查询媒体
小结
关于腾讯云点播媒体管理 腾讯云点播（Video On Demand）服务基于多年技术积累与基础设施建设，为有音视频应用相关需求的客户提供包括音视频存储管理、音视频转码处理、音视频加速播放、音视频加密、音视频AI能力的一站式解决方案，可通过云平台进行上传后的媒资管理。
目前云点播服务使用的是 API 3.0 版本，要使用腾讯云点播 API，需要先执行以下步骤：
在腾讯云 云点播控制台 开通腾讯云点播（VOD）服务。在访问管理控制台中的 云 API 密钥 页面里获取 appid、secretid、secretkey 内容。调用 API 执行操作。 本文将主要介绍如何使用云点播服务之媒体管理相关的常用接口实现。
开发前准备 (1）调用 API 之前，需要生成 HMAC-SHA1加密返回签名，请参考如下代码：
/// HMAC-SHA1加密返回签名 &lt;param name="secret"&gt;密钥&lt;/param&gt; &lt;param name="strOrgData"&gt;源文&lt;/param&gt; public static string GetHmacSha1Sign(string secret, string strOrgData) { var hmacsha1 = new HMACSHA1(Encoding.UTF8.GetBytes(secret)); var dataBuffer = Encoding.UTF8.GetBytes(strOrgData); var hashBytes = hmacsha1.ComputeHash(dataBuffer); return Convert.ToBase64String(hashBytes); } (2）secretId 及 secretKey 的获取在后续范例中均封装为 TCAcount 类，创建及访问示例如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd8068c732487e9f8ae2ade0d77a818f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f454228e7303cc9f103a3bffc0dc2f3/" rel="bookmark">
			C# 实现腾讯云点播之媒体上传常用接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
关于腾讯云点播媒体管理
开发前准备
范例运行环境
常用上传API
申请上传
确认上传
拉取上传
小结
关于腾讯云点播媒体管理 腾讯云点播（Video On Demand）服务基于多年技术积累与基础设施建设，为有音视频应用相关需求的客户提供包括音视频存储管理、音视频转码处理、音视频加速播放、音视频加密、音视频AI能力的一站式解决方案，可通过云平台进行上传后的媒资管理。
目前云点播服务使用的是 API 3.0 版本，要使用腾讯云点播 API，需要先执行以下步骤：
在腾讯云 云点播控制台 开通腾讯云点播（VOD）服务。在访问管理控制台中的 云 API 密钥 页面里获取 appid、secretid、secretkey 内容。调用 API 执行操作。 本文将主要介绍如何使用云点播服务之媒体上传的常用接口实现。
开发前准备 (1）调用 API 之前，需要生成 HMAC-SHA1加密返回签名，请参考如下代码：
/// HMAC-SHA1加密返回签名 &lt;param name="secret"&gt;密钥&lt;/param&gt; &lt;param name="strOrgData"&gt;源文&lt;/param&gt; public static string GetHmacSha1Sign(string secret, string strOrgData) { var hmacsha1 = new HMACSHA1(Encoding.UTF8.GetBytes(secret)); var dataBuffer = Encoding.UTF8.GetBytes(strOrgData); var hashBytes = hmacsha1.ComputeHash(dataBuffer); return Convert.ToBase64String(hashBytes); } (2）secretId 及 secretKey 的获取在后续范例中均封装为 TCAcount 类，创建及访问示例如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f454228e7303cc9f103a3bffc0dc2f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c53d7ee7d98276ff1ca2f3e8963a235b/" rel="bookmark">
			智影AI轻松制作故事转视频AI创作神器！快速开启AI绘画小说推文之旅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.前言 1.1 生成内容形式1.2 小说推文说明 2.产品介绍2.1 产品说明2.2 功能说明 3.推文视频制作3.1 新建小说3.2 新建作品3.3 拆分文案3.4 角色/场景创建3.5 分镜管理3.6 合成视频 4.高阶功能说明4.1 角色/场景一致性4.2 重新生图4.3 合成视频4.4 动态视频 1.前言 1.1 生成内容形式 生成内容形式主要包含三种，PGC（Professionally Generated Content）、UGC（User Generated Content）、AIGC（Artificially Intelligent Generated Content）。也可以简单理解为生成内容形式的三个发展阶段。
PGC 专业生成内容
专业生成内容是由专业人士创作编辑发布内容。
简单来说是文章要由作者创作，新闻要由记者创作，专业的人创作内容。
该形式起源于传统媒体时代，例如报纸、杂志、电视、电影等。UGC 用户生成内容
用户生成内容是由普通用户创作编辑发布内容。
简单来说就是每个人都可以创作内容，通过互联网发布文字、视频、音频等内容。
是互联网趋势下的一种内容生成方式，对传统营销、广告、媒体等产业产生了重大影响。比如自媒体博主等。
优点是创作门槛低，内容更加个性化，缺点是信息泛滥，质量不一，监管难度大等。AIGC 人工智能生成内容
人工智能生成内容是AI创作生成内容。
简单来说就是已经发展到我们看到的内容可能就是AI制作的。
是人工智能发展阶段下的一种新型内容生成方式。利用自然语言处理技术与AI技术来生成内容。比如ChatGPT、PiKa、Sora、文心一言等。
应用范围广泛，发展到今天，已经支持多模态AI，允许输入文本、图片、视频等多种媒体素材，经由AIGC处理输出生成想要的文本、图片、视频、音频等内容。 1.2 小说推文说明 2021年起，市场开始探索小说推文，通过爆火小说，借助抖音、小红书、bilibili等平台发布小说推文视频，推流达到吸粉，引导付费的模式实现盈利，逐步发展趋于稳定盈利。
2023年是小说推文的爆发期，加上火爆的ChatGPT、Midjounery、TTSMAKER、剪映等平台支撑，形成了一套完善的生成式AI链路。极大的降低了小说推文制作门槛，且据统计当时随便制作一个推文视频，播放量基本上在20W左右。
2024年Sora发布的文生视频大模型，给国内外带来了极大震撼，时长接近1分钟，视频画质接近电影级。让人感叹AI已经发展到，快要不易区分人工制作内容和AI制作内容。同时也让国内感受到和国外在人工智能领域的差距。
2.产品介绍 本期说下国内小说推文工具，不是那种素材混剪的工具，而是借助多模态生成式AI，具备文生图、图生视频、文生视频能力的工具。
比如腾讯动态漫画、AI剧本、瓦兔推文、极虎漫剪、推文助手、智影AI等工具。
这些工具大都支持文生图能力，但支持图生视频能力仅腾讯动态漫画、智影AI。动态漫画生成分镜图片后，有个一键动效功能，允许将图片生成2s时长的视频。智影AI有一个动态视频功能，允许将图片生成4s的视频。
2.1 产品说明 智影AI，一款小白也能轻松制作故事转视频的AI创作神器。
官方地址，点击体验
2.2 功能说明 拆分文案
产品能够对故事文案进行拆分镜头，提取故事中的角色和场景；并自动绑定角色/场景和分镜镜头，达到角色场景一致性。
借助ChatGPT分析文案拆分分镜，提取角色场景。角色/场景创建
角色/场景支持新建编辑；支持调整角色描述重新生成角色图片。分镜管理
支持对分镜批量绑定关联角色/场景；镜头支持新建编辑；支持修改分镜描述重新生成分镜图片；支持分镜图片生成4s的动态视频。
借助Fooocus（已支持）、Midjounery（规划中）文生图能力，根据文本描述AI绘图。
借助Stable Diffusion Video（已支持）、PiKa（规划中）图生视频能力，根据分镜图片AI生成视频。合成视频
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c53d7ee7d98276ff1ca2f3e8963a235b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0128cc90d2ba6188e8f817769130934/" rel="bookmark">
			腾讯云 AI 代码助手、讯飞星火 API 全面开放；首个“AI 法案”正式通过 | AI 头条...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整理 | 王启隆
出品 | AI 科技大本营（ID：rgznai100）
一分钟速览新闻点！
科大讯飞震撼发布：星火 AI 模型 API 全面开放
腾讯云 AI 代码助手全面对外开放
AI Pin 开发团队 Humane 考虑出售公司
欧盟率先立法！全球首个人工智能法律框架“AI 法案”正式通过
上交大最新论文助力 AI 模型推理加速，GPU 内存占用大幅降低
革新多模态学习！哈工大团队推出“Uni-MoE”：统一多模态大模型的跨域 MoE
Sam Altman 回应安全争议：GPT-4 级别的 AI 系统已经“足够安全”
音乐界的“ChatGPT”：Suno 融资 1.25 亿美元
全球 AI 要闻
科大讯飞震撼发布：星火 AI 模型 API 全面开放
今日，国内人工智能领军企业科大讯飞宣布了一项重大举措，正式对公众开放其星火系列 API 能力，旨在赋能广大开发者与企业，推动 AI 技术应用进入全新阶段。此次开放不仅包括永久免费的星火 Lite API，更有 Pro/Max 版本 API 调用费用大幅度下调，最低至 0.21 元/万 tokens，极大降低了 AI 技术接入与应用的成本障碍。
科大讯飞此番动作，特别是对于处理复杂数据如长文本、长图文、长语音的能力开放，无疑为开发者提供了强有力的工具支持。这意味着无论是初创团队还是成熟企业，都能够更加便捷地将先进的自然语言处理、图像识别等技术融入产品与服务中，加速创新步伐，开拓 AI 应用场景的无限可能。
腾讯云 AI 代码助手全面对外开放
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0128cc90d2ba6188e8f817769130934/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30d0a42b145d567080709adb6e7df9e7/" rel="bookmark">
			【C语言】自定义类型：联合与枚举的简明概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥引言
关于自定义类型除了我们常用的结构体，还有联合与枚举也是属于自定义类型。本篇将简单介绍联合与枚举基本概念和使用方法
🌈个人主页：是店小二呀
🌈C语言笔记专栏：C语言笔记
🌈C++笔记专栏： C++笔记
🌈喜欢的诗句:无人扶我青云志 我自踏雪至山巅
文章目录 一、联合体(Union)1.1 联合体的声明1.2 联合体的特点1.3 结构体和联合体内存布局对比1.4 计算联合体的大小1.5 联合体的实际使用样例 二、Enum（枚举）2.1 枚举类型的声明2.2 枚举类型的优点2.3 枚举类型的使用 一、联合体(Union) 1.1 联合体的声明 联合体是一个或多个成员组成，其中成员可以是不同类型，并且所有成员共用同一块内存空间，所以联合体也称为共用体。联合体声明的关键字是union。
//联合体类型的声明 union Un { char c; int i; }; int main() { union Un un;//联合体的定义 sizeof("%d\n,sizeof(un)");--&gt;4 return 0; } 1.2 联合体的特点 联合体的特点:
联合体所有成员共用同一块内存空间，一个联合体变量的大小，至少是最大成员的大小，编译器只为最大的成员分配足够大的空间给联合体其中一个成员赋值，其他成员的值也会变化 代码一 union Un { char c; int i; }; int main() { union Un un = {0}; // 下⾯输出的结果是⼀样的吗？ printf("%p\n", &amp;(un.i)); printf("%p\n", &amp;(un.c)); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30d0a42b145d567080709adb6e7df9e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e44b067ea244238ddd220ad0d935afa/" rel="bookmark">
			基于PHP的新生儿疫苗接种管理系统&#43;87023（免费领源码）可做计算机毕业设计JAVA、PHP、爬虫、APP、小程序、C#、C&#43;&#43;、python、数据可视化、大数据、全套文案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PHP新生儿疫苗接种管理系统 摘 要 新生儿计划免疫是根据危害儿童健康的一些传染病，利用安全有效的疫苗，按照规定的免疫程序进行预防接种，提高新生儿免疫力，以达到预防相应传染病的目的。一直以来人们使用传统人工的方式管理文件档案，这种管理方式存在着许多缺点，如效率低、保密性差，另外时间一长，将产生大量的文件和数据，这对于查找、更新和维护都带来了不少的困难。因此迫切需要一套高效的新生儿疫苗接种管理系统对儿童免疫接种信息进行管理，以提高新生儿疫苗接种管理的效率，实现信息的科学化、正规化管理，达到检索迅速、查找方便、可靠性高、存储量大、保密性好、寿命长、成本低等目标。因此，开发这样一套新生儿疫苗接种管理软件成为很有必要的事情。
本文采用PHP语言、Thinkphp框架、Ajax技术进行业务系统的编码及其开发，划分为系统用户、接种员工和管理员三种角色，实现了对新生儿疫苗接种的查询、疫苗信息、疫苗入库、预约信息、儿童档案、财务信息、疫苗仓库等功能模块。经过了多次的测试和结果评估，该新生儿疫苗接种管理系统已经能够满足新生儿疫苗接种管理的实际应用的需要并可以成功上线运行使用了。
关键词：新生儿疫苗接种管理；PHP；Thinkphp
Abstract According to some infectious diseases that endanger children's health, the planned immunization of newborns is to use safe and effective vaccines to carry out vaccination according to the prescribed immunization procedures to improve the immunity of newborns, so as to achieve the purpose of preventing corresponding infectious diseases. For a long time, people have used traditional manual methods to manage files and archives.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e44b067ea244238ddd220ad0d935afa/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/340/">«</a>
	<span class="pagination__item pagination__item--current">341/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/342/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>