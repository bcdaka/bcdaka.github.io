<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb6511b152fa4fc3401e20b8ba66f402/" rel="bookmark">
			【python】OpenCV—Aruco
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Detect ArucoGuess Aruco Type Detect Aruco 学习参考来自：OpenCV基础（19）使用 OpenCV 和 Python 检测 ArUco 标记
更多使用细节可以参考：【python】OpenCV—Color Correction
源码：
链接：https://pan.baidu.com/s/1bEPuiix0MrtL7Fu3paoRug
提取码：123a
# ----------------------------- # USAGE # ----------------------------- # python detect_aruco_image.py --image images/example_01.png --type DICT_5X5_100 # python detect_aruco_image.py --image images/example_02.png --type DICT_ARUCO_ORIGINAL # ----------------------------- # IMPORTS # ----------------------------- # Import the necessary packages import argparse import imutils import cv2 import sys # Construct the argument parser and parse the arguments ap = argparse.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb6511b152fa4fc3401e20b8ba66f402/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b7e14097e3a4960148872df2f9ec977/" rel="bookmark">
			elasticsearch去重：collapse、cardinality、terms&#43;top_hits实现总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		码到三十五 ： 个人主页 目录 一 、collapse折叠去重原理用法注意事项 二、字段聚合(terms) + top_hits聚合 去重原理用法 三、两种方法的比较字段聚合(`terms`)+ `top_hits`聚合使用`collapse`功能对比总结 四、cardinality 统计去重后的数量原理用法precision_threshold 参数说明 五、collapse + cardinality 实现去重统计和查询 一 、collapse折叠去重 elasticsearch中的collapse功能允许用户对搜索结果进行分组，这在某些情况下可以看作是一种去重操作。它的主要目的是在搜索大量文档时，只显示每个分组的一个代表文档，而不是显示所有匹配的文档。
原理 collapse功能基于一个或多个字段的值对搜索结果进行分组。当你指定了collapse参数后，Elasticsearch会在后台对匹配的文档进行分组，并且每个分组只会返回一个代表文档。这个代表文档通常是分组中的第一个文档，但也可以通过其他参数进行定制。
用法 以下是如何在Elasticsearch查询中使用collapse的基本示例：
{ "query": { "match": { "field": "value" } }, "collapse": { "field": "group_field" } } 在这个示例中：
query部分定义了搜索的基本条件。在这个例子中，我们搜索字段field值为value的文档。collapse部分指定了用于分组的字段，即group_field。所有在这个字段上具有相同值的文档将被分组在一起，并且只返回一个代表文档。 你还可以通过添加inner_hits参数来定制返回的分组代表文档。例如，如果你想在每个分组中返回评分最高的文档，你可以这样做：
{ "query": { "match": { "field": "value" } }, "collapse": { "field": "group_field", "inner_hits": { "name": "most_relevant", "size": 1, "sort": [ { "_score": { "order": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b7e14097e3a4960148872df2f9ec977/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e76419a4d3c5cd8f42144a00ed0a132/" rel="bookmark">
			Cyuyanzhong的内存函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、memcpy函数的使用与模拟实现二、memmove函数的使用和模拟实现三、memset函数与memcmp函数的使用（一）、memset函数（内存块设置）（二）、memcmp函数（内存块比较） 总结 前言 提示：这里可以添加本文要记录的大概内容：
提示：以下是本篇文章正文内容，下面案例可供参考
前面已经介绍了关于字符串和单个字符的操作，本文主要介绍（任意类型）内存层面的操作函数，主要介绍
memcpy:内存拷贝
memmove:内存移动
memset:内存设置
memcmp:内存比较
这四类关于内存函数的 相关知识.它们的头文件都是&lt;string.h&gt;
一、memcpy函数的使用与模拟实现 函数库函数原型： void*memcpy(void*destination,const void*source,size_t num); 这个函数作用就是从source位置开始向后复制num个字节的数据到destination指向的内存位置。
关于这个函数注意以下几点：
num的单位是字节！！！一定要注意；
这个函数在遇到’\0’的时候不会停下来
如果source和destination有任何重叠，复制的结果是未定义，换句话说memcpy不负责重叠空间的拷贝！！，它只负责非重叠空间的拷贝，即destination和source所指向的空间没有重叠。memcpy函数的使用 #include&lt;stdio.h&gt; #include&lt;string.h&gt; int main() { int arr1[] = { 1,2,3,4,5,6,7,8,9,10 }; int arr2[20] = { 0 }; memcpy(arr2, arr1 + 2, 20);//计算的是字节数 int sz = sizeof(arr2) / sizeof(int); for (int i = 0; i &lt; sz; i++) { printf("%d,", arr2[i]); } } 运行结果：
这里很显然将arr1的数组中从3开始以后的20个字节内容（即4个整形）拷贝到arr2的前4个元素中。
memcpy函数的模拟实现 void* my_memcpy(void*dest,const void*src,size_t num) { //转换成char*，一个字节一个节搞，这样我们可以照顾所有数据类型 void* ret = dest; for (int i = 0; i &lt; num; i++) { *(char*)dest = *(char*)src; //这里不能用自加加,因为强转是临时型的。要展开来写 //(char*)dest++;这种写法不可以 dest = (char*)dest + 1; src = (char*)src + 1; } return ret;//返回起始地址 } int main() { int arr1[] = { 1,2,3,4,5,6,7,8,9,10 }; int arr2[20] = { 0 }; my_memcpy(arr2, arr1 + 2, 20);//计算的是字节数 int sz = sizeof(arr2) / sizeof(int); for (int i = 0; i &lt; sz; i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e76419a4d3c5cd8f42144a00ed0a132/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab54bc6a3978b07daf807384bbf3be6c/" rel="bookmark">
			微服务部署上线过程总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、找到适合自己的部署方式 二、开始部署，先安装需要的环境 2.1 梳理一下都需要安装什么软件
2.2 配置数据库环境
2.3 配置redis 2.4 配置nacos
2.5 配置rabbitmq
2.6 配置docker环境 三、环境配置好了，开始部署后端 3.1 梳理后端都有什么端口
3.2 部署后端
3.3 部署后端之前的项目配置
四、部署前端
五、域名配置 一、找到适合自己的部署方式 我使用的是宝塔linux部署，但是宝塔安装rabbitmq无法启动（暂时不知道什么原因），所以我最后选择在centos中部署项目。
选择centos部署的原因：
centos中原生部署有点麻烦，我选择在centos中安装了一个宝塔来部署，至于为什么我选择在centos中安装宝塔，是因为我宝塔启动不了rabbitmq，所以我打算在centos中安装rabbitmq，其他的软件都在宝塔安装就好了。（哈哈哈 投机取巧）
二、开始部署，先安装需要的环境 我使用的是腾讯云，在腾讯云买了一个2核8g的服务器，安装的是centos7.6的系统。
接下来就需要在centos中安装宝塔了，安装宝塔的详细步骤如下，跟着来就行了！
CentOS宝塔搭建（超详细）
宝塔搭建好了，就看下面步骤吧！！！ 2.1 梳理一下都需要安装什么软件 1. 需要数据库mysql8
2. 需要redis做缓存
3. 需要nacos做服务中心
4. 需要rabbitmq做消息队列
5. 我有个代码沙箱，所以还需要个docker 2.2 配置数据库环境 跟着我这篇博客一步一步来就好了，很简单 宝塔面板安装MySQL8数据库 2.3 配置redis 宝塔安装redis并且远程连接redis教程跟着我这篇博客一步一步来就好了，很简单 宝塔安装redis并且远程连接redis教程 2.4 配置nacos （1） 下载安装包 我需要2.2.0版本的，你需要什么版本自己去springcloud官网查看就行 地址 :http://https: github.com/alibaba/nacos/releases （2） 版本要选2.2.0.tar.gz （3）上传到服务器并安装
无脑安装：
进入目录 你放安装包的目录 cd /www/server/Nacos 解压 tar -xvf nacos-server-2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab54bc6a3978b07daf807384bbf3be6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e095e06a25b5a2e6b63fb3f1ba046b8e/" rel="bookmark">
			昇思25天学习打卡营第3天|数据集全攻略：加载、操作与自定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导入数据集相关库和类 首先，导入了 NumPy 库，并将其简称为 np 。要知道，NumPy 乃是用于科学计算的关键库，作用非凡。接着，从 mindspore.dataset 当中导入了 vision 模块。此外，还从 mindspore.dataset 里引入了 MnistDataset 和 GeneratorDataset 这两个与数据集紧密相关的类。最后，导入了 matplotlib 库的 pyplot 模块，并简称为 plt ，其主要用于实现数据的可视化。
代码如下：
import numpy as np from mindspore.dataset import vision from mindspore.dataset import MnistDataset, GeneratorDataset import matplotlib.pyplot as plt 数据集加载 首先是从开放数据集去下载数据，随后导入了一个叫“download”的功能模块或者函数。接下来，设定了一个字符串变量“url”，这个“url”代表着要下载的数据所在的网址。最后呢，调用“download”这个函数来下载“url”所指定的那些数据，并且把数据存放到当前的目录（“./”）当中。要注意哦，下载的这些数据是压缩文件（zip 格式的），要是本地已经有相同的文件了，那就会进行替换操作。
代码如下：
# Download data from open datasets from download import download url = "https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/" \ "notebook/datasets/MNIST_Data.zip" path = download(url, "./", kind="zip", replace=True) 运行结果：
创建了一个名为 train_dataset 的数据集对象，该数据集是基于“MNIST_Data/train”路径下的数据创建的 MnistDataset 类型，并且设置了不进行随机打乱（shuffle=False）。然后，打印出 train_dataset 的数据类型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e095e06a25b5a2e6b63fb3f1ba046b8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fb28d82d57d1a4e4ddd860a77f0d92f/" rel="bookmark">
			用MATLAB编写牛拉法潮流计算(电力系统稳态分析)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 用MATLAB形成节点导纳矩阵
文章目录 系列文章目录前言一、程序二、输入原始数据三、所求潮流计算总结 前言 本文通过编写m语言实现牛拉法求潮流计算，所用电力网络图是《用MATLAB形成节点导纳矩阵》中的第一张图。
在这里不讲解牛拉法原理，只贴出代码和相关步骤。
一、程序 n=input('n='); nl=input('nl='); isb=input('isb='); pr=input('pr='); B1=input('B1='); B2=input('B2='); X=input('X='); Y=zeros(n);e=zeros(1,n);f=zeros(1,n);V=zeros(1,n);O=zeros(1,n);S1=zeros(nl); for i=1:n if X(i,2)~=0; p=X(i,1); Y(p,p)=1./X(i,2); end end for i=1:nl if B1(i,6)==0 p=B1(i,1);q=B1(i,2); else p=B1(i,2);q=B1(i,1); end Y(p,q)=Y(p,q)-1./(B1(i,3)*B1(i,5)); Y(q,p)=Y(p,q); Y(q,q)=Y(q,q)+1./(B1(i,3)*B1(i,5)^2)+B1(i,4)./2; Y(p,p)=Y(p,p)+1./B1(i,3)+B1(i,4)./2; end G=real(Y);B=imag(Y); for i=1:n e(i)=real(B2(i,3)); f(i)=imag(B2(i,3)); V(i)=B2(i,4); end for i=1:n S(i)=B2(i,1)-B2(i,2); B(i,i)=B(i,i)+B2(i,5); end P=real(S);Q=imag(S); ICT1=0;IT2=1;N0=2*n;N=N0+1;a=0; while IT2~=0 IT2=0;a=a+1; for i=1:n if i~=isb C(i)=0; D(i)=0; for j1=1:n C(i)=C(i)+G(i,j1)*e(j1)-B(i,j1)*f(j1); D(i)=D(i)+G(i,j1)*f(j1)+B(i,j1)*e(j1); end P1=C(i)*e(i)+f(i)*D(i); Q1=f(i)*C(i)-D(i)*e(i); V2=e(i)^2+f(i)^2; if B2(i,6)~=3 DP=P(i)-P1; DQ=Q(i)-Q1; for j1=1:n if j1~=isb&amp;j1~=i X1=-G(i,j1)*e(i)-B(i,j1)*f(i); X2=B(i,j1)*e(i)-G(i,j1)*f(i); X3=X2; X4=-X1; p=2*i-1;q=2*j1-1;J(p,q)=X3;J(p,N)=DQ;m=p+1; J(m,q)=X1;J(m,N)=DP;q=q+1;J(p,q)=X4;J(m,q)=X2; elseif j1==i&amp;j1~=isb X1=-C(i)-G(i,i)*e(i)-B(i,i)*f(i); X2=-D(i)+B(i,i)*e(i)-G(i,i)*f(i); X3=D(i)+B(i,i)*e(i)-G(i,i)*f(i); X4=-C(i)+G(i,i)*e(i)+B(i,i)*f(i); p=2*i-1;q=2*j1-1;J(p,q)=X3;J(p,N)=DQ;m=p+1; J(m,q)=X1;J(m,N)=DP;q=q+1;J(p,q)=X4;J(m,q)=X2; end end else DP=P(i)-P1; DV=V(i)^2-V2; for j1=1:n if j1~=isb&amp;j1~=i X1=-G(i,j1)*e(i)-B(i,j1)*f(i); X2=B(i,j1)*e(i)-G(i,j1)*f(i); X5=0; X6=0; p=2*i-1;q=2*j1-1;J(p,q)=X5;J(p,N)=DV;m=p+1; J(m,q)=X1;J(m,N)=DP;q=q+1;J(p,q)=X6;J(m,q)=X2; elseif j1==i&amp;j1~=isb X1=-C(i)-G(i,i)*e(i)-B(i,i)*f(i); X2=-D(i)+B(i,i)*e(i)-G(i,i)*f(i); X5=-2*e(i); X6=-2*f(i); p=2*i-1;q=2*j1-1;J(p,q)=X5;J(p,N)=DV;m=p+1; J(m,q)=X1;J(m,N)=DP;q=q+1;J(p,q)=X6;J(m,q)=X2; end end end end end for k=3:N0 k1=k+1;N1=N; for k2=k1:N1 J(k,k2)=J(k,k2).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fb28d82d57d1a4e4ddd860a77f0d92f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fc1d9e6973f20b03176fbd9816f036a/" rel="bookmark">
			开源C&#43;&#43;智能语音识别库whisper.cpp开发使用入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		whisper.cpp是一个C++编写的轻量级开源智能语音识别库，是基于openai的开源python智能语音模型whisper的移植版本，依赖项少，内存占用低，性能更优，方便作为依赖库集成的到应用程序中提供语音识别功能。
以下基于whisper.cpp的源码利用C++ api来开发实例demo演示读取本地音频文件并转成文字。
项目结构 whispercpp_starter - whisper.cpp-v1.5.0 - src |- main.cpp - CMakeLists.txt CMakeLists.txt
cmake_minimum_required(VERSION 3.15) project(whispercpp_starter) set(CMAKE_CXX_STANDARD 14) set(CMAKE_CXX_STANDARD_REQUIRED ON) add_subdirectory(whisper.cpp-v1.5.0) include_directories( ${CMAKE_CURRENT_SOURCE_DIR}/whisper.cpp-v1.5.0 ${CMAKE_CURRENT_SOURCE_DIR}/whisper.cpp-v1.5.0/examples ) file(GLOB SRC src/*.h src/*.cpp ) add_executable(${PROJECT_NAME} ${SRC}) target_link_libraries(${PROJECT_NAME} common whisper # remember to copy dll or so to bin folder ) main.cpp
#include &lt;cmath&gt; #include &lt;fstream&gt; #include &lt;cstdio&gt; #include &lt;string&gt; #include &lt;thread&gt; #include &lt;vector&gt; #include &lt;cstring&gt; #include "common.h" #include "whisper.h" #if defined(_MSC_VER) #pragma warning(disable: 4244 4267) // possible loss of data #endif // Terminal color map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fc1d9e6973f20b03176fbd9816f036a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc2982dd83468930e6eee6f217ac4367/" rel="bookmark">
			MySQL84 -- ERROR 1524 (HY000): Plugin ‘msql_native_password‘ is not loaded.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【问题描述】
MySQL 8.4版本，配置用户使用mysql_native_password认证插件验证用户身份，报错：
【解决方法】（Windows, MySQL 8.4) 1、修改MySQL配置文件my.ini，在[mysqld]段添加mysql_native_password=ON。
2、管理员身份启动mysql命令行，重启mysql。
3、 修改认证方式。
4、navicat连接mysql。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6aab642ba6bb7c9373d162661b635e0d/" rel="bookmark">
			django模型、项目、配置、模型类、数据库操作、查询、F/Q对象、字段类型、聚合函数、排序函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模型重点
模型配置数据的增删改 增:book = BookInfo() book.save() 和BookInfo.objects.create()删:book.delete() 和BookInfo.objects.get().delete()改:book.name='xxx' book.save() 和 BookInfo.objects.get().update(name=xxx)数据的查询 基础查询F对象和Q对象关联查询 查询集QuerySet
MVT图解
一、项目准备 1.1创建项目与应用 django-admin startproject bookmanager python manager.py startapp book 1.2安装应用 1.3本地化 1.4模板路径 在应用同级目录下,创建templates模板文件夹
1.5项目中匹配urls 正则 : 路径只要不是admin/就算匹配成功。并包含到应用中的urls.py
1.6准备视图 1.7应用中匹配urls.py 应用中创建 urls.py 正则 : 路径中包含bookls/，就调用视图中对应的bookList函数
1.8开启服务器, 测试项目 # 进入项目文件中, 开启项目对应的服务器 python manage.py runserver # 浏览器中输入网址 http://127.0.0.1:8000/bookls/ 二、配置 在settings.py中保存了数据库的连接配置信息，Django默认初始配置使用sqlite数据库。
DATABASES = { 'default': { 'ENGINE': 'django.db.backends.sqlite3', 'NAME': BASE_DIR / 'db.sqlite3', } } 在Django的工程同名子目录的__init__.py文件中添加如下语句 修改DATABASES配置信息
DATABASES = { 'default': { 'ENGINE': 'django.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6aab642ba6bb7c9373d162661b635e0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d662d25e51ca5c95caedfe27d2ecc04b/" rel="bookmark">
			我在高职教STM32——GPIO入门之按键输入（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是老耿，高职青椒一枚，一直从事单片机、嵌入式、物联网等课程的教学。对于高职的学生层次，同行应该都懂的，老师在课堂上教学几乎是没什么成就感的。正因如此，才有了借助 CSDN 平台寻求认同感和成就感的想法。在这里，我准备陆续把自己花了很多心思的教学设计分享出来，主要面向广大师生朋友，单片机老鸟就略过吧。欢迎点赞+关注，各位的支持是本人持续输出的动力，多谢多谢！
前面，我们介绍了STM32的IO口作为输出的使用，这一章，我们将向大家介绍如何使用IO口作为输入。在本章中，我们将利用开发板上的按键来控制LED的亮灭。通过本章的学习，我们将明白按键的电路原理，了解按键消抖是怎么回事，巩固GPIO的初始化配置，学习GPIO端口输入函数等知识。
【学习目标】 了解按键防抖、锁存的方法巩固GPIO初始化的过程，独立完成代码编写理解按键单击、双击、长按的程序算法 按键是初学嵌入式的第一类输入器件，入门不难，但是一旦按法多样化（单击/双击/长按），或是结合其他被控器件，就需要用上中断、定时器、状态机等知识，难度也就上来了。本章还是基于GPIO输入电平的传统方法来按键，计划分两个部分，本文是第二部分。
三、按键的单击/双击/长按 电子产品上的轻触按键，除了单击，双击和长按也是比较普遍的输入方式，这样可以在同一个按键上实现更多的控制效果，鼠标就是典型的例子。上一节的程序仅能检测单击这个动作，这一节，我们就来学习一下如何通过一定算法，把这三种动作都能检测出来。
3.1 编程要点 我们来分析三种动作的按键IO口电平变化，如图7所示，看看各自有何特征。首先，无论何种动作，都是从按下这个动作开始的。接下来，就是要看按下的时长了，如果超过了长按标准（图中的S3，如2s），那么毫无疑问肯定是长按了，也就排除了单击和双击。因此，从逻辑上来看，判断出长按所需的条件是最少的。
其次，如果按下的时长小于S3，也就是说没到长按标准就松开了，那么就只能是单击或双击其中一种可能。这时，看的就是松开的时长了，如果超过了两次单击间隔标准（图中的D1，如250ms），那么就不是双击了，只能是单击。反之，就是双击。所以，单击或双击的判断依据就变成了“按下时长小于S3 且 松开时长是否小于D1”这样的双重条件了。
最后，还有一种可能，那就是无动作。当然，发生这种情况的条件是没有按下这个动作发生。这种情况其实是程序的初态，或者说是完成一次按键动作后应该回归的状态。至此，本程序的目的就是要通过一系列条件判断得到“单击/双击/长按/无动作”其中一种结果。
图7 单击/双击/长按对应的IO口电平变化 3.2 代码剖析 本实验的硬件电路和工程文件清单跟上一个实验一样，但文件中的代码发生了较大变化，因此我们将上一个实验的工程文件另存一份再进行编写，这样不会混淆。需要说明的是，这里为了节省篇幅和排版需要，一些与之前重复的代码做了省略，阅读时请注意，完整的源码请阅读本实验配套的工程。
1. key.h文件源码 如代码清单4所示，这个头文件了增加了很多跟按键动作有关的宏，其实就是把每个按键的每一种可能都起好名字，编好数字。当然，还有一个用来扫描按键动作的函数声明 Key_Scan()，其代码也是本实验的重点。
//------------------------------------------------------- // 代码清单4：补充与完善后的key.h //------------------------------------------------------- #ifndef _KEY_H_ #define _KEY_H_ #include "stm32f10x.h" //------------------------------------------------------- // 与按键状态和动作有关的宏定义 //------------------------------------------------------- #define KEY_DOWN	0 #define KEY_UP	1 #define KEY1_DOWN	10 #define KEY1_UP	11 #define KEY1_DOUBLE	12 #define KEY1_DOWNLONG	13 #define KEY2_DOWN	20 #define KEY2_UP	21 #define KEY2_DOUBLE	22 #define KEY2_DOWNLONG	23 #define KEY3_DOWN	30 #define KEY3_UP	31 #define KEY3_DOUBLE	32 #define KEY3_DOWNLONG	33 #define KEY4_DOWN	40 #define KEY4_UP	41 #define KEY4_DOUBLE	42 #define KEY4_DOWNLONG	43 #define KEY_NONE	255 #define KEYDOWN_LONG_TIME	200	//长按标准，单位为10ms //------------------------------------------------------- // 必要的宏定义 //------------------------------------------------------- #define KEY1_PIN GPIO_Pin_13 #define KEY2_PIN GPIO_Pin_11 #define KEY3_PIN GPIO_Pin_12 #define KEY4_PIN GPIO_Pin_2 //------------------------------------------------------- // 库函数操作宏定义 //------------------------------------------------------- #define READ_KEY1	GPIO_ReadInputDataBit(GPIOC, KEY1_PIN) #define READ_KEY2	GPIO_ReadInputDataBit(GPIOC, KEY2_PIN) #define READ_KEY3	GPIO_ReadInputDataBit(GPIOC, KEY3_PIN) #define READ_KEY4	GPIO_ReadInputDataBit(GPIOD, KEY4_PIN) //-------------------------------------------------------- // 函数声明 //-------------------------------------------------------- void Key_Init(void);	//按键初始化函数 u8 Key_Scan(void);	//按键扫描函数	#endif 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d662d25e51ca5c95caedfe27d2ecc04b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a6a6083c9ce0dcc4cb65ea3d6b1b9e3/" rel="bookmark">
			树莓派4B学习笔记14：Python多线程编程_线程间的同步通信_(锁‘threading.Lock’)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今日继续学习树莓派4B 4G：（Raspberry Pi，简称RPi或RasPi）
本人所用树莓派4B 装载的系统与版本如下:
版本可用命令 (lsb_release -a) 查询:
Opencv 版本是4.5.1：
今日学习树莓派与Python的多进程编程_线程间同步通信
文章提供测试代码讲解，整体代码贴出、测试效果图
目录
建立简单的多线程：
创建一个新的线程对象：
代码示例：
测试效果与解释：
join方法的使用：
线程间的同步与通信：
问题代码与说明：
竞态条件：
使用锁同步对共享资源的访问：
代码改进提示：
网上学习网址贴出：
建立简单的多线程： 创建一个新的线程对象： threading.Thread 类用于创建一个新的线程对象。
这个类接受几个参数，其中最重要的是 target 和 args
target
target 参数是一个可调用的对象（如函数或方法），当线程启动时，这个对象会被线程执行。在这个例子中，target 被设置为 counter 函数，所以新创建的线程会执行 counter 函数。
args
args 参数是一个元组，用于给 target 函数传递参数。在这个例子中，args 是一个只包含一个元素的元组，即字符串 "计数A"。当 t1 线程启动并调用 counter 函数时，它会传递这个字符串作为参数。
需要注意的是，由于 args 需要是一个元组，所以即使只传递一个参数，也需要用逗号 , 来表明它是一个元组（在只有一个元素的元组后面加上逗号是一个常见的约定）。
代码示例： 以下代码简单示例了如何编写一个简单的多线程程序：
# -*- coding: utf-8 -*- import time import threading def counter(name): for i in range(5): print(name, i) time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a6a6083c9ce0dcc4cb65ea3d6b1b9e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69420da790ef5e4bc334e840f6906a83/" rel="bookmark">
			同步模式之保护性暂停模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Guarded Suspension：一个线程需要等待另一个线程的执行结果
2. 理解
一个线程需要将结果传递给另一个线程，将这两个线程关联到到同一个 GuardedObject 如果需要源源不断地传递结果，需要使用消息队列（生产者-消费者模型）JDK 中，join 的实现、Future 的实现用的都是保护性暂停模式因为要等待，所以算作同步模式 3. 实现
创建两个线程和一个守护对象，线程 1 wait 等待下载结果 response，线程 2 执行下载，下载完成将结果赋值给 GuardedObject 的 response 属性，然后 notify 唤醒线程 1，线程 1 被唤醒，继续执行，两个线程通过 GuardedObject 传递要用的结果 4. 优点
join 需要等一个线程运行结束了才能得到该线程的结果join 等待结果的变量只能是全局的，GuardedObject 可以是局部的 5. 扩展 1
超时退出：wait(timeout) 只等待一段时间，如果超时了还没有获取到结果就直接退出循环 （resposne 是下载完成之后赋值的，response 不为空之后就可以退出循环，返回 res） 6. join 的原理：保护性暂停是等待一个线程的结果，join 是等待一个线程的结束
就是应用了保护性暂停模式，如果线程还存活（对应上面的下载结果 response == null）且未超时就一直等待，如果超时了（还没有得到结果）就退出循环 /** * Waits at most {@code millis} milliseconds for this thread to * die. A timeout of {@code 0} means to wait forever.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69420da790ef5e4bc334e840f6906a83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76b0157b9b651d619dc8015bdcb6487d/" rel="bookmark">
			Mac版CodeFormer，超强AI人脸修复工具本地运行包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mac版CodeFormer，超强AI人脸修复工具本地运行包 你有没有遇到过那些模糊不清、破损严重的老照片，想要修复却无从下手？或者拥有一些珍贵的视频片段，但因为画质太差而无法欣赏？别担心，今天我为你推荐一款神奇的工具，它的名字叫做——CodeFormer。
什么是CodeFormer？ CodeFormer被誉为“业界顶尖AI去马赛克工具”，它能有效清除学习和研究道路上的障碍。这款工具运用了尖端的神经网络AI技术，能够精确地修复各种破损、模糊、不完整以及黑白的照片和视频，效果令人瞩目！
🐼 旧照片的智能修复 你家的旧照片可能在时间的推移中变得模糊不清。CodeFormer能让这些珍贵的记忆焕然一新。
高精度脸部修复 是不是有些照片因为模糊的脸部细节而失去了光彩？CodeFormer能帮你找回那些被遗忘的面孔。
脸部色彩增强与修复 黑白照片也能变得栩栩如生，CodeFormer不仅能修复，还能增强脸部色彩。
脸部细节填充修复 那些残缺不全的面孔，CodeFormer也能帮你补全。
功能特点 一键式操作：CodeFormer提供简洁明了的用户界面，用户只需上传需要清晰化的图片或视频，点击一键即可完成整个清晰化过程，无需复杂的参数设置。
批量处理：支持批量导入图片和视频文件，一次性完成多个文件的清晰化操作，大大提高了工作效率。
智能优化：利用深度学习技术，CodeFormer能够自动识别图像中的模糊部分，并对其进行智能优化，使图像更加清晰。
高质量输出：清晰化后的图片和视频保持较高的分辨率和画质，满足用户在不同场景下的使用需求。
安装指南 为了简化安装流程，上述工具已经封装成了一个独立的启动包，用户只需简单点击即可运行，无需配置繁琐的Python环境。以下是获取和安装该应用的详细步骤：
下载应用 前往下载页面：Mac版CodeFormer，超强AI人脸修复工具本地运行包_AI MAC范，点击页面右侧的下载按钮进行下载。
注意：仅支持搭载有 Mac M1/2/3 系列芯片的设备。
安装步骤 从上述链接下载DMG镜像文件,将app文件拖拽到Applications文件夹中。
复制安装完成后，首次启动先不要在启动台打开，在应用程序文件夹右键打开。
软件会自动在默认浏览器打开操作界面，地址为 http://127.0.0.1:7860/，此时可以开始在浏览器中使用。
结语 是不是已经迫不及待想要试试这款神奇的工具了？赶紧下载体验吧，让你的旧照片和视频焕发新生！如果你觉得这篇文章对你有帮助，记得点赞、在看、转发三连哦～ 😊
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a925ffd994ba5c97bc03faf3237b7d5/" rel="bookmark">
			基于algorithm2e的LaTeX算法流程使用 (含中英文模板)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于algorithm2e的LaTeX算法流程使用 [含中英文模板] 使用介绍中文模板英文模板参考文献 使用介绍 采用 LaTeX \LaTeX LATE​X写算法流程，可以采用以下三种方式：
采用algpseudocode和algorithm宏包实现采用algorithmic和algorithm宏包实现采用algorithm2e宏包实现 根据使用者的使用偏好，可以选择不同的实现方式。本文考虑采用algorithm2e宏包实现 LaTeX \LaTeX LATE​X的算法流程。
使用前，需要导入algorithm2e宏包，即
\usepackage[linesnumbered,ruled,noline]{algorithm2e} 其中, [ ] [\quad ] []中的内容为算法的选项说明，linesnumbered表示显示数字行号，ruled表示将算法名放在算法的开头，noline表示不添加连接线。更多选项可以参考algorithm2e的官方文档。
如果需要使用中文，则需要导入ctex宏包，即
\usepackage[UTF8]{ctex} 并可以通过定义等价命令的方式将算法的关键词改为中文，即
\renewcommand{\algorithmcfname}{算法} \SetKwInOut{KwIn}{输入} \SetKwInOut{KwOut}{输出} 算法的基本环境为
\begin{algorithm} % your algorithm here. \end{algorithm} 算法由标题、输入、输出、主体部分组成。
算法标题的添加方式为
\caption{title of your algorithm} 算法输入的添加方式为
\KwIn{Your algorithm input} 算法输出的添加方式为
\KwOut{Your algorithm output} 在algorithm2e中，用 \; 命令表示换行，默认在行末显示分号
如果不想显示分号，可以在算法环境中添加
\DontPrintSemicolon 下面简要介绍algorithm2e的关键词用法
for循环的实现方式为
\For{condition}{ for block} if的实现方式为
\If{condition}{ then block} if-else的实现方式为
\eIf{condition}{ then block 1} { then block 2} if-elseif-else的实现方式为
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a925ffd994ba5c97bc03faf3237b7d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83153de68cbf17f4d2e225ad97df12c3/" rel="bookmark">
			【AI 大模型】大模型应用架构 ( 业务架构 - AI Embedded、AI Copilot、AI Agent | 技术架构 - 提示词、代理 &#43; 函数调用、RAG、Fine-tuning )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、大模型技术方向 - 大模型训练 / 大模型应用二、大模型应用 - 业务架构1、AI Embedded 模式2、AI Copilot 模式3、AI Agent 模式 三、大模型应用 - 技术架构1、提示词 技术架构2、Agent + Function Calling 技术架构3、RAG 技术架构4、Fine-tuning 微调 技术架构 一、大模型技术方向 - 大模型训练 / 大模型应用 大模型技术 分为两个方向 :
训练大模型 : 少数实力强的公司做这件事 , 如 OpenAI 训练 ChatGPT 大模型 , 百度训练 文心一言 大模型 , 这种技术岗位很少全世界也就几千个 , 技术难度很高 ;大模型应用 : 使用 别人训练好的大模型 , 建立自己的应用 ; 开发在各个平台上使用的 AI 应用 , 如 : 将 GPT 大模型集成到自己的应用中 ; 如 : Android 应用 , Python 应用 中 ;几乎所有的开发者都要学会 大模型应用 开发 , 其本质就是调用第三方库 ;在上一篇博客 【AI 大模型】OpenAI 接口调用 ① ( 安装 openai 软件包 | 查看 openai 软件包版本 | PyCharm 中开发 Python 程序调用 OpenAI 接口 ) 中 , 就是开发了一个应用 , 集成了 OpenAI 的软件包 , 可以调用 OpenAI 接口使用大模型的功能 ; 二、大模型应用 - 业务架构 1、AI Embedded 模式 应用程序 是 传统应用 , 大模型被嵌入到现有的应用程序或服务中 , 作为一个组成部分 , 仅在其中的某个环节 , 使用了 AI 大模型技术 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83153de68cbf17f4d2e225ad97df12c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc053adf247dabcb0a69310e8a0c717a/" rel="bookmark">
			SpringBoot&#43;SpringSecurity OAuth2 认证服务搭建实战 （六）OAuth2经典场景~授权码模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统要求 JDK17
spring-security-oauth2-authorization-server 1.3.0 以上
spring-boot-starter-oauth2-client 3.3.0 以上
Spring Boot 3.3.0 以上
修改 C:\Windows\System32\drivers\etc\hosts文件。（如果授权服务器和客户端在不同的域名下，就不用修改了）
构建授权服务 POM内容 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.oauth.server.demo&lt;/groupId&gt; &lt;artifactId&gt;oauth_server&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;oauth_server&lt;/name&gt; &lt;description&gt;OAuth2 Server Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;17&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-oauth2-authorization-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc053adf247dabcb0a69310e8a0c717a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89c10d0ab01a06ee191f3a8cff278cf0/" rel="bookmark">
			【专业英语 背诵】3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第11章 Database data integrity（数据完整性）data redundancy（数据冗余） -
Data warehouse（数据仓库）：由组织从各种外部和内部的数据库收集的信息存储在这种类型的数据库。hierarchical database（层次数据库）：每个条目都有一个父节点，父节点有多个子节点。Object-Oriented database（面向对象的数据库）：不仅存数据，还存操作数据的指令。multidimensional database（多维数据库）：也叫data cube（数据立方体），将数据视为三面或更多面得到立方体。company database（企业数据库）：需要通过连接到局域网的个人电脑进行访问。 -
real-time processing（实时处理）batch processing（批处理）：每月银行账单用的这个。group processing（分组处理） LexisNexis（词汇）：提供法律、商业、新闻等多领域信息检索服务的数据库。ProQuest Dialog：提供全球性学术文献的信息检索平台。CSI：用于法律法规方面的检索。Dow Jones Factiva：提供全球商业和新闻信息的数据库服务。 第12章 Syetem Analysis and Design Grid chart（网格图）：显示输入输出文档之前的关系。System audit（系统审计）：确定新程序是否实际提高了生产力。System design report（系统设计报告）：展示了成本与收益，并概述了替代设计对组织的影响。system analysis report（系统分析报告）：描述了当前的信息系统，新系统的需求以及可能得发展时间表。 -
系统生命周期
Phase 1:Preliminary Investigation（初步调查）：提出替换解决方案。Phase 2:System AnalysisPhase 3:systems design：设计新的或替代的信息系统。Phase 5:system implementation（系统实现）：另一个名字叫conversion（转换），在此阶段，安装了新的系统，用户也接受了新系统的培训。Phase 6:maintenance（维修）：大多数系统在该阶段花费时间或金钱更多，被认为是一场持续的活动。 -
系统的直接实现方法被认为是最有风险的。并行系统实行方法仅在失败或中断操作的成本大的情况下使用。系统分析和设计是检查改进信息系统的手段（程序）。Operational feasibility（操作可行性）：确定提议的系统是否实际可以运行。 第13章 Programming and languages top-down program design（自上而下的软件设计）Program specifications document（项目规范文档）程序维护领域的活动分为两类：operations 和 changing needs。 -
pseudocode（伪代码）symbol（符号）debug（调试）syntax error（语法错误）：违反编程语言的错误。 -
Beta testing（β测试）：由一组选定的潜在用户对程序进行测试。 -
Loop structure（回路结构）：while函数之类的结构。Program flowchart（程序流程图）：使用符号显示步骤的编程工具。compiler（编译器）：将源代码转换为机器语言代码。interpreter（解释器）：将过程语言一次一条转换并运行成机器代码。application generator（应用生成器）：提供预编写代码模块的程序。 -
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89c10d0ab01a06ee191f3a8cff278cf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebb1e53cd4fbe2832d5087caa98055a4/" rel="bookmark">
			玄机——第二章日志分析-redis应急响应 wp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言二、概览简介 三、参考文章四、步骤（解析）准备工作#1.0 步骤#1通过本地 PC SSH到服务器并且分析黑客攻击成功的 IP 为多少,将黑客 IP 作为 FLAG 提交;拓展1.1 步骤#2通过本地 PC SSH到服务器并且分析黑客第一次上传的恶意文件,将黑客上传的恶意文件里面的 FLAG 提交; 步骤#3通过本地 PC SSH到服务器并且分析黑客反弹 shell 的IP 为多少,将反弹 shell 的IP 作为 FLAG 提交; 步骤#4通过本地 PC SSH到服务器并且溯源分析黑客的用户名，并且找到黑客使用的工具里的关键字符串(flag{黑客的用户-关键字符串} 注关键字符串 xxx-xxx-xxx)。将用户名和关键字符串作为 FLAG提交拓展1.2 步骤#5通过本地 PC SSH到服务器并且分析黑客篡改的命令,将黑客篡改的命令里面的关键字符串作为 FLAG 提交; 一、前言 题目链接：第二章日志分析-redis应急响应
三连私信免费送玄机注册邀请码私信！！！看见就回！！注意私信！！
首先简单了解一下什么是redis？
Redis 是一个开源的、内存中的数据结构存储系统，用作数据库、缓存和消息代理。它支持多种数据结构，如字符串、散列、列表、集合、有序集合、位图、HyperLogLogs 和地理空间索引半径查询。以下是 Redis 的一些关键特性和用途：
关键特性：
高性能：
由于 Redis 是内存数据库，数据存储和读取的速度非常快。每秒可以执行数百万次操作。 多种数据结构：
Redis 支持多种数据结构，使其非常灵活，能够适应不同类型的应用场景。支持的结构包括：字符串（Strings）、列表（Lists）、集合（Sets）、有序集合（Sorted Sets）、哈希（Hashes）、位图（Bitmaps）等。 持久化：
虽然 Redis 是内存数据库，但它支持将数据持久化到磁盘上，以防数据丢失。两种持久化方式：RDB（快照）和 AOF（追加文件）。 复制（Replication）：
Redis 支持主从复制，可以将数据从一个 Redis 服务器复制到多个从服务器，提供数据冗余和高可用性。 高可用性：
Redis 通过 Redis Sentinel 提供高可用性。Sentinel 监控 Redis 主从实例，并在主服务器不可用时自动进行故障转移。 集群（Cluster）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebb1e53cd4fbe2832d5087caa98055a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78e5d5ad171726662f112414f359348f/" rel="bookmark">
			Kotlin vs Java：深入解析两者之间的最新差异与优劣（全面指南）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 概述2. 语法简洁性3. 空安全4. 扩展函数5. 协程6. 数据类7. 智能类型转换8. 默认参数与命名参数9. 无 checked exceptions10. 单例模式总结 🎉欢迎来到Java学习路线专栏~探索Java中的静态变量与实例变量
☆* o(≧▽≦)o *☆嗨~我是IT·陈寒🍹✨博客主页：IT·陈寒的博客🎈该系列文章专栏：Java学习路线📜其他专栏：Java学习路线 Java面试技巧 Java实战项目 AIGC人工智能 数据结构学习🍹文章作者技术和水平有限，如果文中出现错误，希望大家能指正🙏📜 欢迎大家关注！ ❤️ Kotlin 和 Java 是两种常用的编程语言，尤其是在 Android 开发领域。尽管它们有许多相似之处，但也有显著的区别。本文将详细介绍 Kotlin 和 Java 之间的区别，帮助你更好地理解这两种语言的特点和优缺点。
1. 概述 Java 是由 Sun Microsystems 于 1995 年推出的面向对象编程语言，现在由 Oracle 维护。它是许多大型企业级应用和 Android 应用的主要编程语言。
Kotlin 是由 JetBrains 于 2011 年推出的现代编程语言，它运行在 Java 虚拟机（JVM）上，并且与 Java 完全互操作。Google 在 2017 年宣布 Kotlin 为官方支持的 Android 编程语言，这使得 Kotlin 在 Android 开发者中迅速流行起来。
2. 语法简洁性 Kotlin 的语法比 Java 更简洁，这使得代码更易读、更少出错。以下是一个简单的示例，展示了 Kotlin 和 Java 在定义一个类时的不同：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78e5d5ad171726662f112414f359348f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/892f323d94fd82923e2492e28bded145/" rel="bookmark">
			openfeign出现错误：Did you forget to include spring-cloud-starter-loadbalancer?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用openfeign进行远程调用时出现错误： No Feign Client for loadBalancing defined. Did you forget to include spring-cloud-starter-loadbalancer?
或者：nested exception is java.lang.AbstractMethodError: org.springframework.cloud.netflix.ribbon.RibbonLoadBalancerClient.choose(Ljava/lang/String;Lorg/springframework/cloud/client/loadbalancer/Request;)
这个错误提示是一个 java.lang.AbstractMethodError，这通常意味着你的代码中尝试调用了一个接口的方法，但具体的实现类没有提供这个方法的实现。给出的错误日志中，涉及的是Spring Cloud中与Ribbon相关的部分。
错误指出 RibbonLoadBalancerClient 接口的 choose 方法没有在被使用的实现类中找到。这通常发生在以下几种情况：
版本不兼容：在项目中使用了Spring Cloud的某个版本，但是Ribbon或其他相关依赖的版本并不兼容。例如，Spring Cloud从某个版本开始可能不再使用Ribbon，而是转向了其他负载均衡器（如Spring Cloud LoadBalancer），但你的项目可能仍然依赖于Ribbon。
依赖冲突：项目中可能包含了多个版本的Spring Cloud或Ribbon的jar包，导致类加载器加载了错误的版本。
配置错误：可能在配置文件中错误地指定了某个Bean的实现或参数，导致Spring容器没有正确初始化所需的组件。
要解决这个问题，你可以尝试以下步骤：
检查依赖：确保你的pom.xml（Maven）或build.gradle（Gradle）文件中指定的Spring Cloud和Ribbon的版本是兼容的。你可以参考Spring Cloud的官方文档来确定兼容的版本。
清理和重新构建：使用Maven或Gradle的清理和构建命令来确保没有旧的jar包残留。
检查配置：查看你的Spring配置文件（如application.properties或application.yml），以及任何Java配置类，确保没有错误地配置与Ribbon或负载均衡相关的设置。
如果使用的高版本spring cloud ，请使用spring-cloud-starter-loadbalancer依赖代替ribbon。
&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt; &lt;version&gt;你的Spring Cloud版本对应的版本号&lt;/version&gt; &lt;/dependency&gt; 同时移除ribbon依赖以及其他依赖中包含的ribbon依赖，如nacos中
&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/215/">«</a>
	<span class="pagination__item pagination__item--current">216/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/217/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>