<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b04b5567e4ed2a6a3e02b324e5519be/" rel="bookmark">
			【Python特征工程系列】利用SHAP进行特征重要性分析-决策树模型为例（案例&#43;源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是我的第290篇原创文章。
一、引言 SHAP 属于模型事后解释的方法，它的核心思想是计算特征对模型输出的边际贡献，再从全局和局部两个层面对“黑盒模型”进行解释。SHAP构建一个加性的解释模型，所有的特征都视为“贡献者”。
对于每个预测样本，模型都产生一个预测值，SHAP value就是该样本中每个特征所分配到的数值。
基本思想：计算一个特征加入到模型时的边际贡献，然后考虑到该特征在所有的特征序列的情况下不同的边际贡献，取均值，即某该特征的SHAP baseline value
SHAP值就是一种帮助我们理解机器学习模型是如何做出预测的工具，它通过分析每个特征对预测结果的影响，让我们能够更清楚地看到模型是如何“思考”的。
通过计算SHAP值，我们可以：
解释单个预测：了解每个特征如何影响单个样本的模型预测。
全局解释：通过平均多个样本的SHAP值，了解特征对模型预测的总体影响。
特征选择：识别对模型预测最重要的特征。
本文展示了如何使用条形图和蜂群图来可视化全局特征重要性。
二、实现过程 2.1 准备数据 # 准备数据 data = pd.read_csv(r'dataset.csv') df = pd.DataFrame(data) # 提取目标变量和特征变量 target = 'target' features = df.columns.drop(target) # 划分训练集和测试集 X_train, X_test, y_train, y_test = train_test_split(df[features], df[target], test_size=0.2, random_state=0) df：
2.2 模型训练 # 模型的构建与训练 model = DecisionTreeClassifier() model.fit(X_train, y_train) 2.3 创建SHAP解释器 # 创建Explainer explainer = shap.TreeExplainer(model, X_test) # 以numpy数组的形式输出SHAP值 shap_values = explainer.shap_values(X_test) print(shap_values) # shap_values = shap_obj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b04b5567e4ed2a6a3e02b324e5519be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ded06f8c3f09dc4c0ddf0621749de171/" rel="bookmark">
			【一步一步了解Java系列】：类与对象的联系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看到这句话的时候证明：此刻你我都在努力
加油陌生人
个人主页：Gu Gu Study
专栏：一步一步了解Java
喜欢的一句话： 常常会回顾努力的自己，所以要为自己的努力留下足迹
喜欢的话可以点个赞谢谢了。
作者：小闭
对象 Java中的对象是什么呢？显然不是我们现实生活中的对象。
emmm，在Java中有这么一句话，Java中任何东西皆可为对象，猫，狗，人，猴，洗衣机，手机，电脑，键盘等等。
Java中是一个面向对象的语言，对比C语言有什么不同呢？
我们举一个简单的例子，现在我们要用代码写出一个求阶乘的方法，C语言中叫函数，Java叫方法.。
C语言：C语言中会直接写出一个函数这个函数就是求阶乘的代码作为一个函数。
Java：首先他会先找一个对象，比如上方中是谁要求阶乘，比如要求阶乘的是学生，那么我们就要创建一个学生的对象，然后这个对象要干嘛，他要求阶乘，那么我们这时候就要给这个对象创建方法。这个方法就叫做：成员方法。
上面是一个简单的例子来简单展现C语言与Java的不同，当然可能有人就会问那我该怎么创建对象呢?
那么接下来登场的就是Java中的类。
类 类是用来描述一个对象的，对象是一个真正存在的实体。想要运用好类这个语法。我们就需要完成这么几个步骤：
根据事件找到对象。对象存在着什么变量。变量要完成什么事件。根据这些创建成员变量和成员方法。 注意：我们一般建议一个文件建一个类。
那么接下来就通过举例来让大家更好的理解上面的知识点。
public class Dog { int age; String name; public static void eat(){ System.out.println("吃狗粮"); } public static void speak(){ System.out.println("狗叫"); } } 如上就是我定义的一个类，这个类是用来描述一只狗的。这里面的成员变量有，age年龄，还有名字name，然后还有两个成员变量，当然这个 对象还未进行实例化。那么什么叫实例化呢？
对象的实例化 对象的实例化就是由类生成对象的过程叫做实例化。那么具体的代码实现是怎么样的呢？
public class Dog { int age; String name; public static void eat(){ System.out.println("吃狗粮"); } public static void speak(){ System.out.println("狗叫"); } public static void main(String[] args) { Dog dog=new Dog(); dog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ded06f8c3f09dc4c0ddf0621749de171/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61de7c5f4998639655065e57b7cb1eb7/" rel="bookmark">
			C# 配置文件设置详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 配置文件在 C# 项目中的作用和重要性2. 不同类型的配置文件app.configconfig.exejson 3. 创建和修改配置文件文件位置添加内容修改内容保存和加载 4. 读取和写入配置文件app.config 文件读取config.exe 文件写入JSON 文件读写 5. 示例代码演示6. 配置文件在安全性方面的注意事项7. 跨平台配置文件的创建和应用总结 在软件开发过程中，配置文件是常用的一个功能，用于在程序运行时调整应用程序的行为。C# 提供了多种方式来创建和使用配置文件，使开发者可以灵活地管理应用程序的配置信息。本文将详细介绍 C# 配置文件的创建、修改、读取和写入，以及跨平台配置文件的应用。
1. 配置文件在 C# 项目中的作用和重要性 配置文件允许我们在不修改代码的情况下，动态地调整应用程序的行为。这对于适应不同的运行环境、满足不同用户的需求以及方便维护和升级都非常重要。
例如，我们可以使用配置文件来存储数据库连接字符串、API 密钥、应用设置等敏感信息，而不需要在代码中硬编码这些值。这样，当需要更改这些信息时，只需修改配置文件即可，无需重新编译和部署应用程序。
2. 不同类型的配置文件 C# 支持多种类型的配置文件，常见的有：
app.config app.config 是 C#中最常用的配置文件类型。它通常位于项目的根目录中，以 XML 格式存储配置信息。app.config 文件可以包含多个配置节，如 appSettings、connectionStrings、system.web 等，用于存储不同的配置信息。
config.exe config.exe 是一种二进制格式的配置文件，通常用于 Windows 应用程序。它可以在程序启动时加载，并在程序运行时动态修改。config.exe 文件的优点是加载速度快，但缺点是可读性差，不适合存储大量文本信息。
json JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，易于阅读和编写。在 C# 中，可以使用 Newtonsoft.Json 库将 JSON 配置文件读取为对象。JSON 配置文件适用于跨平台应用程序，因为大多数现代编程语言都支持 JSON。
3. 创建和修改配置文件 文件位置 配置文件可以放置在项目的任何位置，但通常将其放在项目的根目录或专门的配置文件夹中，以便于管理和访问。
添加内容 以 app.config 文件为例，可以通过 XML 编辑器或代码编辑器手动添加配置节和属性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61de7c5f4998639655065e57b7cb1eb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d31d0ab9b93fc0847583953b6a390c9e/" rel="bookmark">
			【动态规划】速解简单多状态类问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
17.16 按摩师
题⽬描述：
解法（动态规划）：
1. 状态表⽰：
2. 状态转移⽅程：
3. 初始化：
4. 填表顺序
5. 返回值
代码
总结：
213.打家劫舍II（medium）
题⽬描述：
解法（动态规划）
代码：
740.删除并获得点数
题⽬描述：
解法（动态规划）：
代码：
剑指OfferI I091. 粉刷房⼦
题⽬描述：
解题思路：
代码：
17.16 按摩师 //打家劫舍问题的变形~⼩偷变成了按摩师
题⽬描述： ⼀个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间 要有休息时间，因此她不能接受相邻的预约。给定⼀个预约请求序列，替按摩师找到最优的预约集合 （总预约时间最⻓），返回总的分钟数。
解法（动态规划）： 算法思路：
1. 状态表⽰： 对于简单的线性dp ，我们可以⽤「经验+题⽬要求」来定义状态表⽰：
i. 以某个位置为结尾，巴拉巴拉；ii. 以某个位置为起点，巴拉巴拉。 这⾥我们选择⽐较常⽤的⽅式，以某个位置为结尾，结合题⽬要求，定义⼀个状态表⽰：
dp[i] 表⽰：选择到 i 位置时，此时的最⻓预约时⻓。
但是我们这个题在 i 位置的时候，会⾯临「选择」或者「不选择」两种抉择，所依赖的状态需要 细分：
▪ f[i] 表⽰：选择到 i 位置时， nums[i] 必选，此时的最⻓预约时⻓；
▪ g[i] 表⽰：选择到 i 位置时， nums[i] 不选，此时的最⻓预约时⻓。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d31d0ab9b93fc0847583953b6a390c9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdf7f8bff5ed057df29b5d9c857d6627/" rel="bookmark">
			HBase分布式数据库入门到精通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
HBase分布式数据库入门到精通
一、简单介绍
二、HBase数据模型
三、HBase的架构
四、HBase写操作流程
五、HBase读操作流程
六、HBase minor小合并和major大合并
七、HBase目标表meta表
八、HBase特点
九、HBase的使用场景
HBase分布式数据库入门到精通 一、简单介绍 HBase是一个高可靠性、高性能、面向列、可伸缩、实时读写的分布式 NOSQL 数据库。
当你需要随机、实时读/写访问大数据时，请使用 Apache HBase。
作用：主要用来存储非结构化、半结构化和结构化的松散数据（列式存储的 NoSQL 数据库）
名称解释：
NameSpace 命名空间，相当于关系型数据库中的 database，每个命名空间下有多个表。Hbase 默认自带的命名空间 hbase 和 default；hbase 中存放的是 HBase 内置的表，default 是用户默认使用的命名空间。
Region 类似关系型数据库的表，不同之处在于 HBase 定义表示只需要声明列族，不需要声明具体的列。列可以动态的按需要指定；HBase 更加适合字段经常变更的场景。开始创建表是一个表对应一个 region，当表增大到一定值是会被拆分为两个 region。
Row HBase 表中的每行数据被称为 Row，由一个 RowKey 和多个 Column 组成，数据是按照 RowKey 的字典顺序存储的，并且查询是只能根据 RowKey 进行检索，所以 RowKey 的设计很关键。
Column 列是由列族（Column Family）和列限定符（Column Qualifier）进行限定，例如： base:name,base:sex。建表示只需定义列族，而列限定符无需预先定义。
Cell 某行中的某一列被称为 Cell（单元格），由{rowkey，column family:columnqualifier,timestamp}确定单元。Cell 中没有具体的类型，全部是字节码的形式（字节数组）存储。
TimeStamp 用于标识数据的不同版本（version），每条数据写入时，如果不指定时间戳，系统会自动为其加上该字段，值为写入 HBase 的时间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdf7f8bff5ed057df29b5d9c857d6627/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fff74203ff65b3218716683600755d87/" rel="bookmark">
			AI模型 YOLOv8在工业中的应用案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YOLOv8在工业中的应用案例 一、YOLOv8简介 YOLOv8（You Only Look Once, Version 8）是YOLO系列的最新版本，以其高效和实时检测的能力在工业领域得到了广泛应用。本文将介绍YOLOv8在几个具体工业应用中的案例，并提供相关的GitHub资源。
二、YOLOv8的工业应用案例 案例一：自动化生产线上的缺陷检测 在制造业中，产品质量检测是一个重要环节。YOLOv8被应用于自动化生产线上的缺陷检测，通过实时监控产品外观，检测出表面缺陷如划痕、凹痕、污点等。
具体实施： 数据采集：在生产线上安装高清摄像头，实时拍摄产品图像。模型训练：使用YOLOv8训练包含不同类型缺陷的图像数据。实时检测：将训练好的模型部署在生产线上，对实时图像进行缺陷检测。 效果： 提高了缺陷检测的准确率和效率，减少了人工检测的成本和时间。及时发现并处理不合格产品，保证了产品质量。 相关资源： YOLOv8 GitHub仓库 案例二：仓库管理中的货物识别与分类 在物流和仓储管理中，货物的快速识别和分类对于提高效率至关重要。YOLOv8用于仓库中对货物进行实时识别和分类。
具体实施： 数据准备：收集仓库中各种货物的图像数据，包含不同角度和光线条件下的图像。模型训练：使用YOLOv8训练货物识别模型。部署与应用：在仓库中安装摄像头，实时监控货物进出，并通过模型进行识别和分类。 效果： 加快了货物的识别与分类过程，提高了仓库管理的自动化水平。减少了人为操作的错误率，提升了库存管理的准确性。 相关资源： YOLOv8在仓库管理中的应用 案例三：工业机器人视觉导航 在智能制造中，工业机器人需要具备视觉导航能力，以提高工作效率和灵活性。YOLOv8用于工业机器人的目标检测和路径规划。
具体实施： 环境数据采集：在机器人工作环境中采集大量图像，标注路径和障碍物。模型训练：使用YOLOv8训练机器人视觉导航模型。实时导航：将训练好的模型集成到机器人系统中，实时分析环境图像，规划路径并避开障碍物。 效果： 提升了工业机器人的自主导航能力，适应复杂的工作环境。提高了生产线的柔性和自动化水平，减少了人工干预。 相关资源： YOLOv8在机器人视觉导航中的应用 三、YOLOv8在工业中的优点 实时性强：适合需要实时检测和响应的工业应用。高效准确：在保证高效检测的同时，保持了较高的检测准确率。通用性强：适用于多种工业场景，包括质量检测、仓库管理和机器人导航等。 四、结论 YOLOv8凭借其高效、实时的目标检测能力，在工业领域中展现了广泛的应用前景。通过具体的案例，我们可以看到YOLOv8在提升生产效率、保证产品质量、优化仓库管理和提高工业机器人智能化水平等方面的显著作用。
希望这些案例和GitHub资源能够为您在工业应用中引入YOLOv8提供一些参考。如果您有任何问题或建议，欢迎在评论区留言讨论。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ab89e7c8dd1fd31ebf5d1fd05c7f5fb/" rel="bookmark">
			数据结构：二叉树与树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 树的基本概念： 1.树的形状： 2.树的定义： 树是一种非线性的数据结构，它是n(n &gt;= 0)个结点的有限集。当n = 0时，称为空树。在任意一棵非空树中应满足：
2.1 有且仅有一个特定的称为根的结点。
2.2 当n &gt; 1时，其余结点可分为m(m &gt; 0)个互不相交的有限集T1 ……Tm，其中每个集合本身又是一棵树，并且称为根的子树。
显然，树的定义是递归的，即在树的定义中又用到其自身，树是一种递归的数据结构。树作为一种逻辑结构，同时也是一种分层结构，具有以下两点特点：
2.3 树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。
2.4 树中所有结点可以有零个或多个后继。
3.树中相关的关键词概念： 3.1 节点的度：一个节点含有的子树的个数称为该节点的度；如上图：A的为6
3.2 路径：树的路径是指从根节点到树内特定节点遍历的节点序列
3.3 根：树顶端的节点称为根。一棵树只有一个根，如果要把一个节点和边的集合称为树，那么从根到其他任何一个节点都必须有且只有一条路径。A是根节点
3.4 父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；如上图：A是B的父节点
3.5 子节点：一个节点含有的子树的根节点称为该节点的子节点；如上图：B是A的子节点
3.6 兄弟节点：具有相同父节点的节点互称为兄弟节点 如上图：I与J就是兄弟
3.7 堂兄弟节点：不是相同父亲的节点且在同一层而和相邻的称堂兄弟节点 如上图：H与I就是堂兄弟
3.8 叶节点：度为0的节点就是叶节点或者说没有孩子的节点 如上图：P和Q
3.9 分支节点：度不为0的点。列如：B、C、D、都是分支节点。
3.10 子树：每个节点都可以作为子树的根，它和它所有的子节点、子节点的子节点等都包含在子树中。
3.11 节点的层次：从根开始定义，根为第一层，根的子节点为第二层，以此类推。
3.12 深度 \ 高度：树中节点的最大层。如图就是4。
3.13 节点的祖先：从根到该节点的所经过分支上的所有节点，A就是所有节点的祖先。
3.14 深林：互不相交的树的集合被称为深林。
3.15 子孙：以某节点为根的子树的子树中任一节点都被称为该节点的子孙。列如所有节点都是A的子孙
4.树的性质： 4.1 树中的结点数等于所有结点的度数之和加1
4.2 度为m的树中第i层上至多有m^(i-1)个结点(i &gt;= 1)
4.3 高度为h的m叉树至多有(m^h - 1)/(m - 1)个结点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ab89e7c8dd1fd31ebf5d1fd05c7f5fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72908f938877a62cc9de79efa1a37cbd/" rel="bookmark">
			Qt Creator（2）【如何在Qt Creator中创建新工程】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读导航 引言一、Qt Creator开始界面介绍二、如何在Qt Creator中创建新工程1. 新建项目2. 选择项目模板3. 选择项目路径4. 选择构建系统5. 填写类信息设置界面6. 选择语言和翻译文件7. 选择Qt套件8. 选择版本控制系统9. 最终效果 三、认识Qt Creator项目内容界面1. 基本界面2. UI设计界面3. 构建区 引言 Qt Creator提供了一套完整的工具集，旨在简化并加速Qt应用程序的开发流程。它不仅包括代码编辑、界面设计、版本控制等功能，还提供了代码自动补全、自定义构建系统和强大的调试工具。通过今天的学习，我们将掌握Qt Creator的基本使用，从创建项目、编写代码到应用程序的调试和部署，全方位提升我们的开发效率和体验。接下来，让我们一起探索Qt Creator的世界，让Qt开发变得更加得心应手。
一、Qt Creator开始界面介绍 ①：菜单栏：菜单栏⼀共有8个菜单选项，包含了常⽤的功能菜单：
菜单功能描述文件包含了新建、打开、关闭项目和文件、打印和退出等基本功能编辑包含了撤销、剪切、复制、查找和选择编码等功能构建包含构建和运行项目等相关功能。调试包含调试运行项目等相关功能。Analyze包含QML分析器、Valgrind内存和性能分析器等相关功能。工具提供了快速定位菜单、外部工具菜单等。这里的选项菜单中包含了Qt Creator各个方面的设置选项：环境设置、文本编辑器设置、帮助设置、构建和运行设置、调试器设置和版本控制设置等。控件包含了设置窗口布局的一些菜单，如全屏显示和隐藏边栏功能等。帮助包含Qt帮助、Qt Creator版本信息、报告bug和插件管理等菜单。 ②：模式选择
模式功能描述欢迎模式提供功能的快捷入口，如打开帮助教程、示例程序、项目、新建项目、快速打开以前的项目和会话、联网查看Qt官方论坛和博客等。示例页面显示了Qt自带的大量示例程序，并提供了搜索栏以实现快速查找；教程页面提供了一些视频教程资源，但为英文。编辑模式主要用来查看和编辑程序代码，管理项目文件。Qt Creator中的编辑器具有关键字特殊颜色显示、代码自动补全、声明定义间快捷切换、函数原型提示、F1键快速打开相关帮助和全项目中进行查找等功能。也可以在"工具-&gt;选项"菜单中对编辑器进行设置。设计模式整合了Qt Designer的功能。可以设计图形界面，进行部件属性设置、信号和槽设置、布局设置等操作。调试模式支持设置断点、单步调试和远程调试等功能，包含局部变量和监视器、断点、线程以及快照等查看窗口。项目模式包含对特定项目的构建设置、运行设置、编辑器设置、代码风格设置和依赖关系等页面。构建设置中可以对项目的版本、使用的Qt版本和编译步骤进行设置；编辑器设置中可以设置文件的默认编码；在代码风格设置中可以设置自己的代码风格。帮助模式在帮助模式中将Qt助手整合了进来，包含目录、索引、查找和书签等几个导航模式，可以在帮助中查看Qt和Qt Creator的各方面信息。 ③：构建套件选择器：构建套件选择器包含了⽬标选择器（Target selector）、运⾏按钮（Run）、调试按钮（Debug）和构建按钮（Building）四个图标。
组件功能描述目标选择器用来选择要构建哪个项目、使用哪个Qt库，对于多个Qt库的项目很有用。还可以选择编译项目的debug版本或是release版本。运行按钮实现项目的构建和运行。调试按钮实现项目的调试。构建按钮完成项目的构建。 ④：欢迎模式下的窗⼝⼯作⽅式
菜单功能描述Project用来新建工程、打开工程。示例包含Qt官方的一些示例。教程提供Qt官方教程。 ⑤：定位器：使⽤定位器来快速定位项⽬、⽂件、类、⽅法、帮助⽂档以及⽂件系统。可以使⽤过滤器来更加准确地定位要查找的结果。
⑥：输出窗格：输出窗格包含了问题、搜索结果（Search Results）、应⽤程序输出、编译输出、Debugger Console、概要信息、测试结果（Test Results）7个选项，它们分别对应⼀个输出窗⼝，响应的快捷键依次是Alt+数字1~7。
窗口名称功能描述问题问题窗口显示程序编译时的错误和警告信息。Search Results搜索结果窗口显示执行了搜索操作后的结果信息。应用程序输出应用程序窗口显示应用程序运行过程中输出的所有信息。编译输出编译输出窗口显示程序编译过程输出的相关信息。 ⑦：会话记录：可以对会话进⾏管理，包括 Clone。如果没打开⼯程，则显⽰的是最后⼀次打开的（会话）⼯程，否则，显⽰当前的会话（⼯程）。
⑧：新建项目
⑨：打开已有项目
二、如何在Qt Creator中创建新工程 1. 新建项目 打开Qt Creator，在菜单栏中选中：“⽂件”--------&gt;“新建⽂件或项⽬”；或者使⽤快捷键：Ctrl +
n；或者直接点击：“new”；
在欢迎模式下，直接点击New，如下图⽰：
2. 选择项目模板 新建项⽬对话框⾥有五类项⽬模板
项目模板说明ApplicationQt应用程序，包括普通窗体程序和QtQuick程序。Library可以创建动态库、静态库以及QtQuick扩展插件、QtCreator自身插件。其他项目可以创建单元测试项目、Qt4设计师自定义控件、子目录项目等。Non-Qt-Project非Qt项目。可以创建纯C或纯C++项目。Import Project导入项目。从版本控制系统管理的软件项目导入旧的项目。 常⽤的只有第⼀类Application，选择它，在右侧会看到Qt应⽤程序的五个⼦模板：
Qt Widgets Application：普通窗体模板，传统基于部件的窗体界⾯程序。Qt Console Application：Qt 控制台应⽤程序。因为 Qt 主要⽤于图形界⾯设计，这个控制台项⽬模板基本不⽤。Qt for Python：在Python下⽤LGPL的许可来开发闭源 Qt软件。Qt Quick Application： Qt 提供的⼀种⾼级⽤⼾界⾯技术，使⽤它可以⽅便快速的为移动以及嵌⼊式设备开发流畅美观的⽤⼾界⾯。Qt Quick 模块是开发QML应⽤的标准库，提供了使⽤QML创建⽤⼾界⾯所需的⼀切，包括可视化、交互、动画、模型、视图、粒⼦效果以及着⾊效果等。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72908f938877a62cc9de79efa1a37cbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ed78f16f36209723211310eb409d808/" rel="bookmark">
			ChatGPT Mac客户端 下载安装教程（免费 不限次数使用 还支持语音聊天）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ChatGPT Mac客户端 下载安装教程（免费 不限次数使用 还支持语音聊天） 免费 不限次数使用 还支持语音聊天 系统要求： macOS 14 和 Apple Silicon（M1 或更高版本） 文章目录 ChatGPT Mac客户端 下载安装教程（免费 不限次数使用 还支持语音聊天）`系统要求： macOS 14 和 Apple Silicon（M1 或更高版本）` 一、准备工作1、下载地址2、注意事项 二、开始安装1.安装2. 登录（login）3.解决 Coming soon 报错 三、客户端常用技巧1. 快捷键2.个性化设置3. 隐私设置 一、准备工作 1、下载地址 链接：http://www.macfxb.cn 2、注意事项 系统要求： macOS 14 和 Apple Silicon（M1 或更高版本）能 ke xue 上网 二、开始安装 1.安装 2. 登录（login） 打开桌面版 点击登录（login） 选择自己的方式登录（我这里通过谷歌登录）
也可以输入自己的 gpt 账号，然后点击登录 目前最常见的报错信息是下面的 3.解决 Coming soon 报错 打开 客户端 点击登录（login）输入自己的 gpt账号，然后点击登录在报错信息出现之前，选中客户端然后使用快捷键：Command + Q重新打开客户端，不用登录可以正常使用啦重点就是卡点，在报错信息出来之前，将客户端关闭
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ed78f16f36209723211310eb409d808/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a432a8cb6b12d1655b7ae1a7dc849f6/" rel="bookmark">
			docker创建 Maxwell容器 并连通Kafka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概要拉取maxwell镜像添加容器卷修改配置文件启动maxwell容器检查连接情况 概要 学到使用maxwell模拟mysql主从复制的slave机，获取master机的bin-log日志后在执行一遍，一开始使用maxwell包想在docker里的linux容器直接解压安装使用，结果发现和kafka版本不匹配（个人觉得是这个问题）换了jdk版本和maxwell版本，高的低的版本都换了还是不能传到kafka，但是切换到producer=stdout 即打印在控制台是可以的，说明就是不能匹配上kafka，而且报错还很迷：
ERROR MaxwellKafkaProducer - UnknownServerException @ Position[BinlogPosition[mysql-bin.000002:749271], lastHeartbeat=0]
干脆想着使用独立的容器单独起一个maxwell算了，开始尝试单独起maxwell然后联通mysql和Kafka。
拉取maxwell镜像 docker search maxwell
找到zendesk/maxwell 然后pull
添加容器卷修改配置文件 要使用maxwell连接mysql和kafka集群 需要在配置文件里面添加mysql服务器ip/端口号/用户名/密码
要连接Kafka集群也需要指定Kafka集群的host：port
其中连接mysql还需要单独为maxwell进程创建一个远程访问用户，高版本mysql不支持一键创建远程用户了：可以参考这篇文章：MySQL ERROR 1064 (42000）——不管怎样grant总是报错，怎么回事？
daemon=true # 第一次启动时建议改为debug，可以开到mysql数据与kafka请求，稳定后再改为info log_level=info producer=kafka kafka.bootstrap.servers=IP1:9092,IP2:9092,IP3:9092 # 会往 kafka下主题为'test'的分区下推送数据 kafka_topic=topic_db #当producer_partition_by设置为table时，Maxwell会将生成的消息根据表名称进行分区，不同的表将会被分配到不同的分区中，默认为database producer_partition_by=primary_key client_id=maxwell_1 # mysql login info 需要先在mysql创建maxwell用户 host=IP port=3306 user=maxwell password=Admin123@qwe schema_database=maxwell 启动maxwell容器 docker run --name maxwell --net spark-cluster-1 \ -v ./:/etc/maxwell/ \ zendesk/maxwell bin/maxwell --config /etc/maxwell/config.properties 指定容器名 网络 挂载数据卷
镜像名 启动容器的时候终端需要执行的命令（即启动maxwell进程）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a432a8cb6b12d1655b7ae1a7dc849f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/376c3429f774a1827bc18df28a0e3f04/" rel="bookmark">
			数据结构的希尔排序（c语言版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.希尔排序的概念 1.希尔排序的基本思想 希尔排序是一种基于插入排序算法的优化排序方法。它的基本思想如下:
选择一个增量序列 t1，t2，......，tk，其中 ti &gt; tj, 当 i &lt; j，并且 tk = 1。
按增量序列个数k，对数组进行k趟排序:
第一趟，按 t1 的增量对数组进行插入排序;第二趟，按 t2 的增量对数组进行插入排序;... ...第k趟，按 tk 的增量(此时 tk = 1)，也就是对整个数组进行插入排序。 2.希尔排序的优点 时间复杂度较低。希尔排序的时间复杂度一般在 O(n^1.25) 和 O(n^1.5) 之间,优于简单的插入排序。
在部分有序的数组中效率很高。希尔排序通过分组插入排序来利用数据的局部有序性,可以有效地加快排序速度。
空间复杂度低,只需要常量级的额外空间。
代码实现相对简单,易于理解和编码。
3.希尔排序的缺点 增量序列的选择对排序效率有很大影响。不同的增量序列会导致很大的性能差异。找到最优的增量序列是一个难题。
在数据量很大时,性能可能不如其他算法,如快速排序、堆排序等。
不稳定。希尔排序是不稳定的排序算法,即相等的元素可能会改变相对次序。
理论分析复杂。希尔排序的时间复杂度分析比较困难,没有得到一个统一的结论。
4.希尔排序与快速排序在使用情况时的差异 数据量中等且部分有序:
希尔排序通过分组排序利用了数据的局部有序性,在部分有序的数组上表现很好。而快速排序在部分有序数组上可能会退化为 O(n^2) 的时间复杂度。 内存受限的环境:
希尔排序只需要常量级的额外空间,而快速排序需要递归调用栈,在内存受限的环境下可能会有优势。 数据分布不均匀:
快速排序的性能很容易受到数据分布的影响,而希尔排序相对更加好。 预先知道数据大致分布情况:
如果对数据的分布有一定了解,可以选择合适的增量序列来优化希尔排序的性能。 对稳定性要求不高:
快速排序是不稳定的,而希尔排序也是不稳定的。如果稳定性不是关键,希尔排序可能是更好的选择。 二.希尔排序的功能 1.分组插入排序 希尔排序的核心思想是通过分组插入排序来优化基本的插入排序算法。它首先选择一个增量序列,如 [n/2, n/4, n/8, ...]，将原始数组划分为多个子数组。每个子数组的元素索引差为增量值。例如，当增量为 4 时，子数组为 arr[0]、arr[4]、arr[8]...。对这些子数组分别进行插入排序。随着增量序列逐步减小，子数组中的元素越来越集中，最终整个数组被完全排序。 2.利用局部有序性 在初始阶段,当增量较大时,子数组中的元素较为分散。随着增量的不断减小,子数组中的元素逐渐趋于有序。这种分组插入排序可以有效利用数据的局部有序性,从而减少插入排序的比较和移动操作次数。 3.时间复杂度优化 基本插入排序的时间复杂度为 O(n^2)。而希尔排序通过分组插入排序和利用局部有序性,可以将平均时间复杂度优化到 O(n^1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/376c3429f774a1827bc18df28a0e3f04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bec61d920006f5be432b08b8007c50f8/" rel="bookmark">
			[联邦学习]FedProx算法&amp;&amp;工作原理&amp;&amp;步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[联邦学习]FedProx FedProx（Federalized Proximal Algorithm）是一种在联邦学习（Federated Learning, FL）环境下设计的优化算法，旨在处理数据在不同客户端之间可能存在的不均匀分布（Non-IID Data）的问题。联邦学习是一种机器学习设置，允许多个客户端协作训练一个共享的模型，同时保持数据的隐私和安全，因为数据不需要集中存储或处理。
FedProx是Li Tian等人于2018年(论文链接)所提出的一种针对系统异构性鲁棒的联邦优化算法，发表于MLSys 2020上。它相较于FedAvg主要做出了两点改进：
采样阶段 使用了按数据集大小比例，可放回采样，并直接平均聚合（无加权）来获得无偏梯度估计
本地训练阶段 基于近端项优化的思路，魔改了本地训练的目标函数为
L + μ 2 ∣ ∣ w k , i t − w g l o b a l ∣ ∣ 2 L + \frac{\mu}{2}||w^t_{k,i} - w_{global}||^2 L+2μ​∣∣wk,it​−wglobal​∣∣2
"采样"指的是服务器从参与方（客户端）的数据集中选择样本进行模型更新。因此，在FedProx中，采样是服务器在每轮迭代中从参与方的数据集中按照每个参与方数据集大小的比例进行选择的过程。具体来说，如果某个参与方的数据集更大，则它在采样中被选中的概率更高。
因此，这里的"采样"是指服务器在联邦学习中选择参与方的过程，而不是指参与方选择自己的数据的过程。
背景和问题 在标准的联邦学习模型中，如FedAvg（Federated Averaging），每个客户端独立地在本地数据上训练模型，然后将更新的模型发送给中央服务器。服务器将这些更新平均合并，以更新全局模型。然而，当不同客户端的数据分布差异很大时（即Non-IID），这种简单的平均可能导致模型性能下降，因为它没有考虑到各客户端更新的差异性。
FedProx的工作原理 FedProx在FedAvg的基础上增加了一个正则化项，这个正则化项惩罚模型参数与全局模型参数之间的偏差。具体来说，FedProx的目标是最小化以下目标函数：
L ( w ) = ∑ k = 1 K n k n ( F k ( w ) + μ 2 ∣ w − w t ∣ 2 ) L(w) = \sum_{k=1}^K \frac{n_k}{n} \left( F_k(w) + \frac{\mu}{2} |w - w^t|^2 \right) L(w)=k=1∑K​nnk​​(Fk​(w)+2μ​∣w−wt∣2)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bec61d920006f5be432b08b8007c50f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f05f68fa89e9f871fd371f620813fa77/" rel="bookmark">
			QR方法求解特征值、特征向量(附Matlab、C代码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QR方法特征分解 1. 实对称矩阵的QR方法特征分解2. 代码实现与验证3. 参考资料 1. 实对称矩阵的QR方法特征分解 ​ 使用QR分解的方法求取实对称矩阵特征值、特征向量，首先通过householder变换将实对称矩阵转化为三对角矩阵，对三对角矩阵进行QR分解迭代
[ × × × × × × × × × × × × × × × × ] → H = I − 2 w ∗ w T [ × × 0 0 × × × 0 0 × × × 0 0 × × ] \begin{bmatrix}\times&amp;\times&amp;\times&amp;\times\\\times&amp;\times&amp;\times&amp;\times\\\times&amp;\times&amp;\times&amp;\times\\\times&amp;\times&amp;\times&amp;\times\end{bmatrix}\xrightarrow{H=I-2w*w^T}\begin{bmatrix}\times&amp;\times&amp;0&amp;0\\\times&amp;\times&amp;\times&amp;0\\0&amp;\times&amp;\times&amp;\times\\0&amp;0&amp;\times&amp;\times\end{bmatrix} ​××××​××××​××××​××××​ ​H=I−2w∗wT ​ ​××00​×××0​0×××​00××​ ​
针对Hessenberg矩阵多采用带位移的QR算法1(如: Rayleigh quotient shift，Wilkinson shift)
{ A k − σ ∗ I = Q k ∗ R k A k + 1 = R k ∗ Q k + σ ∗ I \left\{ \begin{array}{l} {A}_{k} - \sigma * I = {Q}_{k} * {R}_{k} \\ {A}_{k + 1} = {R}_{k} * {Q}_{k} + \sigma * I \end{array}\right.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f05f68fa89e9f871fd371f620813fa77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da0f99a1052eaa2361701d45af1a27fc/" rel="bookmark">
			【从零开始学习RabbitMQ | 第三篇】什么是延迟消息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：
延迟消息：
延迟消息实现方式：
死信交换机：
延迟消息插件：
1.基于注解的方式
2.基于@Bean的方式
总结：
前言： 在现代软件开发中，异步消息处理已成为构建可扩展、高可用系统的关键组成部分。RabbitMQ，作为一款广泛使用的开源消息代理，提供了强大的消息队列功能，支持多种消息模式，包括发布/订阅、请求/响应以及路由等。然而，除了这些基本功能外，RabbitMQ还提供了一项独特的特性——延迟消息，它允许开发者安排消息在将来的某个时间点被处理。
延迟消息，顾名思义，是指那些在发送后不会立即被消费者接收的消息，而是根据预设的延迟时间后才能被消费。这种特性在许多场景下非常有用，例如定时任务的执行、订单超时处理、批处理作业的调度等。通过延迟消息，我们可以将即时处理的需求转化为按计划执行的任务，从而优化资源使用，提高系统的响应性和吞吐量。
延迟消息： 生产者发送消息的时候指定一个时间，消费者不会立即收到消息，而是在指定的时间之后才收到消息。
我举一个实际应用场景：买车票 订单不代表付款，当我们下单之后，只有付款了我们才会更新库存状态 。在苍穹外卖中，我们采用的是定时任务轮询数据库机制，来取消超时订单。
但是这有一个弊端：对数据库的压力太大了，无论是每隔几秒都是对数据库的一次极致拷打。
在黑马点评中，我们用Redis模拟实现了延迟队列，其实就是用Stream去构造订单，过期之后就去数据库查询订单状态。
而在这种环境下，我们可以用RabbitMQ中的延迟队列，当下单之后，我们把消息发送给MQ，设置延迟时间为30分钟，等30分钟后，Rabbitmq检查订单状态，如果未支付就取消订单。
延迟消息实现方式： 死信交换机： 当队列中的消息满足以下一种情况的时候，就会成为死信：
消费者使用basic.reject 或 basic.nack声明消费失败，并且消息的requeue参数设置为fasle消息是一个过期消息，超时无人消费要投递的消息队列满了，最早的消息成为死信 当队列通过dead-letter-exchange 属性指定交换机之后，这个队列中的死信就会投递到这个交换机中，这个交换机成为死信交换机。
这种机制的缺点就是代码实现比较麻烦。所以我们接下来介绍一下延迟消息插件。
延迟消息插件： 延迟消息插件是Rabbitmq官方推出的一个插件，原生支持延迟消息，原理是设计了一个支持延迟消息功能的交换机，当消息投递到交换机的时候可以暂存一段时间，到期之后再投递到队列。
Releases · rabbitmq/rabbitmq-delayed-message-exchange (github.com)https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases在上述网址中下载插件之后，存放到RabbitMQ的插件目录下就可以了。
安装延迟消息插件之后，想要实现延迟消息可以通过两桶途径：
1.基于注解的方式 @RabbitListener(bindings = @QueueBinding( value = @Queue(value = "delay.queue", durable = "true"), exchange = @Exchange(value = "delay.direct", delayed = "true"), key = "delay" )) public void listenDelayQueue(String msg) { log.info("delay.queue：" + msg); } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da0f99a1052eaa2361701d45af1a27fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19342b9427baa34a9f1433d84732647f/" rel="bookmark">
			基于python flask &#43;pyecharts实现的气象数据可视化分析大屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 气象数据可视化分析大屏基于Python Flask和Pyecharts技术，旨在通过图表展示气象数据的分析结果，提供直观的数据展示和分析功能。在当今信息化时代，气象数据的准确性和实时性对各行业具有重要意义。通过搭建气象数据可视化分析大屏，用户可以实时监测和分析气象数据趋势，帮助决策者制定有效的应对措施。该系统将为气象领域的研究人员、气象服务机构和相关行业提供强大的数据分析和决策支持，推动气象信息化应用的发展和提升。
前端设计 前端设计的关键步骤：
页面布局设计： 使用Flex布局将页面分为左侧、中间和右侧三个主要部分，每个部分包含多个子元素。
左侧和右侧各包含三个垂直排列的子元素，用于展示不同类型的数据。
中间部分用于显示地图数据，并包含一个计时器显示当前时间。
样式设计： 设置全局样式，包括页面背景色、字体颜色、间距等，确保页面整体风格统一。
设计每个数据展示框的样式，包括边框样式、高度、宽度等，使其具有辨识度。
为表格容器添加滚动条样式，确保表格数据超出容器高度时可以滚动查看。
数据填充与更新： 使用JavaScript和jQuery库实现数据的动态填充和更新，通过Ajax请求从后端获取最新数据并更新图表。
在表格部分，根据后端返回的数据动态生成表格行，并实现表格的滚动效果。
图表展示： 使用ECharts库初始化各个图表实例，并根据后端返回的数据更新图表内容。
不仅展示静态图表，还可以通过定时器定时刷新数据，实现实时数据展示。
通过以上设计，可以实现一个交互性强、信息展示清晰的气象数据可视化大屏，为用户提供直观、动态的数据分析和监控功能。
后端设计 主要代码
import json # from 天气处理 import * app = Flask(__name__, static_folder="templates") textstyle = opts.TextStyleOpts(color="white") idx = 9 import pandas as pd def chuli(): df=pd.read_csv(r'C:\Users\Administrator\Desktop\天气大屏flask+pyecharts\Flask_DataView_new\天气数据.csv') df['省份']=df['省份'].str.replace('历史天气','') # 完整的省份映射字典 mapping_dict = { "北京": "北京市", "天津": "天津市", "河北": "河北省", "山西": "山西省", "内蒙古": "内蒙古自治区", "辽宁": "辽宁省", "吉林": "吉林省", "黑龙江": "黑龙江省", "上海": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19342b9427baa34a9f1433d84732647f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79f6ce210f045d038c20a85ed2a6e37d/" rel="bookmark">
			基于javaswing和mysql实现的员工工资管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目上传到了github，下载EPMS文件夹即可，源码都在里面，记得给我一个star
https://github.com/XK-coding/projects.git
工资管理系统EPMS目录 工资管理系统EPMS1.功能模块设计1.1java语言连接数据库jdbc1.2系统登录Login1.3实体类设计entity1.4管理员系统AdminSystem 2.员工工资管理AdminWages2.1员工工资添加功能2.2员工工资修改功能2.3员工工资删除功能2.4员工工资查询单个员工工资功能2.5员工工资查询全部员工工资功能 3.员工工资管理AdminWages的界面设计3.1员工工资查询功能3.2员工工资添加功能3.3员工工资修改功能3.4员工工资删除功能3.5工资表格更新功能 4.数据库设计wages4.1账号表设计account4.2工资表设计wages 5.EPMS项目搭建5.1项目搭建如图所示5.2项目搭建每个package的作用和相互之间的联系 工资管理系统EPMS 这个项目是基于javaswing和mysql数据库所开发的
java编译器是eclipse，版本是2020-12-R
mysql管理工具是navicat，版本是8.1
1.功能模块设计 1.1java语言连接数据库jdbc 我们要通过java来操作数据库，首先就要把他们连接起来
代码实现逻辑：
四参五步：我们需要四个参数和五个步骤来成功连接数据库，在这之前，我们需要创建一个lib文件夹，然后再导入我们所需要的mysql-connector的jar包
四参：
加载jdbc连接mysql的驱动driver连接mysql数据库的地址url连接msyql的用户名user连接mysql的密码password 五步：
加载jdbc的驱动连接mysql的连接对象预编译sql执行执行sql语句关闭数据库 代码如下：
package com.jdbc; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; public class DBConnection { //1.加载jdbc连接mysql的驱动 public final static String driver = "com.mysql.cj.jdbc.Driver"; //2.连接mysql数据库的地址 public final static String url = "jdbc:mysql://localhost:3306/wages"; //3.连接mysql的用户名 public final static String user = "root"; //4.连接mysql的密码 public final static String pwd = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79f6ce210f045d038c20a85ed2a6e37d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00303ffc5ef191c9ce5b389c23913b34/" rel="bookmark">
			Transformers x SwanLab：可视化NLP模型训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HuggingFace 的 Transformers 是目前最流行的深度学习训框架之一（100k+ Star），现在主流的大语言模型（LLaMa系列、Qwen系列、ChatGLM系列等）、自然语言处理模型（Bert系列）等，都在使用Transformers来进行预训练、微调和推理。
SwanLab是一个深度学习实验管理与训练可视化工具，由西安电子科技大学团队打造，融合了Weights &amp; Biases与Tensorboard的特点，能够方便地进行 训练可视化、多实验对比、超参数记录、大型实验管理和团队协作，并支持用网页链接的方式分享你的实验。
你可以使用Transformers快速进行模型训练，同时使用SwanLab进行实验跟踪与可视化。
下面将用一个Bert训练，来介绍如何将Transformers与SwanLab配合起来：
1. 代码中引入SwanLabCallback from swanlab.integration.huggingface import SwanLabCallback SwanLabCallback是适配于Transformers的日志记录类。
SwanLabCallback可以定义的参数有：
project、experiment_name、description 等与 swanlab.init 效果一致的参数, 用于SwanLab项目的初始化。你也可以在外部通过swanlab.init创建项目，集成会将实验记录到你在外部创建的项目中。 2. 传入Trainer from swanlab.integration.huggingface import SwanLabCallback from transformers import Trainer, TrainingArguments ... # 实例化SwanLabCallback swanlab_callback = SwanLabCallback() trainer = Trainer( ... # 传入callbacks参数 callbacks=[swanlab_callback], ) 3. 案例-Bert训练 查看在线实验过程：BERT-SwanLab
下面是一个基于Transformers框架，使用BERT模型在imdb数据集上做微调，同时用SwanLab进行可视化的案例代码
""" 用预训练的Bert模型微调IMDB数据集，并使用SwanLabCallback回调函数将结果上传到SwanLab。 IMDB数据集的1是positive，0是negative。 """ import torch from datasets import load_dataset from transformers import AutoTokenizer, AutoModelForSequenceClassification, Trainer, TrainingArguments from swanlab.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00303ffc5ef191c9ce5b389c23913b34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26bc504490227eb88400ab0dba7ebe88/" rel="bookmark">
			Llama模型家族训练奖励模型Reward Model技术及代码实战（三） 使用 TRL 训练奖励模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LlaMA 3 系列博客 基于 LlaMA 3 + LangGraph 在windows本地部署大模型 （一）
基于 LlaMA 3 + LangGraph 在windows本地部署大模型 （二）
基于 LlaMA 3 + LangGraph 在windows本地部署大模型 （三）
基于 LlaMA 3 + LangGraph 在windows本地部署大模型 （四）
基于 LlaMA 3 + LangGraph 在windows本地部署大模型 （五）
基于 LlaMA 3 + LangGraph 在windows本地部署大模型 （六）
基于 LlaMA 3 + LangGraph 在windows本地部署大模型 （七）
基于 LlaMA 3 + LangGraph 在windows本地部署大模型 （八）
基于 LlaMA 3 + LangGraph 在windows本地部署大模型 （九）
基于 LlaMA 3 + LangGraph 在windows本地部署大模型 （十）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26bc504490227eb88400ab0dba7ebe88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00ed499cdc2ceba70006339bded08131/" rel="bookmark">
			LabVIEW高低温试验箱控制系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要实现LabVIEW高低温试验箱控制系统，需要进行硬件配置、软件设计和系统集成，确保LabVIEW能够有效地监控和控制试验箱的温度。以下是详细说明：
硬件配置 选择合适的试验箱：
确定高低温试验箱的型号和品牌。
确认试验箱是否支持外部通信接口（如RS-232、RS-485、以太网等）。
通信接口配置：
配置试验箱的通信接口，确保其与PC的连接稳定。
使用适配器（如RS-232到USB转换器）连接试验箱和PC（如有需要）。
传感器和执行器：
确保试验箱配备温度传感器和控制器，以实现精确的温度监控和调节。
配置与LabVIEW兼容的数据采集卡（如NI DAQ）或使用PLC进行中间控制。
软件设计 安装LabVIEW和相关工具包：
安装LabVIEW软件及相关的模块（如LabVIEW DAQ、LabVIEW DSC模块）。
通信协议配置：
根据试验箱的接口类型，选择合适的通信协议（如Modbus、RS-232）。
使用LabVIEW的相应通信功能块配置通信参数（如波特率、数据位、停止位等）。
程序开发：
创建VI：在LabVIEW中创建虚拟仪器（VI），用于与试验箱进行通信。
温度读取：编写程序读取试验箱的温度数据，并实时显示在LabVIEW界面上。
温度控制：编写程序向试验箱发送温度设定值，实现对温度的闭环控制。
用户界面设计：
设计友好的用户界面，显示当前温度、设定温度、实时曲线等信息。
添加控制按钮和输入框，方便用户操作和设置温度参数。
系统集成与调试 硬件连接测试：
确保所有硬件连接正确，通信正常。
调试LabVIEW程序，确保能正确读取和发送数据。
系统调试：
进行系统整体调试，检查温度控制的准确性和响应速度。
根据调试结果，优化程序和控制算法，确保系统稳定可靠。
故障处理与安全措施：
实现故障检测和报警功能，如通信中断、温度异常等情况的处理。
添加安全措施，防止过温或温度控制失效，保护设备和试验样品。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50bd4bc9d5035c6eb11581a0e3f32a76/" rel="bookmark">
			Android 项目Gradle文件讲解（Groovy和Kotlin）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 项目Gradle文件讲解（Groovy和Kotlin） 前言正文一、Gradle的作用二、Gradle的种类① 工程build.gradle② 项目build.gradle③ settings.gradle④ gradle.properties⑤ gradle-wrapper.properties⑥ local.properties 三、Groovy和Kotlin的语言对比① 开启ViewBinding、DataBinding和buildConfig② 添加依赖库③ 添加lib库中的jar使用④ 配置Jitpack仓库⑤ 自定义打包信息 四、源码 前言 在Android应用开发中，Gradle是很重要的，它关系到你的项目能否正常编译运行，构建APK等等，而随着Android Studio编辑器的更新，Gradle也发生了一些变化。
正文 Gradle 在 Android 开发中扮演了重要角色，它提供了灵活和可扩展的构建工具，使得 Android 项目的构建过程变得更加高效和便捷。
在很多版本中Android Studio中Gradle的主要语言都是Groovy，而在新版本的Android Studio，主要语言换成了Kotlin，虽然你仍然可以选择使用Groovy，但是我们是不是应该知道两者之间的编写方式和规则。出现了问题也要知道怎么解决。
一、Gradle的作用 Gradle 是一种基于 Groovy 的构建工具，被用于 Android 项目的构建、编译和打包。它提供了强大的构建自动化功能，使得在 Android 应用开发中管理依赖、设置环境和自定义构建流程变得更加方便和灵活。
在 Android 开发中，Gradle 被广泛用于构建项目、处理依赖、运行测试、生成 APK 等任务。下面是一些关于 Android 中的 Gradle 的重要说明：
构建脚本： Android 项目中的 build.gradle 文件是 Gradle 的核心配置文件。它定义了项目的构建设置、依赖关系和任务。通常，一个 Android 项目包含根目录下的 build.gradle 文件和每个模块（如 app 模块）下的 build.gradle 文件。
插件： Android Gradle 插件是为了与 Android 构建系统集成而设计的 Gradle 插件。在项目的 build.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50bd4bc9d5035c6eb11581a0e3f32a76/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/334/">«</a>
	<span class="pagination__item pagination__item--current">335/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/336/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>