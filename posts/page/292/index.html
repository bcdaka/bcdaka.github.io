<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cc5ab40afbf09dab5df016282c866ae/" rel="bookmark">
			mysql之日期时间函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是 MySQL 中一些常用的日期和时间函数，包括它们的用法、参数类型和期望的结果。
NOW() 返回当前日期和时间。
参数：无
结果类型：DATETIME
示例：
SELECT NOW(); -- 结果: '2023-04-01 12:45:31' （取决于查询时的实际日期和时间） CURDATE() 返回当前日期。
参数：无
结果类型：DATE
示例：
SELECT CURDATE(); -- 结果: '2023-04-01' （取决于查询时的实际日期） CURTIME() 返回当前时间。
参数：无
结果类型：TIME
示例：
SELECT CURTIME(); -- 结果: '12:45:31' （取决于查询时的实际时间） DATE_ADD(date, INTERVAL expr type) 在日期 date 上加上一个时间间隔 expr。
参数：date 是一个日期或日期时间表达式；expr 是你希望添加的时间间隔数值；type 是间隔的类型（比如，DAY, MONTH, YEAR, HOUR, 等）。
结果类型：与 date 参数类型相同
示例：
SELECT DATE_ADD('2023-04-01', INTERVAL 1 DAY); -- 结结果: '2023-04-02' DATE_SUB(date, INTERVAL expr type) 从日期 date 中减去一个时间间隔 expr。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cc5ab40afbf09dab5df016282c866ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/225a0a70af6f38e9c96a3d8de66c242d/" rel="bookmark">
			通过SSH远程登录华为设备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01 进入系统编辑视图
system-view
Enter system view, return user view with return command.
02 创建本地RSA密钥对
[HUAWEI]rsa local-key-pair creat
The key name will be:HUAWEI_Host
The range of public key size is (2048 ~ 2048).
NOTE: Key pair generation will take a short while.
03 配置vty界面支持的登录协议
[HUAWEI] user-interface vty 0 4
[HUAWEI-ui-vty0-4]authentication-mode aaa
Warning: The level of the user-interface(s) will be the default level of AAA users, please check whether it is correct.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/225a0a70af6f38e9c96a3d8de66c242d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7fe468d0b9aee29d817df7579b0db5c/" rel="bookmark">
			Python魔法之旅-魔法方法(22)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、概述
1、定义
2、作用
二、应用场景
1、构造和析构
2、操作符重载
3、字符串和表示
4、容器管理
5、可调用对象
6、上下文管理
7、属性访问和描述符
8、迭代器和生成器
9、数值类型
10、复制和序列化
11、自定义元类行为
12、自定义类行为
13、类型检查和转换
14、自定义异常
三、学习方法
1、理解基础
2、查阅文档
3、编写示例
4、实践应用
5、阅读他人代码
6、参加社区讨论
7、持续学习
8、练习与总结
9、注意兼容性
10、避免过度使用
四、魔法方法
68、__setattr__方法
68-1、语法
68-2、参数
68-3、功能
68-4、返回值
68-5、说明
68-6、用法
69、__setitem__方法
69-1、语法
69-2、参数
69-3、功能
69-4、返回值
69-5、说明
69-6、用法
70、__sizeof__方法
70-1、语法
70-2、参数
70-3、功能
70-4、返回值
70-5、说明
70-6、用法
五、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、博客个人主页
一、概述 1、定义 魔法方法(Magic Methods/Special Methods，也称特殊方法或双下划线方法)是Python中一类具有特殊命名规则的方法，它们的名称通常以双下划线(`__`)开头和结尾。
魔法方法用于在特定情况下自动被Python解释器调用，而不需要显式地调用它们，它们提供了一种机制，让你可以定义自定义类时具有与内置类型相似的行为。
2、作用 魔法方法允许开发者重载Python中的一些内置操作或函数的行为，从而为自定义的类添加特殊的功能。
二、应用场景 1、构造和析构 1-1、__init__(self, [args...])：在创建对象时初始化属性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7fe468d0b9aee29d817df7579b0db5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baee52187e04166acf34eab68bb24a40/" rel="bookmark">
			PHP超详细安装及应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
所需安装包如下
一、PHP安装
依赖包安装
安装扩展工具（先将PHP所需的软件包全部拖进centos根目录下）
安装libmcrypt
安装mhash
安装mcrypt
安装PHP
二、设置LAMP组件环境（要保证mysql、http都安装完成了）
Php.ini的建立及基本配置
添加zendguardloader优化模块
Httpd.conf配置调整
重启服务更新配置
三、测试LAMP协同工作
测试php网页能否正确显示
创建php测试文件
网站访问
测试php网站能否访问mysql数据库
创建测试文件
四、部署phpmyadmin系统
访问管理页面，输入mysql的用户以及密码
登录成功
所需安装包如下 PHP（PHP: Hypertext Preprocessor）即“超文本预处理器”，是在服务器端执行的脚本语言，尤其适用于Web开发并可嵌入HTML中。PHP语法学习了C语言，吸纳Java和Perl多个语言的特色发展出自己的特色语法，并根据它们的长项持续改进提升自己，例如java的面向对象编程，该语言当初创建的主要目标是让开发人员快速编写出优质的web网站。 PHP同时支持面向对象和面向过程的开发，使用上非常灵活
一、PHP安装 依赖包安装 rpm -ivh /run/media/root/CentOS\ 7\ x86_64/Packages/zlib-devel-1.2.7-18.el7.x86_64.rpm rpm -ivh /run/media/root/CentOS\ 7\ x86_64/Packages/xz-devel-5.2.2-1.el7.x86_64.rpm rpm -ivh /run/media/root/CentOS\ 7\ x86_64/Packages/libxml2-devel-2.9.1-6.el7.5.x86_64.rpm 安装扩展工具（先将PHP所需的软件包全部拖进centos根目录下） 安装libmcrypt //解压 tar zxf libmcrypt-2.5.8.tar.gz -C /usr/src/ //切换目录 cd /usr/src/libmcrypt-2.5.8/ //编译及安装 make &amp;&amp; make install //创建软链接 ln -s /usr/local/lib/libmcrypt.* /usr/lib/ 安装mhash tar zxf mhash-0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/baee52187e04166acf34eab68bb24a40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc16eb39dd95e918ef1ee9df15ccc84d/" rel="bookmark">
			mysql之数字函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当然，以下是一些常用的 MySQL 数学函数的详细介绍和示例，包括调用这些函数后的结果。
ABS(x) 返回 x 的绝对值。
SELECT ABS(-42); -- 结果: 42 CEILING(x) 或 CEIL(x) 返回大于或等于 x 的最小整数值。
SELECT CEILING(42.7); -- 结果: 43 FLOOR(x) 返回小于或等于 x 的最大整数值。
SELECT FLOOR(42.7); -- 结果: 42 ROUND(x, d) 将 x 四舍五入到小数点后 d 位，如果 d 被省略，则默认到最近的整数。
SELECT ROUND(42.789, 2); -- 结果: 42.79 SELECT ROUND(42.789); -- 结果: 43 RAND() 或 RAND(N) 返回一个随机浮点值 v，在 0 到 1.0 之间（不包括 1.0）。如果提供了一个整数参数 N，它会作为种子值，用于生成重复的随机数序列。
SELECT RAND(); -- 结果: 随机数，如 0.3456（每次调用结果不同） SELECT RAND(42); -- 结果: 为种子值 42 产生的随机数，如 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc16eb39dd95e918ef1ee9df15ccc84d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7916506bb9e40cf368eabcb70c683511/" rel="bookmark">
			C语言详解（动态内存管理）1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hi~！这里是奋斗的小羊，很荣幸您能阅读我的文章，诚请评论指点，欢迎欢迎 ~~
💥💥个人主页：奋斗的小羊
💥💥所属专栏：C语言
🚀本系列文章为个人学习笔记，在这里撰写成文一为巩固知识，二为展示我的学习过程及理解。文笔、排版拙劣，望见谅。
目录 前言1、为什么要有动态内存分配2、malloc 和 free2.1 malloc2.2 free 3、calloc 和 realloc3.1 calloc3.2 realloc 总结 前言 本篇文章将介绍C语言中除指针和结构体外又一重要的内容——动态内存管理
在C语言中，我们更多的需要手动分配和释放内存，这意味着我们必须正确地管理内存，以避免内存泄漏、内存溢出和其他内存错误，这些错误可能导致程序崩溃或安全漏洞。因此，了解内存管理是编写高质量、高效率和健壮性程序的重要部分。
1、为什么要有动态内存分配 目前我们申请内存的方法有两种，创建相关类型变量int n = 0;和创建相关类型数组int arr[10] = { 0 };
但是这样申请的内存是有缺点的：
申请的内存大小是有限的，不能指定大小
数组在声明的时候必须指定长度，数组空间一旦确定下来就不能调整
数组空间在申请前我们不能给出一个准确的大小，大了浪费，小了不够
有时候我们需要的空间大小在程序运行的时候才能知道，那数组的编译时开辟空间的方式就不能满足了
为了解决这个问题，C语言引入了动态内存开辟，让我们可以自己申请和释放内存，这样就比较灵活了
空间不够我们可以增大，空间太大我们可以缩小
2、malloc 和 free 使用动态内存管理函数都需要包含头文件&lt;stdlib.h&gt;
2.1 malloc C语言提供了一个动态内存开辟的函数malloc
void* malloc(size_t size); malloc 函数的作用是开辟一块指定大小的、连续的、有限的内存空间，大小由size 决定，是不能开辟无限空间的
在x86环境下开辟一块超大内存空间，若开辟失败打印出失败原因：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int* p = (int*)malloc(INT_MAX);//INT_MAX=2147483647 if (p == NULL) { //空间开辟失败 perror("malloc"); //失败后用return终止程序 return 1; } return 0; } 对于malloc函数，我们需要注意：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7916506bb9e40cf368eabcb70c683511/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/792d3c2d173f69c03c163b6e1baca27c/" rel="bookmark">
			【C&#43;&#43;】用红黑树封装map、set
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用红黑树封装map、set 1. 红黑树1.1 模板参数的控制1.1.1 Value1.1.2 KeyOfValue 1.2 正向迭代器1.2.1 构造函数1.2.2 begin()+end()1.2.3 operator++()1.2.4 operator--()1.2.5 operator*()1.2.6 operator-&gt;()1.2.7 operator==()1.2.8 operator!=()1.2.9 总代码 1.3 反向迭代器1.3.1 rbegin()+rend()1.3.2 总代码 1.4 find()1.5 insert() 2. Map2.1 operator[] 3. typename作用4. 完整代码4.1 Map.h4.2 Set.h4.3 RBTree.h 1. 红黑树 set是K模型，map是KV模型，二者底层都是使用红黑树来实现的，所以我们可以将红黑树设置为模板，即：set、map复用同一个类模板的红黑树。 1.1 模板参数的控制 1.1.1 Value Value决定你是k模型的set、还是KV模型的map。 enum Color { //枚举，一一列举出事物具有的所有可能 Red, //枚举常量，给枚举变量进行赋值 Black, }; template&lt;class T&gt;//红黑树的节点 struct RBTreeNode { typedef RBTreeNode&lt;T&gt; Node; //三叉链-》优点：便于查找孩子、父亲节点 Node* _left; //该节点的左孩子 Node* _right; //该节点的右孩子 Node* _parent; //该节点的父亲，便于向上更新 T _data; Color _col; RBTreeNode(const T&amp; data, Color col = Red) //构造函数 :_data(data) , _left(nullptr) , _right(nullptr) , _parent(nullptr) , _col(col) //默认新插入节点的颜色为红色 { } }; //Value决定你是k模型的set、还是KV模型的map template&lt;class K, class T, class KeyOfT&gt; class RBTree { public: typedef RBTreeNode&lt;T&gt; Node; }; template&lt;class K&gt; class set{ //K模型 public: private: //set中的key不允许被修改 RBTree&lt;K, const K, SetKeyOfT&gt; _t; //红黑树对象 }; } template&lt;class K, class V&gt; class map { //KV模型 public: private: //map中的key不允许被修改 RBTree&lt;K, pair&lt;const K, V&gt;, MapKeyOfT&gt; _t; //红黑树对象 }; }; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/792d3c2d173f69c03c163b6e1baca27c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55d3930e9ec904a56f97aa85f374049a/" rel="bookmark">
			【CVE-2024-4577】PHP CGI 远程代码执行漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 转载 本文出自：【CVE-2024-4577】PHP CGI 远程代码执行漏洞 - 极核GetShell (get-shell.com)
# 漏洞描述 PHP 语言在设计时忽略Windows 作业系统内部对字元编码转换的Best-Fit特性，导致未认证的攻击者可透过特定的字元序列绕过旧有CVE-2012-1823的保护，透过参数注入等攻击在远端PHP 服务器上执行任意代码。该漏洞在特定PHP版本和简体（繁体）中文、日语语言等语言环境下的Windows平台，可以绕过CVE-2012-1823的保护。
# 影响版本 PHP 8.3 &lt; 8.3.8PHP 8.2 &lt; 8.2.20PHP 8.1 &lt; 8.1.29Windows平台的语言环境 繁体中文(字码页950)简体中文(字码页936)日文(字码页932)对于其它执行在英文、韩文、西欧语系之 Windows 操作系统，由于 PHP 使用情境广泛、暂无法完全列举并排除其利用情境，因此还是建议用户全面盘点资产、确认使用情境并更新 PHP 至最新版本确保万无一失！ # 修补建议 更新到PHP官方发布的最新PHP版本如无法更新建议编写Rewrite 规则阻止攻击，注意：此份规则只作为繁体中文、简体中文及日文语系中的暂时性缓解机制，建议以更新版本进行修复 RewriteEngine On RewriteCond %{QUERY_STRING} ^%ad [NC] RewriteRule .? - [F,L] # 漏洞复现 GET /test.php?%add+allow_url_include%3don+%add+auto_prepend_file%3dphp://input HTTP/1.1 Host: 172.17.148.112 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.54 Safari/537.36 Accept: image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55d3930e9ec904a56f97aa85f374049a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8af3c88dcd77190f569873f042804e54/" rel="bookmark">
			【C&#43;&#43;进阶】深入STL之list：模拟实现深入理解List与迭代器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📝个人主页🌹：Eternity._
⏩收录专栏⏪：C++ “ 登神长阶 ”
🤡往期回顾🤡：初步了解 list
🌹🌹期待您的关注 🌹🌹
❀STL之list 📒1. list的基本结构📕2. list的模拟实现🌈构造函数🌞析构函数🌙拷贝构造函数⭐赋值运算符重载 📚3. list的迭代器🍂迭代器的基本结构🍁迭代器的运算符重载🌸list的迭代器 📙4. list的const迭代器🎩方法一🎈方法二 📜5. 统一的方式访问STL容器中的元素📔6. list与vector的对比📖7. 总结补充💧补充：insert和erase的模拟实现🔥总结 在软件开发中，数据结构和算法的选择与实现是每一个开发者都必须面对的问题。标准模板库（STL）为我们提供了一系列高效且通用的数据结构和算法模板，极大地简化了C++编程中的许多常见任务。然而，了解这些数据结构和算法背后的实现原理，不仅有助于我们更深入地理解STL，还能提升我们的编程能力和解决问题的能力。
前言： 在STL中，list是一种双向链表，它支持在序列的任何位置进行快速插入和删除操作。与此同时，迭代器是STL中非常重要的一个概念，它使得我们能够以统一的方式遍历和访问STL容器中的元素。在深入了解STL的过程中，模拟实现list和迭代器无疑是一个极有价值的学习过程。
本节我们将从基本的链表结构开始，逐步构建出完整的list类，并实现相应的迭代器类。
📒1. list的基本结构 list是一个个带头双向循环链表，这意味着每个元素（通常称为节点）都有两个指针：一个指向前一个元素，另一个指向后一个元素，因此我们需要单独再定义一个类来表示节点结构，每个节点再串联起来构成list
节点定义（示例）：
template&lt;class T&gt; struct list_node { T _data; list_node&lt;T&gt;* _next; list_node&lt;T&gt;* _prev; list_node(const T&amp; x = T()) :_data(x) ,_next(nullptr) ,_prev(nullptr) {} }; 而在构建list时，我们成员变量只需要一个头节点。
list定义（示例）：
template&lt;class T&gt; struct list { typedef list_node&lt;T&gt; Node; public: // 构造函数等可能的其他成员函数... private: Node* _head; }; 📕2. list的模拟实现 注意：关于erase和insert这两个函数的模拟我们依然作为补充放在末尾
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8af3c88dcd77190f569873f042804e54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12838936752d0841728a61498ae4b21f/" rel="bookmark">
			探秘大数据的宇宙 —— bigdata-hub项目深度剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		探秘大数据的宇宙 —— bigdata-hub项目深度剖析 在大数据洪流涌动的时代，如何高效地管理和分析海量数据成为了一项至关重要的技能。今天，我们将一起探索一个汇聚了大数据领域精华的开源宝藏——bigdata-hub。这不仅仅是一个项目，更是一扇通往数据科学广阔世界的门户。
项目介绍 bigdata-hub是为了解锁大数据领域的无限可能而生的全面资源库，它覆盖了从基础框架到前沿技术的每一个角落。这里集结了Hadoop、Spark、Flink等重量级计算框架，到HBase、Kafka等关键存储解决方案，再到数据调度系统如Oozie、Azkaban等，形成了一个完整的生态链，旨在支持开发者和数据工程师快速上手并优化大数据处理流程。
项目技术分析 此项目的核心价值在于其系统的知识组织结构，它按照大数据的技术栈分门别类，细致入微地涵盖了每个技术点的学习路径和实战案例。例如，在Hadoop部分，不仅有基础操作指南，还有企业级别的优化实践；而在Spark领域，则深入到了Spark SQL和流处理应用的细节。对于数据存储爱好者，Elasticsearch和Zookeeper的文档同样不容错过，它们解释了如何利用这些工具来构建高可用的数据存储系统。
项目及技术应用场景 bigdata-hub提供的技术蓝图广泛应用于数据仓库建设、实时分析、数据集成等多个场景。在数据仓库建设部分，你可以找到如何结合Hive和Spark构建实时数仓的最佳实践；对于追求效率的企业来说，通过DolphinScheduler进行复杂作业调度，或是采用DataSphere Studio打造一站式数据平台，都是提升数据处理能力的关键。此外，对于正兴起的湖仓一体化趋势，如Hudi的介绍，让开发者能够紧跟行业动态，构建更为灵活的数据架构。
项目特点 全面性：几乎囊括了大数据生态系统的所有重要组成部分。深度学习资源：每个技术分支下都配以详细的教程和实战案例，适合初学者到专家各个层次。生态整合：强调不同技术间的集成应用，帮助用户理解如何构建端到端的大数据解决方案。前沿技术追踪：持续更新的前沿技术板块，确保用户不落后于最新的技术潮流，如数据中台和DataOps。实际操作指南：环境搭建到应用实施的全程指导，减少入门壁垒，加速项目启动。 在大数据这片星辰大海中航行，bigdata-hub就如同一位经验丰富的导航员，带领着每一位探险者走向知识的深处，发掘数据的无穷价值。无论是为了职业发展，还是出于对大数据技术的热爱，加入这个社区，将是你探索大数据世界的绝佳起点。立刻启程，开启你的大数据之旅吧！
通过本文的介绍，希望你已经对bigdata-hub这个宝藏项目产生了浓厚的兴趣。不论是想要快速上手大数据技术的新手，还是寻求提高现有技术水平的专业人士，bigdata-hub都将是你不可多得的宝贵资源。让我们共同在这片浩瀚的数据海洋里扬帆远航。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb8baf2881c7690efbd6501604cab6a9/" rel="bookmark">
			如何解决移动硬盘在mac上只读不写 macbook无法显示移动硬盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你的Mac电脑有没有遇到过只读硬盘无法写入的问题呢？如果你遇到了这种问题又是怎么解决的呢？很多用户可能通过格式化为其他文件系统格式来解决此问题。本文就来教大家如何解决移动硬盘在mac上只读不写，并且教大家macbook无法显示移动硬盘怎么解决。
一、如何解决移动硬盘在mac上只读不写
相信很多Mac用户在使用外置磁盘（移动硬盘、U盘等外置存储设备）过程中，都遇到过图1所示的情况，将文件拖入磁盘内，文件上显示图示标识，无法拷贝进去，但是可以正常查看磁盘内的文件，这是怎么回事呢？
图1：无法复制
查看磁盘简介可以看到，如图2所示，磁盘的系统格式为NTFS格式，并且下方Mac提示“您只可以读”，这就是问题所在。如何解决移动硬盘在mac上只读不写呢？
图2：NTFS格式磁盘
因为使用的是NTFS格式磁盘，由于系统限制，Mac系统并不支持NTFS格式磁盘写入，这也是Mac的“槽点”。那么有没有什么办法可以在Mac系统上拥有对NTFS格式磁盘的“写”的权限呢？答案是：有。
准备工具：Tuxera NTFS for Mac
Tuxera ntfs for mac是一款Mac完全读写软件，不仅可轻松解决Mac无法读写NTFS磁盘的问题，还能对磁盘进行修复、格式化操作，提升数据读写的安全性、便捷性。
Tuxera NTFS for Mac 2023中文免费安装包：https://souurl.cn/IE35lO
图3：Tuxera NTFS for Mac
安装成功后，首次启动需要手动开启内核批准，根据提示操作即可。最后，保证该软件为“已启用”状态，你的Mac电脑就可以写入NTFS格式硬盘了。
图4：内核扩展批准
如果仍然无法写入磁盘，可以尝试重启电脑。另外，请确保软件处于“已启用”状态。
图5：已启用Tuxera NTFS for Mac
完成上述操作，Mac系统就可以正常写入NTFS格式磁盘了，此时再查看磁盘简介，可以看到，仍然是NTFS格式磁盘，此时mac提示“您可以读与写”。
图6：拥有写的权限
二、macbook无法显示移动硬盘
如果你的Macbook在桌面不显示硬盘，你可在mac的桌面上点击“访达-偏好设置—通用”，勾选外置磁盘，并且在“边栏”勾选“硬盘”。如果这两项未勾选，即使移动硬盘与Mac电脑连接成功，Mac桌面也不显示。
图7：勾选外置磁盘
如果勾选了此选项，插入后仍然不显示，不排除是移动硬盘自身问题导致的。你可以尝试检查移动硬盘是否存在“坏道”，使用Tuxera NTFS for Mac这款软件即可检测以及修复。实际上Tuxera NTFS for Mac不仅是一款运行在mac电脑上的磁盘读写工具，也是一款功能强大的磁盘管理工具，它能解决磁盘无法正常显示以及磁盘常规管理，是管理mac磁盘不错的辅助工具。借助这款软件可以检查移动硬盘是否损坏，如果损坏可以尝试修复。
在启动台启动“Tuxera”，选中你的移动硬盘后，选择上方“维护”，点击“检查”后，该软件会自动执行检查程序，如果移动硬盘存在任何问题，可以点击“修复”按钮尝试修复。
图8：检查移动硬盘
三、总结
本文为大家介绍了如何解决移动硬盘在Mac上只读不写的问题。如果你在Mac电脑上使用了NTFS格式的移动硬盘，并且电脑上未安装NTFS For Mac工具，就会遇到“只读不写”的情况，解决方法就是在你的Mac电脑上安装Tuxera NTFS for Mac。本文还为大家介绍了怎么解决macbook无法显示移动硬盘的问题。如果你遇到了类似的情况，可以参考本文解决。
Tuxera NTFS for Mac 2023中文免费安装包下载：https://souurl.cn/IE35lO
Tuxera NTFS for Mac永久激活入口：https://souurl.cn/kg02Ve
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/500704d9d51fb0b939ce8306ebe21f9a/" rel="bookmark">
			自制植物大战僵尸：HTML5与JavaScript实现的简单游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在本文中，我们将一起探索如何使用HTML5和JavaScript来创建一个简单的植物大战僵尸游戏。这不仅是一项有趣的编程挑战，也是学习游戏开发基础的绝佳机会。
什么是植物大战僵尸？ 植物大战僵尸是一款流行的策略塔防游戏，玩家需要种植不同类型的植物来防御进攻的僵尸。我们的目标是复现这款游戏的核心机制，以一个简化的版本呈现。
准备工作 在开始编码之前，你需要具备基本的HTML、CSS和JavaScript知识。此外，一个代码编辑器（如VS Code或Sublime Text）将帮助你编写和测试代码。
比如:
HBulider
HTML结构 首先，我们创建HTML页面的基本结构，包括&lt;!DOCTYPE html&gt;, &lt;html&gt;, &lt;head&gt;, 和 &lt;body&gt;标签。在&lt;head&gt;部分，我们定义了页面的元数据和标题。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;植物大战僵尸&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; CSS样式 接下来，我们添加内联&lt;style&gt;标签来定义游戏的样式。这包括背景、按钮、植物、僵尸和动画等元素的样式。
body { * { margin: 0; padding: 0; /* 设置怪异盒子 */ box-sizing: border-box; } body{ background-color:#949489; } #app { margin: 50px auto; width: 1400px; height: 600px; border: 5px solid #010101; border-radius: 50px; background-image: url(../images/background1.jpg); background-repeat: no-repeat; background-size: cover; position: relative; } #topui { width: 1200px; height: 45px; position: absolute; top: 10px; left: 150px; } /* 能量栏 */ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/500704d9d51fb0b939ce8306ebe21f9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ff9b565d464f362cdccad1ecce6451e/" rel="bookmark">
			推荐文章：PyDeequ - 大数据质量的守护者
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐文章：PyDeequ - 大数据质量的守护者 在大数据时代，确保数据的质量是数据分析和机器学习成功的基石。今天，我们有幸介绍一款强大的工具——PyDeequ，这是专为Python开发者量身打造的数据质量检验框架，源于AWS Labs的创新成果Deequ，它让数据的“单元测试”变得前所未有的简单与强大。
项目介绍 PyDeequ是一个基于Apache Spark的Python接口，旨在简化大规模数据集的数据质量检查。通过提供一个高效且直观的API，PyDeequ使得定义和执行数据验证规则成为一件轻而易举的事情。这个项目桥接了Python社区与Deequ的强大力量，让你能够在熟悉的环境中实施复杂的 数据质量和一致性检查。
项目技术分析 PyDeequ的核心功能围绕着四个关键组件：
指标计算：利用Analyzers进行数据剖析，生成每一列的数据概要。约束建议：自动提出基于不同分析组的验证约束，以确保数据的一致性。约束验证：依据设定的标准对数据集进行实时或批量验证。度量存储库：实现对验证历史的跟踪与存储，便于持续监控数据质量。 其架构设计高效，支持灵活的集成与扩展，尤其是对Apache Spark的支持，使得处理PB级数据成为可能。
项目及技术应用场景 PyDeequ适用于多种场景：
数据湖治理：在AWS生态系统内，通过结合AWS Glue、Athena和SageMaker，PyDeequ能有效监测和提升数据湖中的数据质量。实时数据流检查：在大型应用中，实时监控流式数据源，确保数据准确无误。数据仓库维护：在ETL流程中，对导入数据进行全面检查，预防错误信息进入下游分析。机器学习预处理：保障训练数据的质量，提高模型的可靠性和准确性。 项目特点 便捷性：简单的安装过程，无缝集成到现有的PySpark工作流中。灵活性：支持定制化数据分析与验证规则，适应各种数据质量需求。全面性：覆盖数据完整性、一致性等多维度质量检查。可追溯性：通过度量存储库记录每一次数据校验的结果，便于审计和历史比较。社区活跃：拥有活跃的开发者社区，并提供了详尽的文档和教程资源，以及便捷的Slack交流频道。 结语 如果你正寻找一种高效、可靠的手段来提升你的数据管道的数据质量，PyDeequ无疑是一个值得探索的宝藏。通过其强大的功能集合和友好的Python接口，PyDeequ能够让数据科学家和工程师们更加专注于洞察而非数据清洗的繁重工作。立即加入这一先进技术的使用者行列，让你的数据分析之旅更加顺畅、可信。让我们一起，用PyDeequ守护数据之光！
本文介绍了PyDeequ的概览、技术优势、应用场景及其独特的项目特性，希望能够激发你对高质量数据管理的兴趣，将PyDeequ的力量融入到你的数据工作中去。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87ba50dcb23bf7afec689af01bb6c1d1/" rel="bookmark">
			直流放大器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，概念及存在问题 集成电路主要由半导体材料构成，其内部适合用二极管，三极管等类型的元器件制作，而不适用电容，电感和变压器，因此集成放大电路内部多个放大电路之间通常采用直接耦合。直接耦合电路除了可以放大交流信号外，还可以放大直流信号，所以直流耦合放大电路又称为直流放大器。
直流放大器在传输信号时不会使信号衰减，但是前后级电路之间的静态工作点会互相影响，而且容易出现零点偏移。下面介绍两种方法的解决办法。
二，静态工作点互相影响的问题 1，问题解析 如下图所示为一个两级直接耦合直流放大器。从图中可以看出，VT1的集电极Uc1和VT2基极Ub2大小相等，由于PN结的导通电压为0.7V所以Ub2=Uc1=0.7V，而VT1的基极和发射极导通电压也为0.7V，所以Ub1=0.7V，这时Uc1=Ub1，如果给Ub1加上正向电压信号会使Ub1上升，Uc1下降，这时Uc1&lt;Ub1，VT1就会进入饱和状态，这就是静态工作点互相影响导致的问题。具体解决方法有在后级电路中增加发射极电阻，在后级电路中增加稳压二极管，将PNP型三极管和NPN型三极管配合使用。
2，在后级电路中增加发射极电阻 在VT2的发射极增加发射极电阻来抬高VT2的发射极电压，VT2基极电压也被抬高，VT1集电极电压也被抬高，这样VT1不易进入饱和状态。发射极电阻R5越大抬高的电压也就越高，VT1也就越不容易进入饱和状态，但是R5太高会导致基极电流减少，这样流过三极管的电流就会减少而导致三极管的放大能力下降，这也是这种方法的缺点。
3，在后级电路增加稳压二极管 在VT2的发射极增加一个稳压二极管VZ(R5用来提高发射极电压达到稳压二极管的击穿电压，否则发射极电压太低无法达到稳压效果，发射极会断路)，来抬高VT2发射极电压。选用不同稳压值的稳压二极管可以将Ue2抬高到不同的电压，另外稳压二极管击穿导通电压不是很大，不会使VT2基极的电流减少太多，VT2仍有较大放大能力。
4， 将PNP型三极管和NPN型三极管配合使用 VT2为PNP型三极管，它的发射极电压比它的基极电压高0.7V，所以可以抬高VT2的基极电压，而且电阻R4在发射极电路，这样也不会影响VT1的电流大小。
三，零点漂移问题 一个直流放大器，在输入信号为0时，输出信号并不为0，这种现象称为0点漂移
下图电路，如果不存在零点漂移，当VT1的基极A点无信号输入时(即电位不变化时)，输出端B点的电位也不会变化，但实际上由于环境温度变化等某些原因，即使A点不变化，B点电位也会变化(比如环境温度升高，VT1的集电极电流Ic1升高导致E点电压下降，最终会导致输出端B点点位升高)。
放大级数越多，零点漂移越严重。如果输入信号很小，可能会导致信号被零点漂移信号淹没。产生零点漂移的原因很多，如温度的变化，电源电压的波动，元器件参数变化等，其中主要是三极管随温度变化而导致的Ic的变化。解决零点漂移的方法是选择温度性能好的三极管和其他元器件，电路供电采用稳定的电源，但这些无法从根本上解决零点漂移问题，最好的方法是采用差动放大电路作为直流放大器。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5189c51c52140b946dad3f94f568475b/" rel="bookmark">
			Android 14 Audio模块 音量增益 framework到HAL 层加载流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 背景概念Android Audio调用流程（app-framework-HAL）标记0 libaudioclient标记1 libaudioclient ：aps变量赋值标记1.1 binder变量赋值 标记2 audiopolicy标记4 audiopolicy：mAudioPolicyManager变量赋值 标记5 audiopolicy标记6 audiopolicy：mpClientInterface变量赋值 标记7 audiopolicy标记8 audiopolicy标记10 audioflinger标记11 audioflinger：hwDevice变量赋值 标记12 audioflinger标记12.1 hardware：load_audio_interface 标记13 hardware dumpsys调试 背景 平台：Android 14
在设备开机的过程中，需要设置用户关机前的音量，因此在开机时可获取当前音量值去设置某个端口的音量增益，来达到设备开机后的音量记忆。
概念 进入代码分析之前，重温一下平时设置的音量1-100和音量增益(Volume Gain)的关系，有助于更好理解Android音量设置原理。
平时在音频设备或软件中设置的音量（比如1-100的范围）通常是一个相对的量度，用于提供给用户一个直观的方式来控制音频输出的响度。这个音量设置并不直接对应于特定的分贝值，而是根据设备的硬件或软件配置来确定增益的大小。
以下是音量设置与增益关系的一般概念：
相对刻度 ： 音量滑块或旋钮上的1-100通常表示一个从非常安静到非常响亮的相对刻度。音量增益通常以分贝（dB）为单位进行度量，分贝是一个比例单位。具体的分贝值取决于系统的参考音量级别和增益范围。 线性关系 ： 在某些系统中，音量和增益可能呈线性关系，这意味着音量的每次增加或减少对应相同的分贝数。例如，音量每增加10，增益增加1 dB。 对数关系 ： 更常见的是，音量和增益之间存在对数关系，以模拟人耳对声音的感知。在对数刻度中，音量的增加不是均匀的，而是随着音量级别的增加而增加的。 系统校准 ： 音频系统通常会在校准过程中确定1-100音量级别与增益之间的确切映射。这涉及到设置参考音量（通常是0 dBFS，即满刻度信号）和最大音量对应的最大增益。 最大音量与增益 ： 最大音量（例如100）通常对应于系统能够安全输出的最大增益，而不会引起失真。这个最大增益可能是在特定音量级别下不会失真的最高分贝数。 最小音量与增益 ： 最小音量（例如1）则对应于系统可以输出的最小增益，仍然保持可听见的水平。这通常远高于0 dB SPL，因为人耳的听觉阈值非常低。 中间音量级别 ： 中间的音量级别（例如50）通常对应于系统增益的中间点，提供平衡的听感。 设备差异 ： 不同的音频设备和软件可能会有不同的音量和增益映射方式。 音量标准化 ： 有些系统可能会采用音量标准化技术，以确保不同音量级别下的音频输出保持一致的响度。 Android Audio调用流程（app-framework-HAL） 先上图
应用调用setStreamVolume函数设置音量后会调用mAudioManager.setAudioPortGain来设置硬件增益，达到设备开机后的音量增益记忆。
frameworks/base/services/core/java/com/android/server/tv/TvInputHardwareManager.java
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5189c51c52140b946dad3f94f568475b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8a2154035339a53f29be237ef8cab2b/" rel="bookmark">
			【postgresql初级使用】视图上的触发器instead of，替代计划的rewrite，实现不一样的审计日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		instead of 触发器 ​专栏内容：
postgresql使用入门基础手写数据库toadb并发编程 个人主页：我的主页
管理社区：开源数据库
座右铭：天行健，君子以自强不息；地势坤，君子以厚德载物.
文章目录 instead of 触发器概述 机制原理 INSTEAD OF 触发器语法 INSTEAD OF 触发器执行步骤 多触发器的优先级 审计案例解析 数据准备 创建两张数据表创建视图创建执行函数创建触发器 结果展示 信息查看新员工入职变岗调薪 总结 结尾 概述 在postgresql 中，触发器与SQL标准相比，有一个扩展特性就是可以在视图上创建触发器。
在视图上的触发器类型是’INSTEAD OF`，可以在insert, update, delete事件的before或after进行触发，
本文就来详细分享一下，并通过一个实用的审计数据的案例来展示效果。
机制原理 下面先来介绍SQL语法，然后通过介绍它的执行过程，了解它的机制原理。
INSTEAD OF 触发器语法 视图触发器的创建语法如下：
CREATE TRIGGER trigger_name INSTEAD OF [INSERT OR UPDATE OR DELETE] ON table_name FOR EACH ROW EXECUTE FUNCTION trigger_function; 在视图上的触发器，类型只有INSTEAT OF，而且它对应的触发器件有insert,update,delete，此处没有truncate事件。
另外，instead of 触发器也只能定义为行级触发器，这个原因下面会分析。
INSTEAD OF 触发器执行步骤 视图触发器执行的步骤如下
当在视图上执行INSERT、UPDATE或DELETE操作时，如果为该视图定义了INSTEAD OF触发器，那么这些操作不会直接对视图或其基础表执行。相反地，INSTEAD OF触发器会代替这些操作执行。也就是说，对于需要修改的每一行，都会触发INSTEAD OF触发器。触发器的函数需要负责执行必要的修改到视图的基础表，并在适当的情况下返回修改后的行，以便在视图中显示。这允许开发者在不影响基础表结构的情况下，通过视图执行复杂的操作逻辑。 如果视图上没有INSTEAD OF触发器，那么对视图的操作必须被转换为对基础表的操作，是直接操作基础表。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8a2154035339a53f29be237ef8cab2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05aafb2d5d3b0ca9850d426fea18662d/" rel="bookmark">
			【postgresql初级使用】触发器的创建删除，你不知道的触发器函数中的系统变量，数据一致性还可以这样来保证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用触发器 ​专栏内容：
postgresql使用入门基础手写数据库toadb并发编程 个人主页：我的主页
管理社区：开源数据库
座右铭：天行健，君子以自强不息；地势坤，君子以厚德载物.
文章目录 使用触发器概述 创建触发器 触发器函数 删除触发器 案例分析 数据准备 动作函数 增加触发器 触发结果 总结 结尾 概述 前一节介绍了触发器的原理，以及在postgresql中支持的触发器的类型，有基于行的触发器，也有基于SQL语句的触发器，同时触发的位置可以是执行前，也可以是执行后。
从本节开始介绍触发器的创建，使用，通过案例看看它们的什么样的区别。
创建触发器 触发器的创建语法如下：
CREATE TRIGGER trigger_name {BEFORE | AFTER} ON table_name [FOR [EACH] { ROW | STATEMENT }] EXECUTE { FUNCTION | PROCEDURE } trigger_function; 语法说明
触发器创建使用关键字 create trigger, 然后指定触发器的名称；使用关键字before 或者 after来指定是在执行前或者执行后触发；on指定触发器作用的表或视图；选择行触发器还是语句级触发器，行触发器使用for each row，而语句级触发器使用 for each statement; 当然each可以省略；最后指定动作执行函数；如果这里指定为function时，函数定义也必须为function,这里建议使用function， procedure是一种历史写法。 触发器函数 触发器的内容包含一个自定义的函数，所以首先得有一个执行动作的函数。
先来定义一个函数，如果触发就打印一条信息。
CREATE FUNCTION tri_fun() RETURNS TRIGGER LANGUAGE PLPGSQL AS $$ BEGIN -- trigger logic raise notice 'trigger excute'; END; $$ 函数说明 触发器使用的函数没有参数，在系统自动调用时会传入默认的参数；返回值类型必须为 trigger; 函数参数 在系统调用触发器函数时，会传入默认的参数，参数类型为TriggerData, 它的定义如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05aafb2d5d3b0ca9850d426fea18662d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f07d0b4ea33a56144ae441743fdf1ff/" rel="bookmark">
			java web计科毕业设计简单的项目选题100例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 前言2 选题汇总3 详细介绍 题目1 : 基于SpringBoot的敬老院管理系统 &lt;br /&gt; 题目2 : 基于Springboot的医院管理系统 &lt;br /&gt; 题目3 : 基于SSM的宠物领养系统&lt;br /&gt; 题目4 : 基于SSM的学生信息管理系统 &lt;br /&gt; 题目5 : 基于SpringBoot的养老院管理系统 &lt;br /&gt; 题目6 : 基于SSM的电影购票系统 &lt;br /&gt; 1 前言 🔥 这两年开始毕业设计和毕业答辩的要求和难度不断提升，传统的java web缺少创新和亮点，往往达不到毕业答辩的要求。
🔥 为了大家能够以最少的精力顺利通过毕业设计，学长推荐15个新颖优质 java毕业设计选题分享给大家，同时分享项目与论文(源码+论文)。
🔥 下文会对每个推荐的项目进行展示与打分，大家可以挑选自己喜欢的项目作为毕业设计。
项目分享：见文末！
2 选题汇总 基于SpringBoot的敬老院管理系统
基于Springboot的医院管理系统
基于SSM的宠物领养系统
基于SSM的学生信息管理系统
基于SpringBoot的养老院管理系统
基于SSM的电影购票系统
3 详细介绍 题目1 : 基于SpringBoot的敬老院管理系统 🥇 题目综合评分(每项满分5分)
难度系数：3分工作量：5分创新点：3分界面美化：5分 🥇 相关技术和工具 :
数据库：MySql服务器：apache-tomcat编译器：IntelliJ IDEA项目管理工具： maven 🥇 功能模块
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f07d0b4ea33a56144ae441743fdf1ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/520c4fe22eeafba9893e927afc26a02a/" rel="bookmark">
			Three.js——粒子效果、粒子水波、粒子组成立方体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人简介
👀个人主页： 前端杂货铺
⚡开源项目： rich-vue3 （基于 Vue3 + TS + Pinia + Element Plus + Spring全家桶 + MySQL）
🙋‍♂️学习方向： 主攻前端方向，正逐渐往全干发展
📃个人状态： 研发工程师，现效力于中国工业软件事业
🚀人生格言： 积跬步至千里，积小流成江海
🥇推荐学习：🍖开源 rich-vue3 🍍前端面试宝典 🍉Vue2 🍋Vue3 🍓Vue2/3项目实战 🥝Node.js实战 🍒Three.js
🌕个人推广：每篇文章最下方都有加入方式，旨在交流学习&amp;资源分享，快加入进来吧
内容参考链接WebGL专栏WebGL 入门Three.js（一）创建场景、渲染三维对象、添加灯光、添加阴影、添加雾化Three.js（二）scene场景、几何体位置旋转缩放、正射投影相机、透视投影相机Three.js（三）聚光灯、环境光、点光源、平行光、半球光Three.js（四）基础材质、深度材质、法向材质、面材质、朗伯材质、Phong材质、着色器材质、直线和虚线、联合材质Three.js（五）Three.js——二维平面、二维圆、自定义二维图形、立方体、球体、圆柱体、圆环、扭结、多面体、文字Three.js（六）Three.js——tween动画、光线投射拾取、加载.obj/.mtl外部文件、使用相机控制器Three.js（七）Three.js——骨骼动画Three.js（八）Three.js——基础纹理、凹凸纹理、法向贴图、环境贴图、canvas贴图 文章目录 前言一、粒子效果二、粒子水波三、粒子组成立方体总结 前言 大家好，这里是前端杂货铺。
上篇文章我们学习了 基础纹理、凹凸纹理、法向贴图、环境贴图、canvas贴图。接下来，我们继续我们 three.js 的学习！
在学习的过程中，如若需要深入了解或扩展某些知识，可以自行查阅 =&gt; three.js官方文档。
一、粒子效果 Sprite 精灵，是一个总是面朝着摄像机的平面，通常含有使用一个半透明的纹理。
new THREE.Sprite( material : Material ); 参数名称描述material（可选值）是 SpriteMaterial 的一个实例。 默认值是一个白色的 SpriteMaterial SpriteMaterial 点精灵材质，一种使用 Sprite 的材质。
new THREE.SpriteMaterial( parameters : Object ) 参数名称描述parameters(可选) 用于定义材质外观的对象，具有一个或多个属性。 材质的任何属性都可以从此处传入(包括从 Material 继承的任何属性)。 接下来，我们创建一个 10 x 10 的粒子效果，通过精灵和点精灵材质构建，添加到场景中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/520c4fe22eeafba9893e927afc26a02a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9204370ec47b7f03e9d8841bedce1d52/" rel="bookmark">
			【python】tkinter GUI编程经典用法，Label标签组件应用实战详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨✨ 欢迎大家来到景天科技苑✨✨
🎈🎈 养成好习惯，先赞后看哦~🎈🎈
🏆 作者简介：景天科技苑
🏆《头衔》：大厂架构师，华为云开发者社区专家博主，阿里云开发者社区专家博主，CSDN全栈领域优质创作者，掘金优秀博主，51CTO博客专家等。
🏆《博客》：Python全栈，前后端开发，小程序开发，人工智能，js逆向，App逆向，网络系统安全，数据分析，Django，fastapi，flask等框架，linux，shell脚本等实操经验，网站搭建，数据库等分享。
所属的专栏：python图形化GUI编程tkinter精讲
景天的主页：景天科技苑
文章目录 1.tkinter 主窗口测试 tkinter 主窗口位置和大小的设置 2.python GUI 编程整体描述3.tkinter常用组件汇总列表4.GUI 应用程序类的经典写法标准的面向对象 GUI 程序类的写法 5.Label 组件Label（标签）的用法实战 1.tkinter 主窗口 主窗口位置和大小
通过 geometry(‘wxh±x±y’)进行设置。w 为宽度，h 为高度。+x 表示距屏幕左边的距离；
-x 表示距屏幕右边的距离；+y 表示距屏幕上边的距离；-y 表示距屏幕下边的距离。单位是像素
前两个参数表示的是创建窗口的大小，而且一定要用x（小写的x表示），否则会报错：TclError: bad geometry specifier “400*300+100+100”，初学者一定要注意
测试 tkinter 主窗口位置和大小的设置 from tkinter import * root = Tk() #title设置窗口的主题 root.title("测试主窗口的位置和大小") #geometry(‘wxh±x±y’)进行设置窗口大小和位置 root.geometry("500x400+100+200") #宽度 500，高度 400；距屏幕左边 100，距屏幕上边 200 ,注意这里是小写的x，不能写*，否则会报错 root.mainloop() 运行显示
2.python GUI 编程整体描述 图形用户界面是由一个个组件组成，就像小孩“搭积木”一样最终组成了整个界面。有
的组件还能在里面再放置其他组件，我们称为“容器”。Tkinter 的 GUI 组件关系图如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9204370ec47b7f03e9d8841bedce1d52/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/291/">«</a>
	<span class="pagination__item pagination__item--current">292/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/293/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>