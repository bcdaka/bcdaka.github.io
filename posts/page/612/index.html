<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/483979ec055a48d7affbc6f768444fe1/" rel="bookmark">
			SQL Server2022版&#43;SSMS安装教程（保姆级）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL Server2022版+SSMS安装教程（保姆级） 一，安装SQL Server数据库 1.下载安装包 （1）百度网盘下载安装包 链接：https://pan.baidu.com/s/1A-WRVES4EGv8EVArGNF2QQ?pwd=6uvs
提取码：6uvs
（2）官网下载安装包 https://www.microsoft.com/en-us/sql-server/sql-server-downloads
进入官网后选择Developer选择安装
2.安装配置 打开下载好后的安装包！
选择自定义安装
选择安装位置（最好安装到除C盘以外的文件中）
等待安装…（1分钟左右）
待安装好后会自动弹出页面
选择安装全新的SQL Server
waiting一下下…
进入后
选择Developer版本（应该是默认不用管）
默认下一步就好
选择我接受许可条款
直接打上对勾
有警告⚠不用管，直接下一步
取消勾选适用于SQL Server的Azure
取消勾选
取消勾选
在实例功能中仅仅勾选如图所示内容：
不要勾选Analysis Services（勾选了其实也没事，因为本来就没有安装这个功能，在最后的时候可能会出现报错—提醒安装完成但未成功，其实也没啥事，就是勾选了这个功能但之前没有安装Analysis罢了）
如果你勾选Analysis Services，到安装最后会弹出来这个窗口，但没事的，这样也代表安装成功的
其中，这一步里有个实例目录，我建议在你下载SQL Server的文件夹中新建三个文件，然后放里面，因为默认的是C盘，你改到D盘或者其他盘就行
例如这样，新建三个依次放到里面就可以
然后就下一步了
选择默认实例就行（一般是默认，直接下一步）
默认选择，直接下一步
勾选对勾，下一步
选择Windows身份验证模式（W）
然后添加当前用户
稍等一下下就会自动弹出当前的计算机名称（如图中蓝条条所示），即可代表完成
下一步
这一步的话，有个配置文件，这个的路径该不了，直接写到C盘里了，但是文件不大，忽视即可
点击安装，waiting一小会
OK安装成功后，直接关闭即可
接下来，要按安装SQL Server自带的管理工具了
二，SSMS的安装—SQL Server Management Studio 在刚才的界面中，点击第三个SQL Sever管理工具
或者点击连接
https://learn.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-ver16
选择划线部分即可：
等待安装包下载完成即可：
or百度网盘下载地址：
链接：https://pan.baidu.com/s/1kLgpXZcCUDbvnlJTtQ0bVg?pwd=g13j
提取码：g13j
直接打开安装包即可：
更改一下位置更改到D盘，选择安装
waiting一会，没弹出安装成功的时候不要选择取消
如图
就代表安装成功
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/483979ec055a48d7affbc6f768444fe1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ca647a77833b6b297062d482a45187d/" rel="bookmark">
			考研408 王道计算机考研 (初试/复试) 网课笔记总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机初试、复试笔记总结（导航栏）📝 408 考研人，人狠话不多：3、2、1，上链接 ！
408 考研初试 - 备战期，专业课笔记，导航🚥🚥🚥
🥬 数据结构与算法；🥕 计算机网络；🥪 操作系统；🍊 计算机组成原理；
408 考研复试 - 决战期，复试速成笔记，导航🚥🚥🚥
🥬 数据结构与算法 考研复试速成 - 知识点精炼 (加班中)🥕 计算机网络 考研复试速成 - 知识点精炼🥪 操作系统 考研复试速成 - 知识点精炼🍊 计算机组成原理 考研复试速成 - 知识点精炼🍒 软件工程 考研复试速成 - 知识点精炼
录取通知，恭喜你顺利上岸！研究生你好！😀😀😀
研究生拟录取，打算暑假去实习挣钱 💴💴💴， Java八股文面试题，导航🚥🚥🚥
🥬 JavaSE 八股文 面试宝典🥕 MySQL 八股文 面试宝典🥪 Spring、MyBatis、SpringMVC 八股文 面试宝典🍊 SpringBoot框架 八股文 面试宝典未完待续 ... 如果本篇文章对大家起到帮助的话，跪求准研究生们，求赞👍 、求收藏、求关注！
你必考上研究生！我说的，耶稣来了也拦不住！
408 - 1. 数据结构与算法 数据结构与算法 笔记导航🚥🚥🚥
🥬 第一章 绪论(无)🥕 第二章 线性表🥪 第三章 栈和队列🍊 第四章 串-KMP(看毛片算法)🍒 第五章 树和二叉树🍀 第六章 图🍚 第七章 查找(B树、散列表)🧄 第八章 排序 (内部排序：八大排序动图演示与实现 + 外部排序)🎨数据结构与算法 复试精简笔记 (未完成) 408 - 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ca647a77833b6b297062d482a45187d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dff48ffdb647bbfa39f875d087e28eb/" rel="bookmark">
			zookeeper的环境搭建和配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		zookeeper的环境搭建和配置 1. zookeeper下载2. zookeeper的安装和配置2.1 解压上传的压缩包到指定的目录位置2.2 配置zookeeper的环境变量，以及zookeeper配置文件2.3 创建zkdata文件夹2.4将zookeeper及其配置文件转发复制到其他的节点中2.5对其他两台节点的myid（服务器id值进行配置）2.6 运行测试 1. zookeeper下载 zookeeper官网链接: https://zookeeper.apache.org/
进入到其官网后，选择download下载对应的zookeeper版本即可（我这里以3.8.1为例子）。
这里直接选择Http的对应链接下载即可
点击之后就下载完啦，很快的…
2. zookeeper的安装和配置 首先，将三台节点启动（node-01,node-02,node-03）,同时使用XShell远程登录到三台主机上面去，然后打开Xftp将刚刚下载的安装包进行传输。
2.1 解压上传的压缩包到指定的目录位置 首先切换到上传的目录/export/software中，然后使用tar 命令将其解压到具体的位置，（我这里是/export/servers/）。
cd /export/software/ #切换目录 tar -zxvf apache-zookeeper-3.8.1.tar.gz -C /export/servers/ #解压到/export/servers/ cd /export/servers/ #切换目录 ll # 查看当前目录信息 mv apache-zookeeper-3.8.1 zookeeper-3.8.1 # 重命名 ll # 查看当前目录信息 2.2 配置zookeeper的环境变量，以及zookeeper配置文件 配置环境变量，使用vi编辑器对/etc/profile配置文件进行修改(vi /etc/profile)，在其配置文件中，添加下面的语句：
export ZK_HOME=/export/servers/zookeeper-3.8.1 export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$ZK_HOME/bin 修改完环境变量后，使用source命令刷新配置
source /etc/profile 然后切换到zookeeper的安装目录中，找到conf文件夹，里面有zoo-sample.cfg 文件，它为zookeeper的配置文件，将其重命名为zoo.cfg，然后使用 vi 编辑器将配置进行修改。
cd /export/servers/zookeeper-3.8.1/conf #切换到zookeeper的conf目录中 mv zoo-sample.cfg zoo.cfg #重命名 vi zoo.cfg #使用vi编辑器进行修改 修改的内容如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dff48ffdb647bbfa39f875d087e28eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c44f3b5bcb0a59edf686863ee881dac/" rel="bookmark">
			Cookie和Session（会话技术）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Cookie和Session（会话技术）一、Cookie1、Cookie概述1.1、Cookie简介1.2、Cookie的使用场景1.3、Cookie底层原理 2、Cookie的基本使用3、Cookie实现显示用户上次访问时间4、Cookie编码与解码5、Cookie总结 二、Session1、Session概述1.1、Session简介1.2、Session的使用场景1.3、Session的底层原理 2、Session的基本使用3、Session的登录案例4、Session的购物案例5、Session总结 三、Session和Cookie的区别 Cookie和Session（会话技术） 一、Cookie 1、Cookie概述 1.1、Cookie简介 将会话过程中的数据保存到用户的浏览器中。服务端给客户端一个 信件，客户端下次访问服务端带上 信件 就可以了。客户端技术（响应，请求）用户打开一个浏览器，点击了很多超链接，访问多个web资源，关闭浏览器，这个过程可以称之为会话（Cookie）。一个Cookie只能保存一个信息。一个web站点可以给浏览器发送多个cookie，最多存放20个cookie。Cookie大小有限制4kb。300个cookie浏览器上限。一次会话中可以包含多次请求和响应。 1.2、Cookie的使用场景 常用来判断是否第一次登录，如果是你下次不用再登录了，第二次访问直接就上去了！ 1.3、Cookie底层原理 2、Cookie的基本使用 Cookie(name,value)：Cookie的构造方法，以键值对的形式存放addCookie(cookie)：添加CookiegetCookies()：获取请求发送时的Cookie对象的数组getName()：获取Cookie名称(键)getValue()：获取Cookie的值setMaxAge(int expiry)：设置Cookie的有效期，秒为单位，默认为-1永久存活(但是会在浏览器关闭时被删除)，0为删除 RegistServlet.java @WebServlet(name = "RegistServlet", value = "/registServlet") public class RegistServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setCharacterEncoding("utf-8"); response.setContentType("text/html;charset=UTF-8"); // 获取前端传来的参数 String username = request.getParameter("username"); String password = request.getParameter("password"); // 判断输入的账号和密码是否正确 if (username.equals("root") &amp;&amp; password.equals("111")){ // 创建Cookie对象，键值对形式存放 Cookie cookie1 = new Cookie("username", username); Cookie cookie2 = new Cookie("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c44f3b5bcb0a59edf686863ee881dac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ad0181e142843a8eca4b7ddc77b6206/" rel="bookmark">
			【Python】Pandas Groupby操作的25个示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pandas Groupby操作的25个示例 1. Groupby的基本原理2. agg聚合操作3. transform4. apply5. 25个代码示例1. 单列聚合2. 多列聚合3. 多方式聚合4. 对聚合结果进行命名5. 多个聚合和多个函数6. 不同列的聚合进行命名7. as_index参数8. 用于分组的多列9. 排序输出10. 最大的Top N11. 最小的Top N12. 第n个值13. 第n个值，倒排序14. 唯一值15. 唯一值的数量16. Lambda表达式17. apply函数18. dropna19. 求组的个数20. 获得一个特定分组21. rank函数22. 累计操作23. expanding函数24. 累积平均25. 展开后的最大值 参考资料 在日常的数据分析中，经常需要将数据根据某个（多个）字段划分为不同的群体（group）进行分析，如电商领域将全国的总销售额根据省份进行划分，分析各省销售额的变化情况，社交领域将用户根据画像（性别、年龄）进行细分，研究用户的使用情况和偏好等。在Pandas中，上述的数据处理操作主要运用groupby完成，本文就介绍一下 groupby的基本原理及对应的 agg、 transform和 apply等操作，总共包含25个代码示例。 首先，模拟生成10个样本数据：
import pandas as pd import numpy as np company=["A","B","C"] data=pd.DataFrame({ "company":[company[x] for x in np.random.randint(0,len(company),10)], "salary":np.random.randint(5,50,10), "age":np.random.randint(15,50,10) } ) 1. Groupby的基本原理 在pandas中，实现分组操作的代码很简单，仅需一行代码，在这里，将上面的数据集按照company字段进行划分：
这个生成的DataFrameGroupBy是啥呢？对data进行了groupby后发生了什么？ipython所返回的结果是其内存地址，并不利于直观地理解，为了看看group内部究竟是什么，这里把group转换成list的形式来看一看：
转换成列表的形式后，可以看到，列表由三个元组组成，每个元组中，第一个元素是组别（这里是按照company进行分组，所以最后分为了A,B,C），第二个元素的是对应组别下的DataFrame，整个过程可以图解如下：
总结来说，groupby的过程就是将原有的DataFrame按照groupby的字段（这里是company），划分为若干个分组DataFrame，被分为多少个组就有多少个分组DataFrame。所以说，在groupby之后的一系列操作（如agg、apply等），均是基于子DataFrame的操作。理解了这点，也就基本摸清了Pandas中groupby操作的主要原理。
2. agg聚合操作 聚合操作是groupby操作之后非常常见的操作。聚合操作可以用来求和、均值、最大值、最小值等，下面的表格列出了Pandas中常见的聚合操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ad0181e142843a8eca4b7ddc77b6206/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/046de0940bd95e45f59504c1a34c9d17/" rel="bookmark">
			〖大前端 - 基础入门三大核心之CSS篇⑱〗- CSS中的背景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：该文属于 大前端全栈架构白宝书专栏，目前阶段免费开放，购买任意白宝书体系化专栏可加入TFS-CLUB 私域社区。福利：除了通过订阅"白宝书系列专栏"加入社区获取所有付费专栏的内容之外，还可以通过加入星荐官共赢计划 加入私域社区。当前子专栏 基础入门三大核心篇 也是免费开放阶段。推荐他人订阅，可获取扣除平台费用后的35%收益。 作者：不渴望力量的哈士奇(哈哥)，十余年工作经验, 跨域学习者，从事过全栈研发、产品经理等工作，目前任某金融品类App负责人。荣誉：2022年度博客之星Top4、博客专家认证、全栈领域优质创作者、新星计划导师，“星荐官共赢计划” 发起人。现象级专栏《白宝书系列》作者，文章知识点浅显易懂且不失深度；TFS-CLUB社区创立者，旨在以“赋能 共赢”推动共建技术人成长共同体。 🏆 白宝书系列 🏅 Python全栈白宝书🏅 产品思维训练白宝书🏅 全域运营实战白宝书🏅 大前端全栈架构白宝书 文章目录 ⭐️ 背景基础知识🌟 背景颜色🌟 背景图片 ⭐️ 背景图片重复模式⭐️ 背景尺寸⭐️ 背景裁切⭐️ 背景起源⭐️ 背景固定⭐️ 背景图片位置 我们已经非常熟悉 “background-color” 属性了，知道它可以用来设置背景的颜色。实际工作中，肯定不仅仅给背景设置纯色，否则就太丑了。背景还可以设置背景图片，渐变色，多个颜色，还需要对背景进行裁切、位置调整等。下面我们就来详细的了解一下css中的背景。
⭐️ 背景基础知识 在学习 CSS 的背景知识之前，先来了解一下 "背景的基础知识" 吧。
🌟 背景颜色 backgroud-color用来设置背景颜色
背景颜色可以用十六进制、rgb()、rgba()表示法表示
padding区域是有背景颜色的
🌟 背景图片 "background-image属性" 用来设置背景图片：background-image: url();括号中填写图片的路径，可以是相对路径，也可以是http://开头的绝对路径。
注意：如果样式表是外链的，那么要书写从css出发到图片的路径，而不是从html出发。
如果图片比盒子小，图片会自动向横向和纵向平铺。
下面看个例子：
如果样式表是外链式的，url要书写从css出发到图片的路径：
⭐️ 背景图片重复模式 background-repeat用来设置背景的重复模式
值描述repeat;x、y均平铺（默认）repeat-x;x平铺repeat-y;y平铺no-repeat;不平铺 下面看些例子：
有些图片天生就可以无缝衔接的拼接，这些图片就非常适合做为背景图片，我们可以给整个网页设置背景图片：
⭐️ 背景尺寸 background-size属性用来设置背景图片的尺寸，可以兼容到IE9，是很常用的设置背景尺寸的属性。
background-size: 100px 200px;值代表背景图片的宽度、高度。
也可以设置成background-size: 20% 20%;表示为盒子的宽、高的百分之多少。
需要等比例设置的值，写auto
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/046de0940bd95e45f59504c1a34c9d17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dad7478f82ae88a1bd1afdf3083d2d0e/" rel="bookmark">
			adb操作提示Read-only file system问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android adb调试时，经常会遇到权限问题（failed for /system/lib/libmm-test.so, Read-only file system），即使Root设备，在向/system等系统文件夹操作时（比如push、rm等），依然可能会提示“Read-only file system”。
使用场景是:在替换手机的内置文件的时候,提示这个,按照以往的经验,
手机开发者模式打开,usb调试打开,或者重复的插拔几下数据线
执行
adb root
adb remount
‘adb remount’ 将 ‘/system’ 部分置于可写入的模式，默认情况下 ‘/system’ 部分是只读模式的。这个命令只适用于已被 root 的设备。
在将文件 push 到 ‘/system’ 文件夹之前，必须先输入命令 ‘adb remount’。
‘adb remount’ 的作用相当于 ‘adb shell mount -o rw,remount,rw /system’
作者：喵酱s
链接：https://www.jianshu.com/p/48507aaea8d1
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
就可以了
这次试了好多次,都不ok,最后找到了一种方案:
adb root //获取root权限 adb disable-verity //关闭分区检测功能 adb reboot //执行adb disable-verity后需要重启设备 adb root //设备重启后再次获取root权限 adb remount //使system分区为可读可写模式 这次如上操作再push文件的时候就成功push了,重点是加了这一句
adb disable-verity:关闭在调试环境下的dm-verity检查
adb命令权限的番外篇:
chmod 777
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dad7478f82ae88a1bd1afdf3083d2d0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e30826e52946d89baad5541188658eb/" rel="bookmark">
			CSS 之 background 系列属性详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、background总览 1、简介 background属性是所有背景属性的缩写，通常建议在代码中使用该缩写属性，而不是使用多条单独的背景属性，因为该缩写属性在老版本浏览器中支持性更好，而且书写简便。未写在缩写属性中的其他背景属性，则会采用默认值。
但我个人不提倡一味的使用缩写属性，因为当缩写的属性过多时，会导致这行代码过长，而且可读性也会变差，所以个人建议只在缩写属性中缩写4~6个属性，如果还需要用到其他属性则通过单独背景属性来定义。
2、系列属性 背景系列属性，共包含9种属性，除了background-blend-mode属性以外，其他8种属性全都支持通过background属性进行简写。
background-color：设置元素的背景颜色，默认值：transparent。background-image：设置元素的背景图像，默认值：none。background-size：设置元素背景图像的大小，默认值：auto。background-position：设置元素背景图像的位置，默认值：0% 0%。background-repeat：设置背景图像是否重复，以及如何重复，默认值：repeat。background-clip：设置元素背景的渲染区域，默认值：border-box。background-origin：设置元素背景的定位区域（背景区），默认值：border-box。background-attachment：设置元素的背景图像是否随页面滚动或固定，默认值：scroll。background-blend-mode（不支持简写）：设置元素背景层的混合模式，默认值：normal。 3、缩写规则 ① background-color、background-image、background-size、background-position、background-repeat、background-attachment这六条属性的属性值可以出现0次或1次，不出现时取其默认值。
② 所有属性可以任意设置顺序，但是background-size只能紧跟在background-position属性后面出现，两条属性之间通过/连接。
③ background-clip和background-origin拥有三条相同的属性值，这三条属性值可以出现0次、1次和2次，出现0次表示都取默认值；出现1次则表示同时设置 background-clip和background-origin的属性，两者一致；出现2次则表示第一个值为 background-origin的属性值，第二个值为 background-clip的属性值。
④ 如果通过background属性设置了多个背景层，那么每个背景层之间需要通过,进行分割，按顺序从前往后渲染，当前面背景层有未能覆盖的区域，将会被后面的背景层填充。但是 background-color属性只能在最后一个背景层中设置，因为一个元素的背景颜色是唯一的。
案例代码： /* 代码太长 可读性较差 */ /* 依次设置：bg-color bg-image bg-repeat bg-position/bg-size bg-origin bg-clip bg-attachment */ background: #ccc url(./image/img.png) no-repeat 0 0 / 100% 100% border-box border-box fixed; /* 长度适中 可读性较好 */ /* 依次设置：bg-color bg-image bg-repeat bg-position bg-attachment */ background: #ccc url(./image/img.png) no-repeat 0 0 fixed; background-size: 100% 100%; background-origin: padding-box; background-clip: border-box; 二、background-color（背景颜色） 该属性用来设置元素的背景颜色，每个元素的背景颜色是唯一的，其属性值分为以下四种：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e30826e52946d89baad5541188658eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae420adfbf4120629421f9c8c5de6b28/" rel="bookmark">
			React 入门（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言：一、React 简介1. 什么是 React2. React 的特点3. React 高效的原因4. React 官网5. React的主要原理6. Facebook为什么要建造React? 二、React 的基本使用1. 基础代码2. 效果3. 相关 js 库4. 创建虚拟DOM的两种方式5. 虚拟DOM与真实DOM6. 虚拟DOM与真实DOM的区别 三、React JSX1. 什么是 JSX2. 渲染虚拟DOM(元素)3. JSX 的使用4. JSX 的语法规则 四、模块与组件、模块化与组件化的理解1. 模块2. 组件3. 函数式组件4. 类式组件 总结： 前言： 本文会引导我们进入一段 React 学习之旅。我们将逐步了解有关它的背景和用例的一些细节，在自己的电脑上建起基本的 React 工具链，创建并使用一个简单的入门应用程序，以学习一些关于 React 在此过程中如何工作的知识。
一、React 简介 1. 什么是 React React 起源于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套，用来架设Instagram 的网站。做出来以后，发现这套东西很好用，就在2013年5月开源了。React 是一个用于构建用户界面的JavaScript 库。React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。React 是用于动态构建用户界面的 JavaScript 库(只关注于视图) 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae420adfbf4120629421f9c8c5de6b28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01c0d2f5051bfb4597438c3ece077b6e/" rel="bookmark">
			【深度学习模型】扩散模型(Diffusion Model)基本原理及代码讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 生成式建模的扩散思想实际上已经在2015年（Sohl-Dickstein等人）提出，然而，直到2019年斯坦福大学（Song等人）、2020年Google Brain（Ho等人）才改进了这个方法，从此引发了生成式模型的新潮流。目前，包括OpenAI的GLIDE和DALL-E 2，海德堡大学的Latent Diffusion和Google Brain的ImageGen，都基于diffusion模型，并可以得到高质量的生成效果。本文以下讲解主要基于DDPM，并适当地增加一些目前有效的改进内容。
基本原理 扩散模型包括两个步骤：
固定的（或预设的）前向扩散过程q：该过程会逐渐将高斯噪声添加到图像中，直到最终得到纯噪声。
可训练的反向去噪扩散过程：训练一个神经网络，从纯噪音开始逐渐去噪，直到得到一个真实图像。
前向与后向的步数由下标 t定义，并且有预先定义好的总步数 T（DDPM原文中为1000）。
t=0 时为从数据集中采样得到的一张真实图片， t=T 时近似为一张纯粹的噪声。
2.1 直观理解 为了看懂扩散模型查了很多资料，但是要么就是大量的数学公式，一行行公式推完了还是不知道它想干啥。要么就是高视角，上来就和能量模型，VAE放一块儿对比说共同点和不同点，看完还是云里雾里。然而事实上下面几句话就能把扩散模型说明白了 扩散模型的目的是什么？ 学习从纯噪声生成图片的方法 扩散模型是怎么做的？ 训练一个U-Net，接受一系列加了噪声的图片，学习预测所加的噪声 前向过程在干啥？ 逐步向真实图片添加噪声最终得到一个纯噪声 对于训练集中的每张图片，都能生成一系列的噪声程度不同的加噪图片 在训练时，这些 【不同程度的噪声图片 + 生成它们所用的噪声】 是实际的训练样本 反向过程在干啥？ 训练好模型后，采样、生成图片 2.2 数学形式 2.2.1 前向过程 是真实数据分布（也就是真实的大量图片），从这个分布中采样即可得到一张真实图片 。我们定义前向扩散过程为 ，即每一个step向图片添加噪声的过程，并定义好一系列，则有：
其中，N为正态分布，均值和方差分别为，因此通过采样标准正态分布，有：
2.2.2 反向过程 那么问题的核心就是如何得到的逆过程 ，这个过程无法直接求出来，所以我们使用神经网络去拟合这一分布。我们使用一个具有参数的神经网络去计算 。假设反向的条件概率分布也是高斯分布，且高斯分布实际上只有两个参数：均值和方差，那么神经网络需要计算的实际上是
在DDPM中，方差被固定，网络只学习均值。而之后的改进模型中，方差也可由网络学习得到。
2.2.3 总结过程 总之，我们定义这么一个过程：给一张图片逐步加噪声直到变成纯粹的噪声，然后对噪声进行去噪得到真实的图片。所谓的扩散模型就是让神经网络学习这个去除噪声的方法。 所谓的加噪声，就是基于稍微干净的图片计算一个（多维）高斯分布（每个像素点都有一个高斯分布，且均值就是这个像素点的值，方差是预先定义的 ），然后从这个多维分布中抽样一个数据出来，这个数据就是加噪之后的结果。显然，如果方差非常非常小，那么每个抽样得到的像素点就和原本的像素点的值非常接近，也就是加了一个非常非常小的噪声。如果方差比较大，那么抽样结果就会和原本的结果差距较大。 去噪声也是同理，我们基于稍微噪声的图片 计算一个条件分布，我们希望从这个分布中抽样得到的是相比于 更加接近真实图片的稍微干净的图片。我们假设这样的条件分布是存在的，并且也是个高斯分布，那么我们只需要知道均值和方差就可以了。问题是这个均值和方差是无法直接计算的，所以用神经网络去学习近似这样一个高斯分布。 2.3 网络训练流程 我们最终要训练的实际上是一个噪声预测器。神经网络输出的噪声是，而真实的噪声取自于正态分布。则损失函数为：
预测网络方面，DDPM采用了 U-Net。
从而，网络的训练流程为：
我们接受一个随机的样本；
我们随机从 1 到 T 采样一个 t；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01c0d2f5051bfb4597438c3ece077b6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30f15c821355ff9ae4bae09ceb44ffbf/" rel="bookmark">
			【排序算法】归并排序与快速排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥🔥 欢迎来到小林的博客！！
🛰️博客主页：✈️小林爱敲代码
🛰️博客专栏：✈️ 算法训练笔记
🛰️社区 :✈️ 进步学堂
🛰️欢迎关注：👍点赞🙌收藏✍️留言
前言 今天给大家分享两种排序，一种是快排，一种是归并。它们的时间复杂度都是 O(n * logn)，而归并要求的空间复杂度是O(N)。归并具有稳定性，快排不具备稳定性。
快速排序 快速排序我们需要借助一个key值，我们拿升序排序来举例。 我们在数组中随机取一个key值，随后用两个指针，一个指针从最左端开始。另一个指针从最右端开始，左指针先走，遇到比key大的值停下。随后右指针也相继往前走，遇到小于key的值停下。随后交换这两个值，走完一遍就完成了单趟排序，随后我们再把这段数组分割成两部分重复以上步骤。我们的key值就取数组的中间值。
随后我们再把数组从 key值所在的下标划分为两半，继续重复先前的步骤，最后即可完成排序。
快排代码模板：
#include&lt;iostream&gt; using namespace std; const int N = 1e6; int q[N]; int n; void sort_quick(int q[],int l , int r) { if(l &gt;= r) return; int i = l - 1, j = r + 1,x = q[(l+r)/2]; while(i &lt; j) { do i++;while(q[i] &lt; x); //找到的值&gt;= x do j--;while(q[j] &gt; x); //找到的值&lt;= x if(i&lt;j) swap(q[i],q[j]);//两个值进行交换 } sort_quick(q,l,j); // l - j这段区间继续排 sort_quick(q,j+1,r); // j + 1 - r这段区间继续排 } int main() { scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30f15c821355ff9ae4bae09ceb44ffbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18768bae1ac88f2a64bfae936dd7668b/" rel="bookmark">
			【数据结构】 | java中 哈希表及其冲突解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎗️ 博客新人，希望大家一起加油进步
🎗️ 乾坤未定，你我皆黑马
目录 1、哈希表概念2、冲突 - 概念3、冲突 - 避免 -哈希函数设计4、冲突 - 避免 -负载因子调节5、冲突 - 解决5.1 闭散列5.2 开散列 6、哈希表的模拟实现7、哈希表和 java 类集的关系 1、哈希表概念 顺序结构以及平衡树中，元素关键码与其存储位置之间没有对应的关系，因此在查找一个元素时，必须要经过关键码的多次比较。顺序查找时间复杂度为O(N)，平衡树中为树的高度，即O(LogN)， 搜索的效率取决于搜索过程中元素的比较次数。
理想的搜索方法：可以不经过任何比较，一次直接从表中得到要搜索的元素。 如果构造一种存储结构，通过某种函数(hashFunc)使元素的存储位置与它的关键码之间能够建立一一映射的关系，那么在查找时通过该函数可以很快找到该元素。
当向该结构中：
插入元素 根据待插入元素的关键码，以此函数计算出该元素的存储位置并按此位置进行存放
搜索元素 对元素的关键码进行同样的计算，把求得的函数值当做元素的存储位置，在结构中按此位置取元素比较，若关键码相等，则搜索成功
该方式即为哈希(散列)方法， 哈希方法中使用的转换函数称为哈希(散列)函数，构造出来的结构称为哈希表(HashTable)(或者称散列表)
例如：数据集合{1，7，6，4，5，9}；
哈希函数设置为：hash(key) = key % capacity; capacity为存储元素底层空间总的大小。
比如：
引出冲突： 用该方法进行搜索不必进行多次关键码的比较，因此搜索的速度比较快， 问题：按照上述哈希方式，向集合中插入元素44，会出现什么问题？
2、冲突 - 概念 对于两个数据元素的关键字不同，经过一个哈希函数之后，两者的存储位置下标可能是相同的，即：不同关键字通过相同哈希哈数计算出相同的哈希地址，该种现象称为哈希冲突或哈希碰撞。 把具有不同关键码而具有相同哈希地址的数据元素称为“同义词”
首先，我们需要明确一点，由于我们哈希表底层数组的容量往往是小于实际要存储的关键字的数量的，这就导致一个问题，冲突的发生是必然的，但我们能做的应该是尽量的降低冲突率。
3、冲突 - 避免 -哈希函数设计 引起哈希冲突的一个原因可能是：哈希函数设计不够合理。
哈希函数设计原则：
哈希函数的定义域必须包括需要存储的全部关键码，而如果散列表允许有m个地址时，其值域必须在0到m-1之间
哈希函数计算出来的地址能均匀分布在整个空间中
哈希函数应该比较简单
常见哈希函数
1. 直接定制法–(常用)
取关键字的某个线性函数为散列地址：Hash（Key）= A*Key + B ，优点：简单、均匀 缺点：需要事先知道关键字的分布情况，使用场景：适合查找比较小且连续的情况。
2. 除留余数法–(常用)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18768bae1ac88f2a64bfae936dd7668b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d256fe38a33570b45fee932ca998f3bf/" rel="bookmark">
			Python爬虫完整代码拿走不谢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于新手做Python爬虫来说是有点难处的，前期练习的时候可以直接套用模板，这样省时省力还很方便。
使用Python爬取某网站的相关数据，并保存到同目录下Excel。
直接上代码：
import re import urllib.error import urllib.request import xlwt from bs4 import BeautifulSoup def main(): baseurl ="http://jshk.com.cn" datelist = getDate(baseurl) savepath=".\\jshk.xls" saveDate(datelist,savepath) # askURL("http://jshk.com.cn/") findlink = re.compile(r'&lt;a href="(.*?)"&gt;') findimg = re.compile(r'&lt;img.*src="(.*?)"',re.S) findtitle = re.compile(r'&lt;span class="title"&gt;(.*)&lt;/span') findrating = re.compile(r'&lt;span class="rating_num" property="v:average"&gt;(.*)&lt;/span') findjudge = re.compile(r'&lt;span&gt;(\d*)人评价&lt;/span&gt;') findinq= re.compile(r'&lt;span class="inq"&gt;(.*)&lt;/span&gt;') def getDate(baseurl): datalist =[] for i in range(0,10): url=baseurl+str(i*25) html=askURL(url) soup = BeautifulSoup(html,"html.parser") for item in soup.find_all('div',class_="item"): data = [] item = str(item) link = re.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d256fe38a33570b45fee932ca998f3bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/530258c0aff8fd46b0bd1580b9ed1860/" rel="bookmark">
			【李沐】动手学深度学习 学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 【内容介绍】动手学深度学习-基于pytorch版本【脉络梳理】预备知识数据操作数据预处理线性代数矩阵计算自动求导 线性神经网络线性回归深度学习的基础优化算法线性回归的从零开始实现线性回归的简洁实现Softmax回归损失函数图像分类数据集Softmax回归的从零开始实现Softmax回归的简洁实现 多层感知机感知机多层感知机多层感知机的从零开始实现多层感知机的简洁实现模型选择过拟合和欠拟合权重衰退暂退法（Dropout）数值稳定性模型初始化和激活函数 深度学习计算层和块参数管理自定义层读写文件 卷积神经网络从全连接层到卷积图像卷积填充和步幅多输入多输出通道池化层（汇聚层）LeNet 现代卷积神经网络深度卷积神经网络（AlexNet）使用块的网络（VGG）网络中的网络（NiN）含并行连结的网络（GoogLeNet）批量规范化（归一化）残差网络（ResNet） 计算性能深度学习硬件(CPU和GPU)深度学习硬件(TPU和其他)单机多卡并行分布式训练 计算机视觉图像增广微调物体检测和数据集锚框物体检测算法：R-CNN，SSD，YOLO单发多框检测（SSD）YOLO语义分割转置卷积全连接卷积神经网络 FCN样式迁移 循环神经网络序列模型语言模型循环神经网络 现代循环神经网络门控循环单元GRU长短期记忆网络（LSTM）深度循环神经网络双向循环神经网络编码器-解码器序列到序列学习束搜索注意力机制注意力分数使用注意力机制的seq2seq自注意力Transformer 自然语言处理：预训练BERT预训练 自然语言处理：应用BERT微调 优化算法优化算法 【内容介绍】动手学深度学习-基于pytorch版本 你好！ 这是【李沐】动手学深度学习v2-基于pytorch版本的学习笔记
教材
源代码
安装教程（安装pytorch不要用pip，改成conda，pip太慢了，下载不下来）
个人推荐学习学习笔记
【脉络梳理】 预备知识 数据操作 本节代码文件在源代码文件的chapter_preliminaries/ndarray.ipynb中
创建数组
创建数组需要：
①形状
②每个元素的数据类型
③每个元素的值访问元素
①一个元素：[1,2]
②一行：[1,:]
③一列：[:,1]
④子区域：[1:3,1:] #第1到2行，第1到最后1列
⑤子区域：[::3,::2] #从第0行开始，每3行一跳，从第0列开始，每2列一跳。 数据预处理 本节代码文件在源代码文件的chapter_preliminaries/pandas.ipynb中
reshape函数
使用reshape函数后不指向同一块内存，但数据改变是同步的import torch a=torch.arange(12) b=a.reshape((3,4)) b[:]=2 # 改变b，a也会随之改变 print(a) # tensor([2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) a[:]=1 # 改变a，b也会随之改变 print(b) # tensor([[1, 1, 1, 1],[1, 1, 1, 1],[1, 1, 1, 1]]) print(id(b)==id(a)) # False # 但a、b内存不同 print(id(a)) # 2157597781424 print(id(b)) # 2157597781424 线性代数 本节代码文件在源代码文件的chapter_preliminaries/linear-algebra.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/530258c0aff8fd46b0bd1580b9ed1860/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/631cec76cde0c46406fd4fe66dc21a55/" rel="bookmark">
			C&#43;&#43; Lambda表达式的常见用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		⭐️我叫忆_恒心，一名喜欢书写博客的在读研究生👨‍🎓。
如果觉得本文能帮到您，麻烦点个赞👍呗！
近期会不断在专栏里进行更新讲解博客~~~ 有什么问题的小伙伴 欢迎留言提问欧，喜欢的小伙伴给个三连支持一下呗。👍⭐️❤️
前言 作为C++11的新特性的Lambada表达式本身书写倒不是什么难事，网上找一找也能轻易写出正确地表达式，但是在那些场景下使用以及应该如何使用反而会让很多新手困惑。
Lambda表达式 1 表达式定义 构造一个闭包：一个能够捕获作用域中变量的未命名函数对象。
在操作上，闭包是将函数与环境一起存储的记录。
2 书写规范 主要分成六个部分，其中1，2，3，5，6是需要重点掌握的。
capture 子句（在 C++ 规范中也称为 lambda 引入器。）参数列表自选。（也称为 lambda 声明符)可变规范自选。异常规范自选。尾随返回类型自选。λ体。 3 书写表达式 书写[] 用于捕获：
3.1 捕获的基本规则 [] - 不捕捉任何变量[&amp;] - 捕获外部作用域中所有变量，并作为引用在函数体内使用 (按引用捕
获)[=] - 捕获外部作用域中所有变量（依赖于编译器，只能捕获不被优化的变量），并作为副本在函数体内使用 (按值捕获)
注:拷贝的副本在匿名函数体内部为const类型.[=, &amp;foo] - 按值捕获外部作用域中所有变量，并按照引用捕获外部变量 foo[bar] - 按值捕获 bar 变量，同时不捕获其他变量[&amp;bar] - 按引用捕获 bar 变量，同时不捕获其他变量[this] - 捕获当前类中的 this 指针让 lambda 表达式拥有和当前类成员函数同样的访问权限
如果已经使用了 &amp; 或者 =, 默认添加此选项 3.2 使用的场景 用到函数指针的地方，应该考虑一下这个地方需不需要写Lambada表达式。
类中定义了只使用一次的方法，可以考虑是否需要用到Lambada表达式。
我只需要使用一次
类中进行调用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/631cec76cde0c46406fd4fe66dc21a55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eac4523ed23de5de7b11ccdf4af3eaf9/" rel="bookmark">
			教你彻底卸载MySQL 并重装（保姆级教程 ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：都是自己踩过的坑（其他博主也有，不过我的特殊，按步骤走完重新安装仍要输入原密码，本篇主要解决和我问题类似的情况），跟着以下步骤走就行。 步骤一：关闭MySQL服务 右击【计算机】，选择【管理】，打开“计算机管理”界面，确保关闭此服务。
步骤二：卸载mysql软件 打开【控制面板】，选择【程序和功能】，找到一切和Mysql相关的软件包括安装包!!!然后右键卸载掉（也可以采用第三方安全软件管家进行卸载，确保卸载干净即可！！！），一会安装的时候重新下载安装包就行。
步骤3：删除MySQL在电脑硬盘上物理位置上的所有文件 先勾选这个，因为这个文件名是隐藏的！！！！
找到这三个目标，打开找到Mysql目录直接全部删除，记得删完再次清空回收站。然后再次搜索看还有该目录没，确保删除干净！！！
关键！！！！删除C:\Documents and Settings\All Users\Application Data\MySQL下的文件夹，一定要删
如果有这个目录就删除，没有就算了，我的就没有，你可以直接访问这个路径试试
步骤四：清空注册表 windows+R运行“regedit”文件，打开注册表
删除注册表，注意这个mysql57是你之前命名的名字不一定就是Mysql，看自己的命名是啥，下面是mysql的目录注册表，确保每一个里面的都要删除掉！！！
HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Application\MySQL HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\Eventlog\Application\MySQL HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Eventlog\Application\MySQL HKEY_LOCAL_MACHINE\SYSTEM\CurrentControl001\Services\MYSQL HKEY_LOCAL_MACHINE\SYSTEM\CurrentControl002\Services\MYSQL HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\MYSQL 右键直接删除该文件，删除右边可能删不完（会有报错，目前没找到可行方法），所以直接删了该文件还是稳妥。
删完后再次搜索看还有该目录没，确保删除干净
步骤五：重新启动 最后一定要重启！！！然后不要先去装，确保删除干净按上述再次搜索一次C盘目录和注册表目录，要是还有就删除再次重启，确保没有再进行重新安装，我的就是重启了两次，最后才成功的。
步骤六：重新安装 最后大部分博主安装都是采用cmd安装，来回配置环境特别麻烦，其实可以直接按着操作步骤进行安装，简单明了易操作，不用那么麻烦，链接放下面了，亲测成功！！！
Windows下通过MySQL Installer安装MySQL服务_野马红尘的技术博客_51CTO博客
安装成功界面如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c2170d542c3eec3faee92fbcef2ce10/" rel="bookmark">
			Stm32-使用TB6612驱动电机及编码器测速
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 起因一、电机及编码器的参数二、硬件三、接线四、驱动电机1、TB6612电机驱动2、定时器的PWM模式驱动电机 五、编码器测速1、定时器的编码器接口模式2、定时器编码器模式测速的原理3、编码器模式的配置4、编码器模式相关代码5、测速方法 六、相关问题以及解答1、编码器模式下的自动重装值ARR和预分频PSC应该如何设置2、如何判断正反转3、圈数如何计算4、转速如何计算5、为什么我的编码器没有输出，获取到的脉冲数是0 七、测速硬件展示及测速现象八、总结九、大家可以参考参考链接1参考链接2参考链接3参考链接4 起因 最近在学习编码电机以及尝试使用编码电机测速。遇到了很多问题，花费了很多时间，在这里做一个记录，对自己学习到的知识进行一个总结
找了很多资料，看了很多视频，这些太多了，以至于让我不知道究竟哪一个是正确的，今天看这个，明天看这个，导致自己的学习效率低下
当然，有很多大佬的文章和资料给了我很大的启发
这个电机我玩了四天，把自己觉得重要的东西和大家分享一下
现在一般都是用编码器电机，参加比赛啥的，编码电机常用于测速，所以编码电机就成了一个必须学习的知识点
编码器被广泛应用于电机测速，实现电机闭环控制。
相关的知识点有：定时器的输出比较（输出PWM）、定时器的输入捕获，定时器的编码器接口、速度控制
一、电机及编码器的参数 编码电机其实就是一个带有编码器的电机，我的这个电机是一个增量式的带霍尔传感器的电机
电机的型号是JGB37-520电机
下方是电机的参数
主要关注的就是电机的额定电压 12V
电机的减速比 30（这个很重要）
编码器的参数
主要关注编码器的线数 11线 （也就是说电机转一圈会产生11个脉冲）
供电电压 5V
输出类型 方波
编码器的连接
一般这种编码器都有六根线
两边靠外的两根线是电机电源线
往里两根是编码器的电源线
中间两根是编码器的A,B相
具体大概是啥意思呢？
就是电机转动的时候编码器会通过编码电机的A相和B相输出两个正交的方波
通过输出的两个方波就可以对电机进行测速和识别电机的方向
二、硬件 整体结构采用洞洞板+TB6612+Stm32C8T6+编码电机(起初采用的是这种结构)
后面采用Stm32ZET6+TB6612+洞洞板+编码电机+12V电源(原因是C8T6烧坏了，哭😥)
主控Stm32C8T6 or Stm32ZET6
电机驱动 TB6612（由于上一个L298N烧了）
520霍尔编码电机
12V电源
三、接线 这里展示驱动一个编码电机的示例，毕竟先从一个电机玩起，弄懂后后面就会使用的更加得心应手啦
主要使用到了定时器的PWM模式（输出比较）功能
大家一定要认真接线，看清出每根线的作用，不要随便接线，一不小心电机驱动就烧了，或者是单片机烧了（在学习的时候就烧了一个单片机，人民币-15）
注意这个是我实现的接线，大家可以根据自己单片机的片上资源合理选择，选择合适的IO口
电机驱动
TB6612C8T6STBY高电平(+3.3V)AIN1PB14AIN2PB15PWMAPA8 （TIM1-CH1）AO1电机电源+AO2电机电源-VM12VVCC3.3VGND和单片机共地 编码器
编码器的A、B相C8T6A相PA0 (TIM2-CH1)B相PA1 (TIM2-CH2) 四、驱动电机 1、TB6612电机驱动 首先了解一下TB6612
下图是TB6612驱动模块
原理图
STBY接高电平 清零电机全部停止
置 1 通过 AIN1 AIN2， BIN1，BIN2 引脚来控制正反转
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c2170d542c3eec3faee92fbcef2ce10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/848327a4d4ce083af30dcb24d371fdd5/" rel="bookmark">
			微信小程序详细登录流程（图解&#43;代码流程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💂 个人网站: 【紫陌】【笔记分享网】 💅 想寻找共同学习交流、共同成长的伙伴， 请点击【前端学习交流群】 微信小程序的登录和web端的登录有一点是不同的，小程序需要和微信的服务通信验证。
1.小程序登录流程官网图 官网图地址
2.认识openid，unionid 和code openid
openid是用来唯一标识用户的一个字符串。在微信小程序中，每个用户的openid都是唯一的。通过openid，小程序可以获取用户的基本信息，如头像、昵称等。
注意：同一个用户在不同的小程序中拥有不同的openid。因此，在开发小程序时，不能使用openid来进行用户的唯一性判断。
unionid
unionid是在用户绑定同一微信开放平台账号下的多个应用时，用来唯一标识用户的一个字符串。如果用户在多个小程序中使用同一个微信号进行登录授权，那么这些小程序中的unionid都是相同的。
注意：用户的unionid只有在用户将多个应用绑定到同一个微信开放平台账号下时才会生成。因此，如果用户没有绑定多个应用，那么小程序将无法获取用户的unionid。
code
code是用户登录凭证，由微信服务器颁发给小程序。在用户授权登录后，小程序可以通过调用微信登录接口获取用户的code。然后，通过code向微信服务器请求用户的openid和session_key等信息。
注意：每个code只能使用一次，且有效期为5分钟。因此，在使用code进行登录时，需要及时将其转换成用户的openid和session_key等信息，以免出现code过期的情况
openid、unionid和code是微信小程序登录授权中非常重要的三个参数，了解这些参数的作用和用法，有助于开发者更好地设计和开发小程序登录授权功能。 3.文字版登录流程（面试会问这个，回答这个即可） 通过wx.login()获取code。
将这个code发送给后端，后端会返回一个token，这个token将作为你身份的唯一标识。
将token通过wx.setStorageSync()保存在本地存储。
用户下次进入⻚面时，会先通过wx.getStorageSync() 方法判断token是否有值，如果有值，则可以请求其它数据，如果没有值，则进行登录操作。
4.图形流程（前端流程和后端流程） 前端步骤：
后端步骤：
5. 代码实现登录流程 简单的实现登录流程。
2. 再进一步完善：把登录封装成一个函数，然后判读本地是否有token有就不用执行登录函数，否则执行登录函数。 onLoad() { //获取token, 判断token是否有值 const token = wx.getStorageSync('token') || '' //如果有值 if(token) { console.log('请求其他数据'); }else{ this.handlerLogin() } }, //登录的回调函数 handlerLogin(){ wx.login({ success: res =&gt; { //获取code const code = res.code console.log(res); //将code发给后端请求token wx.request({ url: 'http://xxxxxxx/login', data:{ code }, method:'post', success:(res) =&gt;{ const token = res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/848327a4d4ce083af30dcb24d371fdd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5f904de4a6876aef77d4c3330a9c193/" rel="bookmark">
			微信小程序实现图片上传（清晰版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在wxml文件中添加一个按钮和一个image标签用于显示上传的图片 &lt;view&gt; &lt;button bindtap="chooseImage"&gt;选择图片&lt;/button&gt; &lt;image src="{{imageUrl}}" /&gt; &lt;/view&gt; 在js文件中添加选择图片和上传图片的方法 Page({ data: { imageUrl: '' }, chooseImage() { wx.chooseImage({ count: 1, // 可选择的图片数量 sizeType: ['compressed'], // 压缩图片 sourceType: ['album', 'camera'], // 来源：相册或相机 success: (res)=&gt; { // 将选择的图片上传到服务器 this.uploadImage(res.tempFilePaths[0]); } }) }, uploadImage(imagePath) { wx.uploadFile({ url: '服务器地址', // 上传图片的接口地址 filePath: imagePath, // 图片文件路径 name: 'image', // 文件对应的 key , 开发者在服务器端通过这个 key 可以获取到文件二进制内容 success: (res) =&gt; { // 上传成功后，将服务器返回的图片地址更新到image标签中 this.setData({ imageUrl: res.data }); }, fail: function (res) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5f904de4a6876aef77d4c3330a9c193/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34cff008a3d2d4b48dcfff34811b46d8/" rel="bookmark">
			Python超市管理系统 毕业设计-附源码111042
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录
摘要 1
1 绪论 1
1.1研究背景 1
1.2研究现状 1
1.3系统开发技术的特色 1
1.4论文结构与章节安排 1
2 基于Python的 超市管理系统 系统分析 3
2.1 可行性分析 3
2.2 系统流程分析 3
2.2.1数据增加流程 3
2.3.2数据修改流程 4
2.3.3数据删除流程 4
2.3 系统功能分析 4
2.3.1 功能性分析 4
2.3.2 非功能性分析 5
2.4 系统用例分析 6
2.5本章小结 7
3 基于Python的 超市管理系统 总体设计 8
3.1 系统架构设计 8
3.2 系统功能模块设计 8
3.2.1整体功能模块设计 9
3.2.2用户模块设计 9
3.2.3评论管理模块设计 10
3.2.4商品信息管理模块设计 10
3.3 数据库设计 10
3.3.1 数据库概念结构设计 10
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34cff008a3d2d4b48dcfff34811b46d8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/611/">«</a>
	<span class="pagination__item pagination__item--current">612/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/613/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>