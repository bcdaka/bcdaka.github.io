<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41fa281ceea02449aef085e40143ce07/" rel="bookmark">
			mac只有键盘怎么连接蓝牙鼠标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 刚才遇到个问题，手头只有一个键盘和一个蓝牙鼠标，但是最新版本的系统对默认的纯键盘控制不太友好，得自己试出怎么连接，这里把如何在mac mini上用一个键盘连接上蓝牙鼠标，手上这台mini系统版本是14.0，有需要的朋友可以参考。
尝试了一个小时搞好了，手上的设备是：
mac mini m2k500键盘微软arc蓝牙鼠标 步骤：
快捷键Command+Option+F5（WIN键盘对应Win键+Alt键+F5）在弹出的窗口后，使用Tab键切换，切换至“全键盘控制”，然后按下空格键，再按下回车键确定。（如果Tab按快了跳过了就Shift+Tab返回上一个选项）按下Command+空格键（WIN键盘对应Win键+空格键），输入蓝牙，方向键选择“蓝牙 - 系统设置”这一项，回车确认选项就可以打开系统蓝牙设置。在窗口出来之后，按两下Tab按钮，焦点锁定至输入框，再次输入“蓝牙”，然后回车，这个时候就会焦点到不会乱跑焦点到蓝牙选项了，然后就是Tab Tab Tab Tab （具体看你要连接的设备上的“连接”按钮位置），然后空格键选定连接即可。参照步骤1和步骤2，关闭“全键盘控制”。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e112b5c71da952f02e58b82d617049ff/" rel="bookmark">
			阿里 P7 三面凉凉，kafka Borker 日志持久化没答上来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👏作者简介：大家好，我是爱敲代码的小黄，阿里巴巴淘天Java开发工程师，CSDN博客专家📕系列专栏：Spring源码、Netty源码、Kafka源码、JUC源码、dubbo源码系列🔥如果感觉博主的文章还不错的话，请👍三连支持👍一下博主哦🍂博主正在努力完成2023计划中：以梦为马，扬帆起航，2023追梦人📝联系方式：hls1793929520，加我进群，大家一起学习，一起进步，一起对抗互联网寒冬👀 文章目录 阿里 P7 三面凉凉，kafka Borker 日志持久化没答上来一、引言二、日志原理介绍二、日志源码1、授权校验2、消息添加2.1 获取 Partition2.2 向 Leader 追加日志2.2.1 是否创建 segment2.2.2 创建 segment2.2.2.1 文件路径校验2.2.2.2 segment 参数2.2.2.3 生成 segment 2.2.3 向 segment 添加日志2.2.3.1 稀疏索引2.2.3.2 偏移量索引2.2.3.3 时间戳索引2.2.3.4 索引总结 2.2.4 flush刷新 2.3 Follow 获取日志 三、流程图四、总结 Kafka从成神到成仙系列
【Kafka从成神到升仙系列 一】Kafka源码环境搭建【Kafka从成神到升仙系列 二】生产者如何将消息放入到内存缓冲区【Kafka从成神到升仙系列 三】你真的了解 Kafka 的元数据嘛【Kafka从成神到升仙系列 四】你真的了解 Kafka 的缓存池机制嘛【Kafka从成神到升仙系列 五】面试官问我 Kafka 生产者的网络架构，我直接开始从源码背起…【Kafka从成神到升仙系列 六】kafka 不能失去网络通信，就像西方不能失去耶路撒冷 阿里 P7 三面凉凉，kafka Borker 日志持久化没答上来 一、引言 前段时间有个朋友，去面了阿里集团的P7岗位，很遗憾的是三面没有过
其中有一个 kafka Borker 日志如何持久化的问题没有答上来
今天正好写一篇源码文章给朋友复盘一下
虽然现在是互联网寒冬，但乾坤未定，你我皆是黑马！
废话不多说，发车！
二、日志原理介绍 在讲 Kafka 日志源码之前，我们要先对 Kafka 日志有一个大体的认识
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e112b5c71da952f02e58b82d617049ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/849741e4b32a7352641f8966abac990f/" rel="bookmark">
			FAILED: HiveException java.lang.RuntimeException: Unable to instantiate org.apache.hadoop.hive.ql.me
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hive执行SQL报错 FAILED: HiveException java.lang.RuntimeException: Unable to instantiate org.apache.hadoop.hive.ql.me 原因： 元数据库连接失败导致。
解决方法： 查看元数据库MYSQL容器已经挂掉：
重新启动元数据库MYSQL容器
[root@flinkv3 ~]# docker start 25d1337fe092 再次启动元数据服务
[zhangflink@flinkv1 hive]$ nohup bin/hive --service metastore &gt; hiveMetastore.log 2&gt;&amp;1 &amp; 再次进入hive
[zhangflink@flinkv1 hive]$ bin/hive 执行成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/576fe3eeee6d03fd982a4162a399112a/" rel="bookmark">
			Android studio中文汉化教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相比于jetbrains的软件直接在软件内搜索chinese 就可以找到中文包相比，Android studio需要手动安装，接下来就给大家介绍下如何汉化
一、确认版本号 根据版本下载对应的中文汉化包，如果安装的汉化包版本不对应，可能会导致安装失败。
查看下相应的版本
二、下载汉化包 打开汉化包下载地址 ，根据刚才查看的版本号选择所对应的汉化包进行下载 三、安装汉化包
打开Settings 选择Plugins，在右侧面板选择 Install Plugin from Disk…
安装完成点击Restart IDE重启软件，重启后汉化完毕
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d96a4783f3d606b6613fb7b822552243/" rel="bookmark">
			Python tkinter 初探Toplevel控件搭建父子窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Toplevel控件搭建父子窗口
最简明的父子窗口框架
改进一：屏蔽和开放按钮
改进二：子窗口始终在主窗口之上
改进三：增加子窗口的关闭协议
改进四：使子窗口长获焦点
总结
Toplevel控件搭建父子窗口 最近，用Python给单位里用的“智慧食堂”系统编制了一个餐卡充值文件生成器，自动匹配餐卡号并快速生成导入数据用的Excel表格，截图如下：
使用tkinter Toplevel控件弹出子窗口，用作设置备注的子窗口。在编程过程中，边学边写探索到不少新知识，简单介绍如下：
最简明的父子窗口框架 创建一个主窗口、一个子窗口，各放一个按钮，代码如下：
import win32api, tkinter as tk def _toplevel(): top = tk.Toplevel(root) top.title("Toplevel Window") W,H=400,300 top.geometry(f'{W}x{H}+{(X-W)//2}+{(Y-H)//2}') btn_Close = tk.Button(top, text="Close", command=top.destroy) btn_Close.pack() if __name__=='__main__': # 创建主窗口 root = tk.Tk() root.title("Main Window") # 获取windows系统桌面分辨率 X,Y=win32api.GetSystemMetrics(0),win32api.GetSystemMetrics(1) W,H=600,480 root.geometry(f'{W}x{H}+{(X-W)//2}+{(Y-H)//2}') # 创建一个打开Toplevel窗口的按钮 btn_Open = tk.Button(root, text="Open Toplevel", command=_toplevel) btn_Open.pack() # 运行Tkinter事件循环 root.mainloop() 上述代码的缺点是主窗口上的Open按钮可以反复点击打开多个子窗口，要想办法按需要来屏蔽它的点击功能。
改进一：屏蔽和开放按钮 以下代码可以调整按钮的使用状态：tk.DISABLED、tk.NORMAL
button.config(state=tk.DISABLED)
button.config(state=tk.NORMAL)
打开子窗口时，Open按钮的状态改为tk.DISABLED，此时已无法点击了。
import win32api, tkinter as tk class TopWindow: def __init__(self, parent): top = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d96a4783f3d606b6613fb7b822552243/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41ceb3eb9398a47a52c02235d1a0c20a/" rel="bookmark">
			用Java编写简单的计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.思路与分析
2.程序代码及分析
3.总结
1.思路与分析 首先我们需要提供一个面板，一些按钮，一个文本框，它可以实现简单的加，减，乘，除，接着我们可以将这些想法付诸行动。
2.程序代码及分析 package ap1; import javax.swing.*; import java.awt.*; import java.awt.event.*; import javax.swing.JFrame; public class Calculator extends JFrame implements ActionListener{ JTextField textField; //定义一个文本框 //定义一些按钮 JButton buttonAdd, buttonSubtract, buttonMultiply, buttonDivide, buttonEquals,buttonPoint,buttonClear; JPanel panelMain; //定义一个面板 double num1, num2; char operator; public Calculator() { //设置窗口名字，大小 setTitle("简易计算器"); setSize(350, 350); textField = new JTextField(30); textField.setEditable(false); //添加按钮 buttonAdd = new JButton("+"); buttonSubtract = new JButton("-"); buttonMultiply = new JButton("*"); buttonDivide = new JButton("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41ceb3eb9398a47a52c02235d1a0c20a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/032768d257b88936fc82af56733e197d/" rel="bookmark">
			Python-pip国内常用镜像及使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用pip安装库时，下载软件包特别慢，是因为下载会默认请求python官网的镜像源。而官网的镜像部署在国外，网络条件不好时，会下载特别慢。为了解决这个痛点，我们可以把下载镜像源设置为国内的镜像源，直接从国内下载，比如清华镜像源、豆瓣镜像源等等。
1、国内常用镜像源 清华大学(推荐) https://pypi.tuna.tsinghua.edu.cn/simple 阿里云 http://mirrors.aliyun.com/pypi/simple 豆瓣 http://pypi.douban.com/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 华中理工大学 http://pypi.hustunique.com/ 山东理工大学 http://pypi.sdutlinux.org/ 网易 http://mirrors.163.com 2、临时使用方法 每次安装库的时候，安装命令中添加镜像即可。
pip install 库名 -i 镜像地址 比如使用清华源安装pygame库：
pip install pygame -i https://pypi.tuna.tsinghua.edu.cn/simple 3、永久设置方法 Windows中，进入 C:\Users\当前使用用户 文件夹创建pip文件夹 在新创建的pip文件夹中，创建文本文档，修改文件名及格式为 pip.ini 以记事本方式打开 pip.ini 文件，复制粘贴以下内容（清华源），并保存文件即可。 [global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple [install] trusted-host = pypi.tuna.tsinghua.edu.cn 可根据自己的实际需求，修改使用的镜像地址。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a05f4ec0aad30efddd49b2906daaa79b/" rel="bookmark">
			数据结构奇妙旅程之栈和队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		꒰˃͈꒵˂͈꒱ write in front ꒰˃͈꒵˂͈꒱
ʕ̯•͡˔•̯᷅ʔ大家好，我是xiaoxie.希望你看完之后,有不足之处请多多谅解，让我们一起共同进步૮₍❀ᴗ͈ . ᴗ͈ აxiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客
本文由xiaoxieʕ̯•͡˔•̯᷅ʔ 原创 CSDN 如需转载还请通知˶⍤⃝˶
个人主页：xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客
系列专栏：xiaoxie的JAVA系列专栏——CSDN博客●'ᴗ'σσணღ*
我的目标:"团团等我💪( ◡̀_◡́ ҂)" ( ⸝⸝⸝›ᴥ‹⸝⸝⸝ )欢迎各位→点赞👍 + 收藏⭐️ + 留言📝​+关注（互三必回）!
一.栈（Stack） 1.概念 栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端称为栈 顶，另一端称为栈底。栈中的数据元素遵守后进先出 LIFO （ Last In First Out ）的原则。 压栈：栈的插入操作叫做进栈 / 压栈 / 入栈， 入数据在栈顶 。 出栈：栈的删除操作叫做出栈。 出数据在栈顶 。 2.栈的模拟实现 可以看出栈Stack 是继承与Vector的， Vector和ArrayList类似，我们可以得到以下的栈的模拟实现，帮助我们更好的理解栈的使用。
//这是栈内存储Integer的模拟，当然栈是泛型，这里只是Integer的模拟 class MyStack { public int[] arr; public int size; public MyStack() { arr = new int[10]; } //入栈 public int push(int e) { ensureCapacity(); arr[size++] = e; return e; } //判断栈是否满 private void ensureCapacity() { if (size == arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a05f4ec0aad30efddd49b2906daaa79b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/623cd219af19b7cf58fbfb78d573df0d/" rel="bookmark">
			数据结构-迷宫问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、题目描述2、题目分析3、代码实现 1、题目描述 题目链接：迷宫问题
、
注意不能斜着走！
2、题目分析 （1）0为可以走，1不能走且只有唯一一条通路
（2）我们可以通过判断上下左右来确定路是否能通过，再设置如果走过的路就用 2 来标记，这样就不会走回头路了，如果有多条能通过，只选择一条路来走
（3）当我们遇到死胡同时，应该返回到上一个位置，再重新判断其他路是否可以走，没有就继续往回退，直到找到下一条路来，像这样的我们就要用到递归了。
（4）因为坐标是2个数据所以我们创建一个结构体来记录坐标。
（5）我们在一进到函数就先保存坐标，再找其他的路，如果没有找到就说明这是一条死胡同，我们就要往后退，再这个过程我们还需要将进来保存的坐标给拿出来，这种后进先出的的数据结构是栈，所以我们要借助栈来实现，不懂栈的可以看看哦：栈
（6）因为栈是先进后出的，所以这跟题目要求不符合，所以我们要再创建一个栈，将另一个栈的数据倒到新的栈里，再输出就符合题目要求了
（7）注意：输出的格式、在结尾还要释放栈和创建的数组、题目可能要求多组测试用例
3、代码实现 #include &lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;stdbool.h&gt; #include&lt;assert.h&gt; //定义结构体，标记坐标 typedef struct Postion { int row;//行 int col;//列 } PT; /// //栈 typedef PT STDataType;//结构体类型 typedef struct Stack { STDataType* a; int top;//元素个数 int capacity;//空间大小 } ST; void StackInit(ST* ps); void StackDestory(ST* ps); // 入栈 void StackPush(ST* ps, STDataType x); // 出栈 void StackPop(ST* ps); STDataType StackTop(ST* ps); int StackSize(ST* ps); bool StackEmpty(ST* ps); void StackInit(ST* ps) { assert(ps); ps-&gt;a = (STDataType*)malloc(sizeof(STDataType) * 4); if (ps-&gt;a == NULL) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/623cd219af19b7cf58fbfb78d573df0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b586afc53adbf7a3df84a82ed1da6cd4/" rel="bookmark">
			Python获取去哪儿旅游数据并作可视化攻略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嗨喽，大家好呀~这里是爱看美女的茜茜呐 开发环境： 版 本： python 3.8
编辑器：pycharm
第三方库： requests &gt;&gt;&gt; pip install requests
parsel &gt;&gt;&gt; pip install parsel
模块安装:
按住键盘 win + r, 输入cmd回车 打开命令行窗口, 在里面输入 pip install 模块名
👇 👇 👇 更多精彩机密、教程，尽在下方，赶紧点击了解吧~ python源码、视频教程、插件安装教程、资料我都准备好了，直接在文末名片自取就可
需求分析 确定需要的数据
找数据真实来源
https://travel.qunar.com/travelbook/list.htm?order=hot_heat
静态数据
代码实现步骤 发送请求
获取数据
提取数据
保存数据
数据获取 导入模块
import requests # 发送请求 代码当中用来访问网站的模块 import parsel # 解析数据的模块 import csv with open('攻略.csv', mode='a', encoding='utf-8', newline='') as f: csv_writer = csv.writer(f) csv_writer.writerow(['title', 'date', 'days', 'photo_nums', 'fee', 'people', 'trip', 'view', 'love', 'comment', 'href']) for page in range(1, 201): url = f'https://travel.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b586afc53adbf7a3df84a82ed1da6cd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dba2725394c1d6399383211252e6a2c/" rel="bookmark">
			后端Windows软件环境安装配置大全[JDK、Redis、RedisDesktopManager、Mysql、navicat、VMWare、finalshell、MongoDB...持续更新中]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 发现宝藏前言1. 安装 JDK2. 安装 Redis3. 安装 RedisDesktopManager（Redis可视化工具）4. 安装 Mysql5. 安装 navicat (Mysql可视化工具)6. 安装 VMWare7. 安装 finalshell (VMWare可视化工具)8. 安装 MongodDB9. 安装 maven 总结 发现宝藏 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。【宝藏入口】。
前言 为了巩固所学的知识，作者尝试着开始发布一些学习笔记类的博客，方便日后回顾。当然，如果能帮到一些萌新进行新技术的学习那也是极好的。作者菜菜一枚，文章中如果有记录错误，欢迎读者朋友们批评指正。
（博客的参考源码可以在我主页的资源里找到，如果在学习的过程中有什么疑问欢迎大家在评论区向我提出）
1. 安装 JDK 1. 下载JDK
打开Oracle官方网站的Java下载页https://www.oracle.com/java/technologies/downloads/选择您需要的JDK版本。如果您是Java的新手，建议下载最新版本的JDK，点击“下载”按钮，接受许可协议，并选择适合您操作系统的JDK版本进行下载 2. 安装JDK
打开下载的JDK安装程序（例如，Windows系统中的EXE文件）。点击“安装”按钮，接受许可协议，并选择安装目录。点击“关闭”按钮，JDK安装完成。 3. 设置环境变量
安装JDK后，需要设置JAVA_HOME和PATH环境变量，以便在命令行或脚本中使用Java
打开控制面板，选择“系统和安全”（或“系统”），然后选择“系统” 点击“高级系统设置”链接，打开“系统属性”对话框 点击“环境变量”按钮，打开“环境变量”对话框 在“系统变量”部分，点击“新建”按钮，输入“JAVA_HOME”作为变量名，输入刚才JDK安装路径的绝对路径作为变量值（例如C:\Program Files\Java\jdk1.8.0_291） 编辑PATH变量，将刚刚新建的JAVA_HOME变量加上bin目录设置到PATH中 %JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;
点击“确定”按钮，保存并关闭所有对话框。 4. 验证安装
在命令行或终端中(Win + R)输入以下命令，验证JDK是否已经成功安装：java -version如果您看到JDK的版本信息，则表示JDK已经成功安装 2. 安装 Redis 1. 解压安装包
Redis的windows版属于绿色软件，直接解压即可使用，解压后目录结构如下
2. 双击 redis-server.exe，启动redis
3. 安装 RedisDesktopManager（Redis可视化工具） 1. 官网下安装包：https://redisdesktop.com/download
2. 点击安装包，一直点击下一步傻瓜式安装
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dba2725394c1d6399383211252e6a2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a1ec95e689077c6cc8e50104e363ed7/" rel="bookmark">
			Nacos与Eureka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Nacos与Eureka微服务Eureka注册中心使用原理：操作步骤 负载均衡负载均衡原理源码跟踪 Nacos注册中心操作步骤1）引入依赖2）配置nacos地址 权重配置环境隔离统一配置管理配置热更新1.方式一2.方式二 配置共享优先级 Nacos与Eureka的区别 Nacos与Eureka 分布式架构的优缺点：
优点：
降低服务耦合有利于服务升级和拓展 缺点：
服务调用关系错综复杂 微服务 微服务的架构特征：
单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责自治：团队独立、技术独立、数据独立，独立部署和交付面向服务：服务提供统一标准的接口，与语言和技术无关隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题 SpringCloud是目前国内使用最广泛的微服务框架。SpringCloud底层是依赖于SpringBoot，并且有版本的兼容关系。
我们课堂学习的版本是 Hoxton.SR10，因此对应的SpringBoot版本是2.3.x版本。
Eureka注册中心 使用原理： 1、Eureka 作为一个服务注册中心启动。
2、Provider 和 Consumer 分别作为服务启动，并且注册到 Eureka 上面去，以 provider 为例，3、provider 注册时会告诉 eureka，我叫 provider，我的地址是 xx.xx.xx.xx，我的端口是 xx，我的 xx 是 xx，就是说，provider 会将自己的一些元数据信息告诉 eureka；同理，consumer 也是如此。
接下来，consumer 要调用 provider 的接口，但是它不知道 provider 的地址是什么，他只知道要调用的服务叫 provider，于是 consumer 找到 eureka，从 eureka 上查询出来 provider 的具体地址和端口，这个具体的地址和端口，可能是一个，也可能是多个(集群化部署)。
consumer 获取到 provider 的地址和端口之后，接下来就直接去调用 provider 了。
从上面一个流程图中，大家可以看出来，一旦 consumer 获取到 provider 的具体地址，接下来的调用其实就没有 eureka 什么事了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a1ec95e689077c6cc8e50104e363ed7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb68011f6a4a051c5a561e7d1289b98b/" rel="bookmark">
			基于LSTM模型的时间序列预测（车厢重量预测），Python中Keras库实现LSTM，实现预测未来未知数据,包括参数详解、模型搭建，预测数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 LSTM是一种常用的循环神经网络，其全称为“长短期记忆网络”（Long Short-Term Memory Network）。相较于传统的循环神经网络，LSTM具有更好的长期记忆能力和更强的时间序列建模能力，因此在各种自然语言处理、语音识别、时间序列预测等任务中广泛应用。
问题 场景：对一节火车进行装载货物，火车轨道上有仪表称，我们希望利用LSTM模型对装车数据进行训练、预测，已经收集到12小时内的仪表重量的时序数据，通过训练模型从而预测未来时间段内的仪表数据，方便进行装车重量调控。
思路 首先训练模型预测未来时间段内数据的能力，训练完后，我们使用收集的数据预测第13h的数据，预测后，我们将13h的数据看做真实数据，放入历史数据中，再用它预测第14h的数据，依次类推，最终预测完未来的数据。
代码 导入模块 import math import torch import keras import numpy as np import pandas as pd import matplotlib.pyplot as plt from pandas import read_csv,Series from keras.models import Sequential from keras.layers import LSTM,Dense,Dropout,Activation from sklearn.preprocessing import MinMaxScaler from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error 读入数据 # 定义随机种子，以便重现结果 np.random.seed(7) # 加载数据 dataframe = read_csv('装车训练数据.csv',encoding='gbk',usecols=[0],engine='python') print(dataframe) data = dataframe.values data = data.astype('float32') dataframe = read_csv('文件名',usecols=[0],encoding='gbk', engine='python')、
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb68011f6a4a051c5a561e7d1289b98b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e657125f8ebae4af8073c117ad42de0a/" rel="bookmark">
			【Python】json.dumps()函数详解和示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		json.dumps() 是 Python 中 json 模块的一个函数，用于将 Python 对象编码为 JSON 格式的字符串。这个函数非常有用，当你需要将 Python 对象保存为 JSON 文件，或者通过网络传输到另一个系统时，它可以很方便地将 Python 数据结构转换为 JSON 格式。
import json # 创建一个 Python 字典 my_dict = {'name': 'Alice', 'age': 30, 'city': 'New York'} # 使用 json.dumps() 将字典转换为 JSON 格式的字符串 json_string = json.dumps(my_dict) print(json_string) 输出：
{"name": "Alice", "age": 30, "city": "New York"} json.dumps()` 函数还有一些其他参数，例如： indent：用于设置输出的 JSON 字符串的缩进层次，使其更易读。 sort_keys：用于设置是否要对字典的键进行排序。 ensure_ascii：用于设置是否仅使用 ASCII 字符。 escape_forward_slashes：用于设置是否要转义正斜杠 /。 import json # 创建一个 Python 字典 my_dict = {'name': 'Alice', 'age': 30, 'city': 'New York'} # 使用 json.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e657125f8ebae4af8073c117ad42de0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d462eee16a089703ff6c195701f2af3/" rel="bookmark">
			【Oracle】创建表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
方法一：CREATE TABLE 语法
创建表示例1：创建stuinfo(学生信息表)
创建表示例2：添加stuinfo(学生信息表)约束
方法二：CREATE TABLE AS 语法
创建表示例3：
创建表示例4：实现对select查询的结果进行快速备份
创建表示例5：复制另一个表的选定列
创建表示例6：从多个表复制选定的列
方法一：CREATE TABLE 语法 CREATE TABLE schema_name.table_name ( column_1 data_type column_constraint, column_2 data_type column_constraint, ... table_constraint ); 首先，在CREATE TABLE子句中，指定新表所属的表名和模式名称。
其次，在圆括号内列出所有列。如果一个表有多个列，则需要用逗号分隔每个列的定义。列定义包括列名，后跟它的数据类型，例如NUMBER，VARCHAR2和列约束，如NOT NULL，主键，约束检查等。
注意：请注意用户权限问题，必须具有CREATE TABLE系统特权才能在模式中创建新表，并使用CREATE ANY TABLE系统特权在其他用户的模式中创建新表。除此之外，新表的所有者必须具有包含新表或UNLIMITED TABLESPACE系统特权的表空间的配额。
在我们之前创建的JT_CS用户下创建表，一定要有CREATE TABLE权限，不然无法创建数据表。
创建表示例1：创建stuinfo(学生信息表) --实例建表stuinfo create table JT_CS.stuinfo ( stuid varchar2(11) not null,--学号：'S'+班号(7位数)+学生序号(3位数)(不能为空)SC200101001 stuname varchar2(50) not null,--学生姓名(不能为空) sex char(1) not null,--性别(不能为空)1(男)、2(女) age number(2) not null,--年龄(不能为空) classno varchar2(7) not null,--班号：'C'+年级(4位数)+班级序号(2位数)(不能为空)C200101 stuaddress varchar2(100) default '地址未录入',--地址 (不填或为空时默认填入‘地址未录入‘) grade char(4) not null,--年级(不能为空) enroldate date,--入学时间 idnumber varchar2(18) default '身份证未采集' not null--身份证(不能为空) ) -- Add comments to the table --comment on table 是给表名进行注释 comment on table JT_CS.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d462eee16a089703ff6c195701f2af3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e471d964256b83659973c14ddbe00eba/" rel="bookmark">
			人工智能与大数据：未来的合作与挑战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景介绍 人工智能(Artificial Intelligence，AI)和大数据(Big Data)是当今最热门的技术话题之一。它们在各个领域的应用已经取得了显著的成果，并且在未来的发展趋势中也具有巨大的潜力。本文将探讨人工智能与大数据之间的关系，以及它们如何相互影响、协同工作，以及未来可能面临的挑战。
1.1 人工智能简介 人工智能是一门研究如何让计算机模拟人类智能的学科。人工智能的目标是让计算机能够理解自然语言、学习、推理、解决问题、感知环境、自主决策等。人工智能可以分为两个主要领域：
人工智能的基础理论研究：研究计算机如何模拟人类思维，如知识表示、推理、学习等。人工智能的应用研究：研究如何将人工智能技术应用于实际问题，如机器学习、深度学习、自然语言处理、计算机视觉等。 1.2 大数据简介 大数据是一种指数级增长的数据集，其规模、速度和复杂性超过传统的数据处理技术能够处理的范围。大数据可以分为以下几个方面：
数据规模：大数据的规模可以是数以亿的数据记录，需要使用分布式计算技术来处理。数据速度：大数据的生成速度非常快，需要使用实时数据处理技术来应对。数据复杂性：大数据可能包含结构化、半结构化和非结构化的数据，需要使用多种数据处理技术来解决。 1.3 人工智能与大数据的关系 人工智能与大数据之间的关系可以从以下几个方面来看：
数据驱动：人工智能的发展依赖于大量的数据，因此人工智能与大数据之间存在紧密的联系。算法与模型：人工智能和大数据的研究需要开发各种算法和模型来处理和分析数据。应用场景：人工智能和大数据的应用场景相互补充，可以在各种领域提供更好的服务和解决方案。 1.4 人工智能与大数据的合作与挑战 人工智能与大数据的合作可以提高计算机的智能水平，以及提高数据处理的效率和准确性。但是，这种合作也面临着一些挑战，如数据安全、数据质量、算法解释性等。
2. 核心概念与联系 在本节中，我们将详细介绍人工智能和大数据的核心概念，以及它们之间的联系。
2.1 人工智能的核心概念 人工智能的核心概念包括：
知识表示：知识表示是指如何将人类的知识表示为计算机可以理解的形式。知识表示可以是规则、框架、语义网络等形式。推理：推理是指如何根据已有的知识得出新的结论。推理可以是推理规则、逻辑推理、推理算法等形式。学习：学习是指如何让计算机从数据中自动学习知识。学习可以是监督学习、无监督学习、强化学习等形式。感知：感知是指如何让计算机从环境中获取信息。感知可以是视觉感知、语音感知、传感器感知等形式。决策：决策是指如何让计算机根据已有的知识和信息进行自主决策。决策可以是规则决策、模型决策、深度决策等形式。 2.2 大数据的核心概念 大数据的核心概念包括：
数据存储：数据存储是指如何将大量数据存储在计算机中。数据存储可以是关系型数据库、非关系型数据库、分布式文件系统等形式。数据处理：数据处理是指如何对大量数据进行处理和分析。数据处理可以是批处理、实时处理、交互式处理等形式。数据清洗：数据清洗是指如何对大量数据进行清洗和预处理。数据清洗可以是数据去重、数据填充、数据转换等形式。数据挖掘：数据挖掘是指如何从大量数据中发现隐藏的知识和模式。数据挖掘可以是关联规则挖掘、聚类挖掘、异常挖掘等形式。数据可视化：数据可视化是指如何将大量数据以图形的形式展示给用户。数据可视化可以是条形图、饼图、地图等形式。 2.3 人工智能与大数据的联系 人工智能与大数据之间的联系可以从以下几个方面来看：
数据驱动：人工智能需要大量的数据来训练和验证模型。因此，人工智能与大数据之间存在紧密的数据驱动关系。算法与模型：人工智能和大数据的研究需要开发各种算法和模型来处理和分析数据。这些算法和模型可以是机器学习算法、深度学习模型、自然语言处理算法等形式。应用场景：人工智能和大数据的应用场景相互补充，可以在各种领域提供更好的服务和解决方案。这些应用场景可以是智能推荐、自动驾驶、语音助手等形式。 3. 核心算法原理和具体操作步骤以及数学模型公式详细讲解 在本节中，我们将详细介绍人工智能和大数据的核心算法原理，以及它们之间的具体操作步骤和数学模型公式。
3.1 人工智能的核心算法原理 人工智能的核心算法原理包括：
知识表示：知识表示可以使用规则、框架、语义网络等形式来表示。例如，规则可以使用IF-THEN形式来表示条件和结果，框架可以使用模板来表示结构，语义网络可以使用RDF格式来表示关系。推理：推理可以使用推理规则、逻辑推理、推理算法等形式来实现。例如，推理规则可以使用模式匹配和变量绑定来得出结论，逻辑推理可以使用先验知识和观测数据来推导结论，推理算法可以使用搜索、回溯和剪枝等技术来优化推理过程。学习：学习可以使用监督学习、无监督学习、强化学习等形式来实现。例如，监督学习可以使用梯度下降和随机梯度下降等方法来优化模型，无监督学习可以使用聚类和主成分分析等方法来发现结构，强化学习可以使用Q-学习和深度Q-学习等方法来学习策略。感知：感知可以使用视觉感知、语音感知、传感器感知等形式来实现。例如，视觉感知可以使用图像处理和深度学习等方法来提取特征，语音感知可以使用自然语言处理和语音识别等方法来理解语音，传感器感知可以使用数据融合和数据预处理等方法来获取信息。决策：决策可以使用规则决策、模型决策、深度决策等形式来实现。例如，规则决策可以使用IF-THEN规则来进行判断，模型决策可以使用机器学习模型来预测结果，深度决策可以使用神经网络和递归神经网络等方法来学习策略。 3.2 大数据的核心算法原理 大数据的核心算法原理包括：
数据存储：数据存储可以使用关系型数据库、非关系型数据库、分布式文件系统等形式来实现。例如，关系型数据库可以使用SQL语句来查询和更新数据，非关系型数据库可以使用键值存储和文档存储等方法来存储数据，分布式文件系统可以使用Hadoop和HDFS等技术来存储大量数据。数据处理：数据处理可以使用批处理、实时处理、交互式处理等形式来实现。例如，批处理可以使用MapReduce和Spark等技术来处理大量数据，实时处理可以使用Kafka和Flink等技术来处理流式数据，交互式处理可以使用Pandas和Dask等技术来处理小量数据。数据清洗：数据清洗可以使用数据去重、数据填充、数据转换等形式来实现。例如，数据去重可以使用Hash和排序等方法来移除重复数据，数据填充可以使用插值和插值法等方法来补全缺失数据，数据转换可以使用JSON和XML等格式来转换数据结构。数据挖掘：数据挖掘可以使用关联规则挖掘、聚类挖掘、异常挖掘等形式来实现。例如，关联规则挖掘可以使用Apriori和Eclat等算法来发现关联规则，聚类挖掘可以使用K-均值和DBSCAN等算法来发现聚类，异常挖掘可以使用Isolation Forest和LOF等算法来发现异常数据。数据可视化：数据可视化可以使用条形图、饼图、地图等形式来实现。例如，条形图可以使用Matplotlib和Seaborn等库来绘制，饼图可以使用PieChart和Plotly等库来绘制，地图可以使用Leaflet和Mapbox等库来绘制。 3.3 人工智能与大数据的具体操作步骤 人工智能与大数据的具体操作步骤可以从以下几个方面来看：
数据收集：首先需要收集大量的数据，这些数据可以是结构化、半结构化和非结构化的数据。数据预处理：对收集到的数据进行清洗和预处理，以便于后续的分析和处理。算法选择：根据具体的问题需求，选择合适的算法和模型来处理和分析数据。模型训练：使用选定的算法和模型对数据进行训练，以便于后续的预测和推理。模型评估：对训练好的模型进行评估，以便于确定模型的性能和准确性。模型部署：将训练好的模型部署到实际应用场景中，以便于提供服务和解决问题。 3.4 人工智能与大数据的数学模型公式 人工智能与大数据的数学模型公式可以从以下几个方面来看：
推理：推理可以使用逻辑推理的数学模型来表示，例如： $$ \frac{\text{P(A|B)}}{\text{P(A|¬B)}} = \frac{\text{P(B|A)}}{\text{P(B|¬A)}} $$学习：学习可以使用梯度下降的数学模型来优化，例如： $$ \theta{t+1} = \thetat - \alpha \nabla J(\theta_t) $$感知：感知可以使用卷积神经网络的数学模型来表示，例如： $$ y = \text{ReLU}(W \times x + b) $$决策：决策可以使用策略梯度的数学模型来优化，例如： $$ \nabla J(\theta) = \mathbb{E}{\pi\theta}[\nabla \log \pi\theta(a|s) Q^{\pi\theta}(s,a)] $$数据处理：数据处理可以使用MapReduce的数学模型来表示，例如： $$ \text{Map}(x) \rightarrow (k, v) \ \text{Reduce}(k, (v1, v2, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e471d964256b83659973c14ddbe00eba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/705493a87bd01d180bd552d55a794cf9/" rel="bookmark">
			Video-LLaMA An Instruction-tuned Audio-Visual Language Model for Video Understanding 用于视频理解的指令调谐视听语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.摘要 我们提出了一个多模态框架Video-LLaMA1，它使大型语言模型(LLM)能够理解视频中的视觉和听觉内容。视频-来自冻结的预训练视频和音频编码器和冻结的LLM的美洲驼引导跨模式训练。不像以前的工作，补充线性最小二乘法只处理视觉或听觉信号(朱等，2023；刘等，2023；Huang et al .，2023a)，Video-LLaMA通过解决两个挑战来实现视频理解:(1)捕捉视觉场景的时间变化，(2)整合视听信号。为了应对第一个挑战，我们提出了一个视频Q-former来将预训练的图像编码器组装到我们的视频编码器中，并引入视频到文本生成任务来学习视频语言的对应性。对于第二个挑战，我们利用ImageBind (Girdhar等人，2023年)，一种对齐多种模态的通用嵌入模型，作为预训练的音频编码器，并在ImageBind之上引入音频Q-former，以学习LLM模块的合理听觉查询嵌入。为了将视频和音频编码器的输出与LLM的嵌入空间对齐，我们首先在大量视频/图像-字幕对上训练视频LLaMA，然后用中等数量但更高质量的视觉指令数据集调整我们的模型。我们发现视频——美洲驼表现出感知和理解视频内容的能力，并根据视频中呈现的视觉和听觉信息产生有意义的反应。
Video-LLaMA1: 大语言模型理解视频内容（视觉+听觉内容）
目标：解决视频理解的两个挑战。
（1）捕捉视觉场景时间变化：
引入视频Q-former：学习视觉语言的对应性。
（2）整合试听信号：
引入音频Q-former：学习合理的试听听觉查询嵌入。【？怎么学的呢？】
视频Q-former的学习：
与训练图像编码器组装到视频编码器。
视频-&gt;文本生成 任务，学习视频和文本对应性。
将视频和音频编码器的输出与LLM的嵌入空间对齐:
视频|图像-字幕训练LLaMA。
中等数量，高质量视觉指令集调整模型。 2.研究意义及价值 对于许多应用场景来说，只有文本的人机交互是不够的，因为真实世界的信息通常是多模态的。为了进一步挖掘LLMs的潜力，许多研究者试图赋予LLMs理解多模态内容的能力。尽管它们有效，但是这些方法致力于将来自一个附加模态的输入与文本(即，图像或音频)对齐，这对于视频理解来说是不令人满意的。具体来说，使LLM能够理解视频需要对不同的模态进行综合处理，包括视觉输入、听觉输入和文本输出，这比只理解图像和只理解音频的任务更具挑战性。在这项工作中，为了填补视听LLM的空白，我们研究了构建多模态LLM的可能性，该多模态LLM支持视频输入，并允许用户围绕用户上传的视频与计算机聊天，该视频通常由多个视频帧和音频组成。 本文认为：
现实世界的信息是多模态的，只有文本的交互不够，所以我们要探索多模态LLMs的潜能。现有的方法总是视觉模态+文本模态捆绑模式，所以当前模型对视频理解能力差，尤其是对音频的理解能力。该项工作探索了多模态LLMs，填补了音频LLM空白，实现计算机能够理解用户发送的视频的聊天形式。 实现思路： 保证跨通道与训练的效率：采用BLIP-2的思想
明确捕捉视觉场景变化：用与训练视觉编码器分解计算帧表示
帧嵌入层注入时间
视频Q-Former生成可是查询令牌
视频中音频的处理：与训练的音频编码器及音频Q-former来学习合理的听觉嵌入。
------------------------------------------------------------------------------------------------------------------------
文本输出与视频对齐：
多分支跨模态预训练学习——&gt;视觉语言对应+音频语言对应。
视觉语言对齐：
首先：大规模视频字幕数据集使用视频CLIP到文本的生成任务对视觉相关组间进行预训练。
预训练阶段引入图像字幕数据集——&gt;加强对静态视觉概念的理解。
然后：使用视频对话的数据集微调这些组件，为指令优化做准备。
音频编码器+语言编码器的对齐：
音频——&gt;使用音频文本数据集在音频文本生成任务上预训练相关组件。
音频文本的衔接：使用Imagebind将不同模态与公共嵌入空间对齐
音频文本数据集有限——&gt;视觉文本数据训练音频相关组件【这合理吗？】
总结：
这些组件学习将Imagebind提供的公共嵌入空间与LLMs的嵌入空间对齐。尽管没有经过音频-文本数据的明确训练，Video-LLaMA在推理过程中表现出显著的零镜头音频理解能力
-----------------------------------------------------------------------------------------------------------------------
Video-LLaMA与现有模型相比表现出色，对视听模态信息理解全面：
创新型：
1.一个多模态框架，弥补了音频LLM空白，使LLM同时处理视频中的视觉+听觉内容。
2.多分支跨通道预训练框架来实现视觉语言对齐和音频语言对齐
3.开源了权重和代码
3.方法设计 Video-LLaMA旨在使冷冻LLM能够理解视频中的视觉和听觉内容
两个主要的分支：
视觉语言分支和音频语言分支，分别将视频帧和音频信号转换为与LLMs的文本输入兼容的查询表——多分支跨模态预训练和视听教学调谐
架构：
视觉-语言模型
音频-语言模型
多分支跨模态训练：A+B两个分支
第一阶段，大规模视觉字幕数据集用于训练
第二阶段，高质量的指令跟随数据集用于微调。图像被视为单帧视频
视觉语言训练 音频语言 视频语言模型： 如图1的左部所示，它包括
一个冻结的预训练图像编码器，用于从视频帧中提取特征；
一个位置嵌入层，用于将时间信息注入视频帧；
一个视频Q-former，用于聚合帧级表示；
一个线性层，用于将输出视频表示投影到与LLM的文本嵌入相同的维度。
实现：利用BLIP-2(李等，2023b)的预训练视觉组件作为冻结视觉编码器，它包括来自EVA-CLIP(方等，2022)的ViT G/14和预训练Q-former
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/705493a87bd01d180bd552d55a794cf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a0f88786826d1d99de3eb61a277f4fb/" rel="bookmark">
			无脑利用API实现文心一言AI对话功能？(附代码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：在当今数字化的时代，人工智能（AI）技术正在不断演进，为开发者提供了丰富的工具和资源。其中，API（应用程序接口）成为构建强大AI应用的关键组成部分之一。本文将介绍如何利用API来打造一个AI对话网站，使用户能够与智能系统进行交互。
以下内容不作太多解释，不懂就无脑套用就行，这里的api接口以文心一言示例，先在LuckyCola注册账号然后在个人中心申请appKey
1.请求方式 请求方式: POST
https://luckycola.com.cn/ai/openwxyy 建议使用https协议,当https协议无法使用时再尝试使用http协议
2.请求参数 序号参数是否必须说明1ques是提交问题2appKey是唯一验证AppKey3uid是唯一标识4isLongChat否是否支持上下文(值为1或者0) 3.请求参数示例 { "ques": "hello", "appKey": "*****************", "uid": "***************", // 是否支持上下文 值1表示支持,0表示不支持 "isLongChat": 0 } 3.接口 返回示例 { // 成功状态码 "code": 0, // 成功提示 "msg": "AI接口返回成功", "data": { // AI回答结果 "result": "您好，如果您需要帮助或有任何问题，请随时告诉我，我将竭诚为您服务。", "countMsg": "无穷", // 当前是否是上下文对话模式,1表示是上下文模式,0为非上下文模式 "longChat": 0 } } 建立前端页面，创建一个用户友好的前端页面，可以使用HTML、CSS和JavaScript等技术来实现交互式的用户界面。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;AI对话网站&lt;/title&gt; &lt;style&gt; /* 在这里添加你的样式 */ &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a0f88786826d1d99de3eb61a277f4fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/150abfdebb71bef8956515e9dd1af32c/" rel="bookmark">
			MySQL - 创建表的三种方法详解及练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
🥙1. 基础创建
🧀实例1
🥙2. 带约束创建
🧀实例2
🥙3. 复制创建
🧀实例3：
🧀实例4：
🧀实例5：
​ 🧀实例6：
🧀实例7：
🥙4. 牛客题：
🥙1. 基础创建 -- 基本语法 CREATE TABLE 表名称( 字段名1 数据类型1, 字段名2 数据类型2, 字段名3 数据类型3); 🧀实例1 创建一个actor表，包含如下列信息
列表
类型
actor_id
smallint(5)
first_name
varchar(45)
last_name
varchar(45)
last_update
date
示例代码
drop table if exists actor; create table actor( actor_id smallint(5), first_name varchar(45), last_name varchar(45), last_update date ); 结果：
🥙2. 带约束创建 -- 基本语法 CREATE TABLE 表名称( 字段名1 数据类型1 主键 自增长, 字段名2 数据类型2 非空 默认值, 字段名3 数据类型3) ENGINE=当前表格的引擎 AUTO_INCREMENT=自增长的起始值 DEFAULT CHARSET=表数据的默认字符集; 🧀实例2 创建一个actor表，包含如下列信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/150abfdebb71bef8956515e9dd1af32c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db09ffd042ce0c2b968ce0ce1e7452c6/" rel="bookmark">
			Mysql - 常用插入数据的三种方法详解及练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
🥙8.1.1 mysql中常用的三种插入数据的语句
1. insert into - 插入数据
2. replace into - 插入替换数据
3. insert ignore - 如果已存在，忽略当前新数据
🥙8.1.2 以上三种方法的练习及区分
🥙8.1.3 说明
🥙8.1.4 牛客练习题
🥙8.1.1 mysql中常用的三种插入数据的语句 1. insert into - 插入数据 数据库会检查主键，如果出现重复会报错； # 第一种方式 insert into 表名(字段名1,字段名2,...) values(值1,值2,...); # 第二种方式：按照表中所有字段进行插入数据，一定要与字段在表中定义的顺序一致 insert into 表名 values(值1,值2,...); 2. replace into - 插入替换数据 需求表中有PrimaryKey，或者unique索引，如果数据库已经存在数据，则用新数据替换，如果没有数据效果则和insert into一样；
# 第一种方式 replace into 表名(字段名1,字段名2,...) values(值1,值2,...); # 第二种方式：按照表中所有字段进行插入数据，一定要与字段在表中定义的顺序一致 replace into 表名 values(值1,值2,...); 3. insert ignore - 如果已存在，忽略当前新数据 如果已经存在相同的记录，则忽略当前新数据；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db09ffd042ce0c2b968ce0ce1e7452c6/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/550/">«</a>
	<span class="pagination__item pagination__item--current">551/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/552/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>