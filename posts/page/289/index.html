<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c20b0180191c91c3a13c6a3aab9cea8d/" rel="bookmark">
			Java 语言概述 -- Java 语言的介绍、现在、过去与将来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是栗筝i，这篇文章是我的 “栗筝i 的 Java 技术栈” 专栏的第 001 篇文章，在 “栗筝i 的 Java 技术栈” 这个专栏中我会持续为大家更新 Java 技术相关全套技术栈内容。专栏的主要目标是已经有一定 Java 开发经验，并希望进一步完善自己对整个 Java 技术体系来充实自己的技术栈的同学。与此同时，本专栏的所有文章，也都会准备充足的代码示例和完善的知识点梳理，因此也十分适合零基础的小白和要准备工作面试的同学学习。当然，我也会在必要的时候进行相关技术深度的技术解读，相信即使是拥有多年 Java 开发经验的从业者和大佬们也会有所收获并找到乐趣。
–
作为 “Java 入门” 也是整个专栏的第一篇文章，我在这里主要是会先介绍一下 Java 语言 —— Java 是什么? 可以用来做什么? 从诞生到现在依旧有这么多人用着 Java，说明它一定做对了一些，有着一些优点，那么都是什么？Java 近些年来在全球的热度有所下降，是什么原因？Java 还值得作为第一门编程语言或者工作语言来学习吗？现在的 Java 就业前景是怎样的？这些都是本篇内容所要讨论的。
最后在前言的末尾我补充一下，如果这篇文章，对大家有所帮助或收获一定的乐趣和想法，那么非常欢迎大家能够，点赞、评论、收藏、订阅。这些也将是我持续更新的最大动力。
文章目录 1、Java 语言的简介1.1、Java 语言的概述1.2、Java 语言的特性1.3、Java 语言的应用现状 2、Java 语言的演进2.1、"Java"名字的由来2.2、Java 演进历史1.3、Java 各个版本特性 3、Java 语言的前景3.1、Java 语言发展现状3.2、Java 语言就业前景 1、Java 语言的简介 1.1、Java 语言的概述 Java 语言是于 1991 年由 Sun（Sun Microsystems，美国）公司的 詹姆斯·高斯林（James Gosling）团队研发的一门面向对象的编程语言。最初命名为 Oak，并于 1995 年更名为 Java 后开始推广。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c20b0180191c91c3a13c6a3aab9cea8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46537ae925a047e9ddf0dea7becec9c6/" rel="bookmark">
			如何从 Android 图库中恢复误删除的照片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果您正在阅读这篇文章，那么您肯定意外地从 Android 设备中删除了照片。并且您正在寻找一种简单的方法来恢复 Android 图库中已删除的照片。
从图库恢复已删除的照片 随着技术的进步，现在使用单个设备（即 Android 手机），您就可以捕捉图像、根据需要编辑图像、高效管理图像、存储图像并与朋友分享图像。现在，我们都知道，我们捕捉或从朋友那里收到的图像或下载的图像默认保存到 Android 图库中。因此，我们都认为，一旦照片从图库中删除，它就会永远丢失。但好消息是，人们可以从 Android 图库中恢复已删除的图像。
因此，读者无需多言，让我们学习如何从Android 图库应用程序中恢复已删除的照片。 方法1：如何使用Google相册从图库中恢复已删除的照片 Google Photos是一款非常实用的应用程序，可用于管理、共享和存储您的所有照片，当您想要从图库中恢复已删除的图片时，它可以帮到您。因此，如果您在 Google Photos 上启用了备份和同步功能，那么您就可以找到图库中之前存在的所有图片。
要通过 Google 相册从 Android 图库恢复已删除的图片，请按照以下步骤操作：
1. 点击设备上的 Google 照片应用图标以打开该应用程序。
2. 现在选择要恢复的图像并点击图像右上角的三个点。
3. 从可用选项中选择“保存到设备”。图像现在将恢复到 Android 图库中的“已恢复”文件夹中。
请注意，如果您的设备上已经存在该图像，则此选项将不存在。
方法2：使用第三方应用程序从Android图库恢复已删除的图像 上述步骤仅在您已将图片和数据同步并备份。但如果您不使用这两种 Google 服务中的任何一种，该怎么办？不用担心，您仍然可以使用奇客数据恢复Android版应用程序恢复已删除的图片。我们建议使用奇客数据恢复Android版开发的照片恢复应用程序。
奇客数据恢复Android版是同类工具中最强大、最先进的工具之一，可以从外部和内部存储器中恢复已删除的图像。
如何使用奇客数据恢复Android版应用程序恢复已删除的图像。 在 Android 设备上安装奇客数据恢复Android版程序后，连接上手机后，打开它并点击“开始扫描”以开始扫描。当请求权限访问时，请提供。
奇客数据恢复安卓版：免费下载扫描数据-奇客官网免费下载奇客安卓手机数据恢复软件扫描数据，支持文件、照片、视频、邮件、音频、微信消息等1000+种文件格式。https://www.geekersoft.cn/geekersoft-recovergo-android.html
现在，该应用程序将在目录、内部存储器和外部存储（如果您使用 SD 卡）中查找所有已删除的照片。
扫描过程可能需要一些时间，具体取决于设备的内存大小。
扫描完成后，您将看到所有已删除照片的缩略图列表。您可以在恢复之前查看每张图片。
方法3：如何使用Google Drive从Android图库恢复图片： 另一种从 Android 图库恢复照片的方法是使用 Google Drive，无论是在 Android 还是在计算机上使用其应用程序。如果您经常使用 Google Drive 备份包括照片在内的数据，那么您可以轻松恢复已删除的照片。
1. 登录您的 Google 帐户并在您的计算机或手机上打开 Google Drive。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46537ae925a047e9ddf0dea7becec9c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fadacd7c9d0e70559445ba71bd3368bb/" rel="bookmark">
			11.Spring AOP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.什么是 Spring AOP？2.为什要用 AOP？3.Spring AOP 应该怎么学习呢？3.1 AOP 组成3.1.1 切⾯（Aspect）= 切点 + 通知3.1.2 连接点（Join Point）3.1.3 切点（Pointcut）3.1.4 通知（Advice） 3.2 Spring AOP 实现3.2.1五大通知类型3.2.2 @Order注解解析3.2.3切点表达式3.2.4@annotation 3.3 Spring AOP 实现原理 - 代理模式(静态代理，动态代理)3.3.1静态代理 代码实现3.3.1动态代理 代码实现3.3.1.1jdk 动态代理实现3.3.1.2CGLIB 动态代理实现 3.3.2面试题 大家好，我是晓星航。今天为大家带来的是 Spring AOP 相关的讲解！😀
1.什么是 Spring AOP？ Spring两大核心思想：Ioc Aop
在介绍 Spring AOP 之前，⾸先要了解⼀下什么是 AOP？
AOP（Aspect Oriented Programming）：⾯向切⾯编程，它是⼀种思想，它是对某⼀类事情的集中处理。⽐如⽤户登录权限的效验，没学 AOP 之前，我们所有需要判断⽤户登录的⻚⾯（中的⽅法），都要各⾃实现或调⽤⽤户验证的⽅法，然⽽有了 AOP 之后，我们只需要在某⼀处配 置⼀下，所有需要判断⽤户登录⻚⾯（中的⽅法）就全部可以实现⽤户登录验证了，不再需要每个⽅法中都写相同的⽤户登录验证了。 ⽽ AOP 是⼀种思想，
⽽ Spring AOP 是⼀个框架，提供了⼀种对 AOP 思想的实现，它们的关系和 IoC 与 DI 类似。
2.为什要用 AOP？ 想象⼀个场景，我们在做后台系统时，除了登录和注册等⼏个功能不需要做⽤户登录验证之外，其他⼏ 乎所有⻚⾯调⽤的前端控制器（ Controller）都需要先验证⽤户登录的状态，那这个时候我们要怎么处理呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fadacd7c9d0e70559445ba71bd3368bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/285883c75cce6f5b18629ed6fa29a302/" rel="bookmark">
			You are applying Flutter‘s app_plugin_loader Gradle plugin imperatively using the apply script metho
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个一般会同时出现两个提示：
一：
原文：You are applying Flutter’s app_plugin_loader Gradle plugin imperatively using the apply script method, which is deprecated and will be removed in a future release. Migrate to applying Gradle plugins with the declarative plugins block: https://flutter.dev/go/flutter-gradle-plugin-apply
翻译：您正在使用apply-script方法强制应用Flutter的app_plugin_loader Gradle插件，该方法已被弃用，将在未来的版本中删除。迁移到使用声明性插件块应用Gradle插件：https://flutter.dev/go/flutter-gradle-plugin-apply
二：
原文：You are applying Flutter’s main Gradle plugin imperatively using the apply script method, which is deprecated and will be removed in a future release. Migrate to applying Gradle plugins with the declarative plugins block: https://flutter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/285883c75cce6f5b18629ed6fa29a302/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92887acdfb1a48adc685dace4b162e88/" rel="bookmark">
			mysql之聚合函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		聚合函数通常在 SQL 查询中与 GROUP BY 语句一起使用，它们对一组值执行计算并返回单个值。以下是一个示例 SQL 查询，它结合使用了多个聚合函数来演示它们的用法：
假设我们有一个名为 sales 的表，它包含了 amount 和 date 两个字段，分别表示销售额和销售日期：
CREATE TABLE sales ( id INT AUTO_INCREMENT PRIMARY KEY,amount DECIMAL(10, 2), sale_date DATE); 现在，我们使用一个查询来演示如何使用聚合函数来获取总销售额、平均销售额、最高销售额、最低销售额和销售记录数量：
SELECT COUNT(*) AS total_sales_count, -- 总销售记录数 SUM(amount) AS total_sales, -- 总销售额 AVG(amount) AS average_sale, -- 平均销售额 MAX(amount) AS highest_sale, -- 最高销售额 MIN(amount) AS lowest_sale -- 最低销售额 FROM sales; 在这个查询中，每个聚合函数都作用于 sales 表的 amount 字段，除了 COUNT(*)，它是用来统计总的销售记录数。
如果我们想要根据某个时间段（比如每个月）来分组统计这些数据，我们可以添加 GROUP BY 语句：
SELECT YEAR(sale_date) AS sale_year, MONTH(sale_date) AS sale_month, COUNT(*) AS total_sales_count, SUM(amount) AS total_sales, AVG(amount) AS average_sale, MAX(amount) AS highest_sale, MIN(amount) AS lowest_sale FROM sales GROUP BY YEAR(sale_date), MONTH(sale_date); 这个查询将 sales 表中的记录按年份和月份进行分组，并计算每个组的总销售记录数、总销售额、平均销售额、最高销售额和最低销售额。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92887acdfb1a48adc685dace4b162e88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdc4406d0893313f9f8ea2b369c87d0d/" rel="bookmark">
			Spring Boot整合Redis通过Zset数据类型&#43;定时任务实现延迟队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😄 19年之后由于某些原因断更了三年，23年重新扬帆起航，推出更多优质博文，希望大家多多支持～
🌷 古之立大事者，不惟有超世之才，亦必有坚忍不拔之志
🎐 个人CSND主页——Micro麦可乐的博客
🐥《Docker实操教程》专栏以最新的Centos版本为基础进行Docker实操教程，入门到实战
🌺《RabbitMQ》专栏主要介绍使用JAVA开发RabbitMQ的系列教程，从基础知识到项目实战
🌸《设计模式》专栏以实际的生活场景为案例进行讲解，让大家对设计模式有一个更清晰的理解
💕《Jenkins实战》专栏主要介绍Jenkins+Docker的实战教程，让你快速掌握项目CI/CD，是2024年最新的实战教程
🌞《Spring Boot》专栏主要介绍我们日常工作项目中经常应用到的功能以及技巧，代码样例完整
如果文章能够给大家带来一定的帮助！欢迎关注、评论互动～
Spring Boot整合Redis通过Zset数据类型+定时任务实现延迟队列 前言redis常见的实现延迟队列的方案❶ 通过过期key通知实现❷ 通过Zset数据类型+定时任务实现❸ Redisson实现延迟队列 Zset数据延迟队列的原理开始实现步骤一：添加依赖步骤二：配置Redis步骤三：创建一个简单任务模型步骤四：创建 Redis 配置类步骤五：创建线程池配置类步骤六：创建延迟队列服务类步骤七：创建测试Controller 开始测试总结 前言 本文对应源码下载地址： https://download.csdn.net/download/lhmyy521125/89412365 无需积分
在我们项目开发中，我们经常需要在特定时间后执行某些任务，例如订单超时未支付自动取消、资金余额低于限额提醒、延时消息发送等。延迟队列是一种非常实用的解决方案，而Redis也具备延迟队列的功能，这里博主将和大家分享基于Redis的Zset数据类型+定时任务实现延迟队列
redis常见的实现延迟队列的方案 ❶ 通过过期key通知实现 开启redis的key过期通知，然后在业务中给key设置过期时间，到了过期时间后redis会自动的将过期的key消息推送给监听者，从而实现延迟任务
首先redis配置文件开启过期通知
notify-keyspace-events Ex Java项目中通过继承 KeyExpirationEventMessageListener 监听器重写 onMessage 方法实现消息的接收
@Component @Slf4j public class RedisExpireKeyService extends KeyExpirationEventMessageListener { public RedisExpireKeyService(RedisMessageListenerContainer listenerContainer) { super(listenerContainer); } /** * 监听过期的key * */ @Override public void onMessage(Message message, byte[] pattern) { String expireKey = message.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdc4406d0893313f9f8ea2b369c87d0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca81ec63d3331b8af1d66c219cd78ec5/" rel="bookmark">
			MySql一条查询语句的执行流程是怎么样的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySql一条查询语句的执行流程是怎么样的？ 1.前言 一条sql语句到底在执行时经历了什么？探究这个问题是学习mysql的重要步骤，面试时常被问到，也使得学习mysql时也有了知识框架的支撑，明白我们背的知识点到底用在哪里，笔者觉得这一点还是很重要的。
注：对一个知识点的总结不仅包含知识点本身，还包含对该知识点的联想，这个联想是在面试时可能被追问的，也可以自己主动说出来（我还知道。。。）加分的。
2.知识点 MySQL 执行流程是怎样的？ 首先要知道的是，我们可以把mysql分成两层，server层和数据库引擎层，前者主要是对我们的查询进行处理（主要包括 {连接器}，{查询缓存}、{解析器}、{预处理器、优化器、执行器} 等），后者是数据真正存储的地方（从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎）。
一条查询的执行流程如下：
第一步：通过连接器连接 MySQL 服务 mysql -h$ip -u$user -p
[连接器联想1]: 连接经过TCP 三次握手，断开经过四次挥手
[连接器联想2]: 如果用户密码都没有问题，连接器就会获取该用户的权限，然后保存起来，后续该用户在此连接里的任何操作，都会基于连接开始时读到的权限进行权限逻辑的判断，意思是管理员修改已登录用户的权限需要等他重新登录才生效
[连接器联想3]: 如何查看 MySQL 服务被多少个客户端连接了？show processlist
[连接器联想4]: 空闲连接会一直占用着吗？MySQL 定义了空闲连接的最大空闲时长，由 wait_timeout 参数控制的，默认值是 8 小时（28880秒），如果空闲连接超过了这个时间，连接器就会自动将它断开。
[连接器联想5]: MySQL 的连接数有限制吗？最大连接数由 max_connections 参数控制，超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。
[连接器联想6]: 怎么解决长连接占用内存的问题？MySQL 的连接也跟 HTTP 一样，有短连接和长连接的概念，长连接的好处就是可以减少建立连接和断开连接的过程，但是，使用长连接后可能会占用内存增多，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。有两种解决方式。第一种，定期断开长连接。第二种，客户端主动重置连接。MySQL 5.7 版本实现了 mysql_reset_connection() 函数的接口来重置连接，达到释放内存的效果。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。
[连接器联想7]: 连接器的工作？与客户端进行 TCP 三次握手建立连接；校验客户端的用户名和密码，如果用户名或密码不对，则会报错；如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；
第二步：查询缓存 连接器得工作完成后，客户端就可以向 MySQL 服务发送 SQL 语句了，MySQL 服务收到 SQL 语句后，就会解析出 SQL 语句的第一个字段，看看是什么类型的语句。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca81ec63d3331b8af1d66c219cd78ec5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/786c7378fc5c5065739c9c5b99a84b82/" rel="bookmark">
			天才程序员周弈帆 | Stable Diffusion 解读（一）：回顾早期工作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文来源公众号“天才程序员周弈帆”，仅用于学术分享，侵权删，干货满满。
原文链接：Stable Diffusion 解读（一）：回顾早期工作
在2022年的这波AI绘画浪潮中，Stable Diffusion无疑是最受欢迎的图像生成模型。究其原因，第一，Stable Diffusion通过压缩图像尺寸显著提升了扩散模型的运行效率，使得每个用户能在自己的商业级显卡上运行模型；第二，有许多基于Stable Diffusion的应用，比如Stable Diffusion自带的文生图、图像补全，以及ControlNet、LoRA、DreamBooth等插件式应用；第三，得益于前两点，Stable Diffusion已经形成了一个庞大的用户社群，大家互相分享模型，交流心得。
不仅是大众，Stable Diffusion也吸引了大量科研人员，很多本来研究GAN的人纷纷转来研究扩散模型。然而，许多人在学习Stable Diffusion时却犯了难：又是公式扎堆的扩散模型，又是VAE，又是U-Net，这该怎么学起呀？
其实，一上来就读Stable Diffusion是很难读懂的。而如果你把之前的一些更基础的文章读懂，再回头来读Stable Diffusion，就会畅行无阻了。在这篇及之后的几篇文章中，我将从科研的角度对Stable Diffusion做一个全面的解读。（1）在第一篇文章中，我将面向完全没接触过图像生成的读者，从头介绍Stable Diffusion是怎样从早期工作中一步一步诞生的；（2）在第二篇文章中，我将详细解读Stable Diffusion的论文；（3）在最后的第三篇文章中，我将带领大家阅读Stable Diffusion的官方源码，以及一些流行的开源库的Stable Diffusion实现。后续我还会写其他和Stable Diffusion相关的文章，比如ControlNet的介绍。
1 从自编码器谈起 包括Stable Diffusion在内，很多图像生成模型都可以看成是一种非常简单的模型——自编码器——的改进版。要谈Stable Diffusion是怎么逐渐诞生的，其实就是在谈自编码器是一步一步进化的。我们的学习就从自编码器开始。
尽管PNG、JPG等图像压缩方法已经非常成熟，但我们会想，会不会还有更好的图像压缩算法呢？图像压缩，其实就是找两个映射，一个把图片编码成压缩数据，另一个把压缩数据解码回图片。我们知道，神经网络理论上可以拟合任何映射。那我们干脆用两个神经网络来拟合两种映射，以实现一个图像压缩算法。负责编码的神经网络叫编码器（Encoder），负责解码的神经网络叫做解码器（Decoder）。
光定义了神经网络还不够，我们还需要给两个神经网络设置一个学习目标。在运行过程中，神经网络应该满足一个显然的约束：编码再解码后的重建图像应该和原图像尽可能一致，即二者的均方误差应该尽可能小。这样，我们只需要随便找一张图片，通过编码器和解码器得到重建图像，就能训练神经网络了。我们不需要给图片打上标签，整个训练过程是自监督的。所以我们说，整套模型是一个自编码器（Autoencoder，AE）。
图像压缩模型AE为什么会和图像生成扯上关系呢？你可以试着把AE的输入图像和编码器遮住，只看解码部分。把一个压缩数据解码成图像，换个角度看，不就是在根据某一数据生成图像嘛。
很可惜，AE并不是一个合格的图像生成模型。我们常说的图像生成，具体是指让程序生成各种各样的图片。为了让程序生成不同的图片，我们一般是让程序根据随机数（或是随机向量）来生成图片。而普通的AE会有过拟合现象，这导致AE的解码器只认得训练集里的图片经编码器解码出来的压缩数据，而不认得随机生成的压缩数据，进而也无法达到图像生成的要求。
所谓过拟合，就是指模型只能处理训练数据，而不能推广到一般的数据上。举一个极端的例子，如下图所示，编码器和解码器直接记忆了整个数据集，把所有图片压缩成了一个数字。也就是模型把编码器当成一个图片到数字的词典，把解码器当成一个数字到图片的词典。这样，不管数据集有多大，所有图片都可以被压缩成一个数字。这样的AE确实压缩能力很强，但它完全没用，因为它过拟合了，处理不了训练集以外的数据。
过拟合现象在普通版AE中是不可避免的。为了利用AE的解码器来生成图片，许多工作都在试图克服AE的过拟合现象。AE的改进思路很多，在这篇文章中，我们仅把AE的改进路线粗略地分成两种：解决过拟合问题以直接用AE做图像生成、用AE压缩图像间接实现图像生成。
2 第一条路线：VAE 和 DDPM 在第一条改进路线中，许多后续工作都试图用更高级的数学模型来解决AE的过拟合问题。变分自编码器（Variational Autoencoder, VAE） 就是其中的代表。
VAE对AE做了若干改动。第一，VAE让编码器的输出不再是一个确定的数据，而是一个正态分布中的一个随机数据。更具体一点，训练时，编码器会同时输出一个均值和方差。随后，模型会从这个均值和方差表达的正态分布里随机采样一个数据，作为解码器的输入。直观上看，这一改动就是在AE的基础上，让编码器多输出了一个方差，使得原AE编码器的输出发生了一点随机扰动。
这一改动可以缓解过拟合现象。这是为什么呢？我们可以这样想：原来的AE之所以会过拟合，是因为它强行记住了训练集里每一个数据的编码输出。现在，我们在VAE里让编码器不再输出一个固定值，而是随机输出一个在均值附近的值。这样的话，VAE就不能死记硬背了，必须要找出数据中的规律。
VAE的第二项改动是多添加一个学习目标，让编码器的输出和标准正态分布尽可能相似。前面我们谈过，图像生成模型一般会根据一个随机向量来生成图像。最常用的产生随机向量的方法是去标准正态分布里采样。也就是说，在用VAE生成图像时，我们会抛掉编码器，用下图所示的流程来生成图像。如果我们不约束编码器的输出分布，不让它输出一个和标准正态分布很相近的分布的话，解码器就不能很好地根据来自标准正态分布的随机向量生成图像了。
综上，VAE对AE做了两项改进：使编码器输出一个正态分布，且该分布要尽可能和标准正态分布相似。训练时，模型从编码器输出的分布里随机采样一个数据作为解码器的输入；图像采样（图像生成）时，模型从标准正态分布里随机采样一个数据作为解码器的输入。VAE的误差函数由两部分组成：原图像和重建图像的重建误差、编码器输出和标准正态分布之间的误差。VAE要最小化重建误差，最大化编码器输出与标准正态分布的相似度。
分布与分布之间的误差可以用一个叫KL散度的指标表示。所以，在上面那个误差函数公式中，负的相似度应该被替换成KL散度。VAE的这两项改动本质上都是在解决AE的过拟合问题，所以，VAE的改动可以被看成一种正则化方法。我们可以把VAE的正则化方法简称为KL正则化。（在机器学习中，正则化方法就是「降低模型过拟合的方法」的简称。）
【补充学习】原文链接：机器学习_KL散度详解（全网最详细）_kl散度计算公式-CSDN博客
VAE确实能减轻AE的过拟合。然而，由于VAE只是让重建图像和原图像的均方误差（重建误差）尽可能小，而没有对重建图像的质量施加更多的约束，VAE的重建结果和图像生成结果都非常模糊。以下是VAE在CelebA数据集上图像生成结果。
在众多对VAE的改进方法中，一个叫做去噪扩散概率模型（Denoising Diffusion Probabilistic Model, DDPM） 的图像生成模型脱颖而出。DDPM正是当今扩散模型的开山鼻祖。我们来看一下DDPM是怎样基于VAE对图像生成建模的。
VAE之所以效果不好，很可能是因为它的约束太少了。VAE的编码和解码都是用神经网络表示的。神经网络是一个黑盒，我们不好对神经网络的中间步骤施加约束，只好在编码器的输出（某个正态分布）和解码器的输出（重建图像）上施加约束。能不能让VAE的编码和解码过程更可控一点呢？
DDPM的设计灵感来自热力学：一个分布可以通过一系列简单的变化（如添加高斯噪声）逐渐变成另一个分布。恰好，VAE的编码器不正是想让来自训练集的图像（训练集分布）变成标准正态分布吗？既然如此，就不要用一个可学习的神经网络来表示VAE的编码器了，干脆用一些预定义好的加噪声操作来表示解码过程。可以从数学上证明，经过了多次加噪声操作后，最后的图像分布会是一个标准正态分布。
既然编码是加噪声，那解码时就应该去掉噪声。DDPM的解码器也不再是一个不可解释的神经网络，而是一个能预测若干个去噪结果的神经网络。
相比只有两个约束条件的VAE，DDPM的约束条件就多得多了。在DDPM中，第t个去噪操作应该尽可能抵消掉第t个加噪操作。
总结一下，DDPM对VAE做了如下改动：
编码器是一系列不可学习（固定）的加噪声操作
解码器是一系列可学习的去噪声操作
图像尺寸自始至终不变
相比于VAE，DDPM的编码过程和解码过程的定义更加明确，可以施加的约束更多。因此，如下图所示，它的生成效果会比VAE好很多。同时，DDPM和VAE类似，它在编码时会从分布里采样，而不是只输出一个固定值，不会出现AE的过拟合问题。
DDPM的图像生成结果
DDPM的生成效果确实很好。但是，由于DDPM始终会对同一个尺寸的数据进行操作，图像的尺寸极大地影响了DDPM的运行速度，用DDPM生成高分辨率图像需要耗费大量计算资源。因此，想要用DDPM生成高质量图像，还得经过另一条路线。
3 第二条路线：VQVAE 在AE的第二条改进路线中，一些工作干脆放弃使用AE做图像生成，转而利用AE的图像压缩能力，把图像生成拆成两步来做：（1）先用AE的编码器把图像压缩成更小的图像，（2）再用另一个图像生成模型生成小图像，并用AE的解码器把小图像重建回真实图像。
为什么会有这么奇怪的图像生成方法呢？这得从另一类图像生成模型讲起。在机器翻译模型Transformer横空出世后的一段时间里，有很多工作都想把Transformer用在图像生成上。但是，原本用来生成文本的Transformer无法直接应用在图像上。在自然语言处理（NLP）中，一个句子可以用若干个单词表示。而每个单词又是用一个整数表示。所以，Transformer生成句子时，实际上是在生成若干个离散的整数，也就是生成一个离散向量。而在图像生成模型中，每个像素的颜色值是一个连续的浮点数。想把Transformer直接用在图像生成上，就得想办法把图像用离散向量表示。我们知道，AE可以把图像编码成一个连续向量。能不能做一些修改，让AE把图像编码成一个离散向量呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/786c7378fc5c5065739c9c5b99a84b82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed97b7aa74202349786ddef8f820f235/" rel="bookmark">
			【数据分析】统计学基础及Python具体实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各位大佬好 ，这里是阿川的博客，祝您变得更强 个人主页：在线OJ的阿川
大佬的支持和鼓励，将是我成长路上最大的动力
阿川水平有限，如有错误，欢迎大佬指正
Python 初阶
Python–语言基础与由来介绍
Python–注意事项
Python–语句与众所周知
数据清洗前 基本技能
数据分析—技术栈和开发环境搭建
数据分析—Numpy和Pandas库基本用法及实例
统计学基础前 必看
数据分析—三前奏：获取/ 读取/ 评估数据
数据分析—数据清洗操作及众所周知
数据分析—数据整理操作及众所周知
目录 统计学概述数值数据分析维度偏态解释 数据分析与统计学不可分割
统计学概述 统计学主要是描述和推断
描述
分类数据 有限数量的类别的数据 定序 有顺序的 例如金银铜三枚奖牌，金大于银大于铜 定类 例如猫的种类，不能说有顺序 数值数据 对可进行数学运算和统计分析计算有意义的数据 连续 例如1~2之间区间有很多连续的数字 离散 只能以整数或自然数为单位的数据 数值数据分析维度 数值数据是数据分析的重点，分析维度主要从三个方面来分析
集中趋势 数据集中分布在哪里 mean平均数 median中位数 mode众数 离散趋势 数据偏离中心分布在哪里 max-min极差 var/std 方差/标准差 quantile（0.75）- quantile（0.25）四分位距
四分位距是将数据按顺序，按四等分分好并排序，处于三个分割点位置的数值就是四分位数-表示中间一半数值的离散程度 越大说明数据越分散越小说明数据越集中 分布形状 可以看出数据的偏态、峰度、异常值分布形状主要是指直方图
plot 表示画图 kind参数具体什么形状 hist表示直方图 偏态解释 直方图一般为正态分布（平均值、中位数、众数差不多都位于中央）
偏态（平均数、中位数、众数偏离中央）
正偏态即右偏态
负偏态及左偏态
注意一下直方图
数据量小，分布形状较不明显数据量大，分布形状较明显 好的，到此为止啦，祝您变得更强
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed97b7aa74202349786ddef8f820f235/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/292a23218e000d85f2cd56b15563ed68/" rel="bookmark">
			达梦8 开启物理逻辑日志对系统的影响
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		物理逻辑日志，是按照特定的格式存储的服务器的逻辑操作，专门用于 DBMS_LOGMNR 包挖掘获取数据库系统的历史执行语句。当开启记录物理逻辑日志的功能时，这部分日志内 容会被存储在重做日志文件中。
要开启物理逻辑日志的功能，需要满足下面两个条件： 首先，要设置 RLOG_APPEND_LOGIC 为 1、2、3 或者 4； 其次，通过设置参数 RLOG_IGNORE_TABLE_SET=1 或者建表（或修改表）时指定 ADD LOGIC LOG 开 启 。
新安装的数据库RLOG_APPEND_LOGIC和RLOG_IGNORE_TABLE_SET参数默认0，即没有开启物理逻辑日志，无法使用DBMS_LOGMNR 包挖掘获取数据库系统的历史执行语句。
在生产库上一切变动都要格外谨慎，下面我们测试一下开启该功能前后的性能对比。
先准备一张测试表
#创建测试表 create table t1(a int); #插入100万行数据 insert into t1 select rownum from dual connect by level&lt;=1000000; 准备好测试脚本
set serveroutput on declare ls_arch_size varchar; begin for i in 1..10 loop update t1 set a=a+1; commit; end loop; select sum(free) into ls_arch_size from v$arch_file; dbms_output.put_line(ls_arch_size); end; 测试步骤：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/292a23218e000d85f2cd56b15563ed68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d6547e0cf0f29e729f23493c16ec5a0/" rel="bookmark">
			程序员如何转行成为一个漫画自媒体-连载2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		仿写关于如何撰写文案的内容如下： 如何编写文案？ 从零开始自己创作显然效率过低，初期阶段还是需要从其他漫画公众号中学习技巧，然而只能看到最终成品，却无法获得他们的实际文案。
不过，通过广泛的阅读，我开始从现有的作品中抽象出一些常见的漫画表达手法。例如，对比型、盘点型、故事型、悬念型、互动型等，这些都是一些标准的表现形式。
这里举例两种常用的格式，如： 对比型漫画：[参考链接] 悬疑型漫画：[参考链接]
我开始尝试撰写自己的文案，基于我已了解的这些格式，大约用了两天时间，模仿着写出了第一篇我认为还算合格的初稿文案。
不过，当文案交给漫画师后，她的反馈是，这样的文案不适合绘制。
后来明白，漫画文案与普通写作完全不同，漫画文案更侧重于场景化的描述，需要详细描述每个画面的具体样子。
这种场景化的思维方式，与通常的文章写作截然不同。
在写文章时，我们只需按照思路清晰地表达想法即可，但对于漫画文案，思维更像是在放映一部电影，要考虑每个镜头包含哪些元素，是远景还是近景，人物的情绪，环境的氛围，详细描述这些内容会更方便漫画师的表现。
在后续观看其他漫画时，我都会特别注意他们如何处理分镜，甚至看电影时，也习惯于分析哪些镜头运用得更为精彩，然后记录下来并应用到我的文案中。
在这样的努力下，为了写出一篇令人满意的文案，我经历了多次的推翻重来，大约一个多月后，我终于完成了第一篇较为满意的文案作品。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fc3fabc7736a3b3938792f8f48d6544/" rel="bookmark">
			【MySQL】函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数 1.日期函数2.字符串函数3.数学函数4.其他函数 点赞👍👍收藏🌟🌟关注💖💖
你的支持是对我最大的鼓励，我们一起努力吧!😃😃
在mysql中其实内置了很多的函数操作，这些函数可以让我们在数据统计的时候以及查表的时候进行各自各样的操作。
1.日期函数 函数名称描述current_date()当前日期current_time()当前时间current_timestamp()当前时间戳date(datetime)返回datetime参数的日期部分date_add(date，interval d_value_type)在date中添加日期或者时间 ，interval后的数值单位可以是：year、minute、second、daydate_sub(date，interval d_value_type)在date中减去日期或者时间 ，interval后的数值单位可以是：year、minute、second、daydatediff(date1，date2)两个日期的差，单位是天now()当前日期时间 获得当前日期(年月日)
select current_date(); 获得当前时间(时分秒)
select current_time(); 获得当前时间戳
select current_timestamp(); 获得当前日期时间
select now(); 截断当前时间，只获得日期部分
select date(now()); 函数中可以嵌套函数
在日期的基础上加日期
select date_add(now(),interval 10 year); 在日期的基础上减去时间
select date_sub(now(),interval 10 minute); 计算两个日期之间相差多少天
select datediff(now(),'1949-10-01'); 前面减后面
这些函数有什么用呢，下面有两个案例
创建一张表，记录生日
create table tmp( id int primary key auto_increment, birthday date not null #时间的类型 年月日 ); 虽然current_time()这里显示的是时分秒，实际上插入的时候也能插入，所有的时间在获取的时候都是年月日 时分秒，只不过显示时是不一样的。
但是不建议这样使用。
这里时间戳也能插入，你可以理解成隐式类型转化，birthday要的是date日期类型，那么只要你有日期就会把日期拿到。
建议还是匹配着使用！
创建一个留言表
平常我们评论的时候不仅有内容显示出来，还有对应的时间。
create table msg( id int primary key auto_increment, content varchar(100) not null, sendtime datetime #日期时间 年月日 时分秒 ); 这就是根据时间类型建立带时间的表结构
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fc3fabc7736a3b3938792f8f48d6544/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05d9416a7f4a34ad771d75d4217fd597/" rel="bookmark">
			【机器学习】机器学习引领AI：重塑人类社会的新纪元
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📝个人主页🌹：Eternity._
🌹🌹期待您的关注 🌹🌹
❀机器学习引领AI 📒1. 引言📕2. 人工智能（AI）🌈人工智能的发展🌞应用领域🌙技术实现⭐赋能者的崛起 📚3. AI与机器学习的结合⛰️人机协作的新时代🏞️AI的简单应用🌄AI：人类的合作伙伴🍂数据收集与预处理🍁训练机器学习模型🌸AI与人类医生协作 📜4. AI：负责任的参与者🎩伦理问题🎈可持续发展 📖5. 总结与展望🌊挑战🔥总结💧展望 📒1. 引言 随着科技的飞速发展，机器学习作为人工智能（AI）的核心驱动力，正在以前所未有的速度重塑人类社会的各个方面。从医疗诊断、金融决策，到智能家居、自动驾驶，AI已经不再是遥不可及的未来科技，而是成为了我们日常生活中不可或缺的一部分
人工智能（AI）是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。其核心思想是通过计算机科学和其他学科的交叉融合，实现智能机器的自主决策、学习和适应环境的能力，从而模拟、延伸和扩展人类的智能。 📕2. 人工智能（AI） 人工智能对于现在的社会影响是非常大的，人工智能也在很多领域上发挥着强大的作用！
🌈人工智能的发展 阶段突破符号逻辑和推理规则阶段（1950年代-1960年代）研究人员尝试使用符号逻辑和推理规则来模拟人类思维。专家系统阶段（1960年代-1970年代）利用知识库、推理规则来解决特定领域的问题。连接主义AI阶段（1980年代-1990年代）转向神经网络和机器学习，通过模拟神经元的连接和规则来实现智能。深度学习阶段（2000年以后）随着大数据和计算能力的提升，深度学习技术得到广泛应用，基于统计模型和神经网络，能够自动从数据中学习，并在图像识别、自然语言处理等领域取得重大突破。 🌞应用领域 人工智能的应用领域非常广泛，包括但不限于以下几个方面：
领域作用机器人智能机器人是人工智能技术在机器人领域的应用，能够根据环境和任务的不同进行自主决策和行动。智能家居通过人工智能技术实现对家居设备的智能化控制，提高家庭生活的舒适度和便利性。智能医疗利用人工智能技术实现对医疗数据的分析和挖掘，提高医疗服务的效率和质量，如智能诊断系统、智能手术机器人等。金融人工智能在金融领域的应用包括智能投顾、智能风控等，可以根据投资者的风险偏好和投资目标提供个性化的投资建议，实现对信贷风险的精准控制。 🌙技术实现 机器学习： 通过对大量数据进行学习和分析，实现对未知数据的预测和分类。机器学习算法包括监督学习、无监督学习、半监督学习等。
深度学习： 深度学习是机器学习领域的一种分支技术，利用神经网络模型对大量数据进行训练和学习，实现对复杂数据的特征提取和分类。
自然语言处理： 通过对人类语言的分析和处理，实现对文本信息的提取、分类和生成。
计算机视觉： 通过对图像和视频的分析和处理，实现对目标物体的识别、跟踪和定位。
⭐赋能者的崛起 在机器学习的助力下，AI已经成为了一个强大的赋能者。它不仅能够自动化处理大量数据，提高生产效率，还能够通过智能算法为人类提供精准的决策支持。
在医疗领域，AI通过深度学习技术，能够辅助医生进行疾病诊断和治疗方案制定；
在金融领域，AI通过大数据分析，能够为客户提供个性化的理财建议和风险管理方案。
这些应用不仅提高了工作效率，也极大地提升了人类的生活质量。
📚3. AI与机器学习的结合 ⛰️人机协作的新时代 过去，AI常常被看作是取代人类劳动力的威胁。然而，在机器学习的推动下，AI已经逐渐转变为人类的合作伙伴。通过人机协作，AI能够为人类提供更高效的解决方案，共同面对复杂的挑战。例如，在智能制造领域，AI系统能够与工人共同操作，提高生产线的灵活性和适应性；在科研领域，AI能够协助科学家进行数据分析和模拟实验，加速科研进程。这种协作模式不仅提高了工作效率，也促进了人类与AI之间的和谐共生。
🏞️AI的简单应用 机器学习使得AI能够处理海量数据，从中学习并提取有用信息，从而赋能各行各业。以下是一个简单的机器学习代码示例，使用Python的scikit-learn库进行线性回归预测：
代码示例（Python，伪代码）：
from sklearn.datasets import load_iris from sklearn.model_selection import train_test_split from sklearn.svm import SVC from sklearn.metrics import accuracy_score # 加载鸢尾花数据集 iris = load_iris() X = iris.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05d9416a7f4a34ad771d75d4217fd597/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4ab870d2cfc30279e463eb8b2d67ed4/" rel="bookmark">
			18-Nacos-NacosRule负载均衡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		18-Nacos-NacosRule负载均衡 1.根据集群负载均衡
1.修改order-service中的application.yml，设置集群为HZ：
spring: cloud: nacos: server-addr: localhost:8848 #nacos服务端地址 discovery: cluster-name: HZ #配置集群名，也就是机房位置，例如：HZ，杭州 2.然后在order-service中设置负载均衡的IRule为NacosRule，这个规则优先会寻找与自己同集群的服务
userservice: ribbon: NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule # 负载均衡规则 注意：NacosRule的访问特点：
优先选择本地集群，在本地集群内的多个服务当中在采用随机方式进行负载均衡
3.注意将user-service的权重都设置为1
2.总结：
1.NacosRule负载均衡策略：
​ 1.优先选择同集群服务实例列表
​ 2.本地集群找不到提供者，才回去其他集群寻找，并且会报警告
​ 3.确定了可用实例列表后。再采用随机负载均衡挑选实例
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5cc1aa798b9c38d0154d2f72852138b/" rel="bookmark">
			RabbitMQ基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习课程文档 目录
背景
初识MQ
同步调用
异步调用 MQ界面介绍 交换机 队列 绑定关系
​发送消息
数据隔离 用户管理 ​virtual host虚拟主机 Spring AMQP 快速入门 起步依赖
消息发送
​消息接收 ​WorkQueues模型
​能者多劳
总结
交换机类型
Fanout交换机
总结
Direct交换机
声明队列和交换机 消息接收 消息发送
总结
Topic交换机
总结
声明队列和交换机
基于Bean声明
fanout示例 基于注解声明
示例 消息转换器(converandsend)
配置JSON转换器 消费者接收Object
背景 RabbitMQ作为一个高性能异步通讯组件，为解决高并发而生。
微服务一旦拆分，必然涉及到服务之间的相互调用，目前我们服务之间调用采用的都是基于OpenFeign的调用。这种调用中，调用者发起请求后需要等待服务提供者执行业务返回结果后，才能继续执行后面的业务。也就是说调用者在调用过程中处于阻塞状态，因此我们成这种调用方式为同步调用，也可以叫同步通讯。但在很多场景下，我们可能需要采用异步通讯的方式。 初识MQ 同步调用 随着业务规模扩大，产品的功能也在不断完善。如果采用同步调用，则假如每个微服务的执行时长都是50ms，则最终整个业务的耗时可能高达300ms，性能太差了。
其次由于我们是基于OpenFeign调用交易服务、通知服务。当交易服务、通知服务出现故障时，整个事务都会回滚，交易失败。我们假设用户余额充足，扣款已经成功，此时我们应该确保支付流水单更新为已支付，确保交易成功。因此，这里不能因为短信通知、更新订单状态失败而回滚整个事务。 综上，同步调用的方式存在下列问题：
拓展性差
性能下降
级联失败
异步调用 异步调用方式其实就是基于消息通知的方式，一般包含三个角色：
消息发送者：投递消息的人，就是原来的调用方
消息Broker：管理、暂存、转发消息，你可以把它理解成微信服务器
消息接收者：接收和处理消息的人，就是原来的服务提供方
采用异步调用后的支付服务：
当扩展业务时： 当然，异步通信也并非完美无缺，它存在下列缺点：
完全依赖于Broker的可靠性、安全性和性能
架构复杂，后期维护和调试麻烦
MQ界面介绍 用户有虚拟主机（类似database），虚拟主机有交换机，交换机与队列绑定关系。 交换机 我们打开Exchanges选项卡，可以看到已经存在很多交换机：
我们点击任意交换机，即可进入交换机详情页面。仍然会利用控制台中的publish message 发送一条消息：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5cc1aa798b9c38d0154d2f72852138b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c4b7de9f6f1aca9d7b7aa8028292e3b/" rel="bookmark">
			【虚拟现实】二、主要的AR/VR硬件设备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人不走空 🌈个人主页：人不走空 💖系列专栏：算法专题 ⏰诗词歌赋：斯是陋室，惟吾德馨 2.1 微软HoloLens 微软HoloLens是一款领先的混合现实设备，结合了AR和VR的元素，允许用户在现实世界中看到和与三维全息图互动。HoloLens在工业、医疗和教育等领域应用广泛。
硬件特点：
空间映射和手势识别：HoloLens通过内置的传感器和摄像头，能够实时捕捉用户周围的环境，进行精确的空间映射和手势识别。其深度感应摄像头和IMU（惯性测量单元）传感器使设备可以理解周围的空间结构和用户的手势，这对实现自然的人机交互至关重要。
高清全息显示：HoloLens提供高分辨率的全息图像，使虚拟内容在现实中看起来栩栩如生。显示器采用透视镜片设计，用户可以在观看全息图的同时看到现实环境，这种“混合现实”体验结合了虚拟和现实元素，增强了用户的感知。
自主计算和无线连接：HoloLens内置了强大的处理器（Holographic Processing Unit, HPU）和电池，可以独立运行，不需要外部计算机的支持。同时支持Wi-Fi和蓝牙等无线连接，使得设备能够与其他设备和网络无缝交互。
应用场景：
工业制造：HoloLens在工业制造中用于辅助装配和维修，通过叠加在现实设备上的虚拟说明和指示，提高操作效率和准确性。医疗领域：在手术中，HoloLens可以为外科医生提供患者的解剖信息和手术导航，帮助医生进行精确的操作。教育培训：HoloLens被用来创建沉浸式的学习环境，学生可以通过互动的全息图深入理解复杂的概念，如解剖学、工程学等。 2.2 Oculus Quest Oculus Quest是由Facebook（现Meta）推出的一款独立的VR头戴设备，提供高质量的沉浸式体验，无需连接到PC或外部传感器。
硬件特点：
独立运行：Oculus Quest配备了强大的移动处理器和内置存储，可以独立运行VR应用和游戏，用户无需连接到计算机或外部传感器。
Inside-Out追踪技术：Quest采用先进的Inside-Out追踪技术，通过设备内置的摄像头和传感器，能够实时跟踪用户的头部和手部动作，提供6自由度（6DoF）的空间追踪。
高分辨率显示：配备高分辨率OLED显示屏，提供清晰的视觉体验，减少画面模糊和屏幕门效应（screen-door effect）。
触觉反馈控制器：Quest的控制器设计精巧，能够提供精确的动作捕捉和逼真的触觉反馈，使用户在虚拟环境中的操作更加直观和沉浸。
应用场景：
家庭娱乐：Oculus Quest因其便携性和易用性，广泛应用于家庭娱乐，为用户提供丰富的VR游戏和多媒体体验。虚拟健身：Quest上有许多虚拟健身应用，用户可以在家中进行互动性强的运动，如虚拟现实中的拳击或舞蹈训练。社交互动：通过VR社交平台，如Facebook Horizon，用户可以在虚拟空间中与朋友互动、游戏和参加虚拟活动。 2.3 HTC Vive HTC Vive是HTC与Valve合作推出的一款高端VR头戴设备，以其卓越的沉浸式体验和精准的运动追踪著称，广泛应用于高端娱乐、设计和专业培训等领域。
硬件特点：
外部基站定位：Vive使用两个外部基站，通过激光扫描房间，提供高精度的6自由度运动追踪，用户可以在虚拟空间中自由移动。
高分辨率显示和宽视野：配备高分辨率的AMOLED显示屏和宽视野设计，提供出色的图像质量和沉浸感，减少运动模糊和画面失真。
高级运动控制器：Vive的控制器设计精良，支持多种手势和动作的精确捕捉，并配备触觉反馈功能，使用户在虚拟环境中的交互更自然和精确。
模块化设计：Vive提供多种可选配件和扩展模块，如无线适配器和追踪器，可以增强设备的功能和适应性，满足不同的应用需求。
应用场景：
高端游戏：Vive提供高质量的VR游戏体验，适合那些要求苛刻的游戏玩家，提供流畅的图形和实时交互。设计和可视化：在建筑和工业设计中，Vive被用来创建虚拟模型和可视化方案，帮助设计师更好地理解和展示他们的作品。专业培训：Vive用于各种专业培训场景，如模拟飞行、医疗手术培训和安全演练，提供安全和沉浸的学习环境。 作者其他作品： 【Java】Spring循环依赖：原因与解决方法
OpenAI Sora来了，视频生成领域的GPT-4时代来了
[Java·算法·简单] LeetCode 14. 最长公共前缀 详细解读
【Java】深入理解Java中的static关键字
[Java·算法·简单] LeetCode 28. 找出字a符串中第一个匹配项的下标 详细解读
了解 Java 中的 AtomicInteger 类
算法题 — 整数转二进制，查找其中1的数量
深入理解MySQL事务特性：保证数据完整性与一致性
Java企业应用软件系统架构演变史
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a24f39ff6639ca95860f07bffd1ec0ae/" rel="bookmark">
			探索未来AI的游乐场：OmniGibson平台深度剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		探索未来AI的游乐场：OmniGibson平台深度剖析 项目介绍 在人工智能的研究前沿，一个名为OmniGibson的平台正迅速崛起，它犹如一扇通往无限可能的大门，专为加速Embodied AI研究而设计。基于NVIDIA的Omniverse平台构建，OmniGibson以其独特的魅力，吸引了众多科研人员和开发者的眼球。它不仅仅是一个模拟环境，更是一片肥沃的土地，让AI系统能够“茁壮成长”，学习如何在真实世界中执行复杂任务。
项目技术分析 OmniGibson的核心在于其对细节的真实追求与技术支持：
极致视觉与物理真实性：利用照片级的渲染能力和精确的物理引擎，使得虚拟世界的体验几乎与现实无异。
多样化的对象与支持：不仅有静态物品，还包括流体与软体物理效果，如水流动、布料下垂，大大丰富了交互体验。
大规模场景构建：精心打造的高质量场景，涵盖广泛，每一处都细节满满，适合各种规模的任务训练。
动态对象状态：模拟物体的动态变化，包括温度、运动状态等，增加了模拟的真实性。
机器人与控制器的无缝整合：支持移动机械臂，配合可定制的控制模块，为AI提供了丰富的行动与交互能力。
兼容OpenAI Gym接口：便于研究人员快速上手，利用现有的算法进行实验。
应用场景 OmniGibson的应用潜力无限，它可以：
在机器人技术领域，帮助开发能理解并适应真实世界复杂性的智能机器人。于教育训练中，为学生提供安全的虚拟环境进行实践操作学习。助力于家庭服务机器人研发，让机器更好地理解和响应人类指令。在游戏开发中，创造更加沉浸式的游戏体验。提供给AI研究者一个逼真的测试场，用于验证AI模型在复杂环境中的表现。 项目特点 高保真模拟：无论是光照、纹理还是物理碰撞反馈，都能达到令人惊叹的真实度。高度可扩展性：随着版本更新，场景、物体以及功能不断增加，保持了平台的生命力。易用性：通过优化安装流程和提供详尽文档，即使是初学者也能快速入门。模块化设计：允许研究人员灵活选择和组合不同的组件，以适应不同研究需求。社区支持：活跃的Discord社区，确保用户能够获得及时的技术支持和交流。 加入OmniGibson的探索之旅，你将不仅仅是在使用一款软件，而是参与到了塑造未来人工智能技术的重要进程中。无论是希望挑战最新AI难题的研究人员，还是渴望创新的开发者，OmniGibson都是一个不可多得的强大工具。准备好了吗？让我们一起在OmniGibson的世界里解锁AI的新境界。🚀
# 推荐文章结束 请注意，以上内容是基于提供的信息构建的一个概述，旨在向潜在用户展示OmniGibson的吸引力和潜力。实际应用和详细技术参数应参考官方文档和最新的发布说明。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2126942bbcde4abb4ae0ece885c7f4dc/" rel="bookmark">
			【CentOS 7】挑战探索：在CentOS 7上实现Python 3.9的完美部署指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【CentOS 7】挑战探索：在CentOS 7上实现Python 3.9的完美部署指南 大家好 我是寸铁👊
总结了一篇【CentOS 7】挑战探索：在CentOS 7上实现Python 3.9的完美部署指南详细步骤✨
喜欢的小伙伴可以点点关注 💝
前言 此篇教程只适用于python3.9之前的，步骤一样，改一下版本号即可，不适用于3.10，笔者踩过很多坑，安装3.10的不要使用此篇教程，可以说是一个避雷贴，可以见笔者主页的另一篇安装教程，非常丝滑地安装！后面会发出来，敬请期待！
基础环境配置升级 sudo yum -y groupinstall “Development tools” sudo yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel sudo yum install -y libffi-devel zlib1g-dev sudo yum install zlib* -y 下载源码包 wget https://www.python.org/ftp/python/3.10.10/Python-3.10.10.tgz 解压进入 tar zxvf Python-3.10.10.tgz cd Python-3.10.10 编译安装 ./configure --prefix=/usr/local/python310 make sudo make install 出现warning是正常的，如果说出现pip3和python3绑定到到/usr/local/python3/bin/pip3路径。则进行软连接的编辑操作，操作如下：
ln -sf /usr/local/python3/bin/pip3 /usr/bin/pip3 ln -sf /usr/local/python3/bin/python3 /usr/bin/python3 配置环境变量 临时变量 下次开机，则需要重新配置变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2126942bbcde4abb4ae0ece885c7f4dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/934f7dbce789e30a9bda054f16d63cc1/" rel="bookmark">
			【Python】实现极致：克服PyInstaller打包挑战，解决libpython3.10.so.1.0库丢失难题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Python】实现极致：克服PyInstaller打包挑战，解决libpython3.10.so.1.0库丢失难题 大家好 我是寸铁👊
总结了一篇【Python】实现极致：克服PyInstaller打包挑战，解决libpython3.10.so.1.0库丢失难题✨
喜欢的小伙伴可以点点关注 💝
前言 相信大家在Centos7使用Pyinstaller打包会遇到Python library not found: libpython3.10.so.1.0问题，没关系，小问题，下面跟着寸铁一步步走下去就能解决。
具体如下：
pyInstaller ,exceptions.PythonLibraryNotFoundError: Python library not found: libpython3.10.so.1.8, libpython3 .10.so This means your Python installation does not come with proper shared library files. This usually happens due to missing development package, or unsuitable build parameters of the Python installat. 解决方案 按照python报错的提示进行重新编译
Step1 先进入到安装的Python的文件夹路径，用于后面的配置做准备
再看一下有无configure这个模块，如下则找到地方： Step2 接着，在这个路径下进行配置，命令如下： sudo ./configure --prefix=/usr/local/python3 --enable-shared --with-ssl 再进行重新编译 sudo make &amp;&amp; sudo make install 需要等待一段时间，安装完毕后显示如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/934f7dbce789e30a9bda054f16d63cc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c696454929b670decdfb7728fc55942/" rel="bookmark">
			【Redis】解决 Redis 运行在 Protected Mode 下的 DENIED 错误：消除 Redis 受保护模式的完美方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Redis】解决 Redis 运行在 Protected Mode 下的 DENIED 错误：消除 Redis 受保护模式的完美方案 大家好 我是寸铁👊
总结了一篇【Redis】解决 Redis 运行在 Protected Mode 下的 DENIED 错误：消除 Redis 受保护模式的完美方案✨
喜欢的小伙伴可以点点关注 💝
前言 今天在使用go程序远程连接redis客户端时
报错如下：Error getting value for key name: DENIED Redis is running in protected mode 这说明需要对redis执行某种魔法，使得可以远程连接到客户端，从而操作redis数据库。
下面笔者开始施展魔法，请跟着笔者一起挥动魔术棒！
具体报错如下：
Error getting value for key name: DENIED Redis is running in protected mode because protected mode is enabled and no password is set for the default user. In this mode connections are only accepted from the loopback
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c696454929b670decdfb7728fc55942/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/288/">«</a>
	<span class="pagination__item pagination__item--current">289/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/290/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>