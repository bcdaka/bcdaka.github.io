<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/453e78458e5037f190ca752251d3849b/" rel="bookmark">
			VMware清理拖拽缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		磁盘空间越用越小，如何快速解决磁盘空间的问题，甩掉烦恼
安装VM tools之后可以通过拖拽的方式把文件拉入虚拟机之中。但每一次拖拽，其实都是现在cache文件夹里面生成一个同样的文件，并使用cp拷贝的方式将其拷贝到拖拽放置的目录中。
因此，如果不进行清理的话，cache文件夹中产生的文件，并不会自动删除或者释放。
进入文件夹，可以见到每一次拖拽产生的文件，都在子文件夹中有一份。
直接删除便可以腾出空间。
cd /home/xxxx/.cache/vmware/drag_and_drop/
rm ./* -rf
此外： 在使用ubuntu过程中，可能会发现自己的硬盘空间不足，所以需要对硬盘占用情况进行分析，来调整或删除自己的硬盘文件。方法很简单，使用ubuntu 自带的硬盘占用分析软件 Disk Usage Analyzer （中文名: 磁盘使用情况分析器）就可以。
在ubuntu搜索框直接搜索 Disk Usage Analyzer 打开软件之后可以进行对磁盘进行分析，查看具体位置的文件，自己进行清理操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29049736ee89b0e2b23a63a0e2e79d43/" rel="bookmark">
			嵌入式硬件VS软件，到底哪个更难？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在嵌入式系统开发中，硬件和软件是密不可分的两个方面。但是，究竟是硬件开发更具挑战性，还是软件开发更难以应对呢？本文将就这一问题展开讨论，探究嵌入式硬件和软件在开发过程中的各种挑战与特点。
一、硬件开发：挑战与精密
嵌入式硬件开发涉及到电路设计、电子元器件选型、PCB设计等诸多方面。在这个过程中，工程师需要具备扎实的电子知识和丰富的实践经验。硬件开发过程中经常会面临的挑战包括：
复杂性：硬件设计往往涉及到复杂的电路结构和信号传输，需要工程师具备深厚的理论知识和良好的分析能力。
精度要求：嵌入式系统往往需要高度精密的硬件设计，对于电路的稳定性、功耗控制、时序要求等方面都有严格的要求。
成本控制：在硬件开发过程中，成本也是一个重要考量因素。工程师需要在保证性能和功能的前提下，尽可能降低成本，提高产品的竞争力。
二、软件开发：复杂性与灵活性
与硬件相比，嵌入式软件开发的难点在于复杂性和灵活性。嵌入式软件开发涉及到操作系统的选择、驱动程序的编写、应用程序的开发等多个层面。软件开发过程中常见的挑战包括：
系统稳定性：嵌入式系统要求高度稳定，对软件的稳定性有着严格的要求。工程师需要充分考虑各种异常情况和错误处理机制，确保系统能够正常运行。
性能优化：嵌入式系统通常具有资源有限的特点，因此性能优化成为软件开发过程中的重要任务。工程师需要精简代码、优化算法，以提高系统的运行效率和响应速度。
软件集成：嵌入式系统通常由多个软件模块组成，工程师需要将这些模块进行有效地集成，确保各个模块之间的正常通信和协作。
三、硬件与软件的协同
在实际的嵌入式系统开发过程中，硬件和软件往往是相辅相成的。硬件提供了系统的基础功能和性能支撑，而软件则赋予了系统更多的灵活性和智能化。因此，硬件和软件之间的协同工作至关重要。工程师需要密切合作，不断优化硬件和软件之间的接口和通信方式，以实现系统的最佳性能和稳定性。
总的来说，无论是硬件开发还是软件开发，在嵌入式系统中都面临着各种各样的挑战。硬件开发注重精密和稳定性，软件开发强调灵活性和性能优化。然而，在实际的工作中，硬件和软件往往是相互依存、相互促进的。只有工程师们紧密合作，充分发挥各自的优势，才能够顺利完成嵌入式系统的开发，为社会带来更多的创新和进步。
如有侵权，联系删除
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43bf7f421cb974c322a7f3fd146976fc/" rel="bookmark">
			使用pnpm创建vue3项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 https://pnpm.io/zh/
全局安装：
npm install -g pnpm
检查版本：
pnpm -v
创建vue3项目：
pnpm create vue@latest
项目装包：
pnpm install
运行项目：
pnpm dev
命令行：
https://pnpm.io/zh/pnpm-cli
pnpm install
pnpm add &lt;pkg&gt;
pnpm &lt;cmd&gt;
store目录
pnpm为了解决npm3带来的一些问题呢，采用了另外一种方式来管理依赖：pnpm 的 node_modules 布局使用符号链接来创建依赖项的嵌套结构管。
node_modules 中.pnpm下每个包的每个文件都是来自内容可寻址存储的硬链接。
人工智能学习网站
https://chat.xutongbao.top
参考链接：
https://www.jb51.net/javascript/306928jnd.htm
https://www.cnblogs.com/goloving/p/16206624.html
https://juejin.cn/post/7114117329687937032 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07924692f5c25d77ddc61d9cb93bd6fd/" rel="bookmark">
			Rabbit MQ和Kafka的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RabbitMQ和Kafka是两种流行的消息队列系统，但它们设计理念、架构和使用场景有所不同。了解它们的区别可以帮助我们在不同的应用场景中做出更合适的选择。以下是RabbitMQ和Kafka在多个维度上的对比：
1. 设计理念和目标 RabbitMQ 消息传递（Message Queue）: RabbitMQ的核心设计是作为消息中间件，专注于消息的可靠传递和复杂的路由。
消息路由: 提供丰富的消息路由功能，通过交换器（Exchange）将消息路由到队列，可以根据不同的规则进行消息的过滤和分发。
可靠性: 支持消息的持久化、确认机制和重试机制，以确保消息不会丢失。
Kafka 事件流处理（Event Streaming）: Kafka被设计为一个高吞吐量的分布式流处理平台，适用于实时数据流处理。
日志系统（Log-Based Storage）: 以日志文件的形式存储消息，消息持久化能力强，每个消息都有唯一的偏移量（Offset），消费者可以任意回溯读取消息。
高吞吐量和可扩展性: Kafka设计的核心是支持高吞吐量和大规模数据流处理，能够处理每秒百万级别的消息。
2. 架构和组件 RabbitMQ Broker: 主要组件是Broker，负责接收、存储和转发消息。
Exchange: 消息进入RabbitMQ后先到达Exchange，Exchange根据规则将消息路由到一个或多个队列。
Queue: 存储实际的消息，消费者从队列中消费消息。
Binding: 将Exchange和Queue进行绑定，定义消息路由的规则。
Kafka Broker: Kafka集群中包含多个Broker，负责存储和管理消息日志。
Topic: 消息按照主题（Topic）进行分类，每个Topic有多个分区（Partition），消息以顺序追加的方式写入分区。
Partition: 每个Topic分成多个Partition，提供水平扩展和并行处理能力。
Consumer Group: 消费者以组的形式读取消息，每个消费者组可以独立地读取消息数据。
Zookeeper/Metadata Management: Kafka使用Zookeeper进行集群管理和元数据存储，Kafka 2.8.0开始支持无Zookeeper的元数据管理。
3. 消息模型 RabbitMQ 消息模型: 典型的生产者-消费者模型，支持点对点（P2P）和发布/订阅（Pub/Sub）模式。
路由机制: 通过Exchange实现复杂的消息路由，包括直接（Direct）、主题（Topic）、广播（Fanout）、和标题（Headers）等不同类型的路由。
Kafka 消息模型: 主要基于发布/订阅（Pub/Sub）模式，适合高吞吐量的流式数据处理。
日志模型: 消息以日志记录的形式存储，消费者可以指定任意偏移量（Offset）来读取消息，可以实现消息的重复读取和回溯。
4. 持久化和可靠性 RabbitMQ 消息持久化: 支持将消息持久化到磁盘，消息持久化需要显式配置，重启后可以恢复消息。
消息确认: 支持消息确认机制，消费者需要显式确认消息处理成功，未确认的消息可以重试。
高可用性: 通过镜像队列（Mirrored Queue）实现消息的高可用性，消息在多个节点上进行复制。
Kafka 消息持久化: 所有消息都持久化到磁盘，并且默认情况下消息会保留一段时间（日志保留时间），可以配置为长期保留或按需清理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07924692f5c25d77ddc61d9cb93bd6fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4487214334f559a9b0ca3cce102be813/" rel="bookmark">
			uniapp条件编辑语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uniapp中的“条件编译”：#ifdef详细解释_uniapp #ifdef-CSDN博客
uniapp 多端兼容 #ifdef #ifndef #endif 和 平台标识 - 简书
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c03a965e319ce632bddbf404a613cc66/" rel="bookmark">
			Web 播放 RTSP(Webrtc方案)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Web 播放 RTSP(Webrtc方案) 需求背景 项目需要在 web 上播放海康摄像头，这个在各种智慧类应用上应该是常见需求，在前几年的时候也有这个需求，那时候通过旧版本谷歌浏览器可以直接播放 rtmp 解决了问题；现在谷歌浏览器已经不再支持，项目上又有这个需求，打算好好处理下。大概需求内容项目有多个车，每个车有多个摄像头，web对这些摄像头进行管理呈现。
Web 播放视频流方案 web 播放视频流有多种方案有 HLS、flv、webrtc 等等，我们这里选用 webrtc 方案，webrtc 播放视频是网页原生支持的音视频通信技术，对比其他其他方案有低时延等优点
Webrtc 实践 海康摄像头推送 rtsp 流，web 播放 webrtc，搜索 rtsp 转 webrtc 发现开源项目 https://github.com/deepch/RTSPtoWebRTC，golang 编写，参照项目说明，项目跑起来很简单，代码仓库拉下来运行就行了，RTSPtoWebRTC 项目自带 http 代理了简单 web 页面
按照项目说明将 config 修改为本地海康摄像头地址，重新运行验证，摄像头就播放出来了
自身项目为前后端分离，开始迁移该项目的 webrtc 代码到自己的项目中，编写一个 Webrtc 组件
export function WebRtcPlayer(props: { suuid: string, url: string }) { let ref = useRef&lt;HTMLVideoElement&gt;(); useEffect(() =&gt; { let { suuid, url } = props; let stream = new MediaStream(); const pc = new RTCPeerConnection(); pc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c03a965e319ce632bddbf404a613cc66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29299034f1454248a7f418a7b472a6c4/" rel="bookmark">
			浅谈配置元件之HTTP请求默认值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浅谈配置元件之HTTP请求默认值 在进行HTTP请求的测试计划设计时，"HTTP请求默认值"配置元件扮演着极其重要的角色，它能够简化测试计划的设置，提高测试效率。本问将详细介绍如何使用JMeter中的“HTTP请求默认值”配置元件。
HTTP请求默认值一般和HTTP请求配套使用
1. 什么是HTTP请求默认值？ “HTTP请求默认值”是JMeter中的一种配置元件。顾名思义，它为测试计划中所有（或指定范围内的）HTTP请求提供一组默认的配置参数。这意味着，一旦你在一个“HTTP请求默认值”元件中设置了如服务器名称、端口号、协议等信息，所有继承这些设置的HTTP请求将自动应用这些默认值，除非它们被单独明确地覆盖。
2. 为什么使用HTTP请求默认值？ ● 简化配置：避免在每个HTTP请求中重复输入相同的服务器信息、端口等参数。
● 易于维护：当基础URL或认证信息发生变化时，只需修改“HTTP请求默认值”，无需逐个调整每个请求。
● 提高效率：减少配置错误，加速测试计划的创建和调整过程。
3. 如何添加HTTP请求默认值？ 打开JMeter，创建一个新的测试计划或者打开现有的测试计划。右键点击测试计划、线程组或其他合适的容器（如取样器），选择“添加” -&gt; “配置元件” -&gt; “HTTP请求默认值”。配置元件将会出现在所选容器下，此时可以开始设置默认参数。 4. 主要配置参数说明 基本设置 ● 协议：默认的通信协议，通常是http或https。
● 服务器名称或IP：默认的服务器地址，所有使用此默认值的HTTP请求将指向该地址。
● 端口号：默认的端口号，例如80或443。
● 内容编码：指定发送请求时的内容编码方式，如UTF-8。
高级设置 一般不进行设置
5. 实例说明 第一步：首先编写一段SpringBoot为框架编写后端代码，主要详细代码如下：
@PostMapping(value = "/login",produces = "application/json;charset=UTF-8") public String authenticate(@RequestBody JSONObject request) { String validUsername = "admin"; String validPassword = "password"; if (request.getString("username").equals(validUsername) &amp;&amp; request.getString("password").equals(validPassword)) { return "认证成功"; } else { return "认证失败"; } } 接口：/login
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29299034f1454248a7f418a7b472a6c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf6973bc65d06903737371a685826bb8/" rel="bookmark">
			从0到1搭建MCU芯片上操作系统环境。开发都需要哪些环节和准备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MCU芯片环境搭建与操作系统上载步骤 1. 硬件准备 选择合适的MCU芯片，例如STM32、GD32等。
准备开发板，用于硬件连接和实验。
准备必要的外围设备，如电源适配器、USB转串口模块等。 2. 软件环境搭建 安装编程语言环境，如C/C++编译器。 安装交叉编译工具链，用于将源代码编译成目标MCU可以执行的机器代码。 安装调试工具，如JTAG仿真器或SWD调试器。 3. 开发环境配置 配置集成开发环境（IDE），如Keil、IAR、Eclipse等，以便编写和调试代码。 配置交叉编译工具链的路径，确保IDE可以找到正确的编译器和链接器。 4. 编写启动代码 编写Bootloader，即启动代码，用于初始化MCU硬件和加载操作系统。
编写应用程序代码，实现特定的功能。
5. 烧录和调试 使用编程器或烧录工具将Bootloader和应用程序代码烧录到MCU芯片。
使用调试工具进行代码调试，确保程序正确无误。
6. 系统上载 如果使用操作系统，如RT-Thread，需要准备操作系统镜像文件。
使用Bootloader将操作系统镜像加载到MCU芯片的指定位置。
7. 系统运行和测试 重启MCU，操作系统应该自动启动。
测试系统功能，确保一切按预期工作。
8. 优化和维护 根据测试结果对系统进行优化，提高性能和稳定性。
定期更新系统，修复发现的问题。
以上步骤是从0到1开发MCU芯片环境和上载操作系统的大致流程。具体细节可能会根据不同的MCU型号和开发环境有所差异。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/358d0db83fc9d3b143f353d170bbd3e7/" rel="bookmark">
			Python跳动的爱心（双爱心版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
系列文章
前言
Turtle简介
Python跳动的爱心
尾声
系列文章 序号文章目录直达链接表白系列1无法拒绝的表白界面https://want595.blog.csdn.net/article/details/1347448942满屏飘字表白代码https://want595.blog.csdn.net/article/details/1350373883无限弹窗表白代码https://want595.blog.csdn.net/article/details/1347447114李峋同款可写字版跳动的爱心https://want595.blog.csdn.net/article/details/1347441915流星雨https://want595.blog.csdn.net/article/details/1347474086漂浮爱心https://want595.blog.csdn.net/article/details/1347449297爱心光波https://want595.blog.csdn.net/article/details/1347473658玫瑰花https://want595.blog.csdn.net/article/details/134747447节日系列1新春/跨年烟花秀(2022)https://want595.blog.csdn.net/article/details/128727394烟花秀(2023)https://want595.blog.csdn.net/article/details/135042880粒子烟花https://want595.blog.csdn.net/article/details/1360294202圣诞节圣诞礼物https://want595.blog.csdn.net/article/details/135336583圣诞树(2022)https://want595.blog.csdn.net/article/details/128428985绿色圣诞树(2023)https://want595.blog.csdn.net/article/details/135048607粉色圣诞树(2023)https://want595.blog.csdn.net/article/details/1350430423冬至大雪纷飞https://want595.blog.csdn.net/article/details/1288060174生日生日蛋糕https://want595.blog.csdn.net/article/details/1287397555儿童节五彩气球https://want595.blog.csdn.net/article/details/1287410436国庆节国庆祝福https://want595.blog.csdn.net/article/details/1287409237万圣节万圣礼物https://want595.blog.csdn.net/article/details/1287343958愚人节愚人代码https://want595.blog.csdn.net/article/details/1286969909中秋节浪漫星空https://want595.blog.csdn.net/article/details/12873728410植树节樱花树https://want595.blog.csdn.net/article/details/128700178动漫系列1名侦探柯南系列柯南https://want595.blog.csdn.net/article/details/1347776132喜羊羊与灰太狼系列喜羊羊https://want595.blog.csdn.net/article/details/134778583懒羊羊https://want595.blog.csdn.net/article/details/134847642灰太狼https://want595.blog.csdn.net/article/details/135335303小灰灰https://want595.blog.csdn.net/article/details/135335445小香香https://want595.blog.csdn.net/article/details/1350567833海绵宝宝系列海绵宝宝https://want595.blog.csdn.net/article/details/1348473644哆啦A梦系列哆啦A梦https://want595.blog.csdn.net/article/details/1350378845HelloKitty系列hellokittyhttps://want595.blog.csdn.net/article/details/1353377326Tom&amp;Jerry系列Tom&amp;Jerryhttps://want595.blog.csdn.net/article/details/1353377757草莓熊系列草莓熊https://want595.blog.csdn.net/article/details/1353378328皮卡丘系列迷你皮卡丘https://want595.blog.csdn.net/article/details/135337911高级皮卡丘https://want595.blog.csdn.net/article/details/135337937豪华皮卡丘https://want595.blog.csdn.net/article/details/1353379479猪猪侠系列猪猪侠https://want595.blog.csdn.net/article/details/13634011110超级英雄系列蜘蛛侠https://want595.blog.csdn.net/article/details/129080659炫酷系列1 一闪一闪亮星星系列张万森下雪了https://want595.blog.csdn.net/article/details/135336915一闪一闪亮星星https://want595.blog.csdn.net/article/details/1353370492代码雨https://want595.blog.csdn.net/article/details/1350543413七彩花朵https://want595.blog.csdn.net/article/details/13505667043D星空https://want595.blog.csdn.net/article/details/1350565165金榜题名https://want595.blog.csdn.net/article/details/1350561506满天星https://want595.blog.csdn.net/article/details/135056305…… 前言 今天博主给大家带来了有趣的跳动的爱心（双心版），一起来看看吧！
Turtle简介 Turtle 是 Python 标准库中的一个模块，用于绘制简单的图形和创建基本的图形用户界面。它借用了 Logo 编程语言中的概念，通过控制一个“海龟”在屏幕上的移动来绘制图形。这个模块非常适合初学者学习编程，因为它提供了一个直观且有趣的方式来理解基本的编程概念，如循环、函数和事件处理。
Turtle 的基本概念 Turtle 模块中的“海龟”其实是一个小箭头，它可以在屏幕上移动，并根据指令绘制路径。以下是一些基本的命令：
`forward(distance)`：让海龟向前移动指定距离。 `backward(distance)`：让海龟向后移动指定距离。 `right(angle)`：让海龟向右转动指定角度。 `left(angle)`：让海龟向左转动指定角度。 `penup()` 和 `pendown()`：抬起或放下笔，抬起笔时移动不会绘制线条。 简单示例 以下是一个使用 Turtle 模块绘制正方形的简单示例：
import turtle # 创建一个屏幕对象 wn = turtle.Screen() wn.title("Turtle 示例") # 创建一个海龟对象 t = turtle.Turtle() # 绘制正方形 for _ in range(4): t.forward(100) t.right(90) # 完成绘图 wn.mainloop() 这个示例代码展示了如何创建一个窗口和一个海龟对象，然后使用循环指令绘制一个正方形。`wn.mainloop()` 用于保持窗口打开状态，以便查看绘制结果。
高级功能 除了基本的移动和绘图命令，Turtle 模块还支持更高级的功能，如：
**颜色和填充**：使用 `color()` 设置绘图颜色，使用 `begin_fill()` 和 `end_fill()` 创建填充图形。**形状**：海龟的形状可以更改为箭头、圆形、正方形等，使用 `shape()` 方法。**速度**：通过 `speed()` 方法控制海龟的移动速度。**事件处理**：Turtle 支持事件处理，如键盘和鼠标事件，可以使用 `onscreenclick()` 和 `onkey()` 方法进行绑定。 应用场景 Turtle 模块广泛应用于教育领域，尤其是编程入门和算法教学。它通过图形化的方式帮助学生理解抽象的编程概念，同时增加了学习的趣味性。此外，Turtle 也可以用于简单的图形设计和数据可视化，尽管功能较为基础，但它为进一步学习更复杂的图形编程打下了良好的基础。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/358d0db83fc9d3b143f353d170bbd3e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3492898b096dac0f27295982fb53f16f/" rel="bookmark">
			【Kafka】SpringBoot整合Kafka详细介绍及代码示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kafka介绍 Apache Kafka是一个分布式流处理平台。它最初由LinkedIn开发，后来成为Apache软件基金会的一部分，并在开源社区中得到了广泛应用。Kafka的核心概念包括Producer、Consumer、Broker、Topic、Partition和Offset。
Producer：生产者，负责将数据发送到Kafka集群。Consumer：消费者，从Kafka集群中读取数据。Broker：Kafka服务器实例，Kafka集群通常由多个Broker组成。Topic：主题，数据按主题进行分类。Partition：分区，每个主题可以有多个分区，用于实现并行处理和提高吞吐量。Offset：偏移量，每个消息在其分区中的唯一标识。 使用场景 Kafka适用于以下场景：
日志收集：集中收集系统日志和应用日志，通过Kafka传输到大数据处理系统。消息队列：作为高吞吐量、低延迟的消息队列系统。数据流处理：实时处理数据流，用于实时分析、监控和处理。事件源架构：将所有的变更事件存储在Kafka中，实现事件溯源和回放。流数据管道：构建数据管道，连接数据源和数据存储系统。 Spring Boot整合Kafka 项目结构 springboot-kafka │ ├── src │ ├── main │ │ ├── java │ │ │ └── com.example.kafka │ │ │ ├── KafkaApplication.java │ │ │ ├── config │ │ │ │ └── KafkaConfig.java │ │ │ ├── producer │ │ │ │ └── KafkaProducer.java │ │ │ ├── consumer │ │ │ │ └── KafkaConsumer.java │ │ │ └── controller │ │ │ └── KafkaController.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3492898b096dac0f27295982fb53f16f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5acadc69904ae0f88273f3b42769c56f/" rel="bookmark">
			aspose-words去水印自用资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方文档https://docs.aspose.com/words/java/convert-a-document-to-pdf/
声明：限个人学习使用，商用后果与本人无关。
1.引入依赖 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.aspose&lt;/groupId&gt; &lt;artifactId&gt;aspose-words&lt;/artifactId&gt; &lt;version&gt;18.6&lt;/version&gt; &lt;classifier&gt;jdk16&lt;/classifier&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;aspose-maven-repository&lt;/id&gt; &lt;url&gt;https://artifact.aspose.com/repo/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; 2.下载依赖后去依赖仓库位置删掉从官方源下载的版本 仓库路径/com/aspose/aspose-words/18.6
删除路径中aspose-words-18.6-jdk16.jar文件，使用我的资源文件替换
3.添加license.xml文件到src/main/resources目录下 &lt;License&gt; &lt;Data&gt; &lt;Products&gt; &lt;Product&gt;Aspose.Total for Java&lt;/Product&gt; &lt;Product&gt;Aspose.Words for Java&lt;/Product&gt; &lt;/Products&gt; &lt;EditionType&gt;Enterprise&lt;/EditionType&gt; &lt;SubscriptionExpiry&gt;20991231&lt;/SubscriptionExpiry&gt; &lt;LicenseExpiry&gt;20991231&lt;/LicenseExpiry&gt; &lt;SerialNumber&gt;8bfe198c-7f0c-4ef8-8ff0-acc3237bf0d7&lt;/SerialNumber&gt; &lt;/Data&gt; &lt;Signature&gt; sNLLKGMUdF0r8O1kKilWAGdgfs2BvJb/2Xp8p5iuDVfZXmhppo+d0Ran1P9TKdjV4ABwAgKXxJ3jcQTqE/2IRfqwnPf8itN8aFZlV3TJPYeD3yWE7IT55Gz6EijUpC7aKeoohTb4w2fpox58wWoF3SNp6sK6jDfiAUGEHYJ9pjU= &lt;/Signature&gt; &lt;/License&gt; 4.添加工具类代码 @Slf4j public class MatchLicense { public static void init() { try { log.info("实现aspose-words授权 -&gt; 去掉头部水印"); /* 实现匹配文件授权 -&gt; 去掉头部水印 `Evaluation Only. Created with Aspose.Words. Copyright 2003-2018 Aspose Pty Ltd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5acadc69904ae0f88273f3b42769c56f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/054d1a8b5811f0b02dcf89e351bcc6a9/" rel="bookmark">
			虚拟化 之一 详解 jailhouse 架构及原理、软硬件要求、源码文件、基本组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jailhouse 是一个基于 Linux 实现的针对创建工业级应用程序的小型 Hypervisor，是由西门子公司的 Jan Kiszka 于 2013 年开发的，并得到了官方 Linux 内核的支持，在开源社区中获得了知名度和吸引力。
Jailhouse Jailhouse 是一种轻量级的虚拟化技术，可以将多个操作系统（或者裸机程序）同时运行在同一台硬件上。它是一个基于 Linux 的静态分区的 Hypervisor，但本身并不改造 Linux 内核，而是利用 Linux 系统的开放性，增加一个或多个实时操作系统，实现多系统在一个多核处理器上运行。
Jailhouse 不会模拟不存在的硬件资源，也不包含任何的调度处理，而是利用虚拟化技术将硬件资源划分为多个被称为 Cell 的独立空间，并将每个 Cell 分配给不同的虚拟机。每个 Cell 独占自己的处理器核心、内存、I/O 设备和中断控制器等资源。这样可以确保不同虚拟机之间的资源互相隔离，提高系统的可靠性。
Root Cell 当 Jailhouse 启动之后，原来的负责启动 Jailhouse 的 Linux 系统所在空间就被称为 Root Cell。对于所有 Jailhouse 虚拟机的管理都是在 Root Cell 中的 Linux 系统中通过 Jailhouse 提供的命令行工具来实现的。
Non-root Cell 除了 Root Cell 之外的每个独立的 Cell 就是一个 Non-root Cell，每个 Non-root Cell 就对应一个虚拟机。Non-root Cell 通过 Root Cell 进行管理，只要资源够用，Non-root Cell 可以有任意多个。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/054d1a8b5811f0b02dcf89e351bcc6a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd957d9aa17941067e82931a66f4dad1/" rel="bookmark">
			快手「可灵」爆火：海外AI圈巨震，中国版Sora一号难求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		短短一年后，AI 生成的「吃面条」已经如此自然流畅？这让全球网友都感受到了亿点点震撼。
*图源：https://x.com/CharaspowerAI/status/1799494388462063632
*
右侧的这些生成视频，都来自快手刚刚推出的文生视频大模型「可灵」（Kling）。
不是预发布、不是纯 Demo 合集，而是直接开放测试的产品级应用，人人都能申请。而且，可灵支持生成最长 2 分钟、30fps 的 1080P 视频，主打从头脑风暴到可发布作品的「一键转化」。（官网地址：https://kling.kuaishou.com/）
最早一批用上的用户已经「真香」：
图源：https://x.com/op7418/status/1799047146089619589
图源：https://weibo.com/7714861068/Oig1Qm8Or?refer_flag=1001030103_
500 人上限的交流群，很快就满员了，满屏都是 tql：
还没用上的外国友人只能干着急，在社交媒体发「求求了」：
不夸张地说，可灵现在是「一号难求」：
消息传到硅谷创投圈，更是引发了一场热议。
Stability AI 前 CEO Emad Mostaque 表示：「中国的 AI 技术有自己的优势。」
图源：https://x.com/EMostaque/status/1799133463003684918
YC CEO 也在 X 平台转发了可灵生成的 Demo：
就图中这个「吃汉堡」的案例而言，在相同的提示词下，可灵的生成效果确实比 Sora 更生动、真实：
Prompt：Une personne tapant son meilleur croc dans son hamburger
视频地址：https://x.com/AngryTomtweets/status/1799787209651859910
对于关注 AI 的人来说，这几天一定陆陆续续看过很多可灵生成的作品了。机器之心也是第一时间就点进了申请通道，并拿到了试用资格。
接下来，我们不妨一边试用、一边分析可灵爆火的原因。
国内首个文生视频产品级应用
或许你还记得这个曾经非常火爆的「气球人」视频。三位创作者花费近两周时间，使用 Sora 制作了这条 1 分 21 秒的视频短片，让人感到十分惊艳。不过，负责后期制作的 Patrick Cederberg 坦白了过程中的很多问题，例如气球的颜色在每次生成中都会改变、镜头中会出现一些瑕疵等等。
Sora 生成结果。完整视频地址：https://youtu.be/9oryIMNVtto?si=F6oDzvrhzfVcQGeh
对于此前的视频生成模型来说，「一气呵成」生成 1 分钟以上的内容确实有难度，特别是要求画面中的各种元素保持前后一致。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd957d9aa17941067e82931a66f4dad1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6806aabf5ec92a9cae482756ba825f9c/" rel="bookmark">
			【数据结构】第十五弹---C语言实现直接插入排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨个人主页： 熬夜学编程的小林
💗系列专栏： 【C语言详解】 【数据结构详解】【C++详解】
目录
1、排序的概念及其运用
1.1、排序的概念与分类
1.2、排序运用
1.3、常见的排序算法
1.4、常见的排序算法性能测试
2、常见排序算法的实现
2.1、直接插入排序
2.1.1、基本思想
2.1.2、代码实现
2.1.3、代码测试
2.1.4、时空复杂度分析
总结
1、排序的概念及其运用 1.1、排序的概念与分类 排序：
排序是一种将一组对象按照某种特定顺序重新排列的过程。在计算机科学中，排序是数据处理中非常基本且重要的操作，它可以帮助人们更有效地理解和分析数据。排序的顺序通常是升序或降序，也可以按照数字、字母、大小或其他标准进行排序。
稳定性：
假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i] == r[j]，且 r[i] 在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。
内部排序：
数据元素全部放在内存中的排序。
外部排序：
数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。
1.2、排序运用 排序的运用非常常见，在我们购物的软件上面，经常会根据不同的属性来进行排序，我们以前上学时候的成绩通常也会对各科进行排序！！！！
1.3、常见的排序算法 常见的排序算法有冒泡排序、选择排序、插入排序、快速排序、希尔排序、堆排序、归并排序等等！！！
注意：在本专栏中，还会讲解计数排序，它的效率非常高，但是局限性也很大。 如下为常见排序实现的接口：
// 排序实现的接口 // 插入排序 void InsertSort(int* a, int n); // 希尔排序 void ShellSort(int* a, int n); // 选择排序 void SelectSort(int* a, int n); // 向下调整算法 void AdjustDwon(int* a, int n, int root); // 堆排序 void HeapSort(int* a, int n); // 冒泡排序 void BubbleSort(int* a, int n) // 快速排序递归实现 // 快速排序hoare版本 int PartSort1(int* a, int left, int right); // 快速排序挖坑法 int PartSort2(int* a, int left, int right); // 快速排序前后指针法 int PartSort3(int* a, int left, int right); void QuickSort(int* a, int left, int right); // 快速排序 非递归实现 void QuickSortNonR(int* a, int left, int right) // 归并排序递归实现 void MergeSort(int* a, int n) // 归并排序非递归实现 void MergeSortNonR(int* a, int n) // 计数排序 void CountSort(int* a, int n) 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6806aabf5ec92a9cae482756ba825f9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79a50e655c390f4aee1f8fc7af8dc96d/" rel="bookmark">
			阿里最强开源大模型本地部署、API调用和WebUI对话机器人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里巴巴通义千问团队发布了Qwen2系列开源模型，该系列模型包括5个尺寸的预训练和指令微调模型：Qwen2-0.5B、Qwen2-1.5B、Qwen2-7B、Qwen2-57B-A14B以及Qwen2-72B。对比当前最优的开源模型，Qwen2-72B在包括自然语言理解、知识、代码、数学及多语言等多项能力上均显著超越当前领先的Llama3-70B等大模型。
老牛同学今天部署和体验Qwen2-7B-Instruct指令微调的中等尺寸模型，相比近期推出同等规模的开源最好的Llama3-8B、GLM4-9B等模型，Qwen2-7B-Instruct依然能在多个评测上取得显著的优势，尤其是代码及中文理解上。
特别注意： 虽然Qwen2开源了，但仍然需要遵循其模型许可，除Qwen2-72B依旧使用此前的Qianwen License外，其余系列版本模型，包括Qwen2-0.5B、Qwen2-1.5B、Qwen2-7B以及Qwen2-57B-A14B等在内，均采用Apache 2.0许可协议。
下载Qwen2-7B-instruct模型文件 为了简化模型的部署过程，我们直接下载GGUF文件。
我们可以根据自己需要，选择下载其它版本的模型文件！
启动Qwen2-7B-Instruct大模型 GGUF模型量化文件下载完成后，我们就可以来运行Qwen2-7B大模型了。
在启动Qwen2-7B大模型之前，我们首先需要安装Python依赖包列表：
pip install llama-cpp-python pip install openai pip install uvicorn pip install starlette pip install fastapi pip install sse_starlette pip install starlette_context pip install pydantic_settings 然后打开一个Terminal终端窗口，切换到GGUF模型文件目录，启动Qwen2-7B大模型（./qwen2-7b-instruct-q5_k_m.gguf即为上一步下载的模型文件路径）：
# 启动Qwen2大模型 # n_ctx=20480代表单次回话最大20480个Token数量 python -m llama_cpp.server \ --host 0.0.0.0 \ --model ./qwen2-7b-instruct-q5_k_m.gguf \ --n_ctx 20480 Qwen2-7B-instruct 命令行对话客户端 # client.py from openai import OpenAI # 注意服务端端口，因为是本地，所以不需要api_key client = OpenAI(base_url="http://127.0.0.1:8000/v1", api_key="not-needed") # 对话历史：设定系统角色是一个只能助理，同时提交“自我介绍”问题 history = [ {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79a50e655c390f4aee1f8fc7af8dc96d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f393a890035d3ef59c2d1d33ee17bac/" rel="bookmark">
			关于Mysql 中 Row size too large (＞ 8126) 错误的解决和理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：啰嗦一嘴 ，数据库的任何操作和验证前，一定要记得先备份！！！不会有错；
文章目录 问题发现一、问题导致的可能原因1、页大小2、行格式2.1 compact格式2.2 Redundant格式2.3 Dynamic格式2.4 Compressed格式 3、BLOB和TEXT列 二、解决办法1、修改页大小（不推荐）2、修改行格式3、修改数据类型为BLOB和TEXT列4、其他优化方式（可以参考使用）4.1 合理设置数据类型大小4.2 合理进行表结构设计4.3 更换存储引擎 问题发现 今天在导入他人项目中的sql数据库文件时，出现一个mysql的错误提示，大致描述是：
Row size too large (&gt; 8126)，英文不算好的我看字面意思，估摸着大概就是说我们插入的行数据可能太大了，超过了设定的阙值；
一、问题导致的可能原因 这个限制主要是因为MySQL内部存储机制的约束，MySQL的InnoDB存储引擎有一个最大行大小限制关于mysql引擎内容比较多，以后再专门写一篇内容好好说说；这里我们只需要知道他是目前mysql 默认的存储引擎就好啦；
而这个最大行大小限制主要由于几个因素影响：
1、页大小 页是InnoDB管理数据的最小单位，InnoDB使用16KB的页来存储数据，行数据在进行保存插入的时候，要求我们的单行数据不能跨越多于半个页（8KB）。否则数据库会自动按照是否进行溢出页的机制来处理数据；
简单说的话，其实就是数据库中的每行数据我们可以看作是一所个人专属的小房子，里面预留了一个固定的空间给他们放东西，如果放入的东西太多了，超过这个空间大小，屋主就会考虑是否可以把东西放在屋外，来保障空间不至于太过拥挤，这里的房间内的空间就是页内空间大小，房外就是多出的
2、行格式 InnoDB支持几种行格式，如compact、redundant、dynamic和compressed。其中，dynamic和compressed格式是为了解决行大小限制而引入的，允许行中的某些列（如BLOB和TEXT类型）存储在页外。
这点简单的来说，四种行格式可以看作是房屋管理办法四个准则，每个准则都有各自适用的场景和优点；
关于行格式，我们这里只需要知道有哪几种，以及他们数据存储方式，各自应用场景即可；
2.1 compact格式 InnoDB的默认行格式，也是最常用常见的格式；采取的是位图压缩的存储方式；适用于大多数OLTP（在线事务处理应用场景。OLTP其实就是指那种较高并发，并且要求低延迟，专注业务操作的应用，类似银行交易、订单处理、库存更新那些情况比较常用；
2.2 Redundant格式 MySQL 5.0以前的默认行格式；适用具有大量NULL值的表；
2.3 Dynamic格式 从 MySQL 5.6.3 开始，默认的行格式是 DYNAMIC，Dynamic行格式具有高度的灵活性，可以动态地调整行的大小和存储方式。基于实际数据长度大小来进行调整存储空间，以节省存储空间；适用于包含大量长度可变列的表，例如包含TEXT、BLOB等大型字段的表。
2.4 Compressed格式 Compressed行格式采用压缩存储方式，它适用于存储大量重复数据或较大的表。Compressed行格式使用多种压缩算法，如Zlib和LZO等，能够显著减少磁盘I/O操作，提高存储和读取性能
3、BLOB和TEXT列 这点因素与上面那点有关，Blob 和 Text 是mysql中的大数据存储类型，但是在我们不设置行模式为ynamic和compressed的时候，这些列通常存储在页外，但它们的元数据（如长度）仍然存储在行内，而这个存储的大小跟行格式的设置会有所不同。也就是说明他会计入行大小限制的计算；
二、解决办法 好了，既然知道问题原因的可能了，现在就是开始如何解决了；
1、修改页大小（不推荐） 虽然mysql InnoDB的引擎默认的页大小是16KB，但是这个值并不是不能修改，修改配置文件；
添加或修改innodb_page_size参数来设置新的页大小。例如，innodb_page_size = 16384（以字节为单位，对应16KB），或者设置的更大；
不过需要注意的是：页大小的调整最好是在数据库初始化的初期去设置，一旦数据库初始化完成后，就不建议更改了，这种情况下意味着你原来已经存在的所有ibdata和ib_logfile文件都需要重建，那就不是很合适了，而且这样做也可能会带来一定的性能影响；
2、修改行格式 既然dynamic和compressed行格式就是为了解决行大小限制而引入的，我们可以修改该格式即可；当然了，我们也不是都要去修改这个，这个也是和我们的mysql版本有关的；
从 MySQL 5.6.3 开始，默认的行格式是 DYNAMIC，也就是说，其实在这个版本之后的我们其实就不需要修改行格式了；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f393a890035d3ef59c2d1d33ee17bac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4608f55c8f7a19095be134d1edc86bae/" rel="bookmark">
			AIGC实践｜用AI制作视频短片创作全流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
在深入探讨了AI在动态有声绘本和小游戏开发的应用之后，本次我们将聚焦于视频创作领域。本篇文章将详细展示如何使用AI工具从概念构思到画面生成再到最终成片的全过程，涵盖剧本创作、分镜头设计、视觉效果生成及音乐配制等各个阶段。让我们一同启程，再次踏上这探索之旅吧～！
星际新家园
一、视频短片创作要素 视频短片的创作是一个复杂的过程，想要制作出令人难忘的电影短片，我们需要精心构思每一个创作要素。大体可以从「概念构思」、「剧本创作」、「分镜头设计」、「视觉效果生成」、「配音配乐」、「后期合成处理」等几个方面去逐步构思完善。
概念构思：首先需要明确短片的主题、风格和目标受众。这一步骤是整个创作过程的基础，决定了后续每个环节的方向。
剧本创作：一个好的剧本是视频短片成功的基石。是灵魂，决定了整个故事的走向和情节发展。利用ChatGPT，可以快速生成剧本的初稿，并根据需要进行修改和完善，确保故事逻辑严密、情节紧凑。
分镜头设计：分镜头设计将剧本转化为具体的视觉语言，是创作过程中的重要环节。完成分镜头的绘制和调整，确定每个镜头的构图和拍摄角度。展示不同的视角和细节。
视觉生成：视觉效果是短片吸引观众的重要元素。利用WHEE等AI工具，可以生成高质量的视觉素材，包括角色设计、场景构建和特效添加，为短片增色不少。
配音配乐：音乐和配音是短片情感表达的重要组成元素。通过Udio和ElevenLabs等AI工具，可以创作符合短片氛围的背景音乐和音效，并实现高质量的配音效果，提升观众的观影体验。
后期处理：在完成所有素材准备后，进行剪辑和合成，完成整个短片的制作。
对于这6个关键创作要素，为了更方便操作和理解，将其划分为四个大步骤：「创意与规划」「设计与制作」「音频与动画」「后期整合与发布」可以更详细地覆盖从概念到成片的整个创作流程。
二、创意与规划 创意与规划中包含了两个部分：概念构思和剧本创作。
首先是概念构思部分，这部分我们需要确定短片的主题、类型风格和目标受众。主题可以选择有深意或者能引起观众共鸣的主题；类型风格可以有很多选择，比如恐怖、爱情、科幻、刑侦等；明确短片的目标受众群体，了解他们的兴趣和偏好，以便在创作过程中更有针对性。更精准地把握目标受众的需求和期望。
剧本创作这部分内容可以利用ChatGPT充当前期的头脑风暴部分，帮我们生成多个主题方案，可以在其中进行挑选，然后加工润色，与GPT沟通几轮进行优化修改，这样基本就可以确定出一个比较符合我们需要的剧本了。
三、设计与制作 设计与制作中包含了分镜头设计与视觉生成两个部分。
分镜头设计这部分我们也直接借助GPT帮我们完成文字版的分镜表格，包括：镜号、画面描述、景别、运镜、旁白、字幕、音效、时长等，也可以简单的绘制一下分镜头的画面，方便后期生图更明确。
经过几轮沟通后，最终确定了分镜头，这样每个画面的效果基本就呈现在脑中了，这时候我们就可以根据GPT或者自己手绘的分镜头，在WHEE中生成画面内容了，在生图过程中同样也需要多多尝试不同的风格模型。
为了方便后续镜头的切换和镜头的运镜等效果，我使用了WHEE的「AI扩图」功能。将图进行扩大，扩图中的提示词我直接复制了之前的提示词。扩图后，使用「AI超清」功能调整图片清晰度。
四：音频与动画 配音配乐部分主要使用Udio。可一句话生成一段30s的音乐，生成后可根据此风格扩写至1分钟左右。
动效部分主要使用WHEE和其他AI动态辅助软件相结合，确保生成的效果连贯且完整。
五：后期整合与发布 在完成所有素材准备后，将所有素材进行剪辑和合成，进行调色、滤镜、电影效果、黑场、音效、片名和画面特效等处理，确保最终成片质量。这样全流程AI制作视频短片就完成了。
六：总结 AI工具的应用大大提升了电影短片创作的效率和质量。从概念构思到剧本创作，再到分镜头设计、视觉效果生成、音乐配制和配音，每一个环节都能借助AI工具实现更高效的创作全流程。通过本文的详细介绍，希望能够为大家在AI短片创作的道路上提供有益的参考。让我们一同探索AI技术的无限可能，创作出更多精彩的电影短片吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71e3b7cba62d4bb00b0def245cb9d9cb/" rel="bookmark">
			【python】tkinter GUI开发: 多行文本Text，单选框Radiobutton，复选框Checkbutton，画布canvas的应用实战详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨✨ 欢迎大家来到景天科技苑✨✨
🎈🎈 养成好习惯，先赞后看哦~🎈🎈
🏆 作者简介：景天科技苑
🏆《头衔》：大厂架构师，华为云开发者社区专家博主，阿里云开发者社区专家博主，CSDN全栈领域优质创作者，掘金优秀博主，51CTO博客专家等。
🏆《博客》：Python全栈，前后端开发，小程序开发，人工智能，js逆向，App逆向，网络系统安全，数据分析，Django，fastapi，flask等框架，linux，shell脚本等实操经验，网站搭建，数据库等分享。
所属的专栏：python图形化GUI编程tkinter精讲
景天的主页：景天科技苑
文章目录 1.Text 多行文本框2.Radiobutton 单选按钮3.Checkbutton 复选按钮4.canvas 画布 1.Text 多行文本框 Text(多行文本框)的主要用于显示多行文本，还可以显示网页链接, 图片, HTML 页面, 甚至 CSS 样式表，添加组件等。因此，也常被当做简单的文本处理器、文本编辑器或者网
页浏览器来使用。比如 IDLE 就是 Text 组件构成的。
【示例】Text 多行文本框基本用法(文本输入、组件和图像显示)
"""测试Text多行文本框组件的基本用法，使用面向对象的方式""" from tkinter import * import webbrowser class Application(Frame): def __init__(self, master=None): super().__init__(master) # super()代表的是父类的定义，而不是父类对象 self.master = master self.pack() self.createWidget() def createWidget(self): self.w1 = Text(root, width=40, height=12,bg="gray") # 宽度20个字母(10个汉字)，高度一个行高 self.w1.pack() #insert第一个参数1.0表示第1行，第0列。列的序号是从0开始 self.w1.insert(1.0, "0123456789\nabcdefg") self.w1.insert(2.3, "锄禾日当午，汗滴禾下土。谁知盘中餐，粒粒皆辛苦\n") #创建按钮pack里面加上side="left"，使按钮水平排列，不加的话默认是垂直排列，垂直排列很占位置 Button(self,text="重复插入文本",command=self.insertText).pack(side="left") Button(self,text="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71e3b7cba62d4bb00b0def245cb9d9cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c471428da0fa41fa1439189212abbe51/" rel="bookmark">
			Java一分钟之-GraalVM Native Image：构建原生可执行文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java开发领域，GraalVM Native Image是一个令人兴奋的技术革新，它允许我们将Java应用程序编译成独立的、原生的可执行文件，从而实现近乎瞬时的启动时间和更低的内存消耗。这一突破性功能对于微服务、桌面应用乃至嵌入式系统具有重要意义。本文旨在深入浅出地探讨GraalVM Native Image的使用，揭示常见的挑战、易错点，并提供实用的解决策略和代码示例。
GraalVM Native Image简介 GraalVM是一个高性能的运行时环境，它不仅支持Java，还兼容JavaScript、Python等多种语言。其中，Native Image是其核心组件之一，它利用即时编译（AOT）技术，在应用程序部署前将其及其依赖转换为机器码，从而消除JVM的启动时间和内存开销。
常见问题与易错点 1. 反射与动态类加载 问题描述：由于Native Image在编译时就需要确定所有类路径，因此对于反射和动态类加载的处理成为一个挑战。
如何避免：使用--report-unsupported-elements-at-runtime标志来报告编译时未发现的反射调用，然后通过配置文件(reflection-config.json)显式声明反射使用的类和方法。
2. 静态初始化问题 问题描述：某些库或框架在静态初始化阶段执行复杂的逻辑，可能导致Native Image构建失败或运行时错误。
解决策略：分析并优化静态初始化逻辑，必要时使用GraalVM提供的配置选项排除问题代码或使用初始化钩子。
3. 依赖冲突与不兼容 问题描述：不是所有的Java库都支持Native Image，特别是那些依赖于运行时类加载或使用了JVM特性的库。
如何避免：在项目初期进行充分的调研，确保所有依赖库与GraalVM Native Image兼容。使用GraalVM的社区资源和官方文档来指导决策。
实战代码示例 假设我们有一个简单的Java应用HelloWorld.java：
public class HelloWorld { public static void main(String[] args) { System.out.println("Hello, Native World!"); } } 构建Native Image 首先，确保安装了GraalVM并配置好环境。然后，通过以下命令构建原生可执行文件：
native-image --no-fallback -H:EnableURLProtocols=http,https -jar HelloWorld.jar 这里，--no-fallback禁止使用解释器回退模式，-H:EnableURLProtocols参数用于启用必要的网络协议支持。
运行原生可执行文件 构建成功后，会生成一个名为hello-world（或根据你的主类命名）的可执行文件，直接在命令行运行即可：
./hello-world 结语 GraalVM Native Image为Java应用的部署和性能优化开辟了新的天地，但其独特的编译模型也带来了一系列挑战。通过细致的前期规划、合理的代码设计以及熟练运用GraalVM提供的工具和配置，我们可以有效避免大多数问题，享受到接近原生应用的启动速度和轻量级运行环境带来的益处。随着GraalVM社区的不断壮大和技术的成熟，相信未来会有更多复杂应用成功拥抱Native Image，开启Java开发的新篇章。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4727fad4a09577a722fd17761c7a244c/" rel="bookmark">
			解决uniapp微信小程序Android与iOS系统获取蓝牙广播包中deviceid不同的办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 因为小程序官方是支持接入低能蓝牙（BLE）的，所以在一个项目中也尝试使用如何接入蓝牙，我们从微信的官方网站就可以清楚知道如何使用，但是其中也是有很多坑的。本着学习的心态，自己也手把手带你摸坑，一起处理一些平台兼容性的问题以及一些逻辑判断问题
作者在开发一款共享干衣机小程序，用的是uniapp框架进行开发的，开发期间时遇到了 苹果(ios) 和 安卓(android)手机 获取到的 deviceId(mac)地址不一致问题;
1、设备绑定 在共享设备铺货到酒店等场所时，我们会让工作人员使用小程序码对共享干衣机设备进行绑定，这个目的就是为了解决，用户打开蓝牙连接时会出现N个蓝牙，用户会不知所措的问题。
绑定过程需要填写以下信息:
1、蓝牙名称：自动生成2、设备编码：扫描提前生成的小程序码（里面包含了设备编码）3、设备：选择设备就是我们选择蓝牙然后拿到deviceId(mac地址)4、代理商5、商户6、网点 2、用户使用流程 我们这个共享项目的用户使用流程是：
1、用户扫码(生成的小程序码) 里面包含设备蓝牙信息；2、弹出连接蓝牙给用户连接 (通过小程序码里的蓝牙信息里的deviceId(mac地址)过滤掉其他蓝牙,只显示用户扫码设备的蓝牙)；3、用户连接成功后 隐藏连接蓝牙按钮显示 立即使用按钮；4、用户选择使用时长(默认30分钟)；5、点击立即使用调用支付；6、支付成功后 (小程序下发开关定时指令给干衣机设备进行使用)； 3、平台差异化 因为我们使用的是uniapp框架开发所以没看到uniapp说明这个…（大坑）
后来我们从微信文档上面看到这样一段话：
看到这里我就想着，完犊子了，因为我们的手机平台有安卓和苹果，唯一标识蓝牙的就是deviceId，但是苹果搜索出来就不是这个了，而是uuid的一串字符串。因为苹果官方认为透露deviceId（MAC地址）会有安全问题，索性直接屏蔽了。
4、问题分析 开发安卓和IOS的APP中，在获取蓝牙模块的MAC地址的时候有区别。
安卓系统在蓝牙这一块，给了获取蓝牙模块MAC地址的接口，所以直接用就行，包括安卓端的微信小程序或者其他小程序。
IOS比较严谨，不允许获取蓝牙模块的MAC地址，没有给出API，所以必须要在蓝牙模块这一端做一些特别的设置。
在设备绑定时工作人员用安卓绑定的设备是唯一的，而用户使用ios搜索蓝牙时，每个用户搜索到的蓝牙设备都是uuid随机的deviceId与我们绑定deviceId的不匹配，因此也就无法在用户使用的时候过滤其他蓝牙了。
5、解决方案 方法1-特定的UUID去读取MAC地址 其实这类型的应用并不多，因为他需要建立连接之后，才能获取到mac地址，这样就不实用了
在程序开发中我们很少有采用这样的方式的 。其实实现也很简单，一说就懂
所以这个方法，暂时不推荐使用，请详细了解一下方法二。
方法2–MAC地址存放在蓝牙模块广播包里面 在广播包里面，查找蓝牙的 MAC 地址，一般良心厂商都会存放在广播包里面，所以可以获取到。
作者开发的蓝牙线路板蓝牙厂商没有写进去…，然后联系厂商重新烧录进去。
经过了九九八十一天来回邮寄线路板，厂商终于把 mac 地址写入进advertisData去了。
这里我们称之为：advertisData（当前蓝牙设备的广播数据段中的 ManufacturerData 数据段， 类型为：ArrayBuffer）。
做这个的目的，有如下原因：
1、微信小程序开发：无法直接获取蓝牙芯片的 mac 地址，没有相应的API，所以可以通过这个获取到，具体网上可以搜一下
2、APP 开发–IOS 端，也没办法直接获取 MAC 地址，也是通过这个方式得到蓝牙芯片的 MAC 地址
3、APP 开发–安卓端，没有这个问题，直接通过 API 时可以获取到蓝牙芯片的 mac 地址的。所以用不用这个功能，都无所谓
实现代码：
// 初始化蓝牙模块 uni.openBluetoothAdapter({ success(res) { // 开始搜寻附近的蓝牙外围设备 uni.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4727fad4a09577a722fd17761c7a244c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/272/">«</a>
	<span class="pagination__item pagination__item--current">273/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/274/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>