<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afcac5ffd7c2ca9886c6f7538b1427da/" rel="bookmark">
			以太网UDP测试实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.UDP简介
1.1UDP概述
1.2UDP协议
二.实验任务
三.模块设计
3.1总体模块设计
3.2UDP模块设计
3.2.1udp_rx模块设计
3.2.2udp_tx模块设计
四.板级验证 一.UDP简介 1.1UDP概述 UDP （User Datagram Protocol)用户数据协议 是一种面向无连接的传输层协议，属于 TCP/IP 协议簇的一种。 UDP 具有消耗资源少、通信效率高等优点，通常用来传输音频、视频等对实时性要求高的场合。 UDP 和 TCP 是传输层中非常重要的两个协议，以下是两者的区别。 1.2UDP协议 可以看出UDP和ICMP在以太网帧里面的位置一样。
UDP 首部共 8 个字节，同 IP 首部一样，也是一行以 32 位（ 4 个字节）为单位。 源端口号： 16 位发送端端口号，用于区分不同服务的端口，端口号的范围从 0 到 65535 。 目的端口号： 16 位接收端端口号。 UDP 长度： 16 位 UDP 长度，包含 UDP 首部长度 + 数据长度，单位是字节（ byte ）。 UDP 校验和： 16 位 UDP 校验和。 UDP 计算校验和的方法和计算 IP 数据报首部校验和的方法相似，但不同的是 IP 数据报的校验和只检验 IP 数据报的首部，而 UDP 校验和包含三个部分： UDP 伪首部， UDP 首部和 UDP 的数据部分。伪首部的数据是从 IP 数据报头和 UDP 数据报头获取的，包括源 IP 地址，目的 IP地址，协议类型和 UDP 长度，其目的是让 UDP 两次检查数据是否已经正确到达目的地，只是单纯为了做校验用的。 二.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afcac5ffd7c2ca9886c6f7538b1427da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a1ecda516e3d342c5ee19e6a60fe2c4/" rel="bookmark">
			【数据结构与算法】十大经典排序算法深度解析：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💓 博客主页：倔强的石头的CSDN主页 📝Gitee主页：倔强的石头的gitee主页
⏩ 文章专栏：《数据结构与算法》
期待您的关注
​
目录
引言
一、排序算法概述
排序算法简介
排序算法的分类
性能指标
二、十大排序算法详解
🍃冒泡排序
🍃直接选择排序
🍃直接插入排序
🍃希尔排序
🍃快速排序
🍃堆排序
🍃归并排序
🍃计数排序
🍃桶排序
🍃基数排序
三、排序算法的性能比较与适用场景分析
性能比较
适用场景分析
四、总结
性能总结
稳定性与适用性
写在结尾
引言 在数据处理的广阔领域中，排序算法作为基石般的存在，扮演着至关重要的角色。无论是从日常生活中的简单列表排序，到复杂系统中海量数据的组织与管理，排序算法都是不可或缺的工具。它们不仅决定了数据处理的效率，还直接影响到用户体验和系统性能。
排序算法的核心任务是将一组数据元素（记录）按照某个关键字（或关键字序列）的递增或递减顺序重新排列，使得原本无序的数据变得有序。这一过程看似简单，实则蕴含着丰富的算法思想和优化策略。
随着计算机科学的发展，众多排序算法应运而生，每种算法都有其独特的适用场景和性能特点。为了帮助读者系统地掌握这些经典算法，本文精心挑选了十大经典排序算法进行深度解析。这十大算法不仅涵盖了比较排序和非比较排序两大类，还包含了从简单直观到高效复杂的多种实现方式，能够满足不同场景下的排序需求。
在本文中，我们将逐一介绍每种排序算法的基本原理、实现步骤、性能特点以及适用场景。通过具体的代码示例和性能比较，读者将能够深入理解每种算法的优势与局限，从而在实际应用中做出更加合理的选择。
一、排序算法概述 排序算法简介 排序算法是计算机科学中用于将一组数据元素（或记录）按照某个特定的顺序重新排列的算法。这些算法广泛应用于各种数据处理场景中，如数据库管理、数据分析、软件开发等。排序算法的核心目标是将无序的数据序列转变为有序的数据序列，以便进行进一步的查找、分析或呈现。
排序算法的分类 排序算法可以根据多种标准进行分类，但最常见的分类方式是基于它们的基本工作原理。主要分为两大类：比较排序和非比较排序。（更多的分类标准可以参照上图）
比较排序：这类排序算法通过比较数据元素之间的大小关系来确定它们的顺序。比较排序算法包括冒泡排序、选择排序、插入排序、归并排序、快速排序等。这些算法的性能通常依赖于数据元素的初始排列和比较操作的效率。
非比较排序：与比较排序不同，非比较排序算法不直接比较数据元素之间的大小。它们通常依赖于数据元素的某些特定属性或额外的数据结构来实现排序。非比较排序算法包括计数排序、桶排序和基数排序等。这些算法在特定条件下（如数据范围有限或数据分布均匀）能够提供比比较排序更优的性能。
性能指标 评价排序算法优劣的关键指标主要包括以下几个方面：
时间复杂度：衡量算法执行所需时间的度量标准。通常用大O表示法（如O(n^2)、O(n log n)）来描述算法在最坏情况、平均情况和最好情况下的时间复杂度。
空间复杂度：衡量算法执行过程中所需额外空间的度量标准。空间复杂度较低的算法更适合处理大数据集或内存受限的环境。
稳定性：稳定性是指排序算法在保持相等元素之间原有顺序的能力。稳定的排序算法在处理具有相等键值的元素时能够保持它们的相对顺序不变。
适应性：指算法对不同类型数据的适应能力。一些算法可能特别适用于整数排序，而另一些则可能更擅长处理浮点数或字符串等复杂数据类型。
通过综合考虑以上性能指标，我们可以选择最适合特定应用场景的排序算法。在本文的后续部分，我们将逐一深入探讨十大经典排序算法的原理、实现和性能特点，以帮助读者更好地理解并应用这些算法。
二、十大排序算法详解 🍃冒泡排序 基本思想：
通过重复地遍历待排序的序列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。遍历序列的工作是重复地进行直到没有再需要交换，也就是说该序列已经排序完成。
详情请阅读专题文章 ：
​【数据结构与算法】冒泡排序：简单易懂的排序算法解析-CSDN博客
算法过程：
比较相邻元素：重复地走访需要排序的元素列表，依次比较两个相邻的元素。交换元素：如果顺序（如从大到小或从小到大）错误，就交换这两个元素的位置。重复进行：重复以上步骤，直到没有相邻的元素需要交换，则元素列表排序完成。 C语言实现代码：
//冒泡排序 void BubbleSort1(DataType* a, int size)//升序排序 { for (int i = 0; i &lt; size - 1; i++)//控制排序趟数 { for (int j = 0; j &lt; size - 1 - i; j++)//控制每次比较次数 { if (a[j] &gt; a[j + 1])//不满足升序就交换位置 { DataType tmp = a[j]; a[j] = a[j + 1]; a[j + 1] = tmp; } } } } void BubbleSort2(DataType* a, int size)//降序排序 { for (int i = 0; i &lt; size - 1; i++)//控制排序趟数 { for (int j = 0; j &lt; size - 1 - i; j++)//控制每次比较次数 { if (a[j] &lt; a[j + 1])//不满足降序就交换位置 { DataType tmp = a[j]; a[j] = a[j + 1]; a[j + 1] = tmp; } } } } 🍃直接选择排序 基本思想：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a1ecda516e3d342c5ee19e6a60fe2c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3940336bde3e05962d66f8932848a14/" rel="bookmark">
			C&#43;&#43;——智能指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：哈喽小伙伴们，今天我们继续来分享C++的一个全新知识——智能指针。
目录
一.何为智能指针
RAII
二.智能指针的种类
三.内存泄漏
结语
一.何为智能指针 RAII RAII（Resource Acquisition Is Initialization）是一种利用对象生命周期来控制程序资源（如内存、文件句柄、网络连接、互斥量等等）的简单技术。
在对象构造时获取资源，接着控制对资源的访问使之在对象的生命周期内始终保持有效，最后在对象析构的时候释放资源。借此，我们实际上把管理一份资源的责任托管给了一个对象。这种做法有两大好处：
不需要显式地释放资源。采用这种方式，对象所需的资源在其生命期内始终保持有效。 借由RAII的思想，我们引出智能指针：
template&lt;class T&gt; class SmartPtr { public: SmartPtr(T* ptr = nullptr) : _ptr(ptr) {} ~SmartPtr() { if(_ptr) delete _ptr; } private: T* _ptr; }; void Func() { SmartPtr&lt;int&gt; sp1(new int); SmartPtr&lt;int&gt; sp2(new int); cout &lt;&lt; div() &lt;&lt; endl; } 所谓智能指针，就是通过一个类来控制指针对象的存亡，通过这种方式创建的对象，只要函数退出，就会自动执行其析构函数。
二.智能指针的种类 上述我们所实现的，只是智能指针的基础部分，那么在C++的库中，是包含很多种智能指针的：
auto_ptrunique_ptrshared_ptr 这三种智能指针，在智能指针之间的拷贝赋值中有所区别。
auto_ptr指针如果进行拷贝，是通过转移管理权的思想，也可以理解为移动构造，直接争夺资源，但是并不会造成原指针的销毁，而是置空。
unique_ptr指针简单粗暴，直接就是禁止进行拷贝。
能够看出，上述两种智能指针，都不允许指针之间进行数据共享，而shared_ptr却可以： shared_ptr的原理：是通过引用计数的方式来实现多个shared_ptr对象之间共享资源。
其具体实现方式为：
shared_ptr在其内部，给每个资源都维护了着一份计数，用来记录该份资源被几个对象共享。在对象被销毁时(也就是析构函数调用)，就说明自己不使用该资源了，对象的引用计数减一。如果引用计数是0，就说明自己是最后一个使用该资源的对象，必须释放该资源；如果不是0，就说明除了自己还有其他对象在使用该份资源，不能释放该资源，否则其他对象就成野指针了。 再日常使用中，shared_ptr是最常用也是最推荐的智能指针。
三.内存泄漏 那么我们设计智能指针的目的，就是为了防止发生内存泄漏。
什么是内存泄漏：内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并不是指内存在物理上的消失，而是应用程序分配某段内存后，因为设计错误，失去了对该段内存的控制，因而造成了内存的浪费。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3940336bde3e05962d66f8932848a14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a81a9cbc6206342ec41f0b72da8d3dd3/" rel="bookmark">
			基于Verilog HDL的FPGA开发入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在电子设计自动化领域，FPGA（现场可编程门阵列）是一种强大的工具，它允许设计者在硬件层面上实现自定义的逻辑电路。Verilog HDL（硬件描述语言）是描述FPGA设计的主要语言之一，以其简洁性和强大的功能而广受欢迎。
FPGA，以其灵活性和可重构性，为工程师提供了一种快速实现和测试数字电路设计的方法。而Verilog HDL，作为FPGA开发的核心语言，为设计者提供了一种表达电子系统行为的高效工具。
Verilog HDL简介 Verilog HDL是一种硬件描述语言，它允许设计者以文本形式描述数字电路的行为、结构或数据流。自1983年诞生以来，Verilog已经成为电子工程师和学生广泛使用的标准化语言。它支持多种编程范式，包括过程式编程和数据流编程，使得设计者能够以直观和灵活的方式构建复杂的数字系统。
基于Verilog HDL的FPGA开发入门 对于初学者来说，掌握Verilog HDL和FPGA开发可能看起来是一项艰巨的任务，但通过系统的学习和实践，你也可以成为这一领域的专家。入门阶段，小编将通过以下三个方面阐述：
一：FPGA基础知识 FPGA定义：现场可编程门阵列，一种可定制的半导体计算电路。
FPGA组成：输入输出单元、可编程逻辑块、内部连接线。内部结构包含周边可编程的输入输出模块及核心可配置的逻辑单元。这些逻辑单元之间通过内部连线互联，形成可由用户验证的逻辑网络。此外，FPGA的内部逻辑又细分为组合逻辑和寄存器-移位寄存器（RR）两大部分，分别对应多变量输入的可编程函数实现和数据流处理。
FPGA特点：可为设计任务量身定制，内部结构包括可编程的输入输出模块和核心的可配置逻辑单元。
FPGA的优势 FPGA提供了一种独特的解决方案，它允许设计者在不制造实际芯片的情况下，通过编程来实现定制的硬件逻辑。与传统的ASIC（应用特定集成电路）相比，FPGA具有以下优势：
优势：
可定制性高。适用于多输入信息通道处理或多通道控制。适合执行重复计算，减少CPU占用。大量I/O支持，适用于地形改善。适用于信号处理，如数字滤波、频率处理等。 劣势：
不适合执行复杂的计算任务。不适合顺序过程或搜索任务。不适合浮点运算，会消耗大量逻辑资源。不适合低功耗设计，可能需要外部IC控制。成本相对较高。 FPGA内部资源 FPGA中的关键组件包括查找表（LUT）、触发器、RAM存储器和时钟网络。
时钟网络则负责接收外部基准时钟并分配给各个模块，确保数据传输与逻辑功能之间的协调工作。
二：FPGA设计开发流程 设计输入：使用Verilog或其他硬件描述语言（HDL）编写代码。
仿真：在代码编写后进行仿真，以验证设计的正确性。
综合：将HDL代码转换成门级或更低级别的逻辑电路。
布局布线：将逻辑电路映射到FPGA芯片上，优化电路性能。
功能仿真：在不考虑延迟的情况下验证设计的功能正确性。
静态时序分析
三、基于Verilog的设计实例 以一个简单例子对数字电路的FPGA设计流程进行展示，目的是使大家迅速了解设计过程的全貌明确学习目标。
设计要求：实现一个在复位、使能和时钟信号控制下的计数器。
代码实现：使用Verilog编写计数器的RTL代码。
仿真测试：编写测试平台，提供输入激励并验证输出。
随着技术的不断进步，Verilog HDL和FPGA开发将继续在电子设计领域扮演着重要角色。无论你是电子工程的学生，还是希望扩展技能集的专业人士，掌握这些工具将为你打开通往创新和实现复杂电子系统设计的大门。在此小编也为你推荐书籍《Verilog HDL数字设计与综合》作为学习资源。如想要本文章内容视频版本或书籍PDF版本，可联系小编！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b7034ee73f186dbdf829e33fa8458ce/" rel="bookmark">
			ccfcsp201412-1 门禁系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述
涛涛最近要负责图书馆的管理工作，需要记录下每天读者的到访情况。每位读者有一个编号，每条记录用读者的编号来表示。给出读者的来访记录，请问每一条记录中的读者是第几次出现。
输入格式
输入的第一行包含一个整数n，表示涛涛的记录条数。
第二行包含n个整数，依次表示涛涛的记录中每位读者的编号。
输出格式
输出一行，包含n个整数，由空格分隔，依次表示每条记录中的读者编号是第几次出现。
样例输入
5
1 2 1 1 3
样例输出
1 1 2 3 1
评测用例规模与约定
1≤n≤1,000，读者的编号为不超过n的正整数。
#include&lt;iostream&gt;
using namespace std;
int main(){
int n;
cin&gt;&gt;n;
int a[1001]={0};
int b[1001];
for(int i=0;i&lt;n;i++){
cin&gt;&gt;a[i];
b[i]=1;
}
for(int i=1;i&lt;n;i++){
for(int j=0;j&lt;i;j++){
if(a[i]==a[j]){
b[i]++;
}
}
}
for(int i=0;i&lt;n;i++){
if(i==n-1){
cout&lt;&lt;b[i]&lt;&lt;endl;
}
else{
cout&lt;&lt;b[i]&lt;&lt;" ";
}
}
return 0;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66fb2671c9f7b16d00535be6f77d5dd5/" rel="bookmark">
			Science Robotics 封面论文：美国宇航局喷气推进实验室开发了自主蛇形机器人，用于冰雪世界探索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人们对探索冰冷的卫星（如土卫二）的兴趣越来越大，这可能具有天体生物学意义。然而，由于地表或冰口内的环境极端，获取样本具有挑战性。美国宇航局的喷气推进实验室正在开发一种名为Exobiology Extant Life Surveyor（EELS）的蛇状机器人，能够在冰冷的表面上自主导航。EELS有一个感知头，其中包含一系列传感器和摄像头来观察其环境，而身体则具有用于改变形状的铰接部分和螺纹状的外表面以实现运动。EELS显示出对复杂冰冻地形进行自主勘探的潜力。
https://www.science.org/doi/10.1126/scirobotics.adh8332
Vaquero等人近期发表的Science Robotics封面论文，概述了EELS项目及其开发工作，以创建一个具有风险意识的自主机器人来导航这些极端的冰地形/环境。描述了机器人的架构以及安全有效地导航和感知冰冷环境的技术挑战。他们专注于与地面移动性、不确定性下的任务和运动规划以及风险量化相关的挑战。从现场测试和模拟场景中提供移动性、任务和运动规划的初步结果。
该系统由 10 个相同的部分组成，使 EELS 具有蛇形机器人典型的自重复结构。所有段的总长度为 ~4 m，质量为 ~100 kg。每个部分都配备了三个执行器，其中两个使机器人能够改变形状，而第三个则驱动蒙皮（螺钉）。每个形状执行器的峰值扭矩为 400 N·m。高维度自由度允许可重构性和广泛的可能步态。除了适应性强的移动性能外，机器人的自动重复结构还允许优雅的退化和冗余。主动皮肤推进是通过使用连接到每个模块的反向旋转螺钉来实现的。这种特性使运动成为可能，同时使形状执行器保持在准静态的运行状态。
在 EELS 中，控制器是分层排序的，以便于问题表述、软件开发、组件测试和代码可维护性。每个控制器将来自较高级别控制器的目标作为输入，并将其转换为较低级别控制器的分解目标。在该层次结构的底部，有低级硬件命令，而在顶部，有任务级目标，表示为操作员的意图。执行器（关节级）控制器将所需的螺杆速度以及弯曲和扭转执行器位置转换为硬件可理解的命令。形状和螺钉控制包括一组控制器，这些控制器接收所需的路径、所需的控制器和偏差信息，并输出所需的接头角度和螺钉速度。不同的步态需要不同的控制方案。路径规划模块以环境中的姿势形式使用目标，并生成实现这些目标的适当路径。
通过在喷气推进实验室火星场的沙地和加利福尼亚州大熊的冰雪地形中进行的实验室和现场测试来评估表面机动性。各种各样的测试地形配置凸显了机器人的适应性，这是通过基于螺杆和形状的运动相结合实现的。测试活动的主要步态是领导者-追随者和基于形状的步态。外感受和本体感受控制都被证明是有效的运动方法。基于螺钉的运动允许对领导者-跟随者步态进行闭环路径跟踪，并且基于形状的运动被证明是一种有用的策略，可以使机器人摆脱可能意味着传统移动系统（如漫游车）终结的情况。此外，当螺旋运动被证明不太可靠时，基于形状的运动被证明是一种有效的导航松散地形的方法，例如粉雪或细沙。值得强调的是，外感受定位和映射在现场多次失败。这些故障源于硬件故障以及外感受算法与环境之间的交互。这些失败强调了本体感受控制策略和能够在控制模式之间切换的系统级自主性的必要性。外感受故障通常是由环境中的退化引起的，可以通过本体感受移动来克服，直到更多特征变得可见，从而允许重新定位。此外，当外感应因硬件故障而失败时，能够继续执行任务仍然有价值，尽管依赖于本体感觉的路径更保守。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9f08913014401f914e6df418b427ba7/" rel="bookmark">
			FLUX.1最强AI绘画开源新模型，本地部署教程！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：FLUX.1最强AI绘画开源新模型，本地部署教程！ (chinaz.com) Flux最近收到了很多模型爱好者的好评，出图质量超越SD3和MJ，许多人说Flux才是大家心目中的SD3，所以我也是非常好奇FLux的实力在这里把本地部署的过程分享给大家
官网参考图：
Flux官网首页：https://blackforestlabs.ai/
人工智能初创公司 Black Forest Labs成立公司并发布其首套文本转图像人工智能模型 FLUX.1。这家总部位于德国的公司由开发Stable Diffusion的研究人员创立，旨在为图像和视频创建先进的生成式人工智能。
模型一共分三款，包含pro版、dev版、schnell版。
Black Forest 的图表声称其 Pro 和 Dev 模型是迄今为止最好的图像生成器，而其功能较弱的 Schnell 排名介于 Midjourney v5 和 Ideogram 之间
这三个版本说明：
Pro版本效果最好，但是闭源，API收费的。
Dev版本开源但是不可商用，至少需要24G显存运行。
Schnell版本开源可商用
如果你想要在线体验，也有在线的网站：
schnell ：https://replicate.com/black-forest-labs/flux-schnell
dev：https://replicate.com/black-forest-labs/flux-dev
pro：https://replicate.com/black-forest-labs/flux-pro
本地部署 目前ComfyUI最新版本已经兼容FLux模型了， 只需内核升级到最新即可体验。
所以我们首先把ComfyUI给更新了
如果你用的是官方的comfyUI整合包就点这个更新
如果你用的是秋叶的启动器就按下图示例更新内核
显存太低的人本地估计运行很可能，我本地电脑配置还行，这里体验下schnell版本。
下载大模型：https://huggingface.co/black-forest-labs/FLUX.1-schnell/tree/main
该链接提供了23.8g的大模型和335MB的Vae模型，我们需要把这两个都下载
下载完成后将大模型放在：ComfyUI/models/unet/ 文件夹中。
VAE应该放在您的 ComfyUI/models/vae/ 文件夹中。
如果电脑配置一般的可以下载Flux-fp8精简版，只有11.9GB：https://huggingface.co/Kijai/flux-fp8/blob/main/flux1-dev-fp8.safetensors
Vae还是通用的ae.sft
我们除了大模型和Vae还需要下载Clip模型：https://huggingface.co/comfyanonymous/flux_text_encoders/tree/main
这其实就是SD3的Clip模型，配置好我们选择fp16，配置一般我们选择fp8，clip_l是一定要下载的
下载完我们放在：ComfyUI\models\clip 该文件夹内
以上的大模型，VAE，Clip都安装完成后我们就可以运行我们的工作流了，官网提供了一个简易的comfyUI工作流：https://comfyanonymous.github.io/ComfyUI_examples/flux/
我们把官网提供的图片保存下来
再把图片拖进ComfyUI中即可，不想这么麻烦的也可以加入我们的交流群直接获取工作流
进入工作流我们确保模型加载没问题就可以点击加入队列等待生成了
生图效果 提示词1：a bottle with a rainbow galaxy inside it on top of a wooden table on a table in the middle of a modern kitchen
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9f08913014401f914e6df418b427ba7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/603885f2dd25e7f6bcb1d34afe6c1f79/" rel="bookmark">
			免费替代Midjourney！FLUX.1使用方法大全，支持ComfyUI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：Flux.1概述 1.1 它是什么 如果你想直接查看使用教程，MeoAI建议你直接跳到第四章：4种使用方法教程。
Flux.1是由Black Forest Labs开发的一款开源AI图像生成模型。这个模型继承了Stable Diffusion的创新精神和技术优势，由Stable Diffusion原班人马和多位Stability AI前研究员打造，致力于研发优质多模态模型并开源。该模型拥有12B参数，是迄今为止最大的文生图模型之一。Flux.1的命名寓意着其在图像生成领域的流动性和创新性，旨在为用户带来源源不断的创意和灵感。
1.2 版本介绍 Flux.1包含三个不同的版本，以满足不同用户的需求：
FLUX.1 [pro]：面向专业用户，提供最高质量的图像生成服务。FLUX.1 [dev]：面向开发者和非商业用途，是一个开源的、经过指导蒸馏的模型。FLUX.1 [schnell]：为快速生成和本地开发设计，提供了最快的图像生成速度。 NameHuggingFace repoLicensemd5sumFLUX.1 [schnell]https://huggingface.co/black-forest-labs/FLUX.1-schnellapache-2.0a9e1e277b9b16add186f38e3f5a34044FLUX.1 [dev]https://huggingface.co/black-forest-labs/FLUX.1-devFLUX.1-dev Non-Commercial Licensea6bd8c16dfc23db6aee2f63a2eba78c0FLUX.1 [pro]Only available in our API. 1.3 社区与支持 Flux.1的开发团队非常重视与技术社区的互动和合作。通过GitHub等平台，Flux.1的源代码和模型权重对所有感兴趣的研究者和开发者开放，鼓励社区成员参与到模型的改进和创新中来。
项目官网：Black Forest Labs - Frontier AI Lab在线试用地址： black-forest-labs/flux-pro – Run with an API on Replicateblack-forest-labs/flux-dev – Run with an API on Replicateblack-forest-labs/flux-schnell – Run with an API on ReplicateGitHub仓库：GitHub - black-forest-labs/flux: Official inference repo for FLUX.1 modelsHuggingFace模型库：https://huggingface.co/black-forest-labs/FLUX.1-schnell 二：核心技术 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/603885f2dd25e7f6bcb1d34afe6c1f79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/593d95d1bf196192b0012681907355d9/" rel="bookmark">
			MySQL--主从复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：本博客仅作记录学习使用，部分图片出自网络，如有侵犯您的权益，请联系删除
一、什么是主从复制 1、定义 主从复制，是用来建立一个和主数据库完全一样的数据库环境，称为从数据库；主数据库一般是准实时的业务数据库。
2、作用 做数据的热备，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率,提高单个机器的I/O性能读写分离，使数据库能支撑更大的并发 在从服务器可以执行查询工作（即我们常说的读功能），降低主服务器压力;（主库写，从库读，降压）在从服务器进行备份，避免备份期间影响主服务器服务;（确保数据安全） 二、主从复制原理 实现整个主从复制，需要由slave服务器上的IO进程和Sql进程共同完成
要实现主从复制，首先必须打开Master端的binary log（bin-log）功能，因为MySQL主从复制过程实际上就是Slave从Master端获取相应的二进制日志，然后再在自己slave端完全按照顺序执行日志中所记录的各种操作。
master 负责写 -----A slave relay-log -----B I/O 负责通信读取binlog日志 SQL 负责写数据 其主从复制流程图与步骤如下：
步骤一：主库db的更新事件(update、insert、delete)被写到binlog步骤二：从库发起连接，连接到主库步骤三：此时主库创建一个binlog dump thread线程，把binlog的内容发送到从库步骤四：从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log.步骤五：从库还会创建一个SQL线程，从relay log里面读取内容，将更新内容写入到slave的db. 面试题：1、主从复制延迟大比较慢原因：
主服务器配置高，从服务器的配置低 并发量大导致主服务器读的慢。从服务器写的慢 网络延迟比较高 从服务器的读写速度慢 从节点过多 面试题：2、从数据库的读的延迟问题了解吗？如何解决？
解决方法： 半同步复制—解决数据丢失的问题 并行复制—-解决从库复制延迟的问题 一、主-从-从架构 10.0.0.2主库---10.0.0.3从库--10.0.0.4从库
1、关闭防火墙 systemctl stop firewalld systemctl disable firewalld 2、设置serve_id （主从库） # 主库2 [root@localhost ~]# vim /etc/my.cnf serve_id=2 log_bin=2 ​ # 从库3 [root@localhost ~]# vim /etc/my.cnf serve_id=3 ​ # 从库4 [root@localhost ~]# vim /etc/my.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/593d95d1bf196192b0012681907355d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1241f92a7fb94e8005f2f4bd13bf55b2/" rel="bookmark">
			设计模式中的类关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 依赖（Dependency） 定义：一个类使用到另一个类的实例，通常是通过方法参数、局部变量等。依赖关系是最弱的关系，因为它仅仅表示类之间的临时关联。
特征：在 UML 图中，依赖关系用带箭头的虚线表示，箭头指向被依赖的类。
示例：
public class Driver { public void drive(Car car) { car.start(); } } ​ public class Car { public void start() { System.out.println("Car started"); } } 在这个例子中，Driver 类依赖于 Car 类，因为 drive 方法使用了 Car 类的对象。
2. 关联（Association） 定义：关联是一种结构关系，描述了一个对象知道另一个对象的存在，并且可以和它进行交互。一个类中存在另一个类的对象作为成员变量，这种关系可以是双向的。关联通常是长期的，是类之间的一种静态关系。
特征：在 UML 图中，关联关系用带箭头或没有箭头的实线表示，箭头指向目标类。关联可以是双向的（双箭头）或单向的（单箭头）。
示例：
public class Person { private Address address; ​ public Person(Address address) { this.address = address; } ​ public Address getAddress() { return address; } } ​ public class Address { private String street; ​ public Address(String street) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1241f92a7fb94e8005f2f4bd13bf55b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcc355792bdd7358bf7db14b7d16e54a/" rel="bookmark">
			mysql 各种锁归纳总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、引言二、锁分类三、Mysql锁四、MyISAM表锁五、InnoDB锁六、间隙锁七、总结 一、引言 在现代应用程序中，数据库是不可或缺的组成部分之一。而MySQL作为一款开源的关系型数据库管理系统，广泛应用于各种规模的应用中。然而，在高并发的情况下，数据库的性能往往成为瓶颈，因此数据库锁机制成为了至关重要的技术。本文将深入探讨MySQL中的各种锁，包括行锁、表锁、页锁等，以及如何使用它们来提高数据库的性能。
二、锁分类 从对数据操作的粒度来分：
表锁：操作时会锁定整个表
行锁：操作时会锁定当前操作行
从对数据操作的类型分：
读锁（共享锁）：针对同一个份数据，多个读操作可以同时进行而不会互相影响
写锁（排它锁）：当前操作没有完成之前，它会阻断其他写锁和读锁
三、Mysql锁 mysql锁的特性：
表级锁
偏向MyISAM存储引擎，开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低
行级锁
偏向InnoDB存储引擎，开销小，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率最低，并发度最高
页面锁
开锁和加锁时间介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般
四、MyISAM表锁 MyISAM在执行查询语句（SELECT）前会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用 LOCK TABLE 命令给MyISAM表显式加锁。
显式加锁语法：
lock table table_name read; lock table table_name write; unlock tables; MyISAM表的读操作不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写操作 MyISAM表的写操作会阻塞其他用户对同一表的读和写操作 MyISAM的读写锁调度是优先写，这也是MyISAM不适合作写为主的表的存储引擎原因。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞
查看锁争用情况：
show open tables; show status like 'Table_locks%'; 五、InnoDB锁 两种类型的行锁
共享锁(S)
又称读锁，简称S锁，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改
排它锁(X)
又称写锁，简称X锁，排他锁就是不能与其他锁并存，如一个事务获取了一个数据行的排它锁，其他事务就不能再获取改行的其他锁，包括共享锁和排它锁，但是获取排它锁的事务是可以对数据行读取和修改
加锁语句：
select * from table_name where … LOCK IN SHARE MODE select * from table_name where… FOR UPDATE TIPS：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcc355792bdd7358bf7db14b7d16e54a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e987738141367277a06efe06ae5f713/" rel="bookmark">
			单片机振荡电路晶振不起振原因分析与解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		晶发电子专注17年晶振生产,晶振产品包括石英晶体谐振器、振荡器、贴片晶振、32.768Khz时钟晶振、有源晶振、无源晶振等，产品性能稳定,品质过硬,价格好,交期快.国产晶振品牌您值得信赖的晶振供应商。
晶振在单片机系统中扮演着至关重要的角色，它为单片机提供稳定的时钟信号。然而，在实际应用中，晶振可能因为各种原因不起振，导致单片机无法正常工作。本文将分析单片机振荡电路造成晶振不起振的原因，并提供相应的解决方法。
晶振不起振的原因分析
1. 激励功率不足或过大：
- 如果晶振起振所需的实际激励功率大于规格书中建议的最大值，可能导致晶振温度特性不正常，这可能是由于芯片故障所致。
2. 频率偏差：
- 晶振的实际输出频率如果严重偏离标称频率，可能会造成单片机逻辑时序错误或数据处理进程终止。
3. 振荡电路失效：
- 如果振荡电路本身存在问题，晶振将无法起振。
4. 晶振振幅过小：
- 晶振振幅过小，无法产生有效的时钟脉冲，可能是由于芯片不良或焊接问题导致。
解决方法
1. 测量工作频率：
- 使用频率测试仪测量晶振频率输入端及输出端的实际工作频率，确认与芯片时钟系统连接的脚位是否正确。
2. 使用信号发生器检查：
- 用信号发生器代替晶振，通过改变信号幅度来检查芯片功能是否正常。
3. 调整外接电容：
- 在电路板上电后，测试晶振的实际输出频率，如果不在标称频率范围内，调整外接电容值的大小，并使用频率计数器监测频率变化。注意，电容值与频率成反比。
4. 检查激励功率：
- 确认振荡电路是否为晶振提供了符合规格书要求的激励功率。
5. 分析芯片问题：
- 检查芯片是否存在暗脚或焊接不良，这可能导致开路，进而造成晶振不起振。
晶振不起振的问题可能由多种因素引起，通过系统的分析和逐步的排查，可以找到问题的根源并采取相应的措施进行解决。在实际操作中，需要结合具体情况，灵活运用上述方法，确保单片机系统的稳定运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/332fdac4d47b034f4e92311143a1bb8b/" rel="bookmark">
			MySQL表的约束
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 表的约束空属性defaultzerofill主键自增长唯一键(unique)外键 表的约束 在MySQL中表要有一定的约束，通过约束让我们未来插入的数据是可预期的。约束的本质是通过技术手段，倒逼程序员插入正确的数据，反过来，站在MySQL的角度，凡是插入进来的数据都是符合数据约束的。真正约束字段的是数据类型，但是数据类型约束很单一，需要有一些额外的约束，更好的保证数据的合法性，从业务逻辑角度保证数据的正确性。
空属性 两个值：null（默认的）和not null(不为空)。
数据库默认字段基本都是字段为空，但是实际开发时，尽可能保证字段不为空，因为数据为空没办法参与运算。
我们在创建表是，可以在属性后面给列属性添加not null约束，添加完之后，在插入数据时这一列就不能为空。
default 默认值：某一种数据会经常性的出现某个具体的值，可以在一开始就指定好，在需要真实数据的时候，用户可以选择性的使用默认值。默认值的生效：数据在插入的时候不给该字段赋值，就使用默认值。default一般自己不设置MySQL会默认设置以为空。所以，如果设置了not null属性在设置一个不是空的default属性，在插入是也可以不指定这一列，当然如果不设置，默认就是空，就会被not null拦截。
comment
列描述：
没有实际含义，专门用来描述字段，会根据表创建语句保存，用来给程序员或DBA来进行了解。
zerofill 我们会看到在desc后每个类型后面都有个数字，没有zerofill这个属性，括号内的数字是毫无意义的。
如果宽度小于设定的宽度，自动填充0。要注意的是，这只是最后显示的结果，在MySQL中实际存储的还是设置的那个数。
zerofill可以理解为一种格式化输出。
主键 primary key用来唯一的约束该字段里面的数据，不能重复，不能为空，一张表中最多只能有一个主键；主键所在的列通常是整数类型。
主键约束：主键对应的字段中不能重复，一旦重复，操作失败。
当表创建好以后但是没有主键的时候，可以再次追加主键。
alter table 表名 add primary key(字段列表) 删除主键
alter table 表名 drop primary key; 复合主键：
在创建表的时候，在所有字段之后，使用primary key(主键字段列表)来创建主键，如果有多个字段作为主键，可以使用复合主键。
create table tt14( -&gt; id int unsigned, -&gt; course char(10) -&gt; score tinyint unsigned default 60 comment '成绩', -&gt; primary key(id, course) -- id和course为复合主键 -&gt; ); 表示值都等id和coutse都相同时才会插入失败，两者有一个不一样都会插入成功。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/332fdac4d47b034f4e92311143a1bb8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58b54580ed3078f4b801247fe685d236/" rel="bookmark">
			阿尔泰科技8路16位多功能同步模拟信号采集卡PCIe9770/1 (A/B)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#数据采集卡
产品简介：
PCIe9770/1 (A/B) 多功能数据采集卡。该系列板卡提供8/4路单端或差分同步模拟输入通道；2路模拟量同步输出；8路带缓冲数字I/O，16/8路可编程I/O及2/1通道多功能计数器。主要应用场合：电子产品质量检测、信号采集、过程控制、伺服控制。 性能描述： ​
指标参数： 型号
AD
DA
CTR
DIO
分辨率
通道
采样率
分辨率
通道
采样率
通道
通道
PCIe9770
16
8
2MS/s
16
2
2MS/s
2路
24路
PCIe9770A
16
8
1MS/s
16
2
1MS/s
2路
24路
PCIe9770B
16
8
500KS/s
16
2
500KS/s
2路
24路
PCIe9771
16
4
2MS/s
16
2
2MS/s
1路
16路
PCIe9771A
16
4
1MS/s
16
2
1MS/s
1路
16路
PCIe9771B
16
4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58b54580ed3078f4b801247fe685d236/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b311d594b1349e7f6bf74648a89107ed/" rel="bookmark">
			Java 实现OCR扫描/识别图片文字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图片内容一般无法编辑，如果想要读取图片中的文本，我们需要用到OCR工具。本文将介绍如何在Java中实现OCR识别读取图片中的文字。
所需工具： IDEASpire.OCR for Java - Java OCR组件，支持识别多种语言、字体，可读取JPG、PNG、GIF、BMP 和 TIFF 等常用图片中的文本信息。 产品包下载链接：下载 | Spire.OCR for Java
或从Maven仓库导入：
&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;com.e-iceblue&lt;/id&gt; &lt;name&gt;e-iceblue&lt;/name&gt; &lt;url&gt;https://repo.e-iceblue.cn/repository/maven-public/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;e-iceblue&lt;/groupId&gt; &lt;artifactId&gt;spire.ocr&lt;/artifactId&gt; &lt;version&gt;1.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 其余依赖文件。按操作系统下载对应文件后，解压缩至指定的文件路径。 Linux
Windows x64
Java OCR识别图片文本的实现步骤 1. 在IDEA中新建一个项目并导入Spire.OCR.jar。
2. 将刚才下载解压缩后的 “dependencies” 文件夹复制到IDEA项目目录下。
3.确保导入以上所需依赖后，运行以下代码实现扫描读取图片中的文本。
import com.spire.ocr.OcrScanner; import java.io.*; public class ReadImage { public static void main(String[] args) throws Exception { //指定依赖文件的路径 String dependencies = "dependencies\\"; //指定要需要扫描的图片的路径 String imageFile = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b311d594b1349e7f6bf74648a89107ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea63ed3bd77ffe32f248f484a8ded39d/" rel="bookmark">
			【C&#43;&#43;】C&#43;&#43;11的新特性 --- lambda表达式 ，新的类功能，模块的可变参数 ， emplace系列接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你停止,就是谷底! 如果你还在继续,就是上坡! 这是我听过关于人生低谷最好的阐述。 -- 刘同 C++11的新特性 1 lambda表达式1.1 基本用法1.2 细谈参数列表与捕捉列表 2 新的类功能2.1 移动构造与移动赋值2.2 default和delete 3 模块的可变参数4 emplace系列接口4.1 emplace接口的实现4.2 push 和 emplace 的对比 Thanks♪(･ω･)ﾉ谢谢阅读！！！下一篇文章见！！! 1 lambda表达式 1.1 基本用法 C语言解决自定义排序问题时，会使用函数指针；C++我们解决排序问题时，一般都会使用仿函数，通过自定义类来实现自定义比较大小。如果涉及的比较排序很多，就要写出很多类，比较繁琐。通
今天的lambda表达式也是一种解决办法。我们来看：这是我们传统的仿函数写法
struct Goods { string _name; // 名字 double _price; // 价格 int _evaluate; // 评价 Goods(const char* str, double price, int evaluate) :_name(str) , _price(price) , _evaluate(evaluate) {} }; class GoodsPriceLess { public: bool operator()(Goods&amp; a , Goods&amp; b) { return a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea63ed3bd77ffe32f248f484a8ded39d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6ecba1f1556871298cf88b71a43fcad/" rel="bookmark">
			程序员短视频上瘾综合症
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、是你疯了还是面试官疯了？ ​ 最近有两个学员咨询问题，把我给整得苦笑不得。大家来看看，你有没有同样的症状。
​ 第一个学员说去一家公司面试，第一轮面试聊得挺好的。第二轮面试自我感觉良好，但是被面试官给Diss了，说他没有技术深度，来问问我什么意见。然后一问具体情况，这哥们一上来就是介绍自己做了一个SAAS架构的中台。聊起这个中台的功能，那叫一个天花乱坠。SSO单点登录啊，通知消息转发啊，啥都有。甚至还有整合数据往后面的技术中台透传啊。反正那叫一个牛逼。结果面试官回了一句“缺少业务深度”。
​ 后面跟这哥们详细了解了一下情况。他做这个项目到是对接过几个前端业务，然后在他做的项目后端，也确实对接了技术中台。但是他这个项目，在公司并没有作为一个中台项目规划。简历中写成个中台，其实是在吹牛的。更可笑的是，前面还提了一个SAAS架构。但是我问他SAAS架构干什么的？解决什么问题？用户数据隔离的方案是什么样的？一问三不知。他甚至跟我直说，SAAS是什么都不太清楚。简历里写上SAAS和中台这些，都是为了让简历好看一些。
​ 第二个学员是一上来就问我要怎么做一个支付系统？有哪些核心业务？要用到哪些技术？刚一看，我还以为是有大人物来了，这是一个很大的活啊。结果一聊，他说他没做过支付，怎么对接银行接口，怎么做风控，什么是统一收银，资金归集，账单对账等等业务全都没接触过。只是为了准备面试，老是看到别人喜欢拿一些电商、支付之类的业务来说事，就想着也要往简历上面写写支付，而且要写，还不能把自己写成一个小喽啰。甚至还煞有介事的说，老师，你做过支付系统，那做一个第三方支付的实战项目，那是小菜一碟把。那赶紧写一个我来学一学。
​ 此话一出，听得我老血一喷。实在难以理解，一个还在纠结用什么技术实现的程序员，哪里来的自信随随便便就要设计一个支付系统？就算想要往简历上贴贴金，什么项目不好找，为什么非要找这种跟钱打交道的项目呢？而且，如果只是准备面试，支付这么复杂的业务，中间任何一个业务环节，稍微问深一点，一定露馅，为什么要给自己挖这样的坑呢？难道扎扎实实拿自己的项目来介绍，就真的找不出一点值得拿出来说道的亮点吗？
二、短视频上瘾综合症 ​ 其实我觉得这两个学员非常有代表性，就是对技术没有一点点敬畏之心，对自己几斤几两也没有一点标准。反倒是天天看些互联网上的短视频，不知道从哪里找一些犄角旮旯的问题，出来吹嘘一下，就恨不得人人都是架构师了，吹着吹着连自己是谁都忘了。我称之为短视频上瘾综合症，症状主要有以下几条：
1、技术越来越浮夸
​ 最近这两年，我一个做培训的都很明显的感觉到接触到的学员技术都越来越菜了。这可能也跟经济下行的大环境有关。但凡有点技术基础的，现在都越来越谨慎，能混就混着，不愿意多花钱培训了。但是，菜也就算了，不是我担心的问题。真正让我越来越烦的是，现在很多学员，还越来越钻牛角尖了。
​ 比如关于各种各样的MQ产品，我之前提出过一个观点，说Kafka的消息安全性其实不如RocketMQ，所以不建议在金融领域使用Kafka。在我看来，这本是一个无关紧要的个人观点，也无所谓对错。但是，最后硬是有好几个学员不断地跟我提意见，反正就是想要说我的观点是错误的，网上都说了Kafka的消息安全性是很高的。撸起袖子好一通输出，大有我不认错，就要跟我扛到底的架势。
​ 然后，与这些较真的朋友形成鲜明对比的是这样的。画风突变。
​ 好歹天天写Java代码的，RocketMQ这样一个Java写的产品，竟然不知道怎么跑。学习技术本来就是要循序渐进的，我真不觉得这点基础都没搞定，就想着直接跳过。非要去学RocketMQ，甚至还要看源码，这有什么用。更重要的是，这时候怎么不较真了？课上有演示，网上有资料，搞不定几个Linux指令？你真要沉下心来解决问题，这么点东西，还至于浪费一天的时间？
​ 为啥这样？其实大家都心知肚明。因为网上各种各样的短视频，全都喜欢讨论类似于消息安全这一类虚头巴脑的问题，这些问题有流量。但是，扎扎实实学技术，一点就透的这些问题，没人讨论。你要不是花钱报了我们的培训班，试试去问问别人。只怕还真没几个人愿意搭理你。
2、心态越来越浮躁
​ 这源自于我之前发的一段视频。之前发了一段视频，为了能够尽量全面又简短的讲明白OAuth2.0协议，我整理了一个二十来分钟的短视频。结合各大互联网开放平台的实际业务场景，加上示例代码，一点点的铺设OAuth协议的技术场景以及解决问题的思路。然后，我收到一个很有代表性的评价。“老师，这么长的视频，根本看不下去啊”。然后，自然是拿出了一堆五分钟、十分钟的OAuth介绍视频，说他们这讲得多好多好，动画多么花里胡哨，技术说得多么浅显易懂。这时我这才深刻发现，现在这帮人的耐心已经被短视频洗脑得连二十来分钟都接受不了了。就这个耐心，别说还劝你们自己写写代码，巩固巩固了，能够把我的示例代码导入到IDEA里跑起来，估计都够呛。
​ 先不说别人出这些流量视频对质量是不是有要求，单说看视频这样人。五分钟、十分钟你就相信能跟着他们把一个东西给学会了？那你这工作经验是不是也太不值钱了一点？你真靠网上那些三五分钟一个的面试八股文就能通过面试找到好工作的话，那别人要超过你，不是也就分分钟的事情了？等你人到中年，都不用等公司淘汰，你自己就把自己给淘汰了。
3、目标越来越悲观
​ 说到这，也不得不提现在的中年危机。这也是很多学员的主旋律。天天大喊环境不好，天天各种花样的说Java崩盘了，Java程序员没前途了，要么躺平混日子，要么转行去送快递。其实为啥总是有这样的论调？背后的逻辑全是流量。只有这样的话题能够提供情绪价值，能够抓住你的眼球，仅此而已。
​ 其实说句实在话，大环境好不好，跟我们大多数人有什么关系？你我如果都是普通人，祖上没权，家里没矿的这种，那就好好保住自己的饭碗就完了。大环境好的时候，你拿到的只是一份工作，那么大环境不好了，你要的不也只是一份工作吗？所谓环境啊，民生啊的问题，自然有吃这碗饭的那些人去操心。以Java为例，网上再怎么鼓吹Java崩盘了。但至少，整个市场还在，那么多大项目，不可能全部退出。国内第一开发语言的地位，还是无法撼动的。有时间操心大环境，不如在你摸鱼偷懒，做些低效率重复功能的时候，多想想怎么提升自己的竞争力。花点钱，报个靠谱的培训班，这或许就是你最应该做的事情。
​ 有人说网上曝光各种培训班割韭菜。你希望你家小孩学游泳，就是在水里瞎扑腾两下。我们小时候都是扔河里，淹不死自然就学会了的东西，现在城市里哪个不得去报个班？怎么？到你自己学习，就应该白嫖了？我们培训机构帮你提供一系列的服务，帮你省时省力，学得更轻轻更有效率。最后有几个自己不努力的，学了半年连个Linux的基础指令都没学会的，出来录几个视频，打滚喊冤，说找不到工作，这就叫割韭菜？你不会真的希望是个培训班，就能把你家小孩培养成潘展乐吧？
​ 网上这帮人这样喊喊也就算了。要么送快递博同情，要么躺平炫耀自己混得好。为啥喜欢这样说？无非都是为了流量，找些有情绪价值的问题说说。但是，你们一个个把自己活成了流量是为什么？傻不傻？你怎么不看看这样搞流量的，背后在买设备，学视频剪辑，学平台规则，学变现方法，花时间花精力在一直坚持，才能出那么点流量呢？你们天天盯着短视频，流口水傻笑的功夫，在坚持什么呢？
​ 我们这有个学员。早几年大环境比较好的时候进的一家互联网企业，在当时火热的大数据部门。后来这两年大环境不好了，企业的业绩下滑非常快。没有业务支撑，大数据部门也就没什么价值了。后来整个部门直接全部被裁了。很多人怨声载道，甚至有拉横幅去公司楼顶抗议的。但是，他们部门经理，技术牛逼，转头就换了家公司，转行去做区块链了。薪资不但没降，甚至还翻了好几倍。这靠的就是平时默默的积累。而那个学员，在大数据部门，和几个同事一起鼓捣了一个底层的IM框架。当时这东西，一看就是应用场景也比较少，除了做IM没别的地方用，属于费力不讨好的项目。很多别的业务线，看到有这么个省事的东西，也就直接拿来用了。结果等到大数据部门真的被裁时，才发现大数据分析可以没有，但是IM这个项目不能停。最后就是他们项目组的几个人，被合并到了云原生部门，闷声保住了饭碗。
所以，有时间跟这些短视频耗着。不如想想你真的要什么吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77c73f896d23eac6fdb840ba17da9e0a/" rel="bookmark">
			【第十届泰迪杯数据挖掘挑战赛A题害虫识别】-农田害虫检测识别-高精度完整更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 农田害虫检测识别项目-高精度完整版 一、说明： 该版本为基于泰迪杯完整害虫数据重新制作数据集、优化增强数据集、重新进行模型训练，达到高精度、高召回率的最优模型代码。包含论文、最优模型文件以及相关文件、原始数据集、训练数据集XML版、增强扩充数据集、处理过程代码、保姆级教程视频 二、效果展示 训练模型结果：
三、项目完整介绍 项目说明： 利用附件1和附件2的信息，建立确定害虫位置及种类的模型和算法。
应用问题1所建立的模型和算法对附件3中提及的图像进行识别，并确定害虫的位置，将结果存放在“result2.csv”文件中（模板文件见附件4中的result2.csv）。
根据问题2得到的结果，对附件3中提及的图像文件中不同种类的害虫数量进行统计，将统计结果存放在“result3.csv”文件中（模板文件见附件4中的result3.csv）。
数据集介绍： 1、原始数据集（附件一）：
包含3015张图片。其中有害虫标签的图片为576张，804张为待测图片、剩余图片为background
给出图片害虫坐标csv（附件二）：
2、制作训练集data：
通过代码处理制作xml标注的文件。真实查看清晰的图片标注情况
3、数据增强扩充数据集：
通过代码、软件等工具进行数据增强扩充处理，因为一共有28种类别，所以原来训练集的576张图片不够，所以必须扩充数据。
4、模型训练参数配置：
python train.py --device 0 --weights ./weights/yolov5s.pt --cfg ./models/yolov5s.yaml --data ./data/hc.yaml --batch-size 4 --imgsz 1280 --epochs 100 --name hc_v1-b4_1280_100epo 预测结果展示： 四、完整更新版获取： 【腾讯文档】葡萄技术服务小店（商品列表） https://docs.qq.com/sheet/DWG9DSUpQcnVsZlZZ?tab=BB08J2 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b764c997d42d9aa258f722f8de682829/" rel="bookmark">
			postgresql 您要的日期查询都在这
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、获取当前日期2、查询今天的数据3、查询昨天的数据4、查询一个月内的数据5、按日, 周, 月, 季度, 年统计数据6、 查询昨天、上周、上月、上年的日期7、查询今天、今月、今年的开始的日期时间8、查询最近1秒，1分，1小时，1天，1周（7天），1月，1年的记录9、从时间戳中提取 年月日时分秒、周 1、获取当前日期 select now(); select current_timestamp; 返回值均是当前年月日、时分秒，且秒保留6位小数，两种方式等价
select current_time; 返回值：时分秒，秒最高精确到6位
select current_date; 返回值：年月日
2、查询今天的数据 SELECT * FROM 表名 WHERE 时间字段 &gt;= current_date AND 时间字段 &lt; current_date + 1; 3、查询昨天的数据 SELECT * FROM 表名 WHERE 时间字段 &gt;= current_date - 1 AND 时间字段 &lt; current_date; 4、查询一个月内的数据 SELECT * FROM 表名 WHERE 时间字段 &gt;= current_date - interval '1 month' AND 时间字段 &lt;= current_date; 5、按日, 周, 月, 季度, 年统计数据 select date_trunc('DAY', 时间字段) as statisticTime, 分组字段, count(0) from 表名 GROUP BY date_trunc('DAY', 时间字段), 分组字段 日: DAY; 周: WEEK; 月: MONTH; 季度: QUARTER; 年: YEAR
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b764c997d42d9aa258f722f8de682829/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21e70536c568efcb8f9b3abcdd81457e/" rel="bookmark">
			spring 不一样的整合fastjson
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、什么是fastjson2、pom.xml 配置3、全局WebMvcConfig配置5、闭坑指南 1、什么是fastjson fastjson是阿里巴巴开发的一个高性能的Java JSON处理库，它支持将Java对象转换成JSON格式，同时也支持将JSON字符串解析成Java对象。 2、pom.xml 配置 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.79&lt;/version&gt; &lt;/dependency&gt; 3、全局WebMvcConfig配置 package com.gis.fastjson.config; import com.alibaba.fastjson2.JSONReader; import com.alibaba.fastjson2.JSONWriter; import com.alibaba.fastjson2.support.config.FastJsonConfig; import com.alibaba.fastjson2.support.spring.http.converter.FastJsonHttpMessageConverter; import org.springframework.context.annotation.Configuration; import org.springframework.http.MediaType; import org.springframework.http.converter.HttpMessageConverter; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; import java.nio.charset.StandardCharsets; import java.util.Collections; import java.util.List; @Configuration public class WebMvcConfig implements WebMvcConfigurer { @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { FastJsonHttpMessageConverter converter = new FastJsonHttpMessageConverter(); //custom configuration FastJsonConfig config = new FastJsonConfig(); config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21e70536c568efcb8f9b3abcdd81457e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/78/">«</a>
	<span class="pagination__item pagination__item--current">79/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/80/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>