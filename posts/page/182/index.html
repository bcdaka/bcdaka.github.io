<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4c0fe43782a631e759cf8cab1204554/" rel="bookmark">
			【数据结构】单链表：数据结构中的舞者，穿梭于理论与实践的舞池
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到白刘的领域 Miracle_86.-CSDN博客 系列专栏 数据结构与算法 先赞后看，已成习惯 创作不易，多多支持！ 一、链表的概念和结构 1.1 链表的概念 在上一篇文章中，我们了解了线性表(linear list)，并且学习了其中一种线性表——顺序表(Sequence List)。链表也是线性表的一种，那么它是一种什么样的结构呢？
链表，顾名思义，带着链子的表。日常生活中，我们知道链子是用来链接两个东西的，那么我们可以很容易理解，顺序表是基于数组实现的，是一个元素一个元素挨着的，那链表我们就可以理解为每个元素用链子连接起来，这样就形成了链表(Linked List)。
1.2 链表的结构 那么我们得到了两个链表的组成的关键元素，一个是每个元素，我们管它叫节点(或结点)，另一个就是那个链子。而在C语言中，我们用结构体来实现节点，用指针来充当链，连接两个节点。
在生活中链表类似于我们的火车的结构，在物理上它是一种存储结构非顺序非连续的结构。
节点的组成主要由两个部分组成：一个是数值域，用来保存当前节点的数据，一个是指针域，用来保存下一个节点的地址(指针变量)。
如图所示，指针变量plist保存的是第一个节点的地址，如果我们想让plist指向第二个节点，我们只需要将plist保存的内容修改为0x0012FFD0。
为什么我们需要指针变量来保存下一个节点的位置？
因为之前我们说了，链表不同于顺序表，它在内存中的地址不一定是连续的，它是独立申请的(对其插入数据时才申请一个节点)。我们需要通过指针才能从当前节点找到下一个节点。
所以我们可以通过一个结构体来实现一个节点，它要有一个节点的数据以及一个指针变量来保存下一个节点的地址，代码如下：
struct SListNode { int data; //节点数据 struct SListNode* next; //指针变量⽤保存下⼀个节点的地址 }; 当然我们也可以用typedef来进行修改，方便我们后续操作。
typedef int SLTDataType; typedef struct SListNode { SLTDataType data; //节点数据 struct SListNode* next; //指针保存下⼀个节点的地址 }SLTNode; 我们如何将链表进行打印呢？
首先我们将节点传到打印函数，然后我们创建了一个指向头结点的结构体指针，利用循环从头遍历到尾，每次打印完成令pcur指向pcur的next节点。这里注意的就是结构体成员的访问的问题，我们用到了-&gt;操作符，在前面的博客我们都介绍过。
武器大师——操作符详解（下）-CSDN博客
代码如下：
void SLTPrint(SLTNode* phead){ SLTNode *cur = phead; while(cur){ printf("%d ",cur-&gt;data); cur = cur-&gt;next; } printf("\n"); } 二、单链表的实现 上面我们知道了什么是链表，那单链表又是什么呢？单链表(Singly Linked List)，一般所指的是“不带头单向不循环链表”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4c0fe43782a631e759cf8cab1204554/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ba26338c9a42c565f9ad3aeb686dd00/" rel="bookmark">
			3款自己电脑就可以运行AI LLM的项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AnythingLLM、LocalGPT和PrivateGPT都是与大语言模型（LLM）相关的项目，它们允许用户在本地环境中与文档进行交互，但它们在实现方式和特点上存在一些差异。AnythingLLM使用Pinecone和ChromaDB来处理矢量嵌入，并使用OpenAI API来实现其LLM和会话功能。
AnythingLLM 由Mintplex Labs Inc.开发的开源工具，旨在创建个人或企业的私有化本地知识库。它通过结合大模型基于RAG（Retrieval-Augmented Generation）检索增强来实现知识库的检索和生成。AnythingLLM支持多用户使用，并可以设置权限管理，支持多种文档类型，如PDF、TXT、DOCX等，并提供简易的文档管理界面。此外，它还支持多种LLM、嵌入模型和向量数据库，允许用户通过对话或搜索的方式进行问题回答和摘要生成。
文档地址：https://docs.useanything.com/
LocalGPT 一个允许用户在本地设备上使用GPT模型与文档进行聊天的项目。它是受original privateGPT启发的项目，使用Vicuna-7B模型和InstructorEmbeddings代替了LlamaEmbeddings。LocalGPT可以在GPU上运行，但也支持CPU，尽管在CPU上运行可能会比较慢。LocalGPT利用LangChain工具来解析文档并创建嵌入，然后将其存储在本地向量数据库中，使用Chroma向量存储。它使用本地LLM来理解问题并创建答案，从文档中提取答案的上下文。
文档地址：https://github.com/PromtEngineer/localGPT
PrivateGPT PrivateGPT 是一个结合了高效能语言处理与强大隐私保护的先进语言模型平台。它基于OpenAI的GPT架构，提供了API，支持正常响应和流式响应。
文档地址：https://docs.privategpt.dev/overview/welcome/introduction
PrivateGPT的主要功能包括：
隐私保护：PrivateGPT在用户输入提示中删除超过50种类型的人可识别信息（PII），然后将这些信息重新填充到生成的回答中，以确保用户体验的无缝性和安全性。
本地化运行：PrivateGPT可以在本地环境中运行，无需上传数据到互联网或与他人分享，从而保护数据隐私。
多种应用场景：PrivateGPT可以应用于多种场景，包括在线聊天机器人、自动邮件回复、文章生成、代码生成等。此外，它还可以用于文本生成、问答系统、自动摘要、情感分析等多种自然语言处理任务。
智能写作：PrivateGPT可以帮助创作者快速草拟文章框架，生成创意内容。
开源项目：PrivateGPT是一个开源项目，用户可以通过Python开发环境构建自己的个性化GPT-4模型，并且无需任何编码或技术知识即可使用。
数据控制能力：PrivateGPT具备完整的数据控制能力，使用户能够在本地环境中与强大的语言模型进行交互，确保数据的私密性和安全性。
PrivateGPT不仅提供了一个高效的语言模型平台，还通过隐私保护和本地化运行等特性，满足了现代企业在数据隐私和安全方面的严格要求。
总的来说，AnythingLLM、LocalGPT和PrivateGPT都提供了一种方式，使用户能够在本地环境中与文档进行交互，保护数据隐私，同时利用大语言模型的能力。不同之处在于它们所使用的具体技术栈、支持的硬件、以及用户界面和权限管理等方面。
LocalGPT与PrivateGPT都要求本地运行LLM，对本地机器有一定的要求，AnythingLLM就稍微轻量一些，本地电脑不必运行LLM也能使用LLM带来的益处。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d71f3022d29739dbbf208bf64c67948/" rel="bookmark">
			ZGC在三色指针中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ZGC基于颜色指针的并发处理算法 ZGC初始化之后，整个内存空间的地址视图被设置为Remapped，当进入标记阶段时的视图转变为Marked0（也称为M0）或者Marked1（也称为M1），从标记阶段结束进入转移阶段时的视图再次设置为Remapped。ZGC通过视图的切换加上SATB算法实现并发处理。具体算法如下。
1．初始化阶段
在ZGC初始化之后，此时地址视图为Remapped，程序正常运行，在内存中分配对象，满足一定条件后垃圾回收启动
2．标记阶段
第一次进入标记阶段时视图为M0，在标记阶段，应用程序和标记线程并发执行，那么对象的访问可能来自标记线程和应用程序线程。
标记线程：它从根集合开始标记对象，在标记前先判断对象的地址视图，如果发现对象的地址视图是M0，说明对象是在进入标记阶段之后新分配的对象或者对象已经完成了标记（对象活跃），无须处理。如果发现对象的地址视图是Remapped，说明对象是前一阶段分配的，而且通过根集合可达，所以把对象的地址视图从Remapped调整为M0。（M0表示活跃）应用程序线程如果创建新的对象，则对象的地址视图为M0。
如果应用程序线程访问对象并且对象的地址视图是Remapped，说明对象是前一阶段分配的，按照SATB的算法，只要把该对象的视图调整为M0就能防止对象漏标。只标记应用线程访问到的对象还不够，实际上还需要把对象的成员变量所引用的对象都进行递归标记。如果应用线程访问对象地址视图是M0，说明对象是在进入标记阶段之后新分配的对象或者对象已经完成了标记，无须额外处理，直接访问。 所以，在标记阶段结束之后，对象的地址视图要么是M0（活跃），要么是Remapped（垃圾）。这里的虚拟地址虽然不一样，但是指向的是物理内存的同一个区域
所有标记为M0的对象放入活跃信息表
3．并发转移阶段
标记结束后就进入转移阶段，此时地址视图再次被设置为Remapped。
转移阶段会把活跃对象转移到新的内存中，并回收对象转移前的内存空间。在转移阶段，应用程序和标记线程并发执行，那么对象的访问可能来自转移线程和应用程序线程。
转移线程：转移线程仅仅根据活跃对象进行转移。当转移线程访问对象时：
如果对象在对象活跃信息表中并且视图为M0，则转移对象，并且视图从M0调整为Remapped。
如果对象在对象活跃信息表中并且视图Remapped，说明对象已经被转移，无须处理。
应用程序线程如果创建新的对象，则对象的地址视图为Remapped。
如果应用线程访问对象且不在活跃信息表中，则说明是新创建的或者对象无须转移，无须处理。
如果应用线程访问对象且在活跃信息表中且视图为Remapped，说明对象已经被转移，无须处理。
如果应用程序线程访问在对象活跃信息表中，且视图为M0，说明对象是标记阶段标记的活跃对象，所以需要转移对象
在对象转移以后，对象的地址视图从M0调整为Remapped；
注意，只把应用线程读到的对象进行转移还不够，实际上还需要把对象的成员变量所引用的对象都进行转移，ZGC对这一实现做了优化，由转移线程完成对象成员变量的转移。
至此，ZGC的一个垃圾回收周期中，并发标记和并发转移就结束了。
我们提到在标记阶段存在两个地址视图M0和M1，上面的算法过程显示只用到了一个地址视图，为什么设计成两个？简单地说是为了区别前一次标记和当前标记。
第一次垃圾回收时地址视图为M0，假设标记了两个对象ObjA和ObjB，说明ObjA和ObjB都是活跃的，它们的地址视图都是M0。在转移阶段，ZGC是按照页面进行部分内存垃圾回收的，也就是说当对象所在的页面需要回收时，页面里面的对象需要被转移，如果页面不需要转移，页面里面的对象也就不需要转移。
假设ObjA所在的页面被回收，ObjB所在的页面在这一次垃圾回收中不会被回收。ObjA被转移后，它的地址视图从M0调整为Remapped，ObjB不会被转移，ObjB的地址视图仍然为M0。
那么下一次垃圾回收标记阶段开始的时候，存在两种地址视图的对象
地址视图为Remapped的对象，说明该对象在并发转移阶段被转移或者被访问过；地址视图为M0的对象，说明该对象在前一次垃圾回收的标记阶段已经被标记。 如果本次垃圾回收标记阶段仍然使用M0这个地址视图，那么就不能区分出对象是活跃的，还是上一次垃圾回收标记过的。
所以新标记阶段使用了另外一个地址视图M1，则标记结束后所有活跃对象的地址视图都为M1。
此时这3个地址视图代表的含义是：
M1：本次垃圾回收中识别的活跃对象。M0：前一次垃圾回收的标记阶段被标记过的活跃对象，对象在转移阶段未被转移，但是在本次垃圾回收中被识别为不活跃对象。Remapped：前一次垃圾回收的转移阶段发生转移的对象或者是被应用程序线程访问的对象，但是在本次垃圾回收中被识别为不活跃对象。 上述过程算法演示 image.png
image.png
image.png
作者：西部小笼包
链接：https://www.jianshu.com/p/664e4da05b2c
这个介绍比较详细
ZGC 详解 - 简书
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/339f1d9a0f7bbee7dcae1c2a9b76322f/" rel="bookmark">
			【C语言小知识】ctype.h系列的字符函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ctype.h系列的字符函数 链接: ctype.h 在代码中，本意是将字符转换，但过程中标点也会被转换，这是因为对应的ASCII码会被相对应的转换，如果程序值转换字母，保留所有的非字母字符（不是空格会更好）。
C语言中有一系列专门处理字符的函数，ctype.h头文件包含了这些函数的原型。
这些函数接受一个字符作为参数，如果该字符属于某特殊的类别，就返回一个非零值（真）；否则，返回0（假）。
#include&lt;stdio.h&gt; #include&lt;ctype.h&gt; int main() { char ch; while ((ch = getchar()) != '\n') { //判断：如果是一个字符 if (isalpha) { putchar(ch + 1); } else { putchar(ch); } putchar(ch); } return 0; } 以isalpha()函数举例，如果isalpha()函数的参数是一个字母，则返回一个非零值。
表1：ctype.h头文件中的字符测试函数 函数名如果是下列参数时，返回值为真isalnum()字母数字（字母或者数字）isalpha()字母isblank()标准的空白字符（空格、水平制表符或换行符）或任何其他本地化指定为空白的字符iscntrl()控制字符，如Ctrl+Bisdigit()数字isgraph()除空格之外的任意可打印字符islower()小写字符isprint()可打印字符ispunct()标点符号（除空格或字母数字字符以外的任何可打印字符）isspace()空白字符（空格、换行符、换页符、回车符、垂直制表符、水平制表符或者其他本地化定义的字符）isupper()大写字母isxdigit()十六进制数字符 表2：ctype.h头文件中的字符映射函数 函数名行为tolower()如果参数是大写字符，该函数返回小写字符；否则，返回原始参数toupper()如果参数是小写字符，该函数返回大写字符，否则，返回原始参数 表1和表2列出了ctype.h头文件中的一些函数，有些函数设计本地化，指的是为适应特定区域的使用习惯修改或者扩展C基本用法的工具。（例如，许多国家在书写小数点时，用逗号代替点号，于是特殊的本地化可以指定C编译器使用逗号以相同的方式输出浮点数）
【注意】字符映射函数不会修改原始的参数，这些函数只会返回已经修改的值，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/225cbea2792487797df8a0a66c588411/" rel="bookmark">
			【Stable Diffusion】来了来了！属于SDXL的ControlNet模型它终于来了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		千呼万唤始出来！就在昨天，WebUI的ControlNet1.1.4版本终于更新，这次的更新支持了SDXL1.0的模型。我怀着兴奋的心情，打开了网站开始下载模型。这次总共出了四种控制类型，分别是Canny、Depth、Sketch和Openpose。
来到Hugging Face的网址：https://huggingface.co/lllyasviel/sd_control_collection/tree/main。可以看到这里有相当多的模型，当然，我们不需要全部都下载下来，因为它们之间有很多功能是重复的，是不同的作者做出来的。
但是呢，为了帮你们提前踩雷，我把他们全部都下载了，而且逐个做了测试，看到我这么辛苦的份上，你们一定会要给我一个“点赞”和“在看”的吧。
接下来，让我们来分类看一下吧。
#Canny硬边缘
首先是canny，它有几个不同的型号，体积越大，速度越慢。
我使用的是4080ti的笔记本进行的测试，12G显存。
模型sdxl base+refiner
提示词：masterpiece,best quality,1girl
采样方法：euler a
尺寸1024*1024
使用diffusers的2.5Gfull模型绘制的图片，一张图花了2分57秒，从这个效率上来看，这个大尺寸基本可以弃了。
使用diffusers的320Mb的small模型，用时34s，质量上差距不大，主要是时间优势很明显。
我们可以再看看其他作者的，这张是kohya的，用时33秒，更接近真实质感。
sai的canny分为128lora和256lora，分别用时39秒和1分08秒，这个模型比较偏绘画的感觉。
最后还有一个t2i的canny模型，用时34s，也是偏插画一点。
你们觉得哪个效果更好呢？时间上基本都在30秒以上，如果关掉refiner的话，能节省一半左右的时间，平均在17秒左右。
#Depth深度
接下来测试一些depth模型，图形尺寸664*1024。
使用diffusers的full模型，用时2分48秒，sdxl给我随机到了一个拼贴画的风格。
使用diffusers的small模型，用时23s。
使用kohya模型，用时42秒。这……好像和我的图片没什么关系。
使用sai模型，用时1分12秒，画质还可以，稍微有点慢。
Sketch草图
接下来测试一下sketch模型，画一只可爱的小猫，图形尺寸1024*624。
使用kohya模型，用时30秒，这是个啥？？？
使用sai模型，没找到小猫具体的位置，用时32秒，画质还可以。
使用t2i模型，用时28秒，唯一一个准的。
Openpose骨架
最后测试一下openpose模型，图形尺寸1024*624。
使用kohya模型，画很好看，但姿势不对，用时40秒。
感兴趣的小伙伴，赠送全套AIGC学习资料，包含AI绘画、AI人工智能等前沿科技教程和软件工具，具体看这里。
AIGC技术的未来发展前景广阔，随着人工智能技术的不断发展，AIGC技术也将不断提高。未来，AIGC技术将在游戏和计算领域得到更广泛的应用，使游戏和计算系统具有更高效、更智能、更灵活的特性。同时，AIGC技术也将与人工智能技术紧密结合，在更多的领域得到广泛应用，对程序员来说影响至关重要。未来，AIGC技术将继续得到提高，同时也将与人工智能技术紧密结合，在更多的领域得到广泛应用。
一、AIGC所有方向的学习路线 AIGC所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照下面的知识点去找对应的学习资源，保证自己学得较为全面。
二、AIGC必备工具 工具都帮大家整理好了，安装就可直接上手！
三、最新AIGC学习笔记 当我学到一定基础，有自己的理解能力的时候，会去阅读一些前辈整理的书籍或者手写的笔记资料，这些笔记详细记载了他们对一些技术点的理解，这些理解是比较独到，可以学到不一样的思路。
四、AIGC视频教程合集 观看全面零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
五、实战案例 纸上得来终觉浅，要学会跟着视频一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d68ba3a0a8000e210deb51d09358c5b7/" rel="bookmark">
			【MySQL】MySQL连接池原理与简易网站数据流动是如何进行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL连接池原理与简易网站数据流动是如何进行 1.MySQL连接池原理2.简易网站数据流动是如何进行 点赞👍👍收藏🌟🌟关注💖💖
你的支持是对我最大的鼓励，我们一起努力吧!😃😃
1.MySQL连接池原理 目前我们对mysql有了一定的理解，下面我们谈一下，mysql在网站或者公司内部一套存储方案它定位的问题。
实际上在开发的时候把表结构各方面设计好了，接下来要做的不是写各种各样的sql，在做开发的时候，是先要连接数据库的。而我们会发现连接数据库的时候每一次连的都是先创建数据库对象然后connet用完之后要把释放把连接关掉，这种执行一条sql这种就把连接关了这是一种短连接，并且挺浪费的。
所以mysql在网站和数据库之间，除了一些缓存方面的技术，还有一个在编码层面上的技术叫做 连接池。
那这个连接池如何理解呢？
以前是这样做的，需要就连接一下连接之后返回，返回之后就断开。而实际上我们可以自己设计一个连接池的小组件，它可以预先让多个线程预先和mysql建立好连接，建立好连接之后不动就一直处于连接的状态，我们可以把sql语句封装成任务扔到连接池中，然后就可以把任务交给连接池中的线程。一定是这个线程启动的时候就绑定或者关联了mysql连接资源，说白了不就是给线程设计一个类，线程内部里在创建MYSQL对象。在线程池构造线程的同时把MYSQL对象也构建除了。线程启动之后就把mysql连接连上，连上之后线程不就进入自己的事件主循环，然后我们就可以直接用这个连接了。
那这个玩意怎么做呢？
如果在Linux学过线程池的话非常简单，这个连接池内部其实只需要维护一个任务队列就可以。这个连接池里面创建线程池今天还需要加上MYSQL对象，每一个线程给它搞一个MYSQL对象，这个创建MYSQL对象可以当作线程类的类内成员，当初始化线程就可以把对应的MYSQL对象也初始化出来。当启动线程之后也把mysql连接建立好，这样每一个线程都有自己mysql的句柄，都维护了自己的连接。然后线程进入等待任务到来的死循环中不断从任务队列中拿任务，有任务就拿没任务就在条件变量下去等。我们未来就可以通过任务队列把任务下达下去。
上层可以构建任务task类，里面可以包含两个成员一个是string sql，还有一个回调函数function cb。比如我现在是一个调用方，我要向mysql服务器下达一个delete指令，所以写一个delete 的sql语句然后把它构建成一个task，然后把这个task扔到连接池的任务队列里，然后线程就可以从任务队列里拿到任务，然后拿到对应任务的线程不是有msyql连接吗，就可以去执行mysql_query，把task对象中的sql拿出来交给mysql_query执行。线程池预先创建，连接池预先创建，所以就避免了重新建立连接的动作，所以此时一旦拿到task之后就给对mysql下达sql指令了。
为什么任务类里面放一个回调函数fuction？
这是因为我们自己的模块可以有一个函数A。如果向mysql增加删除更新还好说，但是读取的时候我们需要把结果拿到。线程拿到这个sql执行之后，然后多做一个动作看看这个fuction是否存在，如果没有那执行完sql就真的完了。如果设置了然后线程池继续回调这个fuction把我们查询出来的结果通过回调拿回来。这个回调就是我们曾经构建task把自己的方法函数A绑定到task里面的function，所以数据就被拿回来了。
所以我们可以用这种想法去设计成一个连接池。
2.简易网站数据流动是如何进行 一个用户逻辑是怎么走的？以注册和登录为例。
现在有一个服务器上面搭载了一个网站，然后还有一台服务器上面搭载了内网中的mysql。这个服务器上面一定要搭建http：nginx或者业务型的tomcat。现在有一个用户向网站发起一个注册请求，然后这个网站给你回应一个注册页面。然后把对应信息填完就提交。可能用的是GET或者POST方法把数据提交给了服务器，在服务器内部它可能会用一些web语言 比如说php，python，java，然后就可以把你提交的这些数据进行提取出来。然后判断你这是注册，所以就把你的数据构建成sql直接提交到mysql里，自此这个用户信息就被记录到用户表里了。但直接和数据库打交道太慢了， 其次一般公司数据库服务可能存在多份，所以它可能存在后端接入多个数据库。那这个网站怎么去选择用那个数据库呢？那就需要一个中间键，可以用一些效率更到的语言如C/C++等。这个构建成sql不用直接交道数据库了，直接先交给它。然后它内部做一些负载均衡，选择把记录插入数据库。这些数据库会定期做数据的互相同步，然后数据就都有了。
所以网站根本不关心后端有多少数据库，我们把数据库集群化。这里就出现这么多数据库选择那一个。你也不用管了，这个时候就在这两个模块之间添加一层软件层。这就是在计算机学科任何的问题都可以通过加一层软件来解决。所以加软件层来解决对应的问题。
然后别人想登录，登录也是一样的要进行请求登录页面，然后就返回登录页面，然后输入用户名和密码接下来就以POST或者GET方法提交上来，然后怎么去验证这个用户呢？所以还是提取后构建一个sql语句，把这个sql通过服务下达给后端的数据库。可以根据负载均衡随便去找个数据库，因为数据是同步的。然后就去查，查完后把查询结果返回，只要有结果说明这个用户是合法，然后就可以在服务器层面给它形成各种cookie，session这样的信息。另外我们在访问页面时可能会有一些高频热度的数据我们可以在加一些缓存之类的，比如说Rides之类的。所以在查数据时不一定要去数据库里查，而先到缓存里，有的话直接从缓存里返回。没有的话就去访问mysql。
这就是一个网站整个初步的逻辑就是这个样子的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20c3d6f86b4e33b875e99a906049bd9d/" rel="bookmark">
			【基础算法总结】分治—归并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分治—归并 1.排序数组2.交易逆序对的总数3.计算右侧小于当前元素的个数4.翻转对 点赞👍👍收藏🌟🌟关注💖💖
你的支持是对我最大的鼓励，我们一起努力吧!😃😃
1.排序数组 题目链接：912. 排序数组
题目描述：
算法原理：
归并排序的核心思想就是，选一个中间节点，将数组分成左右两区间，先将左边排排序相当于又是一个归并过程，选一个中间节点然后在把左边排序，当区间只有一个元素就可以向上返回。左边拍完序，在对右边排排序，当左右排好序后在合并，选择小的插入，然后拷贝回原数组。
快速排序就是选择一个key将数组分块，然后左右继续指向数组分块的核心操作，当数组被分成一个元素或者没有元素就结束分块。
所以说快排和归并非常类似，无非就是处理数组时间不一样。归并画成树就是一个后序，先处理左在处理右然后将左右合并，快排就是一个前序，先把数组分两块，然去搞左边，左边还是找一个key然后分成左和右。。。
class Solution { public: vector&lt;int&gt; tmp; vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) { int n = nums.size(); tmp.resize(n); Mergesort(nums, 0, n-1); return nums; } void Mergesort(vector&lt;int&gt;&amp; nums, int left, int right) { if(left &gt;= right) return; // 1. 选择中间点划分区间 int mid = left + (right - left) / 2; //[left ,mid] [mid+1, right] // 2.把左右区间排序 Mergesort(nums, left, mid); Mergesort(nums, mid + 1, right); // 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20c3d6f86b4e33b875e99a906049bd9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74eafe7341f1efafe18144c057f10009/" rel="bookmark">
			9个用于测试自动化的最佳AI测试工具（2024）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选择一款优质的基于生成式AI人工智能的测试工具能够确保测试过程的准确性和效率，从而加速整个软件测试周期。相反，设计不佳的测试工具可能无法发现错误，并可能存在安全问题。它们可能产生误报或漏报，误导开发与测试团队，导致潜在的软件故障。
testRigor testRigor是一个基于人工智能的工具，允许用户用简单的英语编写测试。开发人员和测试人员很容易简化测试用例开发过程。人工智能的存在也使维护过程自动化，确保更好的准确性。
此AI工具使测试web或移动应用程序变得更顺畅。它提供了自我修复和真实设备测试等功能，并可以与CI/CD完美集成。
功能特点：
生成AI测试：使用testRigor生成AI检测选项来自动创建和执行测试用例。testRigor的AI界面可以识别错误并建议修复，以提高软件的性能。
无代码测试：它允许自动化测试过程，而无需构建那些复杂的编码结构。作为一个非技术用户，我可以用普通英语编写指令来测试软件应用程序。
无脚本自动化：使用testRigor的无脚本自动化环境，可以更快地创建测试，而无需任何脚本和编码方面的专业知识。
机器学习集成：机器学习技术的包含使你更容易在软件开发周期中识别缺陷。
自动化测试创建：testRigor自动化并简化测试创建、执行和维护过程。
2FA登录支持：支持登录的双因素认证（2FA），增强测试环境的安全性和访问控制。可以使用电子邮件、文本消息或Google Authenticator进行身份验证。
API测试：该工具允许你在不需要手动编码的情况下执行API测试，确保了服务和集成正常工作。
模拟API调用：它为你提供了模拟API调用的功能，能够测试应用程序中每个部分的响应。
唯一测试数据：testRigor使你能够快速生成符合指定格式或Regex的唯一测试数据，这种灵活性使你能够轻松准确地验证数据驱动的应用程序。
优点：
它允许你在最终上传之前在特定模板上创建文件。
该工具具有可视化测试功能。
支持Shadow DOMS、iframes和混合应用程序。
官方网址：
https://testrigor.com/
Global App Testing Global App Testing是一种用于进行无法自动化的复杂功能和UX测试的工具。简易启动板连接到后端服务，旨在帮助产品主管和QA专业人员更好地理解他们的软件和GenAI输出。GAT被包括谷歌、微软和Facebook在内的企业软件组织使用，使其成为全球、专业或操作复杂测试的流行选择。
功能特点：
190个国家和160种语言的GenAI测试：使用GAT平台要求测试人员查找几乎任何国家或语言的漏洞、问题和其他问题。
比较即时执行：通过比较结构化流程中的即时结果，比较国家、环境、格式或竞争对手之间的即时执行。
对抗性GenAI使用：让专业人员试图操纵你的GenAI产品，使其违反特定准则或产生一般性的问题材料，以确定恶意产品使用的结果。
上下文评估：UX测试，可以评估你的产品解决用户问题的能力；可用性测试，以确定用户成功的难易程度。
操作复杂测试：适用于设计用于远离桌面的GenAI工具，使用空间和位置数据，结合物理硬件元素等。
与TestRail、Jira等集成：继续使用你已经使用该平台进行的测试；从TestRail中启动你的提示或测试用例，并且在错误发生的地方，选择通过单击将它们导出到Jira中。
根据专业风格指南进行测试：获得具有专业知识的测试人员，以便在重要的用例和上下文中对GenAI应用程序提供真正的反馈。
优点：
190多个国家和语言。
测试仪多样性保证应用程序质量。
适合任何团队成员的简易测试生成器。
官方网址：
https://www.globalapptesting.com/
LambdaTest LambdaTest是一个人工智能驱动的测试执行平台，支持使用可扩展的云基础架构进行大规模手动和自动化测试。有了LambdaTest，开发人员和测试人员可以通过利用AI增强的HyperExecute来增强测试，HyperExecute提供了各种AI驱动的功能，如测试编排，该功能可以优化测试分发。
该平台还提供根本原因分析（RCA），以更快地解决问题和高级片状测试检测，允许定制和深入了解测试脆性。
功能特点：
人工智能支持的测试编排：自动跨环境分组和分发测试，根据过去的故障进行优先级排序，以便更快地识别。
人工智能支持的视觉测试：通过自动化网站、移动应用程序和PDF的视觉测试，确保UI的一致性。
基于人工智能的根本原因分析：对错误进行分类并提供修复方案，以加快问题解决。
片状测试检测和定制：提供人工智能驱动的洞察力，以识别和管理片状测试，提高测试套件的可靠性。
错误分组和分类：对测试日志中的错误进行分类和分组，以有效地确定问题的优先级并解决问题。
分析测试用例：提供对测试用例的洞察，以增强分析和定制。
私有云部署支持：允许测试在私有云中运行，使用历史数据优化测试过程。
优点：
在Linux容器上提供端到端的测试自动化。
提供智能测试编排功能，包括测试的自动分割、不稳定测试的自动重试等。
允许YAML驱动的测试编排。
官方网址：
https://www.lambdatest.com/
BlinqIO BlinqIO是一种基于人工智能的软件测试工具，具有强大的测试框架。它提供了详细的分析，以简化软件开发过程。
使用BlinqIO来测试软件工具的性能。它帮助你在开发阶段识别错误，以便你可以纠正和优化软件解决方案。
功能特点：
虚拟测试自动化工程师：虚拟测试自动化工程特性允许你在不编写任何代码的情况下自动创建和执行测试。它节省了大量的时间和精力，否则将在手动测试中浪费。
实时分析：BlinqIO的仪表板让你即时了解你的模型的性能。
自动测试：这个基于人工智能的工具具有自动测试套件，可以在测试期间节省质量时间。使用这个工具，你可以在工具自动化基本任务的同时，更专注于核心测试过程。
集成功能：BlinqIO与现有的CI/CD无缝集成。
可定制的测试场景：你可以根据特定的用例定制测试。
可扩展性测试：该功能测试AI应用程序，以确保其功能负载能力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74eafe7341f1efafe18144c057f10009/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44db405afbf1c4b4112ce1c0fa06c2cf/" rel="bookmark">
			Java基础-Java中的常用类（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(创作不易，感谢有你，你的支持，就是我前行的最大动力，如果看完对你有帮助，请留下您的足迹）
目录
String类
创建字符串
字符串长度
连接字符串
创建格式化字符串
String 方法
System类
常用方法
方法介绍
getProperties（）
currentTimeMillis（）
arraycopy（）
Scanner类
使用 next 方法：
使用 nextLine 方法：
next()与nextLine()区别
String类 字符串广泛应用在Java编程中，在Java中字符串属于对象，Java提供了String类来创建和操作字符串。
创建字符串 创建字符串最简单的方式如下:
String greeting = "Hello world!"; 在代码中遇到字符串常量时，这里的值是"Hello world!"，编译器会使用该值创建一个String对象。
和其它对象一样，可以使用关键字和构造方法来创建String对象。
String类有11种构造方法，这些方法提供不同的参数来初始化字符串，比如提供一个字符数组参数:
public class StringDemo{ public static void main(String args[]){ char[] helloArray = { 'h', 'e', 'l', 'l', 'o', '.'}; String helloString = new String(helloArray); System.out.println( helloString ); } } 以上实例编译运行结果如下：
hello. 注意:String类是不可改变的，所以你一旦创建了String对象，那它的值就无法改变了。 如果需要对字符串做很多修改，那么应该选择使用StringBuffer &amp; StringBuilder 类。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44db405afbf1c4b4112ce1c0fa06c2cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8088fd58bfd3f57fa5712fdb342782ff/" rel="bookmark">
			ASO优化不仅仅是苹果商店，安卓商店同样不可忽视
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家一谈起ASO优化，不少人反应大多数都是IOS市场的优化，其实安卓也是不可分割的大市场，在国内手机应用市场，安卓的用户质量在稳步提高，因此开发者也越来越重视安卓市场的推广。做好安卓ASO也是非常必要的。
一、安卓市场的背景
目前国内安卓市场主要分为第三方应用市场和手机厂商应用市场两部分。
第三方市场主要有：应用宝、360手机助手、百度手机助手等。第三方应用市场对APP类型的限制较小，应用总量和装机量较大，如果你的应用使用感不好，又没有能力做ASO优化的话，很容易被淹没在众多应用的汪洋大海里。（目前3大第三方市场仅剩应用宝还有一些流量并且可以优化，其他2家基本已经没落）
手机厂商应用市场主要有：华为、小米、VIVO、OPPO、魅族等。手机厂商应用市场他们一般对APP的上架把控比较严格，产品的质量要求比较高，一些功能简单或者相同应用泛滥的APP是不能通过审核的。
二、安卓的基础优化
无论是第三方应用市场还是手机厂商应用市场基础ASO优化都需要做好标题、关键词、评价与反馈等信息。
标题和副标题 确保标题简洁明了且包含关键词，副标题应该提现APP的主要功能和优势。这有助于用户在搜索时快速找到你的应用。 2.关键词
通过工具分析用户搜索习惯、竞品关键词和行业热门词汇，选择与APP相关且能吸引用户的关键词。
3.评价与反馈
及时处理并回应用户的评价和反馈展现开发者的积极态度和责任感，对于负面评价，诚恳解释原因并提出改进措施。并且通过应用内提示和奖励机制等方式鼓励用户给出正面评价，提升应用的评分和口碑。
ASO优化也是一个持续的过程，需要不断努力和改进。同时提供优质的应用体验是吸引用户并保持他们长期使用的关键。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a0dfa2a177343eec0d7132eaf7fc967/" rel="bookmark">
			AIGC时代程序员的跃迁——编程高手的密码武器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是herosunly。985院校硕士毕业，现担任算法研究员一职，热衷于机器学习算法研究与应用。曾获得阿里云天池比赛第一名，CCF比赛第二名，科大讯飞比赛第三名。拥有多项发明专利。对机器学习和深度学习拥有自己独到的见解。曾经辅导过若干个非计算机专业的学生进入到算法行业就业。希望和大家一起成长进步。今天给大家带来的是AIGC时代程序员的跃迁——编程高手的密码武器，希望能对同学们有所帮助。
在这个迅速变化的时代，AI技术已经渗透到我们生活的方方面面，尤其是在软件开发领域。
我们作为《AIGC辅助软件开发：ChatGPT 10倍效率编程实战》一书的团队，也是在实践AIGC中积累了大量的经验， 和大家一同分享。
AIGC除了在文字对话，生成文档方面有突出的表现，它渊博的知识，也为解决很多项目中的疑难问题提供了极大的帮助。以下给大家分享真实项目中发生的例子。
案例 利用ChatGPT解决实际转码HDR视频为SDR视频出现颜色失真的疑难问题。
在苹果手机高端机型默认开启HDR视频作为拍摄视频的模式后， 我们的一款APP便收到用户的使用反馈，上传到APP的视频，打开查看时颜色变得很暗淡。通过iOS开发工程师找到对应机型进行调试和分析，发现在用户上传了HDR视频时会出现颜色失真的状况。当时APP的方案时在用户上传视频前进行转码，为了最大兼容Android系统和iOS系统，视频转码为SDR视频。
失真的视频见如下的对比图：
图1 用户上传视频转码前后对比 图2 开发工程师实际测试视频转码前后对比 图1和图2 的左侧是HDR原始视频，右图是转码后的视频，可以见到颜色差别很大。
非专业音视频开发来说，这个问题卡了我们比较久。我们尝试过各种各样的解决方案，咨询过专业处理视频的朋友，也没有很好解决这个问题。直到ChatGPT的横空出现，我们重新尝试利用ChatGPT来解决。
现在回过头来总结，ChatGPT于我们而言，就是一位专家。从提出问题到解决问题，只用了6轮对话。第7、8轮对话进一步提升了视频转码的性能。下面为大家呈现怎么利用ChatGPT解决视频转码失真问题的过程。
首先，工程师找到APP对用户上传视频的转码命令，原代码为：
这段代码为调用ffmpeg命令对原始视频进行转码为h264编码的视频格式。
在当前信息化飞速发展的时代，多媒体处理技能越来越受到广泛的重视。对于非音视频专业的程序员而言，ffmpeg这一强大而复杂的工具经常让人感到无从下手。它拥有众多的指令参数，每一个参数都有其特定的用途和设置方法，这无疑增加了学习和使用的难度。过去，没有合适的辅助工具，这几乎是一项艰巨的工程。然而，随着人工智能技术的发展，特别是ChatGPT的出现，这一情况得到了根本性的改变。ChatGPT不仅可以理解复杂的ffmpeg命令，还能根据用户的具体需求提供定制化的指令建议。这意味着，即使是非专业的开发者，也可以轻松掌握并有效使用ffmpeg进行音视频处理，大大降低了技术门槛，提升了工作效率。
根据AI的具体指引，拿到了视频的详细信息，然后发送给AI：
到了这一步后，以上的指令已经完成需求了，视频没有失真了，感叹AI的神奇疗法，节约了成吨的时间，但是在实际测试中发现，转码过程比较缓慢，6s的视频几乎花费了15s才转码完成，这效率其实是不能接受的，如果是一分钟，十分钟的视频转码，那简直无法想象，还得继续优化。
大概了解了每个参数的作用之后，我们就可以通过人工修改可以完成这个需求：把-preset slower改成-preset faster；把-b:v 3000k去掉，采用默认值；把-crf 16改成-crf 25。
最终指令如下：
目前转码效率提高几倍，6s视频花费3～4s转码完成，转码后的视频质量也非常不错。
总的来说，AI在编程领域对程序员的帮助还是很大的，不会在每个方面帮助都大，但是在特定方面帮助尤其大，比如以上例举的两个例子：学习新技术，解决技术栈层次更深的问题，这可以解决大量的时间去查阅资料，去理解视频转码的每个参数的意思，尤其视频转码参数众多，理解每个参数都得花费不少的时间，还得挨个组合测试，总之，一级棒。
以上是《AIGC辅助软件开发：ChatGPT 10倍效率编程实战》的一个例子，书中记录了涵盖客户端、前端、后端、测试以及项目各个阶段环节应用ChatGPT提效的案例记录。这本书不仅适合技术专业人员阅读，也适合所有对AI在实际工作中应用感兴趣的读者。
通过真实的开发案例和详尽的技术解析，《AIGC辅助软件开发：ChatGPT 10倍效率编程实战》将帮助你充分利用人工智能的潜力，解决编程中遇到的各种难题。这本书是每一个软件开发者书架上必备的宝典。欢迎阅读，开启你的高效编程之旅！
本文作者：李柏锋__ 信息工程背景的富有创造力的技术专家，梅沙科技联合创始人和首席技术官，原腾讯高级工程师。关注并实践Al，致力于Al应用到实际的生产力提升，以及探索Al在业务中的应用。参与编写并出版了《编程真酷》、《AIGC辅助软件开发：ChatGPT10 倍效率编程实战》等技术专业___书籍。_____
文章来源：IT阅读排行榜
本文摘编自《AIGC辅助软件开发：ChatGPT 10倍效率编程实战》，机械工业出版社出版，经出版方授权发布，转载请标明文章来源。
延伸阅读
《AIGC辅助软件开发：ChatGPT 10倍效率编程实战》
李柏锋、兰军、张阳 等著
AI时代程序员自救指南
阅读本书，先人一步实现能力跃迁
10余位资深IT技术专家在AIGC辅助软件开发领域的一手经验总结
内容简介：
这是一本讲解如何用ChatGPT、GitHub Copilot X、Cursor等主流AIGC工具优化和提升软件开发全流程效率和质量的实战性著作。
全书以软件开发的流程位主线来组织内容，详细讲解了程序员、架构师、项目经理、产品经理、技术团队管理者们如何在技术方案构建、需求文档撰写、代码编写与注解、客户端开发、前端开发、后端开发、测试和调试、性能优化、疑难问题解决、产品设计、软件架构与设计、应试与面试12个主题充分发挥AIGC工具的潜能，在提高研发效率和质量的同时，提升自身的实力。
购买链接：https://item.jd.com/14617898.html
直播预告
7月11日周四19：00，《AIGC辅助软件开发：ChatGPT 10倍效率编程实战》作者团队李柏锋、兰军、周博**，**三位嘉宾与您分享“以一顶十，AIGC时代程序员的跃迁”，点击预约观看！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51c118539c37c878db360a69fe9b74fd/" rel="bookmark">
			国内仅存的3个完美替代Google安卓商店的APP与网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Google安卓商店在国内访问限制，部分谷歌商店镜像站点也相继受限，现分享目前仍可在国内顺畅使用的应用程序商店与网站资源，请大家且用且珍惜。
2024年7月8日国内验证有效的资源 F-Droid 简介：F-Droid，专注于开源软件的纯净应用商店。
特点：网站响应迅速，支持中文界面，每一款都经过精心筛选的开源免费软件。
APP下载：https://wwm.lanzoub.com/b00rn6tkah 密码:7shg
androeed 源自俄罗斯，下载速度快，内容虽没有Google Play丰富，但是更新非常及时。
malavida 内容丰富虽然在下载速度上略逊于androeed，但其在应用内容上几乎可以媲美Google Play。
wandoujia 作为国内知名的应用下载平台，凭借其无需额外安装APP即可在线获取应用的便捷性，赢得了众多用户的青睐。
2024年7月8日国内验证需借助VPN访问 APKPure 简介：作为备受欢迎的免费安卓应用商店，APKPure汇集了众多Google Play上的热门软件资源。
特点：提供网页版与APP双重选择，下载迅速，应用更新及时。
APKMirror 简介：APKMirror被誉为Android APK下载的优选之地，专注于提供官方版本的APK文件。
特点：由Android Police团队运营，确保了网站的安全性与稳定性。
Aurora Store 简介：Aurora Store是一款完全免费且开源的应用程序商店，完美兼容原生安卓系统，无需Google Mobile Services（GMS）也能流畅运行。
特点：界面清爽，操作简便，下载速度快，并支持多语言，为用户带来极佳的使用体验。
APP下载：https://wwm.lanzoub.com/b00rn6tkah 密码:7shg
以上网站的下载链接请到公众号 获取，这里不允许提供
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d1ec64a4c17bace87fd04bb32d23fa6/" rel="bookmark">
			【DFS（深度优先搜索）详解】看这一篇就够啦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【DFS详解】看这一篇就够啦 🍃1. 算法思想🍃2. 三种枚举方式🍃2.1 指数型枚举🍃2.2 排列型枚举🍃2.3 组合型枚举 🍃3. 剪枝优化🍃4. 图的搜索🍃5. 来几道题试试手🍃5.1 选数🍃5.2 火柴棒等式 🚀欢迎互三👉： 2的n次方_💎💎
🚀所属专栏：数据结构与算法学习⭐⭐
🍃1. 算法思想 DFS算法的基本思想是从图中的某个顶点v出发，访问此顶点，然后依次从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到。若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，整个进程反复进行直到所有顶点都被访问为止。
从上图中可以直观的感受到这种思想
就是一条路走到黑的思想，走到无路可走再回退到上一层，再选择另一条路继续一直走，再回退，直到整个遍历完成，深度优先搜索一般是通过递归来实现的，“递”的过程就是往下搜的过程对应着深度，“归”的过程就是回溯，回退上一级
🍃2. 三种枚举方式 🍃2.1 指数型枚举 指数型枚举是指一共有n个数，每一个数都有两种状态，也就是选或不选，时间复杂度也就是2^n，指数级的
例如3个数的枚举时，每一个数都有选和不选两种状态，可以根据这个画出递归搜索树
接着用代码实现一下
#include &lt;iostream&gt; using namespace std; int n; int vis[20]; void dfs(int x){ //表示已经n个数都被判断过了，一种方案已经搜索完成 if(x &gt; n){ for(int i = 1;i &lt;= n;i++){ if(vis[i] == 1) cout&lt;&lt;i&lt;&lt;" "; } cout&lt;&lt;'\n'; return; } vis[x] = 2;//表示不选 dfs(x+1);//继续搜下一个 vis[x] = 0;//回溯 vis[x] = 1;//表示选 dfs(x+1);//继续搜下一个 vis[x] = 0;//回溯 } int main(){ cin&gt;&gt;n; dfs(1); return 0; } 🍃2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d1ec64a4c17bace87fd04bb32d23fa6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48407e6265455a418ae294c534673aa0/" rel="bookmark">
			快速上手：前后端分离开发（Vue&#43;Element&#43;Spring Boot&#43;MyBatis&#43;MySQL）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言项目简介环境准备第一步：初始化前端项目登录页面任务管理页面 第二步：初始化后端项目数据库配置数据库表结构实体类和Mapper服务层和控制器 第三步：连接前后端总结 🎉欢迎来到架构设计专栏~探索Java中的静态变量与实例变量
☆* o(≧▽≦)o *☆嗨~我是IT·陈寒🍹✨博客主页：IT·陈寒的博客🎈该系列文章专栏：架构设计📜其他专栏：Java学习路线 Java面试技巧 Java实战项目 AIGC人工智能 数据结构学习🍹文章作者技术和水平有限，如果文中出现错误，希望大家能指正🙏📜 欢迎大家关注！ ❤️ 前言 随着互联网技术的迅速发展，前后端分离已经成为现代Web开发的主流模式。这种模式不仅提高了开发效率，还使得前端和后端各自独立，便于维护和升级。本文将详细介绍如何使用Vue、Element、Spring Boot、MyBatis和MySQL实现一个简单的前后端分离项目。通过本文的学习，你将能在20分钟内掌握这种开发模式的基本实现方法。
项目简介 我们的项目是一个简单的任务管理系统，包含以下功能：
用户注册和登录任务的增删改查 项目结构如下：
前端：Vue.js + Element UI后端：Spring Boot + MyBatis数据库：MySQL 环境准备 在开始之前，请确保你已经安装了以下工具：
Node.js（建议使用LTS版本）Vue CLIJava JDK 8或以上MavenMySQL 第一步：初始化前端项目 首先，我们使用Vue CLI初始化一个Vue项目。
vue create task-manager 选择默认配置后，进入项目目录并安装Element UI。
cd task-manager vue add element 然后，创建一个简单的登录页面和任务管理页面。
登录页面 在src/views目录下创建Login.vue文件：
&lt;template&gt; &lt;div class="login"&gt; &lt;el-form :model="form" @submit.native.prevent="handleLogin"&gt; &lt;el-form-item label="用户名"&gt; &lt;el-input v-model="form.username"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="密码"&gt; &lt;el-input type="password" v-model="form.password"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48407e6265455a418ae294c534673aa0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a792bafbfe84a8451f27312ff358cabd/" rel="bookmark">
			macbook触控栏养宠物：Touchbar pet for Mac 免费下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		macbook pro自从出了touchbar后，看起来是十分的炫酷，但平时却很少有人使用，为了让touchbar充分利用起来，Touch bar pet就横空出世了，可爱的画风，简单的玩法，让你可以在touchbar上也可以养一只自己的宠物！
下载地址：点击下载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32c94a33063a3972b54fe7347dcbf8cc/" rel="bookmark">
			【EI稳定检索】第五届大数据、人工智能与软件工程国际研讨会（ICBASE 2024）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&gt;&gt;&gt;【独立出版，Ei稳定检索】&lt;&lt;&lt; 第五届大数据、人工智能与软件工程国际研讨会（ICBASE 2024） 2024年09月20-22日 | 中国温州
一轮截稿时间：2024年7月8日
二轮截稿时间：2024年8月5日
大会简介
*会议官网：www.icbase.org 第五届大数据、人工智能与软件工程国际研讨会（ICBASE 2024）将于2024年09月20-22日在中国温州隆重举行。会议主要围绕大数据、人工智能与软件工程等研究领域展开讨论。会议旨在为从事大数据、人工智能与软件工程研究的专家学者、工程技术人员、技术研发人员提供一个共享科研成果和前沿技术，了解学术发展趋势，拓宽研究思路，加强学术研究和探讨，促进学术成果产业化合作的平台。大会诚邀国内外高校、科研机构专家、学者，企业界人士及其他相关人员参会交流。
*ICBASE 2024已进入中国学术会议在线推荐列表：Click
组织单位
主办单位：温州理工学院、加拿大圭尔夫大学
承办单位：温州理工学院数据科学与人工智能学院、加拿大圭尔夫大学工程学院
协办单位：广东省艾思信息化学术交流研究院、AEIC学术交流中心
支持单位：加拿大圭尔夫大学工程学院高级机器人与智能系统实验室
征稿主题
大数据分析、深度学习、机器学习、人工智能、模式识别、数据挖掘、云计算技术、物联网、AI应用于物联网、聚类和分类、软计技术、自然语言处理、电子商务和电子学习、无线网络、网络安全、大数据联网技术、在线数据分析、序列数据处理、基于图像数据分析、信号处理；其他相关主题均可
投稿参会可查看https://ais.cn/u/rqy2U3，更多可咨询何秘书，16782275466（微信同号）
EI会议论文出版
为保证本次会议的学术质量，吸引更多的原创高水平学术论文，现公开征稿，欢迎从事相关专业的专家学者、科研人员、高校师生踊跃投稿，最终所有录用的论文将以论文集的形式提交出版，见刊后由出版社提交至EI, Scopus检索。
同时也欢迎暂无论文但对会议感兴趣的社会各界人士参加会议。
参会方式
1、作者参会：一篇录用文章允许一名作者免费参会；
2、主讲嘉宾：申请主题演讲，由组委会审核；
3、口头演讲：申请口头报告，时间为15分钟；
4、海报展示：申请海报展示，A1尺寸，提交电子版文件至会议邮箱contact@icbase.org；
5、听众参会：不投稿仅参会，也可申请演讲及展示；
6、报名参会：本会议由艾思科蓝支持在线报名
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a714e6e69c783866786eb48adbda846/" rel="bookmark">
			Java异常详解及自定义异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		认识异常，掌握异常处理主要的5个关键字：throw、try、catch、final、throws并掌握自定义异常
目录
1、异常概念与体系结构
1、1异常的概念
1、2异常体系结构
1、3异常的分类
编译时异常：
运行时异常 ：
2、异常处理
2、1防御式编程
2、2异常的抛出
2.3 异常的捕获
2.3.1 异常声明throws
2.3.2 try-catch捕获并处理
2.3.3 finally 3、自定义异常类
1、异常概念与体系结构 1、1异常的概念 在Java中，将程序执行过程中发生的不正常的行为称为异常。
比如写代码经常遇到的：
算数异常 System.out.println(10 / 0);
// 执行结果 Exception in thread "main" java.lang.ArithmeticException: / by zero
数组越界异常 int[] arr = {1, 2, 3};
System.out.println(arr[100]);
// 执行结果 Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 100
空指针异常 int[] arr = null;
System.out.println(arr.length);
// 执行结果 Exception in thread "main" java.lang.NullPointerException
从上述过程中可以看到，java中不同类型的异常，都有与其对应的类来进行描述。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a714e6e69c783866786eb48adbda846/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e76bc7dfd22eb9365f6c128405fce86/" rel="bookmark">
			Python前沿技术：机器学习与人工智能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python前沿技术：机器学习与人工智能 一、引言 随着科技的飞速发展，机器学习和人工智能（AI）已经成为了计算机科学领域的热门话题。Python作为一门易学易用且功能强大的编程语言，已经成为了这两个领域的首选语言之一。本文将深入探讨Python在机器学习和人工智能领域的应用，以及一些前沿技术和工具。
二、Python机器学习基础 2.1 机器学习概述 机器学习是人工智能（AI）的一个关键子集，它的核心在于让计算机系统能够从数据中自主学习并做出决策，而无需进行明确的编程指令。这种学习方式模拟了人类从经验中学习的能力，但以数学和统计模型为基础。机器学习的应用领域广泛，涵盖了从图像识别、语音识别到复杂系统预测和自动化决策等各个方面。
2.1.1 监督学习 监督学习是机器学习中最常见也是最直观的一个框架。其核心思想是通过已标记的数据集训练模型，以便对新的未标记数据进行预测。在Python的Scikit-learn库中，我们可以使用各种监督学习算法，如线性回归、决策树、支持向量机等，来处理分类和回归问题。
例如，使用Scikit-learn实现一个简单的决策树分类器：
from sklearn.tree import DecisionTreeClassifier from sklearn.model_selection import train_test_split from sklearn.datasets import load_iris # 加载数据集 iris = load_iris() X = iris.data y = iris.target # 划分训练集和测试集 X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # 创建决策树模型 model = DecisionTreeClassifier() # 训练模型并预测 model.fit(X_train, y_train) predictions = model.predict(X_test) 2.1.2 无监督学习 与监督学习不同，无监督学习处理的是未标记的数据。它的目标是发现数据中的模式和结构，常用算法包括聚类、主成分分析（PCA）等。这些算法在市场细分、社交网络分析等领域有着广泛的应用。例如，Python中的Scikit-learn库提供了K-means聚类算法，该算法通过迭代计算数据点与中心点的距离来将数据划分为不同的群集。
2.2 Python机器学习库 Python有许多强大的机器学习库，其中最著名的是Scikit-learn。以下是一个简单的线性回归示例：
from sklearn.linear_model import LinearRegression from sklearn.model_selection import train_test_split import numpy as np # 生成数据 X, y = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e76bc7dfd22eb9365f6c128405fce86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6a2839e3b3c1575b452dff2e05b446c/" rel="bookmark">
			【前端】css控制背景图片缩放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在CSS中，控制背景图片的缩放主要依赖于background-size属性。这个属性允许你指定背景图片的尺寸，包括是否保持其原有的宽高比。background-size可以接受不同的值来控制图片的缩放方式。
常用的background-size值 auto：默认值。背景图像保持其原有的尺寸。
cover：背景图像被缩放以完全覆盖容器区域，但可能会裁剪图像以保持宽高比。
contain：背景图像被缩放以在容器中完全显示出来，可能会留下空白（边或角），但图像不会裁剪。
&lt;length&gt;：你可以指定背景图像的确切宽度和高度（例如background-size: 100px 200px;），但这种方式可能不会保持图像的宽高比。
&lt;percentage&gt;：你也可以使用百分比来指定背景图像的尺寸，这相对于元素的尺寸（例如background-size: 50% 100%;），这种方式同样可能会破坏图像的宽高比。
示例 假设你有一个div元素，你想要将其背景图片缩放以覆盖整个元素区域，可以使用以下CSS：
div { width: 300px; height: 200px; background-image: url('your-image-url.jpg'); background-size: cover; /* 缩放背景图片以完全覆盖div */ background-position: center; /* 将背景图片居中显示 */ } 在这个例子中，background-size: cover;确保背景图片被缩放以覆盖整个div区域，而background-position: center;确保图片在缩放后仍然居中显示。
如果你想要保持图片的宽高比，并且确保图片完整地显示在div中（可能留下空白），则可以使用contain值：
div { background-size: contain; /* 缩放背景图片以完整显示在div中，可能会留下空白 */ } 注意 当使用cover或contain时，CSS会自动调整图片的宽度和高度以符合指定的条件，而不会破坏图片的宽高比。当你指定具体的尺寸（如像素值或百分比）时，需要小心处理图片的宽高比，以避免图片看起来失真。在某些情况下，你可能还需要使用background-position属性来调整图片在容器中的位置。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f1cc1d76604622291fea836110eb1ac/" rel="bookmark">
			6. C&#43;&#43;中默认成员函数【取地址重载】【const成员函数】 【运算符重载】【实现一个日期类】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、【C++】赋值运算符重载1.1 运算符重载【引入】1.2 运算符重载1.3 赋值运算符重载1.4 赋值 二、日期类的实现2.1 判断小于2.2 判断等于2.3 判断小于等于2.4 判断大于2.5 判断大于等于2.6 判断不等于2.7 日期加等天数首先要获取月份天数 2.8 日期加天数2.9 日期减等天数2.10 日期减天数 三、前置++ &amp;&amp; 后置++3.1 日期减日期【返回天数】3.2 流插入3.3 流提取3.4 检查输入日期是否合法 四、日期类的实现【源码】五、const修饰5.1 const成员函数5.2 小结一下：5.3 默认成员函数【取地址及const取地址操作符重载】 一、【C++】赋值运算符重载 1.1 运算符重载【引入】 C++为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数，也具有其返回值类型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。函数名字为：关键字operator后面接需要重载的运算符符号。函数原型：返回值类型 operator操作符(参数列表) 注意：
不能通过连接其他符号来创建新的操作符：比如operator@
重载操作符必须有一个类型参数【不能去重载运算符改变内置类型的行为】
用于内置类型的运算符，其含义不能改变，例如：内置的整型+，不 能改变其含义
作为类成员函数重载时，其形参看起来比操作数数目少1个，因为成员函数的第一个参数为隐藏的this
.* :: sizeof ?: . 注意以上5个运算符不能重载。这里的是.*，不是*，这里经常在笔试选择题中出现。
当我们写了一个日期类，有没有可能要比较比较呢？
class Date { public: Date(int year = 1900, int month = 1, int day = 1) { _year = year; _month = month; _day = day; } //private: // 一会有解决方法 int _year; int _month; int _day; }; 我们写了一个比较相等的函数，如果是传值的话没有必要，我们形参直接写成&amp;，而且也不需要修改，所以再加上const bool DateEquel(const Date&amp; x, Date&amp; y) { return x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f1cc1d76604622291fea836110eb1ac/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/181/">«</a>
	<span class="pagination__item pagination__item--current">182/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/183/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>