<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/775c358d8a6ae2a490cec1f073da9d6b/" rel="bookmark">
			C语言printf格式化打印（%d、%md、%f、%c、%s、%o、%x、%p、%e、%E、%n等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在我们以后接触到更多知识点时，类型这种东西其实也就不神秘了，我们在学习操作系统时，经常会见到各种各样的类型，如pid_t、in_port_t、int32_t、int16_t等等，这种一般都是经过typedef的，其实很多时候我们遇到不认识的类型时，就可以看其是否是经过typedef的，再进行格式化输出，但如果大家是学C++的同学，就不用担心了，C++的cout可以自动识别类型，其底层其实是做了运算符重载和函数重载的。
一、整型家族的格式化打印形式 我们要记住 signed ➕ 类型 《==》 单独的类型，如 signed int 《==》 int
所以下面会用 (signed) 来表示：可以省略不写
如果格式化输出的并不是类型匹配的格式，会发生隐式类型转换
1. int类型 （signed）int （有符号整型）———%d unsigned int (无符号的int类型)———%u size_t (无符号的int类型)————%zu单独的unsigned （unsigned int 的缩写）———— %u int a = 2; unsigned int b = 3; size_t c = 4; unsigned d = 5; printf("%d\n", a); printf("%u\n", b); printf("%zu\n", c); printf("%u\n", d); 2. long类型 unsigned（signed）long （有符号长整型）———%ld unsigned long (无符号的长类型)———%lu long a = 2; unsigned long b = 3; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/775c358d8a6ae2a490cec1f073da9d6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a727e3488caa3ca3915ac615eedcc1dd/" rel="bookmark">
			【保姆级教程】Linux上部署Stable Diffusion WebUI和LoRA训练，拥有你的专属图片生成模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 写在前面 Stable Diffusion 是当前最火热的图像生成模型之一，目前已经广泛应用于艺术创作、游戏开发、设计模拟等领域，因其开源生态和易于使用而受到创作者的广泛关注，相比 Midjourney 而言，其最大的优势是完全免费，且拥有庞大的社区资源。
如果需要本地部署 Stable Diffusion，首选 Stable Diffusion Webui。不过本地部署
对设备硬件要求还是比较高的，通常需要至少 4G 显存，有关如何在 Windows 上使用，社区已经有了非常不错的一键启动脚本。
如果需要一个稳定的服务，还是建议将其部署到云服务器上。
本文主要记录一下如何在 Linux 上部署 Stable Diffusion Webui，在把所有的坑都踩了一遍之后，希望对有类似需求的小伙伴有所帮助。
1 Stable Diffusion 1.1 什么是 Stable Diffusion Stable Diffusion 是一种生成式模型，所谓生成式模型也就是能够生成和训练集分布非常相似的输出结果，主流的生成式模型包含如下几类：
Stable Diffusion 是 Diffusion Model 的改进版，完整的Stable Diffusion网络结构应该包含三个部分：
自动编码器： 将图像从像素空间(Pixel Space)压缩到潜在空间(Latent Space)将潜在表示转换成最终图像 条件生成器： 生成去噪过程中依赖的条件(Conditioning)，条件包括文字和图像，对文字而言，最常见的是CLIP text encoder ，用于编码文字信息，控制生成对应文字描述的图像。 噪声估计模型UNet： 针对潜在空间的图片做扩散(Diffusion Process)：添加噪声编码用户输入的 prompt预测噪声，然后依据「去噪条件」去噪，生成图片的潜在表示
1.2 什么是 LoRA LoRA，即Low-Rank Adaptation，是一种轻量级的大模型微调方法，文本生成模型GPT 和 图像生成模型Stable-Diffusion，都可以采用LoRA 进行轻量级微调。它通过在模型的特定部分引入低秩结构来进行微调，从而减少了计算资源的需求。LoRA训练可以在保持模型原有性能的同时，对模型进行个性化调整，使其适应特定的应用场景。
LoRA的思想很简单，在原始模型旁边增加一个旁路，做一个降维再升维的操作。训练的时候固定原始模型的参数，只训练降维矩阵A与升维矩阵B。而模型的输入输出维度不变，输出时将BA与原始模型的参数叠加。
2 Stable Diffusion WebUI Stable Diffusion WebUI 为 Stable Diffusion 模型定制了友好的网页界面，基于 Gradio 实现，它让用户可以轻松地访问和使用 Stable Diffusion 的图像生成能力。有关 Windows 下如何使用，建议直接使用 B 站 @秋葉aaaki 的免费启动器和安装包。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a727e3488caa3ca3915ac615eedcc1dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3d4a365aadb0ecce649781f1b51aa07/" rel="bookmark">
			中级开发的经验之谈（redis篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 在我读书的时候，我曾经很喜欢redis，听了相关的分享、看了相关的博客、读了相关的书、看了喜欢的源码，然后我写了一个总结：《这是全网最硬核redis总结，谁赞成，谁反对？》六万字大合集
现在，这篇文章大概五万多阅读，三千多收藏，三千多点赞。
但是，随着时间的推移，我渐渐的有点看不上这篇文章，主要是觉得写的太多太全了，像流水账一样，好像什么都说了，又好像什么都没说。
所以，现在我有了一些开发经验，有了一些心得体会，我准备写一个浓缩全是精华的分享，写一个初中高级开发看了，都能有收获的分享。
本文主要是告诉你为什么我们使用redis，以及使用时可能遇到的问题。
下文括号中，都是我在公司讲课时，详细讲到的地方，非括号是文章正文。
二、简介 2.2 应用举例 1、延时队列（股票定投/）
2、布隆过滤器
缓存，解决本地缓存命中率太低的问题
（举例发布时读db超时挂掉）
三、性能好 3.1 数据结构 3.1.1 字典 字典，是一种用于保存键值对的抽象数据结构，在Redis中的应用相当广泛，比如Redis的数据库就是使用字典作为底层实现的，对数据库的增删改查等操作也是构建在对字典的操作之上。
特点：
使用的哈希算法：murmurhash，链表处理冲突
（哈希打单点事故的案例分享）
（即使输入的键是有规律的，算法仍能给出一个很好的随机分布性，计算速度非常快，使用简单。因此在多个开源项目中得到应用，包括libstdc、libmemcached、nginx、hadoop等。）
rehash
（元素个数=数组长度扩容/bgsave时五倍，小于10%缩容 1）为ht[1]分配合理空间。2）将ht[0]中的数据rehash到ht[1]上。3）释放ht[0]，将ht[1]设置为ht[0]，ht[1]创建空表，为下次做准备。）
渐进rehash （我们维持一个变量rehashidx，设置为0，代表rehash开始，然后开始rehash，在这期间，每个对字典的操作，程序都会把索引rehashidx上的数据移动到ht[1]。
随着操作不断执行，最终我们会完成rehash，设置rehashidx为-1.）
3.1.2 简单动态字符串（SDC） Redis没有直接使用C语言传统的字符串表示，而是自己构建了名为简单动态字符串（simple dynamic string ,SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。（除了保存数据库中的字符串值之外，SDS还被用作缓冲区，例如AOF的AOF缓冲区、客户端状态中的输入缓冲区等。）
struct sdshdr { int len;//buf已使用字节数量 int free;//未使用的字节数量 char buf[];//用来保存字符串的字节数组 }; 数据结构如图表示：
相对c的改进：
（1）常数复杂度获取字符串长度
（2）杜绝缓冲区溢出（这里是指相加的时候）
（3）减少修改字符串时带来的内存重分配次数（空间预分配、惰性空间释放）
（还有二进制安全之类的）
3.1.3 skiplist （Redis只在两个地方用到了跳跃表，一个是实现有序集合，另一个是集群节点中用作内部数据结构。）
跳跃表是一种有序数据结构，在大多数情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树更为简单，所以有不少程序使用跳跃表代替平衡树。
数据结构如图表示：
Redis为何不用红黑树？优越性和特殊性
todo：演示两个数据结构的操作
3.1.4 链表/整数集合/压缩列表 链表：带表头、双端无环、带长度记录、多态
整数集合：各个项在数组中从小到大有序排列，并且数组中不包含任何重复项。
压缩列表
占空间小，由一系列特殊编码的连续内存块组成的顺序型数据结构，为了节省空间，Previous_entry_length甚至大小可以变化
todo：数据结构精讲\布隆过滤器\HyperLogLog等
3.2 对象 3.2.1 组成 对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象五种类型的对象，每种对象都用到了至少一种前面介绍的数据结构。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3d4a365aadb0ecce649781f1b51aa07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9febe85e72454b17de0e282d376f851f/" rel="bookmark">
			【flutter项目实战】第九节 卡在 Running Gradle task ‘assembleDebug‘ 的无敌解决办法-全网首发-包解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先呢，这个教程，包解决卡住的问题 其次呢，这个问题是真的恶心人 正文开始 一，我们如何遇到这个问题？ 比如，我要引入一个包 package_info_plus
然后我们就去pub.dev 里 找到 install 去安装了
如题 package_info_plus: ^8.0.0
然后你点了运行，结果呢，一直在 Running Gradle task 'assembleDebug'
接下来你就开始疯狂百度了
不过，你很幸运，百度到了我
二，接下来，说正文 1.如何让我们知道怎么卡住了 这个问题出现以后，我们只能干等着，没有进度条吗？
答案就是：有
打开你的项目的：xxx(项目路径)\android\gradlew.bat
这个文件，其实就是你run以后它构建的内容
当你卡住了，你打开它，就会发现是这样的
这就是为什么卡住的原因
这个下载速度比便秘还难受！
2. 那我们如何处理这个问题 也很简单
打开这个网址：https://repo.maven.apache.org/maven2/org/jetbrains/
中央仓库：https://repo1.maven.org/maven2/
网易：http://maven.netease.com/repository/public/
华为云：https://repo.huaweicloud.com/repository/maven/
tencent：https://mirrors.cloud.tencent.com/repository/maven/
中国科技大学：http://mirrors.ustc.edu.cn/maven/maven2/
南京大学：http://maven.nju.edu.cn/repository/
清华大学：https://repo.maven.apache.org/maven2/
北京理工大学：http://mirror.bit.edu.cn/maven/
东软信息学院：https://mirrors.neusoft.edu.cn/maven2/
中国科学院开源协会：http://maven.opencas.cn/maven/
北京交通大学：http://maven.bjtu.edu.cn/maven2/
我们看到，卡住的jar包是kotlin-compiler-embeddable-1.7.22.jar
首先，开头是kotlin
那我们在目录里搜索 kotlin,然后打开目录 https://repo.huaweicloud.com/repository/maven/org/jetbrains/kotlin/
接下来，我们去掉版本号，内容是kotlin-compiler-embeddable,我们在当前目录搜索
然后打开目录:https://repo.huaweicloud.com/repository/maven/org/jetbrains/kotlin/kotlin-compiler-embeddable/
然后呢，根据版本号继续搜索 1.7.22
就可以下载了： https://repo.huaweicloud.com/repository/maven/org/jetbrains/kotlin/kotlin-compiler-embeddable/1.7.22/
注意，最后一步是搜索整个jar包：kotlin-compiler-embeddable-1.7.22.jar
一定要完全限定名，否则你。。算了，无所谓了，就这样吧
3. 不出意外的话，聪明的你已经下好了，接下来让它对号入座 第一步，打开你的Gradle目录，我配置了GRADLE_USER_HOME，你没有配置，一般在
C:\Users\用户名\.gradle下
第二步，找到对应目录
打开如下目录:.gradle\caches\modules-2\files-2.1\org.jetbrains.kotlin\
然后找到对应的jar包文件路径，实在找不到就搜kotlin-compiler-embeddable
第三步，放进去
你的目录可能是这样的，这个目录就是你即将和曾经用过的版本号
注意卡住的版本号是哪个，就打开哪个文件夹，我这里是1.7.22
打开后是这样的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9febe85e72454b17de0e282d376f851f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f2bf3af507c26da32164677890ba8a0/" rel="bookmark">
			数据仓库作业六：第9章 分类规则挖掘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 第9章 分类规则挖掘第一题第二题第三题第四题 第9章 分类规则挖掘 第一题 1、设网球俱乐部有打球与气候条件的历史统计数据如下表1所示。它有“天气”、“气温”、“适度”和“风力”4个描述气候的条件属性，类别属性为“是”与“否”的二元取值，分别表示在当时的气候条件下是否适宜打球的两种类别。
表1 打球与气候情况的历史数据样本集S 样本id天气温度湿度风力类别样本id天气温度湿度风力类别 X 1 X_1 X1​晴高大无否 X 8 X_8 X8​晴中大无否 X 2 X_2 X2​晴高大无否 X 9 X_9 X9​晴低小无是 X 3 X_3 X3​云高大无是 X 10 X_{10} X10​雨中小无是 X 4 X_4 X4​雨中大无是 X 11 X_{11} X11​晴中小有是 X 5 X_5 X5​雨低小无是 X 12 X_{12} X12​云中大有是 X 6 X_6 X6​雨低小有否 X 13 X_{13} X13​云高小无是 X 7 X_7 X7​云低小有是 X 14 X_{14} X14​雨中大有否 对 S S S 中的任意两个数据对象 X , Y X,Y X,Y，定义其在4个条件属性上的相异度为 d ( X , Y ) = ∑ j = 1 r δ ( x j , y j ) d(X,Y)=\sum_{j=1}^r\delta(x_j,y_j) d(X,Y)=j=1∑r​δ(xj​,yj​) 其中 x j , y j x_j,y_j xj​,yj​ 是数据对象 X , Y X,Y X,Y 的第 j j j 个分量值；如果 x j = y j x_j=y_j xj​=yj​， δ ( x j , y j ) = 0 \delta(x_j,y_j)=0 δ(xj​,yj​)=0，否则 δ ( x j , y j ) = 1 \delta(x_j,y_j)=1 δ(xj​,yj​)=1。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f2bf3af507c26da32164677890ba8a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b55f003031864fc50fad96c485cefa13/" rel="bookmark">
			C从零开始实现贪吃蛇大作战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人主页：星纭-CSDN博客
系列文章专栏 : C语言
踏上取经路，比抵达灵山更重要！一起努力一起进步！
有关Win32API的知识点在上一篇文章：WIN32 API
目录
一.地图
1.控制台基本介绍
2.宽字符
1.本地化
2.类项
3.setlocale函数
4.打印宽字符 3.地图坐标
二.游戏的结构设计
1.基础结构
2.游戏流程（未完成）
3.核心逻辑实现
1.游戏开始
1.控制台设置 2.欢迎界面 3.创建地图
4.初始化蛇
5.创建食物
4.游戏运行
1.打印信息
2.判断按键 3.蛇的移动
5.游戏结束 一.地图 这个游戏中，我们是通过控制台来完成的。首先就是需要完成这个地图。
1.控制台基本介绍 接下来介绍有关控制台窗口的一些知识点，当运行程序，需要在控制台上输出信息，打印的时候，第一个字符是在控制台最左上角打印的。我们将这个位置的坐标当作（0，0）.
​
横向的坐标轴称为x轴，从左向右依次增长，纵向的坐标轴是y轴，从上到下依次增长。
2.宽字符 普通的字符是占一个字节的，宽字符是占用两个字节的。
​
打印字符，不难发现，两个英文字符的宽度是等于一个中文字符的宽度的。 而且一个英文字符的高大概是其宽的两倍。
1.&lt;locale.h&gt;本地化 &lt;locale.h&gt;提供的函数用于控制C标准库中对于不同的地区会产生不一样行为的部分。
在标准中，以来地区的部分有以下几项：
数字量的格式货币量的格式字符集日期和时间的表示形式 2.类项 通过修改地区，程序可以改变它的⾏为来适应世界的不同区域。但地区的改变可能会影响库的许多部 分，其中⼀部分可能是我们不希望修改的。所以C语⾔⽀持针对不同的类项进⾏修改，下⾯的⼀个宏， 指定⼀个类项：
• LC_COLLATE：影响字符串⽐较函数 strcoll() 和 strxfrm() 。• LC_CTYPE：影响字符处理函数的⾏为。• LC_MONETARY：影响货币格式。• LC_NUMERIC：影响 printf() 的数字格式。• LC_TIME：影响时间格式 strftime() 和 wcsftime() 。• LC_ALL-针对所有类项修改，将以上所有类别设置为给定的语⾔环境。 参考：setlocale，_wsetlocale | Microsoft Learn 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b55f003031864fc50fad96c485cefa13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8a0731a65dfaf564a893a12da090d83/" rel="bookmark">
			Android USB通信（host转串口）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：公司属于北斗通信行业，项目大多都需要和各式各样的硬件设备相结合来满足项目需求，因此所涉及到的各种技术也相对比较冷门。前段时间有个项目用到了一款定制 Android 设备，其中有多个接口，包括两个 USB 接口和一个 RS232 串口，需要用到其中一个 USB 连接北斗设备实现指令互通，经过摸索现在也大致了解了 Android USB（host）通信流程后续还有另一个项目则用到了 USB（accessory）有空再写一篇。在这里记录和分享一下，有错漏或可优化之处欢迎大家留言。
一、导入模块 工具基于 github 上的串口工具库：usb-serial-for-android
1. 在项目级 build.gradle 文件添加 jitpack.io 库 maven { url 'https://jitpack.io' } 2. 添加依赖 implementation 'com.github.mik3y:usb-serial-for-android:3.4.6' 可能有更新的版本自行修改 3. 本地 2023年11月30日更新：最近把代码拉到家里的电脑准备在家办公时恰好停网了导致第三方库导入不了，于是就到工具库源码上把代码都拉到了本地，如果你也恰好遇到了这种情况也可以这样处理。这里顺手打包了一份，自己重新导入一下即可：https://download.csdn.net/download/lxt1292352578/88565529
二、上代码 DEMO：https://github.com/LXTTTTTT/USBtoSerialPortDemo
源码资源：https://download.csdn.net/download/lxt1292352578/88717549
复制再把报红的部分直接去掉或者换成自己的就能直接使用
package com.example.SecondProject.Utils.Transfer.USB; import android.app.PendingIntent; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.content.IntentFilter; import android.hardware.usb.UsbDeviceConnection; import android.hardware.usb.UsbManager; import android.os.Build; import android.util.Log; import android.widget.Toast; import com.example.SecondProject.Base.MainApplication; import com.example.SecondProject.BuildConfig; import com.example.SecondProject.Global.Constant; import com.example.SecondProject.Global.Variable; import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8a0731a65dfaf564a893a12da090d83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d61355bc011cfe1b5f02660007e90714/" rel="bookmark">
			Android 蓝牙通信（通过 BluetoothSocket 传输文件/文本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：Android 蓝牙通信，通过BluetoothSocket方式建立长连接并传输文本或文件。前段时间有个项目的功能需求是：AR眼镜通过蓝牙的方式连接北斗设备，当北斗设备收到文本/语音/图片消息时转发到AR眼镜上，AR眼镜也可以发送文本/语音/图片数据到北斗设备上并转发到指定的目标地址。刚开始在百度和github找了许多方法都不尽人意而且大多数据传输都仅仅停留在文字方面，不过好在最后临近项目deadline时想到了一种傻瓜也简单的方法实现了这个需求。如果你也恰好遇到了这种 "通过蓝牙或其他低效率的方式传输文件" 类似的情景可以参考这篇文章，希望这篇文章对你的思路有所启发，如果有错漏或可优化之处也欢迎提醒。
一、上代码 DEMO：https://github.com/LXTTTTTT/Android-Bluetooth-Chat-And-Transfer
源码资源：https://download.csdn.net/download/lxt1292352578/88677601
直接复制就能使用
package com.example.sockettransfer; import android.bluetooth.BluetoothAdapter; import android.bluetooth.BluetoothDevice; import android.bluetooth.BluetoothServerSocket; import android.bluetooth.BluetoothSocket; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.content.IntentFilter; import android.os.Environment; import android.util.Log; import org.greenrobot.eventbus.EventBus; import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.nio.charset.StandardCharsets; import java.util.ArrayList; import java.util.List; import java.util.Set; import java.util.UUID; import java.util.regex.Matcher; import java.util.regex.Pattern; // 蓝牙 Socket 工具 public class BluetoothSocketUtil { private static String TAG = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d61355bc011cfe1b5f02660007e90714/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10145d0865a372f46c3a71472ac30016/" rel="bookmark">
			MongoDB 覆盖索引查询：提升性能的完整指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MongoDB 覆盖索引查询是一种优化数据库查询性能的技术，它通过创建适当的索引，使查询可以直接从索引中获取所需的数据，而无需访问实际的文档数据。这种方式可以减少磁盘 I/O 和内存消耗，提高查询性能。
基本语法 在 MongoDB 中，覆盖索引查询的基本语法如下：
db.collection.find(&lt;query&gt;, &lt;projection&gt;) 其中，&lt;query&gt; 是查询条件，&lt;projection&gt; 是投影条件。覆盖索引查询的关键在于使用投影条件，只返回查询结果所需的字段，从而避免了对实际文档的访问。
命令 MongoDB 中的覆盖索引查询主要涉及 find() 方法的使用，以及合适的索引创建。
创建索引： db.collection.createIndex({ field1: 1, field2: 1, ... }) 执行覆盖索引查询： db.collection.find({ &lt;query&gt; }, { field1: 1, field2: 1, ... }) 示例 假设有一个名为 users 的集合，包含以下文档：
{ "_id": ObjectId("5f1d1c6e84e190d8c53f9c76"), "name": "Alice", "age": 30, "city": "New York" } { "_id": ObjectId("5f1d1c6e84e190d8c53f9c77"), "name": "Bob", "age": 25, "city": "Los Angeles" } 我们可以为 name 字段创建一个索引，然后执行覆盖索引查询：
// 创建索引 db.users.createIndex({ name: 1 }) // 执行覆盖索引查询 db.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10145d0865a372f46c3a71472ac30016/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b4d63fe301f42e3c91761d4a357bd3f/" rel="bookmark">
			golang适配GBase8s(南大通用)数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要讲解golang通过odbc连接GBase8s
环境配置 unixODBC安装 yum -y install unixODBC unixODBC-devel
配置 gbase8s-odbc-driver wget https://gbasedbt.com/dl/odbc/GBase8s_3.0.0_1-Linux64-ODBC-Driver.tar.gz --no-check-certificate
tar -zxf GBase8s_3.0.0_1-Linux64-ODBC-Driver.tar.gz
配置 sqlhosts gbase01 onsoctcp ip 9088 g=db_group cm_update group - - i=2,c=0 w1 onsoctcp ip 18888 g=cm_update cm_read group - - i=3,c=0 r1 onsoctcp ip 19999 g=cm_read 配置环境变量 (使用 root) vim /etc/profile export GBASEDBTDIR=/home/gbase8s-odbc-driver
export GBASEDBTSERVER=gbase01
export PATH= G B A S E D B T D I R / b i n : GBASEDBTDIR/bin: GBASEDBTDIR/bin:PATH
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b4d63fe301f42e3c91761d4a357bd3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23d0d99a00fea64528ed6b134a8f324c/" rel="bookmark">
			教程：利用LLaMA_Factory微调llama3:8b大模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装llama模型文件 下载地址（魔塔）：https://modelscope.cn/models/LLM-Research/Meta-Llama-3-8B-Instruct/files
点击下载模型，复制git命令：
git clone https://www.modelscope.cn/LLM-Research/Meta-Llama-3-8B-Instruct.git 在存放模型空白处右键，点击git bash here，下载llama3模型至本地
由于文件较大，因此该过程比较久，保持下载窗口打开，知道出现下一命令行表示下载完成。
二、安装LLaMA-Factory github:hiyouga/LLaMA-Factory: Unify Efficient Fine-Tuning of 100+ LLMs (github.com)
将其下载到本地
三、为LLaMA-Factory配置环境 进入LLaMA-Factory目录，在路径处输入cmd并回车进入该目录位置的终端
新建虚拟环境
conda create -n llama_factory python=3.10 -y 激活虚拟环境
conda activate llama_factory 安装依赖
pip install -e .[metrics,modelscope,qwen] pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu121 pip install https://github.com/jllllll/bitsandbytes-windows-webui/releases/download/wheels/bitsandbytes-0.41.2.post2-py3-none-win_amd64.whl 安装tensorboard
pip install tensorboard 设置环境变量
Set USE MODELSCOPE HUB=1 四、运行LLaMA-Factory的webui.py 执行代码
python src/webui.py 若顺利，会打开如下网页(初始界面)
五、微调模型 在“Model name”中选择“LLaMA3-8B”,将“Model path”中的路径填写Meta-Llama-3-8B-Instruct文件夹的路径
在dataset中即可选择预先准备好的数据集进行微调
以微调为中文模型举例，则在下拉选项中选择后缀为zh的数据集
点击“Start”开始微调。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23d0d99a00fea64528ed6b134a8f324c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b75110b67a3f02bf7ae292b3f48fd4ef/" rel="bookmark">
			深度学习之父 Hinton 万字访谈录：中美 AI 竞赛没有退路可言（GPT-4o总结版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		访谈介绍：Joel Hellermark 与 AI 教父 Geoffery Hinton 的深度对话 Geoffery Hinton
近日，27 岁的天才创始人 Joel Hellermark 与 “AI 教父” Geoffery Hinton 进行了一场深入对话。在这次访谈中，Hinton 回顾了自己的人工智能生涯，并探讨了神经网络、Scaling Law、多模态学习、模拟计算和人工智能伦理安全等多个话题。此外，Hinton 还分享了他对其得意门生 Ilya Sutskever 的看法，给人以深刻的启迪。
Joel Hellermark Hinton 的人工智能之路 早期求学与科研经历 Geoffery Hinton 的人工智能之路始于剑桥大学，他在剑桥大学最初学习生理学，试图通过生理学课程来理解大脑的工作原理。然而，他很快发现生理学课程只涉及神经元如何传导动作电位，而未能揭示大脑整体的工作机制，这令他非常失望。随后，他转向哲学，希望通过哲学课程了解心灵的运作方式，但结果同样令人失望。最终，他选择了人工智能，并在爱丁堡大学攻读人工智能博士学位，1978 年获得了博士学位。
在爱丁堡大学期间，唐纳德·赫布（Donald Hebb）的一本书对 Hinton 产生了深远影响，书中介绍了神经网络中的连接强度学习。Hinton 还提到约翰·冯·诺依曼（John von Neumann）的书《计算机与人脑》，这本书进一步激发了他对人工智能的兴趣。
在卡内基梅隆大学的经历 Hinton 在 1982 年前往卡内基梅隆大学担任计算机科学系教授，直到 1987 年。在卡内基梅隆大学，他接触到了一台 Lisp 机器，这使他开始编写程序。他回忆到，在某个周六晚上，他发现自己无事可做，于是决定去实验室编写一些程序。这次经历让他认识到，美国的学生对未来充满激情，令他耳目一新。
与 Ilya Sutskever 的合作 初次见面与早期合作 Hinton 回忆了与 Ilya Sutskever（Ilya Sutskever即前段时间刚刚离职的OpenAI首席科学家） 的初次见面。他描述了 Ilya 是如何在某个周日急切地敲门，要求加入他的实验室。
“所以我们聊了一会儿，我给了他一篇论文阅读，那是关于反向传播的《自然》（Nature）论文。我们约定一周后再见面，他回来后说：“我没看懂。”
我感到非常失望。我想：“他看起来挺聪明的，但这只是链式法则而已。理解起来并不难。”
他却说：“哦，不，不，那个我懂。我只是不明白 —— 为什么不直接将梯度（即损失函数相对于模型参数的导数）应用于一个更合理的函数优化器呢？” 后来，这个问题成为了我们多年研究探讨的重点。Ilya 就是这样，他对事物的直觉总是非常敏锐。”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b75110b67a3f02bf7ae292b3f48fd4ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bf36a3cc86ea595bf3539fddf463e87/" rel="bookmark">
			【unity2021-2023打包安卓工程】踩坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 踩坑记录使用环境Unity的准备工作Windows10 SDKAndroidstudio第一个需要注意的地方第二个需要注意的地方第三个需要注意的地方第四个需要注意的地方第五个需要注意的地方第六个需要注意的 其他unity启动缓慢 更新更新一 2023.9.27 unity2021关于在Androidstudio打包aar供unity调用的问题关于unity调用aar包打包时出现的问题关于unity打包成apk出现的问题关于打包一直出现mutidex exception的问题问题描述解决方案原因 踩坑记录 踩了快一个星期的坑，希望能帮助到有需要的人
项目使用的是unity2019版本，由于很多新的插件和功能都已经不支持2019了，所以升级unity的版本
在升级版本的过程中遇到了很多的问题，因为本身基础较差，加之比较新，网上能找到的解决办法少之又少，当然也存在不希望外露保持技术神秘感的大神…
扯远了，在这里记录一下踩坑的过程以及解决办法
使用环境 Androidstudio 2022.3 - - -最好是比较新的像4.11左右或者一下的就尽量不要用了，老版本在打包的时候会弹出异常，提示某些以前在build.gradle里的关键字已经失效了，要用新的去代替
unity 2023 - - -安卓打包相关的工具
windows10 sdk 10.0.1314 - - - 后面会说是干嘛的
ndk r23b - - - 后面会上传附件
sdk 28及以上- - -后面会上传附件，也可以在as官网里下
gradle 7.6.0 - - - 这个在安卓工程里的gradle-wrapper.properties里可以修改
gradle插件 7.4.1 - - - 这个需要和gradle进行匹配，网上可以根据gradle找到对应的版本 在项目根目录下的build.gradle里
Unity的准备工作 在unityhub下载unity2023 我的是2023.1.12f
下载对应的安卓环境（同事亲测它帮我们下的安卓环境是有问题的，比如unit2023打包安卓至少是jdk11，但是它帮我们下的jdk还是8的）
下载之后选择安卓环境打开项目，然后制作你的项目
写完代码后可以现在unity打包成apk看看能不能正常打包运行
如果要打包的话，需要自己安装jdk11
然后在
上图的位置去掉勾勾，选择你安装好的jdk11的路径
后面的sdk和ndk，gradle都是一样的道理，当然你可以先用默认的打包看看有没有问题，有的话再去下载我上面说的sdk和ndk版本，然后在上图修改对应的路径
到这里应该就能正常打包了
为什么说可以先试一下官方默认给你的环境路径去打包呢，因为这个2023可能太新了，官方还没有适配还是什么的，后面可能就发现了这个问题，指不定后面的你们去打包的时候他已经适配好了呢是吧？
打包的设置
我使用的是il2cpp的打包模式，mono的还没试过,不过估计比il2cpp简单很多
记得在playersettings里确定下面两个都勾上了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bf36a3cc86ea595bf3539fddf463e87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6283d475e9ea79ef19182042a92e5cd6/" rel="bookmark">
			如何在 Python 中将语音转换为文本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、说明 学习如何使用语音识别 Python 库执行语音识别，以在 Python 中将音频语音转换为文本。想要更快地编码吗？我们的Python 代码生成器让您只需点击几下即可创建 Python 脚本。现在就现在试试！
二、语言AI库 2.1 相当给力的转文字库 语音识别是计算机软件识别口语中的单词和短语并将其转换为人类可读文本的能力。在本教程中，您将学习如何使用SpeechRecognition 库在 Python 中将语音转换为文本。
因此，我们不需要从头开始构建任何机器学习模型，这个库为我们提供了各种知名公共语音识别 API（例如 Google Cloud Speech API、IBM Speech To Text 等）的便捷包装。
请注意，如果您不想使用 API，而是直接对机器学习模型进行推理，那么一定要查看本教程，其中我将向您展示如何使用当前最先进的机器学习模型在Python中执行语音识别。
另外，如果您想要其他方法来执行 ASR，请查看此语音识别综合教程。
另请学习：如何在 Python 中翻译文本。
2.2 安装过程 好吧，让我们开始使用以下命令安装库pip：
pip3 install SpeechRecognition pydub 好的，打开一个新的 Python 文件并导入它：
import speech_recognition as sr 这个库的好处是它支持多种识别引擎：
CMU Sphinx（离线）谷歌语音识别谷歌云语音API维特人工智能微软必应语音识别Houndify APIIBM 语音转文本Snowboy 热词检测（离线）
我们将在这里使用 Google 语音识别，因为它很简单并且不需要任何 API 密钥。 2.3 转录音频文件 确保当前目录中有一个包含英语演讲的音频文件（如果您想跟我一起学习，请在此处获取音频文件）：
filename = "16-122828-0002.wav" 该文件是从LibriSpeech数据集中获取的，但您可以使用任何您想要的音频 WAV 文件，只需更改文件名，让我们初始化我们的语音识别器：
# initialize the recognizer r = sr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6283d475e9ea79ef19182042a92e5cd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b415fb6a6ee618bb84e04de7b5425dc/" rel="bookmark">
			【前端】夯实基础 css/html/js 50个练手项目（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言Day 1 expanding-cardsDay 2 progress-stepsDay 7 Split Landing PageDay9 Sound BoardDay10 Dad JokesDay11 Event KeycodesDay12 FAQ collapse重点1：classList.toggle('active')重点2：css 伪类选择器重点3：css 的覆盖 Day46 Quiz App重点 label 标签的 for 属性 前言 发现一个没有用前端框架的练手项目，很适合我这种纯后端开发夯实基础，内含50个mini project，学习一下，做做笔记。
项目地址：https://github.com/bradtraversy/50projects50days Day 1 expanding-cards 效果预览
核心代码：
&lt;body&gt; &lt;div class="container"&gt; &lt;!--active 标识被点击的图片 --&gt; &lt;div class="panel active" &gt; &lt;/div&gt; &lt;div class="panel" &gt; &lt;/div&gt; &lt;div class="panel" &gt; &lt;/div&gt; &lt;div class="panel" &gt; &lt;/div&gt; &lt;div class="panel" &gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="script.js"&gt;&lt;/script&gt; &lt;/body&gt; // 为所有的 panel 注册点击事件 panels.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b415fb6a6ee618bb84e04de7b5425dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a6ea631bc79da5ae132eccd3c28ce10/" rel="bookmark">
			uniapp小程序过大，uniapp小程序压缩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.运行到小程序时压缩代码，这个仅开发时用 选择运行旁边的 发行》小程序-微信
发行后的代码会比运行时压缩的更小
需要上传小程序时再用，因为不会实时更新你修改的内容
2.图片文件 主包打包时会打包所有组件和静态资源文件，会导致vedor.js文件过大
越大的小程序图片文件肯定也是大量的，这个时候可以把图片文件全部给你的后端，放在线上，然后 全局查找 替换成线上路径，本地图片一个不留
3.分包 小程序项目在开始做的时候就应该先考虑一下后续的功能添加，主包只有2MB，内容稍微多点的小程序肯定是不够的，下面这是我做的一个二期开发的项目，没压缩前达到了12MB
点这里看分包
4.组件 主包打包时会打包所有组件和静态资源文件，会导致vedor.js文件过大
主包没用但是分包用到的自定义组件，在分包下创建components文件，从主包剪切过来，
使用的时候需要 import 引入
可以自己实现的功能尽量不要用插件市场的
4.1组件按需注入 按需注入链接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0ea3193521f00f93c4a347768dc1054/" rel="bookmark">
			C#智驭AI未来：一堂ML.NET实战课，解锁客户流失预测密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥关注墨瑾轩，带你探索C#的奥秘🚀
🔥超萌技术攻略，轻松晋级编程高手🚀
🔥技术宝库已备好，就等你来挖掘🚀
🔥订阅墨瑾轩，智趣学习不孤单🚀
🔥即刻启航，编程之旅更有趣🚀
引言：C#遇见AI的奇妙化学反应
在C#的世界里，集成人工智能与机器学习技术不再是遥不可及的梦想。Microsoft的ML.NET框架，为C#开发者铺平了道路，让他们能够轻松地在应用中融入机器学习的力量。本文将以一个预测分析的实战项目为例，展示如何利用C#和ML.NET从零开始构建一个简单的智能预测模型。
准备工作
环境搭建：确保已安装.NET SDK及Visual Studio，同时安装ML.NET NuGet包。 实战案例：预测客户流失
我们将构建一个模型，用于预测银行客户是否会流失（Churn Prediction）。首先，我们需要准备训练数据集，包含客户的属性（如年龄、账户余额等）以及他们是否流失的信息。
步骤1：加载数据
Csharp
using Microsoft.ML; using Microsoft.ML.Data; public class CustomerData { [LoadColumn(0)] public bool Label { get; set; } // 是否流失 [LoadColumn(1)] public float Age { get; set; } [LoadColumn(2)] public float Balance { get; set; } // 其他特征列... } public class Prediction { [ColumnName("PredictedLabel")] public bool ChurnPrediction { get; set; } } var context = new MLContext(); var data = context.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0ea3193521f00f93c4a347768dc1054/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e62aab409f9d3278983b74249b6cad5d/" rel="bookmark">
			Stable-DiffusionLoRA模型训练教程(新手篇)｜LoRA训练个人经验总结与复盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上周初次尝试了训练LoRA模型，周末两天的时间一直在遇到问题摸索解决问题，修改完善模型，测试模型当中度过，好在问题都一一解决，也在LiblibAI上首发了我的处女作。👏👏👏
本篇文章仅整理归纳我的LoRA训练思路及步骤，以及自己遇到的问题和解决方案的复盘整理。希望对新手炼丹师们有所启发和帮助。
LoRA是Low-Rank Adaptation的缩写，最早在2021年论文《LoRA: Low-Rank Adaptation of Large Language Models》中提出。是一种大语言模型低秩适配器，简单来说就是它可以降低模型可训练参数，使其尽量不损失模型表现的大模型微调方法。
在此之前，StableDiffusion只能通过使用Dreambooth的方法训练大模型，如果对大模型的效果不满意，那么就只能从头开始，重新训练，但是大模型的训练要求高，算力要求大，速度慢。自从LoRA被引入StableDiffusion后，大大降低了训练门槛，并扩宽了产出模型的适用范围。这就使得我们这些对AI绘画感兴趣的非专业人员，也可以在家用电脑上尝试训练自己的LoRA模型。
LoRA的出图原理和理论知识在网上已经有很多，在此不做赘述，感兴趣的小伙伴可自行查找。
LoRA训练对显卡有一定要求，同时需要安装一些方便训练的软件。
首先，对电脑配置的要求主要来自显卡，需要显卡有足够的显存，其他配置不太差就可以。显卡的选择中显存是第一要素，SD1.5版本的底模6G显存勉强可用，8G显存就可以比较流畅的生成图片和炼制LoRA，12G可以流畅的使用Dreambooth微调大模型。我的Mac本直接Pass，Win的配置也不是特别高，所以炼丹速度比较慢，但是勉强可以用。
然后，就是推荐下载几个后续方便训练的软件，帮助新手小白降低训练难度，提升炼丹效率。
其他LoRA训练丹炉，我已经下载还未使用，感兴趣的小伙伴也可以自行下载试用。
1. 确定目的
在训练LoRA模型之前，我们需要首先明确自己需要训练什么类型的LoRA，有的博主将模型分成了几个大类：人物角色、画风/风格、概念、服饰、物体/特定元素等。
我只简单的划分为两类：具象类和泛化类，具象类如：一个物体、一种姿势、一种服装、一个人物、某个特定元素等都可以划归为具象类。泛化类如：某种场景、某种艺术风格、色彩风格等。
前期明确目的的训练能更好的确定要找素材的数量及选择的大模型类型，为后面的具体训练打好基础。
2. 收集素材
⚠️ 「大模型的选择」和「图片质量」都是收集素材的关键！
收集素材阶段，我们仍然按照第一步中的训练目的，分为具象类和泛化类。
具象类LoRA：数量：在具象训练中并不是素材越多越好，一般建议20张左右即可；素材要求：不同角度，不同背景，不同姿势，不同服饰，清晰无遮挡的图片
⚠️ 如果同质化的素材太多，容易造成权重的偏移。
泛化类LoRA：数量：在泛化类训练中需要素材多一些，建议50张以上
⚠️ 这种情况不需要特别在意同质化，但也切勿非常接近的素材占比过高。
3. 处理素材
从这一步起，我们会使用到上文提到的软件。处理素材主要包括统一素材尺寸、生成标签和优化标签。
a、统一素材尺寸
可以使用修改图片工具对图片尺寸进行批量处理，至少保证一边为512px，但必须是64的倍数。横竖图可放一起训练。也可以使用美图秀秀或者PS自行裁剪。
b、生成标签
我使用的是秋叶大佬提供的StableDiffusionWebUI，启动SD-训练-图像预处理。
在你的随便一个盘，建2个文件夹，我简单的命名为1和2（1文件夹放你收集好的图片素材即为「源目录」。2文件夹不需要管，等到SD自动打标完，会将打标文件和你的图片自动存放在2文件夹内，即为「目标目录」），调整宽度和高度与你的素材尺寸保持一致。
复制文件夹1和2的地址，分别粘贴到源目录和目标目录的位置。
有两种生成标签的方式：BLIP即自然语言标签，比如“1个女孩在草地上开心的跳舞”；Deepbooru即词组标签（常用），比如“1个女孩，草地，跳舞，大笑”。一般选择使用Deepbooru生成标签。
当SD界面右侧出现Preprocessing finished，就表示SD已经帮你自动打标好了。
打开刚才建的2文件夹，就可以看到图片和自动生成的标签了。txt文本中的就是SD自动打好的标签。
c、优化标签
第一次训练时我没有优化标签直接训练LoRA，最后的LoRA效果不是很理想，第二遍训练又新增了素材数量，同时优化了标签。
优化标签一般有两种方式：1）保留全部，不做删减，用此方法比较方便，但是需要用精准的关键词，才能还原想要的效果；2）删除部分特征标签，我使用的是此方法。
批量修改关键词的工具BooruDatasetTagManager，很多大佬推荐过，界面比较原始，好用的点是可以批量增删改查关键词，并且可以通过调整关键词位置来调整权重。当然你也可以使用VsCode，或者直接用txt调整都可以。
下载完后，直接双击exe文件运行，就会出现此界面。界面分为三个区域，分别是「数据集区域」「图片标签区域」「数据集内所有标签区域」。标签相关的区域右侧都有操作，可以增加、删除，翻译、上下移动标签，常用的就是这几个功能。
选中文件-读取数据集目录可导入数据集；选中界面-翻译标签，可翻译所有标签，标签可拖动上下移动，更改权重，最后全部修改完别忘记保存更改。
数据集导入后，就可以开始对照图片素材对标签进行删改，需要注意的是标签提示词的前后顺序代表着标签的权重，越靠前的标签权重也就越大，所以我们可以把想要的效果或风格标签放在前面，像背景干净这类标签尽量靠后。
标签优化方法：删减掉训练风格或者需要生成内容的相关词。比如我要生成「手绘插画」的LoRA模型，就需要保留图片素材中手绘插画风格相关的内容作为自带特征，那么就将与手绘插画相关的词语标签删除，增加触发词“shouhui或者chahua”。将“shouhui或者chahua”触发词与其风格相关的词关联，当你填写触发词后就会自带此风格。
4. 调整参数/开始训练
至此，准备工作就完成了，可以开始准备正式训练LoRA了，我使用的还是秋叶大佬的LoRA训练器SD-Trainer，选择新手训练模式。
在新手训练开始之前需要先明确几个概念：
重复次数（Repeat）：每一张素材的重复次数。
需要在文件夹名以【数字_名称】的方式设定，如训练集chahua重复次数10，则文件夹命名为10_chahua。
训练轮数（Epoch）：整个训练集按照重复次数训练一次为一轮，10轮就是10*10为每一张训练100次
在操作过程中也同样要考虑具象类和泛化类不同来调整参数，具象类需要在每一轮提高次数以求精准度；泛化类就降低次数提高轮数，不需要那么精准，一轮轮去训练。新手训练模式下，我们只需要调整这几个参数即可。
进入新手模式后，需要选择训练LoRA使用的大模型
底模文件路径，选择你要训练LoRA使用的大模型，直接点击右侧的小文件夹选择即可。
训练数据集路径：在选择这一步之前，需要现在sd/lora-scripts-v1.7.3/train这个文件夹下建一个文件夹，比如我建的叫“chahua”，再打开“chahua”文件夹在里面建一个“数字_英文名”的文件夹，将之前打标好的图和标签一起复制到“数字_英文名”的文件中（如训练chahua重复次数16，则文件夹命名为16_chahua。）
修改分辨率（之前数据集的尺寸是多少，这里就用多少）
保存设置：保存模型的名称修改成你想要的名称
点击开始训练，就可以在终端看到它正在疯狂训练中...这个时间会比较久，慢慢等待就好。
当出现“训练完成”字样后，表明你的LoRA模型已经初步完成了训练，我是晚上开着电脑自己跑的，用时9小时……初步训练完LoRA模型，我们就可以对LoRA进行测试，来验证我们的LoRA训练成果，以及了解这个LoRA的最佳参数。
在sd/lora-scriipts-v1.7.3/output文件夹中就可以看到我们生成的LoRA模型了，因为我设置的是2步保存一个Lora模型，16步，所以有8个LoRA的阶段稿。（没有数字的这个是最后的LoRA）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e62aab409f9d3278983b74249b6cad5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00c39f01431f965eefffa05bdee735a5/" rel="bookmark">
			Java分支结构详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java分支结构详解 前言一、if 语句基本语法表示一表示二表示三 代码示例判定一个数字是奇数还是偶数判定一个数字是正数还是负数判定某一年份是否是闰年 注意要点悬垂 else 问题代码风格问题分号问题 二、switch 语句基本语法代码示例根据 day 的值输出星期 注意事项break 不要遗漏switch 中的值只能是 整数|枚举|字符|字符串switch 不能表达复杂的条件switch嵌套 前言 推荐一个网站给想要了解或者学习人工智能知识的读者，这个网站里内容讲解通俗易懂且风趣幽默，对我帮助很大。我想与大家分享这个宝藏网站，请点击下方链接查看。
https://www.captainbed.cn/f1
Java中的分支结构用于根据条件执行不同的代码块，包括if-else语句、switch语句等，实现程序流程的控制。
一、if 语句 在Java中，if语句是一个条件控制语句，用于根据条件的真假决定是否执行特定的代码块。
在if语句中，条件是一个布尔表达式，可以是一个比较表达式（例如==、!=、&gt;、&lt;等），也可以是一个逻辑表达式（例如&amp;&amp;、||、!等）。
基本语法 表示一 if(布尔表达式){ //条件满足时执行代码 } 表示二 if(布尔表达式){ //条件满足时执行代码 }else{ //条件不满足时执行代码 } 表示三 if(布尔表达式){ //条件满足时执行代码 }else if(布尔表达式){ //条件满足时执行代码 }else{ //条件都不满足时执行代码 } 代码示例 判定一个数字是奇数还是偶数 public static void main(String[] args) { int num = 10; if (num % 2 == 0) { System.out.println("num 是偶数"); } else { System.out.println("num 是奇数"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00c39f01431f965eefffa05bdee735a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8597287b9fa66f5562080b03726ca4d/" rel="bookmark">
			Java为什么会成为现在主流的编程语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java为什么会成为现在的主流语言 前言一、Java语言概述Java是什么为什么大多数人会选择从事Java为什么从事Java的工作者数量从年递减 二、Java语言的特点简单性面向对象分布式（微服务）健壮性安全性体系结构中立可移植性解释型高性能多线程动态性 三、Java语言发展简史四、Java是最好的语言么Java 语言到底有什么优势可以占据排行榜第一的位置呢Java社区的概况 五、JavaScript和Java有什么关系呢 前言 推荐一个网站给想要了解或者学习人工智能知识的读者，这个网站里内容讲解通俗易懂且风趣幽默，对我帮助很大。我想与大家分享这个宝藏网站，请点击下方链接查看。
https://www.captainbed.cn/f1
Java成为主流语言的原因在于其跨平台性、面向对象特性、丰富的库和框架支持，以及强大的社区和广泛的应用场景。这些优势使得Java在开发大型系统、企业级应用以及移动和Web开发等领域具有显著优势。
一、Java语言概述 Java是什么 Java是一种优秀的程序设计语言，它具有令人赏心悦目的语法和易于理解的语义。不仅如此Java还是一个有一系列计算机软件和规范形成的技术体系，这个技术体系提供了完整的用于软件开发和跨平台部署的支持环境，并广泛应用于嵌入式系统、移动终端、企业服务器、大型机等各种场合。
Java是一种跨平台的面向对象编程语言，由Sun Microsystems（现在是Oracle）在1995年推出。Java被设计用来支持应用程序的开发，特别是因特网上的应用程序。它具有简单性、可移植性和安全性的特点，因此成为了开发企业级应用程序的一种主流语言。
下面我们通过Java官方提供的数据来一起感受一下，Java到底有多“火”。
为什么大多数人会选择从事Java 过上面的数据，各位读者应该对Java目前到底有多流行有一个直观的认识了吧。这里有的读者可能会问了，上面的数据主要是Java在应用市场的流行，那么对于我们开发者，Java是否是我们开发应用程序的第一选择呢？
来看下图
为什么从事Java的工作者数量从年递减 工作市场上的Java工作者太多了
随着技术和市场的发展，对不同类型的开发人员需求也会变化。某些领域可能对Java的需求减少，导致从事Java的工作者数量递减。例如，移动应用开发中，Android平台使用的是Java语言，但随着React Native等跨平台开发框架的出现，其他语言的使用也有增加的趋势。
技术行业的就业市场是动态变化的，有时某个技术可能会在一段时间内更受欢迎，而在另一段时间内相对较少。这可能会导致从事Java的工作者数量的波动。
每个人都有自己的兴趣和发展方向，有些从事Java的工作者可能会选择转向其他领域或技术，以追求个人的职业发展和兴趣。这也可能是导致从事Java的工作者数量递减的原因之一。
需要注意的是，这仅仅是一种趋势，而实际情况可能因地区、行业和个人的不同而有所差异。Java作为一种广泛应用的编程语言，仍然有很多企业和项目需要Java开发人员的技能。但总的来说Java还是主流
二、Java语言的特点 简单性 Java语法是C++语法的一个“纯净版本”。这里没有头文件、指针运算（甚至指针语法）、结构、联合、操作符重载、虚基类等等。
ps:关于C++可以关注我的C++专栏，里面包含了我是如何学习C++的
不仅如此，Java开发环境远远超出大多数其他编程语言的开发环境。
面向对象 什么是面向对象？
这里我们用木匠打一个比方，一个“面向对象”的木匠始终关注的是所制作的椅子，第二位才是所使用的工具；而一个“非面向对象的”木匠首先考虑的是所使用的工具。
在Java的世界里，一切皆对象。
Java的面向对象特性与C++旗鼓相当，与C++的主要不同点在于多重继承。在Java中，取而代之的是更简单的接口概念。而且与C++相比，Java提供了更丰富的运行时自省功能。
分布式（微服务） Java有丰富的例程库，用于处理像HTTP和FTP之类的TCP/IP协议。Java应用程序能够通过URL打开和访问网络上的对象，其便捷程度就好像访问本地文件一样。
健壮性 Java与C++最大的不同在于Java采用的指针模型可以消除重写内存和损坏数据的可能性
ps:对于曾经花费几个小时来检查由于指针bug而引起内存冲突的人来说，一定很喜欢Java的这一特性。
不仅如此，Java编译器能够检测许多在其他语言中仅在运行时才能够检测出来的问题。
安全性 Java适用于网络/分布式环境。为了达到这个目标，在安全性方面投入了大量的精力。使用Java可以构建防病毒、防篡改的系统
从一开始，Java就设计成能够防范常见的各种攻击：
运行时堆栈溢出。蠕虫和病毒常用的攻击手段。破坏自己进程空间之外的内存。未经授权读写文件 体系结构中立 编译器生成一个体系结构中立的目标文件格式，这是一种编译过的代码，只要有Java运行时系统，这些编译后的代码就可以在许多处理器上运行。
Java编译器通过生成与特定计算机体系结构无关的字节码指令来实现这一特性。精心设计的字节码不仅可以很容易的在任何机器上解释执行，而且还可以动态地翻译成本地机器代码。
可移植性 与C/C++不同，Java规范中没有“依赖具体实现的地方”。基本数据类型的大小以及有关运算都做了明确的说明。
例如，Java中的int永远是32位的整数，而在C/C++中，int可能是16位整数、32位整数，也可能是编译器提供商指定的其他大小。在Java中，数据类型具有固定的大小，这消除了代码移植时令人头疼的主要问题。
解释型 Java解释器可以在任何移植了解释器的机器上执行Java字节码。由于链接是一个增量式且轻量级的过程。所以开发过程也变得更加快捷，更加具有探索性。
高性能 尽管对解释后的字节码性能已经比较满意，但在有些场合下可能需要更加高效的性能。字节码可以（在运行时刻）动态的翻译成对应运行这个应用的特定cpu的机器码。
多线程 Java在当时很超前。它是第一个支持并发程序设计的主流语言。多线程可以带来更好的交互响应和实时行为。并发程序设计绝非易事，但是Java在这方面表现出色，可以很好的管理这个工作。
动态性 Java与C/C++相比更加具有动态性。它能够适应不断发展的环境。库中可以自由的添加新方法和实例变量，而对客户端没有任何影响。在Java中找出运行时类型信息十分简单
三、Java语言发展简史 Java 语言源于 1991 年 Sun 公司 James Gosling 领导的的 Oak 项目，1995 年 Sun 公司正式起名为 Java，并提出“Write once, Run anywhere"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8597287b9fa66f5562080b03726ca4d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/341/">«</a>
	<span class="pagination__item pagination__item--current">342/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/343/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>