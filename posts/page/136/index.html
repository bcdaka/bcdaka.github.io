<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1f86fa08a8479450aea9e9457a21e98/" rel="bookmark">
			澎湃算力 玩转AI 华为昇腾AI开发板——香橙派OriengePi AiPro边缘计算案例评测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		澎湃算力 玩转AI 华为昇腾AI开发板 香橙派OriengePi AiPro 边缘计算案例评测 人工智能（AI）技术正以前所未有的速度改变着我们的生活、工作乃至整个社会的面貌。作为推动这一变革的关键力量，边缘计算与AI技术的深度融合正成为行业发展的新趋势。正是基于这样的背景，香橙派与华为昇腾携手合作，共同推出了OrangePi AIpro一款专为边缘计算设计的AI开发板，它不仅承载着双方对技术创新的不懈追求，更预示着AI技术普及与应用的新篇章。
OrangePi AIpro的诞生，是香橙派在智能硬件领域深耕细作与华为昇腾在AI技术方面深厚积累的完美结合。香橙派，作为开源硬件领域的佼佼者，一直致力于为开发者提供高性能、易上手的硬件平台；而华为昇腾，作为华为在AI领域的核心品牌，其先进的AI处理器和解决方案在全球范围内享有盛誉。两者的合作，无疑为AI开发者们带来了一款集高性能、灵活性、易用性于一身的优质产品。
本次开箱测评，我有幸成为体验者之一，将探索OrangePi AIpro的每一个细节，从外观设计到内部构造，从硬件配置到软件生态，全方位、多角度地展现这款产品的魅力所在。我相信，通过我的测评，广大读者将能够更加直观地了解OrangePi AIpro的优势与特点，为他们的AI项目选择最合适的硬件平台提供有力参考。
OrangePi AIpro 开发板官方网站 http://www.orangepi.cn/html/hardWare/computerAndMicrocontrollers/details/Orange-Pi-AIpro.html
华为昇腾 AI 技术 华为昇腾 AI 技术路线以CANN作为核心架构基础，CANN（Compute Architecture for Neural Networks）是华为针对AI场景推出的异构计算架构，对上支持多种AI框架，对下服务AI处理器与编程，发挥承上启下的关键作用，是提升昇腾AI处理器计算效率的关键平台。支持的AI框架包括华为全场景AI框架昇思MindSpore,也包括常见的AI开发框架(PyTorch,TensorFlow,Paddlepaddle)等。
官方网址 https://www.hiascend.com/#/
开发文档 https://www.hiascend.com/zh/document
1.OriengePi AiPro 开发板开箱 硬件资源
CPU4核64位处理器+ AI处理器（昇腾310B4）GPU集成图形处理器AI算力8-12TOPS算力内存LPDDR4X：8GB/16GB（可选），速率：3200Mbps存储• SPI FLASH：32MB • SATA/NVME SSD（M.2接口2280） • eMMC插槽：32GB/64GB/128GB/256GB（可选），eMMC5.1 HS400 • TF插槽WIFI+蓝牙Wi-Fi 5双频2.4G和5G BT4.2/BLE以太网收发器10/100/1000Mbps以太网显示• 2xHDMI2.0 Type-A TX 4K@60FPS • 1x2 lane MIPI DSI via FPC connector摄像头2x2-lane MIPI CSI camera interface，兼容树莓派摄像头USB• USB 3.0 HOST x2 • USB Type-C 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1f86fa08a8479450aea9e9457a21e98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdf7c9cd94911910abf743e0b1d3b985/" rel="bookmark">
			【MySQL】【已解决】Windows安装MySQL8.0时的报错解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 先说一些没用的话，据说安装MySQL是无数数据库初学者的噩梦，我在安装的时候也是查了很多资料，看了很多博客，但是很多毕竟每个人的电脑有各自不同的情况，大家的报错也不尽相同，所以也是很长时间之后才安装成功。
一些软件的安装和环境配置有以下特点：对环境要求很高，同时对笔者这样的初学者很不友好，往往一点小的疏忽就会全盘皆失，网上的教程又不能保证能起到效果，极容易倒在迈出第一步上。而且安装不成功的话卸载会更加麻烦：卸载软件、删除相关文件夹、删除环境变量、删注册表等等 。最后要么重装系统要么永远也别想使用这个软件了，极其痛苦，
所以我希望总结一些学计算机的需要注意的东西，关于正确使用电脑的好习惯，能让你的电脑保持干净！（随时更新补充）
1、首先要有一个良好的文件组织模式，软件、工程、文档什么的分类放好。不要下载个什么东西在电脑中乱放，最后想找个什么文件找不到不说，这种方式最大的弊端就是出了问题的时候没法解决。
2、用户名、主机名、文件路径、变量路径等都不要出现中文（最好是连空格也不要有啦~），真的有无数计算机小白在这上面吃过亏了！能用英文的最好用英文，顺便还能锻炼下英语水平，更有希望过四级（doge）。
PS：还有一些小的经验，在写代码或者是安装软件、配置环境的时候，经常会出现很多报错，你要上网查资料查教程，但是最后却发现搞了一天甚至更长都解决不了，这是很正常的事情，千万不要觉得很烦或者觉得解决不了，只要耐心去弄，仔细看看报错，也许问题就会迎刃而解。在最开始接触Ubuntu的时候，从安装系统到各种下载安装软件各种报错、各种问题，那时候真是折磨得很，但是在处理报错的同时，水平也一定在慢慢提升，现在已经慢慢会看报错寻找问题解决问题了。
安装配置的时候一定要慎重，一个小错误就可能造成难以挽回的后果！
二、安装MySQL时的报错汇总（点击旁边的log选项卡可以查看日志） 错误1：initializing database(may take a long time) 数据库初始化产生错误
日志如下：
Log日志： C:\Program Files\MySQL\MySQL Server 8.0\bin\mysqld.exe (mysqld 8.0.32) initializing of server in progress as process 4212 mysqld: File '.\婵犮垹鐏堥弲婊勬櫠閻樼粯鎲ユ俊顖涘绾捐棄銆?bin.index' not found (OS errno 2 - No such file or directory) The designated data directory C:\ProgramData\MySQL\MySQL Server 8.0\Data\ is unusable. You can remove all files that the server added to it. Aborting C:\Program Files\MySQL\MySQL Server 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdf7c9cd94911910abf743e0b1d3b985/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33a69fc7547365ee6a50e02e82363641/" rel="bookmark">
			2024.7.19 作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.链表的排序 int list_sort(NodePtr L) { if(NULL==L || L-&gt;len&lt;=1) { printf("排序失败"); return -1; } int len=L-&gt;len+1; NodePtr p; int i,j; for( i=1;i&lt;len;i++) { for( j=0,p=L;j&lt;len-i;j++,p=p-&gt;next) { if( p-&gt;data &gt; p-&gt;next-&gt;data ) { datatype t=p-&gt;data; p-&gt;data=p-&gt;next-&gt;data; p-&gt;next-&gt;data=t; } } } printf("排序成功\n"); return 0; } 2.链表的反转（递归实现） // 递归反转链表 NodePtr list_fz(NodePtr L) { // 基础情况：空链表或只有一个节点 if (L == NULL || L-&gt;next == NULL) { return L; } NodePtr new_L = list_fz(L-&gt;next); L-&gt;next-&gt;next = L; L-&gt;next = NULL; return new_L; } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33a69fc7547365ee6a50e02e82363641/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4063815704cb5f5d1b74608c00ca717b/" rel="bookmark">
			【数据结构】优先级队列（堆）从实现到应用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
💎所属专栏：数据结构与算法学习 💎 欢迎大家互三：2的n次方_
🍁1. 优先级队列的概念 在之前已经了解过，队列是一种先进先出的数据结构，而优先级队列是一种抽象数据类型，其中每个元素都有一个优先级。与标准的队列不同，优先级队列中元素的顺序是根据其优先级来决定的，而不是按插入的顺序，优先级高的元素将优先出队。
JDK1.8中的PriorityQueue底层使用了堆这种数据结构，而堆实际就是在完全二叉树的基础上进行了一些调整。
🍁2. 堆的介绍 堆是一种特殊的完全二叉树结构，堆又可以分为大根堆和小根堆
大根堆：每个节点的值都大于或等于其子节点的值，也就是根节点是树中的最大值。
小根堆：每个节点的值都小于或等于其子节点的值，也就是根节点包含树中的最小值。
​
🍁3. 堆的模拟实现 底层通过数组来实现堆
public class MyHeap { public int[] elem; public int usedSize; public MyHeap(int[] elem) { this.elem = elem; } } 将元素存储在数组中后，如果孩子节点的下标为i，那么双亲节点的下标为（i - 1）/ 2
如果双亲节点的下标为 i ，那么左孩子的下标为 2*i+1，右孩子的下标为 2*i+2，如果左孩子或右孩子下标越界了就表示没有左孩子或右孩子
​
明白了节点怎么表示后就可以根据这些关系进行建堆了，
从最后一棵子树开始，依次往上调用向下调整
public void createHeap() { //最后一棵子树 for (int parent = (usedSize - 1 - 1) / 2; parent &gt;= 0; parent--) { siftDown(parent, this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4063815704cb5f5d1b74608c00ca717b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3aa0dd72652ba38e34a202f9ddef2e0/" rel="bookmark">
			主流大数据调度工具DolphinScheduler之数据ETL流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给大家分享主流大数据调度工具DolphinScheduler，以及数据的ETL流程。
一：调度工具DS 主流大数据调度工具DolphinScheduler，
其定位：解决数据处理流程中错综复杂的依赖关系
任务支持类型：支持传统的shell任务，同时支持大数据平台任务调度：MR、Spark、SQL(mysql、postgresql、hive/sparksql)、python、procedure、sub_process。
二，数据ETL流程(调度流程) 今天分享一个把数据从hive推送到人大金仓数据库的案例。
0，数据ETL的底层原理 ETL原理：本次分享的案例​​​​​​​ETL，采用的是DataX的数据传输方式。
1，源数据hive hive表数据如图所示，
在这里一共5条数据，展示的4个字段都是主键，dt为分区。
2，DS主界面 项目管理主界面，包含了很多的工作流，工作流需要自己配置。
3，创建工作流 在这里，我们写一个export的sheet页，主要实现数据从hive推送到数据库。
dept的内容是指的是前置依赖。
4，工作流内容配置 表名是 f_con_fund_deal_reminder
前缀 export 指的是数据推送，一般就是把数据从hive推送到其他数据库。
最重要的是脚本内容：
这里脚本内容是支持shell任务，所以大家一定要懂shell语法。
当然还要再设置参数，这里根据shell内容来，参数可以设置多个。
5，shell脚本开发 在这里底层逻辑采用datex的方式来进行数据的ETL。
5.1，日期配置
涉及时间或者其他参数的传参。
5.2，源表配置
这里的查询语句 query_sql，是可以将其查询出来的数据进行数据的传输（功能强大！！！）。
5.3，目标表配置
tgt_tab_pkey : 是数据库该表的主键。（下次ETL，如果数据发生变更，会把同主键的数据进行变更。）
tgt_tab_column : 是源表查询出来的字段映射到目标表的字段（映射灵活）。
tgt_pre_sql : 在数据ETL之前，可以先对数据库的表先进行操作（牛逼）。
5.4，其他配置
该调度是自然日跑批还是交易日跑批。
通用配置：这部分不需要大家更改。
底层逻辑采用datex的方式来进行数据的ETL，
写在了comment_data_sync.sh里面了。
6，参数的设置/调度运行 是否补数：就是可以跑批任意哪一天的调度。
调度日期：需要自己设置。然后点击运行。
7，在目标库看ETL结果 查询发现，只有4条数据。要的就是这个，因为我们设置主键了。
同主键数据，会随机插入一条数据。这个大家看步骤一。
8，工作流日志 看看工作日志长啥样，里面运行了什么。
发现有刚刚的shell脚本运行过程：
打印最终数据推送的结果：
好啦，今天这篇主流调度工具DS的简单介绍，以及工作流创建，脚本开发，调度流程，日志查看，一整个流程，就分享到这里。
下次再见！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a9a0f4207f7d57b1471b998481c364c/" rel="bookmark">
			LLaMA-Factory在华为显卡上的实验记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何判断目前所选择的模型是否支持
LLaMA-Factory/src/llamafactory/data/template.py
在项目的这个地址中会有不同模型的支持模版。
这里用目前我最常用的两个模型举例子 一个是智谱的glm4-9B模型
_register_template( name="glm4", format_user=StringFormatter(slots=["&lt;|user|&gt;\n{{content}}&lt;|assistant|&gt;"]), format_assistant=StringFormatter(slots=["\n{{content}}"]), format_system=StringFormatter(slots=["&lt;|system|&gt;\n{{content}}"]), format_function=FunctionFormatter(slots=["{{name}}\n{{arguments}}"]), format_observation=StringFormatter(slots=["&lt;|observation|&gt;\n{{content}}&lt;|assistant|&gt;"]), format_tools=ToolFormatter(tool_format="glm4"), format_prefix=EmptyFormatter(slots=["[gMASK]&lt;sop&gt;"]), stop_words=["&lt;|user|&gt;", "&lt;|observation|&gt;"], efficient_eos=True, ) 这段代码看起来是在定义一个模板（template）的注册过程，可能是在某个框架或者系统中使用。让我来解释一下每个参数的作用和含义：
_register_template(...) 这是一个函数或者方法，用来注册一个名为 "glm4" 的模板。
参数解释： name=“glm4”：
这里指定了模板的名称，即 "glm4"。 format_user=StringFormatter(slots=[“\n{{content}}”])：
format_user 是用来格式化用户输入的内容的格式器（formatter）。StringFormatter(slots=["\n{{content}}"]) 表示使用字符串格式化器，slots=["\n{{content}}"] 指定了插槽（slots），用于接收用户输入内容，并在格式化时将内容放置在 \n{{content}} 的位置上。 format_assistant=StringFormatter(slots=[“\n{{content}}”])：
format_assistant 是用来格式化助理（assistant）输出的内容的格式器。同样使用了 StringFormatter，并指定了相同的插槽 ["\n{{content}}"]。 format_system=StringFormatter(slots=[“\n{{content}}”])：
format_system 是用来格式化系统（system）输出的内容的格式器。同样使用了 StringFormatter，并指定了相同的插槽 ["\n{{content}}"]。 format_function=FunctionFormatter(slots=[“{{name}}\n{{arguments}}”])：
format_function 是用来格式化函数（function）定义的格式器。FunctionFormatter(slots=["{{name}}\n{{arguments}}"]) 表示格式化时会使用 {{name}} 和 {{arguments}} 插槽，用于显示函数名称和参数。 format_observation=StringFormatter(slots=[“\n{{content}}”])：
format_observation 是用来格式化观察（observation）输出的内容的格式器。同样使用了 StringFormatter，并指定了相同的插槽 ["\n{{content}}"]。 format_tools=ToolFormatter(tool_format=“glm4”)：
format_tools 是用来格式化工具（tools）的格式器。ToolFormatter(tool_format="glm4") 表示工具格式化器将使用 "glm4" 格式。 format_prefix=EmptyFormatter(slots=[“[gMASK]”])：
format_prefix 是用来格式化前缀（prefix）的格式器。EmptyFormatter(slots=["[gMASK]&lt;sop&gt;"]) 表示前缀格式化器将输出 "[gMASK]&lt;sop&gt;"。 stop_words=[“”, “”]：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a9a0f4207f7d57b1471b998481c364c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a30f956c2d6bfc699b35dae15c6f6363/" rel="bookmark">
			C语言相关知识点（不定期更新内容）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		coutinue只能在循环当中使用
关键字不能用作变量的
typedef是用来给类型取别名的变量
一条语句结束的时候后面要有分号
函数后面不写分号
int main( )是函数，大括号和里面的是函数体，函数和函数体之间不能有分号
void是无、空的意思，后面没有返回语句return 0
括号里面的都是参数
printf是一个库函数
%d指定的是一种格式，它的意思是整数
跟输入输出相关的头文件都要包含stdio.h
\0是一个字符，是一个字符串作为结束的标志
字符串的末尾隐藏一个\0
strlen是一个函数，可以求字符串的长度，统计的是一个字符串的长度
C语言代码是一条一条的语句构成的
C语言是一种结构化的程序设计语言
if语句，switch语句就是循环语句
int是一种数据类型
整形和字符型才有signed和unsigned
可以省略不写的类型可以放到中括号里面去
表示真假的变量，我们把它称作布尔值
-Bool类型创建的变量，里面只能放真和假
-Bool = bool，bool是关键字
sizeof后面如果放的是类型，括号不能省略，如果是表达式或者变量，就能省略
％zd，打印的就是sizeof的返回值
33 ＋ 12 加号叫做操作符，33和12叫做操作数
加号此时又叫双目操作符，因为有两个操作数
％只能用于整数取模，不能用于小数取模
End Of File的值就是-1
全局变量不初始化的时候默认值是零
默认情况下，if和else后面只能跟一条语句
布尔类型是c99之后才有的
条件操作符也叫三目操作符
双引号也叫界定符
每个case语句后面结束的时候都要加上break
sqrt是一个库函数-计算平方根
system的头文件是＃include&lt;stdlib.h&gt;
strcmp是一个库函数，头文件是＃include&lt;string.h&gt;
0x开头的数字是一个十六进制的数字
void表示函数不返回任何值
[ ]叫做下标引用操作符
地址是用％p来打印
sizeof可以计算类型或者变量的长度
变长数组不能初始化
库函数中的头文件用尖括号，自己定义的函数用双引号
全局变量的作用域是整个工程
Add（a，b）把a传给它，把b传给它
set-arr（arr，sz）表示把arr数组中sz个元素设置一下
在函数的声明中，形参可以省略，但形参的类型不能省略
枚举也是一种特殊的整形
条件表达式的执行次数总是比循环表达式的执行次数多一次
递归无限的递归下去，就会出现栈溢出
Stack overflow栈溢出
数组的下标既叫下标，又叫索引
[ ]是双目操作符
在函数调用的时候，函数后面的括号就是函数调用操作符
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a30f956c2d6bfc699b35dae15c6f6363/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dd158867cc7575b2224e4eb13afa210/" rel="bookmark">
			AFAC2024-基于保险条款的问答 比赛日记 llamafactory qwen npu 910B1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AFAC2024: 基于保险条款的问答挑战——我的实战日记 概述 在最近的AFAC2024竞赛中，我参与了基于保险条款的问答赛道。这是一次深度学习与自然语言处理的实战演练，旨在提升模型在复杂保险文本理解与问答生成方面的能力。本文将分享我的参赛过程，包括数据处理、模型选择、微调策略、实验观察及最终成果。
比赛报名链接 https://tianchi.aliyun.com/competition/entrance/532194/introduction
数据与挑战 竞赛提供的数据集包含约6000条基于保险条款的问答对。这些数据覆盖了多种保险类型，如人寿保险、财产保险和健康保险，涉及保险条款的解释、索赔流程、覆盖范围等问题。数据集的多样性和专业性构成了此次竞赛的主要挑战。
llama factory 数据预处理 import json train = json.load(open("round1_training_data/train.json",'r')) dev = json.load(open("round1_training_data/dev.json",'r')) a = [] for train_one in train: a.append({"input":"""目前有产品名称、相关条款。如果问题与产品名称、相关条款有关系，那么就依照产品名称、相关条款回答问题，如果没有关系直接回答问题。 根据"""+train_one['产品名']+""",相关条款"""+train_one['条款']+"，问题："+train_one['问题'],"output":train_one['答案']}) for train_one in dev: a.append({"input":"""目前有产品名称、相关条款。如果问题与产品名称、相关条款有关系，那么就依照产品名称、相关条款回答问题，如果没有关系直接回答问题。 根据"""+train_one['产品名']+""",相关条款"""+train_one['条款']+"，问题："+train_one['问题'],"output":train_one['答案']}) json.dump(a,open('data/a.json','w'),ensure_ascii=False) 任务总共数据6000条。
最大长度超过10000。
修改llama factory data下的data_info.json 加入我们的数据集
"a": { "file_name": "a.json", "columns": { "prompt": "input", "response": "output" } }, 启动云脑任务的时候可以预先选择上我们要进行作业的模型。
配置好这个以后我们就可以启动任务了。在项目启动后我们需要把模型文件拉到本地。
from c2net.context import prepare #初始化导入数据集和预训练模型到容器内 c2net_context = prepare() #获取数据集路径 chat_json_path = c2net_context.dataset_path+"/"+"chat.json" #获取预训练模型路径 qwen1_5_14b_chat_path = c2net_context.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dd158867cc7575b2224e4eb13afa210/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/975f2dd00949b4f6cd00cf825b4fafc7/" rel="bookmark">
			jupyter学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 Jupyter Notebook是一个Web应用程序，它可以在网页页面中直接编写代码和运行代码，代码的运行结果也会直接在代码块下显示。
安装使用 前提：必须安装python
先升级pip至最新版本
pip3 install --upgrade pip 安装jupyter notebook
pip install Jupyter notebook 获取配置文件路径(Overwrite后面即为配置文件路径），打开配置文件找到notebook_dir，取消注释并设置notebook文件的存储路径。
jupyter notebook --generate-config &gt; /Users/a200007/Library/Python/3.8/lib/python/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020 warnings.warn( &gt; Overwrite /Users/a200007/.jupyter/jupyter_notebook_config.py with default config? [y/N]n 启动jupyter notebook
jupyter notebook [I 2024-07-19 17:00:58.604 ServerApp] Jupyter Server 2.7.0 is running at: [I 2024-07-19 17:00:58.604 ServerApp] http://localhost:8888/tree?token=c893dc1b59d3d75e3d5dc6cc8b424e9635cef6a4595aa02a [I 2024-07-19 17:00:58.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/975f2dd00949b4f6cd00cf825b4fafc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ed5b218e48bb8fad2349a6b2b63d1b6/" rel="bookmark">
			学生管理系统（C语言）（Easy-x）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		课 程 报 告
课 程 名 称： 程序设计实践 专 业 班 级 ： XXXXX XXXXX 学 生 姓 名 ： XXX 学 号 ： XXXXXXXXXX 任 课 教 师 ： XXX 学 期 ：XXXX-XXXX学年第X学期 课程报告任务书
题 目
学生成绩管理系统
主要
内容
用C语言开发一个简单的学生成绩管理系统。实现学生信息管理，并且有界面和跳转。
【数据结构】
1．学生成绩信息。包括：学号，姓名，成绩。
2．登陆账号信息。包括：密码、 权限级别（区别系统管理员用户和普通用户）。
3．学生个人信息。包括：学号，姓名，性别，学院，专业，联系方式。
【系统实现功能】
1.系统登陆
使用登陆账号和密码登陆，判断用户编号和密码是否一致，正确，则根据角色不同显示不同的界面。管理员显示管理员菜单。普通用户显示普通用户界面。
2.系统管理员
（1）学生信息管理：学生信息和成绩的增、删、改、查功能。
（2）全部展示所有学生的信息和成绩在一个交互界面上。
3. 普通用户（学生）
（1）学生可以注册自己的个人信息。
（2）学生可以根据自己的学号查询自己的个人信息和成绩。
任务
要求
一、提交材料应包括：
（1）系统源代码
（2）课程报告
二、整个设计过程具体要求
（1）需求分析
要求学生对案例系统进行分析，设计出需要完成的功能，完善各个模块的调用关系；要有系统结构图
（2）设计过程 要求学生进一步明确各模块调用关系，进一步完善模块函数细节（函数名、参数、返回值等），至少有一个关键模块的流程图。
（3）实现过程 要求学生养成良好的编码习惯、完成各个模块并进行测试，最终完成系统整体测试；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ed5b218e48bb8fad2349a6b2b63d1b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/008320fc454a5faa1b79af8be2c99fe5/" rel="bookmark">
			在python中使用正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正则表达式是什么？就是要寻找的数据的规律，使用正则表达式的步骤有三
第一，寻找规律，第二使用正则符号表示规律，第三，提取信息
看下面的代码
import re wenzhang = ('小草偷偷地从土里钻出来，嫩嫩的，绿绿的。园子里，田野里，瞧去，密码是：200073215，一大片一大片满是的。' '坐着，躺着，打两个滚，踢几脚球，赛几趟跑：27329915，一，捉几回迷藏。风轻悄悄的，草软绵绵的。') paqumima= re.findall('：(.*)，',wenzhang) paquzhunque = re.findall('：(.*?)，',wenzhang) print(paqumima,len(paqumima)) print(paquzhunque,len(paquzhunque)) 输出效果为
['200073215，一大片一大片满是的。坐着，躺着，打两个滚，踢几脚球，赛几趟跑：27329915，一，捉几回迷藏。风轻悄悄的'] 1 ['200073215', '27329915'] 2 相关知识：
第一行 import re
python中正则表达式的模块就是re，所以第一行先导入模块re
第二行：wenzhang=（‘巴拉巴拉巴巴拉拉‘）
就是把要提取的文本源文件赋值给一个叫wenzhang的变量，当然这个变量名可以自己随便起。
第三行：paqumima= re.findall('：(.*)，',wenzhang)
re是导入的模块，
点，findall是re模块中的一个方法，findall的使用格式是
re.findall（‘正则表达式’，这是里源文本变量）
‘正则表达式’的格式是
‘要爬取文字前面的字符（.*）要爬取文字后面的字符’
返回的值就是按正则表达式描述的内容。
这里的正则表达式是‘：（.*），’
意思就是，从源文本中找以：开头的，以，结尾的部分，这一部分就是用（.*）表示
其中.表示除换行符以外的任何一个字符。
*表示它前面的一个表达式0次到无限次。
但是第三行的正则表达式有个缺点就是以：开头，以最后一个，结尾，中间还爬取了好多没用的信息，所以我们用了第四行的正则表达式
第四行代码：paquzhunque = re.findall('：(.*?)，',wenzhang)
除了正则表达式多了一个？外，和第三行代码一模一样，从后面输出的效果来看
正则表达式（.*？）表示每一个符合正则表达式的内容。所以后面输出的效果长度也是2，也仅仅是输出了表示密码的部分。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/643f348d5222232ba2e60399b5133b29/" rel="bookmark">
			PACS-医学影像信息管理系统，全影像科室PACS源码，内置包括MPR、CMPR、VR等三维处理功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PACS系统可以覆盖医院现有放射、CT、MR、核医学、超声、内镜、病理、心电等绝大部分DICOM和非DICOM检查设备，支持从科室级、全院机、集团医院级乃至到区域PACS的平滑扩展，能够与医院HIS、集成平台的有效集成和融合，帮助医院实现了全院医学影像和报告的信息共享，提升了医院的服务质量和效率的同时，亦通过数字签名等先进的数字认证技术保证了核心数据的真实性、完整性和不可抵赖性。
PACS系统功能特点
1、严格遵守行业DICOM、IHE-C、HL7、ICD-10标准；
2、涵盖全影像科室的统一预约平台，有效减少患者排队等待时间，可自主定义的排队叫号系统令候诊大厅井然有序；
3、患者自助应用通过虚拟打印技术，提供基于报告、胶片的患者自助打印功能。减少胶片成本，提高用户体验；
4、全院PACS系统涵盖放射、超声、内镜、病理、核医学，以病人为中心的数据整合和统一视图，为用户提供一体化的解决方案；
5、前沿技术的广泛应用，显示协议、预加载窗、人机交互加速、音视频技术、图像识别、操作同步技术、多层架构、采集驱动、加密、权限控制；
6、强大的阅片工具，不仅提供常规测量、调节功能，并且内置包括MPR、CMPR、VR等强大的三维处理功能，解决放射科日常重建需求；
7、提供医学影像的快速调阅响应服务支持能力。支持医学影像的大容量在线存储管理和自动离线备份管理，支持在线存储影像自动维护管理和在线存储规模动态扩展能力。
PACS系统工作流程
1、工作流程设计原则
注重原有工作特征
注重影像中心现有工作流程，结合不同影像检查特点，在遵循PACS基本规律的前提下，工作流程的设计尽量符合影像中心现有工作特点，同时进行优化设计。
保证影像质量
在影像获取、存储、显示及处理过程中，以保证诊断应用为质量为标准。
保证影像传输速度
考虑到诊断过程的实用性要求，满足快速调影像资料。
优化管理模式
结合网络系统优势特点，加强科室人员、物质、费用的管理功能。
2、检查过程工作流程
医院中以图像为主要诊断参考的检查过程主要包括了：检查申请、预约与安排、检查登记、检查、图像存储、书写报告、审核报告、报告发送、报告阅读等几个环节。在每个环节中都可以用相应的计算机系统、软件或模块进行信息处理工作。
1）检查申请
此环节发生在病房或门诊等临床科室，是检查信息处理系统或PACS之外的系统。主要工作是向执行检查的医技科室提出正式的检查申请，说明病人的临床一般情况、检查的目的和要求。此环节生成检查申请清单，临床科室并可将病人的信息及一般情况提前发送至执行检查科室的工作站。
2）预约与安排
根据预约排队信息、检查申请清单，安排病人的检查日期、检查时间和检查地点。在预约和安排过程中完整记录病人的基本信息，这些信息可从上游流程获取，也可直接进行信息录入。可产生检查所必要的准备要求和书面文档及相应标签。此环节产生检查工作清单传送到下游流程，同时将预约状态传送回上游流程。
3）检查登记
在病人到达后执行，将检查清单中的状态修改为开始检查状态，正式启动检查过程。此产生检查设备所需要的工作单（Modality Worklist, MPPS等）。收费操作可在此环节进行。
4）检查
根据检查工作单将数据传送给检查设备，执行检查，产生检查图像，调整默认的图像窗口，选择输出图像，对图像进行质控处理，将图像传送给存储设备。此环节完成后将检查清单中的状态修改为完成检查状态。
5）图像存储
主要用于检查完后，质控医生对拍片技师所拍的图像进行图像质量评定，标记废片，可以对图像进行处理，删除不必要的图像，使报告医生能更好的理解图像，提高诊断质量。只有通过质控后的图像才能让报告医生观看。
可查看病人的信息，核对图像的正确性（即部位、方法正确），图像与病人是否对应。可要求检查医生重拍或补拍，记录重拍、补拍原因。
6）书写报告
可通过模板、词汇等多种方式协助医生输入诊断报告。
7）报告审核
当报告完成后可打印报告，使审核医生能够及时的审核报告，并及时通知报告医生审核是否通过及提示报告医生观看审核意见。
8）报告发送
发布报告到医院网络中供其它科室查阅。
9）报告阅读
此环节发生在病房或门诊等临床科室，提出申请的医生通过系统提供的工具阅读检查报告和图像。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c22b6d7644a304be9aef6ba83e56f6a8/" rel="bookmark">
			[Spring] Spring IoC与DI注入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌸个人主页:https://blog.csdn.net/2301_80050796?spm=1000.2115.3001.5343
🏵️热门专栏:
🧊 Java基本语法(97平均质量分)https://blog.csdn.net/2301_80050796/category_12615970.html?spm=1001.2014.3001.5482
🍕 Collection与数据结构 (92平均质量分)https://blog.csdn.net/2301_80050796/category_12621348.html?spm=1001.2014.3001.5482
🧀Java EE(96平均质量分) https://blog.csdn.net/2301_80050796/category_12643370.html?spm=1001.2014.3001.5482
🍭MySql数据库(93平均质量分)https://blog.csdn.net/2301_80050796/category_12629890.html?spm=1001.2014.3001.5482
🍬算法(97平均质量分)https://blog.csdn.net/2301_80050796/category_12676091.html?spm=1001.2014.3001.5482
🍃 Spring(97平均质量分)https://blog.csdn.net/2301_80050796/category_12724152.html?spm=1001.2014.3001.5482
感谢点赞与关注~~~
目录 1. IoC与DI入门1.1 IoC1.1.1 什么是容器1.1.2 什么是IoC1.1.3 举例说明控制反转(IoC)1.1.4 IoC的优点与IoC容器 1.2 DI 2. IoC与DI在Spring环境下的具体使用3. IoC详解3.1 Bean的存储3.3.1 @Controller3.3.2 @Service3.3.3 @Repository 3.2 为什么要有这么多注解3.3 方法注解@Bean3.3.1 单例使用@Bean3.3.2 定义多个对象使用@Bean3.3.3 重命名Bean 3.4 扫描路径 4. DI详解4.1 属性注入4.2 构造方法注入4.3 Setter注入4.4 @Autowired存在的问题 1. IoC与DI入门 1.1 IoC 通过前面的学习,我们知道了Spring是⼀个开源框架,他让我们的开发更加简单.他支持⼴泛的应用场景,有着活跃而庞大的社区,这也是Spring能够长久不衰的原因.
但是这个概念相对来说,还是比较抽象.
我们用⼀句更具体的话来概括Spring,那就是:Spring是包含了众多工具方法的IoC容器.
1.1.1 什么是容器 容器是用来容纳某种物品的（基本）装置.想我们生活中的水杯,垃圾桶等都是容器.那么我们想一想,我们之前的学习中,都有学习过哪些容器.
List/Map -&gt; 数据存储容器.Tomcat -&gt; Web容器 1.1.2 什么是IoC IoC其实我们在之前学习Spring的阶段就使用过.在类上面添加@RestController 和@Controller 注解,就是在Spring中创建出一个类的对象,并把这个对象交给Spring管理,Spring框架启动时就会加载该类.把对象交给Spring管理,就是IoC思想.这个交给Spring管理的对象我们统称为Bean.
所谓IoC,翻译过来就是Inversion of Control (控制反转),也就是说Spring是⼀个"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c22b6d7644a304be9aef6ba83e56f6a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f03ea798382c5606d4467fcff3d5660f/" rel="bookmark">
			【06】LLaMA-Factory微调大模型——微调模型评估
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上文【05】LLaMA-Factory微调大模型——初尝微调模型，对LLama-3与Qwen-2进行了指令微调，本文则介绍如何对微调后的模型进行评估分析。
一、部署微调后的LLama-3模型 激活虚拟环境，打开LLaMA-Factory的webui页面
conda activate GLM cd LLaMA-Factory/ llamafactory-cli webui 选择 模型的名称，并选择微调参数保存的路径（test1），之后选择Chat对话中加载模型
模型加载成功后即可进行问答交互，输入一条测试数据，来观察微调后模型的回复
请根据基本案情，利用三段论的推理方式得到判决结果，判决结果包括：1.罪名；\n2.刑期。 基本案情：\n广东省鹤山市人民检察院指控被告人李某甲于2014年7月7日9时许，在鹤山市宅梧镇双和公路宅梧收费站附近路段被民警抓获。民警当场从李某甲身上搜获搜获白色晶体38小包。经鉴定，从李某甲处缴获的白色晶体净重12.9克，检出甲基苯丙胺成分。被告人李某甲到案后如实供述自己的罪行，可以从轻处罚。建议对被告人判处有期徒刑六个月至一年六个月，并处罚金。提请法院依法惩处。上述事实，被告人李某甲在开庭审理过程中亦无异议，并有抓获被告人及破案的经过材料、被告人的供述、证人李X锋的证言、扣押物品清单、鉴定意见、辨认笔录、现场勘某足以认定。 模型的回答如下：
加载一个原始模型，输入相同的问题，分析微调前后模型回答的变化 可直观发现微调后的模型回答以三段论的形式展开，逻辑性更强，也具有参考意义 二、评估微调后的LLama-3模型 上传评估用的数据集并对数据集进行注册。
【提示】在模型训练与评估过程中，对数据集划分训练集、验证集和测试集极为重要。通常情况下，可以按照60%-20%-20%的比例进行划分，即60%的数据作为训练集，20%的数据作为验证集，剩下的20%作为测试集。这种划分方法具有广泛的适用性，但也可以根据具体应用场景进行调整。
训练集是机器学习模型训练过程中使用的数据集。通过对训练集进行数据预处理、特征提取和模型训练，可以使得模型能够更好地拟合数据，并能够在未知数据上进行有效的预测。在训练过程中，需要对模型进行参数选择和调整，以使得模型在验证集上的表现达到最佳。
验证集主要用于调整模型的超参数，以及在训练过程中对模型进行验证和评估。超参数是在模型训练过程中需要手动设置的参数，例如学习率、迭代次数等。这些参数对模型的性能有着重要的影响，需要通过验证集来进行调整，以使得模型在验证集上的性能达到最佳。
测试集是在模型训练和参数调整完成后，用于评估模型性能的数据集。模型的最终性能如何，需要通过测试集来进行评估。在测试过程中，需要对数据进行预处理和特征提取，以使得模型能够更好地适应测试数据。同时，需要对模型的预测结果进行分析和评估，以确定模型的性能如何，以及是否需要进行进一步的优化。
具体可参考以下这篇博文
大模型训练：训练集、验证集与测试集的划分策略-百度开发者中心 (baidu.com)https://developer.baidu.com/article/details/1900656数据集包含11236条，本文按照9:1的比例划分训练集和测试集。即训练集：10112条、测试集：1123条。模型使用训练集训练，在测试集上评估。将原始数据集切分的python代码如下：
使用Python的`json`模块来加载和保存JSON数据，以及使用`random`模块来随机划分数据。以下是一个简单的示例代码，它将读取`law_train.json`文件，然后将数据随机分为训练集和测试集，并将它们分别保存到`llm_law_train.json`和`llm_law_test.json`文件中。 ```python import json import random # 定义分割比例 train_ratio = 0.9 # 读取原始JSON文件 with open('law_train.json', 'r', encoding='utf-8') as f: data = json.load(f) # 随机打乱数据顺序 random.shuffle(data) # 计算训练集和测试集的划分点 split_index = int(len(data) * train_ratio) # 分割数据为训练集和测试集 train_data = data[:split_index] test_data = data[split_index:] # 将训练集保存到JSON文件 with open('llm_law_train.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f03ea798382c5606d4467fcff3d5660f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a86f0d895a8d1cf9bce0bffa066e2a81/" rel="bookmark">
			前端跳槽突围课：React18底层源码深入剖析(完结)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		核心代码，注释必读
// download：3w 52xueit com
vue 2.x 响应式
Object.defineProperty
React 18：技术革新与性能飞跃 React 18 作为 React 框架的一个重要里程碑，带来了众多引人注目的新特性和性能优化，极大地提升了开发效率和用户体验。本文将深入探讨 React 18 的核心特性及其在实际开发中的应用。
一、新渲染引擎：React Reconciler React 18 采用了全新的渲染引擎 React Reconciler，这一引擎带来了更好的性能和可扩展性。React Reconciler 允许开发者更高效地处理大型和复杂的组件树，显著减少了在渲染大型应用程序时的卡顿现象，提供了更流畅的用户体验。通过这一新引擎，React 能够在维护 UI 一致性的同时，实现更快的响应速度和更高的吞吐量。
二、并发模式（Concurrent Mode） 并发模式是 React 18 引入的一个革命性特性，它允许 React 应用在同一时间处理多个更新，极大地提升了应用的响应速度和流畅度。并发模式通过引入过渡（Transitions）和悬停（Suspense）等概念，使得开发者能够更精细地控制组件的更新优先级，从而优化应用的性能和用户体验。
过渡（Transitions） 过渡 API 允许开发者将状态更新划分为紧急和非紧急两类。紧急更新会立即处理，以保证应用的即时响应；而非紧急更新则可以在后台进行，不会阻塞用户的交互。这种机制使得应用能够在处理异步操作（如数据加载）时保持流畅的用户体验。
悬停（Suspense） 悬停是 React 16.6.0 引入的，但在 React 18 中得到了进一步的扩展和应用。悬停允许开发者在组件树完成数据加载之前，展示一个默认的加载状态，如加载指示器或骨架屏。这样不仅提升了用户体验，还使得开发者能够更灵活地处理数据加载过程中的状态变化。
三、优化服务器端渲染（SSR） React 18 通过引入新的“Streaming Server Renderer”技术，对服务器端渲染进行了优化。该技术允许 React 在服务器端将组件树分割成小块，然后逐块发送给客户端。这种优化显著提高了首次页面加载速度，从而改善了用户体验。在开发大型或复杂的 Web 应用时，这一特性尤为重要。
四、新的事件处理 API React 18 引入了一个新的事件处理 API，提供了更好的控制和可读性。这一 API 使得开发者能够更轻松地处理用户交互事件，实现更高效的交互和更好的性能。新的事件处理 API 减少了不必要的渲染次数，提高了应用的响应速度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a86f0d895a8d1cf9bce0bffa066e2a81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f9b12b5965f0cc9f1af936d06bc542f/" rel="bookmark">
			SpringBoot整合WebSocket服务 springboot整合websocket springboot使用websocket springboot使用websocket
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot整合WebSocket服务 springboot整合websocket springboot使用websocket springboot使用websocket 1、前言2、开始使用2.1、加入Maven依赖2.2 (推荐方式) 使用 WebSocketConfigurer方式创建 WebSocket端点 (二选一)2.2.1 创建一个 测试 WebSocket处理器2.2.2 开启 WebSocket 并且注册WebSocket处理器 2.3 使用 ServerEndpoint方式创建 WebSocket端点 (二选一)2.3.1创建一个 测试 WebSocket处理器2.3.2 开启 WebSocket 3、 连接访问4、两种方式如何选择ServerEndpointExporterregisterWebSocketHandlers主要区别 1、前言 注意： 仅使用 SpringBoot封装好的 spring-boot-starter-websocket 服务，并不是使用第三方 Netty或者 Apache MINA
spring-boot-starter-web: 底层使用 Java WebSocket API （JSR-356）实现
spring-boot-starter-webflux: 底层使用 Netty实现(没有使用过，不知道具体)
官方文档1
官方文档2
2、开始使用 2.1、加入Maven依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; 2.2 (推荐方式) 使用 WebSocketConfigurer方式创建 WebSocket端点 (二选一) 2.2.1 创建一个 测试 WebSocket处理器 类名称：TestSocketHandler
import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f9b12b5965f0cc9f1af936d06bc542f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c93a1d9767da95b910a5577a0938ae4/" rel="bookmark">
			【AI 大模型】OpenAI 接口调用 ② ( MacOS 中进行 OpenAI 开发 | 安装 openai 软件包 | PyCharm 中开发 Python 程序调用 OpenAI 接口 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、安装 Python SDK1、检查 Python 版本2、安装 Python - 安装包安装3、安装 Python - Homebrew 安装 二、安装 OpenAI 软件包三、安装 PyCharm四、导入 OpenAI 库并进行开发 一、安装 Python SDK 1、检查 Python 版本 打开 MacOS 的 命令行终端 :
进入 MacOS 的 " 启动台 " , 选择 " 其它 " 选项 ,
选择 " 终端 " 选项 , 打开终端 ;
在终端中输入
python --version 或
python3 --version 选项 , 可以查看当前安装的 Python 或 Python3 的版本 ,
执行 第二条命令 , 发现当前的 Python 版本是 Python 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c93a1d9767da95b910a5577a0938ae4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/359e1c71bf63785f44fb165200f8394d/" rel="bookmark">
			开放开源开先河（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		伴随开源生态快速发展壮大、开源项目数量爆发式增长的是国家层面对开源的鼓励和推动。2020被业界称为开源爆发年，本年度的“木兰协议”正式成为国际化开源许可证，工信部联合全球知名开源平台Gitee建设中国独立的开源托管平台。2021年3月，开源首次被列入“十四五”规划，“支持数字技术开源社区等创新联合体发展，完善开源知识产权和法律体系，鼓励企业开放软件源代码、硬件设计和应用服务”。开源已上升至国家战略层面，是政府未来工作的重点。2021年11月，工信部印发《“十四五”软件和信息技术服务业发展规划》，提出到2025年建设2-3个有国际影响力的开源社区。文件突出强调开源在驱动软件产业创新发展、赋能数字中国建设的重要作用，提出“繁荣国内开源生态”的重点任务，设置“开源生态培育”专项行动，统筹推进建设高水平基金会。面向重点领域打造优秀开源项目，深化开源技术应用，夯实开源基础设施，普及开源文化，完善开源治理机制和治理规则，加强开源国际合作，推动形成众研众用众创的开源软件生态。开源指导文件和配套政策逐渐落地，从国家层面鼓励产业加大开源投入，从顶层设计、技术底座、行业标准、数字安全、国际交流等维度为开源生态发展保驾护航。
近年来，国内企业开源软件应用比例逐年提升，对开源技术的接受程度越来越高，使用开源技术已成主流。根据中国信通院调查显示，2021年已经使用开源技术的企业占比为88.2％，暂未计划使用开源技术的企业占比仅为2.1％。而从全球范围来看，97%的开发者和99%的企业都在使用开源软件。从软件供应链来看，开源已成为未来信息技术和产业竞争的新战场。开源已成为当下全球信息产业标准商业操作实践，全球先进科技公司，都将开源作为商业长期成功的关键战略手段，开源和商业相互促进趋势明显。
产、学、研、用、官、媒等品牌次级杠杆分别从技术、政策、生态、产业等方面为塑造中国开源品牌铺平了道路。而产、学、研、用、官、媒既是品牌生态构建的依托和载体，也是科技品牌营销传播渠道扩张的依托和载体。秉持共创共建精神、建设开源生态、打造共享平台，是其发展的必经之路。面临技术的快速迭代和需求的日新月异，共同努力、共享信息的紧迫性显而易见，搭建和使用开源生态是一种加速专业知识价值化创造，避免基础错误发生的高效方式。开源生态平台将行业专家、各行业专业人员、开发者和科学家等聚集在一起的力量和潜力无限，通过各方能力和资源进行共享与优化配置，在机制的保障之下形成生态命运共同体，进行有机高效协作、发挥优势，实现新产品、新服务和新商业模式的价值创造，实现生态系统整体价值提升，并有效防范风险，实现共荣共赢。
伴随着全球开源生态迅猛发展的，是面临不容忽视的开源风险。企业在享受开源引入带来的成本降低、技术迭代速度加快等便利的同时，也面临着安全漏洞风险、数据泄露风险、知识产权风险和管理风险。开源软件的漏洞和缺陷问题威胁系统安全运行，根据新思科技发布的《2021 开源安全与风险分析报告》显示，84％的开源代码库至少含有一个漏洞，近三年漏洞比例逐年增高，60％的已审核代码库中包含高风险漏洞。所有经过审计的营销科技类公司的代码库都包含开源，其中95％的营销科技代码库存在开源漏洞。97％的金融服务、金融科技行业代码库包含开源代码，其中超过60％的代码库存在漏洞。开源软件因其共享特性可能导致数据泄露风险，开源代码在拥有互操作性、无歧视性和透明性的同时，也存在着数据安全隐患。开源软件很多配置信息会涉及到账号密码，如果不对代码所携带的信息进行检查、评估和加密处理，一旦开发者出现疏忽没能及时处理这些敏感数据，可能会造成大量的用户信息随着代码的共享而泄露。开源软件知识产权风险问题相对专业和复杂，由于软件本身在受到知识产权保护时存在一定权利竞合而带来的专业性和复杂性，软件源代码可能同时存在多种权利类型，源代码可以作为计算机软件作品受到著作权保护，源代码实现的功能形成新的技术方案可以申请专利受到专利权保护，开源前如果源代码符合商业秘密保护要求可以受到反不正当竞争法保护，这就要求对开源软件知识产权问题进行多维度的综合分析。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28980d8b318f7ba54dd70c96063a5694/" rel="bookmark">
			【数据结构】初识数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.前言
2.时间和空间复杂度
2.1算法效率
2.2时间复杂度
2.2.1概念
2.2.2大O渐进表示法
2.2.3推导大O阶方法
2.2.4常见时间复杂度计算举例
2.3空间复杂度
2.3.1概念
2.3.2常见空间复杂度计算举例
3.包装类
3.1基本数据类型和对应的包装类
3.2装箱和拆箱
4.泛型
4.1概念
4.2引出泛型
4.3语法
5.泛型类的使用
5.1语法
5.2类型推导
6.泛型的上界
6.1概念
6.2语法
7.泛型方法
8.总结
1.前言 本篇将主要介绍数据结构的基本知识：时间和空间复杂度、算法效率、大O渐进表示法、包装类、泛型相关知识。
2.时间和空间复杂度 2.1算法效率 算法效率分析分为两种：第一种是 时间效率 ，第二种是 空间效率 。 时间效率被称为时间复杂度。 空间效率被称作空间复杂度。 时间复杂度主要衡量的是一个算法的运行速度，而空间复杂度主要衡量一个算法所需要的额外空间。 2.2时间复杂度 2.2.1概念 一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法的时间复杂度。 2.2.2大O渐进表示法 举个例子：请计算一下func1基本操作执行了多少次？
void func1(int N) { int count = 0; for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; N; j++) { count++; } } for (int k = 0; k &lt; 2 * N; k++) { count++; } int M = 10; while ((M--) &gt; 0) { count++; } System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28980d8b318f7ba54dd70c96063a5694/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e36a317abd5d975a132569b255b7c730/" rel="bookmark">
			前端出发能走多远——写在前面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022 年 11 月 15 日，虽然在意料之中，但是靴子终于落地了：我们被裁了。互联网的寒冬肆意呼啸，冰冻了一批又一批人，大环境下能苟活已经很不错了。没有冰冻到你时，你觉得自己是寒冬的旁观者，寒冬降临到你头上时，你才感受到切肤之痛，这就是我当时真实的感受。当然，造成的影响就是北漂生活就此结束，我换了一个城市工作和生活。
如今，2023 年 11 月，一年时间很快过去，我的工作生活相对稳定了。虽然当前的工作与技术相关，但是深度和广度要求不高，担心多年的技术底子最终无用武之地，也担心知识随着时间的推移终究淡忘。于是，我下定决心，要把技术记录下来。
既然已经决定记录，问题便接踵而至：以什么形式的去记录？围绕什么主题展开？既然自我标榜是一名“前端”开发者，那我就从前端入手，同时，我又觉得如果仅仅是前端知识终究圈定了范围，属实是画地为牢了，那么一定要涉及一些前端之外的东西。于是，我定了一个专题前端出发能走多远：从前端开始，不忘记自己是一个前端开发者，它奠定了我的技术低调，“远”体现了两层含义：一是我的技术能挖掘多深，二是我的视界有多大，在深挖的过程中，我能否 360° 全面旋转。我觉得这个工作就好比挖土，挖得多深是离地深度，挖得得宽是土方体积，前者决定层次，后者决定质量。
希望这是一个很好的专题。这是在为自己打气，也在为我自己定目标。
言及至此，我有必要介绍一下我自己和我的前端之路。12 年毕业之后，开启“北漂”之路，从java web开始，2 年时间入了 web 之门，同时也埋下了全栈的执念（那时候也确实没有全栈的说法）。之后加入一家做搜索引擎的公司，参与搜索前端，这是我的技术的快速成长期，我确实体会到技术的乐趣，我能每天汲取新的知识，上午学习，下午处理工作，甚至有时连中午吃饭都是耽误的。之后，加入了一个视频网站，时间不长，却花了比较多的在构建工具的建设。再之后又回到之前的搜索引擎的公司，参与搜索结果的落地页建设，我开始思考如何从 0 到 1 去构建工程，更多的参与一些前端工程化的工作。疫情之后，我来了北漂之行的最后一家公司——所谓的某厂，在这里我可以以更大更广的视角去审视前端页面和前端工程，将前后端彻底打通，微前端、低代码、前后端同构、云原生、大数据等概念和实践轮番登场，确实让我看到了大厂的深厚底蕴。
很幸运，我赶上了互联网浪潮的涨潮。从 jQuery 一统天下到 React、Vue、Angular 三分帝国，而今后起之秀 Svelte、Solid 的加入，外部环境不管如何，前端的技术迭代周期已经打开，而且战况预发激烈。分析上述各框架的内在，jQuery 的直接操作 DOM 变得越来越不被接受，通过数据驱动才是取胜之道，但是虚拟 DOM 存在性能损失，让后来者 Svelet 和 Solid 之流又不得不考虑重新回归到直接操作 DOM，所幸历史只是轮回并没有开倒车，开发者依然只需关注数据流动（变化）。
由此看来，前端技术本质上是依托基本技术原理的上下波动，在激进和保守之间徘徊。比如当年前后端分离如火如荼，边界划分如边境的争夺——寸土必争，前端工程师好不容易逃脱 JSP、ASP、PHP 等动态语言的掌控。然而多年以后，前后端同构仿佛又让一切回到原点，所幸的是这次的主角是 Node.js——使用 javascript 作为编程语言。所以依然是前后端的分、前后端的合，究其原因可能也仅仅是四个字——降本增效。
在很多人来看来，前端就是一个画页面做交互的。我不能说这个说法错误，只能说这个说法只看到了冰山之一角。前端后端之区分本质上是一个边界的划分，前端更加专注于快速的页面呈现和极致的交互体验。这里面我提到了两个关键字：快速和极致，简单来说如何把页面效果快速的呈现给用户，这个用户对于产品的第一印象，之后如何保证丝滑的体验。这是用户所能体验和感受到的，但其内部确实有很多的技术细节，简单列举一下：
页面资源如何加载？资源又如何组织？如何生成？如何快速加载资源？如何快速实现首屏渲染以减少白屏时间？如何设计页面主题风格，按钮风格？如何设计动画效果？如何持续优化用户体验？如何确保不同展现终端的一致体验？数据怎么流动？页面行为如何组织？如何确保网站的稳定性？如何保证部署的稳定性？ 看似一个个简单的页面，背后有这复杂的体系支撑。前端不仅仅是页面的实现，还包括围绕页面的周边技术，从一个页面出发，所能扩展的全部边界。
此刻，我想着我的专题前端出发能走多远，希望对那些入了坑和还未入坑的人有所帮助，我们共同走得更远！
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/135/">«</a>
	<span class="pagination__item pagination__item--current">136/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/137/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>