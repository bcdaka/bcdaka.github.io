<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88cb4076b5af1bb34fd8fef356173493/" rel="bookmark">
			懒人福音：Java版Webhook机器人，一键开启‘躺赢’模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0. 前言 Webhook是一种网络回调机制，允许一个应用程序在特定事件发生时通知另一个应用程序。这种通知通常是通过HTTP POST请求发送给预先设定的URL（即Webhook端点）。当事件触发时，如数据库更新、文件上传完成、支付确认等，源系统会向目标URL发送数据。这种方式使得两个系统能够实时交互，而不需要定期轮询。
企业微信、飞书、钉钉等企业级协作工具中的自定义机器人功能，常常使用Webhook作为实现自动消息传递的核心机制。在当今快速发展的数字化时代，自动化和即时通讯成为了提升工作效率的关键因素。企业微信、飞书、钉钉等协作平台凭借其强大的沟通和管理功能，已经成为许多企业和组织日常运营的基石。然而，随着业务需求的日益复杂，仅仅依赖平台的基础功能已无法满足定制化和自动化的高级需求。因此，Webhook在这些平台中扮演了桥梁的角色，使得自定义机器人能够与外部服务进行实时通信，实现更高级的自动化功能。
让我们一起踏上这段旅程，解锁Webhook自定义机器人的无限潜力，让自动化成为推动企业创新和成长的新动力。
1. 企业微信（WeCom） 1.1 在群组中添加自定义机器人 首先你得有一个企业微信群。然后才能邀请自定义机器人进群。我这里已经创建好了。
点击自定义机器人就可以看到详情：
特别特别要注意：一定要保护好机器人的webhook地址，避免泄漏！不要分享到github、博客等可被公开查阅的地方，否则坏人就可以用你的机器人来发垃圾消息了。
可以在终端先试下curl命令，这里直接填入URL即可正常执行！
1.2 测试调用自定义机器人的 webhook 地址，向所在群组发送消息。 官方网址：https://developer.work.weixin.qq.com/document/path/99110
仔细查看文档，重点看curl的请求参数命令。 代码实现。代码实际上就是在模拟curl命令这个过程，只不过不同的Webhook规范不一样，需要查看官方API文档。 注意：这里在模拟的时候，需要引入两个依赖。这两个Maven依赖项分别用于处理编码解码操作和HTTP请求
&lt;/dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;4.9.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; import okhttp3.*; import java.io.IOException; /** * @author Juechen * @version : WeComWebhookSender.java */ public class WeComWebhookSender { private static void WeCom(String url, String text) { OkHttpClient client = new OkHttpClient(); String webhookUrl = url; String payload = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88cb4076b5af1bb34fd8fef356173493/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f51aeb7c61008853cf1cc2fd4698bcd/" rel="bookmark">
			Python 字典（Dict）详解与实战应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、字典的定义和创建
1.使用花括号定义
2.使用dict()函数创建
二、字典的三种遍历方式
方式1：遍历字典的键，通过键获取值 dict.keys()
方式2：遍历字典的值，但不能通过值获取键 dict.values()
方式3：最常用的方法：直接获取键值对 dict.items()
三、字典的常见操作
1.添加
2.删除
pop（）根据键删除键值对，并返回值
popitem（）默认删除最后一个键值对，并以元组的方式返回这个键值对
clear（）清空字典
3.修改
4.查找
5.copy拷贝
1.浅拷贝
2.深拷贝
总结
前言 字典（Dict）是一种非常强大且常用的数据结构，它通过键值对（key-value pairs）的形式存储数据。字典的键（key）必须是唯一的且不可变（如字符串、数字或元组），而值（value）则可以是任意数据类型。
一、字典的定义和创建 示例：pandas 是基于NumPy 的一种工具，该工具是为了解决数据分析任务而创建的。
1.使用花括号定义 Python中，字典可以通过花括号{}直接定义，键和值之间用冒号:分隔，键值对之间用逗号,分隔。
# 使用花括号定义字典 d1 = { "name": "马云", "age": 18 } print(d1, type(d1)) # 输出: {'name': '马云', 'age': 18} &lt;class 'dict'&gt; 2.使用dict()函数创建 除了直接使用花括号，还可以使用dict()函数来创建字典。该函数可以接受多种形式的参数
# 使用dict()函数创建空字典 d2 = dict() print(d2, type(d2)) # 输出: {} &lt;class 'dict'&gt; # 使用关键字参数创建字典 d3 = dict(a=10, b=20, c=30) print(d3, type(d3)) # 输出: {'a': 10, 'b': 20, 'c': 30} &lt;class 'dict'&gt; # 使用包含键值对的列表（每个元素为元组）创建字典 d4 = dict([("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f51aeb7c61008853cf1cc2fd4698bcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98a35324f1b55fb63e3b1bb753589399/" rel="bookmark">
			基于Java&#43;SpringMvc&#43;Vue技术的药品进销存仓库管理系统设计与实现系统(源码&#43;LW&#43;部署讲解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：每个学校每个老师对论文的格式要求不一样，故本论文只供参考，本论文页数达到60页以上，字数在6000及以上。
基于Java+SpringMvc+Vue技术的在线学习交流平台设计与实现 目录
第一章 绪论
1.1 研究背景
1.2 研究现状
1.3 研究内容
第二章 相关技术介绍
2.1 Java语言
2.2 HTML网页技术
2.3 MySQL数据库
2.4 Springboot 框架介绍
2.5 VueJS介绍
2.6 ElementUI介绍
第三章 系统分析
3.1 可行性分析
3.2 系统性能分析
3.3 系统功能分析
3.4 系统流程分析
第四章 系统设计
4.1 系统概要设计
4.2 系统结构设计
4.3 系统顺序图设计
4.4 系统关系图设计
4.5 数据库设计
第五章 系统详细设计
5.1 供应商管理
5.2 库存管理
5.3 供应商统计分析
5.4 商品管理
5.5 应收管理
5.6 库存盘点
5.7 入库历史
5.8 进货订单
第六章 部分代码实现
6.1 Spring boot 配置代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98a35324f1b55fb63e3b1bb753589399/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/781ec1307e27688ba686649ffb5f1bf6/" rel="bookmark">
			opencv—常用函数学习_“干货“_3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
八、图像拼接
水平拼接图像 (hconcat)
垂直拼接图像 (vconcat)
全景图像拼接 (Stitcher)
九、颜色通道及数据格式
转换图像的颜色空间 (cvtColor)
转换图像的数据类型 (convertTo)
分离和合并颜色通道 (split 和 merge)
提取和插入颜色通道 (extractChannel 和 insertChannel)
应用颜色映射 (applyColorMap)
十、图像复制函数
使用 clone 进行深拷贝
使用 copyTo 进行复制
使用 copyTo 和掩码进行复制
十一、图像变化与增强
缩放、计算绝对值并转换为8位 (convertScaleAbs)
计算自然对数 (log)
计算指数 (exp)
计算幂 (pow)
计算平方根 (sqrt)
直方图均衡化 (equalizeHist)
自适应直方图均衡化 (CLAHE)
细节增强 (detailEnhance)
改变光照条件 (illuminationChange)
http://t.csdnimg.cn/i8pqt —— opencv—常用函数学习_“干货“_总（VIP）
散的正在一部分一部分发，不需要VIP。
资料整理不易，有用话给个赞和收藏吧。
八、图像拼接 在OpenCV中，图像拼接是指将多幅图像合并成一幅图像的过程。OpenCV提供了几种常用的函数和类来实现图像拼接。下面介绍这些拼接相关的函数及其使用示例。
图像拼接函数hconcatvconcatStitcher水平拼接图像垂直拼接图像全景图像拼接类 水平拼接图像 (hconcat) import cv2 import numpy as np # 创建两个示例图像 image1 = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/781ec1307e27688ba686649ffb5f1bf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/844bd76b961af007917b30b5b96193a7/" rel="bookmark">
			算法复杂度＜数据结构 C版＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是算法复杂度？ 简单来说算法复杂度是用来衡量一个算法的优劣的，一个程序在运行时，对运行时间和运行空间有要求，即时间复杂度和空间复杂度。
目录
什么是算法复杂度？
大O的渐近表达式
时间复杂度示例
空间复杂度示例
常见复杂度对比：
大O的渐近表达式 时间复杂度，我们常常使用大O的渐近表示法
推导大O阶的规则：
●时间复杂度函数式T(N)中，只保留高阶项，去掉那些低阶项。
（因为当N不断变大时，低阶项对结果的影响越来越小，当N无穷大时，就可以忽略不计了）
●如果最高阶项存在且不是1，则去除这个项目的常数系数。
（因为当N不断变大，这个系数对结果的影响不断变小，当N无穷大时，其就可以忽略不计了）
●T(N)如果没有N相关的项目，只有常数项，那么就用常数1替代所有加法。
时间复杂度示例 1.
// 计算Func2的时间复杂度？ void Func2(int N) { int count = 0; //1次 for (int k = 0; k &lt; 2 * N ; ++ k) { ++count; //2*N次 } int M = 10; while (M--) { ++count; //10次 } printf("%d\n", count); } 得：T(N)=1+2*N+10
由第一条和第二条规则得到时间复杂度O(N).
2.
// 计算Func3的时间复杂度？ void Func3(int N, int M) { int count = 0; for (int k = 0; k &lt; M; ++ k) //M次 { ++count; } for (int k = 0; k &lt; N ; ++ k) //N次 { ++count; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/844bd76b961af007917b30b5b96193a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afc21516723354dc18c434a123b1e723/" rel="bookmark">
			Spark底层原理：案例解析（第34天）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 一、Spark架构设计概述
二、Spark核心组件
三、Spark架构设计举例分析
四、Job调度流程详解
五、Spark交互流程详解
文章目录 系列文章目录前言一、Spark架构设计概述1. 集群资源管理器（Cluster Manager）2. 工作节点（Worker Node）3. 驱动程序（Driver Program/Driver） 二、Spark核心组件1. Spark Core2. Spark SQL3. Spark Streaming4. Spark MLlib5. Spark GraphX 三、Spark架构设计举例分析四、Job调度流程详解五、Spark交互流程详解1、client_Spark集群2、cluster_Spark集群3、client on Yarn集群4、cluster on Yarn集群 前言 Apache Spark是一个快速、通用、基于内存的分布式计算引擎，专为大规模数据处理而设计。其架构设计体现了高度的模块化和可扩展性，支持多种数据处理模式，包括批处理、实时流处理、交互式查询、机器学习和图计算等。以下将详细介绍Spark的架构设计，并结合具体例子进行分析。
一、Spark架构设计概述 Spark的架构设计遵循主从（Master-Slave）架构模式，主要由以下几部分组成：
1. 集群资源管理器（Cluster Manager） 负责集群资源的分配和管理，包括CPU、内存等资源。根据不同的部署模式，Cluster Manager可以是Spark自带的Standalone模式，也可以是YARN、Mesos等第三方资源管理器。 2. 工作节点（Worker Node） 执行提交的任务，通过注册机制向Cluster Manager汇报自身的资源使用情况。在Master的指示下，Worker Node会创建并启动Executor进程，用于执行具体的计算任务。 3. 驱动程序（Driver Program/Driver） 运行应用程序的main()函数，负责创建SparkContext对象，并与Cluster Manager和Executor进行通信，以协调任务的执行。执行器（Executor）：运行在Worker Node上的进程，负责执行Driver分配的任务，并将结果返回给Driver。Executor是Spark中真正的计算单元，它负责Task的运行并将结果数据保存到内存或磁盘上。 二、Spark核心组件 Spark基于Spark Core建立了多个核心组件，每个组件都提供了特定的数据处理能力：
1. Spark Core 基础设施：包括SparkConf（配置信息）、SparkContext（Spark上下文）、Spark RPC（远程过程调用）、ListenerBus（事件总线）、MetricsSystem（度量系统）、SparkEnv（环境变量）等，为Spark的各种组件提供基础支持。存储系统：Spark的存储系统优先考虑在内存中存储数据，当内存不足时才会将数据写入磁盘。这种内存优先的存储策略使得Spark在处理大规模数据时具有极高的性能。调度系统：由DAGScheduler和TaskScheduler组成，负责任务的调度和执行。DAGScheduler负责将用户程序转换为DAG图，并根据依赖关系划分Stage和Task；TaskScheduler则负责按照调度算法对Task进行批量调度。计算引擎：由内存管理器、任务管理器、Task Shuffle管理器等组成，负责具体的计算任务执行。 2. Spark SQL 提供基于SQL的数据处理方式，支持结构化数据的查询和分析。Spark SQL可以将结构化数据（如JSON、CSV、Parquet等）转换为RDD或DataFrame，并支持使用Hive元数据和SQL查询。 3. Spark Streaming 提供流处理能力，支持从Kafka、Flume、Kinesis、TCP等多种数据源实时获取数据流，并将其转换为可供分析和存储的批处理数据。Spark Streaming使用DStream（离散流）作为数据流的抽象，并支持一系列的转换操作。 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afc21516723354dc18c434a123b1e723/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2ef3d9ae0c0523663a7fa9f6d576a32/" rel="bookmark">
			【Vue】Vue3的emits方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、简介 Vue 3中的emits方法主要用于在子组件中声明它可以触发的事件，这些事件可以被父组件监听和处理。emits方法不仅提供了一种组件间通信的方式，还允许开发者在子组件中定义事件的验证规则，确保事件传递的数据符合预期。 2、基本用法 在Vue 3中，emits可以通过两种方式使用：在&lt;script&gt;标签的export default对象中直接使用，或者在&lt;script setup&gt;标签中使用defineEmits编译器宏。 2.1 在&lt;script&gt;标签中使用 在&lt;script&gt;标签中，emits可以是一个数组或对象。数组形式简单列出子组件可能触发的所有事件名；对象形式则允许为每个事件指定验证函数。
数组形式：
export default { emits: ['update', 'delete'], // ... 其他选项 } 对象形式： export default { emits: { // 无验证函数 update: null, // 有验证函数 delete: (payload) =&gt; { if (typeof payload === 'number') { return true; } else { console.warn('Invalid delete event payload'); return false; } } }, // ... 其他选项 } 2.2 在&lt;script setup&gt;标签中使用defineEmits 在&lt;script setup&gt;中，defineEmits用于声明组件的emits。与在&lt;script&gt;标签中直接声明不同，defineEmits是一个编译器宏，只能在&lt;script setup&gt;中使用。 &lt;script setup&gt; import { defineEmits } from 'vue'; const emit = defineEmits(['update', 'delete']); function handleClick() { emit('update', { id: 1, name: 'New Name' }); // 或者 emit('delete', 123); } &lt;/script&gt; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2ef3d9ae0c0523663a7fa9f6d576a32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54c5f30baa1eed4aa09501e51c97887d/" rel="bookmark">
			【手写数据库内核组件】0301 动态内存池，频繁malloc/free让系统不堪重负，动态内存池让应用自由使用动态内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动态内存管理 ​专栏内容：
postgresql使用入门基础手写数据库toadb并发编程 个人主页：我的主页
管理社区：开源数据库
座右铭：天行健，君子以自强不息；地势坤，君子以厚德载物.
文章目录 动态内存管理一、概述 二、动态内存管理原理 2.1 内存分配策略 2.2 内存回收策略 三、动态内存管理实现 3.1 内存管理结构定义 3.2 memPage 申请与释放 3.3 memNode 释放与释放 3.4 应用申请内存 四、总结 结尾 一、概述 在平时运行时分配内存时，使用动态内存分配malloc/free或 new/delete，会直接从操作系统申请虚拟内存，释放时也归还给操作系统；
而操作系统会记录那些内存片段正在使用，那些已经释放；时间久后，内存碎片就越来越多，最终没法分配一片较大的内存出来，所以系统会尽量让空闲的片段连成一整片，不断的整理。
一般应用程序需要动态分配的次数和频率不高时，对操作系统的负担不重；
而像数据库这样的重型应用跑起来，会有大量的运行时动态内存的分配和释放，如果不对动态内存进行用户态的管理，必然会拖慢操作系统的运行，影响所有应用的性能。
本文就来分享一种在应用程序中进行动态内存管理的方法，减少向操作系统申请和释放的次数，来避免内存碎片整理的负担。
二、动态内存管理原理 动态内存管理的目标主要有两个：
减少向操作系统申请和释放的次数，也就是减少调用malloc/free；减少内存碎片，一旦产生碎片就需整理，同时会造成一部分内存的浪费； 2.1 内存分配策略 针对这两个目标，我们可以这样来做，先从内存的分配来看：
每次从操作系统申请一块较大的内存；单次数量多，次数就会少很多；应用需要时，从这块大内存中切割划分，直到大块内存用尽，再重复1步骤；对于少量一次需要很大的内存时，超过每次申请的上限，此时就直接从操作系统申请，这就按特例来处理。 这有点像买蛋糕，当一个人吃时，每次就买一小块；当过生日时，有很多人一起吃，那就一次性买个大蛋糕，回来切分。
我们也可以说算法来源于生活，而高于生活！
2.2 内存回收策略 对于内存的释放回收，有两种策略：
重复利用策略，释放时不归还给操作系统；下次申请时再重复利用；整体归还策略， 释放时不归还操作系统，如果一大块都释放时，则将此整块内存统一归还给操作系统； 重复利用策略
这种策略对于内存利用次数较高，与操作系统交互更少，但需要增加内存碎片的管理，也就是对于应用使用的不同大小的内存片，归还后要么进行移动合并，要么按大小进行排序再利用；
会增加碎片管理的负担，同时内存会有一些浪费。
整体归还策略
申请一大块内存，在应用内部进行切分为更小的片进行使用，当此大块内存上的分片均释放时，将此大块内存归还给操作系统。
这样避免内存碎片的整理，同时大块的释放也会减少操作系统内存碎片整理的负担；
但是也会存在内存浪费，当大块内存上有一小片一直不释放时，整块内存就会被浪费，迟迟得不到释放。
当然两种策略还可以再优化，但过多的优化，都会带来一些额外的开销。
三、动态内存管理实现 动态内存管理的基本单位称为内存页(page)，大小为4KB，也就是上节提到的大块内存，每次申请与释放都会按内存页来操作。
而对于应用程序来讲，它申请内存是从memPage中进行分配，每次分配一个memNode，包含申请的内存大小。
当一个MemPage用完或不够时，再从下一个memPage中分配。
所有的memPage采用单链表的形式串起来，方便释放时管理。
下面我们就分拆来了解一下，内存页的定义，以及内存的申请与释放的操作。
3.1 内存管理结构定义 内存管理需要记录mempage的链表，同时为了更少的与操作系统交互，增加了一个freeList来记录释放的memPage，当freeList不空时，直接从这里分配即可。
内存管理结构的定义
#define MEMORY_POOL_MANAGER_VERSION (0x0B10) typedef struct MemPoolManagerContext { int version; unsigned long totalSize; /* 已经使用的动态内存大小 */ // SPINLOCK lock; /* protected this structure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54c5f30baa1eed4aa09501e51c97887d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99eca00b1ced7f4625346e049337d0af/" rel="bookmark">
			开源PHP论坛HadSky本地部署与配置公网地址实现远程访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. 网站搭建1.1 网页下载和安装1.2 网页测试1.3 cpolar的安装和注册 2. 本地网页发布2.1 Cpolar临时数据隧道2.2 Cpolar稳定隧道（云端设置）2.3 Cpolar稳定隧道（本地设置）2.4 公网访问测试 总结 前言 今天和大家分享一下如何在自家电脑的Ubuntu系统上，建立轻量化的HadSky论坛，并结合cpolar内网穿透工具将本地服务发布公网让其能够为大家所访问.
在大部分情况下，我们都可以在网络上找到需要的信息，并且能够通过特定方式（如论坛、留言、评论等）与众网友们交换意见和见解。不过，在别人的地盘呆久了，总会有自己建立交互空间吸引大家来畅聊的想法。搭建过程非常简单，人人都能学得会。
1. 网站搭建 HadSky是一款开源的PHP轻论坛系统，依托常用的php和MySQL运行。由于其轻量化的特点，因此即便服务器设备性能不高，也能轻松运行。对于笔者这样将退居二线的过时电脑，是很合适的选择。现在，就让我们开始吧（ 注意：面向公共的论坛网站，必须向当地监管部门申请备案！）。
1.1 网页下载和安装 HadSky作为一款有一定知名度的软件，自然有自己的官网（www.hadsky.com），我们可以在这里找到hadsky网站程序的下载，也能看到hadsky网站的安装要求和问题解答。
根据安装要求，我们需要在本地ubuntu系统上安装PHP5.2和MySQL5.0，当然Apache（或Nginx）也是必不可少的。为了方便起见，笔者在ubuntu系统上安装了宝塔面板，方便快速安装和设置网站运行所需的各种程序。
我们也可以在宝塔面板的主页（可以在浏览器中输入本地地址:宝塔面板输出端口号）左侧，找到“软件商店”按钮，点击进入软件商店页面。在这个页面，我们可以找到常用的网站运行支持程序，包括Nginx、Apache、MySQL、PHP、phpMyadmin、Tomcat、Docker管理器、Redis等等。我们找到所需的软件，点击该软件条目右侧的“安装”，即可将其安装至ubuntu系统上。
依照hadsky官方给出的安装要求，我们需要使用PHP5.2+和MySQL5.0+，我们可以在这里选择对应PHP版本安装即可。
完成Apache、MySQL、PHP几项软件的安装后，我们可以点击软件商店页面上方的“已安装”按钮，查看已经安装的软件。同时，也可以在这里切换每个软件的版本。
接着，我们就可以进行下一步的hadsky网站部署。通常网站部署的步骤是将下载的网站源代码，放置到宝塔面板的wwwroot文件夹下，不过好在hadsky在宝塔面板中提供了“一键部署”模式，又为笔者省了不少事。
点击宝塔面板主界面左侧的“软件商店”。进入软件商店后，在页面上方找到“一键部署”按钮，进入可以一键部署的网站分页，从中选取“hadsky”条目，点击该条目右侧的“一键部署”按钮，
接下来会弹出网站基本设置窗口，在这里我们可以指定网站的基本信息，这些信息包括：
输出端口号 - 在“域名”栏位，通过“打算设置的域名：打算使用的端口”形式设置；
根目录 – 这个栏位可改可不改，但这个根目录内容会与“域名”栏位联动，为防止混淆，笔者还是将其更改为hadsky
数据库 – 这里填入我们之前设置的数据库信息即可；
PHP版本 – 对于某些网站可能会要求使用特定版本的PHP，我们就可以在PHP版本栏位修改（前提是已经安装了对应版本的PHP软件）
完成这些设置后，就可以点击窗口下方的“提交”按钮，创建hadsky网站。
网站创建完成后（一瞬间的事），宝塔面板会弹出已创建网站的地址，重要的网站信息（可能是数据库信息，或是网站后台登录信息）。
下一步打开ubuntu的宝塔面板，在软件主界面左侧点击“网站”按钮，进入网站列表页面，就能看到刚刚安装上线的hadsky网站。
此时我们在ubuntu的浏览器地址栏输入设置好的hadsky网站地址，就能看到haddsky的设置页面。我们继续根据网站显示页面的提示，进行具体的网站设置工作。
在hadsky网站安装过程中，会要求填写数据库相关信息（也就是在一键部署网站时设置的数据库信息），如果记不得网站数据库信息，则可以在宝塔面板左侧的“数据库”页面中找到有关内容。
1.2 网页测试 数据库设置完成后，hadsky网站就会显示出网站安装完成的提示，我们可以在这里选择进入hadsky网站后台，或者直接进入已安装的论坛进行查看。
Hadsky论坛后台页面
Hadsky论坛主页面
1.3 cpolar的安装和注册 完成hadsky论坛的部署后，就可以转入cpolar的安装。想要在ubuntu系统上安装cpolar，可以使用简便的一键安装脚本进行安装。只要在ubuntu的命令行界面输入以下命令，就可以自动执行安装程序（需要注意的是，可能有的ubuntu版本没有安装curl工具，因此最好先执行命令“sudo aptinstall curl”安装curl工具）。
Cpolar一键安装脚本：
“curl -L
https://www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash”
Cpolar安装完成后，就可以再输入命令“systemctl start cpolar”，启动cpolar。
这时ubuntu系统会跳出启动服务的认证框，我们输入ubuntu系统的密码即可。
当然，我们也可以不使用systemctl级别命令，而是输入“cpolar version”查询本地cpolar的版本号，只要能显示出版本信息，就说明cpolar安装完成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99eca00b1ced7f4625346e049337d0af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/621e80c81916b73b50ff5d2ffe11487f/" rel="bookmark">
			ChatGPT对话：如何制作静态网页？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【编者按】编者在很早以前制作过静态网页，之后长期没有使用，已完全不知道最新现状了。所以，从制作工具开始询问ChatGPT，回答非常全面，完全可以解决初学者的问题。
编者虽然长期不制作网页，但一直在编程，所以最后选择了VS Code作为开发工具，并在ChatGPT的帮助下很快建立了网站框架。
在与ChatGPT对话过程中，它有些内容还不能准确理解，需要在它提供的示例代码中进行修改，但明显提高了工作效率，特别是对小白入门特别有帮助。
PS：VS Code需要手动输入HTML标签，不适合制作网页，即使安装了插件，输入标签时有智能提示，但仍然十分麻烦。如果网页很复杂，VS Code更不能胜任。
1问：制作静态网页使用什么工具比较好？
ChatGPT
制作静态网页可以使用多种工具，具体选择取决于你的需求和技术水平。以下是一些常用的工具和方法：
文本编辑器：
VS Code：功能强大，支持各种扩展和插件。Sublime Text：轻量级，高效，支持多种编程语言。Atom：由GitHub开发，具有丰富的插件。 静态网站生成器：
Jekyll：由GitHub Pages支持，适合博客和文档网站。Hugo：快速的静态网站生成器，支持多种模板。Gatsby：基于React，适合创建现代、动态的静态网站。 框架和库：
Bootstrap：一个流行的前端框架，提供了丰富的预定义样式和组件。Tailwind CSS：实用的CSS框架，允许你以原子类方式定制样式。 设计工具：
Figma：在线设计工具，适合团队协作。Adobe XD：适用于设计和原型制作。 版本控制系统：
Git：用于版本控制和协作开发，推荐使用GitHub、GitLab或Bitbucket来托管代码。 托管平台：
GitHub Pages：适合托管静态网站，直接与GitHub仓库集成。Netlify：简单易用，支持持续集成和自动部署。Vercel：适合Next.js和其他静态网站，提供快速的部署和预览功能。 通过这些工具，你可以高效地制作和维护静态网页，并实现良好的用户体验和性能。根据你的需求和喜好选择合适的工具，可以帮助你更好地完成项目。
2问：我记得之前有一个比较好的、常用工具Dreamweaver，你没有提到呢？该工具停止开发了吗？
ChatGPT
Adobe Dreamweaver 仍然是一个流行的网页设计和开发工具，它并没有停止开发。Dreamweaver 提供了一个集成的开发环境（IDE），适用于创建和管理网站。它的主要特点包括：
视觉设计和代码编辑：Dreamweaver 提供了所见即所得（WYSIWYG）编辑器和代码编辑器，适合初学者和专业开发者。
多设备预览：可以实时预览网站在不同设备上的效果，方便进行响应式设计。
集成开发工具：支持 HTML、CSS、JavaScript 等多种语言，并且与 Adobe Creative Cloud 其他工具（如 Photoshop、Illustrator）无缝集成。
FTP 集成：内置 FTP、SFTP 和 WebDAV，方便上传和管理网站文件。
虽然 Dreamweaver 是一个强大的工具，但近年来，许多开发者开始倾向于使用更加现代化和开源的工具（如 VS Code、Sublime Text 等）来进行网页开发。原因包括：
轻量级和快速：很多现代编辑器比 Dreamweaver 更轻量，启动和运行速度更快。插件生态系统：VS Code 等编辑器有丰富的插件，可以扩展其功能以适应各种开发需求。版本控制集成：现代编辑器通常集成了 Git 和其他版本控制系统，方便团队协作。 但这并不意味着 Dreamweaver 不再适用。对于那些已经习惯使用 Dreamweaver 并且需要其所见即所得功能的用户，Dreamweaver 仍然是一个很好的选择。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/621e80c81916b73b50ff5d2ffe11487f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b04109208df8491c659a83a5e5b022f/" rel="bookmark">
			小白学webgl合集-三维数据源和格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大多数地图瓦片数据是二维的，三维效果通过渲染和样式设置实现。主要的三维数据源和格式包括：
1. 3D Tiles (CesiumJS)
3D Tiles 是一种开放标准，用于流式传输和可视化大规模三维地理数据。它可以包含各种三维数据，如建筑物、点云、地形等。CesiumJS 是一个常用的开源库，可以加载和渲染 3D Tiles。
2. Mapbox GL JS Mapbox GL JS 支持加载和渲染三维建筑物和地形数据。虽然其底层数据还是二维矢量瓦片，但通过样式设置可以呈现三维效果。Mapbox 也提供三维地形和建筑物数据源。
3. BIM (Building Information Modeling) BIM 数据通常用于建筑和工程领域，包含详细的三维建筑物模型。虽然不是传统意义上的地图瓦片，但这些数据可以被用于三维地图展示。
CesiumJS 示例：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Cesium 3D Tiles Example&lt;/title&gt; &lt;script src="https://cesium.com/downloads/cesiumjs/releases/latest/Build/Cesium/Cesium.js"&gt;&lt;/script&gt; &lt;link href="https://cesium.com/downloads/cesiumjs/releases/latest/Build/Cesium/Widgets/widgets.css" rel="stylesheet"&gt; &lt;style&gt; #cesiumContainer { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="cesiumContainer"&gt;&lt;/div&gt; &lt;script&gt; const viewer = new Cesium.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b04109208df8491c659a83a5e5b022f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec2a670dc1d3990b06ada7860335f9e2/" rel="bookmark">
			在Ubuntu 16.04上安装和保护MongoDB的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站。
简介 MongoDB 是一个免费且开源的面向文档的数据库。它被归类为 NoSQL 数据库，因为它不依赖于传统的基于表的关系型数据库结构。相反，它使用类似 JSON 的动态模式文档。与关系型数据库不同，MongoDB 在向数据库添加数据之前不需要预定义模式。您可以随时和任意次数地更改模式，而无需设置具有更新后模式的新数据库。
在本教程的第一部分中，我们将使用 MongoDB 仓库来安装最新版本的 MongoDB。在第二部分中，我们将启用身份验证以在本地系统上进行安全设置。最后，在第三部分中，我们将展示如何更安全地允许远程连接（如果需要的话）。
先决条件 要按照本教程操作，您需要：
一个配置了非 root sudo 用户和防火墙的 Ubuntu 16.04 服务器，可以按照 Ubuntu 16.04 初始服务器设置指南进行配置。 当这些条件都满足时，您就可以开始操作了。
第一部分：设置服务器 步骤 1 — 添加 MongoDB 仓库 MongoDB 已经包含在 Ubuntu 软件包仓库中，但官方的 MongoDB 仓库提供了最新版本，并且是安装该软件的推荐方式。在这一步中，我们将向服务器添加官方仓库。
Ubuntu 通过验证软件包是否使用 GPG 密钥签名来确保软件包的真实性，因此我们首先需要导入官方 MongoDB 仓库的密钥。
sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 0C49F3730359A14518585931BC711F9BA15703C6 以下输出确认了我们已成功导入密钥：
执行: /tmp/tmp.IdwenTia0s/gpg.1.sh --keyserver hkp://keyserver.ubuntu.com:80 --recv 0C49F3730359A14518585931BC711F9BA15703C6 gpg: requesting key A15703C6 from hkp server keyserver.ubuntu.com gpg: key A15703C6: public key "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec2a670dc1d3990b06ada7860335f9e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e28403739593660eb3c9d93591d4224/" rel="bookmark">
			数据结构【顺序表】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
​
线性表
顺序表
概念与结构
分类
静态顺序表
动态顺序表
动态顺序表的实现
在头文件中创建结构体
初始化顺序表
销毁顺序表（可以留到后面再看）
尾插数据
申请空间
打印顺序表数据
头插数据
尾删除数据
头删除数据
在指定位置插入数据
在指定位置删除数据
查询数据
顺序表算法题
移除元素
删除有序数组中的重复项
合并两个有序数组
代码
线性表 ++++1
线性表（linear list）是n个具有相同特性的数据元素的有限序列。线性表是⼀种在实际中⼴泛使⽤的 数据结构，常⻅的线性表：顺序表、链表、栈、队列、字符串...
线性表在逻辑上是线性结构，也就说是连续的⼀条直线。但是在物理结构上并不⼀定是连续的，线性 表在物理上存储时，通常以数组和链式结构的形式存储。
线性表是具有相同特性的集合，就比如现实生活中的，水果有苹果，香蕉，西瓜等等....，这些都是水果类型的。线性表：顺序表、链表、栈、队列、字符串等等...
顺序表 概念与结构 概念：顺序表是⽤⼀段物理地址连续的存储单元依次存储数据元素的线性结构，⼀般情况下采⽤数组 存储。
逻辑结构：就像一家早餐店早上有很多人排队，排成一条线，这就是逻辑结构，都是线性的
顺序表也是数组，顺序表在物理结构不一定连续，在逻辑结构是连续的，
顺序表和数组的区别？ 顺序表的底层结构是数组，对数组的封装，实现了常⽤的增删改查等接⼝。
下面这张图，苍蝇馆子就像数组，米其林餐厅就像顺序表，一个普普通通的炒西蓝花，在米其林餐厅西蓝花+料汁+小饰品+摆盘就变成了绿野仙踪，
顺序表也是一样在数组的基础上加了（增加数据，删除数据，修改数据，查找数据）就变成了顺序表
分类 静态顺序表 概念：使⽤定⻓数组存储元素
静态数组只需要，定长数组，有效数据个数
静态顺序表缺陷：空间给少了不够⽤，给多了造成空间浪费
静态顺序表不推荐用，如果要存放用户数据的话，当数据存满了，剩下的数据就会丢失。
动态顺序表 动态顺序表需要有效个数，空间的容量，a也可以说就是个数组
动态顺序表的实现 代码在文章最后
我们需要创建一个seqlist.h头文件，seqlist.c文件存放函数，还有一个.c的测试文件。
在头文件中创建结构体 把int 重命名为 data，这样方便修改类型，就不用一个一个修改了
初始化顺序表 我们要在头文件声明一下，这样的话我们可以方便查看有什么函数，就像我们看一本书，书有目录方便我们阅读。
初始化我们需要把arr赋值为NULL，有效个数和空间容量赋值为0就好了。
如果我们现在申请空间，会导致空间满了我们没法调整。
我们只需要添加数据的数据（申请/调整）空间就好了。
我们可以发现初始化成功了
销毁顺序表（可以留到后面再看） 这里我先讲顺序表销毁，也可以先往后看，最后再来看销毁。
我们申请空间用完了需要还，不然存在空间泄露。
if判断结构体里arr的有没有数据,有数据就free释放空间，有效个数和空间容量赋值为0。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e28403739593660eb3c9d93591d4224/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/599857e9223baa3b046d7676564c91a1/" rel="bookmark">
			【人工智能】-- 受限玻尔兹曼机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人主页：欢迎来到 Papicatch的博客
课设专栏 ：学生成绩管理系统
专业知识专栏： 专业知识 文章目录
🍉引言
🍉受限玻尔兹曼机
🍈RBM的结构
🍍RBM的架构图
🍍RBM的经典实现
🍍代码实现
🍍代码分析
🍉总结
🍉引言 在当今科技飞速发展的时代，人工智能的研究不断取得突破性的进展。其中，受限玻尔兹曼机作为一种重要的模型，正逐渐引起人们的广泛关注。它独特的结构和强大的学习能力，为解决各种复杂的问题提供了新的思路和方法。受限玻尔兹曼机不仅在理论研究上具有深刻的意义，在实际应用中也展现出了巨大的潜力，例如图像识别、语音处理、自然语言处理等领域。
🍉受限玻尔兹曼机 受限玻尔兹曼机（Restricted Boltzmann Machine，RBM）是一种生成性随机人工神经网络，也是一种无向概率图模型，并且受限为二分图。
整个模型有两层，即可见层（包含可见单元）和隐藏层（包含隐单元），满足层内无连接，层间全连接。这种限制使得它在神经元之间的连接上有特定的规则，来自两组单元中的每一组的一对节点（通常称为“可见”和“隐藏”单元）可以在它们之间具有对称连接，而组内的节点之间没有连接。相比一般的玻尔兹曼机，这种限制允许使用更有效的训练算法。
RBM 通常由二值隐单元和可见单元组成，其中权重矩阵 中的每个元素指定了隐单元 和可见层单元 之间边的权重。
此外，对于每个可见层单元 有偏置项 ，对每个隐层单元 有偏置项 。具体来说，需满足以下条件
其能量函数对于一组给定的状态 定义为：
由能量函数可以给出状态 的联合概率分布：
其中， 是归一化常数，计算式为 ，其计算复杂度为 。可见层的边缘分布: ;隐藏层的边缘分布: 。
RBM 的一个重要性质是，由于它是一个二分图，层内没有边相连，因而隐藏层的激活状态在给定可见层节点取值的情况下是条件独立的，类似地，可见层节点的激活状态在给定隐藏层节点取值的情况下也条件独立，用数学公式表示为：
由此可以推导得出在给定可视层 的基础上，隐层第 个节点为 1 或者为 0 的概率为：
在给定隐层 的基础上，可视层第 个节点为 1 或者为 0 的概率为：
在训练 RBM 时，关键是计算模型中的参数 。通常采用对数损失函数，并考虑最大化对数似然函数。但直接按梯度公式计算梯度的复杂度很高，因为其中涉及到归一化常数 的计算，而 的计算复杂度为 。
为解决这个问题，一般使用基于马尔可夫链蒙特卡罗（MCMC）的方法来模拟计算梯度，如 Geoffrey Hinton 提出的对比散度（contrastive divergence，CD）算法。该算法给定样本 后，取初始值 ，然后执行 步 Gibbs 采样，先后采样得到 和 。Gibbs 采样得到的样本服从联合分布 ，利用采样得到的 可以估算梯度公式中期望项的近似值，从而得到梯度的近似值，之后在每一步利用梯度上升法进行参数更新。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/599857e9223baa3b046d7676564c91a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebce29f665ec098035981b135f1fc591/" rel="bookmark">
			数据结构：链表详解 (c&#43;&#43;实现)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 对于数据结构的线性表，其元素在逻辑结构上都是序列关系，即数据元素之间有前驱和后继关系。
但在物理结构上有两种存储方式：
顺序存储结构：
使用此结构的线性表也叫 顺序表物理存储上是连续的，因此可以随机访问，时间复杂度为 O(1)
链式存储结构：
使用此结构的线性表也叫 链表物理存储上不连续，因此不支持随机访问
接下来要介绍的就是 链表。
链表分为 单向链表（单链表）与 双向链表（双链表），理解了单链表，双链表自然也明白了。
1. 什么是单链表 1.1 定义 链表由一系列的节点组成（链表中的每个元素都可称为节点），对于单链表而言，它的节点包含两部分：
数据域：存储当前节点的数据指针域：存储当前节点的下一个节点（后继节点）的地址 那么现在定义单链表 SingleList 的节点 Node：
1.2 创建 Node struct Node { int val;	// 数据域 Node* next;	// 指针域：指向的是 Node，所以类型为 Node* }; 这么定义的 Node 类只能接收数据类型为 int 的数据，对于其他类型的数据当前的类不能处理，因此为了代码的通用性，将 Node 定义为模版类：
template &lt;typename T&gt; struct Node { T val;	// 数据域 Node* next;	// 指针域 Node(T v, Node* n = nullptr) :val{ v }, next{ n } { } }; 为了方便初始化，Node 还增加了构造函数：一个节点肯定必须有数据域，但指针域可以为空（表示没有后继节点了）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebce29f665ec098035981b135f1fc591/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae90962065d49f9a0d0b2d57be26bdb6/" rel="bookmark">
			【人工智能】-- 迁移学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人主页：欢迎来到 Papicatch的博客
课设专栏 ：学生成绩管理系统
专业知识专栏： 专业知识 文章目录
🍉引言
🍉迁移学习
🍈基本概念
🍍定义
🍌归纳迁移学习（Inductive Transfer Learning）：
🍌直推式迁移学习（Transductive Transfer Learning）：
🍌跨领域迁移学习（Cross-Domain Transfer Learning）：
🍌实例迁移学习（Instance Transfer Learning）：
🍌特征迁移学习（Feature Transfer Learning）：
🍌参数迁移学习（Parameter Transfer Learning）：
🍍优势
🍌数据高效性
🍌节省时间和计算资源
🍌提高模型性能
🍌跨领域应用：
🍌加速创新和研究
🍍缺点
🍌负迁移问题
🍌领域适配难度
🍌模型复杂度增加
🍌隐私和法律问题
🍌依赖已有模型
🍈核心方法
🍍基于实例的迁移学习
🍍基于特征的迁移学习
🍍基于模型的迁移学习
🍍基于关系的迁移学习
🍈应用领域
🍍计算机视觉
🍍自然语言处理
🍍医疗领域
🍍金融领域
🍍工业领域
🍍教育领域
🍉VGG16实现图像风格转移
🍈步骤
🍍环境及数据集准备
🍍原理理解
🍈代码实现
🍉总结
🍉引言 在当今数字化和智能化的时代，数据的价值日益凸显，而如何高效地利用数据成为了摆在研究者和从业者面前的重要课题。迁移学习作为一种创新的机器学习方法，应运而生，为解决数据利用和知识迁移的难题提供了全新的思路和有力的工具。
迁移学习旨在将从一个或多个相关领域中学习到的知识和模式，应用到新的、但具有一定相似性的领域或任务中。它打破了传统机器学习中每个任务都需要大量特定标注数据的限制，使得我们能够在数据稀缺的情况下，借助已有的知识和经验，快速有效地开展新的学习和分析。
例如，在图像识别领域，我们可以利用在大规模自然图像数据集上训练好的模型，将其迁移到医学图像诊断任务中，从而节省大量的训练时间和数据标注成本。同样，在语言处理中，从大规模通用文本数据中学习到的语言模型，可以被迁移到特定领域的文本分类或情感分析任务中。
🍉迁移学习 迁移学习（Transfer Learning） 是一种机器学习方法，其核心在于将从一个或多个源领域（Source Domain）和源任务（Source Task）中学习到的知识、模式或模型参数，有效地应用到目标领域（Target Domain）和目标任务（Target Task）中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae90962065d49f9a0d0b2d57be26bdb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59d6afe2aa3fa1c38e9ace964dbed56f/" rel="bookmark">
			【Redis】哨兵(sentinel)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、哨兵是什么？二、 哨兵sentinel文件参数三、 模仿主机redis宕机四、哨兵运行流程和选举原理SDOWN主观下线ODOWN客观下线 五、 使用建议 以下是本篇文章正文内容
一、哨兵是什么？ 哨兵巡查监控后台master主机是否故障，如果故障了根据投票数自动将某一个从库转换为新主库，继续对外服务，俗称无人值守运维
作用：监控redis运行状态，包括master和slave，当master down机时，能自动将slave切换成新master
哨兵的四个功能
主从监控 监控主从redis库运行是否正常 消息通知 哨兵可以将故障转移的结果发送到客户端 故障转移 如果master异常，则会进行主从切换，将其中一个slave作为新master 配置中心 客户端通过连接哨兵来获得当前Redis服务的主节点地址 Redis Sentinel架构
客户端通过哨兵集群访问redis 主从复制架构，哨兵集群对主从复制进行监视
本案例架构如下
3个哨兵 自动监控和维护集群，不存放数据，只是监控 1主2从 用于数据读取和存放主机后续可能会变成从机，需要设置访问新主机的密码，需要在主机conf文件设置masterauth项访问密码为111111, 二、 哨兵sentinel文件参数 bind 服务监听地址，用于客户端连接daemonize 是否以后台daemon方式运行protected-mode 安全保护模式port 端口logfile 日志文件路径pidfile pid日志路径dir 工作目录sentiel monitor &lt; master &gt; &lt; ip &gt; &lt; redis-port &gt; &lt; quorm &gt; 设置要监控的masterquorm 表示最少有几个哨兵认可客观下线，同意故障迁移的法定票数 网络是不可靠的，有时候一个sentinel会因为网络堵塞而误以为一个master redis已经死掉了，在sentinel集群环境下需要多个sentinel互相沟通来确认某个master是否真的死了，
quorum这个参数是进行客观下线的一个依据，意思是至少有quorum个sentinel认为这个master有故障，才会对这个master进行下线以及故障转移。
因为有的时候，某个sentinel节点可能因为自身网络原因，导致无法连接master，而此时master并没有出现故障，所以，这就需要多个sentinel都一致认为该master有问题，才可以进行下一步操作，这就保证了公平性和高可用。
sentiel auth-pass 通过密码连接master 可以直接把以上参数新建一个文件sentiel.conf写进redis工作的目录（即redis.conf所在的目录）
本案例有三个哨兵，需要新建三个sentiel.conf文件
启动主从redis后，启动哨兵
redis-sentinel sentinel26379.conf --sentinel redis-sentinel sentinel26380.conf --sentinel redis-sentinel sentinel26381.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59d6afe2aa3fa1c38e9ace964dbed56f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84b4dab80b739da686b1b4f475774e4c/" rel="bookmark">
			昇思MindSpore学习总结十五 ——基于Mindspore 实现BERT对话情绪识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、环境配置 根据实际情况，选择合适版本。
%%capture captured_output # 实验环境已经预装了mindspore==2.2.14，如需更换mindspore版本，可更改下面mindspore的版本号 !pip uninstall mindspore -y !pip install -i https://pypi.mirrors.ustc.edu.cn/simple mindspore==2.2.14 # 该案例在 mindnlp 0.3.1 版本完成适配，如果发现案例跑不通，可以指定mindnlp版本，执行`!pip install mindnlp==0.3.1` !pip install mindnlp 2、模型简介 BERT全称是来自变换器的双向编码器表征量（Bidirectional Encoder Representations from Transformers），它是Google于2018年末开发并发布的一种新型语言模型。与BERT模型相似的预训练语言模型例如问答、命名实体识别、自然语言推理、文本分类等在许多自然语言处理任务中发挥着重要作用。模型是基于Transformer中的Encoder并加上双向的结构，因此一定要熟练掌握Transformer的Encoder的结构。
BERT模型的主要创新点都在pre-train方法上，即用了Masked Language Model和Next Sentence Prediction两种方法分别捕捉词语和句子级别的representation。
在用Masked Language Model方法训练BERT的时候，随机把语料库中15%的单词做Mask操作。对于这15%的单词做Mask操作分为三种情况：80%的单词直接用[Mask]替换、10%的单词直接替换成另一个新的单词、10%的单词保持不变。
因为涉及到Question Answering (QA) 和 Natural Language Inference (NLI)之类的任务，增加了Next Sentence Prediction预训练任务，目的是让模型理解两个句子之间的联系。与Masked Language Model任务相比，Next Sentence Prediction更简单些，训练的输入是句子A和B，B有一半的几率是A的下一句，输入这两个句子，BERT模型预测B是不是A的下一句。
BERT预训练之后，会保存它的Embedding table和12层Transformer权重（BERT-BASE）或24层Transformer权重（BERT-LARGE）。使用预训练好的BERT模型可以对下游任务进行Fine-tuning，比如：文本分类、相似度判断、阅读理解等。
对话情绪识别（Emotion Detection，简称EmoTect），专注于识别智能对话场景中用户的情绪，针对智能对话场景中的用户文本，自动判断该文本的情绪类别并给出相应的置信度，情绪类型分为积极、消极、中性。 对话情绪识别适用于聊天、客服等多个场景，能够帮助企业更好地把握对话质量、改善产品的用户交互体验，也能分析客服服务质量、降低人工质检成本。
下面以一个文本情感分类任务为例子来说明BERT模型的整个应用过程。
import os # 导入操作系统相关的模块 import mindspore # 导入MindSpore框架 from mindspore.dataset import text, GeneratorDataset, transforms # 从MindSpore的数据集模块导入文本处理、生成器数据集和转换功能 from mindspore import nn, context # 从MindSpore导入神经网络模块和上下文管理模块 from mindnlp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84b4dab80b739da686b1b4f475774e4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d82e24942b064d698e5b663861766337/" rel="bookmark">
			M0G3507完美移植江科大软件IIC MPU6050
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经过两天两夜的查阅文献资料、整理学习，成功的把江科大的软件IIC读写MPU6050移植到MSPM0G3507，亲测有效！！包的，为了让大家直观地感受下，先上图。记得点个赞哦！
学过江科大的STM32的小伙伴是不是觉得这个画面非常熟悉，在这里我选的是满量程为16g，且陀螺仪水平放置，根据Z轴的读数可以计算出当地的重力加速度值，计算公式为读数（X/2^15）*16，即1963/32768*16=0.96。
思路讲解 1.软硬件型号
选择CCS theia进行M0G3507的开发，显示屏为0.96寸4引脚OLED显示屏，陀螺仪选择常见的MPU6050,GY-521模块。
2.软件IIC时序模拟
//IIC写SDA引脚 void MyI2C_W_SDA(uint8_t BitValue) { SDA_ON(); if(BitValue) DL_GPIO_setPins(GPIO_sda_PORT, GPIO_sda_PIN_0_PIN); else DL_GPIO_clearPins(GPIO_sda_PORT, GPIO_sda_PIN_0_PIN); Delay_us(8);	//延时8us，防止时序频率超过要求 } //IIC写SCL引脚 void MyI2C_W_SCL(uint8_t BitValue) { if(BitValue) DL_GPIO_setPins(GPIO_scl_PORT, GPIO_scl_PIN_1_PIN); else DL_GPIO_clearPins(GPIO_scl_PORT, GPIO_scl_PIN_1_PIN); Delay_us(8);	//延时8us，防止时序频率超过要求 } //IIC开始 void MyI2C_Start(void) { SDA_OUT(); MyI2C_W_SDA(1);	//释放SDA，确保SDA为高电平 MyI2C_W_SCL(1);	//释放SCL，确保SCL为高电平 MyI2C_W_SDA(0);	//在SCL高电平期间，拉低SDA，产生起始信号 MyI2C_W_SCL(0);	//起始后拉低SCL，为了占用总线，方便总线时序的拼接 } 3.IIC发送一个字节数据
void MyI2C_SendByte(uint8_t Byte) { SDA_ON(); uint8_t i; for (i = 0; i &lt; 8; i ++)	//循环8次，主机依次发送数据的每一位 { MyI2C_W_SDA(Byte &amp; (0x80 &gt;&gt; i));	//使用掩码的方式取出Byte的指定一位数据并写入到SDA线 MyI2C_W_SCL(1);	//释放SCL，从机在SCL高电平期间读取SDA MyI2C_W_SCL(0);	//拉低SCL，主机开始发送下一位数据 } } 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d82e24942b064d698e5b663861766337/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46afaebb1bc0bc42ef9f43e22a0437f6/" rel="bookmark">
			AI绘画系统课程：从基础入门到商业应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 引言 AI绘画技术的发展为艺术创作提供了新的可能性。本课程旨在教授学习者如何使用AI工具将创意转化为可视化的艺术作品，并探索其在不同领域的应用潜力。
2. 课程概述 本课程为学习者提供了一个全面的学习路径，从AI绘画的基础概念到高级技术的应用，确保学习者能够系统地掌握所需技能。
3. AI绘画技术基础 介绍AI绘画的基本原理，包括软件的下载、安装和基础操作，为学习者打下坚实的基础。
4. 应用逻辑与界面操作 深入讲解AI绘画软件的逻辑结构、界面布局以及提示词的使用技巧，帮助学习者更高效地进行创作。
5. 模型与采样器的高级应用 探讨如何运用采样器和模型来提升AI绘画的质量和效果，包括图生图原理和局部重绘技巧。
6. 后期处理与细节优化 教授学习者如何进行后期处理，包括细节把控和高清放大技术，以提升作品的专业度。
7. 实战案例分析 通过一系列实战案例，展示如何精确控制文生图的创作过程，并进行精修。
8. 插件与工具的实战应用 介绍如何使用Controint等插件进行精准控制，以及Openpose在AI绘画中的应用。
9. 线稿、深度与语义分割的实战技巧 深入讲解Controinet在AI绘画中的应用，包括线稿、深度、涂鸦和语义分割的逻辑及其实战技巧。
10. 模型逻辑与自适应技术 探讨随机洗牌、分块、IP2P参考以及自适应模型的逻辑，并展示其在实战中的应用。
11. LORA原理及其在风格创作中的应用 介绍LORA原理，并展示如何将其应用于风格、人物、景观等不同领域的创作。
12. 复原技术实战案例 通过古画复原、画像复原和老照片复原等案例，展示AI绘画技术在艺术复原领域的应用。
13. 高端摄影与AI绘画的结合 探讨如何将AI绘画技术应用于高端摄影，包括人像照背景更换、模特换装和插件换脸等。
14. 扩图技术与电商图制作 介绍三种扩图方式，并展示如何制作适用于电商的化妆品和运动脚套图。
15. 结语 总结AI绘画课程的核心内容，鼓励学习者继续探索AI绘画的无限可能，并在实践中不断提升自己的技能。
点击获取完整视频教程 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/160/">«</a>
	<span class="pagination__item pagination__item--current">161/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/162/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>