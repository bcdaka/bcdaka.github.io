<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/454f29dc9de557f734e14eaac1c90a33/" rel="bookmark">
			忘记 iPhone 密码：如果忘记密码，如何解锁 iPhone
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了提高个人数据的安全性，用户通常会为不同的帐户和设备创建不同的复杂密码。虽然较新的 iPhone 型号具有生物识别和面部解锁功能，但这些功能并不总是有效 - 如果您忘记了 iPhone 的密码，您可能会遇到麻烦。
iPhone 用户和 Android 用户一样，可能会忘记密码，从而难以访问手机。Android 用户可以解锁 Android 手机密码，而不会丢失数据。iPhone 用户也一样。
尝试几次失败后，屏幕上会显示“ iPhone 已停用”的消息。这可能是一个令人恐惧的时刻，尤其是如果您最近没有备份照片或其他数据文件。
如果您遇到这种情况，请不要担心：有几种方法可以重新获得对 iPhone 的访问权限，无论是否恢复它并丢失所有数据。
防止丢失 iPhone 密码的提示： 选择一个对你来说有逻辑的、令人难忘的绘制模式使用仅对您有意义的字母和数字如果您使用的密码仅包含数字，请确保这些数字与您相关，但不与生日相关，因为使用这些日期作为密码并不安全将密码写在安全的地方，并将其与 iPhone 分开保存创建密码后立即测试密码，以确保设置时没有输入错误的数字或字母 为什么您会在锁定屏幕上看到“iPhone 已停用”消息？ “iPhone 已停用”消息通常出现在有人多次输入错误密码时。在 iPhone 8 及更高型号上，锁定的设备将在锁定屏幕上显示一条消息，提示“iPhone 已停用”。
对于 Apple 设备，加密使得任何不知道密码或无法访问设备数据加密备份文件的人都无法进入 iPhone。因此，一旦多次输入错误密码，唯一的方法就是彻底清除设备/将设备恢复到原始状态。
当您忘记 iPhone 密码时如何访问您的手机？ 如果您忘记了 iPhone 密码并且已停用，您有几种选择。您可以使用恢复模式、iTunes 或 iCloud 来恢复您的设备。
但是，这些选项会抹掉你手机上的数据，然后从备份中恢复。如果你没有最近的备份，你可以使用恢复软件移除锁屏并重新获得对 iPhone 的访问权限。
如果您的iPhone 搭载 iOS 15.2 或更高版本，则可以从“安全锁定”或“iPhone 不可用”屏幕重置 iPhone 密码，而无需将其连接到计算机。另一种选择是使用第三方 iPhone 密码删除工具，它允许您删除忘记的 iPhone 密码，而无需使用 iTunes 执行恢复。
1. 使用 iCloud 解锁 iPhone，无需密码 即使您忘记了 iPhone 的密码，您仍然可以使用 iCloud 帐户访问它。要使此解决方案有效，您必须：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/454f29dc9de557f734e14eaac1c90a33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5921d9304051ba37617cc91db68cb638/" rel="bookmark">
			完美解决org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.reflection.Refl
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完美解决org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.reflection.ReflectionException的正确解决方法，亲测有效！！！
亲测有效 报错问题解决思路解决方法1. 检查MyBatis配置文件2. 检查Mapper映射文件3. 检查实体类和数据库表结构4. 检查数据库连接配置5. 检查MyBatis版本兼容性 示例代码解决思路与总结 报错问题 在使用MyBatis进行数据库操作时，可能会遇到以下错误信息：
org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.reflection.ReflectionException 这个错误通常表明在MyBatis执行反射操作时遇到了问题，可能是由于配置错误、映射文件错误或者实体类和数据库表结构不匹配导致的。
解决思路 检查MyBatis配置文件： 确认mybatis-config.xml文件中的配置正确无误。检查Mapper映射文件： 确保Mapper XML文件中的SQL语句和映射关系正确。检查实体类和数据库表结构： 确认实体类的字段和数据库表的列名一致。检查数据库连接配置： 确认数据库连接配置正确，确保能够成功连接到数据库。检查MyBatis版本兼容性： 确认使用的MyBatis版本与项目的其他依赖版本兼容。 下滑查看解决方法
解决方法 1. 检查MyBatis配置文件 确保mybatis-config.xml文件中配置正确，包括环境配置、映射文件路径配置等。
&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.cj.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mydb"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="password"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5921d9304051ba37617cc91db68cb638/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c70ccf696fdd9882d28db3a5befaf151/" rel="bookmark">
			职业探索-性能测试01-性能工程师成长路径-性能测试的核心概念-性能测试的全周期概览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		职业探索-性能测试01-性能工程师成长路径-性能测试的核心概念-性能测试的全周期概览
参考来源
极客时间专栏：高楼的性能测试实战30讲
课程链接：https://time.geekbang.org/column/intro/100042501
性能测试分析的能力阶梯视图
性能工程师 真正的性能工程师，可以把结果整理清楚之后，又可以下结论，提出解决方案：线上根据这个测试结果，做对应的配置，系统肯定可以稳定运行。又或者是这样的：当前测试说明了线上不能支持，后面应该如何优化
性能测试的内容不仅仅包括测试，还包括分析和调优。
性能工程师的三大学习阶段 性能工具学习期： 理解工具的作用–做脚本和发压力
脚本的逻辑和压力场景的逻辑，和工具本身无关，和业务场景有关。
性能场景学习期： 如何做一个合理的性能测试
性能分析学习期 怎么判断性能瓶颈在哪里呢？
问题的解决，靠的是思维逻辑，靠的是判断，而不是靠工具。
我想看什么数据，而不是说“把数据给我看看”
性能测试分析的能力阶梯视图 1.工具操作：包括压力工具、监控工具、部析工具、调试工具。
2.数值理解：包括上面工具中所有输出的数据，
3.趋势分析、相关性分析、证据链分析：就是理解了工具产生的数值之后，还要把它们的
逻辑关系想明日。这才是性能测试分析中最重要的一环。
4.最后才是调优：有了第3步之后，调优的方案策略就有很多种了，具体选择取决于调优成本和产生的效果。
性能团队 性能团队职责定位 1.性能验证：针对给定的指标，只做性能验证。第三方测试机构基本上都是这样做的
2.性能测试：针对给定的系统，做全面的性能测试，可以得到系统最大容量，但不涉及到
调优。
3.性能测试+分析调优：针对给定的系统，做全面的性能测试，同时将系统调优到最优状态。
性能团队成长阶段 性能团队初建
这时的团队，可以执行场景，可以拿出数据，但工作出的结果并不理想。团队整体的价值就体现在每天跟着版本跑来跑去，一轮轮地测试下去，一个版本短则一两个星期，长则一个月。没有时间去 考虑测试结果对整个软生命期的价值，在各种琐碎的项自中疲于奔命，做脚本，拿出TPS和响应时间，做版本基线比对，出数据罗列式的性能测试报告。
性能团队初成熟
到了这个阶段，团队已经可以应付版本的更迭带来的性能工作压力，团队合作良好，稍有余力，开始考虑团队价值所在，在公司的组织结构中应该承担什么样的职责。在产品的流水线上终于可以占有一席之地了。这样很好，只是从实际的技未细节上来说，仍然没有摆脱第一阶段中琐碎的工作，没有把性能的价值体现出来，只是一个报告提供机器。
性能团队已成熟
有了标准、流程，团队的合作能力也成熟了之后，团队“是时候展示真正的实力了”。但问题来了，什么才是性能团队的真止实力呢？
团队实力的体现：
1.通过你的测试和分析优化之后，性能提升了多少？
这是一句非常简单直接的话。但是我相信有很多做性能测试工程师的人回答不出这样的问题。因为看着混乱的TPS曲线，自己都已经晕了，谁还知道性能提升了多少呢？
而一个成熟的团队应该回答的是：提升了10倍，我们调优了什么。这样的回答有理有据底气十足。
2.通过你的测试和分析优化之后，节省了多少成本？
这人问题就没有那么好回答了，因为你要知道整体的容量规划，线上的真实运营性能。如果之前的版本用了200台机器，而通过我们的测试分析优化之后，只用到了100台机器，那成本就很明显了。
但是，在我的职业生涯中，很少看到有人这样来体现性能存在的价值。有些场合是不需要这样体现，有些场合是不知道这样体现
性能测试的概念 性能测试针对系统的性能指标，建立性能测试模型，制定性能测试方案，制定监控策略，在场景条件之下热行性能场景，分析判断性能瓶颈并调优，最终得出性能结果来评适系统的性能指标是否满足既定值。
性能指标、模型、场景、监控、实施、报告(记住核心的几个概念，更少更容易记住)
概念中的详细解释
有指标 时间指标、容量指标和资源利用率指标
有模型 模型是什么?它是真实场景的抽象，可以告诉性能测试人员，业务模型是什么样子。
性能测试也要选择适合自已系统业务逻辑的方式，用最低的成本、最快的时间来做事情。
有方案 方案规定的内容中有六个关键点，分别是测试环境、测试数据、测试模型、性能指标、压力策略、准入准出和进度风险。基本上有这些内容就够了，这些内容具体的信息还需要精准。
有监控 这部分的监控，要有分层、分段的能力，要有全局监控、定向监控 的能力。
有预定的条件
这里的条件包括软硬件环境、测试数据、测试执行策略、压力补偿等内容。要是展开来说在场景执行之前，这些条件应该是确定的
有场景 场景应该如何定义，来源英文的scenario,
场景来源于英文的scenario，对性能场景中的“场景”比较正宗的描述是：在既定的环境（包括动态扩展等策略）、既定的数据（包括场景热行中的数据变化）、既定的执行策略、既定的监控之下，执行性能脚本，同时观察系统各层级的性能状态参数变化，并实时判断分析场景是否符合预期。
有分析调优 瓶颈判断、性能优化、涉及相关性分析、趋势分析、证据链查找等等手段。
是否需要调优对性能项目划分：
1.新系统性能测试类：这样的项目一般都会要求测试出系统的最大容量，不然上线心里没
底。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c70ccf696fdd9882d28db3a5befaf151/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70c36e06530fc02e7839b7c61d1c30f7/" rel="bookmark">
			“上帝的归上帝，凯撒的归凯撒”：劳动学说界定AIGC著作权及其方法论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
劳动学说界定AIGC著作权及其方法论 1
一、引言 1
二、AIGC可版权的理论核心：一种承认劳动的表示 2
（一）马克思主义劳动学说与洛克劳动混合理论 2
（二）MTL的洞见与创见 3
（三）人工智能的劳动创造与AIGC的可版权进程 3
三、方法论 4
（一）界定方法 4
（二）基于MTL的修订 6
四、案例评述 9
五、成本效益评估模型设定 13
基于劳动价值论的判定方法 16
5.2 DOSSO大道路径 17
5.3 OLS动态回归模型与结论模型 18
5.4 综合模型 19
结语 19
参考文献 20
一、引言
关于人工智能生成内容（Artificial Intelligence Generated Content，AIGC）的著作权益归属问题的讨论由来已久。目前学者们给出的解决路径主要有拟制作者论、人工智能权利主体论、不可版权论、公有论等，本文借助马克思主义劳动学说回答了人工智能生成内容的可版权性问题，提出“以人类的劳动为中心”的法律进路，给出了AIGC可版权和人类作者论的解释，并探索了人工智能拟制作者的正当性认定的方法论，试图解决人工智能生成物著作权归属的混乱。
二、AIGC可版权的理论核心：一种承认劳动的表示
（一）马克思主义劳动学说与洛克劳动混合理论
马克思和洛克都强调劳动作为个人在社会生存和发展的根本意义（Kwok，2020）[[[] Kwok, C. (2020). The Normativity of Work: Lockean and Marxist Overlapping Consensus on Just Work. Journal of Human Values, 26(3), 228–237. ]]，马克思主义劳动学说（Marxist Theory of Labour，MTL）建立在对采集狩猎、农业、手工业、手工业和大机器工业的哲学性的普遍总结之上，这对理解后工业时代的劳动生产也有着借鉴意义（Sayers，2007）[[[] Sayers, S.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70c36e06530fc02e7839b7c61d1c30f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47b088de00723d596ec05c594a7c91f6/" rel="bookmark">
			Python酷库之旅-比翼双飞情侣库(15)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、xlrd库的由来
二、xlrd库优缺点
1、优点
1-1、支持多种Excel文件格式
1-2、高效性
1-3、开源性
1-4、简单易用
1-5、良好的兼容性
2、缺点
2-1、对.xlsx格式支持有限
2-2、功能相对单一
2-3、更新和维护频率低
2-4、依赖外部资源
三、xlrd库的版本说明
1、xlrd 1.2.0版本
2、xlrd 2.0.1版本
3、xlrd3(非官方名称)
四、如何学好xlrd库？
1、获取xlrd库的属性和方法
2、获取xlrd库的帮助信息
3、实战案例
3-144、判断工作表内是否有公式
3-145、判断某单元格区域是否为数组公式区域
3-146、判断工作表内是否有数组公式
3-147、判断单元格的计算公式是否引用了其他工作表数据
3-148、判断单元格的计算公式是否引用了其他工作簿数据
3-149、判断某单元格是否为合并单元格区域的一部分
3-150、获取单元格区域内的值
3-151、获取单元格内的前缀字符
3-152、判断单元格内的数字是否为文本字符
3-153、获取单元格的格式
3-154、获取单元格的字体(Font)对象
3-155、获取单元格的内部(Interior)对象
3-156、获取单元格的边框(Borders)对象
3-157、获取单元格边框线的状态
3-158、获取单元格的样式(Style)对象
3-159、获取单元格的条件格式
3-160、获取单元格的输入规则(有效性设置)
3-161、获取单元格的超链接
3-162、获取单元格的批注信息
3-163、获取单元格的大小(行高和列宽)
3-164、获取单元格的坐标
五、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、Python魔法之旅
5、博客个人主页
在Excel中，通常所说的“情侣键”并非官方术语，而是对某些常用且经常成对出现的快捷键的一种形象化的称呼。其中，最为人熟知和广泛使用的“情侣键”是“Ctrl+C”和“Ctrl+V”。
1、Ctrl+C：这个快捷键的作用是“拷贝”或“复制”。当你在Excel中选中某个单元格、一行、一列或整个工作表的内容后，按下Ctrl+C键，这些内容就会被复制到计算机的剪贴板中，等待下一步的粘贴操作。
2、Ctrl+V：这个快捷键的作用是“粘贴”。在你按下Ctrl+C键将内容复制到剪贴板后，可以通过按下Ctrl+V键将这些内容粘贴到Excel中的另一个位置，这两个操作经常是连续进行的，因此Ctrl+C和Ctrl+V就像一对“情侣”，总是成对出现。
除了这对常见的“情侣键”外，Excel中还有许多其他的快捷键可以帮助用户更高效地完成各种操作。然而，这些快捷键通常并没有像Ctrl+C和Ctrl+V那样形成特定的“情侣”关系。
然而，今天我不再展开介绍“情侣键”，而是要重点推介Python中的“情侣库”，即xlrd和xlwt两个第三方库。
一、xlrd库的由来 xlrd库是一种用于在Python中读取Excel文件的库，它的名称中的"xl"代表Excel，"rd"代表读取，其开发者是John Machin(注：库名字符拆分诠释，只是一种猜测)。
xlrd最初是在2005年开始开发的，是基于Python的开源项目(下载：xlrd库官网下载)。
由于Excel文件在数据处理和分析中的重要性，xlrd库填补了Python在处理Excel文件方面的空白，使得用户可以方便地在Python环境中读取Excel文件的内容，并进行进一步的数据操作和分析。
二、xlrd库优缺点 1、优点 1-1、支持多种Excel文件格式 xlrd库支持多种Excel文件格式，包括`.xls`和`.xlsx`(在旧版本中)，这使得无论数据存储在哪种格式的Excel文件中，用户都可以使用xlrd库来读取。
1-2、高效性 xlrd库使用C语言编写，因此其性能非常高，即使面对非常大的Excel文件，xlrd也可以快速地读取其中的数据。
1-3、开源性 xlrd是完全开源的，可以在GitHub等平台上找到其源代码，这使得任何人都可以根据自己的需求对其进行修改和扩展。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47b088de00723d596ec05c594a7c91f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/915807d928b111b3c3661f76d6810058/" rel="bookmark">
			前端冲刺必备指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 每天努力一点点💪，就能升职加薪💰当上总经理出任 CEO 迎娶白富美走上人生巅峰🗻，想想还有点小激动呢😎。
希望能够把每一处知识点，说明白，（当然，如果哪一处不了解，可以在评论区进行探讨哦！）⏰，计时开始！
如果您发现本文有帮助，请您点赞，收藏，评论，留下您学习的脚印👣，我很乐意谈论😃
话不多说，开始学习！！！
我会不断修改这篇文章内容，一起来探讨吧！😁
学习 css 布局🤣 display 属性，它是 css 中最重要的用于控制布局的属性，每个元素都有一个默认的 display 值，这与元素的类型有关，大多数元素的默认值一般是 block 或 inline。
每个元素都有一个默认的 display
block 元素叫做块级元素；inline 元素叫做行内元素
常用的 display 值，有时候为 none，它是用来再不删除元素的情况下隐藏或显示，display:none。
display 设置成 none 元素不会占据它本来应该显示的空间；使用 visibility:hidden 会占据空间，只是隐藏了，元素还在。
position 属性：static 是默认值，口诀，子绝父相。fixed，一个固定定位元素会相对于视窗来定位，即使页面滚动，它也会停留再相同的位置上。
css 属性中的 float，float 可实现文字环绕图片效果：
img { float: right; margin: 0 0 1em 1em;} 复制代码
clear 属性可以用于被控制的浮动元素，如果一个盒子添加了 float: left 浮动，可以使用 clear: left 清楚元素的向左浮动。
清楚浮动，clearfix hack，可以使用新的 css 样式：
.clearfix { overflow: auto;} 复制代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/915807d928b111b3c3661f76d6810058/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0ed5bd9b3aa3313281c842b0d7285ad/" rel="bookmark">
			python GUI开发: tkinter菜单创建，记事本和画图软件综合项目的实战演练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨✨ 欢迎大家来到景天科技苑✨✨
🎈🎈 养成好习惯，先赞后看哦~🎈🎈
🏆 作者简介：景天科技苑
🏆《头衔》：大厂架构师，华为云开发者社区专家博主，阿里云开发者社区专家博主，CSDN全栈领域优质创作者，掘金优秀博主，51CTO博客专家等。
🏆《博客》：Python全栈，前后端开发，小程序开发，人工智能，js逆向，App逆向，网络系统安全，数据分析，Django，fastapi，flask等框架，linux，shell脚本等实操经验，网站搭建，数据库等分享。
所属的专栏：python图形化GUI编程tkinter精讲
景天的主页：景天科技苑
文章目录 菜单1.主菜单1.1【示例】记事本软件的主菜单 2.上下文菜单2.1【示例】为记事本程序增加上下文菜单 3.【项目】记事本软件开发4.【项目】画图软件开发 菜单 GUI 程序通常都有菜单，方便用户的交互。我们一般将菜单分为两种：
主菜单
主菜单通常位于 GUI 程序上方。例如：
快捷菜单（上下文菜单）
通过鼠标右键单击某个组件对象而弹出的菜单，一般是与该组件相关的操作。
1.主菜单 主菜单一般包含：文件、编辑、帮助等，位于 GUI 窗口的上面。创建主菜单一般有如下 4
步：
创建主菜单栏对象 menubar = tk.Menu(root) 创建菜单，并添加到主菜单栏对象 file_menu = tk.Menu(menubar) menubar.add_cascade(label=”文件”,menu=file_menu) 添加菜单项到 2 步中的菜单 file_menu.add_command(label=”打开”) file_menu.add_command(label=”保存”,accelerator=”^p” command=mySaveFile) file_menu.add_separator() file_menu.add_command(label=”退出”) 将主菜单栏添加到根窗口 root[“menu”]=menubar 1.1【示例】记事本软件的主菜单 #记事本软件,练习主菜单的设计 from tkinter import * from tkinter.filedialog import * root = Tk();root.geometry("400x400") root.title("记事本") #创建主菜单栏 menubar = Menu(root) #创建子菜单 menuFile = Menu(menubar) menuEdit = Menu(menubar) menuHelp = Menu(menubar) #将子菜单加入到主菜单栏 menubar.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0ed5bd9b3aa3313281c842b0d7285ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b22c34f295505fab902c0410b6e2d4c1/" rel="bookmark">
			Multisim软件仿真之频谱分析仪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络上有很多Multisim文件，有些是不能复现的，比如频谱仪，按照下面链接去操作，怎么也测试不出来波形，multisim频谱仪使用_multisim输入输出端口-CSDN博客。
原因分析：
1、博主设置参数未讲全，按照图示，无法得出波形
2、软件版本升级
3、波形过密，无法展开
实际操作和界面参数设置如下：
1、设置右侧参数
照抄即可，能够出波形之后再自由设置
2、点击“仿真开始按钮”
3、点击右侧的“start”按钮 （和其他虚拟仪器操作不一样的地方）
4、出图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4735e2c45897b29de6b97301113e1736/" rel="bookmark">
			前端-尚硅谷-尚品汇-reset
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		辛苦我这么费劲打禹神的reset
/* 基础设施 */
body,h1,h2,h3,h4,h5,h6,hr,p,blockquote,dl,dt,dd,ul,ol,li,pre,form,fieldset,legend,button,input
{
margin: 0px;
padding: 0px;
}
/* 有序 无序列表 前面小圆点数字都没有*/
ol,ul{
list-style: none;
}
img {
/* 底部留白 */
display: block;
border: 0;
}
b,strong {
font-weight: 400;
}
h1,h2,h3,h4,h5,h6{
font-style: 100%;
font-weight: normal;
}
em,i {
/* 不倾斜 */
font-style: normal;
}
u,ins,s,del {
/* 去掉中划线 下划线 */
text-decoration: none;
}
table {
border: 1px solid #999;
/* cellspacing 属性规定单元格之间的空间。 注释： 请勿将该属性与 cellpadding 属性相混淆，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4735e2c45897b29de6b97301113e1736/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f7a4b16c5d572bdccaef476b522ee62/" rel="bookmark">
			人工智能--自然语言处理NLP概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到 Papicatch的博客
目录
🍉引言
🍈基本概念
🍈核心技术
🍈常用模型和方法
🍈应用领域
🍈挑战和未来发展
🍉案例分析
🍈机器翻译中的BERT模型
🍈情感分析在市场分析中的应用
🍈智能客服系统中的对话管理
🍉代码示例
🍈分词
🍈 词性标注
🍈命名实体识别
🍈文本生成
🍈情感分析
🍈机器翻译
🍉总结
🍉引言 自然语言处理（Natural Language Processing，NLP）是计算机科学和人工智能领域的一个重要分支，专注于计算机与人类语言的互动。它涉及使用计算机算法来处理和理解人类语言。以下是NLP的一些关键概念和应用。
🍈基本概念 语法和句法分析：分析句子的结构，包括词性标注（POS tagging）和依存句法分析（Dependency Parsing）。这些技术帮助理解句子的组成部分和它们之间的关系。语义分析：理解句子的意义，包括词义消歧（Word Sense Disambiguation）和命名实体识别（Named Entity Recognition）。语义分析使计算机能够理解不同词汇在不同上下文中的含义。文本生成：生成自然语言文本，如文本摘要、自动回复、对话系统等。这些应用使得机器可以生成符合语法和语义的自然语言文本。情感分析：分析文本中的情感倾向，包括情感分类和情感强度分析。情感分析在市场分析和舆情监控中有重要应用。 🍈核心技术 分词：将文本分解为单独的词或词组，是中文处理中特别重要的一步。词性标注：为每个词分配一个词性标签（如名词、动词等），帮助理解词在句子中的功能。命名实体识别：识别并分类文本中的实体，如人名、地名、组织名等。对于信息抽取和检索非常关键。依存句法分析：分析句子中词与词之间的依存关系，有助于理解复杂句子的结构。语义角色标注：识别句子中各个成分的语义角色，如施事、受事等，帮助深入理解句子含义。 🍈常用模型和方法 规则基础方法：基于语言学规则进行处理，但难以扩展和适应不同领域。统计方法：利用大规模语料库和概率模型进行处理，如n-gram模型。机器学习：包括支持向量机、决策树等传统机器学习算法，用于分类和预测。深度学习：尤其是基于神经网络的方法，如循环神经网络（RNN）、长短期记忆网络（LSTM）、Transformer等。深度学习模型能够处理大规模数据并从中学习复杂的模式。预训练模型：如BERT、GPT等，通过在大规模语料库上进行预训练，再进行特定任务的微调，这些模型显著提高了NLP任务的性能。 🍈应用领域 机器翻译：如Google翻译，通过自动翻译不同语言之间的文本，使得跨语言交流更加便捷。信息检索：如搜索引擎，通过关键词匹配和自然语言理解提高搜索结果的相关性。文本分类：如垃圾邮件过滤、新闻分类等，帮助自动化处理大量文本数据。对话系统：如智能客服、虚拟助手（如Siri、Alexa等），实现人与机器的自然对话。文本生成：如新闻自动生成、内容创作辅助等，提升内容生成的效率和质量。情感分析：用于市场分析、舆情监控等，帮助理解公众对某些事件或产品的态度。 🍈挑战和未来发展 多语言处理：处理不同语言的多样性和复杂性，提高跨语言模型的性能。上下文理解：提高模型对上下文的理解和推理能力，尤其是长文本和复杂句子中的上下文关系。模型解释性：增强模型的可解释性和透明性，使得用户和开发者能够理解模型的决策过程。数据隐私：保护用户数据隐私和安全，尤其在处理敏感信息时。 🍉案例分析 🍈机器翻译中的BERT模型 BERT（Bidirectional Encoder Representations from Transformers）是一种深度学习模型，通过双向编码器表示从大量文本数据中学习语言模式。它在翻译任务中显著提升了翻译的准确性和流畅度。例如，在中英翻译中，BERT模型能够更好地理解和翻译复杂句子结构，提高了翻译质量。
from transformers import MarianMTModel, MarianTokenizer # 加载预训练的MarianMT模型和tokenizer model_name = 'Helsinki-NLP/opus-mt-en-zh' tokenizer = MarianTokenizer.from_pretrained(model_name) model = MarianMTModel.from_pretrained(model_name) # 翻译文本 text = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f7a4b16c5d572bdccaef476b522ee62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b6a0e730e5be8e9b455822144137368/" rel="bookmark">
			RabbitMQ实践——使用死信机制对异常消息进行处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大纲 独立的死信交换器创建死信交换器死信交换器绑定队列创建自动路由到死信交换器上的队列实验 重用原始交换器简单案例测试 复杂案例新建交换器新建队列绑定测试 在《RabbitMQ实践——对不可路由的消息的处理方法》一文中，我们使用备用交换器来处理当前交换器不可路由的消息。这类消息的异常往往出现在Routing key这类会影响路由的字段上，而如果消息体自身有问题——结构不符合业务约定、某个字段值不合法，则怎么处理呢？是抛弃还是让其继续保留在队列中？上述两种方式都不太好：如果抛弃则会让我们丧失分析异常的机会；如果保留在队列中则会堆积，影响后续处理效率。
RabbitMQ提供了死信机制来辅助我们处理这类消息。其基本原理就是在业务逻辑判断这些消息存在异常的情况下，让这些消息路由到另外一个独立的队列中。这样后续维护人员可以从这个队列中获取数据进行分析，而不会影响线上业务。
RabbitMQ提供了两个死信机制。
在做这次实验之前，我们先创建一个普通队列dead_letter_queue，用于保存死信。
独立的死信交换器 如上图，消费者在从正常队列中获取消息。突然发现一个异常消息，它就拒绝该消息，并让RabbitMQ服务不要再发送这条消息。这样RabbitMQ服务会将这条退回到队列中的消息路由到一个独立的死信交换器上，交由它来路由到死信队列。
创建死信交换器 为了让死信交换器可以接收所有消息，我们使用了不用做规则匹配的fanout类型交换器。从下图可以看出，死信交换器（我们给它命名dead.letter）和其他交换器没什么区别。
死信交换器绑定队列 我们让这个交换器绑定到之前创建的死信队列dead_letter_queue上。
创建自动路由到死信交换器上的队列 我们创建一个名字叫queue_with_dead_letter_exchange，x-dead-letter-exchange参数值是之前创建的死信交换器dead.letter的队列。
实验 在默认交换器中，我们发布一条消息到queue_with_dead_letter_exchange队列上。
然后在该队列页面中，接收这条消息，但是告诉RabbitMQ服务，消费者拒绝这条消息，同时不要重发。
这个时候queue_with_dead_letter_exchange队列中就不存在这条消息了。
它被路由到这条队列（queue_with_dead_letter_exchange）通过x-dead-letter-exchange参数指定的死信交换器dead.letter上。然后死信交换器将其路由到死信队列dead_letter_queue上。
重用原始交换器 之前的案例，我们需要新建一个死信交换器、绑定关系、死信队列才能完成死信所有功能。
而RabbitMQ还提供了一种重用原始交换器的功能，我们只要新建绑定关系、死信队列就可以完成所有功能。
简单案例 因为之前使用的是默认交换器。它并不需要设定绑定关系，而是自动通过各个队列名作为Routing key，将消息路由到队列上。这样在简单案例中，我们省去建立绑定关系这个步骤。
但是我们还是要新建一个队列，它需要将x-dead-letter-exchange设定为消息发送来源的交换器，还要将x-dead-letter-routing-key设定为重写消息的Routing key（指向死信队列），让消息在被消费者拒绝且不再重发后，通过这条消息来源的交换器，再路由到死信队列。
因为我们使用的是默认交换器，所以下图中x-dead-letter-exchange是空值，x-dead-letter-routing-key是死信队列的名称。
测试 在默认交换器中，我们给刚创建的队列发布一条消息。
然后消费者拒绝这条消息，并让RabbitMQ不再重发。
这条消息就被路由到死信队列中了
复杂案例 因为之前我们直接使用了默认交换器，省去了Banding关系这个环节。
本例我们将使用一个稍微常见的组织形式。
新建交换器 我们创建一个名字叫direct.with.dead.letter的交换器。该交换器很普通，就是一个direct类型的交换器。
新建队列 新建一个名字叫common_queue的队列。指定x-dead-letter-exchange是上一步创建的交换器名direct.with.dead.letter;指定被拒绝切不重发的消息的Routing key被重写为to.dead.letter。
死信队列就沿用之前创建的队列dead_letter_queue。
绑定 新建两个绑定关系：
to.common的Routing key被路由到队列common_queue。to.dead.letter的Routing key被路由到队列dead_letter_queue。
测试 我们先给common_queue发布一条消息。
然后消费者拒绝这条消息，并通知RabbitMQ不再重发。
这样，这条消息的Routing key就被重写为to.dead.letter，然后被交换器路由到死信队列。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecc7180ae9236e488532928c91659bad/" rel="bookmark">
			数据结构之探索“栈”的奥秘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找往期文章包括但不限于本期文章中不懂的知识点：
个人主页：我要学编程(ಥ_ಥ)-CSDN博客
所属专栏：数据结构（Java版）
目录
栈的有关概念
栈的使用 栈的模拟实现
栈的应用场景
改变元素的序列
将递归转化为循环 栈的相关刷题 20. 有效的括号
150. 逆波兰表达式求值
牛客网——JZ31 栈的压入、弹出序列
155. 最小栈
栈的有关概念 栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则。
压栈：栈的插入操作叫做进栈/压栈/入栈。 出栈：栈的删除操作叫做出栈。
下面是栈以及其有关操作的图示：
栈的使用 栈的基本方法 方法功能Stack()构造一个空的栈E push(E e)将e入栈，并返回eE pop()得到并删除栈顶元素E peek()获取栈顶元素int size()获取栈中有效元素的个数boolean empty()检测栈是否为空 下面是上面方法的使用：
public class Test { public static void main(String[] args) { // 构造方法：构造一个空栈 Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); // 判断栈是否为空 System.out.println(stack.empty()); // 开始往栈区增加元素：压栈/入栈 stack.push(1); stack.push(2); stack.push(3); stack.push(4); stack.push(5); // 获取栈顶元素 System.out.println(stack.peek()); // 得到并删除栈顶元素 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecc7180ae9236e488532928c91659bad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f589b225a13929da1aa155ae0a8cdd54/" rel="bookmark">
			爬虫笔记12——网页爬取数据写入json文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 json数据格式介绍 JSON全称为JavaScript Object Notation， 也就是JavaScript对象标记，它通过对象和数组的组合来表示数据，构造简洁但是结构化程度非常高，是一种轻量级的数据交换格式。该笔记中，我们就来了解如何利用Python保存数据到JSON文件。
python中的json库 直接导入该模块:
import json 方法作用json.dumps()把python对象转换成json对象，生成的是字符串。json.dump()用于将dict类型的数据转成str，并写入到json文件中 爬虫案例 - 4399网站游戏信息采集 import json import requests from lxml import etree def spider_4399(url): response = requests.get(url).content.decode('gbk') # print(response) tree = etree.HTML(response) # print(tree) gameLists = tree.xpath("//ul[@class='tm_list']/li/a") gameDicts = dict() result = list() # print(gameLists) for temp in gameLists: gameDicts['game'] = temp.xpath('./text()')[0] gameDicts['url'] = temp.xpath('./@href')[0] result.append(gameDicts) with open('./game.json', 'w', encoding='utf-8') as f: f.write(json.dumps(result, indent=2, ensure_ascii=False)) print('程序结束！') url = 'https://www.4399.com/' spider_4399(url) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca1a068a6eb3b3e92bfdc4921ff81f87/" rel="bookmark">
			最新Prompt预设词分享，DALL-E3文生图&#43;文档分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用指南 直接复制使用
可以前往已经添加好Prompt预设的AI系统测试使用（可自定义添加使用）
支持GPTs
SparkAi SparkAi创作系统是基于ChatGPT进行开发的Ai智能问答系统和Midjourney绘画系统，支持OpenAI-GPT全模型+国内AI全模型。支持GPT-4o大模型、文档分析、识图图片理解、GPTs应用、GPT语音对话、联网提问、GPT-4全模型、DALL-E3文生图、GPT4-All联网搜索模型、思维导图、会员套餐功能、分销系统、Midjourney绘画动态全功能、AI换脸、垫图混图、Vary Region 局部编辑重绘、插件功能等等！
地址：https://ai.sparkaigf.com
AI模型提问 文档分析 识图理解能力 联网读取分析网页 GPTs应用 可全网搜索使用
AI绘画 Prompt预设词分享 雅思写作考官 我希望你假定自己是雅思写作考官，根据雅思评判标准，按我给你的雅思考题和对应答案给我评分，并且按照雅思写作评分细则给出打分依据。此外，请给我详细的修改意见并写出满分范文。
佛祖 请你充当佛祖，以佛祖的风格回答问题。可以结合佛祖的人生经历、文学修养，作诗风格进行回答。请用能够体现出佛祖说话风格的口吻回答我的任何问题，营造一种和真实的佛祖对话的感觉。
论文摘要润色者 请你充当一名论文编辑专家，在论文评审的角度去修改论文摘要部分，使其更加流畅，优美。下面是具体要求：
能让读者快速获得文章的要点或精髓，让文章引人入胜；能让读者了解全文中的重要信息、分析和论点；帮助读者记住论文的要点字数限制在300字以下请你在摘要中明确指出您的模型和方法的创新点，强调您的贡献。用简洁、明了的语言描述您的方法和结果，以便评审更容易理解论文 下文是论文的摘要部分，请你修改它：
论文改进助手 我想让你做一个 AI 写作导师。我将为您提供一名需要帮助改进其写作的学生，您的任务是使用人工智能工具（例如自然语言处理）向学生提供有关如何改进其作文的反馈。您还应该利用您在有效写作技巧方面的修辞知识和经验来建议学生可以更好地以书面形式表达他们的想法和想法的方法。我的第一个请求是“我需要有人帮我修改我的硕士论文”。
论文内容创作（通过主题） 我要你演院士。您将负责研究您选择的主题，并以论文或文章的形式展示研究结果。您的任务是确定可靠的来源，以结构良好的方式组织材料并通过引用准确记录。我的第一个建议请求是
例子：
我需要帮助写一篇针对 18-25 岁大学生的可再生能源发电现代趋势的文章。
充当 Linux 终端 我想让你充当 Linux 终端。我将输入命令，您将回复终端应显示的内容。我希望您只在一个唯一的代码块内回复终端输出，而不是其他任何内容。不要写解释。除非我指示您这样做，否则不要键入命令。当我需要用英语告诉你一些事情时，我会把文字放在中括号内[就像这样]。我的第一个命令是 pwd
充当英语翻译和改进者 替代：语法，谷歌翻译
我希望你能担任英语翻译、拼写校对和修辞改进的角色。我会用任何语言和你交流，你会识别语言，将其翻译并用更为优美和精炼的英语回答我。请将我简单的词汇和句子替换成更为优美和高雅的表达方式，确保意思不变，但使其更具文学性。请仅回答更正和改进的部分，不要写解释。我的第一句话是“how are you ?”，请翻译它。
充当论文润色者（拿摘要部分举例） 请你充当一名论文编辑专家，在论文评审的角度去修改论文摘要部分，使其更加流畅，优美。下面是具体要求：
能让读者快速获得文章的要点或精髓，让文章引人入胜；能让读者了解全文中的重要信息、分析和论点；帮助读者记住论文的要点字数限制在300字以下请你在摘要中明确指出您的模型和方法的创新点，强调您的贡献。用简洁、明了的语言描述您的方法和结果，以便评审更容易理解论文 下文是论文的摘要部分，请你修改它：
充当英翻中 下面我让你来充当翻译家，你的目标是把任何语言翻译成中文，请翻译时不要带翻译腔，而是要翻译得自然、流畅和地道，使用优美和高雅的表达方式。请翻译下面这句话：“how are you ?”
充当英英词典(附中文解释) 将英文单词转换为包括中文翻译、英文释义和一个例句的完整解释。请检查所有信息是否准确，并在回答时保持简洁，不需要任何其他反馈。第一个单词是“Hello”
充当前端智能思路助手 替代：百度、谷歌人工搜索
我想让你充当前端开发专家。我将提供一些关于Js、Node等前端代码问题的具体信息，而你的工作就是想出为我解决问题的策略。这可能包括建议代码、代码逻辑思路策略。我的第一个请求是“我需要能够动态监听某个元素节点距离当前电脑设备屏幕的左上角的X和Y轴，通过拖拽移动位置浏览器窗口和改变大小浏览器窗口。”
担任面试官 示例：Java 后端开发工程师、React 前端开发工程师、全栈开发工程师、iOS 开发工程师、Android开发工程师等。
我想让你担任Android开发工程师面试官。我将成为候选人，您将向我询问Android开发工程师职位的面试问题。我希望你只作为面试官回答。不要一次写出所有的问题。我希望你只对我进行采访。问我问题，等待我的回答。不要写解释。像面试官一样一个一个问我，等我回答。我的第一句话是“面试官你好”
文字冒险游戏 我想让你扮演一个基于文本的冒险游戏。我在这个基于文本的冒险游戏中扮演一个角色。请尽可能具体地描述角色所看到的内容和环境，并在游戏输出的唯一代码块中回复，而不是其他任何区域。我将输入命令来告诉角色该做什么，而你需要回复角色的行动结果以推动游戏的进行。我的第一个命令是'醒来'，请从这里开始故事
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca1a068a6eb3b3e92bfdc4921ff81f87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bec5fc07964c010bdc713ff40a123695/" rel="bookmark">
			Python 设计模式(第2版) -- 第一部分（创建型模式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 设计模式(第2版) 设计模式的主要特点如下所示：
它们是语言无关的，可以用多种语言实现。它们是动态的，随时会有新的模式引入。它们可以进行定制，因此对开发人员非常有用。 设计模式的优点如下所示：
它们可以在多个项目中重复使用。问题可以在架构级别得到解决。它们都经过了时间的验证和良好的证明，是开发人员和架构师的宝贵经验。它们具有可靠性和依赖性。 Python是一种动态语言。Python 的动态特性如下所示：
类型或类是运行时对象。变量可以根据赋值来确定类型，并且类型可以在运行时改变。动态语言在类限制方面具有更大的灵活性。例如，在 Python 中，多态性是该语言所固有的，并没有诸如 private 和 protected 之类的关键字，因为默认情况下一切都是公共的。可以使用动态语言轻松实现设计模式的用例。 设计模式是由 GoF（Gang of Four）首先提出的，根据他们的观点，设计模式就是解决特定问题的解决方案。在他们的设计模式书中讲到了 23 种设计模式，并将它们分为三大类：
创建型模式。结构型模式。行为型模式。 以下是创建型模式的性质：
它们的运行机制基于对象的创建方式。它们将对象创建的细节隔离开来。代码与所创建的对象的类型无关。 以下是结构型模式的性质：
它们致力于设计出能够通过组合获得更强大功能的对象和类的结构。重点是简化结构并识别类和对象之间的关系。它们主要关注类的继承和组合。 行为型模式具有下列性质：
它们关注对象之间的交互以及对象的响应性。对象应该能够交互，同时仍然保持松散耦合。 首先来看看创建型设计模式有哪些。
单例模式 单例模式提供了这样一个机制，即确保类有且只有一个特定类型的对象，并提供全局访问点。因此，单例模式通常用于下列情形，例如日志记录或数据库操作、打印机后台处理程序，以及其他程序——该程序运行过程中只能生成一个实例，以避免对同一资源产生相互冲突的请求。
下面是基于 Python v3.5 的单例模式实现代码，它主要完成了两件事情。
1．只允许Singleton类生成一个实例。2．如果已经有一个实例了，我们会重复提供同一个对象。
class Singleton(object): def __new__(cls): if not hasattr(cls, 'instance'): cls.instance = super(Singleton, cls).__new__(cls) return cls.instance s = Singleton() print("Object created", s) s1 = Singleton() print("Object created", s1) 单例模式的用例之一就是懒汉式实例化。懒汉式实例化能够确保在实际需要时才创建对象。所以，懒汉式实例化是一种节约资源并仅在需要时才创建它们的方式。
class Singleton: __instance = None def __init__(self): if not Singleton.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bec5fc07964c010bdc713ff40a123695/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d35d6c89674fe5288500c99e3418d2e5/" rel="bookmark">
			【Android WebView】WebView基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 WebView是一个基于webkit引擎、展现web页面的控件。Android的Webview在低版本和高版本采用了不同的webkit版本内核，4.4后直接使用了Chrome。
二、重要类 以WebView类为基础，WebSettings、WebViewClient、WebChromeClient为辅助共同完成安卓段加载网页的操作。
1、WebView //1、加载网页相关 //直接加载服务器网页 my_web_view.loadUrl("https://www.baidu.com") //直接加载本地网页file:///android_asset/为固定写法） my_web_view.loadUrl("file:///android_asset/1.html") // 缓存历史清理 //Clears the resource cache. Note that the cache is per-application, // so this will clear the cache for all WebViews used. my_web_view.clearCache(true) // 清空历史（本webView浏览的） my_web_view.clearHistory() // 结合工具类 my_web_view.webViewClient = object : WebViewClient() // 设置webViewClient my_web_view.webChromeClient = object : WebChromeClient()// 设置WebChromeClient /** * 返回键处理，网页中可返回上一页，不处理返回键直接退出App * */ override fun onKeyDown(keyCode: Int, event: KeyEvent?): Boolean { //when user press back code and canGoBack if (keyCode == KeyEvent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d35d6c89674fe5288500c99e3418d2e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8870883916a17bd659f79da9ea205e73/" rel="bookmark">
			一文弄懂 Python os.walk()，轻松搞定文件处理和目录遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍉 CSDN 叶庭云：https://yetingyun.blog.csdn.net/
Python os 模块的 walk() 方法以自顶向下或自底向上的方式遍历指定的目录树，从而显示目录树中的文件名。对于目录树中的每个目录，os.walk() 方法都会产生一个包含目录路径、当前目录下的子目录列表和文件名的三元组。
当您使用 Python 进行文件处理和目录遍历时，os.walk() 是一个非常有用的函数。这个函数允许您以递归的方式遍历一个目录树，获取关于目录结构的信息，包括其子目录和文件。接下来，我将详细解释 os.walk() 的工作原理以及如何使用它。
本文的思维导图如下所示：
os.walk() 的基本工作原理 os.walk(top, topdown=True, onerror=None, followlinks=False) 是 os 模块中的一个函数，用于生成遍历目录树的文件名。这个函数返回一个三元组 (dirpath, dirnames, filenames)。
dirpath 是一个字符串，表示正在遍历的目录的路径。dirnames 是一个列表，包含了 dirpath 下所有子目录的名字。filenames 是一个列表，包含了非目录文件的名字。 参数详解 top：要遍历的顶级目录的路径。topdown (可选)：如果为 True（默认值），则从顶级开始向下遍历。如果为 False，则从底部的子目录开始向上遍历。onerror (可选)：是一个函数，用于错误处理。如果指定，则应该是一个接受单个参数（异常实例）的函数。如果未指定或为 None，错误将被忽略。followlinks (可选)：如果为 True，则会遍历符号链接指向的目录。 使用示例 假设我们有以下目录结构：
my_project/ ├── main.py ├── module1 │ ├── __init__.py │ └── utils.py └── module2 ├── __init__.py └── helper.py 我们想要遍历 my_project 目录并打印出其结构：
import os # 指定顶级目录路径 top_path = 'my_project' # 使用 os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8870883916a17bd659f79da9ea205e73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c42cc11a271b12ca4836f42cfe45d89f/" rel="bookmark">
			C语言王国——深入自定义类型（结构体）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、引言
二、结构体
1. 结构体类型的声明
2. 结构体变量的创建和初始化
2.1 创建
2.2 初始化
2.3 typedef
2.4 特殊声明
2.5 自引用
3. 结构成员访问操作符
4. 结构体内存对齐
4.1 对齐规则
4.2 offsetof
4.3 为什么存在内存对齐
5. 结构体传参
6. 结构体实现位段
6.1 定义
6.2 位段的内存分配
6.3 跨平台问题
6.4 位段使用的注意事项
三、结论
一、引言 上回我们学完了数据在内存中的存储，那C语言中还有更多来自于我们程序员自己创造的类型——自定义类型，如结构体、联合体、枚举。而本章的深入自定义类型就由姜糖我来给大家讲讲结构体的相关知识。
二、结构体 结构是⼀些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。
与数组差不多，不过数组类型是相同的，结构体类型可以是不同的哦。
1. 结构体类型的声明 struct tag { member-list; }variable-list; 2. 结构体变量的创建和初始化 2.1 创建 如我们定义一个人的结构体：
人： 姓名，年龄，性别
struct people //人的结构体 { char name[5];//姓名 int age; //年龄 char sex[3];//性别 };//与函数不同结尾要有分号 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c42cc11a271b12ca4836f42cfe45d89f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8fb73726ca38f04a10791f33415b39c/" rel="bookmark">
			JavaFX DatePicker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaFX DatePicker允许从给定日历中选择一天。DatePicker控件包含一个带有日期字段和日期选择器的组合框。JavaFX DatePicker控件使用JDK8日期时间API。
import javafx.application.Application; import javafx.scene.Scene; import javafx.scene.control.DatePicker; import javafx.scene.layout.VBox; import javafx.stage.Stage; public class Main extends Application { public static void main(String[] args) { launch(args); } @Override public void start(Stage stage) { VBox vbox = new VBox(20); Scene scene = new Scene(vbox, 400, 400); stage.setScene(scene); DatePicker checkInDatePicker = new DatePicker(); vbox.getChildren().add(checkInDatePicker); stage.show(); } } DatePicker创建 我们可以创建一个DatePicker并在类构造函数中设置一个特定的日期值。
dateP = new DatePicker(LocalDate.of(2018, 10, 8)); 还可以使用setValue()方法设置日期值。
checkInDatePicker.setValue(LocalDate.of(2014, 10, 8)); checkInDatePicker.setValue(LocalDate.now()); 以下代码使用setValue()向结束DatePicker添加更多时间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8fb73726ca38f04a10791f33415b39c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a31db1817af9bb24fbd761d2d0c30caf/" rel="bookmark">
			个人博客测试用例设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 个人博客测试用例设计 个人博客测试用例 分别从功能、性能、安全、兼容及界面分别展开
个人博客测试用例 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/251/">«</a>
	<span class="pagination__item pagination__item--current">252/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/253/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>