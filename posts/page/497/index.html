<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/875698b084f30bcaf6ca7127d6dca9fc/" rel="bookmark">
			​​​​​​​​​​​​​​.NET Core Web API架构&#43;应用场景&#43;实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​​​​​​一.NET Core Web API 架构
.NET Core Web API 架构是一个基于 ASP.NET Core 框架构建的用于创建 HTTP 服务的架构。它采用了 MVC（Model-View-Controller）架构模式，并提供了许多内置的功能和工具，以帮助开发者快速构建可扩展、可维护且高性能的 Web API。
以下是 .NET Core Web API 架构的一些关键组件和概念：
控制器（Controllers）：控制器是处理 HTTP 请求的类，它们负责接收请求数据、调用业务逻辑层的方法，并返回响应数据。控制器中的每个方法通常对应一个特定的 HTTP 动作（如 GET、POST、PUT、DELETE 等）和一个路由。模型（Models）：模型表示应用程序中使用的数据对象。它们通常对应于数据库中的表或业务实体。模型类负责数据的验证、转换和存储。视图（Views）：在 Web API 架构中，视图通常不是用于呈现用户界面，而是用于定义 API 的响应格式。开发者可以使用不同的序列化器（如 JSON.NET、XML 序列化器等）来控制模型数据如何转换为 API 响应。路由（Routing）：路由是确定如何将 HTTP 请求映射到相应控制器和方法的机制。ASP.NET Core 提供了一个灵活的路由系统，允许开发者定义复杂的路由模式和参数。依赖注入（Dependency Injection）：依赖注入是 .NET Core Web API 架构中的一个核心概念，它允许开发者将服务和组件注入到控制器和其他类中。这有助于提高代码的可测试性和可维护性。中间件（Middleware）：中间件是处理 HTTP 请求和响应的组件管道。每个中间件组件都可以执行特定的任务，如身份验证、日志记录、异常处理等。验证和授权（Validation and Authorization）：.NET Core Web API 提供了强大的验证和授权机制，以确保 API 请求的数据有效性和安全性。开发者可以使用数据注解或自定义验证逻辑来验证模型数据，并使用角色和策略来限制对 API 的访问。异常处理（Exception Handling）：为了提供一致的错误处理体验，.NET Core Web API 支持全局异常处理和自定义错误响应。测试（Testing）：ASP.NET Core 提供了丰富的测试工具和框架，如 xUnit、Mockito 等，用于对 Web API 进行单元测试、集成测试和端到端测试。扩展性（Extensibility）：由于 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/875698b084f30bcaf6ca7127d6dca9fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb35b78de208e97c48b4b0142cc71b3d/" rel="bookmark">
			postman安装使用（mac）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		postman用于测试http协议接口，无论是开发、还是测试人员，都有必要学习使用postman来测试接口，用起来非常方便。
postman可以直接在chrome、safari上安装插件，也可以在电脑本地安装postman客户端工具。也就是说postman可作为适用于mac、windows、linux操作系统的本机桌面应用程序使用。
第三方网站下载
https://www.jb51.net/softs/435691.html
官网
https://web.postman.com/
安装 可以以插件的方式使用，在浏览器上安装插件；也可以安装桌面应用。
推荐使用桌面应用
浏览器插件 打开mac的app store，搜索postman
点击【获取】，登录appleID，【安装】
浏览器会提示是否使用插件
桌面应用 下载后是下图中的压缩包，解压后是下图中的postman文件。
双击【postman】，提示是否移入applications文件夹，选择移入。
弹出如下界面，按照界面所示，创建一个账户。
点击上图中的创建账户后，会在浏览器中打开如下界面。
登录是在网页登录的，要联网。
使用 注册登录 见桌面应用
工作空间 登录后，界面如下
工作空间，可以做云备份。可以理解为桌面app的这个postman就是一个客户端。
关闭overview，点击“+”
点击【save】
【create collection】，如下所示，然后点击【create】
选中，然后【save】
getpost等 见oracle数据发布为REST服务中的相关Postman测试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84683bfe3113cc7d514d490512e08a28/" rel="bookmark">
			Python高效操作Word：实用技巧与进阶方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python高效操作Word：实用技巧与进阶方法 引言 在当今数据驱动的时代，自动化处理文档成为了提高工作效率的关键。特别是对于中级和高级开发者而言，能够有效操作Word文档是一个极具价值的技能。Python，作为一门强大的编程语言，提供了丰富的库和工具来处理Word文档，从而使得这一过程既简便又高效。
本文旨在为读者提供一份全面而深入的指南，介绍如何使用Python来操作Word文档。文章将从基本的创建、读取和写入Word文档讲起，逐步深入到格式化文档、处理复杂内容以及高级功能的应用，如批量处理文档、数据提取和报告生成。此外，还将探讨一些特殊技巧，包括图表处理、宏的应用和交叉引用的管理。文章内容将结合丰富的代码示例，确保读者能够在实际开发中迅速应用这些技巧。
无论是需要批量生成报告、提取文档中的关键信息，还是希望优化现有文档处理流程的开发者，都将在本文中找到宝贵的指导和灵感。接下来，让我们一起深入探索Python处理Word文档的世界，解锁更高效的文档处理方法。
Python与Word交互的基础知识 在开始深入探究Python操作Word的各种技巧之前，了解一些基础知识是非常重要的。这包括熟悉用于交互的Python库，以及如何配置环境以支持这些操作。
1. Python与Word的交互工具 Python社区提供了多种库来处理Word文档，但最广泛使用的是python-docx库。它是一个功能丰富的库，允许用户创建、修改甚至是删除Word文档的内容。此外，还有一些其他的库，如docx-mailmerge，专门用于处理邮件合并相关的任务。
2. 安装python-docx 安装python-docx非常简单，可以通过Python的包管理工具pip来完成。打开终端或命令提示符，输入以下命令即可安装：
pip install python-docx 3. 配置环境 安装python-docx后，我们需要确保Python环境配置正确。这通常意味着拥有Python的最新版本，并确保所有依赖包都已更新至最新版本。可以使用以下命令来更新pip自身和所有已安装的包：
pip install --upgrade pip pip list --outdated | cut -d' ' -f1 | xargs pip install --upgrade 4. 基本概念和操作 使用python-docx时，有几个基本概念需要理解： - 文档对象（Document）：这是最基本的单位，代表了整个Word文档。 - 段落（Paragraph）：文档中的一个段落。 - 运行（Run）：段落中具有相同样式的连续文本。
了解了这些基本概念后，我们就可以开始进行一些简单的操作，比如创建一个新的Word文档，或者读取现有文档的内容。
基本操作：创建、读取和写入Word文档 掌握Python对Word文档的基本操作是进一步深入学习的基础。本节将介绍如何使用python-docx库来创建新的Word文档、读取现有文档的内容，以及向文档中写入文本。
1. 创建Word文档 使用python-docx创建一个新的Word文档非常简单。以下代码展示了如何创建一个新文档并保存：
from docx import Document # 创建一个新的Word文档 doc = Document() # 添加一个段落 doc.add_paragraph('这是一个新的段落。') # 保存文档 doc.save('new_document.docx') 2. 读取Word文档内容 读取现有Word文档也是python-docx的一个重要功能。以下示例代码展示了如何打开一个文档并读取其内容：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84683bfe3113cc7d514d490512e08a28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7700c8e738861cb0a04cc7487c291554/" rel="bookmark">
			【企业微信自建应用-前端篇】企业微信自建应用开发流程详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近接到需求，需要我在企业微信端自建一个应用，用来接受PC端派发的工单，告警，公告等内容。
这里写一个帖子汇总一下我经历的全流程开发，当然这是基础的流程啊。因为功能要求也不高。后面如果开发更多的东西再补充。
效果图 PC端下发的工单，告警、审批等推送到企业微信的自建应用内，处理人通过点击消息进去处理
1、企业微信自建应用 1.1 点击企业微信左上方头像弹出框的管理企业，进入企微后台管理
1.2 进入后台管理后，点击应用管理菜单进行自建应用的创建，配置该应用的logo，名称及介绍等
1.3 应用创建好后，点击进去进行可见范围、管理员、应用主页（注：应用主页即项目页面部署的线上地址，如果需要单点登录就需要配置和后端联调对接oauth2的地址）、可信域名等相关配置
一定要点开开发者接口下的网页授权及JS-sdk弹出框配置可信域名，方便后期和后端开发单点登录功能
2、项目开发及配置 1.1 我是用uniapp开发的，在HBuilder 工具中点击文件下-新建-项目 的弹出框中创建默认模板后进行项目的开发
1.2 项目代码开发完成后，点击HBuilder工具下的， 发行–&gt;网站pc web或手机H5 ，输入网站标题及域名后即可开始打包，打包后压缩包路径为，将压缩包部署到对应域名的服务器上
1.3 在企业微信的工作台中找到该应用点击进去，能显示出页面，或者企微消息列表中该应用能接收到 推送的消息即配置成功。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29c922acfc14a5e67fa0e272459465fb/" rel="bookmark">
			Sqlmap常用命令总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sqlmap常用命令总结： 注意：命令为kali linux中运行的 （windows中用python sqlmap.py执行） 1#、注入六连： 1. sqlmap -u "http://www.xx.com?id=x" 【查询是否存在注入点
--dbs 【检测站点包含哪些数据库 3. --current-db 【获取当前的数据库名
--tables -D "db_name" 【获取指定数据库中的表名 -D后接指定的数据库名称 5. --columns -T "table_name" -D "db_name" 【获取数据库表中的字段
6. --dump -C "columns_name" -T "table_name" -D "db_name" 【获取字段的数据内容
2#、COOKIE注入： sqlmap -u "http://www.xx.com?id=x" --cookie "cookie" --level 2 【cookie注入 后接cookie值
--dbs 【检测站点包含哪些数据库 3. --current-db 【获取当前的数据库名
--tables -D "db_name" 【获取指定数据库中的表名 -D后接指定的数据库名称 5. --columns -T "table_name" -D "db_name" 【获取数据库表中的字段
6. --dump -C "columns_name" -T "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29c922acfc14a5e67fa0e272459465fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f0a1564a2ea3263c5fe7a9c750c35f9/" rel="bookmark">
			Java实战：Spring Boot实现WebSocket实时通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文将详细介绍如何在Spring Boot应用程序中实现WebSocket实时通信。我们将探讨WebSocket的基本概念，以及如何使用Spring Boot和Spring WebSocket模块来实现WebSocket服务器和客户端。此外，我们将通过具体的示例来展示如何在Spring Boot应用程序中配置和使用WebSocket，以及如何实现实时消息传递和群发消息等功能。本文适合希望使用WebSocket技术实现实时通信的Spring Boot开发者阅读。
一、引言 在现代Web应用程序中，实时通信是一个关键需求，用于实现即时消息传递、在线聊天、实时数据同步等功能。WebSocket是一种网络通信协议，它提供了一种全双工通信渠道，允许服务器和客户端之间进行实时数据交换。Spring Boot提供了一种简便的方式来集成WebSocket技术，以实现实时通信功能。本文将介绍如何在Spring Boot应用程序中实现WebSocket实时通信。
二、WebSocket的基本概念 1. 什么是WebSocket？
WebSocket是一种网络通信协议，它提供了一种全双工通信渠道，允许服务器和客户端之间进行实时数据交换。WebSocket协议基于TCP协议，通过WebSocket连接，服务器和客户端可以相互发送消息，实现实时通信。
2. WebSocket的特点
全双工通信：WebSocket协议支持服务器和客户端之间的全双工通信，客户端和服务器可以同时发送消息。持久连接：WebSocket连接一旦建立，将持续保持打开状态，直到客户端或服务器关闭连接。跨域通信：WebSocket协议支持跨域通信，允许不同域的服务器与客户端建立连接。 三、在Spring Boot中实现WebSocket实时通信 1. 添加Spring WebSocket依赖
在项目的pom.xml文件中，添加Spring Boot的Spring WebSocket依赖：
&lt;dependencies&gt; &lt;!-- Spring Boot Web依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Boot WebSocket依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2. 创建WebSocket配置类
创建一个WebSocket配置类，用于配置WebSocket服务器端点。以下是一个简单的WebSocket配置类示例：
package com.example.demo.config; import org.springframework.context.annotation.Configuration; import org.springframework.messaging.simp.config.MessageBrokerRegistry; import org.springframework.web.socket.config.annotation.*; @Configuration @EnableWebSocketMessageBroker public class WebSocketConfig implements WebSocketMessageBrokerConfigurer { @Override public void configureMessageBroker(MessageBrokerRegistry config) { config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f0a1564a2ea3263c5fe7a9c750c35f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fc198c10fde8bdd677050fda68769c1/" rel="bookmark">
			uniapp vue3中使用webview在微信小程序中实现双向通讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uniapp vue3中使用webview在微信小程序中实现双向通讯 直接上图，注意事项是这里
官网链接: https://uniapp.dcloud.net.cn/component/web-view.html 传递方法的话好像只能通过url来传，其它方式不支持，，，我这个参数没做处理，用的话记得把参数做一下处理
也就是说传递数据之后需要
uni.redirectTo({ url: '/pages/testFabric/index' }) 特定时机，当然用其他的也行，比如uni.navigateBack()，但是在我这不好使。这样vue中 @message="handlerMessage"才会触发
下面是代码
vue3 ts代码 src就是项目启动的网络地址，他必须要用网络地址， scr后面拼接参数记得做处理，转成json
&lt;template&gt; &lt;view&gt; &lt;web-view src="http://xxxx:5173/src/static/fabric.html?iii=0" @message="handlerMessage" ref="webview" &gt;&lt;/web-view&gt; &lt;view class="button"&gt;evalJs(改变webview背景颜色)&lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script lang="ts" setup&gt; import { ref } from 'vue' const webview = ref(null) const handlerMessage = (e:any) =&gt; { console.log('快来---------') console.log('webview的', e) console.log('webview的webview', webview.value) } &lt;/script&gt; &lt;style lang="scss" scoped&gt; .test { position: relative; } .button { position: absolute; top: 1200rpx; left: 0; } &lt;/style&gt; 注意这里的script标签，需要引入
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fc198c10fde8bdd677050fda68769c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9149bb3ed8a37a2db712b369de71e54c/" rel="bookmark">
			[玩转AIGC]如何训练LLaMA2（模型训练、推理、代码讲解，并附可直接运行的kaggle连接）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、clone仓库二、数据集下载与处理1、数据集下载2、数据集tokenize预处理（耗时较长） 三、修改配置四、开始训练五、模型推理六、train.py训练代码讲解1、导包2、定义模型训练参数与相关设置3、加载模型配置4、迭代生成数据5、模型初始化6、设置自动混合精度与优化函数7、损失评估与学习率获取8、日志保存初始化9、循环训练 七、run.c推理代码讲解1、结构及内存管理2、模型初始化：读取checkpoint3、神经网络模块4、main函数入口 Llama 2，基于优化的 Transformer 架构，是Meta AI正式发布的最新一代开源大模型，一系列模型（7b、13b、70b）均开源可商用，效果直逼gpt3.5。
下面我们来介绍如何使用Llama 2来训练一个故事生成模型。
如果迫不及待想爽一把先，请直接跳到这里，可直接运行：llama2-c，学习不就是先让自己爽起来，而后才有欲望去深究为什么！！！
一、clone仓库 首先从github将仓库拉到本地：
git clone https://github.com/karpathy/llama2.c 进入目录
cd llama2.c 二、数据集下载与处理 注：具体内容可见[玩转AIGC]sentencepiece训练一个Tokenizer(标记器)这篇文章
1、数据集下载 python tinystories.py download 2、数据集tokenize预处理（耗时较长） python tinystories.py pretokenize 若运行到中途卡死了，可将并行运行的线程改小，打开tinystories.py，找到def pretolenize()函数，修改线程数max_workers=4：
# process all the shards in a threadpool with ThreadPoolExecutor(max_workers=4) as executor: executor.map(process_shard, shard_filenames) 注：在运行文末的kaggle代码时，不需要运行这一步，我已经提前编好的，只要运行!cp /kaggle/input/llama2tranningdatabin/databin/* /kaggle/working/llama2.c/data/TinyStories_all_data就可把文件拷贝到对应目录下，因为编号太久了，而且在kaggle里面容易挂掉
三、修改配置 然后修改一些配置：
train.py里面有几个参数要修改
batch_size改小一点，否则会报’CUDA out of memory’ 的错误（土豪卡多随意，不介意的话送我一张）
dtype要改为"float16"，否则会报’Current CUDA Device does not support bfloat16’的错误
compile要改为False，否则会报CUDA Capability过低或complex64不支持的错误
batch_size = 64 dtype = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9149bb3ed8a37a2db712b369de71e54c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab18c1ab75ddedf7f28a17a98bca76ed/" rel="bookmark">
			midjourney免费几次？国内可以用么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于midjourney这个软件，相信大家都听说过吧？毕竟这个软件一直以来是非常的出名的，是一款数一数二的ai绘画软件，但是这个midjourney是需要收费的，有朋友说有免费的次数，今天我们就来详细的聊一聊这方面吧，midjourney免费几次？国内可以用么？
一.midjourney免费么 midjourney在刚开始的时候确实是免费的，一个月有25次的免费使用次数，用完就没有了，但是后面更新了，没得免费白嫖了，需要付费才能使用！
二.Midjourney的收费情况 Midjourney会员分为三个等级，分别是10美元、30美元和60美元。这是月度收费标准，如果选择年费则会相对便宜一些。会员等级的不同主要表现在以下几个方面。
首先，10美元的会员按照张数收费，每20分钟时长可以生成大约200张图。生成一张图需要输入一个关键词或者点击一次u或v键。这种会员的性价比相对较低。
其次，30美元的会员可以享受15个小时的快速生成时间，无需排队，生成的图像分辨率稍微高一些，数量也是无限的。此外，该会员还可以访问会员画廊，查看别人的图片和提示词。总体来说，这种会员的性价比比较高。
最后，60美元的会员除了增加了快速生成时间之外，最重要的是可以隐私生成。这意味着用户生成的关键词不会放到会员画廊中，其他人无法看到用户的关键词。对于有特殊隐私需求的用户来说，这种会员是一个不错的选择。
三.Midjourney国内可以使用么 Midjourney在国内是可以使用的，但是前提你要会魔法，如果不会魔法是用不了的。如果不会魔法，那么可以使用么？
可以，你可以选择使用一些国内的ai绘画站点，有的是基于Midjourney而做出来的ai绘画站点，在使用上不会有太大的差别。你可以在任意的浏览器上车俞入 mj绘画.site 然后按确认进入就可以了。
四.Ai绘画站点的效果图 其实ai绘画站点有一个好处，那就是那些形容词完全是中文的，不需要我们会英文就可以描述生成了，这点是非常的好的。
如：一个年轻的日本女性，皮肤白皙、五官精致、眼睛大而有神，身材苗条、身形匀称，大长腿，穿着红色和白色的日本服装，戴着头饰和腰带
好了，以上就是关于 midjourney免费几次和相关内容的一些相关分享了，希望本文能帮助到大家，如果想了解更多，欢迎继续关注小编哦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5be935fbfdc7dc48d55516c69ddf1f55/" rel="bookmark">
			后轮位置反馈控制与算法仿真实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 后轮反馈控制2. 算法原理3. 算法和仿真实现 1. 后轮反馈控制 后轮反馈控制（Rear wheel feedback）算法是利用后轮中心的跟踪偏差来进行转向控制量计算的方法，属于Frenet坐标系的一个应用。通过选择合适的李雅普诺夫函数设计控制率，利用后轮中心的跟踪偏差来进行转向控制量计算的方法。
2. 算法原理 后轮反馈控制算法原理如上图所示，其中
P P P：当前距离车辆最近的路经点；
e y e_y ey​： P P P点与车辆后轮中心点的横向偏差 A P AP AP，实际上对应的就是frenet坐标下的 l l l；
φ \varphi φ：车辆朝向与 X X X轴正方向的夹角，即航向角；
φ r \varphi_{r} φr​： P P P点切线与 X X X轴正方向的夹角；
φ e \varphi_e φe​：车辆航向角误差，即 φ − φ r \varphi-\varphi_{r} φ−φr​；
n τ ⃗ \vec{n_\tau} nτ​ ​： P P P点法线的单位向量；
τ r ⃗ \vec{\tau_r} τr​ ​： P P P点切线的单位向量；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5be935fbfdc7dc48d55516c69ddf1f55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dcb1cc277d6641d40fb9ce900182b9f/" rel="bookmark">
			vscode&#43;qt&#43;qmake开发环境搭建，史上最全最详细！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		00. 前言 ​ 鉴于Qt官方IDE太过难用，VSCode＋各种插件功能强大，遂采用VSCode来写Qt项目。
01. 环境搭建 1. 需要安装的软件： VSCode，官方最新版就行Qt，版本随意，本文主要针对较老版本使用Qmake构建系统的项目 2. 环境变量： Qt环境变量，需要配置Qt库跟MinGW，尽量使用Qt安装时自带的MinGW
VSCode插件，下面C/C++插件是必需的没意见吧
02. 开始配置 1. 创建项目项目 先用Qt Creator创建个Qmake项目，最简单的空白窗口，项目结构如下
2. 使用VSCode打开项目 3. 配置C/C++插件 VSCode快捷键ctrl+shift+p打开命令面板，输入c++，选择编辑配置
4. 编辑C/C++设置 编译器路径:下拉有得选就选你配置环境变量的Qt版本，没有就自己复制路径过来
IntelliSense 模式：选择安装的gcc的架构，我安装的是64位Qt，上面自带的gcc编译器也是64位，就选择windows-gcc-x64
头文件路径：这个主要是实现头文件识别，要不然Qt的头文件一直飘红，也没法自动跳转头文件，第一行是当前像目录下所有，第二行是安装的Qt库的头文件路径
剩下的配置按需配置，不配置也不影响。选择编辑json可以查看C/C++插件json版本的配置
刚才配置的都在这里面了，现在引用Qt头文件已经不报错了 c_cpp_properties.json
{ "configurations": [ { "name": "Win32", "includePath": [ "${workspaceFolder}/**", "C:/Qt/5.15.2/mingw81_64/include/**" ], "defines": [ "_DEBUG", "UNICODE", "_UNICODE" ], "intelliSenseMode": "windows-gcc-x64", "compilerPath": "C:/Qt/Tools/mingw810_64/bin/g++.exe" } ], "version": 4 } 5. 配置task.json 选择终端-运行任务-配置任务-使用模板创建task.json文件-Others；这一步无所谓，就是搞个模板，用我下面贴的一样
配置编译Qt项目的task，这一步其实是跟Qt Creator相同的，我们打开Qt Creator，选择项目，查看刚才的项目的项目构建配置
Qt Creator构建步骤分析如下：
设置构建目录，也就是编译出来的中间文件目录
qmake，这一步其实是用qmake将.pro配置文件编译成makefile，并且将其中涉及的.ui、.qrc等编译成cpp，都在构建目录中，下面是切换Debug/Release时不同的qmake编译命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dcb1cc277d6641d40fb9ce900182b9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/576c2d6fdcbbd007bb7e07b1ea3679c0/" rel="bookmark">
			Android13 设置固定热点ip地址192.168.43.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android13 设置固定热点ip地址192.168.43.1 文章目录 Android13 设置固定热点ip地址192.168.43.1一、前言二、设置固定ip地址实现1、Android13 代码中的实现：添加属性写法： 2、Android11 或者更旧的代码中的实现： 三、其他1、Android 代码获连接的wifi 的 ip地址：2、获取热点的ip地址（1）adb 获取ip地址（2）Android 代码获取所有网络的ip地址和MAC地址：（3）Android 代码获取热点的 ip地址：（4）动态设置热点ip的代码？（5）热点开启流程 一、前言 Android 热点ip一般的系统都是随机生成的，地址一般是：192.168.XX.XX
如果要设置成一个固定的ip地址，就需要适配系统代码。
相关的适配代码主要都在 IpServer.java 里面。
为啥要设置固定热点ip？
一般是投屏软件需求，或者其他一些开机或者打开热点后被自动连接场景的需求。
二、设置固定ip地址实现 1、Android13 代码中的实现： release\packages\modules\Connectivity\Tethering\src\android\net\ip\IpServer.java
private boolean configureIPv4(boolean enabled) { if (VDBG) Log.d(TAG, "configureIPv4(" + enabled + ")"); if (enabled) { //以前的随机的ip地址 //mIpv4Address = requestIpv4Address(true /* useLastAddress */); //换成自定义的ip地址 mIpv4Address = new LinkAddress("192.168.43.1/24"); } 。。。。 } 就是这么简单，设置一下开启热点前请求到的ipv4地址就可以了。
从代码大致可以看到，如果未做修改的情况这里热点的默认ip是从上一次存在的热点ip，当然第一次还是随机生成的。
添加属性写法： 如果要添加属性判断设置，后期可以动态修改，那么可以设置一下prop属性。具体修改如下：
import android.os.SystemProperties; private boolean configureIPv4(boolean enabled) { if (VDBG) Log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/576c2d6fdcbbd007bb7e07b1ea3679c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf42d027a7f7f5001e9ee78459f19e6f/" rel="bookmark">
			jmeter 测试数据库的详细方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当前版本：
jmeter 5.6.3mysql 5.7.39 简介
JMeter是一个功能强大的开源性能测试工具，它被广泛用于测试Web应用程序、Web服务、API、数据库以及其他类型的应用程序。支持测试数据库的性能和可靠性，可以模拟多个并发用户对数据库执行各种不同类型的操作，例如查询、插入、更新和删除等。这篇文章主要介绍测试数据库的基本方法，压测见《jmeter 专栏》其他文章。
文章目录如下
1. jmeter 怎么测试数据库
1.1. 线程组的介绍
1.2. 数据库连接配置
1.3. 数据库业务构造
1.4. 下载依赖库
2. 测试案例
2.1. 测试读业务
2.2. 测试写业务
1. jmeter 怎么测试数据库 测试数据库与测试web程序类似，web程序的测试需要提供接口，而数据库测试则需要提供依赖库和连接串来测试。
1.1. 线程组的介绍 在学习测试数据库之前需要了解什么是线程组？
线程组是用于模拟并发用户的行为，它是一组线程的集合，每个线程代表一个虚拟用户，可以并发执行相同或不同的测试请求。
在执行过程中，每个线程独立运行，按照指定的逻辑顺序发送请求并接收响应。线程组可以指定启动和停止时间，从而控制测试的持续时间。此外，线程组还可以设置启动延迟和循环计数，以增加测试的复杂性和真实性。通过如下步骤添加：
右击测试计划 → 添加 → 线程(用户) → 线程组 串行测试通常按如下配置：
并发测试通常按如下配置：
它的整体界面由3部分组成：名称设置、异常设置、线程设置。
【第1部分】名称设置
名称：表示这一组业务的名字，比如可以修改为 "用户登录"、"用户购物"等。注释：名称用宏观的方式来写，那么注释就是把业务的一些细节写上去，便于理解。 【第2部分】异常设置
继续：无论当前取样器是否执行成功或失败，都会继续执行下一个取样器。启动下一进程循环：即使当前线程组中有其他线程在运行，也会立即启动新的线程循环。停止线程：当测试计划中有多个线程组，在停止当前线程之后，其他线程组将继续执行。停止测试：停止整个测试计划。 【第3部分】线程设置
线程数：模拟用户的并发数。接口测试一般1个就行，压测就根据情况而定。Ramp-Up时间：指定启动所有线程所需的时间。例如设置为5秒，且有10个线程，则每秒启动2个线程，直到所有线程都被启动。循环次数：每个线程循环的次数。例如设置线程2个，循环10次，那么业务就会执行20次。如果是压测的话勾选永远，再使用调度器指定测试时间。Same user on each iteration：每个迭代使用相同的用户。延迟创建线程直到需要：自动周期性控制。调度器：一般压测需要勾选调度器，指定压测的时长。 1.2. 数据库连接配置 在学习线程组后，第2步需要了解数据库怎么连接。
数据库通过配置元件中的《JDBC Connection Configuration》去连接，添加步骤如下：
右击测试计划 → 添加 → 配置元件 → JDBC Connection Configuration 配置 MySQL 示例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf42d027a7f7f5001e9ee78459f19e6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81483891201f420242e0c4749da77637/" rel="bookmark">
			Java实战：Spring Boot application.yml配置文件详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文将详细介绍Spring Boot application.yml 配置文件的使用和配置项。我们将探讨 application.yml 文件的基本概念，以及如何使用它来配置Spring Boot应用程序的各个方面。此外，我们将通过具体的示例来展示如何配置不同的Spring Boot组件，如数据源、数据库、缓存、邮件服务等。本文适合希望深入了解Spring Boot配置文件的开发者阅读。
一、引言 在Spring Boot应用程序中，application.yml 配置文件是用于配置应用程序属性的重要资源。这个文件提供了了一种简便的方式来配置Spring Boot应用程序的各种组件，如数据源、数据库、缓存、邮件服务等。本文将详细介绍 application.yml 配置文件的使用和配置项，并探讨如何使用它来配置不同的Spring Boot组件。
二、application.yml 配置文件的基本概念 1. 什么是 application.yml 配置文件？
application.yml 是一个YAML（YAML Ain’t Markup Language）格式的配置文件，它用于配置Spring Boot应用程序的各种属性。YAML是一种直观的数据序列化格式，它支持数据结构的表示，如列表、映射、字符串、整数、浮点数等。
2. application.yml 文件的作用
配置应用程序属性：application.yml 文件允许我们配置应用程序的各种属性，如服务器端口、数据库连接、缓存策略等。简化配置管理：通过使用 application.yml 文件，我们可以将应用程序的配置信息集中管理，方便维护和更新。环境隔离：application.yml 文件支持不同环境的配置，我们可以为开发环境、测试环境和生产环境创建不同的配置文件。 三、application.yml 配置文件的使用 1. 创建 application.yml 文件
在Spring Boot应用程序的资源目录下（通常是 src/main/resources），创建一个名为 application.yml 的文件。这个文件将包含应用程序的配置属性。
2. 配置数据源
在 application.yml 文件中，我们可以配置数据源的属性，如数据库类型、URL、用户名和密码等。以下是一个配置数据源的示例：
spring: datasource: url: jdbc:mysql://localhost:3306/test_db username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver 在上面的示例中，我们配置了一个MySQL数据源，包括数据库URL、用户名、密码和驱动类名。
3. 配置数据库
除了数据源配置，我们还可以在 application.yml 文件中配置数据库的属性，如数据库模式、表空间等。以下是一个配置数据库的示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81483891201f420242e0c4749da77637/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d411056fb9135c0c593c5576086c216/" rel="bookmark">
			java篇-无法访问org.springframework.boot.SpringApplication错误的类文件(图文详解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误如下
java: 无法访问org.springframework.boot.SpringApplication
错误的类文件: /C:/D/soft/Maven_Repo/org/springframework/boot/spring-boot/3.2.2/spring-boot-3.2.2.jar!/org/springframework/boot/SpringApplication.class
类文件具有错误的版本 61.0, 应为 52.0
请删除该文件或确保该文件位于正确的类路径子目录中。
解决办法：
更改springboot3.3.2版本为springboot 2.2.6.RELEASE，因为springboot3只支持jdk17以上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b294d2e4a725437a90e267b183eb3922/" rel="bookmark">
			Python pandas 对DataFrame进行遍历(持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三种用迭代器的方法(items,iterrows,itertuples)：沿着行/列对所有元素遍历，适合对每个元素进行操作简单dolumns，loc遍历：遍历每一行/列，适合对每行/列进行求和、离散等整体操作for+zip: 适合选取较少的特定行/列进行操作 之后看到其他好用方法，或者合适的拓展也会继续更新
有错误请指正，欢迎评论建议
items,iterrows,itertuples： items(): 以 (列名, Series) 对的形式遍历 DataFrame 的列。 函数原型：DataFrame.iteritems(None)
返回：返回一个迭代器，产生 （列名，列内容Series） 对的元组。
import pandas as pd data = {'A': [1, 2, 3], 'B': [4, 5, 6]} df = pd.DataFrame(data) for column, series in df.items(): print(f"Column: {column}") print(f"Series:\n{series}\n") 输出：
iterrows()：以 (行下标, Series) 对的形式遍历 DataFrame 的行。 原型：DataFrame.iterrows()
返回：返回迭代器（行号index，行内数据Series）
import pandas as pd data = {'A': [1, 2,], 'B': [4, 5,]} df = pd.DataFrame(data) for index, row in df.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b294d2e4a725437a90e267b183eb3922/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40fe76db26d4b9cb3961dda748a64e4f/" rel="bookmark">
			具身智能（Embodied AI）的概念、核心要素、难点及突破性进展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在ChatGPT之后，具身智能（Embodied AI）这个大模型概念火了，那什么是具身智能呢？
什么是具身智能？ 具身智能作为人工智能发展的一个重要分支，正在迅速崭露头角，成为科技界和大众关注的热门话题，同时在各个领域中展现出巨大的潜力和吸引力
具身智能通过在物理世界和数字世界的学习和进化，达到理解世界、互动交互并完成任务的目标。
具身智能是由“本体”和“智能体”耦合而成且能够在复杂环境中执行任务的智能系统。
以上概念是等价的：
Embodied AI = Embodied Intelligence = 具象AI = 具身智能`
Internet AI = Disembodied AI = 非具身智能
相关概念 具身（Embodiment)：指具有支持感觉和运动（sensorimotor）的物理身体。
具身的 （Embodied）：具有身体的，可参与交互、感知的。
具身智能(Embodied AI)：有身体并支持物理交互的智能体，如家用服务机器人、无人车等。 —— “身体力行”
非具身智能（Disembodied AI）：没有物理身体，只能被动接受人类采集、制作好的数据 。—— “纸上谈兵”或者说 “运筹帷幄”
具身智能机器人：满足具身智能的能力的机器人. 即具身智能机器人：首先，要能够听懂人类语言，然后，分解任务，规划子任务，移动中识别物体，与环境交互，最终完成相应任务
具身任务：像人类一样通过观察、移动、说话和与世界互动从而完成的一系列任务。
多模态：是指一个模型或系统能够处理多种不同类型的输入数据并融合它们生成输出。这些数据类型可能包括文本、图像、音频和视频等。
主动交互：机器人或智能体与环境的实时交互，从而提高智能体的学习、交流和应对问题的能力。
Internet AI从互联网收集到的图像、视频或文本数据集中学习，这些数据集往往制作精良，其与真实世界脱节、难以泛化和迁移。1）数据到标签的映射。2）无法在真实世界进行体验学习。3）无法在真实世界做出影响。
Embodied AI通过与环境的互动，虽然以第一视角得到的数据不够稳定，但这种类似于人类的自我中心感知中学习，从而从视觉、语言和推理到一个人工具象（Artificial Embodiment），可以帮助解决更多真实问题
核心要素 一般认为，具身智能具有如下的四大核心要素：
本体：作为实际的执行者，是在物理或者虚拟世界进行感知和任务执行的机构。 本体通常是具有物理实体的机器人，可以有多种形态。本体的能力边界会限制智能体的能力发挥，所以，具有广泛适应性的机器人本体是非常必要的。如四足机器人、复合机器人、人形机器人本体具备环境感知能力、运动能力和操作执行能力，是连接数字世界和物理世界的载体。 智能体（Embodied Agents），是具身于本体之上的智能核心，负责感知、理解、决策、控制等的核心工作。 智能体可以感知复杂环境，理解环境所包含的语义信息，能够和环境进行交互；可以理解具体任务，并且根据环境的变化和目标状态做出决策，进而控制本体完成任务。随着深度学习的发展，现代智能体通常由深度网络模型驱动，尤其是随着大语言模型（LLM）的发展，结合视觉等多种传感器的复杂多模态模型，已经开始成为新一代智能体的趋势。智能体也分化为多种任务形态，处理不同层次和模态的任务。智能体要能够从复杂的数据中学习决策和控制的范式，并且能够持续的自我演进，进而适应更复杂的任务和环境。智能体设计是具身智能的核心。具有通用能力的LLM和VLM等模型，赋予了通用本体强大的泛化能力，使得机器人从程序执行导向转向任务目标导向，向通用机器人迈出了坚实的步伐。 数据：“数据是泛化的关键，但涉及机器人的数据稀缺且昂贵。” 为了适应复杂环境和任务的泛化性，智能体规模变的越来越大，而大规模的模型对于海量数据更为渴求。现在的LLM通常需要web-scale级别的数据来驱动基础的预训练过程，而针对具身智能的场景则更为复杂多样，这造成了多变的环境和任务，以及围绕着复杂任务链的规划决策控制数据。尤其是针对行业场景的高质量数据，将是未来具身智能成功应用落地的关键支撑。 学习和进化架构：智能体通过和物理世界（虚拟的或真实的）的交互，来适应新环境、学习新知识并强化出新的解决问题方法。 采用虚拟仿真环境进行部分学习是合理的设计，比如英伟达的元宇宙开发平台Omniverse，就是构建了物理仿真的虚拟世界，来加速智能体的演进。真实环境的复杂度通常超过仿真环境，如何耦合仿真和真实世界，进行高效率的迁移（Sim2Real），也是架构设计的关键。 具身智能的难点剖析 需要有强大的通用本体平台：
如何解决硬件的关键零部件技术突破，形成具有优秀运动能力和操作能力的平台级通用机器人产品，将具身本体的可靠性、成本和通用能力做到平衡，是一个巨大的挑战。考虑到通用能力，人形机器人被认为是具身智能的终极形态。这方面的研发，也将持续成为热点和核心挑战。 设计强大的智能体系统
作为具身智能的核心，具备复杂环境感知认知能力的智能体，将需要解决诸多挑战，包括：物理3D环境精确感知、任务编排与执行、强大的通识能力、多级语义推理能力、人机口语多轮交互能力、long-term记忆能力、个性化情感关怀能力、强大的任务泛化与自学迁移能力等。具身智能要求实时感知和决策能力，以适应复杂和变化的环境。这要求高速的数据采集、传输和处理，以及实时的决策反应，尤其是LLM所消耗的算力规模巨大，对于资源有限的机器人处理系统将形成巨大的数据量、AI计算能力和低延迟的挑战 高质量的行业数据将成为巨大挑战
现实场景的复杂多变，使得现阶段缺乏足够的场景数据来训练一个完全通用的大模型，进而让智能体自我进化。耦合的本体，需要实际部署到真实环境中，才能够采集数据，这也是和非具身智能的明显不同。但对于关键业务，要求成功率，则仍然需要高质量的垂域数据。同时，通过层次化的智能体设计，将不同任务限定到特定领域，则是一个解决泛化和成功率的有效尝试 通过虚拟和真实的交互，持续学习和进化的能力，则是具身智能演进的重要技术途径
学习新任务来适应环境的变化，则是持续改进的动力。形态适配环境合适的智能体，则可以快速的学习到解决问题能力，进而更好的适应变化。由于形态的变化空间无穷巨大，搜索所有可能的选择在有限的计算资源情况下变的几乎不可能。本体的自由度设计，也会物理上约束智能体的任务执行能力，进而限制了控制器的学习效果。在复杂环境、形态演化和任务的可学习性之间，存在着未可知的隐式关系，如何快速学习到合理的规划和决策能力，则成为具身智能的重要一环。 2023最新突破性进展 PaLM-E: An Embodied Multimodal Language Model: 一个具身多模态语言模型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40fe76db26d4b9cb3961dda748a64e4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/417f49413d81ed151aa60f420429993d/" rel="bookmark">
			Android安卓app渗透测试环境-抓包教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 今年是2024年，刚过完春节后的第二个工作日，从去年的暑假开始入职，已经有超半年时间了，比起那时候啥都不会的小白，现在起码是懂一点的小白了，过年前的几天还因调休请假的事情给领导产生了不好的印象。啥也没有的我，不指望可以顺利转正了，只保佑可以开心的度过剩下的半年时间。根据去年的网络安全大厂的经济状况，不出意外，去年的年会草草结束和今年的开工红包都没有了，也不知道这行该怎么走下去了。不管怎样，技术还是要提升的，现如今Web层面的漏洞也越来越少，app越来越多导致这方面的安全刻不容缓，多一个技术在手，让自己不必那么早被淘汰…
由于HTTPS的单向认证和双向认证机制，导致Android 7以上的版本，系统不信任第三方安装的证书，也就是所谓的证书锁定Ssl pinning，导致我们抓取不到HTTPS的报文或者报文乱码，之前可以通过Xposed+Trustme绕过，此方法只适用于Android 7以下的版本，但由于现在的app版本越来越高也不再支持低版本的Android系统，于是就产生了本篇文章，大多数app也只采用了单向认证的方式，双向认证成本高，也可以绕过，本文只讨论单向认证方式的绕过。
环境准备 夜神模拟器Android 9版本
Magisk_v25.2 + Lsposed_1.8.6
TrustMeAlready-v1.11-release
Postern_v3.1.3
Android软件包地址：链接：https://pan.baidu.com/s/1qLP2EhHiV9rTUOJZGsOUGQ?pwd=pdxx
提取码：pdxx
安装Magisk+Lsposed 打开夜神模拟器，并添加Android 9版本
直接将Magisk的这两个安装包拖入夜神模拟器中，会自动安装
然后上传Magisk安装包到指定路径，后面需要通过路径进行安装
打开Magisk 鸭，并根据以下步骤依次输入命令
输入m然后回车
输入Y然后回车
进入以下界面，选择允许超级用户请求并永久记住选择
然后回到命令行界面
输入1然后回车
输入x然后回车
输入刚刚上传的Magisk安装包路径：也就是：/sdcard/Pictures/25206.apk
输入路径后回车
输入1然后回车，看到重启模拟器界面
关掉模拟器的开启root模式，不然会与magisk的root冲突，重启
去掉勾选即为关闭
打开magisk，看到版本号，则表示magisk安装成功
点击右上角的设置，划到此处开启Zygisk，为后续安装Lsposed做准备
像拖入magisk安装包的方式拖入Lspose的zip压缩包，并会将此压缩包保存在/storage/emulated/0/Pictures这个文件夹中
点击模块，并从本地安装模块
找到/storage/emulated/0/Pictures这个路径，并选中Lsposed压缩包文件
看到此界面表示安装成功，然后重启，最好是将当前Android 9模拟器重启，不要直接点击下面的重启按钮
重启后，像往下划出菜单即可看到Lsposed加载出来
通知栏 点开（如果没显示，可以通过拨号键输入 ##5776733##** 进入LSPosed）
要想显示app图标可以直接拖入Lsposed.apk到模拟器
安装JustTrustme+Postern 为什么要安装这玩意？
JustTrustme是用来绕过HTTPS的证书锁定
Postern是用来绕过代理检测，有些app检测你是否使用代理则直接关闭
最后是检测是否使用模拟器，这种的话使用真机吧，然后刷magisk+Lsposed。目前不检测的话还是可以应付一下的
安装JustTrustme，直接拖入安装包就行了，so easy！
打开LSPosed，就可以直接看到成功安装JustTrustme模块了
拖入Postern安装包，即可安装成功
模拟器安装burp证书 查看当前ip信息，这个根据实际情况查看填写，具备一定的网络基础知识
模拟器设置成桥接，并设置一个静态ip，保存重启
模拟器进入设置，并点击WLAN，长按wifi即可弹出以下修改网络界面（可能需要取消保存网络）
输入刚才填入的静态ip
然后真机ping一下模拟器的ip查看是否成功
真机打开brup，设置一下监听的ip和端口号
模拟器打开Postern，然后配置代理服务器如下，代理服务器设置为burp的地址和端口，保存
配置规则如下，匹配所有
接下来就是下载burp证书了，不知道为啥模拟器通过浏览器访问burp的代理端口显示无法访问。
只能通过真机下载证书后直接拖入模拟器中了，其实这也是最快的
拖入模拟器的证书路径为/storage/emulated/0/Pictures，和安装Lsposed的原理是一样的
真机下载的好处就是可以直接将der后缀修改为cer后缀后再拖入会比较方便，一定要将der修改为cer后缀
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/417f49413d81ed151aa60f420429993d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c981badc2e1072c3c797d0b5e9bea14f/" rel="bookmark">
			numpy，matplotlib，python的版本对应（implement_array_function method already has a docstring报错）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**********写在前面*********
在我们开始之前，先把numpy，matplotlib卸载干净（同一个包可能会装两个不一样版本），所以同一句卸载指令我们要执行到找不到这个包为止（%%%%%%-----重要------%%%%%）
pip uninstall numpy pip uninstall matplotlib 接下来上干货
https://matplotlib.org/devdocs/devel/min_dep_policy.html
该链接查看三者版本对应关系
直接上图
然后我用的是conda环境，使用如下代码
conda install numpy conda install matplotlib 他会自己匹配对应的版本，结束
（补充--第二版）
我发现有些时候numpy和matplotlib无论什么版本都会冲突，这件事发生在这篇博客第一版发表后的几天，困扰了我好久，我用的是tensorflow的深度学习框架用来图像识别，所以同时下载了pytorch，这三个库由于某种原因关系交织在一起非常乱，所以我直接把matplotlib卸了不再使用，
原先的报错语句
from matplotlib import transforms 我改成了下面的
from torchvision import transforms 发现也能用，果断删掉matplotlib，后来我找到了其他方法，我就放弃这条路了，结果非常成功（也可能bug在后面等我）
本站持续更新，我不用matplotlib了这篇博客out了，后续号上可能会分享些其他的深度学习内容，本人24届苦逼大四生，毕设ing..........《基于tensorflow的XX识别系统》加油！！！！
-----------------------------------------------------------------------------------------------------------------------
（补充--第三版）
在使用如下语句时发生报错（已安装matplotlib==3.7）
import matplotlib.pyplot as plt 提示没有pyplot库，以为又是版本兼容的问题，在anaconda中和prompt中又卸载了一次，看到某博主说是3.X版本的原因让降到2.X版本，结果虚拟环境不让装（在不改变之前其他库版本的条件下），于是又重装了对应版本的matplotlib（在conda虚拟环境中），结果重启pycharm后没报错了，估计又是引导什么的问题，大家遇到同样的问题可以和我一样试试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33eba9355e2235ebe67325ea7d492894/" rel="bookmark">
			AIGC专栏9——Scalable Diffusion Models with Transformers （DiT）结构解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AIGC专栏9——Scalable Diffusion Models with Transformers （DiT）结构解析 学习前言源码下载地址网络构建一、什么是Diffusion Transformer (DiT)二、DiT的组成三、生成流程1、采样流程a、生成初始噪声b、对噪声进行N次采样c、单次采样解析I、预测噪声II、施加噪声 d、预测噪声过程中的网络结构解析i、adaLN-Zero结构解析ii、patch分块处理iii、Transformer特征提取iv、上采样 3、隐空间解码生成图片 类别到图像预测过程代码 学习前言 近期Sora大火，它底层是Diffusion Transformer，本质上是使用Transformer结构代替原本的Unet进行噪声预测，好处是统一了文本生成与视频生成的结构。这训练优化和预测优化而言是个好事，因为只需要优化一种结构就够了。虽然觉得OpenAI是大力出奇迹，但还是得学！
源码下载地址 https://github.com/bubbliiiing/DiT-pytorch
喜欢的可以点个star噢。
网络构建 一、什么是Diffusion Transformer (DiT) DiT基于扩散模型，所以不免包含不断去噪的过程，如果是图生图的话，还有不断加噪的过程，此时离不开DDPM那张老图，如下：
DiT相比于DDPM，使用了更快的采样器，也使用了更大的分辨率，与Stable Diffusion一样使用了隐空间的扩散，但可能更偏研究性质一些，没有使用非常大的数据集进行预训练，只使用了imagenet进行预训练。
与Stable Diffusion不同的是，DiT的网络结构完全由Transformer组成，没有Unet中大量的上下采样，结构更为简单清晰。
本文主要是解析一下整个DiT模型的结构组成，并简单一次扩散，多次扩散的流程。本文代码来自于Diffusers，Diffusers代码较为简单清晰，是一个非常好的仓库，学习起来也比较快。
二、DiT的组成 DiT由三大部分组成。
1、Sampler采样器。
2、Variational Autoencoder (VAE) 变分自编码器。
3、UNet 主网络，噪声预测器。
每一部分都很重要，由于DiT的官方版本并没有在 大规模文本图片 的 数据集上训练，只使用了imagenet进行预训练。所以它并没有文本输入，而是以标签作为输入。因此，DiT只能按照类别进行图片生成，可以生成imagenet中的1000类
三、生成流程 生成流程分为两个部分：
1、生成正态分布向量后进行若干次采样。
2、进行解码。
由于DiT只能按照类别进行图片生成，所以无需对文本进行编码，直接传入类别的对应的id（0-1000）即可指定类别。
# --------------------------------- # # 前处理 # --------------------------------- # # 生成latent latents = randn_tensor( shape=(batch_size, latent_channels, latent_size, latent_size), generator=generator, device=self._execution_device, dtype=self.transformer.dtype, ) latent_model_input = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33eba9355e2235ebe67325ea7d492894/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/496/">«</a>
	<span class="pagination__item pagination__item--current">497/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/498/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>