<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85843b2ae2821bdc057ec0837959ffa8/" rel="bookmark">
			vscode不能进行go跳转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 辗转反侧，弄了好久好久终于出山了
总结：跟vscode版本插件有关
老版本vscode DocsTool修改成godoc 新版本vscode go get golang.org/x/tools/gopls@latest setting中 "go.useLanguageServer": true, "[go]": { "editor.snippetSuggestions": "none", "editor.formatOnSave": true, "editor.codeActionsOnSave": { "source.organizeImports": true } }, "gopls": { "usePlaceholders": true, // add parameter placeholders when completing a function "completionDocumentation": true // for documentation in completion items }, "files.eol": "\n", // formatting only supports LF line endings 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ede125a818f98810a38df0d291bebf3b/" rel="bookmark">
			Linux基础 （十五）：TCP 协议特点和UDP协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一节，我们学习了TCP协议的服务器-客户端的编程流程以及对中间的过程进行了详细的讨论，那么，这一节，我们对于TCP协议的特点进行进一步的分析，这也是面试的重点和难点。
目录
一、TCP 协议特点
1.1 连接的建立与断开
1.1.1 面试题
1.2 TCP 状态转移（面试题）
1.3 流式服务特点
1.4 应答确认与超时重传
1.5 滑动窗口
二、多进程、多线程处理并发 三、UDP协议
3.1 UDP协议编程流程
3.2 UDP 协议特点
3.3 应用场景
四、面试题
4.1 TCP和UDP的区别
4.2 同一个端口可不可以被一个 TCP 和一个 UDP 的应用程序同时使用？
4.3 同一个应用程序可以创建多个套接字吗？
一、TCP 协议特点 通过前面的学习，我们知道：TCP 协议提供的是：面向连接、可靠的、字节流服务。
1.1 连接的建立与断开 使用 TCP 协议通信的双发必须先建立连接（三次握手），然后才能开始数据的读写。双方都必须为该连接分配必要的内核资源，以管理连接的状态和连接上数据的传输。TCP 连接是全双工的，双方的数据可以通过一个连接进行读写。完成数据交换之后，通信双方都必须断开连接以释放系统资源（四次挥手）。 使用 tcpdump 抓包命令可以抓包观察 TCP 连接的建立与关闭。该命令需要管理员权限，格式如下(假设两个测试用的主机 IP 地址为 192.168.43.214 和 192.168.43.160 ) ：
三次握手发生在客户端执行 connect()的时候，该方法返回成功，则说明三次握手已经建 立。三次握手示例图如下：
客户端执行connect（）会给服务器发送一个tcp报文，此时SYN标志有效，还会发送一个序列号；服务器收到报文，会发送报文回复，此时SYN有效，发送一个序列号，还回复会一个确认号是客服端发送的序列号+1；客服端收到服务器的回复，也会再次回复服务器，此时会发送确认号是刚刚客户端发送的序列号+1 ；
四次挥手发生在客户端或服务端执行 close()关闭连接的时候，示例图如下：
当一端要进行close（），会给对方发送一个报文，此时FIN标志有效，还有一个序列号，然后对方收到报文，会回复对方已经收到了，发送一个确认号ACK，是刚刚发送的序列号+1；然后另一端也要close（）关闭，也会给对方发送报文告诉对方字节要关闭了，FIN 序列号，对方收到报文了，会回复对方已经收到了，也发送一个确认号ACK，确认号是刚刚发送的序列号+1。
1.1.1 面试题 1、四次挥手的过程可以用三次完成吗？ 可以，四次挥手可以演化成三次挥手 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ede125a818f98810a38df0d291bebf3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be091f81be8f08ebdd24e7b44d7e7f3a/" rel="bookmark">
			Android Studio项目升级报错：Namespace not specified
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原项目升级AGP到8.0+时报错：
Namespace not specified. Specify a namespace in the module's build file: C:\Users\Administrator\Desktop\MyJetpack\app\build.gradle. See https://d.android.com/r/tools/upgrade-assistant/set-namespace for information about setting the namespace. Android Studio版本是:
根目录中的gradle\wrapper\gradle-wrapper.properties:
#Wed Jun 12 18:06:29 CST 2024 distributionBase=GRADLE_USER_HOME distributionPath=wrapper/dists distributionUrl=https\://services.gradle.org/distributions/gradle-8.6-bin.zip zipStoreBase=GRADLE_USER_HOME zipStorePath=wrapper/dists 根目录中的build.gradle:
// Top-level build file where you can add configuration options common to all sub-projects/modules. buildscript { repositories { google() jcenter() } dependencies { // AGP升级到 8.4.2 了 classpath 'com.android.tools.build:gradle:8.4.2' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be091f81be8f08ebdd24e7b44d7e7f3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f485d0d8d2c69f9672f0e11784ee65e5/" rel="bookmark">
			C#开源软件：OneNote组件oneMore轻松打造自己的公众号编辑器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 OneMore是一款为Microsoft OneNote设计的插件，它提供了许多扩展功能来增强OneNote的使用体验。
插件功能概述： OneMore插件拥有多达一百多个扩展功能，这些功能覆盖了笔记编辑、搜索、导出等多个方面，为用户提供了更加便捷和高效的使用体验。
主要特点： 免费开源：OneMore是一款免费且开源的插件，用户可以自由使用并根据需要进行定制。
功能丰富：该插件提供了多种实用功能，如目录生成、Word导出、图片文字搜索等，大大增强了OneNote的功能性。
易于使用：OneMore插件与OneNote紧密集成，用户可以通过简单的操作即可使用插件提供的各种功能。
具体功能介绍： 搜索功能：OneMore插件提供了强大的搜索功能，支持全匹配搜索，并且可以搜索图片上的文字，这对于需要从大量笔记中快速查找信息的用户来说非常有用。
文件导出：用户可以通过OneMore插件将OneNote笔记导出为Word、PDF等格式，方便与其他人共享或进行打印。
目录生成：插件支持自动生成笔记目录，方便用户快速浏览和定位笔记内容。
自定义工具栏：如果觉得打开某些功能的路径麻烦，可以将这些功能添加到“快速访问工具栏”，从而更方便地使用。
公众号文章编辑： 借助OneMore插件，可以直接从OneNote页面复制内容至微信公众号编辑器，同时确保格式完美无损。这款插件提供了丰富的排版工具，包括大小标题设置、文本格式化、编辑样式定制、图片处理优化以及代码高亮显示等，在OneNote中轻松创建并编辑内容，然后一键同步至微信公众号，实现高效的内容管理与发布。
源码及运行程序下载地址: https://github.com/xuanwujian/OneMore 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8d280bdc187367a56a78ab71d8dd884/" rel="bookmark">
			详解 Flink Table API 和 Flink SQL 之时间特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍 Table API 和 SQL 进行基于时间的操作（比如时间窗口）时需要定义相关的时间语义和时间数据来源的信息。因此会给表单独提供一个逻辑上的时间字段，专门用来在表处理程序中指示时间时间属性（time attributes），其实就是每个表模式结构（schema）的一部分。它可以在创建表的 DDL 里直接定义为一个字段，也可以在 DataStream 转换成表时定义。一旦定义了时间属性，就可以作为一个普通字段引用，并且可以在基于时间的操作中使用时间属性的数据类型为 TIMESTAMP，类似于常规时间戳，可以直接访问并且进行计算。按照时间语义的不同，可以把时间属性的定义分成事件时间（event time）和处理时间（processing time） 二、处理时间定义 /** 处理时间既不需要提取时间戳，也不需要生成 watermark */ public class TestTableProcessingTime { public static void main(String[] args) throws Exception { StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); env.setParallelism(1); StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env); /* 方式一：在 DataStream 转化时直接指定 注意： 1.使用 .proctime，定义处理时间字段 2.proctime 属性只能通过附加逻辑字段，来扩展物理 schema。因此，只能在 schema 定义的末尾定义 */ DataStream&lt;String&gt; inputStream = env.readTextFile("./sensor.txt"); DataStream&lt;SensorReading&gt; dataStream = inputStream.map(line -&gt; { String[] fields = line.split(","); return new SensorReading(fields[0], new Long(fields[1]), new Double(fields[2])); }); Table sensorTable = tableEnv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8d280bdc187367a56a78ab71d8dd884/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08c341f09af4f37177f3793792cd0625/" rel="bookmark">
			ESP32 IDF ADF 加入音频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要把mp3制作成音频bin
用ADF自带工具
果用户需要生成自己的 audio-esp.bin，则需要执行 mk_audio_bin.py 脚本（位于 $ADF_PATH/tools/audio_tone/mk_audio_tone.py），并且指定相关文件的路径。
源 MP3 文件在 tone_mp3_folder 文件夹中，生成的 C 文件、H 文件以及二进制 bin 文件都存放在此目录下。
python3 $ADF_PATH/tools/audio_tone/mk_audio_tone.py -f ./ -r tone_mp3_folder mp3文件放到mytone_mp3_folder
执行
python mk_audio_tone.py -f ./ -r mytone_mp3_folder 将后面两个生成的资源文件也件加入
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/129ec1efe5dad0ccde5694fd58f83fa2/" rel="bookmark">
			Java 泛型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，3种泛型方式：泛型类、泛型接口、泛型方法 泛型类 //此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型 //在实例化泛型类时，必须指定T的具体类型 public class Generic&lt;T&gt;{ private T key; public Generic(T key) { this.key = key; } public T getKey(){ return key; } } 泛型接口 public interface Generator&lt;T&gt; { public T next(); } // 实现泛型接口时，可以传入或者不传实际类型： public class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt; public class FruitGenerator implements Generator&lt;String&gt; 泛型方法 // 只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法 // 此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型 public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass) { T instance = tClass.newInstance(); return instance; } 静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 public class StaticGenerator&lt;T&gt; { public static &lt;T&gt; void show(T t){ } } 泛型方法中添加上下边界的时候，必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加。 // 编译器会报错 public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container) public &lt;T extends Number&gt; T showKeyName(Generic&lt;T&gt; container){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/129ec1efe5dad0ccde5694fd58f83fa2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb76d06fb84d1d2035e4933cfa29711e/" rel="bookmark">
			如何在 Windows 上安装 MySQL（保姆级教程2024版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL 是最流行的数据库管理系统 (DBMS) 之一。它轻量、开源且易于安装和使用，因此对于那些刚开始学习和使用关系数据库的人来说是一个不错的选择。 本文主要系统介绍Windows的环境下MySQL的安装过程和验证过程。
目录
1 安装过程
1.1 前置要求
1.2 下载并安装
1.3 配置
1.4 最后步骤
2 使用 SQLynx 创建第一个数据库
3 概括
虽然对于初学者来说它是个不错的选择，但 MySQL 也足够强大，可以支持更大规模的生产应用程序，并且支持多用户和多线程。
以下我们将介绍在本地 Windows 计算机上安装 MySQL 的过程，从下载到创建和使用第一个数据库。
完成后，您将拥有一个功能齐全的 MySQL 服务器，可在本地运行并随时使用。在最后也使用了SQLynx验证产品的运行是否成功，当然也可以使用软件自带的MySQL workbench来进行测试。
1 安装过程 让我们直入主题。在 Windows 上安装 MySQL 是一个非常简单但漫长的过程。在本文中，我们将逐步介绍如何使用 MySQL 安装程序进行安装，这是数据库文档推荐的方法。
首先，您需要下载安装程序。单击此处，选择与您的操作系统兼容的版本（32 位或 64 位），然后点击Download。请注意，您还可以选择 Web 安装程序或离线安装程序。后者更重，而前者的下载速度会更快。 当您尝试开始下载时，网站会要求您登录或创建帐户，但您不必这样做。请注意按钮No thanks, just start my download。
当你打开安装程序时，它将首先配置安装，然后请求用户的权限才能继续：
完成后，我们终于可以看到安装程序界面了。如下图所示，该过程包括四个步骤：
选择安装类型下载文件安装软件完成安装 第一步中有五种类型的设置可用，您可以勾选侧面的框来查看每种设置将安装哪些内容。但是，我们强烈建议您选择默认选项，尤其是如果您刚开始使用 SQL。
此安装程序将安装的最重要的功能包括：
MySQL 服务器：数据库服务器本身MySQL Workbench：用于管理服务器的应用程序适用于 Visual Studio 的 MySQL：此功能使用户能够从 Visual Studio 使用 MySQL文档和教程 选择完整安装也是可以的，因为这将安装所有可用的 MySQL 资源。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb76d06fb84d1d2035e4933cfa29711e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2ec03cc9c65e5abcb0812f79c3e9dc2/" rel="bookmark">
			【JavaEE进阶】——利用框架完成功能全面的图书管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
🚩项目所需要的技术栈
🚩项目准备工作
🎈环境准备
🎈数据库准备
🚩前后端交互分析
🎈登录
📝前后端交互
📝实现服务器代码
📝测试前后端代码是否正确
🎈添加图书
📝前后端交互
📝实现服务器代码
📝测试前后端代码是否正确
🎈图书列表
📝前后端交互
📝实现服务器代码
📝测试前后端代码是否正确
🎈修改图书
📝前后端交互
📝实现服务器代码 📝测试前后端代码是否正确
🎈删除图书
📝约定前后端交互接⼝
📝实现服务器代码 📝测试前后端代码是否正确
🎈批量删除图书
📝约定前后端交互接⼝
📝实现服务器代码 📝测试前后端代码是否正确
🚩项目所需要的技术栈 该项目是一个针对于SpringBoot+Mybatis+SpringMVC的基础运用项目适合初学者来检验水平测试能力，该项目所需技术栈如下：
&gt;* SpringBoot：作为项目的框架，使用Maven托管代码
&gt;* Mybatis：使用Mybatis框架操纵数据库，其中使用了xml和注解两种方式去操作数据库
&gt;* 前端ajax：前后端的交互使用的是ajax作为前端为后端发送数据以及接收数据
&gt;* 项目分层：项目分为前端页面+control（与前端建立连接的控制层）+Service(服务层供control层进行调用)+Mapper（操纵数据库实现数据与后端代码的 交互）+model(需要实现的主类)。
🚩项目准备工作 🎈环境准备 项目的创建需要选好项目名，项目路径，语言为java，type是基于maven构建，jdk可以选择17以上的(切记最好不要用jdk8)，packing是打成jar包。
此时项目创建成功。MySQL Driver和MyBatis Framework引⼊MyBatis 和 MySQL驱动依赖
也可以手动引入依赖，上面只是更简单。
这是围绕整个项目的配置文件，没有该配置文件，是无法运行成功的，没有它们你就完成不了一个项目。我们依赖该pom.xml文件，让我们能完成该项目。
SpringBookt配置文件,统一使用yml格式 application.yml
很多项⽬或者框架的配置信息也放在配置⽂件中, ⽐如: • 项⽬的启动端⼝ • 数据库的连接信息(包含⽤⼾名和密码的设置) • ⽤于发现和定位问题的普通⽇志和异常⽇志等 server: port: 8080 #配置数据库 spring: datasource: url: jdbc:mysql://127.0.0.1:3306/book_system?characterEncoding=utf8&amp;useSSL=false username: root password: driver-class-name: com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2ec03cc9c65e5abcb0812f79c3e9dc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98579a1ffd0a145765ee92e7b289211a/" rel="bookmark">
			undetected_chromedriver驱动浏览器结束报错OSError: [WinError 6] 句柄无效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		undetected_chromedriver驱动浏览器结束报错OSError: [WinError 6] 句柄无效
问题背景
使用undetected_chromedriver包驱动浏览器结束后报错句柄无效
Exception ignored in: &lt;function Chrome.del at 0x000001DD50F07A60&gt;
Traceback (most recent call last):
File “D:\WorkSpace\py_project\beyondmenu-getdata-new\venv\Lib\site-packages\undetected_chromedriver_init_.py”, line 847, in del
File “D:\WorkSpace\py_project\beyondmenu-getdata-new\venv\Lib\site-packages\undetected_chromedriver_init_.py”, line 798, in quit
OSError: [WinError 6] 句柄无效。
问题原因
当打开未检测到的 chromedriver 的进程完成时，会触发此错误
参考官网issues
解决方案
目前官方已经提issues但没有合并到正式分支，所以需要修改源码
undetected_chromedriver_init_.py文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4d9ff5e59877160c0b6742308bc794e/" rel="bookmark">
			探索C嘎嘎的奇妙世界:第三关---缺省参数与函数重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在c语言中,我们常常在对有参函数进行传参,这样的繁琐过程,C++祖师爷对此进行了相关改进,多说无益,上干货:
1 缺省参数: 缺省参数是指在声明或定义函数时为函数的形参指定一个默认值（默认参数）。在调用该函数时，如果没有指定实参，则采用该形参的缺省值；否则使用指定的实参。缺省参数主要分为两种类型:全缺省参数和半缺省参数
1.1 全缺省参数: 全缺省参数是指函数的所有参数都具有默认值。以下是一个全缺省参数的示例代码：
// 全缺省 void F2(int a = 10, int b = 20, int c = 30) { cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; "c = " &lt;&lt; c &lt;&lt; endl &lt;&lt; endl; } int main() { F2(1, 2, 3); F2(1, 2); F2(1); F2(); return 0; } 在上述代码中,我们会发现,有所不同的是在形参的位置上,我们给予了赋值,这样写又什么作用呢?唉~这样写当我们在调用的时候,少给参数的时候,编译器也不会报错,会自动给上默认值.同时也可以多种方式调用函数了.比如在上述代码中:F2(1,2,3)这样的调用时,上面形参的默认值就不会起作用了,而当我们F2(1,2)这样传参的时候,也不会报错,这是编译器会把a和b的值变为,1和2,而c的值就使用我们给的默认参数进行赋值30.同理可以去理解后两个调用,也可以一个都不传哦,这样形参用的全是我们所给的默认值.
1.2 半缺省参数: 半缺省参数是指从右往左连续地为函数的部分参数提供默认值。以下是一个半缺省参数的示例代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4d9ff5e59877160c0b6742308bc794e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c868f54e0ac37166106b48ef38c1a9f/" rel="bookmark">
			【MySQL】数据库介绍|数据库分类|MySQL的基本结构|MySQL初步认识|SQL分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
数据库介绍
什么是数据库
数据库分类
1.关系型数据库（RDBMS）：
2.非关系型数据库：
MySQL要学啥
MySQL初步认识
SQL分类
💡推荐
前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。【点击跳转到网站】
数据库介绍 什么是数据库 数据库,其实是一类软件,要做的事情,也是对数据进行高效的组织而且实现数据库软件的过程中,内部就会用到很多的数据结构的东西
数据库分类 数据库大体可以分为 关系型数据库 和 非关系型数据库
1.关系型数据库（RDBMS）： 是指采用了关系模型来组织数据的数据库。 简单来说，关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织，每一行都是一条数据，每一行都包含很多列，每个列还会有不同的类型
数据库中的所有数据，列数/类型/含义都要能够匹配
基于标准的SQL，只是内部一些实现有区别。常用的关系型数据库如：
（1）Oracle：甲骨文产品，适合大型项目，适用于做复杂的业务逻辑，如ERP、OA等企业信息系统。收费
（2） MySQL：属于甲骨文，不适合做复杂的业务。开源免费
（3） SQL Server：微软的产品，安装部署在windows server上，适用于中大型项目。收费
（4）SQLite：非常轻量级的数据库，整个只有1M左右大小的可执行程序，这个程序特别适合于一些配置比较低的设备进行使用，尤其是移动设备（手机）
2.非关系型数据库： 对于数据的格式上的要求比较松散，往往都是按照键值对/文档的形式来进行组织的，性能较关系型数据库更高，而且更适合在分布式的场景中使用
（了解）不规定基于SQL实现。现在更多是指NoSQL数据库，如：
（1）基于键值对（Key-Value）：如 memcached、redis
（2）基于文档型：如 mongodb
（3）基于列族：如 Hbase
（4）基于图型：如 neo4j
关系型数据库与非关系型数据库的 区别：
关系型数据库非关系型数据库使用SQL是不强制要求，一般不基于SQL实现事务支持支持不支持复杂操作支持不支持海量读写操作效率低效率高基本结构基于表和列，结构固定灵活性比较高使用场景业务方面的OLTP系统（联机事务处理）用于数据的缓存、或基于统计分析的OLAP系统（联机分析处理） MySQL要学啥 1.SQL 语句的使用（编程语言）
SQL本质上是一个"编程语言”,专门用来操作数据库的编程语言(和 Java,C++之类的画风上差别非常大)
SQL是各个数据库之间通用的,各种数据库使用的语言都是 SQL(结构化的查询语言)
熟悉了 SOL 各种数据库都可以很容易上手了
2.MySQL 内部的一些基础原理(常见面试题)
只是根据面试题,见招拆招的介绍一些原理,应付面试有余,但是不够系统
💡3.针对数据库进行编程
通过 Java 来操作数据库(这个过程中也是会用到 SQL)
MySQL初步认识 MySQL 是一个"客户端-服务器"结构的程序
（1）客户端(client)主动发起请求的一方
（2）服务器(server)被动接受请求的一方（本质上就是一台电脑，只是配置更高，性能更强）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c868f54e0ac37166106b48ef38c1a9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e077d2649d61dae0eb9193d1ada8259b/" rel="bookmark">
			Python Web 前后端分离 后台管理系统 Django&#43;vue（完整代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前后端分离的架构
在前后端分离的架构中，前端和后端分别作为独立的项目进行开发和部署。前端项目通过API与后端项目进行通信。
前端：使用Vue.js构建用户界面，调用后端提供的RESTful API获取和发送数据。后端：使用Django构建API，处理业务逻辑和数据存储 2.创建django项目及vue项目
创建app的时候需要进入项目的目录下 win10 cd xmmc
django-admin startproject xmmc django-admin startapp app01 以管理员身份打开命令行界面，进入任意一个想要创建项目的文件夹
vue create vueproject 然后按自己的需求选择，可以去专门搜一下创建vue的教程
3.配置setting
（1）配置数据库
DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', # 加载mysql引擎 'NAME': 'db_goods', # 数据库名称 'USER': 'root', # mysql账户名 'PASSWORD': '123456', # mysql账户密码 'PORT': 3306, # 端口号 'HOST': 'localhost' } } （2）配置模板文件
TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates')], 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e077d2649d61dae0eb9193d1ada8259b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/feaae1cf7846b74355efc38fe0542727/" rel="bookmark">
			Hadoop 2.0：主流开源云架构（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 四、Hadoop 2.0体系架构（一）Hadoop 2.0公共组件Common（二）分布式文件系统HDFS（三）分布式操作系统Yarn（四）Hadoop 2.0安全机制简介 四、Hadoop 2.0体系架构 （一）Hadoop 2.0公共组件Common 1、Common定位
Common的定位是其他模块的公共组件，定义了程序员取得集群服务的编程接口，为其他模块提供公用API。降低Hadoop设计的复杂性，减少了其他模块之间的耦合性，增强了Hadoop的健壮性。
2、Common功能
提供公用API和程序员编程接口本地Hadoop库（Native Hadoop Library）超级用户superuser服务级别认证HTTP认证 （二）分布式文件系统HDFS 1、HDFS定位
为提高扩展性，HDFS采用了master/slave架构来构建分布式存储集群，这种架构很容易向集群中任意添加或删除slave。
2、HDFS体系架构
（1）HDFS架构
HDFS采用master/slave体系来构建分布式存储服务，提高了HDFS的可扩展性又简化了架构设计。HDFS里将文件分块存储，优化存储颗粒度。namenode统一管理所有slave机器datanode存储空间，datanode以块为单位存储实际的数据。真正的文件I/O操作时客户端直接和datanode交互。
NameNode是主控制服务器，负责维护文件系统的命名空间（Namespace），协调客户端对文件的访问，记录命名空间内的任何改动或命名空间本身的属性改动。DataNode负责它们所在的物理节点上的存储管理，HDFS开放文件系统的命名空间。NameNode执行文件系统的命名空间操作，决定数据块到DataNode的映射。
客户端要访问一个文件。首先，客户端从NameNode获得组成文件的数据块的位置列表；其次，客户端直接从DataNode上读取文件数据。
NameNode使用事务日志（EditLog）记录HDFS元数据的变化，使用映象文件（FsImage）存储文件系统的命名空间。事务日志和映象文件都存储在NameNode的本地文件系统中。将新的元数据刷新到本地磁盘的新的映象文件中，这样可以截去旧的事务日志，这个过程称为检查点（Checkpoint）。HDFS还有Secondary NameNode节点，它辅助NameNode处理映象文件和事务日志。NameNode更新映象文件并清理事务日志，使得事务日志的大小始终控制在可配置的限度下。
（2）HDFS典型拓扑
① 一般拓扑：只有单个NameNode节点，使用SecondaryNameNode或BackupNode节点实时获取NameNode元数据信息，备份元数据。
② 商用拓扑：有两个NameNode节点，并使用ZooKeeper实现NameNode节点间的热切换。
ZooKeeper集群：至少三个ZooKeeper实体，用来选举ActiveNamenode。JourNalNode集群：至少三个，用于与两NameNode交换数据，也可使用NFS。HTTPFS：提供Web端读写HDFS功能。 从架构上看HDFS存在单点故障，无论是一般拓扑还是商用拓扑，新增的实体几乎都是增强NameNode可靠性的组件，当然这里的ZooKeeper集群还可以用于Hbase。
3、HDFS内部特性
（1）冗余备份
HDFS将每个文件存储成一系列数据块（Block），默认块大小为64MB（可配置）。为了容错，文件的所有数据块都会有副本（副本数量即复制因子，可配置）。HDFS的文件都是一次性写入的，并且严格限制为任何时候都只有一个写用户。
（2）副本存放
HDFS集群一般运行在多个机架上，不同机架上机器的通信需要通过交换机。HDFS采用机架感知（Rack-aware）的策略来改进数据的可靠性、可用性和网络带宽的利用率。机架的错误远比节点的错误少，这个策略可以防止整个机架失效时数据丢失，提高数据的可靠性和可用性，又能保证性能。
（3）副本选择
HDFS会尽量使用离程序最近的副本来满足用户请求，这样可以减少总带宽消耗和读延时。HDFS的架构支持数据均衡策略。
（4）心跳检测
NameNode周期性地从集群中的每个DataNode接受心跳包和块报告，收到心跳包说明该DataNode工作正常。NameNode会标记最近没有心跳的DataNode为宕机，不会发给它们任何新的I/O请求。NameNode会不断检测这些需要复制的数据块，并在需要的时候重新复制。
（5）数据完整性检测
多种原因可能造成从DataNode获取的数据块有损坏。HDFS客户端软件实现了对HDFS文件内容的校验和检查（Checksum）。DataNode获得的数据块对应的校验和隐藏文件中的不同，客户端就会判定数据块有损坏，将从其他DataNode获取该数据块的副本。
（6）元数据磁盘失效
映象文件和事务日志是HDFS的核心数据结构。NameNode可以配置为支持维护映象文件和事务日志的多个副本。任何对映象文件或事务日志的修改，都将同步到它们的副本上。当NameNode重新启动时，总是选择最新的一致的映象文件和事务日志。
（7）简单一致性模型、流式数据访问
HDFS的应用程序一般对文件实行一次写、多次读的访问模式。文件一旦创建、写入和关闭之后就不需要再更改了。这样就简化了数据一致性问题，高吞吐量的数据访问才成为可能；运行在HDFS上的应用主要以流式读为主，做批量处理；更注重数据访问的高吞吐量。
（8）客户端缓存
客户端创建文件的请求不是立即到达NameNode，HDFS客户端先把数据缓存到本地的一个临时文件，程序的写操作透明地重定向到这个临时文件。当这个临时文件累积的数据超过一个块的大小（64MB）时，客户端才会联系NameNode。如果NameNode在文件关闭之前死机，那么文件将会丢失。如果不采用客户端缓存，网络速度和拥塞都会对输出产生很大的影响。
（9）流水线复制
当客户端准备写数据到HDFS的文件中时，数据一开始会写入本地临时文件。DataNode从前一个节点接收数据的同时，即时把数据传给后面的节点，这就是流水线复制。
（10）架构特征
硬件错误是常态而不是异常。HDFS被设计为运行在普通硬件上，所以硬件故障是很正常的。错误检测并快速自动恢复是HDFS的最核心设计目标。
（11）超大规模数据集
一般企业级的文件大小可能都在TB级甚至PB级，HDFS支持大文件存储，而且提供整体上高的数据传输带宽。一个单一的HDFS实例应该能支撑数以千万计的文件，并且能在一个集群里扩展到数百个节点。
4、HDFS对外功能
（1）NameNode高可靠性
（2）HDFS快照
（3）HDFS快照
（4）HDFS安全性
（5）HDFS配额功能
（6）HDFS C语言接口
（7）HDFS Short-Circuit功能
（8）WebHdfs
（三）分布式操作系统Yarn 1、定位
分布式操作系统的基本功能：管理计算机资源，提供用户接口。Yarn一方面管理整个集群的计算资源（CPU、内存等），另一方面提供用户程序访问系统资源的API。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/feaae1cf7846b74355efc38fe0542727/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50aacc4126a74fad4a1b5877d3d657b7/" rel="bookmark">
			# RocketMQ 实战：模拟电商网站场景综合案例（六）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RocketMQ 实战：模拟电商网站场景综合案例（六） 一、RocketMQ 实战 ：项目公共类介绍 1、ID 生成器 ：IDWorker：Twitter 雪花算法。 在 shop-common 工程模块中，IDWorker.java 是 ID 生成器公共类，运用 Twitter 雪花算法，自动生成项目 ID，而不会存在重复现象。
package com.itheima.utils; public class IDWorker { /** * 起始的时间戳 */ private final static long START_STMP = 1480166465631L; /** * 每一部分占用的位数 */ private final static long SEQUENCE_BIT = 12; //序列号占用的位数 private final static long MACHINE_BIT = 5; //机器标识占用的位数 private final static long DATACENTER_BIT = 5;//数据中心占用的位数 /** * 每一部分的最大值 */ private final static long MAX_DATACENTER_NUM = -1L ^ (-1L &lt;&lt; DATACENTER_BIT); private final static long MAX_MACHINE_NUM = -1L ^ (-1L &lt;&lt; MACHINE_BIT); private final static long MAX_SEQUENCE = -1L ^ (-1L &lt;&lt; SEQUENCE_BIT); /** * 每一部分向左的位移 */ private final static long MACHINE_LEFT = SEQUENCE_BIT; private final static long DATACENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT; private final static long TIMESTMP_LEFT = DATACENTER_LEFT + DATACENTER_BIT; private long datacenterId; //数据中心 private long machineId; //机器标识 private long sequence = 0L; //序列号 private long lastStmp = -1L;//上一次时间戳 public IDWorker(long datacenterId, long machineId) { if (datacenterId &gt; MAX_DATACENTER_NUM || datacenterId &lt; 0) { throw new IllegalArgumentException("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50aacc4126a74fad4a1b5877d3d657b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc5c6316a0be45ef19aa0cf7b39cf008/" rel="bookmark">
			java设计模式和面向对象编程思想
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java设计模式和面向对象编程思想是软件开发中的核心概念，对于构建可维护、可扩展的软件系统至关重要。下面是对这两个主题的知识点总结：
面向对象编程（OOP）思想 封装：将数据（属性）和操作这些数据的方法（行为）封装在一起，隐藏内部实现细节，仅通过公共接口与外部交互。这有助于减少代码间的耦合度，提高模块化。
继承：允许创建分层次的类结构，子类可以继承父类的属性和方法，并可添加或覆盖它们。这支持代码复用，增强了软件的可扩展性。
多态：同一接口可以被不同的类以不同方式实现，即子类可以根据需要覆盖父类的方法。多态提高了代码的灵活性和可维护性。
抽象：通过抽象类或接口来定义对象的基本形态和行为，不关注具体实现。抽象让程序员专注于对象的接口而非其实现细节。
面向对象编程（Object-Oriented Programming, OOP）是一种编程范式，强调将程序设计中的各种要素封装进对象中，通过对象的交互来设计和实现应用程序。OOP的核心思想主要围绕以下几个基本原则：
1. 封装（Encapsulation） 封装是将对象的状态（数据成员/属性）和行为（成员方法/函数）捆绑在一起，并对外界隐藏其内部实现细节的过程。通过设置访问权限（如Java中的public、private、protected），可以控制对对象内部数据的直接访问，从而保护数据的完整性，减少错误，并增强模块间的独立性。
2. 继承（Inheritance） 继承允许一个类（子类/派生类）继承另一个类（父类/基类）的属性和方法，实现代码的复用。子类可以继承父类的所有非私有属性和方法，并可以增加或重写父类的方法以适应更具体的需求。这有助于建立类的层次结构，促进软件的模块化设计。
3. 多态（Polymorphism） 多态意味着一个接口可以有多种实现方式，或者一个类实例的相同消息可以产生多种响应。在Java等面向对象语言中，多态主要通过方法重写（Override）和接口实现来体现。它使得代码更加灵活和可扩展，因为可以在运行时根据对象的实际类型来决定调用哪个方法，而不是在编译时确定。
4. 抽象（Abstraction） 抽象是指将复杂的系统分解为更简单的组成部分，关注关键特性和行为，忽略不必要的细节。在OOP中，抽象类或接口用来定义一个或多个类的共同属性和操作，但不提供具体实现。抽象类不能被实例化，其目的是为了被子类继承。接口则完全由抽象方法组成，强制实现类遵循某种规范或协议。
实践中的应用 模块化：通过封装和抽象，将复杂系统分解为小的、相互独立的模块，便于管理和维护。代码复用：继承减少了重复代码，提高了开发效率和代码质量。灵活性与扩展性：多态和抽象使得系统容易适应变化，增加新功能或修改现有功能时不会对整个系统造成太大影响。设计模式：许多经典的设计模式（如单例、工厂、策略等）都是基于OOP原则，用于解决特定设计问题，提升软件设计的优雅性和健壮性。 综上所述，面向对象编程思想通过封装、继承、多态和抽象四大原则，促进了软件的模块化、灵活性、可维护性和代码复用，是现代软件开发不可或缺的基础。
Java设计模式 设计模式是在特定情境下解决常见设计问题的标准化解决方案。它们分为三大类：创建型、结构型和行为型模式。
Java设计模式是软件开发中解决常见设计问题的通用解决方案，分为三大类：创建型、结构型和行为型模式。以下是这些模式的详细知识点总结：
创建型模式（Creational Patterns） 单例模式（Singleton）
目的：确保一个类只有一个实例，并提供一个全局访问点。实现：使用私有构造函数、静态私有实例和公开的静态方法确保只创建一个对象。 工厂方法模式（Factory Method）
目的：定义一个用于创建对象的接口，但让子类决定实例化哪一个类。实现：声明一个用于创建对象的接口，让子类决定具体的类。 抽象工厂模式（Abstract Factory）
目的：为创建一组相关或相互依赖的对象提供一个接口，而无需指定它们的 concrete 类。实现：定义接口用于创建一系列相关或相互依赖的对象，而不需要指定它们的具体类。 建造者模式（Builder）
目的：将复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。实现：使用Builder类逐步构建产品对象，Director负责管理构建过程。 原型模式（Prototype）
目的：通过复制现有的实例来创建新的对象，以减少创建新对象的成本。实现：实现Cloneable接口，重写clone()方法以深拷贝或浅拷贝对象。 结构型模式（Structural Patterns） 适配器模式（Adapter）
目的：将一个类的接口转换为客户期望的另一个接口，使原本不兼容的类可以一起工作。实现：创建一个适配器类，继承或组合原有类，并实现目标接口。 桥接模式（Bridge）
目的：将抽象部分与实现部分分离，使它们可以独立变化。实现：定义抽象类和实现类，通过组合而非继承来实现二者之间的松耦合。 装饰器模式（Decorator）
目的：动态地给一个对象添加一些额外的职责，而不改变其结构。实现：创建装饰器类，包装原有的对象，并可以添加额外的行为。 组合模式（Composite）
目的：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。实现：定义Component接口，声明操作，Composite类实现Component并管理子组件。 外观模式（Facade）
目的：为子系统中的一组接口提供一个一致的高层接口，简化客户端与子系统的交互。实现：创建一个Facade类，该类提供了简化的方法来调用子系统中的复杂操作。 享元模式（Flyweight）
目的：运用共享技术有效地支持大量细粒度的对象。实现：创建Flyweight类存储共享状态，客户端通过Factory获取Flyweight对象，外部状态由客户端维护。 行为型模式（Behavioral Patterns） 观察者模式（Observer）
目的：定义对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。实现：Subject（被观察者）维护Observer（观察者）列表，状态改变时通知所有观察者。 模板方法模式（Template Method）
目的：定义一个操作中的算法骨架，而将一些步骤延迟到子类中实现。实现：在父类中定义模板方法，具体步骤留给子类去实现。 策略模式（Strategy）
目的：定义一系列算法，将每一个算法封装起来，并使它们可以互相替换。实现：定义策略接口，具体策略类实现接口，Context使用策略。 迭代器模式（Iterator）
目的：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。实现：定义Iterator接口，聚合类实现创建Iterator的方法。 责任链模式（Chain of Responsibility）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc5c6316a0be45ef19aa0cf7b39cf008/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d63d9c83a9d25afcc4bfdf443c97d46f/" rel="bookmark">
			Mysql中使用where 1=1有什么问题吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天偶然看见一篇文章，提到说如果在mysql查询语句中，使用where 1=1会有性能问题？？
这着实把我吸引了，因为我项目中就有不少同事，包括我自己也有这样写的。为了不给其他人挖坑，赶紧学习一下，这样写sql到底有没有性能问题？
where 1=1的使用场景 我们来看下，where 1=1实际是怎么使用的， 先来看一段SQL
&lt;select id="selectCmsCourseList" parameterType="java.util.Map" resultMap="CourseMap"&gt; SELECT a.id, a.category_id, a.model_id, b.* FROM cms_content a LEFT JOIN cms_course b ON a.id = b.id WHERE 1=1 &lt;if test="courseName != null and courseName != ''"&gt; AND b.course_name like concat(concat("%",#{courseName}),"%") &lt;/if&gt; &lt;if test="disabled != null"&gt; AND a.disabled = #{disabled} &lt;/if&gt; &lt;if test="categoryId != null"&gt; AND a.category_id = #{categoryId} &lt;/if&gt; &lt;/select&gt; 如果用过mybatis的童鞋，看到这段代码应该很熟悉了吧，这里使用where 1=1的作用，就是为了方便后面的条件，能通过if判断，使用AND连接起来，这样即使后面if全部是false，没有参数，这个sql也不会报错。
where 1=1的替换方案 其实上面的这个写法，如果用mybatis，完全可以用where标签来替换,如：
&lt;select id="selectCmsCourseList" parameterType="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d63d9c83a9d25afcc4bfdf443c97d46f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e332f0276643cce14bf2ef32b57e173e/" rel="bookmark">
			map 详细解析 Java 8 Stream API 中的 map 方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		详细解析 Java 8 Stream API 中的 map 方法
没有耐心可直接阅读标题三的示例
Java 8 引入的 Stream API 提供了一种高效处理集合数据的方法。map 方法是 Stream API 中的一个重要中间操作，用于将流中的元素转换为其他形式或类型。它通过一个 Function 接口的实现，将流中的每个元素应用一个函数，并将结果收集到一个新的流中。
一、map 方法的定义 map 方法的定义如下：
&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); 这个方法接受一个 Function 类型的参数，即一个将流中每个元素转换为另一种形式的函数，并返回一个包含转换后元素的新流。
二、map 方法的使用场景 map 方法广泛应用于以下场景：
数据转换：将流中的元素转换为另一种形式。数据处理：对流中的元素应用特定的处理逻辑。 三、map 方法的示例 以下是一些 map 方法的使用示例，展示其在数据转换和处理中的应用。
3.1 数据转换 假设有一个包含字符串的列表，我们希望将每个字符串转换为大写形式。
List&lt;String&gt; strings = Arrays.asList("apple", "banana", "cherry"); List&lt;String&gt; upperCaseStrings = strings.stream() .map(String::toUpperCase) .collect(Collectors.toList()); System.out.println("Upper Case Strings: " + upperCaseStrings); 输出结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e332f0276643cce14bf2ef32b57e173e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02db5298fcade5b29b3cdc0a1ae1379d/" rel="bookmark">
			HBase中Master初始化错误~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ERROR：org.apache.hadoop.hbase.PleaseHoldException:Master is initializing
1、停止HBase运行
2、启动zookeeper中的zkCli.sh服务
./zookeeper/bin/zkCli.sh 3、执行完毕显示以下结果,删除habse文件夹
4、重新启动HBase即可。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c68563a845d5a53df0048056762d9469/" rel="bookmark">
			【C&#43;&#43; | 左值、右值】一文了解C&#43;&#43;的左值、右值、左值引用(&amp;)、右值引用(&amp;&amp;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😁博客主页😁：🚀https://blog.csdn.net/wkd_007🚀
🤑博客内容🤑：🍭嵌入式开发、Linux、C语言、C++、数据结构、音视频🍭
⏰发布时间⏰：2024-06-12 16:35:55
本文未经允许，不得转发！！！
目录 🎄一、概述🎄二、左值(lvalue)🎄三、右值(rvalue)🎄四、左值引用🎄五、右值引用(rvalue reference)✨5.1 右值引用的理解✨5.2 std::move 🎄六、总结 🎄一、概述 左值、右值、左值引用、右值引用，这几个概念常常在C++编程中出现，如果没弄清楚这几个概念的意思，有时会在看一些C++书籍时会感到特别困惑。
左值和右值是表达式的属性。一些表达式生成或要求左值，而另外一些则生成或要求右值。一般而言，一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值。
左值、右值最初是出现在C语言中的，左值最初指的是可出现在赋值语句左边的实体，引入了const关键字之后，常规变量和 const 变量都可视为左值， 因为可通过地址访问它们，但常规变量属于可修改的左值， 而 const 变量属于不可修改的左值。右值一般是没有明确的内存位置，无法使用&amp;获取地址，值不可被修改。例如：立即数、常量、字面值、&amp;(变量)。
在C++中，增加了引用的概念，所以会出现左值引用、右值引用，下文将举例说明这几个概念。
🎄二、左值(lvalue) 左值：英文简写为“lvalue”，是“locator value”的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据。
左值：本质上是可以操作的一块内存区域，一般可以通过&amp;取到该内存起始地址，这块内存的值可以被修改(const对象除外)。除了const对象的其他左值都可以出现在赋值语句左边。
常见的左值有：
1、变量(对象)；
2、const 变量(对象)；
3、对指针解引用，*(指针)；
4、数组元素，a[1]；
5、结构体成员、类成员，s.m_a、ps-&gt;ma；
// g++ 13_lvalue.cpp int main() { int i = 0;	i = 1;	// i是变量(对象)，左值 const int ci = 5;	//ci = 6;	// ci是const变量(对象)，是左值但不能出现在赋值号左边 int *pi = &amp;i; *pi = 1;	// *pi 对指针解引用，左值 int arr[5] = {0,}; arr[0] = 1;	// arr[0] 是数组元素，左值 struct { int m_a; int m_b; } st, *pst=&amp;st; st.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c68563a845d5a53df0048056762d9469/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/275/">«</a>
	<span class="pagination__item pagination__item--current">276/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/277/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>