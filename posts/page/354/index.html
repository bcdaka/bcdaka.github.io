<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="编程大咖的博客">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程大咖">

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9225649407fb57cf1a9cb0c97681360/" rel="bookmark">
			路径规划 | 图解A*、Dijkstra、GBFS算法的异同(附C&#43;&#43;/Python/Matlab仿真)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 0 专栏介绍1 栅格地图与邻域2 贪婪最佳优先搜索3 Dijkstra算法4 启发式A*搜索5 A*、Dijkstra、GBFS算法的异同6 算法仿真与实现6.1 算法流程6.2 ROS C++实现6.3 Python实现6.4 Matlab实现 0 专栏介绍 🔥附C++/Python/Matlab全套代码🔥课程设计、毕业设计、创新竞赛必备！详细介绍全局规划(图搜索、采样法、智能算法等)；局部规划(DWA、APF等)；曲线优化(贝塞尔曲线、B样条曲线等)。
🚀详情：图解自动驾驶中的运动规划(Motion Planning)，附几十种规划算法
1 栅格地图与邻域 搜索(Search)是指从初始状态(节点)出发寻找一组能达到目标的行动序列(或称问题的解)的过程。
在图搜索中，往往将环境简化为栅格地图(Grid Map)，易于刻画固定场景，同时也便于计算机控制系统进行信息处理。所谓栅格就是将连续地图用固定大小正方形方格进行离散化的单位。
在栅格地图中，常见的邻域(neighbor)模式如下所示，即
8邻域24邻域48邻域 栅格的邻域表示了从当前位置出发下一次搜索的集合，例如八邻域法中，当前栅格只能和周围的八个栅格相连形成局部路径。
下面是一个图搜索问题的例子，可以直观理解什么是搜索问题。
例1：在如下的栅格地图中，设绿色栅格为起点，红色栅格为终点，灰色栅格为障碍，白色栅格为可行点，问如何设计一条由栅格组成的连接起点、终点的路径，并尽可能使路径最短？
接下来，围绕这个问题展开阐述。
2 贪婪最佳优先搜索 一个朴素的想法是：每一次搜索时就找那些与终点最近的节点，这里衡量最近可以用多种度量方式——曼哈顿距离、欧式距离等。这种方法像一头狼贪婪地望着食物，迫切寻求最近的路径，因此称为贪婪最佳优先搜索(Greedy Best First Search, GBFS)。
假设采用八邻域法，在GBFS思想指导下，在起点的八邻域中就会选择最右侧的节点，如下所示。
循环地，直到如下所示的节点，因为邻域内有障碍，这些障碍节点不会被候选，所以此时离终点最近的就是下方的方格
依次类推直至终点
3 Dijkstra算法 Dijkstra算法走向了另一个极端，它完全不考虑扩展节点与终点的关系，而是定义了一个路径耗散函数 g ( n ) g(n) g(n)，从起点开始，机器人每走一个栅格就会产生一定的代价或耗散，因为Dijkstra算法希望路径最短，所以每次首选那些使路径耗散最小的节点。
依照Dijkstra算法的观点，从起点开始，其八个邻域节点都会被依次探索，因为它们离起点最近，接着再探索这些节点的子节点。
因此Dijkstra算法会遍历大量的节点，一圈圈地逼近终点
4 启发式A*搜索 A*算法是非常有效且常用的路径规划算法之一，其是结合Dijsktra算法与GBFS各自优势的启发式搜索算法，其搜索代价评估函数为
f ( n ) = g ( n ) + h ( n ) f(n)=g(n)+h(n) f(n)=g(n)+h(n)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9225649407fb57cf1a9cb0c97681360/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd76602b843542b5332280c68c852987/" rel="bookmark">
			【数据结构】排序（一）—— 希尔排序（思路演进版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、常见的排序算法分类
二、常见排序算法的实现 2.1插入排序
2.1.1直接插入排序
基本思想
思路
step1.单趟控制
step2.总体控制 代码实现
测试
特性总结
2.1.2 希尔排序( 缩小增量排序 )
基本思想
思路演进
🌈1.代码实现单组排序（以红色组为例）
🌈2.加入控制多组排序的代码
🌈3.对上面代码修改 ，一组一组排 改为 多组并排！！！
🌈4.最后考虑，如何控制gap?
最终代码实现
测试
特性总结
三、结语
一、常见的排序算法分类 二、常见排序算法的实现 2.1插入排序 2.1.1直接插入排序 基本思想 直接插入排序是一种简单的插入排序法，其基本思想是：
把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为 止，得到一个新的有序序列 。
思路 step1.单趟控制 先考虑单趟排序，暂时不考虑区间到底是从哪到哪 ，先抽象为[0,end]
假设[0,end]是有序的区间 a[end+1] 插入到 [0,end]中
❓具体如何插入：
下标是end+1的元素依次跟[0,end]区间中的元素作比较：
end+1先跟end比 再跟 end-1比较......依次往下
①如果a[end+1]&lt;a[end] 以排升序为例子 ，那么a[end]就往后挪动 也就是往后覆盖
②如果a[end+1]&gt;a[end] ,那么就停止比较 ，a[end+1] 插入到 [0,end]中
❓思路落实到代码：
用临时变量tmp 先保存a[end+1]，最终插入的位置也是a[end+1]
step2.总体控制 接下来考虑如何控制[0,end]区间大小的变化：
❓执行过程描述：
初始时 区间元素个数肯定只有一个，
也就是end = 0 ，区间[0,0]有序，只有一个元素a[0],然后a[1]往里插入，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd76602b843542b5332280c68c852987/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d45850dd70dbdfabf8a3d0332c96a7a/" rel="bookmark">
			Python常见数据类型处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数据类型分类 Python3 中常见的数据类型有：
Number（数字）String（字符串）bool（布尔类型）List（列表）Tuple（元组）Set（集合）Dictionary（字典） Python3 的六个标准数据类型中：
**不可变数据（3 个）：**Number（数字）、String（字符串）、Tuple（元组）；
**可变数据（3 个）：**List（列表）、Dictionary（字典）、Set（集合）。
基本
Number（数字）String（字符串） 多字段
List（列表）Tuple（元组）Dictionary（字典）Set（集合） #	List（列表） my_list = [0, 1, 2, 3, 4, 5, 6, 7, 8] # Tuple（元组）（值不能修改） my_tuple = (1, 2, 3, 4) # Dictionary（字典） my_info = {'name': '张三', 'age': 18, 'address': '北京市'} # Set（集合） set01 = {1, 2, 3, 4} 二、基本数据类型 1、Number（数字） Python3 支持 int、float、bool、complex（复数）。在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。像大多数语言一样，数值类型的赋值和计算都是很直观的。内置的type()函数可以用来查询变量所指的对象类型。Python可以同时为多个变量赋值，如a, b = 1, 2。一个变量可以通过赋值指向不同类型的对象。数值的除法包含两个运算符：/ 返回一个浮点数，// 返回一个整数。在混合计算时，Python会把整型转换成为浮点数 &gt;&gt;&gt; 5 + 4 # 加法 9 &gt;&gt;&gt; 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d45850dd70dbdfabf8a3d0332c96a7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2801a817dbe6df2465c5cb5b20a94fe1/" rel="bookmark">
			数据中台-大数据技术之一文说清如何选择Spark和Flink
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【数据分析小兵】专注数据中台产品领域,覆盖开发套件,包含数据集成、数据建模、数据开发、数据服务、数据可视化、数据治理相关产品以及相关行业的技术方案的分享。对数据中台产品想要体验、做二次开发、关注方案资料、做技术交流的朋友们，可以关注我。
大家好，我是数据分析小兵，小兵今天为大家介绍Flink及Spark两种大数据处理引擎的概念、特点与不同，本文重点是针对计算模式（流计算、批计算）和容错机制两个重要特性，尝试通过通俗易懂的文字举例分析，来讲清楚在什么情况下适合选择Flink和Spark。
01Spark VS Flink概述 Apache Spark ,是一个统一的、快速的分布式计算引擎，能够同时支持批处理与流计算，充分利用内存做并行计算，官方给出Spark内存计算的速度比MapReduce快100倍。因此可以说作为当下最流行的计算框架，Spark已经足够优秀了。
Apache Flink 是一个分布式大数据计算引擎，是一个Stateful Computations Over Streams，即数据流上的有状态的计算，被定义为下一代大数据处理引擎，发展十分迅速并且在行业内已有很多最佳实践。
02Spark VS Flink发展历史 Spark由加州大学伯克利分校AMPLab于2009年启动，并于2010年成立Apache开源基金会。Spark的目标是解决Hadoop的瓶颈问题，通过内存计算和数据分片处理等方法提高大数据处理的效率和性能。2014 年 2 月，Spark 成为 Apache 的顶级项目。
Flink是Apache软件基金会的一个顶级项目，是为分布式、高性能、随时可用以及准确的流处理应用程序打造的开源流处理框架，并且可以同时支持实时计算和批量计算。Flink起源于Stratosphere 项目，该项目是在2010年到2014年间由柏林工业大学、柏林洪堡大学和哈索普拉特纳研究所联合开展的，开始是做批处理，后来转向了流计算。
2014年12月，Flink项目成为Apache软件基金会顶级项目。目前，Flink是Apache软件基金会的5个最大的大数据项目之一，在全球范围内拥有350多位开发人员，并在越来越多的企业中得到了应用。在国外，优步、网飞、微软和亚马逊等已经开始使用Flink。在国内，包括阿里巴巴、美团、滴滴等在内的知名互联网企业，都已经开始大规模使用Flink作为企业的分布式大数据处理引擎。
03Spark VS Flink技术栈 3.1Spark技术栈 支持从多种数据源获取数据，包括Kafk、Flume、Twitter、ZeroMQ、Kinesis 以及TCP sockets，从数据源获取数据之后，可以 使用诸如map、reduce、join和window等高级函数进行复杂算法的处理。最后还可以将处理结果 存储到文件系统，数据库和现场 仪表盘。在“One Stack rule them all”的基础上，还可以使用Spark的其他子框架，如集群学习、图计算等，对流数据进行处理。
3.2Flink技术栈 Flink与Spark类似，同样提供了多种编程模型，从流计算到批处理，再到结构化数据处理以及机器学习、图计算等。
lDataStreamAPl DataSetAP!:这是Fink核心的编程模型，这两套AP!分别面向流处理与批处理，是构建在有状态流处理以及Runtime之上的高级抽象，供大部分业务逻辑处理使用。
lTabIe API&amp; SQL: Table API&amp; SQL是以DataStream AP!和 DataSetAP!为基础面向结构化数据处理的高级抽象，提供类似于关系型数据库的Table和SQL查询功能，能够简单方便的操作数据流。
lCEP:是DataStream APl/DataSetAPI的另一个高级抽象，是一个面向复杂事件处理的库。
lFlinkML:Flink机器学习库，批处理API的高级封装，提供可扩展的ML算法、直观的API和工具。
lGelly:Flink图计算的库，也是在批处理API基础上做的一层封装，提供了创建、转换和修改图的方法以及图算法库。
04Spark VS Flink技术特点 4.1Spark特点： l高性能，与 Hadoop 的 MapReduce 相比，Spark 基于内存的运算要快 100 倍以上，基于硬盘的运算也要快 10 倍以上。Spark 实现了高效的 DAG 执行引擎，可以通过基于内存来高效处理数据流。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2801a817dbe6df2465c5cb5b20a94fe1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62e7d3be6e0e4f2ce0ed657f9474b7b9/" rel="bookmark">
			【数据结构】树-堆的详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.树的概念
树的相关概念：
结点的度：
叶结点或终端结点：
非终端结点或分支结点：
双亲结点或父结点：
孩子结点或子结点：
兄弟结点：
树的度：
结点的层次：
树的高度或深度：
堂兄弟结点：
结点的祖先：
子孙：
森林：
二叉树的概念
堆的概念
大堆，小堆概念 堆的实现
堆的底层逻辑：动态数组 初始化和销毁 堆的插入 堆的删除 堆的判空和取堆的顶数据
整体代码及测试： 1.树的概念 在学习了解堆之前，我们需要来了解树，堆是树中的一种特殊情况。 可能我们听到树这个名字时，脑海中就会不由自主的浮现一颗树的形状，树作为数据结构的一环，它的，模型就像是一颗倒着的树一样的结构，每个节点存放着我们需要的数据，示例图如下：
树的相关概念： 结点的度： 如图所示，节点的度指的就是该节点所连接的其他节点个数，图中A节点的度为6，B节点的度为3 叶结点或终端结点： 叶结点或终端结点又称作叶子，就像一颗树上的叶子一样，后续没有枝干延升了，树中的叶子节点指的就是那些度为0的节点。
非终端结点或分支结点： 指的就是那些度不为0的节点
双亲结点或父结点： 如图，A为父亲的话，那么B,C,D,E,F,G都是它的孩子
孩子结点或子结点： 指的就是B,C,D,E,F,G
兄弟结点： 树的度： 以树中节点度中的最大一个为树的度，如图树中A节点的度最大为6，那么树的度就是为6
结点的层次： 从根开始定义起，根为第1层，根的子结点为第2层，以此类推
树的高度或深度： 树中结点的最大层次； 如上图：树的高度为4
堂兄弟结点： 双亲在同一层的结点互为堂兄弟；如上图：H、I互为兄弟结点
结点的祖先： 从根到该结点所经分支上的所有结点；如上图：A是所有结点的祖先
子孙： 以某结点为根的子树中任一结点都称为该结点的子孙。如上图：所有结点都是A的子孙
森林： 由m（m&gt;0）棵互不相交的树的集合称为森林
二叉树的概念 二叉树是树中特殊的一种，它的每一个父亲节点的孩子都不会超过两个。
二叉树不存在度大于2的结点二叉树的子树有左右之分，次序不能颠倒，因此二叉树是有序树 以下又是二叉树的各种情况： 满二叉树：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是 ，则它就是满二叉树。完全二叉树：完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。 要注意的是满二叉树是一种特殊的完全二叉树。 堆的概念 堆就属于满二叉树或者完全二叉树的一种，堆的底层实现可以通过顺序存储或者链式存储，本次我们实现的是顺序存储。那么一个堆在底层的顺序存储又是什么样子的呢，看下图。
通过上图我们又可以了解如何使用每一个父亲节点去计算孩子节点：
左child = parent * 2 + 1 右child = parent * 2 + 2 通过孩子计算父亲节点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62e7d3be6e0e4f2ce0ed657f9474b7b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7557b5c02dabc7ac1e3fac2308c8f54b/" rel="bookmark">
			初始Java篇（JavaSE基础语法）（8）认识String类（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找往期文章包括但不限于本期文章中不懂的知识点：
个人主页：我要学编程(ಥ_ಥ)-CSDN博客
所属专栏：JavaSE
接上文 初始Java篇（JavaSE基础语法）（8）认识String类（上）-CSDN博客
目录
字符串截取
其他操作方法
字符串的不可变性 字符串修改
StringBuilder和StringBuffer
刷题练习
387.字符串中第一个唯一字符 HJ1 字符串最后一个单词的长度 125.验证回文串
字符串截取 从一个完整的字符串之中截取出部分内容。可用方法如下：
方法功能String substring(int beginIndex)从指定索引的位置截取到结尾String substring(int beginIndex, int endIndex)截取部分内容（从beginIndex位置到endIndex位置） 注意:
1. 索引从0下标开始。
2. 注意前闭后开区间的写法。substring(0, 5) 表示从0下标开始截取，一直到4下标，即[0,5) 。
示例： 其他操作方法 方法功能String trim()去掉字符串中的左右空格,保留中间空格 示例：
字符串的不可变性 String是一种不可变对象。字符串中的内容是不可改变。字符串不可被修改。下面就是String的源码：
这里可能会有小伙伴会说是因为value数组被 final 修饰了，因此这个数组的内容就不可变了，也就是说这个数组里面存放的字符就不可修改了。
其实不然，这个final修饰的数组，只是让这个数组名，也就是数组对象的引用不能被修改了，并不是说这个数组的内容不能被修改了。
例如：
final修饰引用类型表明该引用变量不能去引用其他对象了，但是其引用对象中的内容是可以修改的。 那既然如此，是什么不能让我们修改String的内容呢？其实是 private 修饰的整个数组。如果我们想要修改这个数组内容首先得拿到这个数组吧，但是 private 修饰就直接导致我们拿不到这个数组。因此我们就根本没有机会去修改这个数组。这也就是 String 不可修改的原因。
那可能小伙伴又有疑惑了：既然不能修改String，那前面我们学习的拆分字符串，字符串大小写转换……这些不都改变了字符串本身吗？这只是我们看到的表面现象。所有涉及到可能修改字符串内容的操作都是创建一个新对象，改变的是新对象 。这样我们每一次涉及修改字符串的操作都是创建一个新的对象。
为什么 String 要设计成不可变的?(不可变对象的好处是什么?) （目前简单了解）
1. 方便实现字符串对象池. 如果 String 可变, 那么对象池就需要考虑写时拷贝的问题了。
2. 不可变对象是线程安全的。 3. 不可变对象更方便缓存 hash code, 作为 key 时可以更高效的保存到 HashMap 中.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7557b5c02dabc7ac1e3fac2308c8f54b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e513b4e0eaf5da21fa8155ad5162f81/" rel="bookmark">
			MySQL的基本操作 新建数据库的基本操作、新建表格基本操作、插入数据insert的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新建数据库的基本操作 创建数据库 create database 数据库名 charset utf8;
例如:创建了一个叫java1的数据库,设置该数据库的默认字符集为utf8
打印所有数据库 show databases;
将mysql里所有的数据库都打印出来,包括个人创建和系统自带的
删除数据库(工作上慎重,删了可能就寄了) drop 数据库名;
使用数据库 use 数据库名;
接下来表操作就是在你的数据库中进行的,必须先用一个
表操作 创建表 create table 表名(列名1 列类型1, 列名2 列类型2 , 列名3 列类型3......);
例:创建一个购买表,包含订单号,客户号,商品号,购买数量
打印表字段(列)的详情信息 desc 表名;
例:打印刚刚的购买表的字段(列)的详情信息,对应包括
字段名字段的数据类型是否允许NULL值字段的键信息（如主键、唯一键等）默认值额外的信息（如自增等） 删除表(慎重操作) drop 表名;
打印所有表名 show tables;
会打印当前数据库下所有表名
对表的插入数据 单行插入 insert into 表名values(列1对应数据,列2对应数据......);
打印表内详情数据 select * from person;
指定列插入-单列插入 insert into 表名 (列名)values(数据);
例:insert into person (id)values(100);
将100插入到id列中
指定列插入-单列插入 Insert into 表名 (列1,列2,列3...) values(列1数据,列2数据,列3数据);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e513b4e0eaf5da21fa8155ad5162f81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fed830bc0a359633472aa9f0fc7813e6/" rel="bookmark">
			解决spring boot启动出现Unable to start ServletWebServerApplicationContext due to missing ServletWebServer*
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错原因 今天拉下了一个新的spring boot工程，启动时出现了Unable to start web server; nested exception is org.springframework.context.ApplicationContextException: Unable to start ServletWebServerApplicationContext due to missing ServletWebServerFactory bean.这个异常。在网上搜索这个错误，有几种说法。
说法一：是因为缺少一个spring-boot-starter-web依赖。检查pom文件，发现这个依赖已经被引入了，所以不是这个问题。
说法二：是没有添加@EnableAutoConfiguration这个注解。但是在启动类中已经有@SpringBootApplication这个注解了，这个注解已经包含了@EnableAutoConfiguration注解，所以也不是这个原因，那么到底是什么原因呢。
发现问题 可见是在调用getWebServerFactory()方法时候发生错误，没有找到ServletWebServerFactory这个bean，说明在sping容器启动时没有将其注册进去，缺少相关依赖。没有对应的servelt容器，工程当然也就启动不起来。这里多讲一下，springboot工程会通过@EnableAutoConfiguration这个注解去拉去默认配置，该注解通过@Import注解导入了AutoConfigurationImportSelector类。其实这个类，就是导入通过加载配置文件，加载了很多工厂方法的配置类。最终会加载 META-INF/spring.factories这些文件，通过这些文件完成自动装配。@Import注解加载了tomcat，jetty，undertow三个web服务器的配置类。由于没有导入jetty和undertow的相关jar包，这两个类实例的不会真正的加载。到这里分析，为什么会缺少相应的servlet容器？springboot不默认加载了tomcat容器吗，因为tomcat的相关jar包已经在spring-boot-starter-web中引入了，按照之前我们的分析，实际上被加载的容器应该是tomcat，为什么还会找不到呢？
那么此时我们要分析一下整个工程的依赖情况，看tomcat相关jar包是否被真实的引入。使用mvn dependency:tree命令，对工程进行依赖分析，定位到居然无tomcat相关依赖。
此时可以发现pom.xml文件中，居然把tomcat排除了，那我排除的去掉即可：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 解决方法 去掉排除设置：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!-- &lt;exclusions&gt;--&gt; &lt;!-- &lt;exclusion&gt;--&gt; &lt;!-- &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;--&gt; &lt;!-- &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;--&gt; &lt;!-- &lt;/exclusion&gt;--&gt; &lt;!-- &lt;/exclusions&gt;--&gt; &lt;/dependency&gt; 将pom中的&lt;exclusions&gt;&lt;/exclusions&gt;或者整个注释掉，重新编译测试和运行。重新启动工程，启动成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/894e9a636a2debbe34a6af481b5da3d6/" rel="bookmark">
			llama.cpp 转化 huggingface 模型失败 解决路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： ./main -m ./models/book_q4_K_M -n 128
报错：
terminate called after throwing an instance of 'std::out_of_range' what(): unordered_map::at
解决方案： python convert.py models/llama3-8B/ --vocab-type bpe
报错：
Found vocab files: {'spm': None, 'bpe': PosixPath('models/llama3-8B/vocab.json'), 'hfft': PosixPath('models/llama3-8B/tokenizer.json')} Loading vocab file PosixPath('models/llama3-8B/vocab.json'), type 'bpe' Vocab info: &lt;BpeVocab with 128000 base tokens and 256 added tokens&gt; Special vocab info: &lt;SpecialVocab with 280147 merges, special tokens {'bos': 128000, 'eos': 128009, 'pad': 128009}, add special tokens unset&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/894e9a636a2debbe34a6af481b5da3d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ec34efe3ccc782982562f0650cdbd4b/" rel="bookmark">
			Mac电脑远程桌面连接工具：Microsoft Remote Desktop for Mac 正式版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Microsoft Remote Desktop是微软公司开发的一款功能强大的远程桌面连接工具。这款软件支持跨平台操作，用户可以在Windows、macOS、iOS以及Android等设备上轻松实现远程连接和控制。
功能特点：
下载地址：https://www.macz.com/mac/1004.html?id=OTI2NjQ5Jl8mMjcuMTg2LjguMjQx
远程访问Windows：用户可以从Mac、iOS或Android设备上访问远程Windows设备，运行Windows应用程序，处理Windows文件，并享受与本地设备相似的使用体验。 多个连接和会话管理：支持同时连接和管理多个远程会话，用户可以轻松切换和管理不同的远程Windows设备。 高性能图形传输：提供高性能的图形传输功能，使得在远程会话中运行图形密集型应用程序时能够获得流畅的体验。 安全连接：远程桌面连接通过SSL进行加密，确保数据在传输过程中的安全性。此外，Microsoft Remote Desktop还提供了网络层身份验证、数据加密和多重身份验证等安全功能，保障用户的隐私和数据安全。 简便易用： Microsoft Remote Desktop具有直观的用户界面，容易上手和使用。 用户可以根据个人需求自定义远程连接设置，包括分辨率、音频设置等。 兼容性： 支持与最新版本的Windows操作系统兼容，确保完美兼容性和稳定性。 无论是个人用户还是企业用户，Microsoft Remote Desktop都是实现远程办公、文件共享、应用程序控制等需求的理想选择。 总之，Microsoft Remote Desktop是一款功能全面、操作简便且安全可靠的远程桌面工具，无论是个人用户还是企业用户，都能从中获得极大的便利和效益。
本文由 mdnice 多平台发布
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca725409a4f2f7e77d108f2224cca768/" rel="bookmark">
			我是怎么完成论文降重和aigc降重的？查重降重干货分享！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		希望我本篇分享的论文查重降重以及aigc降低的经历，可以鼓励和帮助正在因为论文查重降重而苦恼的同学。
早日降重成功，顺利通过查重！ 前言
我的论文查重率：7.1%，知网aigc检测9%，（学校要求的是知网查重率15%以下达标），经历了一个多月的修改，总算降重成功。
查重
从3月初初稿出来后我同样经过了多次查重，面对各式各样的查重网站，我使用了万方、checkbug、蝌蚪论文，而这三个网站中checkbug和蝌蚪论文每天都可以免费查重一篇！
checkbug查重
蝌蚪论文查重
我的查重经历概述：
初稿查重：checkbug和蝌蚪论文都用的免费版查的，还有万方查重，检测结果分别是checkbug为51%，蝌蚪论文49%，最低的是万方为32%（学信网万方可以免费查一次）。修改吧......。二稿查重：合买的知网VIP查重，由于是合买的所以查重率没有参考价值，主要参考检测报告标红修改......可是改了几个通宵，在知网个人版一查，查重率降了5%下去，难搞！（所以建议大家要用知网的话就直接提交个人版即可！）继续降重查重：checkbug机器降重和至尊版查重！.......定稿查重：checkbug至尊版5.7%、知网校审7.1%Aigc检测：蝌蚪论文降低aigc后知网检测9% 结论：除了知网，其他查重系统均可以领取免费查重，初稿检测是没有问题的，修改降重后从二稿查重开始就使用收费版吧，不过这类查重系统的收费都不高，1元/千字对于学生来说基本都可以接受；从查重率来看，没有哪个系统会真正和知网一样的，如果学校要求知网查重，那么除了知网，其他的都不准确；但是checkbug和蝌蚪论文的查重报告是很有参考价值，标注和知网最为接近。
降重
看到网上很多说删除法降重的，于是删掉了一些标红内容，结果查重率并没有降多少，再删篇幅就不够了！
完了，我压根就不知道怎么搞定这一大片的红，实在不会了！
老师救我
万般无奈之下，请教老师，佛系的老师就叫我根据查重报告来修改，注意格式和正确引用，可查重率依然居高不下。
学长经验
在躺平的几天里和很多同学一样刷着各种降重的方法，几位学长的关于论文查重的分享让我备受启发，知己知彼百战不殆啊。道理很简单，但过程是曲折的，一遍遍的试错，一个个方法的总结，一段段的修改，然后然后就有了文章开头的成功！
分享
后来，想想几次论文写作和查重降重的经历，是不是应该给一个完整的总结，但是面对这躁动的世界，一直没有静下心来。这几天有学弟问我关于论文降重的一些问题，又点燃了我分享的念头，于是学着之前看到的几位学长的样子把总结的一些论文降重的技巧分享出来，帮助更多同学完成与毕业论文降重的较量。
论文降重技巧：
技巧一、机器降重工具
四种降重模式：1.智能降重；2.强力降重；3.AI知网降重4.降低aigc
如果因为时间紧，实在降不下去，我直接使用checkbug降重软件全文修改，然后在结合其他方法调整自改。
智能降重 针对本系统定稿检测降重超有效！提交查重时选择“智能降重”或者直接上传“智能降重”都可以！然后点击提交！
提交后在智能降重结果页面查看进度，降重完成后点击下载文档。
使用过后发现还可以帮我扩展思路！例如：部分内容智能降重后机器用到了拆分和替换法修改，启发我在另外一个部位自己用该方法修改延展。
2.强力降重（保留格式）
关键的关键！蝌蚪论文和checkbug他们的强力降重还可以保留原格式，所以我使用了两次智能降重（查降查）后，又使用了一次强力降重！买了个3次的降重套餐正好！
降重前后对比：
第三次全文降重后checkbug查重率为9.88%，然后对照查重报告把标红的段落使用“知网降重”逐一改写。
3、知网降重（段落改写续写）
知网降重功能是专门针对局部段落进行AI改写的，只需要复制重复内容粘贴到文本框中 选择改写或续写！
进一步修改最后一次checkbug论文查重5.72%，然后才提交校审的，知网7.1%。
画个重点：修改时尽量不要改动文章结构，特别是没有标红的地方连标点都不要变，变动结构后很容易出现新的重复段落。怎么改的呢？我的方法是对于重复的小句子直接不改动，先搞大面积的重复内容，可以避免新的重复也可能下次查重的时候反而不重复了。
4、降低aigc
最新的aigc检测真是搞不懂为什么自己写的内容也会被标疑似。至于修改方法，大家注意把文中类似首先，其次，再次这样的ai模型语言改换成1，2，3以外，其他方法真不知道如何下手，如果aigc检测率不是很高，大家可以注意检查下。如果降低不下去就用工具吧！
我用的是蝌蚪论文的降低aigc功能！
登录蝌蚪论文系统，选择降低aigc按钮，上传文章提交；
在aigc降低结果页面看改写进度，等几分钟刷新页面，改完后点击现在改写后文档；
下载完后一定要检查全文，确定没有逻辑表述、格式等错误后提交知网aigc检测9%！
至此，论文降重和aigc降低全部完成了！下面分享些自己调整论文降重的技巧！
技巧二：变换语法句式
变换语法句式的核心是：几乎所有的论文查重软件都会通过对一个句子主谓宾定状补等语法结构进行对比，如果出现一个句子中，主语、谓语、宾语关键词和排列的顺序相同，就会判定为抄袭！
注意是排列的顺序相同就会被判定为抄袭，因此，在改重时，可以将句式语法打乱。如将陈述句改成疑问句，关键词重新排序并适当进行近义词替换等等。
例如：
原句：骨表面以下的骨骼实际上有着更多的矿质化，同时显示了较老的及较脆的骨骼的结构特点。
修改：目前表面的矿质化骨骼真的并不存在？当然存在！骨骼中无论是较脆或是较老的，无一不显示出它矿质化的结构特点。
技巧三、复述原句
复述原句的核心是：只保留原句的核心思想，不采用它的句子结构和任何一个字，也就是用自己的话表达出原句的意思，同时尽量变换句式。
这种论文查重修改技巧实施起来颇有难度，可以正面陈述意思，也可以反面印证原意。多用此法修改几次能让你修改得更顺手，掌握此法的精髓，而且，这样改重后绝对没有任何问题。
例如：
原句：严密观察术后伤口渗血情况及石膏的完整性，避免石膏折断和小便污染。
修改：外科治疗后患者的创口会有流血与石膏脱落问题，应严格的跟踪，防止出现创口处石膏与代谢废物的破坏。
技巧四、加字
加字的核心是：可以在句子中插入一个或多个文字，打断查重引擎的查重抄袭率检验系统。因为查重引擎的判定抄袭的规定是连续n个字相同即抄袭，那么，如果超过这n个字，则有可能难以检测。而且，当论文字数偏少时，还可以帮助增加几千上万字。
例如：
原句：A组经过早期的肉芽组织形成阶段，在术后第4周完全填充关节软骨缺损区，且与周围组织连接紧密，细胞周围有典型的软骨陷窝及软骨囊，细胞胞突明显，整个细胞被胶原原纤维环绕；
修改：A组经过了最早期的局部与整体肉芽组织的逐步形成阶段，进而在手术后的第4周就已经完全的填充好了关节软骨的病灶与缺损区，而且与骨膜周围的组织生长完好、连接紧密，在细胞的周围伴生有典型的人体骨骼软骨组织陷窝以及关节软骨囊，且细胞的胞突十分明显，观察细胞后发现整个细胞都被胶原类的原纤维组织所环绕；字数增加了不少，抄袭率问题也迎刃而解。
技巧五、更改关键词
更改关键词的核心是：将关键词用同义词替换，尽量不使用原来出现的文字。该技巧主要是针对论文查重引擎是通过对主谓宾定状补等实词或虚词作为关键词，连续2个或3个关键词相同（哪怕中间有间隔）即为抄袭的原理所总结得出的。
例如：
原句：医护人员必须掌握小儿生理解剖特点和生长发育特点，了解小儿生理、心理状态，对小儿骨科手术进行全方位的麻醉护理。
修改：救治者（替换医护人员）应该（替换必须）了解（替换掌握）孩子（替换小儿）身体结构（替换生理解剖特点）及成长规律（替换生长发育特点），通晓（替换了解）孩子身心情况（替换生理心理状态），实施全面的（替换全方位）的骨科麻醉手术（组合后替换）。
技巧六、图表转化法
对于论文中数据部分和表格重复怎么办？只要老师没有明确要求必须用文本描述，就可以把这部分的数据制作成表格或柱状图表，注意行列对应；标红的表格做成图片，在做成图片时尽量把表格里面的行列互换一下。目前来看，这种方法是非常可行的，因为论文查重软件对图片暂时无法检测。
以上总共五个论文降重技巧和两个论文降重软件的四种降重模式，保持好心态耐心使用修改快速降重超好用！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca725409a4f2f7e77d108f2224cca768/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e64a26b7614d815aed14efe018ca7ae/" rel="bookmark">
			Redis常见数据类型(3)-String, Hash
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
String
命令小结
内部编码
典型的使用场景
缓存功能
计数功能
共享会话
手机验证码
Hash 哈希
命令
hset
hget
hexists
hdel
hkeys
hvals
hgetall
hmget
hlen
hsetnx
hincrby
hincrbyfloat
String 上一篇中介绍了了String里的基本命令, 接下来总结一下
命令小结 命令执行效果时间复杂度set key value [key value...]设置key的值为valueO(1)get key 获取指定的key值O(1)del key[key...]删除指定的keyO(k), k是键的个数mset key value[key value...]批量设置指定的key和valueO(k), k是键的个数mget key [key...]批量获取key的值O(k). k是键的个数incr key指定的key值 + 1O(1)decr key指定的key值 - 1O(1)incrby key n指定的key值 + nO(1)decrby key n指定的key值 - nO(1)incrbyfloat key n指定的key值 + nO(1)append key value指定的key值追加valueO(1)strlen key获取指定key的长度 O(1)
setrange key offset value覆盖指定key的从offset开始的部分值 O(n), n是字符串长度, 通常视为O(1)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e64a26b7614d815aed14efe018ca7ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19ff89a94eefbd57805ba78d42afce7a/" rel="bookmark">
			【C#】未能加载文件或程序集“CefSharp.Core.Runtime.dll”或它的某一个依赖项。找不到指定的模块。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到《小5讲堂》
这是《C#》系列文章，每篇文章将以博主理解的角度展开讲解。
温馨提示：博主能力有限，理解水平有限，若有不对之处望指正！
目录 背景错误提示分析原因解决方法Chromium知识点相关文章 背景 最近在使用Windows窗体在新的电脑上运行时，出现错误提示，
未能加载文件或程序集“CefSharp.Core.Runtime.dll”或它的某一个依赖项。找不到指定的模块。
本篇就来讲讲怎么解决这个问题。
错误提示 分析 然后打开安装程序，发现只有Microsoft Windows Desktop Runtime - 6.0.30（x64）
它是一种用于支持桌面应用程序运行的组件。它提供了一些基本的运行时库和组件，使得桌面应用程序能够在 Windows 操作系统上运行。
原因 由于在其他电脑上没有出现这个报错，所以在另外一台电脑上查看了安装的软件，
然后对比了两台电脑安装的软件，可以发现缺少了
Microsoft Visual C++ 2015-2022 Redistributable（x64）- 14.36.32532
Microsoft Visual C++ 2015-2022 Redistributable（86）- 14.36.32532
它是一种由 Microsoft 提供的软件包，它包含了在运行使用 Visual C++ 编写的应用程序时所需的运行时组件。这些组件是许多 Windows 应用程序的依赖项，因此安装了这个 Redistributable 软件包可以确保这些程序能够在您的系统上正常运行。
解决方法 下载安装相关的软件即可，根据自己操作系统版本下载对应软件。
微软下载Microsoft Visual C++ Redistributable latest supported downloads：
https://learn.microsoft.com/en-US/cpp/windows/latest-supported-vc-redist?view=msvc-170
在 CefSharp 中，你可以使用 ChromiumWebBrowser 控件来加载网页地址。以下是一个简单的示例代码：
using CefSharp; using CefSharp.WinForms; using System; using System.Windows.Forms; namespace YourNamespace { public partial class YourForm : Form { private ChromiumWebBrowser chromiumWebBrowser; public YourForm() { InitializeComponent(); // 初始化 ChromiumWebBrowser 控件 chromiumWebBrowser = new ChromiumWebBrowser("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19ff89a94eefbd57805ba78d42afce7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fdf4bbfb756323519d56d94ea87f0ff/" rel="bookmark">
			JavaSE——类和对象（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.面向对象的初步认知
二. 类定义和使用
三. 类的实例化
四.this引用
五.对象的构造以及初始化
大家好！我是北纬，前面我一直在讲Java是一门面向对象的编程语言，那么今天我们就来讲讲Java中的对象和类,这节内容理解起来比较抽象但是内容相当精彩，接下来会给大家详细讲解。
一.面向对象的初步认知 1. 什么是面向对象
Java是一门纯面向对象的语言(Object Oriented Program，简称OOP)，在面向对象的世界里，一切皆为对象。面向对象是解决问题的一种思想，主要依靠对象之间的交互完成一件事情。用面向对象的思想来设计程序，更符合人们对事物的认知，对于大型程序的设计、扩展以及维护都非常友好。
2 .面向对象与面向过程的区别
这里拿洗衣服的例子给大家详细讲解。
1. 传统洗衣服过程
传统的方式：注重的是洗衣服的过程，要按照步骤一步一步去实现，少了一个环节都不行，而且不同衣服洗的方式，时间长度，拧干方式都不同，处理起来就比较麻烦；类比一下如果我们写代码是按照这样的方式去书写，那么我们将来对代码进行扩展或者维护起来就会比较麻烦。
2.现代洗衣服过程
这时洗衣服涉及四个对象：人，衣服，洗衣液，洗衣机；整个洗衣服的过程：人将衣服放入洗衣机，倒入洗衣液，启动洗衣机，洗衣机就会自动完成洗衣过程并甩干。期间整个过程是由人，衣服，洗衣液，洗衣机这四个对象之间交互完成的，人不需要去关注洗衣机具体是如何洗衣服，如何甩干的。以面向对象方式来进行处理，就不关注洗衣服的过程，具体洗衣机是怎么来洗衣服，如何来甩干的，用户不用去关心，只需要将衣服放进洗衣机，倒入洗衣液，启动开关即可，通过对象之间的交互来完成的。
注意：面向过程和面向对象并不是一门语言，而是解决问题的方法，没有哪个好坏之分，都有其专门的应用场景。
二. 类定义和使用 1.简单认识类
类是用来对一个实体(对象)来进行描述的，主要描述该实体(对象)具有哪些属性(外观尺寸等)，哪些功能(用来干啥），描述完成后计算机就可以识别了。
2. 类的定义格式
在java中定义类时需要用到class关键字，具体语法如下：
class ClassName{ field; // 字段(属性) 或者 成员变量 method; // 行为 或者 成员方法 } class为定义类的关键字，ClassName为类的名字，{}中为类的主体。类中包含的内容称为类的成员，属性主要是用来描述类的，称之为类的成员属性或者类成员变量。方法主要说明类具有哪些功能，称为类的成员方法。
例如定义一个学生类:
注意事项:
1.类名注意采用大驼峰定义；成员前写法统一为public，此处写的方法不带 static 关键字，后面会详细解释。
2.一般一个文件当中只定义一个类，main方法所在的类一般要使用public修饰。
3. public修饰的类必须要和文件名相同。
三. 类的实例化 1 .什么是实例化
定义了一个类，就相当于在计算机中定义了一种新的类型，与int，double类似，只不过int和double是java语言自带的内置类型，而类是用户自定义了一个新的类型，比如上述的Student类。它是类(一种新定义的类型)有了这些自定义的类型之后，就可以使用这些类来定义实例(或者称为对象)。
用类类型创建对象的过程，称为类的实例化，在java中采用new关键字，配合类名来实例化对象。
代码示例：
注意事项：
1. new 关键字用于创建一个对象的实例。
2. 使用 . 来访问对象中的属性和方法。
3. 同一个类可以创建多个实例。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fdf4bbfb756323519d56d94ea87f0ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d260c8220f1a64e3f51d618398288824/" rel="bookmark">
			【大数据】探索大数据中的向量相似度搜索：Faiss入门指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在大数据领域，处理海量向量数据并进行高效的相似度搜索是一项重要任务。Faiss（Facebook AI Similarity Search）是一个强大的开源库，专门用于高维向量的相似度搜索。本文将介绍Faiss库的基本概念以及如何在Python中使用它来实现向量相似度搜索。
什么是Faiss？ Faiss是Facebook开发的用于大规模向量检索和相似度搜索的库。它主要用于处理高维度的向量，例如图像特征、文本向量等。Faiss提供了高效的索引结构和查询算法，能够快速地在海量数据集中找到最相似的向量。
Faiss的基本用法 首先，我们需要安装Faiss库。可以使用pip来安装最新版本的Faiss：
pip install faiss-cpu 安装完成后，我们可以在Python中导入Faiss库并开始使用。以下是一个简单的示例代码，演示了如何创建一个索引并进行向量相似度搜索：
import faiss import numpy as np # 创建随机向量数据集 d = 64 # 向量维度 nb = 100000 # 向量数量 np.random.seed(1234) dataset = np.random.random((nb, d)).astype('float32') # 构建索引 index = faiss.IndexFlatL2(d) # 使用L2距离度量的平坦索引 # 添加数据到索引 index.add(dataset) # 执行相似度搜索 k = 5 # 返回最相似的k个向量 query = np.random.random((1, d)).astype('float32') # 查询向量 distances, indices = index.search(query, k) # 打印搜索结果 print("查询向量的最近邻：") print("距离：", distances) print("索引：", indices) 在这个示例中，我们首先生成了一个包含随机向量的数据集，然后使用Faiss创建了一个平坦索引。接着，我们将数据集添加到索引中，并生成了一个随机的查询向量。最后，我们使用search方法在索引中查找与查询向量最相似的向量，并打印了搜索结果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d260c8220f1a64e3f51d618398288824/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c22a584b36f48e2b8b55e34571235a84/" rel="bookmark">
			uniapp前端实现微信支付（小程序、公众号H5、app）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这段时间通过uniapp开发一个三端合一的项目，涉及到不同平台的支付方式，这里为大家简单介绍一下，希望能有所帮助；
阅读: 微信支付文档
一、微信小程序支付 通过wx.login()获取code、调用后端接口获取openid； wx.login({ success (res) { if (res.code) { //发起网络请求获取openid，一般是访问后端封装好的接口，也可以通过访问微信官方接口获取 uni.request({ url: '后端接口地址,获取openid', method: 'GET', success(res) { //获取openid：用户真实唯一id进行保存 console.log(res.data.openid) } }) } else { console.log('登录失败！' + res.errMsg) } } }) 调用后端接口创建订单，获取orderId； uni.request({ url: '后端接口地址,获取订单id', method: 'POST', data: { 传入接口需要的参数,如商品金额,商品个数等 }, success(res) { console.log(res.data.orderId) } }) 调用后端接口获取支付核心参数，预支付； uni.request({ url: '后端接口地址,获取支付核心数据', method: 'POST', data: { 传入接口需要的参数,如订单ID,openId等 }, success(res) { console.log(res.data) //接口会返回以下核心参数 //timeStamp 时间戳 //nonceStr 随机字符串 //package 统一下单接口返回的 prepay_id 参数值 //signType 签名算法 //paySign 签名 } }) 通过支付核心参数调用wx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c22a584b36f48e2b8b55e34571235a84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d1d19df774e0066779a2b004d2b44f0/" rel="bookmark">
			Midjourney是一个基于GPT-3.5系列接口开发的免费AI机器人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Midjourney是一个基于GPT-3.5系列接口开发的免费AI机器人，旨在提供多领域的智能对话服务。Midjourney在不同领域中有不同的定义和应用，以下是对其中两个主要领域的介绍：
Midjourney官网：https://www.midjourney.com/
一、AI绘画工具Midjourney 介绍： Midjourney是一款由David Holz于2022年3月推出的AI绘画工具。这款工具可以通过用户输入的文字，利用人工智能技术在短时间内（大约一分钟）生成相对应的图片。它支持多种画家的艺术风格，如安迪·华荷、达芬奇、达利和毕加索等，并能识别特定的镜头或摄影术语。2023年，Midjourney官方中文版已经开启内测，用户可以在QQ频道上体验。
原理： Midjourney的原理主要是基于深度学习和生成对抗网络（GAN）技术。通过大量的训练数据，模型学会了如何将输入的文本描述转化为对应的图像。此外，Midjourney还引入了多种画家的艺术风格，使得生成的图像具有更加丰富的多样性。Midjourney的核心原理是使用GPT-3.5模型来生成智能回复。GPT-3.5是一种基于深度学习的模型，训练时使用了大量的文本数据，从而具备了理解自然语言的能力。通过对输入文本的分析和理解，Midjourney可以生成相关的回答或建议。
使用方法： 使用Midjourney时，用户只需在指定的输入框中输入想要描绘的场景或物体，并选择所需的画家风格。然后，Midjourney会在短时间内生成多张与输入描述相符的图像供用户选择。用户还可以根据自己的需求对生成的图像进行微调，如调整色彩、亮度等。
代码案例： Midjourney是一个基于GPT-3.5系列接口开发的免费AI机器人，旨在提供多领域的智能对话服务。以下是使用Python代码与Midjourney进行对话的示例：
import openai openai.api_key = "YOUR_API_KEY" def chat_with_midjourney(message): response = openai.Completion.create( engine="text-davinci-003", prompt=message, max_tokens=50, temperature=0.6, n=1, stop=None, log_level="info", logprobs=0, echo=False, user="user", ) return response.choices[0].text.strip() # 与Midjourney进行对话 while True: user_message = input("User: ") response = chat_with_midjourney(user_message) print("Midjourney: " + response) 注意事项： 由于Midjourney是一款基于Web的工具，因此没有特定的代码案例。然而，在使用时需要注意以下几点：
输入描述时要尽量具体、清晰，以便Midjourney能够更准确地生成符合要求的图像。在选择画家风格时，要注意不同风格的特点和适用范围，以便生成符合自己需求的图像。对于生成的图像，可以进行适当的微调和修改，但不要过度依赖自动生成的结果，要结合自己的创意和审美进行修改。 二、自动化测试框架Midjourney 介绍： Midjourney还是一种基于机器学习的自动化测试框架。它通过分析测试用例和应用程序的行为来识别潜在的错误和缺陷。该框架使用深度学习技术来分析测试过程中的各种指标，如应用程序的性能、响应时间、内存使用情况等，并自动捕获应用程序的状态信息。同时，它还利用自然语言处理技术来分析测试用例的描述和注释，并将其映射到应用程序的代码中。
原理： Midjourney的原理主要是利用机器学习算法来训练模型，从而能够自动识别和分类测试用例中的错误和缺陷。该框架通过分析测试用例和应用程序的行为数据，提取出关键特征，并利用这些特征来训练分类器。在测试过程中，Midjourney会自动执行测试用例并收集相关数据，然后将这些数据输入到分类器中进行预测和判断。
使用方法： 以下是一个使用Python和Selenium的代码案例，用于自动化测试一个网页的登录功能：
from selenium import webdriver from selenium.webdriver.common.keys import Keys # 创建一个Chrome浏览器实例 driver = webdriver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d1d19df774e0066779a2b004d2b44f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3054f6bbd5f28c6a666ad09f90b3cd23/" rel="bookmark">
			【一步一步了解Java系列】：Java中的方法对标C语言中的函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看到这句话的时候证明：此刻你我都在努力~
加油陌生人~
个人主页：Gu Gu Study
专栏：一步一步了解Java
喜欢的一句话： 常常会回顾努力的自己，所以要为自己的努力留下足迹。
_ 如果喜欢能否点个赞支持一下，谢谢啦！_
作者：小闭
引言：相信大家在学习C语言后再学习Java时就经常听到有人说到”方法“，但是当你看到他们所说的方法时，你就会就会感觉到熟悉，你可能就会觉得这不就是C语言中的函数吗？那么Java中的方法和C语言中的有什么不一样吗？其实这两者确实区别不大，甚至可以说一样，只不过C语言面向过程的语言而Java是面向对象的语言。所以叫法上是有一点区别的。那么下面我们就来学习一下Java中的方法的知识吧。
什么是方法以及方法存在的意义 在我看来方法就是将一些代码封装起来的一片代码块，这个代码块可以完成一个单独的功能比如：加法，加法，除法等。再比如：面向对象时有个对象的“说话”功能。
方法存在的意义：
是能够模块化的组织代码(当代码规模比较复杂的时候).做到代码被重复使用, 一份代码可以在多个位置使用.让代码更好理解更简单.直接调用现有方法开发, 不必重复造轮子. 给大家举一个例子：
public static void func1() { int year = 1900; if ((0 == year % 4 &amp;&amp; 0 != year % 100) || 0 == year % 400) { System.out.println(year + "年是闰年"); } else { System.out.println(year + "年不是闰年"); } } 如上就是Java中的一个方法，确实与C语言的函数差不多，差别就是语法上的不一样。上面的代码就是：将判断一个年份是否为闰年的代码写到这一块地方，而这一块地方就是方法。
方法的定义 ** 修饰符 返回值类型 方法名称(参数类型 形参 ){ **
**方法体代码; **
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3054f6bbd5f28c6a666ad09f90b3cd23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4dfb80cfc6236494d3f62e9fdb1c3e5/" rel="bookmark">
			ios17如何打开开发者模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：惊讶地发现中文互联网环境上竟然没有靠谱的打开教程。遂写一篇以帮助有需要的朋友们。
注意：本文忽略安装这些软件和进行这些操作的安全性，目的只是打开开发者模式。对工具抱有疑虑的朋友们酌情考虑本方案。
相关软件资源和文件放在这里：懒得去网站下载的可以下载这个资源。资源固定为1分，有分的朋友可以支持一下:)
ios17打开开发者模式相关软件工具和文件
现状：我的手机在设置（settings）-&gt; 隐私与安全性（privacy and security），拉到底部，是看不到开发者选项的，如图所示：
这种情况下需要借助电脑来开启开发者选项的显示：
1. 下载并安装sideloadly
Sideloadly - iOS, Apple Silicon &amp; TV Sideloading
以macOS版本为例，安装后打开软件如图：
2. 在网站 Supervise.me: Supervise iPhone, iPad or iPod Touch 中点击developer mode：
随后点击get：
这个操作会下载一个ipa文件：
3. 用数据线连接iphone到电脑，会提示需要安装一个软件，点击安装（install）
（此步骤无截图）借用网上的一个截图展示一下：
4. 安装完成后，sideloadly会显示本机信息，然后点击左方的ipa，选中刚才下载的ipa文件，并且输入icloud id：
然后点击start：
然后他会提示输入icloud的密码：
这个步骤就有点敏感了，先给自己的icloud账号改一个临时密码，记录在文本文档上，开启完developer mode再改回去。
·点击start之后，输入临时密码，最后显示done。此步骤之后开发者模式已经打开了，可以改回原来的icloud密码。（有1个小时的安全延迟，等待1个小时后再修改密码）
5. 结果：
设置（settings）-&gt; 隐私与安全性（privacy and security），拉到底部，可以看到开发者模式显示出来了：
6. 卸载下载的软件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e441a53c2b5eb856bad9263a1b7ec9ca/" rel="bookmark">
			【JavaEE精炼宝库】多线程（2）Thread类与常用方法 | 线程状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Thread 类及常见方法
1.1 线程创建 start：
1.2 线程中断 interrupt：
1.2.1 通过共享的标记来进行沟通：
1.2.2 调用 interrupt() 方法来通知：
1.2.3 总结：
1.3 线程等待 join：
1.4 线程休眠：
1.5 获取线程实例：
二、线程的状态 2.1 线程的所有状态：
2.2 线程状态含义：
2.3 线程状态和状态转移的意义：
一、Thread 类及常见方法 1.1 线程创建 start： 调用 start 方法，才是真的在操作系统的底层创建出一个线程。
这个在上一篇文章多线程1已经写过了 start 和 run 的区别。这里就不再赘述。下面代码的 start 方法的开始，才是意味着线程真正被创建了。 注意：一个 Thread 对象只能 start 一次。所以要想再创建一个新的线程，就需要创建另一个 Thread 对象。
public class Main { public static void main(String[] args) { Thread t = new Thread(() -&gt; { while(true){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e441a53c2b5eb856bad9263a1b7ec9ca/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/353/">«</a>
	<span class="pagination__item pagination__item--current">354/621</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/355/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>