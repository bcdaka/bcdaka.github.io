<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>small bird - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/2a635475a93a80c82d7121558f6d0d78/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="small bird">
  <meta property="og:description" content="this-&gt;setWindowFlags(Qt::FramelessWindowHint);//去掉标题栏 // Translucent 透明化 this-&gt;setAttribute(Qt::WA_TranslucentBackground); //窗口透明化 // this-&gt;setWindowFlags(this-&gt;windowFlags() | Qt::WindowStaysOnTopHint);//设置窗口最顶层 this-&gt;setWindowIcon(abc);//设置窗口图标 “用鼠标全局坐标的位置减去父窗口的左上角位置”，这正是这段代码所做的。这种计算方式常用于实现拖拽窗口的功能，特别是当窗口没有标准的标题栏时。通过这种方式，你可以确定鼠标相对于父窗口的位置，进而实现拖拽窗口的功能 event-&gt;globalPos(): 获取鼠标光标在全局坐标系中的位置。 ((QWidget*)this-&gt;parent())-&gt;frameGeometry().topLeft(): 获取父窗口左上角的位置。 event-&gt;globalPos() - ((QWidget*)this-&gt;parent())-&gt;frameGeometry().topLeft(): 计算鼠标光标在全局坐标系中的位置与父窗口左上角位置之间的差值。 m_pos = ...: 将计算得到的差值赋给 m_pos，m_pos 是一个 QPoint 类型的成员变量，表示鼠标光标相对于父窗口左上角的位置。 void Bird_::mouseMoveEvent(QMouseEvent *event) { //获取窗口的gai变量 this-&gt;m_pos= event-&gt;globalPos()-this-&gt;m_pos; emit aftermove(m_pos); // } //((QWidget*)this-&gt;parent())-&gt;frameGeometry().topLeft(); 获取当前窗口左上角的坐标 void Bird_::mousePressEvent(QMouseEvent *event) { //用鼠标全局坐标的位置减去父窗口的左上角位置 m_pos = event-&gt;globalPos() - ((QWidget*)this-&gt;parent())-&gt;frameGeometry().topLeft(); } if(this-&gt;auto_pos.x()&gt;QGuiApplication::primaryScreen()-&gt;geometry().width())
{
this-&gt;auto_pos.setX(-this-&gt;width());
// 需要减去一个尺寸从屏幕左边飞过来 //超出屏幕 x设为 窗口的-宽度
}
当前位置 为屏幕的尺寸的宽度就可 到达最右侧 将 x置为最左侧的-1倍
bird.cpp 及 bird.h">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-06T16:37:30+08:00">
    <meta property="article:modified_time" content="2024-08-06T16:37:30+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">small bird</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <pre><code> this-&gt;setWindowFlags(Qt::FramelessWindowHint);//去掉标题栏
    //  Translucent   透明化

    this-&gt;setAttribute(Qt::WA_TranslucentBackground);  //窗口透明化

    //
    this-&gt;setWindowFlags(this-&gt;windowFlags() | Qt::WindowStaysOnTopHint);//设置窗口最顶层</code></pre> 
<h2></h2> 
<pre><code>this-&gt;setWindowIcon(abc);//设置窗口图标</code></pre> 
<h2></h2> 
<h2>“用鼠标全局坐标的位置减去父窗口的左上角位置”，这正是这段代码所做的。这种计算方式常用于实现拖拽窗口的功能，特别是当窗口没有标准的标题栏时。通过这种方式，你可以确定鼠标相对于父窗口的位置，进而实现拖拽窗口的功能</h2> 
<p></p> 
<p></p> 
<pre><code>event-&gt;globalPos():
获取鼠标光标在全局坐标系中的位置。
((QWidget*)this-&gt;parent())-&gt;frameGeometry().topLeft():
获取父窗口左上角的位置。
event-&gt;globalPos() - ((QWidget*)this-&gt;parent())-&gt;frameGeometry().topLeft():
计算鼠标光标在全局坐标系中的位置与父窗口左上角位置之间的差值。
m_pos = ...:
将计算得到的差值赋给 m_pos，m_pos 是一个 QPoint 类型的成员变量，表示鼠标光标相对于父窗口左上角的位置。</code></pre> 
<pre><code>void Bird_::mouseMoveEvent(QMouseEvent *event)
{

    //获取窗口的gai变量

    this-&gt;m_pos= event-&gt;globalPos()-this-&gt;m_pos;


    emit aftermove(m_pos);
    //
}
//((QWidget*)this-&gt;parent())-&gt;frameGeometry().topLeft();  获取当前窗口左上角的坐标
void Bird_::mousePressEvent(QMouseEvent *event)
{
    //用鼠标全局坐标的位置减去父窗口的左上角位置
    m_pos = event-&gt;globalPos()   - ((QWidget*)this-&gt;parent())-&gt;frameGeometry().topLeft();
}
</code></pre> 
<p></p> 
<p></p> 
<p><strong> if(this-&gt;auto_pos.x()&gt;QGuiApplication::primaryScreen()-&gt;geometry().width())<br>         {<!-- --><br>             this-&gt;auto_pos.setX(-this-&gt;width());<br>             //  需要减去一个尺寸从屏幕左边飞过来        //超出屏幕 x设为 窗口的-宽度<br>         }</strong></p> 
<p></p> 
<p><strong>当前位置 为屏幕的尺寸的宽度就可  到达最右侧 将 x置为最左侧的-1倍</strong></p> 
<p>bird.cpp 及 bird.h</p> 
<pre><code>#ifndef BIRD__H
#define BIRD__H

#include &lt;QWidget&gt;
#include &lt;QPixmap&gt;//显示图片
#include &lt;QTimer&gt;
#include &lt;QMouseEvent&gt;
#include &lt;QMenu&gt;
class Bird_ : public QWidget
{
    Q_OBJECT
public:
    explicit Bird_(QWidget *parent = nullptr);

    QPixmap m_bird;

    int min =1;  //最小值图片下标
    int max = 8;//最大值图片下标  从1切到8实现飞翔的效果

    QTimer *timer;
    bool qmousedown =false; //刚开始并没有按下
bool movingRight;

    QPoint m_pos;//记录当前左边

    QMenu * menu;


    virtual void mouseMoveEvent(QMouseEvent *event); //移动事件
    virtual void mousePressEvent(QMouseEvent *event);//按下事件
    virtual void mouseReleaseEvent(QMouseEvent *event);
void reverseDirection();
    void running();
signals:

    void changepix();//告诉主场景正在改变图片显示  信号不用显示


    void aftermove(QPoint cc);//拖拽后 主场景移动的位置
};

#endif // BIRD__H
</code></pre> 
<p></p> 
<p>bird.cpp</p> 
<pre><code>#include "bird_.h"

Bird_::Bird_(QWidget *parent)
    : QWidget{parent}
{
    //需要提前加载图片

    // m_bird = new QPixmap();

    for(int i =0 ; i&lt;8;i++)
    {
        //第一次string  = bird1 第二次bird2
        QString str = QString("./bird/bird%1").arg(i+1);  //%1占位符   arg用作填补占位
        this-&gt;m_bird.load(str);
    }

    this-&gt;setFixedSize(this-&gt;m_bird.width(),this-&gt;m_bird.height());//设置窗口尺寸为图片的高度和宽度


    timer = new QTimer(this);

    //监听信号
    //每隔1秒发送 timeout信号
    connect(timer,&amp;QTimer::timeout,[this](){
        QString str = QString("./bird/bird%1").arg(this-&gt;min++);
        this-&gt;m_bird.load(str);
        if(this-&gt;min&gt;max)
        {
            this-&gt;min = 1;
        }
        //发出信号
        emit       changepix();
    });

    menu = new QMenu;
    // this-&gt;menu-&gt;addAction("退出")添加菜单项(退出)

    //菜单项 trigger信号

    connect(this-&gt;menu-&gt;addAction("退出"),&amp;QAction::trigger,[=](){
        exit(0);
    });



}

void Bird_::running()
{
    timer-&gt;start(100);//每隔0.1秒启动 都会发出信号
}

void Bird_::mouseMoveEvent(QMouseEvent *event)
{

    //获取窗口的gai变量

    this-&gt;m_pos= event-&gt;globalPos()-this-&gt;m_pos;


    emit aftermove(m_pos);
    //
}
//((QWidget*)this-&gt;parent())-&gt;frameGeometry().topLeft();  获取当前窗口左上角的坐标
void Bird_::mousePressEvent(QMouseEvent *event)
{
    //用鼠标全局坐标的位置减去父窗口的左上角位置
    m_pos = event-&gt;globalPos()   - ((QWidget*)this-&gt;parent())-&gt;frameGeometry().topLeft();


    qmousedown = true;


    if(event-&gt;button()==Qt::RightButton)
    {
        menu-&gt;popup(QCursor::pos());//弹出菜单  和鼠标当前的位置意义 方便点击退出
    }

    //如果菜单是因为别的方式消失的 那么它继续往前飞

    //通过任何手段消失发出的信号
    //&amp;QMenu::aboutToHide
    connect(this-&gt;menu,&amp;QMenu::aboutToHide,[=](){


        //改变状态继续往前飞
        this-&gt;qmousedown =false;
    });
}

void Bird_::mouseReleaseEvent(QMouseEvent *event)
{
    qmousedown = false;

}
</code></pre> 
<p></p> 
<p></p> 
<p>mainscence.h 及cpp</p> 
<pre><code>#ifndef MAINSCENCE_H
#define MAINSCENCE_H

#include &lt;QWidget&gt;
#include "bird_.h"
#include &lt;QPainter&gt;
#include &lt;QTimer&gt;
#include &lt;QVector&gt;
QT_BEGIN_NAMESPACE
namespace Ui {
class Mainscence;
}
QT_END_NAMESPACE

class Mainscence : public QWidget
{
    Q_OBJECT

public:
    Mainscence(QWidget *parent = nullptr);
    ~Mainscence();

   Bird_ *birds;


    //重写画图事件
    QPainter *painter;
    void paintEvent(QPaintEvent *event);

    //让窗口自动移动
    QPoint auto_pos;
    QTimer * timer;
private:
    Ui::Mainscence *ui;
};
#endif // MAINSCENCE_H
</code></pre> 
<p></p> 
<p></p> 
<pre><code>#include "mainscence.h"
#include "ui_mainscence.h"
//主场景
#include &lt;QDesktopServices&gt;
#include &lt;QVector&gt;
Mainscence::Mainscence(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Mainscence)
{
    ui-&gt;setupUi(this);

    this-&gt;setWindowTitle("主窗口");
    QIcon abc("./bird/birdIcon.ico");

    // QSize(30,30);
    this-&gt;setWindowIcon(abc);//设置窗口图标

    this-&gt;birds = new Bird_(this);

    //  birds-&gt;append(*new Bird_(this));
    this-&gt;setFixedSize(birds-&gt;width(),birds-&gt;height());
    this-&gt;setAutoFillBackground(1);

    this-&gt;birds-&gt;running();  //调用running 启动定时器

    //监听鸟切图的信号

    connect(birds,&amp;Bird_::changepix,[=](){
        update();//手动调用绘图事件
        // 调用update后会调用   paintEvent
    });

    //监听鸟拖拽移动
    connect(birds,&amp;Bird_::aftermove,[=](QPoint point){

        this-&gt;move(point);
        auto_pos = point; //鼠标拖拽跟新当前窗口的位置


    });


    timer = new QTimer(this);

    timer-&gt;start(30);

    //QGuiApplication::primaryScreen()-&gt;geometry();//qt6中使用这个代替了 qdesktop


    connect(timer,&amp;QTimer::timeout,[=](){

        if(this-&gt;birds-&gt;qmousedown!=true){
            this-&gt;auto_pos.setX(this-&gt;auto_pos.x()+5);  //x坐标加上5像素
        }  //没有按下就往前飞


        if(this-&gt;auto_pos.x()&gt;QGuiApplication::primaryScreen()-&gt;geometry().width())
        {
            this-&gt;auto_pos.setX(-this-&gt;width());
            //  需要减去一个尺寸从屏幕左边飞过来        //超出屏幕 x设为 窗口的-宽度
        }
        //窗口移动
        this-&gt;move(this-&gt;auto_pos);
    });



    this-&gt;setWindowFlags(Qt::FramelessWindowHint);//去掉标题栏
    //  Translucent   透明化

    this-&gt;setAttribute(Qt::WA_TranslucentBackground);  //窗口透明化

    //
    this-&gt;setWindowFlags(this-&gt;windowFlags() | Qt::WindowStaysOnTopHint);//设置窗口最顶层

}

Mainscence::~Mainscence()
{
    delete ui;
}

void Mainscence::paintEvent(QPaintEvent *event)
{
    painter = new QPainter(this);
    //画图时用 drawPixmap
    painter-&gt;begin(this);
    painter-&gt;drawPixmap(0,0,this-&gt;birds-&gt;m_bird);
    //此处画鸟了

    painter-&gt;end();

}
</code></pre> 
<p></p> 
<ul><li><strong><code>[]</code></strong>：不捕获任何外部变量。</li><li><strong><code>[=]</code></strong>：按值捕获所有外部变量。</li><li><strong><code>[&amp;]</code></strong>：按引用捕获所有外部变量。</li><li><strong>混合使用</strong>：可以选择性地按值或按引用捕获特定变量</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/eba283f8cd18d0d8c755618c7a593526/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C:初识指针—学习笔记</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8ee1ae7027b6f649ed5c9dd0cde20969/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">html&#43;css前端作业和平精英2个页面（无js）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>