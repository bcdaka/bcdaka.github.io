<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】二叉树的实现 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/41b60024c2454e07d0647765d89fcac5/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】二叉树的实现">
  <meta property="og:description" content="如有不懂的地方，可翻阅我之前文章哦！
个人主页：小八哥向前冲~
所属专栏：数据结构【c语言】
目录
前言
二叉树的遍历
前序遍历
中序遍历
后序遍历
总结点数
二叉树的高度
第k层叶子数
查找x值
叶子总数
左（右）孩子数
树的销毁
总代码
前言 前一章我们学习了堆，并且了解了什么是树。简单来说，堆就是一个二叉树，现在我们来真正了解一下二叉树！
以这棵树为例：
我们如何用链式结构来表示一颗二叉树呢？不错，结构体！
根据二叉树的节点特点，可以将每个部分分为左孩子节点，右孩子节点和根节点，于是我们可以这样来描述它：
typedef struct TreeNode { struct TreeNode* left;//左孩子节点 struct TreeNode* right;//右孩子节点 TDatatype val;//节点数值 }TNode; 现在我们手搓一个二叉树（上图为例），来进行深入研究！
//创建节点 TNode* BuyNode(TDatatype x) { TNode* node = (TNode*)malloc(sizeof(TNode)); if (node == NULL) { perror(&#34;malloc failed!&#34;); return NULL; } node-&gt;left = node-&gt;right = NULL; node-&gt;val = x; return node; } //手动创建一个二叉树 TNode* CreateTree() { TNode* node1 = BuyNode(1); TNode* node2 = BuyNode(2); TNode* node3 = BuyNode(3); TNode* node4 = BuyNode(4); TNode* node5 = BuyNode(5); TNode* node6 = BuyNode(6); node1-&gt;left = node2; node2-&gt;left = node3; node1-&gt;right = node4; node4-&gt;left = node5; node4-&gt;right = node6; return node1; } 二叉树的遍历 我们知道链表如何遍历，那么一颗链式树是怎么遍历的呢？">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-30T18:04:35+08:00">
    <meta property="article:modified_time" content="2024-05-30T18:04:35+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】二叉树的实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>如有不懂的地方，可翻阅我之前文章哦！</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/4b/c0/3fBKW6h0_o.jpg"></p> 
<p>                 <strong><span style="color:#fe2c24;">个人主页</span></strong>：<a class="link-info" href="https://blog.csdn.net/Qiwaw?spm=1000.2115.3001.5343" title="小八哥向前冲~">小八哥向前冲~</a></p> 
<p>                  <strong><span style="color:#fe2c24;">所属专栏</span></strong>：<a class="link-info" href="https://blog.csdn.net/qiwaw/category_12656458.html" title="数据结构【c语言】">数据结构【c语言】</a></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86" rel="nofollow">二叉树的遍历</a></p> 
<p id="%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:40px;"><a href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86" rel="nofollow">前序遍历</a></p> 
<p id="%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:40px;"><a href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86" rel="nofollow">中序遍历</a></p> 
<p id="%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:40px;"><a href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86" rel="nofollow">后序遍历</a></p> 
<p id="%E6%80%BB%E7%BB%93%E7%82%B9%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93%E7%82%B9%E6%95%B0" rel="nofollow">总结点数</a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6" rel="nofollow">二叉树的高度</a></p> 
<p id="%E7%AC%ACk%E5%B1%82%E5%8F%B6%E5%AD%90%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E7%AC%ACk%E5%B1%82%E5%8F%B6%E5%AD%90%E6%95%B0" rel="nofollow">第k层叶子数</a></p> 
<p id="%E6%9F%A5%E6%89%BEx%E5%80%BC-toc" style="margin-left:0px;"><a href="#%E6%9F%A5%E6%89%BEx%E5%80%BC" rel="nofollow">查找x值</a></p> 
<p id="%E5%8F%B6%E5%AD%90%E6%80%BB%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E5%8F%B6%E5%AD%90%E6%80%BB%E6%95%B0" rel="nofollow">叶子总数</a></p> 
<p id="%E5%B7%A6%EF%BC%88%E5%8F%B3%EF%BC%89%E5%AD%A9%E5%AD%90%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E5%B7%A6%EF%BC%88%E5%8F%B3%EF%BC%89%E5%AD%A9%E5%AD%90%E6%95%B0" rel="nofollow">左（右）孩子数</a></p> 
<p id="%E6%A0%91%E7%9A%84%E9%94%80%E6%AF%81-toc" style="margin-left:0px;"><a href="#%E6%A0%91%E7%9A%84%E9%94%80%E6%AF%81" rel="nofollow">树的销毁</a></p> 
<p id="%E6%80%BB%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E4%BB%A3%E7%A0%81" rel="nofollow">总代码</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%89%8D%E8%A8%80">前言</h2> 
<p>前一章我们学习了堆，并且了解了什么是树。简单来说，堆就是一个二叉树，现在我们来真正了解一下二叉树！</p> 
<p><strong>以这棵树为例：</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/5f/1c/XTNXYUZ1_o.png"></p> 
<p>我们如何用链式结构来表示一颗二叉树呢？不错，<strong><span style="color:#fe2c24;">结构体</span></strong>！</p> 
<p>根据二叉树的节点特点，可以<span style="color:#fe2c24;">将每个部分分为左孩子节点，右孩子节点和根节点</span>，于是我们可以这样来描述它：</p> 
<pre><code class="language-cpp">typedef struct TreeNode
{
	struct TreeNode* left;//左孩子节点
	struct TreeNode* right;//右孩子节点
	TDatatype val;//节点数值
}TNode;</code></pre> 
<p>现在我们<span style="color:#fe2c24;">手搓一个二叉树（上图为例）</span>，来进行深入研究！</p> 
<pre><code class="language-cpp">//创建节点
TNode* BuyNode(TDatatype x)
{
	TNode* node = (TNode*)malloc(sizeof(TNode));
	if (node == NULL)
	{
		perror("malloc failed!");
		return NULL;
	}
	node-&gt;left = node-&gt;right = NULL;
	node-&gt;val = x;
	return node;
}
//手动创建一个二叉树
TNode* CreateTree()
{
	TNode* node1 = BuyNode(1);
	TNode* node2 = BuyNode(2);
	TNode* node3 = BuyNode(3);
	TNode* node4 = BuyNode(4);
	TNode* node5 = BuyNode(5);
	TNode* node6 = BuyNode(6);

	node1-&gt;left = node2;
	node2-&gt;left = node3;
	node1-&gt;right = node4;
	node4-&gt;left = node5;
	node4-&gt;right = node6;

	return node1;
}</code></pre> 
<h2 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86">二叉树的遍历</h2> 
<p>我们知道链表如何遍历，那么一颗链式树是怎么遍历的呢？</p> 
<p><span style="color:#fe2c24;"><strong>这里有三种遍历方法——前，中，后序遍历！</strong></span></p> 
<h3 id="%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86">前序遍历</h3> 
<p>前序遍历是按照：<span style="color:#fe2c24;"><strong>根，左子树，右子树的方式层层遍历的</strong></span>！</p> 
<p>（上图为例）<span style="color:#fe2c24;">前序遍历结果为：1  2  3 NULL NULL NULL 4 5 NULL NULL 6 NULL NULL</span>。</p> 
<p>代码：</p> 
<pre><code class="language-cpp">//前序遍历  根 左子树 右子树
void Preoder(TNode* root)
{
	if (root == NULL)
	{
		printf("N ");
		return;
	}
	printf("%d ", root-&gt;val);
	Preoder(root-&gt;left);
	Preoder(root-&gt;right);
}</code></pre> 
<p><span style="background-color:#edf6e8;">当根走完，再走左子树遍历，再走右子树遍历，直到全部走完！（递归方式走完）</span></p> 
<h3 id="%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">中序遍历</h3> 
<p>中序遍历按照：<strong><span style="color:#fe2c24;">左子树，根，右子树的的方式遍历</span></strong>！</p> 
<p>（上图为例）<span style="color:#fe2c24;">中序遍历结果：NULL 3 NULL 2 NULL 1 NULL 5  NULL 4 NULL 6  NULL  </span>。</p> 
<p>代码：</p> 
<pre><code class="language-cpp">//中序遍历  左子树 根 右子树
void Inoder(TNode* root)
{
	if (root == NULL)
	{
		printf("N ");
		return;
	}
	Inoder(root-&gt;left);
	printf("%d ", root-&gt;val);
	Inoder(root-&gt;right);
}</code></pre> 
<p><span style="background-color:#edf6e8;">先走左子树遍历，再走根遍历，再走右子树遍历，直到全部递归走完！</span></p> 
<h3 id="%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">后序遍历</h3> 
<p>后序遍历按照：<strong><span style="color:#fe2c24;">左子树，右子树，根方式</span></strong>遍历。</p> 
<p>（上图为例）<span style="color:#fe2c24;">后序遍历结果：NULL  NULL  3 NULL  2  NULL  NULL  5  NULL  NULL  6 4 1</span>。</p> 
<p> 代码：</p> 
<pre><code class="language-cpp">//后序遍历  左子树 右子树 根
void Afteroder(TNode* root)
{
	if (root == NULL)
	{
		printf("N ");
		return;
	}
	Afteroder(root-&gt;left);
	Afteroder(root-&gt;right);
	printf("%d ", root-&gt;val);
}</code></pre> 
<p><span style="background-color:#e7fafa;">先走左子树遍历，再走右子树遍历，最后走根！直到递归走完！</span></p> 
<h2 id="%E6%80%BB%E7%BB%93%E7%82%B9%E6%95%B0">总结点数</h2> 
<p>我们不难知道：<span style="color:#fe2c24;">总结点数==左子树节点数+右子树节点数+1（根本身）</span>。</p> 
<p><span style="background-color:#edf6e8;">如果根为空，节点数就是0</span>。</p> 
<p><strong>代码</strong>：</p> 
<pre><code class="language-cpp">//节点数
int TreeSize(TNode* root)
{
	//每个部分可以看成：左子树+右子树+1（自身）
	return root == NULL ? 0 : TreeSize(root-&gt;left) +
		TreeSize(root-&gt;right) + 1;
}</code></pre> 
<h2 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6">二叉树的高度</h2> 
<p><strong>分析</strong><span style="color:#fe2c24;">：树的高度==左右子树中高的那个子树的高度+1。</span></p> 
<p><strong>代码</strong>：</p> 
<pre><code class="language-cpp">int HeightTree(TNode* root)
{
	//高的子树+1就是高度
	if (root == NULL)
		return 0;
	int leftheight = HeightTree(root-&gt;left);
	int rightHeight = HeightTree(root-&gt;right);
	return leftheight &gt; rightHeight ?
		leftheight + 1 : rightHeight + 1;
}</code></pre> 
<h2 id="%E7%AC%ACk%E5%B1%82%E5%8F%B6%E5%AD%90%E6%95%B0">第k层叶子数</h2> 
<p>分析：<span style="color:#fe2c24;">第k层叶子数==第k层的左子树的叶子数+第k层的右子树的叶子数</span>。</p> 
<p><span style="color:#fe2c24;">如果第k层的叶子为空，那就没有这个叶子！</span></p> 
<p><strong>代码</strong>：</p> 
<pre><code class="language-cpp">//第k层树的节点数 
int LeafKSize(TNode* root, int k)
{
	//第k层：左子树+右子树的叶子数
	if (root == NULL)
		return 0;
	if (k == 1)
		return 1;
	return LeafKSize(root-&gt;left, k - 1) + LeafKSize(root-&gt;right, k - 1);
}</code></pre> 
<h2 id="%E6%9F%A5%E6%89%BEx%E5%80%BC">查找x值</h2> 
<p>思路：<span style="color:#fe2c24;">先找左子树，如果有返回，没有再去右子树查找，有的话返回，没有返回空</span>。</p> 
<p><strong>代码</strong>：</p> 
<pre><code class="language-cpp">//查找值为x的节点
TNode* TreeFind(TNode* root, TDatatype x)
{
	if (root == NULL)
		return NULL;
	if (root-&gt;val == x)
		return root;
	TNode* node1 = TreeFind(root-&gt;left,x);
	//左子树没找到，就去右子树找
	if (node1)
		return node1;
	//在右子树找
	return TreeFind(root-&gt;right, x);
}</code></pre> 
<h2 id="%E5%8F%B6%E5%AD%90%E6%80%BB%E6%95%B0">叶子总数</h2> 
<p><strong>思路</strong>：<span style="color:#fe2c24;">叶子总数==左子树叶子总数+右子树叶子总数</span>。</p> 
<p><span style="color:#fe2c24;">我们要判断某个节点是不是叶子，这个节点的左右孩子是否都为NULL就行！</span></p> 
<p><strong>代码</strong>：</p> 
<pre><code class="language-cpp">//叶子数
int LeafSize(TNode* root)
{
	if (root == NULL)
		return 0;
	if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)
		return 1;
	return LeafSize(root-&gt;left) + LeafSize(root-&gt;right);
}</code></pre> 
<h2 id="%E5%B7%A6%EF%BC%88%E5%8F%B3%EF%BC%89%E5%AD%A9%E5%AD%90%E6%95%B0">左（右）孩子数</h2> 
<p>以统计左孩子数为例：</p> 
<p>我们知道：<span style="color:#fe2c24;">左孩子数==左子树中的左孩子数+右子树中的左孩子数</span></p> 
<p><strong>思路</strong>：</p> 
<p><span style="color:#fe2c24;">遍历左子树和右子树，如果有左孩子就记下来！</span></p> 
<p><strong>代码</strong>：</p> 
<pre><code class="language-cpp">//左孩子数
int LeftSize(TNode* root)
{
	int count = 0;
	if (root == NULL)
		return 0;
	else
	{
		//如果有左孩子，数量就存起来
		if (root-&gt;left)
			count++;
	}
	//遍历一遍，最后再加总数
	return LeftSize(root-&gt;left) + LeftSize(root-&gt;right) + count;
}</code></pre> 
<h2 id="%E6%A0%91%E7%9A%84%E9%94%80%E6%AF%81">树的销毁</h2> 
<p>销毁树节点要注意一个点就是：<span style="color:#fe2c24;">需要先销毁左子树节点，再销毁右子树节点，最后销毁根节点</span>！</p> 
<p><strong>代码</strong>：</p> 
<pre><code class="language-cpp">//二叉树的销毁
void TreeDestroy(TNode* root)
{
	if (root == NULL)
		return;
	TreeDestroy(root-&gt;left);
	TreeDestroy(root-&gt;right);
	free(root);
}</code></pre> 
<h2 id="%E6%80%BB%E4%BB%A3%E7%A0%81">总代码</h2> 
<p><strong>Tree.h文件</strong></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdlib.h&gt;


typedef int TDatatype;
typedef struct TreeNode
{
	struct TreeNode* left;
	struct TreeNode* right;
	TDatatype val;
}TNode;

//创建节点
TNode* BuyNode(TDatatype x);
//创建一个二叉树
TNode* CreateTree();
//前序遍历   根 左子树 右子树
void Preoder(TNode* root);
//中序遍历   左子树 根 右子树
void Inoder(TNode* root);
//后序遍历   左子树 右子树 根
void Afteroder(TNode* root);
//节点数
int TreeSize(TNode* root);
//叶子数
int LeafSize(TNode* root);
//第k层树的节点数 
int LeafKSize(TNode* root,int k);
//查找值为x的节点
TNode* TreeFind(TNode* root, TDatatype x);
//二叉树的销毁
void TreeDestroy(TNode* root);
//二叉树的高度
int HeightTree(TNode* root);
//左孩子数
int LeftSize(TNode* root);</code></pre> 
<p><strong>Tree.c文件</strong></p> 
<pre><code class="language-cpp">//创建节点
TNode* BuyNode(TDatatype x)
{
	TNode* node = (TNode*)malloc(sizeof(TNode));
	if (node == NULL)
	{
		perror("malloc failed!");
		return NULL;
	}
	node-&gt;val = x;
	node-&gt;left = node-&gt;right = NULL;
	return node;
}
//创建一个二叉树
TNode* CreateTree()
{
	TNode* node1 = BuyNode(1);
	TNode* node2 = BuyNode(2);
	TNode* node3 = BuyNode(3);
	TNode* node4 = BuyNode(4);
	TNode* node5 = BuyNode(5);
	TNode* node6 = BuyNode(6);

	node1-&gt;left = node2;
	node1-&gt;right = node4;
	node2-&gt;left = node3;
	node4-&gt;left = node5;
	node4-&gt;right = node6;

	return node1;
}
//前序遍历   根 左子树 右子树
void Preoder(TNode* root)
{
	if (root == NULL)
	{
		printf("N ");
		return;
	}
	printf("%d ", root-&gt;val);
	Preoder(root-&gt;left);
	Preoder(root-&gt;right);
}
//中序遍历   左子树 根 右子树
void Inoder(TNode* root)
{
	if (root == NULL)
	{
		printf("N ");
		return;
	}
	Inoder(root-&gt;left);
	printf("%d ", root-&gt;val);
	Inoder(root-&gt;right);
}
//后序遍历   左子树 右子树 根
void Afteroder(TNode* root)
{
	if (root == NULL)
	{
		printf("N ");
		return;
	}
	Afteroder(root-&gt;left);
	Afteroder(root-&gt;right);
	printf("%d ", root-&gt;val);
}
//节点数
int TreeSize(TNode* root)
{
	//每个部分可以看成：左子树+右子树+1（自身）
	return root == NULL ? 0 : TreeSize(root-&gt;left) +
		TreeSize(root-&gt;right) + 1;
}
//叶子数
int LeafSize(TNode* root)
{
	if (root == NULL)
		return 0;
	if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)
		return 1;
	return LeafSize(root-&gt;left) + LeafSize(root-&gt;right);
}
//第k层树的节点数 
int LeafKSize(TNode* root, int k)
{
	//第k层：左子树+右子树的叶子数
	if (root == NULL)
		return 0;
	if (k == 1)
		return 1;
	return LeafKSize(root-&gt;left, k - 1) + LeafKSize(root-&gt;right, k - 1);
}
//查找值为x的节点
TNode* TreeFind(TNode* root, TDatatype x)
{
	if (root == NULL)
		return NULL;
	if (root-&gt;val == x)
		return root;
	TNode* node1 = TreeFind(root-&gt;left,x);
	//左子树没找到，就去右子树找
	if (node1)
		return node1;
	//在右子树找
	return TreeFind(root-&gt;right, x);
}
//二叉树的销毁
void TreeDestroy(TNode* root)
{
	if (root == NULL)
		return;
	TreeDestroy(root-&gt;left);
	TreeDestroy(root-&gt;right);
	free(root);
}
//二叉树的高度
int HeightTree(TNode* root)
{
	//高的子树+1就是高度
	if (root == NULL)
		return 0;
	int leftheight = HeightTree(root-&gt;left);
	int rightHeight = HeightTree(root-&gt;right);
	return leftheight &gt; rightHeight ?
		leftheight + 1 : rightHeight + 1;
}
//左孩子数
int LeftSize(TNode* root)
{
	int count = 0;
	if (root == NULL)
		return 0;
	else
	{
		//如果有左孩子，数量就存起来
		if (root-&gt;left)
			count++;
	}
	//遍历一遍，最后再加总数
	return LeftSize(root-&gt;left) + LeftSize(root-&gt;right) + count;
}</code></pre> 
<p>这期递归较多，比较难理解，有难度！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a66e119ebac131f08269822b02c4afa3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringBoot Configuration Annotation Processor not configured 解决方案和详细问题分析以及作用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/58f52602e84a5fcbd643494a66d9122c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vscode编译和调试wsl环境的c语言程序</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>