<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;深度探索】AVL树与红黑树的原理与特性 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/85fcad116ac79d8cfe54991d053e6b94/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;深度探索】AVL树与红黑树的原理与特性">
  <meta property="og:description" content="🔥 个人主页：大耳朵土土垚 🔥 所属专栏：C&#43;&#43;从入门至进阶 这里将会不定期更新有关C/C&#43;&#43;的内容，欢迎大家点赞，收藏，评论🥳🥳🎉🎉🎉 前言 前面对map/multimap/set/multiset进行了简单的介绍，我们发现这几个容器有个共同点是：其底层都是按照二叉搜索树来实现的，但是二叉搜索树有其自身的缺陷，假如往树中插入的元素有序或者接近有序，二叉搜索树就会退化成单支树，时间复杂度会退化成O(N)，因此map、set等关联式容器的底层结构是对二叉树进行了平衡处理，即采用平衡树来实现。
而AVL树和红黑树是常用的自平衡二叉搜索树。它们在插入、删除和查找操作上具有较好的性能，并且在各种应用场景中被广泛使用。
文章目录 前言1.AVL树1.1 AVL树的定义1.2 AVL树的性质1.3 AVL树的节点 2.红黑树2.1 红黑树的定义2.2 红黑树的性质2.3 红黑树的节点 3.结语 1.AVL树 1.1 AVL树的定义 二叉搜索树虽可以缩短查找的效率，但如果数据有序或接近有序二叉搜索树将退化为单支树，查找元素相当于在顺序表中搜索元素，效率低下。因此，两位俄罗斯的数学家G.M.Adelson-Velskii和E.M.Landis在1962年发明了一种解决上述问题的方法：当向二叉搜索树中插入新结点后，如果能保证每个结点的左右子树高度之差的绝对值不超过1(需要对树中的结点进行调整)，即可降低树的高度，从而减少平均搜索长度，如下图所示，每个节点都有一个平衡因子：
该平衡因子是由左子树的高度减去右子树的高度得来的（当然也可以选择使用右子树的高度减去左子树的高度），当平衡因子的大小大于等于2或小于等于-2时，说明左右高度差超过1，就需要旋转来维持平衡，这也是平衡因子的作用。
1.2 AVL树的性质 一棵AVL树或者是空树，或者是具有以下性质的二叉搜索树：
它的左右子树都是AVL树左右子树高度之差(简称平衡因子)的绝对值不超过1(-1/0/1) 如果一棵二叉搜索树是高度平衡的，它就是AVL树。如果它有n个结点，其高度可保持在 O ( l o g 2 n ) O(log_2 n) O(log2​n)，搜索时间复杂度O( l o g 2 n log_2 n log2​n)
1.3 AVL树的节点 那么AVL树节点的内容除了左右子树的指针以及存储数据的类型，还需要保存该节点的平衡因子，也就是说AVL树每个节点都包含一个平衡因子，一旦该节点的平衡因子大于等于2或小于等于-2就需要进行旋转，维持平衡：
struct AVLTreeNode { AVLTreeNode&lt;T&gt;* _pLeft; AVLTreeNode&lt;T&gt;* _pRight; AVLTreeNode&lt;T&gt;* _pParent;//父节点指针 T _data;	//存储数据 int _bf; // 节点的平衡因子 //默认构造函数 AVLTreeNode(const T&amp; data = T()) : _pLeft(nullptr) , _pRight(nullptr) , _pParent(nullptr) , _data(data) , _bf(0) {} }; 除了平衡因子，我们发现每个节点都保存了父节点的指针，这是因为旋转或删除一个节点之后，父节点的平衡因子可能也需要改变，所以需要保存。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-27T14:58:08+08:00">
    <meta property="article:modified_time" content="2024-07-27T14:58:08+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;深度探索】AVL树与红黑树的原理与特性</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <div align="center"> 
 <img src="https://images2.imgbox.com/c6/41/qvLUFCEi_o.jpg" width="800"> 
</div> 
<center> 
 <strong><font color="orange">🔥 个人主页：<a href="https://blog.csdn.net/Renswc?type=blog">大耳朵土土垚</a></font></strong> 
</center> 
<center> 
 <strong><font color="orange">🔥 所属专栏：<a href="https://blog.csdn.net/renswc/category_12630230.html">C++从入门至进阶</a></font></strong> 
</center> 
<br> 
<center> 
 <strong> 这里将会不定期更新有关C/C++的内容，欢迎大家点赞，收藏，评论🥳🥳🎉🎉🎉 </strong> 
 <div align="center"> 
  <img src="https://images2.imgbox.com/6b/cd/ZTVFFohA_o.gif" width="800"> 
 </div> 
</center> 
<h2><a id="_10"></a>前言</h2> 
<p>  前面对<code>map/multimap/set/multiset</code>进行了简单的介绍，我们发现这几个容器有个共同点是：其底层都是按照二叉搜索树来实现的，但是二叉搜索树有其自身的缺陷，假如往树中插入的元素有序或者接近有序，二叉搜索树就会退化成单支树，时间复杂度会退化成O(N)，因此<code>map、set</code>等关联式容器的底层结构是对二叉树进行了平衡处理，即采用平衡树来实现。</p> 
<p>  而<mark>AVL树</mark>和<mark>红黑树</mark>是常用的自平衡二叉搜索树。它们在插入、删除和查找操作上具有较好的性能，并且在各种应用场景中被广泛使用。<br> </p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_10" rel="nofollow">前言</a></li><li><a href="#1AVL_15" rel="nofollow">1.AVL树</a></li><li><ul><li><a href="#11_AVL_16" rel="nofollow">1.1 AVL树的定义</a></li><li><a href="#12_AVL_23" rel="nofollow">1.2 AVL树的性质</a></li><li><a href="#13_AVL_29" rel="nofollow">1.3 AVL树的节点</a></li></ul> 
  </li><li><a href="#2_53" rel="nofollow">2.红黑树</a></li><li><ul><li><a href="#21__54" rel="nofollow">2.1 红黑树的定义</a></li><li><a href="#22__57" rel="nofollow">2.2 红黑树的性质</a></li><li><a href="#23__74" rel="nofollow">2.3 红黑树的节点</a></li></ul> 
  </li><li><a href="#3_101" rel="nofollow">3.结语</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1AVL_15"></a>1.AVL树</h2> 
<h3><a id="11_AVL_16"></a>1.1 AVL树的定义</h3> 
<p>  二叉搜索树虽可以缩短查找的效率，但如果数据有序或接近有序二叉搜索树将退化为单支树，查找元素相当于在顺序表中搜索元素，效率低下。因此，两位俄罗斯的数学家<code>G.M.Adelson-Velskii</code>和<code>E.M.Landis</code>在1962年发明了一种解决上述问题的方法：当向二叉搜索树中插入新结点后，如果能保证每个结点的左右子树高度之差的绝对值不超过1(需要对树中的结点进行调整)，即可降低树的高度，从而减少平均搜索长度，如下图所示，每个节点都有一个平衡因子：<br> <br></p> 
<div align="center"> 
 <img src="https://images2.imgbox.com/8f/43/iGjqsZly_o.png" width="800"> 
</div> 
<br> 
<blockquote> 
 <p>该平衡因子是由左子树的高度减去右子树的高度得来的（当然也可以选择使用右子树的高度减去左子树的高度），当平衡因子的大小大于等于2或小于等于-2时，说明左右高度差超过1，就需要旋转来维持平衡，这也是平衡因子的作用。</p> 
</blockquote> 
<h3><a id="12_AVL_23"></a>1.2 AVL树的性质</h3> 
<p>一棵AVL树或者是空树，或者是具有以下性质的二叉搜索树：</p> 
<ul><li>它的左右子树都是AVL树</li><li>左右子树高度之差(简称平衡因子)的绝对值不超过1(-1/0/1)</li></ul> 
<blockquote> 
 <p>如果一棵二叉搜索树是高度平衡的，它就是AVL树。如果它有n个结点，其高度可保持在<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          O 
         
        
          ( 
         
        
          l 
         
        
          o 
         
         
         
           g 
          
         
           2 
          
         
        
          n 
         
        
          ) 
         
        
       
         O(log_2 n) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>，搜索时间复杂度O(<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          l 
         
        
          o 
         
         
         
           g 
          
         
           2 
          
         
        
          n 
         
        
       
         log_2 n 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathnormal">n</span></span></span></span></span>)</p> 
</blockquote> 
<h3><a id="13_AVL_29"></a>1.3 AVL树的节点</h3> 
<p>那么AVL树节点的内容除了左右子树的指针以及存储数据的类型，还需要保存该节点的平衡因子，也就是说AVL树每个节点都包含一个平衡因子，一旦该节点的平衡因子大于等于2或小于等于-2就需要进行旋转，维持平衡：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">AVLTreeNode</span>
<span class="token punctuation">{<!-- --></span>
	AVLTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> _pLeft<span class="token punctuation">;</span>
	AVLTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> _pRight<span class="token punctuation">;</span>
	AVLTreeNode<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> _pParent<span class="token punctuation">;</span><span class="token comment">//父节点指针</span>
	T _data<span class="token punctuation">;</span>	<span class="token comment">//存储数据</span>
	<span class="token keyword">int</span> _bf<span class="token punctuation">;</span>   <span class="token comment">// 节点的平衡因子</span>

	<span class="token comment">//默认构造函数</span>
	<span class="token function">AVLTreeNode</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> data <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token operator">:</span> <span class="token function">_pLeft</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_pRight</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_pParent</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_data</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_bf</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>除了平衡因子，我们发现每个节点都保存了父节点的指针，这是因为旋转或删除一个节点之后，父节点的平衡因子可能也需要改变，所以需要保存。</p> 
</blockquote> 
<h2><a id="2_53"></a>2.红黑树</h2> 
<h3><a id="21__54"></a>2.1 红黑树的定义</h3> 
<p>  红黑树，是一种自平衡的二叉搜索树，它在每个结点上增加一个存储位表示结点的颜色来保持平衡，每个节点的颜色可以是Red或Black。</p> 
<h3><a id="22__57"></a>2.2 红黑树的性质</h3> 
<p>红黑树的节点可以是红色或黑色，满足以下性质：</p> 
<ul><li>根节点是黑色的。</li><li>如果一个节点是红色的，则它的两个子节点都是黑色的。</li><li>从任意节点到其每个叶子节点的路径上包含相同数量的黑色节点。</li><li>所有叶子节点（NIL节点，即空节点）是黑色的。</li></ul> 
<p>如下图：</p> 
<br> 
<div align="center"> 
 <img src="https://images2.imgbox.com/54/ea/RZjRNau9_o.png" width="800"> 
</div> 
<br> 
<p>  红黑树通过对任何一条从根到叶子的路径上各个结点颜色的限制，确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。</p> 
<blockquote> 
 <p>这是因为根据红黑树的性质，其最短路径如果存在则应该是全部都是黑节点，最长路径如果存在则应该是一黑一红交错的路径，这样最长路径是无论如何都不会大于最短路径的两倍，也就相当于最长路径不会大于其他任何路径的两倍，保证了红黑树的相对平衡。</p> 
</blockquote> 
<h3><a id="23__74"></a>2.3 红黑树的节点</h3> 
<pre><code class="prism language-cpp"><span class="token comment">// 节点的颜色</span>
<span class="token keyword">enum</span> <span class="token class-name">Color</span> <span class="token punctuation">{<!-- --></span> RED<span class="token punctuation">,</span> BLACK <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 红黑树节点的定义</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ValueType</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">RBTreeNode</span>
<span class="token punctuation">{<!-- --></span>
	
	RBTreeNode<span class="token operator">&lt;</span>ValueType<span class="token operator">&gt;</span><span class="token operator">*</span> _pLeft<span class="token punctuation">;</span>		<span class="token comment">// 节点的左孩子</span>
	RBTreeNode<span class="token operator">&lt;</span>ValueType<span class="token operator">&gt;</span><span class="token operator">*</span> _pRight<span class="token punctuation">;</span>			<span class="token comment">// 节点的右孩子</span>
	RBTreeNode<span class="token operator">&lt;</span>ValueType<span class="token operator">&gt;</span><span class="token operator">*</span> _pParent<span class="token punctuation">;</span> <span class="token comment">// 节点的双亲(红黑树需要旋转，为了实现简单给出该字段)</span>
	
	ValueType _data<span class="token punctuation">;</span>		<span class="token comment">//节点的值域</span>
	Color _color<span class="token punctuation">;</span>			<span class="token comment">// 节点的颜色</span>

	<span class="token comment">//默认构造函数</span>
	<span class="token function">RBTreeNode</span><span class="token punctuation">(</span><span class="token keyword">const</span> ValueType<span class="token operator">&amp;</span> data <span class="token operator">=</span> <span class="token function">ValueType</span><span class="token punctuation">(</span><span class="token punctuation">)</span>，Color color <span class="token operator">=</span> RED<span class="token punctuation">)</span>
		<span class="token operator">:</span> <span class="token function">_pLeft</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_pRight</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_pParent</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_data</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_color</span><span class="token punctuation">(</span>color<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>红黑树的节点与AVL树一样需要父节点的指针，因为红黑树在插入新节点或删除节点时会出现不满足红黑树性质的情况，这时红黑树需要旋转来维持相对平衡，为了实现简单给出父节点指针。</p> 
<p>此外对于默认构造函数，我们发现新增1一个节点默认给的是红色，这是因为如果给的是黑色，那么新增节点的路径上就多了一个黑色节点，为了满足红黑树所有路径上黑色节点数目相等就必须改变其他节点的颜色；而如果新增节点给的是红色，那么如果父节点是黑色我们就不需要做改动，如果父节点是红色我们才需要做改动，有一半的可能不需要改动，所以我们选择将新增节点默认设为为红色。</p> 
<h2><a id="3_101"></a>3.结语</h2> 
<p>  使用AVL树和红黑树时，可以按照二叉搜索树的规则进行插入、删除和查找操作。由于它们的自平衡特性，插入和删除操作可能需要进行旋转或颜色调整，以确保树的平衡性。这些操作可以保证树的高度保持在<code>O(logn)</code>，从而提供了较好的性能。<br>   在实际应用中，AVL树和红黑树都可以用于需要高效的插入、删除和查找操作的场景，例如数据库中的索引结构、编译器中的符号表等。在选择使用哪种树结构时，可以根据具体的应用需求和性能要求进行评估和选择。以上就是今天所有的内容啦~ 完结撒花~ 🥳🎉🎉</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f311c8fefc03769fc74f0d852b07f31c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue elementui 上传视频 以及上传视频失败重新上传没反应的处理方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c22d40ac8b2b028b544acaa86326e86e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">部署springboot项目到阿里云服务器(小白包会)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>