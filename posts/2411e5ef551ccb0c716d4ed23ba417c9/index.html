<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring Boot实战：拦截器 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/2411e5ef551ccb0c716d4ed23ba417c9/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Spring Boot实战：拦截器">
  <meta property="og:description" content="一.拦截器快速入门 1.1了解拦截器 什么是拦截器：
概念 ：拦截器是Spring框架提供的核⼼功能之⼀, 主要⽤来拦截⽤⼾的请求, 在指定⽅法前后, 根据业务需要执⾏预先设定的代码。 也就是说, 允许开发⼈员提前预定义⼀些逻辑, 在⽤⼾的请求响应前后执⾏. 也可以在⽤⼾请求前阻⽌其执⾏. 在拦截器当中，开发⼈员可以在应⽤程序中做⼀些通⽤性的操作, ⽐如通过拦截器来拦截前端发来的请求, 判断Session中是否有登录⽤⼾的信息. 如果有就可以放⾏, 如果没有就进⾏拦截. 想象一下你去一个需要门禁的办公楼，拦截器就像是那个门禁系统。当你（请求）想要进入办公楼（访问某个资源）时，门禁系统（拦截器）会先检查你是否符合条件（比如是否持有有效的门禁卡或是否已经通过身份验证）。如果符合条件，门禁系统会放行，让你进入办公楼；如果不符合条件，门禁系统会阻止你进入，并可能要求你进行其他操作（比如登记或联系相关人员）。
在SpringBoot中，拦截器就是这样一种机制，它可以在请求到达控制器之前或之后“拦截”请求，并根据预定义的规则对请求进行处理。
拦截器在SpringBoot中主要有以下几个作用：
身份验证和权限控制： 就像门禁系统检查门禁卡一样，拦截器可以检查用户的身份验证状态和权限。例如，当用户尝试访问一个需要登录才能查看的页面时，拦截器会检查用户是否已经登录。如果用户未登录，拦截器可以重定向用户到登录页面或返回错误信息。日志记录： 拦截器可以在请求到达控制器之前或之后记录日志信息。这对于监控和调试应用程序非常有用，因为它可以帮助你了解请求是如何被处理的，以及处理过程中发生了哪些事情。请求预处理和响应后处理： 在请求到达控制器之前，拦截器可以对请求进行预处理，比如修改请求参数、设置请求头等。在控制器处理完请求并生成响应后，拦截器还可以对响应进行后处理，比如修改响应头、添加额外的数据到响应中等。异常处理： 拦截器还可以捕获并处理请求处理过程中发生的异常。例如，如果控制器在处理请求时抛出了异常，拦截器可以捕获这个异常，并根据异常类型进行相应的处理，比如返回自定义的错误页面或错误信息。 1.2拦截器的基本使用
拦截器的使⽤步骤分为两步： 定义拦截器 注册配置拦截器 1.⾃定义拦截器：实现HandlerInterceptor接⼝，并重写其所有⽅法
@Slf4j @Component public class LoginInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { log.info(&#34;LoginInterceptor ⽬标⽅法执⾏前执⾏..&#34;); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { log.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-06T11:03:11+08:00">
    <meta property="article:modified_time" content="2024-08-06T11:03:11+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring Boot实战：拦截器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一.拦截器快速入门</h2> 
<h3 style="background-color:transparent;">1.1了解拦截器</h3> 
<p><strong>什么是拦截器</strong>：</p> 
<div> 
 <span style="color:#956fe7;"><strong>概念</strong></span> 
 <span style="color:#1f2329;">：拦截器是Spring框架提供的核⼼功能之⼀, 主要⽤来拦截⽤⼾的请求, 在指定⽅法前后, 根据业务需要执⾏预先设定的代码。</span> 
</div> 
<div></div> 
<div> 
 <div> 
  <span style="color:#0d0016;">也就是说, 允许开发⼈员提前预定义⼀些逻辑, 在⽤⼾的请求响应前后执⾏. 也可以在⽤⼾请求前阻⽌其执⾏. </span> 
 </div> 
 <div> 
  <span style="color:#0d0016;">在拦截器当中，开发⼈员可以在应⽤程序中做⼀些通⽤性的操作, ⽐如通过拦截器来拦截前端发来的请求, 判断Session中是否有登录⽤⼾的信息. 如果有就可以放⾏, 如果没有就进⾏拦截. </span> 
 </div> 
 <div> 
  <img alt="" height="445" src="https://images2.imgbox.com/d3/2c/OnVcuwri_o.png" width="1200"> 
 </div> 
</div> 
<blockquote> 
 <p><strong>想象一下你去一个需要门禁的办公楼，拦截器就像是那个门禁系统。当你（请求）想要进入办公楼（访问某个资源）时，门禁系统（拦截器）会先检查你是否符合条件（比如是否持有有效的门禁卡或是否已经通过身份验证）。如果符合条件，门禁系统会放行，让你进入办公楼；如果不符合条件，门禁系统会阻止你进入，并可能要求你进行其他操作（比如登记或联系相关人员）。</strong></p> 
 <p><span style="color:#0d0016;"><strong>在SpringBoot中，拦截器就是这样一种机制，它可以在请求到达控制器之前或之后“拦截”请求，并根据预定义的规则对请求进行处理。</strong></span></p> 
 <p> </p> 
</blockquote> 
<p><span style="background-color:#ffd900;">拦截器在SpringBoot中主要有以下几个作用：</span></p> 
<ol><li><strong>身份验证和权限控制</strong>： 
  <ul><li>就像门禁系统检查门禁卡一样，拦截器可以检查用户的身份验证状态和权限。例如，当用户尝试访问一个需要登录才能查看的页面时，拦截器会检查用户是否已经登录。如果用户未登录，拦截器可以重定向用户到登录页面或返回错误信息。</li></ul></li><li><strong>日志记录</strong>： 
  <ul><li>拦截器可以在请求到达控制器之前或之后记录日志信息。这对于监控和调试应用程序非常有用，因为它可以帮助你了解请求是如何被处理的，以及处理过程中发生了哪些事情。</li></ul></li><li><strong>请求预处理和响应后处理</strong>： 
  <ul><li>在请求到达控制器之前，拦截器可以对请求进行预处理，比如修改请求参数、设置请求头等。在控制器处理完请求并生成响应后，拦截器还可以对响应进行后处理，比如修改响应头、添加额外的数据到响应中等。</li></ul></li><li><strong>异常处理</strong>： 
  <ul><li>拦截器还可以捕获并处理请求处理过程中发生的异常。例如，如果控制器在处理请求时抛出了异常，拦截器可以捕获这个异常，并根据异常类型进行相应的处理，比如返回自定义的错误页面或错误信息。</li></ul></li></ol> 
<h4></h4> 
<p> 1.2拦截器的基本使用</p> 
<div> 
 <span style="color:#1f2329;">拦截器的使⽤步骤分为两步： </span> 
</div> 
<ol><li><strong><span style="color:#1456f0;"> </span><span style="color:#1f2329;">定义拦截器 </span></strong></li><li><strong><span style="color:#1f2329;">注册配置拦截器</span></strong></li></ol> 
<p><strong><span style="color:#1f2329;"><span style="background-color:#a2e043;">1.⾃定义拦截器：实现HandlerInterceptor接⼝，并重写其所有⽅法</span></span></strong></p> 
<pre><code class="language-java">@Slf4j
@Component
public class LoginInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse
            response, Object handler) throws Exception {
        log.info("LoginInterceptor ⽬标⽅法执⾏前执⾏..");
        return true;
    }
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse
            response, Object handler, ModelAndView modelAndView) throws Exception {
        log.info("LoginInterceptor ⽬标⽅法执⾏后执⾏");
    }
    @Override
    public void afterCompletion(HttpServletRequest request,
                                HttpServletResponse response, Object handler, Exception ex) throws Exception {
        log.info("LoginInterceptor 视图渲染完毕后执⾏，最后执⾏");
    }
}</code></pre> 
<p> </p> 
<ul><li><span style="color:#1f2329;"><strong>preHandle()⽅法</strong>：⽬标⽅法执⾏前执⾏. 返回true: 继续执⾏后续操作; 返回false: 中断后续操作. </span></li><li><span style="color:#1f2329;"><strong>postHandle()⽅法</strong>：⽬标⽅法执⾏后执⾏ </span></li><li><span style="color:#1f2329;"><strong>afterCompletion()⽅法</strong>：视图渲染完毕后执⾏，最后执⾏(后端开发现在⼏乎不涉及视图, 暂不了</span><span style="color:#1f2329;">解)</span></li></ul> 
<p><strong><span style="color:#1f2329;"><span style="background-color:#a2e043;">2.注册配置拦截器：实现WebMvcConfigurer接⼝，并重写addInterceptors⽅法</span></span><span style="background-color:#a2e043;"> </span></strong></p> 
<pre><code class="language-java">@Configuration
public class WebConfig implements WebMvcConfigurer {
    //⾃定义的拦截器对象
    @Autowired
    private LoginInterceptor loginInterceptor;
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //注册⾃定义拦截器对象
        registry.addInterceptor(loginInterceptor)
                .addPathPatterns("/**");//设置拦截器拦截的请求路径（ /** 表⽰拦截所
        有请求）
    }
}
</code></pre> 
<div> 
 <strong><span style="color:#1f2329;"><span style="background-color:#a2e043;">3.启动服务, 试试访问任意请求, 观察后端⽇志</span></span></strong> 
</div> 
<div> 
 <img alt="" height="384" src="https://images2.imgbox.com/cc/19/ZBRh4tif_o.png" width="1200"> 
</div> 
<div> 
 <span style="color:#1f2329;">可以看到preHandle ⽅法执⾏之后就放⾏了, 开始执⾏⽬标⽅法, ⽬标⽅法执⾏完成之后执⾏ </span> 
</div> 
<div> 
 <span style="color:#1f2329;"><strong>postHandle</strong>和<strong>afterCompletion</strong>⽅法.</span> 
</div> 
<div></div> 
<div> 
 <div> 
  <strong><span style="color:#1f2329;"><span style="background-color:#a2e043;">4.我们把拦截器中preHandle⽅法的返回值改为false, 再观察运⾏结果</span></span></strong> 
 </div> 
 <div> 
  <img alt="" height="160" src="https://images2.imgbox.com/95/10/4zzSLd49_o.png" width="1200"> 
 </div> 
</div> 
<p><span style="color:#1f2329;">可以看到, 拦截器拦截了请求, 没有进⾏响应.</span></p> 
<h3 style="background-color:transparent;">1.2拦截器详解</h3> 
<p> </p> 
<div> 
 <span style="color:#1f2329;">拦截器的⼊⻔程序完成之后，接下来我们来介绍拦截器的使⽤细节。拦截器的使⽤细节我们主要介绍 </span> 
</div> 
<div> 
 <span style="color:#1f2329;">两个部分： </span> 
</div> 
<ol><li><strong><span style="color:#1f2329;">拦截器的拦截路径配置 </span></strong></li><li><strong><span style="color:#1f2329;">拦截器实现原理</span></strong></li></ol> 
<p> </p> 
<div> 
 <span style="color:#1f2329;">拦截路径是指我们定义的这个拦截器, 对哪些请求⽣效. </span> 
</div> 
<div> 
 <span style="color:#1f2329;">我们在注册配置拦截器的时候, 通过 </span> 
 <strong><span style="color:#1f2329;">addPathPatterns() </span></strong> 
 <span style="color:#1f2329;">⽅法指定要拦截哪些请求. 也可以通过 </span> 
</div> 
<div> 
 <strong><span style="color:#1f2329;">excludePathPatterns() </span></strong> 
 <span style="color:#1f2329;">指定不拦截哪些请求. </span> 
</div> 
<div></div> 
<blockquote> 
 <div> 
  <span style="color:#0d0016;"><strong>上述代码中, 我们配置的是 /** , 表⽰拦截所有的请求. </strong></span> 
 </div> 
</blockquote> 
<div></div> 
<div> 
 <span style="color:#1f2329;">⽐如⽤⼾登录校验, 我们希望可以对除了登录之外所有的路径⽣效。</span> 
</div> 
<div> 
 <pre><code class="language-java">import org.springframework.beans.factory.annotation.Autowired;
        import org.springframework.context.annotation.Configuration;
        import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
        import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
@Configuration
public class WebConfig implements WebMvcConfigurer {
    //⾃定义的拦截器对象
    @Autowired
    private LoginInterceptor loginInterceptor;
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //注册⾃定义拦截器对象
        registry.addInterceptor(loginInterceptor)
                .addPathPatterns("/**")
                .excludePathPatterns("/user/login");//设置拦截器拦截的请求路径
        (/** 表⽰拦截所有请求)
         }
  }</code></pre> 
 <div> 
  <div> 
   <span style="color:#1f2329;">在拦截器中除了可以设置 </span> 
   <span style="color:#1f2329;">/** </span> 
   <span style="color:#1f2329;">拦截所有资源外，还有⼀些常⻅拦截路径设置： </span> 
  </div> 
  <div> 
   <img alt="" height="387" src="https://images2.imgbox.com/2f/9a/JrQdaL1y_o.png" width="1148"> 
  </div> 
  <blockquote> 
   <div> 
    <span style="color:#0d0016;"><strong>以上拦截规则可以拦截此项⽬中的使⽤ URL，包括静态⽂件(图⽚⽂件, JS 和 CSS 等⽂件)</strong></span> 
   </div> 
  </blockquote> 
 </div> 
 <div></div> 
 <h3 style="background-color:transparent;"><span style="color:#1f2329;">1.3拦截器执行流程</span></h3> 
 <div> 
  <span style="color:#1f2329;">正常的调⽤顺序: </span> 
 </div> 
 <div> 
  <img alt="" height="651" src="https://images2.imgbox.com/86/6f/00LtMMYs_o.png" width="827"> 
 </div> 
 <div></div> 
 <div></div> 
</div> 
<p> <span style="color:#1f2329;">有了拦截器之后，会在调⽤ Controller 之前进⾏相应的业务处理，执⾏的流程如下图</span></p> 
<p><img alt="" height="681" src="https://images2.imgbox.com/2d/29/F5GnndQV_o.png" width="902"> </p> 
<div> 
 <strong><span style="color:#1f2329;">1.添加拦截器后, 执⾏Controller的⽅法之前, 请求会先被拦截器拦截住. 执⾏ </span><span style="color:#1f2329;">preHandle() </span><span style="color:#1f2329;">⽅法， </span></strong> 
</div> 
<div> 
 <strong><span style="color:#1f2329;">这个⽅法需要返回⼀个布尔类型的值. 如果返回true, 就表⽰放⾏本次操作, 继续访问controller中的</span></strong> 
 <strong><span style="color:#1f2329;">⽅法. 如果返回false，则不会放⾏(controller中的⽅法也不会执⾏). </span></strong> 
</div> 
<div></div> 
<div> 
 <div> 
  <strong><span style="color:#1f2329;">2.controller当中的⽅法执⾏完毕后，再回过来执⾏ </span><span style="color:#1f2329;">postHandle() </span><span style="color:#1f2329;">这个⽅法以afterCompletion() ⽅法，执⾏完毕之后，最终给浏览器响应数据. </span></strong> 
 </div> 
 <div></div> 
</div> 
<h3> 1.4<span style="color:#1f2329;">登录校验</span></h3> 
<div> 
 <span style="color:#1f2329;">学习拦截器的基本操作之后，接下来我们需要完成最后⼀步操作：通过拦截器来完成图书管理系统中的登录校验功能.</span> 
</div> 
<div> 
 <strong><span style="background-color:#a2e043;">1.定义拦截器</span></strong> 
</div> 
<div> 
 <div> 
  <strong><span style="color:#1f2329;">从session中获取⽤⼾信息, 如果session中不存在, 则返回false,并设置http状态码为401, 否则返回true. </span></strong> 
 </div> 
 <div> 
  <pre><code class="language-java">import com.example.demo.constant.Constants;
        import lombok.extern.slf4j.Slf4j;
        import org.springframework.stereotype.Component;
        import org.springframework.web.servlet.HandlerInterceptor;
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;
        import javax.servlet.http.HttpSession;
@Slf4j
@Component
public class LoginInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse
            response, Object handler) throws Exception {
        HttpSession session = request.getSession(false);
        if (session != null &amp;&amp;
                session.getAttribute(Constants.SESSION_USER_KEY) != null) {
            return true;
        }
        response.setStatus(401);
        return false;
    }
}
</code></pre> 
  <blockquote> 
   <div> 
    <strong><span style="color:#646a73;">http状态码401: Unauthorized </span></strong> 
   </div> 
   <div></div> 
   <div> 
    <span style="color:#646a73;">Indicates that authentication is required and was either not provided or has failed. If the </span> 
   </div> 
   <div> 
    <span style="color:#646a73;">request already included authorization credentials, then the 401 status code indicates that </span> 
   </div> 
   <div> 
    <span style="color:#646a73;">those credentials were not accepted. </span> 
   </div> 
   <div> 
    <span style="color:#0d0016;"><strong>中⽂解释: 未经过认证. 指⽰⾝份验证是必需的, 没有提供⾝份验证或⾝份验证失败. 如果请求已经包含授权凭据，那么401状态码表⽰不接受这些凭据</strong></span> 
   </div> 
  </blockquote> 
 </div> 
</div> 
<p><strong><span style="background-color:#a2e043;">2.</span><span style="color:#1f2329;"><span style="background-color:#a2e043;">注册配置拦截器</span></span></strong></p> 
<p> </p> 
<pre><code class="language-java">import org.springframework.beans.factory.annotation.Autowired;
        import org.springframework.context.annotation.Configuration;
        import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
        import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
@Configuration
public class WebConfig implements WebMvcConfigurer {
    //⾃定义的拦截器对象
    @Autowired
    private LoginInterceptor loginInterceptor;
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //注册⾃定义拦截器对象
        registry.addInterceptor(loginInterceptor)
                .addPathPatterns("/**")//设置拦截器拦截的请求路径(/**表⽰拦截所有请
        求)
 .excludePathPatterns("/user/login")//设置拦截器排除拦截的路径
                .excludePathPatterns("/**/*.js") //排除前端静态资源
                .excludePathPatterns("/**/*.css")
                .excludePathPatterns("/**/*.png")
                .excludePathPatterns("/**/*.html");
    }
}
</code></pre> 
<div> 
 <strong><span style="color:#1f2329;"><span style="background-color:#a2e043;">3.删除之前的登录校验代码 </span></span></strong> 
</div> 
<div> 
 <pre><code class="language-java">    @RequestMapping("/getListByPage")
    public Result getListByPage(PageRequest pageRequest, HttpSession session) {
        log.info("获取图书列表, pageRequest:{}", pageRequest);
// //判断⽤⼾是否登录
// if (session.getAttribute(Constants.SESSION_USER_KEY)==null){
// return Result.unlogin();
// }
// UserInfo userInfo = (UserInfo) 
        session.getAttribute(Constants.SESSION_USER_KEY);
// if (userInfo==null || userInfo.getId()&lt;0 || 
        "".equals(userInfo.getUserName())){
// return Result.unlogin();
// }
            //⽤⼾登录, 返回图书列表
            PageResult&lt;BookInfo&gt; pageResult =
                    bookService.getBookListByPage(pageRequest);
            log.info("获取图书列表222, pageRequest:{}", pageResult);
            return Result.success(pageResult);
        }</code></pre> 
 <p><strong><span style="background-color:#a2e043;">4</span><span style="color:#1f2329;"><span style="background-color:#a2e043;">运⾏程序, 通过Postman进⾏测试:</span></span></strong></p> 
 <p><strong><span style="background-color:#4da8ee;">4.1</span><span style="color:#1f2329;"><span style="background-color:#4da8ee;">查看图书列表 </span></span></strong></p> 
 <p><img alt="" height="328" src="https://images2.imgbox.com/65/a3/lgzW70Ry_o.png" width="1200"></p> 
 <div> 
  <span style="color:#1f2329;">观察返回结果: h </span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">也可以通过Fiddler抓包观察</span> 
  <img alt="" height="592" src="https://images2.imgbox.com/b5/74/9nPueqlJ_o.png" width="1200"> 
 </div> 
 <p><strong><span style="background-color:#4da8ee;">4.2</span><span style="color:#1f2329;"><span style="background-color:#4da8ee;">登录</span></span></strong></p> 
</div> 
<p><img alt="" height="430" src="https://images2.imgbox.com/9f/de/Ve9CdvWp_o.png" width="1200"></p> 
<p><strong><span style="background-color:#4da8ee;">4.3</span><span style="color:#1f2329;"><span style="background-color:#4da8ee;">再次查看图书列表</span></span><span style="background-color:#4da8ee;"> </span></strong></p> 
<div> 
 <span style="color:#1f2329;">数据进⾏了返回</span> 
</div> 
<div> 
 <img alt="" height="740" src="https://images2.imgbox.com/cd/25/SvlOBJ5m_o.png" width="1128"> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a6b94482fc7d2c59fcf181d663441fb9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于C#调用文心一言大模型制作桌面软件(可改装接口)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c778eb3cd5e218b11de02d7f62369028/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据结构】哈希表</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>