<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】第十八弹---C语言实现堆排序 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4c0aee77b09f1a787cf392ea505e8f2d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】第十八弹---C语言实现堆排序">
  <meta property="og:description" content="✨个人主页： 熬夜学编程的小林
💗系列专栏： 【C语言详解】 【数据结构详解】【C&#43;&#43;详解】
目录
1、堆排序
1.1、基本思想
1.2、初步代码实现
1.3、代码优化
1.4、代码测试
总结
1、堆排序 在博主数据结构第十二弹---堆的应用有详细讲解堆排序喔~~~
数据结构第十二弹---堆的应用https://blog.csdn.net/2201_75584283/article/details/135348207https://blog.csdn.net/2201_75584283/article/details/135348207
1.1、基本思想 堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。它是通过堆来进行选择数据。需要注意的是排升序要建大堆，排降序建小堆。
为什么升序用到的是大堆呢？
因为：大堆的堆顶是最大的数，可以将其放在数组尾，然后再通过向下调整算法找到次大的数。而小堆的堆顶是最小的数，需要放在第一个位置，如果用原来的堆找不到次小的数，而重新建堆则会更加繁琐。
降序用小堆同理。
动图如下：
1.2、初步代码实现 堆排序的实现可以分为两部分：构建最大堆（或最小堆）和执行排序过程。
注意：此处我们实现的是大堆！！！
第一步：建堆
我们此处是对数组内部的数进行排序，那么怎样才能创建成大堆呢？
这里我们可以使用向上调整算法，从第二个数开始遍历数组，如果不满足大堆则交换父子元素。
for (int i = 1; i &lt; n; i&#43;&#43;) { AjustUp(a, i); } 大堆向上调整：
将被调整的数值与其父节点比较，若是大于父节点，则与父节点交换。若子节点下标为child，父节点下标为(child - 1) / 2。当子节点小于父节点时，或者当子节点已经为堆顶时，停止比较。 代码实现：
void AdjustUp(int* a, int child) { int parent = 0; while (child &gt; 0) { parent = (child - 1) / 2; if (a[child] &gt; a[parent]) { Swap(&amp;a[child], &amp;a[parent]); child = parent; } else { break; } } } 小堆向上调整：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-20T11:51:27+08:00">
    <meta property="article:modified_time" content="2024-06-20T11:51:27+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】第十八弹---C语言实现堆排序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" src="https://images2.imgbox.com/7e/69/2CNF0uDb_o.jpg"></p> 
<p style="text-align:center;">✨<span style="color:#956fe7;">个人主页：</span><a href="https://blog.csdn.net/2201_75584283?spm=1011.2415.3001.5343" title=" 熬夜学编程的小林"> 熬夜学编程的小林</a></p> 
<p style="text-align:center;">💗<span style="color:#fe2c24;">系列专栏：</span> <a href="https://blog.csdn.net/2201_75584283/category_12556736.html" title="【C语言详解】">【C语言详解】</a> <a href="https://blog.csdn.net/2201_75584283/category_12556751.html" title="【数据结构详解】">【数据结构详解】</a><a href="https://blog.csdn.net/2201_75584283/category_12577595.html?spm=1001.2014.3001.5482" title="【C++详解】">【C++详解】</a></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="1.3%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F-toc" style="margin-left:0px;"><a href="#1.3%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F" rel="nofollow">1、堆排序</a></p> 
<p id="1.3.1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-toc" style="margin-left:40px;"><a href="#1.3.1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3" rel="nofollow">1.1、基本思想</a></p> 
<p id="1.3.2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#1.3.2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">1.2、初步代码实现</a></p> 
<p id="%C2%A02.3%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96-toc" style="margin-left:40px;"><a href="#%C2%A02.3%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96" rel="nofollow">1.3、代码优化</a></p> 
<p id="%C2%A01.3.3%E3%80%81%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95-toc" style="margin-left:40px;"><a href="#%C2%A01.3.3%E3%80%81%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95" rel="nofollow">1.4、代码测试</a></p> 
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.3%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F">1、堆排序</h2> 
<p><strong>在博主数据结构第十二弹---堆的应用有详细讲解堆排序喔~~~</strong></p> 
<p><strong><strong><strong><strong><a class="has-card" href="https://blog.csdn.net/2201_75584283/article/details/135348207" title="数据结构第十二弹---堆的应用https://blog.csdn.net/2201_75584283/article/details/135348207"><span class="link-card-box"><span class="link-title">数据结构第十二弹---堆的应用https://blog.csdn.net/2201_75584283/article/details/135348207</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/f6/80/pip8TJDG_o.png" alt="icon-default.png?t=N7T8">https://blog.csdn.net/2201_75584283/article/details/135348207</span></span></a></strong></strong></strong></strong></p> 
<h3 id="1.3.1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">1.1、基本思想</h3> 
<blockquote> 
 <p>堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。它是通过堆来进行选择数据。需要注意的是<strong>排升序要建大堆，排降序建小堆</strong>。</p> 
</blockquote> 
<p></p> 
<p>为什么升序用到的是大堆呢？</p> 
<blockquote> 
 <p><strong>因为：大堆的堆顶是最大的数，可以将其放在数组尾，然后再通过向下调整算法找到次大的数。而小堆的堆顶是最小的数，需要放在第一个位置，如果用原来的堆找不到次小的数，而重新建堆则会更加繁琐。</strong></p> 
</blockquote> 
<p></p> 
<p><strong>降序用小堆同理。</strong></p> 
<p></p> 
<p>动图如下：</p> 
<p><img alt="" src="https://images2.imgbox.com/ff/2a/4kzR4zEL_o.gif"></p> 
<p></p> 
<h3 id="1.3.2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">1.2、初步代码实现</h3> 
<blockquote> 
 <p><strong>堆排序的实现可以分为两部分：构建最大堆（或最小堆）和执行排序过程。</strong></p> 
</blockquote> 
<p><strong>注意：此处我们实现的是大堆！！！</strong></p> 
<p><strong>第一步：建堆</strong></p> 
<p>我们此处是对数组内部的数进行排序，那么怎样才能创建成大堆呢？</p> 
<blockquote> 
 <p>这里我们可以使用<strong>向上调整算法</strong>，从第二个数开始遍历数组，如果不满足大堆则交换父子元素。</p> 
</blockquote> 
<p></p> 
<pre><code>for (int i = 1; i &lt; n; i++)
{
	AjustUp(a, i);
}
</code></pre> 
<p><strong>大堆向上调整：</strong></p> 
<ol><li>将被调整的数值与其父节点比较，若是大于父节点，则与父节点交换。</li><li>若子节点下标为child，父节点下标为(child - 1) / 2。</li><li>当子节点小于父节点时，或者当子节点已经为堆顶时，停止比较。</li></ol> 
<p><strong>代码实现：</strong></p> 
<pre><code>void AdjustUp(int* a, int child)
{
	int parent = 0;
	while (child &gt; 0)
	{
		parent = (child - 1) / 2;
		if (a[child] &gt; a[parent])
		{
			Swap(&amp;a[child], &amp;a[parent]);
			child = parent;
		}
		else
		{
			break;
		}
	}
}
</code></pre> 
<p><strong>小堆向上调整：</strong></p> 
<blockquote> 
 <p> 与向下调整大堆思想的唯一区别就是：将被调整的数值与父节点比较，若是小于父节点，则与父节点交换，将小根堆比较条件改为小于即可</p> 
</blockquote> 
<pre><code>if (a[child] &lt; a[parent])//孩子小于父亲则交换
{
    ...
}</code></pre> 
<p><strong>每次向上调整算法的时间复杂度为O(log N)。 </strong></p> 
<p><strong>​ 所以使用向上调整建好堆的时间复杂度为(N*log N)</strong></p> 
<p></p> 
<p><strong>第二步：执行排序操作</strong></p> 
<p>进行了向上调整之后，此时的数组就是一个大堆了，要怎样才能达到升序呢？</p> 
<blockquote> 
 <ol><li>使用大根堆选出最大的数，放在数组的最后一个位置，依次选出进行排序。</li><li>将堆顶和最后一个数交换。</li><li>然后将新堆顶向下调整，形成堆。</li><li>向下调整时，注意交换后的最后位置不在新堆里，所以要下标要减一。</li><li>没有对堆结构造成破坏，不用对每个数都调整。</li></ol> 
</blockquote> 
<pre><code>//2.向下调整 O(N*logN)
int end = n - 1;
while (end &gt; 0) //从最后一个位置开始交换并调整
{
	Swap(&amp;arr[0], &amp;arr[end]);
	AdjustDown(arr, end, 0);//此处为大根堆向下调整方式
	end--;
}</code></pre> 
<p><strong> 大堆向下调整：</strong></p> 
<blockquote> 
 <ol><li>将被调整的数值与其最大的子节点比较，若是小于最大的子节点，则与该子节点交换。</li><li>若父节点下标为parent，左子节点下标为 parent * 2 + 1，右子节点的下标为 parent * 2 + 2。</li><li>获取最大的子节点时，可以先将左子节点作为最大节点，再与右子节点比较，若是大于右子节点，则将左子节点下标加1得到右子节点下标。</li><li>再循环体内比较左右子节点之前，要先判断右子节点存在，防止堆最后一个节点是左子节点造成越界访问。</li><li>当子节点小于父节点时，或者当子节点超过堆的范围时，停止比较。</li></ol> 
</blockquote> 
<p><img alt="" height="759" src="https://images2.imgbox.com/12/e0/f2h0dO1v_o.png" width="1200"></p> 
<pre><code>//向下调整算法 大堆
void AdjustDown(int* a, int size, int parent)
{
	//1.假设左孩子为小的数据
	int child = parent * 2 + 1;
	while (child &lt; size)
	{
		//2.如果左孩子&gt;右孩子 则将右孩子赋值
		//有可能只有左孩子 所以加条件
		//以下未有左右孩子且左孩子&gt;右孩子情况，则将child++
		if (child + 1 &lt; size &amp;&amp; a[child] &lt; a[child + 1])
		{
			child++;
		}
		//3.将孩子与父亲进行比较 如果孩子小则交换
		//然后将父亲和孩子移动到下一个位置
		if (a[child] &gt; a[parent])
		{
			Swap(&amp;a[child], &amp;a[parent]);
			parent = child;
			child = parent * 2 + 1;
		}
		else
		{
			break;
		}
	}
}</code></pre> 
<p><strong>小堆向下调整：</strong></p> 
<blockquote> 
 <p></p> 
 <ol><li>将被调整的数值与其最小的子节点比较，若是大于最小的子节点，则与该子节点交换。</li><li>将小根堆向下调整时左右子节点的比较条件和父节点与子节点的比较改为小于即可。</li></ol> 
</blockquote> 
<pre><code>if (child + 1 &lt; size &amp;&amp; a[child] &gt; a[child + 1])
{
	...	
}

if (a[child] &lt; a[parent])
{
    ...
}</code></pre> 
<p><strong>堆排序的代码如下：</strong></p> 
<pre><code>void HeapSort(int arr[], int n)
{
	assert(arr);
	//1.建堆 向上调整 O(N*logN)
	for (int i = 1; i &lt; size; i++)
	{
		AdjustUp(arr, i);
	}
	//2.向下调整 O(N*logN)
	int end = n - 1;
	while (end &gt; 0)
	{
		Swap(&amp;arr[0], &amp;arr[end]);
		AdjustDown(arr, end, 0);
		end--;
	}
}</code></pre> 
<h3 id="%C2%A02.3%E3%80%81%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96">1.3、代码优化</h3> 
<blockquote> 
 <p>在建堆的时候，我们既可以使用向上调整算法建堆，也可以使用向下调整算法建堆，在堆的应用那一弹我们计算了向下调整算法建堆的时间复杂度，对整个数组进行向下调整的时间复杂度是O(N)，因此我们在堆排序的时候也可以<strong>统一使用向下调整算法！！！</strong></p> 
</blockquote> 
<p><strong>向下调整：</strong></p> 
<ol><li>向下调整是从后往前调整，先将后面构成堆，再调整上面的节点。</li><li>以叶子节点作为根进行向下调整是完全没有必要的，叶子节点没有子节点，所以对最后一个叶子节点的父节点开始向下调整。</li><li>最后一个节点下标是n-1，它的父节点为 (n-1-1) / 2。</li></ol> 
<p><img alt="" height="737" src="https://images2.imgbox.com/9b/85/kRzVw68G_o.png" width="1200"></p> 
<pre><code>//1.向下调整建堆 O(N)
for (int i = (n - 1 - 1) / 2; i &gt;= 0; i--)//从n-2 到 0 进行调整
{
	AdjustDown(arr, n, i);
}
</code></pre> 
<p> </p> 
<p><strong>堆排序代码如下：</strong></p> 
<pre><code>void HeapSort(int arr[], int n)
{
	assert(arr);
	//1.向下调整建堆 O(N)
    for (int i = (n - 1 - 1) / 2; i &gt;= 0; i--)//从n-2 到 0 进行调整
    {
	    AdjustDown(arr, n, i);
    }
	//2.向下调整 O(N*logN)
	int end = n - 1;
	while (end &gt; 0)
	{
		Swap(&amp;arr[0], &amp;arr[end]);
		AdjustDown(arr, end, 0);
		end--;
	}
}</code></pre> 
<p></p> 
<h3 id="%C2%A01.3.3%E3%80%81%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95">1.4、代码测试</h3> 
<p>测试代码：</p> 
<pre><code>//测试堆排序
int main()
{
	int a[] = { 9,8,7,6,5,4,3,2,1,0 };//给一组数据
	int sz = sizeof(a) / sizeof(a[0]);//计算数组元素个数
	printf("排序前：\n");
	ArrayPrint(a, sz);
	HeapSort(a, sz);
	printf("排序后：\n");
	ArrayPrint(a, sz);
	return 0;
}</code></pre> 
<p>测试结果：</p> 
<p> <img alt="" height="416" src="https://images2.imgbox.com/60/be/TvzGguBz_o.png" width="740"></p> 
<p>堆排序的特性总结：</p> 
<blockquote> 
 <p>1. 堆排序使用堆来选数，效率就高了很多。<br> 2. 时间复杂度：O(N*logN)。<br> 3. 空间复杂度：O(1)。<br> 4. 稳定性：不稳定。</p> 
 <p>5. 复杂性：复杂。</p> 
</blockquote> 
<p></p> 
<h2 id="%E6%80%BB%E7%BB%93">总结</h2> 
<p>本篇博客就结束啦，谢谢大家的观看，如果公主少年们有好的建议可以留言喔，谢谢大家啦！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c8cec38c4e9859b26d84fc476935d120/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">bash: nvcc: command not found</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/089eae739c176592c938ad9a234b1cc7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">吴恩达：从 Agent 到 Agentic，超越基础模型的下一代 AI</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>