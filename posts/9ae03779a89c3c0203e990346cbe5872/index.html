<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【排序算法】—— 计数排序 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/9ae03779a89c3c0203e990346cbe5872/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【排序算法】—— 计数排序">
  <meta property="og:description" content="一、简介 计数排序，顾名思义就是记录数据出现的次数进行排序，时间复杂度为O(N&#43;K)，空间复杂度为O(N)。只能用于整型，对于比较集中重复率比较高数据更为适用。
二、排序原理 比如对接下来这些数进行排序
arr[11] = { 8,6,4,1,6,2,9,6,2,4,3 }
定义一个tmp用来记录数字出现的次数，那么tmp的长度可以设为需要排序的最大的数字加1，因为我们要做的是用下标来表示这个数，
比如tmp[6]=2，其中下标6表示6这个数字，2表示出现两次
所以得先把tmp初始化为0，然后进行计数，比如第一个数字为1那么就在1下标位置加1，以此类推遍历完数组arr。然后根据每个数出现的个数依次赋值给原数组arr。
#include&lt;stdio.h&gt; int main() { int arr[11] = { 8,6,4,1,6,2,9,6,2,4,3 }; int tmp[10] = { 0 }; for (int i = 0; i &lt; 11; i&#43;&#43;) tmp[arr[i]]&#43;&#43;; for (int i = 0, j = 0; i &lt; 10; i&#43;&#43;) { while (tmp[i]--) { arr[j&#43;&#43;] = i; } } for (int i = 0; i &lt; 11; i&#43;&#43;) printf(&#34;%d &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-18T19:13:00+08:00">
    <meta property="article:modified_time" content="2024-07-18T19:13:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【排序算法】—— 计数排序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、简介</h2> 
<p>        计数排序，顾名思义就是<span style="color:#fe2c24;">记录数据出现的次数</span>进行排序，<u><strong>时间复杂度为O(N+K)</strong></u>，<strong><u>空间复杂度为O(N)</u></strong>。<span style="color:#ff9900;">只能用于整型，对于比较集中重复率比较高数据更为适用</span>。</p> 
<h2>二、排序原理</h2> 
<p>比如对接下来这些数进行排序</p> 
<p>                arr[11] = { 8,6,4,1,6,2,9,6,2,4,3 }</p> 
<p>        定义一个tmp用来记录数字出现的次数，那么tmp的长度可以设为需要排序的最大的数字加1，因为我们要做的是用<span style="color:#ff9900;">下标来表示这个数</span>，</p> 
<p>                比如tmp[6]=2，其中下标6表示6这个数字，2表示出现两次</p> 
<p>        所以得先把tmp初始化为0，然后进行计数，比如第一个数字为1那么就在1下标位置加1，以此类推遍历完数组arr。然后根据每个数出现的个数依次赋值给原数组arr。</p> 
<p><img alt="" height="612" src="https://images2.imgbox.com/8c/f8/WZ5CCr0b_o.gif" width="672"></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
int main()
{
	int arr[11] = { 8,6,4,1,6,2,9,6,2,4,3 };
	int tmp[10] = { 0 };
	for (int i = 0; i &lt; 11; i++)
		tmp[arr[i]]++;
	for (int i = 0, j = 0; i &lt; 10; i++)
	{
		while (tmp[i]--)
		{
			arr[j++] = i;
		}
	}
	for (int i = 0; i &lt; 11; i++)
		printf("%d ", arr[i]);
	return 0;
}</code></pre> 
<p>        那这些数据比较大呢，比如下面这组数据<br>                 {1004 1003 1000 1015 1004 1004 1012 1006 1003 1014}<br>         需要申请长为1015的数组大小吗？<br>         其实并不需要，只需要申请长度为16的数组进行记录就行，记录的时候先减去1000，等赋值给原数组的时候再加回去就行。</p> 
<p>        所以到底如何考虑申请多少空间呢？，其实只需要最大的值减最小的值再加1的长度的数组空间就够用了。同样在记录时先减去最小值，等赋值给原数组的时候再加回去。</p> 
<pre><code class="language-cpp">void Sort(int* arr, int size)
{
	int max = arr[0], min = arr[0];
	for (int i = 0; i &lt; size; i++)
	{
		if (max &lt; arr[i])
			max = arr[i];
		if (min &gt; arr[i])
			min = arr[i];
	}
	int ret = max - min + 1;
	int* tmp = (int*)calloc(ret,sizeof(int));
	assert(tmp);
	for (int i = 0; i &lt; size; i++)
		tmp[arr[i]-min]++;
	for (int i = 0, j = 0; i &lt; ret; i++)
	{
		while (tmp[i]--)
			arr[j++] = i + min;
	}
}</code></pre> 
<h2>三、适用范围</h2> 
<p>        计数排序的缺点就是只能对整型数据进行排序，不能对字符，浮点形还有结构体类型进行排序。而且对于整形的排序他更适合的是最小值和最大值跨度比较小的数据，或者重复率比较高的数据。比如10个整数最小的是1最大的那个是100万。使用计数排序就会导致空间的开销很大，效率也比较低。</p> 
<h2>四、源码</h2> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;time.h&gt;
void Sort(int* arr, int size)
{
	int max = arr[0], min = arr[0];
	for (int i = 0; i &lt; size; i++)
	{
		if (max &lt; arr[i])
			max = arr[i];
		if (min &gt; arr[i])
			min = arr[i];
	}
	int ret = max - min + 1;
	int* tmp = (int*)calloc(ret,sizeof(int));
	assert(tmp);
	for (int i = 0; i &lt; size; i++)
		tmp[arr[i]-min]++;
	for (int i = 0, j = 0; i &lt; ret; i++)
	{
		while (tmp[i]--)
			arr[j++] = i + min;
	}
}
int main()
{
	srand((unsigned int)time(NULL));
	int arr[15];
	for (int i = 0; i &lt; 15; i++)
		arr[i] = rand() % 100 + 1;
	for (int i = 0; i &lt; 15; i++)
		printf("%d ", arr[i]);
	Sort(arr, 15);
	printf("\n");
	for (int i = 0; i &lt; 15; i++)
		printf("%d ", arr[i]);
	return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/57b7107f955ba8fe789fa71b0b3d0997/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【人工智能】AI时代：探索个人潜能的新视角</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/92d4908977a57827b5bf0c7e6b80e93a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">谷粒商城-全文检索-ElasticSearch</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>