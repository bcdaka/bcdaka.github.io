<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>手把手教你完成一个Python与OpenCV人脸识别项目（对图片、视频、摄像头人脸的检测）超详细保姆级记录！ - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/8a4bed7a8774817b6be22daa994a90f2/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="手把手教你完成一个Python与OpenCV人脸识别项目（对图片、视频、摄像头人脸的检测）超详细保姆级记录！">
  <meta property="og:description" content="课程来源：一天搞定人脸识别项目！学不会up直接下跪！（python&#43;opencv）_哔哩哔哩_bilibili
环境配置详见：
在conda虚拟环境中安装OpenCv并在pycharm中使用_conda虚拟环境安装opencv_好喜欢吃红柚子的博客-CSDN博客
目录
一、读取图片
1.1 imshow和WaitKey方法 1.2 代码实现
1.3 效果展示 二、图片灰度化
2.1 图片灰度化作用 2.2 所需方法
2.2.1 设置灰度方法
2.2.2 保存图片方法
2.3 代码实现
2.4 效果展示
2.4.1 显示灰度图片 2.4.2 保存灰度图片
三、尺寸转换
3.1 尺寸转换方法
3.2 代码展示 3.3 效果展示
3.3.1 显示修改后的图片
3.3.2 保存图片
3.3.3 输出图片的大小
3.4 按下英文输入法中的m键后退出程序
四、绘制矩形和圆形框
4.1 绘制矩形
4.2 绘制圆形
4.3 代码实现
4.4 效果展示
五、人脸检测
5.1 OpenCV自带的分类器
5.2 detectMultiScale方法
5.3 代码
5.4 效果展示 六、检测多个人脸 6.1 代码实现
6.2 效果展示
七、对视频的检测
7.1 所需函数">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-03-16T17:33:49+08:00">
    <meta property="article:modified_time" content="2023-03-16T17:33:49+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">手把手教你完成一个Python与OpenCV人脸识别项目（对图片、视频、摄像头人脸的检测）超详细保姆级记录！</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>课程来源：</strong><a href="https://www.bilibili.com/video/BV1Lq4y1Z7dm/?spm_id_from=333.337.search-card.all.click&amp;vd_source=e482aea0f5ebf492c0b0220fb64f98d3" rel="nofollow" title="一天搞定人脸识别项目！学不会up直接下跪！（python+opencv）_哔哩哔哩_bilibili">一天搞定人脸识别项目！学不会up直接下跪！（python+opencv）_哔哩哔哩_bilibili</a></p> 
<p><strong>环境配置详见：</strong></p> 
<p><a href="https://blog.csdn.net/weixin_45662399/article/details/128416857?spm=1001.2014.3001.5501" title="在conda虚拟环境中安装OpenCv并在pycharm中使用_conda虚拟环境安装opencv_好喜欢吃红柚子的博客-CSDN博客">在conda虚拟环境中安装OpenCv并在pycharm中使用_conda虚拟环境安装opencv_好喜欢吃红柚子的博客-CSDN博客</a></p> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87" rel="nofollow">一、读取图片</a></p> 
<p id="1.1%20imshow%E5%92%8CWaitKey%E6%96%B9%E6%B3%95%C2%A0-toc" style="margin-left:40px;"><a href="#1.1%20imshow%E5%92%8CWaitKey%E6%96%B9%E6%B3%95%C2%A0" rel="nofollow">1.1 imshow和WaitKey方法 </a></p> 
<p id="%C2%A01.1%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%C2%A01.1%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow"> 1.2 代码实现</a></p> 
<p id="1.2%20%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA%C2%A0-toc" style="margin-left:40px;"><a href="#1.2%20%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA%C2%A0" rel="nofollow">1.3 效果展示 </a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%9B%BE%E7%89%87%E7%81%B0%E5%BA%A6%E5%8C%96-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%9B%BE%E7%89%87%E7%81%B0%E5%BA%A6%E5%8C%96" rel="nofollow">二、图片灰度化</a></p> 
<p id="2.1%20%E5%9B%BE%E7%89%87%E7%81%B0%E5%BA%A6%E5%8C%96%E4%BD%9C%E7%94%A8%C2%A0-toc" style="margin-left:40px;"><a href="#2.1%20%E5%9B%BE%E7%89%87%E7%81%B0%E5%BA%A6%E5%8C%96%E4%BD%9C%E7%94%A8%C2%A0" rel="nofollow">2.1 图片灰度化作用 </a></p> 
<p id="2.2%20%E6%89%80%E9%9C%80%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#2.2%20%E6%89%80%E9%9C%80%E6%96%B9%E6%B3%95" rel="nofollow">2.2 所需方法</a></p> 
<p id="2.2.1%20%E8%AE%BE%E7%BD%AE%E7%81%B0%E5%BA%A6%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#2.2.1%20%E8%AE%BE%E7%BD%AE%E7%81%B0%E5%BA%A6%E6%96%B9%E6%B3%95" rel="nofollow">2.2.1 设置灰度方法</a></p> 
<p id="%C2%A02.2.2%20%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#%C2%A02.2.2%20%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87%E6%96%B9%E6%B3%95" rel="nofollow"> 2.2.2 保存图片方法</a></p> 
<p id="2.3%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#2.3%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">2.3 代码实现</a></p> 
<p id="%C2%A02.4%20%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA-toc" style="margin-left:40px;"><a href="#%C2%A02.4%20%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA" rel="nofollow"> 2.4 效果展示</a></p> 
<p id="2.4.1%20%E6%98%BE%E7%A4%BA%E7%81%B0%E5%BA%A6%E5%9B%BE%E7%89%87%C2%A0-toc" style="margin-left:80px;"><a href="#2.4.1%20%E6%98%BE%E7%A4%BA%E7%81%B0%E5%BA%A6%E5%9B%BE%E7%89%87%C2%A0" rel="nofollow">2.4.1 显示灰度图片 </a></p> 
<p id="2.4.2%20%E4%BF%9D%E5%AD%98%E7%81%B0%E5%BA%A6%E5%9B%BE%E7%89%87-toc" style="margin-left:80px;"><a href="#2.4.2%20%E4%BF%9D%E5%AD%98%E7%81%B0%E5%BA%A6%E5%9B%BE%E7%89%87" rel="nofollow">2.4.2 保存灰度图片</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%B0%BA%E5%AF%B8%E8%BD%AC%E6%8D%A2-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%B0%BA%E5%AF%B8%E8%BD%AC%E6%8D%A2" rel="nofollow">三、尺寸转换</a></p> 
<p id="3.1%C2%A0%C2%A0%E5%B0%BA%E5%AF%B8%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#3.1%C2%A0%C2%A0%E5%B0%BA%E5%AF%B8%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95" rel="nofollow">3.1  尺寸转换方法</a></p> 
<p id="3.2%20%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA%C2%A0-toc" style="margin-left:40px;"><a href="#3.2%20%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA%C2%A0" rel="nofollow">3.2 代码展示 </a></p> 
<p id="3.3%20%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA-toc" style="margin-left:40px;"><a href="#3.3%20%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA" rel="nofollow">3.3 效果展示</a></p> 
<p id="3.3.1%20%E6%98%BE%E7%A4%BA%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E5%9B%BE%E7%89%87-toc" style="margin-left:80px;"><a href="#3.3.1%20%E6%98%BE%E7%A4%BA%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E5%9B%BE%E7%89%87" rel="nofollow">3.3.1 显示修改后的图片</a></p> 
<p id="3.3.2%20%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87-toc" style="margin-left:80px;"><a href="#3.3.2%20%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87" rel="nofollow">3.3.2 保存图片</a></p> 
<p id="3.3.3%20%E8%BE%93%E5%87%BA%E5%9B%BE%E7%89%87%E7%9A%84%E5%A4%A7%E5%B0%8F-toc" style="margin-left:80px;"><a href="#3.3.3%20%E8%BE%93%E5%87%BA%E5%9B%BE%E7%89%87%E7%9A%84%E5%A4%A7%E5%B0%8F" rel="nofollow">3.3.3 输出图片的大小</a></p> 
<p id="3.4%20%E6%8C%89%E4%B8%8B%E8%8B%B1%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E4%B8%AD%E7%9A%84m%E9%94%AE%E5%90%8E%E9%80%80%E5%87%BA%E7%A8%8B%E5%BA%8F-toc" style="margin-left:40px;"><a href="#3.4%20%E6%8C%89%E4%B8%8B%E8%8B%B1%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E4%B8%AD%E7%9A%84m%E9%94%AE%E5%90%8E%E9%80%80%E5%87%BA%E7%A8%8B%E5%BA%8F" rel="nofollow">3.4 按下英文输入法中的m键后退出程序</a></p> 
<p id="%E5%9B%9B%E3%80%81%E7%BB%98%E5%88%B6%E7%9F%A9%E5%BD%A2%E5%92%8C%E5%9C%86%E5%BD%A2%E6%A1%86-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E7%BB%98%E5%88%B6%E7%9F%A9%E5%BD%A2%E5%92%8C%E5%9C%86%E5%BD%A2%E6%A1%86" rel="nofollow">四、绘制矩形和圆形框</a></p> 
<p id="%C2%A04.1%20%E7%BB%98%E5%88%B6%E7%9F%A9%E5%BD%A2-toc" style="margin-left:40px;"><a href="#%C2%A04.1%20%E7%BB%98%E5%88%B6%E7%9F%A9%E5%BD%A2" rel="nofollow"> 4.1 绘制矩形</a></p> 
<p id="4.2%20%E7%BB%98%E5%88%B6%E5%9C%86%E5%BD%A2-toc" style="margin-left:40px;"><a href="#4.2%20%E7%BB%98%E5%88%B6%E5%9C%86%E5%BD%A2" rel="nofollow">4.2 绘制圆形</a></p> 
<p id="4.3%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#4.3%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">4.3 代码实现</a></p> 
<p id="%C2%A04.4%20%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA-toc" style="margin-left:40px;"><a href="#%C2%A04.4%20%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA" rel="nofollow"> 4.4 效果展示</a></p> 
<p id="%C2%A0%E4%BA%94%E3%80%81%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%BA%94%E3%80%81%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B" rel="nofollow"> 五、人脸检测</a></p> 
<p id="5.1%20OpenCV%E8%87%AA%E5%B8%A6%E7%9A%84%E5%88%86%E7%B1%BB%E5%99%A8-toc" style="margin-left:40px;"><a href="#5.1%20OpenCV%E8%87%AA%E5%B8%A6%E7%9A%84%E5%88%86%E7%B1%BB%E5%99%A8" rel="nofollow">5.1 OpenCV自带的分类器</a></p> 
<p id="5.2%20detectMultiScale%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#5.2%20detectMultiScale%E6%96%B9%E6%B3%95" rel="nofollow">5.2 detectMultiScale方法</a></p> 
<p id="5.3%20%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#5.3%20%E4%BB%A3%E7%A0%81" rel="nofollow">5.3 代码</a></p> 
<p id="5.4%20%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA%C2%A0-toc" style="margin-left:40px;"><a href="#5.4%20%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA%C2%A0" rel="nofollow">5.4 效果展示 </a></p> 
<p id="%E5%85%AD%E3%80%81%E6%A3%80%E6%B5%8B%E5%A4%9A%E4%B8%AA%E4%BA%BA%E8%84%B8%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E6%A3%80%E6%B5%8B%E5%A4%9A%E4%B8%AA%E4%BA%BA%E8%84%B8%C2%A0" rel="nofollow">六、检测多个人脸 </a></p> 
<p id="%C2%A06.1%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%C2%A06.1%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow"> 6.1 代码实现</a></p> 
<p id="6.2%20%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA-toc" style="margin-left:40px;"><a href="#6.2%20%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA" rel="nofollow">6.2 效果展示</a></p> 
<p id="%E4%B8%83%E3%80%81%E5%AF%B9%E8%A7%86%E9%A2%91%E7%9A%84%E6%A3%80%E6%B5%8B-toc" style="margin-left:0px;"><a href="#%E4%B8%83%E3%80%81%E5%AF%B9%E8%A7%86%E9%A2%91%E7%9A%84%E6%A3%80%E6%B5%8B" rel="nofollow">七、对视频的检测</a></p> 
<p id="7.1%20%E6%89%80%E9%9C%80%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#7.1%20%E6%89%80%E9%9C%80%E5%87%BD%E6%95%B0" rel="nofollow">7.1 所需函数</a></p> 
<p id="7.1.1%20%E5%88%9B%E5%BB%BA%E8%AF%BB%E5%8F%96%E6%91%84%E5%83%8F%E5%A4%B4%2F%E8%A7%86%E9%A2%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#7.1.1%20%E5%88%9B%E5%BB%BA%E8%AF%BB%E5%8F%96%E6%91%84%E5%83%8F%E5%A4%B4%2F%E8%A7%86%E9%A2%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%BD%E6%95%B0" rel="nofollow">7.1.1 创建读取摄像头/视频对象的函数</a></p> 
<p id="%C2%A07.1.2%20%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E5%B8%A7%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%C2%A07.1.2%20%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E5%B8%A7%E5%87%BD%E6%95%B0" rel="nofollow"> 7.1.2 读取视频帧函数</a></p> 
<p id="7.1.3%20%E9%87%8A%E6%94%BE%E5%9B%BE%E5%83%8F-toc" style="margin-left:80px;"><a href="#7.1.3%20%E9%87%8A%E6%94%BE%E5%9B%BE%E5%83%8F" rel="nofollow">7.1.3 释放图像</a></p> 
<p id="7.1.4%20WaitKey%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#7.1.4%20WaitKey%E6%96%B9%E6%B3%95" rel="nofollow">7.1.4 WaitKey方法</a></p> 
<p id="7.2%20%E6%91%84%E5%83%8F%E5%A4%B4%E6%8D%95%E8%8E%B7%E8%AF%86%E5%88%AB-toc" style="margin-left:40px;"><a href="#7.2%20%E6%91%84%E5%83%8F%E5%A4%B4%E6%8D%95%E8%8E%B7%E8%AF%86%E5%88%AB" rel="nofollow">7.2 摄像头捕获识别</a></p> 
<p id="7.2.1%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%C2%A0-toc" style="margin-left:80px;"><a href="#7.2.1%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%C2%A0" rel="nofollow">7.2.1 代码实现 </a></p> 
<p id="%C2%A07.3%20%E8%A7%86%E9%A2%91%E6%8D%95%E8%8E%B7-toc" style="margin-left:40px;"><a href="#%C2%A07.3%20%E8%A7%86%E9%A2%91%E6%8D%95%E8%8E%B7" rel="nofollow"> 7.3 视频捕获</a></p> 
<p id="%E5%85%AB%E3%80%81%E4%BA%BA%E8%84%B8%E4%BF%A1%E6%81%AF%E5%BD%95%E5%85%A5-toc" style="margin-left:0px;"><a href="#%E5%85%AB%E3%80%81%E4%BA%BA%E8%84%B8%E4%BF%A1%E6%81%AF%E5%BD%95%E5%85%A5" rel="nofollow">八、人脸信息录入</a></p> 
<p id="8.1%C2%A0%20%E6%89%80%E9%9C%80%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#8.1%C2%A0%20%E6%89%80%E9%9C%80%E5%87%BD%E6%95%B0" rel="nofollow">8.1  所需函数</a></p> 
<p id="8.2%200xFF%E7%9A%84%E6%84%8F%E4%B9%89%C2%A0-toc" style="margin-left:40px;"><a href="#8.2%200xFF%E7%9A%84%E6%84%8F%E4%B9%89%C2%A0" rel="nofollow">8.2 0xFF的意义 </a></p> 
<p id="%C2%A08.3%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%C2%A08.3%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow"> 8.3 代码实现</a></p> 
<p id="8.4%20%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA-toc" style="margin-left:40px;"><a href="#8.4%20%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA" rel="nofollow">8.4 效果展示</a></p> 
<p id="%E4%B9%9D%E3%80%81%20%E6%95%B0%E6%8D%AE%E8%AE%AD%E7%BB%83-toc" style="margin-left:0px;"><a href="#%E4%B9%9D%E3%80%81%20%E6%95%B0%E6%8D%AE%E8%AE%AD%E7%BB%83" rel="nofollow">九、 数据训练</a></p> 
<p id="9.1%20%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#9.1%20%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84" rel="nofollow">9.1 项目目录结构</a></p> 
<p id="9.2%20%E8%BF%90%E8%A1%8C%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%C2%A0-toc" style="margin-left:40px;"><a href="#9.2%20%E8%BF%90%E8%A1%8C%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%C2%A0" rel="nofollow">9.2 运行时出现的问题 </a></p> 
<p id="9.3%20%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#9.3%20%E4%BB%A3%E7%A0%81" rel="nofollow">9.3 代码</a></p> 
<p id="9.4%20%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-toc" style="margin-left:40px;"><a href="#9.4%20%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C" rel="nofollow">9.4 运行结果</a></p> 
<p id="%E5%8D%81%E3%80%81%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E3%80%81%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB" rel="nofollow">十、人脸识别</a></p> 
<p id="%E5%8D%81%E4%B8%80%E3%80%81%E7%BD%91%E7%BB%9C%E8%A7%86%E9%A2%91-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E4%B8%80%E3%80%81%E7%BD%91%E7%BB%9C%E8%A7%86%E9%A2%91" rel="nofollow">十一、网络视频</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87">一、读取图片</h2> 
<h3 id="1.1%20imshow%E5%92%8CWaitKey%E6%96%B9%E6%B3%95%C2%A0">1.1 imshow和WaitKey方法 </h3> 
<blockquote> 
 <p>waitKey()–是在一个给定的时间内(单位ms)等待用户按键触发;</p> 
 <p><span style="background-color:#fbd4d0;">waitKey() 函数的功能是不断刷新图像 , 频率时间为delay , 单位为ms</span> </p> 
 <ul><li><span style="color:#fe2c24;">返回值为当前键盘按键值</span></li><li>如果用户没有按下键,则继续等待 (循环)</li><li>常见 : 设置 waitKey(0) , 则表示程序会无限制的等待用户的按键事件；一般在 imgshow 的时候 , 如果设置 waitKey(0) , 代表按任意键继续</li></ul> 
</blockquote> 
<p>        <span style="color:#fe2c24;"><span style="background-color:#fefcd8;">waitkey控制着imshow的持续时间</span></span>，当imshow之后不跟waitkey时，相当于没有给imshow提供时间展示图像，所以只有一个空窗口一闪而过。添加了waitkey后，哪怕仅仅是cv2.waitkey(1),我们也能截取到一帧的图像。所以cv2.imshow后边是必须要跟cv2.waitkey的。 </p> 
<p><a href="https://blog.csdn.net/weixin_44049693/article/details/106271643?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167634153116800188535679%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=167634153116800188535679&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-106271643-null-null.142%5Ev73%5Einsert_down2,201%5Ev4%5Eadd_ask,239%5Ev1%5Econtrol&amp;utm_term=cv2.waitkey&amp;spm=1018.2226.3001.4187" title="cv2.waitKey的入门级理解_山上有强强的博客-CSDN博客_cv2.waitkey">cv2.waitKey的入门级理解_山上有强强的博客-CSDN博客_cv2.waitkey</a></p> 
<p><a href="https://blog.csdn.net/qq_39377418/article/details/101393007?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=cv2.waitkey&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-101393007.142%5Ev73%5Einsert_down2,201%5Ev4%5Eadd_ask,239%5Ev1%5Econtrol&amp;spm=1018.2226.3001.4187" title="python cv2.waitKey()函数_漫天丶飞雪的博客-CSDN博客_cv2.waitkey">python cv2.waitKey()函数_漫天丶飞雪的博客-CSDN博客_cv2.waitkey</a></p> 
<h3 id="%C2%A01.1%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"> 1.2 代码实现</h3> 
<pre><code class="language-python">#导入cv模块
import cv2 as cv
#读取图片
img = cv.imread('1.png')
#显示图片
cv.imshow('showFace',img)
#等待delay
cv.waitKey(0)
#释放内存
cv.destroyAllWindows()</code></pre> 
<h3 id="1.2%20%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA%C2%A0">1.3 效果展示 </h3> 
<p><img alt="" height="700" src="https://images2.imgbox.com/5e/a2/ZsjKs2Pd_o.png" width="1200"></p> 
<p></p> 
<h2 id="%E4%BA%8C%E3%80%81%E5%9B%BE%E7%89%87%E7%81%B0%E5%BA%A6%E5%8C%96">二、图片灰度化</h2> 
<h3 id="2.1%20%E5%9B%BE%E7%89%87%E7%81%B0%E5%BA%A6%E5%8C%96%E4%BD%9C%E7%94%A8%C2%A0">2.1 图片灰度化作用 </h3> 
<p> <a href="https://blog.csdn.net/qq_29788741/article/details/125584261?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167618503116800188533211%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=167618503116800188533211&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-125584261-null-null.142%5Ev73%5Ewechat_v2,201%5Ev4%5Eadd_ask,239%5Ev1%5Econtrol&amp;utm_term=%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%A4%84%E7%90%86%E7%81%B0%E5%BA%A6%E5%9B%BE%E5%83%8F&amp;spm=1018.2226.3001.4187" title="图像处理时为什么灰度化_图像灰度化处理的目的_whaosoft143的博客-CSDN博客">图像处理时为什么灰度化_图像灰度化处理的目的_whaosoft143的博客-CSDN博客</a> </p> 
<hr> 
<p> <u><em><strong><span style="background-color:#fef2f0;">为什么做图片识别要将彩色图像灰度化呢？</span></strong></em></u></p> 
<p><strong><span style="color:#fe2c24;"><span style="background-color:#ffd900;">图像灰度化的目的是为了简化矩阵，提高运算速度。</span></span></strong></p> 
<p>        彩色图像中的每个像素颜色由R、G、B三个分量来决定，而每个分量的取值范围都在0-255之间，这样对计算机来说，彩色图像的一个像素点就会有256*256*256=16777216种颜色的变化范围！</p> 
<p>        而灰度图像是R、G、B分量相同的一种特殊彩色图像，对计算机来说，一个像素点的变化范围只有0-255这256种。</p> 
<p>        彩色图片的信息含量过大，而进行图片识别时，其实只需要使用灰度图像里的信息就足够了，<strong>所以图像灰度化的目的就是为了提高运算速度。</strong></p> 
<p>        当然，有时图片进行了灰度处理后还是很大，也有可能会采用二值化图像（即像素值只能为0或1）。</p> 
<hr> 
<h3 id="2.2%20%E6%89%80%E9%9C%80%E6%96%B9%E6%B3%95">2.2 所需方法</h3> 
<h4 id="2.2.1%20%E8%AE%BE%E7%BD%AE%E7%81%B0%E5%BA%A6%E6%96%B9%E6%B3%95">2.2.1 设置灰度方法</h4> 
<blockquote> 
 <p>cvtColor() </p> 
</blockquote> 
<h4 id="%C2%A02.2.2%20%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87%E6%96%B9%E6%B3%95"> 2.2.2 保存图片方法</h4> 
<blockquote> 
 <p>imwrite()</p> 
</blockquote> 
<h3 id="2.3%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">2.3 代码实现</h3> 
<pre><code class="language-python">#导入模块
import cv2 as cv
#读取图片
img = cv.imread("face1.png")
#灰度转换
gray_img = cv.cvtColor(img,cv.COLOR_BGRA2GRAY)
#显示灰度
cv.imshow("greyImg",gray_img)
#保存灰度图片
cv.imwrite('gray_face1.png',gray_img)
#等待
cv.waitKey(0)
#释放内存
cv.destroyAllWindows()</code></pre> 
<h3 id="%C2%A02.4%20%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA"> 2.4 效果展示</h3> 
<h4 id="2.4.1%20%E6%98%BE%E7%A4%BA%E7%81%B0%E5%BA%A6%E5%9B%BE%E7%89%87%C2%A0">2.4.1 显示灰度图片 </h4> 
<p><img alt="" height="728" src="https://images2.imgbox.com/86/55/PyP7XLvq_o.png" width="1200"></p> 
<h4 id="2.4.2%20%E4%BF%9D%E5%AD%98%E7%81%B0%E5%BA%A6%E5%9B%BE%E7%89%87">2.4.2 保存灰度图片</h4> 
<p>        在关闭显示的灰度图片后，会将该图片进行保存</p> 
<p><img alt="" height="457" src="https://images2.imgbox.com/22/c1/xj4JxeXP_o.png" width="1032"></p> 
<p></p> 
<h2 id="%E4%B8%89%E3%80%81%E5%B0%BA%E5%AF%B8%E8%BD%AC%E6%8D%A2">三、尺寸转换</h2> 
<h3 id="3.1%C2%A0%C2%A0%E5%B0%BA%E5%AF%B8%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95">3.1  尺寸转换方法</h3> 
<blockquote> 
 <p>resize()</p> 
</blockquote> 
<h3 id="3.2%20%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA%C2%A0">3.2 代码展示 </h3> 
<pre><code class="language-python">import cv2 as cv

#读取图片
img = cv.imread("face1.png")
#修改尺寸
img_resized = cv.resize(img,(200,200))
#显示原图
cv.imshow("face01",img)
#显示修改尺寸后的图
cv.imshow("face01_resized",img_resized)
#打印原图和修改图的尺寸
print("原图大小:",img.shape,"\n修改后大小:",img_resized.shape)
#保存修改大小后的图片
cv.imwrite("resize_face1.png",img_resized)
#等待
cv.waitKey(0)
#释放内存
cv.destroyAllWindows()</code></pre> 
<h3 id="3.3%20%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA">3.3 效果展示</h3> 
<h4 id="3.3.1%20%E6%98%BE%E7%A4%BA%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E5%9B%BE%E7%89%87">3.3.1 显示修改后的图片</h4> 
<p><img alt="" height="827" src="https://images2.imgbox.com/f8/7c/wmH43kro_o.png" width="1200"></p> 
<h4 id="3.3.2%20%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87">3.3.2 保存图片</h4> 
<p><img alt="" height="423" src="https://images2.imgbox.com/d9/d1/CwBRnNbl_o.png" width="895"></p> 
<p></p> 
<h4 id="3.3.3%20%E8%BE%93%E5%87%BA%E5%9B%BE%E7%89%87%E7%9A%84%E5%A4%A7%E5%B0%8F">3.3.3 输出图片的大小</h4> 
<p>3为彩色图片的通道数。</p> 
<p><img alt="" height="178" src="https://images2.imgbox.com/20/6a/FlTaTVqt_o.png" width="983"></p> 
<h3 id="3.4%20%E6%8C%89%E4%B8%8B%E8%8B%B1%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E4%B8%AD%E7%9A%84m%E9%94%AE%E5%90%8E%E9%80%80%E5%87%BA%E7%A8%8B%E5%BA%8F">3.4 按下英文输入法中的m键后退出程序</h3> 
<blockquote> 
 <ul><li><code>ord('m')</code> ：返回m的ascii码</li></ul> 
</blockquote> 
<pre><code class="language-python">import cv2 as cv

#读取图片
img = cv.imread("face1.png")
#修改尺寸
img_resized = cv.resize(img,(200,200))
#显示原图
cv.imshow("face01",img)
#显示修改尺寸后的图
cv.imshow("face01_resized",img_resized)
#打印原图和修改图的尺寸
print("原图大小:",img.shape,"\n修改后大小:",img_resized.shape)
#按下m键时退出程序
while True:
    if ord('m') == cv.waitKey(0):
        break
#释放内存
cv.destroyAllWindows()</code></pre> 
<p></p> 
<h2 id="%E5%9B%9B%E3%80%81%E7%BB%98%E5%88%B6%E7%9F%A9%E5%BD%A2%E5%92%8C%E5%9C%86%E5%BD%A2%E6%A1%86">四、绘制矩形和圆形框</h2> 
<h3 id="%C2%A04.1%20%E7%BB%98%E5%88%B6%E7%9F%A9%E5%BD%A2"> 4.1 绘制矩形</h3> 
<blockquote> 
 <p> cv2.rectangle(img, pt1, pt2, color, thickness=None, lineType=None, shift=None)</p> 
</blockquote> 
<p>参数介绍： </p> 
<p> <a href="https://blog.csdn.net/weixin_54998572/article/details/125789696?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167618137116800180636988%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=167618137116800180636988&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125789696-null-null.142%5Ev73%5Ewechat_v2,201%5Ev4%5Eadd_ask,239%5Ev1%5Econtrol&amp;utm_term=cv.rectangle&amp;spm=1018.2226.3001.4187" title="python版opencv函数学习笔记-cv.rectangle()全参数理解_风一样的夏天001的博客-CSDN博客">python版opencv函数学习笔记-cv.rectangle()全参数理解_风一样的夏天001的博客-CSDN博客</a></p> 
<p><strong>作用：</strong>根据给定的左上顶点和右下顶点画矩形 </p> 
<p><strong> 参数说明：</strong></p> 
<ul><li>img：指定一张图片，在这张图片的基础上进行绘制；</li><li>pt1： 矩形的一个顶点；</li><li>pt2： 与pt1在对角线上相对的矩形的顶点；</li><li>color：指定边框的颜色，由（B,G,R）组成，当为（255,0，0）时为绿色，可以自由设定；</li><li>thinkness：线条的粗细值，为正值时代表线条的粗细（以像素为单位），为负值时边框实心;<br>  </li></ul> 
<p></p> 
<h3 id="4.2%20%E7%BB%98%E5%88%B6%E5%9C%86%E5%BD%A2">4.2 绘制圆形</h3> 
<blockquote> 
 <p>cv2.circle(img, center, radius, color, thickness=None, lineType=None, shift=None):</p> 
</blockquote> 
<p><strong>作用：</strong>根据给定的圆心和半径等画圆</p> 
<p><strong>参数说明：</strong></p> 
<ul><li>img：输入的图片data</li><li>center：圆心位置</li><li>radius：圆的半径</li><li>color：圆的颜色</li><li>thickness：圆形轮廓的粗细（如果为正）。负厚度表示要绘制实心圆。</li></ul> 
<p></p> 
<h3 id="4.3%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">4.3 代码实现</h3> 
<pre><code class="language-python">import cv2 as cv
x,y,w,h = 100,100,100,100
#读取图片
img = cv.imread("face1.png")
#绘制矩形
cv.rectangle(img,pt1=(x,y),pt2=(x+w,y+h),color=(0,0,255),thickness=1)
#绘制圆形
cv.circle(img,center=(x,y),radius=100,color=(255,0,0),thickness=2)
#显示图片
cv.imshow("draw_face1",img)

while True:
    if ord('m')==cv.waitKey(0):
        break
cv.destroyAllWindows()</code></pre> 
<p></p> 
<h3 id="%C2%A04.4%20%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA"> 4.4 效果展示</h3> 
<p><img alt="" height="764" src="https://images2.imgbox.com/d2/db/Z0ABDfI8_o.png" width="1200"></p> 
<h2 id="%C2%A0%E4%BA%94%E3%80%81%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B"> <br> 五、人脸检测</h2> 
<h3 id="5.1%20OpenCV%E8%87%AA%E5%B8%A6%E7%9A%84%E5%88%86%E7%B1%BB%E5%99%A8">5.1 OpenCV自带的分类器</h3> 
<p>         在下图的路径中，我们可以看到需要xml文件，这些都是OpenCV中自带的分类器，根据文件名我们可以看到有识别眼睛的，身体的，脸的，等等。</p> 
<p>        使用cv.CascadeClassifier（参数：分类器所在路径）方法定义一个分类器对象。</p> 
<p>     <img alt="" height="640" src="https://images2.imgbox.com/6d/97/iMeQYDWP_o.png" width="984"></p> 
<blockquote> 
 <p><strong>我的分类器所在位置：</strong> </p> 
 <ul><li>OpenCV分类器路径：G:\conda\envs\testOpencv\Lib\site-packages\cv2\data</li><li>本次使用的分类器文件名：haarcascade_frontalface_alt2.xml</li><li>在代码中输入的完整路径（需要把右下划线改为左下划线）： G:/conda/envs/testOpencv/Lib/site-packages/cv2/data/haarcascade_frontalface_alt2.xml</li></ul> 
</blockquote> 
<p></p> 
<p></p> 
<h3 id="5.2%20detectMultiScale%E6%96%B9%E6%B3%95">5.2 detectMultiScale方法</h3> 
<p><a href="https://blog.csdn.net/itismelzp/article/details/50379359?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167618823216782425677017%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=167618823216782425677017&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-50379359-null-null.142%5Ev73%5Ewechat_v2,201%5Ev4%5Eadd_ask,239%5Ev1%5Econtrol&amp;utm_term=detectMultiScale&amp;spm=1018.2226.3001.4187" title="opencv人脸检测--detectMultiScale函数_walker lee的博客-CSDN博客_detectmultiscale">opencv人脸检测--detectMultiScale函数_walker lee的博客-CSDN博客_detectmultiscale</a></p> 
<blockquote> 
 <p><strong>detectMultiScale</strong></p> 
 <p><strong>                    </strong>(self,<br>                      image: Any,<br>                      scaleFactor: Any = None,<br>                      minNeighbors: Any = None,<br>                      flags: Any = None,<br>                      minSize: Any = None,<br>                      maxSize: Any = None) </p> 
</blockquote> 
<p><strong>作用：</strong></p> 
<p>      <u> </u><u><span style="background-color:#fefcd8;"> 它可以检测出图片中所有的人脸，并将人脸</span><strong><span style="background-color:#fefcd8;">用vector保存</span></strong><span style="background-color:#fefcd8;">各个人脸的</span><span style="color:#fe2c24;"><span style="background-color:#fefcd8;">坐标、大小</span></span><span style="background-color:#fefcd8;">，用矩形Rect类表示，函数由分类器对象调用。</span></u></p> 
<p><strong>参数介绍：</strong></p> 
<ol><li>image： 待检测图片，<span style="color:#fe2c24;">一般为灰度图像加快检测速度</span>；</li><li>scaleFactor：表示在前后两次相继的扫描中，搜索窗口的比例系数。默认为1.1，即每次搜索窗口依次扩大10%;  <span style="color:#fe2c24;"> scale_factor参数可以决定两个不同大小的窗口扫描之间有多大的跳跃，</span>这个参数设置的大，则意味着计算会变快，但如果窗口错过了某个大小的人脸，则可能丢失物体</li><li>minNeighbors：默认值为3，<span style="color:#fe2c24;">表示每一个目标至少要被检测到3次才算是真的目标(</span>因为周围的像素和不同的窗口大小都可以检测到人脸),</li><li>flags：一般使用默认值0；</li><li>minSize和maxSize用来限制得到的目标区域的最大/最小尺寸。</li></ol> 
<p></p> 
<h3 id="5.3%20%E4%BB%A3%E7%A0%81">5.3 代码</h3> 
<pre><code class="language-python">import cv2 as cv

def face_detect_methed():
    # 图片灰度化
    grey_img = cv.cvtColor(img,cv.COLOR_BGRA2GRAY)
    # 定义分类器，使用OpenCV自带的分类器
    face_detector = cv.CascadeClassifier('G:/conda/envs/testOpencv/Lib/site-packages/cv2/data/haarcascade_frontalface_alt2.xml')
    # 使用分类器
    face = face_detector.detectMultiScale(grey_img)
    # 在图片中对人脸画矩阵
    for x,y,w,h in face:
        cv.rectangle(img,(x,y),(x+w,y+h),color=(0,0,255),thickness=2)
    cv.imshow('result',img)

#读取图像
img = cv.imread("face1.png")
#调用检测函数
face_detect_methed()


while True:
    if ord('m') == cv.waitKey(0):
        break

cv.destroyAllWindows()
</code></pre> 
<p></p> 
<h3 id="5.4%20%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA%C2%A0">5.4 效果展示 </h3> 
<p> 此时为没有设定参数，可以看到图片识别人脸出现了失误，把背景中的海浪也识别为了人脸。</p> 
<p><img alt="" height="881" src="https://images2.imgbox.com/45/22/lHoLb1qS_o.png" width="1200"></p> 
<p>在调整了参数后可以看到，人脸识别正确，识别出了一个人脸</p> 
<p><img alt="" height="854" src="https://images2.imgbox.com/ac/b3/pc4ltIRX_o.png" width="1200"></p> 
<p></p> 
<h2 id="%E5%85%AD%E3%80%81%E6%A3%80%E6%B5%8B%E5%A4%9A%E4%B8%AA%E4%BA%BA%E8%84%B8%C2%A0">六、检测多个人脸 </h2> 
<p>      此次可以识别多个人脸，<strong><span style="background-color:#ffd900;">与识别一个人脸的代码基本相同</span></strong>，这次换了一个分类器，即OpenCV自带的默认人脸识别分类器，调整了一下detectMultiScale的参数，识别结果较为准确，但是有一个人脸未识别出来。</p> 
<h3 id="%C2%A06.1%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"> 6.1 代码实现</h3> 
<pre><code class="language-python">import cv2 as cv

def face_detect_methed():
    # 图片灰度化
    grey_img = cv.cvtColor(img,cv.COLOR_BGRA2GRAY)
    # 定义分类器，使用OpenCV自带的分类器
    face_detector = cv.CascadeClassifier('G:/conda/envs/testOpencv/Lib/site-packages/cv2/data/haarcascade_frontalface_default.xml')
    # 使用分类器
    face = face_detector.detectMultiScale(grey_img,1.1,5,0,(10,10),(200,200))
    # 在图片中对人脸画矩阵
    for x,y,w,h in face:
        cv.rectangle(img,(x,y),(x+w,y+h),color=(0,0,255),thickness=2)
    cv.imshow('result',img)

#读取图像
img = cv.imread("faceMorePeople.png")
#调用检测函数
face_detect_methed()

while True:
    if ord('m') == cv.waitKey(0):
        break

cv.destroyAllWindows()
</code></pre> 
<h3 id="6.2%20%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA">6.2 效果展示</h3> 
<p><img alt="" height="832" src="https://images2.imgbox.com/3b/92/uCPtoBfD_o.png" width="1200"></p> 
<p>         可以看到识别的不算准确，c位的人脸没有被识别出来，我挑了很多次参数也换了分类器还是不行，就这样吧那~</p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/df/12/LlyViSGw_o.png" width="1200"></p> 
<p>        换了一张有两个人脸的照片，可以检测出来。</p> 
<p class="img-center"><img alt="" height="355" src="https://images2.imgbox.com/bf/5a/SS818iq6_o.png" width="305"></p> 
<p></p> 
<h2 id="%E4%B8%83%E3%80%81%E5%AF%B9%E8%A7%86%E9%A2%91%E7%9A%84%E6%A3%80%E6%B5%8B">七、对视频的检测</h2> 
<h3 id="7.1%20%E6%89%80%E9%9C%80%E5%87%BD%E6%95%B0">7.1 所需函数</h3> 
<h4 id="7.1.1%20%E5%88%9B%E5%BB%BA%E8%AF%BB%E5%8F%96%E6%91%84%E5%83%8F%E5%A4%B4%2F%E8%A7%86%E9%A2%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%BD%E6%95%B0">7.1.1 创建读取摄像头/视频对象的函数</h4> 
<blockquote> 
 <p>cap = cv2.VideoCapture(filepath)</p> 
</blockquote> 
<p><span style="background-color:#ffd900;">cap为读取摄像头或视频的对象。 </span></p> 
<ul><li>cv2.VideoCapture可以捕获摄像头，用数字来控制不同的设备，例如cv.VideoCapture(0)为电脑自带摄像头，1为外接摄像头。</li><li>如果是视频文件，直接指定好路径即可,如 cv.VideoCapture('G:/1.mp4')，即读取在G盘中名为1的MP4视频文件。</li></ul> 
<p></p> 
<h4 id="%C2%A07.1.2%20%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E5%B8%A7%E5%87%BD%E6%95%B0"> 7.1.2 读取视频帧函数</h4> 
<blockquote> 
 <p>flag, frame = cap.read()</p> 
</blockquote> 
<ul><li>第一个参数flag为True或者False,代表有没有读取到图片</li><li>第二个参数<a href="https://so.csdn.net/so/search?q=frame&amp;spm=1001.2101.3001.7020" title="frame">frame</a>表示截取到一帧的图片</li></ul> 
<p> 在这里我们需要使用一个循环判断是否捕获到图像：</p> 
<ul><li>如果flag==false，说明视频结束，退出循环</li><li>否则则继续将视频中捕获到的帧图像放入检测函数face_detect_method中进行检测。</li></ul> 
<pre><code class="language-python">while True:
    flag,frame = cap.read()
    if not flag:
        break
    face_detect_method(frame)
    if ord('c')==cv.waitKey(1):
        break</code></pre> 
<h4 id="7.1.3%20%E9%87%8A%E6%94%BE%E5%9B%BE%E5%83%8F">7.1.3 释放图像</h4> 
<blockquote> 
 <p>cap.release()</p> 
</blockquote> 
<p>        使用结束后释放摄像头资源。</p> 
<p></p> 
<h4 id="7.1.4%20WaitKey%E6%96%B9%E6%B3%95">7.1.4 WaitKey方法</h4> 
<p>        需要设置WaitKey方法的参数为1，如果为0的话则只能捕获到视频的第一帧，不能播放视频。</p> 
<p><img alt="" height="94" src="https://images2.imgbox.com/0e/c0/kXIjE4HG_o.png" width="396"></p> 
<p></p> 
<h3 id="7.2%20%E6%91%84%E5%83%8F%E5%A4%B4%E6%8D%95%E8%8E%B7%E8%AF%86%E5%88%AB">7.2 摄像头捕获识别</h3> 
<h4 id="7.2.1%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%C2%A0">7.2.1 代码实现 </h4> 
<p>        可以看到 </p> 
<pre><code class="language-python">import cv2 as cv

# 检测方法定义
def face_detect_method(img):
    grey_img = cv.cvtColor(img,cv.COLOR_BGRA2GRAY)
    face_detector = cv.CascadeClassifier("G:/conda/envs/testOpencv/Lib/site-packages/cv2/data/haarcascade_frontalface_default.xml")
    face = face_detector.detectMultiScale(grey_img,1.02,4)
    for x,y,w,h in face:
        cv.rectangle(img,(x,y),(x+w,y+h),(255,0,0),2)
    cv.imshow("result",img)

#读取摄像头
cap = cv.VideoCapture(0)
#读取视频
#cap = cv.VideoCapture('G:/1.mp4')

# 循环判断
while True:
    flag,frame = cap.read()
    if not flag:
        break
    face_detect_method(frame)
    if ord('c')==cv.waitKey(1):
        break

cv.destroyAllWindows()
cap.release()</code></pre> 
<p>        可以看到打开摄像头后成功识别到了我的脸，两个人的也可以识别。</p> 
<p><img alt="" height="451" src="https://images2.imgbox.com/b5/c4/M7kBz4ZP_o.jpg" width="783"></p> 
<p><img alt="" height="437" src="https://images2.imgbox.com/8d/b5/9BoQWDc2_o.jpg" width="757"></p> 
<h3 id="%C2%A07.3%20%E8%A7%86%E9%A2%91%E6%8D%95%E8%8E%B7"> 7.3 视频捕获</h3> 
<p>使用如下语句读取存储的视频： </p> 
<blockquote> 
 <pre>cap = cv.VideoCapture('G:/1.mp4')</pre> 
</blockquote> 
<pre><code class="language-python">import cv2 as cv

# 检测方法定义
def face_detect_method(img):
    grey_img = cv.cvtColor(img,cv.COLOR_BGRA2GRAY)
    face_detector = cv.CascadeClassifier("G:/conda/envs/testOpencv/Lib/site-packages/cv2/data/haarcascade_frontalface_default.xml")
    face = face_detector.detectMultiScale(grey_img,1.02,4)
    for x,y,w,h in face:
        cv.rectangle(img,(x,y),(x+w,y+h),(255,0,0),2)
    cv.imshow("result",img)

#读取摄像头
#cap = cv.VideoCapture(0)
#读取视频
cap = cv.VideoCapture('G:/1.mp4')

# 循环判断
while True:
    flag,frame = cap.read()
    if not flag:
        break
    face_detect_method(frame)
    if ord('c')==cv.waitKey(1):
        break

cv.destroyAllWindows()
cap.release()</code></pre> 
<p>         试了一段去青岛旅游的时候拍的视频，效果还是可以的，大部分的人脸都能识别出来。</p> 
<p><img alt="" height="792" src="https://images2.imgbox.com/ea/23/bB7Izs0k_o.png" width="1198"></p> 
<p></p> 
<h2 id="%E5%85%AB%E3%80%81%E4%BA%BA%E8%84%B8%E4%BF%A1%E6%81%AF%E5%BD%95%E5%85%A5">八、人脸信息录入</h2> 
<h3 id="8.1%C2%A0%20%E6%89%80%E9%9C%80%E5%87%BD%E6%95%B0">8.1  所需函数</h3> 
<blockquote> 
 <p>cap.isOpened()</p> 
</blockquote> 
<p>判断视频对象是否成功读取，成功读取视频对象返回True。</p> 
<p></p> 
<h3 id="8.2%200xFF%E7%9A%84%E6%84%8F%E4%B9%89%C2%A0">8.2 0xFF的意义 </h3> 
<p> cv2.waitKey(1000) &amp; 0xFF == ord(‘q’) 是什么意思</p> 
<blockquote> 
 <ul><li>cv2.waitKey(1000)：在1000ms内根据键盘输入返回一个值</li><li>0xFF ：一个十六进制数</li><li>ord('q') ：返回q的ascii码</li></ul> 
</blockquote> 
<p>        0xFF是一个十六进制数，转换为二进制是11111111。waitKey返回值的范围为（0-255），刚好也是8个二进制位。那么我们将 cv2.waitKey(1) &amp; 0xFF计算一下（不知怎么计算的可以百度位与运算）发现结果仍然是waitKey的返回值，那为何要多次一举呢？直接 cv2.waitKey(1) == ord('q')不就好了吗。</p> 
<p>        实际上在linux上使用waitkey有时会出现waitkey返回值超过了（0-255）的范围的现象。通过cv2.waitKey(1) &amp; 0xFF运算，当waitkey返回值正常时 cv2.waitKey(1) = cv2.waitKey(1000) &amp; 0xFF,当返回值不正常时，cv2.waitKey(1000) &amp; 0xFF的范围仍不超过（0-255），就避免了一些奇奇怪怪的BUG。</p> 
<p></p> 
<h3 id="%C2%A08.3%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"> 8.3 代码实现</h3> 
<ol><li> 我们使用电脑自带的摄像头进行人脸的信息捕获，使用num对保存图片进行计数。</li><li>使用cap.isOpened()方法来判断摄像头是否开启。</li><li>使用frame保存视频中捕获到的帧图像，k获取键盘按键，s代表保存图像，空格代表退出程序。</li><li>当按下s键时，使用cv2.imwrite方法对图片进行保存，图片的保存路径和命名方法按自己的习惯来；我的保存路径是H盘的face_detect_save文件夹，命名格式为People(num).face.jpg。<br>  </li><li>计数器+1，表示保存图片张数+1，继续保存下一张。</li><li>按下空格键，退出循环，释放摄像头资源和内存空间。</li></ol> 
<pre><code class="language-python">import cv2 as cv
#创建摄像头对象
cap = cv.VideoCapture(0)
#记录保存图片的数目
num = 1

# 当摄像头开启时
while(cap.isOpened()):
    ret,frame = cap.read()
    cv.imshow("show",frame)
    # 获取按键
    k = cv.waitKey(1)&amp;0xFF
    #按下s保存图像
    if k ==ord('s'):
        cv.imwrite("H:/face_detect_save/"+"People"+str(num)+".face"+".jpg",frame)
        print("sucessfully saved"+str(num)+".jpg")
        print("---------------")
        #计数加一
        num+=1
    #按下空格退出
    elif k==ord(' '):
        break

cap.release()
cv.destroyAllWindows()</code></pre> 
<h3 id="8.4%20%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA">8.4 效果展示</h3> 
<p>        程序开始运行时，摄像头会自动打开，按下s键后可以保存图片到对应的路径中。 </p> 
<p><img alt="" height="768" src="https://images2.imgbox.com/f1/eb/DiLBjqhz_o.png" width="1200">         我保存了两张图片，可以看到对应的文件夹中已经进行了显示。</p> 
<p><img alt="" height="283" src="https://images2.imgbox.com/41/f3/ilqGbyL1_o.png" width="1200"></p> 
<p></p> 
<h2 id="%E4%B9%9D%E3%80%81%20%E6%95%B0%E6%8D%AE%E8%AE%AD%E7%BB%83">九、 使用数据训练识别器</h2> 
<p>用图片训练一个LBPH的识别器，这里使用15张</p> 
<h3 id="9.1%20%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84">9.1 项目目录结构</h3> 
<ul><li>提前创建好data和trainer两个文件夹</li></ul> 
<p><img alt="" height="618" src="https://images2.imgbox.com/d8/32/VgcB65m1_o.png" width="915"></p> 
<ul><li>trainer为空文件夹</li><li>data文件夹下继续创建jm文件夹，在jm其中放置训练的图片，图片命名方式为：序号.姓名 ，这里我用17张王鹤棣人脸图片进行训练图片。</li></ul> 
<p><img alt="" height="545" src="https://images2.imgbox.com/a4/48/iJlnvXx9_o.png" width="992"></p> 
<p> </p> 
<p></p> 
<h3>9.2 主要步骤介绍</h3> 
<p></p> 
<p>9.2.1 采集图片文件夹中的所有文件</p> 
<p>os.listdir可以获取path中的所有图像文件名，然后使用os.path.join方法把文件夹路径和图片名进行拼接，存储在imagePaths列表中，此时列表中存储的就是图片的完整路径，方便下一步open该图片。</p> 
<p></p> 
<p></p> 
<h3 id="9.2%20%E8%BF%90%E8%A1%8C%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%C2%A0">9.3 运行时出现的问题 </h3> 
<ul><li><span style="background-color:#fefcd8;">识别不到cv2模块中的face属性</span></li></ul> 
<p>解决方法：使用pip install命令安装opencv-库</p> 
<p><a href="https://blog.csdn.net/weixin_62075168/article/details/127767849?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167888356316800227471847%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=167888356316800227471847&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-127767849-null-null.142%5Ev73%5Einsert_down2,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&amp;utm_term=module%20cv2%20has%20no%20attribute%20face&amp;spm=1018.2226.3001.4187" title="对于“module ‘cv2.cv2‘ has no attribute ‘face‘与module ‘cv2‘ has no attribute ‘gapi_wip_gst_GStr 的解决方法。_羁旅少年的博客-CSDN博客">对于“module ‘cv2.cv2‘ has no attribute ‘face‘与module ‘cv2‘ has no attribute ‘gapi_wip_gst_GStr 的解决方法。_羁旅少年的博客-CSDN博客</a></p> 
<ul><li><span style="background-color:#fefcd8;">问题：File can't be opened for writing! in function 'cv::face::FaceRecognizer::write'</span></li></ul> 
<p><img alt="" height="177" src="https://images2.imgbox.com/c8/bf/gOm3FmFE_o.png" width="1200"></p> 
<p> 解决：需要提前手动在项目目录下创建好trainer文件夹</p> 
<p><img alt="" height="614" src="https://images2.imgbox.com/c9/1c/C2HMHPRq_o.png" width="1190"></p> 
<p></p> 
<h3 id="9.3%20%E4%BB%A3%E7%A0%81">9.3 代码</h3> 
<pre><code class="language-python">import os
import cv2 as cv
from PIL import Image
import numpy as np

def getImageAndLabels(path):
    #存储人脸数据
    faceSamples = []
    #存储姓名数据
    ids=[]
    #储存图片信息
    imagePaths = [os.path.join(path,f) for f in os.listdir(path)]
    #人脸检测分类器
    face_detecter = cv.CascadeClassifier('G:/conda/envs/testOpencv/Lib/site-packages/cv2/data/haarcascade_frontalface_default.xml')
    #遍历列表中的图片
    for imagePath in imagePaths:
        #打开图片，灰度化
        PIL_img = Image.open(imagePath).convert('L')
        #把图像转换为数组，
        img_numpy = np.array(PIL_img,'uint8')
        #获取图片人脸特征
        faces = face_detecter.detectMultiScale(img_numpy)
        #获取每张图片的id和姓名
        id = int(os.path.split(imagePath)[1].split('.')[0])
        #预防无面容照片
        for x,y,w,h in faces:
            ids.append(id)
            faceSamples.append(img_numpy[y:y+h,x:x+w])

            #打印脸部特征和id
        print('id:',id)
        print('fs:',faceSamples)
        return faceSamples,ids

if __name__ == '__main__':
    #图片路径
    path = './data/jm/'
    #获取图像数组和id标签数组
    faces,ids = getImageAndLabels(path)
    #加载识别器
    recognizer = cv.face.LBPHFaceRecognizer_create()
    #训练
    recognizer.train(faces,np.array(ids))
    #保存文件
    recognizer.write('trainer/trainer.yml')
</code></pre> 
<h3 id="9.4%20%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C">9.4 运行结果</h3> 
<p>trainer文件夹中产生了对应的trainer.yml文件。 </p> 
<p><img alt="" height="189" src="https://images2.imgbox.com/81/5a/if7ykfRa_o.png" width="872"></p> 
<p></p> 
<h2 id="%E5%8D%81%E3%80%81%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB">十、人脸识别</h2> 
<p></p> 
<h2 id="%E5%8D%81%E4%B8%80%E3%80%81%E7%BD%91%E7%BB%9C%E8%A7%86%E9%A2%91">十一、网络视频</h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/32f7300a12bfa54e946e726c0a9d6b48/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">损失函数——交叉熵损失（Cross-entropy loss）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/964b3c464fb7f019e3d1db180283b2fc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">微信开发者工具下载安装教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>