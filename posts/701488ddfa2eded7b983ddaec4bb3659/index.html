<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JVM的面试考点 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/701488ddfa2eded7b983ddaec4bb3659/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="JVM的面试考点">
  <meta property="og:description" content="JVM内存划分 1.堆,整个内存区域中,内存最大的区域,放的都是new出来的对象,new&#43;类名这一部分存放在堆中,
而这个scanner是一个临时变量,这个scanner的地址存放在栈上,scanner里面存放的值是new&#43;类名这个对象的首地址
2.栈,分为JVM虚拟机栈(Java代码),和本地方法栈(C&#43;&#43;),这个栈包含了方法的调用关系
3.元数据区(以前叫做方法区),放的是类对象,代码中的每个类,在JVM上运行的时候,都会有对应的类对象,Text.class还存放了方法相关的信息,类有一些方法,每个方法都代表了一系列的&#34;指令集合&#34;(JVM指令集合)
4.程序计数器,是内存区域中最小的一个区域,只需要保存,当前要执行的下一条指令(JVM字节码)的地址,这个地址就是元数据区里面的一个地址,JVM的PC保存的地址是JVM字节码的地址
关于内存中的地址划分
内存存放基本原则:1)局部变量,堆上
2)成员变量,堆上
3)静态成员变量 方法区/元数据区
上述四个区域中,堆和元数据区,是整个进程只有一份,栈和程序计数器是每个线程都有,多个线程同享一份数据,每个线程的局部变量,不是共享的,每个线程有自己的一份
类加载的过程 当前写的Java代码,是.java文件(硬盘),一个Java进程要跑起来,需要执行cpu指令,通过字节码让JVM翻译出来,就需要把.java文件变为.class文件(硬盘),再加载到内存上,得到类对象
重要过程
1.加载:在硬盘上,找到对应的.class文件,读取文件内容
2.验证:检查.class里的内容,是否符合要求,把读取出来的内容,往这个格式里套,看能不能套进去
u4是unsigned int 无符号的int u2是unsigned short 无符号的short
3.准备:给类对象,分配内存空间(在元数据区中),类加载最终要得到的就是类对象,会先把这个空间里的数据全填为0
4.解析:针对字符串常量进行初始化,把刚才.class文件中的常量内容取出来,放到元数据区
5.初始化:针对类对象中的各部分进行初始化(不是针对对象初始化,与构造方法无关)
双亲委派模型 这是一个类加载的机制,根据代码中写的&#34;全限定类名&#34;(包名&#43;类名,例如Java.lang.String)找到对应的.class文件
这个模型描述了JVM加载.class文件过程中,找文件的过程,这个模型中内置了三个类加载器,在JVM中包含了一个特定的模块/类,这个类负责完成后续类加载的工作
JVM中内置了三个类加载器(负责加载不同的类)
1.BootStrapClassLoader,负责加载标准库的类,这个类是Java官方给出的&#34;标准类&#34;,
2.ExtentionClassLoader,负责加载JVM扩展库的类
3.ApplicationClassLoader,负责加载第三方库的类和你自己写代码的类
三者之间的关系
此处的父子关系,不是通过类的继承表示的,而是通过类加载器中有一个&#34;parent&#34;这样的字段,指向自己父亲的地址,类似于二叉树的三叉实现
工作过程如下:例如给定一个全限定类名,Java.Test,此时加载过程如下
1.工作从ApplicationClassLoader开始进行,这个类加载器并不会立即从第三方库/自己写的代码开始搜索,而是交给自己的父亲ExtentionClassLoader去处理
2.工作就到了.ExtentionClassLoader,这个类加载器也不会立即从JVM扩展库开始搜索,而是交给自己的父亲BootStrapClassLoader去处理
3.工作就到了BootStrapClassLoader,这个类加载器,也不会立即从标准库中开始搜索,而是继续交给自己的父亲,由于自己的父亲为null,只能自己来处理,BootStrapClassLoader尝试在标准库的路径上开始搜索,如果这个类找到了,搜索过程完成,然后打开文件进行后续操作,如果没找到则交给自己的儿子来进行处理,
4.工作回到了.ExtentionClassLoader这个类加载器尝试在JVM扩展库的路径上开始搜索,如果这个类找到了,搜索过程完成,然后打开文件进行后续操作,如果没找到则交给自己的儿子来进行处理,
5.工作回到了ApplicationClassLoader,这个类加载器尝试在第三方库/自己写的代码中的路径上开始搜索,如果这个类找到了,搜索过程完成,然后打开文件进行后续操作,如果没找到则交给自己的儿子来进行处理,由于它的儿子为null,所以会抛出一个异常ClassNotFoundException
上述工作流程,主要应对这个场景,如果自己写的一个类和标准库/扩展库中的类冲突了,此时JVM就会确保标准库/扩展库的类加载成功,
类加载器并非只有三个,还可以手动写更多的类加载器,添加到中间
JVM的垃圾回收机制GC 垃圾回收机制,是Java提供的对于自动回收的机制,自动回收相对于C&#43;&#43;的手动回收来命名的,C&#43;&#43;回收需要手动free函数,可能会遗漏这个操作,
GC需要消耗额外的系统资源,而且存在非常影响效率的&#34;STW&#34;(stop the world)问题,GC回收的是内存,更准确的说是&#34;对象&#34;,回收的是堆上的内存
1)程序计数器(不需要额外回收,线程销毁,自然就回收了)
2)栈(不需要额外回收,线程销毁,自然回收)
3)元数据区(一般也不需要,都是加载类,很少有&#34;卸载类&#34;)
4)堆(GC回收的主力军)
一定是一次回收一个完整的对象,把对象中的成员全都回收
JAVAGC机制有一个方法,GC机制有两个方法
GC的主要流程
1.找到谁是垃圾,不被继续使用的对象
使用对象都是通过引用的方式来使用,如果没有引用指向这个对象,意味着这个对象注定无法在代码被使用,被视为垃圾了,对于JVM来说不是实时的,JVM需要一定的时间周期
如何判断某个对象是否有引用指向呢?
1)引用计数(不是JVM的方案,是Python和PHP的方案)
当引用计数为0时,这个对象就是垃圾了
缺陷如下:
1)消耗额外的存储空间:如果对象的空间比较大,浪费的空间很小,但是如果对象的空间比较小,浪费的空间就会特别大了
2)存在&#34;循环引用&#34;的问题
2)可达性分析(是JVM采取的方案)
解决了空间问题,也解决了循环引用的问题,但是时间上效率变慢,通过&#34;遍历&#34;,JVM把对象之间的引用关系,理解成一个&#34;树形结构&#34;,JVM就会不停的遍历这个结构,把所有能够访问到的对象标记成&#34;可达&#34;,剩下的就是&#34;不可达&#34;
2.释放对应的内存
由于可达性分析,需要消耗一定的时间,因此,JAVA垃圾回收,没法做到实时性,会周期性进行扫描(JVM提供了一组专门负责GC的线程,不停的进行扫描工作)
清理垃圾的策略:
1)标记-清除,直接把视为垃圾的对象对应的内存给释放掉,这样的做法会造成内存碎片化,后续很难申请到连续的空间,申请内存都是需要连续的">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-06T15:12:37+08:00">
    <meta property="article:modified_time" content="2024-08-06T15:12:37+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JVM的面试考点</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h6>JVM内存划分</h6> 
<p><img alt="" height="433" src="https://images2.imgbox.com/07/98/Y3JVCMy4_o.png" width="949"></p> 
<p>1.堆,整个内存区域中,内存最大的区域,放的都是new出来的对象,new+类名这一部分存放在堆中,</p> 
<p><img alt="" height="35" src="https://images2.imgbox.com/50/73/6RdKP3gK_o.png" width="603"></p> 
<p>而这个scanner是一个临时变量,这个scanner的地址存放在栈上,scanner里面存放的值是new+类名这个对象的首地址</p> 
<p><img alt="" height="78" src="https://images2.imgbox.com/5a/50/FBGY0Ew6_o.png" width="176"></p> 
<p>2.栈,分为JVM虚拟机栈(Java代码),和本地方法栈(C++),这个栈包含了方法的调用关系</p> 
<p>3.元数据区(以前叫做方法区),放的是类对象,代码中的每个类,在JVM上运行的时候,都会有对应的类对象,Text.class还存放了方法相关的信息,类有一些方法,每个方法都代表了一系列的"指令集合"(JVM指令集合)</p> 
<p><img alt="" height="94" src="https://images2.imgbox.com/fe/8e/3HL6AfJw_o.png" width="304"></p> 
<p>4.程序计数器,是内存区域中最小的一个区域,只需要保存,当前要执行的下一条指令(JVM字节码)的地址,这个地址就是元数据区里面的一个地址,JVM的PC保存的地址是JVM字节码的地址</p> 
<p></p> 
<p><img alt="" height="793" src="https://images2.imgbox.com/20/a4/Z51cv0Ep_o.png" width="1080"></p> 
<p>关于内存中的地址划分</p> 
<p><img alt="" height="677" src="https://images2.imgbox.com/48/df/XMtKB295_o.png" width="1200"></p> 
<p>内存存放基本原则:1)局部变量,堆上</p> 
<p>                2)成员变量,堆上</p> 
<p>                3)静态成员变量 方法区/元数据区</p> 
<p>上述四个区域中,堆和元数据区,是整个进程只有一份,栈和程序计数器是每个线程都有,多个线程同享一份数据,每个线程的局部变量,不是共享的,每个线程有自己的一份</p> 
<h6>类加载的过程</h6> 
<p>当前写的Java代码,是.java文件(硬盘),一个Java进程要跑起来,需要执行cpu指令,通过字节码让JVM翻译出来,就需要把.java文件变为.class文件(硬盘),再加载到内存上,得到类对象</p> 
<p>重要过程</p> 
<p>1.加载:在硬盘上,找到对应的.class文件,读取文件内容</p> 
<p>2.验证:检查.class里的内容,是否符合要求,把读取出来的内容,往这个格式里套,看能不能套进去</p> 
<p><img alt="" height="338" src="https://images2.imgbox.com/f7/b2/ytD113tO_o.png" width="886"></p> 
<p><img alt="" height="664" src="https://images2.imgbox.com/42/2c/bJU3lJAH_o.png" width="1174"></p> 
<p>u4是unsigned int 无符号的int u2是unsigned short 无符号的short</p> 
<p>3.准备:给类对象,分配内存空间(在元数据区中),类加载最终要得到的就是类对象,会先把这个空间里的数据全填为0</p> 
<p>4.解析:针对字符串常量进行初始化,把刚才.class文件中的常量内容取出来,放到元数据区</p> 
<p>5.初始化:针对类对象中的各部分进行初始化(不是针对对象初始化,与构造方法无关)</p> 
<h6>双亲委派模型</h6> 
<p>这是一个类加载的机制,根据代码中写的"全限定类名"(包名+类名,例如Java.lang.String)找到对应的.class文件</p> 
<p>这个模型描述了JVM加载.class文件过程中,找文件的过程,这个模型中内置了三个类加载器,在JVM中包含了一个特定的模块/类,这个类负责完成后续类加载的工作</p> 
<p><img alt="" height="463" src="https://images2.imgbox.com/7d/f4/eZaegIbr_o.png" width="910"></p> 
<p>JVM中内置了三个类加载器(负责加载不同的类)</p> 
<p>1.BootStrapClassLoader,负责加载标准库的类,这个类是Java官方给出的"标准类",</p> 
<p>2.ExtentionClassLoader,负责加载JVM扩展库的类</p> 
<p>3.ApplicationClassLoader,负责加载第三方库的类和你自己写代码的类</p> 
<p>三者之间的关系</p> 
<p><img alt="" height="319" src="https://images2.imgbox.com/cf/aa/ROvfvm2P_o.png" width="910"></p> 
<p>此处的父子关系,不是通过类的继承表示的,而是通过类加载器中有一个"parent"这样的字段,指向自己父亲的地址,类似于二叉树的三叉实现</p> 
<p><img alt="" height="446" src="https://images2.imgbox.com/63/36/GxAGaenE_o.png" width="761"></p> 
<p>工作过程如下:例如给定一个全限定类名,Java.Test,此时加载过程如下</p> 
<p>1.工作从ApplicationClassLoader开始进行,这个类加载器并不会立即从第三方库/自己写的代码开始搜索,而是交给自己的父亲ExtentionClassLoader去处理</p> 
<p>2.工作就到了.ExtentionClassLoader,这个类加载器也不会立即从JVM扩展库开始搜索,而是交给自己的父亲BootStrapClassLoader去处理</p> 
<p>3.工作就到了BootStrapClassLoader,这个类加载器,也不会立即从标准库中开始搜索,而是继续交给自己的父亲,由于自己的父亲为null,只能自己来处理,BootStrapClassLoader尝试在标准库的路径上开始搜索,如果这个类找到了,搜索过程完成,然后打开文件进行后续操作,如果没找到则交给自己的儿子来进行处理,</p> 
<p>4.工作回到了.ExtentionClassLoader这个类加载器尝试在JVM扩展库的路径上开始搜索,如果这个类找到了,搜索过程完成,然后打开文件进行后续操作,如果没找到则交给自己的儿子来进行处理,</p> 
<p>5.工作回到了ApplicationClassLoader,这个类加载器尝试在第三方库/自己写的代码中的路径上开始搜索,如果这个类找到了,搜索过程完成,然后打开文件进行后续操作,如果没找到则交给自己的儿子来进行处理,由于它的儿子为null,所以会抛出一个异常ClassNotFoundException</p> 
<p>上述工作流程,主要应对这个场景,如果自己写的一个类和标准库/扩展库中的类冲突了,此时JVM就会确保标准库/扩展库的类加载成功,</p> 
<p>类加载器并非只有三个,还可以手动写更多的类加载器,添加到中间</p> 
<h6 style="background-color:transparent;">JVM的垃圾回收机制GC</h6> 
<p>垃圾回收机制,是Java提供的对于自动回收的机制,自动回收相对于C++的手动回收来命名的,C++回收需要手动free函数,可能会遗漏这个操作,</p> 
<p>GC需要消耗额外的系统资源,而且存在非常影响效率的"STW"(stop the world)问题,GC回收的是内存,更准确的说是"对象",回收的是堆上的内存</p> 
<p>1)程序计数器(不需要额外回收,线程销毁,自然就回收了)</p> 
<p>2)栈(不需要额外回收,线程销毁,自然回收)</p> 
<p>3)元数据区(一般也不需要,都是加载类,很少有"卸载类")</p> 
<p>4)堆(GC回收的主力军)</p> 
<p>一定是一次回收一个完整的对象,把对象中的成员全都回收</p> 
<p>JAVAGC机制有一个方法,GC机制有两个方法</p> 
<p>GC的主要流程</p> 
<p>1.找到谁是垃圾,不被继续使用的对象</p> 
<p>使用对象都是通过引用的方式来使用,如果没有引用指向这个对象,意味着这个对象注定无法在代码被使用,被视为垃圾了,对于JVM来说不是实时的,JVM需要一定的时间周期</p> 
<p><img alt="" height="176" src="https://images2.imgbox.com/b2/53/ROmiEgc3_o.png" width="521"></p> 
<p>如何判断某个对象是否有引用指向呢?</p> 
<p>1)引用计数(不是JVM的方案,是Python和PHP的方案)</p> 
<p><img alt="" height="297" src="https://images2.imgbox.com/dd/05/SbPS2YGX_o.png" width="732"></p> 
<p>当引用计数为0时,这个对象就是垃圾了</p> 
<p>缺陷如下:</p> 
<p>               1)消耗额外的存储空间:如果对象的空间比较大,浪费的空间很小,但是如果对象的空间比较小,浪费的空间就会特别大了</p> 
<p>               2)存在"循环引用"的问题</p> 
<p><img alt="" height="649" src="https://images2.imgbox.com/9c/1f/w5xqUaH0_o.png" width="1200"></p> 
<p>2)可达性分析(是JVM采取的方案)</p> 
<p>解决了空间问题,也解决了循环引用的问题,但是时间上效率变慢,通过"遍历",JVM把对象之间的引用关系,理解成一个"树形结构",JVM就会不停的遍历这个结构,把所有能够访问到的对象标记成"可达",剩下的就是"不可达"</p> 
<p><img alt="" height="804" src="https://images2.imgbox.com/71/4b/qwPywUcG_o.png" width="921"></p> 
<p>2.释放对应的内存</p> 
<p>由于可达性分析,需要消耗一定的时间,因此,JAVA垃圾回收,没法做到实时性,会周期性进行扫描(JVM提供了一组专门负责GC的线程,不停的进行扫描工作)</p> 
<p>清理垃圾的策略:</p> 
<p>        1)标记-清除,直接把视为垃圾的对象对应的内存给释放掉,这样的做法会造成内存碎片化,后续很难申请到连续的空间,申请内存都是需要连续的</p> 
<p><img alt="" height="496" src="https://images2.imgbox.com/7b/23/Oa3TBxtj_o.png" width="1098"></p> 
<p>        2)复制算法</p> 
<p><img alt="" height="381" src="https://images2.imgbox.com/9f/51/BJ4O6J9Y_o.png" width="1184"></p> 
<p>        3)标记-整理</p> 
<p><img alt="" height="316" src="https://images2.imgbox.com/51/99/QeBlch3f_o.png" width="950"></p> 
<p>上述这三个方法,都是铺垫,JVM中实际的方案,是综合上述的方案,更复杂的策略,分代回收(分情况讨论,根据不同的场景/特点选择合适的方案),根据对象的年龄(GC有一组线程,进行周期性扫描,没有成为垃圾的对象每进过一轮年龄+1)</p> 
<p><img alt="" height="204" src="https://images2.imgbox.com/4e/c8/CI1i5Dg2_o.png" width="574"></p> 
<p>Eden是伊甸区,S0 S1是新生区/幸存区</p> 
<p><img alt="" height="385" src="https://images2.imgbox.com/18/36/YaxHMbe6_o.png" width="1153"></p> 
<p><img alt="" height="478" src="https://images2.imgbox.com/1d/18/aiSKenkh_o.png" width="1200"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f64d02916ffd4472324f871afb9d1650/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">腾讯云AI代码助手评测：如何智能高效完成Go语言Web项目开发</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/99e718f04a94af397c5faea3eece4f05/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">第12节课：本地存储与应用缓存——提升离线体验和性能</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>