<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java二十三种设计模式-建造者模式（4/23） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/2e5d9a18a42b119bd99f87e4685996cd/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java二十三种设计模式-建造者模式（4/23）">
  <meta property="og:description" content="建造者模式：构建复杂对象的专家 引言 建造者模式（Builder Pattern）是一种创建型设计模式，用于创建一个复杂的对象，同时允许用户只通过指定复杂对象的类型和内容就能构建它们，它将对象的构建和表示分离，使得相同的构建过程可以创建出不同的表示。
基础知识，java设计模式总体来说设计模式分为三大类：
（1）创建型模式，共5种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
（2）结构型模式，共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
（3）行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
第一部分：建造者模式概述 建造者模式是一种高级的创建型设计模式，旨在提供一种灵活的解决方案，用于创建复杂的对象。
1.1 定义与用途 建造者模式的基本定义 建造者模式将一个复杂对象的构建过程封装起来，同时允许按步骤构造对象。它允许用户通过相同的创建过程生成不同的表示。
为何在复杂对象的创建中需要建造者模式 分离构建和表示：将对象的构建过程从其表示中分离出来，使得构建过程不会影响对象的使用。控制复杂性：对于包含多个组成部分的复杂对象，建造者模式可以逐步构建对象，而不是一次性完成，从而简化了构建过程。增强灵活性：允许系统在构建过程中的不同阶段进行修改，而不影响其他部分。 1.2 组成元素 产品（Product） 定义：最终要创建的复杂对象。角色：通常是多个简单对象的组合体，由建造者模式逐步构建。 建造者（Builder） 定义：一个接口，定义了创建产品的方法。角色：提供了一个抽象接口，使得不同的建造者可以构建同一产品的不同表示。 导演者（Director） 定义：负责使用建造者来创建产品的类。角色：它知道如何使用建造者来得到最终的产品，通常持有一个建造者对象，并使用该对象的构建方法来创建产品。 具体建造者（Concrete Builder） 定义：实现建造者接口的具体类。角色：实现具体的构建过程，通常包含一个产品对象，并定义了如何构建该产品的步骤。 客户端（Client） 角色：使用导演者和建造者来获取最终的产品，客户端不直接与产品或具体建造者交互。 角色之间的交互 客户端：通过导演者请求产品。导演者：使用具体建造者来构建产品。具体建造者：实现建造者接口，负责构建产品的具体步骤。 建造者模式特别适合于那些需要通过多个步骤来构建的对象，且这些步骤可能因不同的使用场景而异。通过使用建造者模式，我们可以在不牺牲对象的完整性和一致性的情况下，提供灵活的对象创建过程。在下一部分中，我们将通过Java代码示例来展示建造者模式的具体实现。
第二部分：建造者模式实现 2.1 Java实现示例 以下是使用Java语言实现建造者模式的一个示例。假设我们正在构建一个复杂的汽车对象，汽车由多个部件组成，如引擎、轮胎等。
// 产品接口 interface Car { void assembleEngine(); void assembleWheels(); // 其他组装方法... } // 具体产品 class SportsCar implements Car { public void assembleEngine() { System.out.println(&#34;Assembling sports car engine.&#34;); } public void assembleWheels() { System.out.println(&#34;Assembling sports car wheels.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-15T23:32:03+08:00">
    <meta property="article:modified_time" content="2024-07-15T23:32:03+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java二十三种设计模式-建造者模式（4/23）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>建造者模式：构建复杂对象的专家</h2> 
<h3>引言</h3> 
<p>建造者模式（Builder Pattern）是一种创建型设计模式，用于创建一个复杂的对象，同时允许用户只通过指定复杂对象的类型和内容就能构建它们，它将对象的构建和表示分离，使得相同的构建过程可以创建出不同的表示。</p> 
<p><img alt="" height="500" src="https://images2.imgbox.com/b0/1b/DyZgHdTB_o.png" width="769"></p> 
<p>基础知识，java设计模式总体来说设计模式分为三大类：</p> 
<p>（1）创建型模式，共5种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p> 
<p>（2）结构型模式，共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p> 
<p>（3）行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p> 
<p><img alt="" height="729" src="https://images2.imgbox.com/4d/70/Qm8ydTRP_o.png" width="500"></p> 
<h2>第一部分：建造者模式概述</h2> 
<p>建造者模式是一种高级的创建型设计模式，旨在提供一种灵活的解决方案，用于创建复杂的对象。</p> 
<h3>1.1 定义与用途</h3> 
<h4>建造者模式的基本定义</h4> 
<p>建造者模式将一个复杂对象的构建过程封装起来，同时允许按步骤构造对象。它允许用户通过相同的创建过程生成不同的表示。</p> 
<h4>为何在复杂对象的创建中需要建造者模式</h4> 
<ul><li><strong>分离构建和表示</strong>：将对象的构建过程从其表示中分离出来，使得构建过程不会影响对象的使用。</li><li><strong>控制复杂性</strong>：对于包含多个组成部分的复杂对象，建造者模式可以逐步构建对象，而不是一次性完成，从而简化了构建过程。</li><li><strong>增强灵活性</strong>：允许系统在构建过程中的不同阶段进行修改，而不影响其他部分。</li></ul> 
<p><img alt="" height="1006" src="https://images2.imgbox.com/ca/e8/EGXw24P1_o.png" width="1200"></p> 
<h3>1.2 组成元素</h3> 
<h4>产品（Product）</h4> 
<ul><li><strong>定义</strong>：最终要创建的复杂对象。</li><li><strong>角色</strong>：通常是多个简单对象的组合体，由建造者模式逐步构建。</li></ul> 
<h4>建造者（Builder）</h4> 
<ul><li><strong>定义</strong>：一个接口，定义了创建产品的方法。</li><li><strong>角色</strong>：提供了一个抽象接口，使得不同的建造者可以构建同一产品的不同表示。</li></ul> 
<h4>导演者（Director）</h4> 
<ul><li><strong>定义</strong>：负责使用建造者来创建产品的类。</li><li><strong>角色</strong>：它知道如何使用建造者来得到最终的产品，通常持有一个建造者对象，并使用该对象的构建方法来创建产品。</li></ul> 
<h4>具体建造者（Concrete Builder）</h4> 
<ul><li><strong>定义</strong>：实现建造者接口的具体类。</li><li><strong>角色</strong>：实现具体的构建过程，通常包含一个产品对象，并定义了如何构建该产品的步骤。</li></ul> 
<h4>客户端（Client）</h4> 
<ul><li><strong>角色</strong>：使用导演者和建造者来获取最终的产品，客户端不直接与产品或具体建造者交互。</li></ul> 
<h4>角色之间的交互</h4> 
<ul><li><strong>客户端</strong>：通过导演者请求产品。</li><li><strong>导演者</strong>：使用具体建造者来构建产品。</li><li><strong>具体建造者</strong>：实现建造者接口，负责构建产品的具体步骤。</li></ul> 
<p>建造者模式特别适合于那些需要通过多个步骤来构建的对象，且这些步骤可能因不同的使用场景而异。通过使用建造者模式，我们可以在不牺牲对象的完整性和一致性的情况下，提供灵活的对象创建过程。在下一部分中，我们将通过Java代码示例来展示建造者模式的具体实现。</p> 
<p><img alt="" height="500" src="https://images2.imgbox.com/36/97/g06QS7MN_o.png" width="1200"></p> 
<p></p> 
<h2>第二部分：建造者模式实现</h2> 
<h3>2.1 Java实现示例</h3> 
<p>以下是使用Java语言实现建造者模式的一个示例。假设我们正在构建一个复杂的汽车对象，汽车由多个部件组成，如引擎、轮胎等。</p> 
<pre><code class="language-java">// 产品接口
interface Car {
    void assembleEngine();
    void assembleWheels();
    // 其他组装方法...
}

// 具体产品
class SportsCar implements Car {
    public void assembleEngine() {
        System.out.println("Assembling sports car engine.");
    }

    public void assembleWheels() {
        System.out.println("Assembling sports car wheels.");
    }
    // 其他组装方法实现...
}

// 建造者接口
interface CarBuilder {
    CarBuilder setEngine();
    CarBuilder setWheels();
    // 其他设置方法...
    Car build();
}

// 具体建造者
class SportsCarBuilder implements CarBuilder {
    private SportsCar car;

    public SportsCarBuilder() {
        this.car = new SportsCar();
    }

    public CarBuilder setEngine() {
        car.assembleEngine();
        return this;
    }

    public CarBuilder setWheels() {
        car.assembleWheels();
        return this;
    }
    
    // 其他设置方法...

    public Car build() {
        return car;
    }
}

// 导演者
class CarDirector {
    public Car construct(CarBuilder builder) {
        return builder.setEngine().setWheels().build();
    }
}

// 客户端代码
public class Client {
    public static void main(String[] args) {
        CarBuilder builder = new SportsCarBuilder();
        CarDirector director = new CarDirector();
        
        Car car = director.construct(builder);
        // 使用car...
    }
}</code></pre> 
<p></p> 
<h3>2.2 模式中的角色和职责</h3> 
<h4>产品（Product）</h4> 
<ul><li><strong>职责</strong>：定义最终要创建的复杂对象的接口。</li></ul> 
<h4>建造者（Builder）</h4> 
<ul><li><strong>职责</strong>：定义一个抽象接口，用于创建产品的不同部分。</li></ul> 
<h4>导演者（Director）</h4> 
<ul><li><strong>职责</strong>： 
  <ul><li>负责构建产品的步骤顺序。</li><li>使用建造者接口来创建产品。</li></ul></li></ul> 
<h4>具体建造者（Concrete Builder）</h4> 
<ul><li><strong>职责</strong>： 
  <ul><li>实现建造者接口，提供具体的构建步骤实现。</li><li>存储产品的状态，并返回一个完整的产品。</li></ul></li></ul> 
<h4>客户端（Client）</h4> 
<ul><li><strong>职责</strong>： 
  <ul><li>通过导演者使用建造者来获取最终的产品。</li><li>客户端不直接与具体建造者交互，而是通过导演者和建造者接口。</li></ul></li></ul> 
<h4>相互作用</h4> 
<ul><li><strong>客户端</strong>：请求导演者构建产品。</li><li><strong>导演者</strong>：通过调用具体建造者的方法，按照既定的顺序创建产品。</li><li><strong>具体建造者</strong>：实现具体的构建步骤，最终返回一个完整的产品。</li></ul> 
<p>建造者模式允许系统在创建复杂对象时保持灵活性和可扩展性。通过将构建过程封装在具体建造者中，导演者可以灵活地改变构建过程，而客户端则可以保持不变。在下一部分中，我们将探讨建造者模式的使用场景。</p> 
<p> <img alt="" height="800" src="https://images2.imgbox.com/f1/19/XFyTy8Lq_o.png" width="1200"></p> 
<h2>第三部分：建造者模式使用场景</h2> 
<h3>3.1 复杂对象的构建</h3> 
<p>在软件开发中，有时我们需要构建的对象非常复杂，可能包含多个组件和配置选项。当对象的构建过程复杂时，建造者模式提供了一种清晰和灵活的方式来组织代码。</p> 
<p><strong>何时对象构建过程复杂：</strong></p> 
<ul><li>当对象的构造函数参数列表过长，难以管理时。</li><li>当对象的创建需要多个步骤，且步骤之间存在条件逻辑时。</li></ul> 
<p><strong>建造者模式的应用：</strong></p> 
<ul><li>通过将构建过程分解为一系列步骤，建造者模式简化了复杂对象的创建。</li><li>它允许逐步设置对象的属性，而不是一次性在构造函数中完成。</li></ul> 
<h3>3.2 对象的多样性</h3> 
<p>在某些情况下，我们需要构建的对象可能有多种变体，每种变体都有不同的属性和构建步骤。</p> 
<p><strong>建造者模式的优势：</strong></p> 
<ul><li><strong>灵活性</strong>：可以轻松地添加或修改特定变体的构建步骤，而不影响其他变体。</li><li><strong>可维护性</strong>：通过将不同的构建步骤封装在不同的建造者中，提高了代码的可维护性。</li><li><strong>一致性</strong>：确保所有变体都通过相同的建造过程进行构建，保证了对象的一致性。</li></ul> 
<h2>第四部分：建造者模式的优点与缺点</h2> 
<h3>4.1 优点</h3> 
<p><strong>灵活性</strong>：</p> 
<ul><li>建造者模式允许在构建过程中轻松地添加或修改步骤，从而创建不同的对象变体。</li></ul> 
<p><strong>可扩展性</strong>：</p> 
<ul><li>当需要添加新的对象变体时，可以通过添加新的建造者来实现，而无需修改现有代码。</li></ul> 
<p><strong>解耦</strong>：</p> 
<ul><li>客户端代码与对象的构建过程解耦，客户端不需要知道对象是如何构建的。</li></ul> 
<p><strong>代码复用</strong>：</p> 
<ul><li>导演者可以使用相同的建造者来构建不同类型的产品，提高了代码的复用性。</li></ul> 
<h3>4.2 缺点</h3> 
<p><strong>系统复杂度</strong>：</p> 
<ul><li>引入建造者模式可能会增加系统的复杂度，特别是在建造者和产品类数量较多的情况下。</li></ul> 
<p><strong>性能问题</strong>：</p> 
<ul><li>如果对象的构建过程非常简单，使用建造者模式可能会引入不必要的性能开销。</li></ul> 
<p><strong>学习曲线</strong>：</p> 
<ul><li>对于新手来说，建造者模式可能比简单的构造函数或工厂方法更难理解。</li></ul> 
<p>建造者模式是一种强大的设计模式，适用于构建复杂且多变的对象。然而，它也需要谨慎使用，以避免不必要的复杂性和性能问题。在下一部分中，我们将比较建造者模式与其他设计模式，并提供一些最佳实践和建议。</p> 
<p><img alt="" height="363" src="https://images2.imgbox.com/17/4c/lfaNXgU3_o.png" width="853"></p> 
<h2>第五部分：建造者模式与其他模式的比较</h2> 
<h3>5.1 与工厂方法模式的比较</h3> 
<h4>工厂方法模式</h4> 
<ul><li><strong>定义</strong>：定义一个用于创建对象的接口，让子类决定实例化哪一个类。</li><li><strong>使用场景</strong>：当创建逻辑相对简单，且创建的对象种类较少时。</li></ul> 
<h4>建造者模式</h4> 
<ul><li><strong>定义</strong>：允许通过指定复杂对象的类型和内容来构建它们。</li><li><strong>使用场景</strong>：当创建的对象非常复杂，或者创建过程包含多个步骤时。</li></ul> 
<h4>不同点</h4> 
<ul><li><strong>复杂性</strong>：工厂方法模式适用于创建对象的逻辑相对简单的情况，而建造者模式适用于创建复杂对象。</li><li><strong>灵活性</strong>：建造者模式提供了更灵活的构建过程，允许逐步构建对象。</li></ul> 
<h3>5.2 与抽象工厂模式的对比</h3> 
<h4>抽象工厂模式</h4> 
<ul><li><strong>定义</strong>：提供一个接口，用于创建一系列相关或相互依赖的对象。</li><li><strong>使用场景</strong>：当需要创建多个产品族，并且这些产品族之间存在依赖关系时。</li></ul> 
<h4>建造者模式</h4> 
<ul><li><strong>定义</strong>：允许用户通过指定复杂对象的类型和内容来构建它们。</li><li><strong>使用场景</strong>：当需要构建的对象具有多个组成部分，并且构建过程可能非常复杂时。</li></ul> 
<h4>不同点</h4> 
<ul><li><strong>产品族</strong>：抽象工厂模式关注于创建多个产品族，而建造者模式关注于构建单个复杂对象。</li><li><strong>依赖性</strong>：抽象工厂模式中的产品通常相互依赖，建造者模式则关注于单个对象的构建过程。</li></ul> 
<p><img alt="" height="500" src="https://images2.imgbox.com/23/30/31vc54tv_o.png" width="589"></p> 
<h2>第六部分：最佳实践和建议</h2> 
<h3>6.1 使用建造者模式的最佳时机</h3> 
<ul><li><strong>复杂对象</strong>：当对象的构建涉及多个步骤或多个组成部分时。</li><li><strong>灵活性需求</strong>：当需要不同的构建过程来创建相同类型的对象时。</li></ul> 
<h3>6.2 避免滥用建造者模式</h3> 
<ul><li><strong>过度设计</strong>：避免在对象构建过程非常简单时使用建造者模式，这可能会导致不必要的复杂性。</li><li><strong>性能问题</strong>：在构建过程非常快速且不需要额外灵活性的情况下，使用建造者模式可能会引入不必要的性能开销。</li></ul> 
<h3>6.3 替代方案</h3> 
<h4>原型模式</h4> 
<ul><li><strong>定义</strong>：通过复制现有的对象来创建新的实例。</li><li><strong>适用场景</strong>：当创建新对象的成本较高，或者需要快速复制现有对象时。</li></ul> 
<h4>单例模式</h4> 
<ul><li><strong>定义</strong>：确保一个类只有一个实例，并提供一个全局访问点。</li><li><strong>适用场景</strong>：当需要严格控制对象数量，确保全局只有一个实例时。</li></ul> 
<h4>工厂方法模式</h4> 
<ul><li><strong>适用场景</strong>：当创建对象的逻辑相对简单，且创建的对象种类较少时。</li></ul> 
<p>建造者模式是一种强大的设计模式，适用于构建复杂对象的场景。然而，合理选择使用时机和避免滥用同样重要。了解替代方案可以帮助开发者根据具体需求选择最合适的设计模式。</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/5f/70/OJ8XFYsC_o.png" width="1200"></p> 
<h3 style="background-color:transparent;">结语</h3> 
<p>建造者模式是处理复杂对象创建问题的有效工具。通过本文的深入分析，希望读者能够对建造者模式有更全面的理解，并在实际开发中做出合理的设计选择。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/39a5c1145245745823e4f556bd3b7781/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">十七、【文本编辑器(三)】图像坐标变换</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/528c62f94448aadf6e0d044e890ce34b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">传输层协议之TCP</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>