<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Haproxy负载均衡 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f1033cce0406c7d0b0245d97f8ccc587/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Haproxy负载均衡">
  <meta property="og:description" content="nginx 四层转发 七层代理
lvs 四层转发内核态 用户态
Haproxy 四层转发，七层转发
1、Haproxy的作用和使用场景 1、场景 主要用户高并发的web场景，可以支出1万个以上的并发请求，高性能的tcp和http的负载均衡器。
2、工作原理 haproxy就像LVS的调度器，高可用即实现两台haproxy服务器一主一备。
3、作用 1、进行四层和七层转发
2、主持https
3、haproxy本身不自带缓存功能，可以在请求当中添加cookie，使用缓存功能
4、支持主备切换（keepalive）
4、特点 可靠性高，稳定性好
可以同时维护4万-5万并发，单位时间内可以处理的最大请求数是2万个（单位时间：1秒或者1分钟）
支持负载均衡算法，虽然不带缓存，但是可以支持会话保持
rr
wrr
leastconn
5、实验 Haproxy安装
#haproxy安装包存放在/opt cd /opt tar -xf haproxy-1.5.19.tar.gz mv haproxy-1.5.19 haproxy cd haproxy/ uname -r #查看本机的内核版本 make TARGET=linux2628 ARCH=x86_64 #TARGET内核版本要低于本机的内核版本，架构是x86_64 make install mkdir /etc/haproxy cd examples cp haproxy.cfg /etc/haproxy 对haproxy配置文件进行设置
vim /etc/haproxy/haproxy.cfg global #4-5行 log /dev/log local0 info log /dev/log local1 notice maxconn 4096 #最大连接数，推荐使用10240,需要系统内核参数修改最大打开文件数 #注释下一行 #chroot /usr/share/haproxy #添加下一行 nbproc 4 #Haproxy的并发线程数，设置的数量最好是CPU的2倍或者和CPU保持一致 defaults #默认参数配置，包括连接配置、监听配置以及代理配置 option httplog #类型 http日志 retries 3 #检查节点服务器3次，连续3次失败，就认为节点服务器不可用 redispatch #服务器负载很高时，自动结束当前队列中处理比较久的连接 maxconn 2000 #最大连接数，不能超过global设置的maxconn #下面三行注释掉，已经不用了 #contimeout #clitimeout #srvtimeout timeout http-request 10s #http请求的默认超时时间 timeout queue 1m #在队列当中请求的超时时间 timeout connect 10s #连接超时时间 timeout client 1m #客户端超时时间 timeout server 1m #服务端超时时间 timeout http-keep-alive 10s #默认长连接的超时时间（不是会话保持） timeout check 10s #检查后端服务器的超时时间 #转发请求的设置，既可以是四层，也可以是七层 #四层和七层择其一，不要都写 #七层转发的配置 listen yang1 0.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-15T17:12:20+08:00">
    <meta property="article:modified_time" content="2024-07-15T17:12:20+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Haproxy负载均衡</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>nginx 四层转发 七层代理</p> 
<p>lvs 四层转发内核态 用户态</p> 
<p>Haproxy 四层转发，七层转发</p> 
<h2>1、Haproxy的作用和使用场景</h2> 
<p>1、场景 主要用户高并发的web场景，可以支出1万个以上的并发请求，高性能的tcp和http的负载均衡器。</p> 
<h2>2、工作原理</h2> 
<p>haproxy就像LVS的调度器，高可用即实现两台haproxy服务器一主一备。</p> 
<h2>3、作用</h2> 
<p>1、进行四层和七层转发</p> 
<p>2、主持https</p> 
<p>3、haproxy本身不自带缓存功能，可以在请求当中添加cookie，使用缓存功能</p> 
<p>4、支持主备切换（keepalive）</p> 
<h2>4、特点</h2> 
<p>可靠性高，稳定性好</p> 
<p>可以同时维护4万-5万并发，单位时间内可以处理的最大请求数是2万个（单位时间：1秒或者1分钟）</p> 
<p>支持负载均衡算法，虽然不带缓存，但是可以支持会话保持</p> 
<p>rr</p> 
<p>wrr</p> 
<p>leastconn</p> 
<h2>5、实验</h2> 
<p>Haproxy安装</p> 
<pre><code class="hljs">#haproxy安装包存放在/opt
cd /opt
tar -xf haproxy-1.5.19.tar.gz
mv haproxy-1.5.19 haproxy
cd haproxy/
uname -r
#查看本机的内核版本
make TARGET=linux2628 ARCH=x86_64
#TARGET内核版本要低于本机的内核版本，架构是x86_64
make install
mkdir /etc/haproxy
cd examples
cp haproxy.cfg /etc/haproxy</code></pre> 
<p> 对haproxy配置文件进行设置</p> 
<pre><code class="hljs">vim /etc/haproxy/haproxy.cfg

global
#4-5行
	log /dev/log local0 info
	log /dev/log local1 notice
	maxconn 4096
	#最大连接数，推荐使用10240,需要系统内核参数修改最大打开文件数
	#注释下一行
	#chroot /usr/share/haproxy
	
	#添加下一行
	nbproc 4
	#Haproxy的并发线程数，设置的数量最好是CPU的2倍或者和CPU保持一致

defaults
#默认参数配置，包括连接配置、监听配置以及代理配置
	option httplog
	#类型 http日志
	retries 3
	#检查节点服务器3次，连续3次失败，就认为节点服务器不可用
	redispatch
	#服务器负载很高时，自动结束当前队列中处理比较久的连接
	maxconn 2000
	#最大连接数，不能超过global设置的maxconn
	#下面三行注释掉，已经不用了
	#contimeout
	#clitimeout
	#srvtimeout
	
	
	timeout http-request 10s
	#http请求的默认超时时间
	timeout queue 1m
	#在队列当中请求的超时时间
	timeout connect 10s
	#连接超时时间
	timeout client 1m
	#客户端超时时间
	timeout server 1m
	#服务端超时时间
	timeout http-keep-alive 10s
	#默认长连接的超时时间（不是会话保持）
	timeout check 10s
	#检查后端服务器的超时时间


#转发请求的设置，既可以是四层，也可以是七层
#四层和七层择其一，不要都写

#七层转发的配置
listen yang1 0.0.0.0:80
	option httpchk GET /index.html
	#设置转发请求的内容，方式GET, 获取内容 index.html
	balance static-rr
	#轮询算法
	server rs01 192.168.10.41:80 check inter 2000 fall 3 weight 2
	server rs02 192.168.10.42:80 check inter 2000 fall 3 weight 3

	#server 指定真实服务器，rs01 自定义后端服务器名称
	#check inter 2000 ：启动对后端服务器进行健康检查，检查的间隔时间2000ms
	#fall 3 连续三次检查不到，任务失败

#四层转发
#四层转发的配置
frontend test
#定义服务的名称为test，前端名为test
	bind *:80
	#监听所有网络接口，端口为80
	mode tcp
	#设置负载均衡的模式为TCP
	default_backend test
	#指定默认后端服务名为test

backend test
#定义后端名为test，负责处理前端传递来的请求
	mode tcp
	#前后端模式匹配，都设置为TCP
	balance roundrobin
	#设置负载均衡算法为轮询，即rr
	server rs01 192.168.10.41:80 check inter 2000 fall 3 weight 2
	server rs02 192.168.10.42:80 check inter 2000 fall 3 weight 3

#保存配置</code></pre> 
<p> 让haproxy命令可以被系统识别到</p> 
<pre><code class="hljs">cd /haproxy/example
cp haproxy.init /etc/init.d/haproxy
chmod 777 /etc/init.d/haproxy
chkconfig --add /etc/init.d/haproxy
ln -s /usr/local/sbin/haproxy /usr/sbin</code></pre> 
<p>启动haproxy服务</p> 
<pre><code class="hljs">systemctl start haproxy</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2aaa5a06807f2477b3ccff7d1ed21598/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;初阶：类和对象（二）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a19cccc3fb861d9cfd774298a75e41c4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Qt】信号与槽</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>