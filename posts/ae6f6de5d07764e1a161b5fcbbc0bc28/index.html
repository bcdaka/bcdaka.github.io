<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构【栈和队列】 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ae6f6de5d07764e1a161b5fcbbc0bc28/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构【栈和队列】">
  <meta property="og:description" content="目录
栈
概念与结构
栈的实现
栈的数据
栈的初始化
入栈
出栈
取栈顶元素
获取有效个数
栈的销毁
队列
概念与结构
队列的实现
队列的数据
初始化队列
入队列
出队列
取队头数据
取队尾数据
获取有效个数
队列销毁
栈的代码
stack.h
stack.c
test.c
队列的代码
Queue.h
Queue.c
test.c
栈 概念与结构 栈：⼀种特殊的线性表，其只允许在固定的⼀端进⾏插⼊和删除元素操作。进⾏数据插⼊和删除操作 的⼀端称为栈顶，另⼀端称为栈底。栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则。
压栈：栈的插⼊操作叫做进栈/压栈/⼊栈，⼊数据在栈顶。
出栈：栈的删除操作叫做出栈。出数据也在栈顶。
栈底层结构选型。
栈的实现⼀般可以使⽤数组或者链表实现，相对⽽⾔数组的结构实现更优⼀些。因为数组在尾上插⼊ 数据的代价⽐较⼩。
栈的实现 栈我们用顺序表来实现
栈的数据 arr就是数组，给arr申请空间后就是数组了。
空间就是有多少个空间。
栈顶是用来进栈和出栈的。
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;stdbool.h&gt; #include&lt;assert.h&gt; typedef int data; typedef struct stack { data* arr;//存放数值 int koj; //空间 int top; //栈顶 }stack; 栈的初始化 //初始化 void stack_csh(stack* r); 把arr置为空。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-14T13:05:04+08:00">
    <meta property="article:modified_time" content="2024-08-14T13:05:04+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构【栈和队列】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 style="text-align:center;"></h4> 
<p><img alt="" height="467" src="https://images2.imgbox.com/a5/c9/MDPcl7Lc_o.gif" width="830"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:80px;"></p> 
<p id="-toc" style="margin-left:80px;"></p> 
<p id="%E6%A0%88-toc" style="margin-left:80px;"><a href="#%E6%A0%88" rel="nofollow">栈</a></p> 
<p id="%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%BB%93%E6%9E%84-toc" style="margin-left:120px;"><a href="#%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%BB%93%E6%9E%84" rel="nofollow">概念与结构</a></p> 
<p id="%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">栈的实现</a></p> 
<p id="%E6%A0%88%E7%9A%84%E6%95%B0%E6%8D%AE-toc" style="margin-left:120px;"><a href="#%E6%A0%88%E7%9A%84%E6%95%B0%E6%8D%AE" rel="nofollow">栈的数据</a></p> 
<p id="%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:120px;"><a href="#%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">栈的初始化</a></p> 
<p id="%E5%85%A5%E6%A0%88-toc" style="margin-left:120px;"><a href="#%E5%85%A5%E6%A0%88" rel="nofollow">入栈</a></p> 
<p id="%E5%87%BA%E6%A0%88-toc" style="margin-left:120px;"><a href="#%E5%87%BA%E6%A0%88" rel="nofollow">出栈</a></p> 
<p id="%E5%8F%96%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0-toc" style="margin-left:120px;"><a href="#%E5%8F%96%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0" rel="nofollow">取栈顶元素</a></p> 
<p id="%E8%8E%B7%E5%8F%96%E6%9C%89%E6%95%88%E4%B8%AA%E6%95%B0-toc" style="margin-left:120px;"><a href="#%E8%8E%B7%E5%8F%96%E6%9C%89%E6%95%88%E4%B8%AA%E6%95%B0" rel="nofollow">获取有效个数</a></p> 
<p id="%E6%A0%88%E7%9A%84%E9%94%80%E6%AF%81-toc" style="margin-left:120px;"><a href="#%E6%A0%88%E7%9A%84%E9%94%80%E6%AF%81" rel="nofollow">栈的销毁</a></p> 
<p id="%E9%98%9F%E5%88%97-toc" style="margin-left:80px;"><a href="#%E9%98%9F%E5%88%97" rel="nofollow">队列</a></p> 
<p id="%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%BB%93%E6%9E%84-toc" style="margin-left:120px;"><a href="#%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%BB%93%E6%9E%84" rel="nofollow">概念与结构</a></p> 
<p id="%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">队列的实现</a></p> 
<p id="%E9%98%9F%E5%88%97%E7%9A%84%E6%95%B0%E6%8D%AE-toc" style="margin-left:120px;"><a href="#%E9%98%9F%E5%88%97%E7%9A%84%E6%95%B0%E6%8D%AE" rel="nofollow">队列的数据</a></p> 
<p id="%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%9F%E5%88%97-toc" style="margin-left:120px;"><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%9F%E5%88%97" rel="nofollow">初始化队列</a></p> 
<p id="%E5%85%A5%E9%98%9F%E5%88%97-toc" style="margin-left:120px;"><a href="#%E5%85%A5%E9%98%9F%E5%88%97" rel="nofollow">入队列</a></p> 
<p id="%E5%87%BA%E9%98%9F%E5%88%97-toc" style="margin-left:120px;"><a href="#%E5%87%BA%E9%98%9F%E5%88%97" rel="nofollow">出队列</a></p> 
<p id="%E5%8F%96%E9%98%9F%E5%A4%B4%E6%95%B0%E6%8D%AE-toc" style="margin-left:120px;"><a href="#%E5%8F%96%E9%98%9F%E5%A4%B4%E6%95%B0%E6%8D%AE" rel="nofollow">取队头数据</a></p> 
<p id="%E5%8F%96%E9%98%9F%E5%B0%BE%E6%95%B0%E6%8D%AE-toc" style="margin-left:120px;"><a href="#%E5%8F%96%E9%98%9F%E5%B0%BE%E6%95%B0%E6%8D%AE" rel="nofollow">取队尾数据</a></p> 
<p id="%E8%8E%B7%E5%8F%96%E6%9C%89%E6%95%88%E4%B8%AA%E6%95%B0-toc" style="margin-left:120px;"><a href="#%E8%8E%B7%E5%8F%96%E6%9C%89%E6%95%88%E4%B8%AA%E6%95%B0" rel="nofollow">获取有效个数</a></p> 
<p id="%E9%98%9F%E5%88%97%E9%94%80%E6%AF%81-toc" style="margin-left:120px;"><a href="#%E9%98%9F%E5%88%97%E9%94%80%E6%AF%81" rel="nofollow">队列销毁</a></p> 
<p id="%E6%A0%88%E7%9A%84%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%E6%A0%88%E7%9A%84%E4%BB%A3%E7%A0%81" rel="nofollow">栈的代码</a></p> 
<p id="stack.h-toc" style="margin-left:120px;"><a href="#stack.h" rel="nofollow">stack.h</a></p> 
<p id="stack.c-toc" style="margin-left:120px;"><a href="#stack.c" rel="nofollow">stack.c</a></p> 
<p id="test.c-toc" style="margin-left:120px;"><a href="#test.c" rel="nofollow">test.c</a></p> 
<p id="%E9%98%9F%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%E9%98%9F%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81" rel="nofollow">队列的代码</a></p> 
<p id="Queue.h-toc" style="margin-left:120px;"><a href="#Queue.h" rel="nofollow">Queue.h</a></p> 
<p id="Queue.c-toc" style="margin-left:120px;"><a href="#Queue.c" rel="nofollow">Queue.c</a></p> 
<p id="test.c-toc" style="margin-left:120px;"><a href="#test.c" rel="nofollow">test.c</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h4 id="%E6%A0%88" style="background-color:transparent;">栈</h4> 
<h5 id="%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%BB%93%E6%9E%84">概念与结构</h5> 
<p><span style="background-color:#a2e043;">栈：⼀种特殊的线性表，其只允许在固定的⼀端进⾏插⼊和删除元素操作。进⾏数据插⼊和删除操作 的⼀端称为栈顶，另⼀端称为栈底。栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则。</span></p> 
<blockquote> 
 <p>压栈：栈的插⼊操作叫做进栈/压栈/⼊栈，⼊数据在栈顶。</p> 
 <p>出栈：栈的删除操作叫做出栈。出数据也在栈顶。</p> 
</blockquote> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/30/40/jX7wbl7P_o.png" width="1200"></p> 
<p>栈底层结构选型。</p> 
<p><span style="color:#fe2c24;"><strong>栈的实现⼀般可以使⽤数组或者链表实现，相对⽽⾔数组的结构实现更优⼀些。因为数组在尾上插⼊ 数据的代价⽐较⼩。</strong></span></p> 
<h4 id="%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0">栈的实现</h4> 
<p>栈我们用顺序表来实现</p> 
<h5 id="%E6%A0%88%E7%9A%84%E6%95%B0%E6%8D%AE">栈的数据</h5> 
<p><span style="color:#fe2c24;">arr就是数组，给arr申请空间后就是数组了。</span></p> 
<p><span style="color:#fe2c24;">空间就是有多少个空间。</span></p> 
<p><span style="color:#fe2c24;">栈顶是用来进栈和出栈的。</span></p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/2e/dc/ECrKCk0C_o.png" width="449"></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;stdbool.h&gt;
#include&lt;assert.h&gt;
typedef int data;
typedef struct stack
{
	data* arr;//存放数值
	int koj;  //空间
	int top;  //栈顶
}stack;</code></pre> 
<hr> 
<h5 id="%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">栈的初始化</h5> 
<p><img alt="" height="419" src="https://images2.imgbox.com/3a/5a/D7egEGMV_o.png" width="540"></p> 
<pre><code class="language-cpp">//初始化
void stack_csh(stack* r);</code></pre> 
<hr> 
<p><span style="color:#fe2c24;"><strong>把arr置为空。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>把koj和栈顶置为0。 </strong></span></p> 
<p><img alt="" height="318" src="https://images2.imgbox.com/b9/8c/9Vb0x7Rj_o.png" width="506"></p> 
<pre><code class="language-cpp">//初始化
void stack_csh(stack* r)
{
	assert(r);
	r-&gt;arr = NULL;
	r-&gt;koj = r-&gt;top = 0;
}</code></pre> 
<hr> 
<h5 id="%E5%85%A5%E6%A0%88">入栈</h5> 
<p><img alt="" height="242" src="https://images2.imgbox.com/d1/f8/jufSrOrS_o.png" width="462"></p> 
<pre><code class="language-cpp">//入栈
void stack_push(stack* r, data x);</code></pre> 
<hr> 
<p><span style="color:#fe2c24;">思路：先判断空间够不够，不够就2倍增容。</span></p> 
<p><span style="color:#fe2c24;">够的话，在栈顶的位置插入数据x。</span></p> 
<p><img alt="" height="523" src="https://images2.imgbox.com/3c/10/cY7e87xf_o.png" width="698"></p> 
<pre><code class="language-cpp">//入栈
void stack_push(stack* r, data x)
{
	assert(r);
	//空间大小等于栈顶，就说明空间不够
	if (r-&gt;koj == r-&gt;top)
	{
		int koj1 = r-&gt;koj == 0 ? 4 : 2 * r-&gt;koj;
		stack* tab = (stack*)realloc(r-&gt;arr, sizeof(stack));
		if (tab == NULL)
		{
			perror("realloc");
			exit(1);
		}
		//把新申请的空间给r
		r-&gt;arr = tab;
		r-&gt;koj = koj1;
	}
	//空间够直接入栈
	r-&gt;arr[r-&gt;top] = x;
	r-&gt;top++;
}</code></pre> 
<hr> 
<p><img alt="" height="728" src="https://images2.imgbox.com/ac/27/ldwIJRsc_o.png" width="911"></p> 
<pre><code class="language-cpp">void p()
{
	stack add;
	//初始化栈
	stack_csh(&amp;add);
	//入栈
	stack_push(&amp;add,1);
	stack_push(&amp;add,2);
	stack_push(&amp;add,3);
	stack_push(&amp;add,4);
}

int main()
{
	p();
	return 0;
}</code></pre> 
<hr> 
<h5 id="%E5%87%BA%E6%A0%88">出栈</h5> 
<p><img alt="" height="151" src="https://images2.imgbox.com/a3/95/Ooqlg1RY_o.png" width="385"></p> 
<pre><code class="language-cpp">//布尔类型
bool buer(stack* r);

//出栈
void stack_pop(stack* r);</code></pre> 
<hr> 
<p>布尔类型，栈顶为0返回真，不为0返回假</p> 
<p><img alt="" height="156" src="https://images2.imgbox.com/22/b2/PwUEXRuP_o.png" width="318"></p> 
<pre><code class="language-cpp">//布尔类型
bool buer(stack* r)
{
	assert(r);
	return r-&gt;top == 0;
}
</code></pre> 
<hr> 
<p>这里布尔类型接收真，假，这个逻辑非！把真变假，把假变真。</p> 
<p>栈的删除操作叫做出栈。</p> 
<p>我们只需要让，栈顶减减就行了</p> 
<p><img alt="" height="222" src="https://images2.imgbox.com/04/02/m4lGa12K_o.png" width="342"></p> 
<pre><code class="language-cpp">//出栈
void stack_pop(stack* r)
{
	assert(r);
	//布尔类型
	assert(!buer(r));
	r-&gt;top--;
}</code></pre> 
<hr> 
<p>出栈我们可以用循环来出栈，也可以用4条来出栈。</p> 
<p><img alt="" height="553" src="https://images2.imgbox.com/74/b8/4ZljIzph_o.png" width="384"></p> 
<hr> 
<h5 id="%E5%8F%96%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0">取栈顶元素</h5> 
<p><img alt="" height="78" src="https://images2.imgbox.com/51/d9/s7mJGdxa_o.png" width="353"></p> 
<pre><code class="language-cpp">//取栈顶
data stack_top(stack* r);</code></pre> 
<hr> 
<p></p> 
<p><img alt="" height="255" src="https://images2.imgbox.com/b7/63/BMRaE4wa_o.png" width="448"></p> 
<hr> 
<p><span style="color:#fe2c24;"><strong>arr数组的栈顶减1这个位置就可以拿到4。</strong></span></p> 
<p><img alt="" height="197" src="https://images2.imgbox.com/39/21/nxLY9oZA_o.png" width="387"></p> 
<pre><code class="language-cpp">//取出栈顶
data stack_top(stack* r)
{
	assert(r);
	assert(!buer(r));
	return r-&gt;arr[r-&gt;top - 1];
}</code></pre> 
<hr> 
<p><span style="color:#fe2c24;"><strong>取出栈顶的数据赋值给tab，然后打印出来。然后出栈</strong></span></p> 
<p><img alt="" height="483" src="https://images2.imgbox.com/ac/fd/nMoqElaX_o.png" width="655"></p> 
<pre><code class="language-cpp">	while (!buer(&amp;add))
	{
		//取出栈顶数据
		data tab = stack_top(&amp;add);
		printf("%d ", tab);

		//出栈
		stack_pop(&amp;add);

	}</code></pre> 
<hr> 
<h5 id="%E8%8E%B7%E5%8F%96%E6%9C%89%E6%95%88%E4%B8%AA%E6%95%B0">获取有效个数</h5> 
<p><img alt="" height="156" src="https://images2.imgbox.com/6a/fc/JTXKR8Qu_o.png" width="386"></p> 
<pre><code class="language-cpp">//获取有效个数
data stack_size(stack* r);</code></pre> 
<hr> 
<p>我们直接返回top就行了。</p> 
<p><img alt="" height="178" src="https://images2.imgbox.com/f4/60/rTleolpn_o.png" width="355"></p> 
<pre><code class="language-cpp">//有效个数
data stack_size(stack* r)
{
	assert(r);
	return r-&gt;top;
}
</code></pre> 
<hr> 
<p>当前有效个数是4，循环出栈后，有效个数是0</p> 
<p><img alt="" height="463" src="https://images2.imgbox.com/a7/89/bLuUndNk_o.png" width="713"></p> 
<hr> 
<h5 id="%E6%A0%88%E7%9A%84%E9%94%80%E6%AF%81">栈的销毁</h5> 
<p><img alt="" height="82" src="https://images2.imgbox.com/a6/aa/WJGPJq6P_o.png" width="239"></p> 
<pre><code class="language-cpp">//销毁
void xiaoh(stack* r);</code></pre> 
<hr> 
<p>判断arr这个空间是不是空，不是空释放arr空间，</p> 
<p>koj和top赋值为0。</p> 
<p><img alt="" height="268" src="https://images2.imgbox.com/97/af/JZxZzbAP_o.png" width="348"></p> 
<pre><code class="language-cpp">//销毁
void xiaoh(stack* r)
{
	assert(r);
	if (r-&gt;arr != NULL)
	{
		free(r-&gt;arr);
	}
	r-&gt;arr = NULL;
	r-&gt;koj = r-&gt;top = 0;
}</code></pre> 
<hr> 
<h4 id="%E9%98%9F%E5%88%97">队列</h4> 
<h5 style="background-color:transparent;">概念与结构</h5> 
<p><span style="background-color:#a2e043;">概念：只允许在⼀端进⾏插⼊数据操作，在另⼀端进⾏删除数据操作的特殊线性表，队列具有先进先 出FIFO(First In First Out)</span></p> 
<blockquote> 
 <p>⼊队列：进⾏插⼊操作的⼀端称为<span style="color:#fe2c24;">队尾</span></p> 
 <p>出队列：进⾏删除操作的⼀端称为<span style="color:#fe2c24;">队头</span></p> 
</blockquote> 
<p><img alt="" height="216" src="https://images2.imgbox.com/3a/c6/i3x9nmv9_o.png" width="850"></p> 
<p>队列底层结构选型</p> 
<p><span style="color:#fe2c24;"><strong>队列也可以数组和链表的结构实现，使⽤链表的结构实现更优⼀些，因为如果使⽤数组的结构，出队 列在数组头上出数据，效率会⽐较低。</strong></span></p> 
<hr> 
<h4 id="%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0">队列的实现</h4> 
<p>创建3个文件，test.c测试文件，Queue.h头文件，Queue.c函数文件</p> 
<p><img alt="" height="161" src="https://images2.imgbox.com/0f/3f/HWMLleM5_o.png" width="174"></p> 
<hr> 
<h5 id="%E9%98%9F%E5%88%97%E7%9A%84%E6%95%B0%E6%8D%AE">队列的数据</h5> 
<p><img alt="" height="513" src="https://images2.imgbox.com/2a/09/6oztSzGe_o.png" width="704"></p> 
<pre><code class="language-cpp">typedef int data;
typedef struct queuedata//单链表
{
	data arr;//存放的数据
	struct queuedata* p;//指向下一个节点
}queuedata;

typedef struct Queue
{
	queuedata* to; //队头——单链表的 头节点
	queuedata* wei;//队尾——单链表的 尾节点
	int size; //有效个数
}Queue;</code></pre> 
<hr> 
<h5 id="%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%9F%E5%88%97">初始化队列</h5> 
<p><img alt="" height="391" src="https://images2.imgbox.com/5b/74/rZ22plLR_o.png" width="455"></p> 
<pre><code class="language-cpp">//初始化
void csh(Queue* r);</code></pre> 
<hr> 
<p>我们只需要把队头和队尾置为NULL，有效个数给0。</p> 
<p><img alt="" height="190" src="https://images2.imgbox.com/66/8b/k4LWt9hj_o.png" width="300"></p> 
<pre><code class="language-cpp">//初始化
void csh(Queue* r)
{
	assert(r);
	r-&gt;to = r-&gt;wei = NULL;
	r-&gt;size = 0;
}</code></pre> 
<hr> 
<p><img alt="" height="102" src="https://images2.imgbox.com/3c/29/98PiHl14_o.png" width="1131"></p> 
<hr> 
<h5 id="%E5%85%A5%E9%98%9F%E5%88%97">入队列</h5> 
<p><strong><span style="color:#fe2c24;">入队列要从队尾进入</span></strong></p> 
<p><img alt="" height="139" src="https://images2.imgbox.com/3b/e5/gyyDsLYY_o.png" width="356"></p> 
<pre><code class="language-cpp">//入队，队尾
void dui_wei(Queue* r,data x);</code></pre> 
<hr> 
<p>思路:</p> 
<p><span style="color:#fe2c24;"><strong>1.申请一个单链表的空间，把x给新申请的空间，</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>2.判断队尾是不是空，是空当前链表里没有数据，所以让队头和队尾指向新申请的空间，</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>3.不是空，这个和单链表的尾插差不多，队尾的p指向新申请的空间，</strong></span></p> 
<p>有效个数加1</p> 
<p><img alt="" height="738" src="https://images2.imgbox.com/dd/cd/oYFS1htW_o.png" width="682"></p> 
<pre><code class="language-cpp">//入队尾
void dui_wei(Queue* r,data x)
{
	assert(r);
	//申请单链表空间
	queuedata* tab = (queuedata*)malloc(sizeof(queuedata));
	if (tab == NULL)
	{
		perror("malloc");
		exit(1);
	}
	//把x赋值给新申请空间的arr
	tab-&gt;arr = x;
	tab-&gt;p = NULL;

	//入队
	//判断队尾是不是空
	if (r-&gt;wei == NULL)
	{
		//是空，队头队尾指向新申请的空间
		r-&gt;to = r-&gt;wei = tab;
	}
	else//不是空
	{
		//队尾p指向新申请的空间
		r-&gt;wei-&gt;p = tab;
		//队尾走到新申请的空间
		r-&gt;wei = r-&gt;wei-&gt;p;
	}
	//有效个数加1
	r-&gt;size++;
}</code></pre> 
<hr> 
<p>我们可以看到插入了4个数据1,2,3,4，有效个数是4</p> 
<p><img alt="" height="628" src="https://images2.imgbox.com/ef/67/IBTDBoiG_o.png" width="1200"></p> 
<pre><code class="language-cpp">void p()
{
	Queue add;
	//初始化
	csh(&amp;add);
	//入队，尾
	dui_wei(&amp;add, 1);
	dui_wei(&amp;add, 2);
	dui_wei(&amp;add, 3);
	dui_wei(&amp;add, 4);

}

int main()
{
	p();
	return 0;
}</code></pre> 
<hr> 
<h5 id="%E5%87%BA%E9%98%9F%E5%88%97">出队列</h5> 
<p>出队列：进⾏删除操作的⼀端称为<span style="color:#fe2c24;">队头</span></p> 
<p><strong><span style="color:#fe2c24;">出队列要从队头出，</span></strong></p> 
<hr> 
<p>出队列，我们要用布尔类型，判断链表是不是空，是空不能出队列，报错。</p> 
<p><img alt="" height="135" src="https://images2.imgbox.com/5e/be/PQPZQiNX_o.png" width="361"></p> 
<pre><code class="language-cpp">//布尔类型
bool buer(Queue* r);
//出队列
void dui_to(Queue* r);</code></pre> 
<hr> 
<p>布尔判断队头是不是等于空，是返回真，不是返回假。</p> 
<p><img alt="" height="159" src="https://images2.imgbox.com/8c/3e/pUVvrc8e_o.png" width="319"></p> 
<pre><code class="language-cpp">//布尔类型
bool buer(Queue* r)
{
	assert(r);
	return r-&gt;to == NULL;
}</code></pre> 
<hr> 
<p><span style="color:#fe2c24;"><strong>思路：判断队头等于队尾，说明只有一个节点。直接释放就行了，</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>不等于说明有链表里有空间，把头节点的下一个节点给tab，释放头节点，再把tab给头节点。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>有效个数减1</strong></span></p> 
<p><img alt="" height="608" src="https://images2.imgbox.com/fe/be/n48g2Dtw_o.png" width="518"></p> 
<pre><code class="language-cpp">
//出队,头
void dui_to(Queue* r)
{
	assert(r);
	//布尔类型，！把真变假，把假变真
	assert(!buer(r));
	//判断队头等于队尾，就说明只有一个节点
	if (r-&gt;to == r-&gt;wei)
	{
		//直接释放空间
		free(r-&gt;to);
		//把队头和队尾置为空
		r-&gt;to = r-&gt;wei = NULL;
	}
	else
	{
		//把队头的下一个节点给tab
		queuedata* tab = r-&gt;to-&gt;p;
		//释放当前队头节点
		free(r-&gt;to);
		//把tab节点给队头
		r-&gt;to = tab;
	}
	//有效个数减1
	--r-&gt;size;
}
</code></pre> 
<hr> 
<h5 id="%E5%8F%96%E9%98%9F%E5%A4%B4%E6%95%B0%E6%8D%AE">取队头数据</h5> 
<p><img alt="" height="82" src="https://images2.imgbox.com/9a/ff/uzI5c1sg_o.png" width="260"></p> 
<pre><code class="language-cpp">//取队头数据
data qto(Queue* r);</code></pre> 
<hr> 
<p>直接返回头节点的数据就行了</p> 
<p><img alt="" height="190" src="https://images2.imgbox.com/f9/d3/srEbaqCv_o.png" width="281"></p> 
<pre><code class="language-cpp">//取队头数据
data qto(Queue* r)
{
	assert(r);
	assert(!buer(r));
	return r-&gt;to-&gt;arr;
}</code></pre> 
<hr> 
<p><img alt="" height="260" src="https://images2.imgbox.com/e6/a6/3rX8Zg9p_o.png" width="498"></p> 
<pre><code class="language-cpp">printf("头:%d\n", qto(&amp;add));</code></pre> 
<hr> 
<h5 id="%E5%8F%96%E9%98%9F%E5%B0%BE%E6%95%B0%E6%8D%AE">取队尾数据</h5> 
<p><img alt="" height="81" src="https://images2.imgbox.com/7d/ac/XcY6aA2V_o.png" width="263"></p> 
<pre><code class="language-cpp">//取队尾数据
data qwei(Queue* r);</code></pre> 
<hr> 
<p>直接返回队尾的数据就行了。</p> 
<p><img alt="" height="197" src="https://images2.imgbox.com/2c/dc/4rD7KRy7_o.png" width="292"></p> 
<pre><code class="language-cpp">//取尾
data qwei(Queue* r)
{
	assert(r);
	assert(!buer(r));
	return r-&gt;wei-&gt;arr;
}</code></pre> 
<hr> 
<p><img alt="" height="266" src="https://images2.imgbox.com/0e/99/4m8DQkHd_o.png" width="494"></p> 
<pre><code class="language-cpp">printf("尾:%d\n", qwei(&amp;add));</code></pre> 
<hr> 
<h5>获取有效个数</h5> 
<p><img alt="" height="87" src="https://images2.imgbox.com/54/47/xeuBDZWl_o.png" width="283"></p> 
<pre><code class="language-cpp">//有效个数
data size(Queue* r);</code></pre> 
<hr> 
<p><img alt="" height="175" src="https://images2.imgbox.com/81/bc/oczXaqMK_o.png" width="264"></p> 
<pre><code class="language-cpp">//有效个数
data size(Queue* r)
{
	assert(r);
	return r-&gt;size;
}
</code></pre> 
<hr> 
<p><img alt="" height="287" src="https://images2.imgbox.com/ff/1c/7hfstVqL_o.png" width="577"></p> 
<pre><code class="language-cpp">printf("size:%d\n", size(&amp;add));</code></pre> 
<hr> 
<h5 id="%E9%98%9F%E5%88%97%E9%94%80%E6%AF%81" style="background-color:transparent;">队列销毁</h5> 
<p><img alt="" height="81" src="https://images2.imgbox.com/c4/48/hw1lxJuk_o.png" width="250"></p> 
<pre><code class="language-cpp">
//销毁
void xiaoh(Queue* r);</code></pre> 
<hr> 
<p><span style="color:#fe2c24;">把队头给tab，让tab循环销毁单链表，add保存头节点的下一个节点，释放头节点，把add给tab，</span></p> 
<p><span style="color:#fe2c24;">把队头和队尾置为NULL，有效个数给0。</span></p> 
<p><img alt="" height="536" src="https://images2.imgbox.com/c0/f7/dN2JmoDI_o.png" width="459"></p> 
<pre><code class="language-cpp">//销毁
void xiaoh(Queue* r)
{
	assert(r);
	assert(!buer(r));
	//把队头给tab
	queuedata* tab = r-&gt;to;
	//循环销毁单链表
	while (tab != NULL)
	{
		//add保存头节点的下一个节点
		queuedata* add = tab-&gt;p;
		//释放头节点
		free(tab);
		//把add给tab
		tab = add;
	}
	//把队头和队尾置为空
	r-&gt;to = r-&gt;wei = NULL;
	//有效个数赋值为0
	r-&gt;size = 0;
}</code></pre> 
<hr> 
<h4 id="%E6%A0%88%E7%9A%84%E4%BB%A3%E7%A0%81">栈的代码</h4> 
<h5 id="stack.h">stack.h</h5> 
<pre><code class="language-cpp">#pragma once
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;stdbool.h&gt;
#include&lt;assert.h&gt;
typedef int data;
typedef struct stack
{
	data* arr;//存放数值
	int koj;  //空间
	int top;  //栈顶
}stack;

//初始化
void stack_csh(stack* r);
//入栈
void stack_push(stack* r, data x);

//布尔类型
bool buer(stack* r);

//出栈
void stack_pop(stack* r);

//取栈顶
data stack_top(stack* r);

//获取有效个数
data stack_size(stack* r);

//销毁
void xiaoh(stack* r);</code></pre> 
<h5 id="stack.c">stack.c</h5> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1
#include"stack.h"

//初始化
void stack_csh(stack* r)
{
	assert(r);
	r-&gt;arr = NULL;
	r-&gt;koj = r-&gt;top = 0;
}

//入栈
void stack_push(stack* r, data x)
{
	assert(r);
	//空间大小等于栈顶，就说明空间不够
	if (r-&gt;koj == r-&gt;top)
	{
		int koj1 = r-&gt;koj == 0 ? 4 : 2 * r-&gt;koj;
		stack* tab = (stack*)realloc(r-&gt;arr, sizeof(stack));
		if (tab == NULL)
		{
			perror("realloc");
			exit(1);
		}
		//把新申请的空间给r
		r-&gt;arr = tab;
		r-&gt;koj = koj1;
	}
	//空间够直接入栈
	r-&gt;arr[r-&gt;top] = x;
	r-&gt;top++;
}

//布尔类型
bool buer(stack* r)
{
	assert(r);
	return r-&gt;top == 0;
}

//出栈
void stack_pop(stack* r)
{
	assert(r);
	//布尔类型
	assert(!buer(r));
	r-&gt;top--;
}

//取出栈顶
data stack_top(stack* r)
{
	assert(r);
	assert(!buer(r));
	return r-&gt;arr[r-&gt;top - 1];
}

//有效个数
data stack_size(stack* r)
{
	assert(r);
	return r-&gt;top;
}

//销毁
void xiaoh(stack* r)
{
	assert(r);
	if (r-&gt;arr != NULL)
	{
		free(r-&gt;arr);
	}
	r-&gt;arr = NULL;
	r-&gt;koj = r-&gt;top = 0;
}</code></pre> 
<h5 id="test.c">test.c</h5> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1
#include"stack.h"


void p()
{
	stack add;
	//初始化栈
	stack_csh(&amp;add);
	//入栈
	stack_push(&amp;add,1);
	stack_push(&amp;add,2);
	stack_push(&amp;add,3);
	stack_push(&amp;add,4);
	//出栈
	/*stack_pop(&amp;add);
	stack_pop(&amp;add);
	stack_pop(&amp;add);
	stack_pop(&amp;add);*/
	printf("size:%d\n", stack_size(&amp;add));

	while (!buer(&amp;add))
	{
		//取出栈顶数据
		data tab = stack_top(&amp;add);
		printf("%d ", tab);

		//出栈
		stack_pop(&amp;add);

	}
	printf("size:%d\n", stack_size(&amp;add));

	//销毁
	xiaoh(&amp;add);
}

int main()
{
	p();
	return 0;
}</code></pre> 
<hr> 
<h4 id="%E9%98%9F%E5%88%97%E7%9A%84%E4%BB%A3%E7%A0%81">队列的代码</h4> 
<h5 id="Queue.h">Queue.h</h5> 
<pre><code class="language-cpp">#pragma once
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;

typedef int data;
typedef struct queuedata//单链表
{
	data arr;//存放的数据
	struct queuedata* p;//指向下一个节点
}queuedata;

typedef struct Queue
{
	queuedata* to; //队头——单链表的 头节点
	queuedata* wei;//队尾——单链表的 尾节点
	int size; //有效个数
}Queue;

//初始化
void csh(Queue* r);

//入队，队尾
void dui_wei(Queue* r,data x);

//布尔类型
bool buer(Queue* r);
//出队列
void dui_to(Queue* r);

//取队头数据
data qto(Queue* r);

//取队尾数据
data qwei(Queue* r);

//有效个数
data size(Queue* r);

//销毁
void xiaoh(Queue* r);</code></pre> 
<h5 id="Queue.c" style="background-color:transparent;">Queue.c</h5> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1
#include"Queue.h"

//初始化
void csh(Queue* r)
{
	assert(r);
	r-&gt;to = r-&gt;wei = NULL;
	r-&gt;size = 0;
}

//入队尾
void dui_wei(Queue* r,data x)
{
	assert(r);
	//申请单链表空间
	queuedata* tab = (queuedata*)malloc(sizeof(queuedata));
	if (tab == NULL)
	{
		perror("malloc");
		exit(1);
	}
	//把x赋值给新申请空间的arr
	tab-&gt;arr = x;
	tab-&gt;p = NULL;

	//入队
	//判断队尾是不是空
	if (r-&gt;wei == NULL)
	{
		//是空，队头队尾指向新申请的空间
		r-&gt;to = r-&gt;wei = tab;
	}
	else//不是空
	{
		//队尾p指向新申请的空间
		r-&gt;wei-&gt;p = tab;
		//队尾走到新申请的空间
		r-&gt;wei = r-&gt;wei-&gt;p;
	}
	//有效个数加1
	r-&gt;size++;
}
//布尔类型
bool buer(Queue* r)
{
	assert(r);
	return r-&gt;to == NULL;
}

//出队,头
void dui_to(Queue* r)
{
	assert(r);
	//布尔类型，！把真变假，把假变真
	assert(!buer(r));
	//判断队头等于队尾，就说明只有一个节点
	if (r-&gt;to == r-&gt;wei)
	{
		//直接释放空间
		free(r-&gt;to);
		//把队头和队尾置为空
		r-&gt;to = r-&gt;wei = NULL;
	}
	else
	{
		//把队头的下一个节点给tab
		queuedata* tab = r-&gt;to-&gt;p;
		//释放当前队头节点
		free(r-&gt;to);
		//把tab节点给队头
		r-&gt;to = tab;
	}
	//有效个数减1
	--r-&gt;size;
}

//取队头数据
data qto(Queue* r)
{
	assert(r);
	assert(!buer(r));
	return r-&gt;to-&gt;arr;
}

//取尾
data qwei(Queue* r)
{
	assert(r);
	assert(!buer(r));
	return r-&gt;wei-&gt;arr;
}


//有效个数
data size(Queue* r)
{
	assert(r);
	return r-&gt;size;
}

//销毁
void xiaoh(Queue* r)
{
	assert(r);
	assert(!buer(r));
	//把队头给tab
	queuedata* tab = r-&gt;to;
	//循环销毁单链表
	while (tab != NULL)
	{
		//add保存头节点的下一个节点
		queuedata* add = tab-&gt;p;
		//释放头节点
		free(tab);
		//把add给tab
		tab = add;
	}
	//把队头和队尾置为空
	r-&gt;to = r-&gt;wei = NULL;
	//有效个数赋值为0
	r-&gt;size = 0;
}</code></pre> 
<h5 style="background-color:transparent;">test.c</h5> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1
#include"Queue.h"
void p()
{
	Queue add;
	//初始化
	csh(&amp;add);
	//入队，尾
	dui_wei(&amp;add, 1);
	dui_wei(&amp;add, 2);
	dui_wei(&amp;add, 3);
	dui_wei(&amp;add, 4);

	printf("头:%d\n", qto(&amp;add));


	printf("尾:%d\n", qwei(&amp;add));
	printf("size:%d\n", size(&amp;add));
	//销毁
	xiaoh(&amp;add);
}

int main()
{
	p();
	return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/31e059fd6ea2532057de7ab8ba6b52df/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【人工智能】全景解析：【机器学习】【深度学习】从基础理论到应用前景的【深度探索】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ddf472946266e6297eaea50e510fee3a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解析网络流量管理方案：简化基于云的DNS负载均衡</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>