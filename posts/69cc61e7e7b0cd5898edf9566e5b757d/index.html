<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringBoot导出Excel的四种方式 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/69cc61e7e7b0cd5898edf9566e5b757d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="SpringBoot导出Excel的四种方式">
  <meta property="og:description" content="方法一：hutools 该方法通过自研的一套Excel注解，在实体类上添加注解，然后用一套工具类(见源码中com.leixi.excel.util.excelOne)实现实体类列表的导出。优点是不用建模板，调用简单，缺点是迁移麻烦。有好几个配套的文件如注解，工具类等，想要在别的项目中使用，就涉及到文件的拷贝。老实说，不太优雅，而且更可惜的是，这些方法里居然没有封装导出方法。下面给出实体类创建，方法调用的代码，供各位参考（相关源码会在文中提供）
//引入依赖
&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.7.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.afterturn&lt;/groupId&gt; &lt;artifactId&gt;easypoi-base&lt;/artifactId&gt; &lt;version&gt;4.3.0&lt;/version&gt; &lt;/dependency&gt; //controller方法，不得不说，调用起来是真的方便 @PostMapping(value = &#34;/exportData&#34;) public ResponseEntity&lt;byte[]&gt; exportData(String fileName) { List&lt;ExcelOneDto&gt; list = CommonUtil.buildDemoExcel(ExcelOneDto.class); Workbook workbook = new DefaultWriteHandler&lt;ExcelOneDto&gt;().write(&#34;sheet名称&#34;,list, ExcelOneDto.class); return CommonUtil.exportWorkbook(workbook, fileName); } //实体类 @Data public class ExcelOneDto { @ExcelCell(priority = &#34;A&#34;, cellTitle = &#34;编号&#34;) private Integer code; @ExcelCell(priority = &#34;B&#34;, cellTitle = &#34;名称&#34;) private String name; @ExcelCell(priority = &#34;C&#34;, cellTitle = &#34;详情&#34;) private String desc; @ExcelCell(priority = &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-02-01T15:04:00+08:00">
    <meta property="article:modified_time" content="2024-02-01T15:04:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringBoot导出Excel的四种方式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2> 方法一：hutools</h2> 
<p><br>        该方法通过自研的一套Excel注解，在实体类上添加注解，然后用一套工具类(见源码中com.leixi.excel.util.excelOne)实现实体类列表的导出。优点是不用建模板，调用简单，缺点是迁移麻烦。有好几个配套的文件如注解，工具类等，想要在别的项目中使用，就涉及到文件的拷贝。老实说，不太优雅，而且更可惜的是，这些方法里居然没有封装导出方法。下面给出实体类创建，方法调用的代码，供各位参考（相关源码会在文中提供）</p> 
<p>//引入依赖</p> 
<pre><code>        &lt;dependency&gt;
            &lt;groupId&gt;cn.hutool&lt;/groupId&gt;
            &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;
            &lt;version&gt;5.7.12&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;cn.afterturn&lt;/groupId&gt;
            &lt;artifactId&gt;easypoi-base&lt;/artifactId&gt;
            &lt;version&gt;4.3.0&lt;/version&gt;
        &lt;/dependency&gt;</code></pre> 
<p><br>  </p> 
<pre><code>//controller方法，不得不说，调用起来是真的方便
    @PostMapping(value = "/exportData")
    public ResponseEntity&lt;byte[]&gt; exportData(String fileName) {
        List&lt;ExcelOneDto&gt; list = CommonUtil.buildDemoExcel(ExcelOneDto.class);
        Workbook workbook = new DefaultWriteHandler&lt;ExcelOneDto&gt;().write("sheet名称",list, ExcelOneDto.class);
        return CommonUtil.exportWorkbook(workbook, fileName);
    }
 
 //实体类
@Data
public class ExcelOneDto {
    @ExcelCell(priority = "A", cellTitle = "编号")
    private Integer code;
 
    @ExcelCell(priority = "B", cellTitle = "名称")
    private String name;
 
 
    @ExcelCell(priority = "C", cellTitle = "详情")
    private String desc;
 
    @ExcelCell(priority = "D", cellTitle = "备注")
    private String remark;
}</code></pre> 
<p><br> 这是导出的测试结果：</p> 
<p></p> 
<p><img alt="" height="148" src="https://images2.imgbox.com/90/a3/roM9FRFs_o.png" width="716"></p> 
<h2> 方法二：easyexcel</h2> 
<p>       现在使用频率较高的是用easyexcel实现的。经过一番了解，我将easyexcel的实现方式也列出来作为参考。该方法的优点是使用方便，功能强大！本文中我只实现了最简单的导入导出，easyexcel还支持很多如嵌套导入，合并行列等高级操作，相关实现可以参考大神的博客【精选】Spring Boot 集成 EasyExcel 3.x 优雅实现Excel导入导出_easyexcel3-CSDN博客。 以下是我学习了他的博客后，整理的最基本的代码：</p> 
<pre><code>//引入maven依赖
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;
            &lt;version&gt;3.1.3&lt;/version&gt;
        &lt;/dependency&gt;
 
//controller:
    @PostMapping(value = "/exportData")
    public void exportData(String fileName, HttpServletResponse response) {
        try {
            this.setExcelResponseProp(response, fileName);
            List&lt;ExcelFourDto&gt; list = CommonUtil.buildDemoExcel(ExcelFourDto.class);;
            EasyExcel.write(response.getOutputStream())
                    .head(ExcelFourDto.class)
                    .excelType(ExcelTypeEnum.XLSX)
                    .sheet(fileName)
                    .doWrite(list);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
 
    @PostMapping("/importData")
    @SneakyThrows
    public Object importUserExcel(@RequestPart("file") MultipartFile file) {
            List&lt;ExcelFourDto&gt; list = EasyExcel.read(file.getInputStream())
                    .head(ExcelFourDto.class).sheet().doReadSync();
            return list;
    }
    
    /**
     * 设置响应结果
     *
     * @param response    响应结果对象
     * @param rawFileName 文件名
     * @throws UnsupportedEncodingException 不支持编码异常
     */
    private void setExcelResponseProp(HttpServletResponse response, String rawFileName) throws UnsupportedEncodingException {
        response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
        response.setCharacterEncoding("utf-8");
        String fileName = URLEncoder.encode(rawFileName, "UTF-8").replaceAll("\\+", "%20");
        response.setHeader("Content-disposition", "attachment;filename*=utf-8''" + fileName + ".xlsx");
    } 
 
// 实体类
@Data
public class ExcelFourDto {
    @ExcelProperty("编号")
    @ColumnWidth(20)
    private Integer code;
 
    @ExcelProperty("名称")
    @ColumnWidth(20)
    private String name;
 
    @ExcelProperty("详情")
    @ColumnWidth(20)
    private String desc;
 
    @ExcelProperty("备注")
    @ColumnWidth(20)
    private String remark;
}</code></pre> 
<p>      以下是测试结果：</p> 
<p><img alt="" height="159" src="https://images2.imgbox.com/32/85/tO9fqIKy_o.png" width="732"></p> 
<h2></h2> 
<h2>方法三：ExcelImportUtil工具类</h2> 
<p>该方法的优点：不用excel模板，导出导出方便。缺点是封装的不够好。研发人员使用时需要对ExcelImportUtil进行一定的加工。下面是我封装后的代码：</p> 
<p>//maven依赖<br>        </p> 
<pre><code>&lt;dependency&gt;
            &lt;groupId&gt;cn.afterturn&lt;/groupId&gt;
            &lt;artifactId&gt;easypoi-base&lt;/artifactId&gt;
            &lt;version&gt;4.3.0&lt;/version&gt;
        &lt;/dependency&gt;</code></pre> 
<pre><code>//control类的导入导出
 
    @PostMapping(value = "/importData")
    public Object importManageData(@RequestPart("file") MultipartFile file) throws Exception {
        return CommonUtil.getExcelDataFromFile(file, ExcelTwoDto.class, 1,2);
    }
 
    @PostMapping(value = "/exportData")
    public ResponseEntity&lt;byte[]&gt; exportData(@RequestParam("fileName") String fileName){
        List&lt;ExcelTwoDto&gt; list  = CommonUtil.buildDemoExcel(ExcelTwoDto.class);
        List&lt;Map&lt;String, Object&gt;&gt; exportView = CommonUtil.buildExportView("测试Title", "测试Sheet",list);
        Workbook workbook = ExcelExportUtil.exportExcel(exportView, ExcelType.XSSF);
        ExcelStyleUtil.addNotExistCell(workbook, 0, 3);
        return CommonUtil.exportWorkbook(workbook, fileName);
    }
    
//实体类 
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ExcelTwoDto {
 
    @Excel(name = "第一列" ,fixedIndex = 0, orderNum = "0")
    private String codeOne;
    @Excel(name = "第二列" ,fixedIndex = 1, orderNum = "1", width = 50)
    private String codeTwo;
    @ExcelCollection(name = "第三列" , orderNum = "2")
    private List&lt;ExcelChildDto&gt; codeThree;
 
    @Excel(name = "第四列" ,fixedIndex = 4, orderNum = "4", width = 50)
    private String codeFour;
    @Excel(name = "第五列" ,fixedIndex = 5, orderNum = "5")
    private String codeFive;
    @Excel(name = "第六列A", groupName = "第六列汇总" ,fixedIndex = 6, orderNum = "6")
    private String codeThreeOne;
    @Excel(name = "第六列B", groupName = "第六列汇总" ,fixedIndex = 7, orderNum = "7")
    private String codeThreeTwo;
    @Excel(name = "第六列C", groupName = "第六列汇总" ,fixedIndex = 8, orderNum = "8")
    private String codeThreeThree;
}
 
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ExcelChildDto {
    @Excel(name = "编码" ,fixedIndex = 0, orderNum = "0")
    private String code;
    @Excel(name = "名称" ,fixedIndex = 1, orderNum = "1", width = 50)
    private String name;
}</code></pre> 
<p>   导出测试结果：</p> 
<p><img alt="" height="523" src="https://images2.imgbox.com/77/89/738anO7p_o.png" width="1200"><br>        </p> 
<h2>方法四：Excel模板导出</h2> 
<p>第三种方案是通过excel模板来实现的方法，现在基本已经废弃了，之所以放在这里是为了做一个参照，让大家看看不同的实现方法的区别。这种方式通过创建一个Excel模板和对应模板的实体类来实现文件导出，优点是实体类里不需要加注解了，而且在excel里可以设计一些style和格式，缺点是配置excelTemplate太麻烦了。配置繁琐，且过程中如出现参数名错误，符号错误等 ，调试起来很不方便，如果要增减字段，实体类和excel都得调整。下面给出编写的代码：</p> 
<pre><code>// controller方法
    @PostMapping(value = "/exportData")
    public ResponseEntity&lt;byte[]&gt; exportData(@RequestParam("fileName") String fileName) {
        TemplateExportParams params = new TemplateExportParams("templates/template.xlsx");
        params.setScanAllsheet(true);
        Map&lt;String, Object&gt; dataMap = new HashMap&lt;&gt;();
        List&lt;ExcelThreeDto&gt; list  = CommonUtil.buildDemoExcel(ExcelThreeDto.class);
        dataMap.put("titleName", "标题名称");
        dataMap.put("desc", "备注名称");
        dataMap.put("dataList", list);
        Workbook workbook = ExcelExportUtil.exportExcel(params, dataMap);
        ExcelStyleUtil.setAutoHeight(workbook, 0, 4);
        return CommonUtil.exportWorkbook(workbook, fileName);
    }
    
//实体类
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public class ExcelThreeDto {
        private Integer code;
        private String name;
        private String desc;
        private String remark;
    }</code></pre> 
<p>        Excel模板的配置</p> 
<p><img alt="" height="147" src="https://images2.imgbox.com/4f/95/KmF7s2qB_o.png" width="623"></p> 
<p>        导出的结果：</p> 
<p><img alt="" height="174" src="https://images2.imgbox.com/f5/7e/gxBkSgxH_o.png" width="572"></p> 
<p>        由于年代久远，我没能找到对应的模板导入的方法，于是在网上搜索了相关资料，编写了一个较通用的文件导入方法：</p> 
<pre><code>//maven依赖
        &lt;dependency&gt;
            &lt;groupId&gt;cn.afterturn&lt;/groupId&gt;
            &lt;artifactId&gt;easypoi-base&lt;/artifactId&gt;
            &lt;version&gt;4.3.0&lt;/version&gt;
        &lt;/dependency&gt;
 
    /**
     * excel 导入
     */
    @PostMapping("/importData")
    public Object upload(@RequestParam(name = "file") MultipartFile file) {
        return CommonUtil.importExcel(file, 3, ExcelThreeDto.class);
    }
 
    /**
     * 通用的excel导入的方法
     *
     * @param file 导入文件
     * @param startRow 第几行开始读数据
     * @param clazz 导入后转成的实体类
     * @return
     * @param &lt;T&gt; 
     */
    @SneakyThrows
    public static &lt;T&gt; List&lt;T&gt; importExcel(MultipartFile file, Integer startRow, Class&lt;T&gt; clazz) {
        Workbook wb = new XSSFWorkbook(file.getInputStream());
        //1.2.获取Sheet
        Sheet sheet = wb.getSheetAt(0);
        List&lt;T&gt; list = new ArrayList&lt;&gt;();
        Field[] fields = clazz.getDeclaredFields();
        for (int rowNum = startRow; rowNum &lt;= sheet.getLastRowNum(); rowNum++) {
            //根据索引获取每一个行
            Row row = sheet.getRow(rowNum);
            T obj = clazz.newInstance();
            for (int cellNum = 0; cellNum &lt; row.getLastCellNum() &amp;&amp; cellNum&lt; fields.length; cellNum++) {
                Cell cell = row.getCell(cellNum);
                Object value = CommonUtil.getCellValue(cell);
                Field field = fields[cellNum];
                field.setAccessible(true);
                // 注意，这里是为了演示，只分析了Integer和String的写法，实际上要根据Field数据的枚举分类处理
                if (field.getType().equals(Integer.class) &amp;&amp; value != null) {
                    field.set(obj, new Double(value.toString()).intValue());
                } else {
                    field.set(obj, value);
                }
            }
            list.add(obj);
        }
        return list;
    }</code></pre> 
<p>        导入的结果还是蛮令人满意的：</p> 
<p><img alt="" height="561" src="https://images2.imgbox.com/27/e4/1OhwgxFW_o.png" width="824"></p> 
<h2></h2> 
<p>        原以为方法一已经是别开生面了，但是对比起来，仍然是有些差强人意。时代真是进步的飞快，对于程序员来说，这种变迁显得尤为明显。它就像一根鞭子，不断的抽打着码农们，稍有懈怠就会被这洪流所淹没…</p> 
<p>        (文中附上四种方式的源码，仅用于学习和参考！)</p> 
<p>本人力荐前两种方法，有大量的项目使用，相关的博客也比较多，尤其是easyexcel，官方对每种导入导出的方式都有完整的案例参考，简单上手！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/094acfa9a818575628dd7dfbc60b9118/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java中字符串替换的4种方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1ada2a1bfdee8e8f9d4e54e708dd24ff/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">sql判断字符串是否存在</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>