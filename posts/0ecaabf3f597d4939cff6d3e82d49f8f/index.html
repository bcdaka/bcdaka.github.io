<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>A*(star)算法原理讲解以及程序实现(基于Python) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/0ecaabf3f597d4939cff6d3e82d49f8f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="A*(star)算法原理讲解以及程序实现(基于Python)">
  <meta property="og:description" content="A*搜索算法原理及其程序实现 去我的个人博客观看，观感更佳哦，😙😙
运行环境推荐 anaconda3，集成了常用的用于科学计算的包，以及对应的Python解释器(本例使用的解释器版本为3.9.12)编辑器：VScode 摘要 本文将以迷宫探索最优路径为例，讲解A *搜索算法原理及其程序实现。
在原理讲解部分，首先从为什么要使用A *搜索算法和A *搜索算法的全局最优逻辑出发，讲解A *算法的原理。其次对A *的行动函数g(n)和启发函数h(n)的细节进行了讲解说明，并补充了启发函数的选择对于A *算法的影响。
在程序实现部分，首先从程序流程框图出发，解释A *算法的流程。其次按函数的类划分并讲解主要代码，接着展示程序的运行结果，最后对A *算法进行总结分析。
原理讲解 为什么要使用A*搜索算法？ 搜索算法的核心是从起点出发，找到一条到达目标的最优（路径最短/成本最低/两者兼具）的路径。
根据不同需求，我们通常会选择：广度优先搜索（BFS）、Dijkstra算法（统一成本搜索）和贪婪优先搜索之一，下面我们逐个分析其优劣。
广度优先算法：不考虑每一步的移动成本，不断拓展边界，直到边界到达目标点，通常耗费大量时间。
Dijkstra算法：以BFS为基础，只考虑每一点的总移动成本，没有解决BFS耗费大量时间的问题。
贪婪优先搜索：只考虑到达终点的估计距离，能较快寻找到目标，但是无法保证路线全局最优。
A*搜索算法：以BSF为基础，综合考虑了总移动成本和到达终点的估计距离，巧妙地叠加了Dijkstra算法的成本最低和贪婪优先搜索的速度最优，具有更好的性能。
下面是A * 算法的核心公式：
f ( n ) = g ( n ) &#43; h ( n ) f(n)=g(n)&#43;h(n) f(n)=g(n)&#43;h(n)
说明：f(n)是总的预期成本，g(n)是当前点到起点的总移动成本，h(n)是当前点到目标点的预期代价 A *搜索算法的全局最优逻辑 首先，对于搜索算法来说，想要减少搜索的时间，那就必须要在搜索最优路径时搜索尽量少的点，最好搜索的全部节点恰好就是我们的全局最优路径。但显然，像贪婪优先搜索那样，只考虑当前点到目标点的预期距离的话，往往只能寻找到局部最优。
换句话说，贪婪优先算法只考虑单一的：当前点到目标点的估计距离，这显然不足以作为全局最优的参考指标。但是它赋予了程序有目的地前往终点方向的能力
而我们知道，BFS、Dijkstra实质上是对所有节点进行遍历，其中后者是对前者的优化，保证了起点到每一个中间点都是成本最优的选择。
那我们结合一下Dijkstra（保障当前点对起点是成本最优的）和贪婪优先搜索（保障当前点到终点的方向是最优的）
就可以构建一个新的参考指标：用于保证每一次从当前点选择下一个节点的时候都是全局最优的。
对行动函数 g(n) 的细节说明（可以简单理解g是小兵） 在A *算法中对于g(n)，也就是从起点到当前点的总移动代价（沉没成本），如果我们只考虑上下左右四个方向的话，并不需要额外考虑每一步行动的代价（因为每一步都是相同的），但是如果我们从上下左右和四个边角都能被行动，那我们就需要考虑走斜边和直上直下的代价差异。
本样例中，所有的节点都是正方形，从而可知走斜边与直上直下的代价比值应为
2 : 1 \sqrt2:1 2 ​:1
我们为了方便计算，取1.4：1作为走斜边和直上直下的代价比值
对启发函数 h(n) 的讲解（可以简单理解h是领导） 在A *算法中对于h(n)，也就是对当前点到目标点的预期代价估计通常采用“距离”作为度量。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-26T16:16:33+08:00">
    <meta property="article:modified_time" content="2024-07-26T16:16:33+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">A*(star)算法原理讲解以及程序实现(基于Python)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="A_0"></a>A*搜索算法原理及其程序实现</h2> 
<blockquote> 
 <p>去我的<a href="https://kashima19960.github.io/2024/07/16/%E7%AE%97%E6%B3%95/A%20Star%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/" rel="nofollow">个人博客</a>观看，观感更佳哦，😙😙</p> 
</blockquote> 
<h3><a id="_3"></a>运行环境推荐</h3> 
<ol><li>anaconda3，集成了常用的用于科学计算的包，以及对应的Python解释器(本例使用的解释器版本为3.9.12)</li><li>编辑器：VScode</li></ol> 
<h3><a id="_8"></a>摘要</h3> 
<p>本文将以迷宫探索最优路径为例，讲解A *搜索算法原理及其程序实现。</p> 
<p>在原理讲解部分，首先从为什么要使用A *搜索算法和A *搜索算法的全局最优逻辑出发，讲解A *算法的原理。其次对A *的行动函数g(n)和启发函数h(n)的细节进行了讲解说明，并补充了启发函数的选择对于A *算法的影响。</p> 
<p>在程序实现部分，首先从程序流程框图出发，解释A *算法的流程。其次按函数的类划分并讲解主要代码，接着展示程序的运行结果，最后对A *算法进行总结分析。</p> 
<h3><a id="_16"></a>原理讲解</h3> 
<h4><a id="A_18"></a>为什么要使用A*搜索算法？</h4> 
<p>搜索算法的核心是从起点出发，找到一条到达目标的最优（路径最短/成本最低/两者兼具）的路径。</p> 
<p>根据不同需求，我们通常会选择：广度优先搜索（BFS）、Dijkstra算法（统一成本搜索）和贪婪优先搜索之一，下面我们逐个分析其优劣。</p> 
<ol><li> <p>广度优先算法：不考虑每一步的移动成本，不断拓展边界，直到边界到达目标点，通常耗费大量时间。</p> </li><li> <p>Dijkstra算法：以BFS为基础，<strong>只考虑每一点的总移动成本</strong>，没有解决BFS耗费大量时间的问题。</p> </li><li> <p>贪婪优先搜索：<strong>只考虑到达终点的估计距离</strong>，能较快寻找到目标，但是无法保证路线全局最优。</p> </li><li> <p>A*搜索算法：以BSF为基础，<strong>综合考虑了总移动成本和到达终点的估计距离</strong>，巧妙地叠加了Dijkstra算法的成本最低和贪婪优先搜索的速度最优，具有更好的性能。</p> </li><li> <p>下面是A * 算法的核心公式：<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            f 
           
          
            ( 
           
          
            n 
           
          
            ) 
           
          
            = 
           
          
            g 
           
          
            ( 
           
          
            n 
           
          
            ) 
           
          
            + 
           
          
            h 
           
          
            ( 
           
          
            n 
           
          
            ) 
           
          
         
           f(n)=g(n)+h(n) 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></span></p> </li></ol> 
<blockquote> 
 <h6><a id="fngnhn_38"></a>说明：f(n)是总的预期成本，g(n)是当前点到起点的总移动成本，h(n)是当前点到目标点的预期代价</h6> 
</blockquote> 
<h4><a id="A__42"></a>A *搜索算法的全局最优逻辑</h4> 
<p>首先，对于搜索算法来说，想要减少搜索的时间，那就必须要在搜索最优路径时搜索尽量少的点，最好搜索的全部节点恰好就是我们的全局最优路径。但显然，像贪婪优先搜索那样，只考虑当前点到目标点的预期距离的话，往往只能寻找到局部最优。</p> 
<p><img src="https://images2.imgbox.com/bb/d6/EeE4GDWX_o.png" alt="在这里插入图片描述"></p> 
<p><strong>换句话说，贪婪优先算法只考虑单一的：当前点到目标点的估计距离，这显然不足以作为全局最优的参考指标。但是它赋予了程序有目的地前往终点方向的能力</strong></p> 
<p>而我们知道，BFS、Dijkstra实质上是对所有节点进行遍历，其中后者是对前者的优化，保证了起点到每一个中间点都是成本最优的选择。</p> 
<p><img src="https://images2.imgbox.com/6b/d6/lsqO0DFC_o.png" alt="在这里插入图片描述"></p> 
<p>那我们结合一下Dijkstra（保障当前点对起点是<strong>成本</strong>最优的）和贪婪优先搜索（保障当前点到终点的<strong>方向</strong>是最优的）</p> 
<p>就可以构建一个新的参考指标：用于保证每一次从当前点选择下一个节点的时候都是全局最优的。</p> 
<p><img src="https://images2.imgbox.com/1e/6c/MsVNeXEm_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="__gn___g_69"></a>对行动函数 <strong>g(n)</strong> 的细节说明（<strong>可以简单理解g是小兵</strong>）</h4> 
<p>在A *算法中对于g(n)，也就是从起点到当前点的总移动代价（沉没成本），如果我们只考虑上下左右四个方向的话，并不需要额外考虑每一步行动的代价（因为每一步都是相同的），但是如果我们从上下左右和四个边角都能被行动，那我们就需要考虑走斜边和直上直下的代价差异。</p> 
<p>本样例中，所有的节点都是正方形，从而可知走斜边与直上直下的代价比值应为<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           2 
          
         
        
          : 
         
        
          1 
         
        
       
         \sqrt2:1 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.04em; vertical-align: -0.0839em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.9561em;"><span class="svg-align" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord" style="padding-left: 0.833em;">2</span></span><span class="" style="top: -2.9161em;"><span class="pstrut" style="height: 3em;"></span><span class="hide-tail" style="min-width: 0.853em; height: 1.08em;"> 
            <svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"> 
             <path d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"></path> 
            </svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.0839em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span></span><br> 我们为了方便计算，取1.4：1作为走斜边和直上直下的代价比值</p> 
<h4><a id="__hn___h_81"></a>对启发函数 <strong>h(n)</strong> 的讲解（<strong>可以简单理解h是领导</strong>）</h4> 
<p>在A *算法中对于h(n)，也就是对当前点到目标点的预期代价估计通常采用“距离”作为度量。</p> 
<p>在二维地图中，我们讨论两点间距离常用的方式有两种。</p> 
<ol><li> <p>曼哈顿距离</p> <p><img src="https://images2.imgbox.com/0e/48/jpl5nMeM_o.png" alt="在这里插入图片描述"></p> <p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            c 
           
          
            = 
           
          
            ∣ 
           
           
           
             x 
            
           
             2 
            
           
          
            − 
           
           
           
             x 
            
           
             1 
            
           
          
            ∣ 
           
          
            + 
           
          
            ∣ 
           
           
           
             y 
            
           
             2 
            
           
          
            − 
           
           
           
             y 
            
           
             1 
            
           
          
            ∣ 
           
          
         
           c=|x_{2}-x_{1}|+|y_{2}-y_{1}| 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord">∣</span></span></span></span></span></span><br> 曼哈顿距离用来标明两个点在标准坐标系上的绝对轴距总和，简单来理解就是：直角三角形的两直角边之和</p> </li><li> <p>欧式距离</p> <p><img src="https://images2.imgbox.com/65/7a/Lrh8X1Ak_o.png" alt="在这里插入图片描述"></p> <p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            d 
           
          
            = 
           
           
            
            
              （ 
             
             
             
               x 
              
             
               2 
              
             
            
              − 
             
             
             
               x 
              
             
               1 
              
             
             
             
               ） 
              
             
               2 
              
             
            
              + 
             
            
              （ 
             
             
             
               y 
              
             
               2 
              
             
            
              − 
             
             
             
               y 
              
             
               1 
              
             
             
             
               ） 
              
             
               2 
              
             
            
           
          
         
           d= \sqrt{<!-- -->{（x_{2}-x_{1}）^{2}+（y_{2}-y_{1}）^{2}}} 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.24em; vertical-align: -0.2333em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.0067em;"><span class="svg-align" style="top: -3.2em;"><span class="pstrut" style="height: 3.2em;"></span><span class="mord" style="padding-left: 1em;"><span class="mord"><span class="mord cjk_fallback">（</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mord cjk_fallback">）</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.7401em;"><span class="" style="top: -2.989em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord cjk_fallback">（</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mord cjk_fallback">）</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.7401em;"><span class="" style="top: -2.989em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="" style="top: -2.9667em;"><span class="pstrut" style="height: 3.2em;"></span><span class="hide-tail" style="min-width: 1.02em; height: 1.28em;"> 
              <svg width="400em" height="1.28em" viewbox="0 0 400000 1296" preserveaspectratio="xMinYMin slice"> 
               <path d="M263,681c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l0 -0
c4.7,-7.3,11,-11,19,-11
H40000v40H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M1001 80h400000v40h-400000z"></path> 
              </svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2333em;"><span class=""></span></span></span></span></span></span></span></span></span></span><br> 欧式距离用来标明两个点在标准坐标系上的绝对距离，简单来理解就是：直角三角形的斜边</p> </li></ol> 
<p>在接下来的代码实现中，因为曼哈顿距离不需要开方，计算较为简便，因此本例选用曼哈顿距离作为启发函数的参考指标。</p> 
<h4><a id="_120"></a>补充：启发函数的选择对算法的影响（了解）</h4> 
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          f 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          = 
         
        
          g 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
          + 
         
        
          h 
         
        
          ( 
         
        
          n 
         
        
          ) 
         
        
       
         f(n)=g(n)+h(n) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></span></p> 
<table><thead><tr><th>情况</th><th>算法</th><th>结果</th></tr></thead><tbody><tr><td>h(n)=0</td><td>A*退化为Dijkstra算法</td><td>保证能找到最短路径，但时间花费较大</td></tr><tr><td>h(n)=实际代价</td><td>仅拓展必要节点</td><td>时间和路径都最佳</td></tr><tr><td>h(n)&gt;&gt;g(n)</td><td>A*算法退化到贪婪优先</td><td>不保证全局路径最优，但速度很快</td></tr></tbody></table> 
<h3><a id="_134"></a>程序流程图</h3> 
<p><img src="https://images2.imgbox.com/ed/a5/jq11uOVk_o.png" alt="在这里插入图片描述"></p> 
<ul><li>地图初始化：设置地图大小、起点终点、障碍物。</li><li>遍历待测节点：将起点放入待测列表（open_list）中，进而让A *算法开始运行，计算并存储列表中每一个节点的 "f(n) " 。</li><li>定位正在检测点：查找"f(n) "最小的节点，并把它定位为正在检测的点（select_current）。</li><li>邻点检测：A *算法的核心，通过对邻点属性的判断和对预期总移动成本的权衡来选择下一个节点</li><li>移动到已测点集：将已经检测过但是没被选择的节点放入已测列表中，保证不会重复搜索</li><li>找到终点：找到终点后，由终点向起点进行最短路径的回溯，并通过调用pillow库，将结果导出为图片</li></ul> 
<h3><a id="AStar_145"></a>AStar类</h3> 
<p>是整个算法的关键，内部包括了A *算法的初始化、最优点选择、邻点检测、节点判断和路径寻找功能的实现</p> 
<h4><a id="_149"></a>初始化参数</h4> 
<p>通过构造函数，将地图属性：地图大小、起点、终点和障碍物读入，初始化 A *算法的参数：</p> 
<pre><code class="prism language-python">    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> start<span class="token punctuation">:</span> Point<span class="token punctuation">,</span> end<span class="token punctuation">:</span> Point<span class="token punctuation">,</span> map2d<span class="token punctuation">:</span> Map2D<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>			
        self<span class="token punctuation">.</span>closed_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>open_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>start <span class="token operator">=</span> start
        self<span class="token punctuation">.</span>end <span class="token operator">=</span> end
        self<span class="token punctuation">.</span>map2d <span class="token operator">=</span> map2d
</code></pre> 
<h4><a id="_165"></a>最优点选择</h4> 
<p>遍历待检测队列（open_list），找到f值最小的节点（全局最优节点），然后返回全局最优节点</p> 
<pre><code class="prism language-python">    <span class="token keyword">def</span> <span class="token function">select_current</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        min_f <span class="token operator">=</span> sys<span class="token punctuation">.</span>maxsize
        node_temp <span class="token operator">=</span> <span class="token boolean">None</span>
        <span class="token keyword">for</span> node <span class="token keyword">in</span> self<span class="token punctuation">.</span>open_list<span class="token punctuation">:</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>f <span class="token operator">&lt;</span> min_f<span class="token punctuation">:</span>
                min_f <span class="token operator">=</span> node<span class="token punctuation">.</span>f
                node_temp <span class="token operator">=</span> node
        <span class="token keyword">return</span> node_temp
</code></pre> 
<h4><a id="_182"></a>判断节点是否在待检测队列中</h4> 
<p>通过读入要判断的节点（node），遍历open_list，判断node是否在待测队列中</p> 
<pre><code class="prism language-python">    <span class="token keyword">def</span> <span class="token function">is_in_open_list</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token builtin">any</span><span class="token punctuation">(</span><span class="token punctuation">[</span>open_node<span class="token punctuation">.</span>point <span class="token operator">==</span> node<span class="token punctuation">.</span>point <span class="token keyword">for</span> open_node <span class="token keyword">in</span> self<span class="token punctuation">.</span>open_list<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> 
<h4><a id="_193"></a>判断节点是否在已检测队列中</h4> 
<p>通过读入要判断的节点（node），遍历closed_list，判断node是否在已检测队列中</p> 
<pre><code class="prism language-python">    <span class="token keyword">def</span> <span class="token function">is_in_closed_list</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token builtin">any</span><span class="token punctuation">(</span><span class="token punctuation">[</span>closed_node<span class="token punctuation">.</span>point <span class="token operator">==</span> node<span class="token punctuation">.</span>point <span class="token keyword">for</span> closed_node <span class="token keyword">in</span> self<span class="token punctuation">.</span>closed_list<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> 
<h4><a id="_204"></a>判断节点是否是障碍物</h4> 
<p>通过读入要判断的节点（node），简单比较节点是否为"⬛"，进而判断node是否是障碍物</p> 
<pre><code class="prism language-python">    <span class="token keyword">def</span> <span class="token function">is_obstacle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>map2d<span class="token punctuation">.</span>data<span class="token punctuation">[</span>node<span class="token punctuation">.</span>point<span class="token punctuation">.</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>point<span class="token punctuation">.</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"⬛"</span>
</code></pre> 
<h4><a id="_215"></a>相邻点检测</h4> 
<p>通过对当前节点（node）的"上下左右"和"四角"的八个方向进行检测，寻找全局最优的点，判断下一步该前往哪个节点，其中包括对邻点是否为终点、已检测点、待检测点、最优节点或障碍物的一系列判断</p> 
<pre><code class="prism language-python">    <span class="token keyword">def</span> <span class="token function">explore_neighbors</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 定义八个方向</span>
        directions <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> direction <span class="token keyword">in</span> directions<span class="token punctuation">:</span>
            ud<span class="token punctuation">,</span> rl <span class="token operator">=</span> direction
            <span class="token comment"># 根据方向计算相邻节点</span>
            neighbor <span class="token operator">=</span> node<span class="token punctuation">.</span>get_near<span class="token punctuation">(</span>ud<span class="token punctuation">,</span> rl<span class="token punctuation">)</span>
            <span class="token comment"># 如果相邻节点是终点，则返回 True</span>
            <span class="token keyword">if</span> neighbor<span class="token punctuation">.</span>point <span class="token operator">==</span> self<span class="token punctuation">.</span>end<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token comment"># 如果相邻节点在 closed_list 中或为障碍物，则跳过</span>
            <span class="token keyword">if</span> self<span class="token punctuation">.</span>is_in_closed_list<span class="token punctuation">(</span>neighbor<span class="token punctuation">)</span> <span class="token keyword">or</span> self<span class="token punctuation">.</span>is_obstacle<span class="token punctuation">(</span>neighbor<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">continue</span>
            <span class="token comment"># 如果相邻节点在 open_list 中，则比较评分</span>
            <span class="token keyword">if</span> self<span class="token punctuation">.</span>is_in_open_list<span class="token punctuation">(</span>neighbor<span class="token punctuation">)</span><span class="token punctuation">:</span>
                existing_node <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">(</span>open_node <span class="token keyword">for</span> open_node <span class="token keyword">in</span> self<span class="token punctuation">.</span>open_list <span class="token keyword">if</span> open_node<span class="token punctuation">.</span>point <span class="token operator">==</span> neighbor<span class="token punctuation">.</span>point<span class="token punctuation">)</span>
                <span class="token keyword">if</span> neighbor<span class="token punctuation">.</span>f <span class="token operator">&lt;</span> existing_node<span class="token punctuation">.</span>f<span class="token punctuation">:</span>
                    <span class="token comment"># 如果评分更优，则更新相邻节点的父节点和评分</span>
                    existing_node<span class="token punctuation">.</span>father <span class="token operator">=</span> node
                    existing_node<span class="token punctuation">.</span>g <span class="token operator">=</span> neighbor<span class="token punctuation">.</span>g
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token comment"># 如果相邻节点不在 open_list 中，则将其加入 open_list</span>
                neighbor<span class="token punctuation">.</span>father <span class="token operator">=</span> node
                self<span class="token punctuation">.</span>open_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>neighbor<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span>
</code></pre> 
<h4><a id="_249"></a>寻找路径</h4> 
<p>这个方法将起点另外存储在回溯路径列表里（path），并不断选择最优节点前进，同时每一次前进到下一个最优节点时，都会将最优节点的父节点放进回溯路径（path）中，在最后找到终点后，利用回溯路径列表从终点回溯到起点（子节点按父节点回溯）</p> 
<pre><code class="prism language-python">    <span class="token keyword">def</span> <span class="token function">find_path</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 创建起点节点</span>
        start_node <span class="token operator">=</span> AStar<span class="token punctuation">.</span>Node<span class="token punctuation">(</span>self<span class="token punctuation">.</span>start<span class="token punctuation">,</span> self<span class="token punctuation">.</span>end<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>open_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>start_node<span class="token punctuation">)</span>

        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
            <span class="token comment"># 选择当前最优节点</span>
            current_node <span class="token operator">=</span> self<span class="token punctuation">.</span>select_current<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token comment"># 如果没有最优节点，则返回 None</span>
            <span class="token keyword">if</span> current_node <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">None</span>
            <span class="token comment"># 将当前节点从 open_list 中移除，并加入 closed_list 中</span>
            self<span class="token punctuation">.</span>open_list<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>current_node<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>closed_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>current_node<span class="token punctuation">)</span>

            <span class="token comment"># 如果当前节点是终点，则返回路径</span>
            <span class="token keyword">if</span> current_node<span class="token punctuation">.</span>point <span class="token operator">==</span> self<span class="token punctuation">.</span>end<span class="token punctuation">:</span>
                <span class="token comment"># 沿着父节点回溯路径</span>
                <span class="token keyword">while</span> current_node<span class="token punctuation">.</span>father <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                    self<span class="token punctuation">.</span>path<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> current_node<span class="token punctuation">.</span>point<span class="token punctuation">)</span>
                    current_node <span class="token operator">=</span> current_node<span class="token punctuation">.</span>father
                <span class="token keyword">return</span> self<span class="token punctuation">.</span>path

            <span class="token comment"># 探索相邻节点</span>
            <span class="token keyword">if</span> self<span class="token punctuation">.</span>explore_neighbors<span class="token punctuation">(</span>current_node<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token comment"># 如果找到了终点，则沿着父节点回溯路径</span>
                <span class="token keyword">while</span> current_node<span class="token punctuation">.</span>father <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                    self<span class="token punctuation">.</span>path<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> current_node<span class="token punctuation">.</span>point<span class="token punctuation">)</span>
                    current_node <span class="token operator">=</span> current_node<span class="token punctuation">.</span>father
                <span class="token keyword">return</span> self<span class="token punctuation">.</span>path
</code></pre> 
<h3><a id="AStarNode_288"></a>AStar.Node类</h3> 
<p>是AStar类的一个内部类，包含的初始化中间节点参数和获取相邻节点的方法是邻点检测和寻找路径的基础</p> 
<h4><a id="_292"></a>初始化中间节点的参数</h4> 
<p>构造函数，初始化节点的参数：point:（当前节点的坐标）、endpoint（终点的坐标）、g（从起点到当前节点的代价），并且通过曼哈顿距离计算这条路径预计的总移动成本，是最优点选择的基础</p> 
<pre><code class="prism language-python">        <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> point<span class="token punctuation">:</span> Point<span class="token punctuation">,</span> endpoint<span class="token punctuation">:</span> Point<span class="token punctuation">,</span> g<span class="token punctuation">:</span> <span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>point <span class="token operator">=</span> point
            self<span class="token punctuation">.</span>endpoint <span class="token operator">=</span> endpoint
            self<span class="token punctuation">.</span>father <span class="token operator">=</span> <span class="token boolean">None</span>
            self<span class="token punctuation">.</span>g <span class="token operator">=</span> g
            <span class="token comment"># 计算启发值h，使用曼哈顿距离</span>
            self<span class="token punctuation">.</span>h <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">abs</span><span class="token punctuation">(</span>endpoint<span class="token punctuation">.</span>x <span class="token operator">-</span> point<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>endpoint<span class="token punctuation">.</span>y <span class="token operator">-</span> point<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10</span>
            <span class="token comment"># 计算预计的总移动成本f</span>
            self<span class="token punctuation">.</span>f <span class="token operator">=</span> self<span class="token punctuation">.</span>g <span class="token operator">+</span> self<span class="token punctuation">.</span>h
</code></pre> 
<h4><a id="_308"></a>获取相邻节点</h4> 
<p>获取上下左右和四角共八个方向的邻点，计算并更新A *算法的g(n)值，是邻点检测的基础</p> 
<p>ud: 上下方向的移动量（1 表示向上，-1 表示向下，0 表示不移动）</p> 
<p>rl: 左右方向的移动量（1 表示向右，-1 表示向左，0 表示不移动）</p> 
<pre><code class="prism language-python">        <span class="token keyword">def</span> <span class="token function">get_near</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ud<span class="token punctuation">,</span> rl<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 根据上下左右和四角，共八个方向，计算相邻节点的坐标</span>
            near_point <span class="token operator">=</span> Point<span class="token punctuation">(</span>self<span class="token punctuation">.</span>point<span class="token punctuation">.</span>x <span class="token operator">+</span> rl<span class="token punctuation">,</span> self<span class="token punctuation">.</span>point<span class="token punctuation">.</span>y <span class="token operator">+</span> ud<span class="token punctuation">)</span>
            <span class="token comment"># 计算相邻节点的总移动成本</span>
            near_node <span class="token operator">=</span> AStar<span class="token punctuation">.</span>Node<span class="token punctuation">(</span>near_point<span class="token punctuation">,</span> self<span class="token punctuation">.</span>endpoint<span class="token punctuation">,</span> self<span class="token punctuation">.</span>g <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token keyword">if</span> ud <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">or</span> rl <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">else</span> <span class="token number">14</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> near_node
</code></pre> 
<h3><a id="Map2D__327"></a>Map2D 类</h3> 
<p>主要是对生成的2D地图进行处理，包括地图初始化和导出地图数据的功能</p> 
<h4><a id="_331"></a>初始化地图</h4> 
<p>构造函数，通过读取用户设定的地图大小，初始化地图数据，每个元素都放置一个"⬜"字符</p> 
<pre><code class="prism language-python">    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> height<span class="token punctuation">,</span> width<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>height <span class="token operator">=</span> height
        self<span class="token punctuation">.</span>width <span class="token operator">=</span> width
        self<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"⬜"</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>width<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre> 
<h4><a id="_344"></a>导出地图数据</h4> 
<p>调用pillow模块，在A *算法所在的 py 文件夹内生成一个 result.png 的图片，首先将其绘制为全白色背景，再依次遍历A *算法处理后的地图数据，并在白色背景上绘制颜色，最后展示一个A *算法处理后的结果图（包含最优路径）</p> 
<pre><code class="prism language-python">    <span class="token keyword">def</span> <span class="token function">export_image</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> file_name<span class="token operator">=</span><span class="token string">"map.png"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 设置单元格大小</span>
        cell_size <span class="token operator">=</span> <span class="token number">10</span>
        <span class="token comment"># 创建一个白色背景的图像</span>
        image <span class="token operator">=</span> Image<span class="token punctuation">.</span>new<span class="token punctuation">(</span><span class="token string">"RGB"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>width <span class="token operator">*</span> cell_size<span class="token punctuation">,</span> self<span class="token punctuation">.</span>height <span class="token operator">*</span> cell_size<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"white"</span><span class="token punctuation">)</span>
        <span class="token comment"># 创建一个绘图对象</span>
        draw <span class="token operator">=</span> ImageDraw<span class="token punctuation">.</span>Draw<span class="token punctuation">(</span>image<span class="token punctuation">)</span>

        <span class="token comment"># 遍历地图数据，根据不同的字符绘制不同的颜色</span>
        <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>height<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> y <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>width<span class="token punctuation">)</span><span class="token punctuation">:</span>
                color <span class="token operator">=</span> <span class="token string">"white"</span>
                <span class="token keyword">if</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"⬛"</span><span class="token punctuation">:</span>
                    color <span class="token operator">=</span> <span class="token string">"black"</span>
                <span class="token keyword">elif</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"🟥"</span><span class="token punctuation">:</span>
                    color <span class="token operator">=</span> <span class="token string">"red"</span>
                <span class="token keyword">elif</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"🟩"</span><span class="token punctuation">:</span>
                    color <span class="token operator">=</span> <span class="token string">"green"</span>
                <span class="token comment"># 绘制一个矩形</span>
                draw<span class="token punctuation">.</span>rectangle<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span>y <span class="token operator">*</span> cell_size<span class="token punctuation">,</span> x <span class="token operator">*</span> cell_size<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> cell_size<span class="token punctuation">,</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> cell_size<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> fill<span class="token operator">=</span>color<span class="token punctuation">)</span>

        <span class="token comment"># 保存图像</span>
        image<span class="token punctuation">.</span>save<span class="token punctuation">(</span>file_name<span class="token punctuation">)</span>
</code></pre> 
<h4><a id="_376"></a>设置障碍物</h4> 
<p>通过用户设置的障碍点坐标，将"⬜"（可探索位置）更新为"⬛"（障碍物）</p> 
<pre><code class="prism language-python">    <span class="token keyword">def</span> <span class="token function">set_obstacle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"⬛"</span>
</code></pre> 
<h4><a id="_387"></a>设置起点和终点</h4> 
<p>通过用户设置的起点和终点坐标，将"⬜"（可探索位置）更新为"🟥"（起点或者终点）</p> 
<pre><code class="prism language-python">    <span class="token keyword">def</span> <span class="token function">set_start_end</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> start<span class="token punctuation">:</span> Point<span class="token punctuation">,</span> end<span class="token punctuation">:</span> Point<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>start<span class="token punctuation">.</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>start<span class="token punctuation">.</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"🟥"</span>
        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>end<span class="token punctuation">.</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>end<span class="token punctuation">.</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"🟥"</span>
</code></pre> 
<h3><a id="_399"></a>其他函数</h3> 
<h4><a id="_401"></a>随机放置障碍物</h4> 
<p>首先计算地图总格数，通过 obstacle_ratio 设置障碍物占全图的比例，再通过循环来实现大范围的障碍物放置，同时设置了对起点终点和现有障碍物的保护，达到增加搜索难度的目的</p> 
<pre><code class="prism language-python">total_cells <span class="token operator">=</span> map2d<span class="token punctuation">.</span>height <span class="token operator">*</span> map2d<span class="token punctuation">.</span>width  <span class="token comment"># 计算地图总格数</span>
obstacle_cells <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>total_cells <span class="token operator">*</span> <span class="token number">0.3</span><span class="token punctuation">)</span>  <span class="token comment"># 计算障碍物格数，这里设置障碍物占据地图的 30%</span>

<span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>obstacle_cells<span class="token punctuation">)</span><span class="token punctuation">:</span>
    x <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> map2d<span class="token punctuation">.</span>height <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
    y <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> map2d<span class="token punctuation">.</span>width <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token comment"># 确保障碍物不覆盖起点、终点或其他障碍物</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> start_point<span class="token punctuation">.</span>x <span class="token keyword">and</span> y <span class="token operator">==</span> start_point<span class="token punctuation">.</span>y<span class="token punctuation">)</span> <span class="token keyword">or</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> end_point<span class="token punctuation">.</span>x <span class="token keyword">and</span> y <span class="token operator">==</span> end_point<span class="token punctuation">.</span>y<span class="token punctuation">)</span> <span class="token keyword">or</span> map2d<span class="token punctuation">.</span>data<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"⬛"</span><span class="token punctuation">:</span>
        x <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> map2d<span class="token punctuation">.</span>height <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
        y <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> map2d<span class="token punctuation">.</span>width <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>

    <span class="token comment"># 设置障碍物</span>
    map2d<span class="token punctuation">.</span>set_obstacle<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span>

</code></pre> 
<h3><a id="_424"></a>运行结果展示</h3> 
<p><img src="https://images2.imgbox.com/17/cf/YNPWFhxQ_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/c3/f3/0mL0lXyA_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="100_x_100_430"></a>在100 x 100地图下运行</h4> 
<p><img src="https://images2.imgbox.com/df/2c/XRKR2wqs_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/7d/4d/4EJIh7hU_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="150_x_150_437"></a>在150 x 150地图下运行</h4> 
<p><img src="https://images2.imgbox.com/d8/2b/Ik4wdm2w_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/27/f3/urHvHOLP_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="200_x_200_443"></a>在200 x 200地图下运行</h4> 
<p><img src="https://images2.imgbox.com/bb/e0/HifJKzbc_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/b5/f0/kbVqssJr_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_449"></a>总结与分析</h3> 
<p>总体而言，A *算法在随机生成障碍物的情况下，由于其使用了启发函数，尽可能地减少了过程中不必要的搜索，所以无论是在50 x 50,100 x 100,150 x 150还是200 x 200的测试样例中均能在0.05s左右找到正确的最优路径，展现了A *算法的优越性。</p> 
<h3><a id="_453"></a>结语</h3> 
<p>有任何的问题，可以在评论区中提出，虽然我一般没办法及时回复，但有空肯定会来看看的</p> 
<h3><a id="_457"></a>全部代码</h3> 
<p>有人说需要全部的代码，可能是觉得把文章中的代码片段一个个复制出来很麻烦，所以我在这里就直接附加全部的代码，只要安装好相应的库就能直接运行</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> sys
<span class="token keyword">import</span> time
<span class="token keyword">from</span> typing <span class="token keyword">import</span> List
<span class="token keyword">import</span> random
<span class="token keyword">from</span> PIL <span class="token keyword">import</span> Image<span class="token punctuation">,</span> ImageDraw

<span class="token triple-quoted-string string">"""
Point类是数学坐标系的一个抽象的点,和Node类不是一回事
"""</span>
<span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token boolean">None</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>x <span class="token operator">=</span> x
        self<span class="token punctuation">.</span>y <span class="token operator">=</span> y

    <span class="token comment">#重载“==”运算符，(x1,y1)==(x2,y2)，当且仅当x1=x2，y1=y2</span>
    <span class="token keyword">def</span> <span class="token function">__eq__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token builtin">bool</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>x <span class="token operator">==</span> other<span class="token punctuation">.</span>x <span class="token keyword">and</span> self<span class="token punctuation">.</span>y <span class="token operator">==</span> other<span class="token punctuation">.</span>y

<span class="token keyword">class</span> <span class="token class-name">Map2D</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> height<span class="token punctuation">,</span> width<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token boolean">None</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>height <span class="token operator">=</span> height
        self<span class="token punctuation">.</span>width <span class="token operator">=</span> width
        <span class="token comment">#width可以看成二维地图的行，height可以看成二维地图的列</span>
        self<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"⬜"</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>width<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token punctuation">]</span>

    <span class="token comment">#将地图数据用文本导出</span>
    <span class="token keyword">def</span> <span class="token function">show</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> file_name<span class="token operator">=</span><span class="token string">"output.txt"</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token boolean">None</span><span class="token punctuation">:</span>
        <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>file_name<span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token builtin">file</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> row <span class="token keyword">in</span> self<span class="token punctuation">.</span>data<span class="token punctuation">:</span>
              <span class="token builtin">file</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>row<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'\n'</span><span class="token punctuation">)</span>

    <span class="token comment">#将地图数据用图片导出</span>
    <span class="token keyword">def</span> <span class="token function">export_image</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> file_name<span class="token operator">=</span><span class="token string">"map.png"</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token boolean">None</span><span class="token punctuation">:</span>
        cell_size <span class="token operator">=</span> <span class="token number">10</span>
        image <span class="token operator">=</span> Image<span class="token punctuation">.</span>new<span class="token punctuation">(</span><span class="token string">"RGB"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>width <span class="token operator">*</span> cell_size<span class="token punctuation">,</span> self<span class="token punctuation">.</span>height <span class="token operator">*</span> cell_size<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"white"</span><span class="token punctuation">)</span>
        draw <span class="token operator">=</span> ImageDraw<span class="token punctuation">.</span>Draw<span class="token punctuation">(</span>image<span class="token punctuation">)</span>
        <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>height<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> y <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>width<span class="token punctuation">)</span><span class="token punctuation">:</span>
                color <span class="token operator">=</span> <span class="token string">"white"</span>
                <span class="token keyword">if</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"⬛"</span><span class="token punctuation">:</span>
                    color <span class="token operator">=</span> <span class="token string">"black"</span>
                <span class="token keyword">elif</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"🟥"</span><span class="token punctuation">:</span>
                    color <span class="token operator">=</span> <span class="token string">"red"</span>
                <span class="token keyword">elif</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"🟩"</span><span class="token punctuation">:</span>
                    color <span class="token operator">=</span> <span class="token string">"green"</span>
                draw<span class="token punctuation">.</span>rectangle<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span>y <span class="token operator">*</span> cell_size<span class="token punctuation">,</span> x <span class="token operator">*</span> cell_size<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> cell_size<span class="token punctuation">,</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> cell_size<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> fill<span class="token operator">=</span>color<span class="token punctuation">)</span>
        image<span class="token punctuation">.</span>save<span class="token punctuation">(</span>file_name<span class="token punctuation">)</span>

    <span class="token comment">#当地图点为⬛，则为障碍物</span>
    <span class="token keyword">def</span> <span class="token function">set_obstacle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"⬛"</span>

    <span class="token comment">#设置起点和终点</span>
    <span class="token keyword">def</span> <span class="token function">set_start_end</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> start<span class="token punctuation">:</span> Point<span class="token punctuation">,</span> end<span class="token punctuation">:</span> Point<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token boolean">None</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>start<span class="token punctuation">.</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>start<span class="token punctuation">.</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"🟥"</span>
        self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>end<span class="token punctuation">.</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>end<span class="token punctuation">.</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"🟥"</span>
    <span class="token keyword">def</span> <span class="token function">obstacle_generate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ratio<span class="token punctuation">:</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token boolean">None</span><span class="token punctuation">:</span>
        <span class="token comment"># 随机放置障碍物</span>
        obstacle_cells <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>height <span class="token operator">*</span> self<span class="token punctuation">.</span>width<span class="token punctuation">)</span> <span class="token operator">*</span> ratio<span class="token punctuation">)</span>  <span class="token comment"># 障碍物占据40%的格子</span>
        <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>obstacle_cells<span class="token punctuation">)</span><span class="token punctuation">:</span>
            x <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> map2d<span class="token punctuation">.</span>height <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
            y <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> map2d<span class="token punctuation">.</span>width <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> start_point<span class="token punctuation">.</span>x <span class="token keyword">and</span> y <span class="token operator">==</span> start_point<span class="token punctuation">.</span>y<span class="token punctuation">)</span> <span class="token keyword">or</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> end_point<span class="token punctuation">.</span>x <span class="token keyword">and</span> y <span class="token operator">==</span> end_point<span class="token punctuation">.</span>y<span class="token punctuation">)</span> <span class="token keyword">or</span> map2d<span class="token punctuation">.</span>data<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"⬛"</span><span class="token punctuation">:</span>
                x <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> map2d<span class="token punctuation">.</span>height <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
                y <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> map2d<span class="token punctuation">.</span>width <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
            map2d<span class="token punctuation">.</span>set_obstacle<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span>

<span class="token triple-quoted-string string">"""
1.ud指的是up and down
2.rl指的是right and left
"""</span>
<span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> point<span class="token punctuation">:</span> Point<span class="token punctuation">,</span> endpoint<span class="token punctuation">:</span> Point<span class="token punctuation">,</span> g<span class="token punctuation">:</span> <span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment"># 初始化中间节点的参数</span>
        self<span class="token punctuation">.</span>point <span class="token operator">=</span> point
        self<span class="token punctuation">.</span>endpoint <span class="token operator">=</span> endpoint
        self<span class="token punctuation">.</span>father <span class="token operator">=</span> <span class="token boolean">None</span>
        self<span class="token punctuation">.</span>g <span class="token operator">=</span> g
        <span class="token comment">#h取曼哈顿距离，c=|x2-x1|+|y2-y1|</span>
        self<span class="token punctuation">.</span>h <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">abs</span><span class="token punctuation">(</span>endpoint<span class="token punctuation">.</span>x <span class="token operator">-</span> point<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>endpoint<span class="token punctuation">.</span>y <span class="token operator">-</span> point<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10</span>
        self<span class="token punctuation">.</span>f <span class="token operator">=</span> self<span class="token punctuation">.</span>g <span class="token operator">+</span> self<span class="token punctuation">.</span>h

    <span class="token keyword">def</span> <span class="token function">get_near</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ud<span class="token punctuation">,</span> rl<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#获取相邻节点</span>
        near_point <span class="token operator">=</span> Point<span class="token punctuation">(</span>self<span class="token punctuation">.</span>point<span class="token punctuation">.</span>x <span class="token operator">+</span> rl<span class="token punctuation">,</span> self<span class="token punctuation">.</span>point<span class="token punctuation">.</span>y <span class="token operator">+</span> ud<span class="token punctuation">)</span>
        near_node <span class="token operator">=</span> Node<span class="token punctuation">(</span>near_point<span class="token punctuation">,</span> self<span class="token punctuation">.</span>endpoint<span class="token punctuation">,</span> self<span class="token punctuation">.</span>g <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token keyword">if</span> ud <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">or</span> rl <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">else</span> <span class="token number">14</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> near_node
    
<span class="token keyword">class</span> <span class="token class-name">AStar</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> start<span class="token punctuation">:</span> Point<span class="token punctuation">,</span> end<span class="token punctuation">:</span> Point<span class="token punctuation">,</span> map2d<span class="token punctuation">:</span> Map2D<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment">#初始化A*算法的参数</span>
        self<span class="token punctuation">.</span>path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>closed_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>open_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>start <span class="token operator">=</span> start
        self<span class="token punctuation">.</span>end <span class="token operator">=</span> end
        self<span class="token punctuation">.</span>map2d <span class="token operator">=</span> map2d

    <span class="token comment">#从open_list里面找到一个代价最小的节点</span>
    <span class="token keyword">def</span> <span class="token function">select_current</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span>Node<span class="token punctuation">:</span>
        min_f <span class="token operator">=</span> sys<span class="token punctuation">.</span>maxsize
        node_temp <span class="token operator">=</span> <span class="token boolean">None</span>
        <span class="token keyword">for</span> node <span class="token keyword">in</span> self<span class="token punctuation">.</span>open_list<span class="token punctuation">:</span>
            <span class="token keyword">if</span> node<span class="token punctuation">.</span>f <span class="token operator">&lt;</span> min_f<span class="token punctuation">:</span>
                min_f <span class="token operator">=</span> node<span class="token punctuation">.</span>f
                node_temp <span class="token operator">=</span> node
        <span class="token keyword">return</span> node_temp

    <span class="token keyword">def</span> <span class="token function">is_in_open_list</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">:</span>Node<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token builtin">bool</span><span class="token punctuation">:</span><span class="token comment"># 判断节点是否在待检测队列中</span>
        <span class="token keyword">return</span> <span class="token builtin">any</span><span class="token punctuation">(</span><span class="token punctuation">[</span>open_node<span class="token punctuation">.</span>point <span class="token operator">==</span> node<span class="token punctuation">.</span>point <span class="token keyword">for</span> open_node <span class="token keyword">in</span> self<span class="token punctuation">.</span>open_list<span class="token punctuation">]</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">is_in_closed_list</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">:</span>Node<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token builtin">bool</span><span class="token punctuation">:</span><span class="token comment"># 判断节点是否在已检测队列中</span>
        <span class="token keyword">return</span> <span class="token builtin">any</span><span class="token punctuation">(</span><span class="token punctuation">[</span>closed_node<span class="token punctuation">.</span>point <span class="token operator">==</span> node<span class="token punctuation">.</span>point <span class="token keyword">for</span> closed_node <span class="token keyword">in</span> self<span class="token punctuation">.</span>closed_list<span class="token punctuation">]</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">is_obstacle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">:</span>Node<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token builtin">bool</span><span class="token punctuation">:</span><span class="token comment"># 判断节点是否是障碍物</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>map2d<span class="token punctuation">.</span>data<span class="token punctuation">[</span>node<span class="token punctuation">.</span>point<span class="token punctuation">.</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>point<span class="token punctuation">.</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"⬛"</span>

    <span class="token triple-quoted-string string">"""
这个函数是A*算法的核心函数，找到当前节点代价最小的邻点
用list来当作是队列的数据结构，存放探测过或者未被探测的节点，以此来进行路径探索
在路径探索中节点有三种状态
状态1.加入了队列并且已经检测了，这个单独用一个Close_list队列存放
状态2.加入了队列但是还没有检测，这个用Open_list队列存放
状态3.还没有被加入队列
    """</span>
    <span class="token keyword">def</span> <span class="token function">explore_neighbors</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> current_node<span class="token punctuation">:</span>Node<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token builtin">bool</span><span class="token punctuation">:</span>
        up<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#上</span>
        down<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#下</span>
        right<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">#右</span>
        left<span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">#左</span>
        top_right<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#右上</span>
        top_left<span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#左上</span>
        Bottom_right<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#右下</span>
        Bottom_left<span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#左下</span>
        directions <span class="token operator">=</span> <span class="token punctuation">[</span>up<span class="token punctuation">,</span>down<span class="token punctuation">,</span>right<span class="token punctuation">,</span>left<span class="token punctuation">,</span>top_right<span class="token punctuation">,</span>top_left<span class="token punctuation">,</span>Bottom_right<span class="token punctuation">,</span>Bottom_left<span class="token punctuation">]</span>
        <span class="token keyword">for</span> direction <span class="token keyword">in</span> directions<span class="token punctuation">:</span>
            ud<span class="token punctuation">,</span> rl <span class="token operator">=</span> direction
            <span class="token comment">#current_neighbor是当前节点的邻点</span>
            current_neighbor <span class="token operator">=</span> current_node<span class="token punctuation">.</span>get_near<span class="token punctuation">(</span>ud<span class="token punctuation">,</span> rl<span class="token punctuation">)</span>
            <span class="token comment">#如果检测到的节点是终点，就没必要接着往下探索了，直接退出循环，结束这个函数</span>
            <span class="token keyword">if</span> current_neighbor<span class="token punctuation">.</span>point <span class="token operator">==</span> self<span class="token punctuation">.</span>end<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token comment">#判断一下邻点是不是已经检测或者是障碍物，如果是，就跳过这个邻点</span>
            <span class="token keyword">if</span> self<span class="token punctuation">.</span>is_in_closed_list<span class="token punctuation">(</span>current_neighbor<span class="token punctuation">)</span> <span class="token keyword">or</span> self<span class="token punctuation">.</span>is_obstacle<span class="token punctuation">(</span>current_neighbor<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">continue</span>
            <span class="token keyword">if</span> self<span class="token punctuation">.</span>is_in_open_list<span class="token punctuation">(</span>current_neighbor<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token triple-quoted-string string">"""
                作用:在open_list中找到第一个与current_neighbor相同(坐标相同)的节点
                这里有两个值得注意的点
                1.在open_list中,可能有多个与current_neighbor相同(坐标相同)的节点，
                出现这种情况是因为同一个节点，是可以通过多条不同的路径抵达的(意思就是g值不同)
                比如说节点C是当前节点,点A与节点B都能抵达节点C且g值都相同,那么节点C此时在open_list就会被添加两次

                2.previous_current_neighbor是取的在open_list中与current_neighbor相同(坐标相同)的节点中
                他们唯一的区别就是g值不同但因为有多个匹配,因此这里用next函数只取一次即可
                """</span>

                previous_current_neighbor <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">(</span>open_node <span class="token keyword">for</span> open_node <span class="token keyword">in</span> self<span class="token punctuation">.</span>open_list <span class="token keyword">if</span> open_node<span class="token punctuation">.</span>point <span class="token operator">==</span> current_neighbor<span class="token punctuation">.</span>point<span class="token punctuation">)</span>

                <span class="token triple-quoted-string string">"""
                这时就要比较current_neighbor与previous_current_neighbor的代价了,
                假如我在本次的路径探索到的current_neighbor要比我之前的路径探索到的previous_current_neighbor的代价要小
                (这里时刻注意,current_neighbor与previous_current_neighbor是坐标相同的),那么我就要更新previous_current_neighbor的代价
                """</span>
                <span class="token keyword">if</span> current_neighbor<span class="token punctuation">.</span>f <span class="token operator">&lt;</span> previous_current_neighbor<span class="token punctuation">.</span>f<span class="token punctuation">:</span>
                    <span class="token comment">#更新父节点</span>
                    previous_current_neighbor<span class="token punctuation">.</span>father <span class="token operator">=</span> current_node
                    <span class="token comment">#更新g值</span>
                    previous_current_neighbor<span class="token punctuation">.</span>g <span class="token operator">=</span> current_neighbor<span class="token punctuation">.</span>g
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token comment">#对应状态3，直接入队</span>
                current_neighbor<span class="token punctuation">.</span>father <span class="token operator">=</span> current_node
                self<span class="token punctuation">.</span>open_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>current_neighbor<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span>

    <span class="token keyword">def</span> <span class="token function">find_path</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        start_node <span class="token operator">=</span> Node<span class="token punctuation">(</span>point<span class="token operator">=</span>self<span class="token punctuation">.</span>start<span class="token punctuation">,</span> endpoint<span class="token operator">=</span>self<span class="token punctuation">.</span>end<span class="token punctuation">,</span> g<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>open_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>start_node<span class="token punctuation">)</span>
        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
            <span class="token comment">#从open_list里面取出一个代价值最小节点</span>
            current_node <span class="token operator">=</span> self<span class="token punctuation">.</span>select_current<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> current_node <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">None</span>
            <span class="token comment">#取出来后，从open_list里面删除，添加到closed_list里面</span>
            self<span class="token punctuation">.</span>open_list<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>current_node<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>closed_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>current_node<span class="token punctuation">)</span>
            <span class="token comment">#当current_node是终点时，explore_neighbors函数会返回一个True</span>
            <span class="token keyword">if</span> current_node<span class="token punctuation">.</span>point <span class="token operator">==</span> self<span class="token punctuation">.</span>end <span class="token keyword">or</span> self<span class="token punctuation">.</span>explore_neighbors<span class="token punctuation">(</span>current_node<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">while</span> current_node<span class="token punctuation">.</span>father <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                    self<span class="token punctuation">.</span>path<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> current_node<span class="token punctuation">.</span>point<span class="token punctuation">)</span>
                    <span class="token comment">#这里其实就是相当于遍历一个链表</span>
                    current_node <span class="token operator">=</span> current_node<span class="token punctuation">.</span>father
                <span class="token keyword">return</span> self<span class="token punctuation">.</span>path

<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>
    <span class="token comment"># 创建地图</span>
    map2d <span class="token operator">=</span> Map2D<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>
    <span class="token comment"># 设置起点和终点</span>
    start_point <span class="token operator">=</span> Point<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
    end_point <span class="token operator">=</span> Point<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span>
    map2d<span class="token punctuation">.</span>set_start_end<span class="token punctuation">(</span>start_point<span class="token punctuation">,</span> end_point<span class="token punctuation">)</span>
    map2d<span class="token punctuation">.</span>obstacle_generate<span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span>
    <span class="token comment"># 运行A*算法</span>
    start_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
    a_star <span class="token operator">=</span> AStar<span class="token punctuation">(</span>start_point<span class="token punctuation">,</span> end_point<span class="token punctuation">,</span> map2d<span class="token punctuation">)</span>
    path <span class="token operator">=</span> a_star<span class="token punctuation">.</span>find_path<span class="token punctuation">(</span><span class="token punctuation">)</span>
    end_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment"># 打印结果</span>
    <span class="token keyword">if</span> path<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"找到最佳路径："</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> point <span class="token keyword">in</span> path<span class="token punctuation">:</span>
            map2d<span class="token punctuation">.</span>data<span class="token punctuation">[</span>point<span class="token punctuation">.</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>point<span class="token punctuation">.</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"🟩"</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"未找到路径！"</span><span class="token punctuation">)</span>
    map2d<span class="token punctuation">.</span>export_image<span class="token punctuation">(</span><span class="token string">"result.png"</span><span class="token punctuation">)</span>
    <span class="token comment"># 打印运行时间</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"程序运行时间："</span><span class="token punctuation">,</span> end_time <span class="token operator">-</span> start_time<span class="token punctuation">,</span> <span class="token string">"秒"</span><span class="token punctuation">)</span>

</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c7a4bab354b8ed6b4bb30dd72b00e421/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Ruby、Python、Java 开发者必备：Codigger之软件项目体检</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9d5c7a846a979bc50646b828ef4079f5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AI论文阅读笔记 | Timer: Generative Pre-trained Transformers Are Large Time Series Models(ICML 2024)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>