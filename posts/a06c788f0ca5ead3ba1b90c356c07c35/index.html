<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; --＞ 类和对象(二) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/a06c788f0ca5ead3ba1b90c356c07c35/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C&#43;&#43; --＞ 类和对象(二)">
  <meta property="og:description" content="前言 在前面简单的介绍了OOP，什么是类，在类中的this指针。接下来就深入理解类和对象。
默认成员函数 默认构造函数：用于在创建对象时初始化对象的成员变量。默认拷贝构造函数：用于使用已存在的对象来初始化新创建的对象。默认析构函数：在对象生命周期结束时执行清理操作，通常是删除动态分配的资源。默认重载赋值运算符：用于将一个对象的值赋给另一个已存在的对象。默认移动构造函数（C&#43;&#43;11及以后版本）：用于将资源从一个对象转移到另一个对象，而不是复制这些资源。默认重载移动赋值操作符（C&#43;&#43;11及以后版本）：用于将一个对象的资源移动到另一个已存在的对象 ​ 接下来就依次介绍默认成员函数
一、构造函数 构造函数的特性 构造函数类似于初始化函数，在写Stack时候，首先需要初始化Stack。
构造函数并不是开辟空间创建对象，而是初始化
函数名与类名相同无返回值对象实例化时编译器自动调用构造函数构造函数可以重载 class Date { public: //构造函数 Date()	//无参构造函数 { } Date(int year , int month , int day ) //带参构造函数 { _year = year; _month = month; _day = day; } void Print() { cout &lt;&lt; _year &lt;&lt; &#34;-&#34; &lt;&lt; _month &lt;&lt; &#34;-&#34; &lt;&lt; _day &lt;&lt; endl; } private: int _year; int _month; int _day; }; int main() { Date d0;//调用无参数构造 初始化的值是随机值 Date d1(2024, 7.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-12T17:35:02+08:00">
    <meta property="article:modified_time" content="2024-07-12T17:35:02+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; --＞ 类和对象(二)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>前言</h2> 
<blockquote> 
 <p>在前面简单的介绍了OOP，什么是类，在类中的this指针。接下来就深入理解类和对象。</p> 
</blockquote> 
<h3><a id="_4"></a>默认成员函数</h3> 
<ul><li><strong>默认构造函数</strong>：用于在创建对象时初始化对象的成员变量。</li><li><strong>默认拷贝构造函数</strong>：用于使用已存在的对象来初始化新创建的对象。</li><li><strong>默认析构函数</strong>：在对象生命周期结束时执行清理操作，通常是删除动态分配的资源。</li><li><strong>默认重载赋值运算符</strong>：用于将一个对象的值赋给另一个已存在的对象。</li><li><strong>默认移动构造函数</strong>（C++11及以后版本）：用于将资源从一个对象转移到另一个对象，而不是复制这些资源。</li><li><strong>默认重载移动赋值操作符</strong>（C++11及以后版本）：用于将一个对象的资源移动到另一个已存在的对象</li></ul> 
<p>​ <mark>接下来就依次介绍默认成员函数</mark></p> 
<h2><a id="_15"></a>一、构造函数</h2> 
<h3><a id="_17"></a>构造函数的特性</h3> 
<p>构造函数类似于初始化函数，在写Stack时候，首先需要初始化Stack。</p> 
<p><mark>构造函数并不是开辟空间创建对象，而是初始化</mark></p> 
<ol><li>函数名与类名相同</li><li>无返回值</li><li>对象实例化时编译器自动调用构造函数</li><li>构造函数可以重载</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Date</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">//构造函数</span>
	<span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span>								<span class="token comment">//无参构造函数</span>
	<span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">}</span>
	<span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">int</span> year <span class="token punctuation">,</span> <span class="token keyword">int</span> month <span class="token punctuation">,</span> <span class="token keyword">int</span> day <span class="token punctuation">)</span>  <span class="token comment">//带参构造函数</span>
	<span class="token punctuation">{<!-- --></span>
		_year <span class="token operator">=</span> year<span class="token punctuation">;</span>
		_month <span class="token operator">=</span> month<span class="token punctuation">;</span>
		_day <span class="token operator">=</span> day<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> _year <span class="token operator">&lt;&lt;</span> <span class="token string">"-"</span> <span class="token operator">&lt;&lt;</span> _month <span class="token operator">&lt;&lt;</span> <span class="token string">"-"</span> <span class="token operator">&lt;&lt;</span> _day <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _year<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _month<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _day<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Date d0<span class="token punctuation">;</span><span class="token comment">//调用无参数构造 初始化的值是随机值</span>
	Date <span class="token function">d1</span><span class="token punctuation">(</span><span class="token number">2024</span><span class="token punctuation">,</span> <span class="token number">7.1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用带参构造</span>
	d1<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>注意：在调用无参构造函数，初始化时候是随机值。</p> 
<ol start="5"><li>如果类中没有显式定义构造函数，则C++编译器会自动生成一个无参的默认构造函数，一旦 用户显式定义编译器将不再生成。</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Date</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">//Date(int year, int month, int day)</span>
	<span class="token comment">//{<!-- --></span>
	<span class="token comment">//	_year = year;</span>
	<span class="token comment">//	_month = month;</span>
	<span class="token comment">//	_day = day;</span>
	<span class="token comment">//}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _year<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _month<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _day<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Date d0<span class="token punctuation">;</span>
	Date d1<span class="token punctuation">;</span>
	d1<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol><li>在这段代码中,没有显示定义构造函数,那么编译器就会生成一个默认构造函数.</li><li>如果显示定义(即将代码取消注释),那么 <mark>d0</mark> <mark>d1</mark>将没有可调用的默认构造函数 .</li></ol> 
<p>注意:<mark>在 (C++11) 中,针对内置类型不初始化打了补丁,成员变量在声明的时候可以给默认值</mark></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Date</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _year <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> _month <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> _day <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<ol start="7"><li> <p>无参的构造函数和全缺省的构造函数都称为<mark>默认构造函数</mark>，并且默认构造函数只能有一个。</p> <p>注意：无参构造函数、全缺省构造函数、我们没写编译器默认生成的构造函数，都可以认为 是<strong>默认构造函数</strong>。</p> </li></ol> 
<pre><code class="prism language-cpp"><span class="token comment">//无参构造函数</span>
<span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">int</span> year<span class="token punctuation">,</span> <span class="token keyword">int</span> month<span class="token punctuation">,</span> <span class="token keyword">int</span> day<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    _year <span class="token operator">=</span> year<span class="token punctuation">;</span>
    _month <span class="token operator">=</span> month<span class="token punctuation">;</span>
    _day <span class="token operator">=</span> day<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//全缺省构造函数</span>
<span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">int</span> year <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> month <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> day <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    _year <span class="token operator">=</span> year<span class="token punctuation">;</span>
    _month <span class="token operator">=</span> month<span class="token punctuation">;</span>
    _day <span class="token operator">=</span> day<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_128"></a>小结</h3> 
<ul><li>一般情况下,构造函数自己写</li><li>内置类型都有缺省值,并且符合我们的要求可以不写构造函数</li><li>类成员变量均为自定义类型(这些均有自己的构造函数),会调用他们自己的构造函数.</li></ul> 
<h2><a id="_134"></a>二、析构函数</h2> 
<h3><a id="_136"></a>析构函数的特性</h3> 
<ol><li>析构函数名是类名前面加“~”</li><li>无返回值</li><li>在一个类中,如析构函数未显示定义,将自动生成.</li><li>不可以重载</li><li>对象生命周期结束时候C++编译系统自动调用析构函数</li></ol> 
<pre><code class="prism language-cpp"><span class="token comment">//在这里面以以  Stack  为例</span>
<span class="token keyword">class</span> <span class="token class-name">Stack</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token operator">~</span><span class="token function">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">free</span><span class="token punctuation">(</span>_a<span class="token punctuation">)</span><span class="token punctuation">;</span>
		_a <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span><span class="token operator">*</span> _a<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _capacity<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _size<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<ol start="6"><li>如果类中没有申请资源时，析构函数可以不写，直接使用编译器生成的默认析构函数，比如 Date类；有资源申请时，一定要写，否则会造成资源泄漏，比如Stack类。</li></ol> 
<h3><a id="_162"></a>小结</h3> 
<ul><li>内置类型不做任何处理,调用其自己的析构函数.</li><li>动态申请资源,就要显示定义析构函数.</li><li>没有动态申请资源可以不写析构函数.</li></ul> 
<h2><a id="_168"></a>三、拷贝构造函数</h2> 
<h3><a id="_170"></a>拷贝构造函数的特性</h3> 
<ol><li>只有单个形参数,一般用const修饰. 
  <ul><li>const修饰是为了防止赋值错误：例如：本应该_year = year 却写成了year = _year；</li></ul> </li><li>拷贝构造是析构函数的重载形式.</li><li>参数只有一个,且是类类型对象的引用</li><li>自定义传值调用C++编译器调用其拷贝构造函数.</li><li>拷贝构造函数的参数只有一个且必须是类类型对象的引用，使用传值方式编译器直接报错， 因为会引发无穷递归调用</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Date</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">int</span> year <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> month <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> day <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_year <span class="token operator">=</span> year<span class="token punctuation">;</span>
		_month <span class="token operator">=</span> month<span class="token punctuation">;</span>
		_day <span class="token operator">=</span> day<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    <span class="token comment">// DateP(const Date d); 错误示范</span>
	<span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> d<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_year <span class="token operator">=</span> d<span class="token punctuation">.</span>_year<span class="token punctuation">;</span>
		_month <span class="token operator">=</span> d<span class="token punctuation">.</span>_month<span class="token punctuation">;</span>
		_day <span class="token operator">=</span> d<span class="token punctuation">.</span>_day<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _year<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _month<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _day<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Date <span class="token function">d1</span><span class="token punctuation">(</span><span class="token number">2024</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	Date <span class="token function">d2</span><span class="token punctuation">(</span>d1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>注意</strong> : 如果拷贝构造函数不加引用,会发生无穷递归. 函数在传值调用会调用拷贝构造函数,如其函数不加入引用(即传值调用),就会发生无限递归.</p> 
<ol start="6"><li>若未显示定义拷贝构造函数,编译器自动生成.</li></ol> 
<ul><li>内置类型完成值拷贝（浅拷贝）</li><li>自定义类型会调用它自己的拷贝构造。</li></ul> 
<h4><a id="_217"></a>深浅拷贝</h4> 
<p>​ <strong>浅拷贝</strong>：浅拷贝是指复制对象时只复制其基本数据类型成员和指针成员，而不复制指针所指向的内存内容</p> 
<p>​ <strong>深拷贝</strong>：深拷贝则是在复制对象时，不仅复制基本数据类型成员和指针成员，还会为指针所指向的内存内容分配新的内存空间，并将原有内容复制过去。</p> 
<h2><a id="operator_223"></a>四、赋值运算符重载（关键字：operator）</h2> 
<h3><a id="_225"></a>运算符重载</h3> 
<h4><a id="_227"></a>运算符重载的概念</h4> 
<ul><li>运算符重载是一项允许开发者为用户自定义的数据类型（如类）定义运算符的特性。</li><li>通过运算符重载，可以使自定义类型的对象能够使用类似于内置类型的运算符进行操作，从而提高代码的可读性和自然性。</li><li>运算符重载实质上是函数重载的一种特殊形式，重载的函数通过关键字 <code>operator</code> 后跟要重载的运算符符号来命名。</li></ul> 
<h4><a id="_233"></a>运算符重载的规则</h4> 
<ul><li><strong>运算符重载的限制</strong>：C++不允许创建新的运算符，只能对已存在的运算符进行重载。重载运算符不能改变运算符的优先级和结合性，也不能改变运算符操作数的个数及语法结构。</li><li><strong>运算符重载的实现方式</strong>：运算符重载可以通过类的成员函数或非成员函数（通常作为友元函数）来实现。成员函数形式的运算符重载通常用于双目运算符，因为它们可以省略一个参数（即隐含的 <code>this</code> 指针）。非成员函数形式的运算符重载则适用于不涉及类对象或需要对称操作的场合。</li><li><strong>运算符重载的设计原则</strong>：重载运算符应该保持其操作的直觉性，避免产生歧义。例如，重载加号运算符（<code>+</code>）应该执行加法操作，而不是其他操作。</li></ul> 
<p>注意：</p> 
<ol><li>作为类成员函数重载，其形参操作数少一个，形参的第一个参数隐含的this指针。</li><li>（<mark>.*</mark>）（<mark>: :</mark>）（<mark>sizeof</mark>）（<mark>? : :</mark>）（<mark>.</mark>）这五种不可以重载。</li></ol> 
<h3><a id="_244"></a>赋值运算符重载</h3> 
<h5><a id="_246"></a>重载格式：</h5> 
<ul><li>参数类型：const T&amp;，传递引用可以提高传参效率</li><li>返回值类型：T&amp;，返回引用可以提高返回的效率，有返回值目的是为了支持连续赋值 检测是否自己给自己赋值</li><li>返回*this ：要复合连续赋值的含义</li></ul> 
<h5><a id="_252"></a>重载注意：</h5> 
<ul><li>赋值运算符重载不能是全局函数，它必须是类的成员函数。</li><li>重载赋值运算符时，应当考虑异常安全性，确保即使在赋值过程中发生异常，也不会留下半更新的状态。</li><li>重载赋值运算符时，可以选择返回<code>const</code>引用，以避免在赋值后对当前对象进行不必要的修改。</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Date</span>
<span class="token punctuation">{<!-- --></span> 
<span class="token keyword">public</span> <span class="token operator">:</span>
 <span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">int</span> year <span class="token operator">=</span> <span class="token number">1900</span><span class="token punctuation">,</span> <span class="token keyword">int</span> month <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> day <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>
   <span class="token punctuation">{<!-- --></span>
        _year <span class="token operator">=</span> year<span class="token punctuation">;</span>
        _month <span class="token operator">=</span> month<span class="token punctuation">;</span>
        _day <span class="token operator">=</span> day<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
 
 <span class="token function">Date</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> d<span class="token punctuation">)</span>
   <span class="token punctuation">{<!-- --></span>
        _year <span class="token operator">=</span> d<span class="token punctuation">.</span>_year<span class="token punctuation">;</span>
        _month <span class="token operator">=</span> d<span class="token punctuation">.</span>_month<span class="token punctuation">;</span>
        _day <span class="token operator">=</span> d<span class="token punctuation">.</span>_day<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
 <span class="token comment">//赋值运算符重载   </span>
 Date<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Date<span class="token operator">&amp;</span> d<span class="token punctuation">)</span><span class="token comment">//返回this，用来连续赋值。</span>
 <span class="token punctuation">{<!-- --></span>
 <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>d<span class="token punctuation">)</span>
       <span class="token punctuation">{<!-- --></span>
            _year <span class="token operator">=</span> d<span class="token punctuation">.</span>_year<span class="token punctuation">;</span>
            _month <span class="token operator">=</span> d<span class="token punctuation">.</span>_month<span class="token punctuation">;</span>
            _day <span class="token operator">=</span> d<span class="token punctuation">.</span>_day<span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
        
        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">int</span> _year <span class="token punctuation">;</span>
 <span class="token keyword">int</span> _month <span class="token punctuation">;</span>
 <span class="token keyword">int</span> _day <span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>赋值运算符只能重载成类的成员函数不能重载成全局函数（因为其属于<mark>默认成员函数</mark>）</li></ul> 
<p>​ <strong>赋值运算符如果不显式实现，编译器会生成一个默认的。此时用户再在类外自己实现 一个全局的赋值运算符重载，就 和编译器在类中生成的默认赋值运算符重载冲突了，故赋值 运算符重载只能是类的成员函数。</strong></p> 
<ul><li>用户没有显式实现时，编译器会生成一个默认赋值运算符重载，以值的方式逐字节拷贝。(浅拷贝)</li></ul> 
<h3><a id="_302"></a>单目运算符号（自增、自减）</h3> 
<h4><a id="_304"></a>自增</h4> 
<p>在下面的例子中：</p> 
<p>前置：</p> 
<ul><li>前置++：返回+1之后的结果</li><li>注意：this指向的对象函数结束后不会销毁，故以引用方式返回提高效率</li></ul> 
<p>后置：</p> 
<ul><li>前置++和后置++都是一元运算符，为了让前置++与后置++形成能正确重载</li><li>C++规定：后置++重载时多增加一个int类型的参数，但调用函数时该参数不用传递，编译器 自动传递</li><li>注意：后置++是先使用后+1，因此需要返回+1之前的旧值，故需在实现时需要先将this保存 一份，然后给this+1</li><li>temp是临时对象，因此只能以值的方式返回，不能返回引用</li></ul> 
<pre><code class="prism language-cpp"><span class="token comment">// 前置++</span>
Date<span class="token operator">&amp;</span> Date<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 后置++</span>
Date Date<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Date tmp<span class="token punctuation">;</span>	
	tmp <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_336"></a>自减</h4> 
<p>在这里和前置++ 后置++ 思想一致。</p> 
<pre><code class="prism language-cpp"><span class="token comment">// 后置--</span>
Date Date<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Date tmp<span class="token punctuation">;</span>
	tmp <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 前置--</span>
Date<span class="token operator">&amp;</span> Date<span class="token double-colon punctuation">::</span> <span class="token keyword">operator</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span> <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/01485598978658a65702eb1ffa20c78d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringBoot统一功能处理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eea91ca94474f54fb22370f2c1548123/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">6-7 宠物领养开发及相关代码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>