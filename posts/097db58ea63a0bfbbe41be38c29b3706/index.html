<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】一文带你全面了解排序（下）——冒泡排序、快速排序、归并排序、计数排序 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/097db58ea63a0bfbbe41be38c29b3706/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】一文带你全面了解排序（下）——冒泡排序、快速排序、归并排序、计数排序">
  <meta property="og:description" content="目录
一、常见排序算法的实现 1.1 交换排序
1.1.1 基本思想
1.1.2 冒泡排序 1.1.3 快速排序
1.2 归并排序
1.3 非比较排序
二、排序算法复杂度及稳定性分析
人总得为过去的懒惰而付出点代价！
一、常见排序算法的实现 1.1 交换排序 1.1.1 基本思想 基本思想：所谓交换，就是根据序列中两个记录键值的比较结果来对换这两个记录在序列中的位置，交换排序的特点是：将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。
1.1.2 冒泡排序 详细内容见：冒泡排序链接
冒泡排序：
void BubbleSort(int* a, int n) { for (int i = 0; i &lt; n - 1; i&#43;&#43;)//趟数 { int end = n - i - 1; for (int j = 0; j &lt; end; &#43;&#43;j)//交换次数 { if (a[j] &gt; a[j &#43; 1]) { Swap(&amp;a[j], &amp;a[j &#43; 1]); } } } } 冒泡排序优化：【当第一趟进行交换的时候，没有进行交换，说明数组是有序的，那么就不需要进行后面几趟的冒泡了】 void BubbleSort(int* a, int n) { for (int i = 0; i &lt; n - 1; i&#43;&#43;)//趟数 { int exchange = 0; int end = n - i - 1; for (int j = 0; j &lt; end; &#43;&#43;j)//交换次数 { if (a[j] &gt; a[j &#43; 1]) { exchange = 1; Swap(&amp;a[j], &amp;a[j &#43; 1]); } } if (exchange == 0) { break; } } } 把直接插入排序和优化后的冒泡排序进行比较： 如果顺序是有序的，两者是一样的；但是，如果是局部有序，或者接近有序，那么插入适应性和比较次数更少">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-07-23T05:26:50+08:00">
    <meta property="article:modified_time" content="2023-07-23T05:26:50+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】一文带你全面了解排序（下）——冒泡排序、快速排序、归并排序、计数排序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> </p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%C2%A0" rel="nofollow">一、常见排序算法的实现 </a></p> 
<p id="%C2%A01.1%C2%A0%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#%C2%A01.1%C2%A0%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F" rel="nofollow"> 1.1 交换排序</a></p> 
<p id="1.1.1%C2%A0%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-toc" style="margin-left:80px;"><a href="#1.1.1%C2%A0%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3" rel="nofollow">1.1.1 基本思想</a></p> 
<p id="1.1.2%C2%A0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%C2%A0-toc" style="margin-left:80px;"><a href="#1.1.2%C2%A0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%C2%A0" rel="nofollow">1.1.2 冒泡排序 </a></p> 
<p id="1.1.3%C2%A0%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#1.1.3%C2%A0%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" rel="nofollow">1.1.3 快速排序</a></p> 
<p id="1.2%20%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#1.2%20%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" rel="nofollow">1.2 归并排序</a></p> 
<p id="1.3%20%E9%9D%9E%E6%AF%94%E8%BE%83%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#1.3%20%E9%9D%9E%E6%AF%94%E8%BE%83%E6%8E%92%E5%BA%8F" rel="nofollow">1.3 非比较排序</a></p> 
<p id="%E4%BA%8C%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%8F%8A%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%8F%8A%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90" rel="nofollow">二、排序算法复杂度及稳定性分析</a></p> 
<hr> 
<p><span style="color:#ff9900;"> 人总得为过去的懒惰而付出点代价！</span></p> 
<hr> 
<h2 id="%E4%B8%80%E3%80%81%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%C2%A0">一、常见排序算法的实现 </h2> 
<h3 id="%C2%A01.1%C2%A0%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F" style="background-color:transparent;"> 1.1 交换排序</h3> 
<h4 id="1.1.1%C2%A0%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">1.1.1 基本思想</h4> 
<p>基本思想：所谓交换，就是根据序列中两个记录键值的比较结果来对换这两个记录在序列中的位置，交换<strong>排序的特点</strong>是：将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。</p> 
<h4 id="1.1.2%C2%A0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%C2%A0" style="background-color:transparent;">1.1.2 冒泡排序 </h4> 
<p>详细内容见：<a href="http://t.csdn.cn/ml7Uv" rel="nofollow" title="冒泡排序链接">冒泡排序链接</a></p> 
<p>冒泡排序：</p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span> n)</span>
</span>{
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)<span class="hljs-comment">//趟数</span>
	{
		<span class="hljs-type">int</span> end = n - i - <span class="hljs-number">1</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; end; ++j)<span class="hljs-comment">//交换次数</span>
		{
			<span class="hljs-keyword">if</span> (a[j] &gt; a[j + <span class="hljs-number">1</span>])
			{
				<span class="hljs-built_in">Swap</span>(&amp;a[j], &amp;a[j + <span class="hljs-number">1</span>]);
			}
		}
	}
}
</code></pre> 
</div> 
<p>冒泡排序优化：【当第一趟进行交换的时候，没有进行交换，说明数组是有序的，那么就不需要进行后面几趟的冒泡了】 </p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span> n)</span>
</span>{
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)<span class="hljs-comment">//趟数</span>
	{
		<span class="hljs-type">int</span> exchange = <span class="hljs-number">0</span>;
		<span class="hljs-type">int</span> end = n - i - <span class="hljs-number">1</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; end; ++j)<span class="hljs-comment">//交换次数</span>
		{
			<span class="hljs-keyword">if</span> (a[j] &gt; a[j + <span class="hljs-number">1</span>])
			{
				exchange = <span class="hljs-number">1</span>;
				<span class="hljs-built_in">Swap</span>(&amp;a[j], &amp;a[j + <span class="hljs-number">1</span>]);
			}
		}
		<span class="hljs-keyword">if</span> (exchange == <span class="hljs-number">0</span>)
		{
			<span class="hljs-keyword">break</span>;
		}
	}
}</code></pre> 
</div> 
<p><strong>把直接插入排序和优化后的冒泡排序进行比较</strong>： 如果顺序是有序的，两者是一样的；但是，如果是局部有序，或者接近有序，那么插入适应性和比较次数更少</p> 
<blockquote> 
 <p>1. 冒泡排序是一种非常容易理解的排序</p> 
 <p>2. 时间复杂度：O(N^2)</p> 
 <p>3. 空间复杂度：O(1)</p> 
 <p>4. 稳定性：稳定</p> 
</blockquote> 
<h4 id="1.1.3%C2%A0%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" style="background-color:transparent;">1.1.3 快速排序</h4> 
<p>快速排序是Hoare于1962年提出的一种二叉树结构的交换排序方法，其基本思想为：<strong>任取待排序元素序列中</strong><strong>的某元素作为基准值，按照该排序码将待排序集合分割成两子序列，左子序列中所有元素均小于基准值，右</strong><strong>子序列中所有元素均大于基准值，然后最左右子序列重复该过程，直到所有元素都排列在相应位置上为止</strong>。</p> 
<hr> 
<blockquote> 
 <p> 单趟排序：选出一个key，一般是第一个数或者是最后一个数，排序之后要求左边的值都比key小，右边的值都比key大</p> 
</blockquote> 
<p>将区间按照基准值划分为左右两半部分的常见方式有（单趟排序）：</p> 
<p>（1）<strong>hoare版本（霍尔）</strong></p> 
<blockquote> 
 <p><strong>key在左边（</strong>第一个数<strong>）</strong></p> 
 <p>先右边的right找比key小的数据，找到就停止，然后左边的left找比key大的数据，找到就停止，然后进行交换数据，一直到left和right相遇，将该位置的值和key进行交换</p> 
 <p>【因为，交换完之后【left是小的】，右面先走，所以相遇的位置一定是比key小的数字】</p> 
 <p>【相遇的情况只有两种，left主动和right碰面和right主动和left碰面，这两种情况，都是在比key小的位置停下来】</p> 
</blockquote> 
<blockquote> 
 <p><strong>key在右边（</strong>最后一个数<strong>）</strong></p> 
 <p>先左边的left找比key大的数据，找到就停止，然后右边的right找比key小的数据，找到就停止，然后进行交换数据，一直到left和right相遇，将该位置的值和key进行交换</p> 
 <p>【因为，交换完之后【left是小的】，左面先走，所以相遇的位置一定是比key大的数字】</p> 
 <p>【相遇的情况只有两种，left主动和right碰面和right主动和left碰面，这两种情况，都是在比key大的位置停下来】</p> 
</blockquote> 
<p><strong>代码1展示</strong>：</p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PartSort1</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>
</span>{
	<span class="hljs-type">int</span> keyi = left;
	<span class="hljs-keyword">while</span> (left &lt; right)
	{
		<span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt;= a[keyi])
			right--;
		<span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= a[keyi])
			left++;
		<span class="hljs-built_in">Swap</span>(&amp;a[left], &amp;a[right]);
	}
	<span class="hljs-built_in">Swap</span>(&amp;a[left], &amp;a[keyi]);
}</code></pre> 
</div> 
<blockquote> 
 <p>细节问题：（1）【key在左面】如果right在走得时候，遇到左面的数字一直小于等于key，就会一直--，就会越界，所以加上left&lt;right</p> 
</blockquote> 
<p><strong>（2）挖坑法</strong></p> 
<blockquote> 
 <p><strong>key在左边（</strong>第一个数<strong>）</strong></p> 
 <p>边首先，把key值保存，然后这个位置成为一个坑位，然后右边的right找比key小的数据，找到就填补坑位，此时右面的right形成一个坑位，需要左面的left找比key大的数据，找到后填补右面的坑位，一直到left和right相遇，然后key填补相遇时的坑位【左边做坑，右边先走；右边做坑，左边先走】</p> 
 <p><strong>key在右边（</strong>最后一个数<strong>）也同理</strong></p> 
</blockquote> 
<blockquote> 
 <p>和hoare相比，代码几乎一样，但是容易理解：（1）不用理解为什么相遇位置比key小（2）不需要理解左边做key，右边先走</p> 
</blockquote> 
<p><strong>代码2展示</strong>：</p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">PartSort2</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>
</span>{
	<span class="hljs-type">int</span> key = a[left];
	<span class="hljs-type">int</span> pit = left;
	<span class="hljs-keyword">while</span> (left &lt; right)
	{

		<span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt;= key)
		{
			right--;
		}
		a[pit] = a[right];
		pit = right;
		<span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= key)
		{
			left++;
		}
		a[pit] = a[left];
		pit = left;
	}
	a[pit] = key;
	<span class="hljs-keyword">return</span> pit;
}</code></pre> 
</div> 
<p><strong>（3）前后指针法</strong></p> 
<blockquote> 
 <p><strong>key在左边（</strong>第一个数<strong>）</strong></p> 
 <p>两个指针，一个prev，一个cur。刚开始 prev在keyi的位置，cur在keyi的下一个位置;cur找小，如果找到prev++,并交换prev和cur的值；【如果cur和prev++在同一个位置，就没有交换数据的必要：如果cur的第一个位置就是比key小，那么需要prev++,然后交换位置，但是在同一个位置，就没有必要】【while(cur &lt;= right)】</p> 
</blockquote> 
<blockquote> 
 <p>prev和cur的关系：（1）cur还没有遇到比key大的值，prev紧跟cur，一前一后（2）cur遇到比key大的值，prev和cur之间间隔着一段比key大的值的区间。</p> 
</blockquote> 
<p>代码3展示：</p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">PartSort3</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>
</span>{
	<span class="hljs-type">int</span> key = a[left];
	<span class="hljs-type">int</span> prev = left;
	<span class="hljs-type">int</span> cur = left + <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (cur &lt;= right)
	{
		<span class="hljs-keyword">if</span> (a[cur] &lt; key &amp;&amp; a[cur] != a[++prev])<span class="hljs-comment">//这个条件，只有前面条件符合才会走后面的条件</span>
		{
			<span class="hljs-built_in">Swap</span>(&amp;a[cur], &amp;a[prev]);
		}
		cur++;
	}
	<span class="hljs-built_in">Swap</span>(&amp;a[left], &amp;a[prev]);<span class="hljs-comment">//这里不能写&amp;key，因为并不能改变a[left]的值，不要和局部变量交换</span>
	<span class="hljs-keyword">return</span> prev;
}</code></pre> 
</div> 
<blockquote> 
 <p><strong>key在右面（最后</strong>一个数<strong>）</strong></p> 
 <p>两个指针，一个prev，一个cur。刚开始 prev在left-1的位置，cur在left;cur找小，如果找到prev++,并交换prev和cur的值；【如果cur和prev++在同一个位置，就没有交换数据的必要：如果cur的第一个位置就是比key小，那么需要prev++,然后交换位置，但是在同一个位置，就没有必要】【while (cur &lt;= right - 1】</p> 
</blockquote> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">PartSort4</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>
</span>{
	<span class="hljs-type">int</span> key = a[right];
	<span class="hljs-type">int</span> prev = left - <span class="hljs-number">1</span>;
	<span class="hljs-type">int</span> cur = left;
	<span class="hljs-keyword">while</span> (cur &lt;= right - <span class="hljs-number">1</span>)
	{
		<span class="hljs-keyword">if</span> (a[cur] &lt; key &amp;&amp; a[cur] != a[++prev])<span class="hljs-comment">//这个条件，只有前面条件符合才会走后面的条件</span>
		{
			<span class="hljs-built_in">Swap</span>(&amp;a[cur], &amp;a[prev]);
		}
		cur++;
	}
	<span class="hljs-built_in">Swap</span>(&amp;a[right], &amp;a[++prev]);<span class="hljs-comment">//这里不能写&amp;key，因为并不能改变a[left]的值，不要和局部变量交换</span>
	<span class="hljs-keyword">return</span> prev;
}</code></pre> 
</div> 
<hr> 
<blockquote> 
 <p>整体排序：单趟排序之后，key已经放在正确的位置，不需要进行移动，此时只要保证左边有序，右面有序，就可以保证整体有序了【分治解决子问题】</p> 
</blockquote> 
<p>代码展示：（hoare单趟排序+分治整体排序） </p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-comment">//快速排序</span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">PartSort</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>
</span>{
	<span class="hljs-type">int</span> keyi = left;
	<span class="hljs-keyword">while</span> (left &lt; right)
	{
		<span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt;= a[keyi])
			right--;
		<span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= a[keyi])
			left++;
		<span class="hljs-built_in">Swap</span>(&amp;a[left], &amp;a[right]);
	}
	<span class="hljs-built_in">Swap</span>(&amp;a[left], &amp;a[keyi]);
	<span class="hljs-keyword">return</span> left;
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span>
</span>{
	<span class="hljs-keyword">if</span> (begin &gt;= end)
		<span class="hljs-keyword">return</span>;
	<span class="hljs-type">int</span> keyi = <span class="hljs-built_in">PartSort</span>(a, begin, end);
	<span class="hljs-built_in">QuickSort</span>(a, begin, keyi - <span class="hljs-number">1</span>);
	<span class="hljs-built_in">QuickSort</span>(a, keyi + <span class="hljs-number">1</span>, end);
}</code></pre> 
</div> 
<blockquote> 
 <p>1. 快速排序整体的综合性能和使用场景都是比较好的，所以才敢叫<strong>快速</strong>排序</p> 
 <p>2. 时间复杂度：O(N*logN)  每次调用快速排序，都需要把所有元素进行遍历一遍</p> 
 <p>最好的情况：每次选key都是中位数O(N*logN)   最差的情况：每次选key都是最大的数字或者最小的数字O(N^2)  [有序或者接近有序]</p> 
 <p>3. 空间复杂度：O(logN)</p> 
 <p>4. 稳定性：不稳定</p> 
</blockquote> 
<hr> 
<p><strong> 快速排序<u>优化 </u></strong></p> 
<blockquote> 
 <p> 因为最坏的情况，所以可以对key进行优化，让key不是最大或者最小的数字：（1）随机选key（2）三个数字选不大也不小的那个数字，然后这个数字和left或者right位置的数据进行交换。</p> 
</blockquote> 
<p>代码展示：</p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetMinIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>
</span>{
	<span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;
	<span class="hljs-keyword">if</span> (a[left] &lt; a[mid])
	{
		<span class="hljs-keyword">if</span> (a[right] &gt; a[mid])
		{
			<span class="hljs-keyword">return</span> mid;
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[left] &gt; a[right])
		{
			<span class="hljs-keyword">return</span> left;
		}
		<span class="hljs-keyword">else</span>
		{
			<span class="hljs-keyword">return</span> right;
		}
	}
	<span class="hljs-keyword">else</span>
	{
		<span class="hljs-keyword">if</span> (a[mid] &gt; a[right])
		{
			<span class="hljs-keyword">return</span> mid;
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[right] &gt; a[left])
		{
			<span class="hljs-keyword">return</span> left;
		}
		<span class="hljs-keyword">else</span>
		{
			<span class="hljs-keyword">return</span> right;
		}
	}
}

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">PartSort1</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>
</span>{
	<span class="hljs-type">int</span> midi = <span class="hljs-built_in">GetMidIndex</span>(a, left, right);
	<span class="hljs-built_in">Swap</span>(&amp;a[left], &amp;a[midi]);
	<span class="hljs-type">int</span> keyi = left;
	<span class="hljs-keyword">while</span> (left &lt; right)
	{
		<span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt;= a[keyi])
			right--;
		<span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= a[keyi])
			left++;
		<span class="hljs-built_in">Swap</span>(&amp;a[left], &amp;a[right]);
	}
	<span class="hljs-built_in">Swap</span>(&amp;a[left], &amp;a[keyi]);
	<span class="hljs-keyword">return</span> left;
}</code></pre> 
</div> 
<blockquote> 
 <p>小区间优化：区间很小时，不再使用递归划分的思路，而是直接使用插入排序对小区间进行排序，减少递归调用</p> 
</blockquote> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span>
</span>{
	<span class="hljs-keyword">if</span> (begin &gt;= end)
		<span class="hljs-keyword">return</span>;
	<span class="hljs-keyword">if</span> (end - begin + <span class="hljs-number">1</span> &lt;= <span class="hljs-number">10</span>)
	{
		<span class="hljs-built_in">InsertSort</span>(a + begin, end - begin + <span class="hljs-number">1</span>);
	}
	<span class="hljs-keyword">else</span>
	{
		<span class="hljs-type">int</span> keyi = <span class="hljs-built_in">PartSort1</span>(a, begin, end);
		<span class="hljs-built_in">QuickSort</span>(a, begin, keyi - <span class="hljs-number">1</span>);
		<span class="hljs-built_in">QuickSort</span>(a, keyi + <span class="hljs-number">1</span>, end);
	}
}</code></pre> 
</div> 
<hr> 
<p><strong>快速排序非递归（栈）</strong></p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QucikSort</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span>
</span>{
	ST st;
	<span class="hljs-built_in">StackInit</span>(&amp;st);
	<span class="hljs-built_in">StackPush</span>(&amp;st, begin);
	<span class="hljs-built_in">StackPush</span>(&amp;st, end);

	<span class="hljs-keyword">while</span> (!<span class="hljs-built_in">StackEmpty</span>(&amp;st))
	{
		<span class="hljs-type">int</span> right = <span class="hljs-built_in">StackTop</span>(&amp;st);
		<span class="hljs-built_in">StackPop</span>(&amp;st);
		<span class="hljs-type">int</span> left = <span class="hljs-built_in">StackTop</span>(&amp;st);
		<span class="hljs-built_in">StackPop</span>(&amp;st);
		<span class="hljs-type">int</span> keyi = <span class="hljs-built_in">PartSort</span>(a, left, right);
		<span class="hljs-keyword">if</span> (left &lt; keyi - <span class="hljs-number">1</span>)
		{
			<span class="hljs-built_in">StackPush</span>(&amp;st, left);
			<span class="hljs-built_in">StackPush</span>(&amp;st, keyi <span class="hljs-number">-1</span>);
		}
		<span class="hljs-keyword">if</span> (right &gt; keyi + <span class="hljs-number">1</span>)
		{
			<span class="hljs-built_in">StackPush</span>(&amp;st, keyi - <span class="hljs-number">1</span>);
			<span class="hljs-built_in">StackPush</span>(&amp;st, right);
		}
	}
	<span class="hljs-built_in">StackDestory</span>(&amp;st);
}</code></pre> 
</div> 
<blockquote> 
 <p> 递归改成非递归：（1）用循环（2）用栈【递归会有爆栈的风险】</p> 
</blockquote> 
<h3 id="1.2%20%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" style="background-color:transparent;">1.2 归并排序</h3> 
<p>先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表【先让左右区间有序，再对两个区间归并】</p> 
<hr> 
<p>一个数组分成左右两个数组，假设数组有序，两个有序数组，归并成一个有序数组。（取两个数组中小的数据，依此尾插到新的数组），但是这个数组是无序的，所以把数组一直分，一直分到一个数据或者没有数据，就可以认为是有序的，然后依次合并，然后这个数组就是有序的。【先分再合并】</p> 
<p>代码展示：【递归】</p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-type">void</span> _MergeSort(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span>* tmp)
{
	<span class="hljs-keyword">if</span> (begin &gt;= end)
	{
		<span class="hljs-keyword">return</span>;
	}
	<span class="hljs-type">int</span> mid = (begin + end) / <span class="hljs-number">2</span>;<span class="hljs-comment">//中间值</span>
	_MergeSort(a, begin, mid, tmp);<span class="hljs-comment">//左边有序</span>
	_MergeSort(a, mid + <span class="hljs-number">1</span>, end, tmp);<span class="hljs-comment">//右边有序</span>
	<span class="hljs-type">int</span> begin1 = begin;
	<span class="hljs-type">int</span> end1 = mid;
	<span class="hljs-type">int</span> begin2 = mid + <span class="hljs-number">1</span>;
	<span class="hljs-type">int</span> end2 = end;
	<span class="hljs-type">int</span> index = begin;
	<span class="hljs-keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)
	{
		<span class="hljs-keyword">if</span> (a[begin1] &lt; a[begin2])
		{
			tmp[index++] = a[begin1++];
		}
		<span class="hljs-keyword">else</span>
		{
			tmp[index++] = a[begin2++];
		}
	}
	<span class="hljs-keyword">while</span> (begin1 &lt;= end1)
	{
		tmp[index++] = a[begin1++];
	}
	<span class="hljs-keyword">while</span> (begin2 &lt;= end2)
	{
		tmp[index++] = a[begin2++];
	}
	<span class="hljs-built_in">memcpy</span>(a+begin, tmp+begin, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * (end - begin + <span class="hljs-number">1</span>));
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span> n)</span>
</span>{
	<span class="hljs-type">int</span>* tmp = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * n);
	<span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">NULL</span>)
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"malloc fail\n"</span>);
		<span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);
	}
	_MergeSort(a, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, tmp);
	<span class="hljs-built_in">free</span>(tmp);
	tmp = <span class="hljs-literal">NULL</span>;
}</code></pre> 
</div> 
<blockquote> 
 <p>（1）mid等于（第一个数据的下标+最后一个数据的下标）/2，分成的两个区间应该是【left，mid】【mid+ 1, right】,否则就会出现死循环。</p> 
 <p>（2）分割完再合并，分割完分别调用合并排序，  合并排序写在调用后面。【分割的两个数组都有序之后，再合并】【函数主框架，左面有序+右面有序+合并】</p> 
 <p>（3）归并完再把内容复制到原来的数组里。【归并的时候需要新的数组】</p> 
 <p>（4）类似于后序遍历</p> 
</blockquote> 
<blockquote> 
 <p>1. 归并的缺点在于需要O(N)的空间复杂度，归并排序的思考更多的是解决在磁盘中的外排序问题。</p> 
 <p>2. 时间复杂度：O(N*logN)   N个数据，logN层 </p> 
 <p>3. 空间复杂度：O(N)    时间复杂度是O(N + logN) 但是 logN可以忽略不计</p> 
 <p>4. 稳定性：稳定</p> 
</blockquote> 
<p>代码展示：【非递归】</p> 
<div> 
 <pre><code class="language-cpp hljs"><span class="hljs-comment">//归并排序</span>
<span class="hljs-comment">//非递归</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeSort2</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span> n)</span>
</span>{
	<span class="hljs-type">int</span>* tmp = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * n);
	<span class="hljs-type">int</span> gap = <span class="hljs-number">1</span>;
	<span class="hljs-keyword">while</span> (gap &lt; n)
	{
		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += <span class="hljs-number">2</span> * gap)
		{
			<span class="hljs-type">int</span> begin1 = i, end1 = i + gap - <span class="hljs-number">1</span>;
			<span class="hljs-type">int</span> begin2 = i + gap, end2 = i + <span class="hljs-number">2</span> * gap - <span class="hljs-number">1</span>;
			<span class="hljs-keyword">if</span> (end1 &gt;= n)
				end1 = n - <span class="hljs-number">1</span>;
			<span class="hljs-keyword">if</span> (begin2 &gt;= n)
			{
				begin2 = n;
				end2 = n - <span class="hljs-number">1</span>;
			}
			<span class="hljs-comment">// begin2没有越界， end2越界，修正end2即可</span>
			<span class="hljs-keyword">if</span> (begin2 &lt; n &amp;&amp; end2 &gt;= n)
				end2 = n - <span class="hljs-number">1</span>;

			<span class="hljs-type">int</span> index = i;
			<span class="hljs-keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)
			{
				<span class="hljs-keyword">if</span> (a[begin1] &lt; a[begin2])
					tmp[index++] = a[begin1++];
				<span class="hljs-keyword">else</span>
					tmp[index++] = a[begin2++];
			}

			<span class="hljs-keyword">while</span> (begin1 &lt;= end1)
				tmp[index++] = a[begin1++];

			<span class="hljs-keyword">while</span> (begin2 &lt;= end2)
				tmp[index++] = a[begin2++];
		}
		<span class="hljs-built_in">memcpy</span>(a, tmp, n * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));
		gap *= <span class="hljs-number">2</span>;
	}
	<span class="hljs-built_in">free</span>(tmp);
}</code></pre> 
</div> 
<blockquote> 
 <p>首先gap为1进行归并，此时2个数据一组是有序的，然后gap = gap*2 = 2,判断gap是否&gt;=n, 然后gap为2进行归并，此时4个数据一组是有序的，然后gap = gap*2 = 4判断gap是否&gt;=n,然后gap为4进行归并……直到gap&gt;=n的时候结束【gap是多少，就多少一组进行合并】</p> 
</blockquote> 
<blockquote> 
 <p><strong>越界问题:</strong>begin1是不可能越界的（begin1是等于i的，i又是小于n的）end1、begin2、end2是可能越界的</p> 
 <p>(1)只有end2越界，进行修正，n-1</p> 
 <p>（2）begin2越界，那么end2也越界，此时归并的第二组数据都越界，那么begin2和end2就不需要修正，那么第二组区间不存在</p> 
 <p>（3）end1越界，进行修正，那么第二组区间不存在即可</p> 
</blockquote> 
<blockquote> 
 <p>时间复杂度：O(N*logN)           空间复杂度：O(N) </p> 
</blockquote> 
<blockquote> 
 <p><strong>调试小技巧：</strong></p> 
 <div> 
  <pre><code class="language-cpp hljs"><span class="hljs-comment">// 条件断点</span>
			<span class="hljs-keyword">if</span> (begin1 == <span class="hljs-number">8</span> &amp;&amp; end1 == <span class="hljs-number">9</span> &amp;&amp; begin2 == <span class="hljs-number">9</span> &amp;&amp; end2 == <span class="hljs-number">9</span>)
			{
				<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;
			}</code></pre> 
 </div> 
 <p>当我们想要在某一个地方停止，但是比较麻烦，可以直接写一个条件断点，然后打一个断点即可</p> 
</blockquote> 
<h3 id="1.3%20%E9%9D%9E%E6%AF%94%E8%BE%83%E6%8E%92%E5%BA%8F" style="background-color:transparent;">1.3 非比较排序</h3> 
<p><strong>比较排序</strong>：直接插入排序、希尔排序、选择排序、堆排序、冒泡排序、快速排序、归并排序</p> 
<p><strong>非比较排序</strong>：（1）计数排序（2）基数排序、桶排序</p> 
<p>计数排序又称为鸽巢原理，是对哈希直接定址法的变形应用。</p> 
<p>计数排序代码展示：</p> 
<div> 
 <pre><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CountSort</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span> n)</span>
</span>{
	<span class="hljs-type">int</span> min = a[<span class="hljs-number">0</span>];
	<span class="hljs-type">int</span> max = a[<span class="hljs-number">0</span>];
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)
	{
		<span class="hljs-keyword">if</span> (a[i] &lt; min)
			min = a[i];
		<span class="hljs-keyword">if</span> (a[i] &gt; max)
			max = a[i];
	}
	<span class="hljs-type">int</span> range = max - min + <span class="hljs-number">1</span>;
	<span class="hljs-type">int</span>* countA = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * range);
	<span class="hljs-keyword">if</span> (countA == <span class="hljs-literal">NULL</span>)
	{
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"malloc fail\n"</span>);
		<span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);
	}
	<span class="hljs-built_in">memset</span>(countA, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * range);
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
	{
		countA[a[i] - min]++;
	}
	<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; range; i++)
	{
		<span class="hljs-keyword">while</span> (countA[i]--)
		{
			a[j++] = i + min;
		}
	}
}
</code></pre> 
</div> 
<blockquote> 
 <p>首先找出数据的最大值的最小值，然后相减+1算出新数组的大小，然后新数组的值都赋值为0，然后遍历以前的数组，遍历的数字-min，就是新数组的下标，这个下标里面的值就+1，遍历完以前的数组之后，再把新的数组的值再返回以前的数组即可</p> 
</blockquote> 
<blockquote> 
 <p>1. 计数排序<strong>在数据范围集中时</strong>，效率很高，但是适用范围及场景有限。（适用于数据范围集中）（适用于整数，负数也可以，其他类型不可以）</p> 
 <p>2. 时间复杂度：O(MAX(N,范围))</p> 
 <p>3. 空间复杂度：O(范围)</p> 
 <p>4. 稳定性：稳定</p> 
</blockquote> 
<h2 id="%E4%BA%8C%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%8F%8A%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90" style="background-color:transparent;">二、排序算法复杂度及稳定性分析</h2> 
<p><img alt="" height="597" src="https://images2.imgbox.com/bb/71/Kw2KnSeE_o.png" width="1163"><span title="点击并拖拽以改变尺寸">​</span></p> 
<p><img alt="" height="404" src="https://images2.imgbox.com/b3/dc/sPG4wEEy_o.png" width="1152"><span title="点击并拖拽以改变尺寸">​</span></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/880d8ae9529dc6738db0cb1d954a6262/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【数据结构】一文带你全面了解排序（上）——直接插入排序、希尔排序、选择排序、堆排序</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f130eac23126a6a68d9ce887665525a4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python中安装Gurobi：配置与使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>