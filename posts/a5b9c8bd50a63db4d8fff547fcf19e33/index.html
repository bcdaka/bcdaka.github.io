<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C语言】第四十二弹---一万六千字教你从0到1实现通讯录 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/a5b9c8bd50a63db4d8fff547fcf19e33/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C语言】第四十二弹---一万六千字教你从0到1实现通讯录">
  <meta property="og:description" content="✨个人主页： 熬夜学编程的小林
💗系列专栏： 【C语言详解】 【数据结构详解】
目录
1、通讯录分析和设计
1.1、通讯录的功能说明
1.2、程序的分析和设计
1.2.1、数据结构的分析
1.2.2、文件结构设计
2、通讯录的结构分析
2.1、创建通讯录结构
2.1.1、静态版本
2.1.2、动态版本
2.2、用户选择
2.3、初始化通讯录
2.3.1、静态通讯录
2.3.2、动态通讯录
2.3.3、动态文件通讯录
2.4、添加联系人信息
2.5、打印联系人信息
2.6、删除联系人
2.7、 查找联系人
2.8、修改联系人
2.9、排序联系人信息
2.10、存储联系人信息到文件
2.11、销毁通讯录
3、完整代码
3.1、contact.h
3.2、contact.c 3.3、test.c
总结
前面接近四十弹内容基本都在学习C语言的基本语法，单纯的学习语法会让我们的学习比较枯燥，因此该节内容通过C语言学习的语法知识实现一个我们手机都有的通讯录功能。
1、通讯录分析和设计 1.1、通讯录的功能说明 1、通讯录中包含个人的姓名，性别，年龄，电话与地址。
2、用户可以自由进出程序。
3、用户可以自由增删查改以及排序通讯录中的数据。
程序的界面：
1.2、程序的分析和设计 1.2.1、数据结构的分析 通讯录中存储的数据有姓名，性别，年龄，电话与地址，此处会用到字符串(字符串通过字符数组进行实现)，整型的结合，因此我们可以封装成一个结构体进行统一存储。根据通讯录功能的说明，我们需要对通讯录进行增删改查操作，如何才能确定需要操作的数据是哪一组呢？如何确定最终存储了多少组数据呢？
解决办法如下：
1、再创建一个结构体，该结构体的内容包括存储数据的结构体和该结构体的最大存储个数(静态版本，创建静态数组)。
2、再创建一个结构体，该结构体的内容包括存储数据的结构体、存储数据的结构体的实际存储个数以及存储数据的结构体的(容量)最大存储个数(动态版本，动态开辟数组)。
知道数据的存储之后就是创建我们常用的菜单，即前面扫雷，猜数字游戏用到的菜单，通讯录也是同样的原理，用do while循环实现此菜单，根据上面程序的界面可以知道，我们需要实现接口函数较多，因此推荐使用switch选择语句，但是switch语句的类型需要整型，单纯我们整数去实现该函数不够通俗易懂，此处的解决办法有1、通过#define定义常量 2、使用枚举类型。
如果使用#define定义常量，需要7处，代码也比较繁琐，但是如果此处使用枚举类型，可以定义一次即可(枚举类型不初始化第一个变量自动初始化为0，后面依次加&#43;)，非常满足此处的需求。
后面就是基本接口函数的实现了，在后面一一详细讲解。
1.2.2、文件结构设计 之前学习了多文件的形式对函数的声明和定义，这里我们实践⼀下，我们设计三个⽂件：
test.c : 文件中写程序的测试逻辑
Contact.c : 文件中写程序中函数的实现等
Contact.h : 文件中写程序需要的数据类型和函数声明等
建议：写一些代码就测试一些代码。
2、通讯录的结构分析 2.1、创建通讯录结构 2.1.1、静态版本 静态通讯录就是在开辟空间时，给一个固定的大小，缺陷在于空间小了，不能扩容，空间大了，会造成浪费。
//常量使用#define宏定义，便于以后修改 #define NAME_MAX 20 #define SEX_MAX 5 #define TELE_MAX 13 #define ADDR_MAX 30 #define MAX 100 //通讯录大小，存放多少人的信息 //一个人的信息 typedef struct PeoInfo { char name[NAME_MAX]; int age; char sex[SEX_MAX]; char tele[TELE_MAX]; char addr[ADDR_MAX]; }PeoInfo; //静态版本，通讯录的信息 typedef struct Contact { PeoInfo data[MAX]; int sz; }Contact; 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-27T16:46:48+08:00">
    <meta property="article:modified_time" content="2024-06-27T16:46:48+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C语言】第四十二弹---一万六千字教你从0到1实现通讯录</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" src="https://images2.imgbox.com/15/6a/Cejwy0MM_o.jpg"></p> 
<p style="text-align:center;"> ✨<span style="color:#956fe7;">个人主页：</span><a href="https://blog.csdn.net/2201_75584283?spm=1011.2415.3001.5343" title=" 熬夜学编程的小林"> 熬夜学编程的小林</a></p> 
<p style="text-align:center;">💗<span style="color:#fe2c24;">系列专栏：</span> <a href="https://blog.csdn.net/2201_75584283/category_12556736.html" title="【C语言详解】">【C语言详解】</a> <a href="https://blog.csdn.net/2201_75584283/category_12556751.html" title="【数据结构详解】">【数据结构详解】</a></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%86%E6%9E%90%E5%92%8C%E8%AE%BE%E8%AE%A1-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%86%E6%9E%90%E5%92%8C%E8%AE%BE%E8%AE%A1" rel="nofollow">1、通讯录分析和设计</a></p> 
<p id="1.1%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E7%9A%84%E5%8A%9F%E8%83%BD%E8%AF%B4%E6%98%8E-toc" style="margin-left:40px;"><a href="#1.1%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E7%9A%84%E5%8A%9F%E8%83%BD%E8%AF%B4%E6%98%8E" rel="nofollow">1.1、通讯录的功能说明</a></p> 
<p id="1.2%20%E6%B8%B8%E6%88%8F%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E8%AE%BE%E8%AE%A1-toc" style="margin-left:40px;"><a href="#1.2%20%E6%B8%B8%E6%88%8F%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E8%AE%BE%E8%AE%A1" rel="nofollow">1.2、程序的分析和设计</a></p> 
<p id="1.2.1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#1.2.1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%86%E6%9E%90" rel="nofollow">1.2.1、数据结构的分析</a></p> 
<p id="1.2.2%E3%80%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1-toc" style="margin-left:80px;"><a href="#1.2.2%E3%80%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1" rel="nofollow">1.2.2、文件结构设计</a></p> 
<p id="2%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90-toc" style="margin-left:0px;"><a href="#2%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90" rel="nofollow">2、通讯录的结构分析</a></p> 
<p id="2.1%E3%80%81%E5%88%9B%E5%BB%BA%E9%80%9A%E8%AE%AF%E5%BD%95%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#2.1%E3%80%81%E5%88%9B%E5%BB%BA%E9%80%9A%E8%AE%AF%E5%BD%95%E7%BB%93%E6%9E%84" rel="nofollow">2.1、创建通讯录结构</a></p> 
<p id="2.1.1%E3%80%81%E9%9D%99%E6%80%81%E7%89%88%E6%9C%AC-toc" style="margin-left:80px;"><a href="#2.1.1%E3%80%81%E9%9D%99%E6%80%81%E7%89%88%E6%9C%AC" rel="nofollow">2.1.1、静态版本</a></p> 
<p id="2.1.2%E3%80%81%E5%8A%A8%E6%80%81%E7%89%88%E6%9C%AC-toc" style="margin-left:80px;"><a href="#2.1.2%E3%80%81%E5%8A%A8%E6%80%81%E7%89%88%E6%9C%AC" rel="nofollow">2.1.2、动态版本</a></p> 
<p id="2.1%E3%80%81%E7%94%A8%E6%88%B7%E9%80%89%E6%8B%A9-toc" style="margin-left:40px;"><a href="#2.1%E3%80%81%E7%94%A8%E6%88%B7%E9%80%89%E6%8B%A9" rel="nofollow">2.2、用户选择</a></p> 
<p id="2.3%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%80%9A%E8%AE%AF%E5%BD%95-toc" style="margin-left:40px;"><a href="#2.3%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%80%9A%E8%AE%AF%E5%BD%95" rel="nofollow">2.3、初始化通讯录</a></p> 
<p id="2.3.1%E3%80%81%E9%9D%99%E6%80%81%E9%80%9A%E8%AE%AF%E5%BD%95-toc" style="margin-left:80px;"><a href="#2.3.1%E3%80%81%E9%9D%99%E6%80%81%E9%80%9A%E8%AE%AF%E5%BD%95" rel="nofollow">2.3.1、静态通讯录</a></p> 
<p id="2.3.2%E3%80%81%E5%8A%A8%E6%80%81%E9%80%9A%E8%AE%AF%E5%BD%95-toc" style="margin-left:80px;"><a href="#2.3.2%E3%80%81%E5%8A%A8%E6%80%81%E9%80%9A%E8%AE%AF%E5%BD%95" rel="nofollow">2.3.2、动态通讯录</a></p> 
<p id="2.3.3%E3%80%81%E5%8A%A8%E6%80%81%E6%96%87%E4%BB%B6%E9%80%9A%E8%AE%AF%E5%BD%95-toc" style="margin-left:80px;"><a href="#2.3.3%E3%80%81%E5%8A%A8%E6%80%81%E6%96%87%E4%BB%B6%E9%80%9A%E8%AE%AF%E5%BD%95" rel="nofollow">2.3.3、动态文件通讯录</a></p> 
<p id="2.4%E3%80%81%E6%B7%BB%E5%8A%A0%E8%81%94%E7%B3%BB%E4%BA%BA%E4%BF%A1%E6%81%AF-toc" style="margin-left:40px;"><a href="#2.4%E3%80%81%E6%B7%BB%E5%8A%A0%E8%81%94%E7%B3%BB%E4%BA%BA%E4%BF%A1%E6%81%AF" rel="nofollow">2.4、添加联系人信息</a></p> 
<p id="%C2%A02.5%E3%80%81%E6%89%93%E5%8D%B0%E8%81%94%E7%B3%BB%E4%BA%BA%E4%BF%A1%E6%81%AF-toc" style="margin-left:40px;"><a href="#%C2%A02.5%E3%80%81%E6%89%93%E5%8D%B0%E8%81%94%E7%B3%BB%E4%BA%BA%E4%BF%A1%E6%81%AF" rel="nofollow">2.5、打印联系人信息</a></p> 
<p id="%C2%A02.6%E3%80%81%E5%88%A0%E9%99%A4%E8%81%94%E7%B3%BB%E4%BA%BA-toc" style="margin-left:40px;"><a href="#%C2%A02.6%E3%80%81%E5%88%A0%E9%99%A4%E8%81%94%E7%B3%BB%E4%BA%BA" rel="nofollow">2.6、删除联系人</a></p> 
<p id="2.7%E3%80%81%20%E6%9F%A5%E6%89%BE%E8%81%94%E7%B3%BB%E4%BA%BA-toc" style="margin-left:40px;"><a href="#2.7%E3%80%81%20%E6%9F%A5%E6%89%BE%E8%81%94%E7%B3%BB%E4%BA%BA" rel="nofollow">2.7、 查找联系人</a></p> 
<p id="2.8%E3%80%81%E4%BF%AE%E6%94%B9%E8%81%94%E7%B3%BB%E4%BA%BA-toc" style="margin-left:40px;"><a href="#2.8%E3%80%81%E4%BF%AE%E6%94%B9%E8%81%94%E7%B3%BB%E4%BA%BA" rel="nofollow">2.8、修改联系人</a></p> 
<p id="2.9%E3%80%81%E6%8E%92%E5%BA%8F%E8%81%94%E7%B3%BB%E4%BA%BA%E4%BF%A1%E6%81%AF-toc" style="margin-left:40px;"><a href="#2.9%E3%80%81%E6%8E%92%E5%BA%8F%E8%81%94%E7%B3%BB%E4%BA%BA%E4%BF%A1%E6%81%AF" rel="nofollow">2.9、排序联系人信息</a></p> 
<p id="%C2%A02.10%E3%80%81%E5%AD%98%E5%82%A8%E8%81%94%E7%B3%BB%E4%BA%BA%E4%BF%A1%E6%81%AF%E5%88%B0%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#%C2%A02.10%E3%80%81%E5%AD%98%E5%82%A8%E8%81%94%E7%B3%BB%E4%BA%BA%E4%BF%A1%E6%81%AF%E5%88%B0%E6%96%87%E4%BB%B6" rel="nofollow">2.10、存储联系人信息到文件</a></p> 
<p id="2.11%E3%80%81%E9%94%80%E6%AF%81%E9%80%9A%E8%AE%AF%E5%BD%95-toc" style="margin-left:40px;"><a href="#2.11%E3%80%81%E9%94%80%E6%AF%81%E9%80%9A%E8%AE%AF%E5%BD%95" rel="nofollow">2.11、销毁通讯录</a></p> 
<p id="3%E3%80%81%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;"><a href="#3%E3%80%81%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow">3、完整代码</a></p> 
<p id="3.1%E3%80%81contact.h-toc" style="margin-left:40px;"><a href="#3.1%E3%80%81contact.h" rel="nofollow">3.1、contact.h</a></p> 
<p id="3.2%E3%80%81contact.c%C2%A0-toc" style="margin-left:40px;"><a href="#3.2%E3%80%81contact.c%C2%A0" rel="nofollow">3.2、contact.c </a></p> 
<p id="3.3%E3%80%81test.c-toc" style="margin-left:40px;"><a href="#3.3%E3%80%81test.c" rel="nofollow">3.3、test.c</a></p> 
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p>前面接近四十弹内容基本都在学习C语言的基本语法，单纯的学习语法会让我们的学习比较枯燥，因此该节内容通过C语言学习的语法知识实现一个我们手机都有的通讯录功能。</p> 
<h2 id="1%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%86%E6%9E%90%E5%92%8C%E8%AE%BE%E8%AE%A1">1、通讯录分析和设计</h2> 
<h3 id="1.1%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E7%9A%84%E5%8A%9F%E8%83%BD%E8%AF%B4%E6%98%8E"><br> 1.1、通讯录的功能说明</h3> 
<blockquote> 
 <p>1、通讯录中包含个人的<span style="background-color:#fbd4d0;">姓名，性别，年龄，电话与地址。</span></p> 
 <p>2、用户可以<span style="background-color:#fbd4d0;">自由进出程序。</span></p> 
 <p>3、用户可以自由<span style="background-color:#fbd4d0;">增删查改以及排序通讯录中的数据。</span></p> 
</blockquote> 
<p>程序的界面：</p> 
<p><img alt="" height="199" src="https://images2.imgbox.com/e8/21/ZyFJVgOi_o.png" width="575"></p> 
<h3 id="1.2%20%E6%B8%B8%E6%88%8F%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E8%AE%BE%E8%AE%A1">1.2、程序的分析和设计</h3> 
<h4 id="1.2.1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%86%E6%9E%90"><br> 1.2.1、数据结构的分析</h4> 
<p><span style="color:#0d0016;">通讯录中存储的数据有姓名，性别，年龄，电话与地址，此处会用到字符串(字符串通过字符数组进行实现)，整型的结合，因此我们可以封装成一个结构体进行统一存储。根据通讯录功能的说明，我们需要对通讯录进行增删改查操作，<strong>如何才能确定需要操作的数据是哪一组呢？如何确定最终存储了多少组数据呢？</strong></span></p> 
<p><span style="color:#0d0016;">解决办法如下：</span></p> 
<p><span style="color:#0d0016;">1、再创建一个结构体，该结构体的内容包括</span><span style="color:#fe2c24;"><strong>存储数据的结构体</strong></span><span style="color:#0d0016;">和该结构体的</span><span style="color:#fe2c24;"><strong>最大存储个数</strong></span><span style="color:#0d0016;">(<strong>静态版本</strong>，创建静态数组)。</span></p> 
<p><span style="color:#0d0016;">2、再创建一个结构体，该结构体的内容包括</span><span style="color:#fe2c24;"><strong>存储数据的结构体</strong></span><span style="color:#0d0016;">、存储数据的结构体的</span><span style="color:#fe2c24;"><strong>实际存储个数</strong></span><span style="color:#0d0016;">以及存储数据的结构体的(</span><span style="color:#fe2c24;"><strong>容量</strong></span><span style="color:#0d0016;">)</span><span style="color:#fe2c24;"><strong>最大存储个数</strong></span><span style="color:#0d0016;">(<strong>动态版本</strong>，动态开辟数组)。</span></p> 
<p><span style="color:#0d0016;">知道数据的存储之后就是创建我们常用的菜单，即前面扫雷，猜数字游戏用到的菜单，通讯录也是同样的原理，用do while循环实现此菜单，根据上面程序的界面可以知道，我们需要实现接口函数较多，因此推荐<strong>使用switch选择语句</strong>，但是switch语句的类型需要整型，单纯我们整数去实现该函数不够通俗易懂，此处的解决办法有</span><span style="color:#fe2c24;"><strong>1、通过#define定义常量 2、使用枚举类型</strong></span><span style="color:#0d0016;">。</span></p> 
<p><span style="color:#0d0016;">如果<strong>使用#define定义常量</strong>，需要7处，<strong>代码也比较繁琐</strong>，但是如果此处<strong>使用枚举类型</strong>，可以定义一次即可(枚举类型不初始化第一个变量自动初始化为0，后面依次加+)，<strong>非常满足此处的需求</strong>。</span></p> 
<p><span style="color:#0d0016;">后面就是基本接口函数的实现了，在后面一一详细讲解。</span></p> 
<h4 id="1.2.2%E3%80%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><br> 1.2.2、文件结构设计</h4> 
<p><br><span style="color:#0d0016;">之前学习了多文件的形式对函数的声明和定义，这里我们实践⼀下，我们设计三个⽂件：</span></p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong><span style="background-color:#38d8f0;">test.c</span></strong> : <em>文件中写程序的测试逻辑</em></span></p> 
 <p><span style="color:#0d0016;"><strong><span style="background-color:#38d8f0;">Contact.c</span></strong> : <em>文件中写程序中函数的实现等</em></span></p> 
 <p><span style="color:#0d0016;"><strong><span style="background-color:#38d8f0;">Contact.h</span></strong> : <em>文</em><em>件中写程序需要的数据类型和函数声明等</em></span></p> 
</blockquote> 
<p></p> 
<p><span style="color:#fe2c24;">建议：写一些代码就测试一些代码。</span></p> 
<p></p> 
<h2 id="2%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90">2、通讯录的结构分析</h2> 
<h3 id="2.1%E3%80%81%E5%88%9B%E5%BB%BA%E9%80%9A%E8%AE%AF%E5%BD%95%E7%BB%93%E6%9E%84">2.1、创建通讯录结构</h3> 
<h4 id="2.1.1%E3%80%81%E9%9D%99%E6%80%81%E7%89%88%E6%9C%AC">2.1.1、静态版本</h4> 
<p>静态通讯录就是<span style="background-color:#fbd4d0;">在开辟空间时，给一个固定的大小</span>，<span style="background-color:#f9eda6;">缺陷</span>在于<span style="background-color:#f9eda6;">空间小了，不能扩容，空间大了，会造成浪费。</span></p> 
<pre><code>//常量使用#define宏定义，便于以后修改

#define NAME_MAX 20
#define SEX_MAX 5
#define TELE_MAX 13
#define ADDR_MAX 30

#define MAX 100  //通讯录大小，存放多少人的信息
//一个人的信息
typedef struct PeoInfo
{
	char name[NAME_MAX];
	int age;
	char sex[SEX_MAX];
	char tele[TELE_MAX];
	char addr[ADDR_MAX];
}PeoInfo;

//静态版本，通讯录的信息
typedef struct Contact
{
	PeoInfo data[MAX];
	int sz;
}Contact;</code></pre> 
<h4 id="2.1.2%E3%80%81%E5%8A%A8%E6%80%81%E7%89%88%E6%9C%AC">2.1.2、动态版本</h4> 
<p><span style="background-color:#fbd4d0;">动态通讯录</span>就是<span style="background-color:#fbd4d0;">对静态通讯录的缺陷进行改进</span>，<span style="background-color:#f9eda6;">通过动态内存管理来开辟空间，减少空间浪费的问题。</span></p> 
<pre><code>//常量使用#define宏定义，便于以后修改

#define NAME_MAX 20
#define SEX_MAX 5
#define TELE_MAX 13
#define ADDR_MAX 30

//一个人的信息
typedef struct PeoInfo
{
	char name[NAME_MAX];
	int age;
	char sex[SEX_MAX];
	char tele[TELE_MAX];
	char addr[ADDR_MAX];
}PeoInfo;

typedef struct Contact
{
	PeoInfo* data;
	int sz;
	int capacity;
}Contact;</code></pre> 
<p></p> 
<h3 id="2.1%E3%80%81%E7%94%A8%E6%88%B7%E9%80%89%E6%8B%A9">2.2、用户选择</h3> 
<p>首先用户选择需要的功能，输入<span style="background-color:#fbd4d0;">1则添加信息</span>，输入<span style="background-color:#fbd4d0;">2则删除信息</span>，输入<span style="background-color:#fbd4d0;">3则查询信息</span>，输入<span style="background-color:#fbd4d0;">4则修改信息</span>，输入<span style="background-color:#fbd4d0;">5则展示信息</span>，输入<span style="background-color:#fbd4d0;">6则排序信息</span>，输入<span style="background-color:#fbd4d0;">0则退出游戏</span>，<span style="background-color:#fbd4d0;">输入其他值则重新输入。</span></p> 
<p>从这可以知道此处为一个循环，而且一定会进入一次，符号do while的特性，因此<strong><span style="color:#0d0016;">使用do while循环</span></strong>，但是此处需要打印一个选项的界面，因此可以使用创建一个菜单。</p> 
<p><img alt="" height="532" src="https://images2.imgbox.com/c0/ab/MzCiSCKm_o.png" width="698"></p> 
<p><strong><span style="color:#fe2c24;">为了更好的表示switch中每个分支的意思，此处使用枚举变量来表示！！！ </span></strong></p> 
<p><strong><span style="color:#0d0016;">主体函数如下：</span></strong></p> 
<blockquote> 
 <p><strong><span style="color:#0d0016;">该结构中是包含文件版本的，在退出程序之前会保存联系人信息。</span></strong></p> 
</blockquote> 
<pre><code>void menu()
{
	printf("********************************************\n");
	printf("**********   1.add      2.del     **********\n");
	printf("**********   3.search   4.modify  **********\n");
	printf("**********   5.show     6.sort    **********\n");
	printf("**********   0.exit               **********\n");
	printf("********************************************\n");
}

//增强代码可读性，使用枚举变量
enum Option
{
	EXIT,//退出游戏，默认值为0
	ADD,//添加联系人信息
	DEL,//删除联系人信息
	SEARCH,//查找联系人信息
	MODIFY,//修改联系人信息
	SHOW,//打印联系人信息
	SORT//排序联系人信息
};

int main()
{
	int input = 0;
	Contact con;//创建通讯录,不初始化里面的值是随机值，我们需要将大小初始化为0
	//初始化通讯录
	InitContact(&amp;con);//形参不能修改实参，需要传地址
	do
	{
		menu();
		printf("请选择:&gt;\n");
		scanf("%d", &amp;input);
		switch (input)
		{
		case ADD:
			AddContact(&amp;con);
			break;
		case DEL:
			DelContact(&amp;con);
			break;
		case SEARCH:
			SearchContact(&amp;con);
			break;
		case MODIFY:
			ModifyContact(&amp;con);
			break;
		case SHOW:
			ShowContact(&amp;con);
			break;
		case SORT:
			SortContact(&amp;con);
			break;
		case EXIT:
			SaveContact(&amp;con);//保存联系人信息
			DestroyContact(&amp;con);//销毁通讯录
			printf("退出通讯录\n");
			break;
		default:
			printf("选择错误，请重新选择\n");
			break;
		}
	} while (input);
	return 0;
}</code></pre> 
<h3></h3> 
<p></p> 
<h3 id="2.3%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%80%9A%E8%AE%AF%E5%BD%95">2.3、初始化通讯录</h3> 
<p>通讯录初始化有三个版本，一个是<span style="background-color:#f9eda6;">静态数组的版本</span>，一个是<span style="background-color:#f9eda6;">动态数组的版本</span>，一个是<span style="background-color:#f9eda6;">动态数组加文件的版本</span>，因此操作可能有些许的差异，但是总体逻辑基本一致。</p> 
<h4 id="2.3.1%E3%80%81%E9%9D%99%E6%80%81%E9%80%9A%E8%AE%AF%E5%BD%95">2.3.1、静态通讯录</h4> 
<blockquote> 
 <p>使用内存设置函数<span style="background-color:#fbd4d0;">将通讯录的内容都设置为0。</span></p> 
</blockquote> 
<pre><code>//静态版本
void InitContact(Contact* pc)
{
	assert(pc);//需要对数据进行解引用，加assert断言
	pc-&gt;sz = 0;//将联系人个数初始化为0
	memset(pc-&gt;data, 0, sizeof(pc-&gt;data));//将整个存放信息的数组初始化为0
}</code></pre> 
<h4 id="2.3.2%E3%80%81%E5%8A%A8%E6%80%81%E9%80%9A%E8%AE%AF%E5%BD%95">2.3.2、动态通讯录</h4> 
<blockquote> 
 <p>先开辟3个空间，将大小初始化为0，容量初始化为3。</p> 
</blockquote> 
<pre><code>#define DEFAULT_SZ 3//初始化空间大小
//动态版本
void InitContact(Contact* pc)
{
	assert(pc);//需要对数据进行解引用，加assert断言
	pc-&gt;sz = 0;//将联系人个数初始化为0
	pc-&gt;capacity = DEFAULT_SZ;
	pc-&gt;data = (PeoInfo*)calloc(pc-&gt;capacity, sizeof(PeoInfo));
	if (pc-&gt;data == NULL)
	{
		perror("InitContact malloc");
		return;
	}
}</code></pre> 
<h4 id="2.3.3%E3%80%81%E5%8A%A8%E6%80%81%E6%96%87%E4%BB%B6%E9%80%9A%E8%AE%AF%E5%BD%95">2.3.3、动态文件通讯录</h4> 
<blockquote> 
 <p><span style="background-color:#fbd4d0;">动态文件通讯录</span>就是<span style="background-color:#f9eda6;">对动态通讯录不能保存数据进行优化</span>，在使用通讯录之前先从文件中导入数据，再进行通讯录操作。</p> 
</blockquote> 
<p><strong><span style="color:#fe2c24;">注意：文件版本因为需要导入数据，可能出现容量不够的情况，因此需要判断容量，因此需要在前面实现检查容量的函数。</span></strong></p> 
<p><span style="background-color:#38d8f0;">检查容量函数：</span></p> 
<pre><code>#define DEFAULT_INC 2 //一次增减两个容量
void Check_Capacity(Contact* pc)
{
	if (pc-&gt;sz == pc-&gt;capacity)
	{
		PeoInfo* ptr = (PeoInfo*)realloc(pc-&gt;data, (pc-&gt;capacity + DEFAULT_INC) * sizeof(PeoInfo));
		if (ptr != NULL)
		{
			pc-&gt;data = ptr;
			pc-&gt;capacity += DEFAULT_INC;
			printf("增容成功\n");
		}
		else
		{
			perror("AddContact-&gt;realloc");
			return;
		}
	}
}</code></pre> 
<p><span style="background-color:#38d8f0;">初始化函数： </span></p> 
<blockquote> 
 <p><span style="background-color:#fbd4d0;">使用fread读取文件信息</span>，<span style="background-color:#f9eda6;">一次读取一个，如果返回值为0，说明文件信息读取完毕</span>，退出循环即可。</p> 
</blockquote> 
<pre><code>void InitContact(Contact* pc)
{
	assert(pc);//需要对数据进行解引用，加assert断言
	pc-&gt;sz = 0;//将联系人个数初始化为0
	pc-&gt;capacity = DEFAULT_SZ;
	pc-&gt;data = (PeoInfo*)calloc(pc-&gt;capacity, sizeof(PeoInfo));
	if (pc-&gt;data == NULL)
	{
		perror("InitContact malloc");
		return;
	}
	//读取文件
	FILE* pf = fopen("contact.txt", "r");
	if (pf == NULL)
	{
		perror("InitContact");
		return;
	}
	PeoInfo tmp = { 0 };
	while (fread(&amp;tmp, sizeof(PeoInfo), 1, pf))//每次读取一个大小，返回值为0则结束读取
	{
		Check_Capacity(pc);
		pc-&gt;data[pc-&gt;sz] = tmp;
		pc-&gt;sz++;
	}
}</code></pre> 
<h3 id="2.4%E3%80%81%E6%B7%BB%E5%8A%A0%E8%81%94%E7%B3%BB%E4%BA%BA%E4%BF%A1%E6%81%AF">2.4、添加联系人信息</h3> 
<blockquote> 
 <p><span style="background-color:#fbd4d0;">添加联系人信息</span>即<span style="background-color:#f9eda6;">输入该联系人的相关信息</span>并<span style="background-color:#f9eda6;">将信息存放到通讯录中</span>，但是<span style="background-color:#98c091;">在添加信息之前需要检查容量是否充足。 </span></p> 
</blockquote> 
<pre><code>void AddContact(Contact* pc)
{
	assert(pc);
	printf("添加联系人信息\n");
	//容量满了需要增容
	Check_Capacity(pc);
	printf("请输入名字:\n");
	scanf("%s", pc-&gt;data[pc-&gt;sz].name);
	printf("请输入年龄:\n");
	scanf("%d", &amp;(pc-&gt;data[pc-&gt;sz].age));
	printf("请输入性别:\n");
	scanf("%s", pc-&gt;data[pc-&gt;sz].sex);
	printf("请输入电话:\n");
	scanf("%s", pc-&gt;data[pc-&gt;sz].tele);
	printf("请输入地址:\n");
	scanf("%s", pc-&gt;data[pc-&gt;sz].addr);

	pc-&gt;sz++;
	printf("增加成功\n");
}</code></pre> 
<h3 id="%C2%A02.5%E3%80%81%E6%89%93%E5%8D%B0%E8%81%94%E7%B3%BB%E4%BA%BA%E4%BF%A1%E6%81%AF">2.5、打印联系人信息</h3> 
<p>为了测试添加联系人信息是否添加成功，因此先实现一个打印信息的函数，也为后面测试做铺垫。</p> 
<p>为了打印出来的信息更加美观，博主在打印之前<span style="background-color:#fbd4d0;">按照占位符对其数据进行打印</span>，uu们也可以按照自己的喜好设置。</p> 
<blockquote> 
 <p>遍历整个通讯录，依次打印通讯录中的信息。</p> 
</blockquote> 
<pre><code>void ShowContact(const Contact* pc)
{
	assert(pc);
	printf("打印联系人信息\n");
	//判断是否有联系人
	if (pc-&gt;sz == 0)
	{
		printf("无联系人，无需打印\n");
		return;
	}
	printf("%-15s%-5s%-5s%-13s%-20s\n", "名字", "年龄", "性别", "电话", "地址");
	int i = 0;
	for (i = 0; i &lt; pc-&gt;sz; i++)
	{
		printf("%-15s%-5d%-5s%-13s%-20s\n",
			pc-&gt;data[i].name, pc-&gt;data[i].age, pc-&gt;data[i].sex, pc-&gt;data[i].tele, pc-&gt;data[i].addr);
	}
}</code></pre> 
<h3 id="%C2%A02.6%E3%80%81%E5%88%A0%E9%99%A4%E8%81%94%E7%B3%BB%E4%BA%BA">2.6、删除联系人</h3> 
<p>博主实现的是<span style="background-color:#fbd4d0;">通过名字搜索来查找删除的联系人</span>，uu们可以按照自己的需要设计其他的查找函数喔，因为<span style="background-color:#d4e9d5;">查找函数只需要在contact.c文件中使用</span>，因此博主<span style="background-color:#f9eda6;">将查找函数加了static修饰，只能在该文件使用此函数。</span></p> 
<p><span style="background-color:#38d8f0;">按照名字查找函数：</span></p> 
<blockquote> 
 <p>找到则返回下标，没找到返回-1.</p> 
 <p></p> 
</blockquote> 
<pre><code>static int FindByName(const Contact* pc, char name[])//static修饰，只在该文件中使用
{
	int i = 0;
	for (i = 0; i &lt; pc-&gt;sz; i++) 
	{
		if ((strcmp(pc-&gt;data[i].name, name)) == 0)
		{
			return i;
		}
	}
	return -1;//没有找到
}</code></pre> 
<p><span style="background-color:#38d8f0;">删除联系人函数 </span></p> 
<blockquote> 
 <p><span style="background-color:#fbd4d0;">删除联系人信息之前判断通讯录中是否有数据</span>，如果<span style="background-color:#f9eda6;">没有数据则给出提示</span>，如果<span style="background-color:#f9eda6;">有数据再进行查找删除操作。</span></p> 
</blockquote> 
<pre><code>void DelContact(Contact* pc)
{
	char name[NAME_MAX];
	assert(pc);
	printf("删除联系人信息\n");
	if (pc-&gt;sz == 0)
	{
		printf("无联系人，无需删除\n");
		return;
	}
	//删除谁的信息，使用名字查找
	printf("请输入要删除联系人的名字\n");
	scanf("%s", name);
	int ret = FindByName(pc, name);
	if (ret == -1)
	{
		printf("没有该联系人，无需删除\n");
		return;
	}
	//删除信息 把后面一个人的信息赋值给前面一个人
	int i = 0;
	for (i = ret; i &lt; pc-&gt;sz - 1; i++)
	{
		pc-&gt;data[i] = pc-&gt;data[i + 1];
	}
	pc-&gt;sz--;
	printf("删除成功\n");
}</code></pre> 
<h3 id="2.7%E3%80%81%20%E6%9F%A5%E6%89%BE%E8%81%94%E7%B3%BB%E4%BA%BA">2.7、 查找联系人</h3> 
<blockquote> 
 <p>通过<span style="background-color:#fbd4d0;">输入名字查找联系人</span>，<span style="background-color:#f9eda6;">没有找到则给出提示</span>，<span style="background-color:#fbd4d0;">找到则打印该联系人的相关信息</span>。(uu们也可以设计其他的查找方式喔！！！)</p> 
</blockquote> 
<pre><code>void SearchContact(const Contact* pc)
{
	char name[NAME_MAX];
	assert(pc);
	printf("查找联系人信息\n");
	printf("请输入要查找联系人的名字\n");
	scanf("%s", name);
	int ret = FindByName(pc, name);
	if (ret == -1)
	{
		printf("没有该联系人\n");
		return;
	}
	//打印该联系人信息
	printf("%-15s%-5s%-5s%-13s%-20s\n", "名字", "年龄", "性别", "电话", "地址");
	printf("%-15s%-5d%-5s%-13s%-20s\n",
		pc-&gt;data[ret].name, pc-&gt;data[ret].age, pc-&gt;data[ret].sex, pc-&gt;data[ret].tele, pc-&gt;data[ret].addr);
}</code></pre> 
<h3 id="2.8%E3%80%81%E4%BF%AE%E6%94%B9%E8%81%94%E7%B3%BB%E4%BA%BA">2.8、修改联系人</h3> 
<blockquote> 
 <p>通过<span style="background-color:#fbd4d0;">输入名字查找联系人</span>，<span style="background-color:#f9eda6;">没有找到则给出提示</span>，<span style="background-color:#fbd4d0;">找到则修改该联系人的相关信息</span>。</p> 
</blockquote> 
<pre><code>void ModifyContact(Contact* pc)
{
	char name[NAME_MAX];
	assert(pc);
	printf("修改联系人信息\n");
	printf("请输入要修改联系人的名字\n");
	scanf("%s", name);
	int ret = FindByName(pc, name);
	if (ret == -1)
	{
		printf("没有该联系人\n");
		return;
	}
	printf("请输入名字:\n");
	scanf("%s", pc-&gt;data[ret].name);
	printf("请输入年龄:\n");
	scanf("%d", &amp;(pc-&gt;data[ret].age));
	printf("请输入性别:\n");
	scanf("%s", pc-&gt;data[ret].sex);
	printf("请输入电话:\n");
	scanf("%s", pc-&gt;data[ret].tele);
	printf("请输入地址:\n");
	scanf("%s", pc-&gt;data[ret].addr);

	printf("修改成功\n");
}</code></pre> 
<h3 id="2.9%E3%80%81%E6%8E%92%E5%BA%8F%E8%81%94%E7%B3%BB%E4%BA%BA%E4%BF%A1%E6%81%AF">2.9、排序联系人信息</h3> 
<p><span style="background-color:#38d8f0;">排序方式函数：</span></p> 
<blockquote> 
 <p>此处<span style="background-color:#fbd4d0;">实现的函数均为升序函数</span>，包含所以成员变量的升序。</p> 
</blockquote> 
<pre><code>int cmp_by_name(const void* e1, const void* e2)
{
	return strcmp(((PeoInfo*)e1)-&gt;name, ((PeoInfo*)e2)-&gt;name);
}
int cmp_by_age(const void* e1, const void* e2)
{
	return ((PeoInfo*)e1)-&gt;age - ((PeoInfo*)e2)-&gt;age;
}
int cmp_by_sex(const void* e1, const void* e2)
{
	return strcmp(((PeoInfo*)e1)-&gt;sex, ((PeoInfo*)e2)-&gt;sex);
}
int cmp_by_tele(const void* e1, const void* e2)
{
	return strcmp(((PeoInfo*)e1)-&gt;tele, ((PeoInfo*)e2)-&gt;tele);
}
int cmp_by_addr(const void* e1, const void* e2)
{
	return strcmp(((PeoInfo*)e1)-&gt;addr, ((PeoInfo*)e2)-&gt;addr);
}

void SortByName(Contact* pc)
{
	qsort(pc-&gt;data, pc-&gt;sz, sizeof(PeoInfo), cmp_by_name);
}
void SortByAge(Contact* pc)
{
	qsort(pc-&gt;data, pc-&gt;sz, sizeof(PeoInfo), cmp_by_age);
}
void SortBySex(Contact* pc)
{
	qsort(pc-&gt;data, pc-&gt;sz, sizeof(PeoInfo), cmp_by_sex);
}
void SortByTele(Contact* pc)
{
	qsort(pc-&gt;data, pc-&gt;sz, sizeof(PeoInfo), cmp_by_tele);
}
void SortByAddr(Contact* pc)
{
	qsort(pc-&gt;data, pc-&gt;sz, sizeof(PeoInfo), cmp_by_addr);
}</code></pre> 
<p><span style="background-color:#38d8f0;">排序联系人函数</span></p> 
<blockquote> 
 <p>输入想要进行排序的方式，输入错误会提示重新输入。</p> 
</blockquote> 
<pre><code>void SortContact(Contact* pc)
{
	assert(pc);
	char input[20];
	printf("排序联系人信息\n");
	printf("请选择如何进行排序，选择有名字，年龄，性别，电话，地址！\n");
	while (1)
	{
		scanf("%s", input);
		if (strcmp(input, "名字") == 0)
		{
			printf("按照姓名升序\n");
			SortByName(pc);
			ShowContact(pc);
			break;
		}
		else if (strcmp(input, "年龄") == 0)
		{
			printf("按照年龄升序\n");
			SortByAge(pc);
			ShowContact(pc);
			break;
		}
		else if (strcmp(input, "性别") == 0)
		{
			printf("按照性别升序\n");
			SortBySex(pc);
			ShowContact(pc);
		}
		else if (strcmp(input, "电话") == 0)
		{
			printf("按照电话升序\n");
			SortByTele(pc);
			ShowContact(pc);
			break;
		}
		else if (strcmp(input, "地址") == 0)
		{
			printf("按照地址升序\n");
			SortByTele(pc);
			ShowContact(pc);
			break;
		}
		else
		{
			printf("输入错误，请重新选择\n");
		}
	}
}</code></pre> 
<h3 id="%C2%A02.10%E3%80%81%E5%AD%98%E5%82%A8%E8%81%94%E7%B3%BB%E4%BA%BA%E4%BF%A1%E6%81%AF%E5%88%B0%E6%96%87%E4%BB%B6"> 2.10、存储联系人信息到文件</h3> 
<p><span style="background-color:#38d8f0;">数据写入文件函数</span></p> 
<blockquote> 
 <p><span style="background-color:#fbd4d0;">使用fwrite函数依次将数据写入到文件中。</span></p> 
</blockquote> 
<pre><code>void SaveContact(Contact* pc)
{
	//将通讯录信息写入到文件中
	FILE* pf = fopen("contact.txt", "wb");
	if (pf == NULL)
	{
		perror("SaveContact");
		return;
	}
	//一个信息一个信息写入
	int i = 0;
	for (i = 0; i &lt; pc-&gt;sz; i++)
	{
		//fwrite(&amp;(pc-&gt;data[i]), sizeof(PeoInfo), 1, pf);
		fwrite(pc-&gt;data + i, sizeof(PeoInfo), 1, pf);
	}

	fclose(pf);
	pf = NULL;
}
</code></pre> 
<h3 id="2.11%E3%80%81%E9%94%80%E6%AF%81%E9%80%9A%E8%AE%AF%E5%BD%95">2.11、销毁通讯录</h3> 
<p>动态版本通讯录才需要销毁通讯录。</p> 
<blockquote> 
 <p><span style="background-color:#fbd4d0;">释放动态开辟的内存空间，并将大小个容量初始化为0.</span></p> 
</blockquote> 
<pre><code>void DestroyContact(Contact* pc)
{
	free(pc-&gt;data);
	pc-&gt;data = NULL;
	pc-&gt;sz = 0;
	pc-&gt;capacity = 0;
}</code></pre> 
<h2 id="3%E3%80%81%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">3、完整代码</h2> 
<h3 id="3.1%E3%80%81contact.h">3.1、contact.h</h3> 
<pre><code>#pragma once
#include&lt;stdio.h&gt;
#include&lt;assert.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;

//常量使用#define宏定义，便于以后修改
#define NAME_MAX 20
#define SEX_MAX 5
#define TELE_MAX 13
#define ADDR_MAX 30

#define MAX 100  //通讯录大小，存放多少人的信息

#define DEFAULT_SZ 3
#define DEFAULT_INC 2


typedef struct PeoInfo
{
	char name[NAME_MAX];
	int age;
	char sex[SEX_MAX];
	char tele[TELE_MAX];
	char addr[ADDR_MAX];
}PeoInfo;

//静态版本
//typedef struct Contact
//{
//	PeoInfo data[MAX];
//	int sz;
//}Contact;


typedef struct Contact
{
	PeoInfo* data;
	int sz;
	int capacity;
}Contact;


//初始化通讯录
void InitContact(Contact* pc);
//增加联系人
void AddContact(Contact* pc);
//显示所有联系人信息
void ShowContact(const Contact* pc);//不会修改值，可以加const
//删除指定联系人
void DelContact(Contact* pc);
//查找指定联系人
void SearchContact(const Contact* pc);
//修改指定联系人
void ModifyContact(Contact* pc);
//排序通讯录
void SortContact(Contact* pc);
//销毁通讯录
void DestroyContact(Contact* pc);
//将通讯录信息写入到文件中
void SaveContact(Contact* pc);</code></pre> 
<h3 id="3.2%E3%80%81contact.c%C2%A0">3.2、contact.c </h3> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS 1

#include "contact.h"

//静态版本
//void InitContact(Contact* pc)
//{
//	assert(pc);//需要对数据进行解引用，加assert断言
//	pc-&gt;sz = 0;//将联系人个数初始化为0
//	memset(pc-&gt;data, 0, sizeof(pc-&gt;data));//将整个存放信息的数组初始化为0
//}

//动态版本
//void InitContact(Contact* pc)
//{
//	assert(pc);//需要对数据进行解引用，加assert断言
//	pc-&gt;sz = 0;//将联系人个数初始化为0
//	pc-&gt;capacity = DEFAULT_SZ;
//	pc-&gt;data = (PeoInfo*)calloc(pc-&gt;capacity, sizeof(PeoInfo));
//	if (pc-&gt;data == NULL)
//	{
//		perror("InitContact malloc");
//		return;
//	}
//}

void Check_Capacity(Contact* pc);

//文件版本
void InitContact(Contact* pc)
{
	assert(pc);//需要对数据进行解引用，加assert断言
	pc-&gt;sz = 0;//将联系人个数初始化为0
	pc-&gt;capacity = DEFAULT_SZ;
	pc-&gt;data = (PeoInfo*)calloc(pc-&gt;capacity, sizeof(PeoInfo));
	if (pc-&gt;data == NULL)
	{
		perror("InitContact malloc");
		return;
	}
	//读取文件
	FILE* pf = fopen("contact.txt", "r");
	if (pf == NULL)
	{
		perror("InitContact");
		return;
	}
	PeoInfo tmp = { 0 };
	while (fread(&amp;tmp, sizeof(PeoInfo), 1, pf))//每次读取一个大小，返回值为0则结束读取
	{
		Check_Capacity(pc);
		pc-&gt;data[pc-&gt;sz] = tmp;
		pc-&gt;sz++;
	}
}

void DestroyContact(Contact* pc)
{
	free(pc-&gt;data);
	pc-&gt;data = NULL;
	pc-&gt;sz = 0;
	pc-&gt;capacity = 0;
}


//静态版本
//void AddContact(Contact* pc)
//{
//	assert(pc);
//	//判断通讯录是否满了
//	if (pc-&gt;sz == MAX)
//	{
//		printf("通讯录已满，不能添加联系人\n");
//		return;
//	}
//	printf("请输入名字:\n");
//	scanf("%s", pc-&gt;data[pc-&gt;sz].name);
//	printf("请输入年龄:\n");
//	scanf("%d", &amp;(pc-&gt;data[pc-&gt;sz].age));
//	printf("请输入性别:\n");
//	scanf("%s", pc-&gt;data[pc-&gt;sz].sex);
//	printf("请输入电话:\n");
//	scanf("%s", pc-&gt;data[pc-&gt;sz].tele);
//	printf("请输入地址:\n");
//	scanf("%s", pc-&gt;data[pc-&gt;sz].addr);
//
//	pc-&gt;sz++;
//	printf("增加成功\n");
//}

void Check_Capacity(Contact* pc)
{
	if (pc-&gt;sz == pc-&gt;capacity)
	{
		PeoInfo* ptr = (PeoInfo*)realloc(pc-&gt;data, (pc-&gt;capacity + DEFAULT_INC) * sizeof(PeoInfo));
		if (ptr != NULL)
		{
			pc-&gt;data = ptr;
			pc-&gt;capacity += DEFAULT_INC;
			printf("增容成功\n");
		}
		else
		{
			perror("AddContact-&gt;realloc");
			return;
		}
	}
}
void AddContact(Contact* pc)
{
	assert(pc);
	printf("添加联系人信息\n");
	//容量满了需要增容
	Check_Capacity(pc);
	printf("请输入名字:\n");
	scanf("%s", pc-&gt;data[pc-&gt;sz].name);
	printf("请输入年龄:\n");
	scanf("%d", &amp;(pc-&gt;data[pc-&gt;sz].age));
	printf("请输入性别:\n");
	scanf("%s", pc-&gt;data[pc-&gt;sz].sex);
	printf("请输入电话:\n");
	scanf("%s", pc-&gt;data[pc-&gt;sz].tele);
	printf("请输入地址:\n");
	scanf("%s", pc-&gt;data[pc-&gt;sz].addr);

	pc-&gt;sz++;
	printf("增加成功\n");
}

void ShowContact(const Contact* pc)
{
	assert(pc);
	printf("打印联系人信息\n");
	//判断是否有联系人
	if (pc-&gt;sz == 0)
	{
		printf("无联系人，无需打印\n");
		return;
	}
	printf("%-15s%-5s%-5s%-13s%-20s\n", "名字", "年龄", "性别", "电话", "地址");
	int i = 0;
	for (i = 0; i &lt; pc-&gt;sz; i++)
	{
		printf("%-15s%-5d%-5s%-13s%-20s\n",
			pc-&gt;data[i].name, pc-&gt;data[i].age, pc-&gt;data[i].sex, pc-&gt;data[i].tele, pc-&gt;data[i].addr);
	}
}

static int FindByName(const Contact* pc, char name[])//static修饰，只在该文件中使用
{
	int i = 0;
	for (i = 0; i &lt; pc-&gt;sz; i++) 
	{
		if ((strcmp(pc-&gt;data[i].name, name)) == 0)
		{
			return i;
		}
	}
	return -1;//没有找到
}
void DelContact(Contact* pc)
{
	char name[NAME_MAX];
	assert(pc);
	printf("删除联系人信息\n");
	if (pc-&gt;sz == 0)
	{
		printf("无联系人，无需删除\n");
		return;
	}
	//删除谁的信息，使用名字查找
	printf("请输入要删除联系人的名字\n");
	scanf("%s", name);
	int ret = FindByName(pc, name);
	if (ret == -1)
	{
		printf("没有该联系人，无需删除\n");
		return;
	}
	//删除信息 把后面一个人的信息赋值给前面一个人
	int i = 0;
	for (i = ret; i &lt; pc-&gt;sz - 1; i++)
	{
		pc-&gt;data[i] = pc-&gt;data[i + 1];
	}
	pc-&gt;sz--;
	printf("删除成功\n");
}


void SearchContact(const Contact* pc)
{
	char name[NAME_MAX];
	assert(pc);
	printf("查找联系人信息\n");
	printf("请输入要查找联系人的名字\n");
	scanf("%s", name);
	int ret = FindByName(pc, name);
	if (ret == -1)
	{
		printf("没有该联系人\n");
		return;
	}
	//打印该联系人信息
	printf("%-15s%-5s%-5s%-13s%-20s\n", "名字", "年龄", "性别", "电话", "地址");
	printf("%-15s%-5d%-5s%-13s%-20s\n",
		pc-&gt;data[ret].name, pc-&gt;data[ret].age, pc-&gt;data[ret].sex, pc-&gt;data[ret].tele, pc-&gt;data[ret].addr);
}

void ModifyContact(Contact* pc)
{
	char name[NAME_MAX];
	assert(pc);
	printf("修改联系人信息\n");
	printf("请输入要修改联系人的名字\n");
	scanf("%s", name);
	int ret = FindByName(pc, name);
	if (ret == -1)
	{
		printf("没有该联系人\n");
		return;
	}
	printf("请输入名字:\n");
	scanf("%s", pc-&gt;data[ret].name);
	printf("请输入年龄:\n");
	scanf("%d", &amp;(pc-&gt;data[ret].age));
	printf("请输入性别:\n");
	scanf("%s", pc-&gt;data[ret].sex);
	printf("请输入电话:\n");
	scanf("%s", pc-&gt;data[ret].tele);
	printf("请输入地址:\n");
	scanf("%s", pc-&gt;data[ret].addr);

	printf("修改成功\n");
}

int cmp_by_name(const void* e1, const void* e2)
{
	return strcmp(((PeoInfo*)e1)-&gt;name, ((PeoInfo*)e2)-&gt;name);
}
int cmp_by_age(const void* e1, const void* e2)
{
	return ((PeoInfo*)e1)-&gt;age - ((PeoInfo*)e2)-&gt;age;
}
int cmp_by_sex(const void* e1, const void* e2)
{
	return strcmp(((PeoInfo*)e1)-&gt;sex, ((PeoInfo*)e2)-&gt;sex);
}
int cmp_by_tele(const void* e1, const void* e2)
{
	return strcmp(((PeoInfo*)e1)-&gt;tele, ((PeoInfo*)e2)-&gt;tele);
}
int cmp_by_addr(const void* e1, const void* e2)
{
	return strcmp(((PeoInfo*)e1)-&gt;addr, ((PeoInfo*)e2)-&gt;addr);
}

void SortByName(Contact* pc)
{
	qsort(pc-&gt;data, pc-&gt;sz, sizeof(PeoInfo), cmp_by_name);
}
void SortByAge(Contact* pc)
{
	qsort(pc-&gt;data, pc-&gt;sz, sizeof(PeoInfo), cmp_by_age);
}
void SortBySex(Contact* pc)
{
	qsort(pc-&gt;data, pc-&gt;sz, sizeof(PeoInfo), cmp_by_sex);
}
void SortByTele(Contact* pc)
{
	qsort(pc-&gt;data, pc-&gt;sz, sizeof(PeoInfo), cmp_by_tele);
}
void SortByAddr(Contact* pc)
{
	qsort(pc-&gt;data, pc-&gt;sz, sizeof(PeoInfo), cmp_by_addr);
}

void SortContact(Contact* pc)
{
	assert(pc);
	char input[20];
	printf("排序联系人信息\n");
	printf("请选择如何进行排序，选择有名字，年龄，性别，电话，地址！\n");
	while (1)
	{
		scanf("%s", input);
		if (strcmp(input, "名字") == 0)
		{
			printf("按照姓名升序\n");
			SortByName(pc);
			ShowContact(pc);
			break;
		}
		else if (strcmp(input, "年龄") == 0)
		{
			printf("按照年龄升序\n");
			SortByAge(pc);
			ShowContact(pc);
			break;
		}
		else if (strcmp(input, "性别") == 0)
		{
			printf("按照性别升序\n");
			SortBySex(pc);
			ShowContact(pc);
		}
		else if (strcmp(input, "电话") == 0)
		{
			printf("按照电话升序\n");
			SortByTele(pc);
			ShowContact(pc);
			break;
		}
		else if (strcmp(input, "地址") == 0)
		{
			printf("按照地址升序\n");
			SortByTele(pc);
			ShowContact(pc);
			break;
		}
		else
		{
			printf("输入错误，请重新选择\n");
		}
	}
}

void SaveContact(Contact* pc)
{
	//将通讯录信息写入到文件中
	FILE* pf = fopen("contact.txt", "wb");
	if (pf == NULL)
	{
		perror("SaveContact");
		return;
	}
	//一个信息一个信息写入
	int i = 0;
	for (i = 0; i &lt; pc-&gt;sz; i++)
	{
		//fwrite(&amp;(pc-&gt;data[i]), sizeof(PeoInfo), 1, pf);
		fwrite(pc-&gt;data + i, sizeof(PeoInfo), 1, pf);
	}

	fclose(pf);
	pf = NULL;
}
</code></pre> 
<h3 id="3.3%E3%80%81test.c">3.3、test.c</h3> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS 1

#include "contact.h"
void menu()
{
	printf("********************************************\n");
	printf("**********   1.add      2.del     **********\n");
	printf("**********   3.search   4.modify  **********\n");
	printf("**********   5.show     6.sort    **********\n");
	printf("**********   0.exit               **********\n");
	printf("********************************************\n");
}

//增强代码可读性，使用枚举变量
enum Option
{
	EXIT,//退出游戏，默认值为0
	ADD,//添加联系人信息
	DEL,//删除联系人信息
	SEARCH,//查找联系人信息
	MODIFY,//修改联系人信息
	SHOW,//打印联系人信息
	SORT//排序联系人信息
};

int main()
{
	int input = 0;
	Contact con;//创建通讯录,不初始化里面的值是随机值，我们需要将大小初始化为0
	//初始化通讯录
	InitContact(&amp;con);//形参不能修改实参，需要传地址
	do
	{
		menu();
		printf("请选择:&gt;\n");
		scanf("%d", &amp;input);
		switch (input)
		{
		case ADD:
			AddContact(&amp;con);
			break;
		case DEL:
			DelContact(&amp;con);
			break;
		case SEARCH:
			SearchContact(&amp;con);
			break;
		case MODIFY:
			ModifyContact(&amp;con);
			break;
		case SHOW:
			ShowContact(&amp;con);
			break;
		case SORT:
			SortContact(&amp;con);
			break;
		case EXIT:
			SaveContact(&amp;con);
			DestroyContact(&amp;con);
			printf("退出通讯录\n");
			break;
		default:
			printf("选择错误，请重新选择\n");
			break;
		}
	} while (input);
	return 0;
}</code></pre> 
<h2 id="%E6%80%BB%E7%BB%93">总结</h2> 
<p>本篇博客就结束啦，谢谢大家的观看，如果公主少年们有好的建议可以留言喔，谢谢大家啦！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a690f48d60ae2e8c9395a6891be61299/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">气象数据NC、grb2解析成矢量json、CMIS、MICPS及图片应用到webgis</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3ebd3a45b4a210c6b575c3281930f1ee/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AI从业者怎么做Science？清华大学AIR周浩：从文本生成到蛋白质设计的跨界探索</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>