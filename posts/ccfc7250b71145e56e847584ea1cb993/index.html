<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vue自我总结面试 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ccfc7250b71145e56e847584ea1cb993/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Vue自我总结面试">
  <meta property="og:description" content="1.vue-router中有哪些模式？有什么区别？ Vue Router 提供了三种路由模式：‌Hash 模式、‌History 模式和 Abstract 模式。‌
Hash 模式（默认）：
URL中带有 # ，兼容较老的浏览器。例如：http://xxxx.com/#/path。当 URL 的哈希值发生变化时，浏览器不会向服务器发送请求，而是通过监听 hashchange 事件来进行路由导航。 History 模式：
使用 HTML5 的 History API 来管理路由。可使用正常的 URL 地址。例如：http://xxxx.com/path。通过pushState方法&#43;popstate事件来实现的，监听popstate事件是为了响应浏览器的前进后退功能。当 URL 发生变化时，浏览器会向服务器发送请求，服务器需要配置相应的路由规则，以确保在刷新页面或直接访问 URL 时能正确响应路由。 history模式开发的SPA项目，需要服务器端做额外的配置，否则会出现刷新白屏（链接分享失效）。原因是页面刷新时，浏览器会向服务器真的发出对这个地址的请求，而这个文件资源又不存在，所以就报404。处理方式就由后端做一个保底映射:所有的请求全部拦截到index.html上。这样的话，后端就无法判断404了，前端就需要在路由最后自己增加一个匹配‘*’，匹配所有其他路由，自定义自己的notFound.vue组件。
Abstract 模式：
主要用于非浏览器环境，比如在服务器端渲染（Server-Side Rendering）时使用。Vue Router 不会对 URL 进行任何处理，而是将路由信息保存在内存中，需要手动管理路由的变化 动态路由：动态路由允许你在运行时根据不同的条件添加或删除路由。方法：addRoute和removeRoute。这种灵活性对于构建复杂的单页应用尤为重要，尤其是在需要根据不同用户角色或权限动态显示或隐藏路由的情况下。
例如：.在导航守卫中添加路由后，如果立即导航到新添加的路由，需要使用 next 函数的参数来指定新路由：
router.beforeEach((to, from, next) =&gt; { // 添加路由逻辑 router.addRoute(&#39;newRoute&#39;, { path: &#39;/new-path&#39;, component: () =&gt; import(&#39;@/components/NewComponent.vue&#39;) }); // 如果目标路由是新添加的路由，则直接导航到新路由 if (to.path === &#39;/new-path&#39;) { next({ ...to, name: &#39;newRoute&#39; }); } else { next(); } }); 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-15T22:15:00+08:00">
    <meta property="article:modified_time" content="2024-08-15T22:15:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vue自我总结面试</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4><span style="color:#4da8ee;"><strong>1.vue-router中有哪些模式？有什么区别？</strong></span></h4> 
<p><strong>Vue Router 提供了三种路由模式：‌Hash 模式、‌History 模式和 Abstract 模式。‌</strong></p> 
<p><strong>Hash 模式（默认）：</strong></p> 
<ul><li>URL中带有 # ，兼容较老的浏览器。例如：<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Flinks.jianshu.com%2Fgo%3Fto%3Dhttp%253A%252F%252Fxxxx.com%252F%2523%252Fpath&amp;source=article&amp;objectId=2322580" rel="nofollow" title="http://xxxx.com/#/path">http://xxxx.com/#/path</a>。</li><li>当 URL 的哈希值发生变化时，浏览器不会向<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&amp;from=20065" rel="nofollow" title="服务器">服务器</a>发送请求，而是通过监听 hashchange 事件来进行路由导航。</li></ul> 
<p><strong>History 模式：</strong></p> 
<ul><li>使用 HTML5 的 History API 来管理路由。可使用正常的 URL 地址。例如：<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Flinks.jianshu.com%2Fgo%3Fto%3Dhttp%253A%252F%252Fxxxx.com%252Fpath&amp;source=article&amp;objectId=2322580" rel="nofollow" title="http://xxxx.com/path">http://xxxx.com/path</a>。</li><li>通过pushState方法+popstate事件来实现的，监听popstate事件是为了响应浏览器的前进后退功能。</li><li>当 URL 发生变化时，浏览器会向服务器发送请求，服务器需要配置相应的路由规则，以确保在刷新页面或直接访问 URL 时能正确响应路由。</li></ul> 
<p><span style="color:#ff9900;">history模式开发的SPA项目，需要服务器端做额外的配置，否则会出现刷新白屏（链接分享失效）。原因是页面刷新时，浏览器会向服务器真的发出对这个地址的请求，而这个文件资源又不存在，所以就报404。处理方式就由后端做一个保底映射:所有的请求全部拦截到index.html上。</span>这样的话，后端就无法判断404了，前端就需要在路由最后自己增加一个匹配‘*’，匹配所有其他路由，自定义自己的notFound.vue组件。</p> 
<p><strong>Abstract 模式：</strong></p> 
<ul><li>主要用于非浏览器环境，比如在服务器端渲染（Server-Side Rendering）时使用。</li><li>Vue Router 不会对 URL 进行任何处理，而是将路由信息保存在内存中，需要手动管理路由的变化</li></ul> 
<p><span style="color:#fe2c24;">动态路由：</span>动态路由允许你在运行时根据不同的条件添加或删除路由。方法：addRoute和removeRoute。这种灵活性对于构建复杂的单页应用尤为重要，尤其是在需要根据不同用户角色或权限动态显示或隐藏路由的情况下。</p> 
<p>例如：.在导航守卫中添加路由后，如果立即导航到新添加的路由，需要使用 next 函数的参数来指定新路由：</p> 
<pre><code>router.beforeEach((to, from, next) =&gt; {
  // 添加路由逻辑
  router.addRoute('newRoute', {
    path: '/new-path',
    component: () =&gt; import('@/components/NewComponent.vue')
  });
  // 如果目标路由是新添加的路由，则直接导航到新路由
  if (to.path === '/new-path') {
    next({ ...to, name: 'newRoute' });
  } else {
    next();
  }
});
</code></pre> 
<h4><span style="color:#4da8ee;"><strong>2.vue中，props与data优先级</strong></span></h4> 
<p>props &gt; methods &gt; data &gt; computed &gt; watch</p> 
<h4><span style="color:#4da8ee;"><strong>3.vue中，v-for 和 v-if 优先级？可以一起用吗？</strong></span></h4> 
<p>Vue 2.x版本中，‌v-for 的优先级高于v-if，所以每次执行v-for都会执行v-if，一起使用会浪费性能，不建议同时使用。</p> 
<p>解决方法：v-if 写在 v-for 的前面一层。</p> 
<p>Vue 3.x版本中，‌v-if 的优先级高于 v-for，不推荐同时使用</p> 
<h4><span style="color:#4da8ee;"><strong>3.第一次页面记载会触发哪些钩子？第二次/第n次会触发哪些钩子？刷新页面会触发哪些钩子？</strong></span></h4> 
<p>第一次：beforeCreate,  created,  beforeMount,  mounted</p> 
<p>如果加入<code>&lt;keep-alive&gt;，会执行：</code>beforeCreate,  created,  beforeMount,  mounted，activated</p> 
<p>第2/n次：如果使用的是<code>&lt;keep-alive&gt;</code>组件来缓存组件状态。只会触发activated钩子，</p> 
<p>              如果没有，beforeCreate,  created,  beforeMount,  mounted</p> 
<p>刷新页面：beforeCreate,  created,  beforeMount,  mounted？验证一下</p> 
<p><strong><span style="color:#4da8ee;">4.对象的深拷贝有哪些？</span></strong></p> 
<p>1. ‌<strong>JSON序列化</strong>‌</p> 
<p>通过<code>JSON.stringify()</code>将对象转换为字符串，‌然后再用<code>JSON.parse()</code>将其转回对象，但有其局限性，‌例如无法处理函数、‌<code>undefined</code>、‌<code>Symbol</code>等类型的数据</p> 
<p>2.使用第三方库：lodash库提供的<code>cloneDeep()</code>方法</p> 
<p>3.<strong>利用循环和递归的方式</strong></p> 
<pre><code class="hljs">    function deepClone(obj) {
        //判断拷贝的要进行深拷贝的是数组还是对象，是数组的话进行数组拷贝，对象的话进行对象拷贝
        var objClone = Array.isArray(obj) ? [] : {};
        //进行深拷贝的不能为空，并且是对象或者是数组
        if (obj &amp;&amp; typeof obj === "object") {
            for (let key in obj) {
                if (obj.hasOwnProperty(key)) {
                    if (obj[key] &amp;&amp; typeof obj[key] === "object") {
                        objClone[key] = deepClone(obj[key]);
                    } else {
                        objClone[key] = obj[key];
                    }
                }
            }
        }
        return objClone;
    }
</code></pre> 
<p><strong><span style="color:#4da8ee;">5.import和export的区别？</span></strong></p> 
<p></p> 
<p> </p> 
<p><strong><span style="color:#4da8ee;">6.vue中data是什么类型？数据是怎么双向绑定的？this.name怎么可以获取到data里的数据？</span></strong></p> 
<p>data是一个函数，原因：</p> 
<p>数据</p> 
<p>7.</p> 
<p>         </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/45e512b2e96f77547d8cfa250c27b963/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【数据结构】位图与布隆过滤器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/997097e8de91ffbedcf2bf3606e9ed63/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mysql 物理备份 MySQL 全量备份 增量备份 差异备份 日志备份万字长文 1.3万字</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>