<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python：基础&amp;爬虫 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f7da14cfd9167155003318fb370775c1/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Python：基础&爬虫">
  <meta property="og:description" content="Python爬虫学习（网络爬虫（又称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。）
python学习资料已打包好，需要的小伙伴可以戳这里【python资料】
一、基础知识准备 Python在各个编程语言中比较适合新手学习，Python解释器易于扩展，可以使用C、C&#43;&#43;或其他可以通过C调用的语言扩展新的功能和数据类型。Python也可用于可定制化软件中的扩展程序语言。Python丰富的标准库，提供了适用于各个主要系统平台的源码或机器码。
1 条件判断语句 score = 60 if score &gt;=90 and score &lt;=100: print(&#34;本次考试等级为A&#34;) elif score &gt;=70 and score &lt;90: #elif == else if print(&#34;本次考试等级为B&#34;) else: print(&#34;本次考试等级为C&#34;) #output: 本次考试等级为C 2 循环语句 2.1 for循环 for i in range(5): #输出5个数 [0 1 2 3 4] print(i) for i in range(0,10,3):#从[0,10)，以3为间距输出 #output: [0 3 6 9] print(i) for i in range(-10,-100,-30):#从[-10，-100)，以-30为间距 #output: [-10 -40 -70] print(i) name=&#34;chengdu&#34; for x in name: print(x) #output: [c h e n g d u] a = [&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-11T11:20:51+08:00">
    <meta property="article:modified_time" content="2024-06-11T11:20:51+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python：基础&amp;爬虫</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="autoid-0-0-0">Python爬虫学习（网络爬虫（又称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。）</p> 
<p>python学习资料已打包好，需要的小伙伴可以戳这里<a href="https://mp.weixin.qq.com/s?__biz=MzkzNzcwNzU1Mg==&amp;mid=2247483668&amp;idx=1&amp;sn=6cd5a636f77005216b8af5e310c3066a&amp;chksm=c28a105bf5fd994dab91e852c49fdc08849d1998d6ec191d4a1247b7d20f43b71d9103703a4d&amp;token=1651258958&amp;lang=zh_CN#rd" rel="nofollow" title="【python资料】">【python资料】</a></p> 
<p></p> 
<h3 id="autoid-0-0-0">一、基础知识准备</h3> 
<blockquote> 
 <p>Python在各个编程语言中比较适合新手学习，Python解释器易于扩展，可以使用C、C++或其他可以通过C调用的语言扩展新的功能和数据类型。Python也可用于可定制化软件中的扩展程序语言。Python丰富的标准库，提供了适用于各个主要系统平台的源码或机器码。</p> 
</blockquote> 
<h4>1 条件判断语句</h4> 
<pre><code>score = 60
if score &gt;=90 and score &lt;=100:
    print("本次考试等级为A")
elif score &gt;=70 and score &lt;90:  #elif == else if
    print("本次考试等级为B")      
else:
    print("本次考试等级为C")      #output: 本次考试等级为C
</code></pre> 
<h4 id="autoid-1-0-0">2 循环语句</h4> 
<h5 id="autoid-2-0-0">2.1 for循环</h5> 
<pre><code>for i in range(5): #输出5个数 [0 1 2 3 4]
    print(i)

for i in range(0,10,3):#从[0,10)，以3为间距输出                #output: [0 3 6 9]
    print(i)


for i in range(-10,-100,-30):#从[-10，-100)，以-30为间距     #output: [-10 -40 -70]
    print(i)



name="chengdu" 
for x in name:
    print(x)            #output: [c h e n g d u]

    
a = ["a", "b", "c"] 
for i in range(len(a)):
     print(i, a[i])    #output: [0 a 1 b 2 c]
</code></pre> 
<h5 id="autoid-2-1-0">2.2 while循环</h5> 
<pre><code>i=0
while i&lt;3:
    print("这是第%d次循环："%(i+1))
    print("i=%d"%i)
    i+=1

'''#output: 
这是第1次循环：
i=0
这是第2次循环：
i=1
这是第3次循环：
i=2
'''
</code></pre> 
<pre><code>count = 0
while count&lt;3:
    print(count,"小于3")
    count +=1
else:
    print(count,"大于或等于3")
    
'''#output: 
0 小于3
1 小于3
2 小于3
3 大于或等于3
'''
</code></pre> 
<h4 id="autoid-2-2-0">3 字符串</h4> 
<pre><code>str="chengdu"			  
print(str)                #chengdu
print(str[0])             #c
print(str[0:5])           #[0,5) cheng
print(str[1:7:2])         #[起始位置：结束位置：步进值] hnd
print(str[5:])            #显示5以后的 du
print(str[:5])            #显示5以前的 cheng
print(str+",hello")       #字符串连接 chengdu,hello
print(str*3)              #打印3次 chengduchengduchengdu
print("hello\nchengdu")   #\n换行 hello  chengdu
print(r"hello\nchengdu")  #前面加"r"，表示显示原始字符串，不进行转义hello\nchengdu
print("-"*30)             #打印30个“-”
</code></pre> 
<h4 id="autoid-3-0-0">4 列表-List</h4> 
<blockquote> 
 <p>列表中的每个元素都分配一个数字 - 它的位置或索引，第一个索引是0，第二个索引是1，依此类推。</p> 
</blockquote> 
<h5 id="autoid-4-0-0">4.1 列表定义</h5> 
<pre><code>namelist = ["小张","小王","小李"]
testlist = [1,"测试","str"]  #列表中可以存储混合类型
testlist = [["a","b"],["c","d"],["e","f","g"]] #列表嵌套
</code></pre> 
<h5 id="autoid-4-1-0">4.2 列表元素输出</h5> 
<pre><code>namelist = ["小张","小王","小李"]
#输出指定元素
print(namelist[1])     #output: 小王

#遍历输出
for name in namelist: 
    print(name)
   
'''output
小张
小王
小李
'''    

#使用枚举函数enenumerate()，同时拿到列表下标和元素类容
for i,name in enumerate(namelist): 
    print(i,name)
    
'''output
0 小张
1 小王
2 小李
'''
</code></pre> 
<h5 id="autoid-4-2-0">4.3 列表元素切片</h5> 
<p>如下所示：L=[‘Google’, ‘Python’, ‘Taobao’]</p> 
<table><thead><tr><th>Python</th><th>表达式 结果</th><th>描述</th></tr></thead><tbody><tr><td>L[2]</td><td>‘Taobao’</td><td>读取第三个元素</td></tr><tr><td>L[-1]</td><td>‘Taobao’</td><td>读取最后一个元素</td></tr><tr><td>L[1:]</td><td>[‘Python’, ‘Taobao’]</td><td>输出从第二个元素开始后的所有元素</td></tr><tr><td>L[:-1]</td><td>[‘Google’, ‘Python’]</td><td>输出从第一个到倒数第一个的所有元素</td></tr><tr><td>L[-2:]</td><td>[‘Python’, ‘Taobao’]</td><td>输出从倒数第二个到末尾的所有元素</td></tr></tbody></table> 
<h5 id="autoid-4-3-0">4.4 列表元素追加</h5> 
<pre><code>#append
a = [1,2]
b = [3,4]
a.append(b)  #将b列表当做一个元素加入到a中
print(a)     #output: [1, 2, [3, 4]]

#extend
a = [1,2]
b = [3,4]
a.extend(b) #将b列表中的诶个元素，逐一追加到a中
print(a)    #output: [1, 2, 3, 4]

#insert
a=[1,2,4]
a.insert(2,3) ##在下标为2的位置插入3   #指定下标位置插入元素（第一个表示下标，第二个表示元素）
print(a)  #output: [1, 2, 3, 4] 
</code></pre> 
<h5 id="autoid-4-4-0">4.5 列表元素删除</h5> 
<pre><code>#del
a = ["小张","小王","小李"]
del a[2]                      #删除指定下标元素
print(a)                      #output: ['小张', '小王']

#pop
a = ["小张","小王","小李"]
a.pop()                      #弹出末尾元素
print(a)                     #output: ['小张', '小王']

#remove
a = ["小张","小王","小李"]
a.remove("小李")             #直接删除指定内容的元素
print(a)                    #output: ['小张', '小李']
</code></pre> 
<h5 id="autoid-4-5-0">4.6 列表元素修改</h5> 
<pre><code>a = ["小张","小王","小李"]
a[2] = "小红"				 #修改指定下标元素内容
print(a) 				  #output: ['小张', '小王', '小红']
</code></pre> 
<h5 id="autoid-4-6-0">4.7 列表元素查找</h5> 
<pre><code>#in / not in
a = ["小张","小王","小李"]
findName = input("请输入你要查找的学生姓名：")
if findName in a:
    print("找到")
else:
    print("未找到")
    
#index
a = ["小张","小王","小李"]
print(a.index("小王",0,2))    #可以查找指定下标范围的元素，并返回找到对应数据的下标  #output: 1
print(a.index("小李",0,2))   #范围区间：左开右闭[0,2) # ValueError: '小李' is not in list

#count
print(a.count("小王"))      #查找某个元素出现的次数  #output: 1
</code></pre> 
<h5 id="autoid-4-7-0">4.8 列表元素反转和排序</h5> 
<pre><code>a = [1,4,2,3]
a.reverse()             #将列表所有元素反转
print(a)                #output: [3, 2, 4, 1]
 
a.sort()                #升序
print(a)                #output: [1, 2, 3, 4]

a.sort(reverse=True)    #降序
print(a)                #output: [1, 2, 3, 4]
</code></pre> 
<h4 id="autoid-4-8-0">5 前段知识综合练习</h4> 
<blockquote> 
 <p>Topic: 将8个老师随机分配到3个办公室</p> 
</blockquote> 
<pre><code>import random
offices = [[],[],[]]							#3个教室
teachers = ["A","B","C","D","E","F","G","H"]	#8个老师
for teacher in teachers:                 		#遍历teachers放入office中
    index = random.randint(0,2)   		 		#产生随机数0,1,2
    offices[index].append(teacher)     		    #将teachers追加到office中
i=1 #office1
for office in offices:                			 #输出每个office人数和对应的老师
    print("office%d的人数为：%d"%(i,len(office)))
    i += 1  #遍历offices
    for name in office:
        print("%s"%name,end="\t")    			 #打印每个office老师的名字
    print("\n")                       			 #打印完一个office换行
    print("-"*20)                    			 #打印完一个office输出20个-
</code></pre> 
<h4 id="autoid-5-0-0">6 元组-Tuple</h4> 
<blockquote> 
 <p>元组与列表类似，不同之处在于元组的元素不能修改。<br> 元组使用小括号，列表使用方括号。</p> 
</blockquote> 
<h5 id="autoid-6-0-0">6.1 元组定义</h5> 
<pre><code>tup1=()     #空元组
tup2=(5)    #&lt;class 'int'&gt;  不是元组
tup2=(5,)   #&lt;class 'tuple'&gt;
tup3 = ('Google', 'Python', 1997, 2000)
</code></pre> 
<h5 id="autoid-6-1-0">6.2 元组元素切片</h5> 
<pre><code>tup=(1,2,3)
print(tup[0])    #第一个元素     #output:  1
print(tup[-1])   #最后一个元素   #output:  3
print(tup[0:2])  #左闭右开[0,2) #output:  (1, 2)
</code></pre> 
<h5 id="autoid-6-2-0">6.3 元组元素增加(连接)</h5> 
<pre><code>tup1 = (12,34,56)
tup2 = ("ab","cd","ef")
tup3 = tup1+tup2
print(tup3)          #(12, 34, 56, 'ab', 'cd', 'ef')
</code></pre> 
<h5 id="autoid-6-3-0">6.4 元组元素删除</h5> 
<pre><code>tup1 = (12,34,56)
#del tup1[0]    #不允许删除单个元素
del tup1        #删除了整个元组变量
</code></pre> 
<h5 id="autoid-6-4-0">6.5 元组元素不能修改</h5> 
<pre><code>tup1 = (12,34,56)
tup1[0] = 72  #报错 不能修改
</code></pre> 
<h4 id="autoid-6-5-0">7 字典-dict</h4> 
<blockquote> 
 <p>字典使用键值对(key=&gt;value)存储；键必须是唯一的，但值则不必。</p> 
</blockquote> 
<h5 id="autoid-7-0-0">7.1 字典定义</h5> 
<pre><code>dict = {key1 : value1, key2 : value2 }
info = {"name":"简简","age":18}
</code></pre> 
<h5 id="autoid-7-1-0">7.2 字典访问</h5> 
<pre><code>info = {"name":"简简","age":18}
print(info["name"])
print(info["age"])

#访问不存在键
print(info["sex"])               #直接访问不存在的键，会报错
print(info.get("sex"))           #使用get()方法，访问不存在的键，默认返回：none
print(info.get("sex","没有"))     #没有找到的时候，返回自定义值  #output： 没有
</code></pre> 
<h5 id="autoid-7-2-0">7.3 字典键值增加</h5> 
<pre><code>info = {"name":"简简","age":18}
info["sex"]="man"   			#新增sex
print(info)         			#output: {'name': '简简', 'age': 18, 'sex': 'man'}
</code></pre> 
<h5 id="autoid-7-3-0">7.4 字典键值删除</h5> 
<pre><code>#del
info = {"name":"简简","age":18}
del info["name"]                #删除name键值对
print(info)                     #output: {'age': 18}

del info                        #删除整个字典
print(info)                     #output: NameError: name 'info' is not defined

#clear
info = {"name":"简简","age":18}
info.clear()                     #清空字典内键值对
print(info)                      #output: {}
</code></pre> 
<h5 id="autoid-7-4-0">7.5 字典键值修改</h5> 
<pre><code>info = {"name":"简简","age":18}
info["age"]=20
print(info)
</code></pre> 
<h5 id="autoid-7-5-0">7.6 字典键值查找</h5> 
<pre><code>info = {"name":"简简","age":18}
print(info.keys())               #得到所有的键     #output: dict_keys(['name', 'age'])
print(info.values())             #得到所有的值     #output: dict_values(['简简', 18])
print(info.items())     		 #得到所有的键值对 #output: dict_items([('name', '简简'), ('age', 18)])


#遍历所有的键
for key in info.keys():
    print(key)     #output: name age
    
#遍历所有的值
for value in info.values():
    print(value)     #output: 简简 18
    
#遍历所有的键值对
for key,value in info.items():
        print("(key=%s,value=%s)"%(key,value)) 
#output: (key=name,value=简简) (key=age,value=18)
</code></pre> 
<h4 id="autoid-7-6-0">8 函数</h4> 
<h5 id="autoid-8-0-0">8.1 函数定义和使用</h5> 
<pre><code>def printinfo(a,b): #函数定义
    c =a + b
    print(c)

printinfo(1,2) 		#函数的使用
</code></pre> 
<h5 id="autoid-8-1-0">8.2 带返回值的函数</h5> 
<pre><code>def info(a,b):
    c =a + b
    return c 		#返回值

print(info(1,2)) 
</code></pre> 
<h5 id="autoid-8-2-0">8.3 返回多个值的函数</h5> 
<pre><code>def divid(a,b):
    shang = a//b
    yushu = a%b
    return shang,yushu #多个返回值用逗号隔开

sh,yu = divid(5,2)     #需要用多个值来保存返回内容
print("商：%d 余数:%d"%(sh,yu))
</code></pre> 
<h4 id="autoid-8-3-0">9 文件操作</h4> 
<h5 id="autoid-9-0-0">9.1 打开文件(open)</h5> 
<p>用法：对象=open(文件名，访问模式)</p> 
<pre><code>f = open('test.txt', 'w')
</code></pre> 
<table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td><strong>r</strong></td><td>以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td></tr><tr><td><strong>w</strong></td><td>打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td></tr><tr><td>a</td><td>打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td><strong>rb</strong></td><td>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。</td></tr><tr><td><strong>wb</strong></td><td>以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td></tr><tr><td>ab</td><td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td>r+</td><td>打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td>w+</td><td>打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td></tr><tr><td>a+</td><td>打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td></tr><tr><td>rb+</td><td>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td>wb+</td><td>以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td></tr><tr><td>ab+</td><td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td></tr></tbody></table> 
<h5 id="autoid-9-1-0">9.2 关闭文件(close)</h5> 
<p>用法：对象.close()</p> 
<pre><code>f.close()
</code></pre> 
<h5 id="autoid-9-2-0">9.3 写数据(write)</h5> 
<p>用法：对象.write()</p> 
<pre><code>f=open("test.txt","w")  # 打开文件，w(写模式)-文件不存在就在当前路径给你新建一个
f.write("hello,world")  # write将字符写入文件
f.close()
</code></pre> 
<h5 id="autoid-9-3-0">9.4 读数据(read)</h5> 
<p>用法：对象.read()</p> 
<pre><code>f=open("test.txt","r")   #打开文件，r(读模式)
content=f.read(5)        #read读取5个字符
print(content)
f.close()
</code></pre> 
<h5 id="autoid-9-4-0">9.5 读一行数据(readline)</h5> 
<p>用法：对象.readline()</p> 
<pre><code>f = open('test.txt', 'r')
content = f.readline()
print("1:%s"%content)#读取一行
content = f.readline()
print("2:%s"%content)#再读下一行
f.close()
</code></pre> 
<h5 id="autoid-9-5-0">9.6 读多行数据(readlines)</h5> 
<p>用法：对象.readlines()</p> 
<pre><code>f=open("test.txt","r")   #打开文件，r(读模式)
content=f.readlines()    #readlines读取整个文件，以列表形式输出
print(content)           #输出形式为列表 #output: ['hello,world\n', 'hello,world']

#对列表进行处理，按序号一行一行输出
i=1
for temp in content:
    print("%d:%s" % (i, temp))
    i += 1  #output: 1:hello,world 2:hello,world
f.close() 
</code></pre> 
<h5 id="autoid-9-6-0">9.7 OS模块</h5> 
<ul><li>使用该模块必须先导入模块：</li></ul> 
<pre><code>    import os
</code></pre> 
<h6 id="autoid-9-7-0">os模块中的函数:</h6> 
<table><thead><tr><th>序号</th><th>函数名称</th><th>描述</th><th>格式</th></tr></thead><tbody><tr><td>1</td><td>getcwd()</td><td>获取当前的工作目录</td><td>格式：os.getcwd() 返回值：路径字符串</td></tr><tr><td>2</td><td>chdir()</td><td>修改当前工作目录</td><td>格式:os.chdir() 返回值:None</td></tr><tr><td>3</td><td>listdir()</td><td>获取指定文件夹中的 所有文件和文件夹组成的列表</td><td>格式:os.listdir(目录路径) 返回值：目录中内容名称的列表</td></tr><tr><td>4</td><td>mkdir()</td><td>创建一个目录/文件夹</td><td>格式：os.mkdir(目录路径) 返回值：None</td></tr><tr><td>5</td><td>makedirs()</td><td>递归创建文件夹</td><td>格式:os.makedirs(路径)</td></tr><tr><td>6</td><td>rmdir()</td><td>移除一个目录（必须是空目录）</td><td>格式：os.rmdir(目录路径) 返回值:None</td></tr><tr><td>7</td><td>removedirs()</td><td>递归删除文件夹</td><td>格式：os.removedirs(目录路径) 返回值：None 注意最底层目录必须为空</td></tr><tr><td>8</td><td>rename()</td><td>修改文件和文件夹的名称</td><td>格式：os.rename(源文件或文件夹，目标文件或文件夹) 返回值：None</td></tr><tr><td>9</td><td>stat()</td><td>获取文件的相关 信息</td><td>格式：os.stat(文件路径) 返回值：包含文件信息的元组</td></tr><tr><td>10</td><td>system()</td><td>执行系统命令</td><td>格式:os.system() 返回值：整型 慎用！ 玩意来个rm -rf 你就爽了！</td></tr><tr><td>11</td><td>getenv()</td><td>获取系统环境变量</td><td>格式：os.getenv(获取的环境变量名称) 返回值：字符串</td></tr><tr><td>12</td><td>putenv()</td><td>设置系统环境变量</td><td>格式：os.putenv(‘环境变量名称’,值) 返回值：无 注意：无法正常的getenv检测到。</td></tr><tr><td>13</td><td>exit()</td><td>推出当前执行命令，直接关闭当前操作</td><td>格式:exit() 返回值：无</td></tr></tbody></table> 
<h4 id="autoid-9-7-1">10 异常处理</h4> 
<h5 id="autoid-10-0-1">10.1 异常简介</h5> 
<pre><code> print '-----test--1---'  
    open('123.txt','r')  
 print '-----test--2---'
</code></pre> 
<p></p> 
<p class="img-center"><img alt="image-20200323100011079" height="78" src="https://images2.imgbox.com/e3/f3/7V3vXbKa_o.png" width="416"></p> 
<blockquote> 
 <p>打开一个不存在的文件123.txt，当找不到123.txt 文件时，就会抛出给我们一个IOError类型的错误，No such ﬁle or directory：123.txt （没有123.txt这样的文件或目录）</p> 
</blockquote> 
<h5 id="autoid-10-1-0">10.2 捕获异常</h5> 
<pre><code>try:
     print('-----test--1---')  
    open('123.txt','r') 	 	 
    print('-----test--2---')
except IOError:
    pass
</code></pre> 
<blockquote> 
 <p>此程序看不到任何错误，因为用except 捕获到了IOError异常，并添加了处理的方法<br> pass 表示实现了相应的实现，但什么也不做；如果把pass改为print语句，那么就会输出其他信息</p> 
</blockquote> 
<p><strong>总结：</strong></p> 
<p></p> 
<p class="img-center"><img alt="image-20200323100335376" height="128" src="https://images2.imgbox.com/d7/a9/EU66Eqnr_o.png" width="442"></p> 
<p>把可能出现问题的代码，放在try中<br> 把处理异常的代码，放在except中</p> 
<pre><code>try:
  print num 
except IOError:
  print('产生错误了')
</code></pre> 
<p>上例程序，已经使用except来捕获异常，但是还会看到错误的信息提示</p> 
<blockquote> 
 <p>except捕获的错误类型是IOError，而此时程序产生的异常为 NameError ，所以except没有生效</p> 
</blockquote> 
<pre><code>try:
  print num
except NameError:
  print('产生错误了')
</code></pre> 
<p>Python的一些內建异常：</p> 
<table><thead><tr><th>异常</th><th>描述</th></tr></thead><tbody><tr><td>Exception</td><td>常规错误的基类</td></tr><tr><td>AttributeError</td><td>对象没有这个属性</td></tr><tr><td>IOError</td><td>输入/输出操作失败</td></tr><tr><td>IndexError</td><td>序列中没有此索引(index)</td></tr><tr><td>KeyError</td><td>映射中没有这个键</td></tr><tr><td>NameError</td><td>未声明/初始化对象 (没有属性)</td></tr><tr><td>SyntaxError</td><td>Python 语法错误</td></tr><tr><td>TypeError</td><td>对类型无效的操作</td></tr><tr><td>ValueError</td><td>传入无效的参数</td></tr><tr><td>ZeroDivisionError</td><td>除(或取模)零 (所有数据类型)</td></tr><tr><td></td><td></td></tr></tbody></table> 
<h5 id="autoid-10-2-0">10.3 捕获多个异常</h5> 
<pre><code>#coding=utf-8 
try:
 print('-----test--1---')
 open('123.txt','r') # 如果123.txt文件不存在，那么会产生 IOError 异常  
 print('-----test--2---')
 print(num)# 如果num变量没有定义，那么会产生 NameError 异常
 except (IOError,NameError):
 #如果想通过一次except捕获到多个异常可以用一个元组的形式
</code></pre> 
<h5 id="autoid-10-3-0">10.4 获取异常的信息描述</h5> 
<p></p> 
<p class="img-center"><img alt="image-20200323102016442" height="101" src="https://images2.imgbox.com/a9/58/jCMeoMcH_o.png" width="442"></p> 
<p></p> 
<p></p> 
<p class="img-center"><img alt="image-20200323102023020.png" height="93" src="https://images2.imgbox.com/a8/c1/v06JqKq6_o.png" width="442"></p> 
<p></p> 
<h5 id="autoid-10-4-0">10.5 try…ﬁnally…</h5> 
<blockquote> 
 <p>在程序中，如果一个段代码必须要执行，即无论异常是否产生都要执行，那么此时就需要使用ﬁnally。 比如文件关闭，释放锁，把数据库连接返还给连接池等</p> 
</blockquote> 
<pre><code>import time
try:
    f = open('test.txt')
    try:
        while True:
            content = f.readline()
            if len(content) == 0:
                break
            time.sleep(2)
            print(content)
    except:
         #如果在读取文件的过程中，产生了异常，那么就会捕获到  
         #比如 按下了 ctrl+c
        pass
    finally:
        f.close()
        print('关闭文件')
except:
    print("没有这个文件")
</code></pre> 
<p>test.txt文件中每一行数据打印，但是我有意在每打印一行之前用time.sleep方法暂停2秒钟。这样做的原因是让程序运行得慢一些。在程序运行的时候，按Ctrl+c中断（取消）程序。<br> 我们可以观察到KeyboardInterrupt异常被触发，程序退出。但是在程序退出之前，ﬁnally从句仍然被执行，把文件关闭。</p> 
<h4 id="autoid-10-5-0">11 Python知识</h4> 
<h5 id="autoid-11-0-0">除法</h5> 
<ul><li>除 /</li><li>整除 //</li><li>求余 %</li><li>商和余数的元组 divmod</li></ul> 
<h5 id="autoid-11-1-0">移位操作</h5> 
<h6 id="autoid-11-2-0">左移（&lt;&lt;）</h6> 
<p>`a&lt;，左移 n 位相当于原操作数乘以 2^n，原操作数不发生变化。</p> 
<pre><code>&gt;&gt;&gt; 3&lt;&lt;1      # 向右移动一位，相当于是乘以2
6             
&gt;&gt;&gt; -3&lt;&lt;2     # 向右移动一位，相当于是乘以4
-12
</code></pre> 
<h6 id="autoid-11-2-1">右移（&gt;&gt;）</h6> 
<p><code>a&gt;&gt;n，则a' =a//(2^n)</code>，左移 n 位相当于原操作数整除 2^n，原操作数不发生变化。</p> 
<pre><code>&gt;&gt;&gt; 2&gt;&gt;1     # 移动一位，相当于是2//2
1            
&gt;&gt;&gt; 2&gt;&gt;2     # 相当于先左移一位得到1，结果1再除以2等于0
0
&gt;&gt;&gt; 2&gt;&gt;3     # 相当于2//8
0  
          
&gt;&gt;&gt; -8&gt;&gt;2    # 移动2位，相当于-8//4
-2
&gt;&gt;&gt; -8&gt;&gt;3    # 移动3位，相当于是用结果-2再除以2
-1
&gt;&gt;&gt; -8&gt;&gt;4    # 移动4位，相当于是用结果-1再除以2
-1
</code></pre> 
<p>如果操作数是正数，那么对之不停进行右移操作，最终结果一定可以得到 <code>0</code>；如果操作数是负数，对之不停进行右移操作，最终结果一定可以得到 <code>-1</code>。</p> 
<h5 id="autoid-11-2-2">匿名函数lambda</h5> 
<p>匿名函数 lambda 是指一类无需定义标识符（函数名）的函数或子程序。<br> lambda 函数可以接收任意多个参数 (包括可选参数) 并且返回单个表达式的值。</p> 
<p>语法：</p> 
<pre><code>lambda [arg1,arg2,.....argn]:expression
</code></pre> 
<p>冒号前是参数，可以有多个，用逗号隔开，冒号右边的为表达式（只能为一个）。其实lambda返回值是一个函数的地址，也就是函数对象。</p> 
<pre><code>lambda arg: print("hello,world",arg)
</code></pre> 
<p>lambda表达式限制只能包含一行代码，但是其实可以利用元组或列表强行让其包含多行。（但是这么做会严重影响可读性，除非万不得已不要使用）</p> 
<pre><code>lambda :(
    print("hello"),
    print("world"),           
)
</code></pre> 
<h5 id="autoid-11-3-0">切片</h5> 
<p></p> 
<p class="img-center"><img alt="" height="720" src="https://images2.imgbox.com/a2/10/uoNWhx5z_o.png" width="1200"></p> 
<pre><code>t=[1,2,3,4,5]

print(t[1:])     取第二个到最后一个元素
结果：[2 3 4 5]

print(t[:])     取所有元素
结果：[1 2 3 4 5]

print(t[1:3])     取t[1]-t[2]
结果：[ 2 3 ]

print(t[:-1])     除了最后一个取全部
结果：[ 1 2 3 4 ]
 
print(t[::-1])     取从后向前（相反）的元素
结果：[ 5 4 3 2 1 ]
 
print(t[2::-1])     取从下标为2的元素翻转读取
结果：[ 3 2 1 ]
</code></pre> 
<h5 id="autoid-11-4-0">字符串方法</h5> 
<h6 id="autoid-11-5-0">join(iterable)</h6> 
<blockquote> 
 <p>获取可迭代对象(iterable)中的所有项目，并将它们连接为一个字符串。</p> 
</blockquote> 
<p>实例1：</p> 
<pre><code>myTuple = ("Bill", "Steve", "Elon")
x = "#".join(myTuple)
print(x)

'''
输出：
Bill#Steve#Elon
'''
</code></pre> 
<p>实例2：</p> 
<pre><code>myDict = {"name": "Bill", "country": "USA"}
mySeparator = "TEST"
x = mySeparator.join(myDict)
print(x)

'''
输出：
nameTESTcountry
'''
</code></pre> 
<p>注释：在使用字典作为迭代器时，返回的值是键，而不是值。</p> 
<h6 id="autoid-11-5-1">split(separator, max)</h6> 
<blockquote> 
 <p>将字符串拆分为列表，您可以指定分隔符，默认分隔符是任何空白字符。若指定 max，列表将包含指定数量加一的元素。</p> 
</blockquote> 
<p>实例1：</p> 
<pre><code>txt = "welcome to China"
x = txt.split()
print(x)

'''
输出：
['welcome', 'to', 'China']
'''
</code></pre> 
<p>实例2：</p> 
<pre><code>txt = "apple#banana#cherry#orange"
# 将 max 参数设置为 1，将返回包含 2 个元素的列表！
x = txt.split("#", 1)
print(x)

'''
输出：
['apple', 'banana#cherry#orange']
'''
</code></pre> 
<h5 id="autoid-11-5-2">内置函数</h5> 
<h6 id="autoid-11-6-0">enumerate()</h6> 
<blockquote> 
 <p>用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</p> 
</blockquote> 
<p>实例1：</p> 
<pre><code>&gt;&gt;&gt;seq = ['one', 'two', 'three']
&gt;&gt;&gt; for i, element in enumerate(seq):
...     print i, element
... 
0 one
1 two
2 three
</code></pre> 
<p>实例2：</p> 
<pre><code>&gt;&gt;&gt;seasons = ['Spring', 'Summer', 'Fall', 'Winter']
&gt;&gt;&gt; list(enumerate(seasons))
[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
&gt;&gt;&gt; list(enumerate(seasons, start=1))       # 下标从 1 开始
[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]
</code></pre> 
<h6 id="autoid-11-6-1">exec()</h6> 
<blockquote> 
 <p>exec 执行储存在字符串或文件中的 Python 语句，相比于 eval，exec可以执行更复杂的 Python 代码。</p> 
</blockquote> 
<pre><code># 单行语句字符串
&gt;&gt;&gt;exec('print("Hello World")')
Hello World

#  多行语句字符串
&gt;&gt;&gt; exec ("""for i in range(5):
...     print ("iter time: %d" % i)
... """)
iter time: 0
iter time: 1
iter time: 2
iter time: 3
iter time: 4
</code></pre> 
<h3 id="autoid-11-6-2">二、Python爬虫</h3> 
<blockquote> 
 <p>下面的学习方式是以爬取豆瓣top250 网页进行开展的</p> 
 <p>基本流程: 爬取网页—&gt;解析数据—&gt;保存数据</p> 
</blockquote> 
<h4>1 requests库</h4> 
<blockquote> 
 <p><code>Requests</code>是一个简单方便的<code>HTTP 库</code>。比<code>Python</code>标准库中的<code>urllib2</code>模块功能强大。Requests 使用的是 urllib3，因此继承了它的所有特性。Requests 支持使用<code>cookie</code> 保持会话，支持文件上传，支持自动确定响应内容的编码，支持<code>URL</code> 和 <code>POST</code> 数据自动编码。帮助我们轻松解决关于<code>HTTP</code>的大部分问题。</p> 
</blockquote> 
<p>爬取网页首先要学习requests库或者urllib库的使用,不然你无法看懂下面代码</p> 
<h4 id="autoid-12-0-2">2 爬取网页</h4> 
<h5 id="autoid-13-0-2">2.1 爬取豆瓣top250第一页数据</h5> 
<pre><code>#-*- coding =utf-8 -*-
import requests

def askUrl(url):
    head = { #模拟浏览器头部信息，向豆瓣服务器发送消息
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.69 Safari/537.36 Edg/81.0.416.34"
    # 用户代理：告诉豆瓣服务器，我们是什么类型的浏览器（本质上是告诉浏览器我们可以接收什么水平的文件内容）
    }
    html=""  #用来接收数据
    r = requests.get(url, headers = head) #get方式发送请求
    html = r.text #接收数据
    print(html)  
    return html

if __name__ == "__main__": # main函数用于测试程序
    askUrl("https://movie.douban.com/top250?start=") #调用函数
</code></pre> 
<p>可以看到成功的爬取到豆瓣top250第一页的数据</p> 
<p></p> 
<p class="img-center"><img alt="image-20200327113957848" height="378" src="https://images2.imgbox.com/38/8c/24q20jL0_o.png" width="1200"></p> 
<p></p> 
<h5 id="autoid-13-1-0">2.2 爬取豆瓣top250前10页数据</h5> 
<pre><code>#-*- coding =utf-8 -*-
import requests

#爬取一个页面
def askUrl(url):
    head = { #模拟浏览器头部信息，向豆瓣服务器发送消息
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.69 Safari/537.36 Edg/81.0.416.34"
    # 用户代理：告诉豆瓣服务器，我们是什么类型的浏览器（本质上是告诉浏览器我们可以接收什么水平的文件内容）
    }
    #html=""
    r = requests.get(url, headers = head)
    html = r.text
    print(html)

# 爬取所有页面
def getData(baseurl):
    for i in range(0, 10):
        url = baseurl + str(i * 25)
        html = askUrl(url)

if __name__ == "__main__": # main函数用于测试程序
    baseurl = "https://movie.douban.com/top250?start="
    getData(baseurl)
</code></pre> 
<p>可以看到排名250的梦之安魂曲也被成功爬取到</p> 
<p></p> 
<p class="img-center"><img alt="image-20200327115150029" height="463" src="https://images2.imgbox.com/16/7f/dJUTBpe2_o.png" width="1144"></p> 
<p><strong>image-20200327115150029</strong></p> 
<h4 id="autoid-13-2-0">3 BeautifulSoup4库</h4> 
<blockquote> 
 <p>BeautifulSoup4和 lxml 一样，Beautiful Soup 也是一个HTML/XML的解析器，主要的功能也是如何解析和提取 HTML/XML 数据。</p> 
</blockquote> 
<p>假设有这样一个baidu.html，放在py文件目录下，下面的例子都基于该html,具体内容如下：</p> 
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta content="text/html;charset=utf-8" http-equiv="content-type" /&gt;
    &lt;meta content="IE=Edge" http-equiv="X-UA-Compatible" /&gt;
    &lt;meta content="always" name="referrer" /&gt;
    &lt;link href="https://ss1.bdstatic.com/5eN1bjq8AAUYm2zgoY3K/r/www/cache/bdorz/baidu.min.css" rel="stylesheet" type="text/css" /&gt;
    &lt;title&gt;百度一下，你就知道 &lt;/title&gt;
&lt;/head&gt;
&lt;body link="#0000cc"&gt;
  &lt;div id="wrapper"&gt;
    &lt;div id="head"&gt;
        &lt;div class="head_wrapper"&gt;
          &lt;div id="u1"&gt;
            &lt;a class="mnav" href="http://news.baidu.com" name="tj_trnews"&gt;&lt;!--新闻--&gt;&lt;/a&gt;
            &lt;a class="mnav" href="http://news.baidu.com" name="tj_trnews"&gt;新闻&lt;/a&gt;
            &lt;a class="mnav" href="https://www.hao123.com" name="tj_trhao123"&gt;hao123&lt;/a&gt;
            &lt;a class="mnav" href="http://map.baidu.com" name="tj_trmap"&gt;地图&lt;/a&gt;
            &lt;a class="mnav" href="http://v.baidu.com" name="tj_trvideo"&gt;视频&lt;/a&gt;
            &lt;a class="mnav" href="http://tieba.baidu.com" name="tj_trtieba"&gt;贴吧&lt;/a&gt;
            &lt;a class="bri" href="//www.baidu.com/more/" name="tj_briicon" style="display: block;"&gt;更多产品 &lt;/a&gt;
          &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<h5 id="autoid-14-0-0">3.1 快速使用案例</h5> 
<pre><code># 导入模块
from bs4 import BeautifulSoup

# 读取html文件信息（在真实代码中是爬取的网页信息）
file = open("./baidu.html",'rb') #解析器
content = f.read()
f.close()

# 创建解析器
bs = BeautifulSoup(content,"html.parser")

# 输出网页内容：注：此内容已被缩进格式化（自动更正格式），其实这个是在上一步实例化时就已完成
print(bs)

#输出网页中title标签中的内容
print(bs.title.string)
</code></pre> 
<h5 id="autoid-14-1-0">3.2 BeautifulSoup4主要解析器</h5> 
<table><thead><tr><th>解析器</th><th>使用方法</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>Python标准库</td><td>BeautifulSoup(markup, “html.parser”)</td><td>Python的内置标准库，执行速度适中，文档容错能力强</td><td>Python 2.7.3 or 3.2.2前的版本中文档容错能力差</td></tr><tr><td>lxml HTML 解析器</td><td>BeautifulSoup(markup, “lxml”)</td><td>速度快 文档容错能力强</td><td>需要安装C语言库</td></tr><tr><td>lxml XML 解析器</td><td>BeautifulSoup(markup, [“lxml-xml”]) BeautifulSoup(markup, “xml”)</td><td>速度快 唯一支持XML的解析器</td><td>需要安装C语言库</td></tr><tr><td>html5lib</td><td>BeautifulSoup(markup, “html5lib”)</td><td>最好的容错性，以浏览器的方式解析文档，生成HTML5格式的文档</td><td>速度慢、不依赖外部扩展</td></tr></tbody></table> 
<h5 id="autoid-14-2-0">3.2 BS4四大对象种类</h5> 
<blockquote> 
 <p>BeautifulSoup4将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以归纳为4种</p> 
</blockquote> 
<ul><li>Tag</li><li>NavigableString</li><li>BeautifulSoup</li><li>Comment</li></ul> 
<h6 id="autoid-14-3-0">3.2.1 Tag</h6> 
<blockquote> 
 <p>Tag通俗点讲就是为了获取HTML中的一个个标签</p> 
</blockquote> 
<pre><code>from bs4 import BeautifulSoup 
file = open('./baidu.html', 'rb') 
content = file.read() 
bs = BeautifulSoup(content,"html.parser") 

# 获取title标签的所有内容
print(bs.title)  #&lt;title&gt;百度一下，你就知道 &lt;/title&gt;

# 获取head标签的所有内容
print(bs.head) 

# 获取第一个a标签的所有内容
print(bs.a) 

# 类型
print(type(bs.a)) # &lt;class 'bs4.element.Tag'&gt;


#bs 对象本身比较特殊，它的 name 即为 [document] 
print(bs.name) # [document]

# head #对于其他内部标签，输出的值便为标签本身的名称
print(bs.head.name)  # head

# 获取a标签里的所有属性，打印输出来，得到的类型是一个字典。 
print(bs.a.attrs) 
# {'class': ['mnav'], 'href': 'http://news.baidu.com', 'name': 'tj_trnews'}

#还可以利用get方法，传入属性的名称，二者是等价的
print(bs.a['class']) # 等价 bs.a.get('class') 

# 可以对这些属性和内容等等进行修改
bs.a['class'] = "newClass"
print(bs.a) 

# 还可以对这个属性进行删除
del bs.a['class'] 
print(bs.a)
</code></pre> 
<h6 id="autoid-14-3-1">3.2.2 NavigableString</h6> 
<blockquote> 
 <p>既然我们已经得到了标签的内容，那么问题来了，我们要想获取标签内部的文字怎么办呢？很简单，用 .string 即可，例如</p> 
</blockquote> 
<pre><code>from bs4 import BeautifulSoup 
file = open('./baidu.html', 'rb') 
content = file.read() 
bs = BeautifulSoup(content,"html.parser") 

#获取title标签中的字符串
print(bs.title.string) #百度一下，你就知道 

# 类型
print(type(bs.title.string)) 
#&lt;class 'bs4.element.NavigableString'&gt;
</code></pre> 
<h6 id="autoid-14-3-2">3.3.3 BeautifulSoup</h6> 
<blockquote> 
 <p>BeautifulSoup对象表示的是一个文档的内容。大部分时候，可以把它当作 Tag 对象，是一个特殊的 Tag，我们可以分别获取它的类型，名称，以及属性，例如：</p> 
</blockquote> 
<pre><code>from bs4 import BeautifulSoup 
file = open('./baidu.html', 'rb') 
content = file.read() 
bs = BeautifulSoup(content,"html.parser") 

#获取整个文档
print(bs)

print(type(bs)) #&lt;class 'bs4.BeautifulSoup'&gt;
</code></pre> 
<h6 id="autoid-14-3-3">3.3.4 Comment</h6> 
<blockquote> 
 <p>Comment 对象是一个特殊类型的 NavigableString 对象，其输出的内容不包括注释符号。</p> 
</blockquote> 
<pre><code>from bs4 import BeautifulSoup 
file = open('./baidu.html', 'rb') 
content = file.read() 
bs = BeautifulSoup(content,"html.parser") 

print(bs.a)
# a标签如下：
# &lt;a class="mnav" href="http://news.baidu.com" name="tj_trnews"&gt;&lt;!--新闻--&gt;&lt;/a&gt;

print(bs.a.string) # 新闻  #不会输出上面a标签中的注释符号

print(type(bs.a.string)) 
# &lt;class 'bs4.element.Comment'&gt;
</code></pre> 
<h5 id="autoid-14-3-4">3.3 遍历文档数</h5> 
<p><strong>.contents：获取Tag的所有子节点，返回一个list</strong></p> 
<pre><code>from bs4 import BeautifulSoup 
file = open('./baidu.html', 'rb') 
content = file.read() 
bs = BeautifulSoup(content,"html.parser") 

print(bs.head.contents)  #获取head下面的所有直接子节点，返回列表 
print(bs.head.contents[1 #用列表索引来获取它的某一个元素
</code></pre> 
<p><strong>.children：获取Tag的所有子节点，返回一个生成器</strong></p> 
<pre><code>from bs4 import BeautifulSoup 
file = open('./baidu.html', 'rb') 
content = file.read() 
bs = BeautifulSoup(content,"html.parser") 

for child in  bs.body.children:
    print(child)
</code></pre> 
<table><thead><tr><th>.descendants</th><th>获取Tag的所有子孙节点</th></tr></thead><tbody><tr><td><strong>.strings</strong></td><td><strong>如果Tag包含多个字符串，即在子孙节点中有内容，可以用此获取，而后进行遍历</strong></td></tr><tr><td><strong>.stripped_strings</strong></td><td><strong>与strings用法一致，只不过可以去除掉那些多余的空白内容</strong></td></tr><tr><td><strong>.parent</strong></td><td><strong>获取Tag的父节点</strong></td></tr><tr><td><strong>.parents</strong></td><td><strong>递归得到父辈元素的所有节点，返回一个生成器</strong></td></tr><tr><td><strong>.previous_sibling</strong></td><td><strong>获取当前Tag的上一个节点，属性通常是字符串或空白，真实结果是当前标签与上一个标签之间的顿号和换行符</strong></td></tr><tr><td><strong>.next_sibling</strong></td><td><strong>获取当前Tag的下一个节点，属性通常是字符串或空白，真是结果是当前标签与下一个标签之间的顿号与换行符</strong></td></tr><tr><td><strong>.previous_siblings</strong></td><td><strong>获取当前Tag的上面所有的兄弟节点，返回一个生成器</strong></td></tr><tr><td><strong>.next_siblings</strong></td><td><strong>获取当前Tag的下面所有的兄弟节点，返回一个生成器</strong></td></tr><tr><td><strong>.previous_element</strong></td><td><strong>获取解析过程中上一个被解析的对象(字符串或tag)，可能与previous_sibling相同，但通常是不一样的</strong></td></tr><tr><td><strong>.next_element</strong></td><td><strong>获取解析过程中下一个被解析的对象(字符串或tag)，可能与next_sibling相同，但通常是不一样的</strong></td></tr><tr><td><strong>.previous_elements</strong></td><td><strong>返回一个生成器，可以向前访问文档的解析内容</strong></td></tr><tr><td><strong>.next_elements</strong></td><td><strong>返回一个生成器，可以向后访问文档的解析内容</strong></td></tr><tr><td><strong>.has_attr</strong></td><td><strong>判断Tag是否包含属性</strong></td></tr></tbody></table> 
<p></p> 
<h5 id="autoid-14-4-0">3.4 文档的搜索find_all()</h5> 
<h6 id="autoid-14-5-0">name参数</h6> 
<pre><code>from bs4 import BeautifulSoup 
file = open('./baidu.html', 'rb') 
content = file.read() 
bs = BeautifulSoup(content,"html.parser") 

#字符串过滤：会查找与字符串完全匹配的内容
t_list = bs.find_all("a")
t_list = bs.find_all("title")
print(t_list)

#正则表达式过滤：如果传入的是正则表达式，那么BeautifulSoup4会通过search()来匹配内容
import re
t_list = bs.find_all(re.compile("a"))
print(t_list)
</code></pre> 
<h6 id="autoid-14-5-1">函数参数</h6> 
<pre><code>from bs4 import BeautifulSoup 
file = open('./baidu.html', 'rb') 
content = file.read() 
bs = BeautifulSoup(content,"html.parser") 

#定义函数：传入一个函数，根据函数的要求来搜索
def name_is_exists(tag):
    return tag.has_attr("name")#搜索包含name的标签

t_list = bs.find_all(name_is_exists)
for item in t_list: #打印列表内容
     print(item)
</code></pre> 
<h6 id="autoid-14-5-2">keyword参数</h6> 
<pre><code>from bs4 import BeautifulSoup 
file = open('./baidu.html', 'rb') 
content = file.read() 
bs = BeautifulSoup(content,"html.parser") 

#搜索id=head的内容
t_list = bs.find_all(id="head")
for item in t_list:
    print(item)
    
#搜索class=manav的内容    
t_list = bs.find_all(class_="mnav")
for item in t_list: 
     print(item)
        
#搜索链接的内容 
t_list = bs.find_all(href="http://news.baidu.com")
for item in t_list: 
     print(item)
</code></pre> 
<h6 id="autoid-14-5-3">text参数</h6> 
<pre><code>from bs4 import BeautifulSoup 
file = open('./baidu.html', 'rb') 
content = file.read() 
bs = BeautifulSoup(content,"html.parser") 

import re
#t_list = bs.find_all(text="hao123")
#t_list = bs.find_all(text=["hao123","贴吧","地图"])
t_list = bs.find_all(text=re.compile("\d"))#查找包含数字的文本
for item in t_list: 
     print(item)
</code></pre> 
<h6 id="autoid-14-5-4">limit 参数</h6> 
<pre><code>from bs4 import BeautifulSoup 
file = open('./baidu.html', 'rb') 
content = file.read() 
bs = BeautifulSoup(content,"html.parser") 

t_list = bs.find_all("a",limit=3)
for item in t_list: 
     print(item)
</code></pre> 
<h5 id="autoid-14-5-5">3.5 css选择器</h5> 
<pre><code>from bs4 import BeautifulSoup 
file = open('./baidu.html', 'rb') 
content = file.read() 
bs = BeautifulSoup(content,"html.parser") 

#通过标签来查找
t_list = bs.select('title')   

#通过类名（.表示类）来查找
t_list = bs.select('.mnav')

#通过id（#表示id）来查找
t_list = bs.select('#u1')

#通过属性来查找 查找a标签中class=bri的内容
t_list = bs.select("a[class='bri']")   

#通过父子标签来查找
t_list=bs.select("head &gt; title")   

#通过兄弟标签来查找
t_list=bs.select(".mnav ~ .bri")   

for item in t_list: #打印列表内容
       print(item)
print(t_list[0].get_text()) #拿到t_list中的文本
</code></pre> 
<h4 id="autoid-14-6-0">4 re库</h4> 
<blockquote> 
 <p>正则表达式(Regular Expression)通常被用来<code>匹配</code>、<code>检索</code>、<code>替换</code>和<code>分割</code>那些符合某个模式(规则)的文本。</p> 
</blockquote> 
<h5 id="autoid-15-0-0">4.1 正则表达式常用操作符</h5> 
<table><thead><tr><th>操作符</th><th>说明</th><th>实例</th></tr></thead><tbody><tr><td>.</td><td>表示除 “\n” 之外的任何单个字符。</td><td></td></tr><tr><td>[ ]</td><td>宇符集，对单个字符给出取值范围</td><td>[abc]表示a,b,c;[a-z]表示a到z单个字符</td></tr><tr><td>[^ ]</td><td>非字符集,对单个字符恰给出排除范围</td><td>[^abc]表示非a或非b或c的单个字符</td></tr><tr><td>*</td><td>前一个字符0次或无限次扩展</td><td>abc* 表示ab、abc、abcc、abcc等</td></tr><tr><td>+</td><td>前一个字符1次或无限次扩展</td><td>abc+ 表示abc、abcc、abcc等</td></tr><tr><td>?</td><td>前一个字符0次或1攻扩展</td><td>abc? 表示ab、abc</td></tr><tr><td>|</td><td>左右表达式任意一个</td><td>abc|def 表示abc、def</td></tr><tr><td></td><td>扩展前一个字符m次</td><td>ab(2}c表示abbc</td></tr><tr><td></td><td>扩展前一个字符m至n次(含n)</td><td>ab{1,2}c表示abc、abbc</td></tr><tr><td>^</td><td>匹配字符串开头</td><td>^abc表示abc且在一个字符串的开头</td></tr><tr><td>$</td><td>匹配字符串结尾</td><td>abc$表示abc且在一个字符串的结尾</td></tr><tr><td>( )</td><td>分组标记,内部只能使用|操作符</td><td>(abc)表示abc ,(abc|def)表示abc、def</td></tr><tr><td>\d</td><td>数字,等价于[0-9]</td><td></td></tr><tr><td>\w</td><td>单词字符,等价于[A-Za-z0-9_ ]</td><td></td></tr></tbody></table> 
<h5 id="autoid-15-1-0">4.2 re库常用函数</h5> 
<table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>re.compile()</td><td>返回一个正则对象的模式。</td></tr><tr><td>re. search()</td><td>在一个字符串中搜素匹配正则表达式的第一个位置 ,返回match对象</td></tr><tr><td>re. match()</td><td>从一个字符串的开始位置起匹配正则表达式,返回match对象</td></tr><tr><td>re. findall()</td><td>搜索字符串,以列表类型返回全部能匹配的子串</td></tr><tr><td>re. split()</td><td>将一个字符串按照正则表达式匹配结果进行分割,返回列表类型</td></tr><tr><td>re. finditer()</td><td>擅索字符串。返回一个匹配结果的迭代类型，每个选代元素是match对象</td></tr><tr><td>re. sub()</td><td>在一个字符串中普换所有匹配正则表达式的子串,返回替换后的字符申</td></tr></tbody></table> 
<h6 id="autoid-15-2-0">4.2.1 compile()</h6> 
<p>格式：<code>re.compile(pattern[,flags=0])</code></p> 
<ul><li><code>pattern</code>: 编译时用的表达式字符串。</li><li><code>flags</code>: 编译标志位，用于修改正则表达式的匹配方式，如：re.I、re.S等</li></ul> 
<pre><code>import re
pat=re.compile("A")
m=pat.search("CBA") #等价于 re.search(A,CBA)
print(m)#&lt;re.Match object; span=(2, 3), match='A'&gt;  表示匹配到了

m=pat.search("CBD")
print(m)  #None 表示没匹配到
</code></pre> 
<h6 id="autoid-15-2-1">4.2.2 search()</h6> 
<ul><li>在字符串中寻找模式</li><li>格式：<code>re.search(pattern, string[, flags=0])</code></li><li>re.search函数会在字符串内查找模式匹配,只要找到第一个匹配然后返回，如果字符串没有匹配，则返回None。</li></ul> 
<pre><code>  import re
  m = re.search("asd" , "ASDasd" )
  print(m)# &lt;_sre.SRE_Match object at 0xb72cd6e8&gt;  #匹配到了，返回MatchObject（True）
  
  
  m = re.search("asd" , "ASDASD" )
  print(m)                                 #没有匹配到，返回None（False）
</code></pre> 
<h6 id="autoid-15-2-2">4.2.3 match()</h6> 
<ul><li>在字符串开始处匹配模式</li><li>格式：<code>re.match(pattern, string[, flags=0])</code></li></ul> 
<pre><code>import re
pat=re.compile( "a" ) 
print(pat.match( "Aasd" )) #输出None

pat=re.compile( "A" ) 
print(pat.match( "Aasd" )) #输出&lt;_sre.SRE_Match object; span=(0, 1), match='A'&gt;
</code></pre> 
<ul><li>注：match和search一旦匹配成功，就是一个match object对象，而match object对象有以下方法： 
  <ul><li>group() 返回被 RE 匹配的字符串</li><li>start() 返回匹配开始的位置</li><li>end() 返回匹配结束的位置</li><li>span() 返回一个元组包含匹配 (开始,结束) 的位置</li></ul></li></ul> 
<h6 id="autoid-15-2-3">4.2.3 findall()</h6> 
<ul><li>列表形式返回匹配项</li><li>格式：<code>re.findall(pattern, string[, flags=0])</code></li></ul> 
<pre><code>  import re
  #前面字符串是规则（正则表达式），后面字符串是被校验的字符串
  print(re.findall("a","ASDaDFGAa"))      
  #[a,a] 	#列表形式返回匹配到的字符串
  
  p = re.compile(r'\d+')
  print(p.findall('o1n2m3k4'))
  #执行结果如下：
  #['1', '2', '3', '4']
  
  print(re.findall("[A-Z]","ASDaDFGAa"))
  #[ A , S , D , D , F , G , A ] 
  
  print(re.findall("[A-Z]+","ASDaDFGAa"))
  #[ ASD , DFGA ]
  
  pat = re.compile("[A-Za-z]")
  print(pat.findall("ASDcDFGAa"))
  #[ A , S , D , c , D , F , G , A , a ]
</code></pre> 
<h6 id="autoid-15-2-4">4.2.4 re. split()</h6> 
<ul><li>按照能够匹配的子串将string分割后返回列表。</li><li>可以使用re.split来分割字符串，如：re.split(r’\s+’, text)；将字符串按空格分割成一个单词列表。</li><li>格式：<code>re.split(pattern, string[, maxsplit])</code> 
  <ul><li><code>maxsplit</code>: 用于指定最大分割次数，不指定将全部分割。</li></ul></li></ul> 
<pre><code>print(re.split('\d+','one1two2three3four4five5'))

# 执行结果如下：
# ['one', 'two', 'three', 'four', 'five', '']
</code></pre> 
<h6 id="autoid-15-2-5">4.2.5 finditer()</h6> 
<ul><li> <p>搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。</p> </li><li> <p>找到 RE 匹配的所有子串，并把它们作为一个迭代器返回。</p> </li><li> <p>格式：<code>re.finditer(pattern, string[, flags=0])</code></p> <pre><code>import re
iter = re.finditer(r'\d+','12 drumm44ers drumming, 11 ... 10 ...')
for i in iter:
    print(i)
    print(i.group())
    print(i.span())

'''
# 执行结果如下：
&lt;_sre.SRE_Match object; span=(0, 2), match='12'&gt;
12
(0, 2)
&lt;_sre.SRE_Match object; span=(8, 10), match='44'&gt;
44
(8, 10)
&lt;_sre.SRE_Match object; span=(24, 26), match='11'&gt;
11
(24, 26)
&lt;_sre.SRE_Match object; span=(31, 33), match='10'&gt;
10
(31, 33)
'''
</code></pre> </li></ul> 
<h6 id="autoid-15-2-6">4.2.6 sub()</h6> 
<ul><li> <p>格式：<code>re.sub(pattern, repl, string, count)</code></p> </li><li> <p>用repl替换 pattern匹配项</p> <pre><code>import re
print(re.sub(a,A,abcasd)) #找到a用A替换，后面见和group的配合使用
#AbcAsd  #第四个参数指替换个数。默认为0，表示每个匹配项都替换。

text = "JGood is a handsome boy, he is cool, clever, and so on..."
print(re.sub(r'\s+', '-', text)) #\s:空格
#JGood-is-a-handsome-boy,-he-is-cool,-clever,-and-so-on...
</code></pre> </li></ul> 
<h5 id="autoid-15-2-7">4.3 模式修正符</h5> 
<blockquote> 
 <p>所谓模式修正符，即可以在不改变正则表达式的情况下，通过模式修正符改变正则表达式的含义，从而实现一些匹配结果的调整等功能。</p> 
</blockquote> 
<table><thead><tr><th>修饰符</th><th>描述</th></tr></thead><tbody><tr><td>re.I</td><td>使匹配对大小写不敏感</td></tr><tr><td>re.L</td><td>做本地化识别（locale-aware）匹配</td></tr><tr><td>re.M</td><td>多行匹配，影响 ^ 和 $</td></tr><tr><td>re.S</td><td>使 . 匹配包括换行在内的所有字符</td></tr><tr><td>re.U</td><td>根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.</td></tr><tr><td>re.X</td><td>该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。</td></tr></tbody></table> 
<pre><code>import re
string = "Python"
pat = "pyt"
rst = re.search(pat,string,re.I) # 第三个参数
print(rst)#&lt;_sre.SRE_Match object; span=(0, 3), match='Pyt'&gt;</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/071edf7c1095dccd858b36095b3354be/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">设计模式学习（二）工厂模式——工厂方法模式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a7a1b8190468b7c95c54101750f1553f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用seq2seq架构实现英译法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>