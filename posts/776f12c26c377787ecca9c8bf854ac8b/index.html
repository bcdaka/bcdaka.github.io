<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;】—— 类与对象（五） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/776f12c26c377787ecca9c8bf854ac8b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;】—— 类与对象（五）">
  <meta property="og:description" content="【C&#43;&#43;】—— 类与对象（五） 1、类型转换1.1、类型转换介绍1.2、类型转换的应用1.3、explicit 关键字 2、static 静态成员2.1、static 静态成员变量2.2、static 静态成员函数2.3、总结 3、友元3.1、友元函数3.2、友元类 4.内部类5、匿名对象6、对象拷贝时的编译器优化6.1、情况一：类型转换6.2、情况二：传值传参6.3、情况三：传值返回 1、类型转换 1.1、类型转换介绍 我们知道，整型和浮点型之间可以发生隐式类型转换
int main() { int a = 2.2; cout &lt;&lt; a &lt;&lt; endl; return 0; } 运行结果：
int a = 2.2;这句代码，会发生隐式类型转换。中间生成一个临时对象，将右操作数强制类型转换为左操作数的类型，再将临时对象的值赋值给 a a a。
那么下面代码小伙伴们见过吗
class A { public : A(int a1) : _a1(a1) {} A(int a1, int a2) :_a1(a1) , _a2(a2) {} void Print() { cout &lt;&lt; _a1 &lt;&lt; &#34; &#34; &lt;&lt; _a2 &lt;&lt; endl; } private: int _a1 = 1; int _a2 = 2; }; int main() { A aa1(5); aa1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-13T22:02:35+08:00">
    <meta property="article:modified_time" content="2024-08-13T22:02:35+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】—— 类与对象（五）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>【C++】—— 类与对象（五）</h4> 
 <ul><li><a href="#1_2" rel="nofollow">1、类型转换</a></li><li><ul><li><a href="#11_3" rel="nofollow">1.1、类型转换介绍</a></li><li><a href="#12_102" rel="nofollow">1.2、类型转换的应用</a></li><li><a href="#13explicit__157" rel="nofollow">1.3、explicit 关键字</a></li></ul> 
  </li><li><a href="#2static__188" rel="nofollow">2、static 静态成员</a></li><li><ul><li><a href="#21static__189" rel="nofollow">2.1、static 静态成员变量</a></li><li><a href="#22static__248" rel="nofollow">2.2、static 静态成员函数</a></li><li><a href="#23_350" rel="nofollow">2.3、总结</a></li></ul> 
  </li><li><a href="#3_401" rel="nofollow">3、友元</a></li><li><ul><li><a href="#31_407" rel="nofollow">3.1、友元函数</a></li><li><a href="#32_461" rel="nofollow">3.2、友元类</a></li></ul> 
  </li><li><a href="#4_527" rel="nofollow">4.内部类</a></li><li><a href="#5_591" rel="nofollow">5、匿名对象</a></li><li><a href="#6_672" rel="nofollow">6、对象拷贝时的编译器优化</a></li><li><ul><li><a href="#61_714" rel="nofollow">6.1、情况一：类型转换</a></li><li><a href="#62_747" rel="nofollow">6.2、情况二：传值传参</a></li><li><a href="#63_805" rel="nofollow">6.3、情况三：传值返回</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1_2"></a>1、类型转换</h2> 
<h3><a id="11_3"></a>1.1、类型转换介绍</h3> 
<p>  我们知道，<strong>整型</strong>和<strong>浮点型</strong>之间可以发生<code>隐式类型转换</code></p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2.2</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>运行结果：</strong></p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/67/4f/rxbUgOXf_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  <code>int a = 2.2;</code>这句代码，会发生<code>隐式类型转换</code>。中间生成一个<code>临时对象</code>，将右操作数强制类型转换为左操作数的类型，再将临时对象的值赋值给 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
       
      
        a 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span></span>。<br>   <br> 那么下面代码小伙伴们见过吗</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span> <span class="token operator">:</span>

	<span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> a1<span class="token punctuation">)</span>
		<span class="token operator">:</span> <span class="token function">_a1</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	<span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> a1<span class="token punctuation">,</span> <span class="token keyword">int</span> a2<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_a1</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_a2</span><span class="token punctuation">(</span>a2<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> _a1 <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> _a2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _a1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> _a2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	A <span class="token function">aa1</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	aa1<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	A aa2 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	aa2<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>运行结果：</strong></p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/91/3b/hw3cTC8q_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  诶？是不是感觉怪怪的<br>   <code>A aa1(5);</code>很好理解，就是调用构造函数。那<code>A aa2 = 10;</code>又该怎么理解呢？是拷贝构造吗？如果是拷贝构造那不应该用同类的对象来初始化吗？怎么现在是一个整型呢？</p> 
<p>  <code>A aa2 = 10;</code>本质是一个<mark>类型转换</mark>，10 从一个整型转换成了 A 类，其用 <font color="red">10</font> 去 <font color="red">构造</font> 了一个<code>临时对象</code> <code>A类</code>，再通过<font color="red">拷贝构造</font>初始化 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
       
         a 
        
       
         2 
        
       
      
        aa2 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord mathnormal">aa</span><span class="mord">2</span></span></span></span></span></p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/c6/6a/hXgpqrbY_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  不过编译器会对上述过程<mark>进行优化</mark>，<code>优化为直接构造</code>。虽然语法意义上面是走上述步骤。<br>   </p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	A <span class="token function">aa1</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	aa1<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	A<span class="token operator">&amp;</span> aa1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  这样引用行不行呢？<br>   <mark>不行</mark>的，因为类型转换会产生一个<code>临时对象</code>，临时对象是<code>常性</code>。<br>   用 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         c 
        
       
         o 
        
       
         n 
        
       
         s 
        
       
         t 
        
       
      
        const 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6151em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span></span> 引用：<code>const A&amp; aa1 = 10;</code>就可以啦<br>   <br>   那多参数的可以吗？<br>   可以的，<mark>C++11</mark> 后<code>支持了多参数的类型转换</code><br>   <br> 调用方法如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	A aa1 <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	aa1<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/f1/cd/gEWEYcjb_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  <br>   </p> 
<h3><a id="12_102"></a>1.2、类型转换的应用</h3> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Stack</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>

	<span class="token keyword">void</span> <span class="token function">Push</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> aa<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//···</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	A _arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> _top<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>  现在，我们有一个栈，栈放着 A类 成员，怎么插入数据呢？</p> 
<p>  正常来讲是这样写</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Stack st<span class="token punctuation">;</span>

	A <span class="token function">aa1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	st<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span>aa1<span class="token punctuation">)</span><span class="token punctuation">;</span>

	A <span class="token function">aa2</span><span class="token punctuation">(</span><span class="token number">2</span>，<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	st<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span>aa2<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  有了类型转换后，我们就可以这样</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Stack st<span class="token punctuation">;</span>

	st<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	st<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  效果是一样的，但代码<strong>简洁</strong>了许多</p> 
<p>  这里 1 和 2.2 会构建一个<code>临时对象</code>，再将临时对象 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         P 
        
       
         u 
        
       
         s 
        
       
         h 
        
       
      
        Push 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span></span></span></span></span></p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/6b/10/N1gfLWrB_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  这里，也体现了加引用尽量加 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         c 
        
       
         o 
        
       
         n 
        
       
         s 
        
       
         t 
        
       
      
        const 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6151em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span></span> 的重要性。因为<code>临时对象具有常性</code>，不加 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         c 
        
       
         o 
        
       
         n 
        
       
         s 
        
       
         t 
        
       
      
        const 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6151em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span></span> 会造成<code>权限放大</code>，编译无法通过。<br>   <br>   </p> 
<h3><a id="13explicit__157"></a>1.3、explicit 关键字</h3> 
<p>  如果我们<code>不想让它发生类型转换</code>，可以增加 <mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          e 
         
        
          x 
         
        
          p 
         
        
          l 
         
        
          i 
         
        
          c 
         
        
          i 
         
        
          t 
         
        
       
         explicit 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right: 0.0197em;">pl</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span></span></span></span></span> 关键字</mark></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span> <span class="token operator">:</span>

	<span class="token keyword">explicit</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> a1<span class="token punctuation">)</span>
		<span class="token operator">:</span> <span class="token function">_a1</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

	<span class="token keyword">explicit</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> a1<span class="token punctuation">,</span> <span class="token keyword">int</span> a2<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_a1</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span>
		<span class="token punctuation">,</span> <span class="token function">_a2</span><span class="token punctuation">(</span>a2<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> _a1 <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> _a2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _a1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> _a2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/43/c0/9zHyApTJ_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  <br>   </p> 
<h2><a id="2static__188"></a>2、static 静态成员</h2> 
<h3><a id="21static__189"></a>2.1、static 静态成员变量</h3> 
<blockquote> 
 <ul><li>用 <mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            s 
           
          
            t 
           
          
            a 
           
          
            t 
           
          
            i 
           
          
            c 
           
          
         
           static 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span></span></span></span></span></mark> 修饰的成员变量，称之为<code>静态成员变量</code>，静态成员变量一定要在<font color="red"><strong>类外</strong>进行初始化</font></li><li>静态成员变量为<code>所有当前类对象所共享</code>，不属于某个具体的对象，<code>不存在对象中，存放在静态区</code></li></ul> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span> <span class="token operator">:</span>
	<span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token operator">++</span>_scount<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> 
	<span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> t<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token operator">++</span>_scount<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> 
	<span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token operator">--</span>_scount<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> 

<span class="token comment">//private:</span>
	<span class="token comment">// 类⾥⾯声明</span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> _scount<span class="token punctuation">;</span>

	<span class="token comment">// 声明时可以给缺省值吗？</span>
	<span class="token comment">//static int _scount = 0;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//在类外初始化</span>
<span class="token keyword">int</span> A<span class="token double-colon punctuation">::</span>_scount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//指定类域就可以访问_scount(公有情况下）</span>
	<span class="token comment">//因为_scount并不在某个对象中</span>
	<span class="token comment">//cout &lt;&lt; A::_scount &lt;&lt; endl;</span>

	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>运行结果：</strong></p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/18/69/46bNvZqR_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  上述代码中<code>static int _scount;</code>就是在类中定义了一个<strong>静态成员变量</strong>。</p> 
<p>  <code>int A::_scount = 1;</code>是 _<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         s 
        
       
         c 
        
       
         o 
        
       
         u 
        
       
         n 
        
       
         t 
        
       
      
        scount 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6151em;"></span><span class="mord mathnormal">sco</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span></span></span></span></span> 的声明，静态成员变量 <font color="red">一定要在类外声明</font></p> 
<p>  静态成员变量可以认为是<mark>全局变量</mark>，放在<code>静态区</code>，并不是存在类中（通过 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         s 
        
       
         i 
        
       
         z 
        
       
         e 
        
       
         o 
        
       
         f 
        
       
      
        sizeof 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">zeo</span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span></span></span></span></span> 也可看出），只是<code>受类域的限制，受访问限定符限制</code><br>   静态成员变量 <mark>在 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          m 
         
        
          a 
         
        
          i 
         
        
          n 
         
        
       
         main 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">main</span></span></span></span></span>函数 之前就开辟好了</mark>，并不随对象一起开辟<br>   可以通过直接指定类域区访问静态成员变量：<code>类名::静态成员</code>，因为它不是在某个对象中（公有情况下）</p> 
<p>  那在类中声明时，可以给缺省值吗？<br>   <mark>不可以</mark>，因为声明时的缺省值是给<code>初始化列</code>表用的，静态成员<code>变量不是存在类里面的，不走初始化列表。</code></p> 
<p>  <br>   </p> 
<h3><a id="22static__248"></a>2.2、static 静态成员函数</h3> 
<blockquote> 
 <ul><li>用 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           s 
          
         
           t 
          
         
           a 
          
         
           t 
          
         
           i 
          
         
           c 
          
         
        
          static 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span></span></span></span></span> 修饰的成员函数，称之为<mark>静态成员函数</mark>，<mark>静态成员函数<font color="red">没有 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             t 
            
           
             h 
            
           
             i 
            
           
             s 
            
           
          
            this 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span></span></span></span></span>指针</font></mark></li><li>静态成员函数<code>可以访问其他静态成员</code>，但是<code>不能访问非静态的</code>，因为没有 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           t 
          
         
           h 
          
         
           i 
          
         
           s 
          
         
        
          this 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span></span></span></span></span>指针</li><li>非静态的成员函数，可以<code>访问任意的静态成员变量和静态成员函数</code></li></ul> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span> <span class="token operator">:</span>
	<span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token operator">++</span>_scount<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> 
	<span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> t<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token operator">++</span>_scount<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> 
	<span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token operator">--</span>_scount<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> 

	<span class="token comment">//静态成员函数</span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">GetACount</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> _scount<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token comment">// 类⾥⾯声明</span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> _scount<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>  当静态成员变量是私有，就无法直接突破类域访问，这时就可以使用静态成员函数来访问。<br>   静态成员函数没有 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         t 
        
       
         h 
        
       
         i 
        
       
         s 
        
       
      
        this 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span></span></span></span></span>指针，因此<mark>只能访问静态成员变量</mark>。<br>   静态成员函数同样可以通过通过 <code>类名::静态函数</code> 访问；当然，也可以像普通成员函数那样通过 <code>对象.函数</code> 来访问</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> A<span class="token double-colon punctuation">::</span>_scount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">GetACount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	A a1<span class="token punctuation">,</span> a2<span class="token punctuation">;</span>
	A <span class="token function">a3</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">GetACount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> a1<span class="token punctuation">.</span><span class="token function">GetACount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>运行结果：</strong></p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/7c/e2/N9RwZRKb_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  </p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">GetACount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	A a1<span class="token punctuation">,</span> a2<span class="token punctuation">;</span>

	<span class="token punctuation">{<!-- --></span>
		A <span class="token function">a3</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">GetACount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	cout <span class="token operator">&lt;&lt;</span> a1<span class="token punctuation">.</span><span class="token function">GetACount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>运行结果：</strong></p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/ee/24/FuHM0BW3_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  上述代码利用静态成员变量来计算该对象实例化出多少个对象。</p> 
<p>  <font color="red">注</font>：在 C++ 中，任意一个 <code>{ }</code> 中的内容都<mark>单独形成一个域</mark>。<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
       
         3 
        
       
      
        a3 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord mathnormal">a</span><span class="mord">3</span></span></span></span></span> 是在域中创建，出了作用域就销毁</p> 
<p>  同时静态成员函数只能访问静态成员变量，因为静态成员函数没有 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         t 
        
       
         h 
        
       
         i 
        
       
         s 
        
       
      
        this 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span></span></span></span></span> 指针</p> 
<pre><code class="prism language-cpp">	<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">GetACount</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_a<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> _scount<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/f0/2d/agjJGHOG_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  但是<strong>非静态成员函数</strong>可以<code>随便访问静态成员变量和静态成员函数</code>，因为突破类域就可以访问静态成员，而非静态成员函数本来就在域中。</p> 
<p>  <br>   </p> 
<h3><a id="23_350"></a>2.3、总结</h3> 
<blockquote> 
 <ul><li>用 <mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            s 
           
          
            t 
           
          
            a 
           
          
            t 
           
          
            i 
           
          
            c 
           
          
         
           static 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span></span></span></span></span></mark> 修饰的成员变量，称之为<mark>静态成员变量</mark>，静态成员变量一定要在<code>类外初始化</code></li><li>静态成员是为<code>所有类对象所共</code>享，不属于某个具体的对象，不存在对象中，存放在<mark>静态区</mark></li><li>用 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           s 
          
         
           t 
          
         
           a 
          
         
           t 
          
         
           i 
          
         
           c 
          
         
        
          static 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6595em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span></span></span></span></span> 修饰的成员函数，称之为静态成员函数，<mark>静态成员函数<font color="red">没有<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
         
          
           
           
             t 
            
           
             h 
            
           
             i 
            
           
             s 
            
           
          
            this 
           
          
        </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span></span></span></span></span>指针</font></mark></li><li><code>静态成员函数</code>中<font color="red">可以</font>访问其他<code>静态成员</code>，但是<font color="red">不能</font>访问<code>非静态</code>的，因为没有 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           t 
          
         
           h 
          
         
           i 
          
         
           s 
          
         
        
          this 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span></span></span></span></span>指针</li><li><code>非静态的成员函数</code>，可以访问任意的<strong>静态成员变量</strong>和<strong>静态成员函数</strong></li><li>突破类yu就可以访问静态成员，可以通过 <code>类名::静态成员</code> 或者 <code>对象.静态成员</code> 来访问静态成员变量和静态成员函数</li><li>静态成员也是<code>类的成员</code>，受 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           p 
          
         
           u 
          
         
           b 
          
         
           l 
          
         
           i 
          
         
           c 
          
         
        
          public 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">c</span></span></span></span></span>、<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           p 
          
         
           r 
          
         
           o 
          
         
           t 
          
         
           e 
          
         
           c 
          
         
           t 
          
         
           e 
          
         
           d 
          
         
        
          protected 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span></span></span></span></span>、<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           p 
          
         
           r 
          
         
           i 
          
         
           v 
          
         
           a 
          
         
           t 
          
         
           e 
          
         
        
          private 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span></span></span></span></span> 访问限定符的限制</li><li>静态成员变量<code>不能在声明位置给缺省值初始化</code>，因为缺省值是用来给构造函数<code>初始化列表的</code>，静态成员变量不属于某个对象，不走构造函数初始化列表。</li></ul> 
</blockquote> 
<p>  <br> 设已经有A,B,C,D 4个类的定义，程序中A,B,C,D构造函数调用顺序为？（）<br> 设已经有A,B,C,D 4个类的定义，程序中A,B,C,D析构函数调用顺序为？（）</p> 
<pre><code class="prism language-cpp"><span class="token comment">//A：D B A C</span>
<span class="token comment">//B：B A D C</span>
<span class="token comment">//C：C D B A</span>
<span class="token comment">//D：A B D C</span>
<span class="token comment">//E：C A B D</span>
<span class="token comment">//F：C D A B</span>

C c<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	A a<span class="token punctuation">;</span>
	B b<span class="token punctuation">;</span>
	<span class="token keyword">static</span> D d<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <ol><li>选：<font color="red">E</font></li></ol> 
 <ul><li> <p>A、B、C的初始化顺序相信大家都没问题，那 D 是什么时候初始化呢？</p> </li><li> <p>局部的静态变量是在<mark>第一次运行到该位置</mark>才初始化</p> </li></ul> 
</blockquote> 
<blockquote> 
 <ol start="2"><li>选：<font color="red">B</font></li></ol> 
 <ul><li> <p>首先，对 B 和 A，后定义的先定义的先析构，B 肯定在 A 之前</p> </li><li> <p>因为 C 和 D 的声明周期是全局的，所以他们的析构肯定在 A 和 B 之后。再先析构 D，最后才是 C</p> </li></ul> 
</blockquote> 
<p>  <br>   </p> 
<h2><a id="3_401"></a>3、友元</h2> 
<p>  友元提供了一种<mark>突破访问限定符封装的方式</mark>，友元分为：<code>友元函数</code>和<code>友元类</code>，在函数声明或类声明前加关键字 <mark><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          f 
         
        
          r 
         
        
          i 
         
        
          e 
         
        
          n 
         
        
          d 
         
        
       
         friend 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.1076em;">f</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span></span></span></span></span></mark>，并且把友元声明放到一个类的里面</p> 
<h3><a id="31_407"></a>3.1、友元函数</h3> 
<p>  有些情况，函数无法定义在类里面(如：不想 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         t 
        
       
         h 
        
       
         i 
        
       
         s 
        
       
      
        this 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span></span></span></span></span>指针放在第一个参数位置)，但是函数又必须访问类中的成员变量（<code>operator&lt;&lt;</code>详情情看：）。<br>   怎么办呢？这时 C++ 提供了<mark>友元</mark>这种<code>突破访问限定符的方式</code>。让<code>类外的函数可以访问类中私有的成员变量</code></p> 
<p>  打个比方：小刚家有个大泳池，小明一直想去小刚家里游泳，但他们两人并不熟，这时小明肯定无法去游的。怎么办呢？小明选择和小刚交往，成为小刚的朋友，这时小明就可以去小刚家游泳啦<br>   <br> 友元函数的基本知识：</p> 
<blockquote> 
 <ul><li><code>外部友元函数可以访问类的私有和保护成员</code>，友元函数仅仅是一种<mark>声明</mark>，他不是类的成员函数</li><li>友元函数可以在类定义的任何地方声明，<mark>不受<font color="red">类访问限定符</font>的限制</mark></li><li>一个函数可以是<code>多个</code>类的友元函数</li></ul> 
</blockquote> 
<p>  友元声明没有明确规定放在哪个位置，但一般都是放在类的最上面</p> 
<pre><code class="prism language-cpp"><span class="token comment">// 前置声明，都则A的友元函数声明编译器不认识B</span>
<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 友元声明</span>
	<span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> aa<span class="token punctuation">,</span> <span class="token keyword">const</span> B<span class="token operator">&amp;</span> bb<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _a1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> _a2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 友元声明</span>
	<span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">const</span> A <span class="token operator">&amp;</span> aa<span class="token punctuation">,</span> <span class="token keyword">const</span> B <span class="token operator">&amp;</span> bb<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _b1 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> _b2 <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> aa<span class="token punctuation">,</span> <span class="token keyword">const</span> B<span class="token operator">&amp;</span> bb<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> aa<span class="token punctuation">.</span>_a1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> bb<span class="token punctuation">.</span>_b1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  <strong>一个函数可以成为多个类的友元</strong>（我多交几个朋友不过分吧）</p> 
<p><font color="red">注</font>：编译器有一个原则：<code>我要用任何类型的变量都要向上找</code>。上述代码要给 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         c 
        
       
         l 
        
       
         a 
        
       
         s 
        
       
         s 
        
       
      
        class 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal">ss</span></span></span></span></span> B 一个前置声明，否则<code>friend void func(const A&amp; aa, const B&amp; bb);</code>中 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         c 
        
       
         l 
        
       
         a 
        
       
         s 
        
       
         s 
        
       
      
        class 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal">ss</span></span></span></span></span> A 不认识<code> const B&amp; bb</code>中的 B。</p> 
<p>  <br>   </p> 
<h3><a id="32_461"></a>3.2、友元类</h3> 
<p>友元类的基本知识：</p> 
<blockquote> 
 <ul><li>友元类中的成员函数<mark>都是</mark>另一个类的友元函数，都可以访问另一个类中的私有和保护成员。</li><li>友元类的关系是<mark>单向</mark>的，不具有交换性，比如 A 类是 B 类的友元，但是 B 类不是 A 类的友元。</li><li><mark>友元关系不能传递</mark>，如果 A 是 B 的友元，B 是 C 的友元，但是 A 不是 B 的友元。</li></ul> 
</blockquote> 
<p>  <br>   当一个类需要大量的去访问另外一个类，如果仅仅是把成员函数定义成别人的友元会很不方便，这时就可以使用友元类。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 友元声明</span>
	<span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">;</span>
    
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _a1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> _a2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span> <span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> aa<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> aa<span class="token punctuation">.</span>_a1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> _b1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	
	<span class="token punctuation">}</span> 
	<span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> aa<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> aa<span class="token punctuation">.</span>_a2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
			cout <span class="token operator">&lt;&lt;</span> _b2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _b1 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> _b2 <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	A aa<span class="token punctuation">;</span>
	B bb<span class="token punctuation">;</span>
	bb<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span>aa<span class="token punctuation">)</span><span class="token punctuation">;</span>
	bb<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span>aa<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>运行结果：</strong></p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/95/13/ICy7OFFJ_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  友元类就是：<strong>我的所有成员函数都是你的友元函数</strong></p> 
<p>  友元类是<mark>单向性</mark>的，上述代码 B 是 A 的友元，但 A 不是 B 的友元，A 是不能访问 B 中的成员变量的。如果 A 的成员函数也想访问 B 中的成员变量，可以在 B 中加入 A 的友元声明，这样就可以互相访问啦。</p> 
<ul><li>虽然友元提供了便利，但是<mark>友元会<font color="red">增加耦合度</font></mark>，破坏了封装，所以<code>友元不宜多用</code></li></ul> 
<p>  <br>   </p> 
<h2><a id="4_527"></a>4.内部类</h2> 
<p>  我们能不能把一个类定义在另一个类的里面呢？可以的，这就是<mark>内部类</mark></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span> <span class="token operator">:</span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> _k<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _h <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">class</span> <span class="token class-name">B</span> 
	<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span> <span class="token operator">:</span>
		<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">const</span> A <span class="token operator">&amp;</span> a<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> _k <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> 
			cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">.</span>_h <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> 
		<span class="token punctuation">}</span>
    <span class="token keyword">private</span><span class="token operator">:</span>
		<span class="token keyword">int</span> _b<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  上述代码中 <code>B 就是 A 的内部类</code></p> 
<p>  那么问题来了，A 的大小是多少呢？它的大小会算上 B 类的大小吗？</p> 
<p>我们来看下运行结果：</p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/d4/61/CakqF3ZD_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  可以看到 A 的大小是<code>不计算</code> B 的</p> 
<blockquote> 
 <ul><li>如果一个类定义在另一个类的内部，这个内部类就叫做<mark>内部类</mark>。<mark>内部类是一个<font color="red">独立的类</font></mark>，跟定义在全局相比，他只受外部类<code>类域限制和访问限定符限制</code>，所以外部类定义的对象中 <mark><font color="red">不包含</font>内部类</mark>。</li></ul> 
</blockquote> 
<p>  因为内部类受到外部类的限制，所以访问内部类B需要<code>指定类域</code><br>   它也<code>受 A 访问限定符的限制</code>，如果 B 定义在 A 的私有，那么外面就无法访问到 B 了。</p> 
<blockquote> 
 <ul><li><strong>内部类默认是外部类的 <mark>友元类</mark></strong></li></ul> 
</blockquote> 
<p>  也就是说默认 <mark>B 是 A 的友元</mark>，B 可以直接访问 A 的私有，但 A 无法访问 B 的私有</p> 
<blockquote> 
 <ul><li>内部类本质也是一种<mark>封装</mark>，当 A 类和 B 类<mark>紧密关联</mark>，<code>A 类实现出来主要就是给 B 类使用，那么可以考虑把 A 类设计为 B 的内部类</code>，如果放到 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           p 
          
         
           r 
          
         
           i 
          
         
           v 
          
         
           a 
          
         
           t 
          
         
           e 
          
         
           / 
          
         
           p 
          
         
           r 
          
         
           o 
          
         
           t 
          
         
           e 
          
         
           c 
          
         
           t 
          
         
           e 
          
         
           d 
          
         
        
          private/protected 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right: 0.0359em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord">/</span><span class="mord mathnormal">p</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span></span></span></span></span> 位置，那么 A 类就是 B 类的专属内部类，其他地方都用不了</li></ul> 
</blockquote> 
<p>  <br>   </p> 
<h2><a id="5_591"></a>5、匿名对象</h2> 
<p>  之前我们实例化对象不传参是这样的</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	A aa1<span class="token punctuation">;</span>
	
	<span class="token comment">//不能这样</span>
	<span class="token comment">//因为分不清是实例化还是函数声明</span>
	A <span class="token function">aa2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  但是 C++ 还可以这样定义对象</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//传参</span>
	<span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//不传参</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  这样实例化出的是<mark>匿名对象</mark>，而我们之前定义的对象，叫做<mark>有名对象</mark></p> 
<blockquote> 
 <ul><li>匿名对象的<code>声明周期</code>只有<mark>当前这一行</mark>。一般临时定义一个对象当前用一下即可，就可以定义匿名对象</li></ul> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">int</span> <span class="token function">Sum_Solution</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> 
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//...</span>
		<span class="token keyword">return</span> n<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Solution aa1<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> aa1<span class="token punctuation">.</span><span class="token function">Sum_Solution</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	cout <span class="token operator">&lt;&lt;</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Sum_Solution</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  如：想调用 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         S 
        
       
         u 
        
       
         m 
        
       
      
        Sum 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span></span></span></span></span><em><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          S 
         
        
          o 
         
        
          l 
         
        
          u 
         
        
          t 
         
        
          i 
         
        
          o 
         
        
          n 
         
        
       
         Solution 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span></span></span></span></span> 函数，但 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          S 
         
        
          u 
         
        
          m 
         
        
       
         Sum 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span></span></span></span></span></em><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         S 
        
       
         o 
        
       
         l 
        
       
         u 
        
       
         t 
        
       
         i 
        
       
         o 
        
       
         n 
        
       
      
        Solution 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span></span></span></span></span> 是成员函数，因此正常来讲应定义一个有名对象，才能调用。但难免有些繁琐，毕竟这里定义对象仅仅是为了调用 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         S 
        
       
         u 
        
       
         m 
        
       
      
        Sum 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span></span></span></span></span>_<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         S 
        
       
         o 
        
       
         l 
        
       
         u 
        
       
         t 
        
       
         i 
        
       
         o 
        
       
         n 
        
       
      
        Solution 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0576em;">S</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span></span></span></span></span> 函数。这时，我们就可以使用<code>匿名对象</code>，这样就方便多了。</p> 
<p>  简单来理解，匿名对象没有其他的，就是为了<code>更方便</code>一点</p> 
<p>  但是，对匿名对象进行<mark>引用</mark>可以<code>延长</code>匿名对象的<code>生命周期</code></p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//匿名对象是常性，用const引用</span>
	<span class="token keyword">const</span> Solution<span class="token operator">&amp;</span> a <span class="token operator">=</span> <span class="token function">Solution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  <br>   </p> 
<h2><a id="6_672"></a>6、对象拷贝时的编译器优化</h2> 
<blockquote> 
 <ul><li>现代编译器为了尽可能<mark>提高程序的效率</mark>，在<mark>不影响正确性</mark>的情况下会尽可能<mark>减少一些<font color="red">传参</font>和<font color="red">传参过程</font>中可以省略的拷贝</mark></li><li>如何优化 C++ 标准并没有严格规定，各个编译器会根据情况<code>自行处理</code>。当前主流的相对新一点的编译器对于<code>连续一个表达式步骤中的连续拷贝会进行合并优化</code>，有些更新更“激进”的编译还会进行跨行跨表达式的合并优化</li></ul> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span> <span class="token operator">:</span>
	<span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token operator">:</span> <span class="token function">_a1</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A(int a)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> 

	<span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> aa<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_a1</span><span class="token punctuation">(</span>aa<span class="token punctuation">.</span>_a1<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A(const A&amp; aa)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> 

	A<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> aa<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A&amp; operator=(const A&amp; aa)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>aa<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			_a1 <span class="token operator">=</span> aa<span class="token punctuation">.</span>_a1<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> 
		<span class="token keyword">return</span><span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> 

	<span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~A()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _a1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="61_714"></a>6.1、情况一：类型转换</h3> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	A aa1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  从<strong>语法</strong>上来说，上述代码会发生<code>隐式类型转换</code>。<br>   先用 1 <code>构造</code>一个临时对象 A类；再调用<code>拷贝构造</code>，将临时对象赋值给 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
       
         a 
        
       
         1 
        
       
      
        aa1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord mathnormal">aa</span><span class="mord">1</span></span></span></span></span></p> 
<p><strong>运行结果：</strong></p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/85/b5/GYWfSgRF_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  可以看到，经过编译器的优化，实际运行结果<code>只有构造</code>，并没有调用拷贝构造。</p> 
<p>  因为编译器认为构造一个临时对象，马上进行拷贝，中间的临时对象什么都没做，太浪费效率。因此<code>省略了中间的临时对象</code>，直接构造 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
       
         a 
        
       
         1 
        
       
      
        aa1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord mathnormal">aa</span><span class="mord">1</span></span></span></span></span>。</p> 
<p>  但下面这种情况就无法省略临时对象</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//引用的是构造的临时对象</span>
	<span class="token keyword">const</span> A<span class="token operator">&amp;</span> aa2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  <br>   </p> 
<h3><a id="62_747"></a>6.2、情况二：传值传参</h3> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span>A aa<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	A <span class="token function">aa1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">f1</span><span class="token punctuation">(</span>aa1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  我们知道，对<strong>自定义类型</strong>，传值传参要先调用其<code>拷贝构造</code>，那上述代码有发生优化吗？</p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/92/a9/zR379AqV_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  没有，因为构造与拷贝构造并<code>没有发生在一个连续的步骤中</code>，所以编译器并没有选择优化</p> 
<p>那如果我使用<code>匿名对象</code>呢？</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span>A aa<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">f1</span><span class="token punctuation">(</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  这样构造和拷贝构造就是在一个连续的表达式的调用里面了</p> 
<p><strong>运行结果：</strong></p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/ae/7e/t2dN7BSG_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  按语法逻辑来说，应该是先调用<code>构造函数</code>构造匿名对象，再传值传参调用<code>拷贝构造</code><br>   现在，经过译器的优化，直接合二为一，只剩下<code>构造</code>。</p> 
<p><font color="red">注</font>：调用析构函数是在出函数作用域调的，不是程序结束。虽然过程合二为一，但它还是局部变量。<br>   </p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">f1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/45/f7/e9SNh953_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  这也是同理。<br>   <br>   </p> 
<h3><a id="63_805"></a>6.3、情况三：传值返回</h3> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span> <span class="token operator">:</span>
	<span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token operator">:</span> <span class="token function">_a1</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A(int a)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> 

	<span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> aa<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_a1</span><span class="token punctuation">(</span>aa<span class="token punctuation">.</span>_a1<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A(const A&amp; aa)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> 

	A<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> aa<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A&amp; operator=(const A&amp; aa)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>aa<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			_a1 <span class="token operator">=</span> aa<span class="token punctuation">.</span>_a1<span class="token punctuation">;</span>
		<span class="token punctuation">}</span> 
		<span class="token keyword">return</span><span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> 

	<span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~A()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A::Print-&gt;"</span> <span class="token operator">&lt;&lt;</span> _a1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _a1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>  从语法上来说，传值返回会先将返回值<code>拷贝到一个临时对象中</code>，再将临时对象<code>拷贝</code>给函数外接收的变量<br>   那么经过编译器优化又会是什么结果呢？</p> 
<pre><code class="prism language-cpp">A <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	A <span class="token function">aa</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> aa<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  这里我没有选择接收，而是用产生的临时对象取调用 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         P 
        
       
         r 
        
       
         i 
        
       
         n 
        
       
         t 
        
       
      
        Print 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span></span></span></span></span> 函数</p> 
<p><strong>VS2019 运行结果：</strong></p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/a7/2b/1dqK5ndP_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  在VS2019中：先<code>构造</code>生成 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
       
         a 
        
       
      
        aa 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">aa</span></span></span></span></span> ，后调用<code>拷贝构造</code>产生临时对象。此时出函数作用域，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
       
         a 
        
       
      
        aa 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">aa</span></span></span></span></span> 生命周期结束，调用析构函数析构 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
       
         a 
        
       
      
        aa 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">aa</span></span></span></span></span>。临时对象调用 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         P 
        
       
         r 
        
       
         i 
        
       
         n 
        
       
         t 
        
       
      
        Print 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span></span></span></span></span> 函数后，生命周期结束(临时对象声明周期只在当前行)，调用析构函数。<br>   </p> 
<p><strong>VS2022运行结果：</strong></p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/b9/c2/oBXBjnmb_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  可以看到，VS2022的优化是比较<strong>激进</strong>的。<br>   那他是没有生成临时对象还是没有生成 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
       
         a 
        
       
      
        aa 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">aa</span></span></span></span></span> 呢？严格来说是没有生成 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
       
         a 
        
       
      
        aa 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">aa</span></span></span></span></span> <code>只生成了临时对象</code>。为什么呢？我们可以看到析构函数的调用是在 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         P 
        
       
         r 
        
       
         i 
        
       
         n 
        
       
         t 
        
       
      
        Print 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span></span></span></span></span> 函数之后，此时已经出了函数作用域了。</p> 
<p>  编译器优化这么“激进”不怕出 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         b 
        
       
         u 
        
       
         g 
        
       
      
        bug 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right: 0.0359em;">ug</span></span></span></span></span> 吗？<br>   我们重载一个 ++，再看它优不优化</p> 
<pre><code class="prism language-cpp"><span class="token comment">//前置++重载</span>
<span class="token comment">//A&amp; operator++()</span>
<span class="token comment">//{<!-- --></span>
<span class="token comment">//	++_a1;</span>
<span class="token comment">//	return *this;</span>
<span class="token comment">//}</span>

A <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	A <span class="token function">aa</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token operator">++</span>aa<span class="token punctuation">;</span><span class="token comment">//加1，看你还优不优化</span>
	<span class="token keyword">return</span> aa<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/f2/53/msjDoSiY_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  可以看到，优化还是这么激进，可<code>结果居然是对的</code>。<br>   只能说确实牛。</p> 
<p>  那如果我选择接收呢？</p> 
<pre><code class="prism language-cpp">A <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	A <span class="token function">aa</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token operator">++</span>aa<span class="token punctuation">;</span>

	<span class="token keyword">return</span> aa<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	A ret <span class="token operator">=</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ret<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>运行结果：</strong></p> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/ff/1b/ZyLrigWa_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<p>  现在不仅仅是省略掉了 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
       
         a 
        
       
      
        aa 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">aa</span></span></span></span></span>，连临时对象都省略掉了，合三为一。直接将结果算好，再用 2 去构造 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         r 
        
       
         e 
        
       
         t 
        
       
      
        ret 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6151em;"></span><span class="mord mathnormal">re</span><span class="mord mathnormal">t</span></span></span></span></span>，连 ++ 都考虑了。<br>   不过这是 VS2022 太强了，一般的编译器走：<code>构造-&gt;拷贝构造-&gt;拷贝构造</code> 或者 <code>构造-&gt;拷贝构造</code> 才是正常的。即不优化和优化一级是正常的，像 VS2022 这种优化两级的只能说变态。<br>   <br>   <br>   <br>   <br>   </p> 
<hr> 
<p>  <em><font color="orange">好啦，本期关于类和对象的知识就介绍到这里啦，希望本期博客能对你有所帮助。同时，如果有错误的地方请多多指正，让我们在C语言的学习路上一起进步！</font></em></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/04ac44ebb86858e113a6ede14212ec49/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CSS 垂直居中显示的方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/89fc9ffc4791370344b02b1df972a7d4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Datawhale X 魔搭 AI夏令营第四期 魔搭-AIGC方向 task02笔记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>