<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数学建模——评价决策类算法（熵权法、模糊综合评价） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/6e18c9f0ee86fdb0723153e80460f531/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数学建模——评价决策类算法（熵权法、模糊综合评价）">
  <meta property="og:description" content="一、熵权法（求解权重） 概念原理 代码 import numpy as np # 导入numpy库，并简称为np # 定义一个自定义的对数函数mylog，用于处理输入数组中的零元素 def mylog(p): n = len(p) # 获取输入向量p的长度 lnp = np.zeros(n) # 创建一个长度为n，元素都为0的新数组lnp for i in range(n): # 对向量p的每一个元素进行循环 if p[i] == 0: # 如果当前元素的值为0 lnp[i] = 0 # 则在lnp中对应位置也设置为0，因为log(0)是未定义的，这里我们规定为0 else: lnp[i] = np.log(p[i]) # 如果p[i]不为0，则计算其自然对数并赋值给lnp的对应位置 return lnp # 返回计算后的对数数组 # 定义一个指标矩阵X X = np.array([[9, 0, 0, 0], [8, 3, 0.9, 0.5], [6, 7, 0.2, 1]]) # 对矩阵X进行标准化处理，得到标准化矩阵Z Z = X / np.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-13T18:04:32+08:00">
    <meta property="article:modified_time" content="2024-08-13T18:04:32+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数学建模——评价决策类算法（熵权法、模糊综合评价）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、熵权法（求解权重）</h3> 
<h4>概念原理</h4> 
<p><img alt="" height="850" src="https://images2.imgbox.com/cc/cc/e3AfkrC5_o.png" width="1200"></p> 
<h4> 代码</h4> 
<pre><code class="language-python">import numpy as np  # 导入numpy库，并简称为np

# 定义一个自定义的对数函数mylog，用于处理输入数组中的零元素
def mylog(p):
    n = len(p)  # 获取输入向量p的长度
    lnp = np.zeros(n)  # 创建一个长度为n，元素都为0的新数组lnp
    for i in range(n):  # 对向量p的每一个元素进行循环
        if p[i] == 0:  # 如果当前元素的值为0
            lnp[i] = 0  # 则在lnp中对应位置也设置为0，因为log(0)是未定义的，这里我们规定为0
        else:
            lnp[i] = np.log(p[i])  # 如果p[i]不为0，则计算其自然对数并赋值给lnp的对应位置
    return lnp  # 返回计算后的对数数组

# 定义一个指标矩阵X
X = np.array([[9, 0, 0, 0], [8, 3, 0.9, 0.5], [6, 7, 0.2, 1]])

# 对矩阵X进行标准化处理，得到标准化矩阵Z
Z = X / np.sqrt(np.sum(X*X, axis=0))

print("标准化矩阵 Z = ")
print(Z)  # 打印标准化矩阵Z

# 计算熵权所需的变量和矩阵初始化
n, m = Z.shape  # 获取标准化矩阵Z的行数和列数
D = np.zeros(m)  # 初始化一个长度为m的数组D，用于保存每个指标的信息效用值

# 计算每个指标的信息效用值
for i in range(m):  # 遍历Z的每一列
    x = Z[:, i]  # 获取Z的第i列，即第i个指标的所有数据
    p = x / np.sum(x)  # 对第i个指标的数据进行归一化处理，得到概率分布p
    # 使用自定义的mylog函数计算p的对数。需要注意的是，如果p中含有0，直接使用np.log会得到-inf，这里使用自定义函数避免这个问题
    e = -np.sum(p * mylog(p)) / np.log(n)  # 根据熵的定义计算第i个指标的信息熵e
    D[i] = 1 - e  # 根据信息效用值的定义计算D[i]

# 根据信息效用值计算各指标的权重
W = D / np.sum(D)  # 将信息效用值D归一化，得到各指标的权重W

print("权重 W = ")
print(W)  # 打印得到的权重数组W</code></pre> 
<h3>二、模糊综合评价</h3> 
<h4>原理概念</h4> 
<p>        现实中的许多现象及关系比较模糊。如高与矮， 长与短，大与小，多与少，穷与富，好与差， 年轻与年老等。这类现象不满足“非此即彼”的排中律，而具有“亦此亦彼”的模糊性。 需要指出的是，模糊不确定不同于随机不确定。 随机不确定是因果律破损造成的不确定，而模糊不确定是由于排中律破损造成的不确定。</p> 
<p>传统集合是指具有相同属性的事物的集体，如正整数集合，具有如下性质：</p> 
<p>互异性：集合中任意两个元素都是不同的对象，如{ 1 1 2}和{1 2}这两个集合是等价的</p> 
<p>逻辑性：每一个对象都能确定是不是某一集合的元素，这个性质主要用于判断一个集合是否能形成集合</p> 
<p>独立性：集合的基数、集合本身的个数必须为自然数</p> 
<p>无序性：{a b c}和{c b a}是同一个集合</p> 
<p>纯粹性：所谓集合的纯粹性，用个例子来表示，集合A={x|x&lt;2}，集合A 中所有的元素都要符合x&lt;2</p> 
<p>完备性：仍用上面的例子，所有符合x&lt;2的数都在集合A中</p> 
<p>传统集合的特征函数</p> 
<p><img alt="" height="482" src="https://images2.imgbox.com/73/45/9gQ2Lk9B_o.png" width="1200"></p> 
<p>         模糊集合用来描述形容高矮胖瘦这种没有明确指标的模糊性问题。不具有传统集合的互异性， 而是“亦此亦彼”的。</p> 
<p>模糊集合的隶属函数</p> 
<p><img alt="" height="658" src="https://images2.imgbox.com/d6/fb/ZPhbiVKL_o.png" width="1200"></p> 
<p>模糊集合的表示方法</p> 
<p><img alt="" height="520" src="https://images2.imgbox.com/d4/41/9lvof6G8_o.png" width="1200"><img alt="" height="562" src="https://images2.imgbox.com/16/84/vfaCNL0z_o.png" width="1200"></p> 
<p>模糊集与特征函数的关系</p> 
<p><img alt="" height="620" src="https://images2.imgbox.com/c6/d4/2RSthrTT_o.png" width="1200"> <img alt="" height="822" src="https://images2.imgbox.com/47/13/MCAEW7w5_o.png" width="1200"></p> 
<p>F分布确定隶属函数</p> 
<p><img alt="" height="639" src="https://images2.imgbox.com/c7/0f/Alinp7Uk_o.png" width="894"></p> 
<p><img alt="" height="613" src="https://images2.imgbox.com/a0/51/3X52vrTO_o.png" width="899"></p> 
<p><img alt="" height="645" src="https://images2.imgbox.com/07/f6/SGbMBehs_o.png" width="894"></p> 
<h4>代码 </h4> 
<pre><code class="language-python">import numpy as np

# 1、一级模糊综合评判
# 影响运行费用的各因素的单因素评价矩阵为：
R23 = np.array([
     [0.18, 0.14, 0.18, 0.14, 0.13, 0.23],
     [0.15, 0.20, 0.15, 0.25, 0.10, 0.15],
     [0.25, 0.12, 0.13, 0.12, 0.18, 0.20],
     [0.16, 0.15, 0.21, 0.11, 0.20, 0.17],
     [0.23, 0.18, 0.17, 0.16, 0.15, 0.11],
     [0.19, 0.13, 0.12, 0.12, 0.11, 0.33],
     [0.17, 0.16, 0.15, 0.08, 0.25, 0.19]])
# 权重分配为
A23 = np.array([0.20, 0.15, 0.10, 0.10, 0.20, 0.15, 0.10])
# 评价结果
# np.dot是Numpy库中的一个函数，用于计算两个数组的点积。对于一维数组，它计算的是这两个数组的内积。
# 对于二维数组（矩阵），它计算的是矩阵乘法。
B23 = np.dot(A23, R23)

# 2、二级模糊综合评判
# 产品情况的二级评判如下：
R1 = np.array([
    [0.12, 0.18, 0.17, 0.23, 0.13, 0.17],
    [0.15, 0.13, 0.18, 0.25, 0.12, 0.17],
    [0.14, 0.13, 0.16, 0.18, 0.20, 0.19],
    [0.12, 0.14, 0.15, 0.17, 0.19, 0.23],
    [0.16, 0.12, 0.13, 0.25, 0.18, 0.16]])
A1 = np.array([0.15, 0.40, 0.25, 0.10, 0.10])
B1 = np.dot(A1, R1)
# 销售能力二级评判如下：
R2 = np.array([
    [0.13, 0.15, 0.14, 0.18, 0.16, 0.25],
    [0.12, 0.16, 0.13, 0.17, 0.19, 0.23],
    B23,
    [0.14, 0.13, 0.15, 0.16, 0.18, 0.24],
    [0.16, 0.15, 0.15, 0.17, 0.18, 0.19]])
A2 = np.array([0.2, 0.15, 0.25, 0.25, 0.15])
B2 = np.dot(A2, R2)

# 市场需求的二级评判
R3 = np.array([
    [0.15, 0.14, 0.13, 0.18, 0.14, 0.26],
    [0.16, 0.15, 0.18, 0.14, 0.16, 0.21]])
A3 = np.array([0.55, 0.45])
B3 = np.dot(A3, R3)

# 3、三级模糊综合评判
R = np.array([B1, B2, B3])
A = np.array([0.4, 0.3, 0.3])
B = np.dot(A, R)

print(B)
</code></pre> 
<h4> 例题</h4> 
<p>例题：某公司计划推出一款新产品，为了评估该产品的市场潜力，公司希望通过模糊综合评价算法对产品进行评价。评价指标包括：市场需求、技术成熟度、成本控制、用户体验。评价集分为：很高、较高、一般、较低、很低。</p> 
<p>步骤1：建立评价指标集和评价集</p> 
<p>评价指标集U： U = {市场需求，技术成熟度，成本控制，用户体验}</p> 
<p>评价集V： V = {很高，较高，一般，较低，很低}</p> 
<p>步骤2：确定各指标的权重</p> 
<p>假设通过专家打分法，得到各指标的权重向量W： W = [0.3, 0.25, 0.2, 0.25]</p> 
<p>步骤3：建立模糊评价矩阵</p> 
<p>通过调查问卷或专家评分，得到各指标在不同评价等级上的隶属度，构建模糊评价矩阵R。</p> 
<p>R = [[0.2, 0.5, 0.2, 0.1, 0],<br>      [0.4, 0.4, 0.1, 0.1, 0],<br>      [0.1, 0.3, 0.4, 0.2, 0],<br>      [0.3, 0.4, 0.2, 0.1, 0]]</p> 
<p>步骤4：进行模糊综合评价</p> 
<p>使用模糊综合评价算法计算评价结果B。</p> 
<p>B = W * R</p> 
<p>步骤5：对评价结果进行解释</p> 
<p>根据评价结果B，对新产品进行综合评价。</p> 
<p>下面是Python代码实现：</p> 
<pre><code class="language-python">import numpy as np

# 指标权重
W = np.array([0.3, 0.25, 0.2, 0.25])

# 模糊评价矩阵
R = np.array([[0.2, 0.5, 0.2, 0.1, 0],
              [0.4, 0.4, 0.1, 0.1, 0],
              [0.1, 0.3, 0.4, 0.2, 0],
              [0.3, 0.4, 0.2, 0.1, 0]])

# 模糊综合评价
B = np.dot(W, R)

# 归一化评价结果
B_normalized = B / np.sum(B)

# 输出评价结果
print("新产品综合评价结果：")
print("很高：{:.2f}, 较高：{:.2f}, 一般：{:.2f}, 较低：{:.2f}, 很低：{:.2f}".format(*B_normalized))
</code></pre> 
<p>        运行上述代码，将输出新产品的综合评价结果，这个结果反映了新产品在各个评价等级上的综合表现。根据这个结果，公司可以决定是否推出新产品，或者对产品进行进一步的改进。 </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3b7522ac48262ff07ba64680327a3a94/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【CentOS 】DHCP 更改为静态 IP 地址并且遇到无法联网</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5fa3f42eee1c2bde0e487c19ddd71d37/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">socket和websocket 有什么区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>