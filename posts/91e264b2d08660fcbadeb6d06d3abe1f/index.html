<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>FloodFill算法---DFS - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/91e264b2d08660fcbadeb6d06d3abe1f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="FloodFill算法---DFS">
  <meta property="og:description" content="目录
floodfill算法概念：
算法模板套路： 例题1：图像渲染
例题2：岛屿数量
例题3：岛屿的最大面积
例题4：被围绕的区域
floodfill算法概念： floodfill算法是一种常用的图像处理算法，用于填充连通区域。它从指定的种子点开始，将相邻的像素点按照某种条件进行填充，直到所有符合条件的像素点都被填充为止。floodfill算法常用于图像处理中的填充、边界提取、区域分割等任务。它可以用于实现画图工具中的油漆桶工具，也可以用于图像分割中的区域填充。
floodfill算法的中文名为洪水灌溉算法，基本实现内容：从某个点开始向四周扩散，直到无法再扩散为止。（可以使用DFS和BFS，本文讲解DFS解决）从这个实现内容我们不难发现这很适合我们利用爆搜来实现（一般数据范围不会太大）。如下图数字为1的就是一个性质相同的连通块。这类问题通常会问我们1的最大联通块是多大？或者有几个1的连通块？使用floodfill算法解决的题目基本一眼就能看得出来，不想滑动窗口和动态规划之类的算法，你不试一试是看不出来要使用什么算法的😭😭😭。
算法模板套路： 创建所需的全局变量（最好设置为静态，因为非静态只有在leetcode上才行）
static boolean[][] vis;//（ 不一定要有）
static int[ ] dx = {0 , 0 , 1 , -1 };
static int[ ] dy = {1 , -1 , 0 , 0 };
vis这个布尔类型数组来标记我们已经走过的路，防止重复走导致死循环。如果题目可以改给出的二维数组的值的话可以修改值就不用创建这个数组来标记了。
dx，dy数组配合使用，对应就是上下左右走，这是四个方向（上下左右）的，如果题目要求8个方向的话可以在草稿纸上画个图推一下很快的。
其他的一些条件根据题目的具体情况创建。
DFS模板如下：
其中n为行的个数，m为列的个数，至于要不要回溯要根据题目要求什么来决定。如果是8个方向的话把改一下dx和dy还有k的值变为8即可。x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m 这个可以说是默写了，因为这就是防止越界，每道题目都是这么写的。
public static void dfs(int i,int j,.....){ for(int k = 0;k &lt; 4;k&#43;&#43;){ int x = i &#43; dx[k]; int y = j &#43; dy[k]; if(x &gt;=0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; !">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-25T12:42:47+08:00">
    <meta property="article:modified_time" content="2024-04-25T12:42:47+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">FloodFill算法---DFS</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="floodfill%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%EF%BC%9A-toc" style="margin-left:0px;"><a href="#floodfill%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%EF%BC%9A" rel="nofollow">floodfill算法概念：</a></p> 
<p id="%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%A5%97%E8%B7%AF%EF%BC%9A%C2%A0-toc" style="margin-left:0px;"><a href="#%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%A5%97%E8%B7%AF%EF%BC%9A%C2%A0" rel="nofollow">算法模板套路： </a></p> 
<p id="%E4%BE%8B%E9%A2%981%EF%BC%9A%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93-toc" style="margin-left:0px;"><a href="#%E4%BE%8B%E9%A2%981%EF%BC%9A%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93" rel="nofollow">例题1：图像渲染</a></p> 
<p id="%E4%BE%8B%E9%A2%982%EF%BC%9A%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-toc" style="margin-left:0px;"><a href="#%E4%BE%8B%E9%A2%982%EF%BC%9A%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F" rel="nofollow">例题2：岛屿数量</a></p> 
<p id="%E4%BE%8B%E9%A2%983%EF%BC%9A%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF-toc" style="margin-left:0px;"><a href="#%E4%BE%8B%E9%A2%983%EF%BC%9A%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF" rel="nofollow">例题3：岛屿的最大面积</a></p> 
<p id="%E4%BE%8B%E9%A2%984%EF%BC%9A%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F-toc" style="margin-left:0px;"><a href="#%E4%BE%8B%E9%A2%984%EF%BC%9A%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F" rel="nofollow">例题4：被围绕的区域</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="floodfill%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%EF%BC%9A">floodfill算法概念：</h2> 
<p>floodfill算法是一种常用的图像处理算法，用于填充连通区域。它从指定的种子点开始，将相邻的像素点按照某种条件进行填充，直到所有符合条件的像素点都被填充为止。floodfill算法常用于图像处理中的填充、边界提取、区域分割等任务。它可以用于实现画图工具中的油漆桶工具，也可以用于图像分割中的区域填充。</p> 
<p>floodfill算法的中文名为洪水灌溉算法，<span style="color:#ff9900;">基本实现内容：从某个点开始向四周扩散，直到无法再扩散为止。（可以使用DFS和BFS，本文讲解DFS解决）</span><span style="color:#fe2c24;">从这个实现内容我们不难发现这很适合我们利用爆搜来实现（一般数据范围不会太大）。</span>如下图数字为1的就是一个性质相同的连通块。这类问题通常会问我们1的最大联通块是多大？或者有几个1的连通块？使用floodfill算法解决的题目基本一眼就能看得出来，不想滑动窗口和动态规划之类的算法，你不试一试是看不出来要使用什么算法的😭😭😭。</p> 
<p><img alt="" height="856" src="https://images2.imgbox.com/22/24/FuKxuyXM_o.png" width="1200"></p> 
<h2 id="%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E5%A5%97%E8%B7%AF%EF%BC%9A%C2%A0">算法模板套路： </h2> 
<p><strong>创建所需的全局变量（最好设置为静态，因为非静态只有在leetcode上才行）</strong></p> 
<blockquote> 
 <p>static boolean[][] vis;//（ 不一定要有）</p> 
 <p>static int[ ] dx = {0 , 0 , 1 , -1 };</p> 
 <p>static int[ ] dy = {1 , -1 , 0 , 0 };</p> 
</blockquote> 
<p>vis这个布尔类型数组来标记我们已经走过的路，<span style="color:#ff9900;">防止重复走导致死循环</span>。如果题目可以改给出的二维数组的值的话可以修改值就不用创建这个数组来标记了。</p> 
<p>dx，dy数组配合使用，对应就是上下左右走，这是四个方向（上下左右）的，如果题目要求8个方向的话可以在草稿纸上画个图推一下很快的。</p> 
<p><img alt="" height="94" src="https://images2.imgbox.com/7e/4d/a0BEENFU_o.png" width="553"></p> 
<p>其他的一些条件根据题目的具体情况创建。</p> 
<p><strong>DFS模板如下：</strong></p> 
<p>其中n为行的个数，m为列的个数，至于要不要回溯要根据题目要求什么来决定。如果是8个方向的话把改一下dx和dy还有k的值变为8即可。<span style="color:#ff9900;">x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m 这个可以说是默写了，因为这就是防止越界，每道题目都是这么写的。</span></p> 
<pre><code class="language-java">public static void dfs(int i,int j,.....){
        for(int k = 0;k &lt; 4;k++){
            int x = i + dx[k];
            int y = j + dy[k];
            if(x &gt;=0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; !vis[x][y] &amp;&amp; 题目条件){
                vis[x][y] = true;
                dfs(x,y,.....);
                vis[x][y] = false;//回溯
            }
        }
    }</code></pre> 
<p>上面的这些是作者自己总结出来的，友友们刚开始可以试试，后面做的熟练了基本写出这些就是肌肉记忆了，这个在比赛中也会考到。</p> 
<p><span style="color:#fe2c24;">下面给出的例题前三题必看，可以说是floodfill算法的经典题型了。</span></p> 
<h2 id="%E4%BE%8B%E9%A2%981%EF%BC%9A%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93">例题1：图像渲染</h2> 
<p><a class="link-info" href="https://leetcode.cn/problems/flood-fill/description/" rel="nofollow" title="链接：图像渲染">链接：图像渲染</a></p> 
<p>有一幅以 <code>m x n</code> 的二维整数数组表示的图画 <code>image</code> ，其中 <code>image[i][j]</code> 表示该图画的像素值大小。</p> 
<p>你也被给予三个整数 <code>sr</code> ,  <code>sc</code> 和 <code>newColor</code> 。你应该从像素 <code>image[sr][sc]</code> 开始对图像进行 上色<strong>填充</strong> 。</p> 
<p>为了完成<strong> 上色工作</strong> ，从初始像素开始，记录初始坐标的 <strong>上下左右四个方向上</strong> 像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应 <strong>四个方向上</strong> 像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为 <code>newColor</code> 。</p> 
<p>最后返回 <em>经过上色渲染后的图像 </em>。</p> 
<p><img alt="" height="1016" src="https://images2.imgbox.com/b3/05/zXyo1sCG_o.png" width="1200"></p> 
<p><strong>详细题解： </strong></p> 
<p><strong>可以利用深搜，遍历到与该点相连的所有像素相同的点，然后将其修改成指定的像素即可。</strong></p> 
<p><span style="color:#ff9900;">这里再强调一下，在leetcode中不加static是可以的，但是在比赛中（要求自己写Main类）只能用static修饰的。 </span></p> 
<p>直接对题目给出的一个点进行DFS，本题是直接在二位数组image的基础上直接修改那么就不用用到 vis 来标记了，因为走过的地方值被修改了那么就不会出现重复走的情况。具体代码如下：</p> 
<pre><code class="language-java">class Solution {
    int[] dx = {0,0,1,-1};
    int[] dy = {1,-1,0,0};
    int prev;
    int m,n;
    public int[][] floodFill(int[][] image, int sr, int sc, int color) {
        if(image[sr][sc] == color){
            return image;
        }
        prev = image[sr][sc];
        m = image.length;
        n = image[0].length;
        dfs(image,sr,sc,color);
        return image;
    }
    public void dfs(int[][] image,int i,int j,int color){
        image[i][j] = color;
        for(int k = 0;k &lt; 4;k++){
            int x = i + dx[k];
            int y = j + dy[k];
            if(x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;=0 &amp;&amp; y &lt; n &amp;&amp; image[x][y] == prev){
                dfs(image,x,y,color);
            }
        }
    }
}</code></pre> 
<h2 id="%E4%BE%8B%E9%A2%982%EF%BC%9A%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F">例题2：岛屿数量</h2> 
<p><a class="link-info" href="https://leetcode.cn/problems/number-of-islands/description/" rel="nofollow" title="链接：岛屿数量">链接：岛屿数量</a></p> 
<p>给你一个由 <code>'1'</code>（陆地）和 <code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p> 
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p> 
<p>此外，你可以假设该网格的四条边均被水包围。</p> 
<p><img alt="" height="367" src="https://images2.imgbox.com/5a/13/sOk1s315_o.png" width="1200"></p> 
<p><strong>详细题解：</strong></p> 
<p>非常经典的一道floodfill算法题目其思路过程为：</p> 
<p>遍历整个矩阵，每当找到一块陆地时，岛屿数量 + 1，并且将这个陆地相连的所有陆地，也就是这块岛屿，全部变成海洋。这样的话，我们下次遍历到这块岛屿的时候，它已经是海洋了，不会影响最终结果（当然也可以不修改矩阵，我们可以使用vis数组来完成去重操作）。变成海洋的操作可以利用DFS解决和上面给出的模板差不多😎😎😎</p> 
<p><strong>代码实现：</strong></p> 
<pre><code class="language-java">class Solution {
    static int ret;
    static boolean[][] vis;
    static int n;
    static int m;
    static int[] dx = {0,0,1,-1};
    static int[] dy = {1,-1,0,0};
    public static int numIslands(char[][] grid) {
        ret = 0;
        n = grid.length;
        m = grid[0].length;
        vis = new boolean[n][m];
        for(int i = 0;i &lt; n;i++){
            for(int j = 0;j &lt; m;j++){
                if(grid[i][j] == '1' &amp;&amp; !vis[i][j]){
                    dfs(grid,i,j);
                    ret++;
                }

            }
        }
        return ret;
    }
    public static void dfs(char[][] grid,int i,int j){
        vis[i][j] = true;
        for(int k = 0;k &lt; 4;k++){
            int x = i + dx[k];
            int y = j + dy[k];
            if(x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; grid[x][y] == '1' &amp;&amp; !vis[x][y]){
                dfs(grid,x,y);
            }
        }
    }
}</code></pre> 
<h2 id="%E4%BE%8B%E9%A2%983%EF%BC%9A%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF">例题3：岛屿的最大面积</h2> 
<p><a class="link-info" href="https://leetcode.cn/problems/max-area-of-island/description/" rel="nofollow" title="链接：岛屿的最大面积">链接：岛屿的最大面积</a></p> 
<p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code> 。</p> 
<p><strong>岛屿</strong> 是由一些相邻的 <code>1</code> (代表土地) 构成的组合，这里的「相邻」要求两个 <code>1</code> 必须在 <strong>水平或者竖直的四个方向上 </strong>相邻。你可以假设 <code>grid</code> 的四个边缘都被 <code>0</code>（代表水）包围着。</p> 
<p>岛屿的面积是岛上值为 <code>1</code> 的单元格的数目。</p> 
<p>计算并返回 <code>grid</code> 中最大的岛屿面积。如果没有岛屿，则返回面积为 <code>0</code> 。</p> 
<p><img alt="" height="606" src="https://images2.imgbox.com/0c/4a/GsOVBd5x_o.png" width="989"></p> 
<p>没错又是这张图因为比较经典且作者水平有限😭😭😭，所以就直接使用了。</p> 
<p><strong>详细题解：</strong></p> 
<p><strong>遍历整个矩阵，每当遇到⼀块土地的时候，就用DFS将与这块土地相连的整个岛屿的面积计算出来。然后在搜索得到的所有岛屿面积中求一个最大值即可。这题我们就可以使用vis数组来标记这个位置是否已经被访问过了。</strong></p> 
<p>求这种最大值的又是深搜，建议大家自己设置一个变量来专门存储临时值和最大值，我一般存储临时值采用path，存储结果也就是最大值采用ret，step表示递归的层数（这个floodfill算法不涉及，在别的DFS题会用到）这个都行就是自己要明白。</p> 
<pre><code class="language-java">class Solution {
    int[] dx = {0,0,1,-1};
    int[] dy = {1,-1,0,0};
    int ret;
    boolean[][] vis;
    int n,m;
    int path;
    public int maxAreaOfIsland(int[][] grid) {
        n = grid.length;
        m = grid[0].length;
        vis = new boolean[n][m];
        ret = 0;
        for(int i = 0;i &lt; n;i++){
            for(int j = 0;j &lt; m;j++){
                if(grid[i][j] == 1 &amp;&amp; !vis[i][j]){
                    path = 0;
                    dfs(grid,i,j);
                    ret = Math.max(ret,path);
                }
            }
        }
        return ret;
    }
    public void dfs(int[][] grid,int i,int j){
        vis[i][j] = true;
        path++;
        for(int k = 0;k &lt; 4;k++){
            int x = i + dx[k];
            int y = j + dy[k];
            if(x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; 
            grid[x][y] == 1 &amp;&amp; !vis[x][y]){
                dfs(grid,x,y);
            }
        }
    }
}</code></pre> 
<p>相信做完上面三道题目，友友们是不是觉得有点没有意思，感觉就是在考背诵一样，DFS的写法基本差不多，上面的只要根据题意稍加修改即可。其实DFS确实差不多，有些难点是在如何使用DFS而不是写出DFS，例如下面的例题四，运用到了我们解决问题的经典思路<span style="color:#fe2c24;">正难则反</span>。</p> 
<h2 id="%E4%BE%8B%E9%A2%984%EF%BC%9A%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F">例题4：被围绕的区域</h2> 
<p><a class="link-info" href="https://leetcode.cn/problems/surrounded-regions/description/" rel="nofollow" title="链接：被围绕的区域">链接：被围绕的区域</a></p> 
<p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>'X'</code> 和 <code>'O'</code> ，找到所有被 <code>'X'</code> 围绕的区域，并将这些区域里所有的 <code>'O'</code> 用 <code>'X'</code> 填充。</p> 
<p><img alt="" height="800" src="https://images2.imgbox.com/46/51/l1wVAUcy_o.png" width="1200"></p> 
<p>可以看到如果我们不加以转换的话直接按照我们前面三题的思路来的话有点困难，因为要判断很多边界情况，且要进行两遍DFS，所以我们要想一种更为巧妙的解法：<span style="color:#fe2c24;">正难则反。</span></p> 
<p><strong>解题过程：</strong></p> 
<p>可以先利用dfs将与边缘相连的'0' 区域做上标记，然后重新遍历矩阵，将没有标记过的'0' 修改成'X' 即可。就是这么的简单。遍历边缘就画个图模拟一下即可，至于DFS的编写那还不是手到擒来🤩🤩🤩 ,具体代码如下：</p> 
<pre><code class="language-java">class Solution {
    int[] dx = {0,0,1,-1};
    int[] dy = {1,-1,0,0};
    boolean[][] vis;
    int n,m;
    public void solve(char[][] board) {
        n = board.length;
        m = board[0].length;
        vis = new boolean[n][m];
        //标记vis
        for(int i = 0;i &lt; n;i++){
            if(board[i][0] == 'O'){
                dfs(board,i,0);
            }
            if(board[i][m - 1] == 'O'){
                dfs(board,i,m - 1);
            }
        }
        for(int i = 0;i &lt; m;i++){
            if(board[0][i] == 'O'){
                dfs(board,0,i);
            }
            if(board[n - 1][i] == 'O'){
                dfs(board,n - 1,i);
            }
        }
        //将O用X填充
        for(int i = 0;i &lt; n;i++){
            for(int j = 0;j &lt; m;j++){
                if(board[i][j] == 'O' &amp;&amp; !vis[i][j]){
                    board[i][j] = 'X';
                }
            }
        }
    }
    public void dfs(char[][] board,int i,int j){
        vis[i][j] = true;
        for(int k = 0;k &lt; 4;k++){
            int x = i + dx[k];
            int y = j + dy[k];
            if(x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; board[x][y] == 'O' &amp;&amp; 
            !vis[x][y]){
                dfs(board,x,y);
            }
        }
    }
}</code></pre> 
<p><strong>总结：这类题难点在如何使用DFS，全局变量要根据具体情况来创建，这些搞定后写个DFS就是默写的事情。</strong></p> 
<p><strong>结语：</strong></p> 
<p><strong>其实写博客不仅仅是为了教大家，同时这也有利于我巩固知识点，和做一个学习的总结，由于作者水平有限，对文章有任何问题还请指出，非常感谢。如果大家有所收获的话还请不要吝啬你们的点赞收藏和关注，这可以激励我写出更加优秀的文章。</strong></p> 
<p><img alt="" height="400" src="https://images2.imgbox.com/12/56/xVYg98SG_o.png" width="1080"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c0dd754dd1e752df7185887311b177d3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">rabbitmq五种消息模型</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0655d39c02669fe73c2bdf98ddc62133/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Mac电脑Android Studio和VS Code配置Flutter开发环境（图文超详细）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>