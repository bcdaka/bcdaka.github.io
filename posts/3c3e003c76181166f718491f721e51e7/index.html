<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【高阶数据结构】秘法（一）——并查集：探索如何高效地管理集合 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/3c3e003c76181166f718491f721e51e7/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【高阶数据结构】秘法（一）——并查集：探索如何高效地管理集合">
  <meta property="og:description" content="前言：
前面我们已经学习了简单的数据结构，包括栈与队列、二叉树、红黑树等等，今天我们继续数据结构的学习，但是难度上会逐渐增大，在高阶数据结构中我们要学习的重点是图等
目录
一、并查集的原理
二、并查集的基本操作
三、并查集的实现（简略版）
四、并查集的实现方式和优化策略
五、并查集的实现（完整版）
六、总结
一、并查集的原理 在某些情况下，对于一组元素，我们会把它们划分成不同的集合。起初每个元素组成一个单元素集合，然后按照一定规律将归于同一种类型的集合合并，同时在这个过程中我们可能会反复用到查询某个元素属于哪个集合的运算，这种管理集合所对应的抽象概念就是并查集
并查集，也称为链接-切割数据结构，是一种用于管理集合的高效数据结构。它特别适用于处理“动态连接”的问题，即动态地合并集合或查询两个元素是否属于同一个集合。并查集在计算机科学中有着广泛的应用，如用于解决最小生成树问题（Prim算法和Kruskal算法）、解决网络连通性问题、解决图论中的问题等。
下面来看这样一个例子：某旅游团内有游客10人，其中西安4人，成都3人，武汉3人，10个人来自不同的地方，起先互不相识，每个游客都是一个独立的小团体，现给这些游客进行编号：{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; 给以下数组用来存储该小集体，数组中的数字代表：该小集团中具有成员的个数（负数的意义下文讲解）
旅行结束后，游客们要乘车回家，每个地方的游客自发组织成小分队一起上路，于是：西安游客小分队s1={0,6,7,8}，成都游客小分队s2={1,4,9}，武汉游客小分队s3={2,3,5}就相互认识了，10个人形成了三个小团体。假设右三个群主0,1,2担任队长，负责大家的出行。 一趟火车之旅后，每个小分队成员就互相熟悉，称为了一个朋友圈。 从上图可以看出：编号6,7,8游客属于0号小分队，该小分队中有4人(包含队长0)；编号为4和9的同学属于1号小分队，该小分队有3人(包含队长1)，编号为3和5的游客属于2号小分队，该小分队有3个人(包含队长1)。 仔细观察数组中内融化，可以得出以下结论： 1. 数组的下标对应集合中元素的编号
2. 数组中如果为负数，负号代表根，数字代表该集合中元素个数
3. 数组中如果为非负数，代表该元素双亲在数组中的下标 回家一段时间后，西安小分队中8号游客与成都小分队1号游客奇迹般的走到了一起，两个小圈子的游客相互介绍，最后成为了一个小圈子： 现在0集合有7个人，2集合有3个人，总共两个朋友圈 通过以上例子可知，并查集一般可以解决一下问题： 1. 查找元素属于哪个集合 沿着数组表示树形关系以上一直找到根(即：树中中元素为负数的位置) 2. 查看两个元素是否属于同一个集合 沿着数组表示的树形关系往上一直找到树的根，如果根相同表明在同一个集合，否则不在 3. 将两个集合归并成一个集合 将两个集合中的元素合并 将一个集合名称改成另一个集合的名称 4. 集合的个数 遍历数组，数组中元素为负数的个数即为集合的个数。 二、并查集的基本操作 并查集主要支持以下三种基本操作：
查找（Find）：确定一个元素属于哪个集合。合并（Union）：将两个集合合并为一个集合。初始化（Init）：为每个元素创建一个独立的集合。 三、并查集的实现（简略版） 根据上面讲的原理和预期功能，我们可以先来实现一个简略版的并查集： class UnionFindSet { public: // 初始时，将数组中元素全部设置为-1 UnionFindSet(size_t size) : _ufs(size, -1) {} // 给一个元素的编号，找到该元素所在集合的名称 int FindRoot(int index) { int root=index; // 如果数组中存储的是负数，找到，否则一直继续 while (_ufs[index] &gt;= 0) { index = _ufs[index]; } //路径压缩 while(_ufs[root]&gt;=0) { int parent=_ufs[root]; _ufs[root]=index; x=parent; } return index; } bool Union(int x1, int x2) { int root1 = FindRoot(x1); int root2 = FindRoot(x2); // x1已经与x2在同一个集合 if (root1 == root2) return false; //优化(合并后让子树多的做根） if(abs(_ufs[root1])&lt;abs(_ufs[root2]) swap(root1,root2); // 将两个集合中元素合并 _ufs[root1] &#43;= _ufs[root2]; // 将其中一个集合名称改变成另外一个 _ufs[root2] = root1; return true; } // 数组中负数的个数，即为集合的个数 size_t Count()const { size_t count = 0; for (auto e : _ufs) { if (e &lt; 0) &#43;&#43;count; } return count; } private: vector&lt;int&gt; _ufs; }; 四、并查集的实现方式和优化策略 并查集有两种常见的实现方式：路径压缩和按秩合并。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-09-02T22:00:01+08:00">
    <meta property="article:modified_time" content="2024-09-02T22:00:01+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【高阶数据结构】秘法（一）——并查集：探索如何高效地管理集合</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>前言：</strong></p> 
<blockquote> 
 <p>前面我们已经学习了简单的数据结构，包括栈与队列、二叉树、红黑树等等，今天我们继续数据结构的学习，但是难度上会逐渐增大，在高阶数据结构中我们要学习的重点是图等</p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:80px;"></p> 
<p id="%E4%B8%80%E3%80%81%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#%E4%B8%80%E3%80%81%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E5%8E%9F%E7%90%86" rel="nofollow">一、并查集的原理</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#%E4%BA%8C%E3%80%81%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C" rel="nofollow">二、并查集的基本操作</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E7%AE%80%E7%95%A5%E7%89%88%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E4%B8%89%E3%80%81%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E7%AE%80%E7%95%A5%E7%89%88%EF%BC%89" rel="nofollow">三、并查集的实现（简略版）</a></p> 
<p id="%E5%9B%9B%E3%80%81%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5-toc" style="margin-left:80px;"><a href="#%E5%9B%9B%E3%80%81%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5" rel="nofollow">四、并查集的实现方式和优化策略</a></p> 
<p id="%E4%BA%94%E3%80%81%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%AE%8C%E6%95%B4%E7%89%88%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E4%BA%94%E3%80%81%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%AE%8C%E6%95%B4%E7%89%88%EF%BC%89" rel="nofollow">五、并查集的实现（完整版）</a></p> 
<p id="%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93-toc" style="margin-left:80px;"><a href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93" rel="nofollow">六、总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h4 id="%E4%B8%80%E3%80%81%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E5%8E%9F%E7%90%86">一、并查集的原理</h4> 
<blockquote> 
 <p>在某些情况下，对于一组元素，我们会把它们划分成不同的集合。起初每个元素组成一个单元素集合，然后按照一定规律将归于同一种类型的集合合并，同时在这个过程中我们可能会反复用到查询某个元素属于哪个集合的运算，这种管理集合所对应的抽象概念就是并查集</p> 
</blockquote> 
<hr> 
<blockquote> 
 <p>并查集，也称为链接-切割数据结构，是一种用于管理集合的高效数据结构。它特别适用于处理“动态连接”的问题，即动态地合并集合或查询两个元素是否属于同一个集合。并查集在计算机科学中有着广泛的应用，如用于解决最小生成树问题（Prim算法和Kruskal算法）、解决网络连通性问题、解决图论中的问题等。</p> 
</blockquote> 
<hr> 
<blockquote> 
 <p>下面来看这样一个例子：某旅游团内有游客10人，其中西安4人，成都3人，武汉3人，10个人来自不同的地方，起先互不相识，每个游客都是一个独立的小团体，现给这些游客进行编号：{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; 给以下数组用来存储该小集体，数组中的数字代表：该小集团中具有成员的个数（负数的意义下文讲解）</p> 
</blockquote> 
<p><img alt="" height="221" src="https://images2.imgbox.com/33/a0/vVvzfzgn_o.png" width="1126"></p> 
<blockquote> 
 <div>
   旅行结束后，游客们要乘车回家，每个地方的游客自发组织成小分队一起上路，于是：西安游客小分队s1={0,6,7,8}，成都游客小分队s2={1,4,9}，武汉游客小分队s3={2,3,5}就相互认识了，10个人形成了三个小团体。假设右三个群主0,1,2担任队长，负责大家的出行。 
 </div> 
</blockquote> 
<div> 
 <img alt="" height="326" src="https://images2.imgbox.com/75/65/8KYXnwdy_o.png" width="1067"> 
</div> 
<blockquote> 
 <div>
   一趟火车之旅后，每个小分队成员就互相熟悉，称为了一个朋友圈。 
 </div> 
</blockquote> 
<div> 
 <img alt="" height="437" src="https://images2.imgbox.com/9b/0a/ky7TlPuI_o.png" width="1200"> 
</div> 
<blockquote> 
 <div>
   从上图可以看出：编号6,7,8游客属于0号小分队，该小分队中有4人(包含队长0)；编号为4和9的同学属于1号小分队，该小分队有3人(包含队长1)，编号为3和5的游客属于2号小分队，该小分队有3个人(包含队长1)。 
 </div> 
 <div>
   仔细观察数组中内融化，可以得出以下结论： 
  <br> 
  <strong><span style="background-color:#ffd900;">1. 数组的下标对应集合中元素的编号</span><br><span style="background-color:#ffd900;">2. 数组中如果为负数，负号代表根，数字代表该集合中元素个数</span><br><span style="background-color:#ffd900;">3. 数组中如果为非负数，代表该元素双亲在数组中的下标</span></strong> 
 </div> 
</blockquote> 
<div> 
 <br> 
 <strong>回家一段时间后，西安小分队中8号游客与成都小分队1号游客奇迹般的走到了一起，两个小圈子的游客相互介绍，最后成为了一个小圈子：</strong> 
</div> 
<div></div> 
<div> 
 <img alt="" height="525" src="https://images2.imgbox.com/ee/39/CRHqlTEm_o.png" width="1040"> 
</div> 
<div></div> 
<div></div> 
<div>
  现在0集合有7个人，2集合有3个人，总共两个朋友圈 
</div> 
<div></div> 
<div> 
 <blockquote> 
  <div> 
   <strong><span style="background-color:#ffd900;">通过以上例子可知，并查集一般可以解决一下问题：</span></strong> 
   <br> 
   <strong>1. 查找元素属于哪个集合</strong> 
   <br> 沿着数组表示树形关系以上一直找到根(即：树中中元素为负数的位置) 
   <br> 
   <strong>2. 查看两个元素是否属于同一个集合</strong> 
   <br> 沿着数组表示的树形关系往上一直找到树的根，如果根相同表明在同一个集合，否则不在 
   <br> 
   <strong>3. 将两个集合归并成一个集合</strong> 
   <br> 将两个集合中的元素合并 
   <br> 将一个集合名称改成另一个集合的名称 
  </div> 
  <div> 
   <div> 
    <strong>4. 集合的个数 </strong> 
    <br> 遍历数组，数组中元素为负数的个数即为集合的个数。 
   </div> 
  </div> 
 </blockquote> 
</div> 
<h4 id="%E4%BA%8C%E3%80%81%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">二、并查集的基本操作</h4> 
<div> 
 <p><strong>并查集主要支持以下三种基本操作：</strong></p> 
 <blockquote> 
  <ol><li><strong>查找（Find）</strong>：确定一个元素属于哪个集合。</li><li><strong>合并（Union）</strong>：将两个集合合并为一个集合。</li><li><strong>初始化（Init）</strong>：为每个元素创建一个独立的集合。</li></ol> 
 </blockquote> 
</div> 
<h4 id="%E4%B8%89%E3%80%81%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E7%AE%80%E7%95%A5%E7%89%88%EF%BC%89">三、并查集的实现（简略版）</h4> 
<p><img alt="" height="284" src="https://images2.imgbox.com/eb/33/JKRqFJFw_o.png" width="888"></p> 
<div>
  根据上面讲的原理和预期功能，我们可以先来实现一个简略版的并查集： 
</div> 
<div></div> 
<div> 
 <pre><code class="language-cpp">class UnionFindSet
{
public:
	// 初始时，将数组中元素全部设置为-1
	UnionFindSet(size_t size)
		: _ufs(size, -1)
	{}
	// 给一个元素的编号，找到该元素所在集合的名称
	int FindRoot(int index)
	{
        int root=index;
			// 如果数组中存储的是负数，找到，否则一直继续
			while (_ufs[index] &gt;= 0)
			{
				index = _ufs[index];
			}
        
        //路径压缩
        while(_ufs[root]&gt;=0)
        {
           int parent=_ufs[root];
           _ufs[root]=index;
           x=parent;
        }
		return index;
	}
	bool Union(int x1, int x2)
	{
		int root1 = FindRoot(x1);
		int root2 = FindRoot(x2);

		// x1已经与x2在同一个集合
		if (root1 == root2)
			return false;
        
        //优化(合并后让子树多的做根）
        if(abs(_ufs[root1])&lt;abs(_ufs[root2])
            swap(root1,root2);
		// 将两个集合中元素合并
		_ufs[root1] += _ufs[root2];

		// 将其中一个集合名称改变成另外一个
		_ufs[root2] = root1;
		return true;
	}
	// 数组中负数的个数，即为集合的个数
	size_t Count()const
	{
		size_t count = 0;
		for (auto e : _ufs)
		{
			if (e &lt; 0)
				++count;
		}

		return count;
	}

private:
	vector&lt;int&gt; _ufs;
};</code></pre> 
 <h4 id="%E5%9B%9B%E3%80%81%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5">四、并查集的实现方式和优化策略</h4> 
 <p><strong><span style="background-color:#ffd900;">并查集有两种常见的实现方式：路径压缩和按秩合并。</span></strong></p> 
 <blockquote> 
  <ul><li><strong>路径压缩</strong>：在查找操作中，将查找路径上的所有节点的父节点直接指向根节点，以减少查找路径的深度。</li><li><strong>按秩合并</strong>：在合并操作中，将秩较小的集合合并到秩较大的集合中，以减少树的高度。</li></ul> 
 </blockquote> 
 <hr> 
 <blockquote> 
  <p>为了提高查找操作的效率，通常结合使用路径压缩和按秩合并两种策略。路径压缩确保查找操作的时间复杂度接近常数，而按秩合并则减少了树的高度，进一步优化了合并操作的时间复杂度。</p> 
 </blockquote> 
 <h4 id="%E4%BA%94%E3%80%81%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%AE%8C%E6%95%B4%E7%89%88%EF%BC%89">五、并查集的实现（完整版）</h4> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

class UnionFind {
private:
    std::vector&lt;int&gt; parent;
    std::vector&lt;int&gt; rank;

public:
    UnionFind(int n) : parent(n), rank(n) {
        for (int i = 0; i &lt; n; ++i) {
            parent[i] = i;
            rank[i] = 1;
        }
    }

    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // 路径压缩
        }
        return parent[x];
    }

    void unite(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX == rootY) return;

        if (rank[rootX] &gt; rank[rootY]) {
            parent[rootY] = rootX;
        } else if (rank[rootX] &lt; rank[rootY]) {
            parent[rootX] = rootY;
        } else {
            parent[rootY] = rootX;
            rank[rootX] += 1;
        }
    }

    bool connected(int x, int y) {
        return find(x) == find(y);
    }
};

int main() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    UnionFind uf(n);
    for (int i = 0; i &lt; m; ++i) {
        int a, b;
        std::cin &gt;&gt; a &gt;&gt; b;
        uf.unite(a - 1, b - 1); // 转换为0-based索引
    }
    for (int i = 0; i &lt; m; ++i) {
        int a, b;
        std::cin &gt;&gt; a &gt;&gt; b;
        std::cout &lt;&lt; (uf.connected(a - 1, b - 1) ? "YES" : "NO") &lt;&lt; std::endl;
    }
    return 0;
}</code></pre> 
 <h4 id="%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93">六、总结</h4> 
 <blockquote> 
  <p>并查集的高效性在于其优化策略，使得查找和合并操作的时间复杂度保持在较低的水平，从而在处理大规模数据集时依然表现出色。平时我们在刷题或学习中还是会经常遇到并查集的</p> 
 </blockquote> 
</div> 
<div> 
 <img alt="" src="https://images2.imgbox.com/5f/f3/s7j9wFKU_o.jpg"> 
</div> 
<div></div> 
<div> 
 <strong><span style="background-color:#ffd900;">感谢各位大佬观看，创作不易，还请各位大佬点赞支持！！！</span></strong> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/683bad786b97296dd5af8cca18015563/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HarmonyOS开发实战（ Beta5版）延迟加载lazy-import实践使用指导</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8c38c324235737bc5a04635b3e972a81/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">建模杂谈系列253 序列突变点的判定</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>