<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>对数据结构的初步认识 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ecf20b73a6fc1995e8755aa8afa7fbc0/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="对数据结构的初步认识">
  <meta property="og:description" content="前言: 牛牛开始更新数据结构的知识了.本专栏后续会分享用c语言实现顺序表,链表,二叉树,栈和队列,排序算法等相关知识,欢迎友友们互相学习,可以私信互相讨论哦!
🎈个人主页:🎈 :✨✨✨初阶牛✨✨✨
🐻推荐专栏: 🍔🍟🌯 c语言初阶
🔑个人信条: 🌵知行合一
🍉本篇简介:&gt;:讲解数据结构的入门知识,时间复杂度与空间复杂度,以及一些对学习数据结构的建议.
金句分享:
✨最快的脚步不是冲刺,而是坚持!✨
目录 前言:1、数据结构是什么?2、数据结构应该怎么学呢? 算法效率如何衡量?一、 时间复杂度大O的渐进表示法时间复杂度的练习:1.1 常见的时间复杂度:1.2 冒泡排序的时间复杂度1.3 &#34;二分查找&#34;的时间复杂度1.4 递归的时间复杂度:常见量级的比较图 二、空间复杂度 1、数据结构是什么? 数据结构&#43;算法=程序.
数据结构(Data Structure):是计算机存储、组织数据的方式，指相互之间存在一种或多种特定关系的数据元素的集合。
例如后面会提到的顺序表,链表这些线性数据结构,还有后面的二叉树树形数据结构等.
算法(Algorithm):就是定义良好的计算过程，他取一个或一组的值为输入，并产生出一个或一组值作为输出。简单来说算法就是一系列的计算步骤，用来将输入数据转化成输出结果.
例如:排序算法.
数据结构与算法对于一个程序员是很重要的,不论对你思考问题的方式还是对你编程的思维都会有很大的好处。同时在找工作时算法也是一个重要考点之一.
2、数据结构应该怎么学呢? 1.多多练习代码.
数据结构的学习并不简单,需要多锻炼代码能力,最怕偷懒,很多时候头脑虽然理解了,但是动起手来写代码会忽略很多细节,导致程序出错,不能光有思路,而代码能力却实现不了就很尴尬了.
2.多画图(这个强烈推荐)
除了代码能力需要锻炼以外,很重要的一点是要有思路,通过画图辅助,可以很好地帮助我们找到思路和理解数据结构中的很多思想,切忌上来就开始码代码,这样对于简单的问题可能可以解决,但是对于稍微复杂的问题可能会让你头痛(大佬除外😂😂),很容易被绕进去,陷入痛苦的调试找bug环节.
画图会让提供给我们清晰的思路,同时,即使出现了bug,也可以很快的找到,清晰可见.写代码只是用于实现思路,思路清晰,代码写起来并不困难.
3.刷题
刷题会锻炼我们的思考能力,解题是一种很灵活的事情.一方面可以巩固我们学的基础知识,另一方面可以拓展思维.
最后,坚持学习才是最重要的.
算法效率如何衡量? 对于一个问题,可以有很多解法,那怎样衡量一个算法的好坏呢?
比谁的代码更简洁吗?
算法的效率主要考虑两点:1.时间复杂度. 2.空间复杂度
一个算法在编译生成可执行文件后,运行时会耗费时间资源和空间(内存)资源 。
从时间和空间两个维度来衡量一个算法的好坏是比较合理的，这就是时间复杂度和空间复杂度。
时间复杂度主要衡量一个算法的运行快慢，而空间复杂度主要衡量一个算法运行所需要的额外空间。在计算机发展的早期，计算机的存储容量很小。所以对空间复杂度很是在乎。但是经过计算机行业的迅速发展，计算机的存储容量已经达到了很高的程度。所以我们如今已经不需要再特别关注一个算法的空间复杂度。
一、 时间复杂度 时间复杂度的定义：在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。一个算法执行所耗费的时间.
但是从理论上说，这个只有将代码进行测试,并统计时间才能知道.并不能通过计算得到.
但对于每一个算法,我们都去跑一下,这未免显得有些麻烦,我们可以通过算法中的代码估计运行大概的时间,看看属于哪一个量级来衡量它的效率.
算法中的基本操作的执行次数，为算法的时间复杂度。
即：找到某条基本语句与问题规模N之间的数学表达式，就是算出了该算法的时间复杂度
理论不是很理解的话,我们来点实际的,找几段代码算算吧!
🌰小试牛刀
你能算出在test1中&#43;&#43;count语句最终被执行了多少次吗?
void test1(int N) { int count = 0; //1 for (int i = 0; i &lt; N; i&#43;&#43;) { for (int j = 0; j &lt; N; j&#43;&#43;) { &#43;&#43;count; } } //2 for (int k = 1; k &lt; N; k*=2) { &#43;&#43;count; } //3 for (int k = 0; k &lt; 2 * N; k&#43;&#43;) { &#43;&#43;count; } //4 int a = 100; while (a--) { &#43;&#43;count; } printf(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-05-01T08:42:38+08:00">
    <meta property="article:modified_time" content="2023-05-01T08:42:38+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">对数据结构的初步认识</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-kimbie-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/4c/21/xnfoFpmY_o.gif" alt="在这里插入图片描述"></p> 
<h2><a id="_3"></a>前言:</h2> 
<p>牛牛开始更新<strong>数据结构</strong>的知识了.本专栏后续会分享用c语言实现<strong>顺序表</strong>,<strong>链表</strong>,<strong>二叉树</strong>,<strong>栈</strong>和<strong>队列</strong>,<strong>排序</strong>算法等相关知识,欢迎友友们互相学习,可以私信互相讨论哦!</p> 
<blockquote> 
 <p>🎈个人主页:🎈 :<a href="https://blog.csdn.net/qq_67276605?spm=1018.2226.3001.5343">✨✨✨初阶牛✨✨✨</a><br> 🐻推荐专栏: 🍔🍟🌯 <a href="https://blog.csdn.net/qq_67276605/category_12070485.html">c语言初阶</a><br> 🔑个人信条: 🌵知行合一<br> 🍉本篇简介:&gt;:讲解数据结构的入门知识,时间复杂度与空间复杂度,以及一些对学习数据结构的建议.<br> <font face="黑体" color="#FFD700" size="5">金句分享:<br> <font face="黑体" color="PaleVioletRed" size="4">✨最快的脚步不是冲刺,而是坚持!✨</font></font></p> 
</blockquote> 
<p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_3" rel="nofollow">前言:</a></li><li><ul><li><a href="#1_15" rel="nofollow">1、数据结构是什么?</a></li><li><a href="#2_35" rel="nofollow">2、数据结构应该怎么学呢?</a></li></ul> 
  </li><li><a href="#_53" rel="nofollow">算法效率如何衡量?</a></li><li><ul><li><a href="#__62" rel="nofollow">一、 时间复杂度</a></li><li><ul><li><a href="#O_118" rel="nofollow">大O的渐进表示法</a></li><li><a href="#_147" rel="nofollow">时间复杂度的练习:</a></li><li><a href="#11__148" rel="nofollow">1.1 常见的时间复杂度:</a></li><li><a href="#12__267" rel="nofollow">1.2 冒泡排序的时间复杂度</a></li><li><a href="#13__302" rel="nofollow">1.3 "二分查找"的时间复杂度</a></li><li><a href="#14__344" rel="nofollow">1.4 递归的时间复杂度:</a></li><li><a href="#_378" rel="nofollow">常见量级的比较图</a></li></ul> 
   </li><li><a href="#_384" rel="nofollow">二、空间复杂度</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="1_15"></a>1、数据结构是什么?</h3> 
<p><mark>数据结构+算法=程序.</mark></p> 
<blockquote> 
 <p><strong>数据结构</strong>(Data Structure):是<mark>计算机存储、组织数据</mark>的<mark>方式</mark>，指相互之间存在一种或多种特定关系的数据元素的集合。<br> 例如后面会提到的<strong>顺序表,链表这些线性数据结构,<strong>还有后面的</strong>二叉树树形数据结构</strong>等.</p> 
</blockquote> 
<img src="https://images2.imgbox.com/0f/3d/X2C8nowq_o.png" width="30%"> 
<img src="https://images2.imgbox.com/ff/4c/Emm2WYeV_o.png" width="30%"> 
<img src="https://images2.imgbox.com/8d/10/1FsOxRDD_o.png" width="20%"> 
<img src="https://images2.imgbox.com/58/ea/Mh38VDCG_o.png" width="30%"> 
<blockquote> 
 <p><strong>算法(Algorithm)</strong>:就是定义良好的计算过程，他取一个或一组的值为输入，并产生出一个或一组值作为输出。简单来说算法就是一系列的计算步骤，用来将输入数据转化成输出结果.<br> 例如:排序算法.</p> 
</blockquote> 
<p><strong>数据结构与算法</strong>对于一个程序员是很重要的,不论对你思考问题的方式还是对你编程的思维都会有很大的好处。同时在找工作时算法也是一个重要考点之一.</p> 
<h3><a id="2_35"></a>2、数据结构应该怎么学呢?</h3> 
<p><strong>1.多多练习代码.</strong><br> <img src="https://images2.imgbox.com/25/d5/uaaJnrmM_o.gif" alt="在这里插入图片描述"></p> 
<p><strong>数据结构的</strong>学习并不简单,需要多锻炼代码能力,最怕偷懒,很多时候头脑虽然理解了,但是动起手来写代码会忽略很多细节,导致程序出错,不能光有思路,而代码能力却实现不了就很尴尬了.</p> 
<p><strong>2.多画图(这个强烈推荐)</strong><br> <img src="https://images2.imgbox.com/0d/54/3r3K6GTr_o.png" width="70%"></p> 
<p>除了<strong>代码能力</strong>需要锻炼以外,很重要的一点是要<strong>有思路</strong>,通过画图辅助,可以很好地帮助我们找到思路和理解数据结构中的很多思想,切忌<strong>上来就开始码代码</strong>,这样对于简单的问题可能可以解决,但是对于稍微复杂的问题可能会让你头痛(大佬除外😂😂),很容易被绕进去,陷入痛苦的调试找bug环节.<br> 画图会让提供给我们清晰的思路,同时,即使出现了bug,也可以很快的找到,清晰可见.写代码只是用于实现思路,思路清晰,代码写起来并不困难.</p> 
<p><strong>3.刷题</strong><br> 刷题会锻炼我们的思考能力,解题是一种很灵活的事情.一方面可以巩固我们学的基础知识,另一方面可以拓展思维.<br> 最后,坚持学习才是最重要的.<br> <img src="https://images2.imgbox.com/4e/93/VG4TCddZ_o.gif" alt="在这里插入图片描述"></p> 
<h2><a id="_53"></a>算法效率如何衡量?</h2> 
<p>对于一个问题,可以有很多解法,那怎样衡量一个算法的好坏呢?<br> 比谁的代码更简洁吗?<br> 算法的效率主要考虑两点:<mark>1.时间复杂度. 2.空间复杂度</mark></p> 
<p>一个算法在编译生成可执行文件后,<strong>运行时</strong>会耗费时<strong>间资源和空间(内存)资源</strong> 。<br> 从时间和空间两个维度来衡量一个算法的好坏是比较合理的，这就是<strong>时间复杂度</strong>和<strong>空间复杂度</strong>。</p> 
<p><strong>时间复杂度</strong>主要衡量一个算法的运行快慢，而<strong>空间复杂度</strong>主要衡量一个算法运行所需要的<mark>额外空间</mark>。在计算机发展的早期，计算机的存储容量很小。所以对空间复杂度很是在乎。但是经过计算机行业的迅速发展，计算机的存储容量已经达到了很高的程度。所以我们如今已经不需要再特别关注一个算法的空间复杂度。</p> 
<h3><a id="__62"></a>一、 时间复杂度</h3> 
<blockquote> 
 <p>时间复杂度的定义：在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。一个算法执行所耗费的时间.</p> 
</blockquote> 
<p>但是从理论上说，这个只有将代码进行测试,并统计时间才能知道.并不能通过计算得到.<br> 但对于每一个算法,我们都去跑一下,这未免显得有些麻烦,我们可以通过算法中的代码估计运行<strong>大概的时间</strong>,看看属于哪一个<font color="red" size="5" face="楷体"><strong>量级</strong></font>来衡量它的效率.</p> 
<p>算法中的基本操作的执行次数，为算法的时间复杂度。<br> 即：找到某条基本语句与问题规模N之间的数学表达式，就是算出了该算法的<strong>时间复杂度</strong></p> 
<p>理论不是很理解的话,我们来点实际的,找几段代码算算吧!</p> 
<p>🌰小试牛刀<br> 你能算出在test1中++count语句最终被执行了多少次吗?</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token comment">//1</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token operator">++</span>count<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//2</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> k<span class="token operator">*=</span><span class="token number">2</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token operator">++</span>count<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//3</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">*</span> N<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token operator">++</span>count<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//4</span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token operator">--</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token operator">++</span>count<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>答案:<br> 1: N * N<br> 2: log<sub>2</sub> N<br> 3. 2*N<br> 4. 100</p> 
<p>则我们可以抽象出这样的数学公式:</p> 
<p>   <font size="5" face="微软雅黑" color="#00dd00">test(N)=N<sup>2</sup> +log<sub>2</sub> N+2N+100</font><br></p> 
<img src="https://images2.imgbox.com/07/84/2zrewT9E_o.png" width="50%"> 
<h4><a id="O_118"></a>大O的渐进表示法</h4> 
<p>计算机的运行速度是很快的,对于<strong>时间复杂度</strong>的计算,没有必要追求那么精确,对于那些<strong>对结果影响不大的项</strong>,我们可以<strong>忽略不计</strong>.如果我们只保留N<sup>2</sup>这一起<strong>决定因素</strong>的项.<br> <img src="https://images2.imgbox.com/20/ff/nMCvjyct_o.png" width="50%"></p> 
<p><strong>大O阶方法计算方法：</strong></p> 
<ul><li>1、用<strong>常数1</strong>取代运行时间中的<strong>所有加法常数</strong>。</li><li>2、在修改后的运行次数函数中，只保留<strong>最高阶项</strong>。</li><li>3、如果最高阶项存在且不是1，则<strong>去除</strong>与这个项目相乘的<strong>常数</strong>。得到的结果就是大O阶。</li></ul> 
<p>使用大O的渐进表示法以后，test1的时间复杂度为:</p> 
<table><tbody><tr><td bgcolor="#D1EEEE">(O)N ^ 2</td></tr></tbody></table> 
<p>即使是<mark>100N</mark>系数也应当去掉,因为当数据足够大的时候100的影响并不大.<br> 只要是常数,都应当是1.<br> 也许你会认为100很大或者100000很大.但是,要看和谁比,如果是和10亿比呢?一万亿比呢?<br> 那我们打个比方:</p> 
<blockquote> 
 <p>你觉得你们学校大吗?还行.<br> 你所在的城市大吗?算大吧!<br> 你觉得我们的祖国大吗?地大物博,确实大.</p> 
</blockquote> 
<p>但是,与太阳系相比呢?与银河系相比呢?这就显得很渺小了,沧海之一粟罢了.<br> 所以当数据量足够大的时候,常数项和那些影响不大的忽略不计.</p> 
<img src="https://images2.imgbox.com/0d/e6/vKJo3tAl_o.png" width="50%"> 
<h4><a id="_147"></a>时间复杂度的练习:</h4> 
<h4><a id="11__148"></a>1.1 常见的时间复杂度:</h4> 
<p>例1:</p> 
<pre><code class="prism language-c"><span class="token comment">// 计算Test2的时间复杂度？</span>
<span class="token keyword">void</span> <span class="token function">Test2</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	 <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">*</span> N <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	 <span class="token punctuation">{<!-- --></span>
	 	<span class="token operator">++</span>count<span class="token punctuation">;</span>
	 <span class="token punctuation">}</span>
	 <span class="token keyword">int</span> M <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	 <span class="token keyword">while</span> <span class="token punctuation">(</span>M<span class="token operator">--</span><span class="token punctuation">)</span>
	 <span class="token punctuation">{<!-- --></span>
		 <span class="token operator">++</span>count<span class="token punctuation">;</span>
	 <span class="token punctuation">}</span>
	 <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>例2:</p> 
<pre><code class="prism language-c"><span class="token comment">// 计算Test3的时间复杂度？</span>
<span class="token keyword">void</span> <span class="token function">Test3</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">,</span> <span class="token keyword">int</span> M<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	 <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> M<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	 <span class="token punctuation">{<!-- --></span>
	 	<span class="token operator">++</span>count<span class="token punctuation">;</span>
	 <span class="token punctuation">}</span>
	 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	 <span class="token punctuation">{<!-- --></span>
		 <span class="token operator">++</span>count<span class="token punctuation">;</span>
	 <span class="token punctuation">}</span>
	 <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>例3:</p> 
<pre><code class="prism language-c"><span class="token comment">// 计算Test4的时间复杂度？</span>
<span class="token keyword">void</span> <span class="token function">Test4</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	 <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	 <span class="token punctuation">{<!-- --></span>
		 <span class="token operator">++</span>count<span class="token punctuation">;</span>
	 <span class="token punctuation">}</span>
	 <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>答案:<br> 这三个例子的时间复杂度还是很好计算的.<br> 例1:</p> 
<blockquote> 
 <p>2N+10用大O表示法表示时间复杂度为O(N).</p> 
</blockquote> 
<p>例2:</p> 
<blockquote> 
 <p>基本操作执行了M+N次，有两个未知数M和N，时间复杂度为 O(N+M)<br> 如果m和n相等则可以表示为O(N),如果一方远大于另一方,则可以用大的一方表示,记住是远大于,即不在一个<strong>量级</strong>.</p> 
</blockquote> 
<p>例3:</p> 
<blockquote> 
 <p>基本操作语句被执行了常数次.这用大O表示法表示时间复杂度为O(1).</p> 
</blockquote> 
<p>那试着分析<code>TargetNum</code>函数的时间复杂度.<br> <code>TargetNum</code>函数是用于在一个数组中查找目标值的函数,找到了就返回目标值的地址,没找到就返回NULL.</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span><span class="token operator">*</span> <span class="token function">TargetNum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> num<span class="token punctuation">)</span><span class="token comment">//找到目标数字则返回数字的地址</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> arr <span class="token operator">+</span> i<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">*</span>ret <span class="token operator">=</span><span class="token function">TargetNum</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"该目标值不存在"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>sz <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>ret <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>此时就让人有些疑惑了,这个函数的时间复杂度似乎不是固定的.在1~n的范围之间的那如何确定它的时间复杂度呢?<br> <img src="https://images2.imgbox.com/27/d9/5i46MuIi_o.gif" alt="在这里插入图片描述"></p> 
<p>分析一下:<br> 最好情况时(第一个数就是目标值): O(1).<br> 平均情况时:O(n/2).<br> 最坏情况时:O(n).</p> 
<p>那我们选择哪种情况比较合理呢?<br> 那我们讲一个小故事吧.</p> 
<blockquote> 
 <p>假如你是一名高中生,你刚经历期末考试,晚上,老师只公布了部分答案.<br> 你可以确保自己可以拿到60分,有剩余的40分中,你按照以往的每次考试的经验来看,不出意外20分是可以拿到的.<br> 此时回到家中,老爸问你能考多少分?考多少分老爸就奖励你多少钱,嘿嘿.🍭🍭🍭<br> 你会说80(平均情况)分吗?还是会选择100分(最好情况)呢?<br> 万一食言了呢?<br> 咱一般都会选择最坏的情况,那样即使出现了意外,我们也没有说错,而不出意外时,无论是平均还是最好情况,我们都会比较高兴的.</p> 
</blockquote> 
<p>这里牛牛也想告诉大家,结局未定之前,不要过分高看自己,降低期望,当然也不要自卑,继续努力,继续前行,保持对生活的热爱,生活也会拥抱你的!🍭🍭🍭</p> 
<p>回到正题,此时我们会选择<strong>最坏的情况</strong>作为<strong>时间复杂度</strong>,即<code>TargetNum</code>函数的时间复杂度是O(n).</p> 
<h4><a id="12__267"></a>1.2 冒泡排序的时间复杂度</h4> 
<p>大家还记得c语言时学的冒泡排序吗?</p> 
<pre><code class="prism language-c"><span class="token comment">// 计算BubbleSort的时间复杂度？</span>
<span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	 <span class="token function">assert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> end <span class="token operator">=</span> n<span class="token punctuation">;</span> end <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>end<span class="token punctuation">)</span>
	 <span class="token punctuation">{<!-- --></span>
	 	<span class="token keyword">int</span> exchange <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	 <span class="token punctuation">{<!-- --></span>
	 	<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
	 	<span class="token punctuation">{<!-- --></span>
	 		<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	 		exchange <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	 	<span class="token punctuation">}</span>
	 <span class="token punctuation">}</span>
	 <span class="token keyword">if</span> <span class="token punctuation">(</span>exchange <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
	 	<span class="token keyword">break</span><span class="token punctuation">;</span>
	 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>那么<strong>最好情况</strong>和<strong>最坏情况</strong>时的<strong>时间复杂度</strong>分别是多少呢?</p> 
<p>对于冒泡排序不熟悉的友友们可能会以为最好的情况时O(0)或者O(1).<br> 首先呢,没有O(0)这一说法,这几乎不可能,其次这里最好的情况也不是O(1),为什么呢?<br> 如果数组有序,那不就不需要排序吗?那不就是O(1)吗?</p> 
<p>其实,<strong>即使数组有序</strong>,我们也需要<strong>循环遍历一遍这个数组</strong>,才能知道有序,计算机不是人哦,他不能看一眼就知道有序,而且就算是人,当数据量比较大的时候人一眼也看不出来是否有序吧!<br> 总结:<br> <strong>最好情况:O(N)<br> 最坏情况:O(N<sup>2</sup>)</strong></p> 
<h4><a id="13__302"></a>1.3 "二分查找"的时间复杂度</h4> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">BinarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	 <span class="token function">assert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token keyword">int</span> begin <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	 <span class="token keyword">int</span> end <span class="token operator">=</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	 <span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;=</span> end<span class="token punctuation">)</span>
	 <span class="token punctuation">{<!-- --></span>
	 	<span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>begin<span class="token operator">+</span>end<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//找到中间值</span>
	 	<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> x<span class="token punctuation">)</span><span class="token comment">//如果该值比中间值大,则直接从中间值的后半部分里面找</span>
		<span class="token punctuation">{<!-- --></span>
		 	begin <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&gt;</span> x<span class="token punctuation">)</span><span class="token comment">//如果该值比中间值小,则直接从中间值的前半部分里面找</span>
		 <span class="token punctuation">{<!-- --></span>
		 	end <span class="token operator">=</span> mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
		 <span class="token punctuation">}</span>
	 	<span class="token keyword">else</span><span class="token comment">//找到了</span>
	 		<span class="token keyword">return</span> mid<span class="token punctuation">;</span>
	 <span class="token punctuation">}</span>
	 <span class="token comment">//没找到返回-1,这里设置为-1也许有些不合理,可以使用逻辑值.</span>
	 <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>判断一次(与中间值比较),就可以去掉一半的值.即该算法一次N的值就会等于N/2.<br> 不难得出该算法的时间复杂度是O(log<sub>n</sub>2).</p> 
<p>补充知识:<strong>log<sub>n</sub>2经常省略写成log2甚至lg2</strong></p> 
<p>"二分查找"看起来平平无奇,但其实是个隐藏的<strong>大佬</strong>啊!<br> 大家知道这些量级的差距有多大吗?log2是很可怕的<strong>量级</strong>,速度极快.<br> 看图感受一下吧!</p> 
<img src="https://images2.imgbox.com/72/26/lCSmzOrY_o.png" width="70%"> 
<p>友友们感受到<strong>二分查找</strong>的厉害了吧!</p> 
<p>遗憾的是,二分查找的<mark>前提是数据得是有序</mark>的,否则他无法实现一次排除一半.而数据往往是无序的,并且有些特殊的数据还不允许排序,排序会破坏数据的.<br> 这也就让二分查找无计可施了,纸老虎罢了.😂😂😂</p> 
<h4><a id="14__344"></a>1.4 递归的时间复杂度:</h4> 
<pre><code class="prism language-c"><span class="token comment">// 计算阶乘递归Fac的时间复杂度？</span>
<span class="token keyword">int</span> <span class="token function">Fac</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	 <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> N<span class="token punctuation">)</span><span class="token comment">//递归的结束条件</span>
	 <span class="token punctuation">{<!-- --></span>
	 	<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	 <span class="token punctuation">}</span>
	 
	 <span class="token keyword">return</span> <span class="token function">Fac</span><span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>N<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>递归的时间复杂度计算主要是根据其<strong>递归的层数</strong>来决定.<br> 该算法每次递归N就-1,则递归的次数为N.<br> 故算法的<strong>时间复杂度为:O(N).</strong></p> 
<pre><code class="prism language-c"><span class="token comment">// 计算斐波那契递归Fib的时间复杂度？</span>
<span class="token keyword">int</span> <span class="token function">Fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	 <span class="token keyword">if</span><span class="token punctuation">(</span>N <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span>
	 <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	 
	 <span class="token keyword">return</span> <span class="token function">Fib</span><span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">Fib</span><span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>此算法,每次经过递归都需要再递归2 * N次.<br> <img src="https://images2.imgbox.com/b4/a4/zT7hTShX_o.png" alt="在这里插入图片描述"><br> 则此算法的时间复杂度为O(2<sup>n</sup>).</p> 
<h4><a id="_378"></a>常见量级的比较图</h4> 
<p><strong>大O的渐进表示法:</strong><br> <img src="https://images2.imgbox.com/5c/04/J61LdJyA_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_384"></a>二、空间复杂度</h3> 
<p>空间复杂度<strong>并不是重点</strong>,现如今,一般情况下我们的时间的价值比空间的价值要高的多.<br> 定义:</p> 
<blockquote> 
 <p>空间复杂度也是一个数学表达式，是对一个算法在运行过程中临时占用存储空间大小的量度 。<br> 空间复杂度不是程序占用了多少bytes的空间，因为这个也没太大意义，所以空间复杂度算的是变量的个数。<br> 空间复杂度计算规则基本跟实践复杂度类似，也使用大O渐进表示法。</p> 
</blockquote> 
<p>注意：函数运行时所需要的栈空间(存储参数、局部变量、一些寄存器信息等)在编译期间已经确定好了，因此空间复杂度主要通过函数在运行时候显式申请的额外空间来确定</p> 
<p>例题:<br> 还是拿冒泡排序来举例吧!</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	 <span class="token function">assert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> end <span class="token operator">=</span> n<span class="token punctuation">;</span> end <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>end<span class="token punctuation">)</span>
	 <span class="token punctuation">{<!-- --></span>
	 	<span class="token keyword">int</span> exchange <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	 <span class="token punctuation">{<!-- --></span>
	 	<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
	 	<span class="token punctuation">{<!-- --></span>
	 		<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	 		exchange <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	 	<span class="token punctuation">}</span>
	 <span class="token punctuation">}</span>
	 <span class="token keyword">if</span> <span class="token punctuation">(</span>exchange <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
	 	<span class="token keyword">break</span><span class="token punctuation">;</span>
	 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>为了实现冒泡排序我们定义了<code>int exchange = 0;</code>以及<code>Swap(&amp;a[i-1], &amp;a[i]);</code>函数中的<code>int tmp.</code><br> 这项常数个临时变量,故空间复杂度为O(1).</p> 
<p>例2:</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">Fac</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	 <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> N<span class="token punctuation">)</span><span class="token comment">//递归的结束条件</span>
	 <span class="token punctuation">{<!-- --></span>
	 	<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	 <span class="token punctuation">}</span>
	 
	 <span class="token keyword">return</span> <span class="token function">Fac</span><span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>N<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>同样递归的空间复杂度由开辟的栈帧个数(每次递归开辟一次栈帧)决定，开辟了N个栈帧，每个栈帧使用了常数个空间。空间复杂度为O(N).</p> 
<p>好了,数据结构的初步认识就到这里啦!后续牛牛会继续更新数据结构的相关知识.<br> 如果文章对大家有用的话记得一键三连哦!💗💗💗<br> <font color="#dd00dd">如果文章中有部分错误之处,可以私信牛牛,互相讨论哦!!!</font><br></p> 
<p><img src="https://images2.imgbox.com/1c/c8/kXQbZz28_o.gif" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/faf03cea3b663cc37cdf48542570f668/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【PCL】—— 点云配准ICP(Iterative Closest Point)算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/315a93737307710d61e59c779afcccfa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">人工智能之配置环境教程二：在Anaconda中创建虚拟环境安装GPU版本的Pytorch及torchvision并在VsCode中使用虚拟环境</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>