<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>口袋算法的示例 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/305f60b431b91146936098a1de49c8d4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="口袋算法的示例">
  <meta property="og:description" content="原理 口袋算法是感知器（Perceptron）算法的一种改进。感知器算法是一种线性分类算法，但在训练数据不是线性可分的情况下，它可能无法收敛，即无法找到一个线性分类器来正确分类所有的训练样本。为了解决这个问题，口袋算法引入了一个&#34;口袋&#34;（Pocket），用来存储迄今为止最好的权重向量（即使它不能正确分类所有样本，但错误率最低）。
口袋算法的基本思想是：
初始化权重向量。在每次迭代中，随机选择一个误分类样本。根据这个样本更新权重向量。如果更新后的权重向量比当前最佳的权重向量更好（即误分类样本更少），则将其存入&#34;口袋&#34;中。继续迭代直到达到预定的最大迭代次数或连续若干次迭代不再更新最佳权重向量。 作用 口袋算法的作用是改进感知器算法，使其能够在训练数据非线性可分的情况下仍然能够找到一个尽可能好的线性分类器。它能够在一定程度上减少误分类的样本数，提高分类器的准确性。
口袋算法步骤 初始化：
迭代：
终止条件：
达到预定的最大迭代次数。连续若干次迭代不再更新最佳权重向量。 数学原理推导过程 口袋算法（Pocket Algorithm）是感知器算法的一种改进版本。它旨在解决感知器算法在处理非线性可分数据集时可能无法收敛的问题。口袋算法引入了一个“口袋”来存储迄今为止最好的权重向量，以确保即使在数据集不可线性分的情况下，算法也能找到一个尽可能好的线性分类器。
口袋算法的改进 口袋算法在感知器算法的基础上引入了一个“口袋”，用于存储迄今为止最好的权重向量。具体步骤如下：
3. 终止条件：
达到预定的最大迭代次数。连续若干次迭代不再更新最佳权重向量。 数学推导 感知器学习算法（PLA） 感知器学习算法（PLA，Perceptron Learning Algorithm）是机器学习中的一种基础算法，专用于处理二分类问题。它的目标是找到一条能够线性分割两个类别的超平面。
PLA的关键概念 线性可分：
PLA假设数据是线性可分的，即存在一个超平面能够将两个类别的数据完全分开。 算法步骤：
PLA从初始权重开始，通常设置为零向量。遍历训练数据，对每个样本进行分类，如果分类错误，则更新权重。更新规则是简单的：对于一个分类错误的样本，按照样本的特征向量和标签的乘积进行更新。 更新规则：
权重更新规则可以表示为： 收敛性：
如果数据是线性可分的，PLA保证能找到一个超平面正确分类所有训练数据。如果数据不是线性可分的，PLA可能永远不会收敛。 PLA与口袋算法 口袋算法是PLA的扩展，设计用来处理线性不可分的数据。其关键思想是保持（或放入口袋）迄今为止找到的最佳解决方案，即使当前权重向量不能完美分类所有数据，也会保留错误最少的那个。
PLA的例子 以下是PLA的一个简化版本的实现：
import numpy as np def perceptron_learning_algorithm(X, y): &#34;&#34;&#34; 感知器学习算法实现。 注意：该算法仅适用于线性可分的数据集。对于不可线性分的数据集，算法可能不会收敛。 参数： X (ndarray): 训练数据特征，形状为 (样本数, 特征数) y (ndarray): 目标标签，形状为 (样本数,) 返回值： ndarray: 学习到的权重系数，形状为 (特征数,) &#34;&#34;&#34; # 初始化变量 done = False W = np.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-16T22:44:26+08:00">
    <meta property="article:modified_time" content="2024-07-16T22:44:26+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">口袋算法的示例</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>原理</h2> 
<p>口袋算法是感知器（Perceptron）算法的一种改进。感知器算法是一种线性分类算法，但在训练数据不是线性可分的情况下，它可能无法收敛，即无法找到一个线性分类器来正确分类所有的训练样本。为了解决这个问题，口袋算法引入了一个"口袋"（Pocket），用来存储迄今为止最好的权重向量（即使它不能正确分类所有样本，但错误率最低）。</p> 
<p>口袋算法的基本思想是：</p> 
<ol><li>初始化权重向量。</li><li>在每次迭代中，随机选择一个误分类样本。</li><li>根据这个样本更新权重向量。</li><li>如果更新后的权重向量比当前最佳的权重向量更好（即误分类样本更少），则将其存入"口袋"中。</li><li>继续迭代直到达到预定的最大迭代次数或连续若干次迭代不再更新最佳权重向量。</li></ol> 
<h2>作用</h2> 
<p>口袋算法的作用是改进感知器算法，使其能够在训练数据非线性可分的情况下仍然能够找到一个尽可能好的线性分类器。它能够在一定程度上减少误分类的样本数，提高分类器的准确性。</p> 
<h2>口袋算法步骤</h2> 
<ul><li> <p><strong>初始化</strong>：</p> 
  <ul><li><img alt="" height="190" src="https://images2.imgbox.com/4a/cb/3AVP7jFe_o.png" width="675"></li></ul></li><li> <p><strong>迭代</strong>：</p> 
  <ul><li><img alt="" height="294" src="https://images2.imgbox.com/99/8f/7GS2qPjS_o.png" width="803"></li></ul></li><li> <p><strong>终止条件</strong>：</p> 
  <ul><li>达到预定的最大迭代次数。</li><li>连续若干次迭代不再更新最佳权重向量。</li></ul></li></ul> 
<h2>数学原理推导过程</h2> 
<p>           口袋算法（Pocket Algorithm）是感知器算法的一种改进版本。它旨在解决感知器算法在处理非线性可分数据集时可能无法收敛的问题。口袋算法引入了一个“口袋”来存储迄今为止最好的权重向量，以确保即使在数据集不可线性分的情况下，算法也能找到一个尽可能好的线性分类器。</p> 
<p><img alt="" height="451" src="https://images2.imgbox.com/2f/38/bfmRHnpm_o.png" width="993"></p> 
<h3>口袋算法的改进</h3> 
<p>口袋算法在感知器算法的基础上引入了一个“口袋”，用于存储迄今为止最好的权重向量。具体步骤如下：</p> 
<p><img alt="" height="648" src="https://images2.imgbox.com/fb/8d/dVR1x39d_o.png" width="966"></p> 
<p><strong>3.  终止条件</strong>：</p> 
<ul><li>达到预定的最大迭代次数。</li><li>连续若干次迭代不再更新最佳权重向量。</li></ul> 
<h3>数学推导</h3> 
<p><img alt="" height="600" src="https://images2.imgbox.com/53/df/bCeoPBHL_o.png" width="970"></p> 
<h2>感知器学习算法（PLA）</h2> 
<p>感知器学习算法（PLA，Perceptron Learning Algorithm）是机器学习中的一种基础算法，专用于处理二分类问题。它的目标是找到一条能够线性分割两个类别的超平面。</p> 
<h3>PLA的关键概念</h3> 
<ol><li> <p><strong>线性可分</strong>：</p> 
  <ul><li>PLA假设数据是线性可分的，即存在一个超平面能够将两个类别的数据完全分开。</li></ul></li><li> <p><strong>算法步骤</strong>：</p> 
  <ul><li>PLA从初始权重开始，通常设置为零向量。</li><li>遍历训练数据，对每个样本进行分类，如果分类错误，则更新权重。</li><li>更新规则是简单的：对于一个分类错误的样本，按照样本的特征向量和标签的乘积进行更新。</li></ul></li><li> <p><strong>更新规则</strong>：</p> 
  <ul><li>权重更新规则可以表示为： <img alt="" height="148" src="https://images2.imgbox.com/ea/a3/z4d4T4uy_o.png" width="816"></li></ul></li></ol> 
<ol><li> <p><strong>收敛性</strong>：</p> 
  <ul><li>如果数据是线性可分的，PLA保证能找到一个超平面正确分类所有训练数据。</li><li>如果数据不是线性可分的，PLA可能永远不会收敛。</li></ul></li></ol> 
<h3>PLA与口袋算法</h3> 
<p>口袋算法是PLA的扩展，设计用来处理线性不可分的数据。其关键思想是保持（或放入口袋）迄今为止找到的最佳解决方案，即使当前权重向量不能完美分类所有数据，也会保留错误最少的那个。</p> 
<h3>PLA的例子</h3> 
<p>以下是PLA的一个简化版本的实现：</p> 
<pre><code class="language-python">import numpy as np

def perceptron_learning_algorithm(X, y):
    """
    感知器学习算法实现。
    注意：该算法仅适用于线性可分的数据集。对于不可线性分的数据集，算法可能不会收敛。
    
    参数：
    X (ndarray): 训练数据特征，形状为 (样本数, 特征数)
    y (ndarray): 目标标签，形状为 (样本数,)
    
    返回值：
    ndarray: 学习到的权重系数，形状为 (特征数,)
    """
    # 初始化变量
    done = False
    W = np.zeros(X.shape[1])  # 初始化权重系数为零
    
    # 迭代直到收敛
    while not done:
        done = True
        
        # 遍历训练数据中的每个样本
        for index in range(len(X)):
            x = X[index]
            
            # 检查当前样本是否被错误分类
            if np.dot(x, W) * y[index] &lt;= 0:
                done = False
                # 更新权重系数
                W += y[index] * x
    
    return W

# 示例用法：
if __name__ == "__main__":
    # 示例数据：二维点及其标签
    X = np.array([[2, 3], [4, 5], [1, 8], [6, 2], [7, 3]])
    y = np.array([1, 1, -1, -1, 1])
    
    # 运行感知器学习算法
    W = perceptron_learning_algorithm(X, y)
    
    # 输出学习到的权重系数
    print("Learned weights:", W)
</code></pre> 
<h4>运行结果</h4> 
<pre><code class="language-python">Learned weights: [10.  4.]
</code></pre> 
<h4>结果解释</h4> 
<ol><li> <p><strong>初始权重</strong>: 程序首先将权重向量 <code>W</code> 初始化为零向量，即 <code>[0, 0]</code>。这意味着在开始时，算法没有任何偏向性。</p> </li><li> <p><strong>遍历样本</strong>: 在每次迭代中，算法遍历所有样本，检查每个样本是否被正确分类。</p> </li><li> <p><strong>更新权重</strong>: 如果发现某个样本被错误分类（即当前权重 <code>W</code> 无法正确分类该样本），则算法会更新权重。更新公式为：</p> </li></ol> 
<p><img alt="" height="111" src="https://images2.imgbox.com/9c/1a/jwJcs1Q8_o.png" width="604"></p> 
<p><strong>    </strong>4.<strong> 收敛</strong>: 当所有样本都被正确分类时，算法停止迭代，并返回最终的权重向量。</p> 
<h4>权重向量 <code>[10, 4]</code> 的含义</h4> 
<ul><li>学习到的权重向量 <code>[10, 4]</code> 表示一个直线决策边界，能够将样本点正确地线性分割为两类。</li><li>在二维平面中，直线的方程为：</li></ul> 
<p><img alt="" height="78" src="https://images2.imgbox.com/ec/b5/hG5OtQ7r_o.png" width="459"></p> 
<p>             这条直线将样本空间分为两部分，使得每个部分包含相应类别的样本点。</p> 
<h4>总结</h4> 
<ul><li>感知器学习算法通过反复调整权重，找到一个线性决策边界，使得所有样本点都被正确分类。</li><li>该算法对于线性可分的数据集非常有效，但对于不可线性分的数据集可能不会收敛。</li></ul> 
<h3>感知器学习算法演示</h3> 
<pre><code>import numpy as np

def perceptron_learning_algorithm_with_history(X, y):
    """
    感知器学习算法实现，带有权重历史记录。
    注意：该算法仅适用于线性可分的数据集，对于线性不可分的数据集，该函数将不会收敛。
    
    参数：
    X (ndarray): 训练数据特征，形状为 (样本数, 特征数)
    y (ndarray): 目标标签，形状为 (样本数,)
    
    返回：
    ndarray: 权重系数历史记录数组，形状为 (迭代次数, 特征数)
    list: 误分类样本的索引列表
    """
    done = False
    W = np.zeros(X.shape[1])  # 初始化权重系数为零
    weight_history = np.array([W])  # 数组用于存储权重系数的历史记录
    error_indices = []  # 列表用于存储误分类样本的索引
    
    while not done:
        done = True
        for index in range(len(X)):  # 遍历训练数据中的每一个样本
            x = X[index]
            if np.dot(x, W) * y[index] &lt;= 0:  # 检查当前样本是否被误分类
                done = False
                W = W + y[index] * x  # 更新权重系数
                weight_history = np.append(weight_history, [W], axis=0)  # 将更新后的权重系数添加到历史记录
                error_indices.append(index)  # 记录误分类样本的索引
    
    return weight_history, error_indices

# 示例代码
if __name__ == "__main__":
    # 生成示例数据：带标签的二维点
    X = np.array([[2, 3], [4, 5], [1, 8], [6, 2], [7, 3]])
    y = np.array([1, 1, -1, -1, 1])
    
    # 运行感知器学习算法
    weight_history, error_indices = perceptron_learning_algorithm_with_history(X, y)
    
    # 输出学习到的权重系数和误分类样本的索引
    print("权重历史记录：\n", weight_history)
    print("误分类样本的索引：\n", error_indices)
</code></pre> 
<h4>结果与解释</h4> 
<p>假设示例数据如下：</p> 
<p>特征值 (X):</p> 
<pre><code>[[2, 3],
 [4, 5],
 [1, 8],
 [6, 2],
 [7, 3]]
</code></pre> 
<p>目标标签值 (y):</p> 
<pre><code>[ 1,  1, -1, -1,  1]
</code></pre> 
<p>运行算法后，可能得到以下输出：</p> 
<pre><code>权重历史记录：
 [[ 0.  0.]
  [ 2.  3.]
  [ 1. 11.]
  [-5. -3.]]
误分类样本的索引：
 [0, 2, 3]
</code></pre> 
<p><strong>解释</strong>：</p> 
<ul><li>初始权重系数为 [0, 0]。</li><li>第一次更新后权重系数变为 [2, 3]。</li><li>第二次更新后权重系数变为 [1, 11]。</li><li>第三次更新后权重系数变为 [-5, -3]。</li></ul> 
<p>误分类样本的索引表示在训练过程中被误分类的样本在数据集中的位置。通过权重历史记录，可以观察到权重的更新过程和算法的收敛情况。</p> 
<p>参考：</p> 
<p>文献一、<a class="link-info" href="https://github.com/lawlite19/MachineLearning_Python" title="https://github.com/lawlite19/MachineLearning_Python">https://github.com/lawlite19/MachineLearning_Python</a></p> 
<p>文献二、<a class="link-info" href="https://github.com/Jack-Lee-Hiter/AlgorithmsByPython" title="https://github.com/Jack-Lee-Hiter/AlgorithmsByPython">https://github.com/Jack-Lee-Hiter/AlgorithmsByPython</a></p> 
<p>文献三、<a class="link-info" href="https://github.com/zkywsg/Daily-DeepLearning?tab=readme-ov-file" title="https://github.com/zkywsg/Daily-DeepLearning?tab=readme-ov-file">https://github.com/zkywsg/Daily-DeepLearning?tab=readme-ov-file</a></p> 
<p>文献四、<a class="link-info" href="https://github.com/MemorialCheng/deep-learning-from-scratch" title="https://github.com/MemorialCheng/deep-learning-from-scratch">https://github.com/MemorialCheng/deep-learning-from-scratch</a></p> 
<p>文献五、<a class="link-info" href="https://github.com/shunliz/Machine-Learning" title="https://github.com/shunliz/Machine-Learning">https://github.com/shunliz/Machine-Learning</a></p> 
<p>文献六、<a class="link-info" href="https://github.com/Saisimon/AIMindMap/tree/main/machine-learning" title="https://github.com/Saisimon/AIMindMap/tree/main/machine-learning">https://github.com/Saisimon/AIMindMap/tree/main/machine-learning</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/414e5d66541353f1b9dcf73e05642ba8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python 正则表达式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8f4e9968229a26df6a50b9b5be8250e5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">二维空间和三维空间刚体变换中雅克比矩阵的推导</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>