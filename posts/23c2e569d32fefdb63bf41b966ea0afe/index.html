<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Zookeeper入门篇，了解ZK存储特点 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/23c2e569d32fefdb63bf41b966ea0afe/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Zookeeper入门篇，了解ZK存储特点">
  <meta property="og:description" content="Zookeeper入门篇，了解ZK存储特点 前言一、为什么要用 Zookeeper？二、Zookeeper存储特色1. 树状结构2. 节点类型 三、存储位置1. 内存存储1. DataTree2. DataNode 2. 硬盘存储1. 事务日志2. 快照 前言 继上次说完 Zookeeper 的安装后，已经过去半年多了，一直没有后续，本次得空就更新一下入门篇，给同学们介绍一下 Zookeeper ，并着重说一下其存储原理
📕作者简介：战斧，从事金融IT行业，有着多年一线开发、架构经验；爱好广泛，乐于分享，致力于创作更多高质量内容
📗本文收录于 Zookeeper 专栏，有需要者，可直接订阅专栏实时获取更新
📘高质量专栏 云原生、RabbitMQ、Spring全家桶 等仍在更新，欢迎指导
📙 mysql Redis dubbo docker netty等诸多框架，以及架构与分布式专题即将上线，敬请期待
一、为什么要用 Zookeeper？ 我们先看 Zookeeper 官方自己的定义
ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services. All of these kinds of services are used in some form or another by distributed applications.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-22T14:13:19+08:00">
    <meta property="article:modified_time" content="2024-07-22T14:13:19+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Zookeeper入门篇，了解ZK存储特点</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Zookeeper入门篇，了解ZK存储特点</h4> 
 <ul><li><a href="#_6" rel="nofollow">前言</a></li><li><a href="#_Zookeeper_23" rel="nofollow">一、为什么要用 Zookeeper？</a></li><li><a href="#Zookeeper_37" rel="nofollow">二、Zookeeper存储特色</a></li><li><ul><li><a href="#1__39" rel="nofollow">1. 树状结构</a></li><li><a href="#2__44" rel="nofollow">2. 节点类型</a></li></ul> 
  </li><li><a href="#_62" rel="nofollow">三、存储位置</a></li><li><ul><li><a href="#1__65" rel="nofollow">1. 内存存储</a></li><li><ul><li><a href="#1_DataTree_68" rel="nofollow">1. DataTree</a></li><li><a href="#2_DataNode_73" rel="nofollow">2. DataNode</a></li></ul> 
   </li><li><a href="#2__89" rel="nofollow">2. 硬盘存储</a></li><li><ul><li><a href="#1__91" rel="nofollow">1. 事务日志</a></li><li><a href="#2__128" rel="nofollow">2. 快照</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_6"></a>前言</h2> 
<p><img src="https://images2.imgbox.com/08/64/6X6QdIhY_o.png" alt="在这里插入图片描述"></p> 
<p><code>继上次说完 Zookeeper 的安装后，已经过去半年多了，一直没有后续，本次得空就更新一下入门篇，给同学们介绍一下 Zookeeper ，并着重说一下其存储原理</code></p> 
<blockquote> 
 <p>📕作者简介：战斧，从事金融IT行业，有着多年一线开发、架构经验；爱好广泛，乐于分享，致力于创作更多高质量内容<br> 📗本文收录于 <a href="https://blog.csdn.net/u011709538/category_12370704.html">Zookeeper</a> 专栏，有需要者，可直接订阅专栏实时获取更新<br> 📘高质量专栏 <a href="https://blog.csdn.net/u011709538/category_12400343.html">云原生</a>、<a href="https://blog.csdn.net/u011709538/category_12356838.html">RabbitMQ</a>、<a href="https://blog.csdn.net/u011709538/category_9161843.html">Spring全家桶</a> 等仍在更新，欢迎指导<br> 📙 <a href="https://blog.csdn.net/u011709538/category_12505673.html">mysql</a> Redis <a href="https://blog.csdn.net/u011709538/category_12363619.html">dubbo</a> docker netty等诸多框架，以及架构与分布式专题即将上线，敬请期待</p> 
</blockquote> 
<hr> 
<h2><a id="_Zookeeper_23"></a>一、为什么要用 Zookeeper？</h2> 
<p>我们先看 Zookeeper 官方自己的定义</p> 
<blockquote> 
 <p>ZooKeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services. All of these kinds of services are used in some form or another by distributed applications. Each time they are implemented there is a lot of work that goes into fixing the bugs and race conditions that are inevitable. Because of the difficulty of implementing these kinds of services, applications initially usually skimp on them, which make them brittle in the presence of change and difficult to manage. Even when done correctly, different implementations of these services lead to management complexity when the applications are deployed.<br> ZooKeeper是一个集中的服务，用于维护配置信息、命名、提供分布式同步、提供组服务。分布式应用程序以某种形式使用所有这些类型的服务。每次实现它们时，都有大量的工作要做，以修复不可避免的错误和竞争条件。由于实现这类服务的困难，应用程序最初通常会忽略它们，这使得它们在出现变化时变得脆弱，并且难以管理。即使正确地完成了这些服务，在部署应用程序时，这些服务的不同实现也会导致管理复杂性。</p> 
</blockquote> 
<p>说人话，就是人如其名，ZooKeeper 就是动物园管理者，而各个组件和应用则是动物园里的动物。我们每引入一个组件，就可以把组件的配置信息，以及组件提供的服务信息等内容存储在ZK里。</p> 
<p>如果仅仅是保存信息，那么很多组件都有这个能力，凭什么要有这么个<code>ZooKepper</code>？主要是<code>ZooKepper</code>有一些特性比较好用，比如：<strong>高可用</strong>、<strong>高性能</strong>、<strong>一致性</strong> 等</p> 
<p><strong>当然最实用的肯定是其提供了 <code>监听与心跳</code> 的功能：<code>心跳</code>可以用来检测节点的存活状态。节点在启动时会向ZK服务器发送心跳消息，如果一段时间内没有收到节点的心跳消息，ZK服务器会认为该节点不可用，而<code>监听</code>则可以让应用程序在ZK节点发生变化时收到通知，当节点发生变化（如节点创建、删除、数据变更）时，ZK会将变化事件通知到注册的监听器上。这样，应用程序可以及时响应节点变化，进行相应的处理。</strong></p> 
<h2><a id="Zookeeper_37"></a>二、Zookeeper存储特色</h2> 
<h3><a id="1__39"></a>1. 树状结构</h3> 
<p>首先，让我们了解 Zookeeper 存储的基本原理。<strong>Zookeeper 使用一种<code>层次化</code>的命名空间进行数据存储，类似于一个树形结构。每个节点都是一个 znode</strong>，可以包含数据和子节点。Zookeeper 的数据存储是基于内存的，这意味着可以快速访问和更新数据。同时，Zookeeper 还使用了一种<strong>类似于文件系统的节点路径</strong>来唯一标识每个 znode，可以方便地对数据进行读写和查询，如下：</p> 
<p><img src="https://images2.imgbox.com/c9/0c/vT3cXLri_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2__44"></a>2. 节点类型</h3> 
<p>上面我们说了，ZK是以树状节点的样式来管理存储信息的。同时ZK也提供了四种节点类型：</p> 
<ol><li> <p><code>持久节点</code>（Persistent Node）：创建后将一直存在，直到主动删除。当客户端与ZK断开连接后，持久节点的数据依然保留。</p> </li><li> <p><code>临时节点</code>（Ephemeral Node）：只在创建它的客户端与ZK保持连接期间存在，一旦客户端断开连接，临时节点将被自动删除。</p> </li><li> <p><code>持久顺序节点</code>（Persistent Sequential Node）：创建后将一直存在，直到主动删除。与持久节点类似，但ZK会为每个创建的节点自动分配一个递增的序列号。</p> </li><li> <p><code>临时顺序节点</code>（Ephemeral Sequential Node）：只在创建它的客户端与ZK保持连接期间存在，一旦客户端断开连接，临时节点将被自动删除。与临时节点类似，但ZK会为每个创建的节点自动分配一个递增的序列号。<br> Zooke</p> </li></ol> 
<p>说是四种节点，其实主要是两个属性：<strong>① 是否临时、② 是否排序</strong>。这种设计使得我们在很多场景都能利用上ZK。</p> 
<p>比如<code>临时节点</code>通常用于表示临时的状态信息、临时的工作单元等。当一个临时节点的客户端与ZooKeeper会话断开连接时，该节点的信息就能被自动删除</p> 
<p><code>排序节点</code>就是节点路径后会由ZK附加一个自增的序列号，当大家都想创建同一个节点时，就能利用这个序号进行排序了，利用这种性质，能做成分布式锁。</p> 
<h2><a id="_62"></a>三、存储位置</h2> 
<p>因为ZK需要快速读取和处理各种状态信息，并且需要提供低延迟的响应，所以 ZK的数据是存储在内存中的。然而，虽然数据存储在内存中，ZK也会将数据持久化到硬盘上，以确保数据的持久性和可靠性，所以我们说ZK同时有<code>内存存储</code> 和 <code>硬盘存储</code></p> 
<h3><a id="1__65"></a>1. 内存存储</h3> 
<p>ZK的数据在内存中，其结构主要依赖两个类，一个是节点类 <code>DataNode</code>，一个是树结构类DataTree。</p> 
<h4><a id="1_DataTree_68"></a>1. DataTree</h4> 
<p><code>DataTree</code> 维护两个并行的数据结构:一个从完整路径映射到datanode的散列表和一个由datanode组成的树。所有对路径的访问都要通过哈希表。只有在序列化到磁盘时才遍历树</p> 
<p><img src="https://images2.imgbox.com/c4/d2/epFe2TUt_o.png" alt="在这里插入图片描述"><br> 这种双结构的存储方式，redis中也是一样的。这样会让我们在查询单个节点的时候，走的是 <em><strong>HashMap</strong></em>，时间复杂度为O(1)，所以非常快。</p> 
<h4><a id="2_DataNode_73"></a>2. DataNode</h4> 
<p>而所谓树状结构是怎么建立起来的呢？我们看一下 <code>DataNode</code> 的定义其实就清楚了，它其实是靠一个Set集合维护着子节点的。这样</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DataNode</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">/** the data for this datanode */</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">;</span>

    <span class="token comment">/**
     * 该节点的子节点列表。注意，子字符串列表不包含父路径——只包含路径的最后一部分。
     * 对于该集合的变动和查询都必须要使用 synchronized ，除了反序列化(为了加速问题)之外。
     */</span>
    <span class="token keyword">private</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> children <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>得益于这样节点内 <em><strong>synchronized</strong></em> 的设计，使得我们在某个节点下增、减、查子节点时，都要先获取同步锁。<strong>这是ZK能作为分布式锁给其他组件使用的重要基础</strong>。</p> 
<h3><a id="2__89"></a>2. 硬盘存储</h3> 
<p>除了内存用来存储数据外，ZK还具有硬盘存储的机制，这种落盘机制的作用是<strong>确保ZK的数据在服务器故障或重启后能够重新加载并保持一致性</strong>。</p> 
<h4><a id="1__91"></a>1. 事务日志</h4> 
<p>ZK的事务日志是指<strong>将每个写操作都记录在一个磁盘上的事务日志文件</strong>中。当客户端请求对ZK进行写操作时，ZK首先将该操作追加到日志文件中，然后向客户端返回成功响应。日志文件是顺序写入的，这样可以提高写入的效率。通过记录每个写操作，ZK可以保证它的数据是具有顺序一致性的。这份文件的主要格式，我们能在源码的 <code>FileTxnLog</code> 类中看到</p> 
<pre><code class="prism language-java"><span class="token class-name">FileTxnLog</span> 类实现了<span class="token class-name">TxnLog</span>接口。它提供api来访问txnlogs并向其中添加条目。

事务日志文件的格式如下由三部分构成<span class="token operator">:</span>
<span class="token comment">// 文件头     事务列表    文件末尾的填充0</span>
<span class="token class-name">FileHeader</span>    <span class="token class-name">TxnList</span>      <span class="token class-name">ZeroPad</span>

<span class="token comment">// 文件头构成：</span>
<span class="token class-name">FileHeader</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
magic <span class="token number">4</span>bytes <span class="token punctuation">(</span><span class="token constant">ZKLG</span><span class="token punctuation">)</span>
version <span class="token number">4</span>字节
dbid <span class="token number">8</span>个字节
<span class="token punctuation">}</span>

<span class="token comment">// 事务列表由一个或多个事务记录构成</span>
<span class="token class-name">TxnList</span><span class="token operator">:</span>
<span class="token class-name">Txn</span> <span class="token operator">||</span> <span class="token class-name">Txn</span> <span class="token class-name">TxnList</span>

<span class="token comment">// 事务记录构成:</span>
checksum <span class="token class-name">Txnlen</span> <span class="token class-name">TxnHeader</span> <span class="token class-name">Record</span> <span class="token number">0x42</span>

checksum<span class="token operator">:</span> <span class="token number">8</span>字节，使用的<span class="token class-name">Adler32</span>算法的校验和
<span class="token class-name">Txnlen</span><span class="token operator">:</span> <span class="token number">4</span>字节

<span class="token class-name">TxnHeader</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
sessionid <span class="token number">8</span>个字节
cxid <span class="token number">4</span>字节
zxid <span class="token number">8</span>个字节
time <span class="token number">8</span>个字节
type <span class="token number">4</span>个字节
<span class="token punctuation">}</span>
</code></pre> 
<p>关于事务这部分的详细情况，我们会在后面讲ZK集群的一致性时着重说明，现在我们只要知道ZK有事务日志功能即可</p> 
<h4><a id="2__128"></a>2. 快照</h4> 
<p>除了事务日志，ZK还使用快照来进行数据的持久化。快照是指ZK的内存数据结构在某个时刻的一份副本。ZK定期将内存中的数据转存到磁盘上，形成一个快照文件。快照文件是一个压缩文件，包含了ZK服务器的所有数据</p> 
<pre><code class="prism language-java"><span class="token comment">// SyncRequestProcessor.java</span>

代码步骤解释： 
<span class="token number">1.</span> 获取当前日志数量  logCount  和日志大小  logSize 。 
<span class="token number">2.</span> 判断条件：如果日志数量大于（快照计数设定值 snapCount  的一半加上随机数  randRoll ），
 或者如果快照大小（ snapSizeInBytes ）大于<span class="token number">0</span>且日志大小大于（快照大小设定值 的一半加上随机大小  randSize ）
<span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">shouldSnapshot</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> logCount <span class="token operator">=</span> zks<span class="token punctuation">.</span><span class="token function">getZKDatabase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTxnCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> logSize <span class="token operator">=</span> zks<span class="token punctuation">.</span><span class="token function">getZKDatabase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTxnSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>logCount <span class="token operator">&gt;</span> <span class="token punctuation">(</span>snapCount <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">+</span> randRoll<span class="token punctuation">)</span><span class="token punctuation">)</span>
               <span class="token operator">||</span> <span class="token punctuation">(</span>snapSizeInBytes <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> logSize <span class="token operator">&gt;</span> <span class="token punctuation">(</span>snapSizeInBytes <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">+</span> randSize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>通过事务日志的方式，ZK可以在发生故障时，通过回放日志文件来恢复数据。而通过快照文件，可以加快数据恢复的速度。因此，落盘机制是非常重要的，它保证了ZK的数据的持久性和可靠性。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/092400b8a5cf85d812fda1cd5a6f5803/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【MySQL调优】如何进行MySQL调优？从参数、数据建模、索引、SQL语句等方向，三万字详细解读MySQL的性能优化方案（2024版）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/86f30fc005791ae4a18a7f327bd60072/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">英伟达、Mistral AI 开源企业级大模型，120亿参数、可商用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>