<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】链表力扣刷题详解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/6ceff888049b3fe8e0aa99a0cc89cf36/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】链表力扣刷题详解">
  <meta property="og:description" content="前言 题目链接
移除链表元素
链表的中间结点
反转链表
分割链表
环形链表的约瑟夫问题
​
欢迎关注个人主页：逸狼
创造不易，可以点点赞吗~
如有错误，欢迎指出~
移除链表元素 题述
给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 ​
思路1：直接删除原链表中不符合的节点 遍历原链表，遇到val就执行删除操作
执行删除操作修改指针的指向有点麻烦，还有其他办法
​
思路2：满足要求的节点放在新链表上 定义新链表，利用pcur遍历原链表，找不为val的节点，尾插在新链表中
新链表：newHead newTail
要考虑链表是否为空
链表为空：插入进来的节点就是链表的头节点和尾节点
链表不为空，插入进来的节点就是链表的新的尾节点
​
代码实现思路2 /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ typedef struct ListNode ListNode; struct ListNode* removeElements(struct ListNode* head, int val) { //定义新链表的头尾指针 ListNode* newHead,* newTail; newHead=newTail=NULL; ListNode* pcur=head; while(pcur) { //不是val,尾插到新链表 if(pcur-&gt;val!">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-19T19:36:26+08:00">
    <meta property="article:modified_time" content="2024-03-19T19:36:26+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】链表力扣刷题详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p style="text-align:center;"></p> 
 <h2>前言</h2> 
 <p>题目链接</p> 
 <p><a class="link-info" href="https://leetcode.cn/problems/remove-linked-list-elements/description/" rel="nofollow" title="移除链表元素">移除链表元素</a></p> 
 <p><a class="link-info" href="https://leetcode.cn/problems/middle-of-the-linked-list/description/" rel="nofollow" title="链表的中间结点">链表的中间结点</a></p> 
 <p><a class="link-info" href="https://leetcode.cn/problems/reverse-linked-list/description/" rel="nofollow" title="反转链表">反转链表</a></p> 
 <p><a class="link-info" href="https://leetcode.cn/problems/partition-list-lcci/description/" rel="nofollow" title="分割链表">分割链表</a></p> 
 <p><a href="https://www.nowcoder.com/practice/41c399fdb6004b31a6cbb047c641ed8a" rel="nofollow" title="环形链表的约瑟夫问题">环形链表的约瑟夫问题</a></p> 
 <p><br>  </p> 
</blockquote> 
<p></p> 
<blockquote> 
 <p><img alt="" src="https://images2.imgbox.com/67/1d/Q9AlpvxL_o.jpg">​</p> 
 <p style="text-align:center;">欢迎关注个人主页：<a class="link-info" href="https://blog.csdn.net/2301_80898480" title="逸狼">逸狼</a></p> 
 <hr> 
 <p style="text-align:center;">创造不易，可以点点赞吗~</p> 
 <p style="text-align:center;">如有错误，欢迎指出~</p> 
</blockquote> 
<hr> 
<h2>移除链表元素</h2> 
<p>题述</p> 
<p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> </p> 
<p><img alt="" height="1009" src="https://images2.imgbox.com/e8/02/9zdQnFN9_o.png" width="1051">​</p> 
<h3>思路1：直接删除原链表中不符合的节点</h3> 
<p>遍历原链表，遇到val就执行删除操作<br> 执行删除操作修改指针的指向有点麻烦，还有其他办法</p> 
<p><img alt="" height="367" src="https://images2.imgbox.com/1a/c3/z1R0L68n_o.png" width="1130">​</p> 
<h3>思路2：满足要求的节点放在新链表上</h3> 
<p>定义新链表，利用pcur遍历原链表，找不为val的节点，尾插在新链表中<br> 新链表：newHead  newTail</p> 
<p>要考虑链表是否为空<br> 链表为空：插入进来的节点就是链表的头节点和尾节点<br> 链表不为空，插入进来的节点就是链表的新的尾节点</p> 
<p><img alt="" height="360" src="https://images2.imgbox.com/95/8a/9SaP9lNw_o.png" width="1080">​</p> 
<h3>代码实现思路2</h3> 
<div> 
 <pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
typedef struct ListNode ListNode;
struct ListNode* removeElements(struct ListNode* head, int val) {
    //定义新链表的头尾指针
    ListNode* newHead,* newTail;
    newHead=newTail=NULL;

    ListNode* pcur=head;
    while(pcur)
    {
        //不是val,尾插到新链表
        if(pcur-&gt;val!=val){
            //链表为空
            if(newHead==NULL)
            {
                newHead=newTail=pcur;
            }
            else{
                //链表不为空
                newTail-&gt;next=pcur;
                newTail=newTail-&gt;next;//
            }
        }
        //pcur继续往下走
        pcur=pcur-&gt;next;
    }
    if(newTail)//要先判断newTail本来是否为空
    {
        newTail-&gt;next=NULL;
    }
    return newHead;
}</code></pre> 
</div> 
<h2>链表的中间结点</h2> 
<p></p> 
<p>给你单链表的头结点 head ，请你找出并返回链表的中间结点。<br> 如果有两个中间结点，则返回第二个中间结点</p> 
<p><img alt="" height="945" src="https://images2.imgbox.com/4d/90/30uf0zZY_o.png" width="1155"></p> 
<h3>思路1：统计链表中节点的个数，通过除2找到中间节点</h3> 
<p>for(统计链表个数）<br>     for(根据除2结果走到中间节点)</p> 
<h3>思路2：快慢指针</h3> 
<p>slow指针每次走1步，fast走2步<br> 当fast-&gt;next或者fast走到为空，则slow刚好指向的就是中间节点<br>  </p> 
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

 typedef struct ListNode ListNode;
struct ListNode* middleNode(struct ListNode* head) {
    ListNode* fast,*slow;
    fast=slow=head;
    while(fast&amp;&amp;fast-&gt;next)//条件fast和fast-&gt;next不能相反，会造成短路
    {
        slow=slow-&gt;next;//slow走1步
        fast=fast-&gt;next-&gt;next;//fast走2步
    }
    return slow;
}</code></pre> 
<h2> 反转链表</h2> 
<p><br> 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p> 
<p><img alt="" height="975" src="https://images2.imgbox.com/cd/ca/dtEx7XQv_o.png" width="1034"></p> 
<h3>思路1</h3> 
<p>创建新链表，遍历原链表的节点将其插入到新链表中</p> 
<h3>思路2：创建3个指针</h3> 
<p>分别记录前驱节点，当前节点，后继节点，改变原链表的指向1</p> 
<p><img alt="" height="399" src="https://images2.imgbox.com/f9/07/3VS4siHY_o.png" width="1200"></p> 
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
 typedef struct ListNode ListNode;
struct ListNode* reverseList(struct ListNode* head) {
    //要先处理空链表
    if(head==NULL)
    {
        return head;
    }
    ListNode *n1,*n2,*n3;
    n1=NULL;
    n2=head;
    n3=head-&gt;next;

    while(n2)
    {
        //修改n2的指向
        n2-&gt;next=n1;
        //n1,n2,n3往下走
        n1=n2;
        n2=n3;
        if(n3)//要先判断n3不为空，才能往下走
        {
            n3=n3-&gt;next;
        }
    }
    return n1;
}</code></pre> 
<p></p> 
<h2>合并两个有序链表</h2> 
<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p> 
<p><img alt="" height="956" src="https://images2.imgbox.com/64/d9/s28hwSXH_o.png" width="902"></p> 
<h3>代码实现</h3> 
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

typedef struct ListNode ListNode;
struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {
    if (list1 == NULL)
        return list2;
    if (list2 == NULL)
        return list1;

    ListNode *l1, *l2;
    l1 = list1, l2 = list2;
    //创建头节点
    ListNode *newHead, *newTail;
    newHead = newTail = (ListNode*)malloc(sizeof(ListNode));

    while (l1 &amp;&amp; l2) {
        if (l1-&gt;val &lt; l2-&gt;val) {
            // l1小，l1上，但要先判断l1不为空指针
            // if (newHead == NULL)
            //     newHead = newTail = l1;
            // else {
            //     newTail-&gt;next = l1;
            //     newTail = newTail-&gt;next;
            // }
            // l1 = l1-&gt;next;

            //代码优化
            newTail-&gt;next=l1;
            newTail=newTail-&gt;next;
            l1=l1-&gt;next;
        } else {
            // l2小
            // if (newHead == NULL)
            //     newHead = newTail = l2;
            // else {
            //     newTail-&gt;next = l2;
            //     newTail = newTail-&gt;next;
            // }
            // l2 = l2-&gt;next;

             //代码优化
            newTail-&gt;next=l2;
            newTail=newTail-&gt;next;
            l2=l2-&gt;next;
        }
    }
    if (l1) {
        newTail-&gt;next = l1;
    }
    if (l2) {
        newTail-&gt;next = l2;
    }
    return newHead-&gt;next;
}</code></pre> 
<h2 style="background-color:transparent;">分割链表</h2> 
<p><br> 给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。<br> 你不需要 保留 每个分区中各节点的初始相对位置。</p> 
<p></p> 
<p><img alt="" height="1007" src="https://images2.imgbox.com/88/5c/BLMHdJ2b_o.png" width="1149"></p> 
<h3>思路</h3> 
<p>定义2个链表：大链表和小链表，遍历原链表的节点将其放到对应的新链表中，最将大小链表<strong>首尾相连</strong></p> 
<p>创建大小链表都要先创建一个哨兵位</p> 
<p>利用pcur遍历链表</p> 
<p><img alt="" height="762" src="https://images2.imgbox.com/34/c2/deN6CNIV_o.png" width="1200"></p> 
<h3 style="background-color:transparent;">代码实现</h3> 
<pre><code>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

typedef struct ListNode ListNode; 
struct ListNode* partition(struct ListNode* head, int x){
    if(head==NULL)
        return head;
    //创建带头的大小链表
    ListNode* lessHead ,*lessTail;
    ListNode* greaterHead,*greaterTail;
    lessHead=lessTail=(ListNode*)malloc(sizeof(ListNode));
    greaterHead=greaterTail=(ListNode*)malloc(sizeof(ListNode));

    //遍历原链表，将节点放在对应的新链表中
    ListNode*pcur=head;
    while(pcur)
    {
        if(pcur-&gt;val &lt; x)
        {
            //放在小链表中
            lessTail-&gt;next=pcur;
            lessTail=lessTail-&gt;next;
        }
        else
        {
            //放在大链表中
            greaterTail-&gt;next=pcur;
            greaterTail=greaterTail-&gt;next;
        }
    pcur=pcur-&gt;next;
    }
    //大链表尾要置为空
    greaterTail-&gt;next=NULL;

    //大小链表首尾相连
    lessTail-&gt;next=greaterHead-&gt;next;
    ListNode*ret=lessHead-&gt;next;
    free(greaterHead);
    free(lessHead);
    return ret;
}</code></pre> 
<h2 style="background-color:transparent;">环形链表的约瑟夫问题</h2> 
<p></p> 
<p>编号为 1 到 n 的 n 个人围成一圈。从编号为 1 的人开始报数，报到 m 的人离开。</p> 
<p>下一个人继续从 1 开始报数。</p> 
<p>n-1 轮结束以后，只剩下一个人，问最后留下的这个人编号是多少？、</p> 
<p><img alt="" height="866" src="https://images2.imgbox.com/01/74/ZEco94rY_o.png" width="1157"></p> 
<h3 style="background-color:transparent;">代码实现</h3> 
<pre><code> //这道OJ题已经创建好了结构体结点，只是没有展示出来
 typedef struct ListNode ListNode;
//申请新节点
ListNode* BuyNode(int x)
{
    ListNode* newNode=(ListNode*)malloc(sizeof(ListNode));
    //可写可不写，一般不会申请失败
    if(newNode==NULL)
    {
        exit(1);
    }
    newNode-&gt;val=x;
    newNode-&gt;next=NULL;
    return newNode;
}
//创建循环链表
ListNode*createList(int n)
{
    //创建头节点
    ListNode* phead=BuyNode(1);
    ListNode* ptail=phead;
    //从2开始，共创建了n个节点
    for(int i=2;i&lt;=n;i++)
    {
        ptail-&gt;next=BuyNode(i);
        ptail=ptail-&gt;next;
    }
    //链表要首尾相连，循环起来
    ptail-&gt;next=phead;
    return phead;
}
int ysf(int n, int m ) {
    //创建不带头单向循环链表
    //逢m删除节点
    ListNode*head=createList(n);
    ListNode*pcur=head;
    ListNode*prev=NULL;//用于记录pcur走过的位置,是pcur的前驱节点

    int count=1;
    //逢m删除节点
    while(pcur-&gt;next!=pcur)//表示删除节点到只剩下自己跳出循环
    {
        if(count==m)
        {
            //删除当前节点pcur
            prev-&gt;next=pcur-&gt;next;
            free(pcur);
            //删除pcur节点后，要让pcur走到新的位置，count置为初始值
            pcur=prev-&gt;next;
            count=1;
        }
        else 
        {
            //pcur往后走
            prev=pcur;
            pcur=pcur-&gt;next;
            count++;
        }
    }
    //此时pcur节点就是幸存下来的节点
    return pcur-&gt;val;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f2517a9affd05a50c7159d856be2370f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java 数据长度获取方式对比：length属性、length()和size()方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0b8360f7d2758f4935256a2e33b8a802/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">可视化工具 Another-Redis-Desktop-Manager 的安装与使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>