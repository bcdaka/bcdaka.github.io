<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】详细介绍线性表中的顺序表，带你复盘实现细节，附上顺序表编程练习题 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/6a06f94daea1e6ad0c5fbe1ecba9ca32/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】详细介绍线性表中的顺序表，带你复盘实现细节，附上顺序表编程练习题">
  <meta property="og:description" content="目录
一. 线性表
二. 顺序表 1. 静态顺序表与动态顺序表
2. 动态顺序表的接口实现 2.1 顺序表初始化 2.2 判断是否需要扩容 2.3 顺序表指定位置插入
2.4 顺序表头插
2.5 顺序表尾插
2.6 顺序表指定位置删除
2.7 顺序表头删
2.8 顺序表尾删
2.9 顺序表查找
2.10 顺序表修改 2.11 顺序表销毁
2.12 顺序表打印
3. 顺序表的缺点
4. 顺序表编程练习题 4.1 移除元素
4.2 删除有序数组中的重复项
4.3 合并两个有序数组
一. 线性表 1. 线性表(linear list)是n个具有相同特性的数据元素的有限序列。
2. 线性表是一种在实际中广泛使用的数据结构，常见的线性表：顺序表、链表、栈、队列、字符串...
3. 线性表在逻辑上是线性结构，也就说是连续的一条直线。但是在物理结构上并不一定是连续的，线性表在物理上存储时，通常以数组和链式结构的形式存储。
二. 顺序表 1. 静态顺序表与动态顺序表 1. 顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存储，在数组上完成数据的增删查改。
2. 顺序表一般可以分为：
静态顺序表：使用定长数组存储元素。
#define N 10 typedef int SLDataType; typedef struct SeqList { SLDataType array[N]; //定长数组 size_t size; //有效数据个数 }SeqList; 动态顺序表：使用动态开辟的数组存储。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-13T15:56:48+08:00">
    <meta property="article:modified_time" content="2024-08-13T15:56:48+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】详细介绍线性表中的顺序表，带你复盘实现细节，附上顺序表编程练习题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.%20%E7%BA%BF%E6%80%A7%E8%A1%A8-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%20%E7%BA%BF%E6%80%A7%E8%A1%A8" rel="nofollow">一. 线性表</a></p> 
<p id="%E4%BA%8C.%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%C2%A0" rel="nofollow">二. 顺序表 </a></p> 
<p id="1.%20%E9%9D%99%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8E%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8-toc" style="margin-left:40px;"><a href="#1.%20%E9%9D%99%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8E%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8" rel="nofollow">1. 静态顺序表与动态顺序表</a></p> 
<p id="2.%20%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%C2%A0-toc" style="margin-left:40px;"><a href="#2.%20%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%C2%A0" rel="nofollow">2. 动态顺序表的接口实现 </a></p> 
<p id="2.1%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%C2%A0-toc" style="margin-left:80px;"><a href="#2.1%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%C2%A0" rel="nofollow">2.1 顺序表初始化 </a></p> 
<p id="2.2%20%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E6%89%A9%E5%AE%B9%C2%A0%C2%A0-toc" style="margin-left:80px;"><a href="#2.2%20%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E6%89%A9%E5%AE%B9%C2%A0%C2%A0" rel="nofollow">2.2 判断是否需要扩容  </a></p> 
<p id="%C2%A02.3%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5-toc" style="margin-left:80px;"><a href="#%C2%A02.3%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5" rel="nofollow">2.3 顺序表指定位置插入</a></p> 
<p id="%C2%A02.4%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%A4%B4%E6%8F%92-toc" style="margin-left:80px;"><a href="#%C2%A02.4%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%A4%B4%E6%8F%92" rel="nofollow">2.4 顺序表头插</a></p> 
<p id="2.5%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%B0%BE%E6%8F%92-toc" style="margin-left:80px;"><a href="#2.5%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%B0%BE%E6%8F%92" rel="nofollow">2.5 顺序表尾插</a></p> 
<p id="%C2%A02.6%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E5%88%A0%E9%99%A4-toc" style="margin-left:80px;"><a href="#%C2%A02.6%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E5%88%A0%E9%99%A4" rel="nofollow">2.6 顺序表指定位置删除</a></p> 
<p id="%C2%A02.7%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%A4%B4%E5%88%A0-toc" style="margin-left:80px;"><a href="#%C2%A02.7%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%A4%B4%E5%88%A0" rel="nofollow">2.7 顺序表头删</a></p> 
<p id="%C2%A02.8%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%B0%BE%E5%88%A0-toc" style="margin-left:80px;"><a href="#%C2%A02.8%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%B0%BE%E5%88%A0" rel="nofollow">2.8 顺序表尾删</a></p> 
<p id="2.9%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE-toc" style="margin-left:80px;"><a href="#2.9%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE" rel="nofollow">2.9 顺序表查找</a></p> 
<p id="2.10%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%BF%AE%E6%94%B9%C2%A0-toc" style="margin-left:80px;"><a href="#2.10%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%BF%AE%E6%94%B9%C2%A0" rel="nofollow">2.10 顺序表修改 </a></p> 
<p id="2.11%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E9%94%80%E6%AF%81-toc" style="margin-left:80px;"><a href="#2.11%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E9%94%80%E6%AF%81" rel="nofollow">2.11 顺序表销毁</a></p> 
<p id="2.12%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%89%93%E5%8D%B0-toc" style="margin-left:80px;"><a href="#2.12%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%89%93%E5%8D%B0" rel="nofollow">2.12 顺序表打印</a></p> 
<p id="3.%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E7%BC%BA%E7%82%B9-toc" style="margin-left:40px;"><a href="#3.%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E7%BC%BA%E7%82%B9" rel="nofollow">3. 顺序表的缺点</a></p> 
<p id="4.%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0%E9%A2%98%C2%A0-toc" style="margin-left:40px;"><a href="#4.%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0%E9%A2%98%C2%A0" rel="nofollow">4. 顺序表编程练习题 </a></p> 
<p id="4.1%C2%A0%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-toc" style="margin-left:80px;"><a href="#4.1%C2%A0%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0" rel="nofollow">4.1 移除元素</a></p> 
<p id="4.2%C2%A0%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-toc" style="margin-left:80px;"><a href="#4.2%C2%A0%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9" rel="nofollow">4.2 删除有序数组中的重复项</a></p> 
<p id="4.3%C2%A0%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84-toc" style="margin-left:80px;"><a href="#4.3%C2%A0%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84" rel="nofollow">4.3 合并两个有序数组</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2>一. 线性表</h2> 
<blockquote> 
 <p>1. 线性表(linear list)是n个具有相同特性的数据元素的有限序列。</p> 
 <p>2. 线性表是一种在实际中广泛使用的数据结构，常见的线性表：顺序表、链表、栈、队列、字符串...</p> 
 <p>3. 线性表在逻辑上是线性结构，也就说是连续的一条直线。但是在物理结构上并不一定是连续的，线性表在物理上存储时，通常以数组和链式结构的形式存储。</p> 
 <p><img alt="" height="305" src="https://images2.imgbox.com/93/95/Tn2kmv2e_o.png" width="808"></p> 
</blockquote> 
<p></p> 
<h2 id="%E4%BA%8C.%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%C2%A0">二. 顺序表 </h2> 
<h3 id="1.%20%E9%9D%99%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8E%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8">1. 静态顺序表与动态顺序表</h3> 
<blockquote> 
 <p>1. 顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存储，在数组上完成数据的增删查改。</p> 
 <p>2. 顺序表一般可以分为：</p> 
 <p>静态顺序表：使用定长数组存储元素。</p> 
 <pre><code class="language-cpp">#define N 10
typedef int SLDataType;
typedef struct SeqList
{
	SLDataType array[N]; //定长数组
	size_t size;         //有效数据个数
}SeqList;</code></pre> 
 <p>动态顺序表：使用动态开辟的数组存储。</p> 
 <pre><code class="language-cpp">typedef int SLDataType;
typedef struct SeqList
{
	SLDataType* array; //指向动态开辟的数组
	size_t size;       //有效数据个数
	size_t capacity;   //空间容量
}SeqList;</code></pre> 
</blockquote> 
<h3 id="2.%20%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%C2%A0">2. 动态顺序表的接口实现 </h3> 
<blockquote> 
 <p>1. 静态顺序表只适用于确定知道需要存多少数据的场景。</p> 
 <p>2. 静态顺序表的定长数组导致N定大了，空间开多了浪费，开少了不够用。</p> 
 <p>3. 所以现实中基本都是使用动态顺序表，根据需要动态的分配空间大小，所以下面我们实现动态顺序表。</p> 
</blockquote> 
<h4 id="2.1%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%C2%A0">2.1 顺序表初始化 </h4> 
<blockquote> 
 <p>1. 将结构的每个成员进行初始化</p> 
 <pre><code class="language-cpp">void SeqListInit(SeqList* psl, size_t capacity)
{
	assert(psl);

	psl-&gt;array = (SLDataType*)malloc(sizeof(SeqList) * capacity);
	if (psl-&gt;array == NULL)
	{
		perror("malloc");
		return;
	}
	psl-&gt;size = 0;
	psl-&gt;capacity = capacity;
}</code></pre> 
</blockquote> 
<h4 id="2.2%20%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E6%89%A9%E5%AE%B9%C2%A0%C2%A0">2.2 判断是否需要扩容  </h4> 
<blockquote> 
 <p>1. 判断有效个数是否和容量相等。</p> 
 <p>2. 使用realloc增容。</p> 
 <pre><code class="language-cpp">void CheckCapacity(SeqList* psl)
{
	assert(psl);

	if (psl-&gt;size == psl-&gt;capacity)
	{
		SLDataType* tmp = (SLDataType*)realloc(psl-&gt;array, sizeof(SLDataType) * psl-&gt;capacity * 2);
		if (tmp == NULL)
		{
			perror(realloc);
			return;
		}
		psl-&gt;array = tmp;
		psl-&gt;capacity *= 2;
	}
}</code></pre> 
</blockquote> 
<h4 id="%C2%A02.3%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5">2.3 顺序表指定位置插入</h4> 
<blockquote> 
 <p>1. 对pos进行范围判断。</p> 
 <p>1. 判断是否需要扩容。</p> 
 <p>2. 将pos后面的元素往后挪一位。</p> 
 <p>3. pos位置插入值。</p> 
 <p>4. 有效个数加一。</p> 
 <pre><code class="language-cpp">void SeqListInsert(SeqList* psl, size_t pos, SLDataType x)
{
	assert(psl);
	assert(pos &gt;= 0 &amp;&amp; pos &lt;= psl-&gt;size);

	CheckCapacity(psl);

	size_t cur = psl-&gt;size;
	while (cur != pos)
	{
		psl-&gt;array[cur] = psl-&gt;array[cur - 1];
		cur--;
	}

	psl-&gt;array[pos] = x;
	psl-&gt;size++;
}</code></pre> 
</blockquote> 
<h4 id="%C2%A02.4%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%A4%B4%E6%8F%92">2.4 顺序表头插</h4> 
<blockquote> 
 <p>1. 判断是否需要扩容。</p> 
 <p>2. 将所有元素都往后移一位，留出第一个位置插入(如果头插之前没有元素，则直接插入即可)。</p> 
 <p>3. 有效个数加一。</p> 
 <pre><code class="language-cpp">void SeqListPushFront(SeqList* psl, SLDataType x)
{
	assert(psl);

	CheckCapacity(psl);

	int tmp = psl-&gt;size;
	while (tmp &gt; 0) //当本身为空时，就不走这个循环
	{
		psl-&gt;array[tmp] = psl-&gt;array[tmp - 1];
		tmp--;
	}

	psl-&gt;array[0] = x;
	psl-&gt;size++;
}</code></pre> 
 <p>方法2：复用SeqListInsert</p> 
 <pre><code class="language-cpp">void SeqListPushFront(SeqList* psl, SLDataType x)
{
	SeqListInsert(psl, 0, x);
}</code></pre> 
</blockquote> 
<h4 id="2.5%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%B0%BE%E6%8F%92">2.5 顺序表尾插</h4> 
<blockquote> 
 <p>1. 插入前判断是否需要增容。</p> 
 <p>2. size作为下标正好是最后一个元素的后一位。</p> 
 <pre><code class="language-cpp">void SeqListPushBack(SeqList* psl, SLDataType x)
{
	assert(psl);

	CheckCapacity(psl);
	psl-&gt;array[psl-&gt;size++] = x;
}</code></pre> 
 <p>方法2：复用SeqListInsert</p> 
 <pre><code class="language-cpp">void SeqListPushBack(SeqList* psl, SLDataType x)
{
	assert(psl);

	SeqListInsert(psl, psl-&gt;size, x);
}</code></pre> 
</blockquote> 
<h4 id="%C2%A02.6%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E5%88%A0%E9%99%A4">2.6 顺序表指定位置删除</h4> 
<blockquote> 
 <p>1. 判断pos是否合法。</p> 
 <p>2. 将pos后面的元素往前覆盖一位。</p> 
 <p>3. 有效个数减一。</p> 
 <pre><code class="language-cpp">void SeqListErase(SeqList* psl, size_t pos)
{
	assert(psl);
	assert(pos &gt;= 0 &amp;&amp; pos &lt; psl-&gt;size);

	int cur = pos;
	while (cur &lt; psl-&gt;size - 1)
	{
		psl-&gt;array[cur] = psl-&gt;array[cur + 1];
		cur++;
	}
	
	psl-&gt;size--;
}</code></pre> 
</blockquote> 
<h4 id="%C2%A02.7%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%A4%B4%E5%88%A0">2.7 顺序表头删</h4> 
<blockquote> 
 <p>1. 判断有效个数是否为0，为0不用删。</p> 
 <p>2. 将后面的与元素往前覆盖一位。</p> 
 <p>3. 有效元素个数减一。</p> 
 <pre><code class="language-cpp">void SeqListPopFront(SeqList* psl)
{
	assert(psl);
	assert(psl-&gt;size);

	size_t cur = 0;
	while (cur &lt; psl-&gt;size - 1)
	{
		psl-&gt;array[cur] = psl-&gt;array[cur + 1];
		cur++;
	}

	psl-&gt;size--;
}</code></pre> 
 <p>方法2：复用SeqListErase</p> 
 <pre><code class="language-cpp">void SeqListPopFront(SeqList* psl)
{
	assert(psl);

	SeqListErase(psl, 0);
}</code></pre> 
</blockquote> 
<h4 id="%C2%A02.8%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%B0%BE%E5%88%A0">2.8 顺序表尾删</h4> 
<blockquote> 
 <p>1. 判断size，size如果为0就不能删。</p> 
 <p>2. 删除尾部元素直接将size减减即可。</p> 
 <pre><code class="language-cpp">void SeqListPopBack(SeqList* psl)
{
	assert(psl);
	assert(psl-&gt;size);

	psl-&gt;size--;
}</code></pre> 
 <p>方法2：复用SeqListErase</p> 
 <pre><code class="language-cpp">void SeqListPopBack(SeqList* psl)
{
	assert(psl);

	SeqListErase(psl, psl-&gt;size - 1);
}</code></pre> 
</blockquote> 
<h4 id="2.9%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE">2.9 顺序表查找</h4> 
<blockquote> 
 <p>1. 遍历一遍进行比较。</p> 
 <p>2. 找到返回下标，否则返回-1。</p> 
 <pre><code class="language-cpp">int SeqListFind(SeqList* psl, SLDataType x)
{
	assert(psl);

	for (size_t i = 0; i &lt; psl-&gt;size; i++)
	{
		if (psl-&gt;array[i] == x) return i;
	}

	return -1;
}</code></pre> 
</blockquote> 
<h4 id="2.10%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%BF%AE%E6%94%B9%C2%A0">2.10 顺序表修改 </h4> 
<blockquote> 
 <p>1. 对pos进行范围判断。</p> 
 <p>2. 将pos作为下标进行修改。</p> 
 <pre><code class="language-cpp">void SeqListModify(SeqList* psl, size_t pos, SLDataType x)
{
	assert(psl);
	assert(pos &gt;= 0 &amp;&amp; pos &lt; psl-&gt;size);

	psl-&gt;array[pos] = x;
}</code></pre> 
</blockquote> 
<h4 id="2.11%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E9%94%80%E6%AF%81">2.11 顺序表销毁</h4> 
<blockquote> 
 <p>1. 销毁时需要释放空间，指针置空。</p> 
 <p>2. 有效个数和容量置0。</p> 
 <pre><code class="language-cpp">void SeqListDestory(SeqList* psl)
{
	assert(psl);

	free(psl-&gt;array);
	psl-&gt;array = NULL;
	psl-&gt;capacity = 0;
	psl-&gt;size = 0;
}</code></pre> 
</blockquote> 
<h4 id="2.12%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%89%93%E5%8D%B0">2.12 顺序表打印</h4> 
<blockquote> 
 <p>1. 遍历数组打印</p> 
 <pre><code class="language-cpp">void SeqListPrint(SeqList* psl)
{
    assert(psl);

	for (int i = 0; i &lt; psl-&gt;size; i++) printf("%d ", psl-&gt;array[i]);
    printf("\n");
}</code></pre> 
</blockquote> 
<p>完整代码 </p> 
<p><a href="https://gitee.com/lin-yuheng123/data-structure/tree/master/SeqList/SeqList" rel="nofollow" title="SeqList/SeqList · 林宇恒/DataStructure - 码云 - 开源中国 (gitee.com)">SeqList/SeqList · 林宇恒/DataStructure - 码云 - 开源中国 (gitee.com)</a></p> 
<h3 id="3.%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E7%BC%BA%E7%82%B9">3. 顺序表的缺点</h3> 
<blockquote> 
 <p>1. 中间/头部的插入删除，时间复杂度为O(N)。</p> 
 <p>2. 增容需要申请新空间，拷贝数据，释放旧空间，会有不小的消耗。</p> 
 <p>3. 增容一般是呈2倍的增长，势必会有一定的空间浪费。例如当前容量为100，满了以后增容到200，我们再继续插入了5个数据，后面没有数据插入了，那么就浪费了95个数据空间。</p> 
</blockquote> 
<h3 id="4.%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0%E9%A2%98%C2%A0">4. 顺序表编程练习题 </h3> 
<h4 id="4.1%C2%A0%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0">4.1 移除元素</h4> 
<blockquote> 
 <p>链接：<a href="https://leetcode.cn/problems/remove-element/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
 <p><img alt="" height="282" src="https://images2.imgbox.com/b9/c9/oPoa2tI0_o.png" width="622"></p> 
 <p>思路： </p> 
 <p>1. src遍历判断，等于val就什么也不做，不等于val就把当前值给dst。</p> 
 <p>2. 等待src给我值，然后加加。</p> 
 <p><img alt="" height="646" src="https://images2.imgbox.com/49/eb/25SSx3qu_o.png" width="525"></p> 
 <pre><code class="language-cpp">int removeElement(int* nums, int numsSize, int val)
{
    int dst = 0;
    for(int src=0; src&lt;numsSize; src++)
    {
        if(nums[src] != val) nums[dst++] = nums[src];
    }

    return dst;        
}</code></pre> 
</blockquote> 
<h4 id="4.2%C2%A0%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9">4.2 <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/" rel="nofollow" title="删除有序数组中的重复项">删除有序数组中的重复项</a></h4> 
<blockquote> 
 <p>链接：<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
 <p><img alt="" height="311" src="https://images2.imgbox.com/f1/7e/pWGnR6gA_o.png" width="622"></p> 
 <p>思路：利用双指针进行比较。</p> 
 <p><img alt="" height="330" src="https://images2.imgbox.com/5a/bf/cUO4AETR_o.png" width="707"></p> 
 <pre><code class="language-cpp">int removeDuplicates(int* nums, int numsSize) 
{
    int dst = 0;
    for(int src=1; src&lt;numsSize; src++)
    {
        if(nums[dst] != nums[src]) nums[++dst] = nums[src];
    }

    return dst+1;
}</code></pre> 
</blockquote> 
<h4 id="4.3%C2%A0%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84">4.3 <a href="https://leetcode.cn/problems/merge-sorted-array/" rel="nofollow" title="合并两个有序数组">合并两个有序数组</a></h4> 
<blockquote> 
 <p>链接：<a href="https://leetcode.cn/problems/merge-sorted-array/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
 <p><img alt="" height="651" src="https://images2.imgbox.com/40/27/VnD0CepU_o.png" width="629"></p> 
 <p>思路：</p> 
 <p>1. 从后面开始比较，谁大谁放在后面。</p> 
 <p>2. 注意结束条件，这里以tail为标准。</p> 
 <pre><code class="language-cpp">void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n) 
{
    int src1 = m-1;
    int src2 = n-1;
    int tail = nums1Size-1;
    while(tail&gt;=0)
    {
        if(src2&lt;0) break;
        if(src1&lt;0) nums1[tail] = nums2[src2--];
        else if(nums2[src2] &gt;= nums1[src1]) nums1[tail] = nums2[src2--];
        else if(nums2[src2] &lt; nums1[src1]) nums1[tail] = nums1[src1--];
        tail--;
    }
}</code></pre> 
</blockquote> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bf21ebcc2a6fd578b349ae30ebf64e49/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2024最新版Node.js下载安装及环境配置教程（手把手教你）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b7922e0c0df1c0b00b011cc98b14483e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2024年8月13日（lvs NAT脚本 RS脚本 ds脚本）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>