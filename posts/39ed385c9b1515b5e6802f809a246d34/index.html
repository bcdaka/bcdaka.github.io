<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构【没头单链表】 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/39ed385c9b1515b5e6802f809a246d34/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构【没头单链表】">
  <meta property="og:description" content="目录
​
概念与结构
结点
链表的性质
链表的打印分析
实现单链表：
创建单链表数据
申请空间
尾插数据
打印
头插数据
尾删
头删
查询数据
指定位置前插入数据
指定位置后插入数据
删除pos节点
删除pos后面的节点
销毁
链表的分类
链表说明：
概念与结构 概念：链表是⼀种物理存储结构上⾮连续、⾮顺序的存储结构，数据元素的逻辑顺序是通过链表中的 指针链接次序实现的。
这个单链表我们需要一个整行或其他类型的存放数据，还有一个结构体指针，结构体指针连接下一个节点。
结点 与顺序表不同的是，链表⾥的每节&#34;⻋厢&#34;都是独⽴申请下来的空间，我们称之为“结点/结点” 结点的组成主要有两个部分：当前结点要保存的数据和保存下⼀个结点的地址（指针变量）。
图中指针变量plist保存的是第⼀个结点的地址，我们称plist此时“指向”第⼀个结点，如果我们希望 plist“指向”第⼆个结点时，只需要修改plist保存的内容为0x0012FFA0。 链表中每个结点都是独⽴申请的（即需要插⼊数据时才去申请⼀块结点的空间），我们需要通过指针 变量来保存下⼀个结点位置才能从当前结点找到下⼀个结点。
链表的性质 1、链式机构在逻辑上是连续的，在物理结构上不⼀定连续
2、结点⼀般是从堆上申请的
3、从堆上申请来的空间，是按照⼀定策略分配出来的，每次申请的空间可能连续，可能不连续
结合前⾯学到的结构体知识，我们可以给出每个结点对应的结构体代码：
假设当前保存的结点为整型：
struct SListNode { int data; //节点数据 struct SListNode* next; //指针变量⽤保存下⼀个节点的地址 }; 当我们想要保存⼀个整型数据时，实际是向操作系统申请了⼀块内存，这个内存不仅要保存整型数 据，也需要保存下⼀个节点的地址（当下⼀个节点为空时保存的地址为空）。 当我们想要从第⼀个节点⾛到最后⼀个节点时，只需要在当前节点拿上下⼀个结点的地址就可以了。
链表的打印分析 给定的链表结构中，如何实现结点从头到尾的打印？
思考：当我们想保存的数据类型为字符型、浮点型或者其他⾃定义的类型时，该如何修改？
实现单链表： 创建3个文件，slist.h头文件，slist.c存放函数的文件，test.c测试文件
创建单链表数据 arr用来存放数据，p指向下一个节点
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;assert.h&gt; typedef int data; typedef struct slist { //存放数据 data* arr; //指向下一个节点 struct slist* p; }SL; 在测试文件创建链表为NULL">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-22T21:36:15+08:00">
    <meta property="article:modified_time" content="2024-07-22T21:36:15+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构【没头单链表】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 id="%E2%80%8B%E7%BC%96%E8%BE%91" style="text-align:center;"><img alt="" height="460" src="https://images2.imgbox.com/31/98/9B3R9fbz_o.gif" width="817"></h4> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:80px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91" rel="nofollow">​</a></p> 
<p id="-toc" style="margin-left:80px;"></p> 
<p id="%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%BB%93%E6%9E%84" rel="nofollow">概念与结构</a></p> 
<p id="%E7%BB%93%E7%82%B9-toc" style="margin-left:120px;"><a href="#%E7%BB%93%E7%82%B9" rel="nofollow">结点</a></p> 
<p id="%E9%93%BE%E8%A1%A8%E7%9A%84%E6%80%A7%E8%B4%A8-toc" style="margin-left:80px;"><a href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E6%80%A7%E8%B4%A8" rel="nofollow">链表的性质</a></p> 
<p id="%E9%93%BE%E8%A1%A8%E7%9A%84%E6%89%93%E5%8D%B0%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E6%89%93%E5%8D%B0%E5%88%86%E6%9E%90" rel="nofollow">链表的打印分析</a></p> 
<p id="%E5%AE%9E%E7%8E%B0%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%AE%9E%E7%8E%B0%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%9A" rel="nofollow">实现单链表：</a></p> 
<p id="%E5%88%9B%E5%BB%BA%E5%8D%95%E9%93%BE%E8%A1%A8%E6%95%B0%E6%8D%AE-toc" style="margin-left:120px;"><a href="#%E5%88%9B%E5%BB%BA%E5%8D%95%E9%93%BE%E8%A1%A8%E6%95%B0%E6%8D%AE" rel="nofollow">创建单链表数据</a></p> 
<p id="%E7%94%B3%E8%AF%B7%E7%A9%BA%E9%97%B4-toc" style="margin-left:120px;"><a href="#%E7%94%B3%E8%AF%B7%E7%A9%BA%E9%97%B4" rel="nofollow">申请空间</a></p> 
<p id="%E5%B0%BE%E6%8F%92%E6%95%B0%E6%8D%AE-toc" style="margin-left:120px;"><a href="#%E5%B0%BE%E6%8F%92%E6%95%B0%E6%8D%AE" rel="nofollow">尾插数据</a></p> 
<p id="%E6%89%93%E5%8D%B0-toc" style="margin-left:120px;"><a href="#%E6%89%93%E5%8D%B0" rel="nofollow">打印</a></p> 
<p id="%E5%A4%B4%E6%8F%92%E6%95%B0%E6%8D%AE-toc" style="margin-left:120px;"><a href="#%E5%A4%B4%E6%8F%92%E6%95%B0%E6%8D%AE" rel="nofollow">头插数据</a></p> 
<p id="%E5%B0%BE%E5%88%A0-toc" style="margin-left:120px;"><a href="#%E5%B0%BE%E5%88%A0" rel="nofollow">尾删</a></p> 
<p id="%E5%A4%B4%E5%88%A0-toc" style="margin-left:120px;"><a href="#%E5%A4%B4%E5%88%A0" rel="nofollow">头删</a></p> 
<p id="%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE-toc" style="margin-left:120px;"><a href="#%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE" rel="nofollow">查询数据</a></p> 
<p id="%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E5%89%8D%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE-toc" style="margin-left:120px;"><a href="#%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E5%89%8D%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE" rel="nofollow">指定位置前插入数据</a></p> 
<p id="%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E5%90%8E%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE-toc" style="margin-left:120px;"><a href="#%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E5%90%8E%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE" rel="nofollow">指定位置后插入数据</a></p> 
<p id="%E5%88%A0%E9%99%A4pos%E8%8A%82%E7%82%B9-toc" style="margin-left:120px;"><a href="#%E5%88%A0%E9%99%A4pos%E8%8A%82%E7%82%B9" rel="nofollow">删除pos节点</a></p> 
<p id="%E5%88%A0%E9%99%A4pos%E5%90%8E%E9%9D%A2%E7%9A%84%E8%8A%82%E7%82%B9-toc" style="margin-left:120px;"><a href="#%E5%88%A0%E9%99%A4pos%E5%90%8E%E9%9D%A2%E7%9A%84%E8%8A%82%E7%82%B9" rel="nofollow">删除pos后面的节点</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:120px;"></p> 
<p id="%E9%94%80%E6%AF%81-toc" style="margin-left:120px;"><a href="#%E9%94%80%E6%AF%81" rel="nofollow">销毁</a></p> 
<p id="%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB-toc" style="margin-left:80px;"><a href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB" rel="nofollow">链表的分类</a></p> 
<p id="%E9%93%BE%E8%A1%A8%E8%AF%B4%E6%98%8E%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%E9%93%BE%E8%A1%A8%E8%AF%B4%E6%98%8E%EF%BC%9A" rel="nofollow">链表说明：</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h4 id="%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%BB%93%E6%9E%84">概念与结构</h4> 
<p>概念：链表是⼀种物理存储结构上⾮连续、⾮顺序的存储结构，数据元素的逻辑顺序是通过链表中的 指针链接次序实现的。</p> 
<p><img alt="" height="227" src="https://images2.imgbox.com/0b/d8/zRFXFLn2_o.png" width="1200"></p> 
<p><strong> 这个单链表我们需要一个整行或其他类型的存放数据，还有一个结构体指针，结构体指针连接下一个节点。</strong></p> 
<h5 id="%E7%BB%93%E7%82%B9">结点</h5> 
<p>与顺序表不同的是，链表⾥的每节"⻋厢"都是独⽴申请下来的空间，我们称之为“结点/结点” </p> 
<blockquote> 
 <p>结点的组成主要有两个部分：当前结点要保存的数据和保存下⼀个结点的地址（指针变量）。</p> 
</blockquote> 
<p>图中指针变量plist保存的是第⼀个结点的地址，我们称plist此时“指向”第⼀个结点，如果我们希望 plist“指向”第⼆个结点时，只需要修改plist保存的内容为0x0012FFA0。 链表中每个结点都是独⽴申请的（即需要插⼊数据时才去申请⼀块结点的空间），我们需要通过指针 变量来保存下⼀个结点位置才能从当前结点找到下⼀个结点。</p> 
<h4 id="%E9%93%BE%E8%A1%A8%E7%9A%84%E6%80%A7%E8%B4%A8">链表的性质</h4> 
<blockquote> 
 <p>1、链式机构在逻辑上是连续的，在物理结构上不⼀定连续</p> 
 <p>2、结点⼀般是从堆上申请的</p> 
 <p> 3、从堆上申请来的空间，是按照⼀定策略分配出来的，每次申请的空间可能连续，可能不连续</p> 
</blockquote> 
<p>结合前⾯学到的结构体知识，我们可以给出每个结点对应的结构体代码：</p> 
<p>假设当前保存的结点为整型：</p> 
<pre><code class="language-cpp">struct SListNode
{
 int data; //节点数据
 struct SListNode* next; //指针变量⽤保存下⼀个节点的地址
};
</code></pre> 
<p>当我们想要保存⼀个整型数据时，实际是向操作系统申请了⼀块内存，这个内存不仅要保存整型数 据，也需要保存下⼀个节点的地址（当下⼀个节点为空时保存的地址为空）。 当我们想要从第⼀个节点⾛到最后⼀个节点时，只需要在当前节点拿上下⼀个结点的地址就可以了。</p> 
<h4 id="%E9%93%BE%E8%A1%A8%E7%9A%84%E6%89%93%E5%8D%B0%E5%88%86%E6%9E%90">链表的打印分析</h4> 
<p>给定的链表结构中，如何实现结点从头到尾的打印？</p> 
<p><img alt="" height="1080" src="https://images2.imgbox.com/03/be/dTwnKWp1_o.png" width="1200"></p> 
<p>思考：当我们想保存的数据类型为字符型、浮点型或者其他⾃定义的类型时，该如何修改？</p> 
<h4 id="%E5%AE%9E%E7%8E%B0%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%9A">实现单链表：</h4> 
<p>创建3个文件，slist.h头文件，slist.c存放函数的文件，test.c测试文件</p> 
<p><img alt="" height="167" src="https://images2.imgbox.com/d0/9c/w8tRwFox_o.png" width="215"></p> 
<hr> 
<h5 id="%E5%88%9B%E5%BB%BA%E5%8D%95%E9%93%BE%E8%A1%A8%E6%95%B0%E6%8D%AE">创建单链表数据</h5> 
<p>arr用来存放数据，p指向下一个节点</p> 
<p><img alt="" height="374" src="https://images2.imgbox.com/fd/3f/ROSJ63X8_o.png" width="590"></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
typedef int data;
typedef struct slist
{
	//存放数据
	data* arr;
	//指向下一个节点
	struct slist* p;
}SL;</code></pre> 
<hr> 
<p>在测试文件创建链表为NULL</p> 
<p><img alt="" height="199" src="https://images2.imgbox.com/ae/26/BcWWlkoQ_o.png" width="472"></p> 
<hr> 
<h5 id="%E7%94%B3%E8%AF%B7%E7%A9%BA%E9%97%B4">申请空间</h5> 
<p>接收的是数值，返回的是空间，把arr赋值x，p给空返回add</p> 
<p><img alt="" height="399" src="https://images2.imgbox.com/65/f2/hdRhhuAf_o.png" width="416"></p> 
<pre><code class="language-cpp">//申请空间
SL* koj(data x)
{
	//申请空间
	SL* add = (SL*)malloc(sizeof(SL));
	//判断是不是空
	if (add == NULL)
	{
		perror("malloc");
		exit(1);
	}
	//把数据赋值给add
	add-&gt;arr = x;
	add-&gt;p = NULL;
	//然后返回
	return add;
}</code></pre> 
<hr> 
<h5 id="%E5%B0%BE%E6%8F%92%E6%95%B0%E6%8D%AE">尾插数据</h5> 
<p>头文件</p> 
<p>使用二级指针接收，直接修改实参。用一级的话还要赋值。</p> 
<p><span style="color:#fe2c24;">声明尾插的函数，为什么要声明，因为如果我们有很多个函数的话要一个一个找很麻烦，所以声明在头文件，就像我们看书的目录一样方便我们查看有哪些函数。</span></p> 
<p><img alt="" height="479" src="https://images2.imgbox.com/4f/88/asz55XVk_o.png" width="421"></p> 
<pre><code class="language-cpp">//尾插
void weic(SL** r, data x);</code></pre> 
<p><img alt="" height="196" src="https://images2.imgbox.com/28/28/bNX5zwLA_o.png" width="1053"></p> 
<hr> 
<p>add接收的新申请的空间</p> 
<p>思路：<span style="color:#fe2c24;">先判断当前r是不是空，是就直接把申请的空间给过去就行了</span></p> 
<p><span style="color:#fe2c24;">有空间，把地址给tab循环走到最后一个节点，然后让最后一个节点的指针指向add空间</span></p> 
<p><img alt="" height="599" src="https://images2.imgbox.com/ea/d8/VizWgBLG_o.png" width="595"></p> 
<pre><code class="language-cpp">//尾插
void weic(SL** r, data x)
{
	assert(r);
	//申请空间
	SL* add = koj(x);
	//判断单链表是不是空
	if (*r == NULL)
	{
		//是空就直接赋值
		*r = add;
	}
	//不是空就循环走到tab-&gt;p 的null位置，进行连接
	else
	{
		//把r地址给tab
		SL* tab = *r;
		while (tab-&gt;p)
		{
			//循环走到tab-&gt;p 的null位置，进行连接
			tab = tab-&gt;p;
		}
		//把申请的空间和tab-&gt;p连接
		tab-&gt;p = add;
	}
}</code></pre> 
<hr> 
<h5 id="%E6%89%93%E5%8D%B0">打印</h5> 
<p>打印用一级就行了，我们只是打印数据。</p> 
<p><img alt="" height="475" src="https://images2.imgbox.com/65/0e/JmpGDTRr_o.png" width="626"></p> 
<pre><code class="language-cpp">//打印
void day(SL* r);</code></pre> 
<hr> 
<p>打印</p> 
<p>循环往后打印，最后一个打印NULL</p> 
<p><img alt="" height="268" src="https://images2.imgbox.com/6a/c9/mJkZLceP_o.png" width="414"></p> 
<pre><code class="language-cpp">//打印
void day(SL* r)
{
	SL* add = r;
	while (add)
	{
		printf("%d-&gt;", add-&gt;arr);
		add = add-&gt;p;
	}
	printf("NULL\n");
}</code></pre> 
<hr> 
<p><img alt="" height="369" src="https://images2.imgbox.com/0c/a9/KovFb6Bz_o.png" width="489"></p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/5b/1c/mqZFwP97_o.png" width="661"></p> 
<pre><code class="language-cpp">    SL* add = NULL;
	//尾插
	weic(&amp;add, 1);
	weic(&amp;add, 2);
	weic(&amp;add, 3);
	weic(&amp;add, 4);</code></pre> 
<hr> 
<h5 id="%E5%A4%B4%E6%8F%92%E6%95%B0%E6%8D%AE">头插数据</h5> 
<p><img alt="" height="193" src="https://images2.imgbox.com/03/91/RSvmF7V3_o.png" width="412"></p> 
<pre><code class="language-cpp">//头插
void toc(SL** r, data x);</code></pre> 
<p><img alt="" height="253" src="https://images2.imgbox.com/3c/54/lZnJGKHS_o.png" width="1030"></p> 
<hr> 
<p><span style="color:#fe2c24;">思路：申请add空间，add的指针指向头节点*r，把add给*r这样新申请的空间就是头节点了。</span></p> 
<p><img alt="" height="284" src="https://images2.imgbox.com/e6/b4/kY0lnPPy_o.png" width="496"></p> 
<pre><code class="language-cpp">//头插
void toc(SL** r, data x)
{
	assert(r);
	//申请空间
	SL* add = koj(x);
	//把申请空间的add-&gt;p指向r的当前地址
	add-&gt;p = *r;
	//把add的地址给r
	*r = add;
}</code></pre> 
<p><img alt="" height="448" src="https://images2.imgbox.com/ad/63/ib7ox4ko_o.png" width="717"></p> 
<pre><code class="language-cpp">    SL* add = NULL;
	//头插
	toc(&amp;add, 1);
	toc(&amp;add, 2);
	toc(&amp;add, 3);
	toc(&amp;add, 4);
</code></pre> 
<hr> 
<h5 id="%E5%B0%BE%E5%88%A0">尾删</h5> 
<p><img alt="" height="205" src="https://images2.imgbox.com/87/ed/fQU2OBSJ_o.png" width="332"></p> 
<pre><code class="language-cpp">//尾删除
void weisc(SL** r);</code></pre> 
<p><img alt="" height="341" src="https://images2.imgbox.com/85/11/D3oUHucB_o.png" width="909"></p> 
<hr> 
<p></p> 
<p>思路：<span style="color:#fe2c24;">判断当前节点的下一个节点是不是空，是就说明只有一个节点，直接释放。</span></p> 
<p><span style="color:#fe2c24;">循环往后走到最后一个节点，每走一步前保存到tab，就能拿到前一个节点了。</span></p> 
<p><span style="color:#fe2c24;">把tab-&gt;p赋值为空，释放add空间就可以了。</span></p> 
<p><img alt="" height="713" src="https://images2.imgbox.com/24/bd/x6FLjwrF_o.png" width="524"></p> 
<pre><code class="language-cpp">//尾删除
void weisc(SL** r)
{
	assert(r &amp;&amp; *r);
	//判断第一个节点的p是不是null，是就直接释放
	if ((*r)-&gt;p == NULL)
	{
		free(*r);
		*r = NULL;
	}
	else
	{
		//这个找后面的节点
		SL* add = *r;
		//这个是后面的前一个节点
		SL* tab = NULL;
		//循环到后面的节点
		while (add-&gt;p)
		{
			//把当前节点给tab
			tab = add;
			//然后指向下一个节点
			add = add-&gt;p;
		}
		//把tab赋值为null
		tab-&gt;p = NULL;
		//然后释放add的空间
		free(add);
		add = NULL;
	}
}
</code></pre> 
<hr> 
<p>我们可以看到尾插1,2,3,4删除了4这个节点</p> 
<p><img alt="" height="223" src="https://images2.imgbox.com/a8/db/733X6tC0_o.png" width="474"></p> 
<pre><code class="language-cpp">    SL* add = NULL;
	//尾插
	weic(&amp;add, 1);
	weic(&amp;add, 2);
	weic(&amp;add, 3);
	weic(&amp;add, 4);
	//尾删
	weisc(&amp;add);
	day(add);</code></pre> 
<hr> 
<h5 id="%E5%A4%B4%E5%88%A0">头删</h5> 
<p><img alt="" height="258" src="https://images2.imgbox.com/3a/2f/ngOCcqYt_o.png" width="416"></p> 
<pre><code class="language-cpp">//头删除
void tosc(SL** r);</code></pre> 
<p><img alt="" height="320" src="https://images2.imgbox.com/27/19/m5jzTupk_o.png" width="840"></p> 
<hr> 
<p>思路：<span style="color:#fe2c24;">创建add保存头节点，r往后走一步，释放add空间</span></p> 
<p><img alt="" height="263" src="https://images2.imgbox.com/84/3e/RTpFKzJl_o.png" width="309"></p> 
<pre><code class="language-cpp">//头删除
void tosc(SL** r)
{
	assert(*r);

	SL* add = *r;
	*r = (*r)-&gt;p;
	free(add);
	add = NULL;
}</code></pre> 
<hr> 
<p>可以看到我们删了1和2。</p> 
<p><img alt="" height="257" src="https://images2.imgbox.com/fe/0c/YKSLOJEB_o.png" width="601"></p> 
<pre><code class="language-cpp">	SL* add = NULL;
	//尾插
	weic(&amp;add, 1);
	weic(&amp;add, 2);
	weic(&amp;add, 3);
	weic(&amp;add, 4);
	//头删
	tosc(&amp;add);
	tosc(&amp;add);
	day(add);</code></pre> 
<hr> 
<h5 id="%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE">查询数据</h5> 
<p><img alt="" height="299" src="https://images2.imgbox.com/86/6c/aFl4638v_o.png" width="437"></p> 
<pre><code class="language-cpp">//查询
SL* cx(SL* r,data x);</code></pre> 
<hr> 
<p>思路：<span style="color:#fe2c24;">把r给add,让add循环判断每个节点的arr数据等不等于x，等于直接返回当前节点，不等于返回NULL</span>。</p> 
<p><img alt="" height="465" src="https://images2.imgbox.com/17/ef/XNjmwkbn_o.png" width="487"></p> 
<pre><code class="language-cpp">//查询
SL* cx(SL* r, data x)
{
	SL* add = r;
	//循环查询
	while (add)
	{
		//判断是不是等于x
		if (add-&gt;arr == x)
		{
			//是就返回当前节点
			return add;
		}
		//指向下一个节点
		add = add-&gt;p;
	}
	//没有返回空
	return NULL;
}
</code></pre> 
<hr> 
<p>pos接收当前节点，等于空打印没找到，不等于打印找到了。</p> 
<p><img alt="" height="421" src="https://images2.imgbox.com/a3/54/CfbCiQCO_o.png" width="309"></p> 
<pre><code class="language-cpp">	SL* add = NULL;
	//尾插
	weic(&amp;add, 1);
	weic(&amp;add, 2);
	weic(&amp;add, 3);
	weic(&amp;add, 4);
	day(add);
	//查询
	SL* pos = cx(add, 4);
	if (pos == NULL)
	{
		printf("没找到\n");
	}
	else
	{
		printf("找到了\n");
	}
</code></pre> 
<hr> 
<h5 id="%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E5%89%8D%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE">指定位置前插入数据</h5> 
<p><img alt="" height="345" src="https://images2.imgbox.com/e6/ee/75o59cYW_o.png" width="444"></p> 
<pre><code class="language-cpp">//在指定位置前插入数据
void zhidqcr(SL** r, SL* pos, data x);</code></pre> 
<p><img alt="" height="465" src="https://images2.imgbox.com/ad/0f/kMJPr4EW_o.png" width="846"></p> 
<hr> 
<p>思路：<span style="color:#fe2c24;">判断pos等于r就说明在第一个节点或只有一个节点，直接调用头插的函数就行了。</span></p> 
<p><span style="color:#fe2c24;">add循环到pos后面，tab-&gt;p连接pos，add-&gt;p连接tab。</span></p> 
<p><img alt="" height="622" src="https://images2.imgbox.com/dc/02/PFv6qjJB_o.png" width="467"></p> 
<pre><code class="language-cpp">//在指定位置前插入数据
void zhidqcr(SL** r,SL* pos, data x)
{
	assert(r);
	assert(pos);
	//判断是不是在第一个节点
	if (pos == *r)
	{
		//是就调用头插
		toc(r,x);
	}
	else
	{
		//申请的空间
		SL* tab = koj(x);
		SL* add = *r;
		//循环到节点前面停下
		while (add-&gt;p != pos)
		{
			add = add-&gt;p;
		}
		//进行
		tab-&gt;p = pos;
		add-&gt;p = tab;

	}
}</code></pre> 
<hr> 
<p>在3的前面插入了一个数据为99的节点</p> 
<p><img alt="" height="482" src="https://images2.imgbox.com/50/99/ptDyawZv_o.png" width="630"></p> 
<pre><code class="language-cpp">	SL* add = NULL;
	//尾插
	weic(&amp;add, 1);
	weic(&amp;add, 2);
	weic(&amp;add, 3);
	weic(&amp;add, 4);
	//查询
	SL* pos = cx(add, 3);
	//if (pos == NULL)
	//{
	//	printf("没找到\n");
	//}
	//else
	//{
	//	printf("找到了\n");
	//}
	zhidqcr(&amp;add, pos, 99);

	day(add);
</code></pre> 
<hr> 
<h5 id="%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E5%90%8E%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE">指定位置后插入数据</h5> 
<p><img alt="" height="411" src="https://images2.imgbox.com/86/62/JClFd9da_o.png" width="536"></p> 
<pre><code class="language-cpp">//在指定位置后插入数据
void zhidhcr(SL* pos, data x);</code></pre> 
<p><img alt="" height="429" src="https://images2.imgbox.com/e1/2a/wdararWV_o.png" width="918"></p> 
<hr> 
<p>思路：<span style="color:#fe2c24;">add是新申请的空间，add-&gt;p连接pos下一个节点，pos-&gt;p连接add。</span></p> 
<p><img alt="" height="284" src="https://images2.imgbox.com/21/a9/cABpjLaC_o.png" width="429"></p> 
<pre><code class="language-cpp">//指定位置后插入数据
void zhidhcr(SL* pos, data x)
{
	assert(pos);
	//申请空间
	SL* add = koj(x);
	//把r后面那个节点的地址给新的节点
	add-&gt;p = pos-&gt;p;
	//把新的节点给r
	pos-&gt;p = add;
}</code></pre> 
<hr> 
<p>我们可以看到在3后面插入了一个99的节点。</p> 
<p><img alt="" height="451" src="https://images2.imgbox.com/75/8b/T7KzH4rT_o.png" width="773"></p> 
<pre><code class="language-cpp">	SL* add = NULL;
	//尾插
	weic(&amp;add, 1);
	weic(&amp;add, 2);
	weic(&amp;add, 3);
	weic(&amp;add, 4);
	//查询
	SL* pos = cx(add, 3);
	//if (pos == NULL)
	//{
	//	printf("没找到\n");
	//}
	//else
	//{
	//	printf("找到了\n");
	//}
	zhidhcr(pos, 99);</code></pre> 
<hr> 
<h5 id="%E5%88%A0%E9%99%A4pos%E8%8A%82%E7%82%B9">删除pos节点</h5> 
<p><img alt="" height="437" src="https://images2.imgbox.com/5d/19/dCJL4IkQ_o.png" width="412"></p> 
<pre><code class="language-cpp">//删除pos节点
void scpos(SL** r, SL* pos);</code></pre> 
<p><img alt="" height="255" src="https://images2.imgbox.com/bd/53/rQ0E08Fc_o.png" width="814"></p> 
<hr> 
<p>思路：<span style="color:#fe2c24;">判断只有一个节点或等于当前节点，直接释放。</span></p> 
<p><span style="color:#fe2c24;">把r给add,让add循环到pos前一个节点，add-&gt;p指向pos下一个节点，然后释放pos空间。</span></p> 
<p><img alt="" height="624" src="https://images2.imgbox.com/35/a8/pl10b67R_o.png" width="790"></p> 
<pre><code class="language-cpp">//删除pos节点
void scpos(SL** r, SL* pos)
{
	//我们需要pos前一个节点，和后一个节点连接
	assert(r &amp;&amp; *r);
	assert(pos);
	//判断如果（第一个节点等于要删除的节点）直接释放
	if (*r == pos)
	{
		free(*r);
		*r = NULL;
	}
	else
	{
		SL* add = *r;
		//循环走到pos节点的后面
		while (add-&gt;p != pos)
		{
			add = add-&gt;p;
		}
		//把pos指向的节点，给pos前面的节点（把pos后面的节点和pos前面的节点进行连接）
		add-&gt;p = pos-&gt;p;
		//释放pos空间
		free(pos);
		pos = NULL;
	}
}</code></pre> 
<hr> 
<p>我们可以看到3被删除了</p> 
<p><img alt="" height="486" src="https://images2.imgbox.com/be/9c/gVmpugn6_o.png" width="777"></p> 
<pre><code class="language-cpp">    SL* add = NULL;
	//尾插
	weic(&amp;add, 1);
	weic(&amp;add, 2);
	weic(&amp;add, 3);
	weic(&amp;add, 4);
	//查询
	SL* pos = cx(add, 3);
	//if (pos == NULL)
	//{
	//	printf("没找到\n");
	//}
	//else
	//{
	//	printf("找到了\n");
	//}
	scpos(&amp;add,pos);</code></pre> 
<hr> 
<h5 id="%E5%88%A0%E9%99%A4pos%E5%90%8E%E9%9D%A2%E7%9A%84%E8%8A%82%E7%82%B9">删除pos后面的节点</h5> 
<p><img alt="" height="486" src="https://images2.imgbox.com/8d/5a/fRvtU3iL_o.png" width="455"></p> 
<pre><code class="language-cpp">//删除pos后面的节点
void schpos(SL* pos);</code></pre> 
<p><img alt="" height="275" src="https://images2.imgbox.com/f8/a0/tpkESGac_o.png" width="855"></p> 
<hr> 
<p>思路：<span style="color:#fe2c24;">把pos下一个节点给add,   pos-&gt;p指向add下一个节点。释放add空间。</span></p> 
<p><img alt="" height="305" src="https://images2.imgbox.com/3c/ef/zrCMbxox_o.png" width="388"></p> 
<pre><code class="language-cpp">//删除pos后面的节点
void schpos(SL* pos)
{
	assert(pos&amp;&amp;pos-&gt;p);
	//把pos下一个节点给add
	SL* add = pos-&gt;p;
	//把add下个节点给pos
	pos-&gt;p = add-&gt;p;
	//释放add
	free(add);
	add = NULL;
}</code></pre> 
<hr> 
<h5><img alt="" height="452" src="https://images2.imgbox.com/fb/e7/CX3MeXP0_o.png" width="741"></h5> 
<pre><code class="language-cpp">	SL* add = NULL;
	//尾插
	weic(&amp;add, 1);
	weic(&amp;add, 2);
	weic(&amp;add, 3);
	weic(&amp;add, 4);
	//查询
	SL* pos = cx(add, 3);
	//if (pos == NULL)
	//{
	//	printf("没找到\n");
	//}
	//else
	//{
	//	printf("找到了\n");
	//}
	scpos(&amp;add,pos);
	day(add);</code></pre> 
<hr> 
<h5 id="%E9%94%80%E6%AF%81">销毁</h5> 
<p><img alt="" height="213" src="https://images2.imgbox.com/c5/86/4XnbC69O_o.png" width="306"></p> 
<pre><code class="language-cpp">//链表销毁
void xiaoh(SL** r);</code></pre> 
<hr> 
<p>思路：add循环释放，tab保存add下一个节点，释放add，在把tab给add,</p> 
<p>最后还剩下*r赋值为NULL。</p> 
<p><img alt="" height="504" src="https://images2.imgbox.com/f7/a5/Ayxpimrm_o.png" width="394"></p> 
<pre><code class="language-cpp">//链表销毁
void xiaoh(SL** r)
{
	assert(r &amp;&amp; *r);
	//把r节点给add
	SL* add = *r;
	SL* tab = NULL;
	//循环走全部节点
	while (add)
	{
		//把add下一个节点给tab
		tab = add-&gt;p;
		//释放add节点
		free(add);
		//把tab给add
		add = tab;
	}
	//把一开始的*r赋值为NULL
	*r = NULL;

}</code></pre> 
<hr> 
<p>释放完后还剩下*r的空间需要赋值为NULL</p> 
<p><img alt="" height="843" src="https://images2.imgbox.com/75/29/boa6TBXm_o.png" width="951"></p> 
<p><img alt="" height="706" src="https://images2.imgbox.com/e8/6a/M9DJb9Pp_o.png" width="986"></p> 
<hr> 
<h4 id="%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB">链表的分类</h4> 
<p>链表的结构⾮常多样，以下情况组合起来就有8种（2x2x2）链表结构：</p> 
<p><img alt="" height="852" src="https://images2.imgbox.com/98/84/gHXHhgGb_o.png" width="734"></p> 
<h5 id="%E9%93%BE%E8%A1%A8%E8%AF%B4%E6%98%8E%EF%BC%9A">链表说明：</h5> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/f6/20/q0FMS7Mn_o.png" width="1200"></p> 
<p>虽然有这么多的链表的结构，但是我们实际中最常⽤还是两种结构：单链表和双向带头循环链表</p> 
<p>1.⽆头单向⾮循环链表：结构简单，⼀般不会单独⽤来存数据。实际中更多是作为其他数据结构的⼦ 结构，如哈希桶、图的邻接表等等。另外这种结构在笔试⾯试中出现很多。 </p> 
<p>2.带头双向循环链表：结构最复杂，⼀般⽤在单独存储数据。实际中使⽤的链表数据结构，都是带头 双向循环链表。另外这个结构虽然结构复杂，但是使⽤代码实现以后会发现结构会带来很多优势，实 现反⽽简单了，后⾯我们代码实现了就知道了。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6f1cee7d37150070d917bdaa1187f6ad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">算法学习6——贪心算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d659a4256badc6430a9138fdf81b8136/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Tuxera 2024 NTFS for Mac 破解版安装、密钥下载与激活教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>