<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Java】面向对象的三大特征：封装、继承、多态 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/0fd4a8277a67f1c1318b1787ef3c58ba/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【Java】面向对象的三大特征：封装、继承、多态">
  <meta property="og:description" content="封装 什么叫封装？
在我们写代码的时候经常会涉及两种角色： 类的实现者 和 类的调用者。 封装的本质就是让类的调用者不必太多的了解类的实现者是如何实现类的， 只要知道如何使用类就行了，这样就降低了类使用者的学习和使用成本， 从而 降低了复杂程度。 下面我们来介绍一下在我们Java里的几个访问权限修饰符： private: 类内部能访问, 类外部不能访问默认(也叫包访问权限): 类内部能访问, 同一个包中的类可以访问, 其他类不能访问protected: 类内部能访问, 子类和同一个包中的类可以访问, 其他类不能访问public : 类内部和类的调用者都能访问 使用private实现封装 被 public 修饰的成员变量或者成员方法， 可以直接被类的调用者使用。被 private 修饰的成员变量或者成员方法， 不能被类的调用者使用。 封装的本质是：类的使用者根本不需要知道， 也不需要关注一个类都有哪些 private 的成员。从而让类调用者以更低的成本来使用类。
代码示例：
class Student{ private String name = &#34;张三&#34;; private int age = 20; public void show(){ System.out.println(&#34;姓名：&#34;&#43;name&#43;&#34; ,年龄：&#34;&#43;age); } } public class Demo1 { public static void main(String[] args) { Student student = new Student(); student.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-01T21:29:57+08:00">
    <meta property="article:modified_time" content="2024-06-01T21:29:57+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Java】面向对象的三大特征：封装、继承、多态</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>封装</h2> 
<p><strong>什么叫封装？</strong></p> 
<div> 
 <span style="color:#777777;">在我们写代码的时候经常会涉及两种角色：</span> 
 <span style="color:#777777;"><strong>类的实现者</strong></span> 
 <span style="color:#777777;">和</span> 
 <span style="color:#777777;"><strong>类的调用者。</strong></span> 
</div> 
<div> 
 <span style="color:#777777;">封装的本质就是让类的调用者不必太多的了解类的实现者是如何实现类的，</span> 
 <span style="color:#777777;">只要知道如何使用类就行了，这样就降低了类使用者的学习和使用成本， 从而</span> 
 <span style="color:#777777;">降低了复杂程度。</span> 
</div> 
<div></div> 
<div>
  下面我们来介绍一下在我们Java里的几个访问权限修饰符： 
</div> 
<div></div> 
<div> 
 <img alt="" height="1156" src="https://images2.imgbox.com/b0/a3/qq6xqOWv_o.png" width="1200"> 
</div> 
<div></div> 
<ul><li>private: 类内部能访问, 类外部不能访问</li><li>默认(也叫包访问权限): 类内部能访问, 同一个包中的类可以访问, 其他类不能访问</li><li>protected: 类内部能访问, 子类和同一个包中的类可以访问, 其他类不能访问</li><li>public : 类内部和类的调用者都能访问</li></ul> 
<h3>使用private实现封装</h3> 
<ul><li>被 public 修饰的成员变量或者成员方法， 可以直接被类的调用者使用。</li><li>被 private 修饰的成员变量或者成员方法， 不能被类的调用者使用。</li></ul> 
<p>封装的本质是：类的使用者根本不需要知道， 也不需要关注一个类都有哪些 private 的成员。从而让类调用者以更低的成本来使用类。</p> 
<p>代码示例：</p> 
<pre><code>class Student{
    private String name = "张三";
    private int age = 20;

    public void show(){
        System.out.println("姓名："+name+" ,年龄："+age);
    }
}
public class Demo1 {
    public static void main(String[] args) {
        Student student = new Student();
        student.show();
    }
}</code></pre> 
<ul><li>此时字段已经使用 private 来修饰，类的调用者(main方法中)不能直接使用， 而需要借助 show 方法，此时类的使用者就不必了解 Person 类的实现细节。</li><li>同时如果类的实现者修改了字段的名字，类的调用者不需要做出任何修改(类的调用者根本访问不到 name， age这样的字段)</li></ul> 
<p><strong>注意事项</strong></p> 
<ul><li><strong>private 不光能修饰字段, 也能修饰方法。</strong></li><li><strong>通常情况下我们会把字段设为 private 属性, 但是方法是否需要设为 public, 就需要视具体情形而定. 一般我们希望一个类只提供 "必要的" public 方法, 而不应该是把所有的方法都无脑设为 public</strong></li></ul> 
<h2><strong>继承</strong></h2> 
<p><strong>代码中创建的类, 主要是为了抽象现实中的一些事物(包含属性和方法)</strong></p> 
<p><strong>有的时候客观事物之间就存在一些关联关系, 那么在表示成类和对象的时候也会存在一定的关联</strong></p> 
<p>这时我们就需要引入<span style="color:#fe2c24;">父类 , 基类 或 超类</span><span style="color:#0d0016;">和</span><span style="color:#fe2c24;">子类, 派生类</span><span style="color:#0d0016;">，和现实中的儿子继承父亲的财产类似, 子类也会继承父类的字段和方法, 以达到代码重用的效果，从而降低代码的冗余性。</span></p> 
<p>继承的基本语法：</p> 
<blockquote> 
 <p>class 子类 extends 父类 {<!-- --><br> }</p> 
</blockquote> 
<ul><li>使用 extends 指定父类</li><li>Java 中一个子类只能继承一个父类</li><li>子类会继承父类的所有 public 的字段和方法</li><li>对于父类的 private 的字段和方法, 子类中是无法访问的</li><li>子类的实例中, 也包含着父类的实例. 可以使用 super 关键字得到父类实例的引用 </li></ul> 
<p>我们来用代码实现一个继承关系：</p> 
<pre><code class="language-java">class Father{
    public String name;
    public int age;
    public char sex;

    public void eat(){
        System.out.println("吃饭");
    }
}

class Son extends Father{
    public void drink(){
        System.out.println("喝水");
    }
}

public class Demo1{
    public static void main(String[] args) {
        Son son = new Son();
        son.name = "张三";
        son.age = 20;
        son.sex = '男';
        son.eat();
        son.drink();
    }
}</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="198" src="https://images2.imgbox.com/b5/87/jNagWd2O_o.png" width="748"></p> 
<p> 我们通过代码很容易看出来：当 Son 类继承了 Father 类后，就相当于把父类里的一些用 public 修饰过的属性和方法给拷贝过来了。</p> 
<h3 style="background-color:transparent;">protected 关键字</h3> 
<p>在上述代码中我们发现, 如果把字段设为 private, 子类不能访问. 但是设成 public, 又违背了我们 "封装" 的初衷。所以我们就有个两全其美的办法：就是使用 protected 关键字。</p> 
<ul><li>对于类的调用者来说, protected 修饰的字段和方法是不能访问的</li><li>对于类的 子类 和 同一个包的其他类 来说, protected 修饰的字段和方法是可以访问的</li></ul> 
<h3 style="background-color:transparent;">Final关键字</h3> 
<p> ﬁnal 关键字, 修饰一个变量或者字段的时候, 表示 <strong>常量</strong> (不能修改)</p> 
<blockquote> 
 <p>final int a = 10;<br> a = 20;  // 编译出错</p> 
</blockquote> 
<p>ﬁnal 关键字也能修饰类, 此时表示被修饰的类就不能被继承</p> 
<p><img alt="" height="386" src="https://images2.imgbox.com/6d/7d/fsyoeJnj_o.png" width="1034"></p> 
<p>当我们用 final 修饰 Father 类后，再想用 Son 类继承 Father 类就发生报错了</p> 
<h3>组合</h3> 
<p><strong>和继承类似, 组合也是一种表达类之间关系的方式, 也是能够达到代码重用的效果 。</strong></p> 
<p><strong>代码示例:</strong></p> 
<pre><code class="language-java">class Student {

}
class Teacher {

}
class School {
    public Student[] students;
    public Teacher[] teachers;
}</code></pre> 
<p>组合并没有涉及到特殊的语法(诸如 extends 这样的关键字), 仅仅是将一个类的实例作为另外一个类的字段.这是我们设计类的一种常用方式之一.</p> 
<h3>多态</h3> 
<h3>向上转型</h3> 
<p>代码示例：</p> 
<pre><code class="language-java">class Father{
    
}
class Son extends Father{
    
}
public class Data {
    public static void main(String[] args) {
        Father f1 = new Father();
    }
}</code></pre> 
<p>向上转型发生的时机：</p> 
<ul><li>直接赋值</li><li>方法传参</li><li>方法返回</li></ul> 
<p>直接赋值的方式我们已经演示了. 另外两种方式和直接赋值没有本质区别</p> 
<h4>方法传参</h4> 
<p>代码示例：</p> 
<pre><code class="language-java">class Father{

}
class Son extends Father{

}
public class Data {
    public static void func(Father f1){
        
    }
    public static void main(String[] args) {
        func(new Son());
    }
}</code></pre> 
<h4>方法返回</h4> 
<p>代码示例</p> 
<pre><code class="language-java">class Father{

}
class Son extends Father{

}
public class Data {
    public static Father func(){
        Son son = new Son();
        return son;
    }
    public static void main(String[] args) {
        Father f1 = func();
    }
}</code></pre> 
<p>此时方法 func() 返回的是一个 Father 类型的引用, 但是实际上对应到 Son 的实例。</p> 
<h3>动态绑定</h3> 
<p>当子类和父类中出现同名方法的时候, 再去调用就会发生动态绑定。</p> 
<pre><code class="language-java">class Father{
    public String name;
    public int age;
    public void eat(){
        System.out.println("正在吃东西");
    }
}
class Son extends Father{
    public void eat(){
        System.out.println("正在吃苹果");
    }
}
public class Data {
    public static void main(String[] args) {
        Father f = new Son();
        f.eat();
    }
}</code></pre> 
<p><strong>此时, 我们发现：</strong></p> 
<ul><li><strong>f 虽然是 Father 类型的引用, 但是 f 指向 Son 类型的实例。</strong></li><li><strong>在调用 eat() 方法的时候，本应该是调用 Father 类里面的方法，实际上调用的是 Son 类里面的方法</strong></li></ul> 
<p><strong>因此, 在 Java 中, 调用某个类的方法, 究竟执行了哪段代码 (是父类方法的代码还是子类方法的代码) , 要看究竟这个引用指向的是父类对象还是子类对象. 这个过程是程序运行时决定的(而不是编译期), 因此称为 动态绑定。</strong></p> 
<h3>方法重写</h3> 
<p>针对刚才的 eat 方法来说:子类实现父类的同名方法, 并且参数的类型和个数完全相同, 这种情况称为 覆写/重写/覆盖。</p> 
<p>关于重写的注意事项：</p> 
<ul><li>1. 重写和重载完全不一样. </li><li>2. 普通方法可以重写, static 修饰的静态方法不能重写.</li><li>3. 重写中子类的方法的访问权限不能低于父类的方法访问权限.</li><li>4. 重写的方法返回值类型不一定和父类的方法相同(但是建议最好写成相同, 特殊情况除外)</li></ul> 
<p><strong>重载和重写的区别：</strong></p> 
<p><img alt="" height="1158" src="https://images2.imgbox.com/87/71/nDJWPsCE_o.png" width="1200"></p> 
<h3>多态</h3> 
<p>有了面的向上转型, 动态绑定, 方法重写之后, 我们就可以使用 多态的形式来设计程序了.我们可以写一些只关注父类的代码, 就能够同时兼容各种子类的情况。</p> 
<p>代码示例：打印各种形状</p> 
<pre><code class="language-java">class Shape{
    public void draw(){
        System.out.println("打印一个图形");
    }
}
class Rectangle extends Shape{
    @Override
    public void draw() {
        System.out.println("矩形");
    }
}
class Circle extends Shape{
    @Override
    public void draw() {
        System.out.println("圆形");
    }
}
class Flower extends Shape{
    @Override
    public void draw() {
        System.out.println("❀");
    }
}

public class Data{
    public static void stamp(Shape shape){
        shape.draw();
    }
    public static void main(String[] args) {
        stamp(new Rectangle());
        stamp(new Circle());
        stamp(new Flower());
    }
}</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="225" src="https://images2.imgbox.com/e7/e9/hFsSuY6W_o.png" width="802"></p> 
<p>多态顾名思义, 就是 "一个引用, 能表现出多种不同形态"</p> 
<p><strong>使用多态的好处是什么?</strong></p> 
<p><strong>1) 类调用者对类的使用成本进一步降低</strong></p> 
<ul><li><strong>封装是让类的调用者不需要知道类的实现细节.</strong></li><li><strong>多态能让类的调用者连这个类的类型是什么都不必知道, 只需要知道这个对象具有某个方法即可</strong></li></ul> 
<p>2) 能够降低代码的 "圈复杂度", 避免使用大量的 if - else</p> 
<p>3) 可扩展能力更强</p> 
<h3 style="background-color:transparent;">向下转型</h3> 
<p>向上转型是子类对象转成父类对象, 向下转型就是父类对象转成子类对象. 相比于向上转型来说, 向下转型没那么常见,但是也有一定的用途.</p> 
<p>代码示例：</p> 
<pre><code class="language-java">class Son extends Father{
    public void eat(){
        System.out.println(name + "正在吃东西");
    }

    public void haha(){
        System.out.println("haha");
    }
}

public class Data{
    public static void main(String[] args) {
        Father f2 = new Son();
        if(f2 instanceof Son){
            Son f3 = (Son)f2;
            f3.haha();
        }else{
            System.out.println("不能转型");
        }
    }
}</code></pre> 
<p>如果我们用普通的向上转型的话，是无法使用除了与父类同名的方法外的任何方法，但是我们使用向下转型就可以使用。只是这样一般不安全，所以我们要使用 instanceof 来判断是否正确的引用了子类。</p> 
<h2>super关键字</h2> 
<p>前面的代码中由于使用了重写机制, 调用到的是子类的方法. 如果需要在子类内部调用父类方法怎么办? 可以使用super 关键字。</p> 
<p>代码示例：</p> 
<pre><code class="language-java">class Father{
    public String name;
    public int age = 20;
    public void eat(){
        System.out.println("正在吃东西");
    }
}
class Son extends Father{
   public int age = 30;
   public void func(){
       System.out.println(super.age);
   }
}
public class Data {
    public static void main(String[] args) {
        Son son = new Son();
        son.func();
    }
}</code></pre> 
<p>我们可以看到在我们的子类和父类里都有属性 age ，当我们使用了 super 关键字后就可以访问父类的该属性。</p> 
<p>运行结果：</p> 
<p><img alt="" height="182" src="https://images2.imgbox.com/93/41/3GEC4j2P_o.png" width="808"></p> 
<p><strong>super 和 this 的区别：</strong></p> 
<p><img alt="" height="1156" src="https://images2.imgbox.com/dc/98/6ldF9sfy_o.png" width="1200"></p> 
<h2>抽象类</h2> 
<p>语法规则：</p> 
<blockquote> 
 <p>abstract class Shape {<!-- --><br> abstract public void draw();<br> }</p> 
</blockquote> 
<ul><li>在 draw 方法前加上 abstract 关键字, 表示这是一个抽象方法. 同时抽象方法没有方法体(没有 { }, 不能执行具体代码).</li><li>对于包含抽象方法的类, 必须加上 abstract 关键字表示这是一个抽象类. </li></ul> 
<p><strong>注意事项：</strong></p> 
<p><strong>1) 抽象类不能直接实例化</strong></p> 
<blockquote> 
 <p><strong>Shape shape = new Shape();<br> // 编译出错<br> Error:(30, 23) java: Shape是抽象的; 无法实例化</strong></p> 
</blockquote> 
<p>2) 抽象方法不能是 private 的</p> 
<blockquote> 
 <p>abstract class Shape {<!-- --><br> abstract private void draw();<br> }<br> // 编译出错<br> Error:(4, 27) java: 非法的修饰符组合: abstract和private </p> 
</blockquote> 
<p>3) 抽象类中可以包含其他的非抽象方法, 也可以包含字段. 这个非抽象方法和普通方法的规则都是一样的, 可以被重写,也可以被子类直接调用 </p> 
<blockquote> 
 <p>abstract class Shape {<!-- --><br> abstract public void draw();<br> void func() {<!-- --><br> System.out.println("func");<br> }<br> }<br> class Rect extends Shape {<!-- --><br> ...<br> }</p> 
</blockquote> 
<p><strong>抽象类的作用 ：</strong></p> 
<ul><li><strong>抽象类存在的最大意义就是为了被继承</strong></li><li><strong>抽象类本身不能被实例化, 要想使用, 只能创建该抽象类的子类. 然后让子类重写抽象类中的抽象方法</strong></li><li><strong>使用抽象类相当于多了一重编译器的校验</strong></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/72418d0909956de6c9e5321222f56b5c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">认识JAVA中的异常</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8df947b9df59190478564dea94970438/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">卷积神经网络——为什么卷积哪儿都能用？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>