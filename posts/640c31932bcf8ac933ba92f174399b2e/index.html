<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Sentinel限流规则详解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/640c31932bcf8ac933ba92f174399b2e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Sentinel限流规则详解">
  <meta property="og:description" content="上一期教程讲解了 Sentinel 的快速入门：Sentinel快速入门，这一期主要讲述 Sentinel 的限流规则
簇点链路 簇点链路就是项目内的调用链路（Controller -&gt; Service -&gt; Mapper），链路中被监控的每个接口就是一个资源。默认情况下 Sentinel 会监控 SpringMVC 的每一个端点（Endpoint），因此 SpringMVC 的每一个端点（Endpoint）就是调用链路中的一个资源（这里指的就是 Controller 中的方法）
流控、熔断等都是针对簇点链路中的资源来设置的，因此我们可以点击对应资源后面的按钮来设置规则：
点击后面的流控按钮，就可以弹出表单。表单中可以添加流控规则，如下图所示：
然后，我们在单击阈值的框中填写数字 1 并点击新增按钮，表示限制 /service1/hello 这个资源的单击 QPS 为1，即每秒只允许1次请求，超出的请求会被拦截并报错
之后在浏览器快速刷新对应的页面，结果如下所示，表示限流规则已经生效
流控模式 在添加限流规则时，点击高级选项，可以选择三种流控模式：
三种模式对应的含义是：
1.直接
统计当前资源的请求，触发阈值时对当前资源直接限流，是默认的模式
2.关联
统计与当前资源相关的另一个资源，当另一个资源触发阈值时，对当前资源限流
使用场景：用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁，产生竞争。业务需求是优先支付和更新订单的业务，因此当修改订单业务触发阈值时，需要对查询订单业务限流
例如，对于下图来说，当 /write 资源访问量触发阈值时，就会对 /read 资源限流，避免影响 /write 资源
一般来说，满足下面条件就可以使用关联模式：
① 两个有竞争关系的资源
② 一个优先级较高，一个优先级较低
3.链路
统计从指定链路访问到本资源的请求，触发阈值时，对指定链路限流
例如，有两条请求链路：
① /link1 -&gt; /common
② /link2 -&gt; /common
如果只希望统计从 /link2 进入到 /common 的请求，就可以设置链路模式的流控规则
实现步骤：
1.在服务层中填写共同调用的方法
@Service public class WebServiceImpl implements WebService { @Override @SentinelResource(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-23T19:38:58+08:00">
    <meta property="article:modified_time" content="2024-07-23T19:38:58+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Sentinel限流规则详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>上一期教程讲解了 Sentinel 的快速入门：<a href="https://blog.csdn.net/Vendetta_A_A/article/details/140633104?spm=1001.2014.3001.5501">Sentinel快速入门</a>，这一期主要讲述 Sentinel 的<strong>限流规则</strong></p> 
<h2><a id="_2"></a>簇点链路</h2> 
<p>簇点链路就是项目内的调用链路（Controller -&gt; Service -&gt; Mapper），链路中被监控的每个接口就是一个资源。默认情况下 Sentinel 会监控 SpringMVC 的每一个<strong>端点（Endpoint）</strong>，因此 <strong>SpringMVC 的每一个端点（Endpoint）就是调用链路中的一个资源</strong>（这里指的就是 Controller 中的方法）</p> 
<p>流控、熔断等都是<strong>针对簇点链路中的资源</strong>来设置的，因此我们可以点击对应资源后面的按钮来设置规则：</p> 
<p><img src="https://images2.imgbox.com/28/5a/rwDuCk2i_o.png" alt="image-20240723132225733"></p> 
<p>点击后面的流控按钮，就可以弹出表单。表单中可以添加流控规则，如下图所示：</p> 
<p><img src="https://images2.imgbox.com/01/87/euS73YlI_o.png" alt="image-20240723132308620"></p> 
<p>然后，我们在单击阈值的框中填写数字 1 并点击新增按钮，表示限制 <code>/service1/hello</code> 这个资源的单击 QPS 为1，即每秒只允许1次请求，超出的请求会被拦截并报错</p> 
<p>之后在浏览器快速刷新对应的页面，结果如下所示，表示限流规则已经生效</p> 
<p><img src="https://images2.imgbox.com/7c/30/kMlXmqxr_o.png" alt="image-20240723132556847"></p> 
<h2><a id="_20"></a>流控模式</h2> 
<p>在添加限流规则时，点击高级选项，可以选择三种流控模式：</p> 
<p><img src="https://images2.imgbox.com/ba/2a/RgDJDJ2S_o.png" alt="image-20240723132703948"></p> 
<p>三种模式对应的含义是：</p> 
<p>1.<strong>直接</strong></p> 
<p>统计当前资源的请求，触发阈值时对当前资源直接限流，是默认的模式</p> 
<p>2.<strong>关联</strong></p> 
<p>统计与当前资源相关的另一个资源，当另一个资源触发阈值时，对当前资源限流</p> 
<p>使用场景：用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁，产生竞争。业务需求是优先支付和更新订单的业务，因此当修改订单业务触发阈值时，需要对查询订单业务限流</p> 
<p>例如，对于下图来说，当 <code>/write</code> 资源访问量触发阈值时，就会对 <code>/read</code> 资源限流，避免影响 <code>/write</code> 资源</p> 
<p><img src="https://images2.imgbox.com/b6/a3/bbpb7D80_o.png" alt="关联模式"></p> 
<p>一般来说，满足下面条件就可以使用关联模式：</p> 
<p>① 两个有竞争关系的资源<br> ② 一个优先级较高，一个优先级较低</p> 
<p><strong>3.链路</strong></p> 
<p>统计从指定链路访问到本资源的请求，触发阈值时，对指定链路限流</p> 
<p>例如，有两条请求链路：</p> 
<p>① <code>/link1</code> -&gt; <code>/common</code><br> ② <code>/link2</code> -&gt; <code>/common</code></p> 
<p>如果只希望统计从<code> /link2</code> 进入到 <code>/common</code> 的请求，就可以设置链路模式的流控规则</p> 
<p><strong>实现步骤：</strong></p> 
<p>1.在服务层中填写共同调用的方法</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">WebService</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token annotation punctuation">@SentinelResource</span><span class="token punctuation">(</span><span class="token string">"/common"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">common</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用共同方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>需要注意的是，Sentinel 默认只标记 Controller 中的方法作为资源，如果要标记其它方法，需要利用 <strong><code>@SentinelResource</code></strong> 注解进行标记，参数为对应资源的路径</p> 
<p>2.在控制层中，编写两条请求链路方法</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@RestController</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/service1"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebController</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">WebService</span> service<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/link1"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">link1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        service<span class="token punctuation">.</span><span class="token function">common</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token string">"调用链路1"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/link2"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">link2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        service<span class="token punctuation">.</span><span class="token function">common</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token string">"调用链路2"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>3.修改配置文件</p> 
<p>Sentinel 默认会将 Controller 中所有的方法进行 context 整合，此时会认为所有的 Controller 端点是同一个根链路发展而来的两个子链路，那么最终还是属于一个链路，由于不是两个链路，因此会导致链路模式的流控失效</p> 
<p>如下图所示：</p> 
<p><img src="https://images2.imgbox.com/73/bc/VLYX7HMx_o.png" alt="image-20240723143120544"></p> 
<p>此时需要在 application.yml 添加：</p> 
<pre><code class="prism language-yml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">sentinel</span><span class="token punctuation">:</span>
      <span class="token key atrule">web-context-unify</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 关闭context整合</span>
</code></pre> 
<p>重新启动后，可以发现变成了两个链路，如下图所示：</p> 
<p><img src="https://images2.imgbox.com/c9/c0/y7FK5BDC_o.png" alt="image-20240723143926675"></p> 
<p>4.在控制台设置流控规则，限制从 <code>/service1/link2</code> 进入到 <code>/common</code> 的 QPS 阈值为 2</p> 
<p><img src="https://images2.imgbox.com/2e/5d/Zn2LH9Y1_o.png" alt="image-20240723144016213"></p> 
<p>5.测试</p> 
<p>快速在浏览器刷新 link2 的请求，可以得到如下结果，即流控规则已经生效</p> 
<p><img src="https://images2.imgbox.com/53/0f/urvkBefQ_o.png" alt="image-20240723144128389"></p> 
<h2><a id="_133"></a>流控效果</h2> 
<p>流控效果是指请求达到流控阈值时应该采取的措施，包括三种：</p> 
<p><strong>1.快速失败</strong></p> 
<p>达到阈值后，新的请求会被立即拒绝并抛出 FlowException 异常。是默认的处理方式</p> 
<p><strong>2.wam up</strong></p> 
<p>预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化，从一个较小值逐渐增加到最大阈值</p> 
<p>warm up 是应对服务冷启动（冷启动指的是服务器虽然具有某一 QPS 最大值，但在刚启动时，是无法达到这个最大值的，如果此时请求数较高，即使没有超过最大QPS，服务器也可能因此挂掉）的一种方案。请求阈值初始值是 <code>threshold / coldFactor</code>，threshold 是最大阈值，coldFactor 是冷启动因子。持续指定时长后，逐渐提高到 threshold 值。而 coldFactor 的默认值是 3</p> 
<p><img src="https://images2.imgbox.com/d6/4e/LyvoMl43_o.png" alt="预热模式"></p> 
<p><strong>3.排队等待</strong></p> 
<p>让所有的请求按照先后次序排队执行，两个请求的间隔不能小于指定时长</p> 
<p>在排队等待中，所有请求都会进入一个队列中，然后按照阈值允许的时间间隔依次执行。后来的请求必须等待前面执行完成，如果请求的等待时间超出最大时长，则会被拒绝</p> 
<p>例如，如果 QPS = 5，意味着每 200ms 处理一个队列中的请求；而如果此时 timeout = 2000，则意味着等待超过 2000ms 的请求会被拒绝并抛出异常</p> 
<p><img src="https://images2.imgbox.com/c4/d0/TMJZCqbP_o.png" alt="排队等待案例"></p> 
<p>这种效果的好处是，即使请求数量的波动较大，即某段时间请求数量很少，某段时间请求数量很多，从队列中出去的数量也会是稳定的。因此起到流量削峰的作用，对微服务具有一定的保护功能</p> 
<p><img src="https://images2.imgbox.com/fe/09/YAiloyHG_o.png" alt="排队等待"></p> 
<h2><a id="_163"></a>热点参数限流</h2> 
<p>之前的限流是统计访问某个资源的所有请求，判断是否超过 QPS 阈值。而热点参数限流是分别统计<strong>参数值相同</strong>的请求，判断是否超过 QPS 阈值。这种方式是一种粒度更细的限流，精细到参数级别</p> 
<p>例如，在下图中，有四个请求，其中三个请求的参数 id 为1，最后一个请求的参数 id 为 2。此时就可以得出，id 为 1 的 QPS 为 3，id 为 2 的 QPS 为1</p> 
<p><img src="https://images2.imgbox.com/4c/77/8RSca6jL_o.png" alt="热点参数限流"></p> 
<p>案例：</p> 
<p>1.编写控制层代码</p> 
<p>这里需要注意的是，热点参数限流对默认的 SpringMVC 资源无效，只有通过 <strong><code>@SentinelResource</code></strong> 注解声明的资源才有效</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@RestController</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/service1"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebController</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/hot"</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@SentinelResource</span><span class="token punctuation">(</span><span class="token string">"/hot"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">hot</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">,</span> <span class="token class-name">Integer</span> age<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token string">"热点"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>2.在控制台中编写热点规则</p> 
<p><img src="https://images2.imgbox.com/30/bd/TT08IqNR_o.png" alt="image-20240723185922856"></p> 
<p><img src="https://images2.imgbox.com/62/e3/gRRfuyPw_o.png" alt="image-20240723192317280"></p> 
<p>该配置代表的含义是，对 <code>/hot</code> 这个资源的第 0 号参数（即第一个参数）做统计，每 10s 相同参数值的请求数不能超过 1</p> 
<p>点击高级选项，可以对部分参数进行例外配置。如下图所示</p> 
<p><img src="https://images2.imgbox.com/56/60/NTr3l4jM_o.png" alt="image-20240723190640738"></p> 
<p>结合之前的配置，表示对第一个参数限流，每 10s 相同参数的 QPS 不能超过 1，但有两个例外：</p> 
<p>① 如果参数类型是 String 且 参数值是 123456，则每 1 秒允许的 QPS 为 2<br> ② 如果参数类型是 int 且 参数值是 20，则每 1 秒允许的 QPS 为 3</p> 
<p>3.测试</p> 
<p>在浏览器输入：<a href="http://localhost:8081/service1/hot?username=%E5%BC%A0%E4%B8%89&amp;password=123456&amp;age=20" rel="nofollow">localhost:8081/service1/hot?username=张三&amp;password=123456&amp;age=20</a></p> 
<p>测试点主要有三个：</p> 
<p>① 快速刷新浏览器，此时结果应为刷新到第二次时就会报错<br> ② 将参数索引修改为 1，此时结果应为刷新到第三次时就会报错<br> ③ 将参数索引修改为 2，此时结果应为刷新到第四次时就会报错</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6efd382f728ae804f3a878ae8a23b653/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue3&#43;vite纯前端实现自动触发浏览器刷新更新版本内容，并在打包时生成版本号文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/437c61061b1a7f191a76996f0719d941/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CSP-J复赛模拟赛2————赵义弘补题报告</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>