<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;】继承（定义、菱形继承、虚拟继承） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/8cb79a775e5d5f58d49de4a1abd0367c/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;】继承（定义、菱形继承、虚拟继承）">
  <meta property="og:description" content="🌈个人主页：秦jh_-CSDN博客
🔥 系列专栏：https://blog.csdn.net/qinjh_/category_12575764.html?spm=1001.2014.3001.5482
​ 目录
继承的概念
继承定义
定义格式
继承关系和访问限定符 继承基类成员访问方式的变化 基类和派生类对象赋值转换
继承中的作用域
派生类的默认成员函数
继承与友元 继承与静态成员 复杂的菱形继承及菱形虚拟继承 虚拟继承解决数据冗余和二义性的原理 继承的总结和反思
继承和组合 前言 💬 hello! 各位铁子们大家好哇。
今日更新了继承的相关内容
🎉 欢迎大家关注🔍点赞👍收藏⭐️留言📝
继承的概念 继承(inheritance)机制是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生新的类，称派生类。继承呈现了面向对象程序设计的层次结构，体现了由简单到复杂的认知过程。以前我们接触的复用都是函数复用，继承是类设计层次的复用。
继承后父类的Person的成员（成员函数&#43;成员变量）都会变成子类的一部分。 继承定义 定义格式 Person是父类，也称作基类。Student是子类，也称作派生类。
继承关系和访问限定符 继承基类成员访问方式的变化 记忆方法：基类的私有成员，无论哪种方式继承，在派生类中都是不可见。基类其他成员在子类的访问方式，取基类成员的访问限定符和继承方式中小的一个。
在继承中，一般用公有和保护，少用私有。
总结： 基类private成员在派生类中无论以什么方式继承都是不可见的。这里的不可见是指基类的私 有成员还是被继承到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类外面 都不能去访问它。基类private成员在派生类中是不能被访问，如果基类成员不想在类外直接被访问，但需要在 派生类中能访问，就定义为protected。可以看出保护成员限定符是因继承才出现的。实际上面的表格我们进行一下总结会发现，基类的私有成员在子类都是不可见。基类的其他 成员在子类的访问方式 == Min(成员在基类的访问限定符，继承方式)，public &gt; protected &gt; private。使用关键字class时默认的继承方式是private，使用struct时默认的继承方式是public，不过 最好显示的写出继承方式。 在实际运用中一般使用都是public继承，几乎很少使用protetced/private继承，也不提倡使用protetced/private继承，因为protetced/private继承下来的成员都只能在派生类的类里面使用，实际中扩展维护性不强。 基类和派生类对象赋值转换 派生类对象可以赋值给基类对象。
注意：必须是公有继承才可以，保护和私有都不行。 public继承是is -a的关系，即每个子类对象都是一个特殊的父类对象。
派生类对象可以赋值给 基类的对象 / 基类的指针 / 基类的引用。这里有个形象的说法叫切片 或者切割。寓意把派生类中父类那部分切来赋值过去。 基类对象不能赋值给派生类对象。基类的指针或者引用可以通过强制类型转换赋值给派生类的指针或者引用。但是必须是基类 的指针是指向派生类对象时才是安全的。 切片有赋值兼容，在赋值的时候不会产生临时对象，就不需要加const。如下图，此时ref是直接指向派生类中基类的那一部分。
继承中的作用域 在继承体系中基类和派生类都有独立的作用域。子类和父类中有同名成员，子类成员将屏蔽父类对同名成员的直接访问，这种情况叫隐藏， 也叫重定义。（在子类成员函数中，可以使用 基类::基类成员 显示访问）需要注意的是如果是成员函数的隐藏，只需要函数名相同就构成隐藏。注意在实际中在继承体系里面最好不要定义同名的成员。 默认访问子类的，想要访问父类前面就得加上父类的类域。 B中的fun和A中的fun不是构成重载，因为不是在同一作用域 。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-24T14:53:32+08:00">
    <meta property="article:modified_time" content="2024-06-24T14:53:32+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】继承（定义、菱形继承、虚拟继承）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> <strong>🌈个人主页：</strong><a href="https://blog.csdn.net/qinjh_?type=blog" title="秦jh_-CSDN博客">秦jh_-CSDN博客</a><br><strong>🔥 系列专栏：</strong><a href="https://blog.csdn.net/qinjh_/category_12575764.html?spm=1001.2014.3001.5482" title="https://blog.csdn.net/qinjh_/category_12575764.html?spm=1001.2014.3001.5482">https://blog.csdn.net/qinjh_/category_12575764.html?spm=1001.2014.3001.5482</a></p> 
<p> <img alt="9efbcbc3d25747719da38c01b3fa9b4f.gif" src="https://images2.imgbox.com/de/ff/QCQ5Igqp_o.gif">​ </p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">继承的概念</a></p> 
<p id="%E7%BB%A7%E6%89%BF%E5%AE%9A%E4%B9%89-toc" style="margin-left:0px;"><a href="#%E7%BB%A7%E6%89%BF%E5%AE%9A%E4%B9%89" rel="nofollow">继承定义</a></p> 
<p id="%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F-toc" style="margin-left:40px;"><a href="#%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F" rel="nofollow">定义格式</a></p> 
<p id="%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%92%8C%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6%C2%A0-toc" style="margin-left:40px;"><a href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%92%8C%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6%C2%A0" rel="nofollow">继承关系和访问限定符 </a></p> 
<p id="%E7%BB%A7%E6%89%BF%E5%9F%BA%E7%B1%BB%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8F%98%E5%8C%96%C2%A0-toc" style="margin-left:40px;"><a href="#%E7%BB%A7%E6%89%BF%E5%9F%BA%E7%B1%BB%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8F%98%E5%8C%96%C2%A0" rel="nofollow">继承基类成员访问方式的变化 </a></p> 
<p id="%C2%A0%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC%E8%BD%AC%E6%8D%A2-toc" style="margin-left:0px;"><a href="#%C2%A0%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC%E8%BD%AC%E6%8D%A2" rel="nofollow"> 基类和派生类对象赋值转换</a></p> 
<p id="%C2%A0%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F-toc" style="margin-left:0px;"><a href="#%C2%A0%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F" rel="nofollow"> 继承中的作用域</a></p> 
<p id="%C2%A0%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#%C2%A0%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0" rel="nofollow"> 派生类的默认成员函数</a></p> 
<p id="%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8F%8B%E5%85%83%C2%A0-toc" style="margin-left:0px;"><a href="#%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8F%8B%E5%85%83%C2%A0" rel="nofollow">继承与友元 </a></p> 
<p id="%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%C2%A0-toc" style="margin-left:0px;"><a href="#%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%C2%A0" rel="nofollow">继承与静态成员 </a></p> 
<p id="%E5%A4%8D%E6%9D%82%E7%9A%84%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E5%8F%8A%E8%8F%B1%E5%BD%A2%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%A4%8D%E6%9D%82%E7%9A%84%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E5%8F%8A%E8%8F%B1%E5%BD%A2%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF%C2%A0" rel="nofollow">复杂的菱形继承及菱形虚拟继承 </a></p> 
<p id="%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%86%97%E4%BD%99%E5%92%8C%E4%BA%8C%E4%B9%89%E6%80%A7%E7%9A%84%E5%8E%9F%E7%90%86%C2%A0-toc" style="margin-left:40px;"><a href="#%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%86%97%E4%BD%99%E5%92%8C%E4%BA%8C%E4%B9%89%E6%80%A7%E7%9A%84%E5%8E%9F%E7%90%86%C2%A0" rel="nofollow">虚拟继承解决数据冗余和二义性的原理 </a></p> 
<p id="%C2%A0%E7%BB%A7%E6%89%BF%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E5%8F%8D%E6%80%9D-toc" style="margin-left:0px;"><a href="#%C2%A0%E7%BB%A7%E6%89%BF%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E5%8F%8D%E6%80%9D" rel="nofollow"> 继承的总结和反思</a></p> 
<p id="%E7%BB%A7%E6%89%BF%E5%92%8C%E7%BB%84%E5%90%88%C2%A0-toc" style="margin-left:40px;"><a href="#%E7%BB%A7%E6%89%BF%E5%92%8C%E7%BB%84%E5%90%88%C2%A0" rel="nofollow">继承和组合 </a></p> 
<hr id="hr-toc"> 
<h2 id="%E5%89%8D%E8%A8%80">前言</h2> 
<blockquote> 
 <p>    <strong>💬 hello! 各位铁子们大家好哇。</strong></p> 
 <p><strong>             今日更新了继承的相关内容</strong><br>     <strong>🎉 欢迎大家关注🔍点赞👍收藏⭐️留言📝</strong></p> 
</blockquote> 
<h2 id="%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5">继承的概念</h2> 
<p>继承(inheritance)机制是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生新的类，称派生类。继承呈现了面向对象程序设计的层次结构，体现了由简单到复杂的认知过程。以前我们接触的复用都是函数复用，<strong>继承是类设计层次的复用。</strong></p> 
<p><img alt="" height="1008" src="https://images2.imgbox.com/b9/7c/vWrfqBxe_o.png" width="762"><img alt="" height="346" src="https://images2.imgbox.com/84/7f/pdixGe6V_o.png" width="737"></p> 
<blockquote> 
 <p>继承后父类的Person的成员（成员函数+成员变量）都会变成子类的一部分。 </p> 
</blockquote> 
<h2 id="%E7%BB%A7%E6%89%BF%E5%AE%9A%E4%B9%89">继承定义</h2> 
<h3 id="%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F">定义格式</h3> 
<p><img alt="" height="347" src="https://images2.imgbox.com/c8/f4/PM4RDUr2_o.png" width="609"></p> 
<blockquote> 
 <p> Person是父类，也称作基类。Student是子类，也称作派生类。</p> 
</blockquote> 
<h3 id="%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%92%8C%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6%C2%A0">继承关系和访问限定符 </h3> 
<p><img alt="" height="612" src="https://images2.imgbox.com/3f/f9/qXtBgqTe_o.png" width="531"></p> 
<h3 id="%E7%BB%A7%E6%89%BF%E5%9F%BA%E7%B1%BB%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8F%98%E5%8C%96%C2%A0">继承基类成员访问方式的变化 </h3> 
<p><img alt="" height="443" src="https://images2.imgbox.com/d6/f0/DdItnodL_o.png" width="1096"></p> 
<blockquote> 
 <p>记忆方法：基类的私有成员，无论哪种方式继承，在派生类中都是不可见。基类其他成员在子类的访问方式，取基类成员的访问限定符和继承方式中小的一个。</p> 
 <p>在继承中，一般用公有和保护，少用私有。</p> 
</blockquote> 
<p><strong>总结： </strong></p> 
<ol><li><strong>基类private成员在派生类中无论以什么方式继承都是不可见的。</strong>这里的不可见是指基类的私 有成员还是被继承到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类外面 都不能去访问它。</li><li>基类private成员在派生类中是不能被访问，如果基类成员<strong>不想在类外直接被访问，但需要在 派生类中能访问，就定义为protected</strong>。可以看出保护成员限定符是因继承才出现的。</li><li>实际上面的表格我们进行一下总结会发现，基类的私有成员在子类都是不可见。<strong>基类的其他 成员在子类的访问方式 == Min(成员在基类的访问限定符，继承方式)，public &gt; protected &gt; private。</strong></li><li>使用关键字<strong>class</strong>时默认的继承方式是<strong>private</strong>，使用<strong>struct</strong>时默认的继承方式是<strong>public</strong>，不过 最好显示的写出继承方式。</li><li> 在实际运用中一般使用都是public继承，几乎很少使用protetced/private继承，也不提倡使用protetced/private继承，因为protetced/private继承下来的成员都只能在派生类的类里面使用，实际中扩展维护性不强。</li></ol> 
<h2 id="%C2%A0%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC%E8%BD%AC%E6%8D%A2"> 基类和派生类对象赋值转换</h2> 
<p><img alt="" height="265" src="https://images2.imgbox.com/55/49/VHhdGrao_o.png" width="362"> <img alt="" height="250" src="https://images2.imgbox.com/1a/53/hJboy9pM_o.png" width="565"></p> 
<blockquote> 
 <p>派生类对象可以赋值给基类对象。</p> 
 <p>注意：必须是公有继承才可以，保护和私有都不行。 </p> 
 <p>public继承是<strong>is -a</strong>的关系，即每个子类对象都是一个特殊的父类对象。</p> 
</blockquote> 
<ul><li>派生类对象可以赋值给 基类的对象 / 基类的指针 / 基类的引用。这里有个形象的说法叫切片 或者切割。寓意把派生类中父类那部分切来赋值过去。 </li><li>基类对象不能赋值给派生类对象。</li><li>基类的指针或者引用可以通过强制类型转换赋值给派生类的指针或者引用。但是必须是基类 的指针是指向派生类对象时才是安全的。</li></ul> 
<p><img alt="" height="430" src="https://images2.imgbox.com/cd/a7/H0ftaw1f_o.png" width="883"></p> 
<blockquote> 
 <p><img alt="" height="210" src="https://images2.imgbox.com/38/49/egsRwMHX_o.png" width="487"></p> 
 <p>切片有赋值兼容，在赋值的时候不会产生临时对象，就不需要加const。如下图，此时ref是直接指向派生类中基类的那一部分。</p> 
 <p><img alt="" height="450" src="https://images2.imgbox.com/aa/ce/uZZClL26_o.png" width="484"></p> 
</blockquote> 
<h2 id="%C2%A0%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"> 继承中的作用域</h2> 
<ol><li>在继承体系中基类和派生类都有独立的作用域。</li><li>子类和父类中有同名成员，子类成员将屏蔽父类对同名成员的直接访问，这种情况叫隐藏， 也叫重定义。（在子类成员函数中，可以使用 <strong>基类::基类成员 </strong>显示访问）</li><li>需要注意的是如果是<strong>成员函数的隐藏</strong>，只需要<strong>函数名相同</strong>就构成隐藏。</li><li>注意在实际中在继承体系里面最好不要定义同名的成员。</li></ol> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/6a/2f/XsHFCpbe_o.png" width="729"><img alt="" height="226" src="https://images2.imgbox.com/56/ff/uOiMGF0q_o.png" width="461"> </p> 
<blockquote> 
 <p>默认访问子类的，想要访问父类前面就得加上父类的类域。 </p> 
</blockquote> 
<p><img alt="" height="1045" src="https://images2.imgbox.com/9c/b9/Xmx8OYrZ_o.png" width="850"></p> 
<blockquote> 
 <p>B中的fun和A中的fun不是构成重载，因为不是在同一作用域 。</p> 
 <p>B中的fun和A中的fun构成隐藏，成员函数满足函数名相同就构成隐藏。</p> 
 <p>想在子类对象调用父类方法也要加上类域。 </p> 
</blockquote> 
<h2 id="%C2%A0%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"> 派生类的默认成员函数</h2> 
<p><img alt="" height="1043" src="https://images2.imgbox.com/6a/38/Hm2FCMSC_o.png" width="919"></p> 
<blockquote> 
 <p>上方中父类有默认构造，子类会调用父类的默认构造。 </p> 
</blockquote> 
<p><img alt="" height="944" src="https://images2.imgbox.com/80/4e/5Gpl2aQU_o.png" width="868"></p> 
<blockquote> 
 <p>上图父类没有默认构造，此时子类如果不显示调用，就会报错。显示调用如下：</p> 
 <p><img alt="" height="963" src="https://images2.imgbox.com/83/16/WvU6zme3_o.png" width="860"></p> 
</blockquote> 
<blockquote> 
 <ol><li> 派生类的构造函数必须调用基类的构造函数初始化基类的那一部分成员。如果基类没有默认 的构造函数，则必须在派生类构造函数的初始化列表阶段显示调用。</li><li>派生类的拷贝构造函数必须调用基类的拷贝构造完成基类的拷贝初始化。</li><li> 派生类的operator=必须要调用基类的operator=完成基类的复制。</li><li> 派生类的析构函数会在被调用完成后<strong>自动调用基类的析构函数</strong>清理基类成员。因为这样才能 保证派生类对象先清理派生类成员再清理基类成员的顺序。</li><li> 派生类对象初始化先调用基类构造再调派生类构造。</li><li>派生类对象析构清理先调用派生类析构再调基类的析构。</li><li> 因为后续一些场景析构函数需要构成重写，重写的条件之一是函数名相同(这个我们后面会讲 解)。那么编译器会对析构函数名进行特殊处理，处理成destrutor()，所以父类析构函数不加 virtual的情况下，子类析构函数和父类析构函数构成隐藏关系。</li></ol> 
</blockquote> 
<p><img alt="" height="421" src="https://images2.imgbox.com/81/0b/tlzZH0Lu_o.png" width="1200"></p> 
<blockquote> 
 <p>构造是先父后子，析构是先子后父。</p> 
</blockquote> 
<p>成员函数代码：</p> 
<pre><code class="language-cpp">class Person
{
public:
	Person(const char* name = "peter")
		: _name(name)
	{
		cout &lt;&lt; "Person()" &lt;&lt; endl;
	}

	Person(const Person&amp; p)
		: _name(p._name)
	{
			cout &lt;&lt; "Person(const Person&amp; p)" &lt;&lt; endl;
	}

	Person&amp; operator=(const Person&amp; p)
	{
		cout &lt;&lt; "Person operator=(const Person&amp; p)" &lt;&lt; endl;
		if (this != &amp;p)
			_name = p._name;
		return *this;
	}

	~Person()
	{
		cout &lt;&lt; "~Person()" &lt;&lt; endl;
	}

protected:
	string _name; // 姓名
};

class Student : public Person
{
public:
	Student(const char* name, int num)
		: Person(name)
		, _num(num)
	{
		cout &lt;&lt; "Student()" &lt;&lt; endl;
	}

	Student(const Student&amp; s)
		: Person(s)  //传s即可，因为会自动进行切片
		, _num(s._num)
	{
		cout &lt;&lt; "Student(const Student&amp; s)" &lt;&lt; endl;
	}

	Student&amp; operator = (const Student&amp; s)
	{
		cout &lt;&lt; "Student&amp; operator= (const Student&amp; s)" &lt;&lt; endl;
		if (this != &amp;s)
		{
			Person::operator =(s);  //构成隐藏，需要指定类域，不然会发生无限递归
			_num = s._num; 
		}
		return *this;
	}

	~Student()
	{
		cout &lt;&lt; "~Student()" &lt;&lt; endl;  //子类析构调用完成后会自动调用父类析构
	}									//所以这里不需要自己调用
protected:
	int _num; //学号
};</code></pre> 
<blockquote> 
 <p>如果没有写默认成员函数，子类成员的内置类型不做处理，自定义类型会去调用他的默认构造。而父类成员可以看作是一个自定义类型成员，会回去父类找默认构造函数。</p> 
</blockquote> 
<h2 id="%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8F%8B%E5%85%83%C2%A0">继承与友元 </h2> 
<p><strong>友元关系不能继承</strong>，也就是说基类友元不能访问子类私有和保护成员 。</p> 
<p><img alt="" height="908" src="https://images2.imgbox.com/de/ce/tDHsIVi6_o.png" width="1112"></p> 
<h2 id="%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%C2%A0">继承与静态成员 </h2> 
<p><strong>基类定义了static静态成员，则整个继承体系里面只有一个这样的成员。</strong>无论派生出多少个子 类，都只有一个static成员实例 。 </p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/c0/cc/rynapnme_o.png" width="753"><img alt="" height="228" src="https://images2.imgbox.com/d5/de/T8SE6cvX_o.png" width="410"> </p> 
<blockquote> 
 <p>静态成员是共用的，他们的地址都是一样的。 </p> 
</blockquote> 
<h2 id="%E5%A4%8D%E6%9D%82%E7%9A%84%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E5%8F%8A%E8%8F%B1%E5%BD%A2%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF%C2%A0">复杂的菱形继承及菱形虚拟继承 </h2> 
<p><strong>单继承：一个子类只有一个直接父类时称这个继承关系为单继承 </strong></p> 
<p><img alt="" height="506" src="https://images2.imgbox.com/db/b5/vL6EVHuj_o.png" width="778"></p> 
<p><strong>多继承：一个子类有两个或以上直接父类时称这个继承关系为多继承 </strong></p> 
<p><img alt="" height="418" src="https://images2.imgbox.com/2a/45/Jc46KMyt_o.png" width="882"></p> 
<p><strong>菱形继承：菱形继承是多继承的一种特殊情况。 </strong></p> 
<p><img alt="" height="502" src="https://images2.imgbox.com/fa/d5/3RjJ6fR1_o.png" width="836"></p> 
<hr> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/cc/f4/Rjytlh9X_o.png" width="1038"></p> 
<blockquote> 
 <p>上方虽然显示指定访问哪个父类的成员解决了二义性问题，但是数据冗余问题仍无法解决。这时就需要使用虚拟继承：</p> 
 <p><img alt="" height="489" src="https://images2.imgbox.com/2c/ab/Xdkg1zFn_o.png" width="805"></p> 
 <p><img alt="" height="230" src="https://images2.imgbox.com/ed/72/tZgZEm1i_o.png" width="402"></p> 
 <p>此时，_name就只有一份了。</p> 
 <p>注意：virtual是加在腰部的类的。</p> 
 <p>虚拟继承可以解决菱形继承的二义性和数据冗余的问题。如上面的继承关系，在Student和 Teacher的继承Person时使用虚拟继承，即可解决问题。</p> 
</blockquote> 
<h3 id="%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%86%97%E4%BD%99%E5%92%8C%E4%BA%8C%E4%B9%89%E6%80%A7%E7%9A%84%E5%8E%9F%E7%90%86%C2%A0">虚拟继承解决数据冗余和二义性的原理 </h3> 
<p>我们给出了一个简化的菱形继承继承体系，再借助内存窗口观察对象成员的模型 </p> 
<pre><code class="language-cpp">class A
{
public:
	int _a;
};

class B : public A
//class B : virtual public A
{
public:
	int _b;
};

class C : public A
//class C : virtual public A
{
public:
	int _c;
};

class D : public B, public C
{
public:
	int _d;
};

int main()
{
	D d;
	d.B::_a = 1;
	d.C::_a = 2;
	d._b = 3;
	d._c = 4; 
	d._d = 5;
	return 0;
}</code></pre> 
<p>下图是菱形继承的内存对象成员模型：</p> 
<p><img alt="" height="424" src="https://images2.imgbox.com/39/c8/9RNestQq_o.png" width="748"></p> 
<p>下图是菱形虚拟继承的内存对象成员模型:</p> 
<p><img alt="" height="353" src="https://images2.imgbox.com/91/9c/iekVUAOy_o.png" width="858"><img alt="" height="506" src="https://images2.imgbox.com/53/f7/iNYvueCb_o.png" width="388"></p> 
<blockquote> 
 <p>D对象中将A放到的了对象组成的最下面，这个A同时属于B和C。那么B和C如何去找到公共的A呢？这里是通过了B和C的两个指针，指向的一张表。这两个指针叫虚基表指针，A叫做虚基类，这两个表叫虚基表。虚基表中存的偏移量。通过偏移量可以找到下面的A。</p> 
</blockquote> 
<p><img alt="" height="315" src="https://images2.imgbox.com/89/8f/rMISBIfL_o.png" width="480"></p> 
<blockquote> 
 <p>上图也是菱形继承，virtual要放在继承了公共基类的地方。 </p> 
</blockquote> 
<h2 id="%C2%A0%E7%BB%A7%E6%89%BF%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E5%8F%8D%E6%80%9D"> 继承的总结和反思</h2> 
<p>一般不建议设计出多继承，一定不要设 计出菱形继承。否则在复杂度及性能上都有问题。 </p> 
<h3 id="%E7%BB%A7%E6%89%BF%E5%92%8C%E7%BB%84%E5%90%88%C2%A0">继承和组合 </h3> 
<p><img alt="" height="627" src="https://images2.imgbox.com/b1/c1/wr0s0NUk_o.png" width="283"></p> 
<ul><li>public继承是一种is-a的关系。也就是说每个派生类对象都是一个基类对象。</li><li>组合是一种has-a的关系。假设B组合了A，每个B对象中都有一个A对象。 </li><li>优先使用对象组合，而不是类继承。</li><li>继承允许你根据基类的实现来定义派生类的实现。这种通过生成派生类的复用通常被称为白箱复用。术语“白箱”是相对可视性而言：在继承方式中，基类的 内部细节对子类可见 。继承一定程度破坏了基类的封装，基类的改变，对派生类有很大的影响。派生类和基类间的依赖关系很强，耦合度高。</li><li>对象组合是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或组合对象来获得。对象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为黑箱复用，因为对象的内部细节是不可见的。对象只以“黑箱”的形式出现。 组合类之间没有很强的依赖关系，耦合度低。优先使用对象组合有助于你保持每个类被封装。</li></ul> 
<blockquote> 
 <p>适合is-a关系，就用继承</p> 
 <p>适合has-a关系，就用组合。</p> 
 <p>is-a和has-a的关系都可以，就用组合。</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ba73c3b406f4ef21dad49bf5c7034229/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">alibaba easyexcel 导出excel使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6f11dc8d9f85ad430cffe74b5323e647/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python篇-pywinauto使用-持续更新</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>