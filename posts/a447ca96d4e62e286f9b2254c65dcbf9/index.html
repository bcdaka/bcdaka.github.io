<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>离线安装docker、docker_redis_加载离线docker，这操作真香 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/a447ca96d4e62e286f9b2254c65dcbf9/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="离线安装docker、docker_redis_加载离线docker，这操作真香">
  <meta property="og:description" content="一、离线安装docker 1、下载离线包 https://link.zhihu.com/?target=https%3A//download.docker.com/linux/static/stable/x86_64/
docker-18.09.8.tgz
2、安装docker 复制docker-18.09.8.tgz到 /usr/bin下（usr/bin是环境变量目录，在路径下可以直接运行docker命令） 解压 tar xvf docker-18.09.8.tgz
ls -l docker cp docker/* /usr/bin
rm -rf docker docker-18.09.8.tgz 配置docker服务
vim /etc/systemd/system/docker.service 添加 [Unit]
Description=Docker Application Container Engine
Documentation=https://docs.docker.com
After=network-online.target firewalld.service
Wants=network-online.target
[Service]
Type=notify
ExecStart=/usr/bin/dockerd
ExecReload=/bin/kill -s HUP $MAINPID
LimitNOFILE=infinity
LimitNPROC=infinity
TimeoutStartSec=0
Delegate=yes
KillMode=process
Restart=on-failure
StartLimitBurst=3
StartLimitInterval=60s
[Install]
WantedBy=multi-user.target
赋执行权限
chmod &#43;x /etc/systemd/system/docker.service
systemctl daemon-reload
3. docker 命令 开机启动 systemctl enable docker.service
启动docker systemctl start docker
docker状态 systemctl status docker">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-07T02:11:39+08:00">
    <meta property="article:modified_time" content="2024-04-07T02:11:39+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">离线安装docker、docker_redis_加载离线docker，这操作真香</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="docker_4"></a>一、离线安装docker</h3> 
<h4><a id="1_7"></a>1、下载离线包</h4> 
<blockquote> 
 <p>https://link.zhihu.com/?target=https%3A//download.docker.com/linux/static/stable/x86_64/</p> 
</blockquote> 
<p>docker-18.09.8.tgz</p> 
<h4><a id="2docker_21"></a>2、安装docker</h4> 
<blockquote> 
 <h2><a id="docker18098tgz_usrbinusrbindocker_26"></a>复制docker-18.09.8.tgz到 /usr/bin下（usr/bin是环境变量目录，在路径下可以直接运行docker命令）</h2> 
 <h2><a id="_29"></a>解压</h2> 
 <p>tar xvf docker-18.09.8.tgz</p> 
 <h2><a id="ls_l_docker_35"></a>ls -l docker</h2> 
 <p>cp docker/* /usr/bin</p> 
 <h2><a id="rm_rf_docker_docker18098tgz_41"></a>rm -rf docker docker-18.09.8.tgz</h2> 
</blockquote> 
<p><img src="https://images2.imgbox.com/07/0e/MX2BbKVI_o.png" alt=""></p> 
<p>配置docker服务</p> 
<h2><a id="vim_etcsystemdsystemdockerservice_53"></a>vim /etc/systemd/system/docker.service</h2> 
<blockquote> 
 <h2><a id="_58"></a>添加</h2> 
 <p>[Unit]</p> 
 <p>Description=Docker Application Container Engine</p> 
 <p>Documentation=https://docs.docker.com</p> 
 <p>After=network-online.target firewalld.service</p> 
 <p>Wants=network-online.target</p> 
 <p>[Service]</p> 
 <p>Type=notify</p> 
 <p>ExecStart=/usr/bin/dockerd</p> 
 <p>ExecReload=/bin/kill -s HUP $MAINPID</p> 
 <p>LimitNOFILE=infinity</p> 
 <p>LimitNPROC=infinity</p> 
 <p>TimeoutStartSec=0</p> 
 <p>Delegate=yes</p> 
 <p>KillMode=process</p> 
 <p>Restart=on-failure</p> 
 <p>StartLimitBurst=3</p> 
 <p>StartLimitInterval=60s</p> 
 <p>[Install]</p> 
 <p>WantedBy=multi-user.target</p> 
</blockquote> 
<p>赋执行权限</p> 
<blockquote> 
 <p>chmod +x /etc/systemd/system/docker.service</p> 
 <p>systemctl daemon-reload</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/11/e4/XCT0l7i5_o.png" alt=""></p> 
<h4><a id="3_docker__138"></a><strong><strong><strong>3. docker 命令</strong></strong></strong></h4> 
<blockquote> 
 <h2><a id="_143"></a>开机启动</h2> 
 <p>systemctl enable docker.service</p> 
 <h2><a id="docker_149"></a>启动docker</h2> 
 <p>systemctl start docker</p> 
 <h2><a id="docker_155"></a>docker状态</h2> 
 <p>systemctl status docker</p> 
 <h2><a id="docker_161"></a>重启docker服务</h2> 
 <p>systemctl restart docker</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/31/f7/Dpn5MXMw_o.png" alt=""></p> 
<h3><a id="dockercompose__173"></a><strong><strong>二、docker-compose 离线安装</strong></strong></h3> 
<h4><a id="1__176"></a><strong><strong><strong>1. 下载离线包</strong></strong></strong></h4> 
<ul><li>下载离线包</li></ul> 
<p><a href="" rel="nofollow">https://github.com/docker/compose/releases</a></p> 
<ul><li>下载的最新版本（这里要展开才能看到）</li></ul> 
<p>docker-compose-linux-x86_64</p> 
<h4><a id="2_dockercompose_191"></a><strong><strong><strong>2. 安装docker-compose</strong></strong></strong></h4> 
<ul><li>上传安装包</li></ul> 
<blockquote> 
 <h2><a id="dockercompose__usrlocalbin_199"></a>改名为docker-compose 复制到 /usr/local/bin/下</h2> 
 <p>cp -f ./docker-compose-linux-x86_64 /usr/local/bin/docker-compose</p> 
 <h2><a id="_205"></a>赋执行权限</h2> 
 <p>chmod +x /usr/local/bin/docker-compose</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/c3/40/q0qnOb6k_o.png" alt=""></p> 
<h3><a id="_docker__217"></a><strong><strong><strong>三、 docker 离线镜像</strong></strong></strong></h3> 
<h4><a id="1_220"></a><strong>1、在有网络的环境下下载镜像</strong></h4> 
<h2><a id="redis__223"></a>redis 镜像</h2> 
<blockquote> 
 <p>docker pull redis:5.0.14</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/f8/89/XxVhZWmV_o.png" alt=""></p> 
<p>2、导出镜像</p> 
<blockquote> 
 <p>docker save redis:5.0.14 -o redis5014.tar</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/0b/71/nkNwY5Yt_o.png" alt=""></p> 
<h4><a id="2_251"></a><strong>2、上传离线环境导入镜像</strong></h4> 
<blockquote> 
 <p>docker load -i redis5014.tar</p> 
</blockquote> 
<h4><a id="3_262"></a>3、查看镜像</h4> 
<blockquote> 
 <p>docker images</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/bc/c1/qc5STFyj_o.png" alt=""></p> 
<h4><a id="4redis_276"></a>4、创建redis管理目录，方便后期管理</h4> 
<p>mkdir data</p> 
<h4><a id="5redisconf_282"></a>5、编辑redis.conf配置文件</h4> 
<p>vim redis.conf</p> 
<blockquote> 
 <h2><a id="Redis_configuration_file_example_290"></a>Redis configuration file example.</h2> 
 <p>#<br>  # Note that in order to read the configuration file, Redis must be<br>  # started with the file path as first argument:<br>  #<br>  # ./redis-server /path/to/redis.conf<br>  ​<br>  # Note on units: when memory size is needed, it is possible to specify<br>  # it in the usual form of 1k 5GB 4M and so forth:<br>  #<br>  # 1k =&gt; 1000 bytes<br>  # 1kb =&gt; 1024 bytes<br>  # 1m =&gt; 1000000 bytes<br>  # 1mb =&gt; 1024*1024 bytes<br>  # 1g =&gt; 1000000000 bytes<br>  # 1gb =&gt; 1024*1024*1024 bytes<br>  #<br>  # units are case insensitive so 1GB 1Gb 1gB are all the same.<br>  ​<br>  ################################## INCLUDES ###################################<br>  ​<br>  # Include one or more other config files here.  This is useful if you<br>  # have a standard template that goes to all Redis servers but also need<br>  # to customize a few per-server settings.  Include files can include<br>  # other files, so use this wisely.<br>  #<br>  # Notice option “include” won’t be rewritten by command “CONFIG REWRITE”<br>  # from admin or Redis Sentinel. Since Redis always uses the last processed<br>  # line as value of a configuration directive, you’d better put includes<br>  # at the beginning of this file to avoid overwriting config change at runtime.<br>  #<br>  # If instead you are interested in using includes to override configuration<br>  # options, it is better to use include as the last line.<br>  #<br>  # include /path/to/local.conf<br>  # include /path/to/other.conf<br>  ​<br>  ################################## MODULES #####################################<br>  ​<br>  # Load modules at startup. If the server is not able to load modules<br>  # it will abort. It is possible to use multiple loadmodule directives.<br>  #<br>  # loadmodule /path/to/my_module.so<br>  # loadmodule /path/to/other_module.so<br>  ​<br>  ################################## NETWORK #####################################<br>  ​<br>  # By default, if no “bind” configuration directive is specified, Redis listens<br>  # for connections from all the network interfaces available on the server.<br>  # It is possible to listen to just one or multiple selected interfaces using<br>  # the “bind” configuration directive, followed by one or more IP addresses.<br>  #<br>  # Examples:<br>  #<br>  # bind 192.168.1.100 10.0.0.1<br>  # bind 127.0.0.1 ::1<br>  #<br>  # ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the<br>  # internet, binding to all the interfaces is dangerous and will expose the<br>  # instance to everybody on the internet. So by default we uncomment the<br>  # following bind directive, that will force Redis to listen only into<br>  # the IPv4 lookback interface address (this means Redis will be able to<br>  # accept connections only from clients running into the same computer it<br>  # is running).<br>  #<br>  # IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES<br>  # JUST COMMENT THE FOLLOWING LINE.<br>  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br>  # bind 127.0.0.1<br>  ​<br>  # Protected mode is a layer of security protection, in order to avoid that<br>  # Redis instances left open on the internet are accessed and exploited.<br>  #<br>  # When protected mode is on and if:<br>  #<br>  # 1) The server is not binding explicitly to a set of addresses using the<br>  #    “bind” directive.<br>  # 2) No password is configured.<br>  #<br>  # The server only accepts connections from clients connecting from the<br>  # IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain<br>  # sockets.<br>  #<br>  # By default protected mode is enabled. You should disable it only if<br>  # you are sure you want clients from other hosts to connect to Redis<br>  # even if no authentication is configured, nor a specific set of interfaces<br>  # are explicitly listed using the “bind” directive.<br>  protected-mode no<br>  ​<br>  # Accept connections on the specified port, default is 6379 (IANA #815344).<br>  # If port 0 is specified Redis will not listen on a TCP socket.<br>  port 6379<br>  ​<br>  # TCP listen() backlog.<br>  #<br>  # In high requests-per-second environments you need an high backlog in order<br>  # to avoid slow clients connections issues. Note that the Linux kernel<br>  # will silently truncate it to the value of /proc/sys/net/core/somaxconn so<br>  # make sure to raise both the value of somaxconn and tcp_max_syn_backlog<br>  # in order to get the desired effect.<br>  tcp-backlog 511<br>  ​<br>  # Unix socket.<br>  #<br>  # Specify the path for the Unix socket that will be used to listen for<br>  # incoming connections. There is no default, so Redis will not listen<br>  # on a unix socket when not specified.<br>  #<br>  # unixsocket /tmp/redis.sock<br>  # unixsocketperm 700<br>  ​<br>  # Close the connection after a client is idle for N seconds (0 to disable)<br>  timeout 0<br>  ​<br>  # TCP keepalive.<br>  #<br>  # If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence<br>  # of communication. This is useful for two reasons:<br>  #<br>  # 1) Detect dead peers.<br>  # 2) Take the connection alive from the point of view of network<br>  #    equipment in the middle.<br>  #<br>  # On Linux, the specified value (in seconds) is the period used to send ACKs.<br>  # Note that to close the connection the double of the time is needed.<br>  # On other kernels the period depends on the kernel configuration.<br>  #<br>  # A reasonable value for this option is 300 seconds, which is the new<br>  # Redis default starting with Redis 3.2.1.<br>  tcp-keepalive 300<br>  ​<br>  ################################# GENERAL #####################################<br>  ​<br>  # By default Redis does not run as a daemon. Use ‘yes’ if you need it.<br>  # Note that Redis will write a pid file in /var/run/redis.pid when daemonized.<br>  daemonize yes<br>  ​<br>  # If you run Redis from upstart or systemd, Redis can interact with your<br>  # supervision tree. Options:<br>  #   supervised no      - no supervision interaction<br>  #   supervised upstart - signal upstart by putting Redis into SIGSTOP mode<br>  #   supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET<br>  #   supervised auto    - detect upstart or systemd method based on<br>  #                        UPSTART_JOB or NOTIFY_SOCKET environment variables<br>  # Note: these supervision methods only signal “process is ready.”<br>  #       They do not enable continuous liveness pings back to your supervisor.<br>  supervised no<br>  ​<br>  # If a pid file is specified, Redis writes it where specified at startup<br>  # and removes it at exit.<br>  #<br>  # When the server runs non daemonized, no pid file is created if none is<br>  # specified in the configuration. When the server is daemonized, the pid file<br>  # is used even if not specified, defaulting to “/var/run/redis.pid”.<br>  #<br>  # Creating a pid file is best effort: if Redis is not able to create it<br>  # nothing bad happens, the server will start and run normally.<br>  pidfile /var/run/redis_6379.pid<br>  ​<br>  # Specify the server verbosity level.<br>  # This can be one of:<br>  # debug (a lot of information, useful for development/testing)<br>  # verbose (many rarely useful info, but not a mess like the debug level)<br>  # notice (moderately verbose, what you want in production probably)<br>  # warning (only very important / critical messages are logged)<br>  loglevel notice<br>  ​<br>  # Specify the log file name. Also the empty string can be used to force<br>  # Redis to log on the standard output. Note that if you use standard<br>  # output for logging but daemonize, logs will be sent to /dev/null<br>  logfile “”<br>  ​<br>  # To enable logging to the system logger, just set ‘syslog-enabled’ to yes,<br>  # and optionally update the other syslog parameters to suit your needs.<br>  # syslog-enabled no<br>  ​<br>  # Specify the syslog identity.<br>  # syslog-ident redis<br>  ​<br>  # Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.<br>  # syslog-facility local0<br>  ​<br>  # Set the number of databases. The default database is DB 0, you can select<br>  # a different one on a per-connection basis using SELECT where<br>  # dbid is a number between 0 and ‘databases’-1<br>  databases 16<br>  ​<br>  # By default Redis shows an ASCII art logo only when started to log to the<br>  # standard output and if the standard output is a TTY. Basically this means<br>  # that normally a logo is displayed only in interactive sessions.<br>  #<br>  # However it is possible to force the pre-4.0 behavior and always show a<br>  # ASCII art logo in startup logs by setting the following option to yes.<br>  always-show-logo yes<br>  ​<br>  ################################ SNAPSHOTTING  ################################<br>  #<br>  # Save the DB on disk:<br>  #<br>  #   save <br>  #<br>  #   Will save the DB if both the given number of seconds and the given<br>  #   number of write operations against the DB occurred.<br>  #<br>  #   In the example below the behaviour will be to save:<br>  #   after 900 sec (15 min) if at least 1 key changed<br>  #   after 300 sec (5 min) if at least 10 keys changed<br>  #   after 60 sec if at least 10000 keys changed<br>  #<br>  #   Note: you can disable saving completely by commenting out all “save” lines.<br>  #<br>  #   It is also possible to remove all the previously configured save<br>  #   points by adding a save directive with a single empty string argument<br>  #   like in the following example:<br>  #<br>  #   save “”<br>  ​<br>  save 900 1<br>  save 300 10<br>  save 60 10000<br>  ​<br>  # By default Redis will stop accepting writes if RDB snapshots are enabled<br>  # (at least one save point) and the latest background save failed.<br>  # This will make the user aware (in a hard way) that data is not persisting<br>  # on disk properly, otherwise chances are that no one will notice and some<br>  # disaster will happen.<br>  #<br>  # If the background saving process will start working again Redis will<br>  # automatically allow writes again.<br>  #<br>  # However if you have setup your proper monitoring of the Redis server<br>  # and persistence, you may want to disable this feature so that Redis will<br>  # continue to work as usual even if there are problems with disk,<br>  # permissions, and so forth.<br>  stop-writes-on-bgsave-error yes<br>  ​<br>  # Compress string objects using LZF when dump .rdb databases?<br>  # For default that’s set to ‘yes’ as it’s almost always a win.<br>  # If you want to save some CPU in the saving child set it to ‘no’ but<br>  # the dataset will likely be bigger if you have compressible values or keys.<br>  rdbcompression yes<br>  ​<br>  # Since version 5 of RDB a CRC64 checksum is placed at the end of the file.<br>  # This makes the format more resistant to corruption but there is a performance<br>  # hit to pay (around 10%) when saving and loading RDB files, so you can disable it<br>  # for maximum performances.<br>  #<br>  # RDB files created with checksum disabled have a checksum of zero that will<br>  # tell the loading code to skip the check.<br>  rdbchecksum yes<br>  ​<br>  # The filename where to dump the DB<br>  dbfilename dump.rdb<br>  ​<br>  # The working directory.<br>  #<br>  # The DB will be written inside this directory, with the filename specified<br>  # above using the ‘dbfilename’ configuration directive.<br>  #<br>  # The Append Only File will also be created inside this directory.<br>  #<br>  # Note that you must specify a directory here, not a file name.<br>  dir ./<br>  ​<br>  ################################# REPLICATION #################################<br>  ​<br>  # Master-Slave replication. Use slaveof to make a Redis instance a copy of<br>  # another Redis server. A few things to understand ASAP about Redis replication.<br>  #<br>  # 1) Redis replication is asynchronous, but you can configure a master to<br>  #    stop accepting writes if it appears to be not connected with at least<br>  #    a given number of slaves.<br>  # 2) Redis slaves are able to perform a partial resynchronization with the<br>  #    master if the replication link is lost for a relatively small amount of<br>  #    time. You may want to configure the replication backlog size (see the next<br>  #    sections of this file) with a sensible value depending on your needs.<br>  # 3) Replication is automatic and does not need user intervention. After a<br>  #    network partition slaves automatically try to reconnect to masters<br>  #    and resynchronize with them.<br>  #<br>  # slaveof <br>  ​<br>  # If the master is password protected (using the “requirepass” configuration<br>  # directive below) it is possible to tell the slave to authenticate before<br>  # starting the replication synchronization process, otherwise the master will<br>  # refuse the slave request.<br>  #<br>  # masterauth <br>  ​<br>  # When a slave loses its connection with the master, or when the replication<br>  # is still in progress, the slave can act in two different ways:<br>  #<br>  # 1) if slave-serve-stale-data is set to ‘yes’ (the default) the slave will<br>  #    still reply to client requests, possibly with out of date data, or the<br>  #    data set may just be empty if this is the first synchronization.<br>  #<br>  # 2) if slave-serve-stale-data is set to ‘no’ the slave will reply with<br>  #    an error “SYNC with master in progress” to all the kind of commands<br>  #    but to INFO and SLAVEOF.<br>  #<br>  slave-serve-stale-data yes<br>  ​<br>  # You can configure a slave instance to accept writes or not. Writing against<br>  # a slave instance may be useful to store some ephemeral data (because data<br>  # written on a slave will be easily deleted after resync with the master) but<br>  # may also cause problems if clients are writing to it because of a<br>  # misconfiguration.<br>  #<br>  # Since Redis 2.6 by default slaves are read-only.<br>  #<br>  # Note: read only slaves are not designed to be exposed to untrusted clients<br>  # on the internet. It’s just a protection layer against misuse of the instance.<br>  # Still a read only slave exports by default all the administrative commands<br>  # such as CONFIG, DEBUG, and so forth. To a limited extent you can improve<br>  # security of read only slaves using ‘rename-command’ to shadow all the<br>  # administrative / dangerous commands.<br>  slave-read-only yes<br>  ​<br>  # Replication SYNC strategy: disk or socket.<br>  #<br>  # -------------------------------------------------------<br>  # WARNING: DISKLESS REPLICATION IS EXPERIMENTAL CURRENTLY<br>  # -------------------------------------------------------<br>  #<br>  # New slaves and reconnecting slaves that are not able to continue the replication<br>  # process just receiving differences, need to do what is called a “full<br>  # synchronization”. An RDB file is transmitted from the master to the slaves.<br>  # The transmission can happen in two different ways:<br>  #<br>  # 1) Disk-backed: The Redis master creates a new process that writes the RDB<br>  #                 file on disk. Later the file is transferred by the parent<br>  #                 process to the slaves incrementally.<br>  # 2) Diskless: The Redis master creates a new process that directly writes the<br>  #              RDB file to slave sockets, without touching the disk at all.<br>  #<br>  # With disk-backed replication, while the RDB file is generated, more slaves<br>  # can be queued and served with the RDB file as soon as the current child producing<br>  # the RDB file finishes its work. With diskless replication instead once<br>  # the transfer starts, new slaves arriving will be queued and a new transfer<br>  # will start when the current one terminates.<br>  #<br>  # When diskless replication is used, the master waits a configurable amount of<br>  # time (in seconds) before starting the transfer in the hope that multiple slaves<br>  # will arrive and the transfer can be parallelized.<br>  #<br>  # With slow disks and fast (large bandwidth) networks, diskless replication<br>  # works better.<br>  repl-diskless-sync no<br>  ​<br>  # When diskless replication is enabled, it is possible to configure the delay<br>  # the server waits in order to spawn the child that transfers the RDB via socket<br>  # to the slaves.<br>  #<br>  # This is important since once the transfer starts, it is not possible to serve<br>  # new slaves arriving, that will be queued for the next RDB transfer, so the server<br>  # waits a delay in order to let more slaves arrive.<br>  #<br>  # The delay is specified in seconds, and by default is 5 seconds. To disable<br>  # it entirely just set it to 0 seconds and the transfer will start ASAP.<br>  repl-diskless-sync-delay 5<br>  ​<br>  # Slaves send PINGs to server in a predefined interval. It’s possible to change<br>  # this interval with the repl_ping_slave_period option. The default value is 10<br>  # seconds.<br>  #<br>  # repl-ping-slave-period 10<br>  ​<br>  # The following option sets the replication timeout for:<br>  #<br>  # 1) Bulk transfer I/O during SYNC, from the point of view of slave.<br>  # 2) Master timeout from the point of view of slaves (data, pings).<br>  # 3) Slave timeout from the point of view of masters (REPLCONF ACK pings).<br>  #<br>  # It is important to make sure that this value is greater than the value<br>  # specified for repl-ping-slave-period otherwise a timeout will be detected<br>  # every time there is low traffic between the master and the slave.<br>  #<br>  # repl-timeout 60<br>  ​<br>  # Disable TCP_NODELAY on the slave socket after SYNC?<br>  #<br>  # If you select “yes” Redis will use a smaller number of TCP packets and<br>  # less bandwidth to send data to slaves. But this can add a delay for<br>  # the data to appear on the slave side, up to 40 milliseconds with<br>  # Linux kernels using a default configuration.<br>  #<br>  # If you select “no” the delay for data to appear on the slave side will<br>  # be reduced but more bandwidth will be used for replication.<br>  #<br>  # By default we optimize for low latency, but in very high traffic conditions<br>  # or when the master and slaves are many hops away, turning this to “yes” may<br>  # be a good idea.<br>  repl-disable-tcp-nodelay no<br>  ​<br>  # Set the replication backlog size. The backlog is a buffer that accumulates<br>  # slave data when slaves are disconnected for some time, so that when a slave<br>  # wants to reconnect again, often a full resync is not needed, but a partial<br>  # resync is enough, just passing the portion of data the slave missed while<br>  # disconnected.<br>  #<br>  # The bigger the replication backlog, the longer the time the slave can be<br>  # disconnected and later be able to perform a partial resynchronization.<br>  #<br>  # The backlog is only allocated once there is at least a slave connected.<br>  #<br>  # repl-backlog-size 1mb<br>  ​<br>  # After a master has no longer connected slaves for some time, the backlog<br>  # will be freed. The following option configures the amount of seconds that<br>  # need to elapse, starting from the time the last slave disconnected, for<br>  # the backlog buffer to be freed.<br>  #<br>  # Note that slaves never free the backlog for timeout, since they may be<br>  # promoted to masters later, and should be able to correctly “partially<br>  # resynchronize” with the slaves: hence they should always accumulate backlog.<br>  #<br>  # A value of 0 means to never release the backlog.<br>  #<br>  # repl-backlog-ttl 3600<br>  ​<br>  # The slave priority is an integer number published by Redis in the INFO output.<br>  # It is used by Redis Sentinel in order to select a slave to promote into a<br>  # master if the master is no longer working correctly.<br>  #<br>  # A slave with a low priority number is considered better for promotion, so<br>  # for instance if there are three slaves with priority 10, 100, 25 Sentinel will<br>  # pick the one with priority 10, that is the lowest.<br>  #<br>  # However a special priority of 0 marks the slave as not able to perform the<br>  # role of master, so a slave with priority of 0 will never be selected by<br>  # Redis Sentinel for promotion.<br>  #<br>  # By default the priority is 100.<br>  slave-priority 100<br>  ​<br>  # It is possible for a master to stop accepting writes if there are less than<br>  # N slaves connected, having a lag less or equal than M seconds.<br>  #<br>  # The N slaves need to be in “online” state.<br>  #<br>  # The lag in seconds, that must be &lt;= the specified value, is calculated from<br>  # the last ping received from the slave, that is usually sent every second.<br>  #<br>  # This option does not GUARANTEE that N replicas will accept the write, but<br>  # will limit the window of exposure for lost writes in case not enough slaves<br>  # are available, to the specified number of seconds.<br>  #<br>  # For example to require at least 3 slaves with a lag &lt;= 10 seconds use:<br>  #<br>  # min-slaves-to-write 3<br>  # min-slaves-max-lag 10<br>  #<br>  # Setting one or the other to 0 disables the feature.<br>  #<br>  # By default min-slaves-to-write is set to 0 (feature disabled) and<br>  # min-slaves-max-lag is set to 10.<br>  ​<br>  # A Redis master is able to list the address and port of the attached<br>  # slaves in different ways. For example the “INFO replication” section<br>  # offers this information, which is used, among other tools, by<br>  # Redis Sentinel in order to discover slave instances.<br>  # Another place where this info is available is in the output of the<br>  # “ROLE” command of a master.<br>  #<br>  # The listed IP and address normally reported by a slave is obtained</p> 
 <h2><a id="in_the_following_way_755"></a>in the following way:</h2> 
 <p>#</p> 
 <h2><a id="IP_The_address_is_auto_detected_by_checking_the_peer_address_757"></a>IP: The address is auto detected by checking the peer address</h2> 
 <h2><a id="of_the_socket_used_by_the_slave_to_connect_with_the_master_758"></a>of the socket used by the slave to connect with the master.</h2> 
 <p>#</p> 
 <h2><a id="Port_The_port_is_communicated_by_the_slave_during_the_replication_760"></a>Port: The port is communicated by the slave during the replication</h2> 
 <h2><a id="handshake_and_is_normally_the_port_that_the_slave_is_using_to_761"></a>handshake, and is normally the port that the slave is using to</h2> 
 <h2><a id="list_for_connections_762"></a>list for connections.</h2> 
 <p>#</p> 
 <h2><a id="However_when_port_forwarding_or_Network_Address_Translation_NAT_is_764"></a>However when port forwarding or Network Address Translation (NAT) is</h2> 
 <h2><a id="used_the_slave_may_be_actually_reachable_via_different_IP_and_port_765"></a>used, the slave may be actually reachable via different IP and port</h2> 
 <h2><a id="pairs_The_following_two_options_can_be_used_by_a_slave_in_order_to_766"></a>pairs. The following two options can be used by a slave in order to</h2> 
 <h2><a id="report_to_its_master_a_specific_set_of_IP_and_port_so_that_both_INFO_767"></a>report to its master a specific set of IP and port, so that both INFO</h2> 
 <h2><a id="and_ROLE_will_report_those_values_768"></a>and ROLE will report those values.</h2> 
 <p>#</p> 
 <h2><a id="There_is_no_need_to_use_both_the_options_if_you_need_to_override_just_770"></a>There is no need to use both the options if you need to override just</h2> 
 <h2><a id="the_port_or_the_IP_address_771"></a>the port or the IP address.</h2> 
 <p>#</p> 
 <h2><a id="slaveannounceip_5555_773"></a>slave-announce-ip 5.5.5.5</h2> 
 <h2><a id="slaveannounceport_1234_774"></a>slave-announce-port 1234</h2> 
 <p>​ <br> ################################## SECURITY ################################### <br> ​</p> 
 <h2><a id="Require_clients_to_issue_AUTH_PASSWORD_before_processing_any_other_778"></a>Require clients to issue AUTH before processing any other</h2> 
 <h2><a id="commands_%C2%A0This_might_be_useful_in_environments_in_which_you_do_not_trust_779"></a>commands.  This might be useful in environments in which you do not trust</h2> 
 <h2><a id="others_with_access_to_the_host_running_redisserver_780"></a>others with access to the host running redis-server.</h2> 
 <p>#</p> 
 <h2><a id="This_should_stay_commented_out_for_backward_compatibility_and_because_most_782"></a>This should stay commented out for backward compatibility and because most</h2> 
 <h2><a id="people_do_not_need_auth_eg_they_run_their_own_servers_783"></a>people do not need auth (e.g. they run their own servers).</h2> 
 <p>#</p> 
 <h2><a id="Warning_since_Redis_is_pretty_fast_an_outside_user_can_try_up_to_785"></a>Warning: since Redis is pretty fast an outside user can try up to</h2> 
 <h2><a id="150k_passwords_per_second_against_a_good_box_This_means_that_you_should_786"></a>150k passwords per second against a good box. This means that you should</h2> 
 <h2><a id="use_a_very_strong_password_otherwise_it_will_be_very_easy_to_break_787"></a>use a very strong password otherwise it will be very easy to break.</h2> 
 <p>#</p> 
 <h2><a id="requirepass_foobared_789"></a>requirepass foobared</h2> 
 <p>​</p> 
 <h2><a id="Command_renaming_791"></a>Command renaming.</h2> 
 <p>#</p> 
 <h2><a id="It_is_possible_to_change_the_name_of_dangerous_commands_in_a_shared_793"></a>It is possible to change the name of dangerous commands in a shared</h2> 
 <h2><a id="environment_For_instance_the_CONFIG_command_may_be_renamed_into_something_794"></a>environment. For instance the CONFIG command may be renamed into something</h2> 
 <h2><a id="hard_to_guess_so_that_it_will_still_be_available_for_internaluse_tools_795"></a>hard to guess so that it will still be available for internal-use tools</h2> 
 <h2><a id="but_not_available_for_general_clients_796"></a>but not available for general clients.</h2> 
 <p>#</p> 
 <h2><a id="Example_798"></a>Example:</h2> 
 <p>#</p> 
 <h2><a id="renamecommand_CONFIG_b840fc02d524045429941cc15f59e41cb7be6c52_800"></a>rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</h2> 
 <p>#</p> 
 <h2><a id="It_is_also_possible_to_completely_kill_a_command_by_renaming_it_into_802"></a>It is also possible to completely kill a command by renaming it into</h2> 
 <h2><a id="an_empty_string_803"></a>an empty string:</h2> 
 <p>#</p> 
 <h2><a id="renamecommand_CONFIG__805"></a>rename-command CONFIG “”</h2> 
 <p>#</p> 
 <h2><a id="Please_note_that_changing_the_name_of_commands_that_are_logged_into_the_807"></a>Please note that changing the name of commands that are logged into the</h2> 
 <h2><a id="AOF_file_or_transmitted_to_slaves_may_cause_problems_808"></a>AOF file or transmitted to slaves may cause problems.</h2> 
 <p>​ <br> ################################### CLIENTS #################################### <br> ​</p> 
 <h2><a id="Set_the_max_number_of_connected_clients_at_the_same_time_By_default_812"></a>Set the max number of connected clients at the same time. By default</h2> 
 <h2><a id="this_limit_is_set_to_10000_clients_however_if_the_Redis_server_is_not_813"></a>this limit is set to 10000 clients, however if the Redis server is not</h2> 
 <h2><a id="able_to_configure_the_process_file_limit_to_allow_for_the_specified_limit_814"></a>able to configure the process file limit to allow for the specified limit</h2> 
 <h2><a id="the_max_number_of_allowed_clients_is_set_to_the_current_file_limit_815"></a>the max number of allowed clients is set to the current file limit</h2> 
 <h2><a id="minus_32_as_Redis_reserves_a_few_file_descriptors_for_internal_uses_816"></a>minus 32 (as Redis reserves a few file descriptors for internal uses).</h2> 
 <p>#</p> 
 <h2><a id="Once_the_limit_is_reached_Redis_will_close_all_the_new_connections_sending_818"></a>Once the limit is reached Redis will close all the new connections sending</h2> 
 <h2><a id="an_error_max_number_of_clients_reached_819"></a>an error ‘max number of clients reached’.</h2> 
 <p>#</p> 
 <h2><a id="maxclients_10000_821"></a>maxclients 10000</h2> 
 <p>​ <br> ############################## MEMORY MANAGEMENT ################################ <br> ​</p> 
 <h2><a id="Set_a_memory_usage_limit_to_the_specified_amount_of_bytes_825"></a>Set a memory usage limit to the specified amount of bytes.</h2> 
 <h2><a id="When_the_memory_limit_is_reached_Redis_will_try_to_remove_keys_826"></a>When the memory limit is reached Redis will try to remove keys</h2> 
 <h2><a id="according_to_the_eviction_policy_selected_see_maxmemorypolicy_827"></a>according to the eviction policy selected (see maxmemory-policy).</h2> 
 <p>#</p> 
 <h2><a id="If_Redis_cant_remove_keys_according_to_the_policy_or_if_the_policy_is_829"></a>If Redis can’t remove keys according to the policy, or if the policy is</h2> 
 <h2><a id="set_to_noeviction_Redis_will_start_to_reply_with_errors_to_commands_830"></a>set to ‘noeviction’, Redis will start to reply with errors to commands</h2> 
 <h2><a id="that_would_use_more_memory_like_SET_LPUSH_and_so_on_and_will_continue_831"></a>that would use more memory, like SET, LPUSH, and so on, and will continue</h2> 
 <h2><a id="to_reply_to_readonly_commands_like_GET_832"></a>to reply to read-only commands like GET.</h2> 
 <p>#</p> 
 <h2><a id="This_option_is_usually_useful_when_using_Redis_as_an_LRU_or_LFU_cache_or_to_834"></a>This option is usually useful when using Redis as an LRU or LFU cache, or to</h2> 
 <h2><a id="set_a_hard_memory_limit_for_an_instance_using_the_noeviction_policy_835"></a>set a hard memory limit for an instance (using the ‘noeviction’ policy).</h2> 
 <p>#</p> 
 <h2><a id="WARNING_If_you_have_slaves_attached_to_an_instance_with_maxmemory_on_837"></a>WARNING: If you have slaves attached to an instance with maxmemory on,</h2> 
 <h2><a id="the_size_of_the_output_buffers_needed_to_feed_the_slaves_are_subtracted_838"></a>the size of the output buffers needed to feed the slaves are subtracted</h2> 
 <h2><a id="from_the_used_memory_count_so_that_network_problems__resyncs_will_839"></a>from the used memory count, so that network problems / resyncs will</h2> 
 <h2><a id="not_trigger_a_loop_where_keys_are_evicted_and_in_turn_the_output_840"></a>not trigger a loop where keys are evicted, and in turn the output</h2> 
 <h2><a id="buffer_of_slaves_is_full_with_DELs_of_keys_evicted_triggering_the_deletion_841"></a>buffer of slaves is full with DELs of keys evicted triggering the deletion</h2> 
 <h2><a id="of_more_keys_and_so_forth_until_the_database_is_completely_emptied_842"></a>of more keys, and so forth until the database is completely emptied.</h2> 
 <p>#</p> 
 <h2><a id="In_short_if_you_have_slaves_attached_it_is_suggested_that_you_set_a_lower_844"></a>In short… if you have slaves attached it is suggested that you set a lower</h2> 
 <h2><a id="limit_for_maxmemory_so_that_there_is_some_free_RAM_on_the_system_for_slave_845"></a>limit for maxmemory so that there is some free RAM on the system for slave</h2> 
 <h2><a id="output_buffers_but_this_is_not_needed_if_the_policy_is_noeviction_846"></a>output buffers (but this is not needed if the policy is ‘noeviction’).</h2> 
 <p>#</p> 
 <h2><a id="maxmemory_bytes_848"></a>maxmemory </h2> 
 <p>​</p> 
 <h2><a id="MAXMEMORY_POLICY_how_Redis_will_select_what_to_remove_when_maxmemory_850"></a>MAXMEMORY POLICY: how Redis will select what to remove when maxmemory</h2> 
 <h2><a id="is_reached_You_can_select_among_five_behaviors_851"></a>is reached. You can select among five behaviors:</h2> 
 <p>#</p> 
 <h2><a id="volatilelru__Evict_using_approximated_LRU_among_the_keys_with_an_expire_set_853"></a>volatile-lru -&gt; Evict using approximated LRU among the keys with an expire set.</h2> 
 <h2><a id="allkeyslru__Evict_any_key_using_approximated_LRU_854"></a>allkeys-lru -&gt; Evict any key using approximated LRU.</h2> 
 <h2><a id="volatilelfu__Evict_using_approximated_LFU_among_the_keys_with_an_expire_set_855"></a>volatile-lfu -&gt; Evict using approximated LFU among the keys with an expire set.</h2> 
 <h2><a id="allkeyslfu__Evict_any_key_using_approximated_LFU_856"></a>allkeys-lfu -&gt; Evict any key using approximated LFU.</h2> 
 <h2><a id="volatilerandom__Remove_a_random_key_among_the_ones_with_an_expire_set_857"></a>volatile-random -&gt; Remove a random key among the ones with an expire set.</h2> 
 <h2><a id="allkeysrandom__Remove_a_random_key_any_key_858"></a>allkeys-random -&gt; Remove a random key, any key.</h2> 
 <h2><a id="volatilettl__Remove_the_key_with_the_nearest_expire_time_minor_TTL_859"></a>volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)</h2> 
 <h2><a id="noeviction__Dont_evict_anything_just_return_an_error_on_write_operations_860"></a>noeviction -&gt; Don’t evict anything, just return an error on write operations.</h2> 
 <p>#</p> 
</blockquote> 
<p><strong>自我介绍一下，小编13年上海交大毕业，曾经在小公司待过，也去过华为、OPPO等大厂，18年进入阿里一直到现在。</strong></p> 
<p><strong>深知大多数Linux运维工程师，想要提升技能，往往是自己摸索成长或者是报班学习，但对于培训机构动则几千的学费，着实压力不小。自己不成体系的自学效果低效又漫长，而且极易碰到天花板技术停滞不前！</strong></p> 
<p><strong>因此收集整理了一份《2024年Linux运维全套学习资料》，初衷也很简单，就是希望能够帮助到想自学提升又不知道该从何学起的朋友，同时减轻大家的负担。</strong><br> <img src="https://images2.imgbox.com/a5/e0/toXUVojS_o.png" alt="img"><br> <img src="https://images2.imgbox.com/95/cb/I0X3uKIL_o.png" alt="img"><br> <img src="https://images2.imgbox.com/ba/8c/sdw4AmYz_o.png" alt="img"><br> <img src="https://images2.imgbox.com/14/38/R4dNuZAp_o.png" alt="img"><br> <img src="https://images2.imgbox.com/61/07/6s5CTc1s_o.png" alt="img"></p> 
<p><strong>既有适合小白学习的零基础资料，也有适合3年以上经验的小伙伴深入学习提升的进阶课程，基本涵盖了95%以上Linux运维知识点，真正体系化！</strong></p> 
<p><strong>由于文件比较大，这里只是将部分目录大纲截图出来，每个节点里面都包含大厂面经、学习笔记、源码讲义、实战项目、讲解视频，并且后续会持续更新</strong></p> 
<p><strong>如果你觉得这些内容对你有帮助，可以添加VX：vip1024b （备注Linux运维获取）</strong><br> <img src="https://images2.imgbox.com/fc/69/5qIhdou6_o.jpg" alt="img"></p> 
<p>为了做好运维面试路上的助攻手，特整理了上百道 <strong>【运维技术栈面试题集锦】</strong> ，让你面试不慌心不跳，高薪offer怀里抱！</p> 
<p>这次整理的面试题，<strong>小到shell、MySQL，大到K8s等云原生技术栈，不仅适合运维新人入行面试需要，还适用于想提升进阶跳槽加薪的运维朋友。</strong></p> 
<p><img src="https://images2.imgbox.com/e4/bc/kd5Uwsyu_o.png" alt=""></p> 
<p>本份面试集锦涵盖了</p> 
<ul><li><strong>174 道运维工程师面试题</strong></li><li><strong>128道k8s面试题</strong></li><li><strong>108道shell脚本面试题</strong></li><li><strong>200道Linux面试题</strong></li><li><strong>51道docker面试题</strong></li><li><strong>35道Jenkis面试题</strong></li><li><strong>78道MongoDB面试题</strong></li><li><strong>17道ansible面试题</strong></li><li><strong>60道dubbo面试题</strong></li><li><strong>53道kafka面试</strong></li><li><strong>18道mysql面试题</strong></li><li><strong>40道nginx面试题</strong></li><li><strong>77道redis面试题</strong></li><li><strong>28道zookeeper</strong></li></ul> 
<p><strong>总计 1000+ 道面试题， 内容 又全含金量又高</strong></p> 
<ul><li><strong>174道运维工程师面试题</strong></li></ul> 
<blockquote> 
 <p>1、什么是运维?</p> 
</blockquote> 
<blockquote> 
 <p>2、在工作中，运维人员经常需要跟运营人员打交道，请问运营人员是做什么工作的?</p> 
</blockquote> 
<blockquote> 
 <p>3、现在给你三百台服务器，你怎么对他们进行管理?</p> 
</blockquote> 
<blockquote> 
 <p>4、简述raid0 raid1raid5二种工作模式的工作原理及特点</p> 
</blockquote> 
<blockquote> 
 <p>5、LVS、Nginx、HAproxy有什么区别?工作中你怎么选择?</p> 
</blockquote> 
<blockquote> 
 <p>6、Squid、Varinsh和Nginx有什么区别，工作中你怎么选择?</p> 
</blockquote> 
<blockquote> 
 <p>7、Tomcat和Resin有什么区别，工作中你怎么选择?</p> 
</blockquote> 
<blockquote> 
 <p>8、什么是中间件?什么是jdk?</p> 
</blockquote> 
<blockquote> 
 <p>9、讲述一下Tomcat8005、8009、8080三个端口的含义？</p> 
</blockquote> 
<blockquote> 
 <p>10、什么叫CDN?</p> 
</blockquote> 
<blockquote> 
 <p>11、什么叫网站灰度发布?</p> 
</blockquote> 
<blockquote> 
 <p>12、简述DNS进行域名解析的过程?</p> 
</blockquote> 
<blockquote> 
 <p>13、RabbitMQ是什么东西?</p> 
</blockquote> 
<blockquote> 
 <p>14、讲一下Keepalived的工作原理?</p> 
</blockquote> 
<blockquote> 
 <p>15、讲述一下LVS三种模式的工作过程?</p> 
</blockquote> 
<blockquote> 
 <p>16、mysql的innodb如何定位锁问题，mysql如何减少主从复制延迟?</p> 
</blockquote> 
<blockquote> 
 <p>17、如何重置mysql root密码?</p> 
</blockquote> 
<p><a href="https://bbs.csdn.net/forums/4304bb5a486d4c3ab8389e65ecb71ac0"><strong>一个人可以走的很快，但一群人才能走的更远。如果你从事以下工作或对以下感兴趣，欢迎戳这里加入程序员的圈子，让我们一起学习成长！</strong></a></p> 
<p><strong>AI人工智能、Android移动开发、AIGC大模型、C C#、Go语言、Java、Linux运维、云计算、MySQL、PMP、网络安全、Python爬虫、UE5、UI设计、Unity3D、Web前端开发、产品经理、车载开发、大数据、鸿蒙、计算机网络、嵌入式物联网、软件测试、数据结构与算法、音视频开发、Flutter、IOS开发、PHP开发、.NET、安卓逆向、云计算</strong></p> 
<p>面试题**</p> 
<ul><li><strong>77道redis面试题</strong></li><li><strong>28道zookeeper</strong></li></ul> 
<p><strong>总计 1000+ 道面试题， 内容 又全含金量又高</strong></p> 
<ul><li><strong>174道运维工程师面试题</strong></li></ul> 
<blockquote> 
 <p>1、什么是运维?</p> 
</blockquote> 
<blockquote> 
 <p>2、在工作中，运维人员经常需要跟运营人员打交道，请问运营人员是做什么工作的?</p> 
</blockquote> 
<blockquote> 
 <p>3、现在给你三百台服务器，你怎么对他们进行管理?</p> 
</blockquote> 
<blockquote> 
 <p>4、简述raid0 raid1raid5二种工作模式的工作原理及特点</p> 
</blockquote> 
<blockquote> 
 <p>5、LVS、Nginx、HAproxy有什么区别?工作中你怎么选择?</p> 
</blockquote> 
<blockquote> 
 <p>6、Squid、Varinsh和Nginx有什么区别，工作中你怎么选择?</p> 
</blockquote> 
<blockquote> 
 <p>7、Tomcat和Resin有什么区别，工作中你怎么选择?</p> 
</blockquote> 
<blockquote> 
 <p>8、什么是中间件?什么是jdk?</p> 
</blockquote> 
<blockquote> 
 <p>9、讲述一下Tomcat8005、8009、8080三个端口的含义？</p> 
</blockquote> 
<blockquote> 
 <p>10、什么叫CDN?</p> 
</blockquote> 
<blockquote> 
 <p>11、什么叫网站灰度发布?</p> 
</blockquote> 
<blockquote> 
 <p>12、简述DNS进行域名解析的过程?</p> 
</blockquote> 
<blockquote> 
 <p>13、RabbitMQ是什么东西?</p> 
</blockquote> 
<blockquote> 
 <p>14、讲一下Keepalived的工作原理?</p> 
</blockquote> 
<blockquote> 
 <p>15、讲述一下LVS三种模式的工作过程?</p> 
</blockquote> 
<blockquote> 
 <p>16、mysql的innodb如何定位锁问题，mysql如何减少主从复制延迟?</p> 
</blockquote> 
<blockquote> 
 <p>17、如何重置mysql root密码?</p> 
</blockquote> 
<p><a href="https://bbs.csdn.net/forums/4304bb5a486d4c3ab8389e65ecb71ac0"><strong>一个人可以走的很快，但一群人才能走的更远。如果你从事以下工作或对以下感兴趣，欢迎戳这里加入程序员的圈子，让我们一起学习成长！</strong></a></p> 
<p><strong>AI人工智能、Android移动开发、AIGC大模型、C C#、Go语言、Java、Linux运维、云计算、MySQL、PMP、网络安全、Python爬虫、UE5、UI设计、Unity3D、Web前端开发、产品经理、车载开发、大数据、鸿蒙、计算机网络、嵌入式物联网、软件测试、数据结构与算法、音视频开发、Flutter、IOS开发、PHP开发、.NET、安卓逆向、云计算</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4bfd03083594fdc011b51390ff0f4464/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MATLAB中cvx工具箱的使用介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/94e0206b49df3f4b7acdb73c9eb299d1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">常见的SQL面试题：经典50例</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>