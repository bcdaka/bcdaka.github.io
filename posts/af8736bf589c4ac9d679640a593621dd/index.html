<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;的数据结构(五）：树和存储结构及示例 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/af8736bf589c4ac9d679640a593621dd/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C&#43;&#43;的数据结构(五）：树和存储结构及示例">
  <meta property="og:description" content="在计算机科学中，树是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。这种数据结构以一系列连接的节点来形成树形结构。在C&#43;&#43;中，树的概念和存储结构是实现各种复杂算法和数据操作的基础。 树是由节点和边组成的图，其中每个节点有零个或多个子节点，但只有一个父节点（除了根节点，它没有父节点）。树的顶部节点称为根节点。如果一个节点没有子节点，那么它被称为叶子节点。除了根节点和叶子节点之外的其他节点称为内部节点。由树的根节点和若干棵子树所构成的树称为森林。如下图所示。
树的术语： （1）路径：在两个节点之间，一系列的边和节点的组合。路径的长度是组成路径的边数。
（2）深度：一个节点的深度是指从根节点到该节点的最长路径上的边数。根节点的深度为0。
（3）层次：树的层次从根开始定义，根为第一层，根的子节点为第二层，以此类推。
（4）高度：树的高度是从叶子节点开始自底向上逐层累加的路径上边的数量。根节点的高度就是树的高度。
在C&#43;&#43;中，树的存储结构主要有两种：顺序存储和链式存储。不同的存储结构对应着不同的表示方法，如孩子表示法、双亲表示法、孩子兄弟表示法等。
1. 顺序存储：顺序存储通常用于完全二叉树。在完全二叉树中，除了最后一层外，其他层的节点数是满的，并且最后一层的节点都靠左排列。这种特性使得完全二叉树可以使用数组进行顺序存储，其中每个节点的索引与其在树中的位置相关。
示例：创建一棵简单的完全二叉树，代码如下。
#include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; class TreeNode { public: int value; TreeNode* left; TreeNode* right; TreeNode(int x) : value(x), left(nullptr), right(nullptr) {} }; class BinaryTree { private: vector&lt;TreeNode*&gt; nodes; public: // 初始化树的根节点 void initRoot(int value) { nodes.push_back(new TreeNode(value)); } // 添加子节点 void addChild(int parentIndex, int leftChildValue, int rightChildValue) { int nextEmptyIndex = nodes.size(); if (leftChildValue != -1) { nodes.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-13T09:07:48+08:00">
    <meta property="article:modified_time" content="2024-05-13T09:07:48+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;的数据结构(五）：树和存储结构及示例</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>        在计算机科学中，树是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。这种数据结构以一系列连接的节点来形成树形结构。在C++中，树的概念和存储结构是实现各种复杂算法和数据操作的基础。   </p> 
<p>     树是由节点和边组成的图，其中每个节点有零个或多个子节点，但只有一个父节点（除了根节点，它没有父节点）。树的顶部节点称为根节点。如果一个节点没有子节点，那么它被称为叶子节点。除了根节点和叶子节点之外的其他节点称为内部节点。由树的根节点和若干棵子树所构成的树称为森林。如下图所示。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/96/be/Mpg0tNl6_o.jpg"></p> 
<p>         树的术语：    </p> 
<p>        （1）路径：在两个节点之间，一系列的边和节点的组合。路径的长度是组成路径的边数。</p> 
<p>        （2）深度：一个节点的深度是指从根节点到该节点的最长路径上的边数。根节点的深度为0。</p> 
<p>        （3）层次：树的层次从根开始定义，根为第一层，根的子节点为第二层，以此类推。</p> 
<p>        （4）高度：树的高度是从叶子节点开始自底向上逐层累加的路径上边的数量。根节点的高度就是树的高度。</p> 
<p>        在C++中，树的存储结构主要有两种：顺序存储和链式存储。不同的存储结构对应着不同的表示方法，如孩子表示法、双亲表示法、孩子兄弟表示法等。</p> 
<p>        1. 顺序存储：顺序存储通常用于完全二叉树。在完全二叉树中，除了最后一层外，其他层的节点数是满的，并且最后一层的节点都靠左排列。这种特性使得完全二叉树可以使用数组进行顺序存储，其中每个节点的索引与其在树中的位置相关。</p> 
<p>        示例：创建一棵简单的完全二叉树，代码如下。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

class TreeNode {
public:
    int value;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : value(x), left(nullptr), right(nullptr) {}
};

class BinaryTree {
private:
    vector&lt;TreeNode*&gt; nodes;
public:
    // 初始化树的根节点
    void initRoot(int value) {
        nodes.push_back(new TreeNode(value));
    }
    
    // 添加子节点
    void addChild(int parentIndex, int leftChildValue, int rightChildValue) {
        int nextEmptyIndex = nodes.size();
        if (leftChildValue != -1) {
            nodes.push_back(new TreeNode(leftChildValue));
            nodes[parentIndex]-&gt;left = nodes[nextEmptyIndex];
        }
        if (rightChildValue != -1) {
            nodes.push_back(new TreeNode(rightChildValue));
            nodes[parentIndex]-&gt;right = nodes[nextEmptyIndex + (leftChildValue != -1)];
        }
    }
    
    // 示例：创建一棵简单的完全二叉树
    void createExampleTree() {
        initRoot(1);
        addChild(0, 2, 3);
        addChild(1, 4, 5);
        addChild(2, 6, -1);
        addChild(3, 7, 8);
    }
    
    // 其他操作，如遍历、查找等...
};</code></pre> 
<p>        链式存储：链式存储通过节点和指针来表示树中的关系。每个节点包含数据域和指向其子节点的指针域。链式存储方式更加灵活，适用于各种类型的树。</p> 
<p>        示例一：使用孩子表示法创建树，代码如下。</p> 
<pre><code class="language-cpp">class TreeNode {
public:
    int value;
    vector&lt;TreeNode*&gt; children;
    TreeNode(int x) : value(x) {}
};

// 使用孩子表示法创建树
TreeNode* createTree() {
    TreeNode* root = new TreeNode(1);
    TreeNode* node2 = new TreeNode(2);
    TreeNode* node3 = new TreeNode(3);
    TreeNode* node4 = new TreeNode(4);
    TreeNode* node5 = new TreeNode(5);
    
    root-&gt;children.push_back(node2);
    root-&gt;children.push_back(node3);
    node2-&gt;children.push_back(node4);
    node2-&gt;children.push_back(node5);
    
    return root;
}</code></pre> 
<p>        上述代码展示了如何使用孩子表示法来创建一个树，其中每个节点都有一个指向其子节点的指针列表。这种方式可以很直观地表示一个节点的所有子节点，但是在查找父节点时不够高效，因为父节点的信息并未存储在当前节点中。</p> 
<p>        在双亲表示法中，每个节点不仅包含数据域和指向其子节点的指针，还包含一个指向其父节点的指针。这使得我们可以方便地访问一个节点的父节点，但可能需要额外的空间来存储父节点的指针。</p> 
<p>        示例二：使用双亲表示法创建树，代码如下：</p> 
<pre><code class="language-cpp">class TreeNode {
public:
    int value;
    TreeNode* parent; // 指向父节点的指针
    vector&lt;TreeNode*&gt; children; // 子节点列表
    TreeNode(int x) : value(x), parent(nullptr) {}
};

// 使用双亲表示法创建树
void createTreeWithParent(TreeNode*&amp; root) {
    root = new TreeNode(1); // 根节点的父节点为null
    TreeNode* node2 = new TreeNode(2);
    TreeNode* node3 = new TreeNode(3);
    TreeNode* node4 = new TreeNode(4);
    TreeNode* node5 = new TreeNode(5);
    
    node2-&gt;parent = root;
    node3-&gt;parent = root;
    node4-&gt;parent = node2;
    node5-&gt;parent = node2;
    
    root-&gt;children.push_back(node2);
    root-&gt;children.push_back(node3);
    node2-&gt;children.push_back(node4);
    node2-&gt;children.push_back(node5);
}</code></pre> 
<p>        在双亲表示法中，我们可以沿着父节点的指针向上遍历树，直到找到根节点或者到达一个父节点为空的节点。这种表示法在需要频繁进行父子节点关系查询时比较有用。</p> 
<p>        孩子兄弟表示法是一种结合了孩子表示法和双亲表示法的思想的方法。在这种表示法中，每个节点包含指向其第一个孩子节点的指针和指向其下一个兄弟节点的指针。这种表示法对于二叉树非常自然，并且可以很方便地表示任何类型的树。<br>         示例三： 使用孩子兄弟表示法创建树，代码如下：</p> 
<pre><code class="language-cpp">class TreeNode {
public:
    int value;
    TreeNode* firstChild; // 指向第一个孩子节点
    TreeNode* nextSibling; // 指向下一个兄弟节点
    TreeNode(int x) : value(x), firstChild(nullptr), nextSibling(nullptr) {}
};

// 使用孩子兄弟表示法创建树
void createTreeWithChildSibling(TreeNode*&amp; root) {
    root = new TreeNode(1);
    TreeNode* node2 = new TreeNode(2);
    TreeNode* node3 = new TreeNode(3);
    TreeNode* node4 = new TreeNode(4);
    TreeNode* node5 = new TreeNode(5);
    
    root-&gt;firstChild = node2;
    node2-&gt;nextSibling = node3;
    node3-&gt;firstChild = node4;
    node3-&gt;nextSibling = node5;
}</code></pre> 
<p>        在这种表示法中，通过firstChild可以访问到该节点的所有子节点，而通过nextSibling可以遍历该节点的所有兄弟节点。这种方法特别适合处理那些子节点之间没有顺序要求的树结构。</p> 
<p>        每种存储结构都有其适用的场景和优缺点，例如顺序存储适合表示完全二叉树，而链式存储则更加灵活，能够表示任意结构的树。在实际应用中，需要根据具体需求和树的特点来选择适当的存储结构。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/021dc3f0768c2c54f4f1755854d05d99/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">小程序蓝牙连接ESP32通信(可直接拿来用)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6fc0037419f174cf2805805196e91399/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AI绘画Stable Diffusion【真人模型】：SD1.5人像模型新高度，超级逼真的AI真人模型</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>