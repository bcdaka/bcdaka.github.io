<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构奇妙旅程之栈和队列 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/a05f4ec0aad30efddd49b2906daaa79b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构奇妙旅程之栈和队列">
  <meta property="og:description" content="꒰˃͈꒵˂͈꒱ write in front ꒰˃͈꒵˂͈꒱
ʕ̯•͡˔•̯᷅ʔ大家好，我是xiaoxie.希望你看完之后,有不足之处请多多谅解，让我们一起共同进步૮₍❀ᴗ͈ . ᴗ͈ აxiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客
本文由xiaoxieʕ̯•͡˔•̯᷅ʔ 原创 CSDN 如需转载还请通知˶⍤⃝˶
个人主页：xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客
系列专栏：xiaoxie的JAVA系列专栏——CSDN博客●&#39;ᴗ&#39;σσணღ*
我的目标:&#34;团团等我💪( ◡̀_◡́ ҂)&#34; ( ⸝⸝⸝›ᴥ‹⸝⸝⸝ )欢迎各位→点赞👍 &#43; 收藏⭐️ &#43; 留言📝​&#43;关注（互三必回）!
一.栈（Stack） 1.概念 栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端称为栈 顶，另一端称为栈底。栈中的数据元素遵守后进先出 LIFO （ Last In First Out ）的原则。 压栈：栈的插入操作叫做进栈 / 压栈 / 入栈， 入数据在栈顶 。 出栈：栈的删除操作叫做出栈。 出数据在栈顶 。 2.栈的模拟实现 可以看出栈Stack 是继承与Vector的， Vector和ArrayList类似，我们可以得到以下的栈的模拟实现，帮助我们更好的理解栈的使用。
//这是栈内存储Integer的模拟，当然栈是泛型，这里只是Integer的模拟 class MyStack { public int[] arr; public int size; public MyStack() { arr = new int[10]; } //入栈 public int push(int e) { ensureCapacity(); arr[size&#43;&#43;] = e; return e; } //判断栈是否满 private void ensureCapacity() { if (size == arr.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-12-16T15:43:36+08:00">
    <meta property="article:modified_time" content="2023-12-16T15:43:36+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构奇妙旅程之栈和队列</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>꒰˃͈꒵˂͈꒱ write in front ꒰˃͈꒵˂͈꒱<br> ʕ̯•͡˔•̯᷅ʔ大家好，我是xiaoxie.希望你看完之后,有不足之处请多多谅解，让我们一起共同进步૮₍❀ᴗ͈ . ᴗ͈ ა<a href="https://blog.csdn.net/xiaoxie8023?spm=1000.2115.3001.5343" title="xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客">xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客</a><br> 本文由xiaoxieʕ̯•͡˔•̯᷅ʔ 原创 CSDN 如需转载还请通知˶⍤⃝˶<br><a href="https://so.csdn.net/so/search?q=%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5&amp;spm=1001.2101.3001.7020" title="个人主页">个人主页</a>：<a href="https://blog.csdn.net/xiaoxie8023/article/details/134417887?spm=1001.2014.3001.5501" title="xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客">xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客</a><br> 系列专栏：<a href="https://blog.csdn.net/xiaoxie8023/category_12482318.html?spm=1001.2014.3001.5482" title="xiaoxie的JAVA系列专栏——CSDN博客●'ᴗ'σσணღ*">xiaoxie的JAVA系列专栏——CSDN博客●'ᴗ'σσணღ*</a><br><span style="color:#fe2c24;"><strong>我的目标:"团团等我💪( ◡̀_◡́ ҂)" </strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>( ⸝⸝⸝›ᴥ‹⸝⸝⸝ )欢迎各位→点赞👍 + 收藏⭐️ + 留言📝​+关注（互三必回）!</strong></span></p> 
</blockquote> 
<p><img alt="" height="1080" src="https://images2.imgbox.com/b2/cb/CDUE0Ocf_o.jpg" width="1080"></p> 
<h2> 一.栈（Stack）</h2> 
<h3>1.概念</h3> 
<p>栈<span style="color:#333333;">：一种特殊的线性表，其<strong>只允许在固定的一端进行插入和删除元素操作</strong></span><span style="color:#333333;">。进行数据插入和删除操作的一端称为栈 </span></p> 
<div> 
 <span style="color:#333333;">顶，另一端称为栈底。栈中的数据元素遵守后进先出</span> 
 <span style="color:#333333;">LIFO</span> 
 <span style="color:#333333;">（</span> 
 <span style="color:#333333;">Last In First Out</span> 
 <span style="color:#333333;">）的原则。 </span> 
</div> 
<div> 
 <span style="color:#333333;">压栈：栈的插入操作叫做进栈</span> 
 <span style="color:#333333;">/</span> 
 <span style="color:#333333;">压栈</span> 
 <span style="color:#333333;">/</span> 
 <span style="color:#333333;">入栈，</span> 
 <span style="color:#333333;"><strong>入数据在栈顶</strong></span> 
 <span style="color:#333333;">。 </span> 
</div> 
<div> 
 <span style="color:#333333;">出栈：栈的删除操作叫做出栈。</span> 
 <span style="color:#333333;"><strong>出数据在栈顶</strong></span> 
 <span style="color:#333333;">。 </span> 
</div> 
<h3>2.栈的模拟实现</h3> 
<p><img alt="" height="770" src="https://images2.imgbox.com/6e/56/Th0ZtWDL_o.png" width="1185"></p> 
<p></p> 
<p>可以看出栈Stack 是继承与Vector的， Vector和ArrayList类似，我们可以得到以下的栈的模拟实现，帮助我们更好的理解栈的使用。</p> 
<pre><code class="language-java">//这是栈内存储Integer的模拟，当然栈是泛型，这里只是Integer的模拟
class MyStack {
    public int[] arr;
    public int size;
    public MyStack() {
     arr = new int[10];
    }
    //入栈
    public int push(int e) {
        ensureCapacity();
        arr[size++] = e;
        return e;
    }
    //判断栈是否满
    private void ensureCapacity() {
        if (size == arr.length) {
            arr = Arrays.copyOf(arr, size * 2);
        }
    }
    //栈顶元素
    public int peek() {
        if(empty()) {
            System.out.println("栈为空，无元素");
            return -1;
        }
        return arr[size-1];
    }
    //出栈
    public int pop() {
        int tmp = peek();
        size--;
        return tmp;
    }
    //判断栈是否为空
    public boolean empty() {
        return this.size == 0;
    }

}</code></pre> 
<h3>3.栈、虚拟机栈、栈帧有什么区别呢</h3> 
<p>栈、虚拟机栈和栈帧是计算机科学中的概念，它们之间有以下区别：</p> 
<ol><li> <p>栈：栈是一种具有后进先出（Last-In-First-Out，LIFO）特性的数据结构，可以存储和检索数据。在计算机中，栈通常用于管理函数调用和局部变量的分配。栈在内存中是连续存储的一块区域，主要用于存储函数调用的上下文信息以及局部变量。</p> </li><li> <p>虚拟机栈：虚拟机栈是Java虚拟机（JVM）为每个线程分配的内存区域，用于存储方法的调用和执行信息。每个线程在执行方法时，都会在虚拟机栈中创建一个栈帧，栈帧中包含了方法的局部变量、操作数栈、方法返回地址等信息。</p> </li><li> <p>栈帧：栈帧是方法在虚拟机栈中的表示，用于存储方法的局部变量、操作数栈、方法返回地址等信息。每个方法在执行时，都会在虚拟机栈中创建一个对应的栈帧，方法的参数、局部变量以及中间计算结果都存储在栈帧中。当方法执行完毕后，对应的栈帧就会被销毁。</p> </li></ol> 
<p>总结来说，栈是一种数据结构，用于存储和检索数据；虚拟机栈是Java虚拟机为每个线程分配的内存区域，用于存储方法的调用和执行信息；栈帧是方法在虚拟机栈中的表示，用于存储方法的局部变量、操作数栈、方法返回地址等信息。</p> 
<h3> 4.栈的应用</h3> 
<p><a class="link-info" href="https://leetcode.cn/problems/min-stack/" rel="nofollow" title="155.最小栈">155.最小栈</a></p> 
<p> <img alt="" height="1200" src="https://images2.imgbox.com/52/eb/02UJp5V8_o.png" width="1200"></p> 
<p>题目分析：</p> 
<p>我们都知道栈是一个先进后出的数据结构，所以我们只使用一个普通栈是无法实现最小栈，应该要用两个栈来模拟实现最小栈。</p> 
<p><img alt="" height="836" src="https://images2.imgbox.com/2d/f9/2fJ732Mu_o.png" width="1200"></p> 
<p>如果两个栈都为空就先将元素入栈</p> 
<p><img alt="" height="908" src="https://images2.imgbox.com/9b/47/YfeW2I64_o.png" width="1200"></p> 
<p>然后下一个元素先入stack 栈 之后和minstack 比较如果 &lt; minstack的栈顶元素，就入 minstack 否则就不入，</p> 
<p><img alt="" height="816" src="https://images2.imgbox.com/c2/36/Yhea1Da0_o.png" width="1200"></p> 
<p>这样就通过用两个普通栈模拟最小栈了</p> 
<pre><code class="language-java">class MinStack {
     Stack&lt;Integer&gt; stack;
     Stack&lt;Integer&gt; minstack;
    public MinStack() {
        stack = new Stack&lt;&gt;();
        minstack = new Stack&lt;&gt;();
    }
    public void push(int val) {
        stack.push(val);
        if(minstack.empty()) {
            minstack.push(val);
        }else {
            if(minstack.peek() &gt;= val) {
                minstack.push(val);
            }
        }
    }
    
    public void pop() {
        int tmp = stack.pop();
        if(tmp == minstack.peek()) {
            minstack.pop();
        }
    }
    
    public int top() {
      return stack.peek();
    }
    
    public int getMin() {
       return minstack.peek();
    }
}</code></pre> 
<h4> 1.面试进阶</h4> 
<p>是否可以不用辅助栈呢</p> 
<p> 栈中每个元素代表的是要压入元素与当前栈中最小值的差值 有个很重要问题： 在弹出时如何维护min？ 因为每次压入新的元素时，压入的都是与当前栈中最小值的差值（还未压入当前元素），故在弹出元素时，若弹出了当前最小值，因为栈中记录了当前元素与【之前】最小值的差值，故根据这个记录可以更新弹出元素后的最小值。 接下来看代码吧</p> 
<pre><code class="language-java">class MinStack {
    // 记录每个元素与【未压入】该元素时栈中最小元素的差值
    LinkedList&lt;Long&gt; stack;
    // 当前【已压入】栈中元素的最小值
    private long min;
    public MinStack() {
        stack = new LinkedList();
    }
    
    public void push(int val) {
        // 压入第一个元素
        if(stack.isEmpty()){
            min = val;
            stack.addFirst(0L);
            return;
        }
        // 栈不为空时，每次压入计算与min的差值后压入结果
        stack.push((long)val-min);
        // 更新min
        min = Math.min((long)val,min);
        // 上面两个语句是不能颠倒的！一定是先压入，在更新，因为min一定是当前栈中的最小值
    }
    
    public void pop() {
        long pop = stack.removeFirst();
        // 当弹出元素小于0时，说明弹出元素是当前栈中的最小值，要更新最小值
        if(pop&lt;0){
            // 因为对于当前弹出的元素而言，计算压入栈中的值时，计算的是该元素与【未压入】该元素时
            // 栈中元素的最小值的差值，故弹出该元素后栈中的最小值就是未压入该元素时的最小值
            // 即当前元素的值（min）减去两者的差值
            long lastMin = min;
            min = lastMin - pop;
        }
        // 若大于等于0，不会对min有影响
    }
    
    public int top() {
        long peek = stack.peek();
        // 若当前栈顶小于等于0，说明最小值就是栈顶元素
        if(peek&lt;=0) return (int)min;
        // 否则就是min+peek
        return (int)(min+peek);
    }
    
    public int getMin() {
        return (int)min;
    }
}</code></pre> 
<h2>二.队列</h2> 
<h3>1.概念</h3> 
<div> 
 <span style="color:#333333;"><strong>队列</strong></span> 
 <span style="color:#333333;">：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有先进先出</span> 
 <span style="color:#333333;">FIFO(First </span> 
</div> 
<div> 
 <span style="color:#333333;">In First Out) </span> 
 <span style="color:#333333;">入队列：进行插入操作的一端称为</span> 
 <span style="color:#333333;"><strong>队尾（</strong></span> 
 <span style="color:#333333;"><strong>Tail/Rear</strong></span> 
 <span style="color:#333333;"><strong>） </strong></span> 
 <span style="color:#333333;">出队列：进行删除操作的一端称为</span> 
 <span style="color:#333333;"><strong>队头 </strong></span> 
 <span style="color:#333333;"><strong>（</strong></span> 
 <span style="color:#333333;"><strong>Head/Front</strong></span> 
 <span style="color:#333333;"><strong>）</strong></span> 
</div> 
<h3><span style="color:#333333;"><strong>2.队列的模拟实现</strong></span></h3> 
<pre><code class="language-java">public class Queue {

    private int maxSize;
    private int[] queueArray;
    private int front;
    private int rear;
    private int nItems;

    public Queue(int size) {
        maxSize = size;
        queueArray = new int[maxSize];
        front = 0;
        rear = -1;
        nItems = 0;
    }

    public void insert(int value) {
        if (rear == maxSize - 1) {
            rear = -1;
        }
        queueArray[++rear] = value;
        nItems++;
    }

    public int remove() {
        int temp = queueArray[front++];
        if (front == maxSize) {
            front = 0;
        }
        nItems--;
        return temp;
    }

    public int peek() {
        return queueArray[front];
    }

    public boolean isEmpty() {
        return (nItems == 0);
    }

    public boolean isFull() {
        return (nItems == maxSize);
    }

    public int size() {
        return nItems;
    }

}
 
</code></pre> 
<h2>  三.面试题</h2> 
<h2> <a class="link-info" href="https://leetcode.cn/problems/implement-stack-using-queues/" rel="nofollow" title="用队列实现栈">用队列实现栈</a></h2> 
<p>大家都清楚栈是先进后出，队列是先进先出的数据结构，如果要用队列模拟实现栈，仅靠一个队列是无法实现，需要用到两个队列，来模拟模拟实现栈</p> 
<p><img alt="" height="830" src="https://images2.imgbox.com/1b/b2/OnNYueWT_o.png" width="1200">                                                                                                                                  </p> 
<p>如果两个队列都为空 就入q1 的队</p> 
<p><img alt="" height="858" src="https://images2.imgbox.com/64/05/yTom8ty1_o.png" width="1200"></p> 
<p>谁不为空就入队那个队列，如果要出栈的话，就把除了要出栈的那个元素之外的元素，入到另一个 队列中。</p> 
<p><img alt="" height="866" src="https://images2.imgbox.com/c6/60/8fJwYiB4_o.png" width="1200"></p> 
<p> 代码如下</p> 
<pre><code class="language-java">class MyStack {
   Queue&lt;Integer&gt; q1;
   Queue&lt;Integer&gt; q2;
    public MyStack() {
        q1 = new LinkedList&lt;&gt;();
        q2 = new LinkedList&lt;&gt;();
    }

    public void push(int x) {
        if(empty()) {
            q1.add(x);
            return;
        }if( ! q1.isEmpty()) {
            q1.add(x);
        }else {
            q2.add(x);
        }
    }

    public int pop() {
        if(empty()) return -1;
        if(!q1.isEmpty()) {
            int size1 = q1.size();
            for (int i = 0;i &lt; size1-1;i++) {
                q2.add(q1.poll());
            }
            return q1.poll();
        }else {
            int size2 = q2.size();
            for (int i = 0; i &lt; size2-1; i++) {
                q1.add(q2.poll());
            }
            return q2.poll();
        }
    }

    public int top() {
        if(empty()) {
            return -1;
        }int temp = -1;
        if(!q1.isEmpty()) {
            int size2 = q1.size();
            for(int i = 0; i &lt; size2;i++) {
                temp = q1.poll();
                q2.offer(temp);
            }
            return temp;
        }else {
                 int size2 = q2.size();
                for(int i = 0;i &lt; size2; i++) {
                   temp = q2.poll();
                   q1.offer(temp);
                }
            return temp;
        }
    }
    public boolean empty() {
        return q1.isEmpty() &amp;&amp; q2.isEmpty();
    }
}
</code></pre> 
<p><a class="link-info" href="https://leetcode.cn/problems/implement-queue-using-stacks/" rel="nofollow" title="用栈实现队列">用栈实现队列</a></p> 
<p>栈实现队列的出队操作效率低下：栈底元素（对应队首元素）无法直接删除，需要将上方所有元素出栈。</p> 
<p>两个栈可实现将列表倒序：设有含三个元素的栈 A = [1,2,3] 和空栈 B = [] 。若循环执行 A 元素出栈并添加入栈 B ，直到栈 A 为空，则 A = [] , B = [3,2,1] ，即栈 B 元素为栈 A 元素倒序。</p> 
<p>利用栈 B 删除队首元素：倒序后，B 执行出栈则相当于删除了 A 的栈底元素，即对应队首元素。</p> 
<p>因此，可以设计栈 A 用于加入队尾操作，栈 B 用于将元素倒序，从而实现删除队首元素。</p> 
<p><img alt="" height="808" src="https://images2.imgbox.com/5e/4a/ffSEnLJk_o.png" width="1076"></p> 
<p>代码如下</p> 
<pre><code class="language-java">class MyQueue {
    Stack&lt;Integer&gt; s1;
    Stack&lt;Integer&gt; s2;
    public MyQueue() {
        s1 = new Stack&lt;&gt;();
        s2 = new Stack&lt;&gt;();
    }
    public void push(int x) {
        s1.push(x);
    }
    public int pop() {
        if(s2.empty()) {
            while(!s1.empty()) {
                s2.push(s1.pop());
            }
        }
        return s2.pop();
    }
    public int peek() {
        if(s2.empty()){
            while(!s1.empty()){
                s2.push(s1.pop());
            }
        }
        return s2.peek();
    }
    public boolean empty() {
        return s1.empty() &amp;&amp; s2.empty();
    }
}</code></pre> 
<p>以上就是栈和队列的所有内容了，在这里博主还是要说一句，要想理解栈和队列还是要多多刷类似的题目，一定可以更好的理解他们的使用</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/623cd219af19b7cf58fbfb78d573df0d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据结构-迷宫问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/032768d257b88936fc82af56733e197d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python-pip国内常用镜像及使用方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>