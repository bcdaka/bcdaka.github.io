<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构之初始二叉树（4） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4fa5217edd47c4df82f5886f7bb7a2e2/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构之初始二叉树（4）">
  <meta property="og:description" content="找往期文章包括但不限于本期文章中不懂的知识点：
个人主页：我要学编程(ಥ_ಥ)-CSDN博客
所属专栏：数据结构（Java版）
二叉树的基本操作
二叉树的相关刷题（上）通过上篇文章的学习，我们简单的了解了二叉树的相关操作。接下来就是有关二叉树的经典题型练习。
二叉树的相关刷题（上）
上一篇也是有关二叉树的经典题型。沿着上篇接着开始学习。
目录
二叉树的前序遍历
二叉树的层序遍历
二叉树的层序遍历 II
从前序与中序遍历序列构造二叉树
二叉树的最近公共祖先
根据二叉树创建字符串
二叉树的前序遍历 题目：
给你二叉树的根节点 root ，返回它节点值的 前序 遍历。
示例 1：
输入：root = [1,null,2,3] 输出：[1,2,3] 示例 2：
输入：root = [] 输出：[] 示例 3：
输入：root = [1] 输出：[1] 示例 4：
输入：root = [1,2] 输出：[1,2] 示例 5：
输入：root = [1,null,2] 输出：[1,2] 提示：
树中节点数目在范围 [0, 100] 内-100 &lt;= Node.val &lt;= 100 这个题目如果用递归去做那就比较简单了，但是现在我们要采用非递归的方法来写。
思路：利用栈，将遍历到的所有根结点都入栈（以前序遍历的路线去走） ，并且将这些节点都放入List当中。当遇到 null 时，就开始出栈顶的元素，并且以栈顶元素的 right 指针来重新遍历这棵树，直至栈为空即可。
代码实现：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-22T20:17:27+08:00">
    <meta property="article:modified_time" content="2024-07-22T20:17:27+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构之初始二叉树（4）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>找往期文章包括但不限于本期文章中不懂的知识点：</p> 
<blockquote> 
 <p><strong>个人主页：</strong><a href="https://blog.csdn.net/2301_80854132?type=blog" title="我要学编程(ಥ_ಥ)-CSDN博客">我要学编程(ಥ_ಥ)-CSDN博客</a></p> 
 <p><strong>所属专栏：<strong><strong><strong><strong><strong><strong><strong><a href="https://blog.csdn.net/2301_80854132/category_12650676.html" title="数据结构（Java版）">数据结构（Java版）</a></strong></strong></strong></strong></strong></strong></strong></strong></p> 
</blockquote> 
<p><a href="https://blog.csdn.net/2301_80854132/article/details/140419482?spm=1001.2014.3001.5502" title="二叉树的基本操作">二叉树的基本操作</a></p> 
<p><a href="https://blog.csdn.net/2301_80854132/article/details/140442878?spm=1001.2014.3001.5502" title="二叉树的相关刷题（上）">二叉树的相关刷题（上）</a>通过上篇文章的学习，我们简单的了解了二叉树的相关操作。接下来就是有关二叉树的经典题型练习。</p> 
<p><a href="https://blog.csdn.net/2301_80854132/article/details/140442878?spm=1001.2014.3001.5502" title="二叉树的相关刷题（上）">二叉树的相关刷题（上）</a></p> 
<p>上一篇也是有关二叉树的经典题型。沿着上篇接着开始学习。</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86" rel="nofollow">二叉树的前序遍历</a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86" rel="nofollow">二叉树的层序遍历</a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%20II-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%20II" rel="nofollow">二叉树的层序遍历 II</a></p> 
<p id="%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:0px;"><a href="#%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">从前序与中序遍历序列构造二叉树</a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88" rel="nofollow">二叉树的最近公共祖先</a></p> 
<p id="%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2-toc" style="margin-left:0px;"><a href="#%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2" rel="nofollow">根据二叉树创建字符串</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86" style="background-color:transparent;"><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/" rel="nofollow" title="二叉树的前序遍历">二叉树的前序遍历</a></h2> 
<p>题目：</p> 
<blockquote> 
 <p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong><em> </em>遍历。</p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <p class="img-center"><img alt="" height="324" src="https://images2.imgbox.com/e4/ab/dbMLFyi8_o.jpg" width="202"></p> 
 <pre><strong>输入：</strong>root = [1,null,2,3]
<strong>输出：</strong>[1,2,3]
</pre> 
 <p><strong>示例 2：</strong></p> 
 <pre><strong>输入：</strong>root = []
<strong>输出：</strong>[]
</pre> 
 <p><strong>示例 3：</strong></p> 
 <pre><strong>输入：</strong>root = [1]
<strong>输出：</strong>[1]
</pre> 
 <p><strong>示例 4：</strong></p> 
 <p class="img-center"><img alt="" height="202" src="https://images2.imgbox.com/40/3f/Eom8iM2y_o.jpg" width="202"></p> 
 <pre><strong>输入：</strong>root = [1,2]
<strong>输出：</strong>[1,2]
</pre> 
 <p><strong>示例 5：</strong></p> 
 <p class="img-center"><img alt="" height="202" src="https://images2.imgbox.com/f0/12/KOuFEXjc_o.jpg" width="202"></p> 
 <pre><strong>输入：</strong>root = [1,null,2]
<strong>输出：</strong>[1,2]

</pre> 
 <p><strong>提示：</strong></p> 
 <ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul> 
</blockquote> 
<p>这个题目如果用递归去做那就比较简单了，但是现在我们要采用非递归的方法来写。</p> 
<p>思路：利用栈，将遍历到的所有根结点都入栈（以前序遍历的路线去走） ，并且将这些节点都放入List当中。当遇到 null 时，就开始出栈顶的元素，并且以栈顶元素的 right 指针来重新遍历这棵树，直至栈为空即可。</p> 
<p><img alt="" height="1149" src="https://images2.imgbox.com/8c/f2/W6FlpvxP_o.png" width="1200"></p> 
<p>代码实现：</p> 
<pre><code class="language-java">class Solution {
    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
        List&lt;Integer&gt; list = new LinkedList&lt;&gt;();
        if (root == null) {
            return list;
        }
        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
        TreeNode cur = root;
        // 因为第一次时，这个循环进不来，所以就加了 cur != null 这个条件
        while (cur != null || !stack.isEmpty()) {
            while (cur != null) {
                // 根结点
                stack.push(cur);
                list.add(cur.val);
                // 左子树
                cur = cur.left;
            }
            TreeNode top = stack.pop();
            // 右子树
            cur = top.right;
        }
        return list;
    }
}</code></pre> 
<p>既然前序遍历的代码出来了，那么中序遍历和后序遍历也就可以搞定了。</p> 
<p><a class="link-info" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/" rel="nofollow" title="中序遍历">中序遍历</a>：</p> 
<pre><code class="language-java">class Solution {
    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {
        List&lt;Integer&gt; list = new LinkedList&lt;&gt;();
        if (root == null) {
            return list;
        }
        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
        TreeNode cur = root;
        while (cur != null || !stack.isEmpty()) {
            while (cur != null) {
                // 左子树
                stack.push(cur);
                cur = cur.left;
            }
            TreeNode top = stack.pop();
            // 根结点
            list.add(top.val);
            // 右子树
            cur = top.right;
        }
        return list;
    }
}</code></pre> 
<p><a class="link-info" href="https://leetcode.cn/problems/construct-string-from-binary-tree/description/" rel="nofollow" title="后序遍历">后序遍历</a>：</p> 
<pre><code class="language-java">class Solution {
    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
        List&lt;Integer&gt; list = new LinkedList&lt;&gt;();
        if (root == null) { 
            return list;
        }
        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
        TreeNode cur = root;
        TreeNode prev = null; // 记录添加的前一个位置（防止死循环）
        while (cur != null || !stack.isEmpty()) {
            while (cur != null) {
                stack.push(cur);
                cur = cur.left;
            }
            // 注意这里不能是pop，因为我们不能确定这个节点的右边是否还有节点
            TreeNode top = stack.peek();
            // 如果右边还有元素，那就得去遍历它；否则，就打印（左为null，右也为null）
            if (top.right == null || top.right == prev) { // 右边被处理过才能进来
                list.add(top.val);
                prev = stack.pop(); // 更新为前一个位置的值 
            } else {
                cur = top.right;
            }
        }
        return list;
    }
}</code></pre> 
<p> 总结：其实只要我们知道遍历的顺序，从遍历顺序去解决，那么这种题目就迎刃而解了。</p> 
<h2 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><a class="link-info" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/" rel="nofollow" title="二叉树的层序遍历">二叉树的层序遍历</a></h2> 
<p>题目：</p> 
<blockquote> 
 <p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <p class="img-center"><img alt="" height="302" src="https://images2.imgbox.com/8b/3f/vvjVttzg_o.jpg" width="277"></p> 
 <pre><strong>输入：</strong>root = [3,9,20,null,null,15,7]
<strong>输出：</strong>[[3],[9,20],[15,7]]
</pre> 
 <p><strong>示例 2：</strong></p> 
 <pre><strong>输入：</strong>root = [1]
<strong>输出：</strong>[[1]]
</pre> 
 <p><strong>示例 3：</strong></p> 
 <pre><strong>输入：</strong>root = []
<strong>输出：</strong>[]

</pre> 
 <p><strong>提示：</strong></p> 
 <ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul> 
</blockquote> 
<p>思路：通过队列来存储树中的节点，先储存根结点，再把根结点出队，判断左右子树是否为空，来使其入队。 </p> 
<p><img alt="" height="720" src="https://images2.imgbox.com/36/93/2Ytwkv6F_o.png" width="1200"></p> 
<p>代码实现：</p> 
<pre><code class="language-java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        List&lt;List&lt;Integer&gt;&gt; ret = new LinkedList&lt;&gt;();
        // 通过队列进行层序遍历
        if (root == null) {
            return ret;
        }
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);
        while (!queue.isEmpty()) {
            List&lt;Integer&gt; list = new LinkedList&lt;&gt;();
            // 记录每一层的个数
            int size = queue.size();    
            // 先把每一层的节点都放到list中
            while (size-- &gt; 0) {
                TreeNode cur = queue.poll();
                list.add(cur.val);
                if (cur.left != null) {
                    queue.offer(cur.left);
                }
                if (cur.right != null) {
                    queue.offer(cur.right);
                }
            }
            // 再把每一层的list放到总的ret中
            ret.add(list);
        }
        return ret;
    }
}</code></pre> 
<p>刚刚我们是从上往下遍历这棵树的，现在如果让我们从下往上遍历这棵树呢？</p> 
<h2 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%20II" style="background-color:transparent;"><a class="link-info" href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/" rel="nofollow" title="二叉树的层序遍历 II">二叉树的层序遍历 II</a></h2> 
<p>题目：</p> 
<blockquote> 
 <p>给你二叉树的根节点 <code>root</code> ，返回其节点值 <strong>自底向上的层序遍历</strong> 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <p class="img-center"><img alt="" height="302" src="https://images2.imgbox.com/f9/da/WVMauMgP_o.jpg" width="277"></p> 
 <pre><strong>输入：</strong>root = [3,9,20,null,null,15,7]
<strong>输出：</strong>[[15,7],[9,20],[3]]
</pre> 
 <p><strong>示例 2：</strong></p> 
 <pre><strong>输入：</strong>root = [1]
<strong>输出：</strong>[[1]]
</pre> 
 <p><strong>示例 3：</strong></p> 
 <pre><strong>输入：</strong>root = []
<strong>输出：</strong>[]

</pre> 
 <p><strong>提示：</strong></p> 
 <ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul> 
</blockquote> 
<p>思路：从上往下我们已经知道了该怎么遍历，但是从下往上不知道该从何下手？这是我们就可以采用换汤不换药的方法了。即将从上到下的遍历结果储存起来，然后再交换两者的值即可。这样我们最终得到的值就是从下往上遍历的结果了。</p> 
<p>代码实现：</p> 
<pre><code class="language-java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) {
        List&lt;List&lt;Integer&gt;&gt; ret = new LinkedList&lt;&gt;();
        if (root == null) {
            return ret;
        }
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);
        while (!queue.isEmpty()) {
            List&lt;Integer&gt; list = new LinkedList&lt;&gt;();
            int size = queue.size();
            while (size-- &gt; 0) {
                TreeNode cur = queue.poll();
                list.add(cur.val);
                if (cur.left != null) {
                    queue.offer(cur.left);
                }
                if (cur.right != null) {
                    queue.offer(cur.right);
                }
            }
            ret.add(list);
        }
        // 现在ret中是按照从上往下的顺序存储的，我们需要的刚好相反，即需要交换
        swap(ret);
        return ret;
    }

    private void swap(List&lt;List&lt;Integer&gt;&gt; ret) {
        int left = 0;
        int right = ret.size()-1;
        while (left &lt; right) {
            // 交换
            List&lt;Integer&gt; tmp = ret.get(left);
            ret.set(left, ret.get(right));
            ret.set(right, tmp);
            left++;
            right--;
        }
    }
}</code></pre> 
<p>还有一种实现方式：就是在插入时，我们不采用尾插的方式，采用头插的方式去构建LIst。</p> 
<pre><code class="language-java">// 采用头插的方式
ret.addFirst(list);</code></pre> 
<p><span style="color:#956fe7;">前序遍历、中序遍历、后续遍历的迭代版实现和层序遍历的实现所用的数据结构不同的原因：</span></p> 
<p>不管是前序遍历、中序遍历还是后序遍历，都是左子树的遍历顺序在前，右子树的遍历顺序在后，这就导致了一个问题：如果根结点找不到了（先打印了，就出队列了），那么怎么去找右子树呢？因此我们的需求就是把二叉树的根结点存储起来，即让其最后再出去。这个的效果就是先进后出——&gt; 栈 ；而层序遍历就没有这样的需求了，即从上往下、从左往右依次遍历打印，那么我们打印完这一层的节点之后，就可以舍弃它们了。即先进先出——&gt;队列。</p> 
<p>前面我们学习了给了前序和中序遍历或者后续和中序遍历，来构建二叉树，现在我们就用代码来实现一下： </p> 
<h2 id="%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><a class="link-info" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/" rel="nofollow" title="从前序与中序遍历序列构造二叉树">从前序与中序遍历序列构造二叉树</a></h2> 
<p>题目： </p> 
<blockquote> 
 <p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p> 
 <p></p> 
 <p><strong>示例 1:</strong></p> 
 <p class="img-center"><img alt="" height="302" src="https://images2.imgbox.com/28/1f/0wZezGSM_o.jpg" width="277"></p> 
 <pre><strong>输入</strong><strong>:</strong> preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
<strong>输出:</strong> [3,9,20,null,null,15,7]
</pre> 
 <p><strong>示例 2:</strong></p> 
 <pre><strong>输入:</strong> preorder = [-1], inorder = [-1]
<strong>输出:</strong> [-1]

</pre> 
 <p><strong>提示:</strong></p> 
 <ul><li><code>1 &lt;= preorder.length &lt;= 3000</code></li><li><code>inorder.length == preorder.length</code></li><li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li><li><code>preorder</code> 和 <code>inorder</code> 均 <strong>无重复</strong> 元素</li><li><code>inorder</code> 均出现在 <code>preorder</code></li><li><code>preorder</code> <strong>保证</strong> 为二叉树的前序遍历序列</li><li><code>inorder</code> <strong>保证</strong> 为二叉树的中序遍历序列</li></ul> 
</blockquote> 
<p>思路：与我们做选填是一样的。通过前序遍历来确定二叉树的根结点，再通过根结点在中序遍历中的位置来确定左子树和右子树，而前序遍历往后，就是左子树的根结点，再确定在中序遍历中的位置来确定左子树的根结点的左子树和右子树。一直这样递归下去，直至左子树的下标大于右子树的下标（在中序遍历中） 。</p> 
<p><img alt="" height="542" src="https://images2.imgbox.com/ca/d4/oNIpz4BY_o.png" width="1200"></p> 
<p>代码实现： </p> 
<pre><code class="language-java">class Solution {
    // 创建一棵二叉树，先创建根结点，再创建左子树和右子树
    // 根结点就是根据前序遍历来找，
    // 左子树和右子树都是根据前序遍历和中序遍历来找出左子树和右子树的根结点
    private int rootIndex;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        
        return buildTreeChild(preorder, inorder, 0, inorder.length-1);
    }

    private TreeNode buildTreeChild(int[] preorder, int[] inorder, 
    int inorderbegin, int inorderend) {
        // 空树
        if (inorderbegin &gt; inorderend) {
            return null;
        }
        // 创建根结点
        TreeNode root = new TreeNode(preorder[rootIndex]);
        // 找到边界
        int border = findVal(inorder, preorder[rootIndex]);
        rootIndex++;
        // 创建左子树
        root.left = buildTreeChild(preorder, inorder, inorderbegin, border-1);
        // 创建右子树
        root.right = buildTreeChild(preorder, inorder, border+1, inorderend);
        return root;
    }
       
    // 找到根结点在中序遍历中的位置来划分左子树和右子树
    private int findVal(int[] inorder, int val) {
        for (int i = 0; i &lt; inorder.length; i++) {
            if (inorder[i] == val) {
                return i;
            }
        }
        return -1;
    }
}</code></pre> 
<p>前序学完了，还有后序：</p> 
<p><a class="link-info" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/" rel="nofollow" title="从中序与后序遍历序列构造二叉树">从中序与后序遍历序列构造二叉树</a></p> 
<p>思路：后序遍历同样是确定根结点的位置，从后序遍历数组的末尾开始遍历根节点，在中序遍历中寻找到根结点的位置并划分左右子树。与上述思路类似。</p> 
<p>注意：后序遍历是：左子树 右子树 根；而前序遍历是：根 左子树 右子树 。这也就意味着前序遍历找到的根是左子树的根（除祖先节点外） ，即我们先得创建左子树；而后序遍历找到的根是右子树的根（除祖先节点外），即我们先得创建右子树。因为创建二叉树其实就是依赖于根结点，谁于根结点临近创建谁。</p> 
<pre><code class="language-java">class Solution {
    // 后续遍历找到根结点，再根据根结点确定左子树和右子树
    private int rootIndex;
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        rootIndex = postorder.length-1;
        return buildTreeChild(inorder, postorder, 0, inorder.length-1);
    }

    private TreeNode buildTreeChild(int[] inorder, int[] postorder,
    int inorderbegin, int inorderend) {
        if (inorderbegin &gt; inorderend) {
            return null;
        }
        TreeNode root = new TreeNode(postorder[rootIndex]);
        // 在中序遍历的数组中找到根结点的位置
        int border = findVal(inorder, postorder[rootIndex]);
        rootIndex--;
        root.right = buildTreeChild(inorder, postorder, border+1, inorderend);
        root.left = buildTreeChild(inorder, postorder, inorderbegin, border-1);
        return root;
    }

    private int findVal(int[] inorder, int val) {
        for (int i = 0; i &lt; inorder.length; i++) {
            if (inorder[i] == val) {
                return i;
            }
        }
        return -1;
    }
}</code></pre> 
<h2 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><a class="link-info" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/" rel="nofollow" title="二叉树的最近公共祖先"><span style="color:#fe2c24;">二叉树的最近公共祖先</span></a></h2> 
<p>题目： </p> 
<blockquote> 
 <p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p> 
 <p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin" rel="nofollow" title="百度百科">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <p class="img-center"><img alt="" height="190" src="https://images2.imgbox.com/d9/8d/SMJdDbxt_o.png" width="200"></p> 
 <pre><strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
<strong>输出：</strong>3
<strong>解释：</strong>节点 <code>5 </code>和节点 <code>1 </code>的最近公共祖先是节点 <code>3 。</code>
</pre> 
 <p><strong>示例 2：</strong></p> 
 <p class="img-center"><img alt="" height="190" src="https://images2.imgbox.com/7e/36/aRwdN8ZR_o.png" width="200"></p> 
 <pre><strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
<strong>输出：</strong>5
<strong>解释：</strong>节点 <code>5 </code>和节点 <code>4 </code>的最近公共祖先是节点 <code>5 。</code>因为根据定义最近公共祖先节点可以为节点本身。
</pre> 
 <p><strong>示例 3：</strong></p> 
 <pre><strong>输入：</strong>root = [1,2], p = 1, q = 2
<strong>输出：</strong>1

</pre> 
 <p><strong>提示：</strong></p> 
 <ul><li>树中节点数目在范围 <code>[2, 105]</code> 内。</li><li><code>-109 &lt;= Node.val &lt;= 109</code></li><li>所有 <code>Node.val</code> <code>互不相同</code> 。</li><li><code>p != q</code></li><li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li></ul> 
</blockquote> 
<p>思路一：采用穷举的方法，看看会出现几种情况。</p> 
<p><img alt="" height="731" src="https://images2.imgbox.com/2e/72/0086ICth_o.png" width="1200"></p> 
<p>上面三种情况其实就是通过示例总结出来的 </p> 
<p> 代码实现：</p> 
<pre><code class="language-java">class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // 在递归去寻找的过程中可能会出现下面两种情况（限制条件）
        if (root == null) {
            return null;
        }
        if (root == q || root == p) {
            return root;
        }
        // 走到这里说明根结点一定不存在，则判断左子树和右子树即可
        // 遍历左子树
        TreeNode leftTree = lowestCommonAncestor(root.left, p, q);
        // 遍历右子树
        TreeNode rightTree = lowestCommonAncestor(root.right, p, q);
        // 再遍历完成之后，我们就来判断是哪种情况
        if (leftTree != null &amp;&amp; rightTree != null) {
            return root;
        }
        if (leftTree != null &amp;&amp; rightTree == null) {
            return leftTree;
        }
        // 下面的代码可以简化为 return rightTree;
        if (leftTree == null &amp;&amp; rightTree != null) {
            return rightTree;
        }
        return null;
    }
}</code></pre> 
<p>如果我们总结不出来，也没关系。还有另外一种方法，就是把p和q出现的路线储存起来，然后再去一 一比较，遇到第一个相等的就是公共的祖先。</p> 
<p>首先，得确定是用什么数据结构来储存路线。栈 还是 队列呢？其实都是可以的。因为我们采用的是从上往下遍历，那么根结点一定是最先被放入栈（队列）中的。而我们比较的方式不同，就导致了储存的方式不同。如果我们是想找不同，那就得用队列，从根结点开始比较；如果我们是想找相同，那就得用栈，从p和q开始比较，找到相同的节点。</p> 
<p>栈的实现方式：</p> 
<pre><code class="language-java">class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        Stack&lt;TreeNode&gt; stackP = new Stack&lt;&gt;();
        Stack&lt;TreeNode&gt; stackQ = new Stack&lt;&gt;();
        getPath(root, p, stackP);
        getPath(root, q, stackQ);
        // 先让长的走差值步数
        if (stackP.size() &gt; stackQ.size()) {
            int size = stackP.size() - stackQ.size();
            while (size-- &gt; 0) {
                stackP.pop();
            }
        } else {
            int size = stackQ.size() - stackP.size();
            while (size-- &gt; 0) {
                stackQ.pop();
            }
        }
        // 开始一起出
        while (stackQ.peek() != stackP.peek()) {
            stackQ.pop();
            stackP.pop();
        }
        return stackQ.peek();
    }

    private TreeNode getPath(TreeNode root, TreeNode target, Stack&lt;TreeNode&gt; stack) {
        if (root == null) {
            return null;
        }
        stack.push(root); // 先得把这个入栈
        if (root == target) {
            return root;
        }
        // 左子树
        TreeNode leftTree = getPath(root.left, target, stack);
        if (leftTree != null) { // 左子树不为null，说明在左子树找到了，即返回
            return leftTree;
        }
        // 右子树
        TreeNode rightTree = getPath(root.right, target, stack);
        if (rightTree != null) { // 右子树不为null，说明在右子树找到了，即返回
            return rightTree;
        }
        // 左右子树的遍历结果都是null，即都没找到，就出栈
        if (leftTree == null &amp;&amp; rightTree == null) {
            stack.pop();
        }
        return null;
    }
}</code></pre> 
<p>在用队列去写时，我们就会发现一个问题：如果左右子树都为null，那么证明这个节点不是我们路径上的节点，就得出队，但是队列的数据是先进先出的特点，不满足我们的要求，即普通队列是不行的。因此，就只能用栈。</p> 
<p>我们在分析问题时，可能刚刚不会遇到这点，但是后面在做题时，体会到了这点就行，不管是什么思路，我们都得上手去写才可以。</p> 
<h2 id="%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2" style="background-color:transparent;"><a class="link-info" href="https://leetcode.cn/problems/construct-string-from-binary-tree/description/" rel="nofollow" title="根据二叉树创建字符串"><span style="color:#fe2c24;">根据二叉树创建字符串</span></a></h2> 
<p>题目：</p> 
<blockquote> 
 <p>给你二叉树的根节点 <code>root</code> ，请你采用前序遍历的方式，将二叉树转化为一个由括号和整数组成的字符串，返回构造出的字符串。</p> 
 <p>空节点使用一对空括号对 <code>"()"</code> 表示，转化后需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。</p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <p></p> 
 <p class="img-center"><img alt="" height="301" src="https://images2.imgbox.com/97/f0/grIem4MN_o.jpg" width="292"></p> 
 <pre><strong>输入：</strong>root = [1,2,3,4]
<strong>输出：</strong>"1(2(4))(3)"
<strong>解释：</strong>初步转化后得到 "1(2(4)())(3()())" ，但省略所有不必要的空括号对后，字符串应该是"1(2(4))(3)" 。
</pre> 
 <p><strong>示例 2：</strong></p> 
 <p></p> 
 <p class="img-center"><img alt="" height="293" src="https://images2.imgbox.com/05/49/gk8uYeBA_o.jpg" width="207"></p> 
 <pre><strong>输入：</strong>root = [1,2,3,null,4]
<strong>输出：</strong>"1(2()(4))(3)"
<strong>解释：</strong>和第一个示例类似，但是无法省略第一个空括号对，否则会破坏输入与输出一一映射的关系。
</pre> 
 <p><strong>提示：</strong></p> 
 <ul><li>树中节点的数目范围是 <code>[1, 104]</code></li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul> 
</blockquote> 
<p>思路：根据示例，我们就可以看出：遇到左子树就得添加“（”，当左子树走完，就得添加“）”，当左子树为null，并且右子树不为null时，得添加“（）”。 </p> 
<p>代码实现：</p> 
<pre><code class="language-java">class Solution {
    // 通过 StringBuild 来构建字符串
    private StringBuilder sb = new StringBuilder();
    public String tree2str(TreeNode root) {
        dfs(root);
        return sb.toString();
    }
    
    private void dfs(TreeNode root) {
        if (root == null) {
            return;
        }
        // 根结点
        sb.append(root.val);
        // 根的左子树
        if (root.left != null) {
            sb.append("(");
            // 继续递归去左子树寻找
            dfs(root.left);
            // 左子树走完了得加右括号
            sb.append(")");
        } else {
            if (root.right != null) {
                // 左边添加一对空括号
                sb.append("()");
            } else {
                return;
            }
        }
        // 根的右子树
        if (root.right != null) {
            sb.append("(");
            dfs(root.right);
            sb.append(")");
        } else {
            return;
        }
    }
}</code></pre> 
<p>总结：通过上面几题的练习，我们不难发现其实有的题目需要我们去利用示例的规律来写，但更多的题目是需要我们对数据结构进行不断的学习和熟练，这样才能更加得心应手。 </p> 
<p>好啦！本期 数据结构之初始二叉树（4）的学习之旅就到此结束啦！二叉树的折磨也是暂时的结束啦！即将开启新的数据结构之旅！我们下一期再一起学习吧！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fa6e87a29943ee1c403a5ee9f40eeb9a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">5.波士顿房价预测（KNN，决策树，线性回归）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ab1223db435bc98d082a995fa62480fe/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">05 HTTP &amp; Tomcat &amp; Servlet</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>