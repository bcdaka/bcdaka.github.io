<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Datawhale AI 夏令营】基于术语词典干预的机器翻译挑战赛——机器翻译入门极速版【笔记】 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/54f8be67ef99bbe737849990db2316f3/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【Datawhale AI 夏令营】基于术语词典干预的机器翻译挑战赛——机器翻译入门极速版【笔记】">
  <meta property="og:description" content="嗨！大家好呀，今天是一期关于NLP的机器翻译的入门指南，对于参加datawhale第二期夏令营基于术语词典干预的机器翻译挑战赛的同学来说是一期很简单的入门，在这里呢介绍了什么是NLP，什么是机器翻译，的也请各位大佬对本期内容进行补充和指正，方便夏令营的同学快速入门~
那么首先
什么是自然语言处理NLP 自然语言处理（Natural Language Processing，简称NLP）是人工智能和语言学领域的一个分支，它使计算机能够理解、解释和生成人类语言。NLP的目的是缩小人类语言和计算机之间的差距，使计算机能够执行如下任务：
语音识别：将语音转换为文本，这是NLP的第一步，它允许计算机“听到”人类语言。
自然语言理解（NLU）：使计算机能够理解语言的含义，包括语义、语法和上下文。
自然语言生成（NLG）：使计算机能够生成语言，这可以是文本或语音。
是的，NLP的核心任务就是NLU和NLG，那么到底什么是NLP呢？
NLP就是让计算机理解、解释和生成人类的自然语言。打个比方，当你和Siri对话时，或使用有道翻译翻译一句话或者一篇文章，这背后都是NLP在发挥作用。说得简单点，NLP就是让计算机变得更“懂”我们说的话、写的文字。
自然语言处理任务怎么进行 数据预处理：
文本清洗：去除文本中的噪声，如HTML标签、特殊字符等。
分词（Tokenization）：将文本分解成单词、短语或其他有意义的元素。
去除停用词：移除常见的、对文本意义贡献不大的词汇，如“的”、“是”等。
词干提取（Stemming）和词形还原（Lemmatization）：将词汇还原到基本形式。
特征提取：
词袋模型（Bag of Words）：将文本转换为单词出现的频率向量。
TF-IDF（Term Frequency-Inverse Document Frequency）：考虑单词在文档中的频率和在语料库中的稀有度。
词嵌入（Word Embeddings）：如Word2Vec、GloVe，将单词转换为密集的向量表示。
模型训练：
使用提取的特征训练机器学习或深度学习模型。
常见的模型包括支持向量机（SVM）、随机森林、递归神经网络（RNN）、卷积神经网络（CNN）和Transformer。
模型评估：
使用混淆矩阵、精确度、召回率、F1分数等指标评估模型性能。
通过交叉验证来确保模型的泛化能力。
应用部署：
将训练好的模型部署到实际应用中，如聊天机器人、推荐系统、自动翻译等。
NLP的分类，都有什么作用 语音识别：将语音信号转换为文本，如Google语音识别。
语音合成：将文本转换为语音信号，如Google文本转语音。
机器翻译：将一种语言的文本转换为另一种语言的文本，如Google翻译。
情感分析：识别和提取文本中的情感倾向，如正面、负面或中性。
文本分类：将文本自动分类到预定义的类别中，如新闻分类。
信息检索：从大量文档中检索相关信息，如搜索引擎。
问答系统：自动回答用户提出的问题，如Siri、Alexa。
文本摘要：生成文本的简短摘要，如新闻摘要。
命名实体识别（NER）：识别文本中的专有名词，如人名、地名、组织名等。
词性标注：为文本中的每个单词标注其词性，如名词、动词等。
依存句法分析：分析句子中单词之间的依存关系，如主谓宾结构。
语义分析：理解文本的深层含义，包括语义角色标注和语义依存分析。
对话系统：模拟人类对话，如聊天机器人。
文本生成：自动生成文本，如自动写作。
自然语言处理是一个多学科交叉的领域，涉及到计算机科学、人工智能、语言学、认知科学等多个学科。随着深度学习的发展，NLP领域取得了显著的进步，尤其是在语言模型和机器翻译方面。
那么，什么是机器翻译呢 机器翻译（Machine Translation, MT）是利用先进的计算机技术将一种语言转换成另一种语言的过程，它为全球沟通提供了一种高效的解决方案。
它的原理是什么 机器翻译的核心原理在于使计算机掌握不同语言之间的对应关系。这类似于教授儿童学习两种语言，通过不断的练习和记忆，孩子们能够理解和使用这两种语言进行交流。机器翻译通过分析丰富的双语文本数据，学习不同语言之间的词汇、语法和表达方式的映射关系。
如何实现 数据准备：收集广泛的双语对照文本，包括书籍、文章、对话记录等，为训练提供丰富的语料库。
预处理：对收集到的文本进行清洗和格式化，包括分词、去除停用词、统一大小写等，以提高数据质量。
训练模型：利用预处理后的数据训练机器翻译模型，使其学习源语言和目标语言之间的对应关系。
翻译执行：模型训练完成后，输入源语言文本，模型根据学习到的对应关系生成目标语言的翻译。
后处理优化：对模型生成的翻译进行调整，如修正语法错误、调整语序等，以提升翻译的准确性和流畅性。
目前主流模型有哪些 基于规则的机器翻译（Rule-based MT）： 依赖语言学家制定的规则，包括词汇、语法和句法规则，适用于需要高度准确性的翻译场景。
尽管需要大量人工干预，但在处理特定语言结构时表现出色。
基于统计的机器翻译（Statistical MT）： 通过分析大量双语文本数据，统计不同词汇和短语的对应关系，适用于处理大规模语言数据。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-12T13:56:44+08:00">
    <meta property="article:modified_time" content="2024-07-12T13:56:44+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Datawhale AI 夏令营】基于术语词典干预的机器翻译挑战赛——机器翻译入门极速版【笔记】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>嗨！大家好呀，今天是一期关于NLP的机器翻译的入门指南，对于参加datawhale第二期夏令营基于术语词典干预的机器翻译挑战赛的同学来说是一期很简单的入门，在这里呢介绍了什么是NLP，什么是机器翻译，的也请各位大佬对本期内容进行补充和指正，方便夏令营的同学快速入门~</p> 
<p>那么首先</p> 
<h3>什么是自然语言处理NLP</h3> 
<p>自然语言处理（Natural Language Processing，简称NLP）是人工智能和语言学领域的一个分支，它使计算机能够理解、解释和生成人类语言。NLP的目的是缩小人类语言和计算机之间的差距，使计算机能够执行如下任务：</p> 
<ol><li> <p><strong>语音识别</strong>：将语音转换为文本，这是NLP的第一步，它允许计算机“听到”人类语言。</p> </li><li> <p><strong>自然语言理解</strong>（NLU）：使计算机能够理解语言的含义，包括语义、语法和上下文。</p> </li><li> <p><strong>自然语言生成</strong>（NLG）：使计算机能够生成语言，这可以是文本或语音。</p> </li></ol> 
<p>是的，NLP的<strong>核心</strong>任务就是NLU和NLG，那么到底什么是NLP呢？</p> 
<p>NLP就是让计算机理解、解释和生成人类的自然语言。打个比方，当你和Siri对话时，或使用有道翻译翻译一句话或者一篇文章，这背后都是NLP在发挥作用。说得简单点，NLP就是让计算机变得更“懂”我们说的话、写的文字。</p> 
<h4>自然语言处理任务怎么进行</h4> 
<ol><li> <p><strong>数据预处理</strong>：</p> 
  <ul><li> <p><strong>文本清洗</strong>：去除文本中的噪声，如HTML标签、特殊字符等。</p> </li><li> <p><strong>分词</strong>（Tokenization）：将文本分解成单词、短语或其他有意义的元素。</p> </li><li> <p><strong>去除停用词</strong>：移除常见的、对文本意义贡献不大的词汇，如“的”、“是”等。</p> </li><li> <p><strong>词干提取</strong>（Stemming）和<strong>词形还原</strong>（Lemmatization）：将词汇还原到基本形式。</p> </li></ul></li><li> <p><strong>特征提取</strong>：</p> 
  <ul><li> <p><strong>词袋模型</strong>（Bag of Words）：将文本转换为单词出现的频率向量。</p> </li><li> <p><strong>TF-IDF</strong>（Term Frequency-Inverse Document Frequency）：考虑单词在文档中的频率和在语料库中的稀有度。</p> </li><li> <p><strong>词嵌入</strong>（Word Embeddings）：如Word2Vec、GloVe，将单词转换为密集的向量表示。</p> </li></ul></li><li> <p><strong>模型训练</strong>：</p> 
  <ul><li> <p>使用提取的特征训练机器学习或深度学习模型。</p> </li><li> <p>常见的模型包括支持向量机（SVM）、随机森林、递归神经网络（RNN）、卷积神经网络（CNN）和Transformer。</p> </li></ul></li><li> <p><strong>模型评估</strong>：</p> 
  <ul><li> <p>使用混淆矩阵、精确度、召回率、F1分数等指标评估模型性能。</p> </li><li> <p>通过交叉验证来确保模型的泛化能力。</p> </li></ul></li><li> <p><strong>应用部署</strong>：</p> 
  <ul><li> <p>将训练好的模型部署到实际应用中，如聊天机器人、推荐系统、自动翻译等。</p> </li></ul></li></ol> 
<h4>NLP的分类，都有什么作用</h4> 
<ol><li> <p><strong>语音识别</strong>：将语音信号转换为文本，如Google语音识别。</p> </li><li> <p><strong>语音合成</strong>：将文本转换为语音信号，如Google文本转语音。</p> </li><li> <p><strong>机器翻译</strong>：将一种语言的文本转换为另一种语言的文本，如Google翻译。</p> </li><li> <p><strong>情感分析</strong>：识别和提取文本中的情感倾向，如正面、负面或中性。</p> </li><li> <p><strong>文本分类</strong>：将文本自动分类到预定义的类别中，如新闻分类。</p> </li><li> <p><strong>信息检索</strong>：从大量文档中检索相关信息，如搜索引擎。</p> </li><li> <p><strong>问答系统</strong>：自动回答用户提出的问题，如Siri、Alexa。</p> </li><li> <p><strong>文本摘要</strong>：生成文本的简短摘要，如新闻摘要。</p> </li><li> <p><strong>命名实体识别</strong>（NER）：识别文本中的专有名词，如人名、地名、组织名等。</p> </li><li> <p><strong>词性标注</strong>：为文本中的每个单词标注其词性，如名词、动词等。</p> </li><li> <p><strong>依存句法分析</strong>：分析句子中单词之间的依存关系，如主谓宾结构。</p> </li><li> <p><strong>语义分析</strong>：理解文本的深层含义，包括语义角色标注和语义依存分析。</p> </li><li> <p><strong>对话系统</strong>：模拟人类对话，如聊天机器人。</p> </li><li> <p><strong>文本生成</strong>：自动生成文本，如自动写作。</p> </li></ol> 
<p>自然语言处理是一个多学科交叉的领域，涉及到计算机科学、人工智能、语言学、认知科学等多个学科。随着深度学习的发展，NLP领域取得了显著的进步，尤其是在语言模型和机器翻译方面。</p> 
<p></p> 
<h3>那么，什么是机器翻译呢</h3> 
<p>机器翻译（Machine Translation, MT）是利用先进的计算机技术将一种语言转换成另一种语言的过程，它为全球沟通提供了一种高效的解决方案。</p> 
<h4>它的原理是什么</h4> 
<p>机器翻译的核心原理在于使计算机掌握不同语言之间的对应关系。这类似于教授儿童学习两种语言，通过不断的练习和记忆，孩子们能够理解和使用这两种语言进行交流。机器翻译通过分析丰富的双语文本数据，学习不同语言之间的词汇、语法和表达方式的映射关系。</p> 
<h4>如何实现</h4> 
<ol><li> <p><strong>数据准备</strong>：收集广泛的双语对照文本，包括书籍、文章、对话记录等，为训练提供丰富的语料库。</p> </li><li> <p><strong>预处理</strong>：对收集到的文本进行清洗和格式化，包括分词、去除停用词、统一大小写等，以提高数据质量。</p> </li><li> <p><strong>训练模型</strong>：利用预处理后的数据训练机器翻译模型，使其学习源语言和目标语言之间的对应关系。</p> </li><li> <p><strong>翻译执行</strong>：模型训练完成后，输入源语言文本，模型根据学习到的对应关系生成目标语言的翻译。</p> </li><li> <p><strong>后处理优化</strong>：对模型生成的翻译进行调整，如修正语法错误、调整语序等，以提升翻译的准确性和流畅性。</p> </li></ol> 
<h4>目前主流模型有哪些</h4> 
<ol><li> <h5><strong>基于规则的机器翻译（Rule-based MT）</strong>：</h5> 
  <ul><li> <p>依赖语言学家制定的规则，包括词汇、语法和句法规则，适用于需要高度准确性的翻译场景。</p> </li><li> <p>尽管需要大量人工干预，但在处理特定语言结构时表现出色。</p> </li></ul></li><li> <h5><strong>基于统计的机器翻译（Statistical MT）</strong>：</h5> 
  <ul><li> <p>通过分析大量双语文本数据，统计不同词汇和短语的对应关系，适用于处理大规模语言数据。</p> </li><li> <p>尽管在处理歧义和上下文依赖的语言现象时可能存在局限性，但在资源充足的情况下表现良好。</p> </li></ul></li><li> <h5><strong>基于神经网络的机器翻译（Neural MT）</strong>：</h5> 
  <ul><li> <p>采用深度学习技术，特别是循环神经网络（RNN）和注意力机制（Attention Mechanism），提供更自然流畅的翻译结果。</p> </li><li> <p>尽管需要大量的计算资源和训练数据，但其在捕捉语言复杂性和上下文信息方面的优势明显。</p> </li></ul></li><li> <h5><strong>基于Transformer的机器翻译</strong>：</h5> 
  <ul><li> <p>利用自注意力机制（Self-Attention），并行处理整个句子，显著提高了翻译速度和处理长距离依赖关系的能力。</p> </li><li> <p>作为目前最先进的机器翻译模型之一，Transformer在多种语言对的翻译任务中表现出色。</p> </li></ul></li><li> <h5><strong>基于BERT的机器翻译</strong>：</h5> 
  <ul><li> <p>BERT（Bidirectional Encoder Representations from Transformers）通过预训练学习语言的深层表示，提高了翻译的准确性和自然度。</p> </li><li> <p>其对上下文信息的深刻理解，为机器翻译领域带来了革命性的进步。</p> </li></ul></li></ol> 
<h4>要学习的技术有哪些</h4> 
<h5>1. 分词（Tokenization）</h5> 
<p>分词是将文本分解成单词、短语或其他有意义的单元的过程，它是自然语言处理的第一步。在机器翻译中，分词帮助模型理解文本的结构。</p> 
<pre><code class="language-python">from nltk.tokenize import word_tokenize
​
text = "Hello, world! This is an example of tokenization."
tokens = word_tokenize(text)
​
print(tokens)
# 输出: ['Hello', ',', 'world', '!', 'This', 'is', 'an', 'example', 'of', 'tokenization', '.']</code></pre> 
<h5>2. 词嵌入（Word Embeddings）</h5> 
<p>词嵌入是将词汇转换为数值向量的技术，这些向量捕捉了词汇的语义和语法特征。高质量的词嵌入对于机器翻译模型的性能至关重要。</p> 
<pre><code class="language-python">import torch
from torch.nn import Embedding
​
# 在这里定义一张简化的词汇表
vocab = {
    "&lt;PAD&gt;": 0,  # 填充符
    "&lt;SOS&gt;": 1,  # 开始符
    "&lt;EOS&gt;": 2,  # 结束符
    "hello": 3,
    "world": 4,
    "this": 5,
    "is": 6,
    "an": 7,
    "example": 8,
    "of": 9
}
​
vocab_size = len(vocab)  # 词汇表大小
embedding_dim = 5  # 嵌入维度，这里为了简化为5
​
# 创建一个词嵌入层
embedding = Embedding(vocab_size, embedding_dim)
​
# 这里定义一些单词的索引
word_indices = torch.LongTensor([vocab["hello"], vocab["world"], vocab["example"]])
​
# 获取这些单词的嵌入向量
word_embeddings = embedding(word_indices)
​
print("Word indices:", word_indices)
print("Word embeddings:\n", word_embeddings)
# 输出: 一个形状为 [3, 5] 的张量，每行是一个单词的嵌入向量</code></pre> 
<h5>3. 序列到序列模型（Seq2Seq）</h5> 
<p>序列到序列模型（Seq2Seq）是一种深度学习模型，它能够将输入序列（源语言文本）转换为输出序列（目标语言文本）。这种模型通常用于机器翻译。</p> 
<pre><code class="language-python">import torch.nn as nn
​
class Seq2Seq(nn.Module):
    def __init__(self, encoder, decoder):
        super(Seq2Seq, self).__init__()
        self.encoder = encoder
        self.decoder = decoder
​
    def forward(self, source, target):
        # 编码源序列
        source_encoded = self.encoder(source)
        # 解码目标序列
        target_decoded = self.decoder(source_encoded)
        return target_decoded</code></pre> 
<h5>4. 注意力机制（Attention Mechanism）</h5> 
<p>注意力机制允许模型在翻译过程中关注输入文本的不同部分，这对于处理长距离依赖和歧义特别有用。</p> 
<pre><code class="language-python">class Attention(nn.Module):
    def __init__(self, hidden_dim):
        super(Attention, self).__init__()
        self.attention = nn.Linear(hidden_dim, 1)
​
    def forward(self, hidden_states):
        # hidden_states: [seq_len, batch_size, hidden_dim]
        attention_scores = self.attention(hidden_states).squeeze(2)
        # 使用softmax获取注意力权重
        attention_weights = torch.softmax(attention_scores, dim=0)
        # 计算加权的上下文向量
        context_vector = (hidden_states * attention_weights.unsqueeze(2)).sum(dim=0)
        return context_vector</code></pre> 
<h5>5. 自注意力机制（Self-Attention）</h5> 
<p>自注意力机制是Transformer模型的核心，它允许模型在处理一个单词时考虑到整个句子的信息。</p> 
<pre><code class="language-python">class SelfAttention(nn.Module):
    def __init__(self, hidden_dim):
        super(SelfAttention, self).__init__()
        self.query = nn.Linear(hidden_dim, hidden_dim)
        self.key = nn.Linear(hidden_dim, hidden_dim)
        self.value = nn.Linear(hidden_dim, hidden_dim)
​
    def forward(self, x):
        # x: [seq_len, batch_size, hidden_dim]
        query = self.query(x)  # [seq_len, batch_size, hidden_dim]
        key = self.key(x)      # [seq_len, batch_size, hidden_dim]
        value = self.value(x)  # [seq_len, batch_size, hidden_dim]
​
        scores = torch.matmul(query, key.transpose(-2, -1)) / (hidden_dim ** 0.5)
        attention_weights = torch.softmax(scores, dim=-1)
        context = torch.matmul(attention_weights, value)
        return context</code></pre> 
<h5>6. 预训练语言模型（Pre-trained Language Models）</h5> 
<p>预训练语言模型如BERT、GPT等，通过在大量文本上进行预训练，学习语言的深层表示，为机器翻译的改进提供了强有力的支持。</p> 
<pre><code class="language-python">from transformers import BertModel, BertTokenizer
​
# 加载预训练的BERT模型和分词器
tokenizer = BertTokenizer.from_pretrained('bert-base-uncased')
model = BertModel.from_pretrained('bert-base-uncased')
​
# 对文本进行分词
text = "The quick brown fox jumps over the lazy dog"
encoded_input = tokenizer(text, return_tensors='pt')
​
# 获取BERT的输出
output = model(**encoded_input)
​
# output.last_hidden_state 包含了文本的深层表示
print(output.last_hidden_state.shape)
# 输出: torch.Size([1, 序列长度, 隐藏层维度])</code></pre> 
<p>打怪通关，知己知彼方能百战不殆！</p> 
<p>本期内容就到这里，下一期我们来看一下datalwhale第二期夏令营基于术语词典干预的机器翻译挑战赛的baseline~</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9982abaea2fbd2b215df31ea24cd8182/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">n3.平滑升级和回滚</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ad45d5dca0c58d320a79b3d26cdb3e2d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">rabbit启动:Error when reading /var/lib/rabbitmq/.erlang.cookie: eacces auth.erl</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>