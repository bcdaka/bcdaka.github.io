<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python魔法之旅-魔法方法(14) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/94c0d0d43682097f2a42f84bd1a29f1b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Python魔法之旅-魔法方法(14)">
  <meta property="og:description" content="目录
一、概述
1、定义
2、作用
二、应用场景
1、构造和析构
2、操作符重载
3、字符串和表示
4、容器管理
5、可调用对象
6、上下文管理
7、属性访问和描述符
8、迭代器和生成器
9、数值类型
10、复制和序列化
11、自定义元类行为
12、自定义类行为
13、类型检查和转换
14、自定义异常
三、学习方法
1、理解基础
2、查阅文档
3、编写示例
4、实践应用
5、阅读他人代码
6、参加社区讨论
7、持续学习
8、练习与总结
9、注意兼容性
10、避免过度使用
四、魔法方法
44、__length_hint__方法
44-1、语法
44-2、参数
44-3、功能
44-4、返回值
44-5、说明
44-6、用法
45、__lshift__方法
45-1、语法
45-2、参数
45-3、功能
45-4、返回值
45-5、说明
45-6、用法
46、__lt__方法
46-1、语法
46-2、参数
46-3、功能
46-4、返回值
46-5、说明
46-6、用法
五、推荐阅读
1、Python筑基之旅
2、Python函数之旅
3、Python算法之旅
4、博客个人主页
一、概述 1、定义 魔法方法(Magic Methods/Special Methods，也称特殊方法或双下划线方法)是Python中一类具有特殊命名规则的方法，它们的名称通常以双下划线(`__`)开头和结尾。
魔法方法用于在特定情况下自动被Python解释器调用，而不需要显式地调用它们，它们提供了一种机制，让你可以定义自定义类时具有与内置类型相似的行为。
2、作用 魔法方法允许开发者重载Python中的一些内置操作或函数的行为，从而为自定义的类添加特殊的功能。
二、应用场景 1、构造和析构 1-1、__init__(self, [args...])：在创建对象时初始化属性。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-04T09:15:13+08:00">
    <meta property="article:modified_time" content="2024-06-04T09:15:13+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python魔法之旅-魔法方法(14)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong><span style="color:#1a439c;">目录</span></strong></p> 
<p id="%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0-toc" style="margin-left:40px;"><strong><a href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0" rel="nofollow"><span style="color:#1a439c;">一、概述</span></a></strong></p> 
<p id="1%E3%80%81%E5%AE%9A%E4%B9%89-toc" style="margin-left:80px;"><strong><a href="#1%E3%80%81%E5%AE%9A%E4%B9%89" rel="nofollow"><span style="color:#1a439c;">1、定义</span></a></strong></p> 
<p id="2%E3%80%81%E4%BD%9C%E7%94%A8-toc" style="margin-left:80px;"><strong><a href="#2%E3%80%81%E4%BD%9C%E7%94%A8" rel="nofollow"><span style="color:#1a439c;">2、作用</span></a></strong></p> 
<p id="%E4%BA%8C%E3%80%81%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><strong><a href="#%E4%BA%8C%E3%80%81%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow"><span style="color:#1a439c;">二、应用场景</span></a></strong></p> 
<p id="1%E3%80%81%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84-toc" style="margin-left:80px;"><strong><a href="#1%E3%80%81%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84" rel="nofollow"><span style="color:#1a439c;">1、构造和析构</span></a></strong></p> 
<p id="2%E3%80%81%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD-toc" style="margin-left:80px;"><strong><a href="#2%E3%80%81%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD" rel="nofollow"><span style="color:#1a439c;">2、操作符重载</span></a></strong></p> 
<p id="3%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E8%A1%A8%E7%A4%BA-toc" style="margin-left:80px;"><strong><a href="#3%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E8%A1%A8%E7%A4%BA" rel="nofollow"><span style="color:#1a439c;">3、字符串和表示</span></a></strong></p> 
<p id="4%E3%80%81%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86-toc" style="margin-left:80px;"><strong><a href="#4%E3%80%81%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86" rel="nofollow"><span style="color:#1a439c;">4、容器管理</span></a></strong></p> 
<p id="5%E3%80%81%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1-toc" style="margin-left:80px;"><strong><a href="#5%E3%80%81%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1" rel="nofollow"><span style="color:#1a439c;">5、可调用对象</span></a></strong></p> 
<p id="6%E3%80%81%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86-toc" style="margin-left:80px;"><strong><a href="#6%E3%80%81%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86" rel="nofollow"><span style="color:#1a439c;">6、上下文管理</span></a></strong></p> 
<p id="7%E3%80%81%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6-toc" style="margin-left:80px;"><strong><a href="#7%E3%80%81%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6" rel="nofollow"><span style="color:#1a439c;">7、属性访问和描述符</span></a></strong></p> 
<p id="8%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8-toc" style="margin-left:80px;"><strong><a href="#8%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8" rel="nofollow"><span style="color:#1a439c;">8、迭代器和生成器</span></a></strong></p> 
<p id="9%E3%80%81%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><strong><a href="#9%E3%80%81%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B" rel="nofollow"><span style="color:#1a439c;">9、数值类型</span></a></strong></p> 
<p id="10%E3%80%81%E5%A4%8D%E5%88%B6%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96-toc" style="margin-left:80px;"><strong><a href="#10%E3%80%81%E5%A4%8D%E5%88%B6%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96" rel="nofollow"><span style="color:#1a439c;">10、复制和序列化</span></a></strong></p> 
<p id="11%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B1%BB%E8%A1%8C%E4%B8%BA-toc" style="margin-left:80px;"><strong><a href="#11%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B1%BB%E8%A1%8C%E4%B8%BA" rel="nofollow"><span style="color:#1a439c;">11、自定义元类行为</span></a></strong></p> 
<p id="12%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E8%A1%8C%E4%B8%BA-toc" style="margin-left:80px;"><strong><a href="#12%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E8%A1%8C%E4%B8%BA" rel="nofollow"><span style="color:#1a439c;">12、自定义类行为</span></a></strong></p> 
<p id="13%E3%80%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%92%8C%E8%BD%AC%E6%8D%A2-toc" style="margin-left:80px;"><strong><a href="#13%E3%80%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%92%8C%E8%BD%AC%E6%8D%A2" rel="nofollow"><span style="color:#1a439c;">13、类型检查和转换</span></a></strong></p> 
<p id="14%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8-toc" style="margin-left:80px;"><strong><a href="#14%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8" rel="nofollow"><span style="color:#1a439c;">14、自定义异常</span></a></strong></p> 
<p id="%E4%B8%89%E3%80%81%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><strong><a href="#%E4%B8%89%E3%80%81%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">三、学习方法</span></a></strong></p> 
<p id="1%E3%80%81%E7%90%86%E8%A7%A3%E5%9F%BA%E7%A1%80-toc" style="margin-left:80px;"><strong><a href="#1%E3%80%81%E7%90%86%E8%A7%A3%E5%9F%BA%E7%A1%80" rel="nofollow"><span style="color:#1a439c;">1、理解基础</span></a></strong></p> 
<p id="2%E3%80%81%E6%9F%A5%E9%98%85%E6%96%87%E6%A1%A3-toc" style="margin-left:80px;"><strong><a href="#2%E3%80%81%E6%9F%A5%E9%98%85%E6%96%87%E6%A1%A3" rel="nofollow"><span style="color:#1a439c;">2、查阅文档</span></a></strong></p> 
<p id="3%E3%80%81%E7%BC%96%E5%86%99%E7%A4%BA%E4%BE%8B-toc" style="margin-left:80px;"><strong><a href="#3%E3%80%81%E7%BC%96%E5%86%99%E7%A4%BA%E4%BE%8B" rel="nofollow"><span style="color:#1a439c;">3、编写示例</span></a></strong></p> 
<p id="4%E3%80%81%E5%AE%9E%E8%B7%B5%E5%BA%94%E7%94%A8-toc" style="margin-left:80px;"><strong><a href="#4%E3%80%81%E5%AE%9E%E8%B7%B5%E5%BA%94%E7%94%A8" rel="nofollow"><span style="color:#1a439c;">4、实践应用</span></a></strong></p> 
<p id="5%E3%80%81%E9%98%85%E8%AF%BB%E4%BB%96%E4%BA%BA%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><strong><a href="#5%E3%80%81%E9%98%85%E8%AF%BB%E4%BB%96%E4%BA%BA%E4%BB%A3%E7%A0%81" rel="nofollow"><span style="color:#1a439c;">5、阅读他人代码</span></a></strong></p> 
<p id="6%E3%80%81%E5%8F%82%E5%8A%A0%E7%A4%BE%E5%8C%BA%E8%AE%A8%E8%AE%BA-toc" style="margin-left:80px;"><strong><a href="#6%E3%80%81%E5%8F%82%E5%8A%A0%E7%A4%BE%E5%8C%BA%E8%AE%A8%E8%AE%BA" rel="nofollow"><span style="color:#1a439c;">6、参加社区讨论</span></a></strong></p> 
<p id="7%E3%80%81%E6%8C%81%E7%BB%AD%E5%AD%A6%E4%B9%A0-toc" style="margin-left:80px;"><strong><a href="#7%E3%80%81%E6%8C%81%E7%BB%AD%E5%AD%A6%E4%B9%A0" rel="nofollow"><span style="color:#1a439c;">7、持续学习</span></a></strong></p> 
<p id="8%E3%80%81%E7%BB%83%E4%B9%A0%E4%B8%8E%E6%80%BB%E7%BB%93-toc" style="margin-left:80px;"><strong><a href="#8%E3%80%81%E7%BB%83%E4%B9%A0%E4%B8%8E%E6%80%BB%E7%BB%93" rel="nofollow"><span style="color:#1a439c;">8、练习与总结</span></a></strong></p> 
<p id="9%E3%80%81%E6%B3%A8%E6%84%8F%E5%85%BC%E5%AE%B9%E6%80%A7-toc" style="margin-left:80px;"><strong><a href="#9%E3%80%81%E6%B3%A8%E6%84%8F%E5%85%BC%E5%AE%B9%E6%80%A7" rel="nofollow"><span style="color:#1a439c;">9、注意兼容性</span></a></strong></p> 
<p id="10%E3%80%81%E9%81%BF%E5%85%8D%E8%BF%87%E5%BA%A6%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><strong><a href="#10%E3%80%81%E9%81%BF%E5%85%8D%E8%BF%87%E5%BA%A6%E4%BD%BF%E7%94%A8" rel="nofollow"><span style="color:#1a439c;">10、避免过度使用</span></a></strong></p> 
<p id="%E5%9B%9B%E3%80%81%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B-toc" style="margin-left:40px;"><strong><a href="#%E5%9B%9B%E3%80%81%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B" rel="nofollow"><span style="color:#1a439c;">四、魔法方法</span></a></strong></p> 
<p id="1%E3%80%81__abs__%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><strong><a href="#1%E3%80%81__abs__%E6%96%B9%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">44、__length_hint__方法</span></a></strong></p> 
<p id="1-1%E3%80%81%E8%AF%AD%E6%B3%95-toc" style="margin-left:120px;"><strong><a href="#1-1%E3%80%81%E8%AF%AD%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">44-1、语法</span></a></strong></p> 
<p id="1-2%E3%80%81%E5%8F%82%E6%95%B0-toc" style="margin-left:120px;"><strong><a href="#1-2%E3%80%81%E5%8F%82%E6%95%B0" rel="nofollow"><span style="color:#1a439c;">44-2、参数</span></a></strong></p> 
<p id="1-3%E3%80%81%E5%8A%9F%E8%83%BD-toc" style="margin-left:120px;"><strong><a href="#1-3%E3%80%81%E5%8A%9F%E8%83%BD" rel="nofollow"><span style="color:#1a439c;">44-3、功能</span></a></strong></p> 
<p id="1-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC-toc" style="margin-left:120px;"><strong><a href="#1-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC" rel="nofollow"><span style="color:#1a439c;">44-4、返回值</span></a></strong></p> 
<p id="1-5%E3%80%81%E8%AF%B4%E6%98%8E-toc" style="margin-left:120px;"><strong><a href="#1-5%E3%80%81%E8%AF%B4%E6%98%8E" rel="nofollow"><span style="color:#1a439c;">44-5、说明</span></a></strong></p> 
<p id="1-6%E3%80%81%E7%94%A8%E6%B3%95-toc" style="margin-left:120px;"><strong><a href="#1-6%E3%80%81%E7%94%A8%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">44-6、用法</span></a></strong></p> 
<p id="2%E3%80%81__add__%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><strong><a href="#2%E3%80%81__add__%E6%96%B9%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">45、__lshift__方法</span></a></strong></p> 
<p id="17-1%E3%80%81%E8%AF%AD%E6%B3%95-toc" style="margin-left:120px;"><strong><a href="#17-1%E3%80%81%E8%AF%AD%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">45-1、语法</span></a></strong></p> 
<p id="36-2%E3%80%81%E5%8F%82%E6%95%B0-toc" style="margin-left:120px;"><strong><a href="#36-2%E3%80%81%E5%8F%82%E6%95%B0" rel="nofollow"><span style="color:#1a439c;">45-2、参数</span></a></strong></p> 
<p id="36-3%E3%80%81%E5%8A%9F%E8%83%BD-toc" style="margin-left:120px;"><strong><a href="#36-3%E3%80%81%E5%8A%9F%E8%83%BD" rel="nofollow"><span style="color:#1a439c;">45-3、功能</span></a></strong></p> 
<p id="36-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC-toc" style="margin-left:120px;"><strong><a href="#36-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC" rel="nofollow"><span style="color:#1a439c;">45-4、返回值</span></a></strong></p> 
<p id="36-5%E3%80%81%E8%AF%B4%E6%98%8E-toc" style="margin-left:120px;"><strong><a href="#36-5%E3%80%81%E8%AF%B4%E6%98%8E" rel="nofollow"><span style="color:#1a439c;">45-5、说明</span></a></strong></p> 
<p id="36-6%E3%80%81%E7%94%A8%E6%B3%95-toc" style="margin-left:120px;"><strong><a href="#36-6%E3%80%81%E7%94%A8%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">45-6、用法</span></a></strong></p> 
<p id="46%E3%80%81__lt__%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><strong><a href="#46%E3%80%81__lt__%E6%96%B9%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">46、__lt__方法</span></a></strong></p> 
<p id="46-1%E3%80%81%E8%AF%AD%E6%B3%95-toc" style="margin-left:120px;"><strong><a href="#46-1%E3%80%81%E8%AF%AD%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">46-1、语法</span></a></strong></p> 
<p id="37-2%E3%80%81%E5%8F%82%E6%95%B0-toc" style="margin-left:120px;"><strong><a href="#37-2%E3%80%81%E5%8F%82%E6%95%B0" rel="nofollow"><span style="color:#1a439c;">46-2、参数</span></a></strong></p> 
<p id="37-3%E3%80%81%E5%8A%9F%E8%83%BD-toc" style="margin-left:120px;"><strong><a href="#37-3%E3%80%81%E5%8A%9F%E8%83%BD" rel="nofollow"><span style="color:#1a439c;">46-3、功能</span></a></strong></p> 
<p id="37-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC-toc" style="margin-left:120px;"><strong><a href="#37-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC" rel="nofollow"><span style="color:#1a439c;">46-4、返回值</span></a></strong></p> 
<p id="37-5%E3%80%81%E8%AF%B4%E6%98%8E-toc" style="margin-left:120px;"><strong><a href="#37-5%E3%80%81%E8%AF%B4%E6%98%8E" rel="nofollow"><span style="color:#1a439c;">46-5、说明</span></a></strong></p> 
<p id="37-6%E3%80%81%E7%94%A8%E6%B3%95-toc" style="margin-left:120px;"><strong><a href="#37-6%E3%80%81%E7%94%A8%E6%B3%95" rel="nofollow"><span style="color:#1a439c;">46-6、用法</span></a></strong></p> 
<p id="%E4%BA%94%E3%80%81%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB-toc" style="margin-left:40px;"><strong><a href="#%E4%BA%94%E3%80%81%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB" rel="nofollow"><span style="color:#1a439c;">五、推荐阅读</span></a></strong></p> 
<p id="1%E3%80%81Python%E7%AD%91%E5%9F%BA%E4%B9%8B%E6%97%85-toc" style="margin-left:80px;"><strong><a href="#1%E3%80%81Python%E7%AD%91%E5%9F%BA%E4%B9%8B%E6%97%85" rel="nofollow"><span style="color:#1a439c;">1、Python筑基之旅</span></a></strong></p> 
<p id="2%E3%80%81Python%E5%87%BD%E6%95%B0%E4%B9%8B%E6%97%85-toc" style="margin-left:80px;"><strong><a href="#2%E3%80%81Python%E5%87%BD%E6%95%B0%E4%B9%8B%E6%97%85" rel="nofollow"><span style="color:#1a439c;">2、Python函数之旅</span></a></strong></p> 
<p id="3%E3%80%81Python%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85-toc" style="margin-left:80px;"><strong><a href="#3%E3%80%81Python%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85" rel="nofollow"><span style="color:#1a439c;">3、Python算法之旅</span></a></strong></p> 
<p id="4%E3%80%81%E5%8D%9A%E5%AE%A2%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5-toc" style="margin-left:80px;"><strong><a href="#4%E3%80%81%E5%8D%9A%E5%AE%A2%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5" rel="nofollow"><span style="color:#1a439c;">4、博客个人主页</span></a></strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/2e/9f/lBQ8KxK3_o.gif"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/80/7b/K6rB3xFT_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/76/8e/TVgDOTVZ_o.gif"></p> 
<h3 id="%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0">一、概述</h3> 
<h4 id="1%E3%80%81%E5%AE%9A%E4%B9%89">1、定义</h4> 
<p>        <span style="color:#fe2c24;"><strong>魔法方法</strong></span><span style="color:#956fe7;"><strong>(Magic Methods/Special Methods，</strong></span><span style="color:#fe2c24;"><strong>也称特殊方法或双下划线方法</strong></span><span style="color:#956fe7;"><strong>)</strong></span>是Python中<span style="color:#fe2c24;"><strong>一类具有特殊命名规则的方法，它们的名称通常以双下划线(`__`)开头和结尾</strong>。</span></p> 
<p>        <span style="color:#fe2c24;"><strong>魔法方法</strong></span>用于在特定情况下<span style="color:#fe2c24;"><strong>自动被Python解释器调用，而不需要显式地调用它们，它们提供了一种机制，</strong></span>让你可以定义自定义类时具有与内置类型相似的行为。</p> 
<h4 id="2%E3%80%81%E4%BD%9C%E7%94%A8">2、作用</h4> 
<p>        <span style="color:#fe2c24;"><strong>魔法方法</strong></span>允许开发者<span style="color:#fe2c24;"><strong>重载Python中的一些内置操作或函数的行为，从而为自定义的类添加特殊的功能</strong>。</span></p> 
<h3 id="%E4%BA%8C%E3%80%81%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">二、应用场景</h3> 
<h4 id="1%E3%80%81%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84">1、构造和析构</h4> 
<p>1-1、__init__(self, [args...])：在创建对象时初始化属性。<br> 1-2、__new__(cls, [args...])：在创建对象时控制实例的创建过程(通常与元类一起使用)。<br> 1-3、__del__(self)：在对象被销毁前执行清理操作，如关闭文件或释放资源。</p> 
<h4 id="2%E3%80%81%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD">2、操作符重载</h4> 
<p>2-1、__add__(self, other)、__sub__(self, other)、__mul__(self, other)等：自定义对象之间的算术运算。<br> 2-2、__eq__(self, other)、__ne__(self, other)、__lt__(self, other)等：定义对象之间的比较操作。</p> 
<h4 id="3%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E8%A1%A8%E7%A4%BA">3、字符串和表示</h4> 
<p>3-1、__str__(self)：定义对象的字符串表示，常用于print()函数。<br> 3-2、__repr__(self)：定义对象的官方字符串表示，用于repr()函数和交互式解释器。</p> 
<h4 id="4%E3%80%81%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86">4、容器管理</h4> 
<p>4-1、__getitem__(self, key)、__setitem__(self, key, value)、__delitem__(self, key)：用于实现类似列表或字典的索引访问、设置和删除操作。<br> 4-2、__len__(self)：返回对象的长度或元素个数。</p> 
<h4 id="5%E3%80%81%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1">5、可调用对象</h4> 
<p>5-1、__call__(self, [args...])：允许对象像函数一样被调用。</p> 
<h4 id="6%E3%80%81%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86">6、上下文管理</h4> 
<p>6-1、__enter__(self)、__exit__(self, exc_type, exc_val, exc_tb)：用于实现上下文管理器，如with语句中的对象。</p> 
<h4 id="7%E3%80%81%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6">7、属性访问和描述符</h4> 
<p>7-1、__getattr__, __setattr__, __delattr__：这些方法允许对象在访问或修改不存在的属性时执行自定义操作。<br> 7-2、描述符(Descriptors)是实现了__get__, __set__, 和__delete__方法的对象，它们可以控制对另一个对象属性的访问。</p> 
<h4 id="8%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8">8、迭代器和生成器</h4> 
<p>8-1、__iter__和__next__：这些方法允许对象支持迭代操作，如使用for循环遍历对象。<br> 8-2、__aiter__, __anext__：这些是异步迭代器的魔法方法，用于支持异步迭代。</p> 
<h4 id="9%E3%80%81%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">9、数值类型</h4> 
<p>9-1、__int__(self)、__float__(self)、__complex__(self)：定义对象到数值类型的转换。<br> 9-2、__index__(self)：定义对象用于切片时的整数转换。</p> 
<h4 id="10%E3%80%81%E5%A4%8D%E5%88%B6%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96">10、复制和序列化</h4> 
<p>10-1、__copy__和__deepcopy__：允许对象支持浅复制和深复制操作。<br> 10-2、__getstate__和__setstate__：用于自定义对象的序列化和反序列化过程。</p> 
<h4 id="11%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B1%BB%E8%A1%8C%E4%B8%BA">11、自定义元类行为</h4> 
<p>11-1、__metaclass__(Python 2)或元类本身(Python 3)：允许自定义类的创建过程，如动态创建类、修改类的定义等。</p> 
<h4 id="12%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E8%A1%8C%E4%B8%BA">12、自定义类行为</h4> 
<p>12-1、__init__和__new__：用于初始化对象或控制对象的创建过程。<br> 12-2、__init_subclass__：在子类被创建时调用，允许在子类中执行一些额外的操作。</p> 
<h4 id="13%E3%80%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%92%8C%E8%BD%AC%E6%8D%A2">13、类型检查和转换</h4> 
<p>13-1、__instancecheck__和__subclasscheck__：用于自定义isinstance()和issubclass()函数的行为。</p> 
<h4 id="14%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8">14、自定义异常</h4> 
<p>14-1、你可以通过继承内置的Exception类来创建自定义的异常类，并定义其特定的行为。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/de/1c/tRzy17pE_o.png"></p> 
<h3 id="%E4%B8%89%E3%80%81%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95">三、学习方法</h3> 
<p>        要学好Python的魔法方法，你可以遵循以下方法及步骤：</p> 
<h4 id="1%E3%80%81%E7%90%86%E8%A7%A3%E5%9F%BA%E7%A1%80">1、理解基础</h4> 
<p>        首先确保你对Python的基本语法、数据类型、类和对象等概念有深入的理解，这些是理解魔法方法的基础。</p> 
<h4 id="2%E3%80%81%E6%9F%A5%E9%98%85%E6%96%87%E6%A1%A3">2、查阅文档</h4> 
<p>        仔细阅读Python官方文档中关于魔法方法的部分，文档会详细解释每个魔法方法的作用、参数和返回值。你可以通过访问Python的官方网站或使用help()函数在Python解释器中查看文档。</p> 
<h4 id="3%E3%80%81%E7%BC%96%E5%86%99%E7%A4%BA%E4%BE%8B">3、编写示例</h4> 
<p>        为每个魔法方法编写简单的示例代码，以便更好地理解其用法和效果，通过实际编写和运行代码，你可以更直观地感受到魔法方法如何改变对象的行为。</p> 
<h4 id="4%E3%80%81%E5%AE%9E%E8%B7%B5%E5%BA%94%E7%94%A8">4、实践应用</h4> 
<p>        在实际项目中尝试使用魔法方法。如，你可以创建一个自定义的集合类，使用__getitem__、__setitem__和__delitem__方法来实现索引操作。只有通过实践应用，你才能更深入地理解魔法方法的用途和重要性。</p> 
<h4 id="5%E3%80%81%E9%98%85%E8%AF%BB%E4%BB%96%E4%BA%BA%E4%BB%A3%E7%A0%81">5、阅读他人代码</h4> 
<p>        阅读开源项目或他人编写的代码，特别是那些使用了魔法方法的代码，这可以帮助你学习如何在实际项目中使用魔法方法。通过分析他人代码中的魔法方法使用方式，你可以学习到一些新的技巧和最佳实践。</p> 
<h4 id="6%E3%80%81%E5%8F%82%E5%8A%A0%E7%A4%BE%E5%8C%BA%E8%AE%A8%E8%AE%BA">6、参加社区讨论</h4> 
<p>        参与Python社区的讨论，与其他开发者交流关于魔法方法的使用经验和技巧，在社区中提问或回答关于魔法方法的问题，这可以帮助你更深入地理解魔法方法并发现新的应用场景。</p> 
<h4 id="7%E3%80%81%E6%8C%81%E7%BB%AD%E5%AD%A6%E4%B9%A0">7、持续学习</h4> 
<p>        Python语言和其生态系统不断发展，新的魔法方法和功能可能会不断被引入，保持对Python社区的关注，及时学习新的魔法方法和最佳实践。</p> 
<h4 id="8%E3%80%81%E7%BB%83%E4%B9%A0%E4%B8%8E%E6%80%BB%E7%BB%93">8、练习与总结</h4> 
<p>        多做练习，通过编写各种使用魔法方法的代码来巩固你的理解，定期总结你学到的知识和经验，形成自己的知识体系。</p> 
<h4 id="9%E3%80%81%E6%B3%A8%E6%84%8F%E5%85%BC%E5%AE%B9%E6%80%A7">9、注意兼容性</h4> 
<p>        在使用魔法方法时，要注意不同Python版本之间的兼容性差异，确保你的代码在不同版本的Python中都能正常工作。</p> 
<h4 id="10%E3%80%81%E9%81%BF%E5%85%8D%E8%BF%87%E5%BA%A6%E4%BD%BF%E7%94%A8">10、避免过度使用</h4> 
<p>        虽然魔法方法非常强大，但过度使用可能会导致代码难以理解和维护，在编写代码时，要权衡使用魔法方法的利弊，避免滥用。</p> 
<p>        总之，学好Python的魔法方法需要不断地学习、实践和总结，只有通过不断地练习和积累经验，你才能更好地掌握这些强大的工具，并在实际项目中灵活运用它们。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ab/6b/unCYj7tO_o.png"></p> 
<h3 id="%E5%9B%9B%E3%80%81%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B">四、魔法方法</h3> 
<h4 id="1%E3%80%81__abs__%E6%96%B9%E6%B3%95">44、__length_hint__方法</h4> 
<h5 id="1-1%E3%80%81%E8%AF%AD%E6%B3%95">44-1、语法</h5> 
<pre><code class="language-python">__length_hint__(self, /)
    Private method returning an estimate of len(list(it))</code></pre> 
<h5 id="1-2%E3%80%81%E5%8F%82%E6%95%B0">44-2、参数</h5> 
<p><span style="color:#fe2c24;"><strong>44-2-1、self</strong></span><span style="color:#956fe7;"><strong>(必须)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>一个对实例对象本身的引用，在类的所有方法中都会自动传递。</p> 
<p><span style="color:#fe2c24;"><strong>44-2-2、/</strong></span><span style="color:#956fe7;"><strong>(可选)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>这是从Python 3.8开始引入的参数注解语法，它表示这个方法不接受任何位置参数(positional-only parameters)之后的关键字参数(keyword arguments)。</p> 
<h5 id="1-3%E3%80%81%E5%8A%9F%E8%83%BD">44-3、功能</h5> 
<p>        为那些需要知道迭代器大致长度的函数或方法提供一个长度提示。</p> 
<h5 id="1-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC">44-4、返回值</h5> 
<p>        返回一个整数或None。</p> 
<h5 id="1-5%E3%80%81%E8%AF%B4%E6%98%8E">44-5、说明</h5> 
<p><code>   <span style="color:#fe2c24;"><strong>__length_hint__</strong></span></code>方法应该返回<span style="color:#fe2c24;"><strong>一个整数或None</strong></span>：</p> 
<p>44-5-1、如果返回整数，它应该是一个对迭代器长度的合理估计，这个估计可能并不总是准确的，但它应该尽可能接近实际长度。</p> 
<p>44-5-2、如果迭代器长度未知或无法合理估计，则应返回<code>None</code>。</p> 
<h5 id="1-6%E3%80%81%E7%94%A8%E6%B3%95">44-6、用法</h5> 
<pre><code class="language-python"># 044、__length_hint__方法：
# 1、简单的列表包装器
class MyListWrapper:
    def __init__(self, lst):
        self.lst = lst
    def __length_hint__(self):
        return len(self.lst)

# 2、迭代器长度提示
class MyIterator:
    def __init__(self, numbers):
        self.numbers = numbers
        self.index = 0
    def __iter__(self):
        return self
    def __next__(self):
        if self.index &lt; len(self.numbers):
            result = self.numbers[self.index]
            self.index += 1
            return result
        raise StopIteration
    def __length_hint__(self):
        return len(self.numbers) - self.index

# 3、动态生成的序列
class DynamicSequence:
    def __init__(self, start, end):
        self.start = start
        self.end = end
    def __iter__(self):
        return self
    def __next__(self):
        if self.start &gt; self.end:
            raise StopIteration
        current = self.start
        self.start += 1
        return current
    def __length_hint__(self):
        return self.end - self.start + 1 if self.start &lt;= self.end else 0

# 4、缓存长度的迭代器
class CachedLengthIterator:
    def __init__(self, iterable):
        self.iterable = iterable
        self._length = None
    def __iter__(self):
        return iter(self.iterable)
    def __length_hint__(self):
        if self._length is None:
            self._length = sum(1 for _ in self.iterable)
        return self._length

# 5、生成器长度提示(通常不准确，因为生成器是动态的)
def my_generator(n):
    for i in range(n):
        yield i
class GeneratorWrapper:
    def __init__(self, generator_func, *args, **kwargs):
        self.generator = generator_func(*args, **kwargs)
        self._hint = None
    def __iter__(self):
        return iter(self.generator)
    def __length_hint__(self):
        if self._hint is None:
            # 注意：这只是一个示例，对于真正的生成器可能不准确
            self._hint = sum(1 for _ in self.generator)
        return self._hint
        # 使用示例：GeneratorWrapper(my_generator, 10)

# 6、模拟数据库查询结果
class DatabaseQueryResult:
    def __init__(self, count):
        self.count = count
    def __length_hint__(self):
        return self.count

# 7、文件行数预估(基于文件大小)
class FileLineCounterApprox:
    def __init__(self, file_path, avg_line_length=100):  # 假设平均行长为100字节
        self.file_path = file_path
        self.avg_line_length = avg_line_length
    def __length_hint__(self):
        with open(self.file_path, 'rb') as file:
            return file.seek(0, 2) // self.avg_line_length  # 粗略估计

# 8、树形结构节点数预估
class TreeNode:
    def __init__(self, value, children=None):
        self.value = value
        self.children = children if children is not None else []
    def __length_hint__(self):
        # 假设这是一个完全二叉树，用于示例
        return (2 ** self.depth()) - 1 if self.is_full_binary_tree() else "unknown"
    def depth(self):
        # 需要实现一个计算树深度的函数
        pass
    def is_full_binary_tree(self):
        # 需要实现一个检查树是否是完全二叉树的函数
        pass
        # 注意：在实际应用中，树的长度（即节点数）可能需要递归遍历才能准确计算

# 9、网络请求结果集大小预估
class APIResult:
    def __init__(self, response_headers):
        self.response_headers = response_headers
    def __length_hint__(self):
        # 假设API响应头中包含了一个关于结果集大小的字段
        content_length = self.response_headers.get('X-Result-Set-Size', None)
        return int(content_length) if content_length is not None and content_length.isdigit() else "unknown"
        # 注意：这个预估是基于假设的HTTP头字段，实际API可能不会有这样的字段

# 10、流式数据处理长度提示
class StreamProcessor:
    def __init__(self, stream):
        self.stream = stream
        self._processed_count = 0
    def process(self, chunk_size=1024):
        # 处理流数据，这里只是模拟
        for _ in range(chunk_size):
            # 假设每次处理一个数据单元
            self._processed_count += 1
    def __length_hint__(self):
        # 流数据长度通常未知，但可以提供已处理的数量
        return self._processed_count
        # 注意：流数据的长度通常是未知的，除非有额外的信息或上下文

# 11、自定义集合大小预估
class CustomSet:
    def __init__(self, iterable=()):
        self._set = set(iterable)
        self._hint = None
    def add(self, item):
        self._set.add(item)
        self._hint = None  # 清除长度提示缓存
    def remove(self, item):
        self._set.remove(item)
        self._hint = None
    def __iter__(self):
        return iter(self._set)
    def __len__(self):
        return len(self._set)
    def __length_hint__(self):
        if self._hint is None:
            self._hint = len(self)  # 只有在需要时才计算长度
        return self._hint
        # 注意：在实际应用中，集合的大小可以直接通过len()函数获取，但这里展示了如何使用__length_hint__进行缓存
</code></pre> 
<h4 id="2%E3%80%81__add__%E6%96%B9%E6%B3%95">45、__lshift__方法</h4> 
<h5 id="17-1%E3%80%81%E8%AF%AD%E6%B3%95">45-1、语法</h5> 
<pre><code class="language-python">__lshift__(self, other, /)
    Return self &lt;&lt; other</code></pre> 
<h5 id="36-2%E3%80%81%E5%8F%82%E6%95%B0"><strong>45-2、参数</strong></h5> 
<p><span style="color:#fe2c24;"><strong>45-2-1、self</strong></span><span style="color:#956fe7;"><strong>(必须)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>一个对实例对象本身的引用，在类的所有方法中都会自动传递。</p> 
<p><span style="color:#fe2c24;"><strong>45-2-2、 other</strong></span><span style="color:#956fe7;"><strong>(必须)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>表示与self进行左移操作的另一个对象或整数。</p> 
<p><span style="color:#fe2c24;"><strong>45-2-3、/</strong></span><span style="color:#956fe7;"><strong>(可选)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>这是从Python 3.8开始引入的参数注解语法，它表示这个方法不接受任何位置参数(positional-only parameters)之后的关键字参数(keyword arguments)。</p> 
<h5 id="36-3%E3%80%81%E5%8A%9F%E8%83%BD"><strong>45-3、功能</strong></h5> 
<p>        用于定义对象与左移位运算符&lt;&lt;的行为。</p> 
<h5 id="36-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC"><strong>45-4、返回值</strong></h5> 
<p>        返回一个与self类型相同或兼容的对象，该对象表示self对象左移other位之后的结果。</p> 
<h5 id="36-5%E3%80%81%E8%AF%B4%E6%98%8E"><strong>45-5、说明</strong></h5> 
<p>        如果类没有定义__lshift__方法，并且尝试使用左移位运算符&lt;&lt;对其实例进行操作，将会引发一个TypeError。</p> 
<h5 id="36-6%E3%80%81%E7%94%A8%E6%B3%95"><strong>45-6、用法</strong></h5> 
<pre><code class="language-python"># 045、__lshift__方法：
# 1、二进制位移
class BinaryShift:
    def __init__(self, value):
        self.value = value
    def __lshift__(self, other):
        return BinaryShift(self.value &lt;&lt; other)
if __name__ == '__main__':
    a = BinaryShift(4)
    b = a &lt;&lt; 2  # 相当于 4 &lt;&lt; 2 = 16
    print(b.value)  # 输出 16

# 2、整数列表左移
class IntList:
    def __init__(self, values):
        self.values = values
    def __lshift__(self, other):
        if other &lt; 0 or other &gt;= len(self.values):
            raise ValueError("Invalid shift amount")
        return IntList(self.values[other:] + self.values[:other])
if __name__ == '__main__':
    lst = IntList([3, 5, 6, 8, 10, 11, 24])
    shifted = lst &lt;&lt; 2  # 相当于 [6, 8, 10, 11, 24, 3, 5]
    print(shifted.values)  # 输出 [6, 8, 10, 11, 24, 3, 5]

# 3、字符串左移
class StringShift:
    def __init__(self, value):
        self.value = value
    def __lshift__(self, other):
        if other &lt; 0:
            return StringShift(self.value[-other:] + self.value[:-other])
        elif other &gt;= len(self.value):
            return StringShift(self.value)
        else:
            return StringShift(self.value[other:] + self.value[:other])
if __name__ == '__main__':
    s = StringShift("hello")
    shifted = s &lt;&lt; 2  # 相当于 "llohe"
    print(shifted.value)  # 输出 "llohe"

# 4、时间戳左移(模拟时间偏移)
from datetime import datetime, timedelta
class TimestampShift:
    def __init__(self, timestamp):
        self.timestamp = timestamp
    def __lshift__(self, other):
        # 假设 other 是天数
        return TimestampShift(self.timestamp + timedelta(days=other))
if __name__ == '__main__':
    now = datetime.now()
    ts = TimestampShift(now)
    future = ts &lt;&lt; 10  # 10天后的时间
    print(future.timestamp)  # 输出10天后的日期时间

# 5、图形对象的水平移动
class Shape:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def __lshift__(self, other):
        return Shape(self.x + other, self.y)
if __name__ == '__main__':
    rect = Shape(10, 24)
    moved = rect &lt;&lt; 5  # 向右移动5个单位
    print(moved.x, moved.y)  # 输出 15 24

# 6、权重调整(模拟权重左移)
class WeightedItem:
    def __init__(self, value, weight):
        self.value = value
        self.weight = weight
    def __lshift__(self, other):
        # 假设 other 是权重增加的因子（例如，左移1位相当于权重乘以2）
        return WeightedItem(self.value, self.weight * (2 ** other))
if __name__ == '__main__':
    item = WeightedItem('apple', 1)
    item_with_higher_weight = item &lt;&lt; 1  # 权重变为 2
    print(item_with_higher_weight.weight)  # 输出 2

# 7、颜色深度调整(模拟颜色通道值的左移)
class Color:
    def __init__(self, r, g, b):
        self.r = r
        self.g = g
        self.b = b
    def __lshift__(self, other):
        # 假设 other 是亮度增加的因子（注意：这里需要确保值在有效范围内）
        return Color(min(self.r &lt;&lt; other, 255), min(self.g &lt;&lt; other, 255), min(self.b &lt;&lt; other, 255))
if __name__ == '__main__':
    red = Color(255, 0, 0)
    brighter_red = red &lt;&lt; 1  # 增加亮度
    print(brighter_red.r, brighter_red.g, brighter_red.b)  # 输出：255 0 0

# 8、频率调整(模拟音频信号频率的左移)
class AudioSignal:
    # 这里仅作为示例，实际音频处理会更复杂
    def __init__(self, frequencies):
        self.frequencies = frequencies
    def __lshift__(self, other):
        # 假设 other 是频率增加的因子（这在实际中是不准确的，仅作示例）
        return AudioSignal([freq * (2 ** other) for freq in self.frequencies])
if __name__ == '__main__':
    signal = AudioSignal([100, 200, 300])
    higher_freq_signal = signal &lt;&lt; 1  # 模拟频率加倍
    print(higher_freq_signal.frequencies)  # 输出:[200, 400, 600]

# 9、队列元素左移(删除头部元素并在尾部添加新元素)
class Queue:
    def __init__(self):
        self.items = []
    def enqueue(self, item):
        self.items.append(item)
    def dequeue(self):
        if self.is_empty():
            raise IndexError("Queue is empty")
        return self.items.pop(0)
    def is_empty(self):
        return len(self.items) == 0
    # 模拟左移（删除头部并添加新元素）
    def __lshift__(self, new_item):
        self.dequeue()
        self.enqueue(new_item)
if __name__ == '__main__':
    q = Queue()
    q.enqueue(1)
    q.enqueue(2)
    q.enqueue(3)
    print(q.items)  # 输出 [1, 2, 3]
    q &lt;&lt; 4  # 删除1并添加4
    print(q.items)  # 输出 [2, 3, 4]

# 10、价格调整(模拟折扣)
class Price:
    def __init__(self, value):
        self.value = value
    def __lshift__(self, discount_factor):
        # 假设 discount_factor 是折扣的百分比（例如，左移1位代表打五折）
        # 注意：这里的实现仅作为示例，真实的折扣计算会更复杂
        return Price(self.value * (1 - discount_factor / 100))
if __name__ == '__main__':
    original_price = Price(100)
    discounted_price = original_price &lt;&lt; 50  # 假设代表打五折
    print(discounted_price.value)  # 输出 50.0

# 11、时间线事件的前移
class TimelineEvent:
    def __init__(self, name, timestamp):
        self.name = name
        self.timestamp = timestamp
    def __lshift__(self, time_delta):
        # 将事件前移指定的时间量
        self.timestamp -= time_delta
if __name__ == '__main__':
    event = TimelineEvent('Meeting', datetime.now())
    print(event.timestamp)  # 输出当前时间
    event &lt;&lt; timedelta(hours=1)  # 将事件前移1小时
    print(event.timestamp)  # 输出前移1小时后的时间

# 12、图形界面中的元素左移
class GUIElement:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def __lshift__(self, shift_amount):
        # 将元素向左移动指定的像素量
        self.x = max(0, self.x - shift_amount)  # 确保元素不会移出容器的左侧边界
    def __repr__(self):
        # 为了更友好地打印GUIElement对象
        return f"GUIElement(x={self.x}, y={self.y})"
# 假设的GUI容器类（仅用于演示）
class GUIContainer:
    def __init__(self):
        self.elements = []
    def add_element(self, element):
        # 添加元素到容器中（这里只是简单地将元素添加到列表中）
        self.elements.append(element)
# 主程序
if __name__ == '__main__':
    # 创建一个GUI容器
    container = GUIContainer()
    # 创建一个GUI元素（按钮）并添加到容器中（虽然在这里我们并不真正添加到GUI中）
    button = GUIElement(100, 50)
    # 假设有一个add_element方法添加到容器中（这里我们手动调用）
    container.add_element(button)
    # 将按钮向左移动20像素
    button &lt;&lt; 20  # 调用__lshift__方法
    # 打印按钮的新位置
    print(button)  # 输出类似：GUIElement(x=80, y=50)</code></pre> 
<h4 id="46%E3%80%81__lt__%E6%96%B9%E6%B3%95">46、__lt__方法</h4> 
<h5 id="46-1%E3%80%81%E8%AF%AD%E6%B3%95">46-1、语法</h5> 
<pre><code class="language-python">__lt__(self, other, /)
    Return self &lt; other</code></pre> 
<h5 id="37-2%E3%80%81%E5%8F%82%E6%95%B0"><strong>46-2、参数</strong></h5> 
<p><span style="color:#fe2c24;"><strong>46-2-1、self</strong></span><span style="color:#956fe7;"><strong>(必须)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>一个对实例对象本身的引用，在类的所有方法中都会自动传递。</p> 
<p><span style="color:#fe2c24;"><strong>46-2-2、 other</strong></span><span style="color:#956fe7;"><strong>(必须)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>表示与self进行比较的另一个对象。</p> 
<p><span style="color:#fe2c24;"><strong>46-2-3、/</strong></span><span style="color:#956fe7;"><strong>(可选)</strong></span><span style="color:#fe2c24;"><strong>：</strong></span>这是从Python 3.8开始引入的参数注解语法，它表示这个方法不接受任何位置参数(positional-only parameters)之后的关键字参数(keyword arguments)。</p> 
<h5 id="37-3%E3%80%81%E5%8A%9F%E8%83%BD"><strong>46-3、功能</strong></h5> 
<p>        用于定义对象之间“小于”关系的行为。</p> 
<h5 id="37-4%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC"><strong>46-4、返回值</strong></h5> 
<p>        返回一个布尔值(True或False)，表示self是否小于other。</p> 
<h5 id="37-5%E3%80%81%E8%AF%B4%E6%98%8E"><strong>46-5、说明</strong></h5> 
<p>        如果没有在类中定义__lt__方法，并且尝试使用&lt;运算符对其实例进行比较，将会引发一个TypeError，除非该类的实例是某个内置类型的子类(如int、float、str等)，这些内置类型已经定义了它们自己的__lt__方法。</p> 
<h5 id="37-6%E3%80%81%E7%94%A8%E6%B3%95"><strong>46-6、用法</strong></h5> 
<pre><code class="language-python"># 046、__lt__方法：
# 1、自定义整数类
class MyInt:
    def __init__(self, value):
        self.value = value
    def __lt__(self, other):
        if isinstance(other, MyInt):
            return self.value &lt; other.value
        elif isinstance(other, int):
            return self.value &lt; other
        else:
            raise TypeError("Unsupported operand types for &lt;: 'MyInt' and '{}'".format(type(other).__name__))
if __name__ == '__main__':
    a = MyInt(5)
    b = MyInt(10)
    print(a &lt; b)  # True

# 2、自定义字符串长度比较
class StringLength:
    def __init__(self, s):
        self.s = s
    def __lt__(self, other):
        if isinstance(other, StringLength):
            return len(self.s) &lt; len(other.s)
        elif isinstance(other, int):
            return len(self.s) &lt; other
        else:
            raise TypeError("Unsupported operand types for &lt;: 'StringLength' and '{}'".format(type(other).__name__))
if __name__ == '__main__':
    s1 = StringLength("apple")
    s2 = StringLength("banana")
    print(s1 &lt; s2)  # True

# 3、自定义日期类
from datetime import date
class MyDate:
    def __init__(self, year, month, day):
        self.date = date(year, month, day)
    def __lt__(self, other):
        if isinstance(other, MyDate):
            return self.date &lt; other.date
        else:
            raise TypeError("Unsupported operand types for &lt;: 'MyDate' and '{}'".format(type(other).__name__))
if __name__ == '__main__':
    d1 = MyDate(2024, 3, 13)
    d2 = MyDate(2024, 6, 4)
    print(d1 &lt; d2)  # True

# 4、自定义二维点类
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def __lt__(self, other):
        if isinstance(other, Point):
            return (self.x, self.y) &lt; (other.x, other.y)
        else:
            raise TypeError("Unsupported operand types for &lt;: 'Point' and '{}'".format(type(other).__name__))
if __name__ == '__main__':
    p1 = Point(3, 6)
    p2 = Point(5, 11)
    print(p1 &lt; p2)  # True

# 5、自定义矩形面积比较
class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height
    @property
    def area(self):
        return self.width * self.height
    def __lt__(self, other):
        if isinstance(other, Rectangle):
            return self.area &lt; other.area
        else:
            raise TypeError("Unsupported operand types for &lt;: 'Rectangle' and '{}'".format(type(other).__name__))
if __name__ == '__main__':
    rect1 = Rectangle(3, 6)
    rect2 = Rectangle(5, 11)
    print(rect1 &lt; rect2)  # True

# 6、自定义字典按值排序比较(仅比较第一个值)
class ValueSortedDict:
    def __init__(self, dict_items):
        self.dict_items = sorted(dict_items.items(), key=lambda x: x[1])
    def __lt__(self, other):
        if isinstance(other, ValueSortedDict):
            return self.dict_items[0][1] &lt; other.dict_items[0][1]
        else:
            raise TypeError("Unsupported operand types for &lt;: 'ValueSortedDict' and '{}'".format(type(other).__name__))
if __name__ == '__main__':
    dict1 = {'a': 10, 'b': 24}
    dict2 = {'c': 10, 'd': 8}
    vsd1 = ValueSortedDict(dict1)
    vsd2 = ValueSortedDict(dict2)
    print(vsd1 &lt; vsd2)  # False

# 7、自定义分数类，按分数值比较
from fractions import Fraction
class FractionWrapper:
    def __init__(self, numerator, denominator):
        self.fraction = Fraction(numerator, denominator)
    def __lt__(self, other):
        if isinstance(other, FractionWrapper):
            return self.fraction &lt; other.fraction
        elif isinstance(other, Fraction):
            return self.fraction &lt; other
        else:
            raise TypeError("Unsupported operand types for &lt;: 'FractionWrapper' and '{}'".format(type(other).__name__))
if __name__ == '__main__':
    frac1 = FractionWrapper(10, 24)
    frac2 = FractionWrapper(3, 6)
    print(frac1 &lt; frac2)  # True

# 8、自定义复数类，按模长比较
import math
class ComplexNumber:
    def __init__(self, real, imag):
        self.real = real
        self.imag = imag
    @property
    def modulus(self):
        return math.sqrt(self.real ** 2 + self.imag ** 2)
    def __lt__(self, other):
        if isinstance(other, ComplexNumber):
            return self.modulus &lt; other.modulus
        else:
            raise TypeError("Unsupported operand types for &lt;: 'ComplexNumber' and '{}'".format(type(other).__name__))
if __name__ == '__main__':
    c1 = ComplexNumber(3, 6)
    c2 = ComplexNumber(5, 11)
    print(c1 &lt; c2)  # True

# 9、自定义时间戳类，按时间先后比较
from datetime import datetime, timezone
class Timestamp:
    def __init__(self, timestamp):
        self.timestamp = datetime.fromtimestamp(timestamp, tz=timezone.utc)
    def __lt__(self, other):
        if isinstance(other, Timestamp):
            return self.timestamp &lt; other.timestamp
        elif isinstance(other, datetime):
            return self.timestamp &lt; other
        else:
            raise TypeError("Unsupported operand types for &lt;: 'Timestamp' and '{}'".format(type(other).__name__))
if __name__ == '__main__':
    ts1 = Timestamp(1609459200)  # 2021-01-01 00:00:00 UTC
    ts2 = Timestamp(1609545600)  # 2021-01-02 00:00:00 UTC
    print(ts1 &lt; ts2)  # True

# 10、自定义二维点类，按字典序比较
class Point2D:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def __lt__(self, other):
        if not isinstance(other, Point2D):
            return NotImplemented
        if self.x &lt; other.x:
            return True
        elif self.x == other.x and self.y &lt; other.y:
            return True
        return False
    def __repr__(self):
        return f"Point2D({self.x}, {self.y})"
if __name__ == '__main__':
    p1 = Point2D(1, 2)
    p2 = Point2D(2, 1)
    p3 = Point2D(1, 3)
    print(p1 &lt; p2)  # True
    print(p1 &lt; p3)  # True
    print(p2 &lt; p3)  # False

# 11、自定义图书类，按价格或出版时间比较
from datetime import datetime
class Book:
    def __init__(self, title, author, price, publish_date):
        self.title = title
        self.author = author
        self.price = price
        self.publish_date = datetime.strptime(publish_date, '%Y-%m-%d')
    def __repr__(self):
        return f"Book(title={self.title}, author={self.author}, price={self.price}, publish_date={self.publish_date.strftime('%Y-%m-%d')})"
    def __lt_by_price__(self, other):
        if not isinstance(other, Book):
            return NotImplemented
        return self.price &lt; other.price
    def __lt_by_publish_date__(self, other):
        if not isinstance(other, Book):
            return NotImplemented
        return self.publish_date &lt; other.publish_date
if __name__ == '__main__':
    book1 = Book("Python Programming", "Alice", 39.99, "2022-01-01")
    book2 = Book("Java for Beginners", "Bob", 29.99, "2021-05-15")
    book3 = Book("Database Management", "Charlie", 49.99, "2022-06-30")
    # 按价格比较
    print(book1.__lt_by_price__(book2))  # True，因为book1的价格比book2高
    print(book2.__lt_by_price__(book3))  # True，因为book2的价格比book3低
    # 按出版时间比较
    print(book1.__lt_by_publish_date__(book2))  # False，因为book1的出版时间比book2晚
    print(book2.__lt_by_publish_date__(book3))  # True，因为book2的出版时间比book3早

# 12、自定义学生类，按成绩比较
class Student:
    def __init__(self, name, score):
        self.name = name
        self.score = score
    def __repr__(self):
        return f"Student(name={self.name}, score={self.score})"
    def __lt__(self, other):
        if not isinstance(other, Student):
            return NotImplemented
        return self.score &lt; other.score
if __name__ == '__main__':
    student1 = Student("Myelsa", 85)
    student2 = Student("Bruce", 90)
    student3 = Student("Jimmy", 85)
    # 按成绩比较
    print(student1 &lt; student2)  # True，因为student1的成绩比student2低
    print(student1 &lt; student3)  # False，因为student1和student3的成绩相同
    print(student2 &lt; student3)  # False，因为student2的成绩比student3高
</code></pre> 
<h3 id="%E4%BA%94%E3%80%81%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB">五、推荐阅读</h3> 
<h4 id="1%E3%80%81Python%E7%AD%91%E5%9F%BA%E4%B9%8B%E6%97%85">1、<a href="https://myelsa1024.blog.csdn.net/article/details/139241094?spm=1001.2014.3001.5502" rel="nofollow" title="Python筑基之旅">Python筑基之旅</a></h4> 
<h4 id="2%E3%80%81Python%E5%87%BD%E6%95%B0%E4%B9%8B%E6%97%85">2、<a href="https://myelsa1024.blog.csdn.net/article/details/138916144?spm=1001.2014.3001.5502" rel="nofollow" title="Python函数之旅">Python函数之旅</a></h4> 
<h4 id="3%E3%80%81Python%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85">3、<a href="https://blog.csdn.net/ygb_1024/article/details/136889623?spm=1001.2014.3001.5501" title="Python算法之旅">Python算法之旅</a></h4> 
<h4 id="4%E3%80%81%E5%8D%9A%E5%AE%A2%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5">4、<a href="https://blog.csdn.net/ygb_1024?spm=1010.2135.3001.5421" title="博客个人主页">博客个人主页</a></h4>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e33c5f42d825788e3b774a30e10bda46/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【高阶数据结构(八)】跳表详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eb3ca93d7d355b7c3ef79a0659b2dbfb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Stable diffusion prompts 使用语法、参数讲解、插件安装教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>