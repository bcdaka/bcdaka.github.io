<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Bugku---web---速度要快 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/dc84557a8fb58ef1ba69468a4254edcc/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Bugku---web---速度要快">
  <meta property="og:description" content="题目出处：首页 - Bugku CTF
✨打开链接，看到如下界面！！！
✨没有什么想法后直接抓包！！！
✨看到Cookie，像是一串加密的字符串，下面进行解密！！！发现不是一个加密字符串，所以查询cookie这个关键字的作用后发现！！！
Cookie: 这是一个HTTP头字段的名称，用于在客户端（如浏览器）和服务器之间传递小块数据。这些数据通常用于识别用户、跟踪会话或存储用户首选项。PHPSESSID: 这是Cookie的名称。在PHP中，当您开始一个会话（使用session_start()函数）时，PHP通常会设置一个名为PHPSESSID的Cookie（除非您更改了默认的会话名称）。这个Cookie的值（在这里是pqhqpqo2eblephf91j7vk83203）是一个会话标识符，用于唯一地标识一个会话。pqhqpqo2eblephf91j7vk83203: 这是PHPSESSID Cookie的值，是一个随机生成的字符串。这个值用于在服务器上识别特定的用户会话。当用户在多个页面之间导航时，浏览器会发送这个Cookie，以便服务器能够识别用户并恢复他们的会话状态（例如，他们登录的用户名、购物车中的物品等）。 ✨将此消息发送给服务器查看所给的响应是什么！！！
✨发现里面有flag，但是是一种编码形式，下面是解密过程！！！
✨结果不是正确答案，再试着解码一次！！！
✨还是不行，回头看看！！！
✨说到一段英语，大概是要提交你的margin值，根据前面所写的步骤，margin的值显然就是你解码后得到的数字！！！
✨关键来了，快速给系统给定margin的值还是没有任何结果，只能换一种解题思路了，写python脚本，将其逼出原形！！！
✨这是python脚本，运行后即可得到flag的值！！！（下面我展示的网址是又一次打开的环境，故与前述略有不同，但无影响）
import requests //导出requestes模块 import base64 //导出base64模块进行解码 url=&#34;http://114.67.175.224:13636&#34; //将url这个变量定义成我们要访问我网址 s=requests.session() //导出session模块并赋值给s；因为网页是动态的 r1=s.get(url) //用session模块想url定义的这个网站发出一个get请求，并且赋值给r1 decoded_flag = base64.b64decode(r1.headers[&#39;flag&#39;]).decode(&#39;utf-8&#39;) flag1= decoded_flag.split(&#34;:&#34;)[1] //base64对r1响应头中的flag进行解码并且赋值给flag1 flag2= base64.b64decode(flag1) //因为解码没有彻底所以对flag1进行二次解码；并且赋值给flag2 data={&#39;margin&#39;:flag2} //就是把解好码的flag2定义给margin；再将整体赋值给data r2=s.post(url,data=data) //通过session向url定义的网站进行post请求，上传刚刚定义好的data print(r2.text) //然后输出r2的网页显示内容 ✨这是第二种python运行脚本的方法，但是两者差不多，我认为第二种更为简便！！！
# 导入requests库和base64库 import requests import base64 # 定义目标URL url = &#34;http://114.67.175.224:11910&#34; # 创建一个requests.Session对象，用于保持会话状态 req = requests.Session() # 使用Session对象的get方法向URL发起GET请求，并将响应存储在res变量中 res = req.get(url) # 从响应头中获取名为&#39;flag&#39;的值，该值是一个经过两次base64编码的字符串 encoded_flag = res.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-12T20:47:16+08:00">
    <meta property="article:modified_time" content="2024-07-12T20:47:16+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Bugku---web---速度要快</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> 题目出处：<a href="https://ctf.bugku.com/" rel="nofollow" title="首页 - Bugku CTF">首页 - Bugku CTF</a></p> 
<hr> 
<p> <img alt="" height="724" src="https://images2.imgbox.com/35/92/QgDDykMn_o.png" width="1200"></p> 
<p>✨打开链接，看到如下界面！！！</p> 
<p><img alt="" height="285" src="https://images2.imgbox.com/97/6a/zuJ1JvmH_o.png" width="870"></p> 
<p>✨没有什么想法后直接抓包！！！</p> 
<p><img alt="" height="355" src="https://images2.imgbox.com/14/a8/nScUq5DM_o.png" width="1075"></p> 
<p>✨看到Cookie，像是一串加密的字符串，下面进行解密！！！发现不是一个加密字符串，所以查询cookie这个关键字的作用后发现！！！</p> 
<blockquote> 
 <ol><li><strong>Cookie</strong>: 这是一个HTTP头字段的名称，用于在客户端（如浏览器）和服务器之间传递小块数据。这些数据通常用于识别用户、跟踪会话或存储用户首选项。</li><li><strong>PHPSESSID</strong>: 这是Cookie的名称。在PHP中，当您开始一个会话（使用<code>session_start()</code>函数）时，PHP通常会设置一个名为<code>PHPSESSID</code>的Cookie（除非您更改了默认的会话名称）。这个Cookie的值（在这里是<code>pqhqpqo2eblephf91j7vk83203</code>）是一个会话标识符，用于唯一地标识一个会话。</li><li><strong>pqhqpqo2eblephf91j7vk83203</strong>: 这是<code>PHPSESSID</code> Cookie的值，是一个随机生成的字符串。这个值用于在服务器上识别特定的用户会话。当用户在多个页面之间导航时，浏览器会发送这个Cookie，以便服务器能够识别用户并恢复他们的会话状态（例如，他们登录的用户名、购物车中的物品等）。</li></ol> 
</blockquote> 
<p>✨将此消息发送给服务器查看所给的响应是什么！！！</p> 
<p><img alt="" height="499" src="https://images2.imgbox.com/7a/99/SqU3vw6i_o.png" width="743"></p> 
<p>✨发现里面有flag，但是是一种编码形式，下面是解密过程！！！</p> 
<p><img alt="" height="504" src="https://images2.imgbox.com/f3/1b/iJCdYFrG_o.png" width="1030"></p> 
<p>✨结果不是正确答案，再试着解码一次！！！</p> 
<p><img alt="" height="564" src="https://images2.imgbox.com/54/b4/MyeqMC4S_o.png" width="1027"></p> 
<p>✨还是不行，回头看看！！！</p> 
<p><img alt="" height="504" src="https://images2.imgbox.com/02/68/vw6pV5he_o.png" width="814"></p> 
<p>✨说到一段英语，大概是要提交你的margin值，根据前面所写的步骤，margin的值显然就是你解码后得到的数字！！！</p> 
<p>✨关键来了，快速给系统给定margin的值还是没有任何结果，只能换一种解题思路了，写python脚本，将其逼出原形！！！</p> 
<p>✨这是python脚本，运行后即可得到flag的值！！！（下面我展示的网址是又一次打开的环境，故与前述略有不同，但无影响）</p> 
<pre><code class="language-python">import requests       //导出requestes模块
import base64            //导出base64模块进行解码
url="http://114.67.175.224:13636"  //将url这个变量定义成我们要访问我网址
s=requests.session()          //导出session模块并赋值给s；因为网页是动态的
r1=s.get(url)              //用session模块想url定义的这个网站发出一个get请求，并且赋值给r1
decoded_flag = base64.b64decode(r1.headers['flag']).decode('utf-8')
flag1= decoded_flag.split(":")[1]  //base64对r1响应头中的flag进行解码并且赋值给flag1
flag2= base64.b64decode(flag1)     //因为解码没有彻底所以对flag1进行二次解码；并且赋值给flag2
data={'margin':flag2}       //就是把解好码的flag2定义给margin；再将整体赋值给data
r2=s.post(url,data=data)    //通过session向url定义的网站进行post请求，上传刚刚定义好的data
print(r2.text)              //然后输出r2的网页显示内容</code></pre> 
<p> <img alt="" height="901" src="https://images2.imgbox.com/46/37/jqncTHse_o.png" width="1200"></p> 
<p>✨这是第二种python运行脚本的方法，但是两者差不多，我认为第二种更为简便！！！</p> 
<pre><code class="language-python"># 导入requests库和base64库
import requests
import base64

# 定义目标URL
url = "http://114.67.175.224:11910"

# 创建一个requests.Session对象，用于保持会话状态
req = requests.Session()

# 使用Session对象的get方法向URL发起GET请求，并将响应存储在res变量中
res = req.get(url)

# 从响应头中获取名为'flag'的值，该值是一个经过两次base64编码的字符串
encoded_flag = res.headers['flag']

# 使用base64库的b64decode方法对编码后的字符串进行解码，得到原始的flag
decoded_flag = base64.b64decode(base64.b64decode(encoded_flag).decode().split(':')[1])

# 打印解码后的flag
print(decoded_flag)

# 创建一个字典d，其中包含键'margin'和值解码后的flag
d = {'margin': decoded_flag}

# 使用Session对象的post方法向URL发起POST请求，传递字典d作为数据，并将响应内容打印出来
print(req.post(url, data=d).text)
</code></pre> 
<p><img alt="" height="1162" src="https://images2.imgbox.com/6f/65/h3tIdm5X_o.png" width="1200"></p> 
<p> <img alt="" height="435" src="https://images2.imgbox.com/bc/48/V91KBfCg_o.png" width="751"></p> 
<p>✨总结！！！</p> 
<blockquote> 
 <p>      <span style="color:#ad720d;"> Cookie</span>是一种存储在用户浏览器中的小文件，用于保持服务器与客户端之间的状态。当你看到一个特定的Cookie值，如<span style="color:#ad720d;">PHPSESSID</span>，这通常表示服务器使用这个Cookie来跟踪用户的会话或认证状态。       </p> 
 <p>       当你遇到这样的Cookie信息时，它通常意味着你需要编写一个Python脚本来模拟浏览器的行为，以便与服务器进行交互并获取flag。</p> 
 <p>       在这种情况下，你可以使用Python的requests库来发送HTTP请求，并在请求中包含这个Cookie。通过这种方式，你可以模拟登录或访问受保护的资源，从而找到flag。</p> 
</blockquote> 
<blockquote> 
 <p><strong>为什么使用Python脚本进行交互？</strong></p> 
 <ol><li> <p><strong>自动化任务</strong>：Python脚本可以帮助你自动化与服务器的交互过程，例如发送请求、处理响应等。</p> </li><li> <p><strong>处理Cookie</strong>：你可以使用Python脚本来管理Cookie，包括存储、修改和传递Cookie给服务器。</p> </li><li> <p><strong>解析响应</strong>：服务器的响应通常是HTML、JSON或其他格式的数据。Python有强大的库（如BeautifulSoup、json等）来解析这些数据。</p> </li><li> <p><strong>绕过限制</strong>：有时候，服务器可能会对某些请求有限制，例如需要登录才能访问的内容。通过Python脚本，你可以模拟登录并保留登录状态，从而绕过这些限制。</p> </li><li> <p><strong>多线程或异步请求</strong>：Python可以方便地进行多线程或异步请求，提高与服务器交互的效率。</p> </li><li> <p>.................它的作用还有很多，有兴趣的可以深入探究学习。</p> </li></ol> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dee763f6942448f611b7f289184fd792/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C&#43;&#43;】哈希表的模拟实现及 unordered_set 和 unorderded_map 的封装</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5133cc08c481c4f2cbccf7c2b0a32bc5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据结构第一关---- 复杂度</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>