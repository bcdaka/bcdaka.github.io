<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>WebView2教程(基于C&#43;&#43;)【一】环境初始化 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/d03150ce1ddb975df3d20c619086b5e9/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="WebView2教程(基于C&#43;&#43;)【一】环境初始化">
  <meta property="og:description" content="创建一个VisualStudio C&#43;&#43;项目，通过NuGet包管理器安装两个包：
注意，在项目属性页设置项目使用：C&#43;&#43; 20，子系统设置成窗口（相应的预处理器也要改变），DPI识别设置成每个监视器高DPI识别。
附加依赖项设置以下几项：
dwmapi.lib shell32.lib comctl32.lib usp10.lib kernel32.lib user32.lib 新建一个main.cpp代码如下：
#include &lt;Windows.h&gt; #include &#34;App.h&#34; int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPTSTR lpCmdLine, _In_ int nCmdShow) { auto result = CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED); if (result != S_OK) { return 0; } App::init(); MSG msg; while (GetMessage(&amp;msg, NULL, 0, 0)) { TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); } CoUninitialize(); return 0; } 这是入口方法，我们在入口方法里初始化了App类
下面是App类的头文件代码如下：
#pragma once #include &lt;Windows.h&gt; #include &lt;fstream&gt; #include &lt;filesystem&gt; #include &lt;wrl.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-24T16:56:18+08:00">
    <meta property="article:modified_time" content="2024-04-24T16:56:18+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">WebView2教程(基于C&#43;&#43;)【一】环境初始化</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>创建一个VisualStudio C++项目，通过NuGet包管理器安装两个包：</p> 
<p><img alt="" height="206" src="https://images2.imgbox.com/cd/09/SVXeW4mz_o.png" width="484"></p> 
<p>注意，在项目属性页设置项目使用：C++ 20，子系统设置成窗口（相应的预处理器也要改变），DPI识别设置成每个监视器高DPI识别。</p> 
<p>附加依赖项设置以下几项：</p> 
<pre><code>dwmapi.lib
shell32.lib
comctl32.lib
usp10.lib
kernel32.lib
user32.lib</code></pre> 
<p>新建一个main.cpp代码如下：</p> 
<pre><code class="language-cpp">#include &lt;Windows.h&gt;
#include "App.h"

int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance,
 _In_ LPTSTR lpCmdLine, _In_ int nCmdShow)
{
    auto result = CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);
    if (result != S_OK) {
        return 0;
    }
    App::init();
    MSG msg;
    while (GetMessage(&amp;msg, NULL, 0, 0))
    {
        TranslateMessage(&amp;msg);
        DispatchMessage(&amp;msg);
    }
    CoUninitialize();
    return 0;
}</code></pre> 
<p>这是入口方法，我们在入口方法里初始化了App类</p> 
<p>下面是App类的头文件代码如下：</p> 
<pre><code class="language-cpp">#pragma once
#include &lt;Windows.h&gt;
#include &lt;fstream&gt;
#include &lt;filesystem&gt;
#include &lt;wrl.h&gt;
#include &lt;wil/com.h&gt;
#include &lt;WebView2.h&gt;
#include &lt;Shlobj.h&gt;
#include &lt;shellapi.h&gt;

class App
{
public:
	~App();
	static void init();
	static void dispose();
	static App* get();
	static ICoreWebView2Environment* getWebViewEnv();
	static std::wstring getAppPath();
private:
	App();
	void initConfig();
	void regScheme();
	bool checkRuntime();
	bool checkRegKey(const HKEY&amp; key, const std::wstring&amp; subKey);
	bool ensureAppFolder();
	HRESULT envCallBack(HRESULT result, ICoreWebView2Environment* env);
};

</code></pre> 
<p>先看来看看这个类的一部分代码（不是全部）：</p> 
<pre><code class="language-cpp">#include "App.h"
#include &lt;rapidjson/document.h&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;filesystem&gt;
#include &lt;fstream&gt;
#include "Util.h"
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;WebView2EnvironmentOptions.h&gt;
#include "Win.h"

using namespace Microsoft::WRL;

namespace {
	static App* app;
	static rapidjson::Document d;
	static std::vector&lt;Win*&gt; wins;
	static 	std::filesystem::path appPath;
	static ICoreWebView2Environment* webViewEnv;
}

App::App()
{
	initConfig();
	if (!checkRuntime()) {
		return;
	}
	if (!ensureAppFolder()) {
		return;
	}
	regScheme();
	auto envCBInstance = Callback&lt;ICoreWebView2CreateCoreWebView2EnvironmentCompletedHandler&gt;(this, &amp;App::envCallBack);
	HRESULT result = CreateCoreWebView2EnvironmentWithOptions(nullptr, appPath.c_str(), nullptr/*options.Get()*/, envCBInstance.Get());
	if (FAILED(result)) {
		return;
	}
}
App::~App()
{
	for (size_t i = 0; i &lt; wins.size(); i++)
	{
		delete wins[i];
	}
}
void App::init() {
	if (app) {
		return;
	}
	app = new App();
}
App* App::get() {
	return app;
}
void App::dispose()
{
	delete app;
}</code></pre> 
<p>App::init();执行之后，就创建了一个App对象，这个对象被保存在静态变量app中，在App的构造函数中，先初始化了应用程序的配置信息。代码如下：</p> 
<pre><code class="language-cpp">void App::initConfig()
{
	std::ifstream file("config.json");
	std::string content((std::istreambuf_iterator&lt;char&gt;(file)), std::istreambuf_iterator&lt;char&gt;());
	d.Parse(content.c_str());
}</code></pre> 
<p>这段代码读取应用程序(exe文件)所在目录下的config.json文件，并把这个json文件存储在静态变量：static rapidjson::Document d;中，以后我们会从这个d中获取配置信息。</p> 
<p>这个config.json文件的代码如下：</p> 
<pre><code class="language-javascript">{
  "appName": "WebView2JS",
  "windows": [
    {
      "id": "FirstWindow",
      "w": 1200,
      "h": 800,
      "miniWidth": 1200,
      "miniHeight": 800,
      "resizable": true,
      "title": "WebView2JS窗口",
      "frame": false,
      "shadow": true,
      "position": {
        "x": 100,
        "y": 100,
        "centerOfScreen": true
      },
      "webviews": [
        {
          "id": "FirstWebView",
          "url": "https://wv2js/index.html",
          "disableWindowOpen": null,
          "area": {
            "left": 0,
            "right": 0,
            "top": 0,
            "bottom": 0,
            "width": -1,
            "height": -1
          }
        }
      ]
    }
  ]
}</code></pre> 
<p>这里配置了窗口和webview的一些基本信息。</p> 
<p>需要注意的是，我们读取JSON用到了<a class="link-info" href="https://rapidjson.org/zh-cn/" rel="nofollow" title="RapidJSON">RapidJSON</a>，至于怎么用这个库，我们这里就不多做介绍了。甚至你可以完全不用json配置文件。</p> 
<p>initConfig之后，就会执行checkRuntime方法，代码如下：</p> 
<pre><code class="language-cpp">bool App::checkRuntime()
{
	std::wstring regSubKey = L"\\Microsoft\\EdgeUpdate\\Clients\\{F3017226-FE2A-4295-8BDF-00C3A9A7E4C5}";
	bool hasRuntime = checkRegKey(HKEY_LOCAL_MACHINE, L"SOFTWARE\\WOW6432Node" + regSubKey);
	if (hasRuntime) return true;
	hasRuntime = checkRegKey(HKEY_CURRENT_USER, L"Software" + regSubKey);
	if (!hasRuntime) {
		auto result = MessageBox(nullptr, L"error", L"error", MB_OKCANCEL | MB_ICONINFORMATION | MB_DEFBUTTON1);
		if (result == IDOK) {
			ShellExecute(0, 0, L"https://go.microsoft.com/fwlink/p/?LinkId=2124703", 0, 0, SW_SHOW);
		}
		return false;
	}
	return true;
}</code></pre> 
<p>这个方法会判断当前的用户环境，是否安装了WebView2的运行时，如果没有，则打开一个网页，让用户去下载WebView2的运行时。</p> 
<p>接下去执行ensureAppFolder方法，代码如下：</p> 
<pre><code class="language-cpp">bool App::ensureAppFolder() {	
	PWSTR pathTmp;
	auto ret = SHGetKnownFolderPath(FOLDERID_RoamingAppData, 0, nullptr, &amp;pathTmp);
	if (ret != S_OK) {
		CoTaskMemFree(pathTmp);
		auto result = MessageBox(nullptr, L"error", L"error", MB_OK | MB_ICONINFORMATION | MB_DEFBUTTON1);
		exit(1);
		return false;
	}
	appPath = pathTmp;
	CoTaskMemFree(pathTmp);
	appPath /= convertToWideChar(d["appName"].GetString());
	if (!std::filesystem::exists(appPath)) {
		auto flag = std::filesystem::create_directory(appPath);
		if (!flag) {
			MessageBox(nullptr, L"error", L"error", MB_OK | MB_ICONINFORMATION | MB_DEFBUTTON1);
			exit(1);
			return false;
		}
	}
	return true;
}</code></pre> 
<p>这个方法会初始化一个应用程序缓存目录，：C:\Users\[user name]\AppData\Roaming\WebView2JS，其中WebView2JS是从配置文件中读取的。</p> 
<p>目录中的文件如下图所示，这与Electron应用差不多</p> 
<p><img alt="" height="438" src="https://images2.imgbox.com/78/61/I7IH7HBB_o.png" width="374"></p> 
<p>这个路径被保存到appPath静态变量中了。</p> 
<p>接下去会执行regScheme方法：</p> 
<pre><code class="language-cpp">void App::regScheme()
{
	auto options = Microsoft::WRL::Make&lt;CoreWebView2EnvironmentOptions&gt;();
	options-&gt;put_AdditionalBrowserArguments(L"--allow-file-access-from-files");
	Microsoft::WRL::ComPtr&lt;ICoreWebView2EnvironmentOptions4&gt; options4;
	HRESULT oeResult = options.As(&amp;options4);
	const WCHAR* allowed_origins[1] = { L"*" };
	auto defaultRegistration = Microsoft::WRL::Make&lt;CoreWebView2CustomSchemeRegistration&gt;(L"wv2js");
	defaultRegistration-&gt;put_HasAuthorityComponent(TRUE);
	defaultRegistration-&gt;put_TreatAsSecure(TRUE);
	defaultRegistration-&gt;SetAllowedOrigins(1, allowed_origins);
	ICoreWebView2CustomSchemeRegistration* registrations[1] = { defaultRegistration.Get() };
	options4-&gt;SetCustomSchemeRegistrations(1, static_cast&lt;ICoreWebView2CustomSchemeRegistration**&gt;(registrations));
}</code></pre> 
<p>这个方法会为WebView注册一个自定义协议，这样我们就可以用:<a href="https://wv2js" rel="nofollow" title="https://wv2js">https://wv2js</a>这个域名加载我们的自定义页面了。</p> 
<p>App类构造函数中最后几行代码以异步的方式创建WebView2的环境变量对象，异步回调方法为：envCallBack，这个方法的代码如下：</p> 
<pre><code class="language-cpp">HRESULT App::envCallBack(HRESULT result, ICoreWebView2Environment* env)
{
	webViewEnv = env;
	rapidjson::Value&amp; winConfigs = d["windows"].GetArray();
	for (size_t i = 0; i &lt; winConfigs.Size(); i++)
	{
		wins.push_back(new Win(winConfigs[i]));
	}
	return S_OK;
}</code></pre> 
<p>在这个方法中，webview2的环境对象被保存到静态变量webViewEnv中了，接着创建了窗口对象，并保存到一个容器wins中（静态变量）。</p> 
<p>如你所见，依据我们的配置文件，我们是可以在应用程序启动时，直接创建多个窗口的。</p> 
<p>App类还有几个简单的方法，如下所示：</p> 
<pre><code class="language-cpp">ICoreWebView2Environment* App::getWebViewEnv()
{
	return webViewEnv;
}

std::wstring App::getAppPath()
{
	return appPath.wstring();
}</code></pre> 
<p>这两个方法用于给其他类提供全局信息。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d5f0cb7f93a54bf3468b8753bb8d01c8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python设计一个登录界面</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5f2f68ece8ed46cb3e0cf54b7fc4d629/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【SQL】MySQL中的字符串处理函数：concat 函数拼接字符串，COALESCE函数处理NULL字符串</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>