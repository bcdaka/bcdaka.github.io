<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】时间、空间复杂度实例分析 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/65b8db539c2ae9587cb49ba84ded940a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】时间、空间复杂度实例分析">
  <meta property="og:description" content="跌倒了，就重新站起来，继续向前走；傻坐在地上是没用的。💓💓💓
目录
•✨说在前面
🍋知识点一：算法的效率
• 🌰1.斐波那契数列的第n项
• 🌰2.算法的复杂度
🍋知识点二：时间复杂度
• 🌰1.时间复杂度的概念
• 🌰2.大O的渐进表示法
🔥复杂度的一般分析法则
🔥总结求解复杂度的方法
• 🌰3.时间复杂度的量级
• 🌰4.时间复杂度增长趋势​​​​​​​
• 🌰5.时间复杂度计算案例
🔥案例1：单个同量级for循环
🔥案例2：多个同量级for循环
🔥案例3：常数控制的for循环
🔥案例4：strchr函数的时间复杂度
🔥案例5：冒泡排序的时间复杂度
🔥案例6：调整语句为i=i*2的for循环
🔥案例7：二分查找的时间复杂度
🔥案例8：递归求阶乘
🔥案例9：递归求斐波那契数列的第n项
🍋知识点三：空间复杂度
• 🌰1.空间复杂度的概念
• 🌰2.空间复杂度计算案例
🔥案例1：冒泡排序的空间复杂度
🔥案例2：递归求阶乘
• ✨SumUp结语
•✨说在前面 亲爱的读者们大家好！💖💖💖，我们又见面了，在之前的阶段我们学习了顺序表、链表，包括单链表和双向链表，还刷了一些算法OJ练习。这些练习，我们有时可以有多种思路和方法解决，那我们如何对这些方法进行取舍呢？哪些方法是最优的呢？为此，我们必须进入学习时间复杂度和空间复杂度的相关知识，相信你学习完后就可以回答这个问题了。
👇👇👇
💘💘💘知识连线时刻（直接点击即可）
🎉🎉🎉复习回顾🎉🎉🎉
【数据结构】顺序表专题详解（带图解析）
【数据结构】单链表专题详细分析
【数据结构】双向循环链表专题解析
博主主页传送门：愿天垂怜的博客
​
🍋知识点一：算法的效率 • 🌰1.斐波那契数列的第n项 在讲解时间复杂度与空间复杂度之前，我们先看一个简单的例子：
练习：写一个程序，求出斐波那契数列的第n项的值。
方法1：迭代法
long long Fibonacci(int n) { int x1 = 1; int x2 = 1; int x3 = 1; while (n &gt;= 3) { x3 = x1 &#43; x2; x1 = x2; x2 = x3; n--; } return x3; } 方法2：递归法">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-15T23:17:17+08:00">
    <meta property="article:modified_time" content="2024-05-15T23:17:17+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】时间、空间复杂度实例分析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><span style="color:#fe2c24;"><strong>跌倒了，就重新站起来，继续向前走；傻坐在地上是没用的。💓💓💓</strong></span></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E2%80%A2%E2%9C%A8%E8%AF%B4%E5%9C%A8%E5%89%8D%E9%9D%A2-toc" style="margin-left:40px;"><a href="#%E2%80%A2%E2%9C%A8%E8%AF%B4%E5%9C%A8%E5%89%8D%E9%9D%A2" rel="nofollow">•✨说在前面</a></p> 
<p id="%F0%9F%8D%8B%E9%80%9A%E8%AE%AF%E5%BD%95%E5%9F%BA%E6%9C%AC%E9%87%8F%E8%AE%BE%E8%AE%A1-toc" style="margin-left:40px;"><a href="#%F0%9F%8D%8B%E9%80%9A%E8%AE%AF%E5%BD%95%E5%9F%BA%E6%9C%AC%E9%87%8F%E8%AE%BE%E8%AE%A1" rel="nofollow">🍋知识点一：算法的效率</a></p> 
<p id="%C2%A0%C2%A0%E2%80%A2%20%F0%9F%8C%B01.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9A%84%E7%AC%ACn%E9%A1%B9-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%E2%80%A2%20%F0%9F%8C%B01.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9A%84%E7%AC%ACn%E9%A1%B9" rel="nofollow">  • 🌰1.斐波那契数列的第n项</a></p> 
<p id="%C2%A0%E2%80%A2%20%F0%9F%8C%B02.%E5%8F%8C%E5%90%91%E5%B8%A6%E5%A4%B4%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#%C2%A0%E2%80%A2%20%F0%9F%8C%B02.%E5%8F%8C%E5%90%91%E5%B8%A6%E5%A4%B4%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84" rel="nofollow"> • 🌰2.算法的复杂度</a></p> 
<p id="%F0%9F%8D%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C%EF%BC%9A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc" style="margin-left:40px;"><a href="#%F0%9F%8D%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C%EF%BC%9A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" rel="nofollow">🍋知识点二：时间复杂度</a></p> 
<p id="%C2%A0%C2%A0%E2%80%A2%20%F0%9F%8C%B01.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%E2%80%A2%20%F0%9F%8C%B01.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">  • 🌰1.时间复杂度的概念</a></p> 
<p id="%C2%A0%E2%80%A2%20%F0%9F%8C%B02.%E5%A4%A7O%E7%9A%84%E6%B8%90%E8%BF%9B%E8%A1%A8%E7%A4%BA%E6%B3%95-toc" style="margin-left:80px;"><a href="#%C2%A0%E2%80%A2%20%F0%9F%8C%B02.%E5%A4%A7O%E7%9A%84%E6%B8%90%E8%BF%9B%E8%A1%A8%E7%A4%BA%E6%B3%95" rel="nofollow"> • 🌰2.大O的渐进表示法</a></p> 
<p id="%F0%9F%94%A5%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E4%B8%80%E8%88%AC%E5%88%86%E6%9E%90%E6%B3%95%E5%88%99-toc" style="margin-left:120px;"><a href="#%F0%9F%94%A5%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E4%B8%80%E8%88%AC%E5%88%86%E6%9E%90%E6%B3%95%E5%88%99" rel="nofollow">🔥复杂度的一般分析法则</a></p> 
<p id="%F0%9F%94%A5%E6%80%BB%E7%BB%93%E6%B1%82%E8%A7%A3%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%96%B9%E6%B3%95-toc" style="margin-left:120px;"><a href="#%F0%9F%94%A5%E6%80%BB%E7%BB%93%E6%B1%82%E8%A7%A3%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%96%B9%E6%B3%95" rel="nofollow">🔥总结求解复杂度的方法</a></p> 
<p id="%C2%A0%E2%80%A2%20%F0%9F%8C%B03.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E9%87%8F%E7%BA%A7-toc" style="margin-left:80px;"><a href="#%C2%A0%E2%80%A2%20%F0%9F%8C%B03.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E9%87%8F%E7%BA%A7" rel="nofollow"> • 🌰3.时间复杂度的量级</a></p> 
<p id="%C2%A0%E2%80%A2%20%F0%9F%8C%B04.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%A2%9E%E9%95%BF%E8%B6%8B%E5%8A%BF-toc" style="margin-left:80px;"><a href="#%C2%A0%E2%80%A2%20%F0%9F%8C%B04.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%A2%9E%E9%95%BF%E8%B6%8B%E5%8A%BF" rel="nofollow"> • 🌰4.时间复杂度增长趋势</a>​​​​​​​</p> 
<p id="%C2%A0%C2%A0%E2%80%A2%20%F0%9F%8C%B05.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97%E6%A1%88%E4%BE%8B-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%E2%80%A2%20%F0%9F%8C%B05.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97%E6%A1%88%E4%BE%8B" rel="nofollow">  • 🌰5.时间复杂度计算案例</a></p> 
<p id="%F0%9F%94%A5%E6%A1%88%E4%BE%8B1%EF%BC%9A%E5%8D%95%E4%B8%AA%E5%90%8C%E9%87%8F%E7%BA%A7for%E5%BE%AA%E7%8E%AF-toc" style="margin-left:120px;"><a href="#%F0%9F%94%A5%E6%A1%88%E4%BE%8B1%EF%BC%9A%E5%8D%95%E4%B8%AA%E5%90%8C%E9%87%8F%E7%BA%A7for%E5%BE%AA%E7%8E%AF" rel="nofollow">🔥案例1：单个同量级for循环</a></p> 
<p id="%F0%9F%94%A5%E6%A1%88%E4%BE%8B2%EF%BC%9A%E5%A4%9A%E4%B8%AA%E5%90%8C%E9%87%8F%E7%BA%A7for%E5%BE%AA%E7%8E%AF-toc" style="margin-left:120px;"><a href="#%F0%9F%94%A5%E6%A1%88%E4%BE%8B2%EF%BC%9A%E5%A4%9A%E4%B8%AA%E5%90%8C%E9%87%8F%E7%BA%A7for%E5%BE%AA%E7%8E%AF" rel="nofollow">🔥案例2：多个同量级for循环</a></p> 
<p id="%F0%9F%94%A5%E6%A1%88%E4%BE%8B3%EF%BC%9A%E5%B8%B8%E6%95%B0%E6%8E%A7%E5%88%B6%E7%9A%84for%E5%BE%AA%E7%8E%AF-toc" style="margin-left:120px;"><a href="#%F0%9F%94%A5%E6%A1%88%E4%BE%8B3%EF%BC%9A%E5%B8%B8%E6%95%B0%E6%8E%A7%E5%88%B6%E7%9A%84for%E5%BE%AA%E7%8E%AF" rel="nofollow">🔥案例3：常数控制的for循环</a></p> 
<p id="%F0%9F%94%A5%E6%A1%88%E4%BE%8B4%EF%BC%9Astrchr%E5%87%BD%E6%95%B0%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc" style="margin-left:120px;"><a href="#%F0%9F%94%A5%E6%A1%88%E4%BE%8B4%EF%BC%9Astrchr%E5%87%BD%E6%95%B0%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" rel="nofollow">🔥案例4：strchr函数的时间复杂度</a></p> 
<p id="%F0%9F%94%A5%E6%A1%88%E4%BE%8B5%EF%BC%9A%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc" style="margin-left:120px;"><a href="#%F0%9F%94%A5%E6%A1%88%E4%BE%8B5%EF%BC%9A%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" rel="nofollow">🔥案例5：冒泡排序的时间复杂度</a></p> 
<p id="%F0%9F%94%A5%E6%A1%88%E4%BE%8B6%EF%BC%9A%E8%B0%83%E6%95%B4%E8%AF%AD%E5%8F%A5%E4%B8%BAi%3Di*2%E7%9A%84for%E5%BE%AA%E7%8E%AF-toc" style="margin-left:120px;"><a href="#%F0%9F%94%A5%E6%A1%88%E4%BE%8B6%EF%BC%9A%E8%B0%83%E6%95%B4%E8%AF%AD%E5%8F%A5%E4%B8%BAi%3Di*2%E7%9A%84for%E5%BE%AA%E7%8E%AF" rel="nofollow">🔥案例6：调整语句为i=i*2的for循环</a></p> 
<p id="%F0%9F%94%A5%E6%A1%88%E4%BE%8B7%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc" style="margin-left:120px;"><a href="#%F0%9F%94%A5%E6%A1%88%E4%BE%8B7%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" rel="nofollow">🔥案例7：二分查找的时间复杂度</a></p> 
<p id="%F0%9F%94%A5%E6%A1%88%E4%BE%8B8%EF%BC%9A%E9%80%92%E5%BD%92%E6%B1%82%E9%98%B6%E4%B9%98-toc" style="margin-left:120px;"><a href="#%F0%9F%94%A5%E6%A1%88%E4%BE%8B8%EF%BC%9A%E9%80%92%E5%BD%92%E6%B1%82%E9%98%B6%E4%B9%98" rel="nofollow">🔥案例8：递归求阶乘</a></p> 
<p id="%F0%9F%94%A5%E6%A1%88%E4%BE%8B9%EF%BC%9A%E9%80%92%E5%BD%92%E6%B1%82%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9A%84%E7%AC%ACn%E9%A1%B9-toc" style="margin-left:120px;"><a href="#%F0%9F%94%A5%E6%A1%88%E4%BE%8B9%EF%BC%9A%E9%80%92%E5%BD%92%E6%B1%82%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9A%84%E7%AC%ACn%E9%A1%B9" rel="nofollow">🔥案例9：递归求斐波那契数列的第n项</a></p> 
<p id="%F0%9F%8D%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc" style="margin-left:40px;"><a href="#%F0%9F%8D%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" rel="nofollow">🍋知识点三：空间复杂度</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%E2%80%A2%20%F0%9F%8C%B01.%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%E2%80%A2%20%F0%9F%8C%B01.%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">   • 🌰1.空间复杂度的概念</a></p> 
<p id="%C2%A0%C2%A0%E2%80%A2%20%F0%9F%8C%B02.%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97%E6%A1%88%E4%BE%8B-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%E2%80%A2%20%F0%9F%8C%B02.%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97%E6%A1%88%E4%BE%8B" rel="nofollow">  • 🌰2.空间复杂度计算案例</a></p> 
<p id="%F0%9F%94%A5%E6%A1%88%E4%BE%8B1%EF%BC%9A%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc" style="margin-left:120px;"><a href="#%F0%9F%94%A5%E6%A1%88%E4%BE%8B1%EF%BC%9A%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" rel="nofollow">🔥案例1：冒泡排序的空间复杂度</a></p> 
<p id="%F0%9F%94%A5%E6%A1%88%E4%BE%8B2%EF%BC%9A%E9%80%92%E5%BD%92%E6%B1%82%E9%98%B6%E4%B9%98-toc" style="margin-left:120px;"><a href="#%F0%9F%94%A5%E6%A1%88%E4%BE%8B2%EF%BC%9A%E9%80%92%E5%BD%92%E6%B1%82%E9%98%B6%E4%B9%98" rel="nofollow">🔥案例2：递归求阶乘</a></p> 
<p id="%E2%80%A2%20%E2%9C%A8SumUp%E7%BB%93%E8%AF%AD-toc" style="margin-left:80px;"><a href="#%E2%80%A2%20%E2%9C%A8SumUp%E7%BB%93%E8%AF%AD" rel="nofollow">• ✨SumUp结语</a></p> 
<hr id="hr-toc"> 
<p></p> 
<blockquote> 
 <h3 id="%E2%80%A2%E2%9C%A8%E8%AF%B4%E5%9C%A8%E5%89%8D%E9%9D%A2" style="background-color:transparent;">•✨说在前面</h3> 
 <p>亲爱的读者们大家好！💖💖💖，我们又见面了，在之前的阶段我们学习了顺序表、链表，包括单链表和双向链表，还刷了一些算法OJ练习。<span style="color:#79c6cd;"><strong>这些练习，我们有时可以有多种思路和方法解决，那我们如何对这些方法进行取舍呢？哪些方法是最优的呢？</strong></span>为此，我们必须进入学习时间复杂度和空间复杂度的相关知识，相信你学习完后就可以回答这个问题了。</p> 
 <p>   </p> 
 <p> 👇👇👇<br> 💘💘💘知识连线时刻（直接点击即可）</p> 
 <p>  🎉🎉🎉复习回顾🎉🎉🎉</p> 
 <p><a href="https://blog.csdn.net/2302_81580770/article/details/138400994?spm=1001.2014.3001.5501" title="【数据结构】顺序表专题详解（带图解析）">【数据结构】顺序表专题详解（带图解析）</a></p> 
 <p><a href="https://blog.csdn.net/2302_81580770/article/details/138564253?spm=1001.2014.3001.5502" title="【数据结构】单链表专题详细分析">【数据结构】单链表专题详细分析</a></p> 
 <p><a href="https://blog.csdn.net/2302_81580770/article/details/138749459?spm=1001.2014.3001.5501" title="【数据结构】双向循环链表专题解析">【数据结构】双向循环链表专题解析</a></p> 
 <p>    </p> 
 <p><span style="color:#956fe7;"><strong>  博主主页传送门：</strong></span><a href="https://blog.csdn.net/2302_81580770?type=blog" title="愿天垂怜的博客">愿天垂怜的博客</a></p> 
</blockquote> 
<p><img alt="" height="298" src="https://images2.imgbox.com/f2/cf/uIUMJ5TT_o.png" width="298"></p> 
<p><img alt="" height="40" src="https://images2.imgbox.com/19/88/WMfjtsbW_o.png" width="1200">​</p> 
<blockquote> 
 <h3 id="%F0%9F%8D%8B%E9%80%9A%E8%AE%AF%E5%BD%95%E5%9F%BA%E6%9C%AC%E9%87%8F%E8%AE%BE%E8%AE%A1"><a name="t4"></a>🍋知识点一：算法的效率</h3> 
</blockquote> 
<h4 id="%C2%A0%C2%A0%E2%80%A2%20%F0%9F%8C%B01.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9A%84%E7%AC%ACn%E9%A1%B9" style="background-color:transparent;">  • 🌰1.斐波那契数列的第n项</h4> 
<p>在讲解时间复杂度与空间复杂度之前，我们先看一个简单的例子：</p> 
<p><strong>练习：写一个程序，求出斐波那契数列的第n项的值。</strong></p> 
<p><span style="color:#1c7892;"><strong>方法1：</strong></span>迭代法</p> 
<pre><code class="language-cpp">long long Fibonacci(int n)
{
	int x1 = 1;
	int x2 = 1;
	int x3 = 1;
	while (n &gt;= 3)
	{
		x3 = x1 + x2;
		x1 = x2;
		x2 = x3;
		n--;
	}
	return x3;
}</code></pre> 
<p><span style="color:#1c7892;"><strong>方法2：</strong></span>递归法</p> 
<pre><code class="language-cpp">long long Fibonacci(int n)
{
	if (n == 1 || n == 2)
		return 1;
	return Fibonacci(n - 1) + Fibonacci(n - 2);
}</code></pre> 
<p>由观察不难发现，递归的写法明显要比迭代的写法要短的多，那是不是就说明递归的写法就比迭代的写法更好呢？其实不然，实际上用递归来写的话它的运行效率将会大大降低。</p> 
<p><img alt="" height="770" src="https://images2.imgbox.com/9f/01/RUcvgZGL_o.png" width="1200"></p> 
<p>比如求第50项，就要先得到49项和48项，要得到第49项，就要得到48项和47项……它会执行很多很多次，这是它效率不高的原因。</p> 
<p>所以，项数较大时，我们还是用循环（迭代）的方式来实现。</p> 
<p>所以说，我们不能只根据程序的<span style="color:#1c7892;"><strong>长短</strong></span>就果断地判断程序的好坏。</p> 
<p><img alt="" height="40" src="https://images2.imgbox.com/8b/04/EurwpOMo_o.png" width="1200"></p> 
<h4 id="%C2%A0%E2%80%A2%20%F0%9F%8C%B02.%E5%8F%8C%E5%90%91%E5%B8%A6%E5%A4%B4%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84"> • 🌰2.算法的复杂度</h4> 
<p>那究竟如何衡量算法的好坏呢？就是要看程序的<strong>时间复杂度</strong>和<strong>空间复杂度。</strong></p> 
<p>算法在编写成可执行的程序后，运行时需要耗费时间资源和空间（内存）资源，因此衡量一个算法好坏，一般从时间和空间两个维度来衡量的，即时间复杂度和空间复杂度。</p> 
<p>时间复杂度主要衡量一个算法的<span style="color:#1c7892;"><strong>运行快慢</strong></span>，而空间复杂度主要衡量一个算法运行所需要的额外<span style="color:#1c7892;"><strong>空间</strong></span>。在计算机发展的早期，计算机的存储容量很小，所以对于空间复杂度很是在乎，但结果计算机行业的迅速发展，计算机的存储容量已经达到了很高的程度，所以我们如今已经不需要再特别关注一个算法的空间复杂度，转而更加关注他的时间复杂度。</p> 
<p><img alt="" height="40" src="https://images2.imgbox.com/fd/bc/sFSG5zUi_o.png" width="1200"></p> 
<blockquote> 
 <h3 id="%F0%9F%8D%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C%EF%BC%9A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" style="background-color:transparent;">🍋知识点二：时间复杂度</h3> 
</blockquote> 
<h4 id="%C2%A0%C2%A0%E2%80%A2%20%F0%9F%8C%B01.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5">  • 🌰1.时间复杂度的概念</h4> 
<p><strong>定义：</strong>在计算机科学中，算法的时间复杂度是一个<span style="color:#79c6cd;"><strong>函数</strong></span>，它定量描述了该算法的运行时间。</p> 
<p>一个算法执行所消耗的时间，从理论上来说，是不能算出来的，只有你把你的程序放在机器上跑起来，才能知道。但是我们需要每个算法都上机测试吗？这显然非常麻烦，所以才有了时间复杂度这个分析方式。一个算法所花费的时间与其中语句的执行次数成正比，<span style="color:#ff9900;"><strong>算法中的基本操作的执行次数，为算法的时间复杂度。</strong></span></p> 
<p>即：找到某条基本语句与问题规模N之间的数学表达式，就是算出了该算法的时间复杂度。</p> 
<p><img alt="" height="40" src="https://images2.imgbox.com/cc/d8/duM6DgzS_o.png" width="1200"></p> 
<h4 id="%C2%A0%E2%80%A2%20%F0%9F%8C%B02.%E5%A4%A7O%E7%9A%84%E6%B8%90%E8%BF%9B%E8%A1%A8%E7%A4%BA%E6%B3%95"> • 🌰2.大O的渐进表示法</h4> 
<p>实际问题中我们不需要精确的计算执行次数，而只需要<strong><span style="color:#79c6cd;">大概</span></strong>的执行次数，即使用大O的渐进表示法。</p> 
<p>公式如下：</p> 
<p><img alt="" height="137" src="https://images2.imgbox.com/e3/a3/kjpiEcIu_o.jpg" width="1200"></p> 
<p>🎉<strong>参数：</strong></p> 
<p><strong>• T(n)：</strong>代码执行所需要的时间，它是n的函数，T(n)代表了算法的时间复杂度。</p> 
<p><strong>• n：</strong>数据规模的大小，但有可能不止一个，如两个for循环分别循环m、n次，则该参数为m、n。</p> 
<p><strong>• f(n)：</strong>每行代码执行的次数总和，它是n的函数，但我们只关注最大量级的那一项。</p> 
<p><strong>• O：</strong>表示T(n)与f(n)之间的关系为正比例，即一个算法所花费的时间与其中语句的执行次数成正比。</p> 
<h5 id="%F0%9F%94%A5%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E4%B8%80%E8%88%AC%E5%88%86%E6%9E%90%E6%B3%95%E5%88%99" style="background-color:transparent;"><strong>🔥</strong><strong>复杂度的一般分析法则</strong></h5> 
<p><span style="color:#1c7892;">1）单端代码看高频：比如for、while循环。</span></p> 
<p><span style="color:#1c7892;">2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。</span></p> 
<p><span style="color:#1c7892;">3）嵌套代码求乘积：例如递归、多重循环的结构。</span></p> 
<p><span style="color:#1c7892;">4）多个规模求加法：比如算法中有两个参数控制了两个for循环，那么此时复杂度取二者复杂度之和。</span></p> 
<p>🎉<strong>举例：</strong></p> 
<pre><code class="language-cpp">//请计算一下Func1中++count语句总共执行了多少次？
void Func(int n)
{
	int count = 0;
	for (int i = 0; i &lt; n; ++i)
	{
		for (int j = 0; j &lt; n; ++j)
		{
			++count;
		}
	}

	for (int k = 0; k &lt; 2 * n; ++k)
	{
		++count;
	}
	int M = 10;
	while (M--)
	{
		++count;
	}
	printf("%d\n", count);
}</code></pre> 
<p>根据复杂度的分析原则，在上面的这个函数Func1中，第一个循环是嵌套结构，for循环嵌套结构执行了n^2次，第二个for循环执行了2n次，最后一个while循环执行了10次。</p> 
<p>由此，这个函数中基本语句的执行次数f(n)的表达式为：f(n)=n^2+2n+10，所以T(n)=O(n^2+2n+10)。但是，大O的渐进表示法并不具体代表代码真正的执行时间，而是代表代码执行时间随数据规模n增长的变化趋势。</p> 
<p>当n很大时，比如1000、100000，<strong><span style="color:#79c6cd;">此时公式中的低阶、常量、系数三部分不左右增长趋势，所以都可以忽略，只关注最高阶的那一项就可以了。</span></strong></p> 
<p>所以最终，Func的时间复杂度表示为：T(n)=O(n^2)。</p> 
<div> 
 <h5 id="%F0%9F%94%A5%E6%80%BB%E7%BB%93%E6%B1%82%E8%A7%A3%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%96%B9%E6%B3%95" style="background-color:transparent;"><strong>🔥总结求解复杂度的方法</strong></h5> 
 <p><span style="color:#1c7892;">1）只关注循环执行次数最多的一段代码，总复杂度等于量级最大的那段代码的复杂度</span></p> 
 <p><span style="color:#1c7892;">2）加法法则：若控制两个for循环的数量级相同，则总复杂度取二者复杂度之和。</span></p> 
 <p><span style="color:#1c7892;">3）乘法法则：嵌套循环的复杂度等于嵌套内外代码复杂度的乘积。</span></p> 
 <p><img alt="" height="40" src="https://images2.imgbox.com/ec/29/rlssn05s_o.png" width="1200"></p> 
 <h4 id="%C2%A0%E2%80%A2%20%F0%9F%8C%B03.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E9%87%8F%E7%BA%A7" style="background-color:transparent;"> • 🌰3.时间复杂度的量级</h4> 
 <p><img alt="" height="964" src="https://images2.imgbox.com/09/d3/F76pfsHb_o.jpg" width="1200"></p> 
</div> 
<p><span style="color:#6eaad7;"><strong>多项式阶：</strong></span>随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长，包括：O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）。</p> 
<p><span style="color:#6eaad7;"><strong>非多项式阶：</strong></span>随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，<br> O(2^n)（指数阶）、O(n!)（阶乘阶）。</p> 
<p> <img alt="" height="40" src="https://images2.imgbox.com/61/a2/n6DbTipQ_o.png" width="1200"></p> 
<h4 id="%C2%A0%E2%80%A2%20%F0%9F%8C%B04.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%A2%9E%E9%95%BF%E8%B6%8B%E5%8A%BF" style="background-color:transparent;"> • 🌰4.时间复杂度增长趋势</h4> 
<p>常见不同数量级的复杂度增长趋势图如下：</p> 
<p><img alt="" height="421" src="https://images2.imgbox.com/62/1d/cUcGRZak_o.jpg" width="694"></p> 
<p> 另外有些算法的时间复杂度存在最好、平均和最快的情况：</p> 
<p><span style="color:#6eaad7;"><strong>🎉最坏情况：</strong></span>代码在最坏情况下执行的时间复杂度，即任意输入规模的最大运行次数（上界）。</p> 
<p><span style="color:#6eaad7;"><strong>🎉平均情况：</strong></span>代码在所有情况下执行的次数的加权平均值，即任意输入规模的期望运行次数。</p> 
<p><span style="color:#6eaad7;"><strong>🎉最好情况：</strong></span>代码在最理想情况下执行的时间复杂度，任意输入规模的最小运行次数（下界）。</p> 
<p><strong>比如：在一个长度为N的数组中搜索数据x</strong></p> 
<p>最坏情况：N次找到</p> 
<p>平均情况：N/2次找到</p> 
<p>最好情况：1次找到</p> 
<p><span style="color:#79c6cd;"><strong>在实际中一般情况关注的是算法的最坏运行情况，所以数组中搜索数据的时间复杂度为O(N)。</strong></span></p> 
<h4 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="40" src="https://images2.imgbox.com/41/28/txHFBKL6_o.png" width="1200"></h4> 
<h4 id="%C2%A0%C2%A0%E2%80%A2%20%F0%9F%8C%B05.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97%E6%A1%88%E4%BE%8B" style="background-color:transparent;">  • 🌰5.时间复杂度计算案例</h4> 
<h5 id="%F0%9F%94%A5%E6%A1%88%E4%BE%8B1%EF%BC%9A%E5%8D%95%E4%B8%AA%E5%90%8C%E9%87%8F%E7%BA%A7for%E5%BE%AA%E7%8E%AF">🔥案例1：单个同量级for循环</h5> 
<p>计算Func2的时间复杂度。</p> 
<pre><code class="language-cpp">void Func2(int N)
{
	int count = 0;
	for (int k = 0; k &lt; 2 * N; ++k)
	{
		++count;
	}
	int M = 10;
	while (M--)
	{
		++count;
	}
	printf("%d\n", count);
}</code></pre> 
<p>函数Func2中，第一个for循环执行了2N次，第二个while循环的执行次数是M，但是M为已知量10，量级最大的为2N，所以Func2的时间复杂度为<strong>O(N)</strong>。</p> 
<div> 
 <img alt="" height="40" src="https://images2.imgbox.com/51/b2/MuUsgnPD_o.png" width="1200"> 
</div> 
<h5 id="%F0%9F%94%A5%E6%A1%88%E4%BE%8B2%EF%BC%9A%E5%A4%9A%E4%B8%AA%E5%90%8C%E9%87%8F%E7%BA%A7for%E5%BE%AA%E7%8E%AF">🔥案例2：多个同量级for循环</h5> 
<p>计算Func3的时间复杂度。</p> 
<pre><code class="language-cpp">void Func3(int N, int M)
{
	int count = 0;
	for (int k = 0; k &lt; M; ++k)
	{
		++count;
	}
	for (int k = 0; k &lt; N; ++k)
	{
		++count;
	}
	printf("%d\n", count);
}</code></pre> 
<p>函数Func3中，第一个for循环执行了M次，第二个for循环执行了N次，且M、N量级相同，所以Func3的时间复杂度为<strong>O(M+N)，或O(max(M，N))</strong>。</p> 
<p><strong><span style="color:#79c6cd;">注意：若M&gt;&gt;N，则时间复杂度为O(M)，若M&lt;&lt;N，则时间复杂度为O(N)。</span></strong></p> 
<p></p> 
<div> 
 <img alt="" height="40" src="https://images2.imgbox.com/24/bb/e8suSuWx_o.png" width="1200"> 
</div> 
<h5 id="%F0%9F%94%A5%E6%A1%88%E4%BE%8B3%EF%BC%9A%E5%B8%B8%E6%95%B0%E6%8E%A7%E5%88%B6%E7%9A%84for%E5%BE%AA%E7%8E%AF">🔥案例3：常数控制的for循环</h5> 
<p>计算Func4的时间复杂度。</p> 
<pre><code class="language-cpp">void Func4(int N)
{
	int count = 0;
	for (int k = 0; k &lt; 100; ++k)
	{
		++count;
	}
	printf("%d\n", count);
}</code></pre> 
<p>函数Func4中，控制for循环的次数为常数，代码不随n的增长而增长，常数阶的时间复杂度为O(1)，即Func4的时间复杂度为<strong>O(1)</strong>。</p> 
<div> 
 <img alt="" height="40" src="https://images2.imgbox.com/3d/9d/QGPqNfSy_o.png" width="1200"> 
</div> 
<h5 id="%F0%9F%94%A5%E6%A1%88%E4%BE%8B4%EF%BC%9Astrchr%E5%87%BD%E6%95%B0%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">🔥案例4：strchr函数的时间复杂度</h5> 
<p><strong>strchr：</strong>strchr() 用于查找字符串中的一个字符，并返回该字符在字符串中第一次出现的位置。</p> 
<p>strchr函数模拟实现代码如下：</p> 
<pre><code class="language-cpp">const char* my_strchr(const char* str, int character)
{
	assert(str);
	while (*str)
	{
		if (*str == character)
			return str;
		else
			str++;
	}
}</code></pre> 
<p>在strchr查找的过程中，<span style="color:#79c6cd;"><strong>最好的情况</strong></span>是字符character就在下一个字符，一次就可以找到，也就是常数阶，此时时间复杂度为O(1)；<span style="color:#79c6cd;"><strong>最坏的情况</strong></span>是字符character在离位置的无穷远处，也就是线性阶。此时时间复杂度为O(N)；取最坏的情况，所以strchr的时间复杂度为<strong>O(N)</strong>。</p> 
<div> 
 <img alt="" height="40" src="https://images2.imgbox.com/24/63/ahHxVY3C_o.png" width="1200"> 
</div> 
<h5 id="%F0%9F%94%A5%E6%A1%88%E4%BE%8B5%EF%BC%9A%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" style="background-color:transparent;">🔥案例5：冒泡排序的时间复杂度</h5> 
<p>计算冒泡排序BubSort的时间复杂度。</p> 
<pre><code class="language-cpp">void bubSort(int arr[], int length)
{
	assert(arr);
	int flag = 1;
	while (flag &amp;&amp; length--)
	{
		flag = 0;
		for (int i = 0; i &lt; length; i++)
		{
			if (arr[i] &gt; arr[i + 1])
			{
				int temp = arr[i];
				arr[i] = arr[i + 1];
				arr[i + 1] = temp;
				flag = 1;
			}
		}
	}
}</code></pre> 
<p>冒泡排序中，由类似案例2的嵌套循环结构，但是像案例2这样的嵌套循环，它的内层for循环的控制参数是不变的，也就是说，内部循环一共执行了M次，每次执行内部循环都需要循环N次，所以总共的执行次数是M*N，这很好理解，但现在冒泡排序的内部循环一共执行了length次，而第一次for循环length次，第二次length-1次，第三次length-2次...，若考虑最坏的情况，最后到1次。这种情况怎么处理呢？</p> 
<p><span style="color:#79c6cd;"><strong>显然内部for循环的循环次数是一个等差数列，其中公差d=2，首项a1=1，尾项an=length（简写为n），项数为length。</strong></span>对于这样一个等差数列，我们可以对其求和，所得到的结果不就是所有的执行次数了吗？</p> 
<p><img alt="" height="228" src="https://images2.imgbox.com/a3/b7/oRodpM2K_o.jpg" width="1200"></p> 
<p>根据高斯求和公式，很容易计算出等差数列的前n项和，即基本操作的执行次数，显然为平方阶，量级为N^2，所以冒泡排序Bubsort的时间复杂度为<strong>O(N^2)</strong>。</p> 
<p>其实对于案例2这样每次都是循环固定次数的嵌套，或者说，<span style="color:#ff9900;"><strong>任意的双层嵌套都可以转化为数列求和的问题，</strong></span><span style="color:#79c6cd;"><strong>如案例2，显然就是一个公差d=0，首项为N，尾项为N，项数为M的等差数列</strong></span></p> 
<p><img alt="" height="203" src="https://images2.imgbox.com/70/bc/k6atP6oo_o.jpg" width="1200"></p> 
<p> 根据高斯求和公式，也能够分析出基本操作的执行次数，即时间复杂度为<strong>O(MN)</strong>。</p> 
<div> 
 <img alt="" height="40" src="https://images2.imgbox.com/0b/26/0SymsPRQ_o.png" width="1200"> 
</div> 
<h5 id="%F0%9F%94%A5%E6%A1%88%E4%BE%8B6%EF%BC%9A%E8%B0%83%E6%95%B4%E8%AF%AD%E5%8F%A5%E4%B8%BAi%3Di*2%E7%9A%84for%E5%BE%AA%E7%8E%AF">🔥案例6：调整语句为i=i*2的for循环</h5> 
<p>计算Func5的时间复杂度。</p> 
<pre><code class="language-cpp">void Func5(int n)
{
	int x = 0;
	for (int i = 1; i &lt; n; i *= 2)
	{
		x++;
	}
}</code></pre> 
<p>函数Func5中，这个for循环的调整语句为i*=2，即i每次都是前一次的两倍。这种循环是有规律的，这个我们后面再说。我们先直接分析这个函数，假设基本语句x++执行了N次，那么有循环语句可得：</p> 
<p><img alt="" height="192" src="https://images2.imgbox.com/fc/4e/A3XLT28F_o.jpg" width="1200"></p> 
<p>所以我们得到，执行次数N为对数阶，所以时间复杂度为<strong>O(logN)</strong>。<span style="color:#79c6cd;"><strong>这里需要注意，为了方便起见，当底数为2时，我们直接将底数2省略不写， </strong></span></p> 
<div> 
 <img alt="" height="40" src="https://images2.imgbox.com/09/d9/Fje8RJKK_o.png" width="1200"> 
</div> 
<h5 id="%F0%9F%94%A5%E6%A1%88%E4%BE%8B7%EF%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" style="background-color:transparent;">🔥案例7：二分查找的时间复杂度</h5> 
<p>计算二分查找BinarySearch的时间复杂度。</p> 
<pre><code class="language-cpp">int BinarySearch(int arr[], int length, int x)
{
	assert(arr);
	int left = 0;
	int right = length - 1;
	while (left &lt;= right)
	{
		int mid = left + right - ((left - right) &gt;&gt; 1);
		if (arr[mid] &lt; x)
			left = mid + 1;
		else if (arr[mid] &gt; x)
			right = mid - 1;
		else if (mid == x)
			return x;
	}
	return -1;
}</code></pre> 
<p>在二分查找函数BinarySearch中，如果我们直接观察while循环的话，其实是不太好看出来的，因为left和right时不时都在改变，此时我们不要死盯代码，一定要理解它的实际意义，也可以看图进行观察</p> 
<p><img alt="" height="148" src="https://images2.imgbox.com/14/46/wh6i2V8g_o.png" width="610"></p> 
<p> 最好的情况我们很容易想到，就是要查找的x就在中间，我们一下就找到了，此时是时间复杂度为O(1)。那最坏的情况呢？其实就是当要查找的x在数组的两端的时候，比如x是第一个元素，此时我们设mid到x的距离为n，<span style="color:#79c6cd;"><strong>则mid会以每次靠近一半的速度逼近第一个元素x，也就是每次都除以2，直到这个值等于1，</strong></span>就找到了第一个元素。我们设循环执行了N次，mid第一次的位置为n，则</p> 
<p><img alt="" height="203" src="https://images2.imgbox.com/cf/84/mpvLCI8q_o.jpg" width="1200"></p> 
<p>同样地，如果x是最后一个元素，也是同样的道理。显然为对数阶，所以二分查找BinarySearch的</p> 
<p>的时间复杂度为<strong>O(logN)</strong>。</p> 
<div> 
 <img alt="" height="40" src="https://images2.imgbox.com/56/8e/i7hbD4hH_o.png" width="1200"> 
</div> 
<h5 id="%F0%9F%94%A5%E6%A1%88%E4%BE%8B8%EF%BC%9A%E9%80%92%E5%BD%92%E6%B1%82%E9%98%B6%E4%B9%98" style="background-color:transparent;">🔥案例8：递归求阶乘</h5> 
<p>计算Fact的时间复杂度。</p> 
<pre><code class="language-cpp">long long Fact(size_t N)
{
	if (0 == N)
		return 1;

	return Fac(N - 1) * N;
}</code></pre> 
<p>这是一个递归求阶乘的函数。在函数Fact中，我们假设N=5的情况如下：</p> 
<p><img alt="" height="789" src="https://images2.imgbox.com/69/2a/b3eifIA8_o.png" width="1200"></p> 
<p>可以发现，每次递归的单个函数都是常数阶，即O(1)，而递归总共调用了5+1=6次（Fact(5)、Fact(4)、Fact(3)、Fact(2)、Fact(1)、Fact(0)）。</p> 
<p>所<span style="color:#79c6cd;"><strong>以递归的函数我们先看单个函数内部的阶，再看递归了多少次。</strong></span>如果是N，那么每个函数为O(1)，递归了N+1次，那么总共为(N+1)O(1)，所以递归求阶乘函数的时间复杂度为<strong>O(N)</strong>。</p> 
<div> 
 <img alt="" height="40" src="https://images2.imgbox.com/c9/06/TMerpnrL_o.png" width="1200"> 
</div> 
<h5 id="%F0%9F%94%A5%E6%A1%88%E4%BE%8B9%EF%BC%9A%E9%80%92%E5%BD%92%E6%B1%82%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9A%84%E7%AC%ACn%E9%A1%B9" style="background-color:transparent;">🔥案例9：递归求斐波那契数列的第n项</h5> 
<p>计算Fibonacci函数的时间复杂度。</p> 
<pre><code class="language-cpp">long long Fibonacci(int n)
{
	if (n == 1 || n == 2)
		return 1;
	return Fibonacci(n - 1) + Fibonacci(n - 2);
}</code></pre> 
<p>同样的道理，我们看单个函数内部的阶，显然为O(1)，那递归了多少次呢？</p> 
<p><img alt="" height="1027" src="https://images2.imgbox.com/46/0e/uYtZRj3f_o.png" width="1200"></p> 
<p>我们以n=5为例，此时我们能画出面类似于树状图的结构，在数的每个节点都进而伸出两个节点，第一行为个数为1（2^0），第二行个数为2（2^1），第三行个数为4（2^2）...以此类推，第n行的个数为2^n。但其实上大家能看到，这颗树是歪的，它的底部缺失了一块三角形的部分，但是当n很大时，这些缺失的部分相对于整体的个数其实就很少了，<span style="color:#79c6cd;"><strong>由此我们可以将每一行的递归次数看做一项，那整体就可以看做首项a1=1，公比q=2的等比数列，求和得到的即是全体递归的总次数。</strong></span></p> 
<p><img alt="" height="271" src="https://images2.imgbox.com/47/1a/YTBLBFVx_o.jpg" width="1200"></p> 
<p><span style="color:#79c6cd;"><strong>虽然真正的递归次数没有这么多，但是它的量级是不会被影响的，</strong></span>依然是指数阶，所以用递归求斐波那契数列的第n项，它的时间复杂度为<strong>O(2^N)</strong>。</p> 
<p>稍许有些不严谨，在二叉树的部分我们还会提到。</p> 
<p><img alt="" height="40" src="https://images2.imgbox.com/7c/29/qPXxOoOa_o.png" width="1200"></p> 
<blockquote> 
 <h3 id="%F0%9F%8D%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89%EF%BC%9A%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">🍋知识点三：空间复杂度</h3> 
</blockquote> 
<h4 id="%C2%A0%C2%A0%C2%A0%E2%80%A2%20%F0%9F%8C%B01.%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5" style="background-color:transparent;">   • 🌰1.空间复杂度的概念</h4> 
<p><span style="color:#79c6cd;"><strong>空间复杂度也是一个数学表达式，</strong></span>是对一个算法在运行过程中临时占用存储空间大小的亮度。</p> 
<p><img alt="" height="186" src="https://images2.imgbox.com/3e/cc/EB1c5H9S_o.jpg" width="1200"></p> 
<p>空间复杂度不是程序占用了多少bytes的空间，因为这个也没太大意义，所以空间复杂度算的是变量的个数。</p> 
<p>空间复杂度计算规则基本和时间复杂度类似，也是大O渐进表示法。</p> 
<p>注意：<span style="color:#ff9900;"><strong>函数运行时所需要的栈空间（存储参数、局部变量、一些寄存器信息等）在编译期间已经确定好了，因此空间复杂度主要通过函数在运行时候显式的额外空间来确定。</strong></span></p> 
<h4><img alt="" height="40" src="https://images2.imgbox.com/c6/04/deBMZNsR_o.png" width="1200"></h4> 
<h4 id="%C2%A0%C2%A0%E2%80%A2%20%F0%9F%8C%B02.%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97%E6%A1%88%E4%BE%8B" style="background-color:transparent;">  • 🌰2.空间复杂度计算案例</h4> 
<h5 id="%F0%9F%94%A5%E6%A1%88%E4%BE%8B1%EF%BC%9A%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">🔥案例1：冒泡排序的空间复杂度</h5> 
<p>计算冒泡排序BubSort的空间复杂度。</p> 
<pre><code class="language-cpp">void bubSort(int arr[], int length)
{
	assert(arr);
	int flag = 1;
	while (flag &amp;&amp; length--)
	{
		flag = 0;
		for (int i = 0; i &lt; length; i++)
		{
			if (arr[i] &gt; arr[i + 1])
			{
				int temp = arr[i];
				arr[i] = arr[i + 1];
				arr[i + 1] = temp;
				flag = 1;
			}
		}
	}
}</code></pre> 
<p>在冒泡排序BubSort中，创建了：int flag = 1，int i = 0两个变量，为常数个，所以冒泡排序的空间复杂度为<strong>O(1)</strong>。 </p> 
<p><span style="color:#79c6cd;"><strong>注意：空间复杂度算的是算法中额外开辟的空间，所以数组arr和长度length并不算在内。</strong></span></p> 
<p><img alt="" height="40" src="https://images2.imgbox.com/fb/6d/552uxdf2_o.png" width="1200"></p> 
<h5 id="%F0%9F%94%A5%E6%A1%88%E4%BE%8B2%EF%BC%9A%E9%80%92%E5%BD%92%E6%B1%82%E9%98%B6%E4%B9%98" style="background-color:transparent;">🔥案例2：递归求阶乘</h5> 
<p>计算Fact函数的空间复杂度。</p> 
<pre><code class="language-cpp">long long Fact(size_t N)
{
	if (0 == N)
		return 1;

	return Fac(N - 1) * N;
}</code></pre> 
<p>对于这样的一个递归函数，每次递归都会在栈上创建栈帧空间（函数栈帧），每个栈帧使用了常数个空间，所以空间复杂度为<strong>O(N)</strong>。</p> 
<p><img alt="" height="40" src="https://images2.imgbox.com/62/41/1ybvXKwt_o.png" width="1200"></p> 
<blockquote> 
 <h4 id="%E2%80%A2%20%E2%9C%A8SumUp%E7%BB%93%E8%AF%AD">• ✨SumUp结语</h4> 
 <p>数据结构的学习一定要多画图，多理解，多思考，切忌直接抄写代码，就认为自己已经会了，一定到自己动手，才能明白自己哪个地方有问题。</p> 
 <p><span style="color:#79c6cd;"> </span></p> 
 <p><span style="color:#79c6cd;"><strong>如果大家觉得有帮助，麻烦大家点点赞，如果有错误的地方也欢迎大家指出~</strong></span></p> 
</blockquote> 
<p><img alt="" height="370" src="https://images2.imgbox.com/e6/94/VjTfrQjk_o.png" width="371"> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a81b650aecc0dc80c3edf870976e7a85/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C中Mysql的基本api接口</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/69bba8a70a676ca363f5d67d7d625253/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Hive 调优(包含hive所有调优方式 看这一篇就够了)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>