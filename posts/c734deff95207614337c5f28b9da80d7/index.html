<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SHA-256算法的原理与C/C&#43;&#43;实现 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/c734deff95207614337c5f28b9da80d7/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="SHA-256算法的原理与C/C&#43;&#43;实现">
  <meta property="og:description" content="一、原理 SHA-256 是一种加密哈希函数，旨在将任意大小的数据映射到一个固定大小的哈希值，通常是 256 位（32 字节）。它属于 SHA-2（安全哈希算法 2）家族，旨在提供更高的安全性。
SHA-256 的设计原则包括以下关键步骤：
消息填充：输入消息的位数必须是 512 的倍数。因此，第一步是对输入消息进行填充。填充包括在消息末尾附加一个 &#39;1&#39;，然后追加足够的零，使消息长度对 512 取模后余 448。追加消息长度：填充后，将原始的 64 位消息长度追加到消息的末尾。这确保了哈希值受到消息长度的影响，增强了安全性。哈希值的初始化：SHA-256 使用 8 个 32 位字作为初始哈希值。这些值是使用前 8 个素数的平方根的小数部分来设置的。消息分块：对填充后的消息分为 512 位的块，每个块包含 16 个 32 位字。消息调度：依次处理每个块，生成 64 个扩展的 32 位字。这些字大部分基于之前的字和哈希值，通过一系列逻辑函数和位运算计算得出。压缩函数：SHA-256 使用一种包含 64 轮的压缩函数，每一轮应用不同的逻辑函数和常数。每一轮都会修改哈希值的不同部分，引入新的数据。最终哈希值：处理完所有块后，最终的 8 个 32 位字被连接起来形成 256 位的哈希值。 二、C/C&#43;&#43;实现 SHA-256.h #pragma once #ifndef SHA_256_H #define SHA_256_H #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; typedef struct hash_context { uint8_t buffer[64]; uint32_t state[8]; uint32_t total[2]; } hash_context; void hash_start(hash_context* ctx); void hash_update(hash_context* ctx, uint8_t* input, size_t ilen); void hash_finish(hash_context* ctx, uint8_t* output); static void sha256_transform(hash_context* ctx, const uint8_t data[]); #endif // SHA_256_H SHA-256.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-27T22:26:50+08:00">
    <meta property="article:modified_time" content="2024-01-27T22:26:50+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SHA-256算法的原理与C/C&#43;&#43;实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、原理</h2> 
<p>SHA-256 是一种加密哈希函数，旨在将任意大小的数据映射到一个固定大小的哈希值，通常是 256 位（32 字节）。它属于 SHA-2（安全哈希算法 2）家族，旨在提供更高的安全性。</p> 
<p>SHA-256 的设计原则包括以下关键步骤：</p> 
<ul><li><strong>消息填充</strong>：输入消息的位数必须是 512 的倍数。因此，第一步是对输入消息进行填充。填充包括在消息末尾附加一个 '1'，然后追加足够的零，使消息长度对 512 取模后余 448。</li><li><strong>追加消息长度</strong>：填充后，将原始的 64 位消息长度追加到消息的末尾。这确保了哈希值受到消息长度的影响，增强了安全性。</li><li><strong>哈希值的初始化</strong>：SHA-256 使用 8 个 32 位字作为初始哈希值。这些值是使用前 8 个素数的平方根的小数部分来设置的。</li><li><strong>消息分块</strong>：对填充后的消息分为 512 位的块，每个块包含 16 个 32 位字。</li><li><strong>消息调度</strong>：依次处理每个块，生成 64 个扩展的 32 位字。这些字大部分基于之前的字和哈希值，通过一系列逻辑函数和位运算计算得出。</li><li><strong>压缩函数</strong>：SHA-256 使用一种包含 64 轮的压缩函数，每一轮应用不同的逻辑函数和常数。每一轮都会修改哈希值的不同部分，引入新的数据。</li><li><strong>最终哈希值</strong>：处理完所有块后，最终的 8 个 32 位字被连接起来形成 256 位的哈希值。</li></ul> 
<h2>二、C/C++实现</h2> 
<h3>SHA-256.h</h3> 
<pre><code class="language-cpp">#pragma once
#ifndef SHA_256_H
#define SHA_256_H

#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;

typedef struct hash_context {
    uint8_t buffer[64];
    uint32_t state[8];
    uint32_t total[2];
} hash_context;

void hash_start(hash_context* ctx);
void hash_update(hash_context* ctx, uint8_t* input, size_t ilen);
void hash_finish(hash_context* ctx, uint8_t* output);
static void sha256_transform(hash_context* ctx, const uint8_t data[]);

#endif // SHA_256_H
</code></pre> 
<h3>SHA-256.cpp</h3> 
<pre><code class="language-cpp">#include &lt;cstdint&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;time.h&gt;
#include &lt;cstdlib&gt;
#include "SHA-256.h"
using namespace std;

typedef unsigned int uint32_t;
typedef unsigned char uint8_t;

//typedef struct hash_context {
//    uint8_t buffer[64];
//    uint32_t state[8];
//    uint32_t total[2];
//} hash_context;

// SHA-256 算法的宏定义
#define ROTRIGHT(word, bits) (((word) &gt;&gt; (bits)) | ((word) &lt;&lt; (32 - (bits))))
#define CH(x, y, z) (((x) &amp; (y)) ^ (~(x) &amp; (z)))
#define MAJ(x, y, z) (((x) &amp; (y)) ^ ((x) &amp; (z)) ^ ((y) &amp; (z)))
#define EP0(x) (ROTRIGHT(x, 2) ^ ROTRIGHT(x, 13) ^ ROTRIGHT(x, 22))
#define EP1(x) (ROTRIGHT(x, 6) ^ ROTRIGHT(x, 11) ^ ROTRIGHT(x, 25))
#define SIG0(x) (ROTRIGHT(x, 7) ^ ROTRIGHT(x, 18) ^ ((x) &gt;&gt; 3))
#define SIG1(x) (ROTRIGHT(x, 17) ^ ROTRIGHT(x, 19) ^ ((x) &gt;&gt; 10))

// SHA-256 常量
static const uint32_t K[64] = {
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
};

 函数声明
//void hash_start(hash_context* ctx);
//void hash_update(hash_context* ctx, uint8_t* input, size_t ilen);
//void hash_finish(hash_context* ctx, uint8_t* output);
//static void sha256_transform(hash_context* ctx, const uint8_t data[]);


static void sha256_transform(hash_context* ctx, const uint8_t data[]) {
    uint32_t a, b, c, d, e, f, g, h, i, j, t1, t2, m[64];

    for (i = 0, j = 0; i &lt; 16; ++i, j += 4)
        m[i] = (data[j] &lt;&lt; 24) | (data[j + 1] &lt;&lt; 16) | (data[j + 2] &lt;&lt; 8) | (data[j + 3]);
    for (; i &lt; 64; ++i)
        m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];

    a = ctx-&gt;state[0];
    b = ctx-&gt;state[1];
    c = ctx-&gt;state[2];
    d = ctx-&gt;state[3];
    e = ctx-&gt;state[4];
    f = ctx-&gt;state[5];
    g = ctx-&gt;state[6];
    h = ctx-&gt;state[7];

    for (i = 0; i &lt; 64; ++i) {
        t1 = h + EP1(e) + CH(e, f, g) + K[i] + m[i];
        t2 = EP0(a) + MAJ(a, b, c);
        h = g;
        g = f;
        f = e;
        e = d + t1;
        d = c;
        c = b;
        b = a;
        a = t1 + t2;
    }

    ctx-&gt;state[0] += a;
    ctx-&gt;state[1] += b;
    ctx-&gt;state[2] += c;
    ctx-&gt;state[3] += d;
    ctx-&gt;state[4] += e;
    ctx-&gt;state[5] += f;
    ctx-&gt;state[6] += g;
    ctx-&gt;state[7] += h;
}

void hash_start(hash_context* ctx) {
    ctx-&gt;state[0] = 0x6a09e667;
    ctx-&gt;state[1] = 0xbb67ae85;
    ctx-&gt;state[2] = 0x3c6ef372;
    ctx-&gt;state[3] = 0xa54ff53a;
    ctx-&gt;state[4] = 0x510e527f;
    ctx-&gt;state[5] = 0x9b05688c;
    ctx-&gt;state[6] = 0x1f83d9ab;
    ctx-&gt;state[7] = 0x5be0cd19;

    ctx-&gt;total[0] = 0;
    ctx-&gt;total[1] = 0;
}

void hash_update(hash_context* ctx, uint8_t* input, size_t ilen) {
    size_t fill;
    uint32_t left;

    if (ilen == 0)
        return;

    left = ctx-&gt;total[0] &amp; 0x3F;
    fill = 64 - left;

    ctx-&gt;total[0] += (uint32_t)ilen;
    ctx-&gt;total[0] &amp;= 0xFFFFFFFF;

    if (ctx-&gt;total[0] &lt; (uint32_t)ilen)
        ctx-&gt;total[1]++;

    if (left &amp;&amp; ilen &gt;= fill) {
        memcpy((void*)(ctx-&gt;buffer + left), input, fill);
        sha256_transform(ctx, ctx-&gt;buffer);
        input += fill;
        ilen -= fill;
        left = 0;
    }

    while (ilen &gt;= 64) {
        sha256_transform(ctx, input);
        input += 64;
        ilen -= 64;
    }

    if (ilen &gt; 0) {
        memcpy((void*)(ctx-&gt;buffer + left), input, ilen);
    }
}

void hash_finish(hash_context* ctx, uint8_t* output) {
    uint32_t last, padn;
    uint32_t high, low;
    uint8_t msglen[8];
    high = (ctx-&gt;total[0] &gt;&gt; 29) | (ctx-&gt;total[1] &lt;&lt; 3);
    low = (ctx-&gt;total[0] &lt;&lt; 3);

    msglen[0] = (uint8_t)(high &gt;&gt; 24);
    msglen[1] = (uint8_t)(high &gt;&gt; 16);
    msglen[2] = (uint8_t)(high &gt;&gt; 8);
    msglen[3] = (uint8_t)(high);
    msglen[4] = (uint8_t)(low &gt;&gt; 24);
    msglen[5] = (uint8_t)(low &gt;&gt; 16);
    msglen[6] = (uint8_t)(low &gt;&gt; 8);
    msglen[7] = (uint8_t)(low);

    last = ctx-&gt;total[0] &amp; 0x3F;
    padn = (last &lt; 56) ? (56 - last) : (120 - last);

    hash_update(ctx, (uint8_t*)"\x80", 1);
    hash_update(ctx, (uint8_t*)(msglen + 1), padn - 1);
    hash_update(ctx, msglen, 8);

    for (int i = 0; i &lt; 8; i++) {
        output[i * 4] = (uint8_t)(ctx-&gt;state[i] &gt;&gt; 24);
        output[i * 4 + 1] = (uint8_t)(ctx-&gt;state[i] &gt;&gt; 16);
        output[i * 4 + 2] = (uint8_t)(ctx-&gt;state[i] &gt;&gt; 8);
        output[i * 4 + 3] = (uint8_t)(ctx-&gt;state[i]);
    }
}



/************************** 宏定义 **************************/
//#define DATA_SIZE 1073741824
#define DATA_SIZE 1073741824ULL // 将数据大小定义为 unsigned long long
#define ROUNDS 1ULL // 将循环次数定义为 unsigned long long

int main()
{
    hash_context ctx;

    uint8_t hash[32]; // SHA-256 输出长度为 32 字节
    clock_t start, end;

    // 初始化随机数生成器
    srand(static_cast&lt;unsigned int&gt;(time(NULL)));

    uint8_t* data = (uint8_t*)malloc(DATA_SIZE); // 分配数据缓冲区

    // 生成随机数据填充到 data 数组中
    for (unsigned long long i = 0; i &lt; DATA_SIZE; i++) // 使用 unsigned long long
    {
        data[i] = rand() &amp; 0xFF;
    }

    // 开始计时
    start = clock();
    for (unsigned long long i = 0; i &lt; ROUNDS; i++) // 使用 unsigned long long
    {
        hash_start(&amp;ctx);
        hash_update(&amp;ctx, data, DATA_SIZE);
        hash_finish(&amp;ctx, hash);
    }
    // 结束计时
    end = clock();

    // 释放分配的内存
    free(data);

    // 计算总运行时间和每秒处理的数据量
    double time = (double)(end - start) / CLOCKS_PER_SEC;
    double computing_speed = (DATA_SIZE * ROUNDS * (unsigned long long)8 / 1000 / 1000) / time;

    printf("运行时间： %f seconds\n", time);
    printf("运算速度: %f Mbps\n", computing_speed);

    return 0;
}
</code></pre> 
<h2>三、运行结果</h2> 
<p><img alt="" height="87" src="https://images2.imgbox.com/b8/0c/lnpzSN89_o.png" width="566"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1523db72a74d236cfc632db4f1750bb8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2024年最热门的十个AI对话聊天模型网站</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3f5c35ac444fd215c45aef5f9171060d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SDK does not contain ‘libarclite‘ at the path ‘/Applications/Xcode.app/Contents/Developer/Toolchains</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>