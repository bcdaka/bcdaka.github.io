<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MySQL ——多表连接查询 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/142f5fe7e729af6c528f25ae049713f6/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="MySQL ——多表连接查询">
  <meta property="og:description" content="一、（左、右和全）连接概念 内连接： 假设A和B表进行连接，使用内连接的话，凡是A表和B表能够匹配上的记录查询出来。A和B两张表没有主付之分，两张表是平等的。
关键字：inner join on
语句：select * from a_table a inner join b_table b on a.a_id = b.b_id;
说明：组合两个表中的记录，返回关联字段相符的记录，也就是返回两个表的交集（阴影）部分。
左连接（左外连接，表示左边的这张表是主表）： 假设A和B表进行连接，使用外连接的话，A，B两张表中有一张主表，一张副表，主要查询主表中数据，捎带着查询副表。当副表中数据没有和主表中的数据匹配上，副表自动模拟出NULL与之匹配。外连接主要特点： 主表中的数据无条件全部查询出来。
关键字：left join on / left outer join on
语句：select * from a_table a left join b_table b on a.a_id = b.b_id;
说明：left join 是left outer join的简写，称是左外连接，是外连接中的一种。
左(外)连接，左表(a_table)的记录将会全部表示出来，而右表(b_table)只会显示符合搜索条件的记录。右表记录不足的地方均为NULL。
右连接（右外连接，表示右边的这张表是主表）
关键字：right join on / right outer join on
语句：select * from a_table a right outer join b_table b on a.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-09-26T14:14:04+08:00">
    <meta property="article:modified_time" content="2023-09-26T14:14:04+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySQL ——多表连接查询</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、（左、右和全）连接概念</h2> 
<p><strong>内连接</strong>： 假设A和B表进行连接，使用内连接的话，凡是A表和B表能够匹配上的记录查询出来。A和B两张表没有主付之分，两张表是平等的。</p> 
<p class="img-center"><img alt="" height="171" src="https://images2.imgbox.com/d9/69/QCUa3Grl_o.png" width="239"></p> 
<p><br> 关键字：inner join on<br> 语句：select * from a_table a inner join b_table b on a.a_id = b.b_id;</p> 
<p>说明：组合两个表中的记录，返回关联字段相符的记录，也就是返回两个表的交集（阴影）部分。</p> 
<p><strong>左连接（左外连接，</strong>表示左边的这张表是主表<strong>）：</strong> 假设A和B表进行连接，使用外连接的话，A，B两张表中有一张主表，一张副表，主要查询主表中数据，捎带着查询副表。当副表中数据没有和主表中的数据匹配上，副表自动模拟出NULL与之匹配。外连接主要特点： 主表中的数据无条件全部查询出来。</p> 
<p class="img-center"><img alt="" height="161" src="https://images2.imgbox.com/0d/c6/EPqdjqoi_o.png" width="246"></p> 
<p>关键字：left join on / left outer join on<br> 语句：select * from a_table a left join b_table b on a.a_id = b.b_id;</p> 
<p>说明：left join 是left outer join的简写，称是左<a href="https://so.csdn.net/so/search?q=%E5%A4%96%E8%BF%9E%E6%8E%A5&amp;spm=1001.2101.3001.7020" title="外连接">外连接</a>，是外连接中的一种。<br> 左(外)连接，左表(a_table)的记录将会全部表示出来，而右表(b_table)只会显示符合搜索条件的记录。右表记录不足的地方均为NULL。</p> 
<p><strong>右连接（右外连接，</strong>表示右边的这张表是主表<strong>）</strong></p> 
<p class="img-center"><img alt="" height="156" src="https://images2.imgbox.com/e3/79/RnCJ2qrw_o.png" width="239"></p> 
<p><br> 关键字：right join on / right outer join on<br> 语句：select * from a_table a right outer join b_table b on a.a_id = b.b_id;<br> 说明：right join是right outer join的简写，全称是右外连接，是外连接中的一种。<br> 与左(外)连接相反，右(外)连接，左表(a_table)只会显示符合搜索条件记录，而右表(b_table)的记录将会全部表示出来。左表记录不足的地方均为NULL。</p> 
<p><strong>全连接（全外连接）</strong>MySQL目前不支持此种方式，可以用其他方式替代解决。</p> 
<p class="img-center"><img alt="" height="174" src="https://images2.imgbox.com/2c/1b/lOYUC0Qt_o.png" width="232"></p> 
<p><br> 全外连接：左表和右表都不做限制，所有记录都显示，两表不足地方用null 填充，也就是：<br> 左外连接=左表全部记录+相关联结果    ；右外连接=右表全部记录+相关联结果</p> 
<p><strong>综上：</strong></p> 
<ul><li>内连接：只返回两个表中匹配的行，即两个表中连接字段相等的行。</li><li>全连接：返回两个表中所有的行，无论是否有匹配的行。如果某个表中没有匹配的行，对应的结果集中该表的部分会使用NULL填充。</li></ul> 
<h2>二、连表查询SQL实例</h2> 
<p><strong>问题：根据下列的三张表，求出总分最高的学生。</strong></p> 
<p><img alt="" height="150" src="https://images2.imgbox.com/4d/10/nHXg9Kvu_o.png" width="200"><img alt="" height="149" src="https://images2.imgbox.com/d3/0a/gXFDd9aG_o.png" width="173"></p> 
<p><img alt="" height="284" src="https://images2.imgbox.com/00/05/3ng5zi7i_o.png" width="304"></p> 
<pre><code class="language-sql">-- create
CREATE TABLE course(
id INTEGER PRIMARY KEY,
name TEXT NOT NULL
);
CREATE TABLE student (
id INTEGER PRIMARY KEY,
name TEXT NOT NULL
);
CREATE TABLE score(
id INTEGER PRIMARY KEY,
course_id INTEGER NOT NULL,
student_id INTEGER NOT NULL,
score INTEGER NOT NULL
);

INSERT INTO course VALUES(1, "语文"), (2, "数学"), (3, "外语");
INSERT INTO student VALUES(1, "小张"), (2, "小王"), (3, "小马");
INSERT INTO score VALUES(1, 1, 1, 80), (2, 2, 1, 90), (3, 3, 1, 70);
INSERT INTO score VALUES(4, 1, 2, 70), (5, 2, 2, 90), (6, 3, 2, 80);
INSERT INTO score VALUES(7, 1, 3, 80), (8, 2, 3, 60), (9, 3, 3, 70);

SELECT *FROM course;
SELECT *FROM student;
SELECT *FROM score;</code></pre> 
<p><strong>       当然这里面包含两种情况，到底是单科总分最高，还是所有科总分加起来最高，如果面试官没有讲清楚，还是先别急于回答，或者把这两个情况都分析一遍：</strong></p> 
<p><strong>①、求所有科目总分最高的学生</strong></p> 
<pre><code class="language-sql">SELECT s.name, t.total_score 
FROM student s 
RIGHT JOIN 
    (SELECT student_id, SUM(score) AS total_score 
    FROM score 
    GROUP BY student_id 
    HAVING SUM(score) = (
        SELECT SUM(score) 
        FROM score 
        GROUP BY student_id 
        ORDER BY SUM(score) DESC 
        LIMIT 1)
     ) t ON s.id = t.student_id;</code></pre> 
<p><img alt="" height="130" src="https://images2.imgbox.com/b8/ac/aZfiik2z_o.png" width="211"></p> 
<p>具体SQL的解释如下：</p> 
<p>这个查询的目的是找到总成绩排名第一的学生，并返回该学生的姓名和总成绩。</p> 
<ol><li> <p>子查询 <code>t</code>：首先，我们执行一个子查询来计算每个学生的总成绩。</p> <p class="img-center"><img alt="" height="152" src="https://images2.imgbox.com/cc/74/0EAihChC_o.png" width="508"></p> <p>子查询从 <code>score</code> 表中获取每个学生的学生 ID (<code>student_id</code>) 和对应的成绩总和 (<code>SUM(score) AS total_score</code>)。使用 <code>GROUP BY student_id</code> 对成绩进行分组，以便计算每个学生的总成绩。然后，通过 <code>HAVING SUM(score) = (SELECT SUM(score) FROM score GROUP BY student_id ORDER BY SUM(score) DESC LIMIT 1)</code> 这一行筛选出总成绩最高的学生，确保只选择总成绩等于所有学生中最高总成绩的学生。</p> </li><li> <p>主查询：在主查询中，我们使用 <code>RIGHT JOIN</code> 将学生表 (<code>student</code>) 和子查询 <code>t</code> 关联起来。这样，我们可以获取到总成绩最高的学生以及他们的总成绩。通过 <code>ON s.id = t.student_id</code> 来建立关联条件，确保学生 ID 匹配。</p> </li><li> <p>结果过滤：在最终结果中，我们选择了学生的姓名 (<code>s.name</code>) 和对应的总成绩 (<code>t.total_score</code>)。</p> </li></ol> 
<p></p> 
<p><strong>②、求单科科目总分最高的学生</strong></p> 
<pre><code class="language-sql">SELECT s.name, c.name , s2.max_score FROM score s1
RIGHT JOIN 
    (SELECT MAX(score) max_score, course_id 
    FROM score 
    GROUP BY course_id) s2
ON s1.course_id = s2.course_id AND s1.score = s2.max_score
LEFT JOIN course c ON c.id = s1.course_id
LEFT JOIN student s ON s1.student_id = s.id</code></pre> 
<p><img alt="" height="193" src="https://images2.imgbox.com/4b/48/62JgPh8a_o.png" width="286"></p> 
<p>具体SQL的解释如下：</p> 
<ul><li><code>SELECT s.name, c.name AS course_name, s2.max_score</code>: 这部分定义了要选择的列。<code>s.name</code> 表示学生的姓名，<code>c.name AS course_name</code> 表示课程的名称（使用别名 <code>course_name</code>），<code>s2.max_score</code> 表示最高分数。</li><li><code>FROM score s1</code>: 这表示从 <code>score</code> 表中查询数据，并为其创建别名 <code>s1</code>。</li><li><code>(SELECT MAX(score) max_score, course_id FROM score GROUP BY course_id) s2</code>: 这是一个子查询，它计算每门课程的最高分，并将结果存储在 <code>s2</code> 中。它选择了每个课程的最高分数（使用别名 <code>max_score</code>）和课程ID。</li></ul> 
<p><img alt="" height="166" src="https://images2.imgbox.com/99/36/vlCgTwS6_o.png" width="512"></p> 
<ul><li><code>RIGHT JOIN</code>: 这是一个右连接，将 <code>s1</code> 和 <code>s2</code> 进行连接。它基于课程ID和最高分数匹配。</li><li><code>ON s1.course_id = s2.course_id AND s1.score = s2.max_score</code>: 这是连接条件，用于将 <code>s1</code> 和 <code>s2</code> 进行连接，使得课程ID和最高分数相匹配。</li><li><code>JOIN student s ON s1.student_id = s.id</code>: 这是一个内连接，将 <code>s1</code> 和 <code>student</code> 表连接起来。它基于学生ID匹配 （可以展示出 学生的姓名）。</li><li><code>LEFT JOIN course c ON c.id = s1.course_id</code>: 这是一个左连接，将 <code>s1</code> 和 <code>course</code> 表连接起来。它基于课程ID匹配（可以展示出 课程的名称）。</li><li>最后的查询结果将包含学生的姓名、课程名称和最高分。</li></ul> 
<p>        如果将原来的 <code>LEFT JOIN </code>连接操作更改为 <code>RIGHT JOIN</code>，则结果中将显示右表（即子查询 <code>s2</code>）的所有记录，而左表（即 <code>score s1</code>）在右表中没有匹配的记录将被包含为 NULL 值。具体来说，右连接（<code>RIGHT JOIN</code>）会返回右表中满足连接条件的记录，并且左表中不满足连接条件或没有匹配的记录将被包含为 NULL 值。</p> 
<p>        在这种情况下，由于 <code>s2</code> 是一个子查询，它计算了每门课程的最高分，并且只包含具有最高分的信息，所以使用 <code>RIGHT JOIN</code> 可能不会得到预期的结果。因为右表中的记录数量较少，而左表中的记录数量较多。</p> 
<p>        如果我们想要获取所有的学生姓名和对应课程的最高分，并将它们与课程名称进行匹配，那么使用 <code>LEFT JOIN</code> 是更常见和合适的选择。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dc64f692c65b6ce59e804ca3363f02e9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Visual Studio Code配置Tomcat运行Java Web项目</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9a2d732753c8a8518fbfd32df79115b4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【从入门到起飞】JavaAPI—BigInteger，BigDecimal的使用方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>