<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>链表-----节点最大值，累加和，统计节点个数，逆序数据建立链表以及回文字符串 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/148781863c976326a1fbe58dc85471ba/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="链表-----节点最大值，累加和，统计节点个数，逆序数据建立链表以及回文字符串">
  <meta property="og:description" content="链表-节点最大值 本题要求实现一个函数，遍历一个不带头节点的链表，求链表节点数据的最大值
节点类型定义：
struct node { int ch ; struct node *next ;}
函数接口定义： 在这里描述函数接口。例如： int max_node( struct node *p)
p是链表头指针,返回链表上最大的ch属性值。
裁判测试程序样例： #include &lt;stdio.h&gt; #include&lt;stdlib.h&gt; struct node {int ch; struct node * next;}; struct node *setlink(int N);//建立链表函数，已经定义 int max_node(struct node * head);//需要定义这个函数 int main() { int N; struct node *head; scanf(&#34;%d&#34;,&amp;N); head=setlink(N); printf(&#34;%d&#34;, max_node(head)); return 0; } 输入样例： 在这里给出一组输入。例如：
6 7 8 9 1 2 3 输出样例： 在这里给出相应的输出。例如：
9 其实这个题目相对简单，我们只需要注意链表如何后移即可 int max_node( struct node *p) { int max=0; max=p-&gt;ch; struct node * s;//定义一个临时变量 s=p; while(1) { if(s-&gt;next==NULL) break; if(s-&gt;ch&gt;max) max=s-&gt;ch; s=s-&gt;next; //可以实现进入下一个节点 } return max; } 链表—累加和 本题要求实现一个函数，遍历一个不带头结点的链表，求链表节点数据的累加和">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-02-24T15:09:49+08:00">
    <meta property="article:modified_time" content="2024-02-24T15:09:49+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">链表-----节点最大值，累加和，统计节点个数，逆序数据建立链表以及回文字符串</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>链表-节点最大值</h2> 
<p>本题要求实现一个函数，遍历一个不带头节点的链表，求链表节点数据的最大值</p> 
<p>节点类型定义：</p> 
<p>struct node { int ch ; struct node *next ;}</p> 
<h4 id="函数接口定义：">函数接口定义：</h4> 
<pre></pre> 
<p><code>在这里描述函数接口。例如： int max_node( struct node *p)</code></p> 
<p>p是链表头指针,返回链表上最大的ch属性值。</p> 
<h4 id="裁判测试程序样例：">裁判测试程序样例：</h4> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct  node
{int ch;
struct node * next;}; 

struct node *setlink(int N);//建立链表函数，已经定义

int max_node(struct node * head);//需要定义这个函数

int main()
{
int N;
struct node *head; 
scanf("%d",&amp;N); 
head=setlink(N);
printf("%d", max_node(head));
return 0;
}
</code></pre> 
<h4 id="输入样例：">输入样例：</h4> 
<p>在这里给出一组输入。例如：</p> 
<pre><code>6
7 8 9 1 2 3
</code></pre> 
<h4 id="输出样例：">输出样例：</h4> 
<p>在这里给出相应的输出。例如：</p> 
<pre><code>9</code></pre> 
<p>其实这个题目相对简单，我们<strong>只需要注意链表如何后移即可 </strong></p> 
<pre><code class="language-cs">int max_node( struct node *p)
{
    int max=0;
    max=p-&gt;ch;
    struct node * s;//定义一个临时变量
    s=p;
    while(1)
    {
        if(s-&gt;next==NULL)
            break;
        if(s-&gt;ch&gt;max)
            max=s-&gt;ch;
        s=s-&gt;next;  //可以实现进入下一个节点
    }
    return max;
}</code></pre> 
<p> </p> 
<h3>链表—累加和</h3> 
<p>本题要求实现一个函数，遍历一个不带头结点的链表，求链表节点数据的累加和</p> 
<p>节点类型定义：</p> 
<p>struct node { int ch ; struct node *next ;}</p> 
<h4>函数接口定义：</h4> 
<p><code>int sum_node( struct node *p)</code></p> 
<p>p是链表头指针,返回链表上所有节点ch属性值的累加和。</p> 
<h4>裁判测试程序样例：</h4> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct  node
{int ch;
struct node * next;};

struct node *setlink(int N);//建链表函数已经定义 
int sum_node(struct node * head);//需要定义的函数

int main()
{
int N;
struct node *head; 
scanf("%d",&amp;N); 
head=setlink(N);
printf("%d", sum_node(head));
return 0;
}
/* 请在这里填写答案 */</code></pre> 
<h4>输入样例：</h4> 
<p>在这里给出一组输入。例如：</p> 
<pre><code>6
3 1 2 7 4 5
</code></pre> 
<h4>输出样例：</h4> 
<p>在这里给出相应的输出。例如：</p> 
<pre><code>22</code></pre> 
<p>这个题目也较为简单只<strong>需要注意一下最后一步 </strong></p> 
<pre><code class="language-cs">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
int sum_node( struct node *p)
{
    int sum=0;
    struct node * s;
    s=p;
    while(1)
    {
        if(s-&gt;next==NULL)
            break;
        sum+=s-&gt;ch;
        s=s-&gt;next;
    }
    sum+=s-&gt;ch; //这里要注意尾结点的数据域在上面循环中未能进行处理
    return sum;
}</code></pre> 
<p> </p> 
<h4 style="background-color:transparent;">链表——统计节点个数</h4> 
<p>定义函数，遍历一个不带头结点的链表，统计链表上的节点个数</p> 
<h4>函数接口定义：</h4> 
<p><code>int countnode(struct node * head)</code></p> 
<p>head是链表头指针，返回值是节点个数</p> 
<h4>裁判测试程序样例：</h4> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct  node
{int ch;
struct node * next;}; 

struct node *setlink(int N);//建立链表函数已建立

int countnode(struct node * head);//需要顶一次函数

int main()
{
int i,N;
struct node *head; 
scanf("%d",&amp;N); 
head=setlink(N);
printf("%d", countnode(head));
return 0;
}

/* 请在这里填写答案 */</code></pre> 
<h4 style="background-color:transparent;">输入样例：</h4> 
<p>在这里给出一组输入。例如：</p> 
<pre><code>6
1 2 3 4 5 6
</code></pre> 
<h4 style="background-color:transparent;">输出样例：</h4> 
<p>在这里给出相应的输出。例如：</p> 
<pre><code>6</code></pre> 
<p><strong>看完前两个题目，这个题也很容易了！ </strong></p> 
<pre><code class="language-cs">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
int countnode(struct node * head)
{
    int a=0;
    struct node * s;
    s=head;
    while(1)
    {
        if(s-&gt;next==NULL)
            break;
        else
        {
            a++;
            s=s-&gt;next;
        }
    }
    return a+1; //跟第二个题一样需要注意尾结点
}</code></pre> 
<p> </p> 
<h5 style="background-color:transparent;">逆序数据建立链表</h5> 
<p>本题要求实现一个函数，按输入数据的逆序建立一个链表。</p> 
<h4>函数接口定义</h4> 
<h4><code>struct ListNode *createlist();</code></h4> 
<p>函数<code>createlist</code>利用<code>scanf</code>从输入中获取一系列正整数，当读到−1时表示输入结束。按输入数据的逆序建立一个链表，并返回链表头指针。链表节点结构定义如下：</p> 
<p><code>struct ListNode { int data; struct ListNode *next; };</code></p> 
<h4>裁判测试程序样例：</h4> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct ListNode {
    int data;
    struct ListNode *next;
};

struct ListNode *createlist();

int main()
{
    struct ListNode *p, *head = NULL;

    head = createlist();
    for ( p = head; p != NULL; p = p-&gt;next )
        printf("%d ", p-&gt;data);
    printf("\n");

    return 0;
}

/* 你的代码将被嵌在这里 */</code></pre> 
<h4>输入样例：</h4> 
<pre><code>1 2 3 4 5 6 7 -1
</code></pre> 
<h4>输出样例：</h4> 
<pre><code>7 6 5 4 3 2 1 </code></pre> 
<p><strong>看了前三个是不是感觉还可以呢，现在来上点难度 </strong></p> 
<p>分析一下题目，<strong>逆序输出链表，那不就是要用头插法建立链表么</strong>，<strong>头插法就是一直往前插入数据</strong>，而<strong>尾插法是一直往后插入数据</strong>。</p> 
<pre><code class="language-cs">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;malloc.h&gt;
struct ListNode *createlist()
{
    struct ListNode * s,* head;
    int data;
    head=(struct ListNode *)malloc(sizeof(struct ListNode));//这里我们要建立一个头结点
    head-&gt;next=NULL;  //头结点的指针域为空
    while(1)
    {
        scanf("%d",&amp;data);
        if(data==-1)//链表结束标志
            break;
        s=(struct ListNode *)malloc(sizeof(struct ListNode));
        s-&gt;data=data; //s中存储新的数据
        s-&gt;next=head-&gt;next; //s的指针域指向头结点
        head-&gt;next=s;    //头结点的指针域指向存放新数据的s
    }    //循环结束后head相当于头指针，其指针域指向我们所要的第一个节点
    return head-&gt;next;
}</code></pre> 
<p> </p> 
<h6>判断回文字符串</h6> 
<p>本题要求编写函数，判断给定的一串字符是否为“回文”。所谓“回文”是指顺读和倒读都一样的字符串。如“XYZYX”和“xyzzyx”都是回文。</p> 
<h4>函数接口定义：</h4> 
<h4><code>int Judge_char( char *s );</code></h4> 
<p>函数Judge_char判断输入字符串char *s是否为回文，若是则返回1，否则返回0。</p> 
<h4>裁判测试程序样例：</h4> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#define MAXN 20
int Judge_char( char *s );

int main()
{
    char s[MAXN];
    
    scanf("%s", s);
    if ( Judge_char(s)==1 )
        printf("Yes\n");
    else
        printf("No\n");
    printf("%s\n", s);

    return 0;
}

/* 你的代码将被嵌在这里 */</code></pre> 
<h4>输入样例：</h4> 
<pre><code>thisistrueurtsisiht
</code></pre> 
<h4>输出样例：</h4> 
<pre><code>Yes
thisistrueurtsisiht
</code></pre> 
<h4 id="输入样例：-1">输入样例：</h4> 
<pre><code>thisisnottrue
</code></pre> 
<h4 id="输出样例：-1">输出样例：</h4> 
<pre><code>No
thisisnottrue</code></pre> 
<p>最后再附上最近碰见的回文吧！ </p> 
<pre><code class="language-cs">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int Judge_char( char *s )
{
    int i=0,j;
    for(i=0,j=strlen(s)-1-i;i&lt;j;i++,j--)
    {
        if(s[i]!=s[j])
            break;
    }
    if(j&lt;=i)   //是回文的话一定存在i&gt;=j,否则不是回文
        return 1;
    if(i&lt;j)
        return 0;
}</code></pre> 
<p> 欢迎大家积极留言呀！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fe383ca3b2206ec15956217eff93f000/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【MySQL】数据类型——MySQL的数据类型分类、数值类型、小数类型、字符串类型</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2096f9fd4c57891fc5d92e1139aad6b2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">计算广告中涉及的设备id：oaid、androidid、imei、idfa、caid</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>