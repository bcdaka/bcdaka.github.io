<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>微服务系列：Spring Cloud 之 Feign、Ribbon、Hystrix 三者超时时间配置 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/a49829ba444ddb46cc58dc89b31ec7e3/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="微服务系列：Spring Cloud 之 Feign、Ribbon、Hystrix 三者超时时间配置">
  <meta property="og:description" content="Feign 自身有超时时间配置
Feign 默认集成的 Ribbon 中也有超时时间配置
假如我们又使用了 Hystrix 来实现熔断降级，Hystrix 自身也有一个超时时间配置
注: spring-cloud-starter-openfeign 低一点的版本中默认集成的有 Hystrix，高版本中又移除了。
一、Feign和 Ribbon 1. 设置 OpenFeign 的超时时间 我们首先来看一下 OpenFeign 自己的请求超时配置，直接在 yml 文件中配置：
feign: # 设置 feign 超时时间 client: config: # default 设置的全局超时时间，指定服务名称可以设置单个服务的超时时间 default: connectTimeout: 5000 readTimeout: 5000 default 默认是全局的，将 default 换成某个服务的名称可以设置单个服务的超时时间
2. 设置 Ribbon 的超时时间 ribbon: # 建立链接所用的时间，适用于网络状况正常的情况下， 两端链接所用的时间 ReadTimeout: 5000 # 指的是建立链接后从服务器读取可用资源所用的时间 ConectTimeout: 5000 注意这两个参数设置的时候没有智能提示！
ConnectTimeout：
指的是建立连接所用的时间，适用于网络状况正常的情况下，两端连接所用的时间。在java中，网络状况正常的情况下，例如使用 HttpClient 或者 HttpURLConnetion 连接时设置参数 connectTimeout=5000 即5秒，如果连接用时超过5秒就是抛出 java.net.SocketException: connetct time out 的异常。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-14T11:13:58+08:00">
    <meta property="article:modified_time" content="2024-08-14T11:13:58+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">微服务系列：Spring Cloud 之 Feign、Ribbon、Hystrix 三者超时时间配置</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <ul><li> <p><code>Feign</code> 自身有超时时间配置</p> </li><li> <p><code>Feign</code> 默认集成的 <code>Ribbon</code> 中也有超时时间配置</p> </li><li> <p>假如我们又使用了 <code>Hystrix</code> 来实现熔断降级，<code>Hystrix</code> 自身也有一个超时时间配置</p> </li></ul> 
<p>注: <code>spring-cloud-starter-openfeign</code> 低一点的版本中默认集成的有 <code>Hystrix</code>，高版本中又移除了。</p> 
<hr> 
<h3>一、Feign和 Ribbon</h3> 
<h4>1. 设置 OpenFeign 的超时时间</h4> 
<p>我们首先来看一下 <code>OpenFeign</code> 自己的请求超时配置，直接在 yml 文件中配置：</p> 
<pre><code class="language-XML">feign:
 # 设置 feign 超时时间
 client:
   config:
     # default 设置的全局超时时间，指定服务名称可以设置单个服务的超时时间
     default:
       connectTimeout: 5000
       readTimeout: 5000</code></pre> 
<p>default 默认是全局的，将 default 换成某个服务的名称可以设置单个服务的超时时间</p> 
<h4>2. 设置 Ribbon 的超时时间</h4> 
<pre><code class="language-XML">ribbon:
     # 建立链接所用的时间，适用于网络状况正常的情况下， 两端链接所用的时间
     ReadTimeout: 5000
     # 指的是建立链接后从服务器读取可用资源所用的时间
     ConectTimeout: 5000</code></pre> 
<p>注意这两个参数设置的时候没有智能提示！</p> 
<p><strong>ConnectTimeout：</strong></p> 
<p>指的是建立连接所用的时间，适用于网络状况正常的情况下，两端连接所用的时间。在java中，网络状况正常的情况下，例如使用 HttpClient 或者 HttpURLConnetion 连接时设置参数 connectTimeout=5000 即5秒，如果连接用时超过5秒就是抛出 java.net.SocketException: connetct time out 的异常。</p> 
<p><strong>ReadTimeout：</strong></p> 
<p>指的是建立连接后从服务器读取到可用资源所用的时间。在这里我们可以这样理解ReadTimeout：正常情况下，当我们发出请求时可以收到请求的结果，也就是页面上展示的内容，但是当网络状况很差的时候，就会出现页面上无法展示出内容的情况。另外当我们使用爬虫或者其他全自动的程序时，无法判断当前的网络状况是否良好，此时就有了ReadTimeout的用武之地了，通过设置ReadTimeout参数，例：ReadTimeout=5000，超过5秒没有读取到内容时，就认为此次读取不到内容并抛出Java.net.SocketException: read time out的异常。</p> 
<h4>3. 源码追踪</h4> 
<p>配置都比较简单，接下来我们来追踪一下相关的源码。</p> 
<p>首先从 <code>@EnableFeignClients</code> 进去，再到 <code>FeignClientsRegistrar</code> 类中</p> 
<p class="img-center"><img alt="" height="228" src="https://images2.imgbox.com/0e/70/wzEfb2SN_o.png" width="810"></p> 
<p></p> 
<p class="img-center"><img alt="" height="398" src="https://images2.imgbox.com/90/79/e5Y2S1d5_o.png" width="648"></p> 
<p>跟踪到 <code>FeignClientsRegistrar</code> 类中的 <code>registerFeignClient</code> 方法</p> 
<p class="img-center"><img alt="" height="192" src="https://images2.imgbox.com/09/4b/KgbbPvTB_o.png" width="1080"></p> 
<p>接着到 <code>FeignClientFactoryBean</code> 类中的 <code>configureUsingProperties</code> 方法</p> 
<p class="img-center"><img alt="" height="202" src="https://images2.imgbox.com/3c/d0/y3wLhaEK_o.png" width="1080"></p> 
<p>最后一直跟到 <code>feign.Request</code> 中的这里</p> 
<p class="img-center"><img alt="" height="89" src="https://images2.imgbox.com/9f/c7/75HIhXNZ_o.png" width="1080"></p> 
<p>可以发现 <code>OpenFeign</code> 的默认的 <code>connectTimeout</code> 是 10 秒，<code>readTimeout</code> 是 60 秒。</p> 
<p>接下来我们来验证一下，修改我们测试用的那个接口，让它睡个 5 秒</p> 
<pre><code class="language-XML">@GetMapping("/getUserInfo")
public Map&lt;String, Object&gt; getUserInfo(int userId){
   Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
   User user = new User(1, "小黑", 26);
   map.put("code", 200);
   map.put("data", user.toString());
   try {
       Thread.sleep(5000);
   } catch (InterruptedException e) {
     e.printStackTrace();
   }
   return map;
}</code></pre> 
<ul><li> <p><code>OpenFeign</code> 默认超时时间</p> </li></ul> 
<p>此时，我们是要验证 <code>OpenFeign</code> 的默认超时时间，所以在 <code>application.yml</code> 中 feign 和 ribbon 的超时时间都没有设置。</p> 
<p>启动项目再次调用我们的老接口：<code>http://localhost:9203/test/getUserInfo?userId=2</code></p> 
<p class="img-center"><img alt="" height="162" src="https://images2.imgbox.com/0d/cc/zBVzrjVE_o.png" width="1080"></p> 
<p>疑问? 报错了，连接超时，可是我们代码里睡 5 秒，明明还在超时时间范围内，怎么就连接超时了呐？</p> 
<p>其实 <code>OpenFeign</code> 集成了 <code>Ribbon</code>，Ribbon 的默认超时连接时间、读超时时间都是 1 秒，源码在 <code>org.springframework.cloud.openfeign.ribbon.FeignLoadBalancer#execute()</code>方法中，如下图：</p> 
<p class="img-center"><img alt="" height="197" src="https://images2.imgbox.com/8d/84/aj8unnoq_o.png" width="1080"></p> 
<p>断点打到这里（需要访问上面接口才会进断点）会发现：如果<code>OpenFeign</code> 没有设置对应得超时时间，那么将会采用 <code>Ribbon</code> 的默认超时时间</p> 
<p class="img-center"><img alt="" height="230" src="https://images2.imgbox.com/dc/f7/O5MQTrTV_o.png" width="1080"></p> 
<p class="img-center"><img alt="" height="176" src="https://images2.imgbox.com/c3/01/m7Vhohrr_o.png" width="1080"></p> 
<ul><li> <p>设置 <code>OpenFeign</code> 超时时间</p> </li></ul> 
<pre><code class="language-XML">feign:
client:
  config:
    default:
      connectTimeout: 8000
      readTimeout: 8000</code></pre> 
<p>然后我们重启项目后再访问接口进入上面那个断点看看，发现超时时间变成我们配置的了</p> 
<p class="img-center"><img alt="" height="201" src="https://images2.imgbox.com/69/d2/0ZX2jO0T_o.png" width="1080"></p> 
<p>接口也返回了正常的结果：</p> 
<p><img alt="" height="190" src="https://images2.imgbox.com/3f/b8/yCF731bN_o.png" width="736"></p> 
<ul><li> <p>设置 <code>Ribbon</code> 超时时间</p> </li></ul> 
<pre><code class="language-XML">ribbon:
    ReadTimeout: 7000
    ConectTimeout: 7000</code></pre> 
<p>重复上面步骤，断点进去一看 ？？？怎么还是 8000</p> 
<p class="img-center"><img alt="" height="361" src="https://images2.imgbox.com/73/3f/i6vn2xEl_o.png" width="1080"></p> 
<p>原因是 ，<code>OpenFeign</code> 和 <code>Ribbon</code> 的超时时间只会有一个生效两者是二选一的，且 <code>OpenFeign</code> 优先。并且，注掉 <code>OpenFeign</code> 超时时间配置之后，就变成了使用设置的 <code>Ribbon</code> 的超时时间，更加验证了<code>OpenFeign</code> 优先。</p> 
<h4>4. 结论</h4> 
<p><code>Feign</code> 和 <code>Ribbon</code> 的超时时间<strong>只会有一个生效</strong>，规则：</p> 
<ul><li> <p>如果没有设置过<strong>feign超时（</strong>也就是等于默认值的时候）<strong>，</strong>就会读取 ribbon 的配置，使用 ribbon 的超时时间和重试设置。</p> </li><li> <p>如果设置了feign超时，则使用 feign 自身的设置。两者是二选一的，且 feign 优先<em>。</em></p> </li></ul> 
<hr> 
<h3>二、Ribbon 和 Hystrix</h3> 
<h4>1. Hystrix 设置超时时间</h4> 
<pre><code class="language-XML"># 先要开启feign.hystrix.enabled，然后下面这个配置才会起作用
feign:
  hystrix:
    enabled: true

hystrix:
  command:
    default:
      execution:
        timeout:
          enabled: true
        isolation:
          thread:
            timeoutInMilliseconds: 5000</code></pre> 
<p>配置好 fallback</p> 
<pre><code class="language-XML">@FeignClient(contextId = "remoteUserService", value = "cloud-system", fallbackFactory = RemoteUserFallbackFactory.class)</code></pre> 
<p>注意：如果<strong>没有配置 fallback</strong>，那么 <strong>hystrix 的超时就不会生效</strong>，而是由 ribbon 来控制。</p> 
<p>hystrix 的默认超时时间是 1s，这个配置在 HystrixCommandProperties 类中：</p> 
<pre><code class="language-XML">private static final Integer default_executionTimeoutInMilliseconds = 1000;</code></pre> 
<p>设置 hystrix 超时时间比 ribbon 大（OpenFign 的超时时间注掉）</p> 
<pre><code class="language-XML">ribbon:
  ReadTimeout: 2000
  ConectTimeout: 2000</code></pre> 
<p>访问地址 <code>http://localhost:9203/test/getUserInfo?userId=2</code> 发现请求 2s 左右就返回了，这个值刚好是 ribbon.ReadTimeout 的时间。表示此时 ribbon 超时触发了。然后进入了 hystrix 的熔断过程。</p> 
<h4>2. 结论：</h4> 
<ul><li> <p>如果请求时间超过 ribbon 的超时配置，会触发重试；</p> </li><li> <p>在配置 fallback 的情况下，如果请求的时间(包括 ribbon 的重试时间)，超出了 ribbon 的超时限制，或者 hystrix 的超时限制，那么就会熔断。</p> </li></ul> 
<p>一般来说，会设置 ribbon 的超时时间 &lt; hystrix， 这是因为 ribbon 有重试机制。(这里说的 ribbon 超时时间是包括重试在内的，即，最好要让 ribbon 的重试全部执行，直到 ribbon 超时被触发)。</p> 
<p><strong>由于 connectionTime 一般比较短，可以忽略</strong>。那么，设置的超时时间应该满足如下，避免ribbon还未重试完就过早的被Hystrix熔断了：</p> 
<pre>(1 + MaxAutoRetries) * (1 + MaxAutoRetriesNextServer)* ReadTimeOut &lt; hystrix 的 *timeoutInMilliseconds</pre> 
<p></p> 
<h3>附录1:</h3> 
<h4>一、 Feign设置超时时间</h4> 
<p>使用Feign调用接口分两层，ribbon的调用和hystrix的调用，所以ribbon的超时时间和Hystrix的超时时间的结合就是Feign的超时时间</p> 
<pre><code class="language-XML">#hystrix的超时时间
hystrix:
    command:
        default:
            execution:
              timeout:
                enabled: true
              isolation:
                thread:
                  timeoutInMilliseconds: 9000
#ribbon的超时时间
ribbon:
  ReadTimeout: 60000
  ConnectTimeout: 60000</code></pre> 
<p>一般情况下 都是 ribbon 的超时时间（&lt;）hystrix的超时时间（因为涉及到ribbon的重试机制）<strong>因为ribbon的重试机制和Feign的重试机制有冲突，所以源码中默认关闭Feign的重试机制，源码如下</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="286" src="https://images2.imgbox.com/a6/df/daJCBh9z_o.png" width="796"></p> 
<p>要开启Feign的重试机制如下：（Feign默认重试五次 源码中有）</p> 
<pre><code>@Bean
Retryer feignRetryer() {
        return  new Retryer.Default();
}</code></pre> 
<p></p> 
<h5>二、ribbon的重试机制</h5> 
<p>设置重试次数：</p> 
<pre><code class="language-XML">ribbon:
  ReadTimeout: 3000
  ConnectTimeout: 3000
  MaxAutoRetries: 1 #同一台实例最大重试次数,不包括首次调用
  MaxAutoRetriesNextServer: 1 #重试负载均衡其他的实例最大重试次数,不包括首次调用
  OkToRetryOnAllOperations: false  #是否所有操作都重试</code></pre> 
<p>根据上面的参数计算重试的次数：MaxAutoRetries+MaxAutoRetriesNextServer+(MaxAutoRetries *MaxAutoRetriesNextServer) 即重试3次 则一共产生4次调用如果在重试期间，时间超过了hystrix的超时时间，便会立即执行熔断，fallback。所以要根据上面配置的参数计算hystrix的超时时间，使得在重试期间不能达到hystrix的超时时间，不然重试机制就会没有意义。hystrix超时时间的计算：(1 + MaxAutoRetries + MaxAutoRetriesNextServer) * ReadTimeout 即按照以上的配置 hystrix的超时时间应该配置为 （1+1+1）*3=9秒</p> 
<p>当ribbon超时后且hystrix没有超时，便会采取重试机制。当OkToRetryOnAllOperations设置为false时，只会对get请求进行重试。如果设置为true，便会对所有的请求进行重试，如果是put或post等写操作，如果服务器接口没做幂等性，会产生不好的结果，所以OkToRetryOnAllOperations慎用。</p> 
<p>如果不配置ribbon的重试次数，默认会重试一次<em>注意：</em><strong>默认情况下,GET方式请求无论是连接异常还是读取异常,都会进行重试</strong><strong>非GET方式请求,只有连接异常时,才会进行重试</strong></p> 
<p></p> 
<h3>附录2  spring cloud ribbon配置自动重试</h3> 
<p>spring cloud 通过eureka 访问其他服务默认没有重试机制，需要额外进行配置实现客户端重试，特别是对方服务在进行滚动发布的时候，本地维护的节点信息还没有更新，就需要进行自动重试，保证前端业务流畅。</p> 
<p>pom文件添加依赖：</p> 
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt;
    &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre> 
<p>应用添加配置：</p> 
<pre><code>ribbon.ReadTimeout=30000
ribbon.ConnectTimeout=5000
ribbon.SocketTimeout=30000
ribbon.MaxAutoRetries=0
ribbon.MaxAutoRetriesNextServer=2
ribbon.OkToRetryOnAllOperations=true
ribbon.ServerListRefreshInterval=5000

spring.cloud.loadbalancer.retry.enable=true</code></pre> 
<p>客户端使用可以直接根据服务名进行访问了：服务内注入restTemplate进行外部服务访问：</p> 
<pre><code>BaseResponse response = restTemplate.postForObject("http://xxx-service/cellphone", req, new BaseResponse&lt;String&gt;().getClass());</code></pre> 
<p>4 补充实现AbstractLoadBalancingClient的类有</p> 
<p>4.1  RetryableOkHttpLoadBalancingClient（spring-retry）开启条件</p> 
<pre><code class="language-XML"># 导入spring-retry 依赖
ribbon.okhttp.enabled=true
ribbon.httpclient.enabled=false
</code></pre> 
<p>4.2 OkHttpLoadBalancingClient开启条件</p> 
<pre><code class="language-XML">ribbon.okhttp.enabled=true
ribbon.httpclient.enabled=false</code></pre> 
<p>4.3 RibbonLoadBalancingHttpClient开启条件默认</p> 
<p>4.4 RetryableRibbonLoadBalancingHttpClient（spring-try）开启条件</p> 
<pre><code class="language-XML">spring.cloud.loadbalancer.retry.enabled=true
zuul.retryable=true
#导入spring-try
#Retry 次数计算
#reTry次数的计算= (MaxAutoRetries*+1）*（MaxAutoRetriesNextServer+1）</code></pre> 
<p>超时最大时间</p> 
<p><span style="color:#fe2c24;">ribbonTimeout=(ribbonReadTimeout+ ribbonConnectTimeout) *(maxAutoRetries + 1) * (maxAutoRetriesNextServer+ 1)</span></p> 
<p>gateway:</p> 
<pre>- name: Retry
args:
retries: 1
methods: GET,POST
#多个参数用-连接
statuses: BAD_GATEWAY
#参考同上,series与statuses二选一即可
series:
  #表示5xx,以5开头的各种状态码

- SERVER_ERROR
  exceptions:
      #有以下异常时触发重试,此处注意timeout的时间与熔断设置的时间

   - java.util.concurrent.TimeoutException
     - java.net.ConnectException
</pre> 
<p>get io异常 重试；post io异常 不重试；</p> 
<p>ribbon resttemplate:</p> 
<pre>spring.cloud.loadbalancer.retry.enabled=true
ribbon.ConnectTimeout=1000
ribbon.ReadTimeout=10000
ribbon.OkToRetryOnAllOperations=false
ribbon.MaxAutoRetriesNextServer=2
ribbon.maxAutoRetries=0</pre> 
<p>get 在发生io异常的时候回进行重试；post 在发生io异常不会进行重试；开启Hystrix</p> 
<p>       同样的，Feign中已经内置了Hystrix，直接通过配置来开启Hystrix，如下所示：</p> 
<pre><code>feign:
	hsytrix:
		enabled: true</code></pre> 
<h6>开启Feign功能</h6> 
<p>       在服务消费方的引导类上添加注解@EnableFeignClients，用于开启Feign功能。</p> 
<h4>优化Feign第一次调用的策略</h4> 
<p>Feign初始化开销<br> 懒加载（Lazy Loading）：Feign客户端通常是在需要时才进行初始化的，这种机制被称为懒加载。当第一次调用Feign客户端时，它会执行一系列的初始化操作，包括加载配置、创建代理对象、解析服务地址、建立连接池等。这些操作都需要一定的时间来完成，因此第一次调用自然会相对较慢。<br> 服务发现和注册：如果你的应用使用了服务注册与发现机制（如Eureka、Consul等），Feign在第一次调用时还需要从注册中心获取服务的实例信息。这个过程涉及到网络通信和DNS解析，可能会因为网络延迟或注册中心的性能问题而变慢。<br> 线程池和连接池初始化：Feign在进行远程调用时，通常会使用线程池来管理线程，以及连接池来管理HTTP连接。第一次调用时，这些资源可能还没有初始化好，Feign需要创建新的线程和连接，这也会增加调用的启动时间。<br> 类加载和代理生成：Feign使用动态代理来生成客户端代码，第一次调用时可能需要加载和生成相关的类，这同样会增加调用的启动时间。</p> 
<p>Ribbon饥饿加载：开启Ribbon的饥饿加载模式，让Ribbon在应用启动时就完成服务列表的加载和缓存，避免在第一次调用时进行这些操作。配置方式如下：</p> 
<pre><code class="language-XML">ribbon:
  eager-load:
    enabled: true  
    clients: your-feign-client-name # 注解 @FeignClient 中的 value 值写在此处
</code></pre> 
<h5 id="h6">Feign配置压缩</h5> 
<p> Spring Cloud Feign能够对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。直接通过配置feign中的参数即可开启压缩功能，如下所示：</p> 
<pre><code>feign:
	compression:
		request:
			enabled: true #请求压缩
			mime-types: text/html,application/xml,application.json #压缩的数据类型
			mim-request-size: 2048 #设置触发压缩的大小下限
		response:
			enabled: true #响应压缩</code></pre> 
<p><strong>Feign支持的日志级别</strong>：<br>        （1） NONE： 不记录任何日志信息，默认</p> 
<p>       （2） BASIC： 只记录请求的方法，URL以及响应状态码和执行时间</p> 
<p>       （3） HEADERS：在BASIC的基础上，添加了请求和响应的头信息</p> 
<p>       （4） FULL：记录所有请求和响应的明细，包括头信息，请求体，元数据</p> 
<p><strong> (1)开启Feign日志配置文件写法：</strong><br> 开启Feign的日志功能，可以帮助你更清晰地了解Feign在调用过程中的行为，包括初始化过程、请求发送、响应接收等。这有助于你定位问题并进行优化。配置方式如下：</p> 
<pre><code>feign:
  client:  
    config:  
      default:  
        loggerLevel: full
  
logging:  
  level:  
    com.yourpackage.feignclient: debug
</code></pre> 
<h6>(2)开启Feign日志的配置类写法：</h6> 
<p>       添加Feign的配置类，定义日志级别。注意，要在该配置类上添加@Configuration表示这是一个配置类。</p> 
<pre><code id="code_id_10">package com.springboot.config;

import feign.Logger;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class FeignConfig {

    @Bean
    Logger.Level feignLoggerLevel(){
        return Logger.Level.FULL;
    }
}</code></pre> 
<p><strong>Feign Hystrix 熔断、线程使用坑点：</strong></p> 
<p>hystrx 官方配置解释地址：</p> 
<p>https://github.com/Ne<a href="https://m.hqchip.com/app/1522" rel="nofollow" title="tf">tf</a>lix/Hystrix/wiki/Configuration</p> 
<p>线程池队列配置问题</p> 
<p>常用配置：</p> 
<pre><code>​
#核心线程池大小，默认值为：10 
hystrix.threadpool.default.coreSize=10 

#调用超时时间，默认值为1000ms 
hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=15000 

#最大线程池大小，这是在不开始拒绝的情况下可以支持的最大并发量。默认值为10。 
hystrix.threadpool.default.maximumSize=50 

#队列大小拒绝阈值，默认值为5。即使maxQueueSize未达到也会发生拒绝。在maxQueueSize==-1时不生效。 
hystrix.threadpool.default.queueSizeRejectionThreshold=100 

#maximumSize配置是否生效，默认值为false。maximumSize可以等于或高于coreSize。 
#设置coreSize&lt; maximumSize 创建一个可以维持maximumSize并发性的线程池； 
# 但会在相对不活动期间将线程返回给系统。（受限于keepAliveTimeInMinutes）。 
hystrix.threadpool.default.allowMaximumSizeToDivergeFromCoreSize = true 

# 最大队列大小，默认值为 -1。
# 值为-1时：使用 thenSynchronousQueue；
# 值为正值时：使用 LinkedBlockingQueue。 
hystrix.threadpool.default.maxQueueSize = 50</code></pre> 
<h4><strong>错误配置①：</strong></h4> 
<pre><code>hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=1000
</code></pre> 
<pre>feign使用的是懒加载，第一次调用时，会初始化各种bean，速度很慢，默认1秒很容易超时。</pre> 
<p><strong>错误配置②：</strong></p> 
<pre><code>hystrix.threadpool.default.coreSize=10
hystrix.threadpool.default.maxQueueSize=1000
hystrix.threadpool.default.queueSizeRejectionThreshold=20</code></pre> 
<p>因为 queueSizeRejectionThreshold 太小，实际上在并发达到 30 以上的时候，就会拒绝后面的请求了。</p> 
<p><strong>错误配置③：</strong></p> 
<pre><code>hystrix.threadpool.default.coreSize=10
hystrix.threadpool.default.maxQueueSize=20
hystrix.threadpool.default.queueSizeRejectionThreshold=1000</code></pre> 
<p>因为 maxQueueSize 太小，实际上在并发达到 30 以上的时候，就会拒绝后面的请求了。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a0d4c42027fb686f8fd692458190d42d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">高可用集群keepalived从部署到实战一篇解决</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b1cc9b76a998c5a210f93a833f4f6a8f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">机器学习速成第二集——监督学习之回归（理论部分）！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>