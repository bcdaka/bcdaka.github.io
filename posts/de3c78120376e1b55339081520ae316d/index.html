<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Webpack: 三种Chunk产物的打包逻辑 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/de3c78120376e1b55339081520ae316d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Webpack: 三种Chunk产物的打包逻辑">
  <meta property="og:description" content="概述 在前文 Webpack: Dependency Graph 管理模块间依赖 中，我们已经详细讲解了「构建」阶段如何从 Entry 开始逐步递归读入、解析模块内容，并最终构建出模块依赖关系图 —— ModuleGraph 对象。本文我们继续往下，讲解在接下来的「封装」阶段，如何根据 ModuleGraph 内容组织 Chunk，并进一步构建出 ChunkGroup、ChunkGraph 依赖关系对象的主流程。 主流程之外，我们还会详细讲解几个比较模糊的概念：
Chunk、ChunkGroup、ChunGraph 对象分别是什么？互相之间存在怎样的交互关系？Webpack 默认分包规则，以及规则中存在的问题。 ChunkGraph 构建过程 在 前 Init、Make、Seal》中，我们已经介绍了 Webpack 底层构建逻辑大体上可以划分为：「初始化、构建、封装」三个阶段：
其中，「构建」阶段负责分析模块间的依赖关系，建立起模块之间的 依赖关系图（ModuleGraph）；紧接着，在「封装」阶段根据依赖关系图，将模块分开封装进若干 Chunk 对象中，并将 Chunk 之间的父子依赖关系梳理成 ChunkGraph 与若干 ChunkGroup 对象。
「封装」阶段最重要的目标就是根据「构建」阶段收集到的 ModuleGraph 关系图构建 ChunkGraph 关系图，这个过程的逻辑比较复杂：
我们简单分析一下这里面几个重要步骤的实现逻辑。
第一步非常关键： 调用 seal() 函数后，遍历 entry 配置，为每个入口创建一个空的 Chunk 与 EntryPoint 对象（一种特殊的 ChunkGroup），并初步设置好基本的 ChunkGraph 结构关系，为下一步骤做好准备，关键代码：
class Compilation { seal(callback) { // ... const chunkGraphInit = new Map(); // 遍历入口模块列表 for (const [name, { dependencies, includeDependencies, options }] of this .">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-04T04:15:00+08:00">
    <meta property="article:modified_time" content="2024-07-04T04:15:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Webpack: 三种Chunk产物的打包逻辑</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="_0"></a>概述</h4> 
<ul><li>在前文 <a href="https://active.blog.csdn.net/article/details/140085479" rel="nofollow">Webpack: Dependency Graph 管理模块间依赖</a> 中，我们已经详细讲解了「构建」阶段如何从 Entry 开始逐步递归读入、解析模块内容，并最终构建出模块依赖关系图 —— ModuleGraph 对象。本文我们继续往下，讲解在接下来的「封装」阶段，如何根据 ModuleGraph 内容组织 Chunk，并进一步构建出 ChunkGroup、ChunkGraph 依赖关系对象的主流程。</li></ul> 
<p>主流程之外，我们还会详细讲解几个比较模糊的概念：</p> 
<ul><li>Chunk、ChunkGroup、ChunGraph 对象分别是什么？互相之间存在怎样的交互关系？</li><li>Webpack 默认分包规则，以及规则中存在的问题。</li></ul> 
<h3><a id="ChunkGraph__9"></a>ChunkGraph 构建过程</h3> 
<p>在 前 <a href="https://active.blog.csdn.net/article/details/140083531" rel="nofollow">Init、Make、Seal</a>》中，我们已经介绍了 Webpack 底层构建逻辑大体上可以划分为：「<strong>初始化、构建、封装</strong>」三个阶段：</p> 
<p><img src="https://images2.imgbox.com/d4/eb/jmSna99E_o.png" alt="在这里插入图片描述"></p> 
<p>其中，「<strong>构建</strong>」阶段负责分析模块间的依赖关系，建立起模块之间的 <a href="https://webpack.js.org/concepts/dependency-graph/#root" rel="nofollow">依赖关系图</a>（ModuleGraph）；紧接着，在「<strong>封装</strong>」阶段根据依赖关系图，将模块分开封装进若干 Chunk 对象中，并将 Chunk 之间的父子依赖关系梳理成 ChunkGraph 与若干 ChunkGroup 对象。</p> 
<p>「封装」阶段最重要的目标就是根据「构建」阶段收集到的 ModuleGraph 关系图构建 ChunkGraph 关系图，这个过程的逻辑比较复杂：</p> 
<p><img src="https://images2.imgbox.com/99/15/HWWfrrvL_o.png" alt="请添加图片描述"></p> 
<p>我们简单分析一下这里面几个重要步骤的实现逻辑。</p> 
<p><strong>第一步非常关键：</strong> 调用 <code>seal()</code> 函数后，遍历 <code>entry</code> 配置，为每个入口创建一个空的 <code>Chunk</code> 与 <a href="https://github1s.com/webpack/webpack/blob/HEAD/lib/Entrypoint.js" rel="nofollow">EntryPoint</a> 对象（一种特殊的 <code>ChunkGroup</code>），并初步设置好基本的 <code>ChunkGraph</code> 结构关系，为下一步骤做好准备，关键代码：</p> 
<pre><code class="prism language-js"><span class="token keyword">class</span> <span class="token class-name">Compilation</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">seal</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// ...</span>
    <span class="token keyword">const</span> chunkGraphInit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 遍历入口模块列表</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token punctuation">[</span>name<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span> dependencies<span class="token punctuation">,</span> includeDependencies<span class="token punctuation">,</span> options <span class="token punctuation">}</span><span class="token punctuation">]</span> <span class="token keyword">of</span> <span class="token keyword">this</span>
      <span class="token punctuation">.</span>entries<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 为每一个 entry 创建对应的 Chunk 对象</span>
      <span class="token keyword">const</span> chunk <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addChunk</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 为每一个 entry 创建对应的 ChunkGroup 对象</span>
      <span class="token keyword">const</span> entrypoint <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entrypoint</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 关联 Chunk 与 ChunkGroup</span>
      <span class="token function">connectChunkGroupAndChunk</span><span class="token punctuation">(</span>entrypoint<span class="token punctuation">,</span> chunk<span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token comment">// 遍历 entry Dependency 列表</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> dep <span class="token keyword">of</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>globalEntry<span class="token punctuation">.</span>dependencies<span class="token punctuation">,</span> <span class="token operator">...</span>dependencies<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 为每一个 EntryPoint 关联入口依赖对象，以便下一步从入口依赖开始遍历其它模块</span>
        entrypoint<span class="token punctuation">.</span><span class="token function">addOrigin</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span> name <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">/** @type {any} */</span> <span class="token punctuation">(</span>dep<span class="token punctuation">)</span><span class="token punctuation">.</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">const</span> module <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>moduleGraph<span class="token punctuation">.</span><span class="token function">getModule</span><span class="token punctuation">(</span>dep<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>module<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          <span class="token comment">// 在 ChunkGraph 中记录入口模块与 Chunk 关系</span>
          chunkGraph<span class="token punctuation">.</span><span class="token function">connectChunkAndEntryModule</span><span class="token punctuation">(</span>chunk<span class="token punctuation">,</span> module<span class="token punctuation">,</span> entrypoint<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token comment">// ...</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 调用 buildChunkGraph 方法，开始构建 ChunkGraph</span>
    <span class="token function">buildChunkGraph</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> chunkGraphInit<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 触发各种优化钩子</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>执行完成后，形成如下数据结构：<br> <img src="https://images2.imgbox.com/19/db/0Hfw8Dpq_o.png" alt="在这里插入图片描述"></p> 
<p>其次，若此时配置了 <code>entry.runtime</code>，Webpack 还会在这个阶段为运行时代码 <a href="https://github1s.com/webpack/webpack/blob/HEAD/lib/Compilation.js#L2933-L2934" rel="nofollow">创建</a> 相应的 Chunk 并直接 <a href="https://github1s.com/webpack/webpack/blob/HEAD/lib/Compilation.js#L2937-L2938" rel="nofollow">分配</a> 给 <code>entry</code> 对应的 <code>ChunkGroup</code>对象。一切准备就绪后调用 <a href="https://github1s.com/webpack/webpack/blob/HEAD/lib/buildChunkGraph.js#L1347-L1348" rel="nofollow">buildChunkGraph</a> 函数，进入下一步骤。</p> 
<p><strong>第二步：</strong> 在 <code>buildChunkGraph</code> 函数内 <a href="https://github1s.com/webpack/webpack/blob/HEAD/lib/buildChunkGraph.js#L1367-L1368" rel="nofollow">调用</a> <code>visitModules</code> 函数，遍历 ModuleGraph，将所有 Module 按照依赖关系分配给不同 <code>Chunk</code> 对象；这个过程中若遇到 <a href="https://webpack.js.org/blog/2020-10-10-webpack-5-release/#async-modules" rel="nofollow">异步模块</a>，则为该模块 <a href="https://github1s.com/webpack/webpack/blob/HEAD/lib/buildChunkGraph.js#L740-L742" rel="nofollow">创建</a>新的 <code>ChunkGroup</code> 与 <code>Chunk</code> 对象，最终形成如下数据结构：<br> <img src="https://images2.imgbox.com/95/07/b4RkRD7x_o.png" alt="请添加图片描述"></p> 
<p><strong>第三步：</strong> 在 <code>buildChunkGraph</code> 函数中<a href="https://github1s.com/webpack/webpack/blob/HEAD/lib/buildChunkGraph.js#L1381-L1382" rel="nofollow">调用</a> <code>connectChunkGroups</code> 方法，建立 <code>ChunkGroup</code> 之间、<code>Chunk</code> 之间的依赖关系，生成完整的 <code>ChunkGraph</code> 对象，最终形成如下数据结构：<br> <img src="https://images2.imgbox.com/3c/aa/21pNXpRg_o.png" alt="请添加图片描述"></p> 
<p><strong>第四步：</strong> 在 <code>buildChunkGraph</code> 函数中<a href="https://github1s.com/webpack/webpack/blob/HEAD/lib/buildChunkGraph.js#L1397-L1398" rel="nofollow">调用</a> <code>cleanupUnconnectedGroups</code> 方法，清理无效 <code>ChunkGroup</code>，主要起到性能优化作用。</p> 
<p>自上而下经过这四个步骤后，<code>ModuleGraph</code> 中存储的模块将根据模块本身的性质，被分配到 Entry、Async、Runtime 三种不同的 Chunk 对象，并将 Chunk 之间的依赖关系存储到 ChunkGraph 与 ChunkGroup 集合中，后续可在这些对象基础上继续修改分包策略（例如 <code>SplitChunksPlugin</code>），通过重新组织、分配 Module 与 Chunk 对象的归属实现分包优化。</p> 
<h3><a id="Chunk_vs_ChunkGroup_vs_ChunkGraph_81"></a>Chunk vs ChunkGroup vs ChunkGraph</h3> 
<p>上述构建过程涉及 Chunk、ChunkGroup、ChunkGraph 三种关键对象，我们先总结它们的概念与作用，加深理解：</p> 
<ul><li><code>Chunk</code>：Module 用于读入模块内容，记录模块间依赖等；而 Chunk 则根据模块依赖关系合并多个 Module，输出成资产文件（合并、输出产物的逻辑，我们放到下一章讲解）：</li></ul> 
<p><img src="https://images2.imgbox.com/32/b2/rld5Hn6N_o.png" alt="请添加图片描述"></p> 
<ul><li><code>ChunkGroup</code>：一个 <code>ChunkGroup</code> 内包含一个或多个 <code>Chunk</code> 对象；<code>ChunkGroup</code> 与 <code>ChunkGroup</code> 之间形成父子依赖关系：</li></ul> 
<p><img src="https://images2.imgbox.com/54/5e/VjbEdkZR_o.png" alt="请添加图片描述"></p> 
<ul><li><code>ChunkGraph</code>：最后，Webpack 会将 Chunk 之间、ChunkGroup 之间的依赖关系存储到 <code>compilation.chunkGraph</code> 对象中，形成如下类型关系：<br> <img src="https://images2.imgbox.com/4f/eb/N24k3JAG_o.png" alt="请添加图片描述"></li></ul> 
<h3><a id="_96"></a>默认分包规则</h3> 
<p>综合上述 <code>ChunkGraph</code> 构建流程最终会将 Module 组织成三种不同类型的 Chunk：</p> 
<ul><li>Entry Chunk：同一个 <code>entry</code> 下触达到的模块组织成一个 Chunk；</li><li>Async Chunk：异步模块单独组织为一个 Chunk；</li><li>Runtime Chunk：<code>entry.runtime</code> 不为空时，会将运行时模块单独组织成一个 Chunk。</li></ul> 
<p>这是 Webpack 内置的，在不使用 <code>splitChunks</code> 或其它插件的情况下，模块输入映射到输出的默认规则，是 Webpack 底层关键原理之一，因此有必要展开介绍每一种 Chunk 的具体规则。</p> 
<p><strong>Entry Chunk:</strong></p> 
<p>先从 Entry Chunk 开始，Webpack 首先会为每一个 <code>entry</code> 创建 <code>Chunk</code> 对象，例如对于如下配置：</p> 
<pre><code class="prism language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
  <span class="token literal-property property">entry</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">main</span><span class="token operator">:</span> <span class="token string">"./src/main"</span><span class="token punctuation">,</span>
    <span class="token literal-property property">home</span><span class="token operator">:</span> <span class="token string">"./src/home"</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>遍历 <code>entry</code> 对象属性并创建出 <code>chunk[main]</code> 、<code>chunk[home]</code> 两个对象，此时两个 Chunk 分别包含 <code>main</code> 、<code>home</code> 模块：<br> <img src="https://images2.imgbox.com/67/ed/ji5NxUqZ_o.png" alt="在这里插入图片描述"></p> 
<p>初始化完毕后，Webpack 会根据 <code>ModuleGraph</code> 的依赖关系数据，将 <code>entry</code> 下所触及的所有 Module 塞入 Chunk （发生在 <a href="https://github1s.com/webpack/webpack/blob/HEAD/lib/buildChunkGraph.js#L187-L188" rel="nofollow">visitModules</a> 方法），比如对于如下文件依赖：<br> <img src="https://images2.imgbox.com/e5/58/GTkySbsj_o.png" alt="在这里插入图片描述"></p> 
<p><code>main.js</code> 以同步方式直接或间接引用了 a/b/c/d 四个文件，Webpack 会首先为 <code>main.js</code> 模块创建 Chunk 与 EntryPoint 对象，之后将 a/b/c/d 模块逐步添加到 <code>chunk[main]</code> 中，最终形成：<br> <img src="https://images2.imgbox.com/49/6f/1VUtX0gb_o.png" alt="在这里插入图片描述"></p> 
<p><strong>Async Chunk:</strong></p> 
<p>其次，Webpack 会将每一个异步导入语句（<code>import(xxx)</code> 及 <code>require.ensure</code>）处理为一个单独的 Chunk 对象，并将其子模块都加入这个 Chunk 中 —— 我们称之为 Async Chunk。例如对于下面的例子：</p> 
<pre><code class="prism language-js"><span class="token comment">// index.js</span>
<span class="token keyword">import</span> <span class="token string">'./sync-a.js'</span>
<span class="token keyword">import</span> <span class="token string">'./sync-b.js'</span>

<span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./async-a.js'</span><span class="token punctuation">)</span>

<span class="token comment">// async-a.js</span>
<span class="token keyword">import</span> <span class="token string">'./sync-c.js'</span>
</code></pre> 
<p>在入口模块 <code>index.js</code> 中，以同步方式引入 sync-a、sync-b；以异步方式引入 async-a 模块；同时，在 async-a 中以同步方式引入 <code>sync-c</code> 模块，形成如下模块依赖关系图：<br> <img src="https://images2.imgbox.com/e4/ed/c4AbrdvZ_o.png" alt="请添加图片描述"></p> 
<p>此时，Webpack 会为入口 <code>index.js</code>、异步模块 <code>async-a.js</code> 分别创建分包，形成如下 Chunk 结构：<br> <img src="https://images2.imgbox.com/34/1b/DTZ7zYbC_o.png" alt="在这里插入图片描述"></p> 
<p>并且 <code>chunk[index]</code> 与 <code>chunk[async-a]</code> 之间形成了单向依赖关系，Webpack 会将这种依赖关系保存在 <code>ChunkGroup._parents</code> 、<code>ChunkGroup._children</code> 属性中。</p> 
<p><strong>Runtime Chunk:</strong></p> 
<p>最后，除了 <code>entry</code>、异步模块外，Webpack5 还支持将 Runtime 代码单独抽取为 Chunk。这里说的 Runtime 代码是指一些为了确保打包产物能正常运行，而由 Webpack 注入的一系列基础框架代码，举个例子，常见的 Webpack 打包产物结构如：<br> <img src="https://images2.imgbox.com/17/d6/rvdo4oIu_o.png" alt="请添加图片描述"><br> 上图红框圈出来的一大段代码就是 Webpack 动态生成的运行时代码，编译时，Webpack 会根据业务代码，决定输出哪些支撑特性的运行时代码（基于 <code>Dependency</code> 子类），例如：</p> 
<ul><li>需要 <code>__webpack_require__.f</code>、<code>__webpack_require__.r</code> 等功能实现最起码的模块化支持；</li><li>如果用到动态加载特性，则需要写入 <code>__webpack_require__.e</code> 函数；</li><li>如果用到 Module Federation 特性，则需要写入 <code>__webpack_require__.o</code> 函数；</li><li>等等。</li></ul> 
<p>虽然每段运行时代码可能都很小，但随着特性的增加，最终结果会越来越大，特别对于多 entry 应用，在每个入口都重复打包一份相似的运行时显得有点浪费，为此 Webpack5 提供了 <code>entry.runtime</code> 配置项用于声明如何打包运行时代码。用法上只需在 <code>entry</code> 项中增加字符串形式的 <code>runtime</code> 值，例如：</p> 
<pre><code class="prism language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
  <span class="token literal-property property">entry</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">index</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">import</span><span class="token operator">:</span> <span class="token string">"./src/index"</span><span class="token punctuation">,</span> <span class="token literal-property property">runtime</span><span class="token operator">:</span> <span class="token string">"solid-runtime"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>在 <code>compilation.seal</code> 函数中，Webpack 首先为 <code>entry</code> 创建 <code>EntryPoint</code>，之后判断 <code>entry</code> 配置中是否带有 <code>runtime</code> 属性，有则创建以 <code>runtime</code> 值为名的 Chunk，因此，上例配置将生成两个 Chunk：<code>chunk[index.js]</code> 、<code>chunk[solid-runtime]</code>，并据此最终产出两个文件：</p> 
<ul><li>入口 index 对应的 <code>index.js</code> 文件；</li><li>运行时配置对应的 <code>solid-runtime.js</code> 文件。</li></ul> 
<p>在多 <code>entry</code> 场景中，只要为每个 <code>entry</code> 都设定相同的 <code>runtime</code> 值，Webpack 运行时代码就会合并写入到同一个 Runtime Chunk 中，最终达成产物性能优化效果。例如对于如下配置：</p> 
<pre><code class="prism language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
  <span class="token literal-property property">entry</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">index</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">import</span><span class="token operator">:</span> <span class="token string">"./src/index"</span><span class="token punctuation">,</span> <span class="token literal-property property">runtime</span><span class="token operator">:</span> <span class="token string">"solid-runtime"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">home</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">import</span><span class="token operator">:</span> <span class="token string">"./src/home"</span><span class="token punctuation">,</span> <span class="token literal-property property">runtime</span><span class="token operator">:</span> <span class="token string">"solid-runtime"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>入口 <code>index</code>、<code>home</code> 共享相同的 <code>runtime</code> 值，最终生成三个 Chunk，分别为：<br> <img src="https://images2.imgbox.com/5a/f6/IZTtiikp_o.png" alt="请添加图片描述"></p> 
<p>此时入口 <code>chunk[index]</code>、<code>chunk[home]</code> 与运行时 <code>chunk[solid-runtime]</code> 也会形成父子依赖关系。</p> 
<h3><a id="_197"></a>分包规则的问题</h3> 
<p>默认分包规则最大的问题是无法解决模块重复，如果多个 Chunk 同时包含同一个 Module，那么这个 Module 会被不受限制地重复打包进这些 Chunk。比如假设我们有两个入口 main/index 同时依赖了同一个模块：<br> <img src="https://images2.imgbox.com/0e/3f/aXsJ97L0_o.png" alt="在这里插入图片描述"></p> 
<p>默认情况下，Webpack 不会对此做额外处理，只是单纯地将 c 模块同时打包进 main/index 两个 Chunk，最终形成：</p> 
<p><img src="https://images2.imgbox.com/68/bb/O8GgNDzQ_o.png" alt="在这里插入图片描述"></p> 
<p>可以看到 <code>chunk</code> 间互相孤立，模块 c 被重复打包，对最终产物可能造成不必要的性能损耗！</p> 
<p>为了解决这个问题，Webpack 3 引入 <code>CommonChunkPlugin</code> 插件试图将 entry 之间的公共依赖提取成单独的 <code>chunk</code>，但 <code>CommonChunkPlugin</code> 本质上还是基于 Chunk 之间简单的父子关系链实现的，很难推断出提取出的第三个包应该作为 <code>entry</code> 的父 <code>chunk</code> 还是子 <code>chunk</code>，<code>CommonChunkPlugin</code> 统一处理为父 <code>chunk</code>，某些情况下反而对性能造成了不小的负面影响。</p> 
<p>为此，在 Webpack4 之后才专门引入了更复杂的数据结构 —— <code>ChunkGroup</code> 专门实现关系链管理，配合 <code>SplitChunksPlugin</code> 能够更高效、智能地实现<strong>启发式分包。</strong></p> 
<h3><a id="_214"></a>总结</h3> 
<p>综上，「构建」阶段负责根据模块的引用关系构建 ModuleGraph；「封装」阶段则负责根据 ModuleGraph 构建一系列 Chunk 对象，并将 Chunk 之间的依赖关系（异步引用、Runtime）组织为 ChunkGraph —— Chunk 依赖关系图对象。与 ModuleGraph 类似，ChunkGraph 结构的引入也能解耦 Chunk 之间依赖关系的管理逻辑，整体架构逻辑更合理更容易扩展。</p> 
<p>不过，虽然看着很复杂，但「封装」阶段最重要的目标还是在于：确定有多少个 Chunk，以及每一个 Chunk 中包含哪些 Module —— 这些才是真正影响最终打包结果的关键因素。</p> 
<p>针对这一点，我们需要理解 Webpack5 内置的三种分包规则：Entry Chunk、Async Chunk 与 Runtime Chunk，这些是最最原始的分包逻辑，其它插件（例如 <a href="https://webpack.js.org/plugins/split-chunks-plugin/" rel="nofollow">splitChunksPlugin</a>）都是在此基础，借助 <code>buildChunkGraph</code> 后触发的各种钩子进一步拆分、合并、优化 Chunk 结构，实现扩展分包效果。</p> 
<p>思考 <code>Chunk</code> 一定会且只会生产出一个产物文件吗？为什么？<code>mini-css-extract-plugin</code>、<code>file-loader</code> 这一类能写出额外文件的组件，底层是怎么实现的？</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a6745531f83ca1e91f9c4d4e03f9ddb1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">20240704 每日AI必读资讯</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7058e99826bd6f3a985c34b8884f094b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C&#43;&#43;】类和对象（中）--上篇</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>