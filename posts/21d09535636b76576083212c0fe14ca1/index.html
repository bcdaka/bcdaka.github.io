<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>窗口函数-详细讲解分析 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/21d09535636b76576083212c0fe14ca1/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="窗口函数-详细讲解分析">
  <meta property="og:description" content="目录
窗口函数
1.窗口函数概述
2.窗口函数的语法
1.窗口函数语法解释-Function(arg1,..., argn)
1.聚合函数
2.排序函数
3.跨行函数
2.窗口函数语法解释-OVER [PARTITION BY &lt;...&gt;] 3.窗口函数语法解释- [ORDER BY &lt;....&gt;] 4.窗口函数语法解释-[window_expression]
窗口函数练习
建库建表语句：
题目：
答案：
窗口函数 1.窗口函数概述 窗口函数是一种SQL函数，非常适合于数据分析，其最大的特点就是：输入值是从SELECT语句的结果集中的一行或者多行的&#34;窗口&#34;中获取的，也可以理解为窗口有大有小（行数有多有少）。
通过OVER子句，窗口函数与其他的SQL函数有所区别，如果函数具有OVER子句，则它是窗口函数。如果它缺少了OVER子句，则他就是个普通的聚合函数。
窗口函数可以简单地解释为类似于聚合函数的计算函数，但是通过GROUP BY子句组合的常规聚合会隐去正在聚合的各个行，最终输出称为一行。但是窗口函数聚合完之后还可以访问当前行的其他数据，并且可以将这些行的某些属性添加到结果当中去。
下面可以通过两个图来区分普通的聚合函数和窗口函数
为了更加直观的反映窗口函数和普通聚合函数的区别，让我们通过代码的形式感受一下 首先让我们先添加测试数据，并查看表。
CREATE DATABASE IF NOT EXISTS EmployeeDB; USE EmployeeDB; CREATE TABLE Employees ( EmployeeID INT AUTO_INCREMENT PRIMARY KEY, Name VARCHAR(100), DepartmentID INT, Salary DECIMAL(10, 2) ); INSERT INTO Employees (Name, DepartmentID, Salary) VALUES (&#39;Alice&#39;, 1, 50000), (&#39;Bob&#39;, 1, 55000), (&#39;Charlie&#39;, 2, 60000), (&#39;David&#39;, 1, 50000), (&#39;Eve&#39;, 2, 65000), (&#39;Frank&#39;, 3, 45000), (&#39;Grace&#39;, 3, 47000), (&#39;Hannah&#39;, 3, 48000), (&#39;Ian&#39;, 2, 70000), (&#39;Jack&#39;, 1, 52000); -------------------------------------sum&#43;group by常规的聚合函数操作--------------------------------------">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-30T22:55:11+08:00">
    <meta property="article:modified_time" content="2024-07-30T22:55:11+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">窗口函数-详细讲解分析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E7%9A%84%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px;"><a href="#%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E7%9A%84%E6%A6%82%E8%BF%B0" rel="nofollow">窗口函数</a></p> 
<p id="1.%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E6%A6%82%E8%BF%B0-toc" style="margin-left:40px;"><a href="#1.%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E6%A6%82%E8%BF%B0" rel="nofollow">1.窗口函数概述</a></p> 
<p id="%C2%A02.%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95-toc" style="margin-left:40px;"><a href="#%C2%A02.%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95" rel="nofollow">2.窗口函数的语法</a></p> 
<p id="1.%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A-Function(arg1%2C...%2C%20argn)-toc" style="margin-left:80px;"><a href="#1.%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A-Function%28arg1%2C...%2C%20argn%29" rel="nofollow">1.窗口函数语法解释-Function(arg1,..., argn)</a></p> 
<p id="%C2%A01.%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0-toc" style="margin-left:120px;"><a href="#%C2%A01.%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0" rel="nofollow">1.聚合函数</a></p> 
<p id="2.%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0-toc" style="margin-left:120px;"><a href="#2.%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0" rel="nofollow">2.排序函数</a></p> 
<p id="3.%E8%B7%A8%E8%A1%8C%E5%87%BD%E6%95%B0-toc" style="margin-left:120px;"><a href="#3.%E8%B7%A8%E8%A1%8C%E5%87%BD%E6%95%B0" rel="nofollow">3.跨行函数</a></p> 
<p id="%C2%A02.%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A-OVER%20%5BPARTITION%20BY%20%3C...%3E%5D%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A02.%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A-OVER%20%5BPARTITION%20BY%20%3C...%3E%5D%C2%A0" rel="nofollow">2.窗口函数语法解释-OVER [PARTITION BY &lt;...&gt;] </a></p> 
<p id="3.%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A-%C2%A0%5BORDER%20BY%20%3C....%3E%5D%C2%A0-toc" style="margin-left:80px;"><a href="#3.%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A-%C2%A0%5BORDER%20BY%20%3C....%3E%5D%C2%A0" rel="nofollow">3.窗口函数语法解释- [ORDER BY &lt;....&gt;] </a></p> 
<p id="4.%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A%5B%3Cwindow_expression%3E%5D-toc" style="margin-left:80px;"><a href="#4.%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A%5B%3Cwindow_expression%3E%5D" rel="nofollow">4.窗口函数语法解释-[window_expression]</a></p> 
<p id="%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E7%BB%83%E4%B9%A0-toc" style="margin-left:0px;"><a href="#%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E7%BB%83%E4%B9%A0" rel="nofollow">窗口函数练习</a></p> 
<p id="%E5%BB%BA%E5%BA%93%E5%BB%BA%E8%A1%A8%E8%AF%AD%E5%8F%A5%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E5%BB%BA%E5%BA%93%E5%BB%BA%E8%A1%A8%E8%AF%AD%E5%8F%A5%EF%BC%9A" rel="nofollow">建库建表语句：</a></p> 
<p id="%E9%A2%98%E7%9B%AE%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E9%A2%98%E7%9B%AE%EF%BC%9A" rel="nofollow">题目：</a></p> 
<p id="%C2%A0%E7%AD%94%E6%A1%88%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A0%E7%AD%94%E6%A1%88%EF%BC%9A" rel="nofollow">答案：</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E7%9A%84%E6%A6%82%E8%BF%B0" style="background-color:transparent;">窗口函数</h2> 
<h3 id="1.%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E6%A6%82%E8%BF%B0">1.窗口函数概述</h3> 
<p><span style="color:#fe2c24;">        窗口函数</span>是一种SQL函数，非常适合于数据分析，其最大的特点就是：输入值是从SELECT语句的结果集中的一行或者多行的"窗口"中获取的，也可以理解为窗口有大有小（行数有多有少）。</p> 
<p>        通过OVER子句，窗口函数与其他的SQL函数有所区别，<span style="background-color:#ffd900;">如果函数具有OVER子句，则它是窗口函数。如果它缺少了OVER子句，则他就是个普通的聚合函数。</span></p> 
<p>        窗口函数可以简单地解释为类似于聚合函数的计算函数，但是通过GROUP BY子句组合的常规聚合会隐去正在聚合的各个行，最终输出称为一行。但是窗口函数聚合完之后还可以访问当前行的其他数据，并且可以将这些行的某些属性添加到结果当中去。</p> 
<blockquote> 
 <p>下面可以通过两个图来区分普通的聚合函数和窗口函数</p> 
</blockquote> 
<p> <img alt="" height="113" src="https://images2.imgbox.com/42/e0/DV9rXMa7_o.png" width="326"><img alt="" height="113" src="https://images2.imgbox.com/71/4d/qbKXghQB_o.png" width="314"></p> 
<blockquote> 
 <p>为了更加直观的反映窗口函数和普通聚合函数的区别，让我们通过代码的形式感受一下 </p> 
</blockquote> 
<p> 首先让我们先添加测试数据，并查看表。</p> 
<pre><code class="language-sql">CREATE DATABASE IF NOT EXISTS EmployeeDB;
USE EmployeeDB;
CREATE TABLE Employees (
    EmployeeID INT AUTO_INCREMENT PRIMARY KEY,
    Name VARCHAR(100),
    DepartmentID INT,
    Salary DECIMAL(10, 2)
);

INSERT INTO Employees (Name, DepartmentID, Salary) VALUES
('Alice', 1, 50000),
('Bob', 1, 55000),
('Charlie', 2, 60000),
('David', 1, 50000),
('Eve', 2, 65000),
('Frank', 3, 45000),
('Grace', 3, 47000),
('Hannah', 3, 48000),
('Ian', 2, 70000),
('Jack', 1, 52000);</code></pre> 
<p><img alt="" height="325" src="https://images2.imgbox.com/49/50/HEY2Hs9H_o.png" width="924"></p> 
<blockquote> 
 <p>-------------------------------------sum+group by常规的聚合函数操作--------------------------------------</p> 
</blockquote> 
<pre><code class="language-sql">select DepartmentID, sum(salary) as total
from employees
group by DepartmentID;</code></pre> 
<p><img alt="" height="134" src="https://images2.imgbox.com/42/51/b7egRU0Y_o.png" width="1041"></p> 
<p>我们可以看的出来，常规聚合函数把id进行分组然后把每组的薪资综合计算出来放在最后面。</p> 
<blockquote> 
 <p>--------------------------------------------sum+窗口函数的聚合操作-------------------------------------------</p> 
</blockquote> 
<pre><code class="language-sql">select *, 
       sum(Salary) over (partition by DepartmentID) total
from employees</code></pre> 
<p><img alt="" height="365" src="https://images2.imgbox.com/b3/63/wcg9BUxp_o.png" width="1165"></p> 
<p> 我们可以通过这两个例子看出来，聚合函数和窗口聚合函数的区别。就是窗口函数会进行分组，但不会把行进行合并。对于每一组窗口函数返回出来的结果都会重复的放在最后面。</p> 
<h3 id="%C2%A02.%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95" style="background-color:transparent;"> 2.窗口函数的语法</h3> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>Function(arg1,..., argn) OVER ([PARTITION BY &lt;...&gt;] [ORDER BY &lt;....&gt;] [&lt;window_expression&gt;])</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;">对于以上的窗口函数的语法[   ]中的语法是可以根据自己的需求进行选择（非必须写入语法），并且此语法严格按照上面的顺序来规定。</p> 
 <p style="margin-left:.0001pt;text-align:justify;"></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>Function(arg1,..., argn)是表示函数的分类，可以是下面分类中的任何一组。</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;">----------聚合函数，例如sum,min,avg,count等函数（常用）</p> 
 <p style="margin-left:.0001pt;text-align:justify;">----------排序函数，例如rank row_number  dense_rank()等函数（常用）</p> 
 <p style="margin-left:.0001pt;text-align:justify;">----------跨行函数，lag  lead 函数</p> 
 <p style="margin-left:.0001pt;text-align:justify;"></p> 
 <p style="margin-left:.0001pt;text-align:justify;"></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>OVER [PARTITION BY &lt;...&gt;] 类似于group by 用于指定分组</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;">--每个分组你可以把它叫做窗口</p> 
 <p style="margin-left:.0001pt;text-align:justify;">--不分组的情况可以写成partition by null 或者直接不写partition by，所有列为一个大组</p> 
 <p style="margin-left:.0001pt;text-align:justify;">--分组的情况下，partition by 后面可以跟多个列，例如partition by cid,cname</p> 
 <p style="margin-left:.0001pt;text-align:justify;"></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>[ORDER BY &lt;....&gt;]  用于指定每个分组内的数据排序规则 支持ASC、DESC</strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong>[&lt;window_expression&gt;] 用于指定每个窗口中 操作的数据范围 默认是窗口中所有行</strong></p> 
</blockquote> 
<h4 id="1.%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A-Function(arg1%2C...%2C%20argn)" style="background-color:transparent;margin-left:.0001pt;text-align:justify;">1.窗口函数语法解释-<strong>Function(arg1,..., argn)</strong></h4> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;">通常和partition by分组使用。当然也可以不分组使用，但也不分组使用通常没有意义。</p> 
 <p style="margin-left:.0001pt;text-align:justify;">----------聚合函数，例如sum,min,avg,count等函数（常用）</p> 
 <p style="margin-left:.0001pt;text-align:justify;">----------排序函数，例如rank row_number  dense_rank()等函数（常用）</p> 
 <p style="margin-left:.0001pt;text-align:justify;">----------跨行函数，lag  lead 函数</p> 
</blockquote> 
<h5 id="%C2%A01.%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0" style="background-color:transparent;"> 1.聚合函数</h5> 
<p>我们还通过上文的测试数据进行演示。我们就演示2个函数，其他的聚合类函数都是相同的用法。</p> 
<blockquote> 
 <p><strong>sum函数：求和</strong></p> 
</blockquote> 
<pre><code class="language-sql">select *,
       sum(Salary) over (partition by DepartmentID) total
from employees</code></pre> 
<p><img alt="" height="331" src="https://images2.imgbox.com/62/1c/gv3fgsv2_o.png" width="1118"></p> 
<blockquote> 
 <p><strong>min函数 ：最小值</strong></p> 
</blockquote> 
<pre><code class="language-sql">select *,
       min(Salary) over (partition by DepartmentID) total
from employees;</code></pre> 
<p><img alt="" height="339" src="https://images2.imgbox.com/b2/e0/kpOARUm0_o.png" width="1121"></p> 
<p>其他的聚合函数都是同样的用法。</p> 
<h5 id="2.%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0" style="background-color:transparent;">2.排序函数</h5> 
<blockquote> 
 <p>rank   row_number   dense_rank()等函数，通常与order by函数一起使用。</p> 
 <p></p> 
 <p><strong>row_number()函数：对分组之后按照某些规则从高到低或者从低到高进行排序(order by),然后打上序号,<span style="color:#fe2c24;">不考虑并列的情况。</span></strong></p> 
 <p></p> 
 <pre><code class="language-sql">select *,
       row_number() over (partition by DepartmentID order by Salary desc ) total
from employees;</code></pre> 
 <p><img alt="" height="328" src="https://images2.imgbox.com/79/05/FPJctDKQ_o.png" width="1126"></p> 
 <p><strong>rank()函数：对分组之后按照某些规则从高到低或者从低到高进行排序(order by),然后打上序号，<span style="color:#fe2c24;">考虑并列情况并且跳跃排名，对此我们需要增添一组数据。</span></strong></p> 
 <pre><code class="language-sql">INSERT INTO Employees (Name, DepartmentID, Salary) VALUES('css',1,45000);</code></pre> 
 <pre><code class="language-sql">select *,
       rank() over (partition by DepartmentID order by Salary desc ) total
from employees;</code></pre> 
 <p><img alt="" height="356" src="https://images2.imgbox.com/b6/96/diwRmz1V_o.png" width="1103"></p> 
 <p><strong>dense_rank()函数：</strong></p> 
 <pre><code class="language-sql">select *,
       dense_rank() over (partition by DepartmentID order by Salary desc ) total
from employees;</code></pre> 
 <p><img alt="" height="359" src="https://images2.imgbox.com/35/8f/GZ1yU0Is_o.png" width="1132"></p> 
</blockquote> 
<h5 id="3.%E8%B7%A8%E8%A1%8C%E5%87%BD%E6%95%B0" style="background-color:transparent;">3.跨行函数</h5> 
<blockquote> 
 <p style="text-align:left;"><span style="color:#fe2c24;"><strong>LAG(col,n,DEFAULT) 用于统计窗口内往上第n行值</strong></span></p> 
 <p style="text-align:left;">第一个参数为列名，第二个参数为往上第n行（可选，默认为1），第三个参数为默认值（当往上第n行为NULL时候，取默认值，如不指定，则为NULL）；</p> 
 <pre><code class="language-sql">select *,
       lag(Salary,1) over (partition by DepartmentID order by Salary desc ) total
from employees;</code></pre> 
 <p style="text-align:left;"><img alt="" height="440" src="https://images2.imgbox.com/06/e6/zET8qbk8_o.png" width="1190"></p> 
 <p style="text-align:left;"><span style="color:#fe2c24;"><strong>LEAD(col,n,DEFAULT) 用于统计窗口内往下第n行值</strong></span></p> 
 <p style="text-align:left;">第一个参数为列名，第二个参数为往下第n行（可选，默认为1），第三个参数为默认值（当往下第n行为NULL时候，取默认值，如不指定，则为NULL）；</p> 
 <pre><code class="language-sql">select *,
       lead(Salary,1) over (partition by DepartmentID order by Salary desc ) total
from employees;</code></pre> 
 <p style="text-align:left;"><img alt="" height="442" src="https://images2.imgbox.com/6e/9f/KurZm4X4_o.png" width="1200"></p> 
 <p style="text-align:left;"><span style="color:#fe2c24;"><strong>FIRST_VALUE 取分组内排序后，截止到当前行，第一个值；</strong></span></p> 
 <pre><code class="language-sql">select *,
       first_value(Salary) over (partition by DepartmentID order by Salary desc ) total
from employees;</code></pre> 
 <p style="text-align:left;"><img alt="" height="443" src="https://images2.imgbox.com/78/32/SHrDurhx_o.png" width="1117"></p> 
 <p style="text-align:left;"><span style="color:#fe2c24;"><strong>LAST_VALUE 取分组内排序后，截止到当前行，最后一个值；</strong></span></p> 
 <pre><code class="language-sql">select *,
      last_value(Salary) over (partition by DepartmentID order by Salary desc  ) total
from employees;</code></pre> 
 <p><img alt="" height="460" src="https://images2.imgbox.com/0a/2f/5FxNjke1_o.png" width="1197"></p> 
 <p><strong>从这个数据我们有个疑问，为啥不是去分组内的最后一个值呢？</strong></p> 
 <p>在这里我给大家解释一下，对于我们分的窗口（比如部门id=1）里面还有个小窗口row函数</p> 
 <p>对于我们没有指定小窗口默认是当之前所有行到当前行，这样理解可以很抽象，我们举个例子。对于部门id=1来说，我们从第一行来看（心里默念从之前所有行到当前行）从之前所有行到当前行来看确实输出的值应该是55000.00，那么我们看第二行（心里默念从之前所有行到当前行）那么确实输出的是52000.00。这样我们通过row函数来改变一下小窗口的范围。更清晰的感受一下这个函数。</p> 
 <pre><code class="language-sql">select *,
      last_value(Salary) over (partition by DepartmentID order by Salary desc
          rows between unbounded preceding and unbounded following ) total
from employees;</code></pre> 
 <p>解释一下设置小窗口的含义：rows between unbounded preceding and unbounded following</p> 
 <p>之前所有的行到之后所有的行，那么让我们输出一下。</p> 
 <p><img alt="" height="374" src="https://images2.imgbox.com/c6/62/UWndptVh_o.png" width="1141"></p> 
 <p>我们可以很清晰的看出来，输出的是每一组里面最后一个的薪资。</p> 
</blockquote> 
<h4 id="%C2%A02.%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A-OVER%20%5BPARTITION%20BY%20%3C...%3E%5D%C2%A0" style="background-color:transparent;"> 2.窗口函数语法解释-<strong>OVER [PARTITION BY &lt;...&gt;] </strong></h4> 
<p>over是窗口函数的标志，partition by 用来指定分组，把partition by 后面跟的字段相同的放在一起</p> 
<p><img alt="" height="410" src="https://images2.imgbox.com/a4/1f/OFjLdPnU_o.png" width="1199"></p> 
<h4 id="3.%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A-%C2%A0%5BORDER%20BY%20%3C....%3E%5D%C2%A0" style="background-color:transparent;">3.窗口函数语法解释- <strong>[ORDER BY &lt;....&gt;] </strong></h4> 
<p><em><em>用于指定每个分组内的数据排序规则 支持</em></em><em><em>ASC</em></em><em><em>、</em></em><em><em>DESC， 跟group by 中的order by是一样的用法</em></em></p> 
<h4 id="4.%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A%5B%3Cwindow_expression%3E%5D" style="background-color:transparent;"><strong>4.</strong><strong>窗口函数语法解释-</strong><strong>[window_expression] </strong></h4> 
<p>用于指定每个窗口中 操作的数据范围 默认是窗口中所有行</p> 
<blockquote> 
 <p><strong>窗口子句操作的数据范围：</strong><br><strong>1)起始行:N preceding/unbounded preceding<br> 2)当前行:currentrow<br> 3)终止行:N following/unbounded following</strong><br> 举例:<br><span style="color:#fe2c24;"><strong>rows between unbounded preceding and current row 从之前所有的行到当前行</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>rows between 2 preceding and current row 从前面两行到当前行</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>rows between current row and unbounded following 从当前行到之后所有的行</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>rows between current row and 1following 从当前行到后面一行</strong></span></p> 
 <p>注意:<br> 排序子句后面缺少窗口子句，窗口规范默认是rows between unbounded preceding and current row</p> 
 <p>排序子句和窗口子句都缺失，窗口规范默认是 rows between unbounded preceding and unbounded following</p> 
 <p>总体流程<br> 1)通过partition by和 order by 子句确定大窗口(定义出上界unbounded preceding和下界unbounded following)</p> 
 <p>2)通过row 子句针对每一行数据确定小窗口(滑动窗口)<br> 3)对每行的小窗口内的数据执行函数并生成新的列</p> 
</blockquote> 
<h2 id="%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E7%BB%83%E4%B9%A0">窗口函数练习</h2> 
<h3 id="%E5%BB%BA%E5%BA%93%E5%BB%BA%E8%A1%A8%E8%AF%AD%E5%8F%A5%EF%BC%9A">建库建表语句：</h3> 
<pre><code class="language-sql">CREATE DATABASE IF NOT EXISTS sales_db;
USE sales_db;

CREATE TABLE IF NOT EXISTS sales (
    id INT AUTO_INCREMENT PRIMARY KEY,
    product_id INT comment '商品id',
    sale_date DATE comment '销售日期',
    amount DECIMAL(10, 2)comment '销售额',
    region VARCHAR(50) comment '地区'
)comment '销售';

-- 插入一些示例数据
INSERT INTO sales (product_id, sale_date, amount, region) VALUES
(1, '2023-01-01', 100.00, 'East'),
(2, '2023-01-01', 150.00, 'West'),
(1, '2023-01-02', 200.00, 'East'),
(3, '2023-01-02', 120.00, 'South'),
(2, '2023-01-03', 180.00, 'West'),
(1, '2023-01-03', 220.00, 'East'),
(3, '2023-01-04', 140.00, 'South'),
(4, '2023-01-04', 300.00, 'North'),
(2, '2023-01-05', 250.00, 'West'),
(1, '2023-01-05', 280.00, 'East');
insert into sales(product_id, sale_date, amount, region) values
(1,'2023-01-01',200.00,'East');</code></pre> 
<h3 id="%E9%A2%98%E7%9B%AE%EF%BC%9A">题目：</h3> 
<blockquote> 
 <pre>1.计算每日销售额总和（分区按日期）
2.计算每个区域的总销售额
3.为每个产品计算其销售排名（按销售额降序）
4.计算每个区域每天的平均销售额
5.计算每个产品的销售累计总额
6.计算每个区域每个产品的销售总额
7.计算每个区域最近7天的平均销售额
8.为每个产品的销售记录添加序列号（按日期排序）
9.计算每个区域每天相对于前一天的销售额变化
10.计算每个产品的销售占比（销售额/总销售额）
</pre> 
 <p>自己可以先把这些最基础的窗口函数做完之后，再看下面的解析</p> 
</blockquote> 
<h3 id="%C2%A0%E7%AD%94%E6%A1%88%EF%BC%9A"> 答案：</h3> 
<pre><code class="language-sql"># 计算每日销售额总和（分区按日期）
SELECT *,sale_date, SUM(amount) OVER (PARTITION BY sale_date order by sale_date) AS total_daily_sales
FROM sales;
# 计算每个区域的总销售额
SELECT region, SUM(amount) OVER (PARTITION BY region) AS total_regional_sales
FROM sales;
# 为每个产品计算其销售排名（按销售额降序）
select product_id,rank() over (order by sum(amount) desc )as '销售排名' from sales group by product_id ;
# 计算每个区域每天的平均销售额
select *,avg(amount)over (partition by region,sale_date rows between unbounded preceding and unbounded following) from sales;
# 计算每个产品的销售累计总额
select *,sum(amount)over (partition by product_id) from sales;
# 计算每个区域每个产品的销售总额
select *,sum(amount)over (partition by product_id,region)from sales;
# 计算每个区域最近7天的平均销售额
with t1 as ( select *,dense_rank() over(partition by region order by sale_date)as ttime from sales )
select *,avg(amount)over(partition by region) from t1 where ttime&lt;7;
;
# 为每个产品的销售记录添加序列号（按日期排序）
select *,dense_rank() over (partition by product_id order by sale_date)from sales;
# 计算每个区域每天相对于前一天的销售额变化
SELECT
    a.sale_date,
    a.region,
    a.amount,
    a.amount - LAG(a.amount) OVER (PARTITION BY a.region ORDER BY a.sale_date) AS daily_change
FROM sales a;
# 计算每个产品的销售占比（按总销售额
select *,sales.amount/sum(amount)over (partition by product_id)from sales;</code></pre> 
<blockquote> 
 <p>窗口函数很重要，希望大家可以好好琢磨琢磨，也希望发布的文章可以帮到大家。</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6ba490cada33463fd3b51a4f988c6a44/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C# &amp; Unity 面向对象补全计划 之 继承（字段与属性）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cde9658693e275761d1728d0c6cf777a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">golang JSON序列化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>