<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【排序算法（二）】——冒泡排序、快速排序和归并排序—＞深层解析 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/69d09b1a88f6b94541773e9fff62b6a4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【排序算法（二）】——冒泡排序、快速排序和归并排序—＞深层解析">
  <meta property="og:description" content="前言： 接上篇，排序算法除了选择排序（希尔排序）和插入排序（堆排序）之外，还用交换排序（冒泡排序、快速排序）和归并排序已经非比较排序，本篇来深层解析这些排序算法
一、交换排序 1.1、冒泡排序 冒泡排序，这个再熟悉不过了，学校中老师讲的第一个排序就是冒泡排序；直接看代码
代码如下：
//冒泡排序 void BubbleSort(int* arr, int n) { int exchange = 0; for (int i = 0; i &lt; n; i&#43;&#43;) { for (int j = 0; j &lt; n - i - 1; j&#43;&#43;) { if (arr[j] &gt; arr[j &#43; 1]) { exchange = 1; Swap(&amp;arr[j], &amp;arr[j &#43; 1]); } } if (exchange == 0) { break; } } } 时间复杂度：O(n^2)；空间复杂度O(1)。
1.2、快速排序 快速排序，是hoare于1962年提出的一种二叉树结构的交换排序算法，其基本思想为：任意取待排序元素序列中的某元素作为基准值，按照该排序码将待排序集合分割成两个子序列，左子序列中所有元素均小于基准值，右子序列所有元素均大于基准值然后左右子序列重复此过程，直到所有元素都排列在相应位置上。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-30T20:48:34+08:00">
    <meta property="article:modified_time" content="2024-07-30T20:48:34+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【排序算法（二）】——冒泡排序、快速排序和归并排序—＞深层解析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="background-color:transparent;"><span style="color:#4da8ee;"><strong>前言：</strong></span></h2> 
<blockquote> 
 <p>        <strong><span style="color:#0d0016;"><span style="background-color:#38d8f0;">接上篇，排序算法除了选择排序（希尔排序）和插入排序（堆排序）之外，还用交换排序（冒泡排序、快速排序）和归并排序已经非比较排序，本篇来深层解析这些排序算法</span></span></strong></p> 
</blockquote> 
<p></p> 
<h2 style="background-color:transparent;">一、交换排序</h2> 
<h3>        1.1、冒泡排序</h3> 
<p>        冒泡排序，这个再熟悉不过了，学校中老师讲的第一个排序就是冒泡排序；直接看代码</p> 
<p><span style="color:#0d0016;"><strong>代码如下：</strong></span></p> 
<pre><code class="language-cpp">//冒泡排序
void BubbleSort(int* arr, int n)
{
	int exchange = 0;
	for (int i = 0; i &lt; n; i++)
	{
		for (int j = 0; j &lt; n - i - 1; j++)
		{
			if (arr[j] &gt; arr[j + 1])
			{
				exchange = 1;
				Swap(&amp;arr[j], &amp;arr[j + 1]);
			}
		}
		if (exchange == 0)
		{
			break;
		}
	}
}</code></pre> 
<p>        时间复杂度：O(n^2)；空间复杂度O(1)。</p> 
<h3 style="background-color:transparent;">        1.2、快速排序</h3> 
<blockquote> 
 <p>      <strong>  快速排序，是hoare于1962年提出的一种二叉树结构的交换排序算法，其基本思想为：任意取待排序元素序列中的某元素作为基准值，按照该排序码将待排序集合分割成两个子序列，左子序列中所有元素均小于基准值，右子序列所有元素均大于基准值然后左右子序列重复此过程，直到所有元素都排列在相应位置上。</strong></p> 
</blockquote> 
<p><strong>实现快速排序主要框架如下：</strong></p> 
<pre><code class="language-cpp">//快速排序
void QuickSort(int* a, int left, int right)
{
	if (left &gt;= right) {
		return;
	}
	//_QuickSort⽤于按照基准值将区间[left,right)中的元素进⾏划分
	int meet = _QuickSort(a, left, right);
	QuickSort(a, left, meet - 1);
	QuickSort(a, meet + 1, right);
}</code></pre> 
<p>下面的不同方法指的是找基准值的方法不同而已。</p> 
<h4 style="background-color:transparent;">1.2.1、hoare版本</h4> 
<p>思路：</p> 
<blockquote> 
 <p><span style="color:#4da8ee;"><strong>        1.  创建左右指针，却基准值</strong></span></p> 
 <p><span style="color:#4da8ee;"><strong>        2.  从左到右找出比基准值大的数据，从右到左找出比基准值小的数据，左右指针数据交换，进入下一次循环</strong></span></p> 
</blockquote> 
<p><span style="color:#4da8ee;"><strong>这里可能有一些问题，</strong></span></p> 
<p><strong>        </strong><strong>1.跳出循环后，right位置的值一定不大于key？</strong></p> 
<p>        当left &gt; right时，即right走到了left的左侧，而left走过的位置值都不大于key，因此right此时指向的数据一定不大于key</p> 
<p><strong>        </strong><strong>2.为什么left或者right指定的数据与key值相等也要交换？</strong></p> 
<p><strong>        </strong>这里如果，数组中大量的数据都相等，不进行交换的话，就无法进行有效的分割数组。</p> 
<p><span style="color:#0d0016;"><strong>代码实现：</strong></span></p> 
<pre><code class="language-cpp">//快速排序
int _QuickSort1(int* arr, int left, int right)
{
	int key = arr[left];
	int mid = left;
	left++;
	while (left &lt;= right)
	{
		//左边找大
		while (left&lt;=right &amp;&amp; arr[left] &lt; key)
		{
			left++;
		}
		//右边找小
		while (left &lt;= right &amp;&amp; arr[right] &gt; key)
		{
			right--;
		}
		if (left &lt;= right)
		{
			Swap(&amp;arr[left], &amp;arr[right]);
			left++;
			right--;
		}
	}
	Swap(&amp;arr[mid], &amp;arr[right]);
	return right;
}</code></pre> 
<h4 style="background-color:transparent;">1.2.2、挖坑法</h4> 
<p><strong><span style="color:#4da8ee;">思路：</span></strong></p> 
<blockquote> 
 <p>        <strong>创建左右指针；首先从右向左找出比基准值小的数据，找到后立即放入左边 "坑" 中，当前位置变为新的 "坑"，然后从左往右找出比基准值大的数据，找到后立即放入右边坑中，当前位置变为新的 "坑"，结束循环后将最开始存储的分界值放入当前的 "坑"中，返回当前"坑"下标。</strong></p> 
</blockquote> 
<p><img alt="" height="430" src="https://images2.imgbox.com/bc/43/6UrRCXJO_o.png" width="889"></p> 
<p><span style="color:#0d0016;"><strong>代码实现如下：</strong></span></p> 
<pre><code class="language-cpp">int _QuickSort2(int* arr, int left, int right)
{
	int tmp = arr[left];
	int hole = left;
	left++;
	while (left &lt; right)
	{
		//从右边开始找
		while (left &lt; right &amp;&amp; arr[right] &gt; tmp)
		{
			right--;
		}
		arr[hole] = arr[right];
		hole = right;
		while (left &lt; right &amp;&amp; arr[left] &lt; tmp)
		{
			left++;
		}
		arr[hole] = arr[left];
		hole = left;
	}
	arr[hole] = tmp;
	return hole;
}</code></pre> 
<h4 style="background-color:transparent;">1.2.3、lomuto指针法</h4> 
<p><span style="color:#4da8ee;"><strong>思路：</strong></span></p> 
<blockquote> 
 <p><strong>        创建前后指针，从左往右找比基准值小的进行交换，使得小的都排在基准值的左边。</strong></p> 
</blockquote> 
<p class="img-center"><img alt="" height="399" src="https://images2.imgbox.com/a0/dc/Je6mtRky_o.png" width="746"></p> 
<p><strong><span style="color:#0d0016;">代码实现：</span></strong></p> 
<pre><code class="language-cpp">int _QuickSort(int* arr, int left, int right)
{
	int prev = left, pcur = left + 1;
	int key = left;
	while (pcur &lt;= right)
	{
		if (arr[pcur] &lt; arr[key] &amp;&amp; ++prev != pcur)
		{
			Swap(&amp;arr[prev], &amp;arr[pcur]);
		}
		pcur++;
	}
	Swap(&amp;arr[key], &amp;arr[prev]);
	return prev;
}</code></pre> 
<h2 style="background-color:transparent;">二、归并排序</h2> 
<p><span style="color:#4da8ee;"><strong>思路：</strong></span></p> 
<blockquote> 
 <p>        <strong>归并排序，是建立在归并操作上的一种有效的排序算法，该算法是采用分治法的一个典型的应用。将已有序的子序列合并，得到完全有序的序列；即先让每一个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路合并。</strong></p> 
</blockquote> 
<p><img alt="" height="544" src="https://images2.imgbox.com/62/ee/vANLWQc1_o.png" width="999"></p> 
<p><span style="color:#0d0016;"><strong>代码实现：</strong></span></p> 
<pre><code class="language-cpp">//归并排序
void _MergeSort(int* arr, int left, int right,int* tmp)
{
	if (left &gt;= right)
	{
		return;
	}

	int mid = (left + right) / 2;
	_MergeSort(arr, left, mid, tmp);
	_MergeSort(arr, mid+1, right, tmp);


	//合并数组
	int begin1 = left, end1 = mid;
	int begin2 = mid + 1, end2 = right;
	int index = left;
	while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)
	{
		if (arr[begin1] &lt; arr[begin2])
		{
			tmp[index++] = arr[begin1++];
		}
		else {
			tmp[index++] = arr[begin2++];
		}
	}
	while (begin1 &lt;= end1)
	{
		tmp[index++] = arr[begin1++];
	}
	while (begin2 &lt;= end2)
	{
		tmp[index++] = arr[begin2++];
	}
	//将tmp数据拷贝回arr中
	for (int i = left; i &lt;= right; i++)
	{
		arr[i] = tmp[i];
	}
}
void MergeSort(int* arr, int n)
{
	int* tmp = (int*)malloc(sizeof(int) * n);

	_MergeSort(arr, 0, n - 1, tmp);

	free(tmp);
}
</code></pre> 
<h2 style="background-color:transparent;">三、非比较排序</h2> 
<p>非比较排序，就是不进行比较数据来进行排序。</p> 
<h3 style="background-color:transparent;">        计数排序</h3> 
<p>1&gt;  统计相同元素出现次数</p> 
<p>2&gt;  根据统计的结果将序列回收到原来的序列中</p> 
<p><img alt="" height="194" src="https://images2.imgbox.com/9f/e0/h2gsY1TF_o.png" width="481"></p> 
<p></p> 
<p>这里又会存在一些问题，比如如果数据是负数，那该怎样开辟空间？</p> 
<p>        这里，我们开辟空间大小为数组数据最大值和最小值之差。</p> 
<p>然后在将统计结果返回到原来数组当中时，让数组下标加上原数组最小值即可。</p> 
<pre><code class="language-cpp">//计数排序
void CountSort(int* arr, int n)
{
	int max = arr[0];
	int min = arr[0];
	for (int i = 0; i &lt; n; i++)
	{
		if (arr[i] &gt; max)
		{
			max = arr[i];
		}
		if (arr[i] &lt; min)
		{
			min = arr[i];
		}
	}

	//开辟空间
	int range = max - min + 1;
	int* tmp = (int*)calloc(sizeof(int),range);
	if (tmp == NULL)
	{
		perror("calloc fail");
		return;
	}

	for (int i = 0; i &lt; n; i++)
	{
		tmp[arr[i] - min]++;
	}
	int j = 0;
	for (int i = 0; i &lt; range; i++)
	{
		while (tmp[i]--)
		{
			arr[j++] = i + min;
		}
	}
}</code></pre> 
<h2>各种排序算法的算法复杂度和稳定性分析</h2> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/71/15/qNv5xq4C_o.jpg"></p> 
<p><span style="color:#4da8ee;"><strong>到这里，排序算法就结束了，希望你能有所收获</strong></span></p> 
<p></p> 
<p><span style="color:#ff9900;"><strong><span style="background-color:#38d8f0;">感谢各位大佬支持并指出问题，</span></strong></span></p> 
<p><strong>                        <span style="color:#4da8ee;"><span style="background-color:#f9eda6;">如果本篇内容对你有帮助，可以一键三连支持以下，感谢支持！！！</span></span></strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/46/a5/CceK8hH2_o.jpg"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f3ebb5d342fee89c7b70a4fcd5ddcbfc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">js中map属性</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1e49e2cd8876cf6669642ce1546097da/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">花几千上万学习Java，真没必要！（三十五）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>