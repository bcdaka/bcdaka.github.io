<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>前端MQTT详细使用 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/52bb92a418d70f184257f702213fac7d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="前端MQTT详细使用">
  <meta property="og:description" content="首先 npm install mqtt --save 一,.第一种方法 (相对比较容易看懂) 使用场景跟MQTTX 类似的测试调试订阅接收信息的工具 (参数都是可配置的)
1.1 新建 mqtt.js import * as mqtt from &#34;mqtt/dist/mqtt.min&#34;; import { ElMessage } from &#39;element-plus&#39; class MQTT { url = &#39;&#39;;// mqtt地址 topic = &#39;&#39;; // clientId = &#39;&#39;; username = &#39;&#39;; password = &#39;&#39;;//密码 qos = 0; // 初始化类实例 constructor(params) { this.topic = params.topic; this.url = params.url; // 虽然是mqtt但是在客户端这里必须采用websock的链接方式 this.clientId = params.clientId; this.username = params.username; this.password = params.password; this.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-20T11:01:59+08:00">
    <meta property="article:modified_time" content="2024-03-20T11:01:59+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前端MQTT详细使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>首先</h4> 
<pre><code class="hljs">npm install mqtt --save
</code></pre> 
<h3><strong>一,.第一种方法 (相对比较容易看懂) </strong></h3> 
<p>使用场景跟MQTTX 类似的测试调试订阅接收信息的工具 (<span style="color:#fe2c24;">参数都是可配置的</span>)</p> 
<p><img alt="" height="578" src="https://images2.imgbox.com/5b/10/ZPR0nrh4_o.png" width="1200"></p> 
<h4>1.1 新建 mqtt.js</h4> 
<pre><code class="hljs">
import * as mqtt from "mqtt/dist/mqtt.min";
import { ElMessage } from 'element-plus'
class MQTT {
    url = '';// mqtt地址
    topic = ''; //
    clientId = '';
    username = '';
    password = '';//密码
    qos = 0;
    // 初始化类实例
    constructor(params) {
        this.topic = params.topic;
        this.url = params.url;
        // 虽然是mqtt但是在客户端这里必须采用websock的链接方式
        this.clientId = params.clientId;
        this.username = params.username;
        this.password = params.password;
        this.qos = params.qos;
    }

    //初始化mqtt
    init() {
        const options = {
            // protocol: "ws",
            // host: this.url,
            // ws: 8083; wss: 8084
            // port: 8083,
            // endpoint: "/mqtt",
            clean: true,
            connectTimeout: 4000, // 超时时间
            username: this.username,
            password: this.password,
            clientId: this.clientId,
            clean: true,
            connectTimeout: 30 * 1000, // ms
            reconnectPeriod: 4000, // ms
        };
//ws://localhost:8083/mqtt  这里组合起来是这种格式的地址 但是我传递过来的地址直接就是完整地址不用组装 所以我才注释上面 options 中的参数 
        const connectUrl = `${options.protocol}://${options.host}:${options.port}${options.endpoint}`;
//并在这里直接使用地址链接
        this.client = mqtt.connect(this.url, options);
        // 消息处理
        this.client.on("message", (topic, message) =&gt; {
            // console.log("收到消息", topic, message);
            // console.log("收到消息" + topic + '发来的' + JSON.parse(message));
        })
        // 重连处理
        this.client.on('reconnect', (error) =&gt; {
            console.log('正在重连:', error)
        });
        // 链接失败
        this.client.on('error', (error) =&gt; {
            console.log(error);
        });
    }
    //取消订阅
    unsubscribes() {
        this.client.unsubscribe(this.topic, (error) =&gt; {
            if (!error) {
                console.log('取消订阅成功');
            } else {
                // console.log('取消订阅失败');
            }
        });
    }
    //连接
    link() {
        this.client.on('connect', (con) =&gt; {
            let qosValue = this.qos
            this.client.subscribe(this.topic, { qosValue }, (error, res) =&gt; {
                if (!error) {
                    console.log('订阅成功');
                    ElMessage({
                        message: '订阅成功',
                        type: 'success',
                    })
                } else {
                    ElMessage({
                        message: '订阅失败',
                        type: 'error',
                    })
                    // console.log('订阅失败');
                }
            });
        });
    }
    // 发送信息
    SendMessage(topic, sendMsg) {
        let options = this.qos
        this.client.publish('rscu/sensor/exterior/up/id', sendMsg, options, (err, a) =&gt; {
            if (!err) {
                console.log('发送信息成功');
                ElMessage({
                    message: '发送信息成功',
                    type: 'success',
                })
            } else {
                console.log('发送信息失败');
            }
        })
    }
    //收到的消息
    get(callback) {
        this.client.on('message', callback);
    }
    //结束链接
    over() {
        this.client.end();
        console.log('结束链接');
    }
}
export default MQTT;
</code></pre> 
<h4>1.2 新建useMqtt.js (当时与对上面 mqtt.js的使用并二次封装)</h4> 
<pre><code class="hljs">import MQTT from './mqtt';
import { onUnmounted, ref } from 'vue';
import { ElMessage } from 'element-plus'
export default function useMqtt() {
    const PublicMqtt = ref(null);

    const startMqtt = (val, callback) =&gt; {

        //设置订阅地址
        PublicMqtt.value = new MQTT(val);
        //初始化mqtt
        PublicMqtt.value.init();
        //链接mqtt
        PublicMqtt.value.link();
        getMessage(callback);
    };
    // 发送信息 监测有没有链接 没有弹框
    const send = (topic, message) =&gt; {
        if (PublicMqtt.value) {
            let mqttPayload = JSON.parse(message);
            mqttPayload.dynamicType = "";
            message = JSON.stringify(mqttPayload);
            PublicMqtt.value.SendMessage(topic, message);
        } else {
            ElMessage({
                message: '尚未连接',
                type: 'error',
            });
        }
    }
    const getMessage = (callback) =&gt; {
        PublicMqtt.value?.get(callback);
    };
    // 断开链接
    const endMqtt = () =&gt; {
        if (PublicMqtt.value) {
            PublicMqtt.value.unsubscribes();
            PublicMqtt.value.over();
        }
    }
    onUnmounted(() =&gt; {
        //页面销毁结束订阅
        if (PublicMqtt.value) {
            PublicMqtt.value.unsubscribes();
            PublicMqtt.value.over();
        }
    });

    return {
        startMqtt,
        send,
        endMqtt
    };
}</code></pre> 
<h4>1.3页面使用</h4> 
<pre><code class="hljs">import useMqtt from '../../../utils/useMqtt'
const { startMqtt, send, endMqtt } = useMqtt();


//链接 订阅 方法  在需要的地方调用  (参数可看第一张效果图上的参数)
function ConcatMqttFn() {
//校验输入信息
    protocolForm.value.validate((valid) =&gt; {
        if (valid) {
            let params = {
                topic: protocolFormData.topic,   //主题  
                url: protocolFormData.addressPath, //地址
                clientId: protocolFormData.clientId,  //clientId
                username: protocolFormData.account,   //用户名
                password: protocolFormData.password,  //密码
                qos: protocolFormData.qos,  //qos
            }
            startMqtt(params, (topic, message) =&gt; {
//因为我在封装js里面 callback 将他接收的信息返回回来了 所以我在这可以直接接收到
                const msg = JSON.parse(message.toString());
                requestData.value = msg
            });
        }
    })
}


//最后在需要关闭链接 取消订阅的地方使用   endMqtt() 方法</code></pre> 
<h3>二,第二种方法 (<span style="color:#fe2c24;">适用于不用配置 全局固定死链接地址和订阅主题</span>) 就一个js文件</h3> 
<h4>2.1 新建allMqtt.js</h4> 
<pre><code class="hljs">import * as mqtt from "mqtt/dist/mqtt.min";
import { onUnmounted, ref, reactive } from 'vue';
import { ElNotification } from 'element-plus'
export default function useMqtt() {
    let client = ref({
        connected: false
    });
    const notifyPromise = ref(Promise.resolve())
    const qosList = [0, 1, 2];
    // 订阅主题
    const topic = ref('rscu/sensor/warning/count')
    // 发送主题
    const sendTopic = ref('rscu/sensor/warning')
    const qos = ref(1)
    // 链接地址
    const hostUrl = ref('')

//window.server.fileUploadUrl  这个是我在public文件下 static文件下 
//创建的config.js 中定义的一个全局静态地址 并在 index.html中引用了他 他不会被打包 
//你们也可以直接固定死
    hostUrl.value = window.server.fileUploadUrl ? window.server.fileUploadUrl : ''
    const connection = reactive({
        // 指明协议类型
        protocol: "ws",
        host: hostUrl.value,
        // ws: 8083; wss: 8084
        port: 8083,
        endpoint: "/mqtt",
        // for more options, please refer to https://github.com/mqttjs/MQTT.js#mqttclientstreambuilder-options
        clean: true,
        connectTimeout: 30 * 1000, // ms
        reconnectPeriod: 4000, // ms
        clientId: "emqx_benYing_" + Math.random().toString(16).substring(2, 8),
        // auth
        username: "warning",
        password: "root",
    });
    const messageValue = ref(false)
    // 订阅的信息
    const receiveNews = ref('')
    const time = ref(null)
    const startMqtt = (topic, callback) =&gt; {
        try {
            const { protocol, host, port, endpoint, ...options } = connection;
            const connectUrl = `${protocol}://${host}:${port}${endpoint}`;
            client.value = mqtt.connect(connectUrl, options);
            if (client.value.on) {
                // 连接
                client.value.on("connect", () =&gt; {
                    console.log("连接成功 successful");
                    link()
                });
                // 重连
                client.value.on("reconnect", handleOnReConnect);
                client.value.on("error", (error) =&gt; {
                    // console.log("重连失败 error:", error);
                });
                // 收到信息 callback返回收到的信息
                client.value.on("message", callback);
            }
        } catch (error) {
            // console.log("mqtt.connect error:", error);
        }
    };
    // 订阅
    const link = () =&gt; {
        client.value.subscribe(
            topic.value,
            '1',
            (error, granted) =&gt; {
                if (error) {
                    // console.log("订阅失败 error:", error);
                    return;
                } else {
                    sendMessage()
                    // console.log("订阅成功 successfully:", granted);
                }
            }
        );
    };
    // 取消订阅
    const UnSubscribe = () =&gt; {
        let qosValue = qos.value
        client.value.unsubscribe(topic.value, { qosValue }, (error) =&gt; {
            if (error) {
                // console.log("取消订阅失败 error:", error);
                return;
            }
            console.log(`取消订阅成功 topic: ${topic}`);
        });
    };
    // 取消连接
    const destroyConnection = () =&gt; {
        if (client.value.connected) {
            try {
                client.value.end(false, () =&gt; {
                    console.log("断开连接成功 successfully");
                });
            } catch (error) {
                // console.log("断开连接失败 error:", error);
            }
        }
    };

    const retryTimes = ref(0);
    const handleOnReConnect = () =&gt; {
        retryTimes.value += 1;
        if (retryTimes.value &gt; 5) {
            try {
                client.value.end();
                initData();
                // console.log("connection maxReconnectTimes limit, stop retry");
            } catch (error) {
                // console.log("handleOnReConnect catch error:", error);
            }
        }
    };
    const initData = () =&gt; {
        client.value = {
            connected: false,
        };
        retryTimes.value = 0;
    };
//发送信息
    const sendMessage = () =&gt; {
        client.value.publish('rscu/sensor/warning', '1', '1', (err, a) =&gt; {
            if (!err) { } else {

            }
        })
    };

    return {
        startMqtt,
        link,
        UnSubscribe,
        destroyConnection,
        sendMessage
    };
}</code></pre> 
<p><img alt="" height="249" src="https://images2.imgbox.com/12/dd/tKlrOTqf_o.png" width="662"></p> 
<p><img alt="" height="173" src="https://images2.imgbox.com/b1/05/dcOINQku_o.png" width="459"></p> 
<h4><strong>2.2使用</strong></h4> 
<pre><code class="hljs">// 使用MQTT
import useMqtt from '../../utils/allMqtt.js'
const { startMqtt, link, UnSubscribe, destroyConnection } = useMqtt();


//html:
    &lt;div class="message-prompt" :class="{ 'change': animateClass == true }"&gt;
                &lt;el-dropdown trigger="click" @command="messageHandleCommand"&gt;
                    &lt;span style="cursor: pointer;"&gt;
                        &lt;el-badge :value="all" :max="99" class="item"&gt;
                            &lt;el-icon color="#fff" size="20"&gt;
                                &lt;Bell /&gt;
                            &lt;/el-icon&gt;
                        &lt;/el-badge&gt;
                    &lt;/span&gt;
                    &lt;template #dropdown&gt;
                        &lt;el-dropdown-menu&gt;
                            &lt;el-dropdown-item command="warning"&gt;
                                &lt;span&gt;预警&lt;/span&gt;
                                &lt;span class="warning-text num"&gt;{<!-- -->{ alarm }}&lt;/span&gt;
                            &lt;/el-dropdown-item&gt;
                            &lt;el-dropdown-item command="alarm"&gt;
                                &lt;span&gt;报警&lt;/span&gt;
                                &lt;span class="alarm-text num"&gt;{<!-- -->{ warning }}&lt;/span&gt;
                            &lt;/el-dropdown-item&gt;
                            &lt;el-dropdown-item command="all"&gt;
                                &lt;span&gt;查看全部&lt;/span&gt;
                            &lt;/el-dropdown-item&gt;
                        &lt;/el-dropdown-menu&gt;
                    &lt;/template&gt;
                &lt;/el-dropdown&gt;
            &lt;/div&gt;






//因为我在链接的时候 顺便调用了他的订阅方法 在js中 所以我在这直接链接
function ConcatMqttFn() {
    startMqtt('', (topic, message) =&gt; {
//拿到的数据
        const msg = JSON.parse(message.toString());
        // console.log(msg, 'msg');
        alarm.value = msg.data.alarm
        all.value = msg.data.all
        warning.value = msg.data.warning
    });
}


//生命周期销毁的时候 取消 断开
onMounted(() =&gt; {
    destroyConnection()
    ConcatMqttFn()
});
</code></pre> 
<h4>2.3实现效果</h4> 
<p><img alt="" height="180" src="https://images2.imgbox.com/ce/80/VL8oLRXn_o.png" width="243"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3458520f4a5f1f393614539ec5a5ae9b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Java】Comparator 的用法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/98d74497c5ca0f2cc7a1c0e9269505c9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SpringBoot整合Nacos做配置中心</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>