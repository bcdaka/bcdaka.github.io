<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Python】超详细实例讲解python多线程（threading模块） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/57fba68c47a7486040caf52d800e3b7b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【Python】超详细实例讲解python多线程（threading模块）">
  <meta property="og:description" content="什么是多线程? 线程（thread）是操作系统中能够进行运算的最小单位，包含于进程之中，一个进程可以有多个线程，这意味着一个进程中可以并发多个线程，即为多线程。
对于一个python程序，如果需要同时大量处理多个任务，有使用多进程和多线程两种方法。在python中，实现多线程主要通过threading模块，而多进程主要通过multiprocessing模块。
这两个模块的主要区别是：threading模块基于线程，而multiprocessing模块基于进程。threading模块使用共享内存来实现多线程，所有线程都共享一样的变量（这点在后续的实例中可以感受到）；而multiprocessing基于子进程，每个子进程之间都有独立的变量和数据结构。两者的区别意味着threading更使用于I/O密集型任务（例如需要进行多表格读取操作），multiprocessing模块更适用于包含较多计算的CPU密集型任务（矩阵运算，图片处理类任务）。
需要注意的是，由于python中的GIL锁的存在，Python解释器只允许一个Python进程使用，这意味着对于一个解释器只允许一个进程在运行，这也是为什么threading模块无法适用于CPU密集型这类需要大量CPU资源的任务，因为一个进程的CPU资源有限，无论开启多少个线程，总的资源就只有那些，总耗时不会有太大变化。而multiprocessing模块则可以开多个进程，能够更快速的处理CPU密集型任务。
关于GIL锁和Multiprocessing模块的部分就不继续深入介绍了，本次主要介绍如何使用threading模块实现多线程的相关内容。
线程完整生命周期 一个线程完整的生命周期包括新建——就绪——运行——阻塞——死亡。
新建：即新创建一个线程对象就绪：调用start方法后，线程对象等待运行，什么时候开始运行取决于调度运行：线程处于运行状态阻塞：处于运行状态的线程被堵塞，通俗理解就是被卡住了，可能的原因包括但不限于程序自身调用sleep方法阻塞线程运行，或调用了一个阻塞式I/O方法，被阻塞的进程会等待何时解除阻塞重新运行死亡：线程执行完毕或异常退出，线程对象被销毁并释放内存 主线程与子线程 我们讲的多线程实际上指的就是只在主线程中运行多个子线程，而主线程就是我们的python编译器执行的线程，所有子线程和主线程都同属于一个进程。在未添加子线程的情况下，默认就只有一个主线程在运行，他会将我们写的代码从开头到结尾执行一遍，后文中我们也会提到一些主线程与子线程的关系。
不扯那么多概念了，接下来直接进入正题！
实例1：直接使用Thread创建线程对象 Thread类创建新线程的基本语法如下：
Newthread = Thread(target=function, args=(argument1,argument2,...))
Newthread: 创建的线程对象function: 要执行的函数argument1,argument2: 传递给线程函数的参数，为tuple类型 假设一个任务task(当然task可以替换为其他任何任务，本实例中仅为假设)，这个任务实现的功能是每隔1s打印某个字母，我们使用两个子线程，分别同时打印不同的字母a和b，实例如下：
&#34;&#34;&#34; &lt;case1: 直接使用threading中的Thread类创建线程&gt; Date: 2024/5/15 Author: 猫猫不吃sakana &#34;&#34;&#34; from threading import Thread import time from time import sleep # 自定义的函数，可以替换成其他任何函数 def task(threadName, number, letter): print(f&#34;【线程开始】{threadName}&#34;) m = 0 while m &lt; number: sleep(1) m &#43;= 1 current_time = time.strftime(&#39;%H:%M:%S&#39;, time.localtime()) print(f&#34;[{current_time}] {threadName} 输出 {letter}&#34;) print(f&#34;【线程结束】{threadName}&#34;) thread1 = Thread(target=task, args=(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-24T14:21:42+08:00">
    <meta property="article:modified_time" content="2024-05-24T14:21:42+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Python】超详细实例讲解python多线程（threading模块）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>什么是多线程?</h2> 
<p>线程（thread）是操作系统中能够进行运算的最小单位，包含于进程之中，一个进程可以有多个线程，这意味着一个进程中可以并发多个线程，即为多线程。</p> 
<p>对于一个python程序，如果需要同时大量处理多个任务，有使用多进程和多线程两种方法。在python中，实现多线程主要通过threading模块，而多进程主要通过multiprocessing模块。</p> 
<p>这两个模块的主要区别是：threading模块基于线程，而multiprocessing模块基于进程。threading模块使用共享内存来实现多线程，所有线程都共享一样的变量（这点在后续的实例中可以感受到）；而multiprocessing基于子进程，每个子进程之间都有独立的变量和数据结构。两者的区别意味着threading更使用于I/O密集型任务（例如需要进行多表格读取操作），multiprocessing模块更适用于包含较多计算的CPU密集型任务（矩阵运算，图片处理类任务）。</p> 
<p>需要注意的是，由于python中的GIL锁的存在，Python解释器只允许一个Python进程使用，这意味着对于一个解释器只允许一个进程在运行，这也是为什么threading模块无法适用于CPU密集型这类需要大量CPU资源的任务，因为一个进程的CPU资源有限，无论开启多少个线程，总的资源就只有那些，总耗时不会有太大变化。而multiprocessing模块则可以开多个进程，能够更快速的处理CPU密集型任务。</p> 
<p>关于GIL锁和Multiprocessing模块的部分就不继续深入介绍了，本次主要介绍如何使用threading模块实现多线程的相关内容。</p> 
<h2>线程完整生命周期</h2> 
<blockquote> 
 <p>一个线程完整的生命周期包括新建——就绪——运行——阻塞——死亡。</p> 
 <ol><li>新建：即新创建一个线程对象</li><li>就绪：调用start方法后，线程对象等待运行，什么时候开始运行取决于调度</li><li>运行：线程处于运行状态</li><li>阻塞：处于运行状态的线程被堵塞，通俗理解就是被卡住了，可能的原因包括但不限于程序自身调用sleep方法阻塞线程运行，或调用了一个阻塞式I/O方法，被阻塞的进程会等待何时解除阻塞重新运行</li><li>死亡：线程执行完毕或异常退出，线程对象被销毁并释放内存</li></ol> 
</blockquote> 
<h2>主线程与子线程 </h2> 
<blockquote> 
 <p>我们讲的多线程实际上指的就是只在主线程中运行多个子线程，而主线程就是我们的python编译器执行的线程，所有子线程和主线程都同属于一个进程。在未添加子线程的情况下，默认就只有一个主线程在运行，他会将我们写的代码从开头到结尾执行一遍，后文中我们也会提到一些主线程与子线程的关系。</p> 
</blockquote> 
<p><em>不扯那么多概念了，接下来直接进入正题！</em></p> 
<h2>实例1：直接使用Thread创建线程对象</h2> 
<blockquote> 
 <p>Thread类创建新线程的基本语法如下：</p> 
 <p><strong>Newthread</strong> = Thread(target=<strong>function</strong>, args=(<strong>argument1</strong>,<strong>argument2</strong>,...))</p> 
 <ul><li><strong>Newthread</strong>: 创建的线程对象</li><li><strong>function</strong>: 要执行的函数</li><li><strong>argument1</strong>,<strong>argument2</strong>: 传递给线程函数的参数，为tuple类型</li></ul> 
</blockquote> 
<p>假设一个任务task(当然task可以替换为其他任何任务，本实例中仅为假设)，这个任务实现的功能是每隔1s打印某个字母，我们使用两个子线程，分别同时打印不同的字母a和b，实例如下：</p> 
<pre><code class="language-python">"""
&lt;case1: 直接使用threading中的Thread类创建线程&gt;
Date: 2024/5/15
Author: 猫猫不吃sakana
"""

from threading import Thread
import time
from time import sleep


# 自定义的函数，可以替换成其他任何函数
def task(threadName, number, letter):
    print(f"【线程开始】{threadName}")
    m = 0
    while m &lt; number:
        sleep(1)
        m += 1
        current_time = time.strftime('%H:%M:%S', time.localtime())
        print(f"[{current_time}] {threadName} 输出 {letter}")
    print(f"【线程结束】{threadName}")


thread1 = Thread(target=task, args=("thread_1", 4, "a"))  # 线程1：执行任务打印4个a
thread2 = Thread(target=task, args=("thread_2", 2, "b"))  # 线程2：执行任务打印2个b

thread1.start()  # 线程1开始
thread2.start()  # 线程2开始

thread1.join()  # 等待线程1结束
thread2.join()  # 等待线程2结束</code></pre> 
<p>其输出为：</p> 
<pre><code class="language-python">【线程开始】thread_1
【线程开始】thread_2
[13:42:00] thread_1 输出 a
[13:42:00] thread_2 输出 b
[13:42:01] thread_1 输出 a
[13:42:01] thread_2 输出 b
【线程结束】thread_2
[13:42:02] thread_1 输出 a
[13:42:03] thread_1 输出 a
【线程结束】thread_1</code></pre> 
<p>线程thread1和thread2同时开始，thread2打印2个b后结束，而thread1继续打印a直到完成。</p> 
<h2> 实例2：使用join阻塞线程</h2> 
<blockquote> 
 <p>在前一个实例中我们可以看到在结尾有thread1.join()和thread2.join()两个语句，这两个语句出现在末尾表示主线程会等待所有的子线程执行完成，当然了，由于默认我们创建的子线程是前台线程（这个概念会在后面提到），如果没有join语句主线程也会等待所有子线程执行完毕才退出。</p> 
 <p>join方法可以用于阻塞主线程的顺序执行，因此，在主线程中使用可以调整各个子线程的执行顺序，了解完这些之后，我们来看下一个实例。</p> 
</blockquote> 
<pre><code class="language-python">"""
&lt;case2: 使用join方法阻塞进程&gt;
Date: 2024/5/15
Author: 猫猫不吃sakana
"""

from threading import Thread
import time
from time import sleep


# 自定义的函数，可以替换成其他任何函数
def task(threadName, number, letter):
    print(f"【线程开始】{threadName}")
    m = 0
    while m &lt; number:
        sleep(1)
        m += 1
        current_time = time.strftime('%H:%M:%S', time.localtime())
        print(f"[{current_time}] {threadName} 输出 {letter}")
    print(f"【线程结束】{threadName}")


thread1 = Thread(target=task, args=("thread_1", 6, "a"))  # 线程1：假设任务为打印6个a
thread2 = Thread(target=task, args=("thread_2", 4, "b"))  # 线程2：假设任务为打印4个b
thread3 = Thread(target=task, args=("thread_3", 2, "c"))  # 线程3：假设任务为打印2个c

thread1.start()  # 线程1启动
thread2.start()  # 任务2启动
thread2.join()   # 等待线程2
thread3.start()  # 线程2完成任务后线程3才启动
thread1.join()   # 等待线程1完成线程
thread3.join()   # 等待线程3完成线程</code></pre> 
<p>其输出为：</p> 
<pre><code class="language-python">【线程开始】thread_1
【线程开始】thread_2
[13:44:20] thread_2 输出 b
[13:44:20] thread_1 输出 a
[13:44:21] thread_2 输出 b
[13:44:21] thread_1 输出 a
[13:44:22] thread_2 输出 b
[13:44:22] thread_1 输出 a
[13:44:23] thread_2 输出 b
【线程结束】thread_2
[13:44:23] thread_1 输出 a
【线程开始】thread_3
[13:44:24] thread_3 输出 c
[13:44:24] thread_1 输出 a
[13:44:25] thread_1 输出 a
[13:44:25] thread_3 输出 c
【线程结束】thread_3
【线程结束】thread_1</code></pre> 
<p>由输出可以看出，由于join的加入，thread2.join使得主进程一直在等待thread2线程完成任务，因此直到线程thread2结束后，thread3才开始任务。</p> 
<p>由于这里thread1一共打印6个a，thread2打印4个b，thread3打印2个c。thread1的工作量等于thread2+thread3的工作量之和，因此整个程序可以看成是thread1与thread2+thread3并行运行。</p> 
<h2>实例3：重写父类threading.Thread创建线程</h2> 
<blockquote> 
 <p>实例1和2中，我们已经介绍了如何直接导入Thread函数创建线程以及如何利用join方法，但是这种创建线程的方法本质上使用的是其父类的默认设置，具有局限性。在实例3中，将进一步深入探讨如何继承并重写父类threading.Thread类创建子线程。</p> 
</blockquote> 
<p>和实例2相同，我们假设需要用多个线程处理任务task1，thread1打印4个a字母（耗时4s），thread2线程打印2个b字母（耗时2s），如下：</p> 
<pre><code class="language-python">"""
&lt;case3: 重写父类threading.Thread创建线程&gt;
Date: 2024/5/15
Author: 猫猫不吃sakana
"""

import threading
import time
from time import sleep


# myThread继承父类，并进行重写
class myThread(threading.Thread):
    # 重写父类的构造函数
    def __init__(self, number, letter):
        threading.Thread.__init__(self)
        self.number = number  # 添加number变量
        self.letter = letter  # 添加letter变量

    # 重写父类中的run函数
    def run(self):
        print(f"【线程开始】{self.name}")
        task1(self.name, self.number, self.letter)
        print("【线程结束】", self.name)

    # 重写父类析构函数
    def __del__(self):
        print("【线程销毁释放内存】", self.name)


# 自定义的函数，此处可以替换成任何其他想要多线程执行的任务
def task1(threadName, number, letter):
    m = 0
    while m &lt; number:
        sleep(1)
        m += 1
        current_time = time.strftime('%H:%M:%S', time.localtime())
        print(f"[{current_time}] {threadName} 输出 {letter}")

# def task2...
# def task3...


thread1 = myThread(4, "a")  # 创建线程thread1：任务耗时2s
thread2 = myThread(2, "b")  # 创建线程thread2：任务耗时4s

thread1.start()  # 启动线程1
thread2.start()  # 启动线程2

thread1.join()  # 等待线程1
thread2.join()  # 等待线程2</code></pre> 
<p>输出为：</p> 
<pre><code class="language-python">【线程开始】Thread-1
【线程开始】Thread-2
[10:37:58] Thread-1 输出 a
[10:37:58] Thread-2 输出 b
[10:37:59] Thread-1 输出 a
[10:37:59] Thread-2 输出 b
【线程结束】 Thread-2
[10:38:00] Thread-1 输出 a
[10:38:01] Thread-1 输出 a
【线程结束】 Thread-1
【线程销毁释放内存】 Thread-1
【线程销毁释放内存】 Thread-2</code></pre> 
<p>从输出中，我们可以清楚的看到两个并行任务从开始到结束，最后一起销毁并释放内存的全过程，很好的体现了线程的一个完整生命周期过程。</p> 
<p>最后实现的效果与实例1实现的效果相同，但是使用继承重写父类的方法，可以让我们更加自由的定义各项参数以及定义线程处理的任务，也能让我们对threading模块的理解更加深入。</p> 
<h2>实例4：前台线程与后台线程（守护线程）</h2> 
<blockquote> 
 <p>在前面的所有实例中，我们忽略了threading.Thread的daemon参数，其默认为False，表示线程默认就是一个前台线程。</p> 
 <p>前台线程表示当所有的前台线程都执行完毕时，整个程序才退出。将daemon参数设定为True是表示线程是一个后台线程，此时主进程结束时，所有未执行完成的后台线程也都会直接自动结束。</p> 
</blockquote> 
<p>在上一个实例的基础上，在初始化部分加入self.daemon=True，并去掉末尾的join方法，替换成sleep方法来阻塞主程序的运行，我们来看看结果会变成什么样，实例如下：</p> 
<pre><code class="language-python">"""
&lt;case4: 前台线程与后台线程&gt;
Date: 2024/5/15
Author: 猫猫不吃sakana
"""

import threading
import time
from time import sleep


# myThread继承父类，并进行重写
class myThread(threading.Thread):
    # 重写父类的构造函数
    def __init__(self, number, letter):
        threading.Thread.__init__(self)
        self.number = number  # 添加number变量
        self.letter = letter  # 添加letter变量
        self.daemon = True  # 默认前台线程

    # 重写父类中的run函数
    def run(self):
        print(f"【线程开始】{self.name}")
        task1(self.name, self.number, self.letter)
        print("【线程结束】", self.name)

    # 重写父类析构函数
    def __del__(self):
        print("【线程销毁释放内存】", self.name)


# 自定义的函数，此处可以替换成任何其他想要多线程执行的任务
def task1(threadName, number, letter):
    m = 0
    while m &lt; number:
        sleep(1)
        m += 1
        current_time = time.strftime('%H:%M:%S', time.localtime())
        print(f"[{current_time}] {threadName} 输出 {letter}")

# def task2...
# def task3...


thread1 = myThread(4, "a")  # 创建线程thread1：假设任务耗时2s
thread2 = myThread(2, "b")  # 创建线程thread2：假设任务耗时4s

thread1.start()  # 启动线程1
thread2.start()  # 启动线程2

time.sleep(3)  # 主程序等待3s再继续执行</code></pre> 
<p>其输出将变为：</p> 
<pre><code class="language-python">【线程开始】Thread-1
【线程开始】Thread-2
[10:31:45] Thread-1 输出 a
[10:31:45] Thread-2 输出 b
[10:31:46] Thread-1 输出 a
[10:31:46] Thread-2 输出 b
【线程结束】 Thread-2

Process finished with exit code 0</code></pre> 
<p>我们用sleep方法强行阻塞了主程序3s，但是由于我们将线程设定为了后台线程，3s过后，主程序将执行完毕，此时两个子线程thread1和thread2无论是否执行完成，都将强行结束。</p> 
<p>将daemon参数设定为False，其输出则与实例3相同，如下：</p> 
<pre><code class="language-python">【线程开始】Thread-1
【线程开始】Thread-2
[10:30:14] Thread-1 输出 a
[10:30:14] Thread-2 输出 b
[10:30:15] Thread-1 输出 a
[10:30:15] Thread-2 输出 b
【线程结束】 Thread-2
[10:30:16] Thread-1 输出 a
[10:30:17] Thread-1 输出 a
【线程结束】 Thread-1
【线程销毁释放内存】 Thread-1
【线程销毁释放内存】 Thread-2</code></pre> 
<h2>实例5：线程同步（线程锁）</h2> 
<p>我们设想一下这种情况，当多线程同时执行时，由于threading模块的中线程的变量和数据结构共享，可能会出现多个线程同时修改一个数据的情况，这绝对是不行的。</p> 
<blockquote> 
 <p>为了将各个线程同步，我们引入线程锁的概念。当某个线程访问数据时，先对其加锁，其他线程若再想访问这个数据就会被阻塞，直到前一个线程解锁释放。在threading模块中，加锁和释放锁主要使用Lock类，使用其中的acquire()和release()方法：</p> 
 <pre><code class="language-python">Lock = threading.Lock()  # 在threading模块中获得锁类
Lock.acquire()  # 设置锁
Lock.release()  # 释放锁</code></pre> 
</blockquote> 
<p>在介绍线程锁实例时，我们就不使用前面几个实例用的打印字母的任务了。为了让各位更加直观地体会到线程锁的作用，我们使用多线程对一个列表list进行数据删改。</p> 
<p>假设此时有多个线程都需要对这个列表进行修改操作，实例如下：</p> 
<pre><code class="language-python">"""
&lt;case5: 线程同步，线程锁&gt;
Date: 2024/5/15
Author: 猫猫不吃sakana
"""

import threading
import time


# 子类myThread继承父类threading.Thread，并进行重写
class myThread(threading.Thread):
    # 重写父类构造函数
    def __init__(self, number):
        threading.Thread.__init__(self)
        self.number = number

    # 重写父类run函数，在调用start()时自动调用run函数
    def run(self):
        print(f"【线程开始】{self.name}")
        Lock.acquire()  # 设置线程锁
        edit_list(self.name, self.number)
        Lock.release()  # 释放线程锁

    # 重写父类析构函数
    def __del__(self):
        print("【线程销毁】", self.name)


# 自定义的任务函数
def edit_list(threadName, number):
    while number &gt; 0:
        time.sleep(1)
        data_list[number-1] += 1
        current_time = time.strftime('%H:%M:%S', time.localtime())
        print(f"[{current_time}] {threadName} 修改datalist为{data_list}")
        number -= 1
    print(f"【线程{threadName}完成工作】")


data_list = [0, 0, 0, 0]
Lock = threading.Lock()

# 创建3个子线程
thread1 = myThread(1)
thread2 = myThread(2)
thread3 = myThread(3)

# 启动3个子线程
thread1.start()
thread2.start()
thread3.start()

# 主进程等待所有线程完成
thread1.join()
thread2.join()
thread3.join()

print("【主进程结束】")</code></pre> 
<p>输出为：</p> 
<pre><code class="language-python">【线程开始】Thread-1
【线程开始】Thread-2
【线程开始】Thread-3
[09:55:22] Thread-1 修改datalist为[1, 0, 0, 0]
【线程Thread-1完成工作】
[09:55:23] Thread-2 修改datalist为[1, 1, 0, 0]
[09:55:24] Thread-2 修改datalist为[2, 1, 0, 0]
【线程Thread-2完成工作】
[09:55:25] Thread-3 修改datalist为[2, 1, 1, 0]
[09:55:26] Thread-3 修改datalist为[2, 2, 1, 0]
[09:55:27] Thread-3 修改datalist为[3, 2, 1, 0]
【线程Thread-3完成工作】
【主进程结束】
【线程销毁】 Thread-1
【线程销毁】 Thread-2
【线程销毁】 Thread-3</code></pre> 
<blockquote> 
 <p> 当三个线程都需要使用同一个数据时，我们只需要对线程的run方法中进行加锁和释放锁的操作即可。此时三个子线程将会进行顺序操作，前一个子线程执行完成释放锁后，后一个线程才会继续执行。要注意的是，这三个子线程使用的需要是同一把锁。</p> 
</blockquote> 
<h2> 写在最后</h2> 
<p>这是我第一次尝试发文，写文章的初衷就是和大家能够一起进步，有什么不足大家也可以在评论区提出来，后续可能会继续更新python的一些知识点以及自己的学习感悟，与各位共勉。</p> 
<p>threading模块还有很多可选参数和方法可供使用，详情可参见threading模块的官方文档</p> 
<p><a class="has-card" href="https://docs.python.org/zh-cn/3/library/threading.html#" rel="nofollow" title="点击链接：threading --- Thread-based parallelism — Python 3.12.3 文档"><span class="link-card-box"><span class="link-title">点击链接：threading --- Thread-based parallelism — Python 3.12.3 文档</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/58/a1/lWTU8E1h_o.png" alt="icon-default.png?t=N7T8">https://docs.python.org/zh-cn/3/library/threading.html#</span></span></a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9d2cded2e4413803d95c574019f0dfb3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C/C&#43;&#43;运行时库和UCRT系统通用运行时库总结及问题实例分享</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f2c46d995042c1f694ae92f4289e053a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【微信小程序[app.json: 在项目根目录未找到 app.json]】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>