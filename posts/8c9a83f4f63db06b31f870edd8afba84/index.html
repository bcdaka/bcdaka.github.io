<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构之链表的经典笔试题 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/8c9a83f4f63db06b31f870edd8afba84/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构之链表的经典笔试题">
  <meta property="og:description" content="找往期文章包括但不限于本期文章中不懂的知识点：
个人主页：我要学编程(ಥ_ಥ)-CSDN博客
所属专栏：数据结构（Java版）
目录
203. 移除链表元素
206. 反转链表
876. 链表的中间节点
面试题 02.02. 返回倒数第k个节点
快慢指针的原理分析 21. 合并两个有序链表
牛客网——链表的回文
牛客网——链表分割
160. 相交链表
141. 环形链表
142. 环形链表 II
单链表的刷题，点我
下面的这些面试题有一部分在上面这篇博文中，有兴趣可以看一看。
​
下列题目中出现的这个，是出题者想告诉我们这个链表的节点是由什么组成的。 203. 移除链表元素 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。
示例 1：
​
输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5] 示例 2：
输入：head = [], val = 1 输出：[] 示例 3：
输入：head = [7,7,7,7], val = 7 输出：[] 提示：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-12T22:30:00+08:00">
    <meta property="article:modified_time" content="2024-06-12T22:30:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构之链表的经典笔试题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> 找往期文章包括但不限于本期文章中不懂的知识点：</p> 
<blockquote> 
 <p><strong>个人主页：</strong><a href="https://blog.csdn.net/2301_80854132?type=blog" title="我要学编程(ಥ_ಥ)-CSDN博客">我要学编程(ಥ_ಥ)-CSDN博客</a></p> 
 <p><strong>所属专栏：<strong><a href="https://blog.csdn.net/2301_80854132/category_12650676.html" title="数据结构（Java版）">数据结构（Java版）</a></strong></strong></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="203.%20%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0-toc" style="margin-left:0px;"><a href="#203.%20%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0" rel="nofollow">203. 移除链表元素</a></p> 
<p id="206.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#206.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8" rel="nofollow">206. 反转链表</a></p> 
<p id="876.%20%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9-toc" style="margin-left:0px;"><a href="#876.%20%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9" rel="nofollow">876. 链表的中间节点</a></p> 
<p id="%E9%9D%A2%E8%AF%95%E9%A2%98%2002.02.%20%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9-toc" style="margin-left:0px;"><a href="#%E9%9D%A2%E8%AF%95%E9%A2%98%2002.02.%20%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9" rel="nofollow">面试题 02.02. 返回倒数第k个节点</a></p> 
<p id="%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E7%9A%84%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E7%9A%84%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%C2%A0" rel="nofollow">快慢指针的原理分析 </a></p> 
<p id="21.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#21.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8" rel="nofollow">21. 合并两个有序链表</a></p> 
<p id="%E7%89%9B%E5%AE%A2%E7%BD%91%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9B%9E%E6%96%87-toc" style="margin-left:0px;"><a href="#%E7%89%9B%E5%AE%A2%E7%BD%91%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9B%9E%E6%96%87" rel="nofollow">牛客网——链表的回文</a></p> 
<p id="%E7%89%9B%E5%AE%A2%E7%BD%91%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8%E5%88%86%E5%89%B2-toc" style="margin-left:0px;"><a href="#%E7%89%9B%E5%AE%A2%E7%BD%91%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8%E5%88%86%E5%89%B2" rel="nofollow">牛客网——链表分割</a></p> 
<p id="160.%20%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#160.%20%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8" rel="nofollow">160. 相交链表</a></p> 
<p id="%C2%A0141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#%C2%A0141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8" rel="nofollow"> 141. 环形链表</a></p> 
<p id="142.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II-toc" style="margin-left:0px;"><a href="#142.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II" rel="nofollow">142. 环形链表 II</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p><a href="https://blog.csdn.net/2301_80854132/article/details/137676612" title="单链表的刷题，点我">单链表的刷题，点我</a></p> 
<p>下面的这些面试题有一部分在上面这篇博文中，有兴趣可以看一看。</p> 
<p><img alt="" height="379" src="https://images2.imgbox.com/a1/c4/RXfrVZN5_o.png" width="1200">​</p> 
<p>下列题目中出现的这个，是出题者想告诉我们这个链表的节点是由什么组成的。 </p> 
<h2 id="203.%20%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0" style="background-color:transparent;"><a href="https://leetcode.cn/problems/remove-linked-list-elements/" rel="nofollow" title="203. 移除链表元素">203. 移除链表元素</a></h2> 
<blockquote> 
 <p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <div> 
  <p><img alt="" height="222" src="https://images2.imgbox.com/90/a4/LP62oyA5_o.jpg" width="782">​</p> 
 </div> 
 <pre><strong>输入：</strong>head = [1,2,6,3,4,5,6], val = 6
<strong>输出：</strong>[1,2,3,4,5]
</pre> 
 <p><strong>示例 2：</strong></p> 
 <pre><strong>输入：</strong>head = [], val = 1
<strong>输出：</strong>[]
</pre> 
 <p><strong>示例 3：</strong></p> 
 <pre><strong>输入：</strong>head = [7,7,7,7], val = 7
<strong>输出：</strong>[]
</pre> 
 <p><strong>提示：</strong></p> 
 <ul><li>列表中的节点数目在范围 <code>[0, 104]</code> 内</li><li><code>1 &lt;= Node.val &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 50</code></li></ul> 
</blockquote> 
<p>思路：就是遍历链表，找到所有值为val的节点，并删除即可。 </p> 
<div> 
 <pre><code class="language-java">class Solution {
    public ListNode removeElements(ListNode head, int val) {
        // 删除链表中所有值为节点
        // 首先判断链表是否为空
        if (head == null ) {
            // 链表为空，肯定head为空
            return head;
        }
        ListNode cur = head;
        while (cur.next != null) {
            // 找到值为val的前一个节点
            if (cur.next.val == val) {
                cur.next = cur.next.next;
            }else {
                // 没找到就继续往后找
                cur = cur.next;
            }
        }
        // 判断头节点是否为val
        if (head.val == val) {
            head = head.next;
        }
        return head;
    }
}</code></pre> 
</div> 
<h2 id="206.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><a href="https://leetcode.cn/problems/reverse-linked-list/" rel="nofollow" title="206. 反转链表">206. 反转链表</a></h2> 
<blockquote> 
 <p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <div> 
  <p><img alt="" height="222" src="https://images2.imgbox.com/6b/dd/0ufaO4v3_o.jpg" width="542">​</p> 
 </div> 
 <pre><strong>输入：</strong>head = [1,2,3,4,5]
<strong>输出：</strong>[5,4,3,2,1]
</pre> 
 <p><strong>示例 2：</strong></p> 
 <div> 
  <p><img alt="" height="222" src="https://images2.imgbox.com/20/26/kVq32rny_o.jpg" width="182">​</p> 
 </div> 
 <pre><strong>输入：</strong>head = [1,2]
<strong>输出：</strong>[2,1]
</pre> 
 <p><strong>示例 3：</strong></p> 
 <pre><strong>输入：</strong>head = []
<strong>输出：</strong>[]

</pre> 
 <p><strong>提示：</strong></p> 
 <ul><li>链表中节点的数目范围是 <code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul> 
</blockquote> 
<p>思路：遍历原链表，将其中的所有节点全部头插到原链表中。</p> 
<div> 
 <pre><code class="language-java">class Solution {
    public ListNode reverseList(ListNode head) {
        // 当链表为空，或者只有一个节点时，就直接返回原链表
        if (head == null || head.next == null) {
            return head;
        }
        // 开始头插
        ListNode cur = head.next;
        // 这个要变为null，否则就会成环。
        // 因为这个节点是最后一个节点，而最后一个节点的next值不为null，就会造成错误
        head.next = null; 
        while (cur != null) {
            ListNode curNext = cur.next;
            cur.next = head; 
            head = cur;
            cur = curNext;
        }
        return head;
    }
}</code></pre> 
</div> 
<h2 id="876.%20%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9"><a href="https://leetcode.cn/problems/middle-of-the-linked-list/" rel="nofollow" title="876. 链表的中间节点">876. 链表的中间节点</a></h2> 
<blockquote> 
 <p>给你单链表的头结点 <code>head</code> ，请你找出并返回链表的中间结点。</p> 
 <p>如果有两个中间结点，则返回第二个中间结点。</p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <div> 
  <p><img alt="" height="65" src="https://images2.imgbox.com/b7/9e/N3SlR1qV_o.jpg" width="544">​</p> 
 </div> 
 <pre><strong>输入：</strong>head = [1,2,3,4,5]
<strong>输出：</strong>[3,4,5]
<strong>解释：</strong>链表只有一个中间结点，值为 3 。
</pre> 
 <p><strong>示例 2：</strong></p> 
 <div> 
  <p><img alt="" height="65" src="https://images2.imgbox.com/a7/a2/0J5nj0Yp_o.jpg" width="664">​</p> 
 </div> 
 <pre><strong>输入：</strong>head = [1,2,3,4,5,6]
<strong>输出：</strong>[4,5,6]
<strong>解释：</strong>该链表有两个中间结点，值分别为 3 和 4 ，返回第二个结点。

</pre> 
 <p><strong>提示：</strong></p> 
 <ul><li>链表的结点数范围是 <code>[1, 100]</code></li><li><code>1 &lt;= Node.val &lt;= 100</code></li></ul> 
</blockquote> 
<p>思路一：通过遍历链表得出链表的长度，然后让cur从头节点开始走 长度的一半 的步数，那么这个节点的位置就是中间节点。</p> 
<p>思路二：通过快慢指针的方式来解题。快指针fast，一次走两步，慢指针slow，一次走一步。当快指针走到链表的尾节点处时，慢指针就是在当前链表的中间节点。</p> 
<div> 
 <pre><code class="language-java">class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        // 只要两者有一种情况不满足，就说明走到了尾节点，可以停止遍历了。
        while (fast != null &amp;&amp; fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow;
    }
}</code></pre> 
</div> 
<h2 id="%E9%9D%A2%E8%AF%95%E9%A2%98%2002.02.%20%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9"><a href="https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/" rel="nofollow" title="面试题 02.02. 返回倒数第k个节点">面试题 02.02. 返回倒数第k个节点</a></h2> 
<blockquote> 
 <p> 实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。</p> 
 <p><strong>注意：</strong>本题相对原题稍作改动</p> 
 <p><strong>示例：</strong></p> 
 <pre><strong>输入：</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5 和 <em>k</em> = 2
<strong>输出： </strong>4</pre> 
 <p><strong>说明：</strong></p> 
 <p>给定的 <em>k</em> 保证是有效的。</p> 
</blockquote> 
<p>思路一：遍历得出链表的长度，然后用长度减去k，得出的结果就是cur要走的步数。</p> 
<p>思路二：通过快慢指针的方式来解题。快指针先走k-1步，然后快指针和慢指针一起走，直至快指针到达尾节点，这时慢指针的位置就是倒数第k个节点的位置。</p> 
<div> 
 <pre><code class="language-java">class Solution {
    public int kthToLast(ListNode head, int k) {
        ListNode fast = head;
        ListNode slow = head;
        while ((k-1) &gt; 0) {
            fast = fast.next;
            k--;
        }
        while (fast.next != null) {
            fast = fast.next;
            slow = slow.next;
        }
        return slow.val;
    }
}</code></pre> 
</div> 
<h2 id="%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E7%9A%84%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%C2%A0">快慢指针的原理分析 </h2> 
<p>通过这两题，我们来分析快慢指针的原理。</p> 
<p>链表的中间节点 —— 假设有两个人在同一时间赛跑，fast是slow的速度的二倍，当fast到达终点时，这个slow就会在这个总路程的一半处。因此就可以得出中间节点的位置。</p> 
<p>返回倒数第k个节点 —— fast先走k-1步，那么fast与slow就相差k-1步，当两者一起走，并且fast走到了终点时，这时fast与slow还是相差k-1步，那么这个slow就是倒数第k个节点（因为fast的位置是倒数第一个节点）。</p> 
<h2 id="21.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><a href="https://leetcode.cn/problems/merge-two-sorted-lists/" rel="nofollow" title="21. 合并两个有序链表">21. 合并两个有序链表</a></h2> 
<blockquote> 
 <p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <div> 
  <p><img alt="" height="302" src="https://images2.imgbox.com/c8/93/3Tx7PwLZ_o.jpg" width="662">​</p> 
 </div> 
 <pre><strong>输入：</strong>l1 = [1,2,4], l2 = [1,3,4]
<strong>输出：</strong>[1,1,2,3,4,4]
</pre> 
 <p><strong>示例 2：</strong></p> 
 <pre><strong>输入：</strong>l1 = [], l2 = []
<strong>输出：</strong>[]
</pre> 
 <p><strong>示例 3：</strong></p> 
 <pre><strong>输入：</strong>l1 = [], l2 = [0]
<strong>输出：</strong>[0]

</pre> 
 <p><strong>提示：</strong></p> 
 <ul><li>两个链表的节点数目范围是 <code>[0, 50]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul> 
</blockquote> 
<p>思路：创建一个新的带头链表。通过遍历两个链表，比较两者的大小，将 小的val值 对应的节点尾插到这个带头链表中，直至有一方节点结束，再把另一方的节点直接尾插到新链表即可。</p> 
<div> 
 <pre><code class="language-java">class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        // 当list1为空或者list1与list2都为空时，直接返回list2
        if (list1 == null) {
            return list2;
        }
        if (list2 == null) {
            return list1;
        }
        // 创建一个新的头节点
        ListNode head = new ListNode(-1);
        ListNode cur = head;
        ListNode cur1 = list1;
        ListNode cur2 = list2;
        while (cur1 != null &amp;&amp; cur2 != null) {
            if (cur1.val &gt; cur2.val) {
                // 尾插cur2
                cur.next = cur2;
                cur2 = cur2.next;
            }else {
                // 尾插cur1
                cur.next = cur1;
                cur1 = cur1.next;
            }
            // 因为这一行代码无论走哪里，都会进行，因此放到外边来
            cur = cur.next;
        }
        // 还有一方还剩节点
        if (cur1 != null) {
            // 尾插cur1就行了，因为原来就是链表，因此不用循环
            cur.next = cur1;
        }
        if (cur2 != null) {
            // 尾插cur2就行了，因为原来就是链表，因此不用循环
            cur.next = cur2;
        }
        return head.next;
    }
}</code></pre> 
</div> 
<h2 id="%E7%89%9B%E5%AE%A2%E7%BD%91%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9B%9E%E6%96%87"><a href="https://www.nowcoder.com/practice/d281619e4b3e4a60a2cc66ea32855bfa?tpId=49&amp;&amp;tqId=29370&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/2016test/question-ranking" rel="nofollow" title="牛客网——链表的回文">牛客网——链表的回文</a></h2> 
<blockquote> 
 <p><strong>描述</strong></p> 
 <p>对于一个链表，请设计一个时间复杂度为O(n),额外空间复杂度为O(1)的算法，判断其是否为回文结构。</p> 
 <p>给定一个链表的头指针<strong>A</strong>，请返回一个bool值，代表其是否为回文结构。保证链表长度小于等于900。</p> 
 <p>测试样例：</p> 
 <pre>1-&gt;2-&gt;2-&gt;1</pre> 
 <pre>返回：true
</pre> 
</blockquote> 
<p>思路：虽然描述很简洁，但是难度却是比较大的一题。按照我们以往写回文的思路，就是定义一个left 和 right 指针指向两头，遍历比较。遇到不相等的就直接返回false，遍历完就返回true。但很可惜这题是单链表不能够反向遍历。既然不能直接反向遍历，那么我们就把这个后面的链表反转一下，变成可以反向遍历的情况。那问题又来了：从哪里开始反转呢？我们想一下，普通回文遍历的结束条件是left &lt; right ，也就是两者相遇或者说是到了中间位置就可以停止了。那么我们这里的反转也就可以从中间位置开始。反转完，之后就可比较了。因此，最终要做的事情就是：</p> 
<p>1. 找到链表的中间节点；</p> 
<p>2. 从中间位置开始反转；</p> 
<p>3. 从两头开始遍历比较。</p> 
<p>下面是反转的具体分析过程：</p> 
<p><img alt="" height="698" src="https://images2.imgbox.com/12/43/r4XXfgG0_o.png" width="1200">​</p> 
<div> 
 <pre><code class="language-java">public class PalindromeList {
    public boolean chkPalindrome(ListNode A) {
        // 当链表为空或者只有一个节点时，必回文
        if (A == null || A.next == null) {
            return true;
        }
        // 找到中间节点
        ListNode fast = A;
        ListNode slow = A;
        while (fast != null &amp;&amp; fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        ListNode cur = slow.next;
        // 从中间节点往后反转
        // 当slow走到尾节点时，就可以不必再继续了
        while (cur != null) {
            ListNode curNext = cur.next;
            cur.next = slow;
            slow = cur;
            cur = curNext;
        }
        // 开始遍历回文
        // 这里不要用fast，因为fast可能不在尾节点
        while (A != slow) {
            if (A.val != slow.val) {
                return false;
            }
            // 当链表长度为偶数时，会出现一种情况（后面细说）
            if (A.next == slow) {
                return true;
            }
            A = A.next;
            slow = slow.next; 
        }
        return true;
    }
}</code></pre> 
</div> 
<p><img alt="" height="1088" src="https://images2.imgbox.com/a0/da/6X4fGvPv_o.png" width="1200">​</p> 
<p>反转也不能写成下面这样：</p> 
<div> 
 <pre><code class="language-java">    while (slow.next != null) {
            ListNode cur = slow.next;
            ListNode curNext = cur.next;
            cur.next = slow;
            slow = cur;
            cur = curNext;
        }</code></pre> 
</div> 
<p>上面的代码会陷入死循环。因为在最后修改了 slow 的位置，变成了 cur，所以 slow.next 是指向的位置是原来的 slow 。因此最终就陷入了死循环。如下图：</p> 
<p><img alt="" height="1044" src="https://images2.imgbox.com/2d/ce/Zw3B5pc8_o.png" width="1200">​</p> 
<p>最后，我们会发现其实改来改去最终都在兜圈子。 </p> 
<p>综上本题来看，难度确实是挺大的，要注意的细节也是挺多的，无愧于 字节跳动 的秋招笔试题。 </p> 
<h2 id="%E7%89%9B%E5%AE%A2%E7%BD%91%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8%E5%88%86%E5%89%B2"><a class="link-info" href="https://www.nowcoder.com/practice/0e27e0b064de4eacac178676ef9c9d70?tpId=8&amp;&amp;tqId=11004&amp;rp=2&amp;ru=/activity/oj&amp;qru=/ta/cracking-the-coding-interview/question-ranking" rel="nofollow" title="牛客网——链表分割">牛客网——链表分割</a></h2> 
<blockquote> 
 <p><strong>描述</strong></p> 
 <p>现有一链表的头指针 ListNode* <strong>pHead</strong>，给一定值x，编写一段代码将所有小于x的结点排在其余结点之前，且不能改变原来的数据顺序，返回重新排列后的链表的头指针。</p> 
</blockquote> 
<p>思路：既然要分割链表，那我们直接按照原来的链表顺序遍历，把小于 x 的节点放到小链表中，其余节点放到大链表中。 </p> 
<p>我们就会不假思索的写出下面的代码：</p> 
<pre><code class="language-java">public class Partition {
    public ListNode partition(ListNode pHead, int x) {
        // 这题比较虾仁猪心：思路简单，但细节很多
        // 如果链表为空或者链表只有一个节点，就直接返回该节点
        if (pHead == null || pHead.next == null) {
            return pHead;
        }
        // 为了更为方便，我们定义头节点和尾节点
        ListNode beforeStart = null;
        ListNode beforeEnd = null;
        ListNode afterStart = null;
        ListNode afterEnd = null;
        // 遍历链表，小于放一边，大于放一边，然后小的串大的
        while (pHead != null) {
            if (pHead.val &lt; x) {
                // 尾插到小链表中
                if (beforeStart == null) {
                    beforeStart = pHead;
                    beforeEnd = pHead;
                } else {
                    beforeEnd.next = pHead;
                    beforeEnd = beforeEnd.next;
                }
            } else {
                // 尾插到大链表中
                if (afterStart == null) {
                    afterStart = pHead;
                    afterEnd = pHead;
                } else {
                    afterEnd.next = pHead;
                    afterEnd = afterEnd.next;
                }
            }
            pHead = pHead.next;
        }
        beforeEnd.next = afterStart;
        return beforeStart;
    }
}</code></pre> 
<p>但上面的代码在测试的时候，会抛出空指针异常。其实就是当小链表为空（链表中所有的值均大于 x）时，这个 beforeStart 为空，那么去访问其 next 值时，就会发生空指针异常。因此，当小链表为空时，直接返回大链表，当大链表为空时，直接返回小链表即可。但很遗憾，又出现了死循环的问题：如下图所示：</p> 
<p><img alt="" height="1147" src="https://images2.imgbox.com/7d/fd/xzB9Zw8b_o.png" width="1200"></p> 
<p>因此，我们还得把 afterEnd 的 next 置为null。 通过一系列的纠正，最终的代码如下：</p> 
<pre><code class="language-java">public class Partition {
    public ListNode partition(ListNode pHead, int x) {
        // 这题比较虾仁猪心：思路简单，但细节很多
        // 如果链表为空或者链表只有一个节点，就直接返回该节点
        if (pHead == null || pHead.next == null) {
            return pHead;
        }
        // 为了更为方便，我们定义头节点和尾节点
        ListNode beforeStart = null;
        ListNode beforeEnd = null;
        ListNode afterStart = null;
        ListNode afterEnd = null;
        // 遍历链表，小于放一边，大于放一边，然后小的串大的
        while (pHead != null) {
            if (pHead.val &lt; x) {
                // 尾插到小链表中
                if (beforeStart == null) {
                    beforeStart = pHead;
                    beforeEnd = pHead;
                } else {
                    beforeEnd.next = pHead;
                    beforeEnd = beforeEnd.next;
                }
            } else {
                // 尾插到大链表中
                if (afterStart == null) {
                    afterStart = pHead;
                    afterEnd = pHead;
                } else {
                    afterEnd.next = pHead;
                    afterEnd = afterEnd.next;
                }
            }
            pHead = pHead.next;
        }
        
        // 把小链表和大链表串起来
        if (beforeEnd == null) {
            // 如果小链表为空，那么就直接返回大链表
            // 那么大链表就是按照原来链表的顺序，即无需将最后节点的next置为null
            return afterStart;
        }
        if (afterStart == null) {
            return beforeStart;
        }
        beforeEnd.next = afterStart;
        afterEnd.next = null;
        return beforeStart;
    }
}</code></pre> 
<p>这题虽然思路简单，但要注意的细节很多，稍一疏忽，就会犯错。简直就是：虾仁猪心 。</p> 
<h2 id="160.%20%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><a class="link-info" href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/" rel="nofollow" title="160. 相交链表">160. 相交链表</a></h2> 
<blockquote> 
 <p style="margin-left:0;"><span style="color:#262626;"><span style="background-color:#f0f0f0;">给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</span></span></p> 
 <p style="margin-left:0;"><span style="color:#262626;"><span style="background-color:#f0f0f0;">图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></span></span></p> 
 <p style="margin-left:0;"></p> 
 <p class="img-center"><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" rel="nofollow"><img alt="" height="241" src="https://images2.imgbox.com/a9/54/COjXPZBB_o.png" width="742"></a></p> 
 <p style="margin-left:0;"><span style="color:#262626;"><span style="background-color:#f0f0f0;">题目数据 <strong>保证</strong> 整个链式结构中不存在环。</span></span></p> 
 <p style="margin-left:0;"><span style="color:#262626;"><span style="background-color:#f0f0f0;"><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</span></span></p> 
 <p style="margin-left:0;"><span style="color:#262626;"><span style="background-color:#f0f0f0;"><strong>自定义评测：</strong></span></span></p> 
 <p style="margin-left:0;"><span style="color:#262626;"><span style="background-color:#f0f0f0;"><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</span></span></p> 
 <ul><li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li><li><code>listA</code> - 第一个链表</li><li><code>listB</code> - 第二个链表</li><li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li><li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li></ul> 
 <p style="margin-left:0;"><span style="color:#262626;"><span style="background-color:#f0f0f0;">评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</span></span></p> 
 <p style="margin-left:0;"><span style="color:#262626;"><span style="background-color:#f0f0f0;"> </span></span></p> 
 <p style="margin-left:0;"><span style="color:#262626;"><span style="background-color:#f0f0f0;"><strong>示例 1：</strong></span></span></p> 
 <p style="margin-left:0;"></p> 
 <p class="img-center"><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png" rel="nofollow"><img alt="" height="241" src="https://images2.imgbox.com/27/f3/mBe5kJjM_o.png" width="742"></a></p> 
 <pre style="margin-left:0;"><span style="background-color:#f0f0f0;"><strong>输入：</strong>intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
<strong>输出：</strong>Intersected at '8'
<strong>解释：</strong>相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。
</span>
</pre> 
 <p style="margin-left:0;"><span style="color:#262626;"><span style="background-color:#f0f0f0;"><strong>示例 2：</strong></span></span></p> 
 <p style="margin-left:0;"></p> 
 <p class="img-center"><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png" rel="nofollow"><img alt="" height="241" src="https://images2.imgbox.com/9b/ea/ghyvwYG3_o.png" width="622"></a></p> 
 <pre style="margin-left:0;"><span style="background-color:#f0f0f0;"><strong>输入：</strong>intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
<strong>输出：</strong>Intersected at '2'
<strong>解释：</strong>相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
</span></pre> 
 <p style="margin-left:0;"><span style="color:#262626;"><span style="background-color:#f0f0f0;"><strong>示例 3：</strong></span></span></p> 
 <p style="margin-left:0;"></p> 
 <p class="img-center"><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png" rel="nofollow"><img alt="" height="241" src="https://images2.imgbox.com/5c/ea/Eizss1vt_o.png" width="382"></a></p> 
 <pre style="margin-left:0;"><span style="background-color:#f0f0f0;"><strong>输入：</strong>intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
<strong>输出：</strong>null
<strong>解释：</strong>从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。
</span>
</pre> 
 <p style="margin-left:0;"><span style="color:#262626;"><span style="background-color:#f0f0f0;"><strong>提示：</strong></span></span></p> 
 <ul><li><code>listA</code> 中节点数目为 <code>m</code></li><li><code>listB</code> 中节点数目为 <code>n</code></li><li><code>1 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li></ul> 
</blockquote> 
<p>思路： 两个链表相交，有一个特点就是：相交之后的链表长度一定是相同的。假设前面不相交的长度是想等的，定义一个 cur1 指向一个链表，定义一个 cur2 指向另一个链表，去遍历两个链表，当两者不相等时，就一直遍历，直至相等为止。但遗憾的是两者长度会出现不一样的情况，这里依然是使用快慢指针的方法。当长度不相等时，就让 长度长的链表 先走 两者的差值步数，然后再一起走，那么最终的结果一定是两者一起走到相等或者两者走到都为 null。最终的步骤：</p> 
<p>1、先算出两者的长度，求其长度差。</p> 
<p>2、再让长度长的链表走长度差步</p> 
<p>3、接着两者一起走，判断是否相等</p> 
<pre><code class="language-java">public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        // 先算出各自长度，让长的链表走两者长度的差值步，再一起走，如果相遇则其相交。
        ListNode cur1 = headA;
        ListNode cur2 = headB;
        int len1 = 0;
        int len2 = 0;
        while (cur1 != null) {
            len1++;
            cur1 = cur1.next;
        }
        while (cur2 != null) {
            len2++;
            cur2 = cur2.next;
        }
        if (len1 &gt; len2) {
            // 让headA走差值步
            cur1 = headA;
            cur2 = headB;
            int len = len1 - len2;
            while (len-- &gt; 0) {
                cur1 = cur1.next;
            }
            // 开始比较
            while (cur1 != cur2) {
                cur1 = cur1.next;
                cur2 = cur2.next;
            }
            // 走到这里，有两种情况：1、cur1与cur2 都为空了，跳出了循环
            // 2、两者确实是相遇了。 我们只需判断一下即可
            if (cur1 == null) {
                return null;
            }
            // 其实这里不判断，也可以运行通过，因为题目要求不相遇就返回null，
            // 而比较到null时，cur1也是null，所以返回cur1也是对的（碰巧）。
            return cur1;
        }else {
            // 让headB走差值步
            cur1 = headA;
            cur2 = headB;
            int len = len2 - len1;
            while (len-- &gt; 0) {
                cur2 = cur2.next;
            }
            // 开始比较
            while (cur1 != cur2) {
                cur1 = cur1.next;
                cur2 = cur2.next;
            }
            // 走到这里，有两种情况：1、cur1与cur2 都为空了，跳出了循环
            // 2、两者确实是相遇了。 我们只需判断一下即可
            if (cur1 == null) {
                return null;
            }
            // 其实这里不判断，也可以运行通过，因为题目要求不相遇就返回null，
            // 而比较到null时，cur1也是null，所以返回cur1也是对的（碰巧）。
            return cur1;
        }
    }
}</code></pre> 
<p>上面的代码在后面一起走的部分中大部分代码是一致的，因此就可以简化为下面这样：</p> 
<pre><code class="language-java">public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        // 先算出各自长度，让长的链表走两者长度的差值步，再一起走，如果相遇则其相交。
        ListNode cur1 = headA;
        ListNode cur2 = headB;
        int len1 = 0;
        int len2 = 0;
        while (cur1 != null) {
            len1++;
            cur1 = cur1.next;
        }
        while (cur2 != null) {
            len2++;
            cur2 = cur2.next;
        }
        // 假设headA为长链表
        int len = len1-len2;
        cur1 = headA;
        cur2 = headB;
        if (len &lt; 0) {
            // 说明headB是长链表
            len = - len;
            cur1 = headB;
            cur2 = headA;
        }
        // 走到这里，长链表一定已经确定了
        while (len-- &gt; 0) {
            cur1 = cur1.next;
        }
        while (cur1 != cur2) {
            cur1 = cur1.next;
            cur2 = cur2.next;
        }
        if (cur1 == null) {
            return null;
        }
        return cur1;
    }
}</code></pre> 
<h2 id="%C2%A0141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8" style="background-color:transparent;"> <a class="link-info" href="https://leetcode.cn/problems/linked-list-cycle/" rel="nofollow" title="141. 环形链表">141. 环形链表</a></h2> 
<blockquote> 
 <p></p> 
 <p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p> 
 <p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递 </strong>。仅仅是为了标识链表的实际情况。</p> 
 <p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <p></p> 
 <p class="img-center"><img alt="" height="171" src="https://images2.imgbox.com/b0/05/nB71v6f1_o.png" width="531"></p> 
 <pre><strong>输入：</strong>head = [3,2,0,-4], pos = 1
<strong>输出：</strong>true
<strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。
</pre> 
 <p><strong>示例 2：</strong></p> 
 <p></p> 
 <p class="img-center"><img alt="" height="105" src="https://images2.imgbox.com/16/54/XV25UAdN_o.png" width="201"></p> 
 <pre><strong>输入：</strong>head = [1,2], pos = 0
<strong>输出：</strong>true
<strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。
</pre> 
 <p><strong>示例 3：</strong></p> 
 <p></p> 
 <p class="img-center"><img alt="" height="65" src="https://images2.imgbox.com/b8/d6/H0MNnaVw_o.png" width="65"></p> 
 <pre><strong>输入：</strong>head = [1], pos = -1
<strong>输出：</strong>false
<strong>解释：</strong>链表中没有环。

</pre> 
 <p><strong>提示：</strong></p> 
 <ul><li>链表中节点的数目范围是 <code>[0, 104]</code></li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li></ul> 
</blockquote> 
<p>思路：快慢指针。当一个链表没有环，那么肯定是快指针先走到终点，如果一个链表有环，则快指针会先入环，接着慢指针再入环，最终快慢指针会相遇（一定是快指针走两步，慢指针走一步，这样快指针才不会包含慢指针）。如果快指针走三步，就有可能出现慢指针一直在快指针中间的情况。</p> 
<pre><code class="language-java">public class Solution {
    public boolean hasCycle(ListNode head) {
        // 如果链表为空或者链表的第一个节点的next为空，则说明没有成环
        if (head == null || head.next == null) {
            return false;
        }
        ListNode fast = head;
        ListNode slow = head;
        // 快指针如果遇到结尾的情况就可以停止了
        while (fast != null &amp;&amp; fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            // 一定要走完才能判断
            if (fast == slow) {
                return true;
            }
        }
        return false;
    }
}</code></pre> 
<p>其实，我们仔细观察会发现：在快指针还没开始走的时候，while循环的判断条件和前面的if判断条件是一样的，都是判断链表是否为空或者是链表的第一个节点的 next 值是是否为空。</p> 
<pre><code class="language-java">public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        // 快指针如果遇到结尾的情况就可以停止了
        while (fast != null &amp;&amp; fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            // 一定要走完才能判断
            if (fast == slow) {
                return true;
            }
        }
        return false;
    }
}</code></pre> 
<h2 id="142.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II" style="background-color:transparent;"><a class="link-info" href="https://leetcode.cn/problems/linked-list-cycle-ii/description/" rel="nofollow" title="142. 环形链表 II">142. 环形链表 II</a></h2> 
<blockquote> 
 <p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p> 
 <p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p> 
 <p><strong>不允许修改 </strong>链表。</p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <p></p> 
 <p class="img-center"><img alt="" height="171" src="https://images2.imgbox.com/fd/80/AzjVbyA4_o.png" width="531"></p> 
 <pre><strong>输入：</strong>head = [3,2,0,-4], pos = 1
<strong>输出：</strong>返回索引为 1 的链表节点
<strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。
</pre> 
 <p><strong>示例 2：</strong></p> 
 <p></p> 
 <p class="img-center"><img alt="" height="105" src="https://images2.imgbox.com/9b/71/f8wNWPGy_o.png" width="201"></p> 
 <pre><strong>输入：</strong>head = [1,2], pos = 0
<strong>输出：</strong>返回索引为 0 的链表节点
<strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。
</pre> 
 <p><strong>示例 3：</strong></p> 
 <p></p> 
 <p class="img-center"><img alt="" height="65" src="https://images2.imgbox.com/1f/f9/sSoMvHvg_o.png" width="65"></p> 
 <pre><strong>输入：</strong>head = [1], pos = -1
<strong>输出：</strong>返回 null
<strong>解释：</strong>链表中没有环。
</pre> 
 <p></p> 
 <p><strong>提示：</strong></p> 
 <ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul> 
</blockquote> 
<p>思路： 这个题目的意思就是让我们找到链表的第一个成环的节点。如下图所示：</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/0b/2f/C2k0E8OL_o.png" width="1200"></p> 
<p>上面那种情况只是我们认为的理想情况：慢指针入环时，快指针刚好只走完一圈，但是实际走完几圈我们是不确定的，因此可以设 n 为快指针走的圈数，带入求解的结果就是：x = n*m - y = (n-1)*m + (m-y)，最终结果还是我们前面的结论。因为 (n-1)只是圈数，最终还是会停在这个相遇点。</p> 
<p>这里最重要的是抓住：快指针走的路程是慢指针的两倍。 </p> 
<p>1、找到相遇点</p> 
<p>2、慢指针从头走，快指针从相遇点走，都以相同的速度。</p> 
<pre><code class="language-java">public class Solution {
    public ListNode detectCycle(ListNode head) {
        // 找到相遇点
        ListNode fast = head;
        ListNode slow = head;
        while (fast != null &amp;&amp; fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            // 相遇就停下来
            if (slow == fast) {
                break;
            }
        }
        // 链表里没有环的情况有几种：
        if (fast != slow || head == null || head.next == null) {
            // 说明没有环
            return null;
        }
        // slow从链表头开始走，fast从相遇点开始走
        slow = head;
        while (slow != fast) {
            fast = fast.next;
            slow =slow.next;
        }
        return slow;
    }
}</code></pre> 
<p>因为这里在相遇之后，还要执行代码，就必须要判断链表是否为空和只有一个节点无环的情况。 </p> 
<p>好啦！本期 数据结构之链表的经典笔试题 的学习之旅就到此结束啦！我们下一期再一起学习吧！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/04b4f09655feda50b4678f54eeddcbff/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">大数据-11-案例演习-淘宝双11数据分析与预测 （期末问题）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/549168f3ded9905784b8e8ab851a8b1b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">LVS&#43;KeepAlived高可用负载均衡集群</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>