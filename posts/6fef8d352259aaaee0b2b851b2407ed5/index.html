<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;入门基础 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/6fef8d352259aaaee0b2b851b2407ed5/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C&#43;&#43;入门基础">
  <meta property="og:description" content="目录
1.C&#43;&#43;的第一个程序
2.命名空间 2.1namespace的价值
2.2namespace的定义
2.3命名空间的使用
3.C&#43;&#43;中的输入和输出
4.缺省参数
5.函数重载
6.引用
6.1引用的概念和定义
6.2引用的特性
6.3引用的使用
6.4const引用
6.5指针和引用的关系
7.inline
8.nullptr
1.C&#43;&#43;的第一个程序 首先说明，C&#43;&#43;兼容C语言绝大多数的语法，所以C语言实现的代码在C&#43;&#43;的编译器中绝大部分也能运行，C&#43;&#43;中需要把定义文件代码后缀改为.cpp，vs编译器看到是.cpp就会调⽤C&#43;&#43;编译器编译，linux下要⽤g&#43;&#43;编译，不再是gcc。
C语言版本的hello world
// test.c #include&lt;stdio.h&gt; int main() { printf(&#34;hello world\n&#34;); return 0; } C&#43;&#43;版本的hello world
// test.cpp #include&lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; &#34;hello world\n&#34; &lt;&lt; endl; return 0; } 2.命名空间 2.1namespace的价值 在C/C&#43;&#43;中，变量、函数和后⾯要学到的类都是⼤量存在的，这些变量、函数和类的名称将都存在于全局作⽤域中，可能会导致很多冲突。使⽤命名空间的⽬的是对标识符的名称进⾏本地化，以避免命名冲突或名字污染，namespace关键字的出现就是针对这种问题的。
#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; namespace xiaoc { int rand = 10; } int main() { printf(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-13T14:20:44+08:00">
    <meta property="article:modified_time" content="2024-08-13T14:20:44+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;入门基础</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.C%2B%2B%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F-toc" style="margin-left:0px;"><a href="#1.C%2B%2B%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F" rel="nofollow">1.C++的第一个程序</a></p> 
<p id="2.%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%C2%A0-toc" style="margin-left:0px;"><a href="#2.%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%C2%A0" rel="nofollow">2.命名空间 </a></p> 
<p id="2.1namespace%E7%9A%84%E4%BB%B7%E5%80%BC-toc" style="margin-left:40px;"><a href="#2.1namespace%E7%9A%84%E4%BB%B7%E5%80%BC" rel="nofollow">2.1namespace的价值</a></p> 
<p id="2.2namespace%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#2.2namespace%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">2.2namespace的定义</a></p> 
<p id="2.3%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#2.3%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">2.3命名空间的使用</a></p> 
<p id="3.C%2B%2B%E4%B8%AD%E7%9A%84%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA-toc" style="margin-left:0px;"><a href="#3.C%2B%2B%E4%B8%AD%E7%9A%84%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA" rel="nofollow">3.C++中的输入和输出</a></p> 
<p id="4.%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0-toc" style="margin-left:0px;"><a href="#4.%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0" rel="nofollow">4.缺省参数</a></p> 
<p id="5.%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD-toc" style="margin-left:0px;"><a href="#5.%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD" rel="nofollow">5.函数重载</a></p> 
<p id="6.%E5%BC%95%E7%94%A8-toc" style="margin-left:0px;"><a href="#6.%E5%BC%95%E7%94%A8" rel="nofollow">6.引用</a></p> 
<p id="6.1%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#6.1%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%9A%E4%B9%89" rel="nofollow">6.1引用的概念和定义</a></p> 
<p id="6.2%E5%BC%95%E7%94%A8%E7%9A%84%E7%89%B9%E6%80%A7-toc" style="margin-left:40px;"><a href="#6.2%E5%BC%95%E7%94%A8%E7%9A%84%E7%89%B9%E6%80%A7" rel="nofollow">6.2引用的特性</a></p> 
<p id="6.3%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#6.3%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">6.3引用的使用</a></p> 
<p id="6.4const%E5%BC%95%E7%94%A8-toc" style="margin-left:40px;"><a href="#6.4const%E5%BC%95%E7%94%A8" rel="nofollow">6.4const引用</a></p> 
<p id="6.5%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%85%B3%E7%B3%BB-toc" style="margin-left:40px;"><a href="#6.5%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%85%B3%E7%B3%BB" rel="nofollow">6.5指针和引用的关系</a></p> 
<p id="7.inline-toc" style="margin-left:0px;"><a href="#7.inline" rel="nofollow">7.inline</a></p> 
<p id="8.nullptr-toc" style="margin-left:0px;"><a href="#8.nullptr" rel="nofollow">8.nullptr</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2>1.C++的第一个程序</h2> 
<p>        <span style="color:#0d0016;"><strong>首先说明，C++兼容C语言绝大多数的语法，所以C语言实现的代码在C++的编译器中绝大部分也能运行，C++中需要把定义文件代码后缀改为.cpp，vs编译器看到是.cpp就会调⽤C++编译器编译，linux下要⽤g++编译，不再是gcc。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>       </strong> C语言版本的hello world</span></p> 
<pre><code class="language-cpp">// test.c
#include&lt;stdio.h&gt;
int main()
{
    printf("hello world\n");
    return 0;
}</code></pre> 
<p>        C++版本的hello world</p> 
<pre><code class="language-cpp">// test.cpp
#include&lt;iostream&gt;
using namespace std;

int main()
{
    cout &lt;&lt; "hello world\n" &lt;&lt; endl;
    return 0;
}</code></pre> 
<h2 id="2.%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%C2%A0">2.命名空间 </h2> 
<h3 id="2.1namespace%E7%9A%84%E4%BB%B7%E5%80%BC">2.1namespace的价值</h3> 
<p>        <span style="color:#1f2329;">在C/C++中，变量、函数和后⾯要学到的类都是⼤量存在的，这些变量、函数和类的名称将都存在于全局作⽤域中，可能会导致很多冲突。<strong>使⽤命名空间的⽬的是对标识符的名称进⾏本地化，以避免命名冲突或名字污染，</strong>namespace关键字的出现就是针对这种问题的。</span></p> 
<pre><code class="language-cpp">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;


namespace xiaoc
{
	int rand = 10; 
}

int main()
{
	printf("%p\n", rand); //stdlib.h中的rand函数
	printf("%d\n", xiaoc::rand);    //xiaoc命名空间中的rand

	return 0;
}</code></pre> 
<p>        使用命名空间就可以避免命名冲突等问题。 </p> 
<h3 id="2.2namespace%E7%9A%84%E5%AE%9A%E4%B9%89">2.2namespace的定义</h3> 
<p>（1）<span style="color:#1f2329;">定义命名空间，<strong>需要使⽤到namespace关键字，后⾯跟命名空间的名字，然后接⼀对{}即可，{}中即为命名空间的成员。命名空间中可以定义变量/函数/类型等</strong>。如上述代码中xiaoc这个命名空间。</span></p> 
<p>(2)<span style="color:#1f2329;">namespace本质是定义出⼀个域，这个域跟全局域各⾃独⽴，<strong>不同的域可以定义同名变量</strong>，所以上⾯的rand不在冲突了。 </span></p> 
<p><span style="color:#1f2329;">(3)</span><span style="color:#1f2329;"><strong>C++中域有函数局部域，全局域，命名空间域，类域</strong>；域影响的是编译时语法查找⼀个变量/函数/类型出处(声明或定义)的逻辑，所有有了域隔离，名字冲突就解决了。局部域和全局域除了会影响编译查找逻辑，还会影响变量的⽣命周期，<strong>命名空间域和类域不影响变量⽣命周期(定义在其中的生命周期和全局域中的变量一样)。</strong></span></p> 
<p>(4)<span style="color:#1f2329;">namespace只能定义在全局，但是他还可以嵌套定义。</span></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
namespace xiaoc
{
	//1
	namespace xiaoc1
	{
		int rand = 1;
		int Add(int left, int right)
		{
			return left + right;
		}
	}
	//2
	namespace xiaoc2
	{
		int rand = 2;
		int Add(int left, int right)
		{
			return (left + right) * 10;
		}
	}
}

int main()
{
	//用xiaoc1的Add
	cout &lt;&lt; xiaoc::xiaoc1::Add(1, 2) &lt;&lt; endl;
	//用xiaoc2的Add
	cout &lt;&lt; xiaoc::xiaoc2::Add(1, 2) &lt;&lt; endl;

	return 0;
}</code></pre> 
<p>(5)项目工程中多文件中定义的同名namespace会认为是一个namespace，不会冲突。</p> 
<p>(6)<strong><span style="color:#1f2329;">C++标准库都放在⼀个叫std(standard)的命名空间中。</span></strong></p> 
<h3 id="2.3%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E4%BD%BF%E7%94%A8"><span style="color:#1f2329;">2.3命名空间的使用</span></h3> 
<p>(1)指定命名空间访问，项⽬中推荐这种⽅式。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

namespace xiaoc
{
	int a = 0;
	int b = 1;
}
//指定命名空间访问
int main()
{
	cout &lt;&lt; xiaoc::a &lt;&lt; " " &lt;&lt; xiaoc::b &lt;&lt; endl;
	return 0;
}</code></pre> 
<p>(2)<span style="color:#1f2329;">using将命名空间中某个成员展开，项⽬中经常访问的不存在冲突的成员推荐这种⽅式。</span></p> 
<pre><code class="language-cpp">//using将命名空间中某个成员展开
using xiaoc::a;
int main()
{
	cout &lt;&lt; a &lt;&lt; endl;
	return 0;
}</code></pre> 
<p>(3) <span style="color:#1f2329;">展开命名空间中全部成员，项⽬不推荐，冲突⻛险很⼤，⽇常⼩练习程序为了⽅便推荐使⽤。 </span></p> 
<pre><code class="language-cpp">//展开命名空间中全部成员
using namespace xiaoc;
int main()
{
	cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl;
	return 0;
}</code></pre> 
<h2 id="3.C%2B%2B%E4%B8%AD%E7%9A%84%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA">3.C++中的输入和输出</h2> 
<p>(1) <span style="color:#1f2329;">&lt;iostream&gt;头文件是 Input Output Stream 的缩写，是标准的输⼊、输出流库，定义了标准的输⼊、输出对象。</span></p> 
<p>(2)<span style="color:#1f2329;">std::cin 是 istream 类的对象，它主要⾯向窄字符的标准输⼊流。std::cout 是 ostream 类的对象，它主要⾯向窄字符的标准输出流。</span></p> 
<p><span style="color:#1f2329;">(3)</span><span style="color:#1f2329;">std::endl 是⼀个函数，流插⼊输出时，相当于插⼊⼀个换⾏字符加入刷新缓冲区。</span></p> 
<p><span style="color:#1f2329;">(4)&lt;&lt;是流插⼊运算符，&gt;&gt;是流提取运算符。（C语⾔还⽤这两个运算符做位运算左移/右移）。</span></p> 
<p><strong>(5)<span style="color:#1f2329;">C++的输⼊输出可以⾃动识别变量类型(本质是通过函数重载实现的)，其实最重要的是C++的流能更好的⽀持⾃定义类型对象的输⼊输出。</span></strong></p> 
<p><span style="color:#1f2329;">(6)cout/cin/endl等都属于C++标准库，C++标准库都放在⼀个叫std(standard)的命名空间中，所以要通过命名空间的使⽤⽅式去⽤他们。 </span></p> 
<p><strong><span style="color:#1f2329;">(7)我们没有包含&lt;stdio.h&gt;，也可以使⽤printf和scanf，在包含&lt;iostream&gt;间接包含了。vs系列 编译器是这样的，其他编译器可能会报错。</span></strong></p> 
<pre><code class="language-cpp">//c++的输入输出
#include &lt;iostream&gt;
using namespace std;

int main()
{
	int a = 0;
	double b = 0.1;
	char c = 'a';

	//C语言的输出
	printf("%d %lf %c\n", a, b, c);

	//c++的输出
	cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; " " &lt;&lt; c &lt;&lt; endl;
	return 0;
}</code></pre> 
<h2 id="4.%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0">4.缺省参数</h2> 
<p>(1) <span style="color:#1f2329;"><strong>缺省参数是声明或定义函数时为函数的参数指定⼀个缺省值。</strong>在调⽤该函数时，<strong>如果没有指定实参则采⽤该形参的缺省值，否则使⽤指定的实参</strong>，缺省参数分为全缺省和半缺省参数。（有些地⽅把缺省参数也叫默认参数）。</span></p> 
<p><span style="color:#1f2329;">(2)</span><span style="color:#1f2329;">全缺省就是全部形参给缺省值，半缺省就是部分形参给缺省值。<strong>C++规定半缺省参数必须从右往左依次连续缺省，不能间隔跳跃给缺省值。</strong></span></p> 
<p>(3)<strong><span style="color:#1f2329;">带缺省参数的函数调⽤，C++规定必须从左到右依次给实参，不能跳跃给实参。</span></strong></p> 
<p>(4)<span style="color:#1f2329;">函数声明和定义分离时，缺省参数不能在函数声明和定义中同时出现，<strong>规定必须函数声明给缺省值(在.h文件中给缺省值)。</strong></span></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

//全缺省
void Func1(int a = 10, int b = 20, int c = 30) //全部参数都有默认值
{
	cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; endl;
	cout &lt;&lt; "c = " &lt;&lt; c &lt;&lt; endl &lt;&lt; endl;
}
// 半缺省
void Func2(int a, int b = 10, int c = 20)  //部分参数有默认值
{
	cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; endl;
	cout &lt;&lt; "c = " &lt;&lt; c &lt;&lt; endl &lt;&lt; endl;
}</code></pre> 
<h2 id="5.%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">5.函数重载</h2> 
<p><span style="color:#1f2329;">        <strong>C++⽀持在同⼀作⽤域中出现同名函数，但是要求这些同名函数的形参不同，可以是参数个数不同或者类型不同。</strong>这样C++函数调⽤就表现出了多态⾏为，使⽤更灵活。C语⾔是不⽀持同⼀作⽤域中出现同名函数的。 </span></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

//1.参数类型不同
int Add(int left, int right)
{
	cout &lt;&lt; "int Add(int left, int right)" &lt;&lt; endl;
	return left + right;
}
double Add(double left, double right)
{
	cout &lt;&lt; "double Add(double left, double right)" &lt;&lt; endl;
	return left + right;
}

//2.参数个数不同
void f()
{
	cout &lt;&lt; "f()" &lt;&lt; endl;
}
void f(int a)
{
	cout &lt;&lt; "f(int a)" &lt;&lt; endl;
}

//3.参数类型顺序不同，本质是类型不同
void f(int a, char b)
{
	cout &lt;&lt; "f(int a,char b)" &lt;&lt; endl;
}
void f(char b, int a)
{
	cout &lt;&lt; "f(char b, int a)" &lt;&lt; endl;
}

//4.返回值不同不能作为重载条件，因为调用时也无法区分
//void fxx()
//{}
//
//int fxx()
//{
// return 0;
//}

//5.下面两个函数构成重载,但是调用时不给实参使用默认参数会报错，存在歧义
//void f1()
//{
//	cout &lt;&lt; "f()" &lt;&lt; endl;
//}
//void f1(int a = 10)
//{
//	cout &lt;&lt; "f(int a)" &lt;&lt; endl;
//}</code></pre> 
<h2 id="6.%E5%BC%95%E7%94%A8">6.引用</h2> 
<h3 id="6.1%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%9A%E4%B9%89">6.1引用的概念和定义</h3> 
<p>         <strong><span style="color:#1f2329;">引⽤不是新定义⼀个变量，⽽是给已存在变量取了⼀个别名，编译器不会为引⽤变量开辟内存空间，它和它引⽤的变量共⽤同⼀块内存空间。</span></strong></p> 
<p><strong><span style="color:#1f2329;">        </span></strong><span style="color:#1f2329;">引用的格式为：<strong>类型&amp; 引⽤别名 = 引⽤对象; </strong></span></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main()
{
	int a = 10;
	int&amp; b = a;
	int&amp; c = b;

	cout &lt;&lt; &amp;a &lt;&lt; endl;
	cout &lt;&lt; &amp;b &lt;&lt; endl;
	cout &lt;&lt; &amp;c &lt;&lt; endl;

	c++;

	cout &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; b &lt;&lt; endl;
	cout &lt;&lt; c &lt;&lt; endl;


	return 0;
}</code></pre> 
<p class="img-center"><img alt="" height="179" src="https://images2.imgbox.com/18/8f/8VrQdZPw_o.png" width="980"></p> 
<p>        <strong>引用其实就是一个变量的别名，指向的空间和被引用的对象指向的空间相同，对引用进行改变也会改变被引用的对象。</strong> </p> 
<h3 id="6.2%E5%BC%95%E7%94%A8%E7%9A%84%E7%89%B9%E6%80%A7">6.2引用的特性</h3> 
<p>(1)引用在定义时必须初始化</p> 
<pre><code class="language-cpp">int main()
{
	int&amp; ra;     //引用时为初始化
    //编译报错：“ra”: 必须初始化引⽤
}</code></pre> 
<p>(2)一个变量可以有多个引用 </p> 
<pre><code class="language-cpp">int main()
{
	int a = 10;
	int&amp; b = a;
	int&amp; c = a;    //一个变量多个引用
}</code></pre> 
<p>(3) <span style="color:#1f2329;">引⽤⼀旦引⽤⼀个实体，再不能引⽤其他实体</span></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main()
{
	//int&amp; ra; 会报错

	int a = 10;

	int&amp; b = a;

	int c = 20;

	b = c; //这里不是b引用c，而是给b赋值.a和b还是同一块地址，c是另一块地址

	cout &lt;&lt; &amp;a &lt;&lt; endl;
	cout &lt;&lt; &amp;b &lt;&lt; endl;
	cout &lt;&lt; &amp;c &lt;&lt; endl;

	return 0;
}</code></pre> 
<p class="img-center"><img alt="" height="135" src="https://images2.imgbox.com/98/e8/QG6xEJuC_o.png" width="976"></p> 
<h3 id="6.3%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%BF%E7%94%A8">6.3引用的使用</h3> 
<p> (1)<span style="color:#1f2329;">在实践中主要是<strong>引⽤作传参和引⽤作返回值中减少拷⻉提⾼效率和改变引⽤对象时同时改变被引⽤对象。</strong> </span></p> 
<p>(2)<span style="color:#1f2329;">引⽤传参跟指针传参功能是类似的，引⽤传参相对更⽅便⼀些。 </span></p> 
<p><span style="color:#1f2329;">(3)引⽤和指针在实践中相辅相成，功能有重叠性，但是各有特点，互相不可替代。</span></p> 
<h3 id="6.4const%E5%BC%95%E7%94%A8"><span style="color:#1f2329;">6.4const引用</span></h3> 
<p><span style="color:#1f2329;">(1)<strong>可以引⽤⼀个const对象，但是必须⽤const引⽤。const引⽤也可以引⽤普通对象，因为对象的访问权限在引⽤过程中可以缩⼩，但是不能放⼤。</strong></span></p> 
<pre><code class="language-cpp"> //引用中的权限缩小和放大
int main()
{
	const int a = 10;

	int&amp; ra = a; //因为原本a变量是不能被修改的，但是引用没用const修饰，意为可以被修改的引用，存        //在权限放大，不能进行引用

	const int&amp; ra = a; //这样才是正确的
	//const修饰的变量具有常性，通过引用也不能修改值

	int b = 20;
	const int&amp; rb = b; //原本b可以被修改，用const修改的rb引用b，rb不能被修改，这样引用是权限缩
    //小，可以引用，但是不会影响b变量本身，所以可以对b变量本身进行赋值修改

	return 0;
}</code></pre> 
<p>(2)<span style="color:#1f2329;">不需要注意的是类似 (a)</span><span style="color:#1f2329;">int&amp; rb = a*3;   (a)double d = 12.34; int&amp; rd = d;</span></p> 
<p><span style="color:#1f2329;">        a场景下，<strong>引用的是一个表达式，表达式计算的结果会存储在一个临时变量中，在C++中规定临时变量具有常性，不能被修改，</strong>所以这里要用const修饰的引用进行引用。</span></p> 
<p><span style="color:#1f2329;">        b场景下，<strong>引用的类型和被引用的变量类型不同，在进行类型转换时计算的结果也存储在一个临时变量中，</strong>所以这里也要用const修饰的引用进行引用。</span></p> 
<p><span style="color:#1f2329;">(3)所谓临时对象就是<strong>编译器需要⼀个空间暂存表达式的求值结果时临时创建的⼀个未命名的对象，C++中把这个未命名对象叫做临时对象。</strong></span></p> 
<pre><code class="language-cpp">int main()
{
	int a = 10;
	const int&amp; ra = a * 3;    //正确的引用

	return 0;
}</code></pre> 
<h3 id="6.5%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%85%B3%E7%B3%BB">6.5指针和引用的关系</h3> 
<p>(1)<strong><span style="color:#1f2329;">语法概念上引⽤是⼀个变量的取别名不开空间，指针是存储⼀个变量地址，要开空间。</span></strong></p> 
<p><span style="color:#1f2329;">(2)<strong>引⽤在定义时必须初始化，</strong>指针建议初始化，但是语法上不是必须的。</span></p> 
<p><span style="color:#1f2329;">(3)<strong>引⽤在初始化时引⽤⼀个对象后，就不能再引⽤其他对象</strong>；⽽指针可以在不断地改变指向对象。</span></p> 
<p><span style="color:#1f2329;">(4)引⽤可以直接访问指向对象，指针需要解引⽤才是访问指向对象。</span></p> 
<p><span style="color:#1f2329;">(5)sizeof中含义不同，引⽤结果为引⽤类型的⼤⼩，但指针始终是地址空间所占字节个数(32位平台下占4个字节，64位下是8byte)。</span></p> 
<p><span style="color:#1f2329;">(6)</span><span style="color:#1f2329;">指针很容易出现空指针和野指针的问题，引⽤很少出现，引⽤使⽤起来相对更安全⼀些。</span></p> 
<h2 id="7.inline"><span style="color:#1f2329;">7.inline</span></h2> 
<p><strong><span style="color:#1f2329;">(1)用inline修饰的函数叫做内联函数，编译时C++编译器会在调用的地方展开内敛函数，就和C语言中的宏一样，这样调用内联函数就不需要建立栈帧了，就可以提高效率。</span></strong></p> 
<p><span style="color:#1f2329;">(2)</span><span style="color:#1f2329;">inline对于编译器⽽⾔只是⼀个建议，也就是说，你加了inline编译器也可以选择在调⽤的地⽅不展开，不同编译器关于inline什么情况展开各不相同，因为C++标准没有规定这个。<strong>inline适⽤于频繁调⽤的短⼩函数，对于递归函数，代码相对多⼀些的函数，加上inline也会被编译器忽略。</strong> </span></p> 
<p>(3)<span style="color:#1f2329;">C语⾔实现宏函数也会在预处理时替换展开，但是宏函数实现很复杂很容易出错的，且不⽅便调 试，C++设计了inline⽬的就是替代C的宏函数。 </span></p> 
<p><span style="color:#1f2329;">(4)<strong>inline不建议声明和定义分离到两个⽂件，</strong>分离会导致链接错误。因为inline被展开，就没有函数地址，链接时会出现报错。</span></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
inline int Add(int x, int y)
{
    int ret = x + y;
    ret += 1;
    ret += 1;
    ret += 1;
    return ret;
}
int main()
{
    // 可以通过汇编观察程序是否展开
    // 有call Add语句就是没有展开，没有就是展开了
    int ret = Add(1, 2);
    cout &lt;&lt; Add(1, 2) * 5 &lt;&lt; endl;
    return 0;
}</code></pre> 
<h2 id="8.nullptr">8.nullptr</h2> 
<p>        NULL实际是一个宏，<span style="color:#1f2329;">在传统的C头⽂件(stddef.h)中，可以看到如下代码：</span></p> 
<pre><code class="language-cpp">#ifndef NULL
    #ifdef __cplusplus
        #define NULL 0
    #else
        #define NULL ((void *)0)
    #endif
#endif</code></pre> 
<p>(1)<strong> </strong><span style="color:#1f2329;"><strong>C++中NULL可能被定义为字⾯常量0</strong>，或者C中被定义为⽆类型指针(void*)的常量。不论采取何种定义，在使⽤空值的指针时，都不可避免的会遇到⼀些⿇烦，本想通过f(NULL)调⽤指针版本的f(int*)函数，但是由于NULL被定义成0，调⽤了f(int x)，因此与程序的初衷相悖。f((void*)NULL);调⽤会报错。 </span></p> 
<p>(2)<span style="color:#1f2329;">C++11中引⼊nullptr，nullptr是⼀个特殊的关键字，nullptr是⼀种特殊类型的字⾯量，它可以转换成任意其他类型的指针类型。<strong>使⽤nullptr定义空指针可以避免类型转换的问题，因为nullptr只能被隐式地转换为指针类型，⽽不能被转换为整数类型。</strong></span></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void f(int x)
{
	cout &lt;&lt; "f(int x)" &lt;&lt; endl;
}

void f(int* ptr)
{
	cout &lt;&lt; "f(int * ptr)" &lt;&lt; endl;
}

int main()
{
	f(0);
	f(NULL); //在C++中NULL被定义为整型0，所以这输出的也是f(int x)
	f(nullptr); //这是在C++专门为指针定义的指针类型的空指针输出为f(int* ptr)
	return 0;
}</code></pre> 
<p class="img-center"><img alt="" height="150" src="https://images2.imgbox.com/9d/34/vx6Gdkmv_o.png" width="980"></p> 
<p> </p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8af4d20eb4b35f8ecb738575f8e231f3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">GD32替换STM32的型号对应选型方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d5657d88551a3b090dbb076f67dddc7b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">38-PCB布局实战实战及优化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>