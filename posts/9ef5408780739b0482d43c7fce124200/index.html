<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>模板初阶（详解） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/9ef5408780739b0482d43c7fce124200/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="模板初阶（详解）">
  <meta property="og:description" content="一、泛型编程 为了引出模板，我们来看下面代码，比如要实现不同类型的交换函数，如下：
void Swap(int&amp; a, int&amp; b) { int c = a; a = b; b = c; } void Swap(char&amp; a, char&amp; b) { char c = a; a = b; b = c; } void Swap(double&amp; a, double&amp; b) { double c = a; a = b; b = c; } 这样每个类型交换都需要写一个函数重载，其中代码的重复率很高，只有类型不同而逻辑都一样，写起来也非常的繁琐，那我们能不能写一个通用的函数告诉编译器一个模版让编译器根据不同的类型利用该模版来生成代码呢？这就是本章的主题——模板。
泛型编程：编写与类型无关的通用代码，是代码复用的一种手段。模板是泛型编程的基础。
模板分为函数模板和类模板，接下来我们分别来详细学习。
二、函数模版 函数模板的格式：
template&lt;typename T1, typename T2 , ... ... ,typename Tn&gt;
返回类型 函数名(参数列表){}">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-11T17:02:08+08:00">
    <meta property="article:modified_time" content="2024-08-11T17:02:08+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">模板初阶（详解）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、泛型编程</h2> 
<p>为了引出模板，我们来看下面代码，比如要实现不同类型的交换函数，如下：</p> 
<pre><code class="language-cpp">void Swap(int&amp; a, int&amp; b)
{
	int c = a;
	a = b;
	b = c;
}
void Swap(char&amp; a, char&amp; b)
{
	char c = a;
	a = b;
	b = c;
}
void Swap(double&amp; a, double&amp; b)
{
	double c = a;
	a = b;
	b = c;
}</code></pre> 
<p>        这样每个类型交换都需要写一个函数重载，其中代码的重复率很高，只有类型不同而逻辑都一样，写起来也非常的繁琐，那我们能不能写一个通用的函数告诉编译器一个模版让编译器根据不同的类型利用该模版来生成代码呢？这就是本章的主题——模板。</p> 
<p><span style="color:#fe2c24;"><strong>泛型编程</strong></span>：<u>编写与类型无关的通用代码，是代码复用的一种手段。模板是泛型编程的基础。</u></p> 
<p>模板分为函数模板和类模板，接下来我们分别来详细学习。</p> 
<h2>二、函数模版</h2> 
<p>函数模板的格式：</p> 
<p>template&lt;typename T1, typename T2 , ... ... ,typename Tn&gt;</p> 
<p>返回类型 函数名(参数列表){}</p> 
<p><span style="color:#fe2c24;">注意：这里typename可以换为calss，但不能换位struct。</span></p> 
<p>代码示例：</p> 
<pre><code class="language-cpp">template&lt;typename T&gt;
void Swap(T&amp; a, T&amp; b)
{
	T c = a;
	a = b;
	b = c;
}</code></pre> 
<p>        这样我们写一个模板就可以省了很多代码，还增加可读性。以上并不是一个函数只是一个模板，需要等到使用这个函数的时候编译器会具体的实例化出对应类型的函数，<span style="color:#ff9900;">它和写多个函数重载并没有本质区别，只是说这个工作让编译器帮我们做了而已，在效率上并没有提升。</span></p> 
<p><img alt="" height="724" src="https://images2.imgbox.com/5b/07/Df0c3xrl_o.png" width="1200"></p> 
<p>        需要注意的是如果在这里传两个不同的参数的话会编译报错，因为这里模板参数只有一个，而传入两个不同的类型的实参的时候，<span style="color:#fe2c24;">编译器并不会帮你强制类型转换</span>，因为它并不知道转成那个类型出了问题它可不背锅。那么我们硬要传两个不同的参数的话，可以<span style="color:#ff9900;">显示的强制类型转换成两个相同类型，或者调用的时候在函数名后面加&lt;&gt;，尖括号里面加类型名，也就是</span><strong><span style="color:#fe2c24;">显示实例化</span></strong><span style="color:#ff9900;">，</span></p> 
<p>如下示例：</p> 
<p><img alt="" height="441" src="https://images2.imgbox.com/d0/86/B2y9aw5k_o.png" width="699"></p> 
<p>        这里有人可能会试图去测试Swap模板，结构还是编不过，这是因为不符合引用的语法，我在之前讲过，如下链接：</p> 
<p><a href="https://blog.csdn.net/2302_80105876/article/details/140560773?spm=1001.2014.3001.5501" title="C++入门基础-CSDN博客">C++入门基础-CSDN博客</a></p> 
<p><img alt="" height="438" src="https://images2.imgbox.com/49/30/d2C5MaEO_o.png" width="1187">        对于这种情况，我们可以在外面进行强制类型转换存入新的变量里面然后再把新的变量代替原来变量做函数参数。 </p> 
<p>       <span style="color:#fe2c24;"> 函数模板与模板函数的区别：</span>通过这两个词就可以看出来函数模板的主语是模板，模板函数的主语是函数，那么接下来就好理解了，函数模板就是一个模板如刚才我们写的那些都是函数模板，而模板函数是函数模板经过实例化后生成的函数。</p> 
<h2>三、类模板</h2> 
<p>类模板的定义个格式：</p> 
<p>template&lt;typename T1, typename T2, ... ... ,typename Tn&gt;</p> 
<p>class 类模板名</p> 
<p>{}</p> 
<p>同样这里typename可以换为calss，但不能换位struct。</p> 
<p>        对于类模板与函数模板不同，类模板在使用的时候必须显示实例化，在类模板名后面加&lt;&gt;尖括号里面放入类型名。</p> 
<p>注意：类模板不是类，要经过实例化后才是类。如下一个Stack类模板的部分：</p> 
<pre><code class="language-cpp">// 类模版
template&lt;typename T&gt;
class Stack
{
public :
	Stack(size_t capacity = 4)
	{
		_array = new T[capacity];
		_capacity = capacity;
		_size = 0;
	} 
	void Push(const T&amp; data);
	//... ...
private:
	T* _array;
	size_t _capacity;
	size_t _size;
};
// 模版不建议声明和定义分离到两个文件.h 和.cpp会出现链接错误
template&lt;class T&gt;
void Stack&lt;T&gt;::Push(const T&amp; data)
{
	// 扩容
	//... ...
	_array[_size] = data;
	++_size;
} 
int main()
{
	Stack&lt;int&gt; st1;
	Stack&lt;double&gt; st2;
	return 0;
}
</code></pre> 
<h2>四、模板参数的匹配原则</h2> 
<p>接下来讲的匹配原则对于类模板和函数模板都是相同的，我们就以函数模板为例。</p> 
<p>一个非模板函数是可以和模板函数同名的，而怎么区分编译器会调用那个呢，如下：</p> 
<pre><code class="language-cpp">template&lt;typename T&gt;
T Add(T a, T b)
{
	return a + b;
}
int Add(int a, int b)
{
	return a + b;
}
int main()
{
	int a1 = 2, b1 = 4;
	double a2 = 2.5, b2 = 1.5;
	int ret1=Add(a1, b1);
	double ret2=Add(a2, b2);
	return 0;
}</code></pre> 
<p>        编译器在做调用(不仅指函数的调用)的时候有一个特点，<span style="color:#fe2c24;">有现成的就调现成的，没现成的就调用模板实例化一个。</span>如这里第一个Add调用的是非模板函数，第二个Add调用的是模板函数。 </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cf8dc79b8537ba5382a1e4d8dfb5824e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HAProxy理论&#43;实验</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/32cfb2ea70b1df2be606d25a17e8f1ad/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【MySQL基础】非常全面！一文掌握MySQL常用语法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>