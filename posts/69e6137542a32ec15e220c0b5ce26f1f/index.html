<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java----抽象类和接口 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/69e6137542a32ec15e220c0b5ce26f1f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java----抽象类和接口">
  <meta property="og:description" content="欢迎大家来这次博客-----抽象类和接口。 1.抽象类 1.1 抽象类概念 在Java中我们都是通过类来描述对象，但反过来并不是所有的类都是用来描述对象的。当一个类中没有足够的信息来描述一个具体对象，我们就将该类称为抽象类。
如上图中的Shape类，我们想通过Shape类中的draw()方法来实现画各种图形，但由于Shape类不是具体的图形，所以Shape类中的draw()方法也无法实现画各种图形，所以我们将Shape类设置成抽象类。
代码演示
abstract class Shape{ public abstract void draw(); } class Triangle extends Shape{ @Override public void draw() { System.out.println(&#34;画一个三角形&#34;); } } class Cycle extends Shape{ @Override public void draw() { System.out.println(&#34;画一个圆&#34;); } } class Rect extends Shape{ @Override public void draw() { System.out.println(&#34;画一个矩形&#34;); } } public class Test { public static void main(String[] args) { Shape[] shapes={new Triangle(), new Cycle(), new Rect()}; for(Shape shape:shapes){ shape.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-09T14:51:05+08:00">
    <meta property="article:modified_time" content="2024-06-09T14:51:05+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java----抽象类和接口</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>欢迎大家来这次博客-----抽象类和接口。 </p> 
<p class="img-center"><img alt="" height="675" src="https://images2.imgbox.com/75/96/6DM2ita6_o.jpg" width="1200"></p> 
<h2>1.抽象类</h2> 
<h3>1.1 抽象类概念</h3> 
<p>在Java中我们都是通过类来描述对象，但反过来并不是所有的类都是用来描述对象的。当一个类中没有足够的信息来描述一个具体对象，我们就将该类称为<strong>抽象类</strong>。</p> 
<p class="img-center"><img alt="" height="421" src="https://images2.imgbox.com/df/48/JvdFxtk0_o.jpg" width="968"></p> 
<p>如上图中的Shape类，我们想通过Shape类中的draw()方法来实现画各种图形，但由于Shape类不是具体的图形，所以Shape类中的draw()方法也无法实现画各种图形，所以我们将Shape类设置成抽象类。</p> 
<p>代码演示</p> 
<pre><code class="language-java">abstract class Shape{
    public abstract void draw();
}
class Triangle extends Shape{
    @Override
    public void draw() {
        System.out.println("画一个三角形");
    }
}
class Cycle extends Shape{
    @Override
    public void draw() {
        System.out.println("画一个圆");
    }
}
class Rect extends Shape{
    @Override
    public void draw() {
        System.out.println("画一个矩形");
    }
}
public class Test {
    public static void main(String[] args) {
        Shape[] shapes={new Triangle(), new Cycle(), new Rect()};
        for(Shape shape:shapes){
            shape.draw();
        }
    }
}</code></pre> 
<p></p> 
<p class="img-center"><img alt="" height="471" src="https://images2.imgbox.com/b8/2b/bYN1zeXv_o.jpg" width="924"></p> 
<p>代码演示</p> 
<pre><code class="language-java">abstract class Animal{
    public abstract void Bark();
}
class Dog extends Animal{
    @Override
    public void Bark() {
        System.out.println("小狗在汪汪叫");
    }
}
class Cat extends Animal{
    @Override
    public void Bark() {
        System.out.println("小猫在喵喵叫");
    }
}
public class Test {
    public static void func(Animal animal){
        animal.Bark();
    }
    public static void main(String[] args) {
        Dog dog=new Dog();
        func(dog);
        Cat cat=new Cat();
        func(cat);
    }
}
</code></pre> 
<p>注意，如以上代码有些地方看不懂，后面回一 一介绍。</p> 
<h3>1.2 抽象类语法</h3> 
<p>在Java中，当一个类被关键字abstract修饰，该类就被称为抽象类，抽象类中如果有方法被abstract修饰，则该方法就被称为抽象方法，<strong>抽象方法不需要具体实现</strong>。</p> 
<pre><code class="language-java">//抽象类
abstract class Animal{
    //抽象方法
    public abstract void Bark();
}</code></pre> 
<p>注意事项：</p> 
<p><strong>抽象类中也可以包含普通的方法，甚至也可以包含构造方法</strong>。 </p> 
<h3>1.3 抽象类的特性</h3> 
<p>1. 抽象类不能实例化对象</p> 
<p class="img-center"><img alt="" height="351" src="https://images2.imgbox.com/03/ab/IxtV4l0G_o.png" width="906"></p> 
<p>2. 抽象方法不能被private修饰。</p> 
<p class="img-center"><img alt="" height="320" src="https://images2.imgbox.com/09/4c/fVJYhIof_o.png" width="897"></p> 
<p>3. 抽象方法不能被final和static修饰，因为子类要重写抽象方法。</p> 
<p class="img-center"><img alt="" height="325" src="https://images2.imgbox.com/8d/d2/8tuRXsOK_o.png" width="855"></p> 
<p class="img-center"><img alt="" height="243" src="https://images2.imgbox.com/aa/52/TidoQDUf_o.png" width="904"></p> 
<p>4. 抽象类必须被继承，继承抽象类的子类必须重写抽象类中的抽象方法。<strong>否则子类也是抽象类，必须用abstract修饰。</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="288" src="https://images2.imgbox.com/c2/a5/EDIjehR1_o.png" width="643"></p> 
<p>5. 抽象类中不一定有抽象方法，但有抽象方法的类一定是抽象类。</p> 
<p>6. 抽象类中可以有构造方法，供子类创建对象时，初始化父类的成员变量。</p> 
<h3>1.4 抽象类的作用</h3> 
<p>抽象类本身是不能实例化的，要想使用抽象类，必须需要继承的子类重写抽象类中的抽象方法。</p> 
<p>有人这时候就很疑惑，普通类不是也能被继承吗？</p> 
<p>确实如此，但是使用抽象类多了一层编译器的校验。</p> 
<p>如上面的代码，我们完成的操作都是由子类去完成的，但是如果交由父类去完成，普通编译器是不会报错的，但使用了抽象类，父类在实例化的时候就会报错，起到一个提醒的作用。</p> 
<h2>2. 接口</h2> 
<h3>2.1 接口的概念</h3> 
<p>在生活中，接口比比皆是，如插座，USB插口。</p> 
<p class="img-center"><img alt="" height="371" src="https://images2.imgbox.com/d1/0e/Ehfe4F2g_o.jpg" width="514"></p> 
<p class="img-center"><img alt="" height="321" src="https://images2.imgbox.com/e6/2d/dOcCoK0x_o.jpg" width="498"></p> 
<p>接口通俗来说就是一种固定行为规范，只要你的操作符合规范，就能使用接口。</p> 
<p><strong>在Java中，接口可以看作为多个类的行为规范，是一种引用数据类型。 </strong></p> 
<h3><strong>2.2 接口的语法规则</strong></h3> 
<p>关键字interface  接口名字</p> 
<p>举例，如下图，</p> 
<p class="img-center"><img alt="" height="130" src="https://images2.imgbox.com/18/eb/lGfrcJXa_o.png" width="403"></p> 
<h3>2.3 接口的特性</h3> 
<p><strong>1.接口是一种引用数据类型，但是不能直接new关键字来创建对象。</strong></p> 
<p class="img-center"><img alt="" height="391" src="https://images2.imgbox.com/da/be/xsLSZDKF_o.png" width="624"></p> 
<p><strong>2.接口中的每一个方法都是默认由public abstract 修饰的，也就是说接口中的方法不能被其他关键字修饰。（可以不写修饰接口中方法的关键字，编译器默认为public abstract）</strong></p> 
<p class="img-center"><img alt="" height="357" src="https://images2.imgbox.com/b4/d5/cSyEGlXH_o.png" width="595"></p> 
<p><strong>3. 接口中的方法不能在接口中实现，只能在使用接口的类中实现。（有特殊情况）</strong></p> 
<p class="img-center"><img alt="" height="311" src="https://images2.imgbox.com/7e/e3/AKs29bdP_o.png" width="576"></p> 
<p> <strong>4. 如果接口中的方法被default或者static修饰，可以有具体实现。</strong></p> 
<p class="img-center"><img alt="" height="263" src="https://images2.imgbox.com/8e/e2/1kGtgFO6_o.png" width="509"></p> 
<p><strong>5.  重写接口中的方法时，不能使用默认的访问权限。</strong></p> 
<p class="img-center"><img alt="" height="412" src="https://images2.imgbox.com/d6/bc/HznpZEvn_o.png" width="700"></p> 
<p><strong>6. 接口中可以含有变量，但会默认为被 public static final 修饰。  </strong></p> 
<p class="img-center"><img alt="" height="325" src="https://images2.imgbox.com/cc/82/GZUA6Fkb_o.png" width="607"></p> 
<p class="img-center"><img alt="" height="334" src="https://images2.imgbox.com/cc/5b/nPxCsgHk_o.png" width="553"></p> 
<p><strong>7. 接口中不能含有静态代码块和构造方法</strong></p> 
<p class="img-center"><img alt="" height="289" src="https://images2.imgbox.com/fb/73/Jjv8ZUeH_o.png" width="370"></p> 
<p><strong>8.如果类中没有重写接口中所有的抽象方法，则该类要用abstract修饰</strong>。</p> 
<p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/f9/ed/XGMAD2xV_o.png" width="541"></p> 
<p><strong>9.接口虽然不是类，但接口编译完成后的字节码文件的后缀也是 .java 。</strong></p> 
<h3>2.4 接口的使用</h3> 
<p>接口不能直接使用，必须要有一个 “实现类” 来重写接口中的抽象方法，通过这个实现类来使用接口。</p> 
<p>如果一个类想使用一个接口，要用到<span style="color:#fe2c24;"><strong>implements</strong></span>关键字。</p> 
<p>语法格式</p> 
<pre><code class="language-java">public class 类名称 implements 接口名称{
        // ...
}</code></pre> 
<p>注意：父类与子类之间的关系为extends，类与接口之间的关系为implements。</p> 
<h4 style="background-color:transparent;">实现一个USB接口</h4> 
<p class="img-center"><img alt="" height="223" src="https://images2.imgbox.com/a6/56/eYtLuqVc_o.png" width="739"></p> 
<pre><code class="language-java">interface USB{
     void close();
     void open();
}
class Mouse implements USB{
    @Override
    public void close() {
        System.out.println("关闭鼠标");
    }
    public void open(){
        System.out.println("打开鼠标");
    }
    public void click(){
        System.out.println("点击鼠标");
    }
}
class KeyBoard implements USB{
    public void close(){
        System.out.println("关闭键盘");
    }

    @Override
    public void open() {
        System.out.println("开启键盘");
    }
    public void input(){
        System.out.println("输入功能");
    }
}
class Computer implements USB{
    @Override
    public void close() {
        System.out.println("关闭电脑");
    }
    public void open(){
        System.out.println("打开电脑");
    }
    public void use(USB usb){
        usb.open();
        if(usb instanceof Mouse){
            ((Mouse) usb).click();
        }else{
            ((KeyBoard)usb).input();
        }
        usb.close();
    }

}
public class Test {
    public static void main(String[] args) {
       Computer computer=new Computer();
       computer.open();
       USB usb1=new Mouse();
       computer.use(usb1);
       System.out.println("=======");
       USB usb2=new KeyBoard();
       computer.use(usb2);
       computer.close();
    }
}
</code></pre> 
<p class="img-center"><img alt="" height="352" src="https://images2.imgbox.com/ab/a3/lTwfdvS8_o.png" width="766"></p> 
<h3>2.5  实现多个接口</h3> 
<p>一个类不能同时继承多个类，但是一个类可以同时使用多个接口。</p> 
<p>举个例子：用Java来描述鸭子会飞，会游泳和会跑。</p> 
<p>我们可以将会飞，会游泳，会跑设置为三个接口。</p> 
<p>ISwimming接口</p> 
<pre><code class="language-java">public interface ISwimming {
    void swim();
}
</code></pre> 
<p>IRunning接口</p> 
<pre><code class="language-java">public interface IRunning {
     void run();
}
</code></pre> 
<p>IFly接口</p> 
<pre><code class="language-java">public interface IFly {
    void fly();
}
</code></pre> 
<p>Duck类</p> 
<pre><code class="language-java">public class Duck extends Animal implements IFly,IRunning,ISwimming{
    public Duck(String name){
        super(name);
    }

    @Override
    public void fly() {
        System.out.println(this.name+"会飞");
    }

    @Override
    public void run() {
        System.out.println(this.name+"会跑");
    }

    @Override
    public void swim() {
        System.out.println(this.name+"会游泳");
    }
}
</code></pre> 
<p>测试类</p> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        Duck duck=new Duck("小鸭");
        duck.fly();
        duck.run();
        duck.swim();
    }
}
</code></pre> 
<p class="img-center"><img alt="" height="238" src="https://images2.imgbox.com/7d/d0/7TDRXLrV_o.png" width="667"></p> 
<h4><span style="color:#fe2c24;"><strong> 快捷操作：CTRL+I键 快速实现接口</strong></span></h4> 
<p> 使用接口的好处就是可以让程序员忘记类的限制，只需要关注该类有没有此接口对应的功能。</p> 
<pre><code class="language-java">class Robot implements IRunning{
    @Override
    public void run() {
        System.out.println("机器人再跑1");
    }
}
public class Test {
    public static void func(IRunning running){
        running.run();
    }
    public static void main(String[] args) {
        Duck duck=new Duck("小鸭");
        func(duck);
        Robot robot=new Robot();
        func(robot);
    }
}</code></pre> 
<p class="img-center"><img alt="" height="91" src="https://images2.imgbox.com/df/01/PP0G5xT0_o.png" width="390"></p> 
<p>如以上代码，我们给func函数穿的参数可以是Duck类，也可以是Robot类，只要这两个类具备跑的能力就行了。</p> 
<h3>2.6 接口之间的继承</h3> 
<p>在Java中，类与类之间只允许单继承，不允许多继承。但是对于接口来说，接口之间既可以单继承，也可以多继承。</p> 
<p>接口之间的继承也是用到extends关键字。</p> 
<p> 代码演示</p> 
<pre><code class="language-java">interface Double extends IRunning,ISwimming{
}
class Dog implements Double{
    @Override
    public void run() {
        System.out.println("狗会跑");
    }

    @Override
    public void swim() {
        System.out.println("狗会游泳");
    }
}
public class Test {
    public static void main(String[] args) {
        Dog dog=new Dog();
        dog.run();
        dog.swim();
    }
}
</code></pre> 
<p class="img-center"><img alt="" height="97" src="https://images2.imgbox.com/9e/39/yD2pxUpT_o.png" width="514"></p> 
<p>到此，抽象类和接口的基础内容就介绍完了，感谢观看。</p> 
<p class="img-center"><img alt="" height="675" src="https://images2.imgbox.com/ae/0d/7tmihGPB_o.jpg" width="1200"></p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c3679791e95d431c0acf04e3bf6faec6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">浅议Flink中算子间的八种数据传输策略</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0bcb02f0c05e8d572bec1e8eb4366bd8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据结构】二叉树专题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>