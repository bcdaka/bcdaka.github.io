<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>手把手教你搭建 Android MVI架构: MVI &#43; kotlin &#43; Flow - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/efd2cf267077114511b5faa4f409424e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="手把手教你搭建 Android MVI架构: MVI &#43; kotlin &#43; Flow">
  <meta property="og:description" content="一、什么是MVI Android MVI是一种用于构建Android应用程序的架构模式，其核心思想在于实现单向数据流和唯一可信数据源。在MVI架构中，应用程序的状态管理得到简化，并且用户界面与业务逻辑之间的交互更加清晰和规范。
二、MVI组成 MVI由Model、View和Intent三个核心组件组成：
Model：代表数据模型，负责存储应用程序的状态。它是唯一可信的数据源，意味着应用程序的所有状态都集中在这里管理，避免了状态不一致的问题。
View：即用户界面，负责展示Model中的状态，并响应用户的操作。当用户与界面进行交互时，会产生相应的Intent。
Intent：表示用户的意图或操作。它是View向Model传递信息的方式，告诉Model用户想要执行的操作或期望达到的状态。
在MVI架构中，数据流动是单向的：View产生Intent，Intent传递给Reducer（一个处理Intent并更新Model状态的函数），Reducer根据Intent生成新的Model状态，并将这个状态发送回View进行渲染。这种单向数据流有助于简化状态管理，并使得代码更加可预测和易于维护。
MVI架构还强调代码分层和清晰的责任划分。ViewModel无需关心View如何触发和更新，它只需要维护Intent和State。View与ViewModel的交互更加规范，使用Kotlin的密封类特性来封装Intent和State，使得代码更加规范、整洁和易读。
从图中可以看到，
数据从Data Layer -&gt; ViewModel -&gt; UI，数据是单向流动的。ViewModel将数据封装成UI State传输到UI elements中，而UI elements是不会传输数据到ViewModel的。UI elements上的一些点击或者用户事件，都会封装成events事件，发送给ViewModel。ViewModel更新状态： 在处理事件的过程中，ViewModel 的内部状态（即 UI State）可能会发生变化。这些状态变化通常是基于用户操作和业务逻辑的结果。通知Vew UI更新： 一旦 ViewModel 的状态发生变化，它需要通知 UI 进行相应的更新。这通常是通过某种机制完成的，比如使用观察者模式（如 RxSwift、Kotlin Flow 等），或者通过数据绑定（如 Flutter 的数据流或 Jetpack Compose 的状态持有者）。当 UI 接收到 ViewModel 的状态更新时，它会根据新的状态重新渲染自己。 通过这样的流程，ViewModel 在应用程序中充当了一个中介角色，它接收 UI 的事件，处理这些事件并更新状态，然后通知 UI 进行相应的渲染。这种单向数据流的方式有助于保持代码的可维护性和可测试性，同时也有助于实现更清晰的组件间解耦。
三、MVI框架搭建 搭建步骤：
定义UI State、events构建UI State单向数据流UDF构建事件流eventsUI State的订阅和发送 3.1 定义UIState、events import androidx.annotation.Keep @Keep interface IUiIntent import androidx.annotation.Keep @Keep interface IUiState 然后根据具体逻辑定义页面的UIState和UiIntent。
data class MainState(val bannerUiState: BannerUiState, val detailUiState: DetailUiState) : IUiState sealed class BannerUiState { object INIT : BannerUiState() data class SUCCESS(val models: List&lt;Banner&gt;) : BannerUiState() } sealed class DetailUiState { object INIT : DetailUiState() data class SUCCESS(val articles: Article) : DetailUiState() } sealed class MainIntent : IUiIntent { object GetBanner : MainIntent() data class GetDetail(val page: Int) : MainIntent() } 通过MainState将页面的不同状态封装起来，从而实现唯一可信数据源">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-15T17:34:58+08:00">
    <meta property="article:modified_time" content="2024-03-15T17:34:58+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">手把手教你搭建 Android MVI架构: MVI &#43; kotlin &#43; Flow</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h5></h5> 
<h5>一、什么是MVI</h5> 
<p>Android MVI是一种用于构建Android应用程序的架构模式，其核心思想在于实现单向数据流和唯一可信数据源。在MVI架构中，应用程序的状态管理得到简化，并且用户界面与业务逻辑之间的交互更加清晰和规范。</p> 
<h5>二、MVI组成</h5> 
<p>MVI由Model、View和Intent三个核心组件组成：</p> 
<blockquote> 
 <ol><li> <p><strong>Model</strong>：代表数据模型，负责存储应用程序的状态。它是唯一可信的数据源，意味着应用程序的所有状态都集中在这里管理，避免了状态不一致的问题。</p> </li><li> <p><strong>View</strong>：即用户界面，负责展示Model中的状态，并响应用户的操作。当用户与界面进行交互时，会产生相应的Intent。</p> </li><li> <p><strong>Intent</strong>：表示用户的意图或操作。它是View向Model传递信息的方式，告诉Model用户想要执行的操作或期望达到的状态。</p> </li></ol> 
</blockquote> 
<p>在MVI架构中，数据流动是单向的：View产生Intent，Intent传递给Reducer（一个处理Intent并更新Model状态的函数），Reducer根据Intent生成新的Model状态，并将这个状态发送回View进行渲染。这种单向数据流有助于简化状态管理，并使得代码更加可预测和易于维护。</p> 
<p>MVI架构还强调代码分层和清晰的责任划分。ViewModel无需关心View如何触发和更新，它只需要维护Intent和State。View与ViewModel的交互更加规范，使用Kotlin的密封类特性来封装Intent和State，使得代码更加规范、整洁和易读。</p> 
<p><img alt="" height="1103" src="https://images2.imgbox.com/28/91/p61aJOkh_o.png" width="1200"></p> 
<p>从图中可以看到，</p> 
<blockquote> 
 <ol><li>数据从Data Layer -&gt; ViewModel -&gt; UI，数据是单向流动的。ViewModel将数据封装成<code>UI State</code>传输到UI elements中，而UI elements是不会传输数据到ViewModel的。</li><li>UI elements上的一些点击或者用户事件，都会封装成<code>events</code>事件，发送给ViewModel。</li><li>ViewModel更新状态： 
   <ul><li>在处理事件的过程中，<code>ViewModel</code> 的内部状态（即 <code>UI State</code>）可能会发生变化。</li><li>这些状态变化通常是基于用户操作和业务逻辑的结果。</li></ul></li><li>通知Vew UI更新： 
   <ul><li>一旦 <code>ViewModel</code> 的状态发生变化，它需要通知 <code>UI</code> 进行相应的更新。</li><li>这通常是通过某种机制完成的，比如使用观察者模式（如 RxSwift、Kotlin Flow 等），或者通过数据绑定（如 Flutter 的数据流或 Jetpack Compose 的状态持有者）。</li><li>当 <code>UI</code> 接收到 <code>ViewModel</code> 的状态更新时，它会根据新的状态重新渲染自己。</li></ul></li></ol> 
</blockquote> 
<p>通过这样的流程，<code>ViewModel</code> 在应用程序中充当了一个中介角色，它接收 <code>UI</code> 的事件，处理这些事件并更新状态，然后通知 <code>UI</code> 进行相应的渲染。这种单向数据流的方式有助于保持代码的可维护性和可测试性，同时也有助于实现更清晰的组件间解耦。</p> 
<h5>三、MVI框架搭建</h5> 
<p>  搭建步骤：</p> 
<blockquote> 
 <ol><li>定义<code>UI State</code>、<code>events</code></li><li>构建<code>UI State</code>单向数据流<code>UDF</code></li><li>构建事件流<code>events</code></li><li><code>UI State</code>的订阅和发送</li></ol> 
</blockquote> 
<h6>3.1 定义<code>UIState</code>、<code>events</code></h6> 
<pre><code class="language-Kotlin">import androidx.annotation.Keep
@Keep
interface IUiIntent</code></pre> 
<pre><code class="language-Kotlin">import androidx.annotation.Keep
@Keep
interface IUiState</code></pre> 
<p>然后根据具体逻辑定义页面的UIState和UiIntent。</p> 
<pre><code class="language-Kotlin">data class MainState(val bannerUiState: BannerUiState, val detailUiState: DetailUiState) : IUiState</code></pre> 
<pre><code class="language-Kotlin">sealed class BannerUiState {
    object INIT : BannerUiState()
    data class SUCCESS(val models: List&lt;Banner&gt;) : BannerUiState()
}</code></pre> 
<pre><code class="language-Kotlin">sealed class DetailUiState {
    object INIT : DetailUiState()
    data class SUCCESS(val articles: Article) : DetailUiState()
}</code></pre> 
<pre><code class="language-Kotlin">sealed class MainIntent : IUiIntent {
    object GetBanner : MainIntent()
    data class GetDetail(val page: Int) : MainIntent()
}</code></pre> 
<p>通过<code>MainState</code>将页面的不同状态封装起来，从而实现<code>唯一可信数据源</code></p> 
<h6><code>3.2 构建事件流</code></h6> 
<p>在ViewModel中使用<code>StateFlow</code>构建UI State流</p> 
<ul><li><code>_uiStateFlow</code>用来更新数据</li><li><code>uiStateFlow</code>用来暴露给UI elements订阅</li></ul> 
<pre><code class="language-Kotlin">abstract class BaseViewModel&lt;UiState : IUiState, UiIntent : IUiIntent&gt; : ViewModel() {

    private val _uiStateFlow = MutableStateFlow(initUiState())
    val uiStateFlow: StateFlow&lt;UiState&gt; = _uiStateFlow

    protected abstract fun initUiState(): UiState

    protected fun sendUiState(copy: UiState.() -&gt; UiState) {
        _uiStateFlow.update { copy(_uiStateFlow.value) }
    }
}
</code></pre> 
<pre><code class="language-Kotlin">class MainViewModel : BaseViewModel&lt;MainState, MainIntent&gt;() {

    override fun initUiState(): MainState {
        return MainState(BannerUiState.INIT, DetailUiState.INIT)
    }
}
</code></pre> 
<p>3.3 构建事件流</p> 
<p>在ViewModel中使用 <code>Channel</code>构建事件流</p> 
<blockquote> 
 <p>有人好奇这里为啥用Channel，而不用SharedFlow或者StateFlow？</p> 
 <p>Channel就像一个队列一样，适合实现单个生产者和单个消费者之间的通信，而 SharedFlow 更适合实现多个观察者订阅同一数据源。而这里的Intent事件更像前者，各个协程生产出不同的Intent事件通过Channel发送给ViewModel，然后在ViewModel中集中处理消费。</p> 
</blockquote> 
<ol><li><code>_uiIntentFlow</code>用来传输Intent</li><li>在viewModelScope中开启协程监听<code>uiIntentFlow</code>，在子ViewModel中只用重写<code>handlerIntent</code>方法就可以处理Intent事件了</li><li>通过sendUiIntent就可以发送Intent事件了</li></ol> 
<p></p> 
<pre><code class="language-Kotlin">abstract class BaseViewModel&lt;UiState : IUiState, UiIntent : IUiIntent&gt; : ViewModel() {

    private val _uiIntentFlow: Channel&lt;UiIntent&gt; = Channel()
    val uiIntentFlow: Flow&lt;UiIntent&gt; = _uiIntentFlow.receiveAsFlow()
    
    fun sendUiIntent(uiIntent: UiIntent) {
        viewModelScope.launch {
            _uiIntentFlow.send(uiIntent)
        }
    }

    init {
        viewModelScope.launch {
            uiIntentFlow.collect {
                handleIntent(it)
            }
        }
    }

    protected abstract fun handleIntent(intent: IUiIntent)
</code></pre> 
<pre><code class="language-Kotlin">class MainViewModel : BaseViewModel&lt;MainState, MainIntent&gt;() {

    override fun handleIntent(intent: IUiIntent) {
        when (intent) {
            MainIntent.GetBanner -&gt; {
                requestDataWithFlow()
            }
            is MainIntent.GetDetail -&gt; {
                requestDataWithFlow()
            }
        }
    }
}
</code></pre> 
<h6>3.4 UI State的订阅和发送</h6> 
<h6>3.4.1 订阅UI State</h6> 
<p>在Activity中订阅UI state的变化</p> 
<ol><li>在<code>lifecycleScope</code>中开启协程，<code>collect</code> <code>uiStateFlow</code>。</li><li>使用<code>map</code> 来做局部变量的更新</li><li>使用<code>distinctUntilChanged</code>来做数据防抖</li></ol> 
<pre><code class="language-Kotlin">class MainActivity : BaseMVIActivity() {

    private fun registerEvent() {
        lifecycleScope.launchWhenStarted {
            mViewModel.uiStateFlow.map { it.bannerUiState }.distinctUntilChanged().collect { bannerUiState -&gt;
                when (bannerUiState) {
                    is BannerUiState.INIT -&gt; {}
                    is BannerUiState.SUCCESS -&gt; {
                        bannerAdapter.setList(bannerUiState.models)
                    }
                }
            }
        }
        lifecycleScope.launchWhenStarted {
            mViewModel.uiStateFlow.map { it.detailUiState }.distinctUntilChanged().collect { detailUiState -&gt;
                when (detailUiState) {
                    is DetailUiState.INIT -&gt; {}
                    is DetailUiState.SUCCESS -&gt; {
                        articleAdapter.setList(detailUiState.articles.datas)
                    }
                }

            }
        }
    }
}
</code></pre> 
<h6>3.4.2 发送Intent</h6> 
<p>直接调用<code>sendUiIntent</code>就可以发送Intent事件</p> 
<pre><code class="language-Kotlin">button.setOnClickListener {
    mViewModel.sendUiIntent(MainIntent.GetBanner)
    mViewModel.sendUiIntent(MainIntent.GetDetail(0))
}
</code></pre> 
<h6>3.4.3 更新Ui State</h6> 
<p>调用<code>sendUiState</code>发送Ui State更新</p> 
<p><strong>需要注意的是：</strong> 在UiState改变时，使用的是copy复制一份原来的UiState，然后修改变动的值。这是为了做到 <strong>“可信数据源”</strong>，在定义<code>MainState</code>的时候，设置的就是<code>val</code>，是为了避免多线程并发读写，导致线程安全的问题。</p> 
<pre><code class="language-Kotlin">class MainViewModel : BaseViewModel&lt;MainState, MainIntent&gt;() {
    private val mWanRepo = WanRepository()

    override fun initUiState(): MainState {
        return MainState(BannerUiState.INIT, DetailUiState.INIT)
    }

    override fun handleIntent(intent: IUiIntent) {
        when (intent) {
            MainIntent.GetBanner -&gt; {
                requestDataWithFlow(showLoading = true,
                    request = { mWanRepo.requestWanData() },
                    successCallback = { data -&gt; sendUiState { copy(bannerUiState = BannerUiState.SUCCESS(data)) } },
                    failCallback = {})
            }
            is MainIntent.GetDetail -&gt; {
                requestDataWithFlow(showLoading = false,
                    request = { mWanRepo.requestRankData(intent.page) },
                    successCallback = { data -&gt; sendUiState { copy(detailUiState = DetailUiState.SUCCESS(data)) } })
            }
        }
    }
}
</code></pre> 
<p>其中 <code>requestDataWithFlow</code> 是封装的一个网络请求的方法</p> 
<pre><code class="language-Kotlin">protected fun &lt;T : Any&gt; requestDataWithFlow(
    showLoading: Boolean = true,
    request: suspend () -&gt; BaseData&lt;T&gt;,
    successCallback: (T) -&gt; Unit,
    failCallback: suspend (String) -&gt; Unit = { errMsg -&gt;
        //默认异常处理
    },
) {
    viewModelScope.launch {
        val baseData: BaseData&lt;T&gt;
        try {
            baseData = request()
            when (baseData.state) {
                ReqState.Success -&gt; {
                    sendLoadUiState(LoadUiState.ShowMainView)
                    baseData.data?.let { successCallback(it) }
                }
                ReqState.Error -&gt; baseData.msg?.let { error(it) }
            }
        } catch (e: Exception) {
            e.message?.let { failCallback(it) }
        }
    }
}
</code></pre> 
<pre><strong>至此一个MVI的框架基本就搭建完毕了</strong>
</pre> 
<p><strong>觉得我写的好的兄弟可以动动发财的小手帮我点个赞 谢谢！！！！！</strong></p> 
<p>源码链接地址：<a href="https://download.csdn.net/download/a546036242/88971170" title="https://download.csdn.net/download/a546036242/88971170">https://download.csdn.net/download/a546036242/88971170</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/25070f77c9c62a4eb32d18a0e0146a32/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用 ZipArchiveInputStream 读取压缩包内文件总数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7539e6c6b2810fbe61490567fe17e353/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">快速删除node_modules</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>