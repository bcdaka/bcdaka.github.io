<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>在VScode下配置C/C&#43;&#43;环境(tasks.json、launch.json、c_cpp_properties.json) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f155bbdefd5fc5e56f220267fcc4e815/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="在VScode下配置C/C&#43;&#43;环境(tasks.json、launch.json、c_cpp_properties.json)">
  <meta property="og:description" content="文章目录 1. tasks.json、launch.json配置文件中参数(属性)的说明2. tasks.json介绍3. launch.json介绍4. 直接生成tasks.json、launch.json配置文件的另外一种方式5. c_cpp_properties.json介绍6. 运行多个C/C&#43;&#43;文件7. 命令行方式编译C&#43;&#43; 1. tasks.json、launch.json配置文件中参数(属性)的说明 首先我们创建了一个code项目，然后在code文件夹下分别建立了day1和day2两个目录(文件夹)，最后在day1和day2文件夹下分别创建hello.c和main.cpp两个文件，code项目的组织结构如下图1所示。在VScode中，默认情况下code文件夹是一个workspace(工作区、工作空间)。
图1 code项目的组织结构 下面，我们基于上面code项目的组织结构对tasks.json、launch.json配置文件中的参数(属性)进行说明。（以hello.c文件为例）
（1）${workspaceFolder}：表示当前workspace(工作区、工作空间)文件夹的路径，也即当前项目绝对路径。例如：D:\code，code就是一个工作区。
（2）${fileDirname}：表示当前打开文件的绝对路径，但不包括文件名。例如打开hello.c文件，该文件所在的绝对路径(${fileDirname})为：D:\code\day1，day1就是hello.c文件的目录。
（3）${workspaceFolder}/**：表示当前workspace(工作区、工作空间)文件夹的路径，而且还会递归搜索所有子目录。例如：当前项目的绝对路径为D:\code，不仅要搜索code文件夹，还会递归搜索code的所有子目录（子文件夹）。
（4）${workspaceRootFolderName}：表示workspace(工作区、工作空间)文件夹名字，也就是当前项目所在文件夹名字，例如code文件夹。
（5）${file}：表示当前打开的文件，指的是当前活动文件。包括绝对路径，文件名，文件后缀名。例如：D:\code\day1\hello.c。
（6）${fileBasename}：当前打开含有后缀的文件名，不包括路径。
（7）${fileBasenameNoExtension}：表示当前打开的文件名，但不包括路径和后缀名。
（8）cwd(current working directory)：当前工作目录，它是操作系统当前正在运行进程所在的目录。在命令行界面(比如，cmd)中，用户输入命令时，默认情况下会在cwd下执行。
更多命令参考：变量参考
参考文章
最新VS code配置C/C&#43;&#43;环境(tasks.json, launch.json,c_cpp_properties.json)及运行多个文件、配置Cmake
（上面这篇文章介绍的比较详细，我下面总结的大部分内容都摘抄于该文章，非常感谢该博主）
2. tasks.json介绍 tasks.json在编译时用的到，配置tasks.json文件的步骤(下面以hello.c文件为例)：
首先运行hello.c文件(点击右上角的运行图标)，再点击&#34;C/C&#43;&#43;：gcc.exe生成和调试活动文件&#34;，如图2所示。
图2 运行当前活动文件 经过步骤1，在工作区code文件夹下可以生成一个.vscode\tasks.json文件，如下图3所示。除了tasks.json配置文件外，launch.json、c_cpp_properties.json配置文件也放在.vscode文件夹下。
图3 产生的tasks.json文件 tasks.json文件配置内容如下。在配置路径时只能使用\\或/隔开目录。 { &#34;tasks&#34;: [ { &#34;type&#34;: &#34;cppbuild&#34;, &#34;label&#34;: &#34;C/C&#43;&#43;: gcc.exe 生成活动文件&#34;, &#34;command&#34;: &#34;d:\\AppInstall\\GCCAPP\\mingw64\\bin\\gcc.exe&#34;, &#34;args&#34;: [ &#34;-fdiagnostics-color=always&#34;, &#34;-g&#34;, &#34;${file}&#34;, &#34;-o&#34;, &#34;${fileDirname}\\${fileBasenameNoExtension}.exe&#34; ], &#34;options&#34;: { &#34;cwd&#34;: &#34;d:\\AppInstall\\GCCAPP\\mingw64\\bin&#34; // &#34;cwd&#34;: &#34;${fileDirname}&#34;：有时候&#34;cwd&#34;的值为：&#34;${fileDirname}&#34; }, &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-16T23:27:28+08:00">
    <meta property="article:modified_time" content="2024-07-16T23:27:28+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">在VScode下配置C/C&#43;&#43;环境(tasks.json、launch.json、c_cpp_properties.json)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1_tasksjsonlaunchjson_1" rel="nofollow">1. tasks.json、launch.json配置文件中参数(属性)的说明</a></li><li><a href="#2_tasksjson_27" rel="nofollow">2. tasks.json介绍</a></li><li><a href="#3_launchjson_80" rel="nofollow">3. launch.json介绍</a></li><li><a href="#4_tasksjsonlaunchjson_142" rel="nofollow">4. 直接生成tasks.json、launch.json配置文件的另外一种方式</a></li><li><a href="#5_c_cpp_propertiesjson_151" rel="nofollow">5. c_cpp_properties.json介绍</a></li><li><a href="#6_CC_194" rel="nofollow">6. 运行多个C/C++文件</a></li><li><a href="#7_C_281" rel="nofollow">7. 命令行方式编译C++</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1_tasksjsonlaunchjson_1"></a>1. tasks.json、launch.json配置文件中参数(属性)的说明</h2> 
<p>  首先我们创建了一个code项目，然后在code文件夹下分别建立了day1和day2两个目录(文件夹)，最后在day1和day2文件夹下分别创建<code>hello.c</code>和<code>main.cpp</code>两个文件，code项目的组织结构如下图1所示。在VScode中，默认情况下code文件夹是一个workspace(工作区、工作空间)。</p> 
<p><img src="https://images2.imgbox.com/22/61/we2xeCSz_o.png" alt="在这里插入图片描述"></p> 
<center>
  图1 code项目的组织结构 
</center> 
<p>  下面，我们基于上面code项目的组织结构对tasks.json、launch.json配置文件中的参数(属性)进行说明。（以hello.c文件为例）</p> 
<p>（1）<code>${workspaceFolder}</code>：表示当前workspace(工作区、工作空间)文件夹的路径，也即当前项目绝对路径。例如：<code>D:\code</code>，code就是一个工作区。<br> （2）<code>${fileDirname}</code>：表示当前打开文件的绝对路径，但不包括文件名。例如打开hello.c文件，该文件所在的绝对路径(<code>${fileDirname}</code>)为：<code>D:\code\day1</code>，day1就是hello.c文件的目录。<br> （3）<code>${workspaceFolder}/**</code>：表示当前workspace(工作区、工作空间)文件夹的路径，而且还会递归搜索所有子目录。例如：当前项目的绝对路径为<code>D:\code</code>，不仅要搜索code文件夹，还会递归搜索code的所有子目录（子文件夹）。<br> （4）<code>${workspaceRootFolderName}</code>：表示workspace(工作区、工作空间)文件夹名字，也就是当前项目所在文件夹名字，例如code文件夹。<br> （5）<code>${file}</code>：表示当前打开的文件，指的是当前活动文件。包括绝对路径，文件名，文件后缀名。例如：<code>D:\code\day1\hello.c</code>。<br> （6）<code>${fileBasename}</code>：当前打开含有后缀的文件名，不包括路径。<br> （7）<code>${fileBasenameNoExtension}</code>：表示当前打开的文件名，但不包括路径和后缀名。<br> （8）<code>cwd</code>(current working directory)：当前工作目录，它是操作系统当前正在运行进程所在的目录。在命令行界面(比如，cmd)中，用户输入命令时，默认情况下会在cwd下执行。</p> 
<p>更多命令参考：<a href="https://code.visualstudio.com/docs/editor/variables-reference" rel="nofollow">变量参考</a><br> <strong>参考文章</strong><br> <a href="https://blog.csdn.net/thefg/article/details/137474276">最新VS code配置C/C++环境(tasks.json, launch.json,c_cpp_properties.json)及运行多个文件、配置Cmake</a><br> （上面这篇文章介绍的比较详细，我下面总结的大部分内容都摘抄于该文章，非常感谢该博主）</p> 
<h2><a id="2_tasksjson_27"></a>2. tasks.json介绍</h2> 
<p>  tasks.json在<strong>编译</strong>时用的到，配置tasks.json文件的步骤(下面以hello.c文件为例)：</p> 
<ol><li>首先运行hello.c文件(点击右上角的<strong>运行图标</strong>)，再点击"<strong>C/C++：gcc.exe生成和调试活动文件</strong>"，如图2所示。<br> <img src="https://images2.imgbox.com/d8/54/4f4YEr3y_o.png" alt="在这里插入图片描述"></li></ol> 
<center>
  图2 运行当前活动文件 
</center> 
<ol start="2"><li>经过步骤1，在工作区code文件夹下可以生成一个<code>.vscode\tasks.json</code>文件，如下图3所示。除了tasks.json配置文件外，launch.json、c_cpp_properties.json配置文件也放在<code>.vscode</code>文件夹下。<br> <img src="https://images2.imgbox.com/bb/73/8gFk1sf5_o.png" alt="在这里插入图片描述"></li></ol> 
<center>
  图3 产生的tasks.json文件 
</center> 
<ol start="3"><li>tasks.json文件配置内容如下。在配置路径时只能使用<code>\\</code>或<code>/</code>隔开目录。</li></ol> 
<pre><code>{
    "tasks": [
        {
            "type": "cppbuild",
            "label": "C/C++: gcc.exe 生成活动文件",
            "command": "d:\\AppInstall\\GCCAPP\\mingw64\\bin\\gcc.exe",
            "args": [
                "-fdiagnostics-color=always",
                "-g",
                "${file}",
                "-o",
                "${fileDirname}\\${fileBasenameNoExtension}.exe"
            ],
            "options": {
                "cwd": "d:\\AppInstall\\GCCAPP\\mingw64\\bin"
                // "cwd": "${fileDirname}"：有时候"cwd"的值为："${fileDirname}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "调试器生成的任务。"
        }
    ],
    "version": "2.0.0"
}
</code></pre> 
<p>下面对tasks.json文件中的参数进行介绍：<br> （1）“type”：任务类型，可以取cppbuild、shell、process，三种执行时稍有差异，这里选择默认cppbuild。<br> （2）“label”：任务标签(标记)，也称任务名称，对应的值可以更改。tasks.json文件中label对应的值要和launch.json里面"preLaunchTask"对应的值一致。<br> （3）“command”：编译器及其路径。<code>.c</code>用gcc.exe编译器(C语言编译器)，<code>.cpp</code>用g++.exe编译器(C++语言编译器)，还可以是Cmake、make。<br> （4）“args”：方括号里面是传给gcc命令或g++命令的一系列参数，用于实现某些功能。<br> （5）“-g”：生成和调试有关的信息，launch.json会用到这些信息。如果少了这个"-g"，生成的可执行文件就不能被调试了。<br> （6）“${file}”：编译当前打开的.c(或.cpp)文件，此处是hello.c文件。<br> （7） “-o”：指定编译的输出，windows系统下输出.exe文件。<br> （8）<code>"${fileDirname}\\${fileBasenameNoExtension}.exe"</code>：表示在当前工作目录下生成一个与源代码同名的可执行文件，即在day1目录下生成一个hello.exe文件。如果将<code>${fileDirname}</code>修改为<code>${workspaceFolder}</code>，那么就会在当前工作区code文件夹下生成一个hello.exe文件。也可以在工作区code文件夹中建立一个bin文件夹，接着将编译后输出的可执行文件路径设置为：<code>"${fileDirname}\\bin\\${fileBasenameNoExtension}.exe"</code>。同时需要将launch.json文件中的参数"program"设置为：<code>"${fileDirname}\\bin\\${fileBasenameNoExtension}.exe"</code>。那么就会在bin文件夹下生成一个可执行文件(.exe)。</p> 
<h2><a id="3_launchjson_80"></a>3. launch.json介绍</h2> 
<p>   launch.json文件主要用于<strong>运行和调试</strong>的配置，具有程序启动调试功能。launch.json文件会启用tasks.json的任务，并能实现调试功能。</p> 
<ol><li>单击左侧栏<strong>运行和调试图标</strong>，再点击<strong>创建launch.json文件</strong>选项，会在右侧出现<strong>选择调试器</strong>菜单。接着单击<strong>C++(GDB/LLDB)</strong>，这里的GDB、LLDB是可以作为C/C++的调试器(debugger)。具体实现过程如下图4所示。<br> <img src="https://images2.imgbox.com/42/f6/l6HeHFRS_o.png" alt="在这里插入图片描述"></li></ol> 
<center>
  图4 launch.json文件生成过程 
</center> 
<ol start="2"><li>执行完步骤1，会在工作区code中的.vscode文件夹里面生成一个launch.json配置文件。这里的launch.json文件是首次配置，默认为空，如下图5所示。<br> <img src="https://images2.imgbox.com/b1/72/f3F5X9Gq_o.png" alt="在这里插入图片描述"></li></ol> 
<center>
  图5 launch.json文件中的内容 
</center> 
<ol start="3"><li>在configurations的中括号里进行配置launch.json文件，配置的内容如下。</li></ol> 
<pre><code>{
    "configurations": [
        {
            "name": "C/C++: gcc.exe 生成和调试活动文件",
            "type": "cppdbg",
            "request": "launch",
            "program": "${fileDirname}\\${fileBasenameNoExtension}.exe",
            "args": [],
            "stopAtEntry": false,
            "cwd": "d:\\AppInstall\\GCCAPP\\mingw64\\bin",
            // 有时候 "cwd"为: "${fileDirname}"或"${workspaceFolder}"
            "environment": [],
            "externalConsole": false,
            "MIMode": "gdb",
            "miDebuggerPath": "d:\\AppInstall\\GCCAPP\\mingw64\\bin\\gdb.exe",
            "setupCommands": [
                {
                    "description": "为 gdb 启用整齐打印",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                },
                {
                    "description": "将反汇编风格设置为 Intel",
                    "text": "-gdb-set disassembly-flavor intel",
                    "ignoreFailures": true
                }
            ],
            "preLaunchTask": "C/C++: gcc.exe 生成活动文件"
        }
    ],
    "version": "2.0.0"
}
</code></pre> 
<p>下面对launch.json文件中的参数进行介绍：<br> （1）“name”：自定义命名运行与调式的名称，将在左侧<strong>运行和调试</strong>的菜单中显示名称，如下图6所示。<br> <img src="https://images2.imgbox.com/5c/ed/reR28pTX_o.png" alt="在这里插入图片描述"></p> 
<center>
  图6 运行与调式的名称 
</center> 
<p>（2）“type”：配置类型，调试器类型，cppdbg为C/C++的调试类型。<br> （3）“request”：配置请求类型，可以为launch（启动）或attach（附加）。<br> （4）“program”：在windows系统下需要进行调试的可执行文件(.exe文件)及其路径，应该与tasks.json编译后输出的可执行文件(.exe文件)及其路径一致。<br> （5）“args”：程序调试时传递给程序的命令行参数，一般设为空即可，这里提到的程序实际就上面的.exe文件。<br> （6）“stopAtEntry”：设为true时程序将暂停在程序入口处，一般设置为false。<br> （7）“cwd”：当前工作目录(路径)。<br> （8）“environment”：添加到程序的环境变量。<br> （9）“externalConsole”：true开启外部控制台窗口，false会使用vscode内部控制台窗口。<br> （10）“MIMode”：指示 MIDebugEngine 要连接到的控制台调试程序，允许的值为 “gdb”、“lldb”。这里使用gdb进行调试。<br> （10）“miDebuggerPath”：调试器debugger文件及其路径，这里是调用gdb调试器的路径。<br> （11）“preLaunchTask”：运行和调式前要启动的tasks任务，也即要启动的编译任务，任务名要和tasks.json里面的"label"值对应一致。</p> 
<h2><a id="4_tasksjsonlaunchjson_142"></a>4. 直接生成tasks.json、launch.json配置文件的另外一种方式</h2> 
<ol><li>点击右上方的<strong>添加调试配置</strong>按钮，接着再点击"C/C++：gcc.exe生成和调试活动文件"，如下图7所示。<br> <img src="https://images2.imgbox.com/37/ae/HT27hl7h_o.png" alt="在这里插入图片描述"></li></ol> 
<center>
  图7 生成tasks.json、launch.json配置文件的过程 
</center> 
<ol start="2"><li>经过步骤1可以在.vscode文件夹中生成tasks.json、launch.json这两个配置文件，如下图8所示。<br> <img src="https://images2.imgbox.com/1e/9f/pOR1cRlj_o.png" alt="在这里插入图片描述"></li></ol> 
<center>
  图8 .vscode文件夹中的tasks.json、launch.json文件 
</center> 
<h2><a id="5_c_cpp_propertiesjson_151"></a>5. c_cpp_properties.json介绍</h2> 
<p>   c_cpp_properties.json文件主要是对编辑环境的配置，是针对IntelliSense(智能感知)引擎的有关配置。intelliSense是各种代码编辑功能的通用术语，包括：代码补全、参数信息提示、快速信息描述提示和成员列表提示等，因而，intelliSense也称为代码提示(code hinting)。<br>    当我们装了C/C++编译器，并在vs code中安装了具有调试功能的C/C++扩展(Extension)后，会自动产生默认的c_cpp_properties.json配置。上面tasks.json、launch.json文件配置完后，我们就能运行C/C++程序了，此时采用默认的c_cpp_properties.json配置。<strong>一般情况下，我们可以不用配置c_cpp_properties.json</strong>，按上面步骤配置完tasks.json、launch.json后就可以运行代码了。但如果我们要指定头文件(.h文件)、库的位置，那么就需要配置<strong>c_cpp_properties.json、tasks.json</strong>文件。<br>    我们可以通过快捷键<code>Ctrl+Shift+P</code>打开命令面板，接着输入关键词<code>C/C++编辑配置 </code>，之后会弹出C/C++编辑配置(JSON)和C/C++编辑配置(UI)两种选项，如下图所示。<br> <img src="https://images2.imgbox.com/5c/60/C4JuhwtE_o.png" alt="在这里插入图片描述"><br> （1）C/C++编辑配置(JSON)是c_cpp_properties.json文件形式的设置，单击该选项就会在.vscode文件夹下生成一个c_cpp_properties.json配置文件；<br> （2）C/C++编辑配置(UI)可以通过一个可视化界面来手动设置，当我们单击 C/C++编辑配置(UI) 选项时，就会自动在.vscode文件夹下生成一个c_cpp_properties.json配置文件。我们可以<strong>C/C++配置</strong> 菜单下来制定编译器路径，如下图所示。<br> <img src="https://images2.imgbox.com/33/83/J7Uitdj1_o.png" alt="在这里插入图片描述"><br> （3）c_cpp_properties.json配置文件的默认配置如下：</p> 
<pre><code>{
    "configurations": [
        {
            "name": "Win32",
            "includePath": [
                "${workspaceFolder}/**"
            ],
            "defines": [
                "_DEBUG",
                "UNICODE",
                "_UNICODE"
            ],
            "cStandard": "c17",
            "cppStandard": "gnu++14",
            "intelliSenseMode": "windows-gcc-x64",
            "compilerPath": "D:/AppInstall/GCCAPP/mingw64/bin/gcc.exe"
        }
    ],
    "version": 4
}
</code></pre> 
<p>文件中的参数介绍如下：</p> 
<ul><li>“name”：名称。操作系统根据这个名称识别对应的属性配置，windows系统：Win32；Linux系统：Linux；macOS系统：Mac。</li><li>“includePath”：头文件路径。以便IntelliSense(智能感知)引擎的搜索。</li><li><code>"${workspaceFolder}/**"</code>：当前项目所在根目录并递归搜索子目录，也就是当前工作区文件夹的路径(例如：D:\code)，而且还会递归查找其所有的子目录。</li><li>“defines”：IntelliSense(智能感知)引擎在分析文件时要使用的预处理器定义列表。</li><li>“cStandard”：用于IntelliSense(智能感知)引擎的c标准(版本)。</li><li>“cppStandard”：用于IntelliSense(智能感知)引擎的c++标准(版本)。</li><li>“intelliSenseMode”：IntelliSense(智能感知)的模式。</li><li>“compilerPath”：根据该路径查询编译器(gcc.exe、g++.exe)，以便启用更加准确的IntelliSense(智能感知)。<strong>这里并不是调用编译器，真正启用编译器编译的是在tasks.json文件里</strong>。</li></ul> 
<h2><a id="6_CC_194"></a>6. 运行多个C/C++文件</h2> 
<p>   按照上面步骤配置好tasks.json、launch.json文件后，我们就可以编译运行C/C++程序，只不过此时只能编译运行一个C/C++源文件。如果我们编写的主程序需要调用其它文件的函数，也就是要编译多个文件时，task.json文件中的<code>"${file}"</code>是不能实现多文件编译的，因为<code>"${file}"</code>表示当前打开的C/C++源文件，也就是说只能编译一个C/C++源文件。那这时候该咋办啊，我好怕怕啊，救命啊。不要慌不要急，下面给出解决方案。<br>   我们以<code>图1 code项目的组织结构</code>为基础，在工作区code文件夹的day1文件夹下创建<code>hello.c、func.c、sum.h</code>这个文件，如下图9所示。<br> <img src="https://images2.imgbox.com/71/86/9JBoCJcm_o.png" alt="在这里插入图片描述"><br> <strong>其中hello.c文件为</strong>：</p> 
<pre><code class="prism language-C++">#include &lt;stdio.h&gt;
#include "sum.h"
int main()
{
    printf("hello C");
    int s = sum(1,2);
    printf("sum = %d", s);
    return 0;
}
</code></pre> 
<p><strong>func.c文件为</strong>：</p> 
<pre><code class="prism language-C++">int sum(int a, int b){

    return a+b;
}
</code></pre> 
<p><strong>sum.h文件为</strong>：</p> 
<pre><code class="prism language-C++">int sum(int a, int b);
</code></pre> 
<p>  解决方案的中心思想是：<strong>你在编译的时候用到几个C/C++源文件，那么在tasks.json配置文件中就添加相应数量的C/C++源文件路径</strong>。<strong>C/C++源文件路径添加的位置在tasks.json文件下"args"参数中</strong>，即：</p> 
<pre><code>"args": [	     
                 ...
                "-g",
      //在"-g"和"-o"之间添加编译时用到的C/C++源文件路径
                "-o",
                 ...
            ]
</code></pre> 
<p>（1）第一种方法：将<code>"${file}"、"${fileDirname}\\func.c"</code>添加进去。<code>"${file}"</code>表示当前打开的活动文件，也就是hello.c文件路径；<code>"${fileDirname}\\func.c"</code>表示func.c文件路径。<br> （2）第二种方法：将<code>"${file}"、"${workspaceFolder}\\day1\\func.c"</code>添加进去；<code>"${workspaceFolder}\\day1\\func.c"</code>表示func.c文件路径。<br> （3）第三种方法：前两种方法需要手动地将每个源文件路径添加进去，太麻烦了。所以可以将<code>"${fileDirname}\\*.c"</code>添加进去，此命令相当于把所有后缀名为.c的文件路径都添加进去。<br> （4）如果是C++源文件，将后缀名".c"换成".cpp"即可。<br> （5）tasks.json配置文件中的内容更改如下，launch.json保持不变。</p> 
<pre><code>{
    "tasks": [
        {
            "type": "cppbuild",
            "label": "C/C++: gcc.exe 生成活动文件",
            "command": "d:\\AppInstall\\GCCAPP\\mingw64\\bin\\gcc.exe",
            "args": [
                "-fdiagnostics-color=always",
                "-g",
                // 第一种方法：
                "${file}",
                "${fileDirname}\\func.c",

                // 第二种方法：
                // "${file}",
                // "${workspaceFolder}\\day1\\func.c",

                // 第三种方法：
                // "${fileDirname}\\*.c",
                "-o",
                "${fileDirname}\\${fileBasenameNoExtension}.exe"
            ],
            "options": {
                "cwd": "d:\\AppInstall\\GCCAPP\\mingw64\\bin"
                // "cwd": "${fileDirname}"：有时候"cwd"的值为："${fileDirname}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "调试器生成的任务。"
        }
    ],
    "version": "2.0.0"
}
</code></pre> 
<h2><a id="7_C_281"></a>7. 命令行方式编译C++</h2> 
<p>（1）编译单个C++文件：<code>g++ -g "C++源文件" -o 编译生成的可执行文件</code>，例如：<code>g++ -g .\main.cpp -o main.exe</code>。<br> （2）编译多个C++文件：<code>g++ -g "C++源文件1" "C++源文件2" ... "C++源文件n" -o 编译生成的可执行文件</code>，例如：<code>g++ -g a.cpp b.cpp c.cpp -o multi_file.exe</code>。<br> （3）上面生成的可执行文件后缀名(.exe)可以省略。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fd028dcf78ee339b9f7f41421e6756ff/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;必修：深入探索多态的奥秘</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9894b9b576909cb7f6dc19aa89939cd3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux的学习（七）：读取，函数，正则表达式，文本处理工具cut和awk</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>