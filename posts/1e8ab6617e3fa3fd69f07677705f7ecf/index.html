<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Java】了解异常 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/1e8ab6617e3fa3fd69f07677705f7ecf/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【Java】了解异常">
  <meta property="og:description" content="初始异常 我们平时应该已经接触过一些 “异常” 了，这里列举一些例子。
算术异常：
数组下标越界异常：
访问空指针异常：
所谓异常指的就是程序在 运行时 出现错误时通知调用者的一种机制。
异常的基本用法 捕获异常 try{
有可能出现异常的语句 ;
}[catch (异常类型 异常对象) {
} ... ]
[finally {
异常的出口
}]
try 代码块中放的是可能出现异常的代码.catch 代码块中放的是出现异常后的处理行为.ﬁnally 代码块中的代码用于处理善后工作, 会在最后执行.其中 catch 和 ﬁnally 都可以根据情况选择加或者不加. 使用处理异常的好处 不处理异常：
我们能够发现若是不处理异常的话程序遇到异常时候就会终止进程。
如果我们想要使程序遇到异常之后还能运行下去就得处理异常。
处理异常：
我们发现, 一旦 try 中出现异常, 那么 try 代码块中的程序就不会继续执行, 而是交给 catch 中的代码来执行. catch 执行完毕会继续往下执行 。
catch 也可以有多个
public class Test1 { public static void main(String[] args) { int[] array = {1,2,3,4}; try{ System.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-07T23:13:58+08:00">
    <meta property="article:modified_time" content="2024-07-07T23:13:58+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Java】了解异常</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>初始异常</h2> 
<p>我们平时应该已经接触过一些 “异常” 了，这里列举一些例子。</p> 
<p>算术异常：</p> 
<p><img alt="" height="548" src="https://images2.imgbox.com/a3/42/5odnXxPe_o.png" width="1200"></p> 
<p> 数组下标越界异常：</p> 
<p><img alt="" height="535" src="https://images2.imgbox.com/4e/ef/ftaGha0h_o.png" width="1200"></p> 
<p>访问空指针异常：</p> 
<p><img alt="" height="730" src="https://images2.imgbox.com/ef/93/JSBQzBtP_o.png" width="1200"></p> 
<p></p> 
<p> 所谓异常指的就是程序在 运行时 出现错误时通知调用者的一种机制。</p> 
<h2>异常的基本用法</h2> 
<h3>捕获异常</h3> 
<blockquote> 
 <p>try{<!-- --><br> 有可能出现异常的语句 ;<br> }[catch (异常类型 异常对象) {<!-- --><br> } ... ]<br> [finally {<!-- --><br> 异常的出口<br> }]</p> 
</blockquote> 
<ul><li> try 代码块中放的是可能出现异常的代码.</li><li>catch 代码块中放的是出现异常后的处理行为.</li><li>ﬁnally 代码块中的代码用于处理善后工作, 会在最后执行.</li><li>其中 catch 和 ﬁnally 都可以根据情况选择加或者不加.</li></ul> 
<h3>使用处理异常的好处</h3> 
<p>不处理异常：</p> 
<p><img alt="" height="660" src="https://images2.imgbox.com/96/17/wIihtFaq_o.png" width="1200"></p> 
<p>我们能够发现若是不处理异常的话程序遇到异常时候就会终止进程。</p> 
<p>如果我们想要使程序遇到异常之后还能运行下去就得处理异常。</p> 
<p>处理异常：</p> 
<p><img alt="" height="929" src="https://images2.imgbox.com/8b/87/voxXKHLS_o.png" width="1200"></p> 
<p>我们发现, 一旦 try 中出现异常, 那么 try 代码块中的程序就不会继续执行, 而是交给 catch 中的代码来执行. catch 执行完毕会继续往下执行 。</p> 
<p>catch 也可以有多个</p> 
<pre><code class="language-java">public class Test1 {
    public static void main(String[] args) {
       int[] array = {1,2,3,4};
        try{
            System.out.println("before");
            System.out.println(array[10]);
            System.out.println("end");
        }catch (ArrayIndexOutOfBoundsException e){
            System.out.println("这是数组越界异常");
            e.printStackTrace();
        }catch (NullPointerException e){
            System.out.println("这是空指针异常");
        }
        System.out.println("after try catch");
    }
}</code></pre> 
<p>如果多个异常的处理方式是完全相同, 也可以写成这样：</p> 
<blockquote> 
 <p>catch (ArrayIndexOutOfBoundsException | NullPointerException e) {<!-- --><br> ...<br> }</p> 
</blockquote> 
<p>也可以用一个 catch 捕获所有异常(不推荐)</p> 
<pre><code class="language-java">public class Test1 {
    public static void main(String[] args) {
       int[] array = {1,2,3,4};
        try{
            System.out.println("before");
            System.out.println(array[10]);
            System.out.println("end");
        }catch (Exception e){
            System.out.println("出现异常");
            e.printStackTrace();
        }
        System.out.println("after try catch");
    }
}</code></pre> 
<p> ﬁnally 表示最后的善后工作, 例如释放资源</p> 
<pre><code class="language-java">int[] arr = {1, 2, 3};
try {
   System.out.println("before");
   arr = null;
   System.out.println(arr[100]);
   System.out.println("after");
} catch (Exception e) {
   e.printStackTrace();
} finally {
   System.out.println("finally code");
}</code></pre> 
<p>无论是否存在异常, ﬁnally 中的代码一定都会执行到. 保证最终一定会执行到 Scanner 的 close 方法</p> 
<h3> 异常处理流程</h3> 
<ul><li>程序先执行 try 中的代码</li><li>如果 try 中的代码出现异常, 就会结束 try 中的代码, 看和 catch 中的异常类型是否匹配.</li><li>如果找到匹配的异常类型, 就会执行 catch 中的代码</li><li>如果没有找到匹配的异常类型, 就会将异常向上传递到上层调用者.</li><li>无论是否找到匹配的异常类型, ﬁnally 中的代码都会被执行到(在该方法结束之前执行).</li><li>如果上层调用者也没有处理的了异常, 就继续向上传递.</li><li>一直到 main 方法也没有合适的代码处理异常, 就会交给 JVM 来进行处理, 此时程序就会异常终止</li></ul> 
<h3>抛出异常</h3> 
<p>除了 Java 内置的类会抛出一些异常之外, 我们也可以手动抛出某个异常. 使用 throw 关键字完成这个操作</p> 
<p><img alt="" height="618" src="https://images2.imgbox.com/b3/51/nVK9SLeq_o.png" width="1200"></p> 
<h3> 异常说明</h3> 
<ul><li>我们在处理异常的时候, 通常希望知道这段代码中究竟会出现哪些可能的异常.</li><li>我们可以使用 throws 关键字, 把可能抛出的异常显式的标注在方法定义的位置. 从而提醒调用者要注意捕获这些异常</li></ul> 
<p><img alt="" height="528" src="https://images2.imgbox.com/73/58/W8jvr3XB_o.png" width="1195"></p> 
<h3>关于finally</h3> 
<p>ﬁnally 中的代码保证一定会执行到. 这也会带来一些麻烦 。</p> 
<p>注意:<br> ﬁnally 执行的时机是在方法返回之前(try 或者 catch 中如果有 return 会在这个 return 之前执行 ﬁnally). 但是如果ﬁnally 中也存在 return 语句, 那么就会执行 ﬁnally 中的 return, 从而不会执行到 try 中原有的 return。所以我们一般不建议在finally中使用return。</p> 
<h2>Java中的异常体系</h2> 
<p>下图表示 Java 内置的异常类之间的继承关系：</p> 
<p><img alt="" height="657" src="https://images2.imgbox.com/47/29/sKwDil9m_o.png" width="320"></p> 
<ul><li> 顶层类 Throwable 派生出两个重要的子类, Error 和 Exception</li><li>其中 Error 指的是 Java 运行时内部错误和资源耗尽错误. 应用程序不抛出此类异常. 这种内部错误一旦出现，</li><li>除了告知用户并使程序终止之外, 再无能无力. 这种情况很少出现.</li><li>Exception 是我们所使用的异常类的父类.</li><li>其中 Exception 有一个子类称为 RuntimeException , 这里面又派生出很多我们常见的异常类</li><li>NullPointerException , IndexOutOfBoundsException 等</li></ul> 
<h2>自定义异常类</h2> 
<p>Java 中虽然已经内置了丰富的异常类, 但是我们实际场景中可能还有一些情况需要我们对异常类进行扩展, 创建符合我们实际情况的异常。</p> 
<p>我们模拟实现一个登录过程：</p> 
<pre><code class="language-java">class UserError extends Exception {
    public UserError(String message) {
        super(message);
    }
}
class PasswordError extends Exception {
    public PasswordError(String message) {
        super(message);
    }
}
public class Test1 {
    public static String userName = "admin";
    public static String password = "123456";
    public static void login(String userName, String password) throws UserError,
            PasswordError {
        if (!Test1.userName.equals(userName)) {
            throw new UserError("用户名错误");
        }
        if (!Test1.password.equals(password)) {
            throw new PasswordError("密码错误");
        }
        System.out.println("登陆成功");
    }
    public static void main(String[] args) {
        try {
            login("admin", "123456");
        } catch (UserError userError) {
            userError.printStackTrace();
        } catch (PasswordError passwordError) {
            passwordError.printStackTrace();
        }
    }
}</code></pre> 
<p><strong>注意事项：</strong></p> 
<ul><li>自定义异常通常会继承自 Exception 或者 RuntimeException</li><li>继承自 Exception 的异常默认是受查异常</li><li>继承自 RuntimeException 的异常默认是非受查异常</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f8e5ab573ed245f422cacf8d4c8cac46/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【植物大战僵尸杂交版】获取&#43;存档插件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/727ebe16a4b4133933e2606bed2f05e7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java算法day8</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>