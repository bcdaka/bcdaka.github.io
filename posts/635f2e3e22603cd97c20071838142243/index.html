<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Activiti7系列】基于Spring Security的Activiti7工作流管理系统简介及实现（附源码）（下篇） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/635f2e3e22603cd97c20071838142243/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【Activiti7系列】基于Spring Security的Activiti7工作流管理系统简介及实现（附源码）（下篇）">
  <meta property="og:description" content="作者：后端小肥肠
上篇：【Activiti7系列】基于Spring Security的Activiti7工作流管理系统简介及实现（上篇）_spring security activiti7-CSDN博客
目录
1.前言
2. 核心代码
2.1. 流程定义模型管理
2.1.1. 新增流程定义模型数据
2.1.2. 通过流程定义模型id部署流程定义
2.1.3. 导出流程定义模型zip压缩包
2.2. 流程定义管理
2.2.1. 更新流程状态：激活（启动）或者挂起（暂停）
2.2.2. 导出流程定义文件（xml,png)
2.2.3. 上传zip、bpmn、xml后缀的文件来进行部署流程定义
2.3. 流程配置管理
2.4. 流程实例管理
2.4.1. 提交申请，启动流程实例
2.4.2. 撤回申请
2.4.3. 挂起或激活流程实例
2.4.4. 通过流程实例id获取历史流程图
2.4.5. 通过流程实例id获取任务办理历史记录
2.5. 任务管理
2.5.1. 查询当前用户的待办任务
2.5.2. 获取目标节点（下一个节点）
2.5.3. 完成任务
2.5.4. 获取历史任务节点，用于驳回功能
2.5.5. 驳回历史节点
2.6. 请假申请管理
3. 源码地址
4. 结语
1.前言 在《基于Spring Security的Activiti7工作流管理系统简介及实现（上篇）》中，向大家展示了工作流管理系统的功能界面及模块，具体应用场景，在本文中将会讲解该工作流管理系统实现的具体技术细节及核心代码。
本文面向人群为有工作流基础的后端人员，如对您有帮助请三连支持一下小肥肠~
2. 核心代码 本章只做代码简介（部分代码，简单的crud不介绍）及核心代码讲解，文末会提供源代码链接（仅后端）。
2.1. 流程定义模型管理 流程定义模型管理对应前端的模型管理界面，相关接口包括新增流程定义模型数据、条件分页查询流程定义模型数据、通过流程定义模型id部署流程定义、导出流程定义模型zip压缩包、删除流程定义模型。
2.1.1. 新增流程定义模型数据 public Result add(ModelAddREQ req) throws Exception { /*String name = &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-10T18:21:03+08:00">
    <meta property="article:modified_time" content="2024-06-10T18:21:03+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Activiti7系列】基于Spring Security的Activiti7工作流管理系统简介及实现（附源码）（下篇）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p id="articleContentId"><span style="color:#4da8ee;"><strong>作者：后端小肥肠</strong></span></p> 
 <p>上篇：<a href="https://blog.csdn.net/c18213590220/article/details/136966219?spm=1001.2014.3001.5501" title="【Activiti7系列】基于Spring Security的Activiti7工作流管理系统简介及实现（上篇）_spring security activiti7-CSDN博客">【Activiti7系列】基于Spring Security的Activiti7工作流管理系统简介及实现（上篇）_spring security activiti7-CSDN博客</a></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:40px;"></p> 
<p id="1.%E5%89%8D%E8%A8%80-toc" style="margin-left:40px;"><a href="#1.%E5%89%8D%E8%A8%80" rel="nofollow">1.前言</a></p> 
<p id="2.%20%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#2.%20%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81" rel="nofollow">2. 核心代码</a></p> 
<p id="2.1.%C2%A0%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8B%E7%AE%A1%E7%90%86-toc" style="margin-left:80px;"><a href="#2.1.%C2%A0%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8B%E7%AE%A1%E7%90%86" rel="nofollow">2.1. 流程定义模型管理</a></p> 
<p id="2.1.1.%20%E6%96%B0%E5%A2%9E%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8B%E6%95%B0%E6%8D%AE-toc" style="margin-left:120px;"><a href="#2.1.1.%20%E6%96%B0%E5%A2%9E%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8B%E6%95%B0%E6%8D%AE" rel="nofollow">2.1.1. 新增流程定义模型数据</a></p> 
<p id="2.1.2.%C2%A0%E9%80%9A%E8%BF%87%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8Bid%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89-toc" style="margin-left:120px;"><a href="#2.1.2.%C2%A0%E9%80%9A%E8%BF%87%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8Bid%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89" rel="nofollow">2.1.2. 通过流程定义模型id部署流程定义</a></p> 
<p id="2.1.3.%20%E5%AF%BC%E5%87%BA%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8Bzip%E5%8E%8B%E7%BC%A9%E5%8C%85-toc" style="margin-left:120px;"><a href="#2.1.3.%20%E5%AF%BC%E5%87%BA%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8Bzip%E5%8E%8B%E7%BC%A9%E5%8C%85" rel="nofollow">2.1.3. 导出流程定义模型zip压缩包</a></p> 
<p id="2.2.%C2%A0%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%90%86-toc" style="margin-left:80px;"><a href="#2.2.%C2%A0%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%90%86" rel="nofollow">2.2. 流程定义管理</a></p> 
<p id="2.2.1.%C2%A0%C2%A0%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B%E7%8A%B6%E6%80%81%EF%BC%9A%E6%BF%80%E6%B4%BB%EF%BC%88%E5%90%AF%E5%8A%A8%EF%BC%89%E6%88%96%E8%80%85%E6%8C%82%E8%B5%B7%EF%BC%88%E6%9A%82%E5%81%9C%EF%BC%89-toc" style="margin-left:160px;"><a href="#2.2.1.%C2%A0%C2%A0%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B%E7%8A%B6%E6%80%81%EF%BC%9A%E6%BF%80%E6%B4%BB%EF%BC%88%E5%90%AF%E5%8A%A8%EF%BC%89%E6%88%96%E8%80%85%E6%8C%82%E8%B5%B7%EF%BC%88%E6%9A%82%E5%81%9C%EF%BC%89" rel="nofollow">2.2.1.  更新流程状态：激活（启动）或者挂起（暂停）</a></p> 
<p id="2.2.2.%C2%A0%20%E5%AF%BC%E5%87%BA%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89%E6%96%87%E4%BB%B6%EF%BC%88xml%2Cpng)-toc" style="margin-left:160px;"><a href="#2.2.2.%C2%A0%20%E5%AF%BC%E5%87%BA%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89%E6%96%87%E4%BB%B6%EF%BC%88xml%2Cpng%29" rel="nofollow">2.2.2.  导出流程定义文件（xml,png)</a></p> 
<p id="2.2.3.%20%E4%B8%8A%E4%BC%A0zip%E3%80%81bpmn%E3%80%81xml%E5%90%8E%E7%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%A5%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89-toc" style="margin-left:160px;"><a href="#2.2.3.%20%E4%B8%8A%E4%BC%A0zip%E3%80%81bpmn%E3%80%81xml%E5%90%8E%E7%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%A5%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89" rel="nofollow">2.2.3. 上传zip、bpmn、xml后缀的文件来进行部署流程定义</a></p> 
<p id="2.3.%20%E6%B5%81%E7%A8%8B%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86-toc" style="margin-left:80px;"><a href="#2.3.%20%E6%B5%81%E7%A8%8B%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86" rel="nofollow">2.3. 流程配置管理</a></p> 
<p id="2.4.%20%E6%B5%81%E7%A8%8B%E5%AE%9E%E4%BE%8B%E7%AE%A1%E7%90%86-toc" style="margin-left:80px;"><a href="#2.4.%20%E6%B5%81%E7%A8%8B%E5%AE%9E%E4%BE%8B%E7%AE%A1%E7%90%86" rel="nofollow">2.4. 流程实例管理</a></p> 
<p id="2.4.1.%C2%A0%E6%8F%90%E4%BA%A4%E7%94%B3%E8%AF%B7%EF%BC%8C%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%AE%9E%E4%BE%8B-toc" style="margin-left:120px;"><a href="#2.4.1.%C2%A0%E6%8F%90%E4%BA%A4%E7%94%B3%E8%AF%B7%EF%BC%8C%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%AE%9E%E4%BE%8B" rel="nofollow">2.4.1. 提交申请，启动流程实例</a></p> 
<p id="2.4.2.%C2%A0%E6%92%A4%E5%9B%9E%E7%94%B3%E8%AF%B7-toc" style="margin-left:120px;"><a href="#2.4.2.%C2%A0%E6%92%A4%E5%9B%9E%E7%94%B3%E8%AF%B7" rel="nofollow">2.4.2. 撤回申请</a></p> 
<p id="2.4.3.%C2%A0%E6%8C%82%E8%B5%B7%E6%88%96%E6%BF%80%E6%B4%BB%E6%B5%81%E7%A8%8B%E5%AE%9E%E4%BE%8B-toc" style="margin-left:120px;"><a href="#2.4.3.%C2%A0%E6%8C%82%E8%B5%B7%E6%88%96%E6%BF%80%E6%B4%BB%E6%B5%81%E7%A8%8B%E5%AE%9E%E4%BE%8B" rel="nofollow">2.4.3. 挂起或激活流程实例</a></p> 
<p id="2.4.4.%C2%A0%E9%80%9A%E8%BF%87%E6%B5%81%E7%A8%8B%E5%AE%9E%E4%BE%8Bid%E8%8E%B7%E5%8F%96%E5%8E%86%E5%8F%B2%E6%B5%81%E7%A8%8B%E5%9B%BE-toc" style="margin-left:120px;"><a href="#2.4.4.%C2%A0%E9%80%9A%E8%BF%87%E6%B5%81%E7%A8%8B%E5%AE%9E%E4%BE%8Bid%E8%8E%B7%E5%8F%96%E5%8E%86%E5%8F%B2%E6%B5%81%E7%A8%8B%E5%9B%BE" rel="nofollow">2.4.4. 通过流程实例id获取历史流程图</a></p> 
<p id="2.4.5.%20%E9%80%9A%E8%BF%87%E6%B5%81%E7%A8%8B%E5%AE%9E%E4%BE%8Bid%E8%8E%B7%E5%8F%96%E4%BB%BB%E5%8A%A1%E5%8A%9E%E7%90%86%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95-toc" style="margin-left:120px;"><a href="#2.4.5.%20%E9%80%9A%E8%BF%87%E6%B5%81%E7%A8%8B%E5%AE%9E%E4%BE%8Bid%E8%8E%B7%E5%8F%96%E4%BB%BB%E5%8A%A1%E5%8A%9E%E7%90%86%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95" rel="nofollow">2.4.5. 通过流程实例id获取任务办理历史记录</a></p> 
<p id="2.5.%20%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-toc" style="margin-left:80px;"><a href="#2.5.%20%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86" rel="nofollow">2.5. 任务管理</a></p> 
<p id="2.5.1.%C2%A0%C2%A0%E6%9F%A5%E8%AF%A2%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7%E7%9A%84%E5%BE%85%E5%8A%9E%E4%BB%BB%E5%8A%A1-toc" style="margin-left:120px;"><a href="#2.5.1.%C2%A0%C2%A0%E6%9F%A5%E8%AF%A2%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7%E7%9A%84%E5%BE%85%E5%8A%9E%E4%BB%BB%E5%8A%A1" rel="nofollow">2.5.1.  查询当前用户的待办任务</a></p> 
<p id="%C2%A02.5.2.%C2%A0%E8%8E%B7%E5%8F%96%E7%9B%AE%E6%A0%87%E8%8A%82%E7%82%B9%EF%BC%88%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%89-toc" style="margin-left:120px;"><a href="#%C2%A02.5.2.%C2%A0%E8%8E%B7%E5%8F%96%E7%9B%AE%E6%A0%87%E8%8A%82%E7%82%B9%EF%BC%88%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%89" rel="nofollow"> 2.5.2. 获取目标节点（下一个节点）</a></p> 
<p id="2.5.3.%C2%A0%E5%AE%8C%E6%88%90%E4%BB%BB%E5%8A%A1-toc" style="margin-left:120px;"><a href="#2.5.3.%C2%A0%E5%AE%8C%E6%88%90%E4%BB%BB%E5%8A%A1" rel="nofollow">2.5.3. 完成任务</a></p> 
<p id="2.5.4.%C2%A0%E8%8E%B7%E5%8F%96%E5%8E%86%E5%8F%B2%E4%BB%BB%E5%8A%A1%E8%8A%82%E7%82%B9%EF%BC%8C%E7%94%A8%E4%BA%8E%E9%A9%B3%E5%9B%9E%E5%8A%9F%E8%83%BD-toc" style="margin-left:120px;"><a href="#2.5.4.%C2%A0%E8%8E%B7%E5%8F%96%E5%8E%86%E5%8F%B2%E4%BB%BB%E5%8A%A1%E8%8A%82%E7%82%B9%EF%BC%8C%E7%94%A8%E4%BA%8E%E9%A9%B3%E5%9B%9E%E5%8A%9F%E8%83%BD" rel="nofollow">2.5.4. 获取历史任务节点，用于驳回功能</a></p> 
<p id="2.5.5.%C2%A0%E9%A9%B3%E5%9B%9E%E5%8E%86%E5%8F%B2%E8%8A%82%E7%82%B9-toc" style="margin-left:120px;"><a href="#2.5.5.%C2%A0%E9%A9%B3%E5%9B%9E%E5%8E%86%E5%8F%B2%E8%8A%82%E7%82%B9" rel="nofollow">2.5.5. 驳回历史节点</a></p> 
<p id="2.6.%20%E8%AF%B7%E5%81%87%E7%94%B3%E8%AF%B7%E7%AE%A1%E7%90%86-toc" style="margin-left:80px;"><a href="#2.6.%20%E8%AF%B7%E5%81%87%E7%94%B3%E8%AF%B7%E7%AE%A1%E7%90%86" rel="nofollow">2.6. 请假申请管理</a></p> 
<p id="3.%20%E6%BA%90%E7%A0%81%E5%9C%B0%E5%9D%80-toc" style="margin-left:40px;"><a href="#3.%20%E6%BA%90%E7%A0%81%E5%9C%B0%E5%9D%80" rel="nofollow">3. 源码地址</a></p> 
<p id="4.%20%E7%BB%93%E8%AF%AD-toc" style="margin-left:40px;"><a href="#4.%20%E7%BB%93%E8%AF%AD" rel="nofollow">4. 结语</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="1.%E5%89%8D%E8%A8%80">1.前言</h3> 
<p style="text-align:justify;">在《基于Spring Security的Activiti7工作流管理系统简介及实现（上篇）》中，向大家展示了工作流管理系统的功能界面及模块，具体应用场景，在本文中将会讲解该工作流管理系统实现的具体技术细节及核心代码。</p> 
<p style="text-align:justify;"><span style="color:#4da8ee;"><strong>本文面向人群为有工作流基础的后端人员，如对您有帮助请三连支持一下小肥肠~</strong></span></p> 
<h3 id="2.%20%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81">2. 核心代码</h3> 
<p><strong><span style="color:#956fe7;">本章只做代码简介（部分代码，简单的crud不介绍）及核心代码讲解，文末会提供源代码链接（仅后端）。</span></strong></p> 
<h4 id="2.1.%C2%A0%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8B%E7%AE%A1%E7%90%86" style="background-color:transparent;">2.1. 流程定义模型管理</h4> 
<p>流程定义模型管理对应前端的模型管理界面，相关接口包括<span style="color:#98c091;"><strong>新增流程定义模型数据</strong></span>、<span style="color:#98c091;"><strong>条件分页查询流程定义模型数据</strong></span>、<span style="color:#98c091;"><strong>通过流程定义模型id部署流程定义</strong></span>、<span style="color:#98c091;"><strong>导出流程定义模型zip压缩包</strong></span>、<span style="color:#98c091;"><strong>删除流程定义模型</strong></span>。</p> 
<p><img alt="" height="922" src="https://images2.imgbox.com/b0/af/TMJYmNPz_o.png" width="1200"></p> 
<h5 id="2.1.1.%20%E6%96%B0%E5%A2%9E%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8B%E6%95%B0%E6%8D%AE" style="background-color:transparent;">2.1.1. 新增流程定义模型数据</h5> 
<pre><code class="language-java">    public Result add(ModelAddREQ req) throws Exception {
        /*String name = "请假流程模型";
        String key = "leaveProcess";
        String desc = "请输入描述信息……";*/
        int version = 0;

        // 1. 初始空的模型
        Model model = repositoryService.newModel();
        model.setName(req.getName());
        model.setKey(req.getKey());
        model.setVersion(version);

        // 封装模型json对象
        ObjectNode objectNode  = objectMapper.createObjectNode();
        objectNode.put(ModelDataJsonConstants.MODEL_NAME, req.getName());
        objectNode.put(ModelDataJsonConstants.MODEL_REVISION, version);
        objectNode.put(ModelDataJsonConstants.MODEL_DESCRIPTION, req.getDescription());
        model.setMetaInfo(objectNode.toString());
        // 保存初始化的模型基本信息数据
        repositoryService.saveModel(model);

        // 封装模型对象基础数据json串
        // {"id":"canvas","resourceId":"canvas","stencilset":{"namespace":"http://b3mn.org/stencilset/bpmn2.0#"},"properties":{"process_id":"未定义"}}
        ObjectNode editorNode = objectMapper.createObjectNode();
        ObjectNode stencilSetNode = objectMapper.createObjectNode();
        stencilSetNode.put("namespace", "http://b3mn.org/stencilset/bpmn2.0#");
        editorNode.replace("stencilset", stencilSetNode);
        // 标识key
        ObjectNode propertiesNode = objectMapper.createObjectNode();
        propertiesNode.put("process_id", req.getKey());
        editorNode.replace("properties", propertiesNode);

        repositoryService.addModelEditorSource(model.getId(), editorNode.toString().getBytes("utf-8"));

        return Result.ok(model.getId());
    }</code></pre> 
<p>上述代码实现了创建一个基于 Activiti 7 的工作流模型的功能。关键步骤包括初始化模型对象，封装模型的元信息和基础数据为 JSON 字符串，以及将该字符串保存到模型编辑器中。最终返回新创建模型的ID作为结果。</p> 
<p><span style="color:#956fe7;"><strong>新增流程定义模型数据</strong></span>主要涉及到了 Activiti 7 中的模型管理相关的表，包括：</p> 
<ol><li><code>ACT_RE_MODEL</code>：用于存储模型的基本信息，如模型名称、键、版本等。</li><li><code>ACT_GE_BYTEARRAY</code>：存储模型编辑器的源数据，即模型对象的基础数据 JSON 字符串。</li></ol> 
<p>这些表存储了创建的工作流模型的信息，包括其名称、键、版本、元信息和基础数据，以便后续的流程定义和流程实例化。</p> 
<h5 id="2.1.2.%C2%A0%E9%80%9A%E8%BF%87%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8Bid%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89" style="background-color:transparent;">2.1.2. 通过流程定义模型id部署流程定义</h5> 
<pre><code class="language-java">    public Result deploy(String modelId) throws Exception {
        // 1. 查询流程定义模型json字节码
        byte[] jsonBytes = repositoryService.getModelEditorSource(modelId);
        if(jsonBytes == null) {
           return Result.error("模型数据为空，请先设计流程定义模型，再进行部署");
        }
        // 将json字节码转为 xml 字节码，因为bpmn2.0规范中关于流程模型的描述是xml格式的，而activiti遵守了这个规范
        byte[] xmlBytes = bpmnJsonXmlBytes(jsonBytes);
        if(xmlBytes == null) {
            return Result.error("数据模型不符合要求，请至少设计一条主线流程");
        }
        // 2. 查询流程定义模型的图片
        byte[] pngBytes = repositoryService.getModelEditorSourceExtra(modelId);

        // 查询模型的基本信息
        Model model = repositoryService.getModel(modelId);

        // xml资源的名称 ，对应act_ge_bytearray表中的name_字段
        String processName = model.getName() + ".bpmn20.xml";
        // 图片资源名称，对应act_ge_bytearray表中的name_字段
        String pngName = model.getName() + "." + model.getKey() + ".png";

        // 3. 调用部署相关的api方法进行部署流程定义
        Deployment deployment = repositoryService.createDeployment()
                .name(model.getName()) // 部署名称
                .addString(processName, new String(xmlBytes, "UTF-8")) // bpmn20.xml资源
                .addBytes(pngName, pngBytes) // png资源
                .deploy();

        // 更新 部署id 到流程定义模型数据表中
        model.setDeploymentId(deployment.getId());
        repositoryService.saveModel(model);

        return Result.ok();
    }</code></pre> 
<p>上述代码实现了根据给定的模型ID部署流程定义的功能。它首先查询模型的 JSON 字节码，并将其转换为符合<span style="color:#98c091;"><strong> BPMN 2.0 </strong></span>规范的 <span style="color:#98c091;"><strong>XML </strong></span>字节码，然后查询模型的图片字节码。接着，通过创建部署对象并添加相应的资源文件进行流程定义的部署，最后更新模型的部署ID，并返回部署成功的结果。 </p> 
<p> <span style="color:#956fe7;"><strong>通过流程定义模型id部署流程定义</strong></span>涉及了 Activiti 7 中的以下几张表：</p> 
<ol><li><code>ACT_RE_MODEL</code>：用于存储模型的基本信息，如模型名称、键、版本等。</li><li><code>ACT_GE_BYTEARRAY</code>：存储模型的编辑器源数据、XML 格式的流程定义文件以及流程图片等资源数据。</li><li><code>ACT_RE_DEPLOYMENT</code>：存储流程部署的相关信息，如部署名称、部署时间等。</li></ol> 
<h5 id="2.1.3.%20%E5%AF%BC%E5%87%BA%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8Bzip%E5%8E%8B%E7%BC%A9%E5%8C%85" style="background-color:transparent;">2.1.3. 导出流程定义模型zip压缩包</h5> 
<pre><code class="language-java">    public void exportZip(String modelId, HttpServletResponse response) {
        ZipOutputStream zipos = null;
        try {
            // 实例化zip输出流
            zipos = new ZipOutputStream(response.getOutputStream());

            // 压缩包文件名
            String zipName = "模型不存在";

            // 1. 查询模型基本信息
            Model model = repositoryService.getModel(modelId);
            if(model != null) {
                // 2. 查询流程定义模型的json字节码
                byte[] bpmnJsonBytes = repositoryService.getModelEditorSource(modelId);
                // 2.1 将json字节码转换为xml字节码
                byte[] xmlBytes = bpmnJsonXmlBytes(bpmnJsonBytes);
                if(xmlBytes == null) {
                    zipName = "模型数据为空-请先设计流程定义模型，再导出";
                }else {
                    // 压缩包文件名
                    zipName = model.getName() + "." + model.getKey() + ".zip";

                    // 将xml添加到压缩包中(指定xml文件名：请假流程.bpmn20.xml ）
                    zipos.putNextEntry(new ZipEntry(model.getName() + ".bpmn20.xml"));
                    zipos.write(xmlBytes);

                    // 3. 查询流程定义模型的图片字节码
                    byte[] pngBytes = repositoryService.getModelEditorSourceExtra(modelId);
                    if(pngBytes != null) {
                        // 图片文件名（请假流程.leaveProcess.png)
                        zipos.putNextEntry(new ZipEntry(model.getName() + "." + model.getKey() + ".png"));
                        zipos.write(pngBytes);
                    }

                }
            }
            response.setContentType("application/octet-stream");
            response.setHeader("Content-Disposition",
                    "attachment; filename=" + URLEncoder.encode(zipName, "UTF-8") + ".zip");
            // 刷出响应流
            response.flushBuffer();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if(zipos != null) {
                try {
                    zipos.closeEntry();
                    zipos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }</code></pre> 
<p>这段代码实现了根据给定的模型ID导出流程定义及相关图片的功能。它首先查询模型的基本信息，包括模型名称和键，然后查询模型的 JSON 字节码，并将其转换为符合 <span style="color:#98c091;"><strong>BPMN 2.0 </strong></span>规范的<span style="color:#98c091;"><strong> XML </strong></span>字节码。接着，将 XML 文件和模型的图片字节码压缩成一个 ZIP 文件，通过 <span style="color:#98c091;"><strong>HttpServletResponse</strong></span> 输出给用户进行下载。 </p> 
<h4 id="2.2.%C2%A0%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89%E7%AE%A1%E7%90%86" style="background-color:transparent;">2.2. 流程定义管理</h4> 
<p>流程定义管理对应前端的流程管理界面，相关接口包括<span style="color:#98c091;"><strong>条件分页查询相同key的最新版本的流程定义列表数据</strong></span>、<span style="color:#98c091;"><strong>更新流程状态：激活（启动）或者挂起（暂停）、删除流程定义</strong></span>、<span style="color:#98c091;"><strong>导出流程定义文件（xml,png)</strong></span>、<span style="color:#98c091;"><strong>上传zip、bpmn、xml后缀的文件来进行部署流程定义</strong></span>。</p> 
<p><img alt="" height="922" src="https://images2.imgbox.com/35/b1/F1HnOoXn_o.png" width="1200"></p> 
<h6 id="2.2.1.%C2%A0%C2%A0%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B%E7%8A%B6%E6%80%81%EF%BC%9A%E6%BF%80%E6%B4%BB%EF%BC%88%E5%90%AF%E5%8A%A8%EF%BC%89%E6%88%96%E8%80%85%E6%8C%82%E8%B5%B7%EF%BC%88%E6%9A%82%E5%81%9C%EF%BC%89" style="background-color:transparent;">2.2.1.  更新流程状态：激活（启动）或者挂起（暂停）</h6> 
<p>前端界面：</p> 
<p><img alt="" height="922" src="https://images2.imgbox.com/ec/4a/epWklOvk_o.png" width="1200"></p> 
<p>后端代码： </p> 
<pre><code class="language-java">    public Result updateProcDefState(String ProcDefiId) {
        ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery()
                .processDefinitionId(ProcDefiId)
                .singleResult();
        // 判断是否挂起，true则挂起，false则激活
        if(processDefinition.isSuspended()) {
            // 将当前为挂起状态更新为激活状态
            // 参数说明：参数1：流程定义id,参数2：是否激活（true是否级联对应流程实例，激活了则对应流程实例都可以审批），参数3：什么时候激活，如果为null则立即激活，如果为具体时间则到达此时间后激活
            repositoryService.activateProcessDefinitionById(ProcDefiId, true, null);
        }else {
            // 将当前为激活状态更新为挂起状态
            // 参数说明：参数1：流程定义id,参数2：是否挂起（true是否级联对应流程实例，挂起了则对应流程实例都不可以审批），参数3：什么时候挂起，如果为null则立即挂起，如果为具体时间则到达此时间后挂起
            repositoryService.suspendProcessDefinitionById(ProcDefiId, true, null);
        }
        return Result.ok();
    }</code></pre> 
<h6 id="2.2.2.%C2%A0%20%E5%AF%BC%E5%87%BA%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89%E6%96%87%E4%BB%B6%EF%BC%88xml%2Cpng)" style="background-color:transparent;">2.2.2.  导出流程定义文件（xml,png)</h6> 
<pre><code class="language-java">@GetMapping("/export/{type}/{definitionId}")
public void exportFile(@PathVariable String type,
                           @PathVariable String definitionId,
                           HttpServletResponse response) {
        try {
            ProcessDefinition processDefinition = repositoryService.getProcessDefinition(definitionId);

            String resourceName = "文件不存在";

            if("xml".equals(type)) {
                // 获取的是 xml 资源名
                resourceName = processDefinition.getResourceName();
            }else if("png".equals(type)) {
                // 获取 png 图片资源名
                resourceName = processDefinition.getDiagramResourceName();
            }

            // 查询到相关的资源输入流 （deploymentId, resourceName）
            InputStream input =
                    repositoryService.getResourceAsStream(processDefinition.getDeploymentId(), resourceName);

            // 创建输出流
            response.setHeader("Content-Disposition",
                    "attachment; filename=" + URLEncoder.encode(resourceName, "UTF-8"));

            // 流的拷贝放到设置请求头下面，不然文件大于10k可能无法导出
            IOUtils.copy(input, response.getOutputStream());

            response.flushBuffer();
        } catch (Exception e) {
            e.printStackTrace();
            log.error("导出文件失败：{}", e.getMessage());
        }
    }</code></pre> 
<p>这段代码实现了根据流程定义ID导出流程定义文件（XML 或 PNG 格式）的功能。它首先根据流程定义ID查询相关的流程定义信息，然后根据用户请求的类型（XML 或 PNG）获取对应的资源名。接着，通过 <span style="color:#98c091;"><strong><code>repositoryService.getResourceAsStream()</code></strong></span> 方法获取资源的输入流，并将其写入 HttpServletResponse 的输出流中，实现文件的下载。 </p> 
<h6 id="2.2.3.%20%E4%B8%8A%E4%BC%A0zip%E3%80%81bpmn%E3%80%81xml%E5%90%8E%E7%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%A5%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B%E5%AE%9A%E4%B9%89" style="background-color:transparent;">2.2.3. 上传zip、bpmn、xml后缀的文件来进行部署流程定义</h6> 
<pre><code class="language-java">@PostMapping("/file/deploy")    
public Result deployByFile(@RequestParam("file") MultipartFile file) {
        try {
            // 文件名+后缀名
            String filename = file.getOriginalFilename();
            // 文件后缀名
            String suffix = filename.substring(filename.lastIndexOf(".") + 1).toUpperCase();

            InputStream input = file.getInputStream();

            DeploymentBuilder deployment = repositoryService.createDeployment();
            if("ZIP".equals(suffix)) {
                // zip
                deployment.addZipInputStream(new ZipInputStream(input));
            }else {
                // xml 或 bpmn
                deployment.addInputStream(filename, input);
            }

            // 部署名称
            deployment.name(filename.substring(0, filename.lastIndexOf(".")));

            // 开始部署
            deployment.deploy();

            return Result.ok();
        } catch (IOException e) {
            e.printStackTrace();
            log.error("部署失败：" + e.getMessage());
            return Result.error("部署失败");
        }

    }</code></pre> 
<p>这段代码实现了通过上传文件部署流程定义的功能。它接受一个 MultipartFile 对象作为参数，获取上传文件的文件名和后缀名，并根据后缀名判断文件类型（ZIP 或 XML/BPMN）。然后根据文件类型，使用相应的方法将文件内容添加到部署构建器中，设置部署名称，并最终调用<span style="color:#98c091;"><strong> deploy() </strong></span>方法进行部署。 </p> 
<h4 id="2.3.%20%E6%B5%81%E7%A8%8B%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86" style="background-color:transparent;">2.3. 流程配置管理</h4> 
<p>流程配置主要是将流程定义与具体的业务（如请假，借款）进行绑定。<span style="color:#956fe7;"><strong>在实际项目中建议在表中配置死即可。</strong></span></p> 
<p><img alt="" height="922" src="https://images2.imgbox.com/39/ec/9eevI60a_o.png" width="1200"></p> 
<p>在上图中，关联路由名对应前端路由名称，关联路由组件名对应前端表单名称：</p> 
<p><img alt="" height="920" src="https://images2.imgbox.com/a4/96/7ReTBlJT_o.png" width="1200"></p> 
<p>流程配置绑定表如下图所示：</p> 
<p><img alt="" height="496" src="https://images2.imgbox.com/3a/98/oNWs3zEI_o.png" width="1200"></p> 
<p> 只要在上述表中将流程定义KEY和前端参数（路由名，表单名）进行绑定即可。后台代码如下：</p> 
<pre><code class="language-java">   @PutMapping
    public Result saveOrUpdate(@RequestBody ProcessConfig processConfig) {
        boolean b = processConfigService.saveOrUpdate(processConfig);
        if(b) {
            return Result.ok();
        }else {
            return Result.error("操作失败");
        }
    }</code></pre> 
<h4 id="2.4.%20%E6%B5%81%E7%A8%8B%E5%AE%9E%E4%BE%8B%E7%AE%A1%E7%90%86" style="background-color:transparent;">2.4. 流程实例管理</h4> 
<p>流程实例管理对应前端的业务办理界面（请假申请、借款申请），相关接口包括<span style="color:#98c091;"><strong>提交申请，启动流程实例</strong></span>、<span style="color:#98c091;"><strong>撤回申请</strong></span>、<span style="color:#98c091;"><strong>挂起或激活流程实例</strong></span>、<span style="color:#98c091;"><strong>通过流程实例id获取申请表单组件名</strong></span>等。</p> 
<h5 id="2.4.1.%C2%A0%E6%8F%90%E4%BA%A4%E7%94%B3%E8%AF%B7%EF%BC%8C%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%AE%9E%E4%BE%8B" style="background-color:transparent;">2.4.1. 提交申请，启动流程实例</h5> 
<p>前端界面:</p> 
<p><img alt="" height="922" src="https://images2.imgbox.com/8c/cb/uRRI5rT7_o.png" width="1200"></p> 
<p>在本工作流管理系统中，需要在流程启动时动态指定一级审批用户,我这里指定的是<span style="color:#956fe7;"><strong>username</strong></span>，为了更好的用户体验可以改为指定用户的真实姓名，通过下拉框来选择审批人。</p> 
<p>后端代码：</p> 
<pre><code class="language-java">    public Result startProcess(StartREQ req) {
        // 1. 通过业务路由名获取流程配置信息：流程定义key和表单组件名（查询历史审批记录需要）
        ProcessConfig processConfig =
                processConfigService.getByBusinessRoute(req.getBusinessRoute());

        // 2. 表单组件名设置到流程变量中，后面查询历史审批记录需要
        Map&lt;String, Object&gt; variables = req.getVariables(); // 前端已经传递了当前申请信息｛entity: {业务申请数据}}
        variables.put("formName", processConfig.getFormName());

        // 判断办理人为空，则直接结束
        List&lt;String&gt; assignees = req.getAssignees();
        if(CollectionUtils.isEmpty(assignees)) {
            return Result.error("请指定审批人");
        }

        // 3. 启动流程实例（提交申请）
        Authentication.setAuthenticatedUserId(UserUtils.getUsername());
        ProcessInstance pi =
                runtimeService.startProcessInstanceByKey(processConfig.getProcessKey(),
                        req.getBusinessKey(), variables);

        // 将流程定义名称 作为 流程实例名称
        runtimeService.setProcessInstanceName(pi.getProcessInstanceId(), pi.getProcessDefinitionName());


        // 4. 设置任务办理人
        List&lt;Task&gt; taskList = taskService.createTaskQuery().processInstanceId(pi.getId()).list();
        for (Task task : taskList) {
            if(assignees.size() == 1) {
                // 如果只能一个办理人，则直接设置为办理人
               taskService.setAssignee(task.getId(), assignees.get(0));
            }else {
                // 多个办理人，则设置为候选人
                for(String assignee: assignees) {
                    taskService.addCandidateUser(task.getId(), assignee);
                }
            }
        }

        // 5. 更新业务状态为：办理中, 和流程实例id
        return businessStatusService.updateState(req.getBusinessKey(),
                BusinessStatusEnum.PROCESS,
                pi.getProcessInstanceId());
    }
</code></pre> 
<p>这段代码实现了启动流程实例的功能。首先根据业务路由名获取流程配置信息，设置表单组件名到流程变量中。然后判断办理人是否为空，若为空则返回错误信息。接着通过设置认证用户为当前用户启动流程实例，将流程定义名称作为流程实例名称，并设置任务办理人。最后更新业务状态为办理中，并返回更新结果。 </p> 
<p>启动流程实例涉及了 Activiti 7 中的以下几张表：</p> 
<ol><li><span style="color:#98c091;"><strong><code>ACT_RU_TASK</code></strong></span>：用于存储流程任务的运行时信息，包括任务的唯一标识、流程实例ID、任务名称等。</li><li><span style="color:#98c091;"><strong><code>ACT_RU_PROCESS_INSTANCE</code></strong></span>：存储流程实例的运行时信息，包括流程实例的唯一标识、流程定义ID、当前活动节点等。</li><li><span style="color:#98c091;"><strong><code>ACT_RU_VARIABLE</code></strong></span>：用于存储流程实例的运行时变量信息，包括流程实例ID、变量名称、变量值等。</li><li><span style="color:#98c091;"><strong><code>ACT_HI_TASKINST</code></strong></span>：存储历史流程任务的信息，包括任务的执行过程、持续时间等。</li><li><span style="color:#98c091;"><strong><code>ACT_HI_PROCINST</code></strong></span>：存储历史流程实例的信息，包括流程实例的启动时间、结束时间等。</li><li><span style="color:#98c091;"><strong><code>ACT_HI_ACTINST</code></strong></span>：存储历史流程执行的信息，包括每个流程实例的执行路径、执行活动的持续时间等。</li></ol> 
<h5 id="2.4.2.%C2%A0%E6%92%A4%E5%9B%9E%E7%94%B3%E8%AF%B7" style="background-color:transparent;">2.4.2. 撤回申请</h5> 
<pre><code class="language-java">    public Result cancel(String businessKey, String procInstId, String message) {
        // 1. 删除当前流程实例
        runtimeService.deleteProcessInstance(procInstId,
                UserUtils.getUsername() + " 主动撤回了当前申请：" + message);

        // 2. 删除历史记录
        historyService.deleteHistoricProcessInstance(procInstId);
        historyService.deleteHistoricTaskInstance(procInstId);

        // 3. 更新业务状态
        return businessStatusService.updateState(businessKey, BusinessStatusEnum.CANCEL, "");
    }</code></pre> 
<p>这段代码实现了取消流程实例的功能。它首先通过流程实例ID删除当前运行中的流程实例，并添加一条撤回消息作为删除原因。然后删除相关的历史记录，包括历史流程实例和历史任务实例。最后更新业务状态为取消，并返回更新结果。</p> 
<p>撤回申请涉及了 Activiti 7 中的以下几张表：</p> 
<ol><li><span style="color:#98c091;"><strong><code>ACT_RU_PROCESS_INSTANCE</code></strong></span>：用于存储流程实例的运行时信息，包括流程实例的唯一标识、当前活动节点等。</li><li><span style="color:#98c091;"><strong><code>ACT_HI_PROCINST</code></strong></span>：存储历史流程实例的信息，包括流程实例的启动时间、结束时间等。</li><li><span style="color:#98c091;"><strong><code>ACT_HI_TASKINST</code></strong></span>：存储历史任务实例的信息，包括任务的执行过程、持续时间等。</li></ol> 
<h5 id="2.4.3.%C2%A0%E6%8C%82%E8%B5%B7%E6%88%96%E6%BF%80%E6%B4%BB%E6%B5%81%E7%A8%8B%E5%AE%9E%E4%BE%8B">2.4.3. 挂起或激活流程实例</h5> 
<p>前端界面:</p> 
<p><img alt="" height="922" src="https://images2.imgbox.com/7e/e7/N8ijY2U8_o.png" width="1200"></p> 
<p>后端代码：</p> 
<pre><code class="language-java">  @PutMapping("/state/{procInstId}")
    public Result updateProcInstState(@PathVariable String procInstId) {
        // 1. 查询指定流程实例的数据
        ProcessInstance processInstance = runtimeService.createProcessInstanceQuery()
                .processInstanceId(procInstId)
                .singleResult();

        // 2. 判断当前流程实例的状态
        if(processInstance.isSuspended()) {
            // 如果是已挂起，则更新为激活状态
            runtimeService.activateProcessInstanceById(procInstId);
        }else {
            // 如果是已激活，则更新为挂起状态
            runtimeService.suspendProcessInstanceById(procInstId);
        }

        return Result.ok();
    }</code></pre> 
<p>这段代码实现了更新流程实例状态的功能。它首先查询指定流程实例的数据，然后判断当前流程实例的状态，若是已挂起则更新为激活状态，若是已激活则更新为挂起状态。最后返回更新结果。 </p> 
<h5 id="2.4.4.%C2%A0%E9%80%9A%E8%BF%87%E6%B5%81%E7%A8%8B%E5%AE%9E%E4%BE%8Bid%E8%8E%B7%E5%8F%96%E5%8E%86%E5%8F%B2%E6%B5%81%E7%A8%8B%E5%9B%BE">2.4.4. 通过流程实例id获取历史流程图</h5> 
<p>前端界面：</p> 
<p><img alt="" height="922" src="https://images2.imgbox.com/8f/16/PHeakjqE_o.png" width="1200"></p> 
<p>后端代码：</p> 
<pre><code class="language-java">    public void getHistoryProcessImage(String prodInstId, HttpServletResponse response) {
        InputStream inputStream = null;
        try {
            // 1.查询流程实例历史数据
            HistoricProcessInstance instance = historyService.createHistoricProcessInstanceQuery()
                    .processInstanceId(prodInstId).singleResult();

            // 2. 查询流程中已执行的节点，按时开始时间降序排列
            List&lt;HistoricActivityInstance&gt; historicActivityInstanceList = historyService.createHistoricActivityInstanceQuery()
                    .processInstanceId(prodInstId)
                    .orderByHistoricActivityInstanceStartTime().desc()
                    .list();

            // 3. 单独的提取高亮节点id ( 绿色）
            List&lt;String&gt; highLightedActivityIdList =
                    historicActivityInstanceList.stream()
                        .map(HistoricActivityInstance::getActivityId).collect(Collectors.toList());

            // 4. 正在执行的节点 （红色）
            List&lt;Execution&gt; runningActivityInstanceList = runtimeService.createExecutionQuery()
                    .processInstanceId(prodInstId).list();

            List&lt;String&gt; runningActivityIdList = new ArrayList&lt;&gt;();
            for (Execution execution : runningActivityInstanceList) {
                if(StringUtils.isNotEmpty(execution.getActivityId())) {
                    runningActivityIdList.add(execution.getActivityId());
                }
            }

            // 获取流程定义Model对象
            BpmnModel bpmnModel = repositoryService.getBpmnModel(instance.getProcessDefinitionId());

            // 实例化流程图生成器
            CustomProcessDiagramGenerator generator = new CustomProcessDiagramGenerator();
            // 获取高亮连线id
            List&lt;String&gt; highLightedFlows = generator.getHighLightedFlows(bpmnModel, historicActivityInstanceList);
            // 生成历史流程图
            inputStream = generator.generateDiagramCustom(bpmnModel, highLightedActivityIdList,
                    runningActivityIdList, highLightedFlows,
                    "宋体", "微软雅黑", "黑体");

            // 响应相关图片
            response.setContentType("image/svg+xml");
            byte[] bytes = IOUtils.toByteArray(inputStream);
            ServletOutputStream outputStream = response.getOutputStream();
            outputStream.write(bytes);
            outputStream.flush();
            outputStream.close();
        }catch (Exception e) {
            e.printStackTrace();
        }finally {
            if( inputStream != null){
                try {
                    inputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }</code></pre> 
<p>这段代码实现了根据流程实例ID获取历史流程图的功能。它首先查询指定流程实例的历史数据和已执行的节点信息，并提取出高亮节点和正在执行的节点的ID列表。然后根据流程定义的模型对象和节点信息，使用自定义的流程图生成器生成历史流程图，并将流程图以 <span style="color:#98c091;"><strong>SVG </strong></span>格式返回给前端。 </p> 
<h5 id="2.4.5.%20%E9%80%9A%E8%BF%87%E6%B5%81%E7%A8%8B%E5%AE%9E%E4%BE%8Bid%E8%8E%B7%E5%8F%96%E4%BB%BB%E5%8A%A1%E5%8A%9E%E7%90%86%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95">2.4.5. 通过流程实例id获取任务办理历史记录</h5> 
<p>前端界面：</p> 
<p><img alt="" height="922" src="https://images2.imgbox.com/04/07/R8NWH64U_o.png" width="1200"></p> 
<p>后端代码：</p> 
<pre><code class="language-java">    public Result getHistoryInfoList(String procInstId) {
        // 查询每任务节点历史办理情况
        List&lt;HistoricTaskInstance&gt; list = historyService.createHistoricTaskInstanceQuery()
                .processInstanceId(procInstId)
                .orderByHistoricTaskInstanceStartTime()
                .asc()
                .list();

        List&lt;Map&lt;String, Object&gt;&gt; records = new ArrayList&lt;&gt;();
        for (HistoricTaskInstance hti : list) {
            Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();
            result.put("taskId", hti.getId()); // 任务ID
            result.put("taskName", hti.getName()); // 任务名称
            result.put("processInstanceId", hti.getProcessInstanceId()); //流程实例ID
            result.put("startTime", DateUtils.format(hti.getStartTime())); // 开始时间
            result.put("endTime", DateUtils.format(hti.getEndTime())); // 结束时间
            result.put("status", hti.getEndTime() == null ? "待处理": "已处理"); // 状态
            result.put("assignee", hti.getAssignee()); // 办理人

            // 撤回原因
            String message = hti.getDeleteReason();
            if(StringUtils.isEmpty(message)) {
                List&lt;Comment&gt; taskComments = taskService.getTaskComments(hti.getId());
                message = taskComments.stream()
                        .map(m -&gt; m.getFullMessage()).collect(Collectors.joining("。"));
            }
            result.put("message", message);

            records.add(result);
        }

        return Result.ok(records);
    }</code></pre> 
<p>这段代码实现了查询指定流程实例的历史任务信息列表的功能。它首先通过历史任务实例查询服务查询指定流程实例的历史任务信息，并按照任务开始时间升序排序。然后遍历历史任务列表，将每个历史任务的相关信息封装到一个 Map 中，并将所有的 Map 组成一个列表返回给调用方，包括<span style="color:#98c091;"><strong>任务ID</strong></span>、<span style="color:#98c091;"><strong>任务名称</strong></span>、<span style="color:#98c091;"><strong>流程实例ID</strong></span>、<span style="color:#98c091;"><strong>任务开始时间</strong></span>、<span style="color:#98c091;"><strong>任务结束时间</strong></span>、<span style="color:#98c091;"><strong>任务状态</strong></span>、<span style="color:#98c091;"><strong>办理人</strong></span>以及<span style="color:#98c091;"><strong>撤回原因</strong></span>等。 </p> 
<h4 id="2.5.%20%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86">2.5. 任务管理</h4> 
<p>任务管理对应前端待办任务和已办任务界面，包含查询<span style="color:#98c091;"><strong>当前用户的待办任务</strong></span>、<span style="color:#98c091;"><strong>获取目标节点（下一个节点）</strong></span>、<span style="color:#98c091;"><strong>完成任务</strong></span>、<span style="color:#98c091;"><strong>获取历史任务节点</strong>，<strong>用于驳回功能</strong></span><span style="color:#0d0016;">、</span><span style="color:#98c091;"><strong>驳回历史节点</strong></span>等接口。</p> 
<p><img alt="" height="922" src="https://images2.imgbox.com/00/95/B8hxzWI6_o.png" width="1200"></p> 
<h5 id="2.5.1.%C2%A0%C2%A0%E6%9F%A5%E8%AF%A2%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7%E7%9A%84%E5%BE%85%E5%8A%9E%E4%BB%BB%E5%8A%A1">2.5.1.  查询当前用户的待办任务</h5> 
<pre><code class="language-java"> @PostMapping("/list/wait")
    public Result findWaitTask(@RequestBody TaskREQ req) {

        String assignee = UserUtils.getUsername();

        TaskQuery query = taskService.createTaskQuery()
                .taskCandidateOrAssigned(assignee) // 候选人或者办理人
                .orderByTaskCreateTime().asc();

        if(StringUtils.isNotEmpty(req.getTaskName())) {
            query.taskNameLikeIgnoreCase("%" + req.getTaskName() + "%");
        }
        // 分页查询
        List&lt;Task&gt; taskList = query.listPage(req.getFirstResult(), req.getSize());

        long total = query.count();

        List&lt;Map&lt;String, Object&gt;&gt; records = new ArrayList&lt;&gt;();
        for (Task task : taskList) {
            Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();
            result.put("taskId", task.getId());
            result.put("taskName", task.getName());
            result.put("processStatus", task.isSuspended() ? "已暂停": "已启动");
            result.put("taskCreateTime", DateUtils.format(task.getCreateTime()) );
            result.put("processInstanceId", task.getProcessInstanceId());
            result.put("executionId", task.getExecutionId());
            result.put("processDefinitionId", task.getProcessDefinitionId());
            // 任务办理人: 如果是候选人则没有值，办理人才有
            result.put("taskAssignee", task.getAssignee());

            // 查询流程实例
            ProcessInstance pi = runtimeService.createProcessInstanceQuery()
                    .processInstanceId(task.getProcessInstanceId()).singleResult();
            result.put("processName", pi.getProcessDefinitionName());
            result.put("version", pi.getProcessDefinitionVersion());
            result.put("proposer", pi.getStartUserId());
            result.put("businessKey", pi.getBusinessKey());

            records.add(result);
        }


        Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();
        result.put("total", total);
        result.put("records", records);
        return Result.ok(result);
    }</code></pre> 
<p>这段代码实现了查询待办任务列表的功能。它首先获取当前用户的用户名作为任务的候选人或办理人，然后根据任务查询条件构建任务查询对象，并按任务创建时间升序排列。接着根据分页参数查询待办任务列表，并统计总数。最后，将待办任务的相关信息（<span style="color:#98c091;"><strong>如任务ID</strong></span>、<span style="color:#98c091;"><strong>任务名称</strong></span>、<span style="color:#98c091;"><strong>流程状态</strong></span>、<span style="color:#98c091;"><strong>任务创建时间</strong></span>、<span style="color:#98c091;"><strong>流程实例ID</strong></span>等）封装到一个列表中，并返回给调用方。 </p> 
<h5 id="%C2%A02.5.2.%C2%A0%E8%8E%B7%E5%8F%96%E7%9B%AE%E6%A0%87%E8%8A%82%E7%82%B9%EF%BC%88%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%89" style="background-color:transparent;"> 2.5.2. 获取目标节点（下一个节点）</h5> 
<p>本工作流框架支持动态指定审批人，故完成本节点审批时，需要动态获取下一任务节点，方便在本节点通过审批后动态指定下一个节点审批人。</p> 
<p><img alt="" height="922" src="https://images2.imgbox.com/78/da/nBfOEDlI_o.png" width="1200"></p> 
<p>后端代码： </p> 
<pre><code class="language-java"> @GetMapping("/next/node")
    public Result getNextNodeInfo(@RequestParam String taskId) {
        Task task = taskService.createTaskQuery().taskId(taskId).singleResult();
        // 2. 从当前任务信息中获取此流程定义id，
        String processDefinitionId = task.getProcessDefinitionId();
        // 3. 拿到流程定义id后可获取此bpmnModel对象
        BpmnModel bpmnModel = repositoryService.getBpmnModel(processDefinitionId);

        // 4. 通过任务节点id，来获取当前节点信息
        FlowElement flowElement = bpmnModel.getFlowElement(task.getTaskDefinitionKey());
        // 封装下一个用户任务节点信息
        List&lt;Map&lt;String, Object&gt;&gt; nextNodes = new ArrayList&lt;&gt;();
        getNextNodes(flowElement, nextNodes);

        return Result.ok(nextNodes);
    }

    public void getNextNodes(FlowElement flowElement, List&lt;Map&lt;String, Object&gt;&gt; nextNodes) {
        // 获取当前节点的连线信息
        List&lt;SequenceFlow&gt; outgoingFlows = ((FlowNode) flowElement).getOutgoingFlows();
        // 当前节点的所有下一节点出口
        for (SequenceFlow outgoingFlow : outgoingFlows) {
            // 下一节点的目标元素
            FlowElement nextFlowElement = outgoingFlow.getTargetFlowElement();
            if(nextFlowElement instanceof UserTask) {
                // 用户任务，则获取响应给前端设置办理人或者候选人
                Map&lt;String, Object&gt; node = new HashMap&lt;&gt;();
                node.put("id", nextFlowElement.getId()); // 节点id
                node.put("name", nextFlowElement.getName()); // 节点名称
                nextNodes.add(node);
            }else if(nextFlowElement instanceof EndEvent) {
                break;
            }else if(nextFlowElement instanceof ParallelGateway // 并行网关
                || nextFlowElement instanceof ExclusiveGateway) { // 排他网关
                getNextNodes(nextFlowElement, nextNodes);
            }
        }
    }</code></pre> 
<p> 这段代码实现了获取指定任务的下一个节点信息的功能。它首先根据任务ID查询任务信息，然后根据任务信息获取流程定义ID，并通过流程定义ID获取相应的 <span style="color:#98c091;"><strong>BPMN 模型对象</strong></span>。接着根据任务节点ID获取当前节点信息，并递归遍历当前节点的连线信息，获取所有下一个节点的信息，将其封装成列表并返回给调用方。</p> 
<p>前端返回结果：</p> 
<p><img alt="" height="1002" src="https://images2.imgbox.com/7e/a4/kz4YDhX8_o.png" width="1200"></p> 
<h5 id="2.5.3.%C2%A0%E5%AE%8C%E6%88%90%E4%BB%BB%E5%8A%A1">2.5.3. 完成任务</h5> 
<p>前端传入参数：</p> 
<p><img alt="" height="1002" src="https://images2.imgbox.com/c0/f5/6t5XMkKB_o.png" width="1200"></p> 
<p>TaskCompleteREQ 编写：</p> 
<pre><code class="language-java">public class TaskCompleteREQ implements Serializable {

    @ApiModelProperty("任务ID")
    private String taskId;

    @ApiModelProperty("审批意见")
    private String message;

    @ApiModelProperty("下一个节点审批，key: 节点id, vallue：审批人集合,多个人使用英文逗号分隔")
    private Map&lt;String, String&gt; assigneeMap;

    public String getMessage() {
        return StringUtils.isEmpty(message) ? "审批通过": message;
    }

    /**
     * 通过节点id获取审批人集合
     * @param key
     * @return
     */
    public String[] getAssignees(String key) {
        if(assigneeMap == null) {
            return null;
        }
        return assigneeMap.get(key).split(",");
    }

}</code></pre> 
<p>完成任务代码:</p> 
<pre><code class="language-java">    @PostMapping("/complete")
    public Result completeTask(@RequestBody TaskCompleteREQ req) {
        String taskId = req.getTaskId();
        //1. 查询任务信息
        org.activiti.api.task.model.Task task = taskRuntime.task(taskId);
        if(task == null) {
            return Result.error("任务不存在或不是您办理的任务");
        }
        String procInstId = task.getProcessInstanceId();
        // 2. 指定任务审批意见
        taskService.addComment(taskId, procInstId, req.getMessage());

        // 3. 完成任务
        taskRuntime.complete(TaskPayloadBuilder.complete().withTaskId(taskId).build());

        // 4. 查询下一个任务
        List&lt;Task&gt; taskList = taskService.createTaskQuery().processInstanceId(procInstId).list();

        // 5. 指定办理人
        if(CollectionUtils.isEmpty(taskList)) {
            // task.getBusinessKey() m5版本中没有 值
            HistoricProcessInstance hpi = historyService.createHistoricProcessInstanceQuery()
                    .processInstanceId(procInstId).singleResult();
            // 更新业务状态已完成
            return businessStatusService.updateState(hpi.getBusinessKey(), BusinessStatusEnum.FINISH);
        }else {
            Map&lt;String, String&gt; assigneeMap = req.getAssigneeMap();
            if(assigneeMap == null) {
                // 如果没有办理人，直接将流程实例删除（非法操作）
                return deleteProcessInstance(procInstId);
            }
            // 有办理人
            for (Task t: taskList) {
                if(StringUtils.isNotEmpty(t.getAssignee())) {
                    // 如果当前任务有办理人，则直接忽略，不用指定办理人
                    continue;
                }
                // 根据当前任务节点id获取办理人
                String[] assignees = req.getAssignees(t.getTaskDefinitionKey());
                if(ArrayUtils.isEmpty(assignees)) {
                    // 没有办理人
                    return deleteProcessInstance(procInstId);
                }

                if(assignees.length == 1) {
                    taskService.setAssignee(t.getId(), assignees[0]);
                }else {
                    // 多个作为候选人
                    for(String assignee: assignees) {
                        taskService.addCandidateUser(t.getId(), assignee);
                    }
                }
            }
        }

        return Result.ok();
    }</code></pre> 
<p>这段代码实现了完成任务的操作，并根据任务完成情况进行下一步的流程处理。它首先根据任务ID查询任务信息，然后添加任务审批意见并完成任务。接着查询流程实例的下一个任务，如果没有下一个任务则更新业务状态为已完成；如果有下一个任务，则根据指定的办理人信息指派任务给相应的用户或候选人。</p> 
<h5 id="2.5.4.%C2%A0%E8%8E%B7%E5%8F%96%E5%8E%86%E5%8F%B2%E4%BB%BB%E5%8A%A1%E8%8A%82%E7%82%B9%EF%BC%8C%E7%94%A8%E4%BA%8E%E9%A9%B3%E5%9B%9E%E5%8A%9F%E8%83%BD">2.5.4. 获取历史任务节点，用于驳回功能</h5> 
<p>本工作流框架支持在审批过程中驳回至之前的任意节点，需要完成这个功能首先我们应该获取运行流程中的历史任务节点。</p> 
<p>前端界面：</p> 
<p><img alt="" height="922" src="https://images2.imgbox.com/7b/73/YAQdRHpm_o.png" width="1200"></p> 
<p>后端代码：</p> 
<p><strong><span style="color:#fe2c24;">ps:源代码获取历史任务节点代码有bug，这是我修改以后的，源代码我没改（因为我懒 = =）</span></strong></p> 
<pre><code class="language-java">    public ResponseStructure getBackNodes(String taskId) {
        try {
            Task task = taskService.createTaskQuery().taskId(taskId).singleResult();
            // 2. 从当前任务信息中获取此流程定义id，
            String processDefinitionId = task.getProcessDefinitionId();
            // 3. 拿到流程定义id后可获取此bpmnModel对象
            BpmnModel bpmnModel = repositoryService.getBpmnModel(processDefinitionId);
            // 4. 通过任务节点id，来获取当前节点信息
            FlowElement flowElement = bpmnModel.getFlowElement(task.getTaskDefinitionKey());
            List&lt;Map&lt;String,Object&gt;&gt;parentNodes=new ArrayList&lt;&gt;();
            getParentNodes(flowElement,parentNodes);
            return ResponseStructure.success(parentNodes);
        } catch (Exception e) {
            e.printStackTrace();
            return ResponseStructure.failed("查询驳回节点失败：" + e.getMessage());
        }
    }
    public void getParentNodes(FlowElement flowElement, List&lt;Map&lt;String, Object&gt;&gt; parentNodes) {
        List&lt;SequenceFlow&gt;incommingFlows=((FlowNode)flowElement).getIncomingFlows();
        for (SequenceFlow incommingFlow : incommingFlows) {
            FlowNode source = (FlowNode)incommingFlow.getSourceFlowElement();
            if(source instanceof ParallelGateway||source instanceof ExclusiveGateway){
                getParentNodes(source,parentNodes);
            }else if(source instanceof StartEvent){
                break;
            }else if(source instanceof UserTask){
                Map&lt;String, Object&gt; node = new HashMap&lt;&gt;();
                node.put("activityId", source.getId()); // 节点id
                node.put("activityName", source.getName()); // 节点名称
                parentNodes.add(node);
                getParentNodes(source,parentNodes);
            }
        }
    }</code></pre> 
<p>这段代码实现了获取指定任务可驳回的节点信息的功能。它首先根据任务ID查询当前任务信息，然后根据当前任务的<span style="color:#98c091;"><strong>流程定义ID</strong></span>获取<span style="color:#98c091;"><strong>BpmnModel对象</strong></span>，通过任务节点ID递归查询父节点信息，将可驳回的节点信息封装成列表返回给调用方。</p> 
<h5 id="2.5.5.%C2%A0%E9%A9%B3%E5%9B%9E%E5%8E%86%E5%8F%B2%E8%8A%82%E7%82%B9">2.5.5. 驳回历史节点</h5> 
<pre><code class="language-java">    @PostMapping("/back")
    public Result backProcess(@RequestParam String taskId,
                              @RequestParam String targetActivityId) {
        try {
            // 1. 查询当前任务信息
            Task task = taskService.createTaskQuery()
                    .taskId(taskId)
                    .taskAssignee(UserUtils.getUsername())
                    .singleResult();
            if(task == null) {
                return Result.error("当前任务不存在或你不是任务办理人");
            }

            String procInstId = task.getProcessInstanceId();

            // 2. 获取流程模型实例 BpmnModel
            BpmnModel bpmnModel = repositoryService.getBpmnModel(task.getProcessDefinitionId());
            // 3. 当前节点信息
            FlowNode curFlowNode = (FlowNode)bpmnModel.getMainProcess().getFlowElement(task.getTaskDefinitionKey());
            // 4. 获取当前节点的原出口连线
            List&lt;SequenceFlow&gt; sequenceFlowList = curFlowNode.getOutgoingFlows();
            // 5. 临时存储当前节点的原出口连线
            List&lt;SequenceFlow&gt; oriSequenceFlows = new ArrayList&lt;&gt;();
            oriSequenceFlows.addAll(sequenceFlowList);
            // 6. 将当前节点的原出口清空
            sequenceFlowList.clear();

            // 7. 获取目标节点信息
            FlowNode targetFlowNode = (FlowNode)bpmnModel.getFlowElement(targetActivityId);
            // 8. 获取驳回的新节点
            // 获取目标节点的入口连线
            List&lt;SequenceFlow&gt; incomingFlows = targetFlowNode.getIncomingFlows();
            // 存储所有目标出口
            List&lt;SequenceFlow&gt; allSequenceFlow = new ArrayList&lt;&gt;();
            for (SequenceFlow incomingFlow : incomingFlows) {
                // 找到入口连线的源头（获取目标节点的父节点）
                FlowNode source = (FlowNode)incomingFlow.getSourceFlowElement();
                List&lt;SequenceFlow&gt; sequenceFlows;
                if(source instanceof ParallelGateway) {
                    // 并行网关: 获取目标节点的父节点（并行网关）的所有出口，
                    sequenceFlows = source.getOutgoingFlows();
                } else {
                    // 其他类型父节点, 则获取目标节点的入口连续
                    sequenceFlows = targetFlowNode.getIncomingFlows();
                }
                allSequenceFlow.addAll(sequenceFlows);
            }

            // 9. 将当前节点的出口设置为新节点
            curFlowNode.setOutgoingFlows(allSequenceFlow);

            // 10. 完成当前任务，流程就会流向目标节点创建新目标任务
            //      删除已完成任务，删除已完成并行任务的执行数据 act_ru_execution
            List&lt;Task&gt; list = taskService.createTaskQuery().processInstanceId(procInstId).list();
            for (Task t : list) {
                if(taskId.equals(t.getId())) {
                    // 当前任务，完成当前任务
                    String message = String.format("【%s 驳回任务 %s =&gt; %s】",
                            UserUtils.getUsername(), task.getName(), targetFlowNode.getName());
                    taskService.addComment(t.getId(), procInstId, message);
                    // 完成任务，就会进行驳回到目标节点，产生目标节点的任务数据
                    taskService.complete(taskId);
                    // 删除执行表中 is_active_ = 0的执行数据， 使用command自定义模型
                    DelelteExecutionCommand deleteExecutionCMD = new DelelteExecutionCommand(task.getExecutionId());
                    managementService.executeCommand(deleteExecutionCMD);
                }else {
                    // 删除其他未完成的并行任务
                    // taskService.deleteTask(taskId); // 注意这种方式删除不掉，会报错：流程正在运行中无法删除。
                    // 使用command自定义命令模型来删除，直接操作底层的删除表对应的方法，对应的自定义是否删除
                    DeleteTaskCommand deleteTaskCMD = new DeleteTaskCommand(t.getId());
                    managementService.executeCommand(deleteTaskCMD);
                }
            }

            // 13. 完成驳回功能后，将当前节点的原出口方向进行恢复
            curFlowNode.setOutgoingFlows(oriSequenceFlows);


            // 12. 查询目标任务节点历史办理人
            List&lt;Task&gt; newTaskList = taskService.createTaskQuery().processInstanceId(procInstId).list();
            for (Task newTask : newTaskList) {
                // 取之前的历史办理人
                HistoricTaskInstance oldTargerTask = historyService.createHistoricTaskInstanceQuery()
                        .taskDefinitionKey(newTask.getTaskDefinitionKey()) // 节点id
                        .processInstanceId(procInstId)
                        .finished() // 已经完成才是历史
                        .orderByTaskCreateTime().desc() // 最新办理的在最前面
                        .list().get(0);
                taskService.setAssignee(newTask.getId(), oldTargerTask.getAssignee());
            }

            return Result.ok();
        } catch (Exception e) {
            e.printStackTrace();
            return Result.error("驳回失败："+ e.getMessage());
        }
    }</code></pre> 
<p>这段代码实现了流程任务的驳回功能。它首先查询当前任务信息，然后获取流程模型实例，通过修改当前节点的出口连线为目标节点的入口连线，完成当前任务并删除已完成的其他任务（并行网关），恢复当前节点的原出口方向，最后设置目标任务节点的办理人为之前的历史办理人。 </p> 
<h4 id="2.6.%20%E8%AF%B7%E5%81%87%E7%94%B3%E8%AF%B7%E7%AE%A1%E7%90%86">2.6. 请假申请管理</h4> 
<p>请假申请管理对应前端请假申请页面，包含新增请假申请、条件分页查询请假申请列表数据、查询请假详情信息、更新请假详情信息接口。接口都很简单，我在这里讲一下业务流程和工作流怎么串接起来。</p> 
<p style="background-color:transparent;"><strong>创建BusinessStatus表：</strong></p> 
<pre>BusinessStatus表为串接业务流程和工作流的中间表，字段如下图，大家看图自行创建就行：</pre> 
<p><img alt="" height="496" src="https://images2.imgbox.com/90/1e/4XHWO97Z_o.png" width="1200"></p> 
<p><strong>基于status字段，在代码中创建BusinessStatusEnum枚举：</strong></p> 
<pre><code class="language-java">@Getter
@AllArgsConstructor
public enum BusinessStatusEnum {

    CANCEL(0, "已撤回"), WAIT(1, "待提交"), PROCESS(2, "处理中"),
    FINISH(3, "已完成"), INVALID(4, "已作废"), DELETE(5, "已删除");
    private Integer code;
    private String desc;

    public static BusinessStatusEnum getEumByCode(Integer code){
        if(code == null) return null;

        for(BusinessStatusEnum statusEnum: BusinessStatusEnum.values()) {
            if(statusEnum.getCode() == code) {
                return statusEnum;
            }
        }
        return null;
    }

}
</code></pre> 
<p><strong> 新增申请，流程审批通过，驳回，需要顺带操作BusinessStatus表。</strong></p> 
<p><img alt="" height="785" src="https://images2.imgbox.com/84/e1/9n0t3819_o.png" width="1200"></p> 
<p>由上图即可看出哪些申请新增了，哪些还没有绑定流程，哪些流程正在运行，哪些流程已经执行完毕。</p> 
<p><span style="color:#956fe7;"><strong>到此，源码已经讲解完啦，还有一些比较简单的可以异步源码地址去看。</strong></span></p> 
<h3 id="3.%20%E6%BA%90%E7%A0%81%E5%9C%B0%E5%9D%80" style="background-color:transparent;">3. 源码地址</h3> 
<p><span style="color:#98c091;"><strong>关注gzh：后端小肥肠  免费领取源码资源</strong></span></p> 
<h3 id="4.%20%E7%BB%93%E8%AF%AD" style="background-color:transparent;">4. 结语</h3> 
<p>本文作为《基于Spring Security的Activiti7工作流管理系统简介及实现》的下半部分，以实例代码及代码讲解展示了工作流管理系统的实现，文末还粘贴了源码地址，如本文对你有帮助，请动动发财的小手点点关注哦~~</p> 
<p><img alt="" height="383" src="https://images2.imgbox.com/46/1f/5YXLqbzv_o.jpg" width="900"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bff982c19246020042fa23589f907944/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">GO语言 环境搭建</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0676b2152270cf7f9890ed30eb8900f7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Navicat导入json文件（json文件数据导入到MySQL表中）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>