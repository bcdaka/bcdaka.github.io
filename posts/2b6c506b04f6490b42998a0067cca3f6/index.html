<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深入理解数据结构第六弹——排序（3）——归并排序 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/2b6c506b04f6490b42998a0067cca3f6/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="深入理解数据结构第六弹——排序（3）——归并排序">
  <meta property="og:description" content="排序1：深入了解数据结构第四弹——排序（1）——插入排序和希尔排序-CSDN博客
排序2：深入理解数据结构第五弹——排序（2）——快速排序-CSDN博客
前言：
在前面，我们已经学习了插入排序、堆排序、快速排序等一系列排序，今天我们来讲解一下另一个很高效的排序方法——归并排序
目录
一、归并排序的思想
二、归并排序的递归实现
三、归并排序的非递归实现
四、完整的代码实例
五、总结
一、归并排序的思想 归并排序是一种经典的排序算法，它采用了分治法的思想。分治法的核心是“分而治之”，即将一个复杂的问题分解成两个或多个相同或相似的子问题，将这些子问题逐个解决，最后将子问题的解合并以解决原问题。
归并排序的基本思想如下：
分解（Divide）：
将待排序的数组从中间分成两半，递归地对这两半分别进行归并排序。一直分解，直到每个子数组只包含一个元素，因为一个元素的数组自然是有序的。 解决（Conquer）：
当分解到最小子问题时，即每个子数组只有一个元素时，开始解决这些小问题。解决的方式是合并（Merge）两个有序的子数组，从而得到一个更大的有序数组。 合并（Merge）：
合并过程是归并排序的关键步骤。它将两个有序的子数组合并成一个有序的数组。通常使用两个指针分别指向两个子数组的起始位置，然后比较两个指针所指向的元素，将较小的元素放入结果数组中，并移动该指针。重复这个过程，直到一个子数组被完全合并到结果数组中，然后将另一个子数组的剩余元素直接复制到结果数组中。 归并排序的操作如下：
归并操作其实就是将一组数据通过递归等不断划分成两个部分，直到划分到一个元素之后，再对这两部分排序排进一个数组内，相当于把划分的过程再反过来走了一遍，只是走回去的过程中会把数组一步一步的有序化
二、归并排序的递归实现 递归的实现其实是很有意思的，在上面我们已经讲了递归的思想，其实就是不断的重复划分然后排序的过程，所以我们就可以设计一个递归来实现这种，同时，由于每一步都要进行分区划分，所以我们可以封装一个划分函数（_MergeSort函数）在前，重复这个过程
void MergeSort(int* a, int n) { int* tmp = (int*)malloc(sizeof(int) * n); _MergeSort(a, 0, n - 1,tmp); free(tmp); } 1、因为我们在划分结束后，需要将各个小的部分再排序成一个有序的大部分，所以我们创建一个tmp的指针指向一个与原数组一样大小的空间，然后每一次排序放进这个空间，最后再把这个空间中的数据复制回原数组
2、其中_MergeSort函数内参数分别为原数组指针，首元素位置，尾元素位置，tmp指针
然后我们就来实现这个分步函数，这个函数的功能就是实现将一个数组不断分为两个部分，当划分成最小单元时，两个两个比较大小，并且放入tmp中，再复制进原数组中，我们先拿数组 { 8 ，7，6，5，4，3，2，1 } 举个例子
实现上述过程的代码如下
//归并排序 void _MergeSort(int* a, int begin,int end,int* tmp) { if (begin == end) return; //小区间优化 if (end - begin &#43; 1 &lt; 10) { InsertSort(a &#43; begin, begin - end &#43; 1); } int mid = (begin &#43; end) / 2; _MergeSort(a, begin, mid, tmp); _MergeSort(a, mid &#43; 1, end, tmp); int begin1 = begin, end1 = mid; int begin2 = mid &#43; 1, end2 = end; int i = begin; while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) { if (a[begin1] &lt; a[begin2]) { tmp[i&#43;&#43;] = a[begin1]; begin1&#43;&#43;; } else tmp[i&#43;&#43;] = a[begin2&#43;&#43;]; } while (begin1 &lt;= end1) { tmp[i&#43;&#43;] = a[begin1&#43;&#43;]; } while (begin2 &lt;= end2) { tmp[i&#43;&#43;] = a[begin2&#43;&#43;]; } memcpy(a &#43; begin, tmp &#43; begin, sizeof(int) * (end - begin &#43; 1)); } 在这段代码有些部分我们在下面单独讲解一下：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-16T12:25:47+08:00">
    <meta property="article:modified_time" content="2024-04-16T12:25:47+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深入理解数据结构第六弹——排序（3）——归并排序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>排序1：<a href="https://blog.csdn.net/2301_80220607/article/details/137565797?spm=1001.2014.3001.5501" title="深入了解数据结构第四弹——排序（1）——插入排序和希尔排序-CSDN博客">深入了解数据结构第四弹——排序（1）——插入排序和希尔排序-CSDN博客</a></p> 
<p>排序2：<a href="https://blog.csdn.net/2301_80220607/article/details/137696296?spm=1001.2014.3001.5501" title="深入理解数据结构第五弹——排序（2）——快速排序-CSDN博客">深入理解数据结构第五弹——排序（2）——快速排序-CSDN博客</a></p> 
<p><strong>前言：</strong></p> 
<blockquote> 
 <p>在前面，我们已经学习了插入排序、堆排序、快速排序等一系列排序，今天我们来讲解一下另一个很高效的排序方法——归并排序</p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%9D%E6%83%B3-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%9D%E6%83%B3" rel="nofollow">一、归并排序的思想</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0" rel="nofollow">二、归并排序的递归实现</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0" rel="nofollow">三、归并排序的非递归实现</a></p> 
<p id="%E5%9B%9B%E3%80%81%E5%AE%8C%E6%95%B4%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%E3%80%81%E5%AE%8C%E6%95%B4%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B" rel="nofollow">四、完整的代码实例</a></p> 
<p id="%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93" rel="nofollow">五、总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="%E4%B8%80%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%9D%E6%83%B3">一、归并排序的思想</h3> 
<blockquote> 
 <p>归并排序是一种经典的排序算法，它采用了分治法的思想。分治法的核心是“分而治之”，即将一个复杂的问题分解成两个或多个相同或相似的子问题，将这些子问题逐个解决，最后将子问题的解合并以解决原问题。</p> 
</blockquote> 
<p>归并排序的基本思想如下：</p> 
<blockquote> 
 <ol><li> <p><strong>分解（Divide）</strong>：</p> 
   <ul><li>将待排序的数组从中间分成两半，递归地对这两半分别进行归并排序。</li><li>一直分解，直到每个子数组只包含一个元素，因为一个元素的数组自然是有序的。</li></ul></li><li> <p><strong>解决（Conquer）</strong>：</p> 
   <ul><li>当分解到最小子问题时，即每个子数组只有一个元素时，开始解决这些小问题。</li><li>解决的方式是合并（Merge）两个有序的子数组，从而得到一个更大的有序数组。</li></ul></li><li> <p><strong>合并（Merge）</strong>：</p> 
   <ul><li>合并过程是归并排序的关键步骤。它将两个有序的子数组合并成一个有序的数组。</li><li>通常使用两个指针分别指向两个子数组的起始位置，然后比较两个指针所指向的元素，将较小的元素放入结果数组中，并移动该指针。</li><li>重复这个过程，直到一个子数组被完全合并到结果数组中，然后将另一个子数组的剩余元素直接复制到结果数组中。</li></ul></li></ol> 
</blockquote> 
<p>归并排序的操作如下：</p> 
<p><img alt="" height="660" src="https://images2.imgbox.com/81/0f/69Fc1coB_o.jpg" width="1049"></p> 
<blockquote> 
 <p>归并操作其实就是将一组数据通过递归等不断划分成两个部分，直到划分到一个元素之后，再对这两部分排序排进一个数组内，相当于把划分的过程再反过来走了一遍，只是走回去的过程中会把数组一步一步的有序化</p> 
</blockquote> 
<h3 id="%E4%BA%8C%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0">二、归并排序的递归实现</h3> 
<p>递归的实现其实是很有意思的，在上面我们已经讲了递归的思想，其实就是不断的重复划分然后排序的过程，所以我们就可以设计一个递归来实现这种，同时，由于每一步都要进行分区划分，所以我们可以封装一个<span style="color:#fe2c24;"><strong>划分函数（_MergeSort函数）</strong></span>在前，重复这个过程</p> 
<pre><code class="language-cpp">void MergeSort(int* a, int n)
{
	int* tmp = (int*)malloc(sizeof(int) * n);

	_MergeSort(a, 0, n - 1,tmp);

	free(tmp);
}
</code></pre> 
<blockquote> 
 <p>1、因为我们在划分结束后，需要将各个小的部分再排序成一个有序的大部分，所以我们创建一个tmp的指针指向一个与原数组一样大小的空间，然后每一次排序放进这个空间，最后再把这个空间中的数据复制回原数组</p> 
 <p>2、其中<span style="color:#fe2c24;"><strong>_MergeSort</strong></span>函数内参数分别为原数组指针，首元素位置，尾元素位置，tmp指针</p> 
</blockquote> 
<p>然后我们就来实现这个分步函数，这个函数的功能就是实现将一个数组不断分为两个部分，当划分成最小单元时，两个两个比较大小，并且放入tmp中，再复制进原数组中，我们先拿数组<span style="color:#fe2c24;"><strong> { 8 ，7，6，5，4，3，2，1 } </strong></span>举个例子</p> 
<p><img alt="" height="556" src="https://images2.imgbox.com/36/26/eVOOmqqd_o.png" width="1087"></p> 
<p><strong>实现上述过程的代码如下</strong></p> 
<pre><code class="language-cpp">//归并排序
void _MergeSort(int* a, int begin,int end,int* tmp)
{
	if (begin == end)
		return;

	//小区间优化
	if (end - begin + 1 &lt; 10)
	{
		InsertSort(a + begin, begin - end + 1);
	}

	int mid = (begin + end) / 2;
	_MergeSort(a, begin, mid, tmp);
	_MergeSort(a, mid + 1, end, tmp);
	
	int begin1 = begin, end1 = mid;
	int begin2 = mid + 1, end2 = end;
	int i = begin;
	while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)
	{
		if (a[begin1] &lt; a[begin2])
		{
			tmp[i++] = a[begin1];
			begin1++;
		}
		else
			tmp[i++] = a[begin2++];
	}
	while (begin1 &lt;= end1)
	{
		tmp[i++] = a[begin1++];
	}
	while (begin2 &lt;= end2)
	{
		tmp[i++] = a[begin2++];
	}
	memcpy(a + begin, tmp + begin, sizeof(int) * (end - begin + 1));
}
</code></pre> 
<p>在这段代码有些部分我们在下面单独讲解一下：</p> 
<p><strong>小区间优化是什么及其作用</strong></p> 
<p><img alt="" height="546" src="https://images2.imgbox.com/90/4c/kPYOCWbA_o.png" width="1200"></p> 
<h3 id="%E4%B8%89%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0">三、归并排序的非递归实现</h3> 
<p>学习完归并排序的递归实现后，我们来看一下归并排序的非递归实现</p> 
<blockquote> 
 <p>归并排序由于需要不断划分，可想而知其非递归实现是一定需要用到循环的，但是它其实还是有几个很大的坑等着我们的，归并排序的非递归实现要比其递归实现复杂的多</p> 
</blockquote> 
<p><span style="background-color:#ffd900;">归并排序非递归实现需要注意的点：</span></p> 
<blockquote> 
 <p><strong>1、在上面举的例子中我们都是举的2的n次方的例子，所以能恰好完全归并，但是我们实际排序时也可能遇到排11个数等，这里就比较麻烦了，所以我们需要分情况处理</strong></p> 
 <p><strong>2、由于上面在循环归并时次数的不确定性，所以我们每一次循环排序结束都要拷贝回原数组</strong></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ff/cb/2sxEUavn_o.png"></p> 
<p>如图，我们在对两个数组进行归并时是要定义两个数组的起始位置的，但是我们可能会遇到下面三种情况：</p> 
<blockquote> 
 <p><strong>1、end1&gt;n，即从end1开始就超出数组长度</strong></p> 
 <p><strong>2、end1&lt;n,begin2&gt;n，即从begin2开始超出数组长度</strong></p> 
 <p><strong>3、end2&gt;n，即从end2开始才超出数组长度</strong></p> 
 <p><strong>不管这上面哪一种，都会导致我们之后的归并排序中会有数组落单，所以我们就需要针对这中情况进行处理</strong></p> 
</blockquote> 
<p><img alt="" height="431" src="https://images2.imgbox.com/11/7a/EDmTFchP_o.png" width="575"></p> 
<p><strong>针对这种情况我们有两种解决方法：</strong></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>1、跳出：</strong></span>就是当end1或者begin2大于n时跳出不进行处理</p> 
 <p><span style="color:#fe2c24;"><strong>2、优化：</strong></span>就是将end1、begin2、end2进行优化处理，让它能够进行操作</p> 
</blockquote> 
<p>具体操作如下：</p> 
<p><span style="color:#fe2c24;"><strong>1、跳出的思想</strong></span></p> 
<pre><code class="language-cpp">//非递归的归并排序(跳出的思想）
void MergeSortNonR(int* a, int n)
{
	int* tmp = (int*)malloc(sizeof(int) * n);
	int gap = 1;
	while (gap &lt; n)
	{
		gap *= 2;
		int j = 0;
		for (int i = 0; i &lt; n; i += 2 * gap)
		{
			int begin1 = i, end1 = i + gap - 1;
			int begin2 = i + gap, end2 = i + gap * 2 - 1;
			
			if (end1 &gt;= n || begin2 &gt;= n)
			{
				break;
			}
			if (end2 &gt;= n)
			{
				end2 = n - 1;
			}

			while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)
			{
				if (a[begin1] &lt; a[begin2])
				{
					tmp[j++] = a[begin1++];
				}
				else
				{
					tmp[j++] = a[begin2++];
				}
			}
			
			while (begin1 &lt;= end1)
			{
				tmp[j++] = a[begin1++];
			}
			while (begin2 &lt;= end2)
			{
				tmp[j++] = a[begin2++];
			}

			memcpy(a + i, tmp + i, sizeof(int) * (end2 - i + 1));
		}
	}
	free(tmp);
}
</code></pre> 
<p><span style="color:#fe2c24;"><strong>2、优化的思想</strong></span></p> 
<pre><code class="language-cpp">//非递归的归并排序（修正的思路）
void MergeSortNonR2(int* a, int n)
{
	int* tmp = (int*)malloc(sizeof(int) * n);
	int gap = 1;
	while (gap &lt; n)
	{
		gap *= 2;
		int j = 0;
		for (int i = 0; i &lt; n; i += 2 * gap)
		{
			int begin1 = i, end1 = i + gap - 1;
			int begin2 = i + gap, end2 = i + gap * 2 - 1;

			if (end1 &gt;= n )
			{
				end1 = n - 1;
				begin2 = n;
				end2 = n - 1;
			}
			else if (begin2 &gt;= n)
			{
				begin2 = n;
				end2 = n - 1;
			}
			else if (end2 &gt;= n)
			{
				end2 = n - 1;
			}

			while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)
			{
				if (a[begin1] &lt; a[begin2])
				{
					tmp[j++] = a[begin1++];
				}
				else
				{
					tmp[j++] = a[begin2++];
				}
			}

			while (begin1 &lt;= end1)
			{
				tmp[j++] = a[begin1++];
			}
			while (begin2 &lt;= end2)
			{
				tmp[j++] = a[begin2++];
			}

			memcpy(a + i, tmp + i, sizeof(int) * (end2 - i + 1));
		}
	}
	free(tmp);
}
</code></pre> 
<h3 id="%E5%9B%9B%E3%80%81%E5%AE%8C%E6%95%B4%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B">四、完整的代码实例</h3> 
<p>下面我们通过<span style="color:#fe2c24;"><strong>排序数组{ 4,7,1,9,3,6,5,6,8,3,2,0,6 }</strong></span>来检验这三种方法是否成功（递归一种，非递归i两种）</p> 
<p>SeqList.h</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
//归并排序
void MergeSort(int* a, int n);</code></pre> 
<p>test.c</p> 
<pre><code class="language-cpp">//测试归并排序
void TestMergeSort()
{
	int a[] = { 4,7,1,9,3,6,5,6,8,3,2,0,6 };
	int b[]= { 4,7,1,9,3,6,5,6,8,3,2,0,6 };
	int c[]= { 4,7,1,9,3,6,5,6,8,3,2,0,6 };
	printf("a数组排序前：");
	PrintArray(a, sizeof(a) / sizeof(a[0]));
	MergeSort(a, sizeof(a) / sizeof(a[0]));   //递归法
	printf("a数组排序后（递归法）：");
	PrintArray(a, sizeof(a) / sizeof(a[0]));
	printf("\n");

	printf("b数组排序前：");
	PrintArray(b, sizeof(b) / sizeof(b[0]));
	MergeSortNonR(b, sizeof(b) / sizeof(b[0]));   //非递归法(跳出法）
	printf("b数组排序后（跳过法）：");
	PrintArray(b, sizeof(b) / sizeof(b[0]));
	printf("\n");

	printf("c数组排序前：");
	PrintArray(c, sizeof(c) / sizeof(c[0]));
	MergeSortNonR2(c, sizeof(c) / sizeof(c[0]));   //非递归法（修正法）
	printf("c数组排序后（修正法）：");
	PrintArray(c, sizeof(c) / sizeof(c[0]));
	printf("\n");
}
int main()
{
	
	TestMergeSort();
	
	return 0;
}
</code></pre> 
<p>SeqList.c</p> 
<pre><code class="language-cpp">//归并排序
void _MergeSort(int* a, int begin,int end,int* tmp)
{
	if (begin == end)
		return;

	//小区间优化
	if (end - begin + 1 &lt; 10)
	{
		InsertSort(a + begin, begin - end + 1);
	}

	int mid = (begin + end) / 2;
	_MergeSort(a, begin, mid, tmp);
	_MergeSort(a, mid + 1, end, tmp);
	
	int begin1 = begin, end1 = mid;
	int begin2 = mid + 1, end2 = end;
	int i = begin;
	while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)
	{
		if (a[begin1] &lt; a[begin2])
		{
			tmp[i++] = a[begin1];
			begin1++;
		}
		else
			tmp[i++] = a[begin2++];
	}
	while (begin1 &lt;= end1)
	{
		tmp[i++] = a[begin1++];
	}
	while (begin2 &lt;= end2)
	{
		tmp[i++] = a[begin2++];
	}
	memcpy(a + begin, tmp + begin, sizeof(int) * (end - begin + 1));
}
void MergeSort(int* a, int n)
{
	int* tmp = (int*)malloc(sizeof(int) * n);

	_MergeSort(a, 0, n - 1,tmp);

	free(tmp);
}
//非递归的归并排序(跳出的思想）
void MergeSortNonR(int* a, int n)
{
	int* tmp = (int*)malloc(sizeof(int) * n);
	int gap = 1;
	while (gap &lt; n)
	{
		int j = 0;
		for (int i = 0; i &lt; n; i += 2 * gap)
		{
			int begin1 = i, end1 = i + gap - 1;
			int begin2 = i + gap, end2 = i + gap * 2 - 1;
			
			if (end1 &gt;= n || begin2 &gt;= n)
			{
				break;
			}
			if (end2 &gt;= n)
			{
				end2 = n - 1;
			}

			while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)
			{
				if (a[begin1] &lt; a[begin2])
				{
					tmp[j++] = a[begin1++];
				}
				else
				{
					tmp[j++] = a[begin2++];
				}
			}
			
			while (begin1 &lt;= end1)
			{
				tmp[j++] = a[begin1++];
			}
			while (begin2 &lt;= end2)
			{
				tmp[j++] = a[begin2++];
			}

			memcpy(a + i, tmp + i, sizeof(int) * (end2 - i + 1));
		}
		gap *= 2;

	}
	free(tmp);
}
//非递归的归并排序（修正的思路）
void MergeSortNonR2(int* a, int n)
{
	int* tmp = (int*)malloc(sizeof(int) * n);
	int gap = 1;
	while (gap &lt; n)
	{
		int j = 0;
		for (int i = 0; i &lt; n; i += 2 * gap)
		{
			int begin1 = i, end1 = i + gap - 1;
			int begin2 = i + gap, end2 = i + gap * 2 - 1;

			if (end1 &gt;= n )
			{
				end1 = n - 1;
				begin2 = n;
				end2 = n - 1;
			}
			else if (begin2 &gt;= n)
			{
				begin2 = n;
				end2 = n - 1;
			}
			else if (end2 &gt;= n)
			{
				end2 = n - 1;
			}

			while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)
			{
				if (a[begin1] &lt; a[begin2])
				{
					tmp[j++] = a[begin1++];
				}
				else
				{
					tmp[j++] = a[begin2++];
				}
			}

			while (begin1 &lt;= end1)
			{
				tmp[j++] = a[begin1++];
			}
			while (begin2 &lt;= end2)
			{
				tmp[j++] = a[begin2++];
			}

			memcpy(a + i, tmp + i, sizeof(int) * (end2 - i + 1));
		}
		gap *= 2;
	}
	free(tmp);
}
//打印数组
void PrintArray(int* a, int n)
{
	for (int i = 0; i &lt; n; i++)
	{
		printf("%d ", a[i]);
	}
	printf("\n");
}
</code></pre> 
<p><strong>程序运行结果：</strong></p> 
<p><img alt="" height="422" src="https://images2.imgbox.com/90/82/8x1Oc5Df_o.png" width="1110"></p> 
<h3 id="%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93">五、总结</h3> 
<blockquote> 
 <p>综合以上，我们其实就可以清楚的认识到归并排序的有趣及其思想，这篇文章并没有将归并排序的时间复杂度和适用场景等问题，我打算在后边写一个总结的文章，将这几种排序放在一起比较，给出他们时间复杂度的快慢和适用场景的不同，敬请期待吧！！！</p> 
</blockquote> 
<p><strong><span style="background-color:#ffd900;">谢谢各位大佬观看，创作不易，还请各位大佬点赞支持！！！</span></strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/425c91ea388a0b46d546447f098142ef/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Redis实现JWT（JSON Web TOKEN）自动延长TOKEN过期时间</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0492d7e8ef136e4ba35d69944483b2f6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【安装部署】Apache SeaTunnel 和 Web快速安装详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>