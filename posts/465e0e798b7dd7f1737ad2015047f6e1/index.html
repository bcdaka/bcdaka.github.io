<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Rust】——使用Drop Trait 运行清理代码和Rc＜T＞ 引用计数智能指针 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/465e0e798b7dd7f1737ad2015047f6e1/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【Rust】——使用Drop Trait 运行清理代码和Rc＜T＞ 引用计数智能指针">
  <meta property="og:description" content="💻博主现有专栏：
C51单片机（STC89C516），c语言，c&#43;&#43;，离散数学，算法设计与分析，数据结构，Python，Java基础，MySQL，linux，基于HTML5的网页设计及应用，Rust（官方文档重点总结），jQuery，前端vue.js，Javaweb开发，Python机器学习等
🥏主页链接：
Y小夜-CSDN博客
目录
🎯使用Drop Trait 运行清理代码
🎃通过std::mem::drop提早丢弃值
🎯Rc 引用计数智能指针
🎃使用Rc共享数据
🎃克隆Rc会增加引用计数
🎯使用Drop Trait 运行清理代码 对于智能指针模式来说第二个重要的 trait 是 Drop，其允许我们在值要离开作用域时执行一些代码。可以为任何类型提供 Drop trait 的实现，同时所指定的代码被用于释放类似于文件或网络连接的资源。
我们在智能指针上下文中讨论 Drop 是因为其功能几乎总是用于实现智能指针。
在其他一些语言中的某些类型，我们不得不记住在每次使用完那些类型的智能指针实例后调用清理内存或资源的代码。如果忘记的话，运行代码的系统可能会因为负荷过重而崩溃。在 Rust 中，可以指定每当值离开作用域时被执行的代码，编译器会自动插入这些代码。于是我们就不需要在程序中到处编写在实例结束时清理这些变量的代码 —— 而且还不会泄漏资源。
指定在值离开作用域时应该执行的代码的方式是实现 Drop trait。Drop trait 要求实现一个叫做 drop 的方法，它获取一个 self 的可变引用。为了能够看出 Rust 何时调用 drop，让我们暂时使用 println! 语句实现 drop。
struct CustomSmartPointer { data: String, } impl Drop for CustomSmartPointer { fn drop(&amp;mut self) { println!(&#34;Dropping CustomSmartPointer with data `{}`!&#34;, self.data); } } fn main() { let c = CustomSmartPointer { data: String::from(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-01T12:19:40+08:00">
    <meta property="article:modified_time" content="2024-05-01T12:19:40+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Rust】——使用Drop Trait 运行清理代码和Rc＜T＞ 引用计数智能指针</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong>💻博主现有专栏：</strong></p> 
 <p><strong>                C51单片机（STC89C516），c语言，c++，离散数学，算法设计与分析，数据结构，Python，Java基础，MySQL，linux，基于HTML5的网页设计及应用，Rust（官方文档重点总结），jQuery，前端vue.js，Javaweb开发，Python机器学习等<br> 🥏主页链接：</strong></p> 
 <p><strong>                </strong><a href="https://blog.csdn.net/shsjssnn?spm=1000.2115.3001.5343" title="Y小夜-CSDN博客">Y小夜-CSDN博客</a></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%F0%9F%8E%AF%E4%BD%BF%E7%94%A8Drop%20Trait%20%E8%BF%90%E8%A1%8C%E6%B8%85%E7%90%86%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;"><a href="#%F0%9F%8E%AF%E4%BD%BF%E7%94%A8Drop%20Trait%20%E8%BF%90%E8%A1%8C%E6%B8%85%E7%90%86%E4%BB%A3%E7%A0%81" rel="nofollow">🎯使用Drop Trait 运行清理代码</a></p> 
<p id="%F0%9F%8E%AF%E9%80%9A%E8%BF%87std%3A%3Amem%3A%3Adrop%E6%8F%90%E6%97%A9%E4%B8%A2%E5%BC%83%E5%80%BC-toc" style="margin-left:40px;"><a href="#%F0%9F%8E%AF%E9%80%9A%E8%BF%87std%3A%3Amem%3A%3Adrop%E6%8F%90%E6%97%A9%E4%B8%A2%E5%BC%83%E5%80%BC" rel="nofollow">🎃通过std::mem::drop提早丢弃值</a></p> 
<p id="%F0%9F%8E%AFRc%3CT%3E%20%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-toc" style="margin-left:0px;"><a href="#%F0%9F%8E%AFRc%3CT%3E%20%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88" rel="nofollow">🎯Rc 引用计数智能指针</a></p> 
<p id="%F0%9F%8E%83%E4%BD%BF%E7%94%A8Rc%3CT%3E%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#%F0%9F%8E%83%E4%BD%BF%E7%94%A8Rc%3CT%3E%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE" rel="nofollow">🎃使用Rc共享数据</a></p> 
<p id="%F0%9F%8E%83%E5%85%8B%E9%9A%86Rc%3CT%3E%E4%BC%9A%E5%A2%9E%E5%8A%A0%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0-toc" style="margin-left:40px;"><a href="#%F0%9F%8E%83%E5%85%8B%E9%9A%86Rc%3CT%3E%E4%BC%9A%E5%A2%9E%E5%8A%A0%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0" rel="nofollow">🎃克隆Rc会增加引用计数</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%F0%9F%8E%AF%E4%BD%BF%E7%94%A8Drop%20Trait%20%E8%BF%90%E8%A1%8C%E6%B8%85%E7%90%86%E4%BB%A3%E7%A0%81">🎯使用Drop Trait 运行清理代码</h2> 
<blockquote> 
 <p>        对于智能指针模式来说第二个重要的 trait 是 <code>Drop</code>，其允许我们在值要离开作用域时执行一些代码。可以为任何类型提供 <code>Drop</code> trait 的实现，同时所指定的代码被用于释放类似于文件或网络连接的资源。</p> 
 <p>        我们在智能指针上下文中讨论 <code>Drop</code> 是因为其功能几乎总是用于实现智能指针。</p> 
 <p>        在其他一些语言中的某些类型，我们不得不记住在每次使用完那些类型的智能指针实例后调用清理内存或资源的代码。如果忘记的话，运行代码的系统可能会因为负荷过重而崩溃。在 Rust 中，可以指定每当值离开作用域时被执行的代码，编译器会自动插入这些代码。于是我们就不需要在程序中到处编写在实例结束时清理这些变量的代码 —— 而且还不会泄漏资源。</p> 
 <p>        指定在值离开作用域时应该执行的代码的方式是实现 <code>Drop</code> trait。<code>Drop</code> trait 要求实现一个叫做 <code>drop</code> 的方法，它获取一个 <code>self</code> 的可变引用。为了能够看出 Rust 何时调用 <code>drop</code>，让我们暂时使用 <code>println!</code> 语句实现 <code>drop</code>。</p> 
 <pre><code class="language-rust">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from("my stuff"),
    };
    let d = CustomSmartPointer {
        data: String::from("other stuff"),
    };
    println!("CustomSmartPointers created.");
}</code></pre> 
 <p><code>   Drop</code> trait 包含在 prelude 中，所以无需导入它。我们在 <code>CustomSmartPointer</code> 上实现了 <code>Drop</code> trait，并提供了一个调用 <code>println!</code> 的 <code>drop</code> 方法实现。<code>drop</code> 函数体是放置任何当类型实例离开作用域时期望运行的逻辑的地方。这里选择打印一些文本以可视化地展示 Rust 何时调用 <code>drop</code>。</p> 
 <p>        在 <code>main</code> 中，我们新建了两个 <code>CustomSmartPointer</code> 实例并打印出了 <code>CustomSmartPointer created.</code>。在 <code>main</code> 的结尾，<code>CustomSmartPointer</code> 的实例会离开作用域，而 Rust 会调用放置于 <code>drop</code> 方法中的代码，打印出最后的信息。注意无需显式调用 <code>drop</code> 方法：</p> 
 <p>当运行这个程序，会出现如下输出：</p> 
 <pre><code class="language-rust">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.60s
     Running `target/debug/drop-example`
CustomSmartPointers created.
Dropping CustomSmartPointer with data `other stuff`!
Dropping CustomSmartPointer with data `my stuff`!
</code></pre> 
 <p>        当实例离开作用域 Rust 会自动调用 <code>drop</code>，并调用我们指定的代码。变量以被创建时相反的顺序被丢弃，所以 <code>d</code> 在 <code>c</code> 之前被丢弃。这个例子的作用是给了我们一个 drop 方法如何工作的可视化指导，不过通常需要指定类型所需执行的清理代码而不是打印信息。</p> 
</blockquote> 
<h3 id="%F0%9F%8E%AF%E9%80%9A%E8%BF%87std%3A%3Amem%3A%3Adrop%E6%8F%90%E6%97%A9%E4%B8%A2%E5%BC%83%E5%80%BC">🎃通过std::mem::drop提早丢弃值</h3> 
<blockquote> 
 <p>        不幸的是，我们并不能直截了当的禁用 <code>drop</code> 这个功能。通常也不需要禁用 <code>drop</code> ；整个 <code>Drop</code> trait 存在的意义在于其是自动处理的。然而，有时你可能需要提早清理某个值。一个例子是当使用智能指针管理锁时；你可能希望强制运行 <code>drop</code> 方法来释放锁以便作用域中的其他代码可以获取锁。Rust 并不允许我们主动调用 <code>Drop</code> trait 的 <code>drop</code> 方法；当我们希望在作用域结束之前就强制释放变量的话，我们应该使用的是由标准库提供的 <code>std::mem::drop</code>。</p> 
 <pre><code class="language-rust">fn main() {
    let c = CustomSmartPointer {
        data: String::from("some data"),
    };
    println!("CustomSmartPointer created.");
    c.drop();
    println!("CustomSmartPointer dropped before the end of main.");
}</code></pre> 
 <p>如果尝试编译代码会得到如下错误：</p> 
 <pre><code class="language-rust">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
error[E0040]: explicit use of destructor method
  --&gt; src/main.rs:16:7
   |
16 |     c.drop();
   |     --^^^^--
   |     | |
   |     | explicit destructor calls not allowed
   |     help: consider using `drop` function: `drop(c)`

For more information about this error, try `rustc --explain E0040`.
error: could not compile `drop-example` due to previous error
</code></pre> 
 <p>        错误信息表明不允许显式调用 <code>drop</code>。错误信息使用了术语 <strong>析构函数</strong>（<em>destructor</em>），这是一个清理实例的函数的通用编程概念。<strong>析构函数</strong> 对应创建实例的 <strong>构造函数</strong>。Rust 中的 <code>drop</code> 函数就是这么一个析构函数。</p> 
 <p><code>        Drop</code> trait 实现中指定的代码可以用于许多方面，来使得清理变得方便和安全：比如可以用其创建我们自己的内存分配器！通过 <code>Drop</code> trait 和 Rust 所有权系统，你无需担心之后的代码清理，Rust 会自动考虑这些问题。</p> 
 <p>        我们也无需担心意外的清理掉仍在使用的值，这会造成编译器错误：所有权系统确保引用总是有效的，也会确保 <code>drop</code> 只会在值不再被使用时被调用一次。</p> 
</blockquote> 
<h2 id="%F0%9F%8E%AFRc%3CT%3E%20%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">🎯Rc&lt;T&gt; 引用计数智能指针</h2> 
<blockquote> 
 <p>        大部分情况下所有权是非常明确的：可以准确地知道哪个变量拥有某个值。然而，有些情况单个值可能会有多个所有者。例如，在图数据结构中，多个边可能指向相同的节点，而这个节点从概念上讲为所有指向它的边所拥有。节点在没有任何边指向它从而没有任何所有者之前，都不应该被清理掉。</p> 
 <p>        为了启用多所有权需要显式地使用 Rust 类型 <code>Rc&lt;T&gt;</code>，其为 <strong>引用计数</strong>（<em>reference counting</em>）的缩写。引用计数意味着记录一个值的引用数量来知晓这个值是否仍在被使用。如果某个值有零个引用，就代表没有任何有效引用并可以被清理。</p> 
 <p><code>  Rc&lt;T&gt;</code> 用于当我们希望在堆上分配一些内存供程序的多个部分读取，而且无法在编译时确定程序的哪一部分会最后结束使用它的时候。如果确实知道哪部分是最后一个结束使用的话，就可以令其成为数据的所有者，正常的所有权规则就可以在编译时生效。</p> 
</blockquote> 
<h3 id="%F0%9F%8E%83%E4%BD%BF%E7%94%A8Rc%3CT%3E%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE">🎃使用Rc&lt;T&gt;共享数据</h3> 
<blockquote> 
 <p>        可以改变 <code>Cons</code> 的定义来存放一个引用，不过接着必须指定生命周期参数。通过指定生命周期参数，表明列表中的每一个元素都至少与列表本身存在的一样久。这是示例 15-17 中元素与列表的情况，但并不是所有情况都如此。</p> 
 <p>        现在每一个 <code>Cons</code> 变量都包含一个值和一个指向 <code>List</code> 的 <code>Rc&lt;T&gt;</code>。当创建 <code>b</code> 时，不同于获取 <code>a</code> 的所有权，这里会克隆 <code>a</code> 所包含的 <code>Rc&lt;List&gt;</code>，这会将引用计数从 1 增加到 2 并允许 <code>a</code> 和 <code>b</code> 共享 <code>Rc&lt;List&gt;</code> 中数据的所有权。创建 <code>c</code> 时也会克隆 <code>a</code>，这会将引用计数从 2 增加为 3。每次调用 <code>Rc::clone</code>，<code>Rc&lt;List&gt;</code> 中数据的引用计数都会增加，直到有零个引用之前其数据都不会被清理。</p> 
 <pre><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}</code></pre> 
 <p>        需要使用 <code>use</code> 语句将 <code>Rc&lt;T&gt;</code> 引入作用域，因为它不在 prelude 中。在 <code>main</code> 中创建了存放 5 和 10 的列表并将其存放在 <code>a</code> 的新的 <code>Rc&lt;List&gt;</code> 中。接着当创建 <code>b</code> 和 <code>c</code> 时，调用 <code>Rc::clone</code> 函数并传递 <code>a</code> 中 <code>Rc&lt;List&gt;</code> 的引用作为参数。</p> 
 <p>        也可以调用 <code>a.clone()</code> 而不是 <code>Rc::clone(&amp;a)</code>，不过在这里 Rust 的习惯是使用 <code>Rc::clone</code>。<code>Rc::clone</code> 的实现并不像大部分类型的 <code>clone</code> 实现那样对所有数据进行深拷贝。<code>Rc::clone</code> 只会增加引用计数，这并不会花费多少时间。深拷贝可能会花费很长时间。通过使用 <code>Rc::clone</code> 进行引用计数，可以明显的区别深拷贝类的克隆和增加引用计数类的克隆。当查找代码中的性能问题时，只需考虑深拷贝类的克隆而无需考虑 <code>Rc::clone</code> 调用。</p> 
</blockquote> 
<h3 id="%F0%9F%8E%83%E5%85%8B%E9%9A%86Rc%3CT%3E%E4%BC%9A%E5%A2%9E%E5%8A%A0%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0">🎃克隆Rc&lt;T&gt;会增加引用计数</h3> 
<blockquote> 
 <p>        以便观察创建和丢弃 <code>a</code> 中 <code>Rc&lt;List&gt;</code> 的引用时引用计数的变化。</p> 
 <p>        这样就可以观察当 <code>c</code> 离开作用域时引用计数如何变化。</p> 
 <pre><code class="language-rust">fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!("count after creating b = {}", Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!("count after creating c = {}", Rc::strong_count(&amp;a));
    }
    println!("count after c goes out of scope = {}", Rc::strong_count(&amp;a));
}</code></pre> 
 <p>        在程序中每个引用计数变化的点，会打印出引用计数，其值可以通过调用 <code>Rc::strong_count</code> 函数获得。这个函数叫做 <code>strong_count</code> 而不是 <code>count</code> 是因为 <code>Rc&lt;T&gt;</code> 也有 <code>weak_count</code>；</p> 
 <p>        从这个例子我们所不能看到的是，在 <code>main</code> 的结尾当 <code>b</code> 然后是 <code>a</code> 离开作用域时，此处计数会是 0，同时 <code>Rc&lt;List&gt;</code> 被完全清理。使用 <code>Rc&lt;T&gt;</code> 允许一个值有多个所有者，引用计数则确保只要任何所有者依然存在其值也保持有效。</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f993715445005d63f420e85d10dabf93/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Elasticsearch：理解近似最近邻 (ANN) 算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/859c477b4c1e491aa9e939a48a85d9e2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">前端之实现大文件上传的解决方案———断点续传</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>