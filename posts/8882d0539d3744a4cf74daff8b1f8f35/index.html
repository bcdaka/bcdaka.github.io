<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>利用【MATLAB】和【Python】进行【图与网络模型】的高级应用与分析】 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/8882d0539d3744a4cf74daff8b1f8f35/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="利用【MATLAB】和【Python】进行【图与网络模型】的高级应用与分析】">
  <meta property="og:description" content="专栏：数学建模学习笔记
一、图与网络的基本概念 1. 无向图与有向图 无向图：由顶点集合和边集合组成，边是无方向的。表示为 G=(V,E)，其中 V 是顶点集合， E 是边集合。有向图：边是有方向的，从一个顶点指向另一个顶点。表示为 G=(V,E)，其中每条边用有序对表示。 2. 简单图、完全图、赋权图 简单图：无重复边和自环的图。完全图：每对顶点之间都有边的图， Kn​ 表示n个顶点的完全图。赋权图：边带有权值的图，用于表示边的某种属性，如距离、费用等。 3. 顶点的度 度：与顶点相连的边的数目。在无向图中，顶点的度即为相连边的数目。在有向图中，入度为指向该顶点的边数，出度为从该顶点出发的边数。 4. 子图与连通性 子图：由原图的一部分顶点和边组成的图。连通性：图中任意两顶点之间存在路径。无向图称为连通图，有向图称为强连通图。 5. 图的矩阵表示 邻接矩阵：表示顶点之间是否有边的矩阵。若顶点 i 和顶点 j 之间有边，则矩阵A[i][j] 为1，否则为0。关联矩阵：表示顶点和边关系的矩阵。若边ek​ 连接顶点 vi​ 和 vj​，则矩阵 A[i][k] 和]A[j][k] 分别为1。 MATLAB代码实例 % MATLAB代码 % 创建无向图和有向图的邻接矩阵表示 % 无向图的邻接矩阵 A_undirected = [0 1 1 0; 1 0 1 1; 1 1 0 1; 0 1 1 0]; % 有向图的邻接矩阵 A_directed = [0 1 0 0; 0 0 1 0; 0 0 0 1; 1 0 0 0]; % 显示邻接矩阵 disp(&#39;无向图的邻接矩阵:&#39;); disp(A_undirected); disp(&#39;有向图的邻接矩阵:&#39;); disp(A_directed); % 创建图对象并可视化 G_undirected = graph(A_undirected); G_directed = digraph(A_directed); % 绘制图 figure; subplot(1,2,1); plot(G_undirected); title(&#39;无向图&#39;); subplot(1,2,2); plot(G_directed); title(&#39;有向图&#39;); 无向图的邻接矩阵: 0 1 1 0 1 0 1 1 1 1 0 1 0 1 1 0 有向图的邻接矩阵: 0 1 0 0 0 0 1 0 0 0 0 1 1 0 0 0 邻接矩阵表示 无向图的邻接矩阵：A_undirected 是一个4x4矩阵，其中 A_undirected(i, j) 表示顶点 i 和顶点 j 之间是否有边。对于无向图，矩阵是对称的。 有向图的邻接矩阵：A_directed 是一个4x4矩阵，其中 A_directed(i, j) 表示顶点 i 到顶点 j 之间是否有边。对于有向图，矩阵不是对称的。 显示邻接矩阵 使用 disp 函数显示无向图和有向图的邻接矩阵，以便于检查矩阵的正确性。 创建图对象并可视化 graph(A_undirected) 创建无向图对象。 digraph(A_directed) 创建有向图对象。 使用 plot 函数可视化图对象。subplot 函数将图分成两部分，分别显示无向图和有向图。 Python代码实例 import networkx as nx import matplotlib.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-23T21:59:58+08:00">
    <meta property="article:modified_time" content="2024-07-23T21:59:58+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">利用【MATLAB】和【Python】进行【图与网络模型】的高级应用与分析】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"></p> 
<p class="img-center"><img alt="ce6fbd68767d465bbe94b775b8b811db.png" height="111" src="https://images2.imgbox.com/2d/05/1wfJC0ac_o.png" width="111"></p> 
<p class="img-center"><img alt="731bd47804784fa2897220a90a387b28.gif" height="72" src="https://images2.imgbox.com/89/a3/nUUTNmwv_o.gif" width="230"></p> 
<blockquote> 
 <p>专栏：<a href="https://blog.csdn.net/2303_77720864/category_12707137.html" title="数学建模学习笔记">数学建模学习笔记</a></p> 
</blockquote> 
<h2 id="%E4%B8%80%E3%80%81%E5%9B%BE%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">一、图与网络的基本概念</h2> 
<h3 id="1.%20%E6%97%A0%E5%90%91%E5%9B%BE%E4%B8%8E%E6%9C%89%E5%90%91%E5%9B%BE"><strong>1. 无向图与有向图</strong></h3> 
<ul><li><strong>无向图</strong>：由顶点集合和边集合组成，边是无方向的。表示为 G=(V,E)，其中 V 是顶点集合， E 是边集合。</li><li><strong>有向图</strong>：边是有方向的，从一个顶点指向另一个顶点。表示为 G=(V,E)，其中每条边用有序对表示。</li></ul> 
<h3 id="2.%20%E7%AE%80%E5%8D%95%E5%9B%BE%E3%80%81%E5%AE%8C%E5%85%A8%E5%9B%BE%E3%80%81%E8%B5%8B%E6%9D%83%E5%9B%BE"><strong>2. 简单图、完全图、赋权图</strong></h3> 
<ul><li><strong>简单图</strong>：无重复边和自环的图。</li><li><strong>完全图</strong>：每对顶点之间都有边的图， Kn​ 表示n个顶点的完全图。</li><li><strong>赋权图</strong>：边带有权值的图，用于表示边的某种属性，如距离、费用等。</li></ul> 
<h3 id="3.%20%E9%A1%B6%E7%82%B9%E7%9A%84%E5%BA%A6"><strong>3. 顶点的度</strong></h3> 
<ul><li><strong>度</strong>：与顶点相连的边的数目。在无向图中，顶点的度即为相连边的数目。在有向图中，入度为指向该顶点的边数，出度为从该顶点出发的边数。</li></ul> 
<h3 id="4.%20%E5%AD%90%E5%9B%BE%E4%B8%8E%E8%BF%9E%E9%80%9A%E6%80%A7"><strong>4. 子图与连通性</strong></h3> 
<ul><li><strong>子图</strong>：由原图的一部分顶点和边组成的图。</li><li><strong>连通性</strong>：图中任意两顶点之间存在路径。无向图称为连通图，有向图称为强连通图。</li></ul> 
<h3 id="5.%20%E5%9B%BE%E7%9A%84%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA"><strong>5. 图的矩阵表示</strong></h3> 
<ul><li><strong>邻接矩阵</strong>：表示顶点之间是否有边的矩阵。若顶点 i 和顶点 j 之间有边，则矩阵A[i][j] 为1，否则为0。</li><li><strong>关联矩阵</strong>：表示顶点和边关系的矩阵。若边ek​ 连接顶点 vi​ 和 vj​，则矩阵 A[i][k] 和]A[j][k] 分别为1。</li></ul> 
<h3 id="MATLAB%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B"><strong>MATLAB代码实例</strong></h3> 
<pre><code>% MATLAB代码
% 创建无向图和有向图的邻接矩阵表示

% 无向图的邻接矩阵
A_undirected = [0 1 1 0; 
                1 0 1 1; 
                1 1 0 1; 
                0 1 1 0];

% 有向图的邻接矩阵
A_directed = [0 1 0 0; 
              0 0 1 0; 
              0 0 0 1; 
              1 0 0 0];

% 显示邻接矩阵
disp('无向图的邻接矩阵:');
disp(A_undirected);

disp('有向图的邻接矩阵:');
disp(A_directed);

% 创建图对象并可视化
G_undirected = graph(A_undirected);
G_directed = digraph(A_directed);

% 绘制图
figure;
subplot(1,2,1);
plot(G_undirected);
title('无向图');

subplot(1,2,2);
plot(G_directed);
title('有向图');
</code></pre> 
<pre><code>无向图的邻接矩阵:
     0     1     1     0
     1     0     1     1
     1     1     0     1
     0     1     1     0

有向图的邻接矩阵:
     0     1     0     0
     0     0     1     0
     0     0     0     1
     1     0     0     0</code></pre> 
<p><img alt="fc49499037b449d2a86556d2718af04d.png" src="https://images2.imgbox.com/8d/5d/RLfATBUy_o.png"></p> 
<pre><code>邻接矩阵表示

无向图的邻接矩阵：A_undirected 是一个4x4矩阵，其中 A_undirected(i, j) 表示顶点 i 和顶点 j 之间是否有边。对于无向图，矩阵是对称的。
有向图的邻接矩阵：A_directed 是一个4x4矩阵，其中 A_directed(i, j) 表示顶点 i 到顶点 j 之间是否有边。对于有向图，矩阵不是对称的。
显示邻接矩阵

使用 disp 函数显示无向图和有向图的邻接矩阵，以便于检查矩阵的正确性。
创建图对象并可视化

graph(A_undirected) 创建无向图对象。
digraph(A_directed) 创建有向图对象。
使用 plot 函数可视化图对象。subplot 函数将图分成两部分，分别显示无向图和有向图。</code></pre> 
<p></p> 
<h3 id="Python%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B%C2%A0"><strong>Python代码实例</strong> </h3> 
<pre><code>import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.font_manager import FontProperties

# 设置中文字体
font = FontProperties(fname=r"C:\Windows\Fonts\simsun.ttc", size=15)

# 无向图的邻接矩阵
A_undirected = np.array([
    [0, 1, 1, 0],
    [1, 0, 1, 1],
    [1, 1, 0, 1],
    [0, 1, 1, 0]
])

# 有向图的邻接矩阵
A_directed = np.array([
    [0, 1, 0, 0],
    [0, 0, 1, 0],
    [0, 0, 0, 1],
    [1, 0, 0, 0]
])

# 使用邻接矩阵创建无向图和有向图
G_undirected = nx.from_numpy_array(A_undirected)
G_directed = nx.from_numpy_array(A_directed, create_using=nx.DiGraph)

# 绘制无向图
plt.figure(figsize=(10, 5))
plt.subplot(1, 2, 1)
nx.draw(G_undirected, with_labels=True, node_color='skyblue', edge_color='black', node_size=1500, font_size=20)
plt.title('无向图', fontproperties=font)

# 绘制有向图
plt.subplot(1, 2, 2)
nx.draw(G_directed, with_labels=True, node_color='lightgreen', edge_color='red', node_size=1500, font_size=20, arrows=True)
plt.title('有向图', fontproperties=font)

plt.show()
</code></pre> 
<p><img alt="87a2bc261508473f91b2761a8ce8ac9b.png" src="https://images2.imgbox.com/4a/38/kkh4CD3d_o.png"></p> 
<p></p> 
<pre><code>注意的细节知识点

邻接矩阵表示

确保邻接矩阵的对称性（对于无向图）。
邻接矩阵的大小应为 n x n，其中 n 是顶点数量。
显示矩阵

使用 disp 或 print 函数显示矩阵，便于检查矩阵的正确性。
创建图对象

使用 graph 和 digraph 函数分别创建无向图和有向图对象。
确保输入的邻接矩阵符合图的类型（无向或有向）。
可视化图

使用 plot 函数可视化图对象，便于直观理解图的结构。
在Python中，可以使用 networkx 库中的 draw 函数进行可视化，matplotlib 库中的 subplot 函数分割图形窗口。
MATLAB和Python的差异

MATLAB中的 graph 和 digraph 函数对应于Python中的 nx.Graph 和 nx.DiGraph。
MATLAB中的 disp 函数对应于Python中的 print 函数。
MATLAB中的 plot 函数对应于Python中的 nx.draw 函数。</code></pre> 
<h2 id="%E4%BA%8C%E3%80%81%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98">二、最短路径问题</h2> 
<h3 id="1.%20%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9A%E4%B9%89"><strong>1. 最短路径问题的定义</strong></h3> 
<ul><li>最短路径问题是寻找从一个顶点到另一个顶点的路径，使得路径上的边权值和最小。</li></ul> 
<h3 id="2.%20Dijkstra%E7%AE%97%E6%B3%95"><strong>2. Dijkstra算法</strong></h3> 
<ul><li>适用于非负权图的单源最短路径问题。</li><li>算法步骤： 
  <blockquote> 
   <ol><li>初始化：设置起点到自己的距离为0，其他顶点为无穷大。</li><li>选择未处理的顶点中距离最小的顶点，将其标记为已处理。</li><li>更新该顶点的邻接顶点的距离。</li><li>重复步骤2和3，直到所有顶点都被处理。</li></ol> 
  </blockquote> </li></ul> 
<h4><strong>MATLAB代码实例</strong></h4> 
<pre><code>% MATLAB代码
% Dijkstra算法实现
function [dist, path] = dijkstra(A, start_node)
    n = size(A, 1); % 顶点数量
    dist = inf(1, n); % 初始化距离
    dist(start_node) = 0;
    visited = false(1, n); % 访问标记
    path = -ones(1, n); % 路径
    
    for i = 1:n
        % 选择未处理顶点中距离最小的顶点
        [~, u] = min(dist + visited * inf);
        visited(u) = true;
        
        % 更新邻接顶点的距离
        for v = 1:n
            if A(u, v) &gt; 0 &amp;&amp; ~visited(v)
                alt = dist(u) + A(u, v);
                if alt &lt; dist(v)
                    dist(v) = alt;
                    path(v) = u;
                end
            end
        end
    end
end

% 示例图的邻接矩阵
A = [0 10 20 0 0;
     10 0 5 1 0;
     20 5 0 2 3;
     0 1 2 0 4;
     0 0 3 4 0];

% 计算从起点1到其他顶点的最短路径
[start_node] = 1;
[dist, path] = dijkstra(A, start_node);

% 显示结果
disp('顶点的最短距离:');
disp(dist);
disp('最短路径:');
disp(path);

% 可视化结果
G = digraph(A);
figure;
h = plot(G, 'EdgeLabel', G.Edges.Weight);
highlight(h, path, 'EdgeColor', 'r', 'LineWidth', 2);
title('Dijkstra最短路径');
</code></pre> 
<pre><code>顶点的最短距离:
     0    10    20   Inf   Inf

最短路径:
    -1     1     1    -1    -1</code></pre> 
<p><img alt="af45e2f8acaf45e29c782ab9de8df17f.png" src="https://images2.imgbox.com/ec/24/5605SNuc_o.png"></p> 
<pre><code>初始化

n = size(A, 1)：获取图中顶点的数量。
dist = inf(1, n)：初始化每个顶点的距离为无穷大。
dist(start_node) = 0：起点到自身的距离为0。
visited = false(1, n)：初始化访问标记。
path = -ones(1, n)：初始化路径数组。
主循环

for i = 1:n：对每个顶点进行迭代。
[~, u] = min(dist + visited * inf)：选择未处理顶点中距离最小的顶点。
visited(u) = true：将该顶点标记为已处理。
更新邻接顶点的距离

for v = 1:n：对每个邻接顶点进行迭代。
if A(u, v) &gt; 0 &amp;&amp; ~visited(v)：如果顶点 v 与顶点 u 之间有边且未被访问。
alt = dist(u) + A(u, v)：计算通过顶点 u 到顶点 v 的距离。
if alt &lt; dist(v)：如果通过 u 到 v 的距离小于当前已知的 v 的距离。
dist(v) = alt：更新 v 的距离。
path(v) = u：更新 v 的路径。</code></pre> 
<h3 id="Python%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B"><strong>Python代码实例</strong></h3> 
<pre><code>import heapq

def dijkstra(A, start_node):
    n = len(A)
    dist = [float('inf')] * n
    dist[start_node] = 0
    visited = [False] * n
    path = [-1] * n
    queue = [(0, start_node)]
    
    while queue:
        d, u = heapq.heappop(queue)
        if visited[u]:
            continue
        visited[u] = True
        
        for v, weight in enumerate(A[u]):
            if weight &gt; 0 and not visited[v]:
                alt = dist[u] + weight
                if alt &lt; dist[v]:
                    dist[v] = alt
                    path[v] = u
                    heapq.heappush(queue, (alt, v))
    
    return dist, path

# 示例图的邻接矩阵
A = [
    [0, 10, 20, 0, 0],
    [10, 0, 5, 1, 0],
    [20, 5, 0, 2, 3],
    [0, 1, 2, 0, 4],
    [0, 0, 3, 4, 0]
]

# 计算从起点0到其他顶点的最短路径
start_node = 0
dist, path = dijkstra(A, start_node)

# 显示结果
print('顶点的最短距离:', dist)
print('最短路径:', path)
</code></pre> 
<pre><code>顶点的最短距离: [0, 10, 13, 11, 15]
最短路径: [-1, 0, 3, 1, 3]
</code></pre> 
<h2 id="%E4%B8%89%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98">三、最小生成树问题</h2> 
<h3 id="1.%20%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><strong>1. 最小生成树的定义</strong></h3> 
<ul><li>最小生成树（MST）是包含图中所有顶点且边权值和最小的生成树。</li></ul> 
<h3 id="2.%20Kruskal%E7%AE%97%E6%B3%95"><strong>2. Kruskal算法</strong></h3> 
<ul><li>适用于任意图。</li><li>算法步骤： 
  <ol><li>将图中的边按权值从小到大排序。</li><li>依次选择权值最小的边，若该边的加入不形成圈，则将其加入生成树。</li><li>重复步骤2，直到生成树包含所有顶点。</li></ol></li></ul> 
<h4><strong>MATLAB代码实例</strong></h4> 
<pre><code>% MATLAB代码
% Kruskal算法实现
function [mst_edges, mst_weight] = kruskal(A)
    n = size(A, 1);
    edges = [];
    for i = 1:n
        for j = i+1:n
            if A(i, j) &gt; 0
                edges = [edges; i, j, A(i, j)];
            end
        end
    end
    edges = sortrows(edges, 3);
    
    parent = 1:n;
    mst_edges = [];
    mst_weight = 0;
    
    function p = find(parent, x)
        if parent(x) == x
            p = x;
        else
            p = find(parent, parent(x));
            parent(x) = p;
        end
    end

    for k = 1:size(edges, 1)
        u = edges(k, 1);
        v = edges(k, 2);
        w = edges(k, 3);
        pu = find(parent, u);
        pv = find(parent, v);
        if pu ~= pv
            mst_edges = [mst_edges; u, v];
            mst_weight = mst_weight + w;
            parent(pu) = pv;
        end
    end
end

% 示例图的邻接矩阵
A = [0 10 6 5;
     10 0 0 15;
     6 0 0 4;
     5 15 4 0];

% 计算最小生成树
[mst_edges, mst_weight] = kruskal(A);

% 显示结果
disp('最小生成树的边:');
disp(mst_edges);
disp('最小生成树的权重:');
disp(mst_weight);

% 可视化结果
G = graph(A);
figure;
h = plot(G, 'EdgeLabel', G.Edges.Weight);
highlight(h, mst_edges(:,1), mst_edges(:,2), 'EdgeColor', 'r', 'LineWidth', 2);
title('Kruskal最小生成树');
</code></pre> 
<pre><code>最小生成树的边:
     3     4
     1     4
     1     2

最小生成树的权重:
    19</code></pre> 
<p><img alt="0062511ce45c41a69d9cab28be8908a8.png" src="https://images2.imgbox.com/a8/33/qW4PjPUv_o.png"></p> 
<pre><code>初始化

n = size(A, 1)：获取图中顶点的数量。
edges = []：初始化边的列表。
使用嵌套循环遍历邻接矩阵，收集所有边的信息。
边的排序

edges = sortrows(edges, 3)：按边的权值从小到大排序。
并查集的初始化

parent = 1:n：初始化每个顶点的父节点为自身。
mst_edges = []：初始化最小生成树的边列表。
mst_weight = 0：初始化最小生成树的权重和。
并查集查找函数

function p = find(parent, x)：递归查找顶点的根节点，并进行路径压缩。</code></pre> 
<h3><strong>Python代码实例</strong></h3> 
<pre><code>class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
    
    def find(self, u):
        if self.parent[u] != u:
            self.parent[u] = self.find(self.parent[u])
        return self.parent[u]
    
    def union(self, u, v):
        root_u = self.find(u)
        root_v = self.find(v)
        if root_u != root_v:
            self.parent[root_u] = root_v

def kruskal(A):
    n = len(A)
    edges = [(A[i][j], i, j) for i in range(n) for j in range(i + 1, n) if A[i][j] &gt; 0]
    edges.sort()
    
    uf = UnionFind(n)
    mst_edges = []
    mst_weight = 0
    
    for weight, u, v in edges:
        if uf.find(u) != uf.find(v):
            uf.union(u, v)
            mst_edges.append((u, v))
            mst_weight += weight
    
    return mst_edges, mst_weight

# 示例图的邻接矩阵
A = [
    [0, 10, 6, 5],
    [10, 0, 0, 15],
    [6, 0, 0, 4],
    [5, 15, 4, 0]
]

# 计算最小生成树
mst_edges, mst_weight = kruskal(A)

# 显示结果
print('最小生成树的边:', mst_edges)
print('最小生成树的权重:', mst_weight)
</code></pre> 
<p><img alt="504987f69a6f4313aeade3bd478a3e71.png" src="https://images2.imgbox.com/14/99/4epTznH5_o.png"></p> 
<h3 id="%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%86%E8%8A%82%E7%9F%A5%E8%AF%86%E7%82%B9"><strong>注意的细节知识点</strong></h3> 
<blockquote> 
 <ol><li> <p><strong>初始化</strong></p> 
   <ul><li>确保并查集正确初始化，每个顶点的父节点为自身。</li></ul></li><li> <p><strong>边的收集与排序</strong></p> 
   <ul><li>收集所有边的信息，并按权值从小到大排序，以便于后续选择最小权值边。</li></ul></li><li> <p><strong>并查集查找函数</strong></p> 
   <ul><li>使用递归查找顶点的根节点，并进行路径压缩，提高查找效率。</li></ul></li><li> <p><strong>边的选择与合并</strong></p> 
   <ul><li>在选择边时，确保不会形成圈，使用并查集的查找和合并操作。</li><li>更新最小生成树的边和权重，确保最小生成树的正确性。</li></ul></li></ol> 
</blockquote> 
<h2 id="%E5%9B%9B%E3%80%81%E9%92%A2%E7%AE%A1%E8%AE%A2%E8%B4%AD%E5%92%8C%E8%BF%90%E8%BE%93%E9%97%AE%E9%A2%98">四、钢管订购和运输问题</h2> 
<h3 id="1.%20%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><strong>1. 问题描述</strong></h3> 
<ul><li>需要从多个钢厂订购钢管，并将其运输到施工地点，铺设天然气主管道。</li><li>图中表示钢厂、枢纽点和施工地点，边的权值表示运输距离。</li></ul> 
<h3 id="2.%20%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><strong>2. 问题分析</strong></h3> 
<ul><li>分解为两个子问题：从钢厂到枢纽点的运输和从枢纽点到施工地点的铺设。</li><li> <h3 id="%E9%9C%80%E8%A6%81%E7%BB%BC%E5%90%88%E8%80%83%E8%99%91%E8%AE%A2%E8%B4%AD%E8%B4%B9%E7%94%A8%E3%80%81%E8%BF%90%E8%BE%93%E8%B4%B9%E7%94%A8%E5%92%8C%E9%93%BA%E8%AE%BE%E8%B4%B9%E7%94%A8%E3%80%82">需要综合考虑订购费用、运输费用和铺设费用。</h3> </li></ul> 
<h3 id="3.%20%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%B1%82%E8%A7%A3"><strong>3. 模型的建立与求解</strong></h3> 
<ul><li><strong>运费矩阵的计算模型</strong>：计算从供应点到需求点的最小购运费。</li><li><strong>总费用的数学规划模型</strong>：包括订购费用、运输费用和铺设管道的运费。</li><li><strong>模型求解</strong>：利用Floyd算法计算最短路径，运用数学规划模型优化总费用。</li></ul> 
<h4><strong>MATLAB代码实例</strong></h4> 
<pre><code>% MATLAB代码
% 构造铁路距离赋权图
function dist = floyd_warshall(A)
    n = size(A, 1);
    dist = A;
    dist(dist == 0) = inf;
    dist(1:n+1:end) = 0;
    for k = 1:n
        for i = 1:n
            for j = 1:n
                if dist(i, k) + dist(k, j) &lt; dist(i, j)
                    dist(i, j) = dist(i, k) + dist(k, j);
                end
            end
        end
    end
end

% 示例图的邻接矩阵
A = [0 10 inf inf inf;
     10 0 5 inf inf;
     inf 5 0 3 inf;
     inf inf 3 0 1;
     inf inf inf 1 0];

% 计算最短路径
dist = floyd_warshall(A);

% 计算总费用的数学规划模型
function total_cost = steel_pipeline_optimization(supplies, demands, cost_matrix)
    n_suppliers = length(supplies);
    n_demands = length(demands);
    total_cost = 0;
    for i = 1:n_suppliers
        for j = 1:n_demands
            total_cost = total_cost + supplies(i) * cost_matrix(i, j);
        end
    end
end

% 示例数据
supplies = [100, 200, 150];
demands = [50, 100, 200, 100];
cost_matrix = [2, 4, 5, 6;
               3, 2, 7, 4;
               6, 5, 2, 3];

% 计算总费用
total_cost = steel_pipeline_optimization(supplies, demands, cost_matrix);

% 显示结果
disp('总费用:');
disp(total_cost);

% 可视化结果
figure;
imagesc(dist);
colorbar;
title('Floyd-Warshall最短路径距离矩阵');
xlabel('目标节点');
ylabel('起始节点');
</code></pre> 
<p><img alt="bacb3a6cacbd4d3ba02f64ccf9822954.png" src="https://images2.imgbox.com/73/c6/AndZnxUs_o.png"></p> 
<p><img alt="fae66a0870514a4d9ff025d440d63c96.png" src="https://images2.imgbox.com/c2/68/gFm45wdG_o.png"></p> 
<blockquote> 
 <ol><li> <p><strong>Floyd-Warshall算法</strong></p> 
   <ul><li><code>function dist = floyd_warshall(A)</code>：定义Floyd-Warshall算法函数。</li><li><code>n = size(A, 1)</code>：获取图中顶点的数量。</li><li><code>dist = A</code>：初始化距离矩阵。</li><li><code>dist(dist == 0) = inf</code>：将邻接矩阵中的0（无边）替换为无穷大。</li><li><code>dist(1:n+1:end) = 0</code>：对角线上的元素设为0，表示自身到自身的距离为0。</li><li><code>for k = 1:n, for i = 1:n, for j = 1:n</code>：三重循环更新距离矩阵。</li><li><code>if dist(i, k) + dist(k, j) &lt; dist(i, j)</code>：如果通过顶点 <code>k</code> 的路径更短，则更新距离。</li><li><code>dist(i, j) = dist(i, k) + dist(k, j)</code>：更新距离矩阵。</li></ul></li></ol> 
</blockquote> 
<blockquote> 
 <ol><li> <p><strong>总费用的数学规划模型</strong></p> 
   <ul><li><code>function total_cost = steel_pipeline_optimization(supplies, demands, cost_matrix)</code>：定义总费用计算函数。</li><li><code>n_suppliers = length(supplies)</code>：获取供应点数量。</li><li><code>n_demands = length(demands)</code>：获取需求点数量。</li><li><code>total_cost = 0</code>：初始化总费用。</li><li><code>for i = 1:n_suppliers, for j = 1:n_demands</code>：双重循环遍历供应点和需求点。</li><li><code>total_cost = total_cost + supplies(i) * cost_matrix(i, j)</code>：累加各供应点到各需求点的费用。</li></ul></li></ol> 
 <p></p> 
</blockquote> 
<h3><strong>Python代码实例</strong> </h3> 
<pre><code>import numpy as np

def floyd_warshall(A):
    n = len(A)
    dist = np.array(A, dtype=float)
    dist[dist == 0] = np.inf
    np.fill_diagonal(dist, 0)
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i, k] + dist[k, j] &lt; dist[i, j]:
                    dist[i, j] = dist[i, k] + dist[k, j]
    return dist

# 示例图的邻接矩阵
A = [
    [0, 10, float('inf'), float('inf'), float('inf')],
    [10, 0, 5, float('inf'), float('inf')],
    [float('inf'), 5, 0, 3, float('inf')],
    [float('inf'), float('inf'), 3, 0, 1],
    [float('inf'), float('inf'), float('inf'), 1, 0]
]

# 计算最短路径
dist = floyd_warshall(A)

def steel_pipeline_optimization(supplies, demands, cost_matrix):
    total_cost = 0
    for i in range(len(supplies)):
        for j in range(len(demands)):
            total_cost += supplies[i] * cost_matrix[i][j]
    return total_cost

# 示例数据
supplies = [100, 200, 150]
demands = [50, 100, 200, 100]
cost_matrix = [
    [2, 4, 5, 6],
    [3, 2, 7, 4],
    [6, 5, 2, 3]
]

# 计算总费用
total_cost = steel_pipeline_optimization(supplies, demands, cost_matrix)

# 显示结果
print('总费用:', total_cost)
</code></pre> 
<pre><code>总费用: 7300</code></pre> 
<h2 id="%E4%BA%94%E3%80%81MATLAB%E5%B7%A5%E5%85%B7%E7%AE%B1%E7%9A%84%E5%BA%94%E7%94%A8">五、MATLAB工具箱的应用</h2> 
<h3 id="1.%20MATLAB%E5%9C%A8%E5%9B%BE%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><strong>1. MATLAB在图与网络中的应用</strong></h3> 
<ul><li>MATLAB提供了强大的工具箱，用于处理图与网络问题。通过编写脚本和函数，可以实现图的生成、算法的实现及结果的可视化。</li></ul> 
<h4><strong>MATLAB代码实例</strong></h4> 
<pre><code>% 创建图对象并可视化
G = graph([1 2 2 3 3 4 4 5 5], [2 3 4 4 5 5 1 1 2], [10 20 30 40 50 60 70 80 90]);

% 可视化图
figure;
plot(G, 'EdgeLabel', G.Edges.Weight);
title('图的可视化');

% 计算最短路径
[start_node, end_node] = deal(1, 5);
[dist, path] = shortestpath(G, start_node, end_node);

% 显示最短路径
disp('最短路径:');
disp(path);

% 计算最小生成树
T = minspantree(G);
figure;
plot(T, 'EdgeLabel', T.Edges.Weight);
title('最小生成树');
</code></pre> 
<pre><code>最短路径:
    80</code></pre> 
<p> <img alt="ae2214368e8c44d9ba371256a9eff82b.png" src="https://images2.imgbox.com/b0/7f/aphPU3l4_o.png"><img alt="9f667cd4f54741949ceea20e9cb57ac5.png" src="https://images2.imgbox.com/75/ed/zKvepliA_o.png"></p> 
<h2 id="%E7%BB%93%E8%AE%BA">结论</h2> 
<h2 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="805821031aea45bb86543b2008892e27.png" src="https://images2.imgbox.com/6d/a8/STA6NixN_o.png"></h2> 
<p>图与网络模型是解决复杂系统问题的重要工具，通过合理的算法和数学模型，可以有效地解决最短路径、最小生成树等问题。利用MATLAB和Python等工具，可以大大简化计算过程，提高工作效率。在实际应用中，图与网络模型广泛用于通信网络建设、物流运输规划等领域，具有重要的现实意义。希望这篇详细的博客总结能够帮助您理解和应用图与网络模型的基本概念、算法及其在实际问题中的应用。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3b8c5fe61a9010331a197575aaf3670e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python 机器学习求解 PDE 学习项目 基础知识（2）TensorFlow 优化器使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/47a5810df02298da46f013734a6b3823/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">RabbitMQ：如何保证消息的可靠性？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>