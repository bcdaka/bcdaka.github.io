<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;基础入门 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/28ccde1fd5b9e75488c52dc6ea951aeb/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C&#43;&#43;基础入门">
  <meta property="og:description" content="​​​​​​​ 🌟个人主页：落叶​​​​​​​
目录
C&#43;&#43;的第⼀个程序
命名空间
namespace的价值
namespace的定义
命名空间的使用
using将命名空间中某个成员展开
C&#43;&#43;输⼊&amp;输出
std::cout标准输出流
std::endl换行
std::cin的标准输⼊流
缺省参数
全缺省
半缺省
函数重载
参数类型不同
参数个数不同
参数的顺序不同
返回函数不同不是函数重载
引⽤
引⽤的概念和定义
引⽤的特性
引⽤的使⽤
const引⽤
指针和引⽤的关系
inline展开
nullptr
C&#43;&#43;的第⼀个程序 C&#43;&#43;兼容C语⾔绝⼤多数的语法，所以C语⾔实现的helloworld依旧可以运⾏，C&#43;&#43;中需要把定义⽂件 代码后缀改为.cpp，vs编译器看到是.cpp就会调⽤C&#43;&#43;编译器编译，linux下要⽤g&#43;&#43;编译，不再是gcc
// test.cpp #include&lt;stdio.h&gt; int main() { printf(&#34;hello world\n&#34;); return 0; } 当然C&#43;&#43;有⼀套⾃⼰的输⼊输出，严格说C&#43;&#43;版本的helloworld应该是这样写的。
// test.cpp // 这⾥的std cout等我们都看不懂，没关系，下⾯我们会依次讲解 #include&lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; &#34;hello world\n&#34; &lt;&lt; endl; return 0; } 命名空间 namespace的价值 在C/C&#43;&#43;中，变量、函数和后⾯要学到的类都是⼤量存在的，这些变量、函数和类的名称将都存在于全 局作⽤域中，可能会导致很多冲突。使⽤命名空间的⽬的是对标识符的名称进⾏本地化，以避免命名 冲突或名字污染，namespace关键字的出现就是针对这种问题的。 c语⾔项⽬类似下⾯程序这样的命名冲突是普遍存在的问题，C&#43;&#43;引⼊namespace就是为了更好的解决 这样的问题。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-09-01T00:35:24+08:00">
    <meta property="article:modified_time" content="2024-09-01T00:35:24+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;基础入门</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><img alt="" height="438" src="https://images2.imgbox.com/d2/37/zYevU9zn_o.gif" width="778">​​​​​​​</h2> 
<hr> 
<blockquote> 
 <p> 🌟<strong>个人主页：<a class="link-info" href="https://blog.csdn.net/qq_67578580?type=blog" title="落叶">落叶</a>​​​​​​​</strong></p> 
</blockquote> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="C%2B%2B%E7%9A%84%E7%AC%AC%E2%BC%80%E4%B8%AA%E7%A8%8B%E5%BA%8F-toc" style="margin-left:0px;"><a href="#C%2B%2B%E7%9A%84%E7%AC%AC%E2%BC%80%E4%B8%AA%E7%A8%8B%E5%BA%8F" rel="nofollow">C++的第⼀个程序</a></p> 
<p id="%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-toc" style="margin-left:0px;"><a href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4" rel="nofollow">命名空间</a></p> 
<p id="namespace%E7%9A%84%E4%BB%B7%E5%80%BC-toc" style="margin-left:40px;"><a href="#namespace%E7%9A%84%E4%BB%B7%E5%80%BC" rel="nofollow">namespace的价值</a></p> 
<p id="namespace%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#namespace%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">namespace的定义</a></p> 
<p id="%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">命名空间的使用</a></p> 
<p id="using%E5%B0%86%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%AD%E6%9F%90%E4%B8%AA%E6%88%90%E5%91%98%E5%B1%95%E5%BC%80-toc" style="margin-left:80px;"><a href="#using%E5%B0%86%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%AD%E6%9F%90%E4%B8%AA%E6%88%90%E5%91%98%E5%B1%95%E5%BC%80" rel="nofollow">using将命名空间中某个成员展开</a></p> 
<p id="%C2%A0C%2B%2B%E8%BE%93%E2%BC%8A%26%E8%BE%93%E5%87%BA-toc" style="margin-left:0px;"><a href="#%C2%A0C%2B%2B%E8%BE%93%E2%BC%8A%26%E8%BE%93%E5%87%BA" rel="nofollow"> C++输⼊&amp;输出</a></p> 
<p id="std%3A%3Acout%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81-toc" style="margin-left:40px;"><a href="#std%3A%3Acout%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81" rel="nofollow">std::cout标准输出流</a></p> 
<p id="std%3A%3Aendl%E6%8D%A2%E8%A1%8C-toc" style="margin-left:40px;"><a href="#std%3A%3Aendl%E6%8D%A2%E8%A1%8C" rel="nofollow">std::endl换行</a></p> 
<p id="%C2%A0std%3A%3Acin%E7%9A%84%E6%A0%87%E5%87%86%E8%BE%93%E2%BC%8A%E6%B5%81-toc" style="margin-left:40px;"><a href="#%C2%A0std%3A%3Acin%E7%9A%84%E6%A0%87%E5%87%86%E8%BE%93%E2%BC%8A%E6%B5%81" rel="nofollow"> std::cin的标准输⼊流</a></p> 
<p id="%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0" rel="nofollow">缺省参数</a></p> 
<p id="%C2%A0%E5%85%A8%E7%BC%BA%E7%9C%81-toc" style="margin-left:40px;"><a href="#%C2%A0%E5%85%A8%E7%BC%BA%E7%9C%81" rel="nofollow"> 全缺省</a></p> 
<p id="%E5%8D%8A%E7%BC%BA%E7%9C%81-toc" style="margin-left:40px;"><a href="#%E5%8D%8A%E7%BC%BA%E7%9C%81" rel="nofollow">半缺省</a></p> 
<p id="%C2%A0%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD-toc" style="margin-left:0px;"><a href="#%C2%A0%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD" rel="nofollow"> 函数重载</a></p> 
<p id="%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C-toc" style="margin-left:40px;"><a href="#%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C" rel="nofollow">参数类型不同</a></p> 
<p id="%E5%8F%82%E6%95%B0%E4%B8%AA%E6%95%B0%E4%B8%8D%E5%90%8C-toc" style="margin-left:40px;"><a href="#%E5%8F%82%E6%95%B0%E4%B8%AA%E6%95%B0%E4%B8%8D%E5%90%8C" rel="nofollow">参数个数不同</a></p> 
<p id="%E5%8F%82%E6%95%B0%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%B8%8D%E5%90%8C-toc" style="margin-left:40px;"><a href="#%E5%8F%82%E6%95%B0%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%B8%8D%E5%90%8C" rel="nofollow">参数的顺序不同</a></p> 
<p id="%E8%BF%94%E5%9B%9E%E5%87%BD%E6%95%B0%E4%B8%8D%E5%90%8C%E4%B8%8D%E6%98%AF%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD-toc" style="margin-left:40px;"><a href="#%E8%BF%94%E5%9B%9E%E5%87%BD%E6%95%B0%E4%B8%8D%E5%90%8C%E4%B8%8D%E6%98%AF%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD" rel="nofollow">返回函数不同不是函数重载</a></p> 
<p id="%E5%BC%95%E2%BD%A4-toc" style="margin-left:0px;"><a href="#%E5%BC%95%E2%BD%A4" rel="nofollow">引⽤</a></p> 
<p id="%E5%BC%95%E2%BD%A4%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#%E5%BC%95%E2%BD%A4%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%9A%E4%B9%89" rel="nofollow">引⽤的概念和定义</a></p> 
<p id="%E5%BC%95%E2%BD%A4%E7%9A%84%E7%89%B9%E6%80%A7-toc" style="margin-left:40px;"><a href="#%E5%BC%95%E2%BD%A4%E7%9A%84%E7%89%B9%E6%80%A7" rel="nofollow">引⽤的特性</a></p> 
<p id="%C2%A0%E5%BC%95%E2%BD%A4%E7%9A%84%E4%BD%BF%E2%BD%A4-toc" style="margin-left:40px;"><a href="#%C2%A0%E5%BC%95%E2%BD%A4%E7%9A%84%E4%BD%BF%E2%BD%A4" rel="nofollow"> 引⽤的使⽤</a></p> 
<p id="const%E5%BC%95%E2%BD%A4-toc" style="margin-left:40px;"><a href="#const%E5%BC%95%E2%BD%A4" rel="nofollow">const引⽤</a></p> 
<p id="%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E2%BD%A4%E7%9A%84%E5%85%B3%E7%B3%BB-toc" style="margin-left:40px;"><a href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E2%BD%A4%E7%9A%84%E5%85%B3%E7%B3%BB" rel="nofollow">指针和引⽤的关系</a></p> 
<p id="inline%E5%B1%95%E5%BC%80-toc" style="margin-left:0px;"><a href="#inline%E5%B1%95%E5%BC%80" rel="nofollow">inline展开</a></p> 
<p id="nullptr-toc" style="margin-left:0px;"><a href="#nullptr" rel="nofollow">nullptr</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="C%2B%2B%E7%9A%84%E7%AC%AC%E2%BC%80%E4%B8%AA%E7%A8%8B%E5%BA%8F" style="background-color:transparent;">C++的第⼀个程序</h2> 
<p>C++兼容C语⾔绝⼤多数的语法，所以C语⾔实现的helloworld依旧可以运⾏，C++中需要把定义⽂件 代码后缀改为.cpp，vs编译器看到是.cpp就会调⽤C++编译器编译，linux下要⽤g++编译，不再是gcc</p> 
<pre><code class="language-cpp">// test.cpp
#include&lt;stdio.h&gt;
int main()
{
 printf("hello world\n");
 
 return 0;
}</code></pre> 
<p>当然C++有⼀套⾃⼰的输⼊输出，严格说C++版本的helloworld应该是这样写的。</p> 
<pre><code class="language-cpp">// test.cpp
// 这⾥的std cout等我们都看不懂，没关系，下⾯我们会依次讲解 
#include&lt;iostream&gt;
using namespace std;

int main()
{
 cout &lt;&lt; "hello world\n" &lt;&lt; endl;
 
 return 0;
}</code></pre> 
<h2 id="%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">命名空间</h2> 
<h3 id="namespace%E7%9A%84%E4%BB%B7%E5%80%BC">namespace的价值</h3> 
<p><strong>在C/C++中，变量、函数和后⾯要学到的类都是⼤量存在的，这些变量、函数和类的名称将都存在于全 局作⽤域中，可能会导致很多冲突。使⽤命名空间的⽬的是对标识符的名称进⾏本地化，以避免命名 冲突或名字污染，namespace关键字的出现就是针对这种问题的。 c语⾔项⽬类似下⾯程序这样的命名冲突是普遍存在的问题，C++引⼊namespace就是为了更好的解决 这样的问题。</strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt; 


#include &lt;stdlib.h&gt;
int rand = 10;

int main()
{
	// 编译报错：error C2365: “rand”: 重定义；以前的定义是“函数” 
	printf("%d\n", rand);
	return 0;
}</code></pre> 
<hr> 
<h3 id="namespace%E7%9A%84%E5%AE%9A%E4%B9%89">namespace的定义</h3> 
<blockquote> 
 <ul><li><strong>定义命名空间，需要使⽤到namespace关键字，后⾯跟命名空间的名字，然后接⼀对{}即可，{}中 即为命名空间的成员。命名空间中可以定义变量/函数/类型等。</strong></li><li><strong>namespace本质是定义出⼀个域，这个域跟全局域各⾃独⽴，不同的域可以定义同名变量，所以下 ⾯的rand不在冲突了。</strong></li><li><strong>C++中域有函数局部域，全局域，命名空间域，类域；域影响的是编译时语法查找⼀个变量/函数/ 类型出处(声明或定义)的逻辑，所有有了域隔离，名字冲突就解决了。局部域和全局域除了会影响 编译查找逻辑，还会影响变量的⽣命周期，命名空间域和类域不影响变量⽣命周期。</strong></li><li><strong>namespace只能定义在全局，当然他还可以嵌套定义。</strong></li><li><strong>项⽬⼯程中多⽂件中定义的同名namespace会认为是⼀个namespace，不会冲突。</strong></li><li><strong>C++标准库都放在⼀个叫std(standard)的命名空间中。</strong></li></ul> 
</blockquote> 
<p></p> 
<p><strong>下面这代码，命名空间为bit，在使用bit命名空间的时候，前面要加bit::</strong></p> 
<p><span style="color:#fe2c24;"><strong>局部域出了生命周期就销毁了。<br> 命名空间域就是为了跟全局域进行隔离的，不能把命名空间域定义在局部。</strong></span></p> 
<pre><code class="language-cpp">int x = 0;//全局域

namespace bit
{
	int x = 1;//命名空间域
}

void func()
{
	//这个局部域只能在当前局部域内访问
	int x = 2;//局部域
}

int main()
{
	int x = 3;//局部域

	printf("%d\n", x);//这个会在局部搜索，再到全局搜索
	printf("%d\n", bit::x);//访问命名空间域
	printf("%d\n", ::x);//访问全局

	return 0;
}</code></pre> 
<hr> 
<p><strong>命名空间可以嵌套</strong></p> 
<pre><code class="language-cpp">//命名空间可以嵌套
namespace bit
{
	//在bit命名空间嵌套a和b的命名空间
	namespace a
	{
		int tab = 99;
		int add(int x, int y)
		{
			return x + y;
		}
	}

	namespace b
	{
		int tab = 10;
		int att(int x, int y)
		{
			return x * y;
		}
	}
}

int main()
{
	printf("%d \n",bit::a::tab);
	printf("%d \n",bit::b::tab);

	printf("%d \n", bit::a::add(13, 23));
	printf("%d \n", bit::b::att(5, 5));
}</code></pre> 
<hr> 
<p><strong>多⽂件中可以定义同名namespace，他们会默认合并到⼀起，就像同⼀个namespace⼀样</strong></p> 
<hr> 
<h3 id="%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E4%BD%BF%E7%94%A8">命名空间的使用</h3> 
<p><strong>编译查找⼀个变量的声明/定义时，默认只会在局部或者全局查找，不会到命名空间⾥⾯去查找。所以下⾯程序会编译报错。所以我们要使⽤命名空间中定义的变量/函数，有三种⽅式：</strong></p> 
<blockquote> 
 <ul><li><span style="color:#fe2c24;"><strong>指定命名空间访问，项⽬中推荐这种⽅式。</strong></span></li><li><span style="color:#fe2c24;"><strong>using将命名空间中某个成员展开，项⽬中经常访问的不存在冲突的成员推荐这种⽅式。</strong></span></li><li><span style="color:#fe2c24;"><strong>展开命名空间中全部成员，项⽬不推荐，冲突⻛险很⼤，⽇常⼩练习程序为了⽅便推荐使⽤。</strong></span></li></ul> 
</blockquote> 
<hr> 
<p><strong>下面这个代码我们可以看到“a”未声明的标识符，因为a不能访问到fang里的a。</strong></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;

namespace fang
{
	int a = 10;
	int b = 20;
}

int main()
{
	 编译报错：error C2065: “a”: 未声明的标识符
	printf("%d \n", a);
	return 0;
}</code></pre> 
<pre><code class="language-cpp">// 指定命名空间访问
int main()
{
printf("%d\n", fang::a);
return 0;
}</code></pre> 
<h4 id="using%E5%B0%86%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%AD%E6%9F%90%E4%B8%AA%E6%88%90%E5%91%98%E5%B1%95%E5%BC%80">using将命名空间中某个成员展开</h4> 
<p><span style="color:#fe2c24;"><strong>using可以把命名空间的成员暴露到全局，。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>注意的是全局变量的名字不能和命名空间的成员名字一样。</strong></span></p> 
<pre><code class="language-cpp">// using将命名空间中某个成员展开

using namespace fang;//默认到局部找，再到全局找

int main()
{
	printf("%d\n", a);//fang暴露到全局后，就不用加fang::了
	printf("%d\n", b);
	return 0;
}</code></pre> 
<hr> 
<p><span style="color:#fe2c24;"><strong>展开命名空间中全部成员，项⽬不推荐，冲突⻛险很⼤，⽇常⼩练习程序为了⽅便推荐使⽤。</strong></span></p> 
<p><strong>下面这代码，using单独暴露a在全局变量，</strong></p> 
<p><strong>打印b可以访问fang里的b成员，也可以访问全局变量的b，单独暴露可以避免全部暴露带来的名字冲突。</strong></p> 
<pre><code class="language-cpp">// using将命名空间中某个成员展开

namespace fang
{
	int a = 10;
	int b = 20;
}

using fang::a;//把a单独暴露到全局

int b = 99;

int main()
{
	printf("%d\n",a);
	printf("%d\n",a);
	printf("%d\n",a);
	printf("%d\n",a);
	printf("%d\n",a);
	fang::b++;
	printf("%d\n",fang::b);

	printf("%d\n", b);//全局的b
	return 0;
}</code></pre> 
<p>结果：</p> 
<p><img alt="" height="185" src="https://images2.imgbox.com/fd/1e/3gLwzgOo_o.png" width="149"></p> 
<hr> 
<h2 id="%C2%A0C%2B%2B%E8%BE%93%E2%BC%8A%26%E8%BE%93%E5%87%BA"> C++输⼊&amp;输出</h2> 
<blockquote> 
 <ul><li><span style="color:#0d0016;"><strong>&lt;iostream&gt; 是 Input Output Stream 的缩写，是标准的输⼊、输出流库，定义了标准的输⼊、输出对象。</strong></span></li><li><span style="color:#fe2c24;"><strong>std::cin</strong></span><span style="color:#0d0016;"><strong> 是 istream 类的对象，它主要⾯向窄字符（narrow characters (of type char)）的标准输<br> ⼊流。</strong></span></li><li><span style="color:#fe2c24;"><strong>std::cout </strong></span><span style="color:#0d0016;"><strong>是 ostream 类的对象，它主要⾯向窄字符的标准输出流。</strong></span></li><li><span style="color:#fe2c24;"><strong>std::endl</strong></span><span style="color:#0d0016;"><strong> 是⼀个函数，流插⼊输出时，相当于插⼊⼀个换⾏字符加刷新缓冲区。</strong></span></li><li><span style="color:#0d0016;"><strong>&lt;&lt;是流插⼊运算符，&gt;&gt;是流提取运算符。（C语⾔还⽤这两个运算符做位运算左移/右移）</strong></span></li><li><span style="color:#0d0016;"><strong>使⽤C++输⼊输出更⽅便，不需要像printf/scanf输⼊输出时那样，需要⼿动指定格式，C++的输⼊输出可以⾃动识别变量类型(本质是通过函数重载实现的，这个以后会讲到)，其实最重要的是C++的流能更好的⽀持⾃定义类型对象的输⼊输出。</strong></span></li><li><span style="color:#0d0016;"><strong>IO流涉及类和对象，运算符重载、继承等很多⾯向对象的知识，这些知识我们还没有讲解，所以这⾥我们只能简单认识⼀下C++ IO流的⽤法，后⾯我们会有专⻔的⼀个章节来细节IO流库。</strong></span></li><li><span style="color:#0d0016;"><strong>cout/cin/endl等都属于C++标准库，C++标准库放在⼀个叫std(standard)的命名空间中，所以要通过命名空间的使⽤⽅式去⽤他们。</strong></span></li><li><span style="color:#0d0016;"><strong>⼀般⽇常练习中我们可以using namespace std，实际项⽬开发中不建议using namespace std。</strong></span></li><li><span style="color:#0d0016;"><strong>这⾥我们没有包含&lt;stdio.h&gt;，也可以使⽤printf和scanf，在包含&lt;iostream&gt;间接包含了。vs系列编译器是这样的，其他编译器可能会报错。</strong></span></li></ul> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>std::cout</strong></span><span style="color:#0d0016;"><strong>标准输出流，它是把数值</strong></span><span style="color:#fe2c24;"><strong>转换</strong></span><span style="color:#0d0016;"><strong>成字符输出到屏幕（终端）上的，如果本身就是字符就不用</strong></span><span style="color:#fe2c24;"><strong>转换</strong></span><span style="color:#0d0016;"><strong>。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>std::cin</strong></span><span style="color:#0d0016;"><strong>的标准输⼊流，它就是把在屏幕（终端）上输入的字符</strong></span><span style="color:#fe2c24;"><strong>转换</strong></span><span style="color:#0d0016;"><strong>成对应的</strong></span><span style="color:#fe2c24;"><strong>整行</strong></span><span style="color:#0d0016;"><strong>或</strong></span><span style="color:#fe2c24;"><strong>浮点型</strong></span><span style="color:#0d0016;"><strong>，给给变量。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>std::endl</strong></span><span style="color:#0d0016;"><strong>是⼀个函数，流插⼊输出时，相当于插⼊⼀个换⾏字符加刷新缓冲区。</strong></span></p> 
<hr> 
<h3 id="std%3A%3Acout%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81"><span style="color:#0d0016;"><strong>std::cout标准输出流</strong></span></h3> 
<p>c++的标准输出流（可以自动识别类型）然后输出，不像c语言一样，需要指定类型输出。</p> 
<pre><code class="language-cpp">int main()
{
	// &lt;&lt; 流插入
	std::cout &lt;&lt; "您好";
	int a = 10;
	std::cout &lt;&lt; a;

	double b = 5.99;
	std::cout &lt;&lt; b;
}</code></pre> 
<p>结果：</p> 
<p><img alt="" height="238" src="https://images2.imgbox.com/7a/fa/3rtNyukl_o.png" width="425"></p> 
<p>但是要怎么换行呢，我们可以直接用<span style="color:#fe2c24;"><strong>std::endl这是一个函数。</strong></span></p> 
<hr> 
<h3 id="std%3A%3Aendl%E6%8D%A2%E8%A1%8C"><span style="color:#0d0016;"><strong>std::endl换行</strong></span></h3> 
<p><span style="color:#fe2c24;"><strong>相当于插⼊⼀个换⾏字符加刷新缓冲区</strong></span></p> 
<pre><code class="language-cpp">int main()
{
	// &lt;&lt; 流插入
	std::cout &lt;&lt; "您好" &lt;&lt; std::endl;
	int a = 10;
	std::cout &lt;&lt; a &lt;&lt; std::endl &lt;&lt; std::endl;

	double b = 5.99;
	std::cout &lt;&lt; b &lt;&lt; std::endl;
}

</code></pre> 
<p><img alt="" height="236" src="https://images2.imgbox.com/6c/ef/WICtcCMe_o.png" width="614"></p> 
<hr> 
<h3 id="%C2%A0std%3A%3Acin%E7%9A%84%E6%A0%87%E5%87%86%E8%BE%93%E2%BC%8A%E6%B5%81"><span style="color:#0d0016;"><strong> std::cin的标准输⼊流</strong></span></h3> 
<p><span style="color:#fe2c24;"><strong>std::cin</strong></span><span style="color:#0d0016;"><strong>的标准输⼊流，它就是把在屏幕（终端）上输入的字符</strong></span><span style="color:#fe2c24;"><strong>转换</strong></span><span style="color:#0d0016;"><strong>成对应的</strong></span><span style="color:#fe2c24;"><strong>整行</strong></span><span style="color:#0d0016;"><strong>或</strong></span><span style="color:#fe2c24;"><strong>浮点型</strong></span><span style="color:#0d0016;"><strong>，给给变量。</strong></span></p> 
<pre><code class="language-cpp">int main()
{
	int a = 0;
	double b = 10;
	//输入流
	std::cin &gt;&gt; a &gt;&gt; b;
	//输出流
	std::cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; std::endl;

}</code></pre> 
<p><strong>输入了5和9.9，输出了5和9.9。</strong></p> 
<p><img alt="" height="255" src="https://images2.imgbox.com/b7/ad/8ISJhV8j_o.png" width="611"></p> 
<hr> 
<p><strong>可以把cout和cin暴露出来，这样就不用在前面加std::了</strong></p> 
<p><img alt="" height="311" src="https://images2.imgbox.com/54/90/pA8EY0MJ_o.png" width="543"></p> 
<hr> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int main()
{
	// 在io需求⽐较⾼的地⽅，如部分⼤量输⼊的竞赛题中，加上以下3⾏代码
	// 可以提⾼C++IO效率
	ios_base::sync_with_stdio(false);//这一句是让c++不在兼容c语言，关掉
	cin.tie(nullptr);//不在跟其他流绑定，自己做自己的
	cout.tie(nullptr);//不在跟其他流绑定，自己做自己的
	return 0;
}</code></pre> 
<hr> 
<h2 id="%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0">缺省参数</h2> 
<blockquote> 
 <ul><li><span style="color:#fe2c24;"><strong>缺省参数是声明或定义函数时为函数的参数指定⼀个缺省值。在调⽤该函数时，如果没有指定实参则采⽤该形参的缺省值，否则使⽤指定的实参，缺省参数分为全缺省和半缺省参数。（有些地⽅把缺省参数也叫默认参数）</strong></span></li><li><span style="color:#fe2c24;"><strong>全缺省就是全部形参给缺省值，半缺省就是部分形参给缺省值。C++规定半缺省参数必须从右往左依次连续缺省，不能间隔跳跃给缺省值。</strong></span></li><li><span style="color:#fe2c24;"><strong>带缺省参数的函数调⽤，C++规定必须从左到右依次给实参，不能跳跃给实参。</strong></span></li><li><span style="color:#fe2c24;"><strong>函数声明和定义分离时，缺省参数不能在函数声明和定义中同时出现，规定必须函数声明给缺省值。</strong></span></li></ul> 
</blockquote> 
<hr> 
<p>缺省参数就是在行参里给一个赋值，就是缺省参数，</p> 
<p><span style="color:#fe2c24;"><strong>不传参时，使用的就是缺省参数，传参时，使⽤指定的实参。</strong></span></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;assert.h&gt;
using namespace std;

void fang(int a = 0)//缺省参数
{
	cout &lt;&lt; a &lt;&lt; endl;
}
int main()
{
	fang();// 没有传参时，使⽤参数的默认值
	fang(10); // 传参时，使⽤指定的实参
	return 0;
}</code></pre> 
<hr> 
<h3 id="%C2%A0%E5%85%A8%E7%BC%BA%E7%9C%81"> 全缺省</h3> 
<p><span style="color:#0d0016;">全缺省就是全部都是缺省参数</span>，<span style="color:#0d0016;">不传参时，使用的就是缺省参数，传参时，使⽤指定的实参，</span></p> 
<p><span style="color:#0d0016;">传1的时候，a就是1了，传1和2的时候，a就是1，b就是2，传1,2,3的话，a是1，b是2，c是3。</span></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
// 全缺省
void Func1(int a = 10, int b = 20, int c = 30)
{
	cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; endl;
	cout &lt;&lt; "c = " &lt;&lt; c &lt;&lt; endl &lt;&lt; endl;
}
int main()
{
	Func1();
	Func1(1);
	Func1(1, 2);
	Func1(1, 2, 3);
	return 0;
}</code></pre> 
<p><img alt="" height="396" src="https://images2.imgbox.com/aa/e9/lsRwxu7F_o.png" width="584"></p> 
<hr> 
<h3 id="%E5%8D%8A%E7%BC%BA%E7%9C%81" style="background-color:transparent;">半缺省</h3> 
<p>半缺省我们可以看到行参a没有被赋值，b和c都被赋值了，这就是半缺省。</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

// 半缺省
void Func2(int a, int b = 10, int c = 20)
{
	cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; endl;
	cout &lt;&lt; "c = " &lt;&lt; c &lt;&lt; endl &lt;&lt; endl;
}
int main()
{
	Func2(100);
	Func2(100, 200);
	Func2(100, 200, 300);
	return 0;
}
</code></pre> 
<p><img alt="" height="381" src="https://images2.imgbox.com/36/fe/0l7TVqYp_o.png" width="549"></p> 
<hr> 
<p><span style="color:#fe2c24;"><strong>缺省参数不能声明和定义同时给，能在声明给。</strong></span></p> 
<pre><code class="language-cpp">// Stack.h
#include &lt;iostream&gt;
#include &lt;assert.h&gt;
using namespace std;
typedef int STDataType;
typedef struct Stack
{
	STDataType* a;
	int top;
	int capacity;
}ST;
void STInit(ST* ps, int n = 4);</code></pre> 
<pre><code class="language-cpp">// Stack.cpp
#include"Stack.h"
// 缺省参数不能声明和定义同时给
void STInit(ST* ps, int n)
{
	assert(ps &amp;&amp; n &gt; 0);
	ps-&gt;a = (STDataType*)malloc(n * sizeof(STDataType));
	ps-&gt;top = 0;
	ps-&gt;capacity = n;
}</code></pre> 
<pre><code class="language-cpp">// test.cpp
#include"Stack.h"
int main()
{
	ST s1;
	STInit(&amp;s1);
	// 确定知道要插⼊1000个数据，初始化时⼀把开好，避免扩容
	ST s2;
	STInit(&amp;s2, 1000);
	return 0;
}</code></pre> 
<hr> 
<h2 id="%C2%A0%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><strong> 函数重载</strong></h2> 
<p><strong>C++⽀持在同⼀作⽤域中出现同名函数，但是要求这些同名函数的形参不同，可以是参数个数不同或者类型不同。这样C++函数调⽤就表现出了多态⾏为，使⽤更灵活。C语⾔是不⽀持同⼀作⽤域中出现同名函数的。</strong></p> 
<p><strong>函数重载就像是同一个函数，不同的行为。</strong></p> 
<hr> 
<h3 id="%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C">参数类型不同</h3> 
<p><span style="color:#fe2c24;">类型不同，也可以找到对应的函数。</span></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

// 1、参数类型不同
int Add(int left, int right)
{
	cout &lt;&lt; "int Add(int left, int right)" &lt;&lt; endl;
	return left + right;
}

double Add(double left, double right)
{
	cout &lt;&lt; "double Add(double left, double right)" &lt;&lt; endl;
	return left + right;
}

int main()
{
	Add(10, 20);
	Add(10.1, 20.2);
	return 0;
}</code></pre> 
<p><img alt="" height="363" src="https://images2.imgbox.com/f2/21/e0zWEJQ5_o.png" width="943"></p> 
<hr> 
<h3 id="%E5%8F%82%E6%95%B0%E4%B8%AA%E6%95%B0%E4%B8%8D%E5%90%8C">参数个数不同</h3> 
<p><span style="color:#fe2c24;">参数的个数不同，也可以找到对应的函数。</span></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

// 2、参数个数不同
void f()
{
	cout &lt;&lt; "f()" &lt;&lt; endl;
}
void f(int a)
{
	cout &lt;&lt; "f(int a)" &lt;&lt; endl;
}

int main()
{

	f();
	f(10);

	return 0;
}</code></pre> 
<p><img alt="" height="424" src="https://images2.imgbox.com/09/e9/nXRg1PEd_o.png" width="575"></p> 
<hr> 
<h3 id="%E5%8F%82%E6%95%B0%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%B8%8D%E5%90%8C">参数的顺序不同</h3> 
<p><span style="color:#fe2c24;">参数的顺序不同，也可以找到对应的函数。</span></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

// 3、参数类型顺序不同
void f(int a, char b)
{
	cout &lt;&lt; "f(int a,char b)" &lt;&lt; endl;
}
void f(char b, int a)
{
	cout &lt;&lt; "f(char b, int a)" &lt;&lt; endl;
}

int main()
{
	f(10, 'a');
	f('a', 10);
	return 0;
}
</code></pre> 
<p><img alt="" height="369" src="https://images2.imgbox.com/90/cc/iP57dUkN_o.png" width="683"></p> 
<hr> 
<h3 id="%E8%BF%94%E5%9B%9E%E5%87%BD%E6%95%B0%E4%B8%8D%E5%90%8C%E4%B8%8D%E6%98%AF%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">返回函数不同不是<strong>函数重载</strong></h3> 
<p>返回函数不同不是<span style="color:#fe2c24;">函数重载</span>，因为调⽤时也⽆法区分</p> 
<pre><code class="language-cpp">// 返回值不同不能作为重载条件，因为调⽤时也⽆法区分
void fxx()
{
}

int fxx()
{
 return 0;
}</code></pre> 
<hr> 
<p><span style="color:#fe2c24;"><strong>下⾯两个函数构成重载，个数不同<br> 但是f()调⽤时，会报错，存在歧义，编译器不知道调⽤谁。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>是</strong></span><span style="color:#fe2c24;"><strong>构成重载，但是不能调用。</strong></span></p> 
<pre><code class="language-cpp">// 下⾯两个函数构成重载
// f()但是调⽤时，会报错，存在歧义，编译器不知道调⽤谁
void f1()
{
	cout &lt;&lt; "f()" &lt;&lt; endl;
}
void f1(int a = 10)
{
	cout &lt;&lt; "f(int a)" &lt;&lt; endl;
}
</code></pre> 
<hr> 
<h2 id="%E5%BC%95%E2%BD%A4">引⽤</h2> 
<h3 id="%E5%BC%95%E2%BD%A4%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%9A%E4%B9%89">引⽤的概念和定义</h3> 
<p><strong>引⽤不是新定义⼀个变量，⽽是给已存在变量取了⼀个别名，编译器不会为引⽤变量开辟内存空间，它和它引⽤的变量共⽤同⼀块内存空间。⽐如：⽔虎传中李逵，宋江叫"铁⽜"，江湖上⼈称"⿊旋⻛"；林冲，外号豹⼦头；</strong></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>类型 &amp; 引⽤别名 = 引⽤对象;</strong></span></p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>C++中为了避免引⼊太多的运算符，会复⽤C语⾔的⼀些符号，⽐如前⾯的&lt;&lt;?和?&gt;&gt;，这⾥引⽤也和取地址使⽤了同⼀个符号&amp;，⼤家注意使⽤⽅法⻆度区分就可以。（吐槽⼀下，这个问题其实挺坑的，个⼈觉得⽤更多符号反⽽更好，不容易混淆）</strong></span></p> 
<p><img alt="" height="207" src="https://images2.imgbox.com/92/95/WkvKcqff_o.png" width="330"><img alt="" height="210" src="https://images2.imgbox.com/a1/1c/MB5oKAZM_o.png" width="330"></p> 
<hr> 
<p><span style="color:#fe2c24;"><strong>下面这代码我们可以看到，给a变量取别名为b和c，</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>也可以给别名b取别名，g相当于还是a的别名，g++相当于a++，</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>也就是a这一块空间地址，有很多个名字。，它们都是同一块空间。</strong></span></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main()
{
	int a = 0;
	// 引⽤：b和c是a的别名
	int&amp; b = a;
	int&amp; c = a;
	// 也可以给别名b取别名，g相当于还是a的别名
	int&amp; g = b;
	g++;

	// 这⾥取地址我们看到是⼀样的
	cout &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; b &lt;&lt; endl;
	cout &lt;&lt; c &lt;&lt; endl;
	cout &lt;&lt; g &lt;&lt; endl;

	return 0;
}</code></pre> 
<p><img alt="" height="216" src="https://images2.imgbox.com/ac/94/aqhyvwj2_o.png" width="294"></p> 
<p><img alt="" height="493" src="https://images2.imgbox.com/bb/fd/7cPkXt3L_o.png" width="644"></p> 
<hr> 
<h3 id="%E5%BC%95%E2%BD%A4%E7%9A%84%E7%89%B9%E6%80%A7">引⽤的特性</h3> 
<blockquote> 
 <ul><li>引⽤在定义时必须初始化</li><li>⼀个变量可以有多个引⽤</li><li>引⽤⼀旦引⽤⼀个实体，再不能引⽤其他实体</li></ul> 
</blockquote> 
<p></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int main()
{
	int a = 10;
	// 编译报错：“ra”: 必须初始化引⽤
	//int&amp; ra;
	int&amp; b = a;
	int c = 20;
	// 这⾥并⾮让b引⽤c，因为C++引⽤不能改变指向，
	// 这⾥是⼀个赋值
	b = c;
	cout &lt;&lt; &amp;a &lt;&lt; endl;
	cout &lt;&lt; &amp;b &lt;&lt; endl;
	cout &lt;&lt; &amp;c &lt;&lt; endl;
	return 0;
}</code></pre> 
<hr> 
<p><span style="color:#fe2c24;"><strong>当然指针也是可以取别名的，p1取了a的地址，p1的别名是p2，p2也就是a的地址，</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>p2 = &amp;e 这个，p2本来是指向a的，现在被指向e了，所以打印出了的是99。</strong></span></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>注意：</strong></span><strong>引⽤不能替代指针因为引⽤</strong><strong>不能改变指向，比如单链表这些，需要改变指向的就不能用。</strong></p> 
</blockquote> 
<pre><code class="language-cpp">int main()
{
	int a = 1;
	int* p1 = &amp;a;
	int*&amp; p2 = p1;

	int e = 99;
	p2 = &amp;e;

	cout &lt;&lt; *p2 &lt;&lt; endl;
	return 0;
}</code></pre> 
<hr> 
<p><img alt="" height="211" src="https://images2.imgbox.com/f8/b6/83GGiBu9_o.png" width="332"></p> 
<hr> 
<h3 id="%C2%A0%E5%BC%95%E2%BD%A4%E7%9A%84%E4%BD%BF%E2%BD%A4"> 引⽤的使⽤</h3> 
<blockquote> 
 <ul><li><span style="color:#fe2c24;"><strong>引⽤在实践中主要是于引⽤传参和引⽤做返回值中减少拷⻉提⾼效率和改变引⽤对象时同时改变被引⽤对象。</strong></span></li><li><span style="color:#fe2c24;"><strong>引⽤传参跟指针传参功能是类似的，引⽤传参相对更⽅便⼀些。</strong></span></li><li><span style="color:#fe2c24;"><strong>引⽤返回值的场景相对⽐较复杂，我们在这⾥简单讲了⼀下场景，还有⼀些内容后续类和对象章节中会继续深⼊讲解。</strong></span></li><li><span style="color:#fe2c24;"><strong>引⽤和指针在实践中相辅相成，功能有重叠性，但是各有特点，互相不可替代。C++的引⽤跟其他语⾔的引⽤(如Java)是有很⼤的区别的，除了⽤法，最⼤的点，C++引⽤定义后不能改变指向，Java的引⽤可以改变指向。</strong></span></li><li><span style="color:#fe2c24;"><strong>⼀些主要⽤C代码实现版本数据结构教材中，使⽤C++引⽤替代指针传参，⽬的是简化程序，避开复杂的指针，但是很多人没学过引⽤，导致⼀头雾⽔。</strong></span></li></ul> 
</blockquote> 
<hr> 
<p><strong>我们可以看到<span style="color:#fe2c24;">jh</span>这个函数，传了a和b过去，x取的是a的别名，y取的是b的别名，所以交换还是a和b。</strong></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

//交换
void jh(int&amp; x, int&amp; y)
{
	int tab = x;
	x = y;
	y = tab;
}

int main()
{
	int a = 10;
	int b = 99;
	cout &lt;&lt; "没交换前：" &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl;
	//交换函数
	jh(a, b);
	cout &lt;&lt; "交换后:" &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl;
	
}</code></pre> 
<hr> 
<p><strong>结果：</strong></p> 
<p><strong>我们可以看到语句交换了</strong></p> 
<p><img alt="" height="474" src="https://images2.imgbox.com/87/d6/fJRbi9Fn_o.png" width="675"></p> 
<hr> 
<p></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;assert.h&gt;
using namespace std;
typedef int STDataType;
typedef struct Stack
{
	STDataType* a;
	int top;
	int capacity;
}ST;
void STInit(ST&amp; rs, int n = 4)
{
	rs.a = (STDataType*)malloc(n * sizeof(STDataType));
	rs.top = 0;
	rs.capacity = n;
}
// 栈顶-入数据
void STPush(ST&amp; rs, STDataType x)
{
	// 满了， 扩容
	if (rs.top == rs.capacity)
	{
		printf("扩容\n");
		int newcapacity = rs.capacity == 0 ? 4 : rs.capacity * 2;
		STDataType* tmp = (STDataType*)realloc(rs.a, newcapacity *
			sizeof(STDataType));
		if (tmp == NULL)
		{
			perror("realloc fail");
			return;
		}
		rs.a = tmp;
		rs.capacity = newcapacity;
	}
	rs.a[rs.top] = x;
	rs.top++;
}
// 栈顶
int&amp; STTop(ST&amp; rs)
{
	assert(rs.top &gt; 0);
	return rs.a[rs.top];
}
int main()
{
	// 调⽤全局的
	ST st1;
	STInit(st1);
	STPush(st1, 1);
	STPush(st1, 2);
	cout &lt;&lt; STTop(st1) &lt;&lt; endl;

    //修改栈顶数据
	STTop(st1) += 10;
	cout &lt;&lt; STTop(st1) &lt;&lt; endl;
	return 0;
}</code></pre> 
<hr> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>引⽤在实践中主要是于引⽤传参和引⽤做返回值中减少拷⻉提⾼效率和改变引⽤对象时同时改变被引⽤对象。</strong></span></p> 
</blockquote> 
<p>我们这里+10的话，加的是临时对象，那要怎么解决这种问题呢？</p> 
<p><img alt="" height="473" src="https://images2.imgbox.com/3a/c9/bQmsuAPr_o.png" width="443"></p> 
<hr> 
<p><span style="color:#fe2c24;"><strong>那就要用到引⽤返回了，这样返回的就是别名了，加的也是数组里的数值了。</strong></span></p> 
<p><img alt="" height="446" src="https://images2.imgbox.com/cb/4e/m4GEz3pF_o.png" width="369"></p> 
<p><span style="color:#fe2c24;"><strong>结果：</strong></span></p> 
<p><img alt="" height="136" src="https://images2.imgbox.com/39/0f/D1CLwrlG_o.png" width="550"></p> 
<hr> 
<p><span style="color:#fe2c24;"><strong>引用返回在有些场景是不能用的，下面这一张图我们可以看到吗，a引用返回，但是局部空间都销毁，加10就越界访问了。</strong></span></p> 
<p><img alt="" height="357" src="https://images2.imgbox.com/64/a7/WQWYtsp1_o.png" width="238"></p> 
<hr> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>⼀些主要⽤C代码实现版本数据结构教材中，使⽤C++引⽤替代指针传参，⽬的是简化程序，避开复杂的指针，但是很多同学没学过引⽤，导致⼀头雾⽔。</strong></span></p> 
</blockquote> 
<pre><code class="language-cpp">
#include&lt;iostream&gt;
using namespace std;
typedef struct SeqList
{
	int a[10];
	int size;
}SLT;
// ⼀些主要⽤C代码实现版本数据结构教材中，使⽤C++引⽤替代指针传参，⽬的是简化程序，避开复
//杂的指针，但是很多同学没学过引⽤，导致⼀头雾⽔。
void SeqPushBack(SLT&amp; sl, int x)
{}
typedef struct ListNode
{
	int val;
	struct ListNode* next;
}LTNode, * PNode;

// 指针变量也可以取别名，这⾥LTNode*&amp; phead就是给指针变量取别名
// 这样就不需要⽤⼆级指针了，相对⽽⾔简化了程序
//void ListPushBack(LTNode** phead, int x)
//void ListPushBack(LTNode*&amp; phead, int x)
void ListPushBack(PNode&amp; phead, int x)
{
	PNode newnode = (PNode)malloc(sizeof(LTNode));
	newnode-&gt;val = x;
	newnode-&gt;next = NULL;
	if (phead == NULL)
	{
		phead = newnode;
	}
	else
	{
		//...
	}
}

int main()
{
	PNode plist = NULL;
	ListPushBack(plist, 1);
	return 0;
}</code></pre> 
<hr> 
<h3 id="const%E5%BC%95%E2%BD%A4">const引⽤</h3> 
<blockquote> 
 <ul><li><strong>可以引⽤⼀个const对象，但是必须⽤const引⽤。const引⽤也可以引⽤普通对象，因为对象的访问权限在引⽤过程中可以缩⼩，但是不能放⼤。</strong></li><li><strong>需要注意的是类似 int&amp; rb = a*3; double d = 12.34; int&amp; rd = d; 这样⼀些场<br> 景下a*3的和结果保存在⼀个临时对象中， int&amp; rd = d 也是类似，在类型转换中会产⽣临时对象存储中间值，也就是时，rb和rd引⽤的都是临时对象，⽽C++规定临时对象具有常性，所以这⾥就触发了权限放⼤，必须要⽤常引⽤才可以。</strong></li><li><strong>所谓临时对象就是编译器需要⼀个空间暂存表达式的求值结果时临时创建的⼀个未命名的对象，C++中把这个未命名对象叫做临时对象。</strong></li></ul> 
</blockquote> 
<p>权限不能放大，我们可以看到被const修饰的变量，就不能在引用了，const引用就可以了。</p> 
<p><img alt="" height="212" src="https://images2.imgbox.com/90/4b/ZkqHSfxI_o.png" width="259"><img alt="" height="218" src="https://images2.imgbox.com/dd/06/vNunY12l_o.png" width="244"></p> 
<hr> 
<p>权限可以缩小，被const引用的ps不能修改，但是b可以。</p> 
<p><img alt="" height="155" src="https://images2.imgbox.com/5a/2f/GeUWzDv0_o.png" width="314"><img alt="" height="139" src="https://images2.imgbox.com/f0/53/IdyO8YdK_o.png" width="228"></p> 
<hr> 
<pre><code class="language-cpp">int main()
{
	// 权限不能放大
	const int a = 10;
	const int* p1 = &amp;a;
	//int* p2 = p1;

	// 权限可以缩小
	int b = 20;
	int* p3 = &amp;b;
	const int* p4 = p3;

	// 不存在权限放大，因为const修饰的是p5本身不是指向的内容
	int* const p5 = &amp;b;
	int* p6 = p5;

	return 0;
}</code></pre> 
<hr> 
<blockquote> 
 <p><strong>需要注意的是类似 int&amp; rb = a*3; double d = 12.34; int&amp; rd = d; 这样⼀些场<br> 景下a*3的和结果保存在⼀个临时对象中， int&amp; rd = d 也是类似，在类型转换中会产⽣临时对象存储中间值，也就是时，rb和rd引⽤的都是临时对象，⽽C++规定临时对象具有常性，所以这⾥就触发了权限放⼤，必须要⽤常引⽤才可以。</strong></p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>rd引用的是临时变量，所以需要const引用</strong></span></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int main()
{
    //a是先给到临时变量，再给到rd , 临时变量是被cinst修饰的
    //rd引用的是临时变量，所以需要cinst引用

	int a = 10;
	const int&amp; ra = 30;
	// 编译报错: “初始化”: ⽆法从“int”转换为“int &amp;”
	// int&amp; rb = a * 3;
    //加上const就行了
	const int&amp; rb = a * 3;



    //d是先给到临时变量，再给到rd , 临时变量是被cinst修饰的
    //rd引用的是临时变量，所以需要cinst引用

	double d = 12.34;
	// 编译报错：“初始化”: ⽆法从“double”转换为“int &amp;”
	// int&amp; rd = d;
    //加上const就行了,
	const int&amp; rd = d;
	return 0;
}</code></pre> 
<hr> 
<p>引用传参</p> 
<p>const可以引用以下对象</p> 
<p>1.const对象</p> 
<p>2.普通对像</p> 
<p>3.临时对象</p> 
<p><img alt="" height="361" src="https://images2.imgbox.com/01/37/ZnKsoLFa_o.png" width="342"></p> 
<pre><code class="language-cpp">void f1(const int&amp; rx)
{

}

int main()
{
	const int xx = 20;
	int a = 10;
	const int&amp; rb = a * 3;

	double d = 12.34;
	const int&amp; rd = d;

	f1(xx);
	f1(a);
	f1(a*3);
	f1(d);

	return 0;
}</code></pre> 
<hr> 
<h3 id="%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E2%BD%A4%E7%9A%84%E5%85%B3%E7%B3%BB">指针和引⽤的关系</h3> 
<p>C++中指针和引⽤就像两个性格迥异的亲兄弟，指针是哥哥，引⽤是弟弟，在实践中他们相辅相成，功能有重叠性，但是各有⾃⼰的特点，互相不可替代。</p> 
<ul><li><strong>语法概念上引⽤是⼀个变量的取别名不开空间，指针是存储⼀个变量地址，要开空间。</strong></li><li><strong>引⽤在定义时必须初始化，指针建议初始化，但是语法上不是必须的。</strong></li><li><strong>引⽤在初始化时引⽤⼀个对象后，就不能再引⽤其他对象；⽽指针可以在不断地改变指向对象。</strong></li><li><strong>引⽤可以直接访问指向对象，指针需要解引⽤才是访问指向对象。</strong></li><li><strong>sizeof中含义不同，引⽤结果为引⽤类型的⼤⼩，但指针始终是地址空间所占字节个数(32位平台下占4个字节，64位下是8byte)</strong></li><li><strong>指针很容易出现空指针和野指针的问题，引⽤很少出现，引⽤使⽤起来相对更安全⼀些。</strong></li><li><img alt="" height="426" src="https://images2.imgbox.com/b5/02/Cv8CPIca_o.png" width="1200"></li></ul> 
<hr> 
<h2 id="inline%E5%B1%95%E5%BC%80">inline<strong>展开</strong></h2> 
<blockquote> 
 <ul><li><strong>⽤inline修饰的函数叫做内联函数，编译时C++编译器会在调⽤的地⽅展开内联函数，这样调⽤内联函数就不需要建⽴栈帧了，就可以提⾼效率。</strong></li><li><strong>inline对于编译器⽽⾔只是⼀个建议，也就是说，你加了inline编译器也可以选择在调⽤的地⽅不展开，不同编译器关于inline什么情况展开各不相同，因为C++标准没有规定这个。inline适⽤于频繁调⽤的短⼩函数，对于递归函数，代码相对多⼀些的函数，加上inline也会被编译器忽略。</strong></li><li><strong>C语⾔实现宏函数也会在预处理时替换展开，但是宏函数实现很复杂很容易出错的，且不⽅便调试，C++设计了inline⽬的就是替代C的宏函数。</strong></li><li><strong>vs编译器?debug版本下⾯默认是不展开inline的，这样⽅便调试，debug版本想展开需要设置⼀下以下两个地⽅。</strong></li><li><strong>inline不建议声明和定义分离到两个⽂件，分离会导致链接错误。因为inline被展开，就没有函数地址，链接时会出现报错。</strong></li></ul> 
</blockquote> 
<p><img alt="" height="209" src="https://images2.imgbox.com/5e/cd/UNbKBow5_o.png" width="300"><img alt="" height="205" src="https://images2.imgbox.com/c8/98/kt5rkm2a_o.png" width="300"></p> 
<hr> 
<p><strong>⽤inline修饰的函数叫做内联函数，编译时C++编译器会在调⽤的地⽅展开内联函数，这样调⽤内联函数就不需要建⽴栈帧了，就可以提⾼效率。</strong></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
// 没有宏函数的坑，也不用建立栈帧，提效
inline int Add(int x, int y)
{
	int ret = x + y;
	ret += 1;
	ret += 1;
	ret += 1;
	return ret;
}
int main()
{
	// 可以通过汇编观察程序是否展开
	// 有call Add语句就是没有展开，没有就是展开了
	int ret = Add(1, 2);
	cout &lt;&lt; Add(1, 2) * 5 &lt;&lt; endl;
	return 0;
}</code></pre> 
<p><img alt="" height="250" src="https://images2.imgbox.com/75/29/DvkAswfl_o.png" width="1200"></p> 
<p><img alt="" height="586" src="https://images2.imgbox.com/ac/8a/650w1z2N_o.png" width="1200"></p> 
<p><img alt="" height="502" src="https://images2.imgbox.com/0f/41/KBOOZI5o_o.png" width="533"></p> 
<hr> 
<p><strong>宏函数</strong></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
// 实现⼀个ADD宏函数的常⻅问题
//#define ADD(int a, int b) return a + b;
//#define ADD(a, b) a + b;
//#define ADD(a, b) (a + b)
// 正确的宏实现
#define ADD(a, b) ((a) + (b))
// 为什么不能加分号?
// 为什么要加外⾯的括号?
// 为什么要加⾥⾯的括号?
int main()
{
	int ret = ADD(1, 2);
	cout &lt;&lt; ADD(1, 2) &lt;&lt; endl;
	cout &lt;&lt; ADD(1, 2) * 5 &lt;&lt; endl;
	int x = 1, y = 2;
	ADD(x &amp; y, x | y); // -&gt; (x&amp;y+x|y)
	return 0;
}</code></pre> 
<hr> 
<p><strong>inline不建议声明和定义分离到两个⽂件，分离会导致链接错误。因为inline被展开，就没有函数地址，链接时会出现报错。</strong></p> 
<pre><code class="language-cpp">// F.h
#include &lt;iostream&gt;

using namespace std;
inline void f(int i);


// F.cpp--错误
#include "F.h"
void f(int i)
{
	cout &lt;&lt; i &lt;&lt; endl;
}

// F.cpp--正确
#include "F.h"
inline void f(int i)
{
	cout &lt;&lt; i &lt;&lt; endl;
}


// main.cpp
#include "F.h"
int main()
{
	// 链接错误：⽆法解析的外部符号 "void __cdecl f(int)" (?f@@YAXH@Z)
	f(10);
	return 0;
}</code></pre> 
<hr> 
<h2 id="nullptr" style="background-color:transparent;">nullptr</h2> 
<p>NULL实际是⼀个宏，在传统的C头⽂件(stddef.h)中，可以看到如下代码：</p> 
<pre><code class="language-cpp">#ifndef NULL
	#ifdef __cplusplus
		#define NULL 0
	#else
		#define NULL ((void *)0)
	#endif
#endif</code></pre> 
<blockquote> 
 <ul><li><strong>C++中NULL可能被定义为字⾯常量0，或者C中被定义为⽆类型指针(void*)的常量。不论采取何种定义，在使⽤空值的指针时，都不可避免的会遇到⼀些⿇烦，本想通过f(NULL)调⽤指针版本的f(int*)函数，但是由于NULL被定义成0，调⽤了f(int?x)，因此与程序的初衷相悖。f((void*)NULL);调⽤会报错。</strong></li><li><strong>C++11中引⼊nullptr，nullptr是⼀个特殊的关键字，nullptr是⼀种特殊类型的字⾯量，它可以转换成任意其他类型的指针类型。使⽤nullptr定义空指针可以避免类型转换的问题，因为nullptr只能被隐式地转换为指针类型，⽽不能被转换为整数类型。</strong></li></ul> 
</blockquote> 
<p><strong>C++是0；</strong></p> 
<p><strong>C语言是（（void *）0）；</strong></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
void f(int x)
{
	cout &lt;&lt; "f(int x)" &lt;&lt; endl;
}
void f(int* ptr)
{
	cout &lt;&lt; "f(int* ptr)" &lt;&lt; endl;
}
int main()
{
	f(0);
	// 本想通过f(NULL)调⽤指针版本的f(int*)函数，但是由于NULL被定义成0，调⽤了f(int x)，因此与程序的初衷相悖。
	f(NULL);
	f((int*)NULL);
	// 编译报错：error C2665: “f”: 2 个重载中没有⼀个可以转换所有参数类型
	// f((void*)NULL);
	f(nullptr);
	return 0;
}</code></pre> 
<hr> 
<p><img alt="" height="476" src="https://images2.imgbox.com/ad/b2/yrrYnCSg_o.png" width="618"></p> 
<hr> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/65f770195faac0de3ca88a9c6a554296/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">单一职责原则介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c9a8d6eebefb134fd5b3c14c00f229f0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据结构：树形结构（树、堆）详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>