<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深入了解数据结构第四弹——排序（1）——插入排序和希尔排序 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/9441884f3473b61706971c42ead1bd4a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="深入了解数据结构第四弹——排序（1）——插入排序和希尔排序">
  <meta property="og:description" content="前言：
从本篇开始，我们就开始进入排序的学习，在结束完二叉树的学习之后，相信我们对数据在内存中的存储结构有了新的认识，今天开始，我们将进入排序的学习，今天来学习第一篇——插入排序
目录
什么是插入排序？
一、直接插入排序
1、直接插入排序的实现
2、直接插入排序的时间复杂度
二、希尔排序
1、希尔排序的实现
2、希尔排序的时间复杂度
三、直接插入排序和希尔排序时间复杂度的比较
四、总结
首先，我们先来了解一下几种排序算法都有什么，方便我们后期学习，今天，我们先来讲解插入排序
什么是插入排序？ 插入排序其实挺有意思，这种排序方法在我们生活中也挺常见，例如，当我们在打扑克的时候，当我们再次摸牌时，我们会将新牌按照大小顺序插入到旧牌中
插入排序实际上就是将一个数字按照大小顺序插入到已知的序列中去
一、直接插入排序 1、直接插入排序的实现 插入排序是从后往前比较的，例如
当我们对这样一个数组进行插入排序时，我们先将1放进去，然后再放进去2与1比较，再放进去4与前面的1和2比较，以此类推，每放进去一个数字与前面数字比较，所以插入排序的过程是需要遍历数组的，我们首先可以给一个end变量标记现在排好序的数组的末端位置，再给出一个tmp变量来表示要排序的数字
插入排序的代码如下：（降序）
void InsertSort(int* a, int n) { for (int i = 1; i &lt; n; i&#43;&#43;) { int end = i - 1; int tmp=a[i]; while (end&gt;=0) { if (tmp &gt; a[end]) { a[end &#43; 1] = a[end]; end--; } else { break; } } a[end &#43; 1] = tmp; } } 通过这段代码我们就可以看出插入排序的规则：当插入数据大于end位置的数据时，让end位置的数据向后移动一位，同时让end位置存放新插入的数据；当插入数据小于end位置数据时，那就直接让插入数据存放在end加1的位置就行">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-10T22:38:37+08:00">
    <meta property="article:modified_time" content="2024-04-10T22:38:37+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深入了解数据结构第四弹——排序（1）——插入排序和希尔排序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>前言：</strong></p> 
<blockquote> 
 <p>从本篇开始，我们就开始进入排序的学习，在结束完二叉树的学习之后，相信我们对数据在内存中的存储结构有了新的认识，今天开始，我们将进入排序的学习，今天来学习第一篇——插入排序</p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%BB%80%E4%B9%88%E6%98%AF%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%9F" rel="nofollow">什么是插入排序？</a></p> 
<p id="%E4%B8%80%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" rel="nofollow">一、直接插入排序</a></p> 
<p id="1%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">1、直接插入排序的实现</a></p> 
<p id="2%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" rel="nofollow">2、直接插入排序的时间复杂度</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" rel="nofollow">二、希尔排序</a></p> 
<p id="1%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">1、希尔排序的实现</a></p> 
<p id="2%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" rel="nofollow">2、希尔排序的时间复杂度</a></p> 
<p id="%E4%B8%89%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%92%8C%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%AF%94%E8%BE%83-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%92%8C%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%AF%94%E8%BE%83" rel="nofollow">三、直接插入排序和希尔排序时间复杂度的比较</a></p> 
<p id="%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93" rel="nofollow">四、总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<blockquote> 
 <p>首先，我们先来了解一下几种排序算法都有什么，方便我们后期学习，今天，我们先来讲解插入排序</p> 
 <p></p> 
</blockquote> 
<p><img alt="" height="439" src="https://images2.imgbox.com/ef/f2/4WhI43iA_o.jpg" width="629"></p> 
<h3 id="%E4%BB%80%E4%B9%88%E6%98%AF%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%9F">什么是插入排序？</h3> 
<blockquote> 
 <p>插入排序其实挺有意思，这种排序方法在我们生活中也挺常见，例如，当我们在打扑克的时候，当我们再次摸牌时，我们会将新牌按照大小顺序插入到旧牌中</p> 
</blockquote> 
<p><img alt="" height="666" src="https://images2.imgbox.com/64/d8/2KU7AXvP_o.png" width="663"></p> 
<p>插入排序实际上就是将一个数字按照大小顺序插入到已知的序列中去</p> 
<p><img alt="" height="157" src="https://images2.imgbox.com/fa/17/GIgD7P48_o.png" width="329"></p> 
<h3 id="%E4%B8%80%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">一、直接插入排序</h3> 
<h4 id="1%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0">1、直接插入排序的实现</h4> 
<blockquote> 
 <p>插入排序是从后往前比较的，例如</p> 
</blockquote> 
<p><img alt="" height="33" src="https://images2.imgbox.com/db/0f/01IR6oHZ_o.png" width="399"></p> 
<blockquote> 
 <p>当我们对这样一个数组进行插入排序时，我们先将1放进去，然后再放进去2与1比较，再放进去4与前面的1和2比较，以此类推，每放进去一个数字与前面数字比较，所以插入排序的过程是需要遍历数组的，<strong>我们首先可以给一个end变量标记现在排好序的数组的末端位置，再给出一个tmp变量来表示要排序的数字</strong></p> 
</blockquote> 
<p><img alt="" height="514" src="https://images2.imgbox.com/70/43/XoO6gzUX_o.png" width="853"></p> 
<p><strong>插入排序的代码如下：（降序）</strong></p> 
<pre><code class="language-cpp">void InsertSort(int* a, int n)
{
	for (int i = 1; i &lt; n; i++)
	{
		int end = i - 1;
		int tmp=a[i];
		while (end&gt;=0)
		{
			if (tmp &gt; a[end])
			{
				a[end + 1] = a[end];
				end--;
			}
			else
			{
				break;
			}
		}
		a[end + 1] = tmp;
	}
}
</code></pre> 
<blockquote> 
 <p>通过这段代码我们就可以看出插入排序的规则：当插入数据大于end位置的数据时，让end位置的数据向后移动一位，同时让end位置存放新插入的数据；当插入数据小于end位置数据时，那就直接让插入数据存放在end加1的位置就行</p> 
</blockquote> 
<p></p> 
<p><span style="background-color:#ffd900;">我们建立一个完整的代码示例并打印结果，给大家看看效果</span></p> 
<pre><code class="language-cpp">
//插入排序
void PrintArray(int* a, int n)
{
	for (int i = 0; i &lt; n; i++)
	{
		printf("%d ", a[i]);
	}
	printf("\n");
}
void InsertSort(int* a, int n)
{
	for (int i = 1; i &lt; n; i++)
	{
		int end = i - 1;
		int tmp = a[i];
		while (end &gt;= 0)
		{
			if (tmp &gt; a[end])
			{
				a[end + 1] = a[end];
				end--;
			}
			else
			{
				break;
			}
		}
		a[end + 1] = tmp;
	}
}

void TestInsertSort()
{
	int a[] = { 1,2,4,7,8,2,5,3 };
	PrintArray(a, sizeof(a) / sizeof(a[0]));
	InsertSort(a, sizeof(a) / sizeof(a[0]));
	PrintArray(a, sizeof(a) / sizeof(a[0]));
}
int main()
{
	TestInsertSort();
	return 0;
}</code></pre> 
<p><strong>运行结果：</strong></p> 
<p><strong>第一行是排序前，第二行是排序后</strong></p> 
<p><img alt="" height="240" src="https://images2.imgbox.com/30/74/S7YDOr8W_o.png" width="886"></p> 
<h4 id="2%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">2、直接插入排序的时间复杂度</h4> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>时间复杂度最坏O(N^2)<br> 时间复杂度最好O(N)</strong></span></p> 
</blockquote> 
<p><strong>如图所示：</strong></p> 
<p><img alt="" height="362" src="https://images2.imgbox.com/0d/97/NvWUImt9_o.png" width="1200"></p> 
<blockquote> 
 <p>不同的两组数据在用直接插入排序降序时，左边时间复杂度明显小于右边</p> 
</blockquote> 
<p><span style="background-color:#38d8f0;">综上，其实综合来说直接插入排序的时间复杂度是介于</span><span style="color:#fe2c24;"><strong><span style="background-color:#38d8f0;">O(N)</span></strong></span><span style="background-color:#38d8f0;">和</span><span style="color:#fe2c24;"><strong><span style="background-color:#38d8f0;">O(N^2)</span></strong></span><span style="background-color:#38d8f0;">之间的</span></p> 
<h3 id="%E4%BA%8C%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">二、希尔排序</h3> 
<h4 id="1%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0">1、希尔排序的实现</h4> 
<blockquote> 
 <p>希尔排序是插入排序的改进，它通过将待排序的数据分割成若干个子序列来提高插入排序的效率。希尔排序的基本思想是：先将整个待排序的序列分割成若干个子序列，然后对这些子序列分别进行插入排序，最后再对整个序列进行一次插入排序。</p> 
</blockquote> 
<blockquote> 
 <p>希尔排序的具体步骤如下：</p> 
 <ol><li>选择一个增量序列，通常是按照一定规则递减的序列，最常用的是取增量序列为n/2，n/4，n/8...1，后来经过改进，一般选择n/3+1来确保程序的稳定性</li><li>根据增量序列的值，将待排序序列分割成若干个子序列，对每个子序列进行插入排序。</li><li>逐渐缩小增量，重复第2步，直到增量为1。</li><li>最后对整个序列进行一次插入排序</li></ol> 
</blockquote> 
<p>例如：对于<span style="color:#0d0016;"><strong><span style="background-color:#ffd900;">{9，8，7，6，5，4，3，2，1，0}</span></strong></span>这样一组数据，用希尔排序排升序的步骤如下：</p> 
<p><img alt="" height="505" src="https://images2.imgbox.com/12/d2/FPkVKHiS_o.png" width="956"></p> 
<p><strong>实现上图功能的代码如下：</strong></p> 
<pre><code class="language-cpp">void ShellSort(int* a, int n)
{
	int gap = n;
	while (gap &gt; 1)
	{
		gap = gap / 3 + 1;    //+1可以保证最后一次一定为1
		
		for (int i = 0; i &lt; n - gap; i++)      //每组插入排序
		{
			int end = i;
			int tmp = a[end + gap];
			while (end &gt;= 0)
			{
				if (a[end] &gt; tmp)
				{
					a[end + gap] = a[end];
					end -= gap;
				}
				else
				{
					break;
				}
			}
			a[end + gap] = tmp;
		}
	}
}</code></pre> 
<p>这个过程跟插入排序相似度很高，可以将两者放在一起比较体会一下</p> 
<p><img alt="" height="724" src="https://images2.imgbox.com/21/33/1E1XhIEq_o.png" width="1200"></p> 
<p><strong>希尔排序的完整代码示例：</strong></p> 
<pre><code class="language-cpp">void PrintArray(int* a, int n)
{
	for (int i = 0; i &lt; n; i++)
	{
		printf("%d ", a[i]);
	}
	printf("\n");
}
void ShellSort(int* a, int n)
{
	int gap = n;
	while (gap &gt; 1)
	{
		gap = gap / 3 + 1;    //+1可以保证最后一次一定为1
		for (int i = 0; i &lt; n - gap; i++)      //每组插入排序
		{
			int end = i;
			int tmp = a[end + gap];
			while (end &gt;= 0)
			{
				if (a[end] &gt; tmp)
				{
					a[end + gap] = a[end];
					end -= gap;
				}
				else
				{
					break;
				}
			}
			a[end + gap] = tmp;
		}
	}
}
void TestShell()
{
	int a[] = { 9,8,7,6,5,4,3,2,1,0 };
	printf("排序前：");
	PrintArray(a, sizeof(a) / sizeof(0));
	ShellSort(a, sizeof(a) / sizeof(0));
	printf("排序后：");
	PrintArray(a, sizeof(a) / sizeof(0));
}
int main()
{
	TestShell();
	return 0;
}</code></pre> 
<p><strong>运行结果：</strong></p> 
<p><img alt="" height="275" src="https://images2.imgbox.com/07/0e/ohKc2k3q_o.png" width="996"></p> 
<h4 id="2%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">2、希尔排序的时间复杂度</h4> 
<blockquote> 
 <p>希尔排序的时间复杂度取决于增量序列的选择，一般情况下，希尔排序的时间复杂度为O(n log n)到O(n^2)之间。希尔排序是不稳定的排序算法，因为在排序过程中会改变相同元素之间的相对位置，所以希尔排序的时间复杂度其实并不能真正的计算出来，但希尔排序仍然要比直接排序要高效的多，我们可以通过一些方式来检验这种高效性</p> 
</blockquote> 
<h3 id="%E4%B8%89%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%92%8C%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%AF%94%E8%BE%83">三、直接插入排序和希尔排序时间复杂度的比较</h3> 
<p>我们可以通过<span style="color:#fe2c24;"><strong>clock()</strong></span>函数来检验他们两个的时间复杂度</p> 
<pre><code class="language-cpp">void TestOP()
{
	srand(time(0));
	const int N = 10000;
	int* a1 = (int*)malloc(sizeof(int) * N);
	int* a2 = (int*)malloc(sizeof(int) * N);
	int* a3 = (int*)malloc(sizeof(int) * N);
	for (int i = 0; i &lt; N; i++)       //让这两个算法都处理一万组数据，比较他们两个用时长短
	{
		a1[i] = rand();
		a2[i] = a1[i];
		a3[i] = a1[i];
	}
	int begin1 = clock();  
	InsertSort(a1, N);
	int end1 = clock();

	int begin2 = clock();
	ShellSort(a2, N);
	int end2 = clock();

	printf("InsertSort:%d\n", end1 - begin1);  //直接插入排序所用时间
	printf("ShellSort:%d\n", end2 - begin2);   //希尔排序所用时间
}</code></pre> 
<p><strong>运行结果：</strong></p> 
<p><img alt="" height="105" src="https://images2.imgbox.com/be/e4/NTWfksYc_o.png" width="816"></p> 
<h3 id="%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93">四、总结</h3> 
<p>通过运行结果我们可以明显的观察到，在处理相同大小的一组数据时，希尔排序比直接插入排序要高效的多，且随着数据的增多，这种差异会愈加明显</p> 
<p>以上就是插入排序的全部内容，鉴于篇幅问题，本篇文章讲解的有些粗糙，如果有不理解的地方，欢迎与我私信交流或者在评论区中指出！！！</p> 
<p></p> 
<p><strong><span style="background-color:#ffd900;">感谢观看，创作不易，还请各位大佬点赞支持！！！</span></strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bd08baf469d0a30847e49c3fa2ecef5e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">docker报错：Docker Desktop - WSL distro terminated abruptly</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/334ff706c9187302e40d522e2ccf945e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">层层剥开Android14升级后异常弹框的神秘面纱_此应用与最新版 android 不兼容。请检查是否有更新,或与应用开发者联系。(1)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>