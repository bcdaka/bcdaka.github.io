<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【c&#43;&#43;】继承学习(一)：继承机制与基类派生类转换 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4e77292f30a81f979db51032035e1a5a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【c&#43;&#43;】继承学习(一)：继承机制与基类派生类转换">
  <meta property="og:description" content="🔥个人主页：Quitecoder
🔥专栏：c&#43;&#43;笔记仓
朋友们大家好，本篇文章我们来学习继承部分
目录 `1.继承的概念和定义``继承的定义``继承基类成员的访问方式变化` `2.基类和派生类对象赋值转换``3.继承中的作用域` 1.继承的概念和定义 继承(inheritance)机制是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生新的类，称派生类。继承呈现了面向对象程序设计的层次结构，体现了由简单到复杂的认知过程。以前我们接触的复用都是函数复用，继承是类设计层次的复用
通过继承，子类可以重用父类的代码，这有助于减少代码冗余和复杂性，并增加代码的可复用性
子类和父类是继承关系中的两个基本概念：
父类/ 基类:
父类是一个更一般的类，它定义了一种通用的数据类型和方法，这些可以被其他类继承。它是继承关系中处于较高层次的类，其特性（属性和方法）可以传递到派生的类中。其他从父类继承的类会自动获得父类定义的所有公共和受保护的成员。
子类/ 派生类:
子类是从一个或多个父类继承特性的类。它是继承关系中处于较低层次的类，可以继承其一或多个父类的属性和方法。子类通常会添加一些特有的属性和方法，或者重写某些从父类继承的方法来改变行为。子类集成了父类的特征，并可以拥有自己的特征。
简单来说，父类是派生过程的起点，提供了基础的属性和方法，而子类是继承的结果，它可以扩展和定制继承来的属性和方法。通过这种方式，子类和父类形成了一种层次结构，允许更高层次的代码重用和泛化
例如下面的例子：
父类包含一些通用的属性，人名和年龄，派生类继承自父类但具有不同的额外特性或方法
class Person { public: void Print() { cout &lt;&lt; &#34;name:&#34; &lt;&lt; _name &lt;&lt; endl; cout &lt;&lt; &#34;age:&#34; &lt;&lt; _age &lt;&lt; endl; } protected: string _name = &#34;jason&#34;; // 姓名 int _age = 18; // 年龄 }; class Student : public Person { protected: int _stuid; // 学号 }; class Teacher : public Person { protected: int _jobid; // 工号 }; 继承后父类的Person的成员（成员函数&#43;成员变量）都会变成子类的一部分。这里体现出了Student和Teacher复用了Person的成员。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-03T19:20:09+08:00">
    <meta property="article:modified_time" content="2024-05-03T19:20:09+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【c&#43;&#43;】继承学习(一)：继承机制与基类派生类转换</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/7d/48/eSn96Z6R_o.png" alt="Alt" width="300" height="170"></p> 
<p><font color="peru" size="4"><b>🔥个人主页</b>：<a href="https://blog.csdn.net/arf_dog?type=blog"><font color="#33CCCC" size="4"><b>Quitecoder</b></font></a></font></p> 
<p><font color="peru" size="4">🔥<strong>专栏</strong></font>：<a href="https://blog.csdn.net/arf_dog/category_12614029.html?spm=1001.2014.3001.5482"><font color="#33CCCC" size="4"><b>c++笔记仓</b></font></a></p> 
<p><img src="https://images2.imgbox.com/92/92/Yj4FEOmh_o.gif" alt="Alt"></p> 
<blockquote> 
 <p>朋友们大家好，本篇文章我们来学习<strong>继承</strong>部分</p> 
</blockquote> 
<p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#1_17" rel="nofollow">`1.继承的概念和定义`</a></li><li><ul><li><a href="#_84" rel="nofollow">`继承的定义`</a></li><li><a href="#_92" rel="nofollow">`继承基类成员的访问方式变化`</a></li></ul> 
  </li><li><a href="#2_180" rel="nofollow">`2.基类和派生类对象赋值转换`</a></li><li><a href="#3_263" rel="nofollow">`3.继承中的作用域`</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1_17"></a><code>1.继承的概念和定义</code></h2> 
<p><strong>继承</strong>(inheritance)机制是面向对象程序设计<mark>使代码可以复用</mark>的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生新的类，称<strong>派生类</strong>。继承<strong>呈现了面向对象程序设计的层次结构</strong>，体现了由简单到复杂的认知过程。以前我们接触的复用都是函数复用，<strong>继承是类设计层次的复用</strong></p> 
<p><strong>通过继承，子类可以重用父类的代码，这有助于减少代码冗余和复杂性，并增加代码的可复用性</strong></p> 
<p>子类和父类是继承关系中的两个基本概念：</p> 
<ol><li> <p><strong>父类/ 基类</strong>:<br> 父类是一个更一般的类，它定义了<strong>一种通用的数据类型和方法</strong>，这些可以被其他类继承。它是继承关系中处于较高层次的类，其特性（属性和方法）可以传递到派生的类中。其他从父类继承的类会自动获得父类定义的所有公共和受保护的成员。</p> </li><li> <p><strong>子类/ 派生类</strong>:<br> 子类是从一个或多个父类继承特性的类。它是继承关系中处于较低层次的类，可以继承其一或多个父类的属性和方法。子类通常会添加一些特有的属性和方法，或者重写某些从父类继承的方法来改变行为。子类集成了父类的特征，并可以拥有自己的特征。</p> </li></ol> 
<blockquote> 
 <p><strong>简单来说，父类是派生过程的起点，提供了基础的属性和方法，而子类是继承的结果，它可以扩展和定制继承来的属性和方法。通过这种方式，子类和父类形成了一种层次结构，允许更高层次的代码重用和泛化</strong></p> 
</blockquote> 
<p>例如下面的例子：</p> 
<p><img src="https://images2.imgbox.com/36/42/UZZo79ba_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>父类包含一些通用的属性，人名和年龄，派生类继承自父类但具有不同的额外特性或方法</strong></p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"name:"</span> <span class="token operator">&lt;&lt;</span> _name <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"age:"</span> <span class="token operator">&lt;&lt;</span> _age <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	string _name <span class="token operator">=</span> <span class="token string">"jason"</span><span class="token punctuation">;</span> <span class="token comment">// 姓名</span>
	<span class="token keyword">int</span> _age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>  <span class="token comment">// 年龄</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _stuid<span class="token punctuation">;</span> <span class="token comment">// 学号</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Teacher</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _jobid<span class="token punctuation">;</span> <span class="token comment">// 工号</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>继承后父类的Person的成员（成员函数+成员变量）都会变成子类的一部分。这里体现出了Student和Teacher复用了Person的成员</strong>。</p> 
<p>下面我们使用监视窗口查看Student和Teacher对象，可以看到变量的复用。调用Print可以看到成员函数的复用</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Student s<span class="token punctuation">;</span>
	Teacher t<span class="token punctuation">;</span>
	s<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	t<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/ea/88/tfLRioAf_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/fe/fd/BPKXHNAD_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_84"></a><code>继承的定义</code></h3> 
<p><strong>格式</strong>：</p> 
<p><img src="https://images2.imgbox.com/eb/30/CWZRsUIC_o.png" alt="在这里插入图片描述"><br> 继承关系和访问限定符：</p> 
<p><img src="https://images2.imgbox.com/4b/50/vtLWmoBa_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_92"></a><code>继承基类成员的访问方式变化</code></h3> 
<table><thead><tr><th>类成员/继承方式</th><th>public继承</th><th>protected继承</th><th>private继承</th></tr></thead><tbody><tr><td><strong>基类的public成员</strong></td><td><strong>派生类的public成员</strong></td><td><strong>派生类的protected成员</strong></td><td><strong>派生类的private成员</strong></td></tr><tr><td><strong>基类的protected成员</strong></td><td><strong>派生类的protected成员</strong></td><td><strong>派生类的protected成员</strong></td><td><strong>派生类的private成员</strong></td></tr><tr><td><strong>基类的private成员</strong></td><td><strong>在派生类中不可见</strong></td><td><strong>在派生类中不可见</strong></td><td><strong>在派生类中不可见</strong></td></tr></tbody></table> 
<ol><li><strong>基类private成员在派生类中无论以什么方式继承都是不可见的</strong>。这里的不可见是指基类的私有成员还是被继承到了派生类对象中，<mark>但是语法上限制派生类对象不管在类里面还是类外面都不能去访问它</mark></li></ol> 
<p><strong>我们前面知道，类里面可以访问它的成员，但是private继承下，子类是无法访问父类的成员的</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"name:"</span> <span class="token operator">&lt;&lt;</span> _name <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"age:"</span> <span class="token operator">&lt;&lt;</span> _age <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	string _name <span class="token operator">=</span> <span class="token string">"jason"</span><span class="token punctuation">;</span> <span class="token comment">// 姓名</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>  <span class="token comment">// 年龄</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>我们这个类，拥有三个成员</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_name <span class="token operator">=</span> <span class="token string">"peter"</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _stuid<span class="token punctuation">;</span> <span class="token comment">// 学号</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>在我们这个子类中，<strong>我们可以访问除了父类私有成员的其他成员</strong>，<mark>父类的私有成员父类自己可以用，子类不可以直接使用</mark></p> 
<p>但是可以间接使用，比如我用<strong>子类来调用上面的Print函数</strong>，</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">void</span> <span class="token function">Fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_name <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>
		<span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _stuid<span class="token punctuation">;</span> <span class="token comment">// 学号</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre> 
<p><img src="https://images2.imgbox.com/55/15/khD6HHY2_o.png" alt="在这里插入图片描述"></p> 
<ol start="2"><li> <p><strong>基类private成员在派生类中是不能被访问，如果基类成员不想在类外直接被访问，但需要在派生类中能访问，就定义为protected</strong>。<mark>可以看出保护成员限定符是因继承才出现的</mark></p> </li><li> <p>实际上面的表格我们进行一下总结会发现，基类的私有成员在子类都是不可见。基类的其他成员在子类的访问方式 == 权限小的那个(成员在基类的访问限定符，继承方式)，<strong>public &gt; protected &gt; private。</strong></p> </li><li> <p><strong>使用关键字class时默认的继承方式是private，使用struct时默认的继承方式是public，不过最好显示的写出继承方式</strong></p> </li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">protected</span> <span class="token class-name">Person</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">Fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_name <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>
		<span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _stuid<span class="token punctuation">;</span> <span class="token comment">// 学号</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>公有的Print函数遇到protected继承变成保护类，无法外部直接调用：</p> 
<p><img src="https://images2.imgbox.com/78/e2/0QNAFQJS_o.png" alt="在这里插入图片描述"><br> <mark>保护是类外面不能访问，类里面还可以访问</mark></p> 
<p><img src="https://images2.imgbox.com/b6/f3/1j4zjgnm_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>在实际运用中一般使用都是<code>public</code>继承，几乎很少使用protetced/private继承，也不提倡使用<code>protetced/private</code>继承，因为<code>protetced/private</code>继承下来的成员都只能在派生类的类里面使用，实际中扩展维护性不强</strong></p> 
</blockquote> 
<h2><a id="2_180"></a><code>2.基类和派生类对象赋值转换</code></h2> 
<ol><li><strong>派生类对象</strong>可以赋值给<strong>基类的对象</strong> / <strong>基类的指针</strong> / <strong>基类的引用</strong>。这里有个形象的说法叫切片或者切割。寓意把派生类中父类那部分切来赋值过去</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	string _name<span class="token punctuation">;</span> <span class="token comment">// 姓名</span>
	string _sex<span class="token punctuation">;</span><span class="token comment">// 性别</span>
	<span class="token keyword">int</span> _age<span class="token punctuation">;</span> <span class="token comment">// 年龄</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _No<span class="token punctuation">;</span> <span class="token comment">// 学号</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<pre><code class="prism language-cpp">Student sobj<span class="token punctuation">;</span>
<span class="token comment">// 1.子类对象可以赋值给父类对象/指针/引用</span>
Person pobj <span class="token operator">=</span> sobj<span class="token punctuation">;</span>
Person<span class="token operator">*</span> pp <span class="token operator">=</span> <span class="token operator">&amp;</span>sobj<span class="token punctuation">;</span>
Person<span class="token operator">&amp;</span> rp <span class="token operator">=</span> sobj<span class="token punctuation">;</span>
</code></pre> 
<p><strong>每一个子类对象都是一个特殊的父类对象</strong><br> <img src="https://images2.imgbox.com/75/4e/oV1KQTEF_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>当派生类对象被赋值给基类对象时会发生。在切片过程中，派生类对象的部分（通常是额外添加的成员变量和方法）会被忽略，只有基类中定义的部分会被复制到基类对象中。因此，派生类特有的成员变量和方法不会出现在基类对象中，就像它们被“切掉”了一样</strong></p> 
</blockquote> 
<p>在代码中：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _No<span class="token punctuation">;</span> <span class="token comment">// 学号</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Student sobj<span class="token punctuation">;</span>
	<span class="token comment">// 1.子类对象可以赋值给父类对象/指针/引用</span>
	Person pobj <span class="token operator">=</span> sobj<span class="token punctuation">;</span>  <span class="token comment">// 切片发生在这里</span>
	Person<span class="token operator">*</span> pp <span class="token operator">=</span> <span class="token operator">&amp;</span>sobj<span class="token punctuation">;</span>  <span class="token comment">// 没有切片，因为 pp 指向的是一个 Student 对象</span>
	Person<span class="token operator">&amp;</span> rp <span class="token operator">=</span> sobj<span class="token punctuation">;</span>   <span class="token comment">// 没有切片，因为 rp 引用的是一个 Student 对象</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li> <p>在行 <code>Person pobj = sobj;</code> 中，由于 <code>pobj</code> 是 <code>Person</code> 类型的对象，<code>sobj</code>（一个 <code>Student</code> 对象）被赋值给 <code>pobj</code> 时，<code>Student</code> 类特有的 <code>_No</code> 成员被“切掉”，不会体现在 <code>pobj</code> 中。因此，<code>pobj</code> 中无法反映出 <code>sobj</code> 的完整状态和行为。</p> </li><li> <p>在行 <code>Person* pp = &amp;sobj;</code> 中，<code>pp</code> 是指向 <code>Person</code> 类型的指针，但它实际上指向了派生类 <code>Student</code> 的对象 <code>sobj</code>，没有发生切片，因为指针指向的是完整的 <code>Student</code> 对象。</p> </li><li> <p>在行 <code>Person&amp; rp = sobj;</code> 中，<code>rp</code> 是一个引用 <code>Person</code> 类型，它引用了 <code>sobj</code>，同样没有发生切片，因为引用关联的是 <code>sobj</code> 的完整实体。</p> </li></ul> 
<p>实际上，在行 <code>Person&amp; rp = sobj;</code> 中，引用 <code>rp</code> 的确是 <code>Person</code> 类型，<strong>但它并不导致对象切片</strong>。引用实际上并不拥有它所引用的对象，而只是提供另一个名称来访问现有对象。因此，当我们通过基类引用访问派生类对象时，并没有创建新的对象，也没有丢失派生类的任何部分。</p> 
<p>在这行代码中：</p> 
<pre><code class="prism language-cpp">Person<span class="token operator">&amp;</span> rp <span class="token operator">=</span> sobj<span class="token punctuation">;</span>
</code></pre> 
<p><code>rp</code> 实际上是对 <code>sobj</code> （它是一个 <code>Student</code> 类型的对象）的另一个访问方式。即使 <code>rp</code> 被声明为 <code>Person</code> 类型的引用，它实际引用的还是 <code>sobj</code> 的完整实体（包含 <code>Person</code> 部分和 <code>Student</code> 特有的部分）。<mark>但是，通过 <code>rp</code> 只能直接访问 <code>sobj</code> 中由 <code>Person</code> 定义的成员，<code>Student</code> 特有的成员（如 <code>_No</code>）不可以通过 <code>rp</code> 直接访问，除非进行了适当的强制转换</mark></p> 
<p>例子：</p> 
<pre><code class="prism language-cpp">Person<span class="token operator">&amp;</span> rp <span class="token operator">=</span> sobj<span class="token punctuation">;</span>
rp<span class="token punctuation">.</span>_name <span class="token operator">=</span> <span class="token string">"Name"</span><span class="token punctuation">;</span>    <span class="token comment">// 可以访问，因为_name是Person的成员</span>
<span class="token comment">// rp._No = 123;      // 错误！无法访问，因为_No是Student特有的成员，即使它实际上存在于sobj中</span>
</code></pre> 
<p><strong>即使我们通过基类引用或指针操作对象，派生类对象的完整信息（所有成员变量和函数）仍然都在内存中，没有丢失。使用引用和指针时不会发生切片</strong></p> 
<p>对象切片的问题仅在派生类对象被赋值给另一个基类类型的对象时才会发生，比如当派生类对象被传值给一个基类对象的函数参数，或者通过赋值构造一个新的基类对象。这时候派生类特有的信息实际上会被切割掉并不会出现在新的基类对象中。在使用引用或指针时，这种情况并不会发生</p> 
<ol start="2"><li><strong>基类对象不能赋值给派生类对象</strong></li><li><strong>基类的指针或者引用可以通过强制类型转换赋值给派生类的指针或者引用。但是必须是基类的指针是指向派生类对象时才是安全的</strong>。这里基类如果是多态类型，可以使用RTTI(Run-Time Type Information)的<code>dynamic_cast</code> 来进行识别后进行安全转换</li></ol> 
<h2><a id="3_263"></a><code>3.继承中的作用域</code></h2> 
<ol><li><strong>在继承体系中基类和派生类都有独立的作用域</strong>。</li><li><strong>子类和父类中有同名成员，子类成员将屏蔽父类对同名成员的直接访问，这种情况叫隐藏，也叫重定义。（在子类成员函数中，可以使用 基类::基类成员 显示访问）</strong></li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	string _name <span class="token operator">=</span> <span class="token string">"a"</span><span class="token punctuation">;</span> <span class="token comment">// 姓名</span>
	<span class="token keyword">int</span> _num <span class="token operator">=</span> <span class="token number">111</span><span class="token punctuation">;</span> <span class="token comment">// 身份证号</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">" 姓名:"</span> <span class="token operator">&lt;&lt;</span> _name <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">" 身份证号:"</span> <span class="token operator">&lt;&lt;</span> Person<span class="token double-colon punctuation">::</span>_num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">" 学号:"</span> <span class="token operator">&lt;&lt;</span> _num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _num <span class="token operator">=</span> <span class="token number">999</span><span class="token punctuation">;</span> <span class="token comment">// 学号</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Student s1<span class="token punctuation">;</span>
	s1<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>这段代码展示了成员隐藏，以及如何在派生类中访问基类的被隐藏成员的概念。</p> 
<ul><li> <p>在 <code>Student</code> 类中，成员函数 <code>Print</code> 试图访问名称为 <code>_num</code> 的成员变量。由于派生类中存在同名成员，派生类的 <code>_num</code> 会隐藏基类的同名成员。</p> </li><li> <p>如果在派生类中尝试访问一个被隐藏的基类成员，需要显式地使用类名限定符来指定基类的成员。在 <code>Print</code> 方法中使用 <code>Person::_num</code> 来访问基类 <code>Person</code> 中的 <code>_num</code> 成员。</p> </li></ul> 
<p>输出结果将是：</p> 
<pre><code>姓名: a
身份证号: 111
学号: 999
</code></pre> 
<ol start="3"><li>需要注意的是如果是成员函数的隐藏，<mark>只需要函数名相同</mark>就构成隐藏</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func(int i)-&gt;"</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>B中的fun和A中的fun <mark>不是构成重载</mark>，因为不是在同一作用域<br> B中的fun和A中的fun <mark>构成隐藏</mark>，成员函数满足函数名相同就构成隐藏</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>  <span class="token comment">// 接受一个整型参数</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 编译器将会提示错误：找不到不带参数的 "fun" 函数。</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func(int i)-&gt;"</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>在这个代码中，试图调用基类 <code>A</code> 的 <code>fun</code> 函数。然而，由于派生类 <code>B</code> 提供了一个参数不同的版本 <code>fun(int)</code>，所以基类 <code>A</code> 中的 <code>fun</code> 函数在派生类 <code>B</code> 的作用域中被隐藏了。C++ 规则规定，如果派生类提供了和基类同名的函数，基类中同名的函数在派生类的作用域就不再可见了</p> 
<p>因此，在 <code>B</code> 类的成员函数 <code>fun(int)</code> 中，<strong>调用 <code>fun()</code> 试图无参数调用被隐藏的同名函数会无法编译，因为编译器认为我们试图调用 <code>fun(int)</code> 这个版本，但没有提供参数，导致参数不匹配</strong></p> 
<p><font color="red" size="5">修复</font></p> 
<p>为了调用基类 <code>A</code> 的 <code>fun</code> 函数，我们必须显式地使用作用域解析运算符 <code>::</code> 来指明我们想要调用的函数属于基类作用域：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 正确：调用基类 `A` 中的 `fun`</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func(int i)-&gt;"</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>这样，当我们在类 <code>B</code> 的 <code>fun(int i)</code> 函数中调用 <code>A::fun()</code> 时，它将成功地调用基类 <code>A</code> 无参数的 <code>fun</code> 函数，然后输出整型参数 <code>i</code> 的值。</p> 
<p>如果你希望在派生类中保留对基类中同名函数的访问能力（不希望隐藏），可以使用 <code>using</code> 声明在派生类中导入基类中的函数：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">using</span> A<span class="token double-colon punctuation">::</span>fun<span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 正确：由于 "using A::fun;"，此处调用的是基类 `A` 中的 `fun`</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func(int i)-&gt;"</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>在实际编程中，为了避免混淆，通常不建议在派生类中使用与基类成员同名的变量。</strong></p> 
<p>本节内容到此结束！感谢大家阅读！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8233f793e89ce03925c63a15fb362e50/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言/数据结构——每日一题（环形链表的约瑟夫问题）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4e55d04900a97c24a0d75cd8f1b57786/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">《Mask2Former》算法详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>