<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 算法篇-链表的经典算法：有序链表去重、合并多个有序链表 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/63dc3eec8534bf8cb0e00e35063fb7f2/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java 算法篇-链表的经典算法：有序链表去重、合并多个有序链表">
  <meta property="og:description" content="🔥博客主页： 【小扳_-CSDN博客】
❤感谢大家点赞👍收藏⭐评论✍ 文章目录
1.0 链表的说明
2.0 有序链表去重的实现方式
2.1 有序链表去重(保留重复的节点) - 使用递归来实现
2.2 有序链表去重(保留重复的节点) - 使用双指针来实现
2.3 有序链表去重(不保留重复的节点) - 使用递归来实现
2.4 有序链表去重(不保留重复的节点) - 使用三指针来实现
3.0 合并升序链表
3.1 合并升序链表(两个链表) - 迭代法
3.2 合并升序链表(两个链表) - 递归法
3.3 合并多个升序链表
4.0 实现有序链表去重、合并升序链表的完整代码
1.0 链表的说明 为了更好的讲解本篇当中的两种经典算法，先创建一个带哨兵的链表。链表是一种常见的数据结构，用于存储一系列元素。链表由一系列节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针。
代码如下：
import java.util.Iterator; public class List implements Iterable&lt;Integer&gt;{ private Node sentry; static class Node { public int value; public Node next; public Node(int value, Node next) { this.value = value; this.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-11-18T10:32:25+08:00">
    <meta property="article:modified_time" content="2023-11-18T10:32:25+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 算法篇-链表的经典算法：有序链表去重、合并多个有序链表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong>🔥博客主页： 【<strong><a href="https://blog.csdn.net/Tingfeng__?spm=1000.2115.3001.5343" title="小扳_-CSDN博客】">小扳_-CSDN博客】</a></strong><br> ❤感谢大家点赞👍收藏⭐评论✍</strong>   </p> 
</blockquote> 
<p style="text-align:center;"><img alt="" height="436" src="https://images2.imgbox.com/68/f3/oAjw7hpX_o.jpg" width="400"> </p> 
<p style="text-align:center;"> </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/65/22/dJ034cIP_o.gif"></p> 
<p id="main-toc"><strong>文章目录</strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20%E9%93%BE%E8%A1%A8%E7%9A%84%E8%AF%B4%E6%98%8E-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A02.0%20%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F" rel="nofollow">         </a><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20%E9%93%BE%E8%A1%A8%E7%9A%84%E8%AF%B4%E6%98%8E" rel="nofollow">1.0 链表的说明</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A02.0%20%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A02.0%20%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F" rel="nofollow">         2.0 有序链表去重的实现方式</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.1%20%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D(%E4%BF%9D%E7%95%99%E9%87%8D%E5%A4%8D%E7%9A%84%E8%8A%82%E7%82%B9)%20-%C2%A0%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E6%9D%A5%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.1%20%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D%28%E4%BF%9D%E7%95%99%E9%87%8D%E5%A4%8D%E7%9A%84%E8%8A%82%E7%82%B9%29%20-%C2%A0%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E6%9D%A5%E5%AE%9E%E7%8E%B0" rel="nofollow">        2.1 有序链表去重(保留重复的节点) - 使用递归来实现</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2%C2%A0%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D(%E4%BF%9D%E7%95%99%E9%87%8D%E5%A4%8D%E7%9A%84%E8%8A%82%E7%82%B9)%20-%C2%A0%E4%BD%BF%E7%94%A8%E5%8F%8C%E6%8C%87%E9%92%88%E6%9D%A5%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2%C2%A0%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D%28%E4%BF%9D%E7%95%99%E9%87%8D%E5%A4%8D%E7%9A%84%E8%8A%82%E7%82%B9%29%20-%C2%A0%E4%BD%BF%E7%94%A8%E5%8F%8C%E6%8C%87%E9%92%88%E6%9D%A5%E5%AE%9E%E7%8E%B0" rel="nofollow">        2.2 有序链表去重(保留重复的节点) - 使用双指针来实现</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.3%C2%A0%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D(%E4%B8%8D%E4%BF%9D%E7%95%99%E9%87%8D%E5%A4%8D%E7%9A%84%E8%8A%82%E7%82%B9)%20-%C2%A0%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E6%9D%A5%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.3%C2%A0%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D%28%E4%B8%8D%E4%BF%9D%E7%95%99%E9%87%8D%E5%A4%8D%E7%9A%84%E8%8A%82%E7%82%B9%29%20-%C2%A0%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E6%9D%A5%E5%AE%9E%E7%8E%B0" rel="nofollow">        2.3 有序链表去重(不保留重复的节点) - 使用递归来实现</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.4%C2%A0%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D(%E4%B8%8D%E4%BF%9D%E7%95%99%E9%87%8D%E5%A4%8D%E7%9A%84%E8%8A%82%E7%82%B9)%20-%C2%A0%E4%BD%BF%E7%94%A8%E4%B8%89%E6%8C%87%E9%92%88%E6%9D%A5%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.4%C2%A0%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D%28%E4%B8%8D%E4%BF%9D%E7%95%99%E9%87%8D%E5%A4%8D%E7%9A%84%E8%8A%82%E7%82%B9%29%20-%C2%A0%E4%BD%BF%E7%94%A8%E4%B8%89%E6%8C%87%E9%92%88%E6%9D%A5%E5%AE%9E%E7%8E%B0" rel="nofollow">        2.4 有序链表去重(不保留重复的节点) - 使用三指针来实现</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%20%E5%90%88%E5%B9%B6%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%20%E5%90%88%E5%B9%B6%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8" rel="nofollow">        3.0 合并升序链表</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1%C2%A0%E5%90%88%E5%B9%B6%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8(%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8)%C2%A0-%20%E8%BF%AD%E4%BB%A3%E6%B3%95-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1%C2%A0%E5%90%88%E5%B9%B6%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8%28%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%29%C2%A0-%20%E8%BF%AD%E4%BB%A3%E6%B3%95" rel="nofollow">        3.1 合并升序链表(两个链表) - 迭代法</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.2%C2%A0%E5%90%88%E5%B9%B6%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8(%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8)%C2%A0-%20%E9%80%92%E5%BD%92%E6%B3%95-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.2%C2%A0%E5%90%88%E5%B9%B6%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8%28%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%29%C2%A0-%20%E9%80%92%E5%BD%92%E6%B3%95" rel="nofollow">        3.2 合并升序链表(两个链表) - 递归法</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.3%20%E5%90%88%E5%B9%B6%E5%A4%9A%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.3%20%E5%90%88%E5%B9%B6%E5%A4%9A%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8" rel="nofollow">        3.3 合并多个升序链表</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.0%20%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D%E3%80%81%E5%90%88%E5%B9%B6%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%20%E5%90%88%E5%B9%B6%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8" rel="nofollow">        </a><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.0%20%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D%E3%80%81%E5%90%88%E5%B9%B6%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow">4.0 实现有序链表去重、合并升序链表的完整代码</a></strong></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20%E9%93%BE%E8%A1%A8%E7%9A%84%E8%AF%B4%E6%98%8E">        1.0 链表的说明</h2> 
<p>        <strong>为了更好的讲解本篇当中的两种经典算法，先创建一个带哨兵的链表。链表是一种常见的数据结构，用于存储一系列元素。<span style="color:#fe2c24;">链表由一系列节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针</span>。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">import java.util.Iterator;

public class List implements Iterable&lt;Integer&gt;{
    private  Node sentry;

    static class Node {
        public int value;
        public Node next;

        public Node(int value, Node next) {
            this.value = value;
            this.next = next;
        }
    }

    public List() {
        sentry = new Node(-1,null);
    }

    //头插节点
    public void addFirst(int value) {
        sentry.next = new Node(value,sentry.next);
    }

    //尾插节点
    public void addLast( int value) {
        Node temp = sentry;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.next = new Node(value,null);
    }

    //重写迭代器
    @Override
    public Iterator&lt;Integer&gt; iterator() {
        return new Iterator&lt;Integer&gt;() {
            Node p = sentry.next;
            @Override
            public boolean hasNext() {
                return p != null;
            }

            @Override
            public Integer next() {
                int value = p.value;
                p = p.next;
                return value;
            }
        };
    }

}</code></pre> 
 <p>        <strong>简单讲解一下，创建了一个链表类，该类中包含一个静态内部类，即节点类，还实现了一个基本的方法：头插节点、尾插节点、重写了迭代器等等。</strong></p> 
 <p><strong>需要了解的小伙伴<span style="color:#fe2c24;">可以点击该链接</span>：<span style="color:#fe2c24;"><a href="https://blog.csdn.net/Tingfeng__/article/details/134231658?spm=1001.2014.3001.5502" title="【Java 数据结构篇-实现单链表核心API-CSDN博客】">【Java 数据结构篇-实现单链表核心API-CSDN博客】</a></span></strong></p> 
</blockquote> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A02.0%20%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F" style="background-color:transparent;">         2.0 有序链表去重的实现方式</h2> 
<p>       <strong> 在此之前，需要分为两个方向：</strong></p> 
<p><strong>        一、<span style="color:#fe2c24;">需要保留重复值的节点</span></strong></p> 
<p><strong>        使用递归来实现有序链表的去重、使用双指针来实现有序链表的去重。</strong></p> 
<p><strong>        二、<span style="color:#fe2c24;">不需要保留重复值的节点</span></strong></p> 
<p><strong>        使用递归来实现有序链表的去重、使用三指针来实现有序链表的去重。</strong></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.1%20%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D(%E4%BF%9D%E7%95%99%E9%87%8D%E5%A4%8D%E7%9A%84%E8%8A%82%E7%82%B9)%20-%C2%A0%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E6%9D%A5%E5%AE%9E%E7%8E%B0" style="background-color:transparent;">        2.1 有序链表去重(保留重复的节点) - 使用递归来实现</h3> 
<p>        <strong>具体思路：<span style="color:#fe2c24;">先来考虑终止递出的条件为：p == null 或者 p.next == null ，对于 p == null 情况，当该链表为空链表时，直接返回 null ，对于 p.next == null 情况，当递出到最后只剩一个时，也没有必要继续下去了，不会再有重复的值的节点了。再来考虑递出的具体过程：当 p.value == p.next.value 的情况，就该忽略该节点，则需要返回下一个节点；当 p.value != p.next.value 的情况，就需要返回该节点，但是在返回之前，需要对 p.next 该节点的指向进行重整</span>。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //去重方法一(保留):递归
    public List removeRecursion(List list) {
        Node sentry1 = list.sentry;
        sentry = recursion1(sentry1);
        return list;
    }

    private Node recursion1(Node p) {

        if (p == null || p.next == null) {
            return p;
        }
        if (p.value == p.next.value) {
            return recursion1(p.next);
        }else {
            p.next = recursion1(p.next);
            return p;
        }

    }</code></pre> 
 <p><strong>        需要注意的是，先得判断链表对象是否为 null ，不然会空指针异常。</strong></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.2%C2%A0%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D(%E4%BF%9D%E7%95%99%E9%87%8D%E5%A4%8D%E7%9A%84%E8%8A%82%E7%82%B9)%20-%C2%A0%E4%BD%BF%E7%94%A8%E5%8F%8C%E6%8C%87%E9%92%88%E6%9D%A5%E5%AE%9E%E7%8E%B0" style="background-color:transparent;">        2.2 有序链表去重(保留重复的节点) - 使用双指针来实现</h3> 
<p>        <strong>具体思路：<span style="color:#fe2c24;">定义两个指针 n1 与 n2 ，对于 n1 来说：n1 一开始指向头节点，假如指向哨兵节点时，那么后续就会掺入了哨兵节点的值来比较，因此，n1 一开始时需要指向头节点。对于 n2 来说，n2 = n1.next ，也就是 n2 在 n1 指向的节点的前一个节点。接下来：当 n1.value == n2.value 时，则将 n1.next = n2.next ；当 n1.value != n2.value 时，则 n1 = n1.next</span> 。     </strong></p> 
<p><strong>        循环的条件为：<span style="color:#fe2c24;">(n2 = n1.next) != null</span> 。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //去重方法二(保留):双指针
    public List removeDoublePointer(List list) {
        if (list == null) {
            return null;
        }

        //少于两个节点，不存在重复的值
        if (list.sentry.next == null || list.sentry.next.next == null) {
            return null;
        }

        Node n1 = list.sentry.next;
        Node n2;

        while ((n2 = n1.next) != null) {

            if (n2.value == n1.value) {
                n1.next = n2.next;
            }else {
                n1 = n1.next;
            }
        }

        return list;
    }</code></pre> 
 <p>        <strong>需要注意的是，先得判断对象是否为 null ；还有一种情况，当节点少于两个时，不存在重复的值的节点。</strong></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.3%C2%A0%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D(%E4%B8%8D%E4%BF%9D%E7%95%99%E9%87%8D%E5%A4%8D%E7%9A%84%E8%8A%82%E7%82%B9)%20-%C2%A0%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E6%9D%A5%E5%AE%9E%E7%8E%B0">        2.3 有序链表去重(不保留重复的节点) - 使用递归来实现</h3> 
<p>        <strong>具体思路：<span style="color:#fe2c24;">先来考虑递出的终止条件为：当 p == null 或者 p.next == null 的情况时，直接返回 p 该节点，因为当 p.next == null 时，不存在有两个重复值的节点，因此就没有必要再继续递归下去了。再来考虑递出的两种情况：当 p.value != p.next.value 时，没有重复，则返回当前节点 p ，但是在此之前，需要对 p.next 重新赋值，即重新调整 p.next 的指向；当 p.value == p.next.vaule 时，存在重复，则将该值的节点全部找出来，直到找到最后一个节点。循环的条件为： p.value == p.next.value ，循环结束后，得到的 p 就是最后一个重复值的节点，因为不需要这个节点，则返回下一个节点</span>。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //去重方法一(不保留):递归
    public List removeRepeat(List list) {
        Node temp = list.sentry;
        sentry = recursion(temp);
        return list;
    }

    public Node recursion(Node p) {
        if (p == null || p.next == null) {
            return p;
        }

        if (p.value != p.next.value) {
            p.next = recursion(p.next);
            return p;
        }else {
            while (p.value == p.next.value) {
                p = p.next;
            }
            return recursion(p.next);
        }

    }</code></pre> 
 <p>        <strong>同样的，也需要先判断该对象是否为 null ，否则容易报异常。</strong></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.4%C2%A0%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D(%E4%B8%8D%E4%BF%9D%E7%95%99%E9%87%8D%E5%A4%8D%E7%9A%84%E8%8A%82%E7%82%B9)%20-%C2%A0%E4%BD%BF%E7%94%A8%E4%B8%89%E6%8C%87%E9%92%88%E6%9D%A5%E5%AE%9E%E7%8E%B0">        2.4 有序链表去重(不保留重复的节点) - 使用三指针来实现</h3> 
<p>        <strong>具体思路：先定义三个指针，<span style="color:#fe2c24;">对于 p1 来说： 一开始时指向哨兵节点，假如不实现哨兵节点，则删除不了当链表中前几个为重复值的节点(比如：1-&gt;1-&gt;1-&gt;2-&gt;null) ，因此，需要实现哨兵来完成该需求</span>；<span style="color:#fe2c24;">对与 p2 来说：一开始时指向头节点，即 p1.next；对于 p3 来说：一开始时指向头节点的下一个节点，即 p2.next </span>。接下来，对于循环的两种过程来分析：<span style="color:#fe2c24;">当 p2.value == p3.value 时，需要接着找到两个节点的值不相等的时候，所以内层循环条件为：p2.value == p3.value 且 p3 != null</span>，这里需要特别注意的是，千万不能丢了 p3 != null 的限制条件。跳出内层循环是，就可能意味着找到了，则将 p1.next = p3 ；当 p2.value != p3.value 时，直接 p1 = p1.next 即可。外层循环的条件为：（(p2 = p1.next) != null 且 (p3 = p2.next) != null）</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //去重方法二(不保留):三指针
    public List removeThreePointer(List list) {

        if (list == null) {
            return null;
        }

        Node n1 = list.sentry;
        Node n2 ;
        Node n3 ;
        while ((n2 = n1.next) != null &amp;&amp; (n3 = n2.next) != null) {
            if (n2.value == n3.value) {
                while (n3 != null &amp;&amp; n2.value == n3.value) {
                    n3 = n3.next;
                }
                n1.next = n3;
            }else {
                n1 = n1.next;
            }
        }
        return list;
    }</code></pre> 
 <p>        <strong>这里有个小技巧，对与 p2、p3 来说，不着急赋值，在判断条件的时候再进行赋值，可以简略代码量，提高可读性。</strong></p> 
</blockquote> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%20%E5%90%88%E5%B9%B6%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8" style="background-color:transparent;">        3.0 合并升序链表</h2> 
<p>       <strong> 分为两种情况：</strong></p> 
<p><strong>        一、合并两个升序链表</strong></p> 
<p><strong>        <span style="color:#fe2c24;">使用迭代法实现合并链表、使用递归实现合并链表</span></strong></p> 
<p><strong>        二、合并多个升序链表</strong></p> 
<p><strong>        <span style="color:#fe2c24;">合并多个升序链表就是一个个合并两个升序链表的情况，用递归来实现</span></strong></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1%C2%A0%E5%90%88%E5%B9%B6%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8(%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8)%C2%A0-%20%E8%BF%AD%E4%BB%A3%E6%B3%95">        3.1 合并升序链表(两个链表) - 迭代法</h3> 
<p>        <strong>具体思路：对于两个链表合并来说，在各自的链表中分别定义一个指针，分别指向各自的头节点。合并一条新的链表，定义一个指针指向哨兵节点。</strong></p> 
<blockquote> 
 <p class="img-center"><img alt="" height="427" src="https://images2.imgbox.com/3b/d5/ahUwrskL_o.png" width="892"></p> 
</blockquote> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    //合并升序链表
    public static List combinedList(List l1,List l2) {
        if (l1 == null &amp;&amp; l2 == null) {
            return null;
        } else if (l1 == null) {
            return l2;
        } else if (l2 == null) {
            return l1;
        }

        List newList = new List();
        Node node1 = l1.sentry.next;
        Node node2 = l2.sentry.next;
        Node p = newList.sentry;

        while (node1 != null &amp;&amp; node2 != null) {

            if (node1.value &lt; node2.value) {
                p.next = node1;
                node1 = node1.next;
            }else {
                p.next = node2;
                node2 = node2.next;
            }
            p = p.next;
        }

        if (node1 != null) {
            p.next = node1;
        }
        if (node2 != null) {
            p.next = node2;
        }
        return newList;
    }</code></pre> 
 <p>        </p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.2%C2%A0%E5%90%88%E5%B9%B6%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8(%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8)%C2%A0-%20%E9%80%92%E5%BD%92%E6%B3%95">        3.2 合并升序链表(两个链表) - 递归法</h3> 
<p>        <strong>具体思路：先来考虑递出的终止条件为：<span style="color:#fe2c24;">当 p1 == null 时，则直接返回 p2</span>；<span style="color:#fe2c24;">当 p2 == null 时，则直接返回 p1</span>。再来考虑递出的过程：<span style="color:#fe2c24;">当 p1.value &lt; p2.value 时，返回的节点为 p1 节点，在返回节点之前，需要将 p1.next 对该节点的重新调整指向下一个节点</span>；<span style="color:#fe2c24;">当 p1.value &gt;= p2.value 时，返回的节点为 p2 节点，同理，在返回该节点之前，需要将 p2.next 对该节点的重新调整指向下一个节点</span>。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">     private Node combineRecursion(Node p1, Node p2) {
        if (p1 == null) {
            return p2;
        } else if (p2 == null ) {
            return p1;
        }

        if (p1.value &lt; p2.value) {
            p1.next = combineRecursion(p1.next,p2);
            return p1;
        }else {
            p2.next = combineRecursion(p1,p2.next);
            return p2;
        }

     }</code></pre> 
 <p></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.3%20%E5%90%88%E5%B9%B6%E5%A4%9A%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8">        3.3 合并多个升序链表</h3> 
<p>        <strong>具体思路：这是一个多路递归，在每一次的递归过程中，都可以看成有两个升序链表进行来合并。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">     //实现多个升序链表合并
    public List moreCombine(Node[] nodes) {
        List list = new List();
        list.sentry.next = moreCombineRecursion(nodes,0, nodes.length-1);
        return list;
    }

    private Node moreCombineRecursion(Node[] nodes,int i,int j) {

        if (j == 1) {
            return nodes[i];
        }
        int mid = (i + j) &gt;&gt;&gt; 1;
        Node left = moreCombineRecursion(nodes,i,mid);
        Node right = moreCombineRecursion(nodes,mid+1,j);
        return combineRecursion(left,right);
    }</code></pre> 
 <p></p> 
</blockquote> 
<p><strong>举例画图分析：</strong></p> 
<blockquote> 
 <p class="img-center"><img alt="" height="186" src="https://images2.imgbox.com/3e/89/slXJQSJx_o.png" width="749"></p> 
</blockquote> 
<blockquote> 
 <p class="img-center"><img alt="" height="710" src="https://images2.imgbox.com/5d/ee/xEw2IM8m_o.png" width="1200"></p> 
</blockquote> 
<p>       <strong> 对以上的流程图简单分析：注意的是结束递出的条件为：<span style="color:#fe2c24;">i == j 结束递出，开始回归</span>。回归的是每一个链表的节点，最后集齐了两个链表，需要通过利用两个链表升序合并的返回进行合并，可以用<span style="color:#fe2c24;">迭代法</span>或者<span style="color:#fe2c24;">递归法</span>。这只是其中的一小部分，不过每一个过程都是一样的，就不多赘述了。</strong></p> 
<p> </p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.0%20%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D%E3%80%81%E5%90%88%E5%B9%B6%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" style="background-color:transparent;">        4.0 实现有序链表去重、合并升序链表的完整代码</h2> 
<blockquote> 
 <p> </p> 
 <pre><code class="language-java">import java.util.Iterator;

public class List implements Iterable&lt;Integer&gt;{
    private  Node sentry;

    static class Node {
        public int value;
        public Node next;

        public Node(int value, Node next) {
            this.value = value;
            this.next = next;
        }
    }

    public List() {
        sentry = new Node(-1,null);
    }

    //头插节点
    public void addFirst(int value) {
        sentry.next = new Node(value,sentry.next);
    }

    //尾插节点
    public void addLast( int value) {
        Node temp = sentry;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.next = new Node(value,null);
    }

    //重写迭代器
    @Override
    public Iterator&lt;Integer&gt; iterator() {
        return new Iterator&lt;Integer&gt;() {
            Node p = sentry.next;
            @Override
            public boolean hasNext() {
                return p != null;
            }

            @Override
            public Integer next() {
                int value = p.value;
                p = p.next;
                return value;
            }
        };
    }

    //去重方法二(保留):双指针
    public List removeDoublePointer(List list) {
        if (list == null) {
            return null;
        }

        //少于两个节点，不存在重复的值
        if (list.sentry.next == null || list.sentry.next.next == null) {
            return null;
        }

        Node n1 = list.sentry.next;
        Node n2;

        while ((n2 = n1.next) != null) {

            if (n2.value == n1.value) {
                n1.next = n2.next;
            }else {
                n1 = n1.next;
            }
        }

        return list;
    }


    //去重方法一(保留):递归
    public List removeRecursion(List list) {
        Node sentry1 = list.sentry;
        sentry = recursion1(sentry1);
        return list;
    }

    private Node recursion1(Node p) {

        if (p == null || p.next == null) {
            return p;
        }
        if (p.value == p.next.value) {
            return recursion1(p.next);
        }else {
            p.next = recursion1(p.next);
            return p;
        }

    }



    //去重方法一(不保留):递归
    public List removeRepeat(List list) {
        Node temp = list.sentry;
        sentry = recursion(temp);
        return list;
    }

    public Node recursion(Node p) {
        if (p == null || p.next == null) {
            return p;
        }

        if (p.value != p.next.value) {
            p.next = recursion(p.next);
            return p;
        }else {
            while (p.value == p.next.value) {
                p = p.next;
            }
            return recursion(p.next);
        }

    }


    //去重方法二(不保留):三指针
    public List removeThreePointer(List list) {

        if (list == null) {
            return null;
        }

        Node n1 = list.sentry;
        Node n2 ;
        Node n3 ;
        while ((n2 = n1.next) != null &amp;&amp; (n3 = n2.next) != null) {
            if (n2.value == n3.value) {
                while (n3 != null &amp;&amp; n2.value == n3.value) {
                    n3 = n3.next;
                }
                n1.next = n3;
            }else {
                n1 = n1.next;
            }
        }
        return list;
    }


    //合并升序链表
    public static List combinedList(List l1,List l2) {
        if (l1 == null &amp;&amp; l2 == null) {
            return null;
        } else if (l1 == null) {
            return l2;
        } else if (l2 == null) {
            return l1;
        }

        List newList = new List();
        Node node1 = l1.sentry.next;
        Node node2 = l2.sentry.next;
        Node p = newList.sentry;

        while (node1 != null &amp;&amp; node2 != null) {

            if (node1.value &lt; node2.value) {
                p.next = node1;
                node1 = node1.next;
            }else {
                p.next = node2;
                node2 = node2.next;
            }
            p = p.next;
        }

        if (node1 != null) {
            p.next = node1;
        }
        if (node2 != null) {
            p.next = node2;
        }
        return newList;
    }

    //合并链表:递归实现
    public List combineList(List list2) {
        List newList = new List();
        Node p1 = this.sentry.next;
        Node p2 = list2.sentry.next;
        Node p = combineRecursion(p1,p2);
        newList.sentry.next = p;
        return newList;
    }

     private Node combineRecursion(Node p1, Node p2) {
        if (p1 == null) {
            return p2;
        } else if (p2 == null ) {
            return p1;
        }

        if (p1.value &lt; p2.value) {
            p1.next = combineRecursion(p1.next,p2);
            return p1;
        }else {
            p2.next = combineRecursion(p1,p2.next);
            return p2;
        }

     }

     //实现多个升序链表合并
    public List moreCombine(Node[] nodes) {
        List list = new List();
        list.sentry.next = moreCombineRecursion(nodes,0, nodes.length-1);
        return list;
    }

    private Node moreCombineRecursion(Node[] nodes,int i,int j) {

        if (j == i) {
            return nodes[i];
        }
        int mid = (i + j) &gt;&gt;&gt; 1;
        Node left = moreCombineRecursion(nodes,i,mid);
        Node right = moreCombineRecursion(nodes,mid+1,j);
        return combineRecursion(left,right);
    }

}</code></pre> 
 <p></p> 
</blockquote> 
<p style="text-align:center;">         </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/14/e0/5vPy8oGd_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7d2d9d398160fddf4ea06f08bec2f1e4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【cpolar】Ubuntu本地快速搭建web小游戏网站，公网用户远程访问</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b2b961edaebc8513d1e4c19cf692de36/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JDK21下载&#43;安装&#43;环境配置教程(Windows系统)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>