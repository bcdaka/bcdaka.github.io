<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言内存操控的艺术探索：踏足四大秘境，铸就内存管理之巅峰传奇 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/2cb7bb20e971c99a911bbe4930912b12/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C语言内存操控的艺术探索：踏足四大秘境，铸就内存管理之巅峰传奇">
  <meta property="og:description" content="欢迎来到白刘的领域 Miracle_86.-CSDN博客 系列专栏 C语言知识 先赞后看，已成习惯 创作不易，多多支持！ 在C语言的内存管理领域，四大秘境之一的内存操作函数无疑为程序员提供了强大的工具。这些函数——memcpy、memmove、memset、memcmp——各自拥有独特的用途和特性，它们在内存操控中扮演着至关重要的角色。
目录
一、memcpy——内存的拷贝艺术
1.1 memcpy的使用
1.2 memcpy的模拟实现
1.3 重叠问题
二、memmove——内存的移动魔法
2.1 memmove的使用
2.2 memmove的模拟实现
三、memset——内存的初始化神器
四、memcmp——内存的比较之术
一、memcpy——内存的拷贝艺术 在前面我们讲了许多字符串函数：
C语言字符函数与字符串函数：编织文字的舞会之梦（上）-CSDN博客
C语言字符函数与字符串函数：编织文字的舞会之梦（下）-CSDN博客
其中我们发现strcpy和memcpy非常相似，我们了解了str代表字符串，cpy代表copy，也就是拷贝，那mem是什么呢？其实它是memory的简写，memory我们都知道是记忆的意思，而它还有一个意思——内存。可以简单理解为计算机的记忆，那不就是内存嘛。那我们可以推断出来，memcpy，它的作用是用来拷贝内存的。
1.1 memcpy的使用 它的原型如下：
void* memcpy(void* destination, const void* source, size_t num); 不难看出，它和strncpy的参数是一模一样的，没错，正是如此，只不过它可以copy任意类型的，而strncpy只能拷贝字符串。
1.原理：memcpy从source的位置开始，向后复制num个字节，到destination指向的内存的位置。
2.与strncpy不同的是，mem在遇到&#39;\0&#39;时不会停止。
3.使用需要包含头文件&lt;string.h&gt;。
#include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { int arr1[] = { 1,2,3,4,5,6,7,8,9,10 }; int arr2[10] = { 0 }; memcpy(arr2, arr1, 20); int i = 0; for (i = 0; i &lt; 10; i&#43;&#43;) { printf(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-24T20:03:17+08:00">
    <meta property="article:modified_time" content="2024-04-24T20:03:17+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言内存操控的艺术探索：踏足四大秘境，铸就内存管理之巅峰传奇</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 id="%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E7%99%BD%E5%88%98%E7%9A%84%E9%A2%86%E5%9F%9F%C2%A0%20%C2%A0Miracle_86.-CSDN%E5%8D%9A%E5%AE%A2" style="text-align:center;"><strong><span style="color:#38d8f0;">欢迎来到白刘的领域 </span>  </strong><a href="https://blog.csdn.net/Miracle_86?type=blog" title="Miracle_86.-CSDN博客">Miracle_86.-CSDN博客</a></h4> 
<h4 id="%E7%B3%BB%E5%88%97%E4%B8%93%E6%A0%8F%C2%A0%C2%A0C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86" style="text-align:center;"><strong><span style="color:#ff9900;">系列专栏</span>  </strong><a href="https://blog.csdn.net/miracle_86/category_12537212.html?spm=1001.2014.3001.5482" title="C语言知识">C语言知识</a></h4> 
<h4 id="%E5%85%88%E8%B5%9E%E5%90%8E%E7%9C%8B%EF%BC%8C%E5%B7%B2%E6%88%90%E4%B9%A0%E6%83%AF" style="text-align:center;"><span style="color:#a2e043;"><strong>先赞后看，已成习惯</strong></span></h4> 
<h4 id="%C2%A0%20%C2%A0%E5%88%9B%E4%BD%9C%E4%B8%8D%E6%98%93%EF%BC%8C%E5%A4%9A%E5%A4%9A%E6%94%AF%E6%8C%81%EF%BC%81" style="text-align:center;"><span style="color:#956fe7;">   创作不易，多多支持！</span></h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/4a/d5/fbFLNzNn_o.gif"></p> 
<p>在C语言的内存管理领域，四大秘境之一的内存操作函数无疑为程序员提供了强大的工具。这些函数——memcpy、memmove、memset、memcmp——各自拥有独特的用途和特性，它们在内存操控中扮演着至关重要的角色。</p> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81memcpy%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%9A%84%E6%8B%B7%E8%B4%9D%E8%89%BA%E6%9C%AF-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81memcpy%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%9A%84%E6%8B%B7%E8%B4%9D%E8%89%BA%E6%9C%AF" rel="nofollow">一、memcpy——内存的拷贝艺术</a></p> 
<p id="1.1%20memcpy%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#1.1%20memcpy%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">1.1 memcpy的使用</a></p> 
<p id="1.2%20memcpy%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#1.2%20memcpy%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow">1.2 memcpy的模拟实现</a></p> 
<p id="1.3%20%E9%87%8D%E5%8F%A0%E9%97%AE%E9%A2%98-toc" style="margin-left:80px;"><a href="#1.3%20%E9%87%8D%E5%8F%A0%E9%97%AE%E9%A2%98" rel="nofollow">1.3 重叠问题</a></p> 
<p id="%E4%BA%8C%E3%80%81memmove%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81memmove%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow">二、memmove——内存的移动魔法</a></p> 
<p id="2.1%20memmove%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#2.1%20memmove%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">2.1 memmove的使用</a></p> 
<p id="2.2%20memmove%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#2.2%20memmove%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow">2.2 memmove的模拟实现</a></p> 
<p id="%C2%A0%E4%B8%89%E3%80%81memset%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#%C2%A0%E4%B8%89%E3%80%81memset%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow"> 三、memset——内存的初始化神器</a></p> 
<p id="%C2%A0%E5%9B%9B%E3%80%81memcmp%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#%C2%A0%E5%9B%9B%E3%80%81memcmp%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow"> 四、memcmp——内存的比较之术</a></p> 
<hr> 
<h3 id="%E4%B8%80%E3%80%81memcpy%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%9A%84%E6%8B%B7%E8%B4%9D%E8%89%BA%E6%9C%AF">一、memcpy——<strong>内存的拷贝艺术</strong></h3> 
<p>在前面我们讲了许多字符串函数：</p> 
<blockquote> 
 <p><a href="https://blog.csdn.net/Miracle_86/article/details/136880597?spm=1001.2014.3001.5501" title="C语言字符函数与字符串函数：编织文字的舞会之梦（上）-CSDN博客">C语言字符函数与字符串函数：编织文字的舞会之梦（上）-CSDN博客</a></p> 
 <p><a href="https://blog.csdn.net/Miracle_86/article/details/136937364?spm=1001.2014.3001.5501" title="C语言字符函数与字符串函数：编织文字的舞会之梦（下）-CSDN博客">C语言字符函数与字符串函数：编织文字的舞会之梦（下）-CSDN博客</a></p> 
</blockquote> 
<p>其中我们发现<strong>strcpy</strong>和<strong>memcpy</strong>非常相似，我们了解了str代表字符串，cpy代表copy，也就是拷贝，那mem是什么呢？其实它是memory的简写，memory我们都知道是记忆的意思，而它还有一个意思——<strong>内存。</strong>可以简单理解为计算机的记忆，那不就是内存嘛。那我们可以推断出来，memcpy，它的作用是用来<strong>拷贝内存</strong>的。</p> 
<h4 id="1.1%20memcpy%E7%9A%84%E4%BD%BF%E7%94%A8">1.1 memcpy的使用</h4> 
<p>它的原型如下：</p> 
<pre><code class="language-cpp">void* memcpy(void* destination, const void* source, size_t num);</code></pre> 
<p>不难看出，它和strncpy的参数是一模一样的，没错，正是如此，只不过它可以copy任意类型的，而strncpy只能拷贝字符串。</p> 
<blockquote> 
 <p>1.原理：memcpy从source的位置开始，向后复制num个字节，到destination指向的内存的位置。</p> 
 <p>2.与strncpy不同的是，mem在遇到'\0'时不会停止。</p> 
 <p>3.使用需要包含头文件<strong>&lt;string.h&gt;。</strong></p> 
</blockquote> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main()
{
	int arr1[] = { 1,2,3,4,5,6,7,8,9,10 };
	int arr2[10] = { 0 };
	memcpy(arr2, arr1, 20);
	int i = 0;
	for (i = 0; i &lt; 10; i++)
	{
		printf("%d ", arr2[i]);
	}
	return 0;
}</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="128" src="https://images2.imgbox.com/62/7c/goisJBlY_o.png" width="383"></p> 
<h4 id="1.2%20memcpy%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">1.2 memcpy的模拟实现</h4> 
<p>聊完它的基本原理以及使用后，我们再来看看它的模拟实现。</p> 
<p>首先通过参数来看，我们传进去一个目的地，一个源头，还有字节数，那我可以这么写：</p> 
<pre><code class="language-cpp">void* memcpy(void* dst, const void* src, size_t count)</code></pre> 
<p>接下来我们可以使用循环，次数为count，由于count是字节数，所以我们这里一个字节一个字节进行拷贝会比较容易操作。而void*类型的指针不可以解引用，我们需要进行强制类型转换，将其转换成char*，代码如下：</p> 
<pre><code class="language-cpp">void* memcpy(void* dst, const void* src, size_t count)
{
	void* ret = dst;
	assert(dst);
	assert(src);
	/*
	* copy from lower addresses to higher addresses
	*/
	while (count--) {
		*(char*)dst = *(char*)src;
		dst = (char*)dst + 1;
		src = (char*)src + 1;
	}
	return(ret);
}</code></pre> 
<p> 这里返回ret（目标空间的首元素地址）是因为在memcpy中返回的也是这个：</p> 
<p><img alt="" height="625" src="https://images2.imgbox.com/c9/5e/MMymsNjV_o.png" width="959"></p> 
<p>但是问题出现了，如果目标空间和源头重叠了怎么办？ </p> 
<h4 id="1.3%20%E9%87%8D%E5%8F%A0%E9%97%AE%E9%A2%98">1.3 重叠问题</h4> 
<p>我们来看下面一段代码：</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include&lt;assert.h&gt;
void* my_memcpy(void* dst, const void* src, size_t count)
{
	void* ret = dst;
	assert(dst);
	assert(src);
	/*
	* copy from lower addresses to higher addresses
	*/
	while (count--) {
		*(char*)dst = *(char*)src;
		dst = (char*)dst + 1;
		src = (char*)src + 1;
	}
	return(ret);
}
int main()
{
	int arr1[] = { 1,2,3,4,5,6,7,8,9,10 };
	int arr2[10] = { 0 };
	my_memcpy(arr1+2, arr1, 20);
	int i = 0;
	for (i = 0; i &lt; 10; i++)
	{
		printf("%d ", arr1[i]);
	}
	return 0;
}</code></pre> 
<p>我们可以看到目标空间与源头有重叠的部分，本来我们想把1,2,3,4,5拷贝到3,4,5,6,7的位置。</p> 
<p>预期结果：1，2，1，2，3，4，5，8，9，10 </p> 
<p>实际结果：<img alt="" height="139" src="https://images2.imgbox.com/c6/4f/TfnihDaB_o.png" width="347"></p> 
<p>这是为什么呢？这是因为在拷贝3的时候，3的位置已经是1了，3被覆盖掉了，其他的同理。这可怎么办呢？其实memcpy它被设计出来就是为了拷贝不重叠的情况的，如果它拷贝到重叠的部分，结果都是未定义的。那我们就没办法完成拷贝重叠部分了嘛？别着急，下面这个函数就可以解决这个问题。</p> 
<h3 id="%E4%BA%8C%E3%80%81memmove%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">二、memmove——<strong>内存的移动魔法</strong></h3> 
<p>memmove和memcpy几乎是一模一样的，<strong>唯一的差别</strong>就是它<strong>可以处理重叠</strong>的源内存块和目标内存块。</p> 
<h4 id="2.1%20memmove%E7%9A%84%E4%BD%BF%E7%94%A8">2.1 memmove的使用</h4> 
<pre><code class="language-cpp">void* memmove(void* destination, const void* source, size_t num);</code></pre> 
<p>来看刚刚的问题的代码解决：</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main()
{
	int arr1[] = { 1,2,3,4,5,6,7,8,9,10 };
	memmove(arr1 + 2, arr1, 20);
	int i = 0;
	for (i = 0; i &lt; 10; i++)
	{
		printf("%d ", arr1[i]);
	}
	return 0;
}</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="145" src="https://images2.imgbox.com/fe/47/64xdA9JN_o.png" width="403"></p> 
<p>它是怎么实现的呢？我们试着来模拟一下。</p> 
<h4 id="2.2%20memmove%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">2.2 memmove的模拟实现</h4> 
<p>我们先来画图解析一下：</p> 
<p><img alt="" height="195" src="https://images2.imgbox.com/71/c1/Nz6lYRI5_o.png" width="308"></p> 
<p>我们正常来讲是将1拷贝到3,2拷贝到4，是正着拷的。那如果我们反过来，先把5拷过去，倒着拷是不是就避免了被重叠覆盖的情况了。</p> 
<p>这里有的人就耍小聪明了，就喜欢死记硬背了，正着拷不行，那就都倒着拷。</p> 
<p>那再来看这张图：</p> 
<p><img alt="" height="185" src="https://images2.imgbox.com/14/cc/piXll135_o.png" width="282"></p> 
<p>如果我还是倒着拷的话，还是会覆盖。</p> 
<blockquote> 
 <p>所以我们得到了一个结论：<strong>当dest在src左面时，从前向后拷（正着拷）；当dest在src右面时，从后向前拷（倒着拷）。</strong></p> 
</blockquote> 
<p>当你不理解的时候，画个图自己捋一下就好了。</p> 
<p>思路有了，我们来看代码：</p> 
<pre><code class="language-cpp">void* memmove(void* dst, const void* src, size_t count)
{
	void* ret = dst;
	if (dst &lt;= src || (char*)dst &gt;= ((char*)src + count)) {

		//正着拷形式如同memcpy

		while (count--) {
			*(char*)dst = *(char*)src;
			dst = (char*)dst + 1;
			src = (char*)src + 1;
		}
	}
	else {
		
        //倒着拷将首元素地址+字节数再-1即可指向最后一个字节。

		dst = (char*)dst + count - 1;
		src = (char*)src + count - 1;
		while (count--) {
			*(char*)dst = *(char*)src;
			dst = (char*)dst - 1;
			src = (char*)src - 1;
		}
	}
	return(ret);
}</code></pre> 
<h3 id="%C2%A0%E4%B8%89%E3%80%81memset%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"> 三、memset——<strong>内存的初始化神器</strong></h3> 
<p>从名字上来看，set译为设置，那这个函数的作用大概率是设置内存的。</p> 
<pre><code class="language-cpp">void* memset(void* ptr, int value, size_t num);</code></pre> 
<p><img alt="" height="474" src="https://images2.imgbox.com/c3/9f/BdR4PaLT_o.png" width="941"></p> 
<blockquote> 
 <p>首先来看它的三个参数：</p> 
 <p>1.ptr：一个void*类型的指针，指向要被填充的内存块。</p> 
 <p>2.value：要设置的值。</p> 
 <p>3.num：字节的个数（设置多少个value的值，以字节为单位）</p> 
 <p>也就是说<span style="color:#1f2329;">memset是⽤来设置内存的，将内存中的值以字节为单位设置成想要的内容。 </span></p> 
 <p><span style="color:#1f2329;"> </span></p> 
 <p><span style="color:#1f2329;">它包含在头文件<strong>&lt;string.h&gt;</strong>中。</span></p> 
</blockquote> 
<p> 因此memset经常被用来写游戏外挂。</p> 
<p>我们来看代码实例：</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main ()
{
 char str[] = "hello world";
 memset (str,'x',6);
 printf(str);
 return 0;
}</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="150" src="https://images2.imgbox.com/f4/43/oumH09fG_o.png" width="329"></p> 
<blockquote> 
 <p><strong>切记：memset以字节为单位设置，若用于数组中，绝不是以元素为单位！！</strong></p> 
</blockquote> 
<h3 id="%C2%A0%E5%9B%9B%E3%80%81memcmp%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"> 四、memcmp——<strong>内存的比较之术</strong></h3> 
<p>经过这么多次的学习，我们已经对mem和cmp非常熟悉了，一个是内存，一个是比较。显然这个函数是用来<strong>比较两个内存块</strong>的大小的。</p> 
<pre><code class="language-cpp">int memcmp(const void* ptr1, const void* ptr2, size_t num);</code></pre> 
<blockquote> 
 <div> 
  <span style="color:#1f2329;">原理：⽐较从ptr1和ptr2指针指向的位置开始，向后的num个字节</span> 
 </div> 
</blockquote> 
<p>返回值如下：</p> 
<p><img alt="" height="168" src="https://images2.imgbox.com/aa/95/B7pqeJtQ_o.png" width="712"> 其实和strcmp相类似。</p> 
<p>代码示例：</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main()
{
	char buffer1[] = "DWgaOtP12df0";
	char buffer2[] = "DWGAOTP12DF0";
	int n;
	n = memcmp(buffer1, buffer2, sizeof(buffer1));
	if (n &gt; 0)
		printf("'%s' is greater than '%s'.\n", buffer1, buffer2);
	else if (n &lt; 0)
		printf("'%s' is less than '%s'.\n", buffer1, buffer2);
	else
		printf("'%s' is the same as '%s'.\n", buffer1, buffer2);
	return 0;
}</code></pre> 
<p>来看运行结果：</p> 
<p><img alt="" height="182" src="https://images2.imgbox.com/b6/f0/w130pIpi_o.png" width="577"></p> 
<hr> 
<p>完</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4003066dd9fe397f9959f46f91f4ef68/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">polarctf靶场 【web】签到题、简单 rce、蜜雪冰城吉警店、到底给不给flag呢</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/806907b1b088d8ac707141e357dace64/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于Java的物联网云平台完整源码及功能模块解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>