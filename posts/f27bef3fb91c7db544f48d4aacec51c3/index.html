<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构(6_2_3)——十字链表法和多重领接表 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f27bef3fb91c7db544f48d4aacec51c3/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构(6_2_3)——十字链表法和多重领接表">
  <meta property="og:description" content="十字链表存储有向图 橙色入度，绿色出度
代码示例：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; // 定义十字链表节点结构体 typedef struct OLNode { int row; // 行号 int col; // 列号 int value; // 节点值 struct OLNode* right; // 指向右边节点的指针 struct OLNode* down; // 指向下方节点的指针 } OLNode, * OLink; // 定义十字链表的头节点结构体 typedef struct { OLink* row_head; // 行表头指针数组 OLink* col_head; // 列表头指针数组 int m, n, len; // 矩阵的行数、列数和非零元素的个数 } CrossList; // 创建十字链表 CrossList CreateCrossList(int m, int n) { CrossList M; M.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-20T12:14:20+08:00">
    <meta property="article:modified_time" content="2024-08-20T12:14:20+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构(6_2_3)——十字链表法和多重领接表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>十字链表存储有向图</h2> 
<p>橙色入度，绿色出度</p> 
<p><img alt="" height="836" src="https://images2.imgbox.com/28/de/BU3roLsU_o.png" width="1200"></p> 
<p> 代码示例：</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// 定义十字链表节点结构体
typedef struct OLNode {
    int row;         // 行号
    int col;         // 列号
    int value;       // 节点值
    struct OLNode* right; // 指向右边节点的指针
    struct OLNode* down;  // 指向下方节点的指针
} OLNode, * OLink;

// 定义十字链表的头节点结构体
typedef struct {
    OLink* row_head; // 行表头指针数组
    OLink* col_head; // 列表头指针数组
    int m, n, len;   // 矩阵的行数、列数和非零元素的个数
} CrossList;
// 创建十字链表
CrossList CreateCrossList(int m, int n) {
    CrossList M;
    M.m = m;
    M.n = n;
    M.len = 0;

    // 初始化行和列的头指针数组
    M.row_head = (OLink*)malloc((m + 1) * sizeof(OLink));
    M.col_head = (OLink*)malloc((n + 1) * sizeof(OLink));
    if (!M.row_head || !M.col_head) {
        exit(1); // 内存分配失败
    }

    for (int i = 1; i &lt;= m; i++) {
        M.row_head[i] = NULL;
    }
    for (int j = 1; j &lt;= n; j++) {
        M.col_head[j] = NULL;
    }

    return M;
}
// 向十字链表插入元素
void Insert(CrossList* M, int i, int j, int value) {
    if (i &gt; M-&gt;m || j &gt; M-&gt;n || value == 0) {
        return; // 插入位置不合法或值为0
    }

    // 创建新节点
    OLNode* newNode = (OLNode*)malloc(sizeof(OLNode));
    newNode-&gt;row = i;
    newNode-&gt;col = j;
    newNode-&gt;value = value;
    newNode-&gt;right = NULL;
    newNode-&gt;down = NULL;

    // 插入行
    if (M-&gt;row_head[i] == NULL) {
        M-&gt;row_head[i] = newNode;
    }
    else {
        OLNode* current = M-&gt;row_head[i];
        while (current-&gt;right &amp;&amp; current-&gt;right-&gt;col &lt; j) {
            current = current-&gt;right;
        }
        newNode-&gt;right = current-&gt;right;
        current-&gt;right = newNode;
    }

    // 插入列
    if (M-&gt;col_head[j] == NULL) {
        M-&gt;col_head[j] = newNode;
    }
    else {
        OLNode* current = M-&gt;col_head[j];
        while (current-&gt;down &amp;&amp; current-&gt;down-&gt;row &lt; i) {
            current = current-&gt;down;
        }
        newNode-&gt;down = current-&gt;down;
        current-&gt;down = newNode;
    }

    M-&gt;len++; // 更新非零元素个数
}
// 从十字链表删除元素
void Delete(CrossList* M, int i, int j) {
    if (i &gt; M-&gt;m || j &gt; M-&gt;n) {
        return; // 位置不合法
    }

    // 查找要删除的节点
    OLNode* p = M-&gt;row_head[i];
    while (p &amp;&amp; p-&gt;col &lt; j) {
        p = p-&gt;right;
    }

    if (p &amp;&amp; p-&gt;col == j) {
        // 删除行中的节点
        if (p == M-&gt;row_head[i]) {
            M-&gt;row_head[i] = p-&gt;right;
        }
        else {
            OLNode* q = M-&gt;row_head[i];
            while (q-&gt;right != p) {
                q = q-&gt;right;
            }
            q-&gt;right = p-&gt;right;
        }

        // 删除列中的节点
        if (p == M-&gt;col_head[j]) {
            M-&gt;col_head[j] = p-&gt;down;
        }
        else {
            OLNode* q = M-&gt;col_head[j];
            while (q-&gt;down != p) {
                q = q-&gt;down;
            }
            q-&gt;down = p-&gt;down;
        }

        free(p); // 释放节点内存
        M-&gt;len--; // 更新非零元素个数
    }
}
// 在十字链表中查找元素
OLNode* Find(CrossList M, int i, int j) {
    if (i &gt; M.m || j &gt; M.n) {
        return NULL; // 位置不合法
    }

    OLNode* p = M.row_head[i];
    while (p &amp;&amp; p-&gt;col &lt; j) {
        p = p-&gt;right;
    }

    if (p &amp;&amp; p-&gt;col == j) {
        return p; // 找到元素，返回节点指针
    }
    else {
        return NULL; // 未找到元素
    }
}
// 打印十字链表
void PrintCrossList(CrossList M) {
    printf("十字链表如下：\n");
    for (int i = 1; i &lt;= M.m; i++) {
        OLNode* p = M.row_head[i];
        while (p) {
            printf("(%d, %d, %d) ", p-&gt;row, p-&gt;col, p-&gt;value);
            p = p-&gt;right;
        }
        printf("\n");
    }
}
// 释放十字链表
void FreeCrossList(CrossList* M) {
    for (int i = 1; i &lt;= M-&gt;m; i++) {
        OLNode* p = M-&gt;row_head[i];
        while (p) {
            OLNode* q = p;
            p = p-&gt;right;
            free(q);
        }
    }
    free(M-&gt;row_head);
    free(M-&gt;col_head);
}
int main() {
    int m = 3, n = 4; // 定义一个3行4列的稀疏矩阵
    CrossList M = CreateCrossList(m, n); // 创建十字链表

    // 插入元素
    Insert(&amp;M, 1, 2, 12);
    Insert(&amp;M, 1, 4, 9);
    Insert(&amp;M, 3, 1, -3);
    Insert(&amp;M, 3, 3, 14);

    // 打印十字链表
    PrintCrossList(M);

    // 删除元素
    Delete(&amp;M, 1, 2);

    // 再次打印十字链表
    printf("删除元素后的十字链表：\n");
    PrintCrossList(M);

    // 释放十字链表
    FreeCrossList(&amp;M);

    return 0;
}

</code></pre> 
<h2> 十字链表法性能分析</h2> 
<p><img alt="" height="798" src="https://images2.imgbox.com/9f/96/u0BiRJ8G_o.png" width="1200"></p> 
<p> </p> 
<h2>领接矩阵、邻接表存储无向图的缺点</h2> 
<p><img alt="" height="763" src="https://images2.imgbox.com/6c/3b/ukR0nnuh_o.png" width="1200"></p> 
<h2>邻接多重表存储无向图 </h2> 
<p>优点：</p> 
<p>每一条边只对应一个边结点，没有冗余数据，删除结点或者删除边的时候会方便很多</p> 
<p><img alt="" height="888" src="https://images2.imgbox.com/fd/b3/HGD8Mqrb_o.png" width="1200"></p> 
<p><img alt="" height="803" src="https://images2.imgbox.com/1a/d4/p70TFlIg_o.png" width="1200"> </p> 
<p> 代码示例：</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// 定义邻接多重表的边节点结构体
typedef struct EdgeNode {
    int ivex;            // 边的起点
    int jvex;            // 边的终点
    struct EdgeNode* ilink; // 指向起点相同的下一条边
    struct EdgeNode* jlink; // 指向终点相同的下一条边
    int mark;            // 标记边是否被访问过
} EdgeNode;

// 定义邻接多重表的顶点节点结构体
typedef struct VertexNode {
    int data;            // 顶点数据
    EdgeNode* firstedge; // 指向第一条依附于该顶点的边
} VertexNode;

// 定义邻接多重表结构体
typedef struct {
    VertexNode* vertices; // 顶点表
    int vexnum, edgenum;  // 顶点数和边数
}AMLGraph;
// 创建邻接多重表
AMLGraph CreateAMLGraph(int vexnum, int edgenum) {
    AMLGraph graph;
    graph.vexnum = vexnum;
    graph.edgenum = edgenum;

    // 初始化顶点表
    graph.vertices = (VertexNode*)malloc(vexnum * sizeof(VertexNode));
    if (!graph.vertices) {
        exit(1); // 内存分配失败
    }

    for (int i = 0; i &lt; vexnum; i++) {
        graph.vertices[i].data = i;
        graph.vertices[i].firstedge = NULL;
    }

    return graph;
}
// 插入边
void InsertEdge(AMLGraph* graph, int ivex, int jvex) {
    // 创建边节点
    EdgeNode* newEdge = (EdgeNode*)malloc(sizeof(EdgeNode));
    newEdge-&gt;ivex = ivex;
    newEdge-&gt;jvex = jvex;
    newEdge-&gt;ilink = graph-&gt;vertices[ivex].firstedge;
    newEdge-&gt;jlink = graph-&gt;vertices[jvex].firstedge;
    newEdge-&gt;mark = 0;

    // 插入到顶点ivex的边表
    graph-&gt;vertices[ivex].firstedge = newEdge;

    // 插入到顶点jvex的边表
    graph-&gt;vertices[jvex].firstedge = newEdge;
}
// 删除边
void DeleteEdge(AMLGraph* graph, int ivex, int jvex) {
    EdgeNode* p = graph-&gt;vertices[ivex].firstedge;
    EdgeNode* pre = NULL;

    while (p &amp;&amp; (p-&gt;ivex != ivex || p-&gt;jvex != jvex)) {
        pre = p;
        if (p-&gt;ivex == ivex) {
            p = p-&gt;ilink;
        }
        else {
            p = p-&gt;jlink;
        }
    }

    if (p) {
        if (pre) {
            if (p-&gt;ivex == ivex) {
                pre-&gt;ilink = p-&gt;ilink;
            }
            else {
                pre-&gt;jlink = p-&gt;jlink;
            }
        }
        else {
            if (p-&gt;ivex == ivex) {
                graph-&gt;vertices[ivex].firstedge = p-&gt;ilink;
            }
            else {
                graph-&gt;vertices[jvex].firstedge = p-&gt;jlink;
            }
        }
        free(p);
    }
}
// 查找顶点
VertexNode* FindVertex(AMLGraph graph, int data) {
    for (int i = 0; i &lt; graph.vexnum; i++) {
        if (graph.vertices[i].data == data) {
            return &amp;graph.vertices[i];
        }
    }
    return NULL;
}
// 打印邻接多重表
void PrintAMLGraph(AMLGraph graph) {
    printf("邻接多重表如下：\n");
    for (int i = 0; i &lt; graph.vexnum; i++) {
        EdgeNode* p = graph.vertices[i].firstedge;
        while (p) {
            int ivex = p-&gt;ivex;
            printf("(%d, %d) ", ivex, jvex);
            // 根据当前顶点，决定移动到ilink还是jlink
            if (ivex == i) {
                p = p-&gt;ilink;
            }
            else {
                p = p-&gt;jlink;
            }
        }
        printf("\n");
    }
}
// 释放邻接多重表
void FreeAMLGraph(AMLGraph* graph) {
    for (int i = 0; i &lt; graph-&gt;vexnum; i++) {
        EdgeNode* p = graph-&gt;vertices[i].firstedge;
        while (p) {
            EdgeNode* q = p;
            p = p-&gt;ilink;
            free(q);
        }
    }
    free(graph-&gt;vertices);
}
int main() {
    int vexnum = 4; // 定义顶点数为4
    int edgenum = 5; // 定义边数为5
    AMLGraph graph = CreateAMLGraph(vexnum, edgenum); // 创建邻接多重表

    // 插入边
    InsertEdge(&amp;graph, 0, 1);
    InsertEdge(&amp;graph, 0, 2);
    InsertEdge(&amp;graph, 1, 2);
    InsertEdge(&amp;graph, 1, 3);
    InsertEdge(&amp;graph, 2, 3);

    // 打印邻接多重表
    PrintAMLGraph(graph);

    // 删除边
    DeleteEdge(&amp;graph, 1, 2);

    // 再次打印邻接多重表
    printf("删除边后的邻接多重表：\n");
    PrintAMLGraph(graph);

    // 释放邻接多重表
    FreeAMLGraph(&amp;graph);

    return 0;
}

</code></pre> 
<h2><br> 总结：</h2> 
<p><img alt="" height="823" src="https://images2.imgbox.com/2d/83/3imORhon_o.png" width="1200"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8881026da2caf97516946745822de2b0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">The First项目报告：全方位解析链游生态平台Matr1x</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9afaa42ee469416cdc540a9da5bbc75a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ZooKeeper的8大应用场景解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>