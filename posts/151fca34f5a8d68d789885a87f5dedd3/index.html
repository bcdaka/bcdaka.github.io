<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java多线线程-----等待唤醒机制(wait notify) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/151fca34f5a8d68d789885a87f5dedd3/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java多线线程-----等待唤醒机制(wait notify)">
  <meta property="og:description" content="目录
一.等待唤醒机制简介：
二.synchronized,wait(),notify():
三.等待唤醒机制案例:
例题一：
例题二：
四.什么时候释放锁—wait（）、notify（）
一.等待唤醒机制简介： 由于线程之间是抢占式执行的，因此线程的执行顺序难以预知。但是实际开发中有时候我们希望合理的协调多个线程之间的执行先后顺序。为了完成协调的工作，这里主要设计三个方法：
wait() / wait(long timeout) : 让当前线程进入等待状态
notify() / notifyAll(): 唤醒在当前对象上等待的线程
注意：wait,notify,notifyAll都是Object类的方法
二.synchronized,wait(),notify(): synchronized 的含义： Java中每一个对象都可以成为一个监视器（Monitor）, 该Monitor由一个锁（lock）, 一个等待队列（waiting queue ）, 一个入口队列( entry queue).
对于一个对象的方法， 如果没有synchronized关键字， 该方法可以被任意数量的线程，在任意时刻调用。
对于添加了synchronized关键字的方法，任意时刻只能被唯一的一个获得了对象实例锁的线程调用。
synchronized用于实现多线程的同步操作
wait()功能： wait(), notify(), notifyAll() 和 synchonized 需要搭配使用， 用于线程同步
wait()总是在一个循;环中被调用，挂起当前线程来等待一个条件的成立。 Wait调用会一直等到其他线程调用notifyAll()时才返回。
当一个线程在执行synchronized 的方法内部，调用了wait()后， 该线程会释放该对象的锁， 然后该线程会被添加到该对象的等待队列中（waiting queue）, 只要该线程在等待队列中， 就会一直处于闲置状态， 不会被调度执行。 要注意wait()方法会强迫线程先进行释放锁操作，所以在调用wait()时， 该线程必须已经获得锁，否则会抛出异常。由于wait()在synchonized的方法内部被执行， 锁一定已经获得， 就不会抛出异常了。
notify()的功能： wait(), notify(), notifyAll() 和 synchonized 需要搭配使用， 用于线程同步
当一个线程调用一个对象的notify()方法时， 调度器会从所有处于该对象等待队列（waiting queue）的线程中取出任意一个线程， 将其添加到入口队列( entry queue) 中.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-25T19:30:40+08:00">
    <meta property="article:modified_time" content="2024-07-25T19:30:40+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java多线线程-----等待唤醒机制(wait notify)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="-toc" style="margin-left:0px;"><a href="#" rel="nofollow">一.等待唤醒机制简介：</a></p> 
<p id="synchronizedwaitnotify-toc" style="margin-left:0px;"><a href="#synchronizedwaitnotify" rel="nofollow">二.synchronized,wait(),notify():</a></p> 
<p id="-1-toc" style="margin-left:0px;"><a href="#-1" rel="nofollow">三.等待唤醒机制案例:</a></p> 
<p id="-2-toc" style="margin-left:40px;"><a href="#-2" rel="nofollow">例题一：</a></p> 
<p id="-3-toc" style="margin-left:40px;"><a href="#-3" rel="nofollow">例题二：</a></p> 
<p id="waitnotify-toc" style="margin-left:0px;"><a href="#waitnotify" rel="nofollow">四.什么时候释放锁—wait（）、notify（）</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2>一.等待唤醒机制简介：</h2> 
<p>由于线程之间是抢占式执行的，因此线程的执行顺序难以预知。但是实际开发中有时候我们希望合理的协调多个线程之间的执行先后顺序。为了完成协调的工作，这里主要设计三个方法：</p> 
<ul><li> <p>wait() / wait(long timeout) : 让当前线程进入等待状态</p> </li><li> <p>notify() / notifyAll(): 唤醒在当前对象上等待的线程</p> </li></ul> 
<p>注意：wait,notify,notifyAll都是Object类的方法</p> 
<h2 id="synchronizedwaitnotify">二.synchronized,wait(),notify():</h2> 
<ul><li><strong><span style="background-color:#ff9900;">synchronized 的含义：</span></strong></li></ul> 
<p>Java中每一个对象都可以成为一个监视器（Monitor）, 该Monitor由一个锁（lock）, 一个等待队列（waiting queue ）, 一个入口队列( entry queue).</p> 
<p>对于一个对象的方法， 如果没有synchronized关键字， 该方法可以被任意数量的线程，在任意时刻调用。</p> 
<p>对于添加了synchronized关键字的方法，任意时刻只能被唯一的一个获得了对象实例锁的线程调用。</p> 
<p>synchronized用于实现多线程的同步操作</p> 
<ul><li><strong><span style="background-color:#ff9900;">wait()功能：</span></strong></li></ul> 
<p>wait(), notify(), notifyAll() 和 synchonized 需要搭配使用， 用于线程同步</p> 
<p>wait()总是在一个循;环中被调用，挂起当前线程来等待一个条件的成立。 Wait调用会一直等到其他线程调用notifyAll()时才返回。</p> 
<p>当一个线程在执行synchronized 的方法内部，调用了wait()后， 该线程会释放该对象的锁， 然后该线程会被添加到该对象的等待队列中（waiting queue）, 只要该线程在等待队列中， 就会一直处于闲置状态， 不会被调度执行。 要注意wait()方法会强迫线程先进行释放锁操作，所以在调用wait()时， 该线程必须已经获得锁，否则会抛出异常。由于wait()在synchonized的方法内部被执行， 锁一定已经获得， 就不会抛出异常了。</p> 
<ul><li><strong><span style="background-color:#ff9900;">notify()的功能：</span></strong></li></ul> 
<p>wait(), notify(), notifyAll() 和 synchonized 需要搭配使用， 用于线程同步</p> 
<p>当一个线程调用一个对象的notify()方法时， 调度器会从所有处于该对象等待队列（waiting queue）的线程中取出任意一个线程， 将其添加到入口队列( entry queue) 中. 然后在入口队列中的多个线程就会竞争对象的锁， 得到锁的线程就可以继续执行。 如果等待队列中（waiting queue）没有线程， notify()方法不会产生任何作用</p> 
<p>notifyAll() 和notify()工作机制一样， 区别在于notifyAll()会将等待队列（waiting queue）中所有的线程都添加到入口队列中（entry queue）</p> 
<h2 id="-1">三.等待唤醒机制案例:</h2> 
<p>1.让t1执行wait()方法。</p> 
<p>2.此时t2得到锁，再让t2执行notify()方法释放锁。</p> 
<p>3.此时t1得到锁，t1会自动从wait()方法之后的代码，继续执行。</p> 
<p>4.通过上述流程，我们就可以清楚的看到，wait()和notify()各自是怎么工作的了，也可以知道两者是怎么配合的了。</p> 
<pre><code class="language-java">import java.util.*;
public class Main {
    //创建一个将被两个线程同时访问的共享对象
    public static Object loker = new Object();
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(()-&gt;{
            synchronized (loker){
                System.out.println("线程一初次获得对象锁，执行过程中调用锁对象的wait()方法~~");
                try {
                    loker.wait();
                    System.out.println("当线程一被唤醒后，后面的代码继续执行");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("线程一运行结束");
        },"线程一");

        Thread t2 = new Thread(()-&gt;{
            synchronized (loker){
                System.out.println("线程二初次获得对象锁，执行过程中调用锁对象的notify()方法~~");
                loker.notify();
                System.out.println("唤醒线程一前，后面的代码继续执行~~");
            }
            System.out.println("线程二结束");
        },"线程二");

        t1.start();
        //防止t2优先获得CPU执行权而错过唤醒t1
        Thread.sleep(1000);
        t2.start();
    }
}
</code></pre> 
<p>运行结果(运行流程也就是运行的打印结果)：</p> 
<p><img alt="" height="524" src="https://images2.imgbox.com/c1/c4/jcYYRsbA_o.png" width="1200"></p> 
<h3 id="-2">例题一：</h3> 
<p>有三个线程，线程名称分别为：a，b，c。每个线程打印自己的名称。</p> 
<p>需要让他们同时启动，并按 c，b，a的顺序打印</p> 
<p>代码详解：</p> 
<pre><code class="language-java">import java.util.*;
public class Test {
    public static Object loker1 = new Object();
    public static Object loker2 = new Object();

    public static void main(String[] args) {
        System.out.println("打印顺序如下：");

        Thread t1 = new Thread(()-&gt;{
            //为了防止线程A的唤醒没有被线程B接受，这里先让线程A睡一会
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println(Thread.currentThread().getName()+": C");
            synchronized (loker1){
                loker1.notify();
            }
        },"线程C");

        Thread t2 = new Thread(()-&gt;{
            synchronized (loker1){
                //等待线程A的唤醒
                try {
                    loker1.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println(Thread.currentThread().getName()+": B");
            //线程B唤醒线程C
            synchronized (loker2){
                loker2.notify();
            }
        },"线程B");

        Thread t3 = new Thread(()-&gt;{
            //线程C等待线程A的唤醒
            synchronized (loker2){
                try {
                    loker2.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println(Thread.currentThread().getName()+": A");
        },"线程A");
        //开启线程
        t1.start();
        t2.start();
        t3.start();
    }
}
</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="436" src="https://images2.imgbox.com/11/a6/0SH8rs1M_o.png" width="1200"></p> 
<h3 id="-3">例题二：</h3> 
<p>有三个线程，分别只能打印A，B和C</p> 
<p>要求按顺序打印ABC，打印10次</p> 
<p>输出示例：</p> 
<p>ABC</p> 
<p>ABC</p> 
<p>ABC</p> 
<p>ABC</p> 
<p>ABC</p> 
<p>ABC</p> 
<p>ABC</p> 
<p>ABC</p> 
<p>ABC</p> 
<p>ABC</p> 
<p>大致过程：</p> 
<p><img alt="" height="1150" src="https://images2.imgbox.com/a2/fa/3bWMyCTh_o.png" width="1200"></p> 
<p>代码详解：</p> 
<pre><code class="language-java">import java.util.*;
public class Demo {
    private static Object locker1 = new Object();
    private static Object locker2 = new Object();
    private static Object locker3 = new Object();

    public static void main(String[] args) throws InterruptedException {
        System.out.println("打印结果:");
        Thread t1 = new Thread(() -&gt; {
            try {
                for (int i = 0; i &lt; 10; i++) {
                    synchronized (locker1) {
                        locker1.wait();
                    }
                    System.out.print("A");
                    synchronized (locker2) {
                        locker2.notify();
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        Thread t2 = new Thread(() -&gt; {
            try {
                for (int i = 0; i &lt; 10; i++) {
                    synchronized (locker2) {
                        locker2.wait();
                    }
                    System.out.print("B");
                    synchronized (locker3) {
                        locker3.notify();
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        Thread t3 = new Thread(() -&gt; {
            try {
                for (int i = 0; i &lt; 10; i++) {
                    synchronized (locker3) {
                        locker3.wait();
                    }
                    System.out.println("C");
                    synchronized (locker1) {
                        locker1.notify();
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        t1.start();
        t2.start();
        t3.start();
        //让三个线程都拿到锁
        Thread.sleep(1000);

        // 从线程 t1 启动
        synchronized (locker1) {
            locker1.notify();
        }
    }
}
</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="575" src="https://images2.imgbox.com/6a/a4/RsnpiQ0h_o.png" width="1200"></p> 
<h2 id="waitnotify">四.什么时候释放锁—wait（）、notify（）</h2> 
<p>由于等待一个锁定线程只有在获得这把锁之后，才能恢复运行，所以让持有锁的线程在不需要锁的时候及时释放锁是很重要的。在以下情况下，持有锁的线程会释放锁：</p> 
<p>1.执行完同步代码块。</p> 
<p>2.在执行同步代码块的过程中，遇到异常而导致线程终止。</p> 
<p>3.在执行同步代码块的过程中，执行了锁所属对象的wait()方法，这个线程会释放锁，进行对象的等待池。</p> 
<p>除了以上情况外，只要持有锁的对象还没有执行完同步代码块，就不会释放锁。因此在以下情况下，线程不会释放锁：</p> 
<p>1.在执行同步代码块的过程中，执行了Thread.sleep()方法，当前线程放弃CPU，开始睡眠，在睡眠中不会释放锁。</p> 
<p>2.在执行同步代码块的过程中，执行了Thread.yield()方法，当前线程放弃CPU，但不会释放锁。</p> 
<p>3.在执行同步代码块的过程中，其他线程执行了当前对象的suspend()方法，当前线程被暂停，但不会释放锁。但Thread类的suspend()方法已经被废弃。</p> 
<p><strong>结语：</strong> <strong>写博客不仅仅是为了分享学习经历，同时这也有利于我巩固知识点，总结该知识点，由于作者水平有限，对文章有任何问题的还请指出，接受大家的批评，让我改进。同时也希望读者们不吝啬你们的点赞+收藏+关注，你们的鼓励是我创作的最大动力！</strong></p> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/87/80/SiWthlRG_o.gif"></strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bd9e2332d40a37a20ccd098afc30cc7a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据结构——单链表OJ题（下）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2efe586bd60a93c9fd75ce9acf331b86/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">让数组有序的最少交换次数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>