<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python Socketio 介绍 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/da751891835716254082e6919779b952/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Python Socketio 介绍">
  <meta property="og:description" content="socketio是一个Python库，用于处理实时网络通信，它实现了Socket.IO协议。Socket.IO是一个JavaScript库，用于实时、双向和基于事件的通信。它在浏览器和服务器之间建立一个持久的连接，允许它们进行实时通信。
socketio.Client()是socketio库中的一个类，用于创建一个Socket.IO客户端。这个客户端可以连接到一个Socket.IO服务器，并与其进行实时通信。
socketio.Client()的一些主要方法和事件： **connect(url, kwargs): 这个方法用于连接到一个Socket.IO服务器。你需要提供服务器的URL。你还可以提供一些可选的关键字参数，如transports（指定连接使用的协议类型）。
emit(event, data): 这个方法用于发送一个事件到服务器。你需要提供事件的名称和要发送的数据。
on(event): 这个装饰器用于定义一个事件处理器。当客户端收到指定的事件时，它会调用相应的事件处理器。
disconnect(): 这个方法用于断开与服务器的连接。
以下是一个简单的例子，展示了如何使用socketio.Client()：
import socketio sio = socketio.Client() @sio.event def connect(): print(&#34;I&#39;m connected!&#34;) @sio.event def disconnect(): print(&#34;I&#39;m disconnected!&#34;) sio.connect(&#39;http://localhost:5000&#39;) sio.emit(&#39;my event&#39;, {&#39;data&#39;: &#39;Hello, world!&#39;}) sio.disconnect() 我们首先创建了一个socketio.Client()实例。然后，我们定义了两个事件处理器：一个用于处理connect事件，另一个用于处理disconnect事件。然后，我们连接到服务器，发送一个名为my event的事件，然后断开连接。
socketio 库中的一些主要方法： socketio.Client(): 这是一个类，用于创建一个新的Socket.IO客户端实例。
**sio.connect(url, kwargs): 这个方法用于连接到一个Socket.IO服务器。你需要提供服务器的URL。你还可以提供一些可选的关键字参数，如transports（指定连接使用的协议类型）。
sio.emit(event, data): 这个方法用于发送一个事件到服务器。你需要提供事件的名称和要发送的数据。
sio.disconnect(): 这个方法用于断开与服务器的连接。
sio.on(event, handler): 这个方法用于注册一个事件处理器。当客户端收到指定的事件时，它会调用相应的事件处理器。例如，你可以使用 sio.on(&#39;message&#39;, message_handler) 来注册一个处理 &#39;message&#39; 事件的处理器。
sio.wait(): 这个方法会阻塞当前线程，直到客户端断开连接。这对于需要保持连接的应用（如聊天应用、实时游戏等）非常有用。
**sio.start_background_task(target, *args, kwargs): 这个方法用于启动一个后台任务。这对于需要在后台运行的长时间任务非常有用。
sio.sleep(seconds): 这个方法会暂停当前线程指定的秒数。这对于需要在发送事件之间添加延迟的情况非常有用。
sio.event: 这是一个装饰器，用于定义一个事件处理器。当客户端收到指定的事件时，它会调用相应的事件处理器。例如，你可以使用 @sio.event 来定义一个处理 &#39;connect&#39; 事件的处理器。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-16T01:00:26+08:00">
    <meta property="article:modified_time" content="2024-01-16T01:00:26+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python Socketio 介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><code>   socketio</code>是一个Python库，用于处理实时网络通信，它实现了Socket.IO协议。Socket.IO是一个JavaScript库，用于实时、双向和基于事件的通信。它在浏览器和服务器之间建立一个持久的连接，允许它们进行实时通信。</p> 
<p><code>   socketio.Client()</code>是<code>socketio</code>库中的一个类，用于创建一个Socket.IO客户端。这个客户端可以连接到一个Socket.IO服务器，并与其进行实时通信。</p> 
<p></p> 
<h4><code>socketio.Client()</code>的一些主要方法和事件：</h4> 
<p></p> 
<ol><li> <p>**connect(url, <strong>kwargs)</strong>: 这个方法用于连接到一个Socket.IO服务器。你需要提供服务器的URL。你还可以提供一些可选的关键字参数，如<code>transports</code>（指定连接使用的协议类型）。</p> </li><li> <p><strong>emit(event, data)</strong>: 这个方法用于发送一个事件到服务器。你需要提供事件的名称和要发送的数据。</p> </li><li> <p><strong>on(event)</strong>: 这个装饰器用于定义一个事件处理器。当客户端收到指定的事件时，它会调用相应的事件处理器。</p> </li><li> <p><strong>disconnect()</strong>: 这个方法用于断开与服务器的连接。</p> </li></ol> 
<p></p> 
<p>        以下是一个简单的例子，展示了如何使用<code>socketio.Client()</code>：</p> 
<pre><code class="language-python">import socketio

sio = socketio.Client()

@sio.event
def connect():
    print("I'm connected!")

@sio.event
def disconnect():
    print("I'm disconnected!")

sio.connect('http://localhost:5000')
sio.emit('my event', {'data': 'Hello, world!'})
sio.disconnect()</code></pre> 
<p>       </p> 
<p>        我们首先创建了一个<code>socketio.Client()</code>实例。然后，我们定义了两个事件处理器：一个用于处理<code>connect</code>事件，另一个用于处理<code>disconnect</code>事件。然后，我们连接到服务器，发送一个名为<code>my event</code>的事件，然后断开连接。</p> 
<p></p> 
<h4><code>socketio</code> 库中的一些主要方法：</h4> 
<p></p> 
<ol><li> <p><strong>socketio.Client()</strong>: 这是一个类，用于创建一个新的Socket.IO客户端实例。</p> </li><li> <p>**sio.connect(url, <strong>kwargs)</strong>: 这个方法用于连接到一个Socket.IO服务器。你需要提供服务器的URL。你还可以提供一些可选的关键字参数，如<code>transports</code>（指定连接使用的协议类型）。</p> </li><li> <p><strong>sio.emit(event, data)</strong>: 这个方法用于发送一个事件到服务器。你需要提供事件的名称和要发送的数据。</p> </li><li> <p><strong>sio.disconnect()</strong>: 这个方法用于断开与服务器的连接。</p> </li><li> <p><strong>sio.on(event, handler)</strong>: 这个方法用于注册一个事件处理器。当客户端收到指定的事件时，它会调用相应的事件处理器。例如，你可以使用 <code>sio.on('message', message_handler)</code> 来注册一个处理 'message' 事件的处理器。</p> </li><li> <p><strong>sio.wait()</strong>: 这个方法会阻塞当前线程，直到客户端断开连接。这对于需要保持连接的应用（如聊天应用、实时游戏等）非常有用。</p> </li><li> <p>**sio.start_background_task(target, *args, <strong>kwargs)</strong>: 这个方法用于启动一个后台任务。这对于需要在后台运行的长时间任务非常有用。</p> </li><li> <p><strong>sio.sleep(seconds)</strong>: 这个方法会暂停当前线程指定的秒数。这对于需要在发送事件之间添加延迟的情况非常有用。</p> </li><li> <p><strong>sio.event</strong>: 这是一个装饰器，用于定义一个事件处理器。当客户端收到指定的事件时，它会调用相应的事件处理器。例如，你可以使用 <code>@sio.event</code> 来定义一个处理 'connect' 事件的处理器。</p> </li></ol> 
<p></p> 
<h4>注意事项：</h4> 
<p></p> 
<ol><li> <p><strong>事件处理函数</strong>: 当你定义一个事件处理函数时，需要确保它能正确处理从服务器接收到的数据。如果处理函数抛出异常，可能会导致客户端断开连接。</p> </li><li> <p><strong>线程安全</strong>: <code>socketio</code>库是线程安全的，你可以在多个线程中使用同一个<code>socketio.Client</code>实例。但是，如果你在事件处理函数中访问共享数据，你需要确保这些访问是线程安全的。</p> </li><li> <p><strong>连接状态</strong>: 在调用<code>sio.emit()</code>或<code>sio.disconnect()</code>之前，你需要确保客户端已经连接到服务器。如果客户端没有连接到服务器，这些操作将会失败。</p> </li><li> <p><strong>错误处理</strong>: <code>sio.connect()</code>方法可能会抛出异常，例如，如果服务器无法连接。你需要确保你的代码能正确处理这些异常。</p> </li><li> <p><strong>资源清理</strong>: 当你不再需要<code>socketio.Client</code>实例时，你应该调用<code>sio.disconnect()</code>来断开连接并释放资源。</p> </li><li> <p><strong>阻塞操作</strong>: <code>sio.wait()</code>方法是阻塞的，它会阻塞当前线程直到客户端断开连接。如果你不希望阻塞当前线程，你可以在一个单独的线程中调用这个方法。</p> </li><li> <p><strong>后台任务</strong>: 如果你需要在后台运行长时间任务，你可以使用<code>sio.start_background_task()</code>方法。但是，你需要确保这个任务不会阻塞事件处理函数，否则可能会影响到客户端的响应性。</p> </li></ol> 
<p></p> 
<h4><code>socketio.Client</code>类的装饰器</h4> 
<p></p> 
<p>        在Python中，装饰器是一种特殊类型的函数，它可以修改其他函数的行为。</p> 
<p><code>   @sio.event</code>和<code>@sio.on</code>是<code>socketio.Client</code>类的装饰器，它们用于注册事件处理器。</p> 
<p>        <strong>@sio.event: </strong>这个装饰器用于注册一个处理器，当客户端触发特定的Socket.IO事件时，这个处理器会被调用。事件的名称由处理器函数的名称决定。</p> 
<p>        <strong>@sio.on: </strong>这个装饰器用于注册一个处理器，当客户端触发特定的Socket.IO事件时，这个处理器会被调用。事件的名称由装饰器的参数决定。</p> 
<p>        这两个装饰器的主要目的是将事件处理器与特定的事件关联起来。当这些事件发生时，相应的处理器会被自动调用。这使得你可以在处理器中编写处理事件的代码，而不需要在主程序中显式调用这些处理器。这样可以使你的代码更加清晰和模块化。</p> 
<p></p> 
<h4><code>@sio.event</code>和<code>@sio.on有什么区别</code></h4> 
<p></p> 
<p><code>@sio.event</code>和<code>@sio.on</code>都是用于注册事件处理器的装饰器，但它们的使用方式略有不同：</p> 
<ul><li><code>@sio.event</code>：这个装饰器根据被修饰的函数的名称来确定对应的事件。例如，如果你有一个名为<code>connect</code>的函数并且它被<code>@sio.event</code>装饰，那么这个函数会在客户端收到<code>connect</code>事件时被调用。</li></ul> 
<pre><code class="language-python">@sio.event
def connect():
    print("Connected to the server!")</code></pre> 
<ul><li><code>@sio.on</code>：这个装饰器需要一个参数，这个参数是你想要处理的事件的名称。例如，如果你有一个名为<code>handle_connect</code>的函数并且它被<code>@sio.on('connect')</code>装饰，那么这个函数会在客户端收到<code>connect</code>事件时被调用。</li></ul> 
<pre><code class="language-python">@sio.on('connect')
def handle_connect():
    print("Connected to the server!")</code></pre> 
<p>        总的来说，<code>@sio.event</code>和<code>@sio.on</code>都可以用来注册事件处理器，选择使用哪一个主要取决于你的编程风格和需求。如果你希望函数名和事件名保持一致，那么<code>@sio.event</code>可能更适合你。如果你希望能够自由地为函数命名，那么<code>@sio.on</code>可能更适合你。</p> 
<p></p> 
<h4><code>socketio</code>库中其他修饰器</h4> 
<p></p> 
<ul><li><code>@sio.middleware</code>: 这个装饰器用于注册中间件函数。中间件函数在每个事件处理器之前运行，它们可以用于处理跨越多个事件的逻辑，例如身份验证或日志记录。</li></ul> 
<pre><code class="language-python">@sio.middleware
def print_event(sid, data):
    print("Socket ID: ", sid, ", Event data: ", data)</code></pre> 
<ul><li><code>@sio.exception_handler()</code>: 这个装饰器用于注册异常处理器。异常处理器在事件处理器抛出异常时运行，它们可以用于处理事件处理器中未捕获的异常。</li></ul> 
<pre><code class="language-python">@sio.exception_handler(ValueError)
def handle_value_error(e):
    print("A ValueError occurred: ", e)</code></pre> 
<p>        需要注意的是，这些装饰器的用途更加特定，它们不像<code>@sio.event</code>和<code>@sio.on</code>那样常用。在大多数应用中，你可能只需要使用<code>@sio.event</code>和<code>@sio.on</code>。</p> 
<p></p> 
<h4>Socket.IO内置事件</h4> 
<p></p> 
<p>        Socket.IO定义了一些内置的事件，这些事件在客户端和服务器之间的通信过程中自动触发。以下是一些常见的内置事件：</p> 
<ol><li> <p><strong>connect</strong>: 当客户端成功连接到服务器时触发。</p> </li><li> <p><strong>disconnect</strong>: 当客户端从服务器断开连接时触发。</p> </li><li> <p><strong>message</strong> 或 <strong>data</strong>: 当客户端接收到来自服务器的消息时触发。</p> </li><li> <p><strong>error</strong>: 当发生错误时触发。</p> </li></ol> 
<p>除了这些内置事件，你还可以定义自己的自定义事件。自定义事件的名称可以是任何字符串，只要它不与内置事件的名称冲突。你可以使用<code>socket.emit('my event', data)</code>来发送一个自定义事件，然后在另一端使用<code>socket.on('my event', function(data) {})</code>来接收这个事件。</p> 
<p>需要注意的是，虽然Socket.IO允许你定义自己的自定义事件，但是在设计你的应用时，你应该尽量使用内置事件，只有在必要的时候才使用自定义事件。这是因为内置事件已经被优化过，而且它们的行为在所有的Socket.IO实现中都是一致的。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a07542bd021a4cb5cbac5cbb10591e7d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">毕业设计：python商品销售数据采集分析可视化系统 京东商品数据爬取&#43;可视化 大数据 python（源码）✅</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/44746d6069b8aa2dd60a2db29cc508e9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">图像识别技术的发展历程：从传统算法到深度学习</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>