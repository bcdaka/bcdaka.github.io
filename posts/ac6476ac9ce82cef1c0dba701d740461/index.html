<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>hadoop学习（二） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ac6476ac9ce82cef1c0dba701d740461/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="hadoop学习（二）">
  <meta property="og:description" content="一.MapReduce
1.1定义：是一个分布式运算程序的编程框架
1.2核心功能：将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在一个Hadoop集群上。
1.3优点
1）易于编程
它简单的实现一些接口，就可以完成一个分布式程序，这个分布式程序可以分布到大量廉价的PC机器上运行（正是因为这个特点使MapReduce编程变得非常流行）
2）良好扩展性
可以通过简单地增加机器来扩展它的计算能力。
3）高容错性
MapReduce设计的初衷就是使程序能够部署在廉价的PC机器上，这就要求它具有很高的容错性。比如其中一台机器挂了，它可以把上面的计算任务转移到另外一个节点上运行，不至于这个任务运行失败，而且这个过程不需要人工参与，而完全是由Hadoop内部完成的。
4）适合PB级以上海量数据地离线处理
可以实现上千台服务器集群并发工作，提供数据处理能力。
1.4缺点
1）不擅长实时计算
无法像MySQL一样，在毫秒或者秒级内返回结果
2）不擅长流式计算
流式计算的输入数据是动态的，而MapReduce的输入数据集是静态的，不能动态变化。这是因为MapReduce自身的设计特点决定了数据源必须是静态的。
3）不擅长有向无环图计算
每个MapReduce作业的输出结果都会写入到磁盘，会造成大量的磁盘IO，导致性能非常的低下。
1.5MapReduce核心思想
1）分布式的运算程序往往需要分成至少2个阶段。
2）第一个阶段的MapTask并发实例，完全并行运行，互不相干。
3）第二个阶段的ReduceTask并发实例互不相干，但是他们的数据依赖于上一个阶段的所有MapTask并发实例的输出。
4）MapReduce编程模型只能包含一个Map阶段和一个Reduce阶段，如果用户的业务逻辑非常复杂，那就只能多个MapReduce程序，串行运行。
总结：分析WordCount数据流走向深入理解MapReduce核心思想。
1.6 MapReduce进程
一个完整的MapReduce程序在分布式运行时有三类实例进程：
1）MrAppMaster：负责整个程序的过程调度及状态协调。
2）MapTask：负责Map阶段的整个数据处理流程。
3）ReduceTask：负责Reduce阶段的整个数据处理流程。
1.7常用数据反序列类型
1.8 编程规范
编写程序可分为Mapper、Reducer和Driver三部分。
Mapper阶段：
1）自定义的Mapper要继承自己的父类
2）Mapper的业务逻辑写在map（）方法中
3）Mapper的输入、输出数据是K-V对的形式
4）map（）方法（Map Task进程）对每一个k-V调用一次
Reducer阶段
1）自定义的Reduce要继承自己的父类
2）业务逻辑写在reduce（）方法中
3）Reduce的输入数据类型对应Mapper的输出数据类型
4）ReduceTask进程对每一组相同k的&lt;k,v&gt;组调用一次reduce()方法
Driver阶段
相当于YARN集群的客户端，用于提交我们整个程序到YARN集群，提交的是封装了MapReduce程序相关运行参数的job对象。
二、Hadoop序列化
2.1 序列化和反序列化
序列化就是把内存中的对象，转换成字节序列（或其他数据传输协议）以便于存储到磁盘（持久化）和网络传输。 反序列化就是将收到字节序列（或其他数据传输协议）或者是磁盘的持久化数据，转换成内存中的对象。
2.2为何不使用Java的序列化
Java的序列化是一个重量级序列化框架（Serializable），一个对象被序列化后，会附带很多额外的信息（各种校验信息，Header，继承体系等），不便于在网络中高效传输。
2.3 Hadoop序列化的特点
1）紧凑：高效使用存储空间
2）快速：读写数据的额外开销小
3）互操作：支持多语言的交互
2.4 实现bean对象序列化
1）必须实现Writable接口（FlowBean继承Writable接口）
2）反序列化时，需要反射调用空参构造函数，所以必须有空参构造
public FlowBean() { super(); } （3）重写序列化方法">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-28T21:17:21+08:00">
    <meta property="article:modified_time" content="2024-07-28T21:17:21+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">hadoop学习（二）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>一.MapReduce</p> 
<p>1.1定义：是一个<span style="color:#fe2c24;">分布式运算程序</span>的编程框架</p> 
<p>1.2核心功能：将<span style="color:#ff0000;">用户编写的业务逻辑代码</span>和<span style="color:#ff0000;">自带默认组件</span>整合成一个完整的<span style="color:#ff0000;">分布式运算程序</span>，并发运行在一个Hadoop集群上。</p> 
<p>1.3优点</p> 
<p>1）易于编程</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">它简单的实现一些接口，就可以完成一个分布式程序，</span>这个分布式程序可以分布到大量廉价的PC机器上运行（正是因为这个特点使MapReduce编程变得非常流行）</p> 
<p style="margin-left:.0001pt;text-align:justify;">2）良好扩展性</p> 
<p style="margin-left:.0001pt;text-align:justify;">可以通过简单地增加机器来扩展它的计算能力。</p> 
<p style="margin-left:.0001pt;text-align:justify;">3）高容错性</p> 
<p style="margin-left:.0001pt;text-align:justify;">MapReduce设计的初衷就是使程序能够部署在廉价的PC机器上，这就要求它具有很高的容错性。比如<span style="color:#ff0000;">其中一台机器挂了，它可以把上面的计算任务转移到另外一个节点上运行，不至于这个任务运行失败</span>，而且这个过程不需要人工参与，而完全是由Hadoop内部完成的。</p> 
<p style="margin-left:.0001pt;text-align:justify;">4）适合PB级以上海量数据地离线处理</p> 
<p style="margin-left:.0001pt;text-align:justify;">可以实现上千台服务器集群并发工作，提供数据处理能力。</p> 
<p style="margin-left:.0001pt;text-align:justify;">1.4缺点</p> 
<p style="margin-left:.0001pt;text-align:justify;">1）不擅长实时计算</p> 
<p style="margin-left:.0001pt;text-align:justify;">无法像MySQL一样，在毫秒或者秒级内返回结果</p> 
<p style="margin-left:.0001pt;text-align:justify;">2）不擅长流式计算</p> 
<p style="margin-left:.0001pt;text-align:justify;">流式计算的输入数据是动态的，而MapReduce的<span style="color:#ff0000;">输入数据集是静态的</span>，不能动态变化。这是因为MapReduce自身的设计特点决定了数据源必须是静态的。</p> 
<p style="margin-left:.0001pt;text-align:justify;">3）不擅长有向无环图计算</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0d0016;">每个MapReduce作业的输出结果都会写入到磁盘，会造成大量的磁盘IO，导致性能非常的低下。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#fe2c24;">1.5MapReduce核心思想</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">1）分布式的运算程序往往需要分成至少</span><span style="color:#000000;">2</span><span style="color:#000000;">个阶段。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">2）第一个阶段的</span><span style="color:#000000;">MapTask</span><span style="color:#000000;">并发实例，完全并行运行，互不相干。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">3）第二个阶段的</span><span style="color:#000000;">ReduceTask</span><span style="color:#000000;">并发实例互不相干，但是他们的数据依赖于上一个阶段的所有</span><span style="color:#000000;">MapTask</span><span style="color:#000000;">并发实例的输出。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">4）</span><span style="color:#000000;">MapReduce</span><span style="color:#000000;">编程模型只能包含一个</span><span style="color:#000000;">Map</span><span style="color:#000000;">阶段和一个</span><span style="color:#000000;">Reduce</span><span style="color:#000000;">阶段，如果用户的业务逻辑非常复杂，那就只能多个</span><span style="color:#000000;">M</span><span style="color:#000000;">ap</span><span style="color:#000000;">R</span><span style="color:#000000;">educe程序，串行运行。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">总结</span><span style="color:#000000;">：</span><span style="color:#fe2c24;">分析WordCount数据流走向深入理解MapReduce核心思想</span><span style="color:#000000;">。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">1.6 MapReduce进程</p> 
<p style="margin-left:.0001pt;text-align:justify;">一个完整的MapReduce程序在分布式运行时有<span style="color:#fe2c24;">三类实例进程</span>：</p> 
<p style="margin-left:.0001pt;text-align:justify;">1）<strong><strong>MrAppMaster</strong></strong>：负责整个程序的过程调度及状态协调。</p> 
<p style="margin-left:.0001pt;text-align:justify;">2）<strong><strong>MapTask</strong></strong>：负责Map阶段的整个数据处理流程。</p> 
<p style="margin-left:.0001pt;text-align:justify;">3）<strong><strong>ReduceTask</strong></strong>：负责Reduce阶段的整个数据处理流程。</p> 
<p style="margin-left:.0001pt;text-align:justify;">1.7常用数据反序列类型</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="354" src="https://images2.imgbox.com/4e/bc/qjiW868O_o.png" width="807"></p> 
<p style="margin-left:.0001pt;text-align:justify;">1.8 编程规范</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#fe2c24;">编写程序可分为Mapper、Reducer和Driver三部分。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0d0016;">Mapper阶段：</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0d0016;">1）自定义的Mapper要继承自己的父类</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0d0016;">2）Mapper的业务逻辑写在map（）方法中</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0d0016;">3）Mapper的输入、输出数据是K-V对的形式</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0d0016;">4）map（）方法（</span><span style="color:#fe2c24;">Map Task进程</span><span style="color:#0d0016;">）对每一个k-V调用一次</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0d0016;">Reducer阶段</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0d0016;">1）自定义的Reduce要继承自己的父类</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">2）业务逻辑写在reduce（）方法中</p> 
<p style="margin-left:.0001pt;text-align:justify;">3）Reduce的输入数据类型对应Mapper的输出数据类型</p> 
<p style="margin-left:.0001pt;text-align:justify;">4）<span style="color:#fe2c24;">ReduceTask进程对每一组相同k的&lt;k,v&gt;组调用一次reduce()方法</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0d0016;">Driver阶段</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0d0016;">相当于YARN集群的客户端，用于提交我们整个程序到YARN集群，提交的是封装了MapReduce程序相关运行参数的job对象。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">二、Hadoop序列化</p> 
<p style="margin-left:.0001pt;text-align:justify;">2.1 序列化和反序列化</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>序列化</strong></strong>就是<span style="color:#ff0000;">把内存中的对象，转换成字节序列</span>（或其他数据传输协议）以便于存储到磁盘（持久化）和网络传输。 </p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><strong>反序列化</strong></strong>就是将收到字节序列（或其他数据传输协议）或者是<span style="color:#ff0000;">磁盘的持久化数据，转换成内存中的对象。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0d0016;">2.2为何不使用Java的序列化</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">Java的序列化是一个重量级序列化框架（Serializable），一个对象被序列化后，会附带很多额外的信息（各种校验信息，Header，继承体系等），<span style="color:#fe2c24;">不便于在网络中高效传输</span>。</p> 
<p style="margin-left:.0001pt;text-align:justify;">2.3 Hadoop序列化的特点</p> 
<p style="margin-left:.0001pt;text-align:justify;">1）<span style="color:#fe2c24;">紧凑</span>：高效使用存储空间</p> 
<p style="margin-left:.0001pt;text-align:justify;">2）<span style="color:#fe2c24;">快速</span>：读写数据的额外开销小</p> 
<p style="margin-left:.0001pt;text-align:justify;">3）<span style="color:#fe2c24;">互操作</span>：支持多语言的交互</p> 
<p style="margin-left:.0001pt;text-align:justify;">2.4 <span style="color:#000000;">实现</span><span style="color:#000000;">bean对象序列化</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">1）必须实现Writable接口（FlowBean继承Writable接口）</p> 
<p style="margin-left:.0001pt;text-align:justify;">2）反序列化时，需要反射调用空参构造函数，所以必须有空参构造</p> 
<pre><code class="hljs">public FlowBean() {
super();
}</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">（3）重写序列化方法</p> 
<pre><code class="hljs">@Override
public void write(DataOutput out) throws IOException {
out.writeLong(upFlow);
out.writeLong(downFlow);
out.writeLong(sumFlow);
}</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">（4）重写反序列化方法</p> 
<pre><code class="hljs">@Override
public void readFields(DataInput in) throws IOException {
upFlow = in.readLong();
downFlow = in.readLong();
sumFlow = in.readLong();
}</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#ff0000;">（5）反序列化的顺序和序列化的顺序相同</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">（6）要想把结果显示在文件中，需要重写toString()，可用"\t"分开，方便后续用。</p> 
<p style="margin-left:.0001pt;text-align:justify;">（7）如果需要将自定义的bean放在key中传输，则还需要实现Comparable接口，因为MapReduce框中的Shuffle过程要求对key必须能排序。</p> 
<pre><code class="hljs">@Override
public int compareTo(FlowBean o) {
//设置从大到小排序
return this.sumFlow &gt; o.getSumFlow() ? -1 : 1;
}</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">3.InputFormat数据输入</p> 
<p style="margin-left:.0001pt;text-align:justify;">3.1 MapTask并行度决定机制</p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="color:#000000;">数据</span></strong><strong><span style="color:#000000;">块：</span></strong><span style="color:#000000;">Block</span><span style="color:#000000;">是</span><span style="color:#000000;">HDFS</span><span style="color:#000000;">物理</span><span style="color:#000000;">上</span><span style="color:#000000;">把数据分成一块一块。</span><span style="color:#ff0000;">数据块是H</span><span style="color:#ff0000;">DFS</span><span style="color:#ff0000;">存储数据单位</span><span style="color:#000000;">。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong><span style="color:#000000;">数据</span></strong><strong><span style="color:#000000;">切片：</span></strong><span style="color:#000000;">数据切片</span><span style="color:#000000;">只是</span><span style="color:#000000;">在逻辑上</span><span style="color:#000000;">对输入</span><span style="color:#000000;">进行分片，</span><span style="color:#000000;">并不会在磁盘上将其切分成片进行存储</span><span style="color:#000000;">。</span><span style="color:#ff0000;">数据切片是MapReduce程序计算输入数据的单位</span><span style="color:#000000;">，一个切片会对应启动一个Map</span><span style="color:#000000;">T</span><span style="color:#000000;">ask。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="348" src="https://images2.imgbox.com/1f/63/NZXFvnHm_o.png" width="783"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/44284dd0b36f421d24a1aa0b510ed3d4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">一篇笔记总结HTML基础知识</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8ad09a19edd0575557cb664b68973493/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">指针！！C语言(第三篇）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>