<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Redis】Redis数据结构——Hash 哈希 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/83b531c0a3f5900bf3748d866c9b6d75/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【Redis】Redis数据结构——Hash 哈希">
  <meta property="og:description" content="哈希 命令hsethgethexistshdelhkeyshvalshgetallhmgethlenhsetnxhincrbyhincrbyfloat命令小结 内部编码使用场景缓存⽅式对⽐ ⼏乎所有的主流编程语⾔都提供了哈希（hash）类型，它们的叫法可能是哈希、字典、关联数组、映射。在 Redis 中，哈希类型是指值本⾝⼜是⼀个键值对结构，形如 key = “key”，value = { {field1, value1 }, …, {fieldN, valueN } }，Redis 键值对和哈希类型⼆者的关系可以⽤图 2-15 来表⽰。 哈希类型中的映射关系通常称为 field-value，⽤于区分 Redis 整体的键值对（key-value），注意这⾥的 value 是指 field 对应的值，不是键（key）对应的值，请注意 value 在不同上下⽂的作⽤。
命令 hset 设置 hash 中指定的字段（field）的值（value）。
语法：
hset key field value [field value …]
命令有效版本：2.0.0 之后
时间复杂度：插⼊⼀组 field 为 O(1), 插⼊ N 组 field 为 O(N)
返回值：添加的字段的个数。
hget 获取 hash 中指定字段的值。
hexists 判断 hash 中是否有指定的字段。
hdel 删除 hash 中指定的字段。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-23T12:37:01+08:00">
    <meta property="article:modified_time" content="2024-08-23T12:37:01+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Redis】Redis数据结构——Hash 哈希</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>哈希</h4> 
 <ul><li><a href="#_7" rel="nofollow">命令</a></li><li><ul><li><a href="#hset_8" rel="nofollow">hset</a></li><li><a href="#hget_20" rel="nofollow">hget</a></li><li><a href="#hexists_24" rel="nofollow">hexists</a></li><li><a href="#hdel_30" rel="nofollow">hdel</a></li><li><a href="#hkeys_35" rel="nofollow">hkeys</a></li><li><a href="#hvals_40" rel="nofollow">hvals</a></li><li><a href="#hgetall_45" rel="nofollow">hgetall</a></li><li><a href="#hmget_50" rel="nofollow">hmget</a></li><li><a href="#hlen_58" rel="nofollow">hlen</a></li><li><a href="#hsetnx_62" rel="nofollow">hsetnx</a></li><li><a href="#hincrby_67" rel="nofollow">hincrby</a></li><li><a href="#hincrbyfloat_71" rel="nofollow">hincrbyfloat</a></li><li><a href="#_76" rel="nofollow">命令小结</a></li></ul> 
  </li><li><a href="#_79" rel="nofollow">内部编码</a></li><li><a href="#_86" rel="nofollow">使用场景</a></li><li><ul><li><a href="#_97" rel="nofollow">缓存⽅式对⽐</a></li></ul> 
 </li></ul> 
</div> 
<br> ⼏乎所有的主流编程语⾔都提供了哈希（hash）类型，它们的叫法可能是哈希、字典、关联数组、映射。在 Redis 中，哈希类型是指值本⾝⼜是⼀个键值对结构，形如 key = “key”，value = { {field1, value1 }, …, {fieldN, valueN } }，Redis 键值对和哈希类型⼆者的关系可以⽤图 2-15 来表⽰。 
<p></p> 
<p><img src="https://images2.imgbox.com/a6/7e/WCKPMziC_o.png" alt="在这里插入图片描述"><br> 哈希类型中的映射关系通常称为 field-value，⽤于区分 Redis 整体的键值对（key-value），注意这⾥的 value 是指 field 对应的值，不是键（key）对应的值，请注意 value 在不同上下⽂的作⽤。</p> 
<h2><a id="_7"></a>命令</h2> 
<h3><a id="hset_8"></a>hset</h3> 
<p>设置 hash 中指定的字段（field）的值（value）。</p> 
<p>语法：</p> 
<blockquote> 
 <p>hset key field value [field value …]</p> 
</blockquote> 
<p>命令有效版本：2.0.0 之后<br> 时间复杂度：插⼊⼀组 field 为 O(1), 插⼊ N 组 field 为 O(N)<br> 返回值：添加的字段的个数。</p> 
<h3><a id="hget_20"></a>hget</h3> 
<p>获取 hash 中指定字段的值。</p> 
<p><img src="https://images2.imgbox.com/cd/46/f0OUGLh7_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="hexists_24"></a>hexists</h3> 
<p>判断 hash 中是否有指定的字段。</p> 
<p><img src="https://images2.imgbox.com/26/2c/qTuVfRJW_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="hdel_30"></a>hdel</h3> 
<p>删除 hash 中指定的字段。</p> 
<p><img src="https://images2.imgbox.com/05/e4/rbwRTFMb_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="hkeys_35"></a>hkeys</h3> 
<p>获取 hash 中的所有字段。</p> 
<p><img src="https://images2.imgbox.com/5d/39/hPQJWXtz_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="hvals_40"></a>hvals</h3> 
<p>获取 hash 中的所有的值。</p> 
<p><img src="https://images2.imgbox.com/36/41/dBaKMT5S_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="hgetall_45"></a>hgetall</h3> 
<p>获取 hash 中的所有字段以及对应的值。</p> 
<p><img src="https://images2.imgbox.com/15/e1/g5jCQeOe_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="hmget_50"></a>hmget</h3> 
<p>⼀次获取 hash 中多个字段的值。</p> 
<p><img src="https://images2.imgbox.com/2e/82/rfkWDcBQ_o.png" alt="在这里插入图片描述"><br> 在使⽤ HGETALL 时，如果哈希元素个数⽐较多，会存在阻塞 Redis 的可能。如果开发⼈员只需要获取部分 field，可以使⽤ HMGET，如果⼀定要获取全部 field，可以尝试使⽤ HSCAN命令，该命令采⽤渐进式遍历哈希类型，HSCAN 会在后续章节介绍。</p> 
<h3><a id="hlen_58"></a>hlen</h3> 
<p>获取 hash 中的所有字段的个数。</p> 
<p><img src="https://images2.imgbox.com/bd/38/IaMBKEdN_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="hsetnx_62"></a>hsetnx</h3> 
<p>在字段不存在的情况下，设置 hash 中的字段和值。</p> 
<p><img src="https://images2.imgbox.com/d5/77/t3pD9t6M_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="hincrby_67"></a>hincrby</h3> 
<p>将 hash 中字段对应的数值添加指定的值。</p> 
<p><img src="https://images2.imgbox.com/29/f0/r7WSrFqR_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="hincrbyfloat_71"></a>hincrbyfloat</h3> 
<p>HINCRBY 的浮点数版本。</p> 
<p><img src="https://images2.imgbox.com/a5/c1/OTqPR3FI_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_76"></a>命令小结</h3> 
<p><img src="https://images2.imgbox.com/ed/e0/T24aCXds_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_79"></a>内部编码</h2> 
<p>哈希的内部编码有两种：</p> 
<ul><li>ziplist（压缩列表）：当哈希类型元素个数⼩于 hash-max-ziplist-entries 配置（默认 512 个）、同时所有值都⼩于 hash-max-ziplist-value 配置（默认 64 字节）时，Redis 会使⽤ ziplist 作为哈希的内部实现，ziplist 使⽤更加紧凑的结构实现多个元素的连续存储，所以在节省内存⽅⾯⽐hashtable 更加优秀。</li><li>hashtable（哈希表）：当哈希类型⽆法满⾜ ziplist 的条件时，Redis 会使⽤ hashtable 作为哈希的内部实现，因为此时 ziplist 的读写效率会下降，⽽ hashtable 的读写时间复杂度为 O(1)。</li></ul> 
<h2><a id="_86"></a>使用场景</h2> 
<p><img src="https://images2.imgbox.com/76/1e/tCkuvKq3_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/ac/f5/3by7TF34_o.png" alt="在这里插入图片描述"><br> 但是需要注意的是哈希类型和关系型数据库有两点不同之处：</p> 
<ul><li>哈希类型是稀疏的，⽽关系型数据库是完全结构化的，例如哈希类型每个键可以有不同的 field，⽽关系型数据库⼀旦添加新的列，所有⾏都要为其设置值，即使为 null，如图 2-18 所⽰。</li><li>关系数据库可以做复杂的关系查询，⽽ Redis 去模拟关系型复杂查询，例如联表查询、聚合查询等基本不可能，维护成本⾼。</li></ul> 
<p><img src="https://images2.imgbox.com/e8/96/vBoyo3jB_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_97"></a>缓存⽅式对⽐</h3> 
<blockquote> 
 <ol><li>原⽣字符串类型⸺使⽤字符串类型，每个属性⼀个键。</li></ol> 
</blockquote> 
<p><img src="https://images2.imgbox.com/ad/41/dy2cFy2V_o.png" alt="在这里插入图片描述"><br> 优点：实现简单，针对个别属性变更也很灵活。<br> 缺点：占⽤过多的键，内存占⽤量较⼤，同时⽤⼾信息在 Redis 中⽐较分散，缺少内聚性，所以这种⽅案基本没有实⽤性。</p> 
<blockquote> 
 <ol start="2"><li>序列化字符串类型，例如 JSON 格式</li></ol> 
</blockquote> 
<p><img src="https://images2.imgbox.com/ac/f6/qSfEWYk3_o.png" alt="在这里插入图片描述"><br> 优点：针对总是以整体作为操作的信息⽐较合适，编程也简单。同时，如果序列化⽅案选择合适，内存的使⽤效率很⾼。</p> 
<p>缺点：本⾝序列化和反序列需要⼀定开销，同时如果总是操作个别属性则⾮常不灵活。</p> 
<blockquote> 
 <ol start="3"><li>哈希类型</li></ol> 
</blockquote> 
<p><img src="https://images2.imgbox.com/91/b6/8pgx0zO6_o.png" alt="在这里插入图片描述"><br> 优点：简单、直观、灵活。尤其是针对信息的局部变更或者获取操作。</p> 
<p>缺点：需要控制哈希在 ziplist 和 hashtable 两种内部编码的转换，可能会造成内存的较⼤消耗。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/74c7ae15b72f7bca5e61b42300b9a1d0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【大数据算法】一文掌握大数据算法之：时间亚线性算法。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bfbe634724e88e10c7c8ce435e2b830a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">HTML 全解析：从基础到实战</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>