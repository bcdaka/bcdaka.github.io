<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>在WPF中使用WebView2详解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/203b2c00a7096697c542c228a61ae6c5/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="在WPF中使用WebView2详解">
  <meta property="og:description" content="Microsoft Edge WebView2 Microsoft Edge WebView2 控件允许在本机应用中嵌入 web 技术(HTML、CSS 以及 JavaScript)。 WebView2 控件使用 Microsoft Edge 作为绘制引擎，以在本机应用中显示 web 内容。
使用 WebView2 可以在本机应用的不同部分嵌入 Web 代码，或在单个 WebView2 实例中生成所有本机应用。
现在使用混合技术开发桌面客户端已经变得越来越常见了，如网易云音乐、QQ音乐等，因为可以嵌入现有的网页端页面，开发成本是比较低的，而且还可以实现跨平台。
使用混合技术开发的桌面客户端占用资源相对较多，反应速度也会慢点，如果需要对操作系统有较多的功能交互，推荐使用原生API开发。
WebView2已经出来好几年了，我一直没怎么使用过，前面一直使用的是CEFSharp，CEF是基于Google Chromium项目的开源Web browser控件，和CEFSharp一样，WebView2也支持winform和wpf。
简单来说，WebView2就是一个浏览器控件，类似WPF里自带的WebBrowser，只是WebView2的内核Chrome，WebBrowser的内核是IE，而且WebView2提供的可编程接口更多。
对于桌面开发开说，我们可以使用WebView2来实现以下功能
1、爬虫
对于动态网页，可以嵌入WebView2来进行抓取。
2、自制浏览器
使用WebView2可以自己开发简单的浏览器
3、嵌入本地网页
有时候要展示一些简单的网页内容，如报告、图表等，都可以使用WebView2进行加载显示 4、开发混合应用
借助WebView2的本机和Web互操作功能，开发混合应用，例如：网易云音乐。
最近我们有一个需求是需要绘制大量的图表，使用WPF的免费控件都不能很好的满足需求，后面就选择使用Echarts（Echarts是一款基于JavaScript的数据可视化图表库，提供直观，生动，可交互，可个性化定制的数据可视化图表），然后嵌入网页到WPF中来实现。
本来是准备使用CEF的，同事在前期使用了WebView2，所以就继续使用WebView2。
这里我写篇文章做个记录，以便以后需要时查看。注意：本文仅介绍了WebView2中的常用功能，全部功能的使用和介绍可以访问WebView2的官方文档。
WebView2的优点 本机功能。 访问完整的本机 API 集。
代码共享。 向代码库添加 web 代码可以增加跨多个平台的重用。
Microsoft 支持。 Microsoft 在受支持的平台上提供支持并添加新功能请求。
定期发布更新和安全修补的最新版 Chromium。
已修复版本分布。 也可以在应用中打包特定版本的 Chromium 位。
支持Windows10/11
WebView2支持的平台 编程语言
Win32 C/C&#43;&#43;.NET Framework 4.6.2 &#43;.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-26T09:22:56+08:00">
    <meta property="article:modified_time" content="2024-07-26T09:22:56+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">在WPF中使用WebView2详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><span style="color:#4da8ee;"><strong>Microsoft Edge WebView2</strong></span></h2> 
<p><strong>Microsoft Edge WebView2</strong> 控件允许在本机应用中嵌入 web 技术(<strong>HTML、CSS 以及 JavaScript</strong>)。 <strong>WebView2</strong> 控件使用 <strong>Microsoft Edge</strong> 作为绘制引擎，以在本机应用中显示 web 内容。</p> 
<p>使用 <strong>WebView2</strong> 可以在本机应用的不同部分嵌入 Web 代码，或在单个 <strong>WebView2</strong> 实例中生成所有本机应用。</p> 
<p class="img-center"><img alt="" height="290" src="https://images2.imgbox.com/4e/14/0tmhkIsn_o.png" width="693"></p> 
<p>现在使用混合技术开发桌面客户端已经变得越来越常见了，如网易云音乐、QQ音乐等，因为可以嵌入现有的网页端页面，开发成本是比较低的，而且还可以实现跨平台。</p> 
<p>使用混合技术开发的桌面客户端占用资源相对较多，反应速度也会慢点，如果需要对操作系统有较多的功能交互，推荐使用原生API开发。</p> 
<p></p> 
<p><strong>WebView2</strong>已经出来好几年了，我一直没怎么使用过，前面一直使用的是<strong>CEFSharp</strong>，<strong>CEF</strong>是基于<strong>Google Chromium</strong>项目的开源Web browser控件，和<strong>CEFSharp</strong>一样，<strong>WebView2</strong>也支持<strong>winform</strong>和<strong>wpf</strong>。</p> 
<p>简单来说，<strong>WebView2</strong>就是一个浏览器控件，类似<strong>WPF</strong>里自带的<strong>WebBrowser</strong>，只是<strong>WebView2</strong>的内核<strong>Chrome</strong>，<strong>WebBrowser</strong>的内核是<strong>IE</strong>，而且<strong>WebView2</strong>提供的可编程接口更多。</p> 
<p></p> 
<p>对于桌面开发开说，我们可以使用WebView2来实现以下功能</p> 
<p><strong>1、爬虫</strong></p> 
<p>对于动态网页，可以嵌入WebView2来进行抓取。</p> 
<p><strong>2、自制浏览器</strong></p> 
<p>使用WebView2可以自己开发简单的浏览器</p> 
<p><strong>3、嵌入本地网页</strong></p> 
<p>有时候要展示一些简单的网页内容，如报告、图表等，都可以使用WebView2进行加载显示 </p> 
<p><strong>4、开发混合应用</strong></p> 
<p>借助WebView2的本机和Web互操作功能，开发混合应用，例如：网易云音乐。</p> 
<p></p> 
<p>最近我们有一个需求是需要绘制大量的图表，使用WPF的免费控件都不能很好的满足需求，后面就选择使用<strong>Echarts</strong>（Echarts是一款基于JavaScript的数据可视化图表库，提供直观，生动，可交互，可个性化定制的数据可视化图表），然后嵌入网页到WPF中来实现。</p> 
<p>本来是准备使用CEF的，同事在前期使用了<strong>WebView2</strong>，所以就继续使用<strong>WebView2</strong>。</p> 
<p>这里我写篇文章做个记录，以便以后需要时查看。注意：本文仅介绍了WebView2中的常用功能，全部功能的使用和介绍可以访问<a href="https://learn.microsoft.com/zh-cn/microsoft-edge/webview2/" rel="nofollow" title="WebView2的官方文档">WebView2的官方文档</a>。</p> 
<p></p> 
<h2><span style="color:#4da8ee;"><strong>WebView2的优点</strong></span></h2> 
<ul><li> <p>本机功能。 访问完整的本机 API 集。</p> </li><li> <p>代码共享。 向代码库添加 web 代码可以增加跨多个平台的重用。</p> </li><li> <p>Microsoft 支持。 Microsoft 在受支持的平台上提供支持并添加新功能请求。</p> </li><li> <p>定期发布更新和安全修补的最新版 Chromium。</p> </li><li> <p>已修复版本分布。 也可以在应用中打包特定版本的 Chromium 位。</p> </li><li> <p>支持Windows10/11</p> </li></ul> 
<p></p> 
<h2><span style="color:#4da8ee;"><strong>WebView2支持的平台</strong></span></h2> 
<p>编程语言</p> 
<ul><li>Win32 C/C++</li><li>.NET Framework 4.6.2 +</li><li>.NET Core 3.1 +</li><li><a href="https://learn.microsoft.com/en-us/windows/apps/winui/winui2/" rel="nofollow" title="WinUI 2.0">WinUI 2.0</a></li><li><a href="https://learn.microsoft.com/en-us/windows/apps/winui/winui3/" rel="nofollow" title="WinUI 3.0">WinUI 3.0</a></li></ul> 
<p></p> 
<p>操作系统</p> 
<ul><li>Windows 11</li><li>Windows 10</li><li>Windows 10 IoT Enterprise LTSC x32 2019</li><li>Windows 10 IoT Enterprise LTSC x64 2019</li><li>Windows 10 IoT Enterprise 21h1 x64</li><li>Windows Server 2022</li><li>Windows Server 2019</li><li>Windows Server 2016</li></ul> 
<p></p> 
<h2><span style="color:#4da8ee;"><strong>安装WebView2运行时</strong></span></h2> 
<p>如果电脑中没有安装新版本Microsoft Edge(基于Chrome内核)，就需要安装<strong>WebView2</strong>运行时。</p> 
<p>分发应用时，最好带上WebView2运行时的安装包，因为不确定用户电脑上是否会有WebView2运行时。</p> 
<p>下载地址：</p> 
<p><a href="https://go.microsoft.com/fwlink/p/?LinkId=2124703" rel="nofollow" title="https://go.microsoft.com/fwlink/p/?LinkId=2124703">https://go.microsoft.com/fwlink/p/?LinkId=2124703</a></p> 
<p></p> 
<h2><span style="color:#4da8ee;"><strong>WebView2 运行时中的进程</strong></span></h2> 
<p><strong>WebView2 进程组</strong>是 <strong>WebView2</strong> 运行时进程的集合。 <strong>WebView2 进程组</strong>包括以下内容：</p> 
<ul><li>单个浏览器进程。</li><li>一个或多个呈现器进程。</li><li>其他帮助程序进程，例如 GPU 进程和音频服务进程。</li></ul> 
<p>WebView2 进程组中的进程数和状态可能会随着 WebView2 应用程序使用 WebView2 功能而更改。 (但是，WebView2 进程组中只有一个特定的浏览器进程。) 例如，从同 <code>CoreWebView2Environment</code>一个 创建新的 WebView2 实例，但属性中 <code>Source</code> 具有不同的域，通常会启动新的呈现器进程。</p> 
<p>呈现器进程的数量可能因以下条件而异：</p> 
<ul><li> <p>在 WebView2 运行时中使用 <em>站点隔离</em> 功能。 </p> </li><li> <p>在使用相同用户数据文件夹的 WebView2 实例中呈现的不同断开连接源的数目。</p> </li></ul> 
<p>控制何时创建这些额外进程的逻辑取决于Chromium体系结构，并且超出了 WebView2 运行时的范围。</p> 
<p></p> 
<h2><span style="color:#4da8ee;"><strong>WebView2 运行时进程和用户数据文件夹</strong></span></h2> 
<p>WebView2 运行时进程集合中的所有进程都与浏览器进程相关联，浏览器进程又与单个用户数据文件夹相关联。 如果应用程序使用多个用户数据文件夹，将为其中每个用户数据文件夹创建一组 WebView2 运行时进程。</p> 
<p>用户数据文件夹可由多个应用程序共享，但请务必考虑对性能和管理的影响，如 <a href="https://learn.microsoft.com/zh-cn/microsoft-edge/webview2/concepts/user-data-folder" rel="nofollow" title="管理用户数据文件夹">管理用户数据文件夹</a>中所述。</p> 
<p class="img-center"><img alt="" height="183" src="https://images2.imgbox.com/9c/0e/HjNkdZK3_o.png" width="363"></p> 
<p>若要使用多个用户数据文件夹，WebView2 应用程序需要创建不同的 <code>CoreWebView2Environment</code> 对象。 <code>WebView2</code>通过配置的 <code>CoreWebView2Environment</code> 对象为给定的用户数据文件夹创建实例。 每个 <code>CoreWebView2Environment</code> 对象都需要配置不同的用户数据文件夹值。</p> 
<p>为给定的用户数据文件夹创建第一 <code>WebView2</code> 个实例时，将启动与该用户数据文件夹关联的 WebView2 运行时进程集合的浏览器进程。 所有其他进程将由该浏览器进程的生存期管理。</p> 
<p></p> 
<h5 id="multiple-environment-objects">多个环境对象</h5> 
<p>如果创建以相同方式配置的多个 <code>CoreWebView2Environment</code> 对象， (包括共享同一用户数据文件夹) ，则它们将表示相同的用户数据文件夹和相同的关联进程集合。 使用这些对象中的任何 <code>CoreWebView2Environment</code> 一个创建具有一个 <code>CoreWebView2</code> 共享用户数据文件夹和关联的进程集合的 。</p> 
<p>如果尝试使用另<code>CoreWebView2Environment</code>一个已使用的用户数据文件夹创建 <code>CoreWebView2Environment</code> ，并且未将两个<code>CoreWebView2Environment</code>对象配置为相同（例如，如果它们使用不同的值创建<code>CoreWebView2EnvironmentOptions.Language</code>），则第二<code>CoreWebView2Environment</code>个对象将无法创建<code>WebView2</code>对象。 </p> 
<h3 id="handling-process-events-and-lifetime"></h3> 
<h2><span style="color:#4da8ee;"><strong>在WPF中使用WebView2</strong></span></h2> 
<p>这里以<strong>Visual Studio 2022</strong>和<strong>.NET6</strong>进行演示</p> 
<p>1、使用<strong>Visual Studio</strong>创建一个<strong>WPF</strong>工程</p> 
<p>2、使用<strong>nuget</strong>引入包<strong>Microsoft.Web.WebView2</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="221" src="https://images2.imgbox.com/39/52/chSBmdkA_o.png" width="1002"></p> 
<p> 3、在<strong>XAML</strong>中引入命名空间</p> 
<pre><code class="language-XML">xmlns:webview2="clr-namespace:Microsoft.Web.WebView2.Wpf;assembly=Microsoft.Web.WebView2.Wpf"</code></pre> 
<p>4、放置一个<strong>WebView2</strong>控件</p> 
<pre><code class="language-XML">  &lt;Window x:Class="WpfWebView2Demo.MainWindow"
          xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
          xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
          xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
          xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
          xmlns:webview2="clr-namespace:Microsoft.Web.WebView2.Wpf;assembly=Microsoft.Web.WebView2.Wpf"
          xmlns:local="clr-namespace:WpfWebView2Demo"
          mc:Ignorable="d"
          Title="MainWindow" Height="720" Width="1280"&gt;
      &lt;Grid&gt;
          &lt;webview2:WebView2 x:Name="webview2" 
          Source="https://myfreetime.cn"&gt;&lt;/webview2:WebView2&gt;
      &lt;/Grid&gt;
  &lt;/Window&gt;</code></pre> 
<p></p> 
<p>5、运行效果</p> 
<p></p> 
<p class="img-center"><img alt="" height="739" src="https://images2.imgbox.com/3c/4f/DIG1QpdD_o.png" width="1200"></p> 
<p></p> 
<p><strong>注意事项：</strong></p> 
<p><strong>请将项目平台设置成x64而不是Any CPU。</strong></p> 
<p><strong>以前在使用CEF时，如果使用Any CPU，在XAML设计器会无法实时预览CEF控件，WebView2虽然没有这个问题，但是也会也现IntelliSense无法正常工作的问题。</strong></p> 
<p></p> 
<h2><span style="color:#4da8ee;"><strong>基本导航功能</strong></span></h2> 
<p>1、通过<strong>Source</strong>属性，可以设置初始<strong>URI</strong>（支持网址、本地文件等）</p> 
<p>2、导航到指定内容</p> 
<p>调用<strong>WebView2.CoreWebView2.Navigate</strong>函数即可执行导航，如</p> 
<pre>webView2.CoreWebView2.Navigate("https://www.bing.com");</pre> 
<pre>webView2.CoreWebView2.Navigate("C:\Users\xxx\Documents\说明书.pdf"); 


webView2.CoreWebView2.Navigate("file:///C:/Users/username/Documents/GitHub/Demos/demo-to-do/index.html");</pre> 
<p></p> 
<p></p> 
<p class="img-center"><img alt="" height="713" src="https://images2.imgbox.com/33/ac/3PvaPxHB_o.png" width="1200"></p> 
<p> 3、后退</p> 
<p>调用WebView2.CoreWebView2.GoBack函数即可后退</p> 
<pre>webview2.CoreWebView2.GoBack();</pre> 
<p></p> 
<p>4、前进</p> 
<p>调用WebView2.CoreWebView2.GoForward函数即可前进</p> 
<pre>webview2.CoreWebView2.GoForward();</pre> 
<p></p> 
<h2><span style="color:#4da8ee;"><strong>导航到本地内容</strong></span></h2> 
<p>WebView2提供了几种方式，可以导航到本地内容。</p> 
<p><strong>通过不同的方式加载本地内容时会有一些区别 ，如下所示</strong></p> 
<table><thead><tr><th>Scenario</th><th>导航到文件路径</th><th>导航到HTML字符串</th><th>使用虚拟主机名称映射</th><th>使用<code>WebResourceRequested</code></th></tr></thead><tbody><tr><td>Origin-based DOM APIs</td><td>✔️</td><td>❌</td><td>✔️</td><td>✔️</td></tr><tr><td>DOM APIs requiring secure context</td><td>❌</td><td>❌</td><td>✔️</td><td>✔️</td></tr><tr><td>Dynamic content</td><td>❌</td><td>✔️</td><td>❌</td><td>✔️</td></tr><tr><td>Additional web resources</td><td>✔️</td><td>❌</td><td>✔️</td><td>✔️</td></tr><tr><td>Additional web resources resolved in WebView2 process</td><td>✔️</td><td>❌</td><td>✔️</td><td>❌</td></tr></tbody></table> 
<p></p> 
<p>下面我们依次介绍各种方法</p> 
<h3><span style="color:#4da8ee;"><strong>1、直接导航到本地文件</strong></span></h3> 
<pre>this.webview2.CoreWebView2.Navigate("D:\\demo.html");</pre> 
<p></p> 
<p><strong>通过文件路径方式加载的一些限制：</strong></p> 
<ul><li>指定文件URL时，应用程序会导航到磁盘上的文件，而不是网络上的域。因此，无法在生成的文档中使用跨源资源。</li><li>从不同文件URL加载的不同文档不被视为来自同一来源，并且无法访问相同的存储数据。</li><li>某些web API仅限于安全的HTTPS URL，不适用于文件URL加载的文档。</li><li>不能使用相对路径，必须使用绝对路径</li><li>要允许从文件URI引用其他本地文件，或显示应用了XSL转换的XML文件，可以设置--allow file access from files浏览器参数。</li></ul> 
<p><strong>方法如下：</strong></p> 
<pre>1  //允许从文件URI引用其他本地文件
2  var options = new CoreWebView2EnvironmentOptions("--allow-file-access-from-files");
3  var environment = await CoreWebView2Environment.CreateAsync(options: options);
4  await webview2.EnsureCoreWebView2Async(environment);</pre> 
<ul><li>当通过文件URL加载文档时，文档的内容来自磁盘上的静态文件。这意味着无法动态修改此本地内容。这与从web服务器加载文档不同，在web服务器中，每个响应都可以动态生成。</li><li>通过文件URL加载的文档，可以引用其他web资源，如CSS、脚本或图像文件，这些文件也通过文件URL提供。</li></ul> 
<p></p> 
<p>在Windows平台下，可以指定文件的绝对路径进行访问，如</p> 
<pre>D:\demo.html</pre> 
<p></p> 
<p>如果想独立于各个平台，应该使用标准的方式指定文件路径，如</p> 
<pre>file:///D:/demo.html</pre> 
<pre>file:///C:/Users/username/Documents/GitHub/Demos/demo-to-do/index.html</pre> 
<p></p> 
<h3><span style="color:#4da8ee;"><strong>2、导航到HTML字符串</strong></span></h3> 
<p></p> 
<pre>var html = System.IO.File.ReadAllText("D:\\demo.html");
 
this.webview2.CoreWebView2.NavigateToString(html);</pre> 
<p></p> 
<p><strong>通过HTML字符串加载时，会有一些限制：</strong></p> 
<ul><li>使用NavigateToString方法加载的文档的位置设置为about:black，原点设置为null。这意味着不能使用依赖于所定义的源的web API，如localStorage或indexedDB。</li><li>某些web API仅限于安全的HTTPS URL，并且不可用于通过NavigateToString方法加载的文档，因为它们的位置设置为about:black。</li><li>通过NavigateToString方法加载本地内容时，直接将内容作为参数提供给该方法。这也就意味着可以动态显示内容。</li><li>使用NavigateToString方法加载本地内容不会使生成的文档引用其他web资源，如CSS、图像或脚本文件。该方法只允许您指定HTML文档的字符串内容，可以在HTML文档中内联表示这些（或者使用下面的两种方法）。</li></ul> 
<p></p> 
<h3><span style="color:#4da8ee;"><strong>3、使用虚拟主机映射 </strong></span></h3> 
<pre>1 //将demo映射到D:\demohtml\preview文件夹
2 this.webview2.CoreWebView2.SetVirtualHostNameToFolderMapping("demo", @"D:\demohtml\preview", CoreWebView2HostResourceAccessKind.DenyCors);
4 //可以通过https的方式访问，实际映射到D:\demohtml\preview\index.html
5 this.webview2.CoreWebView2.Navigate("https://demo/index.html");</pre> 
<p></p> 
<p>使用虚拟主机映射时，会有一些限制：</p> 
<ul><li>通过虚拟主机名映射加载的本地内容会生成一个具有HTTP或HTTPS URL和相应来源的文档。这意味着，需要localStorage或indexedDB等来源的web API将起作用，并且属于同一来源的其他文档将能够使用存储的数据。</li><li>支持HTTPS的Web API</li><li>通过虚拟主机名映射加载本地内容时，将虚拟主机名映像到磁盘上包含静态文件的本地文件夹。这意味着无法动态修改此本地内容。这与从web服务器加载文档不同，在web服务器中，每个响应都可以动态生成。</li><li>通过虚拟主机名映射加载的本地内容具有支持相对URL解析的HTTP或HTTPS URL。这意味着加载的文档可以引用其他web资源，如CSS、脚本或图像文件，这些文件也通过虚拟主机名映射提供。</li></ul> 
<p></p> 
<h3><span style="color:#4da8ee;"><strong>4、处理WebResourceRequested 事件</strong></span></h3> 
<p>当WebView2尝试加载资源时，会触发WebResourceRequested 事件，我们可以使用此事件拦截请求并提供本地内容。在WebResourceRequested事件处理函数中，可以根据每个请求自定义本地内容的行为。</p> 
<pre><code class="language-cs">  private void btn_handleWebResourceRequested_Click(object sender, RoutedEventArgs e)
   {
       //为WebResourceRequested事件添加Uri和资源上下文过滤器
       this.webview2.CoreWebView2.AddWebResourceRequestedFilter("https://demo/*", CoreWebView2WebResourceContext.All);
       this.webview2.CoreWebView2.WebResourceRequested += CoreWebView2_WebResourceRequested;       
   }
  
   private void CoreWebView2_WebResourceRequested(object? sender, CoreWebView2WebResourceRequestedEventArgs e)
   {
       //获取本地文件路径
       //注意：资源文件要放在一个路径下
       string assetsFilePath = @"D:\demohtml\preview" + e.Request.Uri.Substring("https://demo/*".Length - 1);
       try
       {
           FileStream fs = File.OpenRead(assetsFilePath);
           ManagedStream ms = new ManagedStream(fs);
           string headers = "";
           if (assetsFilePath.EndsWith(".html"))
           {
               headers = "Content-Type: text/html";
           }
           else if (assetsFilePath.EndsWith(".jpg"))
           {
               headers = "Content-Type: image/jpeg";
           }
           else if (assetsFilePath.EndsWith(".png"))
           {
               headers = "Content-Type: image/png";
           }
           else if (assetsFilePath.EndsWith(".css"))
           {
               headers = "Content-Type: text/css";
           }
           else if (assetsFilePath.EndsWith(".js"))
           {
               headers = "Content-Type: application/javascript";
           }
  
           e.Response = this.webview2.CoreWebView2.Environment.CreateWebResourceResponse(ms, 200, "OK", headers);
       }
       catch (Exception)
       {
           e.Response = this.webview2.CoreWebView2.Environment.CreateWebResourceResponse(null, 404, "Not found", "");
       }
  
   }</code></pre> 
<p></p> 
<p>ManagedStream.cs</p> 
<pre><code class="language-cs"> public class ManagedStream : Stream
  {
      public ManagedStream(Stream s)
      {
          steam = s;
      }
  
      public override bool CanRead =&gt; steam.CanRead;
  
      public override bool CanSeek =&gt; steam.CanSeek;
  
      public override bool CanWrite =&gt; steam.CanWrite;
  
      public override long Length =&gt; steam.Length;
  
      public override long Position { get =&gt; steam.Position; set =&gt; steam.Position = value; }
  
      public override void Flush()
      {
          
      }
  
      public override long Seek(long offset, SeekOrigin origin)
      {
          return steam.Seek(offset, origin);
      }
  
      public override void SetLength(long value)
      {
         
      }
  
      public override int Read(byte[] buffer, int offset, int count)
      {
          int read = 0;
          try
          {
              read = steam.Read(buffer, offset, count);
              if (read == 0)
              {
                  steam.Dispose();
              }
          }
          catch
          {
              steam.Dispose();
              throw;
          }
          return read;
      }
  
      public override void Write(byte[] buffer, int offset, int count)
      {
        
      }
  
      private Stream steam;
  }</code></pre> 
<p></p> 
<p>处理WebResourceRequested事件来加载本地内容时，也会有一些限制：</p> 
<ul><li>通过WebResourceRequested加载的本地内容会生成一个具有HTTP或HTTPS URL和相应来源的文档。这意味着，需要localStorage或indexedDB等来源的web API将起作用，并且属于同一来源的其他文档将能够使用存储的数据。</li><li>某些web API仅限于安全的HTTPS URL。使用WebResourceRequested可以将HTTPS URL web资源请求替换为我们自己的本地内容。</li><li>通过WebResourceRequested加载本地内容时，我们在事件处理程序中指定要加载的本地内容，也就是可以动态生成内容。</li><li>WebResourceRequested修改通过支持相对URL解析的HTTP或HTTPS URL加载的内容。这意味着生成的文档可以引用其他web资源，如CSS、脚本或图像文件，这些文件也通过WebResourceRequested提供。</li><li>通过文件URL或虚拟主机名映射加载内容时，解析发生在WebView2进程中。但是，WebResourceRequested事件是在宿主应用程序进程的WebView2 UI线程上引发的，这可能会导致结果文档的加载速度减慢。（如果加载的文件过多，过大，会出现界面假死的情况）</li></ul> 
<p></p> 
<p></p> 
<h2><span style="color:#4da8ee;"><strong>导航事件</strong></span></h2> 
<p>在WebView2导航到指定URI期间，会按顺序引发以下事件</p> 
<ul><li><code>NavigationStarting</code></li><li><code>SourceChanged</code></li><li><code>ContentLoading</code></li><li><code>HistoryChanged</code></li><li><code>NavigationCompleted</code></li></ul> 
<p></p> 
<p class="img-center"><img alt="" height="583" src="https://images2.imgbox.com/63/bd/CBxgmgvl_o.png" width="526"></p> 
<p></p> 
<p>如果导航失败，会按顺序引发以下事件</p> 
<ul><li><code>SourceChanged</code></li><li><code>ContentLoading</code></li><li><code>HistoryChanged</code></li></ul> 
<p></p> 
<p><strong>说明：</strong></p> 
<p><strong>在<code>NavigationStarting事件中，可以通过设置args.Cancel=true来取消导航 </code></strong></p> 
<p></p> 
<p></p> 
<h2><span style="color:#4da8ee;"><strong>本机端和 Web 端代码的互操作</strong></span></h2> 
<p><strong>Microsoft Edge WebView2</strong> 控件允许将 Web 内容嵌入本机应用程序。 可以根据需要完成的任务，以不同的方式使用 <strong>WebView2</strong>。 </p> 
<p>所以就需要本机与Web端进行互操作，例如：</p> 
<ul><li>导航到其他网站后，更新本机主机窗口标题。</li><li>从 Web 应用发送本机相机对象并使用其方法。</li><li>在应用程序的 Web 端运行专用 JavaScript 文件。</li></ul> 
<p></p> 
<p>WebView2支持以下几种互操作方式</p> 
<h3><span style="color:#4da8ee;"><strong>执行JS脚本</strong></span></h3> 
<p>这个功能对于混合开发很重要。以前我在<strong>CEFSharp</strong>中嵌入<strong>Echarts</strong>时，就是调用类似的函数将数据传到页面上。</p> 
<p><strong>WebView2</strong>提供了两种方式执行JS脚本，这两种方式都可以执行JS脚本，只是执行时机不一样</p> 
<table><thead><tr><th>API</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.web.webview2.wpf.webview2.executescriptasync" rel="nofollow" title="ExecuteScriptAsync">ExecuteScriptAsync</a></td><td>在 WebView2 控件中运行 JavaScript。 在页面 文档对象模型 (DOM) 加载内容 或 完成导航后调用此方法。</td></tr><tr><td><a href="https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.web.webview2.core.corewebview2.addscripttoexecuteondocumentcreatedasync" rel="nofollow" title="AddScriptToExecuteOnDocumentCreatedAsync">AddScriptToExecuteOnDocumentCreatedAsync</a></td><td>创建 DOM 时，在每个页面上运行。 在初始化 CoreWebView2 后调用此方法。</td></tr></tbody></table> 
<p></p> 
<h4><strong>ExecuteScriptAsync</strong></h4> 
<p>例如下面在浏览器弹框输出HelloWorld</p> 
<pre>1 await this.webview2.CoreWebView2.ExecuteScriptAsync("alert('HelloWorld')");</pre> 
<p></p> 
<p class="img-center"><img alt="" height="220" src="https://images2.imgbox.com/9d/b8/UVkvVLwg_o.png" width="721"></p> 
<p></p> 
<p><strong>ExecuteScriptAsync</strong>会返回执行结果值的<strong>JSON</strong>串。</p> 
<p>同时<strong>ExecuteScriptAsync</strong>也支持执行本地的js文件</p> 
<p>例如我在运行路径下创建了一个<strong>changecolor.js</strong></p> 
<pre>document.getElementsByTagName("body")[0].style.backgroundColor = "green";</pre> 
<p>然后加载执行：</p> 
<pre>var text = System.IO.File.ReadAllText(@"changecolor.js");
await webView2.CoreWebView2.ExecuteScriptAsync(text);</pre> 
<p> 可以看到网页背景变成了绿色</p> 
<p></p> 
<p class="img-center"><img alt="" height="606" src="https://images2.imgbox.com/f6/6e/ysWyEziA_o.png" width="864"></p> 
<p></p> 
<p></p> 
<h4><strong>AddScriptToExecuteOnDocumentCreatedAsync</strong></h4> 
<p>这个会增加一个在DOM加载但是未创建之前调用的脚本，所以可以进行一些初始始工作。</p> 
<p>例如，禁用右键菜单</p> 
<pre> 1      private async  void webview2_Loaded(object sender, RoutedEventArgs e)
 2      {
 3          await webview2.EnsureCoreWebView2Async();
 4 
 5          if(this.webview2.IsLoaded)
 6          {
 7              //禁用右键菜单
 8              await this.webview2.CoreWebView2.ExecuteScriptAsync("window.addEventListener('contextmenu', window =&gt; {window.preventDefault();});");
 9          }
10      }</pre> 
<p></p> 
<h3><span style="color:#4da8ee;"><strong>主机（应用程序）和Web页面通信</strong></span></h3> 
<p>WebView2提供了两种方式和Web页面通信</p> 
<ul><li> <p>主机使用 <code>CoreWebView2.PostWebMessageAsString</code> 或 <code>CoreWebView2.PostWebMessageAsJSON</code>将消息发布到 WebView2 控件中的 Web 内容。 消息由添加到 <code>window.chrome.webview.addEventListener</code>的处理程序捕获。</p> </li></ul> 
<ul><li> <p>WebView2 控件中的 Web 内容可以使用 将消息发布到主机 <code>window.chrome.webview.postMessage</code>。 主机使用主机上注册 <code>WebMessageReceived</code> 的任何内容处理消息。</p> </li></ul> 
<p></p> 
<h4><strong>使用PostWebMessageAsString</strong></h4> 
<p>首先我们创建一个简单的网页（因为我不会前端 ，所以这真的是一个非常简单的页面）</p> 
<p>这个页面会在收到字符串时进行打印</p> 
<p>html</p> 
<pre> &lt;!DOCTYPE html&gt;
 &lt;html&gt;
 &lt;head&gt;
     &lt;title&gt;ScenarioWebMessage&lt;/title&gt;
     &lt;script&gt;
         window.chrome.webview.addEventListener('message', arg =&gt; {
             document.writeln(arg.data)
         });
     &lt;/script&gt;
 &lt;/head&gt;
 &lt;body&gt;
    
 &lt;/body&gt;
 &lt;/html&gt;</pre> 
<p></p> 
<p> cs</p> 
<pre>this.webview2.CoreWebView2.PostWebMessageAsString(inputWindow.Input);</pre> 
<p>然后调用<strong>PostWebMessageAsString</strong>函数发送字符串到Web端，页面会进行打印</p> 
<p></p> 
<p class="img-center"><img alt="" height="162" src="https://images2.imgbox.com/c6/04/snb3z626_o.png" width="542"></p> 
<p></p> 
<h4><strong>PostWebMessageAsJson</strong></h4> 
<p>这里发送一个简单的json串来指定页面的背景图片，依旧是一个非常简单的页面</p> 
<p>html</p> 
<pre>  &lt;!DOCTYPE html&gt;
  &lt;html&gt;
  &lt;head&gt;
      &lt;title&gt;ScenarioWebMessage&lt;/title&gt;
      &lt;script&gt;
          window.chrome.webview.addEventListener('message', arg =&gt; {
               document.body.style.backgroundImage = "url('" + arg.data.background + "')";
          });
      &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
  
  &lt;/body&gt;
  &lt;/html&gt;</pre> 
<p></p> 
<p> cs</p> 
<pre>var json = "{\"background\":\"https://myfreetime.cn/usr/uploads/2024/4/%E6%B8%85%E5%B9%B3%E8%B0%83%C2%B7%E5%90%8D%E8%8A%B1%E5%80%BE%E5%9B%BD%E4%B8%A4%E7%9B%B8%E6%AC%A2/jk3.jpg\"}";

this.webview2.CoreWebView2.PostWebMessageAsJson(json);</pre> 
<p></p> 
<p>执行以后可以看到网页的背景换了</p> 
<p></p> 
<p class="img-center"><img alt="" height="578" src="https://images2.imgbox.com/4e/ef/ISvkmjRg_o.png" width="863"></p> 
<p></p> 
<h3><span style="color:#4da8ee;"><strong>将消息发送到主机</strong></span></h3> 
<p>在页面中，调用<strong>window.chrome.webview.postMessage</strong>可以将消息发送到主机</p> 
<p>首先我们创建一个html页面，在这个页面中增加一个按钮和文本框，当点击按钮时，将消息发送到主机</p> 
<p>html</p> 
<pre> &lt;!DOCTYPE html&gt;
 &lt;html&gt;
 &lt;head&gt;
     &lt;title&gt;ScenarioWebMessage&lt;/title&gt;
     &lt;script&gt;
         function SetTitleText() {
             let titleText = document.getElementById("title-text");
             window.chrome.webview.postMessage(`${titleText.value}`);
         }
     &lt;/script&gt;
 &lt;/head&gt;
 &lt;body&gt;
     &lt;div id="colorable"&gt;
         &lt;h2&gt;Receiving Messages&lt;/h2&gt;
         &lt;p&gt;
             The host app can receive messages by registering an event handler
             with &lt;code&gt;ICoreWebView2::add_WebMessageReceived&lt;/code&gt;. If you
             enter text and click "Send", this page will send a message to the
             host app which will change the text of the title bar.
         &lt;/p&gt;
         &lt;input type="text" id="title-text" /&gt;
         &lt;button οnclick="SetTitleText()"&gt;Send&lt;/button&gt;
     &lt;/div&gt;
 &lt;/body&gt;
 &lt;/html&gt;</pre> 
<p></p> 
<p>在<strong>WebView2.CoreWebView2.WebMessageReceived</strong>事件中处理接收的消息</p> 
<pre>   private void CoreWebView2_WebMessageReceived(object? sender, CoreWebView2WebMessageReceivedEventArgs e)
   {
       this.lbl_status.Content = "从网页接收到：" + e.TryGetWebMessageAsString();
   }</pre> 
<p></p> 
<p> 运行后在网页输入内容，在主机可以收到相应的内容</p> 
<p></p> 
<p class="img-center"><img alt="" height="254" src="https://images2.imgbox.com/fd/73/lZHvDHgL_o.png" width="389"></p> 
<p></p> 
<p></p> 
<p>借助以上方法，可以做到消息的闭环，可以很好地将主机和Web交互起来。</p> 
<p></p> 
<h2><span style="color:#4da8ee;"><strong>处理与进程相关的事件</strong></span></h2> 
<p><strong>WebView2</strong> 使用多个进程来支持应用程序中的 WebView2 控件。 由于这些进程可以在使用过程中退出，因此WebView2增加了一些事件通知。</p> 
<p></p> 
<p> 通俗来说，当<strong>WebView2</strong>控件初始化完成后，WebView2控件将开始监视这些进程并报告以下事件：</p> 
<ul><li> <p>任何进程失败。 当 <strong>WebView2</strong> 运行时中的任何 <em>进程</em> 失败时，<strong>CoreWebView2</strong> 将引发 事件 <strong><code>ProcessFailed</code> </strong>。</p> </li><li> <p>主浏览器进程退出。 如果main浏览器进程<em>出于任何原因</em>退出，<strong><code>CoreWebView2Environment</code></strong>则会引发 事件<strong><code>BrowserProcessExited</code></strong>。 </p> </li><li> <p>主浏览器进程崩溃。 当main浏览器进程崩溃时，它将同时生成<strong><code>ProcessFailed</code></strong>事件和<strong><code>BrowserProcessExited</code></strong>事件，因为main浏览器进程因失败<em>而退出</em>。</p> </li></ul> 
<p></p> 
<p>这里我们做一个测试，</p> 
<p>xaml</p> 
<pre>  &lt;webview2:WebView2 x:Name="webview2" Source="https://myfreetime.cn"
                     Loaded="webview2_Loaded"&gt;&lt;/webview2:WebView2&gt;</pre> 
<p>cs</p> 
<pre><code class="language-cs">   private async  void webview2_Loaded(object sender, RoutedEventArgs e)
   {
       await webview2.EnsureCoreWebView2Async();
  
       if(this.webview2.IsLoaded)
       {
           this.webview2.CoreWebView2.ProcessFailed += CoreWebView2_ProcessFailed;
           this.webview2.CoreWebView2.Environment.BrowserProcessExited += Environment_BrowserProcessExited;
       }
   }
  
   private void Environment_BrowserProcessExited(object? sender, CoreWebView2BrowserProcessExitedEventArgs e)
   {
       MessageBox.Show("Environment_BrowserProcessExited");
   }
  
   private void CoreWebView2_ProcessFailed(object? sender, Microsoft.Web.WebView2.Core.CoreWebView2ProcessFailedEventArgs e)
   {
       MessageBox.Show("CoreWebView2_ProcessFailed");   
   }</code></pre> 
<p></p> 
<p>然后我们用任务管理器关闭WebView2的一个进程，可以看到会引发 ProcessFailed 事件</p> 
<p></p> 
<p class="img-center"><img alt="" height="701" src="https://images2.imgbox.com/ba/1b/CWkIfEVw_o.png" width="1057"></p> 
<p></p> 
<p></p> 
<h2><span style="color:#4da8ee;"><strong>打印</strong></span></h2> 
<p><strong>WebView2</strong>提供了以下打印函数</p> 
<table><tbody><tr><td><code>ShowPrintUI</code></td><td>打开“WebView2 打印预览 ”对话框或操作系统的“ 打印 ”对话框。 易于实现，对自定义的支持最少。</td></tr><tr><td><code>Print</code></td><td>使用可选的以编程方式指定的打印设置将 WebView2 中的当前顶级文档打印到打印机。 可以使用此功能生成自己的“打印预览”对话框或打印体验。</td></tr><tr><td><code>PrintToPdf</code></td><td>以无提示方式将 WebView2 中的当前顶级文档打印为 PDF 文件。 可以使用它生成自己的代码来打印 PDF 文件。</td></tr><tr><td><code>PrintToPdfStream</code></td><td>以无提示方式将 WebView2 中的当前顶级文档打印到 PDF 流。 可以使用它来生成自己的代码来打印 PDF。</td></tr></tbody></table> 
<p>例如我们可以将当前网页打印为PDF</p> 
<pre>var filePath = Environment.CurrentDirectory + "\\output.pdf";
await this.webview2.CoreWebView2.PrintToPdfAsync(filePath);</pre> 
<p></p> 
<p></p> 
<h2><span style="color:#4da8ee;"><strong>自定义上下文菜单</strong></span></h2> 
<p>WebView2提供了一个默认的上下文菜单，像下面这样</p> 
<p></p> 
<p class="img-center"><img alt="" height="257" src="https://images2.imgbox.com/1f/f0/1Y1q9kXE_o.png" width="307"></p> 
<p></p> 
<p>如果想自定义上下文菜单，<strong>WebView2</strong>提供了一个<code>ContextMenuRequested</code> 事件，在事件处理函数中可以自定义上下文菜单。</p> 
<p></p> 
<p>像下面这样</p> 
<pre><code class="language-cs">   private void btn_addcontextmenu_Click(object sender, RoutedEventArgs e)
   {
       this.webview2.CoreWebView2.ContextMenuRequested += CoreWebView2_ContextMenuRequested;
   }
  
   private void CoreWebView2_ContextMenuRequested(object? sender, CoreWebView2ContextMenuRequestedEventArgs e)
   {
  
       IList&lt;CoreWebView2ContextMenuItem&gt; menuList = e.MenuItems;
       CoreWebView2Deferral deferral = e.GetDeferral();
       e.Handled = true;
       ContextMenu cm = new ContextMenu();
       cm.Closed += (s, ex) =&gt; deferral.Complete();
  
       //添加上下文菜单
       AddContextMenu();
  
       cm.IsOpen = true;
   }</code></pre> 
<p></p> 
<p>属性 <code>AreDefaultContextMenusEnabled</code> 控制是否可以打开任何上下文菜单。 如果 WebView2 <code>AreDefaultContextMenusEnabled</code> 设置设置为 <code>False</code>，则会禁用上下文菜单，并且 <code>ContextMenuRequested</code> 不会引发事件（例如用户右键单击时）。</p> 
<p>当<code>AreDefaultContextMenusEnabled</code> 属性为True时且当前网页允许显示上下文菜单时，WebView2 控件才会引发 <code>ContextMenuRequested</code> 事件。</p> 
<p> <code>AreDefaultContextMenusEnabled</code> 默认值为True。</p> 
<p></p> 
<p>在添加自定义上下文菜单之前，我们还需要了解两个类型：</p> 
<p><strong>1、System.Windows.Controls.ContextMenu类型</strong></p> 
<p>自定义上下文菜单时，需要用到ContextMenu类做为上下文菜单容器。ContextMenu是WPF自带的上下文菜单类，如果你还没有接触过，可以访问下面的链接</p> 
<p><a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.controls.contextmenu?view=windowsdesktop-8.0" rel="nofollow" title="ContextMenu Class (System.Windows.Controls) | Microsoft Learn">ContextMenu Class (System.Windows.Controls) | Microsoft Learn</a></p> 
<p></p> 
<p><strong>2、Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuItem类型</strong></p> 
<p><strong>CoreWebView2ContextMenuItem</strong>是上下文菜单容器项，<strong>WebView2</strong>没有直接使用WPF的<strong>MenuItem</strong>类型，而是新增加了一个类型</p> 
<p></p> 
<p> <strong>CoreWebView2ContextMenuItem</strong>定义的属性如下：</p> 
<table><tbody><tr><td><a href="https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.web.webview2.core.corewebview2contextmenuitem.children?view=webview2-dotnet-1.0.2592.51#microsoft-web-webview2-core-corewebview2contextmenuitem-children" rel="nofollow" title="Children">Children</a></td><td> <p>当菜单项类型是子菜单时，获取菜单项的子菜单</p> </td></tr><tr><td><a href="https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.web.webview2.core.corewebview2contextmenuitem.commandid?view=webview2-dotnet-1.0.2592.51#microsoft-web-webview2-core-corewebview2contextmenuitem-commandid" rel="nofollow" title="CommandId">CommandId</a></td><td> <p>获取CoreWebView2ContextMenuItem的命令Id</p> </td></tr><tr><td><a href="https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.web.webview2.core.corewebview2contextmenuitem.icon?view=webview2-dotnet-1.0.2592.51#microsoft-web-webview2-core-corewebview2contextmenuitem-icon" rel="nofollow" title="Icon">Icon</a></td><td> <p>获取图标，图标的来源是PNG, Bitmap 或SVG 格式的数据流(IStream)</p> </td></tr><tr><td><a href="https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.web.webview2.core.corewebview2contextmenuitem.ischecked?view=webview2-dotnet-1.0.2592.51#microsoft-web-webview2-core-corewebview2contextmenuitem-ischecked" rel="nofollow" title="IsChecked">IsChecked</a></td><td> <p>获取或设置菜单项是否被选中。</p> </td></tr><tr><td><a href="https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.web.webview2.core.corewebview2contextmenuitem.isenabled?view=webview2-dotnet-1.0.2592.51#microsoft-web-webview2-core-corewebview2contextmenuitem-isenabled" rel="nofollow" title="IsEnabled">IsEnabled</a></td><td> <p>获取或设置菜单项是否启用（仅适用于自定义菜单）.</p> </td></tr><tr><td><a href="https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.web.webview2.core.corewebview2contextmenuitem.kind?view=webview2-dotnet-1.0.2592.51#microsoft-web-webview2-core-corewebview2contextmenuitem-kind" rel="nofollow" title="Kind">Kind</a></td><td> <p>获取菜单项类型（ <a href="https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.web.webview2.core.corewebview2contextmenuitemkind?view=webview2-dotnet-1.0.2592.51" rel="nofollow" title="CoreWebView2ContextMenuItemKind">CoreWebView2ContextMenuItemKind</a>.）</p> </td></tr><tr><td><a href="https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.web.webview2.core.corewebview2contextmenuitem.label?view=webview2-dotnet-1.0.2592.51#microsoft-web-webview2-core-corewebview2contextmenuitem-label" rel="nofollow" title="Label">Label</a></td><td> <p>获取菜单项的文本，支持快捷键（使用&amp;开头）</p> </td></tr><tr><td><a href="https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.web.webview2.core.corewebview2contextmenuitem.name?view=webview2-dotnet-1.0.2592.51#microsoft-web-webview2-core-corewebview2contextmenuitem-name" rel="nofollow" title="Name">Name</a></td><td> <p>获取菜单项未本地化的名字</p> </td></tr><tr><td><a href="https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.web.webview2.core.corewebview2contextmenuitem.shortcutkeydescription?view=webview2-dotnet-1.0.2592.51#microsoft-web-webview2-core-corewebview2contextmenuitem-shortcutkeydescription" rel="nofollow" title="ShortcutKeyDescription">ShortcutKeyDescription</a></td><td> <p>获取菜单项本地化键盘快捷键</p> </td></tr></tbody></table> 
<p></p> 
<p><strong>CoreWebView2ContextMenuItem</strong>定义的事件如下</p> 
<table><tbody><tr><td><a href="https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.web.webview2.core.corewebview2contextmenuitem.customitemselected?view=webview2-dotnet-1.0.2592.51#microsoft-web-webview2-core-corewebview2contextmenuitem-customitemselected" rel="nofollow" title="CustomItemSelected">CustomItemSelected</a></td><td> <p>当用户选择了CoreWebView2ContextMenuItem，会引发CustomItemSelected事件</p> </td></tr></tbody></table> 
<p></p> 
<h3><span style="color:#4da8ee;"><strong>菜单项类型</strong></span></h3> 
<p>对于不同的元素，上下文菜单项的显示会不一样，例如，对于图片，显示的是</p> 
<p></p> 
<p class="img-center"><img alt="" height="373" src="https://images2.imgbox.com/85/1e/xEIfEQZ8_o.png" width="291"></p> 
<p>可以通过<code>ContextMenuRequested</code> 事件的参数<strong>CoreWebView2ContextMenuRequestedEventArgs.ContextMenuTarget.Kind</strong>来判断。</p> 
<p><strong>CoreWebView2ContextMenuRequestedEventArgs.ContextMenuTarget.Kind</strong>是一个<strong>CoreWebView2ContextMenuTargetKind</strong>枚举类型</p> 
<p>取值如下：</p> 
<table><tbody><tr><td id="microsoft-web-webview2-core-corewebview2contextmenutargetkind-audio">Audio</td><td>3</td><td> <p>指示 这是为音频元素创建的上下文菜单</p> </td></tr><tr><td id="microsoft-web-webview2-core-corewebview2contextmenutargetkind-image">Image</td><td>1</td><td> <p>指示 这是为图像元素创建的上下文菜单</p> </td></tr><tr><td id="microsoft-web-webview2-core-corewebview2contextmenutargetkind-page">Page</td><td>0</td><td> <p>指示为页面创建的上下文菜单不包含任何其他内容。</p> </td></tr><tr><td id="microsoft-web-webview2-core-corewebview2contextmenutargetkind-selectedtext">SelectedText</td><td>2</td><td> <p>指示是为选择的文本创建的上下文菜单</p> </td></tr><tr><td id="microsoft-web-webview2-core-corewebview2contextmenutargetkind-video">Video</td><td>4</td><td> <p>指示是为视频 元素创建的上下文菜单</p> </td></tr></tbody></table> 
<p></p> 
<h3><strong>如何移除默认上下文菜单项</strong></h3> 
<pre><code class="language-cs">   private void btn_removeimagecontextmenu_Click(object sender, RoutedEventArgs e)
   {
       this.webview2.CoreWebView2.ContextMenuRequested += CoreWebView2_ContextMenuRequested1;
   }
  
   private void CoreWebView2_ContextMenuRequested1(object? sender, CoreWebView2ContextMenuRequestedEventArgs e)
   {
       CoreWebView2ContextMenuTargetKind context = e.ContextMenuTarget.Kind;
       if (context == CoreWebView2ContextMenuTargetKind.Image)
       {
           for (int index = 0; index &lt; e.MenuItems.Count; index++)
           {
               if (e.MenuItems[index].Name == "saveImageAs")
               {
                   //移除另存为菜单项
                   e.MenuItems.RemoveAt(index);
                   break;
               }
           }
       }
   }</code></pre> 
<p></p> 
<p>移除前</p> 
<p></p> 
<p class="img-center"><img alt="" height="354" src="https://images2.imgbox.com/64/91/KU3uH5s6_o.png" width="315"></p> 
<p> 移除后</p> 
<p></p> 
<p class="img-center"><img alt="" height="301" src="https://images2.imgbox.com/db/66/VC1WeymH_o.png" width="303"></p> 
<p></p> 
<p></p> 
<h3><span style="color:#4da8ee;"><strong>如何插入菜单项到默认菜单中</strong></span></h3> 
<p>这里我们插入一个保存网页内容为PDF的菜单项</p> 
<pre><code class="language-cs">    private void CoreWebView2_ContextMenuRequested(object? sender, CoreWebView2ContextMenuRequestedEventArgs e)
    {
        iconStream = new MemoryStream(Properties.Resources.pdf);
        //创建新上下文菜单项
        CoreWebView2ContextMenuItem newItem = this.webview2.CoreWebView2.Environment.CreateContextMenuItem(
                  "保存网页为PDF", iconStream, CoreWebView2ContextMenuItemKind.Command);
        //菜单项选中事件
        newItem.CustomItemSelected += NewItem_CustomItemSelected;
        //插入到当前菜单项最后
        e.MenuItems.Insert(e.MenuItems.Count, newItem);
    }
  
    private void NewItem_CustomItemSelected(object? sender, object e)
    {
        var path = Environment.CurrentDirectory + "\\output.pdf";
        this.webview2.CoreWebView2.PrintToPdfAsync(path);
        System.Diagnostics.Process.Start("explorer.exe", $"/select, {path}");
    }</code></pre> 
<p></p> 
<p>运行效果</p> 
<p></p> 
<p class="img-center"><img alt="" height="269" src="https://images2.imgbox.com/19/36/y6vaSemE_o.png" width="265"></p> 
<p></p> 
<h3><strong>添加自定义上下文菜单</strong></h3> 
<p>通过下面的方式可以替换默认的上下文菜单，并创建自己的上下文菜单。</p> 
<p>通过这种方式创建的上下文菜单没有WebView2默认上下文菜单的外观样式，需要自己创建MenuItem的样式。</p> 
<pre><code class="language-cs">  private void CoreWebView2_ContextMenuRequested2(object? sender, CoreWebView2ContextMenuRequestedEventArgs e)
  {
      IList&lt;CoreWebView2ContextMenuItem&gt; menuList = e.MenuItems;
      CoreWebView2Deferral deferral = e.GetDeferral();
      e.Handled = true;
      ContextMenu cm = new ContextMenu();
      cm.Closed += (s, ex) =&gt; deferral.Complete();
      ReplaceContextMenu(e, menuList, cm);
      cm.IsOpen = true;
  }
 
  void ReplaceContextMenu(CoreWebView2ContextMenuRequestedEventArgs args, IList&lt;CoreWebView2ContextMenuItem&gt; menuList, ItemsControl cm)
  {
      MenuItem menuItem = new MenuItem();
      menuItem.Header = "HelloWorld";
      menuItem.IsEnabled = true;
      menuItem.Click += MenuItem_Click;
      //自定义样式
      menuItem.Style = this.FindResource("StyleMenuItem") as Style;
      cm.Items.Add(menuItem);
  }
  
  private void MenuItem_Click(object sender, RoutedEventArgs e)
  {
      MessageBox.Show("HelloWorld");
  }</code></pre> 
<p></p> 
<p>显示效果如下：</p> 
<p></p> 
<p class="img-center"><img alt="" height="82" src="https://images2.imgbox.com/9f/58/RKIZ3euw_o.png" width="222"></p> 
<p></p> 
<p></p> 
<h2><strong>示例代码</strong></h2> 
<p><a href="https://files-cdn.cnblogs.com/files/zhaotianff/WpfWebView2Demo.zip" rel="nofollow" title="点击下载">点击下载</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/068f1c76d8558f7355dc42cd04c96471/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">大数据-50 Redis 分布式锁 乐观锁 Watch SETNX Lua Redisson分布式锁 Java实现分布式锁</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cdcae92c90240e0161646b744191ec38/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">nvm-desktop window安装，支持动态切换nodejs版本</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>