<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>力扣每日一题 6/28 动态规划/数组 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/563e904d5bc88a3f513044c3687b07b9/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="力扣每日一题 6/28 动态规划/数组">
  <meta property="og:description" content="博客主页：誓则盟约系列专栏：IT竞赛 专栏关注博主，后期持续更新系列文章如果有错误感谢请大家批评指出，及时修改感谢大家点赞👍收藏⭐评论✍ 2742.给墙壁刷油漆【困难】 题目： 给你两个长度为 n 下标从 0 开始的整数数组 cost 和 time ，分别表示给 n 堵不同的墙刷油漆需要的开销和时间。你有两名油漆匠：
一位需要 付费 的油漆匠，刷第 i 堵墙需要花费 time[i] 单位的时间，开销为 cost[i] 单位的钱。一位 免费 的油漆匠，刷 任意 一堵墙的时间为 1 单位，开销为 0 。但是必须在付费油漆匠 工作 时，免费油漆匠才会工作。 请你返回刷完 n 堵墙最少开销为多少。
示例 1：
输入：cost = [1,2,3,2], time = [1,2,3,2] 输出：3 解释：下标为 0 和 1 的墙由付费油漆匠来刷，需要 3 单位时间。同时，免费油漆匠刷下标为 2 和 3 的墙，需要 2 单位时间，开销为 0 。总开销为 1 &#43; 2 = 3 。 示例 2：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-28T12:33:49+08:00">
    <meta property="article:modified_time" content="2024-06-28T12:33:49+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">力扣每日一题 6/28 动态规划/数组</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <ul><li><strong>博客主页：<a href="https://blog.csdn.net/Xxy_1008?type=blog" title="誓则盟约">誓则盟约</a></strong></li><li><strong>系列专栏：<a href="https://blog.csdn.net/xxy_1008/category_12662512.html?spm=1001.2014.3001.5482" title="IT竞赛 专栏">IT竞赛 专栏</a></strong></li><li><strong>关注博主，后期持续更新系列文章</strong></li><li><strong>如果有错误感谢请大家批评指出，及时修改</strong></li><li><strong>感谢大家点赞👍收藏⭐评论✍</strong> </li></ul> 
<hr> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c1/4a/3aZoDoB0_o.gif"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/98/5b/jWgBylXf_o.gif"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ee/30/7h1CSzQ5_o.gif"></p> 
<p></p> 
<h2>2742.给墙壁刷油漆【<span style="color:#fe2c24;">困难</span>】</h2> 
<h4><span style="color:#a2e043;">题目：</span></h4> 
<p>给你两个长度为 <code>n</code> 下标从 <strong>0</strong> 开始的整数数组 <code>cost</code> 和 <code>time</code> ，分别表示给 <code>n</code> 堵不同的墙刷油漆需要的开销和时间。你有两名油漆匠：</p> 
<ul><li>一位需要 <strong>付费</strong> 的油漆匠，刷第 <code>i</code> 堵墙需要花费 <code>time[i]</code> 单位的时间，开销为 <code>cost[i]</code> 单位的钱。</li><li>一位 <strong>免费</strong> 的油漆匠，刷 <strong>任意</strong> 一堵墙的时间为 <code>1</code> 单位，开销为 <code>0</code> 。但是必须在付费油漆匠 <strong>工作</strong> 时，免费油漆匠才会工作。</li></ul> 
<p>请你返回刷完 <code>n</code> 堵墙最少开销为多少。</p> 
<p></p> 
<p><strong>示例 1：</strong></p> 
<pre><strong>输入：</strong>cost = [1,2,3,2], time = [1,2,3,2]
<strong>输出：</strong>3
<strong>解释：</strong>下标为 0 和 1 的墙由付费油漆匠来刷，需要 3 单位时间。同时，免费油漆匠刷下标为 2 和 3 的墙，需要 2 单位时间，开销为 0 。总开销为 1 + 2 = 3 。
</pre> 
<p><strong>示例 2：</strong></p> 
<pre><strong>输入：</strong>cost = [2,3,4,2], time = [1,1,1,1]
<strong>输出：</strong>4
<strong>解释：</strong>下标为 0 和 3 的墙由付费油漆匠来刷，需要 2 单位时间。同时，免费油漆匠刷下标为 1 和 2 的墙，需要 2 单位时间，开销为 0 。总开销为 2 + 2 = 4 。
</pre> 
<p></p> 
<p><strong>提示：</strong></p> 
<ul><li><code>1 &lt;= cost.length &lt;= 500</code></li><li><code>cost.length == time.length</code></li><li><code>1 &lt;= cost[i] &lt;= 10**6</code></li><li><code>1 &lt;= time[i] &lt;= 500</code></li></ul> 
<hr> 
<h4><span style="color:#a2e043;">分析问题：</span></h4> 
<h5><strong>思路一：</strong></h5> 
<p>        首先，我们需要理解问题的本质是在给定成本和时间的列表情况下，找到满足一定体积需求的最小花费。这个问题<strong>通过定义一个 <code>dfs</code> 函数来解决，函数中的参数 <code>i</code> 表示当前考虑的物品索引，<code>j</code> 表示剩余需要的体积</strong>。</p> 
<p>        接下来，分析 <code>dfs</code> 函数的逻辑。<strong>当 <code>j &lt;= 0</code> 时，表示剩余需要的体积已经满足要求，不需要再选择物品，所以返回 <code>0</code> 。当 <code>i &lt; 0</code> 且 <code>j &gt; 0</code> 时，表示没有物品可选但仍有剩余体积需求，这是不合法的情况，所以返回正无穷大 <code>inf</code> </strong>。对于其他情况，有两种选择：一是选择当前物品，此时需要花费 <code>cost[i]</code> ，剩余需要的体积变为 <code>j - time[i] - 1</code> ，然后递归调用 <code>dfs(i - 1, j - time[i] - 1)</code> ；二是不选择当前物品，直接递归调用 <code>dfs(i - 1, j)</code> 。函数返回这两种选择中的最小值。</p> 
<p>        然后，要注意到使用了 <code>@cache</code> 装饰器进行记忆化搜索。这是为了避免重复计算相同的子问题，提高算法的效率。</p> 
<p>        最后，在 <code>paintWalls</code> 方法中，通过获取 <code>cost</code> 列表的长度 <code>n</code> ，然后调用 <code>dfs(n - 1, n)</code> 来计算最小的花费。</p> 
<h5>思路二：</h5> 
<p>        首先，定义两个匿名函数 <code>min</code> 和 <code>max</code> ，分别用于求两个数中的最小值和最大值。</p> 
<p>        然后，获取 <code>cost</code> 列表的长度 <code>n</code> ，并初始化一个列表 <code>f</code> 。 <code>f[0]</code> 设为 <code>0</code> ， <code>f[1]</code> 到 <code>f[n]</code> 设为正无穷大 <code>inf</code> 。</p> 
<p>        接下来，通过<strong>遍历 <code>cost</code> 和 <code>time</code> 列表的对应元素 <code>c</code> 和 <code>t</code> ，进行动态规划的计算</strong>。</p> 
<p>        对于每个 <code>c</code> 和 <code>t</code> ，从 <code>n</code> 到 <code>1</code> 逆序遍历 <code>f</code> 列表。对于每个 <code>j</code> ，更新 <code>f[j]</code> 的值。更新的<strong>方式是取当前的 <code>f[j]</code> 和 <code>f[max(j - t - 1, 0)] + c</code> 中的最小值。 <code>max(j - t - 1, 0)</code> 表示在考虑当前时间 <code>t</code> 的情况下，能够完成的工作量对应的索引</strong>。通过这种方式，我们在每个位置 <code>j</code> 上，都找到了使用前 <code>j</code> 个物品能够达到的最小花费。</p> 
<p>        最后，函数<strong>返回 <code>f[n]</code></strong> ，即使用所有物品能够达到的最小花费。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/84/15/jGgkx914_o.jpg"> </p> 
<h4><span style="color:#a2e043;">代码实现：</span></h4> 
<h5><span style="color:#b95514;">思路一代码实现：</span></h5> 
<pre><code class="language-python">class Solution:
    def paintWalls(self, cost: List[int], time: List[int]) -&gt; int:
        @cache  # 记忆化搜索
        def dfs(i: int, j: int) -&gt; int:  # j 表示剩余需要的体积
            if j &lt;= 0:  # 没有约束，后面什么也不用选了
                return 0
            if i &lt; 0:  # 此时 j&gt;0，但没有物品可选，不合法
                return inf
            return min(dfs(i - 1, j - time[i] - 1) + cost[i], dfs(i - 1, j))
        n = len(cost)
        return dfs(n - 1, n)
</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/dc/30/6au5hHMc_o.png"></p> 
<hr> 
<h5><span style="color:#b95514;">思路二代码实现：</span></h5> 
<pre><code class="language-python">class Solution:
    def paintWalls(self, cost: List[int], time: List[int]) -&gt; int:
        # 定义一个匿名函数min，用于求两个数的最小值
        min = lambda a, b: b if b &lt; a else a
        # 定义一个匿名函数max，用于求两个数的最大值
        max = lambda a, b: b if b &gt; a else a
        n = len(cost)
        # 初始化一个列表f，f[0]为0，f[1]到f[n]为正无穷大
        f = [0] + [float('inf')] * n
        # 遍历cost和time列表的对应元素
        for c, t in zip(cost, time):
            # 从n到1逆序遍历f列表
            for j in range(n, 0, -1):
                # 更新f[j]的值，取当前f[j]和f[max(j - t - 1, 0)] + c的最小值
                f[j] = min(f[j], f[max(j - t - 1, 0)] + c)
        # 返回f[n]，即完成所有工作的最小花费
        return f[n]</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/00/8f/Yw7aAVKJ_o.png"> </p> 
<hr> 
<h4><span style="color:#a2e043;">总结：</span></h4> 
<h5> 思路一代码详解：</h5> 
<ol><li>定义了一个内部的 <code>dfs</code> 函数，该函数使用了记忆化搜索（通过 <code>@cache</code> 装饰器实现）。<code>dfs</code> 函数接受两个参数：<code>i</code> 表示当前考虑的物品索引，<code>j</code> 表示剩余需要的体积。</li><li>在 <code>dfs</code> 函数中，如果 <code>j &lt;= 0</code> ，表示剩余需要的体积已经满足要求，不需要再选择物品，返回 <code>0</code> 。</li><li>如果 <code>i &lt; 0</code> 且 <code>j &gt; 0</code> ，表示没有物品可选但仍有剩余体积需求，这种情况是不合法的，返回 <code>inf</code> （表示正无穷大）。</li><li>对于其他情况，有两种选择： 
  <ul><li>选择当前物品（索引为 <code>i</code> ），那么需要花费 <code>cost[i]</code> ，并且剩余需要的体积变为 <code>j - time[i] - 1</code> ，然后递归调用 <code>dfs(i - 1, j - time[i] - 1)</code> 。</li><li>不选择当前物品，直接递归调用 <code>dfs(i - 1, j)</code> 。</li></ul></li><li>最后，函数返回这两种选择中的最小值。</li><li>在 <code>paintWalls</code> 方法中，首先获取 <code>cost</code> 列表的长度 <code>n</code> ，然后调用 <code>dfs(n - 1, n)</code> 来计算最小的花费。</li></ol> 
<p>        总的来说，这段代码的目的是<strong>通过递归的方式</strong>，在考虑每个物品的选择与否的情况下，计算出满足剩余体积需求的最小花费。<strong>记忆化搜索的使用可以避免重复计算，提高算法的效率</strong>。</p> 
<hr> 
<p><strong>考点</strong>：</p> 
<ol><li>动态规划：两段代码都运用了动态规划的思想来解决问题。通过定义合适的状态（如代码中的 <code>f</code> 数组）和状态转移方程（如更新 <code>f[j]</code> 的值），来逐步求解最优解。</li><li>函数定义与使用：代码中定义了匿名函数（如 <code>min</code> 和 <code>max</code> 函数）来简化比较和操作。</li><li>列表操作：涉及到列表的初始化、遍历（正序和逆序）以及元素的更新。</li><li>逻辑推理与问题分析：需要理解问题的要求，找出合适的解法，并将其转化为代码实现。</li></ol> 
<p> </p> 
<p><strong>收获</strong>：</p> 
<ol><li>深入理解动态规划的概念和应用：通过实际解决这个问题，更加熟悉如何根据问题的特点定义状态和状态转移方程，从而有效地运用动态规划来求解最优解。</li><li>提高函数使用和定义的能力：学会了使用匿名函数来简洁地表达一些常见的操作，增强了代码的可读性和简洁性。</li><li>增强对列表数据结构的操作能力：包括列表的初始化、遍历和元素的修改，能够更加熟练地运用列表来解决实际问题。</li><li>培养逻辑思维和问题分析能力：在理解问题的基础上，能够将其转化为有效的算法和代码实现，提高了解决复杂问题的能力。</li><li>学会从不同的角度思考问题：两段代码虽然都解决了同一个问题，但实现方式略有不同，通过对比学习，可以拓宽解题思路，提高解决问题的灵活性。</li></ol> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/85/eb/Gy4d3A7m_o.jpg"></p> 
<h2 style="text-align:center;"><span style="color:#0d0016;"><span style="background-color:#98c091;">“祈愿万家灯火熨烫过脉络，刀山与火海多深刻，都陪你渡过。”——《不痛》 </span></span></h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c3059872532c0990531520ec03844696/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Kubernetes (K8s) 底层原理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/874796bb17deab04c4fe00b5e03c7fc5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2023年第十四届蓝桥杯JavaB组省赛真题及全部解析（上）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>