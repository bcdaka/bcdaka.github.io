<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>微服务间调用 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/d7a7f34178293590c9a8e3c135de825d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="微服务间调用">
  <meta property="og:description" content="一、restTemplate 1、先将restTemplate注册成为一个bean @Configuration public class RemoteCallConfig { @Bean public RestTemplate restTemplate() { return new RestTemplate(); } } 2、实现代码 private void handleCartItems(List&lt;CartVO&gt; vos) { // TODO 1.获取商品id Set&lt;Long&gt; itemIds = vos.stream().map(CartVO::getItemId).collect(Collectors.toSet()); // 2.查询商品 // List&lt;ItemDTO&gt; items = itemService.queryItemByIds(itemIds); // 2.1.利用RestTemplate发起http请求，得到http的响应 ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; response = restTemplate.exchange( &#34;http://localhost:8081/items?ids={ids}&#34;, HttpMethod.GET, null, new ParameterizedTypeReference&lt;List&lt;ItemDTO&gt;&gt;() { }, Map.of(&#34;ids&#34;, CollUtil.join(itemIds, &#34;,&#34;)) ); // 2.2.解析响应 if(!response.getStatusCode().is2xxSuccessful()){ // 查询失败，直接结束 return; } List&lt;ItemDTO&gt; items = response.getBody(); if (CollUtils.isEmpty(items)) { return; } // 3.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-28T15:42:31+08:00">
    <meta property="article:modified_time" content="2024-08-28T15:42:31+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">微服务间调用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="restTemplate_0"></a>一、restTemplate</h2> 
<h3><a id="1restTemplatebean_1"></a>1、先将restTemplate注册成为一个bean</h3> 
<pre><code>@Configuration
public class RemoteCallConfig {
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
</code></pre> 
<h3><a id="2_11"></a>2、实现代码</h3> 
<pre><code>private void handleCartItems(List&lt;CartVO&gt; vos) {
    // TODO 1.获取商品id
    Set&lt;Long&gt; itemIds = vos.stream().map(CartVO::getItemId).collect(Collectors.toSet());
    // 2.查询商品
    // List&lt;ItemDTO&gt; items = itemService.queryItemByIds(itemIds);
    // 2.1.利用RestTemplate发起http请求，得到http的响应
    ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; response = restTemplate.exchange(
            "http://localhost:8081/items?ids={ids}",
            HttpMethod.GET,
            null,
            new ParameterizedTypeReference&lt;List&lt;ItemDTO&gt;&gt;() {
            },
            Map.of("ids", CollUtil.join(itemIds, ","))
    ); 
    // 2.2.解析响应
    if(!response.getStatusCode().is2xxSuccessful()){
        // 查询失败，直接结束
        return;
    }
    List&lt;ItemDTO&gt; items = response.getBody();
    if (CollUtils.isEmpty(items)) {
        return;
    }
    // 3.转为 id 到 item的map
    Map&lt;Long, ItemDTO&gt; itemMap = items.stream().collect(Collectors.toMap(ItemDTO::getId, Function.identity()));
    // 4.写入vo
    for (CartVO v : vos) {
        ItemDTO item = itemMap.get(v.getItemId());
        if (item == null) {
            continue;
        }
        v.setNewPrice(item.getPrice());
        v.setStatus(item.getStatus());
        v.setStock(item.getStock());
    }
}
</code></pre> 
<h2><a id="openFeign_50"></a>二、openFeign</h2> 
<h3><a id="1__51"></a>1、 引入依赖</h3> 
<pre><code>  &lt;!--openFeign--&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
      &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
  &lt;/dependency&gt;
  &lt;!--负载均衡器--&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
      &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;
  &lt;/dependency&gt;
</code></pre> 
<h3><a id="2OpenFeign_65"></a>2、启用OpenFeign</h3> 
<pre><code>SpringBoot启动类，加上注解@EnableFeignClients
</code></pre> 
<h3><a id="3openFeign_70"></a>3、编写openFeign客户端</h3> 
<pre><code>//item-service微服务名称
@FeignClient("item-service")
public interface ItemClient {
	//yml中的，nacos配置的ip和端口(nacos,可以看我这个专栏),会自动拼上路径
	//ip+端口/items/ids= x,x , x,
    @GetMapping("/items")
    List&lt;ItemDTO&gt; queryItemByIds(@RequestParam("ids") Collection&lt;Long&gt; ids);
}
</code></pre> 
<p>这里只需要声明接口，无需实现方法。接口中的几个关键信息：</p> 
<ul><li>@FeignClient(“item-service”) ：声明服务名称</li><li>@GetMapping ：声明请求方式</li><li>@GetMapping(“/items”) ：声明请求路径</li><li>@RequestParam(“ids”) Collection ids ：声明请求参数</li><li>List ：返回值类型</li></ul> 
<p>有了上述信息，OpenFeign就可以利用动态代理帮我们实现这个方法，发送一个GET请求，携带ids为请求参数，并自动将返回值处理为List。<br> 我们只需要直接调用这个方法，即可实现远程调用了。</p> 
<h3><a id="4_92"></a>4、使用接口</h3> 
<p>1、注入ItemClient<br> 2、调用ItemClient 中的方法，接收返回值</p> 
<h3><a id="5_95"></a>5、连接池</h3> 
<p>Feign底层发起http请求，依赖于其它的框架。其底层支持的http客户端实现包括：</p> 
<ul><li>HttpURLConnection：默认实现，不支持连接池</li><li>Apache HttpClient ：支持连接池</li><li>OKHttp：支持连接池<br> 因此我们通常会使用带有连接池的客户端来代替默认的HttpURLConnection。比如，我们使用OK Http.</li></ul> 
<h4><a id="_101"></a>引入依赖</h4> 
<pre><code>&lt;!--OK http 的依赖 --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;
  &lt;artifactId&gt;feign-okhttp&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre> 
<h4><a id="_110"></a>开启连接池</h4> 
<pre><code>feign:
  okhttp:
    enabled: true # 开启OKHttp功能
</code></pre> 
<h3><a id="6openFeign_117"></a>6、openFeign最佳实践</h3> 
<h4><a id="_118"></a>思路分析</h4> 
<ul><li>思路1：抽取到微服务之外的公共module</li><li>思路2：每个微服务自己抽取一个module</li></ul> 
<p><img src="https://images2.imgbox.com/f0/5b/3LRQaEIS_o.png" alt=""><br> 方案1抽取更加简单，工程结构也比较清晰，但缺点是整个项目耦合度偏高。<br> 方案2抽取相对麻烦，工程结构相对更复杂，但服务之间耦合度降低。</p> 
<p>正常小型微服务项目可以选择，耦合度偏高的maven聚合工程</p> 
<h4><a id="module_128"></a>新建一个微服务module</h4> 
<p>新建之后，引入openFeign需要的坐标，以及负载均衡坐标，服务建立完毕后；<br> 服务建立完毕后，在消费者的微服务模块，引入maven坐标，即可调用里面的方法；</p> 
<h4><a id="_131"></a>消费者启动类扫描对应包</h4> 
<p>1、@EnableFeignClients(basePackages=“消费者调用生产者对应的报名”)<br> 2、@EnableFeignClients(clients={生产者的字节码文件(也就是[a.class])})<br> 例子：@EnableFeignClients(clients={A.class})</p> 
<h3><a id="7_136"></a>7、日志输出</h3> 
<p>OpenFeign只会在FeignClient所在包的日志级别为DEBUG时，才会输出日志。而且其日志级别有4级：</p> 
<ul><li>NONE：不记录任何日志信息，这是默认值。</li><li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li><li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li><li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。<br> Feign默认的日志级别就是NONE，所以默认我们看不到请求日志。</li></ul> 
<pre><code>logging：
	level:
		监控日志包名:debug
</code></pre> 
<h4><a id="module_149"></a>通用的module中定义日志级别</h4> 
<pre><code>public class DefaultFeignConfig {
    @Bean
    public Logger.Level feignLogLevel(){
        return Logger.Level.FULL;
    }
}
</code></pre> 
<h4><a id="_159"></a>消费者启动类加注解</h4> 
<p>平时不建议开启，在出现错误时候，可以开启排查错误</p> 
<pre><code>@EnableFeignClients(defaultConfiguration = DefaultFeignConfig.class)
</code></pre> 
<h2><a id="httpClient_165"></a>三、httpClient</h2> 
<p>可以看我之前苍穹外卖的博客</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1b274f5c548d7fb1d409a926250e5065/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C# for语句</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8786ca1ad34c19eb465a1e6ebe847fd5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">以阅读为翼,将英语学习融入青少年生活日常</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>