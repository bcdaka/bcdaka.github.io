<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>批发行业进销存-webview 读取NFC，会员卡 源码CyberWinApp-SAAS 本地化及未来之窗行业应用跨平台架构 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/aecd8f217411c5c5504f332f6ffdd86d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="批发行业进销存-webview 读取NFC，会员卡 源码CyberWinApp-SAAS 本地化及未来之窗行业应用跨平台架构">
  <meta property="og:description" content="一、混合应用开发 混合应用顾名思义就是网页html和原生APP共同作用的结果
好处在一既有web的跨平台优势（安卓、苹果，电脑、国产电脑、平板电脑，自助机都能用）
好处二可以离线使用，比较稳定
好处三可以与本地硬件交互
二、web调用本地资源 web调用本地交互采用jsapi
代码示例
public WebView cwpd_Web;
java未来之窗内部插件 csp = new java未来之窗内部插件d(main_instance); webview.addJavascriptInterface(new 未来之窗交互(this, this), &#34;未来之窗交互名称&#34;); js调用方式
未来之窗交互名称.读取酒店门锁(酒店门锁厂家)
三、android调用web android 一般不知道当前web情况，一般采用2中方式
1.web不断轮询查询检测结果
缺点：消耗web资源，优点，技术要求低
2.采用webview内部通知机制
优点：不消耗内部资源，缺点：需要了解系统底层
四、webview调用NFC 权限
&lt;uses-permission android:name=&#34;android.permission.NFC&#34; /&gt; &lt;uses-feature android:name=&#34;android.hardware.nfc&#34; /&gt; nfc 资源库
import android.nfc.NdefMessage; import android.nfc.NdefRecord; import android.nfc.NfcAdapter; import android.nfc.Tag; import android.nfc.tech.MifareClassic; import android.nfc.tech.MifareUltralight; import android.nfc.tech.NfcA; nfc 服务
private NfcAdapter NFC_mAdapter2023; private NdefMessage mNdefPushMessage; private PendingIntent mPendingIntent; nfc 服务启动
resolveIntent(getIntent()); NFC_mAdapter2023 = NfcAdapter.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-11T02:55:09+08:00">
    <meta property="article:modified_time" content="2024-08-11T02:55:09+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">批发行业进销存-webview 读取NFC，会员卡 源码CyberWinApp-SAAS 本地化及未来之窗行业应用跨平台架构</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="1200" src="https://images2.imgbox.com/60/01/pNwzk3Mk_o.jpg" width="1200"></p> 
<h2>一、混合应用开发</h2> 
<p>混合应用顾名思义就是网页html和原生APP共同作用的结果</p> 
<p>好处在一既有web的跨平台优势（安卓、苹果，电脑、国产电脑、平板电脑，自助机都能用）</p> 
<p>好处二可以离线使用，比较稳定</p> 
<p>好处三可以与本地硬件交互</p> 
<h2>二、web调用本地资源</h2> 
<p>web调用本地交互采用jsapi</p> 
<p>代码示例</p> 
<p> public WebView cwpd_Web;</p> 
<pre><code class="hljs">   java未来之窗内部插件 csp = new java未来之窗内部插件d(main_instance);
</code></pre> 
<pre><code class="hljs"> webview.addJavascriptInterface(new 未来之窗交互(this, this), "未来之窗交互名称"); </code></pre> 
<p>js调用方式</p> 
<p>未来之窗交互名称.读取酒店门锁(酒店门锁厂家)</p> 
<h2>三、android调用web</h2> 
<p>android 一般不知道当前web情况，一般采用2中方式</p> 
<p>1.web不断轮询查询检测结果</p> 
<p>缺点：消耗web资源，优点，技术要求低</p> 
<p>2.采用webview内部通知机制</p> 
<p>优点：不消耗内部资源，缺点：需要了解系统底层</p> 
<h2>四、webview调用NFC</h2> 
<p>权限</p> 
<pre><code class="language-javascript">    &lt;uses-permission android:name="android.permission.NFC" /&gt;
    &lt;uses-feature android:name="android.hardware.nfc" /&gt;</code></pre> 
<p>nfc 资源库</p> 
<pre><code class="language-java">import android.nfc.NdefMessage;
import android.nfc.NdefRecord;
import android.nfc.NfcAdapter;
import android.nfc.Tag;
import android.nfc.tech.MifareClassic;
import android.nfc.tech.MifareUltralight;
import android.nfc.tech.NfcA;</code></pre> 
<p>nfc 服务</p> 
<pre><code class="language-java">  private NfcAdapter NFC_mAdapter2023;
    private NdefMessage mNdefPushMessage;
    private PendingIntent mPendingIntent;</code></pre> 
<p>nfc 服务启动</p> 
<pre><code class="language-java">    resolveIntent(getIntent());
            NFC_mAdapter2023 = NfcAdapter.getDefaultAdapter(this);
            //初始化NfcAdapter
            LogToFile.d_windows("nfc","nfc调式记录","初始化NfcAdapter");
            if (NFC_mAdapter2023 == null) {
               // showMessage("无设备", "没有NFC设备");
               // finish();
               // return;
            }else {
                LogToFile.d_windows("nfc","nfc调式记录","NFC正常");
                //初始化PendingIntent
                mPendingIntent = PendingIntent.getActivity(this, 0,
                        new Intent(this, getClass()).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP), 0);

               // mPendingIntent = PendingIntent.getActivity(this, 0, new Intent(this, getClass()), 0);

                LogToFile.d_windows("nfc","nfc调式记录","初始化PendingIntent");

                mNdefPushMessage = new NdefMessage(new NdefRecord[]{
                        newTextRecord(
                         "Message from NFC Reader :-)", Locale.ENGLISH, true)}
                        );
            }</code></pre> 
<p>android宿主</p> 
<pre><code class="language-java">  protected void onResume() {
   
        if (NFC_mAdapter2023 != null) {
            if (!NFC_mAdapter2023.isEnabled()) {
                showWirelessSettingsDialog();
            }
            NFC_mAdapter2023.enableForegroundDispatch(this, mPendingIntent, null, null);
            NFC_mAdapter2023.enableForegroundNdefPush(this, mNdefPushMessage);
        }
    }</code></pre> 
<h2>五、android 检测NFC并通知web html</h2> 
<pre><code class="language-java"> private void resolveIntent(Intent intent) {
        String action = intent.getAction();
        if (NfcAdapter.ACTION_TAG_DISCOVERED.equals(action)
                || NfcAdapter.ACTION_TECH_DISCOVERED.equals(action)
                || NfcAdapter.ACTION_NDEF_DISCOVERED.equals(action)) {
            Parcelable[] rawMsgs = intent.getParcelableArrayExtra(NfcAdapter.EXTRA_NDEF_MESSAGES);
            NdefMessage[] msgs;
            if (rawMsgs != null) {
                msgs = new NdefMessage[rawMsgs.length];
                for (int i = 0; i &lt; rawMsgs.length; i++) {
                    msgs[i] = (NdefMessage) rawMsgs[i];
                }
            } else {
                // Unknown tag type
                byte[] empty = new byte[0];
                byte[] id = intent.getByteArrayExtra(NfcAdapter.EXTRA_ID);
                Tag tag = (Tag) intent.getParcelableExtra(NfcAdapter.EXTRA_TAG);

                String 未来之窗NFC=dumpTagData(tag);
               // LogToFile.d_windows();
                LogToFile.d_windows("nfc","nfc调式记录",未来之窗NFC);
              
                String 未来之窗反向js2 = "javascript:" + "未来之窗人工智能交互" + "(\"nfc_reader\",`" + 未来之窗NFC + "`)";
/*
                webview.evaluateJavascript(未来之窗反向js, new ValueCallback&lt;String&gt;() {
                            @Override
                            public void onReceiveValue(String value) {
                               // LogUtil.e(TAG, "getPayId onReceiveValue " + functionName);
                            }
                        }
                         );
*/
                cwpd_Web.evaluateJavascript(未来之窗反向js2, new ValueCallback&lt;String&gt;() {
                            @Override
                            public void onReceiveValue(String value) {
                                // LogUtil.e(TAG, "getPayId onReceiveValue " + functionName);
                            }
                        }
                );
                byte[] payload = 未来之窗NFC.getBytes();
                NdefRecord record = new NdefRecord(NdefRecord.TNF_UNKNOWN, empty, id, payload);
                NdefMessage msg = new NdefMessage(new NdefRecord[] { record });
                msgs = new NdefMessage[] { msg };
               // mTags.add(tag);
            }
            // Setup the views
           // buildTagViews(msgs);
        }
    }</code></pre> 
<h2>六、web接受端</h2> 
<pre><code class="language-javascript">function cyberWin_Device_AIOT_Monitor(action,param){
	// alert("类型："+action);
	//  alert(param);

	  var 未来之窗json = eval("("+param+")");//转换为json对象
	  // alert(未来之窗json.id_dec);
	  

 

	  
	  

}</code></pre> 
<p>到此设备上刷卡web就会通知</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0b44f3e1e0448905c5ec3b0d8d999f60/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">人工智能时代，程序员如何保持核心竞争力？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dd5d9769db3f212c68b8b344480b81d4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Flink-DataWorks第六部分：数据运维（第62天）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>