<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>《LeetCode热题100》---＜5.②普通数组篇五道＞ - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/3318b2082569fd399f09bf489adb6e95/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="《LeetCode热题100》---＜5.②普通数组篇五道＞">
  <meta property="og:description" content="本篇博客讲解LeetCode热题100道普通数组篇中的五道题
第三道：轮转数组（中等）
第四道：除自身以外数组的乘积（中等）
第三道：轮转数组（中等） 方法一：使用额外的数组 class Solution { public void rotate(int[] nums, int k) { int len = nums.length; int[] newArr = new int[len]; for (int i = 0; i &lt; len; &#43;&#43;i) { newArr[(i &#43; k) % len] = nums[i]; } System.arraycopy(newArr, 0, nums, 0, len); } } 1.新建一个nums数组长度的数组。
2.轮转k次。因此我们将从(i &#43; k) % len开始，将nums数组中的值依次赋值给新数组。
3.最终将新数组中的值拷贝回原来的数组。
时间复杂度： O(n)，其中 n 为数组的长度。
空间复杂度： O(n)。
方法二：数组翻转 ​​​​​​class Solution { public void rotate(int[] nums, int k) { k %= nums.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-03T23:33:27+08:00">
    <meta property="article:modified_time" content="2024-08-03T23:33:27+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《LeetCode热题100》---＜5.②普通数组篇五道＞</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>本篇博客讲解LeetCode热题100道<strong>普通数组篇</strong>中的五道题</p> 
 <p>第三道：轮转数组（中等）</p> 
 <p>第四道：除自身以外数组的乘积（中等）</p> 
</blockquote> 
<h2><a class="link-info" href="https://leetcode.cn/problems/rotate-array/description/?envType=study-plan-v2&amp;envId=top-100-liked" rel="nofollow" title="第三道：轮转数组（中等）">第三道：轮转数组（中等）</a></h2> 
<p><img alt="" height="811" src="https://images2.imgbox.com/a2/44/tcrQQMn6_o.png" width="1003"></p> 
<h3> 方法一：使用额外的数组</h3> 
<pre><code class="language-java">class Solution {
    public void rotate(int[] nums, int k) {
        int len = nums.length;
        int[] newArr = new int[len];
        for (int i = 0; i &lt; len; ++i) {
            newArr[(i + k) % len] = nums[i];
        }
        System.arraycopy(newArr, 0, nums, 0, len);
    }
}</code></pre> 
<blockquote> 
 <p> 1.新建一个nums数组长度的数组。</p> 
 <p>2.轮转k次。因此我们将从<span style="color:#fe2c24;">(i + k) % len</span>开始，将nums数组中的值依次赋值给新数组。</p> 
 <p>3.最终将新数组中的值拷贝回原来的数组。</p> 
 <p></p> 
 <p><strong>时间复杂度：</strong> O(n)，其中 n 为数组的长度。</p> 
 <p><strong>空间复杂度：</strong> O(n)。</p> 
</blockquote> 
<h3>方法二：数组翻转</h3> 
<pre><code class="language-java">​​​​​​class Solution {
    public void rotate(int[] nums, int k) {
        k %= nums.length;
        reverse(nums, 0, nums.length - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.length - 1);
    }

    public void reverse(int[] nums, int start, int end) {
        while (start &lt; end) {
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            start += 1;
            end -= 1;
        }
    }
}</code></pre> 
<blockquote> 
 <p><strong>翻转的思想：</strong>轮转k个位置，那么也就相当于先将数组翻转。之后再翻转（0，k-1）这个位置的元素。再翻转（k，n-1）这个位置的元素。下如图演示。</p> 
</blockquote> 
<p><img alt="" height="579" src="https://images2.imgbox.com/63/53/mXPZl14c_o.png" width="804"></p> 
<h2><a class="link-info" href="https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&amp;envId=top-100-liked" rel="nofollow" title="第四道：除自身以外数组的乘积（中等）">第四道：除自身以外数组的乘积（中等）</a></h2> 
<p><img alt="" height="721" src="https://images2.imgbox.com/94/4a/pO08mra0_o.png" width="1156"></p> 
<h3> 方法一：前缀之积乘以后缀之积</h3> 
<pre><code class="language-java">class Solution {
    public int[] productExceptSelf(int[] nums) {
        int length = nums.length;

        // L 和 R 分别表示左右两侧的乘积列表
        int[] L = new int[length];
        int[] R = new int[length];

        int[] answer = new int[length];

        // L[i] 为索引 i 左侧所有元素的乘积
        // 对于索引为 '0' 的元素，因为左侧没有元素，所以 L[0] = 1
        L[0] = 1;
        for (int i = 1; i &lt; length; i++) {
            L[i] = nums[i - 1] * L[i - 1];
        }

        // R[i] 为索引 i 右侧所有元素的乘积
        // 对于索引为 'length-1' 的元素，因为右侧没有元素，所以 R[length-1] = 1
        R[length - 1] = 1;
        for (int i = length - 2; i &gt;= 0; i--) {
            R[i] = nums[i + 1] * R[i + 1];
        }

        // 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积
        for (int i = 0; i &lt; length; i++) {
            answer[i] = L[i] * R[i];
        }

        return answer;
    }
}
</code></pre> 
<blockquote> 
 <p>1.新建一两个数组长度为nums的长度。一个L存前缀之积，一个R存后缀之积</p> 
 <p>2.L[i] 表示索引 i 左侧所有元素的乘积，因为索引为 '0' 的元素左侧没有元素， 所以 L[0] = 1</p> 
 <p>3.for循环从1开始，计算每个元素的前缀之积 L[i] = nums[i - 1] * L[i - 1];</p> 
 <p>4.再从后往前遍历计算后缀之积。R[length - 1] = 1;。R[i] = nums[i + 1] * R[i + 1];得到后缀之积。</p> 
 <p>5.     for (int i = 0; i &lt; length; i++) {<!-- --><br>             answer[i] = L[i] * R[i];<br>         }</p> 
 <p>6.最终返回answer。</p> 
</blockquote> 
<blockquote> 
 <p><strong>时间复杂度：</strong>O(N)，其中 N 指的是数组 nums 的大小。预处理 L 和 R 数组以及最后的遍历计算都是 O(N) 的时间复杂度。<br><strong>空间复杂度：</strong>O(N)，其中 N 指的是数组 nums 的大小。使用了 L 和 R 数组去构造答案，L 和 R 数组的长度为数组 nums 的大小 </p> 
</blockquote> 
<h3>方法二：方法一的进阶，空间复杂度 O(1) 的方法 </h3> 
<pre><code class="language-java">class Solution {
    public int[] productExceptSelf(int[] nums) {
        int length = nums.length;
        int[] answer = new int[length];

        // answer[i] 表示索引 i 左侧所有元素的乘积
        // 因为索引为 '0' 的元素左侧没有元素， 所以 answer[0] = 1
        answer[0] = 1;
        for (int i = 1; i &lt; length; i++) {
            answer[i] = nums[i - 1] * answer[i - 1];
        }

        // R 为右侧所有元素的乘积
        // 刚开始右边没有元素，所以 R = 1
        int R = 1;
        for (int i = length - 1; i &gt;= 0; i--) {
            // 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R
            answer[i] = answer[i] * R;
            // R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上
            R *= nums[i];
        }
        return answer;
    }
}
</code></pre> 
<blockquote> 
 <p>1.新建一个answer数组长度为nums的长度。</p> 
 <p>2.answer[i] 表示索引 i 左侧所有元素的乘积，因为索引为 '0' 的元素左侧没有元素， 所以 answer[0] = 1</p> 
 <p>3.for循环从1开始，计算每个元素的前缀之积answer[i] = nums[i - 1] * answer[i - 1];</p> 
 <p>4.再从后往前遍历计算后缀之积。R 为右侧所有元素的乘积。开始R=1。从n-1开始遍历。令</p> 
 <p>answer[i] = answer[i] * R;得到最终答案。R *= nums[i];得到后缀之积。</p> 
 <p>5.最终返回answer。</p> 
</blockquote> 
<blockquote> 
 <p><strong>时间复杂度：</strong>O(N)，其中 N 指的是数组 nums 的大小。分析与方法一相同。<br><strong>空间复杂度：</strong>O(1)，输出数组不算进空间复杂度中，因此我们只需要常数的空间存放变量。</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/057ce98eef8b7e1a82e5f73b22282550/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据结构初阶：栈和队列</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/29893dfa05ee52f57ff9fe80cfd5e76f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java 并发编程：Java 中的乐观锁与 CAS</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>