<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【二叉树】—— 算法题 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/1a6f1f5e751c692470ab33d6f589a078/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【二叉树】—— 算法题">
  <meta property="og:description" content="一、单值二叉树 题目要求：判断二叉树是不是单值二叉树（就是所以节点的值都相等）。
思路：
利用二叉树的递归思想，判断每一个节点值与其左右子节点的值是否相等，如果遇到空节点，就返回true（说明每一个节点值都相等）；如果遇到节点的值与其左右节点值不相等就返回false；如果该节点的值与其左右子节点的值都相等，就接着递归该节点的左右子树。
代码如下：
bool isUnivalTree(struct TreeNode* root) { if (root == NULL) { return true; } if (root-&gt;left &amp;&amp; root-&gt;left-&gt;val != root-&gt;val) { return false; } if (root-&gt;right &amp;&amp; root-&gt;right-&gt;val != root-&gt;val) { return false; } return isUnivalTree(root-&gt;left) &amp;&amp; isUnivalTree(root-&gt;right); } 二、相同的树 — 对称二叉树 — 另一颗树的子树 2.1、相同的树 判断两个二叉树是否相等
思路：
同时遍历两个二叉树，如果遍历到两个二叉树节点同时为空，就说明这两个二叉树相同；如果其中一个为空而另一个不为空，就说明两个二叉树不相同；如果遍历过程中，遇到两个二叉树节点的值不相等，则两个二叉树不相同。
简单分析一下：
同时遍历这两个二叉树
两个二叉树节点都不为空且值相等，继续遍历其左子树
两个二叉树节点都不为空且值相等，继续遍历其左子树
两个二叉树节点都为空，返回true
先遍历二叉树是2节点的右节点，也为空，这里直接跳过了。
这里回退到1这个节点，接下来遍历1的右子树
遍历到节点都不为空，且值相等，继续遍历 （这因为3的左右节点都为空，就一步带过）
遍历结束，没有遇到一个节点为空一个节点不为空或者值不相等的情况，就返回true。
代码如下：
typedef struct TreeNode TreeNode; bool isSameTree(struct TreeNode* p, struct TreeNode* q) { if (p == NULL &amp;&amp; q == NULL) { return true; } if (p == NULL || q == NULL) { return false; } if (p-&gt;val !">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-28T21:52:15+08:00">
    <meta property="article:modified_time" content="2024-07-28T21:52:15+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【二叉树】—— 算法题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="background-color:transparent;">一、<a class="link-info" href="https://leetcode.cn/problems/univalued-binary-tree/description/" rel="nofollow" title="单值二叉树">单值二叉树</a></h2> 
<p><img alt="" height="560" src="https://images2.imgbox.com/39/d8/VkXQdLcH_o.png" width="810"></p> 
<p>        题目要求：判断二叉树是不是单值二叉树（就是所以节点的值都相等）。</p> 
<p><span style="color:#4da8ee;"><strong>思路：</strong></span></p> 
<blockquote> 
 <p><span style="color:#4da8ee;"><strong>        </strong></span><span style="color:#0d0016;"><strong><span style="background-color:#38d8f0;">利用二叉树的递归思想，判断每一个节点值与其左右子节点的值是否相等，如果遇到空节点，就返回true（说明每一个节点值都相等）；如果遇到节点的值与其左右节点值不相等就返回false；如果该节点的值与其左右子节点的值都相等，就接着递归该节点的左右子树。</span></strong></span></p> 
</blockquote> 
<p><span style="color:#0d0016;"><strong>代码如下：</strong></span></p> 
<pre><code class="language-cpp">bool isUnivalTree(struct TreeNode* root) {
    if (root == NULL) {
        return true;
    }
    if (root-&gt;left &amp;&amp; root-&gt;left-&gt;val != root-&gt;val) {
        return false;
    }
    if (root-&gt;right &amp;&amp; root-&gt;right-&gt;val != root-&gt;val) {
        return false;
    }

    return isUnivalTree(root-&gt;left) &amp;&amp; isUnivalTree(root-&gt;right);
}</code></pre> 
<h2 style="background-color:transparent;">二、<a class="link-info" href="https://leetcode.cn/problems/same-tree/description/" rel="nofollow" title="相同的树">相同的树</a> — <a class="link-info" href="https://leetcode.cn/problems/symmetric-tree/description/" rel="nofollow" title="对称二叉树">对称二叉树</a> — <a class="link-info" href="https://leetcode.cn/problems/subtree-of-another-tree/" rel="nofollow" title="另一颗树的子树">另一颗树的子树</a></h2> 
<h3 style="background-color:transparent;">        2.1、相同的树</h3> 
<p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/cb/ba/NoDE7HLv_o.png" width="587"></p> 
<p>        判断两个二叉树是否相等</p> 
<p><span style="color:#4da8ee;"><strong>思路：</strong></span></p> 
<blockquote> 
 <p>        <strong><span style="color:#0d0016;"><span style="background-color:#38d8f0;">同时遍历两个二叉树，如果遍历到两个二叉树节点同时为空，就说明这两个二叉树相同；如果其中一个为空而另一个不为空，就说明两个二叉树不相同；如果遍历过程中，遇到两个二叉树节点的值不相等，则两个二叉树不相同。</span></span></strong></p> 
</blockquote> 
<p>简单分析一下：</p> 
<p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/79/09/nu4DTskW_o.png" width="442"></p> 
<p>        同时遍历这两个二叉树</p> 
<p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/42/83/DTJkWSvu_o.png" width="445"></p> 
<p>        两个二叉树节点都不为空且值相等，继续遍历其左子树</p> 
<p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/3e/26/XRYk1S8g_o.png" width="398"></p> 
<p>        两个二叉树节点都不为空且值相等，继续遍历其左子树</p> 
<p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/ab/fd/4loPMrxR_o.png" width="393"></p> 
<p>        两个二叉树节点都为空，返回true</p> 
<p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/42/1e/NPCOcH36_o.png" width="398"></p> 
<p>        先遍历二叉树是2节点的右节点，也为空，这里直接跳过了。</p> 
<p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/a3/df/Wukwv6pu_o.png" width="391"></p> 
<p>        这里回退到1这个节点，接下来遍历1的右子树</p> 
<p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/3c/b1/tYkIFt0e_o.png" width="389"></p> 
<p>        遍历到节点都不为空，且值相等，继续遍历 （这因为3的左右节点都为空，就一步带过）</p> 
<p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/a8/47/0baDgean_o.png" width="367"></p> 
<p>        遍历结束，没有遇到一个节点为空一个节点不为空或者值不相等的情况，就返回true。</p> 
<p><span style="color:#0d0016;"><strong>代码如下：</strong></span></p> 
<pre><code class="language-cpp">typedef struct TreeNode TreeNode;
bool isSameTree(struct TreeNode* p, struct TreeNode* q) {
    if (p == NULL &amp;&amp; q == NULL) {
        return true;
    }
    if (p == NULL || q == NULL) {
        return false;
    }
    if (p-&gt;val != q-&gt;val) {
        return false;
    }
    return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);
}</code></pre> 
<h3>        2.2、对称二叉树</h3> 
<p>        </p> 
<p><img alt="" class="left" height="500" src="https://images2.imgbox.com/24/b5/RGFWPyOR_o.png" width="550"></p> 
<p>        判断二叉树是否是对称二叉树，这里还是实现与上题相同的树类似的思路。</p> 
<p><span style="color:#4da8ee;"><strong>思路：</strong></span></p> 
<blockquote> 
 <p>        <span style="color:#0d0016;"><strong><span style="background-color:#38d8f0;">利用相同的树的方法，判断二叉树根节点的左右子树是否对称（判断对称直接判断一个节点的左子树和另一个节点的右子树是否相等即可）。</span></strong></span></p> 
</blockquote> 
<p><span style="color:#0d0016;"><strong>代码如下：</strong></span></p> 
<pre><code class="language-cpp">typedef struct TreeNode TreeNode;
bool isSameTree(struct TreeNode* p, struct TreeNode* q) {
    if (p == NULL &amp;&amp; q == NULL) {
        return true;
    }
    if (p == NULL || q == NULL) {
        return false;
    }
    if (p-&gt;val != q-&gt;val) {
        return false;
    }
    return isSameTree(p-&gt;left, q-&gt;right) &amp;&amp; isSameTree(p-&gt;right, q-&gt;left);
}
bool isSymmetric(struct TreeNode* root) {
    return isSameTree(root-&gt;left,root-&gt;right);
}</code></pre> 
<h3>        2.3、另一颗树的子树</h3> 
<p><img alt="" height="848" src="https://images2.imgbox.com/70/44/EbFyZpMo_o.png" width="1200"></p> 
<p>        判断一个树是否是另一个树的子树</p> 
<p><span style="color:#4da8ee;"><strong>思路：</strong></span></p> 
<blockquote> 
 <p>        <span style="color:#0d0016;"><strong><span style="background-color:#38d8f0;">还是利用相同二叉树的方法，判断二叉树及其左右子树中是否存在与另一棵树相同的树。</span></strong></span></p> 
</blockquote> 
<p><span style="color:#0d0016;"><strong>代码如下：</strong></span></p> 
<pre><code class="language-cpp">typedef struct TreeNode TreeNode;
bool isSameTree(struct TreeNode* p, struct TreeNode* q) {
    if (p == NULL &amp;&amp; q == NULL) {
        return true;
    }
    if (p == NULL || q == NULL) {
        return false;
    }
    if (p-&gt;val != q-&gt;val) {
        return false;
    }
    return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);
}

bool isSubtree(struct TreeNode* root, struct TreeNode* subRoot){
    if(root==NULL)
    {
        return false;
    }
    if(isSameTree(root,subRoot))
    {
        return true;
    }

    return isSubtree(root-&gt;left,subRoot)
            ||isSubtree(root-&gt;right,subRoot);
}</code></pre> 
<h2 style="background-color:transparent;">三、二叉树的遍历（<a class="link-info" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/" rel="nofollow" title="前序">前序</a>、<a class="link-info" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/" rel="nofollow" title="中序">中序</a>、<a class="link-info" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/description/" rel="nofollow" title="后序">后序</a>）</h2> 
<p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/49/25/iZIq42dJ_o.png" width="587"></p> 
<p>        本题要求，前序遍历二叉树，并且返回前序遍历的结果（以数组方式返回），并且还用通过指向修改数据个数。</p> 
<p><strong><span style="color:#4da8ee;">思路：</span></strong></p> 
<blockquote> 
 <p>        <span style="color:#0d0016;"><strong><span style="background-color:#38d8f0;">这里首先求二叉树的节点个数；然后动态申请内存来存储数据并且用来最后返回数组首元素地址；最后就是将数据存储到数组当中了，使用前序遍历。</span></strong></span></p> 
</blockquote> 
<p><span style="color:#0d0016;"><strong>代码如下：</strong></span></p> 
<pre><code class="language-cpp">typedef struct TreeNode TreeNode;
int TreeSize(TreeNode* root) {
    if (root == NULL) {
        return 0;
    }
    return TreeSize(root-&gt;left) + TreeSize(root-&gt;right) + 1;
}
void _preorderTraversal(TreeNode* root,int* arr,int* pi)
{
    if(root==NULL)
    {
        return ;
    }
    arr[(*pi)++]=root-&gt;val;
    _preorderTraversal(root-&gt;left,arr,pi);
    _preorderTraversal(root-&gt;right,arr,pi);
}
int* preorderTraversal(struct TreeNode* root, int* returnSize) {

    // 求出二叉树的节点个数
    *returnSize =TreeSize(root);
    // 动态申请空间大小
    int* returnArr=(int*)malloc(sizeof(int)*(*returnSize));
    // 前序遍历
    int i=0;
    _preorderTraversal(root,returnArr,&amp;i);
    return returnArr;
}</code></pre> 
<p>中序和后序遍历与其思路一样这里直接看代码。</p> 
<p><strong>中序遍历</strong></p> 
<pre><code class="language-cpp"> typedef struct TreeNode TreeNode;
int TreeSize(TreeNode* root) {
    if (root == NULL) {
        return 0;
    }
    return TreeSize(root-&gt;left) + TreeSize(root-&gt;right) + 1;
}
void _inorderTraversal(TreeNode* root,int* arr,int* pi)
{
    if(root==NULL)
    {
        return ;
    }
    _inorderTraversal(root-&gt;left,arr,pi);
    arr[(*pi)++]=root-&gt;val;
    _inorderTraversal(root-&gt;right,arr,pi);
}
int* inorderTraversal(struct TreeNode* root, int* returnSize) {

    // 求出二叉树的节点个数
    *returnSize =TreeSize(root);
    // 动态申请空间大小
    int* returnArr=(int*)malloc(sizeof(int)*(*returnSize));
    // 中序遍历
    int i=0;
    _inorderTraversal(root,returnArr,&amp;i);
    return returnArr;
}</code></pre> 
<p><strong>后序遍历</strong></p> 
<pre><code class="language-cpp">  typedef struct TreeNode TreeNode;
int TreeSize(TreeNode* root) {
    if (root == NULL) {
        return 0;
    }
    return TreeSize(root-&gt;left) + TreeSize(root-&gt;right) + 1;
}
void _postorderTraversal(TreeNode* root,int* arr,int* pi)
{
    if(root==NULL)
    {
        return ;
    }
    _postorderTraversal(root-&gt;left,arr,pi);
    _postorderTraversal(root-&gt;right,arr,pi);
    arr[(*pi)++]=root-&gt;val;
}
int* postorderTraversal(struct TreeNode* root, int* returnSize) {

    // 求出二叉树的节点个数
    *returnSize =TreeSize(root);
    // 动态申请空间大小
    int* returnArr=(int*)malloc(sizeof(int)*(*returnSize));
    // 中序遍历
    int i=0;
    _postorderTraversal(root,returnArr,&amp;i);
    return returnArr;
}</code></pre> 
<h2 style="background-color:transparent;">四、<a class="link-info" href="https://www.nowcoder.com/practice/4b91205483694f449f94c179883c1fef" rel="nofollow" title="二叉树的构建和遍历">二叉树的构建和遍历</a></h2> 
<p><img alt="" height="948" src="https://images2.imgbox.com/cc/0e/uC32Ve13_o.png" width="1200"></p> 
<p>        创建二叉树，并且中序遍历。</p> 
<p>因为这里题目说先序遍历字符串（我们根据这个来构建二叉树），本题要求写全部代码。</p> 
<p><span style="color:#4da8ee;"><strong>思路：</strong></span></p> 
<blockquote> 
 <p>        <span style="color:#0d0016;"><strong><span style="background-color:#38d8f0;">先创建字符数组，根据输入的字符串进行创建二叉树，创建完成以后再进行中序遍历输出即可。</span></strong></span></p> 
</blockquote> 
<p><span style="color:#0d0016;"><strong>代码如下：</strong></span></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
typedef struct BinaryTreeNode
{
    char str;
    struct BinaryTreeNode* left;
    struct BinaryTreeNode* right;
}BTNode;

BTNode* BuyNode(char x)
{
    BTNode* newnode=(BTNode* )malloc(sizeof(BTNode));
    newnode-&gt;str=x;
    newnode-&gt;left=newnode-&gt;right=NULL;
    return newnode;
}
BTNode* CreatTree(char* str,int* pi)
{
    if(str[*pi]=='#')
    {
        (*pi)++;
        return NULL;
    }
    BTNode* root=BuyNode(str[(*pi)++]);
    root-&gt;left=CreatTree(str,pi);
    root-&gt;right=CreatTree(str,pi);
    return root;
}
//中序遍历
void InOrder(BTNode* root)
{
    if(root==NULL)
    {
        return;
    }
    InOrder(root-&gt;left);
    printf("%c ",root-&gt;str);
    InOrder(root-&gt;right);
}
int main() {
    char str[100];
    scanf("%s",str);
    //根据字符创建二叉树
    int i=0;
    BTNode* root=CreatTree(str, &amp;i);
    InOrder(root);
    return 0;
}</code></pre> 
<p><span style="color:#ff9900;"><strong><span style="background-color:#38d8f0;">感谢各位大佬支持并指出问题，</span></strong></span></p> 
<p><strong>                        <span style="color:#4da8ee;"><span style="background-color:#f9eda6;">如果本篇内容对你有帮助，可以一键三连支持以下，感谢支持！！！</span></span></strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a0/a5/csKiguM3_o.jpg"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8ad09a19edd0575557cb664b68973493/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">指针！！C语言(第三篇）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/65c643a33267132abc1c8cf7ca307183/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Javascript前端面试（七）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>