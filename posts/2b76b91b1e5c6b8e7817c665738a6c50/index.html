<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;】哈希(unordered_set、unordered_map) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/2b76b91b1e5c6b8e7817c665738a6c50/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;】哈希(unordered_set、unordered_map)">
  <meta property="og:description" content="🌈个人主页：秦jh_-CSDN博客
🔥 系列专栏：https://blog.csdn.net/qinjh_/category_12575764.html?spm=1001.2014.3001.5482
​ 目录
unordered系列关联式容器 unordered_set的使用
unordered_map的使用
底层结构
哈希概念
哈希冲突
哈希冲突解决 闭散列
线性探测
插入
扩容
开散列
插入
扩容
前言 💬 hello! 各位铁子们大家好哇。
今日更新了哈希的相关内容
🎉 欢迎大家关注🔍点赞👍收藏⭐️留言📝
unordered系列关联式容器 在C&#43;&#43;98中，STL提供了底层为红黑树结构的一系列关联式容器，在查询时时间复杂度为O(logN)。在C&#43;&#43;11中，STL又提供了4个 unordered系列的关联式容器，这四个容器与红黑树结构的关联式容器使用方式基本类似，只是其底层结构不同， 查询时的时间复杂度为O(1)。
unordered_set的使用 unordered_set、unordered_map跟set和map的使用差不多，只是unordered是无序的，且迭代器是单向的。
unordered_map的使用 unordered_map也是无序的。
unordered_map是存储键值对的关联式容器，其允许通过keys快速的索引到与其对应的value。 在unordered_map中，键值通常用于惟一地标识元素，而映射值是一个对象，其内容与此键关联。键和映射值的类型可能不同。在内部,unordered_map没有对按照任何特定的顺序排序, 为了能在常数范围内找到key所对应的value，unordered_map将相同哈希值的键值对放在相同的桶中。 unordered_map容器通过key访问单个元素要比map快，但它通常在遍历元素子集的范围迭 代方面效率较低。unordered_maps实现了直接访问操作符(operator[])，它允许使用key作为参数直接访问 value。 底层结构 unordered系列的关联式容器之所以效率比较高，是因为其底层使用了哈希结构。
哈希概念 顺序结构以及平衡树中，元素关键码与其存储位置之间没有对应的关系，因此在查找一个元素 时，必须要经过关键码的多次比较。顺序查找时间复杂度为O(N)，平衡树中为树的高度，即 O(logN)，搜索的效率取决于搜索过程中元素的比较次数。
理想的搜索方法：可以不经过任何比较，一次直接从表中得到要搜索的元素。 如果构造一种存储结构，通过某种函数(hashFunc)使元素的存储位置与它的关键码之间能够建立 一一映射的关系，那么在查找时通过该函数可以很快找到该元素。
当向该结构中：
插入元素：根据待插入元素的关键码，以此函数计算出该元素的存储位置并按此位置进行存放搜索元素：对元素的关键码进行同样的计算，把求得的函数值当做元素的存储位置，在结构中按此位置 取元素比较，若关键码相等，则搜索成功 该方式即为哈希(散列)方法，哈希方法中使用的转换函数称为哈希(散列)函数，构造出来的结构称 为哈希表(Hash Table)(或者称散列表) 总结：
哈希思想：值--存储位置建立映射关系。
哈希表：哈希思想实现的数据结构。
例如：数据集合{1，7，6，4，5，9}；
哈希函数设置为：hash(key) = key % capacity; capacity为存储元素底层空间总的大小。
用该方法进行搜索不必进行多次关键码的比较，因此搜索的速度比较快
哈希冲突 不同关键字通过相同哈希函数计算出相同的哈希地址，该种现象称为哈希冲突或哈希碰撞。把具有不同关键码而具有相同哈希地址的数据元素称为“同义词”。
哈希冲突解决 解决哈希冲突两种常见的方法是：闭散列和开散列 闭散列 闭散列：也叫开放定址法，当发生哈希冲突时，如果哈希表未被装满，说明在哈希表中必然还有 空位置，那么可以把key存放到冲突位置中的“下一个” 空位置中去。 线性探测 线性探测：从发生冲突的位置开始，依次向后探测，直到寻找到下一个空位置为止。 插入 通过哈希函数获取待插入元素在哈希表中的位置如果该位置中没有元素则直接插入新元素，如果该位置中有元素发生哈希冲突， 使用线性探测找到下一个空位置，插入新元素 删除 采用闭散列处理哈希冲突时，不能随便物理删除哈希表中已有的元素，若直接删除元素 会影响其他元素的搜索。因此线性探测采用标记的伪删除法来删除一个元素。 如上图，如果采用的是物理删除元素。遇到空就停止，查找31时，可以正常找到。当删除55后，再去找31，就找不到了，因为原本55的位置现在是空，这样就造成31在，但是找不到的情况。所以采用标记法。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-12T16:04:19+08:00">
    <meta property="article:modified_time" content="2024-08-12T16:04:19+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】哈希(unordered_set、unordered_map)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p> <strong>🌈个人主页：</strong><a href="https://blog.csdn.net/qinjh_?type=blog" title="秦jh_-CSDN博客">秦jh_-CSDN博客</a><br><strong>🔥 系列专栏：</strong><a href="https://blog.csdn.net/qinjh_/category_12575764.html?spm=1001.2014.3001.5482" title="https://blog.csdn.net/qinjh_/category_12575764.html?spm=1001.2014.3001.5482">https://blog.csdn.net/qinjh_/category_12575764.html?spm=1001.2014.3001.5482</a></p> 
<p> <img alt="9efbcbc3d25747719da38c01b3fa9b4f.gif" src="https://images2.imgbox.com/78/81/8lHoZwbP_o.gif">​ </p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="unordered%E7%B3%BB%E5%88%97%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8%C2%A0-toc" style="margin-left:0px;"><a href="#unordered%E7%B3%BB%E5%88%97%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8%C2%A0" rel="nofollow">unordered系列关联式容器 </a></p> 
<p id="unordered_set%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#unordered_set%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">unordered_set的使用</a></p> 
<p id="unordered_map%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#unordered_map%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">unordered_map的使用</a></p> 
<p id="%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84" rel="nofollow">底层结构</a></p> 
<p id="%E5%93%88%E5%B8%8C%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%E5%93%88%E5%B8%8C%E6%A6%82%E5%BF%B5" rel="nofollow">哈希概念</a></p> 
<p id="%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81-toc" style="margin-left:40px;"><a href="#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81" rel="nofollow">哈希冲突</a></p> 
<p id="%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%C2%A0" rel="nofollow">哈希冲突解决 </a></p> 
<p id="%E9%97%AD%E6%95%A3%E5%88%97-toc" style="margin-left:80px;"><a href="#%E9%97%AD%E6%95%A3%E5%88%97" rel="nofollow">闭散列</a></p> 
<p id="%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B-toc" style="margin-left:120px;"><a href="#%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B" rel="nofollow">线性探测</a></p> 
<p id="%C2%A0%E6%8F%92%E5%85%A5-toc" style="margin-left:120px;"><a href="#%C2%A0%E6%8F%92%E5%85%A5" rel="nofollow"> 插入</a></p> 
<p id="%E6%89%A9%E5%AE%B9-toc" style="margin-left:120px;"><a href="#%E6%89%A9%E5%AE%B9" rel="nofollow">扩容</a></p> 
<p id="%C2%A0%E5%BC%80%E6%95%A3%E5%88%97-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%BC%80%E6%95%A3%E5%88%97" rel="nofollow"> 开散列</a></p> 
<p id="%E6%8F%92%E5%85%A5-toc" style="margin-left:120px;"><a href="#%E6%8F%92%E5%85%A5" rel="nofollow">插入</a></p> 
<p id="%C2%A0%E6%89%A9%E5%AE%B9-toc" style="margin-left:120px;"><a href="#%C2%A0%E6%89%A9%E5%AE%B9" rel="nofollow"> 扩容</a></p> 
<hr id="hr-toc"> 
<h2 id="%E5%89%8D%E8%A8%80">前言</h2> 
<blockquote> 
 <p>    <strong>💬 hello! 各位铁子们大家好哇。</strong></p> 
 <p><strong>             今日更新了哈希的相关内容</strong><br>     <strong>🎉 欢迎大家关注🔍点赞👍收藏⭐️留言📝</strong></p> 
</blockquote> 
<p></p> 
<h2 id="unordered%E7%B3%BB%E5%88%97%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8%C2%A0">unordered系列关联式容器 </h2> 
<p>在C++98中，STL提供了底层为红黑树结构的一系列关联式容器，在查询时时间复杂度为O(logN)。在C++11中，STL又提供了4个 unordered系列的关联式容器，这四个容器与红黑树结构的关联式容器使用方式基本类似，只是其底层结构不同， 查询时的时间复杂度为O(1)。</p> 
<h2 id="unordered_set%E7%9A%84%E4%BD%BF%E7%94%A8">unordered_set的使用</h2> 
<p><img alt="" height="536" src="https://images2.imgbox.com/2a/8f/7un5NMmW_o.png" width="761"></p> 
<blockquote> 
 <p>unordered_set、unordered_map跟set和map的使用差不多，只是unordered是无序的，且迭代器是单向的。</p> 
</blockquote> 
<h2 id="unordered_map%E7%9A%84%E4%BD%BF%E7%94%A8">unordered_map的使用</h2> 
<p><img alt="" height="792" src="https://images2.imgbox.com/22/99/Jrxtfz14_o.png" width="1095"></p> 
<blockquote> 
 <p>unordered_map也是无序的。</p> 
</blockquote> 
<ol><li> unordered_map是存储键值对的关联式容器，其允许通过keys快速的索引到与其对应的value。</li><li> 在unordered_map中，键值通常用于惟一地标识元素，而映射值是一个对象，其内容与此键关联。键和映射值的类型可能不同。</li><li>在内部,unordered_map没有对按照任何特定的顺序排序, 为了能在常数范围内找到key所对应的value，unordered_map将相同哈希值的键值对放在相同的桶中。</li><li> unordered_map容器通过key访问单个元素要比map快，但它通常在遍历元素子集的范围迭 代方面效率较低。</li><li>unordered_maps实现了直接访问操作符(operator[])，它允许使用key作为参数直接访问 value。</li></ol> 
<p><img alt="" height="246" src="https://images2.imgbox.com/e1/dc/xjBNa4GX_o.png" width="1200"><img alt="" height="331" src="https://images2.imgbox.com/64/99/FZR0IZiO_o.png" width="1200"></p> 
<h2 id="%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84">底层结构</h2> 
<p>unordered系列的关联式容器之所以效率比较高，是因为其底层使用了哈希结构。</p> 
<h3 id="%E5%93%88%E5%B8%8C%E6%A6%82%E5%BF%B5">哈希概念</h3> 
<p>顺序结构以及平衡树中，元素关键码与其存储位置之间没有对应的关系，因此在查找一个元素 时，<strong>必须要经过关键码的多次比较。顺序查找时间复杂度为O(N)，平衡树中为树的高度，即 O(logN)，</strong>搜索的效率取决于搜索过程中元素的比较次数。</p> 
<p>理想的搜索方法：可以<strong>不经过任何比较，一次直接从表中得到要搜索的元素。</strong> <strong>如果构造一种存储结构，通过某种函数(hashFunc)使元素的存储位置与它的关键码之间能够建立 一一映射的关系，那么在查找时通过该函数可以很快找到该元素。</strong></p> 
<p>当向该结构中：</p> 
<ul><li><strong>插入元素</strong>：根据待插入元素的关键码，以此函数计算出该元素的存储位置并按此位置进行存放</li><li><strong>搜索元素</strong>：对元素的关键码进行同样的计算，把求得的函数值当做元素的存储位置，在结构中按此位置 取元素比较，若关键码相等，则搜索成功</li></ul> 
<p>该方式即为哈希(散列)方法，<strong>哈希方法中使用的转换函数称为哈希(散列)函数，构造出来的结构称 为哈希表(Hash Table)(或者称散列表) </strong></p> 
<blockquote> 
 <p>总结：</p> 
 <p>哈希思想：值--存储位置建立映射关系。</p> 
 <p>哈希表：哈希思想实现的数据结构。</p> 
</blockquote> 
<p>例如：数据集合{1，7，6，4，5，9}；</p> 
<p>哈希函数设置为：<strong>hash(key) = key % capacity</strong>; capacity为存储元素底层空间总的大小。</p> 
<blockquote> 
 <p><img alt="" height="434" src="https://images2.imgbox.com/bc/68/8W89DH9t_o.png" width="1200">用该方法进行搜索不必进行多次关键码的比较，因此搜索的速度比较快</p> 
</blockquote> 
<h3 id="%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81">哈希冲突</h3> 
<p><strong>不同关键字通过相同哈希函数计算出相同的哈希地址，该种现象称为哈希冲突或哈希碰撞。把具有不同关键码而具有相同哈希地址的数据元素称为“同义词”。</strong></p> 
<h3 id="%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%C2%A0">哈希冲突解决 </h3> 
<p>解决哈希冲突两种常见的方法是：<strong>闭散列和开散列 </strong></p> 
<h4 id="%E9%97%AD%E6%95%A3%E5%88%97">闭散列</h4> 
<p><strong>闭散列：也叫开放定址法，当发生哈希冲突时，如果哈希表未被装满，说明在哈希表中必然还有 空位置，那么可以把key存放到冲突位置中的“下一个” 空位置中去。 </strong></p> 
<h5 id="%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B">线性探测</h5> 
<p><strong>线性探测：从发生冲突的位置开始，依次向后探测，直到寻找到下一个空位置为止。 </strong></p> 
<ul><li>插入 
  <ol><li><strong>通过哈希函数获取待插入元素在哈希表中的位置</strong></li><li><strong>如果该位置中没有元素则直接插入新元素，如果该位置中有元素发生哈希冲突， 使用线性探测找到下一个空位置，插入新元素</strong>                </li></ol></li><li>删除 
  <ol><li><strong>采用闭散列处理哈希冲突时，不能随便物理删除哈希表中已有的元素</strong>，若直接删除元素 会影响其他元素的搜索。因此线性探测<strong>采用标记的伪删除法</strong>来删除一个元素。 </li></ol></li></ul> 
<p><img alt="" height="354" src="https://images2.imgbox.com/52/0c/6C6VGruY_o.png" width="799"></p> 
<blockquote> 
 <p>如上图，如果采用的是物理删除元素。遇到空就停止，查找31时，可以正常找到。当删除55后，再去找31，就找不到了，因为原本55的位置现在是空，这样就造成31在，但是找不到的情况。所以采用标记法。</p> 
</blockquote> 
<p><img alt="" height="826" src="https://images2.imgbox.com/ce/63/z123mv1o_o.png" width="546"></p> 
<h5 id="%C2%A0%E6%8F%92%E5%85%A5"> 插入</h5> 
<p><img alt="" height="653" src="https://images2.imgbox.com/52/77/p0gXE3P9_o.png" width="1200"></p> 
<blockquote> 
 <p> 哈希表中元素个数到达一定的数量，哈希冲突概率会增大，需要扩容来降低哈希冲突，因此哈希表中元素是不会存满的。那什么时候扩容呢?</p> 
</blockquote> 
<h5 id="%E6%89%A9%E5%AE%B9">扩容</h5> 
<p> 负载因子：α=填入表中的元素个数 / 散列表的长度。</p> 
<p>负载因子越大，冲突率越高，效率越低。</p> 
<p>负载因子越小，冲突率越低，效率越高，空间利用率越低。</p> 
<p>对于开放定址法，负载因子是很重要的因素，一般控制在0.7~0.8以下。超过0.8时，就得扩容。</p> 
<p><img alt="" height="962" src="https://images2.imgbox.com/3d/f1/yGV1Tum4_o.png" width="1200"></p> 
<p>所以插入的完整代码如下：</p> 
<pre><code class="language-cpp">bool Insert(const pair&lt;K, V&gt;&amp; kv)
{
    if (Find(kv.first))  //不允许冗余
	return false;

	//扩容
	if (_n * 10 / _tables.size() &gt;= 7)
	{
		//方法一
		//size_t newsize = _tables.size() * 2;    //用vector的话需要手动映射
		//vector&lt;HashData&lt;K, V&gt;&gt; newtables(newsize);

		旧表重新计算负载到新表
		//for(size_t i=0;i&lt;_tables.size();i++)
		//{ }

		//方法二
		HashTable&lt;K, V&gt; newHT;	
		newHT._tables.resize(_tables.size() * 2);

		//旧表重新计算负载到新表
		for (size_t i = 0; i &lt; _tables.size(); i++)
		{
			if (_tables[i]._state == EXIST)
			{
				newHT.Insert(_tables[i]._kv);//用HashTable对象插入，可以复用Insert，不需要手动映射
			}								 //newHT已经是扩容好的了，就跳过扩容，直接来到探测部分
		}									 //新表插入好后，再跟旧表互换
		_tables.swap(newHT._tables);
	}

	size_t hashi = kv.first % _tables.size();  //不能模capacity,否则会得到比size大的数，而size后面的位置不能用[]得到
	//线性探测
	while (_tables[hashi]._state == EXIST)
	{
		++hashi;
		hashi %= _tables.size(); //如果往后找找不到，就回到前面继续找
	}

	_tables[hashi]._kv = kv;
	_tables[hashi]._state = EXIST;
	++_n;

	return true;
}</code></pre> 
<hr> 
<p>当key不是int类型而是string时，就不能取余数了。那该怎么办呢？</p> 
<p><img alt="" height="321" src="https://images2.imgbox.com/e3/2e/CmIKcZs2_o.png" width="636"></p> 
<p> 这里需要用到仿函数，如下图：</p> 
<p><img alt="" height="632" src="https://images2.imgbox.com/42/fb/czcqpBH3_o.png" width="751"><img alt="" height="1200" src="https://images2.imgbox.com/6f/59/dVPXlczB_o.png" width="1100"></p> 
<blockquote> 
 <p>当key可以强转成整形时（比如负数，指针等），用缺省的仿函数即可。当key是string这种不能强转成整形的类型时，就要手动写一个转换成整形的仿函数。上方是取string的第一个字符进行返回。同时也要手动传入这个仿函数。</p> 
 <p><img alt="" height="190" src="https://images2.imgbox.com/b1/d9/Amw8r7ZY_o.png" width="688"></p> 
</blockquote> 
<p> 这种取首字符的方法不是很好，下面是另一种字符串哈希算法：</p> 
<p><img alt="" height="461" src="https://images2.imgbox.com/a3/a5/i0Puhzbw_o.png" width="690"></p> 
<blockquote> 
 <p>该方法是遍历整个字符串，把ASCII码值全部加起来并返回。但是遇到"aadd","abcd"等字符串，还是无法较好的映射，于是就有大佬发现乘上某些数后，就不那么容易冲突，如下图：</p> 
 <p><img alt="" height="507" src="https://images2.imgbox.com/a2/98/cxCwsdTx_o.png" width="648"></p> 
</blockquote> 
<p> 由于字符串经常被用来当key，所以这里可以使用特化：</p> 
<p><img alt="" height="919" src="https://images2.imgbox.com/aa/8e/zWrLq2vE_o.png" width="741"></p> 
<blockquote> 
 <p>使用特化后，就不需要传这个仿函数了。当类型是可以强转的时候，就会走第一个，当类型是string的时候，就会优先走第二个。</p> 
</blockquote> 
<p>上面的过程是闭散列，代码如下：</p> 
<pre><code class="language-cpp">template&lt;class K&gt;
struct HashFunc
{
	size_t operator()(const K&amp; key)
	{
		return (size_t)key; //负数、指针都能转
	}
};

//特化
template&lt;&gt;
struct HashFunc&lt;string&gt;
{
	size_t operator()(const string&amp; key)
	{
		size_t hash = 0;
		for (auto ch : key)
		{
			hash *= 131;
			hash += ch;
		}
		return hash;
	}
};

namespace open_address
{
	enum State
	{
		EMPTY,
		EXIST,
		DELETE
	};

	template&lt;class K, class V&gt;
	struct HashData
	{
		pair&lt;K, V&gt; _kv;
		State _state = EMPTY;
	};

	template&lt;class K, class V, class Hash = HashFunc&lt;K&gt;&gt;
	class HashTable
	{
	public:
		HashTable()
		{
			_tables.resize(10);
		}

		bool Insert(const pair&lt;K, V&gt;&amp; kv)
		{
			if (Find(kv.first))  //不允许冗余
				return false;

			//扩容
			if (_n * 10 / _tables.size() &gt;= 7)
			{
				//方法一
				//size_t newsize = _tables.size() * 2;    //用vector的话需要手动映射
				//vector&lt;HashData&lt;K, V&gt;&gt; newtables(newsize);

				旧表重新计算负载到新表
				//for(size_t i=0;i&lt;_tables.size();i++)
				//{ }

				//方法二
				HashTable&lt;K, V, Hash&gt; newHT;
				newHT._tables.resize(_tables.size() * 2);

				//旧表重新计算负载到新表
				for (size_t i = 0; i &lt; _tables.size(); i++)
				{
					if (_tables[i]._state == EXIST)
					{
						newHT.Insert(_tables[i]._kv);//用HashTable对象插入，可以复用Insert，不需要手动映射
					}								 //newHT已经是扩容好的了，就跳过扩容，直接来到探测部分
				}									 //新表插入好后，再跟旧表互换
				_tables.swap(newHT._tables);
			}
			Hash hs;
			size_t hashi = hs(kv.first) % _tables.size();  //不能模capacity,否则会得到比size大的数，而size后面的位置不能用[]得到
			//线性探测
			while (_tables[hashi]._state == EXIST)
			{
				++hashi;
				hashi %= _tables.size(); //如果往后找找不到，就回到前面继续找
			}

			_tables[hashi]._kv = kv;
			_tables[hashi]._state = EXIST;
			++_n;

			return true;
		}

		HashData&lt;K, V&gt;* Find(const K&amp; key)
		{
			Hash hs;
			size_t hashi = hs(key) % _tables.size();
			//线性探测
			while (_tables[hashi]._state != EMPTY)
			{
				if (_tables[hashi]._state == EXIST &amp;&amp;
					_tables[hashi]._kv.first == key)
				{
					return &amp;_tables[hashi];
				}
				++hashi;
				hashi %= _tables.size();
			}
			return nullptr;
		}

		bool Erase(const K&amp; key)
		{
			HashData&lt;K, V&gt;* ret = Find(key);
			if (ret == nullptr)
			{
				return false;
			}
			else
			{
				ret-&gt;_state = DELETE;
				--_n;
				return true;
			}
		}

	private:
		vector&lt;HashData&lt;K, V&gt;&gt; _tables;
		size_t _n = 0; //有效数据个数
	};

	void TestHT1()
	{
		int a[] = { 10001,11,55,24,19,12,31 };
		HashTable&lt;int, int&gt; ht;
		for (auto e : a)
		{
			ht.Insert(make_pair(e, e));
		}

		cout &lt;&lt; ht.Find(55) &lt;&lt; endl;
		cout &lt;&lt; ht.Find(31) &lt;&lt; endl;

		ht.Erase(55);
		cout &lt;&lt; ht.Find(55) &lt;&lt; endl;
		cout &lt;&lt; ht.Find(31) &lt;&lt; endl;
	}

	void TestHT2()
	{
		int a[] = { 10001,11,55,24,19,12,31 };
		HashTable&lt;int, int&gt; ht;
		for (auto e : a)
		{
			ht.Insert(make_pair(e, e));
		}

		ht.Insert(make_pair(32, 32));
		ht.Insert(make_pair(32, 32));
	}

	//如果key不支持强转成整形取模，就要自己提供转换成整形的仿函数
	void TestHT3()
	{
		HashTable&lt;string, int&gt; ht;
		ht.Insert(make_pair("sort", 1));
		ht.Insert(make_pair("left", 1));
		ht.Insert(make_pair("insert	", 1));

		//cout &lt;&lt; StringHashFunc()("abcd") &lt;&lt; endl;
		//cout &lt;&lt; StringHashFunc()("aadd") &lt;&lt; endl;

	}
}</code></pre> 
<h4 id="%C2%A0%E5%BC%80%E6%95%A3%E5%88%97"> 开散列</h4> 
<p>概念：<strong>开散列法又叫链地址法(开链法)，首先对关键码集合用散列函数计算散列地址，具有相同地 址的关键码归于同一子集合，每一个子集合称为一个桶，各个桶中的元素通过一个单链表链 接起来，各链表的头结点存储在哈希表中</strong>。</p> 
<p><img alt="" height="352" src="https://images2.imgbox.com/fa/1b/1IZTgd8p_o.png" width="810"></p> 
<h5 id="%E6%8F%92%E5%85%A5">插入</h5> 
<p><img alt="" height="719" src="https://images2.imgbox.com/bb/1d/aZrefDf6_o.png" width="712"></p> 
<blockquote> 
 <p>插入是头插，让新节点的next指向当前的第一个节点，然后再让新节点变成头节点。</p> 
</blockquote> 
<h5 id="%C2%A0%E6%89%A9%E5%AE%B9"> 扩容</h5> 
<p><img alt="" height="816" src="https://images2.imgbox.com/16/8a/MFDDRuE9_o.png" width="840"></p> 
<blockquote> 
 <p>扩容的大逻辑跟前面一样。但是需要注意，vector里面每个位置存的是一个一个的桶，当swap后，newHT出了作用域就会调用析构，此时只会销毁每个位置，而不会销毁每个桶，所以需要我们自己写出析构函数。<img alt="" height="375" src="https://images2.imgbox.com/05/6f/1n877kAm_o.png" width="790"><img alt="" height="585" src="https://images2.imgbox.com/7f/35/WpESqoHh_o.png" width="769"></p> 
</blockquote> 
<p>上面的扩容方式，new了多少个节点，就得销毁多少个节点，所以不太好，下面是另一种方式：</p> 
<p><img alt="" height="682" src="https://images2.imgbox.com/48/c1/tvDSNpUI_o.png" width="959"></p> 
<blockquote> 
 <p>重新开一个vector，将旧表里的桶依次取出放到新表对应的位置上，然后销毁旧表的每个位置，最后再进行交换。 </p> 
</blockquote> 
<p> 插入完整代码如下：</p> 
<pre><code class="language-cpp">bool Insert(const pair&lt;K, V&gt;&amp; kv)
{
	if (Find(kv.first))
		return false;

	Hash hs;
	//扩容
	//负载因子为1时扩容
	if (_n == _tables.size())
	{
		//HashTable&lt;K, V&gt; newHT;
		//newHT._tables.resize(_tables.size() * 2);

		旧表重新计算负载到新表
		//for (size_t i = 0; i &lt; _tables.size(); i++)
		//{
		//	Node* cur = _tables[i];
		//	while(cur)
		//	{
		//		newHT.Insert(cur-&gt;_kv);
		//		cur = cur-&gt;_next;
		//	}								 
		//}									
		//_tables.swap(newHT._tables);

		vector&lt;Node*&gt; newTables(_tables.size() * 2, nullptr); 
		for (size_t i = 0; i &lt; _tables.size(); i++) 
		{
			Node* cur = _tables[i]; 
			while(cur)
			{
				Node* next = cur-&gt;_next; 
				//头插到新表的位置
				size_t hashi = hs(cur-&gt;_kv.first) % newTables.size(); 
				cur-&gt;_next = newTables[hashi]; 
				newTables[hashi] = cur; 

				cur = next; 
			}				 
			_tables[i] = nullptr; 
		}									
		_tables.swap(newTables);  
	}

	size_t hashi = hs(kv.first) % _tables.size(); 
	Node* newnode = new Node(kv); 
	//头插
	newnode-&gt;_next = _tables[hashi]; 
	_tables[hashi] = newnode; 
	++_n; 

	return true;
}</code></pre> 
<p>闭散列完整代码：</p> 
<pre><code class="language-cpp">template&lt;class K&gt;
struct HashFunc
{
	size_t operator()(const K&amp; key)
	{
		return (size_t)key; //负数、指针都能转
	}
};

//特化
template&lt;&gt;
struct HashFunc&lt;string&gt;
{
	size_t operator()(const string&amp; key)
	{
		size_t hash = 0;
		for (auto ch : key)
		{
			hash *= 131;
			hash += ch;
		}
		return hash;
	}
};

namespace hash_bucket
{
	template&lt;class K, class V&gt;
	struct HashNode
	{
		pair&lt;K, V&gt; _kv;
		HashNode&lt;K, V&gt;* _next;

		HashNode(const pair&lt;K, V&gt;&amp; kv)
			:_kv(kv)
			,_next(nullptr)
		{}
	};

	template&lt;class K, class V, class Hash = HashFunc&lt;K&gt;&gt;
	class HashTable
	{
		typedef HashNode&lt;K, V&gt; Node;
	public:
		HashTable()
		{
			_tables.resize(10, nullptr);
			_n = 0;
		}
		
		~HashTable()
		{
			for (size_t i = 0; i &lt; _tables.size(); i++)
			{
				Node* cur = _tables[i];
				while (cur)
				{
					Node* next = cur-&gt;_next;
					delete cur;

					cur = next;
				}
				_tables[i] = nullptr;
			}
		}

		bool Insert(const pair&lt;K, V&gt;&amp; kv)
		{
			if (Find(kv.first))
				return false;

			Hash hs;
			//扩容
			//负载因子为1时扩容
			if (_n == _tables.size())
			{
				//HashTable&lt;K, V&gt; newHT;
				//newHT._tables.resize(_tables.size() * 2);

				旧表重新计算负载到新表
				//for (size_t i = 0; i &lt; _tables.size(); i++)
				//{
				//	Node* cur = _tables[i];
				//	while(cur)
				//	{
				//		newHT.Insert(cur-&gt;_kv);
				//		cur = cur-&gt;_next;
				//	}								 
				//}									
				//_tables.swap(newHT._tables);

				vector&lt;Node*&gt; newTables(_tables.size() * 2, nullptr); 
				for (size_t i = 0; i &lt; _tables.size(); i++) 
				{
					Node* cur = _tables[i]; 
					while(cur)
					{
						Node* next = cur-&gt;_next; 
						//头插到新表的位置
						size_t hashi = hs(cur-&gt;_kv.first) % newTables.size(); 
						cur-&gt;_next = newTables[hashi]; 
						newTables[hashi] = cur; 

						cur = next; 
					}				 
					_tables[i] = nullptr; 
				}									
				_tables.swap(newTables);  
			}

			size_t hashi = hs(kv.first) % _tables.size(); 
			Node* newnode = new Node(kv); 
			//头插
			newnode-&gt;_next = _tables[hashi]; 
			_tables[hashi] = newnode; 
			++_n; 

			return true;
		}

		Node* Find(const K&amp; key)
		{
			Hash hs;
			size_t hashi = hs(key) % _tables.size();
			Node* cur = _tables[hashi];
			while (cur)
			{
				if (cur-&gt;_kv.first == key)
				{
					return cur;
				}
				cur = cur-&gt;_next;
			}
			return nullptr;
		}

		bool Erase(const K&amp; key)
		{
			Hash hs;
			size_t hashi = hs(key) % _tables.size(); 
			Node* prev = nullptr;
			Node* cur = _tables[hashi]; 
			while (cur) 
			{
				if (cur-&gt;_kv.first == key)
				{
					//如果删除的是第一个
					if (prev == nullptr)
					{
						_tables[hashi] = cur-&gt;_next;
					}
					else
					{
						prev-&gt;_next = cur-&gt;_next;
					}

					delete cur;
					return true;
				}
				else
				{
					prev = cur;
					cur = cur-&gt;_next;
				}
			}
			return false;
		}

	private:
		vector&lt;Node*&gt; _tables;  //指针数组
		size_t _n;
		
		//vector&lt;list&lt;pair&lt;K, V&gt;&gt;&gt; _tables;
	};

	void TestHT1()
	{
		int a[] = { 10001,11,55,24,19,12,31,4,34,44 };
		HashTable&lt;int, int&gt; ht;
		for (auto e : a)
		{
			ht.Insert(make_pair(e, e));
		}

		ht.Insert(make_pair(32, 32));
		ht.Insert(make_pair(32, 32));

		ht.Erase(31);
		ht.Erase(11);

	}

	void TestHT2()
	{
		HashTable&lt;string, int&gt; ht; 
		ht.Insert(make_pair("sort", 1));
		ht.Insert(make_pair("left", 1));
		ht.Insert(make_pair("insert	", 1));
	}

}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b5e633ee39f0c114216d55b90b3c008d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">移情别恋c&#43;&#43; ദ്ദി˶ｰ̀֊ｰ́ ) ——5.string</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/33f0f2b1a5d384d74475e55cf01512df/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">算法：魔法字典</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>