<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RabbitMQ基础 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b5cc1aa798b9c38d0154d2f72852138b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="RabbitMQ基础">
  <meta property="og:description" content="学习课程文档 目录
背景
初识MQ
同步调用
异步调用 MQ界面介绍 交换机 队列 绑定关系
​发送消息
数据隔离 用户管理 ​virtual host虚拟主机 Spring AMQP 快速入门 起步依赖
消息发送
​消息接收 ​WorkQueues模型
​能者多劳
总结
交换机类型
Fanout交换机
总结
Direct交换机
声明队列和交换机 消息接收 消息发送
总结
Topic交换机
总结
声明队列和交换机
基于Bean声明
fanout示例 基于注解声明
示例 消息转换器(converandsend)
配置JSON转换器 消费者接收Object
背景 RabbitMQ作为一个高性能异步通讯组件，为解决高并发而生。
微服务一旦拆分，必然涉及到服务之间的相互调用，目前我们服务之间调用采用的都是基于OpenFeign的调用。这种调用中，调用者发起请求后需要等待服务提供者执行业务返回结果后，才能继续执行后面的业务。也就是说调用者在调用过程中处于阻塞状态，因此我们成这种调用方式为同步调用，也可以叫同步通讯。但在很多场景下，我们可能需要采用异步通讯的方式。 初识MQ 同步调用 随着业务规模扩大，产品的功能也在不断完善。如果采用同步调用，则假如每个微服务的执行时长都是50ms，则最终整个业务的耗时可能高达300ms，性能太差了。
其次由于我们是基于OpenFeign调用交易服务、通知服务。当交易服务、通知服务出现故障时，整个事务都会回滚，交易失败。我们假设用户余额充足，扣款已经成功，此时我们应该确保支付流水单更新为已支付，确保交易成功。因此，这里不能因为短信通知、更新订单状态失败而回滚整个事务。 综上，同步调用的方式存在下列问题：
拓展性差
性能下降
级联失败
异步调用 异步调用方式其实就是基于消息通知的方式，一般包含三个角色：
消息发送者：投递消息的人，就是原来的调用方
消息Broker：管理、暂存、转发消息，你可以把它理解成微信服务器
消息接收者：接收和处理消息的人，就是原来的服务提供方
采用异步调用后的支付服务：
当扩展业务时： 当然，异步通信也并非完美无缺，它存在下列缺点：
完全依赖于Broker的可靠性、安全性和性能
架构复杂，后期维护和调试麻烦
MQ界面介绍 用户有虚拟主机（类似database），虚拟主机有交换机，交换机与队列绑定关系。 交换机 我们打开Exchanges选项卡，可以看到已经存在很多交换机：
我们点击任意交换机，即可进入交换机详情页面。仍然会利用控制台中的publish message 发送一条消息：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-09T09:55:11+08:00">
    <meta property="article:modified_time" content="2024-06-09T09:55:11+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RabbitMQ基础</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><a class="link-info" href="https://b11et3un53m.feishu.cn/wiki/OQH4weMbcimUSLkIzD6cCpN0nvc" rel="nofollow" title="学习课程文档">学习课程文档</a> </p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E8%83%8C%E6%99%AF-toc" style="margin-left:0px;"><a href="#%E8%83%8C%E6%99%AF" rel="nofollow">背景</a></p> 
<p id="%E5%88%9D%E8%AF%86MQ-toc" style="margin-left:0px;"><a href="#%E5%88%9D%E8%AF%86MQ" rel="nofollow">初识MQ</a></p> 
<p id="%E5%90%8C%E6%AD%A5%E8%B0%83%E7%94%A8-toc" style="margin-left:40px;"><a href="#%E5%90%8C%E6%AD%A5%E8%B0%83%E7%94%A8" rel="nofollow">同步调用</a></p> 
<p id="%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%C2%A0" rel="nofollow">异步调用 </a></p> 
<p id="MQ%E7%95%8C%E9%9D%A2%E4%BB%8B%E7%BB%8D%C2%A0-toc" style="margin-left:0px;"><a href="#MQ%E7%95%8C%E9%9D%A2%E4%BB%8B%E7%BB%8D%C2%A0" rel="nofollow">MQ界面介绍 </a></p> 
<p id="%E4%BA%A4%E6%8D%A2%E6%9C%BA%C2%A0-toc" style="margin-left:40px;"><a href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA%C2%A0" rel="nofollow">交换机 </a></p> 
<p id="%E9%98%9F%E5%88%97%C2%A0-toc" style="margin-left:40px;"><a href="#%E9%98%9F%E5%88%97%C2%A0" rel="nofollow">队列 </a></p> 
<p id="%C2%A0%E7%BB%91%E5%AE%9A%E5%85%B3%E7%B3%BB-toc" style="margin-left:40px;"><a href="#%C2%A0%E7%BB%91%E5%AE%9A%E5%85%B3%E7%B3%BB" rel="nofollow"> 绑定关系</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF-toc" style="margin-left:40px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF" rel="nofollow">​发送消息</a></p> 
<p id="%E6%95%B0%E6%8D%AE%E9%9A%94%E7%A6%BB%C2%A0-toc" style="margin-left:40px;"><a href="#%E6%95%B0%E6%8D%AE%E9%9A%94%E7%A6%BB%C2%A0" rel="nofollow">数据隔离 </a></p> 
<p id="%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%C2%A0-toc" style="margin-left:80px;"><a href="#%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%C2%A0" rel="nofollow">用户管理 </a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91virtual%20host%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%C2%A0-toc" style="margin-left:80px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91virtual%20host%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%C2%A0" rel="nofollow">​virtual host虚拟主机 </a></p> 
<p id="Spring%20AMQP%C2%A0-toc" style="margin-left:0px;"><a href="#Spring%20AMQP%C2%A0" rel="nofollow">Spring AMQP </a></p> 
<p id="%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%C2%A0" rel="nofollow">快速入门 </a></p> 
<p id="%C2%A0%E8%B5%B7%E6%AD%A5%E4%BE%9D%E8%B5%96-toc" style="margin-left:80px;"><a href="#%C2%A0%E8%B5%B7%E6%AD%A5%E4%BE%9D%E8%B5%96" rel="nofollow"> 起步依赖</a></p> 
<p id="%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81-toc" style="margin-left:80px;"><a href="#%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81" rel="nofollow">消息发送</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6%C2%A0-toc" style="margin-left:80px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6%C2%A0" rel="nofollow">​消息接收 </a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91WorkQueues%E6%A8%A1%E5%9E%8B-toc" style="margin-left:40px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91WorkQueues%E6%A8%A1%E5%9E%8B" rel="nofollow">​WorkQueues模型</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%E8%83%BD%E8%80%85%E5%A4%9A%E5%8A%B3-toc" style="margin-left:80px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%E8%83%BD%E8%80%85%E5%A4%9A%E5%8A%B3" rel="nofollow">​能者多劳</a></p> 
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:80px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
<p id="%C2%A0%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#%C2%A0%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B" rel="nofollow"> 交换机类型</a></p> 
<p id="%C2%A0Fanout%E4%BA%A4%E6%8D%A2%E6%9C%BA-toc" style="margin-left:40px;"><a href="#%C2%A0Fanout%E4%BA%A4%E6%8D%A2%E6%9C%BA" rel="nofollow"> Fanout交换机</a></p> 
<p id="%C2%A0%E6%80%BB%E7%BB%93-toc" style="margin-left:80px;"><a href="#%C2%A0%E6%80%BB%E7%BB%93" rel="nofollow"> 总结</a></p> 
<p id="Direct%E4%BA%A4%E6%8D%A2%E6%9C%BA-toc" style="margin-left:40px;"><a href="#Direct%E4%BA%A4%E6%8D%A2%E6%9C%BA" rel="nofollow">Direct交换机</a></p> 
<p id="%E5%A3%B0%E6%98%8E%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA%C2%A0-toc" style="margin-left:80px;"><a href="#%E5%A3%B0%E6%98%8E%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA%C2%A0" rel="nofollow">声明队列和交换机 </a></p> 
<p id="%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6%C2%A0-toc" style="margin-left:80px;"><a href="#%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6%C2%A0" rel="nofollow">消息接收 </a></p> 
<p id="%C2%A0%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81-toc" style="margin-left:80px;"><a href="#%C2%A0%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81" rel="nofollow"> 消息发送</a></p> 
<p id="%C2%A0%E6%80%BB%E7%BB%93-toc" style="margin-left:80px;"><a href="#%C2%A0%E6%80%BB%E7%BB%93" rel="nofollow"> 总结</a></p> 
<p id="%C2%A0Topic%E4%BA%A4%E6%8D%A2%E6%9C%BA-toc" style="margin-left:40px;"><a href="#%C2%A0Topic%E4%BA%A4%E6%8D%A2%E6%9C%BA" rel="nofollow"> Topic交换机</a></p> 
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:80px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
<p id="%C2%A0%E5%A3%B0%E6%98%8E%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA-toc" style="margin-left:40px;"><a href="#%C2%A0%E5%A3%B0%E6%98%8E%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA" rel="nofollow"> 声明队列和交换机</a></p> 
<p id="%E5%9F%BA%E4%BA%8EBean%E5%A3%B0%E6%98%8E-toc" style="margin-left:80px;"><a href="#%E5%9F%BA%E4%BA%8EBean%E5%A3%B0%E6%98%8E" rel="nofollow">基于Bean声明</a></p> 
<p id="fanout%E7%A4%BA%E4%BE%8B%C2%A0-toc" style="margin-left:80px;"><a href="#fanout%E7%A4%BA%E4%BE%8B%C2%A0" rel="nofollow">fanout示例 </a></p> 
<p id="%C2%A0%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E" rel="nofollow"> 基于注解声明</a></p> 
<p id="%E7%A4%BA%E4%BE%8B%C2%A0-toc" style="margin-left:80px;"><a href="#%E7%A4%BA%E4%BE%8B%C2%A0" rel="nofollow">示例 </a></p> 
<p id="%C2%A0%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8(converandsend)-toc" style="margin-left:40px;"><a href="#%C2%A0%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8%28converandsend%29" rel="nofollow"> 消息转换器(converandsend)</a></p> 
<p id="%E9%85%8D%E7%BD%AEJSON%E8%BD%AC%E6%8D%A2%E5%99%A8%C2%A0-toc" style="margin-left:80px;"><a href="#%E9%85%8D%E7%BD%AEJSON%E8%BD%AC%E6%8D%A2%E5%99%A8%C2%A0" rel="nofollow">配置JSON转换器 </a></p> 
<p id="%C2%A0%E6%B6%88%E8%B4%B9%E8%80%85%E6%8E%A5%E6%94%B6Object-toc" style="margin-left:80px;"><a href="#%C2%A0%E6%B6%88%E8%B4%B9%E8%80%85%E6%8E%A5%E6%94%B6Object" rel="nofollow"> 消费者接收Object</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p> </p> 
<h2 id="%E8%83%8C%E6%99%AF" style="background-color:transparent;">背景</h2> 
<p>RabbitMQ作为一个高性能异步通讯组件，为解决高并发而生。</p> 
<p>微服务一旦拆分，必然涉及到服务之间的相互调用，目前我们服务之间调用采用的都是基于OpenFeign的调用。这种调用中，调用者发起请求后需要<strong>等待</strong>服务提供者执行业务返回结果后，才能继续执行后面的业务。也就是说调用者在调用过程中处于阻塞状态，因此我们成这种调用方式为<strong>同步调用</strong>，也可以叫<strong>同步通讯</strong>。但在很多场景下，我们可能需要采用<strong>异步通讯</strong>的方式。 </p> 
<p><img alt="" height="471" src="https://images2.imgbox.com/f6/c0/omMqJ2P3_o.png" width="1200"> <img alt="" height="595" src="https://images2.imgbox.com/3e/86/uXUMwzkn_o.png" width="1126"></p> 
<h2 id="%E5%88%9D%E8%AF%86MQ">初识MQ</h2> 
<h3 id="%E5%90%8C%E6%AD%A5%E8%B0%83%E7%94%A8">同步调用</h3> 
<p><strong>随着业务规模扩大，产品的功能也在不断完善。如果采用同步调用，则假如每个微服务的执行时长都是50ms，则最终整个业务的耗时可能高达300ms，性能太差了。</strong></p> 
<p><strong>其次由于我们是基于OpenFeign调用交易服务、通知服务。当交易服务、通知服务出现故障时，整个事务都会回滚，交易失败。我们假设用户余额充足，扣款已经成功，此时我们应该确保支付流水单更新为已支付，确保交易成功。因此，这里不能因为短信通知、更新订单状态失败而回滚整个事务。 </strong></p> 
<p><strong>综上，同步调用的方式存在下列问题：</strong></p> 
<ul><li> <p><strong>拓展性差</strong></p> </li><li> <p><strong>性能下降</strong></p> </li><li> <p><strong>级联失败</strong></p> </li></ul> 
<p><img alt="" height="699" src="https://images2.imgbox.com/c9/e5/Cpo2iqfb_o.png" width="1028"></p> 
<h3 id="%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%C2%A0">异步调用 </h3> 
<p><strong>异步调用方式其实就是基于消息通知的方式，一般包含三个角色：</strong></p> 
<ul><li> <p><strong>消息发送者：投递消息的人，就是原来的调用方</strong></p> </li><li> <p><strong>消息Broker：管理、暂存、转发消息，你可以把它理解成微信服务器</strong></p> </li><li> <p><strong>消息接收者：接收和处理消息的人，就是原来的服务提供方</strong></p> </li></ul> 
<p><img alt="" height="289" src="https://images2.imgbox.com/b2/d4/vFBYdL5E_o.png" width="941"><strong> 采用异步调用后的支付服务：</strong><img alt="" height="634" src="https://images2.imgbox.com/d0/05/hPk2HkNk_o.png" width="1200"></p> 
<p><strong>当扩展业务时： </strong></p> 
<p><img alt="" height="697" src="https://images2.imgbox.com/d4/ce/wCptyCfb_o.png" width="1176"></p> 
<p><strong>当然，异步通信也并非完美无缺，它存在下列缺点：</strong></p> 
<ul><li> <p><strong>完全依赖于Broker的可靠性、安全性和性能</strong></p> </li><li> <p><strong>架构复杂，后期维护和调试麻烦</strong></p> </li></ul> 
<h2 id="MQ%E7%95%8C%E9%9D%A2%E4%BB%8B%E7%BB%8D%C2%A0" style="background-color:transparent;">MQ界面介绍 </h2> 
<p><strong>用户有虚拟主机（类似database），虚拟主机有交换机，交换机与队列绑定关系。 </strong></p> 
<h3 id="%E4%BA%A4%E6%8D%A2%E6%9C%BA%C2%A0" style="background-color:transparent;">交换机 </h3> 
<p><strong>我们打开Exchanges选项卡，可以看到已经存在很多交换机：</strong></p> 
<p><img alt="" height="840" src="https://images2.imgbox.com/64/39/BU4FQnL1_o.png" width="1200"></p> 
<p><strong> 我们点击任意交换机，即可进入交换机详情页面。仍然会利用控制台中的publish message 发送一条消息：</strong></p> 
<p><img alt="" height="755" src="https://images2.imgbox.com/db/e0/KofYae9G_o.png" width="1182"> <img alt="" height="845" src="https://images2.imgbox.com/00/b8/IOPAyUYB_o.png" width="1200"></p> 
<p><strong> 这里是由控制台模拟了生产者发送的消息。由于没有消费者存在，最终消息丢失了，这样说明交换机没有存储消息的能力。</strong></p> 
<h3 id="%E9%98%9F%E5%88%97%C2%A0">队列 </h3> 
<p><strong>我们打开<code>Queues</code>选项卡，新建一个队列： </strong></p> 
<p><img alt="" height="641" src="https://images2.imgbox.com/cb/62/LZfUDR2Z_o.png" width="1200"><strong> 命名为<code>hello.queue1</code>：</strong></p> 
<p><img alt="" height="838" src="https://images2.imgbox.com/1f/50/hpzl51EK_o.png" width="1200"><strong> 再以相同的方式，创建一个队列，名称为<code>hello.queue2</code>，最终队列列表如下：</strong></p> 
<p><img alt="" height="549" src="https://images2.imgbox.com/72/eb/M1lI5Omg_o.png" width="1200"></p> 
<p><strong>此时，我们再次向<code>amq.fanout</code>交换机发送一条消息。会发现消息依然没有到达队列！！</strong></p> 
<p><strong>怎么回事呢？</strong></p> 
<p><strong>发送到交换机的消息，只会路由到与其绑定的队列，因此仅仅创建队列是不够的，我们还需要将其与交换机绑定。</strong></p> 
<h3 id="%C2%A0%E7%BB%91%E5%AE%9A%E5%85%B3%E7%B3%BB" style="background-color:transparent;"> 绑定关系</h3> 
<p><strong>点击<code>Exchanges</code>选项卡，点击<code>amq.fanout</code>交换机，进入交换机详情页，然后点击<code>Bindings</code>菜单，在表单中填写要绑定的队列名称：</strong></p> 
<p><img alt="" height="742" src="https://images2.imgbox.com/87/d8/af814QBC_o.png" width="1200"></p> 
<p><strong>相同的方式，将hello.queue2也绑定到改交换机。</strong></p> 
<p><strong>最终，绑定结果如下：</strong></p> 
<h3 id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><img alt="" height="591" src="https://images2.imgbox.com/5e/df/ycg5m0le_o.png" width="1200"> 发送消息</h3> 
<p><strong>再次回到exchange页面，找到刚刚绑定的<code>amq.fanout</code>，点击进入详情页，再次发送一条消息： </strong></p> 
<p><img alt="" height="839" src="https://images2.imgbox.com/8d/c0/q1yrdjcM_o.png" width="1200"><strong> 回到<code>Queues</code>页面，可以发现<code>hello.queue</code>中已经有一条消息了：</strong></p> 
<p><img alt="" height="488" src="https://images2.imgbox.com/52/0d/oluAUDe4_o.png" width="1200"> <strong>点击队列名称，进入详情页，查看队列详情，这次我们点击get message：</strong></p> 
<p><img alt="" height="729" src="https://images2.imgbox.com/c6/a3/pvSzMdNg_o.png" width="1200"><strong> 可以看到消息到达队列了：</strong></p> 
<p><img alt="" height="720" src="https://images2.imgbox.com/c7/96/zTFwDpyq_o.png" width="948"><strong> 这个时候如果有消费者监听了MQ的<code>hello.queue1</code>或<code>hello.queue2</code>队列，自然就能接收到消息了。</strong></p> 
<h3 id="%E6%95%B0%E6%8D%AE%E9%9A%94%E7%A6%BB%C2%A0" style="background-color:transparent;">数据隔离 </h3> 
<h4 id="%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%C2%A0">用户管理 </h4> 
<p><strong>点击<code>Admin</code>选项卡，首先会看到RabbitMQ控制台的用户管理界面： </strong></p> 
<p><img alt="" height="613" src="https://images2.imgbox.com/a0/67/a5WRW1gT_o.png" width="1200"><strong> 这里的用户都是RabbitMQ的管理或运维人员。</strong></p> 
<p><strong>仔细观察用户表格中的字段，如下：</strong></p> 
<ul><li> <p><strong><code>Name</code>：<code>itheima</code>，也就是用户名</strong></p> </li><li> <p><strong><code>Tags</code>：<code>administrator</code>，说明<code>itheima</code>用户是超级管理员，拥有所有权限</strong></p> </li><li> <p><strong><code>Can access virtual host</code>： <code>/</code>，可以访问的<code>virtual host</code>，这里的<code>/</code>是默认的<code>virtual host</code></strong></p> </li></ul> 
<p><strong>对于小型企业而言，出于成本考虑，我们通常只会搭建一套MQ集群，公司内的多个不同项目同时使用。这个时候为了避免互相干扰， 我们会利用<code>virtual host</code>的隔离特性，将不同项目隔离。一般会做两件事情：</strong></p> 
<ul><li> <p><strong>给每个项目创建独立的运维账号，将管理权限分离。</strong></p> </li><li> <p><strong>给每个项目创建不同的<code>virtual host</code>，将每个项目的数据隔离。</strong></p> </li></ul> 
<p></p> 
<p><strong>比如，我们给黑马商城创建一个新的用户，命名为<code>hmall</code>： </strong></p> 
<p><img alt="" height="832" src="https://images2.imgbox.com/4b/35/R74KrP4K_o.png" width="1200"></p> 
<p><strong> 你会发现此时hmall用户没有任何<code>virtual host</code>的访问权限：</strong></p> 
<h4 id="%E2%80%8B%E7%BC%96%E8%BE%91virtual%20host%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%C2%A0"><img alt="" height="539" src="https://images2.imgbox.com/b1/bd/dwrakPSz_o.png" width="1156">virtual host虚拟主机 </h4> 
<p><strong>我们先退出登录： </strong></p> 
<p><img alt="" height="503" src="https://images2.imgbox.com/66/05/pT9oyQhs_o.png" width="1200"> <strong>切换到刚刚创建的hmall用户登录，然后点击<code>Virtual Hosts</code>菜单，进入<code>virtual host</code>管理页：</strong></p> 
<p><img alt="" height="562" src="https://images2.imgbox.com/3b/3a/BsRKDGtz_o.png" width="1200"></p> 
<p><strong>可以看到目前只有一个默认的<code>virtual host</code>，名字为 <code>/</code>。</strong></p> 
<p><strong>我们可以给黑马商城项目创建一个单独的<code>virtual host</code>，而不是使用默认的<code>/</code>。</strong></p> 
<p><img alt="" height="753" src="https://images2.imgbox.com/c6/da/J9QRJ0CQ_o.png" width="1200"><strong> 创建完成后如图：</strong></p> 
<p><img alt="" height="352" src="https://images2.imgbox.com/49/21/d2IKdLSZ_o.png" width="1200"><strong> 由于我们是登录<code>hmall</code>账户后创建的<code>virtual host</code>，因此回到<code>users</code>菜单，你会发现当前用户已经具备了对<code>/hmall</code>这个<code>virtual host</code>的访问权限了：</strong></p> 
<p><img alt="" height="533" src="https://images2.imgbox.com/28/41/qFGzNJNx_o.png" width="1111"><strong> 此时，点击页面右上角的<code>virtual host</code>下拉菜单，切换<code>virtual host</code>为 <code>/hmall</code>：</strong></p> 
<p><img alt="" height="327" src="https://images2.imgbox.com/95/0d/2B0F6F9u_o.png" width="1200"><strong> 然后再次查看queues选项卡，会发现之前的队列已经看不到了：</strong></p> 
<p><img alt="" height="637" src="https://images2.imgbox.com/91/70/0zpYIsUF_o.png" width="1200"><strong> 这就是基于<code>virtual host </code>的隔离效果。</strong></p> 
<h2 id="Spring%20AMQP%C2%A0">Spring AMQP </h2> 
<p><strong> AMQP:是用于在应用程序之间传递业务消息的开放标准。该协议与语言和平台无关，更符合微服务中独立性的要求。</strong></p> 
<p><strong>Spring AMQP:基于AMQP协议定义的一套API规范，提供了模板（接口）来发送和接收消息。包含两部分，其中spring-amqp是基础抽象，spring-rabbit是底层的默认实现。</strong></p> 
<p><strong>SpringAMQP提供了三个功能：</strong></p> 
<ul><li> <p><strong>自动声明队列、交换机及其绑定关系</strong></p> </li><li> <p><strong>基于注解的监听器模式，异步接收消息</strong></p> </li><li> <p><strong>封装了RabbitTemplate工具，用于发送消息</strong></p> </li></ul> 
<h3 id="%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%C2%A0">快速入门 </h3> 
<h4 id="%C2%A0%E8%B5%B7%E6%AD%A5%E4%BE%9D%E8%B5%96" style="background-color:transparent;"> 起步依赖</h4> 
<p><strong>项目结构包括三部分：</strong></p> 
<ul><li> <p><strong>mq-demo：父工程，管理项目依赖</strong></p> </li><li> <p><strong>publisher：消息的发送者</strong></p> </li><li> <p><strong>consumer：消息的消费者</strong></p> </li></ul> 
<p><img alt="" height="394" src="https://images2.imgbox.com/9b/43/EOFok79Y_o.png" width="829"><strong> 无论是consumer或publisher都需要引入依赖</strong></p> 
<pre><code class="language-XML">&lt;!--AMQP依赖，包含RabbitMQ--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;</code></pre> 
<h4 id="%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81" style="background-color:transparent;">消息发送</h4> 
<blockquote> 
 <p><strong>1.引入依赖2.配置Rabbitmq的消息收发端口3.注入RabbitTemplate调用其convertAndSend方法(指定队列,指定消息):发送消息至队列</strong></p> 
</blockquote> 
<p><strong>在<code>publisher</code>服务的<code>application.yml</code>中添加配置： </strong></p> 
<pre><code class="language-XML">spring:
  rabbitmq:
    host: 192.168.150.101 # 你的虚拟机IP
    port: 5672 # 端口
    virtual-host: /hmall # 虚拟主机
    username: hmall # 用户名
    password: 123 # 密码</code></pre> 
<p><strong>SpringAMQP提供了RabbitTemplate工具类。</strong></p> 
<p><strong>只需要注入RabbitTemplate并使用其方法便可发送消息。</strong></p> 
<pre><code class="language-java">@SpringBootTest
public class SpringAmqpTest {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Test
    public void testSimpleQueue() {
        // 队列名称
        String queueName = "simple.queue";
        // 消息
        String message = "hello, spring amqp!";
        // 发送消息
        rabbitTemplate.convertAndSend(queueName, message);
    }
}</code></pre> 
<p><strong> 打开控制台，可以看到消息已经发送到队列中：</strong></p> 
<h4 id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6%C2%A0" style="background-color:transparent;"><img alt="" height="666" src="https://images2.imgbox.com/24/b5/q0mFLTY9_o.png" width="1200"> 消息接收 </h4> 
<blockquote> 
 <p><strong>1.引入依赖2.配置Rabbitmq的消息收发端口3.创建@Componet类,定义@RabbitListener(指定消息队列)方法4.启动服务,自动接收该队列的消息 </strong></p> 
</blockquote> 
<p><strong>在<code>consumer</code>服务的<code>application.yml</code>中添加配置： </strong></p> 
<pre><code class="language-XML">spring:
  rabbitmq:
    host: 192.168.150.101 # 你的虚拟机IP
    port: 5672 # 端口
    virtual-host: /hmall # 虚拟主机
    username: hmall # 用户名
    password: 123 # 密码</code></pre> 
<p><strong> 然后在<code>consumer</code>服务的<code>com.itheima.consumer.listener</code>包中新建一个类<code>SpringRabbitListener</code>，代码如下：</strong></p> 
<pre><code class="language-java">@Component
public class SpringRabbitListener {
        // 利用RabbitListener来声明要监听的队列信息
    // 将来一旦监听的队列中有了消息，就会推送给当前服务，调用当前方法，处理消息。
    // 可以看到方法体中接收的就是消息体的内容
    @RabbitListener(queues = "simple.queue")
    public void listenSimpleQueueMessage(String msg) throws InterruptedException {
        System.out.println("spring 消费者接收到消息：【" + msg + "】");
    }
}</code></pre> 
<p><strong> 启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息。最终consumer收到消息：</strong></p> 
<h3 id="%E2%80%8B%E7%BC%96%E8%BE%91WorkQueues%E6%A8%A1%E5%9E%8B"><img alt="" height="479" src="https://images2.imgbox.com/a2/28/mAv3pCP4_o.png" width="1200">WorkQueues模型</h3> 
<p>Work queues，任务模型。简单来说就是<strong>让</strong><strong>多个消费者</strong><strong>绑定到一个队列，共同消费队列中的消息</strong>。 </p> 
<p> </p> 
<p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。</p> 
<p>此时就可以使用work 模型，<strong>多个消费者共同处理消息处理，消息处理的速度就能大大提高</strong>了。</p> 
<h4 id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0%E8%83%BD%E8%80%85%E5%A4%9A%E5%8A%B3"><img alt="" height="347" src="https://images2.imgbox.com/df/ae/YYyW1w7d_o.png" width="950"> 能者多劳</h4> 
<p><strong>消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。</strong></p> 
<p><strong>导致1个消费者空闲，另一个消费者忙的不可开交。没有充分利用每一个消费者的能力，最终消息处理的耗时远远超过了1秒。这样显然是有问题的。 </strong></p> 
<p><strong>我们修改consumer服务的application.yml文件，添加配置： </strong></p> 
<pre><code class="language-java">spring:
  rabbitmq:
    listener:
      simple:
        prefetch: 1 # 每次只能获取一条消息，处理完成才能获取下一个消息</code></pre> 
<p><strong> 再次测试，发现结果如下：</strong></p> 
<pre><code class="language-java">消费者1接收到消息：【hello, message_0】21:12:51.659664200
消费者2........接收到消息：【hello, message_1】21:12:51.680610
消费者1接收到消息：【hello, message_2】21:12:51.703625
消费者1接收到消息：【hello, message_3】21:12:51.724330100
消费者1接收到消息：【hello, message_4】21:12:51.746651100
消费者1接收到消息：【hello, message_5】21:12:51.768401400
消费者1接收到消息：【hello, message_6】21:12:51.790511400
消费者1接收到消息：【hello, message_7】21:12:51.812559800
消费者1接收到消息：【hello, message_8】21:12:51.834500600
消费者1接收到消息：【hello, message_9】21:12:51.857438800
消费者1接收到消息：【hello, message_10】21:12:51.880379600
消费者2........接收到消息：【hello, message_11】21:12:51.899327100
消费者1接收到消息：【hello, message_12】21:12:51.922828400
消费者1接收到消息：【hello, message_13】21:12:51.945617400
消费者1接收到消息：【hello, message_14】21:12:51.968942500
消费者1接收到消息：【hello, message_15】21:12:51.992215400
消费者1接收到消息：【hello, message_16】21:12:52.013325600
消费者1接收到消息：【hello, message_17】21:12:52.035687100
消费者1接收到消息：【hello, message_18】21:12:52.058188
消费者1接收到消息：【hello, message_19】21:12:52.081208400
消费者2........接收到消息：【hello, message_20】21:12:52.103406200
消费者1接收到消息：【hello, message_21】21:12:52.123827300
消费者1接收到消息：【hello, message_22】21:12:52.146165100
消费者1接收到消息：【hello, message_23】21:12:52.168828300
消费者1接收到消息：【hello, message_24】21:12:52.191769500
消费者1接收到消息：【hello, message_25】21:12:52.214839100
消费者1接收到消息：【hello, message_26】21:12:52.238998700
消费者1接收到消息：【hello, message_27】21:12:52.259772600
消费者1接收到消息：【hello, message_28】21:12:52.284131800
消费者2........接收到消息：【hello, message_29】21:12:52.306190600
消费者1接收到消息：【hello, message_30】21:12:52.325315800
消费者1接收到消息：【hello, message_31】21:12:52.347012500
消费者1接收到消息：【hello, message_32】21:12:52.368508600
消费者1接收到消息：【hello, message_33】21:12:52.391785100
消费者1接收到消息：【hello, message_34】21:12:52.416383800
消费者1接收到消息：【hello, message_35】21:12:52.439019
消费者1接收到消息：【hello, message_36】21:12:52.461733900
消费者1接收到消息：【hello, message_37】21:12:52.485990
消费者1接收到消息：【hello, message_38】21:12:52.509219900
消费者2........接收到消息：【hello, message_39】21:12:52.523683400
消费者1接收到消息：【hello, message_40】21:12:52.547412100
消费者1接收到消息：【hello, message_41】21:12:52.571191800
消费者1接收到消息：【hello, message_42】21:12:52.593024600
消费者1接收到消息：【hello, message_43】21:12:52.616731800
消费者1接收到消息：【hello, message_44】21:12:52.640317
消费者1接收到消息：【hello, message_45】21:12:52.663111100
消费者1接收到消息：【hello, message_46】21:12:52.686727
消费者1接收到消息：【hello, message_47】21:12:52.709266500
消费者2........接收到消息：【hello, message_48】21:12:52.725884900
消费者1接收到消息：【hello, message_49】21:12:52.746299900</code></pre> 
<p><strong>可以发现，由于消费者1处理速度较快，所以处理了更多的消息；消费者2处理速度较慢，只处理了6条消息。而最终总的执行耗时也在1秒左右，大大提升。</strong></p> 
<p><strong>正所谓能者多劳，这样充分利用了每一个消费者的处理能力，可以有效避免消息积压问题。</strong></p> 
<h4 id="%E6%80%BB%E7%BB%93">总结</h4> 
<p><strong>Work模型的使用：</strong></p> 
<ul><li> <p><strong>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</strong></p> </li><li> <p><strong>通过设置prefetch来控制消费者预取的消息数量</strong></p> </li></ul> 
<h3 id="%C2%A0%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B"> 交换机类型</h3> 
<p><strong>在之前的两个测试案例中，都没有交换机，生产者直接发送消息到队列。而一旦引入交换机，消息发送的模式会有很大变化： </strong></p> 
<p><img alt="" height="485" src="https://images2.imgbox.com/5e/b2/ECUiD1Js_o.png" width="1195"></p> 
<ul><li> <p><strong>Consumer</strong>：消费者，可以订阅一个或多个队列</p> </li><li> <p><strong>Exchange</strong>：交换机，一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。</p> </li></ul> 
<p> </p> 
<p>交换机的类型有四种：</p> 
<ul><li> <p><strong>Fanout</strong>：广播，将消息交给所有绑定到交换机的队列。我们最早在控制台使用的正是Fanout交换机</p> </li><li> <p><strong>Direct</strong>：订阅，基于RoutingKey（路由key）发送给订阅了消息的队列</p> </li><li> <p><strong>Topic</strong>：通配符订阅，与Direct类似，只不过RoutingKey可以使用通配符</p> </li><li> <p><strong>Headers</strong>：头匹配，基于MQ的消息头匹配，用的较少。</p> </li></ul> 
<h3 id="%C2%A0Fanout%E4%BA%A4%E6%8D%A2%E6%9C%BA" style="background-color:transparent;"> Fanout交换机</h3> 
<p><strong>WorkQueues模型实现的是一条消息由一个消费者接收；Fanout交换机实现的是一条消息可以被多个消费者接收。 </strong></p> 
<p><strong>在广播模式下，消息发送流程是这样的： </strong></p> 
<p><img alt="" height="525" src="https://images2.imgbox.com/05/95/b5yz1Ed3_o.png" width="1200"></p> 
<ul><li> <p><strong>1） 可以有多个队列</strong></p> </li><li> <p><strong>2） 每个队列都要绑定到Exchange（交换机）</strong></p> </li><li> <p><strong>3） 生产者发送的消息，只能发送到交换机</strong></p> </li><li> <p><strong>4） 交换机把消息发送给绑定过的所有队列</strong></p> </li><li> <p><strong>5） 订阅队列的消费者都能拿到消息</strong></p> </li></ul> 
<h4 id="%C2%A0%E6%80%BB%E7%BB%93"> 总结</h4> 
<p><strong>交换机的作用是什么？</strong></p> 
<ul><li> <p><strong>接收publisher发送的消息</strong></p> </li><li> <p><strong>将消息按照规则路由到与之绑定的队列</strong></p> </li><li> <p><strong>不能缓存消息，路由失败，消息丢失</strong></p> </li><li> <p><strong>FanoutExchange的会将消息路由到每个绑定的队列（复制n份消息分别发给绑定的n个队列）</strong></p> </li></ul> 
<h3 id="Direct%E4%BA%A4%E6%8D%A2%E6%9C%BA">Direct交换机</h3> 
<p><strong>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望<span style="color:#fe2c24;">不同的消息被不同的队列消费</span>。这时就要用到Direct类型的Exchange。 </strong></p> 
<p><img alt="" height="549" src="https://images2.imgbox.com/c9/cb/QUkeL2xQ_o.png" width="1200"></p> 
<p></p> 
<p><strong>案例需求如图</strong>： </p> 
<p><img alt="" height="664" src="https://images2.imgbox.com/be/d3/8bqZzUyk_o.png" width="1200"></p> 
<ol><li> <p><strong>声明一个名为<code>hmall.direct</code>的交换机</strong></p> </li><li> <p><strong>声明队列<code>direct.queue1</code>，绑定<code>hmall.direct</code>，<code>bindingKey</code>为<code>blud</code>和<code>red</code></strong></p> </li><li> <p><strong>声明队列<code>direct.queue2</code>，绑定<code>hmall.direct</code>，<code>bindingKey</code>为<code>yellow</code>和<code>red</code></strong></p> </li><li> <p><strong>在<code>consumer</code>服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2</strong></p> </li><li> <p><strong>在publisher中编写测试方法，向<code>hmall.direct</code>发送消息</strong></p> </li></ol> 
<h4 id="%E5%A3%B0%E6%98%8E%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA%C2%A0">声明队列和交换机 </h4> 
<p><strong>首先在控制台声明两个队列<code>direct.queue1</code>和<code>direct.queue2</code> </strong></p> 
<p><img alt="" height="561" src="https://images2.imgbox.com/7f/c3/8G7AGsrO_o.png" width="1200"><strong> 然后声明一个direct类型的交换机，命名为<code>hmall.direct</code>:</strong></p> 
<p><img alt="" height="512" src="https://images2.imgbox.com/4c/8f/f7ZYaom9_o.png" width="1089"><strong> 然后使用<code>red</code>和<code>blue</code>作为key，绑定<code>direct.queue1</code>到<code>hmall.direct</code>：</strong></p> 
<p><img alt="" height="725" src="https://images2.imgbox.com/db/2c/G3e28YzN_o.png" width="1174"> <img alt="" height="730" src="https://images2.imgbox.com/bc/78/7bcZvMsm_o.png" width="1089"></p> 
<p><strong>同理，使用<code>red</code>和<code>yellow</code>作为key，绑定<code>direct.queue2</code>到<code>hmall.direct</code>，步骤略。</strong></p> 
<h4 id="%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6%C2%A0">消息接收 </h4> 
<p><strong>在consumer服务的SpringRabbitListener中添加方法： </strong></p> 
<pre><code class="language-java">@RabbitListener(queues = "direct.queue1")
public void listenDirectQueue1(String msg) {
    System.out.println("消费者1接收到direct.queue1的消息：【" + msg + "】");
}

@RabbitListener(queues = "direct.queue2")
public void listenDirectQueue2(String msg) {
    System.out.println("消费者2接收到direct.queue2的消息：【" + msg + "】");
}</code></pre> 
<h4 id="%C2%A0%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81"> 消息发送</h4> 
<p><strong>在publisher服务的SpringAmqpTest类中添加测试方法： </strong></p> 
<pre><code class="language-java">@Test
public void testSendDirectExchange() {
    // 交换机名称
    String exchangeName = "hmall.direct";
    // 消息
    String message = "红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！";
    // 发送消息
    rabbitTemplate.convertAndSend(exchangeName, "red", message);
}</code></pre> 
<p><strong>由于使用的red这个key，所以两个消费者都收到了消息： </strong></p> 
<p><img alt="" height="204" src="https://images2.imgbox.com/d1/b5/4nwYZi2B_o.png" width="1200"><strong> 我们再切换为blue这个key：</strong></p> 
<pre><code class="language-java">@Test
public void testSendDirectExchange() {
    // 交换机名称
    String exchangeName = "hmall.direct";
    // 消息
    String message = "最新报道，哥斯拉是居民自治巨型气球，虚惊一场！";
    // 发送消息
    rabbitTemplate.convertAndSend(exchangeName, "blue", message);
}</code></pre> 
<p><strong> 你会发现，只有消费者1收到了消息：</strong></p> 
<p><img alt="" height="266" src="https://images2.imgbox.com/21/af/6TDIaIYR_o.png" width="1200"></p> 
<h4> 总结</h4> 
<p><strong>在Direct模型下：</strong></p> 
<ul><li> <p><strong>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</strong></p> </li><li> <p><strong>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</strong></p> </li><li> <p><strong>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</strong></p> </li></ul> 
<ul><li> <p><strong>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</strong></p> </li></ul> 
<h3 id="%C2%A0Topic%E4%BA%A4%E6%8D%A2%E6%9C%BA"> Topic交换机</h3> 
<p><strong>与Direct交换机多了个通配符。 </strong></p> 
<p><img alt="" height="470" src="https://images2.imgbox.com/f5/60/JYnQRy5t_o.png" width="1200"></p> 
<p><strong>假如此时publisher发送的消息使用的<code>RoutingKey</code>共有四种：</strong></p> 
<ul><li> <p><strong><code>china.news </code>代表有中国的新闻消息；</strong></p> </li><li> <p><strong><code>china.weather</code> 代表中国的天气消息；</strong></p> </li><li> <p><strong><code>japan.news</code> 则代表日本新闻</strong></p> </li><li> <p><strong><code>japan.weather</code> 代表日本的天气消息；</strong></p> </li></ul> 
<p><strong>解释：</strong></p> 
<ul><li> <p><strong><code>topic.queue1</code>：绑定的是<code>china.#</code> ，凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到，包括：</strong></p> 
  <ul><li> <p><strong><code>china.news</code></strong></p> </li><li> <p><strong><code>china.weather</code></strong></p> </li></ul></li><li> <p><strong><code>topic.queue2</code>：绑定的是<code>#.news</code> ，凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括:</strong></p> 
  <ul><li> <p><strong><code>china.news</code></strong></p> </li><li> <p><strong><code>japan.news</code></strong></p> </li></ul></li></ul> 
<p><strong>修改Routing key和交换机属性，剩余步骤和Direct交换机一致。 </strong></p> 
<p><img alt="" height="583" src="https://images2.imgbox.com/12/bb/oB9WWLxB_o.png" width="1092"></p> 
<h4>总结</h4> 
<p><strong>描述下Direct交换机与Topic交换机的差异？</strong></p> 
<ul><li> <p><strong>Topic交换机接收的消息<span style="color:#fe2c24;">RoutingKey必须是多个单词</span>，以 <code>.</code> 分割</strong></p> </li><li> <p><strong>Topic交换机与队列绑定时的bindingKey可以指定通配符</strong></p> </li><li> <p><strong><code>#</code>：代表0个或多个词</strong></p> </li><li> <p><strong><code>*</code>：代表1个词</strong></p> </li></ul> 
<h3 id="%C2%A0%E5%A3%B0%E6%98%8E%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA" style="background-color:transparent;"> 声明队列和交换机</h3> 
<p><strong>在实际开发时，队列和交换机是程序员定义的，将来项目上线，又要交给运维去创建。那么程序员就需要把程序中运行的所有队列和交换机都写下来，交给运维。在这个过程中是很容易出现错误的。</strong></p> 
<p><strong>因此推荐的做法是由程序启动时检查队列和交换机是否存在，如果不存在自动创建。</strong></p> 
<p> </p> 
<h4 id="%E5%9F%BA%E4%BA%8EBean%E5%A3%B0%E6%98%8E">基于Bean声明</h4> 
<p><strong>SpringAMQP提供了一个Queue类（还可以用工厂类QueueBuilder构建），用来<span style="color:#fe2c24;">创建队列</span>： </strong></p> 
<p> </p> 
<p><strong>SpringAMQP还提供了一个Exchange接口，来表示所有不同类型的交换机： </strong></p> 
<p><img alt="" height="555" src="https://images2.imgbox.com/fd/5a/MySkA1ah_o.png" width="1200"></p> 
<p><strong>SpringAMQP还提供了ExchangeBuilder来<span style="color:#fe2c24;">创建交换机</span>：</strong></p> 
<p><img alt="" height="388" src="https://images2.imgbox.com/19/35/tp7xz3z5_o.png" width="975"> </p> 
<p><strong> 而在<span style="color:#fe2c24;">绑定队列和交换机</span>时，则需要使用BindingBuilder来创建Binding对象：</strong></p> 
<p><img alt="" height="203" src="https://images2.imgbox.com/45/1e/ryvBro01_o.png" width="822"> </p> 
<h4 id="fanout%E7%A4%BA%E4%BE%8B%C2%A0" style="background-color:transparent;">fanout示例 </h4> 
<p><strong>在consumer中创建一个类，声明队列和交换机： </strong></p> 
<pre><code class="language-java">package com.itheima.consumer.config;


@Configuration
public class FanoutConfig {
    /**
     * 声明交换机
     * @return Fanout类型交换机
     */
    @Bean
    public FanoutExchange fanoutExchange(){
        return new FanoutExchange("hmall.fanout");
    }

    /**
     * 第1个队列
     */
    @Bean
    public Queue fanoutQueue1(){
        return new Queue("fanout.queue1");
    }

    /**
     * 绑定队列和交换机
     */
    @Bean
    public Binding bindingQueue1(Queue fanoutQueue1, FanoutExchange fanoutExchange){
        return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);
    }

    /**
     * 第2个队列
     */
    @Bean
    public Queue fanoutQueue2(){
        return new Queue("fanout.queue2");
    }

    /**
     * 绑定队列和交换机
     */
    @Bean
    public Binding bindingQueue2(Queue fanoutQueue2, FanoutExchange fanoutExchange){
        return BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);
    }
}</code></pre> 
<h4 id="%C2%A0%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E"> 基于注解声明</h4> 
<h4 id="%E7%A4%BA%E4%BE%8B%C2%A0" style="background-color:transparent;">示例 </h4> 
<p><strong>例如，我们同样声明Direct模式的交换机和队列： <span style="color:#fe2c24;">（写在监听器listener类中，Bean声明在config类中）</span></strong></p> 
<pre><code class="language-java">@RabbitListener(bindings = @QueueBinding(
    value = @Queue(name = "direct.queue1"),
    exchange = @Exchange(name = "hmall.direct", type = ExchangeTypes.DIRECT),
    key = {"red", "blue"}
))
public void listenDirectQueue1(String msg){
    System.out.println("消费者1接收到direct.queue1的消息：【" + msg + "】");
}

@RabbitListener(bindings = @QueueBinding(
    value = @Queue(name = "direct.queue2"),
    exchange = @Exchange(name = "hmall.direct", type = ExchangeTypes.DIRECT),
    key = {"red", "yellow"}
))
public void listenDirectQueue2(String msg){
    System.out.println("消费者2接收到direct.queue2的消息：【" + msg + "】");
}</code></pre> 
<p><strong> 再试试Topic模式：</strong></p> 
<pre><code class="language-java">@RabbitListener(bindings = @QueueBinding(
    value = @Queue(name = "topic.queue1"),
    exchange = @Exchange(name = "hmall.topic", type = ExchangeTypes.TOPIC),
    key = "china.#"
))
public void listenTopicQueue1(String msg){
    System.out.println("消费者1接收到topic.queue1的消息：【" + msg + "】");
}

@RabbitListener(bindings = @QueueBinding(
    value = @Queue(name = "topic.queue2"),
    exchange = @Exchange(name = "hmall.topic", type = ExchangeTypes.TOPIC),
    key = "#.news"
))
public void listenTopicQueue2(String msg){
    System.out.println("消费者2接收到topic.queue2的消息：【" + msg + "】");
}</code></pre> 
<p> </p> 
<h3 id="%C2%A0%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8(converandsend)"> 消息转换器(converandsend)</h3> 
<p>Spring的消息发送代码接收的消息体是一个Object：</p> 
<p><img alt="" height="585" src="https://images2.imgbox.com/c8/a1/hrh2no2x_o.png" width="1200"><strong> </strong></p> 
<p><strong>而在数据传输时，它会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。</strong></p> 
<p><strong>只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</strong></p> 
<ul><li> <p><strong>数据体积过大</strong></p> </li><li> <p><strong>有安全漏洞</strong></p> </li><li> <p><strong>可读性差</strong></p> </li></ul> 
<h4 id="%E9%85%8D%E7%BD%AEJSON%E8%BD%AC%E6%8D%A2%E5%99%A8%C2%A0">配置JSON转换器 </h4> 
<p><strong>在<code>publisher</code>和<code>consumer</code>两个服务中都引入依赖(因为发送和接收消息需要使用同一个消息转换器)： </strong></p> 
<pre><code class="language-java">&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;
    &lt;version&gt;2.9.10&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<p><strong> 如果项目中引入了<code>spring-boot-starter-web</code>依赖，则无需再次引入<code>Jackson</code>依赖。</strong></p> 
<p></p> 
<p><strong>配置消息转换器，在<code>publisher</code>和<code>consumer</code>两个服务的启动类中添加一个Bean即可： </strong></p> 
<pre><code class="language-java">@Bean
public MessageConverter messageConverter(){
    // 1.定义消息转换器
    Jackson2JsonMessageConverter jackson2JsonMessageConverter = new Jackson2JsonMessageConverter();
    // 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息
    jackson2JsonMessageConverter.setCreateMessageIds(true);
    return jackson2JsonMessageConverter;
}</code></pre> 
<h4 id="%C2%A0%E6%B6%88%E8%B4%B9%E8%80%85%E6%8E%A5%E6%94%B6Object"> 消费者接收Object</h4> 
<p><strong>我们在consumer服务中定义一个新的消费者，publisher是用Map发送，那么消费者也一定要用Map接收，格式如下： </strong></p> 
<pre><code class="language-java">@RabbitListener(queues = "object.queue")
public void listenSimpleQueueMessage(Map&lt;String, Object&gt; msg) throws InterruptedException {
    System.out.println("消费者接收到object.queue消息：【" + msg + "】");
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2c4b7de9f6f1aca9d7b7aa8028292e3b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【虚拟现实】二、主要的AR/VR硬件设备</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d4ab870d2cfc30279e463eb8b2d67ed4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">18-Nacos-NacosRule负载均衡</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>