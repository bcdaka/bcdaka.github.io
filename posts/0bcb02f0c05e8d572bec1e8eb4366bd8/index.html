<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】二叉树专题 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/0bcb02f0c05e8d572bec1e8eb4366bd8/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】二叉树专题">
  <meta property="og:description" content="前言
本篇博客我们来看一些二叉树的经典题型，也是对上篇博客的补充
💓 个人主页：小张同学zkf
⏩ 文章专栏：数据结构
若有问题 评论区见📝 🎉欢迎大家点赞👍收藏⭐文章 ​
目录
1.单值二叉树
2.检查两棵树是否相同
3.对称二叉树
​编辑 4.二叉树的前序遍历
5.另一棵树的子树
1.单值二叉树 这道题有两种思路，一种是最简单的也是最常见的思路，遍历，就是把每个节点遍历一遍，看是否值相等（代码过于简单就不写了），还有一种思路就是递归，通过递归，判断孩子与父亲是否相等，若相等进行下次递归，直到节点为空，就代表是单值二叉树，我们写下递归方式的代码
代码如下
2.检查两棵树是否相同 这道题我们可以让两颗子树分别遍历，直到双方节点同时都为空，就相等若是一方节点先为空则两棵树不相等，若遍历的同时值不相等，那两棵树也不相等，代码如下
3.对称二叉树 这个对称二叉树就判断左子树与右子树是否相等就行了，也就是说把根节点的左右子树放到上面那道题函数里判断就行了
/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ bool isSameTree(struct TreeNode* p, struct TreeNode* q) { if(p==NULL&amp;&amp;q==NULL) return true; if(p==NULL||q==NULL) return false; if(p-&gt;val!=q-&gt;val) return false; return isSameTree(p-&gt;left,q-&gt;right)&amp;&amp;isSameTree(p-&gt;right,q-&gt;left); } bool isSymmetric(struct TreeNode* root) { return isSameTree(root-&gt;left,root-&gt;right); } 注意一下，这里要看左子树与右子树比较是否相等 ，所以传参的时候注意下">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-09T15:32:36+08:00">
    <meta property="article:modified_time" content="2024-06-09T15:32:36+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】二叉树专题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><span style="color:#4da8ee;">前言</span></p> 
 <p><span style="color:#0d0016;">本篇博客我们来看一些二叉树的经典题型，也是对上篇博客的补充</span></p> 
 <p><span style="color:#0d0016;">💓 个人主页：<a class="link-info" href="https://blog.csdn.net/m0_74091744?spm=1010.2135.3001.5421" title="小张同学zkf">小张同学zkf</a></span></p> 
 <p><span style="color:#0d0016;">⏩ 文章专栏：<a class="link-info" href="https://blog.csdn.net/m0_74091744/category_12630139.html?spm=1001.2014.3001.5482" title="数据结构">数据结构</a></span></p> 
 <p><span style="color:#0d0016;">      若有问题 评论区见📝 </span></p> 
 <p><span style="color:#0d0016;">🎉欢迎大家点赞👍收藏⭐文章 ​</span></p> 
 <p style="text-align:center;"><span style="color:#0d0016;"><img alt="" class="left" src="https://images2.imgbox.com/cd/b5/0VG0ySuQ_o.gif"></span></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/21/56/3mqhORpm_o.gif"> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b1/cf/bLFUfGqV_o.gif"> </p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E5%8D%95%E5%80%BC%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:0px;"><a href="#1.%E5%8D%95%E5%80%BC%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">1.单值二叉树</a></p> 
<p id="2.%E6%A3%80%E6%9F%A5%E4%B8%A4%E6%A3%B5%E6%A0%91%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C-toc" style="margin-left:0px;"><a href="#2.%E6%A3%80%E6%9F%A5%E4%B8%A4%E6%A3%B5%E6%A0%91%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C" rel="nofollow">2.检查两棵树是否相同</a></p> 
<p id="3.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:0px;"><a href="#3.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">3.对称二叉树</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0-toc" style="margin-left:0px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0" rel="nofollow">​编辑 </a></p> 
<p id="4.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:0px;"><a href="#4.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86" rel="nofollow">4.二叉树的前序遍历</a></p> 
<p id="%C2%A05.%E5%8F%A6%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91-toc" style="margin-left:0px;"><a href="#%C2%A05.%E5%8F%A6%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91" rel="nofollow"> 5.另一棵树的子树</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p> </p> 
<h2 id="1.%E5%8D%95%E5%80%BC%E4%BA%8C%E5%8F%89%E6%A0%91">1.单值二叉树</h2> 
<p><img alt="" height="120" src="https://images2.imgbox.com/87/0f/BBOaysU8_o.png" width="729"> </p> 
<p>这道题有两种思路，一种是最简单的也是最常见的思路，遍历，就是把每个节点遍历一遍，看是否值相等（代码过于简单就不写了），还有一种思路就是递归，通过递归，判断孩子与父亲是否相等，若相等进行下次递归，直到节点为空，就代表是单值二叉树，我们写下递归方式的代码</p> 
<p>代码如下</p> 
<p><img alt="" height="387" src="https://images2.imgbox.com/4a/b2/Pq9aRVSV_o.png" width="608"></p> 
<hr> 
<h2 id="2.%E6%A3%80%E6%9F%A5%E4%B8%A4%E6%A3%B5%E6%A0%91%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C">2.检查两棵树是否相同</h2> 
<p><img alt="" height="1057" src="https://images2.imgbox.com/90/87/naPH5KUR_o.png" width="1027"> </p> 
<p> 这道题我们可以让两颗子树分别遍历，直到双方节点同时都为空，就相等若是一方节点先为空则两棵树不相等，若遍历的同时值不相等，那两棵树也不相等，代码如下</p> 
<p><img alt="" height="408" src="https://images2.imgbox.com/4f/0f/HCVjlKXa_o.png" width="772"></p> 
<hr> 
<h2 id="3.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91">3.对称二叉树</h2> 
<p> </p> 
<h2 id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A0"><img alt="" height="884" src="https://images2.imgbox.com/2d/a7/hY4Aipzi_o.png" width="891"> </h2> 
<p> 这个对称二叉树就判断左子树与右子树是否相等就行了，也就是说把根节点的左右子树放到上面那道题函数里判断就行了</p> 
<pre><code class="hljs">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
 bool isSameTree(struct TreeNode* p, struct TreeNode* q) {
    if(p==NULL&amp;&amp;q==NULL)
    return true;
    if(p==NULL||q==NULL)
    return false;
    if(p-&gt;val!=q-&gt;val)
    return false;
    return isSameTree(p-&gt;left,q-&gt;right)&amp;&amp;isSameTree(p-&gt;right,q-&gt;left);
}
bool isSymmetric(struct TreeNode* root) {
    return isSameTree(root-&gt;left,root-&gt;right);
}</code></pre> 
<p>注意一下，这里要看左子树与右子树比较是否相等 ，所以传参的时候注意下</p> 
<hr> 
<h2 id="4.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86">4.二叉树的前序遍历</h2> 
<p><img alt="" height="1039" src="https://images2.imgbox.com/6a/f7/o9tx8WnD_o.png" width="832"> </p> 
<p>前序遍历我们上篇博客说过，但是这个前序遍历将所有根节点的数据，存储到数组中，以数组的形式返回，我们先开辟一个动态数组的空间， 将数组首地址与首下表，传入函数中，创建前序遍历函数，不过在此之前要统计一下二叉树的节点个数，得到数组里数据个数，然后通过递归将每个数据放入数组中，记得下标自增</p> 
<pre><code class="hljs">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
 int number(struct TreeNode* root)
 {
    return root==NULL?0:number(root-&gt;left)+number(root-&gt;right)+1;
 }
 void preorder(struct TreeNode* root,int* a,int* pi)
 {
    if(root==NULL)
    return;
    a[(*pi)++]=root-&gt;val;
    preorder(root-&gt;left,a,pi);
    preorder(root-&gt;right,a,pi);
 }
int* preorderTraversal(struct TreeNode* root, int* returnSize) {
    *returnSize=number(root);
    int* a=(int *)malloc(sizeof(int)*(*returnSize));
    int i=0;
    preorder(root,a,&amp;i);
    return a;
}</code></pre> 
<p>中序后序亦是如此</p> 
<hr> 
<h2 id="%C2%A05.%E5%8F%A6%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91"> 5.另一棵树的子树</h2> 
<p><img alt="" height="1119" src="https://images2.imgbox.com/7a/88/FxtgXO4Y_o.png" width="1200"></p> 
<p>相当于直接通过前序遍历把所有子树找到，然后依次导入我们上边说的判断两棵树是否相等的函数里就行了 ，前提俩子树数据相等</p> 
<p>代码如下</p> 
<p><img alt="" height="315" src="https://images2.imgbox.com/8d/33/ehAVltrr_o.png" width="711"></p> 
<hr> 
<blockquote> 
 <p><span style="color:#4da8ee;">结束语 </span></p> 
 <p>典型的二叉树有关习题总结完了，二叉树主要是遍历，要想判断二叉树里什么什么的可能都得需要遍历，遍历那肯定需要递归，所以递归一定要弄明白</p> 
 <p>OK，本篇博客结束，感谢观看！！！</p> 
 <p style="text-align:center;"><img alt="" class="left" height="100" src="https://images2.imgbox.com/59/0b/uGv72HRF_o.gif" width="100"><img alt="" src="https://images2.imgbox.com/ec/bc/Y2m5XQx4_o.gif"><img alt="" class="right" src="https://images2.imgbox.com/35/60/6Lf9Knho_o.gif"></p> 
</blockquote> 
<p></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/69e6137542a32ec15e220c0b5ce26f1f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java----抽象类和接口</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/846a599adb0db729825d854269c13167/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C# WPF入门学习主线篇（十六）—— Grid布局容器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>