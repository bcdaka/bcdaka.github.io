<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>实战项目: 负载均衡 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/5f436aff015753fc60753887ecfcf5e4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="实战项目: 负载均衡">
  <meta property="og:description" content="0. 前言 这个项目使用了前后端,实现一个丐版的LeetCode刷题网站,并根据每台主机的实际情况,选择对应的主机,负载均衡的调度 0.1 所用技术与开发环境 所用技术: C&#43;&#43; STL 标准库 Boost 准标准库 ( 字符串切割 ) cpp- httplib 第三方开源网络库 ctemplate 第三方开源前端网页渲染库 jsoncpp 第三方开源序列化、反序列化库 负载均衡设计 多进程、多线程 MySQL C connect Ace前端在线编辑器 ( 部分 ) html/css/js/jquery/ajax (部分 ) 开发环境: Centos 7 云服务器, vscode, Mysql Workbench 0.2 建立目录及文件 0.3 项目宏观结构 具体的功能类似 leetcode 的题目列表&#43;在线编程功能 1. compile 服务设计 由于compiler这个模块管理的是编译与运行,则可以先直接就创建所需要的文件 1.0 书写makefile文件 随着后续代码的跟进,并不断引入第三方库,这里还会新增编译选项 1.1 compiler_server 1.1.0 编译功能(compiler.hpp) 在编译的时候,无非存在2种情况,a)要么通过,b)要么不通过要确定编译通过:
只需要确定是否生成对应的.exe文件要当编译出错的时候(stderr):
需要将出错信息,重定向到一个临时文件中,保存编译出错的结果
还需要调用fork();子进程完成编译工作
父进程继续执行 由于需要频繁的文件名转换,所以在comm模块中,新建util.hpp文件并将文件名转换的函数放在一起 还有后面判断编译成功生成的可执行程序,虽然可以直接暴力的打开文件判断是否存在,但这里使用stat函数会好一些stat结构体会记录文件的各种信息 注意: 程序替换是不会影响进程的文件符描述符表的 1.1.1 日志模块(log.hpp) 由于一般日志都会带上时间, 这里还需要实现一个得到当前时间的函数,则我又在util.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-16T22:24:45+08:00">
    <meta property="article:modified_time" content="2024-06-16T22:24:45+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">实战项目: 负载均衡</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>0. 前言</h2> 
<blockquote> 
 <p>这个项目使用了前后端,<span style="color:#956fe7;"><strong>实现一个丐版的LeetCode刷题网站</strong></span>,并根据每台主机的实际情况,选择对应的主机,<strong><span style="color:#fe2c24;">负载均衡的调度 </span></strong></p> 
</blockquote> 
<p><img alt="" height="516" src="https://images2.imgbox.com/fc/88/RX7A6ABc_o.png" width="598"></p> 
<p><img alt="" height="559" src="https://images2.imgbox.com/55/bf/y3CSvkRR_o.png" width="562"></p> 
<h3>0.1 <span style="color:#333333;"><strong>所用技术与开发环境 </strong></span></h3> 
<p><span style="color:#fe2c24;"><strong>所用技术</strong></span>:  </p> 
<ul><li> 
  <div> 
   <span style="color:#333333;">C++ STL </span> 
   <span style="color:#333333;">标准库 </span> 
  </div> </li><li> 
  <div> 
   <span style="color:#333333;">Boost 准标准库</span> 
   <span style="color:#333333;">(</span> 
   <span style="color:#333333;">字符串切割</span> 
   <span style="color:#333333;">) </span> 
  </div> </li><li> 
  <div> 
   <span style="color:#333333;">cpp-</span> 
   <span style="color:#333333;">httplib </span> 
   <span style="color:#333333;">第三方开源网络库 </span> 
  </div> </li><li> 
  <div> 
   <span style="color:#333333;">ctemplate 第三方开源前端网页渲染库 </span> 
  </div> </li><li> 
  <div> 
   <span style="color:#333333;">jsoncpp 第三方开源序列化、反序列化库 </span> 
  </div> </li><li> 
  <div> 
   <span style="color:#333333;">负载均衡设计 </span> 
  </div> </li><li> 
  <div> 
   <span style="color:#333333;">多进程、多线程 </span> 
  </div> </li><li> 
  <div> 
   <span style="color:#333333;">MySQL C connect </span> 
  </div> </li><li> 
  <div> 
   <span style="color:#333333;">Ace前端在线编辑器</span> 
   <span style="color:#333333;">(</span> 
   <span style="color:#333333;">部分</span> 
   <span style="color:#333333;">) </span> 
  </div> </li><li> 
  <div> 
   <span style="color:#333333;">html/css/js/jquery/ajax (部分</span> 
   <span style="color:#333333;">) </span> 
  </div> </li></ul> 
<div> 
 <span style="color:#fe2c24;"><strong>开发环境</strong></span>:  
 <span style="color:#333333;">Centos 7 </span> 
 <span style="color:#333333;">云服务器,</span> 
 <span style="color:#333333;">vscode, </span> 
 <span style="color:#333333;">Mysql Workbench</span> 
</div> 
<div></div> 
<h3>0.2 建立目录及文件</h3> 
<p><img alt="" height="274" src="https://images2.imgbox.com/39/4a/6Jxz8JRI_o.png" width="586"></p> 
<p><img alt="" height="145" src="https://images2.imgbox.com/8b/33/0Ax2F2ic_o.png" width="630"></p> 
<h3>0.3 项目宏观结构</h3> 
<h2><img alt="" height="292" src="https://images2.imgbox.com/a5/b6/IdUSZ0uF_o.png" width="633"></h2> 
<ul><li><span style="color:#333333;">具体的功能<span style="background-color:#a2e043;">类似 leetcode 的题目列表+在线编程功能</span></span><span style="background-color:#a2e043;"> </span></li></ul> 
<h2>1. <span style="color:#333333;">compile </span><span style="color:#333333;"><strong>服务设计</strong></span></h2> 
<p><img alt="" height="313" src="https://images2.imgbox.com/1b/45/HChp1bcv_o.png" width="314"></p> 
<ul><li> 由于compiler这个模块管理的是<span style="color:#956fe7;"><strong>编译与运行</strong></span>,则可以先直接就创建所需要的文件</li></ul> 
<h3>1.0 书写makefile文件 </h3> 
<p><img alt="" height="203" src="https://images2.imgbox.com/d9/e2/ujmd4bjG_o.png" width="548"></p> 
<ul><li>  随着后续代码的跟进,并不断<span style="background-color:#ffd900;">引入第三方库,这里还会新增编译选项</span></li></ul> 
<h3>1.1 compiler_server</h3> 
<h4>1.1.0 <span style="color:#333333;">编译功能(compiler.hpp)</span></h4> 
<p><img alt="" height="409" src="https://images2.imgbox.com/63/5a/g8Jwq7WY_o.png" width="651"></p> 
<p><img alt="" height="218" src="https://images2.imgbox.com/f2/a1/QhAa9veL_o.png" width="650"></p> 
<ul><li> 在编译的时候,无非存在<span style="color:#fe2c24;"><strong>2种情况,</strong></span>a)要么通过,b)要么不通过</li><li><span style="background-color:#a2e043;">要确定编译通过:</span><br> 只需要确定是否生成对应的.exe文件</li><li><span style="background-color:#a2e043;">要当编译出错的时候(stderr):</span><br> 需要将出错信息,重定向到一个临时文件中,保存编译出错的结果<br> 还需要<span style="color:#fe2c24;"><strong>调用fork()</strong></span>;子进程完成编译工作<br> 父进程继续执行</li></ul> 
<hr> 
<p><img alt="" height="738" src="https://images2.imgbox.com/03/26/OWmUkPMs_o.png" width="659"></p> 
<ul><li> 由于需要频繁的文件名转换<span style="background-color:#ffd900;">,所以在comm模块中,新建util.hpp文件</span>并将文件名转换的函数放在一起</li></ul> 
<hr> 
<p> <img alt="" height="153" src="https://images2.imgbox.com/4f/af/Q9MTEVjU_o.png" width="643"></p> 
<ul><li>还有后面判断编译成功生成的可执行程序,虽然可以直接暴力的打开文件判断是否存在,但这里使用<span style="background-color:#a2e043;">stat函数会好一些</span></li><li><span style="background-color:#ffd900;">stat结构体会记录文件的各种信息</span></li></ul> 
<hr> 
<p><img alt="" height="597" src="https://images2.imgbox.com/87/7f/GSaXuZKm_o.png" width="675"></p> 
<ul><li><span style="color:#fe2c24;"><strong> 注意: </strong></span>程序替换是<strong><span style="color:#fe2c24;">不会影响</span></strong>进程的文件符描述符表的</li></ul> 
<h4>1.1.1 日志模块(log.hpp)</h4> 
<p><img alt="" height="737" src="https://images2.imgbox.com/e5/68/qk4sCA8T_o.png" width="669"></p> 
<p>由于一般<span style="color:#fe2c24;"><strong>日志都会带上时间,</strong></span> 这里还需要实现一个得到当前时间的函数,则我又在util.hpp把得到时间函数的类<span style="background-color:#a2e043;">封装成了一个类</span></p> 
<hr> 
<p><img alt="" height="243" src="https://images2.imgbox.com/23/0a/uhNDOevW_o.png" width="567"></p> 
<p> <img alt="" height="232" src="https://images2.imgbox.com/24/83/HLCaoaj1_o.png" width="445"></p> 
<p><img alt="" height="234" src="https://images2.imgbox.com/66/33/OEnA5quw_o.png" width="597"></p> 
<hr> 
<blockquote> 
 <p>由于会频繁的调用日志进行打印信息,也为了<span style="background-color:#a2e043;">更简便的调用</span>,我进行了以下处理</p> 
</blockquote> 
<p> <img alt="" height="74" src="https://images2.imgbox.com/37/17/ZZVvVHwm_o.png" width="525"></p> 
<ul><li><span style="background-color:#ffd900;">如果在宏定义中使用#，那么这个宏就被称为带有字符串化操作的宏</span>。这种宏可以将其参数转换成字符串常量，并在预处理阶段进行替换。 </li></ul> 
<hr> 
<blockquote> 
 <p>由于引入了日志,则就可以把之前所有的<span style="background-color:#a2e043;">输出信息,换成日志输出 </span></p> 
</blockquote> 
<p><img alt="" height="259" src="https://images2.imgbox.com/ab/ff/fugxkesd_o.png" width="492"></p> 
<h4>1.1.2 测试编译模块 </h4> 
<p><img alt="" height="283" src="https://images2.imgbox.com/b3/6a/35TALprv_o.png" width="667"></p> 
<p><img alt="" height="246" src="https://images2.imgbox.com/4a/3d/gnFHtenc_o.png" width="585"></p> 
<ul><li> Compile的参数是文件名,它内部会自动拼接</li><li>我们还需要再<span style="background-color:#a2e043;">./temp中创建一个code.cpp文件</span></li></ul> 
<hr> 
<p><img alt="" height="774" src="https://images2.imgbox.com/b9/5b/cSYT1zht_o.png" width="654"></p> 
<ul><li><span style="color:#fe2c24;"><strong> 上面我的代码有一个错误</strong></span>,在编译成功的时候,并<span style="background-color:#ffd900;">没有return,导致LOG日志打印有问题</span></li></ul> 
<hr> 
<p><img alt="" height="552" src="https://images2.imgbox.com/04/4e/sIQAraQv_o.png" width="631"></p> 
<ul><li> <span style="background-color:#ffd900;">要是我们的源文件有问题</span>,错误信息就会<strong><span style="color:#fe2c24;">重定向</span></strong>到 文件.compile_error中</li><li>在测试的时候,<span style="background-color:#a2e043;">还需要把 文件.exe 文件.compile_error文件删除</span>,就是上次生成的文件</li></ul> 
<h4>1.1.3 <span style="color:#333333;">运行功能(runner.hpp)</span> </h4> 
<p>程序运行: 1)代码跑完,结果正确 2)代码跑完,结果不正确, 3)代码没跑完,异常了</p> 
<blockquote> 
 <p>程序结果是否正确,是由<span style="color:#956fe7;"><strong>oj_server</strong></span>中的测试用例决定的,则<span style="color:#fe2c24;"><strong>run模块只考虑是否正确运行完毕</strong></span></p> 
</blockquote> 
<div> 
 <pre><code class="language-cpp">#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;unistd.h&gt;// fork接口需要

#include "../comm/log.hpp"
#include "../comm/util.hpp"
namespace ns_runner
{

    using namespace ns_util;
    using namespace ns_log;
    class Runner
    {
    public:
        Runner(){}
        ~Runner(){}
        static int Run(const std::string &amp;file_name){
            std::string _execute = PathUtil::Exe(file_name);// 可执行
            std::string _stdin = PathUtil::Stdin(file_name);// 输入
            std::string _stdout = PathUtil::Stdout(file_name);// 输出
            std::string _stderr = PathUtil::Stderr(file_name);// 错误

            umask(0);
            int _stdin_fd = open(_stdin.c_str(),O_CREAT | O_RDONLY,0644);
            int _stdout_fd = open(_stdout.c_str(),O_CREAT | O_WRONLY,0644);
            int _stderr_fd = open(_stderr.c_str(),O_CREAT | O_WRONLY,0644);

            if(_stdin_fd &lt; 0 || _stdout_fd &lt; 0 || _stderr_fd &lt; 0){
                LOG(ERROR) &lt;&lt; "运行时打开标准文件失败" &lt;&lt; "\n";
                return -1;// 代表打开文件失败
            }

            pid_t pid = fork();
            if(pid &lt; 0){
                LOG(ERROR) &lt;&lt; "运行创建子进程失败" &lt;&lt; "\n";
                close(_stdin_fd);
                close(_stdout_fd);
                close(_stderr_fd);
                return -2;// 代表创建自己失败
            }
            else if(pid == 0){
                // 子进程
                dup2(_stdin_fd,0);
                dup2(_stdout_fd,1);
                dup2(_stderr_fd,2);
                LOG(INFO) &lt;&lt; "123";// 是不是有问题啊
                // 这个程序替换等价于 ./tmp/code.exe ./tmp/code.exe
                execl(_execute.c_str(),_execute.c_str(),nullptr);
                exit(1);
            }
            else{
                close(_stdin_fd);
                close(_stdout_fd);
                close(_stderr_fd);
                int status = 0;// 表示输出型参数
                waitpid(pid,&amp;status,0);// 阻塞式等待

                // 程序运行异常,一定是因为收到信号
                LOG(INFO) &lt;&lt; "运行完毕,infor: " &lt;&lt; (status &amp; 0x7f) &lt;&lt; "\n";
                return status &amp; 0x7f;
            }
        }
    };
}</code></pre> 
</div> 
<p><img alt="" height="262" src="https://images2.imgbox.com/26/45/DLDV9BiM_o.png" width="599"></p> 
<ul><li> <p><span style="color:#fe2c24;"><strong>返回值 &gt; 0: 程序异常了</strong></span>，退出时收到了信号，返回值就是对应的信号编号<br><span style="color:#fe2c24;"><strong>返回值 == 0: 正常运行完毕的，</strong></span>结果保存到了对应的临时文件中<br><span style="color:#fe2c24;"><strong>返回值 &lt; 0: 内部错误</strong></span></p> </li><li>run.hpp也是一样的,把自己的各种输出信息,<span style="background-color:#a2e043;">输出到一个临时文件中</span></li><li><span style="background-color:#ffd900;">要判断一个程序是否异常,只需要看它是否收到了异常信号</span></li></ul> 
<hr> 
<p><strong>解释waitpid第2个输出型参数 </strong></p> 
<p> <img alt="" height="173" src="https://images2.imgbox.com/3d/cf/qqMfKwv0_o.png" width="572"></p> 
<ul><li> status并不是按照整数来整体使用的,而是按照比特位的方式,将32个比特位进行划分,<strong>只需要学习低16位</strong></li><li>这也是上面为什么会写成<span style="color:#fe2c24;"><strong>status &amp; 0x7F</strong></span>的原因</li></ul> 
<hr> 
<blockquote> 
 <p>那<span style="color:#956fe7;"><strong>6个程序替换</strong></span>的系统接口,具体使用那个看实际情况 </p> 
</blockquote> 
<p><img alt="" height="257" src="https://images2.imgbox.com/78/da/VOdJrCye_o.png" width="513"></p> 
<ul><li><span style="color:#fe2c24;"><strong>没有p就需要带路径</strong></span></li><li>有l,就是列表式传命令</li><li>有v就是数组式传命令</li><li>有e就需要传自己设置的环境变量</li></ul> 
<h4>1.1.4 测试运行模块</h4> 
<p><img alt="" height="411" src="https://images2.imgbox.com/8b/ba/tTVubUsU_o.png" width="670"></p> 
<ul><li>虽然运行模块已经能正常运行了,但是万一code.cpp是恶意程序了,比如<span style="background-color:#a2e043;">死循环,不停消耗CPU资源 ,</span> 所以还<span style="background-color:#ffd900;">需要进一步的资源约束</span></li></ul> 
<h4>1.1.5 添加资源限制(setrlimit)</h4> 
<p><img alt="" height="263" src="https://images2.imgbox.com/33/51/aPnEcmmh_o.png" width="645"></p> 
<p><img alt="" height="556" src="https://images2.imgbox.com/77/e6/WoIx0n0O_o.png" width="664"></p> 
<p><img alt="" height="225" src="https://images2.imgbox.com/8f/87/RVyGXRo6_o.png" width="567"></p> 
<ul><li><span style="color:#0d0016;"><span style="background-color:#a2e043;">资源不足，导致OS终止进程</span>，是通过</span><span style="color:#fe2c24;"><strong>信号</strong></span><span style="color:#0d0016;">终止的  </span></li></ul> 
<hr> 
<p> <img alt="" height="225" src="https://images2.imgbox.com/48/f2/uVNego47_o.png" width="625"></p> 
<ul><li> 为了方便上层调用,我直接在<span style="background-color:#ffd900;">Run函数中增加了cpu_limit和mem_limit形参</span></li></ul> 
<p> 这个项目走到这里就需要编<span style="background-color:#a2e043;">写compile_run.hpp,将编译和运行的逻辑连接在一起</span>,且code.cpp需要<strong><span style="color:#956fe7;">被处理的源文件,</span></strong>不应该是我们自己添加的,而是需要再<strong><span style="color:#956fe7;">客户端中导入</span></strong>的</p> 
<h4>1.1.6 编译 &amp;&amp; 运行功能 (<span style="color:#333333;">compile_run.hpp</span>)</h4> 
<blockquote> 
 <div>
   这个模块要做的是: 
 </div> 
 <div> 
  <span style="color:#fe2c24;"><strong>a)</strong></span>适配用户请求,引入json定制通信协议字段 
 </div> 
 <div> 
  <span style="color:#fe2c24;"><strong>b)</strong></span>形成唯一文件名 
 </div> 
 <div> 
  <span style="color:#fe2c24;"><strong>c)</strong></span>正确调用compile and run 
 </div> 
</blockquote> 
<div> 
 <pre><code>在centos中安装: sudo yum install json-c-devel</code></pre> 
</div> 
<div> 
 <pre><code>头文件 #include &lt;jsoncpp/json/json.h&gt;</code></pre> 
</div> 
<p><img alt="" height="371" src="https://images2.imgbox.com/d8/07/C5o20CLg_o.png" width="677"></p> 
<ul><li> 注意: 在编译引入了json的文件<span style="background-color:#a2e043;">,需要加上-ljsoncpp</span></li></ul> 
<hr> 
<p><img alt="" height="555" src="https://images2.imgbox.com/2e/90/QkMXshQu_o.png" width="524"></p> 
<p> <img alt="" height="245" src="https://images2.imgbox.com/50/eb/Rjrnh1g5_o.png" width="381"></p> 
<ul><li>虽然这个code就是文件名了,但client可能会提交大量的代码,所以内部就会需要<span style="background-color:#a2e043;">形成唯一的文件名(待完善)</span></li><li>还有<span style="background-color:#ffd900;">很多个出错问题怎么解决(待完善)</span></li></ul> 
<hr> 
<p><strong> complie_run.hpp</strong></p> 
<div> 
 <pre><code class="language-cpp">#pragma once

#include "compiler.hpp"
#include "runner.hpp"
#include "../comm/log.hpp"
#include "../comm/util.hpp"
#include &lt;jsoncpp/json/json.h&gt;

namespace ns_compile_and_run
{
    using namespace ns_log;
    using namespace ns_util;
    using namespace ns_compiler;
    using namespace ns_runner;
    
    // in_json: {"code": "#include...", "input": "","cpu_limit":1, "mem_limit":10240}
    // out_json: {"status":"0", "reason":"","stdout":"","stderr":"",}
    static void Start(const std::string &amp;in_json,std::string *out_json){
        // step1: 反序列化过程
        Json::Value in_value;
        Json::Reader reader;
        // 把in_json中的数据写到in_value中
        reader.parse(in_json,in_value);// 最后再处理差错问题

        std::string code = in_value["code"].asString();
        std::string input = in_value["input"].asString();
        int cpu_limit = in_value["cpu_limit"].asInt();
        int mem_limit = in_value["mem_limit"].asInt();

        Json::Value out_value;
        int status_code = 0;
        int run_result = 0;
        std::string file_name;// 唯一文件名
        if(code.size() == 0){
            status_code = -1;// 代码为空
            goto END;
        }
        // 形成的文件名只居有唯一性,没有目录没有后缀
        // 使用: 毫秒级时间戳 + 原子性递增唯一值 : 来保证唯一性
        file_name = FileUtil::UniqFileName();
        // 形成临时的src文件
        if(!FileUtil::WriteFile(PathUtil::Src(file_name),code)){
            status_code = -2;// 未知错误
            goto END;
        }

        if(!Compiler::Compile(file_name)){
            status_code = -3;// 编译错误
            goto END;
        }
        run_result = Runner::Run(file_name,cpu_limit,mem_limit);
        if(run_result &lt; 0){
            // runnem模块内部错误
            status_code = -2;// 未知错误
        }
        else if(run_result &gt; 0){
            // 程序运行崩溃
            status_code = run_result;// 这里的run_result是信号
        }
        else{
            // 运行成功
            status_code = 0;
        }
    END:
        out_value["status"] = status_code;
        out_value["reason"] = CodeToDest(status_code,file_name);// 得到错误信息字符串
        if(status_code == 0){
            // 整个过程全部成功
            std::string _stdout;
            FileUtil::ReadFile(PathUtil::Stdout(file_name),&amp;_stdout,true);
            out_value["stdout"] = _stdout;

            std::string _stderr;
            FileUtil::ReadFile(PathUtil::Stdout(file_name),&amp;_stderr,true);
            out_value["stdout"] = _stdout;
        }

        // step2: 序列化
        Json::StyledWriter writer;
        *out_json = writer.write(out_value);
        

    }
    

}</code></pre> 
</div> 
<p><img alt="" height="641" src="https://images2.imgbox.com/77/0f/ZJSYRB7j_o.png" width="594"></p> 
<h4> 1.1.7 基于compile_run.hpp对util.hpp的补充</h4> 
<p><img alt="" height="245" src="https://images2.imgbox.com/ad/80/LEzrJqcP_o.png" width="655"></p> 
<hr> 
<p> <img alt="" height="407" src="https://images2.imgbox.com/6c/e6/cnPxCafa_o.png" width="605"></p> 
<ul><li>注意引入流时需要引入头文件:<span style="color:#956fe7;"> <strong>#include &lt;fstream&gt;  </strong></span></li><li> <p><span style="background-color:#a2e043;">getline:不保存行分割符,有些时候需要保留\n,</span>getline内部重载了强制类型转化 </p> </li></ul> 
<h4>1.1.8 测试编译运行模块 </h4> 
<div> 
 <pre><code class="language-cpp">#include "compile_run.hpp"
using namespace ns_compile_and_run;

int main()
{
    std::string in_json;
    Json::Value in_value;
    // R"()", raw string
    in_value["code"] = R"(#include&lt;iostream&gt;
    int main(){
    std::cout &lt;&lt; "你可以看见我了" &lt;&lt; std::endl;
    return 0;
    })";
    in_value["input"] = "";
    in_value["cpu_limit"] = 1;
    in_value["mem_limit"] = 10240 * 3;
    Json::FastWriter writer;
    in_json = writer.write(in_value);
    // std::cout &lt;&lt; in_json &lt;&lt; std::endl;
    // 这个是将来给客户端返回的json串
    std::string out_json;
    CompileAndRun::Start(in_json, &amp;out_json);
    std::cout &lt;&lt; out_json &lt;&lt; std::endl;
    return 0;
}</code></pre> 
</div> 
<p><img alt="" height="165" src="https://images2.imgbox.com/a8/4f/Mgjbs1LV_o.png" width="666"></p> 
<p><img alt="" height="184" src="https://images2.imgbox.com/c1/09/WILQVZSG_o.png" width="664"></p> 
<ul><li> 实际上这里的代码应该是client自动提交给我们的,我们直接<span style="color:#fe2c24;"><strong>使用第三方库</strong></span>就行了</li><li>待优化: <span style="background-color:#a2e043;">可以把临时生成的这些文件都清理掉,</span></li></ul> 
<h4>1.1.9 清理临时文件</h4> 
<p><img alt="" height="431" src="https://images2.imgbox.com/ea/14/gOfMP0xS_o.png" width="600"></p> 
<p><img alt="" height="240" src="https://images2.imgbox.com/07/19/82VaxmkT_o.png" width="624"></p> 
<ul><li> 这个函数直接放在<span style="background-color:#ffd900;">compile_server.cc中的start函数的最后,清理临时文件</span></li></ul> 
<h4>1.1.10 引入cpp-httplib 网络库</h4> 
<blockquote> 
 <p> 下载地址: <a href="https://gitee.com/yuanfeng1897/cpp-httplib/tree/v0.7.15" rel="nofollow" title="cpp-httplib: C++ http 网络库 - Gitee.com">cpp-httplib: C++ http 网络库 - Gitee.com</a></p> 
</blockquote> 
<p><img alt="" height="259" src="https://images2.imgbox.com/86/87/lU5Hmyda_o.png" width="680"></p> 
<ul><li> 这个就是别人写好的网络库,我们<span style="color:#fe2c24;"><strong>直接使用</strong></span>就行了</li></ul> 
<h4>1.1.11 更新gcc</h4> 
<blockquote> 
 <p><span style="color:#aa5500;">安装</span><span style="color:#aa5500;">scl : </span>sudo yum install centos-release-scl scl-utils-build</p> 
 <div> 
  <span style="color:#aa5500;">安装新版本gcc: </span> 
  <span style="color:#000000;">sudo yum install </span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#000000;">y devtoolset</span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#116644;">9</span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#000000;">gcc devtoolset</span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#116644;">9</span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#000000;">gcc</span> 
  <span style="color:#981a1a;">-</span> 
  <span style="color:#000000;">c</span> 
  <span style="color:#981a1a;">++ </span> 
 </div> 
</blockquote> 
<p><img alt="" height="335" src="https://images2.imgbox.com/e7/c9/xx5w8lGP_o.png" width="486"></p> 
<p><img alt="" height="271" src="https://images2.imgbox.com/36/6e/YMNeoFhu_o.png" width="526"></p> 
<ul><li>把 <span style="color:#000000;"><span style="background-color:#a2e043;">scl enable devtoolset</span></span><span style="color:#981a1a;"><span style="background-color:#a2e043;">-</span></span><span style="color:#116644;"><span style="background-color:#a2e043;">9 </span></span><span style="color:#000000;"><span style="background-color:#a2e043;">bash </span>放在 ~</span><span style="color:#981a1a;">/</span><span style="color:#333333;">.</span><span style="color:#000000;">bash_profile中</span></li><li><span style="color:#0d0016;">想每次登陆的时候，都是较新的gcc</span></li></ul> 
<p> 如果不更新在使用cpp-httplib时<span style="color:#956fe7;"><strong>可能会报错, </strong></span><span style="color:#000000;">用老的编译器，要么编译不通过，要么直接运行报错</span></p> 
<h4>1.1.12 测试cpp-httplib网络库 </h4> 
<p><img alt="" height="348" src="https://images2.imgbox.com/b7/22/EedfLkDO_o.png" width="674"></p> 
<p><img alt="" height="341" src="https://images2.imgbox.com/5e/d4/K5VdzArN_o.png" width="680"></p> 
<ul><li>可能会出现<span style="color:#fe2c24;"><strong>服务器的公网ip无法访问的问题</strong></span>,可以试试把<span style="background-color:#a2e043;">防火墙关闭,并打开端口</span></li></ul> 
<h4>1.1.13 将compiler_server打包成网络服务</h4> 
<p><strong>compiler_server.cc</strong></p> 
<div> 
 <pre><code class="language-cpp">#include "compile_run.hpp"
#include "../comm/httplib.h"// 引入

using namespace ns_compile_and_run;
using namespace httplib;// 引入

void Usage(std::string proc){
    std::cerr &lt;&lt; "Usage: " &lt;&lt; "\n\t" &lt;&lt; proc &lt;&lt; " port" &lt;&lt; std::endl;
}

//./copile_server port
int main(int argc,char *argv[])
{
    if(argc != 2){
        Usage(argv[0]);
        return 1;
    }
    Server svr;
    svr.Post("/compile_and_run",[](const Request&amp;req,Response &amp; resp){
        // 用户请求的服务正文是我们想要的json string
        std::string in_json = req.body;
        std::string out_json;
        if(!in_json.empty()){
            CompileAndRun::Start(in_json,&amp;out_json);
            resp.set_content(out_json,"application/json;charset=uft-8");
        }
    });
    svr.listen("0.0.0.0",atoi(argv[1]));
    return 0;
}


</code></pre> 
</div> 
<ul><li>由于我这里<span style="background-color:#a2e043;">没有写客户端代码,则这里暂时不好测试</span>,不过可以借助第三方工具进行测试</li></ul> 
<h2> 2. oj_server服务设计</h2> 
<div> 
 <span style="color:#333333;">本质：</span> 
 <span style="color:#956fe7;"><strong>建立一个小型网站</strong></span> 
</div> 
<div></div> 
<blockquote> 
 <div> 
  <div> 
   <strong><span style="color:#116644;">1. </span><span style="color:#000000;">获取首页，用题目列表充当 </span></strong> 
  </div> 
  <div> 
   <strong><span style="color:#116644;">2. </span><span style="color:#000000;">编辑区域页面 </span></strong> 
  </div> 
  <div> 
   <strong><span style="color:#116644;">3. </span><span style="color:#000000;">提交判题功能</span><span style="color:#333333;">(</span><span style="color:#000000;">编译并运行</span><span style="color:#333333;">)</span></strong> 
  </div> 
 </div> 
</blockquote> 
<h3>2.1 书写makefile文件</h3> 
<p><img alt="" height="205" src="https://images2.imgbox.com/13/dc/XIA8Ff6o_o.png" width="527"></p> 
<ul><li> 随着后续代码的跟进,并不断<span style="background-color:#ffd900;">引入第三方库,这里还会新增编译选项</span></li></ul> 
<h3>2.2 <span style="color:#333333;">服务路由功能(oj_server.cc)</span> </h3> 
<p><img alt="" height="653" src="https://images2.imgbox.com/07/52/tmBD5ckc_o.png" width="628"></p> 
<p><img alt="" height="278" src="https://images2.imgbox.com/23/18/oeZ0AMwo_o.png" width="664"></p> 
<ul><li>为用户实现的路由功能就3个<strong><span style="color:#956fe7;"> a. 获取所有的题目列表</span></strong><span style="color:#ff9900;"><strong> b.根据题目编号,获取题目内容</strong> </span><span style="color:#fe2c24;"><strong>c.判断用户提交的代码 </strong></span> </li></ul> 
<h3><span style="color:#333333;">2.3 MVC </span><span style="color:#333333;"><strong>结构的</strong></span><span style="color:#333333;">oj </span><span style="color:#333333;"><strong>服务设计(M)</strong></span></h3> 
<blockquote> 
 <div> 
  <span style="color:#000000;">Model</span> 
  <span style="color:#333333;">,</span> 
  <span style="color:#fe2c24;"><strong>通常是和数据交互的模块</strong></span> 
  <span style="color:#000000;">，比如，对题库进行增删改查（文件版，</span> 
  <span style="color:#000000;">MySQL</span> 
  <span style="color:#000000;">） </span> 
 </div> 
</blockquote> 
<h4>2.3.1 <span style="color:#333333;"><strong>安装</strong></span><span style="color:#333333;"><strong>boost</strong></span><span style="color:#333333;"><strong>库 &amp;&amp; 字符切分功能</strong></span></h4> 
<blockquote> 
 <p><span style="color:#000000;">sudo yum install </span><span style="color:#981a1a;">-</span><span style="color:#000000;">y boost</span><span style="color:#981a1a;">-</span><span style="color:#000000;">devel </span><span style="color:#aa5500;">//</span><span style="color:#aa5500;">是</span><span style="color:#aa5500;">boost </span><span style="color:#aa5500;">开发库</span></p> 
</blockquote> 
<p><img alt="" height="298" src="https://images2.imgbox.com/1b/10/hleaSvtG_o.png" width="671"></p> 
<ul><li> 第一个参数为<span style="color:#956fe7;"><strong>缓冲区</strong></span>,第二个参数为<strong><span style="color:#956fe7;">被分割的字符串</span></strong></li><li>第三个参数为<span style="color:#956fe7;"><strong>分割符</strong></span>,第四个参数为<span style="color:#fe2c24;"><strong>是否压缩</strong></span> 
  <ul><li>要压缩: 当sep = "空格"时,sepsepsep -&gt; 空格</li><li>不压缩: 当sep = "空格"时,sepsepsep -&gt; 空格空格空格</li></ul></li></ul> 
<h4> 2.3.2 数据结构</h4> 
<p><strong>header.cpp</strong></p> 
<div> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;algorithm&gt;

using namespace std;

class Solution{
    public:
        bool isPalindrome(int x)
        {
            //将你的代码写在下面
            
            return true;
        }
};</code></pre> 
</div> 
<p><strong>tail.cpp</strong></p> 
<div> 
 <pre><code class="language-cpp">#ifndef COMPILER_ONLINE
#include "header.cpp"
#endif

// 这里先把测试用例 暴露出来
void Test1()
{
    // 通过定义临时对象，来完成方法的调用
    bool ret = Solution().isPalindrome(121);
    if(ret){
        std::cout &lt;&lt; "通过用例1, 测试121通过 ... OK!" &lt;&lt; std::endl;
    }
    else{
        std::cout &lt;&lt; "没有通过用例1, 测试的值是: 121"  &lt;&lt; std::endl;
    }
}

void Test2()
{
    // 通过定义临时对象，来完成方法的调用
    bool ret = Solution().isPalindrome(-10);
    if(!ret){
        std::cout &lt;&lt; "通过用例2, 测试-10通过 ... OK!" &lt;&lt; std::endl;
    }
    else{
        std::cout &lt;&lt; "没有通过用例2, 测试的值是: -10"  &lt;&lt; std::endl;
    }
}

int main()
{
    Test1();
    Test2();

    return 0;
}</code></pre> 
</div> 
<p><img alt="" height="333" src="https://images2.imgbox.com/11/9e/MCkahKgB_o.png" width="672"></p> 
<p><img alt="" height="547" src="https://images2.imgbox.com/66/1b/FWPLWGAO_o.png" width="657"></p> 
<ul><li><span style="color:#956fe7;"><strong>des.txt</strong></span>表示题目信息</li><li><span style="color:#956fe7;"><strong> header.cpp</strong></span>表示预设代码</li><li><span style="color:#956fe7;"><strong>tail.cpp</strong></span>表示测试用例</li></ul> 
<hr> 
<p><img alt="" height="178" src="https://images2.imgbox.com/3e/90/W1RtkLOc_o.png" width="434"></p> 
<ul><li><span style="background-color:#a2e043;"> 真正代码 = 用户在head.cpp中的代码 + header.cpp + tail.cpp </span>并<span style="color:#4da8ee;"><strong>去到COMPILER_ONLINE</strong></span></li><li> 这个条件编译只是为了编写tail.cpp时<span style="color:#fe2c24;"><strong>不报错</strong></span></li></ul> 
<h4>2.3.3 <span style="color:#333333;">model功能(oj_model.cpp)</span></h4> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>数据交互 &amp;&amp; 提供接口</strong></span></p> 
</blockquote> 
<p> <img alt="" height="198" src="https://images2.imgbox.com/be/23/yv8z9MMX_o.png" width="613"></p> 
<div> 
 <pre><code class="language-cpp">#pragma once
// 文件版本
#include "../comm/util.hpp"
#include "../comm/log.hpp"
#include &lt;unordered_map&gt;
#include &lt;cassert&gt;
#include &lt;vector&gt;

namespace ns_model
{
    using namespace std;
    using namespace ns_log;
    using namespace ns_util;

    struct Question{
        string number;// 题目编号,唯一
        string tile;// 题目标题
        string star;// 难度: 简单 中等 困难
        
        int cpu_limit;// 题目的时间复杂度(S)
        int mem_limit;// 题目的空间复杂度(KB)
        
        string desc;// 题目描述
        string header; // 题目预设给用户在线编辑器的代码
        string tail;// 题目测试用例,需要和header拼接
    };    

    const string questions_list = "./question/quetions.list";
    const string questions_path = "./question";

    class Model
    {
    public:
        Model(){
            // 加载所有题目:底层是用hash表映射的
            assert(LoadQuestionList(questions_list));
        }
        ~Model(){
            ;
        }

        // 获取所有题目,这里的out是输出型参数
        bool GetAllQuestions(vector&lt;Question&gt;*out){
            if(questions.size() == 0){
                LOG(ERROR) &lt;&lt; "用户获取题库失败" &lt;&lt; "\n";
                return false;
            }
            for(const auto&amp;q: questions){
                out-&gt;push_back(q.second);
            }
            return true;
        }

        // 获取指定题目,这里的q是输出型参数
        bool GetOneQuestion(const string&amp; number,Question* q){
            const auto&amp; iter = questions.find(number);
            if(iter == questions.end()){
                LOG(ERROR) &lt;&lt; "用户获取题目失败,题目编号: " &lt;&lt; number &lt;&lt; "\n";
                return false;
            }
            (*q) = iter-&gt;second;
            return true;
        }

        // 加载配置文件: questions/questions.list + 题目编号文件
        bool LoadQuestionList(const string&amp;question_list){
            // 加载配置文件: questions/questions.list +题目编号文件
            ifstream in(question_list);
            if(!in.is_open()){
                LOG(FATAL) &lt;&lt; "加载题库失败,请检查是否存在题库文件" &lt;&lt; "\n";
                return false;
            }
            string line;
            while(getline(in,line)){
                vector&lt;string&gt;tokens;
                StringUtil::SplitString(line,&amp;tokens," ");// 被分割的字符串 缓冲区 分割符
                // eg: 1 判断回文数 简单 1 30000
                if(tokens.size()!=5){
                    LOG(WARNING) &lt;&lt; "加载部分题目失败,请检查文件格式" &lt;&lt; "\n";
                    continue;
                }
                Question q;
                q.number = tokens[0];
                q.tile = tokens[1];
                q.star = tokens[2];
                q.cpu_limit = atoi(tokens[3].c_str());
                q.mem_limit = atoi(tokens[4].c_str());

                string path = questions_list;
                path += q.number;
                path += "/";

                // 第三个参数代表 是否加上 \n
                FileUtil::ReadFile(path+"desc.txt",&amp;(q.desc),true);
                FileUtil::ReadFile(path+"header.cpp",&amp;(q.header),true);
                FileUtil::ReadFile(path+"tail.txt",&amp;(q.tail),true);
               
                questions.insert({q.number,q});// 录题成功
            }
            LOG(INFO) &lt;&lt; "加载题库...成功" &lt;&lt; "\n";
            in.close();
        }
    private:
        // 题号 : 题目细节
        unordered_map&lt;string,Question&gt; questions;
    };
} 

</code></pre> 
</div> 
<h3><span style="color:#333333;">2.4 MVC </span><span style="color:#333333;"><strong>结构的</strong></span><span style="color:#333333;">oj 服务</span><span style="color:#333333;"><strong>设计(C)</strong></span> </h3> 
<h4>2.4.1 负载均衡模块</h4> 
<div> 
 <pre><code class="language-cpp">namespace ns_control
{
    using namespace std;
    using namespace ns_log;
    using namespace ns_util;
    using namespace ns_model;
    using namespace ns_view;
    using namespace httplib;

    // 提供服务的主机
    class Machine
    {
    public:
        std::string ip;  //编译服务的ip
        int port;        //编译服务的port
        uint64_t load;   //编译服务的负载
        std::mutex *mtx; // mutex禁止拷贝的，使用指针
    public:
        Machine() : ip(""), port(0), load(0), mtx(nullptr)
        {
        }
        ~Machine()
        {
        }

    public:
        // 提升主机负载
        void IncLoad()
        {
            if (mtx) mtx-&gt;lock();
            ++load;
            if (mtx) mtx-&gt;unlock();
        }
        // 减少主机负载
        void DecLoad()
        {
            if (mtx) mtx-&gt;lock();
            --load;
            if (mtx) mtx-&gt;unlock();
        }
        void ResetLoad()
        {
            if(mtx) mtx-&gt;lock();
            load = 0;
            if(mtx) mtx-&gt;unlock();
        }
        // 获取主机负载,没有太大的意义，只是为了统一接口
        uint64_t Load()
        {
            uint64_t _load = 0;
            if (mtx) mtx-&gt;lock();
            _load = load;
            if (mtx) mtx-&gt;unlock();

            return _load;
        }
    };

    const std::string service_machine = "./conf/service_machine.conf";
    class LoadBlance
    {
    private:
        // 可以给我们提供编译服务的所有的主机
        // 每一台主机都有自己的下标，充当当前主机的id
        std::vector&lt;Machine&gt; machines;
        // 所有在线的主机id
        std::vector&lt;int&gt; online;
        // 所有离线的主机id
        std::vector&lt;int&gt; offline;
        // 保证LoadBlance它的数据安全
        std::mutex mtx;

    public:
        LoadBlance()
        {
            assert(LoadConf(service_machine));
            LOG(INFO) &lt;&lt; "加载 " &lt;&lt; service_machine &lt;&lt; " 成功"
                      &lt;&lt; "\n";
        }
        ~LoadBlance()
        {
        }

    public:
        bool LoadConf(const std::string &amp;machine_conf)
        {
            std::ifstream in(machine_conf);
            if (!in.is_open())
            {
                LOG(FATAL) &lt;&lt; " 加载: " &lt;&lt; machine_conf &lt;&lt; " 失败"
                           &lt;&lt; "\n";
                return false;
            }
            std::string line;
            while (std::getline(in, line))
            {
                std::vector&lt;std::string&gt; tokens;
                StringUtil::SplitString(line, &amp;tokens, ":");
                if (tokens.size() != 2)
                {
                    LOG(WARNING) &lt;&lt; " 切分 " &lt;&lt; line &lt;&lt; " 失败"
                                 &lt;&lt; "\n";
                    continue;
                }
                Machine m;
                m.ip = tokens[0];
                m.port = atoi(tokens[1].c_str());
                m.load = 0;
                m.mtx = new std::mutex();

                online.push_back(machines.size());
                machines.push_back(m);
            }

            in.close();
            return true;
        }
        // id: 输出型参数
        // m : 输出型参数
        bool SmartChoice(int *id, Machine **m)
        {
            // 1. 使用选择好的主机(更新该主机的负载)
            // 2. 我们需要可能离线该主机
            mtx.lock();
            // 负载均衡的算法
            // 1. 随机数+hash
            // 2. 轮询+hash
            int online_num = online.size();
            if (online_num == 0)
            {
                mtx.unlock();
                LOG(FATAL) &lt;&lt; " 所有的后端编译主机已经离线, 请运维的同事尽快查看"
                           &lt;&lt; "\n";
                return false;
            }
            // 通过遍历的方式，找到所有负载最小的机器
            *id = online[0];
            *m = &amp;machines[online[0]];
            uint64_t min_load = machines[online[0]].Load();
            for (int i = 1; i &lt; online_num; i++)
            {
                uint64_t curr_load = machines[online[i]].Load();
                if (min_load &gt; curr_load)
                {
                    min_load = curr_load;
                    *id = online[i];
                    *m = &amp;machines[online[i]];
                }
            }
            mtx.unlock();
            return true;
        }
        void OfflineMachine(int which)
        {
            mtx.lock();
            for(auto iter = online.begin(); iter != online.end(); iter++)
            {
                if(*iter == which)
                {
                    machines[which].ResetLoad();
                    //要离线的主机已经找到啦
                    online.erase(iter);
                    offline.push_back(which);
                    break; //因为break的存在，所有我们暂时不考虑迭代器失效的问题
                }
            }
            mtx.unlock();
        }
        void OnlineMachine()
        {
            //我们统一上线，后面统一解决
            mtx.lock();
            online.insert(online.end(), offline.begin(), offline.end());
            offline.erase(offline.begin(), offline.end());
            mtx.unlock();

            LOG(INFO) &lt;&lt; "所有的主机有上线啦!" &lt;&lt; "\n";
        }
        //for test
        void ShowMachines()
        {
             mtx.lock();
             std::cout &lt;&lt; "当前在线主机列表: ";
             for(auto &amp;id : online)
             {
                 std::cout &lt;&lt; id &lt;&lt; " ";
             }
             std::cout &lt;&lt; std::endl;
             std::cout &lt;&lt; "当前离线主机列表: ";
             for(auto &amp;id : offline)
             {
                 std::cout &lt;&lt; id &lt;&lt; " ";
             }
             std::cout &lt;&lt; std::endl;
             mtx.unlock();
        }
    };
}</code></pre> 
</div> 
<h4>2.4.1 <span style="color:#333333;">control功能(oj_control.hpp)</span></h4> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>逻辑控制模块</strong></span></p> 
</blockquote> 
<div> 
 <pre><code class="language-cpp">// 这是我们的核心业务逻辑的控制器
    class Control
    {
    private:
        Model model_; //提供后台数据
        View view_;   //提供html渲染功能
        LoadBlance load_blance_; //核心负载均衡器
    public:
        Control()
        {
        }
        ~Control()
        {
        }

    public:
        void RecoveryMachine()
        {
            load_blance_.OnlineMachine();
        }
        //根据题目数据构建网页
        // html: 输出型参数
        bool AllQuestions(string *html)
        {
            bool ret = true;
            vector&lt;struct Question&gt; all;
            if (model_.GetAllQuestions(&amp;all))
            {
                sort(all.begin(), all.end(), [](const struct Question &amp;q1, const struct Question &amp;q2){
                    return atoi(q1.number.c_str()) &lt; atoi(q2.number.c_str());
                });
                // 获取题目信息成功，将所有的题目数据构建成网页
                // ...
            }
            else
            {
                *html = "获取题目失败, 形成题目列表失败";
                ret = false;
            }
            return ret;
        }
        bool Question(const string &amp;number, string *html)
        {
            bool ret = true;
            struct Question q;
            if (model_.GetOneQuestion(number, &amp;q))
            {
                // 获取指定题目信息成功，将所有的题目数据构建成网页
                // ....
            }
            else
            {
                *html = "指定题目: " + number + " 不存在!";
                ret = false;
            }
            return ret;
        }
        // code: #include...
        // input: ""
        void Judge(const std::string &amp;number, const std::string in_json, std::string *out_json)
        {
            
        }
    };</code></pre> 
</div> 
<ul><li> <span style="color:#333333;">control模块中的<span style="background-color:#a2e043;">判题功能,我打算最后设计</span></span></li></ul> 
<h3>2.5  <span style="color:#333333;">MVC </span><span style="color:#333333;"><strong>结构的</strong></span><span style="color:#333333;">oj 服务</span><span style="color:#333333;"><strong>设计(V)</strong></span></h3> 
<h4>2.4 <span style="color:#333333;"><strong>安装与测试 </strong></span><span style="color:#333333;">ctemplate(网页渲染</span>)</h4> 
<blockquote> 
 <p>渲染本质就是<span style="color:#4da8ee;"><strong>key-value</strong></span>之间的<strong><span style="color:#956fe7;">替换</span></strong></p> 
</blockquote> 
<p><img alt="" height="256" src="https://images2.imgbox.com/e9/97/qhDIsWPe_o.png" width="662"></p> 
<ul><li>安装镜像源: git clone https://gitee.com/mirrors_OlafvdSpek/ctemplate.git </li><li> 
  <div> 
   <span style="color:#333333;">.</span> 
   <span style="color:#981a1a;">/</span> 
   <span style="color:#000000;">autogen</span> 
   <span style="color:#333333;">.</span> 
   <span style="color:#000000;">sh </span> 
  </div> </li><li> 
  <div> 
   <span style="color:#333333;">.</span> 
   <span style="color:#981a1a;">/</span> 
   <span style="color:#000000;">configure </span> 
  </div> </li><li> 
  <div> 
   <span style="color:#000000;">make </span> 
   <span style="color:#aa5500;">//</span> 
   <span style="color:#aa5500;">编译 如果报错请</span> 
   <span style="color:#fe2c24;"><strong>更新gcc</strong></span> 
  </div> </li><li> 
  <div> 
   <span style="color:#000000;">make install </span> 
  </div> </li></ul> 
<hr> 
<p><strong>test.cpp </strong></p> 
<div> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;ctemplate/template.h&gt;
int main()
{
    std::string html = "./test.html";
    std::string html_info = "测试ctemplate渲染";

    // 建立ctemplate参数目录结构
    ctemplate::TemplateDictionary root("test"); // unordered_map&lt;string,string&gt; test;
    
    // 向结构中添加你要替换的数据，kv的
    root.SetValue("info", html_info); // test.insert({key, value});
    
    // 获取被渲染对象
    // DO_NOT_STRIP：保持html网页原貌
    ctemplate::Template *tpl = ctemplate::Template::GetTemplate(html,ctemplate::DO_NOT_STRIP); 
    
    // 开始渲染，返回新的网页结果到out_html
    std::string out_html;
    tpl-&gt;Expand(&amp;out_html, &amp;root);
    
    std::cout &lt;&lt; "渲染的带参html是:" &lt;&lt; std::endl;
    std::cout &lt;&lt; out_html &lt;&lt; std::endl;
    
    return 0;
}</code></pre> 
</div> 
<p><strong> test.html</strong></p> 
<div> 
 <pre><code class="language-cpp">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;p&gt;{<!-- -->{info}}&lt;/p&gt;
    &lt;p&gt;{<!-- -->{info}}&lt;/p&gt;
    &lt;p&gt;{<!-- -->{info}}&lt;/p&gt;
    &lt;p&gt;{<!-- -->{info}}&lt;/p&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre> 
</div> 
<p><img alt="" height="348" src="https://images2.imgbox.com/33/37/o8ZuFXFG_o.png" width="618"></p> 
<hr> 
<p><span style="color:#fe2c24;"><strong> 错误原因: error while loading shared libraries: libmpc.so.3: cannot open shared object file </strong></span></p> 
<div> 
 <div> 
  <pre><code class="language-cpp">export LD\_LIBRARY\_PATH=$LD\_LIBRARY\_PATH:/usr/local/lib</code></pre> 
 </div> 
</div> 
<ul><li> 在命令行上输入 上面这段命令,<span style="background-color:#a2e043;">注:只在当前会话中有效</span></li></ul> 
<blockquote> 
 <p>#  cat /etc/ld.so.conf<br> include ld.so.conf.d/*.conf<br> #  <span style="color:#956fe7;"><strong>echo "/usr/local/lib" &gt;&gt; /etc/ld.so.conf</strong></span><br> #  ldconfig</p> 
</blockquote> 
<h4>2.5.2 渲染功能(oj_view.hpp)</h4> 
<div> 
 <pre><code class="language-cpp">#pragma once
#include &lt;iostream&gt;
#include &lt;ctemplate/template.h&gt;
#include "./oj_model.hpp"

namespace ns_view
{
    using namespace ns_model;

    const std::string template_path = "./template_html/";

    class View
    {
    public:
        View(){}
        ~View(){}

        // 渲染所有题目
        void ALLExpandHtml(const vector&lt;struct Question&gt;&amp;question,std::string *html){
            // 题目编号 题目标题 题难度
            // 推荐表格实现
            // 1.形成路径
            string src_html = template_path + "all_quetions.html";

            // 2.形成数字典
            ctemplate::TemplateDictionary root("all_question");
            for(const auto&amp; q: question){
                ctemplate::TemplateDictionary *sub = root.AddSectionDictionary("question_list");
                sub-&gt;SetValue("number",q.number);
                sub-&gt;SetValue("title",q.title);
                sub-&gt;SetValue("star",q.star);
            }

            // 3. 获取被渲染的html
            ctemplate::Template*tpl = ctemplate::Template::GetTemplate(src_html,ctemplate::DO_NOT_STRIP);

            // 4.开始完成渲染功能
            tpl-&gt;Expand(html,&amp;root);
        }

        // 渲染一道题目
        void OneExpandHtml(const struct Question &amp;q,string *html){
            // 1.形成路径
            std::string src_html = template_path + "one_question.html";

            // 2. 形成数字典
            ctemplate::TemplateDictionary root("one_question");
            root.SetValue("number",q.number);
            root.SetValue("title",q.title);
            root.SetValue("star",q.star);
            root.SetValue("desc",q.desc);
            root.SetValue("header",q.header);

            // 3.获取被渲染的html
            ctemplate::Template*tpl = ctemplate::Template::GetTemplate(src_html,ctemplate::DO_NOT_STRIP);
            // 4.开始完成渲染功能
            tpl-&gt;Expand(html,&amp;root);
        }
    };
}
</code></pre> 
</div> 
<h3>2.6  联动<span style="color:#333333;">MVC模块并测试</span></h3> 
<p><img alt="" height="599" src="https://images2.imgbox.com/2e/f7/qQ1J6rrl_o.png" width="555"></p> 
<p></p> 
<hr> 
<p><strong>oj_server.cc </strong></p> 
<div> 
 <pre><code class="language-cpp">#include &lt;iostream&gt;
#include "../comm/httplib.h"// 引入
#include "oj_control.hpp"

using namespace httplib;// 引入
using namespace ns_control;

int main()
{
    // 用户请求的服务器路由功能
    Server svr;
    Control ctrl;
    // 获取所有的题目列表
    svr.Get("/all_questions",[&amp;ctrl](const Request&amp;req,Response &amp;resp){
        // 返回一张包含所有题目的html网页
        std::string html;// 待处理
        ctrl.AllQuestions(&amp;html);
        resp.set_content(html,"text/html;charset=utf-8");
    });

    // 根据题目编号,获取题目内容
    // \d+ 是正则表达式的特殊符合
    svr.Get(R"(/question/(\d+))",[&amp;ctrl](const Request&amp;req,Response &amp;resp){
        std::string number = req.matches[1];
        std::string html;
        ctrl.Question(number,&amp;html);
        resp.set_content(html,"text/html;charset=utf-8");
    });

    // 判断用户提交的代码(1.每道题c测试用例,2.compile_and_run)
    svr.Post(R"(/judge/(\d+))",[&amp;ctrl](const Request&amp;req,Response &amp;resp){
        std::string number = req.matches[1];
        std::string result_json;
        ctrl.Judge(number,req.body,&amp;result_json);
        resp.set_content(result_json,"application/json;charset=utf-8");
    });
    svr.set_base_dir("./wwwroot");
    svr.listen("0.0.0.0",8080);
    return 0;
}

</code></pre> 
</div> 
<p><img alt="" height="271" src="https://images2.imgbox.com/76/a9/4AUBAXL6_o.png" width="630"></p> 
<ul><li> 这里的前端都是提前做好了的,我们可以不关心前端;</li><li><span style="color:#fe2c24;"><strong>control功能</strong></span>还有个<span style="background-color:#ffd900;">判题功能没有实现</span></li></ul> 
<h3> 2.7 完善oj_control.hpp中的判题功能</h3> 
<div> 
 <pre><code class="language-cpp">void Judge(const std::string &amp;number, const std::string in_json, std::string *out_json)
        {
            // LOG(DEBUG) &lt;&lt; in_json &lt;&lt; " \nnumber:" &lt;&lt; number &lt;&lt; "\n";
            
            // 0. 根据题目编号，直接拿到对应的题目细节
            struct Question q;
            model_.GetOneQuestion(number, &amp;q);

            // 1. in_json进行反序列化，得到题目的id，得到用户提交源代码，input
            Json::Reader reader;
            Json::Value in_value;
            reader.parse(in_json, in_value);
            std::string code = in_value["code"].asString();

            // 2. 重新拼接用户代码+测试用例代码，形成新的代码
            Json::Value compile_value;
            compile_value["input"] = in_value["input"].asString();
            compile_value["code"] = code + "\n" + q.tail;
            compile_value["cpu_limit"] = q.cpu_limit;
            compile_value["mem_limit"] = q.mem_limit;
            Json::FastWriter writer;
            std::string compile_string = writer.write(compile_value);

            // 3. 选择负载最低的主机(差错处理)
            // 规则: 一直选择，直到主机可用，否则，就是全部挂掉
            while(true)
            {
                int id = 0;
                Machine *m = nullptr;
                if(!load_blance_.SmartChoice(&amp;id, &amp;m))
                {
                    break;
                }

                // 4. 然后发起http请求，得到结果
                Client cli(m-&gt;ip, m-&gt;port);
                m-&gt;IncLoad();
                LOG(INFO) &lt;&lt; " 选择主机成功, 主机id: " &lt;&lt; id &lt;&lt; " 详情: " &lt;&lt; m-&gt;ip &lt;&lt; ":" &lt;&lt; m-&gt;port &lt;&lt; " 当前主机的负载是: " &lt;&lt; m-&gt;Load() &lt;&lt; "\n";
                if(auto res = cli.Post("/compile_and_run", compile_string, "application/json;charset=utf-8"))
                {
                    // 5. 将结果赋值给out_json
                    if(res-&gt;status == 200)
                    {
                        *out_json = res-&gt;body;
                        m-&gt;DecLoad();
                        LOG(INFO) &lt;&lt; "请求编译和运行服务成功..." &lt;&lt; "\n";
                        break;
                    }
                    m-&gt;DecLoad();
                }
                else
                {
                    //请求失败
                    LOG(ERROR) &lt;&lt; " 当前请求的主机id: " &lt;&lt; id &lt;&lt; " 详情: " &lt;&lt; m-&gt;ip &lt;&lt; ":" &lt;&lt; m-&gt;port &lt;&lt; " 可能已经离线"&lt;&lt; "\n";
                    load_blance_.OfflineMachine(id);
                    load_blance_.ShowMachines(); //仅仅是为了用来调试
                }
            }</code></pre> 
</div> 
<h3>2.8 测试oj_server服务</h3> 
<p><img alt="" height="164" src="https://images2.imgbox.com/11/4d/ejgiP9f8_o.png" width="662"></p> 
<p><img alt="" height="288" src="https://images2.imgbox.com/de/c0/NSztF948_o.png" width="537"></p> 
<ul><li>在编译时需要加上-D COMPILER_ONLINE条件编译, </li></ul> 
<p><img alt="" height="473" src="https://images2.imgbox.com/93/6e/HZC4dd4T_o.png" width="673"></p> 
<ul><li> 设计到<span style="color:#fe2c24;"><strong>前端网页</strong></span>,下面会有提及</li></ul> 
<h3>2.9 一个BUG </h3> 
<p><img alt="" height="249" src="https://images2.imgbox.com/1a/73/4lZGvIyN_o.png" width="637"></p> 
<ul><li> 把tail.txt改成tail.cpp,不然后面无法进行<span style="color:#fe2c24;"><strong>代码拼接</strong></span></li></ul> 
<h2> 3. 前端页面设计(了解)</h2> 
<h3>3.1 index.html</h3> 
<div> 
 <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;这是我的个人OJ系统&lt;/title&gt;
    &lt;style&gt;
        /* 起手式, 100%保证我们的样式设置可以不受默认影响 */
        * {
            /* 消除网页的默认外边距 */
            margin: 0px;
            /* 消除网页的默认内边距 */
            padding: 0px;
        }

        html,
        body {
            width: 100%;
            height: 100%;
        }

        .container .navbar {
            width: 100%;
            height: 50px;
            background-color: black;
            /* 给父级标签设置overflow，取消后续float带来的影响 */
            overflow: hidden;
        }

        .container .navbar a {
            /* 设置a标签是行内块元素，允许你设置宽度 */
            display: inline-block;
            /* 设置a标签的宽度,a标签默认行内元素，无法设置宽度 */
            width: 80px;
            /* 设置字体颜色 */
            color: white;
            /* 设置字体的大小 */
            font-size: large;
            /* 设置文字的高度和导航栏一样的高度 */
            line-height: 50px;
            /* 去掉a标签的下划线 */
            text-decoration: none;
            /* 设置a标签中的文字居中 */
            text-align: center;
        }
        /* 设置鼠标事件 */
        .container .navbar a:hover {
            background-color: green;
        }
        .container .navbar .login {
            float: right;
        }

        .container .content {
            /* 设置标签的宽度 */
            width: 800px;
            /* 用来调试 */
            /* background-color: #ccc; */
            /* 整体居中 */
            margin: 0px auto;
            /* 设置文字居中 */
            text-align: center;
            /* 设置上外边距 */
            margin-top: 200px;
        }

        .container .content .font_ {
            /* 设置标签为块级元素，独占一行，可以设置高度宽度等属性 */
            display: block;
            /* 设置每个文字的上外边距 */
            margin-top: 20px;
            /* 去掉a标签的下划线 */
            text-decoration: none;
            /* 设置字体大小
            font-size: larger; */
        }
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;!-- 导航栏， 功能不实现--&gt;
        &lt;div class="navbar"&gt;
            &lt;a href="/"&gt;首页&lt;/a&gt;
            &lt;a href="/all_questions"&gt;题库&lt;/a&gt;
            &lt;a href="#"&gt;竞赛&lt;/a&gt;
            &lt;a href="#"&gt;讨论&lt;/a&gt;
            &lt;a href="#"&gt;求职&lt;/a&gt;
            &lt;a class="login" href="#"&gt;登录&lt;/a&gt;
        &lt;/div&gt;
        &lt;!-- 网页的内容 --&gt;
        &lt;div class="content"&gt;
            &lt;h1 class="font_"&gt;欢迎来到我的OnlineJudge平台&lt;/h1&gt;
            &lt;p class="font_"&gt;这个我个人独立开发的一个在线OJ平台&lt;/p&gt;
            &lt;a class="font_" href="/all_questions"&gt;点击我开始编程啦!&lt;/a&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre> 
</div> 
<h3> 3.2 all_questions.html</h3> 
<div> 
 <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;在线OJ-题目列表&lt;/title&gt;
    &lt;style&gt;
        /* 起手式, 100%保证我们的样式设置可以不受默认影响 */
        * {
            /* 消除网页的默认外边距 */
            margin: 0px;
            /* 消除网页的默认内边距 */
            padding: 0px;
        }

        html,
        body {
            width: 100%;
            height: 100%;
        }

        .container .navbar {
            width: 100%;
            height: 50px;
            background-color: black;
            /* 给父级标签设置overflow，取消后续float带来的影响 */
            overflow: hidden;
        }

        .container .navbar a {
            /* 设置a标签是行内块元素，允许你设置宽度 */
            display: inline-block;
            /* 设置a标签的宽度,a标签默认行内元素，无法设置宽度 */
            width: 80px;
            /* 设置字体颜色 */
            color: white;
            /* 设置字体的大小 */
            font-size: large;
            /* 设置文字的高度和导航栏一样的高度 */
            line-height: 50px;
            /* 去掉a标签的下划线 */
            text-decoration: none;
            /* 设置a标签中的文字居中 */
            text-align: center;
        }

        /* 设置鼠标事件 */
        .container .navbar a:hover {
            background-color: green;
        }

        .container .navbar .login {
            float: right;
        }

        .container .question_list {
            padding-top: 50px;
            width: 800px;
            height: 100%;
            margin: 0px auto;
            /* background-color: #ccc; */
            text-align: center;
        }

        .container .question_list table {
            width: 100%;
            font-size: large;
            font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;
            margin-top: 50px;
            background-color: rgb(243, 248, 246);
        }

        .container .question_list h1 {
            color: green;
        }

        .container .question_list table .item {
            width: 100px;
            height: 40px;
            font-size: large;
            font-family: 'Times New Roman', Times, serif;
        }

        .container .question_list table .item a {
            text-decoration: none;
            color: black;
        }

        .container .question_list table .item a:hover {
            color: blue;
            text-decoration: underline;
        }

        .container .footer {
            width: 100%;
            height: 50px;
            text-align: center;
            line-height: 50px;
            color: #ccc;
            margin-top: 15px;
        }
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;!-- 导航栏， 功能不实现--&gt;
        &lt;div class="navbar"&gt;
            &lt;a href="/"&gt;首页&lt;/a&gt;
            &lt;a href="/all_questions"&gt;题库&lt;/a&gt;
            &lt;a href="#"&gt;竞赛&lt;/a&gt;
            &lt;a href="#"&gt;讨论&lt;/a&gt;
            &lt;a href="#"&gt;求职&lt;/a&gt;
            &lt;a class="login" href="#"&gt;登录&lt;/a&gt;
        &lt;/div&gt;
        &lt;div class="question_list"&gt;
            &lt;h1&gt;OnlineJuge题目列表&lt;/h1&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;th class="item"&gt;编号&lt;/th&gt;
                    &lt;th class="item"&gt;标题&lt;/th&gt;
                    &lt;th class="item"&gt;难度&lt;/th&gt;
                &lt;/tr&gt;
                {<!-- -->{#question_list}}
                &lt;tr&gt;
                    &lt;td class="item"&gt;{<!-- -->{number}}&lt;/td&gt;
                    &lt;td class="item"&gt;&lt;a href="/question/{<!-- -->{number}}"&gt;{<!-- -->{title}}&lt;/a&gt;&lt;/td&gt;
                    &lt;td class="item"&gt;{<!-- -->{star}}&lt;/td&gt;
                &lt;/tr&gt;
                {<!-- -->{/question_list}}
            &lt;/table&gt;
        &lt;/div&gt;
        &lt;div class="footer"&gt;
            &lt;!-- &lt;hr&gt; --&gt;
            &lt;h4&gt;@lyc&lt;/h4&gt;
        &lt;/div&gt;
    &lt;/div&gt;

&lt;/body&gt;

&lt;/html&gt;</code></pre> 
</div> 
<h3>3.3 one_questions.html(ACE插件&amp;&amp;<span style="color:#0d0016;"><strong>JQuery&amp;&amp;ajax</strong></span>)</h3> 
<div> 
 <pre><code class="language-cpp">&lt;!-- 引入ACE插件 --&gt;
    &lt;!-- 引入ACE CDN --&gt;
    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.6/ace.js" type="text/javascript"
        charset="utf-8"&gt;&lt;/script&gt;
    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.6/ext-language_tools.js" type="text/javascript"
        charset="utf-8"&gt;&lt;/script&gt;
    &lt;!-- 引入jquery CDN --&gt;
    &lt;script src="http://code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt;</code></pre> 
</div> 
<p><img alt="" height="96" src="https://images2.imgbox.com/f6/5e/gELGS31p_o.png" width="568"></p> 
<p><img alt="" height="529" src="https://images2.imgbox.com/48/32/kXDN9s6Q_o.png" width="638"></p> 
<ul><li> 
  <div> 
   <span style="color:#956fe7;"><strong>ACE插件</strong></span>是一个 
   <span style="background-color:#ffd900;">编写代码的编译框</span> 
  </div> </li><li> 
  <div> 
   <span style="color:#333333;">收集当前页面的有关数据</span> 
   <span style="color:#333333;">, a. </span> 
   <span style="color:#333333;">题号 </span> 
   <span style="color:#333333;">a.</span> 
   <span style="color:#333333;">代码</span> 
   <span style="color:#333333;">,</span> 
   <span style="color:#333333;">我们采用</span> 
   <span style="color:#956fe7;"><strong>JQuery</strong></span> 
   <span style="color:#333333;">来进行<span style="background-color:#ffd900;">获取</span></span> 
   <span style="color:#333333;"><span style="background-color:#ffd900;">html</span></span> 
   <span style="color:#333333;"><span style="background-color:#ffd900;">中的内容</span></span> 
  </div> </li><li> 
  <div>
    构建json,并通过 
   <span style="color:#956fe7;"><strong>ajax</strong></span>向后台 
   <span style="background-color:#ffd900;">发起基于http的json请求</span> 
  </div> </li></ul> 
<hr> 
<p><strong>全部代码</strong></p> 
<div> 
 <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;{<!-- -->{number}}.{<!-- -->{title}}&lt;/title&gt;
    &lt;!-- 引入ACE插件 --&gt;
    &lt;!-- 引入ACE CDN --&gt;
    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.6/ace.js" type="text/javascript"
        charset="utf-8"&gt;&lt;/script&gt;
    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.6/ext-language_tools.js" type="text/javascript"
        charset="utf-8"&gt;&lt;/script&gt;
    &lt;!-- 引入jquery CDN --&gt;
    &lt;script src="http://code.jquery.com/jquery-2.1.1.min.js"&gt;&lt;/script&gt;

    &lt;style&gt;
        * {
            margin: 0;
            padding: 0;
        }

        html,
        body {
            width: 100%;
            height: 100%;
        }

        .container .navbar {
            width: 100%;
            height: 50px;
            background-color: black;
            /* 给父级标签设置overflow，取消后续float带来的影响 */
            overflow: hidden;
        }

        .container .navbar a {
            /* 设置a标签是行内块元素，允许你设置宽度 */
            display: inline-block;
            /* 设置a标签的宽度,a标签默认行内元素，无法设置宽度 */
            width: 80px;
            /* 设置字体颜色 */
            color: white;
            /* 设置字体的大小 */
            font-size: large;
            /* 设置文字的高度和导航栏一样的高度 */
            line-height: 50px;
            /* 去掉a标签的下划线 */
            text-decoration: none;
            /* 设置a标签中的文字居中 */
            text-align: center;
        }

        /* 设置鼠标事件 */
        .container .navbar a:hover {
            background-color: green;
        }

        .container .navbar .login {
            float: right;
        }
        
        .container .part1 {
            width: 100%;
            height: 600px;
            overflow: hidden;
        }

        .container .part1 .left_desc {
            width: 50%;
            height: 600px;
            float: left;
            overflow: scroll;
        }

        .container .part1 .left_desc h3 {
            padding-top: 10px;
            padding-left: 10px;
        }

        .container .part1 .left_desc pre {
            padding-top: 10px;
            padding-left: 10px;
            font-size: medium;
            font-family:'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
        }

        .container .part1 .right_code {
            width: 50%;
            float: right;
        }

        .container .part1 .right_code .ace_editor {
            height: 600px;
        }
        .container .part2 {
            width: 100%;
            overflow: hidden;
        }

        .container .part2 .result {
            width: 300px;
            float: left;
        }

        .container .part2 .btn-submit {
            width: 120px;
            height: 50px;
            font-size: large;
            float: right;
            background-color: #26bb9c;
            color: #FFF;
            /* 给按钮带上圆角 */
            /* border-radius: 1ch; */
            border: 0px;
            margin-top: 10px;
            margin-right: 10px;
        }
        .container .part2 button:hover {
            color:green;
        }

        .container .part2 .result {
            margin-top: 15px;
            margin-left: 15px;
        }

        .container .part2 .result pre {
            font-size: large;
        }
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;!-- 导航栏， 功能不实现--&gt;
        &lt;div class="navbar"&gt;
            &lt;a href="/"&gt;首页&lt;/a&gt;
            &lt;a href="/all_questions"&gt;题库&lt;/a&gt;
            &lt;a href="#"&gt;竞赛&lt;/a&gt;
            &lt;a href="#"&gt;讨论&lt;/a&gt;
            &lt;a href="#"&gt;求职&lt;/a&gt;
            &lt;a class="login" href="#"&gt;登录&lt;/a&gt;
        &lt;/div&gt;
        &lt;!-- 左右呈现，题目描述和预设代码 --&gt;
        &lt;div class="part1"&gt;
            &lt;div class="left_desc"&gt;
                &lt;h3&gt;&lt;span id="number"&gt;{<!-- -->{number}}&lt;/span&gt;.{<!-- -->{title}}_{<!-- -->{star}}&lt;/h3&gt;
                &lt;pre&gt;{<!-- -->{desc}}&lt;/pre&gt;
            &lt;/div&gt;
            &lt;div class="right_code"&gt;
                &lt;pre id="code" class="ace_editor"&gt;&lt;textarea class="ace_text-input"&gt;{<!-- -->{pre_code}}&lt;/textarea&gt;&lt;/pre&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;!-- 提交并且得到结果，并显示 --&gt;
        &lt;div class="part2"&gt;
            &lt;div class="result"&gt;&lt;/div&gt;
            &lt;button class="btn-submit" onclick="submit()"&gt;提交代码&lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;script&gt;
        //初始化对象
        editor = ace.edit("code");

        //设置风格和语言（更多风格和语言，请到github上相应目录查看）
        // 主题大全：http://www.manongjc.com/detail/25-cfpdrwkkivkikmk.html
        editor.setTheme("ace/theme/monokai");
        editor.session.setMode("ace/mode/c_cpp");

        // 字体大小
        editor.setFontSize(16);
        // 设置默认制表符的大小:
        editor.getSession().setTabSize(4);

        // 设置只读（true时只读，用于展示代码）
        editor.setReadOnly(false);

        // 启用提示菜单
        ace.require("ace/ext/language_tools");
        editor.setOptions({
            enableBasicAutocompletion: true,
            enableSnippets: true,
            enableLiveAutocompletion: true
        });

        function submit(){
            // alert("嘿嘿!");
            // 1. 收集当前页面的有关数据, 1. 题号 2.代码
            var code = editor.getSession().getValue();
            // console.log(code);
            var number = $(".container .part1 .left_desc h3 #number").text();
            // console.log(number);
            var judge_url = "/judge/" + number;
            // console.log(judge_url);
            // 2. 构建json，并通过ajax向后台发起基于http的json请求
            $.ajax({
                method: 'Post',   // 向后端发起请求的方式
                url: judge_url,   // 向后端指定的url发起请求
                dataType: 'json', // 告知server，我需要什么格式
                contentType: 'application/json;charset=utf-8',  // 告知server，我给你的是什么格式
                data: JSON.stringify({
                    'code':code,
                    'input': ''
                }),
                success: function(data){
                    //成功得到结果
                    // console.log(data);
                    show_result(data);
                }
            });
            // 3. 得到结果，解析并显示到 result中
            function show_result(data)
            {
                // console.log(data.status);
                // console.log(data.reason);
                // 拿到result结果标签
                var result_div = $(".container .part2 .result");
                // 清空上一次的运行结果
                result_div.empty();

                // 首先拿到结果的状态码和原因结果
                var _status = data.status;
                var _reason = data.reason;

                var reason_lable = $( "&lt;p&gt;",{
                       text: _reason
                });
                reason_lable.appendTo(result_div);

                if(status == 0){
                    // 请求是成功的，编译运行过程没出问题，但是结果是否通过看测试用例的结果
                    var _stdout = data.stdout;
                    var _stderr = data.stderr;

                    var stdout_lable = $("&lt;pre&gt;", {
                        text: _stdout
                    });

                    var stderr_lable = $("&lt;pre&gt;", {
                        text: _stderr
                    })

                    stdout_lable.appendTo(result_div);
                    stderr_lable.appendTo(result_div);
                }
                else{
                    // 编译运行出错,do nothing
                }
            }
        }
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre> 
</div> 
<h3>3.4 相关测试</h3> 
<p><img alt="" height="538" src="https://images2.imgbox.com/5c/4b/9XrhSW62_o.png" width="674"></p> 
<hr> 
<h2> 4. MySQL版题目设计</h2> 
<h3>4.1 注册用户 &amp;&amp; 赋予权限</h3> 
<p><img alt="" height="293" src="https://images2.imgbox.com/4b/64/c2vxJFYS_o.png" width="417"></p> 
<p><img alt="" height="383" src="https://images2.imgbox.com/ea/6e/B1qRXIES_o.png" width="577"></p> 
<ul><li>create user 'oj_client'@'localhost' identified by '123456';</li><li>create database oj;</li><li>grant select on oj.* to 'oj_client'@'localhost';</li><li>select user,Host from user;</li></ul> 
<hr> 
<p><img alt="" height="294" src="https://images2.imgbox.com/b7/df/5dxlYeRb_o.png" width="572"></p> 
<h3> 4.2 下载第三方工具-workbench</h3> 
<p><img alt="" height="181" src="https://images2.imgbox.com/3c/12/csjrvUth_o.png" width="671"></p> 
<p><img alt="" height="793" src="https://images2.imgbox.com/b3/4c/unwZw6co_o.png" width="660"></p> 
<p><img alt="" height="474" src="https://images2.imgbox.com/73/8d/L6DtMQTq_o.png" width="568"></p> 
<p> <img alt="" height="419" src="https://images2.imgbox.com/92/18/iroMqGUQ_o.png" width="595"></p> 
<ul><li> 下载下来之后,就不断的<span style="background-color:#a2e043;">下一步,下一步</span>就行了</li></ul> 
<h3>4.3 录题到mysql中</h3> 
<p><img alt="" height="449" src="https://images2.imgbox.com/40/30/nJXjitwC_o.png" width="618"></p> 
<h3><img alt="" height="419" src="https://images2.imgbox.com/de/49/GxHVOvFz_o.png" width="627"></h3> 
<div> 
 <pre><code class="language-cpp">use oj;
drop table if exists oj_table;

create table if not exists oj_table(
	_number varchar(200)  comment '题目编号',
    _titie varchar(200) comment '题目标题',
    _start varchar(200) comment '题目简单中等困难',
    _desc varchar(2000) comment '题目描述',
    _header varchar(2000) comment '题目预设',
    _tail varchar(2000) comment '题目测试用例',
    _cpu_limit int comment '时间要求',
    _mem_limt int comment '空间要求'
);

insert into oj_table values(
	1,
    '判断回文数',
    '简单',
    '判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

	示例 1:

	输入: 121
	输出: true
	示例 2:

	输入: -121
	输出: false
	解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
	示例 3:

	输入: 10
	输出: false
	解释: 从右向左读, 为 01 。因此它不是一个回文数。
	进阶:

	你能不将整数转为字符串来解决这个问题吗？',
    '#include &lt;iostream&gt;
	#include &lt;string&gt;
	#include &lt;vector&gt;
	#include &lt;map&gt;
	#include &lt;algorithm&gt;

	using namespace std;

	class Solution{
		public:
			bool isPalindrome(int x)
			{
				//将你的代码写在下面
				
				return true;
			}
	};',
    '#ifndef COMPILER_ONLINE
	#include "header.cpp"
	#endif


	void Test1()
	{
		// 通过定义临时对象，来完成方法的调用
		bool ret = Solution().isPalindrome(121);
		if(ret){
			std::cout &lt;&lt; "通过用例1, 测试121通过 ... OK!" &lt;&lt; std::endl;
		}
		else{
			std::cout &lt;&lt; "没有通过用例1, 测试的值是: 121"  &lt;&lt; std::endl;
		}
	}

	void Test2()
	{
		// 通过定义临时对象，来完成方法的调用
		bool ret = Solution().isPalindrome(-10);
		if(!ret){
			std::cout &lt;&lt; "通过用例2, 测试-10通过 ... OK!" &lt;&lt; std::endl;
		}
		else{
			std::cout &lt;&lt; "没有通过用例2, 测试的值是: -10"  &lt;&lt; std::endl;
		}
	}

	int main()
	{
		Test1();
		Test2();

		return 0;
	}',
    1,
    30000
);


select * from oj_table;</code></pre> 
</div> 
<p> <img alt="" height="426" src="https://images2.imgbox.com/88/29/1c6sQSRH_o.png" width="637"></p> 
<ul><li> 这里我只录入了一道题为了<span style="color:#fe2c24;"><strong>测试</strong></span></li></ul> 
<h3>4.4 下载并引入mysql库文件</h3> 
<p><a href="https://dev.mysql.com/downloads/mysql/" rel="nofollow" title="MySQL :: Download MySQL Community Server">MySQL :: Download MySQL Community Server</a></p> 
<blockquote> 
 <p>要使用C/C++连接MySQL，需要使用MySQL官网提供的库</p> 
</blockquote> 
<p> <img alt="" height="477" src="https://images2.imgbox.com/03/06/1KQfOZyd_o.png" width="642">​</p> 
<p> 下载完毕后需要将其上传到云服务器，这里将下载的库文件存放在下面的目录：</p> 
<p><img alt="" height="83" src="https://images2.imgbox.com/c1/ba/I6MbqZWD_o.png" width="654">​</p> 
<p>然后使用tar命令将压缩包解压到当前目录下： </p> 
<p>xz -d mysql-8.0.37-linux-glibc2.28-i686.tar.xz</p> 
<p>tar xvf mysql-8.0.37-linux-glibc2.28-i686.tar</p> 
<p><img alt="" height="78" src="https://images2.imgbox.com/82/87/bIwNXynB_o.png" width="669">​</p> 
<p>进入解压后的目录当中，可以看到有一个include子目录和一个lib子目录，其中，include目录下存放的一堆头文件。而lib64目录下存放的就是动静态库。 </p> 
<p><img alt="" height="532" src="https://images2.imgbox.com/85/b1/avF82Wdj_o.png" width="661">​ </p> 
<hr> 
<p> 然后在我们的项目中<span style="color:#fe2c24;"><strong>建立软连接</strong></span></p> 
<p><img alt="" height="249" src="https://images2.imgbox.com/75/5f/NsqpPkgI_o.png" width="675">​</p> 
<h3>4.5 一个BUG</h3> 
<ul><li> <p>如果你当时下载myql把<span style="color:#4da8ee;"><strong>mysql-devel</strong></span>也下载了,不需要进行上面步骤</p> </li><li> <p>这种引入第三方库的操作,可能会因为版本不兼容,而导致出错<br><strong><span style="color:#fe2c24;">skipping incompatible ./lib/libmysqlclient.so when searching for -lmysqlclient</span></strong></p> </li><li> 建议直接安装:<span style="color:#956fe7;"> <strong>yum -y install mysql-devel</strong></span></li></ul> 
<h3> 4.5 重新设计oj_model</h3> 
<blockquote> 
 <p>因为<span style="background-color:#a2e043;">oj_model模块是管理数据,提供接口的模块</span>,所以要把这个项目变成mysql就需要重新设计</p> 
</blockquote> 
<div> 
 <pre><code class="language-cpp">#pragma once
// 文件版本
#include "../comm/util.hpp"
#include "../comm/log.hpp"
#include &lt;unordered_map&gt;
#include &lt;cassert&gt;
#include &lt;vector&gt;

#include "./include/mysql.h"

namespace ns_model
{
    using namespace std;
    using namespace ns_log;
    using namespace ns_util;

    struct Question{
        string number;// 题目编号,唯一
        string title;// 题目标题
        string star;// 难度: 简单 中等 困难
        
        int cpu_limit;// 题目的时间复杂度(S)
        int mem_limit;// 题目的空间复杂度(KB)
        
        string desc;// 题目描述
        string header; // 题目预设给用户在线编辑器的代码
        string tail;// 题目测试用例,需要和header拼接
    };    

    const std::string oj_questions = "oj_table";
    const std::string host = "127.0.0.1";
    const std::string user = "oj_client";
    const std::string passwd = "123456";
    const std::string db = "oj";
    const int port = 3306;

    class Model
    {
    public:
        Model(){
        }
        ~Model(){
            ;
        }
        bool QueryMysql(const std::string &amp;sql,vector&lt;Question&gt;*out){
            // 这里的out是输出型参数
            // 创建mysql句柄
            MYSQL *my = mysql_init(nullptr);
            // 连接数据库
            if(nullptr == mysql_real_connect(my,host.c_str(),user.c_str(),passwd.c_str(),db.c_str(),port,nullptr,0)){
                LOG(FATAL) &lt;&lt; "连接数据库失败!" &lt;&lt; "\n";
                return false;
            }

            // 一定要设置该链接的编码格式,要不然会出现乱码的问题
            mysql_set_character_set(my,"utf8");
            LOG(INFO) &lt;&lt; "连接数据库成功!" &lt;&lt; "\n";

            // 执行sql语句
            if(0 != mysql_query(my,sql.c_str())){
                LOG(WARNING) &lt;&lt; sql &lt;&lt; " execute error! " &lt;&lt; "\n";
                return false;
            }

            // 提取结果
            MYSQL_RES *res = mysql_store_result(my);// 本质就是一个2级指针

            // 分析结果
            int rows = mysql_num_rows(res);// 获取行的数量
            int cols = mysql_num_fields(res);// 获取列的数量

            Question q;
            for(int i = 0;i &lt; rows;i++){
                MYSQL_ROW row = mysql_fetch_row(res);
                q.number = row[0];
                q.title = row[1];
                q.star = row[2];
                q.desc = row[3];
                q.header = row[4];
                q.tail = row[5];
                q.cpu_limit = atoi(row[6]);
                q.mem_limit = atoi(row[7]);
                out-&gt;push_back(q);
            }

            // 释放控件
            free(res);
            // 关闭mysql连接
            mysql_close(my);

            return true;
        }
        // 获取所有题目,这里的out是输出型参数
        bool GetAllQuestions(vector&lt;Question&gt;*out){
            std::string sql = "select * from ";
            sql += oj_questions;
            return QueryMysql(sql,out);
        }

        // 获取指定题目,这里的q是输出型参数
        bool GetOneQuestion(const string&amp; number,Question* q){
           bool res = false;
           std::string sql = "select * from ";
           sql += oj_questions;
           sql += " where number=";
           sql += number;

           vector&lt;Question&gt; result;
           if(QueryMysql(sql,&amp;result)){
                if(result.size() == 1){
                    *q = result[0];
                    res = true;
                }
           }

           return res;
        }

        
    private:
        // 题号 : 题目细节
        unordered_map&lt;string,Question&gt; questions;
    };
} 

</code></pre> 
</div> 
<ul><li><span style="color:#4da8ee;"><strong>mysql_init</strong></span>: 创建mysql句柄</li><li><span style="color:#4da8ee;"><strong>mysql_real_connect</strong></span>: 创建mysql连接</li><li> <p><span style="color:#4da8ee;"><strong>mysql_query</strong></span>: 发起mysql请求</p> </li><li> <p><span style="color:#4da8ee;"><strong>mysql_close</strong></span>: 关闭mysql连接</p> </li></ul> 
<h3> 4.6 相关测试</h3> 
<p><img alt="" height="149" src="https://images2.imgbox.com/c6/51/0ERh0lhc_o.png" width="668">​</p> 
<ul><li>编译期间告诉编译器头文件和库文件在哪里 <span style="background-color:#a2e043;">-I指明搜索的头文件,-L指明搜索的lib</span></li><li>并加上<span style="color:#4da8ee;"><strong>-lmysqlclient</strong></span></li></ul> 
<p><img alt="" height="499" src="https://images2.imgbox.com/2e/4c/fnlaTDqf_o.png" width="579">​ </p> 
<p><img alt="" height="559" src="https://images2.imgbox.com/63/33/5SKoXuFD_o.png" width="562">​ </p> 
<p><img alt="" height="588" src="https://images2.imgbox.com/6e/f0/1ARwlcAo_o.png" width="658">​</p> 
<h2>5. 扩展</h2> 
<ul><li> 
  <div> 
   <span style="color:#333333;">功能上更完善一下，判断一道题目正确之后，自动下一道题目 </span> 
  </div> </li><li> 
  <div> 
   <div> 
    <span style="color:#333333;">基于注册和登陆的录题功能</span> 
   </div> 
   <div> 
    <span style="color:#333333;">.....</span> 
   </div> 
  </div> </li></ul> 
<h2>6. 完整项目链接 </h2> 
<blockquote> 
 <p><a href="https://github.com/1LYC/projects/tree/main/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/OnlineJudge" title="projects/负载均衡/OnlineJudge at main · 1LYC/projects · GitHub">projects/负载均衡/OnlineJudge at main · 1LYC/projects · GitHub</a></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6392bdd5de03406f24f7324c8c133ca1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">哈喽GPT-4o——对GPT-4o 提示词的思考与看法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bca91c98c692ee06b32baaccbcd64e43/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">大数据开发流程解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>