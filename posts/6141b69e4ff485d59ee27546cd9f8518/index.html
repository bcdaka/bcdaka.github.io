<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>力扣每日一题 6/16 字符串 &#43; 随机一题 动态规划/数学 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/6141b69e4ff485d59ee27546cd9f8518/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="力扣每日一题 6/16 字符串 &#43; 随机一题 动态规划/数学">
  <meta property="og:description" content="博客主页：誓则盟约系列专栏：IT竞赛 专栏关注博主，后期持续更新系列文章如果有错误感谢请大家批评指出，及时修改感谢大家点赞👍收藏⭐评论✍ 521.最长特殊序列 I【简单】 题目： 给你两个字符串 a 和 b，请返回 这两个字符串中 最长的特殊序列 的长度。如果不存在，则返回 -1 。
「最长特殊序列」 定义如下：该序列为 某字符串独有的最长
子序列
（即不能是其他字符串的子序列） 。
字符串 s 的子序列是在从 s 中删除任意数量的字符后可以获得的字符串。
例如，&#34;abc&#34; 是 &#34;aebdc&#34; 的子序列，因为删除 &#34;aebdc&#34; 中斜体加粗的字符可以得到 &#34;abc&#34; 。 &#34;aebdc&#34; 的子序列还包括 &#34;aebdc&#34; 、 &#34;aeb&#34; 和 &#34;&#34; (空字符串)。 示例 1：
输入: a = &#34;aba&#34;, b = &#34;cdc&#34; 输出: 3 解释: 最长特殊序列可为 &#34;aba&#34; (或 &#34;cdc&#34;)，两者均为自身的子序列且不是对方的子序列。 示例 2：
输入：a = &#34;aaa&#34;, b = &#34;bbb&#34; 输出：3 解释: 最长特殊序列是 &#34;aaa&#34; 和 &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-16T19:02:04+08:00">
    <meta property="article:modified_time" content="2024-06-16T19:02:04+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">力扣每日一题 6/16 字符串 &#43; 随机一题 动态规划/数学</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <ul><li><strong>博客主页：<a href="https://blog.csdn.net/Xxy_1008?type=blog" title="誓则盟约">誓则盟约</a></strong></li><li><strong>系列专栏：<a href="https://blog.csdn.net/xxy_1008/category_12662512.html?spm=1001.2014.3001.5482" title="IT竞赛 专栏">IT竞赛 专栏</a></strong></li><li><strong>关注博主，后期持续更新系列文章</strong></li><li><strong>如果有错误感谢请大家批评指出，及时修改</strong></li><li><strong>感谢大家点赞👍收藏⭐评论✍</strong> </li></ul> 
<hr> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ae/dd/Yxlocc23_o.gif"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9a/2b/8G0wPzPo_o.gif"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e1/ca/jdOHyqnv_o.gif"></p> 
<p></p> 
<p></p> 
<h2>521.最长特殊序列 I【<span style="color:#a2e043;">简单</span>】</h2> 
<h4><span style="color:#a2e043;">题目：</span></h4> 
<p>给你两个字符串 <code>a</code> 和 <code>b</code>，请返回 <em>这两个字符串中 <strong>最长的特殊序列</strong> </em> 的长度。如果不存在，则返回 <code>-1</code> 。</p> 
<p><strong>「最长特殊序列」</strong> 定义如下：该序列为 <strong>某字符串独有的最长</strong></p> 
<p><strong>子序列</strong></p> 
<p><strong>（即不能是其他字符串的子序列）</strong> 。</p> 
<p>字符串 <code>s</code> 的子序列是在从 <code>s</code> 中删除任意数量的字符后可以获得的字符串。</p> 
<ul><li>例如，<code>"abc"</code> 是 <code>"aebdc"</code> 的子序列，因为删除 <code>"a<em><strong>e</strong></em>b<strong><em>d</em></strong>c"</code> 中斜体加粗的字符可以得到 <code>"abc"</code> 。 <code>"aebdc"</code> 的子序列还包括 <code>"aebdc"</code> 、 <code>"aeb"</code> 和 <code>""</code> (空字符串)。</li></ul> 
<p></p> 
<p><strong>示例 1：</strong></p> 
<pre><strong>输入:</strong> a = "aba", b = "cdc"
<strong>输出:</strong> 3
<strong>解释:</strong> 最长特殊序列可为 "aba" (或 "cdc")，两者均为自身的子序列且不是对方的子序列。</pre> 
<p><strong>示例 2：</strong></p> 
<pre><strong>输入：</strong>a = "aaa", b = "bbb"
<strong>输出：</strong>3
<strong>解释:</strong> 最长特殊序列是 "aaa" 和 "bbb" 。
</pre> 
<p><strong>示例 3：</strong></p> 
<pre><strong>输入：</strong>a = "aaa", b = "aaa"
<strong>输出：</strong>-1
<strong>解释:</strong> 字符串 a 的每个子序列也是字符串 b 的每个子序列。同样，字符串 b 的每个子序列也是字符串 a 的子序列。
</pre> 
<p></p> 
<p><strong>提示：</strong></p> 
<ul><li><code>1 &lt;= a.length, b.length &lt;= 100</code></li><li><code>a</code> 和 <code>b</code> 由小写英文字母组成</li></ul> 
<p></p> 
<h4><span style="color:#a2e043;">分析问题：</span></h4> 
<p>        这道题很有意思哈，没有自己的主见真的会被题目给带偏，很容易去想如何切割或者如何比较能得到最大长度，但是其实这些都不需要，<strong>只需要对比 a是否等于b</strong> 即可。</p> 
<p>        如果a不等于b的话，直接可以返回a,b的最大长度，可以这样想：如果a!=b， 那取a的全部或者b的全部肯定都不可能是另一方的子序列。</p> 
<p>        如果 a等于b ，那可以直接返回 -1。</p> 
<h4><span style="color:#a2e043;">代码实现：</span></h4> 
<pre><code class="language-python">class Solution:
    def findLUSlength(self, a: str, b: str) -&gt; int:
        return max(len(a), len(b)) if a != b else -1</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e7/04/FDsNqXDP_o.png"></p> 
<hr> 
<h4> <span style="color:#a2e043;">总结：</span></h4> 
<p>        其实这道题就像是一个脑筋急转弯哈，没啥可讲的，就看能不能转过来这个圈了。</p> 
<hr> 
<p> <img alt="" src="https://images2.imgbox.com/2b/c3/5Wn5V1Zq_o.jpg"></p> 
<h2>随机一题：343.整数拆分【<span style="color:#ffd900;">中等</span>】</h2> 
<h4><span style="color:#a2e043;">题目：</span></h4> 
<p>给定一个正整数 <code>n</code> ，将其拆分为 <code>k</code> 个 <strong>正整数</strong> 的和（ <code>k &gt;= 2</code> ），并使这些整数的乘积最大化。</p> 
<p>返回 <em>你可以获得的最大乘积</em> 。</p> 
<p></p> 
<p><strong>示例 1:</strong></p> 
<pre><strong>输入: </strong>n = 2
<strong>输出: </strong>1
<strong>解释: </strong>2 = 1 + 1, 1 × 1 = 1。</pre> 
<p><strong>示例 2:</strong></p> 
<pre><strong>输入: </strong>n = 10
<strong>输出: </strong>36
<strong>解释: </strong>10 = 3 + 3 + 4, 3 × 3 × 4 = 36。</pre> 
<p></p> 
<p><strong>提示:</strong></p> 
<ul><li><code>2 &lt;= n &lt;= 58</code></li></ul> 
<hr> 
<h4 style="background-color:transparent;"><span style="color:#a2e043;"> 题目分析：</span></h4> 
<p>        这道题其实就是在考数学和动态规划了，但是其实我认为这道题数学是一种做法，动态规划是另一种做法，他们两个并不是一体的。所以这道题我提供了两种解法思路。</p> 
<h4><strong><span style="color:#956fe7;">动态规划：</span></strong></h4> 
<p></p> 
<ul><li><strong>首先定义一个内部函数 <code>integer_break</code> 来处理具体的计算逻辑。</strong></li><li><strong>对于小于等于 3 的整数 <code>n</code>，直接返回 <code>n - 1</code>，因为对于 <code>n = 2</code>，拆分为 <code>1 + 1</code>，乘积为 1，而直接返回 1 ；对于 <code>n = 3</code>，拆分为 <code>1 + 2</code>，乘积为 2，而直接返回 2 。</strong></li><li><strong>然后创建一个长度为 <code>n + 1</code> 的 <code>dp</code> 数组，用于保存中间计算的结果。</strong></li><li><strong>初始化 <code>dp[1] = 1</code>，<code>dp[2] = 2</code>，<code>dp[3] = 3</code>。</strong></li><li><strong>从 4 开始到 <code>n</code> 进行遍历，对于每个 <code>i</code>，通过内层循环枚举所有可能的拆分方式。内层循环中，<code>j</code> 从 1 到 <code>i // 2 + 1</code>，表示将 <code>i</code> 拆分为 <code>j</code> 和 <code>i - j</code> 两部分，然后更新 <code>dp[i]</code> 为当前最大值，即之前计算的 <code>dp[j] * dp[i - j]</code> 与当前 <code>dp[i]</code> 的最大值。</strong></li><li><strong>最终返回 <code>dp</code> 数组的最后一个元素，即 <code>dp[-1]</code>，就是 <code>n</code> 的最大乘积拆分结果。</strong></li></ul> 
<h4><span style="color:#a2e043;">代码实现：</span></h4> 
<pre><code class="language-python">class Solution:
    def integerBreak(self, n: int) -&gt; int:
        def integer_break(n):
            if n &lt;= 3:
                return n - 1
            dp = [0] * (n + 1)
            dp[1] = 1
            dp[2] = 2
            dp[3] = 3

            for i in range(4, n + 1):
                for j in range(1, i // 2 + 1):
                    dp[i] = max(dp[i], dp[j] * dp[i - j])
            return dp[-1]
        return integer_break(n)</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c9/e2/5Gt3FQGZ_o.png"> </p> 
<hr> 
<h4><span style="color:#956fe7;"><strong>数学思维：</strong></span></h4> 
<p> </p> 
<ul><li><strong>首先定义了一个内部函数 <code>calc</code> 来处理具体的计算。</strong></li><li><strong>对于小于 4 的整数 <code>n</code>，直接返回 <code>n - 1</code>。这是因为 2 拆分后最大乘积为 1（即 1 + 1），3 拆分后最大乘积为 2（即 1 + 2）。</strong></li><li><strong>对于大于等于 4 的整数 <code>n</code>，根据 <code>n</code> 除以 3 的余数进行不同的处理。</strong> 
  <ul><li><strong>如果 <code>n</code> 除以 3 余数为 0，那么结果就是 3 的 <code>n // 3</code> 次方。这是因为 3 是拆分后能得到较大乘积的基本单元。</strong></li><li><strong>如果余数为 1，结果是 4 乘以 3 的 <code>(n // 3 - 1)</code> 次方。这是因为把一个 3 换成 2 和 2 组成 4 能得到更大的乘积。</strong></li><li><strong>如果余数为 2，结果是 2 乘以 3 的 <code>n // 3</code> 次方。</strong></li></ul></li></ul> 
<h4>代码实现：</h4> 
<pre><code class="language-python">class Solution:
    def integerBreak(self, n: int) -&gt; int:
        def calc(n):
            if n&lt;4: return n-1
            match n%3 :
                case 0: return 3**(n//3)
                case 1: return 4*3**(n//3-1)
                case 2: return 2*3**(n//3)
        return (calc(n))</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/3c/df/Klr5SQqf_o.png"></p> 
<hr> 
<h4 style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9e/de/Ih2jLEmp_o.jpg"></h4> 
<h4><span style="color:#a2e043;">总结：</span></h4> 
<p>        这两段代码都是解决整数 <code>n</code> 拆分以获取最大乘积的问题，但其思路各有千秋。</p> 
<p><strong>考察的内容</strong>：</p> 
<p></p> 
<ul><li>动态规划的思想，通过保存中间计算结果来逐步得出最终解。</li><li>对整数运算和余数的运用，根据不同的余数情况进行特定的处理。</li></ul> 
<p><strong>学到的内容</strong>：</p> 
<p></p> 
<ul><li>对于类似求最优解的问题，可以考虑使用动态规划来降低计算复杂度。</li><li>巧妙运用数学规律，如在这段代码中对 3 的组合以及根据余数的特殊处理，能够优化计算。</li></ul> 
<p><strong>反思</strong>：</p> 
<p></p> 
<ul><li>在解决问题时，要善于分析问题的特点，寻找规律，选择最合适的数据结构和算法。</li><li>对于整数运算和数学特性的深入理解，能够帮助我们设计更高效的算法。</li><li>不同的解法可能有不同的效率和适用场景，需要根据具体情况进行选择和优化。 例如，第一段代码使用动态规划，适用于较大规模的计算，但可能在空间复杂度上有一定开销；第二段代码利用数学规律，计算较为简洁，但可能对于问题的普适性需要进一步思考。 
  <hr><p></p> </li></ul> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/4a/9f/w89rSTXc_o.jpg"></p> 
<h2 style="text-align:center;"><span style="color:#0d0016;"><span style="background-color:#e6b223;"> “戒除欲望，控制行为，充实生活，美好的世界。”——《yuanziyu》</span></span></h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/29e20ae92a3c8f294f412104f1eff3a1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python WordCloud库：词云图制作</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7584403e3b5042578f356c2f4dc36784/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43; 算法教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>