<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】数据结构 知识总复习 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/9b3f726b25057f544bc99a0b8da45d0f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】数据结构 知识总复习">
  <meta property="og:description" content="文章目录 1. 复杂度计算1.1 时间复杂度1.2 空间复杂度1.3 如何计算 2. 常见线性结构2.1 顺序表 和 链表2.1.1 顺序表 (Array List)2.1.2 链表 (Linked List) 2.2 栈 和 队列2.2.1 什么是栈？什么是队列？关系是什么？2.2.2 如何实现？数组链表原生实现？适配器？ 3. 常见非线性结构3.1 二叉树3.2 堆3.2.1 性质和概念3.2.2 实现3.2.3 topk3.2.4 堆排序 3.3 二叉树常见问题3.4 搜索树3.4.1 概念性质3.4.2 增删查改3.4.3 缺陷3.4.4 缺陷解决方案：平衡树 3.5 哈希3.5.1 什么是哈希？3.5.2 如何解决哈希冲突3.5.3 位图3.5.4 布隆过滤器3.5.5 海量数据处理的问题 4. 算法4.1 排序4.2 二分查找 1. 复杂度计算 复杂度计算用于评估算法的效率，通常关注两个方面：时间复杂度和空间复杂度。
1.1 时间复杂度 时间复杂度衡量算法运行所需的时间，通常用大 O 表示法来表示：
O(1)：常数时间，算法执行时间不随输入规模的变化而变化。O(log n)：对数时间，执行时间随输入规模的对数增长，例如二分查找。O(n)：线性时间，执行时间与输入规模成正比，例如线性搜索。O(n log n)：线性对数时间，通常见于高效排序算法，如快速排序。O(n^2)：平方时间，执行时间与输入规模的平方成正比，例如冒泡排序。O(2^n)：指数时间，执行时间随输入规模指数增长，例如某些递归算法。O(n!)：阶乘时间，执行时间随输入规模阶乘增长，例如某些组合问题的算法。 1.2 空间复杂度 空间复杂度衡量算法运行时所需的内存，通常也用大 O 表示法：
O(1)：常数空间，所需内存与输入规模无关。O(n)：线性空间，所需内存与输入规模成正比，例如存储输入数据的数组。O(n^2)：平方空间，所需内存与输入规模的平方成正比，例如二维矩阵。 1.3 如何计算 确定基本操作：找出算法中最频繁执行的操作。分析循环结构：嵌套循环通常会增加复杂度的阶数。简化表达式：忽略低阶项和常数系数，专注于主要增长趋势。 示例：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-17T15:30:30+08:00">
    <meta property="article:modified_time" content="2024-08-17T15:30:30+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】数据结构 知识总复习</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1__1" rel="nofollow">1. 复杂度计算</a></li><li><ul><li><a href="#11__3" rel="nofollow">1.1 时间复杂度</a></li><li><a href="#12__14" rel="nofollow">1.2 空间复杂度</a></li><li><a href="#13__21" rel="nofollow">1.3 如何计算</a></li></ul> 
  </li><li><a href="#2__38" rel="nofollow">2. 常见线性结构</a></li><li><ul><li><a href="#21____39" rel="nofollow">2.1 顺序表 和 链表</a></li><li><ul><li><a href="#211__Array_List_40" rel="nofollow">2.1.1 顺序表 (Array List)</a></li><li><a href="#212__Linked_List_52" rel="nofollow">2.1.2 链表 (Linked List)</a></li></ul> 
   </li><li><a href="#22____65" rel="nofollow">2.2 栈 和 队列</a></li><li><ul><li><a href="#221__66" rel="nofollow">2.2.1 什么是栈？什么是队列？关系是什么？</a></li><li><a href="#222__84" rel="nofollow">2.2.2 如何实现？数组链表原生实现？适配器？</a></li></ul> 
  </li></ul> 
  </li><li><a href="#3__120" rel="nofollow">3. 常见非线性结构</a></li><li><ul><li><a href="#31__121" rel="nofollow">3.1 二叉树</a></li><li><a href="#32__122" rel="nofollow">3.2 堆</a></li><li><ul><li><a href="#321__123" rel="nofollow">3.2.1 性质和概念</a></li><li><a href="#322__128" rel="nofollow">3.2.2 实现</a></li><li><a href="#323_topk_140" rel="nofollow">3.2.3 topk</a></li><li><a href="#324__144" rel="nofollow">3.2.4 堆排序</a></li></ul> 
   </li><li><a href="#33__150" rel="nofollow">3.3 二叉树常见问题</a></li><li><a href="#34__151" rel="nofollow">3.4 搜索树</a></li><li><ul><li><a href="#341__153" rel="nofollow">3.4.1 概念性质</a></li><li><a href="#342__158" rel="nofollow">3.4.2 增删查改</a></li><li><a href="#343__167" rel="nofollow">3.4.3 缺陷</a></li><li><a href="#344__169" rel="nofollow">3.4.4 缺陷解决方案：平衡树</a></li></ul> 
   </li><li><a href="#35__213" rel="nofollow">3.5 哈希</a></li><li><ul><li><a href="#351__214" rel="nofollow">3.5.1 什么是哈希？</a></li><li><a href="#352__216" rel="nofollow">3.5.2 如何解决哈希冲突</a></li><li><a href="#353__252" rel="nofollow">3.5.3 位图</a></li><li><a href="#354__261" rel="nofollow">3.5.4 布隆过滤器</a></li><li><a href="#355__270" rel="nofollow">3.5.5 海量数据处理的问题</a></li></ul> 
  </li></ul> 
  </li><li><a href="#4__293" rel="nofollow">4. 算法</a></li><li><ul><li><a href="#41__294" rel="nofollow">4.1 排序</a></li><li><a href="#42__358" rel="nofollow">4.2 二分查找</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1__1"></a>1. 复杂度计算</h2> 
<p>复杂度计算用于评估算法的效率，通常关注两个方面：时间复杂度和空间复杂度。</p> 
<h3><a id="11__3"></a>1.1 时间复杂度</h3> 
<p>时间复杂度衡量算法运行所需的时间，通常用大 O 表示法来表示：</p> 
<blockquote> 
 <ul><li><strong>O(1)</strong>：常数时间，算法执行时间不随输入规模的变化而变化。</li><li><strong>O(log n)</strong>：对数时间，执行时间随输入规模的对数增长，例如二分查找。</li><li><strong>O(n)</strong>：线性时间，执行时间与输入规模成正比，例如线性搜索。</li><li><strong>O(n log n)</strong>：线性对数时间，通常见于高效排序算法，如快速排序。</li><li><strong>O(n^2)</strong>：平方时间，执行时间与输入规模的平方成正比，例如冒泡排序。</li><li><strong>O(2^n)</strong>：指数时间，执行时间随输入规模指数增长，例如某些递归算法。</li><li><strong>O(n!)</strong>：阶乘时间，执行时间随输入规模阶乘增长，例如某些组合问题的算法。</li></ul> 
</blockquote> 
<h3><a id="12__14"></a>1.2 空间复杂度</h3> 
<p>空间复杂度衡量算法运行时所需的内存，通常也用大 O 表示法：</p> 
<blockquote> 
 <ul><li>O(1)：常数空间，所需内存与输入规模无关。</li><li>O(n)：线性空间，所需内存与输入规模成正比，例如存储输入数据的数组。</li><li>O(n^2)：平方空间，所需内存与输入规模的平方成正比，例如二维矩阵。</li></ul> 
</blockquote> 
<h3><a id="13__21"></a>1.3 如何计算</h3> 
<blockquote> 
 <ol><li><strong>确定基本操作</strong>：找出算法中最频繁执行的操作。</li><li><strong>分析循环结构</strong>：嵌套循环通常会增加复杂度的阶数。</li><li><strong>简化表达式</strong>：忽略低阶项和常数系数，专注于主要增长趋势。</li></ol> 
</blockquote> 
<p><strong>示例：</strong><br> 假设有一个简单的算法：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 常数时间操作</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这个算法的时间复杂度是 O(n^2)，因为有两个嵌套的循环，每个循环都运行 n 次。</p> 
<h2><a id="2__38"></a>2. 常见线性结构</h2> 
<h3><a id="21____39"></a>2.1 顺序表 和 链表</h3> 
<h4><a id="211__Array_List_40"></a>2.1.1 顺序表 (Array List)</h4> 
<blockquote> 
 <ul><li><strong>原理</strong>：使用连续内存空间，支持通过索引直接访问。</li><li><strong>优点</strong>：随机访问速度快 (O(1))。</li><li><strong>缺点</strong>：插入和删除操作较慢 (O(n))，可能需要数组扩展或缩减。</li></ul> 
</blockquote> 
<p><strong>操作：</strong></p> 
<blockquote> 
 <ul><li><strong>查找</strong>：O(1)</li><li><strong>插入</strong>：O(n)</li><li><strong>删除</strong>：O(n)</li><li><strong>修改</strong>：O(1)</li></ul> 
</blockquote> 
<h4><a id="212__Linked_List_52"></a>2.1.2 链表 (Linked List)</h4> 
<blockquote> 
 <ul><li><strong>原理</strong>：节点不连续存储，通过指针链接。</li><li><strong>优点</strong>：插入和删除操作快 (O(1))，动态大小。</li><li><strong>缺点</strong>：随机访问较慢 (O(n))，额外空间用于指针。</li></ul> 
</blockquote> 
<p><strong>操作：</strong></p> 
<blockquote> 
 <ul><li><strong>查找</strong>：O(n)</li><li><strong>插入</strong>：O(1)（已知位置），O(n)（查找位置）</li><li><strong>删除</strong>：O(1)（已知位置），O(n)（查找位置）</li><li><strong>修改</strong>：O(n)（查找位置）</li></ul> 
</blockquote> 
<h3><a id="22____65"></a>2.2 栈 和 队列</h3> 
<h4><a id="221__66"></a>2.2.1 什么是栈？什么是队列？关系是什么？</h4> 
<p><strong>栈 (Stack)</strong></p> 
<blockquote> 
 <ul><li><strong>定义</strong>：遵循“后进先出”（LIFO）原则。最后插入的元素最先被取出。</li><li><strong>主要操作</strong>：入栈、出栈、查看栈顶、判断空栈。</li><li><strong>应用</strong>：函数调用、浏览器历史记录。</li></ul> 
</blockquote> 
<p><strong>队列 (Queue)</strong></p> 
<blockquote> 
 <ul><li><strong>定义</strong>：遵循“先进先出”（FIFO）原则。最早插入的元素最先被取出。</li><li><strong>主要操作</strong>：入队、出队、查看队头、判断空队列。</li><li><strong>应用</strong>：任务调度、数据缓冲。</li></ul> 
</blockquote> 
<p><strong>关系</strong></p> 
<blockquote> 
 <ul><li><strong>操作方式</strong>：栈在一端操作（栈顶），队列在两端操作（队头和队尾）。</li><li><strong>实现</strong>：栈和队列可以通过数组或链表实现，但操作规则不同。</li></ul> 
</blockquote> 
<h4><a id="222__84"></a>2.2.2 如何实现？数组链表原生实现？适配器？</h4> 
<p><strong>栈 的实现：</strong></p> 
<ul><li>数组实现：</li></ul> 
<blockquote> 
 <ul><li><strong>入栈</strong>：添加到数组末尾。</li><li><strong>出栈</strong>：从数组末尾移除元素。</li><li><strong>查看栈顶</strong>：访问数组末尾元素。</li></ul> 
</blockquote> 
<ul><li>链表实现：</li></ul> 
<blockquote> 
 <ul><li><strong>入栈</strong>：在链表头部插入元素。</li><li><strong>出栈</strong>：从链表头部移除元素。</li><li><strong>查看栈顶</strong>：访问链表头部元素。</li></ul> 
</blockquote> 
<p><strong>队列 的实现：</strong></p> 
<ul><li>数组实现：</li></ul> 
<blockquote> 
 <ul><li><strong>入队</strong>：添加到数组末尾。</li><li><strong>出队</strong>：从数组开头移除元素。</li><li><strong>循环数组</strong>：使用环形缓冲区优化性能。</li></ul> 
</blockquote> 
<ul><li>链表实现：</li></ul> 
<blockquote> 
 <ul><li><strong>入队</strong>：在链表尾部插入元素。</li><li><strong>出队</strong>：从链表头部移除元素。</li><li><strong>查看队头</strong>：访问链表头部元素。</li></ul> 
</blockquote> 
<p><strong>适配器实现</strong></p> 
<ul><li>栈基于队列：</li></ul> 
<blockquote> 
 <ul><li>单队列：通过旋转队列模拟栈。</li><li>双队列：使用两个队列交替操作。</li></ul> 
</blockquote> 
<ul><li>队列基于栈：</li></ul> 
<blockquote> 
 <ul><li>双栈：使用两个栈交替操作实现队列。</li></ul> 
</blockquote> 
<h2><a id="3__120"></a>3. 常见非线性结构</h2> 
<h3><a id="31__121"></a>3.1 二叉树</h3> 
<h3><a id="32__122"></a>3.2 堆</h3> 
<h4><a id="321__123"></a>3.2.1 性质和概念</h4> 
<p><strong>堆</strong>是一种完全二叉树数据结构，分为最大堆和最小堆：</p> 
<blockquote> 
 <ul><li><strong>最大堆</strong>：每个节点的值大于或等于其子节点的值，根节点是最大值。</li><li><strong>最小堆</strong>：每个节点的值小于或等于其子节点的值，根节点是最小值。</li></ul> 
</blockquote> 
<h4><a id="322__128"></a>3.2.2 实现</h4> 
<p><strong>数组表示：</strong></p> 
<blockquote> 
 <ul><li><strong>左子节点</strong>索引：<code>2i</code></li><li><strong>右子节点</strong>索引：<code>2i + 1</code></li><li><strong>父节点</strong>索引：<code>i / 2</code></li></ul> 
</blockquote> 
<p><strong>操作：</strong></p> 
<blockquote> 
 <ul><li><strong>插入</strong>：将新元素添加到末尾，然后上浮调整。</li><li><strong>删除</strong>：删除根节点（最大或最小值），用末尾元素替换，然后下沉调整。</li><li><strong>堆化</strong>：将数组调整为堆。</li></ul> 
</blockquote> 
<h4><a id="323_topk_140"></a>3.2.3 topk</h4> 
<p><strong>Top-K 问题：</strong></p> 
<blockquote> 
 <ul><li>使用最小堆保持<code>k</code>个最大元素，时间复杂度<code>O(nlogk)</code></li></ul> 
</blockquote> 
<h4><a id="324__144"></a>3.2.4 堆排序</h4> 
<p><strong>堆排序：</strong></p> 
<blockquote> 
 <ul><li><strong>构建最大堆</strong>。</li><li><strong>排序</strong>：将根节点（最大值）与最后一个元素交换，调整堆。</li><li><strong>时间复杂度</strong>：<code>O(n log n)</code>，<strong>空间复杂度</strong>：<code>O(1)</code>。</li></ul> 
</blockquote> 
<h3><a id="33__150"></a>3.3 二叉树常见问题</h3> 
<h3><a id="34__151"></a>3.4 搜索树</h3> 
<p>搜索树是一种用于存储有序数据并支持高效查找、插入和删除操作的数据结构。主要包括二叉搜索树（BST）、AVL树和红黑树。</p> 
<h4><a id="341__153"></a>3.4.1 概念性质</h4> 
<ul><li><strong>二叉搜索树（BST）</strong>：</li></ul> 
<blockquote> 
 <ul><li><strong>性质</strong>：对于每个节点，其左子树包含所有小于该节点的值，右子树包含所有大于该节点的值。</li><li><strong>查找</strong>：平均时间复杂度 <code>O(log n)</code>，最坏情况 <code>O(n)</code>（如链表）。</li></ul> 
</blockquote> 
<h4><a id="342__158"></a>3.4.2 增删查改</h4> 
<ul><li><strong>查找</strong>：从根节点开始，根据键值向左或右子树递归查找。</li><li><strong>插入</strong>：插入新节点后，维护 BST 的性质。</li><li><strong>删除</strong>：删除节点后，可能需要重构树以保持 BST 的性质。三种情况：</li></ul> 
<blockquote> 
 <ol><li>删除叶节点。</li><li>删除只有一个子节点的节点。</li><li>删除有两个子节点的节点（用右子树的最小值或左子树的最大值替换）。</li></ol> 
</blockquote> 
<h4><a id="343__167"></a>3.4.3 缺陷</h4> 
<ul><li><strong>缺陷</strong>：BST 在最坏情况下退化为链表，导致操作效率降低。</li></ul> 
<h4><a id="344__169"></a>3.4.4 缺陷解决方案：平衡树</h4> 
<p><strong>平衡树</strong>通过自平衡机制保持树的高度尽可能低，保证操作效率。主要包括 AVL 树和红黑树。</p> 
<ul><li><strong>AVL树</strong>：</li></ul> 
<blockquote> 
 <ul><li><strong>性质</strong>：每个节点的左子树和右子树的高度差（平衡因子）至多为 1。</li><li><strong>效率</strong>：查找、插入、删除操作的时间复杂度均为 O(log n)。</li><li><strong>实现逻辑</strong>：</li></ul> 
 <blockquote> 
  <ul><li><strong>旋转操作</strong>：单旋转（左旋、右旋）和双旋转（左-右旋、右-左旋），用于恢复平衡。</li><li><strong>插入</strong>：插入后进行旋转调整。</li><li><strong>删除</strong>：删除后进行旋转调整以恢复平衡。</li></ul> 
 </blockquote> 
</blockquote> 
<ul><li><strong>红黑树</strong>：</li></ul> 
<blockquote> 
 <ul><li><strong>性质</strong>：每个节点是红色或黑色，满足以下条件：</li></ul> 
 <blockquote> 
  <ol><li>根节点是黑色。</li><li>个叶子节点（NIL）是黑色。</li><li>如果一个节点是红色，则它的两个子节点都是黑色。</li><li>从每个节点到其每个叶子节点的路径包含相同数量的黑色节点。</li></ol> 
 </blockquote> 
 <ul><li><strong>效率</strong>：查找、插入、删除操作的时间复杂度均为 O(log n)。</li><li><strong>实现逻辑</strong>：</li></ul> 
 <blockquote> 
  <ul><li><strong>旋转操作</strong>：类似 AVL 树。</li><li><strong>颜色调整</strong>：插入或删除后调整节点颜色和进行旋转以维护红黑树性质。</li></ul> 
 </blockquote> 
</blockquote> 
<ul><li><strong>AVL树 与 红黑树 的区别</strong>：</li></ul> 
<blockquote> 
 <ul><li><strong>平衡性：</strong></li></ul> 
 <blockquote> 
  <ul><li><strong>AVL 树</strong>：更严格的平衡，确保树高度差不超过 1，查找操作更快，但插入和删除需要更多的旋转操作。</li><li><strong>红黑树</strong>：较宽松的平衡，允许更多的高度差，插入和删除操作相对较快，但查找操作可能稍慢。</li></ul> 
 </blockquote> 
 <ul><li><strong>实现复杂性：</strong></li></ul> 
 <blockquote> 
  <ul><li><strong>AVL 树</strong>：旋转操作较多，复杂度高。</li><li><strong>红黑树</strong>：相对较少的旋转操作和颜色调整，易于实现。</li></ul> 
 </blockquote> 
 <ul><li><strong>应用场景：</strong></li></ul> 
 <blockquote> 
  <ul><li><strong>AVL 树</strong>：适用于查找频繁的场景。</li><li><strong>红黑树</strong>：适用于插入和删除操作频繁的场景，如 C++ STL 的 <code>map</code> 和 <code>set</code> 使用红黑树。</li></ul> 
 </blockquote> 
</blockquote> 
<h3><a id="35__213"></a>3.5 哈希</h3> 
<h4><a id="351__214"></a>3.5.1 什么是哈希？</h4> 
<p><strong>哈希</strong>是一种将数据映射到固定大小的值（哈希值）的过程，用于快速查找和存储数据。</p> 
<h4><a id="352__216"></a>3.5.2 如何解决哈希冲突</h4> 
<p><strong>闭散列</strong>（开放地址法）是处理哈希冲突的一种方法。主要有<strong>线性探测</strong>和<strong>二次探测</strong>两种方式：</p> 
<ul><li><strong>线性探测</strong>（Linear Probing）</li></ul> 
<blockquote> 
 <ul><li><strong>方法</strong>：发生冲突时，顺序查找下一个位置。</li><li><strong>缺陷</strong>：</li></ul> 
 <blockquote> 
  <ul><li><strong>主聚集</strong>：连续的被占用区域，导致性能下降。</li><li><strong>性能退化</strong>：表满时，查找和插入效率降低。</li></ul> 
 </blockquote> 
</blockquote> 
<ul><li><strong>二次探测</strong>（Quadratic Probing）</li></ul> 
<blockquote> 
 <ul><li><strong>方法</strong>：冲突后，使用二次方程计算下一个位置。</li><li><strong>缺陷</strong>：</li></ul> 
 <blockquote> 
  <ul><li><strong>二次聚集</strong>：探测序列可能会形成聚集。</li><li><strong>表大小要求</strong>：通常要求表大小为质数，增加实现复杂性。</li></ul> 
 </blockquote> 
</blockquote> 
<ul><li><strong>总结</strong>：线性探测简单但易聚集，二次探测减少了聚集但复杂度更高。选择适当方法需根据实际需求。</li></ul> 
<p><strong>开散列</strong>（拉链法）是一种解决哈希表冲突的方法，通过在每个哈希槽上维护一个链表来存储冲突的元素。它的优点包括：</p> 
<blockquote> 
 <ol><li><strong>简单易实现</strong>：链表操作简单，易于处理动态增长的元素。</li><li><strong>性能稳定</strong>：负载因子增加时，性能相对稳定。</li><li><strong>灵活的内存使用</strong>：链表可以动态增长，无需重新分配整个哈希表。</li><li><strong>删除操作简单</strong>：删除元素只需从链表中移除即可。</li></ol> 
</blockquote> 
<p><strong>应对冲突严重的方法：</strong></p> 
<blockquote> 
 <ol><li><strong>优化哈希函数</strong>：设计良好的哈希函数以减少冲突。</li><li><strong>调整表的大小</strong>：通过扩展哈希表和重新哈希减少链表长度。</li><li><strong>使用其他数据结构</strong>：长链表可用平衡树替代，以提高效率。</li><li><strong>合理设置负载因子</strong>：动态调整负载因子，定期扩展哈希表。</li><li><strong>监控性能</strong>：定期检查哈希表性能，以便进行优化。</li></ol> 
</blockquote> 
<h4><a id="353__252"></a>3.5.3 位图</h4> 
<p>位图是一种用于高效存储和快速查询的二进制数据结构，主要用于表示集合中的元素是否存在。以下是位图的主要特点：</p> 
<blockquote> 
 <ol><li><strong>存储方式</strong>：位图使用一个数组，每个元素用一个比特位表示。如果元素存在，则对应的位设置为1，不存在则设置为0。</li><li><strong>直接定址</strong>：元素的值直接作为数组索引，通过该索引访问或修改对应的位，因此没有哈希冲突。</li><li><strong>节省空间</strong>：位图每个元素只用一个比特位，相比其他数据结构（如整型数组），能够显著减少内存使用，尤其适合处理大量数据的存在性检测。</li><li><strong>查询效率高</strong>：由于位图的查询和更新操作都可以在常数时间内完成，适合需要快速判断元素是否存在的场景。</li></ol> 
</blockquote> 
<p><strong>总结</strong>：位图是一种高效的空间利用和查询的数据结构，用于表示和操作大量元素的存在性。</p> 
<h4><a id="354__261"></a>3.5.4 布隆过滤器</h4> 
<p>布隆过滤器是一种高效的空间优化数据结构，用于判断一个元素是否在一个集合中。其特点包括：</p> 
<blockquote> 
 <ol><li><strong>空间节省</strong>：使用多个哈希函数和一个位图来表示集合，显著减少存储需求，适合处理大规模数据。</li><li><strong>误判</strong>：布隆过滤器可以准确地确定元素<strong>不在</strong>集合中，但不能100%保证元素<strong>在</strong>集合中，可能存在误判（即误报），因为不同的元素可能会映射到相同的位。</li><li><strong>操作效率</strong>：元素的加入和查询操作都很快，时间复杂度为常数时间 O(k)，其中 k 是哈希函数的数量。</li><li><strong>删除问题</strong>：布隆过滤器无法直接删除元素，因为其位图中的位可能被多个元素共享，解决方案包括使用计数型布隆过滤器或周期性重新生成过滤器。</li></ol> 
</blockquote> 
<p><strong>总结</strong>：布隆过滤器通过使用多个哈希函数和位图，能够高效地存储和查询大规模数据，但存在一定的误判概率。</p> 
<h4><a id="355__270"></a>3.5.5 海量数据处理的问题</h4> 
<p>在海量数据处理问题中，以下三种技术可以有效解决数据存储和查询问题：</p> 
<blockquote> 
 <ol><li><strong>位图</strong>：</li></ol> 
 <blockquote> 
  <ul><li><strong>解决方法</strong>：使用一个大位数组（或位图）来记录数据的存在性，每一位表示一个数据项的状态（存在或不存在）。适用于数据范- 围较小且可以用位表示的场景。</li><li><strong>优点</strong>：查询效率高，适合存储和处理布尔值数据。</li><li><strong>缺点</strong>：对于范围非常大的数据（例如大范围的整数），位图可能占用过多内存。</li></ul> 
 </blockquote> 
 <ol start="2"><li>布<strong>隆过滤器</strong>：</li></ol> 
 <blockquote> 
  <ul><li><strong>解决方法</strong>：使用多个哈希函数和一个位图来高效地检测某个元素是否在集合中。适用于需要处理大量数据的情况。</li><li><strong>优点</strong>：节省存储空间，查询速度快。</li><li>缺点：可能产生误判（误报），不能直接删除元素。</li></ul> 
 </blockquote> 
 <ol start="3"><li><strong>哈希切分</strong>（Hash Partitioning）：</li></ol> 
 <blockquote> 
  <ul><li>解决方法：通过哈希函数将数据分散到多个存储分区中，以便更均匀地分配存储负载和提高并行处理能力。</li><li>优点：能处理超大规模数据，通过分区管理避免单个节点的负载过重。</li><li>缺点：需要设计合理的哈希函数和分区策略，以避免数据倾斜和负载不均。</li></ul> 
 </blockquote> 
</blockquote> 
<p>这些技术可以根据具体的数据处理需求和应用场景，单独或组合使用，以优化数据存储和查询性能。</p> 
<h2><a id="4__293"></a>4. 算法</h2> 
<h3><a id="41__294"></a>4.1 排序</h3> 
<ol><li><strong>冒泡排序</strong>（Bubble Sort）：</li></ol> 
<blockquote> 
 <ul><li><strong>实现</strong>：重复遍历待排序列，比较相邻元素并交换，使得较大的元素逐渐“冒泡”到末尾。</li><li><strong>复杂度</strong>：最坏和平均情况 O(n²)，最佳情况 O(n)（当已排序时）。</li><li><strong>稳定性</strong>：稳定。</li><li><strong>适用场景</strong>：数据量较小或对稳定性有高要求时使用。</li></ul> 
</blockquote> 
<ol start="2"><li><strong>选择排序</strong>（Selection Sort）：</li></ol> 
<blockquote> 
 <ul><li><strong>实现</strong>：每次选择未排序部分的最小（或最大）元素，将其放到已排序部分的末尾。</li><li><strong>复杂度</strong>：O(n²)。</li><li><strong>稳定性</strong>：不稳定。</li><li><strong>适用场景</strong>：对内存占用有严格要求且数据量小的情况。</li></ul> 
</blockquote> 
<ol start="3"><li><strong>插入排序</strong>（Insertion Sort）：</li></ol> 
<blockquote> 
 <ul><li><strong>实现</strong>：将待排序元素插入到已排序部分的适当位置，像手工排序扑克牌一样。</li><li><strong>复杂度</strong>：最坏和平均情况 O(n²)，最佳情况 O(n)（当已排序时）。</li><li><strong>稳定性</strong>：稳定。</li><li><strong>适用场景</strong>：数据量较小或部分已排序时使用。</li></ul> 
</blockquote> 
<ol start="4"><li><strong>归并排序</strong>（Merge Sort）：</li></ol> 
<blockquote> 
 <ul><li><strong>实现</strong>：将数据分割成更小的部分，递归地排序这些部分，然后合并已排序的部分。</li><li><strong>复杂度</strong>：O(n log n)。</li><li><strong>稳定性</strong>：稳定。</li><li><strong>适用场景</strong>：大数据量，且需要稳定排序时。</li></ul> 
</blockquote> 
<ol start="5"><li><strong>快速排序</strong>（Quick Sort）：</li></ol> 
<blockquote> 
 <ul><li><strong>实现</strong>：选择一个“基准”元素，将数据分为两个部分，递归地对这两部分进行排序。</li><li><strong>复杂度</strong>：平均情况 O(n log n)，最坏情况 O(n²)（例如基准选择不当）。</li><li><strong>稳定性</strong>：不稳定。</li><li><strong>适用场景</strong>：大数据量时，快速排序通常表现优越。</li></ul> 
</blockquote> 
<ol start="6"><li><strong>堆排序</strong>（Heap Sort）：</li></ol> 
<blockquote> 
 <ul><li><strong>实现</strong>：将数据构建成一个堆，每次取出堆顶元素，并重建堆。</li><li><strong>复杂度</strong>：O(n log n)。</li><li><strong>稳定性</strong>：不稳定。</li><li><strong>适用场景</strong>：需要优良时间复杂度且不要求稳定性时。</li></ul> 
</blockquote> 
<ol start="7"><li><strong>计数排序</strong>（Counting Sort）：</li></ol> 
<blockquote> 
 <ul><li><strong>实现</strong>：统计每个元素的出现次数，然后按顺序重建排序后的数据。</li><li><strong>复杂度</strong>：O(n + k)，其中 k 是元素范围。</li><li><strong>稳定性</strong>：稳定。</li><li><strong>适用场景</strong>：元素范围有限且数据量大的情况。</li></ul> 
</blockquote> 
<ol start="8"><li><strong>基数排序</strong>（Radix Sort）：</li></ol> 
<blockquote> 
 <ul><li><strong>实现</strong>：按每一位的值进行多轮排序（通常结合计数排序作为稳定的子排序）。</li><li><strong>复杂度</strong>：O(nk)，其中 k 是位数。</li><li><strong>稳定性</strong>：稳定。</li><li><strong>适用场景</strong>：处理整数数据，尤其是位数较少时效果良好。</li></ul> 
</blockquote> 
<ol start="9"><li><strong>希尔排序</strong>（Shell Sort）：</li></ol> 
<blockquote> 
 <ul><li><strong>实现</strong>：通过多轮插入排序，逐步减少间隔（增量），最终进行标准插入排序。</li><li><strong>复杂度</strong>：最坏情况 O(n²)，增量序列优化后可达 O(n log n)。</li><li><strong>稳定性</strong>：不稳定。</li><li><strong>适用场景</strong>：中等规模的数据集，内存有限时。</li></ul> 
</blockquote> 
<h3><a id="42__358"></a>4.2 二分查找</h3> 
<p>二分查找是一种高效的查找算法，适用于已排序的数组。其基本思路是将数组分成两半，通过比较中间元素与目标值，决定继续在哪一半进行查找。算法步骤如下：</p> 
<ol><li><strong>初始化</strong>：设定两个指针，<code>left</code> 指向数组起始位置，<code>right</code> 指向数组末尾位置。</li><li><strong>循环</strong>：计算中间位置 <code>mid</code>，比较 <code>mid</code> 位置的元素与目标值。</li></ol> 
<blockquote> 
 <ul><li>如果相等，返回 <code>mid</code> 位置。</li><li>如果目标值小于 <code>mid</code> 位置的元素，将 <code>right</code> 指向 <code>mid - 1</code>。</li><li>如果目标值大于 <code>mid</code> 位置的元素，将 <code>left</code> 指向 <code>mid + 1</code>。</li></ul> 
</blockquote> 
<ol start="3"><li><strong>结束</strong>：当 <code>left</code> 超过 <code>right</code> 时，查找结束，如果未找到目标值，返回 <code>-1</code> 或表示未找到的标识。</li></ol> 
<p><strong>时间复杂度：O(log n)，空间复杂度：O(1)</strong>。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/83d936a9fbb50422599c1709b540cc58/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;类和对象(2)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ceff5de69f530d0a725f3bf32fa2c30b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C:指针学习-指针变量—学习笔记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>