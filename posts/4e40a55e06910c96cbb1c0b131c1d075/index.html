<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构【链试结构二叉树】 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4e40a55e06910c96cbb1c0b131c1d075/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构【链试结构二叉树】">
  <meta property="og:description" content="🌟摘要：设⼆叉树的根结点所在层数 为1，层序遍历就是从所在⼆叉树的根结点出发，⾸先访问第⼀层的树根结点，然后从左到右访问第2 层上的结点，接着是第三层的结点，以此类推，⾃上⽽下，⾃左⾄右逐层访问树的结点的过程就是层 序遍历。根结点的左⼦树和右⼦树分别⼜是由⼦树结点、⼦树结点的左⼦树、⼦树结点的右⼦树组成的，因此 ⼆叉树定义是递归式的,后序链式⼆叉树的操作中基本都是按照该概念实现的。回顾⼆叉树的概念，⼆叉树分为空树和⾮空⼆叉树，⾮空⼆叉树由根结点、根结点的左⼦树、根结点 的右⼦树组成的。根结点、左⼦树、右⼦树。
🌟个人主页：落叶
目录
实现链式结构⼆叉树
前中后序遍历：
遍历规则
代码实现
前序遍历：
中序遍历：
后序遍历：
图解遍历：
函数递归栈帧图：
结点个数以及高度等
【⼆叉树】结点个数
【二叉树】叶子节点个数
【二叉树】第k层节点个数
【二叉树】的深度/⾼度
【二叉树】查找值为x的结点 【二叉树】销毁
层序遍历
判断是否为完全二叉树
实现链式结构⼆叉树 ⽤链表来表⽰⼀棵⼆叉树，即⽤链来指⽰元素的逻辑关系。通常的⽅法是链表中每个结点由三个域组 成，数据域和左右指针域，左右指针分别⽤来给出该结点左孩⼦和右孩⼦所在的链结点的存储地址， 其结构如下：
创建二叉树数据：
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;assert.h&gt; typedef int data; typedef struct Tree { int arr; //数值 struct Tree* zuo;//左孩子 struct Tree* you;//右孩子 }BT; ⼆叉树的创建⽅式⽐较复杂，为了更好的步⼊到⼆叉树内容中，我们先⼿动创建⼀棵链式⼆叉树
我们进行连接后就成下面这个二叉树
当然我们也可以这样看
//申请空间 BT* koj(data x) { //申请节点 BT* tab = (BT*)malloc(sizeof(BT)); if (tab == NULL) { perror(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-25T19:47:16+08:00">
    <meta property="article:modified_time" content="2024-08-25T19:47:16+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构【链试结构二叉树】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 id="%C2%A0%E2%80%8B%E7%BC%96%E8%BE%91"> <img alt="" height="494" src="https://images2.imgbox.com/43/b5/roxpHc7r_o.gif" width="878"></h4> 
<hr> 
<blockquote> 
 <p>🌟<strong>摘要：设⼆叉树的根结点所在层数 为1，层序遍历就是从所在⼆叉树的根结点出发，⾸先访问第⼀层的树根结点，然后从左到右访问第2 层上的结点，接着是第三层的结点，以此类推，⾃上⽽下，⾃左⾄右逐层访问树的结点的过程就是层 序遍历。根结点的左⼦树和右⼦树分别⼜是由⼦树结点、⼦树结点的左⼦树、⼦树结点的右⼦树组成的，因此 ⼆叉树定义是递归式的,后序链式⼆叉树的操作中基本都是按照该概念实现的。回顾⼆叉树的概念，⼆叉树分为空树和⾮空⼆叉树，⾮空⼆叉树由根结点、根结点的左⼦树、根结点 的右⼦树组成的。根结点、左⼦树、右⼦树。</strong></p> 
</blockquote> 
<p></p> 
<hr> 
<blockquote> 
 <p></p> 
 <p>🌟个人主页：<a class="link-info" href="https://blog.csdn.net/qq_67578580?type=blog" title="落叶">落叶</a></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%C2%A0%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:80px;"><a href="#%C2%A0%E2%80%8B%E7%BC%96%E8%BE%91" rel="nofollow"> </a></p> 
<p id="%E5%AE%9E%E7%8E%B0%E9%93%BE%E5%BC%8F%E7%BB%93%E6%9E%84%E2%BC%86%E5%8F%89%E6%A0%91-toc" style="margin-left:80px;"><a href="#%E5%AE%9E%E7%8E%B0%E9%93%BE%E5%BC%8F%E7%BB%93%E6%9E%84%E2%BC%86%E5%8F%89%E6%A0%91" rel="nofollow">实现链式结构⼆叉树</a></p> 
<p id="%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A" rel="nofollow">前中后序遍历：</a></p> 
<p id="%E9%81%8D%E5%8E%86%E8%A7%84%E5%88%99-toc" style="margin-left:160px;"><a href="#%E9%81%8D%E5%8E%86%E8%A7%84%E5%88%99" rel="nofollow">遍历规则</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:160px;"><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">代码实现</a></p> 
<p id="%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A-toc" style="margin-left:200px;"><a href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A" rel="nofollow">前序遍历：</a></p> 
<p id="%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A-toc" style="margin-left:200px;"><a href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A" rel="nofollow">中序遍历：</a></p> 
<p id="%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A-toc" style="margin-left:200px;"><a href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A" rel="nofollow">后序遍历：</a></p> 
<p id="%E5%9B%BE%E8%A7%A3%E9%81%8D%E5%8E%86%EF%BC%9A-toc" style="margin-left:160px;"><a href="#%E5%9B%BE%E8%A7%A3%E9%81%8D%E5%8E%86%EF%BC%9A" rel="nofollow">图解遍历：</a></p> 
<p id="%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92%E6%A0%88%E5%B8%A7%E5%9B%BE%EF%BC%9A-toc" style="margin-left:200px;"><a href="#%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92%E6%A0%88%E5%B8%A7%E5%9B%BE%EF%BC%9A" rel="nofollow">函数递归栈帧图：</a></p> 
<p id="%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0%E4%BB%A5%E5%8F%8A%E9%AB%98%E5%BA%A6%E7%AD%89-toc" style="margin-left:120px;"><a href="#%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0%E4%BB%A5%E5%8F%8A%E9%AB%98%E5%BA%A6%E7%AD%89" rel="nofollow">结点个数以及高度等</a></p> 
<p id="%E3%80%90%E2%BC%86%E5%8F%89%E6%A0%91%E3%80%91%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0-toc" style="margin-left:160px;"><a href="#%E3%80%90%E2%BC%86%E5%8F%89%E6%A0%91%E3%80%91%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0" rel="nofollow">【⼆叉树】结点个数</a></p> 
<p id="%E3%80%90%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0-toc" style="margin-left:160px;"><a href="#%E3%80%90%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0" rel="nofollow">【二叉树】叶子节点个数</a></p> 
<p id="%E3%80%90%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91%E7%AC%ACk%E5%B1%82%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0-toc" style="margin-left:160px;"><a href="#%E3%80%90%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91%E7%AC%ACk%E5%B1%82%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0" rel="nofollow">【二叉树】第k层节点个数</a></p> 
<p id="%E3%80%90%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91%E7%9A%84%E6%B7%B1%E5%BA%A6%2F%E2%BE%BC%E5%BA%A6-toc" style="margin-left:160px;"><a href="#%E3%80%90%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91%E7%9A%84%E6%B7%B1%E5%BA%A6%2F%E2%BE%BC%E5%BA%A6" rel="nofollow">【二叉树】的深度/⾼度</a></p> 
<p id="%E3%80%90%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91%E6%9F%A5%E6%89%BE%E5%80%BC%E4%B8%BAx%E7%9A%84%E7%BB%93%E7%82%B9%C2%A0-toc" style="margin-left:160px;"><a href="#%E3%80%90%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91%E6%9F%A5%E6%89%BE%E5%80%BC%E4%B8%BAx%E7%9A%84%E7%BB%93%E7%82%B9%C2%A0" rel="nofollow">【二叉树】查找值为x的结点 </a></p> 
<p id="%E3%80%90%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91%E9%94%80%E6%AF%81-toc" style="margin-left:160px;"><a href="#%E3%80%90%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91%E9%94%80%E6%AF%81" rel="nofollow">【二叉树】销毁</a></p> 
<p id="%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-toc" style="margin-left:120px;"><a href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86" rel="nofollow">层序遍历</a></p> 
<p id="%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:120px;"><a href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">判断是否为完全二叉树</a></p> 
<p></p> 
<hr> 
<h4 id="%E5%AE%9E%E7%8E%B0%E9%93%BE%E5%BC%8F%E7%BB%93%E6%9E%84%E2%BC%86%E5%8F%89%E6%A0%91" style="background-color:transparent;">实现链式结构⼆叉树</h4> 
<p><span style="background-color:#ffd900;">⽤链表来表⽰⼀棵⼆叉树，即⽤链来指⽰元素的逻辑关系。通常的⽅法是链表中每个结点由三个域组 成，数据域和左右指针域，左右指针分别⽤来给出该结点左孩⼦和右孩⼦所在的链结点的存储地址， 其结构如下：</span></p> 
<p><strong>创建二叉树数据：</strong></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;

typedef int data;
typedef struct Tree
{
	int arr;    //数值
	struct Tree* zuo;//左孩子
	struct Tree* you;//右孩子
}BT;</code></pre> 
<hr> 
<p><span style="color:#fe2c24;"><strong>⼆叉树的创建⽅式⽐较复杂，为了更好的步⼊到⼆叉树内容中，我们先⼿动创建⼀棵链式⼆叉树</strong></span></p> 
<p><img alt="" height="612" src="https://images2.imgbox.com/73/33/t7rV1T5o_o.png" width="425"></p> 
<p><span style="color:#fe2c24;"><strong>我们进行连接后就成下面这个二叉树</strong></span></p> 
<p><img alt="" height="507" src="https://images2.imgbox.com/d3/3f/WMhVcpBe_o.png" width="762"></p> 
<hr> 
<p><span style="color:#fe2c24;"><strong>当然我们也可以这样看</strong></span></p> 
<p><img alt="" height="425" src="https://images2.imgbox.com/93/66/2QnLvukF_o.png" width="605"></p> 
<pre><code class="language-cpp">//申请空间
BT* koj(data x)
{
	//申请节点
	BT* tab = (BT*)malloc(sizeof(BT));
	if (tab == NULL)
	{
		perror("malloic");
		exit(1);
	}
	tab-&gt;arr = x;
	tab-&gt;zuo= tab-&gt;you = NULL;

	return tab;
}
void p()
{
	//创建节点
	BT* n1 = koj(1);
	BT* n2 = koj(2);
	BT* n3 = koj(3);
	BT* n4 = koj(4);
	//进行连接
	n1-&gt;zuo = n2;
	n1-&gt;you = n3;
	n2-&gt;zuo = n4;

}



int main()
{
	p();
	return 0;
}</code></pre> 
<hr> 
<p><span style="background-color:#a2e043;">回顾⼆叉树的概念，⼆叉树分为空树和⾮空⼆叉树，⾮空⼆叉树由根结点、根结点的左⼦树、根结点 的右⼦树组成的</span></p> 
<p><img alt="" height="1184" src="https://images2.imgbox.com/27/81/8SkgGmLB_o.png" width="1200"></p> 
<p>根结点的左⼦树和右⼦树分别⼜是由⼦树结点、⼦树结点的左⼦树、⼦树结点的右⼦树组成的，因此 ⼆叉树定义是递归式的,后序链式⼆叉树的操作中基本都是按照该概念实现的。</p> 
<h5 id="%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A">前中后序遍历：</h5> 
<p><strong>⼆叉树的操作离不开树的遍历，我们先来看看⼆叉树的遍历有哪些⽅式</strong></p> 
<p><img alt="" height="458" src="https://images2.imgbox.com/90/75/sss5JczY_o.png" width="750"></p> 
<h6 id="%E9%81%8D%E5%8E%86%E8%A7%84%E5%88%99">遍历规则</h6> 
<p><span style="background-color:#a2e043;">按照规则，⼆叉树的遍历有：前序/中序/后序的递归结构遍历：</span></p> 
<blockquote> 
 <p>（1）前序遍历(PreorderTraversal亦称先序遍历)：访问根结点的操作发⽣在遍历其左右⼦树之前</p> 
 <p><span style="background-color:#ffd900;">访问顺序为：</span><span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">根结点、左⼦树、右⼦树</span></strong></span></p> 
 <p>（2）中序遍历(InorderTraversal)：访问根结点的操作发⽣在遍历其左右⼦树之中（间）</p> 
 <p><span style="background-color:#ffd900;">访问顺序为：</span><span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">左⼦树、根结点、右⼦树</span></strong></span></p> 
 <p>（3）后序遍历(PostorderTraversal)：访问根结点的操作发⽣在遍历其左右⼦树之后</p> 
 <p><span style="background-color:#ffd900;">访问顺序为：</span><span style="color:#fe2c24;"><strong><span style="background-color:#ffd900;">左⼦树、右⼦树、根结点</span></strong></span></p> 
</blockquote> 
<h6 id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</h6> 
<h6 id="%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A">前序遍历：</h6> 
<p>访问顺序为：<span style="color:#fe2c24;"><strong>根结点、左⼦树、右⼦树</strong></span></p> 
<p><img alt="" height="317" src="https://images2.imgbox.com/3b/b6/9up1Gbjr_o.png" width="306"></p> 
<pre><code class="language-cpp">//前序遍历-（根-左-右）
void qian(BT* root)
{
	if (root == NULL)
	{
		return;
	}
	printf("%d ", root-&gt;arr);
	//左子树
	qian(root-&gt;zuo);
	//右子树
	qian(root-&gt;you);
}
</code></pre> 
<hr> 
<p><img alt="" height="467" src="https://images2.imgbox.com/f7/34/TGhQzgME_o.png" width="750"></p> 
<hr> 
<p><img alt="" height="620" src="https://images2.imgbox.com/8b/71/LlHcEe3v_o.png" width="802"></p> 
<hr> 
<p><strong>结果：</strong></p> 
<p><img alt="" height="146" src="https://images2.imgbox.com/34/67/rBsCuPU0_o.png" width="441"></p> 
<pre><code class="language-cpp">//申请空间
BT* koj(data x)
{
	//申请节点
	BT* tab = (BT*)malloc(sizeof(BT));
	if (tab == NULL)
	{
		perror("malloic");
		exit(1);
	}
	tab-&gt;arr = x;
	tab-&gt;zuo= tab-&gt;you = NULL;

	return tab;
}
void p()
{
	//创建节点
	BT* n1 = koj(1);
	BT* n2 = koj(2);
	BT* n3 = koj(3);
	BT* n4 = koj(4);

	//进行连接
	n1-&gt;zuo = n2;
	n1-&gt;you = n3;
	n2-&gt;zuo = n4;
	
	qian(n1);
	printf("\n");




}



int main()
{
	p();
	return 0;
}</code></pre> 
<hr> 
<h6 id="%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A"><strong>中序遍历：</strong></h6> 
<p>访问顺序为：<span style="color:#fe2c24;"><strong>左⼦树、根结点、右⼦树</strong></span><br><img alt="" height="323" src="https://images2.imgbox.com/8c/c6/k5odUydo_o.png" width="361"></p> 
<pre><code class="language-cpp">//中序遍历-（左-根-右）
void zho(BT* root)
{
	if (root == NULL)
	{
		return;
	}
	//左子树
	zho(root-&gt;zuo);
	printf("%d ", root-&gt;arr);
	//右子树
	zho(root-&gt;you);
}</code></pre> 
<hr> 
<p><img alt="" height="496" src="https://images2.imgbox.com/07/a4/v2HDTtBw_o.png" width="705"></p> 
<hr> 
<p><img alt="" height="728" src="https://images2.imgbox.com/a7/ca/Rr5gX0Vb_o.png" width="774"></p> 
<hr> 
<p><strong>结果：</strong></p> 
<p><img alt="" height="190" src="https://images2.imgbox.com/b0/8c/pSjygf37_o.png" width="330"></p> 
<pre><code class="language-cpp">//申请空间
BT* koj(data x)
{
	//申请节点
	BT* tab = (BT*)malloc(sizeof(BT));
	if (tab == NULL)
	{
		perror("malloic");
		exit(1);
	}
	tab-&gt;arr = x;
	tab-&gt;zuo= tab-&gt;you = NULL;

	return tab;
}
void p()
{
	//创建节点
	BT* n1 = koj(1);
	BT* n2 = koj(2);
	BT* n3 = koj(3);
	BT* n4 = koj(4);
	//进行连接
	n1-&gt;zuo = n2;
	n1-&gt;you = n3;
	n2-&gt;zuo = n4;

	/*qian(n1);
	printf("\n");*/

	zho(n1);
	printf("\n");

}



int main()
{
	p();
	return 0;
}</code></pre> 
<hr> 
<h6 id="%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A">后序遍历：</h6> 
<p>访问顺序为：<span style="color:#fe2c24;"><strong>左⼦树、右⼦树、根结点</strong></span></p> 
<p><img alt="" height="316" src="https://images2.imgbox.com/51/87/LzYQK5Xa_o.png" width="321"></p> 
<pre><code class="language-cpp">//后序遍历
void ho(BT* root)
{
	if (root == NULL)
	{
		return;
	}
	//左子树
	ho(root-&gt;zuo);
	//右子树
	ho(root-&gt;you);
	printf("%d ", root-&gt;arr);
}</code></pre> 
<hr> 
<p><img alt="" height="485" src="https://images2.imgbox.com/41/73/gEK1Bj9J_o.png" width="611"></p> 
<hr> 
<p><img alt="" height="723" src="https://images2.imgbox.com/f4/82/3koiYxRa_o.png" width="1132"></p> 
<hr> 
<p><strong>结果：</strong></p> 
<p><img alt="" height="50" src="https://images2.imgbox.com/7f/b9/pdotujll_o.png" width="200"></p> 
<pre><code class="language-cpp">//申请空间
BT* koj(data x)
{
	//申请节点
	BT* tab = (BT*)malloc(sizeof(BT));
	if (tab == NULL)
	{
		perror("malloic");
		exit(1);
	}
	tab-&gt;arr = x;
	tab-&gt;zuo= tab-&gt;you = NULL;

	return tab;
}
void p()
{
	//创建节点
	BT* n1 = koj(1);
	BT* n2 = koj(2);
	BT* n3 = koj(3);
	BT* n4 = koj(4);

	//进行连接
	n1-&gt;zuo = n2;
	n1-&gt;you = n3;
	n2-&gt;zuo = n4;
	
	/*qian(n1);
	printf("\n");*/

	/*zho(n1);
	printf("\n");*/

	ho(n1);

}



int main()
{
	p();
	return 0;
}</code></pre> 
<hr> 
<h6 id="%E5%9B%BE%E8%A7%A3%E9%81%8D%E5%8E%86%EF%BC%9A">图解遍历：</h6> 
<blockquote> 
 <p><span style="color:#fe2c24;">以前序遍历为例：</span></p> 
</blockquote> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/6d/a5/IzVPb6zf_o.png" width="1200"></p> 
<hr> 
<h6 id="%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92%E6%A0%88%E5%B8%A7%E5%9B%BE%EF%BC%9A">函数递归栈帧图：</h6> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/8a/fb/lvkEGdtl_o.png" width="1200"></p> 
<hr> 
<blockquote> 
 <p>前序遍历结果：<span style="color:#fe2c24;"><strong>123456</strong></span></p> 
 <p>中序遍历结果：<span style="color:#fe2c24;"><strong>321546</strong></span></p> 
 <p>后序遍历结果：<span style="color:#fe2c24;"><strong>315641</strong></span></p> 
</blockquote> 
<hr> 
<h5 id="%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0%E4%BB%A5%E5%8F%8A%E9%AB%98%E5%BA%A6%E7%AD%89">结点个数以及高度等</h5> 
<h6 id="%E3%80%90%E2%BC%86%E5%8F%89%E6%A0%91%E3%80%91%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0">【⼆叉树】结点个数</h6> 
<p><img alt="" height="243" src="https://images2.imgbox.com/ec/d1/P6mfNTsy_o.png" width="640"></p> 
<pre><code class="language-cpp">// ⼆叉树结点个数 
int BinaryTreeSize(BT* root)
{
	if (root == NULL)
	{
		return 0;
	}
	//                左子树                     右子树
	return 1+ BinaryTreeSize(root-&gt;zuo)+ BinaryTreeSize(root-&gt;you);
}
</code></pre> 
<hr> 
<p><img alt="" height="431" src="https://images2.imgbox.com/71/12/YgDsasLt_o.png" width="589"></p> 
<hr> 
<p><img alt="" height="670" src="https://images2.imgbox.com/a5/ba/MqLrCLgY_o.png" width="1200"></p> 
<hr> 
<p><strong>结果：</strong></p> 
<p><img alt="" height="117" src="https://images2.imgbox.com/ce/69/yHQ8nmeK_o.png" width="733"></p> 
<pre><code class="language-cpp">//申请空间
BT* koj(data x)
{
	//申请节点
	BT* tab = (BT*)malloc(sizeof(BT));
	if (tab == NULL)
	{
		perror("malloic");
		exit(1);
	}
	tab-&gt;arr = x;
	tab-&gt;zuo= tab-&gt;you = NULL;

	return tab;
}
void p()
{
	//创建节点
	BT* n1 = koj(1);
	BT* n2 = koj(2);
	BT* n3 = koj(3);
	BT* n4 = koj(4);

	//进行连接
	n1-&gt;zuo = n2;
	n1-&gt;you = n3;
	n2-&gt;zuo = n4;

	/*qian(n1);
	printf("\n");*/

	/*zho(n1);
	printf("\n");*/

	//ho(n1);
	// ⼆叉树结点个数 
	printf("size:%d \n", BinaryTreeSize(n1));


}



int main()
{
	p();
	return 0;
}</code></pre> 
<hr> 
<h6 id="%E3%80%90%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0">【二叉树】叶子节点个数</h6> 
<p><img alt="" height="357" src="https://images2.imgbox.com/b3/3f/p5J6eWkB_o.png" width="820"></p> 
<pre><code class="language-cpp">// ⼆叉树叶⼦结点个数 
int BinaryTreeLeafSize(BT* root)
{
	if (root == NULL)
	{
		return 0;
	}
	//左子树和右子树都等于空，就是叶子节点
	if (BinaryTreeLeafSize(root-&gt;zuo) == NULL &amp;&amp; BinaryTreeLeafSize(root-&gt;you) == NULL)
	{
		return 1;
	}
	return BinaryTreeLeafSize(root-&gt;zuo) + BinaryTreeLeafSize(root-&gt;you);
}</code></pre> 
<hr> 
<p><img alt="" height="286" src="https://images2.imgbox.com/37/78/4ndzlOOt_o.png" width="400"></p> 
<hr> 
<p><img alt="" height="823" src="https://images2.imgbox.com/de/c4/j4Vkr0cM_o.png" width="1200"></p> 
<hr> 
<p><strong>结果：</strong></p> 
<p><img alt="" height="139" src="https://images2.imgbox.com/98/85/jQUEJ7Py_o.png" width="696"></p> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1
#include"Tree.h"
//申请空间
BT* koj(data x)
{
	//申请节点
	BT* tab = (BT*)malloc(sizeof(BT));
	if (tab == NULL)
	{
		perror("malloic");
		exit(1);
	}
	tab-&gt;arr = x;
	tab-&gt;zuo= tab-&gt;you = NULL;

	return tab;
}
void p()
{
	//创建节点
	BT* n1 = koj(1);
	BT* n2 = koj(2);
	BT* n3 = koj(3);
	BT* n4 = koj(4);


	//进行连接
	n1-&gt;zuo = n2;
	n1-&gt;you = n3;
	n2-&gt;zuo = n4;

	
	/*qian(n1);
	printf("\n");*/

	/*zho(n1);
	printf("\n");*/

	//ho(n1);
	// ⼆叉树结点个数 
	//printf("size:%d \n", BinaryTreeSize(n1));

	//叶子节点个数
	printf("叶子节点：%d\n", BinaryTreeLeafSize(n1));



}



int main()
{
	p();
	return 0;
}</code></pre> 
<hr> 
<h6 id="%E3%80%90%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91%E7%AC%ACk%E5%B1%82%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0">【二叉树】第k层节点个数</h6> 
<p><img alt="" height="352" src="https://images2.imgbox.com/19/f7/Wo37n2Id_o.png" width="883"></p> 
<pre><code class="language-cpp">// ⼆叉树第k层结点个数 
int BinaryTreeLevelKSize(BT* root, int k)
{
	if (root == NULL)
	{
		return 0;
	}
	//k等于1了就返回1
	if (k == 1)
	{
		return 1;
	}
	return BinaryTreeLevelKSize(root-&gt;zuo, k - 1) + BinaryTreeLevelKSize(root-&gt;you, k - 1);
}</code></pre> 
<hr> 
<p><img alt="" height="722" src="https://images2.imgbox.com/d5/f5/R0tQIpbu_o.png" width="717"></p> 
<hr> 
<p><img alt="" height="716" src="https://images2.imgbox.com/2e/6c/WfyTaCdg_o.png" width="1200"></p> 
<hr> 
<p><strong>结果：</strong></p> 
<p><span style="color:#fe2c24;"><strong>这里加了2个节点5和6，就和上面那张图一样了。</strong></span></p> 
<p><img alt="" height="645" src="https://images2.imgbox.com/8a/db/f6Tes0z3_o.png" width="855"></p> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1
#include"Tree.h"
//申请空间
BT* koj(data x)
{
	//申请节点
	BT* tab = (BT*)malloc(sizeof(BT));
	if (tab == NULL)
	{
		perror("malloic");
		exit(1);
	}
	tab-&gt;arr = x;
	tab-&gt;zuo= tab-&gt;you = NULL;

	return tab;
}
void p()
{
	//创建节点
	BT* n1 = koj(1);
	BT* n2 = koj(2);
	BT* n3 = koj(3);
	BT* n4 = koj(4);

	//进行连接
	n1-&gt;zuo = n2;
	n1-&gt;you = n3;
	n2-&gt;zuo = n4;
	
	/*qian(n1);
	printf("\n");*/

	/*zho(n1);
	printf("\n");*/

	//ho(n1);
	// ⼆叉树结点个数 
	//printf("size:%d \n", BinaryTreeSize(n1));

	// 
	叶子节点个数
	//printf("叶子节点：%d\n", BinaryTreeLeafSize(n1));
	//k层节点个数
	printf("k: %d \n", BinaryTreeLevelKSize(n1, 3));


}



int main()
{
	p();
	return 0;
}</code></pre> 
<hr> 
<h6 id="%E3%80%90%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91%E7%9A%84%E6%B7%B1%E5%BA%A6%2F%E2%BE%BC%E5%BA%A6">【二叉树】的深度/⾼度</h6> 
<p><img alt="" height="351" src="https://images2.imgbox.com/32/b8/TpFqwze3_o.png" width="436"></p> 
<pre><code class="language-cpp">//⼆叉树的深度/⾼度
int BinaryTreeDepth(BT* root)
{
	if (root == NULL)
	{
		return 0;
	}
	//遍历左子树，把值给zuo
	int zuo = BinaryTreeDepth(root-&gt;zuo);
	//遍历右子树,把值给you
	int you = BinaryTreeDepth(root-&gt;you);
	//进行判断
	return zuo &gt; you ? zuo + 1:you + 1;
}</code></pre> 
<hr> 
<p><img alt="" height="530" src="https://images2.imgbox.com/b7/89/rcRtT2vs_o.png" width="706"></p> 
<hr> 
<p><img alt="" height="778" src="https://images2.imgbox.com/bd/f5/gxT0V6Pk_o.png" width="1200"></p> 
<hr> 
<p><strong>结果：</strong></p> 
<p><img alt="" height="226" src="https://images2.imgbox.com/72/df/jjwriJ5q_o.png" width="683"></p> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1
#include"Tree.h"
//申请空间
BT* koj(data x)
{
	//申请节点
	BT* tab = (BT*)malloc(sizeof(BT));
	if (tab == NULL)
	{
		perror("malloic");
		exit(1);
	}
	tab-&gt;arr = x;
	tab-&gt;zuo= tab-&gt;you = NULL;

	return tab;
}
void p()
{
	//创建节点
	BT* n1 = koj(1);
	BT* n2 = koj(2);
	BT* n3 = koj(3);
	BT* n4 = koj(4);

	//进行连接
	n1-&gt;zuo = n2;
	n1-&gt;you = n3;
	n2-&gt;zuo = n4;

	
	/*qian(n1);
	printf("\n");*/

	/*zho(n1);
	printf("\n");*/

	//ho(n1);
	// ⼆叉树结点个数 
	//printf("size:%d \n", BinaryTreeSize(n1));

	// 
	叶子节点个数
	//printf("叶子节点：%d\n", BinaryTreeLeafSize(n1));
	k层节点个数
	//printf("k: %d \n", BinaryTreeLevelKSize(n1, 3));

	//⼆叉树的深度/⾼度
	printf("高度:%d \n", BinaryTreeDepth(n1));

}



int main()
{
	p();
	return 0;
}</code></pre> 
<hr> 
<h6 id="%E3%80%90%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91%E6%9F%A5%E6%89%BE%E5%80%BC%E4%B8%BAx%E7%9A%84%E7%BB%93%E7%82%B9%C2%A0">【二叉树】查找值为x的结点 </h6> 
<p><img alt="" height="625" src="https://images2.imgbox.com/6b/54/s0Oaxh2I_o.png" width="442"></p> 
<pre><code class="language-cpp">// ⼆叉树查找值为x的结点 
BT* BinaryTreeFind(BT* root, data x)
{
	if (root == NULL)
	{
		return NULL;
	}
	//等于x，返回当前节点
	if (root-&gt;arr == x)
	{
		return root;
	}
	//zuo接收节点
	BT* zuo = BinaryTreeFind(root-&gt;zuo, x);
	if (zuo)
	{
		//返回节点
		return zuo;
	}
	//you接收节点
	BT* you = BinaryTreeFind(root-&gt;you, x);
	if (you)
	{
		//返回节点
		return you;
	}
}</code></pre> 
<hr> 
<p><img alt="" height="436" src="https://images2.imgbox.com/35/c6/b7bjtiMY_o.png" width="537"></p> 
<hr> 
<p><span style="color:#fe2c24;"><strong>左子树找不到，就找右子树</strong></span></p> 
<p><img alt="" height="1046" src="https://images2.imgbox.com/33/ed/f2SPjUTj_o.png" width="773"></p> 
<hr> 
<p><strong>结果：</strong></p> 
<p><img alt="" height="245" src="https://images2.imgbox.com/3b/29/eQZ4JW7B_o.png" width="752"></p> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1
#include"Tree.h"
//申请空间
BT* koj(data x)
{
	//申请节点
	BT* tab = (BT*)malloc(sizeof(BT));
	if (tab == NULL)
	{
		perror("malloic");
		exit(1);
	}
	tab-&gt;arr = x;
	tab-&gt;zuo= tab-&gt;you = NULL;

	return tab;
}
void p()
{
	//创建节点
	BT* n1 = koj(1);
	BT* n2 = koj(2);
	BT* n3 = koj(3);
	BT* n4 = koj(4);

	//BT* n5 = koj(5);
	//BT* n6 = koj(6);
	//进行连接
	n1-&gt;zuo = n2;
	n1-&gt;you = n3;
	n2-&gt;zuo = n4;

	//n2-&gt;you = n5;
	//n3-&gt;zuo = n6;
	
	/*qian(n1);
	printf("\n");*/

	/*zho(n1);
	printf("\n");*/

	//ho(n1);
	// ⼆叉树结点个数 
	//printf("size:%d \n", BinaryTreeSize(n1));

	// 
	叶子节点个数
	//printf("叶子节点：%d\n", BinaryTreeLeafSize(n1));
	k层节点个数
	//printf("k: %d \n", BinaryTreeLevelKSize(n1, 3));

	⼆叉树的深度/⾼度
	//printf("高度:%d \n", BinaryTreeDepth(n1));

	// ⼆叉树查找值为x的结点 
	BT* tab = BinaryTreeFind(n1, 4);
	printf("%s\n", tab == NULL ? "没找到" : "找到了");


}



int main()
{
	p();
	return 0;
}</code></pre> 
<hr> 
<h6 id="%E3%80%90%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91%E9%94%80%E6%AF%81">【二叉树】销毁</h6> 
<p><img alt="" height="341" src="https://images2.imgbox.com/0c/72/vTnjRh8D_o.png" width="398"></p> 
<hr> 
<p></p> 
<p><img alt="" height="255" src="https://images2.imgbox.com/8a/54/gQnTnlub_o.png" width="329"></p> 
<hr> 
<pre><code class="language-cpp">// ⼆叉树销毁
void BinaryTreeDestory(BT** root)
{
	if (*root == NULL)
	{
		return;
	}
	//二级指针，需要传一级指针地址
	BinaryTreeDestory(&amp;(*root)-&gt;zuo);
	BinaryTreeDestory(&amp;(*root)-&gt;you);
	//释放空间
	free(*root);
	*root = NULL;
}
</code></pre> 
<hr> 
<p><strong>图解析：</strong></p> 
<p><img alt="" height="962" src="https://images2.imgbox.com/b9/20/jFjOFzIF_o.png" width="1200"></p> 
<hr> 
<p><strong>结果：</strong></p> 
<p>我们可以看到全部销毁了。</p> 
<p><img alt="" height="347" src="https://images2.imgbox.com/e4/2c/t9FWmuGl_o.png" width="856"></p> 
<hr> 
<h5 id="%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">层序遍历</h5> 
<blockquote> 
 <p>除了先序遍历、中序遍历、后序遍历外，还可以对⼆叉树进⾏层序遍历。设⼆叉树的根结点所在层数 为1，层序遍历就是从所在⼆叉树的根结点出发，⾸先访问第⼀层的树根结点，然后从左到右访问第2 层上的结点，接着是第三层的结点，以此类推，⾃上⽽下，⾃左⾄右逐层访问树的结点的过程就是层 序遍历</p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>实现层序遍历需要额外借助数据结构：队列</strong></span></p> 
<p><img alt="" height="494" src="https://images2.imgbox.com/6a/6c/XubV8unH_o.png" width="923"></p> 
<hr> 
<p><span style="color:#fe2c24;"><strong>创建队列，初始化，把根节点入队列</strong></span></p> 
<p><span style="color:#1c7331;"><strong>循环队列不为空，取队头打印，出队头。</strong></span></p> 
<p><strong><span style="color:#1c7331;">然后判断左子树和右子树，是不是空，不是空就入队列。</span></strong></p> 
<p><strong>销毁队列。</strong></p> 
<p><img alt="" height="718" src="https://images2.imgbox.com/f5/34/O9FS42wO_o.png" width="527"></p> 
<pre><code class="language-cpp">//层序遍历
//借助数据结构--队列
void LevelOrder(BT* root)
{
	Queue add;
	//初始化
	Queuecsh(&amp;add);
	//入数据
	Queue_ruwei(&amp;add, root);

	while (!buer(&amp;add))
	{
		//取队头-打印
		BT* tab = qto(&amp;add);
		printf("%d ", tab-&gt;arr);
		//出队
		Queue_chu(&amp;add);
		//判断是不是空， 队头节点的左右孩子入，队列
		if (tab-&gt;zuo)
		{
			Queue_ruwei(&amp;add, tab-&gt;zuo);
		}
		if (tab-&gt;you)
		{
			Queue_ruwei(&amp;add, tab-&gt;you);
		}
	}

	//队列销毁
	Queuexiaoh(&amp;add);
}
</code></pre> 
<hr> 
<p>结果：</p> 
<p><img alt="" height="49" src="https://images2.imgbox.com/3b/0e/s8MNsulK_o.png" width="311"></p> 
<hr> 
<h5 id="%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91" style="background-color:transparent;">判断是否为完全二叉树</h5> 
<p></p> 
<p><img alt="" height="532" src="https://images2.imgbox.com/f8/70/rorZlPtw_o.png" width="617"></p> 
<hr> 
<blockquote> 
 <strong>注意：</strong> 
 <p><span style="color:#fe2c24;"><strong>如果是完全二叉树，跳出循环之后队列里都是NULL。</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>如果不是完全二叉树，跳出循环之后队列里，还有非空节点。</strong></span></p> 
</blockquote> 
<p><strong>思路：</strong></p> 
<p><span style="color:#fe2c24;"><strong>创建一个队列，把根节点入队列，循环队列里不为空。</strong></span></p> 
<p><span style="color:#1a439c;"><strong>取队头节点，然后出队，判断这个节点是不是空，是空跳出循环。</strong></span></p> 
<p><span style="color:#1a439c;"><strong>不是空，左子树和右子树入队列。</strong></span></p> 
<p><span style="color:#1c7331;"><strong>是完全二叉树的话剩下的都是空，</strong></span></p> 
<p><span style="color:#1c7331;"><strong>循环取出队头数据，出队，进行判断，不等于空的话还有非空节点，那就是不完全二叉树了，返回false。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>最后循环都为空，是完全二叉树，返回true。</strong></span></p> 
<p><img alt="" height="394" src="https://images2.imgbox.com/fe/b4/K9r1cQke_o.png" width="782"></p> 
<hr> 
<p><img alt="" height="1064" src="https://images2.imgbox.com/26/b9/HDipDwlR_o.png" width="642"></p> 
<pre><code class="language-cpp">bool pdercs(BT* root)
{
	Queue add;
	//队列初始化
	Queuecsh(&amp;add);
	//入队列
	Queue_ruwei(&amp;add, root);
	while (!buer(&amp;add))
	{
		//取队头数据
		BT* tab =  qto(&amp;add);
		//出队
		Queue_chu(&amp;add);
		if (tab == NULL)
		{
			//等于空结束循环
			break;
		}//不为空让左右子树入队列

		//左子树_入队列
		Queue_ruwei(&amp;add, tab-&gt;zuo);
		//右子树_入队列
		Queue_ruwei(&amp;add, tab-&gt;you);
	}
	//循环判断队列，有一个数值不是完全二叉树，都是NULL就是完全二叉树
	while (!buer(&amp;add))
	{
		//取队头
		BT* app = qto(&amp;add);
		//出队
		Queue_chu(&amp;add);
		//判断如果还有非空节点，返回false
		if (app != NULL)
		{
			Queuexiaoh(&amp;add);
			return false;
		}
	}//循环完，说明队列里都是NULL,是完全二叉树，返回true

	//队列销毁
	Queuexiaoh(&amp;add);
	return true;
}</code></pre> 
<hr> 
<p><strong>结果：</strong></p> 
<p><img alt="" height="73" src="https://images2.imgbox.com/2d/9f/AbFfOBiD_o.png" width="781"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c530826419b3045dc1b02379609797e2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">fastapi 学习</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6619258e951e622d12fbab68e1892e95/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C&#43;&#43;从小白到大牛】C&#43;&#43;智能指针的使用、原理和分类</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>