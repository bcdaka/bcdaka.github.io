<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>前端 a链接 如何实现下载功能 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/d587c917f57656bd49d4b6e8433ee30c/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="前端 a链接 如何实现下载功能">
  <meta property="og:description" content="目录
前言
标签 download
a 标签链接下载的实现
1. 整体流程
2. 实现步骤
3. 类图
4. 代码示例 download 使用注意点
1. 同源 URL 的限制
2. 不能携带 Header
Blob 转换
方法1. 用作 URL（blob:）
方法2. 转换为 base64（data:）
两种方法总结与对比
responseType
扩展阅读
1. Blob
2. URL.createObjectURL()
3. URL.revokeObjectURL()
4. FileReader.readAsDataURL()
前言 在中后台项目中，前端难免需要处理下载的逻辑，需要下载的内容包括但不限于图片、Excel表格、CSV文件、MP4文件、PDF文件、TXT文件、JSON文件、HTML文件等等。虽然下载的内容各式各样，但是下载的原理大同小异。下面来一起学习一下前端是如何处理下载的。
&lt;a&gt; 标签 download 这应该是最常见，最受广大人民群众喜闻乐见的一种下载方式了，搭配上 download 属性， 就能让浏览器将链接的 URL 视为下载资源，而不是导航到该资源。
如果 download 再指定个 filename ，那么就可以在下载文件时，将其作为预填充的文件名。不过名字中的 / 和 \ 会被转化为下划线 _，而且文件系统可能会阻止文件名中的一些字符，因此浏览器会在必要时适当调整文件名。
a 标签链接下载的实现 1. 整体流程 为了实现通过a标签链接下载文件，我们需要对a标签的href属性进行设置，使其指向文件的下载链接。具体步骤如下表所示：
下面我们将逐步介绍每个步骤需要做的事情，并提供相应的代码和注释。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-11-11T09:19:31+08:00">
    <meta property="article:modified_time" content="2023-11-11T09:19:31+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前端 a链接 如何实现下载功能</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="h_450942203_0-toc" style="margin-left:0px;"><a href="#h_450942203_0" rel="nofollow">前言</a></p> 
<p id="%3Ca%3E%20%E6%A0%87%E7%AD%BE%20download-toc" style="margin-left:0px;"> 标签 download</p> 
<p id="a%20%E6%A0%87%E7%AD%BE%E9%93%BE%E6%8E%A5%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#a%20%E6%A0%87%E7%AD%BE%E9%93%BE%E6%8E%A5%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">a 标签链接下载的实现</a></p> 
<p id="1.%20%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B-toc" style="margin-left:40px;"><a href="#1.%20%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B" rel="nofollow">1. 整体流程</a></p> 
<p id="2.%20%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4-toc" style="margin-left:40px;"><a href="#2.%20%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4" rel="nofollow">2. 实现步骤</a></p> 
<p id="3.%20%E7%B1%BB%E5%9B%BE-toc" style="margin-left:40px;"><a href="#3.%20%E7%B1%BB%E5%9B%BE" rel="nofollow">3. 类图</a></p> 
<p id="4.%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%C2%A0-toc" style="margin-left:40px;"><a href="#4.%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%C2%A0" rel="nofollow">4. 代码示例 </a></p> 
<p id="download%20%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9-toc" style="margin-left:0px;"><a href="#download%20%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9" rel="nofollow">download 使用注意点</a></p> 
<p id="1.%20%E5%90%8C%E6%BA%90%20URL%20%E7%9A%84%E9%99%90%E5%88%B6-toc" style="margin-left:40px;"><a href="#1.%20%E5%90%8C%E6%BA%90%20URL%20%E7%9A%84%E9%99%90%E5%88%B6" rel="nofollow">1. 同源 URL 的限制</a></p> 
<p id="2.%20%E4%B8%8D%E8%83%BD%E6%90%BA%E5%B8%A6%20Header-toc" style="margin-left:40px;"><a href="#2.%20%E4%B8%8D%E8%83%BD%E6%90%BA%E5%B8%A6%20Header" rel="nofollow">2. 不能携带 Header</a></p> 
<p id="Blob%20%E8%BD%AC%E6%8D%A2-toc" style="margin-left:0px;"><a href="#Blob%20%E8%BD%AC%E6%8D%A2" rel="nofollow">Blob 转换</a></p> 
<p id="%E6%96%B9%E6%B3%951.%20%E7%94%A8%E4%BD%9C%20URL%EF%BC%88blob%3A%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E6%96%B9%E6%B3%951.%20%E7%94%A8%E4%BD%9C%20URL%EF%BC%88blob%3A%EF%BC%89" rel="nofollow">方法1. 用作 URL（blob:）</a></p> 
<p id="%E6%96%B9%E6%B3%952.%20%E8%BD%AC%E6%8D%A2%E4%B8%BA%20base64%EF%BC%88data%3A%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E6%96%B9%E6%B3%952.%20%E8%BD%AC%E6%8D%A2%E4%B8%BA%20base64%EF%BC%88data%3A%EF%BC%89" rel="nofollow">方法2. 转换为 base64（data:）</a></p> 
<p id="%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AF%B9%E6%AF%94-toc" style="margin-left:40px;"><a href="#%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AF%B9%E6%AF%94" rel="nofollow">两种方法总结与对比</a></p> 
<p id="responseType-toc" style="margin-left:40px;"><a href="#responseType" rel="nofollow">responseType</a></p> 
<p id="%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-toc" style="margin-left:0px;"><a href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB" rel="nofollow">扩展阅读</a></p> 
<p id="1.%20Blob-toc" style="margin-left:40px;"><a href="#1.%20Blob" rel="nofollow">1. Blob</a></p> 
<p id="2.%20URL.createObjectURL()-toc" style="margin-left:40px;"><a href="#2.%20URL.createObjectURL%28%29" rel="nofollow">2. URL.createObjectURL()</a></p> 
<p id="3.%20URL.revokeObjectURL()-toc" style="margin-left:40px;"><a href="#3.%20URL.revokeObjectURL%28%29" rel="nofollow">3. URL.revokeObjectURL()</a></p> 
<p id="4.%20FileReader.readAsDataURL()-toc" style="margin-left:40px;"><a href="#4.%20FileReader.readAsDataURL%28%29" rel="nofollow">4. FileReader.readAsDataURL()</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="h_450942203_0">前言</h2> 
<p>在中后台项目中，前端难免需要处理下载的逻辑，需要下载的内容包括但不限于图片、Excel表格、CSV文件、MP4文件、PDF文件、TXT文件、JSON文件、HTML文件等等。虽然下载的内容各式各样，但是下载的原理大同小异。下面来一起学习一下前端是如何处理下载的。</p> 
<h2 id="%3Ca%3E%20%E6%A0%87%E7%AD%BE%20download">&lt;a&gt; 标签 download</h2> 
<p>这应该是最常见，最受广大人民群众喜闻乐见的一种下载方式了，搭配上 download 属性， 就能让浏览器将链接的 URL 视为下载资源，而不是导航到该资源。</p> 
<p>如果 download 再指定个 filename ，那么就可以在下载文件时，将其作为预填充的文件名。不过名字中的 / 和 \ 会被转化为下划线 _，而且文件系统可能会阻止文件名中的一些字符，因此浏览器会在必要时适当调整文件名。</p> 
<h2 id="a%20%E6%A0%87%E7%AD%BE%E9%93%BE%E6%8E%A5%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%AE%9E%E7%8E%B0">a 标签链接下载的实现</h2> 
<h3 id="1.%20%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B">1. 整体流程</h3> 
<p>为了实现通过a标签链接下载文件，我们需要对a标签的href属性进行设置，使其指向文件的下载链接。具体步骤如下表所示：</p> 
<p><img alt="" height="294" src="https://images2.imgbox.com/cc/50/XWaSdYyE_o.png" width="1200"></p> 
<p>下面我们将逐步介绍每个步骤需要做的事情，并提供相应的代码和注释。</p> 
<h3 id="2.%20%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><strong>2. 实现步骤</strong></h3> 
<p><strong>步骤1：创建一个a标签元素</strong><br> 首先，我们需要使用document.createElement方法创建一个a标签元素，并将其赋值给一个变量，以便后续操作。</p> 
<pre><code>// 创建一个a标签元素
const downloadLink = document.createElement('a');</code></pre> 
<p><strong>步骤2：设置a标签的href属性为文件的下载链接</strong><br> 接下来，我们需要将下载链接赋值给a标签的href属性，以便浏览器能够正确地下载文件。</p> 
<pre><code>// 设置a标签的href属性为下载链接
downloadLink.href = ''</code></pre> 
<p><strong>步骤3：设置a标签的download属性，用于指定下载链接的默认文件名</strong></p> 
<p>如果我们想要指定下载链接的默认文件名，可以使用a标签的download属性。这样，当用户点击下载链接时，浏览器会自动将文件以指定的文件名保存到本地。</p> 
<pre><code>// 设置a标签的download属性为文件名
downloadLink.download = 'file.pdf'</code></pre> 
<p><strong>步骤4：将a标签添加到HTML文档中</strong></p> 
<p>我们需要将创建的a标签元素添加到HTML文档中的某个元素中，以便用户能够看到下载链接并进行下载操作。</p> 
<pre><code>// 将a标签添加到HTML文档中的某个元素中
document.body.appendChild(downloadLink);</code></pre> 
<p><strong>步骤5：触发a标签的点击事件，即模拟用户点击下载链接</strong></p> 
<p>为了触发文件的下载，我们需要模拟用户点击a标签的行为。可以使用click方法来触发a标签的点击事件。</p> 
<pre><code>// 触发a标签的点击事件，即模拟用户点击下载链接
downloadLink.click();</code></pre> 
<p><strong>步骤6：完成文件下载</strong></p> 
<p>通过以上步骤，我们已经成功地实现了通过a标签链接下载文件的功能。用户点击下载链接后，浏览器会自动下载文件到本地。</p> 
<h3 id="3.%20%E7%B1%BB%E5%9B%BE">3. 类图</h3> 
<p>下面是本文所涉及的类的关系示意图：</p> 
<p><img alt="" height="442" src="https://images2.imgbox.com/18/4d/iWaWPhIk_o.png" width="703"></p> 
<h3 id="4.%20%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%C2%A0">4. 代码示例 </h3> 
<pre><code>// 创建一个a标签元素
const downloadLink = document.createElement('a');

// 设置a标签的href属性为下载链接
downloadLink.href = '

// 设置a标签的download属性为文件名
downloadLink.download = 'file.pdf';

// 将a标签添加到HTML文档中的某个元素中
document.body.appendChild(downloadLink);

// 触发a标签的点击事件，即模拟用户点击下载链接
downloadLink.click();
</code></pre> 
<h2 id="download%20%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9">download 使用注意点</h2> 
<p>&lt;a&gt; 标签虽好，但还有一些值得注意的点：</p> 
<h3 id="1.%20%E5%90%8C%E6%BA%90%20URL%20%E7%9A%84%E9%99%90%E5%88%B6">1. 同源 URL 的限制</h3> 
<blockquote>
  download 只在同源 URL 或 blob: 、 data: 协议起作用 
</blockquote> 
<p>也就是说跨域是下载不了的......（这种说法不全对，除非后端配置 Content-Disposition 为 attachment，后面会讲）</p> 
<p>首先，非同源 URL 会进行导航操作。其次，如果非要下载，可以先将其转换为 blob: 或 data: 再进行下载</p> 
<h3 id="2.%20%E4%B8%8D%E8%83%BD%E6%90%BA%E5%B8%A6%20Header">2. 不能携带 Header</h3> 
<p>使用 &lt;a&gt; 标签下载是带不了 Header 的，因此不能通过添加请求表头的形式来鉴权，但是可以将 sessionid 或 token 字段拼接到 URL 末尾来达到鉴权的目的。这里我们给出另一个解决方案：</p> 
<ol><li>先发送请求获取 blob 文件流，这样就能在请求时进行鉴权；</li><li>鉴权通过后再执行下载操作。</li></ol> 
<p>这样是不是就能很好的同时解决问题1和问题2带来的两个痛点了呢，而且下载的文件名也能自定义了</p> 
<p>顺便提一下，location.href 和 window.open 也存在同样的问题。</p> 
<h2 id="Blob%20%E8%BD%AC%E6%8D%A2">Blob 转换</h2> 
<p>前文介绍到，在非同源请情况下可以将资源当成二进制的 blob 先拿到手，再进行 &lt;a&gt; 的下载处理。接下来，我们介绍两种 blob 的操作：</p> 
<h3 id="%E6%96%B9%E6%B3%951.%20%E7%94%A8%E4%BD%9C%20URL%EF%BC%88blob%3A%EF%BC%89">方法1. 用作 URL（blob:）</h3> 
<p>URL.createObjectURL 可以给 File 或 Blob 生成一个URL，形式为 blob:&lt;origin&gt;/&lt;uuid&gt;，此时浏览器内部就会为每个这样的 URL 存储一个 URL → Blob 的映射。因此，此类 URL 很短，但可以访问 Blob。</p> 
<pre><code>   // 下载 Excel 方法
  excel(data, fileName) {
    this.download0(data, fileName, "application/vnd.ms-excel");
  },


  // 下载 Word 方法
  word(data, fileName) {
    this.download0(data, fileName, "application/msword");
  },

  // 下载 Zip 方法
  zip(data, fileName) {
    this.download0(data, fileName, "application/zip");
  },

  // 下载 Html 方法
  html(data, fileName) {
    this.download0(data, fileName, "text/html");
  },

  // 下载 Markdown 方法
  markdown(data, fileName) {
    this.download0(data, fileName, "text/markdown");
  },
download0(data, fileName, mineType) {
    // 创建 blob
    let blob = new Blob([data], { type: mineType });
    // 创建 href 超链接，点击进行下载
    window.URL = window.URL || window.webkitURL;
    let href = URL.createObjectURL(blob);
    let downA = document.createElement("a");
    downA.href = href;
    downA.download = fileName;
    downA.click();
    // 销毁超连接
    window.URL.revokeObjectURL(href);
  },</code></pre> 
<p>不过它有个副作用。虽然这里有 Blob 的映射，但 Blob 本身只保存在内存中的。浏览器无法释放它。</p> 
<p>在文档退出时（unload），该映射会被自动清除，因此 Blob 也相应被释放了。但是，如果应用程序寿命很长，那这个释放就不会很快发生。</p> 
<p><strong>因此，如果我们创建一个 URL，那么即使我们不再需要该 Blob 了，它也会被挂在内存中。</strong></p> 
<p>不过，URL.revokeObjectURL 可以从内部映射中移除引用，允许 Blob 被删除并释放内存。所以，在即时下载完资源后，不要忘记立即调用 URL.revokeObjectURL。</p> 
<h3 id="%E6%96%B9%E6%B3%952.%20%E8%BD%AC%E6%8D%A2%E4%B8%BA%20base64%EF%BC%88data%3A%EF%BC%89">方法2. 转换为 base64（data:）</h3> 
<p>作为 URL.createObjectURL 的一个替代方法，我们也可以将 Blob 转换为 base64-编码的字符串。这种编码将二进制数据表示为一个由 0 到 64 的 ASCII 码组成的字符串，非常安全且“可读”。</p> 
<p>更重要的是 —— 我们可以在 “data-url” 中使用此编码。“data-url” 的形式为 data:[&lt;mediatype&gt;][;base64],&lt;data&gt;。我们可以在任何地方使用这种 url，和使用“常规” url 一样。</p> 
<p>FileReader 是一个对象，其<strong>唯一目的</strong>就是从 Blob 对象中读取数据，我们可以使用它的 readAsDataURL 方法将 Blob 读取为 base64。请看以下示例：</p> 
<pre><code>let blob = new Blob([res.data]); // res.data是后台返回的文件
 
let reader = new FileReader();
reader.readAsDataURL(blob);
reader.onload = (e) =&gt; {
    // 转换完成，创建一个a标签用于下载
    let a = document.createElement('a');
    a.download = fileName;
    a.href = e.target.result;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}</code></pre> 
<p>在上述例子中，我们先实例化了一个 fileReader，用它来读取 blob。</p> 
<p>一旦读取完成，就可以从 fileReader 的 result 属性中拿到一个data: URL 格式的 Base64 字符串。</p> 
<p>最后，我们给 fileReader 注册了一个 onload 事件，在读取操作完成后开始下载。</p> 
<h3 id="%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AF%B9%E6%AF%94">两种方法总结与对比</h3> 
<p>URL.createObjectURL(blob) 可以直接访问，无需“编码/解码”，但需要记得撤销（revoke）；</p> 
<p>而 Data URL 无需撤销（revoke）任何操作，但对大的 Blob 进行编码时，性能和内存会有损耗。</p> 
<p>总而言之，这两种从 Blob 创建 URL 的方法都可以用。但通常 URL.createObjectURL(blob) 更简单快捷。</p> 
<h3 id="responseType">responseType</h3> 
<pre><code>export const fetchFile = async (params) =&gt; {
  return axios.get(api, {
    params,
    responseType: "blob"
  });
};</code></pre> 
<p>最后，我们回头说一下请求的注意点：如果你的项目使用的是 XHR （比如 axios）而不是 fetch， 那么请记得在请求时添加上 responseType 为 'blob'。</p> 
<p>responseType 不是 axios 中的属性，而是 XMLHttpRequest 中的属性，它用于指定响应中包含的数据类型，当为 "blob" 时，表明 Response 是一个包含二进制数据的 Blob 对象。</p> 
<p>除了 blob 之外，responseType 还有 arraybuffer、json、text等其他枚举字符串值。</p> 
<h2 id="%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB">扩展阅读</h2> 
<h3 id="1.%20Blob" style="background-color:transparent;"><strong>1. Blob</strong></h3> 
<p>Blob 全称为 binary large object ，即二进制大对象，它是 JavaScript 中的一个对象，表示原始的类似文件的数据。下面是 MDN 中对 Blob 的解释：</p> 
<blockquote>
  Blob 对象表示一个不可变、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取，也可以转换成  
 <strong><a href="https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream" rel="nofollow" title="ReadableStream">ReadableStream</a></strong> 来用于数据操作。 
</blockquote> 
<p>实际上，Blob 对象是包含有只读原始数据的类文件对象。简单来说，Blob 对象就是一个不可修改的二进制文件。</p> 
<p><strong>（1）Blob 创建</strong></p> 
<p>可以使用 Blob() 构造函数来创建一个 Blob：</p> 
<pre><code>new Blob(array, options);
</code></pre> 
<p>其有两个参数：</p> 
<ul><li><code>array</code>：由 <code>ArrayBuffer</code>、<code>ArrayBufferView</code>、<code>Blob</code>、<code>DOMString</code> 等对象构成的，将会被放进 <code>Blob</code>；</li><li><code>options</code>：可选的 <code>BlobPropertyBag</code> 字典，它可能会指定如下两个属性 
  <ul><li><code>type</code>：默认值为 ""，表示将会被放入到 <code>blob</code> 中的数组内容的 MIME 类型。</li><li><code>endings</code>：默认值为"<code>transparent</code>"，用于指定包含行结束符<code>\n</code>的字符串如何被写入，不常用。</li></ul></li></ul> 
<p>常见的 MIME 类型如下：</p> 
<p><img alt="" height="632" src="https://images2.imgbox.com/a7/f7/hzZRSSFJ_o.png" width="584"></p> 
<p>下面来看一个简单的例子：</p> 
<pre><code>const blob = new Blob(["Hello World"], {type: "text/plain"});</code></pre> 
<p> 这里可以成为动态文件创建，其正在创建一个类似文件的对象。这个 blob 对象上有两个属性：</p> 
<ul><li><code>size</code>：Blob对象中所包含数据的大小（字节）；</li><li><code>type</code>：字符串，认为该Blob对象所包含的 MIME 类型。如果类型未知，则为空字符串。</li></ul> 
<p>下面来看打印结果：</p> 
<pre><code>const blob = new Blob(["Hello World"], {type: "text/plain"});

console.log(blob.size); // 11
console.log(blob.type); // "text/plain"</code></pre> 
<p>注意，字符串"Hello World"是 UTF-8 编码的，因此它的每个字符占用 1 个字节。</p> 
<p>到现在，Blob 对象看起来似乎我们还是没有啥用。那该如何使用 Blob 对象呢？可以使用 URL.createObjectURL() 方法将将其转化为一个 URL，并在 Iframe 中加载：</p> 
<pre><code>&lt;iframe&gt;&lt;/iframe&gt;

const iframe = document.getElementsByTagName("iframe")[0];

const blob = new Blob(["Hello World"], {type: "text/plain"});

iframe.src = URL.createObjectURL(blob);</code></pre> 
<h3 id="2.%20URL.createObjectURL()" style="background-color:transparent;">2. URL.createObjectURL()</h3> 
<p><strong><code>URL.createObjectURL()</code></strong> 静态方法会创建一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String" rel="nofollow" title="DOMString">DOMString</a>，其中包含一个表示参数中给出的对象的 URL。这个 URL 的生命周期和创建它的窗口中的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document" rel="nofollow" title="document">document</a> 绑定。这个新的 URL 对象表示指定的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File" rel="nofollow" title="File">File</a> 对象或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" rel="nofollow" title="Blob">Blob</a> 对象。</p> 
<blockquote> 
 <p><strong>备注：</strong> 此特性在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API" rel="nofollow" title="Web Worker">Web Worker</a> 中可用</p> 
 <p><strong>备注：</strong> 此特性在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" rel="nofollow" title="Service Worker">Service Worker</a> 中不可用，因为它有可能导致内存泄漏。</p> 
</blockquote> 
<p id="语法"><strong>语法</strong></p> 
<pre><code>objectURL = URL.createObjectURL(object);
</code></pre> 
<p id="参数"><strong>参数</strong> ：object：用于创建 URL 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File" rel="nofollow" title="File">File</a> 对象、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" rel="nofollow" title="Blob">Blob</a> 对象或者 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MediaSource" rel="nofollow" title="MediaSource">MediaSource</a> 对象。</p> 
<p id="返回值"><strong>返回值</strong> ：一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String" rel="nofollow" title="DOMString">DOMString</a>包含了一个对象 URL，该 URL 可用于指定源 <code>object</code>的内容。</p> 
<p id="示例"><strong>内存管理</strong></p> 
<p>在每次调用 <code>createObjectURL()</code> 方法时，都会创建一个新的 URL 对象，即使你已经用相同的对象作为参数创建过。当不再需要这些 URL 对象时，每个对象必须通过调用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/revokeObjectURL_static" rel="nofollow" title="URL.revokeObjectURL()">URL.revokeObjectURL()</a> 方法来释放。</p> 
<p>浏览器在 document 卸载的时候，会自动释放它们，但是为了获得最佳性能和内存使用状况，你应该在安全的时机主动释放掉它们。</p> 
<h3 id="3.%20URL.revokeObjectURL()">3. URL.revokeObjectURL()</h3> 
<p><strong><code>URL.revokeObjectURL()</code></strong> 静态方法用来释放一个之前已经存在的、通过调用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/createObjectURL_static" rel="nofollow" title="URL.createObjectURL()">URL.createObjectURL()</a> 创建的 URL 对象。当你结束使用某个 URL 对象之后，应该通过调用这个方法来让浏览器知道不用在内存中继续保留对这个文件的引用了。</p> 
<p>你可以在 <code>sourceopen</code> 被处理之后的任何时候调用 <code>revokeObjectURL()</code>。这是因为 <code>createObjectURL()</code> 仅仅意味着将一个媒体元素的 <code>src</code> 属性关联到一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MediaSource" rel="nofollow" title="MediaSource">MediaSource</a> 对象上去。调用<code>revokeObjectURL()</code> 使这个潜在的对象回到原来的地方，允许平台在合适的时机进行垃圾收集。</p> 
<p><strong>备注：</strong> 此特性在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API" rel="nofollow" title="Web Worker">Web Worker</a> 中可用</p> 
<p>语法：window.URL.revokeObjectURL(objectURL);</p> 
<p>参数： 一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String" rel="nofollow" title="objo'b'jDOMString">objo'b'jDOMString</a>，表示通过调用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/createObjectURL_static" rel="nofollow" title="URL.createObjectURL()">URL.createObjectURL()</a> 方法产生的 URL 对象。</p> 
<p>返回值 undefined</p> 
<h3 id="4.%20FileReader.readAsDataURL()">4. FileReader.readAsDataURL()</h3> 
<p><code>readAsDataURL</code> 方法会读取指定的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" rel="nofollow" title="Blob">Blob</a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File" rel="nofollow" title="File">File</a> 对象。读取操作完成的时候，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/readyState" rel="nofollow" title="readyState">readyState</a> 会变成已完成<code>DONE</code>，并触发 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/loadend_event" rel="nofollow" title="loadend">loadend</a> 事件，同时 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/result" rel="nofollow" title="result">result</a> 属性将包含一个<code>data:</code>URL 格式的字符串（base64 编码）以表示所读取文件的内容</p> 
<p><strong>语法 </strong></p> 
<pre><code>readAsDataURL(blob)</code></pre> 
<p></p> 
<p><strong> 参数</strong> blob即将被读取的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" rel="nofollow" title="Blob">Blob</a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File" rel="nofollow" title="File">File</a> 对象。</p> 
<p><strong>例子</strong></p> 
<pre><code class="hljs">&lt;input type="file" onchange="previewFile()" /&gt;&lt;br /&gt;
&lt;img src="" height="200" alt="Image preview..." /&gt;

function previewFile() {
  var preview = document.querySelector("img");
  var file = document.querySelector("input[type=file]").files[0];
  var reader = new FileReader();

  reader.addEventListener(
    "load",
    function () {
      preview.src = reader.result;
    },
    false,
  );

  if (file) {
    reader.readAsDataURL(file);
  }
}
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/69252e93be614fe6d97aaaa45a16666c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用github copilot</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/20a9fc19d59d237583694749c2925bd8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【MybatisPlus】对数据库中datetime类型字段的处理（获取与格式处理）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>