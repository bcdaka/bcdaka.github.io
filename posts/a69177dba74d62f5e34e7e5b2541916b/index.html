<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>中间件——Kafka - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/a69177dba74d62f5e34e7e5b2541916b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="中间件——Kafka">
  <meta property="og:description" content="两个系统各自都有各自要去做的事，所以只能将消息放到一个中间平台（中间件）
Kafka 分布式流媒体平台
程序发消息，程序接收消息
Producer：Producer即生产者，消息的产生者，是消息的入口。
Broker：Broker是kafka实例，每个服务器上有一个或多个kafka的实例，我们姑且认为每个broker对应一台服务器。每个kafka集群内的broker都有一个不重复的编号，如图中的broker-0、broker-1等……
Topic：消息的主题，可以理解为消息的分类，kafka的数据就保存在topic。在每个broker上都可以创建多个topic。
Partition：Topic的分区，每个topic可以有多个分区，分区的作用是做负载，提高kafka的吞吐量。同一个topic在不同的分区的数据是不重复的，partition的表现形式就是一个一个的文件夹！
Replication:每一个分区都有多个副本，副本的作用是做备胎。当主分区（Leader）故障的时候会选择一个备胎（Follower）上位，成为Leader。在kafka中默认副本的最大数量是10个，且副本的数量不能大于Broker的数量，follower和leader绝对是在不同的机器，同一机器对同一个分区也只可能存放一个副本（包括自己）。
Message：每一条发送的消息主体。
Consumer：消费者，即消息的消费方，是消息的出口。
Consumer Group：我们可以将多个消费组组成一个消费者组，在kafka的设计中同一个分区的数据只能被消费者组中的某一个消费者消费。同一个消费者组的消费者可以消费同一个topic的不同分区的数据，这也是为了提高kafka的吞吐量！
同一个组下，订阅的主题只能有一个消费者收到消息（一对一）
放到不同 的组下，就能实现一对多
Zookeeper：kafka集群依赖zookeeper来保存集群的的元信息，来保证系统的可用性。
Kafka对于zookeeper是清以来，保存kafka相关节点数据，管理节点。安装Kafka前需先安装zookeeper
1.Kafka生产者和消费者详解 Kafka设计与原理详解
生产者 消费者 谁增加while 让它一直处于监听状态
2.分区机制 加你个主题划分为多个分区（Partition）
可以处理更多的消息，不受单服务器限制，可以不受限的处理更多数据。
消息发送时都被发送到一个topic，其本质就是一个目录，而topic由是由一些Partition Logs(分区日志)组成,其组织结构如下图所示：
我们可以看到，每个Partition中的消息都是有序的，生产的消息被不断追加到Partition log上，其中的每一个消息都被赋予了一个唯一的offset值。
Kafka需要维持的元数据只有一个–消费消息在Partition中的offset值（偏移量-连续自增的数值），Consumer每消费一个消息，offset就会加1。其实消息的状态完全是由Consumer控制的，Consumer可以跟踪和重设这个offset值，这样的话Consumer就可以读取任意位置的消息。
把消息日志以Partition的形式存放有多重考虑，第一，方便在集群中扩展，每个Partition可以通过调整以适应它所在的机器，而一个topic又可以有多个Partition组成，因此整个集群就可以适应任意大小的数据了**；第二就是可以提高并发**，因为可以以Partition为单位读写了。
3.Kafka高可用机制 集群 备份 有了备份机制后，Kafka允许集群中的节点挂掉后而不影响整个集群工作。一个备份数量为n的集群允许n-1个节点失败。在所有备份节点中，有一个节点作为lead节点，这个节点保存了其它备份节点列表，并维持各个备份间的状体同步。
Kafka 提供了一种基于副本（Replication）的备份机制，以确保数据的高可用性和容错能力。以下是 Kafka 备份机制的详细说明：
1.副本（Replicas）与分区（Partitions）
在 Kafka 中，主题（Topic）被划分为多个分区（Partition），每个分区都有多个副本。Leader 副本负责处理所有对该分区的读写请求，而Follower 副本则从 Leader 副本同步数据。这样，即使某个 Broker（即 Leader 副本所在节点）发生故障，其他 Broker 上的 Follower 副本可以迅速晋升为新的 Leader，继续提供服务。
2.副本分配与复制
副本分配：Kafka 使用 ZooKeeper 管理元数据，包括分区与副本的分配信息。在创建主题时，可以指定每个分区的副本数（通常称为副本因子）。Kafka 会根据 Broker 配置和可用性，将分区的副本均匀地分布到不同的 Broker 上，以实现负载均衡和容错。
数据复制：Producer 发送消息到 Leader 副本。Leader 副本将消息写入其本地日志后，立即将消息发送给所有 Follower 副本。Follower 副本接收到消息后，将其写入本地日志。这种同步复制或异步复制（取决于配置）机制确保了数据在集群中的复制。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-16T14:06:12+08:00">
    <meta property="article:modified_time" content="2024-07-16T14:06:12+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">中间件——Kafka</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>两个系统各自都有各自要去做的事，所以只能将消息放到一个中间平台（中间件）</p> 
<h2><a id="Kafka_1"></a>Kafka</h2> 
<p>分布式流媒体平台<br> <img src="https://images2.imgbox.com/99/a8/0WPGEoB5_o.png" alt="在这里插入图片描述"><br> 程序发消息，程序接收消息<br> <img src="https://images2.imgbox.com/24/8a/4R97zOMt_o.png" alt="在这里插入图片描述"><br> Producer：Producer即生产者，消息的产生者，是消息的入口。<br> Broker：Broker是kafka实例，每个服务器上有一个或多个kafka的实例，我们姑且认为<strong>每个broker对应一台服务器</strong>。每个kafka集群内的broker都有一个不重复的编号，如图中的broker-0、broker-1等……<br> Topic：消息的主题，可以理解为<strong>消息的分类</strong>，kafka的数据就保存在topic。在每个broker上都可以创建多个topic。<br> Partition：Topic的分区，<strong>每个topic可以有多个分区，分区的作用是做负载</strong>，提高kafka的吞吐量。同一个topic在不同的分区的数据是不重复的，partition的表现形式就是一个一个的文件夹！<br> Replication:每一个分区都有多个副本，副本的作用是做备胎。当主分区（Leader）故障的时候会选择一个备胎（Follower）上位，成为Leader。在kafka中默认副本的最大数量是10个，且副本的数量不能大于Broker的数量，follower和leader绝对是在不同的机器，同一机器对同一个分区也只可能存放一个副本（包括自己）。<br> Message：每一条发送的消息主体。<br> Consumer：消费者，即消息的消费方，是消息的出口。<br> Consumer Group：我们可以将多个消费组组成一个消费者组，在kafka的设计中同一个分区的数据只能被消费者组中的某一个消费者消费。同一个消费者组的消费者可以消费同一个topic的不同分区的数据，这也是为了提高kafka的吞吐量！<br> <strong>同一个组下，订阅的主题只能有一个消费者收到消息（一对一）</strong><br> <strong>放到不同 的组下，就能实现一对多</strong><br> Zookeeper：kafka集群依赖zookeeper来保存集群的的元信息，来保证系统的可用性。<br> Kafka对于zookeeper是清以来，保存kafka相关节点数据，管理节点。安装Kafka前需先安装zookeeper</p> 
<h3><a id="1Kafka_19"></a>1.Kafka生产者和消费者详解</h3> 
<p><a href="https://www.cnblogs.com/sa-dan/p/8241372.html" rel="nofollow">Kafka设计与原理详解</a></p> 
<h4><a id="_21"></a>生产者</h4> 
<p><img src="https://images2.imgbox.com/ff/48/2pwkVl0U_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_24"></a>消费者</h4> 
<p><img src="https://images2.imgbox.com/a1/c7/Ty1lgirD_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/92/99/3g2y7tn4_o.png" alt="在这里插入图片描述"><br> 谁增加while 让它一直处于监听状态</p> 
<h3><a id="2_28"></a>2.分区机制</h3> 
<p>加你个主题划分为多个分区（Partition）<br> 可以处理更多的消息，不受单服务器限制，可以不受限的处理更多数据。<br> 消息发送时都被发送到一个topic，其本质就是一个目录，而topic由是由一些Partition Logs(分区日志)组成,其组织结构如下图所示：<br> <img src="https://images2.imgbox.com/d0/eb/LpAv3K14_o.png" alt="在这里插入图片描述"><br> 我们可以看到，每个Partition中的消息都是有序的，生产的消息被不断追加到Partition log上，其中的<strong>每一个消息都被赋予了一个唯一的offset值</strong>。<br> Kafka需要维持的元数据只有一个–消费消息在Partition中的offset值（偏移量-连续自增的数值），Consumer每消费一个消息，offset就会加1。其实消息的状态完全是由Consumer控制的，Consumer可以跟踪和重设这个offset值，这样的话Consumer就可以读取任意位置的消息。<br> 把消息日志以Partition的形式存放有多重考虑，<strong>第一，方便在集群中扩展</strong>，每个Partition可以通过调整以适应它所在的机器，而一个topic又可以有多个Partition组成，因此整个集群就可以适应任意大小的数据了**；第二就是可以提高并发**，因为可以以Partition为单位读写了。</p> 
<h3><a id="3Kafka_36"></a>3.Kafka高可用机制</h3> 
<h4><a id="_37"></a>集群</h4> 
<p><img src="https://images2.imgbox.com/5b/cd/cUdKkxHD_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_39"></a>备份</h4> 
<p>有了备份机制后，Kafka允许集群中的节点挂掉后而不影响整个集群工作。<strong>一个备份数量为n的集群允许n-1个节点失败</strong>。在所有备份节点中，有一个节点作为lead节点，这个节点保存了其它备份节点列表，并维持各个备份间的状体同步。<br> <img src="https://images2.imgbox.com/91/9e/lb0MRreZ_o.png" alt="在这里插入图片描述"><br> Kafka 提供了一种基于副本（Replication）的备份机制，以确保数据的高可用性和容错能力。以下是 Kafka 备份机制的详细说明：</p> 
<ul><li> <p>1.副本（Replicas）与分区（Partitions）<br> 在 Kafka 中，主题（Topic）被划分为多个分区（Partition），<strong>每个分区都有多个副本</strong>。Leader 副本负责处理所有对该分区的读写请求，而Follower 副本则从 Leader 副本同步数据。这样，即使某个 Broker（即 Leader 副本所在节点）发生故障，其他 Broker 上的 Follower 副本可以迅速晋升为新的 Leader，继续提供服务。</p> </li><li> <p>2.副本分配与复制<br> 副本分配：Kafka 使用 ZooKeeper 管理元数据，包括分区与副本的分配信息。<strong>在创建主题时，可以指定每个分区的副本数</strong>（通常称为副本因子）。Kafka 会根据 Broker 配置和可用性，将分区的副本均匀地分布到不同的 Broker 上，以实现负载均衡和容错。</p> </li></ul> 
<p>数据复制：Producer 发送消息到 Leader 副本。<strong>Leader 副本将消息写入其本地日志后，立即将消息发送给所有 Follower 副本</strong>。Follower 副本接收到消息后，将其写入本地日志。这种同步复制或异步复制（取决于配置）机制确保了数据在集群中的复制。</p> 
<ul><li>3.ISR（In-Sync Replicas）与副本同步<br> ISR：Kafka 维护了一个名为 <strong>ISR（In-Sync Replicas）的集合</strong>，包含所有与 Leader 副本保持同步的 Follower 副本。只有 I**SR 中的副本被认为是可以安全地晋升为 Leader 的候选者。**当 Follower 副本由于网络延迟、Broker 故障等原因与 Leader 副本失去同步时，会被暂时移出 ISR。</li></ul> 
<p>副本同步：Kafka 通过心跳机制监控 Follower 副本与 Leader 副本的同步状态。Follower 副本定期向 Leader 副本发送心跳，报告其已复制的消息偏移量。Leader 副本根据心跳信息判断 Follower 副本是否处于同步状态，并据此更新 ISR 集合。</p> 
<p>**4. <strong>Leader 选举与故障恢复<br> Leader 选举：当 Leader 副本所在的 Broker 发生故障时，ZooKeeper 会检测到并触发 Leader 选举。从 I</strong>SR 集合中选择一个 Follower 副本晋升为新的 Leader。**其余 Follower 副本随后将与新的 Leader 建立连接并开始同步。</p> 
<p>故障恢复：一旦<strong>新的 Leader 副本被选举出来，Producer 和 Consumer 可以无缝地切换到新的 Leader 进行读写操作</strong>。对于未完成同步的 Follower 副本，它们将在恢复连接后从新的 Leader 处拉取缺失的数据，直至重新加入 ISR。</p> 
<h3><a id="4_62"></a>4.消息可靠性</h3> 
<p>在消息系统中，保证消息在生产和消费过程中的可靠性是十分重要的，在实际消息传递过程中，可能会出现如下三中情况：</p> 
<ul><li>一个消息发送失败</li><li>一个消息被发送多次</li><li>最理想的情况：exactly-once ,一个消息发送成功且仅发送了一次</li></ul> 
<p>有许多系统声称它们实现了exactly-once，但是它们其实忽略了生产者或消费者在生产和消费过程中有可能失败的情况。比如虽然一个Producer成功发送一个消息，但是消息在发送途中丢失，或者成功发送到broker，也被consumer成功取走，但是这个consumer在处理取过来的消息时失败了。<br> （1）从Producer端看：Kafka是这么处理的，当一个消息被发送后，Producer会<strong>等待broker成功接收到消息的反馈</strong>（可通过参数控制等待时间），如果消息在途中丢失或是其中一个broker挂掉，Producer会重新发送（我们知道<strong>Kafka有备份机制，可以通过参数控制是否等待所有备份节点都收到消息</strong>）。<br> （2）从Consumer端看：前面讲到过partition，broker端记录了partition中的一个offset值，这个值指向Consumer下一个即将消费message。当Consumer收到了消息，但却在处理过程中挂掉，此时Consumer可以<strong>通过这个offset值重新找到上一个消息再进行处理</strong>。Consumer还有权限控制这个offset值，对持久化到broker端的消息做任意处理。</p> 
<h3><a id="5_74"></a>5.生产者详解</h3> 
<h4><a id="_75"></a>发送类型</h4> 
<p><img src="https://images2.imgbox.com/91/45/87W1oBqz_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/78/fb/mjweWRlw_o.png" alt="在这里插入图片描述"><br> 异步时响应回调函数。<br> 消息发送失败时会抛出异常，这是可以拿到异常，用于记录或做出补偿。</p> 
<h3><a id="6_80"></a>6.消费者详解</h3> 
<p><img src="https://images2.imgbox.com/81/ac/fjSuF4ne_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ca/a7/aRNcyJlK_o.png" alt="在这里插入图片描述"><br> 只有在一个分区，才能保证消息有序。</p> 
<h4><a id="_84"></a>手动提示偏移量</h4> 
<p><img src="https://images2.imgbox.com/0d/f2/XxtnRngD_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d7/0a/Xhx93lil_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/83/d9/jhEtBJ1M_o.png" alt="在这里插入图片描述"><br> 同步提交尽可能会造成方法堵塞。<img src="https://images2.imgbox.com/74/f8/ITswWHIB_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/0d/27/asFdxHFK_o.png" alt="在这里插入图片描述"><br> 如果异步提交成功则会一直在while（true)监听中，如果出现异常才会捕获异常，捕获完异常后才会执行finally中的同步提交操作</p> 
<h3><a id="7SpringKafka_93"></a>7.Spring集成Kafka</h3> 
<p><img src="https://images2.imgbox.com/16/83/M4hjy0tY_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/ed/62/Yo4hfO5a_o.png" alt="在这里插入图片描述"><br> 异步，通过回调方式实现：</p> 
<pre><code class="prism language-java"><span class="token comment">//发送消息</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            
    <span class="token class-name">ListenableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SendResult</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> kafkaTemplate<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>topicName<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
    future<span class="token punctuation">.</span><span class="token function">addCallback</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ListenableFutureCallback</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SendResult</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onSuccess</span><span class="token punctuation">(</span><span class="token class-name">SendResult</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> result<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Sent message=["</span> <span class="token operator">+</span> message <span class="token operator">+</span> <span class="token string">"] with offset=["</span> <span class="token operator">+</span> result<span class="token punctuation">.</span><span class="token function">getRecordMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">offset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onFailure</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Unable to send message=["</span> <span class="token operator">+</span> message <span class="token operator">+</span> <span class="token string">"] due to : "</span> <span class="token operator">+</span> ex<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-java"><span class="token comment">//接收消息</span>
<span class="token annotation punctuation">@KafkaListener</span><span class="token punctuation">(</span>topics <span class="token operator">=</span> <span class="token string">"topicName"</span><span class="token punctuation">,</span> groupId <span class="token operator">=</span> <span class="token string">"foo"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenGroupFoo</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Received Message in group foo: "</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>一个消费者可以监听多个主题：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@KafkaListener</span><span class="token punctuation">(</span>topics <span class="token operator">=</span> <span class="token string">"topic1, topic2"</span><span class="token punctuation">,</span> groupId <span class="token operator">=</span> <span class="token string">"foo"</span><span class="token punctuation">)</span>

</code></pre> 
<p>Spring也支持获取一个或多个消息头信息，通过在监听器上是哟个@Header注解：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@KafkaListener</span><span class="token punctuation">(</span>topics <span class="token operator">=</span> <span class="token string">"topicName"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenWithHeaders</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Payload</span> <span class="token class-name">String</span> message<span class="token punctuation">,</span> <span class="token annotation punctuation">@Header</span><span class="token punctuation">(</span><span class="token class-name">KafkaHeaders</span><span class="token punctuation">.</span><span class="token constant">RECEIVED_PARTITION_ID</span><span class="token punctuation">)</span> <span class="token keyword">int</span> partition<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Received Message: "</span> <span class="token operator">+</span> message<span class="token string">" + "</span>from partition<span class="token operator">:</span> " <span class="token operator">+</span> partition<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a520e824ef715c7926ba244501bc47a6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">国产化中间件东方通TongWeb环境安装部署（图文详解）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2c3e8161dede9f6d18a4419a7e3ae6e3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">直接在JetBrains IDE中查看Gitee拉取请求（IntelliJ IDEA、PhpStorm、WebStorm、PyCharm、Rider、CLion、Goland等）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>