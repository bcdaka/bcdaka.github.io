<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构奇妙旅程之二叉树题型解法总结 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/28e4d8d9f8f7c8f1090fe6298d82bc58/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构奇妙旅程之二叉树题型解法总结">
  <meta property="og:description" content="꒰˃͈꒵˂͈꒱ write in front ꒰˃͈꒵˂͈꒱
ʕ̯•͡˔•̯᷅ʔ大家好，我是xiaoxie.希望你看完之后,有不足之处请多多谅解，让我们一起共同进步૮₍❀ᴗ͈ . ᴗ͈ აxiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客
本文由xiaoxieʕ̯•͡˔•̯᷅ʔ 原创 CSDN 如需转载还请通知˶⍤⃝˶
个人主页：xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客
系列专栏：xiaoxie的JAVA系列专栏——CSDN博客●&#39;ᴗ&#39;σσணღ*
我的目标:&#34;团团等我💪( ◡̀_◡́ ҂)&#34; ( ⸝⸝⸝›ᴥ‹⸝⸝⸝ )欢迎各位→点赞👍 &#43; 收藏⭐️ &#43; 留言📝​&#43;关注（互三必回）!
一.关于二叉树的遍历的总结 1.使用递归来遍历二叉树 使用递归的方法来遍历二叉树我相信大家应该都没有什么大问题，在这里就不过多的赘述了，直接上代码
1.前序遍历（按照根 -&gt; 左 -&gt; 右） public void preOrder(TreeNode root) { if(root == null) { return; } System.out.print(root.val &#43; &#34; &#34;); preOrder(root.left); preOrder(root.right); } 2.中序遍历（按照左 -&gt; 根 -&gt; 右） public void inOrder(TreeNode root) { if(root == null){ return; } inOrder(root.left); System.out.print(root.val &#43; &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-01-24T16:45:36+08:00">
    <meta property="article:modified_time" content="2024-01-24T16:45:36+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构奇妙旅程之二叉树题型解法总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>꒰˃͈꒵˂͈꒱ write in front ꒰˃͈꒵˂͈꒱<br> ʕ̯•͡˔•̯᷅ʔ大家好，我是xiaoxie.希望你看完之后,有不足之处请多多谅解，让我们一起共同进步૮₍❀ᴗ͈ . ᴗ͈ ა<a href="https://blog.csdn.net/xiaoxie8023?spm=1000.2115.3001.5343" title="xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客">xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客</a><br> 本文由xiaoxieʕ̯•͡˔•̯᷅ʔ 原创 CSDN 如需转载还请通知˶⍤⃝˶<br><a href="https://so.csdn.net/so/search?q=%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5&amp;spm=1001.2101.3001.7020" title="个人主页">个人主页</a>：<a href="https://blog.csdn.net/xiaoxie8023/article/details/134417887?spm=1001.2014.3001.5501" title="xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客">xiaoxieʕ̯•͡˔•̯᷅ʔ—CSDN博客</a><br> 系列专栏：<a href="https://blog.csdn.net/xiaoxie8023/category_12482318.html?spm=1001.2014.3001.5482" title="xiaoxie的JAVA系列专栏——CSDN博客●'ᴗ'σσணღ*">xiaoxie的JAVA系列专栏——CSDN博客●'ᴗ'σσணღ*</a><br><span style="color:#fe2c24;"><strong>我的目标:"团团等我💪( ◡̀_◡́ ҂)" </strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>( ⸝⸝⸝›ᴥ‹⸝⸝⸝ )欢迎各位→点赞👍 + 收藏⭐️ + 留言📝​+关注（互三必回）!</strong></span></p> 
</blockquote> 
<h2><img alt="" height="1080" src="https://images2.imgbox.com/31/3a/r482OMFy_o.png" width="1080"> 一.关于二叉树的遍历的总结</h2> 
<h3>1.使用递归来遍历二叉树</h3> 
<p>使用递归的方法来遍历二叉树我相信大家应该都没有什么大问题，在这里就不过多的赘述了，直接上代码</p> 
<h4>1.前序遍历（按照根 -&gt; 左 -&gt; 右）</h4> 
<pre><code class="language-java">public void preOrder(TreeNode root) {
        if(root == null) {
            return;
        }
        System.out.print(root.val + " ");
        preOrder(root.left);
        preOrder(root.right);
    }</code></pre> 
<h4>2.中序遍历（按照左 -&gt; 根 -&gt; 右）</h4> 
<pre><code class="language-java">public void inOrder(TreeNode root) {
        if(root == null){
            return;
        }
        inOrder(root.left);
        System.out.print(root.val + " ");
        inOrder(root.right);
    }</code></pre> 
<h4>3.后序遍历（按照左 -&gt; 右 -&gt; 根）</h4> 
<pre><code class="language-java">public void postOrder(TreeNode root) {
        if(root == null){
            return;
        }
        postOrder(root.left);
        postOrder(root.right);
        System.out.print(root.val + " ");
    }</code></pre> 
<h3>2.迭代解法 （借助栈的思想）</h3> 
<p><strong><span style="color:#fe2c24;">迭代解法</span></strong>本质上是在模拟递归，因为在递归的过程中使用了系统栈，所以在迭代的解法中常用 <code><strong><span style="color:#fe2c24;">Stack</span></strong></code> 来模拟系统栈。</p> 
<h4>1.前序遍历（按照根 -&gt; 左 -&gt; 右）</h4> 
<p><img alt="" height="992" src="https://images2.imgbox.com/f1/a8/Wy6Xawt9_o.png" width="1200"></p> 
<p>首先我们应该创建一个 Stack 用来存放节点，首先我们想要打印根节点的数据，此时 Stack 里面的内容为空，所以我们优先将头结点加入 Stack，然后打印。</p> 
<p>之后我们应该先打印左子树，然后右子树。所以先加入 Stack 的就是右子树，然后左子树。<br> 此时你能得到的流程如下:</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/88/2d/5EXrd3ac_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/ed/7d/dJHx5MuD_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/2b/13/W9VpcniX_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/05/87/lPhECcZK_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/95/55/xTqmUVmq_o.png" width="1200"></p> 
<p> 代码为：</p> 
<pre><code class="language-java">class Solution {
    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
         List&lt;Integer&gt; list = new ArrayList&lt;&gt;();//打印的容器
        if(root == null) return list;
        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); //创建一个栈
        TreeNode cur = root;//用cur来遍历二叉树
        while (!stack.isEmpty() || cur != null) {
            while (cur != null) {
                list.add(cur.val);
                stack.push(cur);
                cur = cur.left;
            }
            TreeNode top = stack.pop();
            cur = top.right;
        }
        return list;
    }
}</code></pre> 
<p>OJ练习为<a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/" rel="nofollow" title="144. 二叉树的前序遍历 - 力扣（LeetCode）">144. 二叉树的前序遍历 - 力扣（LeetCode）</a></p> 
<h4>2.中序遍历 按照（左 -&gt;根 -&gt; 右）</h4> 
<p>尽可能的将这个节点的左子树压入 Stack，此时栈顶的元素是最左侧的元素，其目的是找到一个最小单位的子树(也就是最左侧的一个节点)，并且在寻找的过程中记录了来源，才能返回上层,同时在返回上层的时候已经处理完毕左子树了。当处理完最小单位的子树时，返回到上层处理了中间节点。（如果把整个左中右的遍历都理解成子树的话，就是处理完 左子树-&gt;中间(就是一个节点)-&gt;右子树）同理创建一个<span style="color:#fe2c24;"> <code>Stack</code></span>，然后按 左 中 右的顺序输出节点，只是输出的顺序改变了这里直接上代码</p> 
<pre><code class="language-java">class Solution {
    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        TreeNode cur = root;
        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
        while(cur != null || !stack.isEmpty()){
        while(cur != null) {
            stack.push(cur);
            cur = cur.left;
        }
        TreeNode top = stack.pop();
        list.add(top.val);
        cur = top.right;
      }
      return list;
    }
}</code></pre> 
<p>OJ练习为<a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/" rel="nofollow" title="94. 二叉树的中序遍历 - 力扣（LeetCode）">94. 二叉树的中序遍历 - 力扣（LeetCode）</a></p> 
<h4>3. 中序遍历 按照（左 -&gt;右 -&gt; 根 ）</h4> 
<p>方法1</p> 
<ol><li>前序遍历的过程 是 根左右。</li><li>将其转化成 根右左。也就是压栈的过程中优先压入左子树，在压入右子树。</li><li>然后将这个结果返回来，这里是利用栈的先进后出倒序打印</li></ol> 
<pre><code class="language-java">class Solution {
    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();
        LinkedList&lt;Integer&gt; ans = new LinkedList&lt;&gt;();
        if (null == root) return ans;
        stack.addFirst(root);
        while(!stack.isEmpty()) {
            TreeNode node = stack.removeFirst();
            ans.addFirst(node.val);
            if (null != node.left) {
                stack.addFirst(node.left);
            }
            if (null != node.right) {
                stack.addFirst(node.right);
            }
        }
        return ans;
    }
}</code></pre> 
<p> 方法2.</p> 
<p>栈遍历版本： 建议先做中序遍历，后序只是在中序上多了一些操作。</p> 
<p>与中序的不同之处在于：</p> 
<ul><li>中序遍历中，从栈中弹出的节点，其左子树是访问完了，可以直接访问该节点，然后接下来访问右子树。</li><li>后序遍历中，从栈中弹出的节点，我们只能确定其左子树肯定访问完了，但是无法确定右子树是否访问过。</li></ul> 
<p>因此，我们在后序遍历中，引入了一个prev来记录历史访问记录。</p> 
<ul><li>当访问完一棵子树的时候，我们用prev指向该节点。</li><li>这样，在回溯到父节点的时候，我们可以依据prev是指向左子节点，还是右子节点，来判断父节点的访问情况。</li></ul> 
<pre><code class="language-java">class Solution{
    public List&lt;Integer&gt; method1(TreeNode root) {
        List&lt;Integer&gt; ans=new LinkedList&lt;&gt;();
        Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;();
        TreeNode prev=null;
        //主要思想：
        //由于在某颗子树访问完成以后，接着就要回溯到其父节点去
        //因此可以用prev来记录访问历史，在回溯到父节点时，可以由此来判断，上一个访问的节点是否为右子树
        while(root!=null||!stack.isEmpty()){
            while(root!=null){
                stack.push(root);
                root=root.left;
            }
            //从栈中弹出的元素，左子树一定是访问完了的
            root=stack.pop();
            //现在需要确定的是是否有右子树，或者右子树是否访问过
            //如果没有右子树，或者右子树访问完了，也就是上一个访问的节点是右子节点时
            //说明可以访问当前节点
            if(root.right==null||prev==root.right){
                ans.add(root.val);
                //更新历史访问记录，这样回溯的时候父节点可以由此判断右子树是否访问完成
                prev=root;
                root=null;
            }else{
            //如果右子树没有被访问，那么将当前节点压栈，访问右子树
                stack.push(root);
                root=root.right;
            }
        }
        return ans;
    }
}</code></pre> 
<p>  OJ练习为<a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/description/" rel="nofollow" title="145. 二叉树的后序遍历 - 力扣（LeetCode）">145. 二叉树的后序遍历 - 力扣（LeetCode）</a></p> 
<h2>二.关于二叉树子树的问题</h2> 
<h3>1.<a href="https://leetcode.cn/problems/same-tree/description/" rel="nofollow" title="100. 相同的树 - 力扣（LeetCode）">100. 相同的树 - 力扣（LeetCode）</a></h3> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/1e/34/BiLoqVqm_o.png" width="1200">​</p> 
<p>要想知道两棵树是否相同，首先我们需要比较结构是否相同，然后再比较值是否相同，同样也可以分为递归和迭代两种方法</p> 
<p>1.递归方法</p> 
<div> 
 <pre><code class="language-java">class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p == null &amp;&amp; q == null) return true;
        if(p == null &amp;&amp; q != null || p != null &amp;&amp; q == null) return false;
        if(p.val != q.val) return false;
        return isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right);
    }</code></pre> 
</div> 
<p>2.迭代的方法</p> 
<div> 
 <pre><code class="language-java">class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p == null &amp;&amp; q == null) return true;
        if (p == null || q == null) return false;
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();
        queue.offer(p);
        queue.offer(q);
        while(!queue.isEmpty()) {
            p = queue.poll();
            q = queue.poll();
            if(p == null &amp;&amp; q == null) continue;
            if((p == null || q == null) || p.val != q.val)
                return false;  
            queue.offer(p.left);
            queue.offer(q.left);
            queue.offer(p.right);
            queue.offer(q.right);     
        }
        return true;
    }
}</code></pre> 
</div> 
<p> 通过借助队列来判断两棵树的结构和节点的值是否相同，需要注意的是两种方法的时间复杂度都为O（n）。</p> 
<h3>2.<a href="https://leetcode.cn/problems/subtree-of-another-tree/description/" rel="nofollow" title="572. 另一棵树的子树 - 力扣（LeetCode）">572. 另一棵树的子树 - 力扣（LeetCode）</a></h3> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/f6/b0/S9nc0RMg_o.png" width="1200">​主要思路：将是否为子树的问题转换成是否相等的问题</p> 
<pre><code class="language-java">class Solution {
    public boolean isSubtree(TreeNode root, TreeNode subRoot) {
        if(root == null) return false;
        if(isSameTree(root,subRoot)) return true;//判断中是否相同
        if(isSubtree(root.left,subRoot.left)) return true;//判断左子树是否相同
        if(isSubtree(root.right,subRoot.right)) return true;//判断右子树是否相同
        return false;
    }
    private boolean isSameTree(TreeNode root, TreeNode subRoot) {
        if(root == null &amp;&amp; subRoot == null) return true;
        if(root == null &amp;&amp; subRoot != null ||root != null &amp;&amp; subRoot == null) return false;
        if(root.val != subRoot.val) return false;
        return isSameTree(root.left,subRoot.left) &amp;&amp; isSameTree(root.right,subRoot.right);
    }
}</code></pre> 
<p>其中需要注意的是</p> 
<p>判断两个树是否相等的三个条件是<strong><span style="color:#fe2c24;">与</span></strong>的关系，</p> 
<p><span style="color:#fe2c24;">即当前两个树的根节点值相等<br> 并且，s的左子树和 r 的左子树相等;<br> 并且，s 的右子树和 r 的右子树相等 </span></p> 
<p>判断<span style="color:#fe2c24;"><strong>s</strong></span> 是否为<span style="color:#fe2c24;"><strong> r</strong></span>的子树的三个条件是<strong><span style="color:#fe2c24;">或</span></strong>的关系</p> 
<p>即当前两棵树相等<br> 或者，s 是 r 的左子树<br> 或者，s 是 r 的右子树</p> 
<p>总的来说以上这些方法都是比较简单的暴力或者是递归解法，可能还达不到面试的高度，但学习就是循序渐进的，学会了这些比较基础的解法我相信你在后面学习更优的解法时，肯定更加得心应手</p> 
<h2>三.二叉树的广度优先搜索的总结（BFS）</h2> 
<h3>1.层序遍历</h3> 
<p>二叉树的层序遍历问题借助队列可以使用广度优先搜索（BFS）算法来实现这种方法可以保证按层遍历二叉树，先遍历完当前层的节点，再遍历下一层的节点，直到所有节点都被遍历完成 </p> 
<p>1.基础的二叉树的层序遍历</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/54/34/doMJ4NXO_o.png" width="1200">                                                                                                                                                            题目要求的二叉树的 <strong>从上至下</strong> 打印（即按层打印），又称为二叉树的 <strong>广度优先搜索</strong>（BFS）。BFS 通常借助 <strong>队列</strong> 的先入先出特性来实现。接下来我将一步步的详细讲解</p> 
<p>我们先将根节点放到队列中，然后不断遍历队列。</p> 
<p><img alt="" height="1174" src="https://images2.imgbox.com/7f/59/fQ4IlBMW_o.png" width="1200"></p> 
<p>再取出根节点，如果左子树或者右子树不为空，就将他们放入队列中。第一遍处理完后，根节点已经从队列中拿走了，而根节点的两个孩子已放入队列中了，现在队列中就有两个节点即为B和C</p> 
<p><img alt="" height="1052" src="https://images2.imgbox.com/e1/07/TxwZ6KTE_o.png" width="1200"></p> 
<p>同理再取出B和C，如果B的左右孩子不为空，就加入队列，C同理，这样就完成了层层遍历了</p> 
<p><img alt="" height="1158" src="https://images2.imgbox.com/e3/c9/RW1ISZMm_o.png" width="1200"> 根据上图的解释我们就可以得到如下的代码</p> 
<pre><code class="language-java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        if(root == null) return res;
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);//首先先把根节点加入到队列中去
        while(!queue.isEmpty()) {
            List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
            int size = queue.size();//根据队列的长度来判断是否为同一层的节点
            while(size &gt;0) {
             TreeNode cur = queue.poll();
             list.add(cur.val);
             size--;
             if(cur.left != null) {//左孩子不为空，就加入到队列中
                 queue.offer(cur.left);
             }
             if(cur.right != null) {//右孩子不为空，就加入到队列中
                 queue.offer(cur.right);
             } 
        }
        res.add(list);
        }
        return res;
    }
}</code></pre> 
<p>   </p> 
<p><span style="color:#0d0016;"><strong>复杂度分析</strong></span></p> 
<p>记树上所有节点的个数为 n。</p> 
<p>时间复杂度：每个结点进队出队各一次，故时间复杂度为 O(n)。<br> 空间复杂度：队列中元素的个数不超过 n 个，故空间复杂度为 O(n)。</p> 
<p>OJ链接为：<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/solutions/244853/bfs-de-shi-yong-chang-jing-zong-jie-ceng-xu-bian-l/" rel="nofollow" title="102. 二叉树的层序遍历 - 力扣（LeetCode）">102. 二叉树的层序遍历 - 力扣（LeetCode）</a></p> 
<h3>2.层序遍历的应用</h3> 
<h3><img alt="" height="1182" src="https://images2.imgbox.com/d0/db/m5SE8T3i_o.png" width="1200"></h3> 
<p>这题就看成和上一题一样使用广度优先搜索（BFS），借助队列只不过是这题需要稍微改变一些，输出的是每一层的<strong>最后一个</strong>。所以可以得到以下的代码</p> 
<pre><code class="language-java">class Solution {
    public List&lt;Integer&gt; rightSideView(TreeNode root) {
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        if(root == null) return list;
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);
        while(!queue.isEmpty()) {
            int size = queue.size();//根据队列的长度判断是每一层有多少个节点
            while(size &gt; 0) {
                TreeNode cur = queue.poll();
                if(size == 1) {//如果是每一层的最后一个节点就输出它
                    list.add(cur.val);
                }
                size--;
                if(cur.left != null) {
                    queue.offer(cur.left);
                }
                if(cur.right != null) {
                    queue.offer(cur.right);
                }
            }
        }
        return list;
    }
}</code></pre> 
<p></p> 
<p>复杂度分析</p> 
<p>时间复杂度 : O(n)。 每个节点最多进队列一次，出队列一次，因此广度优先搜索的复杂度为线性。</p> 
<p>空间复杂度 : O(n)。每个节点最多进队列一次，所以队列长度最大不不超过n，所以这里的空间代价为 O(n)。</p> 
<p> 当然这题也可以用深度优先搜索（DFS），根据题意我们每次都要输出每一层最右边的那一个，然后根据 <strong>根 -&gt; 右 -&gt; 左</strong> 的顺序这样的话每次第一个搜索的就是最右边的那个节点即每一层的最后一个节点 所以我们可以得到以下代码</p> 
<pre><code class="language-java">class Solution {
    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
    public List&lt;Integer&gt; rightSideView(TreeNode root) {
        dfs(root,0);
        return list;
    }
    private void dfs(TreeNode root,int depth) {
        if(root == null) return;
         //先访问 当前节点，再递归地访问 右子树 和 左子树。
        if(depth == list.size()) {//如果当前节点所在深度还没有出现在res里，说明在该深度下当前节点是第一个被访问的节点，因此将当前节点加入res中。
            list.add(root.val);
        }
        depth++;
        dfs(root.right,depth);
        dfs(root.left,depth);
    } 
}</code></pre> 
<p>复杂度分析</p> 
<p>时间复杂度 : O(n)</p> 
<p>空间复杂度 : O(n)</p> 
<p>当然这一题无论是DFS 还是 BFS 都可以解这题，时间复杂度和空间复杂度都差不多，只不过DFS更快一点，BFS更容易理解。</p> 
<p>OJ链接为：<a href="https://leetcode.cn/problems/binary-tree-right-side-view/submissions/497843000/" rel="nofollow" title="199. 二叉树的右视图 - 力扣（LeetCode）">199. 二叉树的右视图 - 力扣（LeetCode）</a>                                                                                                                                                                                                                                  以上就是博主最近学习二叉树总结的所有内容呢，可能总结的并不是那么全面，不过后续博主学习的更加清楚明白一点，会再将这个总结补全完整，感谢大家的观看。                                         </p> 
<p>                                                                                                                                                                                                                        </p> 
<h2></h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2bd30d433ac538323e4da9e653ff9f39/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">一文捋清人工智能机器学习深度学习、大数据、数据分析、数据挖掘的关系</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/face271f81a00539dba1cff3b021982c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">LoRa模型训练教程（炼丹，Stable Diffusion）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>