<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android 蓝牙开发 入门级（史上最全） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/dba909e92803fa43bb6d93328ff64c8f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Android 蓝牙开发 入门级（史上最全）">
  <meta property="og:description" content="第一节：了解蓝牙 1. 蓝牙基础 蓝牙是一种无线技术标准，用于短距离内的数据交换。
在Android设备上，蓝牙技术允许进行设备发现、配对、连接以及数据传输。
技术始于爱立信公司 1994 方案，它是研究在移动电话和其他配件间进行低功耗、低成本无线通信连接的方法。发明者希望为设备间的通讯创造一组统一规则（标准化协议）用来解决用户间相互不兼容的移动电子设备。
2.蓝牙分类 3. 蓝牙权限 在开始开发之前，需要在Android项目的AndroidManifest.xml文件中声明蓝牙相关的权限。对于基本的蓝牙操作，需要以下权限：
&lt;!-- 允许应用程序连接到配对的蓝牙设备 --&gt; &lt;uses-permission android:name=&#34;android.permission.BLUETOOTH&#34; /&gt; &lt;!-- 允许应用程序发现和配对蓝牙设备 --&gt; &lt;uses-permission android:name=&#34;android.permission.BLUETOOTH_ADMIN&#34; /&gt; 从Android 6.0（API级别23）开始，蓝牙扫描需要定位权限，因为蓝牙扫描可以被用来粗略地定位用户。
因此，如果你的应用目标是API级别23或更高，并且需要进行蓝牙扫描，你还需要添加：
&lt;!-- 用于Android 6.0及以上版本的蓝牙扫描 --&gt; &lt;uses-permission android:name=&#34;android.permission.ACCESS_FINE_LOCATION&#34; /&gt; 从Android 10（API级别29）开始，ACCESS_FINE_LOCATION权限被分为更细粒度的权限，如果你的应用需要在后台访问位置，还需要声明：
&lt;uses-permission android:name=&#34;android.permission.ACCESS_BACKGROUND_LOCATION&#34; /&gt; 4. 用户权限请求 对于运行时权限（如位置权限），你需要在应用运行时请求用户授权。这通常在你的应用尝试进行蓝牙扫描之前完成。
这是请求权限的一个基本示例：
（1）安卓原生检查权限和申请权限
if (ContextCompat.checkSelfPermission(thisActivity, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) { ActivityCompat.requestPermissions(thisActivity, new String[]{Manifest.permission.ACCESS_FINE_LOCATION}, MY_PERMISSIONS_REQUEST_ACCESS_FINE_LOCATION); } 在这里，MY_PERMISSIONS_REQUEST_ACCESS_FINE_LOCATION是一个应用定义的整数常量。将在回调方法onRequestPermissionsResult中使用它来接收请求结果。
（2）第三方库xxPermissions
if (ActivityCompat.checkSelfPermission(getContext(), Manifest.permission.BLUETOOTH_CONNECT) != PackageManager.PERMISSION_GRANTED) { // 检查蓝牙连接权限，如果没有，则请求权限 getPermission(Manifest.permission.BLUETOOTH_CONNECT); return; } // 获取权限的方法 private void getPermission(String permission) { // 请求权限 XXPermissions.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-11T14:01:21+08:00">
    <meta property="article:modified_time" content="2024-03-11T14:01:21+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android 蓝牙开发 入门级（史上最全）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4><span style="color:#0d0016;">第一节：了解蓝牙</span></h4> 
<p></p> 
<h5><span style="color:#0d0016;">1. 蓝牙基础</span></h5> 
<p><br> 蓝牙是一种无线技术标准，用于<u>短距离内的数据交换</u>。</p> 
<p>在Android设备上，蓝牙技术允许进行设备<strong><span style="color:#333333;">发现、配对、连接</span></strong>以及<strong><span style="color:#0d0016;">数据传输</span></strong>。</p> 
<p>技术始于爱立信公司 1994 方案，它是研究在移动电话和其他配件间进行低功耗、低成本无线通信连接的方法。发明者希望为设备间的通讯创造一组统一规则（标准化协议）用来解决用户间相互不兼容的移动电子设备。</p> 
<p><img alt="" height="452" src="https://images2.imgbox.com/f5/f4/rTtp8KHS_o.png" width="500"></p> 
<h5><span style="color:#0d0016;">2.蓝牙分类 </span></h5> 
<p><img alt="" height="914" src="https://images2.imgbox.com/c2/88/reiUEvJ6_o.png" width="1200"></p> 
<h5><span style="color:#0d0016;">3. 蓝牙权限</span></h5> 
<p><br> 在开始开发之前，需要在Android项目的AndroidManifest.xml文件中<strong><span style="color:#0d0016;">声明蓝牙相关的权限</span></strong>。对于基本的蓝牙操作，需要以下权限：</p> 
<pre><code class="language-XML">&lt;!-- 允许应用程序连接到配对的蓝牙设备 --&gt;
&lt;uses-permission android:name="android.permission.BLUETOOTH" /&gt;

&lt;!-- 允许应用程序发现和配对蓝牙设备 --&gt;
&lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN" /&gt;</code></pre> 
<p>从Android 6.0（API级别23）开始，蓝牙扫描需要<strong><span style="color:#fe2c24;">定位权限</span></strong>，因为蓝牙扫描可以被用来粗略地定位用户。</p> 
<p>因此，如果你的应用目标是API级别23或更高，并且需要进行蓝牙扫描，你还需要添加：</p> 
<pre><code class="language-XML">&lt;!-- 用于Android 6.0及以上版本的蓝牙扫描 --&gt;
&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt;</code></pre> 
<p>从Android 10（API级别29）开始，ACCESS_FINE_LOCATION权限被分为更细粒度的权限，如果你的应用需要在<span style="color:#0d0016;"><strong>后台访问位置</strong></span>，还需要声明：</p> 
<pre><code class="language-XML">&lt;uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" /&gt;</code></pre> 
<h5><span style="color:#0d0016;">4. 用户权限请求</span></h5> 
<p><br> 对于运行时权限（如<span style="color:#0d0016;"><strong>位置权限</strong></span>），你需要在应用运行时请求用户授权。这通常在你的应用尝试进行<u>蓝牙扫描之前完成</u>。<br><br> 这是请求权限的一个基本示例：</p> 
<p>（1）安卓原生检查权限和申请权限</p> 
<pre><code class="language-java">if (ContextCompat.checkSelfPermission(thisActivity, Manifest.permission.ACCESS_FINE_LOCATION)
        != PackageManager.PERMISSION_GRANTED) {
    ActivityCompat.requestPermissions(thisActivity,
            new String[]{Manifest.permission.ACCESS_FINE_LOCATION},
            MY_PERMISSIONS_REQUEST_ACCESS_FINE_LOCATION);
}</code></pre> 
<p>在这里，<strong>MY_PERMISSIONS_REQUEST_ACCESS_FINE_LOCATION</strong>是一个应用定义的<span style="color:#fe2c24;"><strong>整数常量</strong></span>。将在回调方法<strong>onRequestPermissionsResult</strong>中使用它来<span style="color:#fe2c24;"><strong>接收请求结果</strong></span>。</p> 
<p>（2）第三方库xxPermissions</p> 
<pre><code class="language-java">if (ActivityCompat.checkSelfPermission(getContext(), Manifest.permission.BLUETOOTH_CONNECT) != PackageManager.PERMISSION_GRANTED) {
                // 检查蓝牙连接权限，如果没有，则请求权限
                getPermission(Manifest.permission.BLUETOOTH_CONNECT);
                return;
            }</code></pre> 
<pre><code class="language-java">// 获取权限的方法
    private void getPermission(String permission) {
        // 请求权限
        XXPermissions.with(getContext())
                .permission(permission) // 申请单个权限
                .request(new OnPermissionCallback() {
                    @Override
                    public void onGranted(@NonNull List&lt;String&gt; permissions, boolean allGranted) {
                        if (!allGranted) {
                            // 如果未全部授予权限，则显示提示信息
                            Toast.makeText(getContext(), "获取部分权限成功，但部分权限未正常授予", Toast.LENGTH_SHORT).show();
                            Log.d("TAG", "获取部分权限成功");
                            return;
                        }
                        // 权限全部成功授予后的操作
                        Log.d("TAG", "获取权限成功");
                    }

                    @Override
                    public void onDenied(@NonNull List&lt;String&gt; permissions, boolean doNotAskAgain) {
                        if (doNotAskAgain) {
                            // 如果用户选择不再询问，则提示用户手动开启权限，并跳转到应用设置页面
                            Toast.makeText(getContext(), "被永久拒绝授权，请手动授予权限", Toast.LENGTH_SHORT).show();
                            Log.d("TAG", "被永久拒绝授权，请手动授予权限");
                            XXPermissions.startPermissionActivity(getContext(), permissions);
                        } else {
                            // 如果权限被拒绝但没有选择不再询问，则显示失败提示
                            Toast.makeText(getContext(), "获取权限失败", Toast.LENGTH_SHORT).show();
                            Log.d("TAG", "获取权限失败");
                        }
                    }
                });
    }</code></pre> 
<p>经典蓝牙BT开发流程</p> 
<p><img alt="" height="517" src="https://images2.imgbox.com/ed/9f/uaZ6UpNX_o.png" width="500"></p> 
<p>备注：后面几节讲解的都是以BLE为例子</p> 
<p></p> 
<p>这就是开始使用蓝牙开发所需了解的基础知识。</p> 
<p></p> 
<p>我们继续下一节。</p> 
<p></p> 
<h4><span style="color:#0d0016;">第二节：启用蓝牙和检查设备支持</span></h4> 
<p><br> 在这一节中，我们将学习如何在你的应用中启用蓝牙功能，并检查用户的设备是否支持蓝牙。</p> 
<h5><span style="color:#0d0016;">1. 获取蓝牙适配器</span></h5> 
<p><br> 首先，你需要获取<span style="color:#fe2c24;"><strong>BluetoothAdapter</strong></span>的实例，它是所有蓝牙操作的入口点。</p> 
<pre><code class="language-java">BluetoothAdapter bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();</code></pre> 
<p>如果<span style="color:#0d0016;"><strong>getDefaultAdapter()</strong></span>返回null，则表示<span style="color:#0d0016;"><strong>设备不支持蓝牙</strong></span>。</p> 
<p></p> 
<h5><span style="color:#0d0016;">2. 检查蓝牙是否启用</span></h5> 
<p><br> 接下来，检查蓝牙是否已经启用。使用<strong>BluetoothAdapter</strong>的<span style="color:#fe2c24;"><strong>is<strong>Enabled</strong>()</strong></span>方法可以检查蓝牙是否启用：</p> 
<pre><code class="language-java">if (bluetoothAdapter != null &amp;&amp; !bluetoothAdapter.isEnabled()) {
    // 蓝牙未启用
}</code></pre> 
<p>bluetoothAdapter != null 说明设备支持蓝牙</p> 
<p>!bluetoothAdapter.isEnabled() 说明蓝牙没启用</p> 
<p></p> 
<h5><span style="color:#0d0016;">3. 请求用户启用蓝牙</span></h5> 
<p><br> 如果蓝牙未启用，你可以<span style="color:#0d0016;"><strong>请求用户启用它</strong></span>。</p> 
<p>这可以<u>通过启动一个Intent来请求用户启用蓝牙，而不是直接调用enable()方法，因为<span style="color:#fe2c24;"><strong>enable()</strong></span>方法<span style="color:#fe2c24;">无需</span>用户同意即可启用蓝牙，这可能不是最佳用户体验</u>。</p> 
<pre><code class="language-java">Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);

startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);</code></pre> 
<p></p> 
<p>在这里，<strong>REQUEST_ENABLE_BT</strong>是应用定义的<strong><span style="color:#fe2c24;">整数请求码</span></strong>，用于在你的Activity的onActivityResult回调中接收结果。</p> 
<p></p> 
<h5><span style="color:#0d0016;">4. onActivityResult回调</span></h5> 
<p>当用户响应启用蓝牙的请求时，系统会调用你的Activity的<span style="color:#fe2c24;"><strong>onActivityResult</strong></span>方法。</p> 
<p>你可以在这里检查请求的结果：</p> 
<pre><code class="language-java">@Override

protected void onActivityResult(int requestCode, int resultCode, Intent data) {

    super.onActivityResult(requestCode, resultCode, data);

    if (requestCode == REQUEST_ENABLE_BT) {

        if (resultCode == RESULT_OK) {

            // 用户启用了蓝牙

        } else {

            // 用户未启用蓝牙

        }

    }

}</code></pre> 
<p>这就是如何在你的应用中启用蓝牙并检查设备是否支持蓝牙的基本步骤，理解这些步骤是进行蓝牙开发的基础。</p> 
<p></p> 
<h4><span style="color:#0d0016;">第三节：发现设备和获取已配对设备</span></h4> 
<p><br> 在这一节中，我们将学习<u>如何发现附近的蓝牙设备</u>以及<u>如何获取已经与你的设备配对的蓝牙设备列表。</u></p> 
<h5><span style="color:#0d0016;">1. 获取已配对设备</span></h5> 
<p>你的Android设备可能已经与一些蓝牙设备配对过了。</p> 
<p>要获取这些已配对的设备列表，你可以使用BluetoothAdapter的<span style="color:#fe2c24;"><strong>getBondedDevices()</strong></span>方法：</p> 
<pre><code class="language-java">Set&lt;BluetoothDevice&gt; pairedDevices = bluetoothAdapter.getBondedDevices();
if (pairedDevices.size() &gt; 0) {
    // 至少有一个已配对设备
    for (BluetoothDevice device : pairedDevices) {
        String deviceName = device.getName();
        String deviceHardwareAddress = device.getAddress(); // MAC地址
         Log.d("TAG", "蓝牙设备名称："+deviceName);
         Log.d("TAG", "蓝牙设备地址："+deviceHardwareAddress);
    
                                                    }
}</code></pre> 
<h6></h6> 
<h6></h6> 
<h5><span style="color:#0d0016;">2. 发现新设备</span></h5> 
<p><br> 要发现附近的蓝牙设备，你需要调用BluetoothAdapter的<span style="color:#fe2c24;"><strong>startDiscovery()</strong></span>方法。这个方法是<span style="color:#0d0016;"><strong>异步</strong></span>的，发现过程通常会持续<span style="color:#0d0016;"><strong>12秒</strong></span>。<br><br> 你<u>需要<span style="color:#0d0016;"><strong>注册</strong></span>一个BroadcastReceiver来<span style="color:#0d0016;"><strong>监听</strong></span>BluetoothDevice.ACTION_FOUND<span style="color:#0d0016;"><strong>广播</strong></span></u>，这个广播会在发现新设备时发送。</p> 
<pre><code class="language-java">// 注册广播接收器以监听发现的设备
IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND);
registerReceiver(receiver, filter);

// 发现设备
if (bluetoothAdapter.startDiscovery()) {
    // 发现过程成功启动
}</code></pre> 
<p>疑问：</p> 
<p>BluetoothDevice.ACTION_FOUND 是一个什么值？</p> 
<p>解答：</p> 
<ul><li>BluetoothDevice.ACTION_FOUND 是一个<span style="color:#fe2c24;">字符串常量</span>，用于在广播中<u>标识</u>已找到一个蓝牙设备，值是"android.bluetooth.device.action.FOUND"。</li><li>当你的应用调用BluetoothAdapter的startDiscovery()方法开始扫描附近的蓝牙设备时，<u>每发现一个设备，系统就会发送这个ACTION_FOUND的广播</u>。</li><li>你的应用可以通过注册一个BroadcastReceiver来监听这个广播，以便获取每个发现的蓝牙设备的信息。</li></ul> 
<p></p> 
<p>在你的BroadcastReceiver中，你可以获取发现的设备信息：</p> 
<pre><code class="language-java">private final BroadcastReceiver receiver = new BroadcastReceiver() {
    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();
        if (BluetoothDevice.ACTION_FOUND.equals(action)) {
            // 从Intent中获取发现的BluetoothDevice
            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
            String deviceName = device.getName();
            String deviceHardwareAddress = device.getAddress(); // MAC地址
        }
    }
};</code></pre> 
<p><img alt="" height="418" src="https://images2.imgbox.com/b0/12/GHdpeKcT_o.png" width="950"></p> 
<p></p> 
<p><strong>疑问：</strong></p> 
<h5><strong>action有几种？</strong></h5> 
<p><strong>解答：</strong><br><br> - BluetoothDevice.ACTION_ACL_CONNECTED：当与远程设备<span style="color:#0d0016;"><strong>建立低级别（ACL）连接时</strong></span>发送的广播。<br><br> - BluetoothDevice.ACTION_ACL_DISCONNECT_REQUESTED：当系统要<span style="color:#0d0016;"><strong>断开与远程设备的低级别（ACL）连接时</strong></span>发送的广播。<br><br> - BluetoothDevice.ACTION_ACL_DISCONNECTED：当与远程设备的<span style="color:#0d0016;"><strong>低级别（ACL）连接断开时</strong></span>发送的广播。<br><br> - BluetoothDevice.ACTION_BOND_STATE_CHANGED：当远程设备的<span style="color:#0d0016;"><strong>配对状态发生变化时</strong></span>发送的广播。<br><br> - BluetoothDevice.ACTION_NAME_CHANGED：当<span style="color:#0d0016;"><strong>远程设备的名称发生变化时</strong></span>发送的广播。<br><br> - BluetoothDevice.ACTION_PAIRING_REQUEST：在<span style="color:#0d0016;"><strong>需要配对时</strong></span>发送的广播，通常是因为配对过程<span style="color:#0d0016;"><strong>需要输入PIN码</strong></span>或<span style="color:#0d0016;"><strong>确认配对</strong></span>。<br><br> - BluetoothAdapter.ACTION_DISCOVERY_STARTED：当设备<span style="color:#0d0016;"><strong>发现开始时</strong></span>发送的广播。<br><br> - BluetoothAdapter.ACTION_DISCOVERY_FINISHED：当设备<span style="color:#0d0016;"><strong>发现结束时</strong></span>发送的广播。<br><br> - BluetoothAdapter.ACTION_STATE_CHANGED：当蓝牙<span style="color:#0d0016;"><strong>适配器的状态发生变化时</strong></span>发送的广播，例如蓝牙被开启或关闭。<br><br>  </p> 
<p><span style="color:#fe2c24;">监听这些action可以让你的应用更好地与蓝牙设备交互。</span></p> 
<p></p> 
<p>例如，</p> 
<p>通过监听ACTION_BOND_STATE_CHANGED，你的应用可以<u>知道何时一个设备已经成功配对，或者配对失败。</u></p> 
<p>通过监听ACTION_ACL_CONNECTED和ACTION_ACL_DISCONNECTED，你的应用可以<u>知道何时设备连接或断开连接</u>。</p> 
<p></p> 
<p>可以在这些节点做一些处理。</p> 
<p></p> 
<h5><span style="color:#0d0016;">3. 停止发现</span></h5> 
<p><br> 由于发现过程会消耗大量资源，一旦你找到了你感兴趣的设备，或者你想停止扫描，你应该使用<span style="color:#fe2c24;"><strong>cancelDiscovery()</strong></span>方法来停止发现过程：</p> 
<pre><code class="language-java">bluetoothAdapter.cancelDiscovery();</code></pre> 
<p></p> 
<h5><span style="color:#0d0016;">4. 清理</span></h5> 
<p><br> 记得在不再需要时，<span style="color:#fe2c24;"><strong>unregisterReceiver(receiver)</strong></span>注销你的BroadcastReceiver，例如，在你的Activity或Fragment的onDestroy()方法中：</p> 
<pre><code class="language-java">@Override

protected void onDestroy() {

    super.onDestroy();

    // 确保我们不再监听广播

    unregisterReceiver(receiver);

}</code></pre> 
<p></p> 
<p>这就是如何发现新设备以及获取已配对设备的基本步骤。</p> 
<p>理解这些步骤对于开发能够与其他蓝牙设备交互的应用是非常重要的。<br><br> 当你准备好了，请告诉我，以便我们继续下一节。</p> 
<p></p> 
<h4><span style="color:#0d0016;">第四节：连接到蓝牙设备</span></h4> 
<p><br> 在这一节中，我们将学习如何使用<strong>BluetoothSocket</strong>来连接到一个蓝牙设备。连接到设备是进行数据交换的前提。</p> 
<h6></h6> 
<h5><span style="color:#0d0016;">1. 创建BluetoothSocket</span></h5> 
<p><br> 要与远程蓝牙设备建立连接，首先需要创建一个<span style="color:#fe2c24;"><strong>BluetoothSocket</strong></span>。</p> 
<p>BluetoothSocket代表了<span style="color:#0d0016;"><strong>蓝牙套接字的接口</strong></span>，它是两个设备之间通信的通道。<br><br> 对于大多数用途，你将使用<span style="color:#0d0016;"><strong>createRfcommSocketToServiceRecord(UUID)</strong></span>方法来创建BluetoothSocket。</p> 
<p>这个方法需要一个UUID参数，这个<span style="background-color:#ffd900;">UUID必须是你想要连接的远程设备上的蓝牙服务的UUID</span>。UUID代表通用唯一标识符，用于唯一标识你的应用的蓝牙服务。</p> 
<pre><code class="language-java">BluetoothDevice device = ... // 获取一个BluetoothDevice对象

UUID MY_UUID = UUID.fromString("00001101-0000-1000-8000-00805f9b34fb"); // 示例UUID

BluetoothSocket socket = device.createRfcommSocketToServiceRecord(MY_UUID);</code></pre> 
<p></p> 
<p>有几个概念：</p> 
<ul><li>服务UUID</li><li>特征UUID</li><li>描述UUID</li><li>公共标准UUID</li></ul> 
<p></p> 
<h5><span style="color:#0d0016;">2. 连接到远程设备</span></h5> 
<p><br> 创建BluetoothSocket后，你可以调用它的<span style="color:#fe2c24;"><strong>connect()</strong></span>方法来尝试与远程设备建立连接。</p> 
<p>这个方法是<span style="color:#fe2c24;"><strong>阻塞调用</strong></span><strong>（</strong>直到连接成功或抛出异常）。</p> 
<pre><code class="language-java">try {

    socket.connect();

    // 连接成功，可以开始进行数据交换

} catch (IOException e) {

    // 连接失败

    e.printStackTrace();

}</code></pre> 
<p></p> 
<h5><span style="color:#0d0016;">3. 数据交换</span></h5> 
<p><br> 连接成功后，你可以通过BluetoothSocket的<span style="color:#0d0016;"><strong>输入输出流</strong></span>来进行数据的读写。</p> 
<pre><code class="language-java">try {

    InputStream inputStream = socket.getInputStream();

    OutputStream outputStream = socket.getOutputStream();

    // 从InputStream读取数据

    byte[] buffer = new byte[1024];

    int bytes;

    bytes = inputStream.read(buffer);

    String receivedData = new String(buffer, 0, bytes);

    // 向OutputStream写入数据

    String dataToSend = "Hello, Bluetooth!";

    outputStream.write(dataToSend.getBytes());

} catch (IOException e) {

    // 处理异常

}</code></pre> 
<p></p> 
<h5><span style="color:#0d0016;">4. 断开连接</span></h5> 
<p><br> 完成数据交换后，应该关闭BluetoothSocket来<span style="color:#0d0016;"><strong>释放资源</strong></span>。</p> 
<pre><code class="language-java">try {

    socket.close();

} catch (IOException e) {

    // 处理异常

}</code></pre> 
<p></p> 
<p><strong><span style="color:#fe2c24;">注意事项</span></strong></p> 
<p><br> - 连接过程可能会花费一些时间，<span style="background-color:#ffd900;">建议在一个单独的线程中进行连接操作</span>，以避免阻塞UI线程。<br> - 确保你的UUID与远程设备提供的服务UUID匹配。<br> - 在连接过程中和之后，要妥善处理异常。</p> 
<p>疑问：</p> 
<h5>我听同事说发送数据还有片段发送，是怎么样的</h5> 
<p>解答：</p> 
<p></p> 
<p>在蓝牙通信中，<span style="background-color:#ffd900;">由于蓝牙协议本身的限制以及不同设备的性能差异，发送大量数据时直接发送整个数据包可能会导致数据传输失败或者效率低下。</span></p> 
<p>因此，将大数据分割成小片段（fragments）进行发送是一种常见的做法，这就是所谓的“<span style="color:#0d0016;"><strong>片段发送</strong></span>”或“<span style="color:#0d0016;"><strong>数据分片</strong></span>”。</p> 
<p></p> 
<h6><span style="color:#0d0016;">1.数据分片的基本思想</span></h6> 
<p><br> 数据分片的基本思想，是将大的数据包分割成多个较小的数据片段，然后逐个片段地发送这些数据。接收方收到所有片段后，再将它们<span style="color:#0d0016;"><strong>重新组合</strong></span>成原始的数据包。</p> 
<h6></h6> 
<h6><span style="color:#0d0016;">2.如何实现数据分片?</span></h6> 
<p><br> 实现数据分片的一个简单方法是：</p> 
<ul><li><strong>（1）确定片段大小：</strong> 
  <ul><li>首先，你需要确定每个数据片段的大小。 
    <ul><li>这个大小需要根据你的应用需求和蓝牙硬件的能力来决定。一个常见的做法是使用<span style="color:#fe2c24;">512字节</span>作为每个片段的大小。</li></ul></li></ul></li><li><strong>（2）分割数据</strong>： 
  <ul><li>将你的数据分割成多个片段。 
    <ul><li>如果数据大小不是片段大小的整数倍，最后一个片段可能会更小。</li></ul></li></ul></li><li><strong>（3）发送数据片段：</strong> 
  <ul><li>逐个发送每个数据片段。 
    <ul><li>在每个片段发送之后，<u>可能需要等待接收方的确认，再发送下一个片段</u>。</li></ul></li></ul></li><li><strong>（4）接收方重组数据：</strong> 
  <ul><li>接收方需要按照发送顺序接收并存储每个数据片段。 
    <ul><li>一旦所有片段都被接收，接收方就可以将它们组合成原始的数据包。</li></ul></li></ul></li></ul> 
<h5>示例代码</h5> 
<p><br> 以下是一个简化的示例，展示了如何将一个大的字节数组分割成多个片段并发送：</p> 
<pre><code class="language-java">OutputStream outputStream = bluetoothSocket.getOutputStream();

byte[] largeData = ...; // 假设这是要发送的大数据

int chunkSize = 512; // 片段大小

int offset = 0;

while (offset &lt; largeData.length) {

    // 计算剩余数据大小

    int remaining = largeData.length - offset;

    int byteCount = Math.min(remaining, chunkSize); // 这次发送的字节数

    // 发送数据片段

    outputStream.write(largeData, offset, byteCount);

    outputStream.flush(); // 确保数据被发送

    offset += byteCount; // 更新偏移量

    // 可选：等待接收方的确认

}

// 数据发送完毕</code></pre> 
<h5><span style="color:#fe2c24;">注意事项</span></h5> 
<p><br> - 数据分片会增加通信的复杂度，特别是在需要确保数据完整性和顺序的情况下。<br> - 接收方需要有相应的逻辑来处理接收到的数据片段，包括片段的重组和可能的错误处理。<br> - 在实际应用中，可能还需要考虑如何处理数据传输中的错误，例如重传丢失的片段。<br><br> 通过数据分片，你可以更可靠地通过蓝牙发送大量数据，同时还可以提高数据传输的效率。</p> 
<p></p> 
<h5>示例代码 </h5> 
<p>获取蓝牙设备电量</p> 
<pre><code class="language-java">public  void getBluetoothDeviceBattery() {
    BluetoothAdapter btAdapter = BluetoothAdapter.getDefaultAdapter();
    //获取BluetoothAdapter的Class对象
    Class&lt;BluetoothAdapter&gt; bluetoothAdapterClass = BluetoothAdapter.class;
    try {
        //反射获取蓝牙连接状态的方法
        Method method = bluetoothAdapterClass.getDeclaredMethod("getConnectionState", (Class[]) null);
        //打开使用这个方法的权限
        method.setAccessible(true);
        int state = (int) method.invoke(btAdapter, (Object[]) null);

        if (state == BluetoothAdapter.STATE_CONNECTED) {
            //获取在系统蓝牙的配对列表中的设备--！已连接设备包含在其中
            if (ActivityCompat.checkSelfPermission(this,
                    android.Manifest.permission.BLUETOOTH_CONNECT) != PackageManager.PERMISSION_GRANTED) {
                Log.e(TAG,  "没有权限");
                return;
            }
            Set&lt;BluetoothDevice&gt; devices = btAdapter.getBondedDevices();
            for (BluetoothDevice device : devices) {
                Method batteryMethod = BluetoothDevice.class.getDeclaredMethod("getBatteryLevel", (Class[]) null);
                batteryMethod.setAccessible(true);
                Method isConnectedMethod = BluetoothDevice.class.getDeclaredMethod("isConnected", (Class[]) null);
                isConnectedMethod.setAccessible(true);
                boolean isConnected = (boolean) isConnectedMethod.invoke(device, (Object[]) null);
                int level = (int) batteryMethod.invoke(device, (Object[]) null);
                if (device != null &amp;&amp; level &gt; 0 &amp;&amp; isConnected) {
                    String deviceName = device .getName();
                  //  LogUtils.d(deviceName + "    电量:  " + level);
                    Log.e(TAG, deviceName + "    电量:  " + level);
                }
            }
        } else {
           // ToastUtils.showLong("No Connected Bluetooth Devices Found");
            Log.e(TAG,  "No Connected Bluetooth Devices Found");
        }
    } catch (Exception e) {
        Log.e(TAG,  "Exception"+e.toString());
        e.printStackTrace();
    }

}</code></pre> 
<p></p> 
<p><br><br> 总之，这就是如何连接到蓝牙设备并进行数据交换的基本步骤。理解这些步骤对于开发能够与其他蓝牙设备交互的应用是非常重要的。<br><br> 当你准备好了，请告诉我，以便我们继续下一节。</p> 
<p></p> 
<h4><span style="color:#0d0016;">第五节：管理蓝牙连接</span></h4> 
<p><br> 在这一节中，我们将讨论<span style="color:#0d0016;"><strong>如何管理蓝牙连接</strong></span>，包括：<u>数据的接收处理</u>、<u>连接的维护</u>和<u>断开连接</u>的正确方式。</p> 
<h5><span style="color:#0d0016;">1. 接收数据</span></h5> 
<p><br> 在前一节中，我们讨论了如何发送数据。接收数据同样重要，通常涉及到从BluetoothSocket的输入流中读取数据。</p> 
<p>由于数据接收是阻塞操作，推荐在单独的线程中进行读取操作，以避免阻塞UI线程。</p> 
<pre><code class="language-java">class ConnectedThread extends Thread {

    private final BluetoothSocket socket;

    private final InputStream inputStream;

    private final OutputStream outputStream;

    public ConnectedThread(BluetoothSocket socket) {

        this.socket = socket;

        InputStream tmpIn = null;

        OutputStream tmpOut = null;

        try {

            tmpIn = socket.getInputStream();

            tmpOut = socket.getOutputStream();

        } catch (IOException e) {

            e.printStackTrace();

        }

        inputStream = tmpIn;

        outputStream = tmpOut;

    }

    public void run() {

        byte[] buffer = new byte[1024];  // 缓冲区

        int bytes; // 读取的字节数

        while (true) {

            try {

                // 从InputStream读取数据

                bytes = inputStream.read(buffer);

                String receivedData = new String(buffer, 0, bytes);

                // 处理接收到的数据

            } catch (IOException e) {

                // 连接丢失时的处理

                break;

            }

        }

    }

    // 调用此方法从外部发送数据

    public void write(byte[] bytes) {

        try {

            outputStream.write(bytes);

        } catch (IOException e) {

            e.printStackTrace();

        }

    }

    // 调用此方法关闭连接

    public void cancel() {

        try {

            socket.close();

        } catch (IOException e) {

            e.printStackTrace();

        }

    }

}</code></pre> 
<p></p> 
<h5><span style="color:#0d0016;">2. 维护连接</span></h5> 
<p><br> 维护蓝牙连接的关键，在于<span style="background-color:#ffd900;">处理各种可能导致连接中断的情况。</span></p> 
<p>例如，设备的<span style="color:#fe2c24;">距离过远</span>、<span style="color:#fe2c24;">干扰</span>或<span style="color:#fe2c24;">设备关闭</span>。</p> 
<p>在<strong>ConnectedThread</strong>的<strong>run</strong>方法中，如果<span style="color:#fe2c24;"><strong>inputStream.read(buffer)</strong></span>抛出IOException，通常<span style="background-color:#ffd900;">意味着连接已经丢失</span>，此时应当关闭socket并尝试重新连接或更新UI。</p> 
<p></p> 
<h5><span style="color:#0d0016;">3. 断开连接</span></h5> 
<p><br> 当不再需要蓝牙连接时，正确的断开连接是很重要的。这包括关闭<strong>BluetoothSocket</strong>，以及与之关联的输入输出流。</p> 
<p>在<strong>ConnectedThread</strong>类中，我们提供了一个<span style="color:#fe2c24;"><strong>cancel</strong></span>方法来做这件事。调用cancel可以<span style="background-color:#ffd900;">安全地关闭socket并终止线程</span>。</p> 
<pre><code class="language-java">public void cancel() {

    try {

        socket.close();

    } catch (IOException e) {

        e.printStackTrace();

    }

}</code></pre> 
<p></p> 
<p></p> 
<h5><span style="color:#0d0016;">4. 重连策略</span></h5> 
<p><br> 在实际应用中，可能需要实现<span style="color:#fe2c24;">自动重连</span>的逻辑。这通常涉及到在<span style="background-color:#ffd900;">连接丢失后等待一段时间，然后尝试重新连接到设备</span>。</p> 
<p>重连策略的实现会根据具体的应用需求而有所不同，但<span style="background-color:#ffd900;">基本思路是在捕获到连接丢失的异常后，延迟一段时间后再次尝试连接</span>。<br><br> 这就是关于管理蓝牙连接的基本知识。通过正确地管理连接，你的应用可以更加稳定，为用户提供更好的体验。<br><br> 当你准备好了，请告诉我，以便我们继续下一节。</p> 
<p></p> 
<p></p> 
<h4><span style="color:#0d0016;">第六节：蓝牙服务和特征</span></h4> 
<p><br> 在这一节中，我们将探讨使用<span style="color:#0d0016;"><strong>蓝牙低功耗（</strong></span><span style="color:#fe2c24;"><strong>BLE</strong></span><span style="color:#0d0016;"><strong>）</strong></span>时的高级概念，特别是<span style="color:#0d0016;"><strong>蓝牙服务</strong></span>和<span style="color:#0d0016;"><strong>特征</strong></span>的概念。这些概念对于理解和开发BLE应用至关重要。</p> 
<h5><span style="color:#0d0016;">1. BLE简介</span></h5> 
<p><br> 蓝牙低功耗（BLE），也称为蓝牙4.0 或 蓝牙Smart，是蓝牙技术的一个版本，专为低功耗设备设计，<span style="background-color:#ffd900;">适用于需要长期运行在电池供电下的设备</span>。与经典蓝牙相比，BLE在保持通信能力的同时，大大降低了能耗。</p> 
<p></p> 
<h5><span style="color:#0d0016;">2. 服务和特征</span></h5> 
<p><br> 在BLE中，数据交换是通过服务（Services）和特征（Characteristics）的概念来组织的。<br><br><strong>- 服务（<span style="color:#fe2c24;">Service</span>）：</strong></p> 
<p>        服务是一组功能相关的特征的集合。每个服务都由一个唯一的UUID来标识。</p> 
<p><br><strong>- 特征（<span style="color:#fe2c24;">Characteristic</span>）：</strong></p> 
<p>        特征表示服务中的一个数据点，例如一个传感器的值或者一个配置参数。特征包含一个值以及0到多个描述符（Descriptors），用于描述特征的属性。特征也由UUID标识。</p> 
<p></p> 
<h5><span style="color:#0d0016;">3. 发现服务和特征</span></h5> 
<p><br> 当你的设备与一个BLE设备建立连接后，下一步通常是<span style="background-color:#ffd900;">发现远程设备提供的服务和特征</span>。这可以通过调用<span style="color:#0d0016;"><strong>BluetoothGatt对象</strong></span>的<strong><span style="color:#fe2c24;">discoverServices()</span></strong>方法来完成。</p> 
<p>服务发现完成后，你可以通过调用<span style="color:#fe2c24;"><strong>getServices()</strong></span>方法来<span style="background-color:#ffd900;">获取服务列表</span>，然后<span style="background-color:#ffd900;">遍历这些服务以查找特定的服务和特征</span>。</p> 
<pre><code class="language-java">@Override

public void onServicesDiscovered(BluetoothGatt gatt, int status) {

    if (status == BluetoothGatt.GATT_SUCCESS) {

        for (BluetoothGattService service : gatt.getServices()) {

            UUID serviceUUID = service.getUuid();

            // 检查是否是我们感兴趣的服务UUID

            for (BluetoothGattCharacteristic characteristic : service.getCharacteristics()) {

                UUID characteristicUUID = characteristic.getUuid();

                // 检查是否是我们感兴趣的特征UUID

            }

        }

    } else {

        Log.w(TAG, "onServicesDiscovered received: " + status);

    }

}</code></pre> 
<p></p> 
<p></p> 
<h5><span style="color:#0d0016;">4. 读写特征</span></h5> 
<p><br> 一旦找到了感兴趣的特征，你可以读取特征的值或向其写入值。<br><br> -<span style="color:#0d0016;"><strong> </strong></span><span style="color:#fe2c24;"><strong>读取</strong></span><span style="color:#0d0016;"><strong>特征值：</strong></span></p> 
<p><span style="color:#0d0016;"><strong>                </strong></span>调用<strong>BluetoothGatt</strong>的<span style="color:#fe2c24;"><strong>readCharacteristic()</strong></span>方法。</p> 
<p><br><span style="color:#0d0016;"><strong>- </strong></span><span style="color:#fe2c24;"><strong>写入</strong></span><span style="color:#0d0016;"><strong>特征值：</strong></span></p> 
<p>                首先设置特征的值，然后调用<strong>BluetoothGatt</strong>的<span style="color:#fe2c24;"><strong>writeCharacteristic()</strong></span>方法。</p> 
<pre><code class="language-java">// 读取特征值

gatt.readCharacteristic(characteristic);

// 写入特征值

characteristic.setValue(value);

gatt.writeCharacteristic(characteristic);</code></pre> 
<p></p> 
<p></p> 
<h5><span style="color:#0d0016;">5. 订阅特征通知</span></h5> 
<p><br> 对于一些特征，你可能希望<span style="background-color:#ffd900;">当特征的值发生变化时得到通知</span>。</p> 
<p>这可以<span style="color:#fe2c24;">通过对特征启用通知来实现</span> BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE</p> 
<p>这通常涉及到写入特征的一个相关描述符。</p> 
<pre><code class="language-java">BluetoothGattDescriptor descriptor = characteristic.getDescriptor(

        UUID.fromString(CLIENT_CHARACTERISTIC_CONFIG));

descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);

gatt.writeDescriptor(descriptor);</code></pre> 
<p></p> 
<p>这就是BLE服务和特征的基本概念。</p> 
<p>通过理解和使用这些概念，你可以开发出能够与BLE设备进行复杂交互的应用。<br><br> 当你准备好了，请告诉我，以便我们继续下一节。</p> 
<p></p> 
<h4><span style="color:#0d0016;">第七节：蓝牙安全性和最佳实践</span></h4> 
<p><br> 在这一节中，我们将讨论蓝牙通信的<span style="color:#fe2c24;">安全性问题</span>以及开发蓝牙应用时的一些最佳实践。</p> 
<h5><span style="color:#0d0016;">1. 蓝牙安全性概述</span></h5> 
<p><br> 蓝牙技术包含多种安全特性，旨在保护通信不被未授权访问。这些安全特性包括配对过程中的认证和加密。然而，蓝牙设备和通信仍可能面临一些安全威胁，如中间人攻击（MITM）、身份欺骗等。因此，开发者在使用蓝牙技术时需要采取适当的安全措施。</p> 
<p></p> 
<h5><span style="color:#0d0016;">2. 使用安全的配对模式</span></h5> 
<p><br><span style="color:#0d0016;"><strong>- 配对过程：</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        </strong></span>在设备之间建立连接前，通常会进行配对过程，这个过程可以提供认证和加密。确保使用安全的配对模式，如Passkey Entry或Numeric Comparison，这些模式提供更高级别的安全性。</p> 
<p><br><span style="color:#0d0016;"><strong>- 注意保护PIN码：</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        </strong></span>如果你的应用需要用户输入PIN码来配对设备，确保这个过程是安全的，避免泄露PIN码。</p> 
<p></p> 
<h5><span style="color:#0d0016;">3. 管理已配对设备</span></h5> 
<p><br><span style="color:#0d0016;"><strong>- 信任的设备：</strong></span></p> 
<p>                只允许已知和信任的设备连接。对于不再使用的设备，应从系统中删除其配对信息。<br> - 定期检查配对设备：应用应定期检查已配对设备列表，移除不再需要的设备。</p> 
<p></p> 
<h5><span style="color:#0d0016;">4. 使用加密的数据传输</span></h5> 
<p><br><span style="color:#0d0016;"><strong>- 加密通信：</strong></span></p> 
<p><span style="color:#0d0016;"><strong>                </strong></span>确保数据传输过程中使用加密。对于BLE，一旦设备配对，<span style="background-color:#ffd900;">数据传输通常是加密的</span>。但是，开发者应验证加密确实被启用。</p> 
<p><br><span style="color:#0d0016;"><strong>- 敏感信息处理：</strong></span></p> 
<p>                对于<span style="background-color:#ffd900;">传输敏感信息</span>，考虑在<span style="background-color:#ffd900;">应用层再次加密数据</span>，以增加安全性。</p> 
<p></p> 
<h5><span style="color:#0d0016;">5. 最佳实践</span></h5> 
<p><br><span style="color:#0d0016;"><strong>- 最小权限原则：</strong></span>应用应仅请求完成其功能所必需的最小权限集合。<br><span style="color:#0d0016;"><strong>- 注意隐私问题：</strong></span>在处理用户数据和设备信息时，要注意用户隐私，遵守相关法律法规。<br><span style="color:#0d0016;"><strong>- 错误处理：</strong></span>妥善处理错误和异常，避免泄露敏感信息。<br><span style="color:#0d0016;"><strong>- 更新和维护：</strong></span>定期更新应用和蓝牙设备的固件，以修复已知的安全漏洞。</p> 
<p></p> 
<h5><span style="color:#0d0016;">6. 性能优化</span></h5> 
<p><br><span style="color:#0d0016;"><strong>- 节能策略：</strong></span></p> 
<p><span style="color:#0d0016;"><strong>                </strong></span>蓝牙操作可能会消耗大量电量，特别是在进行设备发现时。<span style="background-color:#ffd900;">合理安排发现过程，减少不必要的操作，可以帮助节省电量</span>。</p> 
<p><br><span style="color:#0d0016;"><strong>- 连接管理：</strong></span></p> 
<p><span style="color:#0d0016;"><strong>                </strong></span>合理管理蓝牙连接，避免不必要的连接和断开，可以<span style="background-color:#ffd900;">提高应用性能和用户体验</span>。<br><br> 通过遵循这些安全性指南和最佳实践，你可以开发出既安全又高效的蓝牙应用。这些措施有助于保护用户数据，提高应用的稳定性和可靠性。<br><br> 这标志着我们蓝牙开发基础教程的结束。如果你有任何问题，或者想要深入了解某个特定主题，请随时留言、点赞、加关注。</p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b7da1e8b7fa9a050405df69342abf237/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python官网进不去怎么办,python官方网站地址</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cfe2a97758900b53078b08164d1aed06/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于Android的电子书阅读器的设计与实现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>