<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构和算法——哈希查找冲突处理方法（开放地址法-线性探测、平方探测、双散列探测、再散列，分离链接法） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/d0e9b408d4e41dfb749ef294bf0fef2f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构和算法——哈希查找冲突处理方法（开放地址法-线性探测、平方探测、双散列探测、再散列，分离链接法）">
  <meta property="og:description" content="目录
开放地址法（Open Addressing）
线性探测（Linear Probing）
散列表查找性能分析
平方探测（Quadratic Probing） 定理
平方探测法的查找与插入
双散列探测法（Double Hashing） 再散列（Rehashing）
分离链接法（Separate Chaining）
平均查找次数
分离链接法的散列表实现
常用处理冲突的思路：
换个位置：开放定址法同一位置的冲突对象组织在一起：链地址法 开放地址法（Open Addressing） 一旦产生了冲突（该地址已有其它元素），就按某种规则去寻找另一空地址。
若发生了第次冲突，试探的下一个地址将增加，基本公式是：
的不同决定了不同的解决冲突方案：线性探测、平方探测、双散列。
线性探测：平方探测：双散列： 线性探测（Linear Probing） 线性探测法：以增量序列1,2，......，（TableSize-1）循环试探下一个存储地址。
通俗地来讲，就是当发生冲突时，将关键词&#43;1；检测地址是否为空，如果不为空，就继续&#43;1；如果为空，则表明不冲突了。
【例】设关键词序列为{47,7,29,11,9,84,54,20,30}，散列表表长TableSize = 13（装填因子）;散列函数为：.
用线性探测法处理冲突，列出依次插入后的散列表，并估算查找性能。
为了方便演示，我们先在不考虑冲突的情况下，把所有关键词的散列地址算出来：
关键词（key）4772911984542030散列地址h（key）3770971098 发现很多地方是冲突的，这次用线性探测法来试着解决冲突。
操作/地址0123456789101112说明插入4747无冲突插入7477无冲突插入2947729插入111147729无冲突插入911477299无冲突插入841147729984插入54114772998454插入2011477299845420插入301130477299845420 最终我们整理得到：
H（key）0123456789101112key1130477299845420冲突次数060010313 散列表查找性能分析 成功平均查找长度(ASLs)不成功平均查找长度(ASLu) ASLs：查找表中关键词的平均查找比较次数（等于其冲突次数加1） 即将所有元素的查找次数加起来，最后除以元素的个数
ASLu：不在散列表中的关键词的平均查找次数（不成功）
因为取余数的计算方式，所以所有不在散列表的关键词至多有p-1中情况（表不为空），例如例题中的散列函数，假设其表只有一个元素，那么其不在表中的情况就会有10种，我们一样考虑其需要比较几次。
余数为0的情况，表中位置[0]和[1]都不为空，所以需要比较3次；
余数为1的情况，表中位置[1]不为空，所以需要比较2次；
余数为2的情况，表中位置[2]为空，所以只需要比较1次；
余数为3的情况，表中位置[3]不为空，所以需要比较2次；
......
以此类推。
平方探测（Quadratic Probing） 平方探测法：以增量序列且循环试探下一个存储地址。
【例】设关键词序列为{47,7,29,11,9,84,54,20,30}，散列表表长TableSize = 11，散列函数为：.用平方探测法处理冲突，列出依次插入后的散列表，并估算ASLs。
关键词（key）4772911984542030散列地址h（key）3770971098 操作/地址012345678910说明插入4747无冲突插入7477无冲突插入2947729插入111147729无冲突插入911477299无冲突插入841147847299插入54114784729954无冲突插入2011204784729954插入301130204784729954 注意：用平方探测法，并不是有空间就一定能检测到的。
定理 如果散列表长度TableSize是某个4k&#43;3（k是正整数）形式的素数时，平方探测法就可以探查到整个散列表空间。
平方探测法的查找与插入 #define MAXTABLESIZE 100000 /* 允许开辟的最大散列表长度 */ typedef int ElementType; /* 关键词类型用整型 */ typedef int Index; /* 散列地址类型 */ typedef Index Position; /* 数据所在位置与散列地址是同一类型 */ /* 散列单元状态类型，分别对应：有合法元素、空单元、有已删除元素 */ typedef enum { Legitimate, Empty, Deleted } EntryType; typedef struct HashEntry Cell; /* 散列表单元类型 */ struct HashEntry{ ElementType Data; /* 存放元素 */ EntryType Info; /* 单元状态 */ }; typedef struct TblNode *HashTable; /* 散列表类型 */ struct TblNode { /* 散列表结点定义 */ int TableSize; /* 表的最大长度 */ Cell *Cells; /* 存放散列单元数据的数组 */ }; int NextPrime( int N ) { /* 返回大于N且不超过MAXTABLESIZE的最小素数 */ int i, p = (N%2)?">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-08-10T08:00:00+08:00">
    <meta property="article:modified_time" content="2023-08-10T08:00:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构和算法——哈希查找冲突处理方法（开放地址法-线性探测、平方探测、双散列探测、再散列，分离链接法）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%B3%95%EF%BC%88Open%20Addressing%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%B3%95%EF%BC%88Open%20Addressing%EF%BC%89" rel="nofollow">开放地址法（Open Addressing）</a></p> 
<p id="%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%EF%BC%88Linear%20Probing%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%EF%BC%88Linear%20Probing%EF%BC%89" rel="nofollow">线性探测（Linear Probing）</a></p> 
<p id="%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90" rel="nofollow">散列表查找性能分析</a></p> 
<p id="%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%B5%8B%EF%BC%88Quadratic%20Probing%EF%BC%89%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%B5%8B%EF%BC%88Quadratic%20Probing%EF%BC%89%C2%A0" rel="nofollow">平方探测（Quadratic Probing） </a></p> 
<p id="%E5%AE%9A%E7%90%86-toc" style="margin-left:80px;"><a href="#%E5%AE%9A%E7%90%86" rel="nofollow">定理</a></p> 
<p id="%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%B5%8B%E6%B3%95%E7%9A%84%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8F%92%E5%85%A5-toc" style="margin-left:40px;"><a href="#%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%B5%8B%E6%B3%95%E7%9A%84%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8F%92%E5%85%A5" rel="nofollow">平方探测法的查找与插入</a></p> 
<p id="%E5%8F%8C%E6%95%A3%E5%88%97%E6%8E%A2%E6%B5%8B%E6%B3%95%EF%BC%88Double%20Hashing%EF%BC%89%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%8F%8C%E6%95%A3%E5%88%97%E6%8E%A2%E6%B5%8B%E6%B3%95%EF%BC%88Double%20Hashing%EF%BC%89%C2%A0" rel="nofollow">双散列探测法（Double Hashing） </a></p> 
<p id="%E5%86%8D%E6%95%A3%E5%88%97%EF%BC%88Rehashing%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E5%86%8D%E6%95%A3%E5%88%97%EF%BC%88Rehashing%EF%BC%89" rel="nofollow">再散列（Rehashing）</a></p> 
<p id="%E5%88%86%E7%A6%BB%E9%93%BE%E6%8E%A5%E6%B3%95%EF%BC%88Separate%20Chaining%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E5%88%86%E7%A6%BB%E9%93%BE%E6%8E%A5%E6%B3%95%EF%BC%88Separate%20Chaining%EF%BC%89" rel="nofollow">分离链接法（Separate Chaining）</a></p> 
<p id="%E5%B9%B3%E5%9D%87%E6%9F%A5%E6%89%BE%E6%AC%A1%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E5%B9%B3%E5%9D%87%E6%9F%A5%E6%89%BE%E6%AC%A1%E6%95%B0" rel="nofollow">平均查找次数</a></p> 
<p id="%E5%88%86%E7%A6%BB%E9%93%BE%E6%8E%A5%E6%B3%95%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%E5%88%86%E7%A6%BB%E9%93%BE%E6%8E%A5%E6%B3%95%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0" rel="nofollow">分离链接法的散列表实现</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p>常用处理冲突的思路：</p> 
<ul><li>换个位置：<span style="color:#1a439c;">开放定址法</span></li><li>同一位置的冲突对象组织在一起：<span style="color:#1a439c;">链地址法</span></li></ul> 
<p></p> 
<h2 id="%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%B3%95%EF%BC%88Open%20Addressing%EF%BC%89">开放地址法（Open Addressing）</h2> 
<p>一旦产生了<span style="color:#1a439c;">冲突</span>（该地址已有其它元素），就按某种规则去<span style="color:#1a439c;">寻找另一空地址</span>。</p> 
<p>若发生了第<img alt="i" class="mathcode" src="https://images2.imgbox.com/78/bf/FmTN3X9a_o.png">次冲突，试探的下一个地址将增加<img alt="d_i" class="mathcode" src="https://images2.imgbox.com/4e/61/YRvqIQv6_o.png">，基本公式是：<img alt="h_i(key)=(h(key)+d_i)\: \: mod\: \: TableSize\: \: \: \: (1\leq i&lt; TableSize)" class="mathcode" src="https://images2.imgbox.com/0f/90/WcH3few3_o.png"></p> 
<p><img alt="d_i" class="mathcode" src="https://images2.imgbox.com/b7/de/UHAPg9C0_o.png">的不同决定了不同的解决冲突方案：线性探测、平方探测、双散列。</p> 
<ul><li>线性探测：<img alt="d_i=i" class="mathcode" src="https://images2.imgbox.com/1b/1b/lHefwUpO_o.png"></li><li>平方探测：<img alt="d_i=\pm \: i^2" class="mathcode" src="https://images2.imgbox.com/44/61/CSEDQQuu_o.png"></li><li>双散列：<img alt="d_i=i*h_2(key)" class="mathcode" src="https://images2.imgbox.com/de/8c/YAZISN7Y_o.png"></li></ul> 
<p></p> 
<h3 id="%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%EF%BC%88Linear%20Probing%EF%BC%89">线性探测（Linear Probing）</h3> 
<p>线性探测法：以增量序列1,2，......，（TableSize-1）循环试探下一个存储地址。</p> 
<p>通俗地来讲，就是当发生冲突时，将关键词+1；检测地址是否为空，如果不为空，就继续+1；如果为空，则表明不冲突了。</p> 
<blockquote> 
 <p>【例】设关键词序列为{47,7,29,11,9,84,54,20,30}，散列表表长TableSize = 13（装填因子<img alt="\alpha =9/13\approx 0.69" class="mathcode" src="https://images2.imgbox.com/bf/23/f5AWMirY_o.png">）;散列函数为：<img alt="h(key)=key\: \: \: mod\: \: \: 11" class="mathcode" src="https://images2.imgbox.com/a6/c6/BDBpVlG8_o.png">.</p> 
 <p>用<span style="color:#fe2c24;">线性探测法</span>处理冲突，列出依次插入后的散列表，并估算查找性能。</p> 
</blockquote> 
<p>为了方便演示，我们先在不考虑冲突的情况下，把所有关键词的散列地址算出来：</p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:670px;"><tbody><tr><th style="text-align:center;">关键词<span style="color:#1a439c;">（key）</span></th><td style="text-align:center;">47</td><td style="text-align:center;">7</td><td style="text-align:center;">29</td><td style="text-align:center;">11</td><td style="text-align:center;">9</td><td style="text-align:center;">84</td><td style="text-align:center;">54</td><td style="text-align:center;">20</td><td style="text-align:center;">30</td></tr><tr><th style="text-align:center;">散列地址<span style="color:#1a439c;">h（key）</span></th><td style="text-align:center;"><span style="color:#1a439c;">3</span></td><td style="text-align:center;"><span style="color:#1a439c;">7</span></td><td style="text-align:center;"><span style="color:#1a439c;">7</span></td><td style="text-align:center;"><span style="color:#1a439c;">0</span></td><td style="text-align:center;"><span style="color:#1a439c;">9</span></td><td style="text-align:center;"><span style="color:#1a439c;">7</span></td><td style="text-align:center;"><span style="color:#1a439c;">10</span></td><td style="text-align:center;"><span style="color:#1a439c;">9</span></td><td style="text-align:center;"><span style="color:#1a439c;">8</span></td></tr></tbody></table> 
<p> 发现很多地方是冲突的，这次用线性探测法来试着解决冲突。</p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:680px;"><tbody><tr><td style="text-align:center;">操作/地址</td><td style="text-align:center;">0</td><td style="text-align:center;width:31px;">1</td><td style="text-align:center;width:33px;">2</td><td style="text-align:center;">3</td><td style="text-align:center;">4</td><td style="text-align:center;">5</td><td style="text-align:center;">6</td><td style="text-align:center;">7</td><td style="text-align:center;">8</td><td style="text-align:center;">9</td><td style="text-align:center;">10</td><td style="text-align:center;">11</td><td style="text-align:center;">12</td><td style="text-align:center;">说明</td></tr><tr><td style="text-align:center;">插入47</td><td style="text-align:center;"></td><td style="text-align:center;width:31px;"></td><td style="text-align:center;width:33px;"></td><td style="text-align:center;"><span style="color:#fe2c24;">47</span></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">无冲突</td></tr><tr><td style="text-align:center;">插入7</td><td style="text-align:center;"></td><td style="text-align:center;width:31px;"></td><td style="text-align:center;width:33px;"></td><td style="text-align:center;">47</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"><span style="color:#fe2c24;">7</span></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">无冲突</td></tr><tr><td style="text-align:center;">插入29</td><td style="text-align:center;"></td><td style="text-align:center;width:31px;"></td><td style="text-align:center;width:33px;"></td><td style="text-align:center;">47</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"><span style="color:#1a439c;">7</span></td><td style="text-align:center;"><span style="color:#fe2c24;">29</span></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"><img alt="d_1=1" class="mathcode" src="https://images2.imgbox.com/80/6e/hBqo4MSq_o.png"></td></tr><tr><td style="text-align:center;">插入11</td><td style="text-align:center;"><span style="color:#fe2c24;">11</span></td><td style="text-align:center;width:31px;"></td><td style="text-align:center;width:33px;"></td><td style="text-align:center;">47</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">7</td><td style="text-align:center;">29</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">无冲突</td></tr><tr><td style="text-align:center;">插入9</td><td style="text-align:center;">11</td><td style="text-align:center;width:31px;"></td><td style="text-align:center;width:33px;"></td><td style="text-align:center;">47</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">7</td><td style="text-align:center;">29</td><td style="text-align:center;"><span style="color:#fe2c24;">9</span></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">无冲突</td></tr><tr><td style="text-align:center;">插入84</td><td style="text-align:center;">11</td><td style="text-align:center;width:31px;"></td><td style="text-align:center;width:33px;"></td><td style="text-align:center;">47</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"><span style="color:#1a439c;">7</span></td><td style="text-align:center;"><span style="color:#1a439c;">29</span></td><td style="text-align:center;"><span style="color:#1a439c;">9</span></td><td style="text-align:center;"><span style="color:#fe2c24;">84</span></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"><img alt="d_3=3" class="mathcode" src="https://images2.imgbox.com/ef/81/u9A7ehhN_o.png"></td></tr><tr><td style="text-align:center;">插入54</td><td style="text-align:center;">11</td><td style="text-align:center;width:31px;"></td><td style="text-align:center;width:33px;"></td><td style="text-align:center;">47</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">7</td><td style="text-align:center;">29</td><td style="text-align:center;">9</td><td style="text-align:center;"><span style="color:#1a439c;">84</span></td><td style="text-align:center;"><span style="color:#fe2c24;">54</span></td><td style="text-align:center;"></td><td style="text-align:center;"><img alt="d_1=1" class="mathcode" src="https://images2.imgbox.com/e4/a7/6OERASxQ_o.png"></td></tr><tr><td style="text-align:center;">插入20</td><td style="text-align:center;">11</td><td style="text-align:center;width:31px;"></td><td style="text-align:center;width:33px;"></td><td style="text-align:center;">47</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">7</td><td style="text-align:center;">29</td><td style="text-align:center;"><span style="color:#1a439c;">9</span></td><td style="text-align:center;"><span style="color:#1a439c;">84</span></td><td style="text-align:center;"><span style="color:#1a439c;">54</span></td><td style="text-align:center;"><span style="color:#fe2c24;">20</span></td><td style="text-align:center;"><img alt="d_3=3" class="mathcode" src="https://images2.imgbox.com/20/71/qu6Tbr5n_o.png"></td></tr><tr><td style="text-align:center;">插入30</td><td style="text-align:center;"><span style="color:#1a439c;">11</span></td><td style="text-align:center;width:31px;"><span style="color:#fe2c24;">30</span></td><td style="text-align:center;width:33px;"></td><td style="text-align:center;">47</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">7</td><td style="text-align:center;"><span style="color:#1a439c;">29</span></td><td style="text-align:center;"><span style="color:#1a439c;">9</span></td><td style="text-align:center;"><span style="color:#1a439c;">84</span></td><td style="text-align:center;"><span style="color:#1a439c;">54</span></td><td style="text-align:center;"><span style="color:#1a439c;">20</span></td><td style="text-align:center;"><img alt="d_6=6" class="mathcode" src="https://images2.imgbox.com/18/17/YHLjPUl7_o.png"></td></tr></tbody></table> 
<p>最终我们整理得到：</p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:680px;"><tbody><tr><th style="text-align:center;"><span style="color:#1a439c;">H（key）</span></th><td style="text-align:center;"><span style="color:#a5a5a5;">0</span></td><td style="text-align:center;"><span style="color:#a5a5a5;">1</span></td><td style="text-align:center;"><span style="color:#a5a5a5;">2</span></td><td style="text-align:center;"><span style="color:#a5a5a5;">3</span></td><td style="text-align:center;"><span style="color:#a5a5a5;">4</span></td><td style="text-align:center;"><span style="color:#a5a5a5;">5</span></td><td style="text-align:center;"><span style="color:#a5a5a5;">6</span></td><td style="text-align:center;"><span style="color:#a5a5a5;">7</span></td><td style="text-align:center;"><span style="color:#a5a5a5;">8</span></td><td style="text-align:center;"><span style="color:#a5a5a5;">9</span></td><td style="text-align:center;"><span style="color:#a5a5a5;">10</span></td><td style="text-align:center;"><span style="color:#a5a5a5;">11</span></td><td style="text-align:center;"><span style="color:#a5a5a5;">12</span></td></tr><tr><th style="text-align:center;"><span style="color:#1a439c;">key</span></th><td style="text-align:center;">11</td><td style="text-align:center;">30</td><td style="text-align:center;"></td><td style="text-align:center;">47</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">7</td><td style="text-align:center;">29</td><td style="text-align:center;">9</td><td style="text-align:center;">84</td><td style="text-align:center;">54</td><td style="text-align:center;">20</td></tr><tr><th style="text-align:center;"><span style="color:#1a439c;">冲突次数</span></th><td style="text-align:center;">0</td><td style="text-align:center;">6</td><td style="text-align:center;"></td><td style="text-align:center;">0</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">0</td><td style="text-align:center;">1</td><td style="text-align:center;">0</td><td style="text-align:center;">3</td><td style="text-align:center;">1</td><td style="text-align:center;">3</td></tr></tbody></table> 
<h4 id="%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90">散列表查找性能分析</h4> 
<ul><li>成功平均查找长度(ASLs)</li><li>不成功平均查找长度(ASLu)</li></ul> 
<p><span style="color:#1a439c;"><strong>ASLs</strong></span>：查找表中关键词的平均查找比较次数（等于其冲突次数加1） </p> 
<p>即将所有元素的查找次数加起来，最后除以元素的个数</p> 
<p><img alt="ASLs=\frac{1+7+1+1+2+1+4+2+4}{9}=\frac{23}{9}\approx 2.56" class="mathcode" src="https://images2.imgbox.com/34/f2/6hb3Rr7k_o.png"></p> 
<p></p> 
<p><span style="color:#1a439c;"><strong>ASLu</strong></span>：不在散列表中的关键词的平均查找次数（不成功）</p> 
<p>因为取余数的计算方式，所以所有不在散列表的关键词至多有p-1中情况（表不为空），例如例题中的散列函数，假设其表只有一个元素，那么其不在表中的情况就会有10种，我们一样考虑其需要比较几次。</p> 
<p>余数为0的情况，表中位置[0]和[1]都不为空，所以需要比较3次；</p> 
<p>余数为1的情况，表中位置[1]不为空，所以需要比较2次；</p> 
<p>余数为2的情况，表中位置[2]为空，所以只需要比较1次；</p> 
<p>余数为3的情况，表中位置[3]不为空，所以需要比较2次；</p> 
<p>......</p> 
<p>以此类推。</p> 
<p><img alt="ASLu=\frac{3+2+1+2+1+1+1+9+8+7+6}{11}=\frac{41}{11}\approx 3.73" class="mathcode" src="https://images2.imgbox.com/cb/ad/zICmuufq_o.png"></p> 
<p></p> 
<h3 id="%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%B5%8B%EF%BC%88Quadratic%20Probing%EF%BC%89%C2%A0">平方探测（Quadratic Probing） </h3> 
<p>平方探测法：以增量序列<img alt="1^2,{-1}^2,2^2,{-2}^2,......,q^2,{-q}^2" class="mathcode" src="https://images2.imgbox.com/e3/8f/vzZR0KO5_o.png">且<img alt="q\leq \left \lfloor TableSize/2 \right \rfloor" class="mathcode" src="https://images2.imgbox.com/c4/af/xhBVbslU_o.png">循环试探下一个存储地址。</p> 
<blockquote> 
 <p>【例】设关键词序列为{47,7,29,11,9,84,54,20,30}，散列表表长TableSize = 11，散列函数为：<img alt="h(key)=key\: \: mod\: \: 11" class="mathcode" src="https://images2.imgbox.com/99/f0/Rw57fTnu_o.png">.用<span style="color:#fe2c24;">平方探测法</span>处理冲突，列出依次插入后的散列表，并<span style="color:#1a439c;">估算ASLs</span>。</p> 
</blockquote> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:670px;"><tbody><tr><th style="text-align:center;">关键词<span style="color:#1a439c;">（key）</span></th><td style="text-align:center;">47</td><td style="text-align:center;">7</td><td style="text-align:center;">29</td><td style="text-align:center;">11</td><td style="text-align:center;">9</td><td style="text-align:center;">84</td><td style="text-align:center;">54</td><td style="text-align:center;">20</td><td style="text-align:center;">30</td></tr><tr><th style="text-align:center;">散列地址<span style="color:#1a439c;">h（key）</span></th><td style="text-align:center;"><span style="color:#1a439c;">3</span></td><td style="text-align:center;"><span style="color:#1a439c;">7</span></td><td style="text-align:center;"><span style="color:#1a439c;">7</span></td><td style="text-align:center;"><span style="color:#1a439c;">0</span></td><td style="text-align:center;"><span style="color:#1a439c;">9</span></td><td style="text-align:center;"><span style="color:#1a439c;">7</span></td><td style="text-align:center;"><span style="color:#1a439c;">10</span></td><td style="text-align:center;"><span style="color:#1a439c;">9</span></td><td style="text-align:center;"><span style="color:#1a439c;">8</span></td></tr></tbody></table> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:680px;"><tbody><tr><td style="text-align:center;">操作/地址</td><td style="text-align:center;">0</td><td style="text-align:center;">1</td><td style="text-align:center;">2</td><td style="text-align:center;">3</td><td style="text-align:center;">4</td><td style="text-align:center;">5</td><td style="text-align:center;">6</td><td style="text-align:center;">7</td><td style="text-align:center;">8</td><td style="text-align:center;">9</td><td style="text-align:center;">10</td><td style="text-align:center;">说明</td></tr><tr><td style="text-align:center;">插入47</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"><span style="color:#fe2c24;">47</span></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">无冲突</td></tr><tr><td style="text-align:center;">插入7</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">47</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"><span style="color:#fe2c24;">7</span></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">无冲突</td></tr><tr><td style="text-align:center;">插入29</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">47</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"><span style="color:#1a439c;">7</span></td><td style="text-align:center;"><span style="color:#fe2c24;">29</span></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"><img alt="d_1=1" class="mathcode" src="https://images2.imgbox.com/8a/49/xA1Lxdkh_o.png"></td></tr><tr><td style="text-align:center;">插入11</td><td style="text-align:center;"><span style="color:#fe2c24;">11</span></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">47</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">7</td><td style="text-align:center;">29</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">无冲突</td></tr><tr><td style="text-align:center;">插入9</td><td style="text-align:center;">11</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">47</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">7</td><td style="text-align:center;">29</td><td style="text-align:center;"><span style="color:#fe2c24;">9</span></td><td style="text-align:center;"></td><td style="text-align:center;">无冲突</td></tr><tr><td style="text-align:center;">插入84</td><td style="text-align:center;">11</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">47</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;"><span style="color:#fe2c24;">84</span></td><td style="text-align:center;"><span style="color:#1a439c;">7</span></td><td style="text-align:center;">29</td><td style="text-align:center;">9</td><td style="text-align:center;"></td><td style="text-align:center;"><img alt="d_2=-1" class="mathcode" src="https://images2.imgbox.com/11/bb/RnuuTNPn_o.png"></td></tr><tr><td style="text-align:center;">插入54</td><td style="text-align:center;">11</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">47</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">84</td><td style="text-align:center;">7</td><td style="text-align:center;">29</td><td style="text-align:center;">9</td><td style="text-align:center;"><span style="color:#fe2c24;">54</span></td><td style="text-align:center;">无冲突</td></tr><tr><td style="text-align:center;">插入20</td><td style="text-align:center;">11</td><td style="text-align:center;"></td><td style="text-align:center;"><span style="color:#fe2c24;">20</span></td><td style="text-align:center;">47</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">84</td><td style="text-align:center;">7</td><td style="text-align:center;"><span style="color:#1a439c;">29</span></td><td style="text-align:center;"><span style="color:#1a439c;">9</span></td><td style="text-align:center;"><span style="color:#1a439c;">54</span></td><td style="text-align:center;"><img alt="d_3=4" class="mathcode" src="https://images2.imgbox.com/58/fc/ELccXmaf_o.png"></td></tr><tr><td style="text-align:center;">插入30</td><td style="text-align:center;">11</td><td style="text-align:center;">30</td><td style="text-align:center;">20</td><td style="text-align:center;">47</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">84</td><td style="text-align:center;"><span style="color:#1a439c;">7</span></td><td style="text-align:center;"><span style="color:#1a439c;">29</span></td><td style="text-align:center;"><span style="color:#1a439c;">9</span></td><td style="text-align:center;"><span style="color:#1a439c;">54</span></td><td style="text-align:center;"><img alt="d_3=4" class="mathcode" src="https://images2.imgbox.com/ec/c4/vLgS3dSZ_o.png"></td></tr></tbody></table> 
<p>注意：用平方探测法，并不是有空间就一定能检测到的。</p> 
<h4 id="%E5%AE%9A%E7%90%86">定理</h4> 
<blockquote> 
 <p>如果散列表长度TableSize是某个<span style="color:#fe2c24;">4k+3</span>（k是正整数）形式的<span style="color:#fe2c24;">素数</span>时，<span style="color:#fe2c24;">平方探测法</span>就可以<span style="color:#fe2c24;">探查到整个散列表空间。</span></p> 
</blockquote> 
<p></p> 
<h3 id="%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%B5%8B%E6%B3%95%E7%9A%84%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8F%92%E5%85%A5">平方探测法的查找与插入</h3> 
<pre><code class="language-cpp">#define MAXTABLESIZE 100000 /* 允许开辟的最大散列表长度 */
typedef int ElementType;    /* 关键词类型用整型 */
typedef int Index;          /* 散列地址类型 */
typedef Index Position;     /* 数据所在位置与散列地址是同一类型 */
/* 散列单元状态类型，分别对应：有合法元素、空单元、有已删除元素 */
typedef enum { Legitimate, Empty, Deleted } EntryType;

typedef struct HashEntry Cell; /* 散列表单元类型 */
struct HashEntry{
    ElementType Data; /* 存放元素 */
    EntryType Info;   /* 单元状态 */
};

typedef struct TblNode *HashTable; /* 散列表类型 */
struct TblNode {   /* 散列表结点定义 */
    int TableSize; /* 表的最大长度 */
    Cell *Cells;   /* 存放散列单元数据的数组 */
};

int NextPrime( int N )
{ /* 返回大于N且不超过MAXTABLESIZE的最小素数 */
    int i, p = (N%2)? N+2 : N+1; /*从大于N的下一个奇数开始 */

    while( p &lt;= MAXTABLESIZE ) {
        for( i=(int)sqrt(p); i&gt;2; i-- )
            if ( !(p%i) ) break; /* p不是素数 */
        if ( i==2 ) break; /* for正常结束，说明p是素数 */
        else  p += 2; /* 否则试探下一个奇数 */
    }
    return p;
}

HashTable CreateTable( int TableSize )
{
    HashTable H;
    int i;

    H = (HashTable)malloc(sizeof(struct TblNode));
    /* 保证散列表最大长度是素数 */
    H-&gt;TableSize = NextPrime(TableSize);
    /* 声明单元数组 */
    H-&gt;Cells = (Cell *)malloc(H-&gt;TableSize*sizeof(Cell));
    /* 初始化单元状态为“空单元” */
    for( i=0; i&lt;H-&gt;TableSize; i++ )
        H-&gt;Cells[i].Info = Empty;

    return H;
}

Position Find( HashTable H, ElementType Key )
{
    Position CurrentPos, NewPos;
    int CNum = 0; /* 记录冲突次数 */

    NewPos = CurrentPos = Hash( Key, H-&gt;TableSize ); /* 初始散列位置 */
    /* 当该位置的单元非空，并且不是要找的元素时，发生冲突 */
    while( H-&gt;Cells[NewPos].Info!=Empty &amp;&amp; H-&gt;Cells[NewPos].Data!=Key ) {
                                           /* 字符串类型的关键词需要 strcmp 函数!! */
        /* 统计1次冲突，并判断奇偶次 */
        if( ++CNum%2 ){ /* 奇数次冲突 */
            NewPos = CurrentPos + (CNum+1)*(CNum+1)/4; /* 增量为+[(CNum+1)/2]^2 */
            if ( NewPos &gt;= H-&gt;TableSize )
                NewPos = NewPos % H-&gt;TableSize; /* 调整为合法地址 */
        }
        else { /* 偶数次冲突 */
            NewPos = CurrentPos - CNum*CNum/4; /* 增量为-(CNum/2)^2 */
            while( NewPos &lt; 0 )
                NewPos += H-&gt;TableSize; /* 调整为合法地址 */
        }
    }
    return NewPos; /* 此时NewPos或者是Key的位置，或者是一个空单元的位置（表示找不到）*/
}

bool Insert( HashTable H, ElementType Key )
{
    Position Pos = Find( H, Key ); /* 先检查Key是否已经存在 */

    if( H-&gt;Cells[Pos].Info != Legitimate ) { /* 如果这个单元没有被占，说明Key可以插入在此 */
        H-&gt;Cells[Pos].Info = Legitimate;
        H-&gt;Cells[Pos].Data = Key;
        /*字符串类型的关键词需要 strcpy 函数!! */
        return true;
    }
    else {
        printf("键值已存在");
        return false;
    }
}
/*​
源代码来自：https://www.icourse163.org/learn/ZJU-93001?tid=1469696455#/learn/content?type=detail&amp;id=1252518398&amp;cid=1282086737   
​*/</code></pre> 
<blockquote> 
 <p>在开放地址散列表中，<span style="color:#fe2c24;">删除操作</span>要很小心。通常只能“<span style="color:#fe2c24;">懒惰删除</span>”，即需要增加一个“删除标记（<span style="color:#fe2c24;">Deleted</span>）”，而并不是真正删除它。以便查找时不会“<span style="color:#fe2c24;">断链</span>”。其空间可以在下次插入时<span style="color:#fe2c24;">重用</span>。</p> 
</blockquote> 
<p></p> 
<h3 id="%E5%8F%8C%E6%95%A3%E5%88%97%E6%8E%A2%E6%B5%8B%E6%B3%95%EF%BC%88Double%20Hashing%EF%BC%89%C2%A0">双散列探测法（Double Hashing） </h3> 
<p>双散列探测法：<img alt="d_i=i*h_2(key)" class="mathcode" src="https://images2.imgbox.com/3c/8b/O9333Lpg_o.png">，<img alt="h_2(key)" class="mathcode" src="https://images2.imgbox.com/7a/90/3IILzjtl_o.png">是另外一个散列函数，</p> 
<p>探测序列成：<img alt="h_2(key),2h_2(key),3h_2(key),......" class="mathcode" src="https://images2.imgbox.com/86/0a/Ll5WpkQm_o.png"></p> 
<p>对任意的key，<img alt="h_2(key)\neq 0" class="mathcode" src="https://images2.imgbox.com/bd/f8/7rwXsJa2_o.png">！！</p> 
<p>探测序列还应该保证<span style="color:#fe2c24;">所有的散列存储单元</span>都应该能够被<span style="color:#fe2c24;">探测到</span>。选择以下形式有良好的效果：</p> 
<p style="text-align:center;"><img alt="h_2(key)=p-(key \: \: mod \: \: p)" class="mathcode" src="https://images2.imgbox.com/53/d4/hArUKoEe_o.png"></p> 
<p>其中，<span style="color:#fe2c24;">p &lt; TableSize，p、TableSize都是素数</span>。</p> 
<p></p> 
<h3 id="%E5%86%8D%E6%95%A3%E5%88%97%EF%BC%88Rehashing%EF%BC%89">再散列（Rehashing）</h3> 
<ul><li>当散列表元素太多（即装填因子<img alt="\alpha" class="mathcode" src="https://images2.imgbox.com/05/54/FOZ5sbHa_o.png">太大）时，查找效率会下降；</li></ul> 
<p>比如散列表的大小为11，但此时表中以装填的元素已达到了9个，装填因子就很大了，再进行元素的插入就会很容易发生冲突，<span style="color:#fe2c24;">实用最大装填因子一般取</span><img alt="0.5\leqslant \alpha \leqslant 0.85" class="mathcode" src="https://images2.imgbox.com/85/aa/FgVEAriR_o.png">.</p> 
<ul><li>当装填因子过大时，解决的方法是加倍扩大散列表，这个过程叫做“<span style="color:#fe2c24;">再散列</span><strong>（Rehashing）</strong>”。</li></ul> 
<p>例如散列表的大小为11，就加倍扩大成23（素数），再将所有元素重新插入。</p> 
<p></p> 
<h2 id="%E5%88%86%E7%A6%BB%E9%93%BE%E6%8E%A5%E6%B3%95%EF%BC%88Separate%20Chaining%EF%BC%89" style="background-color:transparent;">分离链接法（Separate Chaining）</h2> 
<blockquote> 
 <p>分离链接法：将相应位置上冲突的所有关键词存储在同一个单链表中。</p> 
</blockquote> 
<p>分离链接法在逻辑上比较容易理解，看以下的例题：</p> 
<blockquote> 
 <p>【例】设关键字序列为47,7,29,11,16,92,22,8,3,50,37,89,94,21；散列函数取为：<img alt="h(key) =key\: \: mod \: \: 11" class="mathcode" src="https://images2.imgbox.com/b2/93/xoRjuCMJ_o.png">;用<span style="color:#fe2c24;">分离链接法</span>处理冲突。</p> 
</blockquote> 
<pre><code class="language-cpp">struct HashTbl
{
    int TableSize;
    List TheLists;
}*H;</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/21/36/vBwvgBng_o.png"></p> 
<h3 id="%E5%B9%B3%E5%9D%87%E6%9F%A5%E6%89%BE%E6%AC%A1%E6%95%B0">平均查找次数</h3> 
<ul><li>表中有9个结点只需1次查找</li><li>5个结点需要2次查找</li><li>查找成功的平均查找次数：</li></ul> 
<p style="text-align:center;"><img alt="ASLs=\frac{9\times 1+5\times 2}{14}\approx 1.36" class="mathcode" src="https://images2.imgbox.com/d9/e6/crAYqG9n_o.png"></p> 
<p></p> 
<h3 id="%E5%88%86%E7%A6%BB%E9%93%BE%E6%8E%A5%E6%B3%95%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0">分离链接法的散列表实现</h3> 
<pre><code class="language-cpp">#define KEYLENGTH 15                   /* 关键词字符串的最大长度 */
typedef char ElementType[KEYLENGTH+1]; /* 关键词类型用字符串 */
typedef int Index;                     /* 散列地址类型 */
/******** 以下是单链表的定义 ********/
typedef struct LNode *PtrToLNode;
struct LNode {
    ElementType Data;
    PtrToLNode Next;
};
typedef PtrToLNode Position;
typedef PtrToLNode List;
/******** 以上是单链表的定义 ********/

typedef struct TblNode *HashTable; /* 散列表类型 */
struct TblNode {   /* 散列表结点定义 */
    int TableSize; /* 表的最大长度 */
    List Heads;    /* 指向链表头结点的数组 */
};

HashTable CreateTable( int TableSize )
{
    HashTable H;
    int i;

    H = (HashTable)malloc(sizeof(struct TblNode));
    /* 保证散列表最大长度是素数，具体见代码5.3 */
    H-&gt;TableSize = NextPrime(TableSize);

    /* 以下分配链表头结点数组 */
    H-&gt;Heads = (List)malloc(H-&gt;TableSize*sizeof(struct LNode));
    /* 初始化表头结点 */
    for( i=0; i&lt;H-&gt;TableSize; i++ ) {
         H-&gt;Heads[i].Data[0] = '\0';
         H-&gt;Heads[i].Next = NULL;
    }

    return H;
}

Position Find( HashTable H, ElementType Key )
{
    Position P;
    Index Pos;
    
    Pos = Hash( Key, H-&gt;TableSize ); /* 初始散列位置 */
    P = H-&gt;Heads[Pos].Next; /* 从该链表的第1个结点开始 */
    /* 当未到表尾，并且Key未找到时 */ 
    while( P &amp;&amp; strcmp(P-&gt;Data, Key) )
        P = P-&gt;Next;

    return P; /* 此时P或者指向找到的结点，或者为NULL */
}

bool Insert( HashTable H, ElementType Key )
{
    Position P, NewCell;
    Index Pos;
    
    P = Find( H, Key );
    if ( !P ) { /* 关键词未找到，可以插入 */
        NewCell = (Position)malloc(sizeof(struct LNode));
        strcpy(NewCell-&gt;Data, Key);
        Pos = Hash( Key, H-&gt;TableSize ); /* 初始散列位置 */
        /* 将NewCell插入为H-&gt;Heads[Pos]链表的第1个结点 */
        NewCell-&gt;Next = H-&gt;Heads[Pos].Next;
        H-&gt;Heads[Pos].Next = NewCell; 
        return true;
    }
    else { /* 关键词已存在 */
        printf("键值已存在");
        return false;
    }
}

void DestroyTable( HashTable H )
{
    int i;
    Position P, Tmp;
    
    /* 释放每个链表的结点 */
    for( i=0; i&lt;H-&gt;TableSize; i++ ) {
        P = H-&gt;Heads[i].Next;
        while( P ) {
            Tmp = P-&gt;Next;
            free( P );
            P = Tmp;
        }
    }
    free( H-&gt;Heads ); /* 释放头结点数组 */
    free( H );        /* 释放散列表结点 */
}
/*
源代码来自：https://www.icourse163.org/learn/ZJU-93001?tid=1469696455#/learn/content?type=detail&amp;id=1252518398&amp;cid=1282086740
*/</code></pre> 
<hr> 
<p style="text-align:center;"><strong>end</strong></p> 
<hr> 
<p style="text-align:right;"><em>学习自：MOOC数据结构——陈越、何钦铭</em></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/edb284b670045fc671f01a1ea41c6a54/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">OpenAI开发系列（一）：一文搞懂大模型、GPT、ChatGPT等AI概念</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3b3452041d8e1c88f739e0c3354bd100/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">RabbitMQ清除积压消息/管理界面出现 Unacked 消息</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>