<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java的集合框架总结 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/266289348c952798ca7eb803df6905e4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java的集合框架总结">
  <meta property="og:description" content="Map接口和Collection接口是所有集合框架的父接口：
Collection接口的子接口包括：Set接口和List接口
Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等
Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等
List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等
List接口及其实现 ArrayList
基于动态数组实现
允许快速随机访问元素
插入和删除操作可能需要移动其他元素，因此在中间位置插入和删除的时间复杂度为O(n)
非同步，不是线程安全的，可以使用使用Collections.synchronizedList(new ArrayList&lt;&gt;()) 创建一个同步的 ArrayList。
LinkedList 基于双向链表实现
允许快速插入删除元素
不能快速随机访问，访问元素的时间复杂度为O（n）
非同步，不是线程安全的。可以使用 Collections.synchronizedList(new LinkedList&lt;&gt;()) 创建一个同步的 LinkedList。
可以用做队列或双向队列
依赖于两个节点（一个头节点一个尾节点）
常用方法
添加
add(E e)：在链表后添加一个元素； 通用方法 addFirst(E e)：在链表头部插入一个元素； 特有方法 addLast(E e)：在链表尾部添加一个元素； 特有方法
删除
removeFirst(E e)：删除头，获取元素并删除； 特有方法 removeLast(E e)：删除尾； 特有方法
查看
getFirst()：获取第一个元素； 特有方法 getLast()：获取最后一个元素； 特有方法
Stack 基于Vector实现，代表了后进先出（）
是同步的，是线程安全的
push入栈、peek查看栈顶元素、pop出栈、empty是否为空、size（）获取数目
Vector 基于动态数组实现，类似于ArrayList
同步的，是线程安全的
是需要线程安全的动态数组是使用，但是通常使用ArrayList和Collections.syschronizedList来代替
Set接口及其实现类 set其实一直在用map那一套
public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable { private transient HashMap&lt;E,Object&gt; map; private static final Object PRESENT = new Object(); ​ public HashSet() { map = new HashMap&lt;&gt;(); } ​ public boolean add(E e) { return map.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-12T22:06:40+08:00">
    <meta property="article:modified_time" content="2024-06-12T22:06:40+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java的集合框架总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>Map接口和Collection接口是所有集合框架的父接口：</p> 
<ol><li> <p>Collection接口的子接口包括：Set接口和List接口</p> </li></ol> 
<ol><li> <p>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等</p> </li></ol> 
<ol><li> <p>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</p> </li></ol> 
<ol><li> <p>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</p> </li></ol> 
<p><img alt="" height="522" src="https://images2.imgbox.com/05/48/rild1irY_o.png" width="751"></p> 
<h6>List接口及其实现</h6> 
<p><strong>ArrayList</strong></p> 
<ul><li> <p>基于动态数组实现</p> </li><li> <p>允许快速随机访问元素</p> </li><li> <p>插入和删除操作可能需要移动其他元素，因此在中间位置插入和删除的时间复杂度为O(n)</p> </li><li> <p>非同步，不是线程安全的，可以使用使用<code>Collections.synchronizedList(new ArrayList&lt;&gt;())</code> 创建一个同步的 <code>ArrayList</code>。</p> </li></ul> 
<h6>LinkedList</h6> 
<ul><li> <p>基于双向链表实现</p> </li><li> <p>允许快速插入删除元素</p> </li><li> <p>不能快速随机访问，访问元素的时间复杂度为O（n）</p> </li><li> <p>非同步，不是线程安全的。可以使用 <code>Collections.synchronizedList(new LinkedList&lt;&gt;())</code> 创建一个同步的 <code>LinkedList</code>。</p> </li><li> <p>可以用做队列或双向队列</p> <p>依赖于两个节点（一个头节点一个尾节点）</p> <p><strong>常用方法</strong></p> <p><strong>添加</strong></p> <p><em>add(E e)</em>：在链表后添加一个元素； 通用方法 <em>addFirst(E e)</em>：在链表头部插入一个元素； 特有方法 <em>addLast(E e)</em>：在链表尾部添加一个元素； 特有方法</p> <p><strong>删除</strong></p> <p><em>removeFirst(E e)</em>：删除头，获取元素并删除； 特有方法 <em>removeLast(E e)</em>：删除尾； 特有方法</p> <p><strong>查看</strong></p> <p><em>getFirst()</em>：获取第一个元素； 特有方法 <em>getLast()</em>：获取最后一个元素； 特有方法</p> </li></ul> 
<p></p> 
<h6>Stack</h6> 
<ul><li> <p>基于<code>Vector</code>实现，代表了后进先出（）</p> </li><li> <p>是同步的，是线程安全的</p> </li><li> <p><code>push</code>入栈、<code>peek</code>查看栈顶元素、<code>pop</code>出栈、<code>empty</code>是否为空、<code>size</code>（）获取数目</p> </li></ul> 
<h6>Vector</h6> 
<ul><li> <p>基于动态数组实现，类似于<code>ArrayList</code></p> </li><li> <p>同步的，是线程安全的</p> </li><li> <p>是需要线程安全的动态数组是使用，但是通常使用<code>ArrayList</code>和<code>Collections.syschronizedList</code>来代替</p> </li></ul> 
<p></p> 
<h6>Set接口及其实现类</h6> 
<p><strong>set其实一直在用map那一套</strong></p> 
<pre> public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable {
     private transient HashMap&lt;E,Object&gt; map;
     private static final Object PRESENT = new Object();
 ​
     public HashSet() {
         map = new HashMap&lt;&gt;();
     }
 ​
     public boolean add(E e) {
         return map.put(e, PRESENT) == null;
     }
 ​
     // Other methods delegate to the underlying map
 }
 ​</pre> 
<h6>HashSet</h6> 
<ul><li> <p><strong>元素存储</strong><code>HashSet</code> 将元素添加到底层的 <code>HashMap</code> 中，键是元素的哈希码，值是一个占位符对象。<code>HashSet</code>的实现是基于<code>HashMap</code>的，他使用HashMap来存储元素，在HashSet中，元素被当作HashMap的键，而HashMap的值则是一个固定的占位符，通常是 <code>PRESENT</code> 对象（一个静态内部类对象）。这样做是为了节省空间，因为 <code>HashSet</code> 只关心元素的唯一性，不需要存储额外的值。</p> </li><li> <p><strong>去重</strong>：<code>HashSet</code> 使用了 <code>HashMap</code> 键的唯一性来确保 <code>HashSet</code> 中不会有重复的元素。</p> </li><li> <p>不保证集合的迭代顺序，顺序可能会随时间变化。</p> </li><li> <p><strong>方法委派</strong>：<code>HashSet</code> 的许多方法（如 <code>add</code>、<code>remove</code>、<code>contains</code> 等）都是通过调用底层 <code>HashMap</code> 的对应方法来实现的。</p> </li><li> <p><strong>性能</strong>：由于 <code>HashSet</code> 是基于 <code>HashMap</code> 实现的，所以其性能与 <code>HashMap</code> 类似，添加、删除和查找操作的平均时间复杂度为 O(1)。</p> </li><li> <p>允许存储<code>null</code>值。</p> </li></ul> 
<p></p> 
<h6>LinkedHashSet</h6> 
<p><code>LinkedHashSet</code> 是 <code>HashSet</code> 的一个子类，它继承了 <code>HashSet</code> 的特性，并且保持了元素的插入顺序。下面是关于 <code>LinkedHashSet</code> 的一些关键点：</p> 
<ul><li> <p>继承自HashSet并且使用链表维护元素的插入顺序</p> </li><li> <p>保证迭代顺序与插入顺序一致</p> </li><li> <p>允许存储<code>null</code>值。</p> </li><li> <p>插入、删除、和查找操作的时间复杂度为O(1)。</p> </li></ul> 
<p><strong>实现细节</strong></p> 
<ul><li> <p>当你向 <code>LinkedHashSet</code> 添加元素时，它会使用 <code>LinkedHashMap</code> 来存储元素。</p> </li><li> <p>每个元素被当作 <code>LinkedHashMap</code> 的键，值则是一个固定的占位符对象。</p> </li><li> <p><code>LinkedHashSet</code> 通过委派 <code>LinkedHashMap</code> 来实现其 <code>add</code>、<code>remove</code> 和 <code>contains</code> 等方法。</p> </li></ul> 
<p></p> 
<h6>TreeSet</h6> 
<p><code>TreeSet</code> 是 Java 中实现 <code>SortedSet</code> 接口的一个集合类，它基于 <code>TreeMap</code> 实现，并且元素是按照自然顺序（或通过提供的比较器）排序的。以下是 <code>TreeSet</code> 的一些关键点：</p> 
<ul><li> <p>基于红黑树（自平衡二叉搜索树）实现</p> </li><li> <p>元素是有序的，元素按照自然顺序（或通过<code>Comparator</code>指定的顺序）排</p> </li><li> <p>不允许存储<code>null</code>值（会抛出<code>NullPointerException</code>）</p> </li><li> <p>插入、删除、和查找操作的时间复杂度为O(log n)。</p> </li></ul> 
<p></p> 
<h6>Map接口及其实现类</h6> 
<h6><strong>HashMap</strong>：</h6> 
<p><img alt="" height="437" src="https://images2.imgbox.com/9c/7e/kSThVqpt_o.png" width="761"></p> 
<ul><li> <p>基于哈希表实现，调用put方法值，首先将k，v封装到Node对象中，然后底层会调用k的hashCode（）方法得到hash值。根据这个值来决定到底该插入数组下标的哪个位置，如果有两个值的哈希值一样，就会调用equals方法进行比较，如果哈希值一样但是不相等，就会形成链表插入 ，如果相等那么相等的这个节点的value将会被覆盖。如果没有元素占用位置，就直接放入即可。（通过数组加链表形式）</p> </li><li> <p>在Java8对hashmap进行了优化，如果相同哈希值，链表的长度超过8，就从链表转换成红黑树。第一次添加元素的时候，默认初期长度为16，当往map中继续添加元素的时候，通过hash值跟数组长度取“与”来决定放在数组的哪个位置，如果出现放在同一个位置的时候，优先以链表的形式存放，在同一个位置的个数又达到了8个（代码是&gt;=7,从0开始，及第8个开始判断是否转化成红黑树），如果数组的长度还小于64的时候，则会扩容数组。如果数组的长度大于等于64的话，才会将该节点的链表转换成树。在扩容完成之后，如果某个节点的是树，同时现在该节点的个数又小于等于6个了，则会将该树转为链表（只有当数据量大于64才会有红黑树+链表）</p> </li></ul> 
<ul><li> <p>HashMap内部结构是数组（Node[] table）和链表结合组成的复合结构，数组被分成一个个桶（bucket）或槽，通过哈希值决定键值对在这个数组的寻址；哈希值相同的键值对，则以链表形式存储。当链表大小超过阈值（TREEIFY_THRESHOLD = 8）时，链表就会被改造成树形结构。（查询效率变高）</p> </li><li> <p>Java8不再像Java7中那样需要满足两个条件，Java8中扩容只需要满足一个条件：当前存放新值（注意不是替换已有元素位置时）的时候已有元素的个数大于等于阈值（已有元素等于阈值，下一个存放后必然触发扩容机制）且扩容发生在存放后，即是数据存放后（先存放后扩容），判断当前存入对象的个数，如果大于阈值则进行扩容。</p> </li><li> <p>允许存储<code>null</code>键和<code>null</code>值。</p> </li><li> <p>插入、删除、和查找操作的时间复杂度为O(1)。</p> </li><li> <p>非同步，不是线程安全的。</p> </li></ul> 
<h6>LinkedHashMap</h6> 
<p><img alt="" height="675" src="https://images2.imgbox.com/1d/e4/g30dlvUR_o.png" width="752"></p> 
<ul><li> <p>通过hashmap跟双向链表实现，可以确保按照插入顺序迭代链表</p> </li><li> <p><strong>遍历性能：</strong> 与普通的<code>HashMap</code>相比，在迭代<code>LinkedHashMap</code>时，性能更加稳定。因为它不需要遍历整个桶，而是按照链表顺序遍历元素。</p> </li><li> <p><strong>实现方式：</strong> 在内部实现上，<code>LinkedHashMap</code>在每个条目中保留了前一个和后一个条目的引用，以实现双向链表。这使得在插入、删除和遍历元素时的性能表现良好。</p> <h6></h6> </li></ul> 
<h6><strong>TreeMap</strong>：</h6> 
<p><img alt="" height="286" src="https://images2.imgbox.com/f2/8b/SpLR0irK_o.png" width="763"></p> 
<ul><li> <p>基于红黑树实现</p> </li><li> <p>键按照自然顺序（或通过<code>Comparator</code>指定的顺序）排序。</p> </li><li> <p>不允许存储Null键</p> </li><li> <p>插入、删除、和查找操作的时间复杂度为O(log n)。</p> </li></ul> 
<p></p> 
<h6>Hashtable</h6> 
<ul><li> <p>也是使用哈希表还有链表实现</p> </li><li> <p>同步的，是线程安全的。</p> </li><li> <p>不允许存储<code>null</code>键和<code>null</code>值。</p> </li><li> <p>插入、删除、和查找操作的时间复杂度为O(1)。</p> <p></p> <p></p> </li></ul> 
<h6>Properties</h6> 
<ul><li> <p>继承自<code>Hashtable</code>，表示一个持久化的属性集。</p> </li><li> <p>每个键及其对应值都是一个字符串。</p> </li><li> <p>常用于读取和写入配置文件。</p> </li></ul> 
<p></p> 
<h6>ConcurrentHashMap</h6> 
<ul><li> <p>不允许存储<code>null</code>键和<code>null</code>值。</p> </li><li> <p>插入、删除、和查找操作的时间复杂度为O(1)。</p> </li><li> <p>在多线程环境下，使用HashMap进行put操作时存在丢失数据的情况，为了避免这种bug的隐患，强烈建议使用ConcurrentHashMap代替HashMap。</p> </li><li> <p>HashTable是一个线程安全的类，它使用synchronized来锁住整张Hash表来实现线程安全，即每次锁住整张表让线程独占，相当于所有线程进行读写时都去竞争一把锁，导致效率非常低下。ConcurrentHashMap可以做到读取数据不加锁，并且其内部的结构可以让其在进行写操作的时候能够将锁的粒度保持地尽量地小，允许多个修改操作并发进行，其关键在于使用了<strong>锁分段技术</strong>。它使用了多个锁来控制对hash表的不同部分进行的修改。</p> </li></ul> 
<p><strong>分段锁（Segment Locking）机制</strong></p> 
<p>早期版本的<code>ConcurrentHashMap</code>（Java 7及之前）使用分段锁机制，具体如下：</p> 
<ul><li> <p><code>ConcurrentHashMap</code>内部将整个哈希表分为多个段（<code>Segment</code>），每个段都是一个独立的哈希表，并拥有自己的锁。</p> </li><li> <p>这种机制允许多个线程同时访问不同段的元素，从而提高并发度。</p> </li><li> <p>ConcurrentHashMap 为了提高本身的并发能力，在内部采用了一个叫做 Segment 的结构，一个 Segment 其实就是一个类 Hash Table 的结构，Segment 内部维护了一个链表数组，我们用下面这一幅图来看下 ConcurrentHashMap 的内部结构,从下面的结构我们可以了解到，ConcurrentHashMap 定位一个元素的过程需要进行两次Hash操作，第一次 Hash 定位到 Segment，第二次 Hash 定位到元素所在的链表的头部，因此，这一种结构的带来的副作用是 Hash 的过程要比普通的 HashMap 要长，但是带来的好处是写操作的时候可以只对元素所在的 Segment 进行操作即可，不会影响到其他的 Segment，这样，在最理想的情况下，ConcurrentHashMap 可以<strong>最高同时支持 Segment 数量大小的写操作</strong>（刚好这些写操作都非常平均地分布在所有的 Segment上），所以，通过这一种结构，ConcurrentHashMap 的并发能力可以大大的提高。</p> </li></ul> 
<p><img alt="" height="428" src="https://images2.imgbox.com/37/c5/ZkFJsL5C_o.png" width="725"></p> 
<p><strong>CAS操作和分段锁</strong></p> 
<p>在Java 8中，<code>ConcurrentHashMap</code>使用了一种新的机制，结合了CAS（Compare-And-Swap）操作和细粒度的分段锁。</p> 
<ul><li> <p>使用CAS操作来保证对单个节点的原子性操作，减少锁的使用。</p> </li><li> <p>在插入、删除和更新操作中，如果CAS操作失败（即另一个线程同时修改了相同的位置），则退而使用锁进行操作。</p> </li><li> <p>在Java 8中，<code>ConcurrentHashMap</code>取消了分段锁的概念，直接在哈希桶（bucket）级别进行锁定，使用CAS操作和<code>synchronized</code>块来保证并发安全。这使得数据结构更加简单，且操作更加直观。</p> </li><li> <p>为了优化哈希冲突情况下的查找性能，Java 8引入了红黑树。当链表的长度超过一定阈值（默认是8）时，链表会转换为红黑树。这样，在高冲突情况下，查找操作的时间复杂度从O(n)降到了O(log n)，极大地提高了性能。</p> </li><li> <p>CAS 操作通过比较当前值与预期值，如果两者相等则更新为新值，否则重试该操作。</p> </li></ul> 
<p><strong>数据结构</strong></p> 
<p><code>ConcurrentHashMap</code>在Java 8中的内部数据结构有以下几个关键组成部分：</p> 
<ul><li> <p><strong>数组（Node&lt;K,V&gt;[] table）</strong>：哈希表的核心数组，存储链表或红黑树的头节点。</p> </li><li> <p><strong>链表和红黑树</strong>：数组中的每个桶（bucket）最初是一个链表。当链表长度超过阈值（8）时，链表会转换为红黑树，以提高查询效率。</p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b09803cfcc2fe4264a9d9399bc7b02c7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SQL 窗口函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/04b4f09655feda50b4678f54eeddcbff/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">大数据-11-案例演习-淘宝双11数据分析与预测 （期末问题）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>