<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JavaSE：继承和多态（下篇） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/bfefa05f44a62e7a2da7e45f59e870a3/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="JavaSE：继承和多态（下篇）">
  <meta property="og:description" content="目录
一、前言
二、多态
（一）多态的概念
（二）多态实现条件
（三）多态的优缺点
三、重写
（一）重写的概念
（二）重写的规则
（三）重写和重载的区别
四、向上转型和向下转型
（一）向上转型
（二）向下转型 五、总结
一、前言 大家好，前几天蜡笔小欣带大家了解并学习了Java中的继承，子类通过extends关键字来继承父类。通过继承，子类可以重写父类的方法，从而实现多态性。今天我们就一起去认识Java中的多态，了解多态的概念，掌握多态的用法，使我们在写程序时更加方便。
二、多态 （一）多态的概念 多态 通俗来说，就是多种形态， 具体点就是去完成某个行为，当不同的对象去完成时会产生出不同 的状 态。 举个栗子：打印机的功能是打印文件，那么打印机又分为 彩色打印机和 黑白打印机。 简单来说就是同一件事情，发生在不同对象身上，会产生不同的结果 。
（二）多态实现条件 多态实现的条件：
1. 必须在继承体系下， 2. 子类必须要对父类中方法进行重写， 3. 通过父类的引用调用重写的方法。 下面举个例子让大家更好地理解：
我们先定义一个父类Animal，这个类里面有两个成员变量，一个方法。
class Animal { public String name; public int age; public Animal(String name, int age) { this.name = name; this.age = age; } public void eat() { System.out.println(name &#43; &#34;正在吃东西&#34;); } } 接着我们定义两个子类，分别是Dog和Cat，都继承父类Animal，在这两个类中重写eat()方法。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-31T12:23:50+08:00">
    <meta property="article:modified_time" content="2024-03-31T12:23:50+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JavaSE：继承和多态（下篇）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80" rel="nofollow">一、前言</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%A4%9A%E6%80%81-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%A4%9A%E6%80%81" rel="nofollow">二、多态</a></p> 
<p id="%EF%BC%88%E4%B8%80%EF%BC%89%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%B8%80%EF%BC%89%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">（一）多态的概念</a></p> 
<p id="%EF%BC%88%E4%BA%8C%EF%BC%89%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E6%9D%A1%E4%BB%B6-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E6%9D%A1%E4%BB%B6" rel="nofollow">（二）多态实现条件</a></p> 
<p id="%EF%BC%88%E4%B8%89%EF%BC%89%E5%A4%9A%E6%80%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%B8%89%EF%BC%89%E5%A4%9A%E6%80%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9" rel="nofollow">（三）多态的优缺点</a></p> 
<p id="%E4%B8%89%E3%80%81%E9%87%8D%E5%86%99-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E9%87%8D%E5%86%99" rel="nofollow">三、重写</a></p> 
<p id="%EF%BC%88%E4%B8%80%EF%BC%89%E9%87%8D%E5%86%99%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%B8%80%EF%BC%89%E9%87%8D%E5%86%99%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">（一）重写的概念</a></p> 
<p id="%EF%BC%88%E4%BA%8C%EF%BC%89%E9%87%8D%E5%86%99%E7%9A%84%E8%A7%84%E5%88%99-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E9%87%8D%E5%86%99%E7%9A%84%E8%A7%84%E5%88%99" rel="nofollow">（二）重写的规则</a></p> 
<p id="%C2%A0%EF%BC%88%E4%B8%89%EF%BC%89%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#%C2%A0%EF%BC%88%E4%B8%89%EF%BC%89%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow"> （三）重写和重载的区别</a></p> 
<p id="%E5%9B%9B%E3%80%81%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%E5%92%8C%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%E5%92%8C%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B" rel="nofollow">四、向上转型和向下转型</a></p> 
<p id="%EF%BC%88%E4%B8%80%EF%BC%89%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%B8%80%EF%BC%89%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B" rel="nofollow">（一）向上转型</a></p> 
<p id="%EF%BC%88%E4%BA%8C%EF%BC%89%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%C2%A0-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%C2%A0" rel="nofollow">（二）向下转型 </a></p> 
<p id="%C2%A0%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93" rel="nofollow"> 五、总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80">一、前言</h2> 
<p>大家好，前几天蜡笔小欣带大家了解并学习了Java中的继承，<strong>子类通过extends关键字来继承父类</strong>。通过继承，子类可以重写父类的方法，从而实现多态性。今天我们就一起去认识Java中的多态，了解多态的概念，掌握多态的用法，使我们在写程序时更加方便。</p> 
<h2 id="%E4%BA%8C%E3%80%81%E5%A4%9A%E6%80%81"><span style="color:#333333;"><strong>二、多态</strong></span></h2> 
<h3 id="%EF%BC%88%E4%B8%80%EF%BC%89%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E5%BF%B5">（一）<span style="color:#333333;"><strong>多态的概念 </strong></span></h3> 
<div> 
 <span style="color:#fe2c24;"><strong>多态</strong></span> 
 <span style="color:#333333;">通俗来说，就是多种形态，</span> 
 <span style="color:#333333;">具体点就是<strong>去完成某个行为，当不同的对象去完成时会产生出不同 的状</strong></span> 
 <span style="color:#333333;"><strong>态。</strong></span> 
</div> 
<div> 
 <span style="color:#333333;">举个栗子：</span>打印机的功能是打印文件，那么打印机又分为 
 <strong>彩色打印机</strong>和 
 <strong>黑白打印机</strong>。 
</div> 
<div style="text-align:center;"> 
 <img alt="" height="286" src="https://images2.imgbox.com/fe/6c/mTCBK7VD_o.png" width="533"> 
</div> 
<p><span style="color:#333333;">简单来说就是同一件事情，发生在不同对象身上，会产生不同的结果</span> 。</p> 
<h3 id="%EF%BC%88%E4%BA%8C%EF%BC%89%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E6%9D%A1%E4%BB%B6" style="background-color:transparent;">（二）<span style="color:#333333;"><strong>多态实现条件</strong></span></h3> 
<blockquote> 
 <p><span style="color:#333333;"><strong>多态实现的条件：</strong></span></p> 
 <p></p> 
 <div> 
  <span style="color:#333333;">1. </span> 
  <span style="color:#333333;"><strong>必须在继承体系下，</strong></span> 
 </div> 
 <div> 
  <span style="color:#333333;">2. </span> 
  <span style="color:#333333;"><strong>子类必须要对父类中方法进行重写，</strong></span> 
 </div> 
 <div> 
  <span style="color:#333333;">3. </span> 
  <span style="color:#333333;"><strong>通过父类的引用调用重写的方法。</strong></span> 
 </div> 
</blockquote> 
<p><img alt="" height="754" src="https://images2.imgbox.com/b3/49/LDhuSJrt_o.png" width="1200"></p> 
<p>下面举个例子让大家更好地理解：</p> 
<p>我们先定义一个父类Animal，这个类里面有两个成员变量，一个方法。</p> 
<pre><code class="language-java">class Animal {
    public String name;
    public int age;

    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void eat() {
        System.out.println(name + "正在吃东西");
    }
}</code></pre> 
<p> 接着我们定义两个子类，分别是Dog和Cat，都继承父类Animal，在这两个类中重写eat()方法。</p> 
<pre><code class="language-java">class Dog extends Animal {
    public Dog(String name, int age) {
        super(name, age);
    }

    public void eat() {
        System.out.println(name + "正在吃狗粮");
    }

    public void bark() {
        System.out.println(name + "汪汪汪");
    }
}

class Cat extends Animal {
    public Cat(String name, int age) {
        super(name, age);
    }

    public void eat() {
        System.out.println(name + "正在吃猫粮");
    }

    public void mew() {
        System.out.println(name + "喵喵喵");
    }
}</code></pre> 
<p>然后我们在Test里面定义一个静态方法func()，父类Animal作为参数引用，再调用eat()方法。</p> 
<pre><code class="language-java">public class Test {
    public static void eat(Animal animal) {
        animal.eat();
    }
}</code></pre> 
<p>最后实例化对象，进行初始化赋值。</p> 
<pre><code class="language-java">public static void main(String[] args) {
        Dog dog = new Dog("小白", 3);
        Cat cat = new Cat("汤姆", 5);
        eat(dog);
        eat(cat);
}</code></pre> 
<div> 
 <span style="color:#333333;">当类的调用者在编写 </span> 
 <span style="color:#333333;">eat </span> 
 <span style="color:#333333;">这个方法的时候</span> 
 <span style="color:#333333;">, </span> 
 <span style="color:#333333;">参数类型为</span> 
 <span style="color:#333333;"> Animal (</span> 
 <span style="color:#333333;">父类</span> 
 <span style="color:#333333;">), </span> 
 <span style="color:#333333;">此时在该方法内部并</span> 
 <span style="color:#333333;"><strong>不知道</strong></span> 
 <span style="color:#333333;"><strong>, </strong></span> 
 <span style="color:#333333;"><strong>也不关注</strong></span> 
 <span style="color:#333333;">当前的animal引用指向的是哪个类型(</span> 
 <span style="color:#333333;">哪个子类</span> 
 <span style="color:#333333;">)</span> 
 <span style="color:#333333;">的实例。</span> 
 <span style="color:#333333;">此时animal</span> 
 <span style="color:#333333;">这个引用调用</span> 
 <span style="color:#333333;"> eat</span> 
 <span style="color:#333333;">方法可能会有多种不同的表现</span> 
 <span style="color:#333333;">(</span> 
 <span style="color:#333333;">和animal</span> 
 <span style="color:#333333;">引用的实例 相关), </span> 
 <span style="color:#333333;">这种行为就称为</span> 
 <span style="color:#333333;"><strong>多态。</strong></span> 
</div> 
<h3 id="%EF%BC%88%E4%B8%89%EF%BC%89%E5%A4%9A%E6%80%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span style="color:#333333;"><strong>（三）多态的优缺点</strong></span></h3> 
<blockquote> 
 <div> 
  <span style="color:#fe2c24;"><strong>多态的优点：</strong></span> 
 </div> 
 <div> 
  <span style="color:#333333;"><span style="background-color:#a2e043;">1. </span></span> 
  <span style="color:#333333;"><strong><span style="background-color:#a2e043;">能够降低代码的</span></strong></span> 
  <span style="color:#333333;"><strong><span style="background-color:#a2e043;"> "</span></strong></span> 
  <span style="color:#333333;"><strong><span style="background-color:#a2e043;">圈复杂度</span></strong></span> 
  <span style="color:#333333;"><strong><span style="background-color:#a2e043;">", </span></strong></span> 
  <span style="color:#333333;"><strong><span style="background-color:#a2e043;">避免使用大量的</span></strong></span> 
  <span style="color:#333333;"><strong><span style="background-color:#a2e043;"> if - else，</span></strong></span> 
 </div> 
 <div> 
  <span style="color:#333333;"><span style="background-color:#a2e043;">2. </span></span> 
  <span style="color:#333333;"><strong><span style="background-color:#a2e043;">可扩展能力更强。</span></strong></span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#333333;"><strong><span style="background-color:#a2e043;">多态缺陷：代码的运行效率降低</span></strong></span> 
  <span style="color:#333333;"><span style="background-color:#a2e043;">。</span></span> 
 </div> 
</blockquote> 
<h2 id="%E4%B8%89%E3%80%81%E9%87%8D%E5%86%99">三、重写</h2> 
<h3 id="%EF%BC%88%E4%B8%80%EF%BC%89%E9%87%8D%E5%86%99%E7%9A%84%E6%A6%82%E5%BF%B5">（一）重写的概念</h3> 
<div> 
 <span style="color:#333333;">重写</span> 
 <span style="color:#333333;">(override)</span> 
 <span style="color:#333333;">：也称为覆盖。重写是子类对父类非静态、非</span> 
 <span style="color:#333333;">private</span> 
 <span style="color:#333333;">修饰，非</span> 
 <span style="color:#333333;">final</span> 
 <span style="color:#333333;">修饰，非构造方法等的实现过程 进行重新编写, </span> 
 <span style="color:#333333;"><strong>返回值和形参都不能改变</strong></span> 
 <span style="color:#333333;">。</span> 
 <span style="color:#333333;"><strong>即外壳不变，核心重写！</strong></span> 
 <span style="color:#333333;">重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。</span> 
</div> 
<h3 id="%EF%BC%88%E4%BA%8C%EF%BC%89%E9%87%8D%E5%86%99%E7%9A%84%E8%A7%84%E5%88%99"><span style="color:#333333;">（二）重写的规则</span></h3> 
<div>
  1. 
 <span style="color:#fe2c24;"><strong>子类在重写父类的方法时，一般必须与父类方法原型一致</strong></span> 
 <span style="color:#333333;">： 返回值类型</span>、 
 <span style="color:#333333;">方法名</span> 
 <span style="color:#333333;"> (</span> 
 <span style="color:#333333;">参数列表</span> 
 <span style="color:#333333;">) </span> 
 <span style="color:#333333;">要完全一致。</span> 
</div> 
<div> 
 <img alt="" height="666" src="https://images2.imgbox.com/b3/58/uKrZYHfV_o.png" width="810"> 
</div> 
<p><span style="color:#333333;">2.</span><strong><span style="color:#fe2c24;">被重写的方法返回值类型可以不同，但是必须是具有父子关系的。</span></strong><span style="color:#0d0016;">我们可以理解为将eat()方法定义为父子关系。</span></p> 
<p><img alt="" height="484" src="https://images2.imgbox.com/84/3a/dv4DqsVs_o.png" width="836"></p> 
<p>3.<span style="color:#fe2c24;"><strong>访问权限不能比父类中被重写的方法的访问权限更低</strong></span><span style="color:#333333;">。例如：如果父类方法被public</span><span style="color:#333333;">修饰，则子类中重写该方法就不能声明为protected。</span></p> 
<p><img alt="" height="641" src="https://images2.imgbox.com/f8/3f/XYc5TlXd_o.png" width="776"></p> 
<p>4.<span style="color:#fe2c24;"><strong>父类被static、private修饰的方法、构造方法都不能被重写。</strong></span> </p> 
<p><img alt="" height="640" src="https://images2.imgbox.com/08/e4/ja9RUFKr_o.png" width="757"></p> 
<p> 5.<span style="color:#fe2c24;"><strong>重写的方法，可以使用 @Override 注解来显式指定。</strong></span><span style="color:#333333;"> </span><span style="color:#333333;">有了这个注解能帮我们进行一些合法性校验。</span><span style="color:#333333;"> </span><span style="color:#333333;">例如不小心将方法名字拼写错了 (</span><span style="color:#333333;">比如写成</span><span style="color:#333333;"> aet)，</span><span style="color:#333333;">那么此时编译器就会发现父类中没有</span><span style="color:#333333;"> aet </span><span style="color:#333333;">方法</span><span style="color:#333333;">，</span><span style="color:#333333;">就会编译报错，</span><span style="color:#333333;">提示无法构成重写。</span></p> 
<p> 操作步骤：<strong>1.点击鼠标右键，点击generate。</strong></p> 
<p><img alt="" height="776" src="https://images2.imgbox.com/7b/3e/0mtnPpG3_o.png" width="750"></p> 
<p>2.<strong>选择红色箭头所指向的部分。</strong></p> 
<p><img alt="" height="496" src="https://images2.imgbox.com/da/42/ozt9nftg_o.png" width="710"></p> 
<p>3.<strong>点击我们要重写的方法。 </strong></p> 
<p><img alt="" height="776" src="https://images2.imgbox.com/ad/15/bIn2GpfC_o.png" width="706"></p> 
<p> 4.最后就可以对父类的方法进行重写，如果我们不小心把重写的方法名写错了，@Override就可以帮我们检测出来，使我们在重写方法时更加方便。</p> 
<p><img alt="" height="511" src="https://images2.imgbox.com/b9/c6/AxMJCyyX_o.png" width="626"> </p> 
<h3 id="%C2%A0%EF%BC%88%E4%B8%89%EF%BC%89%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB"> （三）重写和重载的区别</h3> 
<p><img alt="" height="287" src="https://images2.imgbox.com/e0/ae/Nq8lDDmE_o.png" width="1200"><span style="color:#333333;"><strong>方法重载</strong>是<strong>一个类</strong>的多态性表现</span><span style="color:#333333;">,</span><span style="color:#333333;">而<strong>方法重写</strong>是<strong>子类与父类</strong>的一种多态性表现。</span></p> 
<h2 id="%E5%9B%9B%E3%80%81%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%E5%92%8C%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B">四、<span style="color:#333333;"><strong>向上转型和向下转型</strong></span></h2> 
<h3 id="%EF%BC%88%E4%B8%80%EF%BC%89%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span style="color:#333333;"><strong>（一）向上转型</strong></span></h3> 
<div> 
 <span style="color:#333333;">向上转型：实际就是创建一个子类对象，将其当成父类对象来使用。</span> 
</div> 
<blockquote> 
 <div> 
  <span style="color:#fe2c24;"><strong>语法格式：父类类型 对象名 = new 子类类型()</strong></span> 
 </div> 
 <div> 
  <div> 
   <span style="color:#000000;">Animal animal </span> 
   <span style="color:#981a1a;">= </span> 
   <span style="color:#770088;">new </span> 
   <span style="color:#000000;">Cat</span> 
   <span style="color:#333333;">(</span> 
   <span style="color:#aa1111;">"</span> 
   <span style="color:#0d0016;">汤姆</span> 
   <span style="color:#aa1111;">"</span> 
   <span style="color:#333333;">,</span> 
   <span style="color:#116644;">5</span> 
   <span style="color:#333333;">); </span> 
  </div> 
 </div> 
</blockquote> 
<p><span style="color:#333333;">animal</span><span style="color:#333333;">是父类类型，但可以引用一个子类对象，因为是从小范围向大范围的转换。</span></p> 
<p><span style="color:#333333;">下面我们举个例子看看：</span></p> 
<pre><code class="language-java">class Animal {
    public String name;
    public int age;

    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void eat() {
        System.out.println(name + "正在吃东西");
    }
}

class Dog extends Animal {
    public Dog(String name, int age) {
        super(name, age);
    }

    @Override
    public void eat() {
        System.out.println(name +"正在吃狗粮");
    }

    public void bark() {
        System.out.println(name + "汪汪汪");
    }
}

public class Test {
    public static void eat(Animal animal) {
        animal.eat();
    }

    public static void main(String[] args) {
        Dog dog = new Dog("小白", 3);
        Animal animal =dog;//animal这个引用指向了Dog对象
        animal.eat();
    }
}</code></pre> 
<p><strong>运行结果如下：</strong></p> 
<p> <img alt="" height="210" src="https://images2.imgbox.com/9e/18/zR7X5iIV_o.png" width="451"></p> 
<p>当我们把Dog类中eat()方法注释后，运行结果为：</p> 
<p><img alt="" height="206" src="https://images2.imgbox.com/8d/f4/WAH1ppiN_o.png" width="464"></p> 
<p>我们会发现它执行了父类Animal中的eat()方法。那如果这时候我们在Dog类中加入一个color成员变量。</p> 
<p><img alt="" height="421" src="https://images2.imgbox.com/74/f5/0Jh55Vc5_o.png" width="705"></p> 
<p>然后我们用对象animal去调用它试试看能否运行。</p> 
<p><img alt="" height="222" src="https://images2.imgbox.com/37/31/NfHNhddU_o.png" width="774"></p> 
<p> 我们发现结果报错，这是因为color这个属性是Dog类中的，而animal无法访问到。</p> 
<blockquote> 
 <div> 
  <span style="color:#fe2c24;"><strong>Tips：</strong></span> 
 </div> 
 <div> 
  <span style="color:#333333;"><strong>向上转型的优点：让代码实现更简单灵活。 </strong></span> 
 </div> 
 <div> 
  <span style="color:#333333;"><strong>向上转型的缺陷：不能调用到子类特有的方法。</strong></span> 
 </div> 
</blockquote> 
<h3 id="%EF%BC%88%E4%BA%8C%EF%BC%89%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%C2%A0">（二）向下转型 </h3> 
<div> 
 <span style="color:#333333;">将一个子类对象经过向上转型之后当成父类方法使用，再无法调用子类的方法，但有时候可能需要调用子类特有的方法，此时：将父类引用再还原为子类对象即可，即向下转型。 </span> 
</div> 
<div> 
 <img alt="" height="509" src="https://images2.imgbox.com/ee/72/wXm8aDGl_o.png" width="974"> 
</div> 
<p> </p> 
<pre><code class="language-java">class Animal {
    public String name;
    public int age;

    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void eat() {
        System.out.println(name + "正在吃东西");
    }
}

class Dog extends Animal {
    public String color;

    public Dog(String name, int age) {
        super(name, age);
        this.color = color;
    }

    /*@Override
    public void eat() {
        System.out.println(name +"正在吃狗粮");
    }*/

    public void bark() {
        System.out.println(name + "汪汪汪");
    }
}

class Cat extends Animal {
    public Cat(String name, int age) {
        super(name, age);
    }

    public void eat() {
        System.out.println(name + "正在吃猫粮");
    }

    public void mew() {
        System.out.println(name + "喵喵喵");
    }
}

public class Test {
    public static void eat(Animal animal) {
        animal.eat();
    }

    public static void main(String[] args) {
        Dog dog = new Dog("小白", 3);
        Animal animal = dog;//animal这个引用指向了Dog对象
        Cat cat = new Cat("汤姆", 5);
        cat = (Cat) animal;
        cat.mew();
    }
}</code></pre> 
<p>Animal向下转型为Cat，Cat本来就是猫，转换为猫，安全；Animal向下转型为Dog，Cat本来是猫，转换为狗，则不安全。 </p> 
<p><strong>运行结果：</strong></p> 
<p><img alt="" height="271" src="https://images2.imgbox.com/95/54/7ETZmjKH_o.png" width="1200"> 因为animal实际指向的是狗，但现在要强制还原为猫，无法正常还原，所以运行时抛出类型转换异常。</p> 
<blockquote> 
 <p><strong>解决方法：</strong></p> 
 <div> 
  <span style="color:#333333;">Java</span> 
  <span style="color:#333333;">中为了提高向下转型的安全性，引入了 </span> 
  <span style="color:#fe2c24;"><strong>instanceof</strong></span> 
  <span style="color:#333333;"> </span> 
  <span style="color:#333333;">，如果该表达式为</span> 
  <span style="color:#333333;">true</span> 
  <span style="color:#333333;">，则可以安全转换。 </span> 
 </div> 
</blockquote> 
<pre><code class="language-java">public class Test {
    public static void eat(Animal animal) {
        animal.eat();
    }

    public static void main(String[] args) {
        Dog dog = new Dog("小白", 3);
        Animal animal = dog;//animal这个引用指向了Dog对象
        Cat cat = new Cat("汤姆", 5);
        if (animal instanceof Cat) {
            cat = (Cat) animal;
            cat.mew();
        }
        if (animal instanceof Dog) {
            dog = (Dog) animal;
            dog.bark();
        }
    }
}</code></pre> 
<p> <strong>运行结果：</strong></p> 
<p><img alt="" height="270" src="https://images2.imgbox.com/8e/36/AJM9M9Jf_o.png" width="557"></p> 
<h2 id="%C2%A0%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93" style="background-color:transparent;"> 五、总结</h2> 
<p>多态是面向对象的一个关键概念，它允许对象以不同的方式表现，具体取决于它们的类型。在 Java中，多态通过继承和方法重写来实现，让我们能够编写灵活、可扩展且可维护的代码。我们这期多态的内容就分享到这里，希望能够对大家有所帮助，感谢各位对蜡笔小欣的鼓励支持，我们下次再见！！！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/85414838196b4db06f554c85cf7e7997/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">AI绘画：利用ComfyUI进行文生图操作的完整指南</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e7fa56bda74f94bc05bd3bfc5a14a4aa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python绘制线图之plt.plot()的介绍以及使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>