<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>链表 --- C语言实现 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/42be5990a32c7087652e2d862754e9e4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="链表 --- C语言实现">
  <meta property="og:description" content="本篇文章来详细介绍一下数据结构中的链表。
目录
1.链表的概念及结构
2.链表的分类
3.单链表的实现
4.链表的面试题
5.双向链表的实现
6.顺序表和链表的区别
1.链表的概念及结构 概念：链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。
注意:
从上图可看出，链式结构在逻辑上是连续的，但是在物理上不一定连续现实中的结点一般都是从堆上申请出来的从堆上申请的空间，是按照一定的策略来分配的，两次申请的空间可能连续，也可能不连续 2.链表的分类 实际中链表的结构非常多样，以下3种情况组合起来就有8种链表结构，2^3 = 8：
1.单项或者双向
2.带头或者不带头
3.循环或者非循环
虽然有这么多的链表的结构，但是我们实际中最常用的还是两种结构
1.无头单向非循环链表
2.带头双向循环链表
1.无头单向非循环链表：结构简单，一般不会单独用来存数据。实际中更多是作为其他数据结构的子结构，如哈希桶、图的邻接表等等。另外这种结构在笔试面试中出现很多。
2.带头双向循环链表∶结构最复杂，一般用在单独存储数据。实际中使用的链表数据结构，都是带头双向循环链表。另外这个结构虽然结构复杂，但是使用代码实现以后会发现结构会带来很多优势，实现反而简单了，后面我们代码实现了就知道了。
3.单链表的实现 //无头&#43;单行&#43;非循环链表的增删改查实现 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;assert.h&gt; typedef int SLTDataType; typedef struct SListNode { SLTDataType data; struct SListNode* next; }SListNode; // 动态申请一个节点 SListNode* BuySListNode(SLTDataType x); // 单链表打印 void SListPrint(SListNode* plist); // 单链表尾插 void SListPushBack(SListNode** pplist, SLTDataType x); // 单链表的头插 void SListPushFront(SListNode** pplist, SLTDataType x); // 单链表的尾删 void SListPopBack(SListNode** pplist); // 单链表头删 void SListPopFront(SListNode** pplist); // 单链表查找 SListNode* SListFind(SListNode* plist, SLTDataType x); // 单链表在pos位置之后插入x // 分析思考为什么不在pos位置之前插入？因为单链表只能向后访问 void SlistInsertAfter(SListNode* pos, SLTDataType x); // 单链表删除pos位置之后的值 // 分析思考为什么不删除pos位置？因为单链表只能向后访问 void SlistEraseAfter(SListNode* pos); // 单链表的销毁 void SListDestroy(SListNode** pphead); //在pos之前插入 void SListInsert(SListNode** pphead, SListNode* pos, SLTDataType x); //删除pos位置的值 void SListErase(SListNode** pphead, SListNode* pos); 接口实现：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-07-20T20:50:14+08:00">
    <meta property="article:modified_time" content="2023-07-20T20:50:14+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">链表 --- C语言实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>本篇文章来详细介绍一下数据结构中的链表。</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#1.%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84" rel="nofollow">1.链表的概念及结构</a></p> 
<p id="2.%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB-toc" style="margin-left:0px;"><a href="#2.%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB" rel="nofollow">2.链表的分类</a></p> 
<p id="3.%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#3.%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">3.单链表的实现</a></p> 
<p id="4.%E9%93%BE%E8%A1%A8%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98-toc" style="margin-left:0px;"><a href="#4.%E9%93%BE%E8%A1%A8%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98" rel="nofollow">4.链表的面试题</a></p> 
<p id="5.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#5.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">5.双向链表的实现</a></p> 
<p id="6.%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:0px;"><a href="#6.%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">6.顺序表和链表的区别</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84">1.链表的概念及结构</h2> 
<p><span style="color:#38d8f0;"><strong>概念：</strong></span>链表是一种<strong>物理存储结构上<span style="color:#ff9900;">非连续</span></strong>、<span style="color:#4da8ee;"><strong>非顺序</strong></span>的存储结构，数据元素的<strong>逻辑顺序</strong>是通过链表中的<strong>指针链接</strong>次序实现的。<br>  </p> 
<p><img alt="" height="131" src="https://images2.imgbox.com/73/9d/rK2na7Rq_o.png" width="758"></p> 
<p><strong>注意:</strong></p> 
<ol><li>从上图可看出，链式结构在逻辑上是连续的，但是在物理上不一定连续</li><li>现实中的结点一般都是从堆上申请出来的</li><li>从堆上申请的空间，是按照一定的策略来分配的，两次申请的空间可能连续，也可能不连续</li></ol> 
<h2 id="2.%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB">2.链表的分类</h2> 
<p>实际中链表的结构非常多样，以下3种情况组合起来就有8种链表结构，2^3 = 8：<br>  </p> 
<p><strong>1.单项或者双向</strong></p> 
<p><img alt="" height="193" src="https://images2.imgbox.com/a2/53/Kh4TWMDU_o.png" width="680"></p> 
<p> </p> 
<p><strong>2.带头或者不带头</strong></p> 
<p><img alt="" height="176" src="https://images2.imgbox.com/3c/02/2EVtwaxe_o.png" width="601"></p> 
<p> </p> 
<p><strong>3.循环或者非循环</strong></p> 
<p><img alt="" height="212" src="https://images2.imgbox.com/d1/13/fu41xrtP_o.png" width="638"></p> 
<p><strong> 虽然有这么多的链表的结构，但是我们实际中最常用的还是两种结构</strong></p> 
<p><span style="color:#a2e043;"><strong> 1.无头单向非循环链表</strong></span></p> 
<p><img alt="" height="88" src="https://images2.imgbox.com/e7/a3/RZbSOxSS_o.png" width="612"></p> 
<p> </p> 
<p><span style="color:#956fe7;"><strong>2.带头双向循环链表</strong></span></p> 
<p><img alt="" height="150" src="https://images2.imgbox.com/d7/05/S1XXNgnH_o.png" width="834"></p> 
<p>1.<span style="color:#ff9900;"><strong>无头单向非循环链表</strong></span>：<strong>结构简单</strong>，一般不会单独用来存数据。实际中更多是作为<strong>其他数据结构的子结构</strong>，如哈希桶、图的邻接表等等。另外这种结构在<strong>笔试面试</strong>中出现很多。<br> 2.<strong><span style="color:#956fe7;">带头双向循环链表</span>∶结构最复杂</strong>，一般用在单独存储数据。实际中使用的链表数据结构，都是带头双向循环链表。另外这个结构虽然结构复杂，但是使用代码实现以后会发现结构会带来很多优势，<strong>实现反而简单</strong>了，后面我们代码实现了就知道了。</p> 
<h2 id="3.%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0">3.单链表的实现</h2> 
<pre><code class="language-cpp">//无头+单行+非循环链表的增删改查实现

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;

typedef int SLTDataType;

typedef struct SListNode
{
	SLTDataType data;
	struct SListNode* next;
}SListNode;

// 动态申请一个节点
SListNode* BuySListNode(SLTDataType x);
// 单链表打印
void SListPrint(SListNode* plist);
// 单链表尾插
void SListPushBack(SListNode** pplist, SLTDataType x);
// 单链表的头插
void SListPushFront(SListNode** pplist, SLTDataType x);
// 单链表的尾删
void SListPopBack(SListNode** pplist);
// 单链表头删
void SListPopFront(SListNode** pplist);
// 单链表查找
SListNode* SListFind(SListNode* plist, SLTDataType x);
// 单链表在pos位置之后插入x
// 分析思考为什么不在pos位置之前插入？因为单链表只能向后访问
void SlistInsertAfter(SListNode* pos, SLTDataType x);
// 单链表删除pos位置之后的值
// 分析思考为什么不删除pos位置？因为单链表只能向后访问
void SlistEraseAfter(SListNode* pos);

// 单链表的销毁
void SListDestroy(SListNode** pphead);

//在pos之前插入
void SListInsert(SListNode** pphead, SListNode* pos, SLTDataType x);

//删除pos位置的值
void SListErase(SListNode** pphead, SListNode* pos);</code></pre> 
<p><strong>接口实现：</strong></p> 
<pre><code class="language-cpp">// 动态申请一个节点
SListNode* BuySListNode(SLTDataType x)
{
	SListNode* newnode = (SListNode*)malloc(sizeof(SListNode));
	if (newnode == NULL)
	{
		perror("malloc fail");
		return NULL;
	}
	//申请成功
	newnode-&gt;data = x;
	newnode-&gt;next = NULL;
	return newnode;
}
// 单链表打印
void SListPrint(SListNode* plist)
{
	SListNode* cur = plist;
	while (cur)
	{
		printf("%d-&gt;", cur-&gt;data);
		cur = cur-&gt;next;
	}
	printf("NULL\n");
}
// 单链表尾插
void SListPushBack(SListNode** pplist, SLTDataType x)
{
	assert(pplist);//链表为空，pphead也不为空，因为它是头指针plist的地址

	SListNode* newnode = BuySListNode(x);
	//空链表
	if (*pplist == NULL)
	{
		*pplist = newnode;
	}
	else
	{
		SListNode* tail = *pplist;
		while (tail-&gt;next)
		{
			tail = tail-&gt;next;
		}
		tail-&gt;next = newnode;
	}
}
// 单链表的头插
void SListPushFront(SListNode** pplist, SLTDataType x)
{
	assert(pplist);//链表为空，pphead也不为空，因为它是头指针plist的地址
	SListNode* newnode = BuySListNode(x);

	newnode-&gt;next = *pplist;
	
	*pplist = newnode;
}
// 单链表的尾删
void SListPopBack(SListNode** pplist)
{
	assert(pplist);//链表为空，pphead也不为空，因为它是头指针plist的地址
	assert(*pplist);//空链表不能尾删

	if ((*pplist)-&gt;next == NULL)
	{
		free(*pplist);
		*pplist = NULL;
	}
	else
	{
		//方法一：
		SListNode* tail = *pplist;
		while (tail-&gt;next-&gt;next)
		{
			tail = tail-&gt;next;
		}
		free(tail-&gt;next);
		tail-&gt;next = NULL;
		//方法二
		/*SListNode* tail = *pplist;
		SListNode* prev = *pplist;
		while (tail-&gt;next)
		{
			prev = tail;
			tail = tail-&gt;next;
		}
		free(tail);
		prev-&gt;next = NULL;*/
	}
}
// 单链表头删
void SListPopFront(SListNode** pplist)
{
	assert(pplist);//链表为空，pphead也不为空，因为它是头指针plist的地址
	assert(*pplist);//空链表不能头删

	SListNode* del = *pplist;
	*pplist = (*pplist)-&gt;next;
	free(del);
	del = NULL;
}
// 单链表查找
SListNode* SListFind(SListNode* plist, SLTDataType x)
{
	SListNode* cul = plist;
	while (cul)
	{
		if (cul-&gt;data == x)
			return cul;
		cul = cul-&gt;next;
	}
	return NULL;
}
// 单链表在pos位置之后插入x
// 分析思考为什么不在pos位置之前插入？没有地址，找不到,单链表只能找后面的
void SlistInsertAfter(SListNode* pos, SLTDataType x)
{
	assert(pos);
	SListNode* newnode = BuySListNode(x);
	newnode-&gt;next = pos-&gt;next;
	pos-&gt;next = newnode;
}
// 单链表删除pos位置之后的值
// 分析思考为什么不删除pos位置？没有地址，找不到
void SlistEraseAfter(SListNode* pos)
{
	assert(pos);
	assert(pos-&gt;next);

	SListNode* del = pos-&gt;next;
	pos-&gt;next = pos-&gt;next-&gt;next;
	free(del);
	del = NULL;
}

// 单链表的销毁
void SListDestroy(SListNode** pphead)
{
	SListNode* del = *pphead;
	while (*pphead)
	{
		del = *pphead;
		*pphead = (*pphead)-&gt;next;
		free(del);
	}
}


//在pos之前插入
void SListInsert(SListNode** pphead, SListNode* pos, SLTDataType x)
{
	assert(pphead);
	SListNode* newnode = BuySListNode(x);
	if (pos == *pphead)
	{
		newnode-&gt;next = *pphead;
		*pphead = newnode;
	}
	else
	{
		SListNode* cur = *pphead;
		while (cur)
		{
			if (cur-&gt;next == pos)
			{
				newnode-&gt;next = pos;
				cur-&gt;next = newnode;
				return;
			}
			cur = cur-&gt;next;
		}
	}
}

//删除pos位置的值
void SListErase(SListNode** pphead, SListNode* pos)
{
	assert(pphead);
	assert(*pphead);
	assert(pos);
	if (pos == *pphead)
	{
		*pphead = (*pphead)-&gt;next;
		free(pos);
	}
	else
	{
		SListNode* cur = *pphead;
		while (cur)
		{
			if (cur-&gt;next == pos)
			{
				cur-&gt;next = pos-&gt;next;
				free(pos);
				return;
			}
			cur = cur-&gt;next;
		}
	
	}
}</code></pre> 
<h2 id="4.%E9%93%BE%E8%A1%A8%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98">4.链表的面试题</h2> 
<p>1.删除链表中等于给定值val的所有结点。<a class="link-info" href="https://leetcode.cn/problems/remove-linked-list-elements/description/" rel="nofollow" title="OJ链接">OJ链接</a></p> 
<p>2.反转一个单链表。<a class="link-info" href="https://leetcode.cn/problems/reverse-linked-list/description/" rel="nofollow" title="OJ链接">OJ链接</a></p> 
<p>3.给定一个带有头结点head的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。<a class="link-info" href="https://leetcode.cn/problems/middle-of-the-linked-list/description/" rel="nofollow" title="ОJ链接">ОJ链接</a></p> 
<p>4.输入一个链表，输出该链表中倒数第k个结点。<a class="link-info" href="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&amp;&amp;tqId=11167&amp;rp=2&amp;ru=/activity/oj&amp;qru=/ta/coding-interviews/question-ranking" rel="nofollow" title="OJ链接">OJ链接</a></p> 
<p>5.将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有结点组成的。<a class="link-info" href="https://leetcode.cn/problems/merge-two-sorted-lists/description/" rel="nofollow" title="OJ链接">OJ链接</a></p> 
<p>6.编写代码，以给定值x为基准将链表分割成两部分，所有小于x的结点排在大于或等于x的结点之前。<a class="link-info" href="https://www.nowcoder.com/practice/0e27e0b064de4eacac178676ef9c9d70?tpId=8&amp;&amp;tqId=11004&amp;rp=2&amp;ru=/activity/oj&amp;qru=/ta/cracking-the-coding-interview/question-ranking" rel="nofollow" title="OJ链接">OJ链接</a></p> 
<p>7.链表的回文结构。<a class="link-info" href="https://www.nowcoder.com/practice/d281619e4b3e4a60a2cc66ea32855bfa?tpId=49&amp;&amp;tqId=29370&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/2016test/question-ranking" rel="nofollow" title="OJ链接">OJ链接</a></p> 
<p>8.输入两个链表，找出它们的第一个公共结点。<a class="link-info" href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/" rel="nofollow" title="OJ链接">OJ链接</a></p> 
<p><span style="color:#fe2c24;"><strong>9.给定一个链表，判断链表中是否有环</strong></span>。<a class="link-info" href="https://leetcode.cn/problems/linked-list-cycle/description/" rel="nofollow" title="OJ链接">OJ链接</a></p> 
<p><strong>【思路】</strong></p> 
<p>快慢指针，即慢指针一次走一步，快指针一次走两步，两个指针从链表起始位置开始运行，如果链表带环则一定会在环中相遇，否则快指针率先走到链表的末尾。</p> 
<p><strong>【扩展问题】</strong></p> 
<p><span style="color:#ff9900;"><strong>1.为什么快指针每次走两步，慢指针走一步可以?</strong></span></p> 
<p>假设链表带环，两个指针最后都会进入环，快指针先进环，慢指针后进环。当慢指针刚进环时，可能就和快指针相遇了，最差情况下两个指针之间的距离刚好就是环的长度。此时，两个指针每移动一次，之间的距离就缩小一步，不会出现每次刚好是套圈的情况，因此:在慢指针走到一圈之前，快指针肯定是可以追上慢指针的，即相遇。</p> 
<p><span style="color:#ff9900;"><strong>2.快指针一次走3步，走4步，...n步行吗?</strong></span></p> 
<p>假设:快指针每次走3步，满指针每次走一步，此时快指针肯定先进环，慢指针后来才进<br> 环。假设慢指针进环时候，快指针的位置如图所示:</p> 
<p><img alt="" height="160" src="https://images2.imgbox.com/b3/44/4wba26P0_o.png" width="585"></p> 
<p>此时按照上述方法来绕环移动，每次快指针走3步，慢指针走1步，是永远不会相遇的，快指针刚好将慢指针套圈了，因此不行。<br> 只有快指针走2步，慢指针走一步才可以，因为换的最小长度是1，即使套圈了两个也在相同的位置。</p> 
<p><span style="color:#fe2c24;"><strong>10.给定一个链表，返回链表开始入环的第一个结点。如果链表无环，则返回NULL。</strong></span><a class="link-info" href="https://leetcode.cn/problems/linked-list-cycle-ii/description/" rel="nofollow" title="OJ链接">OJ链接</a></p> 
<p><strong><span style="color:#38d8f0;">结论：</span></strong></p> 
<p>双指针：先让<strong>一个指针走一步</strong>，一个<strong>指针走两步</strong>，最终两个指针会在<strong>环内相遇</strong>。再让一个指针从链表起始位置开始遍历链表，同时让一个指针从判环时相遇点的位置开始绕环运行，两个指针都是每次均走一步，最终肯定会在入口点的位置相遇。</p> 
<p><span style="color:#38d8f0;"><strong>证明：</strong></span><br><img alt="" height="650" src="https://images2.imgbox.com/9b/74/VaulfAKl_o.png" width="1059"></p> 
<p><strong>说明:</strong></p> 
<p>phead为链表的起始点，E为环入口点，<strong>M与判断是否是环的时候相遇点（快慢指针第9题）</strong></p> 
<p><strong>设:</strong></p> 
<p>环的长度为R，H到E的距离为LE到M的距离为X则:M到E的距离为R-x</p> 
<p>在判环时，快慢指针相遇时所走的路径长度:</p> 
<ul><li>fast: L +X + nR</li><li>slow: L+ x</li></ul> 
<p><strong>注意:</strong></p> 
<p>1.当慢指针进入环时，快指针可能已经在环中绕了n圈了，n至少为1因为:快指针先进环走到M的位置，最后又在M的位置与慢指针相遇</p> 
<p>2.慢指针进环之后，快指针肯定会在慢指针走一圈之内追上慢指针</p> 
<p>因为:慢指针进环后，快慢指针之间的距离最多就是环的长度，而两个指针在移动时，每次它们至今的距离都缩减一步（速度差是1），因此在慢指针移动一圈之前快指针肯定是可以追上慢指针的</p> 
<p><strong>而快指针速度是满指针的两倍，</strong>因此有如下关系是:2*(L+ X)= L+ X + nR<br> L+ x = nR<br> L= nR- x(n为1,2,3,4.......n的大小取决于环的大小，环越小n越大)</p> 
<p>极端情况下，假设n = 1，此时:L =R- x</p> 
<p>即：<span style="color:#fe2c24;"><strong>一个指针从链表起始位置运行，一个指针从相遇点位置绕环，每次都走一步，两个指针最终会在入口点的位置相遇</strong></span></p> 
<p>11.给定一个链表，每个结点包含一个额外增加的随机指针，该指针可以指向链表中的任何结点<br> 或空结点。</p> 
<p>要求返回这个链表的深度拷贝。<a class="link-info" href="https://leetcode.cn/problems/copy-list-with-random-pointer/description/" rel="nofollow" title="OJ链接">OJ链接</a><br>  </p> 
<h2 id="5.%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0">5.双向链表的实现</h2> 
<pre><code class="language-cpp">// 带头+双向+循环链表增删查改实现
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;

typedef int LTDataType;

typedef struct ListNode
{
	struct ListNode* prev;
	LTDataType data;
	struct ListNode* next;
}LTNode;

//初始化
//void InitListNode(LTNode** phead)//使用二级指针
LTNode* InitListNode();//使用返回值
//打印
void LTPrint(LTNode* phead);
//尾插
void LTPushBack(LTNode* phead, LTDataType x);
//头插
void LTPushFront(LTNode* phead, LTDataType x);
//判空
bool LTEmpty(LTNode* phead);
//尾删
void LTPopBack(LTNode* phead);
//头删
void LTPopFront(LTNode* phead);

//查找
LTNode* LTFind(LTNode* phead, LTDataType x);

//pos之前插入(与顺序表一致）
void LTInsert(LTNode* pos, LTDataType x);
//删除pos位置的值
void LTErase(LTNode* pos);
//释放链表
void LTDestroy(LTNode* phead);</code></pre> 
<p><strong> 接口实现：</strong></p> 
<pre><code class="language-cpp">LTNode* BuyaNewNode(LTDataType x)
{
	LTNode* newnode = (LTNode*)malloc(sizeof(LTNode));
	if (newnode == NULL)
	{
		perror("malloc fail");
		return NULL;
	}
	newnode-&gt;prev = NULL;
	newnode-&gt;next = NULL;
	newnode-&gt;data = x;
	return newnode;
}

//初始化
LTNode* InitListNode()
{
	LTNode* phead = BuyaNewNode(0);
	phead-&gt;next = phead;
	phead-&gt;prev = phead;
	return phead; 
}

//打印
void LTPrint(LTNode* phead)
{
	assert(phead);
	printf("gurad&lt;==&gt;");
	LTNode* cur = phead-&gt;next;
	while (cur != phead)
	{
		printf("%d&lt;==&gt;", cur-&gt;data);
		cur = cur-&gt;next;
	}
	printf("gurad\n");
}

//尾插
void LTPushBack(LTNode* phead, LTDataType x)
{
	//LTInsert(phead, x);
	assert(phead);
	LTNode* newnode = BuyaNewNode(x);

	LTNode* tail = phead-&gt;prev;
	tail-&gt;next = newnode;
	newnode-&gt;prev = tail;
	newnode-&gt;next = phead;
	phead-&gt;prev = newnode;
}

//头插
void LTPushFront(LTNode* phead, LTDataType x)
{
	//LTInsert(phead-&gt;next, x);
	assert(phead);
	LTNode* newnode = BuyaNewNode(x);

	newnode-&gt;next = phead-&gt;next;
	phead-&gt;next = newnode;
	newnode-&gt;prev = phead;
	newnode-&gt;next-&gt;prev = newnode;
}

bool LTEmpty(LTNode* phead)
{
	if (phead-&gt;next == phead)
	{
		return true;
	}
	else
	{
		return false;
	}
}


//尾删
void LTPopBack(LTNode* phead)
{
	assert(phead);
	assert(!LTEmpty(phead));//空链表 
	//LTErase(phead-&gt;prev);
	LTNode* tail = phead-&gt;prev;
	LTNode* tailprev = tail-&gt;prev;
	free(tail);
	phead-&gt;prev = tailprev;
	tailprev-&gt;next = phead;
	
}

//头删
void LTPopFront(LTNode* phead)
{
	assert(phead);
	assert(!LTEmpty(phead));//空链表 
	//LTErase(phead-&gt;next);
	LTNode* frist = phead-&gt;next;
	LTNode* second = frist-&gt;next;
	free(frist);
	phead-&gt;next = second;
	second-&gt;prev = phead;
}

//查找
LTNode* LTFind(LTNode* phead, LTDataType x)
{
	assert(phead);
	LTNode* cur = phead-&gt;next;
	while (cur != phead)
	{
		if (cur-&gt;data == x)
		{
			return cur;
		}
		cur = cur-&gt;next;
	}
	return NULL;
}

//pos之前插入(与顺序表一致）
void LTInsert(LTNode* pos, LTDataType x)
{
	assert(pos);
	LTNode* newnode = BuyaNewNode(x);
	LTNode* prev = pos-&gt;prev;

	newnode-&gt;prev = prev;
	newnode-&gt;next = pos;
	prev-&gt;next = newnode;
	pos-&gt;prev = newnode;
}

//删除pos位置的值
void LTErase(LTNode* pos)
{
	assert(pos);
	LTNode* prev = pos-&gt;prev;
	LTNode* next = pos-&gt;next;

	prev-&gt;next = next;
	next-&gt;prev = prev;

	free(pos);
}

//释放链表
void LTDestroy(LTNode* phead)
{
	assert(phead);
	LTNode* cur = phead-&gt;next;
	while (cur != phead)
	{
		LTNode* next = cur-&gt;next;
		free(cur);
		cur = next;
	}
	free(phead);
}</code></pre> 
<h2 id="6.%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB">6.顺序表和链表的区别</h2> 
<p><span style="color:#4da8ee;"><strong>链表（双向循环带头链表）：</strong></span></p> 
<p><span style="color:#956fe7;"><strong> 优点：</strong></span></p> 
<ol><li>任意位置插入删除O(1)</li><li>按需申请释放空间</li></ol> 
<p><span style="color:#956fe7;"><strong> 缺点：</strong></span></p> 
<ol><li>不支持下标随机访问</li><li>CPU高速缓存命中率会更低</li></ol> 
<p><span style="color:#4da8ee;"><strong>顺序表:</strong></span></p> 
<p><span style="color:#956fe7;"><strong>缺点:</strong></span></p> 
<ol><li>前面部分插入删除数据，效率是O(N)，需要挪动数据。</li><li>空间不够，需要扩容。a、扩容是需要付出代价的 b、一般还会伴随空间浪费。</li></ol> 
<p><span style="color:#956fe7;"><strong>优点:</strong></span></p> 
<ol><li>尾插尾删效率不错。</li><li>下标的随机访问。</li><li>CPU高速缓存命中率会更高<br>  </li></ol> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>不同点</td><td>顺序表</td><td>链表</td></tr><tr><td>存储空间上</td><td>物理上一定连续</td><td>逻辑上连续，但物理上不一定连续</td></tr><tr><td>随机访问</td><td>支持O(1)</td><td>不支持，为O(N)</td></tr><tr><td>任意位置插入或者删除元素</td><td>可能需要搬移元素，效率低O(N)</td><td>只需要修改指针指向</td></tr><tr><td>插入</td><td>动态顺序表，空间不够时需要扩容</td><td>没有容量的概念</td></tr><tr><td>应用场景</td><td>元素高效存储+频繁访问</td><td>任意位置插入或删除频繁</td></tr><tr><td>缓存利用率</td><td>高</td><td>低</td></tr></tbody></table> 
<p> 备注：缓存利用率参考存储体系结构 以及 程序的局部性原理。</p> 
<p><img alt="" height="565" src="https://images2.imgbox.com/09/c4/nchiFP7H_o.png" width="832"></p> 
<p> 数据结构是为了帮助我们跟好的<strong>管理内存</strong>。内存需要电，关机后就会消失，磁盘存储的数据在关机后也不会消失。</p> 
<p>在CPU与内存之间存在寄存器和三级缓存。内存小使用寄存器（一般几个字节），大的使用三级缓存。</p> 
<p>CPU读取数据时</p> 
<ol><li> 先去看数据是否在缓存，在就叫缓存命中，则直接访问</li><li>不在就不命中，先加载数据到缓存，再访问</li></ol> 
<p>因为缓存一次会加载需要的数据以及这个数据旁边的数据，数组是连续存放的，所以<span style="color:#a2e043;"><strong>缓存利用率高</strong></span>。</p> 
<p>可以参考：<a class="link-info" href="https://coolshell.cn/articles/20793.html" rel="nofollow" title="与程序员相关的CPU缓存知识">与程序员相关的CPU缓存知识</a></p> 
<p><span style="color:#38d8f0;"><strong>本篇结束。</strong></span><img alt="" height="1200" src="https://images2.imgbox.com/fd/d9/ZyUF0jgI_o.jpg" width="1000"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d04e17afdb1fa11324eece53cc2535ff/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQL免安装版教程(超详细图文教程)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2ec2af6d77055f64f1f580c0063a80a9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mac系统占用100多G怎么清除 mac内存系统占用了好多怎么清理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>