<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[数据结构] 基于交换的排序 冒泡排序&amp;&amp;快速排序 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/730b4f3b4c2e16169ec51bc038a8428a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="[数据结构] 基于交换的排序 冒泡排序&&快速排序">
  <meta property="og:description" content="标题：[数据结构] 基于交换的排序 冒泡排序&amp;&amp;快速排序
@水墨不写bug
（图片来源于网络） 目录
（一）冒泡排序
优化后实现：
（二）快速排序
I、实现方法： （1）hoare法
hoare法实现快排：
（2）挖坑法
挖坑法实现：
（3）双指针法 双指针法实现： II、快速排序复杂度分析：
比较完备的快速排序实现如下：
正文开始：
（一）冒泡排序 时间复杂度：O（N^2）
空间复杂度：O（1）
特点：数组接近有序时，可通过优化来提高效率。
稳定性：稳定
冒泡排序：
基本思想：大数下沉，小数上浮。
实现思路：从内循环到外循环，从一趟到多趟。
冒泡排序通过两层循环来实现，内层循环实现其中的一趟遍历，在一趟的遍历中，需要注意要控制好左右区间边界，冒泡排序的实现方式是多样的，无论用何种实现方式，最主要的是控制好边界，以及内外层循环的衔接；以下是一种冒泡排序的写法：
void BubbleSort(vector&lt;int&gt;&amp; nums) { int n = nums.size(); for (int j = 0; j &lt; n - 1; &#43;&#43;j) { for (int i = 0; i &lt; n - 1 - j; &#43;&#43;i) { if (nums[i] &gt; nums[i &#43; 1]) { ::swap(nums[i], nums[i &#43; 1]); } } } } 优化：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-06T22:36:48+08:00">
    <meta property="article:modified_time" content="2024-07-06T22:36:48+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[数据结构] 基于交换的排序 冒泡排序&amp;&amp;快速排序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><strong>标题：[数据结构] 基于交换的排序 冒泡排序&amp;&amp;快速排序</strong></p> 
<p style="text-align:center;"><strong>@水墨不写bug</strong></p> 
<hr> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/08/58/IKQM8Ere_o.png"></p> 
<p style="text-align:right;">（图片来源于网络） </p> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%EF%BC%88%E4%B8%80%EF%BC%89%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E4%B8%80%EF%BC%89%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" rel="nofollow">（一）冒泡排序</a></p> 
<p id="%E4%BC%98%E5%8C%96%E5%90%8E%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E4%BC%98%E5%8C%96%E5%90%8E%E5%AE%9E%E7%8E%B0%EF%BC%9A" rel="nofollow">优化后实现：</a></p> 
<p id="%EF%BC%88%E4%BA%8C%EF%BC%89%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-toc" style="margin-left:0px;"><a href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" rel="nofollow">（二）快速排序</a></p> 
<p id="I%E3%80%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%EF%BC%9A%C2%A0-toc" style="margin-left:40px;"><a href="#I%E3%80%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%EF%BC%9A%C2%A0" rel="nofollow">I、实现方法： </a></p> 
<p id="%EF%BC%881%EF%BC%89hoare%E6%B3%95-toc" style="margin-left:40px;"><a href="#%EF%BC%881%EF%BC%89hoare%E6%B3%95" rel="nofollow">（1）hoare法</a></p> 
<p id="hoare%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%BF%AB%E6%8E%92%EF%BC%9A-toc" style="margin-left:40px;"><a href="#hoare%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%BF%AB%E6%8E%92%EF%BC%9A" rel="nofollow">hoare法实现快排：</a></p> 
<p id="%C2%A0%EF%BC%882%EF%BC%89%E6%8C%96%E5%9D%91%E6%B3%95-toc" style="margin-left:40px;"><a href="#%C2%A0%EF%BC%882%EF%BC%89%E6%8C%96%E5%9D%91%E6%B3%95" rel="nofollow"> （2）挖坑法</a></p> 
<p id="%E6%8C%96%E5%9D%91%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E6%8C%96%E5%9D%91%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%9A" rel="nofollow">挖坑法实现：</a></p> 
<p id="%EF%BC%883%EF%BC%89%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95%C2%A0-toc" style="margin-left:0px;"><a href="#%EF%BC%883%EF%BC%89%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95%C2%A0" rel="nofollow">（3）双指针法 </a></p> 
<p id="%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%9A%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%9A%C2%A0" rel="nofollow">双指针法实现： </a></p> 
<p id="%C2%A0II%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%C2%A0II%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%9A" rel="nofollow"> II、快速排序复杂度分析：</a></p> 
<p id="%E6%AF%94%E8%BE%83%E5%AE%8C%E5%A4%87%E7%9A%84%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%A6%82%E4%B8%8B%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E6%AF%94%E8%BE%83%E5%AE%8C%E5%A4%87%E7%9A%84%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%A6%82%E4%B8%8B%EF%BC%9A" rel="nofollow">比较完备的快速排序实现如下：</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<p>正文开始：</p> 
<h2 id="%EF%BC%88%E4%B8%80%EF%BC%89%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">（一）冒泡排序</h2> 
<blockquote> 
 <p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/76/6b/1vHPMWtp_o.gif"></p> 
 <p style="text-align:center;"><strong>时间复杂度：O（N^2）</strong></p> 
 <p style="text-align:center;"><strong>空间复杂度：O（1）</strong></p> 
 <p style="text-align:center;"><strong>特点：数组接近有序时，可通过优化来提高效率。</strong></p> 
 <p style="text-align:center;"><strong>稳定性：稳定</strong></p> 
</blockquote> 
<blockquote> 
 <p>冒泡排序：</p> 
 <p>       <strong> 基本思想：大数下沉，小数上浮。</strong></p> 
 <p><strong>        实现思路：从内循环到外循环，从一趟到多趟。</strong></p> 
 <p>        冒泡排序通过两层循环来实现，内层循环实现其中的一趟遍历，在一趟的遍历中，需要注意要控制好左右区间边界，冒泡排序的实现方式是多样的，无论用何种实现方式，最主要的是控制好边界，以及内外层循环的衔接；以下是一种冒泡排序的写法：</p> 
 <pre><code class="language-cpp">
void BubbleSort(vector&lt;int&gt;&amp; nums)
{
	int n = nums.size();
	for (int j = 0; j &lt; n - 1; ++j)
	{
		for (int i = 0; i &lt; n - 1 - j; ++i)
		{
			if (nums[i] &gt; nums[i + 1])
			{
			
				::swap(nums[i], nums[i + 1]);
			}
		}
	}
}</code></pre> 
 <p><strong>优化：</strong></p> 
 <p><strong>        如果在一次遍历的过程中，没有进入if（）交换，这已经说明数组已经有序，可以直接停止排序。</strong></p> 
 <p></p> 
 <h3 id="%E4%BC%98%E5%8C%96%E5%90%8E%E5%AE%9E%E7%8E%B0%EF%BC%9A"><strong>优化后实现：</strong></h3> 
 <pre><code class="language-cpp">
void BubbleSort(vector&lt;int&gt;&amp; nums)
{
	int n = nums.size();
	for (int j = 0; j &lt; n - 1; ++j)
	{
		int ex = 0;
		for (int i = 0; i &lt; n - 1 - j; ++i)
		{
			if (nums[i] &gt; nums[i + 1])
			{
				ex = 1;
				::swap(nums[i], nums[i + 1]);
			}
		}
		if (ex == 0)
			break;
	}
}</code></pre> 
 <p></p> 
</blockquote> 
<p></p> 
<hr> 
<h2 id="%EF%BC%88%E4%BA%8C%EF%BC%89%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">（二）快速排序</h2> 
<blockquote> 
 <p style="text-align:center;"></p> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f5/2c/XsTcMJfA_o.gif"></p> 
 <p style="text-align:center;"><strong>时间复杂度：O（NlogN）</strong></p> 
 <p style="text-align:center;"><strong>空间复杂度：</strong></p> 
 <p style="text-align:center;"><strong>特点：当数据接近有序，比如逆序的时候；或者选取的key在数据中大量存在时，快速排序时间复杂度会退化为O（N^2），这是相当严重的缺陷。</strong></p> 
 <p style="text-align:center;"><strong>稳定性：不稳定。</strong></p> 
</blockquote> 
<blockquote> 
 <p>        快速排序是Hoare于1962年提出的一种二叉树结构的交换排序方法。</p> 
 <p>        <strong>基本思想：任取待排序元素序列中的某元素（记为key）作为基准值，按照key值将待排序集合分割成两子序列，左子序列中所有元素均小于基准值key，右子序列中所有元素均大于基准值key。然后递归，左右子序列重复该过程，直到所有元素都排列在相应位置上为止。</strong></p> 
</blockquote> 
<blockquote> 
 <p>        本质就是将数组根据key值分为两部分，一部分比key大，一部分比key小。对于每一个部分，再次进行如上操作，直到数组不可再分为止。这就是递归实现的浅层次的直观理解。但是递归不是本文的重点，关于递归，我会在后面与你分享。 </p> 
</blockquote> 
<h3 id="I%E3%80%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%EF%BC%9A%C2%A0"><strong>I、实现方法： </strong></h3> 
<h3 id="%EF%BC%881%EF%BC%89hoare%E6%B3%95"><strong>（1）hoare法</strong></h3> 
<p>        hoare法是快排的提出者hoare提供的方法，是一种经典的实现方法。</p> 
<blockquote> 
 <p><strong>实现原理：</strong></p> 
 <p><strong>        定义两个下标：左下标L  和  右下标R；</strong></p> 
 <p><strong>        随机选取一个key值，习惯上我们选择区间的最左侧的元素为key；</strong></p> 
 <p>        让右下标先走，向左寻找比key小的值，找到后停下来：</p> 
 <p><img alt="" height="546" src="https://images2.imgbox.com/c3/7d/VyqU347Y_o.png" width="1145"></p> 
 <p> 停下来后：</p> 
 <p><img alt="" height="319" src="https://images2.imgbox.com/ee/d9/6mw9cMOJ_o.png" width="999"></p> 
 <p> 左下标再向右寻找比key大的值，找到后停下来：</p> 
 <p><img alt="" height="312" src="https://images2.imgbox.com/42/50/B9zr1I29_o.png" width="935"></p> 
 <p>此时，交换两个下标对应的值：</p> 
 <p> <img alt="" height="347" src="https://images2.imgbox.com/f9/76/4jzjI3BR_o.png" width="998"></p> 
 <p>接下来继续执行上述步骤（R先走），我展示关键步骤：</p> 
 <p> 两下标找到要求目标并交换：<img alt="" height="363" src="https://images2.imgbox.com/7e/d8/EOuTAAKS_o.png" width="986"></p> 
 <p><img alt="" height="339" src="https://images2.imgbox.com/0b/38/9ljzprYF_o.png" width="994"></p> 
 <p>直到遇到特殊情况：两下标相遇</p> 
 <p> <img alt="" height="456" src="https://images2.imgbox.com/4a/8c/t7WnLlOj_o.png" width="1034"></p> 
 <p> 这时停止停止循环，将最左侧元素与相遇处的元素交换位置：<img alt="" height="472" src="https://images2.imgbox.com/98/47/npiJb0AU_o.png" width="985"><br> 即可完成一次二分。</p> 
 <p>        <strong>接下来，对于左右区间再次进行上述操作，直到区间不可再分为止。</strong></p> 
 <hr> 
 <p><strong>但是如何保证相遇处的值一定小于key呢？</strong></p> 
 <p></p> 
 <p>对于相遇这个事件，有且仅有两种情况：</p> 
 <p><strong>只可能是R向左移动遇到L；或者是L向右移动遇到R；</strong></p> 
 <p><strong>        （1）R向左移动遇到L：有两种可能情况</strong></p> 
 <p>                       <em> a，第一次R由于没有找到比key小的值，直接一路向左遇到left，此时left就是key，然后执行自己与自己交换：此时相遇的位置的值就是key本身。</em></p> 
 <p><em>                        b，第一次之后R向左遇到L，你要想清楚，在此之前L停止的地方是被交换后的原先R的值（它是比key小的）；在这样的前提条件下，R向左移动与L相遇了，说明R没有找到小于key的元素，与L相遇后指向L的比key小的值。</em></p> 
 <p>        <strong>（2）L向右移动遇到R</strong></p> 
 <p><strong>                       <em> </em></strong><em>R先走，在找到比key小的位置停下，在此前提下，L向右移动与R相遇了，L指向R的比key小的值。</em></p> 
</blockquote> 
<blockquote> 
 <h3 id="hoare%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%BF%AB%E6%8E%92%EF%BC%9A"><strong>hoare法实现快排：</strong></h3> 
 <pre><code class="language-cpp">
void QuickSort(vector&lt;int&gt;&amp; nums,int left,int right)
{
	//递归出口，此时区间不存在或者只有一个值
	if (left &gt;= right)
		return;
	//保存左右下标的值，便于在递归时找到原来的区间边界
	int begin = left, end = right;
	//keyi来记录左区间的下标
	int keyi = left;

	while (left &lt; right)
	{
		//右下标先走，找小
		while (left &lt; right &amp;&amp; nums[keyi] &lt;= nums[right])
		{
			--right;
		}//左区间再走，找大
		while (left &lt; right &amp;&amp; nums[left] &lt;= nums[keyi])
		{
			++left;
		}
		::swap(nums[left], nums[right]);
	}//此时一趟完毕，将key与相遇位置交换
	::swap(nums[left], nums[keyi]);
	keyi = left;//更新keyi

	//递归左右区间
	QuickSort(nums, begin, keyi);
	QuickSort(nums, keyi+1, end);
}</code></pre> 
</blockquote> 
<h3 id="%C2%A0%EF%BC%882%EF%BC%89%E6%8C%96%E5%9D%91%E6%B3%95"> （2）挖坑法</h3> 
<blockquote> 
 <p>实现原理：</p> 
 <p><img alt="" height="546" src="https://images2.imgbox.com/29/07/iv6MfMph_o.png" width="1145"></p> 
 <p><img alt="" height="470" src="https://images2.imgbox.com/67/b3/MKVs6KDd_o.png" width="993"></p> 
 <p>        由于左边有坑，所以右下标先走。</p> 
 <p>        找小，找到后停下来，将找到的值放在坑中，R的位置就成为了新的坑：</p> 
 <p><img alt="" height="314" src="https://images2.imgbox.com/fc/63/cdmW4W8K_o.png" width="925"></p> 
 <p><img alt="" height="341" src="https://images2.imgbox.com/d1/ec/SXIy7f8C_o.png" width="963"></p> 
 <p>此时坑在右边，左边下标先走，找大：</p> 
 <p><img alt="" height="339" src="https://images2.imgbox.com/4c/c3/9QksYK6k_o.png" width="963"></p> 
 <p><img alt="" height="330" src="https://images2.imgbox.com/8d/6b/d1Eupqcd_o.png" width="935"></p> 
 <p>找到后交换，左边又成为新的坑。</p> 
 <p>以此类推，直到左右相遇，相遇的位置一定是坑，此时将key放到坑中，完成单趟：</p> 
 <p><img alt="" height="426" src="https://images2.imgbox.com/13/5c/xc1m9TVO_o.png" width="952"></p> 
 <p><img alt="" height="456" src="https://images2.imgbox.com/08/72/BqMTMvfd_o.png" width="1065"></p> 
 <p>依然是左边都是比6小，右边都是比6大，说明没有错误。</p> 
</blockquote> 
<blockquote> 
 <h3 id="%E6%8C%96%E5%9D%91%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%9A">挖坑法实现：</h3> 
 <p></p> 
 <pre><code class="language-cpp">void QuickSort_(vector&lt;int&gt;&amp; nums, int left, int right)
{
	if (left &gt;= right)
		return;
	int begin = left, end = right;
	int key = nums[left];//记住key的值
	int hole = left;//开始挖坑
	while (left &lt; right)
	{
		//右先找比key大的
		while (left &lt; right &amp;&amp; nums[right] &gt;= key)
			right--;
		//找到后，填坑，然后挖新坑
		nums[hole] = nums[right];
		hole = right;
		//左找比key小的
		while (left &lt; right &amp;&amp; nums[left] &lt;= key)
			left++;
		//找到后，填坑，然后挖新坑
		nums[hole] = nums[left];
		hole = left;
	}
	//此时相遇了，把key值放在坑里
	nums[hole] = key;

	QuickSort_(nums,begin,hole);
	QuickSort_(nums,hole + 1,end);
}</code></pre> 
</blockquote> 
<h2 id="%EF%BC%883%EF%BC%89%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95%C2%A0">（3）双指针法 </h2> 
<blockquote> 
 <p> <img alt="" height="546" src="https://images2.imgbox.com/b6/64/kfIWXZK4_o.png" width="1145"></p> 
 <p></p> 
 <p><strong>// 设置前指针prev，指向首元素，遍历指针cur指向第二个元素，<br> // 接下来cur开始找小，如果没找到小，就一直往前走；</strong></p> 
 <p><strong>//如果找到小的了，就先停下来，然后prev往前走一步，再和cur交换值，然后cur继续向后，重复上述步骤，<br> // 最后cur走出数组后，循环终止！此时prev指向的位置和keyi的位置交换。</strong></p> 
 <p></p> 
 <p><strong>我们详细看一下过程：</strong></p> 
 <p>        <img alt="" height="386" src="https://images2.imgbox.com/58/3c/unOxgIeH_o.png" width="988"></p> 
 <p><img alt="" height="395" src="https://images2.imgbox.com/17/ca/WwKreGD9_o.png" width="1035"></p> 
 <p><img alt="" height="380" src="https://images2.imgbox.com/1d/b9/elFAU9DC_o.png" width="967"></p> 
 <p><img alt="" height="395" src="https://images2.imgbox.com/00/24/jbr5WkFC_o.png" width="966"></p> 
 <p><img alt="" height="373" src="https://images2.imgbox.com/13/e8/bqxMjjFb_o.png" width="1032"></p> 
 <p></p> 
 <p><img alt="" height="383" src="https://images2.imgbox.com/a7/f6/SObdud7j_o.png" width="984"></p> 
 <p><img alt="" height="253" src="https://images2.imgbox.com/b4/88/zFbBJEL0_o.png" width="647"></p> 
 <p><img alt="" height="211" src="https://images2.imgbox.com/3e/ae/YraBPuKo_o.png" width="646"></p> 
 <p><img alt="" height="335" src="https://images2.imgbox.com/9c/2f/xz1m94b9_o.png" width="1068"></p> 
 <p><img alt="" height="361" src="https://images2.imgbox.com/54/49/V8xyATWg_o.png" width="974"></p> 
 <p></p> 
</blockquote> 
<blockquote> 
 <h3 id="%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%9A%C2%A0">双指针法实现： </h3> 
 <pre><code class="language-cpp">
void QuickSort__(vector&lt;int&gt;&amp; nums, int left, int right)
{
	if (left &gt;= right)
		return;
	int begin = left, end = right;
	int prev = left;
	int cur = left + 1;
	int keyi = left;
	while (cur &lt;= right)//cur走出数组循环停止
	{
		//cur一直在走，如果遇到比keyi小的，就停下来等perv走一步后交换，再接着走
		if (nums[cur] &lt; nums[keyi] &amp;&amp; ++prev != cur)
			swap(nums[prev], nums[cur]);
		cur++;
	}
	//cur出去后，prev的值和keyi交换
	swap(nums[keyi], nums[prev]);
	QuickSort__(nums,left,keyi);
	QuickSort__(nums,keyi+1,end);
	
}</code></pre> 
</blockquote> 
<h2 id="%C2%A0II%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%9A"> II、快速排序复杂度分析：</h2> 
<blockquote> 
 <p>        传统的快速排序在处理一些极端问题时会显得无力，接下来我们就来讨论这些极端情况，并且给出应对极端情况的方法：</p> 
 <p><strong>1.对于选择key不合适的问题：</strong></p> 
 <p>        在数组元素接近逆序的时候，由于我们总是在区间的最左侧选取key，如果数组接近逆序，这时选取的key无法有效的将数组分为两个等大的数组，这就导致一次只能排序一个元素，这导致快速排序的复杂度会退化为O（N^2）,这就需要我们不能随便取key。可以通过随机数法在区间内随机取一个元素作为key即可。</p> 
 <p><strong>2.关于选择key大量出现的问题：</strong></p> 
 <p><strong>        如果key大量出现，也会导致上述的情况，一次只能排序一个数，所以我们不能随便分区间，这就要求我们将数组分为三部分，左侧区间都小于key，中间区间则是数值等于key的元素，右侧区间是大于key的数值。</strong></p> 
</blockquote> 
<h3 id="%E6%AF%94%E8%BE%83%E5%AE%8C%E5%A4%87%E7%9A%84%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%A6%82%E4%B8%8B%EF%BC%9A"><strong>比较完备的快速排序实现如下：</strong></h3> 
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) {
        srand(time(NULL));
        qsort(nums,0,nums.size()-1);
        return nums;
    }
    void qsort(vector&lt;int&gt;&amp; nums,int l,int r){
        //递归出口
        if(l &gt;= r) return;
        //数组分三块
        int key = GetRandom(nums,l,r);
        int cur = l,left = l-1,right = r+1;
        while(cur &lt; right){
            if(nums[cur] &lt; key) swap(nums[++left],nums[cur++]);
            else if(nums[cur] == key) cur++;
            else swap(nums[--right],nums[cur]); 
        }
        //递归排序子区间
        qsort(nums,l,left);
        qsort(nums,right,r);
    }
    int GetRandom(vector&lt;int&gt;&amp; nums,int left,int right){
        return nums[ rand() % ( right - left + 1 ) + left];
    }
};</code></pre> 
<hr> 
<p style="text-align:center;"><strong> 完~</strong></p> 
<p style="text-align:center;"><strong>未经作者同意禁止转载</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5ba699d79490d3b5416ac7977d4f94c6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux多进程和多线程(七)进程间通信-信号量</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2cc2dbc6a63e460391ab8fb1100b8311/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;笔试强训2</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>