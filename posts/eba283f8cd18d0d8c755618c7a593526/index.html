<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C:初识指针—学习笔记 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/eba283f8cd18d0d8c755618c7a593526/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C:初识指针—学习笔记">
  <meta property="og:description" content="目录
前言：
1、内存和地址
1.1 理解内存和地址
1.2 理解编址
2、指针变量和地址
2.1 取地址操作符：&amp;
2.2 指针变量
2.3 如何拆解指针类型
2.4 解引用操作符（*）
2.5 指针变量的大小
3、指针变量类型的意义
3.1 指针的解引用
3.2 指针&#43;-整数
4、void* 指针
结语：
前言： 谈及指针，大部分人只有一个感觉：太难学了，好抽象啊！但是，请不要着急，今天当你看完这一篇后，相信你肯定能够理解什么是指针了。
1、内存和地址 1.1 理解内存和地址 在介绍指针前，我们需要先了解什么是内存和地址。
关于内存和地址，生活中有一个例子可以很好的解释它们
比如说你住在一栋宿舍楼，大楼内有100个房间，但是房间并没有编号。这时，你的一个朋友来找你玩，如果想找到你，就得一个房间一个房间的寻找，这样效率很低。但是，如果我根据楼层和楼层的房间的情况，给每一个房间都编上号，比如：
1楼：101 102 103……
当有了门牌号，这时候你只需要将门牌号告诉你朋友，他就可以很快速的找到房间，找到房间里的你。
如何将上面的例子抽象到计算机里呢？你可以理解宿舍楼就是内存，房间就是内存中的一个内存单元，房间里的你就是数据，而门牌号就是地址。
所以内存就是存储数据的空间
我们知道计算机上CPU（中央处理器）在处理数据的时候，需要的数据是在内存中读取的，处理后的数据也会放回内存中，那我们买电脑的时候，电脑上内存是8GB/16GB/32GB等，那这些内存空间如何高效的管理呢？
cpu从内存中读取数据，就好比是你朋友要在宿舍楼里找到你，而你朋友找你，也只是在一个个房间寻找。大楼里的一个一个房间的划分，让人们对大楼内的面积能够充分利用，而计算机中也是如此。内存的空间只有8GB/16GB/32GB，因此对于内存的合理运用也变的很重要。
计算机中把内存也划分为一个个的内存单元，每个内存单元的大小取1字节。
（补充）计算机中常见的单位：
一个bit可以存储一个2进制位的1和0
地址（门牌号）内存（大楼）其中，每个内存单元，相当于⼀个学⽣宿舍，一
个字节空间里面能放8个比特位，就好比同学们住
的八⼈间，每个人是⼀个比特位。0xFFFFFFFF（16进制）1个字节0xFFFFFFFE1个字节1个字节 每个内存单元也都有⼀个编号（这个编号就相当
于宿舍房间的门牌号），有了这个内存单元的编
号，CPU就可以快速找到⼀个内存空间。
（内存单元） 生活中我们把门牌号也叫地址，在计算机中我们
把内存单元的编号也称为地址，
C语言中给地址起了新的名字叫：指针
1个字节0x000000011个字节0x000000001个字节 所以我们可以理解为：
内存单元的编号 == 地址 == 指针
1.2 理解编址 生活中关于我们可以看到通过宿舍门上的门牌号，直接找到我们想去的地方。门牌号是真实存在与宿舍门上的。而内存中的地址我们该怎么理解呢？
计算机中的编址，并不是把每个字节的地址记录下来，而是通过硬件设计完成的。
这就像钢琴，吉他上面没有刻上“剁、来、咪、发、 唆、拉、西”这样的信息，但演奏者照样能够准 确找到每⼀个琴弦的每⼀个位置，这是为何？因为制造商已经在乐器硬件层面上设计好了，并且 所有的演奏者都知道。本质是⼀种约定出来的共识！">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-06T16:28:53+08:00">
    <meta property="article:modified_time" content="2024-08-06T16:28:53+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C:初识指针—学习笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="1080" src="https://images2.imgbox.com/3a/dd/2jZgw6IM_o.jpg" width="1200"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80%EF%BC%9A" rel="nofollow">前言：</a></p> 
<p id="1%E3%80%81%E5%86%85%E5%AD%98%E5%92%8C%E5%9C%B0%E5%9D%80-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E5%86%85%E5%AD%98%E5%92%8C%E5%9C%B0%E5%9D%80" rel="nofollow">1、内存和地址</a></p> 
<p id="1.1%20%E7%90%86%E8%A7%A3%E5%86%85%E5%AD%98%E5%92%8C%E5%9C%B0%E5%9D%80-toc" style="margin-left:40px;"><a href="#1.1%20%E7%90%86%E8%A7%A3%E5%86%85%E5%AD%98%E5%92%8C%E5%9C%B0%E5%9D%80" rel="nofollow">1.1 理解内存和地址</a></p> 
<p id="1.2%20%E7%90%86%E8%A7%A3%E7%BC%96%E5%9D%80-toc" style="margin-left:40px;"><a href="#1.2%20%E7%90%86%E8%A7%A3%E7%BC%96%E5%9D%80" rel="nofollow">1.2 理解编址</a></p> 
<p id="2%E3%80%81%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E5%92%8C%E5%9C%B0%E5%9D%80-toc" style="margin-left:0px;"><a href="#2%E3%80%81%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E5%92%8C%E5%9C%B0%E5%9D%80" rel="nofollow">2、指针变量和地址</a></p> 
<p id="2.1%20%E5%8F%96%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%9A%26-toc" style="margin-left:40px;"><a href="#2.1%20%E5%8F%96%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%9A%26" rel="nofollow">2.1 取地址操作符：&amp;</a></p> 
<p id="2.2%20%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F-toc" style="margin-left:40px;"><a href="#2.2%20%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F" rel="nofollow">2.2 指针变量</a></p> 
<p id="2.3%20%E5%A6%82%E4%BD%95%E6%8B%86%E8%A7%A3%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#2.3%20%E5%A6%82%E4%BD%95%E6%8B%86%E8%A7%A3%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B" rel="nofollow">2.3 如何拆解指针类型</a></p> 
<p id="2.4%20%E8%A7%A3%E5%BC%95%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88*%EF%BC%89-toc" style="margin-left:40px;"><a href="#2.4%20%E8%A7%A3%E5%BC%95%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88*%EF%BC%89" rel="nofollow">2.4 解引用操作符（*）</a></p> 
<p id="2.5%20%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%9A%84%E5%A4%A7%E5%B0%8F-toc" style="margin-left:40px;"><a href="#2.5%20%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%9A%84%E5%A4%A7%E5%B0%8F" rel="nofollow">2.5 指针变量的大小</a></p> 
<p id="3%E3%80%81%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%84%8F%E4%B9%89-toc" style="margin-left:0px;"><a href="#3%E3%80%81%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%84%8F%E4%B9%89" rel="nofollow">3、指针变量类型的意义</a></p> 
<p id="3.1%20%E6%8C%87%E9%92%88%E7%9A%84%E8%A7%A3%E5%BC%95%E7%94%A8-toc" style="margin-left:40px;"><a href="#3.1%20%E6%8C%87%E9%92%88%E7%9A%84%E8%A7%A3%E5%BC%95%E7%94%A8" rel="nofollow">3.1 指针的解引用</a></p> 
<p id="3.2%20%E6%8C%87%E9%92%88%2B-%E6%95%B4%E6%95%B0-toc" style="margin-left:40px;"><a href="#3.2%20%E6%8C%87%E9%92%88%2B-%E6%95%B4%E6%95%B0" rel="nofollow">3.2 指针+-整数</a></p> 
<p id="4%E3%80%81void*%20%E6%8C%87%E9%92%88-toc" style="margin-left:0px;"><a href="#4%E3%80%81void*%20%E6%8C%87%E9%92%88" rel="nofollow">4、void* 指针</a></p> 
<p id="%E7%BB%93%E8%AF%AD%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E7%BB%93%E8%AF%AD%EF%BC%9A" rel="nofollow">结语：</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%89%8D%E8%A8%80%EF%BC%9A">前言：</h2> 
<p>谈及指针，大部分人只有一个感觉：太难学了，好抽象啊！但是，请不要着急，今天当你看完这一篇后，相信你肯定能够理解什么是指针了。</p> 
<hr> 
<h2 id="1%E3%80%81%E5%86%85%E5%AD%98%E5%92%8C%E5%9C%B0%E5%9D%80">1、内存和地址</h2> 
<h3 id="1.1%20%E7%90%86%E8%A7%A3%E5%86%85%E5%AD%98%E5%92%8C%E5%9C%B0%E5%9D%80">1.1 理解内存和地址</h3> 
<p>在介绍指针前，我们需要先了解什么是内存和地址。</p> 
<p>关于内存和地址，生活中有一个例子可以很好的解释它们</p> 
<p>比如说你住在一栋宿舍楼，大楼内有100个房间，但是房间并没有编号。这时，你的一个朋友来找你玩，如果想找到你，就得一个房间一个房间的寻找，这样效率很低。但是，如果我根据楼层和楼层的房间的情况，给每一个房间都编上号，比如：</p> 
<blockquote> 
 <p>1楼：101 102 103……</p> 
</blockquote> 
<p>当有了门牌号，这时候你只需要将门牌号告诉你朋友，他就可以很快速的找到房间，找到房间里的你。</p> 
<p>如何将上面的例子抽象到计算机里呢？你可以理解宿舍楼就是内存，房间就是内存中的一个内存单元，房间里的你就是数据，而门牌号就是地址。</p> 
<p>所以<strong>内存就是存储数据的空间</strong></p> 
<p>我们知道计算机上CPU（中央处理器）在处理数据的时候，需要的<strong>数据是在内存中读取</strong>的，处理后的<strong>数据也会放回内存</strong>中，那我们买电脑的时候，电脑上内存是8GB/16GB/32GB等，那这些内存空间如何高效的管理呢？</p> 
<p>cpu从内存中读取数据，就好比是你朋友要在宿舍楼里找到你，而你朋友找你，也只是在一个个房间寻找。大楼里的一个一个房间的划分，让人们对大楼内的面积能够充分利用，而计算机中也是如此。内存的空间只有8GB/16GB/32GB，因此对于内存的合理运用也变的很重要。</p> 
<p>计算机中把内存也划分为一个个的内存单元，每个内存单元的大小取1字节。</p> 
<p>（<strong>补充</strong>）计算机中常见的单位：</p> 
<p><strong>一个bit可以存储一个2进制位的1和0</strong></p> 
<table><tbody><tr><td style="width:86px;"><strong>地址（门牌号）</strong></td><td style="width:99px;"><strong>内存（大楼）</strong></td><td colspan="4" rowspan="3" style="width:489px;">其中，每个内存单元，相当于⼀个学⽣宿舍，一<br> 个字节空间里面能放8个比特位，就好比同学们住<br> 的八⼈间，每个人是⼀个比特位。</td></tr><tr><td style="width:86px;">0xFFFFFFFF（<span style="color:#fe2c24;">16进制</span>）</td><td style="width:99px;">1个字节</td></tr><tr><td style="width:86px;">0xFFFFFFFE</td><td style="width:99px;">1个字节</td></tr><tr><td style="width:86px;"></td><td style="width:99px;">1个字节</td><td colspan="4" rowspan="4" style="width:489px;"> <p>每个内存单元也都有⼀个编号（这个编号就相当<br> 于宿舍房间的门牌号），有了这个内存单元的编<br> 号，CPU就可以快速找到⼀个内存空间。</p> </td></tr><tr><td style="width:86px;"></td><td style="width:99px;">（<strong><span style="color:#1c7331;">内存单元</span></strong>）</td></tr><tr><td style="width:86px;"></td><td style="width:99px;"></td></tr><tr><td style="width:86px;"></td><td style="width:99px;"></td></tr><tr><td style="width:86px;"></td><td style="width:99px;"></td><td colspan="4" rowspan="4" style="width:489px;"> <p>生活中我们把门牌号也叫地址，在计算机中我们</p> <p>把内存单元的编号也称为地址，<br><strong>C语言中给地址起了新的名字叫：<span style="color:#fe2c24;">指针</span></strong></p> <p></p> </td></tr><tr><td style="width:86px;"></td><td style="width:99px;">1个字节</td></tr><tr><td style="width:86px;">0x00000001</td><td style="width:99px;">1个字节</td></tr><tr><td style="width:86px;">0x00000000</td><td style="width:99px;">1个字节</td></tr></tbody></table> 
<p>所以我们可以理解为：<br><strong>内存单元的编号 == 地址 == 指针</strong></p> 
<h3 id="1.2%20%E7%90%86%E8%A7%A3%E7%BC%96%E5%9D%80">1.2 理解编址</h3> 
<p>生活中关于我们可以看到通过宿舍门上的门牌号，直接找到我们想去的地方。门牌号是真实存在与宿舍门上的。而内存中的地址我们该怎么理解呢？</p> 
<p><strong>计算机中的编址，并不是把每个字节的地址记录下来，而是通过硬件设计完成的。</strong></p> 
<p>这就像钢琴，吉他上面没有刻上“剁、来、咪、发、 唆、拉、西”这样的信息，但演奏者照样能够准 确找到每⼀个琴弦的每⼀个位置，这是为何？因为制造商已经在乐器硬件层面上设计好了，并且 所有的演奏者都知道。本质是⼀种约定出来的共识！</p> 
<p><strong>有点抽象，举个例子：</strong></p> 
<p>图书馆里有一排排的书架，每个书架又有一层层的格子，这些格子就好比内存中的存储单元。</p> 
<p>给每个格子编上号，也就是编址，就像是要给图书馆里的每个格子都贴上标签。</p> 
<p>那这个标签是怎么贴上去的呢？这就得靠图书馆的“硬件设计”了。</p> 
<p>比如说，书架的排列方式、格子的划分规则，就像是硬件的设计。</p> 
<p>想象一下，书架是固定的，它们的位置和大小决定了格子的位置和数量，这就好比硬件决定了内存有多少个可以存储数据的地方。</p> 
<p>然后，有一套专门的标记系统，就像特殊的机器或者装置，按照书架和格子的排列，给每个格子都印上编号，这就是通过硬件实现了编址。</p> 
<p><img alt="" height="248" src="https://images2.imgbox.com/b2/5c/JpZ8cQyq_o.png" width="319"></p> 
<p>那硬件设计又是怎么实现的呢？</p> 
<p>首先，必须理解，计算机内是有很多的硬件单元，而硬件单元是要互相协同工作的。所谓的协 同，至少相互之间要能够进⾏数据传递。 但是硬件与硬件之间是互相独立的，那么如何通信呢？答案很简单，用"线"连起来。 ⽽CPU和内存之间也是有大量的数据交互的，所以，两者必须也用线连起来。通过地址总线，我们就可以了解什么是硬件编址了。</p> 
<p><strong>32位机器有32根地址总线</strong>， 每根线只有两态，表示0,1【电脉冲有无】，那么⼀根线，就能表示2种含义，2根线就表示4种含义，依次类推。32根地址线，就能表示2^32种含义，每⼀种含义都代表⼀个地址。 地址信息被下达给内存，在内存上，就可以找到 该地址对应的数据，将数据在通过数据总线传入CPU内寄存器。</p> 
<p>内存编址这件事，是靠计算机里面那些实实在在的硬件设备，按照一定的规则和办法来做好的。</p> 
<p>简单来说，计算机的编址是通过硬件设计把每一个内存单元的地址都固定好了，不需要把地址额外的存起来。</p> 
<p>知识补充：</p> 
<ol><li><strong>32位机器有32根地址总线</strong>，<strong>64位机器有64根地址总线。</strong></li><li><strong> 地址总线是实际存在的物理电线</strong></li></ol> 
<h2 id="2%E3%80%81%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E5%92%8C%E5%9C%B0%E5%9D%80">2、指针变量和地址</h2> 
<p>当我们了解了内存和地址的关系后，就可以开始对指针的学习啦！</p> 
<p>在C语言中变量创建的本质是<strong>向内存申请空间</strong></p> 
<p>比如说：int a = 10;</p> 
<p>这串代码就相当于向内存内申请了4个字节，一个整型占4个字节，这串空间我们想存放的数据便是变量10。</p> 
<h3 id="2.1%20%E5%8F%96%E5%9C%B0%E5%9D%80%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%9A%26">2.1 取地址操作符：&amp;</h3> 
<pre><code class="language-cpp">int main()
{
	int a = 0x11223344;//16进制数字
	return 0;
}</code></pre> 
<p>16进制0x11223344，一个16进制位可以改写为4个二进制位，因此，11223344可以改写为32个二进制位表示，刚好一个整型可以放下。</p> 
<p>我们可以调试来看一下内存：</p> 
<p><img alt="" height="803" src="https://images2.imgbox.com/e5/62/lkrRk958_o.png" width="1017"></p> 
<p>打开后，输入<strong>&amp;a</strong> 并敲下回车键，列改为一行（记得在x86环境下观察，比较方便）</p> 
<p><img alt="" height="137" src="https://images2.imgbox.com/ef/65/vZXX1RNs_o.png" width="963"></p> 
<p><img alt="" height="167" src="https://images2.imgbox.com/74/e2/gREfK856_o.png" width="982"></p> 
<p>我们可以看到44，33，22，11都各占一个字节，每一个字节都有一个地址。</p> 
<p>我们将列数改为4列再观察</p> 
<p><img alt="" height="102" src="https://images2.imgbox.com/39/13/loRoqJwl_o.png" width="969"></p> 
<p>从上面我们可以看到a确实向内存申请了4个空间。</p> 
<p>读到这我们可能会有一个新的问题，欸，4个字节都有地址，那我们怎么知道a的地址是哪一个呢？</p> 
<p>还记得前面调试的时候我们是怎么观察地址的吗？我们通过输入&amp;a按下回车后出现了0x00E2FEC4，因此0x00E2FEC4便是a的地址，我们也可以发现这个地址和 44 所占字节的地址一样。</p> 
<p>总结一下，<strong>&amp;a取出的是a所占4个字节中地址较小的字节的地址</strong></p> 
<p>虽然整型变量占用4个字节，但是我们只要知道了第一个字节地址，顺藤摸瓜访问到4个字节的数据也是可行的。</p> 
<p>代码展示一下，怎么打印地址</p> 
<pre><code class="language-cpp">int main()
{
	int a = 0x11223344;
	printf("&amp;a=%p\n", &amp;a);
	return 0;	
}</code></pre> 
<p><strong>知识补充：</strong></p> 
<ul><li>&amp;是取地址操作符，想要得到地址，就需要使用这个操作符</li><li> %p：用来打印地址的占位符</li></ul> 
<p>结果展示：</p> 
<p><img alt="" height="143" src="https://images2.imgbox.com/a9/33/jP1kiaJt_o.png" width="1163"></p> 
<p>和前面调试的结果不是一样，是因为在打印的时候又申请了新的空间。</p> 
<h3 id="2.2%20%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F">2.2 指针变量</h3> 
<p>在我们之前学习的过程中，我们如果想要将一个整数存储起来，就会创建一个整型变量，比如我们想存储数字10，如下代码：</p> 
<pre><code class="language-cpp">int main()
{
	int a = 10;
	return 0;	
}</code></pre> 
<p>我们通过创建了一个整型变量 a 来存储10。</p> 
<p>那么如果我们想要将我们通过&amp;得到的地址存储起来，有没有什么办法呢？我们可以将地址存储在<strong>指针变量</strong>中。比如我们想要存放 n 的地址</p> 
<pre><code class="language-cpp">int main()
{
	int a = 10;
	int * pn = &amp;n;
	return 0;	
}</code></pre> 
<p>解读：int * pn = &amp;n;</p> 
<p><strong>1、pn被称为指针变量</strong></p> 
<p>为什么呢？</p> 
<p>&amp;n——n的地址——地址就是指针</p> 
<p>pn = &amp;n；</p> 
<p>pn就是用来存放地址的，也可以说是用来存放指针的</p> 
<p><strong>指针变量就是存放指针的变量。</strong></p> 
<p>可以通过和整型变量来理解指针变量，</p> 
<p>整型变量：a就是用来存放整数的。</p> 
<p><strong>2、int * 被称为指针类型</strong></p> 
<p>int a = 10;<br> int * pn = &amp;n;</p> 
<p>对比就可以发现，int是整数的类型，int*是指针的类型。</p> 
<h3 id="2.3%20%E5%A6%82%E4%BD%95%E6%8B%86%E8%A7%A3%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B">2.3 如何拆解指针类型</h3> 
<p>上文说到了之指针的类型是（int *），那么我们该如何理解指针类型呢？</p> 
<p>pn的类型是int *，我们需要分别理解</p> 
<ul><li>*：说明pn是指针变量</li><li>int：说明pn指向的对象是int类型</li></ul> 
<pre><code class="language-cpp">char ch = 'x';
</code></pre> 
<p>如果我们想要存放x的地址该怎么写呢？</p> 
<blockquote> 
 <p> char * pc = &amp;ch;</p> 
</blockquote> 
<p>这样我们就存放了x的地址</p> 
<p><strong>* </strong>告诉我们pc是指针</p> 
<p>char则告诉我们指针指向的对象是char类型。</p> 
<h3 id="2.4%20%E8%A7%A3%E5%BC%95%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88*%EF%BC%89">2.4 解引用操作符（*）</h3> 
<p>当我们将地址保存起来后，是为了后面能够使用，那么我们该怎么使用呢？</p> 
<p>在现实生活中，我们使用地址要找到⼀个房间，在房间里可以拿去或者存放物品。</p> 
<p>C语言中其实也是⼀样的，我们只要拿到了地址（指针），就可以通过地址（指针）找到地址（指针） 指向的对象，这里必须学习⼀个操作符叫解引用操作符(*)。</p> 
<pre><code class="language-cpp">int main()
{
	int n = 10;
	int * pn = &amp;n;
    //解引用操作符（间接访问操作符）
	*pn = 100;
	printf("%d", n);
	return 0;	
}</code></pre> 
<p>上述代码中的*pn就使用了解引用操作符， *pn 的意思就是通过pn中存放的地址，找到指向的空间， *pn其实就是n变量了；所以*pn=100，这个操作符是把n改成了100.</p> 
<p><img alt="" height="131" src="https://images2.imgbox.com/30/d2/Ixs3ewQd_o.png" width="1105"></p> 
<p>从结果上看，n的值的确被改为了100</p> 
<p>或许通过这个例子你会觉得指针有是什么用？如果只是想修改n的值，为什么不直接写一个n=100呢？这样不是更方便吗？</p> 
<p>其实这里是把n的修改交给了pn来操作，这样对n的修改，就多了⼀种的途径，写代码就会更加灵活， 后期慢慢就能理解了。</p> 
<p>其实这里有一个很好的例子能说明指针的作用，生活中，有些事情是不方便自己去做的，因此呢，就需要委托别人来代替你做，比如说一个老板想要喝奶茶，但是他不会自己顶着大太阳出去买，而是会吩咐他的秘书取帮他完成，差不多就是这样，可能有些不恰当，见谅哈！</p> 
<h3 id="2.5%20%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%9A%84%E5%A4%A7%E5%B0%8F">2.5 指针变量的大小</h3> 
<p>我们知道我们创建一个整型变量int的大小是4个字节，字符变量char的大小是1个字节，那么指针变量的大小又是多少呢？</p> 
<p>思考过程：</p> 
<p>指针变量存放的是地址，地址的存放需要多大的空间呢？知道地址存放的空间就是指针变量的大小</p> 
<p>也就是说<strong>指针变量的大小取决与地址的大小</strong></p> 
<p>通过前面的内容我们了解到，32位机器假设有32根地址总线，每根地址线出来的电信号转换成数字信号后 是1或者0，那我们把32根地址线产生的2进制序列当做⼀个地址，那么⼀个地址就是32个bit位，需要4个字节才能存储。</p> 
<p>如果指针变量是用来存放地址的，那么指针变的大小就得是4个字节的空间才可以。</p> 
<p>同理64位机器，假设有64根地址线，⼀个地址就是64个二进制位组成的⼆进制序列，存储起来就需要 8个字节的空间，指针变量的大小就是8个字节。</p> 
<pre><code class="language-cpp">int main()
{
	int n = 10;
	int * pn = &amp;n;
	printf("%zd\n", sizeof(pn));
	return 0;	
}</code></pre> 
<p><strong>在32位机器上： 可以看到打印的大小是4个字节</strong></p> 
<p><img alt="" height="242" src="https://images2.imgbox.com/e7/80/2iWwBnPG_o.png" width="1200"></p> 
<p><strong>在64位机器上： 可以看到打印的大小是8个字节</strong></p> 
<p><img alt="" height="227" src="https://images2.imgbox.com/e5/fe/z6AxWvUh_o.png" width="1200"></p> 
<p>那么指针类型是否会影响指针变量的大小呢？我们来测试一下</p> 
<pre><code class="language-cpp">int main()
{	
	printf("%zd\n", sizeof(int*));//整型
	printf("%zd\n", sizeof(char*));//字符
	printf("%zd\n", sizeof(short*));//短整型
	printf("%zd\n", sizeof(double*));//双精度浮点型
	return 0;	
}</code></pre> 
<p>在32位系统上结果：</p> 
<p><img alt="" height="289" src="https://images2.imgbox.com/f1/bf/tHd1yj61_o.png" width="1200"></p> 
<p>在64位系统上结果</p> 
<p><img alt="" height="338" src="https://images2.imgbox.com/ef/fc/qIjrACZp_o.png" width="1200"></p> 
<p>我们可以看到，不管指针类型是什么，都不会影响指针变量的大小，指针类型的变量大小，在相同平台下，大小都是相同的。</p> 
<p>总结：</p> 
<ul><li> 32位平台下地址是32个bit位，指针变量大小是4个字节</li><li> 64位平台下地址是64个bit位，指针变量大小是8个字节 X64环境输出结果</li><li> 注意指针变量的大小和类型是无关的，只要指针类型的变量，在相同的平台下，大小都是相同的。</li></ul> 
<h2 id="3%E3%80%81%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%84%8F%E4%B9%89">3、指针变量类型的意义</h2> 
<p>既然指针变量大小与指针类型无关，那么为什么还要搞指针的变量类型呢？</p> 
<h3 id="3.1%20%E6%8C%87%E9%92%88%E7%9A%84%E8%A7%A3%E5%BC%95%E7%94%A8">3.1 指针的解引用</h3> 
<pre><code class="language-cpp">int main()
{
	int n = 0x11223344;
	int* pi = &amp;n;
	*pi = 0;
	return 0;
}
</code></pre> 
<p>调试过程：（<span style="color:#fe2c24;">注意观察内存里的值</span>）</p> 
<p><img alt="" height="190" src="https://images2.imgbox.com/ee/d1/KRS5A3UY_o.png" width="1200"></p> 
<p>运行到292行时内存展示44 33 22 11</p> 
<p><img alt="" height="320" src="https://images2.imgbox.com/63/72/0Zd2yvvR_o.png" width="1200"></p> 
<p>当经过*pi = 0 之后</p> 
<p>内存里4个字节全部变为了 0 </p> 
<p>如果我们不用int *的指针类型，改为char *的类型，结果又是如何呢？</p> 
<p><img alt="" height="277" src="https://images2.imgbox.com/61/a2/PhdzGoBJ_o.png" width="1200"></p> 
<p>我们可以看到只是将n的第⼀个字节改为0。</p> 
<p>我们可以看到int类型指针可以访问4个字节，而char类型指针只访问了1个字节。</p> 
<p>通过对比，我们可以得到一个<span style="color:#0d0016;">结论</span>：</p> 
<p><strong><span style="color:#fe2c24;">结论</span>：指针的类型决定了，对指针解引用的时候有多大的权限（一次能操作几个字节）。</strong></p> 
<h3 id="3.2%20%E6%8C%87%E9%92%88%2B-%E6%95%B4%E6%95%B0">3.2 指针+-整数</h3> 
<pre><code class="language-cpp">int main()
{
	int n = 0x11223344;
	int* pi = &amp;n;
	char* pc = &amp;n;		
	printf("&amp;n = %p\n", &amp;n);
	printf("pi = %p\n", pi);
	printf("pi+1 = %p\n", pi+1);
	printf("pc = %p\n", pc);
	printf("pc+1= %p\n", pc+1);
	return 0;
}</code></pre> 
<p><strong>结果：</strong> </p> 
<p><img alt="" height="162" src="https://images2.imgbox.com/8a/0a/Oe6r4a7m_o.png" width="952"></p> 
<p>我们可以发现， char* 类型的指针变量+1跳过1个字节， int* 类型的指针变量+1跳过了4个字节。 这就是指针变量的类型差异带来的变化。指针+1，其实跳过1个指针指向的元素。指针可以+1，那也可以-1。</p> 
<p><span style="color:#fe2c24;"><strong>结论：</strong></span><strong>指针的类型决定了指针向前或者向后走一步有多大（距离）。</strong></p> 
<h2 id="4%E3%80%81void*%20%E6%8C%87%E9%92%88">4、void* 指针</h2> 
<p>void的意思是无，或者空</p> 
<p>所以void*指针是无具体为<strong>无具体类型的指针</strong>（或者叫泛型指针），这种类型的指针可以用来接受任意类型地址。但是也有局限性， void* 类型的指针不能直接进行指针的+-整数和解引用的运算。 </p> 
<pre><code class="language-cpp">int main()
{
	int n = 10;
	char* pc = &amp;n;
	return 0;
}</code></pre> 
<p>在上面的代码中，将⼀个int类型的变量的地址赋值给⼀个char*类型的指针变量。编译器给出了⼀个警告（如下图），是因为类型不兼容。而是用void*类型就不会有这样的问题。</p> 
<p><img alt="" height="482" src="https://images2.imgbox.com/00/ce/antZGSRp_o.png" width="1180"><br> 使用void*类型的指针接收地址就不会出现警告</p> 
<p><img alt="" height="402" src="https://images2.imgbox.com/52/2f/wGNdkoeW_o.png" width="1098"></p> 
<p>void* 类型的指针不能直接进行指针的+-整数和解引用的运算</p> 
<pre><code class="language-cpp">int main()
{
	int n = 10;
	void* pc = &amp;n;
	*pc = 20;
	return 0;
}</code></pre> 
<p>当我们想运行的时候，就会报下面这个错误 </p> 
<p><img alt="" height="337" src="https://images2.imgbox.com/77/b5/9u80vetR_o.png" width="1200"></p> 
<p> void* 类型的指针可以接收不同类型的地址，但是无法直接进行指针运算。</p> 
<p>这是因为void*是一个无具体类型的指针，当进行解运算的时候，没法确定访问几个字节。</p> 
<p>既然如此，那void*有什么作用呢？</p> 
<p>专门用来存放别人传送过来的地址，当你不知道别人给你传的是什么类型的指针的时候，就可以使用void*来存放，当需要进行解运算的时候，在使用强制类型转换来实现。</p> 
<p>比如：</p> 
<pre><code class="language-cpp">int main()
{
	int n = 10;
	void* pc = &amp;n;
	*(int*)pc = 20;
	return 0;
}</code></pre> 
<p> 这样就将类型强制转换成了整型指针,结果就可以打印出来了</p> 
<p><img alt="" height="175" src="https://images2.imgbox.com/43/cf/wejAJuV2_o.png" width="983"></p> 
<hr> 
<h2 id="%E7%BB%93%E8%AF%AD%EF%BC%9A">结语：</h2> 
<p>本篇文章主要讲了指针的基本知识，通过本篇文章能够了解什么是指针，指针变量，指针类型是什么。后面会继续更新指针相关知识，希望能够帮助大家攻克指针这一模块。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0354d983ad9298208a09c09c3d664f2a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue&#43;elementui 表格分页限制最大页码数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2a635475a93a80c82d7121558f6d0d78/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">small bird</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>