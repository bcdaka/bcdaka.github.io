<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2024年最全前端面试八股文【很经典 很全面 字字珠玑】【建议收藏&#43;关注】，2024年最新web前端面试题 应届生 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/39fedc9f7526d98fad09907685062c6e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="2024年最全前端面试八股文【很经典 很全面 字字珠玑】【建议收藏&#43;关注】，2024年最新web前端面试题 应届生">
  <meta property="og:description" content="自学几个月前端，为什么感觉什么都没学到？？ 这种现象在很多的初学者和自学前端的同学中是比较的常见的。
因为自学走的弯路是比较的多的，会踩很多的坑，学习的过程中是比较的迷茫的。
最重要的是，在学习的过程中，不知道每个部分该学哪些知识点，学到什么程度才算好，学了能做什么。
很多自学的朋友往往都是自己去找资料学习的，资料上有的或许就学到了，资料上没有的或许就没有学到。
这就会给人一个错误的信息就是，我把资料上的学完了，估计也-就差不多的了。
但是真的是这样的吗？非也，因为很多人找的资料就是很基础的。学完了也就是掌握一点基础的东西。分享给你一份前端分析路线，你可以参考。
开源分享：【大厂前端面试题解析&#43;核心总结学习笔记&#43;真实项目实战&#43;最新讲解视频】
还有很多的同学在学习的过程中一味的追求学的速度，很快速的刷视频，写了后面忘了前面，最后什么都没有学到，什么都知道，但是什么都不懂，要具体说，也说不出个所以然。
所以学习编程一定要注重实践操作，练习敲代码的时间一定要多余看视频的时间。
20.动画有哪些实现方法? Js
setTimeout、setInterval、requestAnimationFrame
requestAnimationFrame方法是h5提供的一种专门解决动画更新的API，浏览器会自动以最合适的频率去刷新动画
jQuery中动画也比较实用css
animationcanvas元素结合JS插件
例如 jQuery 21.浅拷贝 浅拷贝对原对象或副本的更改可能也会导致其他对象的更改。它实际上只拷贝了一层，并且只当数组和对象包的值是原始值时才会进行拷贝。
赋值运算符 = let a=[1,2,3] let b=a; console.log(b==a)//true 扩展运算符 … let a=[1,2,3] let b=[...a]//把数组a的内容 挨个取出 放到b数组中 console.log(b===a) //true slice方法 let a=[1,2,3] let b=a.slice() console.log(a===b) //false a[0]=4; console.log(a)//4 2 3 console.log(b) //1 2 3 assign方法 let a=[1,2,3] let b=[] Object.assign(b,a); a[0]=4 console.log(a)//4 2 3 console.log(b) //1 2 3 Array.from let a=[1,2,3] let b=Array.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-14T17:03:47+08:00">
    <meta property="article:modified_time" content="2024-05-14T17:03:47+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2024年最全前端面试八股文【很经典 很全面 字字珠玑】【建议收藏&#43;关注】，2024年最新web前端面试题 应届生</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="_2"></a>自学几个月前端，为什么感觉什么都没学到？？</h4> 
<hr> 
<p>这种现象在很多的初学者和自学前端的同学中是比较的常见的。</p> 
<p>因为自学走的弯路是比较的多的，会踩很多的坑，学习的过程中是比较的迷茫的。</p> 
<p>最重要的是，在学习的过程中，不知道每个部分该学哪些知识点，学到什么程度才算好，学了能做什么。</p> 
<p>很多自学的朋友往往都是自己去找资料学习的，资料上有的或许就学到了，资料上没有的或许就没有学到。</p> 
<p>这就会给人一个错误的信息就是，我把资料上的学完了，估计也-就差不多的了。</p> 
<p>但是真的是这样的吗？非也，因为很多人找的资料就是很基础的。学完了也就是掌握一点基础的东西。分享给你一份前端分析路线，你可以参考。</p> 
<p><strong><a href="https://bbs.csdn.net/forums/4304bb5a486d4c3ab8389e65ecb71ac0">开源分享：【大厂前端面试题解析+核心总结学习笔记+真实项目实战+最新讲解视频】</a></strong></p> 
<p><img src="https://images2.imgbox.com/33/ff/fMC1xqPs_o.png" alt=""></p> 
<p>还有很多的同学在学习的过程中一味的追求学的速度，很快速的刷视频，写了后面忘了前面，最后什么都没有学到，什么都知道，但是什么都不懂，要具体说，也说不出个所以然。</p> 
<p>所以学习编程一定要注重实践操作，练习敲代码的时间一定要多余看视频的时间。</p> 
<hr> 
<h4><a id="20_39"></a>20.动画有哪些实现方法?</h4> 
<ol><li>Js<br> setTimeout、setInterval、<strong>requestAnimationFrame</strong><br> requestAnimationFrame方法是h5提供的一种专门解决动画更新的API，浏览器会自动以最合适的频率去刷新动画<br> jQuery中动画也比较实用</li><li>css<br> animation</li><li>canvas元素结合JS</li><li>插件<br> 例如 jQuery</li></ol> 
<hr> 
<h4><a id="21_58"></a>21.浅拷贝</h4> 
<p>浅拷贝对原对象或副本的更改可能也会导致其他对象的更改。它<strong>实际上只拷贝了一层，并且只当数组和对象包的值是原始值时才会进行拷贝</strong>。</p> 
<ol><li>赋值运算符 =</li></ol> 
<pre><code>	let a=[1,2,3]
	let b=a;
	console.log(b==a)//true

</code></pre> 
<ol start="2"><li>扩展运算符 …</li></ol> 
<pre><code>	let a=[1,2,3]
	let b=[...a]//把数组a的内容 挨个取出 放到b数组中
	console.log(b===a) //true

</code></pre> 
<ol start="3"><li>slice方法</li></ol> 
<pre><code>	let a=[1,2,3]
	let b=a.slice()
	console.log(a===b) //false 
	a[0]=4;
	console.log(a)//4 2 3
	console.log(b) //1 2 3

</code></pre> 
<ol start="4"><li>assign方法</li></ol> 
<pre><code>let a=[1,2,3]
let b=[]
Object.assign(b,a);
a[0]=4
console.log(a)//4 2 3
console.log(b) //1 2 3

</code></pre> 
<ol start="5"><li>Array.from</li></ol> 
<pre><code>let a=[1,2,3]
let b=Array.from(a)
a[0]=4
console.log(a)//4 2 3
console.log(b) //1 2 3

</code></pre> 
<hr> 
<h4><a id="22_132"></a>22.深拷贝</h4> 
<p><strong>Javascript对象和数组如果深度嵌套，浅拷贝只能实现第一层的拷贝，但是深度的值依然和原对象共享引用。</strong></p> 
<pre><code>let a=[ [1],[2], [3]]
let b=[...a] //浅拷贝

a[0][0]= 4
console.log(a) // [[4],[2],[3]]
consle.log(b) // [[4],[2],[3]] 对象b也被改变了 这时浅拷贝的弊端体现出来了


</code></pre> 
<ol><li>使用JSON</li></ol> 
<pre><code>let a=[ [1],[2], [3]]
let b=JSON.parse(JSON.stringfy(a));
a[0][0]=4;
console.log(a) // [ [4],[2], [3]]
console.log(b) // [ [1],[2], [3]]

</code></pre> 
<ol start="2"><li>structuredClone</li></ol> 
<pre><code>let a=[ [1],[2], [3]]
let b=structuredClone(a);
a[0][0]=4;
console.log(a) // [ [4],[2], [3]]
console.log(b) // [ [1],[2], [3]]

</code></pre> 
<ol start="3"><li>第三方库 lodasg、rfdc</li><li>自定义函数实现</li></ol> 
<pre><code>const deepCopy=(obj)=&gt;{
	if(typeof obj !=='object' || obj == null){
		return obj;
	}
	const newObj= Array.isArray(obj) ? []:{};
	Object.keys(obj).forEach((key)=&gt;{
		newObj[key]=deepCopy(obj[key]);
	})
	return newObj;
}

</code></pre> 
<p>上述代码只能处理对象和数组的深度拷贝</p> 
<p><strong>注意理解深拷贝和浅拷贝的区别</strong></p> 
<hr> 
<h4><a id="23__206"></a>23. 说一下原型链</h4> 
<p>原型就是一个普通对象，它是为构造函数的实例共享属性和方法；所有实例中引用<br> 的原型都是同一个对象<br> 使用 prototype 可以把方法挂在原型上，内存值保存一份<br> __proto__可以理解为指针，实例对象中的属性，指向了构造函数的原型（prototype）</p> 
<hr> 
<h4><a id="24_new__220"></a>24. new 操作符具体做了什么？</h4> 
<ol><li>先创建一个空对象</li><li>把空对象和构造函数通过原型链进行链接</li><li>把构造函数的 this 绑定到新的空对象身上</li><li>根据构建函数返回的类型判断，如果是值类型，则返回对象，如果是引用类型，<br> 就要返回这个引用类型</li></ol> 
<hr> 
<h4><a id="25script__async__defer__235"></a>25.script 标签里的 async 和 defer 有什么区别？</h4> 
<p>当没有 async 和 defer 这两个属性的时候，浏览器会立刻加载并执行指定的脚本</p> 
<ol><li>有 async<br> 加载和渲染后面元素的过程将和 script 的加载和执行并行进行（异步）</li><li>有 defer<br> 加载和渲染后面元素的过程将和 script 的加载并行进行（异步），但是它的执行事件要等<br> 所有元素解析完成之后才会执行</li></ol> 
<hr> 
<h4><a id="26_setTimeout__253"></a>26. setTimeout 最小执行时间是多少？</h4> 
<p>HTML5 规定的内容：<br> setTimeout 最小执行时间是 <strong>4ms</strong><br> setInterval 最小执行时间是 <strong>10ms</strong></p> 
<hr> 
<h4><a id="27_promise__266"></a>27. promise 的内部原理是什么？它的优缺点是什么？</h4> 
<blockquote> 
 <p>Promise 对象，封装了一个异步操作并且还可以获取成功或失败的结果<br> Promise 主要就是解决回调地狱的问题，之前如果异步任务比较多，同时他们之间<br> 有相互依赖的关系，就只能使用回调函数处理，这样就容易形成回调地狱，代码的可读性差，可维护性也很差</p> 
</blockquote> 
<p>有三种状态：pending 初始状态 fulfilled 成功状态 rejected 失败状态</p> 
<p>状态改变只会有两种情况，<br> pending -&gt; fulfilled; pending -&gt; rejected 一旦发生，状态就会凝固，不会再变</p> 
<p>首先就是我们无法取消 promise，一旦创建它就会立即执行，不能中途取消<br> 如果不设置回调，promise 内部抛出的错误就无法反馈到外面<br> 若当前处于 pending 状态时，无法得知目前在哪个阶段。</p> 
<p>原理：</p> 
<blockquote> 
 <p>构造一个 Promise 实例，实例需要传递函数的参数，这个函数有两个形参，分<br> 别都是函数类型，一个是 resolve 一个是 reject<br> promise上还有then方法，这个方法就是来指定状态改变时的确定操作，resolve<br> 是执行第一个函数，reject 是执行第二个函数</p> 
</blockquote> 
<hr> 
<h4><a id="28promise__async_await__310"></a>28.promise 和 async await 的区别是什么？</h4> 
<ol><li>都是处理异步请求的方式</li><li>promise 是 ES6，async await 是 ES7 的语法</li><li>async await 是基于 promise 实现的，他和 promise 都是非阻塞性的<br> <strong>优缺点：</strong></li><li>promise 是返回对象我们要用 then，catch 方法去处理和捕获异常，并且书写方式<br> 是链式，容易造成代码重叠，不好维护，async await 是通过 tra catch 进行捕获异常</li><li>async await 最大的优点就是能让代码看起来像同步一样，只要遇到 await 就会立<br> 刻返回结果，然后再执行后面的操作<br> promise.then()的方式返回，会出现请求还没返回，就执行了后面的操作</li></ol> 
<hr> 
<h4><a id="29_329"></a>29.浏览器的存储方式有哪些？</h4> 
<ol><li>cookies<br> H5 标准前的本地存储方式<br> 兼容性好，请求头自带 cookie<br> 存储量小，资源浪费，使用麻烦（封装）</li><li>localstorage<br> H5 加入的以键值对为标准的方式<br> 操作方便，永久存储，兼容性较好<br> 保存值的类型被限定，浏览器在隐私模式下不可读取，不能被爬虫</li><li>sessionstorage<br> 当前页面关闭后就会立刻清理，会话级别的存储方式</li><li>indexedDB<br> H5 标准的存储方式，，他是以键值对进行存储，可以快速读取，适合 WEB 场<br> 景</li></ol> 
<h4><a id="30token__sessionstorage__loaclstorage_347"></a>30.token 存在 sessionstorage 还是 loaclstorage？</h4> 
<p>token：验证身份的令牌，一般就是用户通过账号密码登录后，服务端把这些凭证<br> 通过加密等一系列操作后得到的字符串</p> 
<ol><li>存 loaclstorage 里，后期每次请求接口都需要把它当作一个字段传给后台</li><li>存 cookie 中，会自动发送，缺点就是不能跨域</li><li>如果存在 localstorage 中，容易被 XSS 攻击，但是如果做好了对应的措施，那么是<br> 利大于弊</li><li>如果存在 cookie 中会有 CSRF 攻击</li></ol> 
<hr> 
<h4><a id="31_token__366"></a>31. token 的登录流程。</h4> 
<ol><li>客户端用账号密码请求登录</li><li>服务端收到请求后，需要去验证账号密码</li><li>验证成功之后，服务端会签发一个 token，把这个 token 发送给客户端</li><li>客户端收到 token 后保存起来，可以放在 cookie 也可以是 localstorage</li><li>客户端每次向服务端发送请求资源的时候，都需要携带这个 token</li><li>服务端收到请求，接着去验证客户端里的 token，验证成功才会返回客户端请求<br> 的数据</li></ol> 
<hr> 
<h4><a id="32_383"></a>32.页面渲染的过程是怎样的？</h4> 
<ol><li>DNS 解析</li><li>建立 TCP 连接</li><li>发送 HTTP 请求</li><li>服务器处理请求</li><li>渲染页面<br> 5.1 浏览器会获取 HTML 和 CSS 的资源，然后把 HTML 解析成 DOM 树<br> 5.2 再把 CSS 解析成 CSSOM<br> 5.3 把 DOM 和 CSSOM 合并为渲染树<br> 5.4 布局<br> 5.5 把渲染树的每个节点渲染到屏幕上（绘制）</li><li>断开 TCP 连接</li></ol> 
<hr> 
<h4><a id="33DOM__404"></a>33.DOM 树和渲染树有什么区别？</h4> 
<ol><li>DOM 树是和 HTML 标签一一对应的，包括 head 和隐藏元素</li><li>渲染树是不包含 head 和隐藏元素</li></ol> 
<hr> 
<h4><a id="34_base64__416"></a>34.精灵图和 base64 的区别是什么？</h4> 
<ol><li>精灵图：把多张小图整合到一张大图上，利用定位的一些属性把小图显示在页面上，<br> 当访问页面可以减少请求，提高加载速度</li><li>base64：传输 8Bit 字节代码的编码方式，把原本二进制形式转为 64 个字符的单位，<br> 最后组成字符串<br> base64 是会和 html css 一起下载到浏览器中，减少请求，减少跨域问题，但是一些<br> 低版本不支持，若 base64 体积比原图片大，不利于 css 的加载。</li></ol> 
<hr> 
<h4><a id="35svg__432"></a>35.svg 格式了解多少？</h4> 
<p>基于 XML 语法格式的图像格式，可缩放矢量图，其他图像是基于像素的，SVG 是<br> 属于对图像形状的描述，本质是文本文件，体积小，并且不管放大多少倍都不会失真</p> 
<ol><li>SVG 可直接插入页面中，成为 DOM 一部分，然后用 JS 或 CSS 进行操作<br> <code>&lt;svg&gt;&lt;/svg&gt;</code></li><li>SVG 可作为文件被引入<br> <code>&lt;img src="pic.svg" /&gt;</code></li><li>SVG 可以转为 base64 引入页面</li></ol> 
<hr> 
<h4><a id="36HTTP__451"></a>36.HTTP 协议规定的协议头和请求头有什么？</h4> 
<ol><li>请求头信息：<br> Accept:浏览器告诉服务器所支持的数据类型<br> Host:浏览器告诉服务器我想访问服务器的哪台主机<br> Referer:浏览器告诉服务器我是从哪里来的（防盗链）<br> User-Agent:浏览器类型、版本信息<br> Date:浏览器告诉服务器我是什么时候访问的<br> Connection:连接方式<br> Cookie<br> X-Request-With:请求方式</li><li>响应头信息：<br> Location:这个就是告诉浏览器你要去找谁<br> Server:告诉浏览器服务器的类型<br> Content-Type:告诉浏览器返回的数据类型<br> Refresh:控制了的定时刷新</li></ol> 
<hr> 
<h4><a id="37_475"></a>37.说一下什么是“同源策略”？</h4> 
<p>http:// www. aaa.com:8080/index/vue.js<br> 协议 子域名 主域名 端口号 资源<br> 同源策略是浏览器的核心，如果没有这个策略就会遭受网络攻击<br> 主要指的就是协议+域名+端口号三者一致，若其中一个不一样则不是同源，会产生<br> 跨域<br> 三个允许跨域加载资源的标签：img link script<br> 跨域是可以发送请求，后端也会正常返回结果，只不过这个结果被浏览器拦截了！</p> 
<ol><li>JSONP</li><li>CORS</li><li>websocket</li><li>反向代理</li></ol> 
<hr> 
<h4><a id="38_498"></a>38.防抖和节流是什么？</h4> 
<p>都是应对页面中频繁触发事件的优化方案</p> 
<ol><li>防抖:避免事件重复触发<br> 使用场景:1.频繁和服务端交互 2.输入框的自动保存事件</li><li>节流:把频繁触发的事件减少,每隔一段时间执行<br> 使用场景:scroll 事件</li></ol> 
<hr> 
<h4><a id="39_515"></a>39.有没有做过无感登录？</h4> 
<ol><li>在相应其中拦截，判断 token 返回过期后，调用刷新 token 的接口</li><li>后端返回过期时间，前端判断 token 的过期时间，去调用刷新 token 的接口</li><li>写定时器，定时刷新 token 接口<br> <strong>流程：</strong></li><li>登录成功后保存 token 和 refresh_token</li><li>在响应拦截器中对 401 状态码引入刷新 token 的 api 方法调用</li><li>替换保存本地新的 token</li><li>把错误对象里的 token 替换</li><li>再次发送未完成的请求</li><li>如果 refresh_token 过期了，判断是否过期，过期了就清楚所有 token 重新登</li></ol> 
<hr> 
<h4><a id="40_535"></a>40.大文件上传是怎么做的？</h4> 
<ol><li>分片上传：<br> 1.1把需要上传的文件按照一定的规则，分割成相同大小的数据块<br> 1.2 初始化一个分片上传任务，返回本次分片上传的唯一标识<br> 1.3 按照一定的规则把各个数据块上传<br> 1.4 发送完成后，服务端会判断数据上传的完整性，如果完整，那么就会把数据库合并成原始文件</li><li>断点续传：<br> 服务端返回，从哪里开始 浏览器自己处理</li></ol> 
<hr> 
<h3><a id="Vue_552"></a>Vue篇</h3> 
<hr> 
<h4><a id="1__560"></a>1. 生命周期</h4> 
<h5><a id="11__563"></a>1.1 有哪些生命周期</h5> 
<p>系统自带：</p> 
<blockquote> 
 <ol><li>beforeCreate</li><li>created</li><li>beforeMount</li><li>mounted</li><li>beforeUpdate</li><li>updated</li><li>beforeDestroy</li><li>destroyed</li></ol> 
</blockquote> 
<p>如果给组件加上keep-alive，会额外多</p> 
<blockquote> 
 <ol><li>activated</li><li>deactivated</li></ol> 
</blockquote> 
<hr> 
<h5><a id="12_601"></a>1.2首次进入页面或者组件，会执行哪些生命周期</h5> 
<blockquote> 
 <ol><li>beforeCreate</li><li>created</li><li>beforeMount</li><li>mounted</li></ol> 
</blockquote> 
<p>若组件添加keep-alive属性</p> 
<blockquote> 
 <ol><li>beforeCreate</li><li>created</li><li>beforeMount</li><li>mounted</li><li>acitivated</li></ol> 
</blockquote> 
<hr> 
<h5><a id="13eldata_635"></a>1.3在哪个阶段产生<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         e 
        
       
         l 
        
       
         ， 
        
       
      
        el， 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord cjk_fallback">，</span></span></span></span></span>data</h5> 
<blockquote> 
 <ol><li>$el (根节点dom) 产生阶段 : mounted</li><li>$data产生阶段：created</li></ol> 
</blockquote> 
<hr> 
<h5><a id="14_nn1_652"></a>1.4 第n（n&gt;1）次进入组件会执行哪些生命周期</h5> 
<p>普通组件</p> 
<blockquote> 
 <ol><li>beforeCreate</li><li>created</li><li>beforeMount</li><li>mounted</li></ol> 
</blockquote> 
<p>组件【添加keep-alive属性】</p> 
<blockquote> 
 <ol><li>activated</li><li>若离开，则执行deactivated</li></ol> 
</blockquote> 
<hr> 
<h4><a id="2keepalive_686"></a>2.对keep-alive的理解</h4> 
<blockquote> 
 <ol><li>是什么<br> Vue自带的一个组件<br> 功能:用来缓存组件的 【提升性能】</li><li>使用场景【尽量减少发送网络请求与后端交互+反复访问的组件减少其创建次数】<br> 缓存详情页【组件】-&gt;在详情页的activated方法中判断之前刷新的参数与当前接收的参数是否一致，如果一致就不刷新数据，否则就发送网络请求刷新数据</li></ol> 
</blockquote> 
<hr> 
<h4><a id="3vif__vshow_706"></a>3.v-if 和 v-show的区别</h4> 
<ol><li>dom元素的加载区别</li></ol> 
<blockquote> 
 <p>v-if 是创建了一个dom节点 如果值为true时 值为false时不创建或者移除该节点<br> v-show 是直接创建 display:none 隐藏了</p> 
</blockquote> 
<ol start="2"><li>使用场景不同</li></ol> 
<blockquote> 
 <ol><li>初次加载v-if比v-show好 页面不会多加载dom盒子</li><li>频繁切换 v-show比v-if好 创建和删除开销太大，显示和隐藏开销小</li><li>如果都是值为true，首次加载v-if比v-show快，相同的节点v-show会多加一个display:none=的css属性</li></ol> 
</blockquote> 
<hr> 
<h4><a id="4vif_vfor_739"></a>4.v-if 和v-for优先级</h4> 
<p><strong>v-for</strong> 比 <strong>v-if</strong> 优先级更高 <em>vue.js源码中可以看到 v-for 的分支在v-if之前</em></p> 
<blockquote> 
 <ol><li>如果同一个组件 既加了v-for 也加了 v-if 那么速度会下降许多，是先执行v-for渲染列表数据，然后再每个子项都进行v-if判断，增大开销。</li><li>如果需要判断v-if成立，再执行v-for渲染子项，那么可以使用template模板</li></ol> 
 <pre><code>&lt;template v-if="condition"&gt;
	&lt;div v-for="item in list"&gt;&lt;/div&gt;
&lt;/template&gt;

</code></pre> 
</blockquote> 
<hr> 
<h4><a id="5ref_767"></a>5.ref是什么</h4> 
<blockquote> 
 <ol><li>作用： 用来快速获取dom的，而不用document.getElement*（）</li><li>使用示例：</li></ol> 
 <pre><code>&lt;img ref="imgref"  src="\*\*"  id= "img" &gt;

</code></pre> 
 <p>原生js：<br> <code>document.getElementById("img")</code><br> vue:<br> <code>this.$refs.imgs</code></p> 
</blockquote> 
<hr> 
<h4><a id="6nextTick_796"></a>6.nextTick是什么</h4> 
<blockquote> 
 <ol><li>作用：获取更新后的dom内容<br> 例如：<br> <code>&lt;div ref="box" @click="change"&gt;{<!-- -->{content}}&lt;/div&gt;</code></li></ol> 
</blockquote> 
<pre><code>...
data(){
	return {
		content:"old"
	}
}
methods:{
	change(){
		this.str="new";
		console.log(this.$refs.box.innerText);//输出old ref中的dom数据未来得及更新
		this.$nextTick(()=&gt;{
			console.log(this.$refs.box.innerText);//输出new
		})
	}
}

</code></pre> 
<hr> 
<h4><a id="7scoped__834"></a>7.scoped 原理</h4> 
<blockquote> 
 <ol><li>作用：让样式在本组件中生效，不影响其他组件</li><li>原理：给组件节点新增自定义属性，然后css根据属性选择器添加样式，类似于下面…</li></ol> 
</blockquote> 
<pre><code>&lt;style&gt;
	div[data-v-xxx]{
		background:red;
	}
&lt;/style&gt;
...
&lt;div data-v-xxx&gt;sss&lt;/div&gt;
&lt;div&gt;bbb&lt;/div&gt;

</code></pre> 
<hr> 
<h4><a id="8CSS_864"></a>8.CSS样式穿透</h4> 
<blockquote> 
 <p>如何让CSS只在当前组件中起作用？</p> 
 <ol><li>给当前组件添加scoped<br> <code>&lt;style scoped&gt;&lt;/style&gt;</code><br> <strong>如果不加，则该css样式全局生效</strong></li><li>scss<br> 2.1 先下载 <code>npm install sass-loader node-sass --save</code><br> 2.2 需要给style 添加 属性 <code>lang="scss"</code></li></ol> 
 <pre><code> &lt;style scoped  lang="scss"&gt;
  $color: red;
  .warn{
   	color:	$color;
  }
 &lt;/style&gt;

</code></pre> 
 <p>2.3 scss样式穿透</p> 
 <pre><code>父元素 /deep/ 子元素 {
 新样式
}

</code></pre> 
 <p>例如 修改第三方插件的样式<img src="https://images2.imgbox.com/35/f6/ehNGD0cH_o.png" alt="在这里插入图片描述"><br> 3. stylus<br> 3.1 下载<br> <code>npm install stylus stylus-loader --svae</code><br> 3.2 添加lang属性<br> <code>&lt;style lang="stylus" scoped&gt; &lt;/style&gt;</code><br> 3.3 stylus样式穿透 [两种方式 deep 或者 &gt;&gt;&gt; ]</p> 
 <pre><code>&lt;style scoped lang="stylus"&gt;
父元素 /deep/ 子元素 {
新样式
}
父元素 &gt;&gt;&gt; 子元素 {
新样式
}

&lt;/style&gt;

</code></pre> 
</blockquote> 
<hr> 
<h4><a id="9_933"></a>9.组件的传值</h4> 
<ol><li>父组件传值给子组件</li></ol> 
<blockquote> 
 <ol><li>父组件<br> <code>&lt;Child :data="msg"&gt;&lt;/Child&gt;</code><br> msg和data里面的变量名一致</li><li>子组件</li></ol> 
 <pre><code>&lt;div&gt;{<!-- -->{data}}&lt;/div&gt;
export default{
  //1. 数组
  props:['data']
  //2. 对象
   props:{
     data:String
   }
}

</code></pre> 
</blockquote> 
<ol start="2"><li>子组件传值到父组件</li></ol> 
<blockquote> 
 <ol><li>子组件<br> <code>this.$emit("eventName",value);</code></li><li>父组件 在组件中使用 @事件名 绑定子组件的事件到函数</li></ol> 
 <pre><code>&lt;div  @eventName="getVal"&gt;&lt;/div&gt;
...
methods:{
	getVal(msg){
		this.content=msg; //msg就是子组件传递的内容
	}
}

</code></pre> 
</blockquote> 
<ol start="3"><li>兄弟组件之间的传值</li></ol> 
<blockquote> 
 <p>通过中转站 eventBus</p> 
 <ol><li>创建bus.js</li></ol> 
 <pre><code>import Vue from 'vue'
export default new Vue;

</code></pre> 
 <ol start="2"><li>发送</li></ol> 
 <pre><code>import bus from '@/bus'
bus.$emit("toBrother",value);

</code></pre> 
 <ol start="3"><li>接收</li></ol> 
 <pre><code>import bus from '@/bus'
mounted(){
	bus.$on("toBrother",(data)=&gt;{
		this.data=data;  //data就是其他兄弟节点传递过来的
	})
}

</code></pre> 
</blockquote> 
<hr> 
<h4><a id="10computedmethodswatch_1039"></a>10.computed,methods,watch有什么区别</h4> 
<ol><li>computed <strong>vs</strong> methods</li></ol> 
<blockquote> 
 <p>computed 计算属性是有缓存的【只有当计算的内容发生变化时才会重新计算和调用】 例如 return 111 ; 调用三次 也只会调用一次computed方法，因为值不会发生变化。<br> methods 没有缓存 调用多少次执行多少次</p> 
</blockquote> 
<ol start="2"><li>computed <strong>vs</strong> watch</li></ol> 
<blockquote> 
 <ol><li>watch :<br> 1.1 侦听属性 数据或者路由发生了改变才会执行<br> 1.2 一次只能监听单个变量 变化情况 如需要监听多个比较繁琐</li><li>computed<br> 2.1 计算的某一个属性的值改变了，计算属性会检测到进行返回。<br> 2.2 computed一个方法可以监听多个相关属性</li></ol> 
</blockquote> 
<hr> 
<h4><a id="11props_data__1075"></a>11.props 和data 优先级比较</h4> 
<p><strong>props是父组件传递进来的，data是组件本身定义的</strong><br> 优先级: props =&gt; methods=&gt; data =&gt; computed=&gt; watch</p> 
<hr> 
<h4><a id="12Vue_1087"></a>12.Vue设置代理</h4> 
<p>代理用于解决开发时的网络跨域问题，可以将所有请求交由proxy去访问</p> 
<blockquote> 
 <ol><li>创建配置文件 vue.config.js</li></ol> 
 <pre><code>module.exports = {
publicPath:'./',
	devServer: {
		proxy: 'http://localhost:3000'  // 打包完成后不生效
	}
}

</code></pre> 
 <ol start="2"><li>使用时url 不加前面的ip段 直接写接口 如/login</li><li>如果是开发模式 devServer不适用 会打包后出现异常</li></ol> 
</blockquote> 
<hr> 
<h4><a id="13_Vue_1121"></a>13. Vue打包路径和路由模式</h4> 
<p>打包路径配置<br> vue.config.js</p> 
<pre><code>module.exports = {
	publicPath:'./', // 默认为 / 打包后css js等文件的引入地址前缀
}

</code></pre> 
<p>路由模式：history[默认]，hash #</p> 
<blockquote> 
 <p>前端如果自己测试项目，用hash<br> 项目上线要求是 history模式，该怎么办？<br> 交给后端进行重定向</p> 
</blockquote> 
<hr> 
<h4><a id="14_1154"></a>14.代理和环境变量</h4> 
<p>开发环境 .env.development</p> 
<pre><code>VUE\_APP\_TITLE=
VUE\_APP\_ENV='dev'
VUE\_APP\_BASE\_API="http:localhost:3000/"

</code></pre> 
<p>生产环境 .env.production</p> 
<pre><code>VUE\_APP\_TITLE=
VUE\_APP\_ENV='pro'
VUE\_APP\_BASE\_API="http:127.0.0.1:3000/"

</code></pre> 
<p>在axios封装的时候其base_url</p> 
<pre><code>	let base_url=""
	if(process.env.VUE\_APP\_ENV=='pro'){
		base_url=process.baseApi+url;
	}else{
		// dev模式可以通过代理去访问 直接为默认的url即可
		base_url=url;
	}

</code></pre> 
<hr> 
<h4><a id="15Vue_1199"></a>15.Vue路由</h4> 
<p>路由模式：history[默认]，hash #<br> 区别：</p> 
<blockquote> 
 <ol><li>表现形式不同<br> hash模式多了#</li><li>跳转<br> 访问 http:localhost:8888/id<br> history：会发送请求<br> hash: 不会发送</li><li>打包后 前端自测要使用hash，如果使用history会出现空白</li></ol> 
</blockquote> 
<hr> 
<h4><a id="16SPASPA_1225"></a>16.SPA及SPA的缺点</h4> 
<p>SPA是什么？单页面应用<br> 缺点：</p> 
<blockquote> 
 <ol><li>SEO优化不好</li><li>性能不是特别好【需要首页优化】</li></ol> 
</blockquote> 
<hr> 
<h4><a id="17_MVVM__1246"></a>17.如何理解 MVVM 的？</h4> 
<p>是 Model-View-ViewModel 的缩写。前端开发的架构模式<br> M：模型，对应的就是 data 的数据<br> V：视图，用户界面，DOM<br> VM：视图模型：Vue 的实例对象，连接 View 和 Model 的桥梁<br> 核心是提供对 View 和 ViewModel 的双向数据绑定，当数据改变的时候，ViewModel<br> 能监听到数据的变化，自动更新视图，当用户操作视图的时候，ViewModel 也可以监听到视<br> 图的变化，然后通知数据进行改动，这就实现了双向数据绑定<br> ViewModel 通过双向绑定把 View 和 Model 连接起来，他们之间的同步是自动的，<br> 不需要认为干涉，所以我们只需要关注业务逻辑即可，不需要操作 DOM，同时也不需要关<br> 注数据的状态问题，因为她是由 MVVM 统一管理</p> 
<hr> 
<h4><a id="18vfor__key__1266"></a>18.v-for 中的 key 值的作用是什么？</h4> 
<p>key 属性是 DOM 元素的唯一标识<br> 作用：</p> 
<ol><li>提高虚拟 DOM 的更新</li><li>若不设置 key，可能会触发一些 bug</li><li>为了触发过度效果</li></ol> 
<hr> 
<h4><a id="19VUE_1283"></a>19.VUE路径传值</h4> 
<p>显式传值</p> 
<pre><code>	==&gt;localhost:8080/about?a=1;
	this.$router.push({
		path:'/about',
		query:{
			a:1	
		}
	})
	this.$router.push({
		path:'/about?a=1'
	})
	使用query接收值
	this.$router.query.a

</code></pre> 
<p>隐式传值</p> 
<pre><code>	this.$router.push({
		name:'/About',
		params:{a:1}
	})
	接收：
	this.$router.params.a

</code></pre> 
<hr> 
<h4><a id="20vue__1325"></a>20.vue 中遍历全局的方法有哪些？</h4> 
<ol><li>普通遍历，对象.forEach()</li></ol> 
<pre><code>arr.forEach(function(item,index,arr){
	console.log(item,index)
})

</code></pre> 
<ol start="2"><li>对元素统一操作 对象.map()</li></ol> 
<pre><code>var newarr = arr.map(function(item){
	return item+1
})

</code></pre> 
<p>3.查找符合条件的元素 对象.filter()</p> 
<pre><code>arr.filter(function(item){
	if(item &gt; 2){
		return false
	}else{
		return true
	}
})

</code></pre> 
<p>4.查询符合条件的元素，返回索引 对象.findindex()</p> 
<pre><code>arr.finindex(function(item){
	if(item&gt;1){
		return true
	}else{
		return false
	}
})

</code></pre> 
<ol start="5"><li>对象.evening() 遇到不符合的对象会停止</li><li>对象.some() 找到符合条件的元素就停止</li></ol> 
<hr> 
<h4><a id="21_vue__1389"></a>21. vue 的过滤器怎么使用？</h4> 
<p>vue 的特性，用来对文本进行格式化处理<br> 使用它的两个地方，一个是插值表达式，一个是 v-bind<br> 分类：</p> 
<ol><li>全局过滤器</li></ol> 
<pre><code>Vue.filter('add',function(v){
	return v &lt; 10 ? '0' + v : v
})
&lt;div&gt;{<!-- -->{33 | add}}&lt;/div&gt;

</code></pre> 
<ol start="2"><li>本地过滤器<br> 和 methods 同级</li></ol> 
<pre><code>filter:{
	add:function(v){
		return v &lt; 10 ? '0' + v : v
	}
}

</code></pre> 
<hr> 
<h4><a id="22_1428"></a>22.如何封装一个组件？</h4> 
<ol><li>使用 Vue.extend()创建一个组件</li><li>使用 Vue.components()方法注册组件</li><li>如果子组件需要数据，可以在 props 中接收定义</li><li>子组件修改好数据，要把数据传递给父组件，可以用 emit()方法<br> 原则：<br> (1) 把功能拆开<br> (2)尽量让组件原子化，一个组件做一件事情<br> (3)容器组件管数据，展示组件管视图</li></ol> 
<hr> 
<h4><a id="23_1446"></a>23.封装一个可复用的组件，需要满足什么条件？</h4> 
<ol><li>低耦合，组件之间的依赖越小越好</li><li>最好从父级传入信息，不要在公共组件中请求数据</li><li>传入的数据要进行校验</li><li>处理事件的方法写在父组件中</li></ol> 
<hr> 
<h4><a id="24_1460"></a>24.路由导航守卫有哪些</h4> 
<p>全局、路由独享、组件内</p> 
<blockquote> 
 <ol><li>全局【参数 to from next】<br> beforeEach、beforeResolve, afterEach</li><li>路由独享<br> beforeEnter</li><li>组件内【很少】<br> beforeRouterEnter、beforeRouterUpdate、beforeRouterLeave</li></ol> 
</blockquote> 
<pre><code>const router = new VueRouter({
	mode:"history",
	base:process.env.BASE\_URL,
	routes
})
router.beforeEach((to, from,next)=&gt;{
	console.log(to,from,next)//to是到哪个页面 from从哪来 next 就是保安
	if(有权限){ 
		next() // 放行
	}else{
		router.push('/login') //转发到其他页面
	}
})

</code></pre> 
<p>在进入某个页面之前进行拦截，可以进行<strong>权限判断</strong></p> 
<h4><a id="_1501"></a>分享</h4> 
<p><strong><a href="https://bbs.csdn.net/forums/4304bb5a486d4c3ab8389e65ecb71ac0">开源分享：【大厂前端面试题解析+核心总结学习笔记+真实项目实战+最新讲解视频】</a></strong></p> 
<p><img src="https://images2.imgbox.com/fd/9f/IDU1iSkV_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/15/18/g3Jl34WD_o.png" alt=""></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6d666160afdcc9589346f0dec9ed9246/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2024年最全前端程序员面试笔试宝典，2024年最新web前端高级工程师面试题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/af026ef5d7ab7de1d2006d393452cb0e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL四种方法实现merge into</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>