<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【研发日记】Matlab/Simulink技能解锁(十二)——Stateflow中的两种状态机嵌套对比 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/46acdc9ade65aca2be032fd498493fa3/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【研发日记】Matlab/Simulink技能解锁(十二)——Stateflow中的两种状态机嵌套对比">
  <meta property="og:description" content="文章目录 前言
项目背景
两级状态机
函数状态机
分析和应用
总结
参考资料
前言 见《【研发日记】Matlab/Simulink技能解锁(七)——两种复数移相算法》
见《【研发日记】Matlab/Simulink技能解锁(八)——分布式仿真》
见《【研发日记】Matlab/Simulink技能解锁(九)——基于嵌入式处理器仿真》
见《【研发日记】Matlab/Simulink技能解锁(十)——PID调参技巧》
见《【研发日记】Matlab/Simulink技能解锁(十一)——Stateflow中的en、du、ex应用对比》
项目背景 近期使用Simulink开发的嵌入式项目中，用到了Stateflow中的状态机嵌套，使用过程中发现了两种嵌套方式存在关键的差异，极易踩坑。查阅官方文档并没有找到相应的解释。利用周末时间亲自摸索了一下，把它们的一些基本规律和技巧总结下来。
两级状态机 两级状态机是在某个State里边直接放入一个Stateflow，示例如下：
从上图可以看出，外层s1每次进入之后，一方面正常执行自有的代码（Cnt=Cnt&#43;1;），另一方面也有序地执行内层的Stateflow。当外层s1退出时，内层的Stateflow也全部退出。当外层s1重新进入时，内层的Stateflow不管前一次停在哪个State，这时候都要从初始State（s2）开始执行。
函数状态机 函数状态机是在某个State里边放入一个Simulik Function，然后再在里边放入一个Stateflow，以此间接实现状态机嵌套的目的，示例如下：
从图上可以看出，外层Stateflow进入s1之后，嵌套在s1内部的Simulik Function也被调用起来，Fcn()实际上也是一个Stateflow。跟前面的两级状态机相比，外层Stateflow基本没有区别，内层Stateflow也是完全一样，正常理解的话应该运行得到相同的结果。实际运行起来看到了很关键的差异，就是外层State每次进入后，内层Stateflow运行的起点不一样。第一次外层进入s1时，内层是从初始State（s2）开始执行的。第二次外层进入s1时，内层直接就从s3开始执行。后面外层每次进入s1，内层都从s3开始执行。
分析和应用 1、两级状态机的外层State每次重新进入时，内层的Stateflow不管原本停在哪个State，都会回到初始State重新开始运行。这种状态机嵌套模式，内层的Stateflow是没有“记忆”的，适合应用于有初始化操作或者有复位操作的系统，比如带有累加功能或者积分功能的应用，每次重新启动都需要清零操作。
2、函数状态机的外层State每次重新进入时，内层的Stateflow都会先找到原本停在哪个State，然后从那里开始继续运行。这种状态机嵌套模式，能保证内层的Stateflow有准确“记忆”，适合应用于需要暂存数据的系统，比如有固定执行序列的应用，当应用被打断又重新恢复时，需要从原有的位置开始运行。
总结 以上就是本人在研发中使用Stateflow中的状态机嵌套时，一些个人理解和分析的总结，主要是对比介绍了两种状态机嵌套方式的基本规律，展示了仿真运行的效果，并分析了它们的特点和适用场景。
后续还会分享另外几个最近解锁的Matlab/Simulink新技能，欢迎评论区留言、点赞、收藏和关注，这些鼓励和支持都将成文本人持续分享的动力。
另外，上述例程使用的Demo工程，可以到笔者的主页查找和下载。
参考资料 Mathworks Help -&gt; Stateflow 版权声明，原创文章，转载和引用请注明出处和链接，侵权必究！">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-02T19:48:37+08:00">
    <meta property="article:modified_time" content="2024-08-02T19:48:37+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【研发日记】Matlab/Simulink技能解锁(十二)——Stateflow中的两种状态机嵌套对比</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" height="741" src="https://images2.imgbox.com/d1/eb/VnWf330n_o.png" width="1200"></p> 
<h3 id="%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95" style="margin-left:0;text-align:justify;"><span style="color:#0070c0;">文章目录</span></h3> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:40px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF-toc" style="margin-left:40px;"><a href="#%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF" rel="nofollow">项目背景</a></p> 
<p id="%E4%B8%A4%E7%BA%A7%E7%8A%B6%E6%80%81%E6%9C%BA-toc" style="margin-left:40px;"><a href="#%E4%B8%A4%E7%BA%A7%E7%8A%B6%E6%80%81%E6%9C%BA" rel="nofollow">两级状态机</a></p> 
<p id="%E5%87%BD%E6%95%B0%E7%8A%B6%E6%80%81%E6%9C%BA-toc" style="margin-left:40px;"><a href="#%E5%87%BD%E6%95%B0%E7%8A%B6%E6%80%81%E6%9C%BA" rel="nofollow">函数状态机</a></p> 
<p id="%E5%88%86%E6%9E%90%E5%92%8C%E5%BA%94%E7%94%A8-toc" style="margin-left:40px;"><a href="#%E5%88%86%E6%9E%90%E5%92%8C%E5%BA%94%E7%94%A8" rel="nofollow">分析和应用</a></p> 
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
<p id="%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-toc" style="margin-left:40px;"><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" rel="nofollow">参考资料</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="%E5%89%8D%E8%A8%80" style="margin-left:0;text-align:justify;"><span style="color:#0070c0;">前言</span></h3> 
<p>        见《<a href="https://blog.csdn.net/CSSUST/article/details/138747225" title="【研发日记】Matlab/Simulink技能解锁(七)——两种复数移相算法">【研发日记】Matlab/Simulink技能解锁(七)——两种复数移相算法</a>》</p> 
<p>        见《<a href="https://blog.csdn.net/CSSUST/article/details/138974301" title="【研发日记】Matlab/Simulink技能解锁(八)——分布式仿真">【研发日记】Matlab/Simulink技能解锁(八)——分布式仿真</a>》</p> 
<p>        见《<a href="https://blog.csdn.net/CSSUST/article/details/139030952" title="【研发日记】Matlab/Simulink技能解锁(九)——基于嵌入式处理器仿真">【研发日记】Matlab/Simulink技能解锁(九)——基于嵌入式处理器仿真</a>》</p> 
<p>        见《<a href="https://blog.csdn.net/CSSUST/article/details/140747800" title="【研发日记】Matlab/Simulink技能解锁(十)——PID调参技巧">【研发日记】Matlab/Simulink技能解锁(十)——PID调参技巧</a>》</p> 
<p style="margin-left:0;text-align:justify;">        见《<a class="link-info" href="https://blog.csdn.net/CSSUST/article/details/140809146" title="【研发日记】Matlab/Simulink技能解锁(十一)——Stateflow中的en、du、ex应用对比">【研发日记】Matlab/Simulink技能解锁(十一)——Stateflow中的en、du、ex应用对比</a>》</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<h3 id="%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF" style="margin-left:0;text-align:justify;"><span style="color:#0070c0;">项目背景</span></h3> 
<p style="margin-left:0;text-align:justify;">        近期使用Simulink开发的嵌入式项目中，用到了Stateflow中的<span style="color:#ff0000;">状态机嵌套</span>，使用过程中发现了两种嵌套方式存在<span style="color:#ff0000;">关键的差异</span>，极易踩坑。查阅官方文档并没有找到相应的解释。利用周末时间亲自摸索了一下，把它们的一些基本<span style="color:#ff0000;">规律和技巧</span>总结下来。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<h3 id="%E4%B8%A4%E7%BA%A7%E7%8A%B6%E6%80%81%E6%9C%BA" style="margin-left:0;text-align:justify;"><span style="color:#0070c0;">两级状态机</span></h3> 
<p style="margin-left:0;text-align:justify;">        两级状态机是在某个State里边<span style="color:#ff0000;">直接放入一个Stateflow</span>，示例如下：</p> 
<p class="img-center"><img alt="" height="534" src="https://images2.imgbox.com/e8/22/tVLsM0Zm_o.png" width="700"></p> 
<p class="img-center"><img alt="" height="558" src="https://images2.imgbox.com/9a/ed/IbMnlS8b_o.png" width="900"></p> 
<p style="margin-left:0;text-align:justify;">        从上图可以看出，外层s1每次进入之后，一方面正常执行自有的代码（Cnt=Cnt+1;），另一方面也有序地执行内层的Stateflow。当外层s1退出时，内层的Stateflow也全部退出。当外层s1重新进入时，内层的Stateflow不管前一次停在哪个State，这时候都要从<span style="color:#ff0000;">初始State</span>（s2）开始执行。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<h3 id="%E5%87%BD%E6%95%B0%E7%8A%B6%E6%80%81%E6%9C%BA" style="margin-left:0;text-align:justify;"><span style="color:#0070c0;">函数状态机</span></h3> 
<p style="margin-left:0;text-align:justify;">        函数状态机是在某个State里边放入一个<span style="color:#ff0000;">Simulik Function</span>，然后再在里边放入一个Stateflow，以此间接实现状态机嵌套的目的，示例如下：</p> 
<p class="img-center"><img alt="" height="534" src="https://images2.imgbox.com/ec/7f/xtVtVl7S_o.png" width="700"></p> 
<p class="img-center"><img alt="" height="557" src="https://images2.imgbox.com/b9/b4/cyW6ijgj_o.png" width="900"></p> 
<p>        从图上可以看出，外层Stateflow进入s1之后，嵌套在s1内部的Simulik Function也被调用起来，Fcn()实际上也是一个Stateflow。跟前面的两级状态机相比，外层Stateflow基本没有区别，内层Stateflow也是完全一样，正常理解的话应该运行得到相同的结果。实际运行起来看到了<span style="color:#ff0000;">很关键的差异</span>，就是外层State每次进入后，<span style="color:#ff0000;">内层</span>Stateflow运行的<span style="color:#ff0000;">起点不一样</span>。第一次外层进入s1时，内层是从初始State（s2）开始执行的。第二次外层进入s1时，内层直接就从s3开始执行。后面外层每次进入s1，内层都从s3开始执行。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<h3 id="%E5%88%86%E6%9E%90%E5%92%8C%E5%BA%94%E7%94%A8" style="margin-left:0;text-align:justify;"><span style="color:#0070c0;">分析和应用</span></h3> 
<p style="margin-left:0;text-align:justify;">        1、<span style="color:#ff0000;">两级状态机</span>的外层State每次重新进入时，内层的Stateflow不管原本停在哪个State，都会回到<span style="color:#ff0000;">初始State</span>重新开始运行。这种状态机嵌套模式，内层的Stateflow是<span style="color:#ff0000;">没有“记忆”</span>的，适合应用于有初始化操作或者有复位操作的系统，比如带有累加功能或者积分功能的应用，每次重新启动都需要清零操作。</p> 
<p style="margin-left:0;text-align:justify;">        2、<span style="color:#ff0000;">函数状态机</span>的外层State每次重新进入时，内层的Stateflow都会先找到<span style="color:#ff0000;">原本停在哪个State</span>，然后从那里开始继续运行。这种状态机嵌套模式，能保证内层的Stateflow<span style="color:#ff0000;">有准确“记忆”</span>，适合应用于需要暂存数据的系统，比如有固定执行序列的应用，当应用被打断又重新恢复时，需要从原有的位置开始运行。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<h3 id="%E6%80%BB%E7%BB%93" style="margin-left:0;text-align:justify;"><span style="color:#0070c0;">总结</span></h3> 
<p style="margin-left:0;text-align:justify;">        以上就是本人在研发中使用<span style="color:#ff0000;">Stateflow</span>中的<span style="color:#ff0000;">状态机嵌套</span>时，一些个人理解和分析的总结，主要是对比介绍了两种状态机嵌套方式的基本规律，展示了仿真运行的效果，并分析了它们的特点和适用场景。</p> 
<p style="margin-left:0;text-align:justify;">        后续还会分享另外几个最近解锁的Matlab/Simulink新技能，欢迎评论区留言、点赞、收藏和关注，这些鼓励和支持都将成文本人持续分享的动力。</p> 
<p style="margin-left:0;text-align:justify;">        另外，上述例程使用的Demo工程，可以到笔者的主页查找和下载。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<h3 id="%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" style="margin-left:0;text-align:justify;"><span style="color:#0070c0;">参考资料</span></h3> 
<pre><code class="language-cpp">    Mathworks Help -&gt; Stateflow</code></pre> 
<hr> 
<p style="margin-left:0;text-align:justify;">        版权声明，原创文章，转载和引用请注明出处和链接，<span style="color:#ff0000;">侵权必究！</span></p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="246" src="https://images2.imgbox.com/77/09/lbLpmWeU_o.png" width="1179"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e9cebd17944f824d369443d976ab923a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【2024构建RAG问答系统】深度解析LlamaIndex自动合并检索框架，大语言模型必知</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/072867b857ea28ee791d1832ab9d1551/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言数据在内存中的存储超详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>