<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【基础算法总结】链表 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/c39e09ed71df9de9316768a0140bc2be/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【基础算法总结】链表">
  <meta property="og:description" content="链表 1.链表常用技巧和操作总结2.两数相加4.两两交换链表中的节点4.重排链表5.合并 K 个升序链表6.K 个一组翻转链表 点赞👍👍收藏🌟🌟关注💖💖
你的支持是对我最大的鼓励，我们一起努力吧!😃😃
1.链表常用技巧和操作总结 常用技巧
1.画图 !!! -&gt; 直观 &#43; 形象 &#43; 便于我们理解
2.引入虚拟 “头” 节点
便于处理边界情况方便我们对链表操作 3.不要吝啬空间，大胆去定义变量
比如都会遇到到这种题，前两句必须放前面，不然链表就断开了。但是我们可以定义一个next，这样就不用管按什么顺序了。
4.快慢指针
判环，找链表中环的入口，找链表中倒数第 n 个节点，都是用快慢指针解决的。
链表中的常用操作
1.创建一个新节点 new
2.尾插
3.头插
2.两数相加 题目链接：2. 两数相加
题目分析：
给两个链表，注意是逆序的。将两个数相加，还以逆序方式返回一个表示和的链表。
这道题给逆序正好方便我们从低位相加，如果是正序给的还要把链表逆置一下。
算法原理：
解法：模拟两数相加的过程即可
我们先来一个虚拟头结点，这样就少了判断为空的情况，直接尾插即可！在来一个 t 表示进位。t = cur1-&gt;val &#43; cur2-&gt;val，每次都拿个数位构建节点。
class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode* newhead, *tail; newhead = tail = new ListNode;//创建一个虚拟节点记录最终结果 ListNode* cur1 = l1, *cur2 = l2; int t = 0; // 记录进位 while(cur1 || cur2 || t) { // 先加上第一个链表 if(cur1) { t &#43;= cur1-&gt;val; cur1 = cur1-&gt;next; } // 加上第二个链表 if(cur2) { t &#43;= cur2-&gt;val; cur2 = cur2-&gt;next; } tail-&gt;next = new ListNode(t % 10); tail = tail-&gt;next; t /= 10; } //防内存泄漏 // tail = newhead-&gt;next; // delete newhead; // return tail; return newhead-&gt;next; } }; 4.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-12T09:38:38+08:00">
    <meta property="article:modified_time" content="2024-07-12T09:38:38+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【基础算法总结】链表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>链表</h4> 
 <ul><li><a href="#1_7" rel="nofollow">1.链表常用技巧和操作总结</a></li><li><a href="#2_38" rel="nofollow">2.两数相加</a></li><li><a href="#4_98" rel="nofollow">4.两两交换链表中的节点</a></li><li><a href="#4_159" rel="nofollow">4.重排链表</a></li><li><a href="#5_K__307" rel="nofollow">5.合并 K 个升序链表</a></li><li><a href="#6K__456" rel="nofollow">6.K 个一组翻转链表</a></li></ul> 
</div> 
<p></p> 
<p><img src="https://images2.imgbox.com/36/6f/zW9ysF7Z_o.jpg" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>点赞</strong>👍👍<strong>收藏</strong>🌟🌟<strong>关注</strong>💖💖<br> <font color="red"><strong>你的支持是对我最大的鼓励，我们一起努力吧!😃😃</strong></font></p> 
</blockquote> 
<h2><a id="1_7"></a>1.链表常用技巧和操作总结</h2> 
<p><strong>常用技巧</strong></p> 
<blockquote> 
 <p><strong>1.画图 !!!</strong> -&gt; 直观 + 形象 + 便于我们理解</p> 
</blockquote> 
<blockquote> 
 <p><strong>2.引入虚拟 “头” 节点</strong></p> 
</blockquote> 
<ol><li>便于处理边界情况</li><li>方便我们对链表操作</li></ol> 
<blockquote> 
 <p><strong>3.不要吝啬空间，大胆去定义变量</strong></p> 
</blockquote> 
<p>比如都会遇到到这种题，前两句必须放前面，不然链表就断开了。但是我们可以定义一个next，这样就不用管按什么顺序了。<br> <img src="https://images2.imgbox.com/53/f2/QZQBFfZY_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>4.快慢指针</strong></p> 
</blockquote> 
<p>判环，找链表中环的入口，找链表中倒数第 n 个节点，都是用快慢指针解决的。</p> 
<p><strong>链表中的常用操作</strong></p> 
<blockquote> 
 <p><strong>1.创建一个新节点 new</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>2.尾插</strong></p> 
</blockquote> 
<blockquote> 
 <p><strong>3.头插</strong></p> 
</blockquote> 
<h2><a id="2_38"></a>2.两数相加</h2> 
<p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/add-two-numbers/" rel="nofollow">2. 两数相加</a></p> 
<p><strong>题目分析：</strong></p> 
<p><img src="https://images2.imgbox.com/ae/50/wxc2Q1L9_o.png" alt="在这里插入图片描述"></p> 
<p>给两个链表，注意是逆序的。将两个数相加，还以逆序方式返回一个表示和的链表。</p> 
<p>这道题给逆序正好方便我们从低位相加，如果是正序给的还要把链表逆置一下。<br> <img src="https://images2.imgbox.com/d0/ed/JdE1tB9F_o.png" alt="在这里插入图片描述"><br> <strong>算法原理：</strong></p> 
<p><strong>解法：模拟两数相加的过程即可</strong></p> 
<p>我们先来一个虚拟头结点，这样就少了判断为空的情况，直接尾插即可！在来一个 t 表示进位。t = cur1-&gt;val + cur2-&gt;val，每次都拿个数位构建节点。</p> 
<p><img src="https://images2.imgbox.com/2a/56/9b6GZuyR_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    ListNode<span class="token operator">*</span> <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> l1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> l2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        ListNode<span class="token operator">*</span> newhead<span class="token punctuation">,</span> <span class="token operator">*</span>tail<span class="token punctuation">;</span>
        newhead <span class="token operator">=</span> tail <span class="token operator">=</span> <span class="token keyword">new</span> ListNode<span class="token punctuation">;</span><span class="token comment">//创建一个虚拟节点记录最终结果</span>
        ListNode<span class="token operator">*</span> cur1 <span class="token operator">=</span> l1<span class="token punctuation">,</span> <span class="token operator">*</span>cur2 <span class="token operator">=</span> l2<span class="token punctuation">;</span>
        <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 记录进位</span>

        <span class="token keyword">while</span><span class="token punctuation">(</span>cur1 <span class="token operator">||</span> cur2 <span class="token operator">||</span> t<span class="token punctuation">)</span> 
        <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 先加上第一个链表</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>cur1<span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                t <span class="token operator">+=</span> cur1<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>
                cur1 <span class="token operator">=</span> cur1<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 加上第二个链表</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>cur2<span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                t <span class="token operator">+=</span> cur2<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>
                cur2 <span class="token operator">=</span> cur2<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            tail<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>t <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            tail <span class="token operator">=</span> tail<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>

            t <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">//防内存泄漏</span>
        <span class="token comment">// tail = newhead-&gt;next;</span>
        <span class="token comment">// delete newhead;</span>
        <span class="token comment">// return tail;</span>

        <span class="token keyword">return</span> newhead<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="4_98"></a>4.两两交换链表中的节点</h2> 
<p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/" rel="nofollow">24. 两两交换链表中的节点<br> </a></p> 
<p><strong>题目分析：</strong></p> 
<p><img src="https://images2.imgbox.com/0f/3e/lbXmQ5RD_o.png" alt="在这里插入图片描述"></p> 
<p>两两交换链表的节点，注意不能直接交换里面的值，只能修改指针。这道题在递归、搜索回溯专题用递归的方法解决。这里用循环迭代的方式。</p> 
<p><strong>算法原理：</strong></p> 
<p><strong>解法一：递归</strong></p> 
<p><strong>解法二：循环、迭代(模拟)</strong></p> 
<p>引入一个<strong>头节点</strong>，这样就减少判断边界的问题。如果不引入，交换前两个节点和后面的节点写法是不一样的，因为还要返回头指针，所以就只能先处理前两个找到最终返回的头节点，然后在处理后面的。这样太麻烦了。引入头节点，因为已经有了头节点所有后面处理逻辑都是一样的。</p> 
<p>因为我们要两两交换，这里我们需要四个指针。<strong>不要吝啬空间，大胆去定义变量</strong> ，这样交换指针的时候，不用担心代码顺序导致找不到链表的问题，有了这四个指针随便先写那一步。交换之后指针都移动一下。</p> 
<p><img src="https://images2.imgbox.com/3b/33/PdJZzCfZ_o.png" alt="在这里插入图片描述"></p> 
<p>什么时候结束呢？节点可能有奇数个，也可能有偶数个。</p> 
<p>可以看到当cur或者next为空的时候就结束了。<br> <img src="https://images2.imgbox.com/8e/c8/hwDF334u_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    ListNode<span class="token operator">*</span> <span class="token function">swapPairs</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> head<span class="token operator">-&gt;</span>next <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>

        ListNode<span class="token operator">*</span> newhead <span class="token operator">=</span> <span class="token keyword">new</span> ListNode<span class="token punctuation">;</span>
        newhead<span class="token operator">-&gt;</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>

        ListNode<span class="token operator">*</span> prev <span class="token operator">=</span> newhead<span class="token punctuation">,</span> <span class="token operator">*</span>cur <span class="token operator">=</span> head<span class="token punctuation">,</span> <span class="token operator">*</span>next <span class="token operator">=</span> head<span class="token operator">-&gt;</span>next<span class="token punctuation">,</span> <span class="token operator">*</span>nnext <span class="token operator">=</span> head<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>

        <span class="token keyword">while</span><span class="token punctuation">(</span>cur <span class="token operator">&amp;&amp;</span> next<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 交换节点 </span>
            prev<span class="token operator">-&gt;</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
            next<span class="token operator">-&gt;</span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span>
            cur<span class="token operator">-&gt;</span>next <span class="token operator">=</span> nnext<span class="token punctuation">;</span>

            <span class="token comment">// 修改指针，注意nullptr指针解引用</span>
            prev <span class="token operator">=</span> cur<span class="token punctuation">;</span>
            cur <span class="token operator">=</span> nnext<span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span> next <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span>nnext <span class="token operator">=</span> next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
            
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> newhead<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="4_159"></a>4.重排链表</h2> 
<p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/reorder-list/description/" rel="nofollow">143. 重排链表</a></p> 
<p><strong>题目分析：</strong></p> 
<p><img src="https://images2.imgbox.com/0f/4f/pOMZ5al6_o.png" alt="在这里插入图片描述"></p> 
<p>给一个链表让按照规则重排一下。</p> 
<p><strong>算法原理：</strong></p> 
<p><strong>解法：模拟</strong></p> 
<ol><li><strong>找到链表的中间节点</strong><br> <strong>快慢指针</strong></li><li><strong>把后面的部分逆序</strong><br> <strong>头插</strong></li><li><strong>合并两个链表</strong><br> <strong>(合并两个有序链表)双指针</strong><br> <img src="https://images2.imgbox.com/38/e5/gYtbAUH2_o.png" alt="在这里插入图片描述"></li></ol> 
<p>对于找到中间节点然后逆序，有两种做法。<br> <img src="https://images2.imgbox.com/32/87/XqIHoEUV_o.png" alt="在这里插入图片描述"></p> 
<p>第一种逆序策略：<strong>slow-&gt;next 后面逆序</strong></p> 
<p>因为这道题比较特殊可以将slow-&gt;next 后面逆序，因为你会发现逆序完之后中间位置还是在一起的。因此可以大胆将slow节点给第一个链表。</p> 
<p><img src="https://images2.imgbox.com/10/06/P36rYRLQ_o.png" alt="在这里插入图片描述"></p> 
<p>第二种逆序策略：<strong>从slow位置开始逆序</strong></p> 
<p><img src="https://images2.imgbox.com/84/1b/Cf0FX6md_o.png" alt="在这里插入图片描述"></p> 
<p>两种策略都是可以的。</p> 
<p><img src="https://images2.imgbox.com/8a/72/ZlCj0leZ_o.png" alt="在这里插入图片描述"></p> 
<p>但是如果使用头插法逆序，建议还是第一种策略，因为我们是想让两个链表断开的。如果想逆序后链表还是在一起的，就用第二种策略。</p> 
<p><img src="https://images2.imgbox.com/9e/45/wBsy0oG5_o.png" alt="在这里插入图片描述"><br> 第一种策略</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	 <span class="token keyword">void</span> <span class="token function">reorderList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		 <span class="token comment">// 处理边界情况</span>
		 <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> head<span class="token operator">-&gt;</span>next <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> head<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next <span class="token operator">==</span> nullp
		 
		 <span class="token comment">// 1. 找到链表的中间节点 - 快慢双指针（⼀定要画图考虑 slow 的落点在哪⾥）</span>
		 ListNode<span class="token operator">*</span> slow <span class="token operator">=</span> head<span class="token punctuation">,</span> <span class="token operator">*</span>fast <span class="token operator">=</span> head<span class="token punctuation">;</span>
		 <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">&amp;&amp;</span> fast<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span>
		 <span class="token punctuation">{<!-- --></span>
			 slow <span class="token operator">=</span> slow<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
			 fast <span class="token operator">=</span> fast<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		 <span class="token punctuation">}</span>
		 
		 <span class="token comment">// 2. 把 slow 后⾯的部分给逆序 - 头插法</span>
		 ListNode<span class="token operator">*</span> head2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		 ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> slow<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		 slow<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">// 注意把两个链表给断开</span>
		 <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
		 <span class="token punctuation">{<!-- --></span>
			 ListNode<span class="token operator">*</span> next <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
			 cur<span class="token operator">-&gt;</span>next <span class="token operator">=</span> head2<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
			 head2<span class="token operator">-&gt;</span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span>
			 cur <span class="token operator">=</span> next<span class="token punctuation">;</span>
		 <span class="token punctuation">}</span>
		 <span class="token comment">// 3. 合并两个链表 - 双指针</span>
		 ListNode<span class="token operator">*</span> ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		 ListNode<span class="token operator">*</span> prev <span class="token operator">=</span> ret<span class="token punctuation">;</span>
		 ListNode<span class="token operator">*</span> cur1 <span class="token operator">=</span> head<span class="token punctuation">,</span> <span class="token operator">*</span>cur2 <span class="token operator">=</span> head2<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
		 <span class="token keyword">while</span><span class="token punctuation">(</span>cur1<span class="token punctuation">)</span>
		 <span class="token punctuation">{<!-- --></span>
			 <span class="token comment">// 先放第⼀个链表</span>
			 prev<span class="token operator">-&gt;</span>next <span class="token operator">=</span> cur1<span class="token punctuation">;</span>
			 cur1 <span class="token operator">=</span> cur1<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
			 prev <span class="token operator">=</span> prev<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
			 
			 <span class="token comment">// 再放第⼆个链表</span>
			 <span class="token keyword">if</span><span class="token punctuation">(</span>cur2<span class="token punctuation">)</span>
			 <span class="token punctuation">{<!-- --></span>
			 prev<span class="token operator">-&gt;</span>next <span class="token operator">=</span> cur2<span class="token punctuation">;</span>
			 prev <span class="token operator">=</span> prev<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
			 cur2 <span class="token operator">=</span> cur2<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
			 <span class="token punctuation">}</span>
		 <span class="token punctuation">}</span>
		<span class="token keyword">delete</span> head2<span class="token punctuation">;</span>
		<span class="token keyword">delete</span> ret<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>第二种策略</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">reorderList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        <span class="token comment">// 处理边界情况</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> head<span class="token operator">-&gt;</span>next <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> head<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

        <span class="token comment">// 1.找链表中间节点 -&gt; 快慢指针(画图考虑slow的落点在哪里)</span>
        ListNode<span class="token operator">*</span> fast <span class="token operator">=</span> head<span class="token punctuation">,</span> <span class="token operator">*</span>slow <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">&amp;&amp;</span> fast<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            slow <span class="token operator">=</span> slow<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
            fast <span class="token operator">=</span> fast<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 2.将slow以及后面链表翻转 -&gt; 头插法</span>
        ListNode <span class="token operator">*</span>cur <span class="token operator">=</span> slow<span class="token punctuation">,</span> <span class="token operator">*</span>phead <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> <span class="token operator">*</span>next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            next <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
            cur<span class="token operator">-&gt;</span>next <span class="token operator">=</span> phead<span class="token punctuation">;</span>
            phead <span class="token operator">=</span> cur<span class="token punctuation">;</span>
            cur <span class="token operator">=</span> next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 3.合并两个链表 -&gt; 双指针</span>
        ListNode<span class="token operator">*</span> newhead <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> <span class="token operator">*</span>tail <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        newhead <span class="token operator">=</span> tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>phead<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span><span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                tail<span class="token operator">-&gt;</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>
                tail <span class="token operator">=</span> head<span class="token punctuation">;</span>
                head <span class="token operator">=</span> head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
                
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span>
            <span class="token punctuation">{<!-- --></span>
                tail<span class="token operator">-&gt;</span>next <span class="token operator">=</span> phead<span class="token punctuation">;</span>
                tail <span class="token operator">=</span> phead<span class="token punctuation">;</span>
                phead <span class="token operator">=</span> phead<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token operator">++</span>i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        head <span class="token operator">=</span> newhead<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token keyword">delete</span> newhead<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="5_K__307"></a>5.合并 K 个升序链表</h2> 
<p><strong>题目链接：</strong> <a href="https://leetcode.cn/problems/merge-k-sorted-lists/description/" rel="nofollow">23. 合并 K 个升序链表</a></p> 
<p><strong>题目分析：</strong></p> 
<p><img src="https://images2.imgbox.com/78/6f/6wIZkhA9_o.png" alt="在这里插入图片描述"><br> 前面学过合并两个有序链表，现在有k个有序链表让合并一下。</p> 
<p><strong>算法原理：</strong></p> 
<p><strong>解法一：暴力求解</strong><br> 利用合并两个有序链表思想，可以先让前两个链表合并成一个新的链表，然后拿新的链表在和下一个链表合并。。。。直到把所有链表合并完。</p> 
<p><img src="https://images2.imgbox.com/e8/d7/38Jp5NMy_o.png" alt="在这里插入图片描述"><br> 但是时间复杂度很恐怖，假设每一个链表长度为n，共有k个链表。看合并几次有序链表。如果是第一个链表，需要合并k-1次，并且长度为n，所以第一个链表 时间复杂度 n(k-1)。第二个链表n(k-2)。。。所以最终时间复杂度为O(nk^2)</p> 
<p><img src="https://images2.imgbox.com/c6/75/dXMpxxn3_o.png" alt="在这里插入图片描述"></p> 
<p><strong>解法二：利用优先级队列做优化</strong></p> 
<p>合并K个有序链表，我们可以仿照合并两个有序链表的逻辑。先不考虑优先级队列，考虑如何对上面的做优化。</p> 
<p>我们仿照合并两个有序链表的逻辑，先定义K个指针指向每一个链表，找出这个K个指针中值较小的节点，放在newhead的后面，放完之后，让这个指针往后移动。然后继续比较这K个指针指向的节点。这正好就是合并两个有序链表的逻辑。K个链表就K个指针，谁小谁就先连接newhead后面。</p> 
<p><img src="https://images2.imgbox.com/30/d5/Pw5QC4pN_o.png" alt="在这里插入图片描述"></p> 
<p>如何快速找到谁是K个节点中谁是较小的那个呢？<br> 利用优先级队列。</p> 
<p>因此我们的最终策略就是，搞一个小根堆，先将K个指针先丢到小根堆里，堆顶放的节点就是接下来我们要连接到newhead后面的节点。将堆顶节点连接到newhead后面之后，让这个指针往后移动然后进入优先级队列。此时堆顶也还是K个指针中最小的节点。。。。直到指针到空就不让这个链表进入队列了。等到所有链表的指针都到空了。说明链表合并结束了。</p> 
<p>堆每次调整logk，一共进入nk个，所以这个时间复杂度O(nklogk)</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> 
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">//类中的仿函数不能支持我们将最小节点放在栈顶</span>
	<span class="token comment">//因此指针并不是递增</span>
	<span class="token comment">//所以自己定义一个仿函数用来支持将最小节点放在栈顶</span>
    <span class="token keyword">struct</span> <span class="token class-name">greater</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> ListNode<span class="token operator">*</span> x<span class="token punctuation">,</span><span class="token keyword">const</span> ListNode<span class="token operator">*</span> y<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> x<span class="token operator">-&gt;</span>val <span class="token operator">&gt;</span> y<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    ListNode<span class="token operator">*</span> <span class="token function">mergeKLists</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>ListNode<span class="token operator">*</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> lists<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>lists<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>

        ListNode<span class="token operator">*</span> newhead <span class="token operator">=</span> <span class="token keyword">new</span> ListNode<span class="token punctuation">;</span>
        ListNode<span class="token operator">*</span> tail <span class="token operator">=</span> newhead<span class="token punctuation">;</span>
        priority_queue<span class="token operator">&lt;</span>ListNode<span class="token operator">*</span><span class="token punctuation">,</span>vector<span class="token operator">&lt;</span>ListNode<span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>greater<span class="token operator">&gt;</span> pq<span class="token punctuation">;</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> lists<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>lists<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
                pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>lists<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>


        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 出</span>
            ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            tail<span class="token operator">-&gt;</span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span>
            tail <span class="token operator">=</span> cur<span class="token punctuation">;</span>
            pq<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">//进</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span>
                pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
	
        <span class="token keyword">return</span> newhead<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>解法三：分治 - 递归</strong><br> 利用归并排序。</p> 
<p>假设有6个链表，让把这6个合起来成一个有序链表。此时可以沿着中间将6个链表一分为二，左边三个链表，右边三个链表，现让左边三个合并成一个链表，然后在让右边三个合并成一个链表。然后拿着这个两个有序链表，在合并成一个有序链表。</p> 
<p>两个有序链表，在合并成一个有序链表。我们是非常熟悉的。</p> 
<p><img src="https://images2.imgbox.com/5b/fa/yW6VmQyH_o.png" alt="在这里插入图片描述"><br> 现在重点就是上面的让左边三个合并成一个，右边三个合并成一个，应该怎么做呢？</p> 
<p>其实是和这个大过程是一样的。以左边三个为例，策略和上面一样。把三个链表从中间分开。先左边一个合并成一个有序链表，在让右边两个合并成一个有序链表。然后在把这两个链表合并成一个有序链表。左右可以再分。逻辑是一模一样的，这整体就是一个递归过程！</p> 
<p><img src="https://images2.imgbox.com/7f/e6/mb3wCMyH_o.png" alt="在这里插入图片描述"><br> 此时我们就可以用递归来实现这个策略。并且和归并排序过程是一样的。</p> 
<p>归并排序先分然后才合，时间复杂度我们紧盯每一个链表节点执行多少次。分就是一个完全二叉树。每一个链表都会合并，合并次数是这个数的高度次，假设有k个链表树高度logk，每一个链表都执行logk合并，一共有k个链表，每一个链表有n个节点，所以时间复杂度O(nklogk)</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> 
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>

 	ListNode<span class="token operator">*</span> <span class="token function">mergeKLists</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>ListNode<span class="token operator">*</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> lists<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>

        <span class="token keyword">return</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span>lists<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> lists<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    ListNode<span class="token operator">*</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>ListNode<span class="token operator">*</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> lists<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&gt;</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">==</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span> lists<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
        ListNode<span class="token operator">*</span> newhead1 <span class="token operator">=</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span>lists<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
        ListNode<span class="token operator">*</span> newhead2 <span class="token operator">=</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span>lists<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>

        ListNode<span class="token operator">*</span> newhead <span class="token operator">=</span> <span class="token keyword">new</span> ListNode<span class="token punctuation">;</span>
        ListNode<span class="token operator">*</span> tail <span class="token operator">=</span> newhead<span class="token punctuation">;</span>
        ListNode<span class="token operator">*</span> cur1 <span class="token operator">=</span> newhead1<span class="token punctuation">,</span> <span class="token operator">*</span>cur2 <span class="token operator">=</span> newhead2<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>cur1 <span class="token operator">&amp;&amp;</span> cur2<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
           <span class="token keyword">if</span><span class="token punctuation">(</span>cur1<span class="token operator">-&gt;</span>val <span class="token operator">&lt;</span> cur2<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span>
           <span class="token punctuation">{<!-- --></span>
                tail<span class="token operator">-&gt;</span>next <span class="token operator">=</span> cur1<span class="token punctuation">;</span>
                tail <span class="token operator">=</span> cur1<span class="token punctuation">;</span>
                cur1 <span class="token operator">=</span> cur1<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
           <span class="token keyword">else</span>
           <span class="token punctuation">{<!-- --></span>
                tail<span class="token operator">-&gt;</span>next <span class="token operator">=</span> cur2<span class="token punctuation">;</span>
                tail <span class="token operator">=</span> cur2<span class="token punctuation">;</span>
                cur2 <span class="token operator">=</span> cur2<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span>cur1<span class="token punctuation">)</span>
            tail<span class="token operator">-&gt;</span>next <span class="token operator">=</span> cur1<span class="token punctuation">;</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span>cur2<span class="token punctuation">)</span>
            tail<span class="token operator">-&gt;</span>next <span class="token operator">=</span> cur2<span class="token punctuation">;</span>

        tail <span class="token operator">=</span> newhead<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token keyword">delete</span> newhead<span class="token punctuation">;</span>
        <span class="token keyword">return</span> tail<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="6K__456"></a>6.K 个一组翻转链表</h2> 
<p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/description/" rel="nofollow">25. K 个一组翻转链表</a></p> 
<p><strong>题目分析：</strong></p> 
<p><img src="https://images2.imgbox.com/71/ee/UIUEIo4P_o.png" alt="在这里插入图片描述"><br> 前面有一道题是两两一组翻转链表，现在是让k个一组翻转链表，小于k的就不用翻转了。<br> <img src="https://images2.imgbox.com/44/3c/nRXZWRag_o.png" alt="在这里插入图片描述"></p> 
<p><strong>算法原理：</strong></p> 
<p><strong>解法：模拟</strong></p> 
<ol><li>先求出需要逆序多少组： n</li><li>重复 n 次，长度为 k 的链表的逆序即可(头插法)</li></ol> 
<p>先求出需要逆序多少组： n，剩下的就不逆序了，直接连接上就好了。申请一个头结点newhead，把k个节点头插到newhead后面即可。注意这只是第一组，下一组也要头插怎么办？因此我们需要一个tmp指针记录下一次执行头插的头结点在哪，prev在一次头插结束之后就更新一下 prev = tmp ，prev指向充当头结点。</p> 
<p><img src="https://images2.imgbox.com/37/2a/F2oLoYyu_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    ListNode<span class="token operator">*</span> <span class="token function">reverseKGroup</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        <span class="token comment">// 1.先求出需要逆序多少组</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        ListNode<span class="token operator">*</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token operator">++</span>n<span class="token punctuation">;</span>
            cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        n <span class="token operator">/=</span> k<span class="token punctuation">;</span>

        <span class="token comment">// 2.重复 n 次: 长度为 k 的链表逆序即可</span>
        ListNode<span class="token operator">*</span> newhead <span class="token operator">=</span> <span class="token keyword">new</span> ListNode<span class="token punctuation">;</span>
        ListNode<span class="token operator">*</span> prev <span class="token operator">=</span> newhead<span class="token punctuation">;</span>
        cur <span class="token operator">=</span> head<span class="token punctuation">;</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            ListNode<span class="token operator">*</span> tmp <span class="token operator">=</span> cur<span class="token punctuation">;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                ListNode<span class="token operator">*</span> next <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
                cur<span class="token operator">-&gt;</span>next <span class="token operator">=</span> prev<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
                prev<span class="token operator">-&gt;</span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span>
                cur <span class="token operator">=</span> next<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            prev <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 3.把不需要翻转的接上</span>
        prev<span class="token operator">-&gt;</span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span>

        prev <span class="token operator">=</span> newhead<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token keyword">delete</span> newhead<span class="token punctuation">;</span>
        <span class="token keyword">return</span> prev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f53f35bedbe33b5826c6e197bc63cca6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Hologres&#43;Flink企业级实时数仓核心能力介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8a44411ee007a24ed63902dd65b79342/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">风景区服务热线系统：智能化时代的旅游新选择</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>