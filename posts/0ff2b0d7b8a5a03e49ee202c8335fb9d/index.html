<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;高阶】二叉搜索树的全面解析与高效实现 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/0ff2b0d7b8a5a03e49ee202c8335fb9d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;高阶】二叉搜索树的全面解析与高效实现">
  <meta property="og:description" content="✨ 人生到处知何似，应似飞鸿踏雪泥 🌏 📃个人主页：island1314
🔥个人专栏：C&#43;&#43;学习
🚀 欢迎关注：👍点赞 👂🏽留言 😍收藏 💞 💞 💞
二叉搜索树目录
一、二叉搜索树的概念
二、二叉搜索树的功能
三、二叉搜索树的实现
🧩1. 节点定义：
🧩2. BST定义：
🧩3. 二叉搜索树的操作
🌈a. 查找
🌈b. 插入
🌈c. 删除
🌈d. 遍历
🧩4、二叉搜索树默认成员函数
🎉构造
🎉拷贝构造
🎉赋值重载
🎉析构
4. 二叉搜索树的应用
🍁1. K模型
💧数组的排序实现
🍁2. KV模型
🍁3. KV模型实现
💧英汉词典的查找实现
💧计数
5.二叉搜索树的性能分析
🌄二叉树巩固知识
一、二叉搜索树的概念 二叉搜索树(BST,Binary Search Tree)又称二叉排序树，是一种特殊的二叉树，它或者是一棵空树，或者是具有以下性质的二叉树:
若它的左子树不为空，则左子树上所有节点的值都小于根节点的值若它的右子树不为空，则右子树上所有节点的值都大于根节点的值它的左右子树也分别为二叉搜索树 二叉搜索树（Binary Search Tree）的每个节点的左子树中的所有节点都比该节点小，右子树中的所有节点都比该节点大。这个特性使得二叉搜索树可以用来实现非常高效的查找、插入和删除操作。
二、二叉搜索树的功能 🎈首先，在二叉搜索树的操作中只支持插入，查找，删除，遍历，并不支持修改操作，因为在修改后谁也不能保证它依然是一棵二叉搜索树，二叉搜索树的时间复杂度范围在(O(logN)~O(N))
🎈在二叉搜索树的遍历中一般采用中序遍历： 先遍历左子树，然后访问根节点，最后遍历右子树。在BST中，中序遍历会按照升序访问所有节点
int a[] = {8, 3, 1, 10, 6, 4, 7, 14, 13}; 三、二叉搜索树的实现 二叉搜索树结构的和树形结构差不多，这意味着每个元素（通常称为节点）都有两个指针：一个指向前一个左子树，另一个指向右子树，因此我们需要单独再定义一个类来表示节点结构，每个节点再串联起来构成BST">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-18T17:38:42+08:00">
    <meta property="article:modified_time" content="2024-07-18T17:38:42+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;高阶】二叉搜索树的全面解析与高效实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><img alt="" height="363" src="https://images2.imgbox.com/3b/cf/dgPETLdb_o.jpg" width="531"></p> 
<p style="text-align:center;"></p> 
<p>✨                                                  <span style="color:#956fe7;"><strong>     人生到处知何似，应似飞鸿踏雪泥</strong> </span>      🌏 </p> 
<p>📃<a href="https://so.csdn.net/so/search?q=%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5&amp;spm=1001.2101.3001.7020" title="个人主页">个人主页</a>：<a href="https://blog.csdn.net/island1314?spm=1011.2266.3001.5343" title="island1314">island1314</a></p> 
<p>🔥个人专栏：<a href="https://blog.csdn.net/island1314/category_12622912.html" title="C++学习">C++学习</a></p> 
<p>🚀 欢迎关注：👍点赞 👂🏽留言 😍收藏  💞 💞 💞</p> 
<p style="text-align:center;">     <img alt="" src="https://images2.imgbox.com/4f/52/0LLEMfr5_o.gif"></p> 
<hr> 
<p id="main-toc"><strong>二叉搜索树目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">一、二叉搜索树的概念</a></p> 
<p id="%E4%BA%8C%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%8A%9F%E8%83%BD-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%8A%9F%E8%83%BD" rel="nofollow">二、二叉搜索树的功能</a></p> 
<p id="%E4%B8%89%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">三、二叉搜索树的实现</a></p> 
<p id="%F0%9F%A7%A91.%20%E8%8A%82%E7%82%B9%E5%AE%9A%E4%B9%89%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%F0%9F%A7%A91.%20%E8%8A%82%E7%82%B9%E5%AE%9A%E4%B9%89%EF%BC%9A" rel="nofollow">🧩1. 节点定义：</a></p> 
<p id="%F0%9F%A7%A92.%C2%A0BST%E5%AE%9A%E4%B9%89%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%F0%9F%A7%A92.%C2%A0BST%E5%AE%9A%E4%B9%89%EF%BC%9A" rel="nofollow">🧩2. BST定义：</a></p> 
<p id="%F0%9F%A7%A93.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#%F0%9F%A7%A93.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C" rel="nofollow">🧩3. 二叉搜索树的操作</a></p> 
<p id="%F0%9F%8C%88a.%20%E6%9F%A5%E6%89%BE-toc" style="margin-left:120px;"><a href="#%F0%9F%8C%88a.%20%E6%9F%A5%E6%89%BE" rel="nofollow">🌈a. 查找</a></p> 
<p id="%F0%9F%8C%88b.%20%E6%8F%92%E5%85%A5-toc" style="margin-left:120px;"><a href="#%F0%9F%8C%88b.%20%E6%8F%92%E5%85%A5" rel="nofollow">🌈b. 插入</a></p> 
<p id="%F0%9F%8C%88c.%20%E5%88%A0%E9%99%A4-toc" style="margin-left:120px;"><a href="#%F0%9F%8C%88c.%20%E5%88%A0%E9%99%A4" rel="nofollow">🌈c. 删除</a></p> 
<p id="%F0%9F%8C%88d.%20%E9%81%8D%E5%8E%86-toc" style="margin-left:120px;"><a href="#%F0%9F%8C%88d.%20%E9%81%8D%E5%8E%86" rel="nofollow">🌈d. 遍历</a></p> 
<p id="%F0%9F%A7%A94%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%F0%9F%A7%A94%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0" rel="nofollow">🧩4、二叉搜索树默认成员函数</a></p> 
<p id="%F0%9F%8E%89%E6%9E%84%E9%80%A0-toc" style="margin-left:120px;"><a href="#%F0%9F%8E%89%E6%9E%84%E9%80%A0" rel="nofollow">🎉构造</a></p> 
<p id="%F0%9F%8E%89%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0-toc" style="margin-left:120px;"><a href="#%F0%9F%8E%89%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0" rel="nofollow">🎉拷贝构造</a></p> 
<p id="%F0%9F%8E%89%E8%B5%8B%E5%80%BC%E9%87%8D%E8%BD%BD-toc" style="margin-left:120px;"><a href="#%F0%9F%8E%89%E8%B5%8B%E5%80%BC%E9%87%8D%E8%BD%BD" rel="nofollow">🎉赋值重载</a></p> 
<p id="%F0%9F%8E%89%E6%9E%90%E6%9E%84-toc" style="margin-left:120px;"><a href="#%F0%9F%8E%89%E6%9E%90%E6%9E%84" rel="nofollow">🎉析构</a></p> 
<p id="4.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8-toc" style="margin-left:40px;"><a href="#4.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8" rel="nofollow">4. 二叉搜索树的应用</a></p> 
<p id="%F0%9F%8D%811.%20K%E6%A8%A1%E5%9E%8B-toc" style="margin-left:80px;"><a href="#%F0%9F%8D%811.%20K%E6%A8%A1%E5%9E%8B" rel="nofollow">🍁1. K模型</a></p> 
<p id="%F0%9F%92%A7%E6%95%B0%E7%BB%84%E7%9A%84%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:120px;"><a href="#%F0%9F%92%A7%E6%95%B0%E7%BB%84%E7%9A%84%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0" rel="nofollow">💧数组的排序实现</a></p> 
<p id="%F0%9F%8D%812.%C2%A0KV%E6%A8%A1%E5%9E%8B-toc" style="margin-left:80px;"><a href="#%F0%9F%8D%812.%C2%A0KV%E6%A8%A1%E5%9E%8B" rel="nofollow">🍁2. KV模型</a></p> 
<p id="%F0%9F%8D%813.%20KV%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#%F0%9F%8D%813.%20KV%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0" rel="nofollow">🍁3. KV模型实现</a></p> 
<p id="%F0%9F%92%A7%E8%8B%B1%E6%B1%89%E8%AF%8D%E5%85%B8%E7%9A%84%E6%9F%A5%E6%89%BE%E5%AE%9E%E7%8E%B0-toc" style="margin-left:120px;"><a href="#%F0%9F%92%A7%E8%8B%B1%E6%B1%89%E8%AF%8D%E5%85%B8%E7%9A%84%E6%9F%A5%E6%89%BE%E5%AE%9E%E7%8E%B0" rel="nofollow">💧英汉词典的查找实现</a></p> 
<p id="%F0%9F%92%A7%E8%AE%A1%E6%95%B0-toc" style="margin-left:120px;"><a href="#%F0%9F%92%A7%E8%AE%A1%E6%95%B0" rel="nofollow">💧计数</a></p> 
<p id="5.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#5.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90" rel="nofollow">5.二叉搜索树的性能分析</a></p> 
<p id="%F0%9F%8C%84%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B7%A9%E5%9B%BA%E7%9F%A5%E8%AF%86-toc" style="margin-left:40px;"><a href="#%F0%9F%8C%84%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B7%A9%E5%9B%BA%E7%9F%A5%E8%AF%86" rel="nofollow">🌄二叉树巩固知识</a></p> 
<p></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="%E4%B8%80%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5">一、二叉搜索树的概念</h3> 
<p>二叉搜索树(BST,Binary Search Tree)又称<span style="color:#fe2c24;"><strong>二叉排序树</strong></span>，是一种特殊的二叉树，它或者是一棵空树，或者是具有以下性质的二叉树:</p> 
<ul><li>若它的左子树不为空，则左子树上所有节点的值都<strong>小于</strong>根节点的值</li><li>若它的右子树不为空，则右子树上所有节点的值都<strong>大于</strong>根节点的值</li><li>它的左右子树也分别为<span style="color:#fe2c24;">二叉搜索树</span></li></ul> 
<p><img alt="" height="275" src="https://images2.imgbox.com/42/12/Is6WQ9bA_o.png" width="976"></p> 
<blockquote> 
 <p>    <strong>    二叉搜索树（Binary Search Tree）</strong>的每个节点的左子树中的所有节点都比该节点小，右子树中的所有节点都比该节点大。这个特性使得二叉搜索树可以用来实现非常高效的<strong>查找、插入和删除操作。</strong></p> 
</blockquote> 
<h3 id="%E4%BA%8C%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%8A%9F%E8%83%BD">二、二叉搜索树的功能</h3> 
<p>🎈首先，在二叉搜索树的操作中只支持插入，查找，删除，遍历，并不支持修改操作，因为在修改后谁也不能保证它依然是一棵二叉搜索树，二叉搜索树的时间复杂度范围在(O(logN)~O(N))</p> 
<p>🎈<strong>在二叉搜索树的遍历中一般采用中序遍历：</strong> 先遍历左子树，然后访问根节点，最后遍历右子树。在BST中，中序遍历会按照<strong>升序访问所有节点</strong></p> 
<p><img alt="" height="254" src="https://images2.imgbox.com/d9/5e/GqTOszZO_o.png" width="304"></p> 
<pre><code class="language-cpp">int a[] = {8, 3, 1, 10, 6, 4, 7, 14, 13};
</code></pre> 
<h4></h4> 
<p></p> 
<h3 id="%E4%B8%89%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0">三、二叉搜索树的实现</h3> 
<p><img alt="" height="300" src="https://images2.imgbox.com/9e/9b/arCBaGvc_o.png" width="410"></p> 
<blockquote> 
 <p><strong>二叉搜索树结构的和树形结构差不多，这意味着每个元素（通常称为节点）都有两个指针：一个指向前一个左子树，另一个指向右子树，因此我们需要单独再定义一个类来表示节点结构，每个节点再串联起来构成BST</strong></p> 
</blockquote> 
<p><span style="color:#fe2c24;">（在模拟实现二叉搜索树时，不用定义命名空间，因为不会和库中发生冲突）</span></p> 
<h4 id="%F0%9F%A7%A91.%20%E8%8A%82%E7%82%B9%E5%AE%9A%E4%B9%89%EF%BC%9A">🧩1. 节点定义：</h4> 
<pre><code class="language-cpp">template &lt;class K&gt;
struct BSTNode {
	K _key;
	BSTNode&lt;K&gt;* _left;
	BSTNode&lt;K&gt;* _right;
	
	BSTNode(const K&amp;key)
		:_key(key)
		,_left(nullptr)
		,_right(nullptr)
	{}
};</code></pre> 
<h4 id="%F0%9F%A7%A92.%C2%A0BST%E5%AE%9A%E4%B9%89%EF%BC%9A">🧩2. <strong>BST定义</strong>：</h4> 
<pre><code class="language-cpp">template&lt;class K&gt;
class BSTree
{
	typedef BSTreeNode&lt;K&gt; Node;
public:
	// 构造函数等可能的其他成员函数... 
private:
	Node* _root = nullptr;
};
</code></pre> 
<h4 id="%F0%9F%A7%A93.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C">🧩3. 二叉搜索树的操作</h4> 
<h5 id="%F0%9F%8C%88a.%20%E6%9F%A5%E6%89%BE">🌈a. 查找</h5> 
<blockquote> 
 <p><strong>a、</strong>从根开始比较，查找，比根大则往右边走查找，比根小则往左边走查找。<br><strong>b、</strong>最多查找高度次，走到到空，还没找到，这个值不存在。</p> 
</blockquote> 
<pre><code class="language-cpp">bool Find(const K&amp; key) 
{
	Node* cur = _root;
	while (cur) {
		if (cur-&gt;_key &lt; key) { //查找的值比cur小，往左走
			cur = cur-&gt;_right;
		}
		else if (cur-&gt;_key &gt; key) { //查找的值比cur大，往右走
			cur = cur-&gt;_left;
		}
		else  return true;//找到就返回true
	}
	return false; //找不到
}</code></pre> 
<p><span style="color:#fe2c24;"><strong>递归版本</strong></span></p> 
<pre><code class="language-cpp">bool FindR(Node* _root, const K&amp; key)
		{
			if (_root == nullptr)
			{
				return false;
			}

			if (key &gt; _root-&gt;_key)
			{
				return _FindR(_root-&gt;_right, key);
			}
			else if (key &lt; _root-&gt;_key)
			{
				return _FindR(_root-&gt;_left, key);
			}
			else
			{
				return true;
			}
		}
</code></pre> 
<p></p> 
<h5 id="%F0%9F%8C%88b.%20%E6%8F%92%E5%85%A5">🌈b. 插入</h5> 
<blockquote> 
 <p><strong>a、</strong>树为空，则直接新增节点，赋值给root指针<br><strong>b、</strong>树不空，按二叉搜索树性质查找插入位置，插入新节点</p> 
</blockquote> 
<h4></h4> 
<h4 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="396" src="https://images2.imgbox.com/34/57/I9JorWDp_o.png" width="835"></h4> 
<pre><code class="language-cpp">bool Insert(const K&amp;key) //需要找个节点保留插入节点的父节点，先找到要插入位置
{
	if (_root == nullptr) { //根为空时直接插入
		_root = new Node(key); 
		return true;
	}
	// 定义parent是因为，在最后找到插入位置时，需要parent将节点进行连接
	Node* parent = nullptr;
	Node* cur = _root;
	while (cur) {
		if (cur-&gt;_key &lt; key) {// 插入的值比cur位置大，cur往右走
			parent = cur;
			cur = cur-&gt;_right;
		}
		else if (cur-&gt;_key &gt; key) {// 插入的值比cur位置小，cur往左走
			parent = cur;
			cur = cur-&gt;_left;
		}
        // 当插入的值和cur位置相等时，直接退出，因为二叉搜索树不允许有相同的元素
		else  return false;
	}
	//新插入节点与二叉搜索树连接
	cur = new Node(key);
	if (parent-&gt;_key &lt; key) parent-&gt;_right = cur;
	else parent-&gt;_left = cur;
	
	return true;
}</code></pre> 
<p><span style="color:#fe2c24;">递归版本</span></p> 
<pre><code class="language-cpp">bool InsertR(Node*&amp; _root, const K&amp; key)
{
	// 递归出口
	if (_root == nullptr)
	{
		// 这里我们无需在进行对新节点的连接，因为我们是传引用传参，
		_root = new Node(key);
		return true;
	}

	if (key &gt; _root-&gt;_key)
	{
		return _InsertR(_root-&gt;_right, key);
	}
	else if (key &lt; _root-&gt;_key)
	{
		return _InsertR(_root-&gt;_left, key);
	}
	else
	{
		return false;
	}
}
</code></pre> 
<h5 id="%F0%9F%8C%88c.%20%E5%88%A0%E9%99%A4">🌈c. 删除</h5> 
<blockquote> 
 <p>首先查找元素是否在二叉搜索树中，如果不存在，则返回, 否则要删除的结点可能分下面四种情况：<br><strong>a. 要删除的结点无孩子结点<br> b. 要删除的结点只有左孩子结点<br> c. 要删除的结点只有右孩子结点<br> d. 要删除的结点有左、右孩子结点</strong></p> 
 <p><br><span style="color:#fe2c24;">看起来有待删除节点有4中情况，但是实际情况a可以与情况b或者c合并起来，因此真正的删</span></p> 
 <p><span style="color:#fe2c24;">除过程如下：</span><br>  </p> 
 <p>⭐<strong>情况b：删除该结点且使被删除节点的双亲结点指向被删除节点的左孩子结点--直接删除</strong><br> ⭐<strong>情况c：删除该结点且使被删除节点的双亲结点指向被删除结点的右孩子结点--直接删除</strong><br> ⭐<strong>情况d：在它的右子树中寻找中序下的第一个结点(关键码最小)，用它的值填补到被删除节点</strong><strong>中，再来处理该结点的删除问题--替换法删除</strong></p> 
</blockquote> 
<p><img alt="" height="423" src="https://images2.imgbox.com/46/75/IC9IfP47_o.png" width="1008"></p> 
<pre><code class="language-cpp">bool Erase(const K&amp; key)
{
	Node* parent = nullptr;
	Node* cur = _root;
	while (cur) {
		if (cur-&gt;_key &lt; key) {
			parent = cur;
			cur = cur-&gt;_right;
		}
		else if (cur-&gt;_key &gt; key) {
			parent = cur;
			cur = cur-&gt;_left;
		}
		else { //删除
			//子节点的左为空，0至1个孩子的情况
			if (cur-&gt;_left == nullptr) {
				if (parent == nullptr) _root = cur-&gt;_right;
				else{
					if (parent-&gt;_left == cur) parent-&gt;_left = cur-&gt;_right;

					else parent-&gt;_right = cur-&gt;_right;
				}
				//先判断该节点为父节点的左还是右
				if (parent-&gt;_left == cur)  parent-&gt;_left = cur-&gt;_right;
				else parent-&gt;_right = cur-&gt;_right;
				
				delete cur;
				return true;
			}
			//子节点的右为空
			else if (cur-&gt;_right == nullptr) {
				if (parent == nullptr) _root = cur-&gt;_left;
				else {
					if (parent-&gt;_left == cur) parent-&gt;_left = cur-&gt;_left;
					else parent-&gt;_right = cur-&gt;_left;
				}

				delete cur;
				return true;
			}
			else { //两个孩子的情况，找右子树的最小节点为替代节点
				Node* rightMinP = cur;
				Node* rightMin = cur-&gt;_right;
				while (rightMin-&gt;_left) {
					rightMinP = rightMin;
					rightMin = rightMin-&gt;_left;
				}
				cur-&gt;_key = rightMin-&gt;_key;
		
				if(rightMinP-&gt;_left == rightMin)  rightMinP-&gt;_left = rightMin-&gt;_right;
				else  rightMinP-&gt;_right = rightMin-&gt;_right;
				
				delete rightMin;
				return true;
			}
		}
	}
	return false;
}</code></pre> 
<p><span style="color:#fe2c24;">递归</span></p> 
<pre><code class="language-cpp">bool EraseR(Node*&amp; _root, const K&amp; key)
{
	if (_root == nullptr)
	{
		return false;
	}
	if (key &gt; _root-&gt;_key)
	{
		return _EraseR(_root-&gt;_right, key);
	}
	else if (key &lt; _root-&gt;_key)
	{
		return _EraseR(_root-&gt;_left, key);
	}
	else
	{
		// 删除
		if (_root-&gt;_left == nullptr)
		{
			Node* del = _root;
			_root = _root-&gt;_right;
			delete del;
			return true;
		}
		else if (_root-&gt;_right == nullptr)
		{
			Node* del = _root;
			_root = _root-&gt;_left;
			delete del;
			return true;
		}
		else
		{
			Node* subLeft = _root-&gt;_right;
			while (subLeft-&gt;_left)
			{
				subLeft = subLeft-&gt;_left;
			}
		swap(_root-&gt;_key, subLeft-&gt;_key);
		// 让子树继续递归下去
		return _EraseR(_root-&gt;_right, key);
		}
	}
}
</code></pre> 
<h5 id="%F0%9F%8C%88d.%20%E9%81%8D%E5%8E%86">🌈d. 遍历</h5> 
<blockquote> 
 <p><strong>在二叉搜索树的遍历上，我们依旧采用当初二叉树时的中序遍历，但是我们想要递归遍历就必须调用节点，这里我们要调用两层。</strong></p> 
</blockquote> 
<pre><code class="language-cpp">	void Inorder() //避免_root私有，无法提供的问题
	{
		_Inorder(_root);
	}
private:
	void _Inorder(Node* root)
	{
		if (root == nullptr) return; //递归截止
		_Inorder(root-&gt;_left);
		printf("%d ", root-&gt;_key);
		_Inorder(root-&gt;_right);
	}</code></pre> 
<h4 id="%F0%9F%A7%A94%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">🧩4、二叉搜索树默认成员函数</h4> 
<h5 id="%F0%9F%8E%89%E6%9E%84%E9%80%A0"><strong>🎉构造</strong></h5> 
<pre><code class="language-cpp">BSTree() = default; // 显式地定义默认构造函数  
</code></pre> 
<h5 id="%F0%9F%8E%89%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0"><strong>🎉拷贝构造</strong></h5> 
<pre><code class="language-cpp">BSTree(const BSTree&lt;K&gt;&amp; t)
{
	_root = Copy(t._root);
}
private:
	Node* Copy(Node* root)
	{
		if (root == nullptr)  return nullptr;
        //递归进行拷贝构造
		Node* newRoot = new Node(root-&gt;_key, root-&gt;_value);
		newRoot-&gt;_left = Copy(root-&gt;_left);
		newRoot-&gt;_right = Copy(root-&gt;_right);

		return newRoot;
	}</code></pre> 
<h5 id="%F0%9F%8E%89%E8%B5%8B%E5%80%BC%E9%87%8D%E8%BD%BD"><strong>🎉赋值重载</strong></h5> 
<pre><code class="language-cpp">BSTree&lt;K&gt;&amp; operator=(BSTree&lt;K&gt; t)
{
    // 现代写法-&gt; 直接调用swap
    swap(_root, t._root);
    return *this;
}
</code></pre> 
<h5 id="%F0%9F%8E%89%E6%9E%90%E6%9E%84"><strong>🎉析构</strong></h5> 
<pre><code class="language-cpp">~BSTree()
{
	Destory(_root);
}
private:
	void Destroy(Node* root)
    {
	    if (root == nullptr) return;
	    Destroy(root-&gt;_left);
	    Destroy(root-&gt;_right);
	    delete root;
    }</code></pre> 
<h3 id="4.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8">4. 二叉搜索树的应用</h3> 
<h4 id="%F0%9F%8D%811.%20K%E6%A8%A1%E5%9E%8B"><a name="t17"></a><a id="KV_497"></a>🍁1. K模型</h4> 
<blockquote> 
 <p><strong>K模型：即只有key作为关键码，结构中只需要存储Key即可，关键码即为需要搜索到的值，其实现如上所示。</strong><br> 比如：给一个数据库，判断该数据是否存在，具体方式如下：<br> 以该数据库中所有数据集合中的每个数据作为key，构建一棵二叉搜索树<br> 在二叉搜索树中检索该数据是否存在，存在则正确，不存在则错误。</p> 
</blockquote> 
<h5 id="%F0%9F%92%A7%E6%95%B0%E7%BB%84%E7%9A%84%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0"><strong>💧数组的排序实现</strong></h5> 
<p><strong>代码实现（示例）：</strong></p> 
<pre><code class="language-cpp">void test1()  //二叉排序树
{
	int a[] = { 8,3,1,10,6,4,7,14,13 };
	BSTree&lt;int&gt; t;
	for (auto e : a) 
	{
		t.Insert(e);
	}

	t.Insert(16);
	t.Insert(4);

	t.Inorder();
	cout &lt;&lt; endl;

	t.Erase(3);
	t.Inorder();
	cout &lt;&lt; endl;

	t.Erase(4);
	t.Inorder();
	cout &lt;&lt; endl;
}</code></pre> 
<h4 id="%F0%9F%8D%812.%C2%A0KV%E6%A8%A1%E5%9E%8B">🍁2. KV模型</h4> 
<blockquote> 
 <p><strong>KV模型：每一个关键码key，都有与之对应的值Value，即&lt;Key, Value&gt;的键值对。该种方式在现实生活中非常常见：</strong></p> 
 <ul><li>比如英汉词典就是英文与中文的对应关系，通过英文可以快速找到与其对应的中文，英<br> 文单词与其对应的中文&lt;word, chinese&gt;就构成一种键值对</li><li>再比如统计单词次数，统计成功后，给定单词就可快速找到其出现的次数，单词与其出<br> 现次数就是&lt;word, count&gt;就构成一种键值对</li></ul> 
</blockquote> 
<h4 id="%F0%9F%8D%813.%20KV%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0">🍁3. KV模型实现</h4> 
<blockquote> 
 <p>和上面二叉搜索树建立类似，<strong>在成员函数中，我们只需要在Insert中加入value元素即可，</strong></p> 
 <p><strong>如： BSTNode&lt;K&gt; Node 变成  BSTNode&lt;K, V&gt; Node ， </strong></p> 
 <p><strong>如new Node(key); 变成  new Node(key, value);  </strong></p> 
 <p><strong>还有就是find不再是返回bool值，而是返回的节点值</strong></p> 
 <pre><code class="language-cpp">Node* Find(const K&amp; key)
{
	Node* cur = _root;
	while (cur) {
		if (cur-&gt;_key &lt; key) {
			cur = cur-&gt;_right;
		}
		else if (cur-&gt;_key &gt; key) {
			cur = cur-&gt;_left;
		}
		else  return cur;
	}

	return nullptr;
}</code></pre> 
</blockquote> 
<pre><code class="language-cpp">namespace keyValue  // 避免与之前k模型冲突
{
	template&lt;class K, class V&gt;
	struct BSTreeNode
	{
		BSTreeNode&lt;K&gt;* _left;
		BSTreeNode&lt;K&gt;* _right;
		K _key;
		V _value;
		
		BSTreeNode(const K&amp; key = K(), const V&amp; value = V())
			: _left(nullptr)
			, _right(nullptr)
			, _key(key)
			, _value(value)
		{}
	};
	template&lt;class K, class V&gt;
	class BSTree
	{
		typedef BSTreeNode&lt;K, V&gt; Node;
	public:
		// 构造函数等可能的其他成员函数... 
		// 在成员函数中，我们只需要在insert中加入value元素即可
	private:
		Node* _root = nullptr;
	};
}
</code></pre> 
<h5 id="%F0%9F%92%A7%E8%8B%B1%E6%B1%89%E8%AF%8D%E5%85%B8%E7%9A%84%E6%9F%A5%E6%89%BE%E5%AE%9E%E7%8E%B0"><strong>💧英汉词典的查找实现</strong></h5> 
<p><strong>代码实现（示例）：</strong></p> 
<pre><code class="language-cpp">void test2()
{
	// 输入单词，查找单词对应的中文翻译
	keyValue::BSTree&lt;string, string&gt; dict;
	dict.Insert("string", "字符串");
	dict.Insert("tree", "树");
	dict.Insert("left", "左边、剩余");
	dict.Insert("right", "右边");
	dict.Insert("sort", "排序");
	// 插入词库中所有单词
	string str;
	while (cin &gt;&gt; str)
	{
		auto ret = dict.Find(str);
		if (ret == nullptr)
		{
			cout &lt;&lt; "单词拼写错误，词库中没有这个单词:" &lt;&lt; str &lt;&lt; endl;
		}
		else
		{
			cout &lt;&lt; str &lt;&lt; "中文翻译:" &lt;&lt; ret-&gt;_value &lt;&lt; endl;
		}
	}
}</code></pre> 
<h5 id="%F0%9F%92%A7%E8%AE%A1%E6%95%B0"><strong>💧</strong>计数</h5> 
<p><strong>代码实现（示例）：</strong></p> 
<pre><code class="language-cpp">void test3()
{
	// 统计水果出现的次数
	string arr[] = { "苹果", "西瓜", "苹果", "西瓜", "苹果", "苹果", "西瓜",
	"苹果", "香蕉", "苹果", "香蕉" };
	keyValue::BSTree&lt;string, int&gt; countTree;
	for (const auto&amp; str : arr)
	{
		// 先查找水果在不在搜索树中
		// 1、不在，说明水果第一次出现，则插入&lt;水果, 1&gt;
		// 2、在，则查找到的节点中水果对应的次数++
		//BSTreeNode&lt;string, int&gt;* ret = countTree.Find(str);
		auto ret = countTree.Find(str);
		if (ret == NULL)
		{
			countTree.Insert(str, 1);
		}
		else
		{
			ret-&gt;_value++;
		}
	}
	countTree.InOrder();
}</code></pre> 
<h3 id="5.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90">5.二叉搜索树的性能分析</h3> 
<p>       插入和删除操作都必须先查找，查找效率代表了二叉搜索树中各个操作的性能。<br>   对有n个结点的二叉搜索树，若每个元素查找的概率相等，则二叉搜索树平均查找长度是结点在二叉搜索树的<strong>深度的函数</strong>，即结点越深，则比较次数越多。<br>   但对于同一个关键码集合，如果各关键码插入的次序不同，可能得到不同结构的二叉搜索树：</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/4b/7c/7162KYXH_o.png" width="1200"></p> 
<p><strong>最优情况下</strong>，二叉搜索树为完全二叉树(或者接近完全二叉树)，其平均比较次数为：<img alt="\log N" class="mathcode" src="https://images2.imgbox.com/5f/be/etVmKZoC_o.png"><br> ​<br><strong>最差情况下</strong>，二叉搜索树退化为单支树(或者类似单支)，其平均比较次数为：<img alt="\frac{N}{2}" class="mathcode" src="https://images2.imgbox.com/e7/e6/9NIgLVFF_o.png"><br><br> ​</p> 
<hr> 
<h3 id="%F0%9F%8C%84%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B7%A9%E5%9B%BA%E7%9F%A5%E8%AF%86">🌄二叉树巩固知识</h3> 
<p><strong>最后在这给大家推荐几道巩固二叉树的编程题</strong></p> 
<p><a href="https://blog.csdn.net/island1314/article/details/140437449?spm=1001.2014.3001.5501" title="【题目/训练】二叉树的创建&amp;&amp;遍历（递归&amp;&amp;非递归）-CSDN博客">【题目/训练】二叉树的创建&amp;&amp;遍历（递归&amp;&amp;非递归）-CSDN博客</a></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/cb/65/xndelR2R_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dda10d7d5ce261a57fdc05b7083e28b5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java.io.IOException : Broken pipe 什么情况下会出现这个错误</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2ac5033aea5850786f118e2617a38e03/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">阿里开源语音大模型：SenseVoice 识别，语音识别效果和性能强于 Whisper，还能检测掌声、笑声、咳嗽等！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>