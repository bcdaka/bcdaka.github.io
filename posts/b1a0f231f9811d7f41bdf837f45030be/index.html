<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;】深入解析C/C&#43;&#43;内存管理：new与delete的使用及原理 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b1a0f231f9811d7f41bdf837f45030be/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;】深入解析C/C&#43;&#43;内存管理：new与delete的使用及原理">
  <meta property="og:description" content="C&#43;&#43;语法相关知识点可以通过点击以下链接进行学习一起加油！命名空间缺省参数与函数重载C&#43;&#43;相关特性类和对象-上篇类和对象-中篇类和对象-下篇日期类 本章将分享C&#43;&#43;为何放弃malloc/free系列，选择新系列new/delete去管理内存。深度探索new/delete的使用及其原理,malloc/free系列与new/delete系列的不同之处。
🌈个人主页：是店小二呀
🌈C语言笔记专栏：C语言笔记
🌈C&#43;&#43;笔记专栏： C&#43;&#43;笔记
🌈初阶数据结构笔记专栏： 初阶数据结构笔记
🌈Linux笔记专栏： Linux笔记
🌈喜欢的诗句:无人扶我青云志 我自踏雪至山巅 文章目录 一、C/C&#43;&#43;中程序内存区域划分1.1 相关练习测试 二、C语言中动态内存管理方式三、C&#43;&#43;内存管理方式3.1 使用new/delete进行数据操作3.1.1 new/delete 操作内置类型3.1.2 new和delete操作自定义类型 四、 new和delete原理及其两个全局函数的实现(operator new/operator delerte)五、深入了解new和delete工作原理六、malloc/free系列和new/delete系列的区别七、delete最好匹配使用八、定位new表达式(placement -new)(了解)九、内存泄漏（了解)9.1 内存泄漏概念9.2 内存泄漏的危害9.3 内存泄漏分类 一、C/C&#43;&#43;中程序内存区域划分 内存区域相关作用：
栈又叫堆栈:非静态局部变量、函数参数、返回值等等，栈是向下增长的
内存映射段时高效的I/O映射方式，用于装载一个共享的动态内存库，用户可以使用系统接口创建共享共享内存，做进程间通信
堆用于程序运行时动态内存分配，堆时可以上增长的
数据段:存储全局数据和静态数据
代码段:可执行的代码、只读常量
在语法上将数据段称为静态区、代码段称为常量区，而以上操作系统的命名。
提出相关思考:
为什么要分不同的区域哪个区域是我们需要重点关注的 回答:
根据对象不同的生命周期和作用域，分配到不同的区域中，统一管理，高效地对对象进行处理堆是我们要需要重点关注的，这是系统留给我们控制的内存，其他系统是自动的 1.1 相关练习测试 int globalVar = 1; static int staticGlobalVar = 1; void Test() { static int staticVar = 1; int localVar = 1; int num1[10] = { 1, 2, 3, 4 }; char char2[] = &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-22T10:02:37+08:00">
    <meta property="article:modified_time" content="2024-08-22T10:02:37+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】深入解析C/C&#43;&#43;内存管理：new与delete的使用及原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-kimbie-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/ad/5f/cxieddhE_o.gif" alt="在这里插入图片描述"></p> 
<table><thead><tr><th align="center">C++语法</th><th align="center">相关知识点</th><th align="center">可以通过点击</th><th align="center">以下链接进行学习</th><th align="center">一起加油！</th></tr></thead><tbody><tr><td align="center"><a href="https://blog.csdn.net/2302_79177254/article/details/140668996?spm=1001.2014.3001.5501">命名空间</a></td><td align="center"><a href="https://blog.csdn.net/2302_79177254/article/details/140676622?spm=1001.2014.3001.5501">缺省参数与函数重载</a></td><td align="center"><a href="https://blog.csdn.net/2302_79177254/article/details/140729961?spm=1001.2014.3001.5502">C++相关特性</a></td><td align="center"><a href="https://blog.csdn.net/2302_79177254/article/details/140731502?spm=1001.2014.3001.5501">类和对象-上篇</a></td><td align="center"><a href="https://blog.csdn.net/2302_79177254/article/details/140932152?spm=1001.2014.3001.5501">类和对象-中篇</a></td></tr><tr><td align="center"><a href="https://blog.csdn.net/2302_79177254/article/details/140966821?spm=1001.2014.3001.5501">类和对象-下篇</a></td><td align="center"><a href="https://blog.csdn.net/2302_79177254/article/details/141017550?spm=1001.2014.3001.5501">日期类</a></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table> 
<blockquote> 
 <p>本章将分享C++为何放弃malloc/free系列，选择新系列new/delete去管理内存。深度探索new/delete的使用及其原理,malloc/free系列与new/delete系列的不同之处。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/e2/65/0qW4DzMf_o.gif" alt="请添加图片描述" width="600" height="60"><br> <img src="https://images2.imgbox.com/47/cf/KNtQliKP_o.png" alt="Alt" width="200" height="200"><br> 🌈个人主页：<a href="https://blog.csdn.net/2302_79177254?type=blog">是店小二呀</a><br> 🌈C语言笔记专栏：<a href="https://blog.csdn.net/2302_79177254/category_12498683.html?spm=1001.2014.3001.5482">C语言笔记</a><br> 🌈C++笔记专栏： <a href="https://blog.csdn.net/2302_79177254/category_12596619.html">C++笔记</a><br> 🌈初阶数据结构笔记专栏： <a href="https://blog.csdn.net/2302_79177254/category_12596619.html">初阶数据结构笔记</a><br> 🌈Linux笔记专栏： <a href="https://blog.csdn.net/2302_79177254/category_12742437.html">Linux笔记</a></p> 
<p>🌈喜欢的诗句:无人扶我青云志 我自踏雪至山巅 <img src="https://images2.imgbox.com/62/11/e72H8k7H_o.gif" alt="请添加图片描述" width="600" height="60"><br> </p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#font_colorcornflowerblue_CCfont_22" rel="nofollow"><font color="cornflowerblue"> 一、C/C++中程序内存区域划分</font></a></li><li><ul><li><a href="#font_colorcornflowerblue11_font_51" rel="nofollow"><font color="cornflowerblue">1.1 相关练习测试</font></a></li></ul> 
  </li><li><a href="#font_colorcornflowerblueCfont_87" rel="nofollow"><font color="cornflowerblue">二、C语言中动态内存管理方式</font></a></li><li><a href="#font_colorcornflowerblueCfont_127" rel="nofollow"><font color="cornflowerblue">三、C++内存管理方式</font></a></li><li><ul><li><a href="#font_colorcornflowerblue31_newdeletefont_131" rel="nofollow"><font color="cornflowerblue">3.1 使用new/delete进行数据操作</font></a></li><li><ul><li><a href="#font_colorcornflowerblue311_newdelete_font_133" rel="nofollow"><font color="cornflowerblue">3.1.1 new/delete 操作内置类型</font></a></li><li><a href="#font_colorcornflowerblue312_newdeletefont_166" rel="nofollow"><font color="cornflowerblue">3.1.2 new和delete操作自定义类型</font></a></li></ul> 
  </li></ul> 
  </li><li><a href="#font_colorcornflowerblue_newdeleteoperator_newoperator_delertefont_301" rel="nofollow"><font color="cornflowerblue">四、 new和delete原理及其两个全局函数的实现(operator new/operator delerte)</font></a></li><li><a href="#font_colorcornflowerbluenewdeletefont_413" rel="nofollow"><font color="cornflowerblue">五、深入了解new和delete工作原理</font></a></li><li><a href="#font_colorcornflowerbluemallocfreenewdeletefont_452" rel="nofollow"><font color="cornflowerblue">六、malloc/free系列和new/delete系列的区别</font></a></li><li><a href="#font_colorcornflowerbluedeletefont_469" rel="nofollow"><font color="cornflowerblue">七、delete最好匹配使用</font></a></li><li><a href="#font_colorcornflowerbluenewplacement_newfont_478" rel="nofollow"><font color="cornflowerblue">八、定位new表达式(placement -new)(了解)</font></a></li><li><a href="#font_colorcornflowerbluefont_527" rel="nofollow"><font color="cornflowerblue">九、内存泄漏（了解)</font></a></li><li><ul><li><a href="#91__529" rel="nofollow">9.1 内存泄漏概念</a></li><li><a href="#92__533" rel="nofollow">9.2 内存泄漏的危害</a></li><li><a href="#93__537" rel="nofollow">9.3 内存泄漏分类</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="font_colorcornflowerblue_CCfont_22"></a><font color="cornflowerblue"> 一、C/C++中程序内存区域划分</font></h2> 
<p><img src="https://images2.imgbox.com/f8/ec/NFpIZQwF_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>内存区域相关作用：</p> 
 <ul><li> <p>栈又叫堆栈:非静态局部变量、函数参数、返回值等等，<strong>栈是向下增长的</strong></p> </li><li> <p>内存映射段时高效的I/O映射方式，用于装载一个共享的动态内存库，用户可以使用系统接口创建共享共享内存，做进程间通信</p> </li><li> <p>堆用于程序运行时动态内存分配，堆时可以上增长的</p> </li><li> <p>数据段:存储全局数据和静态数据</p> </li><li> <p>代码段:可执行的代码、只读常量</p> </li></ul> 
</blockquote> 
<p>在语法上将<strong>数据段称为静态区、代码段称为常量区</strong>，而以上操作系统的命名。</p> 
<blockquote> 
 <p>提出相关思考:</p> 
 <ol><li>为什么要分不同的区域</li><li>哪个区域是我们需要重点关注的</li></ol> 
 <p>回答:</p> 
 <ol><li><strong>根据对象不同的生命周期和作用域，分配到不同的区域中，统一管理，高效地对对象进行处理</strong></li><li>堆是我们要需要重点关注的，这是<strong>系统留给我们控制的内存，其他系统是自动的</strong></li></ol> 
</blockquote> 
<h3><a id="font_colorcornflowerblue11_font_51"></a><font color="cornflowerblue">1.1 相关练习测试</font></h3> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> globalVar <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> staticGlobalVar <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> staticVar <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> localVar <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> num1<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> char2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"abcd"</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> pChar3 <span class="token operator">=</span> <span class="token string">"abcd"</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">*</span> ptr1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">*</span> ptr2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">calloc</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">*</span> ptr3 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span>ptr2<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>ptr3<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/eb/3a/P8oScsLp_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>答案:</p> 
 <ul><li> <p>选择题:C、C、C、A、A 。A、A、A、D、A、B</p> </li><li> <p>填空题：40、5、4、4/8、4、4/8</p> </li></ul> 
</blockquote> 
<p>这里容易混洗的<code>char str1[] ="abcd"</code>与<code>const char* str2 ="abcd"</code>。这里<code>str1</code>是个数组将常量拷贝到数组，而<code>str2</code>是直接指向常量区中常量。</p> 
<p><img src="https://images2.imgbox.com/b5/8e/yRmNpoGE_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="font_colorcornflowerblueCfont_87"></a><font color="cornflowerblue">二、C语言中动态内存管理方式</font></h2> 
<blockquote> 
 <p>C语言中，系统通过一系列函数赋予了我们对堆上空间的控制</p> 
</blockquote> 
<pre><code class="prism language-CPP">void Test ()
{
int* p1 = (int*) malloc(sizeof(int));
free(p1);

int* p2 = (int*)calloc(4, sizeof (int));
int* p3 = (int*)realloc(p2, sizeof(int)*10);

free(p3 );
}
</code></pre> 
<blockquote> 
 <p>提出思考:</p> 
 <ol><li> <p>malloc/calloc/realloc的区别是什么？</p> </li><li> <p>这里使用realloc是否还需要free(p2)</p> </li><li> <p>malloc的实现原理?</p> </li></ol> 
</blockquote> 
<p><strong>第一个问题的回答</strong>:</p> 
<p>对于<code>malloc/calloc/realloc</code>是系统为我们提供在堆上申请空间的途径。在功能上大体是相同的，对于<code>malloc</code>与<code>calloc</code>这两个函数，除了参数部分及其是否完成初始化，其他功能是相同的。</p> 
<p><code>relloc</code>比较特别，属于扩容时使用的函数。扩容有两种方式：原地扩容和异地扩容。如果<code>realloc</code>第一个参数部分为空，可以当作<code>malloc</code>使用)。具体还是参考下这篇博客有详细解释内存管理</p> 
<p><strong>第二个问题的回答</strong>:</p> 
<p>由于<code>realloc</code>进行了扩容操作。如果是原地扩容，在原来开辟空间上完成扩容操作，这里p3会同p2指向这块空间，只需要<code>free(p3)</code>；如果是异地扩容，将p2空间中数据拷贝一份，在堆上找一块空间充足地方，完成扩容和拷贝操作，p2指向原空间，会被系统自动收回，不需要对p2进行free操作。对此无论是原地还是异地，只需要free(p3)即可</p> 
<p><strong>第三个问题的回答</strong>:</p> 
<p>可以通过该链接进行学习<a rel="nofollow">GLibc堆利用入门</a></p> 
<h2><a id="font_colorcornflowerblueCfont_127"></a><font color="cornflowerblue">三、C++内存管理方式</font></h2> 
<p>在C++中，虽然可以继续使用C语言对于内存管理方式，但是在<strong>有些地方就无能为力，而且使用起来比较麻烦</strong>。对此因此C++又提出了自己的内存管理方式:<strong>通过new和delete操作符进行动态内存管理</strong></p> 
<h3><a id="font_colorcornflowerblue31_newdeletefont_131"></a><font color="cornflowerblue">3.1 使用new/delete进行数据操作</font></h3> 
<h4><a id="font_colorcornflowerblue311_newdelete_font_133"></a><font color="cornflowerblue">3.1.1 new/delete 操作内置类型</font></h4> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//动态申请一个int类型的空间</span>
	<span class="token keyword">int</span><span class="token operator">*</span> ptr1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>

	<span class="token comment">//动态申请一个int类型的空间并且初始化为10</span>
	<span class="token keyword">int</span><span class="token operator">*</span> ptr2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//动态申请10个int类型的空间</span>
	<span class="token keyword">int</span><span class="token operator">*</span> ptr3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

	<span class="token comment">//动态申请10个int类型的空间并且完成初始化</span>
	<span class="token keyword">int</span><span class="token operator">*</span> ptr4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//剩下没有明确给值，默认为0</span>

	<span class="token keyword">delete</span> ptr1<span class="token punctuation">;</span>
	<span class="token keyword">delete</span> ptr2<span class="token punctuation">;</span>
	<span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>ptr3<span class="token punctuation">;</span>
	<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span>ptr4<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/3e/79/wKqPohBS_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>注意需要匹配使用new和delete操作符：</p> 
 <ul><li><strong>申请和释放单个元素的空间</strong>：new、delete</li><li><strong>申请和释放多个元素的空间</strong>：new[]、delete[]</li></ul> 
</blockquote> 
<h4><a id="font_colorcornflowerblue312_newdeletefont_166"></a><font color="cornflowerblue">3.1.2 new和delete操作自定义类型</font></h4> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_a</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A():"</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~A():"</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _a<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//自定义类型</span>
	A<span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token punctuation">(</span>A<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	A<span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">free</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">delete</span> p2<span class="token punctuation">;</span>

	<span class="token comment">//内置类型</span>
	<span class="token keyword">int</span><span class="token operator">*</span> p3 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">*</span> p4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>
	
	<span class="token function">free</span><span class="token punctuation">(</span>p3<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">delete</span> p4<span class="token punctuation">;</span>
	<span class="token comment">//开辟连续自定义类型空间</span>
	A<span class="token operator">*</span> p5 <span class="token operator">=</span> <span class="token punctuation">(</span>A<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	A<span class="token operator">*</span> p6 <span class="token operator">=</span> <span class="token keyword">new</span> A<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>p5<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p6<span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/ee/35/PzPL9zSe_o.png" alt="在这里插入图片描述"></p> 
<p><strong>从结果上来看，对于<code>new</code>与<code>malloc</code>最大差别在于对自定义类型除了开辟空间以外，还会调用构造函数和析构函数及其进行良好的初始化和控制。对于<code>malloc</code>而言无法对自定义类型进行好的初始化和控制，只负责开辟内存，除此之外内置类型几乎相同（初始化不同）</strong></p> 
<blockquote> 
 <p>对于new优于malloc的几点:</p> 
 <ol><li>用法上进行调正，更简洁好用</li><li>可以控制初始化</li><li>对于自定义类型，new可以开空间+构造函数</li><li><strong>new配合构造函数，可以更加便捷创建节点等</strong></li><li><strong>new失败了以后抛异常，不需要手动检查</strong></li></ol> 
</blockquote> 
<p><strong>第一点</strong>:</p> 
<pre><code class="prism language-cpp">	<span class="token keyword">int</span><span class="token operator">*</span> p0 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>第二点</strong>:</p> 
<pre><code class="prism language-cpp">	<span class="token keyword">int</span><span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">*</span> p3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">*</span> p4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">{<!-- --></span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>第三点</strong>：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">ListNode</span>
<span class="token punctuation">{<!-- --></span>
	ListNode<span class="token operator">*</span> _next<span class="token punctuation">;</span>
	<span class="token keyword">int</span> _val<span class="token punctuation">;</span>

	<span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">_val</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
		<span class="token punctuation">,</span><span class="token function">_next</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//创建不带哨兵位，同时如果是插入数据，new ListNode(3)即可</span>
ListNode<span class="token operator">*</span> <span class="token function">CreateList</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	ListNode <span class="token function">head</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	ListNode<span class="token operator">*</span> tail <span class="token operator">=</span> <span class="token operator">&amp;</span>head<span class="token punctuation">;</span>
	<span class="token keyword">int</span> val<span class="token punctuation">;</span>
	
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请依次输入%d个节点的值：&gt;"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cin <span class="token operator">&gt;&gt;</span> val<span class="token punctuation">;</span>
		tail<span class="token operator">-&gt;</span>_next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
		tail <span class="token operator">=</span> tail<span class="token operator">-&gt;</span>_next<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> head<span class="token punctuation">.</span>_next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>第四点</strong>:</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span>n<span class="token operator">&lt;&lt;</span><span class="token string">"-&gt;"</span><span class="token operator">&lt;&lt;</span> p <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token operator">++</span>n<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   
<span class="token punctuation">{<!-- --></span>
   <span class="token keyword">try</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">const</span> exception<span class="token operator">&amp;</span> e<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/3b/00/Ds4yxXtG_o.png" alt="在这里插入图片描述"></p> 
<p>这里try和catch就是捕捉异常，这一点到后面有涉及。以上种种都是new的优点，所以我们不推荐再使用<code>malloc/free</code>系列。</p> 
<h2><a id="font_colorcornflowerblue_newdeleteoperator_newoperator_delertefont_301"></a><font color="cornflowerblue">四、 new和delete原理及其两个全局函数的实现(operator new/operator delerte)</font></h2> 
<blockquote> 
 <p>new和delete是用户进行动态内存申请和释放的<strong>操作符</strong>，operator new和operator delete是系统提供的<strong>全局函数</strong>，new再底层调用operator new全局函数来申请空间，delete在底层通过operator delete全局函数来释放空间(operator new与operator delete不是对new和delete的重载)</p> 
</blockquote> 
<pre><code class="prism language-cpp">	<span class="token keyword">int</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//int* p1=new int(10*4)</span>
	<span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//delete(p1)</span>
</code></pre> 
<p>从代码中可以看出来，new/delete和operator new/operator delete效果上是相同的。<strong>那么直接使用new/delete就行，operator new/operator delete对于我们来说是没用的，但是有这个东西说明在系统中有它们的一席之地的。</strong></p> 
<pre><code class="prism language-Cpp">/*
operator new：该函数实际通过malloc来申请空间，当malloc申请空间成功时直接返回；申请空间
失败，尝试执行空 间不足应对措施，如果改应对措施用户设置了，则继续申请，否则抛异常。
*/
void *__CRTDECL operator new(size_t size) _THROW1(_STD bad_alloc)
{
    // try to allocate size bytes
    void *p;
    while ((p = malloc(size)) == 0)
    //通过上述两个全局函数的实现知道，operator new 实际也是通过malloc来申请空间，如果
    //malloc申请空间成功就直接返回，否则执行用户提供的空间不足应对措施，如果用户提供该措施
    //就继续申请，否则就抛异常。operator delete 最终是通过free来释放空间的。
    if (_callnewh(size) == 0)
    {
    // report no memory
    // 如果申请内存失败了，这里会抛出bad_alloc 类型异常
    static const std::bad_alloc nomem;
    _RAISE(nomem);
    }
    return (p);
}
/*
operator delete: 该函数最终是通过free来释放空间的
*/
void operator delete(void *pUserData)
{
_CrtMemBlockHeader * pHead;
    RTCCALLBACK(_RTC_Free_hook, (pUserData, 0));
    if (pUserData == NULL)
    return;
    _mlock(_HEAP_LOCK); /* block other threads */
    __TRY
    /* get a pointer to memory block header */
    pHead = pHdr(pUserData);
    /* verify block type */
    _ASSERTE(_BLOCK_TYPE_IS_VALID(pHead-&gt;nBlockUse));
    _free_dbg( pUserData, pHead-&gt;nBlockUse );
    __FINALLY
    _munlock(_HEAP_LOCK); /* release other threads */
    __END_TRY_FINALLY
    return;
}
/*
free的实现
*/
#define free(p) _free_dbg(p, _NORMAL_BLOCK)
</code></pre> 
<p>可以通过上述两个全局函数的实现，可以知道，<strong>operator new实际是通过malloc来申请空间</strong>，如果malloc申请空间成功就直接返回，否则执行用户提供的空间不足应对措施；如果用户提供该措施就继续申请，否则就抛异常。<strong>operator delete最终是通过free来释放空间的。</strong></p> 
<p><strong>内置类型</strong>:</p> 
<p>如果申请的是内置类型的空间，new/malloc与delete/free基本类似，不同的地方是new在申请空间失败时会抛异常，malloc会返回NULL</p> 
<p><strong>自定义类型</strong>:</p> 
<blockquote> 
 <p><strong>new的原理</strong>:</p> 
 <ol><li>调用operator new函数申请空间</li><li>在申请的空间上执行构造函数，完成对象的构造</li></ol> 
 <p><strong>delete的原理</strong>:</p> 
 <ol><li>在空间上执行析构函数，完成对象中资源的清理工作</li><li>调用operator delete含函数释放对象的空间</li></ol> 
 <p><strong>new T[N]的原理</strong>:</p> 
 <ol><li>调用operator new[]函数，在operator new[]中实际调用operator new函数完成N个对象空间的申请</li><li>在申请的空间上执行N次构造函数</li></ol> 
 <p><strong>delete[]的原理</strong>:</p> 
 <ol><li>在释放的对象空间上执行N次析构函数，完成N个对象中资源的清理</li><li>调用operator delete[]释放空间，实际在operator delete[]中调用operator delete来释放空间</li></ol> 
</blockquote> 
<p>通过汇编，深入立即其中</p> 
<p><img src="https://images2.imgbox.com/db/44/XtfIGnPS_o.png" alt="在这里插入图片描述"></p> 
<p><strong>对于自定义类型转换指令只有两个核心动作调用全局函数及其构造或析构，而内置类型只有调用全局函数。</strong></p> 
<blockquote> 
 <p>对此可得:</p> 
 <ul><li>operator new是对malloc的封装，如果失败抛异常，实现new</li><li>operator newp[]封装operator new，最终还是malloc</li><li>operator delete对free的封装</li><li>operator delete[]封装operator delete</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/bc/97/2C6jlPD2_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/5d/73/P4c33i6b_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>同时这里需要注意调用顺序上的问题</p> 
</blockquote> 
<h2><a id="font_colorcornflowerbluenewdeletefont_413"></a><font color="cornflowerblue">五、深入了解new和delete工作原理</font></h2> 
<p>new是个操作符，在编译时new A会转化为汇编指令调用malloc，一般来说malloc失败会返回空，由于C++是面向对象的过程，malloc失败返回空是不太合适，一般采用抛异常。<strong>全局函数operator new来封装malloc，去调正失败的返回情况</strong>。</p> 
<p><img src="https://images2.imgbox.com/e1/20/oeDwMOI3_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	A<span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> A<span class="token punctuation">;</span><span class="token comment">//operator new+1次构造</span>
	A<span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> A<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//operatorn new[]+10构造</span>
	<span class="token keyword">int</span><span class="token operator">*</span> p3<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//operator new[](占用40个字节)</span>
    
	<span class="token keyword">delete</span> p1<span class="token punctuation">;</span><span class="token comment">//1次析构+operator delete</span>
	<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p2<span class="token punctuation">;</span><span class="token comment">//？次析构+operator delete</span>
    <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p3<span class="token punctuation">;</span><span class="token comment">//operator delete</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>结合汇编和代码提供的信息，提出以下问题:</p> 
 <ol><li>编译器如何开始确定所需开辟空间大小</li><li>为什么p2指向大小为44字节空间，而不是40字节空间</li><li>为什么编译器知道p2需要调用10次析构函数</li></ol> 
</blockquote> 
<blockquote> 
 <p><strong>回答</strong>:</p> 
 <ol><li><strong>由于new属于操作符，在编译时就计算出了所需空间的大小。</strong></li><li>编译器在所开辟空间位置前面，也是调用operator new函数多开四个字节，用于记录对象个数(针对自定义类型)</li><li>由于内置类型不需要调用析构函数，对此不需要记录对象个数，而自定义类型需要记录对象个数。<strong>delete[]需要通过对象个数才知道调用多少次析构函数</strong>。如果将析构函数注释，p2占用空间为40字节。由于编译器会自动生成析构函数，而该析构函数没有发挥占用，编译器会优化导致不需要四个字节记录对象个数，具体需要看编译器是否优化</li></ol> 
</blockquote> 
<h2><a id="font_colorcornflowerbluemallocfreenewdeletefont_452"></a><font color="cornflowerblue">六、malloc/free系列和new/delete系列的区别</font></h2> 
<blockquote> 
 <p>我们将通过用法和底层特性两点说明：</p> 
 <p>共同点:</p> 
 <ul><li>都是从堆上申请空间，并且需要用户手动释放</li></ul> 
 <p>不同点:</p> 
 <ul><li>malloc和free属于函数，new和delete属于操作符</li><li>malloc申请的空间不会初始化，new可以初始化</li><li>malloc申请空间时，需要手动计算空间并且传递，new只需在其后跟上空间的类型即可，如果是多个对象，[]中指定对象个数即可</li><li>malloc的返回值为void*，在使用事必须强转，new不需要，因为new后跟的是空间的类型</li><li>malloc申请空间失败时，返回的是NULL，因此使用时必须判空，new不需要的，但是new需要捕获异常</li><li>申请自定义类型对象时，malloc/free只会开辟空间，不会调用构造函数与析构函数，而new在申请空间后会调用构造函数完成对象的初始化，delete在释放空间前会调用析构函数完成空间中资源的清理</li></ul> 
</blockquote> 
<h2><a id="font_colorcornflowerbluedeletefont_469"></a><font color="cornflowerblue">七、delete最好匹配使用</font></h2> 
<p><img src="https://images2.imgbox.com/d9/77/6rqldp3h_o.png" alt="在这里插入图片描述"></p> 
<p><strong>解析说明</strong>:图中delete没有匹配使用，导致可能报错。这里p2指向并不是申请空间的第一个位置，第一个位置是operator new[]实现存放对象个数申请的空间。由于空间是不能一块块释放，对此p2释放的位置是错误的，并且不明确需要调用多少次析构函数，可能会造成内存泄漏。如果是delete[] p2，会将p2指针偏移前面四个字节。</p> 
<p>但是以上种种情况，导致这个问题是否报错，具体需要看编译器是否进行优化(编译器是否调用析构函数)，<strong>对此我们只需要正确的使用delete就行，上面只是了解就行了</strong></p> 
<h2><a id="font_colorcornflowerbluenewplacement_newfont_478"></a><font color="cornflowerblue">八、定位new表达式(placement -new)(了解)</font></h2> 
<p><strong>定位new表达式时在已分配的原始内存空间中调用构造函数初始化一个对象。</strong></p> 
<blockquote> 
 <p>new(指针-&gt;空间)类型() ：<strong>显式调用构造函数对已经有的空间初始化</strong></p> 
 <p>构造函数不能显式调用，析构可以显式调用（一般不会去调用两次析构的)</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token operator">:</span> <span class="token function">_a</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A():"</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~A():"</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> _a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token operator">/</span> 定位<span class="token keyword">new</span><span class="token operator">/</span>replacement <span class="token keyword">new</span>
    <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// p1现在指向的只不过是与A对象相同大小的一段空间，还不能算是一个对象，因为构造函数没</span>
    有执行
        A<span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token punctuation">(</span>A<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">new</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span>A<span class="token punctuation">;</span> <span class="token comment">// 注意：如果A类的构造函数有参数时，此处需要传参</span>
    p1<span class="token operator">-&gt;</span><span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    A<span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token punctuation">(</span>A<span class="token operator">*</span><span class="token punctuation">)</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">new</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    p2<span class="token operator">-&gt;</span><span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>一般没有人会使用，因为这里就是把new分成两部分，那么干嘛不直接使用new更加方便。</p> 
<p><strong>使用场景</strong>:定位new表达式在实际中，一般是配合内存池使用。<strong>因为内存池分配出的内存没有初始化</strong>。如果是自定义类型的对象，需要使用new的定义表达式进行显式调构造函数进行初始化。</p> 
<blockquote> 
 <p>C++基本放弃了malloc/free系列。关于realloc扩容解决措施，在C++相关容器中它们会自动处理内存的扩容，使得开发者可以更加方便地使用动态大小的数据集合。</p> 
</blockquote> 
<h2><a id="font_colorcornflowerbluefont_527"></a><font color="cornflowerblue">九、内存泄漏（了解)</font></h2> 
<h3><a id="91__529"></a>9.1 内存泄漏概念</h3> 
<p>内存泄漏指因为疏忽或者错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并不是指内存在物理上的消失，而是应用程序分配某段内存后，因为设计错误，失去了对该段内存的控制，因而造成了内存的浪费</p> 
<h3><a id="92__533"></a>9.2 内存泄漏的危害</h3> 
<p>长期运行的程序出现内存泄漏，影响很大，如操作系统、后台服务等等，出现内存泄漏会导致响应越来越慢，最终卡死。</p> 
<h3><a id="93__537"></a>9.3 内存泄漏分类</h3> 
<p>C/C++程序中一般我们关心两种方面的内存泄漏</p> 
<p>1.<strong>堆内存泄漏</strong>(Heap leak)</p> 
<p>堆内存指的是程序执行种依据须要分配通过malloc/calloc/realloc/new等从堆中分配的一块内存，用完后必须通过调用相应的free或者delete删除。假设程序的设计错误导致这部分内存没有被释放，那么以后这部分空间将无法再被使用，就会产生Heap Leak。</p> 
<p>2.<strong>系统资源泄漏</strong></p> 
<p>指程序使用系统分配的资源,比方套接字，文件描述符，管道等没有使用对应的函数释放掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定。</p> 
<hr> 
<p><strong><font color="cornflowerblue">以上就是本篇文章的所有内容，在此感谢大家的观看！这里是店小二呀C++笔记，希望对你在学习C++语言旅途中有所帮助！</font></strong><br> <img src="https://images2.imgbox.com/33/ab/SxUJNrFJ_o.gif" alt="请添加图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8402139697770f656184a16afef0c88e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">系统架构设计师 - 软件工程(3)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a97c87e42a0b2352e0be6f65a9a999c6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Springcloud从零开始--Eureka（一）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>