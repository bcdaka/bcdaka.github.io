<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring AOP（2）原理(代理模式和源码解析) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/cb6b807dfef4ba0ad7edc7fc1df9805a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Spring AOP（2）原理(代理模式和源码解析)">
  <meta property="og:description" content="目录
一、代理模式
二、静态代理
三、动态代理
1、JDK动态代理
（1）JDK动态代理实现步骤
（2）定义JDK动态代理类
（3）代码简单讲解
2、CGLIB动态代理
（1）CGLIB 动态代理类实现步骤
（2）添加依赖
（3）自定义MethodInterceptor（方法拦截器）
（4）创建代理类，并使用
（5）代码简单讲解
四、Spring AOP 源码剖析（了解）
五、常见面试题
1、什么是 AOP？
2、Spring AOP的实现方式有哪些？
3、Spring AOP 的实现原理？
4、Spring 使用的是哪种代理方式？
5、JDK 和 CGLIB 的区别？
六、总结
上篇文章学习了 Spring AOP 的应用，接下来我们来学习 Spring AOP 的原理，也就是 Spring 是如何实现 AOP 的。
Spring AOP 是基于动态代理来实现 AOP 的，咱门学习内容主要分以下两部分：
1、代理模式
2、Spring AOP 源码 剖析
一、代理模式 代理模式，也叫 委托模式。
定义：为其他对象提供一种代理以控制这个对象的访问。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用。
某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介作用。
使用代理前：
使用代理后：
生活中的代理：
艺人经纪人：广告商找艺人拍广告，需要经过经纪人，由经纪人来和艺人沟通。
房屋中介：房屋进行租赁时，卖方会把房屋授权给中介，由中介来代理看房，房屋咨询等服务。
经销商：厂商不直接对外销售产品，由经销商负责代理销售。
秘书/助理：合作伙伴找老板谈合作，需要先经过秘书/助理预约。
代理模式的主要角色：
1、Subject：业务接口类。可以是抽象类或者接口（不一定有）。
2、RealSubject：业务实现类。具体的业务执行，也就是被代理对象。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-22T12:30:49+08:00">
    <meta property="article:modified_time" content="2024-07-22T12:30:49+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring AOP（2）原理(代理模式和源码解析)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F" rel="nofollow">一、代理模式</a></p> 
<p id="%E4%BA%8C%E3%80%81%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86" rel="nofollow">二、静态代理</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86" rel="nofollow">三、动态代理</a></p> 
<p id="1%E3%80%81JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-toc" style="margin-left:40px;"><a href="#1%E3%80%81JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86" rel="nofollow">1、JDK动态代理</a></p> 
<p id="%EF%BC%881%EF%BC%89JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4" rel="nofollow">（1）JDK动态代理实现步骤</a></p> 
<p id="%EF%BC%882%EF%BC%89%E5%AE%9A%E4%B9%89JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E5%AE%9A%E4%B9%89JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB" rel="nofollow">（2）定义JDK动态代理类</a></p> 
<p id="%EF%BC%883%EF%BC%89%E4%BB%A3%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B2%E8%A7%A3-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89%E4%BB%A3%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B2%E8%A7%A3" rel="nofollow">（3）代码简单讲解</a></p> 
<p id="2%E3%80%81CGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-toc" style="margin-left:40px;"><a href="#2%E3%80%81CGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86" rel="nofollow">2、CGLIB动态代理</a></p> 
<p id="%EF%BC%881%EF%BC%89CGLIB%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89CGLIB%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4" rel="nofollow">（1）CGLIB 动态代理类实现步骤</a></p> 
<p id="%EF%BC%882%EF%BC%89%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96" rel="nofollow">（2）添加依赖</a></p> 
<p id="%EF%BC%883%EF%BC%89%E8%87%AA%E5%AE%9A%E4%B9%89MethodInterceptor%EF%BC%88%E6%96%B9%E6%B3%95%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%89-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89%E8%87%AA%E5%AE%9A%E4%B9%89MethodInterceptor%EF%BC%88%E6%96%B9%E6%B3%95%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%89" rel="nofollow">（3）自定义MethodInterceptor（方法拦截器）</a></p> 
<p id="%EF%BC%884%EF%BC%89%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E7%B1%BB%EF%BC%8C%E5%B9%B6%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#%EF%BC%884%EF%BC%89%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E7%B1%BB%EF%BC%8C%E5%B9%B6%E4%BD%BF%E7%94%A8" rel="nofollow">（4）创建代理类，并使用</a></p> 
<p id="%EF%BC%885%EF%BC%89%E4%BB%A3%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B2%E8%A7%A3-toc" style="margin-left:80px;"><a href="#%EF%BC%885%EF%BC%89%E4%BB%A3%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B2%E8%A7%A3" rel="nofollow">（5）代码简单讲解</a></p> 
<p id="%E5%9B%9B%E3%80%81Spring%20AOP%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81Spring%20AOP%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89" rel="nofollow">四、Spring AOP 源码剖析（了解）</a></p> 
<p id="%E4%BA%94%E3%80%81%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98" rel="nofollow">五、常见面试题</a></p> 
<p id="1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%20AOP%EF%BC%9F-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%20AOP%EF%BC%9F" rel="nofollow">1、什么是 AOP？</a></p> 
<p id="2%E3%80%81Spring%20AOP%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-toc" style="margin-left:40px;"><a href="#2%E3%80%81Spring%20AOP%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F" rel="nofollow">2、Spring AOP的实现方式有哪些？</a></p> 
<p id="3%E3%80%81Spring%20AOP%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F-toc" style="margin-left:40px;"><a href="#3%E3%80%81Spring%20AOP%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F" rel="nofollow">3、Spring AOP 的实现原理？</a></p> 
<p id="4%E3%80%81Spring%20%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AF%E5%93%AA%E7%A7%8D%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%9F-toc" style="margin-left:40px;"><a href="#4%E3%80%81Spring%20%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AF%E5%93%AA%E7%A7%8D%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%9F" rel="nofollow">4、Spring 使用的是哪种代理方式？</a></p> 
<p id="5%E3%80%81JDK%20%E5%92%8C%20CGLIB%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:40px;"><a href="#5%E3%80%81JDK%20%E5%92%8C%20CGLIB%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">5、JDK 和 CGLIB 的区别？</a></p> 
<p id="%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93" rel="nofollow">六、总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p>        上篇文章学习了 Spring AOP 的应用，接下来我们来学习 Spring AOP 的原理，也就是 Spring 是如何实现 AOP 的。</p> 
<p>        Spring AOP 是基于动态代理来实现 AOP 的，咱门学习内容主要分以下两部分：</p> 
<blockquote> 
 <p>1、代理模式</p> 
 <p>2、Spring AOP 源码 剖析</p> 
</blockquote> 
<hr> 
<h2 id="%E4%B8%80%E3%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F">一、代理模式</h2> 
<p>        代理模式，也叫 委托模式。</p> 
<blockquote> 
 <p><strong>定义</strong>：<span style="color:#956fe7;"><strong>为其他对象提供一种代理以控制这个对象的访问</strong></span>。<span style="background-color:#a2e043;">它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用</span>。</p> 
 <p>       某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介作用。</p> 
</blockquote> 
<p>        使用代理前：</p> 
<p><img alt="" height="232" src="https://images2.imgbox.com/71/c5/yEzCwyZ2_o.png" width="744"></p> 
<p>        使用代理后：</p> 
<p>        <img alt="" height="316" src="https://images2.imgbox.com/58/e5/WVDsd7U2_o.png" width="488"></p> 
<p>        生活中的代理：</p> 
<blockquote> 
 <p>艺人经纪人：广告商找艺人拍广告，需要经过经纪人，由经纪人来和艺人沟通。</p> 
 <p>房屋中介：房屋进行租赁时，卖方会把房屋授权给中介，由中介来代理看房，房屋咨询等服务。</p> 
 <p>经销商：厂商不直接对外销售产品，由经销商负责代理销售。</p> 
 <p>秘书/助理：合作伙伴找老板谈合作，需要先经过秘书/助理预约。</p> 
</blockquote> 
<p>        代理模式的主要角色：</p> 
<blockquote> 
 <p><strong>1、Subject</strong>：<span style="background-color:#a2e043;">业务接口类。可以是抽象类或者接口（不一定有）</span>。</p> 
 <p><strong>2、RealSubject</strong>：<span style="background-color:#a2e043;">业务实现类。具体的业务执行，也就是被代理对象</span>。</p> 
 <p><strong>3、Proxy</strong>：<span style="background-color:#a2e043;">代理类。RealSubject的代理</span>。</p> 
 <p></p> 
 <p>比如 房屋出租：</p> 
 <p>        Subject：就是提前定义了房东做的事情，交给中介代理，也是中介要做的事情。</p> 
 <p>        RealSubject：房东。</p> 
 <p>        Proxy：中介。</p> 
</blockquote> 
<p>        UML类图如下：</p> 
<p>        <img alt="" height="253" src="https://images2.imgbox.com/df/22/rOlWhKWc_o.png" width="445"></p> 
<p>        <span style="background-color:#ffd900;"><strong>代理模式可以在不修改被代理对象的基础上，通过扩展代理类</strong>，进行一些功能的附加与增强</span>。<span style="background-color:#a2e043;">根据代理的创建时期，代理模式分为静态代理和动态代理</span>。</p> 
<p>        <strong>静态代理</strong>：<span style="background-color:#38d8f0;">由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了</span>。</p> 
<p>        <strong>动态代理</strong>：<span style="background-color:#38d8f0;">在程序运行时，运用反射机制动态创建而成</span>。</p> 
<hr> 
<h2 id="%E4%BA%8C%E3%80%81%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86">二、静态代理</h2> 
<p>        静态代理：在程序运行前，代理类的 .class文件 就已经存在了。（在出租房子之前，中介已经做好了相关的工作，就等租户来租房子了）。</p> 
<p>        我们通过代码来加深理解。以房租租赁为例：</p> 
<p><strong>1、定义接口（定义房东要做的事情，也是中介需要做的事情）</strong>：</p> 
<pre><code class="language-java">public interface HouseSubject {
    void rentHouse();
}</code></pre> 
<p><strong>2、实现接口（房东出租房子）</strong>：</p> 
<pre><code class="language-java">public class RealHouseSubject implements HouseSubject{
    @Override
    public void rentHouse() {
        System.out.println("我是房东, 我出租房子");
    }
}</code></pre> 
<p><strong>3、代理（中介，帮房东出租房子）</strong>：</p> 
<pre><code class="language-java">public class HouseProxy implements HouseSubject{
    private HouseSubject target;

    public HouseProxy(HouseSubject target) {
        this.target = target;
    }

    @Override
    public void rentHouse() {
        //代理前
        System.out.println("我是中介, 开始代理");
        //出租房子
        target.rentHouse();;
        //代理后
        System.out.println("我是中介, 结束代理");
    }
}</code></pre> 
<p><strong>4、使用</strong>：</p> 
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        HouseSubject subject = new RealHouseSubject();
        //创建代理类
        HouseProxy houseProxy = new HouseProxy(subject);
        //通过代理类访问⽬标⽅法
        houseProxy.rentHouse();
    }
}</code></pre> 
<p>        运行结果：</p> 
<p><img alt="" height="130" src="https://images2.imgbox.com/13/dc/0Q57hWqx_o.png" width="445"></p> 
<p>        上面这个代理实现方式就是静态代理（仿佛啥也没干）。从上述程序可以看出，虽然静态代理也完成了对目标对象的代理，但是由于代码都写死了，对目标对象的每个方法的增强都是手动完成的，非常不灵活。所以日常开发几乎看不到静态代理的场景。</p> 
<p>        接下来新增需求：中介又新增了其他业务：代理房屋出售。我们就需要对上述代码进行修改。</p> 
<p><strong>1、接口定义修改：</strong></p> 
<pre><code class="language-java">public interface HouseSubject {
    void rentHouse();
    void saleHouse();
}</code></pre> 
<p><strong>2、接口实现修改</strong>：</p> 
<pre><code class="language-java">public class RealHouseSubject implements HouseSubject{
    @Override
    public void rentHouse() {
        System.out.println("我是房东, 我出租房子");
    }

    @Override
    public void saleHouse() {
        System.out.println("我是房东, 我出售房子");
    }
}</code></pre> 
<p><strong>3、代理类修改</strong>：</p> 
<pre><code class="language-java">public class HouseProxy implements HouseSubject{
    private HouseSubject target;

    public HouseProxy(HouseSubject target) {
        this.target = target;
    }

    @Override
    public void rentHouse() {
        //代理前
        System.out.println("我是中介, 开始代理");
        //出租房子
        target.rentHouse();;
        //代理后
        System.out.println("我是中介, 结束代理");
    }

    @Override
    public void saleHouse() {
        //代理前
        System.out.println("我是中介, 开始代理");
        //出租房子
        target.rentHouse();;
        //代理后
        System.out.println("我是中介, 结束代理");
    }
}</code></pre> 
<p><strong>4、使用</strong>：</p> 
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        HouseSubject subject = new RealHouseSubject();
        //创建代理类
        HouseProxy houseProxy = new HouseProxy(subject);
        //通过代理类访问⽬标⽅法
        houseProxy.rentHouse();
        System.out.println("=========");
        houseProxy.saleHouse();
    }
}</code></pre> 
<p>        运行结果：</p> 
<p><img alt="" height="224" src="https://images2.imgbox.com/ae/08/6i4kLupn_o.png" width="411"></p> 
<p>        从上述代码可以看出，<span style="background-color:#a2e043;">我们修改接口（Subject）和业务实现类（RealSubject），还需要修改代理类（Proxy）</span>。</p> 
<p>        同样的，<span style="background-color:#a2e043;">如果新增接口（Subject）和业务实现类（RealSubject），也需要对每一个业务实现类新增代理类（Proxy）</span>。</p> 
<p>        既然代理的流程是一样的，有没有一种办法，让他们通过一个代理类来实现呢？这就需要用到动态代理技术了。</p> 
<hr> 
<h2 id="%E4%B8%89%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">三、动态代理</h2> 
<p>        相比于静态代理来说，动态代理更加灵活。<strong><span style="color:#956fe7;">我们不需要针对每个目标对象都单独创建一个代理对象，而是把这个创建代理对象的工作推迟到程序运行时由JVM来实现</span></strong>。<span style="background-color:#a2e043;">也就是说动态代理在程序运行时，根据需要动态创建生成</span>。</p> 
<p>        比如房屋中介，我不需要提前预测都有哪些业务，而是业务来了我再根据情况创建。</p> 
<p>        先看代码再来理解。Java也对动态代理进行了实现，并给我们提供一些API，常见的实现方式有两种：</p> 
<p>        <strong>1、JDK动态代理</strong></p> 
<p>        <strong>2、CGLIB动态代理</strong></p> 
<blockquote> 
 <p>动态代理在我们日常开发中使用的相对较少，但是在框架中几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。</p> 
</blockquote> 
<h3 id="1%E3%80%81JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">1、JDK动态代理</h3> 
<h4 id="%EF%BC%881%EF%BC%89JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4">（1）JDK动态代理实现步骤</h4> 
<blockquote> 
 <p>1、<span style="background-color:#a2e043;">定义一个接口及其实现类（静态代理中的 HouseSubject 和 RealHouseSubject）</span>。</p> 
 <p>2、<span style="background-color:#a2e043;">自定义 InvocationHandler 并重写 invoke 方法，在 invoke 方法中我们会调用目标方法（被代理类的方法），并自定义一些处理逻辑</span>。</p> 
 <p>3、<span style="background-color:#a2e043;">通过 Proxy.newProxyInstance（ClassLoader, Class&lt;?&gt;[ ]  Interfaces, InvocationHandler  h）方法创建代理对象</span>。</p> 
</blockquote> 
<h4 id="%EF%BC%882%EF%BC%89%E5%AE%9A%E4%B9%89JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB" style="background-color:transparent;">（2）定义JDK动态代理类</h4> 
<p>        创建 JDKInvocationHandler类 实现 InvocationHandler 接口：</p> 
<pre><code class="language-java">public class JDKInvocationHandler implements InvocationHandler {
    //目标对象，即被代理的对象
    private Object target;

    public JDKInvocationHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //代理增强内容
        System.out.println("我是中介，开始代理");
        //通过反射调用被代理类的方法
        Object result = method.invoke(target, args);
        //代理增强内容
        System.out.println("我是中介，结束代理");
        return result;
    }
}
</code></pre> 
<p>        创建一个代理对象并使用：</p> 
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        /**
         * JDK动态代理
         */

        //创建⼀个代理类：通过被代理类、被代理实现的接⼝、⽅法调⽤处理器来创建
        RealHouseSubject target = new RealHouseSubject();//目标对象
        /**
         * newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)
         * loader：加载我们的被代理类的ClassLoad
         * interfaces：要实现的接口
         * h：代理要做的事情，需要实现 InvocationHandler 这个接口
         */
        HouseSubject proxy = (HouseSubject) Proxy.newProxyInstance(
                target.getClass().getClassLoader(),
                new Class[]{HouseSubject.class},
                new JDKInvocationHandler(target)
        );
        proxy.rentHouse();
        System.out.println("==============");
        proxy.saleHouse();
    }
}</code></pre> 
<p>        运行程序，结果如下：</p> 
<p><img alt="" height="224" src="https://images2.imgbox.com/9c/c4/WeKO4Kju_o.png" width="433"></p> 
<p>        假设代理的是类，而不是对象，代码如下：</p> 
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        RealHouseSubject target = new RealHouseSubject();
        RealHouseSubject proxy = (RealHouseSubject) Proxy.newProxyInstance(
                target.getClass().getClassLoader(),
                new Class[]{RealHouseSubject.class},
                new JDKInvocationHandler(target)
        );
        proxy.rentHouse();
        System.out.println("==============");
        proxy.saleHouse();
    }
}</code></pre> 
<p>        运行程序，结果如下：（报错了）</p> 
<p><img alt="" height="222" src="https://images2.imgbox.com/8e/2c/mPAsItoE_o.png" width="1200"></p> 
<p>        <strong>报错原因</strong>：<span style="background-color:#38d8f0;">RealHouseSubject is not an interface（RealHouseSubject 类不是接口）</span>，<span style="color:#fe2c24;"><strong>说明JDK 动态代理只能代理接口，不能代理类</strong></span>，不然会报错。</p> 
<h4 id="%EF%BC%883%EF%BC%89%E4%BB%A3%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B2%E8%A7%A3" style="background-color:transparent;">（3）代码简单讲解</h4> 
<p>        主要是学习API的使用，我们按照 Java API 的规范来使用即可。</p> 
<p><strong>1、InvocationHandler：</strong></p> 
<p>        InvocationHandler 接口是 Java 动态代理的关键接口之一，它定义了一个单一方法 invoke()，用于处理被代理对象的方法调用。</p> 
<pre><code class="language-java">    public interface InvocationHandler {
        /**
         * 参数说明
         * proxy：被代理对象
         * method：被代理对象需要实现的⽅法，即其中需要重写的⽅法
         * args：method所对应⽅法的参数
         */
        public Object invoke(Object proxy, Method method, Object[] args)
                throws Throwable;
    }</code></pre> 
<p>        通过实现 InvocationHandler 接口，可以对被代理对象的方法进行功能增强。</p> 
<p><strong>2、Proxy：</strong></p> 
<p>        Proxy 类中使用频率最高的方法：newProxyInstance()，这个方法主要用来生成一个代理对象。</p> 
<pre><code class="language-java">    public static Object newProxyInstance(ClassLoader loader,
                                          Class&lt;?&gt;[] interfaces,
                                          InvocationHandler h)
            throws IllegalArgumentException
    {
        //...代码省略
    }</code></pre> 
<p>        这个方法一共有 3 个参数：</p> 
<blockquote> 
 <p><strong>loader</strong>：<span style="background-color:#38d8f0;">类加载器，用于加载被代理对象</span>。</p> 
 <p><strong>interface</strong>：<span style="background-color:#38d8f0;">被代理类实现的一些接口（这个参数的定义，也决定了JDK动态代理只能代理实现了接口的一些类）</span>。</p> 
 <p><strong>h</strong>：<span style="background-color:#38d8f0;">代理要做的事情，实现 InvocationHandler 接口的对象</span>。</p> 
</blockquote> 
<h3 id="2%E3%80%81CGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86" style="background-color:transparent;">2、CGLIB动态代理</h3> 
<p>        JDK动态代理有一个<strong>最致命的问题</strong>，<span style="background-color:#a2e043;">是只能代理实现了接口的类</span>。</p> 
<p>        有些场景下，我们的业务码是直接实现的，并没有接口定义。为了解决这个问题，我们可以用 CGLIB 动态代理机制来解决。</p> 
<p>        CGLIB（Code Generation Library）是一个基于 ASM 的字节码生产库，它允许我们在运行时对字节码进行修改和动态生成。</p> 
<p>        CGLIB 通过继承方式实现代理，很多知名的开源框架都使用到了 CGLIB。例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。（<span style="color:#fe2c24;"><strong>其中 Spring 是基于动态代理实现的，动态代理是基于反射实现的</strong></span>）</p> 
<h4 id="%EF%BC%881%EF%BC%89CGLIB%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4" style="background-color:transparent;">（1）CGLIB 动态代理类实现步骤</h4> 
<blockquote> 
 <p>1、<span style="background-color:#a2e043;">定义一个类（被代理类）</span>。</p> 
 <p>2、<span style="background-color:#a2e043;">自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于增强目标方法，和 JDK 动态代理中的 invoke 方法类似</span>。</p> 
 <p>3、<span style="background-color:#a2e043;">通过 Enhancer 类的 create() 创建代理类</span>。</p> 
</blockquote> 
<p>        接下来看实现：</p> 
<h4 id="%EF%BC%882%EF%BC%89%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96" style="background-color:transparent;">（2）添加依赖</h4> 
<p>        和 JDK 动态代理不同，<span style="background-color:#38d8f0;">CGLIB（Code Generation Library）实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖</span>。</p> 
<pre><code class="language-XML">        &lt;dependency&gt;
            &lt;groupId&gt;cglib&lt;/groupId&gt;
            &lt;artifactId&gt;cglib&lt;/artifactId&gt;
            &lt;version&gt;3.3.0&lt;/version&gt;
        &lt;/dependency&gt;</code></pre> 
<h4 id="%EF%BC%883%EF%BC%89%E8%87%AA%E5%AE%9A%E4%B9%89MethodInterceptor%EF%BC%88%E6%96%B9%E6%B3%95%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%89" style="background-color:transparent;">（3）自定义MethodInterceptor（方法拦截器）</h4> 
<p>        实现 MethodInterceptor 接口:</p> 
<pre><code class="language-java">import org.springframework.cglib.proxy.MethodInterceptor;
import java.lang.reflect.Method;

public class CGLibInterceptor implements MethodInterceptor {
    private Object target;

    public CGLibInterceptor(Object target) {
        this.target = target;
    }

    /**
     * 调用代理对象的方法
     */
    @Override
    public Object intercept(Object obj, Method method, Object[] args, org.springframework.cglib.proxy.MethodProxy proxy) throws Throwable {
        //代理增强内容
        System.out.println("我是中介，开始代理");
        Object result = method.invoke(target, args);
        //代理增强内容
        System.out.println("我是中介，结束代理");
        return result;
    }
}</code></pre> 
<h4 id="%EF%BC%884%EF%BC%89%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E7%B1%BB%EF%BC%8C%E5%B9%B6%E4%BD%BF%E7%94%A8">（4）创建代理类，并使用</h4> 
<p>        代理接口：</p> 
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        //目标对象
        HouseSubject target = new RealHouseSubject();
        HouseSubject proxy  = (HouseSubject) Enhancer.create(target.getClass(), new CGLibInterceptor(target));
        proxy.rentHouse();
        System.out.println("=============");
        proxy.saleHouse();
    }
}</code></pre> 
<p>        运行程序，执行结果如下：</p> 
<p><img alt="" height="224" src="https://images2.imgbox.com/e7/45/AN65mlIJ_o.png" width="449"></p> 
<p>        代理类：</p> 
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        //目标对象
        HouseSubject target = new RealHouseSubject();
        RealHouseSubject proxy  = (RealHouseSubject) Enhancer.create(target.getClass(), new CGLibInterceptor(target));
        proxy.rentHouse();
        System.out.println("=============");
        proxy.saleHouse();
    }
}</code></pre> 
<p>        运行程序，执行结果如下：</p> 
<p><img alt="" height="225" src="https://images2.imgbox.com/e4/1f/C4TnPGmL_o.png" width="434"></p> 
<h4 id="%EF%BC%885%EF%BC%89%E4%BB%A3%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B2%E8%A7%A3" style="background-color:transparent;">（5）代码简单讲解</h4> 
<p><strong>1、MethodInterceptor</strong>：</p> 
<p>        MethodInterceptor 和 JDK动态代理中的 InvocationHandler 类似，它只定义了一个方法 intercept()，用于增强目标方法。</p> 
<pre><code class="language-html">    public interface MethodInterceptor extends Callback {
        /**
         * 参数说明:
         * o: 被代理的对象
         * method: ⽬标⽅法(被拦截的⽅法, 也就是需要增强的⽅法)
         * objects: ⽅法⼊参
         * methodProxy: ⽤于调⽤原始⽅法
         */
        Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable;
    }</code></pre> 
<p><strong>2、Enhancer.create()</strong>：</p> 
<pre><code class="language-java">    public static Object create(Class type, Callback callback) {
        //...代码省略
    }</code></pre> 
<p>        <strong>type</strong>：<span style="background-color:#a2e043;">被代理类的类型（类或接口）</span></p> 
<p>        <strong>callback</strong>：<span style="background-color:#a2e043;">自定义方法拦截器 MethodInterceptor</span></p> 
<hr> 
<h2 id="%E5%9B%9B%E3%80%81Spring%20AOP%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89">四、Spring AOP 源码剖析（了解）</h2> 
<p>        Spring AOP 主要基于两种方式实现的：JDK 及 CGLIB 的方式。</p> 
<p>        Spring 源码过于复杂，我们只摘出一些主要内容，以了解为主</p> 
<p>        Spring 对于 AOP 的实现，基本都是靠 AnnotationAwareAspectJAutoProxyCreator 去完成 生成代理对象的逻辑在父类 AbstractAutoProxyCreator 中。</p> 
<pre><code class="language-java">protected Object createProxy(Class&lt;?&gt; beanClass,@Nullable String beanName,
@Nullable Object[]specificInterceptors,TargetSource targetSource){
        if(this.beanFactory instanceof ConfigurableListableBeanFactory){
        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory)
        this.beanFactory,beanName,beanClass);
        }
        //创建代理⼯⼚
        ProxyFactory proxyFactory=new ProxyFactory();
        proxyFactory.copyFrom(this);
        /**
         * 检查proxyTargetClass属性值，spring默认为false
         * proxyTargetClass 检查接⼝是否对类代理, ⽽不是对接⼝代理
         * 如果代理对象为类, 设置为true, 使⽤cglib代理
         */
        if(!proxyFactory.isProxyTargetClass()){
            //是否有设置cglib代理
            if(shouldProxyTargetClass(beanClass,beanName)){
            //设置proxyTargetClass为true,使⽤cglib代理
            proxyFactory.setProxyTargetClass(true);
        }else{
            /**
             * 如果beanClass实现了接⼝，且接⼝⾄少有⼀个⾃定义⽅法，则使⽤JDK代理
             * 否则CGLIB代理(设置ProxyTargetClass为true )
             * 即使我们配置了proxyTargetClass=false, 经过这⾥的⼀些判断还是可能会将其
             设为true
             */
            evaluateProxyInterfaces(beanClass,proxyFactory);
            }
            }
            Advisor[]advisors=buildAdvisors(beanName,specificInterceptors);
            proxyFactory.addAdvisors(advisors);
            proxyFactory.setTargetSource(targetSource);
            customizeProxyFactory(proxyFactory);
    
            proxyFactory.setFrozen(this.freezeProxy);
            if(advisorsPreFiltered()){
            proxyFactory.setPreFiltered(true);
        }

        // Use original ClassLoader if bean class not locally loaded in overriding class loader
        ClassLoader classLoader =getProxyClassLoader();
        if(classLoader instanceof SmartClassLoader&amp;&amp;classLoader != beanClass.getClassLoader()){
            classLoader=((SmartClassLoader)classLoader).getOriginalClassLoader();
        }
//从代理⼯⼚中获取代理
        return proxyFactory.getProxy(classLoader);
        }</code></pre> 
<p>        代理工厂有一个重要的属性：proxyTargetClass，默认值为false。也可以通过程序设置</p> 
<table><tbody><tr><td>proxyTargetClass</td><td>⽬标对象</td><td>代理⽅式</td></tr><tr><td>false</td><td>实现了接口</td><td>jdk代理</td></tr><tr><td>false</td><td>未实现接口(只有实现类)</td><td>cglib代理</td></tr><tr><td>true</td><td>实现了接口</td><td>cglib代理</td></tr><tr><td>true</td><td>未实现接口(只有实现类)</td><td>cglib代理</td></tr></tbody></table> 
<p>        可以通过 @EnableAspectJAutoProxy(proxyTargetClass = true) 来设置。</p> 
<p>        注意：</p> 
<blockquote> 
 <p>Spring 默认 proxyTargetClass：false，会分为两种情况：</p> 
 <p>        <strong>实现了接口</strong>：<span style="background-color:#a2e043;">使用 JDK 代理</span>。</p> 
 <p>        <strong>普通类</strong>：       <span style="background-color:#a2e043;">使用 CGLIB 代理</span>。</p> 
 <p></p> 
 <p>Spring Boot 2.X 开始，默认使用 proxyTargetClass：true</p> 
 <p>        <strong>默认使用 CGLIB 代理</strong></p> 
</blockquote> 
<p>        SpringBoot设置 @EnableAspectJAutoProxy 无效，因为 Spring Boot 默认使用 AopAutoConfiguration 进行装配。</p> 
<p>        可以通过配置项 spring.aop.proxy-target-class=false 来进行修改，设置为 jdk 代理。</p> 
<p>        使用 context.getBean() 需要添加注解，使 HouseProxy，RealHouseSubject 被 Spring 管理。测试 AOP 代理，需要把这些类交给 AOP 管理（自定义注解或使用 @Aspect）</p> 
<p>        我们现在从源码中点进去看看代理工厂的代码：</p> 
<pre><code class="language-java">public class ProxyFactory extends ProxyCreatorSupport {
    //...代码省略
    //获取代理
    public Object getProxy(@Nullable ClassLoader classLoader) {
    //分两步 先createAopProxy,后getProxy
        return createAopProxy().getProxy(classLoader);
    }

    protected final synchronized AopProxy createAopProxy() {
        if (!this.active) {
            activate();
        }
        return getAopProxyFactory().createAopProxy(this);
    }
    //...代码省略
}</code></pre> 
<p>        createAopProxy 的实现在 DefaultAopProxyFactory 中</p> 
<pre><code class="language-java">public class DefaultAopProxyFactory implements AopProxyFactory, Serializable {
    //...代码省略
    @Override
    public AopProxy createAopProxy(AdvisedSupport config) throws
            AopConfigException {
        /**
         * 根据proxyTargetClass判断
         * 如果⽬标类是接⼝, 使⽤JDK动态代理
         * 否则使⽤cglib动态代理
         */
        if (!NativeDetector.inNativeImage() &amp;&amp;
                (config.isOptimize() || config.isProxyTargetClass() ||
                        hasNoUserSuppliedProxyInterfaces(config))) {
            Class&lt;?&gt; targetClass = config.getTargetClass();
            if (targetClass == null) {
                throw new AopConfigException("TargetSource cannot determine
                        target class:" +
                "Either an interface or a target is required for proxy
                creation. ");
            }
            if (targetClass.isInterface() || Proxy.isProxyClass(targetClass) ||
                    ClassUtils.isLambdaClass(targetClass)) {
                return new JdkDynamicAopProxy(config);
            }
            return new ObjenesisCglibAopProxy(config);
        } else {
            return new JdkDynamicAopProxy(config);
        }
    }
    //...代码省略
}</code></pre> 
<p>        接下来就是创建代理了</p> 
<p>JDK动态代理：</p> 
<pre><code class="language-java">final class JdkDynamicAopProxy implements AopProxy, InvocationHandler, Serializable {
    //...代码省略
    @Override
    public Object getProxy(@Nullable ClassLoader classLoader) {
        if (logger.isTraceEnabled()) {
            logger.trace("Creating JDK dynamic proxy: " +
                    this.advised.getTargetSource());
        }
        return Proxy.newProxyInstance(determineClassLoader(classLoader),
                this.proxiedInterfaces, this);
    }
    //...代码省略
}</code></pre> 
<p>CGLIB动态代理：</p> 
<pre><code class="language-java">class CglibAopProxy implements AopProxy, Serializable {
    //...代码省略
    @Override
    public Object getProxy(@Nullable ClassLoader classLoader) {
    //...代码省略
    // Configure CGLIB Enhancer...
        Enhancer enhancer = createEnhancer();
    // Generate the proxy class and create a proxy instance.
        return createProxyClassAndInstance(enhancer, callbacks);
    }
    //...代码省略
}</code></pre> 
<hr> 
<h2 id="%E4%BA%94%E3%80%81%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98">五、常见面试题</h2> 
<h3 id="1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%20AOP%EF%BC%9F">1、什么是 AOP？</h3> 
<blockquote> 
 <p>        AOP是 面向切面编程，也是一种思想，切面指的是某一类特定问题，所以 AOP 也可以理解为 面向切面编程。</p> 
</blockquote> 
<h3 id="2%E3%80%81Spring%20AOP%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">2、Spring AOP的实现方式有哪些？</h3> 
<blockquote> 
 <p>（1）基于注解（@Aspect 或 自定义注解）</p> 
 <p>（2）基于 xml</p> 
 <p>（3）基于代理</p> 
</blockquote> 
<h3 id="3%E3%80%81Spring%20AOP%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F">3、Spring AOP 的实现原理？</h3> 
<blockquote> 
 <p>        基于动态代理实现的，其中的动态代理有两种形式：（1）JDK   （2）CGLIB</p> 
</blockquote> 
<h3 id="4%E3%80%81Spring%20%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AF%E5%93%AA%E7%A7%8D%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%9F">4、Spring 使用的是哪种代理方式？</h3> 
<blockquote> 
 <p>        Spring 的 proxyTargetClass 默认为：false，其中：实现了接口，使用 JDK 代理；普通类：使用CGLIB代理。</p> 
 <p>        Spring Boot 从 2.X 之后，proxyTargetClass 默认为：true，默认使用 CGLIB 代理</p> 
 <p><img alt="" height="232" src="https://images2.imgbox.com/46/90/fSFgkJhb_o.png" width="796"></p> 
 <p>         现在我们测试一下：当这个值为 true 时，则使用的是动态代理</p> 
 <p>        <img alt="" height="85" src="https://images2.imgbox.com/5b/e1/XeQEbu03_o.png" width="352"></p> 
 <pre><code class="language-java">@SpringBootApplication
public class SpringAopApplication {
    public static void main(String[] args) {
       ApplicationContext context = SpringApplication.run(SpringAopApplication.class, args);
        //代理类
        TestController bean = context.getBean(TestController.class);
        System.out.println(bean);
    }
}</code></pre> 
 <p>        要打断电才能观察到结果，如图：</p> 
 <p><img alt="" height="89" src="https://images2.imgbox.com/aa/6c/Xow8raSH_o.png" width="761"></p> 
 <p>        我们获取Spring管理的对象，打断点，观察对象名称，如图：</p> 
 <p><img alt="" height="256" src="https://images2.imgbox.com/b7/b1/ySydGc2a_o.png" width="650"></p> 
 <p>        可以看到，是 CGLIB代理。</p> 
 <p>当值设为 false 时；就要看代理对象是不是接口了，是接口用的就是JDK代理，代理对象是类就是CGLIB代理。</p> 
 <p><img alt="" height="71" src="https://images2.imgbox.com/44/40/0JzhbcNs_o.png" width="359"></p> 
 <p>        因为要代理接口，所以现在重新创建一个接口，内容如下：<br>  </p> 
 <pre><code class="language-java">public interface IFace {
    void test();
}</code></pre> 
 <p>        再创建一个成 Controller 类，实现上面这个类</p> 
 <pre><code class="language-java">@RequestMapping("/test2")
@RestController
public class TestController2 implements IFace{
    @MyAspect
    @RequestMapping("t1")
    @Override
    public void test() {
        System.out.println("测试测试");
    }
}</code></pre> 
 <p>        main方法如下：</p> 
 <pre><code class="language-java">@SpringBootApplication
public class SpringAopApplication {
    public static void main(String[] args) {
       ApplicationContext context = SpringApplication.run(SpringAopApplication.class, args);

       //代理类
        TestController bean = context.getBean(TestController.class);
        System.out.println(bean);

        //代理接口
        IFace iFace = (IFace) context.getBean("testController2");
        System.out.println(iFace);
    }
}</code></pre> 
 <p>        现在看看Spring对象，任然要使用断点才能看到，如图：</p> 
 <p><img alt="" height="91" src="https://images2.imgbox.com/70/c5/ipesITHF_o.png" width="832"></p> 
 <p></p> 
 <p>        看看bean对象，如图：</p> 
 <p><img alt="" height="72" src="https://images2.imgbox.com/ac/7b/3w0m13o9_o.png" width="449"></p> 
</blockquote> 
<h3 id="5%E3%80%81JDK%20%E5%92%8C%20CGLIB%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">5、JDK 和 CGLIB 的区别？</h3> 
<blockquote> 
 <p>        使用JDK 动态代理只能代理接口。</p> 
 <p>        使用 CGLIB 动态代理 既可以代理接口，也可以代理类。</p> 
</blockquote> 
<hr> 
<h2 id="%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93" style="background-color:transparent;">六、总结</h2> 
<p>        1、<span style="color:#fe2c24;"><strong>AOP 是一种思想</strong></span>，<span style="background-color:#a2e043;">是对某一类事情的集中处理</span>。Spring 框架实现了AOP，称之为 Spring AOP。</p> 
<p>        2、Spring AOP 场景的实现方式有两种：<span style="background-color:#38d8f0;">（1）基于注解@Aspect来实现</span>。<span style="background-color:#38d8f0;">（2）基于自定义注解来实现</span>，<span style="background-color:#a2e043;">还有一些更原始的方式，比如基于代理、基于 xml 配置的方式，但目标比较少见</span>。</p> 
<p>        3、Spring AOP 是基于动态代理实现的，有两种方式：<span style="background-color:#38d8f0;">（1）基于 JDK 动态代理实现</span>。<span style="background-color:#38d8f0;">（2）基于 CGLIB 动态代理实现。运行时使用哪种方式与项目配置的代理对象有关</span>。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/62c67af088aa562295a24a2b2c0708da/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">服务韧性工程（SRE）论坛演讲实录 | 雅菲奥朗： 人工智能的未来之路引领智能运维新纪元</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5cf20055c74067e90c45e86d0de906a0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JDK 安装及配置教程（Windows）【安装】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>