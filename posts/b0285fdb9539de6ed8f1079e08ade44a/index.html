<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>力扣每日一题 6/19 排序&#43;动态规划 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b0285fdb9539de6ed8f1079e08ade44a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="力扣每日一题 6/19 排序&#43;动态规划">
  <meta property="og:description" content="博客主页：誓则盟约系列专栏：IT竞赛 专栏关注博主，后期持续更新系列文章如果有错误感谢请大家批评指出，及时修改感谢大家点赞👍收藏⭐评论✍ 2713.矩阵中严格递增的单元格数【困难】 题目： 给你一个下标从 1 开始、大小为 m x n 的整数矩阵 mat，你可以选择任一单元格作为 起始单元格 。
从起始单元格出发，你可以移动到 同一行或同一列 中的任何其他单元格，但前提是目标单元格的值 严格大于 当前单元格的值。
你可以多次重复这一过程，从一个单元格移动到另一个单元格，直到无法再进行任何移动。
请你找出从某个单元开始访问矩阵所能访问的 单元格的最大数量 。
返回一个表示可访问单元格最大数量的整数。
示例 1：
输入：mat = [[3,1],[3,4]] 输出：2 解释：上图展示了从第 1 行、第 2 列的单元格开始，可以访问 2 个单元格。可以证明，无论从哪个单元格开始，最多只能访问 2 个单元格，因此答案是 2 。 示例 2：
输入：mat = [[1,1],[1,1]] 输出：1 解释：由于目标单元格必须严格大于当前单元格，在本示例中只能访问 1 个单元格。 示例 3：
输入：mat = [[3,1,6],[-9,5,7]] 输出：4 解释：上图展示了从第 2 行、第 1 列的单元格开始，可以访问 4 个单元格。可以证明，无论从哪个单元格开始，最多只能访问 4 个单元格，因此答案是 4 。 分析问题： 这道题旨在寻找一个最大解，可以用动态规划来解，而题意又是让我们顺序移动单元格，只能从小到大的顺序，因此我们可以用一个哈希表来记录每个值所对应的坐标，遍历每个可能的起点。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-19T20:26:09+08:00">
    <meta property="article:modified_time" content="2024-06-19T20:26:09+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">力扣每日一题 6/19 排序&#43;动态规划</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <ul><li><strong>博客主页：<a href="https://blog.csdn.net/Xxy_1008?type=blog" title="誓则盟约">誓则盟约</a></strong></li><li><strong>系列专栏：<a href="https://blog.csdn.net/xxy_1008/category_12662512.html?spm=1001.2014.3001.5482" title="IT竞赛 专栏">IT竞赛 专栏</a></strong></li><li><strong>关注博主，后期持续更新系列文章</strong></li><li><strong>如果有错误感谢请大家批评指出，及时修改</strong></li><li><strong>感谢大家点赞👍收藏⭐评论✍</strong> </li></ul> 
<hr> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/96/4e/fTWUaQoF_o.gif"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/17/56/s6wwXIWm_o.gif"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/94/ee/9mhiKX11_o.gif"></p> 
<p></p> 
<h2>2713.矩阵中严格递增的单元格数【<span style="color:#fe2c24;">困难</span>】</h2> 
<h4><span style="color:#a2e043;">题目：</span></h4> 
<p>给你一个下标从 <strong>1</strong> 开始、大小为 <code>m x n</code> 的整数矩阵 <code>mat</code>，你可以选择任一单元格作为 <strong>起始单元格</strong> 。</p> 
<p>从起始单元格出发，你可以移动到 <strong>同一行或同一列</strong> 中的任何其他单元格，但前提是目标单元格的值<strong> 严格大于 </strong>当前单元格的值。</p> 
<p>你可以多次重复这一过程，从一个单元格移动到另一个单元格，直到无法再进行任何移动。</p> 
<p>请你找出从某个单元开始访问矩阵所能访问的 <strong>单元格的最大数量</strong> 。</p> 
<p>返回一个表示可访问单元格最大数量的整数。</p> 
<p><strong>示例 1：</strong></p> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/85/6c/daHOtTyj_o.png"></strong></p> 
<pre><strong>输入：</strong>mat = [[3,1],[3,4]]
<strong>输出：</strong>2
<strong>解释：</strong>上图展示了从第 1 行、第 2 列的单元格开始，可以访问 2 个单元格。可以证明，无论从哪个单元格开始，最多只能访问 2 个单元格，因此答案是 2 。 </pre> 
<p><strong>示例 2：</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/df/e8/tYJfan2X_o.png"></p> 
<pre><strong>输入：</strong>mat = [[1,1],[1,1]]
<strong>输出：</strong>1
<strong>解释：</strong>由于目标单元格必须严格大于当前单元格，在本示例中只能访问 1 个单元格。</pre> 
<p> <strong>示例 3：</strong></p> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/d4/b1/HCO5xWl9_o.png"></strong></p> 
<pre><strong>输入：</strong>mat = [[3,1,6],[-9,5,7]]
<strong>输出：</strong>4
<strong>解释：</strong>上图展示了从第 2 行、第 1 列的单元格开始，可以访问 4 个单元格。可以证明，无论从哪个单元格开始，最多只能访问 4 个单元格，因此答案是 4 。
</pre> 
<hr> 
<h4><span style="color:#a2e043;">分析问题：</span></h4> 
<p>       这道题旨在寻找一个最大解，可以用动态规划来解，而题意又是让我们顺序移动单元格，只能从小到大的顺序，因此我们可以用一个哈希表来记录每个值所对应的坐标，遍历每个可能的起点。</p> 
<p>        在这个过程中，我们可以维护两个数组 rowMax 和 colMax，分别记录每一行和每一列的最大递增长度。初始时，这两个数组的所有元素都为 0。</p> 
<p style="text-align:justify;">        对于每个值对应的所有单元格位置，我们按照位置顺序遍历，对于每个位置 (i,j)，我们可以计算出以该位置为终点的最大递增长度为 <strong>1+max(rowMax[i],colMax[j])，</strong>更新答案，然后更新 <code>rowMax[i]</code> 和 <code>colMax[j]</code>。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/65/4a/j8CLOM4X_o.jpg"></p> 
<h4><span style="color:#a2e043;">代码实现：</span></h4> 
<pre><code class="language-python">class Solution:
    def maxIncreasingCells(self, mat: List[List[int]]) -&gt; int:
        M = len(mat)
        N = len(mat[0])

        # 建立一个哈希表
        value_buckets = defaultdict(list)
        
        for i in range(M):
            for j in range(N):
                value_buckets[mat[i][j]].append((i, j))

        row_best = [0] * M
        col_best = [0] * N
        ans = 0

        for val in sorted(value_buckets.keys()):
            cells = value_buckets[val]
            updates = []
            
            for r, c in cells:
                mx = 1 + max(row_best[r], col_best[c])
                updates.append((r, c, mx))
                ans = max(ans, mx)
            
            for r, c, mx in updates:
                row_best[r] = max(row_best[r], mx)
                col_best[c] = max(col_best[c], mx)
        
        return ans</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/22/59/iEd0ucqJ_o.png"> </p> 
<hr> 
<p> </p> 
<h4><span style="color:#a2e043;">总结：</span></h4> 
<p><strong>代码详解：</strong></p> 
<p>        首先，通过 <code>len(mat)</code> 和 <code>len(mat[0])</code> 分别获取了输入矩阵 <code>mat</code> 的行数 <code>M</code> 和列数 <code>N</code> 。</p> 
<p>        然后，创建了一个默认字典 <code>value_buckets</code> 。在接下来的两层循环中，遍历矩阵 <code>mat</code> 的每个元素。对于每个元素的值，将其对应的坐标 <code>(i, j)</code> 添加到 <code>value_buckets</code> 中以该值为键的列表中。</p> 
<p>        接着，创建了两个列表 <code>row_best</code> 和 <code>col_best</code> ，分别用于记录每行和每列的最佳值，并初始化为全 0 。还初始化了一个变量 <code>ans</code> 用于保存最终的结果，并初始化为 0 。</p> 
<p>        之后，对 <code>value_buckets</code> 中的键（即矩阵中的值）进行排序。对于每个排序后的键值 <code>val</code> ，获取对应的坐标列表 <code>cells</code> 。然后创建一个空列表 <code>updates</code> 用于保存后续的更新信息。</p> 
<p>        在遍历 <code>cells</code> 中的每个坐标 <code>(r, c)</code> 时，计算当前位置能达到的最大值 <code>mx</code> ，它等于 1 加上 <code>row_best[r]</code> 和 <code>col_best[c]</code> 中的最大值。将 <code>(r, c, mx)</code> 添加到 <code>updates</code> 列表中，并更新 <code>ans</code> 为 <code>ans</code> 和 <code>mx</code> 中的最大值。</p> 
<p>        最后，再次遍历 <code>updates</code> 列表，更新 <code>row_best[r]</code> 和 <code>col_best[c]</code> 为它们自身和 <code>mx</code> 中的最大值。</p> 
<p>        最终，方法返回 <code>ans</code> ，即矩阵中按照特定规则能达到的最大结果值。</p> 
<hr> 
<p><strong>主要考查内容</strong>：</p> 
<p></p> 
<ol><li>对二维列表的遍历和操作。</li><li>使用默认字典 <code>defaultdict</code> 来根据值存储坐标。</li><li>对值进行排序，并基于排序后的结果进行一系列计算和更新操作。</li><li>维护两个分别记录每行和每列最佳值的列表 <code>row_best</code> 和 <code>col_best</code> 。</li></ol> 
<p></p> 
<p><strong>通过这段代码可以学到</strong>：</p> 
<p></p> 
<ol><li>如何有效地处理二维数组中的数据。 
  <ul><li>例如通过两层循环遍历二维数组的每个元素。</li></ul></li><li>运用 <code>defaultdict</code> 来根据特定的值组织数据。 
  <ul><li>方便后续按照值的顺序进行处理。</li></ul></li><li>结合排序和逐步更新的策略来解决复杂的最值问题。 
  <ul><li>通过比较和更新 <code>row_best</code> 和 <code>col_best</code> 来获取最终的最大结果。</li></ul></li></ol> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/31/b9/cOfxK79g_o.jpg"></p> 
<h3 style="text-align:center;"><span style="color:#0d0016;"><span style="background-color:#e6b223;">“千金纵买相如赋，脉脉此情谁诉。”——《摸鱼儿·更能消几番风雨》</span></span></h3>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3677a5924562dc1df6c4585e201b542a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据结构之探索“队列”的奥秘</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6fb2acd42fdfa8ae4ac5f52f8c1d3de8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">xcode和iPhone真机或者watch真机连接问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>