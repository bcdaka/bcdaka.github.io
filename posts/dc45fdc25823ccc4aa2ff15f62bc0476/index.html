<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;】关联容器探秘：Map与Multimap详解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/dc45fdc25823ccc4aa2ff15f62bc0476/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;】关联容器探秘：Map与Multimap详解">
  <meta property="og:description" content="目录
1.映射类 map
0. 引入 pair：
1.定义
2.插入
3. 遍历
4.❗operator[]的实现
5. 插入
运用
2.Multimap 类
0. 引入：不去重的 Multi
1. Multimap 不支持 Operator[]
2. Multimap 的删除
1.映射类 map 0. 引入 pair： 在C&#43;&#43;中，std::pair是一个非常有用的容器适配器，它属于C&#43;&#43;标准模板库(STL)的一部分，主要用于存储两个相关联的数据项。std::pair的设计目的是为了方便地处理需要成对出现的数据，比如坐标点(x, y)、键值对(key, value)等。
std::pair由&lt;utility&gt;头文件提供，它包含两个成员，分别是first和second，这两个成员可以是任意类型的组合。std::pair的声明语法如下：
#include &lt;utility&gt; // 包含std::pair的定义 std::pair&lt;Type1, Type2&gt; myPair; 其中，Type1和Type2是你想要存储的两种类型。
创建pair实例 可以通过构造函数直接初始化std::pair：
std::pair&lt;int, double&gt; p1(1, 2.5); 也可以使用std::make_pair函数：
std::pair&lt;int, double&gt; p2 = std::make_pair(1, 2.5); 访问pair成员 std::pair的成员first和second可以直接访问：
std::pair&lt;int, double&gt; p(1, 2.5); int x = p.first; double y = p.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-23T23:16:05+08:00">
    <meta property="article:modified_time" content="2024-07-23T23:16:05+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】关联容器探秘：Map与Multimap详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E6%98%A0%E5%B0%84%E7%B1%BB%20map-toc" style="margin-left:0px;"><a href="#1.%E6%98%A0%E5%B0%84%E7%B1%BB%20map" rel="nofollow">1.映射类 map</a></p> 
<p id="GWMNs-toc" style="margin-left:40px;"><a href="#GWMNs" rel="nofollow">0. 引入 pair：</a></p> 
<p id="MIhXa-toc" style="margin-left:40px;"><a href="#MIhXa" rel="nofollow">1.定义</a></p> 
<p id="RT9bD-toc" style="margin-left:40px;"><a href="#RT9bD" rel="nofollow">2.插入</a></p> 
<p id="jeRtI-toc" style="margin-left:40px;"><a href="#jeRtI" rel="nofollow">3. 遍历</a></p> 
<p id="q90sa-toc" style="margin-left:40px;"><a href="#q90sa" rel="nofollow">4.❗operator[]的实现</a></p> 
<p id="IhAPm-toc" style="margin-left:40px;"><a href="#IhAPm" rel="nofollow">5. 插入</a></p> 
<p id="%C2%A0%E8%BF%90%E7%94%A8-toc" style="margin-left:40px;"><a href="#%C2%A0%E8%BF%90%E7%94%A8" rel="nofollow"> 运用</a></p> 
<p id="sNRHt-toc" style="margin-left:0px;"><a href="#sNRHt" rel="nofollow">2.Multimap 类</a></p> 
<p id="jJJuL-toc" style="margin-left:120px;"><a href="#jJJuL" rel="nofollow">0. 引入：不去重的 Multi</a></p> 
<p id="ImR0f-toc" style="margin-left:120px;"><a href="#ImR0f" rel="nofollow">1. Multimap 不支持 Operator[]</a></p> 
<p id="F2Mnw-toc" style="margin-left:120px;"><a href="#F2Mnw" rel="nofollow">2. Multimap 的删除</a></p> 
<hr id="hr-toc"> 
<h2 style="background-color:transparent;">1.映射类 map</h2> 
<h3 id="GWMNs">0. 引入 pair：</h3> 
<p id="ub20982a6">在C++中，<code>std::pair</code>是一个非常有用的容器适配器，它属于C++标准模板库(STL)的一部分，主要用于存储两个相关联的数据项。<code>std::pair</code>的设计目的是为了方便地处理需要<span style="color:#4da8ee;">成对出现的数据</span>，比如坐标点(x, y)、键值对(key, value)等。</p> 
<p id="u4389391f"><code>std::pair</code>由<code>&lt;utility&gt;</code>头文件提供，它包含两个成员，分别是<span style="color:#4da8ee;"><code>first</code>和<code>second</code></span>，这两个成员可以是任意类型的组合。<code>std::pair</code>的声明语法如下：</p> 
<pre id="qm15n"><code>#include &lt;utility&gt; // 包含std::pair的定义

std::pair&lt;Type1, Type2&gt; myPair;</code></pre> 
<p id="ua6e7b751">其中，<code>Type1</code>和<code>Type2</code>是你想要存储的两种类型。</p> 
<h4 id="TLlZY">创建pair实例</h4> 
<p id="u2ad5cc37">可以通过构造函数直接初始化<code>std::pair</code>：</p> 
<pre id="VISv3"><code>std::pair&lt;int, double&gt; p1(1, 2.5);</code></pre> 
<p id="u2e4f297b">也可以使用<code>std::make_pair</code>函数：</p> 
<pre id="QGaT5"><code>std::pair&lt;int, double&gt; p2 = std::make_pair(1, 2.5);</code></pre> 
<h4 id="nLykU">访问pair成员</h4> 
<p id="ud1e47fec"><code>std::pair</code>的成员<span style="color:#4da8ee;"><code>first</code>和<code>second</code>可以直接访问</span>：</p> 
<pre id="BkrEx"><code>std::pair&lt;int, double&gt; p(1, 2.5);
int x = p.first;
double y = p.second;</code></pre> 
<h4 id="VLjSJ">pair的比较</h4> 
<p id="u5454b16e"><code>std::pair</code>可以进行比较，<span style="color:#4da8ee;"><strong>比较规则首先比较</strong><code><strong>first</strong></code><strong>成员</strong></span>，如果<code>first</code>相等，则比较<code>second</code>成员。这使得<code>std::pair</code>可以用于<code>std::map</code>和<code>std::set</code>等容器中的键值对。</p> 
<h4 id="mHJTt">示例</h4> 
<p id="ub7887671">下面是一个使用<code>std::pair</code>的简单示例：</p> 
<pre id="R17JN"><code>#include &lt;iostream&gt;
#include &lt;utility&gt; // 包含std::pair的定义

int main() {
    std::pair&lt;std::string, int&gt; studentGrade("Alice", 90);

    std::cout &lt;&lt; "Student: " &lt;&lt; studentGrade.first &lt;&lt; ", Grade: " &lt;&lt; studentGrade.second &lt;&lt; std::endl;

   std::pair&lt;std::string, int&gt; studentGradeB("Student:Bob", 85);

if (studentGradeA.second &gt; studentGradeB.second) {
    std::cout &lt;&lt; "Alice has a higher grade than Bob." &lt;&lt; std::endl;
}
    return 0;
}</code></pre> 
<p id="u5423eea1"></p> 
<p class="img-center"><img alt="" height="122" id="u425a2806" src="https://images2.imgbox.com/22/4e/Yz5frnOe_o.png" width="554"></p> 
<p id="u9ac3e58f">在这个示例中，我们创建了一个<code>std::pair</code>实例，存储了学生的名字和成绩，然后比较了两个学生的成绩。</p> 
<h3 id="MIhXa">1.定义</h3> 
<p id="u35bd2da7"></p> 
<p class="img-center"><img alt="" height="202" id="u12cb9434" src="https://images2.imgbox.com/44/0e/PvIwxonQ_o.png" width="765"></p> 
<p id="u772d5c03">key 通常用于排序和唯一地标识元素，value 中存储与 key 关联的内容。</p> 
<p id="u43e3be87">key 和 value 的类型可以不同，在<span style="color:#4da8ee;"> map </span>内部，key 和 value 通过成员类型<span style="color:#4da8ee;"> value_type</span> 绑定</p> 
<p id="ufc848c8a"><span style="color:#4da8ee;">Compare:</span> 比较器的类型，map中的元素是按照key来比较的，缺省情况下按照小于来比较，一般情况下(内置类型元素)该参数不需要传递，如果无法比较时(自定义类型)，需要用户自己显式传递比较规则(一般情况下按照函数指针或者仿函数来传递)</p> 
<p id="u29900f9d"><span style="color:#4da8ee;">Alloc</span>：通过空间配置器来申请底层空间，不需要用户传递，除非用户不想使用标准库提供的空间配置器</p> 
<h3 id="RT9bD">2.插入</h3> 
<p id="u490e4d54">例如简单实现一个字典，我们可以有四种插入方法：</p> 
<p id="u58d09446"><strong>①</strong> 我们可以直接调用<span style="color:#4da8ee;"> pair </span>的构造函数来插入</p> 
<p id="udce4bf16"><strong>②</strong> 可以用匿名对象的方式来写</p> 
<p id="u51021ddd"><strong>③</strong> 调用神奇的<span style="color:#fe2c24;"> make_pair</span></p> 
<p id="u780b5a9a"><strong>④</strong><strong> </strong>直接用<span style="color:#fe2c24;"> { }</span></p> 
<pre id="ww9sY"><code>std::map&lt;std::string, std::string&gt; dict;

    std::pair&lt;std::string, std::string&gt; kv1("insert", "插入");

    // 传参的四种实现
    dict.insert(std::pair&lt;std::string, std::string&gt;("sort", "排序")); // 方法一
    dict.insert(kv1); // 方法二
    // C++98
    dict.insert(std::make_pair("string", "字符串")); // 方法三
    // C++11 多参数的构造函数隐式类型转换
    // 最常用的
    dict.insert({ "erase", "删除" }); // 方法四

    // 输出字典的内容以验证是否插入成功
    for (const auto&amp; item : dict) {
        std::cout &lt;&lt; "Key: " &lt;&lt; item.first &lt;&lt; ", Value: " &lt;&lt; item.second &lt;&lt; std::endl;
    }</code></pre> 
<p id="ufdcac751">运行：</p> 
<p id="u4747d1ec"></p> 
<p class="img-center"><img alt="" height="197" id="ubecc0c49" src="https://images2.imgbox.com/71/01/EQyoQoiR_o.png" width="460"></p> 
<p id="u0f49d4b8">对于方法四中存在的隐式类型转化:</p> 
<pre id="PwWVR"><code>// 隐式类型的转换
	string str1 = "hello";
	A aa1 = { 1, 2 };
	pair&lt;string, string&gt; kv2 = { "string", "字符串" };
}</code></pre> 
<h3 id="jeRtI">3. 遍历</h3> 
<p id="u64fc43d8">和其他容器的迭代器一样，加上<span style="color:#4da8ee;"> <strong>::</strong></span> 小尾巴后就可以召唤出属于<span style="color:#4da8ee;"> map </span>的迭代器了：</p> 
<pre id="w9Dh0"><code>map&lt;string, string&gt;::iterator it = dict.begin();
//有请auto
auto it=dict.begin();</code></pre> 
<p id="u84fff0ec">返回值需要返回迭代器中节点的数据，节点的数据是<span style="color:#4da8ee;"> pair</span>，可惜 pair 并不支持 <strong>流</strong> (stream)</p> 
<p id="u45d8018f"></p> 
<p class="img-center"><img alt="" height="242" id="tdOwg" src="https://images2.imgbox.com/d6/39/RhIxCliK_o.png" width="547"></p> 
<p id="u9370e24d">有问题就有解决方法：使用 <span style="color:#fe2c24;"><code>it-&gt;</code> 中分别提取 first 和 second</span></p> 
<pre id="RuMSD"><code>//map&lt;string, string&gt;::iterator it = dict.begin();//迭代器返回pair指针
	auto it = dict.begin();
	while (it != dict.end())
	{
		//it-&gt;first = "xxx";
		//it-&gt;second = "xxx";

		//cout &lt;&lt; (*it).first &lt;&lt; ":" &lt;&lt; (*it).second &lt;&lt; endl;
		cout &lt;&lt; it-&gt;first &lt;&lt; ":" &lt;&lt; it-&gt;second &lt;&lt; endl;//结构体指针调用

		++it;
	}
	cout &lt;&lt; endl;</code></pre> 
<p id="uc38ad52c">map 同样支持甜甜的 <strong>范围 for </strong>来遍历，这里建议<span style="color:#fe2c24;">加上 &amp;</span> 提效：</p> 
<pre id="rcdWi"><code>for (const auto&amp; kv : dict)
	{
		cout &lt;&lt; kv.first &lt;&lt; ":"&lt;&lt;kv.second&lt;&lt;endl;
	}
}</code></pre> 
<h3 id="q90sa" style="background-color:transparent;">4.<code>❗operator[]</code>的实现</h3> 
<pre id="k4NxQ"><code>mapped_type&amp; operator[] (const key_type&amp; k) {
	pair&lt;iterator, bool&gt; ret = insert(make_pair(k, mapped_type()));
	// return (*(ret.first)).second;
	return ret.first-&gt;second;
}</code></pre> 
<p id="u07b21193">判断 pair 的 first 就是<span style="color:#4da8ee;"> map 的迭代器</span>即指针类型 , map 指针-&gt;second 实现计数</p> 
<blockquote> 
 <ul><li id="u868a0e0d">key 已经在树里面，返回 pair<span style="color:#4da8ee;">&lt;树里面 key 所在节点的 iterator, false&gt;</span></li><li id="u7288e4e1">key 不在树里面，返回 pair<span style="color:#4da8ee;"> &lt;新插入 key 所在节点的 iterator, true&gt;</span></li></ul> 
</blockquote> 
<hr id="A7zQU"> 
<h3 id="IhAPm">5. 插入</h3> 
<p id="ueed2500e"></p> 
<p class="img-center"><img alt="" height="212" id="u128764fc" src="https://images2.imgbox.com/db/2f/xoloN1xm_o.png" width="958"></p> 
<p id="u0c1ca422">注意：</p> 
<pre id="KIbrv"><code>// 不插入，不覆盖；插入过程中，只比较key，value是相同无所谓
	// key已经有了就不插入了
	dict.insert(make_pair("insert", "xxxx"));</code></pre> 
<p id="u6d2dbcae">测试：</p> 
<pre id="n572U"><code>void test_map4()
{
	map&lt;string, string&gt; dict;
	dict.insert(make_pair("string", "字符串"));
	dict.insert(make_pair("sort", "排序"));
	dict.insert(make_pair("insert", "插入"));

	cout &lt;&lt; dict["sort"] &lt;&lt; endl; // 查找和读
	dict["map"];                  // 插入,返回1
	dict["map"] = "映射,地图";     // 修改
	dict["insert"] = "xxx";       // 修改
	dict["set"] = "集合";         // 插入+修改
}</code></pre> 
<hr> 
<h3 id="%C2%A0%E8%BF%90%E7%94%A8"> 运用</h3> 
<p id="ub883cbb6">统计次数：例如说我们要计数如下动物：</p> 
<pre id="zJ32I"><code>"兔子", "大象", "兔子", "长颈鹿", "狮子", "猴子",
"大象", "兔子", "猴子", "猴子", "大象", "斑马",
"狮子", "猴子", "长颈鹿", "兔子", "斑马", "猴子"</code></pre> 
<p id="u617d2e65">我们可以这么写</p> 
<pre id="KhZVm"><code>map&lt;string, int&gt; count_map;
	for (auto&amp; str : arr) {
		map&lt;string, int&gt;::iterator it = count_map.find(str);
		if (it != count_map.end()) {
			it-&gt;second++;
		}
		else {
			count_map.insert(make_pair(str, 1));
		}
	}</code></pre> 
<p id="u2758575e">这里实际上可以让<span style="color:#4da8ee;"> insert </span>来优化一下</p> 
<p id="u1d4a5de8"></p> 
<p class="img-center"><img alt="" height="221" id="uafbf029c" src="https://images2.imgbox.com/f7/95/w5KlwY7d_o.png" width="927"></p> 
<p id="u3ac9aeb2">我们可以看到<span style="color:#4da8ee;"> insert </span>的返回值是一个<span style="color:#fe2c24;"> pair&lt;iterator, bool&gt; </span>类型。</p> 
<p id="u1f2b53eb"><span style="color:#1c7892;">插入成功， second 就是 true；如果插入失败， second 就是 false</span></p> 
<p id="u673f7d0c">既然如此，我们就可以这么去迭代：</p> 
<pre id="kOa1R"><code>for (auto&amp; str : arr) {
	pair&lt; map&lt;string, int&gt;::iterator, bool &gt;ret
    = count_map.insert(make_pair(str, 1)); 
}</code></pre> 
<p id="ue227a0dd">所以我们写一个判断，判断 second (bool) <span style="color:#4da8ee;">是不是 false</span>，如果是就让统计 <strong>次数++。</strong></p> 
<pre id="o7vPp"><code>map&lt;string, int&gt; count_map;
for (auto&amp; str : arr) {
	auto ret = count_map.insert(make_pair(str, 1)); 
	if (ret.second == false) {
		ret.first-&gt;second++;
	}
}</code></pre> 
<p id="u9fa06d7f"></p> 
<p class="img-center"><img alt="" height="284" id="ube630b2b" src="https://images2.imgbox.com/19/27/pGiRJFPA_o.png" width="373"></p> 
<p id="u7cd93c68">实际运用中这两种方法我们几乎都不用，因为会有<span style="color:#4da8ee;">更好的方法</span>，语言之父已经帮我们迭代过啦</p> 
<pre id="oHpzf"><code>for (auto&amp; str : arr) {
	count_map[str]++;
}</code></pre> 
<p id="u003e641e">根据上面我们可以知道，底层返回的实现</p> 
<pre id="rzskK"><code>mapped_type&amp; operator[] (const key_type&amp; k) {
	pair&lt;iterator, bool&gt; ret = insert(make_pair(k, mapped_type()));
	// return (*(ret.first)).second;
	return ret.first-&gt;second;
}</code></pre> 
<p id="u6bb3c35a">如果是第一次出现，就先插入。插入成功后会返回插入的节点中的次数 0 的引用，对它 ++ 后变为 1。如果是第二次插入，<span style="color:#4da8ee;">插入失败，会返回它所在节点的迭代器的次数，再 ++</span>。</p> 
<hr id="Dha2L"> 
<p id="u715ef68f">然后这个地方的使用不仅联想到了 hash ，讲个题外的知识点，将两者做个比较：</p> 
<p id="u619a1bc9"><span style="color:#4da8ee;"><code>std::map</code>和<code>std::unordered_map</code>（</span>通常称为hash map）是C++标准库中提供的两种关联容器，它们的主要区别在于内部实现和性能特征上。</p> 
<h4 id="CL9tQ"><code>std::map</code></h4> 
<blockquote> 
 <ul><li id="u09e07b3d"><strong>内部实现</strong>：<code>std::map</code>使用<span style="color:#4da8ee;">红黑树</span>（一种自平衡的二叉搜索树）作为底层数据结构。这意味着它的键值对是<span style="color:#b95514;">有序的</span>，按照键的自然顺序或由比较器定义的顺序排列。</li><li id="u5987e67c"><strong>查找、插入和删除的时间复杂度</strong>：对于<code>std::map</code>，这些操作的时间复杂度为O(log n)，其中n是容器中的元素数量。这是因为<span style="color:#b95514;">每次操作都需要在树中移动log n的距离</span>。</li><li id="u0909fb18"><strong>迭代</strong>：由于<code>std::map</code>保持了键的<span style="color:#4da8ee;">排序</span>，因此迭代访问元素时可以按照键的顺序进行，这对于需要排序访问的场景非常有用。</li></ul> 
</blockquote> 
<h4 id="uycSv"><code>std::unordered_map</code></h4> 
<blockquote> 
 <ul><li id="ucebb274d"><strong>内部实现</strong>：<code>std::unordered_map</code>使用<span style="color:#4da8ee;">哈希表</span>作为底层数据结构。它将键映射到哈希表中的位置，理想情况下，<span style="color:#b95514;">不同的键将映射到不同的位置</span>，从而允许快速查找。</li><li id="u0ab42c53"><strong>查找、插入和删除的时间复杂度</strong>：平均而言，<code>std::unordered_map</code>的查找、插入和删除操作的时间复杂度为<span style="color:#b95514;">O(1)</span>，即常数时间。但在最坏的情况下，如果<span style="color:#b95514;">哈希冲突频繁发生</span>，这些操作可能退化到线性时间复杂度<span style="color:#b95514;">O(n)</span>。</li><li id="u09b32316"><strong>迭代</strong>：<code>std::unordered_map</code>不保证元素的顺序，因此迭代访问元素时，元素的顺序可能是<span style="color:#4da8ee;">任意的，这取决于哈希函数和哈希表的实现</span>。</li></ul> 
</blockquote> 
<h4 id="uSh2s" style="background-color:transparent;">总结</h4> 
<ul><li id="uc54630b8">当你需要键值对保持<span style="color:#4da8ee;">排序</span>时，使用<code>std::map</code>。</li><li id="uce7e231a">当你需要<span style="color:#4da8ee;">快速查找</span>而不关心键值对的顺序时，使用<code>std::unordered_map</code>。</li><li id="u022b3b63"><code>std::map</code>在查找、插入和删除操作上的性能随着容器大小的增长而增长（对数时间复杂度），而<code>std::unordered_map</code>在平均情况下的性能通常是常数时间，但对于特定的输入数据可能会退化。</li></ul> 
<p id="u2f6516d3">选择使用哪种容器应基于你的具体需求：是否需要排序、预期的性能、以及对最坏情况性能的考虑。</p> 
<hr id="VHlxU"> 
<h2 id="sNRHt">2.Multimap 类</h2> 
<p id="u016402cd"></p> 
<p class="img-center"><img alt="" height="151" id="u19323142" src="https://images2.imgbox.com/52/c3/qCA17tRl_o.png" width="915"></p> 
<h5 id="jJJuL">0. 引入：<span style="color:#4da8ee;">不去重的</span> Multi</h5> 
<ul><li id="u1b70658c"><strong>背景</strong>：对于一词多义的情况，例如单词 "left" 可以表示 "左边" 和 "剩余"，需要<span style="color:#4da8ee;">存储同一个键的多个值</span>。</li><li id="uf07a9eba"><strong>解决方案</strong>：使用 <code>multimap</code> 类，类似于 <code>multiset</code>，它允许存储具有相同键的多个值，但仍然保持排序。</li></ul> 
<pre id="tppCV"><code>void test_multimap() {
    multimap&lt;string, string&gt; dict;
    dict.insert(make_pair("left", "左边"));
    dict.insert(make_pair("left", "剩余"));
}</code></pre> 
<ul><li id="u406bbbe0"><strong>特性</strong>：在 <code>map</code> 中，重复插入相同键的元素会导致失败，而在<span style="color:#4da8ee;"> <code>multimap</code> 中，相同键的多次插入均会成功</span>。</li></ul> 
<h5 id="ImR0f">1. Multimap <span style="color:#4da8ee;">不支持 Operator[]</span></h5> 
<ul><li id="u3284bf8d"><strong>原因</strong>：<code>multimap</code> 允许多个键值对拥有相同的键，因此它不支持通过 <code>operator[]</code> 直接访问元素，因为<span style="color:#4da8ee;">该操作符假定键是唯一的</span>。</li></ul> 
<pre id="P9cnQ"><code>int main() {
    multimap&lt;int, std::string&gt; myMultimap;
    myMultimap.insert(make_pair(1, "apple"));
    myMultimap.insert(make_pair(1, "apricot"));
    // myMultimap[1]; // 错误，因为无法确定返回哪个值
}</code></pre> 
<ul><li id="ubc56b6ec"><strong>替代方案</strong>：使用<span style="color:#4da8ee;">迭代器遍历</span>或 <span style="color:#4da8ee;"><code>equal_range</code></span> 函数来获取相同键的值范围。</li></ul> 
<blockquote> 
 <p id="u0fd589e8"><code>equal_range</code> 是 C++ 标准库中的一个函数模板，主要用于在有序容器（如 <code>set</code>, <code>map</code>, <code>vector</code> 等）中查找一个值的范围。它<span style="color:#4da8ee;">返回一对迭代器</span>，表示要查找值在容器中<span style="color:#4da8ee;">第一次出现的位置</span>所在指针（迭代器）和<span style="color:#4da8ee;">最后一次出现的位置指针</span>。</p> 
</blockquote> 
<pre id="zKPVK"><code>auto range = myMultimap.equal_range(1);
for (auto it = range.first; it != range.second; ++it) {
    cout &lt;&lt; "Value: " &lt;&lt; it-&gt;second &lt;&lt; endl;
}</code></pre> 
<h5 id="F2Mnw" style="background-color:transparent;">2. Multimap 的删除</h5> 
<ul><li id="u95325219"><strong>方法</strong>：使用 <code>erase</code> 函数可以删除指定键的元素，例如删除<span style="background-color:#f9eda6;">所有</span>键为 1 的元素。</li></ul> 
<pre id="T92ga"><code>myMultimap.erase(1); // 删除所有键为 1 的元素</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6019b432cebd0bcf01dd4d0078792976/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">pytorch backbone</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7b673be4c6968cef04e1c4ca381eb298/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SpringBoot整合Flink CDC，实时追踪mysql数据变动</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>