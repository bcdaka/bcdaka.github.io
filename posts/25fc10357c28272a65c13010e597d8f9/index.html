<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】二叉搜索树——高阶数据结构的敲门砖 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/25fc10357c28272a65c13010e597d8f9/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】二叉搜索树——高阶数据结构的敲门砖">
  <meta property="og:description" content="目录
树概述
二叉搜索树概述
概念
特性
元素操作
插入
删除
模拟实现
框架
查找
插入
删除
树概述 树——在计算机中是一种很常见的数据结构。
树是一种很强大的数据结构，数据库，linux操作系统管理和windows操作系统管理所有文件的结构就是一颗树形结构
每个树有且只有一个根节点——根节点个数只有一个，节点可存储数据。
根节点往下可以有多个叶子节点，每个叶子节点也可以有多个叶子节点
如下图
每一个节点都可以是父亲节点，每个父亲节点的叶子节点都是孩子节点
根节点的深度为0，最后一层节点的深度为lgN
如果每一层深度的孩子节点的个数小于等于2，便是二叉树
左边的节点称为左孩子节点，右边的节点称为右孩子节点
如下图
如何正确的看一颗二叉树呢？
3是根节点，6作为3的左孩子也可以是一颗子树，这颗树是以6为根节点的树，也是3的左子树。以22为根节点来作为3的右子树也是一样的。
最小的子树是左孩子和右孩子都为空的叶子节点。
也就是说每一个节点都可以作为根节点，从而成为父亲节点的子树，子树又可以拆成子树，直到左右都为空的叶子节点为止（叶子节点也可以看作一颗子树）。
遍历一颗树应该用递归的思维，如下是遍历顺序
二叉树前序遍历：根 ——&gt; 左子树——&gt;右子树
二叉树中序遍历：左子树——&gt;根——&gt;右子树
二叉树后序遍历：左子树——&gt;右子树——&gt;根
二叉树层序遍历：一条龙遍历，可参考【C&#43;&#43;】详解STL的适配器容器之一：优先级队列 priority_queue-CSDN博客
二叉搜索树概述 概念 二叉搜索树是一种二叉树结构，二叉搜索树存储数据时需要符合如下规则（搜索树是支持泛型的，为了方便理解，小编以int类型为例）：
左孩子节点的值 &lt; 父亲节点的值 &lt; 右孩子节点的值
如下示例：
特性 对于所有数据而言，
从整棵树的根节点开始，不断地找左子树，没有左孩子的左子树存的值最小
从整棵树的根节点开始，不断地找右子树，没有右孩子的右子树存的值最大
如果整棵树走中序遍历则是升序
那么用搜索二叉树找一个节点的效率如何呢？
查找的规则很简单，比根节点的值大往右子树走，比根节点的值小往左子树走。每查找一次就能“砍”掉一半数据，只需要查找次。类似于二分查找。
上述查找条件是：整棵树基本符合二叉树结构。如果是比较极端的结构，效率会接近。比如下述结构
二叉搜索树搜索的效率的上限很高，下限很低。
元素操作 插入 二叉搜索树中不允许有相等的值存在，因为要维持 “左树的值小于根小于右数的值” 这一特性。
如果要插入的值在树中不存在，这个值会插入到中间某个位置吗？
答案是不会，因为这个值一定会从整棵树的根节点比到叶子节点，然后插入到叶子节点的后面。如下示意图：
删除 删除的情况比较复杂，大致可以分为两种情况
孩子节点的个数是1或0
假设被删节点为cur，被删节点的父亲节点为fatherNode。
先找是否有cur，找不到，删除失败。
找到了，判断cur是fatherNode的左孩子还是右孩子
是左孩子，让fatherNode的左指针指向cur的孩子节点
是右孩子，让fatherNode的右指针指向cur的孩子节点">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-27T14:50:42+08:00">
    <meta property="article:modified_time" content="2024-05-27T14:50:42+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】二叉搜索树——高阶数据结构的敲门砖</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E6%A0%91%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px;"><a href="#%E6%A0%91%E6%A6%82%E8%BF%B0" rel="nofollow">树概述</a></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%A6%82%E8%BF%B0" rel="nofollow">二叉搜索树概述</a></p> 
<p id="%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%E6%A6%82%E5%BF%B5" rel="nofollow">概念</a></p> 
<p id="%E7%89%B9%E6%80%A7-toc" style="margin-left:40px;"><a href="#%E7%89%B9%E6%80%A7" rel="nofollow">特性</a></p> 
<p id="%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C-toc" style="margin-left:0px;"><a href="#%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C" rel="nofollow">元素操作</a></p> 
<p id="%E6%8F%92%E5%85%A5-toc" style="margin-left:40px;"><a href="#%E6%8F%92%E5%85%A5" rel="nofollow">插入</a></p> 
<p id="%E5%88%A0%E9%99%A4-toc" style="margin-left:40px;"><a href="#%E5%88%A0%E9%99%A4" rel="nofollow">删除</a></p> 
<p id="%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow">模拟实现</a></p> 
<p id="%E6%A1%86%E6%9E%B6-toc" style="margin-left:40px;"><a href="#%E6%A1%86%E6%9E%B6" rel="nofollow">框架</a></p> 
<p id="%E6%9F%A5%E6%89%BE-toc" style="margin-left:40px;"><a href="#%E6%9F%A5%E6%89%BE" rel="nofollow">查找</a></p> 
<p id="%E6%8F%92%E5%85%A5-toc" style="margin-left:40px;"><a href="#%E6%8F%92%E5%85%A5" rel="nofollow">插入</a></p> 
<p id="%E5%88%A0%E9%99%A4-toc" style="margin-left:40px;"><a href="#%E5%88%A0%E9%99%A4" rel="nofollow">删除</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E6%A0%91%E6%A6%82%E8%BF%B0">树概述</h2> 
<p><span style="color:#0d0016;"><strong><span style="background-color:#38d8f0;">树</span></strong></span>——在计算机中是一种很常见的<span style="color:#ed7976;">数据结构</span>。</p> 
<p>树是一种很强大的数据结构，数据库，linux操作系统管理和windows操作系统管理所有文件的结构就是一颗树形结构</p> 
<p>每个树有且只有<span style="color:#ed7976;">一个根节点</span>——根节点个数只有一个，节点可存储数据。</p> 
<p>根节点往下可以有多个<span style="color:#ed7976;">叶子节点</span>，每个叶子节点也可以有多个叶子节点</p> 
<p>如下图</p> 
<p><img alt="" src="https://images2.imgbox.com/5b/14/eZivsV1e_o.png"></p> 
<p>每一个节点都可以是父亲节点，每个父亲节点的叶子节点都是孩子节点</p> 
<p><span style="color:#ed7976;">根节点的深度为0</span>，最后一层节点的深度为lgN</p> 
<p>如果每一层深度的孩子节点的个数<span style="color:#ed7976;">小于等于2</span>，便是二叉树</p> 
<p>左边的节点称为<span style="color:#ed7976;">左孩子节点</span>，右边的节点称为<span style="color:#ed7976;">右孩子节点</span></p> 
<p>如下图</p> 
<p><img alt="" src="https://images2.imgbox.com/a3/a6/NMGWkbVF_o.png"></p> 
<p>如何正确的看一颗二叉树呢？</p> 
<p></p> 
<p>3是根节点，6作为3的左孩子也可以是一颗子树，这颗树是以<span style="color:#ed7976;">6为根节点的树</span>，也是3<span style="color:#ed7976;">的左子树</span>。以22为根节点来作为3的右子树也是一样的。</p> 
<p><span style="color:#ed7976;">最小的子树</span>是左孩子和右孩子都为空的<span style="color:#ed7976;">叶子节点</span>。</p> 
<p>也就是说每一个节点都可以作为根节点，从而成为父亲节点的子树，子树又可以拆成子树，直到左右都为空的叶子节点为止（叶子节点也可以看作一颗子树）。</p> 
<p>遍历一颗树应该用递归的思维，如下是遍历顺序</p> 
<p>二叉树前序遍历：<strong><span style="background-color:#38d8f0;">根 ——&gt; 左子树——&gt;右子树</span></strong></p> 
<p>二叉树中序遍历：<strong><span style="background-color:#38d8f0;">左子树——&gt;根——&gt;右子树</span></strong></p> 
<p>二叉树后序遍历：<strong><span style="background-color:#38d8f0;">左子树——&gt;右子树——&gt;根</span></strong></p> 
<p>二叉树层序遍历：一条龙遍历，可参考<a href="https://blog.csdn.net/2301_79796701/article/details/138783390?spm=1001.2014.3001.5501" title="【C++】详解STL的适配器容器之一：优先级队列 priority_queue-CSDN博客">【C++】详解STL的适配器容器之一：优先级队列 priority_queue-CSDN博客</a></p> 
<h2 id="%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%A6%82%E8%BF%B0">二叉搜索树概述</h2> 
<h3 id="%E6%A6%82%E5%BF%B5">概念</h3> 
<p><span style="color:#ed7976;">二叉搜索树是一种二叉树结构</span>，二叉搜索树存储数据时需要符合如下规则（搜索树是支持泛型的，为了方便理解，小编以int类型为例）：</p> 
<p><strong><span style="background-color:#38d8f0;">左孩子节点的值 &lt; 父亲节点的值 &lt; 右孩子节点的值</span></strong></p> 
<p>如下示例：</p> 
<p><img alt="" src="https://images2.imgbox.com/45/72/u85VieIp_o.png"></p> 
<h3 id="%E7%89%B9%E6%80%A7">特性</h3> 
<p>对于所有数据而言，</p> 
<p>从整棵树的根节点开始，<strong><span style="background-color:#38d8f0;">不断地找左子树，没有左孩子的左子树存的值最小</span></strong></p> 
<p>从整棵树的根节点开始，<strong><span style="background-color:#38d8f0;">不断地找右子树，没有右孩子的右子树存的值最大</span></strong></p> 
<p>如果整棵树走<span style="color:#ed7976;">中序遍历则是升序</span></p> 
<p>那么用搜索二叉树找一个节点的效率如何呢？</p> 
<p>查找的规则很简单，比根节点的值大往右子树走，比根节点的值小往左子树走。<span style="color:#ed7976;">每查找一次就能“砍”掉一半数据</span>，只需要查找<img alt="log N" class="mathcode" src="https://images2.imgbox.com/66/14/bom50Xhc_o.png">次。类似于二分查找。</p> 
<p>上述查找条件是：整棵树基本符合二叉树结构。如果是比较极端的结构，效率会接近<img alt="N^2" class="mathcode" src="https://images2.imgbox.com/16/d2/HRsjOyfw_o.png">。比如下述结构</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/72/63/6MDMS5la_o.png"></p> 
<p>二叉搜索树<span style="color:#ed7976;">搜索的效率的上限很高，下限很低</span>。</p> 
<h2 id="%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C">元素操作</h2> 
<h3 id="%E6%8F%92%E5%85%A5">插入</h3> 
<p>二叉搜索树中<span style="color:#ed7976;">不允许有相等的值</span>存在，因为要维持 “左树的值小于根小于右数的值” 这一特性。</p> 
<p>如果要插入的值在树中不存在，这个值会插入到中间某个位置吗？</p> 
<p>答案是不会，因为<span style="color:#ed7976;">这个值一定会从整棵树的根节点比到叶子节点，然后插入到叶子节点的后面</span>。如下示意图：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/13/3c/aRy2H2se_o.png"></p> 
<h3 id="%E5%88%A0%E9%99%A4">删除</h3> 
<p>删除的情况比较复杂，大致可以分为两种情况</p> 
<p><strong>孩子节点的个数是1或0</strong></p> 
<p>假设被删节点为<span style="color:#38d8f0;">cur</span>，被删节点的父亲节点为<span style="color:#38d8f0;">fatherNode</span>。</p> 
<p>先找是否有<span style="color:#38d8f0;">cur</span>，找不到，删除失败。</p> 
<p>找到了，判断<span style="color:#38d8f0;">cur</span>是<span style="color:#38d8f0;">fatherNode</span>的左孩子还是右孩子</p> 
<p>是左孩子，让<span style="color:#38d8f0;">fatherNode</span>的左指针指向cur的孩子节点</p> 
<p>是右孩子，让<span style="color:#38d8f0;">fatherNode</span>的右指针指向cur的孩子节点</p> 
<p>如果没有孩子节点，则<span style="color:#38d8f0;">fatherNode</span>的指针指向空</p> 
<p>改变指向关系后整棵树就没有<span style="color:#38d8f0;">cur</span>节点了，最后释放<span style="color:#38d8f0;">cur</span>的内存</p> 
<p><span style="color:#38d8f0;">fatherNode</span><span style="color:#0d0016;">的左孩子被删应该有新的左孩子接替，右孩子应该有新的右孩子接替，这样才不会破坏二叉搜索树的结构，所以要判断</span><span style="color:#38d8f0;">cur</span><span style="color:#0d0016;">是</span><span style="color:#38d8f0;">fatherNode</span><span style="color:#0d0016;">的左孩子还是右孩子</span></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/cf/4d/0Ww0Cp8O_o.png"></p> 
<p><strong>孩子节点的个数是2</strong></p> 
<p>孩子节点是1或0的时候只需改变指向关系，然后再释放被删节点的内存即可。</p> 
<p></p> 
<p><strong>那么被删节点的孩子个数是两个的时候还能这么做吗？</strong></p> 
<p>显然是不能的，因为一个<span style="color:#ed7976;">父亲节点最多只能有两个孩子节点</span>。</p> 
<p></p> 
<p><strong>删除孩子节点的个数是2的节点，最核心的思想是：</strong></p> 
<p><span style="color:#0d0016;">被删节点为</span><span style="color:#38d8f0;">cur</span><span style="color:#ed7976;">，</span><span style="color:#0d0016;">但不直接删</span><span style="color:#38d8f0;">cur</span><span style="color:#0d0016;">这个节点</span>，因为这样会破坏这颗树的结构。</p> 
<p>找<span style="color:#0d0016;">一个孩子节点为1或0的节点为</span><span style="color:#38d8f0;">leftMax_Node</span>，让<span style="color:#38d8f0;">leftMax_Node</span>节点的值和<span style="color:#38d8f0;">cur</span>节点的<span style="color:#ed7976;">值</span>交换，然后删<span style="color:#38d8f0;">leftMax_Node</span>节点</p> 
<p>通过<span style="color:#ed7976;">替换的方法</span>就完成了<span style="color:#38d8f0;">cur</span>节点的删除</p> 
<p></p> 
<p><strong>那么怎么找孩子节点为1或0的节点呢？</strong></p> 
<p><strong><span style="background-color:#38d8f0;">左子树的最大节点</span></strong><span style="color:#ed7976;">或</span><strong><span style="background-color:#38d8f0;">右子树的最小节点</span></strong></p> 
<p><span style="color:#0d0016;"><strong>注意：</strong></span><span style="color:#fe2c24;"><strong>是被删节点</strong></span><span style="color:#38d8f0;"><strong>cur</strong></span><span style="color:#fe2c24;"><strong>的左树（右树），而不是整棵树的左树（右树）</strong></span></p> 
<p>在上文二叉树的特性中已经提过，<span style="color:#ed7976;">找最大值或最小值，找的一定是叶子节点</span></p> 
<p>整个二叉搜索树中，左子树存小值，右子树存大值。</p> 
<p>如果选左子树的最大值放在根节点的位置，依旧符合左子树的值小于根小于右子树这一规则，删掉该节点不会破坏二叉树的结构。</p> 
<p>左子树的最大节点或右子树的最小节点是完美的  “<span style="color:#ed7976;">替罪羊</span>” </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a7/bf/Wyj90SA4_o.png"></p> 
<h2 id="%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">模拟实现</h2> 
<p>模板相关知识可参考：</p> 
<p><a href="https://blog.csdn.net/2301_79796701/article/details/138844019?spm=1001.2014.3001.5501" title="【C++】详解C++的模板-CSDN博客">【C++】详解C++的模板-CSDN博客</a></p> 
<p>内存管理相关知识可参考：</p> 
<p><a href="https://blog.csdn.net/2301_79796701/article/details/138157445?spm=1001.2014.3001.5501" title="【C++】C++的内存管理-CSDN博客">【C++】C++的内存管理-CSDN博客</a></p> 
<h3 id="%E6%A1%86%E6%9E%B6">框架</h3> 
<p><strong>节点的设计</strong></p> 
<p>有两个指针指向左右孩子</p> 
<p>在用一个变量存值</p> 
<pre><code class="language-cpp">template &lt;class K&gt;
class BSNode
{
public:

	BSNode(const K&amp; Key = K())
		:_left(nullptr)
		,_right(nullptr) 
		,_key(Key)  
	{
	}

	BSNode&lt;K&gt;* _left;
	BSNode&lt;K&gt;* _right; 
	K _key;

};</code></pre> 
<p><strong>二叉搜索树的设计</strong></p> 
<p><span style="color:#ed7976;">只需要一个节点指针指向整棵树的根节点即可</span></p> 
<pre><code class="language-cpp">template &lt;class K&gt;
class BSTree
{
	typedef BSNode&lt;K&gt; node;

//......

private:

	node* _root;  
};
</code></pre> 
<p></p> 
<h3 id="%E6%9F%A5%E6%89%BE">查找</h3> 
<p>查找的代码很简单，小编就不细讲了。</p> 
<p>有一点要提醒大家，大家<strong><span style="background-color:#38d8f0;">一定要用判断语句把查找条件分开</span></strong>，比根大就往右树查找，比根小就往左树查找。千万不要写成暴力查找——不管值的大小，遍历整棵树</p> 
<p>代码如下</p> 
<pre><code class="language-cpp">bool _FindNode(node* root, const K&amp; key) 
{
	while (root)
	{
		if (root-&gt;_key &lt; key) 
		{
			root = root-&gt;_right;
		}
		else if (root-&gt;_key &gt; key)
		{
			root = root-&gt;_left;
		}
		else
		{
			return false;
		}

		return true;
	}
}</code></pre> 
<p>可以把上述代码设计成私有，再封装一层共有的函数，这样做的意义是不用传节点的指针了</p> 
<pre><code class="language-cpp">bool FindNode(const K&amp; key)
{
	return _FindNode(_root, key);           
}</code></pre> 
<h3>插入</h3> 
<p>接口</p> 
<pre><code class="language-cpp">bool Insert(const K&amp; key) </code></pre> 
<p>首先应该判断整棵树是否为空，如果为空，直接让_root直接指向新节点</p> 
<pre><code class="language-cpp">if (_root == nullptr) //如果为空
{
	_root = new node(key); //头节点指针指向新节点
	return true;
}</code></pre> 
<p>二叉搜索树是不允许有重复的值出现的</p> 
<p>应该再写一遍查找的逻辑，因为_root是指向整棵树的根的，所以需要定义一个临时指针，当我们找到相等的值时，插入失败。</p> 
<pre><code class="language-cpp">node* cur = _root;  
node* fatherNode = nullptr; 

while (cur) 
{
	if (cur-&gt;_key &lt; key) //插入的元素比当前节点的值大，
	{
		fatherNode = cur; //记录父亲节点的指针
		cur = cur-&gt;_right;   //往右树找
	}
	else if (cur-&gt;_key &gt; key)
	{
		fatherNode = cur;
		cur = cur-&gt;_left;
	}
	else
	{
		return false;
	}
}</code></pre> 
<p>没找到的话，说明临时指针已经找到空了，临时指针的父亲节点就是合适的叶子节点了，插在叶子节点的孩子位置即可，是左孩子还是右孩子需要和父亲节点比较大小</p> 
<pre><code class="language-cpp">  node* newNode =  new node(key);
  if (fatherNode-&gt;_key &lt; key)//判断要插入父亲节点的左边还是右边
  {
	  fatherNode-&gt;_right = newNode; 
  }
  else
  {
	  fatherNode-&gt;_left = newNode; 
  }</code></pre> 
<h3>删除</h3> 
<p>接口</p> 
<pre><code class="language-cpp">bool Erase(const K&amp; key)    </code></pre> 
<p>先判断是否是空树</p> 
<pre><code class="language-cpp">if (nullptr == _root)//如果是空树，删除失败
{
	return false;
}</code></pre> 
<p>和插入类似，要判断被删的节点是否存在</p> 
<pre><code class="language-cpp">node* cur = _root; //临时变量，cur是指要删除的节点
node* fatherNode = nullptr; //cur的父亲节点，

while (cur)//找要删除的节点
{
	if (cur-&gt;_key &lt; key) 
	{
		fatherNode = cur;
	cur = cur-&gt;_right;
	}
	else if (cur-&gt;_key &gt; key)
	{
		fatherNode = cur;
		cur = cur-&gt;_left;
	}
	else
	{
		break;
	}
}</code></pre> 
<pre><code class="language-cpp">if (nullptr == cur) //没找到要删除的节点，删除失败
{
	return false;
}</code></pre> 
<p>下面就是要删除节点的逻辑了，上文已经讲了删除的原理，这里细讲代码细节</p> 
<p><strong>孩子节点数量为1或0</strong></p> 
<p>节点的孩子树不管是1还是0，可以只写左孩子为空的情况和右孩子为空的情况，左右孩子都为空的情况可以不写。</p> 
<p>因为左右孩子都为空的情况，可以走左孩子为空的逻辑，只是指向新节点还是指向空的问题。</p> 
<pre><code class="language-cpp">	if (cur-&gt;_left == nullptr) //要删除的节点左为空
	{
		if (cur == _root)  //极端情况，
		{
			_root = cur-&gt;_right;
			delete cur;
			return true;
		}

		if (fatherNode-&gt;_left == cur)  //判断要删除的节点在父亲节点的左边还是右边
			fatherNode-&gt;_left = cur-&gt;_right;
		else                                   //改变指向
			fatherNode-&gt;_right = cur-&gt;_right;

		delete cur; //删除
		return true;

	}
	else if (cur-&gt;_right == nullptr)//要删除的节点右为空
	{
		if (cur == _root) //极端情况
		{
			_root = cur-&gt;_left;  
			delete cur; 
			return true;
		}

		if (fatherNode-&gt;_left == cur)  //判断要删除的节点在父亲节点的左边还是右边
			fatherNode-&gt;_left = cur-&gt;_left; 
		else                               //改变指向
			fatherNode-&gt;_right = cur-&gt;_left; 

		delete cur; //删除节点
		return true;
	}</code></pre> 
<p>极端情况做了特殊处理</p> 
<p>极端情况如下图所示</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/cf/e6/67LzBp9f_o.png"></p> 
<p><strong>孩子节点数量为2</strong></p> 
<pre><code class="language-cpp">else //要删除的节点左右都不为空
{
	node* leftMax_Node = cur-&gt;_left;  //左树最大节点 （被删节点的左树）
	node* leftMax_FatherNode = cur; //左树最大节点的父亲节点             

	while (leftMax_Node-&gt;_right)      //找代替节点，左树的最右节点（找左树的最大值）
	{
		leftMax_FatherNode = leftMax_Node; 

		leftMax_Node = leftMax_Node-&gt;_right;     
	}

	std::swap(cur-&gt;_key, leftMax_Node-&gt;_key);   //交换完之后，左树的最大节点就是要删的值了  

	if (leftMax_FatherNode-&gt;_left == leftMax_Node)  //要判断被删节点是父亲节点的左孩子还是右孩子
		leftMax_FatherNode-&gt;_left = leftMax_Node-&gt;_left;
	else
		leftMax_FatherNode-&gt;_right = leftMax_Node-&gt;_left;

	delete leftMax_Node;    
	return true;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c1b17ff6fc83431035bd382172820527/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">前端fetch 实现流式接口</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9ffc1d2e50d95dee49960503c43c234e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">字符串函数（2）＜C语言＞</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>