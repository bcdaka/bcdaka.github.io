<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>1.初识redis - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/a7ecd7a570ebd3cce47abe6035f38de2/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="1.初识redis">
  <meta property="og:description" content="文章目录 1.认识redis1.1 mysql和redis 对比1.2分布式系统1.2.1单机架构与分布式架构1.2.2数据库分离(应用服务器和存储服务器分离)与负载均衡1.2.3负载均衡器1.2.4 数据库读写分离1.2.5 数据库服务器引入缓存1.2.6数据库分库分表1.2.7 引入微服务 2.常见概念解释2.1 应用(Application)/系统(System)2.2 模块(Module)/组件(Component)2.3 分布式(Distributed)2.4 集群(Cluster)2.5 主(Master)/从(Slave)2.6 中间件(Middleware)2.7可用性(Availability)2.8 响应时长(Response Time RT)2.9吞吐(Throughput) vs 并发 (Concurrent) 3.总结 大家好，我是晓星航。今天为大家带来的是 初始redis 相关的讲解！😀
1.认识redis Redis是一个 客户端-服务器 结构的程序。
redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)和zset(有序集合)。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。
Redis 是在分布式系统中,才能发挥威力的~~
众所周知，进程是有隔离性的，进程间的通信要依赖网络。而我们的redis就是基于网络，可以把自己内存中的变量给别的进程使，甚至别的主机的进程进行使用。
如果只是单机程序,直接通过变量存储数据的方式是比使用 Redis 更优的选择
1.1 mysql和redis 对比 MySQL 最大的问题在于,访问速度比较慢~~
很多互联网产品中,对于性能要求是很高~~
但是redis访问速度很快，与mysql对比redis最大的劣势就是存储空间是很有限的。
那么怎么样可以使我们存储空间又大，访问速度又快呢？
典型的方案,可以把 Redis 和 MySQL 结合起来使用
引入的问题：系统的复杂程度大大提升了，而且如果数据发生修改，还涉及到redis和mysql之间的数据同步问题。
1.2分布式系统 1.2.1单机架构与分布式架构 单机架构：只有一台服务器，这个服务器负责所有的工作
假设这是一个电商网站
单机程序中,能不能把数据库服务器也去掉,光一个应用服务器又负责业务,又负责数据存储? (也不是不可以,但是就是会比较麻烦)
如果业务进一步增长,用户量和数据量都水涨船高,一台主机难以应付的时候,就需要引入更多的主机,引入更多的硬件资源
一台主机的硬件资源是有上线的！！！
如果我们真的遇到了这样的服务器不够用的场景，怎么处理呢？
1.开源 简单粗暴，增加更多的硬件资源 --&gt; 一台主机拓展到极限了，但还是不够，那么就只能引入多台主机了(分布式)
2.节流 软件上优化。(各凭本事了，需要通过性能测试，找到是哪个环节出现了瓶颈，再去对症下药)
开源到上限引入多台主机(分布式)，这是无奈之举，系统的复杂程度因此会大大提高 --&gt; 出现bug的概率提高 --&gt; 加班概率 &amp; 丢失年终奖的概率 随之提高">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-20T15:15:11+08:00">
    <meta property="article:modified_time" content="2024-08-20T15:15:11+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">1.初识redis</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1redis_4" rel="nofollow">1.认识redis</a></li><li><ul><li><a href="#11_mysqlredis__16" rel="nofollow">1.1 mysql和redis 对比</a></li><li><a href="#12_33" rel="nofollow">1.2分布式系统</a></li><li><ul><li><a href="#121_35" rel="nofollow">1.2.1单机架构与分布式架构</a></li><li><a href="#122_59" rel="nofollow">1.2.2数据库分离(应用服务器和存储服务器分离)与负载均衡</a></li><li><a href="#123_71" rel="nofollow">1.2.3负载均衡器</a></li><li><a href="#124__91" rel="nofollow">1.2.4 数据库读写分离</a></li><li><a href="#125__105" rel="nofollow">1.2.5 数据库服务器引入缓存</a></li><li><a href="#126_121" rel="nofollow">1.2.6数据库分库分表</a></li><li><a href="#127__133" rel="nofollow">1.2.7 引入微服务</a></li></ul> 
  </li></ul> 
  </li><li><a href="#2_181" rel="nofollow">2.常见概念解释</a></li><li><ul><li><a href="#21_ApplicationSystem_183" rel="nofollow">2.1 应用(Application)/系统(System)</a></li><li><a href="#22_ModuleComponent_187" rel="nofollow">2.2 模块(Module)/组件(Component)</a></li><li><a href="#23_Distributed_191" rel="nofollow">2.3 分布式(Distributed)</a></li><li><a href="#24_Cluster_197" rel="nofollow">2.4 集群(Cluster)</a></li><li><a href="#25_MasterSlave_203" rel="nofollow">2.5 主(Master)/从(Slave)</a></li><li><a href="#26_Middleware_209" rel="nofollow">2.6 中间件(Middleware)</a></li><li><a href="#27Availability_219" rel="nofollow">2.7可用性(Availability)</a></li><li><a href="#28_Response_Time_RT_225" rel="nofollow">2.8 响应时长(Response Time RT)</a></li><li><a href="#29Throughput_vs__Concurrent_233" rel="nofollow">2.9吞吐(Throughput) vs 并发 (Concurrent)</a></li></ul> 
  </li><li><a href="#3_239" rel="nofollow">3.总结</a></li></ul> 
</div> 
<p></p> 
<p><strong>大家好，我是晓星航。今天为大家带来的是 初始redis 相关的讲解！😀</strong></p> 
<h2><a id="1redis_4"></a>1.认识redis</h2> 
<p>Redis是一个 客户端-服务器 结构的程序。</p> 
<p>redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(<a href="https://upimg.baike.so.com/doc/630752-667548.html" rel="nofollow">字符串</a>)、list(链表)、set(集合)和zset(有序集合)。这些<a href="https://upimg.baike.so.com/doc/1933730-2045809.html" rel="nofollow">数据类型</a>都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。</p> 
<p>Redis 是在分布式系统中,才能发挥威力的~~</p> 
<p>众所周知，进程是有隔离性的，进程间的通信要依赖网络。而我们的redis就是基于网络，可以把自己内存中的变量给别的进程使，甚至别的主机的进程进行使用。</p> 
<p>如果只是单机程序,直接通过变量存储数据的方式是比使用 Redis 更优的选择</p> 
<h3><a id="11_mysqlredis__16"></a>1.1 mysql和redis 对比</h3> 
<p>MySQL 最大的问题在于,访问速度比较慢~~<br> 很多互联网产品中,对于性能要求是很高~~</p> 
<p>但是redis访问速度很快，与mysql对比redis最大的劣势就是存储空间是很有限的。</p> 
<p>那么怎么样可以使我们存储空间又大，访问速度又快呢？</p> 
<p>典型的方案,可以把 Redis 和 MySQL 结合起来使用</p> 
<p>引入的问题：系统的复杂程度大大提升了，而且如果数据发生修改，还涉及到redis和mysql之间的数据同步问题。</p> 
<h3><a id="12_33"></a>1.2分布式系统</h3> 
<h4><a id="121_35"></a>1.2.1单机架构与分布式架构</h4> 
<p>单机架构：只有一台服务器，这个服务器负责所有的工作</p> 
<p>假设这是一个电商网站</p> 
<p><img src="https://images2.imgbox.com/a4/04/avGJmbxh_o.png" alt="QQ_1722490289060"></p> 
<p>单机程序中,能不能把数据库服务器也去掉,光一个应用服务器又负责业务,又负责数据存储? (也不是不可以,但是就是会比较麻烦)</p> 
<p>如果业务进一步增长,用户量和数据量都水涨船高,一台主机难以应付的时候,就需要引入更多的主机,引入更多的硬件资源</p> 
<p>一台主机的硬件资源是有上线的！！！</p> 
<p><img src="https://images2.imgbox.com/0a/73/XkLQZWET_o.png" alt="QQ_1722490511202"></p> 
<p>如果我们真的遇到了这样的服务器不够用的场景，怎么处理呢？</p> 
<p>1.开源 简单粗暴，增加更多的硬件资源 --&gt; 一台主机拓展到极限了，但还是不够，那么就只能引入多台主机了(分布式)</p> 
<p>2.节流 软件上优化。(各凭本事了，需要通过性能测试，找到是哪个环节出现了瓶颈，再去对症下药)</p> 
<p>开源到上限引入多台主机(分布式)，这是无奈之举，系统的复杂程度因此会大大提高 --&gt; 出现bug的概率提高 --&gt; 加班概率 &amp; 丢失年终奖的概率 随之提高</p> 
<h4><a id="122_59"></a>1.2.2数据库分离(应用服务器和存储服务器分离)与负载均衡</h4> 
<p><img src="https://images2.imgbox.com/eb/d5/QOp6SA0t_o.png" alt="QQ_1722491144526"></p> 
<p>1.机械硬盘，便宜，慢</p> 
<p>2.固态硬盘，贵，快</p> 
<p>引入更多的应用服务器节点</p> 
<p><img src="https://images2.imgbox.com/4a/da/vjAcK0La_o.png" alt="QQ_1722491369630"></p> 
<h4><a id="123_71"></a>1.2.3负载均衡器</h4> 
<p><img src="https://images2.imgbox.com/0f/01/R8rWGmQw_o.png" alt="QQ_1722491699026"></p> 
<p>这里的负载均衡器，看起来承担了所有的请求，他能顶得住吗？</p> 
<p>负载均衡器，对于请求量的承担能力，要远超于应用服务器。</p> 
<p>负载均衡器，是领导，分配工作。</p> 
<p>应用服务器，是组员，执行任务。</p> 
<p>是否会出现，请求量大到负载均衡器也扛不住了呢？也是有可能的！！！</p> 
<p>解决这个问题只需要引入更多的负载均衡器即可(引入多个机房)</p> 
<p>我们这里的负载均衡器和应用服务器可以理解为学校的校长以及老师，校长类似于负载均衡器负责规划学校未来的发展，发布学校平时的活动。而老师就相当于应用服务器，实施校长发布的教学活动，并保证学生们的健康成长！</p> 
<h4><a id="124__91"></a>1.2.4 数据库读写分离</h4> 
<p><img src="https://images2.imgbox.com/f9/9d/gtqAItEc_o.png" alt="QQ_1722492167023"></p> 
<p>我们应用服务器变多了，那存储服务器只有一个会不会发生处理不过来呢？</p> 
<p>答案是肯定的，因此我们把数据库服务器(存储服务器)也增加一个或者几个，并将读写分离开来，将他们分为主(master)数据库和从(slave)数据库。</p> 
<p>我们之前数据库服务器只有一个，他既需要写入也需要读取操作。但现在我们拓展到两个数据库服务器，并把写操作和读操作分开到两个数据库服务器，这样我们数据库服务器的压力便会大大降低，从而达到可以处理更多数据的能力。</p> 
<p>主服务器一般是一个，从服务器可以有多个(一主多从)，同时从数据库通过负载均衡的方式，让应用服务器进行访问。</p> 
<h4><a id="125__105"></a>1.2.5 数据库服务器引入缓存</h4> 
<p>数据库天然有个问题,响应速度是更慢的!</p> 
<p>把数据区分"冷热”，热点数据放到缓存中~缓存的访问速度往往比数据库要快很多了!</p> 
<p><img src="https://images2.imgbox.com/6f/57/tqTisDfb_o.png" alt="QQ_1722492674936"></p> 
<p>这里的缓存很小，因此他只能把频繁要访问的数据放进去</p> 
<p>二八原则：20% 的人持有 80% 的财富~~~</p> 
<p>计算机中的二八原则：</p> 
<p><img src="https://images2.imgbox.com/57/f1/oZjmuQcs_o.png" alt="QQ_1722492714792"></p> 
<h4><a id="126_121"></a>1.2.6数据库分库分表</h4> 
<p>引入分布式系统,不光要能够去应对更高的请求量(并发量),同时也要能应对更大的数据量</p> 
<p>是否可能会出现,一台服务器已经存不下数据了呢?? 当然会存在!!!</p> 
<p>虽然一个服务器, 存储的数据量可以达到 几十个 TB,即使如此也可能会存不下 短视频</p> 
<p>一台主机存不下,就需要多台主机来存储</p> 
<p><img src="https://images2.imgbox.com/6a/12/uJkX4hzk_o.png" alt="QQ_1722493182365"></p> 
<h4><a id="127__133"></a>1.2.7 引入微服务</h4> 
<p>微服务架构</p> 
<p>之前应用服务器,一个服务器程序里面做了很多的业务，这就可能会导致这一个服务器的代码变的越来越复杂</p> 
<p>为了更方便于代码的维护,就可以把这样的一个复杂的服务器,拆分成更多的,功能更单一,但是更小的服务器</p> 
<p><img src="https://images2.imgbox.com/0b/f5/joxetVib_o.png" alt="QQ_1722493588117"></p> 
<p><img src="https://images2.imgbox.com/11/4b/o6LdhRN2_o.png" alt="QQ_1722493598784"></p> 
<p>当应用服务器复杂了势必就需要更多的人来维护了，当人多了,就需要配套的管理,把这些人组织好</p> 
<p>划分组织结构,分成多个组,每个组分别配备领导进行管理</p> 
<p>分成多个组,就需要进行分工</p> 
<p>引入微服务, 解决了人的问题,付出的代价?</p> 
<p>1.系统的性能下降<br> (要想保证性能不下降太多,只能引入更多的机器,更多的硬件资源 =&gt; 充钱)</p> 
<p>拆出来更多的服务,多个功能之间要更依赖 网络通信</p> 
<p>网络通信的速度很可能是比硬盘还慢的!!!</p> 
<p>2.系统复杂程度提高, 可用性收到影响</p> 
<p>服务器更多了,出现问题的概率就更大了</p> 
<p>这就需要一系列的手段,来保证系统的可用性<br> (更丰富的监控报警,以及配套的运维人员)</p> 
<p>微服务的优势：</p> 
<p>1.解决了人的问题</p> 
<p>2.使用微服务，可以更方便于功能的复用</p> 
<p>3.可以给不同的服务进行不同的部署</p> 
<h2><a id="2_181"></a>2.常见概念解释</h2> 
<h3><a id="21_ApplicationSystem_183"></a>2.1 应用(Application)/系统(System)</h3> 
<p>一个应用,就是一个/组 服务器程序</p> 
<h3><a id="22_ModuleComponent_187"></a>2.2 模块(Module)/组件(Component)</h3> 
<p>一个应用,里面有很多个功能. 每个独立的功能,就可以称为是一个 模块/组件</p> 
<h3><a id="23_Distributed_191"></a>2.3 分布式(Distributed)</h3> 
<p>引入多个主机/服务器,协同配合完成一系列的工作.</p> 
<p>物理上的多个主机</p> 
<h3><a id="24_Cluster_197"></a>2.4 集群(Cluster)</h3> 
<p>引入多个主机/服务器,协同配合完成一系列的工作.</p> 
<p>逻辑上的多个主机</p> 
<h3><a id="25_MasterSlave_203"></a>2.5 主(Master)/从(Slave)</h3> 
<p>分布式系统中一种比较典型的结构</p> 
<p>多个服务器节点,其中一个是主,另外的是从,从节点的数据要从主节点这里同步过来</p> 
<h3><a id="26_Middleware_209"></a>2.6 中间件(Middleware)</h3> 
<p>和业务无关的服务(功能更通用的服务)</p> 
<ol><li>数据库</li><li>缓存</li><li>消息队列</li></ol> 
<h3><a id="27Availability_219"></a>2.7可用性(Availability)</h3> 
<p>系统整体可用的时间/总的时间</p> 
<h3><a id="28_Response_Time_RT_225"></a>2.8 响应时长(Response Time RT)</h3> 
<p>衡量服务器的性能，越小越好</p> 
<p>和具体服务器要做的业务密切相关</p> 
<h3><a id="29Throughput_vs__Concurrent_233"></a>2.9吞吐(Throughput) vs 并发 (Concurrent)</h3> 
<p>衡量系统的处理请求的能力。衡量性能的一种方式</p> 
<h2><a id="3_239"></a>3.总结</h2> 
<p><img src="https://images2.imgbox.com/3a/92/xa8NTUaq_o.png" alt="QQ_1722576946275"></p> 
<p><img src="https://images2.imgbox.com/02/b7/6ZsuRBPp_o.png" alt="QQ_1722576974283"></p> 
<p>8 响应时长(Response Time RT)</p> 
<p>衡量服务器的性能，越小越好</p> 
<p>和具体服务器要做的业务密切相关</p> 
<p><em>感谢各位读者的阅读，本文章有任何错误都可以在评论区发表你们的意见，我会对文章进行改正的。如果本文章对你有帮助请动一动你们敏捷的小手点一点赞，你的每一次鼓励都是作者创作的动力哦！😘</em></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/61dd795e84d24a2e3eb5546662be8921/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">《图解设计模式》笔记（三）生成实例</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8d9ec2574fb3c6645e6a7542de9f69c9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Compose（7）交互和动画</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>