<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>unordered_map和set - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/bbae6a867b9a64148999f4401bed2dd1/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="unordered_map和set">
  <meta property="og:description" content="前言：本篇文章继续分享新的容器unordered_map和set。前边我们分享过map和set，其底层为红黑树，而unordered_map和set的底层则为哈希表，因此在unordered_map和set的实现中，我们可以效仿许多在map和set的中就分享过的一些知识，所以在本篇文章中，就不对分享过的知识进行重复讲解。
而unordered_map和set与map和set的区别，即为红黑树和哈希表的区别。
目录
一.修改hash
二.迭代器
三.完整代码
1.unordered_map
2.unordered_set
四.总结
一.修改hash 我们所实现的普通哈希表肯定是无法直接拿来作为unordered_map和set的底层代码的，所以我们需要对其进行优化修改，完整代码如下：
template&lt;class K&gt; struct HashFunc { size_t operator()(const K&amp; key) { return (size_t)key; } }; struct HashStringFunc { size_t operator()(const string&amp; s) { size_t hash = 0; for (auto e : s) { hash &#43;= e; } return hash; } }; namespace hash_bucket { template&lt;class T&gt; struct HashNode { T _data; HashNode&lt;T&gt;* _next; HashNode(const T&amp; data) :_data(data) , _next(nullptr) {} }; //前置声明 template&lt;class K, class T, class KeyOfT, class Hash&gt; class HashTable; template&lt;class K, class T, class KeyOfT, class Hash&gt; struct __Iterator { typedef HashNode&lt;T&gt; Node; typedef __Iterator&lt;K, T, KeyOfT, Hash&gt; Self; Node* _node; HashTable&lt;K, T, KeyOfT, Hash&gt;* _pht; __Iterator(Node* node, HashTable&lt;K, T, KeyOfT, Hash&gt;* pht) :_node(node) ,_pht(pht) {} T&amp; operator*() { return _node-&gt;_data; } T* operator-&gt;() { return &amp;_node-&gt;_data; } Self&amp; operator&#43;&#43;() { if (_node-&gt;_next) //当前桶没走完，找到下一个节点 _node = _node-&gt;_next; else { //当前桶走完了，找下一个不为空的桶的第一个节点 KeyOfT kot; Hash hs; size_t i = hs(kot(_node-&gt;_data)) % _pht-&gt;_tables.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-11T13:05:56+08:00">
    <meta property="article:modified_time" content="2024-07-11T13:05:56+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">unordered_map和set</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>前言</strong>：本篇文章继续分享新的容器unordered_map和set。前边我们分享过map和set，其底层为红黑树，而unordered_map和set的底层则为哈希表，因此在unordered_map和set的实现中，我们可以效仿许多在map和set的中就分享过的一些知识，所以在本篇文章中，就不对分享过的知识进行重复讲解。</p> 
<p>而unordered_map和set与map和set的区别，即为<span style="color:#fe2c24;"><strong>红黑树和哈希表的区别</strong></span>。</p> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.%E4%BF%AE%E6%94%B9hash-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%E4%BF%AE%E6%94%B9hash" rel="nofollow">一.修改hash</a></p> 
<p id="%E4%BA%8C.%E8%BF%AD%E4%BB%A3%E5%99%A8-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%E8%BF%AD%E4%BB%A3%E5%99%A8" rel="nofollow">二.迭代器</a></p> 
<p id="%E4%B8%89.%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;"><a href="#%E4%B8%89.%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow">三.完整代码</a></p> 
<p id="1.unordered_map-toc" style="margin-left:40px;"><a href="#1.unordered_map" rel="nofollow">1.unordered_map</a></p> 
<p id="2.unordered_set-toc" style="margin-left:40px;"><a href="#2.unordered_set" rel="nofollow">2.unordered_set</a></p> 
<p id="%E5%9B%9B.%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E5%9B%9B.%E6%80%BB%E7%BB%93" rel="nofollow">四.总结</a></p> 
<hr> 
<h2 id="%E4%B8%80.%E4%BF%AE%E6%94%B9hash">一.修改hash</h2> 
<p>我们所实现的普通哈希表肯定是<span style="color:#fe2c24;"><strong>无法直接拿来作为unordered_map和set的底层代码</strong></span>的，所以我们需要对其进行优化修改，完整代码如下：</p> 
<pre><code class="language-cpp">template&lt;class K&gt;
struct HashFunc
{
	size_t operator()(const K&amp; key)
	{
		return (size_t)key;
	}
};

struct HashStringFunc
{
	size_t operator()(const string&amp; s)
	{
		size_t hash = 0;
		for (auto e : s)
		{
			hash += e;
		}
		return hash;
	}
};

namespace hash_bucket
{
	template&lt;class T&gt;
	struct HashNode
	{
		T _data;
		HashNode&lt;T&gt;* _next;

		HashNode(const T&amp; data)
			:_data(data)
			, _next(nullptr)
		{}
	};
	//前置声明
	template&lt;class K, class T, class KeyOfT, class Hash&gt;
	class HashTable;

	template&lt;class K, class T, class KeyOfT, class Hash&gt;
	struct __Iterator
	{
		typedef HashNode&lt;T&gt; Node;
		typedef __Iterator&lt;K, T, KeyOfT, Hash&gt; Self;
		Node* _node;
		HashTable&lt;K, T, KeyOfT, Hash&gt;* _pht;
		__Iterator(Node* node, HashTable&lt;K, T, KeyOfT, Hash&gt;* pht)
			:_node(node)
			,_pht(pht)
		{}

		T&amp; operator*()
		{
			return _node-&gt;_data;
		}
		T* operator-&gt;()
		{
			return &amp;_node-&gt;_data;
		}
		Self&amp; operator++()
		{
			if (_node-&gt;_next)
				//当前桶没走完，找到下一个节点
				_node = _node-&gt;_next;
			else
			{
				//当前桶走完了，找下一个不为空的桶的第一个节点
				KeyOfT kot;
				Hash hs;
				size_t i = hs(kot(_node-&gt;_data)) % _pht-&gt;_tables.size();
				i++;
				for (; i &lt; _pht-&gt;_tables.size(); i++)
				{
					if (_pht-&gt;_tables[i])
						break;
				}
				if (i == _pht-&gt;_tables.size())
					//所有桶都走完了，置nullptr
					_node = nullptr;
				else
					_node = _pht-&gt;_tables[i];
			}
			return *this;
		}
		bool operator!=(const Self&amp; s)
		{
			return _node != s._node;
		}
	};

	template&lt;class K, class T, class KeyOfT, class Hash&gt;
	class HashTable
	{
		typedef HashNode&lt;T&gt; Node;
	public:
		//友元
		template&lt;class K, class T, class KeyOfT, class Hash&gt;
		friend struct __Iterator;

		typedef __Iterator&lt;K, T, KeyOfT, Hash&gt; iterator;
		iterator begin()
		{
			for (size_t i = 0; i &lt; _tables.size(); i++)
			{
				Node* cur = _tables[i];
				if (cur)
				{
					return iterator(cur, this);
				}
			}
			return end();
		}
		iterator end()
		{
			return iterator(nullptr, this);
		}
		HashTable()
		{
			_tables.resize(10, nullptr);
			_n = 0;
		}
		~HashTable()
		{
			for (size_t i = 0; i &lt; _tables.size(); i++)
			{
				Node* cur = _tables[i];
				while (cur)
				{
					Node* next = cur-&gt;_next;
					delete cur;

					cur = next;
				}
				_tables[i] = nullptr;
			}
		}
		//插入
		pair&lt;iterator,bool&gt; Insert(const T&amp; data)
		{
			KeyOfT kot;
			Hash hs;
			//判断是否存在
			iterator it = Find(kot(data));
			if (it != end())
				return make_pair(it,false);
			//扩容
			if (_n == _tables.size())
			{
				vector&lt;Node*&gt; newtables(_tables.size() * 2, nullptr);
				for (size_t i = 0; i &lt; _tables.size(); i++)
				{
					Node* cur = _tables[i];
					while (cur)
					{
						Node* next = cur-&gt;_next;
						size_t hashi = hs(kot(cur-&gt;_data)) % newtables.size();
						cur-&gt;_next = newtables[hashi];
						newtables[hashi] = cur;
						cur = next;
					}
					_tables[i] = nullptr;
				}
				_tables.swap(newtables);
			}

			size_t hashi = hs(kot(data)) % _tables.size();
			Node* newnode = new Node(data);
			//头插
			newnode-&gt;_next = _tables[hashi];
			_tables[hashi] = newnode;
			++_n;
			return make_pair(iterator(newnode,this), false);
		}
		//寻找
		iterator Find(const K&amp; key)
		{
			KeyOfT kot;
			Hash hs;
			size_t hashi = hs(key) % _tables.size();
			Node* cur = _tables[hashi];
			while (cur)
			{
				if (kot(cur-&gt;_data) == key)
					return iterator(cur,this);
				cur = cur-&gt;_next;
			}
			return end();
		}
		bool Erase(const K&amp; key)
		{
			KeyOfT kot;
			Hash hs;
			size_t hashi = hs(key) % _tables.size();
			Node* cur = _tables[hashi];
			Node* prev = nullptr;
			while (cur)
			{
				if (kot(cur-&gt;_data) == key)
				{
					//删除的是第一个节点
					if (prev == nullptr)
					{
						_tables[hashi] = cur-&gt;_next;
					}
					else
					{
						prev-&gt;_next = cur-&gt;_next;
					}
					delete cur;
				}
				else
				{
					prev = cur;
					cur = cur-&gt;_next;
				}
			}
			return false;
		}
	private:
		vector&lt;Node*&gt; _tables;//指针数组
		size_t _n;
	};

}</code></pre> 
<p>这其中包括只对key进行操作的修改，以及当插入的元素为string型时对其进行的特殊处理。都是我们之前所分享过的知识。下面我们重点来看<span style="color:#fe2c24;"><strong>迭代器</strong></span>。</p> 
<hr> 
<h2 id="%E4%BA%8C.%E8%BF%AD%E4%BB%A3%E5%99%A8">二.迭代器</h2> 
<p>先来看整体结构：</p> 
<pre><code class="language-cpp">template&lt;class K, class T, class KeyOfT, class Hash&gt;
	struct __Iterator
	{
		typedef HashNode&lt;T&gt; Node;
		typedef __Iterator&lt;K, T, KeyOfT, Hash&gt; Self;
		Node* _node;
		HashTable&lt;K, T, KeyOfT, Hash&gt;* _pht;
		__Iterator(Node* node, HashTable&lt;K, T, KeyOfT, Hash&gt;* pht)
			:_node(node)
			,_pht(pht)
		{}

		T&amp; operator*()
		{
			return _node-&gt;_data;
		}
		T* operator-&gt;()
		{
			return &amp;_node-&gt;_data;
		}
		Self&amp; operator++()
		{
			if (_node-&gt;_next)
				//当前桶没走完，找到下一个节点
				_node = _node-&gt;_next;
			else
			{
				//当前桶走完了，找下一个不为空的桶的第一个节点
				KeyOfT kot;
				Hash hs;
				size_t i = hs(kot(_node-&gt;_data)) % _pht-&gt;_tables.size();
				i++;
				for (; i &lt; _pht-&gt;_tables.size(); i++)
				{
					if (_pht-&gt;_tables[i])
						break;
				}
				if (i == _pht-&gt;_tables.size())
					//所有桶都走完了，置nullptr
					_node = nullptr;
				else
					_node = _pht-&gt;_tables[i];
			}
			return *this;
		}
		bool operator!=(const Self&amp; s)
		{
			return _node != s._node;
		}
	};</code></pre> 
<p>其中最为重要的莫过于<span style="color:#fe2c24;"><strong>++运算符的重载</strong></span>，因为我们的哈希表是闭散列的哈希桶，所以是以<span style="color:#fe2c24;"><strong>指针数组</strong></span>作为底层。</p> 
<p>在执行++操作时，需要<span style="color:#fe2c24;"><strong>先判断当前节点的next是否存在，存在就直接为next节点，不存在就说明当前节点已经是其所属的桶里的最后一个节点</strong></span>，那么接下来的操作就是去<strong><span style="background-color:#ffd900;">寻找下一个不为空的桶的第一个节点</span></strong>。</p> 
<p>此时我们需要<span style="color:#fe2c24;"><strong>先计算出当前节点在数组中的位置，然后通过循环判断其后边的位置是否存在桶</strong></span>，<strong><span style="background-color:#ffd900;">如果存在，就返回新桶的第一个节点，不存在，就说明所有的桶都走完了，此时返回空指针nullptr</span></strong>。</p> 
<hr> 
<h2 id="%E4%B8%89.%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">三.完整代码</h2> 
<h3 id="1.unordered_map">1.unordered_map</h3> 
<pre><code class="language-cpp">#include"hash.h"
namespace Myunordered_map
{
	template&lt;class K,class V, class Hash = HashFunc&lt;K&gt;&gt;
	class unordered_map
	{
		struct MapKeyOfT
		{
			const K&amp; operator()(const pair&lt;K, V&gt;&amp; kv)
			{
				return kv.first;
			}
		};
	public:
		typedef typename hash_bucket::HashTable&lt;K, pair&lt;const K, V&gt;, MapKeyOfT, Hash&gt;::iterator iterator;
		iterator begin()
		{
			return _ht.begin();
		}
		iterator end()
		{
			return _ht.end();
		}
		V&amp; operator[](const K&amp; key)
		{
			pair&lt;iterator, bool&gt; ret = insert(make_pair(key, V()));
			return ret.first-&gt;second;
		}
		pair&lt;iterator, bool&gt; insert(const pair&lt;K, V&gt;&amp; kv)
		{
			return _ht.Insert(kv);
		}
	private:
		hash_bucket::HashTable&lt;K, pair&lt;const K, V&gt;, MapKeyOfT, Hash&gt; _ht;
	};
}</code></pre> 
<hr> 
<h3 id="2.unordered_set">2.unordered_set</h3> 
<pre><code class="language-cpp">#include"hash.h"
namespace Myunordered_set
{
	template&lt;class K, class Hash = HashFunc&lt;K&gt;&gt;
	class unordered_set
	{
		struct SetKeyOfT
		{
			const K&amp; operator()(const K&amp; key)
			{
				return key;
			}
		};
	public:
		typedef typename hash_bucket::HashTable&lt;K, const K, SetKeyOfT, Hash&gt;::iterator iterator;
		iterator begin()
		{
			return _ht.begin();
		}
		iterator end()
		{
			return _ht.end();
		}
		pair&lt;iterator, bool&gt; insert(const K&amp; key)
		{
			return _ht.Insert(key);
		}
	private:
		hash_bucket::HashTable&lt;K, const K, SetKeyOfT, Hash&gt; _ht;
	};
}</code></pre> 
<hr> 
<h2 id="%E5%9B%9B.%E6%80%BB%E7%BB%93">四.总结</h2> 
<p>关于unordered_map和set就分享这么多，通过前边的知识的分享和掌握，unordered_map和set的实现也是如鱼得水。</p> 
<p>喜欢本篇文章的小伙伴记得一键三连，我们下期再见！</p> 
<h3 id="%C2%A0"></h3> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dcdf4cf52af8645fbd47dc2e7cb60ea7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【鸿蒙学习笔记】通过用户首选项实现数据持久化</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a33151bb33f3d545989e53529bb5c6d3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">请结合一个问题bug，帮忙梳理一下DecorView和Window之间的关系</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>