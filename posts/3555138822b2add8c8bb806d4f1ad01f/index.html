<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>代码规范 —— 数据库规范 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/3555138822b2add8c8bb806d4f1ad01f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="代码规范 —— 数据库规范">
  <meta property="og:description" content="优质博文：IT-BLOG-CN
一、建表规范 【1】表达是与否概率的字段，必须使用is_xxx的方式命令，数据类型是tinyint（1表示是，0表示否）
正例：表达逻辑删除的字段名is_active，0表示删除，1表示未删除。
【2】表名、字段名必须使用小写字母或数字，禁止数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。
MySQL在Windows下不区分大小写，但在Linux下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。
正例：aliyun_admin，rdc_config，level3_name；
反例：AliyunAdmin，rdcConfig，level_3_name；
【3】表名不使用复数名词：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于DO类名也是单数形式，符合表达习惯。
正例：store；
反例：stores；
【4】禁用保留字，如desc、range、match、delayed等，请参考MySQL官方保留字。
【5】主键索引名为pk_字段名；唯一索引名为uk_字段名；普通索引名则为idx_字段名。
主键索引自动生成，名：PRIMARY
正例：uk_storeIdidx_storeId_vehicldId；
【6】小数类型为decimal，禁止使用float和double。
【7】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。
【8】varchar是可变长字符串，不预先分配存储空间，长度不要超过5000，如果存储长度大于此值，定义字段类型为text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。
由于公司规范不允许使用text,推荐超过5000使用多条记录拼接。
【9】表必备四字段：id, (BigInt)datachange_createtime,（Timestamp）catachange_lasttime, （Timestamp）is_active (TinyInt)。
【10】表的命名最好是遵循“业务名称_表的作用”：比如订单相关:表全部以订单开头。
【11】库名与应用名称尽量一致。
【12】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：1.不是频繁修改的字段。2.不是唯一索引的字段。3.不是varchar超长字段，更不能是text字段。
【13】单表行数超过500万行或者单表容量超过2GB，才推荐进行分库分表。
如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表
【14】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。
【15】如果存储的字符串长度几乎相等，使用char定长字符串类型。
二、索引规约 【1】业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。不要因为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。
【2】超过二个表禁止join。需要join的字段，数据类型保持绝对一致；多表关联查询时，保证被关联的字段需要有索引。即使双表join也要注意表索引、SQL性能。
【3】在varchar字段上建立索引时，必须指定索引长度（推荐20），没必要对全字段建立索引，根据实际文本区分度决定索引长度。 索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为20的索引，区分度会高达90%以上，可以使用count(distinct left(列名, 索引长度))/count(*)的区分度来确定。
【4】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。索引文件具有B-Tree的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引.
【5】如果有order by的场景，请注意利用索引的有序性。order by最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort的情况，影响查询性能。
正例：where a=? and b=? order by c;索引：a_b_c。索引如果存在范围查询，那么索引有序性无法利用，如：WHERE a&gt;10 ORDER BY b;索引a_b无法排序。
【6】利用覆盖索引来进行查询操作，避免回表。如果一本书需要知道第11章是什么标题，会翻开第11章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效果，用explain的结果，extra列会出现：using index。
【7】利用延迟关联或者子查询优化超多分页场景：MySQL并不是跳过offset行，而是取offset&#43;N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。
正例：先快速定位需要获取的id段，然后再关联SELECT t1.* FROM 表1 as t1, (select id from 表1 where 条件 LIMIT 100000,20 ) as t2 where t1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-08T05:30:00+08:00">
    <meta property="article:modified_time" content="2024-08-08T05:30:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">代码规范 —— 数据库规范</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>优质博文：<a href="https://it-blog-cn.com/blogs/java/code_specifications.html" rel="nofollow">IT-BLOG-CN</a><br> <img src="https://images2.imgbox.com/a6/97/ZlayMAIK_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_3"></a>一、建表规范</h3> 
<p>【1】表达是与否概率的字段，必须使用<code>is_xxx</code>的方式命令，数据类型是<code>tinyint</code>（<code>1</code>表示是，<code>0</code>表示否）<br> 正例：表达逻辑删除的字段名<code>is_active</code>，<code>0</code>表示删除，<code>1</code>表示未删除。</p> 
<p>【2】表名、字段名必须使用小写字母或数字，禁止数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。<br> <code>MySQL</code>在<code>Windows</code>下不区分大小写，但在<code>Linux</code>下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。<br> 正例：<code>aliyun_admin</code>，<code>rdc_config</code>，<code>level3_name</code>；<br> 反例：<code>AliyunAdmin</code>，<code>rdcConfig</code>，<code>level_3_name</code>；</p> 
<p>【3】表名不使用复数名词：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于<code>DO</code>类名也是单数形式，符合表达习惯。<br> 正例：<code>store</code>；<br> 反例：<code>stores</code>；</p> 
<p>【4】禁用保留字，如<code>desc</code>、<code>range</code>、<code>match</code>、<code>delayed</code>等，请参考<code>MySQL</code>官方保留字。</p> 
<p>【5】主键索引名为<code>pk_</code>字段名；唯一索引名为<code>uk_</code>字段名；普通索引名则为<code>idx_</code>字段名。<br> 主键索引自动生成，名：<code>PRIMARY</code><br> 正例：<code>uk_storeIdidx_storeId_vehicldId</code>；</p> 
<p>【6】小数类型为<code>decimal</code>，禁止使用<code>float</code>和<code>double</code>。</p> 
<p>【7】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。</p> 
<p>【8】<code>varchar</code>是可变长字符串，不预先分配存储空间，长度不要超过<code>5000</code>，如果存储长度大于此值，定义字段类型为<code>text</code>，独立出来一张表，用主键来对应，避免影响其它字段索引效率。<br> 由于公司规范不允许使用<code>text</code>,推荐超过<code>5000</code>使用多条记录拼接。</p> 
<p>【9】表必备四字段：<code>id</code>, <code>(BigInt)datachange_createtime</code>,<code>（Timestamp）catachange_lasttime</code>, <code>（Timestamp）is_active (TinyInt)</code>。</p> 
<p>【10】表的命名最好是遵循“业务名称_表的作用”：比如订单相关:表全部以订单开头。</p> 
<p>【11】库名与应用名称尽量一致。</p> 
<p>【12】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：1.不是频繁修改的字段。2.不是唯一索引的字段。3.不是<code>varchar</code>超长字段，更不能是<code>text</code>字段。</p> 
<p><font color="red">【13】单表行数超过<code>500</code>万行或者单表容量超过<code>2GB</code>，才推荐进行分库分表。</font><br> 如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表</p> 
<p>【14】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。</p> 
<p>【15】如果存储的字符串长度几乎相等，使用<code>char</code>定长字符串类型。</p> 
<h3><a id="_44"></a>二、索引规约</h3> 
<p>【1】业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。不要因为唯一索引影响了<code>insert</code>速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。</p> 
<p>【2】超过二个表禁止<code>join</code>。需要<code>join</code>的字段，数据类型保持绝对一致；多表关联查询时，保证被关联的字段需要有索引。即使双表<code>join</code>也要注意表索引、<code>SQL</code>性能。</p> 
<p><font color="red">【3】在<code>varchar</code>字段上建立索引时，必须指定索引长度（推荐<code>20</code>），没必要对全字段建立索引，根据实际文本区分度决定索引长度。</font> 索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为<code>20</code>的索引，区分度会高达<code>90%</code>以上，可以使用<code>count(distinct left(列名, 索引长度))/count(*)</code>的区分度来确定。</p> 
<p>【4】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。索引文件具有<code>B-Tree</code>的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引.</p> 
<p>【5】如果有<code>order by</code>的场景，请注意利用索引的有序性。<code>order by</code>最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现<code>file_sort</code>的情况，影响查询性能。<br> 正例：<code>where a=? and b=? order by c</code>;索引：<code>a_b_c</code>。索引如果存在范围查询，那么索引有序性无法利用，如：<code>WHERE a&gt;10 ORDER BY b</code>;索引<code>a_b</code>无法排序。</p> 
<p>【6】利用覆盖索引来进行查询操作，避免回表。如果一本书需要知道第<code>11</code>章是什么标题，会翻开第<code>11</code>章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效果，用<code>explain</code>的结果，<code>extra</code>列会出现：<code>using index</code>。</p> 
<p>【7】利用延迟关联或者子查询优化超多分页场景：<code>MySQL</code>并不是跳过<code>offset</code>行，而是取<code>offset+N</code>行，然后返回放弃前<code>offset</code>行，返回<code>N</code>行，那当<code>offset</code>特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行<code>SQL</code>改写。<br> 正例：先快速定位需要获取的<code>id</code>段，然后再关联<code>SELECT t1.* FROM 表1 as t1, (select id from 表1 where 条件 LIMIT 100000,20 ) as t2 where t1.id=t2.id</code></p> 
<p>【8】<code>SQL</code>性能优化的目标：至少要达到<code>range</code>级别，要求是<code>ref</code>级别，如果可以是<code>consts</code>最好。<br> 1）<code>consts</code>单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。<br> 2）<code>ref</code>指的是使用普通的索引<code>normal index</code>。<br> 3）<code>range</code>对索引进行范围检索。<br> <code>explain</code>表的结果，<code>type=index</code>索引物理文件全扫描，速度非常慢，这个<code>index</code>级别比较<code>range</code>还低，与全表扫描是小巫见大巫。</p> 
<p>【9】建组合索引的时候，区分度最高的在最左边。存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：<code>where c&gt;? and d=?</code>那么即使<code>c</code>的区分度更高，也必须把<code>d</code>放在索引的最前列，即建立组合索引<code>idx_d_c</code>。如果<code>where a=? and b=?</code>，<code>a</code>列的几乎接近于唯一值，那么只需要单建<code>idx_a</code>索引即可。</p> 
<p>【10】防止因字段类型不同造成的隐式转换，导致索引失效。当操作符与不同类型的操作数一起使用时，会发生类型转换以使操作数兼容。则会发生转换隐式。<br> 隐式类型转换规则:》如果一个或两个参数都是<code>NULL</code>，比较的结果是<code>NULL</code>，除了<code>NULL</code>安全的<code>&lt;=&gt;</code>相等比较运算符。对于<code>NULL &lt;=&gt; NULL</code>，结果为<code>true</code>。不需要转换》如果比较操作中的两个参数都是字符串，则将它们作为字符串进行比较。》如果两个参数都是整数，则将它们作为整数进行比较。》如果不与数字进行比较，则将十六进制值视为二进制字符串》如果其中一个参数是十进制值，则比较取决于另一个参数。 如果另一个参数是十进制或整数值，则将参数与十进制值进行比较，如果另一个参数是浮点值，则将参数与浮点值进行比较》如果其中一个参数是<code>TIMESTAMP</code>或<code>DATETIME</code>列，另一个参数是常量，则在执行比较之前将常量转换为时间戳。》在所有其他情况下，参数都是作为浮点数（实数）比较的。<br> 正例：假如<code>orderId</code>为<code>varchar</code>类型：<code>select * from order_main where order_id='1234'</code><br> 反例：假如<code>orderId</code>为<code>varchar</code>类型：<code>select * from order_main where order_id=1234</code></p> 
<p>【11】创建索引时避免有如下极端误解：1）索引宁滥勿缺。认为一个查询就需要建一个索引。2）吝啬索引的创建。认为索引会消耗空间、严重拖慢记录的更新以及行的新增速度。3）抵制惟一索引。认为惟一索引一律需要在应用层通过“先查后插”方式解决。</p> 
<p>【12】<font color="red"><b>最左前缀匹配原则</b></font>，非常重要的原则，<code>mysql</code>会一直向右匹配直到遇到范围查询(<code>&gt;</code>、<code>&lt;</code>、<code>between</code>、<code>like</code>)就停止匹配，比如<code>a = 1 and b = 2 and c &gt; 3 and d = 4</code>如果建立<code>(a,b,c,d)</code>顺序的索引，<code>d</code>是用不到索引的，如果建立<code>(a,b,d,c)</code>的索引则都可以用到，<code>a,b,d</code>的顺序可以任意调整。</p> 
<p>【13】<code>=</code>和<code>in</code>可以乱序，比如<code>a = 1 and b = 2 and c = 3</code>建立<code>(a,b,c)</code>索引可以任意顺序，<code>mysql</code>的查询优化器会帮你优化成索引可以识别的形式。</p> 
<p>【14】尽量选择区分度高的列作为索引，区分度的公式是<code>count(distinct col)/count(*)</code>，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是<code>1</code>，而一些状态、性别字段可能在大数据面前区分度就是<code>0</code>，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要<code>join</code>的字段我们都要求是<code>0.1</code>以上，即平均<code>1</code>条扫描<code>10</code>条记录。</p> 
<p>【15】索引列不能参与计算，保持列“干净”，比如<code>from_unixtime(create_time) = ’2014-05-29’</code>就不能使用到索引，原因很简单，<code>b+</code>树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成<code>create_time = unix_timestamp(’2014-05-29’)</code>。</p> 
<p>【16】尽量的扩展索引，不要新建索引。比如表中已经有<code>a</code>的索引，现在要加<code>(a,b)</code>的索引，那么只需要修改原来的索引即可。</p> 
<p>【17】业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引.</p> 
<p>【18】合理使用索引，同时需要避免过多创建索引，浪费资源 。</p> 
<p><a href="https://tech.meituan.com/2014/06/30/mysql-index.html" rel="nofollow">美团一篇索引文章，讲的不错。</a></p> 
<h3><a id="sql__92"></a>三、sql 语句</h3> 
<p>【1】不要使用<code>count(列名)</code>或<code>count(常量)</code>来替代<code>count(*)</code>，<code>count(*)</code>是<code>SQL92</code>定义的标准统计行数的语法，跟数据库无关，跟<code>NULL</code>和非<code>NULL</code>无关。<code>count(*)</code>会统计值为<code>NULL</code>的行，而<code>count(列名)</code>不会统计此列为<code>NULL</code>值的行。</p> 
<p>【2】<code>count(distinct col)</code>计算该列除<code>NULL</code>之外的不重复行数，注意<code>count(distinct col1, col2)</code>如果其中一列全为<code>NULL</code>，那么即使另一列有不同的值，也返回为<code>0</code>。</p> 
<p>【3】当某一列的值全是<code>NULL</code>时，<code>count(col)</code>的返回结果为<code>0</code>，但<code>sum(col)</code>的返回结果为<code>NULL</code>，因此使用<code>sum()</code>时需注意<code>NPE</code>问题。</p> 
<p>【4】使用<code>ISNULL()</code>来判断是否为<code>NULL</code>值。<code>NULL</code>与任何值的直接比较都为<code>NULL</code>。1）<code>NULL&lt;&gt;NULL</code>的返回结果是<code>NULL</code>，而不是<code>false</code>。2）<code>NULL=NULL</code>的返回结果是<code>NULL</code>，而不是<code>true</code>。3）<code>NULL&lt;&gt;1</code>的返回结果是<code>NULL</code>，而不是<code>true</code>。<br> 在<code>SQL</code>语句中，如果在<code>null</code>前换行，影响可读性。<code>select * from table where column1 is null and column3 is not null</code>; 而<code>ISNULL(column)</code>是一个整体，简洁易懂。从性能数据上分析，<code>ISNULL(column)</code>执行效率更快一些。</p> 
<p>【5】代码中写分页查询逻辑时，若<code>count</code>为<code>0</code>应直接返回，避免执行后面的分页语句。</p> 
<p>【6】不得使用外键与级联，一切外键概念必须在应用层解决。（概念解释）学生表中的<code>student_id</code>是主键，那么成绩表中的<code>student_id</code>则为外键。如果更新学生表中的<code>student_id</code>，同时触发成绩表中的<code>student_id</code>更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</p> 
<p>【7】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p> 
<p>【8】数据订正（特别是删除或修改记录操作）时，要先<code>select</code>，避免出现误删除，确认无误才能执行更新语句。</p> 
<p>【9】对于数据库中表记录的查询和变更，只要涉及多个表，都需要在列名前加表的别名（或表名）进行限定。对多表进行查询记录、更新记录、删除记录时，如果对操作列没有限定表的别名（或表名），并且操作列在多个表中存在时，就会抛异常。 <br> 正例：<code>select t1.name from table_first as t1, table_second as t2 where t1.id=t2.id;</code><br> 反例：在某业务中，由于多表关联查询语句没有加表的别名（或表名）的限制，正常运行两年后，最近在某个表中增加一个同名字段，在预发布环境做数据库变更后，线上查询语句出现出<code>1052</code>异常：<code>Column 'name' in field list is ambiguous</code>。</p> 
<p>【10】<code>in</code>操作能避免则避免，若实在避免不了，需要仔细评估<code>in</code>后边的集合元素数量，控制在<code>1000</code>个之内。</p> 
<p>【11】<code>SQL</code>语句中表的别名前加<code>as</code>，并且以<code>t1</code>、<code>t2</code>、<code>t3</code>、<code>...</code>的顺序依次命名。1）别名可以是表的简称，或者是依照表在<code>SQL</code>语句中出现的顺序，以<code>t1</code>、<code>t2</code>、<code>t3</code>的方式命名。2）别名前加<code>as</code>使别名更容易识别。<br> 正例：<code>select t1.name from table_first as t1,table_second as t2 where t1.id=t2.id;</code></p> 
<p>【12】因国际化需要，所有的字符存储与表示，均采用<code>utf8mb64</code>字符集，那么字符计数方法需要注意。<code>SELECT LENGTH("轻松工作")</code>； 返回为<code>12</code>。<code>SELECT CHARACTER_LENGTH("轻松工作")</code>； 返回为<code>4</code>如果需要存储表情，那么选择<code>utf8mb4</code>来进行存储，注意它与<code>utf8</code>编码的区别。</p> 
<p>【13】<code>TRUNCATE TABLE</code>比<code>DELETE</code>速度快，且使用的系统和事务日志资源少，但<code>TRUNCATE</code>无事务且不触发<code>trigger</code>，有可能造成事故，故不建议在开发代码中使用此语句。<code>TRUNCATE TABLE</code>在功能上与不带<code>WHERE</code>子句的<code>DELETE</code>语句相同。</p> 
<h3><a id="orm_123"></a>四、orm映射</h3> 
<p>【1】在表查询中，一律不要使用<code>*</code>作为查询的字段列表，需要哪些字段必须明确写明。1）增加查询分析器解析成本。2）增减字段容易与<code>resultMap</code>配置不一致。3）无用字段增加网络消耗，尤其是<code>text</code>类型的字段。</p> 
<p>【2】更新数据表记录时，必须同时更新记录对应的<code>data_last_time</code>字段值为当前时间。</p> 
<p>【3】不要写一个大而全的数据更新接口。传入为<code>POJO</code>类，不管是不是自己的目标更新字段，都进行<code>update table set c1=value1,c2=value2,c3=value3;</code> 这是不对的。执行<code>SQL</code>时，不要更新无改动的字段，一是易出错；二是效率低；三是增加<code>binlog</code>存储。</p> 
<p>【4】<code>@Transactional</code>事务不要滥用。事务会影响数据库的<code>QPS</code>，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。</p> 
<h3><a id="_132"></a>五、事务使用规范</h3> 
<p>【1】一个事务里面，避免一次处理太多数据。</p> 
<p>【2】在一个事务里面，尽量避免不必要的查询。</p> 
<p>【3】在一个事务里面，避免耗时太多的操作，造成事务超时。一些非<code>DB</code>的操作，比如<code>rpc</code>调用，消息队列的操作尽量放到事务之外操作。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cc55627f21bb2c15e69d57b239c23acd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Self-study Python Fish-C Note15 P52to53</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8e02456a1aaf818c07e2d3a8e711bb3f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C&#43;&#43;】初识面向对象：类与对象详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>