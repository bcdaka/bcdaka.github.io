<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】快速排序 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/dc0c4c5b62abc77bf65dfd9fc0e0c498/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】快速排序">
  <meta property="og:description" content="快速排序是通过对序列不断划分，把原始序列以划分元素为界形成两个子序列，再对子序列重复划分的过程。这是一个递归的过程，终止条件就是最终所有的子序列都只含有一个元素。
首先需要一个数组序列，再对其进行划分（重点就是划分）。每次划分都需要设置前后两个指针（low和high），两个指针依次往中间位置移动，当指针重合时，结束这一次划分，还需要设置一个枢轴（temp）。最后的结果分三块，第一块的元素都小于第二块元素，第三块都大于第二块。所以第一次划分大概如下图：
现在讲一下两个指针是如何将序列划分的：先是从high指针往前走，如果high指针所指向的数比枢轴（temp）大的话则继续往前走，直到碰见比枢轴小的数时将这个high指针所指向的数复值给low指针指向的位置。接着就从low指针开始往后走，当遇见比枢轴（temp）大的数就将low指针所指向的数复值给high现在指向的位置。重复以上操作，直至high和low指针指向同一个位置是停止上面的操作，但是需要将枢轴（temp）的数复值给这个位置上的数。这样就出现了三块序列。
int partition(int arr[], int low, int high) { int temp = arr[low]; while (low &lt; high) { while (arr[high] &gt;= temp &amp;&amp; low &lt; high) { high--; } if (arr[high] &lt; temp) { arr[low] = arr[high]; low&#43;&#43;; } while (arr[low] &lt;= temp &amp;&amp; low &lt; high) { low&#43;&#43;; } if (arr[low] &gt; temp) { arr[high] = arr[low]; high--; } } arr[low] = temp; return low; } 再接下来就是重复操作，从第一块中再分三块，也需要前后指针以及枢轴。我就不再重复了，就划分好的序列画出来：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-23T15:55:07+08:00">
    <meta property="article:modified_time" content="2024-05-23T15:55:07+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】快速排序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:justify;">       快速排序是通过对序列不断划分，把原始序列以划分元素为界形成两个子序列，再对子序列重复划分的过程。这是一个<strong>递归</strong>的过程，终止条件就是<u>最终所有的子序列都只含有一个元素</u>。</p> 
<p style="text-align:justify;">       首先需要一个数组序列，再对其进行划分（重点就是划分）。每次划分都需要设置前后两个指针（low和high），两个指针依次往中间位置移动，<strong>当指针重合时，结束这一次划分</strong>，还需要设置一个枢轴（temp）。最后的结果分三块，第一块的元素都小于第二块元素，第三块都大于第二块。所以第一次划分大概如下图：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/31/aa/vkByUOu8_o.png"></p> 
<p style="text-align:justify;">       现在讲一下两个指针是如何将序列划分的：先是从high指针往前走，如果high指针所指向的数比枢轴（temp）大的话则继续往前走，直到碰见比枢轴小的数时将这个high指针所指向的数复值给low指针指向的位置。接着就从low指针开始往后走，当遇见比枢轴（temp）大的数就将low指针所指向的数复值给high现在指向的位置。重复以上操作，直至high和low指针指向同一个位置是停止上面的操作，但是需要将枢轴（temp）的数复值给这个位置上的数。这样就出现了三块序列。</p> 
<pre><code class="hljs">int partition(int arr[], int low, int high)
{
	int temp = arr[low];
	while (low &lt; high)
	{
		while (arr[high] &gt;= temp &amp;&amp; low &lt; high)
		{
			high--;
		}
		if (arr[high] &lt; temp)
		{
			arr[low] = arr[high];
			low++;
		}
		while (arr[low] &lt;= temp &amp;&amp; low &lt; high)
		{
			low++;
		}
		if (arr[low] &gt; temp)
		{
			arr[high] = arr[low];
			high--;
		}
	}
	arr[low] = temp;
	return low;
}</code></pre> 
<p> </p> 
<p style="text-align:justify;">       再接下来就是重复操作，从第一块中再分三块，也需要前后指针以及枢轴。我就不再重复了，就划分好的序列画出来：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/0d/1f/N5ygSknq_o.png"></p> 
<p>      第三块也是一样的操作 ，如下图：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/74/82/hrMtTMBe_o.png"></p> 
<pre><code class="hljs">void quicksort(int arr[], int low, int high)
{
	int k;
	if (low &lt; high)
	{
		k = partition(arr, low, high);
		quicksort(arr, low, k - 1);//第一块序列
		quicksort(arr, k + 1, high);第三块序列
	}
}</code></pre> 
<p> </p> 
<p>一直重复上面操作，直至出现 ：</p> 
<p><img alt="" src="https://images2.imgbox.com/7b/ec/3lLanmxN_o.png"></p> 
<p>       这就是就是快速排序的所有步骤。</p> 
<p>       现在我把从头到尾的代码发出来：</p> 
<pre><code class="hljs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int partition(int arr[], int low, int high)
{
	int temp = arr[low];
	while (low &lt; high)
	{
		while (arr[high] &gt;= temp &amp;&amp; low &lt; high)
		{
			high--;
		}
		if (arr[high] &lt; temp)
		{
			arr[low] = arr[high];
			low++;
		}
		while (arr[low] &lt;= temp &amp;&amp; low &lt; high)
		{
			low++;
		}
		if (arr[low] &gt; temp)
		{
			arr[high] = arr[low];
			high--;
		}
	}
	arr[low] = temp;
	return low;
}


void quicksort(int arr[], int low, int high)
{
	int k;
	if (low &lt; high)
	{
		k = partition(arr, low, high);
		quicksort(arr, low, k - 1);
		quicksort(arr, k + 1, high);
	}
}

int main()
{
	int arr[] = { 52,49,80,36,14,58,61,97,23,75 };//想要一个一个敲进去就用for循环
	int low = 0;
	int high = 9;
	printf("排序后的顺序：\n");
	quicksort(arr, low, high);
	for (int i = 0; i &lt;= 9; i++)
	{
		printf("%d ", arr[i]);
	}
	return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e5f7c7bbfc463e5c9a75d71154e1e8ae/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringBoot整合Netty(服务端)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/27d216a738511938e26e5a45ac40de7a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">新质生产力：AI大模型在制造业的深度融合与应用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>