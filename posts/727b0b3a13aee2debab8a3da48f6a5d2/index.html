<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 数据结构篇-用数组、堆实现优先级队列 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/727b0b3a13aee2debab8a3da48f6a5d2/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java 数据结构篇-用数组、堆实现优先级队列">
  <meta property="og:description" content="🔥博客主页： 【小扳_-CSDN博客】
❤感谢大家点赞👍收藏⭐评论✍ 文章目录
1.0 优先级队列说明
2.0 用数组实现优先级队列
3.0 无序数组实现优先级队列
3.1 无序数组实现优先级队列 - 入队列 offer(E value)
3.2 无序数组实现优先级队列 - 出队列 poll()
3.3 无序数组实现优先级队列 - 查看队列中优先级最大的元素 peek() 3.4 无序数组实现优先级队列 - 判断是否为空队列
3.5 无序数组实现优先级队列 - 判断是否为满队列
3.6 无序数组实现优先级队列完整代码
4.0 有序数组实现优先级队列
4.1 有序数组实现优先级队列 - 入队列 offer(E value)
4.2 有序数组实现有序队列 - 出队列 poll()
4.3 有序数组实现有序队列 - 查看优先级最大的元素 peek()
4.4 有序数组实现优先级队列 - 判断队列是否为空
4.5 有序数组实现优先级队列 - 判断队列是否为满队列
4.6 有序数组实现优先级队列完整代码
5.0 大顶堆实现优先级队列
5.1 堆实现优先级队列 - 入队列 offer(E value)">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-12-13T17:54:27+08:00">
    <meta property="article:modified_time" content="2023-12-13T17:54:27+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 数据结构篇-用数组、堆实现优先级队列</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong>🔥博客主页： 【<strong><a href="https://blog.csdn.net/Tingfeng__?spm=1000.2115.3001.5343" title="小扳_-CSDN博客】">小扳_-CSDN博客】</a></strong><br> ❤感谢大家点赞👍收藏⭐评论✍</strong>  </p> 
</blockquote> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/32/2d/1y3TawBl_o.jpg" width="400"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/bc/f4/BvvpMCkN_o.gif"></p> 
<p id="main-toc"><strong>文章目录</strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E8%AF%B4%E6%98%8E-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E8%AF%B4%E6%98%8E" rel="nofollow">        1.0 优先级队列说明</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.0%20%E7%94%A8%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.0%20%E7%94%A8%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97" rel="nofollow">        2.0 用数组实现优先级队列</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%C2%A0%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%C2%A0%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97" rel="nofollow">        3.0 无序数组实现优先级队列</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1%20%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%85%A5%E9%98%9F%E5%88%97%20offer(E%20value)-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1%20%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%85%A5%E9%98%9F%E5%88%97%20offer%28E%20value%29" rel="nofollow">        3.1 无序数组实现优先级队列 - 入队列 offer(E value)</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.2%20%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%87%BA%E9%98%9F%E5%88%97%20poll()-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.2%20%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%87%BA%E9%98%9F%E5%88%97%20poll%28%29" rel="nofollow">        3.2 无序数组实现优先级队列 - 出队列 poll()</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.3%C2%A0%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E6%9F%A5%E7%9C%8B%E9%98%9F%E5%88%97%E4%B8%AD%E4%BC%98%E5%85%88%E7%BA%A7%E6%9C%80%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0%20peek()%C2%A0-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.3%C2%A0%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E6%9F%A5%E7%9C%8B%E9%98%9F%E5%88%97%E4%B8%AD%E4%BC%98%E5%85%88%E7%BA%A7%E6%9C%80%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0%20peek%28%29%C2%A0" rel="nofollow">        3.3 无序数组实现优先级队列 - 查看队列中优先级最大的元素 peek() </a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.4%20%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%E9%98%9F%E5%88%97-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.4%20%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%E9%98%9F%E5%88%97" rel="nofollow">        3.4 无序数组实现优先级队列 - 判断是否为空队列</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.5%20%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E6%BB%A1%E9%98%9F%E5%88%97-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.5%20%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E6%BB%A1%E9%98%9F%E5%88%97" rel="nofollow">        3.5 无序数组实现优先级队列 - 判断是否为满队列</a></strong></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03.6%C2%A0%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03.6%C2%A0%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow">        3.6 无序数组实现优先级队列完整代码</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.0%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.0%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97" rel="nofollow">        4.0 有序数组实现优先级队列</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.1%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%85%A5%E9%98%9F%E5%88%97%20offer(E%20value)-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.1%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%85%A5%E9%98%9F%E5%88%97%20offer%28E%20value%29" rel="nofollow">        4.1 有序数组实现优先级队列 - 入队列 offer(E value)</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.2%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E9%98%9F%E5%88%97%20-%20%E5%87%BA%E9%98%9F%E5%88%97%20poll()-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.2%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E9%98%9F%E5%88%97%20-%20%E5%87%BA%E9%98%9F%E5%88%97%20poll%28%29" rel="nofollow">        4.2 有序数组实现有序队列 - 出队列 poll()</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.3%C2%A0%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E9%98%9F%E5%88%97%20-%20%E6%9F%A5%E7%9C%8B%E4%BC%98%E5%85%88%E7%BA%A7%E6%9C%80%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0%20peek()-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.3%C2%A0%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E9%98%9F%E5%88%97%20-%20%E6%9F%A5%E7%9C%8B%E4%BC%98%E5%85%88%E7%BA%A7%E6%9C%80%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0%20peek%28%29" rel="nofollow">        4.3 有序数组实现有序队列 - 查看优先级最大的元素 peek()</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.4%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%88%A4%E6%96%AD%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.4%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%88%A4%E6%96%AD%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA" rel="nofollow">        4.4 有序数组实现优先级队列 - 判断队列是否为空</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.5%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%88%A4%E6%96%AD%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E6%BB%A1%E9%98%9F%E5%88%97-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.5%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%88%A4%E6%96%AD%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E6%BB%A1%E9%98%9F%E5%88%97" rel="nofollow">        4.5 有序数组实现优先级队列 - 判断队列是否为满队列</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.6%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.6%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow">        4.6 有序数组实现优先级队列完整代码</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%205.0%20%E5%A4%A7%E9%A1%B6%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97-toc" style="margin-left:0px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%205.0%20%E5%A4%A7%E9%A1%B6%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97" rel="nofollow">        5.0 大顶堆实现优先级队列</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%205.1%20%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%85%A5%E9%98%9F%E5%88%97%20offer(E%20value)-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%205.1%20%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%85%A5%E9%98%9F%E5%88%97%20offer%28E%20value%29" rel="nofollow">        5.1 堆实现优先级队列 - 入队列 offer(E value)</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%205.2%20%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%87%BA%E9%98%9F%E5%88%97%20poll()-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%205.2%20%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%87%BA%E9%98%9F%E5%88%97%20poll%28%29" rel="nofollow">        5.2 堆实现优先级队列 - 出队列 poll()</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%205.3%20%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E6%9F%A5%E7%9C%8B%E4%BC%98%E5%85%88%E7%BA%A7%E6%9C%80%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0%20peek()-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%205.3%20%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E6%9F%A5%E7%9C%8B%E4%BC%98%E5%85%88%E7%BA%A7%E6%9C%80%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0%20peek%28%29" rel="nofollow">        5.3 堆实现优先级队列 - 查看优先级最大的元素 peek()</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A05.4%20%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%88%A4%E6%96%AD%E8%AF%A5%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A05.4%20%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%88%A4%E6%96%AD%E8%AF%A5%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA" rel="nofollow">        </a><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A05.4%20%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%88%A4%E6%96%AD%E8%AF%A5%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA" rel="nofollow">5.4 堆实现优先级队列 - 判断该队列是否为空</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%205.5%20%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%88%A4%E6%96%AD%E8%AF%A5%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E6%BB%A1%E9%98%9F%E5%88%97-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%205.5%20%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%88%A4%E6%96%AD%E8%AF%A5%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E6%BB%A1%E9%98%9F%E5%88%97" rel="nofollow">        5.5 堆实现优先级队列 - 判断该队列是否为满队列</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%205.6%20%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%205.6%20%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow">        5.6 堆实现优先级队列完整代码</a></strong></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%201.0%20%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E8%AF%B4%E6%98%8E">        1.0 优先级队列说明</h2> 
<p>        <strong>优先级队列是一种特殊的队列，其中每个元素都有一个优先级。在优先级队列中，具有最高优先级的元素首先被移除。这与普通队列不同，<span style="color:#fe2c24;">普通队列是先进先出（FIFO）的</span>，而<span style="color:#fe2c24;">优先级队列则是按照优先级来确定元素的出队顺序</span>。</strong></p> 
<p><strong>        优先级队列通常用于需要按照优先级处理元素的场景，比如任务调度、事件处理等。它可以使用不同的数据结构来实现，最常见的是使用堆（heap）来实现优先队列。堆是一种特殊的树形数据结构，它可以快速找到并移除具有最高（或最低）优先级的元素。</strong></p> 
<p><strong>        优先级队列的常见操作包括<span style="color:#fe2c24;">插入元素、移除具有最高优先级的元素、查看具有最高优先级的元素</span>等。实现优先级队列的常见算法包括插入时的堆调整、移除最高优先级元素后的堆调整等。</strong></p> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%202.0%20%E7%94%A8%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97">        2.0 用数组实现优先级队列</h2> 
<p>        <strong>可以使用数组来实现优先级队列，一种简单的实现方式是使用数组来存储元素，并且按照优先级顺序来维护数组。</strong></p> 
<p><strong>        用数组实现优先级队列可分为两种：<span style="color:#fe2c24;">无序数组实现</span>、<span style="color:#fe2c24;">有序数组实现。</span></strong></p> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.0%C2%A0%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97">        3.0 无序数组实现优先级队列</h2> 
<p>        <strong>可以直接简单粗暴来说，<span style="color:#fe2c24;">无序数组就是插入元素的时候不按照优先级进行排序，而出队列的时候，严格按照优先级大小进行出队列</span>。</strong></p> 
<p><strong>        首先，需要实现队列中的接口。比如：入队列、出队列等。</strong></p> 
<p><strong>接口代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">public interface Queue&lt;E&gt; {

    /**
     * 入队操作
     */
    boolean offer(E value);

    /**
     * 出队操作
     */
    E poll();

    /**
     * 查看队头元素
     */
    E peek();

    /**
     * 判断是否为空队列
     */
    boolean isEmpty();

    /**
     * 判断是否为满队列
     */
    boolean isFull();
}</code></pre> 
 <p></p> 
</blockquote> 
<p>        <strong>再接着，<span style="color:#fe2c24;">设置优先级元素</span>。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">public interface Priority {

    int priority();

}</code></pre> 
 <pre><code class="language-java">public class Entry implements  Priority{
    String string;
    int priority;

    public Entry(String string, int priority) {
        this.string = string;
        this.priority = priority;
    }

    @Override
    public int priority() {
        return priority;
    }

    @Override
    public String toString() {
        return "Entry{" +
                "string='" + string + '\'' +
                ", priority=" + priority +
                '}';
    }
}</code></pre> 
 <p>        <strong>该设置的优先级元素需要实现 priority 接口，返回当前优先级的大小。</strong></p> 
</blockquote> 
<p>        <strong>成员变量有 <span style="color:#fe2c24;">Priority[] arr </span>自定义大小的数组、<span style="color:#fe2c24;">size </span>标记当前元素的个数。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">public class UnorderedPriorityQueue&lt;E extends Priority&gt; implements Queue&lt;E&gt; {

    private Priority[] arr;
    private int size;

    public UnorderedPriorityQueue(int capacity) {
        arr = new Priority[capacity];
    }

}</code></pre> 
 <p></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1%20%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%85%A5%E9%98%9F%E5%88%97%20offer(E%20value)">        3.1 无序数组实现优先级队列 - 入队列 offer(E value)</h3> 
<p>        <strong><span style="color:#fe2c24;">由于用无序数组实现，元素可直接在数组尾部入队列</span>。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    @Override
    public boolean offer(E value) {
        if (isFull()) {
            return false;
        }
        arr[size++] = value;
        return true;
    }</code></pre> 
 <p>        <strong>注意：在入队前，需要<span style="color:#fe2c24;">判断是否为满队列</span>。入队完后，需要进行<span style="color:#fe2c24;"> size++</span> 。</strong></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.2%20%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%87%BA%E9%98%9F%E5%88%97%20poll()">        3.2 无序数组实现优先级队列 - 出队列 poll()</h3> 
<p>        <strong>根据元素的优先级大小进行出队列，首先需要遍历数组找到索引为 i 处优先级最大的元素。一般有两种情况：</strong></p> 
<p>       <strong> 第一种情况：<span style="color:#fe2c24;">在索引为 i == size - 1 处找到优先级最大的元素，此时只需要将 size-- ，然后将其引用置为空 arr[size] = null </span>。</strong></p> 
<p><strong>        第二种情况：<span style="color:#fe2c24;">不在索引为 i !=  size - 1 处找到优先级最大的元素。那么需要将索引为 i 的元素被 i + 1 处的元素进行覆盖，长度为：size - 1 - i </span>。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    @Override
    public E poll() {
        if (isEmpty()) {
            return null;
        }
        //先找到优先级大的点
        int j = 0;
        for (int i = 1; i &lt; size; i++) {
            if (arr[j].priority() &lt; arr[i].priority()) {
                j = i;
            }
        }
        E ret = (E)arr[j];
        if (j &lt; size - 1) {
            System.arraycopy(arr,j+1,arr,j,size - 1 - j);
        }
        size--;
        arr[size] = null;
        return ret;
    }</code></pre> 
 <p>        <strong>最后需要返回优先级最大的元素，在被置为<span style="color:#fe2c24;"> null </span>之前将其进行保存。每次出队完毕，后需要进行 <span style="color:#fe2c24;">size--</span> 、置为 <span style="color:#fe2c24;">null </span>。</strong></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.3%C2%A0%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E6%9F%A5%E7%9C%8B%E9%98%9F%E5%88%97%E4%B8%AD%E4%BC%98%E5%85%88%E7%BA%A7%E6%9C%80%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0%20peek()%C2%A0">        3.3 无序数组实现优先级队列 - 查看队列中优先级最大的元素 peek() </h3> 
<p>        <strong><span style="color:#fe2c24;">相比与出队列，找到了优先级最大的元素后，不需要进行删除该优先级最大的元素</span>。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    @Override
    public E peek() {
        if (isEmpty()) {
            return null;
        }
        //先找到优先级大的点
        int j = 0;
        for (int i = 1; i &lt; size; i++) {
            if (arr[j].priority() &lt; arr[i].priority()) {
                j = i;
            }
        }
        E ret = (E)arr[j];
        return ret;
    }</code></pre> 
 <p><strong>        注意：在查看元素之前需要先判断是否为空队列。</strong></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.4%20%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%E9%98%9F%E5%88%97">        3.4 无序数组实现优先级队列 - 判断是否为空队列</h3> 
<p>       <strong> 若 size == 0 ，则为空队列；若不是，则不为空。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    @Override
    public boolean isEmpty() {
        return size == 0;
    }
</code></pre> 
 <p></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.5%20%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E6%BB%A1%E9%98%9F%E5%88%97">        3.5 无序数组实现优先级队列 - 判断是否为满队列</h3> 
<p>        <strong>若 size == arr.length 时，则为满队列；若不相等，则不为满。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    @Override
    public boolean isFull() {
        return size == arr.length;
    }</code></pre> 
 <p></p> 
</blockquote> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03.6%C2%A0%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">        3.6 无序数组实现优先级队列完整代码</h3> 
<blockquote> 
 <pre><code class="language-java">public class UnorderedPriorityQueue&lt;E extends Priority&gt; implements Queue&lt;E&gt; {

    private Priority[] arr;
    private int size;

    public UnorderedPriorityQueue(int capacity) {
        arr = new Priority[capacity];
    }

    @Override
    public boolean offer(E value) {
        if (isFull()) {
            return false;
        }
        arr[size++] = value;
        return true;
    }

    @Override
    public E poll() {
        if (isEmpty()) {
            return null;
        }
        //先找到优先级大的点
        int j = 0;
        for (int i = 1; i &lt; size; i++) {
            if (arr[j].priority() &lt; arr[i].priority()) {
                j = i;
            }
        }
        E ret = (E)arr[j];
        if (j &lt; size - 1) {
            System.arraycopy(arr,j+1,arr,j,size - 1 - j);
        }
        size--;
        arr[size] = null;
        return ret;
    }

    @Override
    public E peek() {
        if (isEmpty()) {
            return null;
        }
        //先找到优先级大的点
        int j = 0;
        for (int i = 1; i &lt; size; i++) {
            if (arr[j].priority() &lt; arr[i].priority()) {
                j = i;
            }
        }
        E ret = (E)arr[j];
        return ret;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == arr.length;
    }
}</code></pre> 
 <p></p> 
</blockquote> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.0%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97">        4.0 有序数组实现优先级队列</h2> 
<p>        <strong>相对于无序数组优先级队列来说，<span style="color:#fe2c24;">有序数组实现优先级队列入队列操作需要按照优先级大小进行插入，而出队列操作直接在索引为 size - 1 处直接获取该最大优先级元素</span>。</strong></p> 
<p><strong>        首先，同样的，需要实现队列中的接口。比如：入队列、出队列等。</strong></p> 
<p><strong>接口代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">public interface Queue&lt;E&gt; {

    /**
     * 入队操作
     */
    boolean offer(E value);

    /**
     * 出队操作
     */
    E poll();

    /**
     * 查看队头元素
     */
    E peek();

    /**
     * 判断是否为空队列
     */
    boolean isEmpty();

    /**
     * 判断是否为满队列
     */
    boolean isFull();
}</code></pre> 
</blockquote> 
<p>        <strong>再接着，设置优先级元素。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">public class Entry implements  Priority{
    String string;
    int priority;

    public Entry(String string, int priority) {
        this.string = string;
        this.priority = priority;
    }

    @Override
    public int priority() {
        return priority;
    }

    @Override
    public String toString() {
        return "Entry{" +
                "string='" + string + '\'' +
                ", priority=" + priority +
                '}';
    }
}</code></pre> 
</blockquote> 
<p>        <strong>成员变量有 <span style="color:#fe2c24;">Priority[] arr </span>自定义大小的数组、<span style="color:#fe2c24;">size</span> 标记当前元素的个数。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">public class OrderedPriorityQueue&lt;E extends Priority&gt; implements Queue&lt;E&gt;{

    private Priority[] arr;
    private int size;

    public OrderedPriorityQueue(int capacity) {
        arr = new Priority[capacity];
    }

}</code></pre> 
 <p></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.1%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%85%A5%E9%98%9F%E5%88%97%20offer(E%20value)">        4.1 有序数组实现优先级队列 - 入队列 offer(E value)</h3> 
<p>        <strong><span style="color:#fe2c24;">使用有序数组实现优先级入队列，在入队列之前从后往前遍历数组，找到优先级小于入队列的元素优先级，找到即可插入其中</span>。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    @Override
    public boolean offer(E value) {
        if (isFull()) {
            return false;
        }
        //先找到优先级比value的优先级大的索引
        int i = size - 1;
        while (i &gt;= 0 &amp;&amp; arr[i].priority() &gt; value.priority()) {
            arr[i+1] = arr[i];
            i--;
        }
        arr[i+1] = value;
        size++;
        return true;
    }</code></pre> 
 <p>        <strong>考虑一种情况，若 size == 0 时，为空队列的时候，该代码有无错误？</strong></p> 
 <p><strong>                答案是：<span style="color:#fe2c24;">没有问题的，当 size == 0 时， 则 i = 0 - 1，i = -1 ， 此时不会进入循环直接跳到 arr[i + 1] 处，所以，在这种情况下，该代码没有问题</span>。</strong></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.2%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E9%98%9F%E5%88%97%20-%20%E5%87%BA%E9%98%9F%E5%88%97%20poll()">        4.2 有序数组实现有序队列 - 出队列 poll()</h3> 
<p>        <strong>这就相对于有序数组入队列来说比较简单了，直接在索引为 <span style="color:#fe2c24;">i = size - 1 </span>处，得到优先级最大的元素，然后将 <span style="color:#fe2c24;">size--</span> ，再接着 <span style="color:#fe2c24;">arr[size]</span> 置为 <span style="color:#fe2c24;">null</span> 。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    @Override
    public E poll() {
        if (isEmpty()) {
            return null;
        }
        E str = (E)arr[size - 1];
        size--;
        arr[size] = null;
        return str;
    }</code></pre> 
 <p>        <strong>注意：需要记录优先级最大的元素并且返回。在出队列之前需要判断该队列是否为空队列。</strong></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.3%C2%A0%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E9%98%9F%E5%88%97%20-%20%E6%9F%A5%E7%9C%8B%E4%BC%98%E5%85%88%E7%BA%A7%E6%9C%80%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0%20peek()">        4.3 有序数组实现有序队列 - 查看优先级最大的元素 peek()</h3> 
<p>        <strong><span style="color:#fe2c24;">先判断该队列是否为空队列，若不是，直接返回该数组索引为 size - 1 处的元素即可</span>。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    @Override
    public E peek() {
        if (isEmpty()) {
            return null;
        }
        E str = (E)arr[size - 1];
        return str;
    }</code></pre> 
 <p></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.4%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%88%A4%E6%96%AD%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA">        4.4 有序数组实现优先级队列 - 判断队列是否为空</h3> 
<p>        <strong>若 size == 0 ，则为空；若不为，则为不空。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    @Override
    public boolean isEmpty() {
        return size == 0;
    }</code></pre> 
 <p></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.5%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%88%A4%E6%96%AD%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E6%BB%A1%E9%98%9F%E5%88%97">        4.5 有序数组实现优先级队列 - 判断队列是否为满队列</h3> 
<p>        <strong>若 size == arr.length 时，则为满队列；若不是，则为不满队列。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    @Override
    public boolean isFull() {
        return size == arr.length;
    }</code></pre> 
 <p></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%204.6%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">        4.6 有序数组实现优先级队列完整代码</h3> 
<blockquote> 
 <pre><code class="language-java">public class OrderedPriorityQueue&lt;E extends Priority&gt; implements Queue&lt;E&gt;{

    private Priority[] arr;
    private int size;

    public OrderedPriorityQueue(int capacity) {
        arr = new Priority[capacity];
    }

    @Override
    public boolean offer(E value) {
        if (isFull()) {
            return false;
        }
        //先找到优先级比value的优先级大的索引
        int i = size - 1;
        while (i &gt;= 0 &amp;&amp; arr[i].priority() &gt; value.priority()) {
            arr[i+1] = arr[i];
            i--;
        }
        arr[i+1] = value;
        size++;
        return true;
    }

    @Override
    public E poll() {
        if (isEmpty()) {
            return null;
        }
        E str = (E)arr[size - 1];
        size--;
        arr[size] = null;
        return str;
    }

    @Override
    public E peek() {
        if (isEmpty()) {
            return null;
        }
        E str = (E)arr[size - 1];
        return str;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == arr.length;
    }
}</code></pre> 
 <p></p> 
</blockquote> 
<p></p> 
<h2 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%205.0%20%E5%A4%A7%E9%A1%B6%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97">        5.0 大顶堆实现优先级队列</h2> 
<p>        <strong>大顶堆说明：</strong></p> 
<p><strong>        <span style="color:#fe2c24;">大顶堆是一种特殊的堆，它是一种完全二叉树，其中每个父节点的值都大于或等于其左右子节点的值。在大顶堆中，根节点的值是整个堆中最大的。</span></strong></p> 
<p><strong>        <span style="color:#fe2c24;">大顶堆可以使用数组来实现，其中堆的根节点存储在数组的第一个位置，然后按照完全二叉树的性质依次存储其他节点。这种实现方式使得大顶堆的父节点和子节点之间可以通过简单的数学关系来计算，从而方便进行堆调整操作。假设 i 不为 0 ，该双亲索引为：（i - 1）/ 2 ；该左孩子为：2 * i + 1；该右孩子为：2 * i  + 2 。</span></strong></p> 
<p><strong>        首先，需要实现队列中的接口。比如：入队列、出队列等。</strong></p> 
<p><strong>接口代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">public interface Queue&lt;E&gt; {

    /**
     * 入队操作
     */
    boolean offer(E value);

    /**
     * 出队操作
     */
    E poll();

    /**
     * 查看队头元素
     */
    E peek();

    /**
     * 判断是否为空队列
     */
    boolean isEmpty();

    /**
     * 判断是否为满队列
     * */
    boolean isFull();
}</code></pre> 
 <p></p> 
</blockquote> 
<p>        <strong> 再接着，设置优先级元素。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">public class Entry implements  Priority{
    String string;
    int priority;

    public Entry(String string, int priority) {
        this.string = string;
        this.priority = priority;
    }

    @Override
    public int priority() {
        return priority;
    }

    @Override
    public String toString() {
        return "Entry{" +
                "string='" + string + '\'' +
                ", priority=" + priority +
                '}';
    }
}</code></pre> 
</blockquote> 
<p>        <strong>成员变量有<span style="color:#fe2c24;"> Priority[] arr </span>自定义大小的数组、<span style="color:#fe2c24;">size </span>标记当前元素的个数。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">public class BigTopPile&lt;E extends Priority&gt; implements Queue&lt;E&gt; {

    private Priority[] arr;
    private int size;

    public BigTopPile(int capacity) {
        arr = new Priority[capacity];
    }

}</code></pre> 
 <p></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%205.1%20%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%85%A5%E9%98%9F%E5%88%97%20offer(E%20value)">        5.1 堆实现优先级队列 - 入队列 offer(E value)</h3> 
<p>        <strong>具体思路为：<span style="color:#fe2c24;">由于是按照优先级大小来存放元素的，所以，需要先比较优先级大小，在适合的位置插入。现在已知 i = size，该双亲为：（i - 1）/ 2 。接下来，需要判断 arr[（i - 1）/ 2] 的优先级于入队列的元素优先级大小，若 arr[（i - 1）/ 2] 的优先级较大，此时该入队列的元素存放的位置为 arr[i] = value ；若 value 的优先级大于当前 arr[（i - 1）/ 2] 时，先将当前 arr[（i - 1）/ 2] 往后放，即 arr[i] = arr[（i - 1）/ 2] 。之后需要继续往上找双亲，将 i = (i - 1) / 2 ，直到 i == 0 或者 value 的优先级小于当前 arr[（i - 1）/ 2] 时，则为 arr[i] = value</span> 。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    @Override
    public boolean offer(E value) {
        if (isFull()) {
            return false;
        }
        int i = size;
        int j = (i - 1) / 2;
        while (i &gt; 0 &amp;&amp; arr[j].priority() &lt; value.priority()) {
            arr[i] = arr[j];
            i = j;
            j = (i - 1) / 2;
        }
        arr[i] = value;
        size++;
        return true;
    }</code></pre> 
 <p><strong>        只要 i == 0 时， j 不能继续往上走了，否则为抛空指针异常。</strong></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%205.2%20%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%87%BA%E9%98%9F%E5%88%97%20poll()">        5.2 堆实现优先级队列 - 出队列 poll()</h3> 
<p>        <strong>具体思路为：分为两步。</strong></p> 
<p><strong>        第一步，<span style="color:#fe2c24;">将 arr[size - 1] 处的元素交换到 arr[0] 处</span>。</strong></p> 
<p><strong>        第二步，<span style="color:#fe2c24;">由于根处的优先级永远都要大于该孩子的优先级，所以，将交换之后的元素进行下潜，即先找到该左右孩子优先级最大的元素，于根元素进行交换，一直往下进行下潜。直到该根元素没有左右孩子或者根元素的优先级都大于该左右孩子的优先级</span>。</strong></p> 
<p><strong>代码实现：</strong></p> 
<blockquote> 
 <p><strong>非递归实现：</strong></p> 
 <pre><code class="language-java">    @Override
    public E poll() {
        if (isEmpty()) {
            return null;
        }

        E top = (E)arr[0];
        arr[0] = arr[size - 1];
        size--;
        arr[size] = null;
        int i = 0;
        while ( (i * 2 + 1) &lt; size &amp;&amp; (i * 2 + 2) &lt; size &amp;&amp; (arr[i].priority() &lt; arr[i * 2 + 1].priority() || arr[i].priority() &lt; arr[i * 2 + 2].priority() ) ) {

            int j = 0;
            if (arr[i * 2 + 1].priority() &gt; arr[i * 2 + 2].priority()) {
                j = i * 2 + 1;
            }else if (arr[i * 2 + 1].priority() &lt;= arr[i * 2 + 2].priority()) {
                j = i * 2 + 2;
            }
            E temp = (E)arr[j];
            arr[j] = arr[i];
            arr[i] = temp;
            i = j;
        }
        return top;
    }</code></pre> 
 <p>        <strong> (i * 2 + 1) &lt; size &amp;&amp; (i * 2 + 2) &lt; size 该代码判断的是有无左右孩子元素。</strong></p> 
 <p></p> 
 <p><strong>递归实现：</strong></p> 
 <pre><code class="language-java">    public E poll1() {
        if (isEmpty()) {
            return null;
        }
        //交换头尾
        swap(0,size - 1);
        size--;
        //置为 null
        E ret = (E)arr[size];
        arr[size] = null;

        //下潜
        down(0);
        return ret;

    }
    private void swap(int i, int j) {
        E t = (E)arr[i];
        arr[i] = arr[j];
        arr[j] = t;
    }
    private void down(int i) {
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        int max = i;
        if ( left &lt; size &amp;&amp; arr[max].priority() &lt; arr[left].priority()) {
            max = left;
        }
        if (right &lt; size &amp;&amp; arr[max].priority() &lt; arr[right].priority()) {
            max = right;
        }
        if (max != i) {
            swap(max,i);
            down(max);
        }
    }</code></pre> 
 <p>        </p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%205.3%20%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E6%9F%A5%E7%9C%8B%E4%BC%98%E5%85%88%E7%BA%A7%E6%9C%80%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0%20peek()">        5.3 堆实现优先级队列 - 查看优先级最大的元素 peek()</h3> 
<p>        <strong>先判断该队列是否为空，若不为空，则直接返回堆顶元素即可。</strong></p> 
<p><strong>代码如下：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    @Override
    public E peek() {
        if (isEmpty()) {
            return null;
        }
        return (E)arr[0];
    }</code></pre> 
 <p></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A05.4%20%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%88%A4%E6%96%AD%E8%AF%A5%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA">         5.4 堆实现优先级队列 - 判断该队列是否为空</h3> 
<p>        <strong>当 size == 0 时，则为空队列。</strong></p> 
<p><strong>代码实现：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    @Override
    public boolean isEmpty() {
        return size == 0;
    }</code></pre> 
 <p></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%205.5%20%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%20-%20%E5%88%A4%E6%96%AD%E8%AF%A5%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E6%BB%A1%E9%98%9F%E5%88%97">        5.5 堆实现优先级队列 - 判断该队列是否为满队列</h3> 
<p>        <strong>当 size == arr.length 时，则为满队列。</strong></p> 
<p><strong>代码实现：</strong></p> 
<blockquote> 
 <pre><code class="language-java">    @Override
    public boolean isFull() {
        return size == arr.length;
    }</code></pre> 
 <p></p> 
</blockquote> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%205.6%20%E5%A0%86%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">        5.6 堆实现优先级队列完整代码</h3> 
<blockquote> 
 <pre><code class="language-java">public class BigTopPile&lt;E extends Priority&gt; implements Queue&lt;E&gt; {

    private Priority[] arr;
    private int size;

    public BigTopPile(int capacity) {
        arr = new Priority[capacity];
    }

    @Override
    public boolean offer(E value) {
        if (isFull()) {
            return false;
        }
        int i = size;
        int j = (i - 1) / 2;
        while (i &gt; 0 &amp;&amp; arr[j].priority() &lt; value.priority()) {
            arr[i] = arr[j];
            i = j;
            j = (i - 1) / 2;
        }
        arr[i] = value;
        size++;
        return true;
    }

    @Override
    public E poll() {
        if (isEmpty()) {
            return null;
        }

        E top = (E)arr[0];
        arr[0] = arr[size - 1];
        size--;
        arr[size] = null;
        int i = 0;
        while ( (i * 2 + 1) &lt; size &amp;&amp; (i * 2 + 2) &lt; size &amp;&amp; (arr[i].priority() &lt; arr[i * 2 + 1].priority() || arr[i].priority() &lt; arr[i * 2 + 2].priority() ) ) {

            int j = 0;
            if (arr[i * 2 + 1].priority() &gt; arr[i * 2 + 2].priority()) {
                j = i * 2 + 1;
            }else if (arr[i * 2 + 1].priority() &lt;= arr[i * 2 + 2].priority()) {
                j = i * 2 + 2;
            }
            E temp = (E)arr[j];
            arr[j] = arr[i];
            arr[i] = temp;
            i = j;
        }
        return top;
    }

    public E poll1() {
        if (isEmpty()) {
            return null;
        }
        //交换头尾
        swap(0,size - 1);
        size--;
        //置为 null
        E ret = (E)arr[size];
        arr[size] = null;

        //下潜
        down(0);
        return ret;

    }
    private void swap(int i, int j) {
        E t = (E)arr[i];
        arr[i] = arr[j];
        arr[j] = t;
    }
    private void down(int i) {
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        int max = i;
        if ( left &lt; size &amp;&amp; arr[max].priority() &lt; arr[left].priority()) {
            max = left;
        }
        if (right &lt; size &amp;&amp; arr[max].priority() &lt; arr[right].priority()) {
            max = right;
        }
        if (max != i) {
            swap(max,i);
            down(max);
        }
    }



    @Override
    public E peek() {
        if (isEmpty()) {
            return null;
        }
        return (E)arr[0];
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public boolean isFull() {
        return size == arr.length;
    }
}</code></pre> 
 <p></p> 
</blockquote> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/30/7a/59o2D8mJ_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/18cb094b11ffa1e7b2b53ed742ee9060/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[MySQL]数据库原理1，三大范式，E-R图，DataBase，数据库管理系统（DBMS），Relationship，实体、属性、联系 映射基数，关系型数据库，联系的度数等——喵喵期末不挂科</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d744bda9ac7f3edc8364e8c0af82a304/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用Log4j与log4j2配置mybatisplus打印sql日志</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>