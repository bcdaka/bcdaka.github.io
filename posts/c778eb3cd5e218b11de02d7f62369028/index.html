<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】哈希表 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/c778eb3cd5e218b11de02d7f62369028/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】哈希表">
  <meta property="og:description" content="1.前言 我们前面学习了二叉搜索树的相关操作、Map和Set的使用，今天继续跟大家分享数据结构中的哈希表相关知识，让我们一起进入数据结构的世界，探索哈希表的奥秘！
2.哈希表 2.1概念 顺序结构以及平衡树中，元素关键码与其存储位置之间没有对应的关系，因此在查找一个元素时，必须要经过关键码的多次比较。顺序查找时间复杂度为O(N)，平衡树中为树的高度，即O(log₂N)，搜索的效率取决于搜索过程中元素的比较次数。 理想的搜索方法：可以不经过任何比较，一次直接从表中得到要搜索的元素。 如果构造一种存储结构，通过某种函数(hashFunc)使元素的存储位置与它的关键码之间能够建立一一映射的关系，那么在查找时通过该函数可以很快找到该元素。 当向该结构中： 插入元素 根据待插入元素的关键码，以此函数计算出该元素的存储位置并按此位置进行存放。
搜索元素 对元素的关键码进行同样的计算，把求得的函数值当做元素的存储位置，在结构中按此位置取元素比较，若关键码相等，则搜索成功。 该方式即为哈希 ( 散列 ) 方法， 哈希方法中使用的转换函数称为哈希 ( 散列 ) 函数，构造出来的结构称为哈希表 (Hash Table)( 或者称散列表 ) 例如：数据集合 {1 ， 7 ， 6 ， 4 ， 5 ， 9} ； 哈希函数设置为： hash(key) = key % capacity ; capacity 为存储元素底层空间总的大小。 用该方法进行搜索不必进行多次关键码的比较，因此搜索的速度比较快。
2.2冲突-概念 对于两个数据元素的关键字 ki 和 k(j)，有ki != kj，但有：Hash(ki) == Hash(kj)，即：不同关键字通过相同哈希函数计算出相同的哈希地址，该现象称为哈希冲突或哈希碰撞。
因此我们把具有不同关键码而具有相同哈希地址的数据元素称为“同义词”。
2.3冲突-避免 我们需要明确一点，由于我们哈希表底层数组的容量往往是小于实际要存储的关键字的数量的，这就导致一个问题， 冲突的发生是必然的 ，但我们能做的应该是尽量的 降低冲突率 。 2.3.1哈希函数设计 引起哈希冲突的一个原因可能是：哈希函数设计不够合理。哈希函数设计原则：
哈希函数的定义域必须包括需要存储的全部关键码，而如果散列表允许有m个地址时，其值域必须在0到m-1之间。哈希函数计算出来的地址能均匀分布在整个空间中 哈希函数应该比较简单。 常见哈希函数">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-06T11:07:23+08:00">
    <meta property="article:modified_time" content="2024-08-06T11:07:23+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】哈希表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1.前言</h2> 
<p>我们前面学习了二叉搜索树的相关操作、Map和Set的使用，今天继续跟大家分享数据结构中的哈希表相关知识，让我们一起进入数据结构的世界，探索哈希表的奥秘！</p> 
<h2>2.<span style="color:#333333;"><strong>哈希表</strong></span></h2> 
<h3><span style="color:#333333;"><strong>2.1概念 </strong></span></h3> 
<p><span style="color:#333333;"><strong>顺序结构以及平衡树</strong></span><span style="color:#333333;">中，元素关键码与其存储位置之间没有对应的关系，因此在</span><span style="color:#333333;"><strong>查找一个元素时，必须要经过关键</strong></span><span style="color:#333333;"><strong>码的多次比较</strong></span><span style="color:#333333;">。</span><span style="color:#333333;"><strong>顺序查找时间复杂度为</strong></span><span style="color:#333333;"><strong>O(N)</strong></span><span style="color:#333333;"><strong>，平衡树中为树的高度，即O(</strong></span><strong>log₂N</strong><span style="color:#333333;"><strong>)</strong>，搜索的效率取决于搜索过程中元素的比较次数。 </span></p> 
<p><span style="color:#333333;">理想的搜索方法：可以<strong>不经过任何比较，一次直接从表中得到要搜索的元素</strong></span><span style="color:#333333;">。 </span><span style="color:#333333;"><strong>如果构造一种存储结构，通过某种函</strong></span><span style="color:#333333;"><strong>数</strong></span><span style="color:#333333;"><strong>(hashFunc)</strong></span><span style="color:#333333;"><strong>使元素的存储位置与它的关键码之间能够建立一一映射的关系，那么在查找时通过该函数可以很快</strong></span><span style="color:#333333;"><strong>找到该元素</strong></span><span style="color:#333333;">。 </span></p> 
<p><span style="color:#333333;">当向该结构中： </span></p> 
<ul><li><span style="color:#333333;"><strong>插入元素 </strong></span></li></ul> 
<p><span style="color:#333333;">根据待插入元素的关键码，以此函数计算出该元素的存储位置并按此位置进行存放。</span></p> 
<ul><li><span style="color:#333333;"><strong>搜索元素 </strong></span></li></ul> 
<div> 
 <span style="color:#333333;">对元素的关键码进行同样的计算，把求得的函数值当做元素的存储位置，在结构中按此位置取元素比较，若关键码相等，则搜索成功。</span> 
</div> 
<div> 
 <span style="color:#333333;">该方式即为哈希</span> 
 <span style="color:#333333;">(</span> 
 <span style="color:#333333;">散列</span> 
 <span style="color:#333333;">)</span> 
 <span style="color:#333333;">方法，</span> 
 <span style="color:#333333;"><strong>哈希方法中使用的转换函数称为哈希</strong></span> 
 <span style="color:#333333;"><strong>(</strong></span> 
 <span style="color:#333333;"><strong>散列</strong></span> 
 <span style="color:#333333;"><strong>)</strong></span> 
 <span style="color:#333333;"><strong>函数，构造出来的结构称为哈希表</strong></span> 
 <span style="color:#333333;"><strong>(Hash </strong></span> 
 <span style="color:#333333;"><strong>Table)(</strong></span> 
 <span style="color:#333333;"><strong>或者称散列表</strong></span> 
 <span style="color:#333333;"><strong>) </strong></span> 
</div> 
<div> 
 <span style="color:#333333;">例如：数据集合</span> 
 <span style="color:#333333;">{1</span> 
 <span style="color:#333333;">，</span> 
 <span style="color:#333333;">7</span> 
 <span style="color:#333333;">，</span> 
 <span style="color:#333333;">6</span> 
 <span style="color:#333333;">，</span> 
 <span style="color:#333333;">4</span> 
 <span style="color:#333333;">，</span> 
 <span style="color:#333333;">5</span> 
 <span style="color:#333333;">，</span> 
 <span style="color:#333333;">9}</span> 
 <span style="color:#333333;">；</span> 
</div> 
<div> 
 <span style="color:#333333;">哈希函数设置为：</span> 
 <span style="color:#333333;"><strong>hash(key) = key % capacity</strong></span> 
 <span style="color:#333333;">; capacity</span> 
 <span style="color:#333333;">为存储元素底层空间总的大小。 </span> 
</div> 
<div> 
 <img alt="" height="398" src="https://images2.imgbox.com/95/89/BDaO7jS2_o.png" width="1200"> 
</div> 
<p><span style="color:#333333;"><strong>用该方法进行搜索不必进行多次关键码的比较，因此搜索的速度比较快。</strong></span></p> 
<h3><span style="color:#333333;"><strong>2.2冲突</strong></span><span style="color:#333333;"><strong>-</strong></span><span style="color:#333333;"><strong>概念</strong></span></h3> 
<p>对于两个数据元素的关键字 ki 和 k(j)，有ki != kj，但有：Hash(ki) == Hash(kj)，即：<strong>不同关键字通过相同哈希函数计算出相同的哈希地址，该现象称为哈希冲突或哈希碰撞。</strong></p> 
<p><img alt="" height="342" src="https://images2.imgbox.com/7a/0c/d1MlXZR0_o.png" width="1200"></p> 
<p><span style="color:#333333;">因此我们把具有不同关键码而具有相同哈希地址的数据元素称为</span><span style="color:#fe2c24;"><strong>“同义词”</strong></span><span style="color:#333333;">。</span></p> 
<h3>2.3<span style="color:#333333;"><strong>冲突</strong></span><span style="color:#333333;"><strong>-</strong></span><span style="color:#333333;"><strong>避免</strong></span></h3> 
<div> 
 <span style="color:#333333;">我们需要明确一点，由于我们哈希表底层数组的容量往往是小于实际要存储的关键字的数量的，这就导致一个问题，</span> 
 <span style="color:#fe2c24;"><strong>冲突的发生是必然的</strong></span> 
 <span style="color:#333333;">，但我们能做的应该是尽量的</span> 
 <span style="color:#333333;"><strong>降低冲突率</strong></span> 
 <span style="color:#333333;">。</span> 
</div> 
<h4><span style="color:#333333;">2.3.1</span><span style="color:#333333;"><strong>哈希函数设计</strong></span></h4> 
<p><span style="color:#333333;">引起哈希冲突的一个原因可能是：</span><span style="color:#fe2c24;"><strong>哈希函数设计不够合理</strong></span><span style="color:#333333;">。</span><span style="color:#333333;"><strong>哈希函数设计原则</strong></span><span style="color:#333333;">：</span></p> 
<blockquote> 
 <ul><li><span style="color:#333333;">哈希函数的定义域必须包括需要存储的全部关键码，而如果散列表允许有</span><span style="color:#333333;">m</span><span style="color:#333333;">个地址时，其值域必须在</span><span style="color:#333333;">0</span><span style="color:#333333;">到</span><span style="color:#333333;">m-1之间。</span></li><li><span style="color:#333333;">哈希函数计算出来的地址能均匀分布在整个空间中 </span></li><li><span style="color:#333333;">哈希函数应该比较简单。</span></li></ul> 
</blockquote> 
<p><span style="color:#333333;"><strong>常见哈希函数</strong></span></p> 
<p><span style="color:#333333;">1.</span><span style="color:#333333;"><strong>直接定制法</strong></span></p> 
<div> 
 <span style="color:#333333;">取关键字的某个线性函数为散列地址：</span> 
 <span style="color:#333333;"><strong>Hash</strong></span> 
 <span style="color:#333333;"><strong>（</strong></span> 
 <span style="color:#333333;"><strong>Key</strong></span> 
 <span style="color:#333333;"><strong>）</strong></span> 
 <span style="color:#333333;"><strong>= A*Key + B</strong></span> 
</div> 
<div> 
 <span style="color:#333333;">优点：</span> 
 <span style="color:#fe2c24;"><strong>简单、均匀</strong></span> 
</div> 
<div> 
 <span style="color:#333333;">缺点：</span> 
 <span style="color:#fe2c24;"><strong>需要事先知道关键字的分布情况</strong></span> 
</div> 
<div> 
 <span style="color:#0d0016;">使用场景：</span> 
 <span style="color:#fe2c24;"><strong>适合查找比较小且连续的情况</strong></span> 
</div> 
<div> 
 <span style="color:#0d0016;">下面给大家举个例子：</span> 
 <a href="https://leetcode.cn/problems/first-unique-character-in-a-string/description/" rel="nofollow" title="387. 字符串中的第一个唯一字符 - 力扣（LeetCode）">387. 字符串中的第一个唯一字符 - 力扣（LeetCode）</a> 
</div> 
<div> 
 <pre><code class="language-java">class Solution {
    public int firstUniqChar(String s) {
        int[] arr =new int[26];
        for(int i = 0;i&lt;s.length();i++){
        char ch = s.charAt(i);
        arr[ch-'a']++;
        }
        for(int i = 0;i&lt;s.length();i++){
        char ch = s.charAt(i);
        if (arr[ch - 'a'] == 1) {
            return i;
        }
        }
        return-1;
    }
}</code></pre> 
</div> 
<div> 
 <img alt="" height="664" src="https://images2.imgbox.com/da/50/oQWrzAKR_o.png" width="1200"> 
</div> 
<div> 
 <span style="color:#0d0016;">2.</span> 
 <span style="color:#333333;"><strong>除留余数法</strong></span> 
</div> 
<div> 
 <div> 
  <span style="color:#333333;">设散列表中允许的</span> 
  <span style="color:#333333;"><strong>地址数为</strong></span> 
  <span style="color:#333333;"><strong>m</strong></span> 
  <span style="color:#333333;"><strong>，取一个不大于</strong></span> 
  <span style="color:#333333;"><strong>m</strong></span> 
  <span style="color:#333333;"><strong>，但最接近或者等于</strong></span> 
  <span style="color:#333333;"><strong>m</strong></span> 
  <span style="color:#333333;"><strong>的质数</strong></span> 
  <span style="color:#333333;"><strong>p</strong></span> 
  <span style="color:#333333;"><strong>作为除数，按照哈希函数：</strong></span> 
  <span style="color:#333333;"><strong>Hash(key) = key% p(p&lt;=m),</strong></span> 
  <span style="color:#333333;"><strong>将关键码转换成哈希地址。</strong></span> 
 </div> 
 <div> 
  <span style="color:#333333;">3. </span> 
  <span style="color:#333333;"><strong>平方取中法</strong></span> 
 </div> 
 <div> 
  <div> 
   <span style="color:#333333;">假设关键字为</span> 
   <span style="color:#333333;">1234</span> 
   <span style="color:#333333;">，对它平方就是</span> 
   <span style="color:#333333;">1522756</span> 
   <span style="color:#333333;">，抽取中间的</span> 
   <span style="color:#333333;">3</span> 
   <span style="color:#333333;">位</span> 
   <span style="color:#333333;">227</span> 
   <span style="color:#333333;">作为哈希地址；再比如关键字为</span> 
   <span style="color:#333333;">4321</span> 
   <span style="color:#333333;">，对它平方就是18671041</span> 
   <span style="color:#333333;">，抽取中间的</span> 
   <span style="color:#333333;">3</span> 
   <span style="color:#333333;">位</span> 
   <span style="color:#333333;">671(</span> 
   <span style="color:#333333;">或</span> 
   <span style="color:#333333;">710)</span> 
   <span style="color:#333333;">作为哈希地址</span> 
   <span style="color:#333333;"><strong>平方取中法比较适合：不知道关键字的分</strong></span> 
   <span style="color:#333333;"><strong>布，而位数又不是很大的情况。</strong></span> 
  </div> 
  <h4><span style="color:#333333;"><strong>2.3.2</strong></span><span style="color:#333333;"><strong>负载因子调节</strong></span></h4> 
  <h4><img alt="" height="243" src="https://images2.imgbox.com/1f/e7/7osPyZbs_o.png" width="1200"></h4> 
 </div> 
</div> 
<p><span style="color:#333333;"><strong>负载因子和冲突率的关系粗略演示</strong></span></p> 
<p><img alt="" height="812" src="https://images2.imgbox.com/d3/f1/IcDEAXvH_o.png" width="858"></p> 
<div> 
 <span style="color:#333333;">所以当冲突率达到一个无法忍受的程度时，我们需要通过降低负载因子来变相的降低冲突率。 </span> 
</div> 
<div> 
 <span style="color:#333333;">已知哈希表中</span> 
 <strong><span style="color:#fe2c24;">已有的关键字个数是不可变</span></strong> 
 <span style="color:#333333;">的，那我们能调整的就只有哈希表中的数组的大小。</span> 
</div> 
<h3>2.4<span style="color:#333333;"><strong>冲突</strong></span><span style="color:#333333;"><strong>-</strong></span><span style="color:#333333;"><strong>解决</strong></span></h3> 
<h4><span style="color:#333333;"><strong>2.4.1闭散列</strong></span></h4> 
<p><span style="color:#333333;">闭散列：也叫开放定址法，当发生哈希冲突时，如果哈希表未被装满，说明在哈希表中必然还有空位置，那么可以</span><span style="color:#333333;">把</span><span style="color:#333333;">key</span><span style="color:#333333;">存放到冲突位置中的</span><span style="color:#333333;">“</span><span style="color:#333333;">下一个</span><span style="color:#333333;">” 空位置中去。</span>那么如何寻找下一个空位置呢？</p> 
<div> 
 <span style="color:#333333;">比如上面的场景，现在需要插入元素</span> 
 <span style="color:#333333;">44</span> 
 <span style="color:#333333;">，先通过哈希函数计算哈希地址，下标为</span> 
 <span style="color:#333333;">4</span> 
 <span style="color:#333333;">，因此</span> 
 <span style="color:#333333;">44</span> 
 <span style="color:#333333;">理论上应该插在该位置，但是该位置已经放了值为4</span> 
 <span style="color:#333333;">的元素，即发生哈希冲突。</span> 
</div> 
<p><span style="color:#333333;"><strong>1.线性探测</strong></span></p> 
<blockquote> 
 <p><span style="color:#333333;">线性探测：从发生冲突的位置开始，依次向后探测，直到寻找到下一个空位置为止。</span></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#333333;">插入：</span></p> 
 <ul><li><span style="color:#333333;">通过哈希函数获取待插入元素在哈希表中的位置；</span></li><li><span style="color:#333333;">如果该位置中没有元素则直接插入新元素，如果该位置中有元素发生哈希冲突，使用线性探测找到下一个空位置，插入新元素。</span></li></ul> 
</blockquote> 
<p><img alt="" height="398" src="https://images2.imgbox.com/e6/87/KljRV0XT_o.png" width="1200"><span style="color:#333333;">采用闭散列处理哈希冲突时，不能随便物理删除哈希表中已有的元素，若直接删除元素会影响其他元素的搜索。比如删除元素4，如果直接删除掉，44查找起来可能会受影响。因此线性探测采用标记的伪删除法来删除一个元素。</span></p> 
<p><span style="color:#333333;">2. </span><span style="color:#333333;"><strong>二次探测</strong></span></p> 
<p><span style="color:#333333;">线性探测的缺陷是产生冲突的数据堆积在一块，这与其找下一个空位置有关系，因为找空位置的方式就是挨着往后去找，因此二次探测为了避免该问题，找下一个空位置的方法为：</span><span style="color:#fe2c24;"><strong>Hi = (H0 + i²) % m</strong></span><span style="color:#333333;">，或者：</span><strong><span style="color:#fe2c24;">Hi = (H0 - i²) % m</span></strong><span style="color:#333333;">。其中：i = 1，2，3…，H0是通过散列函数Hash(x)对元素的关键码key进行计算得到的位置，m是表的大小。</span></p> 
<p><img alt="" height="750" src="https://images2.imgbox.com/eb/c5/2xHfFaHE_o.png" width="1134"></p> 
<div> 
 <span style="color:#333333;">研究表明：当表的长度为质数且表装载因子</span> 
 <span style="color:#333333;">a</span> 
 <span style="color:#333333;">不超过</span> 
 <span style="color:#333333;">0.5</span> 
 <span style="color:#333333;">时，新的表项一定能够插入，而且任何一个位置都不会被探查两次。因此只要表中有一半的空位置，就不会存在表满的问题。在搜索时可以不考虑表装满的情况，但在插入时必须确保表的装载因子a</span> 
 <span style="color:#333333;">不超过</span> 
 <span style="color:#333333;">0.5</span> 
 <span style="color:#333333;">，如果超出必须考虑增容。</span> 
</div> 
<div> 
 <span style="color:#fe2c24;"><strong>因此：比散列最大的缺陷就是空间利用率比较低，这也是哈希的缺陷。</strong></span> 
</div> 
<h4>2.4.2<span style="color:#333333;"><strong>开散列/哈希桶</strong></span></h4> 
<div> 
 <span style="color:#333333;">开散列法又叫链地址法</span> 
 <span style="color:#333333;">(</span> 
 <span style="color:#333333;">开链法</span> 
 <span style="color:#333333;">)</span> 
 <span style="color:#333333;">，首先对关键码集合用散列函数计算散列地址，具有相同地址的关键码归于同一子集合，每一个子集合称为一个桶，各个桶中的元素通过一个单链表链接起来，各链表的头结点存储在哈希表中。</span> 
</div> 
<p><img alt="" height="831" src="https://images2.imgbox.com/63/5b/x4LXBSLS_o.png" width="1137"></p> 
<div> 
 <span style="color:#333333;">从上图可以看出，开散列中每个桶中放的都是发生哈希冲突的元素。</span> 
</div> 
<div> 
 <span style="color:#333333;">因此开散列，我们可以认为是把一个在大集合中的搜索问题转化为在小集合中进行搜索。</span> 
</div> 
<div> 
 <div> 
  <span style="color:#333333;">我们上面提到哈希桶其实可以看作将大集合的搜索问题转化为小集合的搜索问题了，那如果冲突严重，就意味着小集合的搜索性能其实也时不佳的，这个时候我们就可以将这个所谓的小集合搜索问题继续进行转化，例如：</span> 
 </div> 
 <div> 
  <div> 
   <strong><span style="color:#333333;">1. </span><span style="color:#333333;">每个桶的背后是另一个哈希表 </span></strong> 
  </div> 
  <div> 
   <strong><span style="color:#333333;">2. </span><span style="color:#333333;">每个桶的背后是一棵搜索树</span></strong> 
  </div> 
  <div>
    哈希桶代码实现如下所示： 
  </div> 
  <div> 
   <pre><code class="language-java">public class HashBuck {
    //哈希桶
    static class Node {
        public int key;
        public int val;
        public Node next;

        public Node(int key, int val) {
            this.key = key;
            this.val = val;
        }
    }

    public Node[] arr;
    public int usedSize;
    public double loadFactorCount = 0.75;

    public HashBuck() {
        arr = new Node[10];
    }

    public void put(int key, int val) {
        int index = key % arr.length;
        Node cur = arr[index];
        //1.遍历当前链表，是否存在当前值
        while (cur != null) {
            if (cur.key == key) {
                cur.val = val;
                return;
            }
            cur = cur.next;
        }
        //2.说明没有当前值，此时进行头插
        Node node = new Node(key, val);
        node.next = arr[index];
        arr[index] = node;
        usedSize++;
        //3.超过负载因子0.75进行扩容
        if (loadFactorCount() &gt;= loadFactorCount) {
            //对数组进行扩容
            resize();
        }

    }

    private void resize() {
        Node[] arr1 = new Node[arr.length * 2];
        for (int i = 0; i &lt; arr.length; i++) {
            Node cur = arr[i];
            //开始遍历链表
            while (cur != null) {
                int index1 = cur.key % arr1.length;
                //把数据存放在新数组arr1位置
                Node cur1 = cur.next;
                cur.next = arr1[index1];
                arr1[index1] = cur;
                cur = cur1;
            }
        }
        arr = arr1;
    }

    private double loadFactorCount() {
        return usedSize * 1.0 / arr.length;
    }

    public int get(int key) {
        int index = key % arr.length;
        Node cur = arr[index];
        while (cur != null) {
            if (cur.key == key) {
                return cur.val;
            }
            cur = cur.next;
        }
        return -1;
    }
}
</code></pre> 
   <pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        HashBuck hashBuck = new HashBuck();
        hashBuck.put(1,20);
        hashBuck.put(14,22);
        hashBuck.put(8,11);
        hashBuck.put(6,99);
        hashBuck.put(9,41);
        System.out.println(hashBuck.get(8));
    }
}
</code></pre> 
   <p><img alt="" height="224" src="https://images2.imgbox.com/9c/66/5cXUgmBm_o.png" width="711"></p> 
  </div> 
  <h3>2.5<span style="color:#333333;"><strong>性能分析</strong></span></h3> 
  <div> 
   <span style="color:#333333;">虽然哈希表一直在和冲突做斗争，但在实际使用过程中，我们认为哈希表的冲突率是不高的，冲突个数是可控的，也就是每个桶中的链表的长度是一个常数，所以，通常意义下，我们认为<strong>哈希表的插入</strong></span> 
   <span style="color:#333333;"><strong>/</strong></span> 
   <span style="color:#333333;"><strong>删除</strong></span> 
   <span style="color:#333333;"><strong>/</strong></span> 
   <span style="color:#333333;"><strong>查找时间复杂度是</strong></span> 
   <span style="color:#333333;"><strong>O(1) </strong></span> 
   <span style="color:#333333;"><strong>。</strong></span> 
  </div> 
  <h2><span style="color:#333333;"><strong>3.哈希表和</strong></span><span style="color:#333333;"><strong> java </strong></span><span style="color:#333333;"><strong>类集的关系</strong></span></h2> 
  <p><span style="color:#333333;">1. HashMap 和</span><span style="color:#333333;"> HashSet </span><span style="color:#333333;">即</span><span style="color:#333333;"> java </span><span style="color:#333333;">中利用哈希表实现的</span><span style="color:#333333;"> Map </span><span style="color:#333333;">和</span><span style="color:#333333;"> Set </span></p> 
  <p><span style="color:#333333;">2. java 中使用的是哈希桶方式解决冲突的 </span></p> 
  <p><span style="color:#333333;">3. java 会在冲突链表长度大于一定阈值后，将链表转变为搜索树（红黑树） </span></p> 
  <div> 
   <span style="color:#333333;">4. java </span> 
   <span style="color:#333333;">中计算哈希值实际上是调用的类的</span> 
   <span style="color:#333333;"> hashCode </span> 
   <span style="color:#333333;">方法，进行</span> 
   <span style="color:#333333;"> key </span> 
   <span style="color:#333333;">的相等性比较是调用</span> 
   <span style="color:#333333;"> key </span> 
   <span style="color:#333333;">的</span> 
   <span style="color:#333333;"> equals 方</span> 
   <span style="color:#333333;">法。所以如果要用自定义类作为</span> 
   <span style="color:#333333;"> HashMap </span> 
   <span style="color:#333333;">的</span> 
   <span style="color:#333333;"> key </span> 
   <span style="color:#333333;">或者</span> 
   <span style="color:#333333;"> HashSet </span> 
   <span style="color:#333333;">的值，</span> 
   <span style="color:#333333;"><strong>必须覆写</strong></span> 
   <span style="color:#333333;"><strong>hashCode </strong></span> 
   <span style="color:#333333;"><strong>和</strong></span> 
   <span style="color:#333333;"><strong> equals </strong></span> 
   <span style="color:#333333;"><strong>方</strong></span> 
   <span style="color:#333333;"><strong>法</strong></span> 
   <span style="color:#333333;">，而且要做到</span> 
   <span style="color:#333333;"> equals </span> 
   <span style="color:#333333;">相等的对象，</span> 
   <span style="color:#333333;">hashCode </span> 
   <span style="color:#333333;">一定是一致的。</span> 
  </div> 
  <h2><span style="color:#333333;">4..总结</span></h2> 
  <p>哈希表是一种高效的数据结构，它通过哈希函数将元素的关键码映射到存储位置，以<strong>实现快速搜索、插入和删除操作</strong>。为了避免哈希冲突，我们可以通过设计合理的哈希函数、调整负载因子和解决冲突来降低冲突率，常见的哈希函数有<span style="color:#fe2c24;"><strong>直接定制法、除留余数法和平方取中法</strong></span>，以上就是本次所介绍的内容，我们下次再见。</p> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2411e5ef551ccb0c716d4ed23ba417c9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring Boot实战：拦截器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5543c96fa1e09bbd1472f1de7ad17fa5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">IAP程序升级 与 电脑BIOS 的关系</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>