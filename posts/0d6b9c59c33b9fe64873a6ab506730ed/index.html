<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【微服务】springboot 整合 SA-Token 使用详解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/0d6b9c59c33b9fe64873a6ab506730ed/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【微服务】springboot 整合 SA-Token 使用详解">
  <meta property="og:description" content="目录
一、前言
二、认证与授权介绍
2.1 什么是认证
2.1.1 认证的目的
2.1.2 认证基本步骤
2.2 什么是授权
2.2.1 常用的授权模型
三、微服务中常用的认证安全框架
3.1 Spring Security
3.1.1 Spring Security 特点
3.2 JWT (JSON Web Tokens)
3.2.1 JWT特点
3.3 其他认证安全框架
四、SA-Token介绍
4.1 SA-Token是什么
4.2 SA-Token特点
4.3 SA-Token使用场景
五、springboot集成SA-Token
5.1 数据准备
5.1.1 创建认证和授权使用相关的数据表
5.2 搭建springboot工程
5.2.1 导入基础依赖
5.2.2 添加配置文件
5.3 SA-Token 登录认证原理
5.3.1 SA-Token登录认证原理介绍
5.3.2 SA-Token登录登出核心API
5.4 SA-Token登录认证代码演示
5.4.1 增加token的配置类
5.4.2 增加全局异常处理类
5.4.3 登录登出接口
5.4.4 获取用户信息接口
5.4.5 接口测试与效果验证
5.4.6 集成redis管理登录会话">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-04T16:21:07+08:00">
    <meta property="article:modified_time" content="2024-08-04T16:21:07+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【微服务】springboot 整合 SA-Token 使用详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80" rel="nofollow">一、前言</a></p> 
<p id="%E4%BA%8C%E3%80%81%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E4%BB%8B%E7%BB%8D" rel="nofollow">二、认证与授权介绍</a></p> 
<p id="2.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A4%E8%AF%81-toc" style="margin-left:40px;"><a href="#2.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A4%E8%AF%81" rel="nofollow">2.1 什么是认证</a></p> 
<p id="2.1.1%20%E8%AE%A4%E8%AF%81%E7%9A%84%E7%9B%AE%E7%9A%84-toc" style="margin-left:80px;"><a href="#2.1.1%20%E8%AE%A4%E8%AF%81%E7%9A%84%E7%9B%AE%E7%9A%84" rel="nofollow">2.1.1 认证的目的</a></p> 
<p id="2.1.2%20%E8%AE%A4%E8%AF%81%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4-toc" style="margin-left:80px;"><a href="#2.1.2%20%E8%AE%A4%E8%AF%81%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4" rel="nofollow">2.1.2 认证基本步骤</a></p> 
<p id="2.2%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%88%E6%9D%83-toc" style="margin-left:40px;"><a href="#2.2%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%88%E6%9D%83" rel="nofollow">2.2 什么是授权</a></p> 
<p id="2.2.1%20%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%88%E6%9D%83%E6%A8%A1%E5%9E%8B-toc" style="margin-left:80px;"><a href="#2.2.1%20%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%88%E6%9D%83%E6%A8%A1%E5%9E%8B" rel="nofollow">2.2.1 常用的授权模型</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%A4%E8%AF%81%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%A4%E8%AF%81%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6" rel="nofollow">三、微服务中常用的认证安全框架</a></p> 
<p id="3.1%20Spring%20Security-toc" style="margin-left:40px;"><a href="#3.1%20Spring%20Security" rel="nofollow">3.1 Spring Security</a></p> 
<p id="3.1.1%20Spring%20Security%20%E7%89%B9%E7%82%B9-toc" style="margin-left:80px;"><a href="#3.1.1%20Spring%20Security%20%E7%89%B9%E7%82%B9" rel="nofollow">3.1.1 Spring Security 特点</a></p> 
<p id="3.2%20JWT%20(JSON%20Web%20Tokens)-toc" style="margin-left:40px;"><a href="#3.2%20JWT%20%28JSON%20Web%20Tokens%29" rel="nofollow">3.2 JWT (JSON Web Tokens)</a></p> 
<p id="3.2.1%20JWT%E7%89%B9%E7%82%B9-toc" style="margin-left:80px;"><a href="#3.2.1%20JWT%E7%89%B9%E7%82%B9" rel="nofollow">3.2.1 JWT特点</a></p> 
<p id="3.3%20%E5%85%B6%E4%BB%96%E8%AE%A4%E8%AF%81%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6-toc" style="margin-left:40px;"><a href="#3.3%20%E5%85%B6%E4%BB%96%E8%AE%A4%E8%AF%81%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6" rel="nofollow">3.3 其他认证安全框架</a></p> 
<p id="%E5%9B%9B%E3%80%81SA-Token%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81SA-Token%E4%BB%8B%E7%BB%8D" rel="nofollow">四、SA-Token介绍</a></p> 
<p id="4.1%20SA-Token%E6%98%AF%E4%BB%80%E4%B9%88-toc" style="margin-left:40px;"><a href="#4.1%20SA-Token%E6%98%AF%E4%BB%80%E4%B9%88" rel="nofollow">4.1 SA-Token是什么</a></p> 
<p id="4.2%20SA-Token%E7%89%B9%E7%82%B9-toc" style="margin-left:40px;"><a href="#4.2%20SA-Token%E7%89%B9%E7%82%B9" rel="nofollow">4.2 SA-Token特点</a></p> 
<p id="4.3%20SA-Token%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#4.3%20SA-Token%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">4.3 SA-Token使用场景</a></p> 
<p id="%E4%BA%94%E3%80%81springboot%E9%9B%86%E6%88%90SA-Token-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81springboot%E9%9B%86%E6%88%90SA-Token" rel="nofollow">五、springboot集成SA-Token</a></p> 
<p id="5.1%20%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87-toc" style="margin-left:40px;"><a href="#5.1%20%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87" rel="nofollow">5.1 数据准备</a></p> 
<p id="5.1.1%20%E5%88%9B%E5%BB%BA%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A1%A8-toc" style="margin-left:80px;"><a href="#5.1.1%20%E5%88%9B%E5%BB%BA%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A1%A8" rel="nofollow">5.1.1 创建认证和授权使用相关的数据表</a></p> 
<p id="5.2%20%E6%90%AD%E5%BB%BAspringboot%E5%B7%A5%E7%A8%8B-toc" style="margin-left:40px;"><a href="#5.2%20%E6%90%AD%E5%BB%BAspringboot%E5%B7%A5%E7%A8%8B" rel="nofollow">5.2 搭建springboot工程</a></p> 
<p id="5.2.1%20%E5%AF%BC%E5%85%A5%E5%9F%BA%E7%A1%80%E4%BE%9D%E8%B5%96-toc" style="margin-left:80px;"><a href="#5.2.1%20%E5%AF%BC%E5%85%A5%E5%9F%BA%E7%A1%80%E4%BE%9D%E8%B5%96" rel="nofollow">5.2.1 导入基础依赖</a></p> 
<p id="5.2.2%20%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#5.2.2%20%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" rel="nofollow">5.2.2 添加配置文件</a></p> 
<p id="5.3%20SA-Token%20%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#5.3%20SA-Token%20%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E5%8E%9F%E7%90%86" rel="nofollow">5.3 SA-Token 登录认证原理</a></p> 
<p id="5.3.1%20SA-Token%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D-toc" style="margin-left:80px;"><a href="#5.3.1%20SA-Token%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D" rel="nofollow">5.3.1 SA-Token登录认证原理介绍</a></p> 
<p id="5.3.2%20SA-Token%E7%99%BB%E5%BD%95%E7%99%BB%E5%87%BA%E6%A0%B8%E5%BF%83API-toc" style="margin-left:80px;"><a href="#5.3.2%20SA-Token%E7%99%BB%E5%BD%95%E7%99%BB%E5%87%BA%E6%A0%B8%E5%BF%83API" rel="nofollow">5.3.2 SA-Token登录登出核心API</a></p> 
<p id="5.4%20SA-Token%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-toc" style="margin-left:40px;"><a href="#5.4%20SA-Token%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA" rel="nofollow">5.4 SA-Token登录认证代码演示</a></p> 
<p id="5.4.1%20%E5%A2%9E%E5%8A%A0token%E7%9A%84%E9%85%8D%E7%BD%AE%E7%B1%BB-toc" style="margin-left:80px;"><a href="#5.4.1%20%E5%A2%9E%E5%8A%A0token%E7%9A%84%E9%85%8D%E7%BD%AE%E7%B1%BB" rel="nofollow">5.4.1 增加token的配置类</a></p> 
<p id="5.4.2%20%E5%A2%9E%E5%8A%A0%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%B1%BB-toc" style="margin-left:80px;"><a href="#5.4.2%20%E5%A2%9E%E5%8A%A0%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%B1%BB" rel="nofollow">5.4.2 增加全局异常处理类</a></p> 
<p id="5.4.3%20%E7%99%BB%E5%BD%95%E7%99%BB%E5%87%BA%E6%8E%A5%E5%8F%A3-toc" style="margin-left:80px;"><a href="#5.4.3%20%E7%99%BB%E5%BD%95%E7%99%BB%E5%87%BA%E6%8E%A5%E5%8F%A3" rel="nofollow">5.4.3 登录登出接口</a></p> 
<p id="5.4.4%20%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E6%8E%A5%E5%8F%A3-toc" style="margin-left:80px;"><a href="#5.4.4%20%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E6%8E%A5%E5%8F%A3" rel="nofollow">5.4.4 获取用户信息接口</a></p> 
<p id="5.4.5%20%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%95%88%E6%9E%9C%E9%AA%8C%E8%AF%81-toc" style="margin-left:80px;"><a href="#5.4.5%20%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%95%88%E6%9E%9C%E9%AA%8C%E8%AF%81" rel="nofollow">5.4.5 接口测试与效果验证</a></p> 
<p id="5.4.6%20%E9%9B%86%E6%88%90redis%E7%AE%A1%E7%90%86%E7%99%BB%E5%BD%95%E4%BC%9A%E8%AF%9D-toc" style="margin-left:80px;"><a href="#5.4.6%20%E9%9B%86%E6%88%90redis%E7%AE%A1%E7%90%86%E7%99%BB%E5%BD%95%E4%BC%9A%E8%AF%9D" rel="nofollow">5.4.6 集成redis管理登录会话</a></p> 
<p id="5.5%20SA-Token%E6%8E%88%E6%9D%83%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#5.5%20SA-Token%E6%8E%88%E6%9D%83%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D" rel="nofollow">5.5 SA-Token授权模型介绍</a></p> 
<p id="5.5.1%20SA-Token%E6%9D%83%E9%99%90%E6%A6%82%E8%BF%B0-toc" style="margin-left:80px;"><a href="#5.5.1%20SA-Token%E6%9D%83%E9%99%90%E6%A6%82%E8%BF%B0" rel="nofollow">5.5.1 SA-Token权限概述</a></p> 
<p id="5.5.2%20SA-Token%E6%9D%83%E9%99%90%E6%A0%B8%E5%BF%83API%E8%AF%B4%E6%98%8E-toc" style="margin-left:80px;"><a href="#5.5.2%20SA-Token%E6%9D%83%E9%99%90%E6%A0%B8%E5%BF%83API%E8%AF%B4%E6%98%8E" rel="nofollow">5.5.2 SA-Token权限核心API说明</a></p> 
<p id="5.6%20SA-Token%E6%8E%88%E6%9D%83%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-toc" style="margin-left:40px;"><a href="#5.6%20SA-Token%E6%8E%88%E6%9D%83%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA" rel="nofollow">5.6 SA-Token授权代码演示</a></p> 
<p id="5.6.1%20%E6%96%B0%E5%A2%9EStpInterfaceImpl%E7%B1%BB-toc" style="margin-left:80px;"><a href="#5.6.1%20%E6%96%B0%E5%A2%9EStpInterfaceImpl%E7%B1%BB" rel="nofollow">5.6.1 新增StpInterfaceImpl类</a></p> 
<p id="5.6.2%20%E7%94%A8%E6%88%B7%E6%8E%A5%E5%8F%A3%E6%94%B9%E9%80%A0-toc" style="margin-left:80px;"><a href="#5.6.2%20%E7%94%A8%E6%88%B7%E6%8E%A5%E5%8F%A3%E6%94%B9%E9%80%A0" rel="nofollow">5.6.2 用户接口改造</a></p> 
<p id="5.6.3%20%E6%8E%A5%E5%8F%A3%E6%9D%83%E9%99%90%E6%95%88%E6%9E%9C%E6%B5%8B%E8%AF%95-toc" style="margin-left:80px;"><a href="#5.6.3%20%E6%8E%A5%E5%8F%A3%E6%9D%83%E9%99%90%E6%95%88%E6%9E%9C%E6%B5%8B%E8%AF%95" rel="nofollow">5.6.3 接口权限效果测试</a></p> 
<p id="%E5%85%AD%E3%80%81%E5%86%99%E5%9C%A8%E6%96%87%E6%9C%AB-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E5%86%99%E5%9C%A8%E6%96%87%E6%9C%AB" rel="nofollow">六、写在文末</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80">一、前言</h2> 
<p>互联网安全的理念这些年逐渐开始深入人心，以java流行的微服务技术体系来说，安全可以说是构筑微服务系统项目的基石，所以在微服务的技术选型和技术组件中，随处可见安全的影子，比如在springcloud体系中，gateway网关就承载了所有进入微服务接口的安全防线作用，再比如，所有访问系统资源的用户或请求，必须经过登录认证等，但是这些还远远不够，对于一个系统来说，必须从设计和技术选型阶段，就应该结合当前的现状将系统安全作为一个重要的因素考虑进去，从而避免给后续带来麻烦。</p> 
<p></p> 
<h2 id="%E4%BA%8C%E3%80%81%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E4%BB%8B%E7%BB%8D">二、认证与授权介绍</h2> 
<p></p> 
<h3 id="2.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A4%E8%AF%81">2.1 什么是认证</h3> 
<p>在微服务架构中，认证（Authentication）是指确认用户身份的过程。认证是安全领域的一个核心概念，在微服务架构中尤其重要，因为微服务通常通过网络进行交互，这意味着需要确保每个服务请求都是经过适当身份验证。</p> 
<p></p> 
<h4 id="2.1.1%20%E8%AE%A4%E8%AF%81%E7%9A%84%E7%9B%AE%E7%9A%84">2.1.1 认证的目的</h4> 
<p>认证通常具有下面作用：</p> 
<ul><li> <p><strong>验证用户身份</strong>：</p> 
  <ul><li> <p>确保请求是由授权用户发出的；</p> </li></ul></li><li> <p><strong>保护资源安全</strong>：</p> 
  <ul><li> <p>限制对敏感数据或操作的访问；</p> </li><li> <p>通常是为了限制对系统服务API的访问；</p> </li></ul></li><li> <p><strong>跟踪和审计</strong>：</p> 
  <ul><li> <p>记录谁访问了哪些资源，以及进行了什么操作；</p> </li></ul></li></ul> 
<p></p> 
<h4 id="2.1.2%20%E8%AE%A4%E8%AF%81%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4">2.1.2 认证基本步骤</h4> 
<p>尽管不同的微服务系统在技术选型上略有差异，但是认证的基本流程是类似的，下面是一个相对通用的认证流程：</p> 
<ul><li> <p><strong>用户提交凭证</strong></p> 
  <ul><li> <p>用户在尝试访问受保护资源之前，需提交某种形式的凭证，如用户名/密码、API 密钥、令牌等；</p> </li></ul></li><li> <p><strong>验证凭证</strong></p> 
  <ul><li> <p>服务端验证用户提供的凭证是否有效；</p> </li></ul></li><li> <p><strong>颁发凭证</strong></p> 
  <ul><li> <p>如果凭证有效，则颁发一个新的凭证（如访问令牌）给用户，以便后续请求使用；</p> </li></ul></li><li> <p><strong>使用凭证访问资源</strong></p> 
  <ul><li> <p>用户使用颁发的凭证来访问受保护资源；</p> </li></ul></li></ul> 
<p></p> 
<blockquote> 
 <p>事实上，在现在很多微服务项目中，集成了第三方安全框架之后，上面的这些基本的认证流程在安全框架中已经替我们实现了，开发人员只需要集成并按照规范使用即可。</p> 
</blockquote> 
<p></p> 
<h3 id="2.2%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%88%E6%9D%83">2.2 什么是授权</h3> 
<p></p> 
<p>很多初学者很容易把认证与授权这两个概念混为一谈，这样理解肯定是错误的，授权（Authorization）是指确定已经通过认证的用户或服务，能够访问哪些资源或执行哪些操作的过程。授权是在认证之后发生的，通常用来控制访问级别和权限。为什么要授权，主要出于下面的考虑：</p> 
<ul><li> <p><strong>访问控制</strong>：确定用户可以访问哪些资源或执行哪些操作；</p> </li><li> <p><strong>安全性</strong>：防止未经授权的访问，保护敏感数据和功能；</p> </li><li> <p><strong>角色管理</strong>：基于用户的角色来授予不同的权限；</p> </li><li> <p><strong>审计和合规性</strong>：确保系统符合法规要求，如 GDPR 或 HIPAA；</p> </li></ul> 
<p></p> 
<h4 id="2.2.1%20%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%88%E6%9D%83%E6%A8%A1%E5%9E%8B">2.2.1 常用的授权模型</h4> 
<p>在项目开发中，授权模型的选择至关重要，这将关系到系统中涉及到权限控制的方方面面，下面介绍几种常用的授权模型：</p> 
<ul><li> <p><strong>基于角色的访问控制 (RBAC)</strong>：</p> 
  <ul><li> <p><strong>简介</strong>：根据用户的角色来决定他们可以访问哪些资源或执行哪些操作。</p> </li><li> <p><strong>优点</strong>：易于管理和维护，可以轻松地为角色添加或移除权限。</p> </li><li> <p><strong>应用场景</strong>：RBAC是经典的授权模型，适用于大多数企业级的应用。</p> </li></ul></li><li> <p><strong>基于属性的访问控制 (ABAC)</strong>：</p> 
  <ul><li> <p><strong>简介</strong>：基于用户相关属性（如部门、地理位置等）及环境条件（如时间、设备等）来决定访问权限。</p> </li><li> <p><strong>优点</strong>：高度灵活，可以适应复杂的业务需求。</p> </li><li> <p><strong>应用场景</strong>：适用于需要精细控制访问权限的场景。</p> </li></ul></li><li> <p><strong>强制访问控制 (MAC)</strong>：</p> 
  <ul><li> <p><strong>简介</strong>：基于安全标签来决定访问权限，通常用于政务类、军工类相关的项目。</p> </li><li> <p><strong>优点</strong>：提供最高安全级别的安全性。</p> </li><li> <p><strong>应用场景</strong>：适用于需要严格安全控制的环境。</p> </li></ul></li></ul> 
<p></p> 
<blockquote> 
 <p>基本上来说，RBAC如果设计和使用得当，就能满足大多数的项目了，配合一些安全框架的使用，既能达到一定的安全等级，如果项目中还需要对更细粒度的权限进行控制，可以基于RBAC作为基础模型进行数据表的扩展即可。</p> 
</blockquote> 
<p></p> 
<h2 id="%E4%B8%89%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%A4%E8%AF%81%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6">三、微服务中常用的认证安全框架</h2> 
<p>在微服务开发中，可以说越来越少的项目纯粹靠手写安全组件来维护整个系统的权限体系了，多少是借助第三方安全框架集成到项目中进行使用，下面介绍几种微服务中常用的涉及安全认证的技术框架。</p> 
<p></p> 
<h3 id="3.1%20Spring%20Security">3.1 Spring Security</h3> 
<p>Spring Security 是 Spring 生态体系中最成熟、最全面的安全框架，提供了丰富的认证和授权功能，得到了众多公司项目的使用和认可。它提供丰富的认证机制，如表单认证、OAuth2、JWT 等。</p> 
<h4></h4> 
<h4 id="3.1.1%20Spring%20Security%20%E7%89%B9%E7%82%B9">3.1.1 Spring Security 特点</h4> 
<p>Spring Security具有如下特点：</p> 
<ul><li> <p>灵活性好</p> 
  <ul><li> <p><strong>高度可配置</strong>：Spring Security 提供了高度可配置的 API，允许开发者根据自己的需求定制认证和授权逻辑；</p> </li><li> <p><strong>支持多种认证机制</strong>：支持表单认证、HTTP Basic 认证、OAuth2、OpenID Connect、JWT 等多种认证机制；</p> </li><li> <p><strong>可扩展性</strong>：可以轻松地扩展 Spring Security 的功能，例如自定义认证处理器、密码编码器等。</p> </li></ul></li><li> <p>安全功能完善</p> 
  <ul><li> <p><strong>认证</strong>：提供了多种认证方式，包括基于表单、基于 HTTP Basic、基于 OAuth2 等；</p> </li><li> <p><strong>授权</strong>：支持基于角色的访问控制 (RBAC) 和基于属性的访问控制 (ABAC)；</p> </li><li> <p><strong>会话管理</strong>：可以管理用户的会话，包括会话固定保护、会话超时等；</p> </li><li> <p><strong>CSRF 保护</strong>：提供了针对跨站请求伪造 (CSRF) 攻击的保护机制；</p> </li><li> <p><strong>跨站脚本防护</strong>：提供了针对跨站脚本 (XSS) 攻击的防护措施；</p> </li><li> <p><strong>异常处理</strong>：可以配置异常处理逻辑，以优雅地处理认证失败或授权失败的情况。</p> </li></ul></li><li> <p>与其他组件集成能力强</p> 
  <ul><li> <p><strong>与 Spring 生态系统无缝集成</strong>：Spring Security 是 Spring 生态系统的一部分，可以轻松地与其他 Spring 框架集成，如 Spring MVC、Spring Boot 等；</p> </li><li> <p><strong>支持多种数据源</strong>：可以使用 JDBC、LDAP、Active Directory 等多种数据源进行用户认证和授权；</p> </li><li> <p><strong>与其他框架的集成</strong>：可以与其他非 Spring 框架（如 JAX-RS、Vaadin 等）集成。</p> </li></ul></li><li> <p>社区活跃</p> 
  <ul><li> <p><strong>广泛的社区支持</strong>：Spring Security 有着庞大的开发者社区，提供了丰富的文档、教程和示例；</p> </li><li> <p><strong>活跃的开发团队</strong>：Spring Security 由 Pivotal（现 VMware）维护，定期发布新版本和安全更新。</p> </li></ul></li><li> <p>文档和资源丰富</p> 
  <ul><li> <p><strong>详细的文档</strong>：Spring Security 提供了详细的官方文档，覆盖了框架的所有方面；</p> </li><li> <p><strong>丰富的教程和示例</strong>：有许多教程和示例可供参考，帮助开发者快速上手。</p> </li></ul></li></ul> 
<p></p> 
<h3 id="3.2%20JWT%20(JSON%20Web%20Tokens)">3.2 JWT (JSON Web Tokens)</h3> 
<p>JWT 是一种轻量级的令牌标准，用于在各方之间安全地传输信息。在微服务架构中，JWT 常被用作认证机制的一部分，特别是在无状态服务中。</p> 
<p></p> 
<h4 id="3.2.1%20JWT%E7%89%B9%E7%82%B9">3.2.1 JWT特点</h4> 
<p>JWT具有如下特点：</p> 
<ul><li> <p>无状态</p> 
  <ul><li> <p><strong>特点</strong>：JWT 是一个自包含的令牌，不需要服务器保存会话状态或查询数据库来验证用户身份；</p> </li><li> <p><strong>优点</strong>：减少了服务器的负担，提高了可伸缩性和性能。</p> </li></ul></li><li> <p>自包含</p> 
  <ul><li> <p><strong>特点</strong>：JWT 包含了所有必要的信息，如用户标识、权限等，这些信息在令牌本身中编码；</p> </li><li> <p><strong>优点</strong>：不需要额外的数据库查询来验证用户信息，使得 JWT 成为一种快速的认证机制。</p> </li></ul></li><li> <p>轻量级</p> 
  <ul><li> <p><strong>特点</strong>：JWT 是一个轻量级的 JSON 对象，内容体积小，传输效率高；</p> </li><li> <p><strong>优点</strong>：降低了网络带宽的消耗，提高了系统的响应速度。</p> </li></ul></li><li> <p>安全性好</p> 
  <ul><li> <p><strong>特点</strong>：JWT 可以使用 HMAC 算法或 RSA 的公私钥对进行签名，确保了数据的完整性和安全性；</p> </li><li> <p><strong>优点</strong>：可以防止令牌被篡改，确保了数据传输的安全性。</p> </li></ul></li><li> <p>支持多种签名算法</p> 
  <ul><li> <p><strong>特点</strong>：JWT 支持多种签名算法，包括 HMAC SHA256、RSA/ECDSA 等；</p> </li><li> <p><strong>优点</strong>：可以根据安全需求选择合适的签名算法。</p> </li></ul></li><li> <p>扩展性好</p> 
  <ul><li> <p><strong>特点</strong>：JWT 可以包含任意数量的自定义声明，允许在令牌中携带更多的信息；</p> </li><li> <p><strong>优点</strong>：可以根据应用需求灵活地扩展令牌的内容。</p> </li></ul></li><li> <p>解析简单</p> 
  <ul><li> <p><strong>特点</strong>：JWT 的结构清晰，可以很容易地被客户端和服务端解析；</p> </li><li> <p><strong>优点</strong>：简化了开发过程，提高了开发效率。</p> </li></ul></li></ul> 
<p></p> 
<h3 id="3.3%20%E5%85%B6%E4%BB%96%E8%AE%A4%E8%AF%81%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6">3.3 其他认证安全框架</h3> 
<p>这里再补充其他几种框架作为知识的扩展；</p> 
<ul><li> <p>Apache Shiro</p> 
  <ul><li> <p>Apache Shiro 是一个强大且易用的 Java 安全框架，提供了认证、授权、加密和会话管理等功能。</p> 
    <ul><li> <p>提供了丰富的认证和授权功能。</p> </li><li> <p>支持多种认证机制，如表单认证、LDAP 等。</p> </li><li> <p>可以与 Spring 框架很好地集成。</p> </li><li> <p>提供了详细的文档和支持社区。</p> </li></ul></li></ul></li><li> <p>Spring Cloud Security</p> 
  <ul><li> <p>Spring Cloud Security 是 Spring Cloud 的一部分，它为 Spring Cloud 应用提供了一种简单的方法来实现安全性和认证。</p> 
    <ul><li> <p>集成了 Spring Security，提供了微服务安全性的最佳实践。</p> </li><li> <p>支持 OAuth2 和 JWT。</p> </li><li> <p>适用于 Spring Cloud 的服务发现和配置中心。</p> </li></ul></li></ul></li><li> <p>OAuth2</p> 
  <ul><li> <p>OAuth2 是一个开放标准，用于授权第三方应用访问用户的资源，而无需共享用户的凭证。</p> 
    <ul><li> <p>支持多种授权模式，如密码模式、授权码模式、客户端凭证模式等。</p> </li><li> <p>可以与其他认证框架（如 Spring Security）结合使用。</p> </li><li> <p>适用于服务间通信的认证和授权。</p> </li></ul></li></ul></li><li> <p>Keycloak</p> 
  <ul><li> <p>Keycloak 是一个开源的身份和访问管理解决方案，提供了一个全面的认证和授权平台。</p> 
    <ul><li> <p>支持多种认证协议，如 OAuth2、OpenID Connect、SAML 等。</p> </li><li> <p>可以作为独立的服务部署，也可以集成到现有的应用中。</p> </li><li> <p>提供了用户管理、角色管理等功能。</p> </li><li> <p>支持多租户，便于管理多个不同的应用。</p> </li></ul></li></ul></li></ul> 
<p></p> 
<h2 id="%E5%9B%9B%E3%80%81SA-Token%E4%BB%8B%E7%BB%8D">四、SA-Token介绍</h2> 
<p></p> 
<h3 id="4.1%20SA-Token%E6%98%AF%E4%BB%80%E4%B9%88">4.1 SA-Token是什么</h3> 
<p>SA-Token（Simple Authentication Token）是一个轻量级的 Java 认证框架，旨在提供简单易用的认证和授权功能。SA-Token 的设计目标是简单、高效，并且易于集成到现有的 Java 项目中，特别是 Spring Boot 的微服务项目。官网：<a href="https://sa-token.cc/" rel="nofollow" title="Sa-Token">Sa-Token</a>，文档地址：<a href="https://sa-token.cc/doc.html#/" rel="nofollow" title="Sa-Token">Sa-Token</a></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/dd/0b/TwEaOIld_o.png"></p> 
<h3 id="4.2%20SA-Token%E7%89%B9%E7%82%B9">4.2 SA-Token特点</h3> 
<p>SA-Token具有如下特点：</p> 
<ul><li> <p><strong>轻量级</strong></p> 
  <ul><li> <p>SA-Token 的设计初衷是为了提供一个轻量级的认证框架，相比于 Spring Security 等重量级框架，SA-Token 的使用更为简单直接；</p> </li></ul></li><li> <p>上手简单</p> 
  <ul><li> <p>提供了简洁的 API 接口，使得开发者可以快速上手；</p> </li><li> <p>支持多种认证方式，如基于 Token 的认证、基于 Session 的认证等。</p> </li></ul></li><li> <p>性能高</p> 
  <ul><li> <p>采用内存缓存来存储认证信息，减少了数据库的访问频率，提高了系统的性能。</p> </li></ul></li><li> <p>安全性高</p> 
  <ul><li> <p>支持多种加密算法，如 SHA256、HMAC-SHA256 等，确保了令牌的安全性；</p> </li><li> <p>支持令牌的过期时间设置，增强了安全性。</p> </li></ul></li><li> <p>可扩展性好</p> 
  <ul><li> <p>提供了丰富的事件监听器，可以方便地扩展认证逻辑；</p> </li><li> <p>支持自定义认证处理器，可以根据需要定制认证流程。</p> </li></ul></li><li> <p>社区支持</p> 
  <ul><li> <p>拥有一定的社区支持，可以通过官方文档、GitHub 仓库等渠道获得帮助。</p> </li></ul></li></ul> 
<p></p> 
<h3 id="4.3%20SA-Token%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">4.3 SA-Token使用场景</h3> 
<p>SA-Token基于自身的特点，具有丰富的使用场景，下面列举了一些常用的场景：</p> 
<ul><li> <p>单体服务应用</p> 
  <ul><li> <p>对于一般的单体应用，SA-Token 可作为一个快速的认证解决方案，它可以提供基于 Token 的认证，易于集成到现有的项目中。</p> </li></ul></li><li> <p>微服务架构</p> 
  <ul><li> <p>在微服务架构中，SA-Token 可以作为一个轻量级的认证框架，用于处理服务间的认证和授权。它可以提供高性能的认证服务，并且易于扩展。</p> </li></ul></li><li> <p>API 服务</p> 
  <ul><li> <p>对于 RESTful API 或 GraphQL 服务，SA-Token 可以提供基于 Token 的认证机制，确保 API 请求的安全性。</p> </li></ul></li><li> <p>管理后台系统</p> 
  <ul><li> <p>在管理后台系统中，SA-Token 可以提供用户认证和权限控制，确保只有经过认证的用户才能访问管理界面。</p> </li></ul></li><li> <p>用户权限系统</p> 
  <ul><li> <p>SA-Token 可以用于实现用户权限系统，支持角色和权限的管理。它可以提供基于角色的访问控制（RBAC）功能，方便地管理用户权限。</p> </li></ul></li></ul> 
<blockquote> 
 <p>SA-Token 是一个轻量级的 Java 认证框架，适用于需要简单认证逻辑的项目。它提供了易用的 API 和丰富的功能，可以轻松地集成到 Java 项目中。如果你正在寻找一个简单、高效且易于使用的认证框架，SA-Token 是一个不错的选择。</p> 
</blockquote> 
<p></p> 
<h2 id="%E4%BA%94%E3%80%81springboot%E9%9B%86%E6%88%90SA-Token">五、springboot集成SA-Token</h2> 
<p>接下来，详细介绍下如何在springboot项目中集成SA-Token</p> 
<p></p> 
<h3 id="5.1%20%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87">5.1 数据准备</h3> 
<h4></h4> 
<h4 id="5.1.1%20%E5%88%9B%E5%BB%BA%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A1%A8">5.1.1 创建认证和授权使用相关的数据表</h4> 
<p>为了后续模拟登录，认证和鉴权相关的功能，提前创建几张数据表并初始化一些数据，不难看出，这正是经典的rbac的权限模型，如下：</p> 
<pre><code class="language-sql">-- 用户表
CREATE TABLE `user` (
  `user_id` int NOT NULL,
  `user_name` varchar(32) COLLATE utf8mb4_bin DEFAULT NULL,
  `password` varchar(32) COLLATE utf8mb4_bin DEFAULT NULL,
  `real_name` varchar(32) COLLATE utf8mb4_bin DEFAULT NULL,
  `dept_name` varchar(255) COLLATE utf8mb4_bin DEFAULT NULL,
  PRIMARY KEY (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

INSERT INTO `db_sky`.`user`(`user_id`, `user_name`, `password`, `real_name`, `dept_name`) VALUES (1, 'zhangsan', '123456', '张三', '技术部');
INSERT INTO `db_sky`.`user`(`user_id`, `user_name`, `password`, `real_name`, `dept_name`) VALUES (2, 'lishi', '123456', '李四', '测试部');


-- 角色表
CREATE TABLE `role` (
  `role_id` int NOT NULL,
  `role_code` varchar(32) COLLATE utf8mb4_bin NOT NULL,
  `role_name` varchar(32) COLLATE utf8mb4_bin NOT NULL,
  PRIMARY KEY (`role_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

INSERT INTO `db_sky`.`role`(`role_id`, `role_code`, `role_name`) VALUES (1, 'admin', '管理员');
INSERT INTO `db_sky`.`role`(`role_id`, `role_code`, `role_name`) VALUES (2, 'guest', '游客');


-- 权限表
CREATE TABLE `permission` (
  `permission_id` int NOT NULL,
  `permission_code` varchar(32) COLLATE utf8mb4_bin DEFAULT NULL,
  PRIMARY KEY (`permission_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

INSERT INTO `db_sky`.`permission`(`permission_id`, `permission_code`) VALUES (1, 'user-read');
INSERT INTO `db_sky`.`permission`(`permission_id`, `permission_code`) VALUES (2, 'user-write');
INSERT INTO `db_sky`.`permission`(`permission_id`, `permission_code`) VALUES (3, 'product-read');
INSERT INTO `db_sky`.`permission`(`permission_id`, `permission_code`) VALUES (4, 'product-write');


-- 用户角色关联表
CREATE TABLE `role_user` (
  `id` int NOT NULL,
  `role_id` int DEFAULT NULL,
  `user_id` int DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

INSERT INTO `db_sky`.`role_user`(`id`, `role_id`, `user_id`) VALUES (1, 1, 1);
INSERT INTO `db_sky`.`role_user`(`id`, `role_id`, `user_id`) VALUES (2, 2, 1);
INSERT INTO `db_sky`.`role_user`(`id`, `role_id`, `user_id`) VALUES (3, 2, 2);

-- 角色权限表
CREATE TABLE `role_permission` (
  `id` int NOT NULL,
  `role_id` int DEFAULT NULL,
  `permission_id` int DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

INSERT INTO `db_sky`.`role_permission`(`id`, `role_id`, `permission_id`) VALUES (1, 1, 1);
INSERT INTO `db_sky`.`role_permission`(`id`, `role_id`, `permission_id`) VALUES (2, 1, 2);
INSERT INTO `db_sky`.`role_permission`(`id`, `role_id`, `permission_id`) VALUES (3, 1, 3);
INSERT INTO `db_sky`.`role_permission`(`id`, `role_id`, `permission_id`) VALUES (4, 1, 4);
INSERT INTO `db_sky`.`role_permission`(`id`, `role_id`, `permission_id`) VALUES (7, 2, 1);
INSERT INTO `db_sky`.`role_permission`(`id`, `role_id`, `permission_id`) VALUES (8, 2, 3);</code></pre> 
<h3 id="5.2%20%E6%90%AD%E5%BB%BAspringboot%E5%B7%A5%E7%A8%8B">5.2 搭建springboot工程</h3> 
<h4></h4> 
<h4 id="5.2.1%20%E5%AF%BC%E5%85%A5%E5%9F%BA%E7%A1%80%E4%BE%9D%E8%B5%96">5.2.1 导入基础依赖</h4> 
<p>添加如下依赖，由于需要操作数据库，本例使用mybatis+mysql的方式，其他依赖可根据自身情况添加</p> 
<pre><code class="language-java">    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.5.5&lt;/version&gt;
        &lt;relativePath/&gt;
    &lt;/parent&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.1.17&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- MyBatis Starter --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.2.2&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;cn.dev33&lt;/groupId&gt;
            &lt;artifactId&gt;sa-token-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.38.0&lt;/version&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;</code></pre> 
<p></p> 
<h4 id="5.2.2%20%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">5.2.2 添加配置文件</h4> 
<p>yml配置文件中添加如下的配置内容，关于sa-token部分的配置文件，给出了详细的解释说明，更多的配置，可以参阅官网，根据自身的需要进行添加或参数的调整，可以参考：<a href="https://sa-token.cc/doc.html#/start/example" rel="nofollow" title="Sa-Token">Sa-Token</a></p> 
<pre><code class="language-java">server:
  port: 8081

spring:
  application:
    name: user-service

  datasource:
    url: jdbc:mysql://IP:3306/db_sky
    driverClassName: com.mysql.jdbc.Driver
    username: root
    password: 123456

mybatis:
  mapper-locations: classpath:mapper/*.xml
  #目的是为了省略resultType里的代码量
  type-aliases-package: com.congge.entity
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl

sa-token:
  #token的名称，也即cookie的名称
  token-name: satoken
  #token的有效期（单位/秒），默认30天，-1代表永久有效
  timeout: 2592000
  #token最低活跃频率（单位/秒），如果token超过次时间没有访问系统就会被冻结，默认-1表示不限制
  active-timeout: -1
  #是否允许同一账号多地登录 （为true允许一起登录，为false表示新登录挤掉旧的）
  is-concurrent: true
  #在多人登录同一个账号的同时，是否共用一个token
  is-share: true
  #token的风格形式（可选值：uuid，simple-uuid，random-32，random-64，random-128，tik）
  token-style: uuid
  #是否输出日志
  is-log: true</code></pre> 
<p></p> 
<h3 id="5.3%20SA-Token%20%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E5%8E%9F%E7%90%86">5.3 SA-Token 登录认证原理</h3> 
<h4></h4> 
<h4 id="5.3.1%20SA-Token%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D">5.3.1 SA-Token登录认证原理介绍</h4> 
<p>使用安全认证框架，一般来说主要是借助框架的能力做两点需求，认证，和授权，这也是实际做技术选型的核心考虑要素，认证，通常是通过登录的过程体现的，用户输入账号信息，SA-Token介入这个过程，从而管理用户的会话生命周期，具体来说：</p> 
<ul><li> <p>用户提交 <code>name</code> + <code>password</code> 参数，调用登录接口；</p> </li><li> <p>登录成功，返回这个用户的 Token 会话凭证；</p> </li><li> <p>用户后续的每次请求，都携带上这个 Token；</p> </li><li> <p>服务器根据 Token 判断此会话是否登录成功；</p> </li></ul> 
<blockquote> 
 <p>所谓登录认证，指的就是服务器校验账号密码，为用户颁发 Token 会话凭证的过程，这个 Token 也是我们后续判断会话是否登录的关键所在。</p> 
</blockquote> 
<h4></h4> 
<h4 id="5.3.2%20SA-Token%E7%99%BB%E5%BD%95%E7%99%BB%E5%87%BA%E6%A0%B8%E5%BF%83API">5.3.2 SA-Token登录登出核心API</h4> 
<p>在SA-Token的API中，核心的登录API只有下面一句</p> 
<pre><code class="language-java">// 会话登录：参数填写要登录的账号id，建议的数据类型：long | int | String， 不可以传入复杂类型，如：User、Admin 等等
StpUtil.login(Object id);     </code></pre> 
<p>只此一句代码，便可以使会话登录成功，实际上，Sa-Token 在背后做了大量的工作，包括但不限于：</p> 
<ul><li> <p>检查此账号是否之前已有登录；</p> </li><li> <p>为账号生成 <code>Token</code> 凭证与 <code>Session</code> 会话；</p> </li><li> <p>记录 Token 活跃时间；</p> </li><li> <p>通知全局侦听器，xx 账号登录成功；</p> </li><li> <p>将 <code>Token</code> 注入到请求上下文；</p> </li><li> <p>其他要处理的业务...</p> </li></ul> 
<p>除了登录方法，在其API中，我们可能还需要下面的一些方法：</p> 
<pre><code class="language-java">// 当前会话注销登录
StpUtil.logout();

// 获取当前会话是否已经登录，返回true=已登录，false=未登录
StpUtil.isLogin();

// 检验当前会话是否已经登录, 如果未登录，则抛出异常：`NotLoginException`
StpUtil.checkLogin();</code></pre> 
<h3 id="5.4%20SA-Token%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA">5.4 SA-Token登录认证代码演示</h3> 
<p>基于上面准备阶段的代码和配置，参考下面完整的登录认证流程。</p> 
<h4></h4> 
<h4 id="5.4.1%20%E5%A2%9E%E5%8A%A0token%E7%9A%84%E9%85%8D%E7%BD%AE%E7%B1%BB">5.4.1 增加token的配置类</h4> 
<p>该类用于拦截服务器API访问的请求，即系统中的接口均需要认证</p> 
<pre><code class="language-java">import cn.dev33.satoken.filter.SaServletFilter;
import cn.dev33.satoken.interceptor.SaInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class SatokenConfigure implements WebMvcConfigurer {

    /**
     * 注册Sa-Token 拦截器，打开注解鉴权的功能
     * @param registry
     */
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new SaInterceptor()).addPathPatterns("/**");
    }

    /**
     * 注册SA-TOKEN的全局过滤器
     * @return
     */
    @Bean
    public SaServletFilter getSaServletFilter(){
        return new SaServletFilter()
                .addInclude("/**");
    }


}</code></pre> 
<h4 id="5.4.2%20%E5%A2%9E%E5%8A%A0%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%B1%BB">5.4.2 增加全局异常处理类</h4> 
<p>该类作为全局的异常处理器，这里主要是为了兜住与SA-Token相关的业务异常</p> 
<pre><code class="language-java">import cn.dev33.satoken.exception.DisableServiceException;
import cn.dev33.satoken.exception.NotLoginException;
import cn.dev33.satoken.exception.NotPermissionException;
import cn.dev33.satoken.exception.NotRoleException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.http.HttpServletRequest;
import java.util.HashMap;
import java.util.Map;

@ControllerAdvice
public class GlobalBizException {

    @ResponseBody
    @ExceptionHandler
    public ResponseEntity handleException(Exception e, HttpServletRequest request) throws Exception{
        Map&lt;String,Object&gt; resultMap = new HashMap&lt;&gt;();
        if(e instanceof NotLoginException){
            NotLoginException exception = (NotLoginException) e;
            resultMap.put("code",exception.getCode());
            resultMap.put("message",exception.getMessage());
        } else if(e instanceof NotRoleException){
            NotRoleException exception = (NotRoleException) e;
            resultMap.put("code",exception.getCode());
            resultMap.put("message",exception.getMessage());
        } else if(e instanceof NotPermissionException){
            NotPermissionException exception = (NotPermissionException) e;
            resultMap.put("code",exception.getCode());
            resultMap.put("message",exception.getMessage());
        }else if(e instanceof DisableServiceException){
            DisableServiceException exception = (DisableServiceException) e;
            resultMap.put("code",exception.getCode());
            resultMap.put("message",exception.getMessage());
        }else {
            resultMap.put("message",e.getMessage());
        }

        return new ResponseEntity&lt;&gt;(resultMap, HttpStatus.INTERNAL_SERVER_ERROR);
    }

}</code></pre> 
<h4 id="5.4.3%20%E7%99%BB%E5%BD%95%E7%99%BB%E5%87%BA%E6%8E%A5%E5%8F%A3">5.4.3 登录登出接口</h4> 
<p>该类提供了3个接口，登录登出，以及获取token信息</p> 
<pre><code class="language-java">import cn.dev33.satoken.stp.SaTokenInfo;
import cn.dev33.satoken.stp.StpUtil;
import com.congge.entity.User;
import com.congge.service.UserService;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import javax.annotation.Resource;
import java.util.Objects;

@RestController
public class LoginController {

    @Resource
    private UserService userService;

    //localhost:8081/login?name=zhangsan&amp;pwd=123456
    @GetMapping("/login")
    public Object login(@RequestParam("name") String name, @RequestParam("pwd") String pwd){
        User dbUser = userService.queryByNameAndPwd(name,pwd);
        if(Objects.isNull(dbUser)){
            throw new RuntimeException("用户名或密码错误");
        }
        StpUtil.login(dbUser.getUserId());
        return "login success";
    }

    //localhost:8081/getToken
    @GetMapping("/getToken")
    public Object getToken(){
        SaTokenInfo tokenInfo = StpUtil.getTokenInfo();
        return tokenInfo;
    }

    //localhost:8081/logout
    @GetMapping("/logout")
    public Object logout(){
        StpUtil.logout();
        return "logout success";
    }

}</code></pre> 
<h4 id="5.4.4%20%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E6%8E%A5%E5%8F%A3">5.4.4 获取用户信息接口</h4> 
<p>提供一个获取用户信息相关的接口，作为系统的API资源，后续验证对接口的访问必须要通过认证</p> 
<pre><code class="language-java">import com.congge.entity.User;
import com.congge.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RequestMapping("/user")
@RestController
public class UserController {

    @Autowired
    private UserService userService;

    //localhost:8081/user/detail?userId=1
    @GetMapping("/detail")
    public User getById(@RequestParam Integer userId){
        return userService.getById(userId);
    }

}</code></pre> 
<h4 id="5.4.5%20%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%95%88%E6%9E%9C%E9%AA%8C%E8%AF%81">5.4.5 接口测试与效果验证</h4> 
<p><strong>1）登录接口测试</strong></p> 
<p>启动工程之后，首先调用登录接口：localhost:8081/login?name=zhangsan&amp;pwd=123456，看到如下效果：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a3/d7/s5jZfNGR_o.png"></p> 
<p>在上述的效果中，通过F12打开浏览器窗口，可以看到，登录成功之后，SA-Token会通过接口响应向浏览器的cookie中写入一些会话相关的信息，比如：</p> 
<ul><li> <p>cookie中的token的名称；</p> </li><li> <p>会话中的token的过期时间；</p> </li></ul> 
<p></p> 
<p><strong>2）获取用户信息接口测试</strong></p> 
<p>在登录的情况下，调用获取用户信息的接口，此时可以通过接口获取到用户的信息</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/7a/ce/IRhwETu1_o.png"></p> 
<p>F12查看请求信息时可以发现在本次的请求中，在请求的header中自动带上了cookie的信息，这样服务端就可以从请求中解析出token，进而做请求的拦截和解析等工作</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/55/f3/F5QCgLz8_o.png"></p> 
<p><strong>3）登出接口测试</strong></p> 
<p>调用登出接口，可以看到，此时cookie的token就置为null</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b0/f2/lfZ7NCzl_o.png"></p> 
<p>SA-Token在控制台中，也输出了相关的登录登出的日志信息</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a2/00/Wj5eppM4_o.png"></p> 
<blockquote> 
 <p>关于登录认证相关的API使用，更详细的可以参考：<a href="https://sa-token.cc/doc.html#/use/login-auth" rel="nofollow" title="Sa-Token">Sa-Token</a></p> 
</blockquote> 
<p></p> 
<h4 id="5.4.6%20%E9%9B%86%E6%88%90redis%E7%AE%A1%E7%90%86%E7%99%BB%E5%BD%95%E4%BC%9A%E8%AF%9D">5.4.6 集成redis管理登录会话</h4> 
<p>事实上，在微服务的镇上的线上部署模式中，为了提升系统的并发和吞吐性能，某个服务可能会集群（多节点）部署，在这种情况下，如果不借助外部存储，会话信息就与当前的服务进程绑定了，想要扩展服务就成了问题，如何解决呢？业内通常是借助redis作为会话的存储容器，即不管部署了多少个微服务，大家会话信息的获取用的都是同一份存储在redis中的这个，这样就解决了这个问题，SA-Token也是采用了这个思路，具体来说，和大家在日常项目开发中编码几乎类似，这里不再详细展开，提供官方的参考配置文档：<a href="https://sa-token.cc/doc.html#/up/integ-redis" rel="nofollow" title="Sa-Token">Sa-Token</a></p> 
<p></p> 
<h3 id="5.5%20SA-Token%E6%8E%88%E6%9D%83%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D">5.5 SA-Token授权模型介绍</h3> 
<h4></h4> 
<h4 id="5.5.1%20SA-Token%E6%9D%83%E9%99%90%E6%A6%82%E8%BF%B0">5.5.1 SA-Token权限概述</h4> 
<p>一个功能体系完善的安全框架来说，认证和授权是必不可少的，在上面的操作演示中，体验了SA-Token的认证功能，此外，SA-Token还提供了鉴权，所谓鉴权，核心逻辑就是判断一个账号是否拥有指定权限：</p> 
<ul><li> <p>有权限？就让你通过；</p> </li><li> <p>没有？那么禁止访问；</p> </li></ul> 
<p>深入到底层数据结构，就是每个账号都会拥有一组权限码集合，框架来校验这个集合中是否包含指定的权限码。</p> 
<blockquote> 
 <p>例如：当前账号拥有权限码集合 ["user-add", "user-delete", "user-get"]，这时候我来校验权限 "user-update"，则其结果就是：验证失败，禁止访问。</p> 
</blockquote> 
<p></p> 
<h4 id="5.5.2%20SA-Token%E6%9D%83%E9%99%90%E6%A0%B8%E5%BF%83API%E8%AF%B4%E6%98%8E">5.5.2 SA-Token权限核心API说明</h4> 
<p>了解了上面的理论，现在问题的核心就是两个：</p> 
<ul><li> <p>如何获取一个账号所拥有的权限码集合？</p> </li><li> <p>本次操作需要验证的权限码是哪个？</p> </li></ul> 
<p>因为不同的项目需求不同，权限设计的方式也千变万化，因此 [ 获取当前账号权限码集合 ] 这一操作不可能内置到框架中， 所以 Sa-Token 将此操作以接口的方式暴露给你，以方便你根据自己的业务逻辑进行重写。你需要做的就是新建一个类，实现 StpInterface接口，例如以下代码：</p> 
<pre><code class="language-java">/**
 * 自定义权限加载接口实现类
 */
@Component    // 保证此类被 SpringBoot 扫描，完成 Sa-Token 的自定义权限验证扩展 
public class StpInterfaceImpl implements StpInterface {

    /**
     * 返回一个账号所拥有的权限码集合 
     */
    @Override
    public List&lt;String&gt; getPermissionList(Object loginId, String loginType) {
        // 本 list 仅做模拟，实际项目中要根据具体业务逻辑来查询权限
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();    
        list.add("101");
        list.add("user.add");
        list.add("user.update");
        list.add("user.get");
        // list.add("user.delete");
        list.add("art.*");
        return list;
    }

    /**
     * 返回一个账号所拥有的角色标识集合 (权限与角色可分开校验)
     */
    @Override
    public List&lt;String&gt; getRoleList(Object loginId, String loginType) {
        // 本 list 仅做模拟，实际项目中要根据具体业务逻辑来查询角色
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();    
        list.add("admin");
        list.add("super-admin");
        return list;
    }

}</code></pre> 
<p><strong>核心参数说明：</strong></p> 
<ul><li> <p>loginId：账号id，即你在调用 StpUtil.login(id) 时写入的标识值，比如在上文中，写入的是userId；</p> </li><li> <p>loginType：账号体系标识，此处可以暂时忽略；</p> </li></ul> 
<p>更详细的内容可以参阅文档：<a href="https://sa-token.cc/doc.html#/use/jur-auth" rel="nofollow" title="Sa-Token">Sa-Token</a>，下面通过案例的使用深入体会权限的使用。</p> 
<p></p> 
<h3 id="5.6%20SA-Token%E6%8E%88%E6%9D%83%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA">5.6 SA-Token授权代码演示</h3> 
<p>参考下面的步骤。</p> 
<p></p> 
<h4 id="5.6.1%20%E6%96%B0%E5%A2%9EStpInterfaceImpl%E7%B1%BB">5.6.1 新增StpInterfaceImpl类</h4> 
<p>实现StpInterface接口后，该类会在项目启动时自动被框架识别并加入到容器中</p> 
<pre><code class="language-java">import cn.dev33.satoken.stp.StpInterface;
import com.congge.dao.UserMapper;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
import java.util.List;

/**
 * 自定义权限加载接口实现类
 * 保证此类被 SpringBoot 扫描，完成 Sa-Token 的自定义权限验证扩展
 */
@Component
public class StpInterfaceImpl implements StpInterface {

    @Resource
    private UserMapper userMapper;

    /**
     * 返回一个账号所拥有的权限码集合
     */
    @Override
    public List&lt;String&gt; getPermissionList(Object loginId, String loginType) {
        System.out.println("获取权限列表...");
        List&lt;String&gt; permissionList = userMapper.getPermissionList(Integer.valueOf(loginId.toString()));
        return permissionList;
    }

    /**
     * 返回一个账号所拥有的角色标识集合 (权限与角色可分开校验)
     */
    @Override
    public List&lt;String&gt; getRoleList(Object loginId, String loginType) {
        // 本 list 仅做模拟，实际项目中要根据具体业务逻辑来查询角色
        List&lt;String&gt; list = userMapper.getRoleList(Integer.valueOf(loginId.toString()));
        return list;
    }

}</code></pre> 
<p>代码中对应的两个获取权限和角色的sql如下：</p> 
<pre><code class="language-java">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;
&lt;mapper namespace="com.congge.dao.UserMapper"&gt;

    &lt;resultMap id="UserResultMap" type="com.congge.entity.User"&gt;
        &lt;id property="userId" column="user_id"/&gt;
        &lt;result property="userName" column="user_name"/&gt;
        &lt;result property="password" column="password"/&gt;
        &lt;result property="realName" column="real_name"/&gt;
        &lt;result property="deptName" column="dept_name"/&gt;
    &lt;/resultMap&gt;

    &lt;select id="getById" resultMap="UserResultMap"&gt;
        select * from `user` where user_id = #{userId}
    &lt;/select&gt;

    &lt;select id="queryByNameAndPwd" resultMap="UserResultMap"&gt;
        select * from `user` where user_name = #{name} and password = #{pwd}
    &lt;/select&gt;

    &lt;select id="getPermissionList" resultType="java.lang.String"&gt;
        select
            distinct p.permission_code
        from
            role_user ru ,role_permission rp ,permission p
        where
            ru.role_id = rp.role_id and rp.permission_id = p.permission_id and ru.user_id = #{loginId}
    &lt;/select&gt;

    &lt;select id="getRoleList" resultType="java.lang.String"&gt;
        select
            distinct r.role_code
        from
            role r ,role_user ru where ru.role_id = r.role_id and ru.user_id =#{loginId}
    &lt;/select&gt;

&lt;/mapper&gt;</code></pre> 
<p></p> 
<h4 id="5.6.2%20%E7%94%A8%E6%88%B7%E6%8E%A5%E5%8F%A3%E6%94%B9%E9%80%A0">5.6.2 用户接口改造</h4> 
<p>在本案例中提供了用户操作的接口类，通常来说，对于接口权限的控制，是要求登录的用户具备某些权限，或某种角色才允许访问，在SA-Token中，提供了两个常用的用于控制用户访问权限的注解：</p> 
<ul><li> <p>@SaCheckRole("admin")，校验接口访问的人必须具备的角色；</p> </li><li> <p>@SaCheckPermission("user:add")，权限校验登录的人必须具有指定权限才能访问；</p> </li></ul> 
<p></p> 
<p>事实上，SA-Token提供的不仅有注解的方式，也有API的方式进行权限校验，更详细的可以参阅文档：<a href="https://sa-token.cc/doc.html#/use/at-check" rel="nofollow" title="Sa-Token">Sa-Token</a></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/7f/ed/9VVt5lpM_o.png"></p> 
<p>如下，是我们对用户操作的接口的权限改造</p> 
<pre><code class="language-java">import cn.dev33.satoken.annotation.SaCheckPermission;
import cn.dev33.satoken.annotation.SaCheckRole;
import cn.dev33.satoken.annotation.SaMode;
import com.congge.entity.User;
import com.congge.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RequestMapping("/user")
@RestController
public class UserController {

    @Autowired
    private UserService userService;

    //localhost:8081/user/detail?userId=1
    /**
     * 查看用户详情时，只需要拥有 user-read 这个权限即可
     * @param userId
     * @return
     */
    @GetMapping("/detail")
    @SaCheckPermission("user-read")
    public User getById(@RequestParam Integer userId){
        return userService.getById(userId);
    }

    //localhost:8081/user/create
    /**
     * 创建用户时，需要在user-write 和 write中任意拥有一个即可
     * @return
     */
    @GetMapping("/create")
    @SaCheckPermission(value = {"user-write","write"},mode = SaMode.OR)
    public Object createUser(){
        return "create user success";
    }

    //localhost:8081/user/delete
    /**
     * 删除用户时，必须拥有admin这个角色的才行
     * @return
     */
    @SaCheckRole("admin")
    @GetMapping("/delete")
    public Object deleteUser(){
        return "delete user success";
    }

}</code></pre> 
<p><strong>接口说明：</strong></p> 
<ul><li> <p>获取用户详情接口，只需要拥有 user-read 这个权限即可访问；</p> </li><li> <p>创建用户接口，需要在user-write 和 write中任意拥有一个即可；</p> </li><li> <p>删除用户接口，必须具备admin的角色才能删除；</p> </li></ul> 
<p></p> 
<h4 id="5.6.3%20%E6%8E%A5%E5%8F%A3%E6%9D%83%E9%99%90%E6%95%88%E6%9E%9C%E6%B5%8B%E8%AF%95">5.6.3 接口权限效果测试</h4> 
<p>首先，在数据库中，zhangsan这和用户具有admin的角色，先以这个账号进行测试</p> 
<p></p> 
<p><strong>1）登录接口</strong></p> 
<p>未登录效果</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/0b/d5/OsbKZzdO_o.png"></p> 
<p>调用登录接口</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/39/f7/EidjcARP_o.png"></p> 
<p><strong>2）再次获取用户详情接口</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ad/bb/OpsZGUZ1_o.png"></p> 
<p></p> 
<p><strong>3）调用删除接口</strong></p> 
<p>zhangsan这个用户拥有admin的角色，理论上可以删除，调用接口，可以删除成功</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/08/fe/NwSj9n8o_o.png"></p> 
<p><strong>4）退出当前登录使用另一个账户登录</strong></p> 
<p>使用lishi这个账户登录</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/00/4b/ZdS0ipJl_o.png"></p> 
<p><strong>5）调用删除接口</strong></p> 
<p>由于lishi这个账户没有admin的角色，理论上会删除失败，调用接口后可以看到下面的效果</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b2/c0/ToBAJjOA_o.png"></p> 
<p></p> 
<h2 id="%E5%85%AD%E3%80%81%E5%86%99%E5%9C%A8%E6%96%87%E6%9C%AB">六、写在文末</h2> 
<p>本文详细介绍了SA-Token这款安全框架的使用，并结合实际操作演示了如何集成到springboot项目中，可以说作为最近几年慢慢火起来的安全框架，相对于其他的安全框架，SA-Token的优势已经凸显出来了，作为一个技术选型，在今后的项目开发或架构设计中也是一个不错的选择，本篇到此结束，感谢观看。</p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9ec5b6c3c22b513c97778e0765a8b662/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JavaScript 继承百花齐放：从原型链到 ES6 类</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/47ec1b0c78e11284e389152c6b687520/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">分布式服务架构[原理、设计与实践]学习笔记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>