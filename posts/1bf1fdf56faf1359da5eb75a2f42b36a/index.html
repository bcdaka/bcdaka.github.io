<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构初阶】一篇文章带你超深度理解【单链表】 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/1bf1fdf56faf1359da5eb75a2f42b36a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构初阶】一篇文章带你超深度理解【单链表】">
  <meta property="og:description" content="hi ！
目录
前言：
1、链表的概念和结构
2、单链表（Single List，简写SList）的实现
2.1 定义链表（结点）的结构
2.2 创建一个链表
2.3 打印链表
2.4 尾插
2.5 头插
2.6 尾删
2.7 头删
2.8 查找
2.9 在指定位置之前插入数据
2.10 在指定位置之后插入数据
2.11 删除pos结点
2.12 删除pos之后的结点
2.13 销毁链表
———————————————— 《 你的名字 》 ————————————————
正文开始——
前言： 前面我们学习了顺序表，实现了对数组内容增删查改等操作，但是顺序表仍然存在一些缺陷。
中间/头部的插入删除，时间复杂度为O(N)；增容需要申请新空间，拷贝数据，释放旧空间，这是不小的消耗；增容一般是成2倍的增长，大概率会有一些空间的浪费。 那我们该如何解决上面的问题呢？下面我们来学习一下链表 。
1、链表的概念和结构 概念：链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现。
2、单链表（Single List，简写SList）的实现 上面我们了解了链表的概念和结构，链表又分为很多种，今天我们先学习链表之一单链表。
2.1 定义链表（结点）的结构 //定义链表（结点）的结构 typedef int SLTDataType; typedef struct SListNode { SLTDataType data; struct SListNode* next; }SLTNode; 2.2 创建一个链表 这里申请空间使用 malloc，在链表里面不存在增容的操作，想插入数据直接申请一个新的结点即可！用 calloc 也可以，calloc会让申请空间的内容初始化为0。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-26T00:43:37+08:00">
    <meta property="article:modified_time" content="2024-07-26T00:43:37+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构初阶】一篇文章带你超深度理解【单链表】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong> hi ！</strong></p> 
<p class="img-center"><img alt="" height="286" src="https://images2.imgbox.com/4c/8f/JhXW0AwO_o.jpg" width="500"></p> 
<p></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E5%89%8D%E8%A8%80%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80%EF%BC%9A" rel="nofollow">前言：</a></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="1%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%BB%93%E6%9E%84" rel="nofollow">1、链表的概念和结构</a></p> 
<p id="2%E3%80%81%E9%93%BE%E8%A1%A8%EF%BC%88Single%20List%EF%BC%8C%E7%AE%80%E5%86%99SList%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#2%E3%80%81%E9%93%BE%E8%A1%A8%EF%BC%88Single%20List%EF%BC%8C%E7%AE%80%E5%86%99SList%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">2、单链表（Single List，简写SList）的实现</a></p> 
<p id="2.1%C2%A0%20%C2%A0%E5%AE%9A%E4%B9%89%E9%93%BE%E8%A1%A8%EF%BC%88%E7%BB%93%E7%82%B9%EF%BC%89%E7%9A%84%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#2.1%C2%A0%20%C2%A0%E5%AE%9A%E4%B9%89%E9%93%BE%E8%A1%A8%EF%BC%88%E7%BB%93%E7%82%B9%EF%BC%89%E7%9A%84%E7%BB%93%E6%9E%84" rel="nofollow">2.1   定义链表（结点）的结构</a></p> 
<p id="2.2%C2%A0%20%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8-toc" style="margin-left:40px;"><a href="#2.2%C2%A0%20%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8" rel="nofollow">2.2  创建一个链表</a></p> 
<p id="2.3%C2%A0%20%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8-toc" style="margin-left:40px;"><a href="#2.3%C2%A0%20%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8" rel="nofollow">2.3  打印链表</a></p> 
<p id="2.4%C2%A0%20%E5%B0%BE%E6%8F%92-toc" style="margin-left:40px;"><a href="#2.4%C2%A0%20%E5%B0%BE%E6%8F%92" rel="nofollow">2.4  尾插</a></p> 
<p id="2.5%C2%A0%20%E5%A4%B4%E6%8F%92-toc" style="margin-left:40px;"><a href="#2.5%C2%A0%20%E5%A4%B4%E6%8F%92" rel="nofollow">2.5  头插</a></p> 
<p id="2.6%C2%A0%20%E5%B0%BE%E5%88%A0-toc" style="margin-left:40px;"><a href="#2.6%C2%A0%20%E5%B0%BE%E5%88%A0" rel="nofollow">2.6  尾删</a></p> 
<p id="2.7%C2%A0%20%E5%A4%B4%E5%88%A0-toc" style="margin-left:40px;"><a href="#2.7%C2%A0%20%E5%A4%B4%E5%88%A0" rel="nofollow">2.7  头删</a></p> 
<p id="2.8%C2%A0%20%E6%9F%A5%E6%89%BE-toc" style="margin-left:40px;"><a href="#2.8%C2%A0%20%E6%9F%A5%E6%89%BE" rel="nofollow">2.8  查找</a></p> 
<p id="2.9%C2%A0%20%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%89%8D%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#2.9%C2%A0%20%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%89%8D%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE" rel="nofollow">2.9  在指定位置之前插入数据</a></p> 
<p id="2.10%C2%A0%20%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%90%8E%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#2.10%C2%A0%20%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%90%8E%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE" rel="nofollow">2.10  在指定位置之后插入数据</a></p> 
<p id="2.11%C2%A0%20%E5%88%A0%E9%99%A4pos%E7%BB%93%E7%82%B9-toc" style="margin-left:40px;"><a href="#2.11%C2%A0%20%E5%88%A0%E9%99%A4pos%E7%BB%93%E7%82%B9" rel="nofollow">2.11  删除pos结点</a></p> 
<p id="2.12%C2%A0%20%E5%88%A0%E9%99%A4pos%E4%B9%8B%E5%90%8E%E7%9A%84%E7%BB%93%E7%82%B9-toc" style="margin-left:40px;"><a href="#2.12%C2%A0%20%E5%88%A0%E9%99%A4pos%E4%B9%8B%E5%90%8E%E7%9A%84%E7%BB%93%E7%82%B9" rel="nofollow">2.12  删除pos之后的结点</a></p> 
<p id="2.13%C2%A0%20%E9%94%80%E6%AF%81%E9%93%BE%E8%A1%A8-toc" style="margin-left:40px;"><a href="#2.13%C2%A0%20%E9%94%80%E6%AF%81%E9%93%BE%E8%A1%A8" rel="nofollow">2.13  销毁链表</a></p> 
<p id="%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%C2%A0%20%E3%80%8A%C2%A0%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%C2%A0%E3%80%8B%C2%A0%20%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94-toc" style="margin-left:0px;"><a href="#%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%C2%A0%20%E3%80%8A%C2%A0%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%C2%A0%E3%80%8B%C2%A0%20%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94" rel="nofollow">————————————————  《 你的名字 》  ————————————————</a></p> 
<p style="margin-left:0px;"></p> 
<hr id="hr-toc"> 
<p>正文开始——</p> 
<h2 id="%E5%89%8D%E8%A8%80%EF%BC%9A">前言：</h2> 
<p>前面我们学习了顺序表，实现了对数组内容增删查改等操作，但是顺序表仍然存在一些缺陷。</p> 
<ol><li>中间/头部的插入删除，时间复杂度为O(N)；</li><li>增容需要申请新空间，拷贝数据，释放旧空间，这是不小的消耗；</li><li>增容一般是成2倍的增长，大概率会有一些空间的浪费。</li></ol> 
<p>那我们该如何解决上面的问题呢？下面我们来学习一下链表 。</p> 
<h2></h2> 
<h2 id="1%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%BB%93%E6%9E%84"><span style="color:#956fe7;">1、链表的概念和结构</span></h2> 
<p><strong>概念：</strong>链表是一种<strong>物理存储结构上非连续、非顺序</strong>的存储结构，数据元素的<strong>逻辑顺序</strong>是通过链表中的<strong>指针链接</strong>次序实现。</p> 
<p class="img-center"><img alt="" height="931" src="https://images2.imgbox.com/54/fa/7jxEjuxX_o.png" width="1200"></p> 
<p></p> 
<h2 id="2%E3%80%81%E9%93%BE%E8%A1%A8%EF%BC%88Single%20List%EF%BC%8C%E7%AE%80%E5%86%99SList%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0"><span style="color:#956fe7;">2、单链表（Single List，简写SList）的实现</span></h2> 
<p><span style="color:#0d0016;">上面我们了解了链表的概念和结构，链表又分为很多种，今天我们先学习链表之一单链表。</span></p> 
<h3 id="2.1%C2%A0%20%C2%A0%E5%AE%9A%E4%B9%89%E9%93%BE%E8%A1%A8%EF%BC%88%E7%BB%93%E7%82%B9%EF%BC%89%E7%9A%84%E7%BB%93%E6%9E%84"><span style="color:#4da8ee;">2.1   定义链表（结点）的结构</span></h3> 
<pre><code class="language-cs">//定义链表（结点）的结构

typedef int SLTDataType;
typedef struct SListNode {
	SLTDataType data;  
	struct SListNode* next;
}SLTNode;</code></pre> 
<h4></h4> 
<h3 id="2.2%C2%A0%20%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8"><span style="color:#4da8ee;">2.2  创建一个链表</span></h3> 
<p><span style="color:#0d0016;">这里申请空间使用 <strong>malloc</strong>，在链表里面不存在增容的操作，想插入数据直接申请一个新的结点即可！用 <strong>calloc </strong>也可以，calloc会让申请空间的内容初始化为0。</span></p> 
<p><strong><span style="color:#0d0016;">【代码】</span></strong></p> 
<p><strong><span style="color:#0d0016;">test.c</span></strong></p> 
<pre><code class="language-cs">//创建一个链表
void creatSList()
{
	//链表是由一个一个的结点组成的

	SLTNode* node1 = (SLTNode*)malloc(sizeof(SLTNode));
	node1-&gt;data = 1;

	SLTNode* node2 = (SLTNode*)malloc(sizeof(SLTNode));
	node2-&gt;data = 2;

	SLTNode* node3 = (SLTNode*)malloc(sizeof(SLTNode));
	node3-&gt;data = 3;

	SLTNode* node4 = (SLTNode*)malloc(sizeof(SLTNode));
	node4-&gt;data = 4;

	//将结点之间连接起来
	node1-&gt;next=node2;
	node2-&gt;next=node3;
	node3-&gt;next=node4;
	node4-&gt;next = NULL;

}</code></pre> 
<p class="img-center"><img alt="" height="262" src="https://images2.imgbox.com/b7/df/c5FDFnTE_o.png" width="1000"></p> 
<p></p> 
<h3 id="2.3%C2%A0%20%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8"><span style="color:#4da8ee;">2.3  打印链表</span></h3> 
<p><strong><span style="color:#0d0016;">【思路图解】</span></strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/0b/df/QZ7gzV81_o.png"></p> 
<p><span style="color:#0d0016;"><strong>【代码】 </strong></span></p> 
<pre><code class="language-cs">//链表的打印

void SLTPrint(SLTNode* phead)
{
	SLTNode* pcur = phead;
	while (pcur)
	{
		printf("%d-&gt;", pcur-&gt;data);
		pcur = pcur-&gt;next;
	}
	printf("NULL\n");
}</code></pre> 
<p></p> 
<h3 id="2.4%C2%A0%20%E5%B0%BE%E6%8F%92"><span style="color:#4da8ee;">2.4  尾插</span></h3> 
<p><strong><span style="color:#0d0016;">【思路图解】</span></strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6a/c8/uX2IeqLQ_o.png"></p> 
<p><span style="color:#0d0016;"><strong>【代码】 </strong></span></p> 
<p><span style="color:#0d0016;"><strong>SList.c</strong></span></p> 
<pre><code class="language-cs">//申请一个新结点
SLTNode* SLTBuyNode(SLTDataType x)
{
	SLTNode* node = (SLTNode*)malloc(sizeof(SLTNode));
	if (node == NULL)
	{
		perror("malloc file!");
		exit(1);
	}
	node-&gt;data = x;
	node-&gt;next = NULL;

	return node;
}

//尾插
void SLTPushBack(SLTNode** pphead, SLTDataType x)
{
	assert(pphead);
	//申请一个新结点
	SLTNode* newnode = SLTBuyNode(x);

	if (*pphead == NULL)
	{
		*pphead = newnode;
	}
	else
	{
		SLTNode* pcur = *pphead;

		//找尾结点
		while (pcur-&gt;next)
		{
			pcur = pcur-&gt;next;
		}
		pcur-&gt;next = newnode;
	}
}</code></pre> 
<p><strong>test.c</strong></p> 
<pre><code class="language-cs">void SListTest01()
{
	SLTNode* plist = NULL;
    //plist为指向第一个结点的指针
	SLTPushBack(&amp;plist,100);
	SLTPrint(plist);
}

int main()
{
	SListTest01();
	return 0;
}</code></pre> 
<p><strong>【验证】 </strong></p> 
<p class="img-center"><img alt="" height="404" src="https://images2.imgbox.com/aa/87/1GnG5wuT_o.png" width="700"></p> 
<p></p> 
<p><strong>【注意】</strong></p> 
<ol><li>在 test.c 里面尾插时传的是&amp;plist ，而不是 plist。我们希望形参的改变影响实参，所以我们取实参的地址。plist 作为参数传的是一个指针变量而不是一个地址，只有 &amp;plist （有&amp;）才算是真正的取地址使得形参的改变影响实参。用二级指针来接收。</li><li>找尾结点。循环的条件是 pcur-&gt;next，而不是 pcur。因为 pcur-&gt;next 为NULL跳出循环时，说明 pcur 为尾结点，当 pcur 为空跳出循环时，说明 pcur 是尾结点的下一个节点，而不是尾结点。</li><li>pphead==&amp;plist；*pphead==plist（指向第一个结点的指针） 。</li><li>assert (pphead)；传过来的地址不能为空。</li></ol> 
<p></p> 
<h3 id="2.5%C2%A0%20%E5%A4%B4%E6%8F%92"><span style="color:#4da8ee;">2.5  头插</span></h3> 
<p><strong><span style="color:#4da8ee;">各结点的地址应为0x0012FF...，在此纠正下面的错误。</span></strong></p> 
<p><span style="color:#0d0016;"><strong>【思路图解】</strong></span></p> 
<p class="img-center"><img alt="" height="675" src="https://images2.imgbox.com/e5/f9/MwZr5t69_o.png" width="700"></p> 
<p><span style="color:#0d0016;"><strong>【代码】</strong></span></p> 
<p><span style="color:#0d0016;"><strong>SList.c</strong></span></p> 
<pre><code class="language-cs">//头插
void SLTPushFront(SLTNode** pphead, SLTDataType x)
{
	assert(pphead);

	//申请一个新结点
	SLTNode* newnode = SLTBuyNode(x);

	newnode-&gt;next = *pphead;
	*pphead = newnode;
}</code></pre> 
<p><strong>test.c</strong></p> 
<pre><code class="language-cs">
void SListTest01()
{
    //验证尾插
	SLTNode* plist = NULL;
	SLTPushBack(&amp;plist,1);
	SLTPushBack(&amp;plist,2);
	SLTPushBack(&amp;plist,3);
	SLTPushBack(&amp;plist,4);
	SLTPushBack(&amp;plist,100);
	SLTPrint(plist);
    
    //验证头插
	SLTPushFront(&amp;plist, 200);
	SLTPrint(plist);
}

int main()
{
	SListTest01();
	return 0;
}</code></pre> 
<p><strong>【验证】</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/97/05/YXh4obsD_o.png"></p> 
<p></p> 
<h3 id="2.6%C2%A0%20%E5%B0%BE%E5%88%A0"><span style="color:#4da8ee;">2.6  尾删</span></h3> 
<p><strong><span style="color:#4da8ee;">各结点的地址应为0x0012FF...，在此纠正下面的错误。谅解哈~~~</span></strong></p> 
<p><strong>【思路图解】</strong></p> 
<p><strong>当链表内不止一个结点时</strong></p> 
<p class="img-center"><img alt="" height="951" src="https://images2.imgbox.com/0a/a4/st73OCql_o.png" width="800"></p> 
<p style="text-align:center;"></p> 
<p><strong>当链表内只有一个结点时 </strong></p> 
<p class="img-center"><img alt="" height="453" src="https://images2.imgbox.com/eb/0e/2lR6XT50_o.png" width="600"></p> 
<p><strong>【代码】</strong></p> 
<p><strong>SList.c</strong></p> 
<pre><code class="language-cs">
//尾删
void SLTPopBack(SLTNode** pphead)
{
	//链表为空，不可删除
	assert(pphead &amp;&amp; *pphead);

	//处理只有一个结点的情况，要删除的就是头结点
	if ((*pphead)-&gt;next == NULL)
	{
		free(*pphead);
		*pphead = NULL;
	}
	else
	{
		//找 ptail 和 prev
		SLTNode* ptail = *pphead;
		SLTNode* prev = NULL;
		while (ptail-&gt;next)
		{
			prev = ptail;
			ptail = ptail-&gt;next;
		}
		prev-&gt;next = NULL;
		free(ptail);
		ptail = NULL;
	}
}</code></pre> 
<p><strong>test.c</strong></p> 
<pre><code class="language-cs">
void SListTest01()
{
	SLTNode* plist = NULL;
	SLTPushBack(&amp;plist,1);
	SLTPushBack(&amp;plist,2);
	SLTPushBack(&amp;plist,3);
	SLTPushBack(&amp;plist,4);
	SLTPushBack(&amp;plist,100);
	SLTPrint(plist);

	/*SLTPushFront(&amp;plist, 200);
	SLTPrint(plist);*/

	SLTPopBack(&amp;plist);
	SLTPrint(plist);
}

int main()
{
	/*createSList();*/
	SListTest01();
	return 0;
}</code></pre> 
<p><strong>【验证】</strong></p> 
<p class="img-center"><img alt="" height="436" src="https://images2.imgbox.com/a2/63/JcxgLmjF_o.png" width="700"></p> 
<p></p> 
<h3 id="2.7%C2%A0%20%E5%A4%B4%E5%88%A0"><span style="color:#4da8ee;">2.7  头删</span></h3> 
<p><strong><span style="color:#4da8ee;">各结点的地址应为0x0012FF...，在此纠正下面的错误。</span></strong></p> 
<p><strong>【思路图解】</strong></p> 
<p class="img-center"><img alt="" height="421" src="https://images2.imgbox.com/51/85/hXw7jsTM_o.png" width="900"></p> 
<p><strong>【代码】</strong></p> 
<p><strong>SList.c</strong></p> 
<pre><code class="language-cs">//头删
void SLTPopFront(SLTNode** pphead)
{
	//链表不为空
	assert(pphead &amp;&amp; *pphead);

	SLTNode* next = (*pphead)-&gt;next;
	free(*pphead);
	*pphead = next;
}</code></pre> 
<p><strong>test.c</strong></p> 
<pre><code class="language-cs">void SListTest01()
{
	SLTNode* plist = NULL;
	SLTPushBack(&amp;plist,1);
	SLTPushBack(&amp;plist,2);
	SLTPushBack(&amp;plist,3);
	SLTPushBack(&amp;plist,4);
	SLTPushBack(&amp;plist,100);
	SLTPrint(plist);

	/*SLTPushFront(&amp;plist, 200);
	SLTPrint(plist);*/

	/*SLTPopBack(&amp;plist);*/
	/*SLTPrint(plist);*/

	SLTPopFront(&amp;plist);
	SLTPrint(plist);

}

int main()
{
	/*createSList();*/
	SListTest01();
	return 0;
}
</code></pre> 
<p><strong>【验证】</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ff/d6/VeRPXEdI_o.png"></p> 
<p></p> 
<h3 id="2.8%C2%A0%20%E6%9F%A5%E6%89%BE"><span style="color:#4da8ee;">2.8  查找</span></h3> 
<p><strong><span style="color:#4da8ee;">各结点的地址应为0x0012FF...，在此纠正下面的错误。</span></strong></p> 
<p><span style="color:#0d0016;">思路简单，直接上代码：</span></p> 
<p><strong><span style="color:#0d0016;">SList.c</span></strong></p> 
<pre><code class="language-cs">//查找
SLTNode* SLTFind(SLTNode* phead,SLTDataType x)
{
	assert(phead);
	SLTNode* pcur = phead;
	while (pcur)
	{
		if (pcur-&gt;data == x)
		{
			return pcur;
		}
		pcur = pcur-&gt;next;
	}
	//没有找到
	return NULL;
}</code></pre> 
<p><strong>【注意】</strong>SLTNode* pcur = phead，重新定义一个指针变量 pcur 指向第一个结点，让 pcur 来遍历链表，防止头结点丢失。</p> 
<p><strong>test.c</strong></p> 
<pre><code class="language-cs">void SListTest01()
{
	SLTNode* plist = NULL;
	SLTPushBack(&amp;plist,1);
	SLTPushBack(&amp;plist,2);
	SLTPushBack(&amp;plist,3);
	SLTPushBack(&amp;plist,4);
	SLTPushBack(&amp;plist,100);
	SLTPrint(plist);

	/*SLTPushFront(&amp;plist, 200);
	SLTPrint(plist);*/

	/*SLTPopBack(&amp;plist);*/
	/*SLTPrint(plist);*/

	SLTPopFront(&amp;plist);
	SLTPrint(plist);

	SLTNode* find = SLTFind(plist, 2);
	if (find == NULL)
	{
		printf("没找到\n");
	}
	else
	{
		printf("找到了\n");
	}
}
</code></pre> 
<p><strong>【验证】</strong></p> 
<p class="img-center"><img alt="" height="603" src="https://images2.imgbox.com/28/a6/VPfL0lBc_o.png" width="800"></p> 
<p></p> 
<h3 id="2.9%C2%A0%20%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%89%8D%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span style="color:#4da8ee;">2.9  在指定位置之前插入数据</span></h3> 
<p><strong><span style="color:#4da8ee;">各结点的地址应为0x0012FF...，在此纠正下面的错误。</span></strong></p> 
<p><strong><span style="color:#0d0016;">【思路图解】</span></strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f0/24/fBdyUKOG_o.png"></p> 
<p><strong>【代码】</strong></p> 
<p><strong>SList.c</strong></p> 
<pre><code class="language-cs">
//在指定位置之前插入数据
void SLTInsert(SLTNode** pphead, SLTNode* pos, SLTDataType x)
{
	assert(pphead &amp;&amp; *pphead);

	if (pos == *pphead)
	{
		SLTPushFront(pphead, x);
	}
	else
	{
		//申请一个新的结点
		SLTNode* newnode = SLTBuyNode(x);

		//找pos的前一个结点prev
		SLTNode* prev = *pphead;
		while (prev-&gt;next != pos)
		{
			prev = prev-&gt;next;
		}
		newnode-&gt;next = pos;
		prev-&gt;next = newnode;
	}
}</code></pre> 
<p><strong>test.c</strong></p> 
<pre><code class="language-cs">void SListTest01()
{
	SLTNode* plist = NULL;
	SLTPushBack(&amp;plist,1);
	SLTPushBack(&amp;plist,2);
	SLTPushBack(&amp;plist,3);
	SLTPushBack(&amp;plist,4);
	SLTPrint(plist);

	/*SLTPushFront(&amp;plist, 200);
	SLTPrint(plist);*/

	/*SLTPopBack(&amp;plist);*/
	/*SLTPrint(plist);*/

	//SLTPopFront(&amp;plist);
	//SLTPrint(plist);

	//SLTNode* find = SLTFind(plist, 2);
	/*///*if (find == NULL)
	{
		printf("没找到\n");
	}
	else
	{
		printf("找到了\n");
	//}*/

	SLTNode* find = SLTFind(plist, 2);
	SLTInsert(&amp;plist, find, 100);
	SLTPrint(plist);

}</code></pre> 
<p><strong>【验证】</strong></p> 
<p class="img-center"><img alt="" height="180" src="https://images2.imgbox.com/cb/4c/jokvJUIz_o.png" width="800"></p> 
<p></p> 
<h3 id="2.10%C2%A0%20%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%90%8E%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span style="color:#4da8ee;">2.10  在指定位置之后插入数据</span></h3> 
<p><strong><span style="color:#4da8ee;">各结点的地址应为0x0012FF...，在此纠正下面的错误。</span></strong></p> 
<p><strong><span style="color:#0d0016;">【思路图解】</span></strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/4d/ee/vnN7Ox5r_o.png"></p> 
<p><strong>【代码】</strong></p> 
<p><strong>SList.c</strong></p> 
<pre><code class="language-cs">//在指定位置之后插入数据
void SLTInsertAfter(SLTNode** pphead, SLTNode* pos, SLTDataType x)
{
	assert(pos);
	SLTNode* newnode = SLTBuyNode(x);
	newnode-&gt;next = pos-&gt;next;
	pos-&gt;next = newnode;
}</code></pre> 
<p><strong>test.c</strong></p> 
<pre><code class="language-cs">void SListTest01()
{
	SLTNode* plist = NULL;
	SLTPushBack(&amp;plist,1);
	SLTPushBack(&amp;plist,2);
	SLTPushBack(&amp;plist,3);
	SLTPushBack(&amp;plist,4);
	SLTPrint(plist);

	/*SLTPushFront(&amp;plist, 200);
	SLTPrint(plist);*/

	/*SLTPopBack(&amp;plist);*/
	/*SLTPrint(plist);*/

	//SLTPopFront(&amp;plist);
	//SLTPrint(plist);

	//SLTNode* find = SLTFind(plist, 2);
	/*///*if (find == NULL)
	{
		printf("没找到\n");
	}
	else
	{
		printf("找到了\n");
	//}*/

	/*SLTNode* find = SLTFind(plist, 2);
	SLTInsert(&amp;plist, find, 100);
	SLTPrint(plist);*/

	SLTNode* find = SLTFind(plist, 2);
	SLTInsertAfter(find, 100);
	SLTPrint(plist); 

}</code></pre> 
<p><strong>【验证】</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/96/0b/rQdpjQhM_o.png"></p> 
<p></p> 
<h3 id="2.11%C2%A0%20%E5%88%A0%E9%99%A4pos%E7%BB%93%E7%82%B9"><span style="color:#4da8ee;">2.11  删除pos结点</span></h3> 
<p><strong><span style="color:#4da8ee;">各结点的地址应为0x0012FF...，在此纠正下面的错误。</span></strong></p> 
<p><strong>【思路图解】</strong></p> 
<p class="img-center"><img alt="" height="651" src="https://images2.imgbox.com/60/03/Uq0jcIZs_o.png" width="1000"></p> 
<p><strong>【代码】</strong></p> 
<p><strong>SList.c</strong></p> 
<pre><code class="language-cs">//删除pos结点
void SLTErase(SLTNode** pphead,SLTNode* pos)
{
	assert(pphead &amp;&amp; *pphead);
    //这里对pos进行限制，链表中必须有pos这个结点，在查找中若没有pos结点则返回NULL
	assert(pos);

	if (pos == *pphead)
	{
		SLTPopFront(pphead);
	}
	else
	{
		//找到prev：pos的前结点
		SLTNode* prev = *pphead;
		while (prev-&gt;next != pos)
		{
			prev = prev-&gt;next;
		}
		prev-&gt;next = pos-&gt;next;
		free(pos);
		pos = NULL;
	}
}</code></pre> 
<p><strong>test.c</strong></p> 
<pre><code class="language-cs">void SListTest01()
{
	SLTNode* plist = NULL;
	SLTPushBack(&amp;plist,1);
	SLTPushBack(&amp;plist,2);
	SLTPushBack(&amp;plist,3);
	SLTPushBack(&amp;plist,4);
	SLTPrint(plist);

	/*SLTPushFront(&amp;plist, 200);
	SLTPrint(plist);*/

	/*SLTPopBack(&amp;plist);*/
	/*SLTPrint(plist);*/

	//SLTPopFront(&amp;plist);
	//SLTPrint(plist);

	//SLTNode* find = SLTFind(plist, 2);
	/*///*if (find == NULL)
	{
		printf("没找到\n");
	}
	else
	{
		printf("找到了\n");
	//}*/

	/*SLTNode* find = SLTFind(plist, 2);
	SLTInsert(&amp;plist, find, 100);
	SLTPrint(plist);*/

	/*SLTNode* find = SLTFind(plist, 2);
	SLTInsertAfter(find, 100);
	SLTPrint(plist); */

	SLTNode* find = SLTFind(plist, 2);
	SLTErase(&amp;plist, find);//这里的find由pos接收，SLTFind若没找到存储2这个结点则返回NULL
	SLTPrint(plist); 

}</code></pre> 
<p><strong>【验证】</strong></p> 
<p class="img-center"><img alt="" height="141" src="https://images2.imgbox.com/42/2f/h3e9pkFE_o.png" width="600"></p> 
<p></p> 
<p></p> 
<h3 id="2.12%C2%A0%20%E5%88%A0%E9%99%A4pos%E4%B9%8B%E5%90%8E%E7%9A%84%E7%BB%93%E7%82%B9"><span style="color:#4da8ee;">2.12  删除pos之后的结点</span></h3> 
<p><strong><span style="color:#4da8ee;">各结点的地址应为0x0012FF...，在此纠正下面的错误。</span></strong></p> 
<p><strong>【思路图解】</strong></p> 
<p class="img-center"><img alt="" height="1001" src="https://images2.imgbox.com/c4/39/nDdtD8I7_o.png" width="1200"></p> 
<p><strong>【代码】</strong></p> 
<p><strong>SList.c</strong></p> 
<pre><code class="language-cs">//删除pos之后的结点
void SLTEraseAfter(SLTNode* pos)
{
	assert(pos &amp;&amp; pos-&gt;next);
	SLTNode* del = pos-&gt;next;
	pos-&gt;next = pos-&gt;next-&gt;next;
	free(del);
	del = NULL;
}</code></pre> 
<p><strong>test.c</strong></p> 
<pre><code class="language-cs">void SListTest01()
{
	SLTNode* plist = NULL;
	SLTPushBack(&amp;plist,1);
	SLTPushBack(&amp;plist,2);
	SLTPushBack(&amp;plist,3);
	SLTPushBack(&amp;plist,4);
	SLTPrint(plist);

	/*SLTPushFront(&amp;plist, 200);
	SLTPrint(plist);*/

	/*SLTPopBack(&amp;plist);*/
	/*SLTPrint(plist);*/

	//SLTPopFront(&amp;plist);
	//SLTPrint(plist);

	//SLTNode* find = SLTFind(plist, 2);
	/*///*if (find == NULL)
	{
		printf("没找到\n");
	}
	else
	{
		printf("找到了\n");
	//}*/

	/*SLTNode* find = SLTFind(plist, 2);
	SLTInsert(&amp;plist, find, 100);
	SLTPrint(plist);*/

	/*SLTNode* find = SLTFind(plist, 2);
	SLTInsertAfter(find, 100);
	SLTPrint(plist); */

	//SLTNode* find = SLTFind(plist, 2);
	//SLTErase(&amp;plist, find);
	//SLTPrint(plist); 

	SLTNode* find = SLTFind(plist, 2);
	SLTEraseAfter(find);
	SLTPrint(plist); 

}</code></pre> 
<p><strong>【验证】</strong></p> 
<p class="img-center"><img alt="" height="165" src="https://images2.imgbox.com/2a/bc/oebNev7U_o.png" width="600"></p> 
<p></p> 
<h3 id="2.13%C2%A0%20%E9%94%80%E6%AF%81%E9%93%BE%E8%A1%A8"><span style="color:#4da8ee;">2.13  销毁链表</span></h3> 
<p><strong><span style="color:#4da8ee;">各结点的地址应为0x0012FF...，在此纠正下面的错误。</span></strong></p> 
<p><strong><span style="color:#0d0016;">【思路图解】</span></strong></p> 
<p class="img-center"><img alt="" height="286" src="https://images2.imgbox.com/e4/fa/MNobutug_o.png" width="600"></p> 
<p><strong>【代码】</strong></p> 
<p><strong>SList.c</strong></p> 
<pre><code class="language-cs">//销毁链表
void SListDestroy(SLTNode** pphead)
{
	assert(pphead &amp;&amp; *pphead);

	SLTNode* pcur = *pphead;
	while (pcur)
	{
		SLTNode* next = pcur-&gt;next;
		free(pcur);
		pcur = next;
	}
    //*pphead=plist，链表为空，也要把*pphead置为空
	*pphead = NULL;
}</code></pre> 
<p><strong>【验证】</strong></p> 
<p class="img-center"><img alt="" height="141" src="https://images2.imgbox.com/83/f6/Okcz6CAI_o.png" width="600"></p> 
<p></p> 
<p>今天单链表的深度学习就结束啦，拜拜~~~</p> 
<p><img alt="" height="48" src="https://images2.imgbox.com/19/f1/pu1Polu7_o.png" width="48"></p> 
<hr> 
<p><strong>完——</strong></p> 
<p></p> 
<h2 id="%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%C2%A0%20%E3%80%8A%C2%A0%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%C2%A0%E3%80%8B%C2%A0%20%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94"><span style="color:#38d8f0;">————————————————</span><span style="color:#0d0016;"> </span> <span style="background-color:#38d8f0;">《 </span><span style="color:#0d0016;"><span style="background-color:#38d8f0;">你的名字 </span></span><span style="background-color:#38d8f0;">》</span>  <span style="color:#38d8f0;">————————————————</span></h2> 
<p><span style="color:#0d0016;"><strong><span style="background-color:#38d8f0;"> 重要的人，不能忘记的人，不想忘记的人，你，是谁？</span></strong></span></p> 
<p><span style="color:#0d0016;"><strong><span style="background-color:#38d8f0;"> 不管在哪里，不管过多久，不管是要跨过高山，还是跨过湖海，我一定会去见你一面。</span></strong></span></p> 
<p></p> 
<p><a class="has-card" href="https://t4.kugou.com/song.html?id=avhoFadCPV2" rel="nofollow" title="スパークル_RADWIMPS_高音质在线试听_スパークル歌词|歌曲下载_酷狗音乐"><span class="link-card-box"><span class="link-title">スパークル_RADWIMPS_高音质在线试听_スパークル歌词|歌曲下载_酷狗音乐</span><span class="link-desc">酷狗音乐为您提供由RADWIMPS演唱的高清音质无损スパークルmp3在线听,听スパークル,只来酷狗音乐!</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/25/42/6GjsugOX_o.png" alt="icon-default.png?t=N7T8">https://t4.kugou.com/song.html?id=avhoFadCPV2</span></span></a></p> 
<p></p> 
<p class="img-center"><img alt="" height="338" src="https://images2.imgbox.com/03/92/K2DJRshU_o.jpg" width="600"></p> 
<p class="img-center"><img alt="" height="338" src="https://images2.imgbox.com/ae/a7/icNZD9x2_o.jpg" width="600"></p> 
<p><strong>至此结束——</strong></p> 
<p><strong>再见——</strong></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1a9e3d248d94f4968dd0d88e23034025/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【数据结构初阶】顺序表三道经典算法题（详解&#43;图例）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ceeab73504d1874949c51ddc47fa3bab/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何在 Debian 8 上安装和使用 PostgreSQL 9.4</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>