<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java中的经典排序算法：插入排序、希尔排序、选择排序、堆排序与冒泡排序（如果想知道Java中有关插入排序、希尔排序、选择排序、堆排序与冒泡排序的知识点，那么只看这一篇就足够了！） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/c07c19468ea77bd06a946f5ee32ca829/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java中的经典排序算法：插入排序、希尔排序、选择排序、堆排序与冒泡排序（如果想知道Java中有关插入排序、希尔排序、选择排序、堆排序与冒泡排序的知识点，那么只看这一篇就足够了！）">
  <meta property="og:description" content="前言：排序算法是计算机科学中的基础问题之一，它在数据处理、搜索算法以及各种优化问题中占有重要地位，本文将详细介绍几种经典的排序算法：插入排序、选择排序、堆排序和冒泡排序。
✨✨✨这里是秋刀鱼不做梦的BLOG
✨✨✨想要了解更多内容可以访问我的主页秋刀鱼不做梦-CSDN博客
先让我们看一下本文大致的讲解内容：
对于每个排序算法，我们都会从算法简介、其原理与步骤、代码实现、时间复杂度分析、空间复杂度分析与该排序算法的应用场景这几个方面来进行讲解。
目录
1.插入排序（InsertSort）
（1）算法简介
（2）原理与步骤
（3）Java代码实现
（4）时间复杂度 &#43; 空间复杂度分析
（5）应用场景
2.希尔排序（Shell Sort）
（1）算法简介
（2）算法步骤
（3）代码实现
（4）时间复杂度 &#43; 空间复杂度分析
（5）应用场景
3.选择排序（Selection Sort）
（1）算法简介
（2）算法步骤
（3）代码实现
（4）时间复杂度 &#43; 空间复杂度分析
（5）应用场景
4.堆排序（Heap Sort）
（1）算法简介
（2）算法步骤
（3）代码实现
（4）时间复杂度 &#43; 空间复杂度分析
（5）应用场景
5.冒泡排序（Bubble Sort）
（1）算法简介
（2）算法步骤
（3）代码实现
（4）时间复杂度 &#43; 空间复杂度分析
（5）应用场景
1.插入排序（InsertSort） （1）算法简介 在开始学习插入排序算法之前，先让我们来看一下该算法的概念：
——插入排序是一种简单直观的排序算法，通常用于对少量元素的排序。其基本思想是构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
（2）原理与步骤 了解了插入排序算法的概念之后，让我们看一下实现该排序算法的几个核心步骤：
从第一个元素开始，该元素可以认为已经被排序。
取出下一个元素，在已经排序的元素序列中从后向前扫描。
如果已排序的元素大于新元素，将该元素向右移动。
重复步骤3，直到找到已排序的元素小于或等于新元素的位置。
将新元素插入到该位置中。
重复步骤2~5。
读者可以根据上述的描述先简要的了解一些插入排序的核心思路，接下来让我们使用代码来进行对其的实现。
（3）Java代码实现 现在我们使用代码来实现一下插入排序算法：
public class InsertionSort { public void insertSort(int[] array) { for (int i = 1; i &lt; array.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-17T23:53:49+08:00">
    <meta property="article:modified_time" content="2024-08-17T23:53:49+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java中的经典排序算法：插入排序、希尔排序、选择排序、堆排序与冒泡排序（如果想知道Java中有关插入排序、希尔排序、选择排序、堆排序与冒泡排序的知识点，那么只看这一篇就足够了！）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>  <strong>      前言：排序算法是计算机科学中的基础问题之一，它在数据处理、搜索算法以及各种优化问题中占有重要地位，本文将详细介绍几种经典的排序算法：插入排序、选择排序、堆排序和冒泡排序。</strong></p> 
<hr> 
<blockquote> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1e/9f/Nex7v5ya_o.jpg"></p> 
 <p><strong>✨✨✨<span style="color:#ff9900;">这里是秋刀鱼不做梦的BLOG</span></strong></p> 
 <p><span style="color:#ff9900;"><strong>✨✨✨想要了解更多内容可以访问我的主页</strong></span><a href="https://blog.csdn.net/2302_80198073?type=blog" title="秋刀鱼不做梦-CSDN博客">秋刀鱼不做梦-CSDN博客</a></p> 
</blockquote> 
<p><span style="color:#a2e043;"><strong>先让我们看一下本文大致的讲解内容：</strong></span></p> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/f3/be/4e7fnf2u_o.png"></strong></p> 
<p><span style="color:#38d8f0;"><strong>        对于每个排序算法，我们都会从算法简介、其原理与步骤、代码实现、时间复杂度分析、空间复杂度分析与该排序算法的应用场景这几个方面来进行讲解。</strong></span></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88InsertSort%EF%BC%89-toc" style="margin-left:0px;"><strong><a href="#1.%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88InsertSort%EF%BC%89" rel="nofollow">1.插入排序（InsertSort）</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%881%EF%BC%89%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%881%EF%BC%89%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B" rel="nofollow">        （1）算法简介</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%882%EF%BC%89%E5%8E%9F%E7%90%86%E4%B8%8E%E6%AD%A5%E9%AA%A4-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%882%EF%BC%89%E5%8E%9F%E7%90%86%E4%B8%8E%E6%AD%A5%E9%AA%A4" rel="nofollow">        （2）原理与步骤</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%883%EF%BC%89Java%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%883%EF%BC%89Java%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">        （3）Java代码实现</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%884%EF%BC%89%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%20%2B%20%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%884%EF%BC%89%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%20%2B%20%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90" rel="nofollow">        （4）时间复杂度 + 空间复杂度分析</a></strong></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%885%EF%BC%89%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%885%EF%BC%89%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">        （5）应用场景</a></strong></p> 
<p id="2.%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88Shell%20Sort%EF%BC%89-toc" style="margin-left:0px;"><strong><a href="#2.%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88Shell%20Sort%EF%BC%89" rel="nofollow">2.希尔排序（Shell Sort）</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%881%EF%BC%89%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%881%EF%BC%89%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B" rel="nofollow">        （1）算法简介</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%882%EF%BC%89%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%882%EF%BC%89%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4" rel="nofollow">        （2）算法步骤</a></strong></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%883%EF%BC%89%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%883%EF%BC%89%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">        （3）代码实现</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%884%EF%BC%89%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%20%2B%20%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%884%EF%BC%89%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%20%2B%20%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90" rel="nofollow">        （4）时间复杂度 + 空间复杂度分析</a></strong></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%885%EF%BC%89%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%885%EF%BC%89%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">        （5）应用场景</a></strong></p> 
<p id="3.%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%88Selection%20Sort%EF%BC%89-toc" style="margin-left:0px;"><strong><a href="#3.%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%88Selection%20Sort%EF%BC%89" rel="nofollow">3.选择排序（Selection Sort）</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%881%EF%BC%89%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%881%EF%BC%89%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B" rel="nofollow">        （1）算法简介</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%882%EF%BC%89%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%882%EF%BC%89%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4" rel="nofollow">        （2）算法步骤</a></strong></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%883%EF%BC%89%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%883%EF%BC%89%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">        （3）代码实现</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%884%EF%BC%89%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%20%2B%20%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%884%EF%BC%89%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%20%2B%20%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90" rel="nofollow">        （4）时间复杂度 + 空间复杂度分析</a></strong></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%885%EF%BC%89%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%885%EF%BC%89%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">        （5）应用场景</a></strong></p> 
<p id="4.%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88Heap%20Sort%EF%BC%89-toc" style="margin-left:0px;"><strong><a href="#4.%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88Heap%20Sort%EF%BC%89" rel="nofollow">4.堆排序（Heap Sort）</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%881%EF%BC%89%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%881%EF%BC%89%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B" rel="nofollow">        （1）算法简介</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%882%EF%BC%89%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%882%EF%BC%89%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4" rel="nofollow">        （2）算法步骤</a></strong></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%883%EF%BC%89%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%883%EF%BC%89%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">        （3）代码实现</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%884%EF%BC%89%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%20%2B%20%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%884%EF%BC%89%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%20%2B%20%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90" rel="nofollow">        （4）时间复杂度 + 空间复杂度分析</a></strong></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%885%EF%BC%89%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%885%EF%BC%89%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">        （5）应用场景</a></strong></p> 
<p id="5.%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88Bubble%20Sort%EF%BC%89-toc" style="margin-left:0px;"><strong><a href="#5.%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88Bubble%20Sort%EF%BC%89" rel="nofollow">5.冒泡排序（Bubble Sort）</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%881%EF%BC%89%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%881%EF%BC%89%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B" rel="nofollow">        （1）算法简介</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%882%EF%BC%89%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%882%EF%BC%89%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4" rel="nofollow">        （2）算法步骤</a></strong></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%883%EF%BC%89%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%883%EF%BC%89%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">        （3）代码实现</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%884%EF%BC%89%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%20%2B%20%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%884%EF%BC%89%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%20%2B%20%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90" rel="nofollow">        （4）时间复杂度 + 空间复杂度分析</a></strong></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%885%EF%BC%89%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><strong><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%885%EF%BC%89%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">        （5）应用场景</a></strong></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88InsertSort%EF%BC%89"><span style="color:#956fe7;"><strong>1.</strong>插入排序（InsertSort）</span></h2> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%881%EF%BC%89%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B"><span style="color:#4da8ee;">        （1）算法简介</span></h3> 
<p><strong>在开始学习插入排序算法之前，先让我们来看一下该算法的概念：</strong></p> 
<blockquote> 
 <p><span style="color:#ff9900;"><strong>        ——插入排序是一种简单直观的排序算法，通常用于对少量元素的排序。其基本思想是构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</strong></span></p> 
</blockquote> 
<p></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%882%EF%BC%89%E5%8E%9F%E7%90%86%E4%B8%8E%E6%AD%A5%E9%AA%A4"><span style="color:#4da8ee;">        （2）原理与步骤</span></h3> 
<p>        <strong>了解了插入排序算法的概念之后，让我们看一下实现该排序算法的几个核心步骤：</strong></p> 
<ol><li> <p><strong>从第一个元素开始，该元素可以认为已经被排序。</strong></p> </li><li> <p><strong>取出下一个元素，在已经排序的元素序列中从后向前扫描。</strong></p> </li><li> <p><strong>如果已排序的元素大于新元素，将该元素向右移动。</strong></p> </li><li> <p><strong>重复步骤3，直到找到已排序的元素小于或等于新元素的位置。</strong></p> </li><li> <p><strong>将新元素插入到该位置中。</strong></p> </li><li> <p><strong>重复步骤2~5。</strong></p> </li></ol> 
<p>        <span style="color:#a2e043;"><strong>读者可以根据上述的描述先简要的了解一些插入排序的核心思路，接下来让我们使用代码来进行对其的实现。</strong></span></p> 
<p></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%883%EF%BC%89Java%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span style="color:#4da8ee;"><strong>        （3）</strong>Java代码实现</span></h3> 
<p><span style="color:#ffd900;"><strong>现在我们使用代码来实现一下插入排序算法：</strong></span></p> 
<pre><code class="language-java">public class InsertionSort {
    public void insertSort(int[] array) {
        for (int i = 1; i &lt; array.length; i++) {
            int key = array[i];
            int j = i - 1;
            while (j &gt;= 0 &amp;&amp; array[j] &gt; key) {
                array[j + 1] = array[j];
                j = j - 1;
            }
            array[j + 1] = key;
        }
    }
}
</code></pre> 
<p><span style="color:#fe2c24;"><strong>注释解释：</strong></span></p> 
<blockquote> 
 <p><strong>1.外层 <code>for</code> 循环</strong>：</p> 
 <ul><li> <p>从第二个元素（索引为1）开始遍历，因为第一个元素本身已经是一个排序好的子数组。</p> </li></ul> 
 <p><strong>2.保存当前元素</strong>：</p> 
 <ul><li> <p>使用 <code>temp</code> 变量保存当前要插入的元素。</p> </li></ul> 
 <p><strong>3.内层 <code>for</code> 循环</strong>：</p> 
 <ul><li> <p>从当前元素的前一个位置开始向前检查，如果已排序部分的元素大于 <code>temp</code>，就将该元素向后移动一位。</p> </li><li> <p>如果找到的元素小于或等于 <code>temp</code>，则跳出循环，说明找到了插入位置。</p> </li></ul> 
 <p><strong>4.插入元素</strong>：</p> 
 <ul><li> <p>在找到的位置将 <code>temp</code> 插入到数组中。</p> </li></ul> 
</blockquote> 
<p><strong>这样我们就大致的了解了如何去实现插入排序算法了！</strong></p> 
<p></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%884%EF%BC%89%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%20%2B%20%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><strong>   <span style="color:#4da8ee;">     （4）</span></strong><span style="color:#4da8ee;">时间复杂度 + </span><span style="color:#4da8ee;">空间复杂度</span><span style="color:#4da8ee;">分析</span></h3> 
<p>        对于插入排序，其<span style="color:#ff9900;">最坏时间复杂度为O(n^2)</span>，当数据完全逆序时，需进行最多的比较和移动操作。平均情况下的时间复杂度也是O(n^2)，但在<span style="color:#ff9900;">最好的情况下（数据已经有序），时间复杂度为O(n)。</span></p> 
<p>        插入排序是一个原地排序算法，只需要常数级别的额外空间，因此<span style="color:#ff9900;">空间复杂度为O(1)。</span></p> 
<p></p> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%885%EF%BC%89%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span style="color:#ff9900;">      </span><span style="color:#4da8ee;">  （5）应用场景</span></h3> 
<p>        <strong><span style="color:#ff9900;">插入排序常常用于小规模数据集，特别是在数组几乎有序的情况下非常高效</span>。它的稳定性也是其一个优点，在某些需要稳定排序的应用中有着广泛应用。</strong></p> 
<p><strong>        </strong>——<strong>通过上边对插入排序的简单讲解，我们就大致的了解了</strong><strong>插入排序算法了！</strong></p> 
<p></p> 
<p></p> 
<h2 id="2.%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88Shell%20Sort%EF%BC%89"><span style="color:#956fe7;"><strong>2.</strong>希尔排序（Shell Sort）</span></h2> 
<p>        <strong>了解完了插入排序之后，让我们看一下根据其优化的算法——希尔排序。</strong></p> 
<h3><strong>     <span style="color:#4da8ee;">   （1）</span></strong><span style="color:#4da8ee;">算法简介</span></h3> 
<blockquote> 
 <p><span style="color:#ff9900;"><strong>        ——希尔排序（Shell Sort）是插入排序的改进版，它通过分组的方式减少插入排序的移动次数，从而提高排序效率。希尔排序通过一个间隔序列（gap sequence）将数组分成若干子序列，每个子序列进行插入排序，然后逐步减小间隔，最终完成排序。</strong></span></p> 
</blockquote> 
<p></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%882%EF%BC%89%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4"><span style="color:#4da8ee;">        （2）算法步骤</span></h3> 
<p><strong>        了解了希尔排序的基本概念之后，让我们看一下如何去实现希尔排序：</strong></p> 
<ol><li> <p><strong>选择初始间隔（通常为数组长度的一半）。</strong></p> </li><li> <p><strong>对每个间隔下的子序列进行插入排序。</strong></p> </li><li> <p><strong>减小间隔，重复步骤2，直到间隔为1。</strong></p> </li></ol> 
<p><span style="color:#a2e043;"><strong>        ——</strong></span><span style="color:#a2e043;"><strong>那么接下来让我们使用代码来进行对其的实现。</strong></span></p> 
<p></p> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%EF%BC%883%EF%BC%89%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span style="color:#4da8ee;"><strong>        </strong>（3）代码实现</span></h3> 
<p><span style="color:#ffd900;"><strong>以下为实现希尔排序算法的代码：</strong></span></p> 
<pre><code class="language-java">public void shellSort(int[] array) {
    // 初始间隔设置为数组长度
    int gap = array.length;
    
    // 当间隔大于1时，继续进行希尔排序
    while (gap &gt; 1) {
        // 更新间隔，通常将间隔除以2
        gap /= 2;
        
        // 使用当前间隔进行插入排序
        shellInsertSort(gap, array);
    }
}

private void shellInsertSort(int gap, int[] array) {
    // 从间隔后的第一个元素开始遍历
    for (int i = gap; i &lt; array.length; i++) {
        // 保存当前要插入的元素
        int temp = array[i];
        // 从当前元素的前一个间隔位置开始向前检查
        int j = i - gap;
        
        // 将当前元素与前面间隔的元素进行比较
        // 如果前面间隔的元素大于当前元素，则将前面间隔的元素向后移动一位
        // 否则，找到正确的位置
        for (; j &gt;= 0; j -= gap) {
            if (array[j] &gt; temp) {
                array[j + gap] = array[j]; // 移动元素
            } else {
                break; // 找到插入位置
            }
        }
        // 将当前元素插入到找到的位置
        array[j + gap] = temp;
    }
}
</code></pre> 
<p><span style="color:#fe2c24;"><strong>注释解释：</strong></span></p> 
<blockquote> 
 <ol><li> <p><strong><code>shellSort</code> 方法</strong>：</p> 
   <ul><li> <p><strong>初始化间隔</strong>：设置初始间隔为数组的长度。</p> </li><li> <p><strong>更新间隔</strong>：通过将间隔除以2来逐步减小间隔，直到间隔小于等于1。</p> </li><li> <p><strong>调用插入排序</strong>：使用当前的间隔值调用 <code>shellInsertSort</code> 方法对数组进行插入排序。</p> </li></ul></li><li> <p><strong><code>shellInsertSort</code> 方法</strong>：</p> 
   <ul><li> <p><strong>遍历数组</strong>：从当前间隔位置的第一个元素开始遍历数组。</p> </li><li> <p><strong>保存当前元素</strong>：将当前元素保存到 <code>temp</code> 中。</p> </li><li> <p><strong>检查并插入</strong>：从当前元素的前一个间隔位置开始向前检查，如果前面的元素大于当前元素，则将前面的元素向后移动一位，直到找到适合插入的位置。</p> </li><li> <p><strong>插入元素</strong>：将当前元素 <code>temp</code> 插入到找到的位置。</p> </li></ul></li></ol> 
</blockquote> 
<p><strong>        这样我们就大致的了解了如何去实现希尔排序算法了！</strong></p> 
<p></p> 
<h3><strong>     <span style="color:#4da8ee;">   （4）</span></strong><span style="color:#4da8ee;">时间复杂度 + 空间复杂度分析</span></h3> 
<p>        希尔排序的时间复杂度取决于选择的间隔序列。常见的间隔序列有Shell增量（n/2, n/4, …, 1）和Hibbard增量（1, 3, 7, 15, …）。<span style="color:#ff9900;">时间复杂度通常介于O(n)和O(n^2)之间，最坏情况下为O(n^2)。</span></p> 
<p>        希尔排序也是一种原地排序算法，<span style="color:#ff9900;">空间复杂度为O(1)。</span></p> 
<p></p> 
<h3><span style="color:#4da8ee;">        （5）应用场景</span></h3> 
<p><strong>        <span style="color:#ff9900;">希尔排序适用于中小规模的数据集</span>，特别是在内存较为紧张且需要较高排序效率的场景下表现优异。</strong></p> 
<p>        ——<strong>通过上边对希尔排序的简单讲解，我们就大致的了解了希尔</strong><strong>排序算法了！</strong></p> 
<p></p> 
<p></p> 
<h2 id="3.%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%88Selection%20Sort%EF%BC%89"><span style="color:#956fe7;"><strong>3.</strong>选择排序（Selection Sort）</span></h2> 
<p><strong>        接下来让我们学习选择排序算法。</strong></p> 
<h3><span style="color:#4da8ee;">        （1）算法简介</span></h3> 
<blockquote> 
 <p>    <span style="color:#ff9900;"><strong>    ——选择排序（Selection Sort）是一种简单的排序算法。它的基本思想是每次从未排序部分中选择最小的元素，放到已排序部分的末尾。选择排序的特点是每次交换位置时，都能确定一个元素的最终位置，因此它的交换次数较少。</strong></span></p> 
</blockquote> 
<p></p> 
<h3><span style="color:#4da8ee;">        （2）算法步骤</span></h3> 
<p>        <strong>在了解完了选择排序算法的概念之后，让我们看一下实现其算法的核心步骤：</strong></p> 
<ol><li> <p>从数组中找到最小的元素，将其与数组的第一个元素交换位置。</p> </li><li> <p>在剩下的未排序部分中重复上述步骤，直到所有元素都已排序。</p> </li></ol> 
<p><span style="color:#a2e043;"><strong>这样，我们就了解了选择排序的核心思路了，接下来让我们使用代码对其进行实现。</strong></span></p> 
<p></p> 
<h3><span style="color:#a2e043;"><strong>      </strong></span><span style="color:#4da8ee;"><strong>  </strong>（3）代码实现</span></h3> 
<p><span style="color:#ffd900;"><strong>以下为实现选择排序算法的代码：</strong></span></p> 
<pre><code class="language-java">public void selectSort(int[] array) {
    // 遍历数组的每一个元素
    for (int i = 0; i &lt; array.length - 1; i++) {
        // 假设当前元素是最小值
        int minIndex = i;
        
        // 在未排序部分中寻找最小值的索引
        for (int j = i + 1; j &lt; array.length; j++) {
            // 如果找到比当前最小值还小的元素，则更新最小值的索引
            if (array[j] &lt; array[minIndex]) {
                minIndex = j;
            }
        }
        
        // 将当前元素与找到的最小值交换位置
        swap(array, i, minIndex);
    }
}

private void swap(int[] array, int pos1, int pos2) {
    // 交换数组中两个位置的元素
    int temp = array[pos1];
    array[pos1] = array[pos2];
    array[pos2] = temp;
}
</code></pre> 
<p><span style="color:#fe2c24;"><strong>注释解释：</strong></span></p> 
<blockquote> 
 <ol><li> <p><strong><code>selectSort</code> 方法</strong>：</p> 
   <ul><li> <p><strong>遍历数组</strong>：通过外层循环遍历数组的每个元素，作为当前排序的起始位置。</p> </li><li> <p><strong>寻找最小值</strong>：假设当前元素是最小值，并使用内层循环在未排序部分中寻找更小的值。</p> </li><li> <p><strong>更新最小值索引</strong>：如果找到比当前最小值更小的元素，则更新 <code>minIndex</code> 为这个元素的位置。</p> </li><li> <p><strong>交换元素</strong>：调用 <code>swap</code> 方法，将当前元素与找到的最小值元素交换位置，使得最小值元素放置在当前排序的位置上。</p> </li></ul></li><li> <p><strong><code>swap</code> 方法</strong>：</p> 
   <ul><li> <p><strong>交换位置</strong>：使用临时变量 <code>temp</code> 来交换数组中两个指定位置的元素。</p> </li></ul></li></ol> 
</blockquote> 
<p><strong>        这样我们就大致的了解了如何去实现选择排序算法了！</strong></p> 
<p></p> 
<h3><strong>    <span style="color:#4da8ee;">    （4）</span></strong><span style="color:#4da8ee;">时间复杂度 + 空间复杂度分析</span></h3> 
<p><span style="color:#ffd900;"><strong>时间复杂度：</strong></span></p> 
<blockquote> 
 <ul><li><strong>最坏情况</strong>：O(n^2)</li><li><strong>最好情况</strong>：O(n^2)</li><li><strong>平均情况</strong>：O(n^2)</li></ul> 
</blockquote> 
<p><span style="color:#ffd900;"><strong>空间复杂度：</strong></span></p> 
<p>        选择排序也是一种原地排序算法，<span style="color:#ff9900;">空间复杂度为O(1)。</span></p> 
<p></p> 
<h3><span style="color:#ff9900;">     </span><span style="color:#4da8ee;">   （5）应用场景</span></h3> 
<p>        <strong><span style="color:#ff9900;">选择排序适用于对内存写操作次数敏感的场景</span>，因为它的交换次数较少。此外，选择排序在数据量不大且对排序效率要求不高的场合中表现良好。</strong></p> 
<p>        ——<strong>通过上边对选择排序的简单讲解，我们就大致的了解了选择</strong><strong>排序算法了！</strong></p> 
<p></p> 
<h2 id="4.%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88Heap%20Sort%EF%BC%89"><span style="color:#956fe7;"><strong>4.</strong>堆排序（Heap Sort）</span></h2> 
<p>        <strong>接下来让我们学习堆排序算法。</strong></p> 
<h3><span style="color:#4da8ee;"><strong>        （1）</strong>算法简介</span></h3> 
<blockquote> 
 <p><span style="color:#ff9900;"><strong>        ——堆排序（Heap Sort）是一种基于堆这种数据结构的排序算法。堆是一种近似完全二叉树的结构，分为大顶堆和小顶堆。堆排序通过构建一个大顶堆或小顶堆，将根节点与末尾元素交换，逐步减少堆的大小，最终完成排序。</strong></span></p> 
</blockquote> 
<p></p> 
<h3><span style="color:#4da8ee;">        （2）算法步骤</span></h3> 
<p><strong>        在了解完了堆排序算法的概念之后，让我们看一下实现其算法的核心步骤：</strong></p> 
<blockquote> 
 <ol><li> <p><strong>构建一个最大堆。</strong></p> </li><li> <p><strong>将堆顶元素（最大值）与最后一个元素交换，将堆的大小减1。</strong></p> </li><li> <p><strong>调整堆结构，使其重新满足最大堆性质。</strong></p> </li><li> <p><strong>重复步骤2和3，直到堆的大小为1。</strong></p> </li></ol> 
</blockquote> 
<p><span style="color:#a2e043;"><strong>        </strong></span><span style="color:#a2e043;"><strong>接下来让我们使用代码来进行对其的实现。</strong></span></p> 
<p></p> 
<h3><span style="color:#a2e043;"><strong>  </strong></span><span style="color:#4da8ee;"><strong>      </strong>（3）代码实现</span></h3> 
<p><span style="color:#ffd900;"><strong>以下为实现堆排序算法的代码：</strong></span></p> 
<pre><code class="language-java">public void heapSort(int[] array) {
    // 将数组转换为大根堆
    // 从最后一个非叶子节点开始，向上调整堆
    for (int parent = (array.length - 1 - 1) / 2; parent &gt;= 0; parent--) {
        makeHeap(array, parent, array.length);
    }

    // 交换堆顶（最大值）和最后一个元素，重新调整堆
    int end = array.length - 1;
    while (end &gt; 0) {
        // 交换堆顶和当前堆的最后一个元素
        swap(array, 0, end);
        // 调整新的堆顶
        makeHeap(array, 0, end);
        end--;
    }
}

private void makeHeap(int[] array, int parent, int length) {
    // 左子节点的索引
    int child = 2 * parent + 1;
    while (child &lt; length) {
        // 如果右子节点存在且大于左子节点，则将子节点设置为右子节点
        if (child + 1 &lt; length &amp;&amp; array[child] &lt; array[child + 1]) {
            child++;
        }
        // 如果父节点小于子节点，则交换父节点和子节点
        if (array[parent] &lt; array[child]) {
            swap(array, parent, child);
            // 更新父节点为刚交换过的子节点
            parent = child;
            // 更新子节点为新的左子节点
            child = 2 * parent + 1;
        } else {
            break;
        }
    }
}

private void swap(int[] array, int pos1, int pos2) {
    // 交换数组中两个位置的元素
    int temp = array[pos1];
    array[pos1] = array[pos2];
    array[pos2] = temp;
}
</code></pre> 
<p><span style="color:#fe2c24;"><strong>注释解释：</strong></span></p> 
<blockquote> 
 <ol><li> <p><strong><code>heapSort</code> 方法</strong>：</p> 
   <ul><li> <p><strong>构建大根堆</strong>：从最后一个非叶子节点开始（计算公式 <code>(array.length - 1 - 1) / 2</code>），对每个节点调用 <code>makeHeap</code> 方法来调整堆，使整个数组成为一个大根堆。</p> </li><li> <p><strong>排序过程</strong>：将堆顶（最大值）与当前堆的最后一个元素交换，并对新的堆顶进行调整。每次调整后减少堆的有效长度 <code>end</code>，直到 <code>end</code> 为0，即整个数组已经排序完毕。</p> </li></ul></li><li> <p><strong><code>makeHeap</code> 方法</strong>：</p> 
   <ul><li> <p><strong>调整堆</strong>：从父节点开始，检查并维护大根堆的性质。如果子节点存在且大于父节点，则交换父节点和子节点，更新父节点为子节点并继续调整。直到堆的性质被维护好或者没有需要调整的地方。</p> </li></ul></li><li> <p><strong><code>swap</code> 方法</strong>：</p> 
   <ul><li> <p><strong>交换位置</strong>：使用临时变量 <code>temp</code> 来交换数组中两个指定位置的元素</p> </li></ul></li></ol> 
</blockquote> 
<p><strong>这样我们就大致的了解了如何去实现堆排序算法了！</strong></p> 
<p></p> 
<h3><strong>       <span style="color:#4da8ee;"> （4）</span></strong><span style="color:#4da8ee;">时间复杂度 + 空间复杂度分析</span></h3> 
<p><span style="color:#ffd900;"><strong>堆排序的时间复杂度主要来自于构建最大堆和调整堆的过程：</strong></span></p> 
<blockquote> 
 <ul><li><strong>最坏情况</strong>：O(n log n)</li><li><strong>最好情况</strong>：O(n log n)</li><li><strong>平均情况</strong>：O(n log n)</li></ul> 
</blockquote> 
<p><strong><span style="color:#ffd900;">     </span>   </strong><span style="color:#ff9900;">由于堆的调整涉及到树的高度，而树的高度为log n</span>，因此每次调整堆的复杂度为O(log n)，总的时间复杂度为O(n log n)。</p> 
<p><strong><span style="color:#ffd900;">        </span></strong>堆排序是原地排序算法，不需要额外的存储空间，<span style="color:#ff9900;">空间复杂度为O(1)。</span></p> 
<p></p> 
<h3><span style="color:#ff9900;">        </span><span style="color:#4da8ee;"><strong>（5）应用场景</strong></span></h3> 
<p>       <span style="color:#ff9900;"> </span><strong><span style="color:#ff9900;">堆排序适用于需要高效且稳定的排序场景，尤其在需要排序较大数据集的情况下</span>，堆排序表现良好，由于其时间复杂度在最坏情况下仍然保持O(n log n)，堆排序在处理大量数据时非常有用。</strong></p> 
<p>        ——<strong>通过上边对堆排序的简单讲解，我们就大致的了解了堆</strong><strong>排序算法了！</strong></p> 
<p></p> 
<h2 id="5.%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88Bubble%20Sort%EF%BC%89"><span style="color:#956fe7;"><strong>5.</strong>冒泡排序（Bubble Sort）</span></h2> 
<p><strong>        最后，让我们学习一下冒泡排序算法。</strong></p> 
<h3>       <span style="color:#4da8ee;"> （1）算法简介</span></h3> 
<blockquote> 
 <p>   <span style="color:#ff9900;"><strong>     ——冒泡排序（Bubble Sort）是一种最简单的排序算法之一。它的基本思想是通过多次遍历数组，每次都将相邻的两个元素进行比较，并根据大小关系交换它们的位置。这样，较大的元素逐步“冒泡”到数组的末尾。尽管冒泡排序的效率较低，但它的概念简单，容易理解和实现。</strong></span></p> 
</blockquote> 
<p></p> 
<h3>       <span style="color:#4da8ee;"> （2）算法步骤</span></h3> 
<p><strong>        了解了冒泡排序算法的概念之后，让我们看一下实现该排序算法的几个核心步骤：</strong></p> 
<ol><li> <p>从数组的起始位置开始，逐个比较相邻的两个元素。</p> </li><li> <p>如果前一个元素比后一个元素大，则交换它们的位置。</p> </li><li> <p>对整个数组进行多次遍历，直到没有元素需要交换为止。</p> </li></ol> 
<p><span style="color:#a2e043;"><strong>接下来我们使用代码对其进行实现。</strong></span></p> 
<p></p> 
<h3><span style="color:#4da8ee;"><strong>        </strong>（3）代码实现</span></h3> 
<p><span style="color:#ffd900;"><strong>以下为实现冒泡排序算法的代码：</strong></span></p> 
<pre><code class="language-java">public void bubbleSort(int[] array) {
    // 外层循环控制排序的轮数
    for (int i = 0; i &lt; array.length - 1; i++) {
        // 标志位，用于检测是否有交换发生
        boolean flag = true;
        
        // 内层循环进行相邻元素的比较和交换
        for (int j = 0; j &lt; array.length - 1 - i; j++) {
            // 如果当前元素大于下一个元素，则交换它们
            if (array[j] &gt; array[j + 1]) {
                flag = false; // 设置标志位为 false，表示发生了交换
                swap(array, j, j + 1);
            }
        }
        
        // 如果在某一轮排序中没有发生交换，说明数组已经有序，提前退出循环
        if (flag) {
            break;
        }
    }
}

private void swap(int[] array, int pos1, int pos2) {
    // 交换数组中两个位置的元素
    int temp = array[pos1];
    array[pos1] = array[pos2];
    array[pos2] = temp;
}
</code></pre> 
<p><span style="color:#fe2c24;"><strong>注释解释：</strong></span></p> 
<blockquote> 
 <ol><li> <p><strong><code>bubbleSort</code> 方法</strong>：</p> 
   <ul><li> <p><strong>外层循环</strong>：控制排序的轮数，总共需要 <code>array.length - 1</code> 轮。在每一轮中，最大的元素会被移动到数组的末尾。</p> </li><li> <p><strong>标志位 <code>flag</code></strong>：在每一轮开始时，假设数组已经有序。如果在该轮中没有发生任何交换，<code>flag</code> 会保持为 <code>true</code>，表明数组已经完全排序好，可以提前结束排序。</p> </li><li> <p><strong>内层循环</strong>：比较相邻的元素，如果当前元素大于下一个元素，则交换它们，并将 <code>flag</code> 设置为 <code>false</code>，表示发生了交换。每次比较和交换的范围逐渐减小，因为每轮排序都会将最大元素移到末尾。</p> </li></ul></li><li> <p><strong><code>swap</code> 方法</strong>：</p> 
   <ul><li> <p><strong>交换位置</strong>：使用临时变量 <code>temp</code> 来交换数组中两个指定位置的元素。</p> </li></ul></li></ol> 
</blockquote> 
<p><strong>这样我们就大致的了解了如何去实现冒泡排序算法了！</strong></p> 
<p></p> 
<h3><span style="color:#4da8ee;"><strong>        （4）</strong>时间复杂度 + 空间复杂度分析</span></h3> 
<p><span style="color:#ffd900;"><strong>时间复杂度：</strong></span></p> 
<blockquote> 
 <ul><li><strong>最坏情况</strong>：O(n^2)（数组为逆序）</li><li><strong>最好情况</strong>：O(n)（数组已经有序）</li><li><strong>平均情况</strong>：O(n^2）</li></ul> 
</blockquote> 
<p>        <span style="color:#ff9900;">在最坏和平均情况下，冒泡排序的时间复杂度都是O(n^2)</span>，但在最佳情况下，当数组已经有序时，冒泡排序的复杂度可以降为O(n)。</p> 
<p><strong><span style="color:#ffd900;">空间复杂度：</span></strong></p> 
<p>        冒泡排序是原地排序算法，不需要额外的存储空间，<span style="color:#ff9900;">空间复杂度为O(1)。</span></p> 
<p></p> 
<h3 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%EF%BC%885%EF%BC%89%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">   <span style="color:#4da8ee;">     （5）应用场景</span></h3> 
<p><strong>        <span style="color:#ff9900;">冒泡排序适用于小规模数据集或数据基本有序的情况</span>。尽管冒泡排序的效率较低，但其实现简单，<span style="color:#ff9900;">常用于教学演示或一些对效率要求不高的应用场景。</span></strong></p> 
<p>        ——<strong>通过上边对堆排序的简单讲解，我们就大致的了解了堆</strong><strong>排序算法了！</strong></p> 
<p></p> 
<hr> 
<p style="text-align:center;"><span style="color:#38d8f0;"><strong>以上就是本篇文章的全部内容了~~~</strong></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5233ba70efca2ba6e88bbae6343c7510/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">DOM Clobbring个人理解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4e7fb72304a9cbcfa41e9d84d7d14bc1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">c_cpp_properties.json、launch.json、 tasks.json</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>