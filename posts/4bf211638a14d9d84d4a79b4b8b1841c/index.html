<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【JSqlParser】Java使用JSqlParser解析SQL语句总结 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4bf211638a14d9d84d4a79b4b8b1841c/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【JSqlParser】Java使用JSqlParser解析SQL语句总结">
  <meta property="og:description" content="简述 Java解析SQL语句有很多工具都可以做到，比如Mybatis、Druid、目前用来用去最全面的仍然是Jsqlparser，它是一个Github上的开源项目，JSqlParser是一个用于解析SQL语句的Java库，它可以帮助开发者分析和操作SQL语句的结构。无论是从事数据库开发、SQL性能优化，还是需要解析SQL语句以进行其他操作，JSqlParser都能提供强大的支持
特点 支持多种SQL方言：JSqlParser支持多种数据库的SQL方言，包括MySQL、Oracle、PostgreSQL等，这使得在不同数据库之间进行SQL语句解析变得更加方便。
灵活的操作：JSqlParser以多种方式操作SQL语句，例如修改查询条件、提取表名、列名等，甚至整个SQL语句中使用到的函数，从而满足各种需求。
易于集成：JSqlParser可以轻松集成到您的Java项目中，只需将其作为依赖项添加到项目中即可。
社区支持：JSqlParser拥有一个活跃的社区，许多开发者为其提供贡献，使得这个工具不断得到改进和优化，它的主要操刀人manticore-projects (github.com) 也非常负责并愿意解答各种问题和参与讨论
环境准备 将Jsqlparser直接添加到项目中
Maven：
&lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;/dependency&gt; Gradle：
implementation(&#34;com.github.jsqlparser:jsqlparser:4.9&#34;) 快速使用 使用原则 假设现在有一条简单的SQL语句需要拿来解析，首先应该保证这个SQL在结构上是没有问题的，最好是放在数据库中可以直接运行的，不夹杂不应该的标点符号，那样解析起来才不会出错
使用案例：
以下是一个简单的SQL语句，并且这句SQL没有违反原则，是一条基本可以正常运行的SQL语句
SELECT id,name,nickname,age,job,department FROM staff_member WHERE nickname= &#34;刘&#34; 解析SQL语句 接下来使用Jsqlparser去解析语句，其中第二行则是最基本的，将SQL语句字符串拿来解析，如果这句SQL语句违反了原则，例如存在特殊标点符号或者不符合SQL语句，那么在第二行就会产生异常
String sql = &#34;SELECT id,name,nickname,age,job,department FROM staff_member WHERE nickname= &#39;刘&#39;&#34;; // Parse SQL Statement statement = CCJSqlParserUtil.parse(sql); Select selectStatement = (Select) statement; log.info(&#34;==&gt; JsqlParser SQL: {}&#34;, selectStatement.toString()); 正常情况下，将得到一个包含各种属性的statement，这意味着一条SQL成功被解析，并被赋予到一个对象的各个属性中
认识Statement 熟悉JDBC的程序员一般都知道Statement，其实就是语句的意思，不过在Jsqlparser中Statement已经面向对象，被设计成了一个interface，之所以设计成interface大概都可以猜到，因为Jsqlparser既然要去解析SQL，那必然要对SQL语句做区分，到底是Select、还是Insert、还是Delete、甚至是Create，而Jsqlparser对每种语句都做了一个封装，它们都继承了Statement
所以一条SQL语句，根据不同情况，都有适配的对象，例如Select语句对应着 net.sf.jsqlparser.statement.select.Select对象，而Insert也有自己的对象，所以我们都可以通过将Statement强转为它所对应的对象来获取或改变其中的属性，这也是解析SQL的一大目的
其实在Jsqlparser成功解析SQL语句之后，statement就已经有了它的类型
String sql = &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-21T15:33:36+08:00">
    <meta property="article:modified_time" content="2024-06-21T15:33:36+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【JSqlParser】Java使用JSqlParser解析SQL语句总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>简述</h2> 
<p>Java解析SQL语句有很多工具都可以做到，比如Mybatis、Druid、目前用来用去最全面的仍然是Jsqlparser，它是一个Github上的开源项目，JSqlParser是一个用于解析SQL语句的Java库，它可以帮助开发者分析和操作SQL语句的结构。无论是从事数据库开发、SQL性能优化，还是需要解析SQL语句以进行其他操作，JSqlParser都能提供强大的支持</p> 
<h2>特点</h2> 
<ol><li> <p>支持多种SQL方言：JSqlParser支持多种数据库的SQL方言，包括MySQL、Oracle、PostgreSQL等，这使得在不同数据库之间进行SQL语句解析变得更加方便。</p> </li><li> <p>灵活的操作：JSqlParser以多种方式操作SQL语句，例如修改查询条件、提取表名、列名等，甚至整个SQL语句中使用到的函数，从而满足各种需求。</p> </li><li> <p>易于集成：JSqlParser可以轻松集成到您的Java项目中，只需将其作为依赖项添加到项目中即可。</p> </li><li> <p>社区支持：JSqlParser拥有一个活跃的社区，许多开发者为其提供贡献，使得这个工具不断得到改进和优化，它的主要操刀人<a href="https://github.com/manticore-projects" title="manticore-projects (github.com)">manticore-projects (github.com)</a> 也非常负责并愿意解答各种问题和参与讨论</p> </li></ol> 
<h2><strong>环境准备</strong></h2> 
<p>将Jsqlparser直接添加到项目中</p> 
<p>Maven：</p> 
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt;
    &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt;
    &lt;version&gt;4.9&lt;/version&gt;
&lt;/dependency&gt;
</code></pre> 
<p>Gradle：</p> 
<pre><code>implementation("com.github.jsqlparser:jsqlparser:4.9")
</code></pre> 
<h2><strong>快速使用</strong></h2> 
<h3><strong>使用原则</strong></h3> 
<p>假设现在有一条简单的SQL语句需要拿来解析，首先应该保证这个SQL在结构上是没有问题的，最好是放在数据库中可以直接运行的，不夹杂不应该的标点符号，那样解析起来才不会出错</p> 
<p>使用案例：</p> 
<p>以下是一个简单的SQL语句，并且这句SQL没有违反原则，是一条基本可以正常运行的SQL语句</p> 
<pre><code class="language-sql">SELECT id,name,nickname,age,job,department FROM staff_member WHERE nickname= "刘"</code></pre> 
<h3><strong>解析SQL语句</strong></h3> 
<p>接下来使用Jsqlparser去解析语句，其中第二行则是最基本的，将SQL语句字符串拿来解析，如果这句SQL语句违反了原则，例如存在特殊标点符号或者不符合SQL语句，那么在第二行就会产生异常</p> 
<pre><code class="language-java">String sql = "SELECT id,name,nickname,age,job,department FROM staff_member WHERE nickname= '刘'";
// Parse SQL
Statement statement = CCJSqlParserUtil.parse(sql);
Select selectStatement = (Select) statement;
log.info("==&gt; JsqlParser SQL: {}", selectStatement.toString());</code></pre> 
<p>正常情况下，将得到一个包含各种属性的statement，这意味着一条SQL成功被解析，并被赋予到一个对象的各个属性中</p> 
<p><img alt="" height="772" src="https://images2.imgbox.com/6a/05/JXxFNHyz_o.png" width="954"></p> 
<h3>认识Statement</h3> 
<p>熟悉JDBC的程序员一般都知道Statement，其实就是语句的意思，不过在Jsqlparser中Statement已经面向对象，被设计成了一个interface，之所以设计成interface大概都可以猜到，因为Jsqlparser既然要去解析SQL，那必然要对SQL语句做区分，到底是Select、还是Insert、还是Delete、甚至是Create，而Jsqlparser对每种语句都做了一个封装，它们都继承了Statement</p> 
<p><img alt="" height="323" src="https://images2.imgbox.com/1d/ab/qUSSeR3k_o.png" width="198"></p> 
<p>所以一条SQL语句，根据不同情况，都有适配的对象，例如Select语句对应着 net.sf.jsqlparser.statement.select.Select对象，而Insert也有自己的对象，所以我们都可以通过将Statement强转为它所对应的对象来获取或改变其中的属性，这也是解析SQL的一大目的</p> 
<p>其实在Jsqlparser成功解析SQL语句之后，statement就已经有了它的类型</p> 
<pre><code class="language-java">String sql = "SELECT id,name,nickname,age,job,department FROM staff_member WHERE nickname= '刘'";
        // Parse SQL
 Statement statement = CCJSqlParserUtil.parse(sql);
 if(statement instanceof Select){
       Select selectStatement = (Select) statement;
      log.info("==&gt; JsqlParser SQL: {}", selectStatement.toString());
}
if(statement instanceof Insert){
       Insert insertStatement = (Insert) statement;
       log.info("==&gt; JsqlParser SQL: {}", insertStatement.toString());
}
if(statement instanceof Update){
      Update updateStatement = (Update) statement;
      log.info("==&gt; JsqlParser SQL: {}", updateStatement.toString());
}
if (statement instanceof Delete) {
      Delete deleteStatement = (Delete) statement;
      log.info("==&gt; JsqlParser SQL: {}", statement.toString());
}</code></pre> 
<h2>分析语句</h2> 
<h3>查询语句</h3> 
<p>在statement成功解析SQL语句之后，通过PlainSelect就可以拿到SQL语句中的各个元素</p> 
<pre><code class="language-java">String sql = "SELECT id,name,nickname,age,job,department FROM staff_member WHERE nickname= '刘'";
// Parse SQL
Statement statement = CCJSqlParserUtil.parse(sql);
if(statement instanceof Select){
    Select selectStatement = (Select) statement;
    log.info("==&gt; JsqlParser SQL: {}", selectStatement.toString());
    PlainSelect plainSelect = selectStatement.getPlainSelect();
    log.info("==&gt; FromItem: {}", plainSelect.getFromItem());
    log.info("==&gt; SelectItem: {}",plainSelect.getSelectItems());
    log.info("==&gt; Where: {}",plainSelect.getWhere());
}</code></pre> 
<p>运行结果：</p> 
<pre><code class="language-java">==&gt; JsqlParser SQL: SELECT id, name, nickname, age, job, department FROM staff_member WHERE nickname = '刘'
==&gt; FromItem: staff_member
==&gt; SelectItem: [id, name, nickname, age, job, department]
==&gt; Where: nickname = '刘'</code></pre> 
<h4>PlainSelect常用方法：</h4> 
<ul><li> <p><strong>获取和设置表（From子句）:</strong></p> 
  <ul><li><code>FromItem getFromItem()</code>: 获取FROM子句中的表或子查询。</li><li><code>void setFromItem(FromItem fromItem)</code>: 设置FROM子句中的表或子查询。</li></ul></li><li> <p><strong>获取和设置选择项（SelectItems）</strong>:</p> 
  <ul><li><code>List&lt;SelectItem&gt; getSelectItems()</code>: 获取SELECT子句中的选择项列表。</li><li><code>void setSelectItems(List&lt;SelectItem&gt; selectItems)</code>: 设置SELECT子句中的选择项列表。</li></ul></li><li> <p><strong>获取和设置WHERE子句</strong>:</p> 
  <ul><li><code>Expression getWhere()</code>: 获取WHERE子句的条件表达式。</li><li><code>void setWhere(Expression where)</code>: 设置WHERE子句的条件表达式。</li></ul></li><li> <p><strong>获取和设置GROUP BY子句</strong>:</p> 
  <ul><li><code>List&lt;Expression&gt; getGroupByColumnReferences()</code>: 获取GROUP BY子句中的列引用列表。</li><li><code>void setGroupByColumnReferences(List&lt;Expression&gt; groupByColumnReferences)</code>: 设置GROUP BY子句中的列引用列表。</li></ul></li><li> <p><strong>获取和设置ORDER BY子句</strong>:</p> 
  <ul><li><code>List&lt;OrderByElement&gt; getOrderByElements()</code>: 获取ORDER BY子句中的排序元素列表。</li><li><code>void setOrderByElements(List&lt;OrderByElement&gt; orderByElements)</code>: 设置ORDER BY子句中的排序元素列表。</li></ul></li><li> <p><strong>获取和设置LIMIT子句</strong>:</p> 
  <ul><li><code>Limit getLimit()</code>: 获取LIMIT子句。</li><li><code>void setLimit(Limit limit)</code>: 设置LIMIT子句。</li></ul></li><li> <p><strong>获取和设置DISTINCT关键字</strong>:</p> 
  <ul><li><code>boolean isDistinct()</code>: 检查SELECT语句是否使用了DISTINCT关键字。</li><li><code>void setDistinct(boolean distinct)</code>: 设置SELECT语句是否使用DISTINCT关键字。</li></ul></li><li> <p><strong>获取和设置INTO子句（用于SELECT INTO语句）</strong>:</p> 
  <ul><li><code>SubSelect getIntoTables()</code>: 获取INTO子句中的表。</li><li><code>void setIntoTables(SubSelect intoTables)</code>: 设置INTO子句中的表。</li></ul></li><li> <p><strong>获取和设置HAVING子句</strong>:</p> 
  <ul><li><code>Expression getHaving()</code>: 获取HAVING子句的条件表达式。</li><li><code>void setHaving(Expression having)</code>: 设置HAVING子句的条件表达式。</li></ul></li><li> <p><strong>获取和设置别名</strong>:</p> 
  <ul><li><code>String getAlias()</code>: 获取SELECT语句的别名。</li><li><code>void setAlias(String alias)</code>: 设置SELECT语句的别名。</li></ul></li><li> <p><strong>获取和设置子查询（SubSelect）</strong>:</p> 
  <ul><li><code>SubSelect getSubSelect()</code>: 获取子查询。</li><li><code>void setSubSelect(SubSelect subSelect)</code>: 设置子查询。</li></ul></li><li> <p><strong>获取和设置联合查询（Union）</strong>:</p> 
  <ul><li><code>List&lt;PlainSelect&gt; getUnion()</code>: 获取联合查询的SELECT语句列表。</li><li><code>void setUnion(List&lt;PlainSelect&gt; union)</code>: 设置联合查询的SELECT语句列表。</li></ul></li></ul> 
<h3>新增语句</h3> 
<p>新增语句和查询语句一样，只不过由于Insert没有Select语句那么复杂，所以Jsqlparsert并没有专门设计一个类似PlainSelect extend Select这样一个类，而是直接通过Insert对象就可以获取和操作，Insert语句中的内容</p> 
<pre><code class="language-java">String sql = "INSERT INTO employees (employee_id, employee_name, department) VALUES (1, 'John Doe', 'Human Resources')";
// Parse SQL
Statement statement = CCJSqlParserUtil.parse(sql);
if (statement instanceof Insert) {
    Insert insertStatement = (Insert) statement;
    log.info("==&gt; JsqlParser SQL: {}", insertStatement.toString());
    log.info("==&gt; Table: {}", insertStatement.getTable());
    log.info("==&gt; Columns: {}", insertStatement.getColumns());
    log.info("==&gt; ItemsList: {}", insertStatement.getValues());
}</code></pre> 
<p>运行结果：</p> 
<pre><code class="language-java"> ==&gt; JsqlParser SQL: INSERT INTO employees (employee_id, employee_name, department) VALUES (1, 'John Doe', 'Human Resources')
 ==&gt; Table: employees
 ==&gt; Columns: employee_id, employee_name, department
 ==&gt; ItemsList: VALUES (1, 'John Doe', 'Human Resources')</code></pre> 
<h4>Insert常用方法</h4> 
<ul><li><code>Table getTable()</code>: 获取插入语句中的目标表。</li><li><code>List&lt;Column&gt; getColumns()</code>: 获取插入语句中要插入的列的列表。</li><li><code>ItemsList getValues()</code>: 获取插入语句中的值列表，可以是单个值或者子查询。</li><li><code>String getPrefix()</code>: 获取INSERT关键字前的前缀，如<code>INSERT INTO</code>或者<code>INSERT IGNORE</code>。</li><li><code>void setTable(Table table)</code>: 设置插入语句中的目标表。</li><li><code>void setColumns(List&lt;Column&gt; columns)</code>: 设置插入语句中要插入的列的列表。</li><li><code>void setValues(ItemsList values)</code>: 设置插入语句中的值列表。</li><li><code>void setPrefix(String prefix)</code>: 设置INSERT关键字前的前缀。</li></ul> 
<h3>更新语句</h3> 
<p>Update和Insert是一样的，内容相对于Select较为简单，通过Update对象即可获得相关内容</p> 
<pre><code class="language-java">String sql = "UPDATE employees SET department = 'Human Resources' WHERE employee_id = 1";
// Parse SQL
Statement statement = CCJSqlParserUtil.parse(sql);
if (statement instanceof Update) {
    Update updateStatement = (Update) statement;
    log.info("==&gt; JsqlParser SQL: {}", updateStatement.toString());
    Table table = updateStatement.getTable();
    log.info("Table Name: {}", table.getName());
    log.info("==&gt; Columns: {}", updateStatement.getColumns());
    // 获取更新项
    List&lt;UpdateSet&gt; updateSets = updateStatement.getUpdateSets();
    for (UpdateSet updateSet : updateSets) {
        for (Expression expression : updateSet.getColumns()) {
            log.info("==&gt; Expression: {}", expression.toString());
        }
    }
    log.info("==&gt; ItemsList: {}", updateStatement.getExpressions());
    Expression where = updateStatement.getWhere();
    log.info("==&gt; Where: {}", where.toString());
}</code></pre> 
<p>运行结果</p> 
<pre><code class="language-java">==&gt; JsqlParser SQL: UPDATE employees SET department = 'Human Resources' WHERE employee_id = 1
Table Name: employees
==&gt; Columns: department
==&gt; Expression: department
==&gt; ItemsList: 'Human Resources'
==&gt; Where: employee_id = 1
</code></pre> 
<h3>删除语句</h3> 
<pre><code class="language-java">        String sql = "DELETE FROM table_name WHERE condition";
        Statement statement = CCJSqlParserUtil.parse(sql);

        if (statement instanceof Delete) {
            Delete deleteStatement = (Delete) statement;

            // 获取要删除的表
            Table table = deleteStatement.getTable();
            System.out.println("Table Name: " + table.getName());

            // 获取WHERE条件
            Expression where = deleteStatement.getWhere();
            System.out.println("Where Condition: " + where.toString());
        }</code></pre> 
<p>运行结果：</p> 
<pre><code class="language-java">Table Name: table_name
Where Condition: condition</code></pre> 
<h3><strong>从SQL语句中提取表名</strong></h3> 
<pre><code class="language-java">Statement statement = CCJSqlParserUtil.parse("SELECT * FROM MY_TABLE1");
Select selectStatement = (Select) statement;
TablesNamesFinder tablesNamesFinder = new TablesNamesFinder();
List&lt;String&gt; tableList = tablesNamesFinder.getTableList(selectStatement);</code></pre> 
<p>最终tableList里将存入所有给出的SQL语句中的表名，以上案例只有一个表名</p> 
<h3><strong>为SQL语句各个字段表达式添加别名</strong></h3> 
<pre><code class="language-java">String sql = "SELECT id,name,nickname,age,job,department FROM staff_member WHERE nickname= '刘'";
// Parse SQL
Statement statement = CCJSqlParserUtil.parse(sql);
if(statement instanceof Select ){
    Select selectStatement = (Select) statement;
    final AddAliasesVisitor instance = new AddAliasesVisitor();
    instance.setPrefix("t");
    selectStatement.accept(instance);
    log.info("==&gt; JSqlParser finalSQL: {}", selectStatement);
}</code></pre> 
<h3><strong>动态加字段加表达式加条件</strong></h3> 
<h4>使用SelectUtils，为一个Select语句，增加查询的字段</h4> 
<pre><code class="language-java">Select select = (Select) CCJSqlParserUtil.parse("select mydate from mytable");
SelectUtils.addExpression(select, new Column("mylocation"));</code></pre> 
<h4>增加一个表达式</h4> 
<pre><code class="language-java">Select select = (Select) CCJSqlParserUtil.parse("select a from mytable");
SelectUtils.addExpression(select, new Column("b"));
assertEquals("SELECT a, b FROM mytable", select.toString());

Addition add = new Addition();
add.setLeftExpression(new LongValue(5));
add.setRightExpression(new LongValue(6));
SelectUtils.addExpression(select, add);

assertEquals("SELECT a, b, 5 + 6 FROM mytable", select.toString());</code></pre> 
<h4>增加一个Join</h4> 
<p>动态添加Join，可以为Join增加表达式，以及设置Join的表，并且通过setLeft()、setRight()、setInner()可以设置join的方向，最终它会生成对应的SQL语句</p> 
<pre><code class="language-java">Select select = (Select) CCJSqlParserUtil.parse("select a from mytable");
final EqualsTo equalsTo = new EqualsTo();
equalsTo.setLeftExpression(new Column("a"));
equalsTo.setRightExpression(new Column("b"));
Join addJoin = SelectUtils.addJoin(select, new Table("mytable2"), equalsTo);
addJoin.setLeft(true);
assertEquals("SELECT a FROM mytable LEFT JOIN mytable2 ON a = b", select.toString());</code></pre> 
<h4>用SelectUtils构建一个SQL语句</h4> 
<p>下面是SelectUtils里面的一些方法，可以看到不光是为查询语句增加表达式、Join和分组，其次还可以使用build等方法去构建一个SQL语句</p> 
<p><img alt="" height="251" src="https://images2.imgbox.com/4a/35/mrOg2owJ_o.png" width="522"></p> 
<p>这里是一个案例，构建了一个查询语句，其中也使用到了addGroupBy</p> 
<pre><code class="language-java">Select select = SelectUtils.buildSelectFromTableAndExpressions(new Table("mytable"),
                new Column("a"), new Column("b"));
SelectUtils.addExpression(select, new Column("c"));
final EqualsTo equalsTo = new EqualsTo();
equalsTo.setLeftExpression(new Column("id"));
equalsTo.setRightExpression(new Column("1"));
SelectUtils.addGroupBy(select, new Column("d"));
log.info("==&gt; JsqlParser Build SQL: {}", select.toString());</code></pre> 
<p>输出结果：</p> 
<pre><code class="language-java">==&gt; JsqlParser Build SQL: SELECT a, b, c FROM mytable GROUP BY d</code></pre> 
<h3>简短的总结</h3> 
<p>上面的代码虽然不少，但实际上真正需要熟悉的只有一个，就是直接调用CCJSqlParserUtil.parse(sql);去获得Statement，然后通过Statement去操作和获取解析后的SQL中的内容，非常简单方便</p> 
<p></p> 
<h2><strong>实际应用场景</strong></h2> 
<p>说了那么多JSQLPARSER的使用，或许很多朋友并不能联想到有哪些具体可以用到它的地方，实际上想要开发一个优秀的软件产品，那么细节是少不了的，SQL是BS软件的本质之一，那么针对SQL，我们能做的还有很多，以下列举几个常见的场景</p> 
<blockquote> 
 <ul><li> <p><strong>SQL审计和分析</strong>:</p> 
   <ul><li>审计SQL语句，检查是否包含潜在的安全漏洞，如SQL注入。</li><li>分析SQL语句的性能，检查是否存在可以优化的查询条件。</li></ul></li><li> <p><strong>数据库迁移和同步</strong>:</p> 
   <ul><li>在迁移数据库时，使用JSqlParser解析源数据库的SQL语句，并生成目标数据库的相应语句。</li><li>数据库同步工具可以使用JSqlParser来解析和生成SQL语句，以实现数据的同步。</li></ul></li><li> <p><strong>动态SQL生成</strong>:</p> 
   <ul><li>应用程序需要生成动态SQL语句以执行不同的操作，JSqlParser可以用来解析这些动态生成的SQL语句。</li></ul></li><li> <p><strong>SQL测试和验证</strong>:</p> 
   <ul><li>在开发过程中，使用JSqlParser来验证SQL语句的正确性。</li><li>单元测试中，使用JSqlParser来解析和执行测试用例中的SQL语句。</li></ul></li><li> <p><strong>SQL注入防护</strong>:</p> 
   <ul><li>在应用程序中，使用JSqlParser来解析和分析用户输入的SQL查询，以防止SQL注入攻击。</li></ul></li><li> <p><strong>数据库管理工具</strong>:</p> 
   <ul><li>数据库管理工具可以使用JSqlParser来解析和显示SQL语句的结构，帮助开发者理解查询的逻辑。</li></ul></li><li> <p><strong>代码生成</strong>:</p> 
   <ul><li>在生成数据库访问层代码时，使用JSqlParser来解析SQL语句，并生成相应的数据访问对象（DAO）或查询对象（DTO）。</li></ul></li><li> <p><strong>SQL格式化</strong>:</p> 
   <ul><li>使用JSqlParser来格式化SQL语句，使其更易于阅读和理解。</li></ul></li><li> <p><strong>SQL优化</strong>:</p> 
   <ul><li>通过分析SQL语句的结构，可以提出性能优化建议。</li></ul></li><li> <p><strong>数据处理工具</strong>:</p> 
   <ul><li>在数据处理和转换工具中，使用JSqlParser来解析和生成SQL语句，以实现数据的导入和导出。</li></ul></li></ul> 
</blockquote> 
<h2>在Springboot+Mybaits中使用</h2> 
<p><em>如果使用纯原生Mybatis那么我们需要手动在maven中加入Jsqlparser的支持，但如果使用Mybatis plus，那么就无需自己再引用，Mybaits plus自带Jsqlparser</em></p> 
<p>上面举的很多例子都很简单，拿一个SQL语句解析而已，这种情况是手动化的，通常见于单元测试等情况，但如果在项目中想要通过被动的方式，让项目自己去解析SQL语句，就需要分析项目的具体情况，例如在Mybatis中通过Interceptor就可以获得到项目中真正去执行的SQL语句，详见：<a href="https://blog.csdn.net/RudolphLiu/article/details/139311466" title="Mybatis 的 Interceptor（拦截器） 与 JSqlparser 结合解析SQL 使SpringBoot项目多数据库兼容的尝试_mybatis设置jsqlparser-CSDN博客">Mybatis 的 Interceptor（拦截器） 与 JSqlparser 结合解析SQL 使SpringBoot项目多数据库兼容的尝试_mybatis设置jsqlparser-CSDN博客</a></p> 
<p>通过Mybatis的拦截器，我们拿到了项目执行的SQL语句，再通过Jsqlparser去解析，并做一定的处理，例如以上提到的那些实际应用场景</p> 
<h2><strong>高级特性（很实用）</strong></h2> 
<p>Jsqlparser在解析SQL语句的过程中，每一个节点都会被解析成一个叫SimpleNode的对象，它包含着各个节点的属性，这仿佛就像Dom4j解析XML的时候所有的元素都视为Node一样，解析之后的内容都是节点，而循环这些节点，Jsqlparser给出了相应的方法，提供了用于遍历节点的接口CCJSqlParserVisitor，而它的默认实现则是CCJSqlParserDefaultVisitor，在这里创建一个自己的类，并通过继承 CCJSqlParserDefaultVisitor 重写它的 visit 方法，便可以实现自己的策略，更加方便的去操作解析内容</p> 
<pre><code class="language-java">public class SQLModifier extends CCJSqlParserDefaultVisitor {
    @Override
    public Object visit(SimpleNode node, Object data) {
        Object value = node.jjtGetValue();
        switch (node.getId()) {
            case CCJSqlParserTreeConstants.JJTTABLENAME:
                break;
            case CCJSqlParserTreeConstants.JJTCOLUMN:
                break;
            case CCJSqlParserTreeConstants.JJTFUNCTION:
                break;
            default:
                break;
        }
        return super.visit(node, data);
    }
}</code></pre> 
<h3>调用自定义的Visitor</h3> 
<pre><code class="language-java">String originalSql = "select * from user where id = 1";
CCJSqlParser parser = CCJSqlParserUtil.newParser(originalSql);
Statement statement = parser.Statement();
parser.getASTRoot().jjtAccept(sqlTestModifier, null);</code></pre> 
<p>以上代码做了一个自定义的visitor，重写的visit方法中可以看到形参SimpleNode，而调用这个自定义的Visitor之后，语句则会被拆解，依次进入到visit方法中，通过node.jjtGetValue可以获得节点信息，而node.getId()实则是获取节点的类型，而Switch-case中的常量分别代表了在解析SQL语句时，生成的抽象语法树AST （abstract syntax tree）中不同类型的节点，每个节点对应一个特定的SQL构造，如SELECT、FROM、WHERE等。下面是对这些常量代表的SQL构造的简要说明：</p> 
<ul><li><em><span style="background-color:#c7e6ea;">JJTSTATEMENT</span></em>: 代表一个SQL语句。</li><li><em><span style="background-color:#c7e6ea;">JJTVOID</span></em>: 可能代表一个空语句或者不返回结果的语句。</li><li><em><span style="background-color:#c7e6ea;">JJTBLOCK</span></em>: 代表一个语句块，可能包含多个语句。</li><li><em><span style="background-color:#c7e6ea;">JJTSTATEMENTS</span></em>: 代表一个包含多个语句的列表。</li><li><em><span style="background-color:#c7e6ea;">JJTCOLUMN</span></em>: 代表一个列名。</li><li><em><span style="background-color:#c7e6ea;">JJTTABLENAME</span></em>: 代表一个表名。</li><li><em><span style="background-color:#c7e6ea;">JJTSELECT</span></em>: 代表一个SELECT查询。</li><li><em><span style="background-color:#c7e6ea;">JJTPARENTHESEDSELECT</span></em>: 代表被括号包围的SELECT查询。</li><li><em><span style="background-color:#c7e6ea;">JJTLATERALVIEW</span></em>: 代表LATERAL VIEW子句，常用于Hive SQL。</li><li><em><span style="background-color:#c7e6ea;">JJTFORCLAUSE</span></em>: 代表FOR子句。</li><li><em><span style="background-color:#c7e6ea;">JJTLATERALSUBSELECT</span></em>: 代表LATERAL子查询。</li><li><em><span style="background-color:#c7e6ea;">JJTPLAINSELECT</span></em>: 代表一个简单的SELECT查询（不包含UNION等）。</li><li><em><span style="background-color:#c7e6ea;">JJTSETOPERATIONLIST</span></em>: 代表一个集合操作列表，比如UNION, EXCEPT, INTERSECT。</li><li><em><span style="background-color:#c7e6ea;">JJTWITHITEM</span></em>: 代表WITH子句中的单个项。</li><li><em><span style="background-color:#c7e6ea;">JJTSELECTITEM</span></em>: 代表SELECT子句中的一个项，可能是列名、表达式等。</li><li><em><span style="background-color:#c7e6ea;">JJTJOINEREXPRESSION</span></em>: 代表JOIN操作的表达式。</li><li><em><span style="background-color:#c7e6ea;">JJTLIMITWITHOFFSET</span></em>: 代表LIMIT和OFFSET子句。</li><li><em><span style="background-color:#c7e6ea;">JJTPLAINLIMIT</span></em>: 代表一个简单的LIMIT子句。</li><li><em><span style="background-color:#c7e6ea;">JJTEXPRESSION</span></em>: 代表一个表达式。</li><li><em><span style="background-color:#c7e6ea;">JJTREGULARCONDITION</span></em>: 代表一个常规条件（如WHERE子句中的条件）。</li><li><em><span style="background-color:#c7e6ea;">JJTINEXPRESSION</span></em>: 代表IN表达式。</li><li><em><span style="background-color:#c7e6ea;">JJTLIKEEXPRESSION</span></em>: 代表LIKE表达式。</li><li><em><span style="background-color:#c7e6ea;">JJTSIMILARTOEXPRESSION</span></em>: 代表SIMILAR TO表达式。</li><li><em><span style="background-color:#c7e6ea;">JJTISDISTINCTEXPRESSION</span></em>: 代表IS DISTINCT FROM表达式。</li><li><em><span style="background-color:#c7e6ea;">JJTEXPRESSIONLIST</span></em>: 代表一个表达式列表。</li><li><em><span style="background-color:#c7e6ea;">JJTPRIMARYEXPRESSION</span></em>: 代表一个主要表达式。</li><li><em><span style="background-color:#c7e6ea;">JJTCONNECTBYROOTOPERATOR</span></em>: 代表CONNECT BY ROOT操作符。</li><li><em><span style="background-color:#c7e6ea;">JJTCASEWHENEXPRESSION</span></em>: 代表CASE WHEN表达式。</li><li><em><span style="background-color:#c7e6ea;">JJTFUNCTION</span></em>: 代表一个函数调用。</li><li><em><span style="background-color:#c7e6ea;">JJTSEQUENCE</span></em>: 代表一个序列。</li><li><em><span style="background-color:#c7e6ea;">JJTSYNONYM</span></em>: 代表一个同义词。</li></ul> 
<h3>Visit常见应用场景</h3> 
<p>目前我们知道，通过Mybatis 的 interceptor可以拦截到所有执行的SQL语句，而在 自定义的interceptor中调用自定义的visit，就可以对项目中所有运行的SQL做一个拦截并处理，那么具体可以做哪些骚操作呢</p> 
<ol><li> <p><strong>SQL语句重写</strong>： 在某些数据库系统中，为了优化性能或满足特定的需求，可能需要重写SQL语句。通过自定义访问者，可以在AST（abstract syntax tree）层面进行这些操作</p> </li><li> <p><strong>元数据提取</strong>： 自定义访问者可以用来提取SQL语句中的元数据，比如查询涉及的所有表名、列名、函数等，这些信息可以用于构建数据库的概要图或进行数据治理。</p> </li><li> <p><strong>数据屏蔽</strong>： 在需要对敏感数据进行屏蔽的应用中，可以通过自定义访问者来识别并修改涉及敏感数据的查询，以确保在查询结果中不会暴露敏感信息。</p> </li><li> <p><strong>动态查询构建</strong>： 在需要动态构建SQL查询的应用中，可以通过自定义访问者来解析模板SQL语句，并根据实际参数动态替换模板中的占位符，从而构建出完整的SQL语句。</p> </li><li> <p><strong>缓存策略决策</strong>： 根据SQL查询的特征，可以通过自定义访问者来判断查询结果是否适合缓存，以及应该使用什么样的缓存策略。</p> </li></ol> 
<h2><strong>总结</strong></h2> 
<p>Jsqlparser非常容易上手使用，而它也解决了解析SQL语句的问题，结合Springboot 和 mybatis，可以设计自定义插件，就像Mybatis plus的分页插件那样，可以开发自己系统需求的业务处理功能，方便项目业务的时间，甚至可以拿来提高效率，毕竟总有一些时候，对SQL的解析是绕不开的。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2c708cb048c8e396c77791482464b564/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux CentoS安装RabbitMQ：一键安装指南</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a8752fed5f4c831ce4d5d7ce1b4db9f7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">前端新手小白的Vue3入坑指南</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>