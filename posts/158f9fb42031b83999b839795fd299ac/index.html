<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2024.8.26 Python，最大子数和与动态规划，最小路径和，分割回文串，字典序排数，最长重复子数组（动态规划） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/158f9fb42031b83999b839795fd299ac/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="2024.8.26 Python，最大子数和与动态规划，最小路径和，分割回文串，字典序排数，最长重复子数组（动态规划）">
  <meta property="og:description" content="1.最大子数和 接上周的文章：
给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。子数组是数组中的一个连续部分。
示例 1：
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
示例 2：
输入：nums = [1]
输出：1
示例 3：
输入：nums = [5,4,-1,7,8]
输出：23
方法一：
class Solution: def maxSubArray(self,nums:List[int])-&gt;int: tmp=nums[0]	#当前当下的列表和	n=len(nums) res=tmp	#结果 for i in range(1,n): if tmp&#43;nums[i]&gt;nums[i]:	#tmp对nums[i]是有利的，那么就留下tmp res=max(res,tmp&#43;nums[i])	#max的对象是nums[i]&#43;tmp还有res，为什么不需要加tmp是因为判断结束后就已经决定拓展了，res里存了之前的tmp，假如nums[i]是个复数，那么res就胜出了 tmp&#43;=nums[i]	#列表加进nums[i] else:	#说明tmp该丢了	res=max(res,tmp&#43;nums[i],tmp,nums[i])	#在场的各位都最后做一次对比吧最后的波纹了 tmp=nums[i]	#丢了重开 return res 代码逻辑：
这个题为什么不用tmp&#43;nums[i]&gt;tmp来判断，反而是用tmp &#43; nums[i] &gt; nums[i]：
tmp&#43;nums[i]&gt;tmp这个条件只是简单判断加入当前元素是否能让和变大，但它忽略了一个重要情况：如果 nums[i] 本身比 tmp &#43; nums[i] 更大（即当前元素自身的值已经大于累加之前的和），我们就应该重新开始新的子数组，而不是继续扩展之前的子数组。也就是说，添加这个判断的目的不是为了决定要不要nums[i]而是现在要不要tmp也就是说是保留还是新建，是生存还是毁灭问题，tmp如果加了nums[i]比nums[i]还小，那么tmp就该丢了">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-26T21:19:34+08:00">
    <meta property="article:modified_time" content="2024-08-26T21:19:34+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2024.8.26 Python，最大子数和与动态规划，最小路径和，分割回文串，字典序排数，最长重复子数组（动态规划）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="1_0"></a>1.最大子数和</h4> 
<p>接上周的文章：<br> 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。子数组是数组中的一个连续部分。<br> 示例 1：<br> 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br> 输出：6<br> 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。<br> 示例 2：<br> 输入：nums = [1]<br> 输出：1<br> 示例 3：<br> 输入：nums = [5,4,-1,7,8]<br> 输出：23<br> <em><strong>方法一：</strong></em></p> 
<pre><code class="prism language-py"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
	<span class="token keyword">def</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>nums<span class="token punctuation">:</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token builtin">int</span><span class="token punctuation">:</span>
		tmp<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>				<span class="token comment">#当前当下的列表和	</span>
		n<span class="token operator">=</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
		res<span class="token operator">=</span>tmp					<span class="token comment">#结果</span>
		<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
			<span class="token keyword">if</span> tmp<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&gt;</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>				<span class="token comment">#tmp对nums[i]是有利的，那么就留下tmp</span>
				res<span class="token operator">=</span><span class="token builtin">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span>tmp<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>		<span class="token comment">#max的对象是nums[i]+tmp还有res，为什么不需要加tmp是因为判断结束后就已经决定拓展了，res里存了之前的tmp，假如nums[i]是个复数，那么res就胜出了</span>
				tmp<span class="token operator">+=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>					<span class="token comment">#列表加进nums[i]</span>
			<span class="token keyword">else</span><span class="token punctuation">:</span>								<span class="token comment">#说明tmp该丢了	</span>
				res<span class="token operator">=</span><span class="token builtin">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span>tmp<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>tmp<span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>	<span class="token comment">#在场的各位都最后做一次对比吧最后的波纹了</span>
				tmp<span class="token operator">=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>								<span class="token comment">#丢了重开</span>
		<span class="token keyword">return</span> res
</code></pre> 
<p>代码逻辑：<br> 这个题为什么不用tmp+nums[i]&gt;tmp来判断，反而是用tmp + nums[i] &gt; nums[i]：<br> tmp+nums[i]&gt;tmp这个条件只是简单判断加入当前元素是否能让和变大，但它忽略了一个重要情况：如果 nums[i] 本身比 tmp + nums[i] 更大（即当前元素自身的值已经大于累加之前的和），我们就应该重新开始新的子数组，而不是继续扩展之前的子数组。也就是说，添加这个判断的目的不是为了决定要不要nums[i]而是现在要不要tmp也就是说是保留还是新建，是生存还是毁灭问题，tmp如果加了nums[i]比nums[i]还小，那么tmp就该丢了<br> 为什么 tmp + nums[i] &gt; nums[i] 更合理<br> tmp + nums[i] &gt; nums[i] 这个条件能够很好地捕捉到何时应该开始一个新的子数组，因为它考虑了当前元素是否比累积和加上当前元素还要大。<br> <em><strong>方法二</strong></em>动态规划<br> 现在创造一个新的列表，列表中的每一个元素下标和之前的元素一一对应，但是这个列表代表nums[i]为最后一个元素的数组最大和，这个列表名字叫dp的话，那么就有以下的列表：<br> nums=[-2,1,-3,4,-1,2,1,-5,4]<br> dp= [-2,1,-2,4, 3,5,6, 1,5]<br> 这个处理的规律是，dp[i]=max(dp[i-1]+nums[i],nums[i])这样处理之后找dp的最大值即可<br> 代码如下：</p> 
<pre><code class="prism language-py"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>nums<span class="token punctuation">:</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token builtin">int</span><span class="token punctuation">:</span>
        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            dp<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token builtin">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span>
</code></pre> 
<p>也就是说上面所谓的暴力法其实就是动态规划</p> 
<h4><a id="2_50"></a>2.最小路径和</h4> 
<p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。<br> 说明：每次只能向下或者向右移动一步。<br> 输入：grid = [[1,3,1],[1,5,1],[4,2,1]]<br> 输出：7<br> 解释：因为路径 1→3→1→1→1 的总和最小。<br> 示例 2：<br> 输入：grid = [[1,2,3],[4,5,6]]<br> 输出：12<br> <em><strong>方法一：</strong></em></p> 
<pre><code class="prism language-py"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">minPathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grid<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        nr<span class="token operator">=</span><span class="token builtin">len</span><span class="token punctuation">(</span>grid<span class="token punctuation">)</span>
        nc<span class="token operator">=</span><span class="token builtin">len</span><span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        sums<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span>c<span class="token punctuation">,</span>sums<span class="token punctuation">)</span><span class="token punctuation">:</span> 
            sums<span class="token operator">+=</span>grid<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span>           
            <span class="token keyword">if</span> r<span class="token operator">==</span>nr<span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">and</span> c<span class="token operator">==</span>nc<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>
                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>sums<span class="token punctuation">)</span>
                <span class="token keyword">return</span> 
            <span class="token keyword">if</span> r<span class="token operator">!=</span>nr<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>
                dfs<span class="token punctuation">(</span>r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>c<span class="token punctuation">,</span>sums<span class="token punctuation">)</span>
            <span class="token keyword">if</span> c<span class="token operator">!=</span>nc<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>
                dfs<span class="token punctuation">(</span>r<span class="token punctuation">,</span>c<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>sums<span class="token punctuation">)</span>
        dfs<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>sums<span class="token punctuation">)</span> 
        <span class="token keyword">return</span> <span class="token builtin">min</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
</code></pre> 
<p>深度优先搜索的写法，这是我自己写出来的办法，蠢但是能解决一定的问题，但是最后还是超时了，所以不推荐。<br> ***方法二：***动态规划<br> 上一个题中的dp[i]为一维的，而这次的dp变成了二维的，所谓动态规划就是说，我们在计算的过程中可以不需要从头再来计算一次，我们可以通过前人的经验来去总结规律，比如青蛙跳高问题，青蛙可以一次跳两个也可以一次跳一格，那么他跳到第n个格有多少种可能的跳法，我们就是要找到一些规律来去总结这个问题，比如现在就只有abcd四格，那么从a到b有一种，a到c有两种，那么a到d就有2+1=3种，那么a到e就是a到d加a到c。以此类推<br> 也就是说我们要找到dp之间的规律，在跳青蛙这个题中dp的规律就是dp[n]=dp[n-1]+dp[n-2]</p> 
<pre><code class="prism language-py"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">minPathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>grid<span class="token punctuation">:</span>List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token builtin">int</span><span class="token punctuation">:</span>
        nr<span class="token operator">=</span><span class="token builtin">len</span><span class="token punctuation">(</span>grid<span class="token punctuation">)</span>
        nc<span class="token operator">=</span><span class="token builtin">len</span><span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        dp<span class="token operator">=</span>grid
        <span class="token keyword">for</span> r <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>nr<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> c <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>nc<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> r<span class="token operator">==</span><span class="token number">0</span> <span class="token keyword">and</span> c<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">continue</span>
                <span class="token keyword">if</span> r<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span>
                <span class="token keyword">elif</span> c<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>  dp<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>r<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>grid<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>       dp<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token operator">=</span><span class="token builtin">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>r<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span>grid<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>nr<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>nc<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        
</code></pre> 
<p>逻辑就是，到达当前框的最小值，等于到达当前框的上方的框的最小值，和到达当前框的左边的框的最小值相比较，谁小谁加当前框的值。动态规划看不懂的就去CSDN搜动态规划出来的第一篇文章。</p> 
<h4><a id="3_98"></a>3.分割回文串</h4> 
<p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是<br> 回文串 。返回 s 所有可能的分割方案。</p> 
<pre><code class="prism language-py"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
        f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">True</span><span class="token punctuation">]</span> <span class="token operator">*</span> n <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>

        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
                f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">and</span> f<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>

        ret <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        ans <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> i <span class="token operator">==</span> n<span class="token punctuation">:</span>
                ret<span class="token punctuation">.</span>append<span class="token punctuation">(</span>ans<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span>
            
            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
                    ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">:</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
                    dfs<span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
                    ans<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>

        dfs<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> ret
</code></pre> 
<p>代码逻辑：<br> 讲道理，我这道题几乎完全没有看懂，这个题的逻辑太绕了，我将尽可能的把我的理解写出来，首先是两个for循环，这里的i是起始，j是终止，如果最后判断下来，将是一个左下的三角矩阵有变化，右上包括对角的元素都是True。ret是最后的结果，ans是小列表，dfs我理解的事以i为起始开始分割，遇见合适的就append，然后再下一个，我感觉这个代码我打死都自己写不出来。</p> 
<h4><a id="4_130"></a>4.字典序排数</h4> 
<p>给你一个整数 n ，按字典序返回范围 [1, n] 内所有整数。<br> 你必须设计一个时间复杂度为 O(n) 且使用 O(1) 额外空间的算法。<br> 示例 1：<br> 输入：n = 13<br> 输出：[1,10,11,12,13,2,3,4,5,6,7,8,9]<br> 示例 2：<br> 输入：n = 2<br> 输出：[1,2]</p> 
<pre><code class="prism language-py"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">lexicalOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
    	ans<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>n
    	nums<span class="token operator">=</span><span class="token number">1</span>
    	<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    		ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>nums
    		<span class="token keyword">if</span> nums<span class="token operator">*</span><span class="token number">10</span><span class="token operator">&lt;=</span>n<span class="token punctuation">:</span>
    			nums<span class="token operator">*=</span><span class="token number">10</span>
    		<span class="token keyword">else</span><span class="token punctuation">:</span>
    			<span class="token keyword">while</span> nums<span class="token operator">%</span><span class="token number">10</span><span class="token operator">==</span><span class="token number">9</span> <span class="token keyword">or</span> nums<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&gt;</span>n<span class="token punctuation">:</span>
    				nums<span class="token operator">//=</span><span class="token number">10</span>
    			nums<span class="token operator">+=</span><span class="token number">1</span>
    	<span class="token keyword">return</span> ans
</code></pre> 
<p>逆天顺序，代码就是这么个代码，也没啥好说的，就有10就乘10，没十就判断尾数是不是9或者nums+1就超，地板除10+1，进入下一次循环<br> 方法二：dfs，难想</p> 
<pre><code class="prism language-py"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">lexicalOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> k<span class="token operator">&lt;=</span>n<span class="token punctuation">:</span>
                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>k<span class="token punctuation">)</span>
                k<span class="token operator">=</span><span class="token number">10</span><span class="token operator">*</span>k
                <span class="token keyword">if</span> k<span class="token operator">&lt;=</span>n<span class="token punctuation">:</span>
                    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#目的是为了在下一层应用字典排序</span>
                        dfs<span class="token punctuation">(</span>k<span class="token operator">+</span>i<span class="token punctuation">,</span>res<span class="token punctuation">)</span>
        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            dfs<span class="token punctuation">(</span>i<span class="token punctuation">,</span>res<span class="token punctuation">)</span>
        <span class="token keyword">return</span> res
</code></pre> 
<p>这个更能体现字典的排序的方法，i=1，那就是1的字典，重点在于这个k+i，不是+1哦<br> 方法三：</p> 
<pre><code class="prism language-py"><span class="token keyword">return</span> <span class="token builtin">sorted</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token builtin">str</span><span class="token punctuation">)</span>
</code></pre> 
<p>这样就已经够了</p> 
<h4><a id="5_177"></a>5.最长重复子数组</h4> 
<p>提示<br> 给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。<br> 示例 1：<br> 输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]<br> 输出：3<br> 解释：长度最长的公共子数组是 [3,2,1] 。<br> 示例 2：<br> 输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]<br> 输出：5</p> 
<pre><code class="prism language-py"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">findLength</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums1<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        m<span class="token punctuation">,</span>n<span class="token operator">=</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums2<span class="token punctuation">)</span>
        dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>				<span class="token comment">#最后算下来是第一层没在循环中用上</span>
        ans<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> nums1<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>nums2<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span>				<span class="token comment">#第一层设定的目的是为了在这一步的dp[i-1][j-1]有数字</span>
                    ans<span class="token operator">=</span><span class="token builtin">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> ans
</code></pre> 
<p>这个题给我做火了，为什么要用i-1和j-1我想不来，我照着抄完我肯定能理解为啥，但是这个题我完全不能想明白，等我自己做的时候会是什么样子，我完全不会想到j-1和i-1的事情。<br> 代码逻辑：<br> 1.dp比mn多一层<br> 2.for循环里，i和j其实是dp的下标，不是nums的下标，所以要减一，他把nums的i-1等于j-1的时候，的长度存进了dp[i][j]里，所以他的范围是dp[m][n]存了最后一个数字。<br> 方法二：滑动窗口</p> 
<pre><code class="prism language-py"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
	<span class="token keyword">def</span> <span class="token function">findLength</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span>B<span class="token punctuation">:</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token builtin">int</span><span class="token punctuation">:</span>
		<span class="token keyword">def</span> <span class="token function">maxLength</span><span class="token punctuation">(</span>addA<span class="token punctuation">:</span><span class="token builtin">int</span><span class="token punctuation">,</span>addB<span class="token punctuation">:</span><span class="token builtin">int</span><span class="token punctuation">,</span>length<span class="token punctuation">:</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token builtin">int</span><span class="token punctuation">:</span>
			ret<span class="token operator">=</span>k<span class="token operator">=</span><span class="token number">0</span>
			<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">:</span>
				<span class="token keyword">if</span> A<span class="token punctuation">[</span>addA<span class="token operator">+</span>i<span class="token punctuation">]</span><span class="token operator">==</span>B<span class="token punctuation">[</span>addB<span class="token operator">+</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
					k<span class="token operator">+=</span><span class="token number">1</span>
					ret<span class="token operator">=</span><span class="token builtin">max</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span>k<span class="token punctuation">)</span>
				<span class="token keyword">else</span><span class="token punctuation">:</span>
					k<span class="token operator">=</span><span class="token number">0</span>
			<span class="token keyword">return</span> ret

		n<span class="token punctuation">,</span>m<span class="token operator">=</span><span class="token builtin">len</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span>
		ret<span class="token operator">=</span><span class="token number">0</span>
		<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
			length<span class="token operator">=</span><span class="token builtin">min</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span>n<span class="token operator">-</span>i<span class="token punctuation">)</span>
			ret<span class="token operator">=</span><span class="token builtin">max</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span>maxLength<span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>
			length<span class="token operator">=</span><span class="token builtin">min</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>m<span class="token operator">-</span>i<span class="token punctuation">)</span>
			ret<span class="token operator">=</span><span class="token builtin">max</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span>maxLength<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> ret
</code></pre> 
<p>完全看不懂</p> 
<h4><a id="6_229"></a>6.最短的桥</h4> 
<p>给你一个大小为 n x n 的二元矩阵 grid ，其中 1 表示陆地，0 表示水域。<br> 岛 是由四面相连的 1 形成的一个最大组，即不会与非组内的任何其他 1 相连。grid 中 恰好存在两座岛 。<br> 你可以将任意数量的 0 变为 1 ，以使两座岛连接起来，变成 一座岛 。<br> 返回必须翻转的 0 的最小数目。<br> 示例 1：<br> 输入：grid = [[0,1],[1,0]]<br> 输出：1<br> 示例 2：<br> 输入：grid = [[0,1,0],[0,0,0],[0,0,1]]<br> 输出：2<br> 示例 3：<br> 输入：grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]<br> 输出：1<br> 方法一：广度优先搜索</p> 
<pre><code class="prism language-py"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
	<span class="token keyword">def</span> <span class="token function">shortestBridge</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>grid<span class="token punctuation">:</span>List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">&gt;</span><span class="token builtin">int</span><span class="token punctuation">:</span>
		n<span class="token operator">=</span><span class="token builtin">len</span><span class="token punctuation">(</span>grid<span class="token punctuation">)</span>
		<span class="token keyword">for</span> i<span class="token punctuation">,</span>row <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token punctuation">:</span>
			<span class="token keyword">for</span> j<span class="token punctuation">,</span>v <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">:</span>
				<span class="token keyword">if</span> v<span class="token operator">!=</span><span class="token number">1</span><span class="token punctuation">:</span>
					<span class="token keyword">continue</span>
				island<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
				grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span>
				q<span class="token operator">=</span>deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">#双端队列，里边是列表，列表里是元组</span>
				<span class="token keyword">while</span> q<span class="token punctuation">:</span>
					x<span class="token punctuation">,</span>y<span class="token operator">=</span>q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
					island<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span>
					<span class="token keyword">for</span> nx<span class="token punctuation">,</span>ny <span class="token keyword">in</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
						<span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>nx<span class="token operator">&lt;</span>n <span class="token keyword">and</span> <span class="token number">0</span><span class="token operator">&lt;=</span>ny<span class="token operator">&lt;</span>n <span class="token keyword">and</span> grid<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>
							grid<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span>
							q<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>nx<span class="token punctuation">,</span>ny<span class="token punctuation">)</span><span class="token punctuation">)</span>
				step <span class="token operator">=</span> <span class="token number">0</span>
                q <span class="token operator">=</span> island
                <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
                    tmp <span class="token operator">=</span> q
                    q <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
                    <span class="token keyword">for</span> x<span class="token punctuation">,</span> y <span class="token keyword">in</span> tmp<span class="token punctuation">:</span>
                        <span class="token keyword">for</span> nx<span class="token punctuation">,</span> ny <span class="token keyword">in</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                            <span class="token keyword">if</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> nx <span class="token operator">&lt;</span> n <span class="token keyword">and</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> ny <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>
                                <span class="token keyword">if</span> grid<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
                                    <span class="token keyword">return</span> step
                                <span class="token keyword">if</span> grid<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
                                    grid<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>
                                    q<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>nx<span class="token punctuation">,</span> ny<span class="token punctuation">)</span><span class="token punctuation">)</span>
                    step <span class="token operator">+=</span> <span class="token number">1</span>
</code></pre> 
<p>这个代码不需要判断step就可以直接最短，是因为，广度优先搜索就是一层一层的在找，所以一层一层的找一定能找到一个最近的岛屿，所以这个代码一定要学习</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1cea039e4aca0a74693208e0f44fe602/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">15：00面试，15：06就出来了，问的问题有点变态。。。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a6c9fb6667b1e037d128cc40299ccfcc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vue开发者工具安装详细教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>