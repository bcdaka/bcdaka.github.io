<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>栈的详解和例题（力扣有效括号） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/7fff91553a52e06d5c95478c0b38a6f4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="栈的详解和例题（力扣有效括号）">
  <meta property="og:description" content="感谢各位大佬的光临，希望和大家一起进步，望得到你的三连，互三支持，一起进步
个人主页：LaNzikinh-CSDN博客
收入专栏:初阶数据结构_LaNzikinh篮子的博客-CSDN博客
文章目录 前言一.什么是栈二.栈的实现三.例题（力扣）总代码 前言 之前讲了，很多关于栈的习题，还有栈与队列的互相转换，还是补一篇栈的详解
一.什么是栈 栈（stack）是一种只允许在一端进行插入和删除操作的线性表。这一端称为栈顶，另一端称为栈底。栈的特点是后进先出（LIFO），即最后进入的元素最先出来。栈可以用来存储局部变量和一些数据，当函数或线程执行完毕，栈就会释放空间。
二.栈的实现 这样的实现它分为两种，一种是用数组去实现栈，另一种就是用链表去实现栈，我们这里主要讲的是用数组去实现栈，用链表实现栈又叫做链式栈，如果用尾做为栈顶那么尾插尾删就要设计成双向链表，否则删除数据效率会很低。
2.1结构 注意：初始化时把top=0的话，top可以看成有栈中的元素总数，不是栈顶的元素下标！！ typedef int STDataType; typedef struct stack { STDataType* a; int top; int capacity }ST; 其实就可以把它看成一个顺序表，top就是size的意思，它用来控制栈顶的元素的 2.2初始化 初始化时，top给的是0的话，意味着top栈顶数据的指向下一个，top给-1的话，意味着top就是栈顶数据
void stackInit(ST* ps) { assert(ps); ps-&gt;a = NULL; ps-&gt;top = 0;//ps-&gt;top=-1; ps-&gt;capacity = 0; } 2.3放入数据 这里和顺序表的扩容和插入一模一样
void stackPush(ST* ps, STDataType x) { assert(ps); //检查扩容 if (ps-&gt;top == ps-&gt;capacity) { int newcapacity = ps-&gt;capacity == 0 ? 4 : ps-&gt;capacity * 2; STDataType* tmp = (STDataType*)realloc(ps-&gt;a,sizeof(STDataType) * newcapacity); assert(tmp); ps-&gt;a = tmp; ps-&gt;capacity = newcapacity; } ps-&gt;a[ps-&gt;top] = x; ps-&gt;top&#43;&#43;; } 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-06T22:19:57+08:00">
    <meta property="article:modified_time" content="2024-04-06T22:19:57+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">栈的详解和例题（力扣有效括号）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <h2><a id="_0"></a></h2> 
 <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/8a/4e/ntohyDXt_o.gif"></p> 
 <p>感谢各位大佬的光临，希望和大家一起进步，望得到你的三连，互三支持，一起进步</p> 
 <p><a href="https://so.csdn.net/so/search?q=%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5&amp;spm=1001.2101.3001.7020" title="个人主页">个人主页</a>：<a href="https://blog.csdn.net/2301_80344616?type=blog" title="LaNzikinh-CSDN博客">LaNzikinh-CSDN博客</a></p> 
 <p><a href="https://blog.csdn.net/2301_80344616/category_12630868.html" title="收入专栏:初阶数据结构_LaNzikinh篮子的博客-CSDN博客">收入专栏:初阶数据结构_LaNzikinh篮子的博客-CSDN博客</a></p> 
 <p></p> 
</blockquote> 
<div> 
 <h4 style="background-color:transparent;">文章目录</h4> 
 <ul><li><a href="#_12" rel="nofollow">前言</a></li><li><strong>一.什么是栈</strong></li><li><strong>二.栈的实现</strong></li><li><strong>三.例题（力扣）</strong></li><li><strong>总代码</strong></li></ul> 
</div> 
<hr> 
<h2><a id="_12"></a>前言</h2> 
<p><strong>之前讲了，很多关于栈的习题，还有栈与队列的互相转换，还是补一篇栈的详解</strong></p> 
<hr> 
<h2><strong style="color:#4f4f4f;font-size:24px;font-weight:bold;">一.什么是栈</strong></h2> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/13/16/HDwvaFra_o.jpg"></p> 
<blockquote> 
 <p><strong>栈（stack）是一种只允许在一端进行插入和删除操作的线性表。这一端称为栈顶，另一端称为栈底。栈的特点是后进先出（LIFO），即最后进入的元素最先出来。栈可以用来存储局部变量和一些数据，当函数或线程执行完毕，栈就会释放空间。</strong></p> 
</blockquote> 
<h2 style="background-color:transparent;">二.栈的实现</h2> 
<blockquote> 
 <p><strong>这样的实现它分为两种，一种是用数组去实现栈，另一种就是用链表去实现栈，我们这里主要讲的是用数组去实现栈，用链表实现栈又叫做链式栈，如果用尾做为栈顶那么尾插尾删就要设计成双向链表，否则删除数据效率会很低。</strong></p> 
</blockquote> 
<h3>2.1结构</h3> 
<h3><strong><span style="color:#fe2c24;">注意：初始化时把top=0的话，top可以看成有栈中的元素总数，不是栈顶的元素下标！！</span></strong></h3> 
<p style="text-align:center;"><img alt="" height="360" src="https://images2.imgbox.com/fe/a9/83FsTyIj_o.png" width="400"></p> 
<pre><code class="language-cpp">typedef int STDataType;
typedef struct stack
{
	STDataType* a;
	int top;
	int capacity
}ST;</code></pre> 
<h3>其实就可以把它看成一个顺序表，top就是size的意思，它用来控制栈顶的元素的</h3> 
<h3>2.2初始化</h3> 
<blockquote> 
 <p><strong>初始化时，top给的是0的话，意味着top栈顶数据的指向下一个，top给-1的话，意味着top就是栈顶数据</strong></p> 
</blockquote> 
<pre><code class="language-cpp">void stackInit(ST* ps)
{
	assert(ps);
	ps-&gt;a = NULL;
	ps-&gt;top = 0;//ps-&gt;top=-1;
	ps-&gt;capacity = 0;
}</code></pre> 
<h3>2.3放入数据</h3> 
<blockquote> 
 <p><strong>这里和顺序表的扩容和插入一模一样</strong></p> 
</blockquote> 
<pre><code class="language-cpp">void stackPush(ST* ps, STDataType x)
{
	assert(ps);
	//检查扩容
	if (ps-&gt;top == ps-&gt;capacity)
	{
		int newcapacity = ps-&gt;capacity == 0 ? 4 : ps-&gt;capacity * 2;
		STDataType* tmp = (STDataType*)realloc(ps-&gt;a,sizeof(STDataType) * newcapacity);
		assert(tmp);
		ps-&gt;a = tmp;
		ps-&gt;capacity = newcapacity;
	  }
	ps-&gt;a[ps-&gt;top] = x;
	ps-&gt;top++;

}</code></pre> 
<h3> 2.4删数据和取栈顶元素</h3> 
<blockquote> 
 <p><strong>我初始化的top为0，所以取栈顶元素的下标是top-1</strong></p> 
</blockquote> 
<pre><code class="language-cpp">void stackPop(ST* ps)
{
	assert(ps);
	assert(ps-&gt;top &gt; 0);
	ps-&gt;top--;
}

STDataType stackTop(ST* ps)
{
	assert(ps);
	assert(ps-&gt;top &gt; 0);
	//我初始化的top为0，所以取栈顶元素的下标是top-1
	return ps-&gt;a[ps-&gt;top -1 ];
}</code></pre> 
<h3>2.5检查栈中还要元素和释放</h3> 
<pre><code class="language-cpp">bool stackEmpty(ST* ps)
{
	assert(ps);
//说明栈里没有元素了
	if (ps-&gt;top == 0)
		return true;
	else
		return false;
}
void stackDestroy(ST* ps)
{
	assert(ps);
	free(ps-&gt;a);
	ps-&gt;a = NULL;
	ps-&gt;capacity = ps-&gt;top = 0;
}</code></pre> 
<p><strong>然后我们来看一道例题</strong></p> 
<h2 style="background-color:transparent;">三.例题（力扣）</h2> 
<blockquote> 
 <p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p> 
 <p>有效字符串需满足：</p> 
 <ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol> 
 <p><strong>示例 1：</strong></p> 
 <pre><strong>输入：</strong>s = "()"
<strong>输出：</strong>true
<strong>输入：</strong>s = "(]"
<strong>输出：</strong>false</pre> 
 <p><a href="https://leetcode.cn/problems/valid-parentheses/description/" rel="nofollow" title="20. 有效的括号 - 力扣（LeetCode）">20. 有效的括号 - 力扣（LeetCode）</a></p> 
</blockquote> 
<h3>思路:<span style="color:#fe2c24;"><strong>利用栈算法先搭建一个栈，然后我们先让左括号入栈，在让左括号出栈和右括号匹配</strong></span></h3> 
<h3>注意:<span style="color:#fe2c24;">因为如果用C语言去写，c语言中的库没有栈的，所以必须自己搭建一个栈，就是我们上面写的</span></h3> 
<h3>3.1</h3> 
<blockquote> 
 <p><strong>我们先断言一下传来的不能是空指针，然后对栈进行初始化，然后设置一个循环，意思是说等这个字符串走完了之后这个循环就出了，第一步判断我们先得让左括号入栈，如果是左括号的就入栈，然后字符串加加</strong></p> 
</blockquote> 
<pre><code class="language-cpp">assert(s);
ST st;
stackInit(&amp;st);
while (*s)
{
	if (*s == '(' || *s == '{' || *s == '[')
	{
		stackPush(&amp;st, *s);
		s++;
	}</code></pre> 
<h3>3.2</h3> 
<blockquote> 
 <p><strong>然后如果不是左括号我们就可以进行第一次判断了，如果遇到了右括号，但是栈里没有数据，说明前面没有右括号不匹配，我们直接退出，如果不是这个错误的话，我们就可以取栈顶元素，把这个括号取出来删掉，然后进行左括号匹配，如果不是就直接退出，注意:stackDestroy(&amp;st)</strong><span style="color:#fe2c24;">;<strong>为什么我要提前放不在后面放，因为我在这里就退出了存在开屏内存没有释放会造成内存泄露。</strong></span></p> 
</blockquote> 
<pre><code class="language-cpp">else
{
	if (stackEmpty(&amp;st))
	{
		return false;
	}
	STDataType top = stackTop(&amp;st);
	stackPop(&amp;st);
	if ((*s == ')' &amp;&amp; top != '(') || (*s == '}' &amp;&amp; top != '{') || (*s == ']' &amp;&amp; top != '['))
	{
		stackDestroy(&amp;st);
		return false;
	}
	else {
		s++;
	}

}</code></pre> 
<h2>3.3</h2> 
<blockquote> 
 <p><strong>如果只有左括号没有右括号呢，所以我的结尾判断还需要特殊一点，如果栈里还有元素的话就说明还存在左括号没有出去没有匹配，所以我也不能返回正确</strong></p> 
</blockquote> 
<pre><code class="language-cpp">bool ret = stackEmpty(&amp;st);
stackDestroy(&amp;st);
return ret;</code></pre> 
<h2 style="background-color:transparent;">总代码</h2> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>注意这个题目是符号判断，所以我的STDataType是char类型的</strong></span></p> 
</blockquote> 
<pre><code class="language-cpp">typedef char STDataType;
typedef struct stack
{
	STDataType* a;
	int top;
	int capacity;
}ST;

void stackInit(ST* ps)
{
	assert(ps);
	ps-&gt;a = NULL;
	ps-&gt;top = 0;
	ps-&gt;capacity = 0;
}

void stackPush(ST* ps, STDataType x)
{
	assert(ps);
	//检查扩容
	if (ps-&gt;top == ps-&gt;capacity)
	{
		int newcapacity = ps-&gt;capacity == 0 ? 4 : ps-&gt;capacity * 2;
		STDataType* tmp = (STDataType*)realloc(ps-&gt;a, sizeof(STDataType) * newcapacity);
		assert(tmp);
		ps-&gt;a = tmp;
		ps-&gt;capacity = newcapacity;
	}
	ps-&gt;a[ps-&gt;top] = x;
	ps-&gt;top++;

}

void stackDestroy(ST* ps)
{
	assert(ps);
	free(ps-&gt;a);
	ps-&gt;a = NULL;
	ps-&gt;capacity = ps-&gt;top = 0;
}

void stackPop(ST* ps)
{
	assert(ps);
	assert(ps-&gt;top &gt; 0);
	ps-&gt;top--;
}

STDataType stackTop(ST* ps)
{
	assert(ps);
	assert(ps-&gt;top &gt; 0);
	return ps-&gt;a[ps-&gt;top - 1];
}

bool stackEmpty(ST* ps)
{
	assert(ps);
	if (ps-&gt;top == 0)
		return true;
	else
		return false;
}
bool isValid(char* s)
{
	assert(s);
	ST st;
	stackInit(&amp;st);
	while (*s)
	{
		if (*s == '(' || *s == '{' || *s == '[')
		{
			stackPush(&amp;st, *s);
			s++;
		}
		else
		{
			if (stackEmpty(&amp;st))
			{
				return false;
			}
			STDataType top = stackTop(&amp;st);
			stackPop(&amp;st);
			if ((*s == ')' &amp;&amp; top != '(') || (*s == '}' &amp;&amp; top != '{') || (*s == ']' &amp;&amp; top != '['))
			{
				stackDestroy(&amp;st);
				return false;
			}
			else {
				s++;
			}

		}

	}

	bool ret = stackEmpty(&amp;st);
	stackDestroy(&amp;st);
	return ret;

}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9624819000568d2d0b786b7814b8b48b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【数据库】国产达梦数据库与mysql特点、区别、发展前景</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d2e4341e3ef6b641c0e5a888b3e90185/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【热门话题】Stable Diffusion：本地部署教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>