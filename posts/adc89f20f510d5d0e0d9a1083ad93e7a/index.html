<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>模板初阶【C&#43;&#43;】 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/adc89f20f510d5d0e0d9a1083ad93e7a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="模板初阶【C&#43;&#43;】">
  <meta property="og:description" content="文章目录 模板的作用模板的原理模板分为两大类——函数模板和类模板函数模板语法函数模板实例化模板函数的方式模板函数的类型转换既有函数模板又有已经实现的函数，会优先调用哪一个？ 类模板语法模板类实例化对象模板类的模板参数可以有缺省值类模板中的成员函数全函数模板模板类中的成员函数声明和定义分离 模板的作用 模板的主要作用是实现泛型编程，泛型编程即编写与类型无关的通用代码，是代码复用的一种手段
模板就是泛型编程的基础。
例
我们经常使用的交换函数就可以使用泛型编程来进行编写，这样可以大大减少重复的代码
一般编写方式
可以发现上图的三个函数除了参数类型不一样，其他的都是一样的重复的代码太多了，这个时候就可以考虑使用模板进行编写了
模板编写方式：
此时编译器就可以根据类型的不同实例化出不同的函数
模板的原理 模板就如其名字一样，就像一个冰棍模具，把不同的果汁（类型）放进去就可以得到不同口味的冰棍，但是这些冰棍就只有口味不同，外形（代码逻辑）都是一样的。
如下图
在编译器编译阶段，对于模板的使用，编译器会根据传入的实参类型来推演生成对应类型的函数以供
调用。
模板分为两大类——函数模板和类模板 函数模板 语法 template &lt; typename/class T(自定义类型名)， typename/class T，………&gt;
函数模板定义
例
函数模板实例化模板函数的方式 只传实参（隐式调用）[让编译器自己根据实参类型推]
既传实参又传类型（显示调用）[即自己指定模板使用的类型]
必须显式传类型的场景
即仅靠实参推演出的类型不够
例
此时就必须显式传类型
当模板类型个数和实参个数不同时，可能会类型不明
例
此时有3个解决方法
对实参进行强制类型转换
即 把函数调用方式改为： Add（a，（int）c）或者 Add((char) a,c），让参数类型统一。
显式传递模板参数
即 把函数调用方式改为Add&lt;int&gt;（a，c）或者Add&lt;char&gt;（a，c），让编译器知道模板参数是什么，先实例化出对应的函数之后，再传入实参，此时实参就会自动进行隐式类型转换
增加模板参数个数到于实参个数匹配
即
模板函数的类型转换 使用实参类型推导模板参数时（隐式调用），不能隐式类型转换
显式调用时可以隐式类型转换
既有函数模板又有已经实现的函数，会优先调用哪一个？ 例如下图这种情况：
此时分3种情况
如果调用普通函数不会发生类型转换，那就调用已经存在的普通函数
如果调用普通函数会发生类型转换，而调用函数模板实例化的模板函数不会发生类型转换时，就调用模板函数
如果都会发生类型转换，就调用已经存在的普通函数
类模板 语法 template &lt; typename/class T(自定义类型名)， typename/class T，………&gt;
模板类的定义
例
模板类实例化对象 模板类实例化对象时只能显式传类型">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-23T13:07:24+08:00">
    <meta property="article:modified_time" content="2024-06-23T13:07:24+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">模板初阶【C&#43;&#43;】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li>模板的作用</li><li>模板的原理</li><li>模板分为两大类——函数模板和类模板</li><li><ul><li>函数模板</li><li><ul><li>语法</li><li>函数模板实例化模板函数的方式</li><li>模板函数的类型转换</li><li>既有函数模板又有已经实现的函数，会优先调用哪一个？</li></ul> 
   </li><li>类模板</li><li><ul><li>语法</li><li>模板类实例化对象</li><li>模板类的模板参数可以有缺省值</li><li>类模板中的成员函数全函数模板</li><li>模板类中的成员函数声明和定义分离</li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>模板的作用</h2> 
<p>模板的主要作用是实现<code>泛型编程</code>，泛型编程即<mark>编写与类型无关的通用代码，是代码复用的一种手段</mark><br> 模板就是泛型编程的基础。</p> 
<p>例<br> 我们经常使用的交换函数就可以使用泛型编程来进行编写，这样可以大大减少重复的代码</p> 
<p>一般编写方式<br> <img src="https://images2.imgbox.com/67/73/xPMWNdXj_o.png" alt="在这里插入图片描述"><br> 可以发现上图的三个函数<mark>除了参数类型不一样，其他的都是一样的</mark>重复的代码太多了，这个时候就可以考虑使用模板进行编写了</p> 
<hr> 
<p>模板编写方式：<br> <img src="https://images2.imgbox.com/4e/e7/vycLbkj5_o.png" alt="在这里插入图片描述"><br> 此时编译器就<mark>可以根据类型的不同实例化出不同的函数</mark></p> 
<hr> 
<h2><a id="_19"></a>模板的原理</h2> 
<p>模板就如其名字一样，就像一个冰棍模具，把不同的果汁（类型）放进去就可以得到不同口味的冰棍，但是这些冰棍就只有口味不同，外形（代码逻辑）都是一样的。</p> 
<p>如下图<br> <img src="https://images2.imgbox.com/1e/0c/s5cJKHok_o.png" alt="在这里插入图片描述"><br> 在<code>编译器编译阶段</code>，对于模板的使用，<mark>编译器会根据传入的实参类型来推演生成对应类型的函数以供<br> 调用。</mark></p> 
<hr> 
<h2><a id="_29"></a>模板分为两大类——函数模板和类模板</h2> 
<h3><a id="_31"></a>函数模板</h3> 
<h4><a id="_32"></a>语法</h4> 
<p><mark>template &lt; typename/class T(自定义类型名)， typename/class T，………&gt;<br> 函数模板定义</mark></p> 
<p>例<br> <img src="https://images2.imgbox.com/bc/9b/hlpPZOB6_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h4><a id="_42"></a>函数模板实例化模板函数的方式</h4> 
<ol><li> <p>只传实参（隐式调用）[<mark>让编译器自己根据实参类型推</mark>]<br> <img src="https://images2.imgbox.com/fb/64/WzWZYjtb_o.png" alt="在这里插入图片描述"></p> </li><li> <p>既传实参又传类型（显示调用）[<mark>即自己指定模板使用的类型</mark>]<br> <img src="https://images2.imgbox.com/2e/e8/c3JOYdUI_o.png" alt="在这里插入图片描述"></p> </li></ol> 
<p><mark>必须<code>显式传类型</code>的场景</mark></p> 
<p><mark>即仅靠实参推演出的类型<code>不够</code></mark></p> 
<p>例<br> <img src="https://images2.imgbox.com/f2/b2/5cnBhvIf_o.png" alt="在这里插入图片描述"><br> 此时就必须显式传类型<br> <img src="https://images2.imgbox.com/6a/45/LHmlrIRn_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p><mark>当模板类型个数和实参个数不同时，可能会类型不明</mark></p> 
<p>例<br> <img src="https://images2.imgbox.com/b5/cd/k0AUUHIB_o.png" alt="在这里插入图片描述"><br> 此时有3个解决方法</p> 
<ol><li> <p>对实参进行强制类型转换<br> 即 把函数调用方式改为： <code>Add（a，（int）c）</code>或者 <code>Add((char) a,c）</code>，让参数类型统一。</p> </li><li> <p>显式传递模板参数<br> 即 把函数调用方式改为<code>Add&lt;int&gt;（a，c）</code>或者Add<code>&lt;char&gt;（a，c）</code>，让编译器知道模板参数是什么，<mark>先实例化出对应的函数之后</mark>，再传入实参，<mark>此时实参就会自动进行隐式类型转换</mark></p> </li><li> <p>增加模板参数个数到于实参个数匹配<br> 即<br> <img src="https://images2.imgbox.com/4a/8c/bLkZp5sn_o.png" alt="在这里插入图片描述"></p> </li></ol> 
<hr> 
<h4><a id="_80"></a>模板函数的类型转换</h4> 
<p>使用实参类型推导模板参数时（<mark>隐式调用</mark>），<code>不能</code>隐式类型转换</p> 
<p>显式调用时<code>可以</code>隐式类型转换</p> 
<hr> 
<h4><a id="_89"></a>既有函数模板又有已经实现的函数，会优先调用哪一个？</h4> 
<p>例如下图这种情况：<br> <img src="https://images2.imgbox.com/06/a5/dmXEpo8S_o.png" alt="在这里插入图片描述"></p> 
<p>此时分3种情况</p> 
<ol><li> <p>如果调用普通函数<code>不会发生类型转换</code>，那就调用已经存在的普通函数<br> <img src="https://images2.imgbox.com/f7/13/qceJ2KDC_o.png" alt="在这里插入图片描述"></p> </li><li> <p>如果调用普通函数<code>会</code>发生类型转换，而调用函数模板实例化的模板函数<code>不会发生类型转换</code>时，就调用模板函数<br> <img src="https://images2.imgbox.com/1d/10/YWguaVIE_o.png" alt="在这里插入图片描述"></p> </li><li> <p>如果都<code>会</code>发生类型转换，就调用已经存在的普通函数</p> </li></ol> 
<hr> 
<h3><a id="_107"></a>类模板</h3> 
<h4><a id="_109"></a>语法</h4> 
<p><mark>template &lt; typename/class T(自定义类型名)， typename/class T，………&gt;<br> 模板类的定义</mark></p> 
<p>例<br> <img src="https://images2.imgbox.com/27/f1/PI05BTF6_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h4><a id="_118"></a>模板类实例化对象</h4> 
<p>模板类实例化对象时<code>只能显式传类型</code></p> 
<p>此时&lt;&gt;加在类名后面</p> 
<p>[<mark>&lt;&gt;必须要有，哪怕&lt;&gt;中不写类型</mark>]</p> 
<p>例<br> <img src="https://images2.imgbox.com/68/9c/WBBsVAYj_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d4/0f/XIkymdWM_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h4><a id="_134"></a>模板类的模板参数可以有缺省值</h4> 
<p>例<br> <img src="https://images2.imgbox.com/97/db/z0OlSEcF_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_139"></a>类模板中的成员函数全函数模板</h4> 
<p>为什么？</p> 
<p><mark>因为类模板中的成员变量的类型是不确定的，成员函数是否使用了类模板的模板类型不确定</mark></p> 
<p>所以他没有办法像普通类的成员函数一样，在编译时就创建好了</p> 
<p>而是跟函数模板一样需要编译器在运行过程中推演</p> 
<hr> 
<h4><a id="_152"></a>模板类中的成员函数声明和定义分离</h4> 
<p>不能简单地直接类名+：：</p> 
<p>而是</p> 
<p><code>模板类型声明+类中的成员函数的定义</code>[注意此时类名后面还是要加&lt;类型&gt;，因为这样才是一个完整的类类型]，这样类实例化对象的时候就可以推导出对应的成员函数的类型<br> <img src="https://images2.imgbox.com/d3/c9/FjunAS8t_o.png" alt="在这里插入图片描述"></p> 
<p><mark>由于模板类不完整，所以不能直接用它去限定作用域</mark></p> 
<p>即在类外实现成员函数等用：：区限定时，不能直接限定，要先指定类型</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a186b5b351e1d6d90f2861be0b3fc766/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在Ubuntu22.04 使用stable-diffusion-webui 秋叶整合包</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/46efdc35186a8e7bb10ac7b2ce00626e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MacOS安装nvm实现多Node版本管理和自由切换</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>