<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; string模拟实现 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/e4284a334244eb41af0d384f349b2ebb/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C&#43;&#43; string模拟实现">
  <meta property="og:description" content="一 如何区分自定义类与标准库中的同名类 // string.h #define _CRT_SECURE_NO_WARNINGS 1 #pragma once #include&lt;iostream&gt; using namespace std; namespace bit { class string { } } // Test.cpp include &#34;string.h&#34; int main() { return 0; } 既然要模拟实现string底层那就得先理解为什么我写的string和库string里面不会冲突。
1 头文件查找路径
当我们用双引号 &#34;&#34; 包围头文件时，编译器会首先在当前目录下查找这个头文件。这意味着它会优先找到我们自己定义的头文件（比如 string.h），而不是标准库中的头文件。因为标准库的头文件通常在其他系统目录中，所以不会发生冲突。
2 避免名字冲突
虽然使用双引号包含头文件可以让编译器优先使用我们自定义的头文件，但如果我们在头文件中定义了一个与标准库相同名称的类或函数，仍然可能导致混淆或冲突。
为了解决这个问题，我们可以使用命名空间。命名空间就像是一个独立的区域，把我们的代码和标准库的代码隔离开来。比如，我们创建一个 bit 命名空间，然后在这个命名空间里定义一个与标准库同名的类或函数，这样就可以避免冲突。
当我们在代码中使用这些定义时，需要明确指明是哪个命名空间下的。比如，使用 bit::string 来表示我们自定义的 string 类，而 std::string 则表示标准库中的 string 类。这样编译器就能清楚地区分它们。
二 构造 / 拷贝 / 析构函数 2.1 构造 2.1.1 空字符串构造函数（默认构造函数） string() :_str(new char[1]) ,_size(0) ,capacity(0) { _str[0] = &#39;\0&#39;; } 在std::string类,空字符串的初始化会创建一个包含单个字符(&#39;\0&#39;)这个字符用于表示字符串的结束。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-13T20:33:33+08:00">
    <meta property="article:modified_time" content="2024-08-13T20:33:33+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; string模拟实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一 如何区分自定义类与标准库中的同名类</h2> 
<pre><code>// string.h
#define _CRT_SECURE_NO_WARNINGS 1
#pragma once
#include&lt;iostream&gt;
using namespace std;

namespace bit
{
	class string
	{

	}
}

// Test.cpp
include "string.h"

int main()
{
	return 0;
}</code></pre> 
<p>既然要模拟实现string底层那就得先理解为什么我写的string和库string里面不会冲突。</p> 
<p>1 头文件查找路径</p> 
<p>当我们用双引号 <code>""</code> 包围头文件时，编译器会首先在当前目录下查找这个头文件。这意味着它会优先找到我们自己定义的头文件（比如 <code>string.h</code>），而不是标准库中的头文件。因为标准库的头文件通常在其他系统目录中，所以不会发生冲突。</p> 
<p>2 避免名字冲突</p> 
<p>虽然使用双引号包含头文件可以让编译器优先使用我们自定义的头文件，但如果我们在头文件中定义了一个与标准库相同名称的类或函数，仍然可能导致混淆或冲突。</p> 
<p>为了解决这个问题，我们可以使用命名空间。命名空间就像是一个独立的区域，把我们的代码和标准库的代码隔离开来。比如，我们创建一个 <code>bit</code> 命名空间，然后在这个命名空间里定义一个与标准库同名的类或函数，这样就可以避免冲突。</p> 
<p>当我们在代码中使用这些定义时，需要明确指明是哪个命名空间下的。比如，使用 <code>bit::string</code> 来表示我们自定义的 <code>string</code> 类，而 <code>std::string</code> 则表示标准库中的 <code>string</code> 类。这样编译器就能清楚地区分它们。</p> 
<h2>二 构造 / 拷贝 / 析构函数</h2> 
<h3>2.1 构造</h3> 
<h4>2.1.1 空字符串构造函数（默认构造函数）</h4> 
<pre><code>string()
 :_str(new char[1])
 ,_size(0)
 ,capacity(0)
{
 _str[0] = '\0';
}
</code></pre> 
<p><code>在std::string</code>类,空字符串的初始化会创建一个包含单个字符('\0')这个字符用于表示字符串的结束。</p> 
<p>那么:_str(new char[1])就是在堆上new一个包含1个<code>char</code>元素的数组。然后给这唯一的元素赋值'\0'（赋值运算都是在构造函数体内进行）。</p> 
<h4>2.1.2常量字符串构造函数</h4> 
<pre><code>string(const char* str)
  _str(new char[strlen(str)+1])
  _size(strlen(str))
  _capasize(strlen(str))
  {
   strcpy(_str , str);
  }</code></pre> 
<p>既然要把常量字符串复制过来那么首先要知道它的长度(strlen(str)计算长度不包过'\0'所以要+1)，然后让成员变量_str指向堆上新new的空间，空间有了接下俩就可以把字符串复制过来了，而C语言中strcpy函数就是一个很好的选择。从上面代码可以看出来我们多次调用strlen函数来计算字符串长度，可不可以只使用一次,并且将有值构造和默认构造合二唯一？</p> 
<h4>2.1.3 合并</h4> 
<pre><code>string(const char* str = " ")
  _size(strlen(str))
{
  _str = new char[_size + 1];
  _capacity = _size;
 strcpy(_str , str);
}</code></pre> 
<p>合并之后它可以同时作为默认构造函数和常量字符串构造函数。我们首先在初始化列表中确定了字符串的长度并初始化了大小和容量，然后在构造函数体中分配适当大小的内存并将字符串复制到新内存中。</p> 
<h3>2.2 拷贝构造(深拷贝)</h3> 
<pre><code>// 深拷贝
string(const string&amp; s)
{
 _str = new char [s.capacity + 1];
 _size = s._size;
 _capacity = s._capacity;
 strcpy(_str , s._str)
}

// 浅拷贝
string(const string&amp; s) 
{
  _str = s._str;// 直接复制指针
  _size = s._size;
  _capacity = s._capacity;
 }</code></pre> 
<p>回顾一下深拷贝与浅拷贝基本知识内容就基本上懂为什么要写深拷贝而不是以往的浅拷贝</p> 
<p>深拷贝：</p> 
<p>复制对象时，分配新的内存，并复制指针指向的内容。结果是两个对象各自拥有独立的内存，不会互相影响。</p> 
<p>浅拷贝：</p> 
<p>复制对象时，仅复制指针，而不复制指针指向的内容。结果是两个对象共享同一块内存，这可能导致一个对象修改数据，另一个对象的数据也被修改，甚至导致双重释放问题（两个对象在析构时都试图释放同一块内存）。</p> 
<h3>2.3 析构</h3> 
<pre><code>~string()
{
 delete[] _str;
 _str = nullptr;
 size = 0;
 capacity = 0;
 
}</code></pre> 
<p>讲完了如何初始化那就该讲讲怎么遍历了</p> 
<h2>三 遍历字符串</h2> 
<p>遍历字符串有<span style="color:#0d0016;">operator[ ]</span> 、迭代器 俩种方式，那现在让我们模拟实现它们吧。</p> 
<h3><span style="color:#0d0016;">3.1 operator[ ]</span></h3> 
<p>重载<code>operator[]</code>可以让我们像访问数组元素一样访问类的成员变量。</p> 
<pre><code>char&amp; operator[](size_t pos)
{
 assert(pos &lt; _size);
 return _size[pos]
}</code></pre> 
<h3>3.2 迭代器</h3> 
<p>我们一般说迭代器类似指针但是却不是指针</p> 
<pre><code>typedef char* iterator;

iterator begin()
{
  return _str;
}

iterator end()
{
 return _str + _size;
}
</code></pre> 
<h2>四 对内容进行修改</h2> 
<h4><span style="color:#0d0016;">4.1 reserve</span></h4> 
<pre><code>//  开空间

void reserve(size_t n)
{
 if(n &gt; capacity)
 {
  char* tmp = new char[n + 1];
  strcpy(str , tmp);
  delete[] _str;
  _str = tmp;
  capacity = n;
 }
}</code></pre> 
<h4><span style="color:#0d0016;">4.2 </span>push_back</h4> 
<pre><code>//  尾部添加单个字符

void push_back(char ch)
{ 
  if(_size == capacity)
  {
    reserve(capacity == 0 ? 4: capacity * 2);
  }
  _str[_size] = ch;
  ++_size;
  _str[_size] = '\0'
}</code></pre> 
<h4>4.3 append</h4> 
<pre><code>//  尾部添加一个字符串

void append(const char* str)
{
 size_t len = strlen(str);
 if(len + _size &gt; capacity)
 {
  reserve(len + _size);
 }
 strncpy(_str + _size , str , len);
 _size += len;
}</code></pre> 
<p><span style="color:#0d0016;">operator+= </span></p> 
<pre><code>// 尾插单个字符版

string&amp; operator+=(char ch)
{ 
  push_back(ch);
  return *this;
}

// 尾插字符串版

 string&amp; operator+=(const char* str)
{ 
 append(str);
 return *this;
}


//尾插字符串测试代码

int main() 
{
    String str;
    str += "Hello, " += "world!";
return 0;
}</code></pre> 
<p>当执行 <code>str += "Hello, ";</code> 时，编译器会识别出这是 <code>operator+=</code> 操作，并且调用我们为 <code>String</code> 类定义的 <code>operator+=</code> 函数。</p> 
<p>在 <code>operator+=</code> 函数内部，<code>this</code> 是一个指向 <code>str</code> 对象的指针。所以在函数内部，<code>this-&gt;</code> 和 <code>str.</code> 是等价的。</p> 
<p>在 <code>operator+=</code> 函数中，调用了 <code>append(str)</code>，其中 <code>str</code> 是传入的 C 字符串 <code>"Hello, "</code>。此时，<code>this</code> 仍然指向 <code>str</code> 对象。</p> 
<p><code>operator+=</code> 返回当前对象的引用 <code>*this</code>，即 <code>str的引用</code>。</p> 
<h4><span style="color:#0d0016;">4.4 insert </span></h4> 
<pre><code>//在指定位置插入字符

void insert(size_t pos, char ch)
{
 assert(pos &lt;= _size);
 if(pos == _capacity)
 {
  reserve(capacity == 0 ? 4: capacity * 2);
 }
 size_t end = _size
 while(end &gt;= pos)
 {
 _str[end + 1] = _str[end];
 --end;
 }
 _str[pos] = ch;
 _size += 1;
}

//在指定位置插入字符串

void insert(size_t pos, const char* ch)
{
 assert(pos &lt;= _size);
 size_t len = strlen(ch);
 if(_size + len &gt;= _capacity)
 {
  reserve((_size + len) *2);
 }
 size_t end = _size;
  while(end &gt;= pos)
 { 
  _str[end + _size] = _str[end];
  --end;
 }
 strncpy(_str + pos , ch , len);
 _size += len;
}</code></pre> 
<h4><span style="color:#0d0016;">4.5 erase</span></h4> 
<pre><code>// 从指定位置删除指定长度的字符

void erase(size_t pos, size_t len = npos)
{ 
 assert(pos &lt; _size);
 if(len + pos &gt; _size || len == npos)
 { 
  _str[pos] = '\0';
  _size = pos;
 }
 strcpy(_str + pos , _str + pos + len);
 _size -= len;
}</code></pre> 
<p>当 <code>pos + len</code> 超过了有效数据的总长度时，说明操作已经超出范围，这时候最简单的做法就是从 <code>pos</code> 开始删除后面的所有内容。反之，如果 <code>len</code> 没有超出范围，那么就不需要做任何删除操作。</p> 
<ul><li>如果没有显式传递 <code>len</code> 参数，它默认会使用 <code>npos</code> 作为 <code>len</code> 的值。<code>npos</code> 通常表示一个无效位置或者未找到的值，通常等同于 <code>-1</code>（但在 <code>size_t</code> 类型中，<code>-1</code> 实际上是一个非常大的正整数）。</li><li>当 <code>len == npos</code> 时，意味着你没有指定要删除或操作的长度。在这种情况下，函数通常会理解为你希望操作直到字符串的末尾。</li></ul> 
<h4><span style="color:#0d0016;">4.6 find </span></h4> 
<pre><code>// 查找字符

size_t find(char ch,size_t pos=0) const
{ 
 assert(pos &lt; _size);
 for (size_t i = pos; i &lt; _size; i++)
	{
		if (_str[i] == ch)
			return i;
	}
	return npos;
}

// 查找字符串

// const 在函数签名后面:表示这个成员函数不能修改所属对象的状态。
size_t find(const char* str, size_t pos = 0) const
{ 
 assert(pos &lt; _size);
  // 用于查找一个字符串在另一个字符串中的首次出现位置
  // 找到返回它在 _str + pos 中首次出现的位置；如果未找到，a 将为 nullptr。
 const char* m = strstr(_str + pos, str);
 if(a)
 { 
  return m - _str; //指针减去指针返回它们相差的个数 
 }
 else
 { 
  return nops; 
 }
}</code></pre> 
<h4><span style="color:#0d0016;">4.7 substr </span></h4> 
<pre><code>// 在原字符串中获取子串

string substr(size_t pos = 0, size_t len = npos)
{
  string Tmp;
  assert(pos &lt; _size);
  if(pos + len &gt; _size || len == pos)
 {
  for(int i = pos; i &lt; _size; i++)
  {
   // 字符被添加到了 sub 对象所指向的字符串存储空间中，而这个存储空间的指针是 sub 对象的一部分。
   Tmp += _str[i];
  }
  else
  {
   for(int i = pos; i &lt; len + pos; i++)
   {
     sub += _str[i];
   }
  }
 }
 return Tmp;
}</code></pre> 
<h2>五 重载函数</h2> 
<h4><span style="color:#0d0016;">5.1 operator=</span></h4> 
<pre><code>/ 赋值重载

string&amp; operator=(const string&amp; s)
{ 
 char* Tmp = new char[strlen(s._capacity) + 1];
 strcpy(Tmp , _str);
 delete[] _str;
 _size = s._size;
 _capacity = s._capacity;
 return *this;
}</code></pre> 
<h4><span style="color:#0d0016;">5.2 operator==</span></h4> 
<pre><code>// 等几个比较函数

bool operator==(const string&amp; s1, const string&amp; s2)
{ 
 int m = strcmp(s1._str , s2._str);
 return m == 0;
}

bool operator&lt;(const string&amp; s1, const string&amp; s2)
{
 int x = strcmp(s1._str , s2._str);
 return x &lt; 0;
} </code></pre> 
<h4>5.3 operator&lt;&lt;</h4> 
<pre><code>// 流插入与提取

ostream&amp; operator&lt;&lt;(ostream&amp;out,const string&amp;s)
{
  for(auto e : s)
 {
  out &lt;&lt; ch;
 }
 return out
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/004b7a218a8ca441acbac1bd7d7291a8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">计算机网络——HTTP协议详解（上）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3707d0eefe8c6a9960171accf65c578b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于 Flutter 从零开发一款产品（一）—— 跨端开发技术介绍</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>