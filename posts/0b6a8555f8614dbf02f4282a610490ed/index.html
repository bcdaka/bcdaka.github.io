<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux 操作系统 --- 信号 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/0b6a8555f8614dbf02f4282a610490ed/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Linux 操作系统 --- 信号">
  <meta property="og:description" content="序言 在本篇内容中，将为大家介绍在操作系统中的一个重要的机制 — 信号。大家可能感到疑惑，好像我在使用 Linux 的过程中并没有接触过信号，这是啥呀？其实我们经常遇到过，当我们运行的进程当进程尝试访问非法内存地址时，我们的进程会被中断，这是因为操作系统向该进程发送了中断信号。
Linux 操作系统离不开信号机制，在这篇文章中，让我们走进信号，了解信号的从哪里来，又到哪里去。
1. 信号的概念 1.1 定义 信号是操作系统向进程发送的一种通知，表示某个特定事件已经发生。在Unix、类Unix 以及其他系统中，信号被广泛使用。
1.2 特点 信号具有如下的特点：
异步性：信号的产生对进程来说是异步的，即 进程无法预知信号何时到来。通知机制：信号是一种 软件中断(由软件程序触发的中断方式)，用于中断进程的正常执行流程，使其处理特定事件。进程间通信：虽然信号主要用于异常处理和系统调试，但也可以用于进程间的基本通信。
1.3 种类 在 Linux 系统下，使用指令：kill -l 即可查看所有的信号：
信号是使用宏定义的，每个信号前面的数字，就是该信号宏对应的值。
前 31 个信号为常规信号，其余为实时信号。在本篇文章中，我们主要讨论前 31 个常规信号。
你也可以使用指令: man 7 signal 查看每一个详细信息：
补充知识点：Core &amp;&amp; Term 在描述信号的字段中，有一个叫做 Action 的特征，他的值大多都是 Core Term 这是什么呢？
Term term 是 terminate 的缩写，表示默认动作是终止进程。当进程接收到一个默认动作为 term 的信号时，进程会被立即终止。
Core core 表示 默认动作是终止进程并生成一个核心转储（core dump）文件。核心转储是一个包含进程在终止时的内存映像的文件，它对于调试程序非常有用，因为它 提供了进程终止时的状态信息。
咦？就比如，SIGSEGV 段错误 当我的程序非法访问被终结时，被没有产生传说中的核心转储文件呀？这是因为你的服务器默认关闭了该功能，使用指令 ulimit -a 查看：
现在我们使用指令 ulimit -c 4096 开启该功能：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-16T17:50:51+08:00">
    <meta property="article:modified_time" content="2024-08-16T17:50:51+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux 操作系统 --- 信号</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>序言</h3> 
<p> 在本篇内容中，将为大家介绍在操作系统中的一个重要的机制 — 信号。大家可能感到疑惑，好像我在使用 <strong>Linux</strong> 的过程中并没有接触过信号，这是啥呀？其实我们经常遇到过，当我们运行的进程当进程尝试访问非法内存地址时，我们的进程会被中断，这是因为操作系统向该进程发送了中断信号。<br>  <strong>Linux</strong> 操作系统离不开信号机制，在这篇文章中，让我们走进信号，了解信号的从哪里来，又到哪里去。</p> 
<hr> 
<h3><a id="1__5"></a>1. 信号的概念</h3> 
<h4><a id="11__6"></a>1.1 定义</h4> 
<p> 信号是操作系统向进程发送的一种通知，表示某个特定事件已经发生。在<strong>Unix、类Unix</strong> 以及其他系统中，信号被广泛使用。<br> <br></p> 
<h4><a id="12__9"></a>1.2 特点</h4> 
<p> 信号具有如下的特点：</p> 
<ul><li><code>异步性</code>：信号的产生对进程来说是异步的，即 <code>进程无法预知信号何时到来</code>。</li><li><code>通知机制</code>：信号是一种 <code>软件中断(由软件程序触发的中断方式)</code>，用于中断进程的正常执行流程，使其处理特定事件。</li><li><code>进程间通信</code>：虽然信号主要用于异常处理和系统调试，但也可以用于进程间的基本通信。<br> <br></li></ul> 
<h4><a id="13__16"></a>1.3 种类</h4> 
<p> 在 <strong>Linux</strong> 系统下，使用指令：<code>kill -l</code> 即可查看所有的信号：<br> <img src="https://images2.imgbox.com/d1/e7/nTzs9hid_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>信号是使用宏定义的，每个信号前面的数字，就是该信号宏对应的值。</p> 
</blockquote> 
<p>前 31 个信号为常规信号，其余为实时信号。<code>在本篇文章中，我们主要讨论前 31 个常规信号。</code></p> 
<p> 你也可以使用指令: <code>man 7 signal</code> 查看每一个详细信息：<br> <img src="https://images2.imgbox.com/7f/68/3Uk0i3wN_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="Core__Term_26"></a>补充知识点：Core &amp;&amp; Term</h5> 
<p> 在描述信号的字段中，有一个叫做 <code>Action</code> 的特征，他的值大多都是 <code>Core Term</code> 这是什么呢？<br> <br></p> 
<h6><a id="Term_29"></a>Term</h6> 
<p> <code>term</code> 是 <code>terminate</code> 的缩写，表示<code>默认动作是终止进程</code>。当进程接收到一个默认动作为 <code>term</code> 的信号时，进程会被立即终止。<br> <br></p> 
<h6><a id="Core_32"></a>Core</h6> 
<p> <code>core</code> 表示 <code>默认动作是终止进程并生成一个核心转储（core dump）文件</code>。核心转储是一个包含进程在终止时的内存映像的文件，它对于调试程序非常有用，因为它 <code>提供了进程终止时的状态信息</code>。<br>  咦？就比如，<code>SIGSEGV 段错误</code> 当我的程序非法访问被终结时，被没有产生传说中的核心转储文件呀？这是因为你的服务器默认关闭了该功能，使用指令 <code>ulimit -a</code> 查看：<br> <img src="https://images2.imgbox.com/88/72/29NMZzck_o.png" alt="在这里插入图片描述"><br> 现在我们使用指令 <code>ulimit -c 4096</code> 开启该功能：<br> <img src="https://images2.imgbox.com/bb/3c/t7fqJI9X_o.png" alt="在这里插入图片描述"></p> 
<p>现在我们运行下一段程序：</p> 
<pre><code class="prism language-c">   <span class="token number">8</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token number">9</span> <span class="token punctuation">{<!-- --></span>
  <span class="token number">10</span> 
  <span class="token number">11</span>     <span class="token keyword">int</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
  <span class="token number">12</span>     <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token number">13</span>     
  <span class="token number">14</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token number">15</span> <span class="token punctuation">}</span>
</code></pre> 
<p>程序不负众望地报错并退出了，产生了一个文件：<br> <img src="https://images2.imgbox.com/98/9c/zsZi1hFb_o.png" alt="在这里插入图片描述"><br> 这个文件可以干嘛呢？当我们的程序出现异常时，相当该文件保存了案发现场，具体的用法是：</p> 
<ul><li>首先使用 <code>gdb</code> 调试你的程序：<br> <img src="https://images2.imgbox.com/ec/e6/o5k2NUDz_o.png" alt="在这里插入图片描述"></li><li>之后输入指令 <code>core-file your_core</code><br> <img src="https://images2.imgbox.com/22/41/FWizziW2_o.png" alt="在这里插入图片描述"></li></ul> 
<p>可以看到，直接就复原了事故现场。<br> <br></p> 
<h6><a id="_63"></a>区别</h6> 
<ul><li>进程终止：<code>term</code> 信号会终止进程，但 <code>不生成核心转储文件</code>。<code>term</code> 信号通常是用于请求进程正常终止的情况。</li><li>调试信息：<code>core</code> 信号不仅会终止进程，还会 <code>生成核心转储文件</code>，这包含了进程的内存映像、寄存器状态、堆栈跟踪等信息，用于调试目的。</li></ul> 
<hr> 
<h3><a id="2__70"></a>2. 信号的产生</h3> 
<p> 信号是从哪里产生的呢？虽然最后都是操作系统来执行对一个进程发送信号，但是是谁告诉操作系统这样做的呢？</p> 
<h4><a id="21___kill__73"></a>2.1 用户操作 — <code>kill</code> 指令</h4> 
<p> 当我们运行一个程序时，可以通过指令 <code>kill</code> 来让操作系统对该进程发送相应的信号，就比如，我们可以手动发送 <code>SIGKILL 9号</code> 信号将该进程终结，这里有一个程序：</p> 
<pre><code class="prism language-c"> <span class="token number">1</span> TestSig1<span class="token punctuation">.</span>cc                                                                                                                                                                                                  X 
   <span class="token number">1</span> #include <span class="token operator">&lt;</span>iostream<span class="token operator">&gt;</span>
   <span class="token number">2</span> #include <span class="token operator">&lt;</span>unistd<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
   <span class="token number">3</span> 
   <span class="token number">4</span> 
   <span class="token number">5</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token number">6</span> <span class="token punctuation">{<!-- --></span>
   <span class="token number">7</span>     <span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span>
   <span class="token number">8</span>     <span class="token punctuation">{<!-- --></span>
   <span class="token number">9</span>         std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"I am Running, my pid is "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token number">10</span>         <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token number">11</span>     <span class="token punctuation">}</span>
  <span class="token number">12</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token number">13</span> <span class="token punctuation">}</span>
</code></pre> 
<p>该程序会每秒打印相应的内容，现在我们可以使用相关的指令 <code>kill -9 [pid]</code> 来杀掉该进程：<br> <img src="https://images2.imgbox.com/10/b4/RKNSgcNX_o.png" alt="在这里插入图片描述"><br> 可以看到该进程被杀掉了！！！<br> <br></p> 
<h4><a id="22____97"></a>2.2 用户操作 — 按键操作</h4> 
<p> 我们也可通过按键来让操作系统发送相关的信号，就比如我们平时终止一个进程的方式更多的是通过键盘按键，就比如 <code>ctrl + c</code> ：<br> <img src="https://images2.imgbox.com/70/f8/lKlFOEzT_o.png" alt="在这里插入图片描述"><br> 其实这个按键对应的就是 3 号信号 <code>SIGQUIT</code>。<br> <br></p> 
<h4><a id="23____103"></a>2.3 用户操作 — 系统调用</h4> 
<p> 操作系统提供一个系统调用 <code>int kill(pid_t pid, int sig);</code> 该函数你可以想指定进程发送信号：</p> 
<ul><li><code>pid</code>: 表示要发送信号的进程 <code>ID</code></li><li><code>sig</code>: 表示要发送的信号</li><li>返回值：成功返回 0 ，失败返回 -1 ，错误码被设置</li></ul> 
<p>还有一个函数是 <code>int raise(int sig);</code>，该函数是向当前进程发送指定信号，简单来说，相当于简化的 <code>kill</code> =&gt; <code>kill(getpid(), int sig);</code><br> <br></p> 
<h4><a id="24__112"></a>2.4 触发软件条件</h4> 
<p> 在之前管道的学习中，我们了解到如果 <code>读端被关闭了，写端一直再写</code>，那么操作系统就会认为这是一个坏掉的管道，就会发送 13 号信号 <code>SIGPIPE</code> 终止该进程，这就是触发了某种软件条件。<br>  现在，在这里先向大家介绍几个非常重要的函数：</p> 
<h5><a id="signal__115"></a><code>signal</code> 函数</h5> 
<p> 该函数允许程序员定义当特定信号发生时，程序应该如何响应, 简单说，<code>这个函数用于捕获特定信号，然后执行指定操作的</code>。<code>sighandler_t signal(int signum, sighandler_t handler);</code>:</p> 
<ul><li><code>signum</code>：指定要处理的信号类型。注意，<code>SIGKILL</code> 和 <code>SIGSTOP</code> 这两个信号不能被捕获、阻塞或忽略。</li><li><code>handler</code>：指定信号的处理方式。它可以是一个函数指针，指向一个用户定义的信号处理函数；也可以是 <code>SIG_IGN</code>，表示忽略该信号；或者是 <code>SIG_DFL</code>，表示采用信号的默认处理方式。</li><li>返回值：成功时，<code>signal</code> 函数返回之前为该信号设置的信号处理函数的指针。如果之前没有为该信号设置过处理函数，则返回 <code>SIG_DFL</code>。失败时，返回 <code>SIG_ERR</code>，并设置 <code>errno</code> 以指示错误原因。</li></ul> 
<p>看着描述这么多，其实用起来不复杂，比如，现在我要捕获 2 号信号 <code>SIGINT</code>，他的默认操作是退出，现在我不想要推出，想要执行我的逻辑：</p> 
<pre><code class="prism language-c"> <span class="token number">1</span> TestSig1<span class="token punctuation">.</span>cc                                                                                       X 
   <span class="token number">1</span> #include <span class="token operator">&lt;</span>iostream<span class="token operator">&gt;</span>
   <span class="token number">2</span> 
   <span class="token number">3</span> #include <span class="token operator">&lt;</span>unistd<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
   <span class="token number">4</span> #include <span class="token operator">&lt;</span>sys<span class="token operator">/</span>types<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
   <span class="token number">5</span> #include <span class="token operator">&lt;</span>signal<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
   <span class="token number">6</span> 
   <span class="token number">7</span> <span class="token keyword">void</span> <span class="token function">signal_handle</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">)</span>
   <span class="token number">8</span> <span class="token punctuation">{<!-- --></span>
   <span class="token number">9</span>     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"I got you signal: "</span> <span class="token operator">&lt;&lt;</span> signum <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token number">10</span> <span class="token punctuation">}</span>
  <span class="token number">11</span> 
  <span class="token number">12</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token number">13</span> <span class="token punctuation">{<!-- --></span>
  <span class="token number">14</span> 
  <span class="token number">15</span>     <span class="token comment">// 2号信号的捕获</span>
  <span class="token number">16</span>     <span class="token function">signal</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> signal_handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token number">17</span> 
  <span class="token number">18</span>     <span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span>
  <span class="token number">19</span>     <span class="token punctuation">{<!-- --></span>
  <span class="token number">20</span>         std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"I am Running, my pid is "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token number">21</span>         <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token number">22</span>     <span class="token punctuation">}</span>
  <span class="token number">23</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token number">24</span> <span class="token punctuation">}</span>
</code></pre> 
<p>现在我们使用 <code>ctrl + c</code> 已经不能终止该进程了：<br> <img src="https://images2.imgbox.com/86/af/GZ5vHUjL_o.png" alt="在这里插入图片描述"></p> 
<p>你也可将 <code> signal(2, signal_handle);</code> 中的函数换成 <code>SIG_IGN</code> 这样就会忽略该信号。</p> 
<p>现在我有个想法就是将全部信号都捕获，在写个死循环，是不是就没有人把我停下来了！！！我们能想到的，人家肯定也想到了，<code>规定 9 号信号 SIGKILL 和 19 号信号 SIGSTOP 这两个信号不能被捕获、阻塞或忽略。</code>保证系统的稳定性和管理员的控制权。<br> <br></p> 
<h5><a id="alarm__159"></a><code>alarm</code> 函数</h5> 
<p> 大家为了早起都设置过闹钟吧，闹钟的作用就是时间一到就提醒我们执行某件任务。在 <code>Linux</code> 中的闹钟 <code>alarm</code> 也是一样的，我们设置一个定时，当时间一到执行某项任务，<code>unsigned int alarm(unsigned int seconds);</code>：</p> 
<ul><li><code>seconds</code>：定时器应该等待的秒数。如果 <code>seconds</code> 是 0，则任何当前设置的定时器都会被取消（你可以同时设置多个闹钟），但不会发送 <code>SIGALRM</code> 信号。</li><li>返回值：如果之前已经设置了定时器，<code>alarm</code> 函数 <code>返回之前设置的剩余时间（秒）</code>，直到定时器到期。如果之前没有设置定时器，则返回 0。</li></ul> 
<p>当 <code>alarm</code> 定时器到期时，会向进程发送 <code>SIGALRM</code> 信号，终止进程：</p> 
<pre><code class="prism language-c"><span class="token number">12</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token number">13</span> <span class="token punctuation">{<!-- --></span>
  <span class="token number">14</span> 
  <span class="token number">15</span>     <span class="token comment">// 设置一个闹钟，执行默认操作</span>
  <span class="token number">16</span>     <span class="token function">alarm</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token number">17</span> 
  <span class="token number">18</span>     <span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span>
  <span class="token number">19</span>     <span class="token punctuation">{<!-- --></span>
  <span class="token number">20</span>         std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"I am Running, my pid is "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token number">21</span>         <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token number">22</span>     <span class="token punctuation">}</span>
  <span class="token number">23</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token number">24</span> <span class="token punctuation">}</span>
</code></pre> 
<p>两秒之后，进程自动终止：</p> 
<p> 但更多情况下，我们想要闹钟解释后执行我们的逻辑，而不是终止进程，那咋办呢？ <code>捕获该信号，自定义处理信号</code>，这就需要我们上面说的 <code>signal</code> 函数了：</p> 
<pre><code class="prism language-c">   <span class="token number">7</span> <span class="token keyword">void</span> <span class="token function">signal_handle</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">)</span>
   <span class="token number">8</span> <span class="token punctuation">{<!-- --></span>
   <span class="token number">9</span>     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Your alarm clock is ringing."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token number">10</span> <span class="token punctuation">}</span>
  <span class="token number">11</span> 
  <span class="token number">12</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token number">13</span> <span class="token punctuation">{<!-- --></span>
  <span class="token number">14</span> 
  <span class="token number">15</span>     <span class="token comment">// 设置一个闹钟，执行默认操作</span>
  <span class="token number">16</span>     <span class="token function">alarm</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token number">17</span>     <span class="token comment">// 捕获闹钟信号</span>
  <span class="token number">18</span>     <span class="token function">signal</span><span class="token punctuation">(</span>SIGALRM<span class="token punctuation">,</span> signal_handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token number">19</span> 
  <span class="token number">20</span>     <span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span>
  <span class="token number">21</span>     <span class="token punctuation">{<!-- --></span>
  <span class="token number">22</span>         std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"I am Running, my pid is "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token number">23</span>         <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token number">24</span>     <span class="token punctuation">}</span>
  <span class="token number">25</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token number">26</span> <span class="token punctuation">}</span>
</code></pre> 
<p>现在闹钟时间到了，就不会终止进程啦！但是，我还有一个疑问，你这个闹钟只能执行一次呀，之后就失效了，我想要一个一直生效的定时任务，怎么做到呢？当捕获并执行自定义函数时再设置一个闹钟不就好啦：</p> 
<pre><code class="prism language-c">   <span class="token number">7</span> <span class="token keyword">void</span> <span class="token function">signal_handle</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">)</span>
   <span class="token number">8</span> <span class="token punctuation">{<!-- --></span>
   <span class="token number">9</span>     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Your alarm clock is ringing."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token number">10</span>     <span class="token function">alarm</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token number">11</span> <span class="token punctuation">}</span>
</code></pre> 
<p>这样就得到一个持续的定时任务啦：<br> <img src="https://images2.imgbox.com/10/c2/Y4CcFZfC_o.png" alt="在这里插入图片描述"><br> <br></p> 
<p> 在这里的闹钟就是一个触发了软件条件（倒计时），从而产生信号发送给进程！<br> <br></p> 
<h4><a id="24__226"></a>2.4 硬件异常</h4> 
<h5><a id="_227"></a>段错误</h5> 
<p> 在我们的程序中，很可能涉及到 <code>段错误（非法内存访问）</code>，具体触发错误的细节如下：</p> 
<ul><li>现代计算机使用内存管理单元（<code>MMU</code>）来管理内存。<code>MMU</code> 负责 <code>将虚拟地址（程序使用的地址）映射到物理地址（实际内存地址）</code>。</li><li>当我们尝试访问一个地址时，<code>MMU</code> 尝试将虚拟地址翻译为物理地址，并检查该虚拟地址对应的页表项，以确定是否有权限访问该地址，以及地址是否有效</li><li>当 <code>CPU</code> 发现该块地址是 <code>无效的，或者是不具有写权限的，或者是无权限访问的</code>，将触发异常</li><li>操作系统向该进程发送 <code>SIGSEG</code> 的信号</li></ul> 
<p>这就是简单的硬件异常触发流程。</p> 
<hr> 
<h3><a id="3__237"></a>3. 信号的保存</h3> 
<p> 现在我们已经基本了解了信号是从哪里来的，那么信号被一个进程接受过后，是以什么形式存在于进程当中呢？</p> 
<p> 在介绍信号的保存之前，希望大家记住这几个概念：</p> 
<ul><li>实际执行信号的处理动作称为信号递达(<code>Delivery</code>)</li><li>信号从产生到递达之间的状态,称为信号未决(<code>Pending</code>)。</li></ul> 
<p> 信号的信息被保存在一个进程的 <code>task_struct</code> 中：<br> <img src="https://images2.imgbox.com/fc/e7/LVTz2TMZ_o.png" alt="在这里插入图片描述"><br> 我们来好好的介绍这 3 个结构：</p> 
<h4><a id="31_block__248"></a>3.1 block 位图</h4> 
<p> <code>Block</code> 位图用于指示哪些信号当前被进程 <code>阻塞</code>。如果一个信号在 <code>Block</code> 位图中对应的位被设置（为 1 ），那么即使该信号已经到达，它也不会被立即处理，而是会 <code>保持在未决状态，直到进程解除对该信号的阻塞。</code></p> 
<h4><a id="32_pending__251"></a>3.2 pending 位图</h4> 
<p> <code>Pending</code> 位图（通常不是直接暴露给用户的，而是作为进程控制块 <code>task_struct</code> 的一部分）用于 <code>跟踪哪些信号已经到达进程但尚未被处理</code>。每个位代表一个信号，如果该位被设置（通常为 1 ），则表示对应的信号已经到达且处于 <code>未决状态</code>。</p> 
<h4><a id="33_handler__254"></a>3.3 handler 函数指针数组</h4> 
<p> 用户可以通过系统调用来设置特定信号的处理函数。当用户为某个信号注册了一个自定义的处理函数时，操作系统就会将该函数的地址存储在 <code>handler</code> 表中对应信号编号的位置。如果用户没有为某个信号设置自定义处理函数，那么当该信号发生时，操作系统就会 <code>调用默认的处理函数</code>。</p> 
<blockquote> 
 <p> 所以，我们总结一下，当一个信号传递给进程时，操作系统会将 <code>pending</code> 表中该信号对应的值置 1，如果 <code>block</code>表中的对应的值 也是 1，代表该信号被阻塞，不会被立即处理，直至解除阻塞；当解除阻塞或者一开始就不是阻塞状态的话，就会执行 <code>handle</code><br> 表中该信号对应的函数操作。</p> 
</blockquote> 
<h4><a id="34__260"></a>3.4 验证结论</h4> 
<p> 现在我们准备验证我们的想法，我们先阻塞一个信号，然后发送该信号，查看是否执行相关操作，在解除对该信号的阻塞，再次观察现象：</p> 
<blockquote> 
 <p>在这里会涉及到对信号集的操作，大家可以简单理解为 <code>对信号集进行的对某个信号的阻塞操作最终会保存到阻塞表中</code> ，在这里就不具体说明操作了，感兴趣的小伙伴，我找了一篇比较好的文章 👉<a href="https://blog.csdn.net/Goforyouqp/article/details/132360707?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172379698116800184118081%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=172379698116800184118081&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-132360707-null-null.142%5Ev100%5Epc_search_result_base8&amp;utm_term=%E4%BF%A1%E5%8F%B7%E9%9B%86%E6%93%8D%E4%BD%9C&amp;spm=1018.2226.3001.4187">信号集操作指南</a>。</p> 
</blockquote> 
<pre><code class="prism language-c"><span class="token number">6</span> <span class="token comment">// 自定义函数</span>
   <span class="token number">7</span> <span class="token keyword">void</span> <span class="token function">signal_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">)</span>
   <span class="token number">8</span> <span class="token punctuation">{<!-- --></span>
   <span class="token number">9</span>     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Recived signal SIGINT!!!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token number">10</span> <span class="token punctuation">}</span>
  <span class="token number">11</span> 
  <span class="token number">12</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token number">13</span> <span class="token punctuation">{<!-- --></span>
  <span class="token number">14</span>     <span class="token comment">// 捕获信号</span>
  <span class="token number">15</span>     <span class="token function">signal</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span> signal_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token number">16</span> 
  <span class="token number">17</span>     <span class="token class-name">sigset_t</span> sigset<span class="token punctuation">;</span>
  <span class="token number">18</span>     <span class="token comment">// 初始化信号集</span>
  <span class="token number">19</span>     <span class="token function">sigemptyset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sigset<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token number">20</span>     <span class="token comment">// 添加指定信号到信号集</span>
  <span class="token number">21</span>     <span class="token function">sigaddset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sigset<span class="token punctuation">,</span> SIGINT<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token number">22</span> 
  <span class="token number">23</span>     <span class="token comment">// 阻塞该信号</span>
  <span class="token number">24</span>     <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sigset<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token number">25</span>     <span class="token punctuation">{<!-- --></span>
  <span class="token number">26</span>         <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"sigprocmask"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token number">27</span>     <span class="token punctuation">}</span>
  <span class="token number">28</span> 
  <span class="token number">29</span>     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"SIGINT is blocked. Try pressing Ctrl+C after 5s!!!\n"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token number">30</span>     <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token number">31</span> 
  <span class="token number">32</span>     <span class="token comment">// 解除阻塞</span>
  <span class="token number">33</span>     <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_UNBLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sigset<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token number">34</span>     <span class="token punctuation">{<!-- --></span>
  <span class="token number">35</span>         <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"sigprocmask"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token number">36</span>     <span class="token punctuation">}</span>
  <span class="token number">37</span> 
  <span class="token number">38</span>     std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"SIGINT is unblocked. Try pressing Ctrl+C!!!\n"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token number">39</span> 
  <span class="token number">40</span>     <span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span>
  <span class="token number">41</span>     <span class="token punctuation">{<!-- --></span>
  <span class="token number">42</span>         <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token number">43</span>     <span class="token punctuation">}</span>
  <span class="token number">44</span> <span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/33/dc/9P6CQWOZ_o.png" alt="在这里插入图片描述"></p> 
<p>第一次我们按 <code>ctrl + c</code> 没什么反应，过了 5s 后，函数自动被执行，可以看出我们的结论是正确的。</p> 
<hr> 
<h3><a id="4__312"></a>4. 信号的处理</h3> 
<p> 现在我们知道信号哪里来的了，也知道保存在哪里了，现在我们来看看信号的处理方式。</p> 
<h4><a id="41__315"></a>4.1 执行默认方式</h4> 
<p> 对于没有为其注册信号处理函数的信号，进程会执行该信号的默认操作。就比如，<code>SIGTERM</code> 信号的默认操作是请求进程终止，而 <code>SIGSEGV（段错误）</code>信号的默认操作是生成core文件并终止进程。<br> <br></p> 
<h4><a id="42__319"></a>4.2 调用信号处理函数</h4> 
<p> 如果进程为某个信号注册了信号处理函数（也称为信号处理器，上面代码中的 <code>signal_handler</code> 函数），那么当该信号到达时，内核会暂停进程的正常执行流程，转而调用该处理函数。<br> <br></p> 
<h4><a id="43__323"></a>4.3 忽略信号</h4> 
<p>  进程可以选择忽略某些信号。<code>这意味着当这些信号到达时，进程不会执行任何特别的操作，而是继续执行其当前的代码路径。</code>然而，需要注意的是，并非所有信号都可以被忽略。例如，<code>SIGKILL和SIGSTOP等信号是不能被忽略的</code>。<br> <br></p> 
<h4><a id="44__327"></a>4.4 阻塞信号</h4> 
<p> 进程可以选择屏蔽某些信号，以 <code>避免在关键操作期间接收到这些信号</code>。通过调用<code>sigprocmask</code> 等系统调用，进程可以设置其信号屏蔽字，以决定哪些信号能够传递到进程中。<code>被屏蔽的信号将保持在未决状态，直到屏蔽被解除后才会被处理。</code><br> <br></p> 
<h4><a id="45__331"></a>4.5 阻塞和忽略的区别</h4> 
<p> 这两个概念相当容易混淆，从定义上来说：</p> 
<ul><li>阻塞是指 <code>进程选择性地阻止某些信号的传递</code>。当这些被阻塞的信号发生时，它们会被内核记录下来（<code>处于未决状态</code>），但不会立即执行信号的处理函数或执行默认操作。</li><li>忽略是指进程对收到的某些信号 <code>不执行任何操作</code>，即不调用处理函数也不执行默认操作，而是简单地丢弃这些信号。</li></ul> 
<p>大家可以这样理解：<code>信号被阻塞就不会递达,而忽略是在递达之后可选的一种处理动作。</code> 前者是处于未决的状态，后者是被递达后选择了忽略，不做其他处理。</p> 
<hr> 
<h3><a id="_340"></a>总结</h3> 
<p> 在这篇文章中介绍了信号的概念，也介绍了信号从哪里来，到哪里去，被接受处理的过程，希望大家有所收获😁。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c76bc32a444d647d4ef4b2f81c370bd1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">经典动作手机游戏：《艾希》安卓手机游戏下载</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/80a8f25000e073bd1ba3df3175d8b2df/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">saas服务，对同一个功能，需要使用不同客户的接口。那么哪种设计模式可以解决我的问题?</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>