<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>QT之QWebEngineView详细介绍 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/18d08ccc088c3acaa5800ff0bc7892e0/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="QT之QWebEngineView详细介绍">
  <meta property="og:description" content="此篇文章来源于自己学习QT的QWebEngineView类总结的知识点，本人能力有限，若文章有其他错误，大家评论区评论，共同学习，共同进步。
一、QWebEngineView介绍 QWebEngineView是Qt框架中的一个组件，它是基于Chromium内核的Web浏览器引擎，用于在Qt应用程序中嵌入网页内容和实现各种Web应用功能。通过QWebEngineView，开发者可以在本地桌面应用程序中轻松地集成网页浏览功能，支持HTML5、CSS3、JavaScript等现代Web技术。
注意：QWebEngineView类仅支持QT的5.4版本以上，之前的版本都是使用QtWebKit，QtWebKit类在5.4版本以上已经被丢弃了，不能使用了。而对于QWebEngineView类，仅仅支持MSVC的编译器并不支持MinGW。
加载并显示网页内容。与网页中的JavaScript进行交互。监听和处理网页加载完成、加载失败等各种信号槽事件。实现网页导航控制（前进、后退、刷新）等功能。 在Qt Quick中，对应的功能类为QQuickWebEngineView，用于在QML场景中嵌入Web内容。
例如，创建并加载一个网页的基本用法如下：
#include &lt;QWebEngineView&gt; #include &lt;QApplication&gt; int main(int argc, char *argv[]) { QApplication app(argc, argv); QWebEngineView view; view.load(QUrl(QStringLiteral(&#34;http://www.example.com&#34;))); view.show(); return app.exec(); } 以上代码会创建一个QWebEngineView窗口，并加载example.com网站的内容。
二、成员函数 1、QWebEngineView::QWebEngineView(QWidget *parent = Q_NULLPTR) QWebEngineView::QWebEngineView(QWidget *parent = Q_NULLPTR) 是Qt WebEngine模块中用于创建一个QWebEngineView对象的构造函数。
参数 parent 指向一个QWidget指针，它是QWebEngineView的父窗口或父控件。如果不传入参数（使用默认值Q_NULLPTR），则QWebEngineView将成为一个顶级窗口。如果指定了父控件，那么QWebEngineView将作为该父控件的子控件存在，并遵循父控件的生命周期和布局规则。
简而言之，这段代码：
QWebEngineView *webView = new QWebEngineView(parentWidget); 将会创建一个新的QWebEngineView实例，并将其父控件设置为parentWidget。如果需要在窗口中显示一个能够浏览网页内容的视图，这就是创建该视图的基本步骤。随后可以调用webView-&gt;load(QUrl(url))来加载指定的网页URL。
2、void QWebEngineView::back() void QWebEngineView::back() 是Qt WebEngine模块中的一个成员函数，应用于QWebEngineView类。该函数的作用是让QWebEngineView中的网页浏览器历史回退一步，即显示上一个访问过的网页。
在实际应用中，如果你有一个QWebEngineView对象（比如命名为webView），并且用户已经在该浏览器控件中浏览了几个网页，调用 webView-&gt;back(); 就会让浏览器返回到前一个页面，就像在常规Web浏览器中点击“后退”按钮一样。
以下是一个使用QWebEngineView和back()函数的简单代码示例：
#include &lt;QApplication&gt; #include &lt;QWebEngineView&gt; #include &lt;QUrl&gt; int main(int argc, char *argv[]) { QApplication app(argc, argv); // 创建一个QWebEngineView实例 QWebEngineView* webView = new QWebEngineView(); // 加载一个网页 webView-&gt;load(QUrl(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-13T21:49:28+08:00">
    <meta property="article:modified_time" content="2024-04-13T21:49:28+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">QT之QWebEngineView详细介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>此篇文章来源于自己学习QT的QWebEngineView类总结的知识点，本人能力有限，若文章有其他错误，大家评论区评论，共同学习，共同进步。</p> 
<h2>一、QWebEngineView介绍</h2> 
<p>QWebEngineView是Qt框架中的一个组件，它是基于Chromium内核的Web浏览器引擎，用于在Qt应用程序中嵌入网页内容和实现各种Web应用功能。通过QWebEngineView，开发者可以在本地桌面应用程序中轻松地集成网页浏览功能，支持HTML5、CSS3、JavaScript等现代Web技术。</p> 
<p><span style="color:#fe2c24;"><strong>注意：QWebEngineView类仅支持QT的5.4版本以上，之前的版本都是使用QtWebKit，QtWebKit类在5.4版本以上已经被丢弃了，不能使用了。而对于QWebEngineView类，仅仅支持MSVC的编译器并不支持MinGW。</strong></span></p> 
<blockquote> 
 <ol><li>加载并显示网页内容。</li><li>与网页中的JavaScript进行交互。</li><li>监听和处理网页加载完成、加载失败等各种信号槽事件。</li><li>实现网页导航控制（前进、后退、刷新）等功能。</li></ol> 
</blockquote> 
<p>在Qt Quick中，对应的功能类为QQuickWebEngineView，用于在QML场景中嵌入Web内容。</p> 
<p>例如，创建并加载一个网页的基本用法如下：</p> 
<div> 
 <pre><code>#include &lt;QWebEngineView&gt;
#include &lt;QApplication&gt;

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);

    QWebEngineView view;
    view.load(QUrl(QStringLiteral("http://www.example.com")));
    view.show();

    return app.exec();
}
</code></pre> 
</div> 
<p>以上代码会创建一个QWebEngineView窗口，并加载example.com网站的内容。</p> 
<p></p> 
<h2><strong>二、成员函数</strong></h2> 
<h3>1、QWebEngineView::QWebEngineView(<a href="https://doc.qt.io/qt-5/qwidget.html#QWidget" rel="nofollow" title="QWidget">QWidget</a> *<em>parent</em> = Q_NULLPTR)</h3> 
<p><code>QWebEngineView::QWebEngineView(QWidget *parent = Q_NULLPTR)</code> 是Qt WebEngine模块中用于创建一个QWebEngineView对象的构造函数。</p> 
<p>参数 <code>parent</code> 指向一个QWidget指针，它是QWebEngineView的父窗口或父控件。如果不传入参数（使用默认值Q_NULLPTR），则QWebEngineView将成为一个顶级窗口。如果指定了父控件，那么QWebEngineView将作为该父控件的子控件存在，并遵循父控件的生命周期和布局规则。</p> 
<p>简而言之，这段代码：</p> 
<div> 
 <pre><code>QWebEngineView *webView = new QWebEngineView(parentWidget);</code></pre> 
</div> 
<p>将会创建一个新的QWebEngineView实例，并将其父控件设置为<code>parentWidget</code>。如果需要在窗口中显示一个能够浏览网页内容的视图，这就是创建该视图的基本步骤。随后可以调用<code>webView-&gt;load(QUrl(url))</code>来加载指定的网页URL。</p> 
<p></p> 
<h3>2、void QWebEngineView::back()</h3> 
<p><code>void QWebEngineView::back()</code> 是Qt WebEngine模块中的一个成员函数，应用于QWebEngineView类。该函数的作用是让QWebEngineView中的网页浏览器历史回退一步，即显示上一个访问过的网页。</p> 
<p>在实际应用中，如果你有一个QWebEngineView对象（比如命名为<code>webView</code>），并且用户已经在该浏览器控件中浏览了几个网页，调用 <code>webView-&gt;back();</code> 就会让浏览器返回到前一个页面，就像在常规Web浏览器中点击“后退”按钮一样。</p> 
<p>以下是一个使用<code>QWebEngineView</code>和<code>back()</code>函数的简单代码示例：</p> 
<div> 
 <pre><code>#include &lt;QApplication&gt;
#include &lt;QWebEngineView&gt;
#include &lt;QUrl&gt;

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);

    // 创建一个QWebEngineView实例
    QWebEngineView* webView = new QWebEngineView();

    // 加载一个网页
    webView-&gt;load(QUrl("https://www.example.com"));

    // 显示QWebEngineView
    webView-&gt;show();

    // 假设用户已经浏览了一些页面，现在模拟点击“后退”按钮
    if (webView-&gt;history()-&gt;canGoBack()) {
        webView-&gt;back(); // 回退到上一个页面
    }

    return app.exec();
}</code></pre> 
</div> 
<p>在这个例子中，首先创建了一个<code>QWebEngineView</code>实例，并加载了一个网页。然后，检查<code>webView</code>的历史记录中是否可以回退（即是否至少有两个页面），如果可以，则调用<code>back()</code>函数来实现页面回退的功能。在实际应用中，通常会将<code>back()</code>函数的调用绑定到一个按钮的点击事件上，以供用户手动触发页面回退行为。</p> 
<p></p> 
<h3>3、void QWebEngineView::forward()</h3> 
<p><code>void QWebEngineView::forward()</code> 是Qt WebEngine模块中的一个成员函数，用于QWebEngineView类。这个函数的作用是在网页浏览历史中向前推进一步，即显示下一个访问过的网页。</p> 
<p>在实际应用中，如果你有一个QWebEngineView对象（例如 <code>webView</code>），并且用户已经在该浏览器控件中浏览了若干网页，并且当前处于历史记录的前一个页面，调用 <code>webView-&gt;forward();</code> 就会让浏览器跳转到下一个页面，就如同在常规Web浏览器中点击“前进”按钮一样。</p> 
<p>下面是一个使用<code>forward()</code>函数的基本示例：</p> 
<div> 
 <pre><code>#include &lt;QApplication&gt;
#include &lt;QWebEngineView&gt;
#include &lt;QUrl&gt;

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);

    // 创建一个QWebEngineView实例
    QWebEngineView* webView = new QWebEngineView();

    // 加载一个初始网页
    webView-&gt;load(QUrl("https://www.example.com"));

    // 用户浏览了其他页面，现在假设已经按后退按钮回到了之前的页面
    if (webView-&gt;history()-&gt;canGoForward()) { // 检查是否可以前进到下一个页面
        webView-&gt;back(); // 先模拟后退一步
        webView-&gt;forward(); // 然后模拟前进到下一个页面
    }

    // 显示QWebEngineView
    webView-&gt;show();

    return app.exec();
}</code></pre> 
</div> 
<p>在这个示例中，我们首先加载了一个网页，然后假设用户进行了后退操作，并检查是否可以前进。如果可以，我们就调用<code>forward()</code>函数，让浏览器显示下一个页面。在真实应用中，通常会将<code>forward()</code>函数绑定到一个“前进”按钮的点击事件上。</p> 
<p></p> 
<h3>4、void QWebEngineView::iconChanged(const <a href="https://doc.qt.io/qt-5/qicon.html" rel="nofollow" title="QIcon">QIcon</a> &amp;<em>icon</em>)</h3> 
<p><code>void QWebEngineView::iconChanged(const QIcon &amp;icon)</code> 是Qt WebEngine模块中QWebEngineView类的一个信号。当加载的网页图标（favicon）发生变化时，这个信号会被发射。</p> 
<p>这个信号并没有一个对应的成员函数，而是作为一种通知机制，允许您连接到一个槽函数来响应网页图标的变化。例如，当您希望在地址栏或者书签中更新网页对应的图标时，可以这样做：</p> 
<div> 
 <pre><code>QObject::connect(webView, &amp;QWebEngineView::iconChanged, [=](const QIcon &amp;newIcon){
    // 更新地址栏或书签栏中的图标
    addressBar-&gt;setIcon(newIcon);
    bookmarksManager-&gt;updateBookmarkIcon(currentUrl, newIcon);
});

// 或者在槽函数中处理
connect(webView, SIGNAL(iconChanged(QIcon)), this, SLOT(updatePageIcon(QIcon)));

//槽函数
void YourClass::updatePageIcon(const QIcon &amp;icon) {
    // 在这里处理图标变化，例如更新UI中的图标
    myStatusIcon-&gt;setIcon(icon);
}</code></pre> 
</div> 
<p>请注意，上面的代码展示了Qt 5中的信号与槽连接方式，对于Qt 5.14及以后的版本，推荐使用lambda表达式或<code>connect</code>函数的第一个形式来连接信号和槽。在Qt 4风格的信号槽语法中，使用<code>SIGNAL</code>和<code>SLOT</code>宏。</p> 
<p></p> 
<h3>5、void QWebEngineView::iconUrlChanged(const <a href="https://doc.qt.io/qt-5/qurl.html" rel="nofollow" title="QUrl">QUrl</a> &amp;<em>url</em>)</h3> 
<p><code>void QWebEngineView::iconUrlChanged(const QUrl &amp;url)</code> 是Qt WebEngine模块中QWebEngineView类的一个信号。当网页的图标URL（favicon URL）发生变化时，该信号会被发射。这个信号携带了一个QUrl类型的参数，该参数包含了新的图标资源的URL。</p> 
<p>这个信号常用于监控网页favicon的更新，当网页的图标URL变化时，您可以连接到这个信号，并根据新的URL获取和更新对应的图标资源。</p> 
<p>例如，通过信号槽机制，您可以捕获这个信号并做出相应动作：</p> 
<div> 
 <pre><code>QObject::connect(webView, &amp;QWebEngineView::iconUrlChanged, [&amp;](const QUrl &amp;newIconUrl){
    // 新的图标URL已改变，可以在此处根据新的URL下载并更新图标
    // 下面的代码仅为示意，实际应用中可能需要异步下载并处理图标数据
    QImage iconImage = QImageReader(newIconUrl).read();
    if (!iconImage.isNull()) {
        myStatusBar-&gt;setIcon(QIcon(iconImage));
    }
});</code></pre> 
</div> 
<p><code>void QWebEngineView::iconChanged(const QIcon &amp;icon)</code> 和 <code>void QWebEngineView::iconUrlChanged(const QUrl &amp;url)</code> 是Qt WebEngine模块中QWebEngineView类的两个不同信号，它们的区别在于提供的信息和处理方式：</p> 
<ol><li> <p><strong>iconChanged(const QIcon &amp;icon)</strong>：</p> 
  <ul><li>这个信号是在网页的图标（favicon）实际内容发生变化时触发的。</li><li>当网页的favicon加载完成或更新时，该信号会直接传递一个已经解析并加载好的图标对象（QIcon）。</li><li>开发者可以直接使用这个图标对象更新UI，无需关心具体的URL和加载过程。</li></ul></li><li> <p><strong>iconUrlChanged(const QUrl &amp;url)</strong>：</p> 
  <ul><li>这个信号在网页的favicon URL发生变化时触发。</li><li>该信号只提供新的图标资源的URL地址，而不提供已解析的图标数据。</li><li>开发者需要根据这个URL自行加载图片资源（例如通过QImageReader等工具），然后转换成QIcon对象，最后更新UI。</li></ul></li></ol> 
<p>总结来说，<code>iconChanged</code> 提供了 favicon 图片的实体数据，可以直接用于界面更新；而 <code>iconUrlChanged</code> 提供的是图片资源的网址，开发者需要进一步处理才能获取到图片数据。在实际应用中，根据需求可以选择监听其中一个或两个信号，前者更适合快速更新UI，后者则提供了更大的灵活性，但需要额外的处理步骤。</p> 
<p></p> 
<h3>6、void QWebEngineView::loadFinished(bool <em>ok</em>)</h3> 
<p><code>void QWebEngineView::loadFinished(bool ok)</code> 是Qt WebEngine模块中QWebEngineView类的一个信号。当网页加载完毕时，不论加载成功与否，该信号都会被触发。</p> 
<p>参数 <code>bool ok</code> 表示加载操作是否成功。如果 <code>ok</code> 为 <code>true</code>，则表示网页加载顺利完成；如果为 <code>false</code>，则表示加载过程中遇到了错误或中断。</p> 
<p>开发者通常会连接到这个信号来执行网页加载完成后的后续操作，例如：</p> 
<div> 
 <pre><code>QObject::connect(webView, &amp;QWebEngineView::loadFinished, [=](bool success){
    if (success) {
        qDebug() &lt;&lt; "Web page loaded successfully.";
        // 执行加载成功后的操作，例如隐藏进度条、启用UI元素等
    } else {
        qDebug() &lt;&lt; "Failed to load web page!";
        // 执行加载失败后的操作，例如显示错误信息、尝试重新加载等
    }
});</code></pre> 
</div> 
<p>这个信号非常重要，因为它可以帮助开发者跟踪网页加载的状态，并根据加载结果执行相应的程序逻辑。</p> 
<p></p> 
<h3>7、void QWebEngineView::loadProgress(int <em>progress</em>)</h3> 
<p><code>void QWebEngineView::loadProgress(int progress)</code> 是Qt WebEngine模块中QWebEngineView类的一个信号。当网页加载的过程中，这个信号会被周期性地发射，告知当前加载的进度百分比。</p> 
<p>参数 <code>int progress</code> 是一个介于0到100之间的整数，代表网页加载的进度。0表示加载尚未开始或刚刚开始，100表示加载已完成。</p> 
<p>开发者可以连接到这个信号来实时显示网页加载的进度，例如在进度条上反映出来</p> 
<div> 
 <pre><code>QObject::connect(webView, &amp;QWebEngineView::loadProgress, [=](int currentProgress){
    progressBar-&gt;setValue(currentProgress);
    // 这里的progressBar是一个QProgressBar对象，用于显示加载进度
});</code></pre> 
</div> 
<p>这样一来，每当网页加载的进度发生变化时，进度条就会相应地更新其值，让用户直观地了解到加载的过程。</p> 
<p></p> 
<p></p> 
<h3>8、void QWebEngineView::loadStarted()</h3> 
<p><code>void QWebEngineView::loadStarted()</code> 是Qt WebEngine模块中QWebEngineView类的一个信号。当QWebEngineView开始加载一个网页时，该信号会被立即触发。</p> 
<p>开发者通常会连接到这个信号来执行网页加载开始时的一些操作，例如显示加载动画、禁用某些交互功能等，以表明网页正在加载中。以下是一个简单的示例：</p> 
<div> 
 <pre><code>QObject::connect(webView, &amp;QWebEngineView::loadStarted, [=](){
    // 显示加载进度条或加载动画
    loadingIndicator-&gt;start();
    // 禁止用户与界面的某些交互
    someInteractiveWidget-&gt;setEnabled(false);
    qDebug() &lt;&lt; "Web page loading started...";
});</code></pre> 
</div> 
<p>在这段代码中，当网页加载开始时，loadingIndicator（加载指示器）会被启动，同时某个交互式小部件（someInteractiveWidget）会被禁用，以防止用户在加载期间进行无效的操作。同时，控制台会打印一条消息表示加载已经开始。</p> 
<p></p> 
<h3>9、void QWebEngineView::reload()</h3> 
<p><code>void QWebEngineView::reload()</code> 是Qt WebEngine模块中的 <code>QWebEngineView</code> 类的一个成员函数。调用此函数会导致当前在 <code>QWebEngineView</code> 视图中加载的网页重新加载。这意味着它会终止当前页面的加载（如果还在加载中），并从服务器重新获取该页面的最新版本。</p> 
<p>在实际应用中，可能在需要更新网页内容或者处理网页刷新逻辑时使用此方法。例如，当用户点击刷新按钮或者程序需要确保显示的是最新网页数据时，可以调用 <code>reload()</code> 函数来实现页面刷新。</p> 
<p>以下是调用该函数的基本示例：</p> 
<div> 
 <pre><code>QWebEngineView *webView = new QWebEngineView(parent);
// ... 进行视图初始化及加载URL等操作 ...
// 当需要刷新页面时
webView-&gt;reload();</code></pre> 
</div> 
<p></p> 
<h3>10、void QWebEngineView::renderProcessTerminated(<a href="https://doc.qt.io/qt-5/qwebenginepage.html#RenderProcessTerminationStatus-enum" rel="nofollow" title="QWebEnginePage::RenderProcessTerminationStatus">QWebEnginePage::RenderProcessTerminationStatus</a> <em>terminationStatus</em>, int <em>exitCode</em>)</h3> 
<p><code>void QWebEngineView::renderProcessTerminated(QWebEnginePage::RenderProcessTerminationStatus terminationStatus, int exitCode)</code> 是Qt WebEngine模块中QWebEngineView类的一个信号。当网页渲染进程突然终止时，这个信号会被触发。</p> 
<p>参数说明：</p> 
<blockquote> 
 <ul><li><code>QWebEnginePage::RenderProcessTerminationStatus terminationStatus</code>：表示渲染进程结束的状态，它可以是诸如正常退出、异常退出、被浏览器强制结束等各种情况。</li><li><code>int exitCode</code>：表示渲染进程的退出代码，对于异常退出等情况，这个代码有助于了解进程为何终止的具体原因。</li></ul> 
</blockquote> 
<p>当收到这个信号时，开发者通常需要处理这种情况，比如重新加载网页、显示错误提示或者记录日志等。例如：</p> 
<div> 
 <pre><code>QObject::connect(webView, &amp;QWebEngineView::renderProcessTerminated, [&amp;](QWebEnginePage::RenderProcessTerminationStatus status, int code){
    switch (status) {
    case QWebEnginePage::NormalTerminationStatus:
        qDebug() &lt;&lt; "Render process terminated normally with exit code:" &lt;&lt; code;
        // 可能处理正常结束的逻辑
        break;
    case QWebEnginePage::AbnormalTerminationStatus:
        qDebug() &lt;&lt; "Render process terminated abnormally with exit code:" &lt;&lt; code;
        // 可能需要重新加载页面或其他恢复措施
        webView-&gt;reload();
        break;
    case QWebEnginePage::CrashedStatus:
        qDebug() &lt;&lt; "Render process crashed with exit code:" &lt;&lt; code;
        // 可能需要显示错误信息或采取其他错误处理策略
        QMessageBox::critical(nullptr, "Error", "The render process has crashed.");
        break;
    default:
        // 其他未知情况的处理
        break;
    }
});</code></pre> 
</div> 
<p></p> 
<h3>11、void QWebEngineView::selectionChanged()</h3> 
<p><code>void QWebEngineView::selectionChanged()</code> 是Qt WebEngine模块中QWebEngineView类的一个信号。当用户在网页中更改文本选择（例如高亮选中文本）时，这个信号会被触发。</p> 
<p>当您连接到此信号时，可以编写相应的槽函数来接收通知，并据此执行相应的操作，比如获取当前选中的文本、复制到剪贴板，或者做其他的文本处理工作。以下是一个基本的示例：</p> 
<div> 
 <pre><code>QObject::connect(webView, &amp;QWebEngineView::selectionChanged, [=]() {
    QString selectedText = webView-&gt;selectedText();
    qDebug() &lt;&lt; "Selected text changed to: " &lt;&lt; selectedText;
    // 在这里可以处理选中文本的变化，比如显示到另一个控件，或者保存到剪贴板等操作
});</code></pre> 
</div> 
<p>当网页中的文本选择发生变化时，上述代码会捕获到这个事件，并打印出当前选中的文本。</p> 
<p></p> 
<h3>12、void QWebEngineView::stop()</h3> 
<p><code>void QWebEngineView::stop()</code> 是Qt WebEngine模块中QWebEngineView类的一个成员函数。当调用这个函数时，它会停止当前正在加载或渲染的网页。也就是说，如果QWebEngineView正在加载一个网页，或者执行JavaScript脚本、播放媒体等操作，调用此函数将会中止这些活动。</p> 
<p>在实际应用中，这个函数常常被用于用户取消加载或者遇到网络问题需要提前结束加载任务的情况。例如，当用户按下“停止加载”按钮时：</p> 
<div> 
 <pre><code>QPushButton *stopButton = new QPushButton("Stop Loading", this);
QObject::connect(stopButton, &amp;QPushButton::clicked, webView, &amp;QWebEngineView::stop);</code></pre> 
</div> 
<p></p> 
<h3>13、void QWebEngineView::titleChanged(const <a href="https://doc.qt.io/qt-5/qstring.html" rel="nofollow" title="QString">QString</a> &amp;<em>title</em>)</h3> 
<p><code>void QWebEngineView::titleChanged(const QString &amp;title)</code> 是Qt WebEngine模块中QWebEngineView类的一个信号。当网页标题发生变化时，该信号会被触发，参数 <code>title</code> 包含的是新的网页标题字符串。</p> 
<p>在Web应用开发中，开发者通常会连接到这个信号来更新应用程序界面中的标题栏或标签，以便反映出当前网页的实际标题。例如：</p> 
<div> 
 <pre><code>QObject::connect(webView, &amp;QWebEngineView::titleChanged, [=](const QString &amp;newTitle){
    // 更新窗口标题栏或自定义的标题显示控件
    windowTitleBar-&gt;setText(newTitle);
    // 或者
    this-&gt;setWindowTitle(newTitle);
});</code></pre> 
</div> 
<p>在这个例子中，当网页标题发生变化时，窗口标题栏（<code>windowTitleBar</code>）或整个窗口的标题将会被更新为新的网页标题。</p> 
<p></p> 
<h3>14、void QWebEngineView::urlChanged(const <a href="https://doc.qt.io/qt-5/qurl.html" rel="nofollow" title="QUrl">QUrl</a> &amp;<em>url</em>)</h3> 
<p><code>void QWebEngineView::urlChanged(const QUrl &amp;url)</code> 是Qt WebEngine模块中QWebEngineView类的一个信号。当QWebEngineView中的网页URL发生改变时（例如用户点击链接跳转到新的网页，或者通过JavaScript更改location.href），该信号会被触发。</p> 
<p>信号参数 <code>const QUrl &amp;url</code> 指向的是网页当前加载的新URL地址。开发者通常会连接到这个信号来更新相关的UI元素，例如地址栏，或者追踪用户的导航历史，甚至限制用户只能访问预先批准的一系列URL等等。</p> 
<p>下面是一个简单的示例，展示如何在URL变化时更新地址栏：</p> 
<div> 
 <pre><code>QObject::connect(webView, &amp;QWebEngineView::urlChanged, [=](const QUrl &amp;newUrl){
    addressLineEdit-&gt;setText(newUrl.toString()); // 假设addressLineEdit是一个显示当前URL的lineEdit控件
});</code></pre> 
</div> 
<p>当QWebEngineView中的网页URL发生变化时，上述代码将更新<code>addressLineEdit</code>控件的文本内容为新的URL。</p> 
<p></p> 
<h3>15、QWebEngineView::~QWebEngineView()</h3> 
<p><code>QWebEngineView::~QWebEngineView()</code> 是Qt WebEngine模块中QWebEngineView类的析构函数。当一个QWebEngineView对象的生命期结束时，系统会自动调用这个析构函数来清理和释放该对象占用的资源。</p> 
<p>析构函数的主要作用是：</p> 
<ol><li>清理与QWebEngineView相关的所有资源，例如关闭与之关联的网络请求、释放内存、断开连接的信号槽关系等。</li><li>继承自QObject的析构函数还会自动注销对象，避免产生内存泄漏或悬挂指针。</li></ol> 
<p>通常情况下，程序员无需显式调用析构函数，而是由C++的自动内存管理系统在对象超出作用域或被智能指针删除时自动调用。但在一些需要手动管理内存的情况下，如在堆上创建QWebEngineView对象时，应在不再需要该对象时调用delete运算符来释放对象，进而触发析构函数执行清理工作。</p> 
<p></p> 
<h3>16、void QWebEngineView::closeEvent(<a href="https://doc.qt.io/qt-5/qcloseevent.html" rel="nofollow" title="QCloseEvent">QCloseEvent</a> *<em>event</em>)</h3> 
<p><code>void QWebEngineView::closeEvent(QCloseEvent *event)</code> 是Qt框架中一个覆盖基类QWidget的虚函数。当QWebEngineView窗口接收到关闭事件时（例如用户点击窗口关闭按钮或程序调用了close()函数），该函数会被调用。</p> 
<p>在QWebEngineView中重写这个函数可以让你有机会在窗口关闭前执行特定的操作，例如保存当前状态、清理资源、确认用户是否真的想要关闭等。下面是一个简单的示例：</p> 
<div> 
 <pre><code>void MyWebEngineView::closeEvent(QCloseEvent *event)
{
    // 如果需要确认用户是否真的要关闭窗口，可以弹出对话框询问
    if (maybeSaveOrCancel()) {
        // 用户同意关闭，接受关闭事件
        event-&gt;accept();
    } else {
        // 用户不同意关闭，拒绝关闭事件
        event-&gt;ignore();
    }

    // 在关闭窗口之前还可以执行其他必要的清理操作
    // ...

    // 若未重写此函数，窗口将在接收到关闭事件时直接关闭
    // 通过覆盖此函数，我们可以控制关闭流程
}</code></pre> 
</div> 
<p>在这个示例中，<code>MyWebEngineView</code>是一个继承自<code>QWebEngineView</code>的自定义类，它重写了<code>closeEvent</code>函数。在函数内部，可以根据需要处理关闭事件的行为。</p> 
<p></p> 
<h3>17、void QWebEngineView::contextMenuEvent(<a href="https://doc.qt.io/qt-5/qcontextmenuevent.html" rel="nofollow" title="QContextMenuEvent">QContextMenuEvent</a> *<em>event</em>)</h3> 
<p><code>void QWebEngineView::contextMenuEvent(QContextMenuEvent *event)</code> 是Qt WebEngine模块中QWebEngineView类的一个重载事件处理函数。当用户在QWebEngineView控件内右击鼠标时，会触发上下文菜单事件（context menu event），此时这个函数会被调用。</p> 
<p>在该函数内部，开发者可以自定义上下文菜单的行为，例如显示自定义的菜单项，或者阻止默认的上下文菜单出现。下面是一个简单的示例：</p> 
<div> 
 <pre><code>void MyWebEngineView::contextMenuEvent(QContextMenuEvent *event)
{
    QMenu contextMenu(this);

    // 添加自定义菜单项
    QAction *copyAction = contextMenu.addAction(tr("&amp;Copy"));
    connect(copyAction, &amp;QAction::triggered, this, &amp;MyWebEngineView::copySelection);

    // 显示自定义的上下文菜单
    contextMenu.exec(event-&gt;globalPos());

    // 阻止默认的上下文菜单显示
    event-&gt;accept();
}

// 定义一个槽函数来处理复制操作
void MyWebEngineView::copySelection()
{
    // 获取并复制当前选中的文本
    QString selection = this-&gt;selectedText();
    qApp-&gt;clipboard()-&gt;setText(selection);
}</code></pre> 
</div> 
<p>在上述代码中，当用户在QWebEngineView中右击时，会弹出自定义的上下文菜单，其中包括一个“复制”选项。如果用户点击了“复制”，则会调用<code>copySelection</code>槽函数，将当前选中的文本复制到剪贴板中。同时，调用<code>event-&gt;accept()</code>来阻止默认的上下文菜单出现。</p> 
<p></p> 
<h3>18、<a href="https://doc.qt.io/qt-5/qwebengineview.html#QWebEngineView" rel="nofollow" title="QWebEngineView">QWebEngineView</a> *QWebEngineView::createWindow(<a href="https://doc.qt.io/qt-5/qwebenginepage.html#WebWindowType-enum" rel="nofollow" title="QWebEnginePage::WebWindowType">QWebEnginePage::WebWindowType</a> <em>type</em>)</h3> 
<p><code>QWebEngineView *QWebEngineView::createWindow(QWebEnginePage::WebWindowType type)</code> 是Qt WebEngine模块中QWebEngineView类的一个虚拟成员函数。当网页内部触发了一个需要打开新窗口的事件（例如点击了一个<code>&lt;a target="_blank"&gt;</code>标签或运行了打开新窗口的JavaScript代码）时，这个函数会被调用。</p> 
<p>该函数接收一个枚举参数 <code>QWebEnginePage::WebWindowType type</code>，该参数标识了新窗口的类型，例如新标签页、弹出窗口等。</p> 
<p>开发者需要重写这个函数来创建并返回一个新的QWebEngineView实例，以便处理新窗口的打开和显示。如果不重写此函数，默认情况下可能不会创建新窗口或者显示不当。</p> 
<p>示例代码：</p> 
<div> 
 <pre><code>class CustomWebEngineView : public QWebEngineView
{
    Q_OBJECT
public:
    CustomWebEngineView(QWidget *parent = nullptr) : QWebEngineView(parent) {}

protected:
    virtual QWebEngineView *createWindow(QWebEnginePage::WebWindowType type) override
    {
        // 创建并返回一个新的QWebEngineView实例
        auto newView = new QWebEngineView(parentWidget());
        // 可以根据type调整新窗口的外观或行为
        // ...
        return newView;
    }
};</code></pre> 
</div> 
<p>在上述示例中，每当网页内部触发打开新窗口事件时，<code>createWindow</code>函数会被调用，并返回一个新的QWebEngineView实例。开发者可以根据窗口类型来自定义新窗口的行为和样式，比如将其嵌入到现有窗口中，或者作为一个新的窗口显示。</p> 
<p></p> 
<h3>19、void QWebEngineView::dragEnterEvent(<a href="https://doc.qt.io/qt-5/qdragenterevent.html" rel="nofollow" title="QDragEnterEvent">QDragEnterEvent</a> *<em>e</em>)</h3> 
<p><code>void QWebEngineView::dragEnterEvent(QDragEnterEvent *e)</code> 是Qt WebEngine模块中QWebEngineView类的一个重载事件处理函数。当拖放操作中的鼠标光标进入QWebEngineView控件区域时，会触发dragEnterEvent事件。</p> 
<p>这个函数允许你自定义当拖动数据进入QWebEngineView时的行为，比如决定是否接受这次拖放操作。在函数中，可以检查拖放的数据类型，并设置事件的acceptProposedAction()属性来决定是否允许数据在此控件上放下。</p> 
<div> 
 <pre><code>void MyWebEngineView::dragEnterEvent(QDragEnterEvent *e)
{
    if (e-&gt;mimeData()-&gt;hasFormat("text/plain")) // 检查拖动的数据是否是纯文本格式
    {
        e-&gt;acceptProposedAction(); // 接受这次拖放操作，允许数据在此控件上放下
    }
    else
    {
        e-&gt;ignore(); // 不接受此次拖放操作
    }
}</code></pre> 
</div> 
<p>在这个示例中，如果拖拽的数据类型是纯文本，那么我们允许拖放到QWebEngineView上；否则，忽略这次拖放事件。实际应用中，你可能需要根据你的应用需求来处理不同类型的拖放数据。</p> 
<p></p> 
<h3>20、void QWebEngineView::dragLeaveEvent(<a href="https://doc.qt.io/qt-5/qdragleaveevent.html" rel="nofollow" title="QDragLeaveEvent">QDragLeaveEvent</a> *<em>e</em>)</h3> 
<p><code>void QWebEngineView::dragLeaveEvent(QDragLeaveEvent *e)</code> 是Qt WebEngine模块中QWebEngineView类的一个重载事件处理函数。当拖放操作中的鼠标光标离开QWebEngineView控件区域时，会触发dragLeaveEvent事件。</p> 
<p>这个函数主要用于处理拖放操作期间鼠标离开视图区域的情况，通常在自定义拖放功能时，可以在这个函数中撤销之前在<code>dragEnterEvent</code>或<code>dragMoveEvent</code>中设置的一些视觉效果或状态。</p> 
<p>示例代码：</p> 
<div> 
 <pre><code>void MyWebEngineView::dragLeaveEvent(QDragLeaveEvent *e)
{
    // 在这里可以清除之前在dragEnterEvent或dragMoveEvent中设置的任何临时状态或视觉效果
    // 例如，如果在鼠标进入时改变了背景色，这时可以恢复原来的背景色
    setBackgroundColor(originalBackgroundColor);

    // 默认情况下，接受该事件
    e-&gt;accept();
}</code></pre> 
</div> 
<p>在上述代码中，当拖拽操作离开视图时，视图会恢复到原始背景颜色。实际上，具体的处理逻辑取决于你的应用需求和之前对拖放事件所做的定制。</p> 
<p></p> 
<h3>21、void QWebEngineView::dragMoveEvent(<a href="https://doc.qt.io/qt-5/qdragmoveevent.html" rel="nofollow" title="QDragMoveEvent">QDragMoveEvent</a> *<em>e</em>)</h3> 
<p><code>void QWebEngineView::dragMoveEvent(QDragMoveEvent *e)</code> 是Qt WebEngine模块中QWebEngineView类的一个重载事件处理函数。当拖放操作中的鼠标在QWebEngineView控件区域内移动时，会触发dragMoveEvent事件。</p> 
<p>这个函数主要用来处理拖拽过程中鼠标移动时的交互行为，比如可以检测鼠标当前位置，决定是否允许拖放目标区域，并更新相关反馈信息，例如改变鼠标的形状、更新提示信息等。</p> 
<p>示例代码：</p> 
<div> 
 <pre><code>void MyWebEngineView::dragMoveEvent(QDragMoveEvent *e)
{
    // 检查当前拖放的位置是否满足条件，例如在可接受的范围内
    if (isDropAllowed(e-&gt;pos()))
    {
        // 如果允许放下数据，则接受拖动事件
        e-&gt;acceptProposedAction();
        // 可以在这里更新界面状态，如改变控件的背景颜色，显示即将放置的提示等
    }
    else
    {
        // 否则，拒绝此次拖动事件
        e-&gt;ignore();
    }
}

// 示例辅助函数，检查拖放位置是否满足条件
bool MyWebEngineView::isDropAllowed(const QPoint &amp;pos)
{
    // 这里可以根据实际需求判断pos坐标是否在有效范围内
    // 以下代码仅为示例，实际逻辑需根据具体应用场景编写
    QRect rect = this-&gt;rect();
    return rect.contains(pos);
}</code></pre> 
</div> 
<p>在上述代码中，当拖拽操作在QWebEngineView内移动时，会检查当前位置是否满足放置数据的条件，如果满足则接受拖动事件，反之则忽略。同时，可以根据实际情况在这个函数内实现更多复杂的拖放逻辑。</p> 
<p></p> 
<h3>22、void QWebEngineView::dropEvent(<a href="https://doc.qt.io/qt-5/qdropevent.html" rel="nofollow" title="QDropEvent">QDropEvent</a> *<em>e</em>)</h3> 
<p><code>void QWebEngineView::dropEvent(QDropEvent *e)</code> 是Qt WebEngine模块中QWebEngineView类的一个重载事件处理函数。当用户在QWebEngineView控件上完成拖放操作（即释放鼠标按钮）时，会触发dropEvent事件。</p> 
<p>在该函数中，你可以处理拖放的实际数据交换，获取拖放的数据类型，并将数据应用到QWebEngineView中，例如在网页中插入文本、图片或其他类型的数据。</p> 
<p>下面是一个简单的示例：</p> 
<div> 
 <pre><code>void MyWebEngineView::dropEvent(QDropEvent *e)
{
    if (e-&gt;mimeData()-&gt;hasUrls())
    {
        foreach (const QUrl &amp;url, e-&gt;mimeData()-&gt;urls())
        {
            // 处理URL数据，例如加载拖放的链接
            load(url);
        }
        e-&gt;acceptProposedAction();
    }
    else if (e-&gt;mimeData()-&gt;hasText())
    {
        // 处理文本数据，例如将拖放的文本插入到网页中
        QString text = e-&gt;mimeData()-&gt;text();
        // 这里假设有一个insertTextToWebPage(text)的函数可以将文本插入到网页中
        insertTextToWebPage(text);
        e-&gt;acceptProposedAction();
    }
    else
    {
        e-&gt;ignore();
    }
}</code></pre> 
</div> 
<p>在这个示例中，当用户在QWebEngineView上完成拖放操作时，程序会检查拖放的数据类型。如果是URL链接，则加载该链接；如果是文本，则将其插入到网页中。如果数据类型不支持，则忽略这次拖放事件。</p> 
<p></p> 
<h3>23、bool QWebEngineView::event(<a href="https://doc.qt.io/qt-5/qevent.html" rel="nofollow" title="QEvent">QEvent</a> *<em>ev</em>)</h3> 
<p><code>bool QWebEngineView::event(QEvent *ev)</code> 是Qt框架中QWebEngineView类的一个重载函数。在Qt中，所有继承自QObject的类都可以通过重写event()函数来处理各种事件。这个函数接收一个QEvent指针作为参数，通过检查事件类型并进行适当处理。</p> 
<p>在QWebEngineView中，event()函数可以处理所有发送给QWebEngineView对象的事件，包括但不限于键盘输入、鼠标事件、窗口事件等。如果您想自定义QWebEngineView的行为，比如处理一些特殊的事件或扩展默认行为，可以重写这个函数。</p> 
<p>以下是一个简单的示例，展示了如何在event()函数中处理特定类型的事件：</p> 
<div> 
 <pre><code>bool MyWebEngineView::event(QEvent *ev)
{
    if (ev-&gt;type() == QEvent::KeyPress) {
        QKeyEvent *keyEvent = static_cast&lt;QKeyEvent*&gt;(ev);
        // 处理按键事件，例如禁用某个键的功能
        if (keyEvent-&gt;key() == Qt::Key_F5) {
            // 禁止F5键刷新页面
            ev-&gt;ignore();
            return true;
        }
    }

    // 对于未处理的事件，调用父类的event()函数
    return QWebEngineView::event(ev);
}</code></pre> 
</div> 
<p>在上述代码中，当QWebEngineView接收到按键事件时，会检查是否为F5键，如果是，则忽略该事件（不执行默认的刷新页面操作），并返回true表示事件已被处理。对于其他类型的事件，如果没有特殊处理，就交由QWebEngineView的基类来处理。</p> 
<p></p> 
<h3>24、void QWebEngineView::findText(const <a href="https://doc.qt.io/qt-5/qstring.html" rel="nofollow" title="QString">QString</a> &amp;<em>subString</em>, <a href="https://doc.qt.io/qt-5/qwebenginepage.html#FindFlag-enum" rel="nofollow" title="QWebEnginePage::FindFlags">QWebEnginePage::FindFlags</a> <em>options</em> = QWebEnginePage::FindFlags(), const QWebEngineCallback&lt;bool&gt; &amp;<em>resultCallback</em> = QWebEngineCallback&lt;bool&gt;())</h3> 
<p><code>void QWebEngineView::findText(const QString &amp;subString, QWebEnginePage::FindFlags options = QWebEnginePage::FindFlags(), const QWebEngineCallback&lt;bool&gt; &amp;resultCallback = QWebEngineCallback&lt;bool&gt;())</code> 是Qt WebEngine模块中QWebEngineView类的一个成员函数，用于在网页内容中查找指定的字符串。</p> 
<p>函数参数解释：</p> 
<blockquote> 
 <ul><li> <p><code>const QString &amp;subString</code>：要在网页中搜索的字符串。</p> </li><li> <p><code>QWebEnginePage::FindFlags options</code>：查找选项，可以是以下几种标志的组合（使用|符号连接）：</p> 
   <ul><li><code>QWebEnginePage::CaseSensitively</code>：区分大小写查找。</li><li><code>QWebEnginePage::HighlightAllOccurrences</code>：高亮所有找到的结果。</li><li><code>QWebEnginePage::WordStart</code>：从单词开始处查找。</li><li>其他可能的查找选项。</li></ul></li><li> <p><code>const QWebEngineCallback&lt;bool&gt; &amp;resultCallback</code>：查找结果回调函数，当查找完成时，会调用这个回调函数，并传入一个布尔值表示是否找到了匹配项。</p> </li></ul> 
</blockquote> 
<div> 
 <pre><code>myWebEngineView.findText("搜索关键词", QWebEnginePage::FindFlags(QWebEnginePage::CaseSensitively | QWebEnginePage::HighlightAllOccurrences),
                       [](bool found) {
                           if (found) {
                               qDebug() &lt;&lt; "找到了匹配项";
                           } else {
                               qDebug() &lt;&lt; "未找到匹配项";
                           }
                       });</code></pre> 
</div> 
<p>在上述代码中，我们尝试在网页中查找"搜索关键词"，同时设置查找选项为区分大小写并高亮所有匹配项。当查找操作完成时，会调用提供的lambda表达式作为回调函数，输出查找结果。</p> 
<p></p> 
<h3>25、void QWebEngineView::hideEvent(<a href="https://doc.qt.io/qt-5/qhideevent.html" rel="nofollow" title="QHideEvent">QHideEvent</a> *<em>event</em>)</h3> 
<p><code>void QWebEngineView::hideEvent(QHideEvent *event)</code> 是Qt框架中QWebEngineView类的一个重载事件处理函数。当QWebEngineView控件变为不可见（例如，窗口被最小化或隐藏）时，这个函数会被调用。</p> 
<p>在实际应用中，重写此函数可以让你在控件隐藏时执行特定的操作，例如暂停视频播放、释放资源以节省内存、记录用户行为等。示例代码如下：</p> 
<div> 
 <pre><code>void MyWebEngineView::hideEvent(QHideEvent *event)
{
    // 停止视频播放或其他资源消耗较大的操作
    if (videoPlayer.isPlaying())
        videoPlayer.stop();

    // 记录用户隐藏窗口的时间点或其他相关信息
    logUserAction("Web view hidden");

    // 调用父类的hideEvent方法以确保Qt默认的隐藏事件处理也能被执行
    QWebEngineView::hideEvent(event);
}</code></pre> 
</div> 
<p>在这个示例中，当QWebEngineView被隐藏时，首先会检查并停止视频播放（这里假设<code>videoPlayer</code>是一个视频播放器对象），然后记录用户的隐藏操作。最后调用父类QWebEngineView的<code>hideEvent</code>方法来执行默认的事件处理逻辑。</p> 
<p></p> 
<h3>26、<a href="https://doc.qt.io/qt-5/qwebenginehistory.html" rel="nofollow" title="QWebEngineHistory">QWebEngineHistory</a> *QWebEngineView::history() const</h3> 
<p><code>QWebEngineHistory *QWebEngineView::history() const</code> 是Qt WebEngine模块中QWebEngineView类的一个成员函数。这个函数返回一个指向QWebEngineHistory对象的指针，该对象提供了对当前QWebEngineView浏览历史的访问。</p> 
<p>QWebEngineHistory类提供了很多方法来操作浏览历史，例如：</p> 
<blockquote> 
 <ul><li><code>int count()</code>：返回历史记录中的项目总数。</li><li><code>QUrl urlAt(int index)</code>：返回指定索引处的历史项目URL。</li><li><code>int currentIndex()</code>：返回当前激活页面在历史记录中的索引。</li><li><code>void back()</code>：加载历史记录中的前一个页面。</li><li><code>void forward()</code>：加载历史记录中的下一个页面。</li><li><code>void clear()</code>：清除浏览历史。</li></ul> 
</blockquote> 
<p>通过调用 <code>QWebEngineView::history()</code> 函数，开发者可以获取到QWebEngineView的浏览历史记录，并根据需要进行操作，例如实现前进、后退功能，或者遍历历史记录进行其他操作。</p> 
<p></p> 
<h3>27、void QWebEngineView::load(const <a href="https://doc.qt.io/qt-5/qurl.html" rel="nofollow" title="QUrl">QUrl</a> &amp;<em>url</em>)</h3> 
<p><code>void QWebEngineView::load(const QUrl &amp;url)</code> 是Qt WebEngine模块中QWebEngineView类的一个成员函数。这个函数用于在QWebEngineView控件中加载指定的URL地址，也就是在该视图中打开并显示指定网页的内容。</p> 
<p>使用示例：</p> 
<div> 
 <pre><code>#include &lt;QApplication&gt;
#include &lt;QWebEngineView&gt;
#include &lt;QUrl&gt;

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);

    QWebEngineView webView;
    webView.show();

    // 加载一个URL
    QUrl url("https://www.example.com");
    webView.load(url);

    return app.exec();
}</code></pre> 
</div> 
<p>在这个示例中，我们创建了一个QWebEngineView对象，并使其可见。接着，我们定义了一个QUrl对象，指向"https://www.example.com"，然后调用`webView.load(url)`来加载并显示该网页。当调用这个函数后，QWebEngineView会开始加载指定的网页，并在加载完成后显示其内容。</p> 
<p></p> 
<h3>28、void QWebEngineView::load(const <a href="https://doc.qt.io/qt-5/qwebenginehttprequest.html" rel="nofollow" title="QWebEngineHttpRequest">QWebEngineHttpRequest</a> &amp;<em>request</em>)</h3> 
<p><code>void QWebEngineView::load(const QWebEngineHttpRequest &amp;request)</code> 是Qt WebEngine模块中QWebEngineView类的一个成员函数。不同于仅仅通过URL加载网页，这个函数允许你通过一个详细的HTTP请求对象来加载网页内容。</p> 
<p>使用此函数，你可以更详细地控制发送给服务器的请求，例如设置HTTP方法（GET、POST等）、添加HTTP头、传输数据体等。</p> 
<p>示例代码：</p> 
<div> 
 <pre><code>QWebEngineHttpRequest request;
request.setUrl(QUrl("https://example.com/api/data"));
request.setMethod(QWebEngineHttpRequest::Post); // 设置HTTP方法为POST
request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json"); // 设置Content-Type头

QJsonObject json;
json.insert("key", "value"); // 假设我们要发送JSON数据
QJsonDocument doc(json);
request.setBody(doc.toJson(QJsonDocument::Compact)); // 设置请求体为JSON数据

webView.load(request); // 使用自定义的HTTP请求加载数据</code></pre> 
</div> 
<p>在这个示例中，我们创建了一个QWebEngineHttpRequest对象，并设置了URL、HTTP方法、Content-Type头以及请求体。然后我们将这个自定义的HTTP请求对象传递给<code>webView.load(request)</code>函数，以发起一个带有特定参数的HTTP POST请求。这对于需要与服务器进行复杂交互的Web应用尤其有用。</p> 
<p></p> 
<h3>29、<a href="https://doc.qt.io/qt-5/qwebenginepage.html" rel="nofollow" title="QWebEnginePage">QWebEnginePage</a> *QWebEngineView::page() const</h3> 
<p><code>QWebEnginePage *QWebEngineView::page() const</code> 是Qt WebEngine模块中QWebEngineView类的一个成员函数。这个函数返回与QWebEngineView关联的QWebEnginePage对象的指针。</p> 
<p>QWebEnginePage类提供了更加详细的网页操作接口，比如获取网页内容、执行JavaScript、处理网页加载事件、管理网页cookies、打印网页等。当你需要直接操作或获取与QWebEngineView视图中的网页相关的详细信息时，可以使用这个函数来获取QWebEnginePage对象。</p> 
<p>示例：</p> 
<pre><code class="hljs">QWebEngineView *webView = new QWebEngineView(parent);
// 加载网页...
QWebEnginePage *webPage = webView-&gt;page();

// 现在可以通过webPage对象进行更详细的网页操作
webPage-&gt;runJavaScript("console.log('Hello from JavaScript');");</code></pre> 
<p>在上述示例中，我们首先创建了一个QWebEngineView对象并加载网页，然后通过调用<code>page()</code>函数获取了与之关联的QWebEnginePage对象，并执行了一个JavaScript命令。</p> 
<p></p> 
<h3>30、void QWebEngineView::load(const QWebEngineHttpRequest &amp;request)</h3> 
<p><code>void QWebEngineView::load(const QWebEngineHttpRequest &amp;request)</code> 是Qt WebEngine模块中QWebEngineView类的一个函数，用于根据提供的QWebEngineHttpRequest对象加载网页内容。这个函数允许开发者自定义HTTP请求，包括设置请求方法（如GET、POST等）、请求头和请求体等，从而实现更精细的网页加载控制。</p> 
<p>例如，如果你想通过POST方法发送JSON数据到服务器并加载响应的网页内容，可以这样使用：</p> 
<pre><code class="hljs">QWebEngineHttpRequest request;
request.setUrl(QUrl("http://example.com/api/login")); // 设置请求的URL
request.setMethod(QWebEngineHttpRequest::Post); // 设置请求方法为POST

QJsonObject json;
json["username"] = "testuser";
json["password"] = "testpass";

QJsonDocument doc(json);
request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json"); // 设置Content-Type头
request.setBody(doc.toJson()); // 设置请求体为JSON数据

QWebEngineView *webView = new QWebEngineView(parentWidget);
webView-&gt;load(request); // 使用自定义的HTTP请求加载网页</code></pre> 
<p>在上述代码中，我们创建了一个QWebEngineHttpRequest对象，并设置了URL、HTTP方法、Content-Type头以及请求体，然后将这个请求对象传递给QWebEngineView的load函数，以发起一个POST请求到指定的URL，并加载返回的网页内容。</p> 
<p></p> 
<h3>31、QAction *QWebEngineView::pageAction(QWebEnginePage::WebAction action) const</h3> 
<p><code>QAction *QWebEngineView::pageAction(QWebEnginePage::WebAction action) const</code> 是Qt WebEngine模块中QWebEngineView类的一个成员函数。这个函数用于获取与给定的QWebEnginePage::WebAction相关的QAction对象。</p> 
<p>QWebEnginePage::WebAction是一个枚举类型，列举了一系列与网页操作相关的动作，如后退、前进、刷新、停止加载、复制、粘贴等。当你调用这个函数并传入一个WebAction枚举值时，它会返回一个与该动作关联的QAction对象。</p> 
<p>有了这个QAction对象，你就可以将其添加到菜单、工具栏或者关联快捷键，使用户能够方便地执行这些动作。</p> 
<p>示例：</p> 
<pre><code class="hljs">QAction *backAction = webView-&gt;pageAction(QWebEnginePage::WebAction::Back);
backAction-&gt;setShortcut(QKeySequence::Back); // 设置后退按钮的快捷键为Alt+左方向键
menu-&gt;addAction(backAction); // 将后退动作添加到菜单中</code></pre> 
<p>在上述示例中，我们获取到了与后退操作关联的QAction对象，并为其设置了快捷键，并将其添加到了菜单中。这样，用户就可以通过菜单或快捷键执行后退操作了。</p> 
<p></p> 
<h3>32、void QWebEngineView::setContent(const QByteArray &amp;data, const QString &amp;mimeType = QString(), const QUrl &amp;baseUrl = QUrl())</h3> 
<p><code>void QWebEngineView::setContent(const QByteArray &amp;data, const QString &amp;mimeType = QString(), const QUrl &amp;baseUrl = QUrl())</code> 是Qt WebEngine模块中QWebEngineView类的一个成员函数。这个函数用于将给定的二进制数据加载到QWebEngineView中，并显示为网页内容。</p> 
<p>参数解释：</p> 
<blockquote> 
 <ul><li><code>const QByteArray &amp;data</code>: 包含要显示的网页内容的二进制数据。这可能是HTML、CSS、JavaScript或者其他符合某种MIME类型的文件内容。</li><li><code>const QString &amp;mimeType</code>: 指定数据的MIME类型，例如 "text/html"、"image/jpeg" 等。如果省略此参数，默认为空字符串，通常在这种情况下，如果数据看起来像HTML，WebKit引擎会尝试将其当作HTML处理。</li><li><code>const QUrl &amp;baseUrl</code>: 指定基础URL，用于解析相对URL。如果省略此参数，默认为空QUrl。在处理包含相对URL的文档时，基础URL是非常重要的，因为它会影响资源加载路径的解析。</li></ul> 
</blockquote> 
<p>使用示例：</p> 
<pre><code class="hljs">QByteArray htmlData = "&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello, World!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;";
QUrl base("http://example.com");
webView-&gt;setContent(htmlData, "text/html", base);</code></pre> 
<p>上述代码将一段HTML数据加载到QWebEngineView中，并设置了一个基础URL。这样，如果HTML文档中有引用相对路径的资源（如图像、CSS文件等）</p> 
<h3></h3> 
<h3>33、void QWebEngineView::setHtml(const <a href="https://doc.qt.io/qt-5/qstring.html" rel="nofollow" title="QString">QString</a> &amp;<em>html</em>, const <a href="https://doc.qt.io/qt-5/qurl.html" rel="nofollow" title="QUrl">QUrl</a> &amp;<em>baseUrl</em> = QUrl())</h3> 
<p><code>void QWebEngineView::setHtml(const QString &amp;html, const QUrl &amp;baseUrl = QUrl())</code> 是Qt WebEngine模块中的一个函数，它用于在 <code>QWebEngineView</code> 组件中显示HTML内容。这个函数接受两个参数：</p> 
<blockquote> 
 <ol><li><code>const QString &amp;html</code>: 这是你想要显示的HTML内容字符串。</li><li><code>const QUrl &amp;baseUrl = QUrl()</code>: 这是基础URL，用于解析HTML内容中相对路径的链接和其他资源。如果省略或者留空，默认的基础URL将是空的。</li></ol> 
</blockquote> 
<p>使用示例：</p> 
<pre><code class="hljs">QString htmlContent = "&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello, World!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;";
QUrl baseUri("http://example.com"); // 可以留空，表示没有基础URL
myWebEngineView-&gt;setHtml(htmlContent, baseUri);</code></pre> 
<p>在这段代码中，<code>myWebEngineView</code> 是一个 <code>QWebEngineView</code> 类型的对象，通过调用 <code>setHtml</code> 函数，我们可以把 <code>htmlContent</code> 字符串中的HTML内容显示在这个浏览器组件中，同时指定基础URL为 <code>"http://example.com"</code>。如果HTML内容中有相对路径的链接或引用资源，引擎将使用提供的基础URL来解析它们。</p> 
<p></p> 
<h3>34、void QWebEngineView::setPage(<a href="https://doc.qt.io/qt-5/qwebenginepage.html" rel="nofollow" title="QWebEnginePage">QWebEnginePage</a> *<em>page</em>)</h3> 
<p>QWebEngineView类的一个函数，用于设置QWebEngineView所使用的QWebEnginePage页面对象。</p> 
<p>QWebEngineView是用来显示网页内容的主要视图组件，而QWebEnginePage则是承载网页内容和网页脚本执行环境的实际载体。通过调用 <code>setPage</code> 函数，您可以将一个已经创建好的QWebEnginePage对象赋给QWebEngineView，使视图显示该页面的内容。</p> 
<p>例如：</p> 
<pre><code class="hljs">QWebEnginePage *newPage = new QWebEnginePage(this);
// 可以对newPage做进一步的设置，如设置页面代理、设置JavaScript权限等
QWebEngineView *webView = new QWebEngineView(parent);
webView-&gt;setPage(newPage);
// 加载网页
newPage-&gt;load(QUrl("http://www.example.com"));</code></pre> 
<p>在这段代码中，首先创建了一个新的QWebEnginePage对象<code>newPage</code>，然后创建了一个QWebEngineView对象<code>webView</code>，并通过<code>setPage</code>函数将<code>newPage</code>设置为<code>webView</code>要显示的页面，最后加载了一个网址到<code>newPage</code>中，这样<code>webView</code>就会显示这个网页的内容。</p> 
<p></p> 
<h3>35、<a href="https://doc.qt.io/qt-5/qwebenginesettings.html" rel="nofollow" title="QWebEngineSettings">QWebEngineSettings</a> *QWebEngineView::settings() const</h3> 
<p><code>QWebEngineSettings *QWebEngineView::settings() const</code> 是Qt WebEngine模块中QWebEngineView类的一个成员函数。这个函数返回一个指向QWebEngineSettings对象的指针，该对象包含了与QWebEngineView关联的网页渲染和行为相关的各种设置选项。</p> 
<p>通过这个函数，您可以获取并修改QWebEngineView的各种高级设置，比如：</p> 
<blockquote> 
 <ul><li>JavaScript是否启用</li><li>是否允许弹出窗口</li><li>是否加载图片</li><li>是否启用网页插件</li><li>是否启用网页存储数据（如cookies、localStorage等）</li><li>用户代理字符串设置</li><li>网页安全策略等等</li></ul> 
</blockquote> 
<p>示例：</p> 
<pre><code class="hljs">QWebEngineView *webView = new QWebEngineView(parent);
QWebEngineSettings *settings = webView-&gt;settings();

// 禁止加载图片
settings-&gt;setAttribute(QWebEngineSettings::AutoLoadImages, false);

// 允许JavaScript执行
settings-&gt;setAttribute(QWebEngineSettings::JavascriptEnabled, true);</code></pre> 
<p>在这个示例中，我们首先获取了QWebEngineView的设置对象，然后分别禁止了图片的自动加载，并启用了JavaScript执行。</p> 
<p></p> 
<h3>36、void QWebEngineView::showEvent(<a href="https://doc.qt.io/qt-5/qshowevent.html" rel="nofollow" title="QShowEvent">QShowEvent</a> *<em>event</em>)</h3> 
<p><code>void QWebEngineView::showEvent(QShowEvent *event)</code> 是Qt WebEngine模块中QWebEngineView类的一个覆盖方法，它是对QWidget的showEvent事件进行处理的函数。当QWebEngineView组件即将变为可见状态时（即从隐藏变为显示），这个事件处理器会被调用。</p> 
<p>通常在重写这个方法时，你可以在这里做一些在视图显示之前或者显示时需要执行的操作，比如加载网页、调整视图大小、初始化视图状态等。例如：</p> 
<pre><code class="hljs">void MyWebEngineView::showEvent(QShowEvent *event)
{
    // 调用父类的showEvent方法以确保默认处理得以执行
    QWebEngineView::showEvent(event);

    // 在视图显示时加载一个初始网页
    load(QUrl("https://www.example.com"));

    // 或者执行其他与视图显示相关的操作
}</code></pre> 
<p>在这个示例中，当MyWebEngineView变为可见时，它会加载指定的网页地址。当然，你可以根据实际需求在这个函数中执行其他定制的操作。</p> 
<p></p> 
<h3>37、<a href="https://doc.qt.io/qt-5/qsize.html" rel="nofollow" title="QSize">QSize</a> QWebEngineView::sizeHint() const</h3> 
<p><code>QSize QWebEngineView::sizeHint() const</code> 是Qt WebEngine模块中QWebEngineView类的一个成员函数，它返回一个<code>QSize</code>对象，表示QWebEngineView组件建议的最佳大小（size hint）。</p> 
<p>这个大小通常是由QWebEngineView内部根据其内容（如加载的网页大小）计算得出的，用于向布局管理器提供一个参考大小。布局管理器可以根据这个提示信息来更好地安排组件的布局，但最终的大小可能会因为布局约束或者其他因素而不同于这个size hint。</p> 
<p>在实践中，如果你想要获取QWebEngineView在其内容加载完毕后的理想大小，可以调用这个函数获取。然而，具体的显示大小仍需由其父窗口或布局管理器决定。</p> 
<p></p> 
<h3>38、void QWebEngineView::triggerPageAction(<a href="https://doc.qt.io/qt-5/qwebenginepage.html#WebAction-enum" rel="nofollow" title="QWebEnginePage::WebAction">QWebEnginePage::WebAction</a> <em>action</em>, bool <em>checked</em> = false)</h3> 
<p><code>void QWebEngineView::triggerPageAction(QWebEnginePage::WebAction action, bool checked = false)</code> 是Qt WebEngine模块中QWebEngineView类的一个函数，它用于触发与给定WebAction枚举值关联的页面操作。</p> 
<p>QWebEnginePage::WebAction是一个枚举类型，包含了多种预定义的网页操作，如打开新窗口、后退、前进、刷新、停止加载、打印等。</p> 
<p>函数参数说明：</p> 
<ul><li><code>QWebEnginePage::WebAction action</code>：指定要触发的WebAction操作，例如 <code>QWebEnginePage::Back</code> 表示后退，<code>QWebEnginePage::Reload</code> 表示刷新页面等。</li><li><code>bool checked = false</code>：对于某些操作，如检查/取消检查复选框（例如“是否启用Java”这类设置），这个参数用于指定操作的开关状态。对于大多数WebAction而言，这个参数并不重要，但对于某些涉及状态切换的操作可能需要设置。</li></ul> 
<p>例如，触发页面后退操作：</p> 
<pre><code class="hljs">webEngineView-&gt;triggerPageAction(QWebEnginePage::Back);</code></pre> 
<p>触发页面刷新操作：</p> 
<pre><code class="hljs">webEngineView-&gt;triggerPageAction(QWebEnginePage::Reload);</code></pre> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f794d86a27a5cf198bd9566f4b33010a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">深入理解数据结构第五弹——排序（2）——快速排序</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f956f39206420eec595e346c19a7777b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AIGC专栏10——EasyAnimate 一个新的类SORA文生视频模型 轻松文生视频</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>