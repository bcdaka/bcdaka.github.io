<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】初识 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/bbbe47fa8dcb6bf7518a47d1210f79f4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】初识">
  <meta property="og:description" content="💓 博客主页：江池俊的博客
⏩ 收录专栏：数据结构探索
🎉如果觉得博主的文章还不错的话，请点赞👍收藏🌟 三连支持一下博主💞
目录
一、数据结构的基本认知
1.什么是数据结构
📌数据结构和数据库的区别
2.什么是算法 ？
3.数据结构和算法的重要性
4.如何学好数据结构和算法
二、算法的时间复杂度和空间复杂度
1.算法效率
1.1 如何衡量一个算法的好坏
1.2 算法的复杂度
2.时间复杂度
2.1 时间复杂度的概念
2.2大O的渐进表示法
2.3常见时间复杂度计算举例
3.空间复杂度
4. 常见复杂度对比
欢迎大家来到我的博客，今天我将用这篇文章来带你了解数据结构。
一、数据结构的基本认知 1.什么是数据结构 数据结构（Data Structure）是计算机存储、组织数据的方式，指相互之间存在一种或多种特定关系的数据元素的集合。
📌数据结构和数据库的区别 数据结构
数据结构是指在计算机中组织和存储数据的方式和方法。它关注如何将数据组织成一种特定的形式，以便于操作和使用数据。常见的数据结构包括数组、链表、栈、队列、树和图等。数据结构可以用于解决各种问题，例如搜索、排序、插入和删除等操作。它是在内存中管理数据----增删查改。
数据库 数据库是指一个组织和管理数据的系统。它是一个存储和访问数据的集合，提供了一系列的操作和功能，如数据的增删改查、数据的安全性和完整性保证、数据的并发控制等。数据库用于持久地保存和管理大量的结构化数据，并提供了一种机制来处理数据之间的关系和依赖。它是在磁盘中管理数据----增删查改。
总结
数据结构关注的是如何组织和操作数据本身，而数据库关注的是如何管理和处理大量的数据，并提供了相关的查询和操作功能。数据结构可以用于在程序中临时存储和操作数据，而数据库则更适合于长期存储和管理大量的数据。在实际应用中，数据结构和数据库经常会结合使用，以实现高效的数据操作和管理。
2.什么是算法 ？ 算法（Algorithm）就是定义良好的计算过程，他取一个或一组的值为输入，并产生出一个或一组值作为输出。简单来说算法就是一系列的计算步骤，用来将输入数据转化成输出果。
3.数据结构和算法的重要性 🌴效率和性能：数据结构和算法直接影响程序的效率和性能。通过选择合适的数据结构和实现高效的算法，可以降低程序的时间和空间复杂度，提高程序的执行速度和资源利用率。
🌴问题解决能力：数据结构和算法是解决各种计算问题的基础。它们提供了一种通用的方法和框架来分析、设计和实现解决方案。掌握适当的数据结构和算法可以帮助学生更快、更准确地解决问题。
🌴设计和优化能力：数据结构和算法的理解有助于学生设计和优化复杂系统和软件。学习数据结构和算法可以培养学生的抽象思维能力和问题求解能力，帮助他们设计出结构良好、高效的软件系统。
🌴面试准备：数据结构和算法是计算机科学面试中常被问及的核心内容。对于求职和进入高级学术研究的学生来说，熟练掌握数据结构和算法可以增加他们在面试过程中的竞争力。
🌴扩展性和可维护性：合适的数据结构和算法可以提高系统的可扩展性和可维护性。通过选择适当的数据结构和算法，可以更容易地添加新功能、调整系统性能和处理大规模数据。
4.如何学好数据结构和算法 🌲死磕代码，熟练掌握敲代码，提高这方面的能力
🌲注意画图和思考，提高自己的思维能力
二、算法的时间复杂度和空间复杂度 1.算法效率 1.1 如何衡量一个算法的好坏 如何衡量一个算法的好坏呢？比如对于以下斐波那契数列： long long Fib(int N) { if(N &lt; 3) return 1; return Fib(N-1) &#43; Fib(N-2); } 斐波那契数列的递归实现方式非常简洁，但简洁一定好吗？那该如何衡量其好与坏呢？">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-08-26T23:18:20+08:00">
    <meta property="article:modified_time" content="2023-08-26T23:18:20+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】初识</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>💓 博客主页：<a href="https://blog.csdn.net/2201_75743654?type=blog" title="江池俊的博客">江池俊的博客</a></p> 
 <p>⏩ 收录专栏：<a href="https://blog.csdn.net/2201_75743654/category_12378694.html?spm=1001.2014.3001.5482" title="数据结构探索">数据结构探索</a></p> 
 <p>🎉如果觉得博主的文章还不错的话，请点赞👍收藏🌟 三连支持一下博主💞</p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%A4%E7%9F%A5-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%A4%E7%9F%A5" rel="nofollow">一、数据结构的基本认知</a></p> 
<p id="1.%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#1.%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" rel="nofollow">1.什么是数据结构</a></p> 
<p id="%F0%9F%91%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#%F0%9F%91%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">📌数据结构和数据库的区别</a></p> 
<p id="2.%E4%BB%80%E4%B9%88%E6%98%AF%E7%AE%97%E6%B3%95%20%EF%BC%9F-toc" style="margin-left:40px;"><a href="#2.%E4%BB%80%E4%B9%88%E6%98%AF%E7%AE%97%E6%B3%95%20%EF%BC%9F" rel="nofollow">2.什么是算法 ？</a></p> 
<p id="3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7-toc" style="margin-left:40px;"><a href="#3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7" rel="nofollow">3.数据结构和算法的重要性</a></p> 
<p id="4.%E5%A6%82%E4%BD%95%E5%AD%A6%E5%A5%BD%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-toc" style="margin-left:40px;"><a href="#4.%E5%A6%82%E4%BD%95%E5%AD%A6%E5%A5%BD%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95" rel="nofollow">4.如何学好数据结构和算法</a></p> 
<p id="%E4%BA%8C%E3%80%81%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" rel="nofollow">二、算法的时间复杂度和空间复杂度</a></p> 
<p id="1.%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87-toc" style="margin-left:40px;"><a href="#1.%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87" rel="nofollow">1.算法效率</a></p> 
<p id="1.1%20%E5%A6%82%E4%BD%95%E8%A1%A1%E9%87%8F%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E7%9A%84%E5%A5%BD%E5%9D%8F-toc" style="margin-left:80px;"><a href="#1.1%20%E5%A6%82%E4%BD%95%E8%A1%A1%E9%87%8F%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E7%9A%84%E5%A5%BD%E5%9D%8F" rel="nofollow">1.1 如何衡量一个算法的好坏</a></p> 
<p id="%C2%A01.2%20%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6-toc" style="margin-left:80px;"><a href="#%C2%A01.2%20%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6" rel="nofollow">1.2 算法的复杂度</a></p> 
<p id="2.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc" style="margin-left:40px;"><a href="#2.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" rel="nofollow">2.时间复杂度</a></p> 
<p id="2.1%20%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#2.1%20%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">2.1 时间复杂度的概念</a></p> 
<p id="2.2%E5%A4%A7O%E7%9A%84%E6%B8%90%E8%BF%9B%E8%A1%A8%E7%A4%BA%E6%B3%95-toc" style="margin-left:80px;"><a href="#2.2%E5%A4%A7O%E7%9A%84%E6%B8%90%E8%BF%9B%E8%A1%A8%E7%A4%BA%E6%B3%95" rel="nofollow">2.2大O的渐进表示法</a></p> 
<p id="2.3%E5%B8%B8%E8%A7%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97%E4%B8%BE%E4%BE%8B-toc" style="margin-left:80px;"><a href="#2.3%E5%B8%B8%E8%A7%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97%E4%B8%BE%E4%BE%8B" rel="nofollow">2.3常见时间复杂度计算举例</a></p> 
<p id="3.%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-toc" style="margin-left:40px;"><a href="#3.%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" rel="nofollow">3.空间复杂度</a></p> 
<p id="4.%20%E5%B8%B8%E8%A7%81%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AF%B9%E6%AF%94-toc" style="margin-left:40px;"><a href="#4.%20%E5%B8%B8%E8%A7%81%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AF%B9%E6%AF%94" rel="nofollow">4. 常见复杂度对比</a></p> 
<hr id="hr-toc"> 
<p><span style="color:#fe2c24;"><strong>欢迎大家来到我的博客，今天我将用这篇文章来带你了解数据结构。</strong></span></p> 
<p style="text-align:center;"><span style="color:#fe2c24;"><strong><img alt="" height="410" src="https://images2.imgbox.com/4f/3f/y0lYDtsX_o.jpg" width="718"></strong></span></p> 
<h2 id="%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%A4%E7%9F%A5">一、数据结构的基本认知</h2> 
<h3 id="1.%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">1.什么是数据结构</h3> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>数据结构（Data Structure）是计算机存储、组织数据的方式，指相互之间存在一种或多种特定关系的数据元素的集合。</strong></span></p> 
</blockquote> 
<h4 id="%F0%9F%91%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB">📌数据结构和数据库的区别</h4> 
<p><span style="color:#fe2c24;"><strong> 数据结构</strong></span></p> 
<blockquote> 
 <p><strong>数据结构是指在计算机中组织和存储数据的方式和方法。它关注如何将数据组织成一种特定的形式，以便于操作和使用数据。常见的数据结构包括数组、链表、栈、队列、树和图等。数据结构可以用于解决各种问题，例如搜索、排序、插入和删除等操作。<span style="color:#fe2c24;">它是在内存中管理数据----增删查改。</span></strong></p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>数据库 </strong></span></p> 
<blockquote> 
 <p><strong>数据库是指一个组织和管理数据的系统。它是一个存储和访问数据的集合，提供了一系列的操作和功能，如数据的增删改查、数据的安全性和完整性保证、数据的并发控制等。数据库用于持久地保存和管理大量的结构化数据，并提供了一种机制来处理数据之间的关系和依赖。<span style="color:#fe2c24;">它是在磁盘中管理数据----增删查改。</span></strong></p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong> 总结</strong></span></p> 
<blockquote> 
 <p><strong>数据结构关注的是如何组织和操作数据本身，而数据库关注的是如何管理和处理大量的数据，并提供了相关的查询和操作功能。<span style="color:#956fe7;">数据结构可以用于在程序中临时存储和操作数据，而数据库则更适合于长期存储和管理大量的数据。</span>在实际应用中，数据结构和数据库经常会结合使用，以实现高效的数据操作和管理。</strong></p> 
</blockquote> 
<h3 id="2.%E4%BB%80%E4%B9%88%E6%98%AF%E7%AE%97%E6%B3%95%20%EF%BC%9F">2.什么是算法 ？</h3> 
<blockquote> 
 <p style="margin-left:0;"><span style="color:#fe2c24;"><strong>算法（Algorithm）就是定义良好的计算过程，他取一个或一组的值为输入，并产生出一个或一组值作为输出。简单来说算法就是一系列的计算步骤，用来将输入数据转化成输出果。</strong></span></p> 
</blockquote> 
<h3 id="3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7">3.数据结构和算法的重要性</h3> 
<blockquote> 
 <p>🌴<strong><span style="color:#956fe7;">效率和性能：</span></strong>数据结构和算法直接影响程序的效率和性能。通过选择合适的数据结构和实现高效的算法，可以降低程序的时间和空间复杂度，提高程序的执行速度和资源利用率。</p> 
 <p>🌴<strong><span style="color:#956fe7;">问题解决能力：</span></strong>数据结构和算法是解决各种计算问题的基础。它们提供了一种通用的方法和框架来分析、设计和实现解决方案。掌握适当的数据结构和算法可以帮助学生更快、更准确地解决问题。</p> 
 <p>🌴<strong><span style="color:#956fe7;">设计和优化能力：</span></strong>数据结构和算法的理解有助于学生设计和优化复杂系统和软件。学习数据结构和算法可以培养学生的抽象思维能力和问题求解能力，帮助他们设计出结构良好、高效的软件系统。</p> 
 <p>🌴<span style="color:#956fe7;"><strong>面试准备：</strong></span>数据结构和算法是计算机科学面试中常被问及的核心内容。对于求职和进入高级学术研究的学生来说，熟练掌握数据结构和算法可以增加他们在面试过程中的竞争力。</p> 
 <p>🌴<strong><span style="color:#956fe7;">扩展性和可维护性：</span></strong>合适的数据结构和算法可以提高系统的可扩展性和可维护性。通过选择适当的数据结构和算法，可以更容易地添加新功能、调整系统性能和处理大规模数据。</p> 
</blockquote> 
<h3 id="4.%E5%A6%82%E4%BD%95%E5%AD%A6%E5%A5%BD%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95"><strong><span style="color:#333333;">4.</span><span style="color:#333333;">如何学好数据结构和算法</span></strong></h3> 
<p>🌲<strong>死磕代码，熟练掌握敲代码，提高这方面的能力</strong></p> 
<p><strong> </strong><img alt="" height="396" src="https://images2.imgbox.com/90/7e/TnWkcmhu_o.png" width="469"></p> 
<p>🌲<strong>注意画图和思考，提高自己的思维能力</strong></p> 
<p> <img alt="" height="376" src="https://images2.imgbox.com/57/05/UNg7OcQN_o.png" width="563"></p> 
<h2 id="%E4%BA%8C%E3%80%81%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">二、算法的时间复杂度和空间复杂度</h2> 
<h3 id="1.%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87"><span style="color:#333333;"><strong>1.</strong></span><span style="color:#333333;"><strong>算法效率 </strong></span></h3> 
<h4 id="1.1%20%E5%A6%82%E4%BD%95%E8%A1%A1%E9%87%8F%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E7%9A%84%E5%A5%BD%E5%9D%8F"><span style="color:#333333;"><strong>1.1 </strong></span><span style="color:#333333;"><strong>如何衡量一个算法的好坏 </strong></span></h4> 
<div>
  如何衡量一个算法的好坏呢？比如对于以下斐波那契数列： 
</div> 
<div></div> 
<pre><code class="language-cs">long long Fib(int N)
{
 if(N &lt; 3)
 return 1;
 
 return Fib(N-1) + Fib(N-2);
}</code></pre> 
<p> 斐波那契数列的递归实现方式非常简洁，但简洁一定好吗？那该如何衡量其好与坏呢？</p> 
<h4 id="%C2%A01.2%20%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6"><span style="color:#333333;"><strong>1.2 </strong></span><span style="color:#333333;"><strong>算法的复杂度 </strong></span></h4> 
<blockquote> 
 <p></p> 
 <div> 
  <strong><span style="color:#777777;">算法在编写成可执行程序后，运行时需要耗费时间资源和空间</span><span style="color:#777777;">(</span><span style="color:#777777;">内存</span><span style="color:#777777;">)资源 。因此</span><span style="color:#fe2c24;">衡量一个算法的好坏，一般 是从时间和空间两个维度来衡量的，</span><span style="color:#777777;">即时间复杂度和空间复杂度。 </span></strong> 
 </div> 
 <div> 
  <span style="color:#fe2c24;"><strong>时间复杂度主要衡量一个算法的运行快慢，而空间复杂度主要衡量一个算法运行所需要的额外空间</strong>。</span> 
  <strong><span style="color:#777777;">在计算 机发展的早期，计算机的存储容量很小。所以对空间复杂度很是在乎。但是经过计算机行业的迅速发展，计 算机的存储容量已经达到了很高的程度。所以我们如今已经不需要再特别关注一个算法的空间复杂度。</span></strong> 
 </div> 
</blockquote> 
<h3 id="2.%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span style="color:#333333;"><strong>2.</strong></span><span style="color:#333333;"><strong>时间复杂度 </strong></span></h3> 
<h4 id="2.1%20%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5"><span style="color:#333333;"><strong>2.1 </strong></span><span style="color:#333333;"><strong>时间复杂度的概念 </strong></span></h4> 
<blockquote> 
 <div> 
  <strong><span style="color:#777777;">时间复杂度的定义：在计算机科学中，</span><span style="color:#fe2c24;">算法的时间复杂度是一个函数，</span><span style="color:#777777;">它定量描述了该算法的运行时间。一 </span></strong> 
  <strong><span style="color:#777777;">个算法执行所耗费的时间，从理论上说，是不能算出来的，只有你把你的程序放在机器上跑起来，才能知 </span></strong> 
  <strong><span style="color:#777777;">道。但是我们需要每个算法都上机测试吗？是可以都上机测试，但是这很麻烦，所以才有了时间复杂度这个 </span></strong> 
  <strong><span style="color:#777777;">分析方式。一个算法所花费的时间与其中语句的执行次数成正比例，</span><span style="color:#fe2c24;">算法中的基本操作的执行次数，为算法</span></strong> 
  <span style="color:#fe2c24;"><strong>的时间复杂度。 </strong></span> 
 </div> 
 <div> 
  <strong><span style="color:#777777;">即：找到某条基本语句与问题规模</span><span style="color:#777777;">N</span><span style="color:#777777;">之间的数学表达式，就是算出了该算法的时间复杂度。 </span></strong> 
 </div> 
</blockquote> 
<pre><code class="language-cs">// 请计算一下Func1中++count语句总共执行了多少次？
void Func1(int N)
{
int count = 0;
for (int i = 0; i &lt; N ; ++ i)
  {
     for (int j = 0; j &lt; N ; ++ j)
        {
            ++count;
        }
  }
 
for (int k = 0; k &lt; 2 * N ; ++ k)
  {
      ++count;
  }
int M = 10;
while (M--)
  {
     ++count;
  }
printf("%d\n", count);
}</code></pre> 
<div> 
 <span style="color:#fe2c24;"><strong>Func1 执行的基本操作次数 ：</strong></span> 
</div> 
<div> 
 <span style="color:#777777;"><strong>                                              <img alt="F(N)=N^2+2*N+10" class="mathcode" src="https://images2.imgbox.com/0e/46/255IN3J9_o.png"></strong></span> 
</div> 
<div>
  🔘  
 <span style="color:#777777;">N = 10        F(N) = 130 </span> 
</div> 
<div>
  🔘  
 <span style="color:#777777;">N = 100      F(N) = 10210 </span> 
</div> 
<div>
  🔘  
 <span style="color:#777777;">N = 1000    F(N) = 1002010 </span> 
</div> 
<div></div> 
<div> 
 <span style="color:#777777;">实际中我们计算时间复杂度时，我们其实并不一定要计算精确的执行次数，而只需要</span> 
 <span style="color:#fe2c24;"><strong>大概执行次数，那么这 里我们使用大O的渐进表示法。</strong></span> 
</div> 
<div></div> 
<h4 id="2.2%E5%A4%A7O%E7%9A%84%E6%B8%90%E8%BF%9B%E8%A1%A8%E7%A4%BA%E6%B3%95"><span style="color:#333333;">2.2</span><span style="color:#333333;">大O的渐进表示法</span></h4> 
<blockquote> 
 <div> 
  <span style="color:#fe2c24;"><strong>大O符号（Big O notation）：是用于描述函数渐进行为的数学符号。 </strong></span> 
 </div> 
 <div> 
  <div> 
   <span style="color:#fe2c24;"><strong>推导大O阶方法： </strong></span> 
  </div> 
  <div> 
   <div>
     1.用常数1取代运行时间中的所有加法常数。 
   </div> 
   <div>
     2.在修改后的运行次数函数中，只保留最高阶项。 
   </div> 
   <div>
     3.如果最高阶项存在且不是1，则去除与这个项目相乘的常数。得到的结果就是大O阶。 
   </div> 
  </div> 
 </div> 
</blockquote> 
<p><strong><span style="color:#fe2c24;"> 使用大O的渐进表示法以后，Func1的时间复杂度为:</span></strong></p> 
<p><strong><span style="color:#fe2c24;">                                                                               <img alt="O(N^{2})" class="mathcode" src="https://images2.imgbox.com/4f/48/rmayS1BJ_o.png"></span></strong></p> 
<div>
  🔘  
 <span style="color:#777777;">N = 10          F(N) = 100 </span> 
</div> 
<div>
  🔘  
 <span style="color:#777777;">N = 100        F(N) = 10000 </span> 
</div> 
<div>
  🔘  
 <span style="color:#777777;">N = 1000      F(N) = 1000000</span> 
</div> 
<div></div> 
<blockquote> 
 <div> 
  <strong><span style="color:#777777;">通过上面我们会发现大</span><span style="color:#777777;">O</span><span style="color:#777777;">的渐进表示法</span></strong> 
  <span style="color:#fe2c24;"><strong>去掉了那些对结果影响不大的项</strong></span> 
  <strong><span style="color:#777777;">，简洁明了的表示出了执行次数。 </span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#777777;">另外有些算法的时间复杂度存在最好、平均和最坏情况： </span></strong> 
 </div> 
 <div>
   ☺️ 
  <strong><span style="color:#777777;">最坏情况：任意输入规模的最大运行次数</span><span style="color:#777777;">(</span><span style="color:#777777;">上界</span><span style="color:#777777;">) </span></strong> 
 </div> 
 <div>
   ☺️ 
  <strong><span style="color:#777777;">平均情况：任意输入规模的期望运行次数 </span></strong> 
 </div> 
 <div>
   ☺️ 
  <strong><span style="color:#777777;">最好情况：任意输入规模的最小运行次数</span><span style="color:#777777;">(</span><span style="color:#777777;">下界</span><span style="color:#777777;">) </span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#777777;">例如：在一个长度为</span><span style="color:#777777;">N</span><span style="color:#777777;">数组中搜索一个数据</span><span style="color:#777777;">x </span></strong> 
 </div> 
 <div>
   ☺️ 
  <strong><span style="color:#777777;">最好情况：</span><span style="color:#777777;">1</span><span style="color:#777777;">次找到 </span></strong> 
 </div> 
 <div>
   ☺️ 
  <strong><span style="color:#777777;">最坏情况：</span><span style="color:#777777;">N</span><span style="color:#777777;">次找到 </span></strong> 
 </div> 
 <div>
   ☺️ 
  <strong><span style="color:#777777;">平均情况：</span><span style="color:#777777;">N/2</span><span style="color:#777777;">次找到 </span></strong> 
 </div> 
 <div> 
  <span style="color:#fe2c24;"><strong>在实际中一般情况关注的是算法的最坏运行情况，所以数组中搜索数据时间复杂度为O(N)</strong></span> 
 </div> 
</blockquote> 
<h4 id="2.3%E5%B8%B8%E8%A7%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97%E4%B8%BE%E4%BE%8B"><span style="color:#333333;"><strong>2.3</strong></span><span style="color:#333333;"><strong>常见时间复杂度计算举例 </strong></span></h4> 
<p><strong>实例1：</strong></p> 
<pre><code class="language-cs">// 计算Func2的时间复杂度？
void Func2(int N)
{
 int count = 0;
 for (int k = 0; k &lt; 2 * N ; ++ k)
 {
 ++count;
 }
 int M = 10;
 while (M--)
 {
 ++count;
 }
 printf("%d\n", count);
}</code></pre> 
<p><strong>实例2： </strong></p> 
<pre><code class="language-cs">// 计算Func3的时间复杂度？
void Func3(int N, int M)
{
 int count = 0;
 for (int k = 0; k &lt; M; ++ k)
 {
 ++count;
 }
 for (int k = 0; k &lt; N ; ++ k)
 {
 ++count;
 }
 printf("%d\n", count);
}</code></pre> 
<p><img alt="" height="328" src="https://images2.imgbox.com/ac/d5/XqTfy2TV_o.png" width="620"></p> 
<p></p> 
<p><strong>实例3： </strong></p> 
<pre><code class="language-cs">// 计算Func4的时间复杂度？
void Func4(int N)
{
 int count = 0;
 for (int k = 0; k &lt; 10; ++ k)
 {
 ++count;
 }
 printf("%d\n", count);
}</code></pre> 
<p><img alt="" height="233" src="https://images2.imgbox.com/20/a9/p5czKM2J_o.png" width="619"></p> 
<p></p> 
<p><strong>实例4： </strong></p> 
<pre><code class="language-cs">// 计算strchr的时间复杂度？
const char * strchr ( const char * str, int character );

//在一个字符串数组中查找一个字符的函数
const char* strchr(const char* str, int character)
{
	while (*str)
	{
		if (*str == character)
			return str;
		else
			str++;
	}
	return NULL;
}</code></pre> 
<p><strong>实例5： </strong></p> 
<p></p> 
<pre><code class="language-cs">// 计算BubbleSort的时间复杂度？
void BubbleSort(int* a, int n)
{
 assert(a);
 for (size_t end = n; end &gt; 0; --end)
 {
 int exchange = 0;
 for (size_t i = 1; i &lt; end; ++i)
 {
 if (a[i-1] &gt; a[i])
 {
 Swap(&amp;a[i-1], &amp;a[i]);
 exchange = 1;
 }
 }
 if (exchange == 0)
 break;
 }
}</code></pre> 
<figure class="image"> 
 <img alt="" height="484" src="https://images2.imgbox.com/c0/a2/IIQabTCL_o.png" width="650"> 
 <figcaption> 
  <strong>冒泡排序算法</strong> 
 </figcaption> 
</figure> 
<p></p> 
<p><strong> 实例6：（二分查找法）</strong></p> 
<pre><code class="language-cs">// 计算BinarySearch的时间复杂度？
int BinarySearch(int* a, int n, int x)
{
 assert(a);
 int begin = 0;
 int end = n-1;
 while (begin &lt; end)
 {
 int mid = begin + ((end-begin)&gt;&gt;1);
 if (a[mid] &lt; x)
 begin = mid+1;
 else if (a[mid] &gt; x)
 end = mid;
 else
 return mid;
 }
 return -1;
}</code></pre> 
<p><img alt="" height="924" src="https://images2.imgbox.com/d5/99/MWpg9h12_o.png" width="1029"></p> 
<p><strong>实例7： </strong></p> 
<pre><code class="language-cs">// 计算阶乘递归Fac的时间复杂度？
long long Fac(size_t N)
{
 if(0 == N)
 return 1;
 
 return Fac(N-1)*N;
}</code></pre> 
<p><img alt="" height="423" src="https://images2.imgbox.com/c0/02/Sj5xsRkn_o.png" width="964"></p> 
<p><img alt="" height="446" src="https://images2.imgbox.com/de/56/rreQdL19_o.png" width="834"></p> 
<p><strong>实例8： </strong></p> 
<pre><code class="language-cs">// 计算斐波那契递归Fib的时间复杂度？
long long Fib(size_t N)
{
 if(N &lt; 3)
 return 1;
 
 return Fib(N-1) + Fib(N-2);
}</code></pre> 
<p></p> 
<p></p> 
<div> 
 <span style="color:#fe2c24;"><strong>实例答案及分析： </strong></span> 
</div> 
<div> 
 <strong><span style="color:#777777;">1. </span><span style="color:#777777;">实例</span><span style="color:#777777;">1</span><span style="color:#777777;">基本操作执行了</span><span style="color:#777777;">2N+10</span><span style="color:#777777;">次，通过推导大</span><span style="color:#777777;">O</span><span style="color:#777777;">阶方法知道，时间复杂度为</span><span style="color:#777777;"> O(N) </span></strong> 
</div> 
<div> 
 <strong><span style="color:#777777;">2. </span><span style="color:#777777;">实例</span><span style="color:#777777;">2</span><span style="color:#777777;">基本操作执行了</span><span style="color:#777777;">M+N</span><span style="color:#777777;">次，有两个未知数</span><span style="color:#777777;">M</span><span style="color:#777777;">和</span><span style="color:#777777;">N</span><span style="color:#777777;">，时间复杂度为</span><span style="color:#777777;"> O(N+M) </span></strong> 
</div> 
<div> 
 <strong><span style="color:#777777;">3. </span><span style="color:#777777;">实例</span><span style="color:#777777;">3</span><span style="color:#777777;">基本操作执行了</span><span style="color:#777777;">10</span><span style="color:#777777;">次，通过推导大</span><span style="color:#777777;">O</span><span style="color:#777777;">阶方法，时间复杂度为</span><span style="color:#777777;"> O(1) </span></strong> 
</div> 
<div> 
 <strong><span style="color:#777777;">4. </span><span style="color:#777777;">实例</span><span style="color:#777777;">4</span><span style="color:#777777;">基本操作执行最好</span><span style="color:#777777;">1</span><span style="color:#777777;">次，最坏</span><span style="color:#777777;">N</span><span style="color:#777777;">次，时间复杂度一般看最坏，时间复杂度为</span><span style="color:#777777;"> O(N) </span></strong> 
</div> 
<div> 
 <span style="color:#956fe7;"><strong>5. 实例5基本操作执行最好N次，最坏执行了(N*(N+1)/2次，通过推导大O阶方法+时间复杂度一般看最 </strong><strong>坏，时间复杂度为 O(N^2) </strong></span> 
</div> 
<div> 
 <span style="color:#956fe7;"><strong>6. 实例6基本操作执行最好1次，最坏O(logN)次，时间复杂度为 O(logN) ps：logN在算法分析中表示是底</strong><strong>数为2，对数为N。有些地方会写成lgN。（建议通过折纸查找的方式讲解logN是怎么计算出来的） </strong></span> 
</div> 
<div> 
 <span style="color:#956fe7;"><strong>7. 实例7通过计算分析发现基本操作递归了N次，时间复杂度为O(N)。 </strong></span> 
</div> 
<div> 
 <span style="color:#956fe7;"><strong>8. 实例8通过计算分析发现基本操作递归了2^N次，时间复杂度为O(2^N)。（建议画图递归栈帧的二叉树讲解）</strong></span> 
</div> 
<div></div> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>总结：在计算时间复杂度时，不能直接纯粹数循环，要看算法逻辑。</strong></span></p> 
</blockquote> 
<h3 id="3.%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">3.空间复杂度</h3> 
<blockquote> 
 <div>
   👀 
  <strong><span style="color:#777777;">空间复杂度也是一个数学表达式，是对一个算法在运行过程中</span></strong> 
  <span style="color:#fe2c24;"><strong>临时占用存储空间大小的量度。</strong></span> 
 </div> 
 <div>
   👀 
  <strong><span style="color:#777777;">空间复杂度不是程序占用了多少</span><span style="color:#777777;">bytes</span><span style="color:#777777;">的空间，因为这个也没太大意义，</span><span style="color:#fe2c24;">所以空间复杂度算的是变量的个数。 </span></strong> 
 </div> 
 <div>
   👀 
  <strong><span style="color:#777777;">空间复杂度计算规则基本跟时间复杂度类似，也使用</span></strong> 
  <span style="color:#fe2c24;"><strong>大O渐进表示法</strong>。 </span> 
 </div> 
 <div>
   👀 
  <span style="color:#956fe7;"><strong>注意：</strong></span> 
  <span style="color:#fe2c24;"><strong>函数运行时所需要的栈空间(存储参数、局部变量、一些寄存器信息等)在编译期间已经确定好了，因</strong></span> 
  <span style="color:#fe2c24;"><strong>此空间复杂度主要通过函数在运行时候显式申请的额外空间来确定。</strong></span> 
 </div> 
</blockquote> 
<p><strong>实例1：</strong> </p> 
<pre><code class="language-cs">// 计算BubbleSort的空间复杂度？
void BubbleSort(int* a, int n)
{
 assert(a);
 for (size_t end = n; end &gt; 0; --end)
 {
 int exchange = 0;
 for (size_t i = 1; i &lt; end; ++i)
 {
 if (a[i-1] &gt; a[i])
 {
 Swap(&amp;a[i-1], &amp;a[i]);
 exchange = 1;
 }
 }
 if (exchange == 0)
 break;
 }
}</code></pre> 
<p><strong> 实例2：</strong></p> 
<pre><code class="language-cs">// 计算Fibonacci的空间复杂度？
// 返回斐波那契数列的前n项
long long* Fibonacci(size_t n)
{
 if(n==0)
 return NULL;
 
 long long * fibArray = (long long *)malloc((n+1) * sizeof(long long));
 fibArray[0] = 0;
 fibArray[1] = 1;
 for (int i = 2; i &lt;= n ; ++i)
 {
 fibArray[i] = fibArray[i - 1] + fibArray [i - 2];
 }
 return fibArray;
}</code></pre> 
<p><strong> 实例3：</strong></p> 
<pre><code class="language-cs">// 计算阶乘递归Fac的空间复杂度？
long long Fac(size_t N)
{
 if(N == 0)
 return 1;
 
 return Fac(N-1)*N;
}</code></pre> 
<div> 
 <strong><span style="color:#fe2c24;">实例答案及分析： </span></strong> 
</div> 
<div> 
 <strong><span style="color:#777777;">1. </span><span style="color:#777777;">实例</span><span style="color:#777777;">1</span><span style="color:#777777;">使用了常数个额外空间，所以空间复杂度为</span><span style="color:#777777;"> O(1) </span></strong> 
</div> 
<div> 
 <strong><span style="color:#777777;">2. </span><span style="color:#777777;">实例</span><span style="color:#777777;">2</span><span style="color:#777777;">动态开辟了</span><span style="color:#777777;">N</span><span style="color:#777777;">个空间，空间复杂度为</span><span style="color:#777777;"> O(N)</span></strong> 
</div> 
<div> 
 <div> 
  <strong><span style="color:#777777;">3. </span><span style="color:#777777;">实例</span><span style="color:#777777;">3</span><span style="color:#777777;">递归调用了</span><span style="color:#777777;">N</span><span style="color:#777777;">次，开辟了</span><span style="color:#777777;">N</span><span style="color:#777777;">个栈帧，每个栈帧使用了常数个空间。空间复杂度为</span><span style="color:#777777;">O(N)</span></strong> 
 </div> 
 <div></div> 
</div> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>总结： 空间可以重复利用，不累计，时间是一去不返，要累计的。</strong></span></p> 
</blockquote> 
<h3 id="4.%20%E5%B8%B8%E8%A7%81%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AF%B9%E6%AF%94"><span style="color:#333333;"><strong>4. </strong></span><span style="color:#333333;"><strong>常见复杂度对比 </strong></span></h3> 
<div> 
 <strong><span style="color:#777777;">一般算法常见的复杂度如下：</span></strong> 
</div> 
<div></div> 
<div> 
 <img alt="" height="411" src="https://images2.imgbox.com/c9/e9/SqQer7im_o.png" width="813"> 
</div> 
<div> 
 <img alt="" height="497" src="https://images2.imgbox.com/ec/5d/oGtb2APg_o.png" width="858"> 
</div> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/41/3c/jiGNghRP_o.gif"></p> 
<p>🔥<span style="color:#0d0016;"><strong>好了， 今天的内容就分享到这里了，如果您觉得这篇文章对您有所帮助，请给我一个赞或分享给您的朋友，让更多人受益。您的支持将是我不断创作的动力！</strong></span>🤞</p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e8007a42b0ff323ea3023616d3da0b6b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">前端高频面试题 js中堆和栈的区别和浏览器的垃圾回收机制</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/08fc64229ebb27d141848439f675a447/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C语言】Sleep()函数----详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>