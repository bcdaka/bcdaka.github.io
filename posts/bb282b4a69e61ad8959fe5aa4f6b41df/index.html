<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>手搓交换排序、归并排序、计数排序 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/bb282b4a69e61ad8959fe5aa4f6b41df/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="手搓交换排序、归并排序、计数排序">
  <meta property="og:description" content="文章目录 交换排序冒泡排序快速排序hoare版本挖坑法lomuto前后指针 非递归快速排序 归并排序实现计数实现排序代码测试排序算法性能 交换排序 冒泡排序 void BubbleSort(int* arr, int n) { for (int i = 0; i &lt; n; i&#43;&#43;) { int flag = 0; for (int j = 0; j &lt; n - i - 1; j&#43;&#43;) { if (arr[j] &gt; arr[j &#43; 1]) { Swap(&amp;arr[j], &amp;arr[j &#43; 1]); flag = 1; } } if (0 == flag) break; } } 时间复杂度：O(N^2)
快速排序 快速排序是一种二叉树结构的交换排序方式，基本思想：任取待排元素序列中的某元素作为基准值，按照该基准值将待排序列分割成两子序列，左子序列所有元素均小于该基准值，右子序列均大于该基准值，然后在左子序列，和右子序列重复上述过程，直到待排元素符合预期结果。
void QuickSort(int* arr, int left, int right) { if (left &gt;= right)//left 等于 right说明此时子序列里只有一个数据了，若left 大于 right说明此时子序列为空 { return; } //int meet = hoare_QuickSort(arr, left, right); //int meet = hole_QuickSort(arr, left, right); //int meet = lomuto_QuickSort(arr, left, right); QuickSort(arr, left, meet - 1); QuickSort(arr, meet &#43; 1, right); } 时间复杂度：O(nlogn~n^2)，在以下查找基准值的方法，是以待排序列首元素位基准值，这种方法存在缺陷，使得快速排序的性能下降，时间复杂度及较高。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-02T15:52:55+08:00">
    <meta property="article:modified_time" content="2024-08-02T15:52:55+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">手搓交换排序、归并排序、计数排序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">交换排序</a></li><li><ul><li><a href="#_3" rel="nofollow">冒泡排序</a></li><li><a href="#_28" rel="nofollow">快速排序</a></li><li><ul><li><a href="#hoare_55" rel="nofollow">hoare版本</a></li><li><a href="#_99" rel="nofollow">挖坑法</a></li><li><a href="#lomuto_137" rel="nofollow">lomuto前后指针</a></li></ul> 
   </li><li><a href="#_164" rel="nofollow">非递归快速排序</a></li></ul> 
  </li><li><a href="#_225" rel="nofollow">归并排序</a></li><li><a href="#_300" rel="nofollow">实现计数实现排序</a></li><li><a href="#_387" rel="nofollow">代码测试排序算法性能</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>交换排序</h2> 
<h3><a id="_3"></a>冒泡排序</h3> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> flag<span class="token punctuation">)</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><mark>时间复杂度：O(N^2)</mark></p> 
<h3><a id="_28"></a>快速排序</h3> 
<p>快速排序是一种二叉树结构的交换排序方式，基本思想：任取待排元素序列中的某元素作为基准值，按照该基准值将待排序列分割成两子序列，左子序列所有元素均小于该基准值，右子序列均大于该基准值，然后在左子序列，和右子序列重复上述过程，直到待排元素符合预期结果。</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> right<span class="token punctuation">)</span><span class="token comment">//left 等于 right说明此时子序列里只有一个数据了，若left 大于 right说明此时子序列为空</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//int meet = hoare_QuickSort(arr, left, right);</span>
	<span class="token comment">//int meet = hole_QuickSort(arr, left, right);</span>
	<span class="token comment">//int meet = lomuto_QuickSort(arr, left, right);</span>
	<span class="token function">QuickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> meet <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">QuickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> meet <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>时间复杂度：<mark>O(nlogn~n^2)</mark>，在以下查找基准值的方法，是以待排序列首元素位基准值，这种方法存在缺陷，使得快速排序的性能下降，时间复杂度及较高。</p> 
<p>情景：</p> 
<p>待排序列位有序，降序、升序、所有元素大小相同，这三种场景中将待排序列排序位升序的序列，时间复杂度位O(n^2)，挖坑，找基准值的方法后续补充。（我在详细讲解为什么这三种场景，这么找的基准值）</p> 
<p>空间复杂度：<mark>O(logn ~ n)</mark></p> 
<h4><a id="hoare_55"></a>hoare版本</h4> 
<ul><li>随机选择一个基准值例如：待排序列首元素，定义两个指针，left和riight。</li><li>left指针负责从左到右寻找比基准值大的元素</li><li>right指针负责从右向左寻找比基准值小的元素</li><li>找到后将left和right交换，重复以上过程直到left的值大于right的值时，将基准值与right交换。</li><li>此时right所在的位置就是基准值应该在的位置</li></ul> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">hoare_QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> key <span class="token operator">=</span> left<span class="token punctuation">;</span>
    left<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            right<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            left<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span>
            <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/19/fa/IfUv4sYU_o.png" alt="在这里插入图片描述"></p> 
<p>此时走完循环的最后一步，在left7的位置和right3的位置发生交换后，此时right–,left++，若最外层循环的条件是left &lt; right，此时跳出循环，right和key发生交换，交换完的结果不满足左子序列都小于基准值的标准，是一个错误的代码。不止最外层循环的条件必须是 left &lt;= right，包括内层的两个while循环和if判断语句都是避免这种情况的发生，使得最后一次跳出循环right在left的左边，left在right的右边。</p> 
<p>如果不等与使最后的left越过right，是用left &lt; right的限制条件，不保证left和right同时所指的数据满足右子序列大于基准值，或左子序列小于基准值，而直接与rgiht交换</p> 
<p>找基准值的函数，看似有两层循环，实际上是一层循环，通过left和right遍历数组元素，时间复杂度O(N)</p> 
<p>时间复杂度：找相遇点的时间复杂度为O（n）</p> 
<h4><a id="_99"></a>挖坑法</h4> 
<p>不断挖坑找坑填坑的过程</p> 
<ul><li>随机选择一个基准值，设待排序列首元素为坑位hole，通过变量key保存基准值，此时这个位置就是一个坑，可以用别的数据进行填坑，再定义两个指针，left和riight。</li><li>right指针负责从右向左寻找比基准值小的元素，找到后与将其填入坑中，让right此时所指向的位置设位新的坑</li><li>left指针负责从左到右寻找比基准值大的元素，找到后与将其填入坑中，让left此时所指向的位置设位新的坑</li><li>如此循环直到，不满足left &lt; right后跳出循环，最后将key填入坑hole里，此时hole的位置就是基准值的位置。</li></ul> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">hole_QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> hole <span class="token operator">=</span> left<span class="token punctuation">;</span>
	<span class="token keyword">int</span> key <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;</span> key<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			right<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		arr<span class="token punctuation">[</span>hole<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>
		hole <span class="token operator">=</span> right<span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> key<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			left<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		arr<span class="token punctuation">[</span>hole<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
		hole <span class="token operator">=</span> left<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	arr<span class="token punctuation">[</span>hole<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>
	<span class="token keyword">return</span> hole<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>不同于hoare版本的找基准值，通过挖坑法，在循环里，当left == right就直接跳出，hoare版本的left和right相等时需要判断，当前它们所指的值比基准值大还是小，而挖坑法就不需要考虑，left和right相等时，同时指向的位置是一个坑，坑内不存在有效数据，最后直接将基准值填坑即可。</p> 
<h4><a id="lomuto_137"></a>lomuto前后指针</h4> 
<p>定义两个指针prec，cur，它们只负责找比基准值小的元素。</p> 
<ul><li>初始条件prev指向数组首元素，cur指向prev的下一个元素，初始基准值位于基准值首元素位置</li><li>交换条件：当cur此时指向的值比基准值还要小的话prev加1，然后交换两者指向的值，大的跑到后边，小大跑到前面，若jprev和cur相等就不需要交换，让cur继续向走，找比基准值小的元素。</li><li>直到cur越过边界right，跳出循环，此时prev指向的位置就为基准值的位置</li></ul> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">lomuto_QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> prev <span class="token operator">=</span> left<span class="token punctuation">;</span>
    <span class="token keyword">int</span> cur <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> key <span class="token operator">=</span> left<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>cur <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">++</span>prev <span class="token operator">!=</span> cur<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>prev<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
        cur<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>prev<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> prev<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_164"></a>非递归快速排序</h3> 
<p>实现非递归的快速排序，需要借组数据结构栈。<mark>栈：先进后出</mark></p> 
<p>递归版本的快速排序，通过基准值分割左右子序列，定义了left和right来限定左右子序列的取值范围，也是通过left和right来实现对序列的分割。<strong>找完待排序列的基准值后，通过栈保存左右子序列的取值范围，来模拟递归的场景</strong>。</p> 
<p>由于栈的特殊结构，入栈时先入右区间，最后入左区间，出栈的顺序就为左区间、右区间。</p> 
<ul><li>先将初始左右区间入栈</li><li>在循环里出栈，为了和left，right区分开来，使用begin个end来接收序列的左右区间。</li><li>找基准值，找到基准值后，通过基准值分割新的左右子序列。<code>[begin, key - 1]和[key + 1, begin]</code></li><li>可以先模拟递归左子序列，然后再模拟递归右子序列。<mark>先入栈右区间，再入栈左区间</mark></li><li>直至栈为空时，结束循环，排序完成</li></ul> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">QuickSort_NonR</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Stack st<span class="token punctuation">;</span>
	<span class="token function">StackInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>st<span class="token punctuation">.</span>top<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> begin <span class="token operator">=</span> <span class="token function">StackTop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">StackPop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> end <span class="token operator">=</span> <span class="token function">StackTop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">StackPop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
		<span class="token keyword">int</span> prev <span class="token operator">=</span> begin<span class="token punctuation">;</span>
		<span class="token keyword">int</span> cur <span class="token operator">=</span> begin <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> key <span class="token operator">=</span> begin<span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">&lt;=</span> end<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">++</span>prev <span class="token operator">!=</span> cur<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>prev<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			cur<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>prev<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		key <span class="token operator">=</span> prev<span class="token punctuation">;</span>
        
        
		<span class="token keyword">if</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> key <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span> key <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span> begin<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> end<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">StackPush</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">,</span> key <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
        
	<span class="token punctuation">}</span>
	<span class="token function">StackDestory</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>时间复杂度：<mark>O(nlogn)</mark></p> 
<h2><a id="_225"></a>归并排序</h2> 
<p>归并排序是一种稳定的排序算法，该算法采用分治法，通过递归数组进行分半，递归的对两半序列进行排序，通过不断的将两组有序序列合并为一个有序序列<br> <img src="https://images2.imgbox.com/c0/88/Ys27FgUx_o.png" alt="在这里插入图片描述"></p> 
<ul><li>通过将两个有序序列合并为一个有序序列，称为二路归并</li><li>将1 和 3合并为一个有序序列， <code>1 3</code></li><li>将 <code>1 3</code>和 <code>9</code>合并为 一个有序序列，<code>1 3 9</code></li><li>将10 和 6 合并为一个有序序列 <code>6 10</code></li><li>将 <code>6 10</code>和 <code>1 3 9</code>合并为一个有序序列，<code>1 3 6 9 10</code>，排序完成。<br> <img src="https://images2.imgbox.com/f4/1e/sRsQxOqd_o.png" alt="在这里插入图片描述"></li></ul> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">_MergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> temp<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> right<span class="token punctuation">)</span><span class="token comment">//递归结束条件 [left, right]</span>
	<span class="token punctuation">{<!-- --></span><span class="token comment">//一但left与right重合或left大于right，结束递归</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token function">_MergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">_MergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归，分半</span>

	<span class="token keyword">int</span> begin1 <span class="token operator">=</span> left<span class="token punctuation">;</span>
	<span class="token keyword">int</span> end1 <span class="token operator">=</span> mid<span class="token punctuation">;</span><span class="token comment">//第一个序列的区间，左区间</span>
	<span class="token keyword">int</span> begin2 <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> end2 <span class="token operator">=</span> right<span class="token punctuation">;</span><span class="token comment">//第二个序列的区间，右区间</span>
	<span class="token keyword">int</span> index <span class="token operator">=</span> begin1<span class="token punctuation">;</span><span class="token comment">//临时数组的下标起始，从左区间开始</span>


	<span class="token keyword">while</span> <span class="token punctuation">(</span>begin1 <span class="token operator">&lt;=</span> end1 <span class="token operator">&amp;&amp;</span> begin2 <span class="token operator">&lt;=</span> end2<span class="token punctuation">)</span><span class="token comment">//对两个有序序列进行排序</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>begin1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>begin2<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			temp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>begin1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			temp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>begin2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>begin1 <span class="token operator">&lt;=</span> end1<span class="token punctuation">)</span><span class="token comment">//避免该区间还有剩余</span>
	<span class="token punctuation">{<!-- --></span>
		temp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>begin1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>begin2 <span class="token operator">&lt;=</span> end2<span class="token punctuation">)</span><span class="token comment">//避免该区间还有剩余</span>
	<span class="token punctuation">{<!-- --></span>
		temp<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>begin2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">//将临时数组所有元素拷贝到原数组中。</span>
	<span class="token punctuation">{<!-- --></span>
		arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span><span class="token operator">*</span> temp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">_MergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>实现对两个有序序列排序，合成为一个有序序列，并不会在数组里发生，一但这样做，在归并过程会造成数据丢失、覆盖，这里创建一个同等大小的临时数组，来对序列进行排序。</li><li>这样做就无法在 <code>MergeSort</code>函数里实现递归，需要在创建一个函数命名为 <code>_MergeSort</code>，别忘了将临时数组传递过去</li><li>使用 <code>(left + right) / 2;</code>，来完成对数组进行分半 <code>[left, mid]和[mid + 1, right]</code></li><li>这里的递归步骤与二叉树的后续遍历，特别相似。</li></ul> 
<p>时间复杂度：<mark>O(nlogn)</mark></p> 
<p>空间复杂度：<mark>O(n)</mark></p> 
<h2><a id="_300"></a>实现计数实现排序</h2> 
<p>计数排序：</p> 
<ul><li>基于原序列的最大值和最小值相减后加1的结果开辟一个新数组，用来统计相同元素出现个数</li><li>根据该元素的大小所对应下标，放置该元素出现的个数</li><li>根据统计的结果将序列回收到原来的序列中</li></ul> 
<p><mark>适用范围</mark></p> 
<ul><li> <p><strong>与数据范围集中的情况</strong></p> </li><li> <p><strong>只适用于整数排序，不适用小数</strong></p> </li><li> <p><strong>数据过多，可能会对内存消耗造成负担</strong></p> </li></ul> 
<p>假设现在有一组数据：<code>6 1 2 9 4 2 4 1 4</code>，</p> 
<ul><li> <p>先根据最大值最小值的差值开辟空间，若是根据最大值开辟，当最大值为109万，最小值为100，一共有10个数据，此时根据最大值直接开辟空间会很浪费，109个整形大小的空间，只用来存放10个数据。</p> </li><li> <p>1：2次， 2：2次，4：3次， 6：1次， 9：1次。其余没有出现的数据，默认使用0<br> <img src="https://images2.imgbox.com/14/26/2VWFq4mv_o.png" alt="在这里插入图片描述"></p> </li><li> <p>根据下标打印，下标为1的元素出现2次，打印两个1，下标为2的元素出现两次，打印两个2，依次类推，最终打印的结果为 <code>1 1 2 2 4 4 4 6 9</code>，这就排序完成。</p> </li></ul> 
<hr> 
<ul><li> <p>此时对 <code>100 101 109 105 101 105</code>，进行计数排序。</p> </li><li> <p>更具最大值减去最小值后加1开辟空间，109 - 100 + 1 = 10，给count开辟10个整形大小空间。</p> </li><li> <p>统计每个数据出现的个数，根据该数据对应下标存放在count数组里，而此时数组里下标从0开始，待排序列最小值从100开始，无法一一对应。</p> </li><li> <p>通过将待排序列的每个元素大小减去最小值 <code>0 1 9 5 1 5</code>，即可解决上述问题。</p> </li><li> <p>0：出现1次， 1：出现2次， 5，出现2次， 9：出现1次<br> <img src="https://images2.imgbox.com/32/2b/QBIawYbB_o.png" alt="在这里插入图片描述"></p> </li><li> <p>此时，根据下对对应的此时，打印下标的值，和原序列并不相同，既然之前减去最小值，打印的时候加上最小值即可。<code>100 101 101 105 105 109</code></p> </li></ul> 
<hr> 
<ul><li> <p>当待排序列中存在负数，此时还是更具将待排序列中每个元素减去最小值，更具这个值来对应count下标存放它出现的次数。</p> </li><li> <p><code>-5 -3 2 4 2 1</code>，将每个数据减去最小值，<code>0 2 7 9 2 6</code>，在根据count的次数取下标时，加上最小值即可。</p> </li></ul> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">CountSort1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> max <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> min <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min<span class="token punctuation">)</span>
			min <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> max<span class="token punctuation">)</span>
			max <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//确定数组大小</span>
	<span class="token keyword">int</span> range <span class="token operator">=</span> max <span class="token operator">-</span> min <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">*</span> count <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> range<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"malloc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">memset</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> range<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//统计数组中每个元素出现的次数，并放在对应下标的count数组里</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		count<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> min<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> range<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			arr<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> min<span class="token punctuation">;</span><span class="token comment">//放完数据，index++到下一个位置</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>时间复杂度：<mark>O(N + range)</mark></p> 
<p>空间复杂度：<mark>O(range)</mark></p> 
<h2><a id="_387"></a>代码测试排序算法性能</h2> 
<p>10万个数据(单位：ms)：</p> 
<p>没有看错，很夸张，计数排序的运行结果0ms<br> <img src="https://images2.imgbox.com/a9/7c/hZnG8TJP_o.png" alt="在这里插入图片描述"></p> 
<p>100万个数据(单位：ms)：</p> 
<p>直接选择排序、直接插入排序、冒泡排序性能，没有放出来。<br> <img src="https://images2.imgbox.com/88/50/HWZhVvFF_o.png" alt="在这里插入图片描述"></p> 
<p>1000万个数据(单位：ms)：<br> <img src="https://images2.imgbox.com/d7/0c/8knKyOzk_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f346043f26c3d79b64822780492799a2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python 爬虫项目实战（一）：破解网易云 VIP 免费下载付费歌曲</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/92be3f3a58911cedbe2edad7cd07de80/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据结构： 单向链表</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>