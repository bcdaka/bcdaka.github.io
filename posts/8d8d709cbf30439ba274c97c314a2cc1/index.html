<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>告别冗长代码：Java Lambda 表达式如何简化你的编程 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/8d8d709cbf30439ba274c97c314a2cc1/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="告别冗长代码：Java Lambda 表达式如何简化你的编程">
  <meta property="og:description" content="在现代软件开发中，高效和简洁的代码变得越来越重要。Java作为一门成熟而广泛使用的编程语言，一直在不断进化，以满足开发者的需求。Java 8的推出标志着一次重要的飞跃，其中最引人注目的特性之一便是Lambda表达式。
Lambda表达式为Java带来了函数式编程的灵活性，使得代码不仅更加简洁，还大大提升了可读性和维护性。不再需要冗长的匿名类，开发者可以用更少的代码完成更多的功能。对于那些致力于编写高效、简洁代码的开发者来说，掌握Lambda表达式是不可或缺的技能。
在本篇文章中，我们将深入探讨Java的Lambda表达式，揭示它的强大功能和应用场景。无论你是Java的初学者，还是有多年经验的老手，这篇文章都将带你领略Lambda表达式的魅力，帮助你在编程之旅中迈上新的台阶。
文章目录 1、Lambda表达式概述1.1、Lambda表达式的简介1.2、Lambda 表达式的基本语法1.3、Lambda 表达式的基础示例1.4、Lambda表达式的要求 2、函数式接口2.1、什么是函数式接口2.2、函数式接口的定义2.3、主要的函数式接口2.3.1、接口 `Predicate&lt;T&gt;`2.3.2、接口 `Consumer&lt;T&gt;`2.3.3、接口 `Function&lt;T, R&gt;`2.3.4、接口 `Supplier&lt;T&gt;`2.3.5、接口 `BiConsumer&lt;T, U&gt;`2.3.6、接口 `BiFunction&lt;T, U, R&gt;`2.3.7、接口 `UnaryOperator&lt;T&gt;`：2.3.8、接口 `BinaryOperator&lt;T&gt;`： 3、Lambda 方法引用3.1、Lambda 方法引用的介绍3.2、静态方法引用3.3、实例方法引用3.4、特定类型的任意对象的实例方法引用3.5、构造器引用 4、Lambda 变量捕获4.1、变量捕获的类型4.2、什么是 Effectively Final？4.3、示例：捕获局部变量4.4、不可以捕获的情况4.5、捕获实例变量 5、Lambda 在集合当中的使用5.1、`Collection` 新增接口5.2、`List` 新增接口5.3、`Set` 新增接口5.4、`Map` 新增接口 1、Lambda表达式概述 1.1、Lambda表达式的简介 Java（SE）8 于 2014 年 3 月发布，引入了多个改进特性，其中 Lambda 表达式（Lambda expression，也可称为闭包（Closure））是最受欢迎的新特性之一。
Lambda 表达式允允许把函数作为一个方法的参数，允许在方法中传递代码块，从而实现更加灵活的编程方式。Lambda 表达式可以简化代码，减少样板代码的出现，并且使代码更加易读和易于维护。
Lambda 表达式允许我们通过表达式来代替功能接口。Lambda 表达式就和方法一样，它提供了一个正常的参数列表和一个使用这些参数的主体（body，可以是一个表达式或一个代码块）。
Lambda 表达式为 Java 添加了函数式编程的能力，简化了代码，使得编写简洁的代码成为可能。这一特性特别适用于对集合进行操作的场景。
1.2、Lambda 表达式的基本语法 Lambda 表达式基本上是一个简洁的表示匿名函数的方法，它不需要像匿名类那样繁琐。Lambda 表达式的语法如下：
code(parameters) -&gt; expression 或 (parameters) -&gt; { statements; } 其中 Lambda 表达式的三个组成部分：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-07T08:49:14+08:00">
    <meta property="article:modified_time" content="2024-06-07T08:49:14+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">告别冗长代码：Java Lambda 表达式如何简化你的编程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>在现代软件开发中，高效和简洁的代码变得越来越重要。Java作为一门成熟而广泛使用的编程语言，一直在不断进化，以满足开发者的需求。Java 8的推出标志着一次重要的飞跃，其中最引人注目的特性之一便是Lambda表达式。</p> 
 <p>Lambda表达式为Java带来了函数式编程的灵活性，使得代码不仅更加简洁，还大大提升了可读性和维护性。不再需要冗长的匿名类，开发者可以用更少的代码完成更多的功能。对于那些致力于编写高效、简洁代码的开发者来说，掌握Lambda表达式是不可或缺的技能。</p> 
 <p>在本篇文章中，我们将深入探讨Java的Lambda表达式，揭示它的强大功能和应用场景。无论你是Java的初学者，还是有多年经验的老手，这篇文章都将带你领略Lambda表达式的魅力，帮助你在编程之旅中迈上新的台阶。</p> 
</blockquote> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><ul><li><ul><li><a href="#1Lambda_14" rel="nofollow">1、Lambda表达式概述</a></li><li><ul><li><a href="#11Lambda_16" rel="nofollow">1.1、Lambda表达式的简介</a></li><li><a href="#12Lambda__26" rel="nofollow">1.2、Lambda 表达式的基本语法</a></li><li><a href="#13Lambda__42" rel="nofollow">1.3、Lambda 表达式的基础示例</a></li><li><a href="#14Lambda_74" rel="nofollow">1.4、Lambda表达式的要求</a></li></ul> 
     </li><li><a href="#2_84" rel="nofollow">2、函数式接口</a></li><li><ul><li><a href="#21_86" rel="nofollow">2.1、什么是函数式接口</a></li><li><a href="#22_98" rel="nofollow">2.2、函数式接口的定义</a></li><li><a href="#23_109" rel="nofollow">2.3、主要的函数式接口</a></li><li><ul><li><a href="#231_PredicateT_113" rel="nofollow">2.3.1、接口 `Predicate&lt;T&gt;`</a></li><li><a href="#232_ConsumerT_127" rel="nofollow">2.3.2、接口 `Consumer&lt;T&gt;`</a></li><li><a href="#233_FunctionT_R_140" rel="nofollow">2.3.3、接口 `Function&lt;T, R&gt;`</a></li><li><a href="#234_SupplierT_155" rel="nofollow">2.3.4、接口 `Supplier&lt;T&gt;`</a></li><li><a href="#235_BiConsumerT_U_168" rel="nofollow">2.3.5、接口 `BiConsumer&lt;T, U&gt;`</a></li><li><a href="#236_BiFunctionT_U_R_182" rel="nofollow">2.3.6、接口 `BiFunction&lt;T, U, R&gt;`</a></li><li><a href="#237_UnaryOperatorT_196" rel="nofollow">2.3.7、接口 `UnaryOperator&lt;T&gt;`：</a></li><li><a href="#238_BinaryOperatorT_209" rel="nofollow">2.3.8、接口 `BinaryOperator&lt;T&gt;`：</a></li></ul> 
     </li></ul> 
     </li><li><a href="#3Lambda__224" rel="nofollow">3、Lambda 方法引用</a></li><li><ul><li><a href="#31Lambda__226" rel="nofollow">3.1、Lambda 方法引用的介绍</a></li><li><a href="#32_237" rel="nofollow">3.2、静态方法引用</a></li><li><a href="#33_261" rel="nofollow">3.3、实例方法引用</a></li><li><a href="#34_286" rel="nofollow">3.4、特定类型的任意对象的实例方法引用</a></li><li><a href="#35_300" rel="nofollow">3.5、构造器引用</a></li></ul> 
     </li><li><a href="#4Lambda__333" rel="nofollow">4、Lambda 变量捕获</a></li><li><ul><li><a href="#41_337" rel="nofollow">4.1、变量捕获的类型</a></li><li><a href="#42_Effectively_Final_345" rel="nofollow">4.2、什么是 Effectively Final？</a></li><li><a href="#43_349" rel="nofollow">4.3、示例：捕获局部变量</a></li><li><a href="#44_365" rel="nofollow">4.4、不可以捕获的情况</a></li><li><a href="#45_383" rel="nofollow">4.5、捕获实例变量</a></li></ul> 
     </li><li><a href="#5Lambda__412" rel="nofollow">5、Lambda 在集合当中的使用</a></li><li><ul><li><a href="#51Collection__418" rel="nofollow">5.1、`Collection` 新增接口</a></li><li><a href="#52List__453" rel="nofollow">5.2、`List` 新增接口</a></li><li><a href="#53Set___470" rel="nofollow">5.3、`Set` 新增接口</a></li><li><a href="#54Map__474" rel="nofollow">5.4、`Map` 新增接口</a></li></ul> 
    </li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h5><a id="1Lambda_14"></a>1、Lambda表达式概述</h5> 
<h6><a id="11Lambda_16"></a>1.1、Lambda表达式的简介</h6> 
<p>Java（SE）8 于 2014 年 3 月发布，引入了多个改进特性，其中 Lambda 表达式（Lambda expression，也可称为闭包（Closure））是最受欢迎的新特性之一。</p> 
<p>Lambda 表达式允允许把函数作为一个方法的参数，允许在方法中传递代码块，从而实现更加灵活的编程方式。Lambda 表达式可以简化代码，减少样板代码的出现，并且使代码更加易读和易于维护。</p> 
<p>Lambda 表达式允许我们通过表达式来代替功能接口。Lambda 表达式就和方法一样，它提供了一个正常的参数列表和一个使用这些参数的主体（body，可以是一个表达式或一个代码块）。</p> 
<p>Lambda 表达式为 Java 添加了函数式编程的能力，简化了代码，使得编写简洁的代码成为可能。这一特性特别适用于对集合进行操作的场景。</p> 
<h6><a id="12Lambda__26"></a>1.2、Lambda 表达式的基本语法</h6> 
<p>Lambda 表达式基本上是一个简洁的表示匿名函数的方法，它不需要像匿名类那样繁琐。Lambda 表达式的语法如下：</p> 
<pre><code class="prism language-java"><span class="token function">code</span><span class="token punctuation">(</span>parameters<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> expression 或 <span class="token punctuation">(</span>parameters<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span> statements<span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/03/de/0H1GnQNu_o.png" alt="image-20230707105839045"></p> 
<p>其中 Lambda 表达式的三个组成部分：</p> 
<ol><li>参数列表（<code>parameters</code>）：类似方法中的形参列表，这里的参数是函数式接口里的参数。这里的参数类型可以明确的声明，也可不声明而由 JVM 隐含的推断。另外如果只有一个参数，圆括号也可以省略；</li><li>箭头（-&gt;）：连接参数列表和 Lambda 主体,可理解为 “被用于” 的意思；</li><li>Lambda 主体（<code>expression</code> 或 { <code>statements;</code> }）：可以是表达式也可以代码块，是函数式接口里方法的实现。①、<code>expression</code>：表达式，当 Lambda 体只有一条语句时可以是一个表达式或一个单独的语句；②、<code>statements</code>：代码块，如果 Lambda 体包含多条语句，需要用花括号括起来。③、无论是表达式还是代码块，都可以返回一个值或者什么都不反回。</li></ol> 
<h6><a id="13Lambda__42"></a>1.3、Lambda 表达式的基础示例</h6> 
<p>假设我们有一个字符串列表，我们想要对其排序。使用 Lambda 表达式前后的代码对比如下：</p> 
<p>使用传统方法（匿名内部类）：</p> 
<pre><code class="prism language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> names <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"Peter"</span><span class="token punctuation">,</span> <span class="token string">"Anna"</span><span class="token punctuation">,</span> <span class="token string">"Mike"</span><span class="token punctuation">,</span> <span class="token string">"Xenia"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">String</span> a<span class="token punctuation">,</span> <span class="token class-name">String</span> b<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>匿名内部类: 这里 <code>new Comparator&lt;String&gt;() {...}</code> 创建了一个 <code>Comparator&lt;String&gt;</code> 的匿名实现类。匿名内部类是没有类名的类，直接用其父类或要实现的接口作为其类型。</p> 
<p>使用 Lambda 表达式：</p> 
<pre><code class="prism language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> names <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"Peter"</span><span class="token punctuation">,</span> <span class="token string">"Anna"</span><span class="token punctuation">,</span> <span class="token string">"Mike"</span><span class="token punctuation">,</span> <span class="token string">"Xenia"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">String</span> a<span class="token punctuation">,</span> <span class="token class-name">String</span> b<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token operator">--</span><span class="token operator">-</span> 或者更简洁

<span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>names<span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> a<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h6><a id="14Lambda_74"></a>1.4、Lambda表达式的要求</h6> 
<p>虽然说，Lambda 表达式可以在⼀定程度上简化接口的实现。但是，并不是所有的接口都可以使用 Lambda 表达式来简洁实现的。</p> 
<p>Lambda 表达式毕竟只是⼀个匿名方法。当实现的接口中的方法过多或者多少的时候，Lambda 表达式都是不适用的。</p> 
<p>Lambda 表达式，只能实现函数式接口。</p> 
<hr> 
<h5><a id="2_84"></a>2、函数式接口</h5> 
<h6><a id="21_86"></a>2.1、什么是函数式接口</h6> 
<p>在 Java 中，函数式接口（Functional Interface）是指具有单一抽象方法的接口，但它可以有多个默认（default）或静态（static）方法。Java 8 引入了这个概念，主要是为了支持 Lambda 表达式，同时保持对老代码的兼容性。</p> 
<p>函数式接口的特性：</p> 
<ul><li>单一抽象方法：这是函数式接口的核心特征，它意味着该接口中只有一个没有实现的方法；</li><li>默认方法：Java 8 允许在接口中实现方法，这些方法被称为默认方法。默认方法不影响接口的"函数式接口"状态，因为它们不是抽象的；</li><li>静态方法：接口还可以包含静态方法。这些方法同样不影响接口的函数式接口状态，因为静态方法也是具体实现的。</li></ul> 
<p>函数式接口提供了一种将功能逻辑作为数据传递的方式，极大地增强了 Java 在编写高效且简洁代码方面的能力。随着 Java 版本的迭代，函数式编程已成为开发中不可或缺的工具。</p> 
<h6><a id="22_98"></a>2.2、函数式接口的定义</h6> 
<p>在 Java 中，函数式接口通常通过 <code>@FunctionalInterface</code> 注解来表示。这个注解不是必需的，但它可以帮助编译器检查所标注的接口是否满足函数式接口的条件。标准的定义如下：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">MyFunctionalInterface</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h6><a id="23_109"></a>2.3、主要的函数式接口</h6> 
<p>Java 8 引入了 <code>java.util.function</code> 包，这个包中定义了一系列的内建函数式接口，极大地方便了函数式编程的实践，特别是与 Lambda 表达式的结合使用。</p> 
<h6><a id="231_PredicateT_113"></a>2.3.1、接口 <code>Predicate&lt;T&gt;</code></h6> 
<p>用途：<code>Predicate&lt;T&gt;</code> 接口定义一个参数的方法，返回布尔值。这通常用于判断或过滤数据。</p> 
<p>方法签名：<code>boolean test(T t);</code></p> 
<p>示例：使用 <code>Predicate&lt;T&gt;</code> 过滤一个 <code>List&lt;String&gt;</code>，移除不符合条件的元素。</p> 
<pre><code class="prism language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> names <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"Peter"</span><span class="token punctuation">,</span> <span class="token string">"Anna"</span><span class="token punctuation">,</span> <span class="token string">"Mike"</span><span class="token punctuation">,</span> <span class="token string">"Xenia"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 移除以"M"开头的名字</span>
names<span class="token punctuation">.</span><span class="token function">removeIf</span><span class="token punctuation">(</span>name <span class="token operator">-&gt;</span> name<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h6><a id="232_ConsumerT_127"></a>2.3.2、接口 <code>Consumer&lt;T&gt;</code></h6> 
<p>用途：<code>Consumer&lt;T&gt;</code> 接口定义单一输入参数的 accept 方法，不返回任何结果（<code>void</code> 返回类型），常用于在对象上执行某些操作，如打印数据。</p> 
<p>方法签名：<code>void accept(T t);</code></p> 
<p>示例：使用 <code>Consumer&lt;T&gt;</code> 打印 <code>List</code> 中的每个元素。</p> 
<pre><code class="prism language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> numbers <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
numbers<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>number <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h6><a id="233_FunctionT_R_140"></a>2.3.3、接口 <code>Function&lt;T, R&gt;</code></h6> 
<p>用途：<code>Function&lt;T, R&gt;</code> 接口定义一个接受一个参数并产生结果的方法，常用于映射或转换数据。</p> 
<p>方法签名：<code>R apply(T t);</code></p> 
<p>示例：将字符串转换为其长度。</p> 
<pre><code class="prism language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> names <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"Peter"</span><span class="token punctuation">,</span> <span class="token string">"Anna"</span><span class="token punctuation">,</span> <span class="token string">"Mike"</span><span class="token punctuation">,</span> <span class="token string">"Xenia"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> nameLengths <span class="token operator">=</span> names<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>name <span class="token operator">-&gt;</span> name<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h6><a id="234_SupplierT_155"></a>2.3.4、接口 <code>Supplier&lt;T&gt;</code></h6> 
<p>用途：<code>Supplier&lt;T&gt;</code> 不接受任何参数但返回一个值，并且这个值的类型是泛型 <code>T</code>。它常用于延迟生成或提供值的场景。</p> 
<p>方法签名：<code>T get();</code></p> 
<p>示例：提供当前时间的字符串格式。</p> 
<pre><code class="prism language-java"><span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> currentTime <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Current Time: "</span> <span class="token operator">+</span> currentTime<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h6><a id="235_BiConsumerT_U_168"></a>2.3.5、接口 <code>BiConsumer&lt;T, U&gt;</code></h6> 
<p>用途：接受两个输入参数，无返回结果，用于两元素的操作。</p> 
<p>方法签名：<code>void accept(T t, U u);</code></p> 
<p>示例：打印两个参数的和。</p> 
<pre><code class="prism language-java"><span class="token class-name">BiConsumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> add <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Sum: "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 输出 Sum: 8</span>
add<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
</code></pre> 
<h6><a id="236_BiFunctionT_U_R_182"></a>2.3.6、接口 <code>BiFunction&lt;T, U, R&gt;</code></h6> 
<p>用途：接受两个输入参数，返回一个结果，用于两元素的操作。</p> 
<p>方法签名：<code>R apply(T t, U u);</code></p> 
<p>示例：计算两个参数的和。</p> 
<pre><code class="prism language-java"><span class="token class-name">BiFunction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> add <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token comment">// 计算 1+2 的结果</span>
<span class="token class-name">Integer</span> sum <span class="token operator">=</span> add<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
</code></pre> 
<h6><a id="237_UnaryOperatorT_196"></a>2.3.7、接口 <code>UnaryOperator&lt;T&gt;</code>：</h6> 
<p>用途：一种特殊类型的 <code>Function</code>，输入参数类型和返回类型相同。</p> 
<p>方法：<code>T apply(T t);</code></p> 
<p>示例：计算参数的平方并返回。</p> 
<pre><code class="prism language-java"><span class="token class-name">UnaryOperator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> square <span class="token operator">=</span> x <span class="token operator">-&gt;</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span>
<span class="token class-name">Integer</span> result <span class="token operator">=</span> square<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h6><a id="238_BinaryOperatorT_209"></a>2.3.8、接口 <code>BinaryOperator&lt;T&gt;</code>：</h6> 
<p>用途：一种特殊类型的 <code>BiFunction</code>，其中两个输入参数和返回类型都相同。</p> 
<p>方法：<code>T apply(T t1, T t2);</code></p> 
<p>示例：计算两个参数的积并返回。</p> 
<pre><code class="prism language-java"><span class="token class-name">BinaryOperator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> multiply <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span>
<span class="token class-name">Integer</span> product <span class="token operator">=</span> multiply<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre> 
<hr> 
<h5><a id="3Lambda__224"></a>3、Lambda 方法引用</h5> 
<h6><a id="31Lambda__226"></a>3.1、Lambda 方法引用的介绍</h6> 
<p>在 Java 中，方法引用是一种简化 lambda 表达式的写法，特别是当 lambda 表达式只是直接调用一个已存在的方法时。方法引用提供了一种更清晰、更简洁的方式来引用直接已存在的方法或构造器。</p> 
<p>方法引用有四种主要的类型：</p> 
<ol><li>静态方法引用（ClassName::methodName）；</li><li>实例方法引用（instance::methodName）；</li><li>特定类型的任意对象的实例方法引用（ClassName::methodName）；</li><li>构造器引用（ClassName::new）</li></ol> 
<h6><a id="32_237"></a>3.2、静态方法引用</h6> 
<p>如果函数式接口的实现通过调用一个静态方法来完成，可以使用静态方法引用。</p> 
<p>示例：</p> 
<p>假设我们有以下静态方法：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MathOperations</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">multiplyByTwo</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我们可以这样使用方法引用替代相应的 lambda 表达式：</p> 
<pre><code class="prism language-java"><span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> timesTwo <span class="token operator">=</span> <span class="token class-name">MathOperations</span><span class="token operator">::</span><span class="token function">multiplyByTwo</span><span class="token punctuation">;</span>
<span class="token comment">// 输出 10</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>timesTwo<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
</code></pre> 
<h6><a id="33_261"></a>3.3、实例方法引用</h6> 
<p>当目标引用是一个实例的方法时，可以使用实例方法引用。</p> 
<p>示例：</p> 
<p>假设有一个非静态方法：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Printer</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printUpperCase</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>使用实例方法引用：</p> 
<pre><code class="prism language-java"><span class="token class-name">Printer</span> printer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Printer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> printUpper <span class="token operator">=</span> printer<span class="token operator">::</span><span class="token function">printUpperCase</span><span class="token punctuation">;</span>
<span class="token comment">// 输出 HELLO</span>
printUpper<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
</code></pre> 
<h6><a id="34_286"></a>3.4、特定类型的任意对象的实例方法引用</h6> 
<p>如果方法引用是针对特定类型的任意对象，可以使用 <code>ClassName::methodName。</code></p> 
<p><strong>示例：</strong></p> 
<pre><code class="prism language-java"><span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> upperFunct <span class="token operator">=</span> <span class="token class-name">String</span><span class="token operator">::</span><span class="token function">toUpperCase</span><span class="token punctuation">;</span>
<span class="token comment">// 输出 HELLO</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>upperFunct<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这里，我们引用了 <code>String</code> 类的 <code>toUpperCase</code> 方法。</p> 
<h6><a id="35_300"></a>3.5、构造器引用</h6> 
<p>构造器引用与方法引用类似，但它调用的是类的构造器。</p> 
<p>示例：</p> 
<p>假设我们有以下类：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token string">"Person{name='"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">"'}"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>使用构造器引用：</p> 
<pre><code class="prism language-java"><span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> personCreator <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span> p <span class="token operator">=</span> personCreator<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token string">"John Doe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">// 输出 Person{name='John Doe'}</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre> 
<hr> 
<h5><a id="4Lambda__333"></a>4、Lambda 变量捕获</h5> 
<p>Lambda 表达式与匿名内部类相似，它们都可以访问"外围"作用域中的变量。这种访问外围变量的行为称为"变量捕获"。</p> 
<h6><a id="41_337"></a>4.1、变量捕获的类型</h6> 
<p>在 Lambda 表达式中，可以捕获两种类型的变量：</p> 
<ol><li> <p>实例变量和静态变量：Lambda 表达式内部可以自由使用实例变量和静态变量而不受任何限制，这些变量可以自由地被读取或修改；</p> </li><li> <p>局部变量：可以捕获外围方法的局部变量，但这些局部变量必须是事实上的最终变量（effectively final），即这些变量在初始化后不会再为它们赋新值。</p> </li></ol> 
<h6><a id="42_Effectively_Final_345"></a>4.2、什么是 Effectively Final？</h6> 
<p>一个变量如果被声明为 <code>final</code>，那么它就是最终变量。即使变量没有被声明为 <code>final</code>，但在初始化后从未改变过，那么这个变量也是事实上的最终变量。从 Java 8 开始，这样的未声明为 <code>final</code> 的变量也可以在 Lambda 表达式中被捕获。</p> 
<h6><a id="43_349"></a>4.3、示例：捕获局部变量</h6> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LambdaCaptureExample</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
      	<span class="token comment">// Effectively final variable</span>
        <span class="token class-name">Runnable</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
      	<span class="token comment">// 输出 10</span>
        r<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这个例子中，变量 <code>num</code> 虽然没有被声明为 <code>final</code>，但在初始化之后没有再改变，所以它是事实上的最终变量，可以在 Lambda 表达式中被安全捕获。</p> 
<h6><a id="44_365"></a>4.4、不可以捕获的情况</h6> 
<p>如果尝试在 Lambda 表达式中捕获一个不是事实上的最终变量，编译器将会报错：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LambdaCaptureExample</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
        num <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>  
      	<span class="token comment">// 修改变量，使其不再是 effectively final</span>
        <span class="token class-name">Runnable</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 编译错误</span>
        r<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>因为 <code>num</code> 在初始化后被修改，它不是一个事实上的最终变量，因此不能被 Lambda 表达式捕获。</p> 
<h6><a id="45_383"></a>4.5、捕获实例变量</h6> 
<p>实例变量与静态变量不需要是事实上的最终变量，它们可以在 Lambda 表达式内部被修改：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LambdaCaptureExample</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> staticNum <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> instanceNum <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Runnable</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
          	<span class="token comment">// 直接修改静态变量</span>
            staticNum<span class="token operator">++</span><span class="token punctuation">;</span>  
          	<span class="token comment">// 直接修改实例变量</span>
            instanceNum<span class="token operator">++</span><span class="token punctuation">;</span>
          	<span class="token comment">// 输出 12</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>staticNum <span class="token operator">+</span> instanceNum<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        r<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">new</span> <span class="token class-name">LambdaCaptureExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h5><a id="5Lambda__412"></a>5、Lambda 在集合当中的使用</h5> 
<p>Java 8 在 <code>Collection</code>、<code>List</code>、<code>Set</code>、和 <code>Map</code> 接口中引入了多种新方法，这些方法大都利用 Lambda 表达式来提高编程效率和简化代码。</p> 
<p>下面是这些接口中新增方法的详细介绍：</p> 
<h6><a id="51Collection__418"></a>5.1、<code>Collection</code> 新增接口</h6> 
<p><code>Collection</code> 接口是 <code>List</code> 和 <code>Set</code> 接口的父接口，因此在 <code>Collection</code> 中添加的方法也会影响到这两个接口。以下是新增的几个重要方法：</p> 
<p>①、<code>forEach(Consumer&lt;? super T&gt; action)</code> 对每个元素执行指定的动作。这是内部迭代的一种形式，可以替代外部迭代（即使用 for-each 循环）</p> 
<pre><code class="prism language-java">collection<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>②、<code>stream()</code> 返回集合的顺序 Stream 表达形式，可以进行更复杂的聚合操作</p> 
<pre><code class="prism language-java">collection<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>e <span class="token operator">-&gt;</span> e<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>③、<code>parallelStream()</code> 返回集合的并行 Stream 表达形式，用于并行处理集合元素，适用于数据量大时的场景</p> 
<pre><code class="prism language-java">collection<span class="token punctuation">.</span><span class="token function">parallelStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>e <span class="token operator">-&gt;</span> e<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>④、<code>removeIf(Predicate&lt;? super E&gt; filter)</code> 根据指定的条件（Predicate 表达式）删除元素</p> 
<pre><code class="prism language-java"><span class="token comment">// 删除所有空元素</span>
collection<span class="token punctuation">.</span><span class="token function">removeIf</span><span class="token punctuation">(</span>e <span class="token operator">-&gt;</span> e<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>⑤、<code>spliterator() </code>提供了一种创建可分割迭代器（Spliterator）的方法，适用于 Stream 的并行分解</p> 
<pre><code class="prism language-java"><span class="token class-name">Spliterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> spliterator <span class="token operator">=</span> collection<span class="token punctuation">.</span><span class="token function">spliterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h6><a id="52List__453"></a>5.2、<code>List</code> 新增接口</h6> 
<p>除了继承自 <code>Collection</code> 接口的方法外，<code>List</code> 接口特有的新增方法主要包括：</p> 
<p>①、<code>sort(Comparator&lt;? super E&gt; c)</code> 根据指定的比较器对列表进行排序，此方法直接修改原列表</p> 
<pre><code>list.sort(Comparator.naturalOrder());
</code></pre> 
<p>②、<code>replaceAll(UnaryOperator&lt;E&gt; operator)</code> 根据指定的函数应用运算，替换每个元素</p> 
<pre><code class="prism language-java"><span class="token comment">// 将所有字符串元素转换为大写</span>
list<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token function">toUpperCase</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
</code></pre> 
<h6><a id="53Set___470"></a>5.3、<code>Set</code> 新增接口</h6> 
<p><code>Set</code> 接口没有特别的新增方法，它继承了 <code>Collection</code> 接口的所有新增方法，这包括 <code>forEach</code>, <code>stream</code>, <code>parallelStream</code>, <code>removeIf</code>, 和 <code>spliterator</code>。</p> 
<h6><a id="54Map__474"></a>5.4、<code>Map</code> 新增接口</h6> 
<p><code>Map</code> 接口在 Java 8 中增加了一系列非常有用的方法来简化常见的任务：</p> 
<p>①、<code>forEach(BiConsumer&lt;? super K, ? super V&gt; action)</code> 对每个键值对执行指定的操作</p> 
<pre><code class="prism language-java">map<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">": "</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>②、<code>replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function)</code> 将每个元素替换为函数的结果</p> 
<pre><code class="prism language-java">map<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> value<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>③、<code>computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) </code>如果键对应的值为 <code>null</code>，则尝试计算新的映射，并插入到 <code>Map</code> 中</p> 
<pre><code class="prism language-java">map<span class="token punctuation">.</span><span class="token function">computeIfAbsent</span><span class="token punctuation">(</span><span class="token string">"key"</span><span class="token punctuation">,</span> k <span class="token operator">-&gt;</span> <span class="token string">"New "</span> <span class="token operator">+</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>④、<code>computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</code> 如果键存在，则使用给定的重新映射函数计算其值</p> 
<pre><code class="prism language-java">map<span class="token punctuation">.</span><span class="token function">computeIfPresent</span><span class="token punctuation">(</span><span class="token string">"key"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> v <span class="token operator">+</span> <span class="token string">" Updated"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>⑤、<code>compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</code> 对键进行重新计算，无论原来是否存在</p> 
<pre><code class="prism language-java">map<span class="token punctuation">.</span><span class="token function">compute</span><span class="token punctuation">(</span><span class="token string">"key"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span>v <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"New Value"</span> <span class="token operator">:</span> v <span class="token operator">+</span> <span class="token string">" Computed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>⑥、<code>merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction)</code> 将键映射到给定值和当前值（如果已存在）的重新映射结果</p> 
<pre><code class="prism language-java">map<span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span><span class="token string">"key"</span><span class="token punctuation">,</span> <span class="token string">"New Value"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>v1<span class="token punctuation">,</span> v2<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> v1 <span class="token operator">+</span> <span class="token string">", "</span> <span class="token operator">+</span> v2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这些方法使得对集合进行操作更加灵活和强大，特别是在需要对集合进行批量操作、计算或条件更新时。通过这些工具，Java的集合库更加贴近现代编程需求，使得代码不仅更简洁，而且性能也有所提升。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/90bccbb49cd95af70638ac029f2ed0f6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【大模型】Ollama&#43;open-webui/Anything LLM部署本地大模型构建RAG个人知识库教程（Mac）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/66bc462725975193f9fa30a689e740e6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">前端三大主流框架：React、Vue、Angular</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>