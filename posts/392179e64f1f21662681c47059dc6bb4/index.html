<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法——二分查找 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/392179e64f1f21662681c47059dc6bb4/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="算法——二分查找">
  <meta property="og:description" content="前言：本篇文章继续分享一种新的算法——二分查找。
一.二分查找 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
示例 1:
输入: nums = [-1,0,3,5,9,12], target = 9输出: 4 解释: 9 出现在 nums中并且下标为 4 示例 2:
输入: nums = [-1,0,3,5,9,12], target = 2输出: -1 解释: 2 不存在 nums 中因此返回 -1 按照一般的方法去解决上述题目，我们的第一想法肯定是将数组从头到尾遍历一遍，每个值都跟target进行一次比较，从而判断其是否存在于数组中。
此方法虽然简单，但是在最差的情况下，需要进行n次循环，即时间复杂度为O(N)，如果说在数据量很大的前提下，这样做的速度反而是非常慢的。
但是有了数组已经有序（升序）的前提，所以为了降低时间复杂度，引出二分查找的概念：
取一组数据的中间值与target进行比较，如果相等，就直接返回；
如果中间值比target小，那么数组中的目标值就一定在中间值的右边；
如果中间值比target大，那么数组中的目标值就一定在中间值的左边；
通过中间值的方法，不断将数组拆分成两半，便可以使其中一半不满足条件的数据直接舍弃，无需在进行判断，如此以来的时间复杂度变为O(logN)。
下面来看具体代码：
int search(vector&lt;int&gt;&amp; nums, int target) { int left = 0,right = nums.size() - 1; while(left &lt;= right) { int midnum = left &#43; (right - left) / 2; if(nums[midnum] == target) { return midnum; } else if(nums[midnum] &gt; target) right = midnum - 1; else left = midnum &#43; 1; } return -1; } 二分查找，需要定义两个指针left和right，分别管理要处理的数据的两端，起始时为整个数组的两端。 随后我们需要得出中间值，求中间值有一个细节，如果我们使用(right &#43; left) / 2的方式去求算中间值，那么当left和right均接近于INT_MAX时，就会发生数据越界，所以我们采用上述代码的方式更加稳妥。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-06T10:16:20+08:00">
    <meta property="article:modified_time" content="2024-06-06T10:16:20+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法——二分查找</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>前言：本篇文章继续分享一种新的算法——<strong>二分查找</strong>。</p> 
<hr> 
<h2 style="background-color:transparent;">一.二分查找</h2> 
<blockquote> 
 <p>给定一个 <code>n</code> 个元素<strong>有序的（升序）</strong>整型数组 <code>nums</code> 和一个目标值 <code>target</code>  ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。<br><strong>示例 1:</strong></p> 
 <pre><strong>输入:</strong> <code>nums<span style="background-color:#eef0f4;"> = [-1,0,3,5,9,12], </span>target<span style="background-color:#eef0f4;"> = 9</span></code><strong>输出:</strong> 4
<strong>解释:</strong> 9 出现在 nums中并且下标为 4
</pre> 
 <p><strong>示例 2:</strong></p> 
 <pre><strong>输入:</strong> <code>nums<span style="background-color:#eef0f4;"> = [-1,0,3,5,9,12], target</span><span style="background-color:#eef0f4;"> = 2</span></code><strong>输出:</strong> -1
<strong>解释:</strong> 2 不存在 nums 中因此返回 -1</pre> 
</blockquote> 
<p> 按照一般的方法去解决上述题目，我们的第一想法肯定是<span style="color:#fe2c24;"><strong>将数组从头到尾遍历一遍，每个值都跟target进行一次比较，从而判断其是否存在于数组中</strong></span>。</p> 
<p>此方法虽然简单，但是<strong><span style="background-color:#ffd900;">在最差的情况下，需要进行n次循环，即时间复杂度为O(N)</span></strong>，如果说在<span style="color:#fe2c24;"><strong>数据量很大的前提下，这样做的速度反而是非常慢的</strong></span>。</p> 
<p>但是有了数组已经<span style="color:#fe2c24;"><strong>有序（升序）</strong></span>的前提，所以为了降低时间复杂度，引出二分查找的概念：</p> 
<blockquote> 
 <p><strong>取一组数据的中间值与target进行比较，如果相等，就直接返回；</strong></p> 
 <p><strong>如果中间值比target小，那么数组中的目标值就一定在中间值的右边；</strong></p> 
 <p><strong>如果中间值比target大，那么数组中的目标值就一定在中间值的左边；</strong></p> 
</blockquote> 
<p><strong>通过中间值的方法，不断将数组拆分成两半</strong>，便可以使其中一半不满足条件的数据直接舍弃，无需在进行判断，如此以来的<span style="color:#fe2c24;"><strong>时间复杂度变为O(logN)</strong></span>。</p> 
<p>下面来看具体代码：</p> 
<pre><code class="language-cpp">    int search(vector&lt;int&gt;&amp; nums, int target) {
        int left = 0,right = nums.size() - 1;
        while(left &lt;= right)
        {
            int midnum = left + (right - left) / 2;
            if(nums[midnum] == target)
            {
                return midnum;
            }
            else if(nums[midnum] &gt; target)
                right = midnum - 1;
            else
                left = midnum + 1;
        }
        return -1;
    }</code></pre> 
<p>二分查找，需要<span style="color:#fe2c24;"><strong>定义两个指针left和right</strong></span>，<strong><span style="background-color:#ffd900;">分别管理要处理的数据的两端，起始时为整个数组的两端</span></strong>。 </p> 
<p>随后我们需要<span style="color:#fe2c24;"><strong>得出中间值</strong></span>，求中间值有一个<span style="color:#fe2c24;"><strong>细节</strong></span>，如果我们<strong><span style="background-color:#ffd900;">使用(right + left) / 2的方式去求算中间值，那么当left和right均接近于INT_MAX时，就会发生数据越界</span></strong>，所以我们采用上述代码的方式更加稳妥。</p> 
<p>随后进行比较，<strong><span style="background-color:#ffd900;">当中间值和target相等时，遍返回中间值下标；如果中间值比target大，则说明目标值在中间值的左边，此时更新right，反之则更新left，取半查找</span></strong>。</p> 
<p>直到<strong>找到数据，或者left &gt; right，即数组中不存在target时，循环方可结束</strong>。</p> 
<p>值得注意的是，<span style="color:#fe2c24;"><strong>二分查找并不局限于有序的数组</strong></span>，<strong><span style="background-color:#ffd900;">凡是能够通过某种规律将数据不断分成两半的，均可使用二分查找算法</span></strong>。 </p> 
<hr> 
<h2>二.x的平方根</h2> 
<blockquote> 
 <p>给定一个非负整数 <code>x</code> ，计算并返回 <code>x</code> 的平方根，即实现 <code>int sqrt(int x)</code> 函数。</p> 
 <p>正数的平方根有两个，只输出其中的正数平方根。</p> 
 <p>如果平方根不是整数，输出只保留整数的部分，小数部分将被舍去。</p> 
 <p></p> 
 <p><strong>示例 1:</strong></p> 
 <pre><strong>输入:</strong> x = 4
<strong>输出:</strong> 2
</pre> 
 <p><strong>示例 2:</strong></p> 
 <pre><strong>输入:</strong> x = 8
<strong>输出:</strong> 2
<strong>解释:</strong> 8 的平方根是 2.82842...，由于小数部分将被舍去，所以返回 2</pre> 
</blockquote> 
<p>本题也是一道相对简单的题，因为我们<span style="color:#fe2c24;"><strong>无法使用平方根函数直接解题</strong></span>，所以想要得到一个数的平方根，我们<strong><span style="background-color:#ffd900;">必须从1开始，算每个数的平方，直至算到x的平方，判断是否有一个数的平方为x</span></strong>。</p> 
<p>这其实和从一个升序数组中找一个值是一样的，所以本题为了降低时间复杂度，我们需要采用<span style="color:#fe2c24;"><strong>二分查找</strong></span>的算法：<span style="color:#fe2c24;"><strong>1~x的中点值的平方是否为x作为判断二分条件，随后比较大小进行二分</strong></span>。</p> 
<pre><code class="language-cpp">    int mySqrt(int x) {
        if(x == 0)
            return 0;
        int left = 1, right = x;
        while(left &lt; right)
        {
            long long mid = left + (right - left + 1) / 2;
            long long sum = mid * mid;
            if(sum &gt; x)
                right = mid - 1;
            else
                left = mid;
        }
        return left;
    }</code></pre> 
<p>但是本题有一个特殊情况，因为<span style="color:#fe2c24;"><strong>一个非负整数的平方根不一定也是一个整数</strong></span>，所以我们<span style="color:#fe2c24;"><strong>要取其取余后的整数部分</strong></span>，也就是说<strong><span style="background-color:#ffd900;">实际要求的整数比其平方根要小</span></strong>。</p> 
<p>所以在进行区间截取时，我们需要进行改动， <span style="color:#ff9900;"><strong>因为结果小于等于目标值都有可能，所以我们需要将&lt;=的情况放在一起判断</strong></span>。并且<span style="color:#fe2c24;"><strong>当left变动时，不能再取mid+1，因为有可能mid正好就是那个取余后的整数</strong></span>。</p> 
<p>同样，我们<strong>求中间节点的方法也需要进行优化</strong>：</p> 
<p>实际上除了第一个题目中：<strong>left + (right - left) / 2</strong>这个求中的的方法外，还有一种方法：</p> 
<blockquote> 
 <p><strong>left + (right - left + 1) / 2</strong></p> 
</blockquote> 
<p>那么多的这个<span style="color:#fe2c24;"><strong>＋1</strong></span>，会有什么影响呢？？？ </p> 
<p>首先，当从left到right有<span style="color:#fe2c24;"><strong>奇数</strong></span>个数据时，使用这两种方法，<span style="color:#fe2c24;"><strong>所求mid均为中间值</strong></span>。</p> 
<p>但是当从left到right有<span style="color:#fe2c24;"><strong>偶数</strong></span>个数据时，<strong>前者所求数据为中间值的<span style="color:#fe2c24;">左边</span>，而后者则为中间值的<span style="color:#fe2c24;">右边</span></strong>。</p> 
<p>这又会产生什么影响？？?</p> 
<p>当我们<span style="color:#fe2c24;"><strong>要判断的数据只剩两个时</strong></span>，如果采用 <strong>left + (right - left) / 2</strong>的方式求中点，<span style="color:#fe2c24;"><strong>当遇到判断结果要让left = mid时</strong></span><strong><span style="background-color:#ffd900;">，left就会一直等于mid，永远不可能大于等于right，这样就会造成死循环</span></strong>。</p> 
<p>同理，如果采用 <strong>left + (right - left + 1) / 2</strong>的方式求中点，<span style="color:#fe2c24;"><strong>当遇到判断结果要让right = mid时</strong></span>，同样会造成死循环。</p> 
<p>所以当出现该情况时，我们只需<span style="color:#fe2c24;"><strong>将上述两种求中点的方法进行交换即可避免死循环</strong></span>。</p> 
<hr> 
<h2>三.山峰数组的峰值索引</h2> 
<blockquote> 
 <p>符合下列属性的数组 <code>arr</code> 称为 <strong>山峰数组</strong>（<strong>山脉数组）</strong> ：</p> 
 <ul><li><code>arr.length &gt;= 3</code></li><li>存在 <code>i</code>（<code>0 &lt; i &lt; arr.length - 1</code>）使得： 
   <ul><li><code>arr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i] </code></li><li><code>arr[i] &gt; arr[i+1] &gt; ... &gt; arr[arr.length - 1]</code></li></ul></li></ul> 
 <p>给定由整数组成的山峰数组 <code>arr</code> ，返回任何满足 <code>arr[0] &lt; arr[1] &lt; ... arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code> 的下标 <code>i</code> ，即山峰顶部。</p> 
 <p></p> 
 <p><strong>示例 1：</strong></p> 
 <pre><strong>输入：</strong>arr = [0,1,0]
<strong>输出：</strong>1
</pre> 
 <p><strong>示例 2：</strong></p> 
 <pre><strong>输入：</strong>arr = [1,3,5,4,2]
<strong>输出：2</strong></pre> 
</blockquote> 
<p>题目还是很容易理解的，就是<span style="color:#fe2c24;"><strong>在数组中找到最大的一个数，并返回其下标</strong></span>，<strong><span style="background-color:#ffd900;">该数字大于其左边的数单调递增，右边的数单调递减</span></strong>。</p> 
<p> 我们可以<span style="color:#fe2c24;"><strong>通过直接遍历数组的方法</strong></span>去找这个数，<span style="color:#fe2c24;"><strong>当某数字比它的后一个数大时，即为答案</strong></span>。但是<strong><span style="background-color:#ffd900;">如果该数字为最后一个数，那我们就需要遍历整个数组，时间复杂度为O(N)</span></strong>。</p> 
<p>所以为了优化时间复杂度，<span style="color:#fe2c24;"><strong>虽然这道题不是一个有序的数组，但我们依然可以采用二分查找</strong></span>。</p> 
<p>在该数组中，<span style="color:#fe2c24;"><strong>某个数不是比它的前一个数大，就是比它的前一个数小</strong></span>，所以我们可以依此为判断条件：</p> 
<pre><code class="language-cpp">    int peakIndexInMountainArray(vector&lt;int&gt;&amp; arr) {
        int left = 0,right = arr.size() - 1;
        while(left &lt; right)
        {
            int mid = left + (right - left + 1) / 2;
            if(arr[mid] &lt; arr[mid - 1])
                right = mid - 1;
            else
                left = mid;
        }
        return left;
    }</code></pre> 
<p><strong><span style="background-color:#ffd900;">如果mid &lt; mid - 1，说明mid在山的右侧，此时山峰在左半区，所以right左移</span></strong>；<strong><span style="background-color:#ff9900;">当mid &gt;= mid - 1时， 此时mid在山的左半边，山峰则在右半区，left右移</span></strong>，但是<span style="color:#fe2c24;"><strong>因为山峰是最大的数字，所以此时mid也可能是山峰，所以left的移动不能超过mid</strong></span>。</p> 
<p><strong>mid的计算方法则需按照在第二题中分享的方法进行考虑</strong>。</p> 
<hr> 
<h2>总结</h2> 
<p>二分查找算法适用于<strong><span style="background-color:#ffd900;">能够将数据按照某个条件不断分为两部分，并逐渐缩短数据范围从而寻找目标值的情况</span></strong>，<span style="color:#fe2c24;"><strong>数据并非需要严格有序</strong></span>。</p> 
<p>关于二分算法就分享这么多，喜欢本篇文章记得一键三连，我们下期再见！</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/380febf53bdda4deff502e9352f36942/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LeetCode-数学基础开篇</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dc192997b86155f0a506d64cf19522f0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Flutter_Android上架GooglePlay_问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>