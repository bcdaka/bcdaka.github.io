<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2024.7.19 作业 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/33a69fc7547365ee6a50e02e82363641/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="2024.7.19 作业">
  <meta property="og:description" content="1.链表的排序 int list_sort(NodePtr L) { if(NULL==L || L-&gt;len&lt;=1) { printf(&#34;排序失败&#34;); return -1; } int len=L-&gt;len&#43;1; NodePtr p; int i,j; for( i=1;i&lt;len;i&#43;&#43;) { for( j=0,p=L;j&lt;len-i;j&#43;&#43;,p=p-&gt;next) { if( p-&gt;data &gt; p-&gt;next-&gt;data ) { datatype t=p-&gt;data; p-&gt;data=p-&gt;next-&gt;data; p-&gt;next-&gt;data=t; } } } printf(&#34;排序成功\n&#34;); return 0; } 2.链表的反转（递归实现） // 递归反转链表 NodePtr list_fz(NodePtr L) { // 基础情况：空链表或只有一个节点 if (L == NULL || L-&gt;next == NULL) { return L; } NodePtr new_L = list_fz(L-&gt;next); L-&gt;next-&gt;next = L; L-&gt;next = NULL; return new_L; } 3.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-19T20:25:39+08:00">
    <meta property="article:modified_time" content="2024-07-19T20:25:39+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2024.7.19 作业</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>1.链表的排序</h3> 
<pre><code class="language-cs">int list_sort(NodePtr L)
{
	    if(NULL==L || L-&gt;len&lt;=1)
    	{
	 	    printf("排序失败");
        	return -1;
    	}
   
    	int len=L-&gt;len+1;
    	NodePtr p;
    	int i,j;
    	for( i=1;i&lt;len;i++)
    	{
        	for( j=0,p=L;j&lt;len-i;j++,p=p-&gt;next)
        	{
            		if( p-&gt;data &gt; p-&gt;next-&gt;data )
            		{
                		datatype t=p-&gt;data;
                		p-&gt;data=p-&gt;next-&gt;data;
                		p-&gt;next-&gt;data=t;
            		}
        	}
    	}
	    printf("排序成功\n");
	    return 0;
}
</code></pre> 
<p></p> 
<h3 style="background-color:transparent;">2.链表的反转（递归实现）</h3> 
<pre><code class="language-cs">// 递归反转链表  
NodePtr list_fz(NodePtr L) 
{  
	    // 基础情况：空链表或只有一个节点  
    	if (L == NULL || L-&gt;next == NULL) 
	    {  
        	return L;  
    	}  

   	    NodePtr new_L = list_fz(L-&gt;next);  

   	    L-&gt;next-&gt;next = L;  
    	L-&gt;next = NULL;

    	return new_L; 
}</code></pre> 
<p></p> 
<h3 style="background-color:transparent;">3.链表去重</h3> 
<pre><code class="language-cs">
// 去重函数
int list_dr(NodePtr L) 
{
	 NodePtr current = L;
     NodePtr prev = NULL;

   	 while (current != NULL) 
	 {
        	NodePtr runner = L;
        	prev = NULL;
        	int flag = 0;

        	// 查找当前节点的重复项
        	while (runner != current) 
		    {
            		if (runner-&gt;data == current-&gt;data) 
			        {
                		flag = 1;
                		break;
            		}
            		prev = runner;
            		runner = runner-&gt;next;
        	}

        	if (flag) 
		    {
            		// 如果是重复节点，删除当前节点
            		NodePtr temp = current;
            		if (prev != NULL) 
			        {
                		prev-&gt;next = current-&gt;next;
            		} 
			        else 
			        {
                		L = current-&gt;next; // 更新头节点
            
			        }
            		current = current-&gt;next;
            		free(temp);
        	} 	
		    else 	
		    {
            		current = current-&gt;next;
        	}
    	}
}</code></pre> 
<p></p> 
<h3>linklist.h</h3> 
<pre><code class="language-cs">#ifndef LINKLIST_H

#define LINKLIST_H
#include &lt;myhead.h&gt;

typedef int datatype;

typedef struct Node
{
	union
	{
		int len;
		datatype data;
	};

	struct Node *next;
}Node,*NodePtr;

//创建链表
NodePtr list_create();

//申请节点封装数据函数
NodePtr apply_node(datatype e);

//链表判空
int list_empty(NodePtr L);

//头插
int list_insert_head(NodePtr L,datatype e);

//链表遍历函数
int list_show(NodePtr L);

//通过位置查找节点
NodePtr list_search_pos(NodePtr L,int pos);

//任意位置插入
int list_insert_pos(NodePtr L,int pos,datatype e);

//链表头删
int list_delete_head(NodePtr L);

//任意位置删除
int list_delete_pos(NodePtr L,int pos);

//通过值查找返回位置
int list_search_value(NodePtr L,datatype e);

//链表按位置进行修改
int list_update_pos(NodePtr L,int pos,datatype e);

//链表按值进行修改
int list_update_value(NodePtr L,datatype old_e,datatype new_e);

//将链表进行翻转
void list_reverse(NodePtr L);

//释放链表
void list_destroy(NodePtr L);

//链表排序
int list_sort(NodePtr L);

// 去重函数
int list_dr(NodePtr head);

// 递归反转链表 
NodePtr list_fz(NodePtr L);


#endif
</code></pre> 
<h3 style="background-color:transparent;">linklist.c</h3> 
<pre><code class="language-cs">#include "linklist.h"

NodePtr list_create()
{
	NodePtr L=(NodePtr)malloc(sizeof(Node));
	if(NULL==L)
	{
		printf("创建失败\n");
		return NULL;
	}
	L-&gt;len=0;
	L-&gt;next=NULL;
	printf("链表创建成功\n");
	return L;
}

//申请节点封装数据函数
NodePtr apply_node(datatype e)
{
	NodePtr p=(NodePtr)malloc(sizeof(Node));
	if(NULL==p)
	{
		printf("申请失败\n");
		return NULL;
	}
	p-&gt;data = e;
	p-&gt;next = NULL;
	return p;
}

//链表判空
int list_empty(NodePtr L)
{
	return L-&gt;next ==NULL;
}

//头插
int list_insert_head(NodePtr L,datatype e)
{
	if(NULL==L)
	{
		printf("链表不合法\n");
		return -1;
	}
	NodePtr p = apply_node(e);
	if(NULL==p)
	{
		return -1;
	}
	p-&gt;next=L-&gt;next;
	L-&gt;next=p;
	
	L-&gt;len++;
	printf("头插成功\n");
	return 0;

}

//链表遍历函数
int list_show(NodePtr L)
{
	if(NULL==L || list_empty(L))
	{
		printf("遍历失败\n");
		return -1;
	}	

	NodePtr q = L-&gt;next;
	while(q!=NULL)
	{
		printf("%d\t",q-&gt;data);
		q=q-&gt;next;
	}
	putchar(10);
}

//通过位置查找节点
NodePtr list_search_pos(NodePtr L,int pos)
{
	if(NULL==L || list_empty(L) || pos&lt;0 || pos&gt;L-&gt;len)
	{
		printf("查找失败\n");
		return NULL;
	}
	NodePtr q= L;
	for(int i=0;i&lt;pos;i++)
	{
		q=q-&gt;next;
	}
	return q;
}

//任意位置插入
int list_insert_pos(NodePtr L,int pos,datatype e)
{
	if(NULL==L || pos&lt;=0 ||pos&gt;L-&gt;len+1)
	{
		printf("插入失败\n");
		return -1;
	}
	NodePtr p = apply_node(e);
	if(NULL==p)
	{
		return -1;
	}
	NodePtr q =list_search_pos(L,pos-1);

	p-&gt;next=q-&gt;next;
	q-&gt;next=p;
	
	L-&gt;len++;
	printf("插入成功\n");
	return 0;
}


//链表头删
int list_delete_head(NodePtr L)
{
	if(NULL==L || list_empty(L))
	{
		printf("删除失败\n");
		return -1;
	}
	NodePtr p=L-&gt;next;
	L-&gt;next=p-&gt;next;
	free(p);
	p=NULL;

	L-&gt;len--;
	printf("头删成功\n");
	return 0;
}

//任意位置删除
int list_delete_pos(NodePtr L,int pos)
{
	if(NULL==L || list_empty(L) || pos&lt;1 || pos&gt;L-&gt;len)
	{
		printf("删除失败\n");
		return -1;
	}
	NodePtr q=list_search_pos(L,pos-1);
	NodePtr p=q-&gt;next;
	q-&gt;next =p-&gt;next;
	free(p);
	p=NULL;

	L-&gt;len--;
	printf("删除成功\n");
	return 0;
}

//通过值查找返回位置
int list_search_value(NodePtr L,datatype e)
{
	if(NULL==L || list_empty(L))
	{
		printf("查找失败\n");
		return -1;
	}

	NodePtr q=L-&gt;next;
	for(int index=1;index&lt;=L-&gt;len;index++)
	{
		if(q-&gt;data==e)
		{
			return index;
		}
		q=q-&gt;next;
	}
	printf("没找到\n");
	return -1;
}

//链表按位置进行修改
int list_update_pos(NodePtr L,int pos,datatype e)
{
	if(NULL==L || list_empty(L) || pos&lt;1 || pos&gt;L-&gt;len )
	{
		printf("修改失败\n");
		return -1;
	}

	list_search_pos(L,pos)-&gt;data = e;
	printf("修改成功\n");
	return 0;
}

//链表按值进行修改
int list_update_value(NodePtr L,datatype old_e,datatype new_e)
{
	if(NULL==L || list_empty(L))
	{
		printf("修改失败\n");
		return -1;
	}
	int res = list_search_value(L,old_e);
	if(res == -1)
	{
		printf("没有要修改的值\n");
		return -1;
	}
	list_update_pos(L,res,new_e);
	printf("修改成功\n");
	return 0;

}

//将链表进行翻转
void list_reverse(NodePtr L)
{
	if(NULL==L || L-&gt;len&lt;=1)
	{
		printf("翻转失败\n");
		return;
	}
	NodePtr H = L-&gt;next;
	L-&gt;next = NULL;
	NodePtr p = NULL;
	while(H!=NULL)
	{
		p=H;
		H=H-&gt;next;
		p-&gt;next =L-&gt;next;
		L-&gt;next =p;
	}
	printf("翻转成功\n");
	return;
}

//释放链表
void list_destroy(NodePtr L)
{
	//判断逻辑
    	if(NULL == L)
    	{
        	return;
    	}

    	//将所有结点进行释放
    	while(!list_empty(L))
    	{
        	//头删
        	list_delete_head(L);
    	}

    	//释放头结点
    	free(L);
    	L = NULL;

    	printf("释放成功\n");
}




//链表排序
int list_sort(NodePtr L)
{
	if(NULL==L || L-&gt;len&lt;=1)
    	{
	 	printf("排序失败");
        	return -1;
    	}
   
    	int len=L-&gt;len+1;
    	NodePtr p;
    	int i,j;
    	for( i=1;i&lt;len;i++)
    	{
        	for( j=0,p=L;j&lt;len-i;j++,p=p-&gt;next)
        	{
            		if( p-&gt;data &gt; p-&gt;next-&gt;data )
            		{
                		datatype t=p-&gt;data;
                		p-&gt;data=p-&gt;next-&gt;data;
                		p-&gt;next-&gt;data=t;
            		}
        	}
    	}
	printf("排序成功\n");
	return 0;
}


// 递归反转链表  
NodePtr list_fz(NodePtr L) 
{  
	// 基础情况：空链表或只有一个节点  
    	if (L == NULL || L-&gt;next == NULL) 
	{  
        	return L;  
    	}  

   	NodePtr new_L = list_fz(L-&gt;next);  

   	L-&gt;next-&gt;next = L;  
    	L-&gt;next = NULL;

    	return new_L; 
} 




// 去重函数
int list_dr(NodePtr L) 
{
	NodePtr current = L;
    	NodePtr prev = NULL;

   	 while (current != NULL) 
	 {
        	NodePtr runner = L;
        	prev = NULL;
        	int flag = 0;

        	// 查找当前节点的重复项
        	while (runner != current) 
		{
            		if (runner-&gt;data == current-&gt;data) 
			{
                		flag = 1;
                		break;
            		}
            		prev = runner;
            		runner = runner-&gt;next;
        	}

        	if (flag) 
		{
            		// 如果是重复节点，删除当前节点
            		NodePtr temp = current;
            		if (prev != NULL) 
			{
                		prev-&gt;next = current-&gt;next;
            		} 
			else 
			{
                		L = current-&gt;next; // 更新头节点
            
			}
            		current = current-&gt;next;
            		free(temp);
        	} 	
		else 	
		{
            		current = current-&gt;next;
        	}
    	}
}
</code></pre> 
<h3>main.c</h3> 
<pre><code class="language-cs">#include"linklist.h"

int main(int argc, const char *argv[])
{
    
	//调用函数创建一个链表
    	NodePtr L = list_create();
    	if(NULL == L)
    	{
        	return -1;
    	}

    	//调用头插函数
    	list_insert_head(L, 520);
    	list_insert_head(L, 1314);
    	list_insert_head(L, 666);
    	list_insert_head(L, 999);
    
    	//调用遍历函数
    	list_show(L);

    	//调用任意位置插入函数
    	list_insert_pos(L, 1, 100);
   	    list_insert_pos(L, 3, 100);
    	list_insert_pos(L, L-&gt;len+1, 100);
    	list_show(L);
	    printf("排序: ");
	    list_sort(L);
	    list_show(L);
	    printf("去重：");
	    list_dr(L);
	    list_show(L);
	    printf("反转：");
	    L-&gt;next=list_fz(L-&gt;next);
	    list_show(L);
    	return 0;
}
</code></pre> 
<h3 style="background-color:transparent;">思维导图</h3> 
<p><img alt="" height="1199" src="https://images2.imgbox.com/ee/92/NKvSqSWg_o.png" width="1200"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4063815704cb5f5d1b74608c00ca717b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【数据结构】优先级队列（堆）从实现到应用详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cdf7c9cd94911910abf743e0b1d3b985/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【MySQL】【已解决】Windows安装MySQL8.0时的报错解决方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>