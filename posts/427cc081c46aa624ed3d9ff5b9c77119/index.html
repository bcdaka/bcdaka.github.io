<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>leetcode145. 二叉树的后序遍历，递归法&#43;迭代法，全过程图解&#43;步步解析，一点点教会你迭代法后序遍历 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/427cc081c46aa624ed3d9ff5b9c77119/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="leetcode145. 二叉树的后序遍历，递归法&#43;迭代法，全过程图解&#43;步步解析，一点点教会你迭代法后序遍历">
  <meta property="og:description" content="leetcode145. 二叉树的后序遍历，递归法&#43;迭代法 给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。
示例 1：
输入：root = [1,null,2,3]
输出：[3,2,1]
示例 2：
输入：root = []
输出：[]
示例 3：
输入：root = [1]
输出：[1]
递归法还是一如既往的简单。
postorder函数是递归函数，用于辅助实现后序遍历。它接收两个参数：一个指向当前节点的指针root和一个用于存储遍历结果的向量res。函数首先检查当前节点是否为空，如果是，则直接返回。如果不为空，则递归调用自身，先遍历左子树，再遍历右子树。在遍历完左右子树后，将当前节点的值添加到结果向量res中。
postorderTraversal函数是对外提供的公共接口，用于获取二叉树的后序遍历结果。它接收一个参数：一个指向二叉树根节点的指针root。函数首先初始化一个空的结果向量res，然后调用postorder函数进行后序遍历，并将遍历结果存储在res中。遍历完成后，返回这个结果向量。
整个实现过程是典型的递归方法，通过递归调用自身来遍历二叉树的每一个节点。递归的终止条件是当前节点为空，这时函数会返回而不执行任何操作。
class Solution { public: void postorder(TreeNode *root, vector&lt;int&gt; &amp;res) { if (root == nullptr) { return; } postorder(root-&gt;left, res); postorder(root-&gt;right, res); res.push_back(root-&gt;val); } vector&lt;int&gt; postorderTraversal(TreeNode *root) { vector&lt;int&gt; res; postorder(root, res); return res; } }; 二叉树后序遍历的迭代法相对前序和中序来说就要难一点了，
定义辅助栈：使用一个stack&lt;TreeNode *&gt;类型的栈stk来辅助遍历。
定义前一个访问节点：定义一个TreeNode *类型的指针prev，用来记录上一个被访问的节点。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-17T16:58:46+08:00">
    <meta property="article:modified_time" content="2024-07-17T16:58:46+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">leetcode145. 二叉树的后序遍历，递归法&#43;迭代法，全过程图解&#43;步步解析，一点点教会你迭代法后序遍历</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="leetcode145__0"></a>leetcode145. 二叉树的后序遍历，递归法+迭代法</h3> 
<p>给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。<br> 示例 1：<br> <img src="https://images2.imgbox.com/bd/06/k8Hw3txP_o.png" alt="在这里插入图片描述"><br> 输入：root = [1,null,2,3]<br> 输出：[3,2,1]</p> 
<p>示例 2：<br> 输入：root = []<br> 输出：[]</p> 
<p>示例 3：<br> 输入：root = [1]<br> 输出：[1]</p> 
<p>递归法还是一如既往的简单。</p> 
<p><strong>postorder函数是递归函数，用于辅助实现后序遍历</strong>。它接收两个参数：一个指向当前节点的指针root和一个用于存储遍历结果的向量res。函数首先检查当前节点是否为空，如果是，则直接返回。如果不为空，则递归调用自身，先遍历左子树，再遍历右子树。在遍历完左右子树后，将当前节点的值添加到结果向量res中。</p> 
<p><strong>postorderTraversal函数是对外提供的公共接口，用于获取二叉树的后序遍历结果</strong>。它接收一个参数：一个指向二叉树根节点的指针root。函数首先初始化一个空的结果向量res，然后调用postorder函数进行后序遍历，并将遍历结果存储在res中。遍历完成后，返回这个结果向量。</p> 
<p>整个实现过程是典型的递归方法，通过递归调用自身来遍历二叉树的每一个节点。递归的终止条件是当前节点为空，这时函数会返回而不执行任何操作。<br> <img src="https://images2.imgbox.com/a2/0a/BGAIsRkh_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">postorder</span><span class="token punctuation">(</span>TreeNode <span class="token operator">*</span>root<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>res<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">postorder</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">postorder</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>TreeNode <span class="token operator">*</span>root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> res<span class="token punctuation">;</span>
        <span class="token function">postorder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre> 
<p>二叉树后序遍历的迭代法相对前序和中序来说就要难一点了，</p> 
<p><strong>定义辅助栈</strong>：使用一个stack&lt;TreeNode *&gt;类型的栈stk来辅助遍历。</p> 
<p><strong>定义前一个访问节点</strong>：定义一个TreeNode *类型的指针prev，用来记录上一个被访问的节点。</p> 
<p><strong>迭代遍历</strong>：使用一个while循环，条件是root不为空或栈stk不为空。这个循环将一直执行，直到所有节点都被访问。</p> 
<p><strong>向左下推</strong>：内部的第一个while循环将root沿着左子树一直推到最底部，直到遇到空节点。每次迭代，都将当前节点压入栈中，并更新root为当前节点的左子节点。</p> 
<p><strong>处理当前节点</strong>：当左子树被完全遍历后，root将变为nullptr，此时从栈中弹出栈顶元素，即当前节点。</p> 
<p><strong>后序遍历条件判断</strong>：<br> <em>如果当前节点的右子节点为空，或者右子节点已经访问过（即root-&gt;right == prev），则将当前节点的值添加到结果向量res中，并将prev更新为当前节点，然后将root设置为nullptr，准备处理下一个节点。</em><br> <em>如果当前节点的右子节点不为空且未访问过，则将当前节点再次压入栈中，并更新root为当前节点的右子节点，继续遍历右子树。</em><br> <img src="https://images2.imgbox.com/a3/e3/PUtkQmTO_o.png" alt="在这里插入图片描述"><br> 1.我们再以这个图为例，<strong>首先向左下推直到D</strong>，ABD都入栈了，这时候判断D的左子树为null，于是弹出栈顶D，D没有右子树，于是D首先被遍历进结果数组，并将前一个访问节点记录为D，将root变成null，方便处理下一个节点。</p> 
<p>2.<strong>接下来</strong>弹出栈顶元素B，B有右节点且前一个访问节点不是B的右节点，<strong>所以把B再推入栈，访问B的右节点F</strong>。</p> 
<p>3.<strong>F有左节点，于是F入栈,E入栈，E没有左节点，E出栈</strong>。E也没有右节点，<strong>于是E第二个被遍历进结果数组</strong>，并将前一个访问节点记录为E，将root变成null，方便处理下一个节点。</p> 
<p>4.再弹出栈顶元素F，F没有右节点，<strong>于是F第三个被遍历进结果数组</strong>，并将前一个访问节点记录为F，将root变成null，方便处理下一个节点。</p> 
<p>5.再弹出栈顶元素B，<strong>B有右节点，但是！！前一个访问节点是B的右节点F</strong>，所以B第四个被遍历进结果数组，并将前一个访问节点记录为B，将root变成null，方便处理下一个节点。</p> 
<p><strong>依此类推遍历完全部节点DEFBHGICA。</strong><br> 做完此题，二叉树的中序遍历就再简单不过了，可以秒杀。<br> 具体题目如下。</p> 
<table><thead><tr><th>leetcode94</th><th><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/" rel="nofollow">二叉树的中序遍历</a></th></tr></thead></table> 
<p>我也写了<a href="https://blog.csdn.net/qq_51350957/article/details/140440308">二叉树中序遍历的题解</a>，可以去看看。相对二叉树的中序遍历，后序遍历的迭代法确实难了不少，值得反复学习。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d455dbf41d0f3157da7746b81c98fb30/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【香橙派AiPro】基于VGG16的火灾检测模型预测</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/734f78e951751b368117a2e00775cc3a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">uniapp小程序项目解决键盘问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>