<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>配置资源管理 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b682371e5cc7b3d1bf44af2b85891f69/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="配置资源管理">
  <meta property="og:description" content="一 Secret Secret 是用来保存密码、token、密钥等敏感数据的 k8s 资源，这类数据虽然也可以存放在 Pod 或者镜像中，但是放在 Secret 中是为了更方便的控制如何使用数据，并减少暴露的风险。
1 有三种类型： kubernetes.io/service-account-token：由 Kubernetes 自动创建，用来访问 APIServer 的 Secret，Pod 会默认使用这个 Secret 与 APIServer 通信， 并且会自动挂载到 Pod 的 /run/secrets/kubernetes.io/serviceaccount 目录中;
Opaque ：base64 编码格式的 Secret，用来存储用户自定义的密码、密钥等，默认的 Secret 类 型;
kubernetes.io/dockerconfigjson ：用来存储私有 docker registry 的认证信息。
2 Pod 需要先引用才能使用某个 secret，Pod 有 3 种方式来使用 secret： 作为挂载到一个或多个容器上的卷 中的文件。作为容器的环境变量。由 kubelet 在为 Pod 拉取镜像时使用。 应用场景：凭据
https://kubernetes.io/docs/concepts/configuration/secret/ 二 创建 Secret 1 用kubectl create secret命令创建Secret 创建 Secret 1、用kubectl create secret命令创建Secret echo -n &#39;zhangsan&#39; &gt; username.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-31T23:12:22+08:00">
    <meta property="article:modified_time" content="2024-05-31T23:12:22+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">配置资源管理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 style="background-color:transparent;">一 Secret</h3> 
<p>Secret 是用来保存密码、token、密钥等敏感数据的 k8s 资源，这类数据虽然也可以存放在 Pod 或者镜像中，但是放在 Secret 中是为了更方便的控制如何使用数据，并减少暴露的风险。</p> 
<h4 style="background-color:transparent;"> 1 有三种类型： </h4> 
<p>kubernetes.io/service-account-token：由 Kubernetes 自动创建，用来访问 APIServer 的 Secret，Pod 会默认使用这个 Secret 与 APIServer 通信， 并且会自动挂载到 Pod 的 /run/secrets/kubernetes.io/serviceaccount 目录中;</p> 
<p>Opaque ：base64 编码格式的 Secret，用来<span style="color:#ff9900;">存储用户自定义的密码、密钥</span>等，默认的 Secret 类                                                                                                                                                      型;<br> kubernetes.io/dockerconfigjson ：用来存储私有<span style="color:#ff9900;"> docker registry</span> 的认证信息。</p> 
<h4>2 Pod 需要先引用才能使用某个 secret，Pod 有 3 种方式来使用 secret：</h4> 
<ul><li>作为挂载到一个或多个容器上的卷 中的文件。</li><li>作为容器的环境变量。</li><li>由 kubelet 在为 Pod 拉取镜像时使用。</li></ul> 
<p>应用场景：凭据</p> 
<pre><code class="hljs">https://kubernetes.io/docs/concepts/configuration/secret/</code></pre> 
<h3>二 创建 Secret</h3> 
<h5>1 用kubectl create secret命令创建Secret </h5> 
<pre><code class="hljs">创建 Secret
1、用kubectl create secret命令创建Secret
echo -n 'zhangsan' &gt; username.txt
echo -n 'abc1234' &gt; password.txt

kubectl create secret generic mysecret --from-file=username.txt --from-file=password.txt

kubectl get secrets
NAME                  TYPE                                  DATA   AGE
default-token-8pqp6   kubernetes.io/service-account-token   3      3d1h
mysecret              Opaque                                2      51s

kubectl describe secret mysecret
Name:         mysecret
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Type:  Opaque

Data
====
password.txt:  7 bytes
username.txt:  8 bytes
//get或describe指令都不会展示secret的实际内容，这是出于对数据的保护的考虑</code></pre> 
<h5><img alt="" height="329" src="https://images2.imgbox.com/f6/1c/YOAytG32_o.png" width="1200"></h5> 
<h5><img alt="" height="704" src="https://images2.imgbox.com/2e/8c/khf0lsp4_o.png" width="1200"></h5> 
<h5> 2 内容用 base64 编码，创建Secret</h5> 
<pre><code class="hljs">2、内容用 base64 编码，创建Secret
echo -n zhangsan | base64
emhhbmdzYW4K=

echo -n abc1234 | base64
YWJjMTIzNAo==

vim secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysecret1
type: Opaque
data:
  username: emhhbmdzYW4K=
  password: YWJjMTIzNAo==

kubectl create -f secret.yaml 

kubectl get secrets
NAME                  TYPE                                  DATA   AGE
default-token-8pqp6   kubernetes.io/service-account-token   3      3d1h
mysecret              Opaque                                2      43m
mysecret1             Opaque                                2      6s

kubectl get secret mysecret1 -o yaml
apiVersion: v1
data:
  password: YWJjMTIzNAo==
  username: emhhbmdzYW4K=
kind: Secret
metadata:
  creationTimestamp: 2021-05-24T09:11:18Z
  name: mysecret1
  namespace: default
  resourceVersion: "45641"
  selfLink: /api/v1/namespaces/default/secrets/mysecret1
  uid: fffb7902-bc6f-11eb-acba-000c29d88bba
type: Opaque</code></pre> 
<h5><img alt="" height="241" src="https://images2.imgbox.com/86/16/A6BMFru5_o.png" width="858"></h5> 
<h5><img alt="" height="559" src="https://images2.imgbox.com/cf/4b/TzGRLicI_o.png" width="837"></h5> 
<h5><img alt="" height="741" src="https://images2.imgbox.com/1d/90/Oj4vzlSt_o.png" width="1200"></h5> 
<h5 style="background-color:transparent;">3  用挂在存储方式 </h5> 
<p>将 Secret 挂载到 Volume 中，以 Volume 的形式挂载到 Pod 的某个目录下</p> 
<pre><code class="hljs">使用方式 
1、将 Secret 挂载到 Volume 中，以 Volume 的形式挂载到 Pod 的某个目录下
vim secret-test.yaml
apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
  - name: nginx
    image: nginx
    volumeMounts:
    - name: secrets
      mountPath: "/etc/secrets"
      readOnly: true
  volumes:
  - name: secrets
    secret:
      secretName: mysecret

kubectl create -f secret-test.yaml

kubectl get pods
NAME         READY   STATUS    RESTARTS   AGE
seret-test   1/1     Running   0          16s

kubectl exec -it seret-test bash
 # cd /etc/secrets/
 # ls
password.txt  username.txt
 # vi password.txt 
 # vi username.txt </code></pre> 
<p><strong>错误总结 </strong></p> 
<h4><img alt="" height="574" src="https://images2.imgbox.com/08/59/CpGdjO8x_o.png" width="1200"></h4> 
<blockquote> 
 <p>kubectl exec -it seret-test bash</p> 
</blockquote> 
<p>实践版</p> 
<pre><code class="hljs">apiVersion: v1
kind: Pod
metadata:
  labels:
    run: myapp-demo01
  name: myapp-demo01
spec:
  containers:
  - image: soscscs/myapp:v1
    name: myapp-demo01
    ports:
    - containerPort: 80
    volumeMounts:
    - name: mysecret
      mountPath: "/etc/secret"
      readOnly: true
  restartPolicy: Always
  volumes:
    - name: mysecret
    secret:
      secretName: mysecret
</code></pre> 
<p><img alt="" height="747" src="https://images2.imgbox.com/c0/e6/u3leP6Mi_o.png" width="521"> </p> 
<p><img alt="" height="540" src="https://images2.imgbox.com/e9/27/I8HZpXmu_o.png" width="1200"></p> 
<h4><img alt="" height="849" src="https://images2.imgbox.com/04/df/AKK3toUB_o.png" width="1200"></h4> 
<h5 style="background-color:transparent;">4  将 Secret 导出到环境变量中</h5> 
<pre><code class="hljs">vim secret-test1.yaml
apiVersion: v1
kind: Pod
metadata:
  name: mypod1
spec:
  containers:
  - name: nginx
    image: nginx
    env:
      - name: TEST_USER
        valueFrom:
          secretKeyRef:    #调用键值对
            name: mysecret1
            key: username
      - name: TEST_PASSWORD  #变量
        valueFrom:
          secretKeyRef:
            name: mysecret1
            key: password

kubectl apply -f secret-test1.yaml </code></pre> 
<h4><img alt="" height="705" src="https://images2.imgbox.com/08/58/UpTUythp_o.png" width="1200"></h4> 
<h4><img alt="" height="152" src="https://images2.imgbox.com/72/44/oqhk3nzJ_o.png" width="1200"></h4> 
<h4><img alt="" height="290" src="https://images2.imgbox.com/65/38/eKDHc64w_o.png" width="1200"></h4> 
<h4>项目2</h4> 
<pre><code class="hljs">apiVersion: v1
kind: Pod
metadata:
  labels:
    run: myapp-demo02
  name: myapp-demo02
spec:
  containers:
  - image: soscscs/myapp:v1
    name: myapp-demo02
    env:
      - name: TEST_USER
        valueFrom:
          secretKeyRef:
            name: mysecret01
            key: username
      - name: TEST_PASSWORD
        valueFrom:
          secretKeyRef:
            name: mysecret01
            key: password
~                           </code></pre> 
<p><img alt="" height="736" src="https://images2.imgbox.com/9d/79/bHyNVV6j_o.png" width="497"></p> 
<p>文件读取 挂在变量 </p> 
<h4><img alt="" height="338" src="https://images2.imgbox.com/e8/3e/pgRxwWOq_o.png" width="1200"></h4> 
<blockquote> 
 <p>kubectl exec -it myapp demo03-pod-sc.yaml</p> 
 <p>echo $TEST_USER</p> 
 <p>echo $TEST_PASSWORD</p> 
 <p>或  env|TEST</p> 
</blockquote> 
<pre><code class="hljs">中类型secret

1  0paque 通用类型(可以通过文件 目录、变量创建)默认类型

2  kubernetes,io/service-account-token k8s自动创建的给serviceaccountza在k8s集群内部的专属服务 
                                                                    用户)访问APiserver 使用

3  kubernetes.io/dockerconfigison 给k8s 从harbor私有镜像介库去镜像认证使用的

4  kubernetes.io/tls 通过TLS 证书来认证的 (私有文件、秘钥)

陈述式

还可以多次使用，也可以指定多个文件目录kubectl cerate secretgeneric --from-file=文件指定文件名(把 
                                                                    目录下的所有文件引用进去)
           ----from-literal-键值对(key-value)引用 一个键值对，也可以多次

挂载的方式

定义类型secret 的存储卷volumesvolumeMounts 把存储卷挂载到容器目录，secret资源数据中的键 将以文件名的形式显示，值文件内容

容器环境变量的方式eny 
定义容器的环境变量名
使用 valueFrom.secretKeyRef.name指定secret资源的名称
valuerrom.secretKevRef.name指定这个secret资源数据的健名，从而确定引用那个键的值
k8s从hatbor私有仓库拉取镜像的时使用
imagePullsecret指定kubernetes.io/dockerconfigjson类型的 secret 来作为连接私有仓库的认证信息
</code></pre> 
<h3 style="background-color:transparent;">三 创建ConfigMap</h3> 
<blockquote> 
 <p>管理容器的一种工具</p> 
</blockquote> 
<p>与Secret类似，区别在于ConfigMap保存的是不需要加密配置的信息。<br> ConfigMap 功能在 Kubernetes1.2 版本中引入，许多应用程序会从配置文件、命令行参数或环境变量中读取配置信息。</p> 
<p>ConﬁgMap API 给我们提供了向容器中注入配置信息的机制，ConﬁgMap 可以被用来保存单个属性，也可以用来保存整个配置文件或者JSON二进制大对象。<br> 应用场景：应用配置</p> 
<h4>1 使用目录创建</h4> 
<pre><code class="hljs">mkdir /opt/configmap/
 
vim /opt/configmap/game.properties
enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30
 
vim /opt/configmap/ui.properties
color.good=purple
color.bad=yellow
allow.textmode=true
how.nice.to.look=fairlyNice</code></pre> 
<blockquote> 
 <p>ls /opt/configmap/<br> game.properties<br> ui.properties</p> 
</blockquote> 
<pre><code class="hljs">kubectl create configmap game-config --from-file=/opt/configmap

--from-file 指定在目录下的所有文件都会被用在 ConﬁgMap 里面创建一个键值对，键的名字就是文件名，值就是文件的内容</code></pre> 
<pre><code class="hljs">kubectl get cm
NAME          DATA   AGE
game-config   2      10s</code></pre> 
<p><img alt="" height="400" src="https://images2.imgbox.com/d2/31/lcHaxeVA_o.png" width="1200"></p> 
<blockquote> 
 <p> kubectl get cm game-config -o yaml</p> 
</blockquote> 
<h4><img alt="" height="781" src="https://images2.imgbox.com/12/88/7dhY7HEk_o.png" width="1200"> 2 使用文件创建</h4> 
<p> 只要指定为一个文件就可以从单个文件中创建 ConﬁgMap<br> --from-file 这个参数可以使用多次，即可以使用两次分别指定上个实例中的那两个配置文件，效果就跟指定整个目录是一样的</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/44b38849d276356d11713fb8cbe8656b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">个人关于ChatGPT的用法及建议</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/10f1f7b5e803a79e88dae3e6af24efac/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">安全风险 - 组件导出风险</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>