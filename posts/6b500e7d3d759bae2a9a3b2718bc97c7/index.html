<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【架构之路】微服务中常用的几种通信方式 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/6b500e7d3d759bae2a9a3b2718bc97c7/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【架构之路】微服务中常用的几种通信方式">
  <meta property="og:description" content="2024年，计算机相关专业还值得选择吗？ 强烈推荐 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站:人工智能
引言 微服务架构由于其灵活性、高可扩展性和易维护性，已成为构建复杂系统的主流选择。
微服务架构将系统拆分为多个独立的服务，每个服务负责特定的功能，并通过各种通信方式进行协作。
这些通信方式在确保系统高效、可靠运行的过程中起着至关重要的作用。
本文将介绍几种常见的微服务通信方式，包括HTTP REST、gRPC、消息队列和WebSocket，并通过Java示例说明它们的应用场景和实现方法。
几种通信方式 在微服务架构中，服务之间的通信是关键组件之一。常见的通信方式包括HTTP REST、gRPC、消息队列、以及基于WebSocket的通信。下面举例说明这些通信方式。
1. HTTP REST HTTP REST是一种广泛使用的同步通信方式。每个微服务通过HTTP请求相互通信，通常使用JSON作为数据格式。
示例：
假设有两个微服务，一个用于用户管理（User Service），另一个用于订单管理（Order Service）。Order Service需要从User Service获取用户信息。
User Service:
@RestController @RequestMapping(&#34;/users&#34;) public class UserController { @GetMapping(&#34;/{id}&#34;) public ResponseEntity&lt;User&gt; getUserById(@PathVariable String id) { // 假设从数据库获取用户信息 User user = userService.findUserById(id); return ResponseEntity.ok(user); } } Order Service:
@Service public class UserServiceClient { private final RestTemplate restTemplate; @Autowired public UserServiceClient(RestTemplate restTemplate) { this.restTemplate = restTemplate; } public User getUserById(String userId) { String url = &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-12T10:00:00+08:00">
    <meta property="article:modified_time" content="2024-06-12T10:00:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【架构之路】微服务中常用的几种通信方式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="2024_0"></a>2024年，计算机相关专业还值得选择吗？</h3> 
<p><img src="https://images2.imgbox.com/84/05/EqicRLyu_o.gif" alt="579a429daf314744b995f37351b46548"></p> 
<h4><a id="font_colordd0000font_3"></a><font color="#dd0000">强烈推荐</font></h4> 
<p><font color="#dd0000">前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站:</font><a href="https://www.captainbed.cn/venus" rel="nofollow">人工智能</a></p> 
<p><img src="https://images2.imgbox.com/ed/3b/7ebzZobg_o.jpg" alt="b004071ozy_05_amzn"></p> 
<h4><a id="_15"></a>引言</h4> 
<p>微服务架构由于其灵活性、高可扩展性和易维护性，已成为构建复杂系统的主流选择。</p> 
<p>微服务架构将系统拆分为多个独立的服务，每个服务负责特定的功能，并通过各种通信方式进行协作。</p> 
<p>这些通信方式在确保系统高效、可靠运行的过程中起着至关重要的作用。</p> 
<p>本文将介绍几种常见的微服务通信方式，包括HTTP REST、gRPC、消息队列和WebSocket，并通过Java示例说明它们的应用场景和实现方法。</p> 
<hr> 
<h4><a id="_31"></a>几种通信方式</h4> 
<p>在微服务架构中，服务之间的通信是关键组件之一。常见的通信方式包括HTTP REST、gRPC、消息队列、以及基于WebSocket的通信。下面举例说明这些通信方式。</p> 
<h5><a id="1_HTTP_REST_37"></a>1. HTTP REST</h5> 
<p>HTTP REST是一种广泛使用的同步通信方式。每个微服务通过HTTP请求相互通信，通常使用JSON作为数据格式。</p> 
<p><strong>示例：</strong></p> 
<p>假设有两个微服务，一个用于用户管理（User Service），另一个用于订单管理（Order Service）。Order Service需要从User Service获取用户信息。</p> 
<p><strong>User Service:</strong></p> 
<pre><code>@RestController
@RequestMapping("/users")
public class UserController {

    @GetMapping("/{id}")
    public ResponseEntity&lt;User&gt; getUserById(@PathVariable String id) {
        // 假设从数据库获取用户信息
        User user = userService.findUserById(id);
        return ResponseEntity.ok(user);
    }
}
</code></pre> 
<p><strong>Order Service:</strong></p> 
<pre><code>@Service
public class UserServiceClient {

    private final RestTemplate restTemplate;

    @Autowired
    public UserServiceClient(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    public User getUserById(String userId) {
        String url = "http://USER-SERVICE/users/" + userId;
        return restTemplate.getForObject(url, User.class);
    }
}
</code></pre> 
<p><strong>配置RestTemplate:</strong></p> 
<pre><code>@Configuration
public class RestTemplateConfig {

    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
</code></pre> 
<h5><a id="2_gRPC_98"></a>2. gRPC</h5> 
<p>gRPC是Google开源的一个高性能、通用的RPC框架，使用Protocol Buffers作为接口定义语言，并支持多种编程语言。</p> 
<p><strong>示例：</strong></p> 
<p>假设有两个微服务，一个用于用户管理（User Service），另一个用于订单管理（Order Service）。Order Service需要从User Service获取用户信息。</p> 
<p><strong>User Service:</strong></p> 
<p><strong>1.定义.proto文件：</strong></p> 
<pre><code>syntax = "proto3";

option java_package = "com.example.userservice";
option java_outer_classname = "UserServiceProto";

service UserService {
    rpc GetUser (UserRequest) returns (UserResponse) {}
}

message UserRequest {
    string id = 1;
}

message UserResponse {
    string id = 1;
    string name = 2;
    string email = 3;
}
</code></pre> 
<p><strong>2.实现服务端：</strong></p> 
<pre><code>public class UserServiceImpl extends UserServiceGrpc.UserServiceImplBase {

    @Override
    public void getUser(UserRequest request, StreamObserver&lt;UserResponse&gt; responseObserver) {
        // 假设从数据库获取用户信息
        UserResponse response = UserResponse.newBuilder()
                .setId(request.getId())
                .setName("John Doe")
                .setEmail("john.doe@example.com")
                .build();
        responseObserver.onNext(response);
        responseObserver.onCompleted();
    }
}
</code></pre> 
<p><strong>3.配置并启动gRPC服务器：</strong></p> 
<pre><code>public class GrpcServer {

    public static void main(String[] args) throws IOException, InterruptedException {
        Server server = ServerBuilder.forPort(8080)
                .addService(new UserServiceImpl())
                .build();

        server.start();
        System.out.println("Server started on port 8080");
        server.awaitTermination();
    }
}
</code></pre> 
<p><strong>Order Service:</strong></p> 
<p>1.创建gRPC客户端：</p> 
<pre><code>public class UserServiceClient {

    private final UserServiceGrpc.UserServiceBlockingStub userServiceStub;

    public UserServiceClient() {
        ManagedChannel channel = ManagedChannelBuilder.forAddress("localhost", 8080)
                .usePlaintext()
                .build();
        userServiceStub = UserServiceGrpc.newBlockingStub(channel);
    }

    public UserResponse getUserById(String userId) {
        UserRequest request = UserRequest.newBuilder().setId(userId).build();
        return userServiceStub.getUser(request);
    }
}
</code></pre> 
<h5><a id="3__198"></a>3. 消息队列</h5> 
<p>消息队列是一种异步通信方式，常用的消息队列系统有RabbitMQ、Apache Kafka等。消息队列可以解耦生产者和消费者，实现异步处理。</p> 
<p><strong>示例：</strong></p> 
<p>假设有两个微服务，一个用于订单管理（Order Service），另一个用于通知服务（Notification Service）。订单服务在订单创建后发送消息到消息队列，通知服务接收并处理消息。</p> 
<p><strong>Order Service:</strong></p> 
<pre><code>@Service
public class OrderService {

    private final RabbitTemplate rabbitTemplate;

    @Autowired
    public OrderService(RabbitTemplate rabbitTemplate) {
        this.rabbitTemplate = rabbitTemplate;
    }

    public void createOrder(Order order) {
        // 创建订单逻辑
        rabbitTemplate.convertAndSend("order.exchange", "order.created", order);
    }
}
</code></pre> 
<p><strong>Notification Service:</strong></p> 
<pre><code>@Service
public class NotificationService {

    @RabbitListener(queues = "order.queue")
    public void handleOrderCreated(Order order) {
        // 处理订单创建通知
        System.out.println("Received order: " + order);
    }
}
</code></pre> 
<p><strong>配置RabbitMQ:</strong></p> 
<pre><code>@Configuration
public class RabbitMQConfig {

    @Bean
    public Queue queue() {
        return new Queue("order.queue");
    }

    @Bean
    public TopicExchange exchange() {
        return new TopicExchange("order.exchange");
    }

    @Bean
    public Binding binding(Queue queue, TopicExchange exchange) {
        return BindingBuilder.bind(queue).to(exchange).with("order.created");
    }
}
</code></pre> 
<h4><a id="4_WebSocket_271"></a>4. WebSocket</h4> 
<p>WebSocket是一种双向通信协议，适用于需要实时通信的场景。</p> 
<p><strong>示例：</strong></p> 
<p>假设有一个聊天应用，两个微服务分别处理用户和聊天信息。</p> 
<p><strong>Chat Service:</strong></p> 
<pre><code>@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(new ChatWebSocketHandler(), "/chat");
    }
}

@Component
public class ChatWebSocketHandler extends TextWebSocketHandler {

    @Override
    public void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
        // 处理收到的消息
        session.sendMessage(new TextMessage("Received: " + message.getPayload()));
    }
}
</code></pre> 
<hr> 
<h4><a id="_309"></a>应用场景</h4> 
<p>不同的通信方式适用于不同的应用场景，每种方式都有其优缺点和适用领域。以下是对上述几种通信方式的应用场景的说明：</p> 
<h5><a id="1_HTTP_REST_315"></a>1. HTTP REST</h5> 
<p><strong>应用场景：</strong></p> 
<ul><li><strong>Web服务与API接口</strong>：HTTP REST是构建Web服务和API接口的首选方法，广泛应用于提供对外部系统的访问接口。</li><li><strong>同步请求响应</strong>：适用于需要立即得到响应的请求，比如用户查询、订单查询等。</li><li><strong>简单易用</strong>：对开发者友好，易于实现和调试，适合快速开发。</li></ul> 
<p><strong>示例场景：</strong></p> 
<ul><li> <p>用户注册、登录等操作。</p> </li><li> <p>产品信息查询，订单管理系统。</p> </li></ul> 
<h5><a id="2_gRPC_331"></a>2. gRPC</h5> 
<p><strong>应用场景：</strong></p> 
<ul><li><strong>高性能通信</strong>：适用于需要高性能、低延迟通信的场景，如微服务之间的大量数据传输。</li><li><strong>多语言支持</strong>：适用于多语言环境，因为gRPC支持多种编程语言。</li><li><strong>严格的接口定义</strong>：适用于需要严格接口和数据类型约束的场景，通过Protocol Buffers定义接口。</li></ul> 
<p><strong>示例场景：</strong></p> 
<ul><li> <p>实时数据处理，如在线游戏、实时数据分析。</p> </li><li> <p>微服务内部通信，如电商系统中的订单服务与库存服务之间的通信。</p> </li></ul> 
<h5><a id="3__347"></a>3. 消息队列</h5> 
<p><strong>应用场景：</strong></p> 
<ul><li><strong>异步处理</strong>：适用于需要异步处理的场景，避免长时间的同步等待。</li><li><strong>解耦系统</strong>：适用于希望解耦生产者和消费者的场景，使得系统更加灵活和可扩展。</li><li><strong>任务队列</strong>：适用于需要将任务放入队列中逐步处理的场景，如邮件发送、日志处理。</li></ul> 
<p><strong>示例场景：</strong></p> 
<ul><li> <p>订单创建后发送通知或进行库存更新。</p> </li><li> <p>用户注册后发送欢迎邮件。</p> </li><li> <p>日志收集与处理系统。</p> </li></ul> 
<h5><a id="4_WebSocket_365"></a>4. WebSocket</h5> 
<p><strong>应用场景：</strong></p> 
<ul><li><strong>实时通信</strong>：适用于需要实时双向通信的场景，如聊天应用、在线游戏、实时协作工具。</li><li><strong>低延迟要求</strong>：适用于对延迟有严格要求的应用，能够提供持续的低延迟连接。</li><li><strong>状态保持</strong>：适用于需要保持连接状态的应用，如实时数据更新。</li></ul> 
<p><strong>示例场景：</strong></p> 
<ul><li> <p>聊天应用，如即时消息系统。</p> </li><li> <p>实时交易平台，如股票交易、加密货币交易。</p> </li><li> <p>实时协作工具，如在线文档协作、实时编辑器。</p> </li></ul> 
<h5><a id="_383"></a>场景应用总结</h5> 
<ul><li><strong>HTTP REST</strong>适用于简单的请求响应模型和对外提供API的场景，易于实现和使用。</li><li><strong>gRPC</strong>适用于需要高性能通信和严格接口定义的场景，适合多语言环境和实时数据处理。</li><li><strong>消息队列</strong>适用于异步处理和解耦的场景，适合任务队列和事件驱动架构。</li><li><strong>WebSocket</strong>适用于需要实时双向通信和低延迟的场景，适合实时应用和需要保持连接状态的场景。</li></ul> 
<p>根据具体的业务需求和性能要求，开发者可以选择最适合的通信方式来实现微服务之间的通信。</p> 
<hr> 
<h4><a id="_398"></a>总结</h4> 
<p>微服务通信方式的选择在很大程度上影响系统的性能、可靠性和扩展性。</p> 
<p>通过了解和掌握HTTP REST、gRPC、消息队列和WebSocket等不同通信方式的特点和应用场景，开发者可以根据具体业务需求选择最合适的通信方式，从而构建出高效、灵活和可扩展的微服务系统。</p> 
<p>在实际应用中，可能需要结合多种通信方式，以发挥各自的优势，满足系统的不同需求。</p> 
<hr> 
<h4><a id="font_colordd0000font_410"></a><font color="#dd0000">强烈推荐</font></h4> 
<p><font color="#dd0000">前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站:</font><a href="https://www.captainbed.cn/venus" rel="nofollow">人工智能</a></p> 
<p><img src="https://images2.imgbox.com/bd/0c/3LPQnV5B_o.jpg" alt="b004071ozy_05_amzn"></p> 
<hr> 
<h4><a id="_424"></a>专栏集锦</h4> 
<p>大佬们可以收藏以备不时之需：</p> 
<p>Spring Boot 专栏：http://t.csdnimg.cn/peKde</p> 
<p>ChatGPT 专栏：http://t.csdnimg.cn/cU0na</p> 
<p>Java 专栏：http://t.csdnimg.cn/YUz5e</p> 
<p>Go 专栏：http://t.csdnimg.cn/Jfryo</p> 
<p>Netty 专栏：http://t.csdnimg.cn/0Mp1H</p> 
<p>Redis 专栏：http://t.csdnimg.cn/JuTue</p> 
<p>Mysql 专栏：http://t.csdnimg.cn/p1zU9</p> 
<p>架构之路 专栏：http://t.csdnimg.cn/bXAPS</p> 
<hr> 
<h4><a id="_450"></a>写在最后</h4> 
<p><strong>感谢您的支持和鼓励！ 😊🙏</strong></p> 
<p><strong>如果大家对相关文章感兴趣，可以关注公众号"架构殿堂"，会持续更新AIGC，java基础面试题, netty, spring boot, spring cloud等系列文章，一系列干货随时送达!</strong></p> 
<p><strong>如果有项目或者毕设合作，请V:fengyelin8866,备注毕设</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f7e3779b30b629cfb1a11de8a63a618e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">先别吹sora，ComfyUI&#43;SVD才是你2024年必须掌握的ai视频工具！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fede8fc5333af71c114ea7b68f8d3809/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AI大模型探索之路-实战篇：智能化IT领域搜索引擎的构建与初步实践</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>