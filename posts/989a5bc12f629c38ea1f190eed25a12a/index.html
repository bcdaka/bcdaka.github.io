<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;：从C到C&#43;&#43;的飞跃之旅（C&#43;&#43;基础知识） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/989a5bc12f629c38ea1f190eed25a12a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C&#43;&#43;：从C到C&#43;&#43;的飞跃之旅（C&#43;&#43;基础知识）">
  <meta property="og:description" content="本期博客是一篇C&#43;&#43;基础知识，对后续C&#43;&#43;的深入学习，都是有着相当重要的地位❤，内容包含了以下知识：命名空间、C&#43;&#43;的输入&amp;输出流、缺省参数、重载函数、引用、inline（内联函数）、nullptr（主要解决C语言NULL类型混淆的问题）
如果这篇博客对大家有帮助，还请点赞收藏❤，感觉大家的支持~，我会更加努力的❤
一、命名空间 1.问题导向 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int rand = 1314; int main() { printf(&#34;%d\n&#34;, rand); return 0; } /* *这组代码中，就存在了一个不可避免的 会存在编译错误： *error C2365: “rand”: 重定义；以前的定义是“函数” *warning C4477: “printf”: 格式字符串“%d”需要类型“int”的参数，但可变参数 1 *拥有了类型“int (__cdecl *)(void)” */ 不难理解，rand是生成随机数的函数名，其函数的声明存放于头文件&lt;stdlib.h&gt;中，而我们又定义了一个全局变量rand；这就导致了上面的错误，我们称为命名冲突；
问：自己写代码的时候，命名稍加注意一下，不就可以了吗？回：虽然你自己写代码的时候，不会发生命名冲突的问题，但你不能保证，多人协作写一个项目的时候，不会出现命名冲突的问题，毕竟每个人的想法都是参差不齐的。 为了解决命名冲突的问题，C&#43;&#43;引入了一个新的关键字——namespace，namespace后跟一对{}，中间用于变量的定义，函数的声明与定义，类的声明与定义等等；可以为我们在全局域生成一个命名空间域；主要用于解决命名冲突、组织代码、提高代码的可读性和可维护性。
下面的代码，是在域中定义一个malloc为函数名的交换函数，和以rand为变量名的变量。包含头文件&lt;stdlib.h&gt;后，编译器不会报上面的错误。
2.namespace的定义 namespace的本质，在用途方面，可以类似于电脑分盘(新建文件夹)，在不同的盘符(文件夹)中可以定义相同的文件标识；不同的域可以使用相同的标识符，如局部域和作用域，都可以定义变量a；在同一域中，不能出现两个或两个以上的相同的标识符多文件中，存在相同的命名空间域名的时候，编译的时候，会形成同一个域；namespace可嵌套使用；namespace只可在全局域中使用；C&#43;&#43;的作用域主要有四种，函数局部域、全局域、命名空间域、类域。函数局部域、全局域会改变变量或函数的作用域和生命周期，而命名空间域、类域只改变其作用域，不改变其生命周期；C&#43;&#43;的标准域，定义在 std 域中；编译器找变量、函数、或类的出处，默认是局部域和全局域(先局部域，后全局域)；若找不到，则编译器报错；——由此更能体现命名空间对命名冲突问题的解决；下面将对上面所说的某些现象，进行验证与反馈~，若无问题可直接跳转命名空间的使用 //.h文件 #include&lt;stdio.h&gt; namespace zmh { void Print(); } //.cpp文件 #include&#34;zmh.h&#34; namespace zmh { void Print() { printf(&#34;残风也想永存：第一个C&#43;&#43;代码\n&#34;); } } //.main文件 #include&#34;zmh.h&#34; using namespace zmh; // 这里是对命名空间的一种使用方法 int main() { //验证：多文件中，存在相同的命名空间域名的时候，编译的时候，会形成同一个域； //若成功调用Print(),则验证成功！！！ Print(); return 0; } 3.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-22T13:49:43+08:00">
    <meta property="article:modified_time" content="2024-07-22T13:49:43+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;：从C到C&#43;&#43;的飞跃之旅（C&#43;&#43;基础知识）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>        本期博客是一篇C++基础知识，对后续C++的深入学习，都是有着相当重要的地位❤，内容包含了以下知识：<a href="#%E4%BA%8C%E3%80%81%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4" rel="nofollow">命名空间</a>、<a href="#%E4%BA%8C%E3%80%81C%2B%2B%E7%9A%84%E8%BE%93%E5%85%A5%26%E8%BE%93%E5%87%BA%E6%B5%81" rel="nofollow">C++的输入&amp;输出流</a>、<a href="#%E4%B8%89%E3%80%81%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0" rel="nofollow">缺省参数</a>、<a href="#%E5%9B%9B%E3%80%81%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0" rel="nofollow">重载函数</a>、<a href="#%E4%BA%94%E3%80%81%E5%BC%95%E7%94%A8" rel="nofollow">引用</a>、<a href="#%E5%85%AD%E3%80%81%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0" rel="nofollow">inline</a>（内联函数）、<a href="#%E4%B8%83%E3%80%81nullptr" rel="nofollow">nullptr</a>（主要解决C语言NULL类型混淆的问题）</p> 
 <p>        如果这篇博客对大家有帮助，还请点赞收藏❤，感觉大家的支持~，我会更加努力的❤</p> 
</blockquote> 
<h4 id="%E4%BA%8C%E3%80%81%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">一、命名空间</h4> 
<h5 id="1.%E9%97%AE%E9%A2%98%E5%AF%BC%E5%90%91">1.问题导向</h5> 
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

int rand = 1314;

int main()
{
	printf("%d\n", rand);
	return 0;
}

/*
 *这组代码中，就存在了一个不可避免的 会存在编译错误：
 *error C2365: “rand”: 重定义；以前的定义是“函数”
 *warning C4477: “printf”: 格式字符串“%d”需要类型“int”的参数，但可变参数 1 
 *拥有了类型“int (__cdecl *)(void)”  
 */</code></pre> 
<p>        不难理解，rand是生成随机数的函数名，其函数的声明存放于头文件&lt;stdlib.h&gt;中，而我们又定义了一个全局变量rand；这就导致了上面的错误，我们称为<span style="color:#fe2c24;">命名冲突</span>；</p> 
<ul><li>问：自己写代码的时候，命名稍加注意一下，不就可以了吗？</li><li>回：虽然你自己写代码的时候，不会发生命名冲突的问题，但你不能保证，多人协作写一个项目的时候，不会出现命名冲突的问题，毕竟每个人的想法都是参差不齐的。</li></ul> 
<p>        为了解决命名冲突的问题，<span style="color:#fe2c24;">C++引入了一个新的关键字——namespace</span>，namespace后跟一对{}，中间用于变量的定义，函数的声明与定义，类的声明与定义等等；可以<span style="color:#fe2c24;">为我们在全局域生成一个命名空间域；<strong>主要用于解决命名冲突、组织代码、提高代码的可读性和可维护性</strong>。</span></p> 
<p>        下面的代码，是在域中定义一个malloc为函数名的交换函数，和以rand为变量名的变量。包含头文件&lt;stdlib.h&gt;后，编译器不会报上面的错误。</p> 
<p><img alt="" height="578" src="https://images2.imgbox.com/5e/33/vp1hPoty_o.png" width="1200"></p> 
<h5 id="2.namespace%E7%9A%84%E5%AE%9A%E4%B9%89">2.namespace的定义</h5> 
<ul><li><span style="color:#fe2c24;">namespace的本质，在用途方面，可以类似于电脑分盘(新建文件夹)，在不同的盘符(文件夹)中可以定义相同的文件标识</span>；</li><li>不同的域可以使用相同的标识符，如局部域和作用域，都可以定义变量a；</li><li>在同一域中，不能出现两个或两个以上的相同的标识符</li><li><span style="color:#fe2c24;">多文件中，存在相同的命名空间域名的时候，编译的时候，会形成同一个域</span>；</li><li>namespace可嵌套使用；</li><li><span style="color:#fe2c24;">namespace只可在全局域中使用</span>；</li><li>C++的作用域主要有四种，函数局部域、全局域、命名空间域、类域。函数局部域、全局域会改变变量或函数的作用域和生命周期，而命名空间域、类域只改变其作用域，不改变其生命周期；</li><li><span style="color:#fe2c24;">C++的标准域，定义在 std 域中</span>；</li><li>编译器找变量、函数、或类的出处，默认是局部域和全局域(先局部域，后全局域)；若找不到，则编译器报错；——由此更能体现命名空间对命名冲突问题的解决；</li><li>下面将对上面所说的某些现象，进行验证与反馈~，若无问题可直接跳转<a href="#3.%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">命名空间的使用</a></li></ul> 
<blockquote> 
 <p><img alt="" height="453" src="https://images2.imgbox.com/4d/a4/lvskoFKV_o.png" width="1200"></p> 
 <p><img alt="" height="573" src="https://images2.imgbox.com/6f/c4/lEiVQxkF_o.png" width="1200"><img alt="" height="726" src="https://images2.imgbox.com/66/30/Jry8gShN_o.png" width="1200"><img alt="" height="787" src="https://images2.imgbox.com/56/54/Qi5grz33_o.png" width="1200"></p> 
 <pre><code>//.h文件
#include&lt;stdio.h&gt;

namespace zmh
{
	void Print();
}

//.cpp文件
#include"zmh.h"

namespace zmh
{
	void Print()
	{
		printf("残风也想永存：第一个C++代码\n");
	}
}

//.main文件
#include"zmh.h"
using namespace zmh; // 这里是对命名空间的一种使用方法

int main()
{
    //验证：多文件中，存在相同的命名空间域名的时候，编译的时候，会形成同一个域；
    //若成功调用Print(),则验证成功！！！
	Print();
	return 0;
}
</code></pre> 
 <img alt="" height="141" src="https://images2.imgbox.com/24/76/ML8jno5R_o.png" width="1000"> 
</blockquote> 
<h5 id="3.%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E4%BD%BF%E7%94%A8">3.命名空间的使用</h5> 
<p>        我们已经知道，编译器找变量、函数、或类的出处，默认是局部域和全局域(先局部域，后全局域)；那我们就想，怎么才能告诉编译器，去全局域，去找出处呢？</p> 
<p>        答案是有的，这里将学习一个新的<span style="color:#fe2c24;">操作符 ‘::’——作用域解析操作符，而是用于指定某个标识符的所属作用域或命名空间的特殊符号。</span></p> 
<p>        ‘<span style="color:#0d0016;">::’，操作符前是全局域（</span><span style="color:#fe2c24;">双冒号前面什么都没有，则代表全局域</span><span style="color:#0d0016;">）或者是命名空间的域名，后面则是我们要访问的变量，函数或类。</span></p> 
<p><a href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%EF%BC%9A" rel="nofollow">         命名空间使用总结：</a></p> 
<p><span style="color:#0d0016;">        </span>注： ‘<span style="color:#0d0016;">::’不仅仅可以访问全局域和命名空间域，但目前们只需要掌握这两个用途即可</span><a href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%EF%BC%9A" rel="nofollow">  </a></p> 
<p><img alt="" height="563" src="https://images2.imgbox.com/01/56/xlg9I9Zq_o.png" width="1200"></p> 
<p>        如果我们对命名空间域中某一个变量或函数的使用率更频繁的时候，每次都要通过上面的访问方式，是不是有点太过繁琐了？难到就没有其它的解决方法了吗？</p> 
<p>        是有的，C++为我们提供了一个using关键字，在全局域中使用using关键字，可以解决上面的问题。</p> 
<blockquote> 
 <p>其使用方法由以下两种：</p> 
 <p><strong><span style="color:#a2e043;">using (命名空间域名)::(要访问的变量、函数或类);   </span></strong></p> 
 <p><strong><span style="color:#a2e043;">// 对某个要频繁使用的变量、函数或类进行展开</span><br><span style="color:#38d8f0;">using namespace (命名空间域名); </span> </strong></p> 
 <p><strong><span style="color:#38d8f0;">// 对整个命名空间域进行展开</span></strong></p> 
 <p><span style="color:#fe2c24;">功效，可以让我们在使用某个变量、函数或类的时候，不再需要 </span><strong><span style="color:#a2e043;">(命名空间域名)::(要访问的变量、函数或类) </span></strong><span style="color:#fe2c24;">，而是直接(要访问的变量、函数或类)即可。</span></p> 
</blockquote> 
<p><img alt="" height="617" src="https://images2.imgbox.com/55/37/1QoszfcL_o.png" width="1200"></p> 
<p><img alt="" height="766" src="https://images2.imgbox.com/09/d0/ov7TmzNK_o.png" width="1200"></p> 
<blockquote> 
 <h6 id="%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%EF%BC%9A">命名空间使用总结：</h6> 
 <p><span style="color:#0d0016;"><strong>命名空间使用方法一：</strong></span></p> 
 <p><span style="color:#956fe7;"><strong>(命名空间域名)::(要访问的变量、函数或类)</strong></span></p> 
 <p><span style="color:#0d0016;"><strong>命名空间使用方法二：</strong></span></p> 
 <p><strong><span style="color:#a2e043;">using (命名空间域名)::(要访问的变量、函数或类);   </span></strong></p> 
 <p><strong><span style="color:#a2e043;">// 对某个要频繁使用的变量、函数或类进行展开</span></strong></p> 
 <p><strong><span style="color:#0d0016;">命名空间使用方法三：</span><br><span style="color:#38d8f0;">using namespace (命名空间域名); </span> </strong></p> 
 <p><strong><span style="color:#38d8f0;">// 对整个命名空间域进行展开</span></strong></p> 
</blockquote> 
<h4 id="%E4%BA%8C%E3%80%81C%2B%2B%E7%9A%84%E8%BE%93%E5%85%A5%26%E8%BE%93%E5%87%BA%E6%B5%81">二、C++的输入&amp;输出流</h4> 
<ul><li>&lt;iostream&gt;：是C++的标准输出、输入流的库函数头文件；其函数的声明与定义在，命名空间std中。</li><li>std::cout：是C++的标准输出函数；可以通过插入运算符 &lt;&lt;来发送各种类型的数据。</li><li>std::cin：是C++的标准输入函数；可以通过提取运算符 &gt;&gt; 来读取各种类型的数据。</li><li>std::endl：用于在输出流中插入一个换行符，并刷新输出缓冲区；这意味着它不仅仅是插入一个换行符（<code>\n</code>），还会确保所有等待在缓冲区中的输出都被发送到它们的目的地（如屏幕）。</li><li>&lt;&lt;：流输出符号，用于输出数据。</li><li>&gt;&gt;：流提取符号，用于读取数据。</li><li>C++的cout与cin，会自动识别数据格式，无需，我们再像C语言的printf，scanf一样，要注意每个数据类型对应的占位符。</li></ul> 
<h4 id="%E4%B8%89%E3%80%81%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0">三、缺省参数</h4> 
<ul><li>定义：所谓缺省参数，是针对函数形参形式来讲的；在函数声明或定义的时候，我们可以直接给形参赋值。当函数调用的时候，如果对应的实参没有被提供，那么将使用这些缺省值；反之则使用被提供的实参。（缺省参数又叫默认参数）</li><li><span style="color:#fe2c24;">函数声明与实现分离的时候，不能重复给缺省参数，且规定只能在函数声明的时候，给缺省参数。</span></li><li>缺省参数分为全缺省，或半缺省；全缺省就是函数每个形参都又缺省参数，半缺省就是函数每个形参不全部都是缺省参数。</li><li><span style="color:#fe2c24;">C++规定，半缺省参数，只能从右向左给；且函数调用的时候，必须从左向右给值，不能跳跃给值。</span></li><li>错误使用案例，还请大家敲入合适的代码，进行测试；下面只展示正确的使用方法，以及函数的行为。</li></ul> 
<p><img alt="" height="649" src="https://images2.imgbox.com/8d/47/15wgeTIO_o.png" width="1200"></p> 
<h4 id="%E5%9B%9B%E3%80%81%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0">四、重载函数</h4> 
<ul><li>定义：<strong><span style="color:#fe2c24;">在相同域中</span></strong>，函数名相同，但形参不同的两个或两个以上的函数构成重载函数；</li><li>重载函数特征1：<span style="color:#fe2c24;">函数名相同，形参个数不同；</span></li><li>重载函数特征2：<span style="color:#fe2c24;">函数名相同，形参类型不同；</span></li><li>重载函数特征3：<span style="color:#fe2c24;">函数名相同，形参顺序不同；</span></li><li>注意事项：<span style="color:#fe2c24;">不能通过返回值的不同来定义重载函数</span></li><li>优势：允许开发者通过相同的函数名，实现形参类型、个数不同，但功能类似的函数；<span style="color:#fe2c24;">这提高代码的可读性，增加了代码的灵活性</span>；<span style="color:#fe2c24;">同时函数调用也会显得便利</span>。</li></ul> 
<blockquote> 
 <p><span style="color:#fe2c24;">//  形参个数不同</span><br> void ZMH(int a, double b) { ; }<br> void ZMH(int a, double b, int c) { ; }<br><span style="color:#fe2c24;">//  形参类型不同</span><br> void ZMH(int a, double b) { ; }<br> void ZMH(int a, int b) { ; }<br><span style="color:#fe2c24;">//  形参顺序不同</span><br> void ZMH(int a, double b) { ; }<br> void ZMH(double b, int a) { ; }</p> 
 <p><span style="color:#fe2c24;">//  不能通过返回值的不同来定义重载函数</span></p> 
 <p>void ZMH(int a, double b) { ; }<br> int ZMH(int a, double b) { ; }</p> 
 <p><img alt="" height="69" src="https://images2.imgbox.com/91/eb/bgdo5Zi0_o.png" width="1200"></p> 
 <p><span style="color:#fe2c24;">//  重载函数与缺省参数不恰当的混用，可能存在歧义</span></p> 
 <p>void ZMH() { ; }<br> void ZMH(int a = 4) { ; }</p> 
 <p>问：上面两组函数，构成重载吗？</p> 
 <p>答：构成</p> 
 <p>问：调用ZMH();的时候，是执行哪一个函数呢？</p> 
 <p>答：编译器不知道执行哪一个函数，会报错。</p> 
 <p><img alt="" height="59" src="https://images2.imgbox.com/48/0d/QM12g8v0_o.png" width="1200"></p> 
</blockquote> 
<h4 id="%E4%BA%94%E3%80%81%E5%BC%95%E7%94%A8">五、引用</h4> 
<h5 id="1.%E5%BC%95%E7%94%A8%E7%9A%84%E6%84%8F%E4%B9%89">1.引用的意义</h5> 
<p>        讲引用的之前，先插入一个话题：周树人与鲁迅的关系；在革命时期，周树人写的文章很多都是讽刺社会的黑暗，以及国民政党的昏庸，百姓思想的封建。可反动势力，会容忍别人的诋毁吗？当然不会，倘若周树人直接以本名去当文章的作者，说不定上午刚发布完文章，下午反动势力，就闯进家门逮捕了；于是周树人就想着，我能不能取一个别名，去发布文章呢？这样不但降低了被逮捕的风险，而且也能实现自己的目标。</p> 
<p>        <span style="color:#fe2c24;">而C++的引入的引用，其价值，与周树人使用“鲁迅”这一笔名来发表文章，在某种意义上是相似的——都是为了避免直接暴露身份或对象，从而达到更安全、更灵活地执行目的的效果。</span></p> 
<h5 id="2.%E5%BC%95%E7%94%A8%E7%9A%84%E5%AE%9A%E4%B9%89%C2%A0%20%C2%A0">2.引用的定义   </h5> 
<ul><li>引用并非是创建一个新变量，而是引用对象起一个别名，不占用内存空间</li><li>我们可以通过引用，直接去操作引用对象。</li><li>引用，可以用在函数的形参，函数的返回值，以及对某一局部变量直接使用引用。</li><li><span style="color:#fe2c24;">一个引用对象，可以有多个引用。</span></li><li><span style="color:#fe2c24;">引用必须初始化。（指针是推荐初始化，但可以不初始化）</span></li><li><span style="color:#fe2c24;">引用只能选择一个实体对象。（指针可以随意更改所指向的对象）</span></li></ul> 
<h5 id="3.%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%BF%E7%94%A8">3.引用的使用</h5> 
<p>        我们在知道了引用的的重要性和概念之后，我们该如何正确使用引用呢？C++复用了C语言中的取地址操作符——&amp;；在类型之后使用'&amp;'则为引用。<span style="color:#fe2c24;"> type&amp; 别名 = 引用对象；</span>下面将通过代码例子进行进一步的理解。 <img alt="" height="551" src="https://images2.imgbox.com/78/5b/A3S2hmiV_o.png" width="1101"><img alt="" height="572" src="https://images2.imgbox.com/12/92/75b2POm3_o.png" width="1200"><img alt="" height="592" src="https://images2.imgbox.com/0c/77/xLZassh7_o.png" width="1020"></p> 
<h5 id="4.const%20%E5%BC%95%E7%94%A8">4.const 引用</h5> 
<ul><li>const type&amp; 别名 = 引用对象。</li><li>const引用可以接受const对象，和普通对象，但普通的引用不能接受const对象——这遵从于权限不能放大，只能缩小。</li><li>临时对象：程序运行时，会在内存开辟一个临时空间，去存储表达式求值的结果，称为临时对象，且临时对象具有常数性。</li><li>const引用可以接受临时对象，从而达到延长其生命周期的效果。</li></ul> 
<h5 id="5.%E5%BC%95%E7%94%A8%E7%9A%84%E4%BC%98%E5%8A%BF">5.引用的优势</h5> 
<ul><li>引用可以做函数参数和返回值，减少拷贝提高效率；</li><li>引用传参，可以实现指针传参一样的效果，但指针要通过解引用才能访问到对象；</li><li>引用，是对引用对象起别名，这使得代码更加的直观，和安全。</li></ul> 
<h4 id="%E5%85%AD%E3%80%81%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0">六、inline</h4> 
<ul><li>函数声明与定义一起的时候，在其前面加上inline关键字，使得函数在调用的时候，并不会去建立函数栈帧，而是直接在调用函数的内部，将被调用函数的代码展开。这样减少了函数创建栈帧的效率，提高的代码运行效率，此函数称为<span style="color:#fe2c24;">内联函数。</span></li><li>在函数前面加上inline关键字，并非都被编译器所认可；递归函数、有些代码片段较长的函数，不触发内联函数的的机制。一般情况下，函数体小而简单，编译器才会进行内联函数的操作。</li><li>inline不建议声明和定义分离到两个⽂件，分离会导致链接错误。因为inline被展开，就没有函数地址，链接时会出现报错。</li></ul> 
<h4 id="%E4%B8%83%E3%80%81nullptr">七、nullptr</h4> 
<ul><li>在C语言中，C++98中，官方将宏NULL，当作空指针的符号，有些情况是void* 类型的0，而有些情况只是0。</li><li>C++中，void* 类型指针，不能隐式转换为其它类型的指针。</li><li>因此在某些函数重载的时候，NULL是隐形转换为整型0时候，是对于调用重载函数是存在歧义的；而void* 类型的0，编译器会报错。</li><li>所以C++11引用的nullptr关键字，此关键字总能被转换为任意类型的指针。</li><li>所以nullptr当作空指针，比NULL更具有安全性。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f450ec4f637da73f026170be0425358e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【北京迅为】《i.MX8MM嵌入式Linux开发指南》-第三篇 嵌入式Linux驱动开发篇-第三十九章 Linux MISC驱动</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/092400b8a5cf85d812fda1cd5a6f5803/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【MySQL调优】如何进行MySQL调优？从参数、数据建模、索引、SQL语句等方向，三万字详细解读MySQL的性能优化方案（2024版）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>