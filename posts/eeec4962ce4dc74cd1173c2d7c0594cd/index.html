<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构之排序（一） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/eeec4962ce4dc74cd1173c2d7c0594cd/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构之排序（一）">
  <meta property="og:description" content="目录
一.排序的概念及其运用
1.1排序的概念
1.2 常见的排序算法
1.3排序的用途
二、排序的原理及实现 2.1插入排序
2.1.1基本思想 ：
2.1.2排序过程：
​编辑2.1.3代码实现
2.1.4直接插入排序的特性总结：
2.2希尔排序（希尔排序法又称缩小增量法）
2.2.1基本思想：
2.2.2排序过程：
2.2.3代码实现
2.2.4希尔排序的特性总结：
2.3选择排序
2.3.1基本思想：
2.3.2排序过程：
2.3.3代码实现
2.2.4直接选择排序的特性总结：
2.4堆排序
三、结尾
一.排序的概念及其运用 1.1排序的概念 排序：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。
稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次 序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。
简单来讲，就是相同字母颜色不同的J，红色在前，蓝色在后，如图，蓝色的J经过排序之后排在了红色的J前面，则这样的排序称之为不稳定，反之，称之为稳定
内部排序：数据元素全部放在内存中的排序。
外部排序：数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。
1.2 常见的排序算法 1.3排序的用途 在店铺中，我们可以通过我们直接的需求来进行购物，而以价格从低到高，销量，评论数，这些就需要通过排序来供我们选择
二、排序的原理及实现 2.1插入排序 2.1.1基本思想 ： 直接插入排序是一种简单的插入排序法 ，其 基 本 思 想 是把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为 止，得到一个新的有序序列 。
就如我们在摸牌时，摸到一张排，对手上的排从前往后依次比较，若比到比这张牌大的时候，就插入在这张排前面，其上这样的思想与插入排序大相径庭。
2.1.2排序过程： 插入思想：当插入第i(i&gt;=1)个元素时，前面的array[0],array[1],…,array[i-1]已经排好序，此时用array[i]的排序码与 array[i-1],array[i-2],…的排序码顺序进行比较，找到插入位置即将array[i]插入，原来位置上的元素顺序后移。
2.1.3代码实现 void InsertSort(int* a, int n) { for (int i = 1; i &lt; n; i&#43;&#43;) { int end = i - 1; int tmp = a[i]; // 将tmp插入到[0,end]区间中，保持有序 while (end &gt;= 0) { if (tmp &lt; a[end]) { a[end &#43; 1] = a[end]; --end; } else { break; } } a[end &#43; 1] = tmp; } } 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-25T10:49:40+08:00">
    <meta property="article:modified_time" content="2024-08-25T10:49:40+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构之排序（一）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%B8%80.%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E8%BF%90%E7%94%A8-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E8%BF%90%E7%94%A8" rel="nofollow">一.排序的概念及其运用</a></p> 
<p id="1.1%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#1.1%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">1.1排序的概念</a></p> 
<p id="1.2%C2%A0%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-toc" style="margin-left:80px;"><a href="#1.2%C2%A0%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" rel="nofollow">1.2 常见的排序算法</a></p> 
<p id="%C2%A01.3%E6%8E%92%E5%BA%8F%E7%9A%84%E7%94%A8%E9%80%94-toc" style="margin-left:80px;"><a href="#%C2%A01.3%E6%8E%92%E5%BA%8F%E7%9A%84%E7%94%A8%E9%80%94" rel="nofollow"> 1.3排序的用途</a></p> 
<p id="%E4%BA%8C%E3%80%81%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%C2%A0" rel="nofollow">二、排序的原理及实现 </a></p> 
<p id="2.1%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#2.1%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" rel="nofollow">2.1插入排序</a></p> 
<p id="2.1.1%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%20%EF%BC%9A-toc" style="margin-left:120px;"><a href="#2.1.1%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%20%EF%BC%9A" rel="nofollow">2.1.1基本思想 ：</a></p> 
<p id="2.1.2%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B%EF%BC%9A-toc" style="margin-left:120px;"><a href="#2.1.2%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B%EF%BC%9A" rel="nofollow">2.1.2排序过程：</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%912.1.3%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:120px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%912.1.3%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">​编辑2.1.3代码实现</a></p> 
<p id="2.1.4%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%EF%BC%9A-toc" style="margin-left:120px;"><a href="#2.1.4%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%EF%BC%9A" rel="nofollow">2.1.4直接插入排序的特性总结：</a></p> 
<p id="2.2%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E6%B3%95%E5%8F%88%E7%A7%B0%E7%BC%A9%E5%B0%8F%E5%A2%9E%E9%87%8F%E6%B3%95%EF%BC%89-toc" style="margin-left:80px;"><a href="#2.2%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E6%B3%95%E5%8F%88%E7%A7%B0%E7%BC%A9%E5%B0%8F%E5%A2%9E%E9%87%8F%E6%B3%95%EF%BC%89" rel="nofollow">2.2希尔排序（希尔排序法又称缩小增量法）</a></p> 
<p id="2.2.1%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A-toc" style="margin-left:120px;"><a href="#2.2.1%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A" rel="nofollow">2.2.1基本思想：</a></p> 
<p id="2.2.2%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B%EF%BC%9A-toc" style="margin-left:120px;"><a href="#2.2.2%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B%EF%BC%9A" rel="nofollow">2.2.2排序过程：</a></p> 
<p id="2.2.3%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:120px;"><a href="#2.2.3%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">2.2.3代码实现</a></p> 
<p id="2.2.4%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%EF%BC%9A-toc" style="margin-left:120px;"><a href="#2.2.4%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%EF%BC%9A" rel="nofollow">2.2.4希尔排序的特性总结：</a></p> 
<p id="%C2%A02.3%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#%C2%A02.3%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" rel="nofollow"> 2.3选择排序</a></p> 
<p id="2.3.1%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A-toc" style="margin-left:120px;"><a href="#2.3.1%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A" rel="nofollow">2.3.1基本思想：</a></p> 
<p id="2.3.2%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B%EF%BC%9A-toc" style="margin-left:120px;"><a href="#2.3.2%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B%EF%BC%9A" rel="nofollow">2.3.2排序过程：</a></p> 
<p id="%C2%A02.3.3%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:120px;"><a href="#%C2%A02.3.3%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow"> 2.3.3代码实现</a></p> 
<p id="2.2.4%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%EF%BC%9A-toc" style="margin-left:120px;"><a href="#2.2.4%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%EF%BC%9A" rel="nofollow">2.2.4直接选择排序的特性总结：</a></p> 
<p id="2.4%E5%A0%86%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#2.4%E5%A0%86%E6%8E%92%E5%BA%8F" rel="nofollow">2.4堆排序</a></p> 
<p id="%E4%BA%94%E3%80%81%E7%BB%93%E5%B0%BE-toc" style="margin-left:40px;"><a href="#%E4%BA%94%E3%80%81%E7%BB%93%E5%B0%BE" rel="nofollow">三、结尾</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80.%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E8%BF%90%E7%94%A8">一.排序的概念及其运用</h2> 
<h4 id="1.1%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A6%82%E5%BF%B5">1.1排序的概念</h4> 
<p>排序：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。</p> 
<p>稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次 序保持不变，即在原序列中，<span style="color:#fe2c24;">r[i]=r[j]</span>，且<span style="color:#fe2c24;">r[i]在r[j]之前</span>，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是<span style="color:#fe2c24;">稳定的</span>；否则称为<span style="color:#fe2c24;">不稳定的</span>。</p> 
<blockquote> 
 <p>简单来讲，就是相同字母颜色不同的J，红色在前，蓝色在后，如图，蓝色的J经过排序之后排在了红色的J前面，则这样的排序称之为不稳定，反之，称之为稳定</p> 
</blockquote> 
<p><img alt="" height="329" src="https://images2.imgbox.com/11/de/4Y4bR6f8_o.png" width="950"></p> 
<p>内部排序：数据元素全部放在内存中的排序。</p> 
<p>外部排序：数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。</p> 
<h4 id="1.2%C2%A0%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">1.2 常见的排序算法</h4> 
<p class="img-center"><img alt="" height="364" src="https://images2.imgbox.com/38/91/PZwajbwi_o.png" width="455"></p> 
<h4 id="%C2%A01.3%E6%8E%92%E5%BA%8F%E7%9A%84%E7%94%A8%E9%80%94"> 1.3排序的用途</h4> 
<p>在店铺中，我们可以通过我们直接的需求来进行购物，而以价格从低到高，销量，评论数，这些就需要通过排序来供我们选择</p> 
<p><img alt="" height="720" src="https://images2.imgbox.com/3f/a4/hTUM347t_o.png" width="1200"></p> 
<h2 id="%E4%BA%8C%E3%80%81%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%C2%A0">二、排序的原理及实现 </h2> 
<h4 id="2.1%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">2.1插入排序</h4> 
<h5 id="2.1.1%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%20%EF%BC%9A" style="background-color:transparent;">2.1.1基本思想 ：</h5> 
<blockquote> 
 <p>直接插入排序是一种简单的插入排序法 ，其 基 本 思 想 是把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为 止，得到一个新的有序序列 。</p> 
</blockquote> 
<p> </p> 
<p class="img-center"><img alt="" height="316" src="https://images2.imgbox.com/2f/1a/MoME0gmN_o.png" width="359"></p> 
<p>就如我们在摸牌时，摸到一张排，对手上的排从前往后依次比较，若比到比这张牌大的时候，就插入在这张排前面，其上这样的思想与插入排序大相径庭。</p> 
<h5 id="2.1.2%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B%EF%BC%9A" style="background-color:transparent;">2.1.2排序过程：</h5> 
<p><span style="color:#fe2c24;">插入思想：</span>当插入第i(i&gt;=1)个元素时，前面的array[0],array[1],…,array[i-1]已经排好序，此时用array[i]的排序码与 array[i-1],array[i-2],…的排序码顺序进行比较，找到插入位置即将array[i]插入，原来位置上的元素顺序后移。</p> 
<h5 id="%E2%80%8B%E7%BC%96%E8%BE%912.1.3%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><img alt="" height="505" src="https://images2.imgbox.com/45/73/vrpxzenY_o.gif" width="811">2.1.3代码实现</h5> 
<pre><code class="language-cs">void InsertSort(int* a, int n)
{
	for (int i = 1; i &lt; n; i++)
	{
		int end = i - 1;
		int tmp = a[i];
		// 将tmp插入到[0,end]区间中，保持有序
		while (end &gt;= 0)
		{
			if (tmp &lt; a[end])
			{
				a[end + 1] = a[end];
				--end;
			}
			else
			{
				break;
			}
		}

		a[end + 1] = tmp;
	}
}</code></pre> 
<h5 id="2.1.4%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%EF%BC%9A">2.1.4直接插入排序的特性总结：</h5> 
<p>1. 元素集合越接近有序，直接插入排序算法的时间效率越高</p> 
<p>2. 时间复杂度：O(N^2)</p> 
<p>3. 空间复杂度：O(1)，它是一种稳定的排序算法</p> 
<p>4. 稳定性：稳定</p> 
<h4 id="2.2%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E6%B3%95%E5%8F%88%E7%A7%B0%E7%BC%A9%E5%B0%8F%E5%A2%9E%E9%87%8F%E6%B3%95%EF%BC%89">2.2希尔排序（希尔排序法又称缩小增量法）</h4> 
<h5 id="2.2.1%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A" style="background-color:transparent;">2.2.1基本思想：</h5> 
<p>先选定一个整数，把待排序文件中所有记录分成个 组，所有距离为的记录分在同一组内，并对每一组内的记录进行排序。然后，取，重复上述分组和排序的工 作。当到达=1时，所有记录在统一组内排好序。</p> 
<h5 id="2.2.2%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B%EF%BC%9A" style="background-color:transparent;">2.2.2排序过程：</h5> 
<ol><li><strong>初始化增量序列</strong>：选择一个增量序列，如希尔建议的序列、Hibbard序列、Sedgewick序列等，这些序列通常是递减的正整数序列。增量序列的选择会直接影响希尔排序的性能。</li><li><strong>外层循环</strong>：逐步缩小增量。在每次外层循环中，根据当前的增量值对元素进行分组，每组包含相隔一定间隔的元素。</li><li><strong>内层循环</strong>：插入排序。在每一组内，通过插入排序对元素进行排序。即比较相隔增量的元素，并在需要时交换它们的位置，逐步实现每个小组的局部有序。</li><li><strong>完成排序</strong>：重复外层循环和内层循环，逐渐减小增量，直到增量为1。此时，整个序列已经基本有序，再进行一次标准的插入排序，完成整个排序过程。</li></ol> 
<p><img alt="" height="514" src="https://images2.imgbox.com/09/bb/EfMnsWqy_o.png" width="683"></p> 
<h5 id="2.2.3%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">2.2.3代码实现</h5> 
<pre><code class="language-cs">void ShellSort(int* a, int n)
{
    // gap &gt; 1 预排序
	// gap == 1 直接插入排序
	int gap = n;
	while (gap &gt; 1)
	{
        任选一种
		gap /= 2;
        //gap = gap / 3 + 1;
		for (int i = 0; i &lt; n - gap; i++)
		{
			int end = i;
			int tmp = a[i + gap];
			while (end &gt;= 0)
			{
				if (tmp &lt; a[end])
				{
					a[end + gap] = a[end];
					end -= gap;
				}
				else
				{
					break;
				}
			}
			a[end + gap] = tmp;
		}

	}
}</code></pre> 
<h5 id="2.2.4%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%EF%BC%9A" style="background-color:transparent;">2.2.4希尔排序的特性总结：</h5> 
<p>1. 希尔排序是对直接插入排序的优化。</p> 
<p>2. 当gap &gt; 1时都是预排序，目的是让数组更接近于有序。当gap == 1时，数组已经接近有序的了，这样就 会很快。这样整体而言，可以达到优化的效果。我们实现后可以进行性能测试的对比。</p> 
<p>3. 希尔排序的时间复杂度不好计算，因为gap的取值方法很多，导致很难去计算，因此在好些树中给出的 希尔排序的时间复杂度都不固定：</p> 
<p><img alt="" height="375" src="https://images2.imgbox.com/95/f1/kqYHwQaO_o.png" width="1200"></p> 
<p>《数据结构-用面相对象方法与C++描述》--- 殷人昆 </p> 
<p><img alt="" height="417" src="https://images2.imgbox.com/2f/9b/Lwt4oN6o_o.png" width="1200"></p> 
<p>4. 稳定性：不稳定  </p> 
<h4 id="%C2%A02.3%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"> 2.3选择排序</h4> 
<h5 id="2.3.1%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A" style="background-color:transparent;">2.3.1基本思想：</h5> 
<p>每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的 数据元素排完 。</p> 
<h5 id="2.3.2%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B%EF%BC%9A">2.3.2排序过程：</h5> 
<ul><li>在元素集合array[i]--array[n-1]中选择关键码最大(小)的数据元素</li><li>若它不是这组元素中的最后一个(第一个)元素，则将它与这组元素中的最后一个（第一个）元素交换</li><li>在剩余的array[i]--array[n-2]（array[i+1]--array[n-1]）集合中，重复上述步骤，直到集合剩余1个元素</li></ul> 
<p> <img alt="" height="248" src="https://images2.imgbox.com/08/40/ITgIfziJ_o.gif" width="811"></p> 
<h5 id="%C2%A02.3.3%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" style="background-color:transparent;"> 2.3.3代码实现</h5> 
<pre><code class="language-cs">void Swap(int* p1, int* p2)
{
	int tmp = *p1;
	*p1 = *p2;
	*p2 = tmp;
}

// 最坏：O(N^2)
// 最好：O(N^2).
void SelectSort(int* a, int n)
{
	int left = 0, right = n - 1;
	while (left &lt; right)
	{
		int mini = left, maxi = left;
		for (int i = left + 1; i &lt;= right; i++)
		{
			if (a[i] &lt; a[mini])
			{
				mini = i;
			}

			if (a[i] &gt; a[maxi])
			{
				maxi = i;
			}
		}

		Swap(&amp;a[left], &amp;a[mini]);
		// 如果left和maxi重叠，交换后修正一下
		if (left == maxi)
		{
			maxi = mini;
		}

		Swap(&amp;a[right], &amp;a[maxi]);

		++left;
		--right;
	}
}
</code></pre> 
<h5 id="2.2.4%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%EF%BC%9A">2.2.4直接选择排序的特性总结：</h5> 
<p>1. 直接选择排序思考非常好理解，但是效率不是很好。实际中很少使用</p> 
<p>2. 时间复杂度：O(N^2)</p> 
<p>3. 空间复杂度：O(1)</p> 
<p>4. 稳定性：不稳定</p> 
<h4 id="2.4%E5%A0%86%E6%8E%92%E5%BA%8F">2.4堆排序</h4> 
<blockquote> 
 <p>堆排序这里不过多解释了，详细讲解在我写的这篇文章有详细的讲解。<a href="https://blog.csdn.net/2201_75537851/article/details/141095152?spm=1001.2014.3001.5501" title="非线性表之堆的实际应用和二叉树的遍历-CSDN博客">非线性表之堆的实际应用和二叉树的遍历-CSDN博客</a></p> 
</blockquote> 
<h3 id="%E4%BA%94%E3%80%81%E7%BB%93%E5%B0%BE">三、结尾</h3> 
<p>如果有什么建议和疑问，或是有什么错误，希望大家可以在评论区提一下。<br> 希望大家以后也能和我一起进步！！<br> 如果这篇文章对你有用的话，希望能给我一个小小的赞！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7ecf06baf73b71b75418ff5a7a974c21/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据仓库系列4-什么是维度建模,它与关系型建模有什么区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/747fbffbe0c704f5559e91f287770cab/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">《黑神话·悟空》是用什么编程语言开发的？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>