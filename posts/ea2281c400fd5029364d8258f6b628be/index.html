<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>k8s学习--资源控制器StatefulSet详细解释与应用 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ea2281c400fd5029364d8258f6b628be/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="k8s学习--资源控制器StatefulSet详细解释与应用">
  <meta property="og:description" content="文章目录 一 StatefulSet是什么？statefulset是什么k8s中常见的pod控制器类型有哪些statefulset与其他pod控制器的区别是什么有状态服务和无状态服务区别是什么StatefulSet作用statefulSet的特点statefulSet组成 部署statefulset应用部署storageclass（1）主机基础配置（2）配置 NFS:（3）创建配置storageclass 2.部署headless service3.Statefulset应用示例 一 StatefulSet是什么？ statefulset是什么 是k8s中常见的pod控制器类型之一
k8s中常见的pod控制器类型有哪些 ReplicaSet:即RS
Deployment
DaemonSet:即DS
StatefulSet
Job
Cronjob
statefulset与其他pod控制器的区别是什么 我们在生产中常用的副本(pod)控制器如Deployment,DaemonSet,RS都是使用于无状态服务，其所管理的Pod的启停顺序，IP，Pod名称都是随机的，被管理的Pod更新时,这些都会发生变化,而我们在管理如mysql,redis,kafka,consul这些集群是为了管理方便，就可以使用
有状态服务statefulSet
Kubernetes中StatefulSet是专为有状态服务如mysql、redis、kafka、consul等集群准备的集合，管理所有有状态服务。
注:无状态服务同样可以使用statefulset控制器
有状态服务和无状态服务区别是什么 简单理解（个人理解）
无状态服务里随机的参数(Pod的启停顺序、IP、Pod名称)在有状态服务里都不是随机的，有顺序的
详细解释
无状态服务（Stateless Services）：
1.在 Kubernetes 中，无状态服务通常以 Deployment 或者 ReplicaSet 的方式进行部署和管理。
2.无状态服务的实例可以随意扩展和收缩，因为它们之间是相互替换的，而且不需要关注特定实例的状态。
3.无状态服务可以使用水平扩展来应对高负载，Kubernetes 可以根据实际负载自动添加或移除实例。
有状态服务（Stateful Services）：
1.在 Kubernetes 中，有状态服务通常以 StatefulSet 的方式进行部署和管理。
2.StatefulSet 提供了稳定的网络标识和持久化存储的能力，确保每个实例都有唯一的标识并且可以使用持久化卷来保存状态数据。
3.有状态服务的实例通常需要按照确定的顺序部署和扩展，因为它们的状态数据可能会影响到服务的行为。
StatefulSet作用 主要用来管理有状态应用的控制器。
用来管理某Pod集合的部署和扩缩，并为这些 Pod 提供持久存储和持久标识符。
statefulSet的特点 1.稳定的网络标识：StatefulSet 中的每个 Pod 都有一个稳定的网络标识符（例如 hostname），这使得这些 Pod 可以有确定的网络身份，并且可以被其他应用程序依赖和访问。
2.有序部署和扩展：StatefulSet 保证 Pod 的部署和扩展是按照确定的顺序进行的，每个 Pod 都有一个唯一的标识符，这对于需要有序启动和停止的应用程序非常重要。
3.持久化存储：StatefulSet 支持使用持久卷（PersistentVolume）来存储 Pod 的状态数据，确保即使 Pod 被重新调度到其他节点，其状态数据也不会丢失。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-29T14:38:47+08:00">
    <meta property="article:modified_time" content="2024-05-29T14:38:47+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">k8s学习--资源控制器StatefulSet详细解释与应用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_StatefulSet_6" rel="nofollow">一 StatefulSet是什么？</a></li><li><ul><li><a href="#statefulset_7" rel="nofollow">statefulset是什么</a></li><li><a href="#k8spod_10" rel="nofollow">k8s中常见的pod控制器类型有哪些</a></li><li><a href="#statefulsetpod_18" rel="nofollow">statefulset与其他pod控制器的区别是什么</a></li><li><a href="#_24" rel="nofollow">有状态服务和无状态服务区别是什么</a></li><li><a href="#StatefulSet_45" rel="nofollow">StatefulSet作用</a></li><li><a href="#statefulSet_49" rel="nofollow">statefulSet的特点</a></li><li><a href="#statefulSet_60" rel="nofollow">statefulSet组成</a></li></ul> 
  </li><li><a href="#statefulset_70" rel="nofollow">部署statefulset应用</a></li><li><ul><li><a href="#storageclass_86" rel="nofollow">部署storageclass</a></li><li><ul><li><a href="#1_87" rel="nofollow">（1）主机基础配置</a></li><li><a href="#2_NFS_96" rel="nofollow">（2）配置 NFS:</a></li><li><a href="#3storageclass_116" rel="nofollow">（3）创建配置storageclass</a></li></ul> 
   </li><li><a href="#2headless_service_127" rel="nofollow">2.部署headless service</a></li><li><a href="#3Statefulset_140" rel="nofollow">3.Statefulset应用示例</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_StatefulSet_6"></a>一 StatefulSet是什么？</h2> 
<h3><a id="statefulset_7"></a>statefulset是什么</h3> 
<p>是k8s中常见的pod控制器类型之一</p> 
<h3><a id="k8spod_10"></a>k8s中常见的pod控制器类型有哪些</h3> 
<p>ReplicaSet:即RS<br> Deployment<br> DaemonSet:即DS<br> StatefulSet<br> Job<br> Cronjob</p> 
<h3><a id="statefulsetpod_18"></a>statefulset与其他pod控制器的区别是什么</h3> 
<p>我们在生产中常用的副本(pod)控制器如Deployment,DaemonSet,RS都是使用于无状态服务，其所管理的Pod的启停顺序，IP，Pod名称都是随机的，被管理的Pod更新时,这些都会发生变化,而我们在管理如mysql,redis,kafka,consul这些集群是为了管理方便，就可以使用<br> 有状态服务statefulSet<br> Kubernetes中StatefulSet是专为有状态服务如mysql、redis、kafka、consul等集群准备的集合，管理所有有状态服务。<br> <strong>注</strong>:无状态服务同样可以使用statefulset控制器</p> 
<h3><a id="_24"></a>有状态服务和无状态服务区别是什么</h3> 
<p><strong>简单理解</strong>（个人理解）<br> 无状态服务里随机的参数(Pod的启停顺序、IP、Pod名称)在有状态服务里都不是随机的，有顺序的</p> 
<p><strong>详细解释</strong><br> <strong>无状态服务（Stateless Services）：</strong></p> 
<p>1.在 Kubernetes 中，无状态服务通常以 Deployment 或者 ReplicaSet 的方式进行部署和管理。</p> 
<p>2.无状态服务的实例可以随意扩展和收缩，因为它们之间是相互替换的，而且不需要关注特定实例的状态。</p> 
<p>3.无状态服务可以使用水平扩展来应对高负载，Kubernetes 可以根据实际负载自动添加或移除实例。</p> 
<p><strong>有状态服务（Stateful Services）：</strong></p> 
<p>1.在 Kubernetes 中，有状态服务通常以 StatefulSet 的方式进行部署和管理。</p> 
<p>2.StatefulSet 提供了稳定的网络标识和持久化存储的能力，确保每个实例都有唯一的标识并且可以使用持久化卷来保存状态数据。</p> 
<p>3.有状态服务的实例通常需要按照确定的顺序部署和扩展，因为它们的状态数据可能会影响到服务的行为。</p> 
<h3><a id="StatefulSet_45"></a>StatefulSet作用</h3> 
<p>主要用来管理有状态应用的控制器。<br> 用来管理某Pod集合的部署和扩缩，并为这些 Pod 提供持久存储和持久标识符。</p> 
<h3><a id="statefulSet_49"></a>statefulSet的特点</h3> 
<p>1.稳定的网络标识：StatefulSet 中的每个 Pod 都有一个稳定的网络标识符（例如 hostname），这使得这些 Pod 可以有确定的网络身份，并且可以被其他应用程序依赖和访问。</p> 
<p>2.有序部署和扩展：StatefulSet 保证 Pod 的部署和扩展是按照确定的顺序进行的，每个 Pod 都有一个唯一的标识符，这对于需要有序启动和停止的应用程序非常重要。</p> 
<p>3.持久化存储：StatefulSet 支持使用持久卷（PersistentVolume）来存储 Pod 的状态数据，确保即使 Pod 被重新调度到其他节点，其状态数据也不会丢失。</p> 
<p>4.自主管理的标识符：StatefulSet 可以为每个 Pod 分配一个自主管理的标识符，例如在有状态服务中使用的索引或者名称。这些标识符可以在 Pod 重新启动或者重新调度后保持不变。</p> 
<p>5.有状态服务的更新：StatefulSet 支持有状态服务的滚动更新，确保在更新过程中不会破坏服务的可用性，并且可以保持有状态服务的稳定性。</p> 
<h3><a id="statefulSet_60"></a>statefulSet组成</h3> 
<p>一个完整的StatefulSet应用由三个部分组成：</p> 
<p>headless service、<br> StatefulSet controller、<br> volumeClaimTemplate。</p> 
<p>headless service(无头服务)<br> 简单来说就是没有群集ip</p> 
<h2><a id="statefulset_70"></a>部署statefulset应用</h2> 
<table><thead><tr><th>Ip</th><th>主机名</th><th>cpu</th><th>内存</th><th>硬盘</th></tr></thead><tbody><tr><td>192.168.10.11</td><td>master</td><td>1cpu双核</td><td>2G</td><td>40G</td></tr><tr><td>192.168.10.12</td><td>node01</td><td>1cpu双核</td><td>2G</td><td>40G</td></tr><tr><td>192.168.10.13</td><td>node02</td><td>1cpu双核</td><td>2G</td><td>40G</td></tr><tr><td>192.168.10.17</td><td>nfs</td><td>1cpu1核</td><td>1G</td><td>40G</td></tr></tbody></table> 
<p>虚拟机 centos7.9</p> 
<p>master node01 node02 已部署k8s集群<br> 版本 1.18.0</p> 
<p>nfs服务器部署nfs</p> 
<h3><a id="storageclass_86"></a>部署storageclass</h3> 
<h4><a id="1_87"></a>（1）主机基础配置</h4> 
<p>由于nfs是新创建的虚拟机需要关闭防火墙，关闭沙盒</p> 
<pre><code>systemctl stop firewalld
systemctl disable firewalld
setenforce 0
sed -i 's/SELINUX=enforcing/SELINUX=disabled/' /etc/sysconfig/selinux
</code></pre> 
<h4><a id="2_NFS_96"></a>（2）配置 NFS:</h4> 
<p>所有主机都需要安装nfs</p> 
<pre><code>yum -y install nfs-utils rpcbind
</code></pre> 
<p>其次在nfs主机上</p> 
<pre><code>mkdir /nfsdata
vim /etc/exports
输入
/nfsdata *(rw,sync,no_root_squash)
systemctl start rpcbind
systemctl start nfs-server
systemctl enable rpcbind
systemctl enable nfs-server
showmount -e
</code></pre> 
<p>看到这个nfs就部署成功了<br> <img src="https://images2.imgbox.com/72/1e/0pIFQIYF_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3storageclass_116"></a>（3）创建配置storageclass</h4> 
<p>yaml文件内容详见，这里不再过多记述<br> 链接: <a href="https://blog.csdn.net/lwxvgdv/article/details/139268228">storageclass详细解释与应用</a></p> 
<p>创建账号、创建权限、给账号关联权限<br> [root@master ~]# kubectl apply -f account.yaml<br> 通过中间件将访问账号与共享存储关联<br> [root@master ~]# kubectl apply -f nfs-deployment.yaml<br> 配置storageclass与中间件关联<br> [root@master ~]# kubectl apply -f storageclass.yaml</p> 
<h3><a id="2headless_service_127"></a>2.部署headless service</h3> 
<p><strong>为什么用headless service无头服务？</strong><br> 在用Deployment时，每一个Pod名称是没有顺序的，是随机字符串，因此是Pod名称是无序的，但是在statefulset中要求必须是有序，每一个pod不能被随意取代，pod重建后pod名称还是一样的。</p> 
<p>在有状态服务中，pod名称是pod唯一性的标识符，必须持久稳定有效。这时候要用到无头服务，它可以给每个Pod一个唯一的名称。</p> 
<p>**为什么用volumeClaim Template?<br> 对于有状态的副本集都会用到持久存储，特别是对于分布式系统来讲，它的最大特点是数据是不一样的，所以各个节点不能使用同一存储卷，每个节点有自已的专用存储，</p> 
<p>但是如果在Deployment中的Pod template里定义的存储卷，是所有副本集共用一个存储卷，数据是相同的，因为是基于模板来的，</p> 
<p>而statefulset中每个Pod都要自已的专有存储卷，所以statefulset的存储卷就不能再用Pod模板来创建了，于是statefulSet使用volumeClaimTemplate，称为卷申请模板，它会为每个Pod生成不同的pvc，并绑定pv，从而实现各pod有专用存储。</p> 
<h3><a id="3Statefulset_140"></a>3.Statefulset应用示例</h3> 
<p>[root@master yaml]# vim nfs-deployment.yaml</p> 
<pre><code class="prism language-\">apiVersion: v1
kind: Service
metadata:
  name: headless-svc
  labels:
    app: headless-svc
spec:
  ports:
  - name: myweb
    port: 80
  selector:
    app: headless-pod
  clusterIP: None

---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: statefulset
spec:
  serviceName: headless-svc
  replicas: 3
  selector:
    matchLabels:
      app: headless-pod
  template:
    metadata:
      labels:
        app: headless-pod
    spec:
      containers:
      - name: myweb
        image: nginx:1.20
        imagePullPolicy: IfNotPresent
        volumeMounts:
        - name: test-storage
          mountPath: /usr/share/nginx/html
  volumeClaimTemplates:
  - metadata:
      name: test-storage
      annotations:
        volume.beta.kubernetes.io/storage-class: storageclass
    spec:
      accessModes:
        - ReadWriteOnce
      resources:
        requests:
          storage: 100Mi
</code></pre> 
<pre><code class="prism language-\">[root@master yaml]# kubectl apply -f statefulset.yaml 
[root@master yaml]# kubectl get pv,pvc
</code></pre> 
<p><img src="https://images2.imgbox.com/ec/2c/rKuYI2e9_o.png" alt="在这里插入图片描述"><br> 从上面可以看到<br> storageclass自动创建了PV<br> volumeClaimTemplate自动创建了PVC<br> 现在测试每一个Pod是否有自己独特的数据持久化目录，也就是说，每一个Pod内的数据是不是都是不一样的</p> 
<p>分别在对应的PV下，模拟创建不同的数据。</p> 
<pre><code>[root@nfs ~]# echo 000 &gt; /nfsdata/default-test-storage-statefulset-0-pvc-6ff2b4bf-789a-4fd3-987e-72db4fb2fa09/testfile
[root@nfs ~]# echo 111 &gt; /nfsdata/default-test-storage-statefulset-1-pvc-7076ef24-3ea7-419a-abed-4dc27886681a/testfile
[root@nfs ~]# echo 222 &gt; /nfsdata/default-test-storage-statefulset-2-pvc-bc5df9e7-183e-4c70-9574-e8cb48823bae/testfile
</code></pre> 
<p>查看对应Pod的数据持久化目录，可以看出，每个Pod的内容都不一样</p> 
<pre><code>[root@master yaml]# kubectl exec -it statefulset-0 -- cat /usr/share/nginx/html/testfile
000
[root@master yaml]# kubectl exec -it statefulset-1 -- cat /usr/share/nginx/html/testfile
111
[root@master yaml]# kubectl exec -it statefulset-2 -- cat /usr/share/nginx/html/testfile
222
</code></pre> 
<p><img src="https://images2.imgbox.com/1d/9c/8iHcpS37_o.png" alt="在这里插入图片描述"><br> 可以看到是不一样的</p> 
<p>实验完成</p> 
<p>如果对您有帮助就点个赞吧</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/290cdb4c5176ef4e519a8a0ccffe9632/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">相机系列——相机标定简述</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/838bc62b1d75b185eedf783512726bc5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">让 AI 回答更精准 ◎ 来学学这些Prompt入门小技巧</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>