<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>移情别恋c&#43;&#43; ദ്ദി˶ｰ̀֊ｰ́ ) ——9.模板进阶 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b8688d73dd79ae3f2508feb9af853881/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="移情别恋c&#43;&#43; ദ്ദി˶ｰ̀֊ｰ́ ) ——9.模板进阶">
  <meta property="og:description" content="1.非类型模板参数 之前所使用的模板参数都是用来匹配不同的类型，如 int、double、Date 等，模板参数除了可以匹配类型外，还可以匹配常量（非类型）
我们知道模板参数分为 : 类型形参 与 非类型形参 类型模板形参 : 出现在模板参数列表中，跟在 class 或者 typename 类之后的参数类型名称。
template &lt;class T&gt; // T 为模板参数中的 ---------- 类型模板形参
非类型模板形参 : 就是用一个常量作为类(函数)模板的一个参数，在类(函数)模板中可将该参数当成常量来使用。
template &lt;size_t N&gt; // N 为模板参数中的 ------- 非类型模板形参
注：非类型模板参数必须为常量，即在编译阶段确定值 1.1用 类型模板形参和 非类型模板形参构建泛型、大小可自定义 的数组 template&lt;class T, size_t N&gt; class arr { public: T&amp; operator[](size_t pos) { assert(pos &gt;= 0 &amp;&amp; pos &lt; N); return _arr[pos]; } size_t size() const { return N; } private: int _arr[N];	//创建大小为 N 的整型数组 }; int main() { arr&lt;int , 10&gt; a1; // 大小为 10 arr&lt;double , 20&gt; a2; // 大小为 20 arr&lt;char , 100&gt; a3; // 大小为 100 // 输出它们的 类型 cout &lt;&lt; typeid(a1).">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-09-02T13:32:04+08:00">
    <meta property="article:modified_time" content="2024-09-02T13:32:04+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">移情别恋c&#43;&#43; ദ്ദി˶ｰ̀֊ｰ́ ) ——9.模板进阶</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1.非类型模板参数</h2> 
<blockquote> 
 <p>之前所使用的<strong>模板参数</strong>都是用来<strong>匹配不同的类型</strong>，如 <strong><code>int</code>、<code>double</code>、<code>Date</code></strong> 等，<a href="https://so.csdn.net/so/search?q=%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0&amp;spm=1001.2101.3001.7020" title="模板参数">模板参数</a>除了可以匹配类型外，还可以<strong>匹配常量（非类型）</strong></p> 
</blockquote> 
<p>我们知道<strong>模板参数</strong>分为 : <span style="color:#fe2c24;"><strong>类型形参</strong></span> 与 <span style="color:#fe2c24;"><strong>非类型形参 </strong></span></p> 
<blockquote> 
 <p>类型模板形参 : 出现在模板参数列表中，跟在 class 或者 typename 类之后的参数类型名称。</p> 
 <p><br> template &lt;<span style="color:#fe2c24;"><strong>class T</strong></span>&gt;  // T 为模板参数中的 ----------<span style="color:#38d8f0;"><strong> 类型模板形参</strong></span></p> 
 <p><br> 非类型模板形参 : 就是用一个常量作为类(函数)模板的一个参数，在类(函数)模板中可将该参数当成常量来使用。</p> 
 <p><br> template &lt;<span style="color:#fe2c24;">size_t N</span>&gt;  // N 为模板参数中的 ------- <strong><span style="color:#38d8f0;">非类型模板形参</span></strong></p> 
</blockquote> 
<blockquote> 
 <p>注：<strong><span style="color:#956fe7;">非类型模板参数必须为常量</span>，即在编译阶段确定值</strong>  </p> 
</blockquote> 
<p> </p> 
<h3>1.1<span style="color:#0d0016;">用 类型模板形参和 非类型模板形参构建</span><span style="color:#fe2c24;"><strong>泛型</strong></span><span style="color:#0d0016;">、</span><span style="color:#fe2c24;"><strong>大小可自定义</strong></span><span style="color:#0d0016;"> 的数组 </span></h3> 
<p>                           </p> 
<pre><code class="hljs">template&lt;class T, size_t N&gt;
class arr
{
public:
    T&amp; operator[](size_t pos)
	{
		assert(pos &gt;= 0 &amp;&amp; pos &lt; N);
		return _arr[pos];
	}
	size_t size() const
	{
		return N;
	}
 
private:
	int _arr[N];	//创建大小为 N 的整型数组
};
 
int main()
{
	arr&lt;int , 10&gt; a1;   // 大小为 10
	arr&lt;double , 20&gt; a2;   // 大小为 20
	arr&lt;char , 100&gt; a3;  // 大小为 100
 
	// 输出它们的 类型
	cout &lt;&lt; typeid(a1).name() &lt;&lt; endl;
	cout &lt;&lt; typeid(a2).name() &lt;&lt; endl;
	cout &lt;&lt; typeid(a3).name() &lt;&lt; endl;
}</code></pre> 
<h3>1.2非类型模板参数的使用规则 </h3> 
<p> </p> 
<blockquote> 
 <p> 非类型模板参数要求类型为 <strong><span style="color:#956fe7;">整型家族</span></strong>，其他类型是不行的 </p> 
</blockquote> 
<pre><code class="hljs">//整型家族（部分）
template&lt;class T, int N&gt;
class arr1 { /*……*/ };
 
template&lt;class T, long N&gt;
class arr2 { /*……*/ };
 
template&lt;class T, char N&gt;
class arr3 { /*……*/ };</code></pre> 
<blockquote> 
 <p> 因此可以总结出，<strong>非类型模板参数</strong> 的使用要求为</p> 
 <ul><li><strong>只能将<span style="color:#fe2c24;"> 整型家族</span> 类型作为非类型模板参数，其他类型不在标准之内</strong></li><li><strong>非类型模板参数必须为<span style="color:#fe2c24;">常量（不可被修改）</span>，且需要在编译阶段确定结果</strong></li></ul> 
 <p> </p> 
</blockquote> 
<blockquote> 
 <p><strong>整型家族：<code>char</code>、<code>short</code>、<code>bool</code>、<code>int</code>、<code>long</code>、<code>long long</code> 等</strong> </p> 
</blockquote> 
<h2>2. 模板的特化 </h2> 
<h3 style="background-color:transparent;">2.1 概念</h3> 
<p>通常情况下，使用模板可以实现一些与类型无关的代码，但对于一些特殊类型的可能会得到一些 错误的结果，<span style="color:#fe2c24;"><strong>需要特殊处理</strong></span>，比如：实现了一个专门用来进行小于比较的函数模板</p> 
<pre><code class="hljs">// 函数模板 -- 参数匹配
template&lt;class T&gt;
bool Less(T left, T right)
{
 return left &lt; right;
}
int main()
{
 cout &lt;&lt; Less(1, 2) &lt;&lt; endl;   // 可以比较，结果正确
 Date d1(2022, 7, 7);
 Date d2(2022, 7, 8);

 cout &lt;&lt; Less(d1, d2) &lt;&lt; endl;  // 可以比较，结果正确

 Date* p1 = &amp;d1;
 Date* p2 = &amp;d2;
 cout &lt;&lt; Less(p1, p2) &lt;&lt; endl;  // 可以比较，结果错误
 return 0;
}
</code></pre> 
<blockquote> 
 <p>可以看到，Less绝对多数情况下都可以正常比较，但是在特殊场景下就得到错误的结果。上述示 例中，p1指向的d1显然小于p2指向的d2对象，<strong>但是Less内部并没有比较p1和p2指向的对象内 容，而比较的是p1和p2指针的地址，这就无法达到预期而错误。</strong></p> 
 <p></p> 
 <p>此时，就需要对模板进行特化。即：在原模板类的基础上，针对特殊类型所进行特殊化的实现方 式。模板特化中分为<strong><span style="color:#ff9900;">函数模板特化</span></strong>与<strong><span style="color:#ff9900;">类模板特化</span></strong>。 </p> 
</blockquote> 
<p> </p> 
<h3 style="background-color:transparent;">2.2 函数模板特化 </h3> 
<blockquote> 
 <p>函数模板的特化步骤：</p> 
 <p>1. <strong><span style="color:#fe2c24;">必须要先有一个基础的函数模板</span></strong></p> 
 <p></p> 
 <p>2. 关键字template后面接一对空的尖括号&lt;&gt;</p> 
 <p></p> 
 <p>3. 函数名后跟一对尖括号，尖括号中指定需要特化的类型</p> 
 <p></p> 
 <p>4. 函数形参表: 必须要和模板函数的基础参数类型完全相同，如果不同编译器可能会报一些奇 怪的错误。</p> 
</blockquote> 
<pre><code class="hljs">// 函数模板 -- 参数匹配
template&lt;class T&gt;
bool Less(T left, T right)
{
 return left &lt; right;
}

// 对Less函数模板进行特化
template&lt;&gt;
bool Less&lt;Date*&gt;(Date* left, Date* right)
{
 return *left &lt; *right;
}

int main()
{
 cout &lt;&lt; Less(1, 2) &lt;&lt; endl;
 Date d1(2022, 7, 7);
 Date d2(2022, 7, 8);
 cout &lt;&lt; Less(d1, d2) &lt;&lt; endl;
 Date* p1 = &amp;d1;
 Date* p2 = &amp;d2;
 cout &lt;&lt; Less(p1, p2) &lt;&lt; endl;  // 调用特化之后的版本，而不走模板生成了
 return 0;
}</code></pre> 
<blockquote> 
 <p>注意：一般情况下如果函数模板遇到不能处理或者处理有误的类型，<strong><span style="color:#fe2c24;">为了实现简单通常都是将该 函数直接给出。 </span></strong></p> 
 <pre><code class="hljs">bool Less(Date* left, Date* right)
{
 return *left &lt; *right;
}
</code></pre> 
 <p>该种实现简单明了，代码的可读性高，容易书写，因为对于一些参数类型复杂的函数模板，特化 时特别给出，<strong><span style="color:#956fe7;">因此函数模板不建议特化。！！！！！</span></strong></p> 
</blockquote> 
<p> </p> 
<h3> 2.3 类模板特化</h3> 
<h4>2.3.1 全特化</h4> 
<blockquote> 
 <p> 全特化即是将模板参数列表中所有的参数都确定化。</p> 
 <pre><code class="hljs">template&lt;class T1, class T2&gt; 
class Data
{
public:
 Data() {cout&lt;&lt;"Data&lt;T1, T2&gt;" &lt;&lt;endl;}
private:
 T1 _d1;
 T2 _d2;
};

template&lt;&gt; 
class Data&lt;int, char&gt;
{
public:
 Data() {cout&lt;&lt;"Data&lt;int, char&gt;" &lt;&lt;endl;}
private:
 int _d1;
 char _d2;
};         //全特化

void TestVector()
{
 Data&lt;int, int&gt; d1;
 Data&lt;int, char&gt; d2;   //走全特化
} 
</code></pre> 
 <p></p> 
</blockquote> 
<h4>2.3.2 偏特化 </h4> 
<blockquote> 
 <p>偏特化：任何针对模版参数进一步进行条件限制设计的特化版本。比如对于以下模板类：</p> 
 <pre><code class="hljs">template&lt;class T1, class T2&gt; 
class Data
{
public:
 Data() {cout&lt;&lt;"Data&lt;T1, T2&gt;" &lt;&lt;endl;}
private:
 T1 _d1;
 T2 _d2;
};</code></pre> 
 <p>偏特化有以下两种表现方式：</p> 
 <p>1.部分特化</p> 
 <p></p> 
 <p><strong><span style="color:#fe2c24;">将模板参数类表中的一部分参数特化</span></strong>。</p> 
 <pre><code class="hljs">// 将第二个参数特化为int
template &lt;class T1&gt; 
class Data&lt;T1, int&gt;
{
public:
    Data() {cout&lt;&lt;"Data&lt;T1, int&gt;" &lt;&lt;endl;}
private:
    T1 _d1;
    int _d2;
}; 
</code></pre> 
 <p>2.参数更进一步的限制</p> 
 <p></p> 
 <p>偏特化并不仅仅是指特化部分参数，<strong><span style="color:#fe2c24;">而是针对模板参数更进一步的条件限制所设计出来的一 个特化版本。</span></strong></p> 
 <pre><code class="hljs">//两个参数偏特化为指针类型 
template &lt;typename T1, typename T2&gt; 
class Data &lt;T1*, T2*&gt; 
{ 
public:
    Data() {cout&lt;&lt;"Data&lt;T1*, T2*&gt;" &lt;&lt;endl;}
    
private:
    T1 _d1;
    T2 _d2;
};

//两个参数偏特化为引用类型
template &lt;typename T1, typename T2&gt;
class Data &lt;T1&amp;, T2&amp;&gt;
{
public:
    Data(const T1&amp; d1, const T2&amp; d2)
   : _d1(d1)
   , _d2(d2)
   {
            cout&lt;&lt;"Data&lt;T1&amp;, T2&amp;&gt;" &lt;&lt;endl;
   }
    
private:
    const T1 &amp; _d1;
    const T2 &amp; _d2;    
 };
void test2 () 
{
     Data&lt;double , int&gt; d1;      // 调用特化的int版本
     Data&lt;int , double&gt; d2;      // 调用基础的模板    
     Data&lt;int *, int*&gt; d3;       // 调用特化的指针版本
     Data&lt;int&amp;, int&amp;&gt; d4(1, 2);  // 调用特化的指针版本
}</code></pre> 
 <p></p> 
</blockquote> 
<h4>2.3.3 类模板特化应用示例 </h4> 
<blockquote> 
 <pre><code class="hljs">#include&lt;vector&gt;
#include&lt;algorithm&gt;
template&lt;class T&gt;
struct Less
{
 bool operator()(const T&amp; x, const T&amp; y) const
 {
 return x &lt; y;
 }
};
int main()
{
 Date d1(2022, 7, 7);
 Date d2(2022, 7, 6);
 Date d3(2022, 7, 8);
 vector&lt;Date&gt; v1;
 v1.push_back(d1);
 v1.push_back(d2);
 v1.push_back(d3);
 // 可以直接排序，结果是日期升序

 sort(v1.begin(), v1.end(), Less&lt;Date&gt;());
 vector&lt;Date*&gt; v2;
 v2.push_back(&amp;d1);
 v2.push_back(&amp;d2);
 v2.push_back(&amp;d3);
 
 // 可以直接排序，结果错误日期还不是升序，而v2中放的地址是升序
 // 此处需要在排序过程中，让sort比较v2中存放地址指向的日期对象
 // 但是走Less模板，sort在排序时实际比较的是v2中指针的地址，因此无法达到预期
 sort(v2.begin(), v2.end(), Less&lt;Date*&gt;());
 return 0;
}
</code></pre> 
 <p>如果待排 序元素是指针，结果就不一定正确。因为：<strong><span style="color:#fe2c24;">sort最终按照Less模板中方式比较</span></strong>，所以<strong><span style="color:#4da8ee;">只会比较指 针</span>，<span style="color:#956fe7;">而不是比较指针指向空间中内容</span></strong>，此时可以使用类版本特化来处理上述问题：</p> 
 <pre><code class="hljs">// 对Less类模板按照指针方式特化
template&lt;&gt;
struct Less&lt;Date*&gt;
{
 bool operator()(Date* x, Date* y) const
 {
 return *x &lt; *y;
 }
};</code></pre> 
</blockquote> 
<h2>3 模板分离编译</h2> 
<p>假如有以下场景，模板的声明与定义分离开，在头文件中进行声明，源文件中完成定义：</p> 
<pre><code class="hljs">// a.h
template&lt;class T&gt;
T Add(const T&amp; left, const T&amp; right);
// a.cpp
template&lt;class T&gt;
T Add(const T&amp; left, const T&amp; right)
{
 return left + right;
}
// main.cpp
#include"a.h"
int main()
{
 Add(1, 2);
 Add(1.0, 2.0);
 
 return 0;
}</code></pre> 
<blockquote> 
 <p style="text-align:center;">分析：<img alt="" src="https://images2.imgbox.com/5b/48/JJUbT4hr_o.png"> </p> 
</blockquote> 
<blockquote> 
 <p>解决方法：</p> 
 <p><span style="color:#fe2c24;"><strong>将声明和定义放到一个文件 "xxx.hpp" 里面</strong></span>或者xxx.h其实也是可以的。 </p> 
</blockquote> 
<p> </p> 
<p> </p> 
<p></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c45cda8d30ac983ec0df51c451f1ddf9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">大数据知识总结（七）：Spark重要知识汇总</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/af44d729f0ed89314687f0e878693984/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MS SQL Server partition by 函数实战三 成绩排名</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>