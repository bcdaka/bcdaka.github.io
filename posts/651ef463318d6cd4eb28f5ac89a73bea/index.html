<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>排序算法-插入/希尔排序 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/651ef463318d6cd4eb28f5ac89a73bea/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="排序算法-插入/希尔排序">
  <meta property="og:description" content="1 插入排序 1.1基本思想： 直接插入排序是一种简单的插入排序法，其基本思想是：把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列 。 1.2直接插入排序： 当插入第i(i&gt;=1)个元素时，前面的array[0],array[1],…,array[i-1]已经排好序，此时用array[i]的排序码与 array[i-1],array[i-2],…的排序码顺序进行比较，找到插入位置即将array[i]插入，原来位置上的元素顺序后移。
直接插入排序的特性总结： 1. 元素集合越接近有序，直接插入排序算法的时间效率越高 2. 时间复杂度：O(N^2) 3. 空间复杂度：O(1)，它是一种稳定的排序算法 4. 稳定性：稳定 写排序算法的一种好习惯就是先写一个单趟排序，再使用循环来实现整体。假设实现一个升序，首先创建一个变量end=0，然后tmp保存a[end&#43;1]的值，写一个while循环，结束条件是end&lt;0，进入循环判断tmp和a[end]的大小，如果tmp小则将a[end]的值覆盖到a[end&#43;1]，然后end--，跳出循环，此时将tmp插入到a[end&#43;1]也就是a[0]这个位置。如果tmp&gt;=a[end]，直接退出循环。然后将tmp的值插入到a[end&#43;1]这个位置。然后最外层套一层循环，每次单趟结束后end&#43;&#43;。
// 插入排序 void InsertSort(int* a, int n) { for (int i = 0; i &lt; n - 1; i&#43;&#43;) { int end =i; int tmp = a[end &#43; 1]; while (end &gt;= 0) { if (tmp &lt; a[end]) { a[end &#43; 1] = a[end]; } else { break; } end--; } a[end &#43; 1] = tmp; } } 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-12-08T22:31:03+08:00">
    <meta property="article:modified_time" content="2023-12-08T22:31:03+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">排序算法-插入/希尔排序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><span style="color:#333333;"><strong>1 </strong></span><span style="color:#333333;"><strong>插入排序 </strong></span></h2> 
<h3><span style="color:#777777;"><strong>1.1</strong></span><span style="color:#777777;"><strong>基本思想： </strong></span></h3> 
<p><span style="color:#777777;">直接插入排序是一种简单的插入排序法，其基本思想是：<strong>把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列 。 </strong></span></p> 
<h3><span style="color:#777777;"><strong>1.2</strong></span><span style="color:#777777;"><strong>直接插入排序：</strong></span></h3> 
<p><span style="color:#777777;">当插入第i(i&gt;=1)</span><span style="color:#777777;">个元素时，前面的</span><span style="color:#777777;">array[0],array[1],…,array[i-1]</span><span style="color:#777777;">已经排好序，此时用</span><span style="color:#777777;">array[i]</span><span style="color:#777777;">的排序码与 array[i-1],array[i-2],…的排序码顺序进行比较，找到插入位置即将</span><span style="color:#777777;">array[i]</span><span style="color:#777777;">插入，原来位置上的元素顺序后移。</span></p> 
<div> 
 <span style="color:#777777;">直接插入排序的特性总结：</span> 
</div> 
<blockquote> 
 <div> 
  <div> 
   <span style="color:#777777;">1. </span> 
   <span style="color:#777777;">元素集合越接近有序，直接插入排序算法的时间效率越高 </span> 
  </div> 
  <div> 
   <span style="color:#777777;">2. </span> 
   <strong><span style="color:#777777;">时间复杂度：</span><span style="color:#777777;">O(N^2) </span></strong> 
  </div> 
  <div> 
   <span style="color:#777777;">3. </span> 
   <strong><span style="color:#777777;">空间复杂度：</span><span style="color:#777777;">O(1)</span><span style="color:#777777;">，它是一种稳定的排序算法 </span></strong> 
  </div> 
  <div> 
   <span style="color:#777777;">4. </span> 
   <span style="color:#777777;">稳定性：稳定 </span> 
  </div> 
 </div> 
</blockquote> 
<p> 写排序算法的一种好习惯就是先写一个单趟排序，再使用循环来实现整体。假设实现一个升序，首先创建一个变量end=0，然后tmp保存a[end+1]的值，写一个while循环，结束条件是end&lt;0，进入循环判断tmp和a[end]的大小，如果tmp小则将a[end]的值覆盖到a[end+1]，然后end--，跳出循环，此时将tmp插入到a[end+1]也就是a[0]这个位置。如果tmp&gt;=a[end]，直接退出循环。然后将tmp的值插入到a[end+1]这个位置。然后最外层套一层循环，每次单趟结束后end++。</p> 
<p><img alt="" height="455" src="https://images2.imgbox.com/e8/17/5M8eha2S_o.png" width="528"></p> 
<p></p> 
<pre><code class="language-cpp">// 插入排序
void InsertSort(int* a, int n)
{
	for (int i = 0; i &lt; n - 1; i++)
	{
		int end =i;
		int tmp = a[end + 1];
		while (end &gt;= 0)
		{
			if (tmp &lt; a[end])
			{
				a[end + 1] = a[end];
			}
			else
			{
				break;
			}
			end--;
		}
		a[end + 1] = tmp;
	}
}</code></pre> 
<hr> 
<h2><span style="color:#777777;"><strong>2.</strong></span><span style="color:#777777;"><strong>希尔排序</strong></span><span style="color:#777777;"><strong>( </strong></span><span style="color:#777777;"><strong>缩小增量排序</strong></span><span style="color:#777777;"><strong> )</strong></span></h2> 
<div> 
 <span style="color:#777777;">希尔排序法又称缩小增量法。希尔排序法的基本思想是：</span> 
 <span style="color:#777777;"><strong>先选定一个整数，把待排序文件中所有记录分成个</strong></span> 
 <span style="color:#777777;"><strong>组，所有距离为的记录分在同一组内，并对每一组内的记录进行排序。然后取重复上述分组和排序的工</strong></span> 
 <span style="color:#777777;"><strong>作。当到达</strong></span> 
 <span style="color:#777777;"><strong>=1</strong></span> 
 <span style="color:#777777;"><strong>时，所有记录在统一组内排好序</strong></span> 
 <span style="color:#777777;">。 </span> 
</div> 
<div></div> 
<div> 
 <span style="color:#777777;">假设将下列数组分为gap=3组，先完成单趟，将end=0，tmp保存a[end+gap]这个位置的值，进行比较，tmp大则将a[end]覆盖到[end+gap]这个位置，然后end-gap,退出循环，将tmp插入到a[end+gap]这个位置，也就是a[0]这个位置。然后写一个循环控制end的位置，每次end+gap。到这里就完成了黑色的这一组数据，此时可以再套一层循环控制住红色和蓝色的这两组数据。</span> 
</div> 
<div></div> 
<div> 
 <img alt="" height="663" src="https://images2.imgbox.com/4b/f1/cwUmRyBi_o.png" width="808"> 
</div> 
<div></div> 
<div> 
 <pre><code class="language-cpp">void ShellSort1(int* a, int n)
{
	int gap = n;
	while (gap &gt; 1)
	{
		gap = gap / 3 + 1;
		for (int j = 0; j &lt; gap; j++)
		{
			for (int i = j; i &lt; n - gap; i += gap)
			{
				int end = i;
				int tmp = a[end + gap];
				while (end &gt;= 0)
				{
					if (tmp &lt; a[end])
					{
						a[end + gap] = a[end];
						end -= gap;
					}
					else
					{
						break;
					}
				}
				a[end + gap] = tmp;
			}
		}
	}
}</code></pre> 
 <p>当然也可以在单趟外只套一层循环，巧妙地控制i。</p> 
 <pre><code class="language-cpp">void ShellSort2(int* a, int n)
{
	int gap = n;
	while (gap &gt; 1)
	{
		//gap = gap / 2;
		gap = gap / 3 + 1;

		for (int i = 0; i &lt; n - gap; ++i)
		{
			int end = i;
			int tmp = a[end + gap];
			while (end &gt;= 0)
			{
				if (tmp &lt; a[end])
				{
					a[end + gap] = a[end];
					end -= gap;
				}
				else
				{
					break;
				}
			}
			a[end + gap] = tmp;
		}
	}
}</code></pre> 
 <div> 
  <strong><span style="color:#777777;">希尔排序的特性总结： </span></strong> 
 </div> 
 <div></div> 
 <blockquote> 
  <div> 
   <span style="color:#777777;">1. </span> 
   <span style="color:#777777;">希尔排序是对直接插入排序的优化。 </span> 
  </div> 
  <div> 
   <span style="color:#777777;">2. </span> 
   <span style="color:#777777;">当</span> 
   <span style="color:#777777;">gap &gt; 1</span> 
   <span style="color:#777777;">时都是预排序，目的是让数组更接近于有序。当</span> 
   <span style="color:#777777;">gap == 1</span> 
   <span style="color:#777777;">时，数组已经接近有序的了，这样就 会很快。这样整体而言，可以达到优化的效果。我们实现后可以进行性能测试的对比。 </span> 
  </div> 
  <div> 
   <span style="color:#777777;">3. </span> 
   <span style="color:#777777;">希尔排序的时间复杂度不好计算，因为</span> 
   <span style="color:#777777;">gap</span> 
   <span style="color:#777777;">的取值方法很多，导致很难去计算，因此在好些树中给出的 希尔排序的时间复杂度都不固定。</span> 
  </div> 
 </blockquote> 
</div> 
<p><img alt="" height="202" src="https://images2.imgbox.com/e0/f0/J59ywh7y_o.png" width="730"><img alt="" height="245" src="https://images2.imgbox.com/0d/5d/CElNpEWb_o.png" width="764"></p> 
<p><span style="color:#777777;">4. </span><span style="color:#777777;">稳定性：<strong>不稳定 </strong></span><strong> 。</strong></p> 
<hr> 
<p><strong>今天的分享到这里就结束了，感谢大家的阅读！</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/622928fc9df6b0b6b1009613d7a910fe/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python的websocket方法教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/98789031350a4b8bfa15627098906832/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Hadoop 高可用集群完全分布式安装教程一篇就够用（zookeeper、spark、hbase、mysql、hive)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>