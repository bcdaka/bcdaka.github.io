<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;】详解priority_queue（优先级队列）与函数对象 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/65f364b3d78603e141d54356c70550e6/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;】详解priority_queue（优先级队列）与函数对象">
  <meta property="og:description" content="目录
一、priority_queue 的介绍和使用
1.1priority_queue 的介绍
2.2priority_queue 的使用
二、仿函数
2.1什么是仿函数
2.2仿函数的作用
三、函数对象的特点（知识点多）
3.1分析特点5（比较普通函数与函数对象）
3.1.1利用普通函数传递参数
拓展之：深度剖析函数利用模板的本质
3.1.2利用函数对象传递参数
3.1.3函数对象作为for_each的参数（知识点较多）
2.第三个参数传递函数：（计算从0到100）
3.第三个参数传递函数对象：（计算从0到100）
4.难点：关于第三个参数是传值的易错点
5.拓展：如果我重写for_each，加上引用，会不会得到我想要的效果？
3.2分析特点6（一共俩句话）
3.2.1分析保持函数的调用状态（本质是因为成员变量不会销毁）
3.2.2参数个数可变是什么意思？代码分析过程中居然用到了匿名对象！
1.分析函数对象的用法及匿名对象
2.探究匿名对象的生命周期
3.回忆匿名对象拆分开怎么写
4.讨论多参数问题（多参数不是重载函数多，而是类中多变量）
四、函数对象的分类
4.1一元函数
4.2二元函数
4.3一元判定函数
4.4二元判定函数 五、总结知识点（未完待续.....）
一、priority_queue 的介绍和使用 1.1priority_queue 的介绍 priority_queue （优先级队列）是一种容器适配器，它与 queue 共用一个头文件，其底层结构是一个堆，并且默认情况下是一个大根堆，所以它的第一个元素总是它所包含的元素中最大的，并且为了不破坏堆结构，它也不支持迭代器。
同时，由于堆需要进行下标计算，所以 priority_queue 使用 vector 作为它的默认适配容器 (支持随机访问)：
但是，priority_queue 比 queue 和 stack 多了一个模板参数 – 仿函数；关于仿函数的具体细节，我们将在后文介绍
class Compare = less&lt;typename Container::value_type&gt; 2.2priority_queue 的使用 优先级队列默认使用 vector 作为其底层存储数据的容器，在 vector 上又使用了堆算法将 vector 中元素构造成堆的结构，因此 priority_queue 就是堆，所有需要用到堆的位置，都可以考虑使用 priority_queue。(注意：默认情况下priority_queue是大堆)">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-11-01T11:47:55+08:00">
    <meta property="article:modified_time" content="2023-11-01T11:47:55+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】详解priority_queue（优先级队列）与函数对象</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" src="https://images2.imgbox.com/d1/95/POHefZOT_o.gif"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81priority_queue%20%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81priority_queue%20%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8" rel="nofollow">一、priority_queue 的介绍和使用</a></p> 
<p id="1.1priority_queue%20%E7%9A%84%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#1.1priority_queue%20%E7%9A%84%E4%BB%8B%E7%BB%8D" rel="nofollow">1.1priority_queue 的介绍</a></p> 
<p id="2.2priority_queue%20%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#2.2priority_queue%20%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">2.2priority_queue 的使用</a></p> 
<p id="%E4%BA%8C%E3%80%81%E4%BB%BF%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E4%BB%BF%E5%87%BD%E6%95%B0" rel="nofollow">二、仿函数</a></p> 
<p id="2.1%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%BF%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#2.1%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%BF%E5%87%BD%E6%95%B0" rel="nofollow">2.1什么是仿函数</a></p> 
<p id="2.2%E4%BB%BF%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8-toc" style="margin-left:40px;"><a href="#2.2%E4%BB%BF%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8" rel="nofollow">2.2仿函数的作用</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%88%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%9A%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%88%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%9A%EF%BC%89" rel="nofollow">三、函数对象的特点（知识点多）</a></p> 
<p id="3.1%E5%88%86%E6%9E%90%E7%89%B9%E7%82%B95%EF%BC%88%E6%AF%94%E8%BE%83%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%EF%BC%89-toc" style="margin-left:40px;"><a href="#3.1%E5%88%86%E6%9E%90%E7%89%B9%E7%82%B95%EF%BC%88%E6%AF%94%E8%BE%83%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%EF%BC%89" rel="nofollow">3.1分析特点5（比较普通函数与函数对象）</a></p> 
<p id="3.1.1%E5%88%A9%E7%94%A8%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0-toc" style="margin-left:80px;"><a href="#3.1.1%E5%88%A9%E7%94%A8%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0" rel="nofollow">3.1.1利用普通函数传递参数</a></p> 
<p id="%E6%8B%93%E5%B1%95%E4%B9%8B%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%9C%AC%E8%B4%A8-toc" style="margin-left:120px;"><a href="#%E6%8B%93%E5%B1%95%E4%B9%8B%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%9C%AC%E8%B4%A8" rel="nofollow">拓展之：深度剖析函数利用模板的本质</a></p> 
<p id="3.1.2%E5%88%A9%E7%94%A8%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0-toc" style="margin-left:80px;"><a href="#3.1.2%E5%88%A9%E7%94%A8%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0" rel="nofollow">3.1.2利用函数对象传递参数</a></p> 
<p id="3.1.3%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BAfor_each%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%88%E7%9F%A5%E8%AF%86%E7%82%B9%E8%BE%83%E5%A4%9A%EF%BC%89-toc" style="margin-left:80px;"><a href="#3.1.3%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BAfor_each%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%88%E7%9F%A5%E8%AF%86%E7%82%B9%E8%BE%83%E5%A4%9A%EF%BC%89" rel="nofollow">3.1.3函数对象作为for_each的参数（知识点较多）</a></p> 
<p id="2.%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%EF%BC%9A%EF%BC%88%E8%AE%A1%E7%AE%97%E4%BB%8E0%E5%88%B0100%EF%BC%89-toc" style="margin-left:120px;"><a href="#2.%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%EF%BC%9A%EF%BC%88%E8%AE%A1%E7%AE%97%E4%BB%8E0%E5%88%B0100%EF%BC%89" rel="nofollow">2.第三个参数传递函数：（计算从0到100）</a></p> 
<p id="3.%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%EF%BC%9A%EF%BC%88%E8%AE%A1%E7%AE%97%E4%BB%8E0%E5%88%B0100%EF%BC%89-toc" style="margin-left:120px;"><a href="#3.%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%EF%BC%9A%EF%BC%88%E8%AE%A1%E7%AE%97%E4%BB%8E0%E5%88%B0100%EF%BC%89" rel="nofollow">3.第三个参数传递函数对象：（计算从0到100）</a></p> 
<p id="4.%E9%9A%BE%E7%82%B9%EF%BC%9A%E5%85%B3%E4%BA%8E%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0%E6%98%AF%E4%BC%A0%E5%80%BC%E7%9A%84%E6%98%93%E9%94%99%E7%82%B9-toc" style="margin-left:120px;"><a href="#4.%E9%9A%BE%E7%82%B9%EF%BC%9A%E5%85%B3%E4%BA%8E%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0%E6%98%AF%E4%BC%A0%E5%80%BC%E7%9A%84%E6%98%93%E9%94%99%E7%82%B9" rel="nofollow">4.难点：关于第三个参数是传值的易错点</a></p> 
<p id="5.%E6%8B%93%E5%B1%95%EF%BC%9A%E5%A6%82%E6%9E%9C%E6%88%91%E9%87%8D%E5%86%99for_each%EF%BC%8C%E5%8A%A0%E4%B8%8A%E5%BC%95%E7%94%A8%EF%BC%8C%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%BE%97%E5%88%B0%E6%88%91%E6%83%B3%E8%A6%81%E7%9A%84%E6%95%88%E6%9E%9C%EF%BC%9F-toc" style="margin-left:120px;"><a href="#5.%E6%8B%93%E5%B1%95%EF%BC%9A%E5%A6%82%E6%9E%9C%E6%88%91%E9%87%8D%E5%86%99for_each%EF%BC%8C%E5%8A%A0%E4%B8%8A%E5%BC%95%E7%94%A8%EF%BC%8C%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%BE%97%E5%88%B0%E6%88%91%E6%83%B3%E8%A6%81%E7%9A%84%E6%95%88%E6%9E%9C%EF%BC%9F" rel="nofollow">5.拓展：如果我重写for_each，加上引用，会不会得到我想要的效果？</a></p> 
<p id="3.2%E5%88%86%E6%9E%90%E7%89%B9%E7%82%B96%EF%BC%88%E4%B8%80%E5%85%B1%E4%BF%A9%E5%8F%A5%E8%AF%9D%EF%BC%89-toc" style="margin-left:40px;"><a href="#3.2%E5%88%86%E6%9E%90%E7%89%B9%E7%82%B96%EF%BC%88%E4%B8%80%E5%85%B1%E4%BF%A9%E5%8F%A5%E8%AF%9D%EF%BC%89" rel="nofollow">3.2分析特点6（一共俩句话）</a></p> 
<p id="3.2.1%E5%88%86%E6%9E%90%E4%BF%9D%E6%8C%81%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E7%8A%B6%E6%80%81%EF%BC%88%E6%9C%AC%E8%B4%A8%E6%98%AF%E5%9B%A0%E4%B8%BA%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8D%E4%BC%9A%E9%94%80%E6%AF%81%EF%BC%89-toc" style="margin-left:80px;"><a href="#3.2.1%E5%88%86%E6%9E%90%E4%BF%9D%E6%8C%81%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E7%8A%B6%E6%80%81%EF%BC%88%E6%9C%AC%E8%B4%A8%E6%98%AF%E5%9B%A0%E4%B8%BA%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8D%E4%BC%9A%E9%94%80%E6%AF%81%EF%BC%89" rel="nofollow">3.2.1分析保持函数的调用状态（本质是因为成员变量不会销毁）</a></p> 
<p id="3.2.2%E5%8F%82%E6%95%B0%E4%B8%AA%E6%95%B0%E5%8F%AF%E5%8F%98%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%B1%85%E7%84%B6%E7%94%A8%E5%88%B0%E4%BA%86%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%EF%BC%81-toc" style="margin-left:80px;"><a href="#3.2.2%E5%8F%82%E6%95%B0%E4%B8%AA%E6%95%B0%E5%8F%AF%E5%8F%98%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%B1%85%E7%84%B6%E7%94%A8%E5%88%B0%E4%BA%86%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%EF%BC%81" rel="nofollow">3.2.2参数个数可变是什么意思？代码分析过程中居然用到了匿名对象！</a></p> 
<p id="1.%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1-toc" style="margin-left:120px;"><a href="#1.%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1" rel="nofollow">1.分析函数对象的用法及匿名对象</a></p> 
<p id="2.%E6%8E%A2%E7%A9%B6%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-toc" style="margin-left:120px;"><a href="#2.%E6%8E%A2%E7%A9%B6%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" rel="nofollow">2.探究匿名对象的生命周期</a></p> 
<p id="3.%E5%9B%9E%E5%BF%86%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E6%8B%86%E5%88%86%E5%BC%80%E6%80%8E%E4%B9%88%E5%86%99-toc" style="margin-left:120px;"><a href="#3.%E5%9B%9E%E5%BF%86%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E6%8B%86%E5%88%86%E5%BC%80%E6%80%8E%E4%B9%88%E5%86%99" rel="nofollow">3.回忆匿名对象拆分开怎么写</a></p> 
<p id="4.%E8%AE%A8%E8%AE%BA%E5%A4%9A%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98%EF%BC%88%E5%A4%9A%E5%8F%82%E6%95%B0%E4%B8%8D%E6%98%AF%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E5%A4%9A%EF%BC%8C%E8%80%8C%E6%98%AF%E7%B1%BB%E4%B8%AD%E5%A4%9A%E5%8F%98%E9%87%8F%EF%BC%89-toc" style="margin-left:120px;"><a href="#4.%E8%AE%A8%E8%AE%BA%E5%A4%9A%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98%EF%BC%88%E5%A4%9A%E5%8F%82%E6%95%B0%E4%B8%8D%E6%98%AF%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E5%A4%9A%EF%BC%8C%E8%80%8C%E6%98%AF%E7%B1%BB%E4%B8%AD%E5%A4%9A%E5%8F%98%E9%87%8F%EF%BC%89" rel="nofollow">4.讨论多参数问题（多参数不是重载函数多，而是类中多变量）</a></p> 
<p id="%E5%9B%9B%E3%80%81%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E7%B1%BB-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E7%B1%BB" rel="nofollow">四、函数对象的分类</a></p> 
<p id="4.1%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#4.1%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0" rel="nofollow">4.1一元函数</a></p> 
<p id="4.2%E4%BA%8C%E5%85%83%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#4.2%E4%BA%8C%E5%85%83%E5%87%BD%E6%95%B0" rel="nofollow">4.2二元函数</a></p> 
<p id="4.3%E4%B8%80%E5%85%83%E5%88%A4%E5%AE%9A%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#4.3%E4%B8%80%E5%85%83%E5%88%A4%E5%AE%9A%E5%87%BD%E6%95%B0" rel="nofollow">4.3一元判定函数</a></p> 
<p id="4.4%E4%BA%8C%E5%85%83%E5%88%A4%E5%AE%9A%E5%87%BD%E6%95%B0%C2%A0-toc" style="margin-left:40px;"><a href="#4.4%E4%BA%8C%E5%85%83%E5%88%A4%E5%AE%9A%E5%87%BD%E6%95%B0%C2%A0" rel="nofollow">4.4二元判定函数 </a></p> 
<p id="%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD.....%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD.....%EF%BC%89" rel="nofollow">五、总结知识点（未完待续.....）</a></p> 
<h2 id="%E4%B8%80%E3%80%81priority_queue%20%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8">一、priority_queue 的介绍和使用</h2> 
<h3 id="1.1priority_queue%20%E7%9A%84%E4%BB%8B%E7%BB%8D">1.1priority_queue 的介绍</h3> 
<p>priority_queue （优先级队列）是一种容器适配器，它与 queue 共用一个头文件，其<strong><span style="color:#fe2c24;"><span style="background-color:#fefcd8;">底层结构是一个堆</span></span></strong>，并且默认情况下是一个大根堆，所以它的第一个元素总是它所包含的元素中最大的，并且为了不破坏堆结构，它也不支持迭代器。</p> 
<p>同时，由于堆需要进行下标计算，所以 priority_queue <strong><span style="background-color:#fefcd8;">使用 vector 作为它的默认适配容器</span></strong> (支持随机访问)：</p> 
<p class="img-center"><img alt="" height="202" src="https://images2.imgbox.com/04/ed/Edqz8r1c_o.png" width="1169"></p> 
<p> 但是，priority_queue 比 queue 和 stack 多了一个模板参数 – 仿函数；关于仿函数的具体细节，我们将在后文介绍</p> 
<pre><code class="language-cpp">class Compare = less&lt;typename Container::value_type&gt;
</code></pre> 
<h3 id="2.2priority_queue%20%E7%9A%84%E4%BD%BF%E7%94%A8">2.2priority_queue 的使用</h3> 
<p>优先级队列默认使用 vector 作为其底层存储数据的容器，在 vector 上又使用了堆算法将 vector 中元素构造成堆的结构，因此 priority_queue 就是堆，所有需要用到堆的位置，都可以考虑使用 priority_queue。(注意：默认情况下priority_queue是大堆)</p> 
<p><a href="https://legacy.cplusplus.com/reference/queue/priority_queue/" rel="nofollow" title="priority_queue 的使用文档">priority_queue 的使用文档</a></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="text-align:center;"><strong>函数声明</strong></td><td style="text-align:center;"><strong>接口说明</strong></td></tr><tr><td style="text-align:center;">priority_queue()</td><td style="text-align:center;">构造一个空的优先级队列</td></tr><tr><td style="text-align:center;">priority_queue(first, last)</td><td style="text-align:center;">迭代器区间构造优先级队列</td></tr><tr><td style="text-align:center;">empty( )</td><td style="text-align:center;">检测优先级队列是否为空</td></tr><tr><td style="text-align:center;">top( )</td><td style="text-align:center;">返回优先级队列中最大(最小元素)，即堆顶元素</td></tr><tr><td style="text-align:center;">push(x)</td><td style="text-align:center;">在优先级队列中插入元素x</td></tr><tr><td style="text-align:center;">pop()</td><td style="text-align:center;">删除优先级队列中最大(最小)元素，即堆顶元素</td></tr><tr><td style="text-align:center;">size()</td><td style="text-align:center;">返回优先级队列中的元素个数</td></tr></tbody></table> 
<p><strong>注意事项：</strong></p> 
<p><img alt="" height="229" src="https://images2.imgbox.com/bb/60/fZg3QdL5_o.png" width="876"></p> 
<p><strong>priority_queue 默认使用的仿函数是 less，所以默认建成的堆是大堆</strong>；如果我们想要建小堆，则需要指定仿函数为 greater，该仿函数包含在头文件 functional 中，并且由于仿函数是第三个缺省模板参数，所以如果要传递它必须先传递第二个模板参数即适配容器</p> 
<p class="img-center"><img alt="" height="190" src="https://images2.imgbox.com/49/8a/lt3QmrMY_o.png" width="1163"></p> 
<p class="img-center"><img alt="" height="195" src="https://images2.imgbox.com/c2/14/X87L5ONl_o.png" width="1169"></p> 
<pre><code class="language-cpp">void test_priority_queue() {
	priority_queue&lt;int&gt; pq;  //默认建大堆，仿函数为less
	pq.push(5);
	pq.push(2);
	pq.push(4);
	pq.push(1);
	pq.push(3);
	while (!pq.empty()) {
		cout &lt;&lt; pq.top() &lt;&lt; " ";
		pq.pop();
	}
	cout &lt;&lt; endl;

	priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq1;  //建小堆，仿函数为greater，需要显式指定
	pq1.push(5);
	pq1.push(2);
	pq1.push(4);
	pq1.push(1);
	pq1.push(3);
	while (!pq1.empty()) {
		cout &lt;&lt; pq1.top() &lt;&lt; " ";
		pq1.pop();
	}
	cout &lt;&lt; endl;
}</code></pre> 
<p class="img-center"><img alt="" height="459" src="https://images2.imgbox.com/0b/51/BFC4CHoz_o.png" width="1000"></p> 
<hr> 
<h2 id="%E4%BA%8C%E3%80%81%E4%BB%BF%E5%87%BD%E6%95%B0">二、仿函数</h2> 
<h3 id="2.1%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%BF%E5%87%BD%E6%95%B0">2.1什么是仿函数</h3> 
<p>仿函数也叫函数对象，<strong>仿函数是一个类，但是<span style="background-color:#fefcd8;">该类必须重载函数调用运算符 ( )</span></strong>，即 operator()(参数)；由于这样的类的对象可以像函数一样去使用，所以我们将其称为仿函数/函数对象，如下：</p> 
<pre><code class="language-cpp">namespace lzy {
	 class less {
    public:
		bool operator()(const int&amp; x, const int&amp; y) const 
    {
      cout &lt;&lt; "less类" &lt;&lt; endl;
			return x &lt; y;
		}
	};
	class greater 
  {
    public:
		bool operator()(const int&amp; x, const int&amp; y) 
    {
      cout &lt;&lt; "greater类" &lt;&lt; endl;
			return x &gt; y;
		}
	};
}
void functor_test() {
	lzy::less lessFunc;
	cout &lt;&lt; lessFunc(1, 2) &lt;&lt; endl;  //lessFunc.operator(1,2)

	lzy::greater greaterFunc;
	cout &lt;&lt; greaterFunc(1, 2) &lt;&lt; endl;  //greaterFunc.operator(1,2)
}</code></pre> 
<p class="img-center"><img alt="" height="361" src="https://images2.imgbox.com/7e/df/wDZMtUh7_o.png" width="940"></p> 
<p>可以看到，因为 less 类和 greater 类重载了 () 操作符，所以类对象可以像函数一样去使用，因此它们被称为仿函数。</p> 
<h3 id="2.2%E4%BB%BF%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8">2.2仿函数的作用</h3> 
<p>我们以最简单的冒泡排序为例来说明仿函数的作用，我们知道，排序分为排升序和排降序，那么在没有仿函数的时候，即C语言阶段，我们是如何来解决这个问题的呢 – 答案是<strong><span style="color:#fe2c24;"><span style="background-color:#fefcd8;">函数指针</span></span></strong>；</p> 
<p>将排序函数的最后一个参数定义为函数指针，然后通过用户给排序函数传递不同的比较函数来决定升序还是降序：</p> 
<p class="img-center"><img alt="" height="525" src="https://images2.imgbox.com/c3/29/6ot0jqKw_o.png" width="975"></p> 
<p>  </p> 
<p><span style="color:#fe2c24;"><strong>但是！！</strong></span>在 C++ 中，我们不再使用函数指针解决升序降序的问题，转而使用更加方便的仿函数</p> 
<p class="img-center"><img alt="" height="555" src="https://images2.imgbox.com/bd/45/vX0rY72c_o.png" width="1067"></p> 
<hr> 
<h2 id="%E4%B8%89%E3%80%81%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%88%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%9A%EF%BC%89"><strong>三、函数对象的特点（知识点多）</strong></h2> 
<blockquote> 
 <ul><li>函数对象是一个类的对象，而不是函数</li></ul> 
 <p></p> 
 <ul><li>函数对象是重载了operator（）的类对象</li></ul> 
 <p></p> 
 <ul><li>函数对象的调用格式类似于函数调用，所以也称仿函数</li></ul> 
 <p></p> 
 <ul><li>函数对象也具有参数和返回值</li></ul> 
 <p></p> 
 <ul><li>函数对象作为一个对象，可以作为参数传递给函数或其它类函数对象独有的特点</li></ul> 
 <p></p> 
 <ul><li><span style="background-color:#fefcd8;">保持函数的调用状态，参数个数可变</span>（因为函数在栈中，之后会销毁）</li></ul> 
</blockquote> 
<h3 id="3.1%E5%88%86%E6%9E%90%E7%89%B9%E7%82%B95%EF%BC%88%E6%AF%94%E8%BE%83%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%EF%BC%89">3.1分析特点5（比较普通函数与函数对象）</h3> 
<h4 id="3.1.1%E5%88%A9%E7%94%A8%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0">3.1.1利用普通函数传递参数</h4> 
<p>代码作用：<strong>给定成绩数组，找出大于或者小于基准值的成绩分数</strong></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int baseScore = 0;
int arrSize = 5;

typedef bool (*pf) (int,int); //函数指针，是为了代码将来的可维护性 不需要修改count函数内部
int count(int grade[],pf p)//传递int int形的接口
  {
    int sum=0;
    for(int i=0;i&lt;arrSize;++i)
    {
      if(p(baseScore,grade[i]))//难点
      {
        ++sum;
      }
    }
    return sum;
  }
 bool Cmp_big(int base,int num)// 比较函数
  {
    return num&gt;=base;// 也可以返回整数值，设置各种比较情况
  }
  bool Cmp_small(int base,int num)// 修改比较函数
  {
    return num&lt;=base;// 也可以返回整数值，设置各种比较情况
  }
int main()
{
  int grade[arrSize]={1,2,3,4,5};
  cout &lt;&lt; count(grade,Cmp_big) &lt;&lt; endl;
  return 0;
}
</code></pre> 
<p>这里利用到了函数指针的知识点，但在这里我不想过多探讨，所以看注释就好啦</p> 
<p class="img-center"><img alt="" height="150" src="https://images2.imgbox.com/9f/c9/8nUeaybo_o.png" width="437"></p> 
<p>这里通过传递不同的函数比较方法，可以有不同的效果，p是一个函数指针，而函数名正好也是函数指针，所以这里重点正是cmp_big给了p，使得p变成了大于基准值比较函数（sort的第三个参数，实则正可以理解为函数指针（C语言中），在C++的话一定就是模板了）</p> 
<h5 id="%E6%8B%93%E5%B1%95%E4%B9%8B%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%9C%AC%E8%B4%A8">拓展之：深度剖析函数利用模板的本质</h5> 
<p>但是在看了sort函数的底层时，我发现大部分还是用模板（谁还用函数指针啊真是）（但是C没模板，那么C一定就得用函数指针当sort函数的第三个参数了）</p> 
<p class="img-center"><img alt="" height="460" src="https://images2.imgbox.com/58/bb/KbZOWE1U_o.png" width="885"></p> 
<p>这样用着蛮不错的哦，但是如果我们的函数要实例化的话，你就会惊奇的发现：</p> 
<p class="img-center"><img alt="" height="114" src="https://images2.imgbox.com/25/a8/VQL8r5DZ_o.png" width="500"></p> 
<p class="img-center"><img alt="" height="116" src="https://images2.imgbox.com/71/cf/usQPDtXV_o.png" width="796"></p> 
<p> 这个东西长得不就是我们的函数指针吗？这也充分验证了我们函数名就是函数指针的观点！</p> 
<p>模板的好处正是用起来爽，但其实并没有提高效率</p> 
<h4 id="3.1.2%E5%88%A9%E7%94%A8%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0">3.1.2利用函数对象传递参数</h4> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int baseScore = 0;
int arrSize = 5;
  //方法二 利用函数对象
  class cmp_obj
  {
    public:
    int base;
    bool operator()(int score) const
    {
      return (score&gt;=base);
    }
  };
  int count(int grade[],cmp_obj cmp)//grade[i],cmp1 cmp1(grade[i]) cmp1.oprara(grade[i]);
  {
    int sum=0;
    for(int i=0;i&lt;arrSize;++i)
    {
      if(cmp(grade[i])) //cmp.operator(grade[i]);
      {
        ++sum;
      }
    }
    return sum;
  }

int main()
{
  int grade[arrSize]={1,2,3,4,5};
  cmp_obj cmp1;
  cmp1.base=2;
  cout &lt;&lt; count(grade,cmp1) &lt;&lt; endl;

  cmp1.base=4;//修改基准值 
  cout &lt;&lt; count(grade,cmp1) &lt;&lt; endl;

  return 0;
}
</code></pre> 
<p><strong>分析代码：</strong></p> 
<p class="img-center"><img alt="" height="147" src="https://images2.imgbox.com/f9/8d/aQllBXkm_o.png" width="555"></p> 
<p>这里没有比较函数，有的只是对象和重载operator( )，所以要修改比较规则，那么重载里面修改就好了</p> 
<p></p> 
<p> 这正是函数对象作为一个对象，<span style="color:#fe2c24;"><span style="background-color:#fefcd8;">可以作为参数传递给函数或其它类函数对象独有的特点</span></span></p> 
<p class="img-center"><img alt="" height="406" src="https://images2.imgbox.com/a8/50/W9OmXRD8_o.png" width="694"></p> 
<p></p> 
<p class="img-center"><img alt="" height="212" src="https://images2.imgbox.com/60/20/9S6OeL1n_o.png" width="520"></p> 
<p>利用函数的话，修改基准值得用全局变量，但是利用函数对象的话就不需要，这都是优势！ </p> 
<p></p> 
<h4 id="3.1.3%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BAfor_each%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%88%E7%9F%A5%E8%AF%86%E7%82%B9%E8%BE%83%E5%A4%9A%EF%BC%89">3.1.3函数对象作为for_each的参数（知识点较多）</h4> 
<p><strong>1.for_each函数：</strong></p> 
<pre><code class="language-cpp">template&lt;class InputIterator, class Function&gt;
  Function for_each(InputIterator first, InputIterator last, Function fn) 
  //第三个参数是函数或者是函数对象
{
  while (first!=last) {
    fn (*first);//取值 传递到fn函数/函数对象
    ++first;
  }
  return fn;      //如果是函数对象 返回是有意义的 如果是函数  反而是没有意义的
}</code></pre> 
<p class="img-center"><img alt="" height="346" src="https://images2.imgbox.com/15/a3/9nSQy9RC_o.png" width="1044"></p> 
<blockquote> 
 <p>这里重点知识点就是：for_each的<span style="background-color:#fefcd8;">第三个参数可以传递函数对象/函数</span></p> 
 <p></p> 
 <p><span style="color:#fe2c24;">传递函数时：<strong>往往不需要接收返回值</strong></span>，因为接收函数没有意义</p> 
 <p></p> 
 <p><span style="color:#fe2c24;">传递函数对象：<strong><span style="background-color:#fefcd8;">一定得接收返回值</span></strong></span>，因为不接受的话因为是传值，就会丢失想要的值</p> 
</blockquote> 
<h5 id="2.%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%EF%BC%9A%EF%BC%88%E8%AE%A1%E7%AE%97%E4%BB%8E0%E5%88%B0100%EF%BC%89"><strong>2.第三个参数传递函数：（计算从0到100）</strong></h5> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;

int sum=0;
void f(int x)
{
  sum+=x;//这里是f函数 
}
int main()
{
  vector&lt;int&gt; v;
  for(int i=0;i&lt;100;i++)
  {
    v.push_back(i);
  }
  //不需要接收返回值 接收函数没有意义
  for_each(v.begin(),v.end(),f);//在迭代器的范围内，每次取一个x元素，计算f(x)
  
//   for(int i=0;i&lt;v.size();++i)
//   {
//     f(v[i]);
//   }
  cout&lt;&lt; sum; 
}
</code></pre> 
<p class="img-center"><img alt="" height="460" src="https://images2.imgbox.com/0f/dd/0bBvy32H_o.png" width="1052"></p> 
<p></p> 
<p>如果我们将for_each拆分开来：</p> 
<pre><code class="language-cpp">for(int i=0;i&lt;v.size();++i)
  {
    f(v[i]);
  }</code></pre> 
<p class="img-center"><img alt="" height="156" src="https://images2.imgbox.com/1d/3c/n3v46TUt_o.png" width="611"></p> 
<p> 很明显，用for_each是更爽的！ 只可惜有一定的使用难度成本，让我们继续往下看！</p> 
<h5 id="3.%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%EF%BC%9A%EF%BC%88%E8%AE%A1%E7%AE%97%E4%BB%8E0%E5%88%B0100%EF%BC%89"><strong>3.第三个参数传递函数对象：（计算从0到100）</strong></h5> 
<pre><code class="language-cpp">//print为仿函数
class print
{
    int count;
    public:
    int get_count()
    {
        return count;
    }
    print() {count = 0;} //必须写默认构造 要不然下面匿名对象会出问题
    void operator()(int x)
    {
        cout &lt;&lt; x &lt;&lt; " ";
        ++count;
    }
};</code></pre> 
<p>在这里仿函数类中，我们用get_count函数接收私有变量，并且写好了默认构造函数，接着重载了operator( ) ，因为这个我们是用来输出的，所以返回值写成void就好了</p> 
<pre><code class="language-cpp">int main()
{
    list&lt;int&gt; l;//初始化
    for (size_t i= 1;i&lt;10;++i)
    {
        l.push_back(i);
    }
    //遍历ilist元素并打印
    print p = for_each(l.begin(),l.end(),print());//打印l元素个数 这里的第三个参数好好分析一下
    cout &lt;&lt;"count="&lt;&lt;p.get_count() &lt;&lt; endl;
    return 0;
}</code></pre> 
<p>这里我们先对list进行了初始化，接着难点来了：</p> 
<p class="img-center"><img alt="" height="121" src="https://images2.imgbox.com/2f/07/LbCmOkRY_o.png" width="1200"></p> 
<p><span style="color:#fe2c24;"><strong><span style="background-color:#fefcd8;"> 利用构造函数创建匿名对象与对象调用重载（）函数是很容易混淆的！！！</span></strong></span></p> 
<p> 接着由于<strong><span style="background-color:#fefcd8;">返回值是函数对象</span></strong>，所以可以利用p来验证最后的结果~</p> 
<h4></h4> 
<h5 id="4.%E9%9A%BE%E7%82%B9%EF%BC%9A%E5%85%B3%E4%BA%8E%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0%E6%98%AF%E4%BC%A0%E5%80%BC%E7%9A%84%E6%98%93%E9%94%99%E7%82%B9">4.难点：关于第三个参数是传值的易错点</h5> 
<p class="img-center"><img alt="" height="192" src="https://images2.imgbox.com/81/0b/sNmHg4rz_o.png" width="1070"></p> 
<p>但是如果我不接受返回值，直接输出p1.get_count( ) ，你会不会汗流浃背呢？</p> 
<p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/a4/4e/Kjoww3hC_o.png" width="1090"></p> 
<p> 这就说明，我们这里进去的值出来后就被销毁了，为了避免销毁，得加上返回值哦！</p> 
<p></p> 
<h5 id="5.%E6%8B%93%E5%B1%95%EF%BC%9A%E5%A6%82%E6%9E%9C%E6%88%91%E9%87%8D%E5%86%99for_each%EF%BC%8C%E5%8A%A0%E4%B8%8A%E5%BC%95%E7%94%A8%EF%BC%8C%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%BE%97%E5%88%B0%E6%88%91%E6%83%B3%E8%A6%81%E7%9A%84%E6%95%88%E6%9E%9C%EF%BC%9F">5.拓展：如果我重写for_each，加上引用，会不会得到我想要的效果？</h5> 
<p class="img-center"><img alt="" height="309" src="https://images2.imgbox.com/77/2b/i1W40HUa_o.png" width="1029"></p> 
<pre><code class="language-cpp">Function&amp; for_each(InputIterator first, InputIterator last, Function&amp; fn) 
{
  while (first != last) {
    fn(*first);  // 取值并传递到fn函数/函数对象
    ++first;
  }
  return fn;
}</code></pre> 
<p>注意：类对象引用初始化的时候，一定得加上引用的是谁，类类型也是可以用引用的 </p> 
<p class="img-center"><img alt="" height="214" src="https://images2.imgbox.com/1c/64/UTMtvYNY_o.png" width="1164"></p> 
<hr> 
<h3 id="3.2%E5%88%86%E6%9E%90%E7%89%B9%E7%82%B96%EF%BC%88%E4%B8%80%E5%85%B1%E4%BF%A9%E5%8F%A5%E8%AF%9D%EF%BC%89">3.2分析特点6（一共俩句话）</h3> 
<h4 id="3.2.1%E5%88%86%E6%9E%90%E4%BF%9D%E6%8C%81%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E7%8A%B6%E6%80%81%EF%BC%88%E6%9C%AC%E8%B4%A8%E6%98%AF%E5%9B%A0%E4%B8%BA%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8D%E4%BC%9A%E9%94%80%E6%AF%81%EF%BC%89">3.2.1分析保持函数的调用状态（本质是因为成员变量不会销毁）</h4> 
<p>保留函数的调用状态是什么意思呢？ 我们看一段代码！</p> 
<pre><code class="language-cpp">int sum = 0;
void f(int x)
{
  sum += x;
}
class add
{
  int comm;
public:
  int Getsum() { return comm; }
  add() { comm = 0 ;}
  void operator()(int x)
  {
    comm += x;
  }
};
int main()
{
  int i = 0;
  for ( i = 1; i &lt;= 100; i++)
  f(i);
  cout &lt;&lt; sum &lt;&lt; endl; //5050
  add fobi;
  for (i = 1;i &lt;= 100;i++)
  fobi(i); //调用格式类似于函数
  cout &lt;&lt; fobi.Getsum ()&lt;&lt; endl; //5050，保留函数状态
  return 0;
}</code></pre> 
<p class="img-center"><img alt="" height="562" src="https://images2.imgbox.com/06/78/lLwEs4cY_o.png" width="516"></p> 
<p>这段代码的知识点很多咧~ 让小羊博主一起带你们分析一波！</p> 
<p>直观上来说，一个是普通函数，一个是重载（），那么<span style="background-color:#fefcd8;">保留函数的调用状态是什么意思？</span></p> 
<blockquote> 
 <p>1.<span style="color:#fe2c24;"><strong><span style="background-color:#fefcd8;">本质上是因为类中的成员变量不会被销毁，但是函数中的sum与x出了作用域就会清空</span></strong></span></p> 
 <p></p> 
 <p>2.在这俩个函数都是void的情况，为了输出最终结果，俩方势力也是煞费脑筋：</p> 
 <p></p> 
 <p></p> 
 <p>函数势力是<span style="background-color:#fefcd8;">利用了全局变量 int sum=0; </span>才使得得到想要结果（可惜这样是不安全的）</p> 
 <p class="img-center"><img alt="" height="41" src="https://images2.imgbox.com/ca/d6/oh0dz7Nc_o.png" width="211"></p> 
 <p></p> 
 <p>而重载势力是<span style="background-color:#fefcd8;">利用了共有函数接口取回最终的结果值</span></p> 
 <p class="img-center"><img alt="" height="206" src="https://images2.imgbox.com/7c/bb/KOy6AAcL_o.png" width="432"></p> 
</blockquote> 
<p class="img-center"><img alt="" height="149" src="https://images2.imgbox.com/e3/63/nUuqnX86_o.png" width="394"></p> 
<p> 而且看到这个写法会不会觉得很奇怪咧，有俩个括号，意思是第一个是缺省参数吗？</p> 
<p>不不不不，这里是重载（）函数，所以长得有些奇怪，只有第二个int x才是参数~</p> 
<hr> 
<h4 id="3.2.2%E5%8F%82%E6%95%B0%E4%B8%AA%E6%95%B0%E5%8F%AF%E5%8F%98%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%B1%85%E7%84%B6%E7%94%A8%E5%88%B0%E4%BA%86%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%EF%BC%81">3.2.2参数个数可变是什么意思？代码分析过程中居然用到了匿名对象！</h4> 
<h5 id="1.%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1">1.分析函数对象的用法及匿名对象</h5> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
class add_two
{
  int comm;
  //int hehe;
  public:
  int Getsum() { return comm; } 
  add_two()
  { comm = 0;}
  add_two(int v) { comm = v;}
  int operator()(int x) //不是说这个是特殊语法 是因为operator*(int x) 等等重载函数都是这么写的
  {
    return (comm + x );
  }

};
void test1()
{
int ret = add_two()(2); //利用匿名对象
cout &lt;&lt; ret &lt;&lt; endl;// ret=2;

ret = add_two(5)(2);//ret=7;
cout &lt;&lt; ret &lt;&lt; endl;

ret = add_two(6)(2);//ret=8;
cout &lt;&lt; ret &lt;&lt; endl; 

}
int main()
{
  test1();
  return 0;
}</code></pre> 
<p><strong>代码分析：</strong></p> 
<p>还是老样子，在类中依然重载了operator( ) , 所以让我们看看主函数是怎么调用的吧</p> 
<p>类中有俩个构造函数，一个是有参，一个是无参（并且给了默认值是0）</p> 
<p>（吐槽：直接给缺省不就行了，还写俩个构造函数）</p> 
<p></p> 
<p><strong>add_two()：虽然是俩个括号 但是第一个是构造函数 然后用了匿名对象的知识点！！！！</strong>这部分<strong><span style="background-color:#fefcd8;">创建了一个 add_two 的匿名对象（生命周期只有一行），使用了默认构造函数，该构造函数将 comm 成员初始化为 0</span></strong>。<span style="color:#fe2c24;"><strong>这个对象实际上是一个函数对象（因为我们重载了operator（），所以对象后面跟上括号，自然而然就会去调用重载函数去了），因为我们可以调用它</strong></span>。</p> 
<p></p> 
<p>接下来，<span style="background-color:#fefcd8;">像调用函数一样传递了一个整数参数 2 给这个匿名对象</span>。<strong>由于 add_two 类重载了 operator()，因此可以将它视为函数调用。</strong></p> 
<p></p> 
<p> int ret = ...：最后，将这个函数对象调用的结果（在这种情况下是 0 + 2 = 2）赋值给整数变量 ret。</p> 
<p>所以，int ret = add_two()(2); 的含义是<span style="color:#fe2c24;"><span style="background-color:#fefcd8;">创建一个 add_two 的匿名对象，然后将其当做函数调用，将参数 2 传递给它，最后将结果 2 赋给 ret。这展示了函数对象的使用，允许像调用函数一样使用类的实例。</span></span></p> 
<p class="img-center"><img alt="" height="116" src="https://images2.imgbox.com/ae/00/G99GMTHM_o.png" width="805"></p> 
<p>但如果想充分发挥函数对象的作用的话，其实我们可以直接输出：</p> 
<p class="img-center"><img alt="" height="41" src="https://images2.imgbox.com/5c/85/qkXINuzt_o.png" width="472"></p> 
<p></p> 
<h5 id="2.%E6%8E%A2%E7%A9%B6%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">2.探究匿名对象的生命周期</h5> 
<pre><code class="language-cpp">//讲解匿名对象
class MyClass {
public:
    MyClass() {
        std::cout &lt;&lt; "MyClass constructor" &lt;&lt; std::endl;
    }

    ~MyClass() {
        std::cout &lt;&lt; "MyClass destructor" &lt;&lt; std::endl;
    }
};

int main() {
    cout &lt;&lt; "flag1" &lt;&lt; endl;
    MyClass();  // 创建匿名对象 匿名对象的生命周期只有这一行
    cout &lt;&lt; "flag2" &lt;&lt; endl;
    return 0;
}</code></pre> 
<p><span style="color:#fe2c24;"><strong><span style="background-color:#fefcd8;">匿名对象的生命周期只有创建的那一行，走了之后就会被销毁掉！ </span></strong></span></p> 
<p></p> 
<h5 id="3.%E5%9B%9E%E5%BF%86%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E6%8B%86%E5%88%86%E5%BC%80%E6%80%8E%E4%B9%88%E5%86%99">3.回忆匿名对象拆分开怎么写</h5> 
<p>好了，我们了解完匿名对象的知识点后，让我们来回忆一下上面那个例子拆分开来是什么效果 </p> 
<pre><code class="language-cpp">//int tmp=add_two(100);
add_two addFunction(100); // 创建一个 add_two 对象
ret = addFunction(2); // 调用对象的 operator()，传递参数 2
cout &lt;&lt; ret &lt;&lt; endl;</code></pre> 
<p></p> 
<h5 id="4.%E8%AE%A8%E8%AE%BA%E5%A4%9A%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98%EF%BC%88%E5%A4%9A%E5%8F%82%E6%95%B0%E4%B8%8D%E6%98%AF%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E5%A4%9A%EF%BC%8C%E8%80%8C%E6%98%AF%E7%B1%BB%E4%B8%AD%E5%A4%9A%E5%8F%98%E9%87%8F%EF%BC%89">4.讨论多参数问题（多参数不是重载函数多，而是类中多变量）</h5> 
<p class="img-center"><img alt="" height="130" src="https://images2.imgbox.com/1e/eb/d0K0PlFt_o.png" width="819"></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;

// 基本情况：当没有参数时，返回0
int sum() {
    return 0;
}

// 使用可变参数模板来计算总和
template &lt;typename T, typename... Args&gt;
T sum(T first, Args... rest) {
    return first + sum(rest...);
}

int main() {
    int result = sum(1, 2, 3, 4, 5);
    std::cout &lt;&lt; "Sum: " &lt;&lt; result &lt;&lt; std::endl;

    double result2 = sum(1.1, 2.2, 3.3, 4.4);
    std::cout &lt;&lt; "Sum: " &lt;&lt; result2 &lt;&lt; std::endl;

    return 0;
}
</code></pre> 
<p class="img-center"><img alt="" height="221" src="https://images2.imgbox.com/67/90/ps7OMx6Q_o.png" width="819"></p> 
<hr> 
<h2 id="%E5%9B%9B%E3%80%81%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E7%B1%BB">四、函数对象的分类</h2> 
<p>函数对象是重载了operator() 的类的一个实例，operator()是函数调用运算符。</p> 
<p>标准C++库根据 operator() 参数个数为0个，1个，2个加以划分的。要有以下3种类型：</p> 
<ul><li>发生器:一种没有参数且返回一个任意类型值的函数对象，例如随机数发生器。</li></ul> 
<p></p> 
<ul><li>一元函数:一种只有一个任意类型的参数，且返回-个可能不同类型值的函数对象。</li></ul> 
<p></p> 
<ul><li>二元函数:一种有两个任意类型的参数，且返回一个任意类型值的函数对象。</li></ul> 
<p></p> 
<ul><li>一元判定函数: 返回bool型值的一元函数</li></ul> 
<p></p> 
<ul><li>二元判定函数: 返回bool型值的二元函数</li></ul> 
<h3 id="4.1%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0">4.1一元函数</h3> 
<pre><code class="language-cpp">templat&lt;typename _A,typename _R&gt;
class unary_function
{
    typedef _A argument_type;

    typedef _R result_type;      
};</code></pre> 
<p>有俩个模板参数 第一个是输出参数 参数类型 第二个模板参数定义为结果类型 返回类型 动态特性非常强</p> 
<p></p> 
<p><strong>p62 </strong>即使类中从来没有用过 但是还是可以定义用 （意思是，这个基类是在上面的类继承下来的，所以说它的arg也可以当成输出参数，即使我们的基类没有写）</p> 
<p>P62页代码：</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;functional&gt;
#include&lt;vector&gt;
using namespace std;
template&lt;typename _A, typename _R&gt;
struct unary {
	typedef _A argument_type;
	typedef _R result_type;
};


template&lt;typename _inPara, typename _outPara&gt;//邸老师说 希望这里删去
class CSum : public unary&lt;_inPara, _outPara&gt; {
public:
	_outPara sum;//这里可以使用 result_type;
	CSum() { sum = 0; }
	void operator()(_inPara n) { sum += n; } //这里同理也可以用 argument_type;
	_outPara GetSum() { return sum; }
};
template&lt;typename _input&gt;
class CPrint
{
    public://这个记得加
    CPrint(){};
    void operator()(_input var)
    {
        cout &lt;&lt; var &lt;&lt; " ";
    }
};
int main() 
{
    //传int
	vector&lt;int&gt; v;
	for (int i = 1;i &lt;= 5;i++) { v.push_back(i); }
    //遍历int
    vector&lt;int&gt;::iterator it=v.begin();
    for(;it!=v.end();++it)
    {
        cout &lt;&lt; *it &lt;&lt; " ";//这样遍历 可以防止出界 比那个[]遍历更安全
    }cout &lt;&lt; endl;

	CSum&lt;int, int&gt; sobj = for_each(v.begin(), v.end(), CSum&lt;int, int&gt;());//类的显示实例化+匿名对象
	cout &lt;&lt; "sum(int)=" &lt;&lt; sobj.GetSum() &lt;&lt; endl;


    //传float
	vector&lt;float&gt; v2;
	float f = 1.3f;
	for (int i = 1;i &lt;= 5;i++) { 
		v2.push_back(f); 
		f += 1.0f; 
	}
    //遍历float
    vector&lt;float&gt;::iterator it1=v2.begin();
    for(;it1!=v2.end();++it1)
    {
        cout &lt;&lt; *it1 &lt;&lt; " ";//这样遍历 可以防止出界 比那个[]遍历更安全
    }cout &lt;&lt; endl;
    
	CSum&lt;float, float&gt; sobj2 = for_each(v2.begin(), v2.end(), CSum&lt;float, float&gt;());
	cout &lt;&lt; "sum(float)=" &lt;&lt; sobj2.GetSum() &lt;&lt; endl;

    //利用CPrint函数对象 与 for_each代替迭代器输出
    vector&lt;int&gt;v3={1,2,3,4,5};
    for_each(v3.begin(), v3.end(), CPrint&lt;int&gt;());
    cout &lt;&lt; endl;
    //同理
     vector&lt;float&gt;v4={1.1,2.1,3.1,4.1,5.1};
    for_each(v4.begin(), v4.end(), CPrint&lt;float&gt;());

    //lambad表达式
    
	return 0;
}</code></pre> 
<h3 id="4.2%E4%BA%8C%E5%85%83%E5%87%BD%E6%95%B0" style="background-color:transparent;">4.2二元函数</h3> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/76/27/nTl8LZYp_o.jpg" width="1200"></p> 
<p>利用二元函数使得学生成绩升序 </p> 
<p>这个基类只定义了一个变量的名字，其实也没有什么东西，以下程序自定义的类得以这个为基类，派生</p> 
<p>很多时候都要重载与之对应的操作符 模板函数相当于框架，操作符重载相当于调用的接口 </p> 
<p></p> 
<p></p> 
<h3 id="4.3%E4%B8%80%E5%85%83%E5%88%A4%E5%AE%9A%E5%87%BD%E6%95%B0">4.3一元判定函数</h3> 
<h3 id="4.4%E4%BA%8C%E5%85%83%E5%88%A4%E5%AE%9A%E5%87%BD%E6%95%B0%C2%A0">4.4二元判定函数 </h3> 
<h2 id="%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD.....%EF%BC%89">五、总结知识点（未完待续.....）</h2> 
<p class="img-center"><img alt="" height="146" src="https://images2.imgbox.com/57/26/AJm07H1f_o.png" width="765"></p> 
<p>一个类中重载了（），那么这个类创造的对象就叫做函数对象！！！同时这个类被叫做仿函数</p> 
<p>再用起来的时候，函数对象就是函数名！！！！（底层不是）</p> 
<p></p> 
<p><img alt="" height="592" src="https://images2.imgbox.com/df/40/WMOMeAdZ_o.png" width="1200"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0e96d05f3dfc2fd8886baaf1af07e38a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【JavaEE初阶】 认识文件与Java中操作文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4ab24c25d8cf4a76de07dbf8c99381f5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">网络流量调度的艺术：权重公平排队算法（WFQ）揭秘，全面解析！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>