<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[Collection与数据结构] 七大排序算法汇总 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/9d2ad5400ef40791f1a0dbad98b7ad1e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="[Collection与数据结构] 七大排序算法汇总">
  <meta property="og:description" content="🌸个人主页:https://blog.csdn.net/2301_80050796?spm=1000.2115.3001.5343
🏵️热门专栏:🍕 Collection与数据结构 (90平均质量分)https://blog.csdn.net/2301_80050796/category_12621348.html?spm=1001.2014.3001.5482
🧀Java EE(93平均质量分) https://blog.csdn.net/2301_80050796/category_12643370.html?spm=1001.2014.3001.5482
🍭MySql数据库(93平均质量分)https://blog.csdn.net/2301_80050796/category_12629890.html?spm=1001.2014.3001.5482
感谢点赞与关注~~~
1.概述 1.1 概念 排序：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。
稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。
1.2 常见应用 高校排行
商品排序
2. 常见排序 2.1 直接插入排序 从序列的第二个位置开始为基准,把前面的一个元素依次与下一个元素比较,前一个元素大于后一个元素(升序),则交换,如果碰到小于的,则证明前几个元素已经有序了,因为是从第二个元素开始进行插入排序的,直接break掉.
动态演示:
/** * 插入排序 * @param array 传入的数组 */ public static void insertSort(int[] array){ for (int i = 1; i &lt; array.length; i&#43;&#43;) {//基准从1开始 for (int j = i-1; j &gt;= 0; j--) { if (array[j] &gt; array[j&#43;1]){//把前面的元素依次比较 swap(j,j&#43;1,array); }else { break;//遇到不符合条件的直接break } } } } private static void swap(int a,int b,int[] array){ int tmp = array[a]; array[a] = array[b]; array[b] = tmp; } 特性总结:">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-04T23:34:43+08:00">
    <meta property="article:modified_time" content="2024-05-04T23:34:43+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[Collection与数据结构] 七大排序算法汇总</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>🌸个人主页:<a href="https://blog.csdn.net/2301_80050796?spm=1000.2115.3001.5343">https://blog.csdn.net/2301_80050796?spm=1000.2115.3001.5343</a><br> 🏵️热门专栏:🍕 Collection与数据结构 (90平均质量分)<a href="https://blog.csdn.net/2301_80050796/category_12621348.html?spm=1001.2014.3001.5482">https://blog.csdn.net/2301_80050796/category_12621348.html?spm=1001.2014.3001.5482</a><br> 🧀Java EE(93平均质量分) <a href="https://blog.csdn.net/2301_80050796/category_12643370.html?spm=1001.2014.3001.5482">https://blog.csdn.net/2301_80050796/category_12643370.html?spm=1001.2014.3001.5482</a><br> 🍭MySql数据库(93平均质量分)<a href="https://blog.csdn.net/2301_80050796/category_12629890.html?spm=1001.2014.3001.5482">https://blog.csdn.net/2301_80050796/category_12629890.html?spm=1001.2014.3001.5482</a><br> 感谢点赞与关注~~~<br> <img src="https://images2.imgbox.com/4f/5d/LJmTn4qE_o.jpg" alt="在这里插入图片描述"></p> 
</blockquote> 
<h2><a id="1_7"></a>1.概述</h2> 
<h3><a id="11__8"></a>1.1 概念</h3> 
<p>排序：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，<mark>递增或递减的排列</mark>起来的操作。<br> 稳定性：假定在待排序的记录序列中，<mark>存在多个具有相同的关键字的记录</mark>，若经过排序，这些记录的<mark>相对次序保持不变</mark>，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，<mark>则称这种排序算法是稳定的</mark>；否则称为不稳定的。</p> 
<h3><a id="12__11"></a>1.2 常见应用</h3> 
<ol><li>高校排行<br> <img src="https://images2.imgbox.com/cf/7e/FCooJSGY_o.png" alt="在这里插入图片描述"></li><li>商品排序<br> <img src="https://images2.imgbox.com/23/08/C44CW9t9_o.png" alt="在这里插入图片描述"></li></ol> 
<h2><a id="2__16"></a>2. 常见排序</h2> 
<h3><a id="21__17"></a>2.1 直接插入排序</h3> 
<p>从序列的第二个位置开始为基准,把前面的一个元素依次与下一个元素比较,前一个元素大于后一个元素(升序),则交换,如果碰到小于的,则证明前几个元素已经有序了,因为是从第二个元素开始进行插入排序的,直接break掉.<br> <strong>动态演示</strong>:<br> <img src="https://images2.imgbox.com/04/4c/Xz1coy5O_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java"><span class="token comment">/**
     * 插入排序
     * @param array 传入的数组
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">insertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//基准从1开始</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//把前面的元素依次比较</span>
                    <span class="token function">swap</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//遇到不符合条件的直接break</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> tmp <span class="token operator">=</span> array<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>
        array<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>
        array<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p><strong>特性总结</strong>:</p> 
<ol><li><mark>元素越趋于有序,插入排序越快</mark>,因为遇到比较不符合条件的直接回break掉.</li><li>时间复杂度:两层循环,O(n<sup>2</sup>)</li><li>空间复杂度:只在数组本身上进行了操作,O(1)</li><li>稳定性:稳定</li></ol> 
<h3><a id="22__49"></a>2.2 希尔排序</h3> 
<p>希尔排序实际上是直接插入排序的一种升级版,先把序列中的元素<strong>按照一定的间隔个数分成多个组</strong>,之后把各个组中的元素进行排序,之后<strong>缩小缩小间隔个数,也就是缩小组数,增大各个组中的元素个数</strong>,再次排序,<mark>直到元素之间的间隔小于1为止</mark>.<br> <strong>动态演示</strong>:<br> <img src="https://images2.imgbox.com/c0/f2/3t5nupM3_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java"> <span class="token comment">/**
     * 希尔排序,本质上是插入排序的一种升级版
     * @param array
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">shellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> gap <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>gap <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//数据间隙大于1时继续希尔排序</span>
            gap <span class="token operator">=</span> gap<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//缩小数据间隙</span>
            <span class="token function">shell</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span>gap<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">shell</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span><span class="token keyword">int</span> gap<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//针对每一组数据进行插入排序</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">-</span>gap<span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">-=</span>gap<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//只不过每次的步数变成了gap</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> array<span class="token punctuation">[</span>j<span class="token operator">+</span>gap<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    <span class="token function">swap</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span>j<span class="token operator">+</span>gap<span class="token punctuation">,</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>其实我们观察上述代码,我们为什么说他是直接插入排序的升级版,是因为,它相比直接插入排序<mark>只是改变了每次走的步数</mark>.</p> 
<p><strong>特性总结</strong>:</p> 
<ol><li>希尔排序是针对直接插入排序的优化</li><li>当gap&gt;1时都是<strong>预排序</strong>,目的是让数据越来越接近有序.当gap==1的时候,<strong>就是直接插入排序,这时数据已经趋于有序了,直接插入排序就会特别快</strong>.</li><li>时间复杂度:目前仍然存在争议,一般认为是O(n<sup>1.25</sup>~1.6n<sup>1.25</sup>)</li><li>稳定性:不稳定</li></ol> 
<h3><a id="23__85"></a>2.3 选择排序</h3> 
<p>从第一个元素开始,寻找比基准元素小的元素,下标保存到tmp中,之后继续寻找比tmp小的元素,<strong>直到找到最小的元素为止</strong>,之后交换基准元素和tmp下标的元素,基准后移,一些此类推.<br> <strong>动态演示</strong>:</p> 
<p><img src="https://images2.imgbox.com/ab/c4/A1Jsjkg5_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java"><span class="token comment">/**
     * 选择排序
     * @param array
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">selectSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> min <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token comment">//最小值的下标赋值为i,如果没有找到比min下标小的,说明i就是最小的</span>
            <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">&gt;</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    min <span class="token operator">=</span> j<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token function">swap</span><span class="token punctuation">(</span>min<span class="token punctuation">,</span>i<span class="token punctuation">,</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

</code></pre> 
<p><strong>特性总结</strong>:</p> 
<ol><li>时间复杂度:O(n<sup>2</sup>)</li><li>空间复杂度:O(1)</li><li>稳定性:不稳定</li><li>这种排序方法虽然好理解,但是由于效率太低,日常开发中很少用.</li></ol> 
<h3><a id="24__115"></a>2.4 冒泡排序</h3> 
<p>之所以叫冒泡排序,是因为就像水中的气泡一样,一点一点地浮出水面.先确定排序的趟数(下标最大值),就是外层循环,再确定排序交换的次数(下标最大值-i),就是内层循环,遇到比自己小的就交换,这样最大值就像冒泡一样排到了最后.<br> 优化: 如果发现在内层循环遍历的时候,一次都没有交换,说明已经有序,我们通过flag来标记.<br> <strong>动态演示</strong>:<br> <img src="https://images2.imgbox.com/a2/52/RzGuuaJR_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java"><span class="token comment">/**
     * 冒泡排序
     * @param array
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//如果遍历到最后一个元素,就没有必要比较了,就要-1</span>
            <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//这里必须-1,因为如果不-1,就会遍历到最后一个元素,j+1就会越界</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    <span class="token function">swap</span><span class="token punctuation">(</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">,</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">//发生了交换.说明不有序,设置为false</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//如果flag == true,说明没有发生交换,整个数组已经有序</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token comment">//直接返回</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p><strong>特性总结</strong>:</p> 
<ol><li>时间复杂度:O(n<sup>2</sup>)</li><li>空间复杂度:O(1)</li><li>稳定性:稳定</li></ol> 
<h3><a id="25__145"></a>2.5 堆排序</h3> 
<p>首先如果是升序的话,先创建一个大根堆,让end指向最后一个元素为什么不创建小根堆呢?<strong>是因为小根堆只可以保证父节点是最小的,而不可以保证子节点是从小到大排列的</strong>.之后把堆顶元素和堆尾元素交换,就把整个堆的最大元素排到了最后.之后继续把该堆向下调整为大根堆,之后让end向前移动<br> <strong>动态演示</strong>:<br> <img src="https://images2.imgbox.com/4d/03/ZDhUZ7KQ_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java"><span class="token comment">/**
     * 堆排序,从小到大排序,创建大根堆
     * @param array
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> end <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token function">createBigHeap</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//先创建大根堆</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>end <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token function">swap</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>end<span class="token punctuation">,</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//交换堆顶元素和最后一个元素,把堆顶最大的元素放在最后</span>
            end<span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment">//end向前移动</span>
            <span class="token function">shiftDown</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>end<span class="token punctuation">,</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//再次向下调整为大根堆</span>
            <span class="token comment">//先向下调整,再--,因为向下调整的时候,while循环没有等号,如果传入end-1,倒数第二个结点就调整不到</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">createBigHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">shiftDown</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>array<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">shiftDown</span><span class="token punctuation">(</span><span class="token keyword">int</span> parent<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> child <span class="token operator">=</span> parent<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>child <span class="token operator">&lt;=</span> end<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> end <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>child<span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>child<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                child<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>child<span class="token punctuation">]</span> <span class="token operator">&gt;</span> array<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token function">swap</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span>child<span class="token punctuation">,</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
                parent <span class="token operator">=</span> child<span class="token punctuation">;</span>
                child <span class="token operator">=</span> child<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p><strong>特点总结</strong>:</p> 
<ol><li>堆排序适用于海量数据排序,数据越多,堆排序效率越高.</li><li>时间复杂度:复杂度主要集中于向下调整中,元素个数x树的高度,O(n*log<sub>2</sub>n)</li><li>空间复杂度:没有额外空间,O(1)</li><li>稳定性:不稳定</li></ol> 
<h3><a id="26__191"></a>2.6 快速排序(重点)</h3> 
<p>之所以叫快速排序,说明它是真的快.快速排序整体思想为<strong>分治思想,就是把通过递归的思想把整个数组通过一定的方法切成二叉树的形式,之后对每科子树进行排序</strong>.<br> 快速排序的方法有两种,一种是霍尔法,一种是挖坑法.</p> 
<h4><a id="261__194"></a>2.6.1 霍尔法</h4> 
<p>分别定义start和end指向数组首和尾,选取第一个元素为key,之后先让end向前移动,找到比key小的元素,之后再让start向后移动,找到比key大的元素,之后交换end和start下标的值,以此类推.直到start和end相遇,把相遇位置的元素和key交换,之后以相遇点分治,递归以此类推.<br> <strong>动态演示</strong>:<br> <img src="https://images2.imgbox.com/d7/b5/QKqVIrZe_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java"><span class="token comment">/**
     * 快速排序,整体思想:把小的往前放,把大的往后放
     * @param array
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token function">quick</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>array<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//规定开始和结束位置</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quick</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span><span class="token keyword">int</span> s<span class="token punctuation">,</span><span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> left <span class="token operator">=</span> s<span class="token punctuation">;</span>
        <span class="token keyword">int</span> right <span class="token operator">=</span> e<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//当左下标大于右下标的时候,说明递归完成,直接返回</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//把区间内的中间值放在头</span>
        <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token function">position</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">,</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//通过霍尔法找到分治点</span>
        <span class="token function">quick</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span>left<span class="token punctuation">,</span>pos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">quick</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span>pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//以分制点为基准,向两侧递归</span>
    <span class="token punctuation">}</span>
     <span class="token comment">/**
     * 霍尔法找到相遇位置
     * @param start 开始位置
     * @param end 结束位置
     * @param array 原始数组
     * @return
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">position</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> tmp <span class="token operator">=</span> array<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span><span class="token comment">//提前准备比较数据的下标</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> tmp<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//先走后面,注意加上等号</span>
                end<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> tmp<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//加前一个条件是为了防止出现已经排好序的极端情况</span>
                start<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token function">swap</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span>end<span class="token punctuation">,</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//当在前面找到比tmp大的数据,在后面找到比tmp大的数据,就交换</span>
        <span class="token punctuation">}</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>start<span class="token punctuation">,</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//当start和end相遇的时候,交换数列头元素和相遇地方的元素</span>
        <span class="token keyword">return</span> start<span class="token punctuation">;</span><span class="token comment">//返回相遇的点,以相遇的点分制</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h4><a id="262__241"></a>2.6.2 挖坑法</h4> 
<p>先把key(首)元素下标放入tmp中,让end向前移动,找到比tmp小的元素,填上key元素的坑,之后让start向后移动找到比tmp大的元素,填上上一个end的坑.以此类推,最后让tmp填上start和end相遇位置的坑.之后分治,递归重复上述操作.</p> 
<pre><code class="prism language-java"> <span class="token comment">/**
     * 快速排序,整体思想:把小的往前放,把大的往后放
     * @param array
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token function">quick</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>array<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//规定开始和结束位置</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quick</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span><span class="token keyword">int</span> s<span class="token punctuation">,</span><span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> left <span class="token operator">=</span> s<span class="token punctuation">;</span>
        <span class="token keyword">int</span> right <span class="token operator">=</span> e<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//当左下标大于右下标的时候,说明递归完成,直接返回</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//把区间内的中间值放在头</span>
        <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token function">position2</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">,</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">quick</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span>left<span class="token punctuation">,</span>pos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">quick</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span>pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//以分制点为基准,向两侧递归</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/**
     *挖坑法找相遇位置
     * @param start 开始位置
     * @param end 结束位置
     * @param array 原始数组
     * @return
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">position2</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> tmp <span class="token operator">=</span> array<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> tmp<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//先走后面,否则下面没法填坑</span>
                end<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            array<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> tmp<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                start<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            array<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        array<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
        <span class="token keyword">return</span> start<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h4><a id="263__286"></a>2.6.3 快速排序优化</h4> 
<ul><li>由于快速排序越来越趋向有序,所以我们可以以分治之后数组的长度作为基准,当小于一定的值之后,就可以对分治区域使用插入排序.</li><li>为了防止出现二叉树单分支的情况而降低效率,所以我们需要在<strong>分治区间找到中间大小的元素,与首元素交换</strong>.</li></ul> 
<p><strong>快速排序最终版</strong>:</p> 
<pre><code class="prism language-java"><span class="token comment">/**
     * 快速排序,整体思想:把小的往前放,把大的往后放
     * @param array
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token function">quick</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>array<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//规定开始和结束位置</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quick</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span><span class="token keyword">int</span> s<span class="token punctuation">,</span><span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> left <span class="token operator">=</span> s<span class="token punctuation">;</span>
        <span class="token keyword">int</span> right <span class="token operator">=</span> e<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//当左下标大于右下标的时候,说明递归完成,直接返回</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//优化2:在霍尔法或者挖坑法使得数组不断趋于有序时,我们就可以发挥直接插入排序的优势</span>
        <span class="token comment">//越趋于有序,越快</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>right<span class="token operator">-</span>left <span class="token operator">&lt;</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token function">insertSort2</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">,</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//优化1:寻找中间大小的数字,防止出现单分支情况导致效率太低</span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token function">findmid</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//把区间内的中间值放在头</span>
        <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token function">position</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">,</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">quick</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span>left<span class="token punctuation">,</span>pos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">quick</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span>pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//以分制点为基准,向两侧递归</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">insertSort2</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    <span class="token function">swap</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//比较区间内的开始,中间,结束位置的值</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">findmid</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span><span class="token keyword">int</span> start<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start<span class="token operator">+</span>end<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//区间内的中间位置</span>
        <span class="token comment">//先比较左右开始和结束的值</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//mid插入它们两个之间的三个空隙</span>
                <span class="token keyword">return</span> end<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&gt;</span> array<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> mid<span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> start<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> start<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> mid<span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> end<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/**
     * 霍尔法找到相遇位置
     * @param start 开始位置
     * @param end 结束位置
     * @param array 原始数组
     * @return
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">position</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> tmp <span class="token operator">=</span> array<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span><span class="token comment">//提前准备比较数据的下标</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> tmp<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//先走后面,注意加上等号</span>
                end<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> tmp<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//加前一个条件是为了防止出现已经排好序的极端情况</span>
                start<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token function">swap</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span>end<span class="token punctuation">,</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//当在前面找到比tmp大的数据,在后面找到比tmp大的数据,就交换</span>
        <span class="token punctuation">}</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>start<span class="token punctuation">,</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//当start和end相遇的时候,交换数列头元素和相遇地方的元素</span>
        <span class="token keyword">return</span> start<span class="token punctuation">;</span><span class="token comment">//返回相遇的点,以相遇的点分制</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     *挖坑法找相遇位置
     * @param start 开始位置
     * @param end 结束位置
     * @param array 原始数组
     * @return
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">position2</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> tmp <span class="token operator">=</span> array<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> tmp<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//先走后面,否则下面没法填坑</span>
                end<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            array<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> tmp<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                start<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            array<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        array<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
        <span class="token keyword">return</span> start<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h3><a id="27__396"></a>2.7 归并排序</h3> 
<p>先把数组从中间拆分开,让每个小数组有序,之后把小数组合并回来,大数组就是有序的.也是分治思想,整体也是一棵二叉树的形状.<br> <strong>动态演示</strong>:</p> 
<p><img src="https://images2.imgbox.com/f2/68/lj8HpzGB_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java"><span class="token comment">/**
     * 归并排序
     * @param array
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">mergSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token function">mergFunc</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>array<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">mergFunc</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">//拆分数组</span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//递归到left&gt;=right的时候,直接返回</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//向两侧递归</span>
        <span class="token function">mergFunc</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">mergFunc</span><span class="token punctuation">(</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">,</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//开始合并</span>
        <span class="token function">merg</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//在合并的时候进行排序</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">merg</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">,</span><span class="token keyword">int</span> mid<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> s1 <span class="token operator">=</span> left<span class="token punctuation">;</span>
        <span class="token keyword">int</span> e1 <span class="token operator">=</span> mid<span class="token punctuation">;</span>
        <span class="token keyword">int</span> s2 <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> e2 <span class="token operator">=</span> right<span class="token punctuation">;</span>
        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> tmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>right<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>s1 <span class="token operator">&lt;=</span> e1 <span class="token operator">&amp;&amp;</span> s2 <span class="token operator">&lt;=</span> e2<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>s1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>s2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                tmp<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>s1<span class="token punctuation">]</span><span class="token punctuation">;</span>
                k<span class="token operator">++</span><span class="token punctuation">;</span>
                s1<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                tmp<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>s2<span class="token punctuation">]</span><span class="token punctuation">;</span>
                k<span class="token operator">++</span><span class="token punctuation">;</span>
                s2<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//看哪个数组还有数据,拷贝进去</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>s1 <span class="token operator">&lt;=</span> e1<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            tmp<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>s1<span class="token punctuation">]</span><span class="token punctuation">;</span>
            k<span class="token operator">++</span><span class="token punctuation">;</span>
            s1<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>s2 <span class="token operator">&lt;=</span> e2<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            tmp<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>s2<span class="token punctuation">]</span><span class="token punctuation">;</span>
            k<span class="token operator">++</span><span class="token punctuation">;</span>
            s2<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//把临时数组中的数据拷贝到原数组中</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tmp<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            array<span class="token punctuation">[</span>left<span class="token operator">+</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p><strong>特性总结</strong>:</p> 
<ol><li>时间复杂度:元素个数x数的高度,O(n*log<sub>2</sub>n)</li><li>空间复杂度:额外申请了一个数组,所以是O(n)</li><li>稳定性:稳定</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/115188cf85171bc7f02e36ae059fc801/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java高阶私房菜：JVM性能优化案例及讲解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5431d1017427302552ae2625026b758c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AI智能体｜使用扣子Coze创建AI绘画工作流</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>