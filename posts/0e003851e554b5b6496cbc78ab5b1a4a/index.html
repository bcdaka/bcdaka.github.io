<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JSqlParser的使用 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/0e003851e554b5b6496cbc78ab5b1a4a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="JSqlParser的使用">
  <meta property="og:description" content="简介 JSqlParse是一款很精简的sql解析工具，它可以将常用的sql文本解析成具有层级结构的语法树，我们可以针对解析后的节点进行处理(增加、移除、修改等操作),从而生成符合我们业务要求的sql，比如添加过滤条件等等
JSqlParse采用访问者模式
项目简介 项目结构非常简单，从截图上看就5个包。如果对源码感兴趣的可以直接从github上下载源码包调试。其中expression包包含了所有的sql表达式的抽象对象：
statement包含了所有sql语句的类型，比如：增删改查，ddl语句,rollback语句等等
schema包是对数据库基本单元的抽象：服务器、数据库、表、列等等
parser包是整个解析的核心逻辑，感兴趣的可以自行源码调试
使用示例 上面已经做了关于该解析工具的简单介绍，对于工具类，最重要的使用。以下举例关于增、删、改、查的sql语句中，均增加一列为例介绍该工具的简单使用
依赖引入 &lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;4.5&lt;/version&gt; &lt;/dependency&gt; 新增add 原始sql：insert into t_user_info(id,user_name,address) values(&#39;123&#39;,&#39;zhangsan&#39;,&#39;龙华&#39;)
期望在执行该sql时，能增加一列STATUS作为插入
都是一些api的运用，相关代码如下：
package com.lyc.boot.client.test.insert; import com.lyc.boot.client.test.insert.visitor.InsertStatementVisitor; import lombok.extern.slf4j.Slf4j; import net.sf.jsqlparser.JSQLParserException; import net.sf.jsqlparser.expression.Expression; import net.sf.jsqlparser.expression.RowConstructor; import net.sf.jsqlparser.expression.StringValue; import net.sf.jsqlparser.expression.operators.relational.ExpressionList; import net.sf.jsqlparser.expression.operators.relational.ItemsList; import net.sf.jsqlparser.parser.CCJSqlParserUtil; import net.sf.jsqlparser.schema.Column; import net.sf.jsqlparser.statement.Statement; import net.sf.jsqlparser.statement.insert.Insert; import net.sf.jsqlparser.statement.select.Select; import net.sf.jsqlparser.statement.select.SelectBody; import net.sf.jsqlparser.statement.select.SetOperationList; import net.sf.jsqlparser.statement.values.ValuesStatement; import java.util.List; import static com.lyc.boot.client.test.CommonUtil.printStatement; import static com.lyc.boot.client.test.CommonUtil.printTableName; @Slf4j public class InsertCommonTest { private static final String INSERT_COMMON = &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-22T18:24:14+08:00">
    <meta property="article:modified_time" content="2024-03-22T18:24:14+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JSqlParser的使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>简介</h3> 
<p>        JSqlParse是一款很精简的sql解析工具，它可以将常用的sql文本解析成具有层级结构的语法树，我们可以针对解析后的节点进行处理(增加、移除、修改等操作),从而生成符合我们业务要求的sql，比如添加过滤条件等等</p> 
<p>     JSqlParse采用访问者模式</p> 
<h3>项目简介</h3> 
<p>        <img alt="" height="239" src="https://images2.imgbox.com/6f/71/LZ541PJr_o.png" width="508"></p> 
<p>项目结构非常简单，从截图上看就5个包。如果对源码感兴趣的可以直接从github上下载源码包调试。其中expression包包含了所有的sql表达式的抽象对象：</p> 
<p><img alt="" height="418" src="https://images2.imgbox.com/33/d7/tGnxoYFa_o.png" width="468"></p> 
<p>statement包含了所有sql语句的类型，比如：增删改查，ddl语句,rollback语句等等</p> 
<p><img alt="" height="344" src="https://images2.imgbox.com/20/6d/DyZtMSgS_o.png" width="361"></p> 
<p>schema包是对数据库基本单元的抽象：服务器、数据库、表、列等等</p> 
<p><img alt="" height="161" src="https://images2.imgbox.com/51/cf/WvKi71JG_o.png" width="310"></p> 
<p>parser包是整个解析的核心逻辑，感兴趣的可以自行源码调试</p> 
<p><img alt="" height="522" src="https://images2.imgbox.com/1e/45/9AgIYqa0_o.png" width="397"></p> 
<h3>使用示例</h3> 
<p>        上面已经做了关于该解析工具的简单介绍，对于工具类，最重要的使用。以下举例关于增、删、改、查的sql语句中，均增加一列为例介绍该工具的简单使用</p> 
<h4>依赖引入</h4> 
<pre><code class="language-XML">&lt;dependency&gt;
    &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt;
    &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt;
    &lt;version&gt;4.5&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<h4>新增add</h4> 
<p><strong>原始sql：insert into t_user_info(id,user_name,address) values('123','zhangsan','龙华')</strong></p> 
<p><strong>期望在执行该sql时，能增加一列STATUS作为插入</strong></p> 
<p>都是一些api的运用，相关代码如下：</p> 
<pre><code class="language-java">package com.lyc.boot.client.test.insert;

import com.lyc.boot.client.test.insert.visitor.InsertStatementVisitor;
import lombok.extern.slf4j.Slf4j;
import net.sf.jsqlparser.JSQLParserException;
import net.sf.jsqlparser.expression.Expression;
import net.sf.jsqlparser.expression.RowConstructor;
import net.sf.jsqlparser.expression.StringValue;
import net.sf.jsqlparser.expression.operators.relational.ExpressionList;
import net.sf.jsqlparser.expression.operators.relational.ItemsList;
import net.sf.jsqlparser.parser.CCJSqlParserUtil;
import net.sf.jsqlparser.schema.Column;
import net.sf.jsqlparser.statement.Statement;
import net.sf.jsqlparser.statement.insert.Insert;
import net.sf.jsqlparser.statement.select.Select;
import net.sf.jsqlparser.statement.select.SelectBody;
import net.sf.jsqlparser.statement.select.SetOperationList;
import net.sf.jsqlparser.statement.values.ValuesStatement;

import java.util.List;

import static com.lyc.boot.client.test.CommonUtil.printStatement;
import static com.lyc.boot.client.test.CommonUtil.printTableName;

@Slf4j
public class InsertCommonTest {

    private static final String INSERT_COMMON = "insert into t_user_info(id,user_name,address) values('123','zhangsan','龙华')";

    public static void main(String[] args) throws JSQLParserException {
        useCommonAddColumn();
//        useVisitorAddColumn();
    }

    private static void useCommonAddColumn() throws JSQLParserException {
        Statement statement = CCJSqlParserUtil.parse(INSERT_COMMON);
        printStatement(statement);
        if (statement instanceof Insert) {
            Insert insert = (Insert)statement;
            printTableName(insert.getTable());
            List&lt;Column&gt; columns = insert.getColumns();
            columns.add(new Column("STATUS"));

            Select select = insert.getSelect();
            SelectBody selectBody = select.getSelectBody();
            if (selectBody instanceof SetOperationList) {
                SetOperationList operationList = (SetOperationList)selectBody;
                List&lt;SelectBody&gt; selects = operationList.getSelects();
                for (SelectBody body : selects) {
                    if (body instanceof ValuesStatement) {
                        ValuesStatement valuesStatement = (ValuesStatement)body;
                        ItemsList itemsList = valuesStatement.getExpressions();
                        if(itemsList instanceof ExpressionList) {
                            ExpressionList expressionList = (ExpressionList)itemsList;
                            List&lt;Expression&gt; expressions = expressionList.getExpressions();
                            for (Expression expression : expressions) {
                                if(expression instanceof RowConstructor) {
                                    RowConstructor rowConstructor = (RowConstructor)expression;
                                    ExpressionList exprList = rowConstructor.getExprList();
                                    List&lt;Expression&gt; rowConstructorExList = exprList.getExpressions();
                                    rowConstructorExList.add(new StringValue("0"));
                                }
                            }
                        }
                    }
                }
            }
        }
        printStatement(statement);
    }

    /**
     * 使用访问者方式增加insert的column
     *
     * @throws JSQLParserException
     */
    private static void useVisitorAddColumn() throws JSQLParserException {
        Statement statement = CCJSqlParserUtil.parse(INSERT_COMMON);
        printStatement(statement);

        statement.accept(new InsertStatementVisitor());
        printStatement(statement);
    }


}
</code></pre> 
<pre><code class="language-java">package com.lyc.boot.client.test.insert.visitor;

import net.sf.jsqlparser.schema.Column;
import net.sf.jsqlparser.statement.StatementVisitorAdapter;
import net.sf.jsqlparser.statement.insert.Insert;
import net.sf.jsqlparser.statement.select.Select;
import net.sf.jsqlparser.statement.select.SelectBody;

import java.util.List;

import static com.lyc.boot.client.test.CommonUtil.printTableName;

public class InsertStatementVisitor extends StatementVisitorAdapter {

    @Override
    public void visit(Insert insert) {
        printTableName(insert.getTable());
        List&lt;Column&gt; columns = insert.getColumns();
        columns.add(new Column("status"));

        Select select = insert.getSelect();
        SelectBody selectBody = select.getSelectBody();
        selectBody.accept(new InsertSelectVisitor());
    }
}
</code></pre> 
<pre><code class="language-java">package com.lyc.boot.client.test.insert.visitor;

import net.sf.jsqlparser.expression.operators.relational.ItemsList;
import net.sf.jsqlparser.statement.select.SelectBody;
import net.sf.jsqlparser.statement.select.SelectVisitorAdapter;
import net.sf.jsqlparser.statement.select.SetOperationList;
import net.sf.jsqlparser.statement.values.ValuesStatement;

import java.util.List;

public class InsertSelectVisitor extends SelectVisitorAdapter {
    @Override
    public void visit(SetOperationList setOpList) {
        List&lt;SelectBody&gt; selects = setOpList.getSelects();
        for (SelectBody body : selects) {
            body.accept(this);
        }
    }

    @Override
    public void visit(ValuesStatement valuesStatement) {
        ItemsList itemsList = valuesStatement.getExpressions();
        itemsList.accept(new InsertItemsListVisitor());
    }
}
</code></pre> 
<pre><code class="language-java">package com.lyc.boot.client.test.insert.visitor;

import net.sf.jsqlparser.expression.Expression;
import net.sf.jsqlparser.expression.operators.relational.ExpressionList;
import net.sf.jsqlparser.util.validation.validator.ItemsListValidator;

import java.util.List;

public class InsertItemsListVisitor extends ItemsListValidator {

    @Override
    public void visit(ExpressionList expressionList) {
        List&lt;Expression&gt; expressions = expressionList.getExpressions();
        for (Expression expression : expressions) {
            expression.accept(new InsertExpressionVisitor());
        }
    }
}
</code></pre> 
<pre><code class="language-java">package com.lyc.boot.client.test.insert.visitor;

import net.sf.jsqlparser.expression.Expression;
import net.sf.jsqlparser.expression.ExpressionVisitorAdapter;
import net.sf.jsqlparser.expression.RowConstructor;
import net.sf.jsqlparser.expression.StringValue;
import net.sf.jsqlparser.expression.operators.relational.ExpressionList;

import java.util.List;

public class InsertExpressionVisitor extends ExpressionVisitorAdapter {
    @Override
    public void visit(RowConstructor rowConstructor) {
        ExpressionList exprList = rowConstructor.getExprList();
        List&lt;Expression&gt; expressions = exprList.getExpressions();
        expressions.add(new StringValue("0"));
    }
}
</code></pre> 
<p>      以上是关于新增sql增加一列作为插入的简单运用，其中有通过类型判断处理和通过访问者模式处理(基于java多态实现)，最终打印的结果如下：</p> 
<p><img alt="" height="144" src="https://images2.imgbox.com/4f/0e/qEDjjENN_o.png" width="1200"></p> 
<h4 style="background-color:transparent;">删除delete</h4> 
<p><strong>原sql：delete from t_user_info where user_name = ? and addres = ?</strong></p> 
<p><strong>期望在删除时增加过滤条件STATUS='0'</strong></p> 
<p>相关代码如下：</p> 
<pre><code class="language-java">package com.lyc.boot.client.test.delete;

import com.lyc.boot.client.test.delete.visitor.DeleteStatementVisitor;
import lombok.extern.slf4j.Slf4j;
import net.sf.jsqlparser.JSQLParserException;
import net.sf.jsqlparser.parser.CCJSqlParserUtil;
import net.sf.jsqlparser.statement.Statement;
import net.sf.jsqlparser.statement.delete.Delete;

import static com.lyc.boot.client.test.CommonUtil.printStatement;

@Slf4j
public class DeleteCommonTest {

    private static final String DELETE_COMMON = "delete from t_user_info where user_name = ? and addres = ?";

    public static void main(String[] args) throws JSQLParserException {
//        commonAddColumn();
        visitorAddColumn();
    }

    private static void visitorAddColumn() throws JSQLParserException{
        Statement statement = CCJSqlParserUtil.parse(DELETE_COMMON);
        printStatement(statement);
        statement.accept(new DeleteStatementVisitor());
        printStatement(statement);
    }

    private static void commonAddColumn() throws JSQLParserException {
        Statement statement = CCJSqlParserUtil.parse(DELETE_COMMON);
        printStatement(statement);
        if(statement instanceof Delete) {
            Delete delete = (Delete)statement;
            DeleteStatementVisitor.addColumn(delete);
        }
        printStatement(statement);
    }
}
</code></pre> 
<h4></h4> 
<pre><code class="language-java">package com.lyc.boot.client.test.delete.visitor;

import com.lyc.boot.client.test.CommonUtil;
import lombok.extern.slf4j.Slf4j;
import net.sf.jsqlparser.expression.Expression;
import net.sf.jsqlparser.expression.Parenthesis;
import net.sf.jsqlparser.expression.StringValue;
import net.sf.jsqlparser.expression.operators.conditional.AndExpression;
import net.sf.jsqlparser.expression.operators.relational.EqualsTo;
import net.sf.jsqlparser.schema.Column;
import net.sf.jsqlparser.statement.StatementVisitorAdapter;
import net.sf.jsqlparser.statement.delete.Delete;

import java.util.Objects;

@Slf4j
public class DeleteStatementVisitor extends StatementVisitorAdapter {

    @Override
    public void visit(Delete delete) {
        addColumn(delete);
    }

    public static void addColumn(Delete delete) {
        CommonUtil.printTableName(delete.getTable());
        Expression where = delete.getWhere();
        Parenthesis parenthesis = new Parenthesis(new EqualsTo(new Column("STATUS"), new StringValue("1")));
        if (Objects.isNull(where)) {
            delete.setWhere(parenthesis);
        } else {
            delete.setWhere(new AndExpression(where,parenthesis));
        }
    }
}
</code></pre> 
<p>执行结果如下图：</p> 
<p><img alt="" height="106" src="https://images2.imgbox.com/cf/ec/Evue8WqT_o.png" width="992"></p> 
<h4 style="background-color:transparent;"></h4> 
<h4 style="background-color:transparent;">修改update</h4> 
<p><strong>原sql为：update t_user_info set user_name = ?,address = ? where id = ? and score = ?</strong></p> 
<p><strong>期望在修改时set增加STATUS = ? where条件增加STATUS = '1'</strong></p> 
<pre><code class="language-java">package com.lyc.boot.client.test.update;

import com.lyc.boot.client.test.update.visitor.UpdateStatementVisitor;
import lombok.extern.slf4j.Slf4j;
import net.sf.jsqlparser.JSQLParserException;
import net.sf.jsqlparser.expression.Expression;
import net.sf.jsqlparser.expression.JdbcParameter;
import net.sf.jsqlparser.expression.Parenthesis;
import net.sf.jsqlparser.expression.StringValue;
import net.sf.jsqlparser.expression.operators.conditional.AndExpression;
import net.sf.jsqlparser.expression.operators.relational.EqualsTo;
import net.sf.jsqlparser.parser.CCJSqlParserUtil;
import net.sf.jsqlparser.schema.Column;
import net.sf.jsqlparser.schema.Table;
import net.sf.jsqlparser.statement.Statement;
import net.sf.jsqlparser.statement.update.Update;
import net.sf.jsqlparser.statement.update.UpdateSet;

import java.util.ArrayList;
import java.util.Objects;

import static com.lyc.boot.client.test.CommonUtil.printStatement;

/**
 * update语句修改
 *
 *
 */
@Slf4j
public class UpdateCommonTest {

    private static final String COMMON_UPDATE = "update t_user_info set user_name = ?,address = ? where id = ? and score = ?";

    public static void main(String[] args) throws JSQLParserException {
//        commonUpdateAddColumn();
        visitorAddColumn();
    }

    private static void visitorAddColumn() throws JSQLParserException{
        Statement statement = CCJSqlParserUtil.parse(COMMON_UPDATE);
        printStatement(statement);

        statement.accept(new UpdateStatementVisitor());
        printStatement(statement);
    }

    private static void commonUpdateAddColumn() throws JSQLParserException {
        Statement statement = CCJSqlParserUtil.parse(COMMON_UPDATE);
        printStatement(statement);
        if(statement instanceof Update) {
            Update update = (Update)statement;
            Table table = update.getTable();
            ArrayList&lt;UpdateSet&gt; updateSets = update.getUpdateSets();
            Column column = new Column("STATUS");
            StringValue stringValue = new StringValue("?");
            JdbcParameter jdbcParameter = new JdbcParameter();
            UpdateSet updateSet = new UpdateSet(column,jdbcParameter);
            updateSets.add(updateSet);

            Expression whereExpression = update.getWhere();
            EqualsTo equalsTo = new EqualsTo(new Column("STATUS"), new StringValue("1"));
            Parenthesis parenthesis = new Parenthesis(equalsTo);

            if (Objects.isNull(whereExpression)) {
                update.setWhere(parenthesis);
            } else {
                update.setWhere(new AndExpression(whereExpression,parenthesis));
            }
        }
        printStatement(statement);
    }

}
</code></pre> 
<pre><code class="language-java">package com.lyc.boot.client.test.update.visitor;

import com.lyc.boot.client.test.CommonUtil;
import lombok.extern.slf4j.Slf4j;
import net.sf.jsqlparser.expression.Expression;
import net.sf.jsqlparser.expression.JdbcParameter;
import net.sf.jsqlparser.expression.Parenthesis;
import net.sf.jsqlparser.expression.StringValue;
import net.sf.jsqlparser.expression.operators.conditional.AndExpression;
import net.sf.jsqlparser.expression.operators.relational.EqualsTo;
import net.sf.jsqlparser.schema.Column;
import net.sf.jsqlparser.schema.Table;
import net.sf.jsqlparser.statement.StatementVisitorAdapter;
import net.sf.jsqlparser.statement.update.Update;
import net.sf.jsqlparser.statement.update.UpdateSet;

import java.util.ArrayList;
import java.util.Objects;

@Slf4j
public class UpdateStatementVisitor extends StatementVisitorAdapter {

    @Override
    public void visit(Update update) {
        CommonUtil.printTableName(update.getTable());

        ArrayList&lt;UpdateSet&gt; updateSets = update.getUpdateSets();
        UpdateSet statusUpdateSet = new UpdateSet(new Column("STATUS"), new JdbcParameter());
        updateSets.add(statusUpdateSet);

        Expression where = update.getWhere();
        Parenthesis parenthesis = new Parenthesis(new EqualsTo(new Column("STATUS"), new StringValue("1")));

        if (Objects.isNull(where)) {
            update.setWhere(parenthesis);
        } else {
            update.setWhere(new AndExpression(where,parenthesis));
        }
    }
}
</code></pre> 
<p>执行结果如下图所示：</p> 
<p><img alt="" height="119" src="https://images2.imgbox.com/d9/ad/eO9BMWXO_o.png" width="1200"></p> 
<h4>查询select</h4> 
<p>原sql如下：select id as id,user_name as userName,address as address from t_user_info where id = ? and user_name = ? order by create_time desc</p> 
<p>期望在查询时增加where的过滤条件STATUS = '1'</p> 
<pre><code class="language-java">package com.lyc.boot.client.test.select;

import com.lyc.boot.client.test.select.visitor.SelectSelectVisitor;
import com.lyc.boot.client.test.select.visitor.SelectStatementVisitor;
import lombok.extern.slf4j.Slf4j;
import net.sf.jsqlparser.JSQLParserException;
import net.sf.jsqlparser.parser.CCJSqlParserUtil;
import net.sf.jsqlparser.statement.Statement;
import net.sf.jsqlparser.statement.select.*;

import static com.lyc.boot.client.test.CommonUtil.printStatement;

@Slf4j
/**
 * 给查询条件添加更多的过滤条件
 *
 * and status = '1'
 */
public class SelectCommonTest {

    private static final String SELECT_COMMON = "select id as id,user_name as userName,address as address from t_user_info where id = ? and user_name = ? order by create_time desc";

    public static void main(String[] args) throws JSQLParserException {
//        commonSelectAddWhere();
        visitorSelectAddWhere();
    }

    private static void visitorSelectAddWhere() throws JSQLParserException{
        Statement statement = CCJSqlParserUtil.parse(SELECT_COMMON);
        printStatement(statement);
        statement.accept(new SelectStatementVisitor());
        printStatement(statement);
    }

    private static void commonSelectAddWhere() throws JSQLParserException {
        Statement statement = CCJSqlParserUtil.parse(SELECT_COMMON);
        printStatement(statement);
        if (statement instanceof Select) {
            Select select = (Select)statement;
            SelectBody selectBody = select.getSelectBody();
            if (selectBody instanceof PlainSelect) {
                PlainSelect plainSelect = (PlainSelect)selectBody;
                SelectSelectVisitor.setWhereExpression(plainSelect);
            }
        }
        printStatement(statement);
    }

}
</code></pre> 
<pre><code class="language-java">package com.lyc.boot.client.test.select.visitor;

import net.sf.jsqlparser.statement.StatementVisitorAdapter;
import net.sf.jsqlparser.statement.select.Select;
import net.sf.jsqlparser.statement.select.SelectBody;

public class SelectStatementVisitor extends StatementVisitorAdapter {

    @Override
    public void visit(Select select) {
        SelectBody selectBody = select.getSelectBody();
        selectBody.accept(new SelectSelectVisitor());
    }
}
</code></pre> 
<pre><code class="language-java">package com.lyc.boot.client.test.select.visitor;

import com.lyc.boot.client.test.CommonUtil;
import lombok.extern.slf4j.Slf4j;
import net.sf.jsqlparser.expression.Expression;
import net.sf.jsqlparser.expression.Parenthesis;
import net.sf.jsqlparser.expression.StringValue;
import net.sf.jsqlparser.expression.operators.conditional.AndExpression;
import net.sf.jsqlparser.expression.operators.relational.EqualsTo;
import net.sf.jsqlparser.schema.Column;
import net.sf.jsqlparser.schema.Table;
import net.sf.jsqlparser.statement.select.PlainSelect;
import net.sf.jsqlparser.statement.select.SelectVisitorAdapter;

import java.util.List;
import java.util.Objects;

@Slf4j
public class SelectSelectVisitor extends SelectVisitorAdapter {

    @Override
    public void visit(PlainSelect plainSelect) {
        setWhereExpression(plainSelect);
    }

    public static void setWhereExpression(PlainSelect plainSelect) {
        Expression where = plainSelect.getWhere();
        EqualsTo equalsTo = new EqualsTo(new Column("STATUS"), new StringValue("1"));
        Parenthesis parenthesis = new Parenthesis(equalsTo);

        if (Objects.isNull(where)) {
            plainSelect.setWhere(parenthesis);
        } else {
            AndExpression andExpression = new AndExpression(where, parenthesis);
            plainSelect.setWhere(andExpression);
        }
    }
}
</code></pre> 
<p>执行结果如下图：</p> 
<p><img alt="" height="84" src="https://images2.imgbox.com/cc/0d/txGkdFyj_o.png" width="1200"></p> 
<h3>扩展简析</h3> 
<p>jsqlParser的实际之一就是在mybaits-plus中的各种插件，比如：多租户插件com.baomidou.mybatisplus.extension.plugins.inner.TenantLineInnerInterceptor</p> 
<p>该插件的作用是：在执行sql时在where条件处增加了过滤条件(默认是tenant_id = ?,具体的字段可以自己配置实现)</p> 
<p>当配置了MybatisPlusInterceptor，并且添加了TenantLineInnerInterceptor时，在执行sql时会被该拦截器拦截，具体的源码流程如下：</p> 
<p><img alt="" height="610" src="https://images2.imgbox.com/85/e8/ihCDleg5_o.png" width="1200"></p> 
<p>当执行查询语句时，sql会被MybatisPlusInterceptor插件拦截，插件调TenantLineInnerInterceptor的beforeQuery方法触发</p> 
<p>其中BaseMultiTableInnerInterceptor是JsqlParserSupport的子类，提供了模板方法用于修改sql</p> 
<p>图上，生成的sql由com.baomidou.mybatisplus.extension.parser.JsqlParserSupport#parserSingle方法决定</p> 
<p><img alt="" height="313" src="https://images2.imgbox.com/71/30/rYyWjq2r_o.png" width="974"></p> 
<p>最终执行sql解析完成添加过滤条件的操作：</p> 
<p><img alt="" height="673" src="https://images2.imgbox.com/b9/36/fsiyGLwH_o.png" width="1075"></p> 
<p>在TenantLineInnerInterceptor插件中，最终是在where结尾出添加了(默认)tenant_id = xxxx的过滤条件，完成多租户数据隔离处理的。具体的源码逻辑可以调试根据</p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a72cc90ab42ba98e87e0a5e3fcbacd4e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LabVIEW调用Matlab脚本</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b6d20d7dd8d6ef99e1d041f5ce0e653c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Matlab App Designer 【05】Appdesigner和Simulink实时交互</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>