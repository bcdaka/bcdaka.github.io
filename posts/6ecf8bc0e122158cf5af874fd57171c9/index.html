<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C# 如何封装一个客户端，来调用“指定WSDL文件的WebService服务端“ - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/6ecf8bc0e122158cf5af874fd57171c9/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C# 如何封装一个客户端，来调用“指定WSDL文件的WebService服务端“">
  <meta property="og:description" content="根据指定WSDL文件,创建客户端，调用Webservice接口 IDE： Microsoft Visual Studio Community 2022 (64bit)平台：C#.Net6协议：Soap协议（Xml格式） 功能 对方是一个WebService服务端，己方是客户端，双方要遵守对方提供的WSDL规范。 实现方式1 使用BasicHttpBinding 通过WSDL文件，生成WEB服务 注意，这里，我的VS2022的提示步骤和网上查到的操作步骤略有不同，下面的步骤是我的VS2022的操作步骤：
首先，在 VS2022 中打开 .NET 6 项目或者新建一个 .NET 6 项目。
在“解决方案资源管理器”中，右键单击项目名称，然后选择“添加”-&gt;“服务引用”。
在“添加服务引用”窗口中，有三个选项，
OpenAPI，gRPCWCF Web Service 这里选择 WCF Web Service，进入窗口“添加新的WCF Web Service服务引用”
点击“浏览”按钮，然后从文件系统中选择你的 WSDL 文件。
选中 WSDL 文件后，服务引用的配置将在窗口下方显示出来。这里可以在下面的输入框，修改命名空间为你想要的名称，点击下一步，在新窗口中，可以指定数据类型选项，默认不需要改，点击“完成”。
此时，VS2022 会根据你的 WSDL 文件生成 Web 服务的代码，即：原Webservice服务的代理类。
还有一个生成Webservice服务代理类的方法：
用wsdl.exe工具的方式指令是：wsdl /language:c# /n:Fu /out:d:/MyService.cs C:\Users\Administrator\Desktop\MyService.wsdl） “d:/MyService.cs”是输出目录“C:\Users\Administrator\Desktop\MyService.wsdl”是源wsdl文件的位置 具体用法，可以使用搜索引擎查询，这里不再赘述。 调用该WebService的方法 public static async Task TestCallWs() { mydemo.TestMyClient serv = null; try { var binding = new BasicHttpBinding(); var endpoint = new EndpointAddress(UrlString); // url地址 serv = new mydemo.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-04T22:50:11+08:00">
    <meta property="article:modified_time" content="2024-07-04T22:50:11+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C# 如何封装一个客户端，来调用“指定WSDL文件的WebService服务端“</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="WSDLWebservice_0"></a>根据指定WSDL文件,创建客户端，调用Webservice接口</h2> 
<ul><li>IDE： Microsoft Visual Studio Community 2022 (64bit)</li><li>平台：C#.Net6</li><li>协议：Soap协议（Xml格式）</li></ul> 
<hr> 
<h3><a id="_5"></a>功能</h3> 
<ul><li>对方是一个WebService服务端，己方是客户端，双方要遵守对方提供的WSDL规范。</li></ul> 
<hr> 
<h3><a id="span_idway11span_8"></a><span id="way1">实现方式1</span></h3> 
<blockquote> 
 <ul><li>使用BasicHttpBinding</li></ul> 
</blockquote> 
<h4><a id="WSDLWEB_11"></a>通过WSDL文件，生成WEB服务</h4> 
<p><font color="#B22222"><strong>注意，这里，我的VS2022的提示步骤和网上查到的操作步骤略有不同，下面的步骤是我的VS2022的操作步骤：</strong></font></p> 
<ol><li> <p>首先，在 VS2022 中打开 .NET 6 项目或者新建一个 .NET 6 项目。</p> </li><li> <p>在“<strong>解决方案资源管理器</strong>”中，右键单击项目名称，然后选择“<strong>添加</strong>”-&gt;“<strong>服务引用</strong>”。</p> </li><li> <p>在“<strong>添加服务引用</strong>”窗口中，有三个选项，</p> 
  <ul><li><font color="#2E8B57"><strong>OpenAPI</strong></font>，</li><li><font color="#2E8B57"><strong>gRPC</strong></font></li><li><font color="#2E8B57"><strong>WCF Web Service</strong></font></li></ul> <p>这里选择 <font color="#2E8B57"><strong>WCF Web Service</strong></font>，进入窗口“<strong>添加新的WCF Web Service服务引用</strong>”</p> </li><li> <p>点击“<strong>浏览</strong>”按钮，然后从文件系统中选择你的 WSDL 文件。</p> </li><li> <p>选中 WSDL 文件后，服务引用的配置将在窗口下方显示出来。这里可以在下面的输入框，修改命名空间为你想要的名称，点击<strong>下一步</strong>，在新窗口中，可以<font color="#FF00FF">指定数据类型选项</font>，默认不需要改，点击“<strong>完成</strong>”。</p> </li><li> <p>此时，VS2022 会根据你的 WSDL 文件生成 Web 服务的代码，即：原Webservice服务的代理类。</p> </li><li> <p>还有一个生成Webservice服务代理类的方法：</p> 
  <ul><li>用wsdl.exe工具的方式</li><li>指令是：wsdl /language:c# /n:Fu /out:d:/MyService.cs C:\Users\Administrator\Desktop\MyService.wsdl） 
    <ul><li>“d:/MyService.cs”是输出目录</li><li>“C:\Users\Administrator\Desktop\MyService.wsdl”是源wsdl文件的位置</li></ul> </li><li>具体用法，可以使用<a href="https://cn.bing.com/" rel="nofollow">搜索引擎查询</a>，这里不再赘述。</li></ul> </li></ol> 
<h5><a id="WebService_30"></a>调用该WebService的方法</h5> 
<pre><code>		public static async Task TestCallWs()  
        {
            mydemo.TestMyClient serv = null;
            try
            {
                var binding = new BasicHttpBinding();
                var endpoint = new EndpointAddress(UrlString); // url地址
                serv = new mydemo.TestMyClient(binding, endpoint);
                var result = await serv.invokeAsync(ParamsString); // xml格式的字符串参数
                Console.WriteLine("返回接口数据：\n " + result);
                
            }
            catch(HttpRequestException e)
            {
                Console.WriteLine(e.Message);
            }
            finally
            {
                if (serv != null) 
                {
                    serv.Close();
                }
            }
        }
</code></pre> 
<hr> 
<h3><a id="span_idway22span_58"></a><span id="way2">实现方式2</span></h3> 
<blockquote> 
 <p>使用HttpClient</p> 
</blockquote> 
<h4><a id="_61"></a>简单做一下封装</h4> 
<pre><code>- 定义：WsClient
</code></pre> 
<pre><code>	public class WsClient
    {
        // 接口地址
        private string mUrl = string.Empty;
        // 请求参数
        private string mParam = string.Empty;

         namespace命名空间
        //private string ns = "http://XXX:xx/xx/xx"; // TODO填写上你需要的命名空间名称
        
         请求方法名
        //private string funName = string.Empty;

        public WsClient() 
        { 
            throw new NotImplementedException();
        }

        public WsClient(string url)
        {
            this.mUrl = url;
        }

        public async Task&lt;string&gt; Request(string param)
        {
            if (string.IsNullOrEmpty(mUrl))
            {
                return "接口地址为空！";
            }

            if (!mUrl.Contains("http"))
            {
                return "非法接口地址！";
            }

            if (string.IsNullOrEmpty(param))
            {
                return "请求参数为空！";
            }

            this.mParam = param;

            try
            {
                HttpClient httpClient = new();

                // soap参数
                string payload =
                    @"&lt;?xml version=""1.0""?&gt;  
                        &lt;soap:Envelope xmlns:soap=""http://schemas.xmlsoap.org/soap/envelope/""&gt;  
                            &lt;soap:Body&gt;  
                            &lt;invoke xmlns=""http://xxxxx.yyyyyyyy.com""&gt;  
                                &lt;xmlData&gt;" + mParam +
                           @"&lt;/xmlData&gt;  
                            &lt;/invoke&gt;  
                            &lt;/soap:Body&gt;  
                        &lt;/soap:Envelope&gt;";

                // 发送 SOAP 请求并获取响应  
                HttpResponseMessage response = await httpClient.PostAsync(mUrl, new StringContent(payload, Encoding.UTF8, "text/xml"));

                // 解析 SOAP 响应  
                string respStr = await response.Content.ReadAsStringAsync();
                return respStr;
            }
            catch (HttpRequestException e)
            {
                Console.WriteLine("WsClient -&gt; Request()异常 : {0} ", e.Message);
            }

            return "";
        }
    }

</code></pre> 
<p>调用方式：</p> 
<pre><code>string result = await new WsClient(wsUrl).Request(xmlData);
</code></pre> 
<p>wsUrl: 是你的Webservice接口地址；<br> xmlData: 是你拼装好协议里约定的xml格式的数据参数，示例如下：<br> result: 是请求接口，返回的数据，也是xml格式。</p> 
<pre><code>&lt;?xml version=""1.0"" encoding=""UTF-8""?&gt;
&lt;Request&gt;
    &lt;Name&gt;
        QueryUsers
    &lt;/Name&gt;
    &lt;Info&gt;
        &lt;ID&gt;21202012211211&lt;/ID&gt;
    &lt;/Info&gt;
&lt;/Request&gt;
</code></pre> 
<hr> 
<h3><a id="span_idway33__2span_159"></a><span id="way3">实现方式3 - 方式2的优化</span></h3> 
<h4><a id="_160"></a>来自朋友的优化版</h4> 
<pre><code>public class WsClient
{
    /// &lt;summary&gt;
    /// 声明 HttpClient
    /// &lt;/summary&gt;
    private HttpClient httpClient;

    /// &lt;summary&gt;
    /// 超时设定
    /// &lt;/summary&gt;
    private TimeSpan Timeout = new TimeSpan(0, 0, 15);


    #region 事件声明

    /// &lt;summary&gt;
    /// 接收消息事件通知
    /// &lt;/summary&gt;
    public event EventHandler&lt;RespBean&gt; RecvDataEvent;

    /// &lt;summary&gt;
    /// 请求响应异常事件通知
    /// &lt;/summary&gt;
    public event EventHandler&lt;ReqError&gt; RespErrorEvent;

    #endregion

    #region 单例

    private static readonly Lazy&lt;WsClient&gt; _instance = new Lazy&lt;WsClient&gt;(() =&gt; new WsClient());

    public static WsClient Instance
    {
        get { return _instance.Value; }
    }

    private WsClient()
    {
        if (httpClient == null)
        {
            httpClient = new HttpClient(new HttpClientHandler { UseCookies = false });
            httpClient.Timeout = Timeout;
        }
    }

    #endregion


    /// &lt;summary&gt;
    /// 生成SOAP协议
    /// &lt;/summary&gt;
    /// &lt;param name="reqData"&gt;&lt;/param&gt;
    /// &lt;returns&gt;完整SOAP协议,用于请求&lt;/returns&gt;
    private string GetSoapData(string reqData)
    {
        StringBuilder soapBuilder = new StringBuilder();
        soapBuilder.Append("&lt;?xml version=\"1.0\"?&gt;")
                   .Append("&lt;soap:Envelope xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt;")
                   .Append("&lt;soap:Body&gt;")
                   .AppendFormat("&lt;invoke xmlns=\"http://specialmap.chinamap.com\"&gt;&lt;data&gt;{0}&lt;/data&gt;&lt;/invoke&gt;", reqData)
                   .Append("&lt;/soap:Body&gt;")
                   .Append("&lt;/soap:Envelope&gt;");
        return soapBuilder.ToString();
    }

    /// &lt;summary&gt;
    /// Post 请求
    /// &lt;/summary&gt;
    /// &lt;param name="url"&gt;请求地址&lt;/param&gt;
    /// &lt;param name="data"&gt;请求数据体&lt;/param&gt;
    /// &lt;param name="header"&gt;请求头&lt;/param&gt;
    public async Task PostData(string url, string data, List&lt;KeyValuePair&lt;string, string&gt;&gt; headers = null)
    {
        StringContent content = new StringContent(data, Encoding.UTF8, "text/xml");

        if (headers != null &amp;&amp; headers.Count &gt; 0)
        {
            content.Headers.Clear();

            foreach (var header in headers)
            {
                content.Headers.Add(header.Key, header.Value);
            }
        }

        Uri uri = new Uri(url);

        try
        {
            HttpResponseMessage response = await httpClient.PostAsync(uri, content);

            if (response.StatusCode == HttpStatusCode.OK)
            {
                // 接收数据
                string soapStr = await response.Content.ReadAsStringAsync();

                

                // 实际的数据协议内容
                string realStr = GetNodeValue(soapStr, "return");

                // 具体的数据类
                BaseInfo baseInfo = DeserializeObject&lt;BaseInfo&gt;(realStr);

                if (baseInfo == null || baseInfo.Data == null)
                {
                    RespErrorEvent?.Invoke(this, new ReqError()
                    {
                        IpAddr = new IPEndPoint(IPAddress.Parse(uri.Host), uri.Port),
                        ErrorMsg = "协议解析失败"
                    });

                    return;
                }

                RecvDataEvent?.Invoke(this, new RespBean { Ip = url, Data = soapStr });

            }
            else // HTTP 响应错误
            {
                RespErrorEvent?.Invoke(this, new ReqError()
                {
                    IpAddr = new IPEndPoint(IPAddress.Parse(uri.Host), uri.Port),
                    ErrorMsg = $"响应错误 HttpCode={response.StatusCode}"
                });
            }
        }
        catch (TaskCanceledException ex)
        {
            RespErrorEvent?.Invoke(this, new ReqError()
            {
                IpAddr = new IPEndPoint(IPAddress.Parse(uri.Host), uri.Port),
                ErrorMsg = "请求超时"
            });
        }
        catch (Exception ex)
        {
            RespErrorEvent?.Invoke(this, new ReqError()
            {
                IpAddr = new IPEndPoint(IPAddress.Parse(uri.Host), uri.Port),
                ErrorMsg = "请求错误"
            });
        }
    }

    /// &lt;summary&gt;
    /// 发送 Http 请求数据
    /// &lt;/summary&gt;
    public void Request(string host, int port, string content)
    {
        Task.Run(async () =&gt;
        {
            string url = $"http://{host}:{port}/services/FSUService";
            string soapData = GetSoapData(content);
            await PostData(url, soapData);
        });
    }

    /// &lt;summary&gt;
    /// 从{xmlStr}中获取节点{nodeName}的值
    /// &lt;/summary&gt;
    public static string GetNodeValue(string xmlStr, string nodeName)
    {
        try
        {
            XDocument doc = XDocument.Parse(xmlStr);
            XElement element = doc.Descendants(nodeName).FirstOrDefault();
            return element != null ? element.Value : null;
        }
        catch (Exception)
        {
            throw;
        }

    }

    /// &lt;summary&gt;
    /// XML 反序列化
    /// &lt;/summary&gt;
    public static T DeserializeObject&lt;T&gt;(string xmlStr)
    {
        try
        {
            XmlSerializer xmlSerializer = new XmlSerializer(typeof(T));
            using (StringReader textReader = new StringReader(xmlStr))
            {
                return (T)xmlSerializer.Deserialize(textReader);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine("反序列化失败："+ex.Message);
            throw;
        }

    }
}

</code></pre> 
<p>调用方式：</p> 
<pre><code>// 1 监听事件
WsClient.Instance.RecvDataEvent+= Recv_DataEvent;
WsClient.Instance.RespErrorEvent+= Resp_ErrorEvent;

// 2 发送请求
WsClient.Instance.Request(ip, port, paramsXml);
</code></pre> 
<hr> 
<h3><a id="_372"></a>总结</h3> 
<ul><li>经过简单试验，<a href="#way3" rel="nofollow"><strong>方式3</strong></a> &gt; <a href="#way2" rel="nofollow"><strong>方式2</strong></a> &gt; <a href="#way1" rel="nofollow"><strong>方式1</strong></a>。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/21f3173443121602997ed5230bda1341/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【算法训练记录——Day41】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/215f2b83c84825fcce766d244440c3ad/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vscode运行java中文乱码，引发的mac配置问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>