<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Rust 跨平台-Android 和鸿蒙 OS - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/2845e9f0226b7d441c7867733e080c83/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Rust 跨平台-Android 和鸿蒙 OS">
  <meta property="og:description" content="1. 安装 rustup rustup 是 Rust 的安装和版本管理工具
$ curl --proto &#39;=https&#39; --tlsv1.2 https://sh.rustup.rs -sSf | sh 该命令会安装 rusup 和最新的稳定版本的 Rust；包括：
rustc Rust 编译器，用于将 Rust 代码编译成可执行文件或库。
cargo Rust 的包管理器和构建工具，用于管理项目依赖、编译项目、运行测试等。
rustfmt 代码格式化工具，用于自动格式化 Rust 代码以符合官方风格指南。
clippy 静态分析工具，用于捕捉常见错误和改进代码质量。
其他工具，如rustdoc用于生成文档等。
成功后控制台会输出：Rust is installed now. Great!
macOS 系统上需要安装：xcode-select --install
cargo 在开发中较为常用，算是打交道最多的工具之一
2. 标准库 Rust Standard Library 标准库是 Rust 编程语言的官方库，提供了一系列预先编写好的类型和函数，用来处理常见的任务，如：
基本数据类型（比如i32， u64， f32等）。
集合类型（如Vec&lt;T&gt;， HashMap&lt;K, V&gt;等）。
输入/输出（I/O）操作，包括文件操作和网络编程。
线程和并发编程工具。
其他有用的工具，如字符串处理、日期和时间操作等。
渠道 通常情况下安装 rustup 的时候，标准库就已经安装到本地；但是 rust 有几种发布渠道，用于提供不同稳定程度的 Rust 版本，Rust 的三个主要发布渠道是：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-27T16:11:46+08:00">
    <meta property="article:modified_time" content="2024-06-27T16:11:46+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Rust 跨平台-Android 和鸿蒙 OS</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><strong>1. 安装 </strong><strong><code>rustup</code></strong></h2> 
<p>rustup 是 Rust 的安装和版本管理工具</p> 
<div> 
 <pre><code class="language-bash">$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh</code></pre> 
</div> 
<p>该命令会安装 rusup 和最新的稳定版本的 Rust；包括：</p> 
<ul><li> <p><code>rustc</code> Rust 编译器，用于将 Rust 代码编译成可执行文件或库。</p> </li><li> <p><code>cargo</code> Rust 的包管理器和构建工具，用于管理项目依赖、编译项目、运行测试等。</p> </li><li> <p><code>rustfmt</code> 代码格式化工具，用于自动格式化 Rust 代码以符合官方风格指南。</p> </li><li> <p><code>clippy</code> 静态分析工具，用于捕捉常见错误和改进代码质量。</p> </li><li> <p>其他工具，如<code>rustdoc</code>用于生成文档等。</p> </li></ul> 
<p>成功后控制台会输出：<code>Rust is installed now. Great!</code></p> 
<p>macOS 系统上需要安装：<code>xcode-select --install</code></p> 
<p><strong>cargo</strong> 在开发中较为常用，算是打交道最多的工具之一</p> 
<p></p> 
<h2>2. 标准库 Rust Standard Library</h2> 
<p>标准库是 Rust 编程语言的官方库，提供了一系列预先编写好的类型和函数，用来处理常见的任务，如：</p> 
<ol><li> <p>基本数据类型（比如<code>i32</code>， <code>u64</code>， <code>f32</code>等）。</p> </li><li> <p>集合类型（如<code>Vec&lt;T&gt;</code>， <code>HashMap&lt;K, V&gt;</code>等）。</p> </li><li> <p>输入/输出（I/O）操作，包括文件操作和网络编程。</p> </li><li> <p>线程和并发编程工具。</p> </li><li> <p>其他有用的工具，如字符串处理、日期和时间操作等。</p> </li></ol> 
<h3>渠道</h3> 
<p>通常情况下安装 rustup 的时候，标准库就已经安装到本地；但是 rust 有几种发布渠道，用于提供不同稳定程度的 Rust 版本，Rust 的三个主要发布渠道是：</p> 
<ol><li> <p><strong>Stable（稳定版）</strong>：这是大多数用户推荐使用的版本。它每六周发布一次，提供最新的功能和改进，但只包括那些经过充分测试和认为稳定的特性。</p> </li><li> <p><strong>Beta（测试版）</strong>：这个版本比 Stable 新，但可能包含一些即将纳入下一个 Stable 版本的特性和改进。它主要用于测试即将发布的功能，以确保它们在正式成为稳定版之前没有问题。</p> </li><li> <p><strong>Nightly（每夜构建版）</strong>：这是最前沿的版本，包括了所有最新开发的特性。这些特性可能未完全稳定或待评估，因此这个版本主要用于实验和评估最新的语言改进。Nightly 版本，顾名思义，每夜更新一次，包括最新的代码提交。</p> </li></ol> 
<h3>安装</h3> 
<ul><li> <p>列出已安装的版本</p> </li></ul> 
<pre><code class="hljs">rustup toolchain list</code></pre> 
<ul><li> <p>安装新的版本</p> </li></ul> 
<pre><code class="hljs">rustup toolchain install beta</code></pre> 
<p>或者</p> 
<pre><code class="hljs">rustup toolchain install nightly</code></pre> 
<h3>切换版本</h3> 
<p>切换全局（即默认）Rust 版本，使用<code>rustup default</code>命令：</p> 
<pre><code class="hljs">rustup default stable
rustup default beta
rustup default nightly</code></pre> 
<p>这些命令会将你的系统默认 Rust 版本切换为相应的版本。</p> 
<h3>为<strong>特定</strong><strong>项目</strong><strong>切换版本</strong></h3> 
<p>如果你只想为特定的项目切换 Rust 版本，而不影响全局设置，可以在项目目录内使用以下命令设置目录级别的默认版本：</p> 
<pre><code class="hljs">rustup override set stable
rustup override set beta
rustup override set nightly</code></pre> 
<h3>补装标准库源码</h3> 
<pre><code class="hljs">rustup component add rust-src</code></pre> 
<blockquote> 
 <p>每一个 toolchain 都有自己的源码</p> 
 <p>建议安装 stable 和 nightly 的源码，因为只有 nightly 版本支持编译鸿蒙系统</p> 
 <p>如果不安装后续鸿蒙 OS 下编译会报错，根据提示安装也行</p> 
</blockquote> 
<p></p> 
<h3>为特定目标平台编译代码</h3> 
<p>在 stable 下，rust 支持 android 平台的编译，通过 <code>rustup target list |grep android</code> 可以查看支持的所有平台架构</p> 
<pre><code class="hljs">% rustup target list |grep android                                                                                                                                                    24-03-19 - 15:46:34
aarch64-linux-android (installed)
arm-linux-androideabi (installed)
armv7-linux-androideabi (installed)
i686-linux-android (installed)
thumbv7neon-linux-androideabi (installed)
x86_64-linux-android (installed)</code></pre> 
<p>如果已安装，后面会有 （installed） 标识；建议一次性都安装上：</p> 
<pre><code class="hljs">rustup target add aarch64-linux-android arm-linux-androideabi armv7-linux-androideabi i686-linux-android thumbv7neon-linux-androideabi x86_64-linux-android</code></pre> 
<p>鸿蒙 OS 下需要切换到 nightly，通过 <code>rustup target list |grep ohos</code> 可以查看支持的所有平台架构：</p> 
<pre><code class="hljs">% rustup target list |grep ohos                                                         
aarch64-unknown-linux-ohos (installed)
armv7-unknown-linux-ohos (installed)
x86_64-unknown-linux-ohos (installed)</code></pre> 
<p>同样，建议一次性都安装上</p> 
<p></p> 
<h2>3. 创建 Rust Library 工程</h2> 
<p>使用命令行创建：</p> 
<pre><code class="hljs">cargo new demo --lib</code></pre> 
<p>或者使用 IDE，推荐使用 Jetbrains 的 RustRover</p> 
<p><img alt="" height="366" src="https://images2.imgbox.com/b2/ae/32XaQXPd_o.png" width="596"></p> 
<p>此时目录结构如下：</p> 
<pre><code class="hljs">demo
├── Cargo.toml
└── src
    └── lib.rs</code></pre> 
<h3>Cargo.toml 的配置</h3> 
<p><strong>[lib]</strong></p> 
<pre><code class="hljs">[lib]
crate-type = ["cdylib"]</code></pre> 
<p><code>crate-type</code>属性用于指定编译目标类型。这些类型决定了编译器会如何编译你的代码。以下是一些常见的<code>crate-type</code>值及其区别：</p> 
<p><strong>1.</strong> <strong><code>bin</code></strong></p> 
<ul><li> <p><strong>描述</strong>：一个可执行的二进制文件。</p> </li><li> <p><strong>使用</strong><strong>场景</strong>：当你想要创建一个可以直接运行的程序时，使用此类型。大多数应用程序都是以<code>bin</code>类型编译的。</p> </li></ul> 
<p><strong>2.</strong> <strong><code>lib</code></strong></p> 
<ul><li> <p><strong>描述</strong>：一个库文件，可以被其他 Rust 包作为依赖使用。</p> </li><li> <p><strong>使用</strong><strong>场景</strong>：如果你正在开发一个提供函数、类型或特性给其他包使用的库，应选择此类型。</p> </li></ul> 
<p><strong>3.</strong> <strong><code>rlib</code></strong></p> 
<ul><li> <p><strong>描述</strong>：Rust 编译的库文件，包含元数据和符号，供后续的 Rust 编译阶段使用。</p> </li><li> <p><strong>使用</strong><strong>场景</strong>：当你想要编译一个 Rust 库供其他 Rust 项目使用，并期望进行链接和代码生成优化时。</p> </li></ul> 
<p><strong>4.</strong> <strong><code>dylib</code></strong></p> 
<ul><li> <p><strong>描述</strong>：一个动态链接库（DLL），可以在运行时被 Rust 或其他语言的应用程序动态链接。</p> </li><li> <p><strong>使用</strong><strong>场景</strong>：当你想要创建一个可以被多个程序共享的库，或者当你需要和其他使用动态链接的语言互操作时。</p> </li></ul> 
<p><strong>5.</strong> <strong><code>cdylib</code></strong></p> 
<ul><li> <p><strong>描述</strong>：一个为 C 语言接口定制的动态链接库。它移除了 Rust 特有的元数据，只保留了可以从 C 或其他语言调用的符号。</p> </li><li> <p><strong>使用</strong><strong>场景</strong>：当你开发一个 Rust 库，希望能够被 C 或其他语言作为动态链接库使用时。这是创建跨语言共享库的常见方式。</p> </li></ul> 
<p><strong>6.</strong> <strong><code>staticlib</code></strong></p> 
<ul><li> <p><strong>描述</strong>：静态库（<code>.a</code>文件），可以被 C 语言或其他语言的应用程序在编译时静态链接。</p> </li><li> <p><strong>使用场景</strong>：如果你想要创建一个可以被其他语言静态链接的库，或希望你的 Rust 代码被编译进一个单独的二进制文件，而不依赖于 Rust 的运行时或其他动态库。</p> </li></ul> 
<p><strong>7.</strong> <strong><code>proc-macro</code></strong></p> 
<ul><li> <p><strong>描述</strong>：一个过程宏库，用于创建自定义<code>#[derive]</code>宏或其他类型的宏。</p> </li><li> <p><strong>使用场景</strong>：当你想要创建新的宏来扩展 Rust 语法，比如自定义派生属性或宏指令时。</p> </li></ul> 
<p></p> 
<p><strong>[dependencies] 和 [features]</strong></p> 
<p>由于需要区分 android 和 ohos 两个平台的特定库，所以有一些依赖库需要配置为可选的，然后使用 <code>cargo</code> 构建的时候添加 <code>--features</code> 参数来分别进行交叉编译</p> 
<blockquote> 
 <p>对于 android 平台，需要引入 jni 库，来和 java/kotlin 互相调用</p> 
 <p><code>rust</code> 和 <code>node</code> 互相调用可以使用 <code>node-bindgen</code>，但遗憾的是，<code>node-bindgen</code>并不兼容鸿蒙系统；不过已经有人基于<code>node-bindgen</code>兼容了 ohos：https://crates.io/crates/ohos-node-bindgen</p> 
 <p>对于 <code>ohos</code> 平台，需要引入 <code>ohos-node-bindgen</code> 库，来和 <code>node</code> 通信；由于 <code>ohos-node-bindgen</code> 依赖 <code>socket2</code>，然而 <code>socket2</code> 在 <code>ohos</code> 下有 <code>bug</code>，所以这里需要使用<code>https://github.com/stuartZhang/socket2.git</code><code> </code>来替换 <code>ohos-node-bindgen</code> 内部依赖的<code>socket2</code>版本</p> 
</blockquote> 
<p>最终配置如下</p> 
<pre><code class="hljs">[features]
default = ["android"]
android = ["dep:jni", "dep:android_logger"]
ohos = ["dep:ohos-node-bindgen", "dep:socket2"]

[dependencies]
jni = { version = "0.19.0", optional = true }
android_logger = { version = "0.13.3", optional = true }
ohos-node-bindgen = { version = "6.0.3", optional = true }
socket2 = { version = "0.4.10", optional = true }
dashmap = "5.5.3"
threadpool = "1.8.1"
log = "0.4.21"

[patch.crates-io]
socket2 = { version = "0.4.10", git = "https://github.com/stuartZhang/socket2.git", branch = "v0.4.x" }</code></pre> 
<p>也就是说：</p> 
<ul><li> <p><code>dashmap</code>、<code>threadpool</code> 和 <code>log</code> 是所有平台下都参与编译的库</p> </li><li> <p><code>android</code> 单独编译：<code>jni</code> 和 <code>android_logger</code></p> </li><li> <p><code>ohos</code> 单独编译：<code>ohos-node-bindgen</code> 和 <code>socket2</code></p> </li><li> <p>另外，<code>features</code> 的默认值为 <code>android</code></p> </li></ul> 
<p></p> 
<h3>编写代码 - lib.rs</h3> 
<p>由于存在不同的 features，所以对于 android：</p> 
<pre><code class="hljs">#[cfg(feature = "android")]
#[no_mangle]
pub extern "system" fn Java_com_haier_uhome_uplus_hook_monitor_app_NativeLib_hello(
    env: JNIEnv,
    _class: JClass,
) -&gt; jstring {
    // 将 Rust 字符串转换为 JNI 字符串
    let result = env.new_string("Hello from Rust!").expect("Couldn't create Java string!");
    // 返回结果
    result.into_inner()
}</code></pre> 
<p><code>#[cfg(feature = "android")]</code>：与上述 <code>features</code> 对应</p> 
<p><code>#[no_mangle]</code> 则是禁用驼峰警告</p> 
<p>对于 ohos：</p> 
<pre><code class="hljs">#[cfg(feature = "ohos")]
#[ohos_node_bindgen]
pub extern "C" fn add(l: i32, r: i32) -&gt; i32 {
    l + r
}</code></pre> 
<p><code>#[cfg(feature = "ohos")]</code>：与上述 <code>features</code> 对应</p> 
<p><code>#[ohos_node_bindgen]</code> 则是标识 add 函数可以被 node 端调用</p> 
<blockquote> 
 <p>node-bindgen 的大致原理如下：</p> 
 <p><strong>1. FFI（外部函数接口）</strong></p> 
 <p>Node.js 的原生模块基于 C++ 和 Node.js 的 N-API（原生 API），N-API 提供了一套与 V8 引擎解耦的接口，使原生模块在 Node.js 版本升级时保持兼容。<code>node-bindgen</code> 底层利用 Rust 的外部函数接口（FFI）能力，通过这些接口与 Node.js 通信。</p> 
 <p>Rust 的 FFI 功能允许其调用 C 语言 API。因此，<code>node-bindgen</code> 实际上是通过 Rust 的 FFI 调用 Node.js 的 N-API 来创建和管理 JavaScript 值，以及执行与 JavaScript 环境的交互。</p> 
 <p><strong>2. 宏和属性</strong></p> 
 <p><code>node-bindgen</code> 提供了一系列宏（例如 <code>#[node_bindgen]</code>），这些宏在编译时自动生成将 Rust 函数暴露为 Node.js 可调用函数的胶水代码。这个过程包括自动生成用于参数转换和返回值处理的代码，使 Rust 函数能够直接接收来自 JavaScript 的参数并返回可以直接在 JavaScript 中使用的结果。</p> 
 <p><strong>3. 内存管理</strong></p> 
 <p>Rust 和 JavaScript 之间的内存管理是 <code>node-bindgen</code> 的关键部分。Rust 有自己的内存管理规则，主要基于所有权和生命周期，而 JavaScript 的内存则由垃圾收集器自动管理。<code>node-bindgen</code> 必须确保在这两种内存管理模型之间正确地桥接，包括处理 Rust 中的数据所有权转移和确保 JavaScript 对象在需要时保持存活。</p> 
 <p><strong>4. 异步操作</strong></p> 
 <p>Node.js 广泛使用异步操作，而 Rust 也有强大的异步支持。<code>node-bindgen</code> 支持将 Rust 的异步操作暴露给 Node.js。这通过将 Rust 的 <code>Future</code> 转换为 Node.js 的 <code>Promise</code> 来实现。<code>node-bindgen</code> 会自动处理这种转换，允许开发者以 Promise 的形式在 JavaScript 中接收 Rust 异步操作的结果。</p> 
 <p><strong>5. 类型转换</strong></p> 
 <p><code>node-bindgen</code> 自动处理 Rust 类型和 JavaScript 类型之间的转换。对于简单类型（如数字和字符串），这通常是直接的。但对于复杂类型（如结构体或枚举），<code>node-bindgen</code> 生成的代码会负责序列化和反序列化操作，确保两种语言之间可以无缝交换复杂数据结构。</p> 
 <p style="background-color:transparent;"><strong>总结</strong></p> 
 <p><code>node-bindgen</code> 利用 Rust 的 FFI 能力、宏系统、强类型系统和异步特性，提供了一种高效、类型安全的方式来将 Rust 代码与 Node.js 集成。它自动处理大部分繁琐的胶水代码编写工作，使得 Rust 和 Node.js 之间的交互变得更加简单直接。这样的设计允许开发者专注于实现应用逻辑，而无需深入底层的语言绑定细节。理解颇为浅陋，如有任何问题可私 1239604859@qq.com 讨论</p> 
</blockquote> 
<h3>编译 - android 平台的产物</h3> 
<p>官方提供了 <code>cargo-ndk</code> 工具，它简化了为 Android 使用 Rust 编写原生代码库（.so 文件）的过程。</p> 
<ul><li> <p>下载安卓 NDK，并配置到环境变量</p> </li></ul> 
<pre><code class="hljs">export ANDROID_HOME=$HOME/ssd/Android/sdk
PATH="$ANDROID_HOME/ndk-bundle:$PATH"
export PATH</code></pre> 
<ul><li> <p>安装 cargo-ndk</p> </li></ul> 
<pre><code class="hljs">cargo install cargo-ndk</code></pre> 
<ul><li> <p><strong>使用</strong> <strong><code>cargo-ndk</code></strong> <strong>构建你的</strong><strong>项目</strong></p> </li></ul> 
<pre><code class="hljs">cargo ndk -t armv7-linux-androideabi -t aarch64-linux-android -o ../../MonitorTestClient/app/src/main/jniLibs build --release</code></pre> 
<ul><li> <p>参数解释</p> 
  <ul><li> <p><code>-t</code> 或 <code>--target</code>：指定目标架构</p> </li><li> <p><code>-o</code> 或 <code>--output</code>：指定输出目录，这里的目录会用于存放编译生成的 <code>.so</code> 文件</p> </li><li> <p><code>build</code>：是 <code>cargo</code> 的子命令，用于编译项目，会传递它以及任何附加参数给 <code>cargo build</code></p> </li></ul></li></ul> 
<p></p> 
<h3>编译 - ohos 平台的产物</h3> 
<p>官方没有为鸿蒙系统提供类似<code>cargo-ndk</code>的工具，需要手动配置编译参数</p> 
<p>1. 首先切换到 nightly 渠道</p> 
<pre><code class="hljs">rustup override set nightly</code></pre> 
<p>2. 配置环境变量：</p> 
<pre><code class="hljs"># huawei
export OHOS_HOME=$HOME/ssd/huawei/sdk
export OHOS_API_V=9
export OHOS_CORE_V=3.1.0
export OH_NDK_ROOT=$OHOS_HOME/openharmony/$OHOS_API_V/native
PATH="$OHOS_HOME/hmscore/$OHOS_CORE_V/toolchains:$PATH"
export PATH</code></pre> 
<p>单独配置 <code>OHOS_API_V</code> 的好处是如果华为更新了 <code>Native SDK</code>，可以更方便的动态切换</p> 
<p>3. 创建 ohos 对应 target 的可执行脚本，例如和<code>config.toml</code>中 [target.aarch64-unknown-linux-ohos] 对应</p> 
<ul><li> <p>创建位置：<code>~/.cargo</code></p> </li><li> <p>aarch64-unknown-linux-ohos-clang.sh</p> </li></ul> 
<pre><code class="hljs">#!/bin/sh
. $HOME/.bash_profile
exec $OH_NDK_ROOT/llvm/bin/clang \
  -target aarch64-linux-ohos \
  --sysroot=$OH_NDK_ROOT/sysroot \
  -D__MUSL__ \
  "$@"</code></pre> 
<ul><li> <p>armv7-unknown-linux-ohos-clang.sh</p> </li></ul> 
<pre><code class="hljs">#!/bin/sh
. $HOME/.bash_profile
exec $OH_NDK_ROOT/llvm/bin/clang \
  -target arm-linux-ohos \
  --sysroot=$OH_NDK_ROOT/sysroot \
  -D__MUSL__ \
  -march=armv7-a \
  -mfloat-abi=softfp \
  -mtune=generic-armv7-a \
  -mthumb \
  "$@"</code></pre> 
<ul><li> <p>x86_64-unknown-linux-ohos-clang.sh</p> </li></ul> 
<pre><code class="hljs">#!/bin/sh
. $HOME/.bash_profile
exec $OH_NDK_ROOT/llvm/bin/clang \
  -target x86_64-linux-ohos \
  --sysroot=$OH_NDK_ROOT/sysroot \
  -D__MUSL__ \
  "$@"</code></pre> 
<ul><li> <p><code>. $HOME/.bash_profile</code> 根据实际情况进行修改，只要能拿到 <code>$OH_NDK_ROOT</code> 即可</p> </li></ul> 
<p>4. 通用配置：<code>config.toml</code></p> 
<ul><li> <p>创建位置：<code>~/.cargo</code></p> </li></ul> 
<pre><code class="hljs"># 鸿蒙编译工具链-目前只能手动配置:
[target.aarch64-unknown-linux-ohos]
linker = ".cargo/aarch64-unknown-linux-ohos-clang.sh"

[target.armv7-unknown-linux-ohos]
linker = ".cargo/armv7-unknown-linux-ohos-clang.sh"

[target.x86_64-unknown-linux-ohos]
linker = ".cargo/x86_64-unknown-linux-ohos-clang.sh"

# 会概率性地失败于exit code: 0xc0000005, STATUS_ACCESS_VIOLATION错误 - https://rustcc.cn/article?id=568d35d6-b782-49e9-b9b1-5d870d28f927
[profile.dev.package.compiler_builtins]
opt-level = 2

[alias]
ohos-build = ["build", "-Zbuild-std", "--target=aarch64-unknown-linux-ohos", "--target=armv7-unknown-linux-ohos", "--target=x86_64-unknown-linux-ohos"]</code></pre> 
<ul><li> <p><code>[alias]</code> 作用是使得：</p> <p>    <code>cargo ohos-build --release</code> 等价于 <code>cargo build -Zbuild-std --target=aarch64-unknown-linux-ohos --target=armv7-unknown-linux-ohos --target=x86_64-unknown-linux-ohos --release</code></p> </li><li> <p>对于我们演示的 demo 工程，最终编译命令行如下</p> </li></ul> 
<pre><code class="hljs">cargo ohos-build --release --features ohos</code></pre> 
<p></p> 
<h2>4. Android 工程测试 rust 产物</h2> 
<p>把动态库拷贝到 app 模块中</p> 
<pre><code class="hljs">src
├── androidTest
├── main
│   ├── jniLibs
│   │   ├── arm64-v8a
│   │   │   └── libdemo.so
│   │   └── armeabi-v7a
│   │       └── libdemo.so</code></pre> 
<p>创建对应包名的单例</p> 
<pre><code class="language-Kotlin">object NativeLib {
  init {
    System.loadLibrary("demo")
  }

  external fun hello(): String

  external fun mapTest()
}</code></pre> 
<p>在 MainActivity 中调用</p> 
<pre><code class="language-Kotlin">val nstr = NativeLib.hello()
Log.d(TAG, "onCreate: $nstr")</code></pre> 
<pre><code class="language-Kotlin">2024-03-19 19:32:32.207 11941-11941 MainActivity             D  onCreate: Hello from Rust!</code></pre> 
<h3></h3> 
<h2>5. ohos 工程测试 rust 产物</h2> 
<p>把动态库拷贝到 entry 模块中</p> 
<pre><code class="language-Kotlin">entry
├── build-profile.json5
├── hvigorfile.ts
├── libs
│   ├── arm64-v8a
│   │   └── libdemo.so
│   └── armeabi-v7a
│       └── libdemo.so</code></pre> 
<p>在 Index.ets 中</p> 
<pre><code class="language-TypeScript">import hello from "libdemo.so"

@Entry
@Component
struct Index {
  @State message: string = 'Hello World';

  build() {
    Row() {
      Column() {
        Text(this.message)
          .fontSize(50)
          .fontWeight(FontWeight.Bold)
        Button("计 算")
          .fontSize(50)
          .fontWeight(FontWeight.Bold)
          .onClick(() =&gt; {
            let sum = hello.add(3, 5);
            this.message = "3 + 5 = " + sum.toString();
          })
      }
      .width('100%')
    }
    .height('100%')
  }
}</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="478" src="https://images2.imgbox.com/5e/a7/YhdS5qV1_o.png" width="225">      <img alt="" height="477" src="https://images2.imgbox.com/83/a3/mpTy3xoV_o.png" width="225"></p> 
<p></p> 
<h2>6. 团队介绍</h2> 
<p>「<strong>三翼鸟数字化技术平台</strong><strong>-</strong><strong>智家APP</strong><strong>平台</strong>」通过持续迭代演进移动端一站式接入平台为三翼鸟APP、智家APP等多个APP提供基础运行框架、系统通用能力API、日志、网络访问、页面路由、动态化框架、UI组件库等移动端开发通用基础设施；通过Z·ONE平台为三翼鸟子领域提供项目管理和技术实践支撑能力，完成从代码托管、CI/CD系统、业务发布、线上实时监控等Devops与工程效能基础设施搭建。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0705cd48590111b4bd4a341cd6409145/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【MySQL基础篇】概述及SQL指令：DDL及DML</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7bc6d62a12f853bd5cc7d88e21ab016c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">高性能Web服务器-Nginx的常用模块</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>