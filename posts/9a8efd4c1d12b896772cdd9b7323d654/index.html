<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>string类简单模拟实现 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/9a8efd4c1d12b896772cdd9b7323d654/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="string类简单模拟实现">
  <meta property="og:description" content="目录
1. string成员变量
2. string的成员函数
(1). 构造函数和析构函数
(2). string的访问
① 范围for访问
②下标访问
(3). string的修改
① 函数重载&#43;=
② push_back与append的实现
③ insert的实现
④ erase与clear的实现
⑤ 交换函数
(4). string的查找
(5). string的流插入与流提取的重载
(6). 其他一些操作
① 比较
② substr
③ 赋值运算符重载
3. 源代码
(1). 头文件
(2). 实现功能的
我们实现string将其封装到一个namespace(命名空间中)
1. string成员变量 我们在使用string的时候发现它存储字符串，并且可以动态增加容量，于是我们用_str 来存储字符串，用_size来记录它存储的字符个数，用_capacity来记录容量
此外我们还实现了一个静态变量 npos
#pragma once #include&lt;iostream&gt; #include&lt;assert.h&gt; #include&lt;cstring&gt; using std::cout; using std::cin; using std::endl; using std::istream; using std::ostream; namespace Pc { class string { public: //static const size_t npos = -1; static const size_t npos ; .">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-31T22:21:49+08:00">
    <meta property="article:modified_time" content="2024-07-31T22:21:49+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">string类简单模拟实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/54/a7/pltvqUci_o.gif"></p> 
<p><strong>目录</strong></p> 
<p id="1.%20string%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-toc" style="margin-left:120px;"><a href="#1.%20string%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F" rel="nofollow">1. string成员变量</a></p> 
<p id="2.%20string%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-toc" style="margin-left:120px;"><a href="#2.%20string%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0" rel="nofollow">2. string的成员函数</a></p> 
<p id="(1).%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-toc" style="margin-left:160px;"><a href="#%281%29.%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0" rel="nofollow">(1). 构造函数和析构函数</a></p> 
<p id="(2).%20string%E7%9A%84%E8%AE%BF%E9%97%AE-toc" style="margin-left:160px;"><a href="#%282%29.%20string%E7%9A%84%E8%AE%BF%E9%97%AE" rel="nofollow">(2). string的访问</a></p> 
<p id="%E2%91%A0%20%E8%8C%83%E5%9B%B4for%E8%AE%BF%E9%97%AE-toc" style="margin-left:200px;"><a href="#%E2%91%A0%20%E8%8C%83%E5%9B%B4for%E8%AE%BF%E9%97%AE" rel="nofollow">① 范围for访问</a></p> 
<p id="%E2%91%A1%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE-toc" style="margin-left:200px;"><a href="#%E2%91%A1%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE" rel="nofollow">②下标访问</a></p> 
<p id="(3).%20string%E7%9A%84%E4%BF%AE%E6%94%B9-toc" style="margin-left:160px;"><a href="#%283%29.%20string%E7%9A%84%E4%BF%AE%E6%94%B9" rel="nofollow">(3). string的修改</a></p> 
<p id="%E2%91%A0%20%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%2B%3D-toc" style="margin-left:200px;"><a href="#%E2%91%A0%20%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%2B%3D" rel="nofollow">① 函数重载+=</a></p> 
<p id="%E2%91%A1%20push_back%E4%B8%8Eappend%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:200px;"><a href="#%E2%91%A1%20push_back%E4%B8%8Eappend%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">② push_back与append的实现</a></p> 
<p id="%E2%91%A2%20insert%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:200px;"><a href="#%E2%91%A2%20insert%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">③ insert的实现</a></p> 
<p id="%E2%91%A3%20erase%E4%B8%8Eclear%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:200px;"><a href="#%E2%91%A3%20erase%E4%B8%8Eclear%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">④ erase与clear的实现</a></p> 
<p id="%E2%91%A4%20%E4%BA%A4%E6%8D%A2%E5%87%BD%E6%95%B0-toc" style="margin-left:200px;"><a href="#%E2%91%A4%20%E4%BA%A4%E6%8D%A2%E5%87%BD%E6%95%B0" rel="nofollow">⑤ 交换函数</a></p> 
<p id="(4).%20string%E7%9A%84%E6%9F%A5%E6%89%BE-toc" style="margin-left:160px;"><a href="#%284%29.%20string%E7%9A%84%E6%9F%A5%E6%89%BE" rel="nofollow">(4). string的查找</a></p> 
<p id="(5).%C2%A0%20string%E7%9A%84%E6%B5%81%E6%8F%92%E5%85%A5%E4%B8%8E%E6%B5%81%E6%8F%90%E5%8F%96%E7%9A%84%E9%87%8D%E8%BD%BD-toc" style="margin-left:160px;"><a href="#%285%29.%C2%A0%20string%E7%9A%84%E6%B5%81%E6%8F%92%E5%85%A5%E4%B8%8E%E6%B5%81%E6%8F%90%E5%8F%96%E7%9A%84%E9%87%8D%E8%BD%BD" rel="nofollow">(5).  string的流插入与流提取的重载</a></p> 
<p id="(6).%20%E5%85%B6%E4%BB%96%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C-toc" style="margin-left:160px;"><a href="#%286%29.%20%E5%85%B6%E4%BB%96%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C" rel="nofollow">(6). 其他一些操作</a></p> 
<p id="%E2%91%A0%20%E6%AF%94%E8%BE%83-toc" style="margin-left:200px;"><a href="#%E2%91%A0%20%E6%AF%94%E8%BE%83" rel="nofollow">① 比较</a></p> 
<p id="%E2%91%A1%20substr-toc" style="margin-left:200px;"><a href="#%E2%91%A1%20substr" rel="nofollow">② substr</a></p> 
<p id="%E2%91%A2%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-toc" style="margin-left:200px;"><a href="#%E2%91%A2%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD" rel="nofollow">③ 赋值运算符重载</a></p> 
<p id="3.%20%E6%BA%90%E4%BB%A3%E7%A0%81-toc" style="margin-left:120px;"><a href="#3.%20%E6%BA%90%E4%BB%A3%E7%A0%81" rel="nofollow">3. 源代码</a></p> 
<p id="(1).%20%E5%A4%B4%E6%96%87%E4%BB%B6-toc" style="margin-left:200px;"><a href="#%281%29.%20%E5%A4%B4%E6%96%87%E4%BB%B6" rel="nofollow">(1). 头文件</a></p> 
<p id="(2).%20%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD%E7%9A%84-toc" style="margin-left:200px;"><a href="#%282%29.%20%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD%E7%9A%84" rel="nofollow">(2). 实现功能的</a></p> 
<hr id="hr-toc"> 
<p></p> 
<blockquote> 
 <p>我们实现string将其封装到一个namespace(命名空间中)</p> 
</blockquote> 
<h5 id="1.%20string%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">1. string成员变量</h5> 
<p>我们在使用string的时候发现它存储字符串，并且可以动态增加容量，于是我们用_str 来存储字符串，用_size来记录它存储的字符个数，用_capacity来记录容量</p> 
<p>此外我们还实现了一个静态变量 npos</p> 
<pre><code class="language-cpp">#pragma once
#include&lt;iostream&gt;
#include&lt;assert.h&gt;
#include&lt;cstring&gt;
using std::cout;
using std::cin;
using std::endl;
using std::istream;
using std::ostream;
namespace Pc
{
	class string
	{
	public:
        //static const size_t npos = -1;
		static const size_t npos ;
        ........
	private:
		char* _str;
		size_t _size;
		size_t _capacity;
	};
}
</code></pre> 
<p><span style="background-color:#ffd900;">静态变量是类内声明，类外定义</span>。但<strong>这个在类内也可以直接赋值</strong>如上注释代码。此为个例，我在此处仍然在另一个文件(同名namespace)定义</p> 
<h5 id="2.%20string%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">2. string的成员函数</h5> 
<h6 id="(1).%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0" style="background-color:transparent;">(1). 构造函数和析构函数</h6> 
<p>实现之前先<strong>在类里实现</strong>三个函数来获取取的成员变量的值</p> 
<pre><code class="language-cpp">		const char* c_str() const
		{
			return _str;
		}

		size_t size() const
		{
			return _size;
		}
		size_t capacity() const
		{
			return _capacity;
		}</code></pre> 
<p>我们实现的三个构造函数和一个析构函数</p> 
<pre><code class="language-cpp">#pragma once
#include&lt;iostream&gt;
#include&lt;assert.h&gt;
#include&lt;cstring&gt;
using std::cout;
using std::cin;
using std::endl;
using std::istream;
using std::ostream;
namespace Pc
{
	class string
	{
	public:
		string()
			:_str(new char[5])//_caoacity不包含\0
			,_size(0)
			,_capacity(4)
		{
			_str[0] = '\0';
		}
		string(const char* str)
			:_str(new char [strlen(str) + 1])
			//_caoacity不包含\0
			, _size(strlen(str))
			, _capacity(strlen(str))
		{
			strcpy(_str, str);
		}
		string(const string&amp; s1)
			:_str(new char [s1.capacity()+1])
			, _size(s1.size())
			, _capacity(s1.capacity())
		{
			strcpy(_str, s1.c_str());
		}
		~string()
		{
			delete[] _str;//str是nullptr也没问题
			_str = nullptr;
			_size = _capacity = 0;
		}
	private:
		char* _str;
		size_t _size;
		size_t _capacity;
	};

}
</code></pre> 
<p>上面的默认构造函数我们开5个空间容量就为4，因为_capacity中不包括'\0' 所以实际开的要多一个。</p> 
<p>通过字符串构造的string只需要用strlen将字符串的长记录下来赋值就可以了。</p> 
<p>拷贝构造函数可以用过我们上面实现的成员函数来访问s1.的各个成员变量的值</p> 
<p>析构函数直接将new的空间delete掉，将指针指向空即可。</p> 
<h6 id="(2).%20string%E7%9A%84%E8%AE%BF%E9%97%AE">(2). string的访问</h6> 
<h6 id="%E2%91%A0%20%E8%8C%83%E5%9B%B4for%E8%AE%BF%E9%97%AE">① 范围for访问</h6> 
<p><span style="background-color:#ffd900;">范围for底层实际是通过迭代器实现的</span>，所以将迭代器实现出来就可以使用范围for了</p> 
<p>这里实现一个简易版的范围for</p> 
<pre><code class="language-cpp">		typedef char* iterator;
		typedef char* const_iterator;
		//实现迭代器
		iterator begin()
		{
			return _str;
		}
		iterator end()
		{
			return _str + _size;
		}
		const_iterator begin() const
		{
			return _str;
		}
		const_iterator end() const
		{
			return _str + _size;
		}</code></pre> 
<p>由于string中<em><span style="background-color:#ed7976;">iterator</span></em>就是一个指针所以我们这里将char* typedef一下用来模拟实现</p> 
<h6 id="%E2%91%A1%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE">②下标访问</h6> 
<p>即重载 [] 使其接收一个下标，返回对应位置的字符，引用返回减少消耗，与可读写，只读两种接口</p> 
<pre><code class="language-cpp">		char&amp; operator[](size_t pos)
		{
			assert(pos &lt; _size);
			return _str[pos];
		}
		const char&amp; operator[](size_t pos) const
		{
			assert(pos &lt; _size);
			return _str[pos];
		}</code></pre> 
<h6 id="(3).%20string%E7%9A%84%E4%BF%AE%E6%94%B9" style="background-color:transparent;">(3). string的修改</h6> 
<blockquote> 
 <p>我们先实现一个扩容的函数reserve，用来减少代码量</p> 
 <p>这些都从类外实现所以需要域作用限定符</p> 
</blockquote> 
<pre><code class="language-cpp">	void string::reserve(size_t n)
	{
		if (n &gt; _capacity)
		{
			char* tmp = new char[ n + 1];
			strcpy(tmp, _str);
			delete[] _str;
			_str = tmp;
			_capacity = n;
		}
	}</code></pre> 
<h6 id="%E2%91%A0%20%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%2B%3D">① 函数重载+=</h6> 
<p>由于会+=字符或+=字符串所以进行函数重载，实现时注意越界问题</p> 
<pre><code class="language-cpp">	string&amp; string::operator+=(char ch)
	{
		if (_size == _capacity)
		{
			reserve(_capacity == 0 ? 4 : _capacity * 2);
		}

		_str[_size] = ch;
		_size++;
		_str[_size] = '\0';
		return *this;
	}
	string&amp; string::operator+=(const char* str)
	{
		int len = strlen(str);
		if (_size + len &gt;= _capacity)
		{
			reserve(_capacity * 2 &gt; _size + len ? _capacity * 2 : _size + len);

		}
		for (int i = 0; i &lt;= len; i++)//假设字符串为"11\0"
		{
			_str[_size + i] = str[i];
		}
		_size = _size + len;
		return *this;
	}</code></pre> 
<p></p> 
<h6 id="%E2%91%A1%20push_back%E4%B8%8Eappend%E7%9A%84%E5%AE%9E%E7%8E%B0">② push_back与append的实现</h6> 
<p>由于实现了两个+=我们直接复用即可</p> 
<pre><code class="language-cpp">	void string::push_back(char ch)
	{
		*this += ch;
	}
	void string::append(const char* str)
	{
		*this += str;
	}</code></pre> 
<h6 id="%E2%91%A2%20insert%E7%9A%84%E5%AE%9E%E7%8E%B0">③ insert的实现</h6> 
<p>我们需要注意<strong><span style="color:#fe2c24;">size_t类型是无符号整形，所以没有负值</span></strong>，我们可以<span style="background-color:#ffd900;">通过下标加一，操作时整体减一，或将size_t都进行强制类型转换再操作</span>等等</p> 
<pre><code class="language-cpp">	void string::insert(size_t pos, char ch)
	{
		assert(pos &lt;= _size);
		if (_size == _capacity)
		{
			reserve(_capacity == 0 ? 4 : _capacity * 2);
		}
		size_t n = _size+1;
		//while (n &gt;= pos)//隐式类型转换
		//{
		//	_str[n + 1] = _str[n];
		//	n--;
		//}
		while (n &gt; pos)
		{
			_str[n ] = _str[n-1];
			n--;
		}

		_str[pos] = ch;
		_size++;
	}
	void string::insert(size_t pos, const char* str)
	{
		assert(pos &lt;= _size);
		int len = strlen(str);
		if (_size + len &gt;= _capacity)
		{
			reserve(_capacity * 2 &gt; _size + len ? _capacity * 2 : _size + len);
		}

		//for (int i = _size; i &gt;= pos; i--)//隐式类型转换
		//{
		//	_str[i + len] = _str[i];
		//}

		for (int i = _size+1; i &gt;pos; i--)
		{
			_str[i + len-1] = _str[i-1];
		}

		for (int i = 0; i &lt; len; i++)
			_str[pos + i] = str[i];
		_size += len;
	}</code></pre> 
<h6 id="%E2%91%A3%20erase%E4%B8%8Eclear%E7%9A%84%E5%AE%9E%E7%8E%B0" style="background-color:transparent;">④ erase与clear的实现</h6> 
<p>erase实现如下</p> 
<pre><code class="language-cpp">	void string::erase(size_t pos, size_t len )
	{
		assert(pos &lt; _size);
		if (len &gt; _size - pos)
		{
			_str[pos] = '\0';
			_size = pos;
		}
		else
		{
			size_t n = pos;
			for (size_t i = pos + len; i &lt;= _size; i++)
			{
				_str[n] = _str[i];
				n++;
			}
			_size -= len;
		}

	}</code></pre> 
<p>clear由于代码量小直接在类内实现，直接在下标为0处给'\0'  即可</p> 
<pre><code class="language-cpp">		void clear()
		{
			_str[0] = '\0';
			_size = 0;
		}</code></pre> 
<h6 id="%E2%91%A4%20%E4%BA%A4%E6%8D%A2%E5%87%BD%E6%95%B0" style="background-color:transparent;">⑤ 交换函数</h6> 
<p>我们来实现string里的swap</p> 
<pre><code class="language-cpp">		void swap(string&amp; s)
		{
			std::swap(_str, s._str);
			std::swap(_size, s._size);
			std::swap(_capacity, s._capacity);
		}</code></pre> 
<p> 各种信息直接交换很高效，<span style="background-color:#ffd900;">C++98中全局的swap实现交换需要完成三次深拷贝</span>，string里的swap优与全局的，<strong>但C++11中</strong>，全局swap检测到string会直接调用string里的swap因此<strong>效率差不多</strong></p> 
<p>拷贝构造函数也可以写为</p> 
<pre><code class="language-cpp">		string(const string&amp; s1)
		{
			string tmp(s1._str);
			swap(tmp);
		}</code></pre> 
<h6 id="(4).%20string%E7%9A%84%E6%9F%A5%E6%89%BE" style="background-color:transparent;">(4). string的查找</h6> 
<p>查找字符十分简单，查找字符串我们可已<strong>通过strstr来实现</strong>，他如果<span style="background-color:#ffd900;">找到会返回要查找字符串的第一个字符地址若没有找到返回null指针</span></p> 
<pre><code class="language-cpp">	size_t string::find(char ch, size_t pos )
	{
		assert(pos &lt; _size);
		for (size_t i = pos; i &lt; _size; i++)
		{
			if (_str[i] == ch)
				return i;
		}
		return -1;
	}
	size_t string::find(const char* str, size_t pos)
	{
		assert(pos &lt; _size);
		const char* ps = strstr(_str + pos, str);

		if (ps == nullptr)
		{
			return npos;
		}
		else
		{
			return ps - _str;
		}
	}</code></pre> 
<h6 id="(5).%C2%A0%20string%E7%9A%84%E6%B5%81%E6%8F%92%E5%85%A5%E4%B8%8E%E6%B5%81%E6%8F%90%E5%8F%96%E7%9A%84%E9%87%8D%E8%BD%BD" style="background-color:transparent;">(5).  string的流插入与流提取的重载</h6> 
<p>我们在实现流提取时需要注意cin遇见空格与换行是不会读进去的话这时候我们就要用到一个函数get()了</p> 
<pre><code class="language-cpp">	ostream&amp; operator&lt;&lt;(ostream&amp; out, string&amp; s)
	{
		out &lt;&lt; s.c_str();
		return out;
	}
	istream&amp; operator&gt;&gt;(istream&amp; in, string&amp; s)
	{
		s.clear();
		
		//错误示范
		//char ch;
		//in &gt;&gt; ch;
		//while (ch != ' ' &amp;&amp; ch != '\n')
		//{
		//	s += ch;
		//	in &gt;&gt; ch;//遇到空格或换行符就不会读进去
		//}

		//正确
		//char ch;
		//ch = in.get();
		//while (ch != ' ' &amp;&amp; ch != '\n')
		//{
		//	s += ch;
		//	ch = in.get();//不管什么类型一个字符一个字符的读
		//}

		//优化,减少存储字符串很长时扩容次数
		const int N = 256;//字符串特别长，N给大一点点还会减少扩容
		char charval[N];
		int i = 0;
		charval[i] = in.get();
		while (charval[i] != ' ' &amp;&amp; charval[i] != '\n')
		{
			charval[++i] = in.get();
			if (i == N-1)
			{
				charval[i] = '\0';
				s += charval;
				i = 0;
			}
		}
		if(i&gt;0)
		{
			charval[++i] = '\0';
			s += charval;
		}

		return in;
	}</code></pre> 
<p>那还会有一个问题，输入的字符串太长，需要频繁扩容，那么消耗会很大，我们可以<strong><span style="color:#fe2c24;">建立一个数组等这个数组存满了再一次性给string对象</span></strong>，如果没满就结束了，那就退出循环将存储的值给对象<span style="background-color:#ffd900;">(不要忘记给数组'\0'，而且数组要留一个存储'\0')</span>。这样就要有效的减少扩容次数</p> 
<p>我们顺便实现getline(代码几乎一样)</p> 
<pre><code class="language-cpp">	istream&amp; getline(istream&amp; in, string&amp; str, char delim)
	{
		str.clear();
		//优化,减少存储字符串很长时扩容次数
		const int N = 256;//字符串特别长，N给大一点点还会减少扩容
		char charval[N];
		int i = 0;
		charval[i] = in.get();
		while (charval[i] != delim)
		{
			charval[++i] = in.get();
			if (i == N - 1)
			{
				charval[i] = '\0';
				str += charval;
				i = 0;
			}
		}
		if (i &gt; 0)
		{
			charval[++i] = '\0';
			str += charval;
		}

		return in;
	}
	istream&amp; getline(istream&amp; in, string&amp; str)
	{
		str.clear();
		const int N = 256;//字符串特别长，N给大一点点还会减少扩容
		char charval[N];
		int i = 0;
		charval[i] = in.get();
		while (charval[i] != '\n')
		{
			charval[++i] = in.get();
			if (i == N - 1)
			{
				charval[i] = '\0';
				str += charval;
				i = 0;
			}
		}
		if (i &gt; 0)
		{
			charval[++i] = '\0';
			str += charval;
		}

		return in;
	}</code></pre> 
<h6 id="(6).%20%E5%85%B6%E4%BB%96%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C">(6). 其他一些操作</h6> 
<h6 id="%E2%91%A0%20%E6%AF%94%E8%BE%83">① 比较</h6> 
<p>字符串之间的比较是比较ASCII码值，我们通过strcmp实现，再复用代码</p> 
<pre><code class="language-cpp">	bool operator&gt;(const string&amp; s1, const string&amp; s2)
	{
		return strcmp(s1.c_str(), s2.c_str()) &gt; 0;
	}
	bool operator&lt;(const string&amp; s1, const string&amp; s2)
	{
		return strcmp(s1.c_str(), s2.c_str()) &lt; 0;
	}
	bool operator&gt;=(const string&amp; s1, const string&amp; s2)
	{
		return !(s1 &lt; s2);
	}
	bool operator&lt;=(const string&amp; s1, const string&amp; s2)
	{
		return !(s1 &gt; s2);
	}
	bool operator==(const string&amp; s1, const string&amp; s2)
	{
		return strcmp(s1.c_str(), s2.c_str()) == 0;
	}
	bool operator!=(const string&amp; s1, const string&amp; s2)
	{
		return !(s1 == s2);
	}</code></pre> 
<h6 id="%E2%91%A1%20substr">② substr</h6> 
<pre><code class="language-cpp">	string string::substr(size_t pos , size_t len ) const
	{
		assert(pos &lt; _size);
		if (len &gt; _size - pos)
			len = _size - pos;

		string s1;
		s1.reserve(len);
		for (int i = 0; i &lt; len; i++)
		{
			s1 += _str[pos + i];
		}
		return s1; 
	}</code></pre> 
<h6 id="%E2%91%A2%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">③ 赋值运算符重载</h6> 
<p>我们判断是不是给自己赋值，是就跳过，不是就创建一个新变量拷贝构造后进行交换</p> 
<p><span style="background-color:#ffd900;">出了if就将tmp给销毁了，而this指针指向的就是tmp初始化的地址，销毁的为this之前的地址</span></p> 
<pre><code class="language-cpp">		string&amp; operator=(const string&amp; s)
		{
			if (this != &amp;s)//是自己就没必要赋值了
			{
				string tmp(s);
				swap(tmp);
			}
			return *this;
		}</code></pre> 
<p>而我们可以将其简化为，不是引用传参，那他就进行了一次拷贝构造了交换即可</p> 
<pre><code class="language-cpp">		string&amp; operator=(string tmp)
		{
			//不需要判断是否是给自己赋值，因为tmp变量已经创建出来了
			swap(tmp);
			return *this;
		}</code></pre> 
<h5 id="3.%20%E6%BA%90%E4%BB%A3%E7%A0%81">3. 源代码</h5> 
<h6 id="(1).%20%E5%A4%B4%E6%96%87%E4%BB%B6">(1). 头文件</h6> 
<pre><code class="language-cpp">#pragma once
#include&lt;iostream&gt;
#include&lt;assert.h&gt;
#include&lt;cstring&gt;
using std::cout;
using std::cin;
using std::endl;
using std::istream;
using std::ostream;
namespace Pc
{
	class string
	{
	public:
		typedef char* iterator;
		typedef char* const_iterator;
		//static const size_t npos = -1;
		static const size_t npos ;
		//实现迭代器
		iterator begin()
		{
			return _str;
		}
		iterator end()
		{
			return _str + _size;
		}
		const_iterator begin() const
		{
			return _str;
		}
		const_iterator end() const
		{
			return _str + _size;
		}
		//短小，频繁调用的都在类里
		string()
			:_str(new char[5])
			,_size(0)
			,_capacity(4)
		{
			_str[0] = '\0';
		}
		string(const char* str)
			:_str(new char [strlen(str) + 1])
			//_caoacity不包含\0
			, _size(strlen(str))
			, _capacity(strlen(str))
		{
			strcpy(_str, str);
		}

		void swap(string&amp; s)
		{
			std::swap(_str, s._str);
			std::swap(_size, s._size);
			std::swap(_capacity, s._capacity);
		}

		string(const string&amp; s1)
			//:_str(new char [s1.capacity()+1])
			//, _size(s1.size())
			//, _capacity(s1.capacity())
		{
			//strcpy(_str, s1.c_str());
			string tmp(s1._str);
			swap(tmp);
		}
		//string&amp; operator=(const string&amp; s)
		//{
		//	if (this != &amp;s)//是自己就没必要赋值了
		//	{
		//		string tmp(s);
		//		swap(tmp);
		//	}
		//	return *this;
		//}
		string&amp; operator=(string tmp)
		{
			//不需要判断是否是给自己赋值，因为tmp变量已经创建出来了
			swap(tmp);

			return *this;
		}
		~string()
		{
			delete[] _str;//str是nullptr也没问题
			_str = nullptr;
			_size = _capacity = 0;
		}

		const char* c_str() const
		{
			return _str;
		}

		size_t size() const
		{
			return _size;
		}
		size_t capacity() const
		{
			return _capacity;
		}
		char&amp; operator[](size_t pos)
		{
			assert(pos &lt; _size);
			return _str[pos];
		}
		const char&amp; operator[](size_t pos) const
		{
			assert(pos &lt; _size);
			return _str[pos];
		}


		void reserve(size_t n);
		void push_back(char ch);
		void append(const char* str);
		string&amp; operator+=(char ch);
		string&amp; operator+=(const char* str);

		void insert(size_t pos, char ch);
		void insert(size_t pos, const char* str); 
		void erase(size_t pos, size_t len = npos);
		string substr(size_t pos = 0, size_t len = npos) const;
		
		size_t find(char ch, size_t pos = 0);
		size_t find(const char* str, size_t pos = 0);


		void clear()
		{
			_str[0] = '\0';
			_size = 0;
		}
	private:
		char* _str;
		size_t _size;
		size_t _capacity;


	};
	bool operator&gt;(const string&amp; s1,const string&amp; s2);
	bool operator&lt;(const string&amp; s1, const string&amp; s2);
	bool operator&gt;=(const string&amp; s1, const string&amp; s2);
	bool operator&lt;=(const string&amp; s1, const string&amp; s2);
	bool operator==(const string&amp; s1, const string&amp; s2);
	bool operator!=(const string&amp; s1, const string&amp; s2);
	istream&amp; operator&gt;&gt;(istream&amp; in, string&amp; s);
	ostream&amp; operator&lt;&lt;(ostream&amp; out, string&amp; s);

	istream&amp; getline(istream&amp; is, string&amp; str, char delim);
	istream&amp; getline(istream&amp; is, string&amp; str);

}
</code></pre> 
<h6 id="(2).%20%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD%E7%9A%84">(2). 实现功能的</h6> 
<pre><code class="language-cpp">#include"string.h"

namespace Pc
{
	const size_t string::npos = -1;

	void string::reserve(size_t n)
	{
		if (n &gt; _capacity)
		{
			char* tmp = new char[ n + 1];
			strcpy(tmp, _str);
			delete[] _str;
			_str = tmp;
			_capacity = n;
		}
	}

	void string::push_back(char ch)
	{
		*this += ch;
	}
	void string::append(const char* str)
	{
		*this += str;
	}

	string&amp; string::operator+=(char ch)
	{
		if (_size == _capacity)
		{
			reserve(_capacity == 0 ? 4 : _capacity * 2);
		}

		_str[_size] = ch;
		_size++;
		_str[_size] = '\0';
		return *this;
	}
	string&amp; string::operator+=(const char* str)
	{
		int len = strlen(str);
		if (_size + len &gt;= _capacity)
		{
			reserve(_capacity * 2 &gt; _size + len ? _capacity * 2 : _size + len);

		}
		for (int i = 0; i &lt;= len; i++)//假设字符串为"11\0"
		{
			_str[_size + i] = str[i];
		}
		_size = _size + len;
		return *this;
	}

	void string::insert(size_t pos, char ch)
	{
		assert(pos &lt;= _size);
		if (_size == _capacity)
		{
			reserve(_capacity == 0 ? 4 : _capacity * 2);
		}
		size_t n = _size+1;
		//while (n &gt;= pos)//隐式类型转换
		//{
		//	_str[n + 1] = _str[n];
		//	n--;
		//}
		while (n &gt; pos)
		{
			_str[n ] = _str[n-1];
			n--;
		}

		_str[pos] = ch;
		_size++;
	}
	void string::insert(size_t pos, const char* str)
	{
		assert(pos &lt;= _size);
		int len = strlen(str);
		if (_size + len &gt;= _capacity)
		{
			reserve(_capacity * 2 &gt; _size + len ? _capacity * 2 : _size + len);
		}

		//for (int i = _size; i &gt;= pos; i--)//隐式类型转换
		//{
		//	_str[i + len] = _str[i];
		//}

		for (int i = _size+1; i &gt;pos; i--)
		{
			_str[i + len-1] = _str[i-1];
		}

		for (int i = 0; i &lt; len; i++)
			_str[pos + i] = str[i];
		_size += len;
	}


	void string::erase(size_t pos, size_t len )
	{
		assert(pos &lt; _size);
		if (len &gt; _size - pos)
		{
			_str[pos] = '\0';
			_size = pos;
		}
		else
		{
			size_t n = pos;
			for (size_t i = pos + len; i &lt;= _size; i++)
			{
				_str[n] = _str[i];
				n++;
			}
			_size -= len;
		}

	}
	string string::substr(size_t pos , size_t len ) const
	{
		assert(pos &lt; _size);
		if (len &gt; _size - pos)
			len = _size - pos;

		string s1;
		s1.reserve(len);
		for (int i = 0; i &lt; len; i++)
		{
			s1 += _str[pos + i];
		}
		return s1; 
	}
	size_t string::find(char ch, size_t pos )
	{
		assert(pos &lt; _size);
		for (size_t i = pos; i &lt; _size; i++)
		{
			if (_str[i] == ch)
				return i;
		}
		return -1;
	}
	size_t string::find(const char* str, size_t pos)
	{
		assert(pos &lt; _size);
		const char* ps = strstr(_str + pos, str);

		if (ps == nullptr)
		{
			return npos;
		}
		else
		{
			return ps - _str;
		}
	}
	bool operator&gt;(const string&amp; s1, const string&amp; s2)
	{
		return strcmp(s1.c_str(), s2.c_str()) &gt; 0;
	}
	bool operator&lt;(const string&amp; s1, const string&amp; s2)
	{
		return strcmp(s1.c_str(), s2.c_str()) &lt; 0;
	}
	bool operator&gt;=(const string&amp; s1, const string&amp; s2)
	{
		return !(s1 &lt; s2);
	}
	bool operator&lt;=(const string&amp; s1, const string&amp; s2)
	{
		return !(s1 &gt; s2);
	}
	bool operator==(const string&amp; s1, const string&amp; s2)
	{
		return strcmp(s1.c_str(), s2.c_str()) == 0;
	}
	bool operator!=(const string&amp; s1, const string&amp; s2)
	{
		return !(s1 == s2);
	}

	ostream&amp; operator&lt;&lt;(ostream&amp; out, string&amp; s)
	{
		out &lt;&lt; s.c_str();
		return out;
	}
	istream&amp; operator&gt;&gt;(istream&amp; in, string&amp; s)
	{
		s.clear();
		
		//错误示范
		//char ch;
		//in &gt;&gt; ch;
		//while (ch != ' ' &amp;&amp; ch != '\n')
		//{
		//	s += ch;
		//	in &gt;&gt; ch;//遇到空格或换行符就不会读进去
		//}

		//正确
		//char ch;
		//ch = in.get();
		//while (ch != ' ' &amp;&amp; ch != '\n')
		//{
		//	s += ch;
		//	ch = in.get();//不管什么类型一个字符一个字符的读
		//}

		//优化,减少存储字符串很长时扩容次数
		const int N = 256;//字符串特别长，N给大一点点还会减少扩容
		char charval[N];
		int i = 0;
		charval[i] = in.get();
		while (charval[i] != ' ' &amp;&amp; charval[i] != '\n')
		{
			charval[++i] = in.get();
			if (i == N-1)
			{
				charval[i] = '\0';
				s += charval;
				i = 0;
			}
		}
		if(i&gt;0)
		{
			charval[++i] = '\0';
			s += charval;
		}

		return in;
	}
	istream&amp; getline(istream&amp; in, string&amp; str, char delim)
	{
		str.clear();
		//优化,减少存储字符串很长时扩容次数
		const int N = 256;//字符串特别长，N给大一点点还会减少扩容
		char charval[N];
		int i = 0;
		charval[i] = in.get();
		while (charval[i] != delim)
		{
			charval[++i] = in.get();
			if (i == N - 1)
			{
				charval[i] = '\0';
				str += charval;
				i = 0;
			}
		}
		if (i &gt; 0)
		{
			charval[++i] = '\0';
			str += charval;
		}

		return in;
	}
	istream&amp; getline(istream&amp; in, string&amp; str)
	{
		str.clear();
		const int N = 256;//字符串特别长，N给大一点点还会减少扩容
		char charval[N];
		int i = 0;
		charval[i] = in.get();
		while (charval[i] != '\n')
		{
			charval[++i] = in.get();
			if (i == N - 1)
			{
				charval[i] = '\0';
				str += charval;
				i = 0;
			}
		}
		if (i &gt; 0)
		{
			charval[++i] = '\0';
			str += charval;
		}

		return in;
	}

}</code></pre> 
<hr> 
<p>这篇文章就到这里啦~</p> 
<p>希望能帮到你</p> 
<p>（づ￣3￣）づ╭❤～</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e8dbceb2d1a574dab343fb9e9194cb90/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【c&#43;&#43;】爬虫到底违不违法？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ff9a15bfffa98eb996f195fab1f16b44/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">《学会 SpringMVC 系列 · 剖析篇（上）》</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>