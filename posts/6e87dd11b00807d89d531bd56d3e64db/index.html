<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android 15 之如何快速适配 16K Page Size - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/6e87dd11b00807d89d531bd56d3e64db/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Android 15 之如何快速适配 16K Page Size">
  <meta property="og:description" content="在此之前，我们通过 《Android 15 上 16K Page Size 为什么是最坑》 介绍了：
什么是16K Page Size为什么它对于 Android 很坑如何测试 如果你还没了解，建议先去了解下前文，然后本篇主要是提供适配的思路，因为这类适配更多工作量在于实际的执行调整和编译跟踪，而非功能上的适配，本质不复杂，但可能量大且繁琐。
是的，想要适配你首选需要有 C/C&#43;&#43; 等 so 库的源码。
适配的开始，我们可以先粗暴的全局搜索 「4096」关键字，看看是否有将 4096 搭配 mmap 、sysconf 等相关的地方，因为 Android 上的 4K 这么多年已经「深入人心」，可以说不少代码都将 Android 默认为「4096」。
对于这些地方，我们可以通过类似 getpagesize() 等方式来进行调整，例如通过 ALOGV(&#34;####### %d&#34;, getpagesize()); 可以看到在 Android15 上输出的是 16384 。
接着我们可以运行项目到 Android 15 的模拟器上（如果运行不起来看前文），看 so 是否能正常被加载执行，一般情况下你可能会看到类似：
java.lang.UnsatisfiedLinkError: dlopen failed: empty/missing DT_HASH ···· (new hash type from the future?) 这类问题基本都是 so 文件没有 16K 编译对齐的原因，此时，根据你的 CMakeList 版本，可以使用 target_link_options 或者 target_link_libraries 进行调整。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-22T07:11:37+08:00">
    <meta property="article:modified_time" content="2024-07-22T07:11:37+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android 15 之如何快速适配 16K Page Size</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>在此之前，我们通过 <a href="https://blog.csdn.net/ZuoYueLiang/article/details/140270258?spm=1001.2014.3001.5501">《Android 15 上 16K Page Size 为什么是最坑》</a> 介绍了：</p> 
<ul><li>什么是16K Page Size</li><li>为什么它对于 Android 很坑</li><li>如何测试</li></ul> 
<p>如果你还没了解，建议先去了解下前文，然后本篇主要是提供适配的思路，<strong>因为这类适配更多工作量在于实际的执行调整和编译跟踪，而非功能上的适配，本质不复杂，但可能量大且繁琐</strong>。</p> 
<blockquote> 
 <p>是的，想要适配你首选需要有 C/C++ 等 so 库的源码。</p> 
</blockquote> 
<p>适配的开始，我们可以先粗暴的全局搜索 「4096」关键字，看看是否有将 4096 搭配 <code>mmap</code> 、<code>sysconf</code> 等相关的地方，因为 Android 上的 4K 这么多年已经「深入人心」，可以说不少代码都将 Android 默认为「4096」。</p> 
<p><img src="https://images2.imgbox.com/e6/b2/kgizNba8_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/2d/9e/mV3qp1dC_o.png" alt=""></p> 
<p><strong>对于这些地方，我们可以通过类似 <code> getpagesize()</code> 等方式来进行调整</strong>，例如通过 <code>ALOGV("####### %d", getpagesize());</code> 可以看到在 Android15 上输出的是 16384 。</p> 
<p><img src="https://images2.imgbox.com/8c/b9/g0J1s6LA_o.png" alt=""></p> 
<p>接着我们可以运行项目到 Android 15 的模拟器上（<em>如果运行不起来看前文</em>），看 so 是否能正常被加载执行，一般情况下你可能会看到类似：</p> 
<pre><code class="prism language-ini">java.lang.UnsatisfiedLinkError: dlopen failed: empty/missing DT_HASH ···· (new hash type from the future?)
</code></pre> 
<p><img src="https://images2.imgbox.com/9f/ac/1tiOpJRU_o.png" alt=""></p> 
<p><strong>这类问题基本都是 so 文件没有 16K 编译对齐的原因</strong>，此时，根据你的 CMakeList 版本，可以使用 <code>target_link_options</code> 或者 <code>target_link_libraries</code> 进行调整。</p> 
<p><img src="https://images2.imgbox.com/a5/5a/dClekQkJ_o.png" alt=""></p> 
<p>例如 3.13 之前：</p> 
<pre><code class="prism language-cmake">target_link_libraries(a4ijkplayer  "-Wl,-z,max-page-size=16384")
</code></pre> 
<p>例如 3.13 之后：</p> 
<pre><code class="prism language-cmake">target_link_options(a4ijkplayer PRIVATE "-Wl,-z,max-page-size=16384")
</code></pre> 
<blockquote> 
 <p>注意 CMakeList 的版本还需要 SDK Manager 里有下载安装。</p> 
</blockquote> 
<p>如果是 <code>Android.mk</code> ， 则添加 LOCAL_LDFLAGS 也可以配置 16K Page ：</p> 
<pre><code>LOCAL_LDFLAGS += -Wl,-z,max-page-size=16384
</code></pre> 
<p>编译后，我们通过 readelf 工具，可以对比编译前后两个 so 的 elf 对齐情况，工具一般位于 <code>/Users/guoshuyu/Library/Android/sdk/ndk/21.4.7075529/toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/bin</code>，通过以下命令可以输出对应参数：</p> 
<pre><code>./aarch64-linux-android-readelf -l /Users/guoshuyu/workspace/android/******/libs/arm64-v8a/libijkffmpeg.so
</code></pre> 
<p>如下两种图所示：</p> 
<ul><li>图 1 LOAD 段在 Align 栏目显示 1000 (16进制，即 4096) ，也就是还没增加 16K 对齐的状态</li><li>图 2 LOAD 段在 Align 栏目显示 4000 (16进制，即 16384) ，也就是修改编译后，已经增加 16K 对齐的状态</li></ul> 
<p><img src="https://images2.imgbox.com/09/31/t6N2D6cm_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/f4/1a/wkw2ARQk_o.png" alt=""></p> 
<blockquote> 
 <p>这里我们只关心 LOAD 段，因为一般只有 LOAD 段需要加载到内存中。</p> 
</blockquote> 
<p><strong>所以简单情况下，你也可以通过 readelf 工具查看 so 的对齐状态</strong>。</p> 
<p>另外，如果你在低版本 NDK （低于 r27） 上使用动态链接到 C++ 标准库，那么可以也会遇到 <code>1ibc++_shared.so</code> 的相关报错，解决的思路还是：</p> 
<ul><li>升级到 NDK r27</li><li>将 C++ 标准库静态链接到 so 库里面，例如 <code>-DANDROID_STL=c++_static</code></li></ul> 
<pre><code class="prism language-groovy">        externalNativeBuild <span class="token punctuation">{<!-- --></span>
            cmake <span class="token punctuation">{<!-- --></span>
                abiFilters <span class="token string">'armeabi-v7a'</span><span class="token punctuation">,</span> <span class="token string">'arm64-v8a'</span>
                arguments <span class="token string">'-DANDROID_ARM_NEON=TRUE'</span><span class="token punctuation">,</span> <span class="token string">'-DANDROID_STL=c++_static'</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/24/43/XMqKaJ72_o.png" alt=""></p> 
<p>之后，如果 so 运行过程中还存在异常问题， 可以通过地址信息来进行代码定位，例如使用常见的：<code>addr2line</code> 。</p> 
<p><img src="https://images2.imgbox.com/bd/bc/r4t5TwCj_o.png" alt=""></p> 
<p>而 <code>addr2line</code> 的可执行文件位置，一般位于以下位置：</p> 
<pre><code>/Users/guoshuyu/Library/Android/sdk/ndk/21.4.7075529/toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/bin
</code></pre> 
<blockquote> 
 <p>注意 ndkVersion 的版本还需要 SDK Manager 里有下载安装。</p> 
</blockquote> 
<p>其中 ndk 版本为项目 <code>build.gradle</code> 下配置的 ndk 版本，例如 <code>ndkVersion '21.4.7075529'</code> ，之后你只需要通过执行命令输出，即可看到出现问题的文件和行数：</p> 
<pre><code> ./aarch64-linux-android-addr2line -e /Users/guoshuyu/workspace/android/··········/build/intermediates/merged_native_libs/debug/out/lib/arm64-v8a/????.so 000000000007e0a0
</code></pre> 
<p><img src="https://images2.imgbox.com/b2/c1/SCP4EXBq_o.png" alt=""></p> 
<p>当然，也可以增加 -f，通过 <code>./aarch64-linux-android-addr2line -f -e </code> 来查看出问题的函数是什么：</p> 
<p><img src="https://images2.imgbox.com/55/b8/R47KNpwd_o.png" alt=""></p> 
<blockquote> 
 <p>例如，对于 C++ 里静态存储区域分配，内存在程序编译的时候就已经分配好，而 static 这块内存变量上，如果 so 对齐和地址存在问题，也可能会导致访问地址异常。</p> 
</blockquote> 
<p>如果上述在使用 <code>addr2line</code> 输出时看到都是 ?? ，那么你可能需要修改下编译的调试支持和优化级别，例如 <code>Application.mk</code> 上降低优化等级为 <code>APP_CFLAGS := -O0</code>。</p> 
<p>当然，很多时候存在许多「玄学」的问题，例如前段时间就遇到了一个神奇的 Bug ，甚至也不知道为什么，但是又能改好它。</p> 
<p>举个不严谨的例子，通过地址定位，可以定位到报错的地方是这个 <code>static</code> 的全局变量报错，但是为什么会出现 <code>Fatal signal 11(SIGSEGV),code 2(SEGV_ACCERR)</code> 让人费解。</p> 
<p><img src="https://images2.imgbox.com/e2/6e/XwalwNuL_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/d3/ca/PQ94R8lq_o.png" alt=""></p> 
<p>如果按照正常场景来看，C 和 C++ 中的静态变量通常存储在 “data” 区域，但是对于任何未初始化或初始化为零的全局数据，都是存放在 “bss” ：</p> 
<p><img src="https://images2.imgbox.com/fb/9b/ts0f1pX9_o.png" alt=""></p> 
<p>正常情况下，bss 段属于静态内存分配，通常是用来存放未初始化的全局变量和未初始化的局部静态变量，所以 bss 段只是给未初始化的全局变量和未初始化的局部静态变量预留位置而已。</p> 
<p>我们可以通过前面的 readelf 工具看一下，如下命令所示 ，通过 <code>-s | grep _errMsg</code> 输出，我们可以看到 <code>_errMsg</code> 确实存在 [23] 的 bss 的 NOBITS 位置。</p> 
<pre><code>./aarch64-linux-android-readelf -S /Users/guoshuyu/workspace/*****.so -s | grep _errMsg
</code></pre> 
<p><img src="https://images2.imgbox.com/a0/de/jZti2AXH_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/c7/9f/uOFRI5eo_o.png" alt=""></p> 
<p>但是从输出看，貌似也没什么问题，如果从另外的 <code>.text</code> 和 <code>.rodata </code> 的 Address 上看， 165670 - 071fa0 = F36D0 ，也正好是 4000 的 3C 倍数 ，所以分页应该也没问题。</p> 
<p><img src="https://images2.imgbox.com/56/e3/VsMwstk0_o.png" alt=""></p> 
<p>而通过 objdump 输出的结果看，也和没看出异常，所以问题就变得很玄学，根据猜测，可能是以下某个之一的问题：</p> 
<pre><code>./aarch64-linux-android-objdump -h /Users/guoshuyu/workspace/android/****.so
</code></pre> 
<ul><li>某个过程编译的对齐有问题</li><li>NDK 的 gcc 优化存在一些奇怪问题， 例如 gcc 不仅观察变量如何定义，还观察了变量如何在代码中使用</li><li>赋值的寻址有问题没对齐</li><li>模拟器系统问题</li></ul> 
<blockquote> 
 <p>在偶然之下，屏蔽掉某个使用 <code>_errMsg</code> 的 static function 的 <code>static</code> 声明后，它居然就正常运行了，就是偶尔删掉了某个函数的 static 声明，它突然就好了···所以我也不知道是编译的问题还是系统的问题，也许后面有空再深入研究下，不过在适配过程中，真的是「运气好」的情况下，你只需要改一下配置，编译完就可以立即使用，运气不好的情况下，真的就很「玄学」。</p> 
</blockquote> 
<p>最后，如果你需要升级到 NDK r27，你可能还需要对代码的编排方式做一些调整，例如类似 <code>ISO C99 and later do not support implicit function declarations</code> 等小细节问题，因为 NDK r27 目前是 clang-r522817 的版本:</p> 
<p><img src="https://images2.imgbox.com/e6/23/cvEm8jvP_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/26/e1/kgKpx8DJ_o.png" alt=""></p> 
<p>根据 r27 目前的 <code>clang_source_info.md</code> ，其 clang 应该会是 18.1.0 ，也就是包含 C++ 20/23/2C 等的支持，如果升级跨度较大，其实可能会是改了旧坑来新坑的节奏。</p> 
<blockquote> 
 <p>例如腾讯目前的 MMKV，在 <a href="https://github.com/Tencent/MMKV/issues/1353">issue#1353</a> 就提到了兼容的评估问题，虽然对于使用者来说，可能就是几个简单配置就可以重新编译支持，但是对于平台方来说，升级环境是一个“高风险”行为，所以还需要谨慎而行。</p> 
</blockquote> 
<p>最后，这个适配的基础还是你有源码，如果你连源码都没有，那么基本就没希望了，对于 android 环境下，基于 linux 的 4k/16k 内核是不支持混用(详细原因见前文)，所以如果你没做适配，很大可能 so 是无法正常运行，<strong>不过好消息是，OEM 厂商可以不启用，坏消息是，Google 表示明年在 Google Play 上会强制要求</strong>。</p> 
<p><img src="https://images2.imgbox.com/34/f1/dA1Uexe9_o.png" alt=""></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fb1f369d5141007dfbcf98f2b24ff33f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C&#43;&#43;】string类（上）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/064be7c1dddeeff60843a11e89ba85d0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">双向链表＜数据结构 C版＞</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>