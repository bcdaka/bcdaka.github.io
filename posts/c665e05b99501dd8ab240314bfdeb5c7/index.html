<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;深度探索】继承机制详解（一） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/c665e05b99501dd8ab240314bfdeb5c7/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;深度探索】继承机制详解（一）">
  <meta property="og:description" content="hello hello~ ，这里是大耳朵土土垚~💖💖 ，欢迎大家点赞🥳🥳关注💥💥收藏🌹🌹🌹
💥个人主页：大耳朵土土垚的博客
💥 所属专栏：C&#43;&#43;入门至进阶
这里将会不定期更新有关C&#43;&#43;的内容，希望大家多多点赞关注收藏💖💖
目录 1.继承的概念2.继承定义2.1定义格式2.2访问限定符2.3继承方式 3.基类和派生类对象赋值转换4.继承中的重定义(隐藏)5.派生类的默认成员函数✨构造函数✨拷贝构造✨赋值运算符重载✨析构函数 6.结语 1.继承的概念 继承(inheritance)机制是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生新的类，称派生类或子类。继承呈现了面向对象程序设计的层次结构，体现了由简单到复杂的认知过程。以前我们接触的复用都是函数复用，继承是类设计层次的复用。
2.继承定义 2.1定义格式 下面我们看到Person是父类，也称作基类。Student是子类，也称作派生类。
//基类或父类 class Person { public: void Print() { cout &lt;&lt; &#34;name:&#34; &lt;&lt; _name &lt;&lt; endl; cout &lt;&lt; &#34;age:&#34; &lt;&lt; _age &lt;&lt; endl; } protected: string _name = &#34;peter&#34;;// 姓名 int _age = 18; //年龄 }; //派生类或子类 class Student : public Person { protected: int _stuid; // 学号 int _major;	//专业 }; 2.2访问限定符 C&#43;&#43;类的访问限定符用于控制类的成员（包括成员变量和成员函数）在类的外部的可访问性。C&#43;&#43;中有以下三种访问限定符：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-30T22:38:22+08:00">
    <meta property="article:modified_time" content="2024-06-30T22:38:22+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;深度探索】继承机制详解（一）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p><strong>hello hello~ ，这里是大耳朵土土垚~💖💖 ，欢迎大家点赞🥳🥳关注💥💥收藏🌹🌹🌹</strong><br> <img src="https://images2.imgbox.com/f9/76/Lm6kB13c_o.png" alt="在这里插入图片描述"></p> 
 <blockquote> 
  <p>💥<strong>个人主页</strong>：<a href="https://blog.csdn.net/Renswc?type=blog">大耳朵土土垚的博客</a><br> 💥 <strong>所属专栏</strong>：<a href="https://blog.csdn.net/renswc/category_12630230.html">C++入门至进阶</a><br> 这里将会不定期更新有关C++的内容，希望大家多多点赞关注收藏💖💖</p> 
 </blockquote> 
</blockquote> 
<p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#1_7" rel="nofollow">1.继承的概念</a></li><li><a href="#2_10" rel="nofollow">2.继承定义</a></li><li><ul><li><a href="#21_11" rel="nofollow">2.1定义格式</a></li><li><a href="#22_42" rel="nofollow">2.2访问限定符</a></li><li><a href="#23_53" rel="nofollow">2.3继承方式</a></li></ul> 
  </li><li><a href="#3_175" rel="nofollow">3.基类和派生类对象赋值转换</a></li><li><a href="#4_215" rel="nofollow">4.继承中的重定义(隐藏)</a></li><li><a href="#5_323" rel="nofollow">5.派生类的默认成员函数</a></li><li><ul><li><a href="#_366" rel="nofollow">✨构造函数</a></li><li><a href="#_423" rel="nofollow">✨拷贝构造</a></li><li><a href="#_452" rel="nofollow">✨赋值运算符重载</a></li><li><a href="#_456" rel="nofollow">✨析构函数</a></li></ul> 
  </li><li><a href="#6_503" rel="nofollow">6.结语</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1_7"></a>1.继承的概念</h2> 
<p><strong>继承(inheritance)机制</strong>是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上<strong>进行扩展</strong>，增加功能，这样产生新的类，称<strong>派生类</strong>或<strong>子类</strong>。继承呈现了面向对象程序设计的层次结构，体现了由简单到复杂的认知过程。以前我们接触的复用都是函数复用，继承是<strong>类设计层次</strong>的复用。</p> 
<h2><a id="2_10"></a>2.继承定义</h2> 
<h3><a id="21_11"></a>2.1定义格式</h3> 
<p>下面我们看到Person是父类，也称作基类。Student是子类，也称作派生类。</p> 
<pre><code class="prism language-cpp"><span class="token comment">//基类或父类</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"name:"</span> <span class="token operator">&lt;&lt;</span> _name <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"age:"</span> <span class="token operator">&lt;&lt;</span> _age <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	string _name <span class="token operator">=</span> <span class="token string">"peter"</span><span class="token punctuation">;</span><span class="token comment">// 姓名</span>
	<span class="token keyword">int</span> _age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>  <span class="token comment">//年龄</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//派生类或子类</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _stuid<span class="token punctuation">;</span> <span class="token comment">// 学号</span>
	<span class="token keyword">int</span> _major<span class="token punctuation">;</span>	<span class="token comment">//专业</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/0c/9b/G2hPo1a2_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="22_42"></a>2.2访问限定符</h3> 
<p>C++类的访问限定符用于控制类的成员（包括成员变量和成员函数）在<strong>类的外部的</strong>可访问性。C++中有以下三种访问限定符：</p> 
<ul><li> <p>public: 公共访问限定符，任何地方都可以访问公共成员。可以在类的外部使用对象名和成员名直接访问公共成员。</p> </li><li> <p>private: 私有访问限定符，只有<strong>类内部</strong>的其他成员函数可以访问私有成员。类的外部无法直接访问私有成员，但可以通过公共成员函数<strong>间接</strong>访问私有成员。</p> </li><li> <p>protected: 保护访问限定符，只有<strong>类内部</strong>的其他成员函数和<strong>派生类</strong>的成员函数可以访问保护成员。类的外部无法直接访问保护成员，但可以通过公共成员函数或派生类的成员函数间接访问保护成员。</p> </li></ul> 
<p>需要注意的是，访问限定符只在类的内部起作用，在类的外部没有直接的影响。同时，访问限定符可以用于类的成员变量和成员函数的声明中，默认情况下，成员变量和成员函数的访问限定符是private。</p> 
<h3><a id="23_53"></a>2.3继承方式</h3> 
<p><img src="https://images2.imgbox.com/0b/2e/0gxU4oGs_o.png" alt="在这里插入图片描述"><br> C++类的继承方式有以下几种：</p> 
<ul><li>公有继承（public inheritance）：使用关键字"public"表示的继承方式。在公有继承中，基类的公有成员和保护成员都可以在派生类中访问，<strong>私有成员</strong>不能在派生类中直接访问。</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 公有成员</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token comment">// 保护成员</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token comment">// 私有成员</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 公有继承</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>保护继承（protected inheritance）：使用关键字"protected"表示的继承方式。在保护继承中，基类的公有成员和保护成员在派生类中都变为<strong>保护成员</strong>，<strong>私有成员</strong>不能在派生类中直接访问。</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 公有成员</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token comment">// 保护成员</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token comment">// 私有成员</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">protected</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 保护继承</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>私有继承（private inheritance）：使用关键字"private"表示的继承方式。在私有继承中，基类的公有成员和保护成员在派生类中都变为<strong>私有成员</strong>，私有成员不能在派生类中直接访问。</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 公有成员</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token comment">// 保护成员</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token comment">// 私有成员</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">private</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 私有继承</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>总结如下：</p> 
<table><thead><tr><th>类成员/继承方式</th><th>public继承</th><th>protected继承</th><th>private继承</th></tr></thead><tbody><tr><td>基类的public成员</td><td>派生类的public成员</td><td>派生类的protected成员</td><td>派生类的private成员</td></tr><tr><td>基类的protected成员</td><td>派生类的protected成员</td><td>派生类的protected成员</td><td>派生类的private成员</td></tr><tr><td>基类的private成员</td><td>在派生类中不可见</td><td>在派生类中不可见</td><td>在派生类中不可见</td></tr></tbody></table> 
<p>①基类的其他成员在子类的访问方式 == Min(成员在基类的访问限定符，继承方式)，<code>public &gt; protected &gt; private</code></p> 
<blockquote> 
 <p>这些继承方式可以根据具体的需求选择合适的方式</p> 
</blockquote> 
<p>②基类private成员在派生类中无论以什么方式继承都是不可见的。这里的不可见是指基类的私有成员<strong>还是被继承</strong>到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类外面都<strong>不能去访问它</strong>。</p> 
<p>例如：</p> 
<pre><code class="prism language-cpp"><span class="token comment">//基类或父类</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"name:"</span> <span class="token operator">&lt;&lt;</span> _name <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"age:"</span> <span class="token operator">&lt;&lt;</span> _age <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token comment">//保护成员</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	string _name <span class="token operator">=</span> <span class="token string">"tutu"</span><span class="token punctuation">;</span><span class="token comment">// 姓名</span>
	<span class="token keyword">int</span> _age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>  <span class="token comment">//年龄</span>

<span class="token comment">//私有成员</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	string _tele <span class="token operator">=</span> <span class="token string">"123456"</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//派生类或子类</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">sPrint</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token class-name">Person</span><span class="token double-colon punctuation">::</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//可以使用父类的公有成员</span>
	<span class="token punctuation">}</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _stuid<span class="token punctuation">;</span> <span class="token comment">// 学号</span>
	string _sname <span class="token operator">=</span> _name<span class="token punctuation">;</span><span class="token comment">//可以访问父类的保护成员_name</span>

	string _stele <span class="token operator">=</span> _tele<span class="token punctuation">;</span> <span class="token comment">//不可以访问父类的私有成员_tele</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>结果如下：<br> <img src="https://images2.imgbox.com/0e/49/wdGYxljt_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>上述父类Person中成员有三种访问限定分别是public、protected、private，而子类Student使用public继承父类，那么对于父类的公有成员在子类中的访问方式还是public，protected成员访问方式选择继承方式public和protected中较小的protected，同理父类的private成员继承到子类中也是选择private方式，在子类中不可访问</p> 
</blockquote> 
<p>对于私有成员也是被继承到子类中，只是不可访问：</p> 
<p><img src="https://images2.imgbox.com/3c/21/NnCr7Faa_o.png" alt="在这里插入图片描述"></p> 
<p>③基类private成员在派生类中是不能被访问，如果基类成员不想在类外直接被访问，但需要在派生类中能访问，就定义为protected。可以看出保护成员限定符是因继承才出现的。</p> 
<p>④ 使用关键字<code>class</code>时默认的继承方式是<code>private</code>，使用<code>struct</code>时默认的继承方式是<code>public</code>，不过最好显示的写出继承方式。</p> 
<p>⑤在实际运用中一般使用都是<code>public</code>继承，几乎很少使用protetced/private继承，也不提倡使用protetced/private继承，因为protetced/private继承下来的成员都只能在派生类的类里面使用，实际中扩展维护性不强。</p> 
<h2><a id="3_175"></a>3.基类和派生类对象赋值转换</h2> 
<ul><li>派生类对象可以赋值给基类的对象 / 基类的指针 / 基类的引用。这里有个形象的说法叫<strong>切片</strong>或者<strong>切割</strong>。寓意把派生类中父类那部分切来赋值过去。</li></ul> 
<p>如下图所示：</p> 
<p><img src="https://images2.imgbox.com/2b/77/Kn9qUg5l_o.png" alt="在这里插入图片描述"></p> 
<ul><li>基类对象不能赋值给派生类对象</li></ul> 
<p>例如下面代码：</p> 
<pre><code class="prism language-cpp"><span class="token comment">//父类</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	string _name<span class="token punctuation">;</span> <span class="token comment">// 姓名</span>
	string _sex<span class="token punctuation">;</span>  <span class="token comment">//性别</span>
	<span class="token keyword">int</span> _age<span class="token punctuation">;</span> <span class="token comment">// 年龄</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//子类</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _No<span class="token punctuation">;</span> <span class="token comment">// 学号</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Student sobj<span class="token punctuation">;</span>
	<span class="token comment">// 1.子类对象可以赋值给父类对象/指针/引用</span>
	Person pobj <span class="token operator">=</span> sobj<span class="token punctuation">;</span>
	Person<span class="token operator">*</span> pp <span class="token operator">=</span> <span class="token operator">&amp;</span>sobj<span class="token punctuation">;</span>
	Person<span class="token operator">&amp;</span> rp <span class="token operator">=</span> sobj<span class="token punctuation">;</span>

	<span class="token comment">//2.基类对象不能赋值给派生类对象</span>
	sobj <span class="token operator">=</span> pobj<span class="token punctuation">;</span><span class="token comment">//error</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/26/11/uehwHK5Z_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="4_215"></a>4.继承中的重定义(隐藏)</h2> 
<ul><li>在继承体系中基类和派生类都有独立的作用域。</li><li>子类和父类中有<strong>同名成员</strong>，子类成员将屏蔽对父类同名成员的直接访问，这种情况叫隐藏，也叫重定义。</li></ul> 
<blockquote> 
 <p>当一个类继承另一个类时，它可以重定义继承的成员函数或者成员变量。<br> 需要注意的是如果是成员函数的隐藏，只需要<strong>函数名相同</strong>就构成隐藏。</p> 
</blockquote> 
<ul><li>如果要访问被隐藏的父类的同名成员，可以在子类成员函数中，使用 <code>父类::父类成员</code>来显示访问</li></ul> 
<blockquote> 
 <p>注意在实际中在继承体系里面最好不要定义同名的成员。</p> 
</blockquote> 
<p>例如：</p> 
<pre><code class="prism language-cpp"><span class="token comment">// Student的_num和Person的_num构成隐藏关系，可以看出这样代码虽然能跑，但是非常容易混淆</span>
<span class="token comment">//父类</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	string _name <span class="token operator">=</span> <span class="token string">"胡土土"</span><span class="token punctuation">;</span> <span class="token comment">// 姓名</span>
	<span class="token keyword">int</span> _num <span class="token operator">=</span> <span class="token number">1234</span><span class="token punctuation">;</span> <span class="token comment">// 身份证号</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//子类</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">" 姓名:"</span> <span class="token operator">&lt;&lt;</span> _name <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">" 身份证号:"</span> <span class="token operator">&lt;&lt;</span> Person<span class="token double-colon punctuation">::</span>_num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">" 学号:"</span> <span class="token operator">&lt;&lt;</span> _num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _num <span class="token operator">=</span> <span class="token number">999</span><span class="token punctuation">;</span> <span class="token comment">// 学号，与父类的_num重名构成隐藏</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Student s1<span class="token punctuation">;</span>
	s1<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>结果如下：</p> 
<p><img src="https://images2.imgbox.com/cd/4c/d36YqK30_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>我们发现当子类与父类有隐藏关系时，对于同名变量_num的调用，除非显示使用<code>Person::_num</code> 调用的是父类的成员变量，其他情况_num表示的都得子类中定义的变量，这是因为它们有不同的作用域，在子类中调用变量都是先从子类这个作用域中寻找。</p> 
</blockquote> 
<p>再看下面的例子：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"func(int i)-&gt;"</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	B b<span class="token punctuation">;</span>
	b<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>这里 B中的fun和A中的fun不是构成重载，因为不是在同一作用域<br> B中的fun和A中的fun构成隐藏，<strong>成员函数满足函数名相同</strong>就构成隐藏。</p> 
</blockquote> 
<p>结果如下：</p> 
<p><img src="https://images2.imgbox.com/1f/78/oMtvxq8t_o.png" alt="在这里插入图片描述"><br> 如果Test函数中：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	B b<span class="token punctuation">;</span>
	b<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这里没有给参数</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>结果如下：</p> 
<p><img src="https://images2.imgbox.com/58/3c/o2BliY1L_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>使用对象b调用fun()没有给参数，这样编译是不通过的，因为这样调用是调用的类B中的成员函数fun是需要传参的，如果要调用基类中的fun函数就必须显示调用，代码如下：</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	B b<span class="token punctuation">;</span>
	b<span class="token punctuation">.</span><span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//显示调用A中的fun函数</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>结果如下：<br> <img src="https://images2.imgbox.com/d6/27/zvOzeV8K_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="5_323"></a>5.派生类的默认成员函数</h2> 
<p><img src="https://images2.imgbox.com/e1/56/YRjsos0b_o.png" alt="在这里插入图片描述"></p> 
<p>6个默认成员函数，“默认”的意思就是指我们不写，编译器会变我们自动生成一个，那么在派生类中，(先不考虑取地址重载)这几个成员函数是如何生成的呢？</p> 
<p>例如如下父类：</p> 
<pre><code class="prism language-cpp"><span class="token comment">//有如下Person父类</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name <span class="token operator">=</span> <span class="token string">"tutu"</span><span class="token punctuation">)</span>
		<span class="token operator">:</span> <span class="token function">_name</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Person()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">const</span> Person<span class="token operator">&amp;</span> p<span class="token punctuation">)</span>
		<span class="token operator">:</span> <span class="token function">_name</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>_name<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Person(const Person&amp; p)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	Person<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Person<span class="token operator">&amp;</span> p<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Person operator=(const Person&amp; p)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>p<span class="token punctuation">)</span>
			_name <span class="token operator">=</span> p<span class="token punctuation">.</span>_name<span class="token punctuation">;</span>

		<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token operator">~</span><span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~Person()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	string _name<span class="token punctuation">;</span> <span class="token comment">// 姓名</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre> 
<h3><a id="_366"></a>✨构造函数</h3> 
<ul><li>派生类的构造函数必须调用<strong>基类的默认构造函数</strong>初始化基类的那一部分成员。如果基类没有默认的构造函数，则必须在派生类构造函数的初始化列表阶段<strong>显示调用</strong>基类的构造函数。</li></ul> 
<pre><code class="prism language-cpp"><span class="token comment">//基于上面Person的派生类Student</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _num<span class="token punctuation">;</span> <span class="token comment">//学号</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Student s<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>结果如下：<br> <img src="https://images2.imgbox.com/e7/ac/ij8p1OH8_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/b7/00/Wq9jnGVN_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>我们发现对于父类中的成员它会自动调用父类Person的默认构造函数与析构函数</p> 
</blockquote> 
<ul><li>如果父类Person没有默认构造函数，那么我们就需要在初始化列表里显示调用父类的构造函数<br> 例如：<br> <img src="https://images2.imgbox.com/60/e5/18CBg6oT_o.png" alt="在这里插入图片描述"></li></ul> 
<blockquote> 
 <p>当我们将基类的默认构造函数中的缺省值"tutu"，去掉，它就不再是默认构造函数，那么在创建子类Student对象时就不会自动调用默认构造函数，会保错，那么这时我们就需要在初始化列表里显示调用</p> 
</blockquote> 
<p>代码如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Student</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>	<span class="token comment">//显示调用父类构造函数</span>
		<span class="token punctuation">,</span> <span class="token function">_num</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>	
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _num<span class="token punctuation">;</span> <span class="token comment">//学号</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	Student <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">"tutu"</span><span class="token punctuation">,</span> <span class="token number">111</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>结果如下：<br> <img src="https://images2.imgbox.com/e6/1a/X6F5K8PM_o.png" alt="在这里插入图片描述"></p> 
<p>还有一种显示调用情况：</p> 
<p><img src="https://images2.imgbox.com/d4/db/dPkCjGi1_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>这种情况是不可取的，这是因为规定在初始化列表中是不可以使用父类的成员的</p> 
</blockquote> 
<h3><a id="_423"></a>✨拷贝构造</h3> 
<ul><li>派生类的拷贝构造函数必须调用<strong>基类的拷贝构造</strong>完成基类的拷贝初始化。</li></ul> 
<blockquote> 
 <p>默认生成拷贝构造一般情况下够用，只有当子类成员涉及深拷贝时就必须自己实现拷贝构造</p> 
</blockquote> 
<p>这里也可以自己显示实现一下拷贝构造：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">//构造函数</span>
	<span class="token function">Student</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>	<span class="token comment">//显示调用父类构造函数</span>
		<span class="token punctuation">,</span> <span class="token function">_num</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>	

	<span class="token comment">//拷贝构造</span>
	<span class="token function">Student</span><span class="token punctuation">(</span><span class="token keyword">const</span> Student<span class="token operator">&amp;</span> st<span class="token punctuation">)</span>
		<span class="token operator">:</span><span class="token function">Person</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span>	<span class="token comment">//利用前面学习的基类与派生类的赋值转换</span>
		<span class="token punctuation">,</span><span class="token function">_num</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span>_num<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">int</span> _num<span class="token punctuation">;</span> <span class="token comment">//学号</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>注意这里<code>Person(st)</code>中调用Person中的拷贝构造实现赋值兼容</p> 
</blockquote> 
<h3><a id="_452"></a>✨赋值运算符重载</h3> 
<ul><li>派生类的<code>operator=</code>必须要调用基类的<code>operator=</code>完成基类的复制。</li></ul> 
<h3><a id="_456"></a>✨析构函数</h3> 
<ul><li>派生类的析构函数会在被调用完成后自动调用<strong>基类的析构函数</strong>清理基类成员。因为这样才能保证派生类对象先清理派生类成员再清理基类成员的顺序。</li></ul> 
<p>如果自己显示写析构函数：</p> 
<pre><code class="prism language-cpp"><span class="token comment">//析构函数</span>
<span class="token operator">~</span><span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token operator">~</span><span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这样写是错误的</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>因为多态的原因，析构函数的名字会被统一处理为destructor(),所以这里调用会构成隐藏，会循环调用，所以要指定作用域：</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token comment">//析构函数</span>
<span class="token operator">~</span><span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token class-name">Person</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~Student()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>但是我们发现Person的析构函数居然调用了两次：</p> 
<p><img src="https://images2.imgbox.com/ec/67/GU88ziWd_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>这是因为析构函数具有特殊性，在子类析构函数调用完之后会自动调用父类的析构函数，所以即便是自己显示实现了子类的析构函数也不需要自己主动调用父类的析构函数</p> 
</blockquote> 
<p>所以不需要自己主动调用父类的析构函数，否则会报错</p> 
<blockquote> 
 <p>其核心原因在于初始化时先构造父类再构造子类，而析构时先析构子类再析构父类，因为子类析构时是可能用到父类成员的，先父后子可能会出错</p> 
</blockquote> 
<p>所以为了保证先析构子类再析构父类，编译器会在析构了子类后自动调用父类的析构函数</p> 
<p>总结如下：</p> 
<table><thead><tr><th>默认成员函数\子类成员</th><th>内置成员</th><th>自定义成员</th><th>子类中的父类成员(整体)</th></tr></thead><tbody><tr><td>默认生成的构造</td><td>不做处理</td><td>调用自定义类型的默认构造</td><td>调用父类的默认构造</td></tr><tr><td>默认生成的拷贝构造</td><td>值拷贝</td><td>调用自定义类型的拷贝构造</td><td>调用父类的拷贝构造</td></tr><tr><td>默认生成的赋值重载</td><td>直接赋值</td><td>调用自定义类型的赋值重载</td><td>调用父类的赋值重载</td></tr><tr><td>默认生成的析构函数</td><td>不做处理</td><td>调用自定义类型的析构函数</td><td>自动调用父类的析构函数</td></tr></tbody></table> 
<blockquote> 
 <p>对于构造和析构：<br> 派生类对象初始化<strong>先调用基类构造</strong>再调派生类构造。<br> 派生类对象析构清理<strong>先调用派生类析构</strong>再调基类的析构</p> 
</blockquote> 
<h2><a id="6_503"></a>6.结语</h2> 
<p>继承可以分为公有继承（public inheritance）、保护继承（protected inheritance）和私有继承（private inheritance）。继承在C++中的应用非常广泛，可以用于构建复杂的类层次结构，提供代码的复用性和灵活性。但是，在使用继承时也需要注意避免多层次的继承导致的类关系复杂性增加，以及合理设计基类和派生类之间的关系。以上就是今天的所以内容啦~ 完结撒花~ 🥳🎉🎉</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e8b5ffc891b34ede354bd3e9ae94d9be/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">分治精炼宝库-----快速排序运用(⌯꒪꒫꒪)੭</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/82c074d07b08a83632376539790443ef/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C&#43;&#43;】 ——【模板初阶】——基础详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>