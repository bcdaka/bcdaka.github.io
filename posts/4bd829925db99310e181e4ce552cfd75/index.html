<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【WebSocket连接异常】前端使用WebSocket子协议传递token时，Java后端的正确打开方式！！！ - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4bd829925db99310e181e4ce552cfd75/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【WebSocket连接异常】前端使用WebSocket子协议传递token时，Java后端的正确打开方式！！！">
  <meta property="og:description" content="文章目录 1. 背景2. 代码实现和异常发现3. 解决异常3.1 从 URL入手3.2 从 WebSocket子协议的使用方式入手（真正原因） 4. 总结（仍然存在的问题） 前言：
本篇文章记录的是使用WebSocket进行双向通信时踩过的坑，希望能够帮助大家找到解决连接异常的正确方法。
1. 背景 本人在使用WebSocket实现“聊天室”的实时双向通信时（发消息、添加好友、处理好友请求等），一开始使用 cookie &#43; session 的方式来管理用户的上下线情况，后来想引入 JWT，使用 token的方式来增强系统的可用性。这时我遇到了一个问题，大部分的接口都是使用 HTTP 协议的方式传输数据，因此我们可以将令牌放在 Header中用于身份校验；而 WebSocket进行双向通信时，前端无法直接在 header添加token。
经过网上查阅资料可知，有其他的方式可以在 HTTP升级为WebSocket时携带 token：（1）在 URL中追加 token（2）使用WebSocket的子协议传递 token。（通过抓包可以知道，token放在Header的 “Sec-WebSocket-Protocol” 中）
2. 代码实现和异常发现 考虑到 token直接暴露在 url 的安全性及优雅性等因素，我最终选择使用 WebSocket子协议来传递 token。以下是个人操作的过程及心路历程，若只想知道解决方法，可直接查看 3.2 从 WebSocket子协议的使用方式入手。
前端代码如下：
var token = localStorage.getItem(&#34;token&#34;); let websocket = new WebSocket(&#34;ws://&#34; &#43; location.host &#43; &#34;/WebSocketMessage&#34;, [token]); 对于后端来说，可以使用自定义拦截器来验证并处理token（存储token信息，以便后续在WebSocketSession中处理消息时使用），具体方法是自定义类继承 HandshakeInterceptor ，并重写它的两个方法。
建立连接前处理token的代码如下：
@Component public class SaveTokenInterceptor implements HandshakeInterceptor { // 握手前的操作，该方法返回 true 代表同意建立 WebSocket连接，false代表拒绝建立连接 @Override public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes) throws Exception { // HTTP协议 未正式升级为 WebSocket时，可以对 HTTP 报文中的信息进行一定的处理 // 1.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-13T18:51:12+08:00">
    <meta property="article:modified_time" content="2024-04-13T18:51:12+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【WebSocket连接异常】前端使用WebSocket子协议传递token时，Java后端的正确打开方式！！！</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1__7" rel="nofollow">1. 背景</a></li><li><a href="#2__11" rel="nofollow">2. 代码实现和异常发现</a></li><li><a href="#3__114" rel="nofollow">3. 解决异常</a></li><li><ul><li><a href="#31__URL_115" rel="nofollow">3.1 从 URL入手</a></li><li><a href="#32__WebSocket_171" rel="nofollow">3.2 从 WebSocket子协议的使用方式入手（真正原因）</a></li></ul> 
  </li><li><a href="#4__226" rel="nofollow">4. 总结（仍然存在的问题）</a></li></ul> 
</div> 
<p></p> 
<p><strong>前言</strong>：<br> 本篇文章记录的是使用WebSocket进行双向通信时踩过的坑，希望能够帮助大家找到解决连接异常的正确方法。</p> 
<hr> 
<h2><a id="1__7"></a>1. 背景</h2> 
<p>本人在使用WebSocket实现“聊天室”的实时双向通信时（发消息、添加好友、处理好友请求等），一开始使用 cookie + session 的方式来管理用户的上下线情况，后来想引入 JWT，使用 token的方式来增强系统的可用性。这时我遇到了一个问题，大部分的接口都是使用 HTTP 协议的方式传输数据，因此我们可以将令牌放在 Header中用于身份校验；而 WebSocket进行双向通信时，前端无法直接在 header添加token。<br> 经过网上查阅资料可知，有其他的方式可以在 HTTP升级为WebSocket时携带 token：（1）在 URL中追加 token（2）使用WebSocket的子协议传递 token。（通过抓包可以知道，token放在Header的 “Sec-WebSocket-Protocol” 中）</p> 
<h2><a id="2__11"></a>2. 代码实现和异常发现</h2> 
<p>考虑到 token直接暴露在 url 的安全性及优雅性等因素，我最终选择使用 WebSocket子协议来传递 token。以下是个人操作的过程及心路历程，若只想知道解决方法，可直接查看 <mark>3.2 从 WebSocket子协议的使用方式入手</mark>。</p> 
<p>前端代码如下：</p> 
<pre><code class="prism language-javascript"><span class="token keyword">var</span> token <span class="token operator">=</span> localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">"token"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> websocket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSocket</span><span class="token punctuation">(</span><span class="token string">"ws://"</span> <span class="token operator">+</span> location<span class="token punctuation">.</span>host <span class="token operator">+</span> <span class="token string">"/WebSocketMessage"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>token<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>对于后端来说，可以使用自定义拦截器来验证并处理token（存储token信息，以便后续在WebSocketSession中处理消息时使用），具体方法是自定义类继承 <code>HandshakeInterceptor</code> ，并重写它的两个方法。<br> <strong>建立连接前处理token的代码如下</strong>：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SaveTokenInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">HandshakeInterceptor</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 握手前的操作，该方法返回 true 代表同意建立 WebSocket连接，false代表拒绝建立连接</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">beforeHandshake</span><span class="token punctuation">(</span><span class="token class-name">ServerHttpRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">ServerHttpResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">WebSocketHandler</span> wsHandler<span class="token punctuation">,</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> attributes<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{<!-- --></span>
    	<span class="token comment">// HTTP协议 未正式升级为 WebSocket时，可以对 HTTP 报文中的信息进行一定的处理</span>
        <span class="token comment">// 1. 从 header中获取子协议的token，若token为空、过期或非法的，则拒绝建立 WebSocket连接</span>
        <span class="token class-name">String</span> token <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeaders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token string">"Sec-WebSocket-Protocol"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Claims</span> claims <span class="token operator">=</span> <span class="token class-name">JwtUtil</span><span class="token punctuation">.</span><span class="token function">parseToken</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 解析令牌</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>claims <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

        <span class="token comment">// 2. 将 token 中的信息放入到 attributes属性中，后续 WebSoketSession可通过方法获取 attributes，进而获取里面存放的信息</span>
        <span class="token keyword">int</span> id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> claims<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Constant</span><span class="token punctuation">.</span><span class="token constant">CLAIM_USERID</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> username <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> claims<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Constant</span><span class="token punctuation">.</span><span class="token constant">CLAIM_USERNAME</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        attributes<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">Constant</span><span class="token punctuation">.</span><span class="token constant">USER_TOKEN_KEY</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> username<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    <span class="token comment">// 握手完成后的操作</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterHandshake</span><span class="token punctuation">(</span><span class="token class-name">ServerHttpRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">ServerHttpResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">WebSocketHandler</span> wsHandler<span class="token punctuation">,</span> <span class="token class-name">Exception</span> exception<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>连接完成后，查看 WebSocketSession 是否能够正确拿到存储到 attributes 中的属性(通过第一个方法查看)</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Component</span>
<span class="token annotation punctuation">@Slf4j</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestWebSocket</span> <span class="token keyword">extends</span> <span class="token class-name">TextWebSocketHandler</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 这个方法会在 WebSocket建立成功后被自动调用</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterConnectionEstablished</span><span class="token punctuation">(</span><span class="token class-name">WebSocketSession</span> session<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"[WebSocketAPI] 连接成功!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// session.getAttributes() 得到一个 Map</span>
        <span class="token comment">// 里面的元素为之前服务器Session存储的Attribute或放进去的其他自定义信息（上述处理token后存储的User对象）</span>
        <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">User</span><span class="token punctuation">)</span> session<span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Constant</span><span class="token punctuation">.</span><span class="token constant">USER_TOKEN_KEY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"[WebSocketAPI] afterConnectionEstablished, user: "</span> <span class="token operator">+</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 验证是否将token信息放进去了</span>
        
        <span class="token keyword">if</span><span class="token punctuation">(</span>user <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"用户未登录!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 往 hash表 中存储对应客户端的WebSocket对象</span>
        onlineUserManager<span class="token punctuation">.</span><span class="token function">online</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> session<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">handleTextMessage</span><span class="token punctuation">(</span><span class="token class-name">WebSocketSession</span> session<span class="token punctuation">,</span> <span class="token class-name">TextMessage</span> message<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 这个方法是在 websocket 收到消息后被自动调用</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"[WebSocketAPI] 收到消息! "</span> <span class="token operator">+</span> message<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 这个方法是在连接出现异常时被自动调用</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleTransportError</span><span class="token punctuation">(</span><span class="token class-name">WebSocketSession</span> session<span class="token punctuation">,</span> <span class="token class-name">Throwable</span> exception<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"[WebSocketAPI] 连接异常! "</span> <span class="token operator">+</span> exception<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">User</span><span class="token punctuation">)</span> session<span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Constant</span><span class="token punctuation">.</span><span class="token constant">USER_TOKEN_KEY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>user <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        onlineUserManager<span class="token punctuation">.</span><span class="token function">offline</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> session<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    <span class="token comment">// 这个方法是在连接正常关闭后被自动调用</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterConnectionClosed</span><span class="token punctuation">(</span><span class="token class-name">WebSocketSession</span> session<span class="token punctuation">,</span> <span class="token class-name">CloseStatus</span> status<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"[WebSocketAPI] 关闭! "</span> <span class="token operator">+</span> status<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">User</span><span class="token punctuation">)</span> session<span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Constant</span><span class="token punctuation">.</span><span class="token constant">USER_TOKEN_KEY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>user <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        onlineUserManager<span class="token punctuation">.</span><span class="token function">offline</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> session<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>通过抓包及后端控制台日志观察上述过程：<br> <img src="https://images2.imgbox.com/86/f4/QMuOThJO_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/74/69/d7wlPZc4_o.png" alt="在这里插入图片描述"><br> 可以发现：WebSocketSession 已经能够正确拿到 token里的信息，但是控制台也出现了<strong>WebSocket连接异常</strong> 和<strong>token校验失败</strong>两个异常现象。（通过浏览器控制台也可发现连接异常）</p> 
<p><img src="https://images2.imgbox.com/24/f5/eidtlyAd_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h2><a id="3__114"></a>3. 解决异常</h2> 
<h3><a id="31__URL_115"></a>3.1 从 URL入手</h3> 
<p>首先，token校验失败原因比较简单，一般是在拦截器拦截 HTTP请求时发生，于是我通过抓包进行分析，但是令人感到奇怪的是所有 HTTP 请求均正常携带了 token，为什么会出现令牌解析不成功的情况呢？</p> 
<p>经过一番思考，我决定在拦截器拦截请求时，通过 request获取所有经过拦截器的 HTTP请求的 URL，通过打印每个 HTTP 请求的URL及Header携带的 token 分析是否是前端 WebSocket 使用了子协议而导致被拦截器拦截，从而导致的异常。</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoginInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerInterceptor</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">String</span> requestURI <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getRequestURI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 在方法执行前进行拦截，此处判断哪些方法可以被执行</span>
        <span class="token comment">// 从 header中的token 判断用户是否登录</span>
        <span class="token class-name">String</span> token <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token class-name">Constant</span><span class="token punctuation">.</span><span class="token constant">USER_TOKEN_HEADER</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>requestURI<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">JwtUtil</span><span class="token punctuation">.</span><span class="token function">parseToken</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            response<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token number">401</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/29/5e/pujX6fpF_o.png" alt="在这里插入图片描述"></p> 
<p>可以发现：上面的 HTTP 请求都符合预期，出现异常是使用 token 验证用户身份时，由浏览器默认发起的 favicon/ico（GET请求）并不会像其他 HTTP 请求一样，在其 Header 上携带 token，因此出现了令牌校验失败的情况。</p> 
<p>通过上述偶然出现的异常也可以发现该程序上的一个问题，若一个 HTTP 的 Header 没有携带 token（即 token == null）就不需要进行令牌解析了，直接拦截即可。</p> 
<p>因此只需将上述拦截器的拦截规则多做一个判断即可解决令牌解析的异常。（代码如下）</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoginInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerInterceptor</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">String</span> requestURI <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getRequestURI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 在方法执行前进行拦截，此处判断哪些方法可以被执行</span>
        <span class="token comment">// 从 header中的token 判断用户是否登录</span>
        <span class="token class-name">String</span> token <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token class-name">Constant</span><span class="token punctuation">.</span><span class="token constant">USER_TOKEN_HEADER</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>token <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token class-name">JwtUtil</span><span class="token punctuation">.</span><span class="token function">parseToken</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            response<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token number">401</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h3><a id="32__WebSocket_171"></a>3.2 从 WebSocket子协议的使用方式入手（真正原因）</h3> 
<p>由于抓包并不能找到问题出现的原因，因此我查阅了 WebSocket 子协议的相关使用方式发现：<mark>如果前端使用了子协议携带了 token，在 WebSocket连接完成后，返回的响应报文应该携带相同的子协议内容。</mark></p> 
<p>因此我立马通过抓包查看了响应报文：<br> <img src="https://images2.imgbox.com/b4/43/xvIXiL7C_o.png" alt="在这里插入图片描述"></p> 
<p>可以发现，响应报文确实没有携带对应的 Header，为了验证 WebSocket连接异常的原因导致及上述说法的正确性，我对代码作出了如下修改：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SaveTokenInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">HandshakeInterceptor</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 握手前的操作</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">beforeHandshake</span><span class="token punctuation">(</span><span class="token class-name">ServerHttpRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">ServerHttpResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">WebSocketHandler</span> wsHandler<span class="token punctuation">,</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> attributes<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 1. 从 header中获取子协议的token，若token为空、过期或非法的，则拒绝建立 WebSocket连接</span>
        <span class="token class-name">String</span> token <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeaders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token string">"Sec-WebSocket-Protocol"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"[SaveTokenInterceptor] beforeHandshake方法，token: "</span> <span class="token operator">+</span> token<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Claims</span> claims <span class="token operator">=</span> <span class="token class-name">JwtUtil</span><span class="token punctuation">.</span><span class="token function">parseToken</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>claims <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

        <span class="token comment">// 2. 将 id 和 username 存入WebSocket的 attributes中</span>
        <span class="token keyword">int</span> id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> claims<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Constant</span><span class="token punctuation">.</span><span class="token constant">CLAIM_USERID</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> username <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> claims<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Constant</span><span class="token punctuation">.</span><span class="token constant">CLAIM_USERNAME</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        attributes<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">Constant</span><span class="token punctuation">.</span><span class="token constant">USER_TOKEN_KEY</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> username<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    <span class="token comment">// 握手完成后的操作</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterHandshake</span><span class="token punctuation">(</span><span class="token class-name">ServerHttpRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">ServerHttpResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">WebSocketHandler</span> wsHandler<span class="token punctuation">,</span> <span class="token class-name">Exception</span> exception<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 获取 Servlet 的 HttpServletRequest 和 HttpServletResponse 对象</span>
        <span class="token comment">// httpRequest 可以获取 HTTP协议升级前 请求报文的信息，如 header中的键值对等</span>
        <span class="token comment">// httpResponse 可以设置 HTTP响应 的相关信息，如状态码、ContentType、header信息等</span>
        <span class="token class-name">HttpServletRequest</span> httpRequest <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ServletServerHttpRequest</span><span class="token punctuation">)</span> request<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getServletRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">HttpServletResponse</span> httpResponse <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ServletServerHttpResponse</span><span class="token punctuation">)</span> response<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getServletResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>httpRequest<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">"Sec-WebSocket-Protocol"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            httpResponse<span class="token punctuation">.</span><span class="token function">addHeader</span><span class="token punctuation">(</span><span class="token string">"Sec-WebSocket-Protocol"</span><span class="token punctuation">,</span> httpRequest<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">"Sec-WebSocket-Protocol"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上述代码即在 WebSocket 连接完成后，针对响应增加了一个子协议的 header。</p> 
<p>注意：无法直接通过 afterHandshake 方法参数的 ServerHttpResponse 修改响应内容，因为该接口并没有提供修改响应的方法。由于ServerHttpResponse是一个接口，通过源码我们可以发现：<br> <mark>ServletServerHttpResponse类 实现了该接口，且在Spring中 ServletServerHttpResponse 对 Servlet的 HttpServletResponse 类进行了封装，因此我们可以将 方法参数中的 response 强转为底层的实现类ServletServerHttpResponse，再通过 ServletServerHttpResponse 类中的方法获取封装的 HttpServletResponse 类，然后就可以使用该类设置响应报文的内容。</mark><br> <img src="https://images2.imgbox.com/12/d7/prixGEhm_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/64/8f/ldaEwjeA_o.png" alt="在这里插入图片描述"></p> 
<p>对代码作出上述修改后，运行程序的结果如下：<br> <img src="https://images2.imgbox.com/6f/17/akof0WA8_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/71/fe/N1h07St2_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="4__226"></a>4. 总结（仍然存在的问题）</h2> 
<p>通过上述修改后，已经能够使用 token 验证用户身份，管理用户上下线情况，但仍然存在问题：</p> 
<ol><li>在使用 cookie-session 验证用户登录状态和上下线状态时，服务器重启重启会导致存储在内存的 session 消失，因此用户后续的任何请求都可能触发拦截器的拦截操作，需重新进行登录才能正常进行后续的操作。</li></ol> 
<p>而对于使用 token 来代替 cookie-session，虽然触发 HTTP 请求的操作能够做到 “用户无感知”，即服务器因某种原因重启后，用户不用二次登录依然可以完成操作；但对于使用 WebSocket 进行实时通信的消息转发、好友请求转发等功能来说，该程序使用 ConcurrentHashMap 来存储 WebSocketSession，服务器一旦重启，哈希表保存的登录信息就没了，这部分功能也因此直接“<strong>失效</strong>”了。</p> 
<p>要想解决这个问题，可能需要引入 Redis 这样的中间件或使用其他的机制来实现 WebSocket 重连，以保证用户的使用体验。</p> 
<ol start="2"><li>当令牌达到过期时间，而用户没有触发发送 HTTP 请求的操作，而是进行发送消息这种操作，那么上述存储用户信息的方式则是<mark>错误</mark>的，因为这种做法虽然可以让接口代码只有小幅度修改，但会出现用户令牌虽然过期了但 ConcurrentHashMap 存储的 WebSocketSession 并不会被立即移除的情况，仍然能够进行消息发送（上一次操作停留在对话框界面）。</li></ol> 
<hr> 
<p>以上就是本篇文章的全部内容了，如果这篇文章对你有些许帮助，你的点赞、收藏和评论就是对我最大的支持。<br> 另外，文章可能存在许多不足之处，也希望你可以给我一点小小的建议，我会努力检查并改进。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/484231899cb6dde8698ed418a0376912/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【小白视角】大数据基础实践（七） Spark的基本操作_spark操作类型</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/76a1ec1c6fb027f071a2d90e97d82471/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Xcode 15.0 新 #Preview 预览让 SwiftUI 界面调试更加悠然自得</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>