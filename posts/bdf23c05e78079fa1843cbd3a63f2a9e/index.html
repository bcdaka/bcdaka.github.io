<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构C&#43;&#43;之看懂就这一篇】图（下） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/bdf23c05e78079fa1843cbd3a63f2a9e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构C&#43;&#43;之看懂就这一篇】图（下）">
  <meta property="og:description" content="📚博客主页：Zhui_Yi_
🔍：上期回顾：图【中】
❤️感谢大家点赞👍🏻收藏⭐评论✍🏻，您的三连就是我持续更新的动力❤️
🎇追当今朝天骄，忆顾往昔豪杰。
文章目录 前言一、最小生成树引入以及复习广度优先生成树和深度优先生成树求最小生成树如何求最小生成树 Prim算法kruscal算法 二、最短路径Dijkstra算法存储结构（顶点个数为n）算法思想 三、拓扑排序引入AOV网AOE网AOV网示例 算法思想（重复选择没有直接前驱的顶点） 总结 前言 本期我将带来图的应用，包括最小生成树、最短路径、拓扑排序、关键路径。
一、最小生成树 引入以及复习 在理解最小生成树的时候，我们先了解一下生成树。
生成树：包含图G所有顶点的极小连通子图（n-1条边）。
那么什么是极小连通子图呢？
极小连通子图：该子图是G 的连通子图，在该子图中删除任何一条边，子图不再连通。
广度优先生成树和深度优先生成树 那么我们上篇文章提到了广度优先遍历和深度优先遍历：
在广度优先遍历和深度优先遍历过程中，可以得到一颗遍历树，我们称之为广度优先生成树和深度优先生成树。
那么我们根据这个图，以v0作为起点，画出生成树。
我们先把邻接表给画出来：
那么画出来深度优先生成树如下：
广度优先生成树如下：
求最小生成树 我们首先明确一下：
使用不同的遍历图的方法，可以得到不同的生成树
从不同的顶点出发，也可能得到不同的生成树。
按照生成树的定义，n 个顶点的连通网络的生成树有n 个顶点、n-1 条边。
那么我们该如何求最小生成树？
在网的多个生成树中，寻找一个各边权值之和最小的生成树
构造最小生成树的准则：
必须只使用该网中的边来构造最小生成树；
必须使用且仅使用n-1条边来联结网络中的n个顶点
不能使用产生回路的边
那么最小生成树有什么用途呢？
欲在n个城市间建立通信网，则n个城市应铺n-1条线路；但因为每条线路都会有对应的经济成本，而n个城市可能有n(n-1)/2 条线路，那么，如何选择n–1条线路，使总费用最少？
如何求最小生成树 在这里有两种求法：
Prim（普里姆）算法
Kruskal（克鲁斯卡尔）算法
他们的特点是：
Prim算法: 归并顶点，与边数无关，适于稠密网
Kruskal算法：归并边，适于稀疏网
Prim算法 基本思想：归并顶点
设连通网络 N = { V, E }中找最小生成树T={V，TE}
从某顶点 u0 出发，选择与它关联的具有最小权值的边(u0, v)，将其顶点加入到生成树的顶点集合U中每一步从一个顶点在U中，而另一个顶点不在U中的各条边中选择权值最小的边(u, v),把它的顶点加入到U中直到所有顶点都加入到生成树顶点集合U中为止 应用构造最小生成树的过程
我们先把A结点放在U里面，再把其他节点放在V-U里面
然后再找与A相连权值最小的，AB,AC,AD,AE，谁权值最小？AB，再把B放在U里面">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-14T14:11:56+08:00">
    <meta property="article:modified_time" content="2024-07-14T14:11:56+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构C&#43;&#43;之看懂就这一篇】图（下）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><br>📚博客主页：<a href="https://blog.csdn.net/2301_79682950?type=blog">Zhui_Yi_</a><br> 🔍：上期回顾：<a href="https://blog.csdn.net/2301_79682950/article/details/140326961?spm=1001.2014.3001.5501">图【中】</a></p> 
<p>❤️感谢大家点赞👍🏻收藏⭐评论✍🏻，您的三连就是我持续更新的动力❤️<br> 🎇<strong>追当今朝天骄，忆顾往昔豪杰。</strong><br> <img src="https://images2.imgbox.com/ce/25/d3gYY45P_o.gif" alt="在这里插入图片描述"><br> </p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_8" rel="nofollow">前言</a></li><li><a href="#_10" rel="nofollow">一、最小生成树</a></li><li><ul><li><a href="#_11" rel="nofollow">引入以及复习</a></li><li><ul><li><a href="#_21" rel="nofollow">广度优先生成树和深度优先生成树</a></li><li><a href="#_32" rel="nofollow">求最小生成树</a></li><li><a href="#_53" rel="nofollow">如何求最小生成树</a></li></ul> 
   </li><li><a href="#Prim_64" rel="nofollow">Prim算法</a></li><li><a href="#kruscal_109" rel="nofollow">kruscal算法</a></li></ul> 
  </li><li><a href="#_144" rel="nofollow">二、最短路径</a></li><li><ul><li><a href="#Dijkstra_155" rel="nofollow">Dijkstra算法</a></li><li><ul><li><a href="#n_170" rel="nofollow">存储结构（顶点个数为n）</a></li><li><a href="#_180" rel="nofollow">算法思想</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_229" rel="nofollow">三、拓扑排序</a></li><li><ul><li><a href="#_230" rel="nofollow">引入</a></li><li><ul><li><a href="#AOV_240" rel="nofollow">AOV网</a></li><li><a href="#AOE_246" rel="nofollow">AOE网</a></li><li><a href="#AOV_252" rel="nofollow">AOV网示例</a></li></ul> 
   </li><li><a href="#_256" rel="nofollow">算法思想（重复选择没有直接前驱的顶点）</a></li></ul> 
  </li><li><a href="#_265" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_8"></a>前言</h2> 
<p>本期我将带来图的应用，包括最小生成树、最短路径、拓扑排序、关键路径。</p> 
<h2><a id="_10"></a>一、最小生成树</h2> 
<h3><a id="_11"></a>引入以及复习</h3> 
<p>在理解最小生成树的时候，我们先了解一下生成树。</p> 
<blockquote> 
 <p>生成树：包含图G所有顶点的极小连通子图（n-1条边）。</p> 
</blockquote> 
<p>那么什么是极小连通子图呢？</p> 
<blockquote> 
 <p>极小连通子图：该子图是G 的连通子图，在该子图中删除任何一条边，子图不再连通。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/d0/3b/DuYv3dBs_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_21"></a>广度优先生成树和深度优先生成树</h4> 
<p>那么我们上篇文章提到了广度优先遍历和深度优先遍历：<br> 在广度优先遍历和深度优先遍历过程中，可以得到一颗遍历树，我们称之为广度优先生成树和深度优先生成树。<br> <img src="https://images2.imgbox.com/e7/7d/c6oG2SZI_o.png" alt="在这里插入图片描述"><br> 那么我们根据这个图，以v0作为起点，画出生成树。<br> 我们先把邻接表给画出来：<br> <img src="https://images2.imgbox.com/07/5b/KmIDoKuh_o.png" alt="在这里插入图片描述"><br> 那么画出来深度优先生成树如下：<br> <img src="https://images2.imgbox.com/a9/d9/D1by0qZ2_o.png" alt="在这里插入图片描述"><br> 广度优先生成树如下：<br> <img src="https://images2.imgbox.com/dd/09/nJXgiuiS_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_32"></a>求最小生成树</h4> 
<p>我们首先明确一下：</p> 
<blockquote> 
 <p>使用不同的遍历图的方法，可以得到不同的生成树<br> 从不同的顶点出发，也可能得到不同的生成树。<br> 按照生成树的定义，n 个顶点的连通网络的生成树有n 个顶点、n-1 条边。</p> 
</blockquote> 
<p>那么我们该如何求最小生成树？</p> 
<blockquote> 
 <p>在网的多个生成树中，寻找一个各边权值之和最小的生成树</p> 
</blockquote> 
<p>构造最小生成树的准则：</p> 
<blockquote> 
 <p>必须只使用该网中的边来构造最小生成树；<br> 必须使用且仅使用n-1条边来联结网络中的n个顶点<br> 不能使用产生回路的边</p> 
</blockquote> 
<p>那么最小生成树有什么用途呢？</p> 
<blockquote> 
 <p>欲在n个城市间建立通信网，则n个城市应铺n-1条线路；但因为每条线路都会有对应的经济成本，而n个城市可能有n(n-1)/2 条线路，那么，如何选择n–1条线路，使总费用最少？</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/eb/0a/Xmdx8ZsO_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_53"></a>如何求最小生成树</h4> 
<p>在这里有两种求法：</p> 
<blockquote> 
 <p>Prim（普里姆）算法<br> Kruskal（克鲁斯卡尔）算法</p> 
</blockquote> 
<p>他们的特点是：</p> 
<blockquote> 
 <p>Prim算法: 归并顶点，与边数无关，适于稠密网<br> Kruskal算法：归并边，适于稀疏网</p> 
</blockquote> 
<h3><a id="Prim_64"></a>Prim算法</h3> 
<p>基本思想：<strong>归并顶点</strong></p> 
<blockquote> 
 <p>设连通网络 N = { V, E }中找最小生成树T={V，TE}</p> 
 <ol><li>从某顶点 u0 出发，选择与它关联的具有最小权值的边(u0, v)，将其顶点加入到生成树的顶点集合U中</li><li>每一步从一个顶点在U中，而另一个顶点不在U中的各条边中选择权值最小的边(u, v),把它的顶点加入到U中</li><li>直到所有顶点都加入到生成树顶点集合U中为止</li></ol> 
</blockquote> 
<p>应用构造最小生成树的过程<br> <img src="https://images2.imgbox.com/7d/5c/y5ozt3T5_o.png" alt="在这里插入图片描述"><br> 我们先把A结点放在U里面，再把其他节点放在V-U里面<br> <img src="https://images2.imgbox.com/f9/cd/B8H6ixxN_o.png" alt="在这里插入图片描述"><br> 然后再找与A相连权值最小的，AB,AC,AD,AE，谁权值最小？AB，再把B放在U里面<br> <img src="https://images2.imgbox.com/52/84/JX9G3kf2_o.png" alt="在这里插入图片描述"><br> 然后再找与U里面的结点相连权值最小的：AC,AD,AE,BC，谁权值最小？<br> BC，再把C放在U里面<br> <img src="https://images2.imgbox.com/88/77/RXHhgiZP_o.png" alt="在这里插入图片描述"><br> 然后再找最小的，AD,AE,CD,CE，谁最小？<br> AD，把D放在U里面<br> <img src="https://images2.imgbox.com/cf/78/0t0Cu3LK_o.png" alt="在这里插入图片描述"><br> 最后就是DE<br> <img src="https://images2.imgbox.com/c7/af/osvEqcwN_o.png" alt="在这里插入图片描述"><br> 接下来我们考虑几个问题：<br> 如果AE=DE=6，我们该选择那条边呢？<br> 都可以，那么从这里我们得到了什么？<br> 最小生成树的形态不唯一。<br> 那么什么是唯一的呢？<br> 最小生成树的权值之和！！！<br> 如何区分点在U还是在V-U集合？<br> 标志变量！！！<br> 这里我们试一下：<br> <img src="https://images2.imgbox.com/00/4b/SYSpd4OU_o.png" alt="在这里插入图片描述"><br> 画出最小生成树：<br> 先建立邻接矩阵<br> <img src="https://images2.imgbox.com/ad/42/rWMHDH0Z_o.png" alt="在这里插入图片描述"><br> 我们在建立一个一维数组<br> <img src="https://images2.imgbox.com/93/d3/MetmE9Rw_o.png" alt="在这里插入图片描述"><br> 其中最开始的时候U中只有0，故：<br> <img src="https://images2.imgbox.com/5a/a9/AlZLGr8n_o.png" alt="在这里插入图片描述"><br> 然后再比较谁最小，5，故：<br> <img src="https://images2.imgbox.com/be/32/bIS13viO_o.png" alt="在这里插入图片描述"><br> 此时U中有0和5，故：<br> <img src="https://images2.imgbox.com/2a/39/X84vodBu_o.png" alt="在这里插入图片描述"><br> 不断重复以上操作：<br> <img src="https://images2.imgbox.com/53/16/ADTAIZGi_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="kruscal_109"></a>kruscal算法</h3> 
<p>克鲁斯卡尔算法的基本思想－归并边</p> 
<blockquote> 
 <blockquote> 
  <p>设连通网络 N = { V, E }中找最小生成树T={V，TE}</p> 
 </blockquote> 
 <ol><li>构造一个只有 n 个顶点，没有边的非连通图 TE= { V,  }, 每个顶点自成一个连通分量</li><li>在 E 中选最小权值的边,若该边的两个顶点落在不同的连通分量上，则加入 TE 中；否则舍去，重新选择</li><li>重复下去，直到所有顶点在同一连通分量上为止</li></ol> 
</blockquote> 
<p>实现该算法的关键为如何避免选取的边构成回路</p> 
<blockquote> 
 <p>➢假设存在n个顶点，设置一t个辅助数组vset[0…n-1] ➢数据元素vset[i] (初值为i)代表编号为i的顶点所属的连通子图编号<br> ➢如果边(i, j)的两个顶点vset[i]== vset[j],不选，否则选取<br> ➢一旦选取(i,j)将两个顶点的连通分量的vset值改为vset[i]或vset[j]</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/03/9c/mhWuIpGr_o.png" alt="在这里插入图片描述"><br> 构造上述的最小生成树：</p> 
<p>首先按权值大小分：<br> <img src="https://images2.imgbox.com/01/4e/HMPPEAgA_o.png" alt="在这里插入图片描述"><br> 然后再设置辅助元素的值：<br> <img src="https://images2.imgbox.com/78/25/mI1SM6Gx_o.png" alt="在这里插入图片描述"><br> 首先选择权值最小的AB，A和B能连嘛？<br> A的值为0，B的值为1，不一样，可以选，同时使两个顶点的值相同：<br> <img src="https://images2.imgbox.com/b3/c0/yd09gEKf_o.png" alt="在这里插入图片描述"><br> 然后在选取权值最小的，BC，能选吗？<br> 值不相同，可以，再改变C的值使他们相等：<br> <img src="https://images2.imgbox.com/90/05/TcpbKSVl_o.png" alt="在这里插入图片描述"><br> 然后再看谁权值最小，AC，能选吗？<br> 不能，A和C的值都为0。再往下看：<br> AD，能选吗？<br> 值不相同，能选，再改值：<br> <img src="https://images2.imgbox.com/34/12/08vlilTa_o.png" alt="在这里插入图片描述"><br> 重复上述操作：<br> <img src="https://images2.imgbox.com/d9/16/J9Iak9x7_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_144"></a>二、最短路径</h2> 
<blockquote> 
 <p>典型用途：交通问题。如：城市A到城市B有多条线路，但每条线路的交通费（或所需时间）不同，那么，如何选择一条线路，使总费用（或总时间）最少？<br> 问题抽象：在带权有向图中A点（源点）到达B点（终点）的多条路径中，寻找一条各边权值之和最小的路径，即最短路径。</p> 
</blockquote> 
<p>特别注意，最短路径跟最小生成树是不一样的。最短路径上不一定包含n个顶点。</p> 
<blockquote> 
 <p>两种常见的最短路径问题：<br> 一、 单源最短路径—用Dijkstra（迪杰斯特拉）算法<br> 二、所有顶点间的最短路径—用Floyd（弗洛伊德）算法</p> 
</blockquote> 
<h3><a id="Dijkstra_155"></a>Dijkstra算法</h3> 
<p>Dijkstra算法的思想–按路径长度递增次序求解：</p> 
<blockquote> 
 <p>1.初始化：先找出从源点v0到各终点vk的直达路径（v0,vk），即通过一条弧到达的路径。<br> 2.选择：从这些路径中找出一条长度最短的路径（v0,u）。<br> 3.更新：然后对其余各条路径进行适当调整：<br> 若在图中存在弧（u,vk），且（v0,u）+（u,vk）&lt;（v0,vk）,<br> 则以路径（v0,u,vk）代替（v0,vk）。<br> 在调整后的各条路径中，再找长度最短的路径，依此类推。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/a2/8e/lS6ZHLi3_o.png" alt="在这里插入图片描述"><br> 如图。<br> <img src="https://images2.imgbox.com/56/5e/sVbEmNP1_o.png" alt="在这里插入图片描述"><br> 然后建立表格<br> <img src="https://images2.imgbox.com/04/83/qsmNjDyx_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="n_170"></a>存储结构（顶点个数为n）</h4> 
<blockquote> 
 <p>主：邻接矩阵G[n][n] (或者邻接表)<br> 辅：<br> 数组S[n]：记录相应顶点是否已被确定最短距离<br> 数组D[n]：记录源点到相应顶点路径长度<br> 数组Path[n]：记录相应顶点的前驱顶点</p> 
</blockquote> 
<p>初始化结果如图<br> <img src="https://images2.imgbox.com/7d/bf/aZbHS83s_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_180"></a>算法思想</h4> 
<blockquote> 
 <p>① 初始化：<br> ● 将源点v0加到S中，即S[v0] = true；<br> ● 将v0到各个终点的最短路径长度初始化为权值，即D[i] = G.arcs[v0][vi]，(vi∈V − S)；<br> ● 如果v0和顶点vi之间有弧，则将vi的前驱置为v0，即Path[i] = v0，否则Path[i] = −1。<br> ② 选择下一条最短路径的终点vk，使得：<br> D[k] = Min{D[i]|vi∈V − S}<br> ③ 将vk加到S中，即S[vk] = true。<br> ④ 更新从v0出发到集合V − S上任一顶点的最短路径的长度，同时更改vi的前驱为vk。<br> 若S[i]=false 且 D[k]+G.arcs[k][i]&lt;D[i]，则D[i]=D[k]+ G.arcs[k][i]; Path [i]=k;。<br> ⑤ 重复②～④ n − 1次，即可按照路径长度的递增顺序，逐个求得从v0到图上其余各顶点的最短路径。</p> 
</blockquote> 
<p>如图<br> <img src="https://images2.imgbox.com/1a/d9/IVzrVq19_o.png" alt="在这里插入图片描述"><br> 这是我给出一个例子：<br> <img src="https://images2.imgbox.com/b8/67/Ro1qWJcV_o.gif" alt="在这里插入图片描述"><br> 算法流程图如下：<br> <img src="https://images2.imgbox.com/d7/23/yc549SY3_o.png" alt="在这里插入图片描述"><br> 代码实现如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">ShortestPath_DIJ</span><span class="token punctuation">(</span>AMGraph G<span class="token punctuation">,</span> <span class="token keyword">int</span> v0<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> 
    <span class="token comment">//用Dijkstra算法求有向网G的v0顶点到其余顶点的最短路径 </span>
    n<span class="token operator">=</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>                    		<span class="token comment">//n为G中顶点的个数 </span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> <span class="token operator">++</span>v<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>             	<span class="token comment">//n个顶点依次初始化 </span>
       S<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                  	<span class="token comment">//S初始为空集 </span>
       D<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> G<span class="token punctuation">.</span>arcs<span class="token punctuation">[</span>v0<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>           	<span class="token comment">//将v0到各个终点的最短路径长度初始化 </span>
       <span class="token keyword">if</span><span class="token punctuation">(</span>D<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">&lt;</span> MaxInt<span class="token punctuation">)</span>  Path <span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">=</span>v0<span class="token punctuation">;</span> <span class="token comment">//v0和v之间有弧，将v的前驱置为v0 </span>
       <span class="token keyword">else</span> Path <span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>               	<span class="token comment">//如果v0和v之间无弧，则将v的前驱置为-1 </span>
      <span class="token punctuation">}</span><span class="token comment">//for </span>
      S<span class="token punctuation">[</span>v0<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>                    	<span class="token comment">//将v0加入S </span>
      D<span class="token punctuation">[</span>v0<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>                      		<span class="token comment">//源点到源点的距离为0 </span>
      <span class="token comment">/*―开始主循环，每次求得v0到某个顶点v的最短路径，将v加到S集―*/</span> 
      <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>               	<span class="token comment">//对其余n−1个顶点，依次进行计算 </span>
        min<span class="token operator">=</span> MaxInt<span class="token punctuation">;</span> 
        <span class="token keyword">for</span><span class="token punctuation">(</span>w<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>w<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> <span class="token operator">++</span>w<span class="token punctuation">)</span> 
          <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>S<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>D<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">&lt;</span>min<span class="token punctuation">)</span>  
              <span class="token punctuation">{<!-- --></span>v<span class="token operator">=</span>w<span class="token punctuation">;</span> min<span class="token operator">=</span>D<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>         	<span class="token comment">//选择一条当前的最短路径，终点为v </span>
        S<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>                   		<span class="token comment">//将v加入S </span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>w<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>w<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> <span class="token operator">++</span>w<span class="token punctuation">)</span> 	<span class="token comment">//更新从v0出发到集合V−S上所有顶点的最短路径长度 </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>S<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>D<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">+</span>G<span class="token punctuation">.</span>arcs<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">&lt;</span>D<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> 
             D<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">=</span>D<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">+</span>G<span class="token punctuation">.</span>arcs<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">;</span>   	<span class="token comment">//更新D[w] </span>
             Path <span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">=</span>v<span class="token punctuation">;</span>              		<span class="token comment">//更改w的前驱为v </span>
        <span class="token punctuation">}</span><span class="token comment">//if </span>
    <span class="token punctuation">}</span><span class="token comment">//for       </span>
<span class="token punctuation">}</span><span class="token comment">//ShortestPath_DIJ </span>
</code></pre> 
<p>时间复杂度为：O(n2)</p> 
<h2><a id="_229"></a>三、拓扑排序</h2> 
<h3><a id="_230"></a>引入</h3> 
<blockquote> 
 <p>用有向图来描述一个工程或系统的进行过程。<br> 一个工程可以分为若干个子工程，只要完成了这些子工程（活动），就可以导致整个工程的完成。</p> 
</blockquote> 
<blockquote> 
 <p>① AOV网(Activity On Vertices)—用顶点表示活动的网络<br> ② AOE网(Activity On Edges)—用边表示活动的网络</p> 
</blockquote> 
<p>比如教学计划的制定<br> 哪些课程是必须先修的，哪些课程是可以并行学习的。</p> 
<h4><a id="AOV_240"></a>AOV网</h4> 
<blockquote> 
 <p>用顶点表示活动，用边表示活动间的优先关系。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/4e/1b/Z6FW94wJ_o.png" alt="在这里插入图片描述"><br> 如图。</p> 
<h4><a id="AOE_246"></a>AOE网</h4> 
<blockquote> 
 <p>用顶点表示事件，用边表示活动，权表示活动持续的时间。通常可用来估算工程的完成时间。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/c0/d1/3dqMsBxS_o.png" alt="在这里插入图片描述"><br> 如图。</p> 
<h4><a id="AOV_252"></a>AOV网示例</h4> 
<p><img src="https://images2.imgbox.com/6e/96/wslzxYNU_o.png" alt="在这里插入图片描述"><br> 如图<img src="https://images2.imgbox.com/30/0f/BOvpUBma_o.png" alt="在这里插入图片描述"><br> 应该这样画。</p> 
<h3><a id="_256"></a>算法思想（重复选择没有直接前驱的顶点）</h3> 
<blockquote> 
 <p>1.输入AOV网络。令 n 为顶点个数。 <br> 2.在AOV网络中选一个没有直接前驱的顶点, 并输出之;<br> 3.从图中删去该顶点, 同时删去所有它发出的有向边;<br> 4.重复以上 2、3 步, 直到：<br> 全部顶点均已输出，拓扑有序序列形成，拓扑排序完成；或：<br> 图中还有未输出的顶点，但已跳出处理循环。这说明图中还剩下一些顶点，它们都有直接前驱，再也找不到没有前驱的顶点了。这时AOV网络中必定存在有向环。</p> 
</blockquote> 
<h2><a id="_265"></a>总结</h2> 
<p>本篇文章有点粗造，抱歉各位，状态不是很好。<br> 希望可以三哈！！！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9a0516d5a690056b6a5e4998686fe404/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">连锁直营店小程序赋能多店如何管理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/33786d112717ff77c7c3b256e0da6956/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在html中使用vue.js的component</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>