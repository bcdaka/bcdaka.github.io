<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】——单链表实现 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/21235fcaea58278e1bf5891babab6f6e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】——单链表实现">
  <meta property="og:description" content="欢迎光顾我的homepage
前言 链表和顺序表都是线性表的一种，但是顺序表在物理结构和逻辑结构上都是连续的，但链表在逻辑结构上是连续的，而在物理结构上不一定连续；来看以下图片来认识链表与顺序表的差别
这里以动态顺序表为例，和链表中的单链表对比一下
动态顺序表
单链表
这里就可以很清晰的看到顺序表的底层其实就是一个数组，数据的是连续存储的（顺序表物理结构连续）；而链表它每一个数据都不是连续的（链表物理结构上不一定连续）。
链表节点 通过观察上图，我们会发现链表每一个节点都存放在数据和下一个节点的地址。
那么来想一下，为了链表每一个节点都统一起来，都存储有效数据和下一个节点的地址，我们就需要创建应该结构体，来存储有效数据和下一个节点的指针；
注：这里只是单链表
typedef int SLType; typedef struct SLTNode { SLType data; struct SLTNode* next; }SLT; 创建好链表节点，接下来就来实习单链表存储数据的这些功能。
单链表实现 先来看一下单链表都实现都哪些功能
//输出链表 void SLTPrint(SLT* phead); //创建节点 SLT* SLTCreat(SLType x); //单链表头插 void SLTPushFront(SLT** pphead, SLType x); //单链表尾插 void SLTPushBack(SLT** pphead, SLType x); //单链表头删 void SLTPopFront(SLT** pphead); //单链表尾删 void SLTPopBack(SLT** pphead); //查找数据 SLT* SLTFind(SLT* phead, SLType x); //指定位置之前插入 void SLTInsert(SLT** pphead, SLT* pos, SLType x); //指定位置之后插入 void SLTInsertAfter(SLT* pos, SLType x); //删除指定节点 void SLTErase(SLT** pphead, SLT* pos); //删除指定位置后一个节点 void SLTEraseAfter(SLT* pos); 创建节点">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-24T21:58:38+08:00">
    <meta property="article:modified_time" content="2024-07-24T21:58:38+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】——单链表实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="color:#38d8f0;"><strong>                                                        <a class="link-info" href="https://blog.csdn.net/LH__1314?type=blog" title="欢迎光顾我的homepage">欢迎光顾我的homepage</a></strong></span><img alt="" height="56" src="https://images2.imgbox.com/25/00/fWl4zwDd_o.png" width="53"></p> 
<h2>前言        </h2> 
<p><strong>        </strong><span style="color:#0d0016;">链表和顺序表都是线性表的一种，但是顺序表在物理结构和逻辑结构上都是连续的，但链表在逻辑结构上是连续的，而在物理结构上不一定连续；来看以下图片来认识链表与顺序表的差别</span></p> 
<p><span style="color:#0d0016;">这里以动态顺序表为例，和链表中的单链表对比一下</span></p> 
<p><span style="color:#0d0016;">动态顺序表</span><img alt="" height="705" src="https://images2.imgbox.com/70/6c/sBgo22H0_o.png" width="871"></p> 
<p>单链表</p> 
<p><img alt="" height="192" src="https://images2.imgbox.com/80/d3/UF017wUU_o.png" width="1200"></p> 
<p>        这里就可以很清晰的看到顺序表的底层其实就是一个数组，数据的是连续存储的（顺序表物理结构连续）；而链表它每一个数据都不是连续的（链表物理结构上不一定连续）。</p> 
<h2><strong>链表节点</strong></h2> 
<p><strong>        通过观察上图，我们会发现链表每一个节点都存放在数据和下一个节点的地址。</strong></p> 
<p><strong>        那么来想一下，为了链表每一个节点都统一起来，都存储有效数据和下一个节点的地址，我们就需要创建应该结构体，来存储有效数据和下一个节点的指针；<br><span style="color:#fe2c24;">注：这里只是单链表</span></strong></p> 
<pre><code class="language-cpp">typedef int SLType;
typedef struct SLTNode
{
	SLType data;
	struct SLTNode* next;
}SLT;</code></pre> 
<p>创建好链表节点，接下来就来实习单链表存储数据的这些功能。</p> 
<h2>单链表实现</h2> 
<p>先来看一下单链表都实现都哪些功能</p> 
<pre><code class="language-cpp">//输出链表
void SLTPrint(SLT* phead);
//创建节点
SLT* SLTCreat(SLType x);
//单链表头插
void SLTPushFront(SLT** pphead, SLType x);
//单链表尾插
void SLTPushBack(SLT** pphead, SLType x);
//单链表头删
void SLTPopFront(SLT** pphead);
//单链表尾删
void SLTPopBack(SLT** pphead);
//查找数据
SLT* SLTFind(SLT* phead, SLType x);
//指定位置之前插入
void SLTInsert(SLT** pphead, SLT* pos, SLType x);
//指定位置之后插入
void SLTInsertAfter(SLT* pos, SLType x);
//删除指定节点
void SLTErase(SLT** pphead, SLT* pos);
//删除指定位置后一个节点
void SLTEraseAfter(SLT* pos);</code></pre> 
<p><span style="color:#ff9900;"><strong><span style="background-color:#dad5e9;">创建节点</span></strong></span></p> 
<p>        这里创建节点，还是使用动态内存来创建，创建完成后，将数据存储进去，并把新节点的下一个节点置为NULL</p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">//创建节点
SLT* SLTCreat(SLType x)
{
	SLT* newnode = (SLT*)malloc(sizeof(SLT));
	assert(newnode);
	newnode-&gt;data = x;
	newnode-&gt;next = NULL;
	return newnode;
}</code></pre> 
<p>        测试一下代码是否正确</p> 
<p><img alt="" height="150" src="https://images2.imgbox.com/75/60/0zU2PD73_o.png" width="351"><img alt="" height="94" src="https://images2.imgbox.com/c1/d6/qpeNYR4l_o.png" width="556"></p> 
<p>可以看到代码没有问题。</p> 
<p><span style="color:#ff9900;"><strong><span style="background-color:#dad5e9;">输出链表</span></strong></span></p> 
<p>        由于这里实现单链表，存储的是整型数据，就以整型的方式输出，若存储其他类型的数据，就以存储类型的方式输出。</p> 
<p>输出链表，首先就要<span style="color:#ff9900;"><strong>遍历链表</strong></span>，因为链表最后一个节点里存储的下一个节点的地址为空（即最后一个节点  -&gt;next 为空）所以，遍历链表结束的条件就是ptail ==NULL，没输出一个就让ptail指向下一个节点，直到为空，遍历结束。</p> 
<p>        来写代码实现：</p> 
<pre><code class="language-cpp">//输出链表
void SLTPrint(SLT* phead)
{
	SLT* ptail = phead;
	while (ptail!= NULL)//也可以直接写成 ptail
	{
		printf("%d -&gt; ", ptail-&gt;data);
		ptail = ptail-&gt;next;
	}
	printf("NULL\n");
}</code></pre> 
<p>这里先创建两个节点并存储数据输出看一下结果</p> 
<pre><code class="language-cpp">int main()
{
	SLT* plist = SLTCreat(1);
	plist-&gt;next = SLTCreat(2);
	SLTPrint(plist);
	return 0;
}</code></pre> 
<p><img alt="" height="128" src="https://images2.imgbox.com/02/9c/G8bYTahC_o.png" width="580"></p> 
<p>        这里也成功输出插入的两个数据。（最后一个节点的next指向空）</p> 
<p><span style="color:#ff9900;"><strong><span style="background-color:#dad5e9;">单链表头插</span></strong></span></p> 
<p>        在链表头部插入数据，不用像顺序表那样去移动所以的有效数据，链表只需要改变一个指针的指向即可</p> 
<p><img alt="" height="489" src="https://images2.imgbox.com/5f/ab/It1QC35F_o.png" width="1109"></p> 
<p>假设现在链表中已经存在两个数据，再进行头插，这时就只需要改变plist的指向即可，当然新节点的next指针也要指向下一个节点(plist指向的节点)。</p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">//单链表头插
void SLTPushFront(SLT** pphead, SLType x)
{
	assert(pphead);
	SLT* newnode = SLTCreat(x);
	newnode-&gt;next = *pphead;
	*pphead = newnode;
}</code></pre> 
<p>还有一种情况，如果现在链表中没有数据，再进行头插，这里代码也能实现链表没有数据时的头插<img alt="" height="208" src="https://images2.imgbox.com/b3/4b/t2uMw24w_o.png" width="354"><img alt="" height="108" src="https://images2.imgbox.com/1a/b5/sHMtO7Xs_o.png" width="297"></p> 
<p><span style="color:#ff9900;"><strong><span style="background-color:#dad5e9;">单链表尾插</span></strong></span></p> 
<p>        链表的尾插，因为指针传的是指向头节点的指针的地址，所以，我们需要先遍历链表，找到链表的尾部，再修改尾节点的next指针指向。<img alt="" height="430" src="https://images2.imgbox.com/e3/23/OpAhh1oW_o.png" width="1099"></p> 
<p>假设现在链表中已经存在两个数据，再进行尾插，此时我们只需要找到链表的尾部，修改尾节点next指针指向即可，代码如下</p> 
<pre><code class="language-cpp">//单链表尾插
void SLTPushBack(SLT** pphead, SLType x)
{
	assert(pphead);
	SLT* newnode = SLTCreat(x);
	SLT* ptail = *pphead;
	//遍历链表
	while (ptail-&gt;next)
	{
		ptail = ptail-&gt;next;
	}
	ptail-&gt;next = newnode;
}</code></pre> 
<p>        考虑了这种情况，再来看以下<strong><span style="color:#fe2c24;">链表为空</span></strong>的情况，如果链表为空，这里ptail-&gt;next就对空指针进行解引用操作了；所以，我们需要判断链表是否为空？<strong><span style="color:#ff9900;">如果为空，插入的新节点就是头节点</span></strong>，直接让plist（即*pphead)指向新节点即可；如果不为空就正常进行尾插。</p> 
<p>最终代码如下：</p> 
<pre><code class="language-cpp">//单链表尾插
void SLTPushBack(SLT** pphead, SLType x)
{	
	assert(pphead);
	SLT* newnode = SLTCreat(x);
	if (*pphead == NULL) //判断链表是否为空
	{
		*pphead = newnode;
	}
	else {
		SLT* ptail = *pphead;
		//遍历链表
		while (ptail-&gt;next)
		{
			ptail = ptail-&gt;next;
		}
		ptail-&gt;next = newnode;
	}
}</code></pre> 
<p><img alt="" height="200" src="https://images2.imgbox.com/fb/df/FTTRuM1l_o.png" width="345"><img alt="" height="128" src="https://images2.imgbox.com/41/0c/c0clIbee_o.png" width="350"></p> 
<p>这里代码可以正常进行尾插。</p> 
<p><span style="color:#ff9900;"><strong><span style="background-color:#dad5e9;">单链表头删</span></strong></span></p> 
<p>        链表头删，首先我们要判断链表是否为空，如果为空（空链表没有数据该如何删除呢<img alt="？" height="26" src="https://images2.imgbox.com/9f/1d/XDlhZ0RN_o.png" width="25">）</p> 
<p>链表头删，我们需要修改plist（*pphead）指向链表的下一个节点即头节点的next指针。</p> 
<p>    <strong><span style="color:#fe2c24;">    此外：</span><span style="color:#38d8f0;"><span style="background-color:#9c8ec1;">因为我们的节点都是动态申请的内存，所以在删除时，需要把它释放掉。</span></span></strong></p> 
<p>思路很简单，写一下代码：<br>  </p> 
<pre><code class="language-cpp">//单链表头删
void SLTPopFront(SLT** pphead)
{
	assert(pphead &amp;&amp; *pphead);
	SLT* del = (*pphead);
	*pphead = (*pphead)-&gt;next;
	free(del);
	del = NULL;
}</code></pre> 
<p><img alt="" height="276" src="https://images2.imgbox.com/dc/48/Y1Ve8Ai9_o.png" width="571"></p> 
<p><img alt="" height="109" src="https://images2.imgbox.com/42/2e/33pztV0M_o.png" width="569"></p> 
<p>再来看一个如果链表为空，又是啥结果呢？<img alt="" height="266" src="https://images2.imgbox.com/54/0e/DZtmtqpb_o.png" width="704"></p> 
<p>现在链表已经为空，在执行一次头删代码<img alt="" height="242" src="https://images2.imgbox.com/31/bd/CxcpuNsY_o.png" width="1200"></p> 
<p>这里assert断言报错。</p> 
<p><span style="color:#ff9900;"><strong><span style="background-color:#dad5e9;">单链表尾删</span></strong></span></p> 
<p>        首先尾删与头删一样，链表不能为空。</p> 
<p>        尾删与尾插也有共同之处，就是遍历链表，找到链表的尾节点。找到尾节点，删除尾节点；然后修改尾节点上一个节点的next指针为NULL；所以在遍历链表时就要多记录一个节点。</p> 
<pre><code class="language-cpp">//单链表尾删
void SLTPopBack(SLT** pphead)
{
	assert(pphead &amp;&amp; *pphead);
	SLT* ptail = *pphead;
	SLT* pcur = *pphead;
	//遍历链表
	while (ptail-&gt;next)
	{
		pcur = ptail;
		ptail = ptail-&gt;next;
	}
	pcur-&gt;next = NULL;
	free(ptail);
	ptail  = NULL;
}</code></pre> 
<p>        在测试的时候我们会发现一个问题，如果链表只有一个节点，删除之后我们的plist指针并没有置为空，而我们的空间已经释放掉了，这是很危险的<img alt="" height="21" src="https://images2.imgbox.com/92/bf/BNr37L5w_o.png" width="19">；所以这里我们先判断一下链表是否只有一个节点，如果是，我们释放完空间以后，将(*pphead)置为空，以免出现野指针的情况。</p> 
<p>完善后代码：</p> 
<pre><code class="language-cpp">//单链表尾删
void SLTPopBack(SLT** pphead)
{
	assert(pphead &amp;&amp; *pphead);
	if ((*pphead)-&gt;next== NULL)
	{
		free(*pphead);
		*pphead = NULL;

	}
	else {
		SLT* ptail = *pphead;
		SLT* pcur = *pphead;
		//遍历链表
		while (ptail-&gt;next)
		{
			pcur = ptail;
			ptail = ptail-&gt;next;
		}
		free(ptail);
		ptail = NULL;
		pcur-&gt;next = NULL;
	}
}</code></pre> 
<p><img alt="" height="383" src="https://images2.imgbox.com/bc/f1/8Ia6NtdJ_o.png" width="673"></p> 
<p>测试没有问题，代码能够完成尾删这个功能。</p> 
<p><span style="color:#ff9900;"><strong><span style="background-color:#dad5e9;">查找数据</span></strong></span></p> 
<p>        查找数据，遍历链表查找数据，如果找到就返回数据所在节点的地址，如果没有找到就返回NULL;</p> 
<pre><code class="language-cpp">//查找数据
SLT* SLTFind(SLT* phead, SLType x)
{
	SLT* ptail = phead;
	while (ptail)
	{
		if (ptail-&gt;data == x)
		{
			return ptail;
		}
        ptail = ptail-&gt;next;
	}
	return NULL;
}</code></pre> 
<p>这里测试以下：</p> 
<p><span style="color:#ff9900;"><strong>数据存在时</strong></span><img alt="" height="512" src="https://images2.imgbox.com/c1/3a/87SCjxHd_o.png" width="925"></p> 
<p><span style="color:#ff9900;"><strong>数据不存在时</strong></span><img alt="" height="525" src="https://images2.imgbox.com/39/bf/JwYCeyeU_o.png" width="1003"></p> 
<p><span style="color:#ff9900;"><strong><span style="background-color:#dad5e9;">指定节点之前插入</span></strong></span></p> 
<p>        在链表指定节点之前插入数据，我们还需要知道指定节点的前一个节点，所以仍然需要遍历链表，寻找指定节点pos前一个节点。</p> 
<pre><code class="language-cpp">//指定位置之前插入
void SLTInsert(SLT** pphead, SLT* pos, SLType x)
{
	assert(pphead &amp;&amp; *pphead);
	SLT* ptail = *pphead;
	if (ptail == pos)//头插
	{
		SLTPushFront(pphead, x);
	}
	else
	{
		SLT* newnode = SLTCreat(x);
		while (ptail-&gt;next != pos)//找到pos位置
		{
			ptail = ptail-&gt;next;
		}
		newnode-&gt;next = pos;
		ptail-&gt;next = newnode;
	}
}</code></pre> 
<p><img alt="" height="367" src="https://images2.imgbox.com/c2/b4/SRcmz8H3_o.png" width="857"></p> 
<p>当然，这里如果故意传NULL给pos，（这就没啥意义了）这里也可以写以下assert断言pos。</p> 
<p><span style="color:#ff9900;"><strong><span style="background-color:#dad5e9;">指定节点之后插入</span></strong></span></p> 
<p>        在指定节点之后插入数据，就不需要再进行遍历链表，这里直接插入即可。</p> 
<pre><code class="language-cpp">//指定位置之后插入
void SLTInsertAfter(SLT* pos, SLType x)
{
	assert(pos);
	SLT* newnode = SLTCreat(x);
	newnode-&gt;next = pos-&gt;next;
	pos-&gt;next = newnode;
}</code></pre> 
<p><img alt="" height="467" src="https://images2.imgbox.com/b8/19/0PcndUdV_o.png" width="927"></p> 
<p><span style="color:#ff9900;"><strong><span style="background-color:#dad5e9;">删除指定节点</span></strong></span></p> 
<p>        删除链表中的指定节点，我们需要这个节点的上一个节点，所以又需要遍历链表，找到pos上一个节点，修改pos-&gt;next指针指向。</p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">//删除指定节点
void SLTErase(SLT** pphead, SLT* pos)
{
	//找到pos上一个节点
	SLT* ptail = *pphead;
	while (ptail-&gt;next != pos)
	{
		ptail = ptail-&gt;next;
	}
	SLT* p = pos-&gt;next;
	free(pos);
	pos = NULL;
	ptail-&gt;next = p;
}</code></pre> 
<p><img alt="" height="593" src="https://images2.imgbox.com/be/d1/Teo43Dc7_o.png" width="918"></p> 
<p><span style="color:#ff9900;"><strong><span style="background-color:#dad5e9;">删除指定节点后一个节点</span></strong></span></p> 
<p>        删除链表指定节点后一个节点，因为pos就是删除节点的上一个节点，所以不需要遍历链表，直接删除即可。</p> 
<pre><code class="language-cpp">//删除指定位置后一个节点
void SLTEraseAfter(SLT* pos)
{
	assert(pos-&gt;next);
	SLT* del = pos-&gt;next;
	pos-&gt;next = pos-&gt;next-&gt;next;
	free(del);
	del = NULL;
}</code></pre> 
<p><img alt="" height="652" src="https://images2.imgbox.com/6e/a3/TMxxV6P4_o.png" width="946"></p> 
<p style="text-align:center;">这里如果传过来的就是链表的尾节点，那<img alt="没办法" height="49" src="https://images2.imgbox.com/57/ee/i2Sg70oc_o.png" width="43">删除后一个节点，所以断言pos-&gt;next；</p> 
<h2>代码总览</h2> 
<pre><code class="language-cpp">#include"SList.h"
//创建节点
SLT* SLTCreat(SLType x)
{
	SLT* newnode = (SLT*)malloc(sizeof(SLT));
	assert(newnode);
	newnode-&gt;data = x;
	newnode-&gt;next = NULL;
	return newnode;
}
//输出链表
void SLTPrint(SLT* phead)
{
	SLT* ptail = phead;
	while (ptail != NULL)//也可以直接写成 ptail
	{
		printf("%d -&gt; ", ptail-&gt;data);
		ptail = ptail-&gt;next;
	}
	printf("NULL\n");
}
//单链表头插
void SLTPushFront(SLT** pphead, SLType x)
{
	assert(pphead);
	SLT* newnode = SLTCreat(x);
	newnode-&gt;next = *pphead;
	*pphead = newnode;
}
//单链表尾插
void SLTPushBack(SLT** pphead, SLType x)
{	
	assert(pphead);
	SLT* newnode = SLTCreat(x);
	if (*pphead == NULL) //判断链表是否为空
	{
		*pphead = newnode;
	}
	else {
		SLT* ptail = *pphead;
		//遍历链表
		while (ptail-&gt;next)
		{
			ptail = ptail-&gt;next;
		}
		ptail-&gt;next = newnode;
	}
}
//单链表头删
void SLTPopFront(SLT** pphead)
{
	assert(pphead &amp;&amp; *pphead);
	SLT* del = (*pphead);
	*pphead = (*pphead)-&gt;next;
	free(del);
	del = NULL;
}
//单链表尾删
void SLTPopBack(SLT** pphead)
{
	assert(pphead &amp;&amp; *pphead);
	if ((*pphead)-&gt;next== NULL)
	{
		free(*pphead);
		*pphead = NULL;

	}
	else {
		SLT* ptail = *pphead;
		SLT* pcur = *pphead;
		//遍历链表
		while (ptail-&gt;next)
		{
			pcur = ptail;
			ptail = ptail-&gt;next;
		}
		free(ptail);
		ptail = NULL;
		pcur-&gt;next = NULL;
	}
}
//查找数据
SLT* SLTFind(SLT* phead, SLType x)
{
	SLT* ptail = phead;
	while (ptail)
	{
		if (ptail-&gt;data == x)
		{
			return ptail;
		}
		ptail = ptail-&gt;next;
	}
	return NULL;
}
//指定位置之前插入
void SLTInsert(SLT** pphead, SLT* pos, SLType x)
{
	assert(pphead &amp;&amp; *pphead);
	SLT* ptail = *pphead;
	if (ptail == pos)//头插
	{
		SLTPushFront(pphead, x);
	}
	else
	{
		SLT* newnode = SLTCreat(x);
		while (ptail-&gt;next != pos)//找到pos位置
		{
			ptail = ptail-&gt;next;
		}
		newnode-&gt;next = pos;
		ptail-&gt;next = newnode;
	}
}
//指定位置之后插入
void SLTInsertAfter(SLT* pos, SLType x)
{
	assert(pos);
	SLT* newnode = SLTCreat(x);
	newnode-&gt;next = pos-&gt;next;
	pos-&gt;next = newnode;
}
//删除指定节点
void SLTErase(SLT** pphead, SLT* pos)
{
	//找到pos上一个节点
	SLT* ptail = *pphead;
	while (ptail-&gt;next != pos)
	{
		ptail = ptail-&gt;next;
	}
	SLT* p = pos-&gt;next;
	free(pos);
	pos = NULL;
	ptail-&gt;next = p;
}
//删除指定位置后一个节点
void SLTEraseAfter(SLT* pos)
{
	assert(pos-&gt;next);
	SLT* del = pos-&gt;next;
	pos-&gt;next = pos-&gt;next-&gt;next;
	free(del);
	del = NULL;
}</code></pre> 
<p><span style="color:#0d0016;"><strong><span style="background-color:#fefcd8;">感谢各位大佬支持并指出问题，</span></strong></span></p> 
<p style="text-align:center;"><span style="color:#0d0016;"><strong><span style="background-color:#fefcd8;">如果本篇内容对你有帮助，可以一键三连支持以下，感谢支持！！！</span></strong></span></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/06/48/Ds1yzgDg_o.jpg"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f2114325f78711d93c20645afdcd1104/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java中的优先级队列（PriorityQueue）（如果想知道Java中有关优先级队列的知识点，那么只看这一篇就足够了！）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e66debd588d717b6ba7ca924620e8c15/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">算法从零到精通 (一) ~ 快慢双指针</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>