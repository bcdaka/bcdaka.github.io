<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【MySQL】索引 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/27e0857863133ae84ef6f2ccf7837f6f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【MySQL】索引">
  <meta property="og:description" content="索引 1.初识索引2.认识磁盘3.MySQL 与磁盘交互基本单位4.建立共识5.索引的理解6.索引操作7.全文索引 点赞👍👍收藏🌟🌟关注💖💖
你的支持是对我最大的鼓励，我们一起努力吧!😃😃
1.初识索引 没有索引，可能会有什么问题？
索引：提高数据库的性能，索引是物美价廉的东西了。不用加内存，不用改程序，不用调sql，只要执行正确的 create index ，查询速度就可能提高成百上千倍。但是天下没有免费的午餐，查询速度的提高是以插入、更新、删除的速度为代价的，这些写操作，增加了大量的IO。所以它的价值，在于提高一个海量数据的检索速度。
所有mysql的CURD操作全部都是在mysql的内存中进行的，mysql在启动的是会预先开辟一大块空间，开辟好空间之后在合适的时候把数据对应CURD操作体现在内存级，然后mysql会定期把数据刷新到磁盘中做持久化。换言之MySQL的服务器，本质是在内存中的，所有的数据库的CURD操作，全部都是在内存中进行的！ 索引也是如此
索引是提高效率的，一般我们知道提高算法效率的因素：1. 组织数据的方式 ，2. 算法本身。索引是更改特定组织数据的方式，把以前数据的组织方式以新的数据结构组织起来。所以索引是内存中一种特定结构组织的一种结构，具体是什么结构后面再说，
常见索引分为：
主键索引(primary key)唯一索引(unique)普通索引(index)全文索引(fulltext)–解决中子文索引问题。 下面见识一下索引
先整一个海量表，在查询的时候，看看没有索引时有什么问题？
--构建一个8000000条记录的数据 --构建的海量表数据需要有差异性，所以使用存储过程来创建， 拷贝下面代码就可以了，暂时不用理解 -- 产生随机字符串 delimiter $$ create function rand_string(n INT) returns varchar(255) begin declare chars_str varchar(100) default &#39;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#39;; declare return_str varchar(255) default &#39;&#39;; declare i int default 0; while i &lt; n do set return_str =concat(return_str,substring(chars_str,floor(1&#43;rand()*52),1)); set i = i &#43; 1; end while; return return_str; end $$ delimiter ; --产生随机数字 delimiter $$ create function rand_num() returns int(5) begin declare i int default 0; set i = floor(10&#43;rand()*500); return i; end $$ delimiter ; --创建存储过程，向雇员表添加海量数据 delimiter $$ create procedure insert_emp(in start int(10),in max_num int(10)) begin declare i int default 0; set autocommit = 0; repeat set i = i &#43; 1; insert into EMP values ((start&#43;i) ,rand_string(6),&#39;SALESMAN&#39;,0001,curdate(),2000,400,rand_num()); until i = max_num end repeat; commit; end $$ delimiter ; -- 执行存储过程，添加8000000条记录 call insert_emp(100001, 8000000); 到此，已经创建出了海量数据的表了。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-13T14:46:22+08:00">
    <meta property="article:modified_time" content="2024-06-13T14:46:22+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【MySQL】索引</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>索引</h4> 
 <ul><li><a href="#1_7" rel="nofollow">1.初识索引</a></li><li><a href="#2_99" rel="nofollow">2.认识磁盘</a></li><li><a href="#3MySQL__157" rel="nofollow">3.MySQL 与磁盘交互基本单位</a></li><li><a href="#4_182" rel="nofollow">4.建立共识</a></li><li><a href="#5_203" rel="nofollow">5.索引的理解</a></li><li><a href="#6_487" rel="nofollow">6.索引操作</a></li><li><a href="#7_719" rel="nofollow">7.全文索引</a></li></ul> 
</div> 
<p></p> 
<p><img src="https://images2.imgbox.com/ac/2f/hLL1Uyt8_o.jpg" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>点赞</strong>👍👍<strong>收藏</strong>🌟🌟<strong>关注</strong>💖💖<br> <font color="red"><strong>你的支持是对我最大的鼓励，我们一起努力吧!😃😃</strong></font></p> 
</blockquote> 
<h2><a id="1_7"></a>1.初识索引</h2> 
<p><strong>没有索引，可能会有什么问题？</strong></p> 
<p>索引：提高数据库的性能，索引是物美价廉的东西了。不用加内存，不用改程序，不用调sql，只要执行正确的 create index ，查询速度就可能提高成百上千倍。但是天下没有免费的午餐，查询速度的提高是以插入、更新、删除的速度为代价的，这些写操作，增加了大量的IO。所以它的价值，在于<strong>提高一个海量数据的检索速度</strong>。</p> 
<p>所有mysql的CURD操作全部都是在mysql的内存中进行的，mysql在启动的是会预先开辟一大块空间，开辟好空间之后在合适的时候把数据对应CURD操作体现在内存级，然后mysql会定期把数据刷新到磁盘中做持久化。换言之<strong>MySQL的服务器，本质是在内存中的，所有的数据库的CURD操作，全部都是在内存中进行的！ 索引也是如此</strong></p> 
<p>索引是提高效率的，一般我们知道<strong>提高算法效率的因素：1. 组织数据的方式 ，2. 算法本身</strong>。索引是更改特定组织数据的方式，把以前数据的组织方式以新的数据结构组织起来。所以<strong>索引是内存中一种特定结构组织的一种结构</strong>，具体是什么结构后面再说，</p> 
<p>常见索引分为：</p> 
<ul><li>主键索引(primary key)</li><li>唯一索引(unique)</li><li>普通索引(index)</li><li>全文索引(fulltext)–解决中子文索引问题。</li></ul> 
<p>下面见识一下索引<br> 先整一个海量表，在查询的时候，看看没有索引时有什么问题？</p> 
<pre><code class="prism language-cpp"><span class="token operator">--</span>构建一个<span class="token number">8000000</span>条记录的数据
<span class="token operator">--</span>构建的海量表数据需要有差异性，所以使用存储过程来创建， 拷贝下面代码就可以了，暂时不用理解
<span class="token operator">--</span> 产生随机字符串
delimiter $$
create function <span class="token function">rand_string</span><span class="token punctuation">(</span>n INT<span class="token punctuation">)</span>
returns <span class="token function">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span>
begin
	declare chars_str <span class="token function">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token keyword">default</span>
		'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ<span class="token number">'</span><span class="token punctuation">;</span>
declare return_str <span class="token function">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token char">''</span><span class="token punctuation">;</span>
declare i <span class="token keyword">int</span> <span class="token keyword">default</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> i <span class="token operator">&lt;</span> n <span class="token keyword">do</span>
	set return_str <span class="token operator">=</span><span class="token function">concat</span><span class="token punctuation">(</span>return_str<span class="token punctuation">,</span><span class="token function">substring</span><span class="token punctuation">(</span>chars_str<span class="token punctuation">,</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">52</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	set i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
	end <span class="token keyword">while</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> return_str<span class="token punctuation">;</span>
	end $$
delimiter <span class="token punctuation">;</span>


<span class="token operator">--</span>产生随机数字
delimiter $$
create function <span class="token function">rand_num</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
returns <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
begin
	declare i <span class="token keyword">int</span> <span class="token keyword">default</span> <span class="token number">0</span><span class="token punctuation">;</span>
	set i <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">+</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> i<span class="token punctuation">;</span>
end $$
delimiter <span class="token punctuation">;</span>

<span class="token operator">--</span>创建存储过程，向雇员表添加海量数据
delimiter $$
create procedure <span class="token function">insert_emp</span><span class="token punctuation">(</span>in start <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>in max_num <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
begin
declare i <span class="token keyword">int</span> <span class="token keyword">default</span> <span class="token number">0</span><span class="token punctuation">;</span>
	set autocommit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	repeat
		set i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
	insert into EMP <span class="token function">values</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>start<span class="token operator">+</span>i<span class="token punctuation">)</span>
<span class="token punctuation">,</span><span class="token function">rand_string</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token char">'SALESMAN'</span><span class="token punctuation">,</span><span class="token number">0001</span><span class="token punctuation">,</span><span class="token function">curdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2000</span><span class="token punctuation">,</span><span class="token number">400</span><span class="token punctuation">,</span><span class="token function">rand_num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		until i <span class="token operator">=</span> max_num
	end repeat<span class="token punctuation">;</span>
	commit<span class="token punctuation">;</span>
end $$
delimiter <span class="token punctuation">;</span>

<span class="token operator">--</span> 执行存储过程，添加<span class="token number">8000000</span>条记录
call <span class="token function">insert_emp</span><span class="token punctuation">(</span><span class="token number">100001</span><span class="token punctuation">,</span> <span class="token number">8000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>到此，已经创建出了海量数据的表了。</p> 
<p><strong>查询员工编号为998877的员工</strong></p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> EMP where empno=998877<span class="token punctuation">;</span>
</code></pre> 
<p>目前我们什么都没有做，发现查的非常慢。可以看到耗时4.29秒，这还是在本机一个人来操作，在实际项目中，如果放在公网中，假如同时有1000个人并发查询，那很可能就死机。</p> 
<p><img src="https://images2.imgbox.com/25/e5/tRHp7Kug_o.png" alt="在这里插入图片描述"></p> 
<p><strong>解决方法，创建索引</strong></p> 
<pre><code class="prism language-powershell">alter table EMP add index<span class="token punctuation">(</span>empno<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>我们仅仅创建一个索引，发现查找效率根之前相比提升了好几个数量级。</p> 
<p><img src="https://images2.imgbox.com/42/94/FKhvf6h8_o.png" alt="在这里插入图片描述"></p> 
<p>这就是创建索引的好处提高一个海量数据的检索速度，接下来我们正式进入索引的学习，我们先谈硬件，在谈系统，然后在谈mysql。</p> 
<h2><a id="2_99"></a>2.认识磁盘</h2> 
<p><strong>硬件理解</strong></p> 
<p><strong>MySQL与存储</strong><br> MySQL 给用户提供存储服务，而存储的都是数据，数据在磁盘这个外设当中。磁盘是计算机中的一个机械设备，相比于计算机其他电子元件，磁盘效率是比较低的，在加上IO本身的特征，可以知道，如何提升效率，是 MySQL 的一个重要话题。</p> 
<p><strong>先来研究一下磁盘：</strong><br> <img src="https://images2.imgbox.com/43/de/XFsdecGU_o.png" alt="在这里插入图片描述"></p> 
<p>在看看磁盘中一个盘片<br> <img src="https://images2.imgbox.com/47/a1/AO5p16cc_o.png" alt="在这里插入图片描述"><br> <strong>扇区</strong></p> 
<p>数据库文件，本质其实就是保存在磁盘的盘片当中。也就是上面的一个个小格中，就是我们经常所说的扇区。当然，数据库文件很大，也很多，一定需要占据多个扇区。</p> 
<p>题外话：</p> 
<ul><li>从上图可以看出来，在半径方向上，距离圆心越近，扇区越小，距离圆心越远，扇区越大</li><li>那么，所有扇区都是默认512字节吗？目前是的，我们也这样认为。因为保证一个扇区多大，是由比特位密度决定的。</li><li>不过最新的磁盘技术，已经慢慢的让扇区大小不同了，不过我们现在暂时不考虑。</li></ul> 
<p>我们在使用Linux，所看到的大部分目录或者文件，其实就是保存在硬盘当中的。(当然，有一些内存文件系统，如： proc ， sys 之类，我们不考虑)</p> 
<p>建立数据库其实就是在linux下建立一个目录，建立一张表其就是在linux建立一个文件。</p> 
<p><img src="https://images2.imgbox.com/03/c2/xxDBdFN1_o.png" alt="在这里插入图片描述"></p> 
<p>所以，最基本的，找到一个文件的全部，本质，就是在磁盘找到所有保存文件的扇区。</p> 
<p>而我们能够定位任何一个扇区，那么便能找到所有扇区，因为查找方式是一样的。</p> 
<p><strong>定位扇区</strong></p> 
<p><img src="https://images2.imgbox.com/fc/89/kkTtiy5U_o.png" alt="在这里插入图片描述"></p> 
<ul><li>柱面(磁道): 多盘磁盘，每盘都是双面，大小完全相等。那么同半径的磁道，整体上便构成了一个柱面</li><li>每个盘面都有一个磁头，那么磁头和盘面的对应关系便是1对1的</li><li>所以，我们只需要知道，磁头（Heads）、柱面(Cylinder)(等价于磁道)、扇区(Sector)对应的编号。即可在磁盘上定位所要访问的扇区。这种磁盘数据定位方式叫做 CHS 。不过实际系统软件使用的并不是 CHS （但是硬件是），而是 LBA ，一种线性地址，可以想象成虚拟地址与物理地址。系统将 LBA 地址最后会转化成为 CHS ，交给磁盘去进行数据读取。不过，我们现在不关心转化细节，知道这个东西，让我们逻辑自洽起来即可。</li></ul> 
<p><strong>结论</strong></p> 
<p>我们现在已经能够在硬件层面定位，任何一个基本数据块了(扇区)。那么在系统软件上，就直接按照扇区(512字节，部分4096字节),进行IO交互吗？不是</p> 
<ul><li>如果操作系统直接使用硬件提供的数据大小进行交互，那么系统的IO代码，就和硬件强相关，换言之，如果硬件发生变化，系统必须跟着变化</li><li>从目前来看，单次IO 512字节，还是太小了。IO单位小，意味着读取同样的数据内容，需要进行多次磁盘访问，会带来效率的降低。</li><li>之前学习文件系统，就是在磁盘的基本结构下建立的，文件系统读取基本单位，就不是扇区，而是数据块。</li></ul> 
<p>故，系统读取磁盘，是以块为单位的，基本单位是 <strong>4KB</strong> 。</p> 
<p><strong>磁盘随机访问(Random Access)与连续访问(Sequential Access)</strong></p> 
<p>随机访问：本次IO所给出的扇区地址和上次IO给出扇区地址不连续，这样的话磁头在两次IO操作之间需要作比较大的移动动作才能重新开始读/写数据。</p> 
<p>连续访问：如果当次IO给出的扇区地址与上次IO结束的扇区地址是连续的，那磁头就能很快的开始这次IO操作，这样的多个IO操作称为连续访问。</p> 
<p>因此尽管相邻的两次IO操作在同一时刻发出，但如果它们的请求的扇区地址相差很大的话也只能称为随机访问，而非连续访问。</p> 
<p>磁盘是通过机械运动进行寻址的，连续访问不需要过多的定位，故效率比较高。</p> 
<p>硬件我们了解了，接下来就是考虑软件上的，软件上还有两个主体要讨论，一个是操作系统本身，一个是mysql应用程序，这两个加上刚才的磁盘，它们三者之间数据是如何在三者之间传递的呢？</p> 
<h2><a id="3MySQL__157"></a>3.MySQL 与磁盘交互基本单位</h2> 
<p><strong>软件理解</strong></p> 
<p>MySQL 是一个应用层软件，在系统角度它是一个应用进程，在网络角度它是一个应用层服务，不管是系统还是网络角度mysql都是在应用层的，所以在mysql之下并不直接是硬件，而叫做操作系统。</p> 
<p>操作系统和磁盘之间进行IO交互是按照 <strong>4KB</strong> 进行IO交互的。<br> MySQL 作为一款应用软件，就是一种基于OS之上的特殊的文件系统。它比一般的文件系统有着更高的IO场景，所以，为了提高基本的IO效率， MySQL 进行IO的基本单位是 <strong>16KB</strong> ，从逻辑上看就好像mysql和磁盘之间直接进行16KB交互，但mysql是一个应用层服务是不可能直接访问到硬件的。真正和硬件打交道的只有操作系统。这个16KB实际是站在mysql角度它向OS提出来的，在OS内存存在对应缓存区，mysql对某个表进行CURD不就是对表的内容进行增删查改吗，不就是相当于打开文件，有自己的文件缓存区。<strong>MySQL以 16KB 为单位是和OS为单位的</strong>，而OS只是一个管事的，mysql说要16kb空间，那么OS在做磁盘级访问的时候，它需要把16KB的访问方式给我们转化为在文件系统级别的4 * 4KB，需要在文件找4个4KB大小的数据块，在硬件上就变成16*8这么多的扇区加载到内存里。</p> 
<p>MySQL 进行IO的基本单位是 <strong>16KB</strong> ，在逻辑上可以认为mysql从直接从磁盘读了16KB，真实情况下是，MySQL伸手向操作系统要的，操作系统就会从磁盘上把文件内容导入到文件缓存区里，让MySQL以16KB为单位拿到自己的MySQL内部。MySQL自己会提前申请一大块空间buffer pool，会以16KB为单位读到MySQL自己的缓存区里，然后在MySQL内部用自己的代码对数据做处理。</p> 
<p>往后它向对数据做刷新的时候，按照16KB写到文件缓存区里，调用的是write把数据写到缓存区里，然后在调用的fsync把16KB数据刷新到磁盘里。</p> 
<p><img src="https://images2.imgbox.com/11/ef/zSYElm6O_o.png" alt="在这里插入图片描述"><br> 现在我们也大概清楚mysql，操作系统和磁盘z三者之间在数据块流动上的关系。永远都是硬件给操作系统，操作系统给mysql。mysql写的时候先给操作系统，再由操作系统给磁盘。</p> 
<pre><code class="prism language-powershell">SHOW GLOBAL STATUS LIKE <span class="token string">'innodb_page_size'</span><span class="token punctuation">;</span>
</code></pre> 
<p>16*1024=16384</p> 
<p><img src="https://images2.imgbox.com/8f/88/1NHcXbFo_o.png" alt="在这里插入图片描述"></p> 
<p>磁盘这个硬件设备的基本单位是 512 字节，而 MySQL InnoDB引擎 使用 16KB 进行IO交互。即， MySQL 和磁盘进行数据交互的基本单位是 16KB 。这个基本数据单元，在 MySQL 这里叫做 <strong>page</strong>（注意和系统的page区分）它们是1:4的关系</p> 
<h2><a id="4_182"></a>4.建立共识</h2> 
<ul><li>MySQL 中的数据文件，是以page为单位保存在磁盘当中的。</li><li>MySQL 的 CURD 操作，都需要通过<strong>计算</strong>，找到对应的插入位置，或者找到对应要修改或者查询的数据。</li><li>而只要涉及计算，就需要CPU参与，而为了便于CPU参与，一定要能够先将数据移动到内存当中。所以对于磁盘中mysql表中的数据，需要访问的凡是要被CURD操作的，都必须先由磁盘搬到OS内部，在搬到mysql自己对应的缓存区内部，在自己缓存区里面用自己mysql代码对自己缓存区的数据做CURD。</li><li>所以在特定时间内，表中的数据一定是磁盘中有，内存中也有。后续操作完内存数据之后，以特定的刷新策略，刷新到磁盘。而这时，就涉及到磁盘和内存的数据交互，也就是IO了。而此时IO的基本单位就是Page。</li><li>为了更好的进行上面的操作， MySQL 服务器在内存中运行的时候，在服务器内部，就申请了被称为 <strong>Buffer Pool</strong> 的的大内存空间，来进行磁盘和操作系统，操作系统和mysql之间IO交互。其实就是很大的内存空间，来和磁盘数据进行IO交互。</li></ul> 
<p>默认开辟128M，即使注释掉，mysql也会开有自己的默认的大小，一般就是128M</p> 
<p><img src="https://images2.imgbox.com/ea/f7/2ScsZINr_o.png" alt="在这里插入图片描述"></p> 
<ul><li>为何更高的效率，一定要尽可能的减少系统和磁盘IO的次数</li></ul> 
<p>如上就是我们建立的共识，说到底就三个共识：</p> 
<ol><li>mysql以 16KB page为单位进行mysql级别的IO</li><li>mysql要有自己的 buffer pool ，mysql在进行IO的时候会把自己读到的数据写到buffer pool里，刷新的时候也是把buffer pool里的数据刷新到OS内部的缓存区里，最终在刷新到磁盘</li><li>一般在进行系统级IO的时候，尽量减少操作系统和磁盘进行IO的次数，一次IO的数据量越大，IO的次数就会越少，效率就会越高。</li></ol> 
<p>以上就是我们学习索引的预备工作，下面正式开始学习索引。</p> 
<h2><a id="5_203"></a>5.索引的理解</h2> 
<p>建立测试表</p> 
<pre><code class="prism language-powershell">create table <span class="token keyword">if</span> not exists user <span class="token punctuation">(</span>
	id int primary key<span class="token punctuation">,</span> <span class="token operator">--</span>一定要添加主键哦，只有这样才会默认生成主键索引
	age int not null<span class="token punctuation">,</span>
	name varchar<span class="token punctuation">(</span>16<span class="token punctuation">)</span> not null
<span class="token punctuation">)</span>
</code></pre> 
<p>默认就是InnoDB引擎</p> 
<p><img src="https://images2.imgbox.com/43/82/z8P47MB0_o.png" alt="在这里插入图片描述"></p> 
<p>插入多条记录<br> 注意，我们并没有按照主键的大小顺序插入</p> 
<p><img src="https://images2.imgbox.com/76/c8/slNJOkWu_o.png" alt="在这里插入图片描述"></p> 
<p>查看插入结果<br> 发现竟然默认是有序的！</p> 
<p><img src="https://images2.imgbox.com/a0/06/IrP9GhIT_o.png" alt="在这里插入图片描述"></p> 
<p><strong>我们向一个具有主键的表中，乱序插入数据，发现数据会自动排序。谁做的？为什么这么做？</strong></p> 
<p>解决这个问题这里我们需要<strong>重谈一下page</strong><br> 之前说的磁盘上的文件中的数据会被先读到操作系统的文件缓存区中，mysql在启动的时候就给自己申请一个buffer pool，也说过mysql和整个系统之间进行IO交互的基本单位是16KB，为什么是16KB 是为了提高效率减少IO成本，这都没问题。那这是不是意味着在mysql层面上所以的page都会被放到这个buffer pool里，这个也没问题。下面我们的问题就是，<strong>如何理解myql中page的概念？</strong></p> 
<p><strong>mysq内部</strong>，在启动变成一个服务进程的时候，<strong>一定需要并且会存在大量的page</strong>，那一个page新加进来的，那一个page是脏数据曾经被数据写过了，那一个page已经加载了很长时间需要尽快给它刷新，那一个page需要被淘汰，那一个page需要被维持，我们未来在遍历查找的时候怎么在各个page中遍历。这些问题就不仅仅是单个pageIO能解决的。所以mysql中一定会存在大量的page，所以<strong>也就决定了mysql必须要将多个同时存在的page管理起来！</strong></p> 
<p><strong>要管理所有mysql内的page， 需要 先描述，在组织！</strong></p> 
<p><strong>所以，不要简单的将page认为是一个内存块，page内部也必须写入对应的管理信息！！</strong></p> 
<p><strong>所谓在mysql申请一个page，实际是就是new page。然后简单一点将所有page用 “链表” 的形式管理起来。所以我们现在很简单粗暴的在buffer pool内部，对mysql中的page进行了一个建模！</strong></p> 
<p><img src="https://images2.imgbox.com/92/a5/9ECf6W1O_o.png" alt="在这里插入图片描述"></p> 
<p>还有一个认识，<strong>为什么IO交互要是page。</strong><br> <strong>为何MySQL和磁盘进行IO交互的时候，要采用Page的方案进行交互呢?用多少，加载多少不香吗?</strong></p> 
<p>如上面的5条记录，如果MySQL要查找id=2的记录，第一次加载id=1，第二次加载id=2，一次一条记录，那么就需要2次IO。如果要找id=5，那么就需要5次IO。</p> 
<p>但，如果这5条(或者更多)都被保存在一个Page中(16KB，能保存很多记录),那么第一次IO查找id=2的时候，整个Page会被加载到MySQL的Buffer Pool中，这里完成了一次IO。但是往后如果在查找id=1,3,4,5等，完全不需要进行IO了，而是直接在内存中进行了。所以，就在单Page里面，大大减少了IO的次数。</p> 
<p>你怎么保证，用户一定下次找的数据，就在这个Page里面？我们不能严格保证，但是有很大概率，因为有<strong>局部性原理</strong>。<br> 往往IO效率低下的最主要矛盾不是IO单次数据量的大小，而是IO的次数</p> 
<p>上面所说两点关于page的话题，<strong>第一是去理解mysql是会对page做管理的，不要担心load到mysql是乱的。第二为什么要用page，根本原因就是预加载机制可以有效利用局部性原理提高IO效率。</strong> 这就是我们重谈page重要的知识</p> 
<p>现在我们回过头来，我们目前有一个现象，有主键的表对它做插入，对主键列乱序插入，然后查的时候发现是有序的。一个结论，所谓数据最后要以page为单位进行管理的，而page是先描述后组织的。对page有了这样的理解之后，下面就基于一个问题，一个结论，看mysql内部如何对page进行管理的。</p> 
<blockquote> 
 <p><strong>理解单个page</strong></p> 
</blockquote> 
<p>一个page在我看来就是一个大的结构体，里面可以放很多数据也有它自己的属性。一个page可以承载一部分数据，可是一个文件可能很小可能很大，我们目前可以理解mysql建立的表可能会是一个或者多个page构成。</p> 
<p><img src="https://images2.imgbox.com/a9/30/x3YugS6t_o.png" alt="在这里插入图片描述"></p> 
<p>不同的 Page ，在 MySQL 中，都是 16KB ，使用 prev 和 next 构成双向链表</p> 
<p>因为有主键， MySQL 会默认按照主键给我们的数据进行排序，从上面的Page内数据记录可以看出，数据是有序且彼此关联的。如果没有主键默认插入的是什么顺序，查出来就是什么顺序。</p> 
<p><strong>为什么数据库在插入数据时要对其进行排序呢？我们按正常顺序插入数据不是也挺好的吗？</strong><br> 插入数据时排序的目的，就是优化查询的效率。页内部存放数据的模块，实质上也是一个链表的结构，链表的特点也就是增删快，查询修改慢，所以优化查询的效率是必须的。正式因为有序，在查找的时候，从头到后都是有效查找，没有任何一个查找是浪费的，而且，如果运气好，是可以提前结束查找过程的</p> 
<blockquote> 
 <p><strong>理解多个Page</strong></p> 
</blockquote> 
<p>通过上面的分析，我们知道，上面页模式中，只有一个功能，就是<strong>在查询某条数据的时候直接将一整页的数据加载到内存中，以减少硬盘IO次数，从而提高性能</strong>。但是，我们也可以看到，现在的页模式内部，实际上是采用了链表的结构，前一条数据指向后一条数据，本质上还是通过数据的逐条比较来取出特定的数据。</p> 
<p>如果有1千万条数据，一定需要多个Page来保存1千万条数据，多个Page彼此使用双链表链接起来，而且每个Page内部的数据也是基于链表的。那么，查找特定一条记录，也一定是线性查找。这效率也太低了。</p> 
<p><img src="https://images2.imgbox.com/41/27/9Ejo07OV_o.png" alt="在这里插入图片描述"></p> 
<p>所以提高效率我们应该是有两个角度来考量的，一个是在单page的时候如何提高一个page内部链式遍历的效率，一个是在多page的时候怎么去提高在page间查找的效率。</p> 
<p>因此我们引入下一个概念，<strong>页目录</strong></p> 
<p>我们在看《谭浩强C程序设计》这本书的时候，如果我们要看&lt;指针章节&gt;，找到该章节有两种做法</p> 
<ul><li>从头逐页的向后翻，直到找到目标内容</li><li>通过书提供的目录，发现指针章节在234页(假设)，那么我们便直接翻到234页。同时，查找目录的方案，可以顺序找，不过因为目录肯定少，所以可以快速提高定位</li><li>本质上，书中的目录，是多花了纸张的，但是却提高了效率</li><li>所以，目录，是一种“空间换时间的做法”</li></ul> 
<blockquote> 
 <p><strong>单页情况</strong></p> 
</blockquote> 
<p>针对上面的单页Page，我们能否也引入目录呢？当然可以。</p> 
<p>牺牲page一部分保存数据的空间，把腾出来的空间用来保存目录，这所谓的目录里面只有两个字段，第一个是它所指向起始位置的key值，第二它有一个指针字段指向这条记录的起始位置。所以未来在查找key的时候，不需要在数据记录里面查找了，而是去目录中找，先找到对应key值的所处的起始位置，然后在根据指针找到这条记录，然后根据这条记录在向下遍历。虽然最后我们依旧需要遍历，但是是一个很小的子序列遍历了。效率也就大大提高了。</p> 
<p><img src="https://images2.imgbox.com/76/f8/r5iPohRN_o.png" alt="在这里插入图片描述"><br> 那么当前，在一个Page内部，我们引入了目录。比如，我们要查找id=4记录，之前必须线性遍历4次，才能拿到结果。现在直接通过目录2[3]，直接进行定位新的起始位置，提高了效率。</p> 
<p>现在我们可以再次正式回答上面的问题了，为何通过键值 MySQL 会自动排序？<br> <strong>可以很方便引入目录</strong></p> 
<p>目录也是数据它也要占空间，可是page大小是16KB固定的，那么注定page内部保存数据条目要减少，但目录一般都不会特定。所以在单page内建立好目录后，可以提搞对数据检索效率了。</p> 
<blockquote> 
 <p><strong>多页情况</strong></p> 
</blockquote> 
<p>MySQL 中每一页的大小只有 16KB ，单个Page大小固定，所以随着数据量不断增大， 16KB 不可能存下所有的数据，那么必定会有多个页来存储数据。<br> <img src="https://images2.imgbox.com/3a/30/zJGHeNMM_o.png" alt="在这里插入图片描述"><br> 在单表数据不断被插入的情况下， MySQL 会在容量不足的时候，自动开辟新的Page来保存新的数据，然后通过指针的方式，将所有的Page组织起来。</p> 
<p>需要注意，上面的图，是理想结构，大家也知道，目前要保证整体有序，那么新插入的数据，不一定会在新Page上面，这里仅仅做演示。</p> 
<p>这样，我们就可以通过多个Page遍历，Page内部通过目录来快速定位数据。可是，貌似这样也有效率问题，在Page之间，也是需要 MySQL 遍历的，假设数据在最后面，遍历只能在内存中进行，意味着要把前面所有page从磁盘加载到内存里，依旧需要进行大量的IO。其次遍历本身就是线性检测效率依旧是不高的。这样就显得我们之前的Page内部的目录，有点杯水车薪了。</p> 
<p>那么如何解决呢？解决方案，其实就是我们之前的思路，给Page也带上目录</p> 
<ul><li>使用一个目录项来指向某一页，而这个目录项存放的就是将要指向的页中存放的最小数据的键值。</li><li>和页内目录不同的地方在于，这种目录管理的级别是页，而页内目录管理的级别是行。</li><li>其中，每个目录项的构成是：键值+指针。图中没有画全</li></ul> 
<p><img src="https://images2.imgbox.com/86/c7/EGLtO3Li_o.png" alt="在这里插入图片描述"></p> 
<p>存在一个目录页来管理页目录，目录页中的数据存放的就是指向的那一页中最小的数据。有数据，就可通过比较，找到该访问那个Page，进而通过指针，找到下一个Page。</p> 
<p><strong>其实目录页的本质也是页，普通页中存的数据是用户数据，而目录页中存的数据是普通页的地址。</strong></p> 
<p>未来遍历不需要线性遍历最下面那层page了，而是先查页目录，找到对应的page，在这个page里面查page内部的目录，就可以大大提高检索效率。</p> 
<p>可是如果保存数据的page变得非常多，那么注定上层的页目录也变得非常多。我们可以给上层页目录在加页目录！未来我们每次检索数据的时候，直接从顶部开始向下检索</p> 
<p><img src="https://images2.imgbox.com/e5/2c/foqsnG0a_o.png" alt="在这里插入图片描述"></p> 
<p>这个不就是数据结构中的B+树！B+树是一个多叉树。mysql内索引对数据的管理统一使用的是B+树方式管理的。有了B+树就可以快速的的自顶向下的进行数据的查找了。一次可以淘汰更多的数据。</p> 
<p>B+树的特点：</p> 
<blockquote> 
 <p><strong>1.叶子节点保存有数据，路上节点没有，非叶子节点，不要数据，只要目录项</strong></p> 
</blockquote> 
<p>非叶子节点不存数据，可以存储更多的目录项。意味着一个目录页可以更多管理叶子page，也就意味着这棵树它一定是一颗 “<strong>矮胖型</strong>” 的树！</p> 
<p><strong>当未来搜索时一定是从根节点要叶子节点，所以一旦它比较矮胖，意味着途径的路上page减少(注意每一个page都是从磁盘IO来的)，也就意味着找到目标数据只需要更少的page！IO次数更少！在IO层面，提高了效率！</strong></p> 
<p>未来在做搜索时，其实最开始不一定要把整个表结构加载过来创建好，我们只需要把根节点加载过来，然后你需要那一个子节点的我就把你load进来，如果要的数据在一个目录页page所管理的数据页page里，我们只需要加载局部的就可以。我们按序求按照page加载。</p> 
<p><strong>每一个节点都有目录项，可以大大提高搜索效率。</strong></p> 
<p><strong>一个从算法角度提高效率，一个从结构角度提高效率，基于这两点，就整体提高了搜索的效率。</strong></p> 
<p><strong>我们把这整个B+树，局部的也算。我们称为 mysql innode 下的索引结构。一般我们建表插入数据的时候，就是在该结构下进行CURD。</strong></p> 
<p><strong>那我的表就是没有主键怎么办？也是这样的吗？</strong><br> 没错，mysql 在建表的时候会有默认主键，也就是在mysql表中没有指明那列主键，mysql会自动生成一个隐藏列，隐藏列天然就有主键，当数据插入时会以隐藏列充当主键。</p> 
<p>那我自己设置主键是有序的我现在能理解，因为mysql要对数据做管理。可是我没设置主键插入的时候也是B+树，那为什么我插入乱序数据时是乱序查出来的，为什么不是有序。既然都没有主键，那我们想要的有序性，就不应该由我们自己的信息所决定，而是由mysql自己默认带的主键所决定。因为我们主键没有设置对应主键，所以我们怎么插就给我们怎么拿。</p> 
<p>就如前面800w条数据，我们按照员工号搜索那么慢，因为员工号并不是主键，所以只能是在最下面线性遍历，一旦我们以员工号为索引重新构建一颗B+树，我们搜索的是另一棵B+树。所以效率提升了。后面说。</p> 
<p>以后一张表在我看来，mysql内部都是以B+形式呈现的。无论用没有主键，它一定是B+树。这颗B+树是在mysql的缓冲区中的。</p> 
<blockquote> 
 <p><strong>2.叶子节点全部用链表级联起来</strong></p> 
</blockquote> 
<p>首先这是B+树的特点，是mysql选择了这个结构，其次我们比较希望进行范围查找。</p> 
<p><strong>复盘一下</strong></p> 
<ul><li>Page分为目录页和数据页。目录页只放各个下级Page的最小键值。</li><li>查找的时候，自定向下找，只需要加载部分目录页到内存，即可完成算法的整个查找过程，大大减少了IO次数</li></ul> 
<p><strong>现在我们知道构建索引其实就是在mysql内存构建B+树，以你想建立某一列为索引以它作为key值构建B+树。</strong></p> 
<p>刚才我们说的是B+树行，没有说为什么其他数据结构不行？其实没有行不行的概念，只有合不合适。</p> 
<p><strong>InnoDB 在建立索引结构来管理数据的时候，其他数据结构为何不行？</strong></p> 
<p><strong>链表？</strong> 线性遍历</p> 
<p><strong>二叉搜索树？</strong> 退化问题，可能退化成为线性结构</p> 
<p><strong>AVL &amp;&amp; 红黑树？</strong> 虽然是平衡或者近似平衡，但是毕竟是二叉结构，相比较多阶B+，意味着树整体过高，大家都是自顶向下找，层高越低，意味着系统与硬盘更少的IO Page交互。虽然你很秀，但是有更秀的。</p> 
<p><strong>Hash？</strong> 官方的索引实现方式中， MySQL 是支持HASH的，不过 InnoDB 和 MyISAM 并不支持.Hash跟进其算法特征，决定了虽然有时候也很快(O(1))，不过，在面对范围查找就明显不行，另外还有其他差别，有兴趣可以查一下。</p> 
<p>这里的BTREE就是B+<br> <img src="https://images2.imgbox.com/d1/70/M7PpicEI_o.png" alt="在这里插入图片描述"></p> 
<p><strong>B树？</strong> 最值得比较的是 InnoDB 为何不用B树作为底层索引？</p> 
<p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" rel="nofollow">数据结构演示链接</a></p> 
<p><strong>B+ vs B</strong></p> 
<p><strong>B树</strong></p> 
<p><img src="https://images2.imgbox.com/c6/c8/tj0cSPyg_o.png" alt="在这里插入图片描述"></p> 
<p><strong>B+树</strong><br> <img src="https://images2.imgbox.com/1c/0a/hfIz0nLQ_o.png" alt="在这里插入图片描述"><br> B+树非叶子节点不存数据，数据都在叶子节点，并且所有叶子节点用链式结构连接起来。而B树每一个节点内既包含目录项又包含数据，所有B树除了叶子节点有数据路上节点也会包含数据。还有B树的叶子节点是没有被链式结构连接起来的。</p> 
<p><strong>那为什么mysql没有使用B树而用的B+呢？</strong><br> 第一，mysql认为如果给非叶子节点增加数据，也就意味着单个page里能够保存的目录项变少了，意味着一个页目录所能管理的子目录子page就变少了，一旦变少了，在逻辑上这棵B树会比B+树更高一些更瘦一些，也就意味从根道叶子节点搜索的时候，要经过更多的节点要经历更多次IO，算法和IO带来的成本，永远都是IO带来的成本更高的。</p> 
<p>第二，B树的叶子节点没有相连，也就意味着想进行范围查找，依旧要重新遍历这颗B树。而一旦重新遍历B树也就注定在遍历的时候需要每次查B树，可能有些page并不在内存里，又需要在进行IO，同时每次查效率也很慢，不像B+树找到起始位置线性遍历，一定拿到的是有效范围内所有数据。</p> 
<p><strong>最终总结一下为什么选B+?</strong></p> 
<p>节点不存储data，这样一个节点就可以存储更多的key。可以使得树更矮，所以IO操作次数更少。叶子节点相连，更便于进行范围查找</p> 
<blockquote> 
 <p><strong>聚簇索引 VS 非聚簇索引</strong></p> 
</blockquote> 
<p>上面所说的将所有数据都放在叶子节点这种存储引擎是InnoDB默认存储表数据的存储结构。 除了将数据放在叶子节点的InnoDB存储引擎，还有一种就是MyISAM存储引擎。</p> 
<p>MyISAM 存储引擎-主键索引</p> 
<p><strong>MyISAM</strong> 引擎同样使用B+树作为索引结果，<strong>叶节点的data域存放的是数据记录的地址</strong>。下图为 MyISAM表的主索引， Col1 为主键。</p> 
<p><img src="https://images2.imgbox.com/ca/ca/TDaTkMKp_o.png" alt="在这里插入图片描述"></p> 
<p>其中， MyISAM 最大的特点是，将索引Page和数据Page分离，也就是叶子节点没有数据，只有对应数据的地址。</p> 
<p>我们<strong>将B+树和数据本身分离的存储方案称之为 <font color="red">非聚簇索引</font>，我们把B+树和数据放在一起的称之为 <font color="red">聚簇索引</font>。</strong></p> 
<p>下面我们见一下现象，</p> 
<p>默认建表使用的是Innodb存储引擎，数据库建表对应到linux中就是建立文件。会给我们建立两个文件。</p> 
<p>test1.frm <strong>表结构数据</strong> 这个表是什么样子要记录下来<br> test1.ibd 该表对应的是<strong>主键索引和用户数据</strong>，将索引和数据放在一起最终形成一个表结构，虽然现在一行数据没有，但是该表并不为0，因为有主键索引数据</p> 
<p><img src="https://images2.imgbox.com/5d/f3/RCRDpAY5_o.png" alt="在这里插入图片描述"></p> 
<p>该表的存储引擎是myisam，创建表给我我们建立三个文件<br> test2.frm <strong>表结构数据</strong><br> test2.MYD 该表对应的<strong>数据</strong>，当前没有数据，所以是0<br> test.MYI 该表对应的<strong>主键索引数据</strong></p> 
<p>很显然myisam使用两个表来存数据的</p> 
<p><img src="https://images2.imgbox.com/bd/bc/Y8gFSRRb_o.png" alt="在这里插入图片描述"></p> 
<p>换言之我们直接可以看到InnoDB就是聚簇索引，而myisam就是非聚簇索引。</p> 
<p>MyISAM 这种用户数据与索引数据分离的索引方案，叫做非聚簇索引。<br> InnoDB 这种用户数据与索引数据在一起索引方案，叫做聚簇索引。</p> 
<p>当然， MySQL 除了默认会建立主键索引外，我们用户也有可能建立按照其他列信息建立的索引，一般这种索引可以叫做辅助（普通）索引。</p> 
<p>对于 MyISAM ,建立辅助（普通）索引和主键索引没有差别，无非就是主键不能重复，而非主键可重复。</p> 
<p>下图就是基于 MyISAM 的 Col2 建立的索引，和主键索引没有差别</p> 
<p>在mysql中 MyISAM 存储引擎 可以给一张表建立多个B+树，所谓多个B+树每一个都叫做索引。</p> 
<p>所以<strong>索引的本质：就是数据结构！B+ 树</strong></p> 
<p><img src="https://images2.imgbox.com/39/94/W7ov88sr_o.png" alt="在这里插入图片描述"></p> 
<p>InnoDB 除了主键索引，用户也会建立辅助（普通）索引，我们以上表中的 Col3 建立对应的辅助索引如下图，做法依旧是在mysql建立一颗B+树。</p> 
<p><img src="https://images2.imgbox.com/a0/a5/nA4J4yhn_o.png" alt="在这里插入图片描述"><br> 可以看到， InnoDB 的非主键索引中叶子节点并没有数据，而只有对应记录的key值。因为数据没有必要存两份，所以<strong>InnoDB除了主键索引，其他普通索引叶子节点存到都是对应你要构建索引所对应键值的主键值。</strong></p> 
<p>所以通过辅助（普通）索引，找到目标记录，需要两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。这种过程，就叫做<strong>回表查询</strong></p> 
<p>为何 InnoDB 针对这种辅助（普通）索引的场景，不给叶子节点也附上数据呢？<strong>原因就是数据存两份太浪费空间了</strong></p> 
<blockquote> 
 <p><strong>所以一张表没有指明任何主键，mysql默认会给表添加默认主键也会以B+树结构呈现，只不过我没有设立主键就只能线性遍历。如果我们指明主键默认我们的表会配上主键索引，会以我们自己设置的主键为key值设立主键索引。如果我们指明主键索引，未来还想给其他列设置索引，我们可以手动添加。添加之后会在mysql内部重新构建B+树，以MyISAM为例会指向记录，如果是InnoDB保存的是主键值方便我们快速索引。换句话说，一个表可能会建立主键索引或者其他普通索引，不管建立任何索引最终在mysql中一张表可能会有多颗B+树。</strong></p> 
</blockquote> 
<p>索引语法上分三类：<strong>主键索引、唯一键索引、普通索引</strong>，但其实宏观上就两类一个是主键索引，指明就用主键的没有指明就用默认的。一个是普通索引，包括唯一索引。</p> 
<p>总结：</p> 
<ul><li>如何理解硬盘</li><li>如何理解柱面，磁道，扇区，磁头</li><li>InnoDB 主键索引和普通索引</li><li>MyISAM 主键索引和普通索引</li><li>其他数据结构为何不能作为索引结构，尤其是B+和B</li><li>聚簇索引 VS 非聚簇索引</li></ul> 
<h2><a id="6_487"></a>6.索引操作</h2> 
<blockquote> 
 <p><strong>创建主键索引</strong></p> 
</blockquote> 
<p>第一种方式：<strong>在创建表的时候，直接在字段名后指定 primary key</strong><br> 你以为你仅仅指明主键，其实不止如此，在mysql看来它认为这是主键，未来然后会根据这个主键列充当索引的key值。</p> 
<pre><code class="prism language-powershell">create table test1<span class="token punctuation">(</span>id int primary key<span class="token punctuation">,</span> name varchar<span class="token punctuation">(</span>30<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>第二种方式： <strong>在创建表的最后，指定某列或某几列为主键索引</strong></p> 
<pre><code class="prism language-powershell">create table test2<span class="token punctuation">(</span>id int<span class="token punctuation">,</span> name varchar<span class="token punctuation">(</span>30<span class="token punctuation">)</span><span class="token punctuation">,</span> primary key<span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>第三种方式：<strong>创建表以后再添加主键</strong></p> 
<pre><code class="prism language-powershell">create table test3<span class="token punctuation">(</span>id int<span class="token punctuation">,</span> name varchar<span class="token punctuation">(</span>30<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

alter table test3 add primary key<span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这些操作都很简单，但是如何证明你是有这个索引的？所以这里我们先引入查看索引的方式。</p> 
<blockquote> 
 <p><strong>查询索引</strong></p> 
</blockquote> 
<p>第一种方法：</p> 
<pre><code class="prism language-powershell">show keys <span class="token keyword">from</span> 表名
</code></pre> 
<p>第二种方法:</p> 
<pre><code class="prism language-powershell">show index <span class="token keyword">from</span> 表名<span class="token punctuation">;</span>
</code></pre> 
<p>第三种方法（信息比较简略）：</p> 
<pre><code class="prism language-powershell">desc 表名；
</code></pre> 
<p>test1表在创建的是就指明了id为主键，所有天然就有主键索引。</p> 
<p><img src="https://images2.imgbox.com/97/9b/0yW8gbBa_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>删除索引</strong></p> 
</blockquote> 
<p>第一种方法<strong>删除主键索引</strong>：</p> 
<pre><code class="prism language-powershell">alter table 表名 drop primary key<span class="token punctuation">;</span>
</code></pre> 
<p>第二种方法<strong>其他索引的删除</strong>：<br> 索引名就是show index from 表名中的 Key_name 字段</p> 
<pre><code class="prism language-powershell">alter table 表名 drop index 索引名；
</code></pre> 
<p>第三种方法方法：</p> 
<pre><code class="prism language-powershell">drop index 索引名 on 表名
</code></pre> 
<p>这里我们删除主键索引，发现查不到主键索引了，并且表结构的primary key也没有了。</p> 
<p><img src="https://images2.imgbox.com/3c/47/bepTjakp_o.png" alt="在这里插入图片描述"></p> 
<p>现在表中没有主键了，那我们现在可以给它加上主键索引。<br> 发现添加后主键索引又回来了</p> 
<p><img src="https://images2.imgbox.com/bb/66/0eAOFB3Q_o.png" alt="在这里插入图片描述"></p> 
<p>主键索引的特点：</p> 
<ul><li>一个表中，最多有一个主键索引，当然可以使复合主键</li><li>主键索引的效率高（主键不可重复）</li><li>创建主键索引的列，它的值不能为null，且不能重复</li><li>主键索引的列基本上是int</li></ul> 
<blockquote> 
 <p><strong>唯一索引的创建</strong></p> 
</blockquote> 
<p>给某个字段添加唯一键约束，也会默认给我们构建B+树，也叫做唯一索引。</p> 
<p>第一种方式： <strong>在表定义时，在某列后直接指定unique唯一属性。</strong></p> 
<pre><code class="prism language-powershell">create table test4<span class="token punctuation">(</span>id int primary key<span class="token punctuation">,</span> name varchar<span class="token punctuation">(</span>30<span class="token punctuation">)</span> unique<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>第二种方式：<strong>创建表时，在表的后面指定某列或某几列为unique</strong></p> 
<pre><code class="prism language-powershell">create table test5<span class="token punctuation">(</span>id int primary key<span class="token punctuation">,</span> name varchar<span class="token punctuation">(</span>30<span class="token punctuation">)</span><span class="token punctuation">,</span> unique<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>第三种方式：<strong>创建表以后再添加唯一键</strong></p> 
<pre><code class="prism language-powershell">create table test6<span class="token punctuation">(</span>id int primary key<span class="token punctuation">,</span> name varchar<span class="token punctuation">(</span>30<span class="token punctuation">)</span>）<span class="token punctuation">;</span>

alter table test6 add unique<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>此时给name添加唯一键之后，发现有两个B+树，前面是索引名称是 primary ，索引是打在id这一列，第二个索引名称是 name(默认以列名为名称)，索引是打在name这一列，索引类型是B+树</p> 
<p><img src="https://images2.imgbox.com/97/b2/1Wv6M2p3_o.png" alt="在这里插入图片描述"></p> 
<p>其实并不需要自己手动创建一大堆索引，其实当我们建表的时候，mysql会根据约束关系，它本身就会维护表结构，创建一堆索引结构。只不过未来的时候你可能发现这个主键和唯一键用着不爽，你可能想给其他列也打索引，这是后话。</p> 
<p>当我们想删掉唯一键索引，发现和主键一样删除方式不行的。因为主键只有一个并且名称就是primary key。因此只能用第二种方法。</p> 
<p>第二种方法<strong>其他索引的删除</strong>：<br> 索引名就是show index from 表名中的 Key_name 字段</p> 
<pre><code class="prism language-powershell">alter table 表名 drop index 索引名；
</code></pre> 
<p><img src="https://images2.imgbox.com/07/3d/RK3kiy7w_o.png" alt="在这里插入图片描述"></p> 
<p>为什么说这个呢，我们发现主键很特殊，构建是 add primary key，删除是 drop primary key 这没问题。但是删除唯一键不能用drop unique，用的是drop index。未来你会发现我们删除普通索引用的也是drop index。说明unique索引本身也是一个普通索引。只不过指明它是uniqe是为了照顾表中的约束关系。其实在索引层面，普通索引和唯一键索引都是一般索引。最特殊的就是主键索引。</p> 
<p>唯一索引的特点：</p> 
<ul><li>一个表中，可以有多个唯一索引</li><li>查询效率高</li><li>如果在某一列建立唯一索引，必须保证这列不能有重复数据</li><li>如果一个唯一索引上指定not null，等价于主键索引</li></ul> 
<blockquote> 
 <p><strong>普通索引的创建</strong></p> 
</blockquote> 
<p>第一种方式：<strong>在表的定义最后，指定某列为索引</strong></p> 
<pre><code class="prism language-powershell">create table test8<span class="token punctuation">(</span>
	id int primary key<span class="token punctuation">,</span>
	name varchar<span class="token punctuation">(</span>20<span class="token punctuation">)</span><span class="token punctuation">,</span>
	email varchar<span class="token punctuation">(</span>30<span class="token punctuation">)</span><span class="token punctuation">,</span>
	index<span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">--</span>在表的定义最后，指定某列为索引
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>第二种方式：<strong>创建完表以后指定某列为普通索引</strong></p> 
<pre><code class="prism language-powershell">create table test9<span class="token punctuation">(</span>
	id int primary key<span class="token punctuation">,</span> 
	name varchar<span class="token punctuation">(</span>20<span class="token punctuation">)</span><span class="token punctuation">,</span> email
	varchar<span class="token punctuation">(</span>30<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

alter table test9 add index<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">--</span>创建完表以后指定某列为普通索引
</code></pre> 
<p>给name创建索引后，看到现在就有了以name列为key构建索引，结构依旧是B+树，和唯一键是没有任何区别。而唯一键索引知识在语法上强调它这一列的唯一性的。而普通索引随便去用。</p> 
<p><img src="https://images2.imgbox.com/7b/a0/Lfxf9al7_o.png" alt="在这里插入图片描述"></p> 
<p>不用了就给它删除，和唯一键索引删除一模一样。</p> 
<p><img src="https://images2.imgbox.com/8a/4d/YuLPcIzw_o.png" alt="在这里插入图片描述"></p> 
<p>第三种方式：<strong>创建一个索引名为 idx_name 的索引</strong></p> 
<p>可以给要建立的索引取名字</p> 
<pre><code class="prism language-powershell">create table test10<span class="token punctuation">(</span>
	id int primary key<span class="token punctuation">,</span> 
	name varchar<span class="token punctuation">(</span>20<span class="token punctuation">)</span><span class="token punctuation">,</span> email
	varchar<span class="token punctuation">(</span>30<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token operator">--</span> 创建一个索引名为 idx_name 的索引
create index idx_name on test10<span class="token punctuation">(</span>name<span class="token punctuation">)</span>
</code></pre> 
<p>此时发现要创建索引的名字是我们刚才自己写的</p> 
<p><img src="https://images2.imgbox.com/4d/ca/XUQmllCV_o.png" alt="在这里插入图片描述"></p> 
<p>普通索引的特点：</p> 
<ul><li>一个表中可以有多个普通索引，普通索引在实际开发中用的比较多</li><li>如果某列需要创建索引，但是该列有重复的值，那么我们就应该使用普通索引</li></ul> 
<p>那我们创建索引的时候只能在其中某一列创建吗，如果表中有多列信息，<strong>可不可以创建出以多列为key值的索引结构呢？</strong><br> <strong>可以！</strong></p> 
<p>我们以name和email多列建立索引，发现现在有三个索引，难道新增了两个B+树吗？</p> 
<p><img src="https://images2.imgbox.com/3d/14/dSTinfZY_o.png" alt="在这里插入图片描述"></p> 
<p>其实并不是，我们以name和email这两列充当索引列，利用两列值构建B+树，当在这颗B+树搜索的时候这两列必须同时满足才算是找到。它们合起来是一个B+树的键值。</p> 
<p>这里看起来是创建两颗B+树，但是并不是，它们是打在不同列上，一个是name一个是email，用的是同一颗B+树，以多列中的第一列作为索引名称。</p> 
<p><img src="https://images2.imgbox.com/76/67/W9figd6u_o.png" alt="在这里插入图片描述"></p> 
<p>删除的时候，只要一次就删完了</p> 
<p><img src="https://images2.imgbox.com/f1/92/frQKz2FZ_o.png" alt="在这里插入图片描述"></p> 
<p>我们把多列构建起来得到索引，我们称为<strong>复合索引</strong>。说白了其实就是普通索引。只不过以前都是用一列充当key值，而复合索引是把多列值放在一起充当key值，未来查找这颗B+树时必须满足多列值一样才能往下走。</p> 
<p><strong>那什么时候用复合索引呢？</strong><br> 我们知道InnoDB普通索引叶子节点放的是表的主键的key值注定了要回表。今天以name和email构建一个复合索引，未来高频的想通过name找email，其实只用name和email构建一个复合索引，按照name和email去查找的时候，其实数据本来就在这颗复合索引的B+树里，不用在做回表了，因为索引key值就是name和email，只要找到了就可以把它的信息直接返回。<strong>所以一般用复合索引的时候一般比较喜欢在找的时候可能本身key值就是我们想要的值。</strong></p> 
<p>比如根据姓名找到qq号，以前是需要做回表，但是现在将姓名和qq做多列索引，现在仅需按照姓名作为条件进行筛选，<strong>mysql在索引匹配的时候是从左侧开始向右匹配</strong>，姓名只要匹配上了，直接就把qq号返回了，不用在回表。<br> <img src="https://images2.imgbox.com/2e/bb/uANIiStX_o.png" alt="在这里插入图片描述"></p> 
<p>构建复合索引，使用复合索引中某一列来进行在索引中的查找，找到对应的值直接将索引的值直接返回，这种情况我们称为 <strong>索引覆盖</strong> 问题。覆盖的是主键索引直接在复合索引B+树找到对应的值就不用再回表去主键找了。</p> 
<p>mysql在索引匹配的时候是从左侧开始向右匹配，就如上面可以拿张三，或者张三和qq去找，但是不能直接拿qq去找，这种就是复合索引对应的<strong>最左匹配原则</strong>。</p> 
<blockquote> 
 <p><strong>索引创建原则</strong></p> 
</blockquote> 
<ul><li><strong>比较频繁作为查询条件的字段应该创建索引</strong></li><li><strong>唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件</strong><br> 比如给性别打上索引，但性别只有男女，构建出的B+树并不优秀。</li><li><strong>更新非常频繁的字段不适合作创建索引</strong><br> 如考试信息更改太频繁，一般索引创建出来是为了方便我们去查，如果频繁改不仅仅是改数据，索引结构也被调整。因为key变了。</li><li><strong>不会出现在where子句中的字段不该创建索引</strong></li></ul> 
<p>所以<strong>高频被读取、高频作为筛选条件在where出现的、低频被修改、唯一性非常的这样的列比较适合充当索引！</strong></p> 
<h2><a id="7_719"></a>7.全文索引</h2> 
<p>全文索引和之前B+有差别，之前构建的B+都是按照某一列作为键值构建B+树，这个键值的字段往往比较短如id、qq等。但如果这一列中的每一行内容都非常多如上千上万个字符，有时候搜索的时候不仅仅是想找到一条记录，我们就想在这一列中在这一行中找到某些特定的内容。刚才说的主键索引、唯一键索引、普通索引都是为了找到一个记录或者一个记录中某一列或者某几列，如果想找到一列内部它里面某些字段，那我们就必须想办法对这一列内部做搜索，我们就要用全位索引。</p> 
<p><strong>全文索引的创建</strong></p> 
<p>当对文章字段或有大量文字的字段进行检索时，会使用到全文索引。MySQL提供全文索引机制，但是有要求，要求表的存储引擎必须是MyISAM，而且默认的全文索引支持英文，不支持中文。如果对中文进行全文检索，可以使用sphinx的中文版(coreseek)。</p> 
<pre><code class="prism language-powershell">CREATE TABLE articles <span class="token punctuation">(</span>
	id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY<span class="token punctuation">,</span>
	title VARCHAR<span class="token punctuation">(</span>200<span class="token punctuation">)</span><span class="token punctuation">,</span>
	body TEXT<span class="token punctuation">,</span>
	FULLTEXT <span class="token punctuation">(</span>title<span class="token punctuation">,</span>body<span class="token punctuation">)</span>
<span class="token punctuation">)</span>engine=MyISAM<span class="token punctuation">;</span>
</code></pre> 
<p>现在我们是有主键索引的，并且还有全文索引</p> 
<p><img src="https://images2.imgbox.com/fd/03/wu2PTpzK_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-powershell">INSERT INTO articles <span class="token punctuation">(</span>title<span class="token punctuation">,</span>body<span class="token punctuation">)</span> VALUES
	<span class="token punctuation">(</span><span class="token string">'MySQL Tutorial'</span><span class="token punctuation">,</span><span class="token string">'DBMS stands for DataBase ...'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">(</span><span class="token string">'How To Use MySQL Well'</span><span class="token punctuation">,</span><span class="token string">'After you went through a ...'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">(</span><span class="token string">'Optimizing MySQL'</span><span class="token punctuation">,</span><span class="token string">'In this tutorial we will show ...'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">(</span><span class="token string">'1001 MySQL Tricks'</span><span class="token punctuation">,</span><span class="token string">'1. Never run mysqld as root. 2. ...'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">(</span><span class="token string">'MySQL vs. YourSQL'</span><span class="token punctuation">,</span><span class="token string">'In the following database comparison ...'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">(</span><span class="token string">'MySQL Security'</span><span class="token punctuation">,</span><span class="token string">'When configured properly, MySQL ...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/72/a5/ZyAixGTT_o.png" alt="在这里插入图片描述"></p> 
<p><strong>查询有没有database数据</strong></p> 
<p>如果使用如下查询方式，虽然查询出数据，但是没有使用到全文索引</p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> articles where body like <span class="token string">'%database%'</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/cc/5a/Syb6qe62_o.png" alt="在这里插入图片描述"></p> 
<p>可以用<strong>explain工具看一下，是否使用到索引</strong>，explain可以用来查看mysql想怎么指向后面的sql语句。</p> 
<p>id : 这个查的这个sql对应请求序号，序号越大越先执行<br> select_type : SIMPLE表示简单查询，没有用到子查询和合并查询之类的。<br> table : 查的是articles这个表<br> type：表示查询的方式，all表示全部遍历<br> key ：为null 表示没有用到索引</p> 
<p><img src="https://images2.imgbox.com/87/31/rWwgnC3A_o.png" alt="在这里插入图片描述"></p> 
<p><strong>如何使用全文索引呢？</strong></p> 
<pre><code class="prism language-powershell"><span class="token function">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> articles where match<span class="token punctuation">(</span>title<span class="token punctuation">,</span>body<span class="token punctuation">)</span> against <span class="token punctuation">(</span><span class="token string">'database'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>设置match匹配条件，against表示匹配，匹配的是database关键字</p> 
<p><img src="https://images2.imgbox.com/bc/9b/Zzk1pxPZ_o.png" alt="在这里插入图片描述"></p> 
<p>这次在查的时候发现type 是 fulltext 全文索引 ，key代表是使用哪一个索引</p> 
<p><img src="https://images2.imgbox.com/30/75/teYeNedE_o.png" alt="在这里插入图片描述"></p> 
<p>以上作为了解就行了。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/108d9078e1571fda80b633da2382dc4f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【递归、搜索与回溯】综合练习一</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0217bdf62cada5c9e46e6f3760e60972/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vue 3获取DOM元素的大小以及相对于视口的位置的getBoundingClientRect属性</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>