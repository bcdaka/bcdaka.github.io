<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】--- 深入剖析二叉树（上篇）--- 初识树和二叉树 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/08d767c31d16004fe5382bdbb1d31d5b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】--- 深入剖析二叉树（上篇）--- 初识树和二叉树">
  <meta property="og:description" content="Welcome to 9ilk&#39;s Code World (๑•́ ₃ •̀๑) 个人主页: 9ilk (๑•́ ₃ •̀๑) 文章专栏： 数据结构之旅 🏠 初识树 📒 树的概念 树是一种非线性的数据结构，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的集合。把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。
正如现实生活中的树一样，我们的树数据结构也有一个根结点，根节点没有前驱结点树是递归定义的，根节点下有多个分支也就是多个子树，多个子树下又有多个子树对于一颗树可以拆解成根和n颗子树，同样，子树也可以按照相同方式拆分，直到不可拆分 ⚠️ 1.子树不能有交集
2.除了根结点外，每个结点只能有一个父亲
3.一颗N个结点的树有N-1条边
以下的都是子树有交集的，不能叫做树
4.树中不能有环，有环就是图了
为了方便我们深入了解树，我们来普及一些树中的专有名词 ~
📒 树中的专有名词 孩子结点或子结点：某一个结点含有的子树的根结点，如上图中的B,C,D..都是A的子结点双亲结点：若一个节点含有子节点，则这个节点称为其子节点的父节点，，如上图中的A都是B,C,D..的双亲结点兄弟结点：顾名思义，就是有同个双亲结点的子节点，如上图的D,E是兄弟，I,J是兄弟。堂兄弟结点：双亲在同一层的节点互为堂兄弟，如上图的I和K是堂兄弟，注意堂兄弟结点的双亲结点不同结点的祖先：从根到该节点所经分支上的所有节点，如上图A是所有结点祖先，E是IJQP祖先。子孙：以某节点为根的子树中任一节点都称为该节点的子孙.如上图所有结点都是A的子孙，IJQP是E的子孙。结点的度：一个节含有的子树的个数称为该节点的度。叶子结点或终端结点：度为0的结点，也就是没有子树，如上图的P,Q。分支结点或非终端结点：度大于0的结点，如上图的D,H,F...树的度：认为最大的节点的度称为树的度。结点的层次：从根开始定义起，根为第1层（以根为第一层方便区分空树和非空树），根的子节点为第2层，如上图的E层次是2树的高度或深度：树中节点的最大层次，如上图树的深度是4森林：由m（m&gt;0）棵互不相交的树的集合称为森林。（互不相交不仅指没有交集，还有归属关系） 📒 树的表示方法 线性表表示 struct TreeNode { int val; struct TreeNode** subA; int size; int capacity; } 双亲表示法 孩子表示法 这两种较为复杂，博主就不演示了，本人推荐看这位博主文章树的表示
左孩子右兄弟 struct TreeNode { struct TreeNode* leftchild; struct TreeNode* rightbrother; int data; } 🏠 初识二叉树 📒 何为二叉树 一棵二叉树是结点的一个有限集合，该集合:">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-05T11:05:28+08:00">
    <meta property="article:modified_time" content="2024-05-05T11:05:28+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】--- 深入剖析二叉树（上篇）--- 初识树和二叉树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%C2%A0Welcome%20to%209ilk's%20Code%20World" style="text-align:center;"> <span style="color:#a5a5a5;">Welcome to 9ilk's Code World</span></h2> 
<p style="text-align:center;"><span style="color:#a5a5a5;">       <img alt="" src="https://images2.imgbox.com/97/bc/7Li3SOgb_o.jpg"></span></p> 
<p></p> 
<h3 id="(%E0%B9%91%E2%80%A2%CC%81%20%E2%82%83%20%E2%80%A2%CC%80%E0%B9%91)%C2%A0%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5%3A%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A09ilk">(๑•́ ₃ •̀๑) <span style="color:#38d8f0;">个人主页:</span><span style="color:#a5a5a5;">         <a class="link-info" href="https://blog.csdn.net/2301_79448270?type=blog" title="9ilk">9ilk</a></span></h3> 
<h3 id="(%E0%B9%91%E2%80%A2%CC%81%20%E2%82%83%20%E2%80%A2%CC%80%E0%B9%91)%C2%A0%E6%96%87%E7%AB%A0%E4%B8%93%E6%A0%8F%EF%BC%9A%C2%A0%20%C2%A0%20%C2%A0%C2%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%97%85">(๑•́ ₃ •̀๑) <span style="color:#38d8f0;">文章专栏：      <a class="link-info" href="https://blog.csdn.net/2301_79448270/category_12624613.html?spm=1001.2014.3001.5482" title="数据结构之旅">数据结构之旅</a></span></h3> 
<hr> 
<h2 id="%F0%9F%8F%A0%20%E8%AE%A4%E8%AF%86%E6%A0%91">🏠 初识树</h2> 
<h3 id="main-toc">📒 树的概念</h3> 
<blockquote> 
 <p><strong>树</strong>是一种<strong>非线性</strong>的数据结构，它是由n（n&gt;=0）个有限结点组成一个具有层次关系的集合。把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</p> 
</blockquote> 
<ul><li>正如现实生活中的树一样，我们的树数据结构也有一个<strong>根结点，根节点没有前驱结点</strong></li><li><strong>树是递归定义的，根节点下有多个分支也就是多个子树，多个子树下又有多个子树</strong></li><li><strong>对于一颗树可以拆解成根和n颗子树，同样，子树也可以按照相同方式拆分，直到不可拆分</strong></li></ul> 
<p><img alt="" height="562" src="https://images2.imgbox.com/d2/ba/B1J6XgJf_o.png" width="937"></p> 
<blockquote> 
 <p>⚠️  1.子树<span style="color:#fe2c24;">不能有交集</span></p> 
 <p><span style="color:#fe2c24;">       </span><span style="color:#0d0016;">2.除了根结点外，每个结点只能有一个父亲</span></p> 
 <p><span style="color:#0d0016;">       3.一颗N个结点的树有N-1条边</span></p> 
 <p><em><span style="color:#0d0016;">以下的都是子树有交集的，不能叫做树</span></em></p> 
 <p><img alt="" height="175" src="https://images2.imgbox.com/fd/f1/vjwH35bx_o.png" width="528"></p> 
 <p>      4.树中不能有环，<strong>有环就是图了</strong></p> 
</blockquote> 
<p><em>为了方便我们深入了解树，我们来普及一些树中的专有名词 ~</em></p> 
<p></p> 
<h3><span style="color:#38d8f0;">📒 </span><span style="color:#0d0016;">树中的专有名词</span></h3> 
<p>                         <img alt="" height="345" src="https://images2.imgbox.com/72/7c/ld94JIWF_o.png" width="808"></p> 
<ul><li><strong>孩子结点或子结点</strong>：某一个结点含有的<strong>子树的根结点</strong>，如上图中的B,C,D..都是A的子结点</li><li><strong>双亲结点</strong>：若一个节点含有子节点，则这个节点称为其子节点的父节点，，如上图中的A都是B,C,D..的双亲结点</li><li><strong>兄弟结点</strong>：顾名思义，就是有<strong>同个双亲结点的子节点，</strong>如上图的D,E是兄弟，I,J是兄弟。</li><li><strong>堂兄弟结点</strong>：双亲在同一层的节点互为堂兄弟，如上图的I和K是堂兄弟，<span style="color:#fe2c24;">注意堂兄弟结点的双亲结点不同</span></li><li><span style="color:#0d0016;"><strong>结点的祖先</strong>：</span><strong>从根到该节点所经分支上的所有节点</strong>，如上图A是所有结点祖先，E是IJQP祖先。</li><li><strong>子孙</strong>：以<strong>某节点为根的子树中任一节点</strong>都称为该节点的子孙.如上图所有结点都是A的子孙，IJQP是E的子孙。</li><li><strong>结点的度</strong>：一个节<strong>含有的子树的个数</strong>称为该节点的度。</li><li><strong>叶子结点或终端结点</strong>：<strong>度为0</strong>的结点，也就是没有子树，如上图的P,Q。</li><li><strong>分支结点或非终端结点</strong>：度大于0的结点，如上图的D,H,F...</li><li><strong>树的度：认为最大的节点的度称为树的度。</strong></li><li><strong>结点的层次：</strong>从根开始定义起，<strong>根为第1层（以根为第一层方便区分空树和非空树）</strong>，根的子节点为第2层，如上图的E层次是2</li><li><strong>树的高度或深度</strong>：树中节点的最大层次，如上图树的深度是4</li><li><strong>森林</strong>：由m（m&gt;0）棵<span style="color:#fe2c24;">互不相交</span>的树的集合称为森林。（互不相交不仅指没有交集，还有归属关系）</li><li><img alt="" height="595" src="https://images2.imgbox.com/06/ce/Oe0Iex1N_o.png" width="969"></li></ul> 
<h3>📒 树的表示方法</h3> 
<ul><li><strong>线性表表示</strong></li></ul> 
<pre><code class="language-cpp">struct TreeNode
{
    int val;
    struct TreeNode** subA;
    int size;
    int capacity;
}</code></pre> 
<ul><li><strong>双亲表示法 孩子表示法</strong></li></ul> 
<p><em>这两种较为复杂，博主就不演示了，本人推荐看这位博主文章<a class="link-info" href="https://blog.csdn.net/Huberyxiao/article/details/105093085" title="树的表示">树的表示</a></em></p> 
<ul><li>左孩子右兄弟 <pre><code class="language-cpp">struct TreeNode
{
   struct TreeNode* leftchild;
   struct TreeNode* rightbrother;
   int data;
}</code></pre> <p><img alt="" height="732" src="https://images2.imgbox.com/0a/d6/nLyZixN2_o.png" width="1200"></p> </li></ul> 
<p></p> 
<h2>🏠 初识二叉树</h2> 
<h3>📒 何为二叉树</h3> 
<blockquote> 
 <p>一棵二叉树是结点的一个有限集合，该集合:</p> 1. 或者为空 
 <p>2. 由一个根节点加上两棵别称为左子树和右子树的二叉树组成</p> 
</blockquote> 
<p><img alt="" height="478" src="https://images2.imgbox.com/97/88/aP6c2bCQ_o.png" width="1056"></p> 
<blockquote> 
 <p>⚠️ 1.二叉树的结点的度<strong>一定是大与等于0且小于等于2的</strong></p> 
 <p><strong>      </strong>2.二叉树的子树有左右之分，次序不能颠倒，因此二叉树是有序树<br>       3.二叉树可以是空树或只有根结点</p> 
 <p>        <img alt="" height="270" src="https://images2.imgbox.com/18/36/7wkxN7ZG_o.png" width="865"></p> 
</blockquote> 
<h3>📒 完全二叉树 vs 满二叉树</h3> 
<ul><li>满二叉树</li></ul> 
<blockquote> 
 <p>满二叉树：一个二叉树，如果<span style="color:#fe2c24;">每一个层的结点数都达到最大值</span>，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是<span style="color:#fe2c24;">2^k - 1</span> ，则它就是满二叉树</p> 
</blockquote> 
<ul><li>完全二叉树</li></ul> 
<blockquote> 
 <p>完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。</p> 
</blockquote> 
<p>⚠️ </p> 
<p>1.<strong>满二叉树是特殊的完全二叉树</strong></p> 
<p>2.<strong>满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树</strong></p> 
<p>3.<strong>完全二叉树要求最后一层结点从左到右连续</strong></p> 
<p></p> 
<h3>📒 二叉树的性质</h3> 
<ul><li>若规定根节点的层数为1，则一棵非空二叉树的第i层上最多有 2^(i-1)个结点</li><li>若规定根节点的层数为1，则深度为h的二叉树的最大结点数是2^h - 1 .</li></ul> 
<blockquote> 
 <p>推导过程如下图</p> 
 <p><img alt="" height="969" src="https://images2.imgbox.com/f9/a5/YnNsyho7_o.png" width="1200"></p> 
</blockquote> 
<ul><li>若规定根节点的层数为1，具有n个结点的满二叉树的深度，h= log(n+1). (ps:是log以2 <p>为底，n+1为对数).</p> </li></ul> 
<blockquote> 
 <p>推导：设树的高度为h，则n  = 2^(h) - 1; 因此n+1 = 2^h ---&gt; h = log(n+1);</p> 
</blockquote> 
<ul><li>对任何一棵二叉树, 如果度为0其叶结点个数为 n0, 度为2的分支结点个数为n2 ,则有 n0＝ n2＋1.</li></ul> 
<blockquote> 
 <p>推导：假设该二叉树有n个结点，则该二叉树有n-1条边。由于结点个数n=不同度结点个数之和，即n = n0 + n2 + n1;又由于度为2的结点有两条边，度为1的结点有1条边，故可以得到等式关系 n0 + n2 + n1 - 1 = n2 x 2 + n1 x 1;整理可得n0 = n2 + 1. </p> 
</blockquote> 
<ul><li>对于具有n个结点的完全二叉树，如果按照从上至下从左至右的数组顺序对所有节点从0开始编号，则对于序号为i的结点有：</li></ul> 
<ol><li>若i&gt;0，i位置节点的双亲序号：(i-1)/2；i=0，i为根节点编号，无双亲节点</li><li>若2i+1&lt;n，左孩子序号：2i+1，2i+1&gt;=n否则无左孩子</li><li>若2i+2&lt;n，右孩子序号：2i+2，2i+2&gt;=n否则无右孩子</li></ol> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/a3/83/5D0Yk9EE_o.png" width="1200"></p> 
<p></p> 
<h3>📒 二叉树的存储结构</h3> 
<ul><li>顺序存储</li></ul> 
<blockquote> 
 <p>顺序结构存储就是使用数组来存储，一般使用数组只适合表示完全二叉树，因为不是完全二叉树会有空间的浪费。而现实中使用中只有堆才会使用数组来存储，二叉树顺序存储在物理上是一个数组，在逻辑上是一颗二叉树。</p> 
</blockquote> 
<p><img alt="" height="571" src="https://images2.imgbox.com/bf/99/Ciuaq2ZV_o.png" width="1150"></p> 
<p><em>由图中我们可以得知，非完全二叉树采用顺序存储会造成空间的浪费。</em></p> 
<p><em>结论：<span style="color:#fe2c24;">数组存储只适合完全二叉树和满二叉树</span></em></p> 
<p><em>那有什么存储结构表示非完全二叉树而不造成空间的浪费呢？</em></p> 
<ul><li><em>链式存储</em></li></ul> 
<blockquote> 
 <p>二叉树的链式存储结构是指，用链表来表示一棵二叉树，即用链来指示元素的逻辑关系。 通常的方法是链表中每个结点由三个域组成，数据域和左右指针域，左右指针分别用来给出该结点左孩子和右孩子所在的链结点的存储地址 。链式结构又分为二叉链和三叉链。</p> 
</blockquote> 
<p><strong>二叉链</strong></p> 
<pre><code class="language-cpp">typedef int BTDataType;
// 二叉链
struct BinaryTreeNode
{
  struct BinTreeNode* _pLeft; // 指向当前节点左孩子
  struct BinTreeNode* _pRight; // 指向当前节点右孩子
  BTDataType _data; // 当前节点值域
}</code></pre> 
<p><img alt="" height="884" src="https://images2.imgbox.com/db/0d/wVW72JV0_o.png" width="1200"></p> 
<p><strong>三叉链</strong></p> 
<pre><code class="language-cpp">// 三叉链
typedef int BTDataType;
struct BinaryTreeNode
{
 struct BinTreeNode* _pParent; // 指向当前节点的双亲
 struct BinTreeNode* _pLeft; // 指向当前节点左孩子
 struct BinTreeNode* _pRight; // 指向当前节点右孩子
 BTDataType _data; // 当前节点值域
}</code></pre> 
<p><img alt="" height="884" src="https://images2.imgbox.com/46/75/hnvzOKh3_o.png" width="1200"></p> 
<hr> 
<p><em>树上篇到这里就结束啦，下篇博客将介绍二叉树延伸堆及其涉及的算法，望小伙伴们多多支持啊！</em></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1ae256c6f0d8979023d001e647c0ba2b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">文献综述无从下手，这5款AI工具帮你一键搞定，千万别错过！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/54e386d4d0803579f740b1515f8b8a43/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android 14 变更及适配攻略</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>