<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>学习笔记：基于Transformer的时间序列预测模型 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/d42341c5ee58d824c05d6069610d1dc7/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="学习笔记：基于Transformer的时间序列预测模型">
  <meta property="og:description" content="1 一些准备的说明 为了便于读者理解，笔者将采取一个盾构机掘进参数预测的实际项目进行Transformer模型的说明。此外，该贴更多用于本人的学习记录，适合于对Transformer模型已经有一定了解的读者。此此次外，不定期更新中。
一些参考与图片来源：
Transformer论文链接
transformer的细节到底是怎么样的？
深入理解Transformer及其源码解读
Informer论文链接
1.1 采用的数据 具体的数据在csv中如下，这里只展示部分数据
在本项目中，并非所有参数都有用到，本文的示例中，仅仅用到了
&#34;state&#34;: [&#34;刀盘转速(r/min)&#34;, &#34;刀盘压力(bar)&#34;, &#34;总推进力(KN)&#34;, &#34;螺机转速(r/min)&#34;], &#34;action&#34;: [&#34;A组推进压力设定(bar)&#34;, &#34;B组推进压力设定(bar)&#34;, &#34;C组推进压力设定(bar)&#34;, &#34;D组推进压力设定(bar)&#34;, &#34;推进速度2(mm/min)&#34;], &#34;target&#34;: [&#34;VMT导向垂直后(mm)&#34;, &#34;VMT导向水平前(mm)&#34;, &#34;VMT导向垂直前(mm)&#34;, &#34;VMT导向水平后(mm)&#34;, &#34;VMT导向水平趋向RP(mm)&#34;, &#34;VMT导向垂直趋向RP(mm)&#34;] 这些参数，利用pandas包进行提取。
1.2 时间序列数据的格式 接下来，我们理解一下时间序列数据的格式。
对于某一时刻的数据，应该是类似如下所示的一行1×15的tensor：
[[1.51, 86.656, 69.550, ......(共15个数据)]] 这个数据从左到右分别代表某一时刻中的刀盘转速(r/min)、刀盘压力(bar)、总推进力(KN)、......中15个掘进参数的数据。
若是多个连续时刻的数据，如3个时刻的数据，则应是如下所示3×15的tensor：
[[1.51, 86.656, 69.550, ......(共15个数据)], [1.52, 86.756, 69.650, ......(共15个数据)], [1.53, 86.856, 69.750, ......(共15个数据)]] 注意上面这两组数据是笔者胡乱输入的，数值大小没有什么实际意义，切勿对号入座。
1.3 Transformer的输入与输出 假设我们的batch_size = 32，笔者在接下来全文模型的解读中将以训练流程为例进行说明。目的是希望通过8个过去时刻的数据(8×15)预测2个未来时刻的数据(2×6)。
输入：分为encoder与decoder的输入，尺寸分别为32×8×15与32×2×15输出：只有一个，尺寸为32×2×6 其中32为batch_size，32×8×15可理解为32个batch，每个batch中带有8个过去时刻的数据，15是考虑的掘进参数的数目，如1.1图中的刀盘转速、刀盘压力、总推进力、螺机转速、……等15个参数。
在下面的整体结构示意图中，会在对应的位置标出输入与输出的数据尺寸大小，注意Encoder层的输入与输出的tensor大小是一致的，同理Decoder层的输入与输出。
2 整体结构 注：为了适应时间序列预测，相比于原Transformer模型，将最后一个Softmax层删除
3 输入编码 输入在输入前需进行归一化。
输入数据的流动如下图所示，重点关注维度的变化（15——&gt;512）">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-05-09T15:44:05+08:00">
    <meta property="article:modified_time" content="2023-05-09T15:44:05+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">学习笔记：基于Transformer的时间序列预测模型</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1__0"></a>1 一些准备的说明</h2> 
<p>为了便于读者理解，笔者将采取一个盾构机掘进参数预测的实际项目进行Transformer模型的说明。此外，该贴更多用于本人的学习记录，适合于对Transformer模型已经有一定了解的读者。此此次外，不定期更新中。</p> 
<p>一些参考与图片来源：<br> <a href="https://arxiv.org/abs/1706.03762" rel="nofollow">Transformer论文链接</a><br> <a href="https://www.zhihu.com/question/362131975/answer/2182682685" rel="nofollow">transformer的细节到底是怎么样的？</a><br> <a href="https://www.bbsmax.com/A/Gkz1Pm4qdR/" rel="nofollow">深入理解Transformer及其源码解读</a><br> <a href="https://arxiv.org/abs/2012.07436" rel="nofollow">Informer论文链接</a></p> 
<h3><a id="11__10"></a>1.1 采用的数据</h3> 
<p>具体的数据在csv中如下，这里只展示部分数据<br> <img src="https://images2.imgbox.com/8f/2c/7StU94ED_o.png" alt="在这里插入图片描述"><br> 在本项目中，并非所有参数都有用到，本文的示例中，仅仅用到了</p> 
<pre><code>"state": ["刀盘转速(r/min)",
          "刀盘压力(bar)",
          "总推进力(KN)",
          "螺机转速(r/min)"],
"action": ["A组推进压力设定(bar)",
           "B组推进压力设定(bar)",
           "C组推进压力设定(bar)",
           "D组推进压力设定(bar)",
           "推进速度2(mm/min)"],
"target": ["VMT导向垂直后(mm)",
           "VMT导向水平前(mm)",
           "VMT导向垂直前(mm)",
           "VMT导向水平后(mm)",
           "VMT导向水平趋向RP(mm)",
           "VMT导向垂直趋向RP(mm)"]
</code></pre> 
<p>这些参数，利用pandas包进行提取。</p> 
<h3><a id="12__32"></a>1.2 时间序列数据的格式</h3> 
<p>接下来，我们理解一下时间序列数据的格式。<br> 对于某一时刻的数据，应该是类似如下所示的一行1×15的tensor：</p> 
<pre><code>[[1.51, 86.656, 69.550, ......(共15个数据)]]
</code></pre> 
<p>这个数据从左到右分别代表某一时刻中的<code>刀盘转速(r/min)</code>、<code>刀盘压力(bar)</code>、<code>总推进力(KN)</code>、<code>......</code>中15个掘进参数的数据。<br> 若是多个连续时刻的数据，如3个时刻的数据，则应是如下所示3×15的tensor：</p> 
<pre><code>[[1.51, 86.656, 69.550, ......(共15个数据)],
 [1.52, 86.756, 69.650, ......(共15个数据)],
 [1.53, 86.856, 69.750, ......(共15个数据)]]
</code></pre> 
<p>注意上面这两组数据是笔者胡乱输入的，数值大小没有什么实际意义，切勿对号入座。</p> 
<h3><a id="13_Transformer_46"></a>1.3 Transformer的输入与输出</h3> 
<p>假设我们的<code>batch_size = 32</code>，笔者在接下来全文模型的解读中将以训练流程为例进行说明。目的是希望通过8个过去时刻的数据(8×15)预测2个未来时刻的数据(2×6)。</p> 
<ul><li>输入：分为encoder与decoder的输入，尺寸分别为32×8×15与32×2×15</li><li>输出：只有一个，尺寸为32×2×6</li></ul> 
<p>其中32为<code>batch_size</code>，32×8×15可理解为32个batch，每个batch中带有8个过去时刻的数据，15是考虑的掘进参数的数目，如1.1图中的<code>刀盘转速</code>、<code>刀盘压力</code>、<code>总推进力</code>、<code>螺机转速</code>、<code>……</code>等15个参数。<br> 在下面的整体结构示意图中，会在对应的位置标出输入与输出的数据尺寸大小，注意Encoder层的输入与输出的tensor大小是一致的，同理Decoder层的输入与输出。</p> 
<h2><a id="2__53"></a>2 整体结构</h2> 
<p><img src="https://images2.imgbox.com/00/eb/0TQWsmHk_o.jpg" alt="在这里插入图片描述" height="600"><br> 注：为了适应时间序列预测，相比于原Transformer模型，将最后一个<code>Softmax层</code>删除</p> 
<h2><a id="3__56"></a>3 输入编码</h2> 
<p>输入在输入前需进行归一化。<br> 输入数据的流动如下图所示，重点关注维度的变化<code>（15——&gt;512）</code><br> <img src="https://images2.imgbox.com/99/cc/9O7X6JjR_o.jpg" alt="请添加图片描述" height="200"><br> 在一些其他时间序列预测项目，如Informer中，还加入了Global Time Stamp，考虑如星期、月份、节假日等日期因素的影响，这些在本文中均不考虑，只考虑位置编码，具体可见<a href="https://arxiv.org/abs/2012.07436" rel="nofollow">Informer论文链接</a>。</p> 
<h3><a id="31_Embeddings_61"></a>3.1 Embeddings</h3> 
<p>首先利用<code>nn.Linear(n_encoder_inputs, channels)</code>将两个输入的维度投影为512，即尺寸大小由32×8×15和32×2×15分别变为32×8×512和32×2×512</p> 
<h3><a id="32_Positional_Encoding_63"></a>3.2 位置编码（Positional Encoding）</h3> 
<p>利用位置编码，考虑顺序。具体公式如下：<br> <img src="https://images2.imgbox.com/a6/24/lgRIVNgO_o.png" alt="在这里插入图片描述"><br> 其中<code>pos=0~7或0~1</code>、<code>i=0~512/2</code><br> 图中的两个Positional Encoding分别得到尺寸大小为32×8×512和32×2×512的两个tensor<br> （若想深入了解位置编码的作用，可以参考知乎这篇文章<a href="https://www.zhihu.com/question/362131975/answer/2182682685" rel="nofollow">transformer的细节到底是怎么样的？</a>，本文不作过多的讨论）</p> 
<h3><a id="33_Embedding_With_Time_Signal_69"></a>3.3 Embedding With Time Signal</h3> 
<p>将3.1、3.2中的tensor相加，得到一个全新的尺寸大小为32×8×512和32×2×512的两个tensor，如下图所示。<br> <img src="https://images2.imgbox.com/30/05/mwPJlzw0_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="34__72"></a>3.4 代码说明</h3> 
<p>以下只展示与上面说明处相关的代码，以encoder中的为例：</p> 
<pre><code class="prism language-python"> <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>
              n_encoder_inputs<span class="token punctuation">,</span>
              n_decoder_inputs<span class="token punctuation">,</span>
              channels<span class="token operator">=</span><span class="token number">512</span><span class="token punctuation">,</span>
              nhead<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span>
              dropout<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">,</span>
              activation<span class="token operator">=</span><span class="token string">"relu"</span><span class="token punctuation">,</span>
              num_e_layer<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span>
              num_d_layer<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span>
              num_target<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span>TimeSeriesForcasting<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        self<span class="token punctuation">.</span>input_pos_embedding <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Embedding<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">,</span> embedding_dim<span class="token operator">=</span>channels<span class="token punctuation">)</span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        self<span class="token punctuation">.</span>input_projection <span class="token operator">=</span> Linear<span class="token punctuation">(</span>n_encoder_inputs<span class="token punctuation">,</span> channels<span class="token punctuation">)</span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">def</span> <span class="token function">encode_src</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> src<span class="token punctuation">)</span><span class="token punctuation">:</span>
        src_start <span class="token operator">=</span> self<span class="token punctuation">.</span>input_projection<span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">.</span>permute<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>

        in_sequence_len<span class="token punctuation">,</span> batch_size <span class="token operator">=</span> src_start<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> src_start<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        
        pos_encoder <span class="token operator">=</span> <span class="token punctuation">(</span>torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> in_sequence_len<span class="token punctuation">,</span> device<span class="token operator">=</span>src<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span class="token punctuation">.</span>unsqueeze<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>repeat<span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        pos_encoder <span class="token operator">=</span> self<span class="token punctuation">.</span>input_pos_embedding<span class="token punctuation">(</span>pos_encoder<span class="token punctuation">)</span><span class="token punctuation">.</span>permute<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
        
        src <span class="token operator">=</span> src_start <span class="token operator">+</span> pos_encoder
        src <span class="token operator">=</span> self<span class="token punctuation">.</span>encoder<span class="token punctuation">(</span>src<span class="token punctuation">)</span>
        <span class="token keyword">return</span> src
    <span class="token keyword">def</span> <span class="token function">decode_trg</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> trg<span class="token punctuation">,</span> memory<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
        src<span class="token punctuation">,</span> trg <span class="token operator">=</span> x
        src <span class="token operator">=</span> self<span class="token punctuation">.</span>encode_src<span class="token punctuation">(</span>src<span class="token punctuation">)</span>
        out <span class="token operator">=</span> self<span class="token punctuation">.</span>decode_trg<span class="token punctuation">(</span>trg<span class="token operator">=</span>trg<span class="token punctuation">,</span> memory<span class="token operator">=</span>src<span class="token punctuation">)</span>
        <span class="token keyword">return</span> out 
</code></pre> 
<p>输入的<code>src</code>通过投影变换的了维度得到了<code>src_start</code>，即3.1中所述；<br> 关于位置编码，先构造了一个<code>pos_encoder</code>，内为0～in_sequence_len-1(序列长度-1，也就是8-1=7)，此时为[0,1,2,…,7]，然后扩展维度并复制batch_size(32)次，变为</p> 
<pre><code>[[0,1,2,...,7],
 [0,1,2,...,7],
 ...,
 [0,1,2,...,7]]     
</code></pre> 
<p>尺寸大小为(batch_size, in_sequence_len)即(32, 8)，每个位置代表了序列中的位置。<br> 再进行<code>self.input_pos_embedding(pos_encoder)</code>，把值赋给<code>pos_encoder</code>，得到3.2中的Positional Encoding，<br> 最后把<code>src_start</code>和<code>pos_encoder</code>相加，即3.3的操作<br> PS：<br> 这里补充说明下初始化时<br> <code>self.input_pos_embedding = torch.nn.Embedding(1024, embedding_dim=channels)</code><br> 中1024的意义<br> nlp任务中意思是<code>词典的大小，也就是可以被嵌入的词汇表的大小</code>，<br> 放在时间序列预测任务中的话，就是<code>序列长度大小的上限</code>，我的序列长度最多不能超过1024，否则会采取截断或补零等方法解决。</p> 
<p>另外，在实际代码中，采用<code>permute(1, 0, 2)</code>把第0和第1维度转置，应该是为了后续注意力层中操作的便利，在这可暂不理解</p> 
<h2><a id="4_Encoder_130"></a>4 Encoder</h2> 
<p>这里先展示tensor在Encoder中大小变化的过程。<br> <img src="https://images2.imgbox.com/25/92/bbTz7lVY_o.jpg" alt="在这里插入图片描述" height="550"><br> Encoder由N个同样的层构成，每一层的输出作为下一层的输入。其中最后一层的输出进入Decoder，作为Multi-Head Attention层的K与V输入。</p> 
<h3><a id="41_MultiHead_Attention_134"></a>4.1 Multi-Head Attention层</h3> 
<h4><a id="411_SelfAttention_135"></a>4.1.1 Self-Attention</h4> 
<p>下图就是Self-Attention自注意力机制的过程，X为输入，Z为输出。<br> <img src="https://images2.imgbox.com/97/5f/qChz1bjL_o.png" alt="在这里插入图片描述" height="300"><br> <img src="https://images2.imgbox.com/0e/29/UkktTJAK_o.png" alt="在这里插入图片描述" height="200"><br> <img src="https://images2.imgbox.com/bd/50/md18op0g_o.png" alt="在这里插入图片描述" height="80"><br> 关于自注意力更详细的说明可以参考其他文章，网上一搜一大堆，这里就不多赘述了。</p> 
<h4><a id="412_MutiHead_Attention_142"></a>4.1.2 Muti-Head Attention</h4> 
<p>Muti-Head Attention就是将输入转化为Q、K、V，然后按维度<code>d_model=512</code>切割成<code>h=8</code>个，维度变为<code>d_q</code>or<code>d_k</code>or<code>d_v</code>=<code>512/8</code>=<code>64</code>，分别做<code>Self-Attention</code>之后再合并恢复为维度<code>d_model=512</code>,然后再进行一次Linear投影，维度不变，得到输出。如下图所示</p> 
<p>Muti-Head Attention容易产生迷惑的点主要有两：<br> 1、<br> 作者在对Muti-Head Attention介绍时，采用的输入以Q、K、V这样三个字母表示，然后再进行Linear投影，第一次读到的时候确实很容易让人感到混乱，网上几种主流的介绍通常是将输入以及进行Attention计算的Q、K、V进行区分，这使得容易与Self-Attention中的介绍产生冲突。在这里我们可以这么理解，输入（这里先写成Q、K、V）经过Linear投影后，产生了新的Q、K、V替代了原来的Q、K、V，然后进行Self-Attention计算，即上图中的Scaled Dot-Product Attention部分，这样理解就通顺了。</p> 
<p>2、<br> 根据目前本人的搜索结果来看，网上关于Muti-Head Attention的解读方式有两种。<br> <strong>（1）第一种是论文中的解释方式：</strong><br> <mark>论文中的图</mark>以及公式如下<br> <img src="https://images2.imgbox.com/33/e0/2xBpTEJK_o.png" alt="在这里插入图片描述" height="300"><br> <img src="https://images2.imgbox.com/31/20/Dsg3uA34_o.png" alt="在这里插入图片描述" height="200"><br> 并且相信很多人都看过下面这张<mark>解释Muti-Head Attention的图</mark><br> <img src="https://images2.imgbox.com/e3/a3/lZZj9op0_o.png" alt="在这里插入图片描述" height="300"><br> 这两张图的解读都没有问题，但合在一块看就出问题了。<br> 首先，关于Muti-Head Attention输入的表示方式，论文中采用Q、K、V，二图中采用X，二者对应关系存在一定问题。<br> 这个我们在1、中已经进行了说明，其实论文中输入的Q、K、V与二图中的X是完全一致的，即<code>Q=K=V=X</code><br> 其次，最右边的W<sup>O</sup>看上去是一个长条形的矩阵，但实际上，这在论文中应该是一个512×512的矩阵。作者在绘制该图时可能是为了凸显维度的对应关系才画成如此。<br> 那么，将几个问题解决后，重新绘图，应该是如下这一张图<br> <img src="https://images2.imgbox.com/d7/cf/4uiU5Y3Z_o.jpg" alt="在这里插入图片描述" height="500"><br> 理解了这张图后，我们再来看看源码是怎么写的</p> 
<p><strong>（2）第二种是源码的思路：</strong><br> 先上代码，代码可能与pytorch中源码有些许细节上的差别，但整体思路是一致的。</p> 
<pre><code class="prism language-python"><span class="token comment"># 实现多头注意力机制的类</span>
<span class="token keyword">class</span> <span class="token class-name">MultiHeadAttention</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">,</span> embedding_dim<span class="token punctuation">,</span> dropout<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token comment"># head：代表几个头的参数</span>
		<span class="token comment"># embedding_dim：代表词嵌入的维度</span>
		<span class="token comment"># dropout：进行Dropout操作时置零的比率</span>
		<span class="token builtin">super</span><span class="token punctuation">(</span>MultiHeadAttention<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token keyword">assert</span> embedding_dim <span class="token operator">%</span> head <span class="token operator">==</span> <span class="token number">0</span>
		
		self<span class="token punctuation">.</span>d_k <span class="token operator">=</span> embedding_dim <span class="token operator">//</span> head
		self<span class="token punctuation">.</span>head <span class="token operator">=</span> head
		self<span class="token punctuation">.</span>embedding_dim <span class="token operator">=</span> embedding_dim
		<span class="token comment"># 获得四个，分别是Q、K、V及最终输出WO线性层</span>
		self<span class="token punctuation">.</span>linears <span class="token operator">=</span> clones<span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>embedding_dim<span class="token punctuation">,</span> embedding_dim<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>
		<span class="token comment"># 初始化注意力张量</span>
		self<span class="token punctuation">.</span>attn <span class="token operator">=</span> <span class="token boolean">None</span>
		self<span class="token punctuation">.</span>dropout <span class="token operator">=</span> nn<span class="token punctuation">.</span>Dropout<span class="token punctuation">(</span>p<span class="token operator">=</span>dropout<span class="token punctuation">)</span>

	<span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> query<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> mask<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token comment"># query, key, value是注意力机制的三个输入张量，在Encoder中三者一致，mask代表掩码张量</span>
		<span class="token keyword">if</span> mask <span class="token keyword">is</span> <span class="token keyword">not</span> none<span class="token punctuation">:</span>
			<span class="token comment"># 使用suqeeze将掩码张量进行维度扩充，代表多头中的第n个头</span>
			mask <span class="token operator">=</span> mask<span class="token punctuation">.</span>unsqueeze<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>	
		<span class="token comment"># 得到batch_size</span>
		batch_size <span class="token operator">=</span> query<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
		
		query<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value <span class="token operator">=</span> \
		<span class="token punctuation">[</span>model<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>head<span class="token punctuation">,</span> self<span class="token punctuation">.</span>d_k<span class="token punctuation">)</span><span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> \
		<span class="token keyword">for</span> model<span class="token punctuation">,</span> x <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>linears<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>query<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">]</span>
		
		<span class="token comment"># 将每个头的输出传递到注意力层</span>
		x<span class="token punctuation">,</span> self<span class="token punctuation">.</span>atten <span class="token operator">=</span> attention<span class="token punctuation">(</span>query<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> mask<span class="token operator">=</span>mask<span class="token punctuation">,</span> dropout<span class="token operator">=</span>self<span class="token punctuation">.</span>dropout<span class="token punctuation">)</span>
		<span class="token comment"># 得到每个头的计算结果是4维张量，需要进行形状的转换</span>
		<span class="token comment"># 前面已经将1，2两个维度进行转置，在这里要重新转置回来</span>
		<span class="token comment"># 经历了transpose()后必须使用contiguous方法，不然无法使用view()</span>
		x <span class="token operator">=</span> x<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>contiguout<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>head<span class="token operator">*</span>self<span class="token punctuation">.</span>d_k<span class="token punctuation">)</span>
		<span class="token comment"># 最后将x输入线性层列表中的最后一个线性层进行处理</span>
		<span class="token keyword">return</span> self<span class="token punctuation">.</span>linears<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
</code></pre> 
<p>乍一看似乎与论文中的解释方式不太一样，怎么就输入分别乘以三个矩阵再分割呢？不是要考虑多头么？<br> 代码的具体操作可用下图来理解，为了方便进行<code>（1）论文中的解释方式</code>和<code>（2）源码的思路</code>的对比，图中的运算先不考虑<code>batch_size</code>，并且将（1）、（2）放在同一张图中。<br> <img src="https://images2.imgbox.com/38/ff/Sz035IzA_o.jpg" alt="在这里插入图片描述" height="700"><br> （1）、（2）对比可看出，（2）的思路实际上是将W0……W7合并为一个矩阵进行并行运算，本质思路是一致的。</p> 
<h3><a id="42_Add__Norm_213"></a>4.2 Add &amp; Norm层</h3> 
<p>网上非常多，偷懒略了</p> 
<h3><a id="43_Feed_Forward_215"></a>4.3 Feed Forward层</h3> 
<p>网上非常多，偷懒略了</p> 
<h2><a id="5_Decoder_217"></a>5 Decoder</h2> 
<p>Decoder中除了Masked Multi-Head Attention层，其余均与Encoder中的一致，在此不多赘述，仅展示tensor在Decoder中大小变化的过程。<br> <img src="https://images2.imgbox.com/4b/4e/RWziT2uc_o.jpg" alt="在这里插入图片描述" height="700"></p> 
<h3><a id="51_Masked_MultiHead_Attention_221"></a>5.1 Masked Multi-Head Attention层</h3> 
<p>在代码中的作用也可参考4.1.2中的代码部分<br> 在测试以及训练中更加详细的作用见<code>6 模型在训练与测试时的区别</code><br> <img src="https://images2.imgbox.com/b1/c5/EAY2cDrd_o.png" alt="在这里插入图片描述" height="300"><br> <img src="https://images2.imgbox.com/95/5e/yE3KDST4_o.jpg" alt="在这里插入图片描述" height="300"></p> 
<h2><a id="6__226"></a>6 模型在训练与测试时的区别</h2> 
<p>本人在Transformer的学习过程中对此训练与测试时的区别疑惑还是比较大的，特此分出一小节进行说明。主要的思路是参考大佬<a href="https://www.zhihu.com/question/362131975/answer/2182682685" rel="nofollow">transformer的细节到底是怎么样的？</a></p> 
<h3><a id="61__228"></a>6.1 测试时</h3> 
<p>在<code>NLP任务</code>中，通常在Encoder中输入待翻译的句子，若句子中有3个词且翻译后为3个词（如<code>"我""是""谁"</code>——&gt;<code>"who""am""I"</code>），则Encoder输入（先不考虑Padding Mask）的大小为(3, 512)。<br> 而Decoder的输入输出相对不太一样。在Decoder的Multi-Head Attention层中，K和V均是Encoder的输出Memory经过线性变换后的结果（此时的Memory中包含了原始输入序列每个位置的编码信息），而Q是Decoder的Masked Multi-Head Attention层输出的隐含向量经过线性变换后的结果。在Decoder对每一个时刻进行解码时，首先需要做的便是通过Q与K进行交互（query查询），并计算得到注意力权重矩阵；然后再通过注意力权重与V进行计算得到一个权重向量，该权重向量所表示的含义就是在解码时如何将注意力分配到Memory的各个位置上。<br> 在解码第1个时刻时，Decoder输入一个表征的向量（表示句子开头），输入大小为<code>(1, 512)</code>，即下图中所示。得到Q、K、V后，首先Q通过与K进行交互得到权重向量，此时可以看做是Q（待解码向量）在K（本质上也就是Memory）中查询Memory中各个位置与Q有关的信息；然后将权重向量与V进行运算得到解码向量，此时这个解码向量可以看作是考虑了Memory中各个位置编码信息的输出向量，也就是说它包含了在解码当前时刻时应该将注意力放在Memory中哪些位置上的信息。进一步，Decoder得到输出结果后，再经过一次线性层然后输入到分类层中进行分类得到当前时刻的解码输出值。若模型准确，则应当得到<code>"who"</code>的输出结果。<br> <img src="https://images2.imgbox.com/8d/7b/Z2GDotJw_o.png" alt="在这里插入图片描述" height="300"><br> <img src="https://images2.imgbox.com/0e/32/unLGEeHt_o.png" alt="在这里插入图片描述" height="300"><br> 当第1个时刻的解码过程完成之后，应将解码第1个时刻时的输入，以及解码第1个时刻后的输出均作为解码器的输入来解码预测第2个时刻的输出。同理第2个时刻的解码过程完成之后，应将解码第1、2个时刻时的输入，以及解码第2个时刻后的输出均作为解码器的输入来解码预测第2个时刻的输出。</p> 
<ul><li>完整流程如下：<br> 第一个时刻：{<!-- --><code>&lt;start&gt;</code>} ——&gt;{<!-- --><code>who</code>}<br> 第二个时刻：{<!-- --><code>&lt;start&gt;</code>, <code>who</code>} ——&gt;{<!-- --><code>am</code>}<br> 第三个时刻：{<!-- --><code>&lt;start&gt;</code>, <code>who</code>, <code>am</code>} ——&gt;{<!-- --><code>I</code>}<br> 第四个时刻：{<!-- --><code>&lt;start&gt;</code>, <code>who</code>, <code>am</code>, <code>I</code>} ——&gt;{<!-- --><code>&lt;end&gt;</code>}</li></ul> 
<p>显然这时候存在一个问题。如在第三个时刻，输入了{<!-- --><code>&lt;start&gt;</code>, <code>who</code>, <code>am</code>}，应是一个(3, 512)的向量，那么具体计算过程如下图所示。<br> <img src="https://images2.imgbox.com/d7/c9/m4KZ97hi_o.png" alt="在这里插入图片描述" height="300"><br> <img src="https://images2.imgbox.com/c3/da/pIauOvaA_o.png" alt="在这里插入图片描述" height="300"><br> 最后Decoder的输出应是一个和Decoder的输入大小一致的(3, 512)的tensor，而要想得到<code>"I"</code>的结果，Decoder的输出应该是一个(1, 512)的tensor。为此，针对Decoder输出的tensor，只会取其最后一个向量喂入到分类器中进行分类得到当前时刻的解码输出。<br> 同理，在<code>时间序列预测</code>的任务中，我们想要预测2个未来时刻(<code>t1</code>、<code>t2</code>)的数据</p> 
<ul><li>完整流程如下：<br> 第一个时刻：{<!-- --><code>t0时刻数据</code>} ——&gt;{<!-- --><code>t1时刻数据</code>}<br> 第二个时刻：{<!-- --><code>t0时刻数据</code>，<code>t1时刻数据</code>} ——&gt;{<!-- --><code>t2时刻数据</code>}</li></ul> 
<p>在第二个时刻，最后Decoder的输出应是一个和Decoder的输入大小一致的(2, 512)的tensor，而要想得到<code>t2时刻数据</code>，Decoder的输出应该是一个(1, 512)的tensor。为此，针对Decoder输出的tensor，<strong>只会取其最后一个向量</strong>，得到<code>t2时刻数据</code>。</p> 
<h3><a id="62__252"></a>6.2 训练时</h3> 
<p>在介绍完测试时的解码过程后，下面就继续来看在网络在训练过程中是如何进行解码的。在真实预测时解码器需要将上一个时刻的输出作为下一个时刻解码的输入，然后一个时刻一个时刻的进行解码操作。显然，如果训练时也采用同样的方法那将是十分费时的。因此，在训练过程中，解码器也同编码器一样，一次接收解码时所有时刻的输入进行计算。这样做的好处，一是通过多样本并行计算能够加快网络的训练速度；二是在训练过程中直接喂入解码器正确的结果而不是上一时刻的预测值（因为训练时上一时刻的预测值可能是错误的），能够更好的训练网络。<br> 还是以6.1中的NPL任务为例。<mark>编码器的输入</mark>便是{<!-- --><code>"我"</code>, <code>"是"</code>, <code>"谁"</code>}，而<mark>解码器的输入</mark>则是{<!-- --><code>&lt;start&gt;</code>, <code>who</code>, <code>am</code>, <code>I</code>} ，对应的<mark>正确标签</mark>则是{<!-- --><code>who</code>, <code>am</code>, <code>I</code>, <code>&lt;end&gt;</code>,} 。<br> 假设现在解码器的输入{<!-- --><code>&lt;start&gt;</code>, <code>who</code>, <code>am</code>, <code>I</code>} 在分别乘上一个矩阵进行线性变换后得到了Q、K、V，且Q与K作用后得到了注意力权重矩阵（此时还未进行softmax操作），如下图所示。<br> <img src="https://images2.imgbox.com/bc/65/jlx7JIBv_o.png" alt="在这里插入图片描述" height="200"><br> 由第1行的权重向量可知，在解码第1个时刻时应该将2/9的注意力放到<code>&lt;start&gt;</code>上，1/3的注意力放到<code>"who"</code>上等等。不过此时有一个问题就是，模型在预测时是看不到当前时刻之后的信息。因此，Transformer中的Decoder通过加入注意力掩码机制来解决了这一问题。<br> 如下图所示，左边依旧是通过Q和K计算得到了注意力权重矩阵（此时还未进行softmax操作），而中间的就是所谓的注意力掩码矩阵，两者在相加之后再乘上矩阵V便得到了整个自注意力机制的输出，也就是Decoder中的Masked Multi-Head Attention。<br> <img src="https://images2.imgbox.com/1b/df/wAWCKSTo_o.png" alt="在这里插入图片描述" height="170"><br> 那为什么注意力权重矩阵加上这个注意力掩码矩阵就能够达到这样的效果呢？以图中第1行权重为例，当解码器对第1个时刻进行解码时其对应的输入只有<code>&lt;start&gt;</code>，因此这就意味着此时应该将所有的注意力放在第1个位置上（<code>&lt;start&gt;</code>位置上，尽管在训练时解码器一次喂入了所有的输入），换句话说也就是第1个位置上的权重应该是1，而其它位置则是0。从图中可以看出，第1行注意力向量在加上第1行注意力掩码，再经过softmax操作后便得到了一个类似<code>[1,0,0,0,0]</code>的向量。那么，通过这个向量就能够保证在解码第1个时刻时只能将注意力放在第1个位置上（<code>&lt;start&gt;</code>位置上）的特性。在解码后续的时刻也是类似的过程。此外，这个操作与6.1中提到的“只会取其最后一个向量”的操作吻合。<br> 同理，在时间序列预测的任务中也与上述流程类似，具体不在多赘述。</p> 
<h2><a id="7__263"></a>7 模型的一些小改进</h2> 
<p>受<a href="https://arxiv.org/abs/2012.07436" rel="nofollow">Informer</a>的启发，结合自身项目的要求，对模型的输入进行小调整。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8a86810e654bb6b9c819b78088864c99/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PVE 安装 windows10</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ebc0a79067e4369d4df3e21bb4862ca9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android---Glide的基本使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>