<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【收藏】35个JDK 21新特性（含示例代码） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/abb6e8ca9158faa873a132d7a694318f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【收藏】35个JDK 21新特性（含示例代码）">
  <meta property="og:description" content="2024年威哥携三位兄弟，Mask、强哥、索尓一起探索Java JDK21 LTS版，JDK 21 带来了一些令人兴奋的新特性和改进，总结了一些自己的笔记，分享给大家，本文将介绍其中一些重要的内容，并提供相应的示例代码以帮助读者更好地理解，阅读全文需要花费你10分钟，收藏起来肯定有需要用的时候。
1. JEP 400: Java 程序集
JDK 21 引入了 JEP 400，它为 Java 程序集提供了一种新的模块化方式。这项功能使得开发者能够更轻松地组织和管理大型项目中的代码。它通过 java.assembly 模块提供支持。
示例代码：
import java.assembly.*; assembly HelloWorld { module com.example.helloworld { requires java.base; exports com.example.helloworld; } } 解释：上面的示例代码展示了如何使用 java.assembly 模块来定义一个简单的 Java 程序集。你可以通过 requires 来指定依赖关系，并通过 exports 来导出你的模块。
2. JEP 405: 增强的 Pattern Matching for instanceof
Java 17 引入了模式匹配，JDK 21 在此基础上进一步改进了对 instanceof 的模式匹配支持。现在，可以直接在 instanceof 表达式中使用类型转换。
示例代码：
class Example { void process(Object obj) { if (obj instanceof String s) { System.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-27T10:36:52+08:00">
    <meta property="article:modified_time" content="2024-03-27T10:36:52+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【收藏】35个JDK 21新特性（含示例代码）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>2024年威哥携三位兄弟，Mask、强哥、索尓一起探索Java JDK21 LTS版，JDK 21 带来了一些令人兴奋的新特性和改进，总结了一些自己的笔记，分享给大家，本文将介绍其中一些重要的内容，并提供相应的示例代码以帮助读者更好地理解，阅读全文需要花费你10分钟，收藏起来肯定有需要用的时候。</p> 
<p><strong>1. JEP 400: Java 程序集</strong></p> 
<p>JDK 21 引入了 JEP 400，它为 Java 程序集提供了一种新的模块化方式。这项功能使得开发者能够更轻松地组织和管理大型项目中的代码。它通过 <code>java.assembly</code> 模块提供支持。</p> 
<p>示例代码：</p> 
<pre><code class="language-java">import java.assembly.*;

assembly HelloWorld {
    module com.example.helloworld {
        requires java.base;
        exports com.example.helloworld;
    }
}</code></pre> 
<p>解释：上面的示例代码展示了如何使用 java.assembly 模块来定义一个简单的 Java 程序集。你可以通过 requires 来指定依赖关系，并通过 exports 来导出你的模块。</p> 
<p><strong><strong>2. JEP 405: 增强的 Pattern Matching for </strong></strong><strong><strong><code>instanceof</code></strong></strong></p> 
<p><code>Java 17 引入了模式匹配，JDK 21 在此基础上进一步改进了对 <code>instanceof</code> 的模式匹配支持。现在，可以直接在 <code>instanceof</code> 表达式中使用类型转换。</code></p> 
<p>示例代码：</p> 
<pre><code class="language-java">class Example {
    void process(Object obj) {
        if (obj instanceof String s) {
            System.out.println("String length: " + s.length());
        } else {
            System.out.println("Not a String");
        }
    }
}</code></pre> 
<p>解释：上面的示例代码展示了如何使用改进后的 <code>instanceof</code>，其中 <code>s</code> 是在匹配成功后直接转换为 <code>String</code> 类型，从而可以直接使用它的方法。</p> 
<p><strong>3. JEP 409: 随机生成器的改进</strong></p> 
<p>JDK 21 对随机生成器进行了改进，引入了一些新的方法和算法，提高了其性能和质量。</p> 
<p>示例代码：</p> 
<pre><code class="language-java">import java.util.Random;

public class Example {
    public static void main(String[] args) {
        Random random = new Random();
        int randomNumber = random.nextInt(100);
        System.out.println("Random number: " + randomNumber);
    }
}
</code></pre> 
<p>解释：上面的示例代码展示了如何使用 JDK 21 中改进的 <code>Random</code> 类来生成一个介于 0 和 100 之间的随机数。</p> 
<p><strong>4. JEP 413: 非侵入式的 Java 日志记录</strong></p> 
<p>JDK 21 引入了 JEP 413，这项功能提供了一种非侵入式的方式来进行 Java 日志记录，使得开发者能够更轻松地管理应用程序的日志信息。</p> 
<p>示例代码：</p> 
<pre><code class="language-java">import java.logging.Logger;

public class Example {
    private static final Logger logger = Logger.getLogger(Example.class.getName());

    public static void main(String[] args) {
        logger.info("This is an informational message.");
    }
}</code></pre> 
<p>解释：上面的示例代码展示了如何使用 JDK 21 中的 <code>java.logging.Logger</code> 类来记录日志信息，而无需引入额外的日志框架。</p> 
<p><strong>5. JEP 417: Java 原生 HTTP/2 客户端</strong></p> 
<p>JDK 11 引入了原生的 HTTP 客户端，JDK 21 在此基础上进一步增强了对 HTTP/2 的支持，使得开发者能够更高效地与支持 HTTP/2 协议的服务器进行通信。</p> 
<p>示例代码：</p> 
<pre><code class="language-java">import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;

public class Example {
    public static void main(String[] args) throws Exception {
        HttpClient client = HttpClient.newHttpClient();
        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create("https://example.com"))
                .build();

        HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());

        System.out.println("Response code: " + response.statusCode());
        System.out.println("Response body: " + response.body());
    }
}</code></pre> 
<p>解释：上面的示例代码展示了如何使用 JDK 21 中增强的原生 HTTP 客户端与支持 HTTP/2 协议的服务器进行通信。</p> 
<p><strong>6. JEP 419: 改进的本地字符串操作</strong></p> 
<p>JDK 21 引入了 JEP 419，该功能提供了一组改进的本地字符串操作方法，使得开发者能够更轻松地处理字符串操作。</p> 
<p>示例代码：</p> 
<pre><code class="language-java">import java.nio.charset.StandardCharsets;

public class Example {
    public static void main(String[] args) {
        String str = "Hello, 世界!";

        // 计算字符串长度（代码点数量）
        int codePointCount = str.codePointCount(0, str.length());
        System.out.println("Code point count: " + codePointCount);

        // 将字符串转换为字节数组
        byte[] bytes = str.getBytes(StandardCharsets.UTF_8);
        System.out.println("Byte length: " + bytes.length);
    }
}
</code></pre> 
<p>解释：上面的示例代码展示了如何使用 JDK 21 中的改进的字符串操作方法，包括计算代码点数量和将字符串转换为字节数组等。</p> 
<p><strong>7. JEP 422: 改进的异常处理</strong></p> 
<p>JDK 21 引入了 JEP 422，该功能提供了一些改进的异常处理机制，使得开发者能够更清晰地管理和处理异常情况。</p> 
<p>示例代码：</p> 
<pre><code class="language-java">public class Example {
    public static void main(String[] args) {
        try {
            // 可能会抛出异常的代码
            int result = divide(10, 0);
            System.out.println("Result: " + result);
        } catch (ArithmeticException e) {
            // 捕获并处理异常
            System.err.println("Error: " + e.getMessage());
        }
    }

    private static int divide(int dividend, int divisor) {
        if (divisor == 0) {
            throw new ArithmeticException("Division by zero");
        }
        return dividend / divisor;
    }
}</code></pre> 
<p>解释：上面的示例代码展示了如何使用改进的异常处理机制来捕获和处理可能发生的异常情况。</p> 
<p><strong>8. JEP 425: 增强的数组支持</strong></p> 
<p>JDK 21 引入了 JEP 425，该功能提供了一些增强的数组支持，包括更灵活的数组操作和更丰富的数组功能。</p> 
<p>示例代码：</p> 
<pre><code class="language-java">public class Example {
    public static void main(String[] args) {
        int[] array = {1, 2, 3, 4, 5};

        // 使用流操作对数组进行处理
        int sum = Arrays.stream(array).sum();
        System.out.println("Sum: " + sum);

        // 使用 Arrays 类的方法进行数组排序
        Arrays.sort(array);
        System.out.println("Sorted array: " + Arrays.toString(array));
    }
}</code></pre> 
<p>解释：上面的示例代码展示了如何使用 JDK 21 中增强的数组支持功能，包括使用流操作对数组进行处理以及使用 Arrays 类的方法对数组进行排序。</p> 
<p><strong>9. JEP 428: 默认的序列化版本 UID</strong></p> 
<p>JDK 21 引入了 JEP 428，该功能为没有明确指定序列化版本 UID 的类提供了一个默认的序列化版本 UID，从而增强了序列化的兼容性。</p> 
<p>示例代码：</p> 
<pre><code class="language-java">import java.io.*;

public class Example implements Serializable {
    private static final long serialVersionUID = -8041599049250916662L;

    private String name;
    private int age;

    public Example(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public static void main(String[] args) throws Exception {
        Example obj = new Example("John", 30);

        // 将对象序列化到文件
        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("example.ser"));
        out.writeObject(obj);
        out.close();

        // 从文件中读取对象并反序列化
        ObjectInputStream in = new ObjectInputStream(new FileInputStream("example.ser"));
        Example newObj = (Example) in.readObject();
        in.close();

        System.out.println("Deserialized object: " + newObj);
    }

    @Override
    public String toString() {
        return "Example{name='" + name + "', age=" + age + '}';
    }
}</code></pre> 
<p>解释：上面的示例代码展示了如何使用 JDK 21 中默认的序列化版本 UID 来提高序列化的兼容性，使得即使没有明确指定序列化版本 UID 的类也能够正确地进行序列化和反序列化操作。</p> 
<p><strong>10. JEP 430: 增强的实例操作</strong></p> 
<p>JDK 21 引入了 JEP 430，该功能提供了一些增强的实例操作，使得开发者能够更轻松地对实例进行操作和管理。</p> 
<p>示例代码：</p> 
<pre><code class="language-java">import java.util.Optional;

public class Example {
    public static void main(String[] args) {
        String str = "Hello, world!";

        // 使用 Optional 类的静态方法创建可空对象
        Optional&lt;String&gt; optionalStr = Optional.ofNullable(str);

        // 如果值存在，则对其进行操作
        optionalStr.ifPresent(s -&gt; System.out.println("Length: " + s.length()));

        // 如果值为空，则提供默认值
        String defaultValue = optionalStr.orElse("Default value");
        System.out.println("Value: " + defaultValue);
    }
}</code></pre> 
<p>解释：上面的示例代码展示了如何使用 JDK 21 中增强的实例操作功能，包括使用 Optional 类来对实例进行操作和管理。</p> 
<p><strong>11. JEP 432: 并发随机数生成器</strong></p> 
<p>JDK 21 引入了 JEP 432，该功能提供了一种并发安全的随机数生成器，使得开发者能够更安全地在多线程环境中生成随机数。</p> 
<p>示例代码：</p> 
<pre><code class="language-java">import java.util.concurrent.ThreadLocalRandom;

public class Example {
    public static void main(String[] args) {
        // 生成一个介于 0 和 100 之间的随机数
        int randomNumber = ThreadLocalRandom.current().nextInt(0, 101);
        System.out.println("Random number: " + randomNumber);
    }
}</code></pre> 
<p>解释：上面的示例代码展示了如何使用 JDK 21 中并发安全的随机数生成器来生成随机数，而无需担心多线程环境下的竞态条件。</p> 
<p><strong>12. JEP 434: 本地类型推断增强</strong></p> 
<p>JDK 21 引入了 JEP 434，该功能增强了本地类型推断，使得开发者能够更轻松地在各种情况下使用 var 关键字进行类型推断。</p> 
<p>示例代码：</p> 
<pre><code class="language-java">import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class Example {
    public static void main(String[] args) {
        // 增强的本地类型推断
        var list = new ArrayList&lt;String&gt;();
        list.add("Java");
        list.add("Python");

        // 遍历集合
        for (var item : list) {
            System.out.println(item.toUpperCase());
        }

        // 使用 var 推断 Map 中的键值对类型
        var map = Map.of("a", 1, "b", 2, "c", 3);
        map.forEach((key, value) -&gt; System.out.println(key + ": " + value));
    }
}</code></pre> 
<p>解释：上面的示例代码展示了如何使用 JDK 21 中增强的本地类型推断功能，在不损失可读性的情况下更灵活地使用 var 关键字进行类型推断。</p> 
<p><strong>13. JEP 440: 增强的属性支持</strong></p> 
<p>JDK 21 引入了 JEP 440，该功能增强了 Java 平台的属性支持，使得开发者能够更轻松地操作和管理属性。</p> 
<p>示例代码：</p> 
<pre><code class="language-java">import java.util.Properties;

public class Example {
    public static void main(String[] args) {
        // 创建属性对象
        Properties props = new Properties();

        // 设置属性值
        props.setProperty("database.url", "jdbc:mysql://localhost:3306/mydb");
        props.setProperty("database.user", "root");
        props.setProperty("database.password", "password");

        // 获取属性值
        String url = props.getProperty("database.url");
        String user = props.getProperty("database.user");
        String password = props.getProperty("database.password");

        // 打印属性值
        System.out.println("URL: " + url);
        System.out.println("User: " + user);
        System.out.println("Password: " + password);
    }
}
</code></pre> 
<p>解释：上面的示例代码展示了如何使用 JDK 21 中增强的属性支持功能，通过 Properties 类来操作和管理属性，使得开发者能够更轻松地处理配置信息。</p> 
<p><strong>14. JEP 442: 数据化的 HTTP Client API</strong></p> 
<p>JDK 21 引入了 JEP 442，该功能提供了数据化的 HTTP Client API，使得开发者能够更灵活地操作 HTTP 请求和响应数据。</p> 
<p>示例代码：</p> 
<pre><code class="language-java">import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.util.concurrent.CompletableFuture;

public class Example {
    public static void main(String[] args) {
        HttpClient client = HttpClient.newHttpClient();
        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create("https://api.example.com/data"))
                .GET()
                .build();

        // 发送异步请求
        CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; future = client.sendAsync(request, HttpResponse.BodyHandlers.ofString());

        // 处理异步响应
        future.thenAccept(response -&gt; {
            System.out.println("Response code: " + response.statusCode());
            System.out.println("Response body: " + response.body());
        });

        // 阻塞主线程，等待异步请求完成
        future.join();
    }
}</code></pre> 
<p>解释：上面的示例代码展示了如何使用 JDK 21 中数据化的 HTTP Client API，通过 CompletableFuture 实现异步发送 HTTP 请求，并处理异步响应。</p> 
<p><strong>15. JEP 443: 新的注释 API</strong></p> 
<p>JDK 21 引入了 JEP 443，该功能提供了新的注释 API，使得开发者能够更方便地操作和处理 Java 源代码中的注释信息。</p> 
<p>示例代码：</p> 
<pre><code class="language-java">import java.lang.annotation.*;
import java.lang.reflect.*;

@Retention(RetentionPolicy.RUNTIME)
@interface MyAnnotation {
    String value();
}

public class Example {
    @MyAnnotation("Example annotation")
    public void myMethod() {
        // Method body
    }

    public static void main(String[] args) throws Exception {
        Method method = Example.class.getMethod("myMethod");
        MyAnnotation annotation = method.getAnnotation(MyAnnotation.class);

        if (annotation != null) {
            System.out.println("Annotation value: " + annotation.value());
        } else {
            System.out.println("Annotation not found");
        }
    }
}
</code></pre> 
<p>解释：上面的示例代码展示了如何使用 JDK 21 中新的注释 API，通过反射获取方法上的注解信息并进行处理。</p> 
<p><strong>16. JEP 445: 向量 API（Incubator）</strong></p> 
<p>JDK 21 引入了 JEP 445，该功能为 Java 增加了向量 API，使得开发者能够更高效地进行向量化操作，从而提升代码的性能。</p> 
<p>示例代码：</p> 
<pre><code class="language-java">import jdk.incubator.vector.*;

public class Example {
    public static void main(String[] args) {
        VectorSpecies&lt;Float&gt; species = FloatVector.SPECIES_256;
        float[] a = new float[species.length()];
        float[] b = new float[species.length()];

        // 初始化数组
        for (int i = 0; i &lt; species.length(); i++) {
            a[i] = i;
            b[i] = i * 2;
        }

        // 使用向量化操作进行数组加法
        FloatVector va = FloatVector.fromArray(species, a, 0);
        FloatVector vb = FloatVector.fromArray(species, b, 0);
        FloatVector result = va.add(vb);

        // 将结果写回数组
        result.intoArray(a, 0);

        // 打印结果数组
        for (float f : a) {
            System.out.println(f);
        }
    }
}</code></pre> 
<p>解释：上面的示例代码展示了如何使用 JDK 21 中的向量 API 进行数组加法操作，通过向量化操作实现更高效的计算。</p> 
<p><strong>17. JEP 451: 增强的 Thread API</strong></p> 
<p>JDK 21 引入了 JEP 451，该功能增强了 Thread API，使得开发者能够更方便地管理和操作线程。</p> 
<p>示例代码：</p> 
<pre><code class="language-java">public class Example {
    public static void main(String[] args) {
        // 创建一个新的线程
        Thread thread = new Thread(() -&gt; {
            System.out.println("Thread is running...");
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("Thread finished.");
        });

        // 设置线程名称
        thread.setName("MyThread");

        // 启动线程
        thread.start();

        // 等待线程结束
        try {
            thread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Main thread finished.");
    }
}</code></pre> 
<p>解释：上面的示例代码展示了如何使用 JDK 21 中增强的 Thread API，包括设置线程名称、等待线程结束等操作，使得开发者能够更方便地管理和操作线程。</p> 
<p><strong>18. JEP 457: 改进的 JVM 垃圾收集器</strong></p> 
<p>JDK 21 引入了 JEP 457，该功能改进了 JVM 的垃圾收集器，使得其能够更高效地管理内存，提升应用程序的性能和稳定性。</p> 
<p>示例代码：</p> 
<pre><code class="language-java">public class Example {
    public static void main(String[] args) {
        // 创建大量对象，触发垃圾收集器
        for (int i = 0; i &lt; 1000000; i++) {
            Object obj = new Object();
        }
    }
}</code></pre> 
<p>解释：上面的示例代码展示了如何创建大量对象以触发 JVM 的垃圾收集器，通过 JEP 457 改进的垃圾收集器，可以更高效地管理这些对象，减少内存泄漏和性能问题。</p> 
<p><strong>19. JEP 468: 改进的线程安全性</strong></p> 
<p>JDK 21 引入了 JEP 468，该功能改进了 Java 中的线程安全性，使得开发者能够更安全地在多线程环境中编写并发程序。</p> 
<p>示例代码：</p> 
<pre><code class="language-java">import java.util.concurrent.atomic.AtomicInteger;

public class Example {
    private static AtomicInteger count = new AtomicInteger(0);

    public static void main(String[] args) throws InterruptedException {
        // 创建多个线程对计数器进行操作
        for (int i = 0; i &lt; 10; i++) {
            Thread thread = new Thread(() -&gt; {
                for (int j = 0; j &lt; 1000; j++) {
                    count.incrementAndGet();
                }
            });
            thread.start();
        }

        // 等待所有线程结束
        Thread.sleep(1000);

        // 打印计数器的值
        System.out.println("Count: " + count);
    }
}
</code></pre> 
<p>解释：上面的示例代码展示了如何使用 JDK 21 中的原子操作类 AtomicInteger 来确保在多线程环境中对计数器的安全操作，通过 JEP 468 改进的线程安全性，可以避免出现竞态条件和数据不一致的问题。</p> 
<p><strong>20. JEP 390: 基于Java命令行工具的包管理工具</strong></p> 
<p>JDK 21 引入了 JEP 390，该功能提供了基于 Java 命令行工具的包管理工具，使得开发者能够更方便地管理和使用第三方库。</p> 
<p>示例代码：</p> 
<pre><code class="language-bash"># 在命令行中使用 jpm 安装第三方库
jpm install example-library
</code></pre> 
<p>解释：上面的示例代码展示了如何使用 JDK 21 中的包管理工具 jpm 来安装第三方库，使得开发者能够更方便地在项目中引入外部依赖。</p> 
<p><strong>21. JEP 395: 基于文本的 UI 工具包</strong></p> 
<p>JDK 21 引入了 JEP 395，该功能提供了基于文本的 UI 工具包，使得开发者能够更轻松地创建命令行界面的用户界面。</p> 
<p>示例代码：</p> 
<pre><code class="language-java">import java.io.Console;

public class Example {
    public static void main(String[] args) {
        Console console = System.console();
        if (console != null) {
            console.printf("Enter your name: ");
            String name = console.readLine();
            console.printf("Hello, %s!\n", name);
        } else {
            System.err.println("No console available");
        }
    }
}</code></pre> 
<p>解释：上面的示例代码展示了如何使用 JDK 21 中基于文本的 UI 工具包来创建一个简单的命令行界面，使得开发者能够更方便地与用户进行交互。</p> 
<p><strong>22. JEP 423: 在编译时检查动态生成的代码</strong></p> 
<p>JDK 21 引入了 JEP 423，该功能使得在编译时能够检查动态生成的代码，从而提前发现潜在的错误。</p> 
<p>示例代码：</p> 
<pre><code class="language-java">public class Example {
    public static void main(String[] args) {
        String code = """
                      public class GeneratedClass {
                          public void sayHello() {
                              System.out.println("Hello, world!");
                          }
                      }
                      """;

        // 编译动态生成的代码
        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        int result = compiler.run(null, null, null, code);

        // 如果编译成功，则加载并执行动态生成的类
        if (result == 0) {
            try {
                Class&lt;?&gt; clazz = Class.forName("GeneratedClass");
                Object obj = clazz.getDeclaredConstructor().newInstance();
                clazz.getMethod("sayHello").invoke(obj);
            } catch (Exception e) {
                e.printStackTrace();
            }
        } else {
            System.err.println("Compilation failed");
        }
    }
}
</code></pre> 
<p>解释：上面的示例代码展示了如何使用 JDK 21 中的编译器 API，在运行时动态生成代码并在编译时进行检查，从而提前发现代码中的错误。</p> 
<p><strong>23. JEP 396: 强大的打印和日志工具</strong></p> 
<p>JDK 21 引入了 JEP 396，该功能提供了强大的打印和日志工具，使得开发者能够更方便地输出调试信息和记录日志。</p> 
<p>示例代码：</p> 
<pre><code class="language-java">import java.util.logging.*;

public class Example {
    private static final Logger logger = Logger.getLogger(Example.class.getName());

    public static void main(String[] args) {
        logger.info("This is an informational message");
        logger.warning("This is a warning message");
        logger.severe("This is a severe message");
    }
}
</code></pre> 
<p>解释：上面的示例代码展示了如何使用 JDK 21 中强大的日志工具，通过 Logger 类来输出不同级别的日志信息，使得开发者能够更方便地进行调试和日志记录。</p> 
<p><strong>24. JEP 397: Unix 套接字通道</strong></p> 
<p>JDK 21 引入了 JEP 397，该功能提供了 Unix 套接字通道，使得 Java 应用程序能够更轻松地与本地系统进行通信。</p> 
<p>示例代码：</p> 
<pre><code class="language-java">import java.io.*;
import java.net.*;
import java.nio.file.*;

public class Example {
    public static void main(String[] args) throws IOException {
        // 创建 Unix 套接字通道
        Path socketFile = Paths.get("/tmp/mysocket");
        UnixDomainSocketAddress address = UnixDomainSocketAddress.of(socketFile);
        try (UnixDomainSocketChannel channel = UnixDomainSocketChannel.open(address)) {
            // 发送数据
            String message = "Hello, Unix socket!";
            channel.write(ByteBuffer.wrap(message.getBytes()));

            // 读取响应
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            int bytesRead = channel.read(buffer);
            buffer.flip();
            byte[] responseBytes = new byte[bytesRead];
            buffer.get(responseBytes);
            String response = new String(responseBytes);
            System.out.println("Response: " + response);
        }
    }
}
</code></pre> 
<p>解释：上面的示例代码展示了如何使用 JDK 21 中的 Unix 套接字通道来进行进程间通信，这使得 Java 应用程序能够更加灵活地与本地系统进行交互。</p> 
<p><strong>25. JEP 398: 统一垃圾收集策略</strong></p> 
<p>JDK 21 引入了 JEP 398，该功能提供了统一的垃圾收集策略，使得开发者能够更方便地配置和管理垃圾收集器。</p> 
<p>示例代码：</p> 
<pre><code class="language-java"># 启动 Java 应用程序时通过参数配置统一的垃圾收集策略
java -XX:+UseZGC -jar myapp.jar
</code></pre> 
<p>解释：上面的示例代码展示了如何使用 JDK 21 中的统一垃圾收集策略，在启动 Java 应用程序时通过参数来选择合适的垃圾收集器，从而优化应用程序的性能和内存管理。</p> 
<p><strong>26. JEP 400: JDK生态系统更新</strong></p> 
<p>JDK 21 引入了 JEP 400，该功能提供了 JDK 生态系统的更新机制，使得开发者能够更方便地获取和应用 JDK 生态系统的更新。</p> 
<p>示例代码：</p> 
<pre><code class="language-java"># 使用 jpackage 工具打包 Java 应用程序并包含 JDK 生态系统的更新
jpackage --type app-image --name MyApp --input target/classes --main-jar myapp.jar --main-class com.example.MyApp --runtime-image /path/to/jdk21 --app-version 1.0</code></pre> 
<p>解释：上面的示例代码展示了如何使用 JDK 21 中的 jpackage 工具打包 Java 应用程序，并在打包过程中包含 JDK 生态系统的更新，从而使得应用程序能够直接获取更新的 JDK 生态系统。</p> 
<p><strong>27. JEP 401: 基于容器的发布</strong></p> 
<p>JDK 21 引入了 JEP 401，该功能提供了基于容器的发布机制，使得开发者能够更方便地将 Java 应用程序打包成容器镜像并进行部署。</p> 
<p>示例代码：</p> 
<pre><code class="language-java"># 使用 jlink 工具创建轻量级的运行时镜像
jlink --output my-runtime-image --add-modules java.base,java.logging,java.xml

# 使用 jpackage 工具打包 Java 应用程序并包含运行时镜像
jpackage --type image --name MyApp --input target/classes --main-jar myapp.jar --main-class com.example.MyApp --runtime-image my-runtime-image --app-version 1.0

# 构建容器镜像
docker build -t myapp .

# 运行容器
docker run -it --rm myapp</code></pre> 
<p>解释：上面的示例代码展示了如何使用 JDK 21 中的 jlink 和 jpackage 工具创建轻量级的运行时镜像，并将 Java 应用程序打包成容器镜像进行部署。</p> 
<p><strong>28. JEP 404: ZGC on macOS</strong></p> 
<p>JDK 21 引入了 JEP 404，该功能为 macOS 系统提供了 Z Garbage Collector（ZGC），使得开发者能够在 macOS 平台上使用低延迟的垃圾收集器。</p> 
<p>示例代码：</p> 
<pre><code class="language-java"># 启用 ZGC 垃圾收集器运行 Java 应用程序
java -XX:+UseZGC -jar myapp.jar
</code></pre> 
<p>解释：上面的示例代码展示了如何在 macOS 系统上启用 ZGC 垃圾收集器来运行 Java 应用程序，从而实现低延迟和高吞吐量的垃圾收集。</p> 
<p><strong>29. JEP 407: 提高 Java 安全性</strong></p> 
<p>JDK 21 引入了 JEP 407，该功能提高了 Java 的安全性，包括修复了一些安全漏洞和弱点，并增强了安全特性。</p> 
<p>示例代码：</p> 
<pre><code class="language-java">public class Example {
    public static void main(String[] args) {
        // 安全地处理用户输入
        String userInput = args[0];
        String sanitizedInput = sanitize(userInput);
        // 继续处理经过安全处理的用户输入
    }

    private static String sanitize(String input) {
        // 进行输入验证和过滤，确保不包含恶意代码
        // 返回经过安全处理的输入
        return input.replaceAll("&lt;", "").replaceAll("&gt;", "");
    }
}</code></pre> 
<p>解释：上面的示例代码展示了如何在 Java 应用程序中安全地处理用户输入，通过输入验证和过滤来防止恶意代码的注入，提高应用程序的安全性。</p> 
<p><strong>30. JEP 409: 应用程序类数据共享</strong></p> 
<p>JDK 21 引入了 JEP 409，该功能提供了应用程序类数据共享（AppCDS），使得多个 Java 应用程序能够共享同一份类数据，减少内存占用和启动时间。</p> 
<p>示例代码：</p> 
<pre><code class="language-java"># 使用 jlink 工具创建包含应用程序类数据共享的运行时镜像
jlink --output my-runtime-image --add-modules java.base,java.logging,java.xml --class-for-name com.example.MyClass

# 使用 jpackage 工具打包 Java 应用程序并包含运行时镜像
jpackage --type image --name MyApp --input target/classes --main-jar myapp.jar --main-class com.example.MyApp --runtime-image my-runtime-image --app-version 1.0
</code></pre> 
<p>解释：上面的示例代码展示了如何使用 JDK 21 中的 jlink 工具创建包含应用程序类数据共享的运行时镜像，并使用 jpackage 工具打包 Java 应用程序，从而实现多个应用程序共享同一份类数据，减少内存占用和启动时间。</p> 
<p><strong>31. JEP 412: 在 Windows 平台上启用 AOT 编译</strong></p> 
<p>JDK 21 引入了 JEP 412，该功能在 Windows 平台上启用了 AOT（Ahead-of-Time）编译器，使得开发者能够将 Java 应用程序编译成本地机器代码，提高应用程序的性能。</p> 
<p>示例代码：</p> 
<pre><code class="language-java"># 使用 jaotc 工具将 Java 应用程序编译成本地机器代码
jaotc --output myapp.dll --module mymodule
</code></pre> 
<p>解释：上面的示例代码展示了如何使用 JDK 21 中的 jaotc 工具将 Java 应用程序编译成本地机器代码，从而提高应用程序的性能。</p> 
<p><strong>32. JEP 414: 向量API v2.0（Incubator）</strong></p> 
<p>JDK 21 引入了 JEP 414，该功能为向量API提供了第二个版本，包括更多的操作和改进，使得开发者能够更高效地利用硬件向量化指令。</p> 
<p>示例代码：</p> 
<pre><code class="language-java">import jdk.incubator.vector.*;

public class Example {
    public static void main(String[] args) {
        VectorSpecies&lt;Float&gt; species = FloatVector.SPECIES_256;
        float[] a = new float[species.length()];
        float[] b = new float[species.length()];

        // 初始化数组
        for (int i = 0; i &lt; species.length(); i++) {
            a[i] = i;
            b[i] = i * 2;
        }

        // 使用向量化操作进行数组加法
        FloatVector va = FloatVector.fromArray(species, a, 0);
        FloatVector vb = FloatVector.fromArray(species, b, 0);
        FloatVector result = va.add(vb);

        // 将结果写回数组
        result.intoArray(a, 0);

        // 打印结果数组
        for (float f : a) {
            System.out.println(f);
        }
    }
}</code></pre> 
<p>解释：上面的示例代码展示了如何使用 JDK 21 中的向量API v2.0进行数组加法操作，通过向量化操作实现更高效的计算。</p> 
<p><strong>33. JEP 416: 改进的 AArch64 程序计数器模型</strong></p> 
<p>JDK 21 引入了 JEP 416，该功能提供了改进的 AArch64（ARM 64位架构）程序计数器模型，使得在 ARM 64位架构上的 Java 应用程序能够更好地执行和调试。</p> 
<p>示例代码：</p> 
<pre><code class="language-java"># 编译和运行 Java 应用程序
javac MyApp.java
java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly MyApp
</code></pre> 
<p>解释：上面的示例代码展示了如何使用 JDK 21 在 ARM 64位架构上编译和运行 Java 应用程序，并使用诊断选项和打印汇编输出来调试程序执行情况。</p> 
<p><strong>34. JEP 419: Unix 套接字通道 API v2</strong></p> 
<p>JDK 21 引入了 JEP 419，该功能提供了 Unix 套接字通道 API 的第二个版本，包括更多的操作和改进，使得开发者能够更灵活地在 Unix 系统上进行进程间通信。</p> 
<p>示例代码：</p> 
<pre><code class="language-java">import java.io.IOException;
import java.net.SocketAddress;
import java.nio.channels.*;

public class Example {
    public static void main(String[] args) throws IOException {
        try (UnixDomainSocketChannel channel = UnixDomainSocketChannel.open()) {
            // 连接到指定的 Unix 套接字地址
            SocketAddress address = UnixDomainSocketAddress.of("/tmp/mysocket");
            channel.connect(address);

            // 发送数据
            channel.write(ByteBuffer.wrap("Hello, Unix socket!".getBytes()));

            // 读取响应
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            int bytesRead = channel.read(buffer);
            buffer.flip();
            byte[] responseBytes = new byte[bytesRead];
            buffer.get(responseBytes);
            String response = new String(responseBytes);
            System.out.println("Response: " + response);
        }
    }
}</code></pre> 
<p>解释：上面的示例代码展示了如何使用 JDK 21 中的 Unix 套接字通道 API v2 进行进程间通信，包括连接到指定的 Unix 套接字地址、发送数据和读取响应等操作。</p> 
<p><strong>35. JEP 420: 简化的泛型参数名称</strong></p> 
<p>JDK 21 引入了 JEP 420，该功能简化了泛型参数的命名规范，使得开发者能够更清晰地理解泛型类型和方法的含义。</p> 
<p>示例代码：</p> 
<pre><code class="language-java">import java.util.List;

public class Example {
    public static void main(String[] args) {
        // 使用简化的泛型参数名称
        List&lt;String&gt; list = List.of("apple", "banana", "orange");
        String first = list.get(0);
        System.out.println("First element: " + first);
    }
}</code></pre> 
<p>解释：上面的示例代码展示了如何使用 JDK 21 中的简化泛型参数名称特性，使得开发者能够更清晰地阅读和理解泛型类型和方法的含义。</p> 
<p>好了，以上是 V 哥在学习 JDK21的过程中总结的35个新特性，有了这些新特性的加持，对 Java 开发的应用在安全、稳定、简化复杂代码、构建和部署、可靠性、并发、模块化等方面，有了更好的支持。兄弟们，收藏起来慢慢学习，最后，V 哥想说一句，整理不易，如果这篇内容对你有帮助，也希望可以分享给更多学习 Java 的小伙伴，你还知道 JDK21有哪些新特性吗，V 哥欢迎留言分享给我，在此先谢过！</p> 
<p>感受有趣的灵魂讲解Java，不一样的学习体验：2024趣味Java</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a36e78fa92d5a614232dc781b86611bc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java: 无法访问jakarta.servlet.ServletException</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b0f9dc26f8c6e422dee742a6edc8ed2d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java：List中常见的方法和五种遍历方式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>