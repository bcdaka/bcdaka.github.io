<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>今日推荐库：@microsoft/fetch-event-source 前端发送SSE请求实现GPT流式输出 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/a9e1a115edc8b342993d812f9094d0ef/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="今日推荐库：@microsoft/fetch-event-source 前端发送SSE请求实现GPT流式输出">
  <meta property="og:description" content="使用 @microsoft/fetch-event-source 改善服务器发送事件的请求@microsoft/fetch-event-source - npm 在前端开发中，处理服务器发送事件（server-sent events）时，我们通常使用浏览器提供的 EventSource API。然而，该默认 API 存在一些限制，本文介绍了一个名为 @microsoft/fetch-event-source 的包，它提供了更强大的 API，使我们能够更灵活地进行服务器发送事件的请求。
问题与限制 默认的浏览器 EventSource API 在以下方面存在一些限制：
无法传递请求体（request body），必须将执行请求所需的所有信息编码到 URL 中，而大多数浏览器对 URL 的长度限制为 2000 个字符。无法传递自定义请求头。只能进行 GET 请求，无法指定其他方法。如果连接中断，无法控制重试策略，浏览器会自动进行几次尝试然后停止。 @microsoft/fetch-event-source 的优势 @microsoft/fetch-event-source 提供了一个基于 Fetch API 的替代接口，完全兼容 Event Stream 格式。这使得我们能够以更加灵活的方式进行服务器发送事件的消费。以下是该库的一些主要优势：
支持任何请求方法、请求头和请求体，以及 Fetch API 提供的其他功能。甚至可以提供替代的 fetch() 实现，以应对默认浏览器实现无法满足需求的情况。提供对响应对象的访问权限，允许在解析事件源之前进行自定义验证/处理。这在存在 API 网关（如 nginx）的情况下非常有用，如果网关返回错误，我们可能希望正确处理它。对连接中断或发生错误时，提供完全控制的重试策略。 此外，该库还集成了浏览器的 Page Visibility API，使得在文档被隐藏时（例如用户最小化窗口），连接会关闭，当文档再次可见时会自动使用上次事件 ID 进行重试。这有助于减轻服务器负担，避免不必要的开放连接（但如果需要，可以选择禁用此行为）。
安装 npm install @microsoft/fetch-event-source
使用示例 在使用 @microsoft/fetch-event-source 之前，我们通常使用以下方式处理服务器发送事件：
const sse = new EventSource(&#39;/api/sse&#39;); sse.onmessage = (ev) =&gt; { console.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-07T16:46:59+08:00">
    <meta property="article:modified_time" content="2024-03-07T16:46:59+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">今日推荐库：@microsoft/fetch-event-source 前端发送SSE请求实现GPT流式输出</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>使用 @microsoft/fetch-event-source 改善服务器发送事件的请求<a href="https://www.npmjs.com/package/@microsoft/fetch-event-source" rel="nofollow" title="@microsoft/fetch-event-source - npm">@microsoft/fetch-event-source - npm</a></h2> 
<p>在前端开发中，处理服务器发送事件（server-sent events）时，我们通常使用浏览器提供的 EventSource API。然而，该默认 API 存在一些限制，本文介绍了一个名为 <code>@microsoft/fetch-event-source</code> 的包，它提供了更强大的 API，使我们能够更灵活地进行服务器发送事件的请求。</p> 
<h3>问题与限制</h3> 
<p>默认的浏览器 EventSource API 在以下方面存在一些限制：</p> 
<ol><li>无法传递请求体（request body），必须将执行请求所需的所有信息编码到 URL 中，而大多数浏览器对 URL 的长度限制为 2000 个字符。</li><li>无法传递自定义请求头。</li><li>只能进行 GET 请求，无法指定其他方法。</li><li>如果连接中断，无法控制重试策略，浏览器会自动进行几次尝试然后停止。</li></ol> 
<h3>@microsoft/fetch-event-source 的优势</h3> 
<p><code>@microsoft/fetch-event-source</code> 提供了一个基于 Fetch API 的替代接口，完全兼容 Event Stream 格式。这使得我们能够以更加灵活的方式进行服务器发送事件的消费。以下是该库的一些主要优势：</p> 
<ol><li>支持任何请求方法、请求头和请求体，以及 Fetch API 提供的其他功能。甚至可以提供替代的 fetch() 实现，以应对默认浏览器实现无法满足需求的情况。</li><li>提供对响应对象的访问权限，允许在解析事件源之前进行自定义验证/处理。这在存在 API 网关（如 nginx）的情况下非常有用，如果网关返回错误，我们可能希望正确处理它。</li><li>对连接中断或发生错误时，提供完全控制的重试策略。</li></ol> 
<p>此外，该库还集成了浏览器的 Page Visibility API，使得在文档被隐藏时（例如用户最小化窗口），连接会关闭，当文档再次可见时会自动使用上次事件 ID 进行重试。这有助于减轻服务器负担，避免不必要的开放连接（但如果需要，可以选择禁用此行为）。</p> 
<h3>安装</h3> 
<blockquote> 
 <p><code>npm install @microsoft/fetch-event-source</code></p> 
</blockquote> 
<h3>使用示例</h3> 
<p>在使用 <code>@microsoft/fetch-event-source</code> 之前，我们通常使用以下方式处理服务器发送事件：</p> 
<pre><code class="language-javascript">const sse = new EventSource('/api/sse');

sse.onmessage = (ev) =&gt; { console.log(ev.data); };</code></pre> 
<p>现在，我们可以改为使用 <code>@microsoft/fetch-event-source</code>：</p> 
<pre><code class="language-javascript">import { fetchEventSource } from '@microsoft/fetch-event-source';  
await fetchEventSource('/api/sse', { 
    onmessage(ev) { 
        console.log(ev.data);
     } 
});</code></pre> 
<p>可以通过传递所有其他由默认 fetch API 暴露的参数，进行更灵活的请求，例如：</p> 
<pre><code class="language-javascript">const ctrl = new AbortController(); //用于中断请求

fetchEventSource('/api/sse', {

    method: 'POST',

    openWhenHidden: true, //页面退至后台保持连接

    headers: { 'Content-Type': 'application/json', },

    body: JSON.stringify({ foo: 'bar' }),

    signal: ctrl.signal
 });</code></pre> 
<p></p> 
<p>通过使用 <code>@microsoft/fetch-event-source</code>，我们能够更灵活地处理服务器发送事件请求，并充分发挥 Fetch API 的功能。希望这篇博客能够对你理解和使用该库提供一些帮助。</p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d1b11b8bca1f7d2af368a83b1b4c4bff/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">AI 绘画平台难开发，难变现？试试 Stable Diffusion API Serverless 版解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5134dcc91482fb2e889c707b80f23b60/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用ENSP模拟器配置华为防火墙的WEB登录页面 ---＞＞ 保姆级教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>