<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SQL Server中的CTE和临时表优化 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/f99dfc8a85e8007e1c3aecdc54df4160/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="SQL Server中的CTE和临时表优化">
  <meta property="og:description" content="在SQL Server中，优化查询性能是数据库管理的核心任务之一。使用公用表表达式（CTE）和临时表是两种重要的技术手段。本文将深入探讨CTE如何简化代码，以及临时表如何优化查询性能。通过实例和详尽解释，我们将展示这两种技术在实际应用中的优点和注意事项。
第一部分：公用表表达式（CTE） 公用表表达式（CTE）是SQL Server 2005引入的一项功能。CTE通过将复杂查询分解成多个可读性高的部分，使代码更加简洁明了。CTE主要有两种类型：递归CTE和非递归CTE。
1.1 非递归CTE 非递归CTE主要用于简化查询，提高代码可读性。以下是一个典型的非递归CTE示例：
WITH SalesCTE AS ( SELECT SalesPersonID, SUM(TotalDue) AS TotalSales FROM Sales.SalesOrderHeader GROUP BY SalesPersonID ) SELECT sp.FirstName, sp.LastName, sc.TotalSales FROM SalesCTE sc JOIN Sales.SalesPerson sp ON sc.SalesPersonID = sp.SalesPersonID; 在这个示例中，我们使用CTE将总销售额的计算与人员信息的查询分开，从而提高了代码的清晰度。
1.2 递归CTE 递归CTE用于处理层次结构数据，如组织结构或目录树。以下是一个递归CTE示例：
WITH OrgCTE AS ( SELECT EmployeeID, ManagerID, Title FROM HumanResources.Employee WHERE ManagerID IS NULL UNION ALL SELECT e.EmployeeID, e.ManagerID, e.Title FROM HumanResources.Employee e INNER JOIN OrgCTE o ON e.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-09T18:59:24+08:00">
    <meta property="article:modified_time" content="2024-06-09T18:59:24+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SQL Server中的CTE和临时表优化</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在SQL Server中，优化查询性能是数据库管理的核心任务之一。使用公用表表达式（CTE）和临时表是两种重要的技术手段。本文将深入探讨CTE如何简化代码，以及临时表如何优化查询性能。通过实例和详尽解释，我们将展示这两种技术在实际应用中的优点和注意事项。</p> 
<h4>第一部分：公用表表达式（CTE）</h4> 
<p>公用表表达式（CTE）是SQL Server 2005引入的一项功能。CTE通过将复杂查询分解成多个可读性高的部分，使代码更加简洁明了。CTE主要有两种类型：递归CTE和非递归CTE。</p> 
<h5>1.1 非递归CTE</h5> 
<p>非递归CTE主要用于简化查询，提高代码可读性。以下是一个典型的非递归CTE示例：</p> 
<pre><code class="language-sql">WITH SalesCTE AS (
    SELECT 
        SalesPersonID,
        SUM(TotalDue) AS TotalSales
    FROM 
        Sales.SalesOrderHeader
    GROUP BY 
        SalesPersonID
)
SELECT 
    sp.FirstName, 
    sp.LastName, 
    sc.TotalSales
FROM 
    SalesCTE sc
JOIN 
    Sales.SalesPerson sp
ON 
    sc.SalesPersonID = sp.SalesPersonID;
</code></pre> 
<p>在这个示例中，我们使用CTE将总销售额的计算与人员信息的查询分开，从而提高了代码的清晰度。</p> 
<h5>1.2 递归CTE</h5> 
<p>递归CTE用于处理层次结构数据，如组织结构或目录树。以下是一个递归CTE示例：</p> 
<pre><code class="language-sql">WITH OrgCTE AS (
    SELECT 
        EmployeeID, 
        ManagerID, 
        Title
    FROM 
        HumanResources.Employee
    WHERE 
        ManagerID IS NULL
    UNION ALL
    SELECT 
        e.EmployeeID, 
        e.ManagerID, 
        e.Title
    FROM 
        HumanResources.Employee e
    INNER JOIN 
        OrgCTE o
    ON 
        e.ManagerID = o.EmployeeID
)
SELECT 
    EmployeeID, 
    ManagerID, 
    Title
FROM 
    OrgCTE;
</code></pre> 
<p>这个示例展示了如何使用递归CTE来获取一个组织结构中的所有员工信息，包括他们的管理层级。</p> 
<h4>第二部分：临时表优化查询性能</h4> 
<p>临时表在SQL Server中扮演着重要角色，特别是在处理复杂查询时。临时表允许我们将中间结果存储在一个临时的存储结构中，从而优化查询性能。</p> 
<h5>2.1 临时表的创建</h5> 
<p>临时表分为局部临时表和全局临时表。局部临时表以单个会话为作用范围，而全局临时表则可以在多个会话间共享。以下是创建局部临时表的示例：</p> 
<pre><code class="language-sql">CREATE TABLE #TempSales (
    SalesPersonID INT,
    TotalSales MONEY
);

INSERT INTO #TempSales (SalesPersonID, TotalSales)
SELECT 
    SalesPersonID, 
    SUM(TotalDue) AS TotalSales
FROM 
    Sales.SalesOrderHeader
GROUP BY 
    SalesPersonID;
</code></pre> 
<h5>2.2 临时表的应用场景</h5> 
<p>临时表在以下几种场景中尤为有用：</p> 
<ol><li><strong>复杂的多步查询</strong>：将查询分解为多个步骤，每个步骤的结果存储在临时表中，可以提高整体查询效率。</li><li><strong>大数据量的处理中间结果存储</strong>：在处理大数据量时，临时表可以避免重复计算，从而显著提高性能。</li><li><strong>索引和统计信息的应用</strong>：临时表允许我们创建索引，从而优化查询性能。</li></ol> 
<p>以下是一个结合临时表和索引的示例：</p> 
<pre><code class="language-sql">CREATE TABLE #TempSales (
    SalesPersonID INT,
    TotalSales MONEY
);

INSERT INTO #TempSales (SalesPersonID, TotalSales)
SELECT 
    SalesPersonID, 
    SUM(TotalDue) AS TotalSales
FROM 
    Sales.SalesOrderHeader
GROUP BY 
    SalesPersonID;

CREATE INDEX IX_TempSales_SalesPersonID ON #TempSales(SalesPersonID);

SELECT 
    sp.FirstName, 
    sp.LastName, 
    ts.TotalSales
FROM 
    #TempSales ts
JOIN 
    Sales.SalesPerson sp
ON 
    ts.SalesPersonID = sp.SalesPersonID;
</code></pre> 
<p>在这个示例中，我们首先创建了一个临时表，并将中间结果存储在其中。接着，我们为临时表创建了一个索引，从而优化了后续的查询性能。</p> 
<h4>第三部分：CTE与临时表的比较与选择</h4> 
<p>在使用CTE和临时表时，我们需要根据具体情况选择最优方案。以下是CTE和临时表的优缺点比较：</p> 
<h5>3.1 CTE的优点</h5> 
<ul><li><strong>代码简洁</strong>：CTE使得复杂查询更加易读和维护。</li><li><strong>临时作用域</strong>：CTE仅在当前查询中有效，不会影响其他查询。</li></ul> 
<h5>3.2 CTE的缺点</h5> 
<ul><li><strong>性能限制</strong>：对于大数据量的处理中，CTE可能会导致性能问题，因为CTE不会自动创建索引。</li><li><strong>复杂查询受限</strong>：在多步骤复杂查询中，CTE的灵活性较低。</li></ul> 
<h5>3.3 临时表的优点</h5> 
<ul><li><strong>性能优化</strong>：临时表可以通过创建索引和统计信息显著提高查询性能。</li><li><strong>灵活性高</strong>：在多步骤复杂查询中，临时表提供了更多的操作空间和灵活性。</li></ul> 
<h5>3.4 临时表的缺点</h5> 
<ul><li><strong>代码复杂度</strong>：与CTE相比，临时表的代码更加复杂，需要显式创建和删除。</li><li><strong>资源占用</strong>：临时表会占用临时数据库资源，可能导致系统负载增加。</li></ul> 
<h4>第四部分：实例与实践</h4> 
<p>通过实际案例，我们可以更好地理解CTE和临时表的应用场景和性能表现。以下是一个实际案例，展示如何使用CTE和临时表来优化查询。</p> 
<h5>4.1 实例背景</h5> 
<p>假设我们有一个在线销售系统，需要定期生成销售报告。这个报告包括每个销售人员的总销售额、销售订单数量以及客户信息。</p> 
<h5>4.2 使用CTE的实现</h5> 
<p>首先，我们使用CTE来实现这个查询：</p> 
<pre><code class="language-sql">WITH SalesData AS (
    SELECT 
        SalesPersonID,
        COUNT(SalesOrderID) AS OrderCount,
        SUM(TotalDue) AS TotalSales
    FROM 
        Sales.SalesOrderHeader
    GROUP BY 
        SalesPersonID
),
CustomerData AS (
    SELECT 
        c.CustomerID, 
        c.FirstName, 
        c.LastName, 
        s.SalesPersonID
    FROM 
        Sales.Customer c
    JOIN 
        Sales.SalesOrderHeader s
    ON 
        c.CustomerID = s.CustomerID
)
SELECT 
    sd.SalesPersonID, 
    sd.OrderCount, 
    sd.TotalSales, 
    cd.FirstName, 
    cd.LastName
FROM 
    SalesData sd
JOIN 
    CustomerData cd
ON 
    sd.SalesPersonID = cd.SalesPersonID;
</code></pre> 
<p>这个查询使用了两个CTE，将销售数据和客户数据分开处理，最后在主查询中合并结果。</p> 
<h5>4.3 使用临时表的实现</h5> 
<p>接下来，我们使用临时表来实现相同的查询：</p> 
<pre><code class="language-sql">CREATE TABLE #SalesData (
    SalesPersonID INT,
    OrderCount INT,
    TotalSales MONEY
);

INSERT INTO #SalesData (SalesPersonID, OrderCount, TotalSales)
SELECT 
    SalesPersonID, 
    COUNT(SalesOrderID) AS OrderCount,
    SUM(TotalDue) AS TotalSales
FROM 
    Sales.SalesOrderHeader
GROUP BY 
    SalesPersonID;

CREATE TABLE #CustomerData (
    CustomerID INT,
    FirstName NVARCHAR(50),
    LastName NVARCHAR(50),
    SalesPersonID INT
);

INSERT INTO #CustomerData (CustomerID, FirstName, LastName, SalesPersonID)
SELECT 
    c.CustomerID, 
    c.FirstName, 
    c.LastName, 
    s.SalesPersonID
FROM 
    Sales.Customer c
JOIN 
    Sales.SalesOrderHeader s
ON 
    c.CustomerID = s.CustomerID;

SELECT 
    sd.SalesPersonID, 
    sd.OrderCount, 
    sd.TotalSales, 
    cd.FirstName, 
    cd.LastName
FROM 
    #SalesData sd
JOIN 
    #CustomerData cd
ON 
    sd.SalesPersonID = cd.SalesPersonID;

DROP TABLE #SalesData;
DROP TABLE #CustomerData;
</code></pre> 
<p>使用临时表，我们将中间结果存储在两个临时表中，并在最终查询中合并结果。最后，我们删除临时表以释放资源。</p> 
<h4>第五部分：总结</h4> 
<p>CTE和临时表在SQL Server中的应用各有优劣。CTE简化代码，提高可读性，适合较简单的查询和层次结构数据处理。而临时表则提供更高的灵活性和性能优化手段，适用于复杂的多步骤查询和大数据量处理。在实际应用中，我们需要根据具体需求选择最合适的技术手段，以达到最佳的性能和可维护性。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f0e2ad98ef1de55b761cf165fa1d5bf8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">结构体＜C语言＞</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/60bc46b66395cdf14700c8914ab48e9d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【wiki知识库】06.文档管理页面的添加--前端Vue部分</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>