<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>华为OD机试 - 矩阵匹配（Java &amp; JS &amp; Python &amp; C &amp; C&#43;&#43;） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/25510b71273b9c4a20468710563a19c0/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="华为OD机试 - 矩阵匹配（Java & JS & Python & C & C&#43;&#43;）">
  <meta property="og:description" content="题目描述 从一个 N * M（N ≤ M）的矩阵中选出 N 个数，任意两个数字不能在同一行或同一列，求选出来的 N 个数中第 K 大的数字的最小值是多少。
输入描述 输入矩阵要求：1 ≤ K ≤ N ≤ M ≤ 150
输入格式：
N M K
N*M矩阵
输出描述 N*M 的矩阵中可以选出 M! / N! 种组合数组，每个组合数组种第 K 大的数中的最小值。无需考虑重复数字，直接取字典排序结果即可。
备注 注意：结果是第 K 大的数字的最小值
用例 输入3 4 2
1 5 6 6
8 3 4 3
6 8 6 3输出3说明 N*M的矩阵中可以选出 M！/ N！种组合数组，每个组合数组种第 K 大的数中的最小值；
上述输入中选出数组组合为：
1,3,6;
1,3,3;
1,4,8;
1,4,3;
......
上述输入样例中选出的组合数组有24种，最小数组为1,3,3，则第2大的最小值为3">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-09T23:41:10+08:00">
    <meta property="article:modified_time" content="2024-03-09T23:41:10+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">华为OD机试 - 矩阵匹配（Java &amp; JS &amp; Python &amp; C &amp; C&#43;&#43;）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 id="main-toc">题目描述</h4> 
<p>从一个 N * M（N ≤ M）的矩阵中选出 N 个数，任意两个数字不能在同一行或同一列，求选出来的 N 个数中第 K 大的数字的最小值是多少。</p> 
<p></p> 
<h4 id="%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0">输入描述</h4> 
<p>输入矩阵要求：1 ≤ K ≤ N ≤ M ≤ 150</p> 
<p>输入格式：</p> 
<blockquote> 
 <p>N M K</p> 
 <p>N*M矩阵</p> 
</blockquote> 
<p></p> 
<h4 id="%E8%BE%93%E5%87%BA%E6%8F%8F%E8%BF%B0">输出描述</h4> 
<p>N*M 的矩阵中可以选出 M! / N! 种组合数组，每个组合数组种第 K 大的数中的最小值。无需考虑重复数字，直接取字典排序结果即可。</p> 
<p></p> 
<h4>备注</h4> 
<p>注意：结果是第 K 大的数字的最小值</p> 
<p></p> 
<h4 id="%E7%94%A8%E4%BE%8B">用例</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:86px;">输入</td><td style="width:412px;">3 4 2<br> 1 5 6 6<br> 8 3 4 3<br> 6 8 6 3</td></tr><tr><td style="width:86px;">输出</td><td style="width:412px;">3</td></tr><tr><td style="width:86px;">说明</td><td style="width:412px;"> <p>N*M的矩阵中可以选出 M！/ N！种组合数组，每个组合数组种第 K 大的数中的最小值；</p> <p>上述输入中选出数组组合为：</p> <p>1,3,6;</p> <p>1,3,3;</p> <p>1,4,8;</p> <p>1,4,3;</p> <p>......</p> <p>上述输入样例中选出的组合数组有24种，最小数组为1,3,3，则第2大的最小值为3</p> </td></tr></tbody></table> 
<p></p> 
<h4 id="%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90">题目解析</h4> 
<p>本题需要我们从矩阵中选取N个元素，这个N元素的特点是：任意两个不能同行同列。</p> 
<p>而满足上面条件的N个元素存在多组，我们需要找到着各个组中第K大元素的最小值。</p> 
<p></p> 
<blockquote> 
 <p>难点一：如何从矩阵中找到N个互相不同行同列的元素呢？</p> 
</blockquote> 
<p>暴力枚举的话，肯定会超时，因此需要寻找更优解法。</p> 
<p>根据要求，每行每列只能有一个元素被选择，即可以认为每个行号只能和一个列号进行配对，且配对过的列号不能再和其他行号配对，而形成了配对关系的行号，列号，其实就是一个元素的坐标位置。</p> 
<p>因此，找N个互相不同行同列的元素，其实就是在二分图（所有行号一部分，所有列号一部分）找N个边的匹配。</p> 
<p>如下图所示</p> 
<p><img alt="" height="406" src="https://images2.imgbox.com/9c/7d/9PqrhAuB_o.png" width="703"></p> 
<p>关于二分图的知识可以看下：</p> 
<p><a href="https://fcqian.blog.csdn.net/article/details/135420801" rel="nofollow" title="HDU - 2063 过山车（Java &amp; JS &amp; Python &amp; C）-CSDN博客">HDU - 2063 过山车（Java &amp; JS &amp; Python &amp; C）-CSDN博客</a></p> 
<p></p> 
<p>看完上面博客后，我们就可以继续后面说明了。</p> 
<p>现在我们已经有了二分图了，也就可以找到具有N个边的"匹配"，但是这种"匹配"可能非常多，难道要全部找出来，然后对比每个"匹配"中第K大，那不还是暴力吗？</p> 
<p></p> 
<p>题目需要我们多组N个元素中的第K大元素的最小取值，</p> 
<p>换位思考一下，假设我们已经知道了第K大的最小取值是kth，那么：</p> 
<ul><li>检查矩阵中是否至多找到（N - K + 1 个） ≤ kth 的元素值，且这些元素值互不同行同列</li></ul> 
<blockquote> 
 <p>N个数中，有K-1个数比kth大，那么相对应的有 (N - (K-1)) = (N - K + 1 ) 个数 ≤ kth。</p> 
 <p>即找的 N - K + 1 个数中包含了 kth（第K大值）本身。</p> 
</blockquote> 
<p></p> 
<p></p> 
<p>而kth的大小和二分图最大匹配是正相关的，因为：</p> 
<blockquote> 
 <p>每个匹配边 其实就是 行号到列号的配对连线</p> 
</blockquote> 
<blockquote> 
 <p>而行号和列号的组合其实就是坐标位置，根据坐标位置可以得到一个矩阵元素值</p> 
</blockquote> 
<p>因此kth越小，意味着可以找到的 ≤ kth 的矩阵元素越少，相反的，kth 越大，则找到的 ≤ kth 的矩阵元素越多。</p> 
<p></p> 
<p>因此kth值大小和二分图最大匹配数是线性关系，我们可以使用二分法，来枚举kth。</p> 
<p></p> 
<p>二分枚举的范围是：1 ~ 矩阵元素最大值，这里不用担心二分枚举到kth不是矩阵元素，因为这种情况会被过滤掉，原因是：我们要找 N - K + 1 个 &lt;= kth 的矩阵元素，最后把关的必然是 kth 本身，即我们必然要在矩阵中找到一个 kth 值，如果二分枚举到的 kth 不是矩阵元素，则无法满足这个要求。</p> 
<p></p> 
<p>二分枚举到一个kth值：</p> 
<ul><li>如果kth使得二分图最大匹配 &gt;= N-K+1 个，则说明当前kth取大了，我们应该尝试更小的kth值，即缩小二分右边界为kth-1</li><li>如果kth使得二分图最大匹配 &lt; N-K+1 个，则说明当前kth取小了，我们应该继续尝试更大的kth值，即扩大二分左边界为kth+1</li></ul> 
<p>当二分左右边界重合时的kth值即为题解。</p> 
<p></p> 
<p>关于二分法，可以看下：</p> 
<p><a href="https://fcqian.blog.csdn.net/article/details/130097676" rel="nofollow" title="算法设计 - 二分法和三分法，洛谷P3382_二分法与三分法-CSDN博客">算法设计 - 二分法和三分法，洛谷P3382_二分法与三分法-CSDN博客</a></p> 
<p></p> 
<h4 id="%E7%AE%97%E6%B3%95%E6%BA%90%E7%A0%81" style="background-color:transparent;">JS算法源码</h4> 
<pre><code class="language-javascript">const rl = require("readline").createInterface({ input: process.stdin });
var iter = rl[Symbol.asyncIterator]();
const readline = async () =&gt; (await iter.next()).value;
 
void (async function () {
  const [n, m, k] = (await readline()).split(" ").map(Number);
 
  let min = 1;
  let max = -Infinity;
 
  const matrix = [];
  for (let i = 0; i &lt; n; i++) {
    matrix.push((await readline()).split(" ").map(Number));
    max = Math.max(max, ...matrix[i]);
  }
 
  // 二分枚举第K大的最小取值
  while (min &lt;= max) {
    // mid就是被枚举出来的N个数中的第K大的最小取值
    const mid = (min + max) &gt;&gt; 1;
 
    // 检查mid作为N个数中第K大值时，是否存在N-K+1个&lt;=它的值
    if (check(mid)) {
      max = mid - 1;
    } else {
      min = mid + 1;
    }
  }
 
  console.log(min);
 
  function check(kth) {
    // 利用二分图最大匹配来求解，小于等于kth（第K大值）的元素个数（即二分图最大匹配）
    let smallerCount = 0;
 
    // 记录每个列号的匹配成功的行号
    // 初始时每个列号都处于未配对状态，此时将列号配对的行号赋值为-1
    const match = new Array(m).fill(-1);
 
    // 遍历行号，每个行号对互相心仪的列号发起配对请求
    for (let i = 0; i &lt; n; i++) {
      // 记录增广路访问过的列号
      const vis = new Array(m).fill(false);
      if (dfs(i, kth, match, vis)) {
        smallerCount++;
      }
    }
 
    return smallerCount &gt;= n - k + 1;
  }
 
  function dfs(i, kth, match, vis) {
    // 行号 i 发起了配对请求
 
    // 遍历每一个列号j
    for (let j = 0; j &lt; m; j++) {
      // 如果当前列号j未被增广路探索过 &amp;&amp; 当前列j行i可以配对（如果行列号位置(i,j)对应矩阵元素值小于等于kth（第K大值），则可以配对）
      if (!vis[j] &amp;&amp; matrix[i][j] &lt;= kth) {
        vis[j] = true;
 
        // 如果对应列号j未配对，或者，已配对但是配对的行号match[j]可以找到其他列号重新配对
        if (match[j] == -1 || dfs(match[j], kth, match, vis)) {
          // 则当前行号i 和 列号j 可以配对
          match[j] = i;
          return true;
        }
      }
    }
 
    return false;
  }
})();</code></pre> 
<p></p> 
<h4 style="background-color:transparent;">Java算法源码</h4> 
<pre><code class="language-java">import java.util.Arrays;
import java.util.Scanner;

public class Main {
  static int n;
  static int m;
  static int k;
  static int[][] matrix;

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);

    n = sc.nextInt();
    m = sc.nextInt();
    k = sc.nextInt();

    int min = 1;
    int max = Integer.MIN_VALUE;

    matrix = new int[n][m];
    for (int i = 0; i &lt; n; i++) {
      for (int j = 0; j &lt; m; j++) {
        matrix[i][j] = sc.nextInt();
        max = Math.max(max, matrix[i][j]);
      }
    }

    // 二分枚举第K大值
    while (min &lt;= max) {
      // mid就是被枚举出来的N个数中的第K大值
      int mid = (min + max) &gt;&gt; 1;

      // 检查mid作为N个数中第K大值时，是否存在N-K+1个不大于它的值
      if (check(mid)) {
        max = mid - 1;
      } else {
        min = mid + 1;
      }
    }

    System.out.println(min);
  }

  public static boolean check(int kth) {
    // 利用二分图最大匹配来求解，小于等于kth（第K大值）的元素个数（即二分图最大匹配）
    int smallerCount = 0;

    // 记录每个列号的匹配成功的行号
    int[] match = new int[m];
    // 初始时每个列号都处于未配对状态，此时将列号配对的行号赋值为-1
    Arrays.fill(match, -1);

    // 遍历行号，每个行号对互相心仪的列号发起配对请求
    for (int i = 0; i &lt; n; i++) {
      // 记录增广路访问过的列号
      boolean[] vis = new boolean[m];
      if (dfs(i, kth, match, vis)) smallerCount++;
    }

    return smallerCount &gt;= n - k + 1;
  }

  public static boolean dfs(int i, int kth, int[] match, boolean[] vis) {
    // 行号 i 发起了配对请求

    // 遍历每一个列号j
    for (int j = 0; j &lt; m; j++) {
      // 如果当前列号j未被增广路探索过 &amp;&amp; 当前列j行i可以配对（如果行列号位置(i,j)对应矩阵元素值小于等于kth（第K大值），则可以配对）
      if (!vis[j] &amp;&amp; matrix[i][j] &lt;= kth) {
        vis[j] = true;

        // 如果对应列号j未配对，或者，已配对但是配对的行号match[j]可以找到其他列号重新配对
        if (match[j] == -1 || dfs(match[j], kth, match, vis)) {
          // 则当前行号i 和 列号j 可以配对
          match[j] = i;
          return true;
        }
      }
    }

    return false;
  }
}
</code></pre> 
<p></p> 
<h4>Python算法源码</h4> 
<pre><code class="language-python">import sys

# 输入获取
n, m, k = map(int, input().split())
matrix = [list(map(int, input().split())) for _ in range(n)]


def dfs(i, kth, match, vis):
    # 行号 i 发起了配对请求

    # 遍历每一个列号j
    for j in range(m):
        # 如果当前列号j未被增广路探索过 &amp;&amp; 当前列j行i可以配对（如果行列号位置(i,j)对应矩阵元素值小于等于kth（第K大值），则可以配对）
        if not vis[j] and matrix[i][j] &lt;= kth:
            vis[j] = True

            # 如果对应列号j未配对，或者，已配对但是配对的行号match[j]可以找到其他列号重新配对
            if match[j] == -1 or dfs(match[j], kth, match, vis):
                # 则当前行号i 和 列号j 可以配对
                match[j] = i
                return True

    return False


def check(kth):
    # 利用二分图最大匹配来求解，小于等于kth（第K大值）的元素个数（即二分图最大匹配）
    smallerCount = 0

    # 记录每个列号的匹配成功的行号
    # 初始时每个列号都处于未配对状态，此时将列号配对的行号赋值为-1
    match = [-1] * m

    # 遍历行号，每个行号对互相心仪的列号发起配对请求
    for i in range(n):
        # 记录增广路访问过的列号
        vis = [False] * m
        if dfs(i, kth, match, vis):
            smallerCount += 1

    return smallerCount &gt;= n - k + 1


# 算法入口
def getResult():
    low = 1
    high = -sys.maxsize

    for i in range(n):
        for j in range(m):
            high = max(high, matrix[i][j])

    # 二分枚举第K大值
    while low &lt;= high:
        # mid就是被枚举出来的N个数中的第K大值
        mid = (low + high) &gt;&gt; 1

        # 检查mid作为N个数中第K大值时，是否存在N-K+1个&lt;=它的值
        if check(mid):
            high = mid - 1
        else:
            low = mid + 1

    return low


# 算法调用
print(getResult())</code></pre> 
<p></p> 
<h4>C算法源码</h4> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;
#include &lt;math.h&gt;

#define MAX_SIZE 150

#define bool int
#define TRUE 1
#define FALSE 0

int n, m, k;
int matrix[MAX_SIZE][MAX_SIZE];

bool dfs(int i, int kth, int match[], int vis[]) {
    // 行号 i 发起了配对请求
    // 遍历每一个列号j
    for (int j = 0; j &lt; m; j++) {
        // 如果当前列号j未被增广路探索过 &amp;&amp; 当前列j行i可以配对（如果行列号位置(i,j)对应矩阵元素值小于等于kth（第K大值），则可以配对）
        if (!vis[j] &amp;&amp; matrix[i][j] &lt;= kth) {
            vis[j] = TRUE;

            // 如果对应列号j未配对，或者，已配对但是配对的行号match[j]可以找到其他列号重新配对
            if (match[j] == -1 || dfs(match[j], kth, match, vis)) {
                // 则当前行号i 和 列号j 可以配对
                match[j] = i;
                return TRUE;
            }
        }
    }

    return FALSE;
}

bool check(int kth) {
    // 利用二分图最大匹配来求解，小于等于kth（第K大值）的元素个数（即二分图最大匹配）
    int smallerCount = 0;

    // 记录每个列号的匹配成功的行号
    int match[m];
    // 初始时每个列号都处于未配对状态，此时将列号配对的行号赋值为-1
    for (int i = 0; i &lt; m; i++) match[i] = -1;

    // 遍历行号，每个行号对互相心仪的列号发起配对请求
    for (int i = 0; i &lt; n; i++) {
        // 记录增广路访问过的列号
        int vis[MAX_SIZE] = {FALSE};
        if (dfs(i, kth, match, vis)) {
            smallerCount++;
        }
    }

    return smallerCount &gt;= (n - k + 1);
}

int main() {
    scanf("%d %d %d", &amp;n, &amp;m, &amp;k);

    int min = 1;
    int max = INT_MIN;

    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; m; j++) {
            scanf("%d", &amp;matrix[i][j]);
            max = (int) fmax(max, matrix[i][j]);
        }
    }

    // 二分枚举第K大值
    while (min &lt;= max) {
        // mid就是被枚举出来的N个数中的第K大值
        int mid = (min + max) &gt;&gt; 1;

        // 检查mid作为N个数中第K大值时，是否存在N-K+1个&lt;=它的值
        if (check(mid)) {
            max = mid - 1;
        } else {
            min = mid + 1;
        }
    }

    printf("%d\n", min);

    return 0;
}</code></pre> 
<p></p> 
<h4>C++算法源码</h4> 
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

#define MAX_SIZE 150

int n, m, k;
int matrix[MAX_SIZE][MAX_SIZE];

bool dfs(int i, int kth, int match[], bool vis[]) {
    // 行号 i 发起了配对请求

    // 遍历每一个列号j
    for (int j = 0; j &lt; m; j++) {
        // 如果当前列号j未被增广路探索过 &amp;&amp; 当前列j行i可以配对（如果行列号位置(i,j)对应矩阵元素值小于等于kth（第K大值），则可以配对）
        if (!vis[j] &amp;&amp; matrix[i][j] &lt;= kth) {
            vis[j] = true;

            // 如果对应列号j未配对，或者，已配对但是配对的行号match[j]可以找到其他列号重新配对
            if (match[j] == -1 || dfs(match[j], kth, match, vis)) {
                // 则当前行号i 和 列号j 可以配对
                match[j] = i;
                return true;
            }
        }
    }

    return false;
}

bool check(int kth) {
    // 利用二分图最大匹配来求解，小于等于kth（第K大值）的元素个数（即二分图最大匹配）
    int smallerCount = 0;

    // 记录每个列号的匹配成功的行号
    int match[m];
    // 初始时每个列号都处于未配对状态，此时将列号配对的行号赋值为-1
    for (int i = 0; i &lt; m; i++) match[i] = -1;

    // 遍历行号，每个行号对互相心仪的列号发起配对请求
    for (int i = 0; i &lt; n; i++) {
        // 记录增广路访问过的列号
        bool vis[MAX_SIZE] = {false};
        if (dfs(i, kth, match, vis)) smallerCount++;
    }

    return smallerCount &gt;= n - k + 1;
}

int main() {
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;

    int low = 1;
    int high = INT_MIN;

    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; m; j++) {
            cin &gt;&gt; matrix[i][j];
            high = max(high, matrix[i][j]);
        }
    }

    // 二分枚举第K大值
    while (low &lt;= high) {
        // mid就是被枚举出来的N个数中的第K大值
        int mid = (low + high) &gt;&gt; 1;

        // 检查mid作为N个数中第K大值时，是否存在N-K+1个不大于它的值
        if (check(mid)) {
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }

    cout &lt;&lt; low &lt;&lt; endl;

    return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/79e4240d1dff3b3eebffa10533168fb0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">代码训练LeetCode(6)编辑距离</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fd781bd936d47103502a039b7cc6dd04/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">下载pycharm后还要python吗,用python必须下载pycharm</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>