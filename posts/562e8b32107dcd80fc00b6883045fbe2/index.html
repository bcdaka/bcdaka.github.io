<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>视频循环存储的实现 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/562e8b32107dcd80fc00b6883045fbe2/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="视频循环存储的实现">
  <meta property="og:description" content="目录
1. 三方工具
2. 视频存储的实现 2.1 分段存储 - 比如每15分钟
2.2 对齐到15分钟整边界
2.3 循环存储的实现 video_space_daemon.sh
3.封装
3.1 主执行程序，修订版
3.2 创建服务 3.3 service关联的执行脚本文件
4.额外的工作
附录A: ffmpeg视频存储，运行时错误处理 1.运行ffmpeg存储视频时
1.1 处理
附录B 服务创建加载以及运行时异常处理 1.service无法enable
1.1 处理
1. 三方工具 建议使用ffmpeg，这个工具多平台可用，命令行和API都有提供，非常便捷。下载的位置：
Download FFmpeg
我工作在debian环境，下载对应的源码后编译：
./configure
make
make install
2. 视频存储的实现 2.1 分段存储 - 比如每15分钟 下面的脚本里 MIN_PER_FILE控制的是每个视频文件的最大尺寸
#usage: video_recorder &lt;video_file_path&gt; &lt;min_per_file&gt; &lt;rtsp_path&gt; RTSP_URL_WITH_PASSWORD=&#39;rtsp://admin:xxxx@192.168.0.6:554/Streaming/Channels/101?transportmode=unicast&amp;amp;profile=Profile_1&#39; MIN_PER_FILE=03 VIDEO_FILE_PATH=&#39;/tmp/video/&#39; #include postfix mkdir -p $VIDEO_FILE_PATH ffmpeg -rtsp_transport tcp -i $RTSP_URL_WITH_PASSWORD -c:v libx265 -preset fast -crf 28 -t 00:$MIN_PER_FILE:00 $VIDEO_FILE_PATH$(date &#43;&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-08T11:30:01+08:00">
    <meta property="article:modified_time" content="2024-08-08T11:30:01+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">视频循环存储的实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%C2%A0%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7-toc" style="margin-left:0px;"><a href="#1.%C2%A0%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7" rel="nofollow">1. 三方工具</a></p> 
<p id="2.%C2%A0%E8%A7%86%E9%A2%91%E5%AD%98%E5%82%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%C2%A0-toc" style="margin-left:0px;"><a href="#2.%C2%A0%E8%A7%86%E9%A2%91%E5%AD%98%E5%82%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%C2%A0" rel="nofollow">2. 视频存储的实现 </a></p> 
<p id="2.1%C2%A0%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%20-%C2%A0%E6%AF%94%E5%A6%82%E6%AF%8F15%E5%88%86%E9%92%9F-toc" style="margin-left:40px;"><a href="#2.1%C2%A0%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%20-%C2%A0%E6%AF%94%E5%A6%82%E6%AF%8F15%E5%88%86%E9%92%9F" rel="nofollow">2.1 分段存储 - 比如每15分钟</a></p> 
<p id="2.2%C2%A0%E5%AF%B9%E9%BD%90%E5%88%B015%E5%88%86%E9%92%9F%E6%95%B4%E8%BE%B9%E7%95%8C-toc" style="margin-left:40px;"><a href="#2.2%C2%A0%E5%AF%B9%E9%BD%90%E5%88%B015%E5%88%86%E9%92%9F%E6%95%B4%E8%BE%B9%E7%95%8C" rel="nofollow">2.2 对齐到15分钟整边界</a></p> 
<p id="2.3%C2%A0%E5%BE%AA%E7%8E%AF%E5%AD%98%E5%82%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%20video_space_daemon.sh-toc" style="margin-left:40px;"><a href="#2.3%C2%A0%E5%BE%AA%E7%8E%AF%E5%AD%98%E5%82%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%20video_space_daemon.sh" rel="nofollow">2.3 循环存储的实现 video_space_daemon.sh</a></p> 
<p id="3.%E5%B0%81%E8%A3%85-toc" style="margin-left:0px;"><a href="#3.%E5%B0%81%E8%A3%85" rel="nofollow">3.封装</a></p> 
<p id="%C2%A03.1%C2%A0%E4%B8%BB%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%EF%BC%8C%E4%BF%AE%E8%AE%A2%E7%89%88-toc" style="margin-left:80px;"><a href="#%C2%A03.1%C2%A0%E4%B8%BB%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%EF%BC%8C%E4%BF%AE%E8%AE%A2%E7%89%88" rel="nofollow"> 3.1 主执行程序，修订版</a></p> 
<p id="3.2%C2%A0%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%C2%A0-toc" style="margin-left:80px;"><a href="#3.2%C2%A0%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%C2%A0" rel="nofollow">3.2 创建服务 </a></p> 
<p id="3.3%C2%A0service%E5%85%B3%E8%81%94%E7%9A%84%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#3.3%C2%A0service%E5%85%B3%E8%81%94%E7%9A%84%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6" rel="nofollow">3.3 service关联的执行脚本文件</a></p> 
<p id="4.%E9%A2%9D%E5%A4%96%E7%9A%84%E5%B7%A5%E4%BD%9C-toc" style="margin-left:0px;"><a href="#4.%E9%A2%9D%E5%A4%96%E7%9A%84%E5%B7%A5%E4%BD%9C" rel="nofollow">4.额外的工作</a></p> 
<p id="%E9%99%84%E5%BD%95A%3A%C2%A0ffmpeg%E8%A7%86%E9%A2%91%E5%AD%98%E5%82%A8%EF%BC%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%C2%A0-toc" style="margin-left:0px;"><a href="#%E9%99%84%E5%BD%95A%3A%C2%A0ffmpeg%E8%A7%86%E9%A2%91%E5%AD%98%E5%82%A8%EF%BC%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%C2%A0" rel="nofollow">附录A: ffmpeg视频存储，运行时错误处理 </a></p> 
<p id="1.%E8%BF%90%E8%A1%8Cffmpeg%E5%AD%98%E5%82%A8%E8%A7%86%E9%A2%91%E6%97%B6-toc" style="margin-left:40px;"><a href="#1.%E8%BF%90%E8%A1%8Cffmpeg%E5%AD%98%E5%82%A8%E8%A7%86%E9%A2%91%E6%97%B6" rel="nofollow">1.运行ffmpeg存储视频时</a></p> 
<p id="1.1%C2%A0%E5%A4%84%E7%90%86-toc" style="margin-left:80px;"><a href="#1.1%C2%A0%E5%A4%84%E7%90%86" rel="nofollow">1.1 处理</a></p> 
<p id="%E9%99%84%E5%BD%95B%C2%A0%E6%9C%8D%E5%8A%A1%E5%88%9B%E5%BB%BA%E5%8A%A0%E8%BD%BD%E4%BB%A5%E5%8F%8A%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%C2%A0-toc" style="margin-left:0px;"><a href="#%E9%99%84%E5%BD%95B%C2%A0%E6%9C%8D%E5%8A%A1%E5%88%9B%E5%BB%BA%E5%8A%A0%E8%BD%BD%E4%BB%A5%E5%8F%8A%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%C2%A0" rel="nofollow">附录B 服务创建加载以及运行时异常处理 </a></p> 
<p id="1.service%E6%97%A0%E6%B3%95enable-toc" style="margin-left:40px;"><a href="#1.service%E6%97%A0%E6%B3%95enable" rel="nofollow">1.service无法enable</a></p> 
<p id="1.1%C2%A0%E5%A4%84%E7%90%86-toc" style="margin-left:80px;"><a href="#1.1%C2%A0%E5%A4%84%E7%90%86" rel="nofollow">1.1 处理</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%C2%A0%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7">1. 三方工具</h2> 
<p><img alt="" height="394" src="https://images2.imgbox.com/b8/69/q8pWfRIv_o.png" width="1004"></p> 
<p>建议使用ffmpeg，这个工具多平台可用，命令行和API都有提供，非常便捷。下载的位置：</p> 
<p><a href="https://ffmpeg.org/download.html" rel="nofollow" title="Download FFmpeg">Download FFmpeg</a></p> 
<p>我工作在debian环境，下载对应的源码后编译：</p> 
<blockquote> 
 <p>./configure</p> 
 <p>make</p> 
 <p>make install</p> 
</blockquote> 
<h2 id="2.%C2%A0%E8%A7%86%E9%A2%91%E5%AD%98%E5%82%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%C2%A0">2. 视频存储的实现 </h2> 
<h3 id="2.1%C2%A0%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%20-%C2%A0%E6%AF%94%E5%A6%82%E6%AF%8F15%E5%88%86%E9%92%9F">2.1 分段存储 - 比如每15分钟</h3> 
<p>下面的脚本里 MIN_PER_FILE控制的是每个视频文件的最大尺寸</p> 
<pre><code class="language-bash">#usage: video_recorder &lt;video_file_path&gt; &lt;min_per_file&gt; &lt;rtsp_path&gt;
RTSP_URL_WITH_PASSWORD='rtsp://admin:xxxx@192.168.0.6:554/Streaming/Channels/101?transportmode=unicast&amp;amp;profile=Profile_1'
MIN_PER_FILE=03
VIDEO_FILE_PATH='/tmp/video/' #include postfix
mkdir -p $VIDEO_FILE_PATH
ffmpeg -rtsp_transport tcp -i $RTSP_URL_WITH_PASSWORD -c:v libx265 -preset fast -crf 28 -t 00:$MIN_PER_FILE:00 $VIDEO_FILE_PATH$(date +"%Y%m%d%H%M%S").mp4</code></pre> 
<p>这个命令执行时因为环境的原因，可能会提示错误，我这边的一个纠错参见附录A,正确调用后：</p> 
<blockquote> 
 <p>Output #0, mp4, to '/tmp/video/20240807094508.mp4':<br>   Metadata:<br>     title           : Media Presentation<br>     encoder         : Lavf61.1.100<br>   Stream #0:0: Video: hevc (hev1 / 0x31766568), yuvj420p(pc, bt709, progressive), 1920x1080, q=2-31, 10 fps, 10240 tbn<br>       Metadata:<br>         encoder         : Lavc61.3.100 libx265<br>       Side data:<br>         cpb: bitrate max/min/avg: 0/0/0 buffer size: 0 vbv_delay: N/A<br> frame= 1555 fps= 10 q=31.9 size=   12288KiB time=00:02:35.30 bitrate= 648.2kbits/s speed=   1x </p> 
</blockquote> 
<p>估算，最终的视频文件尺寸，单通道.h265大概每15分钟45~50MBytes.</p> 
<h3 id="2.2%C2%A0%E5%AF%B9%E9%BD%90%E5%88%B015%E5%88%86%E9%92%9F%E6%95%B4%E8%BE%B9%E7%95%8C">2.2 对齐到15分钟整边界</h3> 
<p>虽然命令行已经提供了分段存储，比如15分钟一个文件的功能，但是它没有对齐到15分钟整边界，可以看到这个逻辑。注意那个重启视频录制进程的工作使用systemctl的语法来实现的，这个在第3节封装部分会引入。</p> 
<pre><code class="language-python">#!/bin/bash

# 获取传递的参数数量
num_args=$#

if [ $num_args -ne 1 ]; then
    echo "usage: $0 &lt;chIdxbase1&gt;"
    exit 1
else
    CHIDX_BASE1=$(printf "%02d" "$1")
fi


# 变量
SERVICE_NAME="guide_video_storage_ch"$CHIDX_BASE1

# 获取当前时间的秒数
now=$(date +%s)

# 获取当前分钟数和秒数
minute=$(date +%M)
second=$(date +%S)
minute=$(echo $minute | sed 's/^0*//')  # 移除前导0
second=$(echo $second | sed 's/^0*//')  # 移除前导0


# 计算最近 15 分钟整边界
remainder=$((minute % 15))
if (( remainder == 0 &amp;&amp; second == 0 )); then
  target_time=$now
  echo $target_time
else
  if (( remainder == 0 )); then
    # 当前时间在整边界时刻，但秒数不为0
    target_time=$((now + (60 - second)))
    echo $target_time
  else
    # 计算下一个整边界的时间
    next_minute=$(( (minute + (15 - remainder)) % 60 ))
    next_hour=$(date +%H)
    if ((minute + (15 - remainder) &gt;= 60)); then
      next_hour=$(echo $next_hour | sed 's/^0*//')  # 移除前导0
      next_hour=$(( (next_hour + 1) % 24 ))
    fi

    # 计算目标时间
    target_time=$(date -d "$next_hour:$next_minute:00" +%s)
    echo $target_time
  fi
fi

# 计算需要等待的秒数
seconds_to_wait=$((target_time - now))

# 输出等待时间
echo "等待 $seconds_to_wait 秒"
sleep $seconds_to_wait

#重启脚本
sudo systemctl restart $SERVICE_NAME</code></pre> 
<h3 id="2.3%C2%A0%E5%BE%AA%E7%8E%AF%E5%AD%98%E5%82%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%20video_space_daemon.sh">2.3 循环存储的实现 video_space_daemon.sh</h3> 
<p>为了防止出现磁盘快速磨损，使用了回差的概念。</p> 
<pre><code class="language-python">#!/bin/bash

VIDEO_FILE_PATH='/tmp/video/' #include postfix
mkdir -p $VIDEO_FILE_PATH

CH_CNTS=5
DIRECTORY=$VIDEO_FILE_PATH
MAX_SIZE_MB=$((50*$CH_CNTS))
CTRL_SIZE_MB=$(awk "BEGIN {print $MAX_SIZE_MB * 0.8}")
TEMP_FILE="/tmp/file_sizes.txt"

# 计算目录中所有文件的总大小
total_size=$(du -sm "$DIRECTORY" | cut -f1)

# 如果总大小超过最大允许值
if [ "$total_size" -gt "$MAX_SIZE_MB" ]; then
  # 列出文件大小和路径，按时间排序（最旧的文件在前）
  find "$DIRECTORY" -type f -printf '%T+ %s %p\n' | sort | awk '{print $2, $3}' &gt; "$TEMP_FILE"
  
  # 删除最旧的文件，直到总大小低于 90MB
  while [ "$total_size" -gt "$CTRL_SIZE_MB" ]; do
    oldest_file=$(head -n 1 "$TEMP_FILE" | awk '{print $2}')
    file_size=$(head -n 1 "$TEMP_FILE" | awk '{print $1}')
    
    # 删除文件
    rm "$oldest_file"
    
    # 更新总大小
    total_size=$((total_size - file_size / 1024 / 1024))
    
    # 重新列出文件
    tail -n +2 "$TEMP_FILE" &gt; "$TEMP_FILE.tmp" &amp;&amp; mv "$TEMP_FILE.tmp" "$TEMP_FILE"
  done
  
  # 删除临时文件
  rm "$TEMP_FILE"
fi
</code></pre> 
<h2 id="3.%E5%B0%81%E8%A3%85">3.封装</h2> 
<p>因为视频源可能会出问题，所以需要有看护程序，最终使用Service来处理进程的遇错自动重启。然后用一个看护程序，来对齐到15分钟整边界。这里有全部的代码：</p> 
<h4 id="%C2%A03.1%C2%A0%E4%B8%BB%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%EF%BC%8C%E4%BF%AE%E8%AE%A2%E7%89%88"> 3.1 主执行程序，修订版</h4> 
<pre><code class="language-python">#!/bin/bash
#usage: gpVideoRecorder &lt;video_file_path&gt; &lt;min_per_file&gt; &lt;rtsp_path&gt; &lt;chIdxbase1&gt;


# 函数：确保目录路径以斜杠结尾
ensure_trailing_slash() {
    local dir=$1
    if [[ "$dir" != */ ]]; then
        echo "${dir}/"
    else
        echo "$dir"
    fi
}

# 获取传递的参数数量
num_args=$#

if [ $num_args -eq 0 ]; then
    VIDEO_FILE_PATH='/tmp/video/' #include postfix
    MIN_PER_FILE=03
    RTSP_URL_WITH_PASSWORD='rtsp://admin:xxxxx@192.168.0.6:554/Streaming/Channels/101?transportmode=unicast&amp;amp;profile=Profile_1'
    CH_STR="ch"$(printf "%02d" "0")_
elif [ $num_args -ne 4 ]; then
    echo "usage: $0 &lt;video_file_path&gt; &lt;min_per_file&gt; &lt;rtsp_path&gt; &lt;chIdxbase1&gt;"
else
    VIDEO_FILE_PATH=$1
    MIN_PER_FILE=$2
    RTSP_URL_WITH_PASSWORD=$3
    CH_STR="ch"$(printf "%02d" "$4")_
fi

# 确保目录存在
mkdir -p $VIDEO_FILE_PATH
# 确保目录路径以斜杠结尾
VIDEO_FILE_PATH=$(ensure_trailing_slash "$VIDEO_FILE_PATH")/

echo $VIDEO_FILE_PATH$CH_STR$(date +"%Y%m%d%H%M%S").mp4
ffmpeg -rtsp_transport tcp -i $RTSP_URL_WITH_PASSWORD -c:v libx265 -preset fast -crf 28 -t 00:$MIN_PER_FILE:00 $VIDEO_FILE_PATH$CH_STR$(date +"%Y%m%d%H%M%S").mp4</code></pre> 
<h4 id="3.2%C2%A0%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%C2%A0">3.2 创建服务 </h4> 
<pre><code class="language-python">#!/bin/bash

# 获取传递的参数数量
num_args=$#

if [ $num_args -ne 1 ]; then
    echo "usage: $0 &lt;chIdxbase1&gt;"
    exit 1
else
    # 使用 printf 将数字格式化为两位数
    CHIDX_BASE1=$(printf "%02d" "$1")
fi


# 变量
PROGRAM_DIR="/etc/program"
SERVICE_NAME="guide_video_storage_ch"$CHIDX_BASE1
SERVICE_FILE="/etc/systemd/system/${SERVICE_NAME}.service"
#service_name lookslike guide_video_storage_ch01


# 1. 创建目录
if [ ! -d "$PROGRAM_DIR" ]; then
    echo "创建目录 $PROGRAM_DIR"
    sudo mkdir -p "$PROGRAM_DIR"
fi

# 2. 创建服务文件
echo "创建服务文件 $SERVICE_FILE"
cat &lt;&lt;EOL | sudo tee "$SERVICE_FILE"
[Unit]
Description=video streamer local storage service

[Service]
ExecStart=sudo -E /home/app/common/start_video_recording.sh $CHIDX_BASE1
Restart=always
RestartSec=5
User=root

[Install]
WantedBy=multi-user.target
EOL

# 3. 重新加载 systemd 配置
echo "重新加载 systemd 配置"
sudo systemctl daemon-reload

# 4. 启动服务
echo "启动服务 ${SERVICE_NAME}"
sudo systemctl start "${SERVICE_NAME}"

# 5. 设置服务开机启动
echo "设置服务开机启动"
sudo systemctl enable "${SERVICE_NAME}"

echo "服务 ${SERVICE_NAME} 创建并启动完成。"</code></pre> 
<h4 id="3.3%C2%A0service%E5%85%B3%E8%81%94%E7%9A%84%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6">3.3 service关联的执行脚本文件</h4> 
<p>因为service不支持同时启动多个命令：</p> 
<pre><code class="language-python">#这里会对齐至整边界
sudo /home/app/common/video_split_daemon.sh 5&amp;
#循环存储支持
sudo /home/app/common/video_space_daemon.sh &amp;
#这里的文件记录长度可以略长(注意rtsp的用户名密码的规则：)
sudo /home/app/common/gpVideoRecorder /tmp/video 30 'rtsp://admin:xxxx@192.168.0.6:554/Streaming/Channels/101?transportmode=unicast&amp;amp;profile=Profile_1' 5
</code></pre> 
<p> 注意最终的那个调用需要是个阻塞命令。</p> 
<h2 id="4.%E9%A2%9D%E5%A4%96%E7%9A%84%E5%B7%A5%E4%BD%9C">4.额外的工作</h2> 
<p>在实际使用时，至少还有如下工作要做：</p> 
<ul><li>json配置文件解析和开机boot</li><li>mqtt远程命令执行接口</li><li>状态信息redis缓存</li></ul> 
<p>这个环节不再赘述。最终存储的视频文件：</p> 
<p><img alt="" height="170" src="https://images2.imgbox.com/9b/32/UPd7h6oK_o.png" width="538"></p> 
<p>那个4501.mp4, 0001.mp4, 1501.mp4这几个文件，就是自动切换过程留下的。</p> 
<h2 id="%E9%99%84%E5%BD%95A%3A%C2%A0ffmpeg%E8%A7%86%E9%A2%91%E5%AD%98%E5%82%A8%EF%BC%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%C2%A0">附录A: ffmpeg视频存储，运行时错误处理 </h2> 
<h3 id="1.%E8%BF%90%E8%A1%8Cffmpeg%E5%AD%98%E5%82%A8%E8%A7%86%E9%A2%91%E6%97%B6"><strong>1.运行ffmpeg存储视频时</strong></h3> 
<p><span style="color:#fe2c24;">Unrecognized option 'preset'.<br> Error splitting the argument list: Option not found</span></p> 
<h4 id="1.1%C2%A0%E5%A4%84%E7%90%86">1.1 处理</h4> 
<ol><li> 检查是x265编码器可能没有装</li><li>./configure --enable-libx265 --enable-libx264 --disable-x86asm --enable-gpl --pkg-config="pkg-config --static" 
  <ol><li>提示：<span style="color:#fe2c24;">ERROR: x264 not found using pkg-config</span></li></ol></li><li>sudo apt install pkg-config</li><li>sudo apt install libx264-dev</li><li>sudo apt install libx265-dev</li><li>./configure --enable-libx265 --enable-libx264 --disable-x86asm --enable-gpl</li><li>make</li><li>make install<br>  </li></ol> 
<h2 id="%E9%99%84%E5%BD%95B%C2%A0%E6%9C%8D%E5%8A%A1%E5%88%9B%E5%BB%BA%E5%8A%A0%E8%BD%BD%E4%BB%A5%E5%8F%8A%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%C2%A0">附录B 服务创建加载以及运行时异常处理 </h2> 
<h3 id="1.service%E6%97%A0%E6%B3%95enable">1.service无法enable</h3> 
<p><span style="color:#fe2c24;">Failed to enable unit: Unit file /etc/systemd/system/guide_video_storage_ch05.service is masked.</span></p> 
<h4>1.1 处理</h4> 
<p>在更新.service前，一定记得要先disable。如果出现mask:</p> 
<blockquote> 
 <p>sudo systemctl unmask guide_video_storage_ch05</p> 
 <p>sudo systemctl stop guide_video_storage_ch05</p> 
 <p>sudo systemctl disable guide_video_storage_ch05</p> 
</blockquote> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a2b4dc956fbfb6524cd37104b5ffa8dc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringBoot教程（十四） | SpringBoot之集成Redis</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3ec01f0c3fc4a6532b4464ef7dabc3f9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">为啥https比http慢</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>