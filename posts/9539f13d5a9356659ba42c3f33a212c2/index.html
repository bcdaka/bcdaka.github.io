<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】（C语言）：二叉搜索树（不使用递归） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/9539f13d5a9356659ba42c3f33a212c2/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】（C语言）：二叉搜索树（不使用递归）">
  <meta property="og:description" content="二叉搜索树：
非线性的，树是层级结构。基本单位是节点，每个节点最多2个子节点。有序。每个节点，其左子节点都比它小，其右子节点都比它大。每个子树都是一个二叉搜索树。每个节点及其所有子节点形成子树。可以是空树。 C语言实现：（使用链表实现，不使用递归）
创建结构体数据类型（记录二叉搜索树的根节点和数据个数）：
typedef struct Link { LinkNode *root; // 根节点 int length; // 统计有多少数据 } LinkBST; // 别名 创建二叉搜索树，并初始化：
LinkBST bst; bst.root = NULL; // 根节点，初始化为NULL bst.length = 0; // 数据个数，初始化为0 创建节点（结构体数据类型），并创建具体节点实例的函数：
// 节点（结构体数据类型） typedef struct Node { int value; // 数据类型为整型 struct Node *left; // 左子节点 struct Node *right; // 右子节点 } LinkNode; // 别名 // 函数：创建节点 LinkNode *createNode(int data) { LinkNode *node = (LinkNode *)malloc(sizeof(LinkNode)); // 分配节点内存空间 if(node == NULL) { perror(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-04T15:09:06+08:00">
    <meta property="article:modified_time" content="2024-07-04T15:09:06+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】（C语言）：二叉搜索树（不使用递归）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>二叉搜索树：</p> 
<ul><li>非线性的，树是层级结构。</li><li>基本单位是节点，每个节点最多2个子节点。</li><li>有序。每个节点，其左子节点都比它小，其右子节点都比它大。</li><li>每个子树都是一个二叉搜索树。每个节点及其所有子节点形成子树。</li><li>可以是空树。</li></ul> 
<hr> 
<p>C语言实现：（使用链表实现，不使用递归）</p> 
<p> 创建结构体数据类型（记录二叉搜索树的根节点和数据个数）：</p> 
<pre><code class="language-cpp">typedef struct Link
{
    LinkNode *root;            // 根节点
    int length;                // 统计有多少数据
} LinkBST;                     // 别名</code></pre> 
<p>创建二叉搜索树，并初始化：</p> 
<pre><code class="language-cpp">LinkBST bst;
bst.root = NULL;    // 根节点，初始化为NULL
bst.length = 0;     // 数据个数，初始化为0</code></pre> 
<p><br> 创建节点（结构体数据类型），并创建具体节点实例的函数：</p> 
<pre><code class="language-cpp">// 节点（结构体数据类型）
typedef struct Node
{
    int value;                // 数据类型为整型
    struct Node *left;        // 左子节点
    struct Node *right;       // 右子节点
} LinkNode;                   // 别名</code></pre> 
<pre><code class="language-cpp">// 函数：创建节点
LinkNode *createNode(int data)
{
    LinkNode *node = (LinkNode *)malloc(sizeof(LinkNode));    // 分配节点内存空间
    if(node == NULL)
    {
        perror("Memory allocation failed");
        exit(-1);
    }
    node-&gt;value = data;    // 数据
    node-&gt;left = NULL;     // 左子节点，初始化为NULL
    node-&gt;right = NULL;    // 右子节点，初始化为NULL
    return node;
}</code></pre> 
<p><br> 添加元素：</p> 
<p>从根节点开始，比对数值。若比它小，往左子树比对；若比它大，往右子树比对；直到找到为空，则为新元素的位置。</p> 
<pre><code class="language-cpp">void add(LinkBST *bst, int data)	// add a element to the tree
{
	LinkNode *newNode = createNode(data);
	// 若是空树，根节点就是新节点
	if(bst-&gt;root == NULL)
	{
		bst-&gt;root = newNode;
		bst-&gt;length++;
		return ;
	}
	// 非空树，比根节点数值小，往左边比对，比根节点数值大，往右边比对
	LinkNode *cur = bst-&gt;root;
	while(1)
	{
		if(data == cur-&gt;value) return ;
		if(data &lt; cur-&gt;value)
		{
			if(cur-&gt;left == NULL)
			{
				cur-&gt;left = newNode;
				bst-&gt;length++;
				return ;
			}
			cur = cur-&gt;left;
		}
		else if(data &gt; cur-&gt;value)
		{
			if(cur-&gt;right == NULL)
			{
				cur-&gt;right = newNode;
				bst-&gt;length++;
				return ;
			}
			cur = cur-&gt;right;
		}
	}
}</code></pre> 
<p></p> 
<p>删除元素：</p> 
<ul><li>若删除的节点为叶子节点（即无子节点），则直接删除。</li><li>若删除的节点只有左子节点，则左子节点替代删除节点。</li><li>若删除的节点只有右子节点，则右子节点替代删除节点。</li><li>若删除的节点既有左子节点又有右子节点，则找到直接前驱（即删除节点的左子树中的最大值，即删除节点的左子节点的最右节点），直接前驱的值替代删除节点的值，删除直接前驱节点。</li></ul> 
<pre><code class="language-cpp">void delete(LinkBST *bst,int data)	// delete a element from the tree
{
	// 函数：删除节点的具体操作
	LinkNode *del(LinkNode *node)
	{
		// 只有右子节点，右子节点替代删除节点
		if(node-&gt;left == NULL)
		{
			bst-&gt;length--;
			return node-&gt;right;
		}
		// 只有左子节点，左子节点替代删除节点
		if(node-&gt;right == NULL)
		{
			bst-&gt;length--;
			return node-&gt;left;
		}
		// 左右子节点都有，直接前驱(左子节点的最右节点,即左子树中最大值)替代删除节点,删除直接前驱
		if(node-&gt;left &amp;&amp; node-&gt;right)
		{
			LinkNode *tmp = node, *cur = node-&gt;left;
			while(cur-&gt;right)
			{
				tmp = cur;
				cur = cur-&gt;right;
			}
			node-&gt;value = cur-&gt;value;
			bst-&gt;length--;
			if(tmp != node) tmp-&gt;right = cur-&gt;left;
			else tmp-&gt;left = cur-&gt;left;
			return node;
		}
	}
	
	// 函数：找到删除节点
	void delNode(int data)
	{
		LinkNode *parent, *cur = bst-&gt;root;
		while(1)
		{
			if(cur == NULL) return ;
			if(data == cur-&gt;value)
			{
				// 删除节点若是根节点，根节点接收删除后的节点
				if(cur == bst-&gt;root) bst-&gt;root = del(cur);
				// 删除节点若是左子节点，父节点的左子节点接收删除后的节点
				else if(data &lt; parent-&gt;value) parent-&gt;left = del(cur);
				// 删除节点若是右子节点，父节点的右子节点接收删除后的节点
				else if(data &gt; parent-&gt;value) parent-&gt;right = del(cur);
				return ;
			}
			if(data &lt; cur-&gt;value)
			{
				parent = cur;
				cur = cur-&gt;left;
			}
			else if(data &gt; cur-&gt;value)
			{
				parent = cur;
				cur = cur-&gt;right;
			}
		}
	}
    // 空树，直接退出程序
	if(bst-&gt;root == NULL) return ;
	delNode(data);
}</code></pre> 
<p></p> 
<p>遍历元素：</p> 
<p>前序遍历：（顺序：根节点、左子节点、右子节点）</p> 
<p>使用数组实现栈（后进先出），数量：一个栈。</p> 
<p>1、起始栈中元素为根节点。2、栈中元素依次出栈（并打印），找到元素的右节点和左节点依次入栈（注意：先右后左）。3、重复2，直到栈为空。</p> 
<pre><code class="language-cpp">void pretraverse(LinkBST *bst)	// show element one by one,(root,left,right)
{
	LinkNode *cur = NULL;
	// 指针数组(数组元素是指针),实现栈(后进先出)
	LinkNode *arr[bst-&gt;length];
	int n = 1;
	arr[n-1] = bst-&gt;root;
	printf("pretravel: ");
	while(n != 0)
	{
		cur = arr[n-1];
		printf("%d  ", cur-&gt;value);
		n--;
		if(cur-&gt;right)
		{
			arr[n] = cur-&gt;right;
			n++;
		}
		if(cur-&gt;left)
		{
			arr[n] = cur-&gt;left;
			n++;
		}
	}
	printf("\n");
}</code></pre> 
<p>中序遍历：（顺序：左子节点、根节点、右子节点）</p> 
<p>使用数组实现栈（后进先出），数量：一个栈。</p> 
<p>1、从根节点开始遍历，根节点入栈。2、找左节点依次入栈，找到最左节点后，栈中元素依次出栈（并打印），找右节点入栈。3、重复2，直到节点不存在或者栈为空。</p> 
<pre><code class="language-cpp">void midtraverse(LinkBST *bst)	// show element one by one,(left,root,right)
{
	printf("midtravel: ");
	LinkNode *cur = bst-&gt;root;
	// 指针数组(数组元素是指针),实现栈(后进先出)
	LinkNode *arr[bst-&gt;length];
	int n = 0;
	while(cur || n != 0)
	{
		if(cur)
		{
			arr[n] = cur;
			n++;
			cur = cur-&gt;left;
		}
		else
		{
			cur = arr[n-1];
			printf("%d  ", cur-&gt;value);
			n--;
			cur = cur-&gt;right;
		}
	}
	printf("\n");
}</code></pre> 
<p>后序遍历：（顺序：左子节点、右子节点、根节点）</p> 
<p>使用数组实现栈（后进先出），数量：两个栈（辅助栈，目标栈）。</p> 
<p>1、辅助栈中起始元素为根节点。2、辅助栈中元素依次出栈（并入栈目标栈），找到元素的左节点和右节点依次入栈辅助栈（注意：先左后右）。3、重复2，直到辅助栈为空。4、遍历目标栈，并打印。</p> 
<pre><code class="language-cpp">void posttraverse(LinkBST *bst)	// show element one by one,(left,right,root)
{
	LinkNode *cur = NULL;
	// 指针数组(数组元素是指针),实现栈(后进先出)
	LinkNode *arr[bst-&gt;length];    // 辅助栈
	LinkNode *brr[bst-&gt;length];    // 目标栈
	int n = 1, m = 0;
	arr[n-1] = bst-&gt;root;
	while(n != 0)
	{	
		cur = brr[m] = arr[n-1];    // 辅助栈出栈，目标栈入栈
		n--;
		m++;
		if(cur-&gt;left)
		{
			arr[n] = cur-&gt;left;    // 辅助栈入栈
			n++;
		}
		if(cur-&gt;right)
		{
			arr[n] = cur-&gt;right;    // 辅助栈入栈
			n++;
		}
	}
    // 遍历目标栈
	printf("posttravel: ");
	for(int i = m - 1; i &gt;= 0; i--)
	{
		printf("%d  ", brr[i]-&gt;value);
	}
	printf("\n");
}</code></pre> 
<p>广度遍历（层级遍历）：</p> 
<p>使用链表实现队列（先进先出），数量：一个队列。</p> 
<p>1、队列中起始元素为根节点。2、队列中元素依次从队头出队（并打印），找到元素的左节点和右节点依次从队尾入队（注意：先左后右）。3、重复2，直到队列为空。</p> 
<pre><code class="language-cpp">void breadthtraverse(LinkBST *bst)	// show element one by one,(levels)
{
	printf("threadtravel: ");
	// 链表：实现队列(先进先出)，注：链表的函数在bstqueue.c(完整代码中展示)
	Queue queue;
	queue.header = createQnode(bst-&gt;root);    // 头指针，指向第一个元素
	queue.tail = NULL;                        // 尾指针，指向最后一个元素
	LinkNode *cur = NULL;
	while(queue.header)
	{
		cur = queue.header-&gt;bstnode;
		printf("%d  ", cur-&gt;value);
		popQnode(&amp;queue);                    // 从队头出队(函数在bstqueue.c)
		if(cur-&gt;left)
		{
			addQnode(&amp;queue, cur-&gt;left);    // 从队尾入队(函数在bstqueue.c)
		}
		if(cur-&gt;right)
		{
			addQnode(&amp;queue, cur-&gt;right);    // 从队尾入队(函数在bstqueue.c)
		}
	}
	printf("\n");
}</code></pre> 
<p>查找元素：</p> 
<p>从根节点开始，比对数值。若比它小，往左子树查找；若比它大，往右子树查找；直到找到该元素，则返回1（true），若没有，则返回0（false）。</p> 
<pre><code class="language-cpp">int find(LinkNode *node, int data)	// if find data,return 1(true),or return 0(false)
{
	LinkNode *cur = node;
	while(cur)
	{
		if(data == cur-&gt;value) return 1;
		if(data &lt; cur-&gt;value) cur = cur-&gt;left;
		else if(data &gt; cur-&gt;value) cur = cur-&gt;right;
	}
	return 0;
}</code></pre> 
<hr> 
<p>完整代码：（bstree<strong>.</strong>c，bstqueue<strong>.</strong>c（链表实现的队列，用于广度遍历））</p> 
<pre><code class="language-cpp">// bstree.c
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "bstqueue.c"    // 引入链表实现的队列，用于广度遍历

/* structure */
typedef struct Node		// node of the binary search tree(bst)
{
	int value;		    // data type is integer
	struct Node *left;	// left child node
	struct Node *right;	// right child node
} LinkNode;

typedef struct Link		//bst(Linkedlist)
{
	LinkNode *root;		// root node
	int length;		    // the number of the tree
} LinkBST;

/* function prototype */
void add(LinkBST *, int);	    // add a element
void delete(LinkBST *,int);	    // delete a element
void pretraverse(LinkBST *);	// show element one by one,(root,left,right)
void midtraverse(LinkBST *);	// show element one by one,(left,root,right)
void posttraverse(LinkBST *);	// show element one by one,(left,right,root)
void breadthtraverse(LinkBST *);	// show element one by one,(levels)
int find(LinkNode *, int);	    // if find data,return 1(true),or return 0(false)

/* main function */
int main(void)
{
	// create binary search tree and initialization
	LinkBST bst;
	bst.root = NULL;
	bst.length = 0;
	printf("isempty(1:true, 0:false): %d, length is %d\n", bst.root==NULL, bst.length);

	add(&amp;bst, 15);
	add(&amp;bst, 8);
	add(&amp;bst, 23);
	add(&amp;bst, 19);
	add(&amp;bst, 10);
	add(&amp;bst, 6);
	add(&amp;bst, 9);
	add(&amp;bst, 12);
	
	printf("isempty(1:true, 0:false): %d, length is %d\n", bst.root==NULL, bst.length);
	pretraverse(&amp;bst);
	midtraverse(&amp;bst);
	posttraverse(&amp;bst);
	breadthtraverse(&amp;bst);

	printf("find 10(1:true, 0:false): %d\n", find(bst.root, 10));
	printf("find 11(1:true, 0:false): %d\n", find(bst.root, 11));

	delete(&amp;bst, 23);
	delete(&amp;bst, 15);
	delete(&amp;bst, 6);
		
	printf("isempty(1:true, 0:false): %d, length is %d\n", bst.root==NULL, bst.length);
	pretraverse(&amp;bst);
	midtraverse(&amp;bst);
	posttraverse(&amp;bst);
	breadthtraverse(&amp;bst);
	return 0;
}

/* subfunction */
LinkNode *createNode(int data)		// create a node of the binary search tree
{
	LinkNode *node = (LinkNode *)malloc(sizeof(LinkNode));
	if(node == NULL)
	{
		perror("Memory allocation failed");
		exit(-1);
	}
	node-&gt;value = data;
	node-&gt;left = NULL;
	node-&gt;right = NULL;
	return node;
}

void add(LinkBST *bst, int data)	// add a element to the tree
{
	LinkNode *newNode = createNode(data);
	// if empty, root is newNode
	if(bst-&gt;root == NULL)
	{
		bst-&gt;root = newNode;
		bst-&gt;length++;
		return ;
	}
	// if not empty, smaller,to left, biger,to right
	LinkNode *cur = bst-&gt;root;
	while(1)
	{
		if(data == cur-&gt;value) return ;
		if(data &lt; cur-&gt;value)
		{
			if(cur-&gt;left == NULL)
			{
				cur-&gt;left = newNode;
				bst-&gt;length++;
				return ;
			}
			cur = cur-&gt;left;
		}
		else if(data &gt; cur-&gt;value)
		{
			if(cur-&gt;right == NULL)
			{
				cur-&gt;right = newNode;
				bst-&gt;length++;
				return ;
			}
			cur = cur-&gt;right;
		}
	}
}

void delete(LinkBST *bst,int data)	// delete a element from the tree
{
	// subfunction: delete the node
	LinkNode *del(LinkNode *node)
	{
		// if only right child, return right child node
		if(node-&gt;left == NULL)
		{
			bst-&gt;length--;
			return node-&gt;right;
		}
		// if only left child, return left child node
		if(node-&gt;right == NULL)
		{
			bst-&gt;length--;
			return node-&gt;left;
		}
		// both left and right, the max from the left replace the delete node and delete it
		if(node-&gt;left &amp;&amp; node-&gt;right)
		{
			LinkNode *tmp = node, *cur = node-&gt;left;
			while(cur-&gt;right)
			{
				tmp = cur;
				cur = cur-&gt;right;
			}
			node-&gt;value = cur-&gt;value;
			bst-&gt;length--;
			if(tmp != node) tmp-&gt;right = cur-&gt;left;
			else tmp-&gt;left = cur-&gt;left;
			return node;
		}
	}
	
	// subfunction: find the delete node
	void delNode(int data)
	{
		LinkNode *parent, *cur = bst-&gt;root;
		while(1)
		{
			if(cur == NULL) return ;
			if(data == cur-&gt;value)
			{
				// if delete node is root,root receive the node after delete
				if(cur == bst-&gt;root) bst-&gt;root = del(cur);
				// if delete node is left, parent left receive the node after delete
				else if(data &lt; parent-&gt;value) parent-&gt;left = del(cur);
				//if delete node is right,parent right receive the node after delete
				else if(data &gt; parent-&gt;value) parent-&gt;right = del(cur);
				return ;
			}
			if(data &lt; cur-&gt;value)
			{
				parent = cur;
				cur = cur-&gt;left;
			}
			else if(data &gt; cur-&gt;value)
			{
				parent = cur;
				cur = cur-&gt;right;
			}
		}
	}

	if(bst-&gt;root == NULL) return ;
	delNode(data);
}

void pretraverse(LinkBST *bst)	// show element one by one,(root,left,right)
{
	LinkNode *cur = NULL;
	// pointer array(stack:LIFO): array, each element is a pointer(point to node)
	LinkNode *arr[bst-&gt;length];
	int n = 1;
	arr[n-1] = bst-&gt;root;
	printf("pretravel: ");
	while(n != 0)
	{
		cur = arr[n-1];
		printf("%d  ", cur-&gt;value);
		n--;
		if(cur-&gt;right)
		{
			arr[n] = cur-&gt;right;
			n++;
		}
		if(cur-&gt;left)
		{
			arr[n] = cur-&gt;left;
			n++;
		}
	}
	printf("\n");
}

void midtraverse(LinkBST *bst)	// show element one by one,(left,root,right)
{
	printf("midtravel: ");
	LinkNode *cur = bst-&gt;root;
	// pointer array(stack:LIFO): array, each element is a pointer(point to node)
	LinkNode *arr[bst-&gt;length];
	int n = 0;
	while(cur || n != 0)
	{
		if(cur)
		{
			arr[n] = cur;
			n++;
			cur = cur-&gt;left;
		}
		else
		{
			cur = arr[n-1];
			printf("%d  ", cur-&gt;value);
			n--;
			cur = cur-&gt;right;
		}
	}
	printf("\n");
}

void posttraverse(LinkBST *bst)	// show element one by one,(left,right,root)
{
	LinkNode *cur = NULL;
	// pointer array(stack:LIFO): array, each element is a pointer(point to node)
	LinkNode *arr[bst-&gt;length];
	LinkNode *brr[bst-&gt;length];
	int n = 1, m = 0;
	arr[n-1] = bst-&gt;root;
	while(n != 0)
	{	
		cur = brr[m] = arr[n-1];
		n--;
		m++;
		if(cur-&gt;left)
		{
			arr[n] = cur-&gt;left;
			n++;
		}
		if(cur-&gt;right)
		{
			arr[n] = cur-&gt;right;
			n++;
		}
	}
	printf("posttravel: ");
	for(int i = m - 1; i &gt;= 0; i--)
	{
		printf("%d  ", brr[i]-&gt;value);
	}
	printf("\n");
}

void breadthtraverse(LinkBST *bst)	// show element one by one,(levels)
{
	printf("threadtravel: ");
	// queue(FIFO): use Linkedlist implementation
	Queue queue;
	queue.header = createQnode(bst-&gt;root);
	queue.tail = NULL;
	LinkNode *cur = NULL;
	while(queue.header)
	{
		cur = queue.header-&gt;bstnode;
		printf("%d  ", cur-&gt;value);
		popQnode(&amp;queue);
		if(cur-&gt;left)
		{
			addQnode(&amp;queue, cur-&gt;left);
		}
		if(cur-&gt;right)
		{
			addQnode(&amp;queue, cur-&gt;right);
		}
	}
	printf("\n");
}

int find(LinkNode *node, int data)	// if find data,return 1(true),or return 0(false)
{
	LinkNode *cur = node;
	while(cur)
	{
		if(data == cur-&gt;value) return 1;
		if(data &lt; cur-&gt;value) cur = cur-&gt;left;
		else if(data &gt; cur-&gt;value) cur = cur-&gt;right;
	}
	return 0;
}</code></pre> 
<pre><code class="language-cpp">// bstqueue.c
#include &lt;stdlib.h&gt;

/* structure */
typedef struct queueNode	// node of the queue
{
	void *bstnode;			// data type is bst node
	struct queueNode *next;	// point to next node
} Qnode;

typedef struct queue		// queue(Linkedlist)
{
	Qnode *header;		    // point to the top node
	Qnode *tail;		    // point to the last node
} Queue;

/* subfunction */
Qnode *createQnode(void *bstnode)	// create a node of the queue
{
	Qnode *node = (Qnode *)malloc(sizeof(Qnode));
	if(node == NULL)
	{
		perror("Memory allocation failed");
		exit(-1);
	}
	node-&gt;bstnode = bstnode;
	node-&gt;next = NULL;
	return node;
}

void addQnode(Queue *queue, void *node)	// add a element to the end of the queue
{
	Qnode *qnode = createQnode(node);
	if(queue-&gt;tail == NULL) queue-&gt;tail = queue-&gt;header = qnode;
	else
	{
		queue-&gt;tail-&gt;next = qnode;
		queue-&gt;tail = qnode;
	}
}

void popQnode(Queue *queue)		// delete a element from the top of the queue
{
	queue-&gt;header = queue-&gt;header-&gt;next;
	if(queue-&gt;header == NULL) queue-&gt;tail = NULL;
}</code></pre> 
<blockquote> 
 <p>编译链接： gcc -o bstree bstree<strong>.</strong>c</p> 
 <p>执行可执行文件： <strong>.</strong>/bstree</p> 
</blockquote> 
<p><img alt="" height="179" src="https://images2.imgbox.com/66/c9/LsDPWhzb_o.png" width="504"></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/55653fc6dff7e73bb95deeac2d6a072b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Docker加速器配置指南：提升镜像下载速度的秘诀 加速安装Mysql Redis ES</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/72e83fe6a06571ac3baca1a9d3d1e387/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【物联网工程导论期末复习完整知识点】第四章物联网智能硬件与嵌入式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>