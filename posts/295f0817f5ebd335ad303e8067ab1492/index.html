<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>匿名内部类 - ( 零基础学java ) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/295f0817f5ebd335ad303e8067ab1492/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="匿名内部类 - ( 零基础学java )">
  <meta property="og:description" content="Java-匿名内部类 我们先分析匿名内部类的结构,然后逐一解释,最后以下罗列的问题都会在下面的内容中一一得到解答 :
匿名内部类到底是什么?
我们为什么要学习匿名内部类 ?
匿名内部类都有怎样的作用 ?
匿名内部类应用的场景又有哪些 ?
匿名内部类是否有缺陷?
让我们带着这些问题来学习Java中的匿名内部类吧 !
结构决定性质
结构 匿名内部类基本语法 : new 父类构造器(参数) / 实现接口() { // 类的主体部分 }; 解释匿名内部类语法中所有的概念：
new 父类构造器(参数) 表示匿名内部类是某个类的子类实例。
实现接口() 表示匿名内部类是某个接口的实现实例。
{ ... } 内部是匿名内部类的主体部分，包含类的字段、方法等定义。
性质 匿名内部类（Anonymous Inner Class）是一种在声明和创建对象的同时定义类的方式，它没有显式的类名。通过 匿名内部类 看这几个字的字面意思我们都知道这是个没有名字的类,即 非具名类 . 以下是匿名内部类的具备的一些性质 :
可以实现接口或继承类： 匿名内部类可以实现接口或继承某个类，从而提供具体的实现。没有显式的类名： 匿名内部类没有显式的类名，因为它是一种临时的、一次性的实现。一次性使用： 通常用于临时的、一次性的场景，不需要复用。因为匿名内部类没有类名，所以无法在其他地方重复使用。可以访问外部类的成员： 匿名内部类可以访问外部类的成员，包括成员变量和方法。对于外部类的局部变量，有一些规则，比如必须是final或者事实上是final的。可以包含字段和方法： 在匿名内部类的主体部分，可以包含字段（成员变量）和方法的定义。不可以包含静态成员： 匿名内部类不能包含静态成员，包括静态方法和静态变量。 我们来一个一个的解释,同时我也会拿具体的代码演示.
可以实现接口或继承类 匿名内部类可以用来实现接口或者继承类,这也是匿名内部类最常用的一个用法,我们在实际开发中,如果需要实现(重写)某个接口(类)的方法,而且这个方法只是临时使用,不需要复用,而且会出现很多这样的场景,我们肯定是不想一一都去额外的封装一个类去实现接口或者继承类然后再创建类的实例,取调用我们需要的方法,这个时候我们就 匿名内部类 就排上用场啦,我们可以通过匿名内部类去临时创建一个接口的实例(接口不能实例化,这里只是形象比喻一下)或者创建一个临时的子类重写了父类方法的实例. 总结一下 : 当匿名内部类需要实现接口或者继承类时，它可以直接在创建对象的地方定义类的主体，而不需要显式地声明一个具名的类。 package src.demo; //定义一个接口 interface Chef{ void cook(); } class Sever{ public void shangCai(){ System.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-12-11T09:32:40+08:00">
    <meta property="article:modified_time" content="2023-12-11T09:32:40+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">匿名内部类 - ( 零基础学java )</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Java_0"></a>Java-匿名内部类</h2> 
<p>我们先分析匿名内部类的结构,然后逐一解释,最后以下罗列的问题都会在下面的内容中一一得到解答 :</p> 
<p>匿名内部类到底是什么?</p> 
<p>我们为什么要学习匿名内部类 ?</p> 
<p>匿名内部类都有怎样的作用 ?</p> 
<p>匿名内部类应用的场景又有哪些 ?</p> 
<p>匿名内部类是否有缺陷?</p> 
<p>让我们带着这些问题来学习Java中的匿名内部类吧 !</p> 
<p><strong><font color="blown">结构决定性质</font></strong></p> 
<h3><a id="font_color__blue_21"></a><font color="blue">结构</font></h3> 
<ul><li>匿名内部类基本语法 :</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">new</span> 父类构造器<span class="token punctuation">(</span>参数<span class="token punctuation">)</span> <span class="token operator">/</span> 实现接口<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 类的主体部分</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li> <p>解释匿名内部类语法中所有的概念：</p> 
  <ul><li> <p><code>new 父类构造器(参数)</code> 表示匿名内部类是某个类的子类实例。</p> </li><li> <p><code>实现接口()</code> 表示匿名内部类是某个接口的实现实例。</p> </li><li> <p><code>{ ... }</code> 内部是匿名内部类的主体部分，包含类的字段、方法等定义。</p> </li></ul> </li></ul> 
<hr> 
<h3><a id="font_color__blue_41"></a><font color="blue">性质</font></h3> 
<p><strong>匿名内部类</strong>（Anonymous Inner Class）是一种在声明和创建对象的同时定义类的方式，它没有显式的类名。通过 <code>匿名内部类</code> 看这几个字的字面意思我们都知道这是个没有名字的类,即 <font color="red">非具名类</font> . 以下是匿名内部类的具备的一些性质 :</p> 
<ol><li><strong>可以实现接口或继承类：</strong> 匿名内部类可以实现接口或继承某个类，从而提供具体的实现。</li><li><strong>没有显式的类名：</strong> 匿名内部类没有显式的类名，因为它是一种临时的、一次性的实现。</li><li><strong>一次性使用：</strong> 通常用于临时的、一次性的场景，不需要复用。因为匿名内部类没有类名，所以无法在其他地方重复使用。</li><li><strong>可以访问外部类的成员：</strong> 匿名内部类可以访问外部类的成员，包括成员变量和方法。对于外部类的局部变量，有一些规则，比如必须是<code>final</code>或者事实上是<code>final</code>的。</li><li><strong>可以包含字段和方法：</strong> 在匿名内部类的主体部分，可以包含字段（成员变量）和方法的定义。</li><li><strong>不可以包含静态成员：</strong> 匿名内部类不能包含静态成员，包括静态方法和静态变量。</li></ol> 
<p>我们来一个一个的解释,同时我也会拿具体的代码演示.</p> 
<h4><a id="font_color__blownfont_58"></a><strong><font color="blown">可以实现接口或继承类</font></strong></h4> 
<ul><li>匿名内部类可以用来实现接口或者继承类,这也是匿名内部类最常用的一个用法,我们在实际开发中,如果需要实现(重写)某个接口(类)的方法,而且这个方法只是临时使用,不需要复用,而且会出现很多这样的场景,我们肯定是不想一一都去额外的封装一个类去实现接口或者继承类然后再创建类的实例,取调用我们需要的方法,这个时候我们就 <strong>匿名内部类</strong> 就排上用场啦,我们可以通过匿名内部类去临时创建一个接口的实例(接口不能实例化,这里只是形象比喻一下)或者创建一个临时的子类重写了父类方法的实例. <font color="red">总结一下 : 当匿名内部类需要实现接口或者继承类时，它可以直接在创建对象的地方定义类的主体，而不需要显式地声明一个具名的类。</font></li></ul> 
<pre><code class="prism language-java"><span class="token keyword">package</span> <span class="token namespace">src<span class="token punctuation">.</span>demo</span><span class="token punctuation">;</span>

<span class="token comment">//定义一个接口</span>
<span class="token keyword">interface</span>  <span class="token class-name">Chef</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">void</span> <span class="token function">cook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Sever</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shangCai</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"服务员上菜"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo01</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        <span class="token comment">//使用匿名内部类来实现接口</span>
        <span class="token class-name">Chef</span> chef1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Chef</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">cook</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"炒蛋炒饭"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token comment">//调用我们使用匿名内部类实现接口实例中的抽象方法</span>
        chef1<span class="token punctuation">.</span><span class="token function">cook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token comment">//使用匿名内部类重写父类方法</span>
        <span class="token class-name">Sever</span> sever <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sever</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shangCai</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"服务员上菜-&gt;蛋炒饭"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token comment">//调用我们使用匿名内部类重写父类的方法</span>
        sever<span class="token punctuation">.</span><span class="token function">shangCai</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>通过上述的代码,我演示了两种使用匿名内部类的情况：</p> 
<ol><li> <p><strong>实现接口：</strong> 通过匿名内部类实现了 <code>Chef</code> 接口，提供了 <code>cook</code> 方法的具体实现。</p> <pre><code class="prism language-java"><span class="token class-name">Chef</span> chef1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Chef</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">cook</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"炒蛋炒饭"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <p>这部分代码演示了匿名内部类用于实现接口的情况，通过创建一个实现了 <code>Chef</code> 接口的匿名内部类的实例，重写了接口中的抽象方法 <code>cook</code>。</p> </li><li> <p><strong>重写父类方法：</strong> 通过匿名内部类重写了 <code>Sever</code> 类的 <code>shangCai</code> 方法。</p> <pre><code class="prism language-java"><span class="token class-name">Sever</span> sever <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sever</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shangCai</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"服务员上菜-&gt;蛋炒饭"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <p>这部分代码演示了匿名内部类用于重写父类方法的情况，通过创建一个继承自 <code>Sever</code> 类的匿名内部类的实例，重写了 <code>Sever</code> 类的方法 <code>shangCai</code>。</p> </li></ol> 
<p>通过这两种使用情况，你展示了匿名内部类在实现接口和重写父类方法时的便利性。匿名内部类可以直接在创建对象的地方提供类的定义，避免了显式地声明一个具名的类，尤其适用于一次性的实现或重写。</p> 
<h4><a id="font_color__blownfont_135"></a><font color="blown">没有显式的类名</font></h4> 
<p>没有显式的类名,这意味这我们使用匿名内部类创建出来的实例是无法通过类名去访问的,如果我们需要实现函数回调的话,我们就可以使用父类引用或者接口引用去接收. 所以,我们可以知道 **<font color="green">匿名内部类是必须基于已存在的类或者接口,因为它的实质是在这个基础上创建一个新的匿名子类或者实现一个匿名实例,</font>**这样做的优势就是我们省略了显式的创建一个具名子类的步骤,这对于我们一些简单的或者一次性的任务是非常方便的,因我们我们可以在需要的地方直接实现类的功能,而无需为此专门定义一个新的类,这使得代码可以更为紧凑和直观.</p> 
<h4><a id="font_color__blownfont_141"></a><font color="blown">一次性使用</font></h4> 
<p>匿名内部类具备这个性质的理由就是 : 因为匿名内部类没有类名，所以无法在其他地方重复使用。</p> 
<h4><a id="font_color__blownfont_147"></a><font color="blown">可以访问外部类的成员</font></h4> 
<p>实际需求中如果我们需要使用匿名内部类访问外部类的一些成员(包括属性和方法) , 那么其中是否有什么限制或者规则吗 ? 有的 ! 我们后续通过代码测试也可以知道,在这里我们先提前说明有怎样的规则 :</p> 
<p><font color="green"> 匿名内部类可以访问外部类的成员，包括成员变量和方法。对于外部类的局部变量,有一些规则，比如必须是<code>final</code>或者<code>事实上是final</code>的</font>.</p> 
<p><strong>(1)外部类的成员变量：</strong></p> 
<p>匿名内部类中可以访问外部类的成员变量，并且可以进行修改。这是因为外部类的成员变量在匿名内部类中有完整的作用域，而且匿名内部类实际上是外部类的一个扩展，可以直接访问外部类的成员。(需要注意的是 : 在匿名内部类的方法中，可以访问和修改外部类的成员变量。这些修改在匿名内部类的方法中生效，但不会影响外部类实例之外的其他代码。这是因为匿名内部类实际上是一个新的类，其代码块被包含在外部类的方法内部，而成员变量的修改是在匿名内部类的方法中执行的。)</p> 
<p>实例代码如下 :</p> 
<pre><code class="prism language-java"><span class="token keyword">package</span> <span class="token namespace">src<span class="token punctuation">.</span>main</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Example</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> memberVar <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">modifyMemberVar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 匿名内部类</span>
        <span class="token class-name">Runnable</span> r1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">synchronized</span>  <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 访问外部类的成员变量</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Before modification: "</span> <span class="token operator">+</span> memberVar<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment">// 修改外部类的成员变量</span>
                memberVar <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>

                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"After modification: "</span> <span class="token operator">+</span> memberVar<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token class-name">Runnable</span> r2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">synchronized</span>  <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 访问外部类的成员变量</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Before modification: "</span> <span class="token operator">+</span> memberVar<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment">// 修改外部类的成员变量</span>
                memberVar <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>

                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"After modification: "</span> <span class="token operator">+</span> memberVar<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token comment">// 使用匿名内部类的实例</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Example</span> example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Example</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        example<span class="token punctuation">.</span><span class="token function">modifyMemberVar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<ol><li>代码中，匿名内部类实现了<code>Runnable</code>接口，其中的<code>run</code>方法中访问并修改了外部类<code>Example</code>的成员变量<code>memberVar</code>。</li><li>匿名内部类的作用域包括了它所在的方法，也就是<code>modifyMemberVar</code>方法。在这个方法中，您创建了两个不同的匿名内部类的实例（<code>r1</code>和<code>r2</code>），每个实例都有自己的<code>run</code>方法。因此，每个实例的<code>run</code>方法中的对<code>memberVar</code>的修改是在各自匿名内部类的作用域内完成的。</li><li>在<code>modifyMemberVar</code>方法中创建了两个线程，每个线程都启动了一个匿名内部类实例。这意味着两个线程可以并发地执行各自匿名内部类的<code>run</code>方法，但彼此之间的修改不会相互干扰。</li></ol> 
<p><strong>(2)外部类的局部变量：</strong></p> 
<p>匿名内部类可以访问外部类的成员变量和方法，但如果要访问外部方法中的局部变量，这个局部变量必须是 <strong>final</strong> 或者是 <strong>effectively final</strong>。这是因为匿名内部类的实例可能会在方法执行完毕之后仍然存在，而且对局部变量的引用是在匿名内部类中存储的。如果局部变量不是 <strong>final</strong> 或者 <strong>effectively final</strong>，那么在方法执行完毕后，外部局部变量的生命周期结束，但匿名内部类的实例可能仍然存在，这时如果访问这个局部变量就会出现问题。</p> 
<p>这也就是我们说的 <font color="Orange">变量捕获机制</font>,确切地说是对局部变量的捕获机制。</p> 
<p>变量捕获机制的关键是，编译器会生成一个匿名内部类的构造函数，并将外部的局部变量传递给这个构造函数，以确保匿名内部类在之后仍然能够访问这些变量。这种捕获方式确保了在匿名内部类中对外部局部变量的访问是安全的。</p> 
<p>示例代码如下：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Example</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">final</span> <span class="token keyword">int</span> localVar <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token comment">//局部变量</span>
<span class="token comment">//局部变量必须是 final 或者是 effectively final</span>
        <span class="token class-name">Runnable</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">//localVal = 1; 报错,无法修改</span>
                
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>localVar<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在匿名内部类中访问外部类的局部变量</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token comment">// 使用匿名内部类的实例</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>在外部类修改局部变量的值(报错)</li></ul> 
<img src="https://images2.imgbox.com/70/9f/9V9gYr3l_o.png" alt="image-20231211084543439"> 
<ul><li>在匿名内部类中修改局部变量的值(报错)</li></ul> 
<img src="https://images2.imgbox.com/31/2b/4RZ6XKFd_o.png" alt="image-20231211084615734"> 
<ul><li>不修改外部类局部变量的值,而是显式的让其被final修饰</li></ul> 
<img src="https://images2.imgbox.com/30/9b/73KhpGGs_o.png" alt="image-20231211084851143"> 
<ul><li>不修改外部类的局部变量的值,而是隐式的意味着事实上是final,也就是局部变量一旦被定义就不再被修改,那么在事实上就可以认为这个局部变量是一个final修饰的了,而且就是修改了,在匿名类中访问这样的被修改的外部类的局部变量是会报错的!!! 因为变量捕获机制的存在 !!!</li></ul> 
<img src="https://images2.imgbox.com/3c/c2/vHi7cU64_o.png" alt="image-20231211085216762"> 
<p>在上述代码中，<code>localVar</code> 是一个局部变量，因为匿名内部类 <code>Runnable</code> 中引用了这个局部变量，所以必须声明为 <code>final</code>。</p> 
<p><strong>(3) 所以，总结一下：</strong></p> 
<ul><li>外部类的成员变量可以在匿名内部类中被访问和修改。</li><li>外部类的局部变量必须要求是 <code>final</code> 的，或者是事实上是 <code>final</code> 的，才能在匿名内部类中被访问。(变量捕获机制)</li></ul> 
<h4><a id="font_color__blownfont_269"></a><font color="blown">可以包含字段和方法</font></h4> 
<p>贴代码</p> 
<pre><code class="prism language-java"><span class="token keyword">interface</span> <span class="token class-name">Greeting</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">void</span> <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AnonymousInnerClassExample</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 使用匿名内部类实现接口并包含字段和方法</span>
        <span class="token class-name">Greeting</span> greeting <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Greeting</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//字段</span>
            <span class="token keyword">private</span> <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">"Hello from anonymous inner class"</span><span class="token punctuation">;</span>

            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">sayGoodbye</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用匿名内部类中定义的方法</span>
            <span class="token punctuation">}</span>
			<span class="token comment">//方法</span>
            <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">sayGoodbye</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Goodbye from anonymous inner class"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token comment">// 调用实例方法</span>
        greeting<span class="token punctuation">.</span><span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<h4><a id="font_color__blownfont_303"></a><font color="blown">不可以包含静态成员</font></h4> 
<p>这是我的理解 :</p> 
<p>匿名内部类的本质是一个实例,这个实例可以用来重写父类中的实例方法,也可以用来实现接口中的抽象方法,也可以用来实现抽象类中的抽象方法,但是不可以声明静态成员变量或者定义静态方法,虽然可以重写父类的静态方法,但是重写的静态方法是通过实例调用的,这违背了java面向对象编程的理念.所以匿名内部类是一个非具名的实例,之所以叫做类是因为匿名内部类既完成了拓展原有类或者接口的目的又完成了实例的创建.</p> 
<p>( 匿名内部类是一个实例，而不是一个类。静态成员是属于类的，而匿名内部类没有类名，无法定义属于自己的静态成员。)</p> 
<p>贴代码 :</p> 
<pre><code class="prism language-java"><span class="token keyword">package</span> <span class="token namespace">src<span class="token punctuation">.</span>main</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AnonymousInnerClassExample</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 尝试在匿名内部类中定义静态成员（编译错误）</span>
        <span class="token class-name">Runnable</span> myRunnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 尝试定义静态成员变量（编译错误）</span>
            <span class="token comment">// static int staticVariable = 20;</span>

            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 尝试定义静态方法（编译错误）</span>
                <span class="token comment">// staticMethod();</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Inside Runnable"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token comment">// 调用匿名内部类中的 run 方法</span>
        myRunnable<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 尝试在外部类中定义静态方法（正常）</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">staticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Static method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>分析 : 在这个例子中，我们尝试在匿名内部类中定义静态成员变量和静态方法，但这会导致编译错误。匿名内部类无法包含静态成员，因为它本身是一个实例，而静态成员是属于类的，必须在类级别上声明。</p> 
<hr> 
<ul><li> <p>通过分析匿名内部类的结构和性质,我们已经解决了文章开头我们提出的疑问了,现在还剩下最后一个疑问,那就是 : <strong>匿名内部类是否有缺陷? 如果有缺陷是否有更好的替代方案 ?</strong> (答案是有缺陷,而且有更好的替代方案)</p> <p>匿名内部类是一种便捷但有局限性的编程方式。虽然它在短期、轻量级的情况下很方便，但它的一次性使用、可读性较差、不适合复杂继承关系、对外部变量的访问限制、不能包含静态成员以及可能导致生命周期延长等缺陷，使得在一些复杂或长期维护的场景中，更倾向于使用具名类或Lambda表达式等更灵活的替代方式。</p> </li></ul> 
<hr> 
<h3><a id="font_color__blue_355"></a><font color="blue">使用场景</font></h3> 
<p>在以下的场景中，匿名内部类的简洁语法和临时性的特性使得它成为一种方便的编码方式。然而，需要在使用时权衡其便利性和一些限制，选择适合当前情况的实现方式。</p> 
<ol><li> <p><strong>事件处理</strong></p> <p>在 GUI 编程中，匿名内部类常用于处理用户界面上的事件，比如按钮的点击事件。这简化了代码，避免了为每个事件都创建一个独立的类。</p> <pre><code class="prism language-java">button<span class="token punctuation">.</span><span class="token function">addActionListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ActionListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actionPerformed</span><span class="token punctuation">(</span><span class="token class-name">ActionEvent</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 处理按钮点击事件的逻辑</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> </li><li> <p><strong>线程创建</strong></p> <p>匿名内部类可以用于创建简单的线程对象，尤其在某个地方需要一次性的线程执行逻辑时。</p> <pre><code class="prism language-java"><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 线程执行的逻辑</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> </li><li> <p><strong>实现接口或抽象类</strong></p> <p>当只需要实现某个接口或继承某个抽象类的单一实例时，匿名内部类可以提供简洁的语法。</p> <pre><code class="prism language-java"><span class="token class-name">SomeInterface</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SomeInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 实现接口的逻辑</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> </li><li> <p><strong>测试和调试</strong></p> <p>在单元测试或调试时，有时需要临时性地实现某个接口或者继承某个类，匿名内部类能够方便地提供这种快速的实现。</p> <pre><code class="prism language-java"><span class="token class-name">TestingTool</span><span class="token punctuation">.</span><span class="token function">runTest</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TestInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">runTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 测试逻辑</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> </li><li> <p><strong>简化工厂方法</strong></p> <p>在工厂方法中，如果只需要创建一个实例，匿名内部类可以用于快速创建。</p> <pre><code class="prism language-java"><span class="token class-name">Factory</span><span class="token punctuation">.</span><span class="token function">createInstance</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SomeInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 实现接口的逻辑</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> </li><li> <p><strong>回调函数</strong></p> <p>在某些设计模式或异步编程中，匿名内部类可以作为回调函数，用于定义异步操作完成后的回调逻辑。</p> <pre><code class="prism language-java">asyncOperation<span class="token punctuation">.</span><span class="token function">doAsync</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 异步操作完成后的回调逻辑</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> </li></ol> 
<hr> 
<p>通过上述的分析, 相信大家应该对Java中的匿名内部类有了很深刻的理解了,如果文章中有什么地方写的不对,或者理解有误,欢迎大家在评论区留言, 教学相长 ~</p> 
<p>如果觉得这篇文章有帮助到您,您的三连是对我最大的支持 !</p> 
<p><img src="https://images2.imgbox.com/7d/9a/MXz6hCk7_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a630144295beb5607d02431ef50f3279/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">宿舍管理系统的设计与实现 （含源码&#43;sql&#43;视频导入教程）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/21ccbe82db6a5dd67376d7531d36ae30/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据结构】栈和队列超详解！(Stack &amp;&amp; Queue)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>