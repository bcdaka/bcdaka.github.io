<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构——循环队列详解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/0ededc78df07ee85c5ab8a7d546d2eaa/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构——循环队列详解">
  <meta property="og:description" content="目录
一、循环队列的定义
二、 循环队列的基本操作
三、循环队列的实现 1、循环队列的定义
2、循环队列的初始化 3、循环队列出队 4、循环队列入队 5、队列判空
6、 队列判满
7、取队头元素
8、输出队列 9、求队列长度 四、完整代码 五、小结 六、参考文献
一、循环队列的定义 定义：队列主要有顺序队列，循环队列，双端队列，优先队列。而当中循环队列是一种线性数据结构。它也被称为“环形缓冲器”。它只允许在一端进行插入操作，即队尾（rear），而在另一端进行删除操作，即队头 (front)，其操作表现基于FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。向队列中插入新的数据元素称为入队，新入队的元素就成为了队列的队尾元素。
特点：
循环队列允许元素在队尾插入，在队头删除，同时遵循先进先出原则。由于循环队列是基于数组实现的，所以它的访问速度很快，特别是在移动元素时。如果需要大量添加和删除元素，循环队列比链表更有效率，因为它不需要频繁地移动指针来访问元素。不支持随机访问元素，因此不能像数组那样直接访问特定位置的元素。 二、 循环队列的基本操作 1、初始化：这是创建一个空的顺序队列，需要设定队首指针front和队尾指针rear都指向同一个位置，一般初始都设置为0，即队列为空。
2、元素入队：也被称为插入操作，是将一个新元素添加到队列尾部的操作。
3、元素出队：也被称为删除操作，是将队列头部的元素移除的操作。
4、求队列长度：可以通过计算队尾指针和队首指针之差的值再加1来获取当前队列的长度。
5、判断是否为空：通过检查队首指针front和队尾指针rear是否相等来判断队列是否为空。
6、判断是否为满：当队尾指针指向数组的最后一个位置时，下一个要插入的位置就是队头指针。
7、取队头：头元素就是队列中的第一个元素，可以通过返回队首指针front的值来获取。
8、输出队列：将队列中元素通过while语句循环语句打印出来
三、循环队列的实现 1、循环队列的定义
用一个数组来存储队列中的元素，用front作为队头指针，指向队列的第一个元素，用rear作为队尾指针，即指向队列最后一个元素的下一个位置.
#define MAXSIZE 4 typedef int DataType; typedef struct { DataType data[MAXSIZE]; int front; int rear; }CirclesQueue; 2、循环队列的初始化 循环队列的初始化只需要将队头指针（front）和队尾指针（rear）都初始化为0.
/*循环队列初始化*/ int init(CirclesQueue *Q) { Q-&gt;front = Q-&gt;rear = 0; return 0; } 3、循环队列出队 出队前判断队列是否为空，如果为空，返回100002错误信息，如果队列不为空，将队列的队头指针向前移动一位，即将队头指针加1并对MAXSIZE取模，确保指针在数组范围内循环移动，当到达数组末尾时，会回到数组的开头。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-11-07T09:16:18+08:00">
    <meta property="article:modified_time" content="2023-11-07T09:16:18+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构——循环队列详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>目录</strong></p> 
<p style="margin-left:80px;"><a href="#%E4%B8%80%E3%80%81%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">一、循环队列的定义</a></p> 
<p style="margin-left:80px;"><a href="#%E4%BA%8C%E3%80%81%20%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C" rel="nofollow">二、 循环队列的基本操作</a></p> 
<p style="margin-left:80px;"><a href="#%E4%B8%89%E3%80%81%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%C2%A0" rel="nofollow">三、循环队列的实现 </a></p> 
<p style="margin-left:120px;"><a href="#1%E3%80%81%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">1、循环队列的定义</a></p> 
<p style="margin-left:120px;"><a href="#2%E3%80%81%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%C2%A0" rel="nofollow">2、循环队列的初始化 </a></p> 
<p style="margin-left:120px;"><a href="#3%E3%80%81%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E5%87%BA%E9%98%9F%C2%A0" rel="nofollow">3、循环队列出队 </a></p> 
<p style="margin-left:120px;"><a href="#4%E3%80%81%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E5%85%A5%E9%98%9F%C2%A0" rel="nofollow">4、循环队列入队 </a></p> 
<p style="margin-left:120px;"><a href="#5%E3%80%81%E9%98%9F%E5%88%97%E5%88%A4%E7%A9%BA" rel="nofollow">5、队列判空</a></p> 
<p style="margin-left:120px;"><a href="#6%E3%80%81%20%E9%98%9F%E5%88%97%E5%88%A4%E6%BB%A1" rel="nofollow">6、 队列判满</a></p> 
<p style="margin-left:120px;"><a href="#7%E3%80%81%E5%8F%96%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0" rel="nofollow">7、取队头元素</a></p> 
<p style="margin-left:120px;"><a href="#8%E3%80%81%E8%BE%93%E5%87%BA%E9%98%9F%E5%88%97%C2%A0" rel="nofollow">8、输出队列 </a></p> 
<p style="margin-left:120px;"><a href="#9%E3%80%81%E6%B1%82%E9%98%9F%E5%88%97%E9%95%BF%E5%BA%A6%C2%A0" rel="nofollow">9、求队列长度 </a></p> 
<p style="margin-left:80px;"><a href="#%E5%9B%9B%E3%80%81%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%C2%A0" rel="nofollow">四、完整代码 </a></p> 
<p style="margin-left:80px;"><a href="#%E4%BA%94%E3%80%81%E5%B0%8F%E7%BB%93%C2%A0" rel="nofollow">五、小结 </a></p> 
<p style="margin-left:80px;"><a href="#%C2%A0%E5%85%AD%E3%80%81%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE" rel="nofollow">六、参考文献</a></p> 
<hr> 
<h4>一、循环队列的定义</h4> 
<p><strong>定义：</strong>队列主要有顺序队列，循环队列，双端队列，优先队列。而当中<strong>循环队列</strong>是一种线性数据结构。它也被称为“环形缓冲器”。它只允许在一端进行插入操作，即队尾（rear），而在另一端进行删除操作，即队头 (front)，其操作表现基于FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。向队列中插入新的数据元素称为入队，新入队的元素就成为了队列的队尾元素。</p> 
<p><strong>特点：</strong></p> 
<blockquote> 
 <ol><li>循环队列允许元素在队尾插入，在队头删除，同时遵循<strong>先进先出原</strong>则。</li><li>由于循环队列是基于数组实现的，所以它的访问速度很快，特别是在移动元素时。</li><li>如果需要大量添加和删除元素，循环队列比链表更有效率，因为它不需要频繁地移动指针来访问元素。</li><li>不支持随机访问元素，因此不能像数组那样直接访问特定位置的元素。</li></ol> 
</blockquote> 
<p><img src="https://images2.imgbox.com/c0/d4/hsTqFPWN_o.png" alt="8449ee3261ba42d49c11e8f606c23a5c.png"></p> 
<h4>二、 循环队列的基本操作</h4> 
<blockquote> 
 <p>1、初始化：这是创建一个空的顺序队列，需要设定队首指针front和队尾指针rear都指向同一个位置，一般初始都设置为0，即队列为空。</p> 
 <p>2、元素入队：也被称为插入操作，是将一个新元素添加到队列尾部的操作。</p> 
 <p>3、元素出队：也被称为删除操作，是将队列头部的元素移除的操作。</p> 
 <p>4、求队列长度：可以通过计算队尾指针和队首指针之差的值再加1来获取当前队列的长度。</p> 
 <p>5、判断是否为空：通过检查队首指针front和队尾指针rear是否相等来判断队列是否为空。</p> 
 <p>6、判断是否为满：当队尾指针指向数组的最后一个位置时，下一个要插入的位置就是队头指针。</p> 
 <p>7、取队头：头元素就是队列中的第一个元素，可以通过返回队首指针front的值来获取。</p> 
 <p>8、输出队列：将队列中元素通过while语句循环语句打印出来</p> 
</blockquote> 
<h4>三、循环队列的实现 </h4> 
<p>1、循环队列的定义</p> 
<blockquote> 
 <p>用一个数组来存储队列中的元素，用front作为队头指针，指向队列的第一个元素，用rear作为队尾指针，即指向队列最后一个元素的下一个位置.</p> 
</blockquote> 
<pre><code class="language-cpp">#define MAXSIZE 4

typedef int DataType;

typedef struct
{
	DataType data[MAXSIZE];
	int front;
	int rear;
}CirclesQueue;</code></pre> 
<p>2、循环队列的初始化 </p> 
<blockquote> 
 <p>循环队列的初始化只需要将队头指针（front）和队尾指针（rear）都初始化为0.</p> 
</blockquote> 
<pre><code class="language-cpp">/*循环队列初始化*/
int init(CirclesQueue *Q)
{
	Q-&gt;front = Q-&gt;rear = 0;
	return 0;
}

</code></pre> 
<p>3、循环队列出队 </p> 
<blockquote> 
 <p>出队前判断队列是否为空，如果为空，返回100002错误信息，如果队列不为空，将队列的队头指针向前移动一位，即将队头指针加1并对MAXSIZE取模，确保指针在数组范围内循环移动，当到达数组末尾时，会回到数组的开头。</p> 
</blockquote> 
<pre><code class="language-cpp">/*出队*/
int dequeue(CirclesQueue *Q, DataType *x)
{
	if(isempty(Q))
	{
		printf("队列为空！100002\n");
		return 100002;
	}
	Q-&gt;front = (Q-&gt;front+1) % MAXSIZE;
	*x = Q-&gt;data[Q-&gt;front];
	return 0;
}</code></pre> 
<p>4、循环队列入队 </p> 
<blockquote> 
 <p>入队前需要判断队列是否已经满了，如果队列为满，则不能入队。反之，则将队列的队头向前移动一位，确保指针在数组范围内能够循环移动。具体来说，就是将当前队头指针的值加1，然后对队列的最大容量（MAXSIZE）取模来实现。</p> 
</blockquote> 
<pre><code class="language-cpp">/*入队*/
int enqueue(CirclesQueue *Q, DataType x)
{
	if(isfull(Q))
	{
		printf("队列已满！100001\n");
		return 100001;
	}

	Q-&gt;rear = (Q-&gt;rear+1) % MAXSIZE;
	Q-&gt;data[Q-&gt;rear] = x;
	return 0;
}</code></pre> 
<p>5、队列判空</p> 
<blockquote> 
 <p>判断循环队列是否为空通过比较队头指针和队尾指针是否相等来判断，如果它们相等，说明队列中没有元素，反之则存在元素。 </p> 
</blockquote> 
<pre><code class="language-cpp">/*队空*/
int isempty(CirclesQueue *Q)
{
	return (Q-&gt;front == Q-&gt;rear) ? 1 : 0;
}</code></pre> 
<p>6、 队列判满</p> 
<blockquote> 
 <p>判断循环队列是否为满可以让队列的rear指针加1之后对MAXSIZE取模结果等于front指针，这时表明队列已满，反之则未满。</p> 
</blockquote> 
<pre><code class="language-cpp">/*队满？*/
int isfull(CirclesQueue *Q)
{
	return (Q-&gt;rear+1)%MAXSIZE == Q-&gt;front ? 1 : 0;
}

</code></pre> 
<p>7、取队头元素</p> 
<blockquote> 
 <p>想要获取队头元素，首先需要判断队列是否为空，如果为空，返回错误信息。不为空时，可以通过计算front加1后对MAXSIZE取模获取队首元素的位置。</p> 
</blockquote> 
<pre><code class="language-cpp">/*取队头元素*/
int QueueFront(CirclesQueue *Q,DataType *x)
{
	if(isempty(Q))
	{
		printf("队列为空！100002\n");
		return 100002;
	}
	*x = Q-&gt;data[(Q-&gt;front + 1) % MAXSIZE];
	return 0;
</code></pre> 
<p>8、输出队列 </p> 
<blockquote> 
 <p>输出队列前需要先判断队列是否为空，如果为空则输出队列为空，不为空时，将队头指针的值赋给<code>i</code>，并对最大容量<code>MAXSIZE</code>取模，再通过do-while循环来遍历队列中的元素，循环的内部通过计算<code>(i + 1 % MAXSIZE)</code>来获取下一个元素的索引，并输出打印当前元素，同时更新<code>i</code>的值，使其加1并对<code>MAXSIZE</code>取模，以便继续遍历队列。</p> 
</blockquote> 
<pre><code class="language-cpp">/*输出队列*/
void PrintQueue(CirclesQueue *Q){
	int i;
	if (isempty(Q))
	{
		printf("队列为空！\n");
		return;
	}
	i=(Q-&gt;front)%MAXSIZE;    //确保i的值在0到MAXSIZE-1之间，以便在后续操作中作为数组索引使用
	do
	{
		printf("%d、",Q-&gt;data[(i + 1 % MAXSIZE)]);
		i=(i+1)%MAXSIZE;
	}while(i!=Q-&gt;rear);
}</code></pre> 
<p>9、求队列长度 </p> 
<blockquote> 
 <p>求循环队列的长度可以通过计算队列的尾指针（rear）和头指针（front）之间的差值，加上最大容量(MAXSIZE)，然后对最大容量取模，得到队列的实际长度。最后，将计算结果存储在指针x所指向的位置，并返回0表示成功。</p> 
</blockquote> 
<pre><code class="language-cpp">*获取队列长度*/ 
int getLength(CirclesQueue *Q,DataType *x) {  
  *x= (Q-&gt;rear - Q-&gt;front + MAXSIZE) % MAXSIZE; 
  return 0;
}</code></pre> 
<h4>四、完整代码 </h4> 
<p><strong>1、main.c</strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include "CirclesQueue.h"


int main(int argc, char* argv[])
{
	CirclesQueue Q;
	DataType x;
	int cmd;
	char yn;


	do
	{	
		printf("-----------循环队列演示-----------\n");
		printf(" 1. 初始化\n");
		printf(" 2. 入队\n");
		printf(" 3. 出队\n");
		printf(" 4. 队空？\n");
		printf(" 5. 队满\n");
		printf(" 6.取队头\n");
		printf(" 7.输出队列\n");
		printf(" 8.取长度\n");
		printf(" 9.帮助\n");
		printf(" 0. 退出\n");
		printf(" 请选择（0~6）：");
		scanf("%d",&amp;cmd);
		switch(cmd)
		{
		case 1:
			init(&amp;Q);
			printf("队列已初始化！\n");
			break;
		case 2:
			printf("请输入要入队的元素x=");
			scanf("%d", &amp;x);
			if(!enqueue(&amp;Q,x))
			{
				printf("元素x=%d已入队\n", x);
			}
			break;
		case 3:
			printf("确定要出队（出队会将删除对首元素, y or n, n）？");
			flushall();
			scanf("%c", &amp;yn);

			if(yn == 'y' || yn == 'Y')
			{
				if(!dequeue(&amp;Q,&amp;x))
				{
					printf("队首元素【%d】已出队！\n", x);
				}
			}
			break;
		case 4:
			if(isempty(&amp;Q))
			{
				printf("队列为空！\n");
			}
			else{
				printf("队列不为空!\n");
			}
			break;
		case 5:
			if(isfull(&amp;Q))
			{
				printf("队列为满！\n");
			}
			else{
				printf("队列未满!\n");
			}
			
			break;
		case 6:
			if(!QueueFront(&amp;Q,&amp;x))
			{
				printf("队首元素为【%d】！\n", x);
			}
			break;
		case 7:
			PrintQueue(&amp;Q);
			printf("\n");
			break;
		case 8:
			if(!getLength(&amp;Q,&amp;x))
			{
				printf("队列长度为【%d】！\n", x);
			}
			break;
		case 9:
			printf("本程序由zzb设计开发,实现了循环队列的入队、出队、取队头等操作\n");

		}

	}while(cmd!=0);


	return 0;
}</code></pre> 
<p><strong>2、 CirclesQueue.c</strong></p> 
<pre><code class="language-cpp">/*
	CirclesQueue.c
*/
#include "CirclesQueue.h"

/*循环队列初始化*/
int init(CirclesQueue *Q)
{
	Q-&gt;front = Q-&gt;rear = 0;
	return 0;
}


/*入队*/
int enqueue(CirclesQueue *Q, DataType x)
{
	if(isfull(Q))
	{
		printf("队列已满！100001\n");
		return 100001;
	}

	Q-&gt;rear = (Q-&gt;rear+1) % MAXSIZE;
	Q-&gt;data[Q-&gt;rear] = x;
	return 0;
}

/*队满？*/
int isfull(CirclesQueue *Q)
{
	return (Q-&gt;rear+1)%MAXSIZE == Q-&gt;front ? 1 : 0;
}


/*出队*/
int dequeue(CirclesQueue *Q, DataType *x)
{
	if(isempty(Q))
	{
		printf("队列为空！100002\n");
		return 100002;
	}
	Q-&gt;front = (Q-&gt;front+1) % MAXSIZE;
	*x = Q-&gt;data[Q-&gt;front];
	return 0;
}

/*队空*/
int isempty(CirclesQueue *Q)
{
	return (Q-&gt;front == Q-&gt;rear) ? 1 : 0;
}
/*取队头元素*/
int QueueFront(CirclesQueue *Q,DataType *x)
{
	if(isempty(Q))
	{
		printf("队列为空！100002\n");
		return 100002;
	}
	*x = Q-&gt;data[(Q-&gt;front + 1) % MAXSIZE];
	return 0;


}
/*输出队列*/
void PrintQueue(CirclesQueue *Q){
	int i;
	if (isempty(Q))
	{
		printf("队列为空！\n");
		return;
	}
	i=(Q-&gt;front)%MAXSIZE;
	do
	{
		printf("%d、",Q-&gt;data[(i + 1 % MAXSIZE)]);
		i=(i+1)%MAXSIZE;
	}while(i!=Q-&gt;rear);
}
/*获取队列长度*/ 
int getLength(CirclesQueue *Q,DataType *x) {  
  *x= (Q-&gt;rear - Q-&gt;front + MAXSIZE) % MAXSIZE; 
  return 0;
}


</code></pre> 
<p><strong>3、 CirclesQueue.h</strong></p> 
<pre><code class="language-cpp">/*
	CirclesQueue.h
	循环队列
*/

#define MAXSIZE 4

typedef int DataType;

typedef struct
{
	DataType data[MAXSIZE];
	int front;
	int rear;
}CirclesQueue;

/*循环队列初始化*/
int init(CirclesQueue *Q);

/*入队*/
int enqueue(CirclesQueue *Q, DataType x);

/*队满？*/
int isfull(CirclesQueue *Q);

/*出队*/
int dequeue(CirclesQueue *Q, DataType *x);

/*队空*/
int isempty(CirclesQueue *Q);
/*取队头元素*/
int QueueFront(CirclesQueue *Q,DataType *x);
/*输出队列*/
void PrintQueue(CirclesQueue *Q);
/*队列长度*/
int getLength(CirclesQueue *Q,DataType *x);
</code></pre> 
<p><strong>4、运行截图 </strong></p> 
<p><strong><img src="https://images2.imgbox.com/7c/3b/CRbS4UMA_o.png" alt="0c719442831848f38cec4cef022e43a7.png"></strong></p> 
<h4>五、小结 </h4> 
<blockquote> 
 <p>1、<strong>循环队列</strong>是一种线性数据结构。它也被称为“环形缓冲器”。它只允许在一端进行插入操作，即队尾（rear），而在另一端进行删除操作，即队头 (front)，其操作表现基于FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。</p> 
 <p>2、循环队列的应用范围非常广泛，比如线程池任务调度、消息队列系统、缓冲区管理、广度优先搜索算法等应用场景。</p> 
 <p>3、队列满时，无法再进行插入操作；当队列空时，无法再进行删除操作。队列的大小是固定的，一旦创建后不能改变。</p> 
</blockquote> 
<h4><strong> 六、参考文献</strong></h4> 
<p> </p> 
<p>《数据结构》(C语言版）李刚，刘万辉.北京：高等教育出版社 ，2017.   </p> 
<p>《C语言程序设计》(第四版）谭浩强. 北京：清华大学出版社，2014.</p> 
<p>  CSDN 数据结构-----<a class="link-info" href="https://so.csdn.net/so/search?spm=1001.2014.3001.4498&amp;q=%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97&amp;t=&amp;u=" title="循环队列">循环队列</a></p> 
<p> </p> 
<p> </p> 
<p> </p> 
<h4> </h4> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/06ac066ae64b4a957fee19329e2ca5a5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">浏览器自动播放音视频-前端实现方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/166717b7a00296e16d4bbf7f49832e45/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AI短视频制作一本通：文本生成视频、图片生成视频、视频生成视频</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>