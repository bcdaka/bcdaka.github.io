<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spark on YARN 部署搭建详细图文教程 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/7bcafa700a327ad739858a0bb1fe2f0f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Spark on YARN 部署搭建详细图文教程">
  <meta property="og:description" content="目录
一、引言 二、SparkOnYarn 本质
2.1 Spark On Yarn 的本质?
2.2 Spark On Yarn 需要啥?
三、配置 spark on yarn 环境
3.1 spark-env.sh 3.2 连接到 YARN 中
3.2.1 bin/pyspark
3.2.2 bin/spark-shell
3.2.3 bin/spark-submit (PI)
四、部署模式 DeployMode 4.1 Cluster 模式
4.2 Client 模式
4.3 两种模式的区别 4.4 测试 4.4.1 client 模式测试 4.4.2 cluster 模式测试 4.5 两种模式总结 五、两种模式详细流程 5.1 Client 模式 5.2 Cluster 模式 一、引言 按照前面环境部署中所了解到的，如果我们想要一个稳定的生产 Spark 环境，那么最优的选择就是构建 HA StandAlone 集群。
不过在企业中，服务器的资源总是紧张的，许多企业不管做什么业务，都基本上会有 Hadoop 集群，也就是会有 YARN 集群。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-09-15T15:21:47+08:00">
    <meta property="article:modified_time" content="2023-09-15T15:21:47+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spark on YARN 部署搭建详细图文教程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%BC%95%E8%A8%80%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%BC%95%E8%A8%80%C2%A0" rel="nofollow">一、引言 </a></p> 
<p id="%E4%BA%8C%E3%80%81SparkOnYarn%20%E6%9C%AC%E8%B4%A8-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81SparkOnYarn%20%E6%9C%AC%E8%B4%A8" rel="nofollow">二、SparkOnYarn 本质</a></p> 
<p id="2.1%20Spark%20On%20Yarn%20%E7%9A%84%E6%9C%AC%E8%B4%A8%3F-toc" style="margin-left:40px;"><a href="#2.1%20Spark%20On%20Yarn%20%E7%9A%84%E6%9C%AC%E8%B4%A8%3F" rel="nofollow">2.1 Spark On Yarn 的本质?</a></p> 
<p id="2.2%20Spark%20On%20Yarn%20%E9%9C%80%E8%A6%81%E5%95%A5%3F-toc" style="margin-left:40px;"><a href="#2.2%20Spark%20On%20Yarn%20%E9%9C%80%E8%A6%81%E5%95%A5%3F" rel="nofollow">2.2 Spark On Yarn 需要啥?</a></p> 
<p id="%E4%B8%89%E3%80%81%E9%85%8D%E7%BD%AE%20spark%20on%20yarn%20%E7%8E%AF%E5%A2%83-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E9%85%8D%E7%BD%AE%20spark%20on%20yarn%20%E7%8E%AF%E5%A2%83" rel="nofollow">三、配置 spark on yarn 环境</a></p> 
<p id="3.1%C2%A0spark-env.sh%C2%A0-toc" style="margin-left:40px;"><a href="#3.1%C2%A0spark-env.sh%C2%A0" rel="nofollow">3.1 spark-env.sh </a></p> 
<p id="3.2%C2%A0%E8%BF%9E%E6%8E%A5%E5%88%B0%20YARN%20%E4%B8%AD-toc" style="margin-left:40px;"><a href="#3.2%C2%A0%E8%BF%9E%E6%8E%A5%E5%88%B0%20YARN%20%E4%B8%AD" rel="nofollow">3.2 连接到 YARN 中</a></p> 
<p id="3.2.1%20bin%2Fpyspark-toc" style="margin-left:80px;"><a href="#3.2.1%20bin%2Fpyspark" rel="nofollow">3.2.1 bin/pyspark</a></p> 
<p id="3.2.2%C2%A0bin%2Fspark-shell-toc" style="margin-left:80px;"><a href="#3.2.2%C2%A0bin%2Fspark-shell" rel="nofollow">3.2.2 bin/spark-shell</a></p> 
<p id="3.2.3%20bin%2Fspark-submit%20(PI)-toc" style="margin-left:80px;"><a href="#3.2.3%20bin%2Fspark-submit%20%28PI%29" rel="nofollow">3.2.3 bin/spark-submit (PI)</a></p> 
<p id="%E5%9B%9B%E3%80%81%E9%83%A8%E7%BD%B2%E6%A8%A1%E5%BC%8F%20DeployMode%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E9%83%A8%E7%BD%B2%E6%A8%A1%E5%BC%8F%20DeployMode%C2%A0" rel="nofollow">四、部署模式 DeployMode </a></p> 
<p id="4.1%C2%A0Cluster%20%E6%A8%A1%E5%BC%8F-toc" style="margin-left:40px;"><a href="#4.1%C2%A0Cluster%20%E6%A8%A1%E5%BC%8F" rel="nofollow">4.1 Cluster 模式</a></p> 
<p id="4.2%C2%A0Client%20%E6%A8%A1%E5%BC%8F-toc" style="margin-left:40px;"><a href="#4.2%C2%A0Client%20%E6%A8%A1%E5%BC%8F" rel="nofollow">4.2 Client 模式</a></p> 
<p id="4.3%C2%A0%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%C2%A0-toc" style="margin-left:40px;"><a href="#4.3%C2%A0%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%C2%A0" rel="nofollow">4.3 两种模式的区别 </a></p> 
<p id="4.4%20%E6%B5%8B%E8%AF%95%C2%A0-toc" style="margin-left:40px;"><a href="#4.4%20%E6%B5%8B%E8%AF%95%C2%A0" rel="nofollow">4.4 测试 </a></p> 
<p id="4.4.1%20client%C2%A0%E6%A8%A1%E5%BC%8F%E6%B5%8B%E8%AF%95%20%C2%A0-toc" style="margin-left:80px;"><a href="#4.4.1%20client%C2%A0%E6%A8%A1%E5%BC%8F%E6%B5%8B%E8%AF%95%20%C2%A0" rel="nofollow">4.4.1 client 模式测试  </a></p> 
<p id="4.4.2%20cluster%20%E6%A8%A1%E5%BC%8F%E6%B5%8B%E8%AF%95%20%C2%A0-toc" style="margin-left:80px;"><a href="#4.4.2%20cluster%20%E6%A8%A1%E5%BC%8F%E6%B5%8B%E8%AF%95%20%C2%A0" rel="nofollow">4.4.2 cluster 模式测试  </a></p> 
<p id="4.5%C2%A0%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%C2%A0-toc" style="margin-left:40px;"><a href="#4.5%C2%A0%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%C2%A0" rel="nofollow">4.5 两种模式总结 </a></p> 
<p id="%E4%BA%94%E3%80%81%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B%C2%A0" rel="nofollow">五、两种模式详细流程 </a></p> 
<p id="5.1%C2%A0Client%20%E6%A8%A1%E5%BC%8F%C2%A0-toc" style="margin-left:40px;"><a href="#5.1%C2%A0Client%20%E6%A8%A1%E5%BC%8F%C2%A0" rel="nofollow">5.1 Client 模式 </a></p> 
<p id="5.2%C2%A0Cluster%20%E6%A8%A1%E5%BC%8F%C2%A0-toc" style="margin-left:40px;"><a href="#5.2%C2%A0Cluster%20%E6%A8%A1%E5%BC%8F%C2%A0" rel="nofollow">5.2 Cluster 模式 </a></p> 
<hr id="hr-toc"> 
<p></p> 
<p> </p> 
<h2 id="%E4%B8%80%E3%80%81%E5%BC%95%E8%A8%80%C2%A0">一、引言 </h2> 
<p>        按照前面环境部署中所了解到的，如果我们想要一个稳定的生产 Spark 环境，那么最优的选择就是构建 HA StandAlone 集群。</p> 
<p>        不过在企业中，服务器的资源总是紧张的，许多企业不管做什么业务，都基本上会有 Hadoop 集群，也就是会有 YARN 集群。</p> 
<p>        对于企业来说，在已有 YARN 集群的前提下在单独准备 Spark StandAlone 集群，对资源的利用就不高，所以在企业中，多数场景下，会将 Spark 运行到 YARN 集群中。</p> 
<p>        YARN 本身是一个资源调度框架，负责对运行在内部的计算框架进行资源调度管理.。作为典型的计算框架，Spark 本身也是直接运行在 YARN 中，并接受 YARN 的调度的。所以，对于 Spark On YARN 无需部署 Spark 集群，只要找一台服务器，充当 Spark 的客户端，即可提交任务到 YARN 集群中运行。</p> 
<h2 id="%E4%BA%8C%E3%80%81SparkOnYarn%20%E6%9C%AC%E8%B4%A8">二、SparkOnYarn 本质</h2> 
<h3 id="2.1%20Spark%20On%20Yarn%20%E7%9A%84%E6%9C%AC%E8%B4%A8%3F">2.1 Spark On Yarn 的本质?</h3> 
<ul><li>Master 角色由 YARN 的 ResourceManager 担任。</li><li>Worker 角色由 YARN 的 NodeManager 担任。</li><li>Driver 角色运行在 YARN 容器内或提交任务的客户端进程中。</li><li>真正干活的 Executor 运行在 YARN 提供的容器内。</li></ul> 
<h3 id="2.2%20Spark%20On%20Yarn%20%E9%9C%80%E8%A6%81%E5%95%A5%3F">2.2 Spark On Yarn 需要啥?</h3> 
<ol><li>需要 Yarn 集群：已经安装了</li><li>需要 Spark 客户端工具，比如 spark-submit，可以将 Spark 程序提交到 YARN 中</li><li>需要被提交的代码程序：如 spark/examples/src/main/python/pi.py 此示例程序，或我们后续自己开发的 Spark 任务</li></ol> 
<p><img alt="" height="615" src="https://images2.imgbox.com/11/72/mzRpeOtv_o.png" width="1200"></p> 
<h2 id="%E4%B8%89%E3%80%81%E9%85%8D%E7%BD%AE%20spark%20on%20yarn%20%E7%8E%AF%E5%A2%83">三、配置 spark on yarn 环境</h2> 
<h3 id="3.1%C2%A0spark-env.sh%C2%A0">3.1 spark-env.sh </h3> 
<p>具体安装 spark 步骤：<a href="https://blog.csdn.net/weixin_46560589/article/details/132857521" title="Spark-3.2.4 高可用集群安装部署详细图文教程_Stars.Sky的博客-CSDN博客">Spark-3.2.4 高可用集群安装部署详细图文教程_Stars.Sky的博客-CSDN博客</a> </p> 
<p>        确保：HADOOP_CONF_DIR、YARN_CONF_DIR 在 spark-env.sh 以及环境变量配置文件中即可（其他的配置文件都不需要修改，切 spark 和 YARN 在同一机器上）：</p> 
<pre><code class="hljs">(base) [root@hadoop01 /bigdata/spark-3.2.4]# vim conf/spark-env.sh 
## HADOOP软件配置文件目录，读取HDFS上文件和运行YARN集群
HADOOP_CONF_DIR=/bigdata/hadoop/server/hadoop-3.2.4/etc/hadoop/
YARN_CONF_DIR=/bigdata/hadoop/server/hadoop-3.2.4/etc/hadoop/</code></pre> 
<h3 id="3.2%C2%A0%E8%BF%9E%E6%8E%A5%E5%88%B0%20YARN%20%E4%B8%AD">3.2 连接到 YARN 中</h3> 
<h4 id="3.2.1%20bin%2Fpyspark">3.2.1 bin/pyspark</h4> 
<pre><code class="hljs">bin/pyspark --master yarn --deploy-mode client|cluster

# --deploy-mode 选项是指定部署模式，默认是客户端模式
# client 就是客户端模式
# cluster 就是集群模式
# --deploy-mode 仅可以用在 YARN 模式下</code></pre> 
<p><img alt="" height="384" src="https://images2.imgbox.com/8b/76/jadPigua_o.png" width="1200">注意：交互式环境 pyspark  和 spark-shell  无法运行 cluster 模式。</p> 
<h4 id="3.2.2%C2%A0bin%2Fspark-shell">3.2.2 bin/spark-shell</h4> 
<pre><code class="hljs">bin/spark-shell --master yarn --deploy-mode client|cluster</code></pre> 
<p>注意：交互式环境 pyspark  和 spark-shell  无法运行 cluster 模式。 </p> 
<h4 id="3.2.3%20bin%2Fspark-submit%20(PI)">3.2.3 bin/spark-submit (PI)</h4> 
<pre><code class="hljs">bin/spark-submit --master yarn --deploy-mode client|cluster /xxx/xxx/xxx.py 参数</code></pre> 
<h2 id="%E5%9B%9B%E3%80%81%E9%83%A8%E7%BD%B2%E6%A8%A1%E5%BC%8F%20DeployMode%C2%A0">四、部署模式 DeployMode </h2> 
<p>        Spark On YARN 是有两种运行模式的，一种是 Cluster 模式，一种是 Client 模式。这两种模式的区别就是 Driver 运行的位置：</p> 
<ul><li>Cluster 模式即：Driver 运行在 YARN 容器内部，和 ApplicationMaster 在同一个容器内。</li><li>Client 模式即：Driver 运行在客户端进程中，比如 Driver 运行在 spark-submit 程序的进程中。</li></ul> 
<h3 id="4.1%C2%A0Cluster%20%E6%A8%A1%E5%BC%8F">4.1 Cluster 模式</h3> 
<p>如图，此为 Cluster 模式 Driver运行在容器内部：</p> 
<p><img alt="" height="658" src="https://images2.imgbox.com/9e/b2/fKBviKrd_o.png" width="1200"></p> 
<h3 id="4.2%C2%A0Client%20%E6%A8%A1%E5%BC%8F">4.2 Client 模式</h3> 
<p>如图，此为Client 模式 Driver 运行在客户端程序进程中(以 spark-submit 为例) ：</p> 
<p><img alt="" height="716" src="https://images2.imgbox.com/3f/cd/k9pQaGVI_o.png" width="1200"></p> 
<h3 id="4.3%C2%A0%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%C2%A0">4.3 两种模式的区别 </h3> 
<p><img alt="" height="834" src="https://images2.imgbox.com/7a/7d/10zgbxA7_o.png" width="1200"></p> 
<h3 id="4.4%20%E6%B5%8B%E8%AF%95%C2%A0">4.4 测试 </h3> 
<h4 id="4.4.1%20client%C2%A0%E6%A8%A1%E5%BC%8F%E6%B5%8B%E8%AF%95%20%C2%A0">4.4.1 client 模式测试  </h4> 
<p>假设运行圆周率 PI 程序，采用 client 模式，命令如下： </p> 
<pre><code class="hljs">(base) [root@hadoop01 /bigdata/spark-3.2.4]# bin/spark-submit --master yarn --deploy-mode client --driver-memory 512m --executor-memory 512m --num-executors 2 --total-executor-cores 2 /bigdata/spark-3.2.4/examples/src/main/python/pi.py 10</code></pre> 
<ul><li> <p><code>bin/spark-submit</code>: 这是用于提交 Spark 任务的脚本。</p> </li><li> <p><code>--master yarn</code>: 指定 Spark 集群管理器为 YARN。</p> </li><li> <p><code>--deploy-mode client</code>: 这意味着 Spark 任务的 driver 程序将在客户端机器（即你提交命令的机器）上运行。</p> </li><li> <p><code>--driver-memory 512m</code>: 分配给 driver 的内存为 512 MB。</p> </li><li> <p><code>--executor-memory 512m</code>: 每个 Spark executor 使用 512 MB 内存。</p> </li><li> <p><code>--num-executors 2</code>: 指定 Spark 应使用 2 个 executor 进程。</p> </li><li> <p><code>--total-executor-cores 2</code>: 指定所有 executors 合计可使用的 CPU 核心数为 2。</p> </li><li> <p><code>/bigdata/spark-3.2.4/examples/src/main/python/pi.py</code>: 这是你要运行的 Python 程序的路径。</p> </li><li> <p><code>10</code>: 这是传递给 <code>pi.py</code> 程序的一个参数。具体来说，这通常用于指定计算π值时的迭代次数或精度。 </p> </li></ul> 
<p>日志跟随客户端的标准输出流进行输出：</p> 
<p><img alt="" height="689" src="https://images2.imgbox.com/f5/a0/VYRHczIo_o.png" width="1200"></p> 
<h4 id="4.4.2%20cluster%20%E6%A8%A1%E5%BC%8F%E6%B5%8B%E8%AF%95%20%C2%A0">4.4.2 cluster 模式测试  </h4> 
<p>假设运行圆周率 PI 程序，采用 cluster 模式，命令如下： </p> 
<pre><code class="hljs">(base) [root@hadoop01 /bigdata/spark-3.2.4]# bin/spark-submit --master yarn --deploy-mode cluster --driver-memory 512m --executor-memory 512m --num-executors 2 --total-executor-cores 2 /bigdata/spark-3.2.4/examples/src/main/python/pi.py 10</code></pre> 
<p>客户端是无日志信息和结果输出的： </p> 
<p><img alt="" height="628" src="https://images2.imgbox.com/07/01/aRsVfdqz_o.png" width="1200"></p> 
<h3 id="4.5%C2%A0%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%C2%A0">4.5 两种模式总结 </h3> 
<p>Client 模式和 Cluster 模式最最本质的区别是：Driver 程序运行在哪里。</p> 
<p>Client 模式：学习测试时使用，生产不推荐(要用也可以，性能略低，稳定性略低)</p> 
<ol><li>Driver 运行在 Client上，和集群的通信成本高</li><li>Driver 输出结果会在客户端显示</li></ol> 
<p>Cluster模式：生产环境中使用该模式</p> 
<ol><li>Driver 程序在 YARN 集群中，和集群的通信成本低</li><li>Driver 输出结果不能在客户端显示</li><li>该模式下 Driver 运行 ApplicattionMaster 这个节点上，由 Yarn 管理，如果出现问题，yarn 会重启 ApplicattionMaster(Driver) </li></ol> 
<h2 id="%E4%BA%94%E3%80%81%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B%C2%A0">五、两种模式详细流程 </h2> 
<h3 id="5.1%C2%A0Client%20%E6%A8%A1%E5%BC%8F%C2%A0">5.1 Client 模式 </h3> 
<p>在 YARN Client 模式下，Driver 在任务提交的本地机器上运行，示意图如下： </p> 
<p><img alt="" height="741" src="https://images2.imgbox.com/ce/e5/ZwrGlfBp_o.png" width="1200">具体流程步骤如下：</p> 
<ol><li>Driver 在任务提交的本地机器上运行，Driver 启动后会和 ResourceManager 通讯申请启动 ApplicationMaster；</li><li>随后 ResourceManager 分配 Container，在合适的 NodeManager 上启动ApplicationMaster，此时的 ApplicationMaster 的功能相当于一个 ExecutorLaucher，只负责向 ResourceManager 申请 Executor 内存；</li><li>ResourceManager 接到 ApplicationMaster 的资源申请后会分配 Container，然后ApplicationMaster 在资源分配指定的 NodeManager 上启动 Executor 进程；</li><li>Executor 进程启动后会向 Driver 反向注册，Executor 全部注册完成后 Driver 开始执行 main函数；</li><li>之后执行到 Action 算子时，触发一个 Job，并根据宽依赖开始划分 Stage，每个 Stage 生成对应的 TaskSet，之后将 Task 分发到各个 Executor 上执行。 </li></ol> 
<h3 id="5.2%C2%A0Cluster%20%E6%A8%A1%E5%BC%8F%C2%A0">5.2 Cluster 模式 </h3> 
<p>        在 YARN Cluster 模式下，Driver 运行在 NodeManager Contanier 中，此时 Driver 与 AppMaster 合为一体，示意图如下：</p> 
<p><img alt="" height="499" src="https://images2.imgbox.com/79/22/Kw2tcCEj_o.png" width="1200"></p> 
<p>具体流程步骤如下：</p> 
<ol><li>任务提交后会和 ResourceManager 通讯申请启动 ApplicationMaster;</li><li>随后 ResourceManager 分配 Container，在合适的 NodeManager 上启动 ApplicationMaster，此时的 ApplicationMaster 就是 Driver；</li><li>Driver 启动后向 ResourceManager 申请 Executor 内存，ResourceManager 接到ApplicationMaster 的资源申请后会分配 Container，然后在合适的 NodeManager 上启动Executor 进程;</li><li>Executor 进程启动后会向 Driver 反向注册;</li><li>Executor 全部注册完成后 Driver 开始执行 main 函数，之后执行到 Action 算子时，触发一个 job，并根据宽依赖开始划分 stage，每个 stage 生成对应的 taskSet，之后将 task 分发到各个 Executor 上执行。</li></ol> 
<blockquote> 
 <p>上一篇文章：<a href="https://blog.csdn.net/weixin_46560589/article/details/132857521" title="Spark-3.2.4 高可用集群安装部署详细图文教程_Stars.Sky的博客-CSDN博客">Spark-3.2.4 高可用集群安装部署详细图文教程_Stars.Sky的博客-CSDN博客</a> </p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/53e4b2125c03a54b4503db80f666cfeb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决 Axios 跨域问题，轻松实现接口调用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/009b7345a75bc8e0d9b5a1bbe908979b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ORA-00257:archiver error.Connect internal only,until freed.</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>