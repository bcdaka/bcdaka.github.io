<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>详解Qt中connect()函数 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/bdde8ccf0fa83db82ca7a694af57c05a/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="详解Qt中connect()函数">
  <meta property="og:description" content="一、基本概念 要想了解connect() 函数，要先知道在Qt中什么是什么是信号（SIGNAL）和槽（SLOT）。
信号（SIGNAL）：指在特定情况下发射的通知。比如当我们点击了用户界面的一个按钮之后就发射了一个信号。
槽（SLOT）：是指对信号进行响应的函数。也就是我们点击了一个按钮后我们要实现的功能。
那么connect() 函数就是Qt 框架中用于将信号（SIGNAL）和槽（SLOT）关联起来的核心函数。
二、用法 1.旧版用法（Qt4和早期Qt5） connect(sender, SIGNAL(signalName()), receiver, SLOT(slotName())); sender：发射信号的对象名称signalName()：信号名称receiver：接收信号的对象名称，一般情况下为槽函数所属对象，写this即可slotName()：槽函数名称 示例： connect(button, SIGNAL(clicked()), this, SLOT(handleButtonClicked())); 注意： 如果信号与槽函数带参数还需要在函数括号内标出。
2.新版用法（推荐） connect(sender, &amp;SenderClass::signalName, receiver, &amp;ReceiverClass::slotName); 这里引入了基于函数指针的语法，使得编译器可以进行更好的类型检查。但是这里有一个问题：与旧版的写法不同的是，信号与槽函数的参数怎么办？
首先我们知道，在 Qt 的信号与槽机制中，槽函数的参数不能多于信号的参数。也就是说，信号的参数可以多于槽的参数，且槽函数的参数必须是信号参数的一个子集。那么就可以分为如下三种情况：
1.信号和槽函数具有相同数量和类型的参数。这时可以直接连接且无需出现函数参数：
connect(lineEdit, &amp;QLineEdit::textChanged, this, &amp;Widget::do_textChanged); 在上面示例中，信号textChanged(QString)和槽函数do_textChanged(QString)参数相同。
2.信号的参数多于槽函数的参数。槽函数将忽略信号的多余参数，这个特性允许你在信号和槽参数不完全匹配的情况下，仍然能够正常工作。正常情况下，不推荐把槽函数设计为overload型。
3.某些信号的参数有默认值。也就是说同一信号的参数分为有参数和无参数，如QCheckBox的clicked()信号和clicked(bool)信号。这时connect()函数有两种写法：
a.设置不同名字的槽函数： //槽函数 void do_checked(bool checked); void do_checked_NoParam(); //connect()函数 connect(checkBox, &amp;QCheckBox::clicked, this, &amp;Widget::do_checked); connect(checkBox, &amp;QCheckBox::clicked, this, &amp;Widget::do_checked_NoParam); b.使用模板函数qOverload()来明确参数类型：
connect(checkBox, &amp;QCheckBox::clicked, this, qOverload&lt;bool&gt;(&amp;Widget::do_checked)); connect(checkBox, &amp;QCheckBox::clicked, this, qOverload&lt;&gt;(&amp;Widget::do_checked)); 3.自动连接（无需使用connect()函数） 在构建项目时，若勾选了“Generate form”字段，则会生成一个后缀为“.ui”的文件。
那么在ui设计界面种可以选中一个对象，右键选择“Go to slot”或者“转到槽”，在弹出的对话框中再选择信号，那么就会自动生成一个槽函数。如果槽函数的名称符合相应的格式，Qt 会在运行时通过setupUi(this)自动生成connect()函数完成连接。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-20T10:14:15+08:00">
    <meta property="article:modified_time" content="2024-06-20T10:14:15+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">详解Qt中connect()函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、基本概念</h2> 
<blockquote> 
 <p>        要想了解connect() 函数，要先知道在Qt中什么是什么是信号（SIGNAL）和槽（SLOT）。</p> 
 <p>       <strong> 信号（SIGNAL）：</strong>指在特定情况下<strong>发射的通知</strong>。比如当我们点击了用户界面的一个按钮之后就发射了一个信号。</p> 
 <p>        <strong>槽（SLOT）：</strong>是指对信号进行响应的<strong>函数</strong>。也就是我们点击了一个按钮后我们要实现的功能。</p> 
 <p>        那么<strong>connect() 函数</strong>就是Qt 框架中用于将信号（SIGNAL）和槽（SLOT）<strong>关联</strong>起来的核心函数。</p> 
</blockquote> 
<h2>二、用法</h2> 
<h4>1.旧版用法（Qt4和早期Qt5）</h4> 
<pre><code class="language-cpp">connect(sender, SIGNAL(signalName()), receiver, SLOT(slotName()));
</code></pre> 
<ul><li>sender：发射信号的对象名称</li><li>signalName()：信号名称</li><li>receiver：接收信号的对象名称，一般情况下为槽函数所属对象，写this即可</li><li>slotName()：槽函数名称</li></ul> 
<p>示例： </p> 
<pre><code class="language-cpp">connect(button, SIGNAL(clicked()), this, SLOT(handleButtonClicked()));
</code></pre> 
<p><strong><span style="color:#fe2c24;">注意： </span></strong>如果信号与槽函数带参数还需要在函数括号内标出。</p> 
<h4>2.新版用法（推荐）</h4> 
<pre><code class="language-cpp">connect(sender, &amp;SenderClass::signalName, receiver, &amp;ReceiverClass::slotName);
</code></pre> 
<p>         这里引入了基于函数指针的语法，使得编译器可以进行更好的类型检查。但是这里有一个问题：与旧版的写法不同的是，信号与槽函数的参数怎么办？</p> 
<p>        首先我们知道，在 Qt 的信号与槽机制中，槽函数的参数不能多于信号的参数。也就是说，信号的参数可以多于槽的参数，且槽函数的参数必须是信号参数的一个子集。那么就可以分为如下三种情况：</p> 
<p>       <strong> 1.信号和槽函数具有相同数量和类型的参数。</strong>这时可以直接连接且无需出现函数参数：</p> 
<pre><code class="language-cpp">connect(lineEdit, &amp;QLineEdit::textChanged, this, &amp;Widget::do_textChanged);
</code></pre> 
<p>在上面示例中，信号textChanged(QString)和槽函数do_textChanged(QString)参数相同。</p> 
<p>       <strong> 2.信号的参数多于槽函数的参数。</strong>槽函数将忽略信号的多余参数，这个特性允许你在信号和槽参数不完全匹配的情况下，仍然能够正常工作。正常情况下，<span style="color:#fe2c24;">不推荐</span>把槽函数设计为overload型。</p> 
<p>        <strong>3.某些信号的参数有默认值。</strong>也就是说同一信号的参数分为有参数和无参数，如QCheckBox的clicked()信号和clicked(bool)信号。这时connect()函数有两种写法：</p> 
<p>                a.设置不同名字的槽函数： </p> 
<pre><code class="language-cpp">//槽函数
void do_checked(bool checked);
void do_checked_NoParam();

//connect()函数
connect(checkBox, &amp;QCheckBox::clicked, this, &amp;Widget::do_checked);
connect(checkBox, &amp;QCheckBox::clicked, this, &amp;Widget::do_checked_NoParam);</code></pre> 
<p>                b.使用模板函数qOverload()来明确参数类型：</p> 
<pre><code class="language-cpp">connect(checkBox, &amp;QCheckBox::clicked, this, qOverload&lt;bool&gt;(&amp;Widget::do_checked));
connect(checkBox, &amp;QCheckBox::clicked, this, qOverload&lt;&gt;(&amp;Widget::do_checked));</code></pre> 
<h4>3.自动连接（无需使用connect()函数）</h4> 
<p>        在构建项目时，若勾选了“Generate form”字段，则会生成一个后缀为“.ui”的文件。</p> 
<p class="img-center"><img alt="" height="274" src="https://images2.imgbox.com/8c/94/9M37up4l_o.png" width="410"></p> 
<p>        那么在ui设计界面种可以选中一个对象，右键选择“Go to slot”或者“转到槽”，在弹出的对话框中再选择信号，那么就会自动生成一个槽函数。如果槽函数的名称符合相应的格式，Qt 会在运行时通过setupUi(this)自动生成connect()函数完成连接。</p> 
<p class="img-center"><img alt="" height="274" src="https://images2.imgbox.com/1e/54/thVwW2jO_o.png" width="428"></p> 
<pre><code class="language-cpp">Dialog::Dialog(QWidget *parent)
    : QDialog(parent)
    , ui(new Ui::Dialog)
{
    //由go to slot生成的槽函数可以自动关联
    ui-&gt;setupUi(this);  

    //自定义槽函数需要手动关联
    connect(ui-&gt;radioButtonBlack,SIGNAL(clicked()),this,SLOT(do_setFontColor()));
}

//自动生成的槽函数格式：void on_&lt;objectName&gt;_&lt;signalName&gt;(){}
void Widget::on_btnCal_clicked()
{
    ...
}

//手动写的槽函数
void Widget::do_setFontColor()
{
    ...
}</code></pre> 
<p>        当然在设计一些复杂功能时，自动连接方法就不太适用了。</p> 
<h4>4.Lambda表达式（Qt5.4）</h4> 
<p>        lambda 表达式提供了一种非常灵活的方式来处理信号。有如下几个优点：</p> 
<blockquote> 
 <ol><li>可以直接在连接语句中定义信号处理逻辑，无需在类中定义额外的槽函数。这在处理简单逻辑时尤其方便。</li><li>避免为每个信号处理逻辑定义新的槽函数，减少命名空间污染。</li><li>允许你在处理信号参数时，捕获外部变量或定义额外的处理逻辑。</li></ol> 
</blockquote> 
<p>基本格式如下：</p> 
<pre><code class="language-cpp">connect(sender, &amp;SenderClass::signalName, [lambda expression]);
</code></pre> 
<p>         举个栗子对比理解一下：</p> 
<pre><code class="language-cpp">//方法一：使用槽函数指针连接
void processData(int value, QString message) {
    if (value &gt; 10) {
        qDebug() &lt;&lt; "Value is greater than 10:" &lt;&lt; value &lt;&lt; ", Message:" &lt;&lt; message;
    } else {
        qDebug() &lt;&lt; "Value is 10 or less:" &lt;&lt; value;
    }
}

QObject::connect(&amp;sender, &amp;SenderClass::signalName, this, &amp;ReceiverClass::processData);</code></pre> 
<pre><code class="language-cpp">//方法二：使用lambda表达式连接
QObject::connect(&amp;sender, &amp;SenderClass::signalName, [this](int value, QString message) {
    if (value &gt; 10) {
        qDebug() &lt;&lt; "Value is greater than 10:" &lt;&lt; value &lt;&lt; ", Message:" &lt;&lt; message;
    } else {
        qDebug() &lt;&lt; "Value is 10 or less:" &lt;&lt; value;
    }
});</code></pre> 
<h2>三、断开连接disconnect()</h2> 
<h4>1.为什么使用disconnect()</h4> 
<p>        使用connect()函数可以关联信号与槽，那么删除connect()函数不就可以断开连接了吗？</p> 
<p class="img-center"><img alt="" height="156" src="https://images2.imgbox.com/6a/b5/k2ZwpREO_o.jpg" width="156"></p> 
<p>         其实不然！我们最好使用官方的 disconnect() 函数来解除信号与槽的连接。原因有如下几点：</p> 
<h6>a.动态控制信号和槽的连接</h6> 
<p>        有时你需要在运行时动态地控制信号和槽的连接。例如，你可能需要在某些情况下连接信号和槽，而在其他情况下断开它们。在这种情况下，使用 disconnect() 函数可以让你在需要时灵活地断开连接，而不需要修改代码来删除 connect() 调用。</p> 
<h6>b.保持代码的结构和可读性</h6> 
<p>         connect() 调用通常在类的构造函数或初始化方法中设置，表示对象之间的关系和交互。将连接和断开连接的逻辑分开可以使代码更清晰、更具结构性。如果直接删除 connect() 调用，代码逻辑可能会变得混乱且难以维护。</p> 
<h6>c<strong>. </strong><strong>方便的调试和维护</strong></h6> 
<p>        使用 disconnect() 可以更方便地调试和维护代码。你可以在调试时临时断开某些连接，而无需删除和重新添加 connect() 调用。这样可以避免错误，并更容易地还原代码。</p> 
<h6>d<strong>. </strong><strong>多次连接和断开</strong></h6> 
<p>        在某些情况下，你可能会多次连接和断开相同的信号和槽。例如，当某个条件发生变化时，你希望断开以前的连接并建立新的连接。使用 disconnect() 可以确保你正确地断开之前的连接，而不会遗留下不需要的连接。</p> 
<h4>2.使用方法</h4> 
<h6>a.解除与一个发射者所有信号的连接</h6> 
<pre><code class="language-cpp">disconnect(myObject, nullptr, nullptr, nullptr);
myObject-&gt;disconnect();</code></pre> 
<h6>b.解除与一个特定信号的所有连接</h6> 
<pre><code class="language-cpp">disconnect(myObject, SIGNAL(mySignal), nullptr, nullptr);
myObject-&gt;disconnect(SIGNAL(mySignal));</code></pre> 
<h6>c.解除与一个特定接收者的所有连接</h6> 
<pre><code class="language-cpp">disconnect(myObject, nullptr, myReceiver, nullptr);
myObject-&gt;disconnect( myReceiver);</code></pre> 
<h6>d.解除特定的一个信号与槽的连接</h6> 
<pre><code class="language-cpp">disconnect(lineEdit, &amp;QLineEdit::textChanged, label, &amp;QLabel::setText);</code></pre> 
<h2>四、细节问题</h2> 
<p>        1. 一个信号可以连接到多个槽，所有连接的槽都会在信号发出时依次被调用。</p> 
<pre><code class="language-cpp">connect(sender, &amp;SenderClass::signalName, receiver1, &amp;ReceiverClass1::slotName);
connect(sender, &amp;SenderClass::signalName, receiver2, &amp;ReceiverClass2::slotName);
</code></pre> 
<p>        2. 信号和槽机制是单向的，即信号发出时会调用槽函数，但槽函数中发出的信号不会自动调用其他槽函数，除非你明确连接了这些信号和槽。</p> 
<hr> 
<p><span style="color:#fe2c24;"><strong>写在最后：</strong></span>因自己学识浅薄，虽查找大量资料，仍有个别地方存在出入的话，还请读者不吝赐教！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3bc7bf88c57c62dd35e594635f149178/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C&#43;&#43;修行之道】C/C&#43;&#43;内存管理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3761262a37bca97e623705a8b4415715/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Hadoop 2.0：主流开源云架构（二）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>