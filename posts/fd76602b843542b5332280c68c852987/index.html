<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】排序（一）—— 希尔排序（思路演进版） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/fd76602b843542b5332280c68c852987/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】排序（一）—— 希尔排序（思路演进版）">
  <meta property="og:description" content="目录
一、常见的排序算法分类
二、常见排序算法的实现 2.1插入排序
2.1.1直接插入排序
基本思想
思路
step1.单趟控制
step2.总体控制 代码实现
测试
特性总结
2.1.2 希尔排序( 缩小增量排序 )
基本思想
思路演进
🌈1.代码实现单组排序（以红色组为例）
🌈2.加入控制多组排序的代码
🌈3.对上面代码修改 ，一组一组排 改为 多组并排！！！
🌈4.最后考虑，如何控制gap?
最终代码实现
测试
特性总结
三、结语
一、常见的排序算法分类 二、常见排序算法的实现 2.1插入排序 2.1.1直接插入排序 基本思想 直接插入排序是一种简单的插入排序法，其基本思想是：
把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为 止，得到一个新的有序序列 。
思路 step1.单趟控制 先考虑单趟排序，暂时不考虑区间到底是从哪到哪 ，先抽象为[0,end]
假设[0,end]是有序的区间 a[end&#43;1] 插入到 [0,end]中
❓具体如何插入：
下标是end&#43;1的元素依次跟[0,end]区间中的元素作比较：
end&#43;1先跟end比 再跟 end-1比较......依次往下
①如果a[end&#43;1]&lt;a[end] 以排升序为例子 ，那么a[end]就往后挪动 也就是往后覆盖
②如果a[end&#43;1]&gt;a[end] ,那么就停止比较 ，a[end&#43;1] 插入到 [0,end]中
❓思路落实到代码：
用临时变量tmp 先保存a[end&#43;1]，最终插入的位置也是a[end&#43;1]
step2.总体控制 接下来考虑如何控制[0,end]区间大小的变化：
❓执行过程描述：
初始时 区间元素个数肯定只有一个，
也就是end = 0 ，区间[0,0]有序，只有一个元素a[0],然后a[1]往里插入，">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-19T22:01:03+08:00">
    <meta property="article:modified_time" content="2024-05-19T22:01:03+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】排序（一）—— 希尔排序（思路演进版）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB" rel="nofollow">一、常见的排序算法分类</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%C2%A0" rel="nofollow">二、常见排序算法的实现 </a></p> 
<p id="2.1%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#2.1%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" rel="nofollow">2.1插入排序</a></p> 
<p id="%C2%A02.1.2%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#%C2%A02.1.2%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" rel="nofollow">2.1.1直接插入排序</a></p> 
<p id="2.1.1%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-toc" style="margin-left:120px;"><a href="#2.1.1%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3" rel="nofollow">基本思想</a></p> 
<p id="%E6%80%9D%E8%B7%AF-toc" style="margin-left:120px;"><a href="#%E6%80%9D%E8%B7%AF" rel="nofollow">思路</a></p> 
<p id="step1.%E5%8D%95%E8%B6%9F%E6%8E%A7%E5%88%B6-toc" style="margin-left:160px;"><a href="#step1.%E5%8D%95%E8%B6%9F%E6%8E%A7%E5%88%B6" rel="nofollow">step1.单趟控制</a></p> 
<p id="step2.%E6%80%BB%E4%BD%93%E6%8E%A7%E5%88%B6%C2%A0-toc" style="margin-left:160px;"><a href="#step2.%E6%80%BB%E4%BD%93%E6%8E%A7%E5%88%B6%C2%A0" rel="nofollow">step2.总体控制 </a></p> 
<p id="%C2%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:120px;"><a href="#%C2%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">代码实现</a></p> 
<p id="%E6%B5%8B%E8%AF%95-toc" style="margin-left:120px;"><a href="#%E6%B5%8B%E8%AF%95" rel="nofollow">测试</a></p> 
<p id="%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93-toc" style="margin-left:120px;"><a href="#%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93" rel="nofollow">特性总结</a></p> 
<p id="%C2%A02.1.3%20%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F(%20%E7%BC%A9%E5%B0%8F%E5%A2%9E%E9%87%8F%E6%8E%92%E5%BA%8F%20)-toc" style="margin-left:80px;"><a href="#%C2%A02.1.3%20%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%28%20%E7%BC%A9%E5%B0%8F%E5%A2%9E%E9%87%8F%E6%8E%92%E5%BA%8F%20%29" rel="nofollow">2.1.2 希尔排序( 缩小增量排序 )</a></p> 
<p id="%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-toc" style="margin-left:120px;"><a href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3" rel="nofollow">基本思想</a></p> 
<p id="%E6%80%9D%E8%B7%AF%E6%BC%94%E8%BF%9B-toc" style="margin-left:120px;"><a href="#%E6%80%9D%E8%B7%AF%E6%BC%94%E8%BF%9B" rel="nofollow">思路演进</a></p> 
<p id="%F0%9F%8C%881.%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%8D%95%E7%BB%84%E6%8E%92%E5%BA%8F%EF%BC%88%E4%BB%A5%E7%BA%A2%E8%89%B2%E7%BB%84%E4%B8%BA%E4%BE%8B%EF%BC%89-toc" style="margin-left:160px;"><a href="#%F0%9F%8C%881.%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%8D%95%E7%BB%84%E6%8E%92%E5%BA%8F%EF%BC%88%E4%BB%A5%E7%BA%A2%E8%89%B2%E7%BB%84%E4%B8%BA%E4%BE%8B%EF%BC%89" rel="nofollow">🌈1.代码实现单组排序（以红色组为例）</a></p> 
<p id="%F0%9F%8C%882.%E5%8A%A0%E5%85%A5%E6%8E%A7%E5%88%B6%E5%A4%9A%E7%BB%84%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%A3%E7%A0%81-toc" style="margin-left:160px;"><a href="#%F0%9F%8C%882.%E5%8A%A0%E5%85%A5%E6%8E%A7%E5%88%B6%E5%A4%9A%E7%BB%84%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%A3%E7%A0%81" rel="nofollow">🌈2.加入控制多组排序的代码</a></p> 
<p id="%F0%9F%8C%883.%E5%AF%B9%E4%B8%8A%E9%9D%A2%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9%20%EF%BC%8C%E4%B8%80%E7%BB%84%E4%B8%80%E7%BB%84%E6%8E%92%20%E6%94%B9%E4%B8%BA%20%E5%A4%9A%E7%BB%84%E5%B9%B6%E6%8E%92%EF%BC%81%EF%BC%81%EF%BC%81-toc" style="margin-left:160px;"><a href="#%F0%9F%8C%883.%E5%AF%B9%E4%B8%8A%E9%9D%A2%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9%20%EF%BC%8C%E4%B8%80%E7%BB%84%E4%B8%80%E7%BB%84%E6%8E%92%20%E6%94%B9%E4%B8%BA%20%E5%A4%9A%E7%BB%84%E5%B9%B6%E6%8E%92%EF%BC%81%EF%BC%81%EF%BC%81" rel="nofollow">🌈3.对上面代码修改 ，一组一组排 改为 多组并排！！！</a></p> 
<p id="%F0%9F%8C%884.%E6%9C%80%E5%90%8E%E8%80%83%E8%99%91%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6gap%3F-toc" style="margin-left:160px;"><a href="#%F0%9F%8C%884.%E6%9C%80%E5%90%8E%E8%80%83%E8%99%91%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6gap%3F" rel="nofollow">🌈4.最后考虑，如何控制gap?</a></p> 
<p id="%E6%9C%80%E7%BB%88%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:120px;"><a href="#%E6%9C%80%E7%BB%88%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">最终代码实现</a></p> 
<p id="%E6%B5%8B%E8%AF%95-toc" style="margin-left:120px;"><a href="#%E6%B5%8B%E8%AF%95" rel="nofollow">测试</a></p> 
<p id="%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93-toc" style="margin-left:120px;"><a href="#%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93" rel="nofollow">特性总结</a></p> 
<p id="%E4%B8%89%E3%80%81%E7%BB%93%E8%AF%AD-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E7%BB%93%E8%AF%AD" rel="nofollow">三、结语</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB">一、常见的排序算法分类</h2> 
<p><img alt="" src="https://images2.imgbox.com/11/35/0BNYUsPG_o.png"></p> 
<h2 id="%E4%BA%8C%E3%80%81%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%C2%A0">二、常见排序算法的实现 </h2> 
<h3 id="2.1%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">2.1插入排序</h3> 
<h4 id="%C2%A02.1.2%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">2.1.1直接插入排序</h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/32/d0/lSX3LDOf_o.gif"></p> 
<h5>基本思想</h5> 
<p>直接插入排序是一种简单的插入排序法，其基本思想是：</p> 
<blockquote> 
 <p><strong>把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为 止，得到一个新的有序序列 。</strong></p> 
</blockquote> 
<h5 id="%E6%80%9D%E8%B7%AF">思路</h5> 
<h6 id="step1.%E5%8D%95%E8%B6%9F%E6%8E%A7%E5%88%B6">step1.单趟控制</h6> 
<blockquote> 
 <p>先考虑单趟排序，暂时不考虑区间到底是从哪到哪 ，先抽象为[0,end]</p> 
 <p>假设<span style="background-color:#ffd900;">[0,end]是有序的区间</span> <span style="background-color:#ffd900;">a[end+1] 插入到 [0,end]中</span></p> 
 <p><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">❓</span></span>具体如何插入：</strong></p> 
 <p>下标是end+1的元素依次跟[0,end]区间中的元素作比较：</p> 
 <p>end+1先跟end比 再跟 end-1比较......依次往下</p> 
 <p><strong>①</strong>如果a[end+1]&lt;a[end] 以排升序为例子 ，那么a[end]就往后挪动 也就是往后覆盖</p> 
 <p><strong>②</strong>如果a[end+1]&gt;a[end] ,那么就停止比较 ，a[end+1] 插入到 [0,end]中</p> 
 <p><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">❓思路落实到代码：</span></span></strong></p> 
 <p><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">用临时变量</span></span><span style="color:#4d4d4d;"><span style="background-color:#ffd900;">tmp 先保存</span></span><span style="background-color:#ffd900;">a[end+1]</span>，最终插入的位置也是a[end+1]</p> 
 <p></p> 
</blockquote> 
<h6 id="step2.%E6%80%BB%E4%BD%93%E6%8E%A7%E5%88%B6%C2%A0">step2.总体控制 </h6> 
<blockquote> 
 <p>接下来考虑如何控制[0,end]区间大小的变化：</p> 
 <p><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">❓</span></span>执行过程描述：</strong></p> 
 <p>初始时 区间元素个数肯定只有一个，</p> 
 <p>也就是end = 0 ，区间[0,0]有序，只有一个元素a[0],然后a[1]往里插入，</p> 
 <p>完成后，end = 1，区间[0,1]有序，有两个元素，a[2]往里插入...</p> 
 <p>直到整个数组元素都有序，排序完成。</p> 
 <p><strong><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">❓思路落实到代码：</span></span></strong></p> 
 <p><span style="color:#4d4d4d;"><span style="background-color:#ffffff;">执行过程中，我们发现，<strong>end的值</strong>是<strong>不断变化</strong>的，所以<strong>加入外层循环变量i控制</strong>即可！</span></span></p> 
</blockquote> 
<h5 id="%C2%A0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</h5> 
<pre><code class="language-cpp">void InsertSort(int* a, int n)
{
	//外层循环 控制 多趟[0,end]
	for (int i = 0; i &lt; n-1; i++)
	{
		//单趟
		//[0,end] end+1 插入 [0,end]
		int end = i;
		int tmp = a[end + 1];
		while (end &gt;= 0)
		{
			//升序
			if (tmp &lt; a[end])
			{
				//end 往后覆盖 end+1
				a[end + 1] = a[end];
				end--;
			}
			else
			{
				break;
			}
		}
		a[end + 1] = tmp;
	}
}</code></pre> 
<h5 id="%E6%B5%8B%E8%AF%95">测试</h5> 
<p><img alt="" height="380" src="https://images2.imgbox.com/74/3a/p5wsFgVO_o.png" width="984"></p> 
<h5 id="%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93">特性总结</h5> 
<blockquote> 
 <p>1. 元素集合越接近有序，直接插入排序算法的时间效率越高</p> 
 <p>2. 时间复杂度：O(N^2)</p> 
 <p>3. 空间复杂度：O(1)，它是一种稳定的排序算法</p> 
 <p>4. 稳定性：稳定</p> 
</blockquote> 
<h4 id="%C2%A02.1.3%20%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F(%20%E7%BC%A9%E5%B0%8F%E5%A2%9E%E9%87%8F%E6%8E%92%E5%BA%8F%20)" style="background-color:transparent;">2.1.2 希尔排序( 缩小增量排序 )</h4> 
<h5 id="%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">基本思想</h5> 
<p>希尔排序法又称缩小增量法。希尔排序法的基本思想是：</p> 
<blockquote> 
 <p>先选定一个整数gap，把待排序文件中所有记录分成多个组，所有距离为gap的记录分在同一组内，并对每一组内的记录进行排序。然后，再往后依次取 间隔为gap的记录，重复上述分组和排序的工作。当gap==1时，所有记录在统一组内排好序。</p> 
</blockquote> 
<h5 id="%E6%80%9D%E8%B7%AF%E6%BC%94%E8%BF%9B">思路演进</h5> 
<blockquote> 
 <p><strong>总体思路：</strong></p> 
 <p><strong>1、预排序：分别对每个分组进行插入排序</strong></p> 
 <p><strong>2、直接插入排序 ：保证最终结果是有序的</strong></p> 
</blockquote> 
<p>先选定一个整数 ，先假设 gap = 3.  图解</p> 
<p><img alt="" src="https://images2.imgbox.com/94/d5/yI2dR0fo_o.png"></p> 
<h6 id="%F0%9F%8C%881.%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%8D%95%E7%BB%84%E6%8E%92%E5%BA%8F%EF%BC%88%E4%BB%A5%E7%BA%A2%E8%89%B2%E7%BB%84%E4%B8%BA%E4%BE%8B%EF%BC%89">🌈<strong>1.代码实现单组排序（以红色组为例）</strong></h6> 
<p><img alt="" height="561" src="https://images2.imgbox.com/96/76/k4lIzaQo_o.png" width="657"></p> 
<h6 id="%F0%9F%8C%882.%E5%8A%A0%E5%85%A5%E6%8E%A7%E5%88%B6%E5%A4%9A%E7%BB%84%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%A3%E7%A0%81"><strong>🌈2.加入控制多组排序的代码</strong></h6> 
<p><strong><span style="background-color:#ffd900;">总体有gap组 排完红色组 接着排 蓝色组、绿色组 则需要再加入一层循环控制</span></strong></p> 
<p><strong>j==0 红色组 插入排序</strong></p> 
<p><strong>j==1 蓝色组 插入排序</strong></p> 
<p><strong>j==2 绿色组 插入排序</strong></p> 
<p><img alt="" height="694" src="https://images2.imgbox.com/b8/b1/uK3NuWLl_o.png" width="703"></p> 
<h6 id="%F0%9F%8C%883.%E5%AF%B9%E4%B8%8A%E9%9D%A2%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9%20%EF%BC%8C%E4%B8%80%E7%BB%84%E4%B8%80%E7%BB%84%E6%8E%92%20%E6%94%B9%E4%B8%BA%20%E5%A4%9A%E7%BB%84%E5%B9%B6%E6%8E%92%EF%BC%81%EF%BC%81%EF%BC%81">🌈<strong>3.对上面代码修改 ，一组一组排 改为 多组并排！！！</strong></h6> 
<blockquote> 
 <p>上面代码是 ： <span style="background-color:#ffd900;">红色组排完 排绿色组  绿色排完 排蓝色组</span></p> 
 <p>下面代码是 ： <span style="background-color:#ffd900;">红色组第一个位置排好</span>,</p> 
 <p>                        <span style="background-color:#ffd900;">i++ 排蓝色组第一个位置</span> ,</p> 
 <p>                       <span style="background-color:#ffd900;">再 i++ 排绿色组第一个位置</span>，</p> 
 <p>                       以此类推......</p> 
</blockquote> 
<p> 实现多组并排：</p> 
<p><img alt="" height="616" src="https://images2.imgbox.com/8d/49/qRWOUXeZ_o.png" width="698"></p> 
<h6 id="%F0%9F%8C%884.%E6%9C%80%E5%90%8E%E8%80%83%E8%99%91%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6gap%3F">🌈<strong>4.最后考虑，如何控制gap?</strong></h6> 
<blockquote> 
 <p><strong>gap越大：小的值更快调到前面，大的值更快调到后面</strong></p> 
 <p><strong>gap越小：调得越慢 但 越接近有序</strong></p> 
 <p><strong>gap==1 ：就是直接插入排序</strong></p> 
</blockquote> 
<p><strong>所以我们再加入一层循环 控制gap</strong></p> 
<h5 id="%E6%9C%80%E7%BB%88%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">最终代码实现</h5> 
<pre><code class="language-cpp">void ShellSort(int* a, int n)
{
	int gap = n;
	while (gap &gt; 1)
	{
		gap = gap / 2 ;
		for (int i = 0; i &lt; n - gap; i ++)
		{
			//单趟
			//[0,end] end+gap 插入 [0,end]
			int end = i;
			int tmp = a[end + gap];
			while (end &gt;= 0)
			{
				//升序
				if (tmp &lt; a[end])
				{
					//end 往后覆盖
					a[end + gap] = a[end];
					end -= gap;
				}
				else
				{
					break;
				}
			}
			a[end + gap] = tmp;
		}
	}
}</code></pre> 
<h5>测试</h5> 
<p><img alt="" height="364" src="https://images2.imgbox.com/d3/db/V0InhEoQ_o.png" width="991"></p> 
<h5>特性总结</h5> 
<blockquote> 
 <p>1. 希尔排序是对直接插入排序的优化。</p> 
 <p>2. 当gap &gt; 1时都是预排序，目的是让数组<strong>接近于有序</strong>。</p> 
 <p>    当gap == 1时，数组已经是接近有序，再进行直接插入排序，目的是让数组<strong>有序</strong>。</p> 
 <p>    这样整体而言，可以达到优化的效果。我们实现后可以进行性能测试的对比。</p> 
 <p>3. 希尔排序的时间复杂度不好计算，因为gap的取值方法很多，导致很难去计算，因此在好些树中给出的希尔排序的时间复杂度都不固定。<strong>平均时间复杂度O（N^1.3）</strong></p> 
</blockquote> 
<h2 id="%E4%B8%89%E3%80%81%E7%BB%93%E8%AF%AD">三、结语</h2> 
<p>插入排序就先讲到这里，后面滴选择、交换、归并排序，都会快快更新滴~</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3d45850dd70dbdfabf8a3d0332c96a7a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python常见数据类型处理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a9225649407fb57cf1a9cb0c97681360/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">路径规划 | 图解A*、Dijkstra、GBFS算法的异同(附C&#43;&#43;/Python/Matlab仿真)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>