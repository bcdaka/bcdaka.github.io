<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; 哈希的应用【布隆过滤器】 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/d736e64c6c168eaa201d69b7515dfa13/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C&#43;&#43; 哈希的应用【布隆过滤器】">
  <meta property="og:description" content="✨个人主页： 北 海
🎉所属专栏： C&#43;&#43;修行之路
🎃操作环境： Visual Studio 2022 版本 17.6.5
文章目录 🌇前言🏙️正文1、字符串比较2、布隆过滤器的概念3、布隆过滤器的实现3.1、基本结构3.2、插入3.3、查找3.4、删除3.5、测试3.6、优化方案 4、布隆过滤器小结5、海量数据面试题（哈希切割）5.1、题目一5.2、题目二 🌆总结 🌇前言 注册账号是进行网络冲浪的第一步操作，而拥有一个具有个性且独一无二的用户昵称是非常重要的，很多人在填写昵称时，常常会看到 此昵称已存在 的提示，系统是如何快速知道当前昵称是否存在呢？总不能挨个去遍历对比吧，这时候就需要我们本文中的主角： 布隆过滤器
🏙️正文 1、字符串比较 常见的字符串比较方法是 按 ASCII 码值进行比较，直到两个字符串同时结束，说明两者一致
比如字符串1 abcdef 和字符串2 azbmcy
显然两个字符串不一样
这种比较方法很直接，也很可靠，但缺点也很明显：需要对字符串进行遍历
一个字符串还好，如果是几千万个字符串呢？不但需要消耗大量存储空间，查找效率也很低，此时填写个昵称，服务器都要跑一会才有反映，这是用户所无法容忍的
因此人们想出了另一个方法，利用哈希映射 的思想，计算出 哈希值，存储这个值即可，可以借此 标识字符串是否存在
在进行字符串（昵称）比较时，只需要计算出对应的 哈希值，然后看看该位置是否存在即可
哈希值 也是一个整数啊，可以利用 位图 进行 设置，查找字符串时，本质上是在 查找哈希值是否在位图中存在
字符串有千万种组合，但字符是有限的，难免会出现 误判 的情况（此处的 哈希函数 为每个字符相加）
为了尽可能降低 误判率，在 位图 的基础之上设计出了 布隆过滤器
接下来看看什么是 布隆过滤器 吧
2、布隆过滤器的概念 这里是 布隆 可不是 英雄联盟中的 弗雷尔卓德之心 布隆，毕竟他也不能解决字符串比较问题，他只是 召唤师峡谷 中的一个坦克，主要负责 过滤（吸收） 敌方的伤害">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-07-30T21:39:02+08:00">
    <meta property="article:modified_time" content="2023-07-30T21:39:02+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; 哈希的应用【布隆过滤器】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p><font face="微软雅黑" color="" size="4px"><strong>✨个人主页：</strong></font> <font face="微软雅黑" color="" size="3px"><strong><a href="https://blog.csdn.net/weixin_61437787?type=blog">北 海</a></strong></font><br> <font face="微软雅黑" color="" size="4px"><strong>🎉所属专栏：</strong></font> <font face="微软雅黑" color="" size="3px"><strong><a href="https://blog.csdn.net/weixin_61437787/category_12187694.html">C++修行之路</a></strong></font><br> <font face="微软雅黑" color="" size="4px"><strong>🎃操作环境：</strong></font> <font face="微软雅黑" color="" size="3px"><strong><a href="https://visualstudio.microsoft.com/zh-hans/thank-you-downloading-visual-studio/?sku=Community&amp;channel=Release&amp;version=VS2022&amp;source=VSLandingPage&amp;cid=2030&amp;passive=false" rel="nofollow">Visual Studio 2022 版本 17.6.5</a></strong></font></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/00/af/s0KFNE8z_o.gif" alt="成就一亿技术人" title="成就一亿技术人"></p> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_11" rel="nofollow">🌇前言</a></li><li><a href="#_18" rel="nofollow">🏙️正文</a></li><li><ul><li><a href="#1_19" rel="nofollow">1、字符串比较</a></li><li><a href="#2_45" rel="nofollow">2、布隆过滤器的概念</a></li><li><a href="#3_61" rel="nofollow">3、布隆过滤器的实现</a></li><li><ul><li><a href="#31_62" rel="nofollow">3.1、基本结构</a></li><li><a href="#32_161" rel="nofollow">3.2、插入</a></li><li><a href="#33_180" rel="nofollow">3.3、查找</a></li><li><a href="#34_222" rel="nofollow">3.4、删除</a></li><li><a href="#35_239" rel="nofollow">3.5、测试</a></li><li><a href="#36_339" rel="nofollow">3.6、优化方案</a></li></ul> 
   </li><li><a href="#4_424" rel="nofollow">4、布隆过滤器小结</a></li><li><a href="#5_448" rel="nofollow">5、海量数据面试题（哈希切割）</a></li><li><ul><li><a href="#51_449" rel="nofollow">5.1、题目一</a></li><li><a href="#52_500" rel="nofollow">5.2、题目二</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_538" rel="nofollow">🌆总结</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_11"></a>🌇前言</h2> 
<p><strong>注册账号是进行网络冲浪的第一步操作，而拥有一个具有个性且独一无二的用户昵称是非常重要的，很多人在填写昵称时，常常会看到 <code>此昵称已存在</code> 的提示，系统是如何快速知道当前昵称是否存在呢？总不能挨个去遍历对比吧，这时候就需要我们本文中的主角： <code>布隆过滤器</code></strong></p> 
<p><img src="https://images2.imgbox.com/25/d0/xZ7lh9XE_o.png" alt="图示" title="图示"></p> 
<hr> 
<h2><a id="_18"></a>🏙️正文</h2> 
<h3><a id="1_19"></a>1、字符串比较</h3> 
<p>常见的字符串比较方法是 <strong>按 <code>ASCII</code> 码值进行比较，直到两个字符串同时结束，说明两者一致</strong></p> 
<p>比如字符串1 <code>abcdef</code> 和字符串2 <code>azbmcy</code><br> 显然两个字符串不一样</p> 
<p>这种比较方法很直接，也很可靠，但缺点也很明显：<strong>需要对字符串进行遍历</strong><br> 一个字符串还好，如果是几千万个字符串呢？<strong>不但需要消耗大量存储空间，查找效率也很低</strong>，此时填写个昵称，服务器都要跑一会才有反映，这是用户所无法容忍的</p> 
<p>因此人们想出了另一个方法，<strong>利用哈希映射</strong> 的思想，计算出 <strong>哈希值</strong>，存储这个值即可，可以借此 <strong>标识字符串是否存在</strong><br> 在进行字符串（昵称）比较时，只需要计算出对应的 <strong>哈希值</strong>，然后看看该位置是否存在即可</p> 
<p><strong>哈希值</strong> 也是一个整数啊，可以利用 <strong>位图</strong> 进行 <strong>设置</strong>，查找字符串时，本质上是在 <strong>查找哈希值是否在位图中存在</strong></p> 
<p>字符串有千万种组合，但字符是有限的，难免会出现 <strong>误判</strong> 的情况（此处的 <strong>哈希函数</strong> 为每个字符相加）</p> 
<p><img src="https://images2.imgbox.com/7c/b5/WrxwIlPW_o.png" alt="图示" title="图示"></p> 
<p>为了尽可能降低 <strong>误判率</strong>，在 <strong>位图</strong> 的基础之上设计出了 <strong><code>布隆过滤器</code></strong></p> 
<p><strong>接下来看看什么是 <code>布隆过滤器</code> 吧</strong></p> 
<p><img src="https://images2.imgbox.com/71/f3/4ILSPWPJ_o.png" alt="图示" title="图示"></p> 
<hr> 
<h3><a id="2_45"></a>2、布隆过滤器的概念</h3> 
<p>这里是 <strong>布隆</strong> 可不是 <strong>英雄联盟中的 <code>弗雷尔卓德之心 布隆</code></strong>，毕竟他也不能解决字符串比较问题，他只是 <strong>召唤师峡谷</strong> 中的一个坦克，主要负责 <strong>过滤（吸收）</strong> 敌方的伤害</p> 
<p><strong>布隆过滤器</strong> 是由 <code>布隆（Burton Howard Bloom）</code> 在 <code>1970</code> 年提出的一种 <strong>紧凑型的、比较巧妙</strong> 的 <strong>概率型数据结构</strong>，特点是 <strong>高效地插入和查询</strong></p> 
<p><strong>布隆过滤器</strong> 的核心在于通过添加 <strong>哈希函数</strong> 来 <strong>降低误判率</strong></p> 
<blockquote> 
 <p><strong>举个例子，如果每个人的名字都只有一个字，那么肯定存在很多重名的情况，但如果把名字字数增多，重复的情况就会大大缓解</strong></p> 
</blockquote> 
<p>所以 <strong>布隆过滤器</strong> 其实很简单，无非就是映射字符串时，多安排几个不一样的 <strong>哈希函数</strong>，多映射几个 <strong>比特位</strong>，只有当每个 <strong>比特位</strong> 的为 <code>1</code> 时，才能验证这个字符串是存在的</p> 
<p><img src="https://images2.imgbox.com/5e/c4/Viooawpm_o.png" alt="图示" title="图示"></p> 
<hr> 
<h3><a id="3_61"></a>3、布隆过滤器的实现</h3> 
<h4><a id="31_62"></a>3.1、基本结构</h4> 
<p><strong>布隆过滤器</strong> 离不开 <strong>位图</strong>，此时可以搬出之前实现过的 <strong>位图结构</strong></p> 
<p>既然需要增加 <strong>哈希函数</strong>，我们可以在模板中添加三个 <strong>哈希函数</strong> 的模板参数以及待存储的数据类型 <code>K</code></p> 
<pre><code class="prism language-cpp"><span class="token keyword">namespace</span> Yohifo
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">template</span><span class="token operator">&lt;</span>size_t N<span class="token punctuation">,</span>
			<span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span>
			<span class="token keyword">class</span> <span class="token class-name">Hash1</span><span class="token punctuation">,</span>
			<span class="token keyword">class</span> <span class="token class-name">Hash2</span><span class="token punctuation">,</span>
			<span class="token keyword">class</span> <span class="token class-name">Hash3</span><span class="token operator">&gt;</span>
	<span class="token keyword">class</span> <span class="token class-name">BloomFilter</span>
	<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token comment">//……</span>

	<span class="token keyword">private</span><span class="token operator">:</span>
		Yohifo<span class="token double-colon punctuation">::</span>bitset<span class="token operator">&lt;</span>N<span class="token operator">&gt;</span> _bits<span class="token punctuation">;</span>	<span class="token comment">//位图结构</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>显然，这三个 <strong>哈希函数</strong> 的选择是十分重要的，我们在这里提供三种较为优秀的 <strong>哈希函数（<a href="https://www.cnblogs.com/-clq/archive/2012/05/31/2528153.html" rel="nofollow">字符串哈希算法</a>）</strong>，分别是 <code>BKDRHash</code>、<code>APHash</code> 以及 <code>DJBHash</code></p> 
<p>函数原型如下（写成 <strong>仿函数</strong> 的形式，方便传参与调用）：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">BKDRHash</span>
<span class="token punctuation">{<!-- --></span>
    size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        size_t hash <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> str<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            hash <span class="token operator">=</span> hash <span class="token operator">*</span> <span class="token number">131</span> <span class="token operator">+</span> <span class="token punctuation">(</span>size_t<span class="token punctuation">)</span>e<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
        <span class="token keyword">return</span> hash<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">APHash</span>
<span class="token punctuation">{<!-- --></span>
    size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        size_t hash <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> str<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>size_t<span class="token punctuation">)</span>e <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                hash <span class="token operator">^=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>hash <span class="token operator">&lt;&lt;</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>size_t<span class="token punctuation">)</span>e <span class="token operator">^</span> <span class="token punctuation">(</span>hash <span class="token operator">&gt;&gt;</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span>
            <span class="token punctuation">{<!-- --></span>
                hash <span class="token operator">^=</span> <span class="token punctuation">(</span><span class="token operator">~</span><span class="token punctuation">(</span><span class="token punctuation">(</span>hash <span class="token operator">&lt;&lt;</span> <span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>size_t<span class="token punctuation">)</span>e <span class="token operator">^</span> <span class="token punctuation">(</span>hash <span class="token operator">&gt;&gt;</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> hash<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">DJBHash</span>
<span class="token punctuation">{<!-- --></span>
    size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

        size_t hash <span class="token operator">=</span> <span class="token number">5381</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> str<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            hash <span class="token operator">+=</span> <span class="token punctuation">(</span>hash <span class="token operator">&lt;&lt;</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>size_t<span class="token punctuation">)</span>e<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> hash<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>因为 <strong>布隆过滤器</strong> 中最常存储的数据类型是 <strong>字符串</strong>，并且三个 <strong>哈希函数</strong> 我们也已经有了，所以可以将 <strong>布隆过滤器</strong> 中模板添加上 <strong>缺省值</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span>size_t N<span class="token punctuation">,</span>
		<span class="token keyword">class</span> <span class="token class-name">K</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span>
		<span class="token keyword">class</span> <span class="token class-name">Hash1</span> <span class="token operator">=</span> BKDRHash<span class="token punctuation">,</span>
		<span class="token keyword">class</span> <span class="token class-name">Hash2</span> <span class="token operator">=</span> APHash<span class="token punctuation">,</span>
		<span class="token keyword">class</span> <span class="token class-name">Hash3</span> <span class="token operator">=</span> DJBHash<span class="token operator">&gt;</span>
</code></pre> 
<p>如何创建一个<strong>布隆过滤器</strong>？</p> 
<pre><code class="prism language-cpp">BloomFilter<span class="token operator">&lt;</span><span class="token number">100</span><span class="token operator">&gt;</span> bf<span class="token punctuation">;</span>    <span class="token comment">//最大值为 100 的布隆过滤器</span>
</code></pre> 
<h4><a id="32_161"></a>3.2、插入</h4> 
<p><strong>插入</strong> 无非就是利用三个 <strong>哈希函数</strong> 计算出三个不同的 <strong>哈希值</strong>，然后利用 <strong>位图</strong> 分别进行 <strong>设置</strong> 就好了</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>K<span class="token operator">&amp;</span> key<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    size_t HashI1 <span class="token operator">=</span> <span class="token function">Hash1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> N<span class="token punctuation">;</span>   <span class="token comment">//% N 是为了避免计算出的哈希值过大</span>
    _bits<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>HashI1<span class="token punctuation">)</span><span class="token punctuation">;</span>

    size_t HashI2 <span class="token operator">=</span> <span class="token function">Hash2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> N<span class="token punctuation">;</span>
    _bits<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>HashI2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    size_t HashI3 <span class="token operator">=</span> <span class="token function">Hash3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> N<span class="token punctuation">;</span>
    _bits<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>HashI3<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><mark>注意：</mark> <strong>布隆过滤器的插入操作是一定会成功的，因为不管是什么字符串，都可以在其对应的位置留下痕迹</strong></p> 
<h4><a id="33_180"></a>3.3、查找</h4> 
<p><strong>查找</strong> 某个字符串时，需要判断它的每个 <strong>哈希值</strong> 是否都存在，<strong>如果有一个不存在，那么这个字符串必然是不存在的</strong></p> 
<pre><code class="prism language-cpp"> <span class="token keyword">bool</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">const</span> K<span class="token operator">&amp;</span> key<span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
     <span class="token comment">//过滤不存在的情况，至于是否存在，还得进一步判断</span>
     size_t HashI1 <span class="token operator">=</span> <span class="token function">Hash1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> N<span class="token punctuation">;</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>_bits<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>HashI1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
         <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

     size_t HashI2 <span class="token operator">=</span> <span class="token function">Hash2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> N<span class="token punctuation">;</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>_bits<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>HashI2<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
         <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

     size_t HashI3 <span class="token operator">=</span> <span class="token function">Hash3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> N<span class="token punctuation">;</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>_bits<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>HashI3<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
         <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

     <span class="token comment">//经过层层过滤后，判断字符串可能存在</span>
     <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre> 
<p><strong>查找</strong> 函数可以很好的体现 <strong>过滤</strong> 的特性</p> 
<blockquote> 
 <p><strong>如何判断一个人是否存在</strong><br> 不能盲目去查找，而是应该根据姓名，查询身份证号、住址等个人信息，如果这些信息都没有，那么就说明这个人不存在，因为这些信息足够过滤出结果了；如果出现重名或信息重复的情况，则需要进一步判断，这就是说明 <strong>通过过滤判断 “存在” 是不准确的，但判断 “不存在” 是准确的</strong></p> 
</blockquote> 
<p><mark>布隆过滤器判断 “不在” 是准确的，判断 “在” 是不准确的</mark></p> 
<p>比如，字符串1映射了 <code>1、6、7</code> 号位置，字符串2映射了 <code>2、4、5</code> 号位置，字符串3映射了 <code>1、3、4</code> 号位置，虽然这三个字符串不会相互影响，但如果此时字符串4映射的是 <code>1、2、3</code> 号位置，会被误断为 <strong>存在</strong>，理论上 <strong>字符串存储位置越密集，误判率越高</strong></p> 
<p><img src="https://images2.imgbox.com/1d/eb/fQRGdAsd_o.png" alt="图示" title="图示"></p> 
<p>所以对于一些敏感数据，如果要判断是否存在，不能只依靠 <strong>布隆过滤器</strong>，而是使用 <strong>布隆过滤器 + 数据库</strong> 的方式进行双重验证</p> 
<p>当然，如果 <strong>布隆过滤器</strong> 判断字符串不存在，那么就是真的不存在，因为这是绝对准确的</p> 
<p><strong>布隆过滤器</strong> 能容忍误判的场景：<strong>注册时，判断昵称是否存在</strong></p> 
<h4><a id="34_222"></a>3.4、删除</h4> 
<p>一般的 <strong>布隆过滤器</strong> 不支持删除，一旦进行了删除（<strong>重置</strong>），会影响其他字符串</p> 
<p><img src="https://images2.imgbox.com/9f/ad/sUVK6Ne8_o.png" alt="图示" title="图示"></p> 
<p>表面上只删除了 “腾讯”，但实际上影响了 “百度”，在验证 “百度” 是否存在时，会被判断为 <strong>不存在</strong>，此时只有三个字符串，如果有更多呢？造成的影响是很大的，所以对于一般的 <strong>布隆过滤器</strong>，是不支持删除操作的</p> 
<p><strong>如何让布隆过滤器支持删除？</strong><br> 关于共用同一份资源这个问题，我们以前就已经见过了，比如 <strong>命名管道</strong>，当我们试图多次打开同一个 <strong>命名管道</strong> 时，操作系统实际上并不会打开多次，因为这样是很影响效率的，实际每打开一次 <strong>命名管道</strong>，其中的 <strong>计数器<code>++</code></strong>，当关闭 <strong>命名管道</strong> 时，<strong>计数器<code>--</code></strong>，直到 <strong>计数器</strong> 为 <code>0</code> 时，<strong>命名管道</strong> 才会被真正关闭</p> 
<p>这不就是 <strong>引用计数</strong> 的思想吗？</p> 
<p>我们可以给每一个 <strong>比特位</strong> 带上一个 <strong>引用计数器</strong>，用来表示当前位置存在几个映射关系，这样 <strong>布隆过滤器</strong> 就能支持 <strong>删除</strong> 操作了</p> 
<p>但这未免也太本末倒置了，<strong>位图</strong> 的优点是 <strong>高效且空间利用率高</strong>，如果给每一个 <strong>比特位</strong> 都挂上一个 <strong>引用计数器</strong>，会导致 <strong>位图</strong> 占用的内存资源膨胀，浪费很多不必要的空间，并且 <strong>删除</strong> 操作需求不大，没必要添加</p> 
<h4><a id="35_239"></a>3.5、测试</h4> 
<p>接下来测试一下 <strong>布隆过滤器</strong> 是否有用</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">TestBloomFilter1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    BloomFilter<span class="token operator">&lt;</span><span class="token number">100</span><span class="token operator">&gt;</span> bf<span class="token punctuation">;</span>    <span class="token comment">//最大值为 100 的布隆过滤器</span>

    bf<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"aaaaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    bf<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"bbbbb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    bf<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"ccccc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    bf<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"ddddd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    bf<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"eeeee"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"bbbbb: "</span> <span class="token operator">&lt;&lt;</span> bf<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">"bbbbb"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ddddd: "</span> <span class="token operator">&lt;&lt;</span> bf<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">"ddddd"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"============"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"aaaa: "</span> <span class="token operator">&lt;&lt;</span> bf<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">"aaaa"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">//相似字符串</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"CCCCC: "</span> <span class="token operator">&lt;&lt;</span> bf<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">"CCCCC"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"zzzzz: "</span> <span class="token operator">&lt;&lt;</span> bf<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">"zzzzz"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token comment">//不相似字符串</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"wwwww: "</span> <span class="token operator">&lt;&lt;</span> bf<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">"wwwww"</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/b9/7e/6EHtT1zF_o.png" alt="图示" title="图示"></p> 
<p>可以正确进行判断，接下来看看 <strong>设置</strong> 的每个字符串的 <strong>哈希值</strong> 是多少</p> 
<p><img src="https://images2.imgbox.com/13/71/gcNteAH2_o.png" alt="图示" title="图示"></p> 
<p>同时在三个 <strong>哈希值</strong> 的叠加下，<strong>误判</strong> 的概率被大大降低了，尽管如此，在判断字符串存在时，仍然存在较高的 <strong>误判率</strong>，可以通过下面的程序计算 <strong>误判率</strong></p> 
<p>测试方法：<strong>插入约 <code>10 w</code> 个字符串（原生），对原字符串进行微调后插入（近似），最后插入等量的完全不相同的字符串（不同），分别看看 <code>原生</code> 与 <code>近似</code>，<code>原生</code> 与 <code>不同</code> 字符串之间的误判率</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">TestBloomFilter2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   <span class="token comment">//测试误判率</span>
   <span class="token comment">//构建一组字符串 + 一组相似字符串 + 一组完全不同字符串</span>
   <span class="token comment">//通过 test 测试误判率</span>

   <span class="token keyword">const</span> size_t N <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>	<span class="token comment">//字符串数</span>
   std<span class="token double-colon punctuation">::</span>string str <span class="token operator">=</span> <span class="token string">"https://blog.csdn.net/weixin_61437787?spm=1000.2115.3001.5343"</span><span class="token punctuation">;</span>

   <span class="token comment">//构建原生基本的字符串</span>
   std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> <span class="token function">vsStr</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
   <span class="token punctuation">{<!-- --></span>
       std<span class="token double-colon punctuation">::</span>string url <span class="token operator">=</span> str <span class="token operator">+</span> std<span class="token double-colon punctuation">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
       vsStr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> url<span class="token punctuation">;</span>	<span class="token comment">//保存起来，后续要用</span>
   <span class="token punctuation">}</span>

   <span class="token comment">//构建相似的字符串</span>
   std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> <span class="token function">vsSimilarStr</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>
   BloomFilter<span class="token operator">&lt;</span>N<span class="token operator">&gt;</span> bfSimilarStr<span class="token punctuation">;</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
   <span class="token punctuation">{<!-- --></span>
       std<span class="token double-colon punctuation">::</span>string url <span class="token operator">=</span> str <span class="token operator">+</span> std<span class="token double-colon punctuation">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       vsSimilarStr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> url<span class="token punctuation">;</span>
       bfSimilarStr<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   <span class="token comment">//构建完全不一样的字符串</span>
   str <span class="token operator">=</span> <span class="token string">"https://leetcode.cn/problemset/all/"</span><span class="token punctuation">;</span>
   std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> <span class="token function">vsDiffStr</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>
   BloomFilter<span class="token operator">&lt;</span>N<span class="token operator">&gt;</span> bfDiffStr<span class="token punctuation">;</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
   <span class="token punctuation">{<!-- --></span>
       std<span class="token double-colon punctuation">::</span>string url <span class="token operator">=</span> str <span class="token operator">+</span> std<span class="token double-colon punctuation">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
       vsDiffStr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> url<span class="token punctuation">;</span>
       bfDiffStr<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   <span class="token comment">//误判率检测：原生 &lt;---&gt; 近似</span>
   <span class="token keyword">double</span> missVal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> vsStr<span class="token punctuation">)</span>
   <span class="token punctuation">{<!-- --></span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>bfSimilarStr<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
           missVal<span class="token operator">++</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   <span class="token comment">//误判率检测：原生 &lt;---&gt; 不同</span>
   <span class="token keyword">double</span> diffVal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> vsStr<span class="token punctuation">)</span>
   <span class="token punctuation">{<!-- --></span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>bfDiffStr<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
           diffVal<span class="token operator">++</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"原生 &lt;---&gt; 近似 误判率："</span> <span class="token operator">&lt;&lt;</span> missVal <span class="token operator">/</span> N <span class="token operator">*</span> <span class="token number">100</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"%"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
   std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"原生 &lt;---&gt; 不同 误判率："</span> <span class="token operator">&lt;&lt;</span> diffVal <span class="token operator">/</span> N <span class="token operator">*</span> <span class="token number">100</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"%"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/7f/4d/3TPHoXwL_o.png" alt="图示" title="图示"></p> 
<p><mark>显然，此时存在很高的误判率</mark></p> 
<h4><a id="36_339"></a>3.6、优化方案</h4> 
<p>可以从两个方面进行优化：</p> 
<ol><li><strong>增加哈希函数的个数（不是很推荐）</strong></li><li><strong>扩大布隆过滤器的长度，使数据更分散</strong></li></ol> 
<p>因此我们可以控制 <strong>布隆过滤器</strong> 的长度，降低 <strong>误判率</strong></p> 
<blockquote> 
 <p><strong>如何理解空间扩大后，误判率会降低？</strong></p> 
 <p>想想 <strong>地广人稀的西伯利亚</strong> 和 <strong>地狭人稠的香港</strong>，人口越稠密，找人时越有可能发生误判</p> 
 <p><img src="https://images2.imgbox.com/88/05/EfGhHCUO_o.png" alt="图示" title="图示"></p> 
</blockquote> 
<p>那么如何选择 <strong>布隆过滤器</strong> 的长度，做到 <strong>平衡误判率与空间占用呢</strong>？</p> 
<p>《<a href="https://zhuanlan.zhihu.com/p/43263751/" rel="nofollow">详解布隆过滤器的原理，使用场景和注意事项</a>》</p> 
<p><img src="https://images2.imgbox.com/f5/50/na7S4vqZ_o.png" alt="图示" title="图示"><br> <img src="https://images2.imgbox.com/f2/ae/aRz5xOwq_o.png" alt="图示" title="图示"></p> 
<p>经过计算得出，长度为 <code>3~8</code> 时，效果最好</p> 
<ul><li><strong>实际位图的大小为 <code>N * _len</code></strong></li></ul> 
<p>对原来的 <strong>布隆过滤器</strong> 进行修改，结合 <strong>误判率 与 空间</strong>，选择较为折中的 <code>6</code> 作为 <strong>布隆过滤器</strong> 的长度</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span>size_t N<span class="token punctuation">,</span>
		<span class="token keyword">class</span> <span class="token class-name">K</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span>
		<span class="token keyword">class</span> <span class="token class-name">Hash1</span> <span class="token operator">=</span> BKDRHash<span class="token punctuation">,</span>
		<span class="token keyword">class</span> <span class="token class-name">Hash2</span> <span class="token operator">=</span> APHash<span class="token punctuation">,</span>
		<span class="token keyword">class</span> <span class="token class-name">Hash3</span> <span class="token operator">=</span> DJBHash<span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">BloomFilter</span>
<span class="token punctuation">{<!-- --></span>
       <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> _len <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>   <span class="token comment">//布隆过滤器的长度</span>
       <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> _size <span class="token operator">=</span> N <span class="token operator">*</span> _len<span class="token punctuation">;</span> <span class="token comment">//位图的大小</span>
<span class="token keyword">public</span><span class="token operator">:</span>
       <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">const</span> K<span class="token operator">&amp;</span> key<span class="token punctuation">)</span>
       <span class="token punctuation">{<!-- --></span>
           size_t HashI1 <span class="token operator">=</span> <span class="token function">Hash1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> _size<span class="token punctuation">;</span>   <span class="token comment">//% N 是为了避免计算出的哈希值过大</span>
           _bits<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>HashI1<span class="token punctuation">)</span><span class="token punctuation">;</span>

           size_t HashI2 <span class="token operator">=</span> <span class="token function">Hash2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> _size<span class="token punctuation">;</span>
           _bits<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>HashI2<span class="token punctuation">)</span><span class="token punctuation">;</span>

           size_t HashI3 <span class="token operator">=</span> <span class="token function">Hash3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> _size<span class="token punctuation">;</span>
           _bits<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>HashI3<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>

       <span class="token keyword">bool</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">const</span> K<span class="token operator">&amp;</span> key<span class="token punctuation">)</span>
       <span class="token punctuation">{<!-- --></span>
           <span class="token comment">//过滤不存在的情况，至于是否存在，还得进一步判断</span>
           size_t HashI1 <span class="token operator">=</span> <span class="token function">Hash1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> _size<span class="token punctuation">;</span>
           <span class="token keyword">if</span> <span class="token punctuation">(</span>_bits<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>HashI1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
               <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

           size_t HashI2 <span class="token operator">=</span> <span class="token function">Hash2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> _size<span class="token punctuation">;</span>
           <span class="token keyword">if</span> <span class="token punctuation">(</span>_bits<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>HashI2<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
               <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

           size_t HashI3 <span class="token operator">=</span> <span class="token function">Hash3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> _size<span class="token punctuation">;</span>
           <span class="token keyword">if</span> <span class="token punctuation">(</span>_bits<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>HashI3<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
               <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

           <span class="token comment">//经过层层过滤后，判断字符串可能存在</span>
           <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	Yohifo<span class="token double-colon punctuation">::</span>bitset<span class="token operator">&lt;</span>_size<span class="token operator">&gt;</span> _bits<span class="token punctuation">;</span>	<span class="token comment">//位图结构</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>此时再来看看之前的测试：</p> 
<p><img src="https://images2.imgbox.com/94/3c/9c69FOxW_o.png" alt="图示" title="图示"></p> 
<p><strong>误判率降至 <code>5%</code> 左右</strong></p> 
<p>对于 <strong>用户登录时检测昵称是否存在</strong> 这件事上，已经足够用了</p> 
<p>如果想要最求更高的准度，可以使用 <strong>布隆过滤器 + 数据库</strong> 双重验证</p> 
<hr> 
<h3><a id="4_424"></a>4、布隆过滤器小结</h3> 
<p>总的来说，作为 <strong>哈希思想</strong> 的衍生品，<strong>布隆过滤器</strong> 实现了字符串的 <strong>快速查找与极致的空间利用</strong>，在需要判断字符串是否存在的场景中，判断 “不在”，是值得信赖的</p> 
<p><strong>优点：</strong></p> 
<ul><li><strong>查找效率极高，为 <code>O(K)</code>，其中 <code>K</code> 表示哈希函数的个数</strong></li><li><strong>哈希函数之间并没有直接关系，方便进行硬件计算</strong></li><li><strong>数据量很大时，布隆过滤器可以表示全集</strong></li><li><strong>可以利用多个布隆过滤器进行字符串的 交集、并集、差集运算</strong></li><li><strong>在可以容忍误判率的场景中，布隆过滤器优于其他数据结构</strong></li><li><strong>布隆过滤器中存储的数据无法逆向复原，具有一定的安全性</strong></li></ul> 
<p><strong>缺点：</strong></p> 
<ul><li><strong>存在一定的误判性</strong></li><li><strong>无法对元素本身进行操作，仅能判断存在与否</strong></li><li><strong>一般不支持删除功能</strong></li><li><strong>采取计数删除的方案时，可能存在 计数回绕 的问题</strong></li></ul> 
<p><strong>实际应用场景：</strong></p> 
<ul><li><strong>注册时对于 昵称、用户名、手机号的验证</strong></li><li><strong>减少磁盘 <code>IO</code> 或者网络请求，因为一旦一个值必定不存在的话，我们可以不用进行后续昂贵的查询请求</strong></li></ul> 
<p>总之，能被 <strong>布隆过滤器</strong> 拦截（过滤）下来的数据，一定是不存在的</p> 
<hr> 
<h3><a id="5_448"></a>5、海量数据面试题（哈希切割）</h3> 
<h4><a id="51_449"></a>5.1、题目一</h4> 
<blockquote> 
 <p><strong>给两个文件，分别有 <code>100</code> 亿个 <code>query</code>，我们只有 <code>1 GB</code> 内存，如何找到两个文件交集？分别给出<br> 精确算法和近似算法</strong></p> 
</blockquote> 
<p><code>query</code> 指 <strong>查询语句</strong>，比如 <strong>网络请求、<code>SQL</code> 语句等</strong>，假设一个 <code>query</code> 语句占 <code>50 Byte</code>，单个文件中的 <code>100</code> 亿个 <code>query</code> 占 <code>500 GB</code> 的空间，两个文件就是 <code>1000 GB</code></p> 
<p>下面来看看解法</p> 
<p>近似解法：<strong>借助布隆过滤器，先存储其中一个文件的 <code>query</code> 语句，这里给每个 <code>query</code> 语句分配 <code>4</code> 比特位，<code>100</code> 亿个就占约 <code>1 GB</code> 的内存，可以存下，存储完毕后，再从另一个文件读取 <code>query</code> 语句，判断是否在 布隆过滤器 中，“在” 的就是交集。因为 布隆过滤器 判断 “在” 不准确，符合题目要求的 近似算法</strong></p> 
<p>精确解法：<strong>对于这种海量数据，需要用到哈希分割，我们这里把单个文件（<code>500 GB</code> 数据）分割成 <code>1000</code> 个小文件，平均每个文件大小为 <code>512 Mb</code>，再将小文件读取到内存中；另一个文件也是如此，读取两个大文件中的小文件后，可以进行交集查找，再将所有小文件中的交集统计起来，就是题目所求的交集了</strong></p> 
<p><img src="https://images2.imgbox.com/af/a7/So99TxzK_o.png" alt="图示" title="图示"></p> 
<p>此时存在一个问题：<strong>如果我们是直接平均等分成 <code>1000</code> 个小文件的话，我们也不知道小文件中相似的 <code>query</code> 语句位置，是能把每个小文件都进行匹配对比，这样未免为太慢了</strong></p> 
<p>所以不能直接平均等分，需要使用 <strong>哈希分割</strong> 进行切分</p> 
<p><code>i = HashFunc(query) % 1000</code></p> 
<p>不同的 <code>query</code> 会得到不同的下标 <code>i</code>，这个下标 <code>i</code> 决定着这条 <code>query</code> 语句会被存入哪个小文件中，显然，一样的 <code>query</code> 语句计算出一样的下标，也就意味着它们会进入下标相同的小文件中，经过 <strong>哈希切割</strong> 后，只需要将 <strong>大文件 <code>A</code> 中的小文件 <code>0</code></strong> 与 <strong>大文件 <code>B</code> 中的小文件 <code>0</code></strong> 进行求 <strong>交集</strong> 的操作就行了，这样能大大提高效率</p> 
<p><img src="https://images2.imgbox.com/6a/d5/n1fOG8U1_o.png" alt="图示" title="图示"></p> 
<p>但是，此时存在一个 <strong>问题：如果因哈希值一致，而导致单个小文件很大呢？</strong></p> 
<p>此时如果小文件变成了 <code>1GB、2GB、3GB</code> 甚至更大，就无法被加载至内存中（算法还有消耗）</p> 
<p>解决方法很简单：<strong>借助不同的哈希函数再分割</strong></p> 
<p>即使在同一个小文件中，不同的 <code>query</code> 语句经过不同的 <strong>哈希函数</strong> 计算后，仍可错开，怕的是 <strong>存在大量重复的 <code>query</code></strong>，此时 <strong>哈希函数</strong> 就无法 <strong>分割</strong> 了，因为计算出的 <strong>哈希值</strong> 始终一致</p> 
<p><img src="https://images2.imgbox.com/fe/87/X5WUaBD1_o.png" alt="图示" title="图示"></p> 
<p>所以面对小文件过大的问题，目前有两条路可选：</p> 
<ol><li><strong>大多都是相同、重复的 <code>query</code>，无法分割，只能按照大小，放到其他小文件中</strong></li><li><strong>大多都是不相同的 <code>query</code>，可以使用 哈希函数 再分割</strong></li></ol> 
<p>这两条路都很好走，关键在于如何选择？<br> 小文件中实际的情况我们是无法感知的，但可以通过特殊手段得知：<strong>探测</strong></p> 
<p>对于大于 <code>512 Mb</code> 的小文件，我们可以对其进行读取，判断属于情况1、还是情况2</p> 
<ul><li><strong>首先准备一个 <code>unorder_set</code>，目的很简单：去重</strong></li><li><strong>读取文件中的 <code>query</code> 语句，存入 <code>unordered_set</code> 中</strong></li><li><strong>如果小文件读取结束后，没有发生异常情况，说明属于情况1：大多都是相同、重复的 <code>query</code> 语句，把这些重复率高的数据打散，放置其他 <code>512 Mb</code> 的小文件中</strong></li><li><strong>如果小文件读取过程中，出现了一个异常，捕获结果为 <code>bad_alloc</code>，说明读取到的大多都是不重复的 <code>query</code> 语句，因为我们内存只有 <code>1 GB</code>，抛出的异常是 <code>内存爆了</code>，异常的抛出意味着这个小文件属于情况2，可以使用其他的 哈希函数 对其进行再分割，分成 <code>512 Mb</code> 的小文件</strong></li></ul> 
<p>如此一来，这个文件就被解决了，核心在于：<strong>利用哈希切割将数据分为有特性的小文件、利用抛异常得知小文件的实际情况</strong></p> 
<h4><a id="52_500"></a>5.2、题目二</h4> 
<blockquote> 
 <p><strong>给一个超过 <code>100 GB</code>大小的 <code>log file</code>, <code>log</code> 中存着 <code>IP</code> 地址, 设计算法找到出现次数最多的 <code>IP</code> 地址？</strong></p> 
</blockquote> 
<p>这题本质上也是在考 <strong>哈希分割</strong>，将 <code>log file</code> 文件中的 <code>IP</code> 地址看作上一题中的 <code>query</code> 语句，得知文件大小约为 <code>500 GB</code></p> 
<p><strong>因为这里没有内存限制，我们可以将其分为 <code>500</code> 个小文件，每个小文件大小为 <code>1 GB</code></strong></p> 
<p><img src="https://images2.imgbox.com/9d/f6/Tad4JFG1_o.png" alt="图示" title="图示"><br> 这里分为小文件的目的是 <strong>让相同的 <code>IP</code> 分至同一个小文件中</strong></p> 
<p>针对较大的小文件，依然采取 <strong>其他哈希函数继续分割</strong> 或 <strong>分给其他小文件的做法</strong></p> 
<p>读取单个小文件时，利用 <code>unordered_map</code> 统计 <code>IP</code> 地址的出现次数，读取完毕后，遍历 <code>unordered_map</code> 即可得知出现次数最多的 <code>IP</code> 地址</p> 
<blockquote> 
 <p><strong>与上题条件相同，如何找到 <code>Top K</code> 的 <code>IP</code> ？如何直接用 <code>Linux</code> 系统命令实现？</strong></p> 
</blockquote> 
<p>涉及 <code>Top K</code> 的问题都可以通过 <strong>优先级队列（堆）</strong> 解决，在第一问的基础上，构建一个大小为 <code>K</code> 的 <strong>小堆</strong>，将高频出现的 <code>IP</code> 地址入堆，筛选出 <code>Top K</code> 个 <code>IP</code> 即可</p> 
<p>至于如何利用 <code>Linux</code> 命令解决？</p> 
<pre><code class="prism language-bash"><span class="token function">sort</span> log_file <span class="token operator">|</span> <span class="token function">uniq</span> <span class="token parameter variable">-c</span> <span class="token operator">|</span> <span class="token function">sort</span> -nrk1,1 <span class="token operator">|</span> <span class="token function">head</span> <span class="token parameter variable">-K</span>
</code></pre> 
<p>解释：</p> 
<ul><li><code>sort log_file</code> <strong>表示对 <code>log_file</code> 文件进行排序</strong></li><li><code>uniq -c</code> <strong>表示统计出其中每个 <code>IP</code> 的出现次数</strong></li><li><code>sort -nrk1,1</code> <strong>表示按照每个 <code>IP</code> 的出现次数再进行排序</strong></li><li><code>head -k</code> <strong>表示选择前 <code>k</code> 个 <code>IP</code> 地址显示</strong></li></ul> 
<p><mark>注意：</mark> <strong>以上操作都需要借助管道 <code>|</code> 因为它们都是有关联性的</strong></p> 
<hr> 
<h2><a id="_538"></a>🌆总结</h2> 
<p><strong>以上就是本次关于 C++ 哈希的应用【布隆过滤器】的全部内容了，在本文中我们主要学习了布隆过滤器的相关知识，再一次对哈希思想有了更深层次的理解（多组映射），在简单模拟实现布隆过滤器之后，顺便解决了几道海量数据面试题，从中学到了哈希分割这一重要思想，哈希是一个被高频使用的工具，因为它实在是太香了，想要玩的更溜，还需要勤加练习</strong></p> 
<hr> 
<p><img src="https://images2.imgbox.com/24/e0/d4vCRffa_o.jpg" alt="星辰大海"></p> 
<blockquote> 
 <p><strong></strong></p> 
 <center>
   相关文章推荐 
 </center> 
 <p></p> 
 <p><strong></strong></p> 
 <center> 
  <mark>C++ 进阶知识</mark> 
 </center> 
 <p></p> 
 <p><strong></strong></p> 
 <center> 
  <a href="https://blog.csdn.net/weixin_61437787/article/details/131920305?spm=1001.2014.3001.5501">C++ 哈希的应用【位图】</a> 
 </center> 
 <p></p> 
 <p><strong></strong></p> 
 <center> 
  <a href="https://blog.csdn.net/weixin_61437787/article/details/131571080?spm=1001.2014.3001.5501">C++【哈希表的完善及封装】</a> 
 </center> 
 <p></p> 
 <p><strong></strong></p> 
 <center> 
  <a href="https://blog.csdn.net/weixin_61437787/article/details/131628089?spm=1001.2014.3001.5501">C++【哈希表的模拟实现】</a> 
 </center> 
 <p></p> 
 <p><strong></strong></p> 
 <center> 
  <a href="https://blog.csdn.net/weixin_61437787/article/details/131492507?spm=1001.2014.3001.5501">C++【初识哈希】</a> 
 </center> 
 <p></p> 
 <p><strong></strong></p> 
 <center> 
  <a href="https://blog.csdn.net/weixin_61437787/article/details/131349979?spm=1001.2014.3001.5501">C++【一棵红黑树封装 set 和 map】</a> 
 </center> 
 <p></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/307962170ba4af85404159ba4c04e4f1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python 日志记录：6大日志记录库的比较</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9f929973983ad87e9eed20feade719e4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Mac 安装配置adb命令环境（详细步骤）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>