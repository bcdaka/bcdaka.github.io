<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法思想总结：哈希表 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/05899385ba72c74a0787299f01003dc9/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="算法思想总结：哈希表">
  <meta property="og:description" content="一、哈希表剖析 1、哈希表底层：通过对C&#43;&#43;的学习，我们知道STL中哈希表底层是用的链地址法封装的开散列。
2、哈希表作用：存储数据的容器，插入、删除、搜索的时间复杂度都是O（1），无序。
3、什么时候使用哈希表：需要频繁查找数据的场景。
4、OJ中如何使用哈希表？？？
（1）STL中的容器（适用所有场景，比如字符串相关、数据映射下标）
（2）数组模拟简易哈希表（减小时间损耗，容器的封装有一定代价）—&gt;大多以下两种情况适用
情况1：（char）涉及到字符串中的“字符” ，hash[26]可以映射所有的字母。
情况2：（int）数据范围较小的时候
二、两数之和 . - 力扣（LeetCode）
解法2代码： class Solution { public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { unordered_map&lt;int,int&gt; hash; //数值和下标的映射关系 int n=nums.size(); for(int i=0;i&lt;n;&#43;&#43;i) { int x=target-nums[i]; if(hash.count(x)) return {hash[x],i}; hash[nums[i]]=i; } return {-1,-1}; } }; 三、判定是否互为字符重排 . - 力扣（LeetCode）
解法2代码：
class Solution { public: bool CheckPermutation(string s1, string s2) { //小优化 if(s1.size()!=s2.size()) return false; //用哈希表 int hash[26]={0}; for(char&amp;ch:s1) &#43;&#43;hash[ch-&#39;a&#39;]; //检测第二个数组 for(char&amp;ch:s2) if(--hash[ch-&#39;a&#39;]&lt;0) return false; return true; } }; 四、存在重复元素I .">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-01T23:38:36+08:00">
    <meta property="article:modified_time" content="2024-06-01T23:38:36+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法思想总结：哈希表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="text-align:center;"><img alt="" height="308" src="https://images2.imgbox.com/53/97/qszWP9SP_o.gif" width="600"></h2> 
<h2>一、哈希表剖析</h2> 
<p>1、哈希表底层：通过对C++的学习，我们知道<span style="color:#fe2c24;"><strong>STL中哈希表底层是用的链地址法封装的开散列</strong></span>。</p> 
<p>2、哈希表作用：<span style="color:#fe2c24;"><strong>存储数据的容器，插入、删除、搜索的时间复杂度都是O（1），无序。</strong></span></p> 
<p>3、什么时候使用哈希表：<span style="color:#fe2c24;"><strong>需要频繁查找数据的场景。</strong></span></p> 
<p><span style="color:#0d0016;">4、OJ中如何使用哈希表？？？</span></p> 
<p><span style="color:#fe2c24;"><strong>（1）STL中的容器（适用所有场景，比如字符串相关、数据映射下标）</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>（2）数组模拟简易哈希表（减小时间损耗，容器的封装有一定代价）—&gt;大多以下两种情况适用</strong></span></p> 
<p>情况1：（char）涉及到字符串中的“字符” ，hash[26]可以映射所有的字母。</p> 
<p>情况2：（int）数据范围较小的时候</p> 
<h2>二、两数之和</h2> 
<p><a href="https://leetcode.cn/problems/two-sum/description/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
<p><img alt="" height="718" src="https://images2.imgbox.com/8d/87/s4wZZ7ew_o.png" width="1200"></p> 
<p>解法2代码： </p> 
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target)
    {
        unordered_map&lt;int,int&gt; hash; //数值和下标的映射关系
        int n=nums.size();
        for(int i=0;i&lt;n;++i)
        {
            int x=target-nums[i];
            if(hash.count(x)) return {hash[x],i};
            hash[nums[i]]=i;
        }
        return {-1,-1};
    }
};</code></pre> 
<h2> 三、判定是否互为字符重排</h2> 
<p><a href="https://leetcode.cn/problems/check-permutation-lcci/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
<p><img alt="" height="561" src="https://images2.imgbox.com/a2/c7/oYQI4dyQ_o.png" width="1200"></p> 
<p> 解法2代码：</p> 
<pre><code class="language-cpp">class Solution {
public:
    bool CheckPermutation(string s1, string s2) 
    {
        //小优化
        if(s1.size()!=s2.size()) return false;
        //用哈希表
        int hash[26]={0};
        for(char&amp;ch:s1) ++hash[ch-'a'];
        //检测第二个数组
        for(char&amp;ch:s2)  if(--hash[ch-'a']&lt;0)  return false;
        return true;
    }
};</code></pre> 
<h2>四、存在重复元素I</h2> 
<p><a href="https://leetcode.cn/problems/contains-duplicate/description/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
<p><img alt="" height="645" src="https://images2.imgbox.com/6f/06/bjG1cc3v_o.png" width="1200"></p> 
<p>解法2代码：</p> 
<pre><code class="language-cpp">class Solution {
public:
    bool containsDuplicate(vector&lt;int&gt;&amp; nums) {
       unordered_set&lt;int&gt; hash; //有负数，所以必须用库里面的哈希表
       for(auto&amp;e:nums) 
            if(hash.count(e)) return true;
              else hash.insert(e);
         return false;
    }
};</code></pre> 
<h2> 五、存在重复元素II</h2> 
<p><a href="https://leetcode.cn/problems/contains-duplicate-ii/description/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
<p><img alt="" height="679" src="https://images2.imgbox.com/8e/56/uwSzZZdZ_o.png" width="1200"></p> 
<p>解法1代码：</p> 
<pre><code class="language-cpp">class Solution {
public:
    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) 
    {
        unordered_map&lt;int,size_t&gt; hash;//数值和下标的映射
        size_t n=nums.size();
        for(size_t i=0;i&lt;n;++i)
        {
            //如果哈希表中有这个数
            if(hash.count(nums[i])&amp;&amp;i-hash[nums[i]]&lt;=k) return true;
            hash[nums[i]]=i;//存下标的映射
        }
        return false;
    }
};</code></pre> 
<p>解法2代码：</p> 
<pre><code class="language-cpp">class Solution {
public:
    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) {
    //滑动窗口解题，让set始终保存着k个元素，如果发现了区间内有重复元素，那么就可以返回true
    unordered_set&lt;int&gt; s;
    size_t n=nums.size();
    for(size_t i=0;i&lt;n;++i)
    {
        if(s.count(nums[i])) return true;
        s.emplace(nums[i]);//不断将数字丢进去
        if(i&gt;=k) s.erase(nums[i-k]); //窗口超出区间了，就将最前面那个给删掉
    }
    return false;
    }
};</code></pre> 
<h2>六、存在重复元素III(经典)</h2> 
<p><a href="https://leetcode.cn/problems/contains-duplicate-iii/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
<p><img alt="" height="809" src="https://images2.imgbox.com/d9/56/5KcGtcf1_o.png" width="1200"></p> 
<p> 解法1代码：</p> 
<pre><code class="language-cpp">class Solution {
public:
    //绝对值尽量拆解掉
    //滑动窗口解决问题（控制区间）  需要支持插入、查找、删除  尽可能有序 set
    //k是下标的差值  t是元素的差值
    bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) 
    {
        //lower_bound 利用二分找到第一个&gt;=num的迭代器 降序就是&lt;=
        //upper_bound 利用二分找到第一个&gt;num的迭代器  降序就是&lt;
        set&lt;long&gt; s;//需要一个有序集合
        for(size_t i=0;i&lt;nums.size();++i)
           { 
             //在下标范围为 [max(0,i−k),i] 内找到值范围在 [u−t,u+t]的数。
             set&lt;long&gt;::iterator it=s.lower_bound((long)nums[i]-t);
             if(it!=s.end()&amp;&amp;*it&lt;=(long)nums[i]+t) return true;
             s.insert(nums[i]);
             if(i&gt;=k)  s.erase(nums[i - k]);
           }
           return false;
    }
};</code></pre> 
<p> 思路2：分桶（非常精巧的思路）</p> 
<p>思路来源：<a href="https://leetcode.cn/problems/contains-duplicate-iii/solutions/727120/c-li-yong-tong-fen-zu-xiang-xi-jie-shi-b-ofj6" rel="nofollow" title=".  - 力扣（LeetCode）分桶思路详细讲解">. - 力扣（LeetCode）分桶思路详细讲解</a></p> 
<p>     因为这个思路来源写得非常的详细，所以直接看就行，以往我们的分桶，更多的是针对整数的分桶，但是在该题中，扩展了存在负数的时候如何分桶，保证每个桶内的元素个数是一样的。这是一种非常巧妙的方法！！！要结合具体的实例去看！！</p> 
<p>核心思路：<span style="color:#fe2c24;"><strong>保证每个桶内的绝对值相差小于t，k个桶。当我们遍历到这个数的时候，如果对应的桶的存在，就是true，如果相邻桶存在，看看差值是否符合要求。每个桶中只会有一个元素，因为有多的我们就会直接返回结果。</strong></span></p> 
<pre><code class="language-cpp">class Solution {
public:
    int getid(long u,long t)
    {
        return u&gt;=0?u/(t+1):(u+1)/(t+1)-1;
    }
    bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) 
    {
      //桶排序   
      size_t n=nums.size();
      //分成k个桶  每个桶的大小是t+1 (0,1,2,3) -&gt;保证一个桶里面是符合的
      unordered_map&lt;int,int&gt; hash;  //第一个是存id  第二个是存元素
      for(size_t i=0;i&lt;n;++i)
      {
        long u=nums[i];
        int id= getid(u,t); //找编号
        //看看当前桶存不存在
        if(hash.count(id)) return true;
        //看看相邻桶在不在，如果在的话 就看看差值
        if(  hash.count(id-1)&amp;&amp;u-hash[id-1]&lt;=t
           ||hash.count(id+1)&amp;&amp;hash[id+1]-u&lt;=t) return true;
        if(i&gt;=k) hash.erase(getid(nums[i-k],t));//桶数多了，就去掉一个
        hash[id]=u;//开新的桶
      }
      return false;
    }
};</code></pre> 
<h2>七、字母异位词分组(经典)</h2> 
<p><a href="https://leetcode.cn/problems/group-anagrams/description/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
<p><img alt="" height="645" src="https://images2.imgbox.com/a6/c0/B4AIZHCo_o.png" width="929"></p> 
<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) {
        //字母异位词-&gt;排序后都是相同的
        unordered_map&lt;string,vector&lt;string&gt;&gt; hash; //将异位词绑定起来
        for(auto&amp;s:strs)
         {
            string temp=s;
            sort(temp.begin(),temp.end());
            hash[temp].emplace_back(s);
         }
         //提取出来
         vector&lt;vector&lt;string&gt;&gt; ret;
         for(auto&amp;[x,y]:hash)  ret.emplace_back(y); //取哈希表中键值对的方法C++14支持
         //for(auto&amp;kv:hash)  ret.push_back(kv.second);
         return ret;
    }
};</code></pre> 
<h2 style="background-color:transparent;">八、前K个高频单词（经典）</h2> 
<p> <a href="https://leetcode.cn/problems/top-k-frequent-words/description/" rel="nofollow" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p> 
<p><img alt="" height="634" src="https://images2.imgbox.com/37/af/eS46moRV_o.png" width="910"></p> 
<p><span style="color:#fe2c24;"><strong>解法1：map+vector+稳定排序+lambda优化</strong></span><br>           map的底层是红黑树，插入的时候map&lt;string,int&gt; 会按照字典序排好，而我们现在要按照出现次序去排序，同时对于出现次数相同的保证字典序在前面，所以我们其中之一的策略就是vector+sort ,但是sort底层是快排，并不具备稳定性，但是库里面有一个stable_sort是稳定的排序</p> 
<pre><code class="language-cpp">class Solution {
public:
     typedef pair&lt;string,int&gt; PSI;
    vector&lt;string&gt; topKFrequent(vector&lt;string&gt;&amp; words, int k) 
    {
        map&lt;string,int&gt; countmap;//计数
        for(auto&amp;s:words) ++countmap[s];
        //此时已经按照字典序排好了，将其拷贝到vector中
        vector&lt;PSI&gt; nums(countmap.begin(),countmap.end());
        //要用一个稳定的排序 我们排序的是比较value，所以要修改比较逻辑
        stable_sort(nums.begin(),nums.end(),
        [](const PSI&amp;kv1,const PSI&amp;kv2) {return kv1.second&gt;kv2.second;});
        vector&lt;string&gt; ret(k);
        for(int i=0;i&lt;k;++i)  ret[i]=nums[i].first;
        return ret;
    }
};</code></pre> 
<p><span style="color:#fe2c24;"><strong>解法2：unordered_map+vector+sort+调整比较逻辑+lambda优化 </strong></span></p> 
<pre><code class="language-cpp">class Solution {
public:
    typedef pair&lt;string,int&gt; PSI;
    vector&lt;string&gt; topKFrequent(vector&lt;string&gt;&amp; words, int k) 
    {
        unordered_map&lt;string,int&gt; countmap;//计数
        for(auto&amp;s:words) ++countmap[s];
        //此时已经按照字典序排好了，将其拷贝到vector中
        vector&lt;PSI&gt; nums(countmap.begin(),countmap.end());
        //要用一个稳定的排序 我们排序的是比较value，所以要修改比较逻辑
        sort(nums.begin(),nums.end(),
        [](const PSI&amp;kv1,const PSI&amp;kv2){ 
            return kv1.second&gt;kv2.second||(kv1.second==kv2.second&amp;&amp;kv1.first&lt;kv2.first);});
        vector&lt;string&gt; ret(k);
        for(int i=0;i&lt;k;++i)  ret[i]=nums[i].first;
        return ret;
    }
};</code></pre> 
<p>上面两种解法都是借助vector容器+sort去解决的。</p> 
<p> <span style="color:#fe2c24;"><strong>解法3：unordered_map+priority_queue+compare类</strong></span></p> 
<pre><code class="language-cpp">class Solution {
public:
   typedef pair&lt;string,int&gt; PSI;
    struct compare//要注意仿函数要+const修饰，否则可能编译不过
     {
        bool operator()(const PSI&amp;kv1,const PSI&amp;kv2) const
        {
            if(kv1.second==kv2.second) return kv1.first&lt;kv2.first;
            return kv1.second&gt;kv2.second;
        }
     };
    vector&lt;string&gt; topKFrequent(vector&lt;string&gt;&amp; words, int k) 
    {
        unordered_map&lt;string,int&gt; countmap;//计数
        for(auto&amp;s:words) ++countmap[s];
        //丢到优先级队列里
        priority_queue&lt;PSI,vector&lt;PSI&gt;,compare&gt; heap;
        for (auto&amp; it : countmap) {
            heap.push(it);
            if (heap.size() &gt; k) heap.pop();
        }
        vector&lt;string&gt; ret(k);
       for(int i=k-1;i&gt;=0;--i) 
        {
            ret[i]=heap.top().first;
            heap.pop();
        }
       return ret;
    }
};</code></pre> 
<p><span style="color:#fe2c24;"><strong> 解法4：unordered_map+multiset+compare类</strong></span></p> 
<pre><code class="language-cpp">class Solution {
public:
   typedef pair&lt;string,int&gt; PSI;
    struct compare//要注意仿函数要+const修饰，否则可能编译不过
     {
        bool operator()(const PSI&amp;kv1,const PSI&amp;kv2) const
        {
            return kv1.second&gt;kv2.second||(kv1.second==kv2.second&amp;&amp;kv1.first&lt;kv2.first);
        }
     };
    vector&lt;string&gt; topKFrequent(vector&lt;string&gt;&amp; words, int k) 
    {
        unordered_map&lt;string,int&gt; countmap;//计数
        for(auto&amp;s:words) ++countmap[s];
        multiset&lt;PSI,compare&gt; sortmap(countmap.begin(),countmap.end());
        vector&lt;string&gt; ret(k);
        multiset&lt;PSI,compare&gt;::iterator it=sortmap.begin();
        size_t i=0;
        while(k--) 
        {
            ret[i++]=it-&gt;first;
            ++it;
        }
    return ret;
    }
};</code></pre> 
<p><span style="color:#fe2c24;"><strong> 解法5：map+multimap+compare类（能过 但这是巧合）</strong></span></p> 
<p><span style="color:#0d0016;">       这题能过的原因是map实现了字典序的排序。而底层的multimap封装中对于相同的键值是优先插入到其右侧。</span></p> 
<pre><code class="language-cpp">class Solution {
public:
     struct compare//要注意仿函数要+const修饰，否则可能编译不过
     {
        bool operator()(const int&amp;k1,const int&amp;k2) const
        {
            return k1&gt;k2;
        }
     };
    vector&lt;string&gt; topKFrequent(vector&lt;string&gt;&amp; words, int k) 
    {
        map&lt;string,int&gt; countmap;//计数
        for(auto&amp;s:words) ++countmap[s];
        multimap&lt;int,string,compare&gt; sortmap;
        for(auto &amp;kv:countmap) sortmap.insert(make_pair(kv.second,kv.first));
        vector&lt;string&gt; ret(k);
        auto it=sortmap.begin();
        size_t i=0;
        while(k--) 
        {
            ret[i++]=it-&gt;second;
            ++it;
        }
    return ret;
    }
};</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/36/33/py4yUjzM_o.jpg"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/01ed3872366b093bac96a1791e4bd81a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HR青睐的数据库热门考题——事务</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4c9167474270776e966102823f7c1291/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">深入分析 Android Service (完)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>