<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【MySQL基础篇】多表查询 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/973630fae0aed9a5c0664c3d593fd817/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【MySQL基础篇】多表查询">
  <meta property="og:description" content="1、多表关系 概述：项目开发中，在进行数据库表结构操作设计时，会根据业务需求及业务模板之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：
一对多（多对一）
多对多
一对一
· 一对多（多对一）
案例：部门与员工的关系（一个部门对应多个员工，一个员工对应一个部门）
实现：在多的一方建立外键，指向一的一方的主键
· 多对多
案例：学生与课程的关系（一个学生可以选修多门课程，一门课程可以共多个学生选择）
实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键
create table student( id int primary key auto_increment comment &#39;主键ID&#39;, name varchar(10) comment &#39;姓名&#39;, no varchar(10) comment &#39;学号&#39; )comment &#39;学生表&#39;; insert into student values(null,&#39;黛丽丝&#39;,&#39;2000100101&#39;),(null,&#39;谢逊&#39;,&#39;2000100102&#39;),(null,&#39;殷天正&#39;,&#39;2000100103&#39;),(null,&#39;韦一笑&#39;,&#39;2000100104&#39;); create table course( id int primary key auto_increment comment &#39;主键ID&#39;, name varchar(10) comment &#39;课程名称&#39; )comment &#39;课程表&#39;; insert into course values(null,&#39;java&#39;),(null,&#39;php&#39;),(null,&#39;mysql&#39;),(null,&#39;hadoop&#39;); create table student_course( id int primary key auto_increment comment &#39;主键ID&#39;, studentid int not null comment &#39;学生ID&#39;, courseid int not null comment &#39;课程ID&#39;, constraint fk_courseid foreign key (courseid) references course (id), constraint fk_studentid foreign key (studentid) references student (id) )comment &#39;课程中间表&#39;; insert into student_course values(null,1,1),(null,1,2),(null,1,3),(null,2,2),(null,2,3),(null,3,4); · 一对一">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-08T20:31:28+08:00">
    <meta property="article:modified_time" content="2024-07-08T20:31:28+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【MySQL基础篇】多表查询</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1、多表关系</h2> 
<p>概述：项目开发中，在进行数据库表结构操作设计时，会根据业务需求及业务模板之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：</p> 
<blockquote> 
 <p>一对多（多对一）</p> 
 <p>多对多</p> 
 <p>一对一</p> 
</blockquote> 
<p><strong> · </strong>一对多（多对一）</p> 
<p>案例：部门与员工的关系（一个部门对应多个员工，一个员工对应一个部门）</p> 
<p>实现：在多的一方建立外键，指向一的一方的主键</p> 
<p><strong>· </strong>多对多</p> 
<p>案例：学生与课程的关系（一个学生可以选修多门课程，一门课程可以共多个学生选择）</p> 
<p>实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p> 
<pre><code class="language-sql">create table student(
    id int primary key auto_increment comment '主键ID',
    name varchar(10) comment '姓名',
    no varchar(10) comment '学号'
)comment '学生表';
insert into student values(null,'黛丽丝','2000100101'),(null,'谢逊','2000100102'),(null,'殷天正','2000100103'),(null,'韦一笑','2000100104');
create table course(
    id int primary key auto_increment comment '主键ID',
    name varchar(10) comment '课程名称'
)comment '课程表';
insert into course values(null,'java'),(null,'php'),(null,'mysql'),(null,'hadoop');
create table student_course(
    id int primary key auto_increment comment '主键ID',
    studentid int not null comment '学生ID',
    courseid int not null comment '课程ID',
    constraint fk_courseid foreign key (courseid) references course (id),
    constraint fk_studentid foreign key (studentid) references student (id)
)comment '课程中间表';
insert into student_course values(null,1,1),(null,1,2),(null,1,3),(null,2,2),(null,2,3),(null,3,4);</code></pre> 
<p><img alt="" height="611" src="https://images2.imgbox.com/e8/74/annzJgRe_o.png" width="1200"></p> 
<p><strong>·  </strong>一对一</p> 
<p>案例：用户与用户详情的关系（一对一关系多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率）</p> 
<p>实现：在任一方加入外键，关联另一方的主键，并且设置外键为唯一的（UNIQUE）</p> 
<pre><code class="language-sql">create table tb_user(
    id int primary key auto_increment comment '主键ID',
    name varchar(10) comment '姓名',
    age int comment '年龄',
    gender varchar(1) comment '性别',
    phone char(11) comment '电话'
)comment '用户基本信息表';
create table tb_user_edu(
    id int primary key auto_increment comment '主键ID',
    degree varchar(20) comment '学历',
    major varchar(50) comment '专业',
    primaryschool varchar(50) comment '小学',
    middleschool varchar(50) comment '中学',
    university varchar(50) comment '大学',
    userid int unique comment '用户ID',
    constraint fk_userid foreign key (userid) references tb_user(id)
)comment '用户教育信息表';
insert into tb_user values
                        (null,'黄渤',45,'1','18903944771'),
                        (null,'冰冰',32,'2','18903955771'),
                        (null,'马云',55,'1','17719224870'),
                        (null,'李彦宏',50,'1','15538655111');
insert into tb_user_edu values
                            (null,'本科','舞蹈','静安区第一小学','静安区第一中学','北京舞蹈学院',1),
                            (null,'硕士','表演','朝阳区第一小学','朝阳区第一中学','北京电影学院',2),
                            (null,'本科','英语','杭州市第一小学','杭州市第一中学','杭州师范大学',3),
                            (null,'本科','应用数学','阳泉区第一小学','阳泉区第一中学','清华大学',4);</code></pre> 
<h2>2、多表查询概述 </h2> 
<p> 概述：指从多张表中查询数据</p> 
<p>案例：我们用员工与所属部门来作为案例</p> 
<pre><code class="language-sql">select * from emp,dept;</code></pre> 
<p><img alt="" height="306" src="https://images2.imgbox.com/f6/06/cXC8LElq_o.png" width="1200"> 但问题是我们明明只有五条数据却显示了25行信息，这种现象称为笛卡尔积。</p> 
<p>笛卡尔积：在数学中两个集合，A集合和B集合的所有组合情况。（在多表查询时，需要消除无效的笛卡尔积）</p> 
<pre><code class="language-sql">select * from emp,dept where emp.dept_id=dept.id;</code></pre> 
<p> 多表查询分类</p> 
<p><strong>· </strong>连接查询</p> 
<blockquote> 
 <p>        内连接：相当于查询A、B交集部分的数据</p> 
 <p>        外连接：</p> 
 <p>                   左外连接：查询左表所有数据，以及两张表交际部分数据</p> 
 <p>                   右外连接：查询右表所有数据，以及两张表交际部分数据</p> 
 <p>        自连接：当前表与自身的连接查询，自连接必须使用表别名</p> 
</blockquote> 
<p><strong>· </strong>子查询</p> 
<h2>3、内连接查询 </h2> 
<p>内连接查询语法：</p> 
<p>隐式内连接：</p> 
<blockquote> 
 <p> SELECT 字段列表 FROM 表1，表2 WHERE 条件 ...;</p> 
</blockquote> 
<p>显示内连接： </p> 
<blockquote> 
 <p>SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件 ...;</p> 
</blockquote> 
<p><span style="background-color:#ff9900;">内连接查询的是两张表的交集部分 </span></p> 
<pre><code class="language-sql">#内连接演示
#1、查询每一个员工的姓名，及关联部门的名称（隐式内连接实现）
#连接条件：emp.dept_id=dept.id
select emp.name,dept.name from emp,dept where emp.dept_id=dept.id;
#2、查询每一个员工的姓名，及关联部门的名称（显示内连接实现）--关键字：INNER JOIN ... ON ...
select emp.name,dept.name from emp inner join dept on emp.dept_id = dept.id;</code></pre> 
<h2>4、外连接查询 </h2> 
<p>外连接查询语法：</p> 
<p>左外连接：</p> 
<blockquote> 
 <p>SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件 ...;</p> 
</blockquote> 
<p>查询的是左表的所有数据包含两表交集部分的数据 </p> 
<p>右外连接： </p> 
<blockquote> 
 <p>SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件 ...;</p> 
</blockquote> 
<p>查询的是右表的所有数据包含两表交集部分的数据 </p> 
<pre><code class="language-sql">#左外连接和右外连接
#1、查询emp表的所有数据，和对应部门的信息（左外连接）
select * from emp left outer join dept on emp.dept_id = dept.id;
#2、查询dept表的所有数据，和对应员工信息（右外连接）
select * from dept right outer join emp on dept.id = emp.dept_id;</code></pre> 
<h2>5、自连接查询</h2> 
<p>自连接查询语法：</p> 
<blockquote> 
 <p>SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...; </p> 
</blockquote> 
<p>自连接查询，可以是内连接查询，也可以是外连接查询。 </p> 
<pre><code class="language-sql">#自连接
#1、查询员工及其所属领导的名字
select a.name,b.name from emp a,emp b where a.managerid=b.id;
#2、查询所有员工 emp 及其领导的名字 emp，如果员工没有领导也要查询出来
select a.name,b.name from emp a left join emp b on a.managerid=b.id;</code></pre> 
<h2>6、联合查询 </h2> 
<p> 联合查询-union，union all</p> 
<p>对于联合查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。</p> 
<blockquote> 
 <p>SELECT 字段列表 FROM 表A ...</p> 
 <p>UNION [ALL]</p> 
 <p>SELECT 字段列表 FROM 表B ...;</p> 
</blockquote> 
<pre><code class="language-sql">#联合查询
#将薪资低于10000的员工，和年龄大于50岁的员工全部查询出来
select * from emp where salary&lt;10000
union all
select * from emp where age&gt;50;
#对查询结果去重
select * from emp where salary&lt;10000
union 
select * from emp where age&gt;50;</code></pre> 
<p> 总结：对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致；</p> 
<p>union all会将全部的数据直接合并在一起，union会对合并之后的数据去重。</p> 
<h2>7、子查询</h2> 
<p> 概念：SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。</p> 
<blockquote> 
 <p>SELECT * FROM t1 WHERE column1=(SELECT column1 FROM t2);</p> 
</blockquote> 
<p>子查询外部的语句可以是INSERT/UPDATE/DELETE/SELECT 的任何一个。</p> 
<p>根据子查询的结果不同，分为：</p> 
<blockquote> 
 <p>标量子查询（子查询结果为单个值）</p> 
 <p>列子查询（子查询结果为一列）</p> 
 <p>行子查询（子查询结果为一行）</p> 
 <p>表子查询（子查询结果为多行多列）</p> 
</blockquote> 
<p>根据子查询位置，分为：WHERE之后、FROM之后、SELECT之后。</p> 
<h3>标量子查询 </h3> 
<p>子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询称为标量子查询。</p> 
<p>常用的操作符：=  &lt;&gt;  &gt;  &gt;=  &lt;  &lt;=</p> 
<pre><code class="language-sql">#标量子查询
#1、查询研发部所有员工信息
#第一步：查询研发部部门ID
select id from dept where name='研发部';
#第二步：根据研发部部门ID查询员工信息
select * from emp where dept_id=1;
select * from emp where dept_id=(select id from dept where name='研发部');
#2、查询在”杨逍“入职之后的员工信息
#第一步：查询”杨逍“的入职日期
select entrydate from emp where name='杨逍';
#第二步：查询指定日期之后入职员工的信息
select * from emp where entrydate &gt; '2000-11-03';
select * from emp where entrydate &gt;(select entrydate from emp where name='杨逍');</code></pre> 
<h3>列子查询 </h3> 
<p>子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。</p> 
<p>常用操作符：IN、NOT IN、ANY、SOME、ALL</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td>操作符</td><td>描述</td></tr><tr><td>IN</td><td>在指定的集合范围之内，多选一</td></tr><tr><td>NOT IN</td><td>不在指定的集合范围之内</td></tr><tr><td>ANY</td><td>子查询返回列表中，有任意一个满足即可</td></tr><tr><td>SOME</td><td>与ANY等同，使用SOME的地方都可以使用ANY</td></tr><tr><td>ALL</td><td>子查询返回列表的所有值都必须满足</td></tr></tbody></table> 
<pre><code class="language-sql">#列子查询
#1、查询”总经办“和”研发部“所有员工的信息
#第一步：查询总经办和研发部的部门ID
select id from dept where name='总经办'||name='研发部';
#第二步：根据部门ID，查询员工信息
select * from emp where dept_id in (5,1);
select * from emp where dept_id in(select id from dept where name='总经办'||name='研发部');
#2、查询比研发部所有员工工资都高的员工信息
#第一步：查询研发部部门工资
select id from dept where name='研发部';
select salary from emp where dept_id=1;
select salary from emp where dept_id=(select id from dept where name='研发部');
#第二步：比研发部所有员工工资都高的员工信息
select * from emp where salary &gt; all(select salary from emp where dept_id=(select id from dept where name='研发部'));
#3、查询比研发部其中任意一人工资高的员工信息
#第一步：查询研发部所有员工的工资
select salary from emp where dept_id=(select id from dept where name='研发部');
#第二步：比研发部其中任意一人工资高的信息
select * from emp where salary &gt; any(select salary from emp where dept_id=(select id from dept where name='研发部'));</code></pre> 
<h3>行子查询 </h3> 
<p> 子查询的结果是一行（可以是多列），这种查询就称行子查询。</p> 
<p>常用操作符：= 、&lt;&gt;、IN、NOT IN</p> 
<pre><code class="language-sql">#行子查询
#1、查询与”张无忌“的薪资及所属领导相同的员工信息
#第一步：查询张无忌的薪资及直属领导
select salary,emp.managerid from emp where name='张无忌';
#第二步：查询与”张无忌“的薪资及所属领导相同的员工信息
select * from emp where salary=(select salary from emp where name='张无忌')&amp;&amp; emp.managerid=(select managerid from emp where name='张无忌');
#上面这种方法是标量子查询
select * from emp where (salary,managerid)=(select salary,emp.managerid from emp where name='张无忌');</code></pre> 
<h3>表子查询 </h3> 
<p>子查询返回的结果是多行多列，这种子查询称为表子查询。</p> 
<p>常用操作符：IN</p> 
<pre><code class="language-sql">#表子查询
#1、查询与杨逍与韦一笑的职位和薪资相同的员工信息
#第一步：查询与杨逍与韦一笑的职位和薪资
select job,salary from emp where name='杨逍'||name='韦一笑';
#第二步：查询与杨逍与韦一笑的职位和薪资相同的员工信息
select * from emp where (job,salary) in(select job,salary from emp where name='杨逍'||name='韦一笑');
#2、查询入职日期是”2002-01-01“之后的员工信息，及其部门信息
#第一步：入职信息是”2002-01-01“之后的员工信息
select * from emp where entrydate &gt; '2002-01-01';
#第二步：查询这部分员工，对应的部门信息
select e.*,d.* from (select * from emp where entrydate &gt; '2002-01-01') e left join dept d on e.dept_id=d.id;</code></pre> 
<h3> 多表查询案例</h3> 
<pre><code class="language-sql">#多表查询案例
#1、查询员工的姓名、年龄、职位、部门信息。(隐式内连接）
select emp.name,emp.age,emp.job,dept.name from emp,dept where emp.dept_id=dept.id;
#2、查询年龄小于30岁的员工姓名、年龄、职位、部门信息（显示内连接）
select emp.name,emp.age,emp.job,dept.name from emp inner join dept on emp.dept_id=dept.id where emp.age&lt;30;
#3、查询拥有员工的部门ID、部门名称
select distinct dept.id,dept.name from emp,dept where emp.dept_id=dept.id;
#4、查询所有年龄大于40岁的员工，及其归属的部门名称；如果员工没有分配部门，也需要展示出来
select emp.*,dept.name from emp left outer join dept on emp.dept_id = dept.id where emp.age&gt;40;
#5、查询所有员工的工资等级
#准备工作
create table salarygrade(
    grade int,
    losal int,
    hisal int
)comment'工资等级表';
insert into salarygrade values(1,0,3000),
                              (2,3001,5000),
                              (3,5001,8000),
                              (4,8001,10000),
                              (5,10001,15000),
                              (6,15001,20000);
select emp.name,salarygrade.grade from emp,salarygrade where emp.salary&gt;=salarygrade.losal and emp.salary&lt;=salarygrade.hisal;
select emp.name,salarygrade.grade from emp,salarygrade where emp.salary between salarygrade.losal and salarygrade.hisal;
#6、查询研发部所有员工信息及工资等级
select e.*,s.grade from emp e,salarygrade s,dept d where e.dept_id=d.id and e.salary between s.losal and s.hisal and d.name='研发部';
#7、查询研发部员工的平均工资
select avg(emp.salary) from emp,dept where emp.dept_id=dept.id and dept.name='研发部';
#8、查询工资比韦一笑高的员工信息
select * from emp where salary&gt;(select salary from emp where name='韦一笑');
#9、查询比平均薪资高的员工信息
select * from emp where salary &gt;(select avg(salary) from emp where id);
#10、查询低于研发部门平均工资的员工信息
select * from emp where salary&lt;(select avg(salary) from emp,dept where dept.name='研发部' and emp.dept_id=dept.id);
#11、查询所有部门信息，并统计部门员工人数
select d.id,d.name,(select count(*) from emp e where e.dept_id=d.id)'人数' from dept d;</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6a62ed5f4392ec85857137b669bd6174/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何在Vue3中使用Ref访问DOM元素</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/89ef4e287bfeb80a20785c7e9b3a644e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AI Agent：基于大模型的自主智能体</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>