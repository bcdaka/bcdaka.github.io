<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>解决vue3前端获取文件的绝对路径问题 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/812c5c9dc9210a8a6514244b3eaa6a54/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="解决vue3前端获取文件的绝对路径问题">
  <meta property="og:description" content="解决vue3前端获取文件的绝对路径问题 公司的项目是基于vue3的，由于需求需要前端获取用户选的文件的绝对路径。但是浏览器处于安全策略无法获取真实的文件路径，只能拿到相对路径或者是D:\fakepath\xxxx.
看了网上很多方法都很坑，明明没拿到路径非说拿到了，浪费了很多时间，这里要说单纯依靠vue是解决不了的！！
最后选择了引入electron来获取文件的绝对路径。项目已经使用electron进行了打包，所以是可以通过electron方式运行的，现在需要的就是vue的代码中引入electron，进行打开文件管理器，实现文件路径获取。
首先要安装相关的包：
npm install --save-dev electron npm install --save-dev electron-builder 所有的界面代码都是在vue项目中完成的所以vue中不再需要preload.js background.js这些文件
electron的通信是通过ipcRenderer实现的
在需要通信的文件中进行调用
const { ipcRenderer } = require(&#39;electron&#39;) 这时候会报错，错误显示是node_modules/electron/index.js文件中引入fs.existsSync语句造成的
百度查资料得知原因是：
(1)、首先在渲染进程属于浏览器端，没有集成Node的环境，所以类似 fs 这样的Node的基础包是不可以使用。
(2)、因为没有Node环境，所以这种属于node api的require关键词是不可以使用的。
(3)、electron5.x的node集成环境默认是关闭的，这之前的版本是默认开启的
方案是在主进程中集成 Nodejs，也就是添加配置nodeIntegration: true
vue.config.js配置：
pluginOptions: { electronBuilder: { nodeIntegration: true, contextIsolation: false, } } 然后通过使用window.require代替require来引入electron，因为前者不会被webpack编译，在渲染进程require关键字就是表示node模块的系统渲染进程：
const { ipcRenderer } = window.require(&#39;electron&#39;) 这时候又出现 window.require is not a function .错误，这是因为工程是在本地浏览器运行的，识别不了electron中的api,只要保证在electron应用程序下运行就不会报错
解决：npm install --save is-electron
function importStudy() { if (isElectron()) { window.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-08-15T15:52:32+08:00">
    <meta property="article:modified_time" content="2023-08-15T15:52:32+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">解决vue3前端获取文件的绝对路径问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="vue3_0"></a>解决vue3前端获取文件的绝对路径问题</h3> 
<p>公司的项目是基于vue3的，由于需求需要前端获取用户选的文件的绝对路径。但是浏览器处于安全策略无法获取真实的文件路径，只能拿到相对路径或者是D:\fakepath\xxxx.<br> 看了网上很多方法都很坑，明明没拿到路径非说拿到了，浪费了很多时间，这里要说单纯依靠vue是解决不了的！！<br> 最后选择了引入electron来获取文件的绝对路径。项目已经使用electron进行了打包，所以是可以通过electron方式运行的，现在需要的就是vue的代码中引入electron，进行打开文件管理器，实现文件路径获取。<br> 首先要安装相关的包：</p> 
<pre><code>npm install --save-dev electron
npm install --save-dev electron-builder
</code></pre> 
<p>所有的界面代码都是在vue项目中完成的所以vue中不再需要preload.js background.js这些文件<br> electron的通信是通过ipcRenderer实现的<br> 在需要通信的文件中进行调用</p> 
<pre><code>const { ipcRenderer } = require('electron')
</code></pre> 
<p>这时候会报错，错误显示是node_modules/electron/index.js文件中引入fs.existsSync语句造成的<br> 百度查资料得知原因是：<br> (1)、首先在渲染进程属于浏览器端，没有集成Node的环境，所以类似 fs 这样的Node的基础包是不可以使用。<br> (2)、因为没有Node环境，所以这种属于node api的require关键词是不可以使用的。<br> (3)、electron5.x的node集成环境默认是关闭的，这之前的版本是默认开启的<br> 方案是在主进程中集成 Nodejs，也就是添加配置nodeIntegration: true<br> vue.config.js配置：</p> 
<pre><code> pluginOptions: {
        electronBuilder: {
            nodeIntegration: true,
            contextIsolation: false,
        }
    }
</code></pre> 
<p>然后通过使用window.require代替require来引入electron，因为前者不会被webpack编译，在渲染进程require关键字就是表示node模块的系统渲染进程：</p> 
<pre><code>const { ipcRenderer } = window.require('electron')
</code></pre> 
<p>这时候又出现 window.require is not a function .错误，这是因为工程是在本地浏览器运行的，识别不了electron中的api,只要保证在electron应用程序下运行就不会报错<br> 解决：<code>npm install --save is-electron</code></p> 
<pre><code> function importStudy() {
            if (isElectron()) {
                window.ipcRenderer = window.require('electron').ipcRenderer
                ipcRenderer.send('upload', "import study")
                ipcRenderer.on('get-file-path', (event: any, arg: any) =&gt; {
                    console.log(arg)
                    })
                })
            }          
        }
</code></pre> 
<p>vue文件：</p> 
<pre><code> &lt;button @click="importStudy"&gt;import&lt;/button&gt;
</code></pre> 
<p>点击页面的按钮就会向upload发送消息去进行打开文件管理的操作<br> 在electron的包中main.js进行接收</p> 
<pre><code>ipcMain.on('upload',(event,message)=&gt;{
   console.log(message)
   dialog.showOpenDialog({
    title:'选择要上传的文件',//对话框的标题
    buttonLabel: '确认', //确定按钮的自定义标签
    properties: [ 'openDirectory', 'multiSelections'], //打开文件的属性，打开文件还是文件夹，隐藏文件,多选文件
   }).then(res=&gt;{
    if(!res.canceled){
      console.log(res.filePaths)
      event.reply('get-file-path',res.filePaths)//拿到路径后返回
    }
   }).catch(err=&gt;{
    console.log(err)
   });

})
</code></pre> 
<p>此时importStudy可以拿到绝对路径了，但是前端浏览器没办法调试，后端是可以获取到的。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d34461ed89fe7ebfe307d63e37888095/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">创建Maven项目，JDBC连接mysql数据库 超详细的步骤！！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fdec280c9a1ccad882bbfcb203f615e0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PostgreSQL建立自增主键的两种方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>