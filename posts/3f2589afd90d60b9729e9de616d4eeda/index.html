<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>UDP网络通信（发送端&#43;接收端）实例 —— Python - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/3f2589afd90d60b9729e9de616d4eeda/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="UDP网络通信（发送端&#43;接收端）实例 —— Python">
  <meta property="og:description" content="简介
在网络通信编程中，用的最多的就是UDP和TCP通信了，原理这里就不分析了，网上介绍也很多，这里简单列举一下各自的优缺点和使用场景
通信方式优点缺点适用场景UDP及时性好，快速视网络情况，存在丢包 与嵌入式设备通信，实时控制
场景
TCP丢包会自动重发，理论上不用担心丢包问题延时相对大一些 通信可靠性场景，比如IoT设备
控制，状态同步
一、socket
我们要进行网络通信，那么就要用到socket，socket即网络套接字，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。
在 Python 中，使用socket 模块的函数 socket 就可以创建一个socket对象，socket()函数的参数分别有family, type, proto。
1.其中family参数是指协议域，又称为协议族（family），常用的协议族有，AF_INET、AF_INET6、...等等，AF_INET指ipv4，AF_INET6即为ipv6；
2.然后是type，type指定socket类型，有SOCK_STREAM（流式套接字，主要用于 TCP 协议）和SOCK_DGRAM（数据报套接字，主要用于 UDP 协议）等等；
3.proto就是指定的协议，常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议，但是type和proto不可以随意组合，当proto参数为0或者不填时，会自动选择type类型对应的默认协议。
二、UDP发送数据
首先我们要导入socket包
import socket 创建一个udp套接字，ipv4协议，使用SOCK_DGRAM参数，不填proto，就会默认自动选择udp协议；
# 1、创建一个UDP套接字 udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 然后我们把要接收数据的那一端的ip地址和端口号放在一个元组里准备好
​​​# 2. 准备接收方的地址和端口，&#39;127.0.0.1:9999&#39;表示目的ip地址，9999表示目的端口号 udp_addr = (&#39;127.0.0.1&#39;, 9999) # 注意这是一个元组，其中ip地址是字符串，端口号是数字​ 准备好后就可以使用sendto函数进行发送了，要注意，需要对字符串进行编码才可以发送
# 3. 发送数据到指定的ip和端口 udp_socket.sendto(&#34;Hello,I am a UDP socket.&#34;.encode(&#39;utf-8&#39;), dest_addr) 发送完就可以关闭套接字了
# 4. 关闭套接字 udp_socket.close() 例程一：UDP server端，UDP数据接收
​ ​ #!/usr/bin/python3 # -*- coding: utf-8 -*- &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-01T17:54:38+08:00">
    <meta property="article:modified_time" content="2024-08-01T17:54:38+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">UDP网络通信（发送端&#43;接收端）实例 —— Python</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>简介<br> 在网络通信编程中，用的最多的就是UDP和TCP通信了，原理这里就不分析了，网上介绍也很多，这里简单列举一下各自的优缺点和使用场景</p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><th>通信方式</th><th>优点</th><th style="width:130px;">缺点</th><th style="width:319px;">适用场景</th></tr><tr><td>UDP</td><td>及时性好，快速</td><td style="width:130px;">视网络情况，存在丢包</td><td style="width:319px;"> <p>与嵌入式设备通信，实时控制</p> <p>场景</p> </td></tr><tr><td>TCP</td><td>丢包会自动重发，理论上不用担心丢包问题</td><td style="width:130px;">延时相对大一些</td><td style="width:319px;"> <p>通信可靠性场景，比如IoT设备</p> <p>控制，状态同步</p> </td></tr></tbody></table> 
<p><strong>一、socket</strong><br> 我们要进行网络通信，那么就要用到socket，socket即网络套接字，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。<br> 在 Python 中，使用socket 模块的函数 socket 就可以创建一个socket对象，socket()函数的参数分别有family, type, proto。</p> 
<p>1.其中family参数是指协议域，又称为协议族（family），常用的协议族有，AF_INET、AF_INET6、...等等，AF_INET指ipv4，AF_INET6即为ipv6；<br> 2.然后是type，type指定socket类型，有SOCK_STREAM（流式套接字，主要用于 TCP 协议）和SOCK_DGRAM（数据报套接字，主要用于 UDP 协议）等等；<br> 3.proto就是指定的协议，常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议，但是type和proto不可以随意组合，当proto参数为0或者不填时，会自动选择type类型对应的默认协议。</p> 
<p></p> 
<p><strong>二、UDP发送数据</strong><br> 首先我们要导入socket包</p> 
<pre><code class="language-python">import socket</code></pre> 
<p>创建一个udp套接字，ipv4协议，使用SOCK_DGRAM参数，不填proto，就会默认自动选择udp协议；</p> 
<pre><code class="language-python"># 1、创建一个UDP套接字
udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</code></pre> 
<p>然后我们把要接收数据的那一端的ip地址和端口号放在一个元组里准备好</p> 
<pre><code class="language-python">​​​# 2. 准备接收方的地址和端口，'127.0.0.1:9999'表示目的ip地址，9999表示目的端口号
udp_addr = ('127.0.0.1', 9999)  # 注意这是一个元组，其中ip地址是字符串，端口号是数字​</code></pre> 
<p>  准备好后就可以使用sendto函数进行发送了，要注意，需要对字符串进行编码才可以发送</p> 
<pre><code class="language-python"># 3. 发送数据到指定的ip和端口
udp_socket.sendto("Hello,I am a UDP socket.".encode('utf-8'), dest_addr)</code></pre> 
<p>发送完就可以关闭套接字了</p> 
<pre><code class="language-python"># 4. 关闭套接字
udp_socket.close()</code></pre> 
<p></p> 
<p>例程一：UDP server端，UDP数据接收</p> 
<pre><code class="language-python">​
​
#!/usr/bin/python3
# -*- coding: utf-8 -*-

"""
udp通信例程：udp server端，修改udp_addr元组里面的ip地址，即可实现与目标机器的通信，
此处以单机通信示例，ip为127.0.0.1，实际多机通信，此处应设置为目标客户端ip地址
"""

from time import sleep
import socket


def main():
    # udp 通信地址，IP+端口号
    udp_addr = ('127.0.0.1', 9999)
    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    # 绑定端口
    udp_socket.bind(udp_addr)

    # 等待接收对方发送的数据
    while True:
        recv_data = udp_socket.recvfrom(1024)  # 1024表示本次接收的最大字节数
        # 打印接收到的数据
        print("[From %s:%d]:%s" % (recv_data[1][0], recv_data[1][1], recv_data[0].decode("utf-8")))

if __name__ == '__main__':
    print("当前版本： ", __version__)
    print("udp server ")
    main()

​

​</code></pre> 
<p> 代码解析 </p> 
<blockquote> 
 <p>1.socket函数中第二个参数就是通信类型，此处SOCK_DGRAM 就是指定使用UDP通信<br> 2.服务端需要使用bind函数绑定端口，客户端不需要，因为客户端发送的时候已经带了端口参数</p> 
</blockquote> 
<p>例程二：UDP client端，UDP数据发送</p> 
<pre><code class="language-python">#!/usr/bin/python3
# -*- coding: utf-8 -*-

"""
udp通信例程：udp client端，修改udp_addr元组里面的ip地址，即可实现与目标机器的通信，
此处以单机通信示例，ip为127.0.0.1，实际多机通信，此处应设置为目标服务端ip地址
"""

from time import sleep
import socket

def main():
    # udp 通信地址，IP+端口号
    udp_addr = ('127.0.0.1', 9999)
    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

    # 发送数据到指定的ip和端口,每隔1s发送一次，发送10次
    for i in range(10):
        udp_socket.sendto(("Hello,I am a UDP socket for: " + str(i)) .encode('utf-8'), udp_addr)
        print("send %d message" % i)
        sleep(1)

    # 5. 关闭套接字
    udp_socket.close()


if __name__ == '__main__':
    print("当前版本： ", __version__)
    print("udp client ")
    main()</code></pre> 
<p><br> 例程三：多线程实现UDP数据收发</p> 
<pre><code class="language-python">#!/usr/bin/python3
# -*- coding: utf-8 -*-

"""
python多线程通信
"""

from time import sleep
import socket
import threading

# 定义全局变量
t1_count = 0
t2_count = 0


def udp_received_hundle(s):
    global t1_count
    print("this is thread 1 running")
    while True:
        t1_count += 1
        print("thread 1 第 %s 次运行" % t1_count)
        recv_data = s.recvfrom(1024)  # 1024表示本次接收的最大字节数
        # 打印接收到的数据
        print("[From %s:%d]:%s" % (recv_data[1][0], recv_data[1][1], recv_data[0].decode("utf-8")))


def udp_send_hundle(s):
    global t2_count
    print("this is thread 2 running")
    while True:
        t2_count += 1
        print("")
        print("thread 2 第 %s 次运行" % t2_count)
        s.sendto(("Hello,I am a UDP socket for: " + str(t2_count)).encode('utf-8'), udp_addr)
        print("send %d message" % t2_count)
        print("")
        sleep(1)


if __name__ == '__main__':
    print("当前版本： ", __version__)
    # 初始化
    # udp 通信地址，IP+端口号
    udp_addr = ('127.0.0.1', 9999)
    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    # 绑定端口:
    udp_socket.bind(udp_addr)

    # 定义线程
    thread_list = []
    t1 = threading.Thread(target=udp_received_hundle, args=(udp_socket, ))
    thread_list.append(t1)
    t2 = threading.Thread(target=udp_send_hundle, args=(udp_socket, ))
    thread_list.append(t2)

    for t in thread_list:
        t.setDaemon(True)
        t.start()
    for t in thread_list:
        t.join()

    print("exit all task.")
    print('all process end.')</code></pre> 
<p>代码解析<br> 这里用到了多线程，虽然python中的多线程是假的多线程，实际上是一个线程分时复用，这里我们不深究，如果平常用到也就几个小任务跑一跑，抄我这个作业就ok。<br> 多线程实际上是从t.join()后才开始正式运行的，这里一定要注意，不能漏了这个函数。<br> udp的收发与上面的例程几乎是一样的。<br> 代码运行效果如下</p> 
<pre><code class="language-python">当前版本：  1.0.0
this is thread 1 running
thread 1 第 1 次运行
this is thread 2 running

thread 2 第 1 次运行
send 1 message

[From 127.0.0.1:9999]:Hello,I am a UDP socket for: 1
thread 1 第 2 次运行

thread 2 第 2 次运行
send 2 message

[From 127.0.0.1:9999]:Hello,I am a UDP socket for: 2
thread 1 第 3 次运行

thread 2 第 3 次运行
send 3 message

[From 127.0.0.1:9999]:Hello,I am a UDP socket for: 3
thread 1 第 4 次运行

thread 2 第 4 次运行
send 4 message

[From 127.0.0.1:9999]:Hello,I am a UDP socket for: 4
thread 1 第 5 次运行

thread 2 第 5 次运行
send 5 message</code></pre> 
<p></p> 
<p> 使用网络调试助手，测试程序<br><span style="color:#fe2c24;">注意，如果不是在本机windows系统上运行python程序，在Ubuntu虚拟机或者其他局域网内的机器上运行，要把windows的防火墙关了！！！</span><br> 然后我们让其每隔一秒发送一次，发送10次，发送成功</p> 
<p><img alt="" height="258" src="https://images2.imgbox.com/f4/3a/7h4SHymC_o.png" width="532"></p> 
<p>完整代码：</p> 
<pre><code class="language-python">​#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author: William

import socket,time

def main():
    # 1、创建一个UDP套接字
    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

    # 2. 准备接收方的地址和端口，'192.168.0.107'表示目的ip地址，8080表示目的端口号
    dest_addr = ('192.168.8.226', 12341)  # 注意这是一个元组，其中ip地址是字符串，端口号是数字

    # 3. 发送数据到指定的ip和端口
    for i in range(10):
        udp_socket.sendto("Hello,I am a UDP socket.".encode('utf-8'), dest_addr)
        time.sleep(1)

    # 4. 关闭套接字
    udp_socket.close()

if __name__ == '__main__':
    main()

​</code></pre> 
<p>三、UDP接收数据<br> 在之前发送数据的时候，我们可以看到，其端口号是一直在变得，那么我们要接收数据，就需要知道其端口号是什么，所以我们要先固定一个端口号，使用bind函数</p> 
<pre><code class="language-python"># 2. 绑定本地的相关信息，如果不绑定，则系统会随机分配一个端口号
local_addr = ('', 12344)  # ip地址和端口号，ip一般不用写，表示本机的任何一个ip
udp_socket.bind(local_addr)</code></pre> 
<p>接收数据使用recvfrom函数，其参数为接收的最大数据长度</p> 
<pre><code class="language-python"># 3. 等待接收对方发送的数据
recv_data = udp_socket.recvfrom(1024)  # 1024表示本次接收的最大字节数</code></pre> 
<p>接收完后将其打印出来：</p> 
<pre><code class="language-python"># 4、打印接收到的数据
print(recv_data)</code></pre> 
<p>运行，通过网络调试助手发送数据</p> 
<p><img alt="" height="167" src="https://images2.imgbox.com/78/f3/klMMVqHt_o.png" width="1200"> 可以看到，打印出来的信息是一个元组，第一项接收到的字符串，第二项也是一个元组，包含对方的IP地址和端口号<br> 完整代码：</p> 
<pre><code class="language-python">#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author: William

import socket,time

def main():
    # 1、创建一个UDP套接字
    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

    # 2. 绑定本地的相关信息，如果不绑定，则系统会随机分配一个端口号
    local_addr = ('', 12344)  # ip地址和端口号，ip一般不用写，表示本机的任何一个ip
    udp_socket.bind(local_addr)

    # 3. 等待接收对方发送的数据
    recv_data = udp_socket.recvfrom(1024)  # 1024表示本次接收的最大字节数

    # 4、打印接收到的数据
    print(recv_data)

    # 5. 关闭套接字
    udp_socket.close()

if __name__ == '__main__':
    main()</code></pre> 
<p><br> 四、UDP收发数据<br> 实现这样一个功能，通过UDP发送10次消息，然后等待接收，将接收的数据及其来源打印出来：</p> 
<p><img alt="" height="561" src="https://images2.imgbox.com/07/42/Ikm546mU_o.png" width="632"></p> 
<p><img alt="" height="155" src="https://images2.imgbox.com/b2/61/gzWkVDee_o.png" width="1200"></p> 
<p>完成代码：</p> 
<pre><code class="language-python">​
#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author: William

import socket,time

def main():
    # 1、创建一个UDP套接字
    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

    # 2. 绑定本地的相关信息，如果不绑定，则系统会随机分配一个端口号
    udp_socket.bind(('', 12344))

    # 3. 发送数据到指定的ip和端口,每隔1s发送一次，发送10次
    for i in range(10):
        udp_socket.sendto("Hello,I am a UDP socket.".encode('utf-8'), ('192.168.8.226', 12341))
        time.sleep(1)

    # 4. 等待接收对方发送的数据
    while(True):
        recv_data = udp_socket.recvfrom(1024)
        # 打印接收到的数据
        print("[From %s:%d]:%s"%(recv_data[1][0],recv_data[1][1],recv_data[0].decode("utf-8")))

    # 5. 关闭套接字
    udp_socket.close()

if __name__ == '__main__':
    main()

​</code></pre> 
<p><br> 五、同时收发数据<br> 现在实现这样一个功能，即运行程序，然后在控制台输入字符串发送出去，同时，还可以接收数据，我使用多线程来实现这个程序，不过要实现方便接收，我们在程序的开始，将IP地址和端口号打印出来，实现效果如下：</p> 
<p><img alt="" height="547" src="https://images2.imgbox.com/37/ed/N22jbX5L_o.png" width="1200"></p> 
<p><img alt="" height="535" src="https://images2.imgbox.com/cb/f3/iYtiqDVb_o.png" width="645"></p> 
<p>实现代码：</p> 
<pre><code class="language-python">​
#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author: William

import socket,time,threading

def recv_thread(socket):
    # 等待接收对方发送的数据
    while(True):
        try:
            recv_data = socket.recvfrom(1024)
            # 打印接收到的数据
            print("[From %s:%d]:%s"%(recv_data[1][0],recv_data[1][1],recv_data[0].decode("utf-8")))
        except Exception:
            break

def main():
    # 1、创建一个UDP套接字
    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

    # 2、绑定本地的相关信息，如果不绑定，则系统会随机分配一个端口号
    udp_socket.bind(('', 12344))

    # 3、打印本机ip地址和端口号
    print("local ipaddr and port-&gt;",socket.gethostbyname(socket.gethostname())+":12344")

    # 4、创建一个线程，用来接收数据
    t = threading.Thread(target=recv_thread, args=(udp_socket,))
    t.start()

    # 5、等待输入数据,然后发送出去，直到输入的数据为'quit'
    while(True):
        print("please input a string.input 'quit' to quit.")
        send_data = input()
        if send_data == "quit":
            break
        else:
            udp_socket.sendto(send_data.encode('utf-8'), ("192.168.8.226",12341))

    # 6、关闭套接字
    udp_socket.close()

def main1():
    # 1、创建一个UDP套接字
    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

    # 2. 准备接收方的地址和端口，'192.168.0.107'表示目的ip地址，8080表示目的端口号
    dest_addr = ('192.168.8.226', 12341)  # 注意这是一个元组，其中ip地址是字符串，端口号是数字

    # 3. 发送数据到指定的ip和端口
    for i in range(1):
        udp_socket.sendto("Hello,I am a UDP socket.".encode('utf-8'), dest_addr)
        time.sleep(1)

    # 4. 等待接收对方发送的数据
    recv_data = udp_socket.recvfrom(1024)  # 1024表示本次接收的最大字节数

    # 5、打印接收到的数据
    print(recv_data)
    # 4. 关闭套接字
    udp_socket.close()

if __name__ == '__main__':
    main()


​</code></pre> 
<p>结语<br> 这里只是UDP的简单使用，给大家一个示例参考，在实际应用过程中，涉及到复杂数据通信，还需要使用通信协议，协议收发，解包等函数，另外数据缓存也很关键，尤其是大数据量的情况下，通常会用到队列相关知识，这一部分就留给大家自行研究吧，如果这篇文章对你有用，不妨点赞关注，你的支持是我最大的动力。</p> 
<p style="text-align:center;"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dbc0a5f38b4ee3f8b255af2ec3cc6091/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">注册中心--Eureka</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2ae705049b1ef3944efd50d48d352d4c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">云计算学习——5G网络技术</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>