<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;杂货铺】unordered系列容器 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/eb3b555ecb429308587c8a4a1e855cb7/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;杂货铺】unordered系列容器">
  <meta property="og:description" content="目录
🌈 前言🌈
📁 unordered系列关联式容器
📁 底层结构
📂 哈希概念
📂 哈希冲突
📂 哈希函数
📂 哈希冲突解决
📁 模拟实现
📁 总结
🌈 前言🌈 欢迎收看本期【C&#43;&#43;杂货铺】，本期内容将讲解C&#43;&#43;的STL中的unordered系列容器，其中包含了unordered_map 和 unordered_set 的使用，底层结构哈希的原理，实现，最后模拟实现unordered系列的容器。
📁 unordered系列关联式容器 在C&#43;&#43;98中，STL提供了底层为红黑树结构的系列关联式容器，在查询时效率可达到 O(log2)，即最差情况下需要比较红黑树的高度次，当书中的节点比较多时，查询效率也不理想。
最好的查询是，进行很少的比较次数就能将元素找到，因此在C&#43;&#43;11中，STL又提供了4个unordered系列的关联式容器，这四个容器与红黑树结构的关联式容器使用方式基本类似，只是底层结构不同，本文中只对unordered_map 和 unordered_set进行介绍。
其中，unordered_map是存储 &lt;key , value&gt;键值对的关联式容器，其允许通过key快速的索引找到对应的value。
📁 底层结构 unordered系列的关联式容器效率之所以比较高，是因为底层使用了哈希结构。
📂 哈希概念 顺序结构及平衡树中，元素关键码与其存储位置之间没有对应关系，因此在查找一个元素时，必须要经过关键码的多次比较。顺序查找时间复杂度为O(N) ,平衡术中为树的高度，即O(logN)，搜索效率取决于搜索过程中元素的比较次数。
理想的搜索方法是：可以不经过任何比较，一次直接从表中得到搜索的元素。如果构造一种存储结构，通过某种函数（HashFunc）使得元素的存储位置和它的关键码之间能够建立一种映射关系，那么在查找时通过该函数可以很快找到该元素。
该结构中：
● 插入元素：根据插入元素的关键码，用哈希函数计算出该元素的存储位置并按次位置进行存放。
● 搜搜元素：对元素的关键码进行同样的计算，把求得的函数值当做元素的存储位置，在结构中按次位置取元素的比较，若关键码相等，则搜索成功。
该方式即为哈希（散列）方法，哈希方法中使用的转换函数称为哈希（散列）函数，构造出的结构为哈希表（散列表）。
该方法不必经过多次关键码的比较，因此搜索的速度比较快。
📂 哈希冲突 当两个数据元素的关键码 i != j , 但是Hash(i) == Hash(j)，即：不同关键码通过相同的哈希函数计算出相同的哈希地址，这种现象成为哈希冲突（哈希碰撞）。
📂 哈希函数 引起哈希冲突的一个原因可能是，哈希函数设计不合理。
哈希函数的设计原则： 1. 哈希函数的定义域必须包括需要存储的全部关键码，如果散列表允许有m个地址，其值域必须在0 ~ m-1 之间。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-02T20:41:06+08:00">
    <meta property="article:modified_time" content="2024-06-02T20:41:06+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;杂货铺】unordered系列容器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="571" src="https://images2.imgbox.com/79/48/yj5SrTqs_o.png" width="944"></h2> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%F0%9F%8C%88%E5%89%8D%E8%A8%80%F0%9F%8C%88%C2%A0-toc" style="margin-left:0px;"><a href="#%F0%9F%8C%88%E5%89%8D%E8%A8%80%F0%9F%8C%88%C2%A0" rel="nofollow">🌈 前言🌈</a></p> 
<p id="%F0%9F%93%81%20%E9%80%9A%E4%BF%A1%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%F0%9F%93%81%20%E9%80%9A%E4%BF%A1%E6%A6%82%E5%BF%B5" rel="nofollow">📁 unordered系列关联式容器</a></p> 
<p id="%F0%9F%93%81%20%E9%80%9A%E4%BF%A1%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%F0%9F%93%81%20%E9%80%9A%E4%BF%A1%E6%A6%82%E5%BF%B5" rel="nofollow">📁 底层结构</a></p> 
<p id="%F0%9F%93%82%20%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#%F0%9F%93%82%20%E6%8E%A5%E5%8F%A3" rel="nofollow"> 📂 哈希概念</a></p> 
<p id="%C2%A0%F0%9F%93%82%20%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81-toc" style="margin-left:40px;"><a href="#%C2%A0%F0%9F%93%82%20%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81" rel="nofollow"> 📂 哈希冲突</a></p> 
<p id="%C2%A0%F0%9F%93%82%20%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%C2%A0%F0%9F%93%82%20%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0" rel="nofollow"> 📂 哈希函数</a></p> 
<p id="%C2%A0%20%F0%9F%93%82%20%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3-toc" style="margin-left:40px;"><a href="#%C2%A0%20%F0%9F%93%82%20%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3" rel="nofollow">  📂 哈希冲突解决</a></p> 
<p id="%F0%9F%93%81%20%E9%80%9A%E4%BF%A1%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%F0%9F%93%81%20%E9%80%9A%E4%BF%A1%E6%A6%82%E5%BF%B5" rel="nofollow">📁 模拟实现</a></p> 
<p id="%F0%9F%93%81%20%E9%80%9A%E4%BF%A1%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%F0%9F%93%81%20%E9%80%9A%E4%BF%A1%E6%A6%82%E5%BF%B5" rel="nofollow">📁 总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<blockquote> 
 <h2 id="%F0%9F%8C%88%E5%89%8D%E8%A8%80%F0%9F%8C%88%C2%A0" style="background-color:transparent;">🌈 前言🌈</h2> 
 <p>        欢迎收看本期【C++杂货铺】，本期内容将讲解C++的STL中的unordered系列容器，其中包含了unordered_map 和 unordered_set 的使用，底层结构哈希的原理，实现，最后模拟实现unordered系列的容器。</p> 
 <p><img alt="" height="240" src="https://images2.imgbox.com/2a/71/XkMcjcc6_o.gif" width="240"></p> 
</blockquote> 
<p></p> 
<h2 id="%F0%9F%93%81%20%E9%80%9A%E4%BF%A1%E6%A6%82%E5%BF%B5">📁 unordered系列关联式容器</h2> 
<p>        在C++98中，STL提供了底层为红黑树结构的系列关联式容器，在查询时效率可达到 O(log2)，即最差情况下需要比较红黑树的高度次，当书中的节点比较多时，查询效率也不理想。</p> 
<p>        最好的查询是，进行很少的比较次数就能将元素找到，因此在C++11中，STL又提供了4个unordered系列的关联式容器，这四个容器与红黑树结构的关联式容器使用方式基本类似，只是底层结构不同，本文中只对unordered_map 和 unordered_set进行介绍。</p> 
<p>        其中，unordered_map是存储 &lt;key , value&gt;键值对的关联式容器，其允许通过key快速的索引找到对应的value。</p> 
<h2>📁 底层结构</h2> 
<p>        unordered系列的关联式容器效率之所以比较高，是因为底层使用了哈希结构。</p> 
<h3 id="%F0%9F%93%82%20%E6%8E%A5%E5%8F%A3"> 📂 哈希概念</h3> 
<p>        顺序结构及平衡树中，元素关键码与其存储位置之间没有对应关系，因此在查找一个元素时，必须要经过关键码的多次比较。顺序查找时间复杂度为O(N) ,平衡术中为树的高度，即O(logN)，搜索效率取决于搜索过程中元素的比较次数。</p> 
<p>        理想的搜索方法是：可以不经过任何比较，一次直接从表中得到搜索的元素。如果构造一种存储结构，通过某种函数（HashFunc）使得元素的存储位置和它的关键码之间能够建立一种映射关系，那么在查找时通过该函数可以很快找到该元素。</p> 
<p>        该结构中：</p> 
<p>        ● 插入元素：根据插入元素的关键码，用哈希函数计算出该元素的存储位置并按次位置进行存放。</p> 
<p>        ● 搜搜元素：对元素的关键码进行同样的计算，把求得的函数值当做元素的存储位置，在结构中按次位置取元素的比较，若关键码相等，则搜索成功。</p> 
<p>        该方式即为哈希（散列）方法，哈希方法中使用的转换函数称为哈希（散列）函数，构造出的结构为哈希表（散列表）。</p> 
<p>        该方法不必经过多次关键码的比较，因此搜索的速度比较快。</p> 
<h3 id="%C2%A0%F0%9F%93%82%20%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"> 📂 哈希冲突</h3> 
<p>        当两个数据元素的关键码 i != j , 但是Hash(i) == Hash(j)，即：<strong>不同关键码通过相同的哈希函数计算出相同的哈希地址，这种现象成为哈希冲突（哈希碰撞）。</strong></p> 
<h3 id="%C2%A0%F0%9F%93%82%20%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0" style="background-color:transparent;"><strong> 📂 哈希函数</strong></h3> 
<p>        引起哈希冲突的一个原因可能是，哈希函数设计不合理。</p> 
<p>        哈希函数的设计原则：        </p> 
<p>        1. 哈希函数的定义域必须包括需要存储的全部关键码，如果散列表允许有m个地址，其值域必须在0 ~ m-1 之间。</p> 
<p>        2. 哈希函数计算出的地址能均匀分布在整个空间中</p> 
<p>        3. 哈希函数应比较简单。</p> 
<p>        常见的哈希函数：</p> 
<p><strong>        1. 直接定址法（常用）</strong></p> 
<p><strong>         取关键字的某个线性函数为散列地址：Hash(key) = A*Key + B。</strong></p> 
<p><strong>         优点：简单，均匀</strong></p> 
<p><strong>         缺点：需要实现知道关键字的分布情况</strong></p> 
<p><strong>         使用场景：适合查找比较小且连续的情况</strong></p> 
<p><strong>        2. 除留余数法（常用）</strong></p> 
<p><strong>         设散列表允许的地址数为m，取一个不大于m，但是接近或等于m的质数p作为除数，按照哈希函数：Hash(key) = key % p (p &lt;= m) ，将关键字改为哈希地址。</strong></p> 
<p>  <strong>      3. 平方取中法</strong></p> 
<p><strong>        假设关键字为1234，对它平方就是1522756，抽取中间的3位227作为哈希地址； </strong></p> 
<p><strong>        再比如关键字为4321，对它平方就是18671041，抽取中间的3位671(或710)作为哈希地址 </strong></p> 
<p><strong>        平方取中法比较适合：不知道关键字的分布，而位数又不是很大的情况</strong></p> 
<p><strong>         4. 折叠法（了解）</strong></p> 
<p><strong>        折叠法是将关键字从左到右分割成位数相等的几部分(最后一部分位数可以短些)，然后将这 几部分叠加求和，并按散列表表长，取后几位作为散列地址。 </strong></p> 
<p><strong>        折叠法适合事先不需要知道关键字的分布，适合关键字位数比较多的情况</strong></p> 
<p><strong>        5. 随机数法（了解）</strong></p> 
<p><strong>        选择一个随机函数，取关键字的随机函数值为它的哈希地址，即H(key) = random(key),其中 random为随机数函数。</strong></p> 
<p><strong>        通常应用于关键字长度不等时采用此法。</strong></p> 
<p><strong>        6. 数学分析法（了解）</strong></p> 
<p><strong>        设有n个d位数，每一位可能有r种不同的符号，这r种不同的符号在各位上出现的频率不一定 相同，可能在某些位上分布比较均匀，每种符号出现的机会均等，在某些位上分布不均匀只 有某几种符号经常出现。可根据散列表的大小，选择其中各种符号分布均匀的若干位作为散 列地址。例如：</strong></p> 
<p>        假设要存储某家公司员工登记表，如果用手机号作为关键字，那么极有可能前7位都是 相同 的，那么我们可以选择后面的四位作为散列地址，如果这样的抽取工作还容易出现 冲突，还 可以对抽取出来的数字进行反转(如1234改成4321)、右环位移(如1234改成4123)、左环移 位、前两数与后两数叠加(如1234改成12+34=46)等方法。</p> 
<p><strong>        数字分析法通常适合处理关键字位数比较大的情况，如果事先知道关键字的分布且关键字的 若干位分布较均匀的情况</strong></p> 
<p><strong>        注意：哈希函数设计的越精妙，产生哈希冲突的可能性就越低，但是无法避免哈希冲突</strong></p> 
<h3 id="%C2%A0%20%F0%9F%93%82%20%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3"><strong>  📂 哈希冲突解决</strong></h3> 
<p><strong>1. 闭散列</strong></p> 
<p>        <strong>闭散列也叫做开放定址法，当发生哈希冲突时，如果哈希表未被填满，说明在哈希表中必然还有空位置，那么可以吧key存放到冲突位置的“下一个”空位置中区。</strong>那么如果寻找下一个空位置呢？</p> 
<p>        1.1 线性探测：从发生冲突的位置开始，依次向后探测，直到寻找到下一个空位置为止。</p> 
<p>        插入：</p> 
<p>         ● 通过哈希函数获取插入元素在哈希表中的位置</p> 
<p>         ● 如果该位置中没有元素啧直接插入新元素，如果该位置中有元素发生哈希冲突，使用线性探测找到下一个空位置，插入新元素。</p> 
<p><img alt="" height="283" src="https://images2.imgbox.com/c4/54/7m8Irvwn_o.png" width="835"></p> 
<p>        删除：</p> 
<p>    <strong>    采用闭散列处理哈希冲突时，不能随便物理删除哈希表中已有的元素，若直接删除元素会影响到其他元素的搜索。</strong>比如函数元素4，如果直接删除，44差啊后起来会受到影响。<strong>因此线性探测采用标记的未删除法来删除掉一个元素。</strong></p> 
<pre><code class="language-cpp">// 哈希表每个空间给个标记
// EMPTY此位置空， EXIST此位置已经有元素， DELETE元素已经删除
enum State{EMPTY, EXIST, DELETE};
// 注意：假如实现的哈希表中元素唯一，即key相同的元素不再进行插入
// 为了实现简单，此哈希表中我们将比较直接与元素绑定在一起
template&lt;class K, class V&gt;
class HashTable
{
    struct Elem
   {   
        pair&lt;K, V&gt; _val;
        State _state;
   };
    
public:
    HashTable(size_t capacity = 3)
       : _ht(capacity), _size(0)
   {
        for(size_t i = 0; i &lt; capacity; ++i)
            _ht[i]._state = EMPTY;
   }
    
   bool Insert(const pair&lt;K, V&gt;&amp; val)
   {
       // 检测哈希表底层空间是否充足
       // _CheckCapacity();
       size_t hashAddr = HashFunc(key);
       // size_t startAddr = hashAddr;
       while(_ht[hashAddr]._state != EMPTY)
       {
           if(_ht[hashAddr]._state == EXIST &amp;&amp; _ht[hashAddr]._val.first 
== key)
               return false;
           
           hashAddr++;
           if(hashAddr == _ht.capacity())
               hashAddr = 0;
           /*
           // 转一圈也没有找到，注意：动态哈希表，该种情况可以不用考虑，哈希表中元
素个数到达一定的数量，哈希冲突概率会增大，需要扩容来降低哈希冲突，因此哈希表中元素是
不会存满的
           if(hashAddr == startAddr)
               return false;
           */
       }
       
       // 插入元素
       _ht[hashAddr]._state = EXIST;
       _ht[hashAddr]._val = val;
       _size++;
       return true;
   }
   int Find(const K&amp; key)
   {
       size_t hashAddr = HashFunc(key);
       while(_ht[hashAddr]._state != EMPTY)
       {
           if(_ht[hashAddr]._state == EXIST &amp;&amp; _ht[hashAddr]._val.first 
== key)
               return hashAddr;
           
           hashAddr++;
       }
       return hashAddr;
   }
   bool Erase(const K&amp; key)
   {
       int index = Find(key);
       if(-1 != index)
       {
           _ht[index]._state = DELETE;
           _size++;
           return true;
       }
       return false;
   }
   size_t Size()const;
   bool Empty() const;    
   void Swap(HashTable&lt;K, V, HF&gt;&amp; ht);
private:
    size_t HashFunc(const K&amp; key)
   {
        return key % _ht.capacity();
   }
private:
    vector&lt;Elem&gt; _ht;
    size_t _size;
};
</code></pre> 
<p>思考：哈希表什么情况下进行扩容？如何扩容？</p> 
<p><img alt="" height="185" src="https://images2.imgbox.com/ee/1a/F2v1aqqX_o.png" width="920"></p> 
<pre><code class="language-cpp">void CheckCapacity()
{
    if(_size * 10 / _ht.capacity() &gt;= 7)
   {
        HashTable&lt;K, V, HF&gt; newHt(GetNextPrime(ht.capacity));
        for(size_t i = 0; i &lt; _ht.capacity(); ++i)
       {
            if(_ht[i]._state == EXIST)
                newHt.Insert(_ht[i]._val);
       }
        
        Swap(newHt);
   }
}</code></pre> 
<p>线性探测优点：实现非常简单</p> 
<p>线性探测缺点：一<strong>旦发生哈希冲突，所有的冲突连载一起，容易产生数据堆积，即：不同关键码占据了可利用的空位置，使得寻找某关键码的位置需要许多次比较，导致搜搜效率降低</strong>，如何缓解呢？</p> 
<p>        1.2 二次探测</p> 
<p>        线性探测的缺陷是产生冲突的数据堆积在一起，这与其找下一个空位置有关系，因为找空位置的方式就是挨着往后逐个去找，因此二次探测是为了避免该问题。</p> 
<p>        找到下一个空位置的方法为：H(i) = (k + i^2) % m 或者 H(i) = (k - i^2) % m，其中i = 1,2,3..，k是通过哈希函数，对元素键值key进行计算得到的地址，m是表的大小。</p> 
<p>        研究表明：当表的长度为质数且表装载因子a不超过0.5时，新的表项一定能够插入，而且任 何一个位置都不会被探查两次。因此只要表中有一半的空位置，就不会存在表满的问题。在 搜索时可以不考虑表装满的情况，但在插入时必须确保表的装载因子a不超过0.5，如果超出 必须考虑增容。</p> 
<p>        因此，闭散列最大的缺陷就是空间利用率较低，这也是哈希的缺陷。</p> 
<p><strong>2. 开散列</strong></p> 
<p>        开散列又叫做链地址发（开链法），首先要对关键码集合用散列函数计算散列地址，具有相同地址的关键码归于一个集合，每一个子集和称为一个桶，各个桶中的元素通过一个单链表链接起来，各个链表的头节点存储在哈希表中。</p> 
<p><img alt="" height="996" src="https://images2.imgbox.com/38/60/QocGdPOM_o.png" width="1038"></p> 
<pre><code class="language-cpp">template&lt;class V&gt;
struct HashBucketNode
{
    HashBucketNode(const V&amp; data)
       : _pNext(nullptr), _data(data)
   {}
    HashBucketNode&lt;V&gt;* _pNext;
    V _data;
};
// 本文所实现的哈希桶中key是唯一的
template&lt;class V&gt;
class HashBucket
{
    typedef HashBucketNode&lt;V&gt; Node;
    typedef Node* PNode;
public:
    HashBucket(size_t capacity = 3): _size(0)
   { _ht.resize(GetNextPrime(capacity), nullptr);}
    
    // 哈希桶中的元素不能重复
    PNode* Insert(const V&amp; data)
   {
        // 确认是否需要扩容。。。        // _CheckCapacity();
        
        // 1. 计算元素所在的桶号
        size_t bucketNo = HashFunc(data);
        
        // 2. 检测该元素是否在桶中
        PNode pCur = _ht[bucketNo];
        while(pCur)
       {
            if(pCur-&gt;_data == data)
                return pCur;
            
            pCur = pCur-&gt;_pNext;
       }
        
        // 3. 插入新元素
        pCur = new Node(data);
        pCur-&gt;_pNext = _ht[bucketNo];
        _ht[bucketNo] = pCur;
        _size++;
        return pCur;
   }
     
    // 删除哈希桶中为data的元素(data不会重复)，返回删除元素的下一个节点
    PNode* Erase(const V&amp; data)
   {
        size_t bucketNo = HashFunc(data);
        PNode pCur = _ht[bucketNo];
        PNode pPrev = nullptr, pRet = nullptr;
        
        while(pCur)
       {
            if(pCur-&gt;_data == data)
           {
                if(pCur == _ht[bucketNo])
                    _ht[bucketNo] = pCur-&gt;_pNext;
                else
                    pPrev-&gt;_pNext = pCur-&gt;_pNext;
                
                pRet = pCur-&gt;_pNext;
                delete pCur;
                _size--;
                return pRet;
           }
       }
        
        return nullptr;
   }
    
    PNode* Find(const V&amp; data);
    size_t Size()const;
    bool Empty()const;
    void Clear();
    bool BucketCount()const;
    void Swap(HashBucket&lt;V, HF&gt;&amp; ht;
    ~HashBucket();
private:
    size_t HashFunc(const V&amp; data)
   {
        return data%_ht.capacity();
   }
private:
    vector&lt;PNode*&gt; _ht;
    size_t _size;      // 哈希表中有效元素的个数
}；</code></pre> 
<p>开散列增容：</p> 
<p>        桶的个数是一定的，随着元素的不断插入，每个桶中元素的个数不断增多，极端情况下，可 能会导致一个桶中链表节点非常多，会影响的哈希表的性能，因此在一定条件下需要对哈希 表进行增容，那该条件怎么确认呢？开散列最好的情况是：每个哈希桶中刚好挂一个节点， 再继续插入元素时，每一次都会发生哈希冲突，因此，<strong>在元素个数刚好等于桶的个数时，可 以给哈希表增容。</strong></p> 
<pre><code class="language-cpp">void _CheckCapacity()
{
    size_t bucketCount = BucketCount();
    if(_size == bucketCount)
   {
        HashBucket&lt;V, HF&gt; newHt(bucketCount);
        for(size_t bucketIdx = 0; bucketIdx &lt; bucketCount; ++bucketIdx)
       {
            PNode pCur = _ht[bucketIdx];
            while(pCur)
           {
                // 将该节点从原哈希表中拆出来
                _ht[bucketIdx] = pCur-&gt;_pNext;
                
                // 将该节点插入到新哈希表中
                size_t bucketNo = newHt.HashFunc(pCur-&gt;_data);
                pCur-&gt;_pNext = newHt._ht[bucketNo];
                newHt._ht[bucketNo] = pCur;
                pCur = _ht[bucketIdx];
           }
       }
        
        newHt._size = _size;
        this-&gt;Swap(newHt);
   }
}
</code></pre> 
<h2>📁 模拟实现</h2> 
<p><strong>1. 模拟实现哈希表</strong></p> 
<pre><code class="language-cpp">template&lt;class T&gt;
struct HashNode
{
	HashNode()
	{}

	HashNode(const T&amp; data)
		:_data(data)
		, _next(nullptr)
	{}

	T _data;
	HashNode* _next;
};

template&lt;class K,class T,class KOfT ,class Hash=HashFunc&lt;K&gt;&gt;
class HashTable
{
	typedef HashNode&lt;T&gt; Node;

public:

	template&lt;class Ptr,class Ref&gt;
	struct HashTableIterator
	{
		typedef HashNode&lt;T&gt; Node;

		typedef HashTableIterator Self;
			

		Node* _node = nullptr;
		const HashTable* _pht;

		HashTableIterator(Node* node, const HashTable* pht)
			:_node(node)
			, _pht(pht)
		{}
	
		Self&amp; operator++()
		{
			KOfT kot;
			Hash hs;

			if (_node-&gt;_next == nullptr)
			{
				size_t hashi = hs(kot(_node-&gt;_data)) % _pht-&gt;_tables.size();
				hashi++;
				for (; hashi &lt; _pht-&gt;_tables.size();hashi++)
				{
					if (_pht-&gt;_tables[hashi] != nullptr)
					{
						break;
					}
				}
				if (hashi == _pht-&gt;_tables.size())
				{
					_node = nullptr;
				}
				else
				{
					_node = _pht-&gt;_tables[hashi];
				}
			}
			else
			{
				_node = _node-&gt;_next;
			}

			return *this;
		}

		Ref operator*()
		{
			return _node-&gt;_data;
		}

		Ptr operator-&gt;()
		{
			return &amp;_node-&gt;_data;
		}

		bool operator!=(const Self&amp; it)
		{
			return _node != it._node;
		}

	};

	typedef HashTableIterator&lt;T*, T&amp;&gt; Iterator;
	typedef HashTableIterator&lt;const T*, const T&amp;&gt; const_Iterator;

	HashTable()
	{
		_tables.resize(10,nullptr);
		_n = 0;
	}

	Iterator Begin()
	{
		//this -&gt; HT*

		Node* cur = nullptr;
		for (int i = 0; i &lt; _tables.size();i++)
		{
			if (_tables[i])
			{
				cur = _tables[i];
				break;
			}
		}
		return Iterator(cur, this);
	}

	Iterator End()
	{
		//this -&gt; HT*

		return Iterator(nullptr,this);
	}

	const_Iterator Begin() const
	{
		//this -&gt; const HT*

		Node* cur = nullptr;
		for (int i = 0; i &lt; _tables.size();i++)
		{
			if (_tables[i])
			{
				cur = _tables[i];
				break;
			}
		}
		return const_Iterator(cur, this);
	}

	const_Iterator End() const
	{
		//this -&gt; const HT*
		return const_Iterator(nullptr, this);
	}


	Iterator Find(const K&amp; k)
	{
		Hash hs;
		KOfT kot;

		size_t hashi = hs(k) % _tables.size();
		Node* cur = _tables[hashi];
		while (cur)
		{
			if (kot(cur-&gt;_data) == k)
				return Iterator(cur, this);
			cur = cur-&gt;_next;
		}

		return Iterator(nullptr, this);
	}

	pair&lt;Iterator,bool&gt; Insert(const T&amp; data)
	{
		Hash hs;
		KOfT kot;
		Iterator it = Find(kot(data));
		if (it != End())
			return make_pair(it, false);
			
		if (_n == _tables.size())
		{
			//扩容
			vector&lt;Node*&gt; newtables(_tables.size() * 2,nullptr);
			for (int i = 0; i &lt; _tables.size(); i++)
			{
				if (_tables[i])
				{
					Node* cur = _tables[i];
					while (cur)
					{
						size_t hashi = hs(kot(cur-&gt;_data)) % newtables.size();

						Node* next = cur-&gt;_next;
						cur-&gt;_next = newtables[i];
						newtables[hashi] = cur;
						cur = next;
					}
				}
			}
			_tables.swap(newtables);
		}
		size_t hashi = hs(kot(data)) % _tables.size();
		
		Node* newnode = new Node(data);
		newnode-&gt;_next = _tables[hashi];
		_tables[hashi] = newnode;
		_n++;
		return make_pair(Iterator(_tables[hashi], this),true);
	}

	bool Erase(const K&amp; k)
	{
		if (Find(k) == nullptr)
			return false;

		Hash hs;
		KOfT kot;

		size_t hashi = hs(k) % _tables.size();

		Node* prev = nullptr;
		Node* cur = _tables[hashi];
		while (cur)
		{
			if (kot(cur-&gt;_data) == k)
			{
				if (prev == nullptr)
				{
					_tables[hashi] = cur-&gt;_next;
				}
				else
				{
					prev-&gt;_next = cur-&gt;_next;
				}

				delete cur;
				break;
			}
			prev = cur;
			cur = cur-&gt;_next;
		}

		return true;
	}

private:
	vector&lt;Node*&gt; _tables;
	size_t _n = 0;
};</code></pre> 
<p><strong>2. 模拟实现unordered_set</strong></p> 
<pre><code class="language-cpp">template&lt;class K&gt;
class unordered_set
{

	struct SetKOfT
	{
		K operator()(const K&amp; key)
		{
			return key;
		}
	};

public:
	typedef typename hash_bucket::HashTable&lt;K, K, SetKOfT&gt;::Iterator iterator;
	typedef typename hash_bucket::HashTable&lt;K, K, SetKOfT&gt;::const_Iterator const_iterator;

	pair&lt;iterator, bool&gt; insert(const K&amp; key)
	{
		return ht.Insert(key);
	}

	bool erase(const K&amp; key)
	{
		return ht.Erase(key);
	}

	iterator find(const K&amp; key)
	{
		return ht.Find(key);
	}

	iterator begin()
	{
		return ht.Begin();
	}

	iterator end()
	{
		return ht.End();
	}

	const_iterator begin() const
	{
		return ht.Begin();
	}

	const_iterator end() const
	{
		return ht.End();
	}

private:
	hash_bucket::HashTable&lt;K, K,SetKOfT&gt; ht;
};</code></pre> 
<p><strong>3. 模拟实现unordered_map</strong></p> 
<pre><code class="language-cpp">template&lt;class K, class V&gt;
class unordered_map
{

	struct MapKOfT
	{
		K operator()(const pair&lt;K, V&gt;&amp; kv)
		{
			return kv.first;
		}
	};

public:
	typedef typename hash_bucket::HashTable&lt;K, pair&lt;K, V&gt;, MapKOfT&gt;::Iterator iterator;
	typedef typename hash_bucket::HashTable&lt;K, pair&lt;K, V&gt;, MapKOfT&gt;::const_Iterator const_iterator;

	iterator insert(const pair&lt;K, V&gt;&amp; kv)
	{
		return ht.Insert(kv);
	}

	bool erase(const K&amp; key)
	{
		return ht.Erase(key);
	}

	iterator find(const K&amp; key)
	{
		return ht.Find(key);
	}

	iterator begin()
	{
		return ht.Begin();
	}

	iterator end()
	{
		return ht.End();
	}

	const_iterator begin() const
	{
		return ht.Begin();
	}

	const_iterator end() const
	{
		return ht.End();
	}

	V&amp; operator[](const K&amp; key)
	{
		pair&lt;iterator, bool&gt; ret = ht.Insert(make_pair(key, V()));
		return ret.first-&gt;second;
	}

private:
	hash_bucket::HashTable&lt;K, pair&lt;K,V&gt;,MapKOfT&gt; ht;
};</code></pre> 
<h2 style="background-color:transparent;">📁 总结</h2> 
<p>        以上，就是本期内容，介绍了unordered_set 和 unordered_map是什么，底层的哈希表，什么是哈希，以及哈希实现快速查找的原理，通过某种哈希函数对关键字进行计算，得到地址。也讲解了如果不同值计算得到相同地址，即哈希冲突时，如何处理。</p> 
<p>        最后，也给出了模拟实现哈希表，unordered_set 和 unordered_map的代码。</p> 
<p><img alt="" height="240" src="https://images2.imgbox.com/86/a7/eSENrclS_o.gif" width="240"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ca7218268e325713eb7d0e4e2a8cee04/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【数据结构】二叉树链式结构的实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f8cf63645d4b14dc08c49b2695688e94/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">性能优化随笔(一)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>