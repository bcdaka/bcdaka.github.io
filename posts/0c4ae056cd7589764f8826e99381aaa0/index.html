<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>k8s 四种Service类型(ClusterIP、NodePort、LoadBalancer、ExternalName)详解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/0c4ae056cd7589764f8826e99381aaa0/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="k8s 四种Service类型(ClusterIP、NodePort、LoadBalancer、ExternalName)详解">
  <meta property="og:description" content="🐇明明跟你说过：个人主页
🏅个人专栏：《Kubernetes航线图：从船长到K8s掌舵者》 🏅
🔖行路有良友，便是天堂🔖
目录
一、引言
1、k8s概述
2、Service在Kubernetes中的作用
二、ClusterIP类型
1、ClusterIP 类型的特点和用途
2、ClusterIP 的工作机制
3、创建示例
4、ClusterIP 使用场景 三、NodePort类型
1、NodePort 类型的特点和用途
2、NodePort 的工作机制
3、创建示例
4、NodePort 使用场景
5、注意事项
四、LoadBalancer类型
1、LoadBalancer 类型的特点和用途
2、LoadBalancer 的工作机制
3、创建示例
4、使用场景
5、注意事项
五、ExternalName类型
1、ExternalName 类型的特点和用途
2、ExternalName 的工作机制
3、创建示例
4、使用场景
5、注意事项
一、引言 1、k8s概述 Kubernetes（简称K8s）是一个开源的容器编排平台，用于自动化应用程序的部署、扩展和管理。它最初由谷歌开发，并在2014年捐赠给云原生计算基金会（CNCF）。Kubernetes为容器化应用提供了一个灵活、可扩展和高效的管理平台。
2、Service在Kubernetes中的作用 在 Kubernetes 中，Service 是一种抽象方式，用于定义一组逻辑上的 Pod 以及访问这些 Pod 的策略。Service 解决了 Pod 的生命周期管理和通信问题，提供了稳定的网络端点和负载均衡机制，确保应用程序的高可用性和可扩展性。
主要作用
1. 稳定的访问入口：
每个 Pod 都有自己的 IP 地址，但是这些地址是动态分配的，当 Pod 被删除或重新创建时，IP 地址会发生变化。Service 为一组 Pod 提供一个稳定的 IP 地址和 DNS 名称，使得应用程序可以通过固定的端点进行访问。 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-08T07:30:00+08:00">
    <meta property="article:modified_time" content="2024-08-08T07:30:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">k8s 四种Service类型(ClusterIP、NodePort、LoadBalancer、ExternalName)详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center" style="margin-left:0;text-align:center;"><img alt="" height="1080" src="https://images2.imgbox.com/6f/45/euzYLPs7_o.jpg" width="1200"></p> 
<p style="text-align:center;">🐇明明跟你说过：<a href="https://blog.csdn.net/weixin_53269650?spm=1011.2415.3001.5343" title="个人主页">个人主页</a></p> 
<p style="text-align:center;">🏅个人专栏：<a href="https://blog.csdn.net/weixin_53269650/category_12563985.html" title="《Kubernetes航线图：从船长到K8s掌舵者》">《Kubernetes航线图：从船长到K8s掌舵者》</a> 🏅</p> 
<p style="text-align:center;">🔖行路有良友，便是天堂🔖</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%BC%95%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%BC%95%E8%A8%80" rel="nofollow">一、引言</a></p> 
<p id="1%E3%80%81k8s%E6%A6%82%E8%BF%B0-toc" style="margin-left:40px;"><a href="#1%E3%80%81k8s%E6%A6%82%E8%BF%B0" rel="nofollow">1、k8s概述</a></p> 
<p id="2%E3%80%81Service%E5%9C%A8Kubernetes%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8-toc" style="margin-left:40px;"><a href="#2%E3%80%81Service%E5%9C%A8Kubernetes%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8" rel="nofollow">2、Service在Kubernetes中的作用</a></p> 
<p id="%E4%BA%8C%E3%80%81ClusterIP%E7%B1%BB%E5%9E%8B-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81ClusterIP%E7%B1%BB%E5%9E%8B" rel="nofollow">二、ClusterIP类型</a></p> 
<p id="1%E3%80%81ClusterIP%20%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E7%94%A8%E9%80%94-toc" style="margin-left:40px;"><a href="#1%E3%80%81ClusterIP%20%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E7%94%A8%E9%80%94" rel="nofollow">1、ClusterIP 类型的特点和用途</a></p> 
<p id="2%E3%80%81ClusterIP%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-toc" style="margin-left:40px;"><a href="#2%E3%80%81ClusterIP%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6" rel="nofollow">2、ClusterIP 的工作机制</a></p> 
<p id="3%E3%80%81%E5%88%9B%E5%BB%BA%E7%A4%BA%E4%BE%8B-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E5%88%9B%E5%BB%BA%E7%A4%BA%E4%BE%8B" rel="nofollow">3、创建示例</a></p> 
<p id="4%E3%80%81ClusterIP%20%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%C2%A0-toc" style="margin-left:40px;"><a href="#4%E3%80%81ClusterIP%20%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%C2%A0" rel="nofollow">4、ClusterIP 使用场景 </a></p> 
<p id="%E4%B8%89%E3%80%81NodePort%E7%B1%BB%E5%9E%8B-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81NodePort%E7%B1%BB%E5%9E%8B" rel="nofollow">三、NodePort类型</a></p> 
<p id="1%E3%80%81NodePort%20%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E7%94%A8%E9%80%94-toc" style="margin-left:40px;"><a href="#1%E3%80%81NodePort%20%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E7%94%A8%E9%80%94" rel="nofollow">1、NodePort 类型的特点和用途</a></p> 
<p id="2%E3%80%81NodePort%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-toc" style="margin-left:40px;"><a href="#2%E3%80%81NodePort%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6" rel="nofollow">2、NodePort 的工作机制</a></p> 
<p id="3%E3%80%81%E5%88%9B%E5%BB%BA%E7%A4%BA%E4%BE%8B-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E5%88%9B%E5%BB%BA%E7%A4%BA%E4%BE%8B" rel="nofollow">3、创建示例</a></p> 
<p id="4%E3%80%81NodePort%20%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#4%E3%80%81NodePort%20%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">4、NodePort 使用场景</a></p> 
<p id="5%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" rel="nofollow">5、注意事项</a></p> 
<p id="%E5%9B%9B%E3%80%81LoadBalancer%E7%B1%BB%E5%9E%8B-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81LoadBalancer%E7%B1%BB%E5%9E%8B" rel="nofollow">四、LoadBalancer类型</a></p> 
<p id="1%E3%80%81LoadBalancer%20%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E7%94%A8%E9%80%94-toc" style="margin-left:40px;"><a href="#1%E3%80%81LoadBalancer%20%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E7%94%A8%E9%80%94" rel="nofollow">1、LoadBalancer 类型的特点和用途</a></p> 
<p id="2%E3%80%81LoadBalancer%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-toc" style="margin-left:40px;"><a href="#2%E3%80%81LoadBalancer%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6" rel="nofollow">2、LoadBalancer 的工作机制</a></p> 
<p id="3%E3%80%81%E5%88%9B%E5%BB%BA%E7%A4%BA%E4%BE%8B-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E5%88%9B%E5%BB%BA%E7%A4%BA%E4%BE%8B" rel="nofollow">3、创建示例</a></p> 
<p id="4%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">4、使用场景</a></p> 
<p id="5%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" rel="nofollow">5、注意事项</a></p> 
<p id="%E4%BA%94%E3%80%81ExternalName%E7%B1%BB%E5%9E%8B-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81ExternalName%E7%B1%BB%E5%9E%8B" rel="nofollow">五、ExternalName类型</a></p> 
<p id="1%E3%80%81ExternalName%20%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E7%94%A8%E9%80%94-toc" style="margin-left:40px;"><a href="#1%E3%80%81ExternalName%20%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E7%94%A8%E9%80%94" rel="nofollow">1、ExternalName 类型的特点和用途</a></p> 
<p id="2%E3%80%81ExternalName%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-toc" style="margin-left:40px;"><a href="#2%E3%80%81ExternalName%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6" rel="nofollow">2、ExternalName 的工作机制</a></p> 
<p id="3%E3%80%81%E5%88%9B%E5%BB%BA%E7%A4%BA%E4%BE%8B-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E5%88%9B%E5%BB%BA%E7%A4%BA%E4%BE%8B" rel="nofollow">3、创建示例</a></p> 
<p id="4%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">4、使用场景</a></p> 
<p id="5%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" rel="nofollow">5、注意事项</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E5%BC%95%E8%A8%80">一、引言</h2> 
<h3 id="1%E3%80%81k8s%E6%A6%82%E8%BF%B0">1、k8s概述</h3> 
<p><span style="color:#fe2c24;">Kubernetes（简称K8s）</span>是一个开源的容器编排平台，用于自动化应用程序的部署、扩展和管理。它最初由谷歌开发，并在2014年捐赠给云原生计算基金会（CNCF）。Kubernetes为容器化应用提供了一个灵活、可扩展和高效的管理平台。</p> 
<p class="img-center"><img alt="" height="751" src="https://images2.imgbox.com/7c/2d/kXCV1WFQ_o.png" width="1200"></p> 
<h3 id="2%E3%80%81Service%E5%9C%A8Kubernetes%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8">2、Service在Kubernetes中的作用</h3> 
<blockquote> 
 <p>在 Kubernetes 中，<span style="color:#fe2c24;">Service </span>是一种抽象方式，用于定义一组逻辑上的 Pod 以及访问这些 Pod 的策略。Service 解决了 Pod 的生命周期管理和通信问题，提供了稳定的网络端点和负载均衡机制，确保应用程序的高可用性和可扩展性。</p> 
</blockquote> 
<p><strong>主要作用</strong><br><span style="background-color:#dad5e9;">1. 稳定的访问入口：</span></p> 
<ul><li>每个 Pod 都有自己的 IP 地址，但是这些地址是动态分配的，当 Pod 被删除或重新创建时，IP 地址会发生变化。Service 为一组 Pod 提供一个稳定的 IP 地址和 DNS 名称，使得应用程序可以通过固定的端点进行访问。</li></ul> 
<p><br><span style="background-color:#dad5e9;">2. 负载均衡：</span></p> 
<ul><li>Service 会自动将流量分发到后端的一组 Pod 上，进行负载均衡。这样可以均匀分配流量，防止某个 Pod 过载，并提高整体应用的性能和可靠性。</li></ul> 
<p><br><span style="background-color:#dad5e9;">3. 服务发现：</span></p> 
<ul><li>Kubernetes 内部有一个 DNS 服务，所有 Service 都会在这个 DNS 中注册。当应用程序需要访问某个 Service 时，可以通过 DNS 名称进行访问，而无需关心具体的 Pod IP 地址。</li></ul> 
<p><br><span style="background-color:#dad5e9;">4. 跨节点通信：</span></p> 
<ul><li>Service 可以将请求转发到集群中不同节点上的 Pod，实现跨节点通信。这对于分布式系统和跨节点的应用程序来说非常重要。</li></ul> 
<p></p> 
<p class="img-center"><img alt="" height="745" src="https://images2.imgbox.com/19/91/Ktkhvdfn_o.png" width="1200"></p> 
<h2 id="%E4%BA%8C%E3%80%81ClusterIP%E7%B1%BB%E5%9E%8B">二、ClusterIP类型</h2> 
<blockquote> 
 <p>在 Kubernetes 中，<span style="color:#fe2c24;">ClusterIP</span> 类型的 Service 是最基本和默认的 Service 类型。它在集群内部为一组 Pod 提供一个稳定的 IP 地址和 DNS 名称，使得其他服务可以通过固定的网络端点进行访问，而无需关心 Pod 的动态 IP 地址。</p> 
</blockquote> 
<h3 id="1%E3%80%81ClusterIP%20%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E7%94%A8%E9%80%94">1、ClusterIP 类型的特点和用途</h3> 
<p><span style="background-color:#cbe0f1;">1. 内部访问：</span></p> 
<p>ClusterIP 类型的 Service 只能在 Kubernetes 集群内部访问，无法从集群外部直接访问。它适用于集群内部的服务通信，如微服务之间的调用。</p> 
<p><br><span style="background-color:#cbe0f1;">2. 稳定的访问端点：</span></p> 
<p>ClusterIP 为 Service 分配一个稳定的虚拟 IP 地址。无论背后的 Pod 如何变化，访问 Service 的 IP 地址始终不变，提供了稳定的访问端点。</p> 
<p><br><span style="background-color:#cbe0f1;">3. 自动负载均衡：</span></p> 
<p>ClusterIP 会将流量均匀分发到其后端的所有 Pod 上，实现负载均衡。这样可以有效地分散负载，提高应用的性能和可靠性。</p> 
<p class="img-center"><img alt="" height="660" src="https://images2.imgbox.com/8d/47/2pq1lTgK_o.png" width="1200"></p> 
<h3 id="2%E3%80%81ClusterIP%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><br> 2、ClusterIP 的工作机制</h3> 
<p><span style="background-color:#c7e6ea;">1. 标签选择器：</span></p> 
<p>ClusterIP Service 使用标签选择器（Selector）来确定与哪些 Pod 关联。符合选择器条件的所有 Pod 会成为该 Service 的后端。</p> 
<p><br><span style="background-color:#c7e6ea;">2. Endpoints 对象：</span></p> 
<p>Kubernetes 会自动维护一个 Endpoints 对象，记录与 ClusterIP Service 关联的所有 Pod 的 IP 地址和端口。当关联的 Pod 状态发生变化时，Endpoints 对象会自动更新。</p> 
<p><br><span style="background-color:#c7e6ea;">3. kube-proxy：</span></p> 
<p>kube-proxy 是 Kubernetes 集群中的网络代理，负责实现 Service 的网络规则。对于 ClusterIP 类型的 Service，kube-proxy 会在每个 Node 上设置 iptables 规则或 IPVS 规则，将访问 ClusterIP 的流量转发到相应的 Pod 上。</p> 
<p class="img-center"><img alt="" height="963" src="https://images2.imgbox.com/94/69/VnSJ16aq_o.png" width="1200"></p> 
<h3 id="3%E3%80%81%E5%88%9B%E5%BB%BA%E7%A4%BA%E4%BE%8B">3、创建示例</h3> 
<p>以下是一个创建 ClusterIP 类型 Service 的示例：</p> 
<pre><code>apiVersion: v1
kind: Service
metadata:
  name: my-clusterip-service
spec:
  selector:
    app: MyApp
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8080
  type: ClusterIP</code></pre> 
<ul><li><strong>kind: </strong>Service 表示这是一个 Service 资源。</li><li><strong>metadata </strong>包含 Service 的元数据，例如名称。</li><li><strong>spec </strong>定义了 Service 的行为和配置。 
  <ul><li> <strong>selector </strong>指定了 Pod 的标签选择器，选择带有 app=MyApp 标签的 Pod。</li><li> <strong>ports </strong>定义了服务的端口映射，将 Service 的 80 端口映射到 Pod 的 8080 端口。</li><li> <strong>type </strong>明确指定了 Service 的类型为 ClusterIP。</li></ul></li></ul> 
<h3 id="4%E3%80%81ClusterIP%20%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%C2%A0">4、ClusterIP 使用场景 </h3> 
<p><span style="background-color:#d4e9d5;">1. 微服务架构：</span></p> 
<p>在微服务架构中，不同的服务通常会通过 ClusterIP 类型的 Service 相互调用，确保服务之间的稳定通信。</p> 
<p><br><span style="background-color:#d4e9d5;">2. 内部负载均衡：</span></p> 
<p>集群内的负载均衡，通过 ClusterIP Service 将流量均匀分配到后端的多个 Pod，提高应用的可靠性和可扩展性。</p> 
<p><br><span style="background-color:#d4e9d5;">3. 后端服务：</span></p> 
<p>对于数据库、缓存等后端服务，可以使用 ClusterIP 类型的 Service 进行访问，确保集群内所有服务都可以通过稳定的端点访问这些后端服务。</p> 
<p>   </p> 
<p class="img-center"><img alt="" height="859" src="https://images2.imgbox.com/55/57/bA9Q9Aii_o.png" width="790"></p> 
<h2 id="%E4%B8%89%E3%80%81NodePort%E7%B1%BB%E5%9E%8B">三、NodePort类型</h2> 
<blockquote> 
 <p><span style="color:#fe2c24;">NodePort </span>类型的 Service 是 Kubernetes 中的一种 Service 类型，用于将集群内部的服务暴露给外部访问。NodePort 通过在每个 Node 上打开一个特定端口，将外部请求转发到集群内部的 Service，进而到达后端的 Pod。</p> 
</blockquote> 
<h3 id="1%E3%80%81NodePort%20%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E7%94%A8%E9%80%94">1、NodePort 类型的特点和用途</h3> 
<p><span style="background-color:#f9eda6;">1. 外部访问：</span></p> 
<p>NodePort 使集群内部的服务能够通过集群外部的请求访问。它在每个 Node 上分配一个固定端口，将流量转发到 Service。</p> 
<p><br><span style="background-color:#f9eda6;">2. 固定端口：</span></p> 
<p>NodePort 类型的 Service 会在每个 Node 上分配一个从 30000 到 32767 范围内的端口。这个端口在整个集群内是固定的，可以通过 &lt;NodeIP&gt;:&lt;NodePort&gt; 进行访问。</p> 
<p><br><span style="background-color:#f9eda6;">3. 简单易用：</span></p> 
<p>NodePort 是一种简单的方式来暴露集群内的服务，适用于开发和测试环境，也可以作为负载均衡器或 ing  ress 控制器的基础。</p> 
<p class="img-center"><img alt="" height="871" src="https://images2.imgbox.com/b9/e8/hbVDXUFl_o.jpg" width="1200"></p> 
<h3 id="2%E3%80%81NodePort%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><br> 2、NodePort 的工作机制</h3> 
<p><span style="background-color:#ffd7b9;">1. NodePort 分配：</span></p> 
<p>当创建一个 NodePort 类型的 Service 时，Kubernetes 会在每个 Node 上分配一个固定的端口，并配置 iptables 或 IPVS 规则，将外部请求转发到 Service。</p> 
<p><br><span style="background-color:#ffd7b9;">2. 流量转发：</span></p> 
<p>外部请求通过 &lt;NodeIP&gt;:&lt;NodePort&gt; 访问集群内的服务。kube-proxy 会将这些请求转发到对应的 Service IP，进而分发到后端的 Pod 上。</p> 
<p><br><span style="background-color:#ffd7b9;">3. 负载均衡：</span></p> 
<p>和 ClusterIP 类似，NodePort 类型的 Service 也会进行负载均衡，将流量均匀分发到后端的 Pod 上。</p> 
<h3>3、创建示例</h3> 
<p>以下是一个创建 NodePort 类型 Service 的示例：</p> 
<pre><code>apiVersion: v1
kind: Service
metadata:
  name: my-nodeport-service
spec:
  selector:
    app: MyApp
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8080
      nodePort: 30001
  type: NodePort</code></pre> 
<p></p> 
<ul><li><strong>kind: </strong>Service 表示这是一个 Service 资源。</li><li><strong>metadata </strong>包含 Service 的元数据，例如名称。</li><li><strong>spec </strong>定义了 Service 的行为和配置。 
  <ul><li><strong>selector </strong>指定了 Pod 的标签选择器，选择带有 app=MyApp 标签的 Pod。</li><li><strong>ports</strong> 定义了服务的端口映射。</li><li><strong>port </strong>是 Service 的端口（集群内部使用）。</li><li><strong>targetPort </strong>是 Pod 上的端口（容器内部应用监听的端口）。</li><li><strong>nodePort</strong> 是在每个 Node 上分配的固定端口，通过这个端口可以从外部访问 Service。</li></ul></li><li><strong>type </strong>明确指定了 Service 的类型为 NodePort。</li></ul> 
<h3 id="4%E3%80%81NodePort%20%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><br> 4、NodePort 使用场景</h3> 
<p><span style="background-color:#dad5e9;">1. 开发和测试环境：</span></p> 
<p>在开发和测试环境中，NodePort 提供了一种简单的方式来暴露集群内部的服务，方便测试和调试。</p> 
<p><br><span style="background-color:#dad5e9;">2. 临时访问：</span></p> 
<p>在需要临时访问集群内部服务的情况下，NodePort 提供了一种快速解决方案。</p> 
<p><br><span style="background-color:#dad5e9;">3. 基础设施的负载均衡：</span></p> 
<p>NodePort 可以作为负载均衡器或 ingress 控制器的基础，将流量转发到集群内部的服务。</p> 
<p class="img-center"><img alt="" height="840" src="https://images2.imgbox.com/21/93/6zRgkFTj_o.png" width="1200"></p> 
<h3 id="5%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><br> 5、注意事项</h3> 
<p><span style="background-color:#cbe0f1;">1. 端口范围：</span></p> 
<p>NodePort 端口范围为 30000 到 32767，确保在配置时避免冲突。</p> 
<p><br><span style="background-color:#cbe0f1;">2. 安全性：</span></p> 
<p>暴露到外部的 NodePort 端口存在一定的安全风险，建议在生产环境中使用更高级的解决方案（如 LoadBalancer 或 Ingress）来确保安全性。</p> 
<p><br><span style="background-color:#cbe0f1;">3. 负载均衡限制：</span></p> 
<p>NodePort 提供的负载均衡是基于简单的轮询算法，不如专业负载均衡器复杂和高效。</p> 
<h2 id="%E5%9B%9B%E3%80%81LoadBalancer%E7%B1%BB%E5%9E%8B">四、<strong>LoadBalancer类型</strong></h2> 
<blockquote> 
 <p>在 Kubernetes 中，<span style="color:#fe2c24;">LoadBalancer </span>类型的 Service 是一种常见的服务暴露方式，主要用于将集群内部的服务暴露给外部，并且由云提供商自动配置外部负载均衡器。LoadBalancer 类型的 Service 提供了一个外部 IP 地址，可以直接通过这个地址访问集群内的服务，适用于需要高可用性和自动扩展的场景。</p> 
</blockquote> 
<h3 id="1%E3%80%81LoadBalancer%20%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E7%94%A8%E9%80%94">1、LoadBalancer 类型的特点和用途</h3> 
<p><span style="background-color:#cbe0f1;">1. 外部访问：</span></p> 
<p>LoadBalancer 为集群内部的服务提供一个外部 IP 地址，使得外部客户端可以直接访问。</p> 
<p><br><span style="background-color:#cbe0f1;">2. 自动配置：</span></p> 
<p>在公有云环境中（如 AWS、Azure、Google Cloud），Kubernetes 会自动配置云提供商的负载均衡器，将外部流量转发到集群内部的服务。</p> 
<p><br><span style="background-color:#cbe0f1;">3. 高可用性：</span></p> 
<p>LoadBalancer 结合云提供商的负载均衡服务，能够提供高可用性和自动扩展功能，确保服务的可靠性和性能。</p> 
<p class="img-center"><img alt="" height="891" src="https://images2.imgbox.com/2b/d6/BlwFCT5R_o.png" width="1200"></p> 
<h3 id="2%E3%80%81LoadBalancer%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><br> 2、LoadBalancer 的工作机制</h3> 
<p><span style="background-color:#c7e6ea;">1. 云提供商集成：</span></p> 
<p>当在公有云环境中创建 LoadBalancer 类型的 Service 时，Kubernetes 会与云提供商的 API 进行交互，自动创建并配置一个外部负载均衡器。</p> 
<p><br><span style="background-color:#c7e6ea;">2. 流量转发：</span></p> 
<p>云提供商的负载均衡器接收外部流量，并将其转发到 Kubernetes 集群中的 Node 上，再由 Node 上的 kube-proxy 转发到相应的 Pod。</p> 
<p><br><span style="background-color:#c7e6ea;">3. 健康检查：</span></p> 
<p>云提供商的负载均衡器通常会对后端 Pod 进行健康检查，确保只将流量发送到健康的 Pod 上。</p> 
<h3><br> 3、创建示例</h3> 
<p>以下是一个创建 LoadBalancer 类型 Service 的示例：</p> 
<pre><code>apiVersion: v1
kind: Service
metadata:
  name: my-loadbalancer-service
spec:
  selector:
    app: MyApp
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8080
  type: LoadBalancer</code></pre> 
<p><br> 在这个示例中：</p> 
<ul><li><strong>kind: </strong>Service 表示这是一个 Service 资源。</li><li><strong>metadata </strong>包含 Service 的元数据，例如名称。</li><li><strong>spec</strong> 定义了 Service 的行为和配置。</li><li><strong>selector </strong>指定了 Pod 的标签选择器，选择带有 app=MyApp 标签的 Pod。</li><li><strong>ports </strong>定义了服务的端口映射。</li><li><strong>port </strong>是 Service 的端口（外部客户端访问的端口）。</li><li><strong>targetPort </strong>是 Pod 上的端口（容器内部应用监听的端口）。</li><li><strong>type </strong>明确指定了 Service 的类型为 LoadBalancer。</li></ul> 
<h3 id="4%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">4、使用场景</h3> 
<p><span style="background-color:#c7e6ea;">1. 生产环境：</span></p> 
<p>LoadBalancer 类型的 Service 适用于生产环境中需要高可用性和自动扩展的服务。</p> 
<p><br><span style="background-color:#c7e6ea;">2. 外部访问：</span></p> 
<p>当需要将集群内的服务暴露给外部客户端时，可以使用 LoadBalancer 类型的 Service。</p> 
<p><br><span style="background-color:#c7e6ea;">3. 自动化运维：</span></p> 
<p>结合云提供商的负载均衡服务，简化了运维工作，如流量管理、健康检查和故障转移等。</p> 
<p class="img-center"><img alt="" height="774" src="https://images2.imgbox.com/a8/66/XAszyd1n_o.png" width="1090"></p> 
<h3><br> 5、注意事项</h3> 
<p><span style="background-color:#f9eda6;">1. 成本：</span></p> 
<p>使用 LoadBalancer 类型的 Service 可能会产生额外的云提供商费用，特别是在大量使用外部负载均衡器的情况下。</p> 
<p><br><span style="background-color:#f9eda6;">2. 云依赖：</span></p> 
<p>LoadBalancer 类型的 Service 依赖于云提供商的负载均衡服务，因此在本地集群或不支持负载均衡的环境中可能无法使用。</p> 
<p><br><span style="background-color:#f9eda6;">3. 配置限制：</span></p> 
<p>云提供商的负载均衡器可能有一些配置限制，如最大连接数、带宽限制等，需要根据具体需求进行调整和优化。</p> 
<h2 id="%E4%BA%94%E3%80%81ExternalName%E7%B1%BB%E5%9E%8B">五、ExternalName类型</h2> 
<blockquote> 
 <p>在 Kubernetes 中，<span style="color:#fe2c24;">ExternalName</span> 类型的 Service 是一种特殊的 Service 类型，它不通过 Kubernetes 的网络代理（如 kube-proxy）进行流量转发，而是将请求转发到指定的外部 DNS 名称。ExternalName 类型的 Service 主要用于将集群内的服务请求重定向到集群外部的服务，使得 Kubernetes 内部的服务可以透明地访问外部资源。</p> 
</blockquote> 
<h3 id="1%E3%80%81ExternalName%20%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E7%94%A8%E9%80%94">1、ExternalName 类型的特点和用途</h3> 
<p><span style="background-color:#ffd7b9;">1. DNS 名称映射：</span></p> 
<p>ExternalName 类型的 Service 通过 DNS CNAME 记录将请求重定向到指定的外部 DNS 名称，而不是集群内部的 Pod IP 地址。</p> 
<p><br><span style="background-color:#ffd7b9;">2. 无负载均衡：</span></p> 
<p>ExternalName 只是简单地将请求重定向到外部服务，不提供负载均衡、健康检查或服务发现等功能。</p> 
<p><br><span style="background-color:#ffd7b9;">3. 透明访问：</span></p> 
<p>集群内的服务可以通过访问 ExternalName 类型的 Service 像访问集群内的其他服务一样透明地访问外部服务。</p> 
<p class="img-center"><img alt="" height="751" src="https://images2.imgbox.com/90/7e/vvPBYtgy_o.png" width="1200"></p> 
<h3 id="2%E3%80%81ExternalName%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><br> 2、ExternalName 的工作机制</h3> 
<p><span style="background-color:#fbd4d0;">1. CNAME 记录：</span></p> 
<p>ExternalName 类型的 Service 在 Kubernetes 内部 DNS 服务器中创建一个 CNAME 记录，将服务名称映射到指定的外部 DNS 名称。</p> 
<p><br><span style="background-color:#fbd4d0;">2. DNS 查询：</span></p> 
<p>当集群内的服务请求 ExternalName Service 时，DNS 查询会返回外部服务的 DNS 名称，客户端会直接访问该外部服务。</p> 
<h3><br> 3、创建示例</h3> 
<p>以下是一个创建 ExternalName 类型 Service 的示例：</p> 
<pre><code>apiVersion: v1
kind: Service
metadata:
  name: my-external-service
spec:
  type: ExternalName
  externalName: external-service.example.com</code></pre> 
<p><br> 在这个示例中：</p> 
<ul><li><strong>kind: </strong>Service 表示这是一个 Service 资源。</li><li><strong>metadata </strong>包含 Service 的元数据，例如名称。</li><li><strong>spec </strong>定义了 Service 的行为和配置。</li><li><strong>type </strong>明确指定了 Service 的类型为 ExternalName。</li><li><strong>externalName </strong>是外部服务的 DNS 名称，例如 external-service.example.com。</li></ul> 
<p></p> 
<h3>4、使用场景</h3> 
<p><span style="color:#494949;"><span style="background-color:#d7d8d9;">1. 访问外部 API：</span></span></p> 
<p>当 Kubernetes 集群内的应用程序需要访问外部 API 或服务（如第三方 API 服务、外部数据库）时，可以使用 ExternalName 类型的 Service 进行透明访问。</p> 
<p><br><span style="background-color:#d7d8d9;">2. 混合架构：</span></p> 
<p>在混合云或多集群环境中，可以使用 ExternalName 类型的 Service 将请求重定向到外部或其他集群中的服务。</p> 
<p><br><span style="background-color:#d7d8d9;">3. 简化配置：</span></p> 
<p>ExternalName 类型的 Service 可以简化应用程序的配置，通过 Kubernetes 内部的 DNS 名称访问外部服务，而无需在应用程序代码中指定外部 DNS 名称。</p> 
<p class="img-center"><img alt="" height="726" src="https://images2.imgbox.com/1e/0b/8Jj5eJwd_o.png" width="1200"></p> 
<h3><br> 5、注意事项</h3> 
<p><span style="background-color:#ffd7b9;">1. 无负载均衡和健康检查：</span></p> 
<p>ExternalName 类型的 Service 不提供负载均衡和健康检查功能，依赖于外部服务的可用性和稳定性。</p> 
<p><br><span style="background-color:#ffd7b9;">2. 外部服务依赖：</span></p> 
<p>使用 ExternalName 类型的 Service 会引入对外部服务的依赖，确保外部服务的 DNS 名称解析和访问是稳定可靠的。</p> 
<p><br><span style="color:#494949;"><span style="background-color:#ffd7b9;">3. 网络延迟：</span></span></p> 
<p>访问外部服务可能会引入额外的网络延迟，影响应用程序的性能，需要进行适当的性能评估和优化。</p> 
<blockquote> 
 <p>💕💕💕每一次的分享都是一次成长的旅程，感谢您的陪伴和关注。希望这些关于Kubernetes的文章能陪伴您走过技术的一段旅程，共同见证成长和进步！😺😺😺</p> 
 <p></p> 
 <p>🧨🧨🧨让我们一起在技术的海洋中探索前行，共同书写美好的未来！！！  </p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9bde9600e0587c224a0e21e15d10e710/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android沉浸式状态栏库ImmersionBar使用教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1e546e7084d350bb5dff59fbffafdd65/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">DataX-Web UI 项目指南</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>