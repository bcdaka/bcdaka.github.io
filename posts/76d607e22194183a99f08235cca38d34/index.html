<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C＋＋入门基础（二） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/76d607e22194183a99f08235cca38d34/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C＋＋入门基础（二）">
  <meta property="og:description" content="6. 引用（引用就是取别名） 6.1 引用的概念和定义 引用不是新定义一个变量，而是给已存在变量取了⼀个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间。比如：水浒传中李逵，宋江叫&#34;铁牛&#34;，江湖上人称&#34;黑旋风&#34;；林冲，外号豹子头；
类型&amp; 引用别名 = 引用对象;
C&#43;&#43;中为了避免引入太多的运算符，会复用C语言的⼀些符号，比如前面的&lt;&lt; 和 &gt;&gt;，这里引用也和取地址使用了同⼀个符号&amp;，大家注意使用方法角度区分就可以。
int a = 0;
// 引⽤：b和c是a的别名 int&amp; b = a;
int&amp; c = a;
// 也可以给别名b取别名，d相当于还是a的别名 int&amp; d = b;
这串代码在底层的角度是这样的 对指针变量取别名：
int* p1 = &amp;a; int*&amp; p2 = p1;
指针变量的使用： typedef struct ListNode
{
int val;
struct ListNode* next;
}LTNode, *PNode;
int main()
{
PNode plist = NULL;
ListPushBack(plist, 1);
return 0;
}
这里的*PNode是指把typedef struct ListNode* 定义为PNode。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-06T19:20:36+08:00">
    <meta property="article:modified_time" content="2024-08-06T19:20:36+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C＋＋入门基础（二）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>6. 引用（引用就是取别名）</h2> 
<h3>6.1 引用的概念和定义</h3> 
<p>引用不是新定义一个变量，而是给已存在变量取了⼀个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间。比如：水浒传中李逵，宋江叫"铁牛"，江湖上人称"黑旋风"；林冲，外号豹子头；</p> 
<p><strong>类型&amp; 引用别名 = 引用对象;</strong></p> 
<p>C++中为了避免引入太多的运算符，会复用C语言的⼀些符号，比如前面的&lt;&lt; 和 &gt;&gt;，这里引用也和取地址使用了同⼀个符号&amp;，大家注意使用方法角度区分就可以。</p> 
<blockquote> 
 <p> int a = 0;</p> 
 <p><em>// </em><em>引⽤：</em><em>b</em><em>和</em><em>c</em><em>是</em><em>a</em><em>的别名 </em></p> 
 <p>int&amp; b = a;</p> 
 <p>int&amp; c = a;</p> 
 <p><em>// </em><em>也可以给别名</em><em>b</em><em>取别名，</em><em>d</em><em>相当于还是</em><em>a</em><em>的别名 </em></p> 
 <p>int&amp; d = b;</p> 
</blockquote> 
<p><img alt="" height="252" src="https://images2.imgbox.com/f3/2b/hZ1zbxrb_o.png" width="822"></p> 
<p style="text-align:center;">这串代码在底层的角度是这样的 </p> 
<p style="text-align:center;"><img alt="" height="602" src="https://images2.imgbox.com/87/ba/ReNfVTaZ_o.png" width="1030"></p> 
<blockquote> 
 <p>对指针变量取别名：</p> 
 <p>int* p1 = &amp;a; </p> 
 <p>int*&amp; p2 = p1;</p> 
</blockquote> 
<p> 指针变量的使用： <img alt="" height="682" src="https://images2.imgbox.com/23/fa/M7elJ5Yn_o.png" width="1003"></p> 
<blockquote> 
 <p>typedef struct ListNode</p> 
 <p>{<!-- --></p> 
 <p>   int val;</p> 
 <p>   struct ListNode* next;</p> 
 <p>}LTNode, *PNode;</p> 
 <p>int main()</p> 
 <p>{<!-- --></p> 
 <p>   PNode plist = NULL;</p> 
 <p>   ListPushBack(plist, 1);</p> 
 <p>   return 0;</p> 
 <p>}</p> 
 <p> 这里的*PNode是指把typedef struct ListNode* 定义为PNode。</p> 
</blockquote> 
<h3>6.2 <span style="color:#1f2329;">引用的特性 </span></h3> 
<div> 
 <span style="color:#1456f0;">• </span> 
 <span style="color:#1f2329;">引用在定义时必须初始化 </span> 
</div> 
<div> 
 <p class="img-center"><img alt="" height="60" src="https://images2.imgbox.com/45/cd/QucULZXO_o.png" width="199"></p> 
</div> 
<div> 
 <span style="color:#1456f0;">• </span> 
 <span style="color:#1f2329;">⼀个变量可以有多个引用</span> 
</div> 
<div> 
 <img alt="" height="490" src="https://images2.imgbox.com/1d/86/OgpWG2J9_o.png" width="1194"> 
</div> 
<div> 
 <span style="color:#1456f0;">• </span> 
 <span style="color:#1f2329;">引用一旦引用⼀个实体，就不能引用其他实体</span> 
</div> 
<div> 
 <img alt="" height="343" src="https://images2.imgbox.com/23/ec/aWkpzsgM_o.png" width="1009"> 
</div> 
<div> 
 <img alt="" height="751" src="https://images2.imgbox.com/36/1c/PwGeDOwV_o.png" width="1200"> 
</div> 
<p>这里的d的地址没变，说明d还是a的别名，d没有指向e，只是把e的值赋给了d。</p> 
<p>当我们实现链表的时候，我们要删除一个结点，但这时的地址之间是相互关联的，因为引用不能改变指向，所以就不可能完成。所以C＋＋的指针引用不能完全替代指针。</p> 
<p class="img-center"><img alt="" height="208" src="https://images2.imgbox.com/d9/82/HuriYEH9_o.png" width="636"></p> 
<p></p> 
<h3><strong>6.3</strong> <span style="color:#1f2329;">引用的使用</span></h3> 
<div> 
 <span style="color:#1456f0;">• </span> 
 <span style="color:#1f2329;">引用在实践中主要是用于<strong>引用传参和引用做返回值中减少拷贝提高效率和改变引用对象时同时改变被引用对象。</strong>引用用作别名，没有额外开辟空间，可减少拷贝效率。</span> 
</div> 
<div> 
 <img alt="" height="606" src="https://images2.imgbox.com/00/9d/qPMzwmns_o.png" width="1117"> 
</div> 
<p>减少拷贝的案例：</p> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/34/13/bWxAl30a_o.png" width="532"></p> 
<div> 
 <div> 
  <span style="color:#1456f0;">• </span> 
  <span style="color:#1f2329;">引用传参跟指针传参功能是类似的，引用传参相对更方便一些。 </span> 
 </div> 
 <div> 
  <span style="color:#1456f0;">• </span> 
  <span style="color:#1f2329;">引用返回值的场景相对比较复杂，我们在这里简单讲了一下场景，还有一些内容后续类和对象章节中会继续深入讲解。 </span> 
 </div> 
 <div> 
  <span style="color:#1456f0;">• </span> 
  <span style="color:#1f2329;">引用和指针在实践中相辅相成，功能有重叠性，但是各有特点，互相不可替代。C++的引用跟其他语言的引用(如Java)是有很大的区别的，除了用法，最大的点，C++引用定义后不能改变指向， </span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">Java的引用可以改变指向。 </span> 
 </div> 
 <div> 
  <span style="color:#1456f0;">• </span> 
  <span style="color:#1f2329;">⼀些主要用C代码实现版本数据结构教材中，使用C++引用替代指针传参，目的是简化程序，避开复杂的指针，但是很多同学没学过引用，导致一头雾水。</span> 
 </div> 
 <div> 
  <p class="img-center"><img alt="" height="390" src="https://images2.imgbox.com/d6/52/wY4egrKV_o.png" width="568"></p> 
 </div> 
</div> 
<p><span style="color:#1f2329;">传值传参会生成一个拷贝，传值返回也会生成一个拷贝。C＋＋中是这样规定的，在红线这里进行一个传值返回，返回这个对象的时候，</span> 他不会引用这个对象做函数调用的返回值，不会返回要返回的东西，它会生成一个临时对象，把这的值给临时变量，再用临时变量做这个整个表达式的返回值。STTop（st1）+=1；这是的加1就是加到临时对象上面。临时对象具有常性。</p> 
<p>那临时对象是什么呢？</p> 
<p>临时变量通常是指编译器在栈里面临时开一块空间存储中间值的这种，也有可能是用寄存器去存。</p> 
<p>这里如何使用STTop（st1）+=1呢？只需要采用引用返回就可以了。传引用返回就是返回他的别名，也就是这里的2。也就a数组指向的top-1这里的对象。这时候就把引用对象给改变了。</p> 
<p><img alt="" height="217" src="https://images2.imgbox.com/b8/e5/zJSYYj3I_o.png" width="822"></p> 
<p class="img-center"><img alt="" height="234" src="https://images2.imgbox.com/8e/63/Pg1NE2rY_o.png" width="519"></p> 
<blockquote> 
 <p>typedef int STDataType;<br> typedef struct Stack<br> {<!-- --><br>     STDataType* a;<br>     int top;<br>     int capacity;<br> }ST;</p> 
 <p>void STInit(ST&amp; rs, int n = 4)<br> {<!-- --><br>     rs.a = (STDataType*)malloc(n * sizeof(STDataType));<br>     rs.top = 0;<br>     rs.capacity = n;<br> }</p> 
 <p>// 栈顶<br> void STPush(ST&amp; rs, STDataType x)<br> {<!-- --><br>     // 满了， 扩容<br>     if (rs.top == rs.capacity)<br>     {<!-- --><br>         printf("扩容\n");<br>         int newcapacity = rs.capacity == 0 ? 4 : rs.capacity * 2;<br>         STDataType* tmp = (STDataType*)realloc(rs.a, newcapacity *<br>             sizeof(STDataType));<br>         if (tmp == NULL)<br>         {<!-- --><br>             perror("realloc fail");<br>             return;<br>         }<br>         rs.a = tmp;<br>         rs.capacity = newcapacity;<br>     }<br>     rs.a[rs.top] = x;<br>     rs.top++;<br> }<br> int&amp; STTop(ST&amp; rs)<br> {<!-- --><br>     assert(rs.top &gt; 0);</p> 
 <p>    return rs.a[rs.top - 1];<br> }<br> int main()<br> {<!-- --><br>     ST st1;<br>     STInit(st1);<br>     STPush(st1, 1);<br>     STPush(st1, 2);<br>     cout &lt;&lt; STTop(st1) &lt;&lt; endl;<br>     //修改栈顶的数据呢<br>     (STTop(st1)) += 1;<br>     cout &lt;&lt; STTop(st1) &lt;&lt; endl;<br>     return 0;<br> }</p> 
</blockquote> 
<p> 其实指针也可以做到：</p> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/b0/76/INrKOniS_o.png" width="627"></p> 
<p>并不是任何场景都能用引用返回（后面结合类和对象讲），比如说：</p> 
<p class="img-center"><img alt="" height="267" src="https://images2.imgbox.com/fa/49/jTZdemV1_o.png" width="363"></p> 
<p>ret是局部变量，这里类似于野引用。</p> 
<blockquote> 
 <p>int* fun( )</p> 
 <p>{<!-- --></p> 
 <p>     int ret = 10;</p> 
 <p>     return *ret;</p> 
 <p>}</p> 
 <p>这里的指针就越界了，指针越界不一定报错。 </p> 
</blockquote> 
<p><img alt="" height="553" src="https://images2.imgbox.com/c5/7d/MENva0oz_o.png" width="1118"><img alt="" height="582" src="https://images2.imgbox.com/2e/bb/AUejqm9U_o.png" width="1163"> <img alt="" height="298" src="https://images2.imgbox.com/62/8d/YIBzFFUL_o.png" width="1006"></p> 
<p>在vs中设置了抽查位置，这两个位置不分配给别人，给两个固定的值，在程序运行结束时看这两个位置的值有没有发生改变，没有被修改就说明没有越界。 </p> 
<h3>6.4 <span style="color:#1f2329;">const引用</span></h3> 
<div> 
 <span style="color:#1456f0;">• </span> 
 <span style="color:#1f2329;">可以引用一个 const 对象，但是必须用 const 引用。const 引用也可以引用普通对象，因为对象的访问权限在引用过程中可以缩小，但是不能放大。<strong>（const对象只能用const引用，普通对象可以用const引用，也可以普通引用。引用、指针存在权限的放大和缩小。）</strong></span> 
</div> 
<div> 
 <p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/b9/02/k3lbImJP_o.png" width="357"></p> 
</div> 
<p style="text-align:center;"><img alt="" height="250" src="https://images2.imgbox.com/6a/30/YzbrAvfN_o.png" width="388"></p> 
<p class="img-center"><img alt="" height="250" src="https://images2.imgbox.com/bd/a2/aXQfk7Z2_o.png" width="324"></p> 
<p> 这里是把x的这块空间拷贝给给y，x不能修改这块空间。</p> 
<p>下面这个也是经典的权限放大：</p> 
<p><img alt="" height="159" src="https://images2.imgbox.com/67/a6/Sh3vYP1j_o.png" width="580"></p> 
<p>下图这个是权限的缩小： </p> 
<p class="img-center"><img alt="" height="172" src="https://images2.imgbox.com/59/93/JcnuYKgD_o.png" width="616"></p> 
<p><img alt="" height="930" src="https://images2.imgbox.com/68/c7/GFMw3wHN_o.png" width="1200"></p> 
<p>p1对于a的权限是只读不能写的，p1拷贝给给p2，p2又变成可读可写的了，p2的权限被放大，p5指向b的权限是可读可写的，p6指向p5也是可读可写的（这里不存在权限放大，因为const修饰的是p5本身不是指向的内容）。 </p> 
<div> 
 <span style="color:#1456f0;">• </span> 
 <span style="color:#1f2329;">需要注意的是类似 </span> 
 <span style="color:#1f2329;">int&amp;  rb = a*3; double  d = 12.34; int&amp;  rd = d; </span> 
 <span style="color:#1f2329;">这样⼀些场景下 a*3的和结果保存在一个临时对象中， int&amp;  rd = d </span> 
 <span style="color:#1f2329;">也是类似，在类型转换中会产生临时对象存储中间值，也就是时，rb和rd引用的都是临时对象，而<strong>C++规定临时对象具有常性（所谓常性就像是被const修饰了一样）</strong>，所以这里就触发了权限放大，必须要用常引用才可以。 </span> 
</div> 
<div> 
 <span style="color:#1456f0;">• </span> 
 <span style="color:#1f2329;">所谓临时对象就是编译器需要一个空间暂存表达式的求值结果时临时创建的⼀个未命名的对象， </span> 
</div> 
<div> 
 <span style="color:#1f2329;">C++中把这个未命名对象叫做临时对象。</span> 
</div> 
<p><img alt="" height="280" src="https://images2.imgbox.com/95/7e/CxQiy71w_o.png" width="741"></p> 
<p>a * 3这里存在一个临时变量，临时变量具有常性，这里加个const就行了。</p> 
<p class="img-center"><img alt="" height="150" src="https://images2.imgbox.com/0e/7b/H2GeyMWz_o.png" width="251"></p> 
<p>这里的d给给rd其实也不是直接给过去的，中间也会产生一个临时变量来存储中间的结果。d给给中间的临时对象，这个临时对象是int类型，临时对象再给给rd。</p> 
<p class="img-center"><img alt="" height="84" src="https://images2.imgbox.com/9f/23/fYAImgPD_o.png" width="283"></p> 
<p>类型转换会产生临时对象，d给了临时对象，这里的临时对象给给rd。也就是说rd引用了临时对象。</p> 
<p>那上面这些到底有什么用呢？</p> 
<p>这里的传值传参就不说了，对于引用传参</p> 
<p>void fun(int&amp; rx)如果变量 rx 不改变形参，建议前面加 const，void fun(const int&amp; rx),加const的好处是什么呢？传参就非常宽泛。</p> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/09/27/uCBVEMLd_o.png" width="441"></p> 
<blockquote> 
 <p>const引用的价值是什么？</p> 
 <p>1.可以引用const对象 </p> 
 <p>2.可以引用普通对象</p> 
 <p>3.可以引用临时对象</p> 
</blockquote> 
<h3>6.5 <span style="color:#1f2329;">指针和引用的关系 </span></h3> 
<div> 
 <span style="color:#1f2329;">C++中指针和引用就像两个性格迥异的亲兄弟，指针是哥哥，引用是弟弟，在实践中他们相辅相成，功能有重叠性，但是各有自己的特点，互相不可替代。（下面的结论面试官可能会问）</span> 
</div> 
<div> 
 <strong><span style="color:#1456f0;">• </span><span style="color:#1f2329;">语法概念上引用是⼀个变量的取别名不开空间，指针是存储⼀个变量地址，要开空间。 </span></strong> 
</div> 
<div> 
 <strong><span style="color:#1456f0;">• </span><span style="color:#1f2329;">引用在定义时必须初始化，指针建议初始化，但是语法上不是必须的。 </span></strong> 
</div> 
<div> 
 <strong><span style="color:#1456f0;">• </span><span style="color:#1f2329;">引用在初始化时引用一个对象后，就不能再引用其他对象；而指针可以在不断地改变指向对象。 </span></strong> 
</div> 
<div> 
 <strong><span style="color:#1456f0;">• </span><span style="color:#1f2329;">引用可以直接访问指向对象，指针需要解引用才是访问指向对象。 </span></strong> 
</div> 
<div> 
 <strong><span style="color:#1456f0;">• </span><span style="color:#1f2329;">sizeof中含义不同，引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占4个字节，64位下是8byte) </span></strong> 
</div> 
<div> 
 <strong><span style="color:#1456f0;">• </span><span style="color:#1f2329;">指针很容易出现空指针和野指针的问题，引用很少出现，引用使用起来相对更安全一些。 </span></strong> 
</div> 
<div> 
 <img alt="" height="401" src="https://images2.imgbox.com/f5/66/V3dnzkp4_o.png" width="1200"> 
</div> 
<p>野引用的案例： </p> 
<p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/59/0c/BabV9r0a_o.png" width="269"></p> 
<p><strong>从底层汇编的角度看，引用也是用指针实现的。 </strong></p> 
<p></p> 
<h2><span style="color:#0d0016;">7.</span><span style="color:#1456f0;"> </span><span style="color:#1f2329;">inline </span></h2> 
<div> 
 <span style="color:#1456f0;">•</span> 
 <span style="color:#0d0016;"> 用</span> 
 <span style="color:#1f2329;">inline修饰的函数叫做内联函数（通常放到返回值的前面），编译时C++编译器会在调用的地方展开内联函数，这样<strong>调用内联函数就不需要建立栈帧了，就可以提高效率。</strong> </span> 
</div> 
<div> 
 <p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/2c/08/1SmxhIxf_o.png" width="374"></p> inline在这里的作用就是没有宏函数的坑，也不用建立栈帧，提效。 
</div> 
<div> 
 <span style="color:#1456f0;">• </span> 
 <span style="color:#1f2329;">inline对于编译器而言只是⼀个建议，也就是说，加了inline编译器也可以选择在调用的地方不展 </span> 
</div> 
<div> 
 <span style="color:#1f2329;">开，不同编译器关于inline什么情况展开各不相同，因为C++标准没有规定这个。<strong>inline适用于频繁 </strong></span> 
</div> 
<div> 
 <strong><span style="color:#1f2329;">调用的短小函数，对于递归函数，代码相对多⼀些的函数，加上inline也会被编译器忽略。</span></strong> 
</div> 
<div> 
 <div> 
  <span style="color:#1456f0;">• </span> 
  <span style="color:#1f2329;">C语言实现宏函数也会在预处理时替换展开，但是宏函数实现很复杂很容易出错的，且不方便调 </span> 
 </div> 
 <div> 
  <span style="color:#1f2329;">试，C++设计了inline目的就是替代C的宏函数。 </span> 
 </div> 
 <div> 
  <span style="color:#1456f0;">• </span> 
  <span style="color:#1f2329;">vs编译器 debug版本下面默认是不展开inline的（release版本下默认是展开inline的），这样方便调试，debug版本想展开需要设置一下以下两个地方。 </span> 
 </div> 
 <div> 
  <img alt="" height="1000" src="https://images2.imgbox.com/d6/aa/Pcpaer3B_o.png" width="1200"> 
 </div> 
 <div> 
  <p class="img-center"><img alt="" height="268" src="https://images2.imgbox.com/11/52/YplIk5ZS_o.png" width="505"></p> 
  <p>可执行程序是一个文件，它会以一个进程的角度来进行运行（可执行程序会生成一个进程），进程才会给它分配内存，进程会把可执行程序的那个指令加载到内存的里面。</p> 
  <p>10000*100是指10000行指令*100行Add的指令总和的指令，10000+100是指10000行指令+100行Add的指令总和的指令。内联展开会导致一个问题：代码膨胀，代码膨胀会导致可执行程序变大，可执行程序变大，加载到进程也会变大，加载到内存导致内存变大。（可执行程序就是安装包）</p> 
  <p class="img-center"><img alt="" height="180" src="https://images2.imgbox.com/bf/4e/h4RVcBpT_o.png" width="440"></p> 
 </div> 
 <div> 
  <span style="color:#1456f0;">• </span> 
  <span style="color:#1f2329;">inline不建议声明和定义分离到两个文件，分离（分离会找这个链接的地址）会导致链接错误。因为inline被展开，就没有函数地址，链接时会出现报错。链接就是声明的函数要找它的地址，去其它文件找它的地址。</span> 
 </div> 
 <div> 
  <blockquote> 
   <div> 
    <span style="color:#a0a1a7;"><em>// F.h </em></span> 
   </div> 
   <div> 
    <span style="color:#4078f2;">#</span> 
    <span style="color:#a626a4;">include </span> 
    <span style="color:#50a14f;">&lt;iostream&gt; </span> 
   </div> 
   <div> 
    <span style="color:#a626a4;">using namespace </span> 
    <span style="color:#2b2f36;">std; </span> 
   </div> 
   <div> 
    <span style="color:#a626a4;">inline </span> 
    <span style="color:#986801;">void </span> 
    <span style="color:#4078f2;">f</span> 
    <span style="color:#2b2f36;">(</span> 
    <span style="color:#986801;">int </span> 
    <span style="color:#2b2f36;">i); </span> 
   </div> 
   <div> 
    <span style="color:#a0a1a7;"><em>// F.cpp </em></span> 
   </div> 
   <div> 
    <span style="color:#4078f2;">#</span> 
    <span style="color:#a626a4;">include </span> 
    <span style="color:#50a14f;">"F.h" </span> 
   </div> 
   <div> 
    <span style="color:#986801;">void </span> 
    <span style="color:#4078f2;">f</span> 
    <span style="color:#2b2f36;">(</span> 
    <span style="color:#986801;">int </span> 
    <span style="color:#2b2f36;">i) </span> 
   </div> 
   <div> 
    <span style="color:#2b2f36;">{ </span> 
   </div> 
   <div> 
    <span style="color:#2b2f36;">cout &lt;&lt; i &lt;&lt; endl; </span> 
   </div> 
   <div> 
    <span style="color:#2b2f36;">} </span> 
   </div> 
   <div> 
    <span style="color:#a0a1a7;"><em>// text.cpp </em></span> 
   </div> 
   <div> 
    <span style="color:#4078f2;">#</span> 
    <span style="color:#a626a4;">include </span> 
    <span style="color:#50a14f;">"F.h" </span> 
   </div> 
   <div> 
    <span style="color:#986801;">int </span> 
    <span style="color:#4078f2;">main</span> 
    <span style="color:#2b2f36;">() </span> 
   </div> 
   <div> 
    <p><span style="color:#2b2f36;">{ </span></p> 
    <div> 
     <span style="color:#a0a1a7;"><em>// </em></span> 
     <span style="color:#a0a1a7;"><em>链接错误：⽆法解析的外部符号 </em></span> 
     <span style="color:#a0a1a7;"><em>"void __cdecl f(int)" (?f@@YAXH@Z) </em></span> 
    </div> 
    <div> 
     <span style="color:#c18401;">f</span> 
     <span style="color:#2b2f36;">(</span> 
     <span style="color:#986801;">10</span> 
     <span style="color:#2b2f36;">); </span> 
    </div> 
    <div> 
     <span style="color:#a626a4;">return </span> 
     <span style="color:#986801;">0</span> 
     <span style="color:#2b2f36;">; </span> 
    </div> 
    <div> 
     <span style="color:#2b2f36;">} </span> 
    </div> 
    <div> 
     <span style="color:#2b2f36;">//那要怎么做呢？</span> 
    </div> 
    <div> 
     <div> 
      <div> 
       <span style="color:#a0a1a7;"><em>把// F.cpp这个文件中的f（int i）给注释掉</em></span> 
      </div> 
      <div> 
       <span style="color:#4078f2;">#</span> 
       <span style="color:#a626a4;">include </span> 
       <span style="color:#50a14f;">"F.h" </span> 
      </div> 
      <div> 
       <span style="color:#986801;">//void </span> 
       <span style="color:#4078f2;">f</span> 
       <span style="color:#2b2f36;">(</span> 
       <span style="color:#986801;">int </span> 
       <span style="color:#2b2f36;">i) </span> 
      </div> 
      <div> 
       <span style="color:#2b2f36;">//{<!-- --></span> 
      </div> 
      <div> 
       <span style="color:#2b2f36;">//cout &lt;&lt; i &lt;&lt; endl; </span> 
      </div> 
      <div> 
       <span style="color:#2b2f36;">//}</span> 
      </div> 
      <div> 
       <span style="color:#a0a1a7;"><em>在// F.h中定义</em></span> 
      </div> 
      <div> 
       <div> 
        <span style="color:#986801;">inline void </span> 
        <span style="color:#4078f2;">f</span> 
        <span style="color:#2b2f36;">(</span> 
        <span style="color:#986801;">int </span> 
        <span style="color:#2b2f36;">i) </span> 
       </div> 
       <div> 
        <span style="color:#2b2f36;">{ </span> 
       </div> 
       <div> 
        <span style="color:#2b2f36;">cout &lt;&lt; i &lt;&lt; endl; </span> 
       </div> 
       <div> 
        <span style="color:#2b2f36;">}</span> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
  </blockquote> 
 </div> 
</div> 
<blockquote> 
 <p> <span style="color:#a0a1a7;"><em>// </em></span><span style="color:#a0a1a7;"><em>实现⼀个</em></span><span style="color:#a0a1a7;"><em>Add</em></span><span style="color:#a0a1a7;"><em>宏函数的常见问题 </em></span></p> 
 <div> 
  <span style="color:#a0a1a7;"><em>//#define Add(int a, int b) return a + b; </em></span> 
 </div> 
 <div> 
  <span style="color:#a0a1a7;"><em>//#define Add(a, b) a + b; </em></span> 
 </div> 
 <div> 
  <span style="color:#a0a1a7;"><em>//#define Add(a, b) (a + b) </em></span> 
 </div> 
 <div> 
  <div> 
   <span style="color:#a0a1a7;"><em>// </em></span> 
   <span style="color:#a0a1a7;"><em>正确的宏实现（宏本质是一种替换）</em></span> 
  </div> 
  <div> 
   <span style="color:#a0a1a7;"><em>//宏函数坑很多，但是由于替换机制，调用函数时不用建立函数栈帧，能做到提效的作用。</em></span> 
  </div> 
  <div> 
   <span style="color:#4078f2;">#</span> 
   <span style="color:#a626a4;">define </span> 
   <span style="color:#4078f2;">Add(a, b) ((a) + (b)) </span> 
  </div> 
  <div> 
   <span style="color:#a0a1a7;"><em>// </em></span> 
   <span style="color:#a0a1a7;"><em>为什么不能加分号</em></span> 
   <span style="color:#a0a1a7;"><em>? </em></span> 
  </div> 
  <div>
    int main() 
  </div> 
  <div>
    { 
  </div> 
  <div>
         int ret = Add(1,2);//这里是将a替换成1，b替换成2；//int ret = Add(1,2）；； 
  </div> 
  <div>
         //在这种场景下不会有问题 
  </div> 
  <div>
         cout  &lt;&lt;  Add(1,2)  &lt;&lt;  endl; 
  </div> 
  <div>
         //如果加分号在这种情况下就会报错,还有下面这种 
  </div> 
  <div>
         if(Add(1,2)) 
  </div> 
  <div>
         { 
  </div> 
  <div>
             //... 
  </div> 
  <div>
         } 
  </div> 
  <div>
         cout  &lt;&lt;  ret  &lt;&lt;  endl; 
  </div> 
  <div>
    } 
  </div> 
  <div> 
   <span style="color:#a0a1a7;"><em>// </em></span> 
   <span style="color:#a0a1a7;"><em>为什么要加外⾯的括号</em></span> 
   <span style="color:#a0a1a7;"><em>? </em></span> 
  </div> 
  <div> 
   <span style="color:#a0a1a7;"><em>//有下面这种情况</em></span> 
  </div> 
  <div> 
   <div>
     int main() 
   </div> 
   <div>
     { 
   </div> 
   <div>
          int ret = Add(1,2);//这里是将a替换成1，b替换成2；//int ret = Add(1,2）；； 
   </div> 
   <div>
           
   </div> 
   <div>
          cout  &lt;&lt;  Add(1,2)*3  &lt;&lt;  endl; 
   </div> 
   <div>
          //cout  &lt;&lt;  (1)  +  (2) * 3  &lt;&lt;  endl; 
   </div> 
   <div>
     } 
   </div> 
  </div> 
  <div> 
   <span style="color:#a0a1a7;"><em>// </em></span> 
   <span style="color:#a0a1a7;"><em>为什么要加里面的括号</em></span> 
   <span style="color:#a0a1a7;"><em>? </em></span> 
  </div> 
  <div>
    int main() 
  </div> 
  <div>
    { 
  </div> 
  <div>
        int x =1,y = 2； 
  </div> 
  <div>
        Add(x &amp; y ,x | y);  // -&gt;  (x &amp; y + x | y) 
  </div> 
  <div>
    } 
  </div> 
 </div> 
</blockquote> 
<h2>8. <span style="color:#1f2329;">nullptr </span></h2> 
<div> 
 <span style="color:#1f2329;">（C++里面空指针都用NULL）NULL实际是⼀个宏，在传统的C头文件(stddef.h)中，可以看到如下代码： </span> 
</div> 
<div> 
 <blockquote> 
  <div>
    #ifndef NULL 
   <br>         #ifdef __cplusplus 
   <br>                 #define NULL 0//C++ 
   <br>         #else 
   <br>                 #define NULL ((void *)0)//C语言 
   <br>         #endif 
   <br> #endif 
  </div> 
 </blockquote> 
</div> 
<div> 
 <span style="color:#1456f0;">• </span> 
 <span style="color:#1f2329;">C++中NULL可能被定义为字面常量0，或者C中被定义为无类型指针(void*)的常量。不论采取何种定义，在使用空值的指针时，都不可避免的会遇到⼀些麻烦，本想通过f(NULL)调用指针版本的 </span> 
</div> 
<div> 
 <span style="color:#1f2329;">f(int*)函数，但是由于NULL被定义成0，调用了f(int x)，因此与程序的初衷相悖。f((void*)NULL); </span> 
</div> 
<div> 
 <span style="color:#1f2329;">调用会报错。</span> 
</div> 
<div> 
 <span style="color:#1f2329;">下面的代码我们普遍认为f(0)调用f(int x),f(NULL)调用f(int *ptr),但实际调用的都是f(int x)。</span> 
 <img alt="" height="450" src="https://images2.imgbox.com/d7/57/PI6sZsyl_o.png" width="989"> 
</div> 
<p><img alt="" height="500" src="https://images2.imgbox.com/6e/c0/QPA85zvJ_o.png" width="902"><span style="color:#1456f0;">• </span><span style="color:#1f2329;">C++11中引入nullptr，nullptr是⼀个特殊的关键字，nullptr是⼀种特殊类型的字面量，它可以转换 成任意其他类型的指针类型。使用nullptr定义空指针可以避免类型转换的问题，因为nullptr只能被 隐式地转换为指针类型，而不能被转换为整数类型。</span></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2c6149f59e0cc84d17bd2a087b069181/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">探索智谱AI的视频生成神器：CogVideoX完全指南</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/23546629ddafcd64268bce58579634c1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">人工智能深度学习系列—深入解析：均方误差损失（MSE Loss）在深度学习中的应用与实践</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>