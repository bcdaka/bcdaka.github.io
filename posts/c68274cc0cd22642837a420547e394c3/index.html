<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>axios设置 responseType为 “stream“流式获取后端数据 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/c68274cc0cd22642837a420547e394c3/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="axios设置 responseType为 “stream“流式获取后端数据">
  <meta property="og:description" content="使用前景： 工作过程中遇到了后端接口响应过慢，前端界面一致loading的情况，这个时候可以尝试采用将Axios的responseType参数被设置为&#39;stream&#39;类型实现。
stream介绍： stream类型意味着你希望服务器响应的数据以Node.js流（stream）的形式返回，而不是作为JSON、文本或其他类型的响应体。使用它的好处是可以避免一次性加载整个响应体，避免页面一直无响应，同时stream在处理大文件、实时数据传输或需要直接操作数据流的场景中非常有用。
使用： axios&#43;stream const axios = require(&#39;axios&#39;); axios({ method: &#39;post&#39;, url: &#39;YOUR_STREAM_ENDPOINT_URL&#39;, // 替换为你的流式接口URL responseType: &#39;stream&#39;, data: {} }) .then(response =&gt; { // 这里的response.data是一个Node.js的流（Stream）对象 response.data.on(&#34;data&#34;, (chunk) =&gt; { console.log(chunk, &#34;data&#34;); // 处理每个数据块，例如写入文件或进行其他操作 }); response.data.on(&#34;end&#34;, (end) =&gt; { console.log(end, &#34;end&#34;); // 数据接收完毕的处理逻辑 }); response.data.on(&#34;error&#34;, (error) =&gt; { // 流处理过程中发生错误的处理逻辑 }); }); 这个方法和网上搜索出来的大多数流式接口方法一致，但是在axios中设置responseType为 &#34;stream&#34;后，控制台会警告：
The provided value &#39;stream&#39; is not a valid enum value of type XMLHttpRequestResponseType.
因为axios基于XMLHttpRequest原生，而XMLHttpRequest原生不直接支持responseType: &#39;stream&#39;这个值。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-06T09:43:49+08:00">
    <meta property="article:modified_time" content="2024-06-06T09:43:49+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">axios设置 responseType为 “stream“流式获取后端数据</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>使用前景：</h3> 
<p>工作过程中遇到了后端接口响应过慢，前端界面一致loading的情况，这个时候可以尝试采用将Axios的<code>responseType</code>参数被设置为<code>'stream'</code>类型实现。</p> 
<h3><code>stream</code>介绍：</h3> 
<p>stream类型意味着你希望服务器响应的数据以Node.js流（stream）的形式返回，而不是作为JSON、文本或其他类型的响应体。使用它的好处是可以避免一次性加载整个响应体，避免页面一直无响应，同时stream在处理大文件、实时数据传输或需要直接操作数据流的场景中非常有用。</p> 
<h3>使用：</h3> 
<h4>axios+stream</h4> 
<pre><code class="language-javascript">const axios = require('axios');  
  
axios({  
  method: 'post',  
  url: 'YOUR_STREAM_ENDPOINT_URL', // 替换为你的流式接口URL  
  responseType: 'stream',
  data: {}
})  
.then(response =&gt; {  
  // 这里的response.data是一个Node.js的流（Stream）对象  
   response.data.on("data", (chunk) =&gt; {
      console.log(chunk, "data");
      // 处理每个数据块，例如写入文件或进行其他操作
    });

    response.data.on("end", (end) =&gt; {
      console.log(end, "end");
      // 数据接收完毕的处理逻辑
    });

    response.data.on("error", (error) =&gt; {
      // 流处理过程中发生错误的处理逻辑
    });  
});</code></pre> 
<p>这个方法和网上搜索出来的大多数流式接口方法一致，但是在axios中设置responseType为 "stream"后，控制台会警告：</p> 
<p><span style="background-color:#ffd900;">The provided value 'stream' is not a valid enum value of type XMLHttpRequestResponseType.</span></p> 
<p>因为axios基于<code>XMLHttpRequest</code>原生，而<code>XMLHttpRequest</code>原生不直接支持<code>responseType: '<strong>stream</strong>'</code>这个值。</p> 
<h4>fetch+stream</h4> 
<p>曲线救国的方法可以使用fetch来发送请求：</p> 
<pre><code class="language-javascript">try{
    // 发送请求
    let response = await fetch("",
      {
        method: "post",
        responseType: "stream",
        headers: {
          Authorization: "Bearer " + 'token',
          "Content-Type": "application/json",
        },
        body: {},
      }
    );
    // ok字段判断是否成功获取到数据流
    if (!response.ok) {
      throw new Error("Network response was not ok");
    }
    // 用来获取一个可读的流的读取器（Reader）以流的方式处理响应体数据
    const reader = response.body.getReader();
    // 将流中的字节数据解码为文本字符串
    const textDecoder = new TextDecoder();
    let result = true;
    let sqlValue = ''
    while (result) {
      // done表示流是否已经完成读取  value包含读取到的数据块
      const { done, value } = await reader.read();
      if (done) {
        result = false;
        break;
      }
      // 拿到的value就是后端分段返回的数据，大多是以data:开头的字符串
      // 需要通过decode方法处理数据块，例如转换为文本或进行其他操作
      const chunkText = textDecoder
        .decode(value)
        .split("\n")
        .forEach((val) =&gt; {
          if (!val) return;
          try {
            let text = val.data.result;
            console.log(val, text, "输出分段返回的数据");
            sqlValue += text;
          } catch (err) {}
        });
    }
    console.log(sqlValue,'输出所有返回数据')
} catch(err) {}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ec105e141341ec54f3a26a66faa89ab6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">学习python你必须弄懂的 Python、Pycharm、Anaconda 三者之间的关系</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d9c10a3bbea552ed63ddca404d491bcc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python搭建自己的VPN</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>