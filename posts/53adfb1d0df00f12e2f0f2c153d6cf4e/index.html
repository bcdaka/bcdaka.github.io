<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>反向迭代器：reverse_iterator的实现 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/53adfb1d0df00f12e2f0f2c153d6cf4e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="反向迭代器：reverse_iterator的实现">
  <meta property="og:description" content="目录
前言
特点
注意事项
实现
构造函数
功能函数
在list与vector中的使用
vector
list
前言 反向迭代器是一种在序列容器的末尾开始，并向前移动至序列开始处的迭代器。在C&#43;&#43;中，反向迭代器由标准库中的容器类提供，比如vector、list、deque等。它们允许程序员以逆序遍历容器中的元素。
以下是反向迭代器的一些特点：
特点 反向遍历：反向迭代器从序列的最后一个元素开始，逐步移动到第一个元素。操作符重载：C&#43;&#43;中的反向迭代器重载了递增（&#43;&#43;）和递减（--）操作符。递增操作使迭代器向序列的开始方向移动，而递减操作使其向序列的结束方向移动。类型：反向迭代器的类型通常由容器类型加上reverse_iterator后缀表示，例如vector&lt;int&gt;::reverse_iterator。 注意事项 反向迭代器不支持所有的普通迭代器的操作，例如算术操作（加、减）。使用反向迭代器时，递增操作实际上是向序列的开始方向移动。在C&#43;&#43;标准库中，并不是所有容器都支持反向迭代器。只有那些支持双向迭代器（BidirectionalIterator）或随机访问迭代器（RandomAccessIterator）的容器才提供反向迭代器。这是因为反向迭代器需要能够向前和向后遍历容器，而这两种迭代器都支持这些操作。 需要逆序访问容器元素时，它们可以简化代码并提高效率
反向迭代器有const版本和非const版本，所以我们需要实现两个版本。
实现 反向迭代器由于与正向迭代器的行为相似，因此借鉴适配器的思想，用正向迭代器实现反向迭代器
同时我们增加两个模板参数Ref Ptr，作为const T&amp;和Const T*的区分
template&lt;class Iterator, class Ref, class Ptr&gt; class ReverseIterator 成员变量就是一个被适配的正向迭代器
private:
Iterator _it;
构造函数 ReverseIterator(Iterator it) :_it(it) {} 用传入的模板迭代器去初始化成员
功能函数 &#43;&#43; --
Self&amp; operator&#43;&#43;() { --_it; return *this; } Self&amp; operator--() { &#43;&#43;_it; return *this; } * -&gt;两种解引用
为了实现对称，解引用时，解引用的是当前位置的下一个数据
Ref operator*()	//内部去调用普通迭代器的解引用 { Iterator cur = _it; return *(--cur);	//返回数据的引用，不能--_it，防止迭代器错位 } //-&gt;也是一种解引用 Ptr operator-&gt;()	//返回的其实是一个指针 { return &amp;(operator*()); } == ！=">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-31T22:33:24+08:00">
    <meta property="article:modified_time" content="2024-08-31T22:33:24+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">反向迭代器：reverse_iterator的实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="%E7%89%B9%E7%82%B9-toc" style="margin-left:80px;"><a href="#%E7%89%B9%E7%82%B9" rel="nofollow">特点</a></p> 
<p id="%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-toc" style="margin-left:80px;"><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" rel="nofollow">注意事项</a></p> 
<p id="%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E5%AE%9E%E7%8E%B0" rel="nofollow">实现</a></p> 
<p id="%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" rel="nofollow">构造函数</a></p> 
<p id="%E5%8A%9F%E8%83%BD%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E5%8A%9F%E8%83%BD%E5%87%BD%E6%95%B0" rel="nofollow">功能函数</a></p> 
<p id="%E5%9C%A8list%E4%B8%8Evector%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#%E5%9C%A8list%E4%B8%8Evector%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">在list与vector中的使用</a></p> 
<p id="vector-toc" style="margin-left:40px;"><a href="#vector" rel="nofollow">vector</a></p> 
<p id="list-toc" style="margin-left:40px;"><a href="#list" rel="nofollow">list</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%89%8D%E8%A8%80">前言</h2> 
<p>反向迭代器是一种在序列容器的末尾开始，并向前移动至序列开始处的迭代器。在C++中，反向迭代器由标准库中的容器类提供，比如<code>vector</code>、<code>list</code>、<code>deque</code>等。它们允许程序员以逆序遍历容器中的元素。</p> 
<p>以下是反向迭代器的一些特点：</p> 
<h4 id="%E7%89%B9%E7%82%B9">特点</h4> 
<ol><li><strong>反向遍历</strong>：反向迭代器从序列的最后一个元素开始，逐步移动到第一个元素。</li><li><strong>操作符重载</strong>：C++中的反向迭代器重载了<strong>递增（<code>++</code>）和递减（<code>--</code>）</strong>操作符。递增操作使迭代器向序列的开始方向移动，而递减操作使其向序列的结束方向移动。</li><li><strong>类型</strong>：反向迭代器的类型通常由容器类型加上<code>reverse_iterator</code>后缀表示，例如<code>vector&lt;int&gt;::reverse_iterator</code>。</li></ol> 
<h4 id="%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</h4> 
<ul><li>反向迭代器<strong>不支持所有的普通迭代器的操</strong>作，例如算术操作（<strong>加、减</strong>）。</li><li>使用反向迭代器时，递增操作实际上是向序列的开始方向移动。</li><li>在C++标准库中，并不是所有容器都支持反向迭代器。只有那些支持<strong>双向迭代器（<code>BidirectionalIterator</code>）或随机访问迭代器（<code>RandomAccessIterator</code>）</strong>的容器才提供反向迭代器。这是因为反向迭代器需要能够<strong>向前和向后遍历容器</strong>，而这两种迭代器都支持这些操作。</li></ul> 
<p>需要逆序访问容器元素时，它们可以简化代码并提高效率</p> 
<p>反向迭代器有const版本和非const版本，所以我们需要实现两个版本。</p> 
<h2 id="%E5%AE%9E%E7%8E%B0">实现</h2> 
<p>反向迭代器由于与正向迭代器的行为相似，因此借鉴适配器的思想，用正向迭代器实现反向迭代器</p> 
<p>同时我们增加两个模板参数Ref Ptr，作为const T&amp;和Const T*的区分</p> 
<pre><code class="language-cpp">
template&lt;class Iterator, class Ref, class Ptr&gt;
class ReverseIterator
</code></pre> 
<p>成员变量就是一个被适配的正向迭代器</p> 
<p>private:<br>     Iterator _it;</p> 
<h3 id="%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">构造函数</h3> 
<pre><code class="language-cpp">	ReverseIterator(Iterator it)
		:_it(it)
	{}
</code></pre> 
<p>用传入的模板迭代器去初始化成员</p> 
<h3 id="%E5%8A%9F%E8%83%BD%E5%87%BD%E6%95%B0" style="background-color:transparent;">功能函数</h3> 
<p></p> 
<p><strong>++ --</strong></p> 
<pre><code class="language-cpp">
	Self&amp; operator++()
	{
		--_it;
		return *this;
	}
	
	Self&amp; operator--()
	{
		++_it;
		return *this;
	}</code></pre> 
<p><strong>* -&gt;两种解引用</strong></p> 
<p></p> 
<p><strong>为了实现对称，解引用时，解引用的是当前位置的下一个数据</strong></p> 
<pre><code class="language-cpp">
	Ref operator*()	//内部去调用普通迭代器的解引用
	{
		Iterator cur = _it;
		return *(--cur);	//返回数据的引用，不能--_it，防止迭代器错位
	}

		//-&gt;也是一种解引用
	Ptr operator-&gt;()	//返回的其实是一个指针
	{
		return &amp;(operator*());
	}</code></pre> 
<p></p> 
<p><strong>==    ！=</strong></p> 
<p><strong>迭代器的比较，看看成员参数是不是一个</strong></p> 
<pre><code class="language-cpp">
	bool operator!=(const Self&amp; s)
	{
		return _it != s._it;
	}

	bool operator==(const Self&amp; s)
	{
		return _it == s._it;
	}
</code></pre> 
<p></p> 
<h2 id="%E5%9C%A8list%E4%B8%8Evector%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8">在list与vector中的使用</h2> 
<p></p> 
<h3 id="vector">vector</h3> 
<p>首先我们需要展开头文件</p> 
<p>#include "reverse_iterator.h"    //反向迭代器头文件在此展开<br>  </p> 
<p>然后利用typedef将迭代器重命名</p> 
<pre><code class="language-cpp">typedef T* iterator;
typedef const T* const_iterator;
typedef Reverse_Iterator&lt;iterator, T&amp;, T*&gt; reverse_iterator;
typedef Reverse_Iterator&lt;const_iterator, const T&amp;, const T*&gt; const_reverse_iterator;</code></pre> 
<p></p> 
<p>rbegin与rend</p> 
<pre><code class="language-cpp">reverse_iterator rbegin()
{
	return reverse_iterator(end());		
}

reverse_iterator rend()
{
	return reverse_iterator(begin());
}

const_reverse_iterator rbegin() const
{
	return const_reverse_iterator(end());
}

const_reverse_iterator rend() const
{
	return const_reverse_iterator(begin());
}</code></pre> 
<p>其中const反向迭代器将调用const成员（end（）、begin（））</p> 
<p></p> 
<p>（（（（</p> 
<p>题外话：</p> 
<p></p> 
<p>返回时，采用的是传值返回</p> 
<p>自定义类型的传值返回通常是通过拷贝构造函数来实现的。当一个对象作为函数的返回值时，如果采用值返回的方式，函数内部会创建一个临时对象，这个临时对象是通过拷贝构造函数来初始化的，它是对返回对象的一个副本。这个副本具有常性（体现在引用时）</p> 
<p><img alt="" height="174" src="https://images2.imgbox.com/0f/58/3Re3OTDk_o.png" width="631"></p> 
<p>这里一个特例，这是一个匿名对象，具有常性，但是却可以调用非const成员函数。</p> 
<p></p> 
<p>示例：</p> 
<pre><code class="language-cpp">class MyClass {
public:
    MyClass() {
        // 构造函数
    }

    MyClass(const MyClass&amp; other) {
        // 拷贝构造函数
    }

    // 其他成员函数和成员变量...
};

MyClass createObject() {
    MyClass obj;
    // 对obj进行一些操作
    return obj; // 这里会调用拷贝构造函数来构造返回值
}

int main() {
    MyClass result = createObject(); // 接收返回值，同样会调用拷贝构造函数
    return 0;
}
</code></pre> 
<p>在上述代码中，当<code>createObject</code>函数返回<code>obj</code>时，会调用<code>MyClass</code>的拷贝构造函数来构造一个临时对象，这个临时对象随后会被用来初始化<code>main</code>函数中的<code>result</code>对象。因此，在这个过程中至少会发生两次拷贝构造：一次是在函数返回时构造临时对象，另一次是在接收返回值时。</p> 
<p>需要注意的是，现代编译器通常会对此类操作进行优化，比如返回值优化（NRVO，Named Return Value Optimization）或者拷贝省略（copy elision），从而避免不必要的拷贝，以提高性能。在C++11及以后的版本中，这种优化是被标准所允许的，甚至在某些情况下是强制的。</p> 
<p></p> 
<p>示例2：</p> 
<p>iterator begin() { return iterator(_head-&gt;_next);  }</p> 
<p>产生临时对象后：</p> 
<p>这个临时对象会在表达式结束时被销毁，但是因为这是在一个返回语句中，所以返回的对象会被用来初始化函数调用的结果。这样，当函数调用者接收这个返回值时，他们实际上是在接收<strong>一个复制构造的 <code>iterator</code> 临时对象</strong>，而不是原始的返回对象。接收时，会<strong>使用拷贝构造等手段</strong>完成接收。</p> 
<p></p> 
<p></p> 
<p>））））</p> 
<p></p> 
<h3 id="list">list</h3> 
<p>同样得展开头文件</p> 
<p>#include "reverse_iterator.h"    //对应头文件内容在此展开</p> 
<pre><code class="language-cpp">typedef __list_iterator&lt;T, T&amp;, T*&gt; iterator;
typedef __list_iterator&lt;T, const T&amp;, const T*&gt; const_iterator;
typedef Reverse_Iterator&lt;iterator, T&amp;, T*&gt; reverse_iterator;	//把我的迭代器传给这个全局的类
typedef Reverse_Iterator&lt;const_iterator, const T&amp;, const T*&gt; const_reverse_iterator;</code></pre> 
<p>Reverse_Iterator这个模板类已经在此文件中展开，因此在list类中可以直接使用这个类模板，并借助自身的成员去实例化这个模板类。 </p> 
<pre><code class="language-cpp">
		reverse_iterator rbegin() 
		{						//强调对称
			return reverse_iterator(end());		//借助end（）迭代器构造反向迭代器
		}

		reverse_iterator rend()
		{
			return reverse_iterator(begin());
		}

		const_reverse_iterator rbegin() const	//const迭代器
		{
			return const_reverse_iterator(end());	//调用的是const函数end()
		}

		const_reverse_iterator rend() const
		{
			return const_reverse_iterator(begin());	
		}
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bc1cdcc1ecb61ee38d71336a995887c3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">力扣SQL仅数据库(196~569)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0090a66ada6f6a8e2936055540b879e5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Nginx: 使用KeepAlived配置实现虚IP在多服务器节点漂移及Nginx高可用原理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>