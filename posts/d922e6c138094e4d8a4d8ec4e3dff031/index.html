<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】哈希 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/d922e6c138094e4d8a4d8ec4e3dff031/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】哈希">
  <meta property="og:description" content="文章目录 1. 哈希概念2. 哈希冲突3. 哈希函数4. 哈希冲突解决4.1 闭散列4.2 开散列 unordered 系列的关联式容器之所以效率比较高，是因为其底层使用了哈希结构。
1. 哈希概念 顺序结构以及平衡树中，元素关键码与其存储位置之间没有对应的关系，因此在查找一个元素时，必须要经过关键码的多次比较。顺序查找时间复杂度为 O(N)，平衡树中为树的高度，即 O( l o g 2 N log_2 N log2​N)，搜索的效率取决于搜索过程中元素的比较次数。
理想的搜索方法：可以不经过任何比较，一次直接从表中得到要搜索的元素。
如果构造一种存储结构，通过某种函数（hashFunc）使元素的存储位置与它的关键码之间能够建立一一映射的关系，那么在查找时通过该函数可以很快找到该元素。
当向该结构中：
插入元素
根据待插入元素的关键码，以此函数计算出该元素的存储位置，并按此位置进行存放；
搜索元素
对元素的关键码进行同样的计算，把求得的函数值当作元素的存储位置，在结构中按此位置取元素比较，若关键码相等，则搜索成功。
该方式即为哈希（散列）方法，哈希方法中使用的转换函数称为哈希（散列）函数，构造出来的结构称为哈希表（Hash Table）（或者散列表）。
例如：数据集合 { 1, 7, 6, 4, 5, 9 }；
哈希函数设置为：hash(key) = key % capacity; capacity 为存储元素底层空间总的大小。
用该方法进行搜索不必进行多次关键码的比较，因此搜索的速度比较快。
问题：按照上述哈希方式，向集合中插入元素 44，会出现什么问题？
2. 哈希冲突 对于两个数据元素的关键字 k i k_i ki​ 和 k j k_j kj​（i != j），有 k i k_i ki​ !">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-11T21:06:59+08:00">
    <meta property="article:modified_time" content="2024-04-11T21:06:59+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】哈希</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1__5" rel="nofollow">1. 哈希概念</a></li><li><a href="#2__33" rel="nofollow">2. 哈希冲突</a></li><li><a href="#3__40" rel="nofollow">3. 哈希函数</a></li><li><a href="#4__87" rel="nofollow">4. 哈希冲突解决</a></li><li><ul><li><a href="#41__90" rel="nofollow">4.1 闭散列</a></li><li><a href="#42__251" rel="nofollow">4.2 开散列</a></li></ul> 
 </li></ul> 
</div> 
<br> 
<img src="https://images2.imgbox.com/9f/14/kzRKguB0_o.gif" alt="在这里插入图片描述"> 
<p></p> 
<p>unordered 系列的关联式容器之所以效率比较高，是因为其底层使用了哈希结构。</p> 
<h2><a id="1__5"></a>1. 哈希概念</h2> 
<p><strong>顺序结构以及平衡树</strong>中，元素关键码与其存储位置之间没有对应的关系，因此在<strong>查找一个元素时，必须要经过关键码的多次比较。顺序查找时间复杂度为 O(N)，平衡树中为树的高度，即 O(<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          l 
         
        
          o 
         
         
         
           g 
          
         
           2 
          
         
        
          N 
         
        
       
         log_2 N 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0197em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span></span></span></span></span>)</strong>，搜索的效率取决于搜索过程中元素的比较次数。</p> 
<p>理想的搜索方法：<strong>可以不经过任何比较，一次直接从表中得到要搜索的元素</strong>。</p> 
<p><strong>如果构造一种存储结构，通过某种函数（hashFunc）使元素的存储位置与它的关键码之间能够建立一一映射的关系，那么在查找时通过该函数可以很快找到该元素</strong>。</p> 
<p>当向该结构中：</p> 
<ul><li> <p><strong>插入元素</strong></p> <p>根据待插入元素的关键码，以此函数计算出该元素的存储位置，并按此位置进行存放；</p> </li><li> <p><strong>搜索元素</strong></p> <p>对元素的关键码进行同样的计算，把求得的函数值当作元素的存储位置，在结构中按此位置取元素比较，若关键码相等，则搜索成功。</p> </li></ul> 
<p>该方式即为哈希（散列）方法，<strong>哈希方法中使用的转换函数称为哈希（散列）函数，构造出来的结构称为哈希表（Hash Table）（或者散列表）</strong>。</p> 
<p>例如：数据集合 { 1, 7, 6, 4, 5, 9 }；</p> 
<p>哈希函数设置为：<code>hash(key) = key % capacity;</code> capacity 为存储元素底层空间总的大小。</p> 
<p><img src="https://images2.imgbox.com/20/15/vf4l2zwd_o.png" alt="在这里插入图片描述"></p> 
<p><strong>用该方法进行搜索不必进行多次关键码的比较，因此搜索的速度比较快</strong>。</p> 
<p>问题：按照上述哈希方式，向集合中插入元素 44，会出现什么问题？</p> 
<h2><a id="2__33"></a>2. 哈希冲突</h2> 
<p>对于两个数据元素的关键字 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          k 
         
        
          i 
         
        
       
      
        k_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0315em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 和 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          k 
         
        
          j 
         
        
       
      
        k_j 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.9805em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0315em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span>（i != j），有 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          k 
         
        
          i 
         
        
       
      
        k_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0315em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> != <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          k 
         
        
          j 
         
        
       
      
        k_j 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.9805em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0315em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，但有：Hash(<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          k 
         
        
          i 
         
        
       
      
        k_i 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0315em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>) == Hash(<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          k 
         
        
          j 
         
        
       
      
        k_j 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.9805em; vertical-align: -0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0315em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0315em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0572em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2861em;"><span class=""></span></span></span></span></span></span></span></span></span></span>)，即：<strong>不同关键字通过相同哈希函数计算出相同的哈希地址，这种现象称为哈希冲突或哈希碰撞</strong>。</p> 
<p><strong>把具有不同关键码而具有相同哈希地址的数据元素称为“同义词”</strong>。</p> 
<p>发生哈希冲突该如何处理呢？</p> 
<h2><a id="3__40"></a>3. 哈希函数</h2> 
<p>引起哈希冲突的一个原因可能是：<strong>哈希函数设计不够合理</strong>。</p> 
<p><strong>哈希函数设计原则</strong>：</p> 
<ul><li>哈希函数的定义域必须包括需要存储的全部关键码，而如果散列表允许有 m 个地址时，其值域必须在 0 到 m - 1 之间；</li><li>哈希函数计算出来的地址能均匀分布在整个空间中；</li><li>哈希函数应该比较简单。</li></ul> 
<p><strong>常见哈希函数</strong>：</p> 
<ol><li> <p><strong>直接定址法</strong>（常用）</p> <p><strong>取关键字的某个线性函数为散列地址：<code>Hash (Key) = A * Key + B</code></strong>；<br> <strong>优点：简单、均匀</strong><br> <strong>缺点：需要事先知道关键字的分布情况</strong>；<br> <strong>使用场景：适合查找比较小且连续的情况</strong>。</p> </li><li> <p><strong>除留余数法</strong>（常用）</p> <p>设散列表中允许的<strong>地址数为 m，取一个不大于 m，但最接近或者等于 m 的质数 p 作为除数，按照哈希函数：<code>Hash (Key) = Key % p (p &lt;= m)</code>，将关键码转换成哈希地址</strong>。</p> </li><li> <p><strong>平方取中法</strong>（了解）</p> <p>假设关键字为 1234，对它平方就是 1522756，抽取中间的 3 位 227 作为哈希地址；<br> 再比如关键字为 4321，对它平方就是 18671041，抽取中间的 3 位 671（或 710）作为哈希地址；<br> <strong>平方取中法比较适合：不知道关键字的分布，而位数又不是很大的情况</strong>。</p> </li><li> <p><strong>折叠法</strong>（了解）</p> <p>折叠法是将关键字从左到右分割成位数相等的几部分（最后一部分位数可以短些），然后将这几部分叠加求和，并按照散列表表长，取后几位作为散列地址；<br> <strong>折叠法适合事先不需要知道关键字的分布，适合关键字位数比较多的情况</strong>。</p> </li><li> <p><strong>随机数法</strong>（了解）</p> <p>选择一个随机函数，取关键字的随机函数值为它的哈希地址，即 <code>Hash (Key) = random(Key)</code>，其中 random 为随机数函数；<br> <strong>通常应用于关键字长度不等时采用此法</strong>。</p> </li><li> <p><strong>数学分析法</strong>（了解）</p> <p>设有 n 个 d 位数，每一位可能有 r 种不同的符号，这 r 种不同的符号在各位上出现的频率不一定相同，可能在某些位上分布比较均匀，每种符号出现的机会均等，在某些位上分布不均匀，只有某几种符号经常出现。可根据散列表的大小，选择其中各种符号分布均匀的若干位作为散列地址。例如：</p> <p><img src="https://images2.imgbox.com/8d/35/peoFjqpf_o.png" alt="在这里插入图片描述"></p> <p>假设要存储某家公司员工登记表，如果用手机号作为关键字，那么极有可能前 7 位都是相同的，那么我们可以选择后面的四位作为散列地址，如果这样的抽取工作还容易出现冲突，还可以对抽取出来的数字进行反转（如 1234 改成 4321）、右环移位（如 1234 改成 4123）、左环移位、前两数与后两数叠加（如 1234 改成 12+34=46）等方法；<br> <strong>数字分析法通常适合处理关键字位数比较多的情况</strong>。</p> </li></ol> 
<p><strong>注意：哈希函数设计的越精妙，产生哈希冲突的可能性就越低，但是无法避免哈希冲突</strong>。</p> 
<h2><a id="4__87"></a>4. 哈希冲突解决</h2> 
<p><strong>解决哈希冲突</strong>两种常见的方法是：<strong>闭散列</strong>和<strong>开散列</strong>。</p> 
<h3><a id="41__90"></a>4.1 闭散列</h3> 
<p><strong>闭散列：也叫开放定址法，当发生哈希冲突时，如果哈希表未被装满，说明哈希表中必然还有空位置，那么可以把 key 存放到冲突位置中的“下一个”空位置中去</strong>。那如何寻找下一个空位置呢？</p> 
<ol><li> <p><strong>线性探测</strong></p> <p>比如上面的场景：</p> <p><img src="https://images2.imgbox.com/af/e9/n9ovy5a1_o.png" alt="在这里插入图片描述"></p> <p>现在需要插入元素 44，先通过哈希函数计算哈希地址，hashAddr 为 4，因此 44 理论上应该插在该位置，但是该位置已经放了值为 4 的元素，即发生哈希冲突。</p> <p><strong>线性探测：从发生冲突的位置开始，依次向后探测，直到寻找到下一个空位置为止</strong>。</p> 
  <ul><li> <p><strong>插入</strong></p> 
    <ul><li> <p><strong>通过哈希函数获取待插入元素在哈希表中的位置</strong>；</p> </li><li> <p><strong>如果该位置中没有元素则直接插入新元素，如果该位置中有元素发生哈希冲突，使用线性探测找到下一个空位置，插入新元素</strong>。</p> <p><img src="https://images2.imgbox.com/88/c4/OBWx7Fc0_o.png" alt="在这里插入图片描述"></p> </li></ul> </li><li> <p><strong>删除</strong></p> <p><strong>采用闭散列处理哈希冲突时，不能随便物理删除哈希表中已有的元素，若直接删除元素会影响其他元素的搜索</strong>。比如删除元素 4，如果直接删除掉，44 查找起来可能会受影响。因此<strong>线性探测采用标记的伪删除法来删除一个元素</strong>。</p> <pre><code class="prism language-cpp"><span class="token comment">// 哈希表每个空间给个标记</span>
<span class="token comment">// EMPTY此位置空， EXIST此位置已经有元素， DELETE元素已经删除</span>
<span class="token keyword">enum</span> <span class="token class-name">State</span>
<span class="token punctuation">{<!-- --></span>
	EMPTY<span class="token punctuation">,</span>
	EXIST<span class="token punctuation">,</span>
	DELETE
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> </li></ul> </li><li> <p><strong>线性探测的实现</strong></p> <pre><code class="prism language-cpp"><span class="token comment">// 注意：假如实现的哈希表中元素唯一，即key相同的元素不再进行插入</span>
<span class="token comment">// 为了实现简单，此哈希表中我们将比较直接与元素绑定在一起</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">V</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">HashTable</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">struct</span> <span class="token class-name">Elem</span>
	<span class="token punctuation">{<!-- --></span>
		pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span> _val<span class="token punctuation">;</span>
		State _state<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
	
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">HashTable</span><span class="token punctuation">(</span>size_t capacity <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span>
		<span class="token operator">:</span> <span class="token function">_ht</span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_size</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> capacity<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
			_ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>_state <span class="token operator">=</span> EMPTY<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">bool</span> <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> pair<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token operator">&amp;</span> val<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 检测哈希表底层空间是否充足</span>
		<span class="token comment">// _CheckCapacity();</span>
		size_t hashAddr <span class="token operator">=</span> <span class="token function">HashFunc</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// size_t startAddr = hashAddr;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>_ht<span class="token punctuation">[</span>hashAddr<span class="token punctuation">]</span><span class="token punctuation">.</span>_state <span class="token operator">!=</span> EMPTY<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_ht<span class="token punctuation">[</span>hashAddr<span class="token punctuation">]</span><span class="token punctuation">.</span>_state <span class="token operator">==</span> EXIST <span class="token operator">&amp;&amp;</span> _ht<span class="token punctuation">[</span>hashAddr<span class="token punctuation">]</span><span class="token punctuation">.</span>_val<span class="token punctuation">.</span>first <span class="token operator">==</span> key<span class="token punctuation">)</span>
				<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
				
			hashAddr<span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>hashAddr <span class="token operator">==</span> _ht<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
				hashAddr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
			<span class="token comment">/*
			转一圈也没有找到，注意：动态哈希表，该种情况可以不用考虑，哈希表中元素个数到达一定的数量，
			哈希冲突概率会增大，需要扩容来降低哈希冲突，因此哈希表中元素是不会存满的
			if(hashAddr == startAddr)
				return false;
			*/</span>
		<span class="token punctuation">}</span>
		
		<span class="token comment">// 插入元素</span>
		_ht<span class="token punctuation">[</span>hashAddr<span class="token punctuation">]</span><span class="token punctuation">.</span>_state <span class="token operator">=</span> EXIST<span class="token punctuation">;</span>
		_ht<span class="token punctuation">[</span>hashAddr<span class="token punctuation">]</span><span class="token punctuation">.</span>_val <span class="token operator">=</span> val<span class="token punctuation">;</span>
		_size<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">int</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token keyword">const</span> K<span class="token operator">&amp;</span> key<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		size_t hashAddr <span class="token operator">=</span> <span class="token function">HashFunc</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>_ht<span class="token punctuation">[</span>hashAddr<span class="token punctuation">]</span><span class="token punctuation">.</span>_state <span class="token operator">!=</span> EMPTY<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_ht<span class="token punctuation">[</span>hashAddr<span class="token punctuation">]</span><span class="token punctuation">.</span>_state <span class="token operator">==</span> EXIST <span class="token operator">&amp;&amp;</span> _ht<span class="token punctuation">[</span>hashAddr<span class="token punctuation">]</span><span class="token punctuation">.</span>_val<span class="token punctuation">.</span>first <span class="token operator">==</span> key<span class="token punctuation">)</span>
				<span class="token keyword">return</span> hashAddr<span class="token punctuation">;</span>
				
			hashAddr<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> hashAddr<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">bool</span> <span class="token function">Erase</span><span class="token punctuation">(</span><span class="token keyword">const</span> K <span class="token operator">&amp;</span> key<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">Find</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">!=</span> index<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			_ht<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>_state <span class="token operator">=</span> DELETE<span class="token punctuation">;</span>
			_size<span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	size_t <span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span>
	<span class="token keyword">bool</span> <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span>HashTable<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token punctuation">,</span> HF<span class="token operator">&gt;</span><span class="token operator">&amp;</span> ht<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
<span class="token keyword">private</span><span class="token operator">:</span>
	size_t <span class="token function">HashFunc</span><span class="token punctuation">(</span><span class="token keyword">const</span> K<span class="token operator">&amp;</span> key<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> key <span class="token operator">%</span> _ht<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
<span class="token keyword">private</span><span class="token operator">:</span>
	vector<span class="token operator">&lt;</span>Elem<span class="token operator">&gt;</span> _ht<span class="token punctuation">;</span>
	size_t _size<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <p><strong>思考：哈希表什么情况下进行扩容？如何扩容？</strong></p> <p><img src="https://images2.imgbox.com/d8/59/piTi8Xjh_o.png" alt="在这里插入图片描述"></p> <pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">CheckCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>_size <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">/</span> _ht<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">7</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		HashTable<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token punctuation">,</span> HF<span class="token operator">&gt;</span> <span class="token function">newHt</span><span class="token punctuation">(</span><span class="token function">GetNextPrime</span><span class="token punctuation">(</span>ht<span class="token punctuation">.</span>capacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> _ht<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>_ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>_state <span class="token operator">==</span> EXIST<span class="token punctuation">)</span>
				newHt<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span>_ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>_val<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token function">Swap</span><span class="token punctuation">(</span>newHt<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <p>线性探测优点：实现非常简单；</p> <p>线性探测缺点：<strong>一旦发生哈希冲突，所有的冲突连在一起，容易产生数据“堆积”，即：不同关键码占据了可利用的空位置，使得寻找某关键码的位置需要多次比较，导致搜索效率降低</strong>，如何缓解？</p> </li><li> <p><strong>二次探测</strong></p> <p>线性探测的缺陷是产生冲突的数据堆积在一块，这与其找下一个空位置有关系，因为找空位置的方式就是挨着往后逐个去找，因此二次探测为了避免该问题，<strong>找下一个空位置的方法为：<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
           
           
             H 
            
           
             i 
            
           
          
         
           H_i 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0813em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0813em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> = ( <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
           
           
             H 
            
           
             0 
            
           
          
         
           H_0 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0813em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0813em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> + <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
           
           
             i 
            
           
             2 
            
           
          
         
           i^2 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8141em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> ) % m。其中：i = 1, 2, 3…，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
        
         
          
           
           
             H 
            
           
             0 
            
           
          
         
           H_0 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0813em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0813em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 是通过散列函数 Hash(x) 对关键码 key 进行计算得到的位置，m 是表的大小</strong>。</p> <p>对于上面案例，如果要插入 44，产生冲突，使用二次探测解决后的情况为：</p> <p><img src="https://images2.imgbox.com/47/03/Hs4h6hPT_o.png" alt="在这里插入图片描述"></p> <p>研究表明：<strong>当表的长度为质数且表装载因子 a 不超过 0.5 时，新的表项一定能够插入。而且任何一个位置都不会被探查两次。因此只要表中有一半的空位置，就不会存在表满的问题。在搜索时可以不考虑表装满的情况，但在插入时必须确保表的装载因子 a 不超过 0.5</strong>，如果超出必须考虑增容。</p> </li></ol> 
<p>因此：闭散列最大的缺陷就是空间利用率比较低，这也是哈希的缺陷。</p> 
<h3><a id="42__251"></a>4.2 开散列</h3> 
<ol><li> <p><strong>开散列的概念</strong></p> <p><strong>开散列法又叫链地址法（开链法），首先对关键码集合用散列函数计算散列地址，具有相同地址的关键码归于同一子集合，每一个子集合称为一个桶，各个桶中的元素通过一个单链表链接起来，各链表的头节点存储在哈希表中</strong>。</p> <p>个人理解：哈希桶 = 顺序表 + 链表 + 哈希算法；</p> <p><img src="https://images2.imgbox.com/f9/f6/GESQO4lp_o.png" alt="在这里插入图片描述"></p> <p><img src="https://images2.imgbox.com/7b/89/2sQPSoEg_o.png" alt="在这里插入图片描述"></p> <p>从上图可以看出，<strong>开散列中每个桶中放的都是发生哈希冲突的元素</strong>。</p> </li><li> <p><strong>开散列实现</strong></p> <pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">V</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">HashBucketNode</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">HashBucketNode</span><span class="token punctuation">(</span><span class="token keyword">const</span> V<span class="token operator">&amp;</span> data<span class="token punctuation">)</span>
		<span class="token operator">:</span> <span class="token function">_pNext</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_data</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	HashBucketNode<span class="token operator">&lt;</span>V<span class="token operator">&gt;</span><span class="token operator">*</span> _pNext<span class="token punctuation">;</span>
	V _data<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 本文所实现的哈希桶中key是唯一的</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">V</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">HashBucket</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">typedef</span> HashBucketNode<span class="token operator">&lt;</span>V<span class="token operator">&gt;</span> Node<span class="token punctuation">;</span>
	<span class="token keyword">typedef</span> Node<span class="token operator">*</span> PNode<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">HashBucket</span><span class="token punctuation">(</span>size_t capacity <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_size</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		_ht<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token function">GetNextPrime</span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token comment">// 哈希桶中的元素不能重复</span>
	PNode<span class="token operator">*</span> <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> V<span class="token operator">&amp;</span> data<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 确认是否需要扩容。。。</span>
		<span class="token comment">// _CheckCapacity();</span>
		
		<span class="token comment">// 1. 计算元素所在的桶号</span>
		size_t bucketNo <span class="token operator">=</span> <span class="token function">HashFunc</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token comment">// 2. 检测该元素是否在桶中</span>
		PNode pCur <span class="token operator">=</span> _ht<span class="token punctuation">[</span>bucketNo<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>pCur<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>pCur<span class="token operator">-&gt;</span>_data <span class="token operator">==</span> data<span class="token punctuation">)</span>
				<span class="token keyword">return</span> pCur<span class="token punctuation">;</span>
			pCur <span class="token operator">=</span> pCur<span class="token operator">-&gt;</span>_pNext<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
		<span class="token comment">// 3. 插入新元素</span>
		pCur <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
		pCur<span class="token operator">-&gt;</span>_pNext <span class="token operator">=</span> _ht<span class="token punctuation">[</span>bucketNo<span class="token punctuation">]</span><span class="token punctuation">;</span>
		_ht<span class="token punctuation">[</span>bucketNo<span class="token punctuation">]</span> <span class="token operator">=</span> pCur<span class="token punctuation">;</span>
		_size<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> pCur<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token comment">// 删除哈希桶中为data的元素(data不会重复)，返回删除元素的下一个节点</span>
	PNode<span class="token operator">*</span> <span class="token function">Erase</span><span class="token punctuation">(</span><span class="token keyword">const</span> V<span class="token operator">&amp;</span> data<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		size_t bucketNo <span class="token operator">=</span> <span class="token function">HashFunc</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
		PNode pCur <span class="token operator">=</span> _ht<span class="token punctuation">[</span>bucketNo<span class="token punctuation">]</span><span class="token punctuation">;</span>
		PNode pPrev <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> pRet <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>pCur<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>pCur<span class="token operator">-&gt;</span>_data <span class="token operator">==</span> data<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>pCur <span class="token operator">==</span> _ht<span class="token punctuation">[</span>bucketNo<span class="token punctuation">]</span><span class="token punctuation">)</span>
					_ht<span class="token punctuation">[</span>bucketNo<span class="token punctuation">]</span> <span class="token operator">=</span> pCur<span class="token operator">-&gt;</span>_pNext<span class="token punctuation">;</span>
				<span class="token keyword">else</span>
					pPrev<span class="token operator">-&gt;</span>_pNext <span class="token operator">=</span> pCur<span class="token operator">-&gt;</span>_pNext<span class="token punctuation">;</span>
					
				pRet <span class="token operator">=</span> pCur<span class="token operator">-&gt;</span>_pNext<span class="token punctuation">;</span>
				<span class="token keyword">delete</span> pCur<span class="token punctuation">;</span>
				_size<span class="token operator">--</span><span class="token punctuation">;</span>
				<span class="token keyword">return</span> pRet<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	PNode<span class="token operator">*</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token keyword">const</span> V<span class="token operator">&amp;</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
	size_t <span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span>
	<span class="token keyword">bool</span> <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token function">Clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">bool</span> <span class="token function">BucketCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span>HashBucket<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> HF<span class="token operator">&gt;</span><span class="token operator">&amp;</span> ht<span class="token punctuation">;</span>
	<span class="token operator">~</span><span class="token function">HashBucket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
<span class="token keyword">private</span><span class="token operator">:</span>
	size_t <span class="token function">HashFunc</span><span class="token punctuation">(</span><span class="token keyword">const</span> V<span class="token operator">&amp;</span> data<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> data <span class="token operator">%</span> _ht<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
<span class="token keyword">private</span><span class="token operator">:</span>
	vector<span class="token operator">&lt;</span>PNode<span class="token operator">*</span><span class="token operator">&gt;</span> _ht<span class="token punctuation">;</span>
	size_t _size<span class="token punctuation">;</span> <span class="token comment">// 哈希表中有效元素的个数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> </li><li> <p><strong>开散列增容</strong></p> <p>桶的个数是一定的，随着元素的不断插入。每个桶中元素的个数不断增多，极端情况下，可能会导致一个桶中链表节点非常多，会影响哈希表的性能，因此在一定条件下需要对哈希表进行增容，那该条件怎么确认呢？开散列最好的情况是：每个哈希桶中刚好挂一个节点，再继续插入元素时，每一次都会发生哈希冲突，因此，在元素个数刚好等于桶的个数时，可以给哈希表增容。</p> <pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">_CheckCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		size_t bucketCount <span class="token operator">=</span> <span class="token function">BucketCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>_size <span class="token operator">==</span> bucketCount<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			HashBucket<span class="token operator">&lt;</span>V<span class="token punctuation">,</span> HF<span class="token operator">&gt;</span> <span class="token function">newHt</span><span class="token punctuation">(</span>bucketCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t bucketIdx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> bucketIdx <span class="token operator">&lt;</span> bucketCount<span class="token punctuation">;</span> <span class="token operator">++</span>bucketIdx<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				PNode pCur <span class="token operator">=</span> _ht<span class="token punctuation">[</span>bucketIdx<span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token keyword">while</span> <span class="token punctuation">(</span>pCur<span class="token punctuation">)</span>
				<span class="token punctuation">{<!-- --></span>
					<span class="token comment">// 将该节点从原哈希表中拆出来</span>
					_ht<span class="token punctuation">[</span>bucketIdx<span class="token punctuation">]</span> <span class="token operator">=</span> pCur<span class="token operator">-&gt;</span>_pNext<span class="token punctuation">;</span>
					
					<span class="token comment">// 将该节点插入到新哈希表中</span>
					size_t bucketNo <span class="token operator">=</span> newHt<span class="token punctuation">.</span><span class="token function">HashFunc</span><span class="token punctuation">(</span>pCur<span class="token operator">-&gt;</span>_data<span class="token punctuation">)</span><span class="token punctuation">;</span>
					pCur<span class="token operator">-&gt;</span>_pNext <span class="token operator">=</span> newHt<span class="token punctuation">.</span>_ht<span class="token punctuation">[</span>bucketNo<span class="token punctuation">]</span><span class="token punctuation">;</span>
					newHt<span class="token punctuation">.</span>_ht<span class="token punctuation">[</span>bucketNo<span class="token punctuation">]</span> <span class="token operator">=</span> pCur<span class="token punctuation">;</span>
					pCur <span class="token operator">=</span> _ht<span class="token punctuation">[</span>bucketIdx<span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			newHt<span class="token punctuation">.</span>_size <span class="token operator">=</span> _size<span class="token punctuation">;</span>
			<span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token function">Swap</span><span class="token punctuation">(</span>newHt<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> </li><li> <p><strong>开散列的思考</strong></p> 
  <ul><li> <p><strong>只能存储 key 为整型的元素，其他类型怎么解决</strong>？</p> <pre><code class="prism language-cpp"><span class="token comment">// 哈希函数采用除留余数法，被模的key必须要为整形才可以处理，此处提供将key转化为整形的方法</span>
<span class="token comment">// 整形数据不需要转化</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">DefHashF</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> val<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> val<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// key为字符串类型，需要将其转化为整形</span>
<span class="token keyword">class</span> <span class="token class-name">Str2Int</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> str <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">unsigned</span> <span class="token keyword">int</span> seed <span class="token operator">=</span> <span class="token number">131</span><span class="token punctuation">;</span> <span class="token comment">// 31 131 1313 13131 131313</span>
		<span class="token keyword">unsigned</span> <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>str<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			hash <span class="token operator">=</span> hash <span class="token operator">*</span> seed <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">*</span>str<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token punctuation">(</span>hash <span class="token operator">&amp;</span> <span class="token number">0x7FFFFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 为了实现简单，此哈希表中我们将比较直接与元素绑定在一起</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">V</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">HF</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">HashBucket</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// ……</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	size_t <span class="token function">HashFunc</span><span class="token punctuation">(</span><span class="token keyword">const</span> V<span class="token operator">&amp;</span> data<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token function">HF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token operator">%</span> _ht<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> </li><li> <p><strong>除留余数法，最好模一个素数，如何每次快速取一个类似两倍关系的素数？</strong></p> <pre><code class="prism language-cpp">size_t <span class="token function">GetNextPrime</span><span class="token punctuation">(</span>size_t prime<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> PRIMECOUNT <span class="token operator">=</span> <span class="token number">28</span><span class="token punctuation">;</span>
	<span class="token keyword">static</span> <span class="token keyword">const</span> size_t primeList<span class="token punctuation">[</span>PRIMECOUNT<span class="token punctuation">]</span> <span class="token operator">=</span>
	<span class="token punctuation">{<!-- --></span>
	<span class="token number">53ul</span><span class="token punctuation">,</span> <span class="token number">97ul</span><span class="token punctuation">,</span> <span class="token number">193ul</span><span class="token punctuation">,</span> <span class="token number">389ul</span><span class="token punctuation">,</span> <span class="token number">769ul</span><span class="token punctuation">,</span>
	<span class="token number">1543ul</span><span class="token punctuation">,</span> <span class="token number">3079ul</span><span class="token punctuation">,</span> <span class="token number">6151ul</span><span class="token punctuation">,</span> <span class="token number">12289ul</span><span class="token punctuation">,</span> <span class="token number">24593ul</span><span class="token punctuation">,</span>
	<span class="token number">49157ul</span><span class="token punctuation">,</span> <span class="token number">98317ul</span><span class="token punctuation">,</span> <span class="token number">196613ul</span><span class="token punctuation">,</span> <span class="token number">393241ul</span><span class="token punctuation">,</span> <span class="token number">786433ul</span><span class="token punctuation">,</span>
	<span class="token number">1572869ul</span><span class="token punctuation">,</span> <span class="token number">3145739ul</span><span class="token punctuation">,</span> <span class="token number">6291469ul</span><span class="token punctuation">,</span> <span class="token number">12582917ul</span><span class="token punctuation">,</span>
	<span class="token number">25165843ul</span><span class="token punctuation">,</span>
	<span class="token number">50331653ul</span><span class="token punctuation">,</span> <span class="token number">100663319ul</span><span class="token punctuation">,</span> <span class="token number">201326611ul</span><span class="token punctuation">,</span> <span class="token number">402653189ul</span><span class="token punctuation">,</span>
	<span class="token number">805306457ul</span><span class="token punctuation">,</span>
	<span class="token number">1610612741ul</span><span class="token punctuation">,</span> <span class="token number">3221225473ul</span><span class="token punctuation">,</span> <span class="token number">4294967291ul</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
	
	size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> PRIMECOUNT<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>primeList<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> prime<span class="token punctuation">)</span>
			<span class="token keyword">return</span> primeList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> primeList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> </li><li> <p><strong>开散列与闭散列比较</strong></p> <p><strong>应用链地址法处理溢出，需要增设链接指针，似乎增加了存储开销</strong>。事实上：<strong>由于开地址法必须保持大量的空闲空间以确保搜索效率，如二次探测法要求装载因子 a &lt;= 0.7，而表项所占空间又比指针大得多，所以使用链地址法反而比开地址法节省存储空间</strong>。</p> </li></ol> 
<hr> 
<center>
  END 
</center>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4e87190e85e1398babf171ef9f9e5f0b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【AIGC】LangChain入门指南—第二章 LangChain入门指南</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c95f9b8d66414f2d8e6f552f8c6173e6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AIGC革新浪潮：大语言模型如何优化企业运营</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>