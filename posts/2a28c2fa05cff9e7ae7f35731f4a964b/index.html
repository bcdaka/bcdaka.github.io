<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>云原生容器技术入门：Docker、K8s技术的基本原理和用途 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/2a28c2fa05cff9e7ae7f35731f4a964b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="云原生容器技术入门：Docker、K8s技术的基本原理和用途">
  <meta property="og:description" content="🐇明明跟你说过：个人主页
🏅个人专栏：《未来已来：云原生之旅》🏅
🔖行路有良友，便是天堂🔖
目录
一、容器技术概述
1、什么是容器技术
2、容器技术的历史与发展
3、容器技术与虚拟机的比较
4、容器技术在云原生中的作用
二、Docker基础
1、Docker简介
2、Docker架构
3、Docker与工作原理
三、Kubernetes（k8s）基础
1、Kubernetes简介
2、Kubernetes核心概念
一、容器技术概述 1、什么是容器技术 容器是一种轻量级的虚拟化技术，它打包了应用程序及其所有的依赖（库、配置文件等），确保应用程序可以在任何环境中一致地运行。容器本身是一个隔离的、独立的单元，里面包含了运行应用程序所需的一切。
想象一下你要带一份便当去办公室吃午餐。你需要确保便当里的食物不会在运输过程中洒出来，也不会因为环境的变化（比如办公室的冰箱或微波炉）而影响食物的味道和质量。为了做到这一点，你把食物放在一个便当盒里。
应用程序：食物容器：便当盒环境：办公室、家里、朋友的家等 不管你在什么地方，只要有便当盒，你的食物都可以安全无损地食用。同样，容器技术就像这个便当盒，不管你把应用程序放在哪里（开发者的电脑、测试服务器、生产环境的云端），它都能正常运行。
2、容器技术的历史与发展 容器技术的历史与发展可以追溯到几十年前，经历了多个阶段的演变，最终发展成为我们今天广泛使用的现代容器技术。
1. 早期的隔离技术
Chroot (1979)
介绍：Chroot 是 Unix 操作系统中的一个系统调用，最早在 1979 年的第七版 Unix 中引入。功能：它通过改变进程的根目录来提供文件系统级别的隔离，但不提供进程和网络等其他方面的隔离。 2. 进程隔离技术
FreeBSD Jail (2000)
介绍：FreeBSD Jail 是 FreeBSD 操作系统中的一个功能，最早在 2000 年推出。功能：提供了文件系统、网络、用户和进程的隔离。Jail 可以看作是 chroot 的增强版本，支持更多的隔离特性。 Solaris Zones (2004)
介绍：Solaris Zones 是 Solaris 操作系统中的一个功能，于 2004 年推出。功能：提供了完整的操作系统级别的隔离，可以在一个物理主机上运行多个隔离的 Solaris 实例。 3. Linux 容器技术的崛起
LXC (Linux Containers) (2008)">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-24T07:30:00+08:00">
    <meta property="article:modified_time" content="2024-06-24T07:30:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">云原生容器技术入门：Docker、K8s技术的基本原理和用途</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="1080" src="https://images2.imgbox.com/1e/58/0GbtiHdm_o.jpg" width="1200"></p> 
<p style="text-align:center;">🐇明明跟你说过：<a href="https://blog.csdn.net/weixin_53269650?spm=1011.2415.3001.5343" title="个人主页">个人主页</a></p> 
<p style="text-align:center;">🏅个人专栏：<a href="https://blog.csdn.net/weixin_53269650/category_12701571.html?spm=1001.2014.3001.5482" title="《未来已来：云原生之旅》">《未来已来：云原生之旅》</a>🏅</p> 
<p style="text-align:center;">🔖行路有良友，便是天堂🔖</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0" rel="nofollow">一、容器技术概述</a></p> 
<p id="1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF" rel="nofollow">1、什么是容器技术</a></p> 
<p id="2%E3%80%81%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8E%86%E5%8F%B2%E4%B8%8E%E5%8F%91%E5%B1%95-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8E%86%E5%8F%B2%E4%B8%8E%E5%8F%91%E5%B1%95" rel="nofollow">2、容器技术的历史与发展</a></p> 
<p id="3%E3%80%81%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%AF%94%E8%BE%83-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%AF%94%E8%BE%83" rel="nofollow">3、容器技术与虚拟机的比较</a></p> 
<p id="4%E3%80%81%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%9C%A8%E4%BA%91%E5%8E%9F%E7%94%9F%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%9C%A8%E4%BA%91%E5%8E%9F%E7%94%9F%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8" rel="nofollow">4、容器技术在云原生中的作用</a></p> 
<p id="%E4%BA%8C%E3%80%81Docker%E5%9F%BA%E7%A1%80-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81Docker%E5%9F%BA%E7%A1%80" rel="nofollow">二、Docker基础</a></p> 
<p id="1%E3%80%81Docker%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px;"><a href="#1%E3%80%81Docker%E7%AE%80%E4%BB%8B" rel="nofollow">1、Docker简介</a></p> 
<p id="2%E3%80%81Docker%E6%9E%B6%E6%9E%84-toc" style="margin-left:40px;"><a href="#2%E3%80%81Docker%E6%9E%B6%E6%9E%84" rel="nofollow">2、Docker架构</a></p> 
<p id="3%E3%80%81Docker%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#3%E3%80%81Docker%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" rel="nofollow">3、Docker与工作原理</a></p> 
<p id="%E4%B8%89%E3%80%81Kubernetes%EF%BC%88k8s%EF%BC%89%E5%9F%BA%E7%A1%80-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81Kubernetes%EF%BC%88k8s%EF%BC%89%E5%9F%BA%E7%A1%80" rel="nofollow">三、Kubernetes（k8s）基础</a></p> 
<p id="1%E3%80%81Kubernetes%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px;"><a href="#1%E3%80%81Kubernetes%E7%AE%80%E4%BB%8B" rel="nofollow">1、Kubernetes简介</a></p> 
<p id="2%E3%80%81Kubernetes%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#2%E3%80%81Kubernetes%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5" rel="nofollow">2、Kubernetes核心概念</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0">一、容器技术概述</h2> 
<h3 id="1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF">1、什么是容器技术</h3> 
<blockquote> 
 <p><span style="color:#fe2c24;">容器</span>是一种轻量级的虚拟化技术，它打包了应用程序及其所有的依赖（库、配置文件等），确保应用程序可以在任何环境中一致地运行。容器本身是一个隔离的、独立的单元，里面包含了运行应用程序所需的一切。</p> 
</blockquote> 
<p>想象一下你要带一份便当去办公室吃午餐。你需要确保便当里的食物不会在运输过程中洒出来，也不会因为环境的变化（比如办公室的冰箱或微波炉）而影响食物的味道和质量。为了做到这一点，你把食物放在一个便当盒里。</p> 
<ul><li><strong>应用程序：</strong>食物</li><li><strong>容器：</strong>便当盒</li><li><strong>环境：</strong>办公室、家里、朋友的家等</li></ul> 
<p>不管你在什么地方，只要有便当盒，你的食物都可以安全无损地食用。同样，容器技术就像这个便当盒，不管你把应用程序放在哪里（开发者的电脑、测试服务器、生产环境的云端），它都能正常运行。</p> 
<p class="img-center"><img alt="" height="690" src="https://images2.imgbox.com/3a/cc/nsPYW0g1_o.png" width="1200"></p> 
<h3 id="2%E3%80%81%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8E%86%E5%8F%B2%E4%B8%8E%E5%8F%91%E5%B1%95">2、容器技术的历史与发展</h3> 
<p>容器技术的历史与发展可以追溯到几十年前，经历了多个阶段的演变，最终发展成为我们今天广泛使用的现代容器技术。</p> 
<p><strong>1. 早期的隔离技术</strong><br> Chroot (1979)</p> 
<ul><li><strong>介绍：</strong>Chroot 是 Unix 操作系统中的一个系统调用，最早在 1979 年的第七版 Unix 中引入。</li><li><strong>功能：</strong>它通过改变进程的根目录来提供文件系统级别的隔离，但不提供进程和网络等其他方面的隔离。</li></ul> 
<p><br><strong>2. 进程隔离技术</strong><br> FreeBSD Jail (2000)</p> 
<ul><li><strong>介绍：</strong>FreeBSD Jail 是 FreeBSD 操作系统中的一个功能，最早在 2000 年推出。</li><li><strong>功能：</strong>提供了文件系统、网络、用户和进程的隔离。Jail 可以看作是 chroot 的增强版本，支持更多的隔离特性。</li></ul> 
<p>Solaris Zones (2004)</p> 
<ul><li><strong>介绍：</strong>Solaris Zones 是 Solaris 操作系统中的一个功能，于 2004 年推出。</li><li><strong>功能：</strong>提供了完整的操作系统级别的隔离，可以在一个物理主机上运行多个隔离的 Solaris 实例。</li></ul> 
<p><br><strong>3. Linux 容器技术的崛起</strong><br> LXC (Linux Containers) (2008)</p> 
<ul><li><strong>介绍：</strong>LXC 是 Linux 上的容器技术，于 2008 年发布。</li><li><strong>功能：</strong>结合了 Linux 内核中的多个隔离功能（如 namespaces 和 cgroups），实现进程和资源的隔离。</li></ul> 
<p><br><strong>4. Docker 的诞生与流行</strong><br> Docker (2013)</p> 
<ul><li><strong>介绍：</strong>Docker 于 2013 年发布，由 Solomon Hykes 创立。</li><li><strong>功能：</strong>Docker 提供了一套完整的容器化解决方案，包括容器构建、分发和运行的工具。Docker 通过简单易用的接口和强大的社区支持，使容器技术迅速普及。</li><li><strong>影响：</strong>Docker 的出现将容器技术从操作系统层面带到了应用层面，简化了应用程序的部署、迁移和扩展。</li></ul> 
<p><br><strong>5. 容器编排与管理</strong><br> Kubernetes (2014)</p> 
<ul><li><strong>介绍：</strong>Kubernetes 是 Google 开源的容器编排平台，于 2014 年发布。</li><li><strong>功能：</strong>提供自动化的容器部署、扩展和管理功能，解决了大规模容器管理的复杂性问题。</li><li><strong>影响：</strong>Kubernetes 成为容器编排的事实标准，推动了容器技术在企业中的广泛应用。</li></ul> 
<p class="img-center"><img alt="" height="543" src="https://images2.imgbox.com/e0/31/An63M1l3_o.png" width="1150"></p> 
<p></p> 
<h3 id="3%E3%80%81%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%AF%94%E8%BE%83">3、容器技术与虚拟机的比较</h3> 
<p><strong>1. 架构与实现方式</strong></p> 
<ul><li>虚拟机（VM） 
  <ul><li> <span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">架构：</span></span>每个虚拟机都包含一个完整的操作系统实例、虚拟化的硬件（如 CPU、内存、网络设备等）以及应用程序。</li><li> <span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">虚拟化层：</span></span>虚拟机依赖于 Hypervisor（如 VMware ESXi、Microsoft Hyper-V、KVM），Hypervisor 是一个虚拟化层，位于物理硬件和虚拟机之间，管理和分配硬件资源。</li><li> <span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">操作系统：</span></span>每个虚拟机运行自己的操作系统（称为 Guest OS），与主机操作系统（Host OS）完全独立。</li></ul></li><li>容器 
  <ul><li> <span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">架构：</span></span>容器共享主机操作系统的内核，但在用户空间中运行隔离的进程。每个容器包含应用程序及其依赖项，但没有完整的操作系统。</li><li> <span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">虚拟化层：</span></span>容器依赖于操作系统级虚拟化技术，如 Linux 的 cgroups 和 namespaces，实现资源和进程的隔离。</li><li> <span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">操作系统：</span></span>所有容器共享主机操作系统的内核，没有自己的独立操作系统实例。</li></ul></li></ul> 
<p><br><strong>2. 启动时间与资源利用率</strong></p> 
<ul><li>启动时间 
  <ul><li> <span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">虚拟机：</span></span>由于需要启动完整的操作系统实例，虚拟机的启动时间通常较长（几分钟到几十秒）。</li><li> <span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">容器：</span></span>容器只需启动应用进程，启动时间非常快（通常在几秒钟内，甚至是亚秒级）。</li></ul></li><li>资源利用率 
  <ul><li> <span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">虚拟机：</span></span>由于每个虚拟机需要独立的操作系统实例和虚拟化开销，资源利用率相对较低。</li><li> <span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">容器：</span></span>容器共享操作系统内核，减少了冗余和开销，资源利用率更高。</li></ul></li></ul> 
<p><br><strong>3. 性能</strong></p> 
<ul><li><span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">虚拟机：</span></span>虚拟化层的开销（尤其是 I/O 操作）会影响性能，虽然现代 Hypervisor 已经大大优化了性能，但仍存在一定的性能损耗。</li><li><span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">容器：</span></span>由于容器直接运行在主机操作系统上，没有 Hypervisor 的开销，性能接近于直接在物理机上运行的应用程序。</li></ul> 
<p><br><strong>4. 隔离与安全</strong></p> 
<ul><li>隔离 
  <ul><li> <span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">虚拟机：</span></span>提供强隔离，每个虚拟机运行在自己的操作系统中，隔离程度高。虚拟机之间的安全隔离是通过 Hypervisor 实现的。</li><li> <span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">容器：</span></span>通过操作系统内核实现进程和资源的隔离，虽然隔离性较强，但理论上不如虚拟机。现代容器技术（如 Docker）也提供了额外的安全机制（如 seccomp、AppArmor、SELinux）来增强隔离性。</li></ul></li><li>安全 
  <ul><li> <span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">虚拟机：</span></span>由于强隔离，安全性较高，每个虚拟机的漏洞不会直接影响其他虚拟机或主机操作系统。</li><li> <span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">容器：</span></span>由于共享内核，内核级漏洞可能影响所有容器和主机操作系统，需要额外的安全措施来保护容器环境。</li></ul></li></ul> 
<p><br><strong>5. 可移植性与灵活性</strong></p> 
<ul><li> <span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">虚拟机：</span></span>虚拟机镜像较大，迁移和部署较为复杂。虚拟机可以在支持相同虚拟化技术的不同物理服务器之间迁移。</li><li><span style="color:#fe2c24;"><span style="background-color:#f3f3f4;">容器：</span></span>容器镜像小且轻量级，易于迁移和部署。容器化应用可以在任何支持容器运行时（如 Docker、containerd、CRI-O）的环境中运行，实现高度的可移植性。 </li></ul> 
<p class="img-center"><img alt="" height="663" src="https://images2.imgbox.com/16/68/YOQPfrWf_o.png" width="1200"></p> 
<h3 id="4%E3%80%81%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%9C%A8%E4%BA%91%E5%8E%9F%E7%94%9F%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8">4、容器技术在云原生中的作用</h3> 
<p><strong>1. 快速部署和扩展</strong></p> 
<ul><li><strong>快速启动：</strong>容器化应用的启动时间非常短，通常在秒级甚至亚秒级。这使得应用的部署和扩展变得更加迅速。</li><li><strong>弹性伸缩：</strong>通过容器编排工具（如 Kubernetes），可以实现应用的自动扩展和缩减，快速响应负载变化。</li></ul> 
<p><br><strong>2. 一致的运行环境</strong></p> 
<ul><li><strong>环境一致性：</strong>容器镜像包含了应用及其运行所需的所有依赖项，从开发、测试到生产环境，始终保持一致。这解决了“在我电脑上能运行”的问题，减少了环境差异导致的错误。</li></ul> 
<p><br><strong>3. DevOps 和 CI/CD</strong></p> 
<ul><li><strong>持续集成/持续交付（CI/CD）：</strong>容器技术与CI/CD工具链（如 Jenkins、GitLab CI/CD）集成，实现了代码的自动化构建、测试和部署，加速了软件的交付周期。</li><li><strong>DevOps 实践：</strong>容器技术推动了开发和运维的融合，通过基础设施即代码（IaC）和自动化运维工具，实现了高效的持续交付和持续部署。</li></ul> 
<p class="img-center"><img alt="" height="732" src="https://images2.imgbox.com/4f/34/XjQ6eSCi_o.png" width="1107"></p> 
<p></p> 
<h2 id="%E4%BA%8C%E3%80%81Docker%E5%9F%BA%E7%A1%80">二、<strong>Docker基础</strong></h2> 
<h3 id="1%E3%80%81Docker%E7%AE%80%E4%BB%8B">1、Docker简介</h3> 
<blockquote> 
 <p><span style="color:#fe2c24;">Docker </span>是一个用于开发、部署和运行应用程序的工具。它允许开发者将应用程序及其所有依赖项打包到一个可移植的容器中，并且该容器可以在任何支持 Docker 的环境中运行。Docker 提供了一种轻量级的虚拟化技术，不同于传统的虚拟机，容器共享主机的操作系统内核，但保持独立的运行环境。</p> 
</blockquote> 
<p><strong>Docker 的主要组成部分</strong></p> 
<ul><li><strong>Docker 引擎（Docker Engine）：</strong>这是 Docker 的核心组件，它包括： 
  <ul><li> <strong>Docker 守护进程（Docker Daemon）：</strong>负责管理容器的生命周期，包括创建、运行和停止容器。</li><li> <strong>Docker 客户端（Docker Client）：</strong>用户与 Docker 交互的命令行工具，通过命令行向 Docker 守护进程发送请求。</li><li> <strong>REST API：</strong>用于程序化地与 Docker 守护进程通信。</li></ul></li><li><strong>Docker 镜像（Docker Image）：</strong>Docker 镜像是一个包含应用程序及其所有依赖项的只读模板。镜像可以用来创建 Docker 容器。镜像通常是从 Dockerfile 构建的，Dockerfile 是一个包含构建镜像步骤的脚本。</li><li><strong>Docker 容器（Docker Container）：</strong>容器是镜像的运行实例，包含了应用程序及其所有依赖项，并在一个隔离的环境中运行。容器是轻量级的，启动速度快，可以在几秒钟内启动和停止。</li><li><strong>Docker 仓库（Docker Registry）：</strong>Docker 镜像的存储库，Docker Hub 是最常用的公共仓库，用户可以从中下载和上传镜像。也可以使用私有的 Docker 仓库来存储镜像。</li></ul> 
<p class="img-center"><img alt="" height="523" src="https://images2.imgbox.com/8a/18/slTSe9VX_o.png" width="1125"></p> 
<h3 id="2%E3%80%81Docker%E6%9E%B6%E6%9E%84">2、Docker架构</h3> 
<p><strong>Docker 架构</strong></p> 
<ol><li>Docker 客户端 (Docker Client)</li><li>Docker 守护进程 (Docker Daemon)</li><li>Docker 镜像 (Docker Images)</li><li>Docker 容器 (Docker Containers)</li><li>Docker 仓库 (Docker Registry)</li><li>Docker Compose</li></ol> 
<p><strong>1. Docker 客户端 (Docker Client)</strong><br> Docker 客户端是用户与 Docker 进行交互的主要工具。它接收用户的命令，并通过 REST API 将命令发送给 Docker 守护进程。常用的 Docker 客户端命令包括 docker build、docker pull、docker run 等。</p> 
<p></p> 
<p><strong>2. Docker 守护进程 (Docker Daemon)</strong><br> Docker 守护进程在后台运行，负责处理 Docker 客户端的请求，管理 Docker 容器、镜像和网络。Docker 守护进程监听 Docker 客户端通过 REST API 发送的请求，并执行相应的操作。</p> 
<p></p> 
<p><strong>3. Docker 镜像 (Docker Images)</strong><br> Docker 镜像是一个包含应用程序及其依赖项的只读模板，用于创建 Docker 容器。镜像可以从 Docker Hub 下载，也可以通过编写 Dockerfile 来构建。Dockerfile 定义了如何构建一个镜像的步骤。</p> 
<p></p> 
<p><strong>4. Docker 容器 (Docker Containers)</strong><br> Docker 容器是镜像的一个运行实例，包含了应用程序及其所有依赖项，并在一个隔离的环境中运行。容器是轻量级的，启动速度快，可以在几秒钟内启动和停止。每个容器都有自己独立的文件系统、网络和进程空间。</p> 
<p></p> 
<p><strong>5. Docker 仓库 (Docker Registry)</strong><br> Docker 仓库用于存储和分发 Docker 镜像。Docker Hub 是最常用的公共仓库，用户可以从中下载和上传镜像。也可以使用私有的 Docker 仓库来存储镜像。</p> 
<p></p> 
<p><strong>6. Docker Compose</strong><br> Docker Compose 是一个用于定义和运行多容器 Docker 应用程序的工具。用户可以通过编写一个 docker-compose.yml 文件来定义应用程序的服务、网络和卷，然后使用 docker-compose up 命令来启动应用程序的所有服务。</p> 
<p class="img-center"><img alt="" height="730" src="https://images2.imgbox.com/36/7f/WuZJb1pj_o.png" width="1200"></p> 
<h3 id="3%E3%80%81Docker%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">3、Docker与工作原理</h3> 
<p>Docker 使用操作系统级别的虚拟化，通过 Linux 内核的 cgroups 和 namespaces 提供进程隔离和资源管理。</p> 
<ol><li><strong>Namespaces：</strong>Docker 使用 Linux namespaces 来提供隔离环境。每个容器运行在自己的命名空间中，包括进程ID (PID)、网络 (Network)、挂载 (Mount)、主机名 (Hostname)、用户 (User) 和进程 (Process) 等。这样可以确保容器内部的进程不会与其他容器或主机系统的进程相互干扰。</li><li><strong>Cgroups (Control Groups)：</strong>Docker 使用 cgroups 来限制和隔离容器使用的资源（如 CPU、内存、磁盘 I/O 和网络带宽）。cgroups 确保每个容器在资源使用上不会影响到其他容器或主机系统。</li><li><strong>Union File System (UnionFS)：</strong>Docker 镜像是由一系列的只读层组成的，UnionFS 将这些层联合在一起形成一个单一的文件系统。容器启动时，Docker 会为容器创建一个可写层，这个层位于所有只读层之上，使得容器可以对文件系统进行修改，而不会影响到镜像的只读层。</li></ol> 
<p>   </p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/3a/29/r4b3fkWH_o.png"></p> 
<h2 id="%E4%B8%89%E3%80%81Kubernetes%EF%BC%88k8s%EF%BC%89%E5%9F%BA%E7%A1%80">三、<strong>Kubernetes（k8s）基础</strong></h2> 
<h3 id="1%E3%80%81Kubernetes%E7%AE%80%E4%BB%8B"><strong>1、Kubernetes简介</strong></h3> 
<p><br> Kubernetes 是一个开源的平台，用来管理和编排容器化的应用程序。它可以自动化应用程序的部署、扩展和管理。简单来说，Kubernetes 帮助你把应用程序的运行从单个服务器扩展到多个服务器，同时保证高可用性和可伸缩性。</p> 
<p>想象一下，你有一个网站，它运行在一个服务器上。这个服务器有时会崩溃，或者你的网站突然变得很受欢迎，服务器处理不过来。为了确保网站一直能运行，而且可以应对更多的访问量，你决定多准备几台服务器，这样即使一台服务器出问题了，其他的服务器也能接着运行网站。这时候你需要一个智能管家，帮你管理这些服务器，让网站始终高效、可靠地运行。这个智能管家就是 Kubernetes。</p> 
<p class="img-center"><img alt="" height="538" src="https://images2.imgbox.com/a5/cb/2upx8Q05_o.png" width="801"></p> 
<h3 id="2%E3%80%81Kubernetes%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5">2、Kubernetes核心概念</h3> 
<p><span style="color:#4d4d4d;"><strong>1. 集群（Cluster）</strong></span></p> 
<ul><li><span style="color:#4d4d4d;">集群是 Kubernetes 管理的基础单元，包含多个节点（Node）。集群内的所有节点共同工作来运行和管理应用程序。</span></li></ul> 
<p><br><span style="color:#4d4d4d;"><strong>2. 节点（Node）</strong></span></p> 
<ul><li>节点是集群中的一台物理机器或虚拟机，每个节点运行容器。节点由主节点（Master Node）管理，包含 Kubelet 代理，负责与主节点通信和运行 Pod。</li><li><span style="color:#4d4d4d;"><strong>工作节点（Worker Node）</strong>运行实际的应用容器。</span></li><li><span style="color:#4d4d4d;"><strong>主节点（Master Node）</strong>负责集群的管理和调度，包括 API Server、Controller Manager、Scheduler 和 etcd 数据库。</span></li></ul> 
<p><br><span style="color:#4d4d4d;"><strong>3. Pod</strong></span></p> 
<ul><li>Pod是 Kubernetes 中最小的部署单元，一个 Pod 可以包含一个或多个容器，这些容器共享网络、存储和命名空间。</li><li><span style="color:#4d4d4d;">多容器 Pod通常用于需要紧密耦合的应用场景，比如主从结构、日志收集器等。</span></li></ul> 
<p><br><span style="color:#4d4d4d;"><strong>4. 控制器（Controller）</strong></span></p> 
<ul><li>控制器负责管理集群的状态，确保集群的实际状态与期望状态一致。常见的控制器有：</li><li><span style="color:#4d4d4d;"><strong>Deployment：</strong>管理无状态应用的部署和升级。</span></li><li><span style="color:#4d4d4d;"><strong>StatefulSet：</strong>管理有状态应用的部署和升级，确保每个 Pod 都有唯一的身份。</span></li><li><span style="color:#4d4d4d;"><strong>DaemonSet：</strong>在每个节点上运行一个 Pod，常用于日志收集和监控。</span></li><li><span style="color:#4d4d4d;"><strong>Job和CronJob：</strong>分别用于一次性任务和定时任务。</span></li></ul> 
<p><br><span style="color:#4d4d4d;"><strong>5. 服务（Service）</strong></span></p> 
<ul><li>服务为一组 Pod 提供稳定的网络端点，通过标签选择器（Label Selector）来定义服务的范围。服务负责负载均衡，并提供 DNS 名称解析，使得 Pod 可以通过服务名进行访问。</li><li><span style="color:#4d4d4d;"><strong>ClusterIP：</strong>默认类型，提供集群内部访问。</span></li><li><span style="color:#4d4d4d;"><strong>NodePort：</strong>通过节点 IP 和端口号提供外部访问。</span></li><li><span style="color:#4d4d4d;"><strong>LoadBalancer：</strong>在云环境中使用云提供商的负载均衡器。</span></li></ul> 
<p><br><span style="color:#4d4d4d;"><strong>6. 配置和存储（ConfigMap 和 Secret）</strong></span></p> 
<ul><li>ConfigMap用于存储非机密的配置信息，以键值对形式存储，可以在 Pod 中挂载为环境变量或配置文件。</li><li><span style="color:#4d4d4d;">Secret用于存储机密信息，比如密码、OAuth 令牌，可以在 Pod 中挂载为环境变量或配置文件。</span></li></ul> 
<p><br><span style="color:#4d4d4d;"><strong>7. 持久存储（PersistentVolume 和 PersistentVolumeClaim）</strong></span></p> 
<ul><li>PersistentVolume（PV）是集群中的存储资源，独立于 Pod 的生命周期。</li><li><span style="color:#4d4d4d;">PersistentVolumeClaim（PVC）是 Pod 对存储资源的请求，PVC 会绑定到 PV 上，Pod 使用 PVC 来挂载存储卷。</span></li></ul> 
<p><br><span style="color:#4d4d4d;"><strong>8. 命名空间（Namespace）</strong></span></p> 
<ul><li><span style="color:#4d4d4d;">命名空间用于将集群内的资源进行逻辑分组和隔离，不同命名空间内的资源可以重名，适用于多租户环境或项目隔离。</span></li></ul> 
<p><br><span style="color:#4d4d4d;"><strong>9. Ingress</strong></span></p> 
<ul><li><span style="color:#4d4d4d;">Ingress是管理外部访问到集群内服务的规则，通过 HTTP/HTTPS 提供路由功能。Ingress 可以配置负载均衡、SSL 终止、基于主机名和路径的路由等功能。</span></li></ul> 
<p>   </p> 
<p class="img-center"><img alt="" height="1059" src="https://images2.imgbox.com/33/ff/fEX4Vw85_o.png" width="1200"></p> 
<blockquote> 
 <p>  💕💕💕每一次的分享都是一次成长的旅程，感谢您的陪伴和关注。希望这些关于云原生的文章能陪伴您走过技术的一段旅程，共同见证成长和进步！😺😺😺</p> 
 <p></p> 
 <p>🧨🧨🧨让我们一起在技术的海洋中探索前行，共同书写美好的未来！！！ </p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8d7accd5cf6042d1fce18e99f2229fa5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【数据结构】【版本1.4】【线性时代】——队列</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9bd5243fbdf99fb7a52161ce9dd938c7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java项目：基于SSM框架实现的电子竞技管理平台【ssm&#43;B/S架构&#43;源码&#43;数据库&#43;毕业论文】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>