<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>电路布线问题动态规划详解（做题思路） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/b720882cc3ec733533cc79fd6e27a64d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="电路布线问题动态规划详解（做题思路）">
  <meta property="og:description" content="对于电路布线问题，想必学过动态规划的大家都很清除。今天就来讲解一下这个动态规划经典题目。
目录 问题描述输入分析最优子结构代码 问题描述 在一块电路板的上、下2端分别有n个接线柱。根据电路设计，要求用导 线(i,π(i))将上端接线柱与下端接线柱相连，如图所示。其中π(i)是 {1,2,…,n}的一个排列。导线(i,π(i))称为该电路板上的第i条连线。对于任 何1≤i&lt;j≤n，第i条连线和第j条连线相交的充分且必要的条件是π(i)&gt;π(j)。 电路布线问题要确定将哪些连线安排在第一层上，使得该层上有尽可能 多的连线。换句话说，该问题要求确定导线集Nets={(i,π(i)),1≤i≤n}的最 大不相交子集。
输入 两行输入
第一行是一排接线柱的个数
第二行是上接线柱对应的下接线柱位置，即下文的p(i)
对于上图输入就是
10
3 1 2 4 7 9 5 6 10 8
分析 那么什么是最大不相交子集呢。咱们来一个一个字 的 扣含义。
首先最大就是字面意思最大的，最多的。
其次不相交也是字面意思，就是单纯的两条线不能有交点。
最后子集的定义是如果集合A的任意一个元素都是集合B的元素，那么集合A称为集合B的子集（通俗点说就是在给出的导线集合里面，挑选几条导线，这挑选的导线组成的集合就是子集）。
那么组合起来说的就是，在现有的线中挑选数量最多的导线且它们还不相交
我们发现这个题，好像不能从考虑最后一个步骤来推导了，我们好像还真不太好找出最后一个问题是什么。那么我们就换一种思路，回想以前的动态规划好像都是在数组中记录数值，供以后使用的而且都是一行一行的计算子问题。那我们先定义一个数组，考虑到有上下两排线，那就定义二维数组吧.。
设dp[i][j]表示前i个上接线柱和前j个下接线柱组成的问题的最优解包含的导线的数量(即前i个上接线柱和前j个下接线柱组成的集合的最大不相交子集中包含的导线数)
为了方便说明再来定义一些规则：
上接线柱集合（1，2，3，4…n）
下接线柱集合（p(1),p(2),p(3),p(4)…p(n)）
p(n)代表上层接线柱n对应的下层接线柱的编号。例如下图中上接线柱1，p(1)就是3
接下来以上图为例先从第一行来看，来找一下规律触发一下灵感
(第1步) i=1，j=1
(第2步) i=1，j=2
(第3步) i=1，j=3
唉突然发现此时，增加了一个，那就来想一想是什么原因让他增加的呢。我们发现当j&gt;=p(1)时他就增加了，接下来继续看。
(第4步) i=1，j=3
然后类似的一直到 j==10 的时候
… …
(第10步) i=1，j=10
发现第一行除了j==3的时候增加了一个，其他的j&gt;=p(1)的情况并没有增加为什么会这样呢？思考一下。因为我们的i是等于1的所以我们的dp[1][j]他最多只有一条线，我们上接线柱只包含了一个，所以他只能是小于等于一的数
这就给我们一个灵感我们可以根据i,p(i)的关系进行动态规划列出可能的情况加以分析
1.考虑当 i =1的时候
（1）j&lt;p(i):肯定是零
（2）j&gt;=p(i):他也肯定是一，因为这时最优解里面是空的，不用考虑香蕉🍌 （相交）的情况
2.考虑当 i&gt;1时
（1）j&lt;p(i):这时肯定还是不能包含这一条导线的，因为这一条导线的下接线柱没有被包含前 j 个里面。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-11-08T22:02:55+08:00">
    <meta property="article:modified_time" content="2023-11-08T22:02:55+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">电路布线问题动态规划详解（做题思路）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>对于电路布线问题，想必学过动态规划的大家都很清除。今天就来讲解一下这个动态规划经典题目。<br> </p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><ul><li><a href="#_2" rel="nofollow">问题描述</a></li><li><a href="#_6" rel="nofollow">输入</a></li><li><a href="#_13" rel="nofollow">分析</a></li><li><a href="#_66" rel="nofollow">最优子结构</a></li><li><a href="#_81" rel="nofollow">代码</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_2"></a>问题描述</h3> 
<p>在一块电路板的上、下2端分别有n个接线柱。根据电路设计，要求用导 线(i,π(i))将上端接线柱与下端接线柱相连，如图所示。其中π(i)是 {1,2,…,n}的一个排列。导线(i,π(i))称为该电路板上的第i条连线。对于任 何1≤i&lt;j≤n，第i条连线和第j条连线相交的充分且必要的条件是π(i)&gt;π(j)。 电路布线问题要确定将哪些连线安排在第一层上，使得该层上有尽可能 多的连线。换句话说，该问题要求确定导线集Nets={(i,π(i)),1≤i≤n}的最 大不相交子集。<br> <img src="https://images2.imgbox.com/7f/bb/s9Eix75v_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_6"></a>输入</h3> 
<p>两行输入<br> 第一行是一排接线柱的个数<br> 第二行是上接线柱对应的下接线柱位置，即下文的p(i)<br> 对于上图输入就是<br> 10<br> 3 1 2 4 7 9 5 6 10 8</p> 
<h3><a id="_13"></a>分析</h3> 
<p>那么什么是最大不相交子集呢。咱们来<s>一个一个字 的</s> 扣含义。<br> 首先<strong>最大</strong>就是字面意思最大的，最多的。<br> 其次<strong>不相交</strong>也是字面意思，就是单纯的两条线不能有交点。<br> 最后<strong>子集</strong>的定义是<strong>如果集合A的任意一个元素都是集合B的元素，那么集合A称为集合B的子集</strong>（通俗点说就是在给出的导线集合里面，挑选几条导线，这挑选的导线组成的集合就是子集）。<br> 那么组合起来说的就是，<em><strong>在现有的线中挑选数量最多的导线且它们还不相交</strong></em></p> 
<p>我们发现这个题，好像不能从考虑最后一个步骤来推导了，我们好像还真不太好找出最后一个问题是什么。那么我们就换一种思路，回想以前的动态规划好像都是在数组中记录数值，供以后使用的而且都是一行一行的计算子问题。那我们先定义一个数组，考虑到有上下两排线，那就定义二维数组吧.。<br> <strong>设dp[i][j]表示前i个上接线柱和前j个下接线柱组成的问题的最优解包含的导线的数量</strong><s>(即前i个上接线柱和前j个下接线柱组成的集合的最大不相交子集中包含的导线数)</s></p> 
<p><strong>为了方便说明再来定义一些规则</strong>：<br> 上接线柱集合（1，2，3，4…n）<br> 下接线柱集合（p(1),p(2),p(3),p(4)…p(n)）<br> p(n)代表上层接线柱n对应的下层接线柱的编号。<strong>例如下图中上接线柱1，p(1)就是3</strong></p> 
<p><img src="https://images2.imgbox.com/d3/d4/Bjco1974_o.png" alt="在这里插入图片描述"></p> 
<p>接下来<strong>以上图为例</strong>先从第一行来看，来找一下规律触发一下灵感<br> <strong>(第1步)</strong> i=1，j=1</p> 
<p><img src="https://images2.imgbox.com/cb/9b/nX2VUVuf_o.png" alt="在这里插入图片描述"><br> <strong>(第2步)</strong> i=1，j=2</p> 
<p><img src="https://images2.imgbox.com/e9/d8/ilsUXqC2_o.png" alt="在这里插入图片描述"><br> <strong>(第3步)</strong> i=1，j=3</p> 
<p><img src="https://images2.imgbox.com/43/06/MDu23VDE_o.png" alt="在这里插入图片描述"><br> 唉突然发现此时，增加了一个，那就来想一想是什么原因让他增加的呢。我们发现当<strong>j&gt;=p(1)时他就增加了</strong>，接下来继续看。<br> <strong>(第4步)</strong> i=1，j=3</p> 
<p>然后类似的一直到 <strong>j==10</strong> 的时候<br> … …</p> 
<p><strong>(第10步)</strong> i=1，j=10<br> <img src="https://images2.imgbox.com/12/5f/5iq4zl4T_o.png" alt="在这里插入图片描述"><br> 发现第一行除了j==3的时候增加了一个，其他的j&gt;=p(1)的情况并没有增加为什么会这样呢？思考一下。<strong>因为我们的i是等于1的所以我们的dp[1][j]他最多只有一条线，我们上接线柱只包含了一个，所以他只能是小于等于一的数</strong></p> 
<p>这就给我们一个灵感我们可以根据i,p(i)的关系进行动态规划列出可能的情况加以分析</p> 
<p>1.<strong>考虑当 i =1的时候</strong><br> （1）<strong>j&lt;p(i)</strong>:肯定是零<br> （2）<strong>j&gt;=p(i)</strong>:他也肯定是一，因为这时最优解里面是空的，不用考虑<s><s>香蕉🍌</s></s> （相交）的情况<br> 2.<strong>考虑当 i&gt;1时</strong><br> （1）<strong>j&lt;p(i)</strong>:这时肯定还是不能包含这一条导线的，因为这一条导线的下接线柱没有被包含前 j 个里面。<br> <strong>那么这时他就相当于dp[i-1][j]。</strong> 为什么这么说呢？因为在j&lt;p(i)时这一条导线是不可能被包含在我们的最优解里面的，所以就相当与这一条导线（i 导线）对于我们的当前的解是没有任何作用的。他就相当于是前 i -1个上接线柱和前 j 个下接线柱构成的问题的最优解。<br> <strong>也许此时聪明好学的你会问那为什么不是dp[i-1][j-1]呢？（即为什么不是前 i -1个上接线柱和前 j -1 个下接线柱构成的问题的最优解呢？。）</strong><br> 此时我们直接举一个一针见血的例子，如果i-1的下接线柱是 j 呢？dp[i-1][j-1]是不是就把第i-1条导线给漏掉了。<br> （2）<strong>j&gt;=p(i):</strong> 这时候就说明我们<strong>可以</strong>包含这个导线，<mark>注意</mark>我说的是<mark>可以</mark>包含而不是一定包含。那么包含的条件是什么呢？想必你肯定已经知道了，就是当这条导线与最优解里面的<strong>导线都</strong>不香蕉🍌的时候 <strong>且</strong> <strong>包含这个导线的最优解的个数比不包含这条导线的个数要大</strong>的时候才会包含 <strong>（dp[i][j]=Math.max(dp[i-1][p[i]-1]+1,dp[i-1][j])）</strong> 。而相交的时候就不可以包含了（<strong>dp[i][j]=dp[i-1][j]</strong>）。</p> 
<h3><a id="_66"></a>最优子结构</h3> 
<p>1.<strong>对与i&lt;1的时候肯定是满足的</strong>，因为他的子问题不就是空的集合吗。<br> 2.<strong>对于i&gt;1的时候</strong><br> （1）<strong>j&lt;p(i)</strong> 它的最优解所包含的导线个数是是子问题的最优解dp[i-1][j]。假设子问题的最优解不是dp[i-1][j]而是R那么R&gt;dp[i-1][j]所以原问题的最优解应该是R，这就矛盾了。<br> （2）<strong>j&gt;=p(i)</strong> 的时候他的子问题是<strong>选择</strong>这一条导线（dp[i-1][p[i]-1]+1）或则<strong>不选</strong>这一条导线（dp[i][j]=dp[i-1][j]）这两个中的最大值。对于不选择和上面的证明是一样的。<br> <strong>这里证明一下选择的情况：</strong><br> <strong>在证明之前先了解一下子问题为什么是这个集合</strong>（前i-1个上接线柱，前p[i]-1个下接线柱）而不是其他的集合（例如前i-1个上接线柱，前j个下接线柱）。<br> 我们既然选择了这一个导线就说明这个导线是不会与最优解里面的导线相交的。dp[i-1][p[i]-1]是<strong>前i-1个上接线柱，前p[i]-1个下接线柱</strong> 组成的解。我们的这一条导线对应的接线柱是i和p[i]。i&gt;i-1且p[i]&gt;p[i]-1所以他是这个集合中的最后一条线。就好比上图中的前4条导线，4是最后一条所以他肯定不<br> 会与前三条相交的。</p> 
<p><img src="https://images2.imgbox.com/ab/4c/DGMxGK7s_o.png" alt="在这里插入图片描述"></p> 
<p>差不多理解了，就来证明最优子结构：<br> 如果dp[i-1][p[i]-1]不是子问题的最优，最优的是R那么R+1&gt;dp[i-1][p[i]-1]+1,所以由子问题构成的原问题的最优解应该是R+1而不是dp[i-1][p[i]-1]</p> 
<h3><a id="_81"></a>代码</h3> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Scanner</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AD</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">MSN</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

                <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

                    <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>

                    <span class="token punctuation">}</span>

                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>

                    <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>

                <span class="token punctuation">}</span>

            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        <span class="token class-name">Scanner</span> scanner<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> n<span class="token operator">=</span>scanner<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>scanner<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">//        System.out.println(dp[n][n]);</span>
        <span class="token function">MSN</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>p<span class="token punctuation">,</span>dp<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5b85cca1193dbfd0bd8a934e4c59bdb5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据结构-单链表</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d684bd5dc9fc3b905ab0be17d77d9939/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python中的链表：手把手教你实现基本操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>