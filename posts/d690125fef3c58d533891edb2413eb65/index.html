<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【面试题】马上金九银十了，简历该准备起来了，面试题你准备好了吗 ？浅谈 JS 浅拷贝和深拷贝 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/d690125fef3c58d533891edb2413eb65/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【面试题】马上金九银十了，简历该准备起来了，面试题你准备好了吗 ？浅谈 JS 浅拷贝和深拷贝">
  <meta property="og:description" content="代码展示
let obj_old = { name: &#39;Tom&#39;, age: 15, favorite: { food: &#39;bread&#39;, drink: &#39;milk&#39; } } let obj_new = {...obj_old} console.log(obj_old === obj_new) // false console.log(obj_old.name === obj_new.name) // true console.log(obj_old.favorite === obj_new.favorite) // true 3. Array.prototype.concat()
语法：arr.concat(value0, /* … ,*/ valueN)
注：如果省略了所有 valueN 参数，则 concat 会返回调用此方法的现存数组的一个浅拷贝。
代码展示
let arr_old = [1, 2, {name: &#39;Tom&#39;}] let arr_new = arr_old.concat() console.log(arr_old === arr_new) // false console.log(arr_old.name === arr_new.name) // true 4.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-24T22:06:50+08:00">
    <meta property="article:modified_time" content="2024-06-24T22:06:50+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【面试题】马上金九银十了，简历该准备起来了，面试题你准备好了吗 ？浅谈 JS 浅拷贝和深拷贝</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote></blockquote> 
<p>代码展示</p> 
<pre><code>let obj_old = {
    name: 'Tom',
    age: 15,
    favorite: {
        food: 'bread',
        drink: 'milk'
    }
}
let obj_new = {...obj_old}
console.log(obj_old === obj_new)  // false
console.log(obj_old.name === obj_new.name)  // true
console.log(obj_old.favorite === obj_new.favorite)  // true

</code></pre> 
<p>3. <em>Array.prototype.concat()</em></p> 
<blockquote> 
 <p>语法：arr.concat(value0, /* … ,*/ valueN)</p> 
 <p>注：如果省略了所有 <code>valueN</code> 参数，则 <code>concat</code> 会返回调用此方法的现存数组的一个浅拷贝。</p> 
</blockquote> 
<p>代码展示</p> 
<pre><code>let arr_old = [1, 2, {name: 'Tom'}]
let arr_new = arr_old.concat()
console.log(arr_old === arr_new)  // false
console.log(arr_old.name === arr_new.name)  // true

</code></pre> 
<p>4. <em>Array.prototype.slice()</em></p> 
<blockquote> 
 <p>语法：arr.slice(begin, end)</p> 
 <p>注：如果省略了 <code>begin</code>, <code>end</code> 参数，则 <code>slice</code> 会返回调用此方法的现存数组的一个浅拷贝。</p> 
</blockquote> 
<p>代码展示</p> 
<pre><code>let arr_old = [1, 2, {name: 'Tom'}]
let arr_new = arr_old.slice()
console.log(arr_old === arr_new)  // false
console.log(arr_old.name === arr_new.name)  // true

</code></pre> 
<h4><a id="_75"></a>🌄深拷贝</h4> 
<p>接下来说深拷贝</p> 
<p>深拷贝就是在堆内存中开辟一个新的空间存放新对象，拷贝原对象的所有属性，拷贝前后两个对象互不影响</p> 
<p>深拷贝的新旧对象不共享内存</p> 
<p><img src="https://images2.imgbox.com/24/fe/E1tbWuZa_o.png" alt=""></p> 
<p>这时我们去修改新对象中的任意层级的任意属性值，都不会对原对象产生影响，原对象依然保持不变</p> 
<p><strong>举个栗子</strong>🌰</p> 
<pre><code>let obj_old = {
  name: 'Tom',
  age: 15,
  hobby: ['eat', 'game'],
  favorite: {
      food: 'bread',
      drink: {
        dname: 'milk',
        color: 'white',
      },
  }
}
let obj_new = _.cloneDeep(obj_old)
console.log(obj_old)
console.log(obj_new)
console.log(obj_old.name === obj_new.name)
console.log(obj_old.favorite === obj_new.favorite)
console.log(obj_old.favorite.drink === obj_new.favorite.drink)

</code></pre> 
<p>这里我们使用了<code>lodash</code>工具库提供的<code>_.cloneDeep</code>深拷贝方法,来看一下新旧对象的对比</p> 
<p><img src="https://images2.imgbox.com/7c/f4/ezzTTB1U_o.png" alt=""></p> 
<p>可以看见新旧对象所有属性及属性值完全相同</p> 
<p>那再来细节对比一下，看看拷贝后对象的地址是否相同</p> 
<p><img src="https://images2.imgbox.com/d2/03/3xZwmImn_o.png" alt=""></p> 
<blockquote> 
 <p>obj_old.name === obj_new.name为true，这个是基本数据类型，完全相同，没有问题</p> 
</blockquote> 
<blockquote> 
 <p>obj_old.favorite === obj_new.favorite，这里为false，到这里就和浅拷贝不同了，浅拷贝到这一层的时候，对象属性的地址是相同的，而深拷贝是完全拷贝出一个新的对象，所以不管是哪一层，对象属性的地址都是不同的</p> 
</blockquote> 
<blockquote> 
 <p>obj_old.favorite.drink === obj_new.favorite.drink为false，再往深一层仍然是false，即地址不相同</p> 
</blockquote> 
<p>那再来修改一下属性值，看看前后对比</p> 
<pre><code>obj_new.name = 'Jerry'
obj_new.hobby[0] = 'sing'
obj_new.favorite.food = 'cheese'

</code></pre> 
<p><img src="https://images2.imgbox.com/11/d7/iHBGvgNG_o.png" alt=""></p> 
<p>修改属性值之后，新旧对象是互不影响的</p> 
<h5><a id="_175"></a>🏷️深拷贝的方法</h5> 
<p>那么现在就来罗列几个深拷贝的方法</p> 
<p>1. <em>递归实现</em></p> 
<p>使用递归实现原对象每一层的拷贝，当遇到基本数据类型时，直接拷贝，遇到引用数据类型时，递归拷贝它的每个属性</p> 
<p>代码展示</p> 
<pre><code>const obj_old = {
  name: 'Tom',
  age: 15,
  hobby: ['eat', 'game'],
  favorite: {
      food: 'bread',
      drink: {
        dname: 'milk',
        color: 'white',
      },
  }
}
const obj_new = {}

function deepClone(newObj, oldObj){
  for (const key in oldObj) {
    if (oldObj[key] instanceof Object) {
      newObj[key] = {}
      deepClone(newObj[key], oldObj[key])
    } else if (oldObj[key] instanceof Array) {
      newObj[key] = []
      deepClone(newObj[key], oldObj[key])
    } else {
      newObj[key] = oldObj[key]
    }
  }
}

deepClone(obj_new, obj_old)

console.log(obj_old)
console.log(obj_new)
console.log(obj_old.name === obj_new.name)
console.log(obj_old.favorite === obj_new.favorite)
console.log(obj_old.favorite.drink === obj_new.favorite.drink)

</code></pre> 
<p>测试结果</p> 
<p><img src="https://images2.imgbox.com/0f/67/hl8r0u3Z_o.png" alt=""></p> 
<p>2. <em>lodash工具包</em></p> 
<p><a href="" rel="nofollow">点这里去lodash的中文文档</a></p> 
<p>引入成功后，我们直接使用lodash提供给我们的函数_.cloneDeep就行</p> 
<p>代码展示</p> 
<pre><code>let obj_old = {
  name: 'Tom',
  age: 15,
  hobby: ['eat', 'game'],
  favorite: {
      food: 'bread',
      drink: {
        dname: 'milk',
        color: 'white',
      },
  }
}
let obj_new = _.cloneDeep(obj_old)

console.log(obj_old)
console.log(obj_new)
console.log(obj_old.name === obj_new.name)
console.log(obj_old.favorite === obj_new.favorite)
console.log(obj_old.favorite.drink === obj_new.favorite.drink)

</code></pre> 
<p>测试结果</p> 
<p><img src="https://images2.imgbox.com/3a/b0/s73SANZk_o.png" alt=""></p> 
<p>3. <em>JSON.parse(JSON.stringify(obj))</em></p> 
<p><code>JSON.stringify()</code> 将JSON格式的对象转为字符串</p> 
<p><code>JSON.parse()</code> 将JSON格式的字符串转为对象</p> 
<p>代码展示</p> 
<pre><code>const obj_old = {
  name: 'Tom',
  age: 15,
  hobby: ['eat', 'game'],
  favorite: {
      food: 'bread',
      drink: {
        dname: 'milk',
        color: 'white',
      },
  }
}
const obj_new = JSON.parse(JSON.stringify(obj_old))

console.log(obj_old)
console.log(obj_new)
console.log(obj_old.name === obj_new.name)
console.log(obj_old.favorite === obj_new.favorite)
console.log(obj_old.favorite.drink === obj_new.favorite.drink)

</code></pre> 
<p>测试结果</p> 
<p><img src="https://images2.imgbox.com/a3/1c/0bi8NuVi_o.png" alt=""></p> 
<p>❣️虽然这个方法最简单，代码行数最少，但是它也有一定的缺陷：</p> 
<ol><li>拷贝对象的值中如果有‘函数’，‘undefined’，‘symbol’ JSON.stringify()序列化后，键值对丢失</li><li>拷贝RegExp会变成空对象{}</li><li>对象中含有‘NaN’，‘Infinity’会变成null</li><li>拷贝Date会变成字符串</li></ol> 
<h4><a id="_329"></a>🏝️结语</h4> 
<p>其实前端开发的知识点就那么多，面试问来问去还是那么点东西。所以面试没有其他的诀窍，只看你对这些知识点准备的充分程度。so，出去面试时先看看自己复习到了哪个阶段就好。</p> 
<p>这里再分享一个复习的路线：（以下体系的复习资料是我从各路大佬收集整理好的）</p> 
<p>《前端开发四大模块核心知识笔记》</p> 
<p><img src="https://images2.imgbox.com/57/af/F5uCCIAH_o.png" alt=""></p> 
<p>最后，说个题外话，我在一线互联网企业工作十余年里，指导过不少同行后辈。帮助很多人得到了学习和成长。</p> 
<p>我意识到有很多经验和知识值得分享给大家，也可以通过我们的能力和经验解答大家在IT学习中的很多困惑，所以在工作繁忙的情况下还是坚持各种整理和分享。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/32b20bffd3c5d261ee17362dad0f440b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Django模板</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6a54fe5e03a123f3a9642057b64509ab/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何在 macOS 上安装 Docker Desktop</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>