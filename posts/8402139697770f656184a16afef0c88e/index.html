<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>系统架构设计师 - 软件工程(3) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/8402139697770f656184a16afef0c88e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="系统架构设计师 - 软件工程(3)">
  <meta property="og:description" content="软件工程 软件工程（13-22分）非常重要软件测试测试方法动态测试【计算机运行】静态测试【纯人工】 测试阶段集成测试策略系统测试 面向对象的测试（了解） 软件调试系统转换计划遗留系统演化策略新旧系统转换策略数据转换与迁移 系统运行与软件维护 大家好呀！我是小笙，本章我主要分享系统架构设计师 - 软件工程(3)知识，希望内容对你有所帮助！！
软件工程（13-22分）非常重要 软件测试 测试方法 动态测试【计算机运行】 黑盒测试法（一种软件测试方法，主要关注于软件系统的功能和行为，而不是其内部结构或实现细节） 等价类划分：将所有可能的输入划分为若干个等价类，每个等价类代表了一类相似的输入边界值分析：测试输入的边界值和临近值错误推测：基于对系统可能出现错误的经验和直觉，设计测试用例以发现潜在的错误状态测试法：测试系统在各种状态之间转换的行为 白盒测试法（一种软件测试方法，专注于测试软件的内部逻辑和结构，而不仅仅是其功能） 语句覆盖：确保每一条语句都被执行至少一次分支覆盖：测试所有可能的分支路径，以确保每个分支条件都被执行至少一次路径覆盖：测试所有可能的路径组合，包括不同的分支和循环条件覆盖：确保每个条件在所有可能的情况下都被测试到 灰盒测试法（黑盒 &#43; 白盒） 集成测试：测试系统各个组件的交互和集成效果，确保它们协同工作接口测试：检查系统组件或模块之间的接口是否按预期工作，验证数据交换的准确性功能测试：测试系统的功能是否符合需求，通常基于已有的部分内部知识设计测试用例 静态测试【纯人工】 静态代码分析：使用静态分析工具对源代码进行分析，识别编程错误、资源泄漏、死代码等问题代码审查：开发者互相检查代码，确保代码质量，遵循编码规范，并识别潜在的错误或改进点（类似代码走查）文档审查： 审查文档是否清晰、准确地描述了系统需求和设计，确保其符合项目标准和需求桌面检查：对开发或测试环境的检查，确保所有必需的工具、文档和资源都在正确的位置，并且没有遗漏或配置错误 例题
1、软件测试一般分为两个大类：动态测试和静态测试。前者通过运行程序发现错误，包括 边界值分析、逻辑覆盖、基本路径 等方法；后者采用人工和计算机辅助静态分析的手段对程序进行检测，包括 桌面检查、代码审查、代码走查 等方法
边界值分析、逻辑覆盖、基本路径桌面检查、逻辑覆盖、错误推测桌面检查、代码审查、代码走查错误推测、代码审查、基本路径 测试阶段 单元测试：模块测试，模块功能、性能、接口等集成测试：模块间的接口系统测试：真实环境下，验证完整的软件配置项能否和系统正确连接确认测试：验证软件与需求的一致性。内部确认测试、Alpha测试、Beta测试、验收测试回归测试：测试软件变更之后，变更部分的正确性对变更需求的符合性 集成测试策略 一次性组装（风险高）
增量式组装（测试全面）
自顶向下（需要桩模块）自底向上（需要驱动模块）混合式 系统测试 功能测试性能测试 负载测试：各种工作负载下系统的性能压力测试：系统的瓶颈或不能接受的性能点强度测试：系统资源特别低的情况下运行容量测试【并发测试】：同时在线的最大用户数可靠性测试：MTTF之类的参数 健壮性测试用户界面测试安全性测试安装与反安装测试 例题
1、在单元测试中，驱动模块用来调用被测模块，自顶向下的单元测试中不需要另外编写驱动模块
驱动模块用来调用被测模块，自顶向下的单元测试中不需要另外编写驱动模块桩模块用来模拟被测模块所调用的子模块，自顶向下的单元测试中不需要另外编写桩模块驱动模块用来模拟被测模块所调用的子模块，自底向上的单元测试中不需要另外编写驱动模块桩模块用来调用被测模块，自底向上的单元测试中不需要另外编写桩模块 2、软件性能测试有多种不同类型的测试方法，其中，强度测试 用于测试在限定的系统下考查软件系统极限运行的情况，容量测试 可用于测试系统同时处理的在线最大用户数量
强度测试 负载测试 压力测试 容量测试 面向对象的测试（了解） 算法层（单元测试）：包括等价类划分测试、组合功能测试（基于判定表的测试）、递归函数测试和多态消息测试类层（模块测试）：包括不变式边界测试、模态类测试和非模态类测试模板层/类树层（集成测试）：包括多态服务测试和展平测试系统层（系统测试） 软件调试 蛮力法：主要思想是“通过计算机找错”，低效，耗时回溯法：从出错处人工沿控制流程往回追踪，直至发现出错的根源。复杂程序由于回溯路径多，难以实施原因排除法：主要思想是演绎和归纳，用二分法实现 软件测试 VS 软件调试
软件测试软件调试目的是找出存在的错误目的是定位错误并修改程序以修正错误从一个已知的条件开始，使用预先定义的过程，有预知的结果从一个未知的条件开始，结束的过程不可预计测试过程可以事先设计，进度可以事先确定调试不能描述过程或持续时间 系统转换计划 遗留系统演化策略 例题
1、遗留系统的演化可以采用淘汰、继承、改造和集成四种策略。若企业中的遗留系统技术含量较高，业务价值较低，在局部领域中工作良好，形成了一个个信息孤岛时，适合于采用 集成 演化策略
淘汰继承改造集成 新旧系统转换策略 直接转换策略（把现有系统下线，新系统然后上线）并行转换策略分段转换策略 数据转换与迁移 旧数据库 -&gt; 抽取 -&gt; 转换 -&gt; 装载 -&gt; 新数据库">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-22T09:55:11+08:00">
    <meta property="article:modified_time" content="2024-08-22T09:55:11+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">系统架构设计师 - 软件工程(3)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>软件工程</h4> 
 <ul><li><a href="#1322_5" rel="nofollow">软件工程（13-22分）非常重要</a></li><li><ul><li><a href="#_6" rel="nofollow">软件测试</a></li><li><ul><li><a href="#_8" rel="nofollow">测试方法</a></li><li><ul><li><a href="#_10" rel="nofollow">动态测试【计算机运行】</a></li><li><a href="#_27" rel="nofollow">静态测试【纯人工】</a></li></ul> 
    </li><li><a href="#_43" rel="nofollow">测试阶段</a></li><li><ul><li><a href="#_51" rel="nofollow">集成测试策略</a></li><li><a href="#_63" rel="nofollow">系统测试</a></li></ul> 
    </li><li><a href="#_90" rel="nofollow">面向对象的测试（了解）</a></li></ul> 
   </li><li><a href="#_99" rel="nofollow">软件调试</a></li><li><a href="#_115" rel="nofollow">系统转换计划</a></li><li><ul><li><a href="#_117" rel="nofollow">遗留系统演化策略</a></li><li><a href="#_130" rel="nofollow">新旧系统转换策略</a></li><li><a href="#_136" rel="nofollow">数据转换与迁移</a></li></ul> 
   </li><li><a href="#_142" rel="nofollow">系统运行与软件维护</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<p><em><strong>大家好呀！我是小笙，本章我主要分享系统架构设计师 - 软件工程(3)知识，希望内容对你有所帮助！！</strong></em></p> 
<h2><a id="1322_5"></a>软件工程（13-22分）非常重要</h2> 
<h3><a id="_6"></a>软件测试</h3> 
<h4><a id="_8"></a>测试方法</h4> 
<h5><a id="_10"></a>动态测试【计算机运行】</h5> 
<ul><li><strong>黑盒测试法</strong>（一种软件测试方法，主要关注于软件系统的功能和行为，而不是其内部结构或实现细节） 
  <ul><li>等价类划分：将所有可能的输入划分为若干个等价类，每个等价类代表了一类相似的输入</li><li>边界值分析：测试输入的边界值和临近值</li><li>错误推测：基于对系统可能出现错误的经验和直觉，设计测试用例以发现潜在的错误</li><li>状态测试法：测试系统在各种状态之间转换的行为</li></ul> </li><li><strong>白盒测试法</strong>（一种软件测试方法，专注于测试软件的内部逻辑和结构，而不仅仅是其功能） 
  <ul><li>语句覆盖：确保每一条语句都被执行至少一次</li><li>分支覆盖：测试所有可能的分支路径，以确保每个分支条件都被执行至少一次</li><li>路径覆盖：测试所有可能的路径组合，包括不同的分支和循环</li><li>条件覆盖：确保每个条件在所有可能的情况下都被测试到</li></ul> </li><li><strong>灰盒测试法</strong>（黑盒 + 白盒） 
  <ul><li>集成测试：测试系统各个组件的交互和集成效果，确保它们协同工作</li><li>接口测试：检查系统组件或模块之间的接口是否按预期工作，验证数据交换的准确性</li><li>功能测试：测试系统的功能是否符合需求，通常基于已有的部分内部知识设计测试用例</li></ul> </li></ul> 
<h5><a id="_27"></a>静态测试【纯人工】</h5> 
<ul><li>静态代码分析：使用静态分析工具对源代码进行分析，识别编程错误、资源泄漏、死代码等问题</li><li>代码审查：开发者互相检查代码，确保代码质量，遵循编码规范，并识别潜在的错误或改进点（类似代码走查）</li><li>文档审查： 审查文档是否清晰、准确地描述了系统需求和设计，确保其符合项目标准和需求</li><li>桌面检查：对开发或测试环境的检查，确保所有必需的工具、文档和资源都在正确的位置，并且没有遗漏或配置错误</li></ul> 
<p><strong>例题</strong></p> 
<p>1、软件测试一般分为两个大类：动态测试和静态测试。前者通过运行程序发现错误，包括 <strong>边界值分析、逻辑覆盖、基本路径</strong> 等方法；后者采用人工和计算机辅助静态分析的手段对程序进行检测，包括 <strong>桌面检查、代码审查、代码走查</strong> 等方法</p> 
<ul><li>边界值分析、逻辑覆盖、基本路径</li><li>桌面检查、逻辑覆盖、错误推测</li><li>桌面检查、代码审查、代码走查</li><li>错误推测、代码审查、基本路径</li></ul> 
<h4><a id="_43"></a>测试阶段</h4> 
<ul><li>单元测试：模块测试，模块功能、性能、接口等</li><li>集成测试：模块间的接口</li><li>系统测试：真实环境下，验证完整的软件配置项能否和系统正确连接</li><li>确认测试：验证软件与需求的一致性。内部确认测试、Alpha测试、Beta测试、验收测试</li><li>回归测试：测试软件变更之后，变更部分的正确性对变更需求的符合性</li></ul> 
<h5><a id="_51"></a>集成测试策略</h5> 
<ul><li> <p>一次性组装（风险高）</p> </li><li> <p>增量式组装（测试全面）</p> <img src="https://images2.imgbox.com/e0/11/q0tVT2LS_o.png" alt="  "> 
  <ul><li>自顶向下（需要桩模块）</li><li>自底向上（需要驱动模块）</li><li>混合式</li></ul> </li></ul> 
<h5><a id="_63"></a>系统测试</h5> 
<ul><li>功能测试</li><li>性能测试 
  <ul><li>负载测试：<strong>各种工作负载</strong>下系统的性能</li><li>压力测试：系统的<strong>瓶颈</strong>或不能接受的性能点</li><li>强度测试：系统<strong>资源特别低</strong>的情况下运行</li><li>容量测试【并发测试】：<strong>同时在线</strong>的最大用户数</li><li>可靠性测试：MTTF之类的参数</li></ul> </li><li>健壮性测试</li><li>用户界面测试</li><li>安全性测试</li><li>安装与反安装测试</li></ul> 
<p><strong>例题</strong></p> 
<p>1、在单元测试中，<strong>驱动模块用来调用被测模块，自顶向下的单元测试中不需要另外编写驱动模块</strong></p> 
<ul><li>驱动模块用来调用被测模块，自顶向下的单元测试中不需要另外编写驱动模块</li><li>桩模块用来模拟被测模块所调用的子模块，自顶向下的单元测试中不需要另外编写桩模块</li><li>驱动模块用来模拟被测模块所调用的子模块，自底向上的单元测试中不需要另外编写驱动模块</li><li>桩模块用来调用被测模块，自底向上的单元测试中不需要另外编写桩模块</li></ul> 
<p>2、软件性能测试有多种不同类型的测试方法，其中，<strong>强度测试</strong> 用于测试在限定的系统下考查软件系统极限运行的情况，<strong>容量测试</strong> 可用于测试系统同时处理的在线最大用户数量</p> 
<ul><li>强度测试 负载测试 压力测试 容量测试</li></ul> 
<h4><a id="_90"></a>面向对象的测试（了解）</h4> 
<ul><li>算法层（单元测试）：包括等价类划分测试、组合功能测试（基于判定表的测试）、递归函数测试和多态消息测试</li><li>类层（模块测试）：包括不变式边界测试、模态类测试和非模态类测试</li><li>模板层/类树层（集成测试）：包括多态服务测试和展平测试</li><li>系统层（系统测试）</li></ul> 
<hr> 
<h3><a id="_99"></a>软件调试</h3> 
<ul><li><strong>蛮力法</strong>：主要思想是“通过计算机找错”，低效，耗时</li><li><strong>回溯法</strong>：从出错处人工沿控制流程往回追踪，直至发现出错的根源。复杂程序由于回溯路径多，难以实施</li><li><strong>原因排除法</strong>：主要思想是演绎和归纳，用二分法实现</li></ul> 
<p><strong>软件测试 VS 软件调试</strong></p> 
<table><thead><tr><th align="center">软件测试</th><th align="center">软件调试</th></tr></thead><tbody><tr><td align="center">目的是找出存在的错误</td><td align="center">目的是定位错误并修改程序以修正错误</td></tr><tr><td align="center">从一个已知的条件开始，使用预先定义的过程，有预知的结果</td><td align="center">从一个未知的条件开始，结束的过程不可预计</td></tr><tr><td align="center">测试过程可以事先设计，进度可以事先确定</td><td align="center">调试不能描述过程或持续时间</td></tr></tbody></table> 
<hr> 
<h3><a id="_115"></a>系统转换计划</h3> 
<h4><a id="_117"></a>遗留系统演化策略</h4> 
<img src="https://images2.imgbox.com/3f/a8/nHpGLc4x_o.png" alt="image-20240725123839803"> 
<p><strong>例题</strong></p> 
<p>1、遗留系统的演化可以采用淘汰、继承、改造和集成四种策略。若企业中的遗留系统技术含量较高，业务价值较低，在局部领域中工作良好，形成了一个个信息孤岛时，适合于采用 <strong>集成</strong> 演化策略</p> 
<ul><li>淘汰</li><li>继承</li><li>改造</li><li>集成</li></ul> 
<h4><a id="_130"></a>新旧系统转换策略</h4> 
<ul><li>直接转换策略（把现有系统下线，新系统然后上线）</li><li>并行转换策略</li><li>分段转换策略</li></ul> 
<h4><a id="_136"></a>数据转换与迁移</h4> 
<p>旧数据库 -&gt; 抽取 -&gt; 转换 -&gt; 装载 -&gt; 新数据库</p> 
<hr> 
<h3><a id="_142"></a>系统运行与软件维护</h3> 
<ul><li><strong>正确性维护</strong>：指改正在系统开发阶段已发生而系统测试阶段尚未发现的错误</li><li><strong>适应性维护</strong>：指使应用软件适应环境变化【外部环境、数据环境】而进行的修改</li><li><strong>完善性维护</strong>：扩充功能和改善性能而进行的修改</li><li><strong>预防性维护</strong>：为了适应未来的软硬件环境的变化，应主动增加预防性的新的功能，以使用系统适应各类变化而不被淘汰。如将专用报表功能改成通用报表生成功能，以适应将来报表格式的变化</li></ul> 
<p><strong>例题</strong></p> 
<p>1、软件的维护并不只是修正错误。为了满足用户提出的增加新功能、修改现有功能以及一般性的改进要求和建议，需要进行 <strong>完善性维护</strong> ，它是软件维护工作的主要部分；软件测试不可能揭露旧系统中所有潜在的错误，所以这些程序在使用过程中还可能发生错误，诊断和更正这些错误的过程称为 <strong>改正性维护</strong> ；为了改进软件未来的可维护性或可靠性，或者为了给未来的改进提供更好的基础而对软件进行修改，这类活动称为 <strong>预防性维护</strong></p> 
<ul><li>完善性维护</li><li>适应性维护</li><li>预防性维护</li><li>改正性维护</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b381001e3a0a8f014b94d9e3a6d1a2e8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Maven(源码&#43;lw&#43;部署文档&#43;讲解等)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b1a0f231f9811d7f41bdf837f45030be/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C&#43;&#43;】深入解析C/C&#43;&#43;内存管理：new与delete的使用及原理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>