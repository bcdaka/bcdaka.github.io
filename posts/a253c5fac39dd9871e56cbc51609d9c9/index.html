<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>用PyTorch轻松实现二分类：逻辑回归入门 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/a253c5fac39dd9871e56cbc51609d9c9/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="用PyTorch轻松实现二分类：逻辑回归入门">
  <meta property="og:description" content="💗💗💗欢迎来到我的博客，你将找到有关如何使用技术解决问题的文章，也会找到某个技术的学习路线。无论你是何种职业，我都希望我的博客对你有所帮助。最后不要忘记订阅我的博客以获取最新文章，也欢迎在文章下方留下你的评论和反馈。我期待着与你分享知识、互相学习和建立一个积极的社区。谢谢你的光临，让我们一起踏上这个知识之旅！
文章目录 🥦引言🥦什么是逻辑回归？🥦分类问题🥦交叉熵🥦代码实现🥦总结 🥦引言 当谈到机器学习和深度学习时，逻辑回归是一个非常重要的算法，它通常用于二分类问题。在这篇博客中，我们将使用PyTorch来实现逻辑回归。PyTorch是一个流行的深度学习框架，它提供了强大的工具来构建和训练神经网络，适用于各种机器学习任务。
在机器学习中已经使用了sklearn库介绍过逻辑回归，这里重点使用pytorch这个深度学习框架
🥦什么是逻辑回归？ 我们首先来回顾一下什么是逻辑回归？
逻辑回归是一种用于二分类问题的监督学习算法。它的主要思想是通过一个S形曲线（通常是Sigmoid函数）将输入特征映射到0和1之间的概率值，然后根据这些概率值进行分类决策。在逻辑回归中，我们使用一个线性模型和一个激活函数来实现这个映射。
🥦分类问题 这里以MINIST Dataset手写数字集为例
这个数据集中包含了6w个训练集1w个测试集，类别10个
这里我们不再向之前线性回归那样，根据属于判断具体的数值大小；而是根据输入的值判断从0-9每个数字的概率大小记为p（0）、p（1）…而且十个概率值和为1，我们的目标就是根据输入得到这十个分类对于输入的每一个的概率值，哪个大就是我们需要的。
这里介绍一下与torch相关联的库—torchvision
torchvision：
“torchvision” 是一个PyTorch的附加库，专门用于处理图像和视觉任务。
它包含了一系列用于数据加载、数据增强、计算机视觉任务（如图像分类、目标检测等）的工具和数据集。“torchvision” 提供了许多预训练的视觉模型（例如，ResNet、VGG、AlexNet等），可以用于迁移学习或作为基准模型。
此外，它还包括了用于图像预处理、转换和可视化的函数。 上图已经清楚的显示了，这个库包含了一些自带的数据集，但是并不是我们安装完这个库就有了，而且需要进行调用的，类似在线下载，root指定下载的路径，train表示你需要训练集还是测试集，通常情况下就是两个一个训练，一个测试，download就是判断你下没下载，下载了就是摆设，没下载就给你下载了
我们再来看一个数据集（CIFAR-10）
包含了5w训练样本，1w测试样本，10类。调用方式与上一个类似。
接下来我们从一张图更加直观的查看分类和回归
左边的是回归，右边的是分类
过去我们使用回归例如 y ^ \hat{y} y^​=wx&#43;b∈R，这是属于一个实数的；但是在分类问题， y ^ \hat{y} y^​∈[0,1]
这说明我们需要寻找一个函数，将原本实数的值经过函数的映射转化为[0,1]之间。这里我们引入Logistic函数，使用极限很清楚的得出x趋向于正无穷的时候函数为1，x趋向于负无穷的时候，函数为0，x=0的时候，函数为0.5，当我们计算的时候将 y ^ \hat{y} y^​带入这样就会出现一个0到1的概率了。
下图展示一些其他的Sigmoid函数
🥦交叉熵 过去我们所使用的损失函数普遍都是MSE，这里引入一个新的损失函数—交叉熵
==交叉熵（Cross-Entropy）==是一种用于衡量两个概率分布之间差异的数学方法，常用于机器学习和深度学习中，特别是在分类问题中。它是一个非常重要的损失函数，用于衡量模型的预测与真实标签之间的差异，从而帮助优化模型参数。
在交叉熵的上下文中，通常有两个概率分布：
真实分布（True Distribution）： 这是指问题的实际概率分布，表示样本的真实标签分布。通常用 p ( x ) p(x) p(x)表示，其中 x x x表示样本或类别。
预测分布（Predicted Distribution）： 这是指模型的预测概率分布，表示模型对每个类别的预测概率。通常用 q ( x ) q(x) q(x)表示，其中 x x x表示样本或类别。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-10-08T14:42:12+08:00">
    <meta property="article:modified_time" content="2023-10-08T14:42:12+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">用PyTorch轻松实现二分类：逻辑回归入门</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>💗💗💗欢迎来到我的博客，你将找到有关如何使用技术解决问题的文章，也会找到某个技术的学习路线。无论你是何种职业，我都希望我的博客对你有所帮助。最后不要忘记订阅我的博客以获取最新文章，也欢迎在文章下方留下你的评论和反馈。我期待着与你分享知识、互相学习和建立一个积极的社区。谢谢你的光临，让我们一起踏上这个知识之旅！<br> <img src="https://images2.imgbox.com/29/97/T5MvqsrE_o.gif" alt="请添加图片描述"></p> 
</blockquote> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_7" rel="nofollow">🥦引言</a></li><li><a href="#_12" rel="nofollow">🥦什么是逻辑回归？</a></li><li><a href="#_19" rel="nofollow">🥦分类问题</a></li><li><a href="#_60" rel="nofollow">🥦交叉熵</a></li><li><a href="#_87" rel="nofollow">🥦代码实现</a></li><li><a href="#_139" rel="nofollow">🥦总结</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_7"></a>🥦引言</h2> 
<blockquote> 
 <p>当谈到机器学习和深度学习时，逻辑回归是一个非常重要的算法，它通常用于二分类问题。在这篇博客中，我们将使用PyTorch来实现逻辑回归。PyTorch是一个流行的深度学习框架，它提供了强大的工具来构建和训练神经网络，适用于各种机器学习任务。</p> 
</blockquote> 
<p>在机器学习中已经使用了sklearn库介绍过逻辑回归，这里重点使用pytorch这个深度学习框架</p> 
<h2><a id="_12"></a>🥦什么是逻辑回归？</h2> 
<p>我们首先来回顾一下什么是逻辑回归？</p> 
<blockquote> 
 <p>逻辑回归是一种用于二分类问题的监督学习算法。它的主要思想是通过一个S形曲线（通常是Sigmoid函数）将输入特征映射到0和1之间的概率值，然后根据这些概率值进行分类决策。在逻辑回归中，我们使用一个线性模型和一个激活函数来实现这个映射。</p> 
</blockquote> 
<h2><a id="_19"></a>🥦分类问题</h2> 
<p>这里以MINIST Dataset手写数字集为例<br> <img src="https://images2.imgbox.com/0a/77/fotdyS20_o.png" alt="在这里插入图片描述"></p> 
<p>这个数据集中包含了6w个训练集1w个测试集，类别10个<br> 这里我们不再向之前线性回归那样，根据属于判断具体的数值大小；而是根据输入的值判断从0-9每个数字的概率大小记为p（0）、p（1）…而且十个概率值和为1，我们的目标就是根据输入得到这十个分类对于输入的每一个的概率值，哪个大就是我们需要的。</p> 
<p>这里介绍一下与torch相关联的库—torchvision<br> <mark>torchvision：</mark></p> 
<ul><li>“torchvision” 是一个PyTorch的附加库，专门用于处理图像和视觉任务。<br> 它包含了一系列用于数据加载、数据增强、计算机视觉任务（如图像分类、目标检测等）的工具和数据集。</li><li>“torchvision” 提供了许多预训练的视觉模型（例如，ResNet、VGG、AlexNet等），可以用于迁移学习或作为基准模型。<br> 此外，它还包括了用于图像预处理、转换和可视化的函数。</li></ul> 
<p>上图已经清楚的显示了，这个库包含了一些自带的数据集，但是并不是我们安装完这个库就有了，而且需要进行调用的，类似在线下载，root指定下载的路径，train表示你需要训练集还是测试集，通常情况下就是两个一个训练，一个测试，download就是判断你下没下载，下载了就是摆设，没下载就给你下载了</p> 
<p><mark>我们再来看一个数据集（CIFAR-10）</mark><br> <img src="https://images2.imgbox.com/ff/8f/fHebpbqj_o.png" alt="在这里插入图片描述"><br> 包含了5w训练样本，1w测试样本，10类。调用方式与上一个类似。</p> 
<p>接下来我们从一张图更加直观的查看分类和回归<br> <img src="https://images2.imgbox.com/fb/b1/9MuwuIW1_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>左边的是回归，右边的是分类</p> 
</blockquote> 
<hr> 
<p><img src="https://images2.imgbox.com/ee/29/c62V4tMK_o.png" alt="在这里插入图片描述"></p> 
<p>过去我们使用回归例如<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          y 
         
        
          ^ 
         
        
       
      
        \hat{y} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.6944em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span></span><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="accent-body" style="left: -0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.1944em;"><span class=""></span></span></span></span></span></span></span></span></span>=wx+b∈R，这是属于一个实数的；但是在分类问题，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          y 
         
        
          ^ 
         
        
       
      
        \hat{y} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.6944em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span></span><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="accent-body" style="left: -0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.1944em;"><span class=""></span></span></span></span></span></span></span></span></span>∈[0,1]<br> 这说明我们需要寻找一个函数，将原本实数的值经过函数的映射转化为[0,1]之间。这里我们引入Logistic函数，使用极限很清楚的得出x趋向于正无穷的时候函数为1，x趋向于负无穷的时候，函数为0，x=0的时候，函数为0.5，当我们计算的时候将<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          y 
         
        
          ^ 
         
        
       
      
        \hat{y} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.6944em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span></span><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="accent-body" style="left: -0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.1944em;"><span class=""></span></span></span></span></span></span></span></span></span>带入这样就会出现一个0到1的概率了。</p> 
<p>下图展示一些其他的Sigmoid函数<br> <img src="https://images2.imgbox.com/a7/21/SSJkvLBw_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_60"></a>🥦交叉熵</h2> 
<p>过去我们所使用的损失函数普遍都是MSE，这里引入一个新的损失函数—交叉熵</p> 
<p>==交叉熵（Cross-Entropy）==是一种用于衡量两个概率分布之间差异的数学方法，常用于机器学习和深度学习中，特别是在分类问题中。它是一个非常重要的损失函数，用于衡量模型的预测与真实标签之间的差异，从而帮助优化模型参数。</p> 
<p>在交叉熵的上下文中，通常有两个概率分布：</p> 
<ul><li> <p>真实分布（True Distribution）： 这是指问题的实际概率分布，表示样本的真实标签分布。通常用<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           p 
          
         
           ( 
          
         
           x 
          
         
           ) 
          
         
        
          p(x) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span>表示，其中<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           x 
          
         
        
          x 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span>表示样本或类别。</p> </li><li> <p>预测分布（Predicted Distribution）： 这是指模型的预测概率分布，表示模型对每个类别的预测概率。通常用<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           q 
          
         
           ( 
          
         
           x 
          
         
           ) 
          
         
        
          q(x) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">q</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span>表示，其中<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           x 
          
         
        
          x 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span>表示样本或类别。</p> </li></ul> 
<p>交叉熵的一般定义如下：<br> <img src="https://images2.imgbox.com/a5/8c/RAjVX5JI_o.png" alt="在这里插入图片描述">其中，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         H 
        
       
         ( 
        
       
         p 
        
       
         , 
        
       
         q 
        
       
         ) 
        
       
      
        H(p, q) 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0813em;">H</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">q</span><span class="mclose">)</span></span></span></span></span> 表示真实分布 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         p 
        
       
      
        p 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span></span> 和预测分布 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         q 
        
       
      
        q 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">q</span></span></span></span></span> 之间的交叉熵。</p> 
<p>交叉熵的主要特点和用途包括：</p> 
<ul><li> <p>度量差异性： 交叉熵度量了真实分布和预测分布之间的差异。当两个分布相似时，交叉熵较小；当它们之间的差异增大时，交叉熵增大。</p> </li><li> <p>损失函数： 在机器学习中，交叉熵通常用作损失函数，用于衡量模型的预测与真实标签之间的差异。在分类任务中，通常使用交叉熵作为模型的损失函数，帮助模型优化参数以提高分类性能。</p> </li><li> <p>反向传播： 交叉熵在训练神经网络时非常有用。通过计算交叉熵的梯度，可以使用反向传播算法来调整神经网络的权重，从而使模型的预测更接近真实标签。</p> </li></ul> 
<p>在分类问题中，常见的交叉熵损失函数包括二元交叉熵（Binary Cross-Entropy）和多元交叉熵（Categorical Cross-Entropy）。二元交叉熵用于二分类问题，多元交叉熵用于多类别分类问题。</p> 
<p>刘二大人的PPT中也介绍了<br> <img src="https://images2.imgbox.com/0b/90/pAoKD4iG_o.png" alt="在这里插入图片描述"><br> 右边的表格中每组y与<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
        
        
          y 
         
        
          ^ 
         
        
       
      
        \hat{y} 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.6944em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span></span><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="accent-body" style="left: -0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.1944em;"><span class=""></span></span></span></span></span></span></span></span></span>对应的BCE，BCE越高说明越可能，最后将其求均值</p> 
<h2><a id="_87"></a>🥦代码实现</h2> 
<p><img src="https://images2.imgbox.com/67/36/JocdczXL_o.png" alt="在这里插入图片描述"></p> 
<p>根据上图可知，线性回归和逻辑回归的流程与函数只区别于Sigmoid函数<br> <img src="https://images2.imgbox.com/b5/e0/wDlGxGF2_o.png" alt="在这里插入图片描述"><br> 这里就是BCEloss的调用，里面的参数代表求不求均值</p> 
<p><mark>完整代码如下</mark></p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>functional <span class="token keyword">as</span> F
x_data <span class="token operator">=</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2.0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3.0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
y_data <span class="token operator">=</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">LogisticRegressionModel</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token builtin">super</span><span class="token punctuation">(</span>LogisticRegressionModel<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span> 
		self<span class="token punctuation">.</span>linear <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
		y_pred <span class="token operator">=</span> F<span class="token punctuation">.</span>sigmoid<span class="token punctuation">(</span>self<span class="token punctuation">.</span>linear<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> y_pred
model <span class="token operator">=</span> LogisticRegressionModel<span class="token punctuation">(</span><span class="token punctuation">)</span> 
criterion <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>BCELoss<span class="token punctuation">(</span>size_average<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>model<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">)</span>  
<span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	y_pred <span class="token operator">=</span> model<span class="token punctuation">(</span>x_data<span class="token punctuation">)</span>
	loss <span class="token operator">=</span> criterion<span class="token punctuation">(</span>y_pred<span class="token punctuation">,</span> y_data<span class="token punctuation">)</span>
	<span class="token keyword">print</span><span class="token punctuation">(</span>epoch<span class="token punctuation">,</span> loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span> 
	loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>
	optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>最后绘制一下</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt
x <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span>
x_t <span class="token operator">=</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 相当于reshape</span>
y_t <span class="token operator">=</span> model<span class="token punctuation">(</span>x_t<span class="token punctuation">)</span>
y <span class="token operator">=</span> y_t<span class="token punctuation">.</span>data<span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token operator">=</span><span class="token string">'r'</span><span class="token punctuation">)</span> 
plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'Hours'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Probability of Pass'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>grid<span class="token punctuation">(</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p><mark>运行结果如下</mark><br> <img src="https://images2.imgbox.com/64/bb/jB1fCZ4e_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_139"></a>🥦总结</h2> 
<blockquote> 
 <p>这就是使用PyTorch实现逻辑回归的基本步骤。逻辑回归是一个简单但非常有用的算法，可用于各种分类问题。希望这篇博客能帮助你开始使用PyTorch构建自己的逻辑回归模型。如果你想进一步扩展你的知识，可以尝试在更大的数据集上训练模型或探索其他深度学习算法。祝你好运！</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/48/bd/SpK8TWqk_o.jpg" alt="请添加图片描述"></p> 
<blockquote> 
 <p>挑战与创造都是很痛苦的，但是很充实。</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/445fb490c743a80bccc9ae1b8865b74b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">头哥数据库实战答案及解析(1-1 到 1-5)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/af105e91495c05a43bc1d53c3334e875/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">android槽位切换</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>