<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构之初始泛型 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ad567f55a5e6715fe916d3c48e2161db/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构之初始泛型">
  <meta property="og:description" content="找往期文章包括但不限于本期文章中不懂的知识点：
个人主页：我要学编程(ಥ_ಥ)-CSDN博客
所属专栏：数据结构（Java版）
目录
深入了解包装类 包装类的由来
装箱与拆箱 面试题 泛型 泛型的语法与使用
泛型如何编译的 泛型的上界
泛型方法 泛型占位符
深入了解包装类 我们在最开始学习Java的数据类型时，就知道了Java的八大基本数据类型有自己对应的包装类，也就是引用类型。今天，我们就来彻底了解它们。
包装类的由来 在Java中，由于基本类型不是继承自Object类，为了在泛型代码中可以支持基本类型，Java给每个基本类型都创造了对应的一个包装类型。如下：
基本类型与其对应的包装类 类型 基本数据类型包装类 类型byteBytechar Character
shortShortintIntegerlongLongfloatFloatdoubleDoublebooleanBoolean 装箱与拆箱 装箱也叫作：装包。就是把基本数据类型转换成其对应的包装类 类型。
例如：
public class Test { public static void main(String[] args) { Integer a = 10; Integer c = new Integer(10); Integer b = Integer.valueOf(10); System.out.println(a); System.out.println(b); System.out.println(c); } } 上面三种写法，都是装箱的操作，即把基本数据类型转换成其对应的包装类 类型。但要注意的是第二种方法，虽然代码可以正常执行，但我们现在不再使用这种方法了。从Java 9开始，这个方法就已经被摒弃了。下面是Java 8 和 Java 17的不同情况：
Java 8：
Java 17： 需要注意的是：这里爆红，但还是可以运行通过的。 拆箱也叫作：拆包。就是把包装类 类型转换成其对应的基本数据类型。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-06T12:57:46+08:00">
    <meta property="article:modified_time" content="2024-06-06T12:57:46+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构之初始泛型</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>找往期文章包括但不限于本期文章中不懂的知识点：</p> 
<blockquote> 
 <p><strong>个人主页：</strong><a href="https://blog.csdn.net/2301_80854132?type=blog" title="我要学编程(ಥ_ಥ)-CSDN博客">我要学编程(ಥ_ಥ)-CSDN博客</a></p> 
 <p><strong>所属专栏：<a href="https://blog.csdn.net/2301_80854132/category_12650676.html" title="数据结构（Java版）">数据结构（Java版）</a></strong></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E5%8C%85%E8%A3%85%E7%B1%BB%C2%A0-toc" style="margin-left:0px;"><a href="#%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E5%8C%85%E8%A3%85%E7%B1%BB%C2%A0" rel="nofollow">深入了解包装类 </a></p> 
<p id="%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E7%94%B1%E6%9D%A5-toc" style="margin-left:40px;"><a href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E7%94%B1%E6%9D%A5" rel="nofollow">包装类的由来</a></p> 
<p id="%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1%C2%A0-toc" style="margin-left:40px;"><a href="#%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1%C2%A0" rel="nofollow">装箱与拆箱 </a></p> 
<p id="%E9%9D%A2%E8%AF%95%E9%A2%98%C2%A0-toc" style="margin-left:40px;"><a href="#%E9%9D%A2%E8%AF%95%E9%A2%98%C2%A0" rel="nofollow">面试题 </a></p> 
<p id="%E6%B3%9B%E5%9E%8B%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0-toc" style="margin-left:0px;"><a href="#%E6%B3%9B%E5%9E%8B%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0" rel="nofollow">泛型            </a></p> 
<p id="%E6%B3%9B%E5%9E%8B%E7%9A%84%E8%AF%AD%E6%B3%95%E4%B8%8E%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E8%AF%AD%E6%B3%95%E4%B8%8E%E4%BD%BF%E7%94%A8" rel="nofollow">泛型的语法与使用</a></p> 
<p id="%E6%B3%9B%E5%9E%8B%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E7%9A%84%C2%A0-toc" style="margin-left:40px;"><a href="#%E6%B3%9B%E5%9E%8B%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E7%9A%84%C2%A0" rel="nofollow">泛型如何编译的 </a></p> 
<p id="%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%8A%E7%95%8C-toc" style="margin-left:40px;"><a href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%8A%E7%95%8C" rel="nofollow">泛型的上界</a></p> 
<p id="%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%C2%A0-toc" style="margin-left:40px;"><a href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%C2%A0" rel="nofollow">泛型方法 </a></p> 
<p id="%E6%B3%9B%E5%9E%8B%E5%8D%A0%E4%BD%8D%E7%AC%A6-toc" style="margin-left:40px;"><a href="#%E6%B3%9B%E5%9E%8B%E5%8D%A0%E4%BD%8D%E7%AC%A6" rel="nofollow">泛型占位符</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E5%8C%85%E8%A3%85%E7%B1%BB%C2%A0"><span style="color:#fe2c24;">深入了解包装类 </span></h2> 
<p>我们在最开始学习Java的数据类型时，就知道了Java的八大基本数据类型有自己对应的包装类，也就是引用类型。今天，我们就来彻底了解它们。</p> 
<h3 id="%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E7%94%B1%E6%9D%A5"><span style="color:#38d8f0;">包装类的由来</span></h3> 
<p>在Java中，由于基本类型不是继承自Object类，为了在泛型代码中可以支持基本类型，Java给每个基本类型都创造了对应的一个包装类型。如下：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><caption>
   基本类型与其对应的包装类 类型 
 </caption><tbody><tr><td>基本数据类型</td><td>包装类 类型</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>char</td><td> <p>Character</p> </td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table> 
<h3 id="%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1%C2%A0"><span style="color:#38d8f0;">装箱与拆箱 </span></h3> 
<p>装箱也叫作：装包。就是把基本数据类型转换成其对应的包装类 类型。</p> 
<p>例如：</p> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        Integer a = 10;

        Integer c = new Integer(10);

        Integer b = Integer.valueOf(10);


        System.out.println(a);
        System.out.println(b);
        System.out.println(c);
    }
}</code></pre> 
<p>上面三种写法，都是装箱的操作，即把基本数据类型转换成其对应的包装类 类型。但要注意的是第二种方法，虽然代码可以正常执行，但我们现在不再使用这种方法了。从Java 9开始，这个方法就已经被摒弃了。下面是Java 8 和 Java 17的不同情况：</p> 
<p>Java 8：</p> 
<p><img alt="" height="697" src="https://images2.imgbox.com/fd/6f/UHkMDBbN_o.png" width="1200"></p> 
<p>Java 17： </p> 
<p><img alt="" height="725" src="https://images2.imgbox.com/0f/0e/7AYp08nR_o.png" width="1200"></p> 
<p>需要注意的是：这里爆红，但还是可以运行通过的。 </p> 
<p>拆箱也叫作：拆包。就是把包装类 类型转换成其对应的基本数据类型。</p> 
<p>例如：</p> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        Integer integer = 10;

        int a = integer;

        int b = integer.intValue();

        System.out.println(a);
        System.out.println(b);
    }
}</code></pre> 
<p>注意：</p> 
<p>当我们显式地去调用方法来进行装箱或者拆箱操作时，这种方式叫做：显式装箱（拆箱）。</p> 
<p>当我们直接把基本数据类型转换为其对应的包装类 类型或者进行这种拆箱操作时，这就叫做：自动装箱（拆箱）。</p> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        Integer a = 10; // 自动装箱
        Integer b = Integer.valueOf(10); // 显式装箱
        
        int c = a; // 自动拆箱
        int d = b.intValue(); // 显式拆箱
    }
}
</code></pre> 
<h3 id="%E9%9D%A2%E8%AF%95%E9%A2%98%C2%A0"><span style="color:#38d8f0;">面试题 </span></h3> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        Integer a = 100;
        Integer b = 100;
        System.out.println(a == b); // 结果是 true

        Integer c = 200;
        Integer d = 200;
        System.out.println(c == d); // 结果是 false
    }
}</code></pre> 
<p>这里同样都是自动装箱，为什么输出的结果会不一样呢？</p> 
<p>分析：a b c d 在这里都是一个引用类型，那么在用 == 比较时，比较的是它们各自在堆区的地址。这也就说明 a 和 b在堆区是同一块地址，但是c 和 d 在堆区不是同一块地址。</p> 
<p><img alt="" height="1029" src="https://images2.imgbox.com/6d/9d/i8hQHhd4_o.png" width="1200"></p> 
<p>我们就可以去看这个装箱的源码，看看到底做了什么？ </p> 
<p><img alt="" height="233" src="https://images2.imgbox.com/65/2e/JYJUJ2A6_o.png" width="1200"></p> 
<p>可以看到当装箱的 i 的值在 [low, high] 之间的时候，返回的是一个数组所对应的下标的值，而当 i 不在这个范围内时，返回的是一个新的对象。因此，我们可以得出结论了：100在这个范围内，200不在这个范围内。我们还是可以看一个这个源码对应的 low 和 high 的值的。</p> 
<p><img alt="" height="961" src="https://images2.imgbox.com/cf/f4/DUdSH5Oh_o.png" width="1200"></p> 
<p>low 对应的值是 -128，high 对应的值是 127。 </p> 
<p><img alt="" height="352" src="https://images2.imgbox.com/40/14/owjk3F5g_o.png" width="1200"></p> 
<p>根据条件得出这个数组大致是这样的。因此 当 i = 100时，返回的是在数组中的同一份；而 i  = 200时，返回的是 new 的一个新对象。 </p> 
<h2 id="%E6%B3%9B%E5%9E%8B%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%C2%A0"><span style="color:#fe2c24;">泛型</span>            </h2> 
<p>包装类的出现就是为泛型服务的。那么什么是泛型呢？顾名思义：就是一个广泛的类型。泛型的出现是为了解决掉：一个类或者方法只能解决对应类型的问题。</p> 
<p>例如：对整型数据排序，就只能用整型数组类解决。</p> 
<pre><code class="language-java">class Myarray {
    public static void bubble_sort (int[] array) {
        // 趟数
        for (int i = 0; i &lt; array.length; i++) {
            boolean flag = true;
            // 每一趟要比较的内容
            for (int j = 0; j &lt; array.length-i-1; j++) {
                if (array[j] &gt; array[j+1]) {
                    int tmp = array[j];
                    array[j] = array[j+1];
                    array[j+1] = tmp;
                    flag = false;
                }
            }
            if (flag) {
                break;
            }
        }
    }
}
public class Test {
    public static void main(String[] args) {
        int[] array = {10,9,8,7,6,5,4,3,2,1};
        System.out.println("排序前："+ Arrays.toString(array));
        Myarray.bubble_sort(array);
        System.out.println("排序后："+ Arrays.toString(array));
    }
}
</code></pre> 
<p><img alt="" height="124" src="https://images2.imgbox.com/e6/37/dtt4s5rq_o.png" width="1054"></p> 
<p>从排序的结果来看：这个排序的功能是正确的。但是也只局限于排序整型数据，不能排序其他类型的数据，如果要排序的话，还得重新写一个这样的方法。于是就出现了泛型。 所以，泛型的主要目的：就是指定当前的容器，要持有什么类型的对象。让编译器去做检查。</p> 
<h3 id="%E6%B3%9B%E5%9E%8B%E7%9A%84%E8%AF%AD%E6%B3%95%E4%B8%8E%E4%BD%BF%E7%94%A8"><span style="color:#38d8f0;">泛型的语法与使用</span></h3> 
<pre><code class="language-java">class 泛型类名称&lt;类型形参列表&gt; {
    // 这里可以使用类型参数
}</code></pre> 
<p> 这里的参数列表可以不只有一种。就像下面这样：</p> 
<pre><code class="language-java">class 泛型类名称&lt;T1,T2,....,Tn&gt; {
    
}</code></pre> 
<p>这里的T代表的是占位符，表示当前类是一个泛型类。</p> 
<p>类型形参一般使用一个大写字母表示，常用的名称有：</p> 
<blockquote> 
 <p>E 表示 Elements               K 表示 Key                                             V  表示 Value </p> 
 <p>N 表示 Number                 T 表示 Type                S, U, V 等等 - 第二、第三、第四个类型</p> 
</blockquote> 
<p>至于这些占位符的区别以及各自之间的含义，我们待会再学习。我们可以用一个数组来接收多种不同的元素了。</p> 
<pre><code class="language-java">class MyArray&lt;T&gt; {
    // 语法规定不能创建泛型数组，但Object可以拥有接收所有类的功能
    public Object[] objects;
    public MyArray(){
        this.objects = new Object[10];
    }
    public T getValue(int pos) {
        // 取出来的是一个Object类，得强转成 T
        return (T)objects[pos];
    }
    public void setValue(int pos, T value) {
        // 这里不考虑pos的无效，注重这里的思想
        objects[pos] = value;
    }
}

public class Test {
    public static void main(String[] args) {
        MyArray&lt;Integer&gt; myarray = new MyArray&lt;&gt;();
        myarray.setValue(0, 10);
        myarray.setValue(1, 20);


        //                                  这里可写可不写
        MyArray&lt;String&gt; myArray = new MyArray&lt;String&gt;();
        myArray.setValue(0, "Hello");
        myArray.setValue(1, "World");
    }
}</code></pre> 
<p>这里就实现了同一个类，但是可以接收不同的类型，实现了类型的参数化。这就是泛型的意义。</p> 
<p>注意：</p> 
<p>1. 泛型只能接受类，所有的基本数据类型必须使用包装类！ </p> 
<p>2. 编译器会根据我们在实例化一个对象的时候来判断这个T到底是什么类型。</p> 
<p>3. 我们也可能会遇到有的代码在使用泛型类时，没有标明具体的类型，但是还是可以运行通过。这是因为泛型这个概念是在 java 5之后提出来的。之前的 java 版本并没有这种写法，所以为了兼容老版本，泛型类在实例化时，会有未标明具体类型的情况，这种叫做裸类型。但是我们最好不要写这种代码出来。<img alt="" height="138" src="https://images2.imgbox.com/cc/d0/rNGZjlPR_o.png" width="872"></p> 
<h3 id="%E6%B3%9B%E5%9E%8B%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E7%9A%84%C2%A0"><span style="color:#38d8f0;">泛型如何编译的 </span></h3> 
<p>泛型是只存在于编译时期的名词，因为在编译过后不存在T、E等泛型占位符了。泛型的占位符在编译之后就被替换成了Object。这种机制被称为“擦除机制” 。将占位符擦除成Object。</p> 
<h3 id="%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%8A%E7%95%8C"><span style="color:#38d8f0;">泛型的上界</span></h3> 
<p> 如果我们想要限制泛型的传过来的种类也是可以的。</p> 
<p><img alt="" height="950" src="https://images2.imgbox.com/2e/2b/8y26lSfA_o.png" width="1200"></p> 
<p>在定义泛型类时，有时需要对传入的类型变量做一定的约束（就像上面那样），可以通过类型边界来约束。 </p> 
<p> 语法：</p> 
<pre><code class="language-java">class 泛型类名称&lt;类型形参 extends 类型边界&gt; {
    ...
}</code></pre> 
<p>注意：其实所有的泛型类都有一个上界：Object。 </p> 
<h3 id="%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%C2%A0" style="background-color:transparent;"><span style="color:#38d8f0;">泛型方法 </span></h3> 
<p>语法：</p> 
<pre><code class="language-java">方法限定符 &lt;类型形参列表&gt; 返回值类型 方法名称(形参列表) {
         ... 
}
</code></pre> 
<p>例如：</p> 
<pre><code class="language-java">// 规定这个方法是叫把pos位置的值置为value
public static &lt;T&gt; void swap (T[] array, int pos, T value) {
    array[pos] = value;
}</code></pre> 
<p>注意：只有静态的泛型方法里面才能有泛型的出现，普通的静态方法不能有泛型的出现。</p> 
<p>这句话不是说只有静态方法才能是泛型方法，普通方法也可以是泛型方法。只是说不是泛型的方法里面如果没有实例化泛型对象，就不能出现任何与泛型有关的东西。</p> 
<p>因此，上面的排序就可以用泛型方法来解决。但是会有一个新的问题：Comparable 与 这个数组会出现不兼容的情况，因为这个数组是基本数据类型，没有实现接口这一说法。所以得把这个数组变成包装类，但是在传参的过程中，T会被擦除成Object类，因此即使我们传过去的参数强转成T[ ]，也会发生类型转换异常。</p> 
<p><img alt="" height="520" src="https://images2.imgbox.com/18/7e/zlSO0vek_o.png" width="1200"></p> 
<p><img alt="" height="875" src="https://images2.imgbox.com/f6/37/oY8qO7z3_o.png" width="1200"></p> 
<p>因此这个排序最终是失败了。所以我就没有把代码传上来。但是泛型还是有很大的好处的：可以让一份代码对不同的对象执行相同的操作。 </p> 
<h3><span style="color:#38d8f0;">类型推导</span> </h3> 
<pre><code class="language-java">class Myarray&lt;T&gt; {
    // ......
}


public class Test {
    public static void main(String[] args) {
        // 通过这个 Integer 来推导出 Myarray 中的泛型
        Myarray&lt;Integer&gt; myarray = new Myarray&lt;&gt;();
    }
}
</code></pre> 
<p>上面是泛型类的推导。下面是泛型方法的推导 </p> 
<p> </p> 
<pre><code class="language-java">class Myarray {
    public &lt;T&gt; void func () {
        // ......
    }
}


public class Test {
    public static void main(String[] args) {
        Myarray myarray = new Myarray();
        // 通过这个 Integer 来推断这个 T（也可以不写，编译器会根据其具体操作来判断）
        myarray.&lt;Integer&gt;func();
    }
}</code></pre> 
<h3 id="%E6%B3%9B%E5%9E%8B%E5%8D%A0%E4%BD%8D%E7%AC%A6" style="background-color:transparent;"><span style="color:#38d8f0;">泛型占位符</span></h3> 
<p>接下来就学习泛型占位符的知识：</p> 
<blockquote> 
 <p>在Java泛型中，像 &lt;T&gt; 和 &lt;E&gt; 这样的占位符是用来表示类型参数的。它们本身没有本质上的区别，都代表一种未知的类型，将在编译时期由具体的实际类型替换。选择使用T、E或其他的，更多是基于习惯和上下文的清晰性。以下是几个常用的占位符及其常见用途：</p> 
 <ul><li> <p><strong>T</strong> - 通常代表 <strong>Type</strong>，是最常见的泛型占位符，用于表示任何类型。在没有特定上下文暗示的情况下，泛型类或方法常使用 <code>T</code>。</p> </li><li> <p><strong>E</strong> - 通常代表 <strong>Element</strong>，特别在集合框架中使用较多，暗示它代表集合中的元素类型，如 List&lt;E&gt; 或 set&lt;E&gt;。</p> </li><li> <p><strong>K</strong> - 代表 <strong>Key</strong>，通常用在表示键的类型，比如在 Map &lt;K，V&gt; 中。</p> </li><li> <p><strong>V</strong> - 代表 <strong>Value</strong>，通常与 K 一起使用，表示映射中的值类型。</p> </li><li> <p><strong>N</strong> - 有时代表 <strong>Number</strong>，表示数值类型，尽管这不是Java标准库中的正式约定，但在特定上下文中可能会看到它的使用。</p> </li></ul> 
 <p>使用这些占位符主要是为了提高代码的可读性和自文档化能力。开发者可以根据上下文选择最合适的占位符来表达意图，但最终这些占位符都会被编译器替换为具体的类型信息，不会影响到生成的字节码或运行时行为。</p> 
 <p>此外，泛型中还有一个特殊的占位符 <strong>?</strong>（问号），它作为通配符使用，表示未知的类型，可以有三种形式：无界通配符（?）、上界通配符（<strong><code>? extends SomeType</code></strong>）和下界通配符（<strong><code>? super SomeType</code></strong>），用来实现更灵活的泛型参数约束。（了解即可）</p> 
</blockquote> 
<p>这里基本就是java泛型语法的全部内容啦！通过对泛型的学习，我们就可以让代码变得更加高大上一些。</p> 
<p>好啦！本期 数据结构之初始泛型 的学习之旅就到此结束了！相信通过这篇文章的学习，你对Java中泛型的了解将会更进一步！我们下一期再一起学习吧！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d46b092b0a0c8161a502ad46b9817428/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">详解 Flink 的常见部署方式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/81d73a95d9bb4a47ac2289b38f21a2d9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【恶补计算机基础】定点数和浮点数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>