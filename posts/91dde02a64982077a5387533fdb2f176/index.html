<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【轻松拿捏】java中为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝区别是什么？ - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/91dde02a64982077a5387533fdb2f176/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【轻松拿捏】java中为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝区别是什么？">
  <meta property="og:description" content="java中为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝区别是什么？
一、如何在Java中实现对象克隆
1.1 浅拷贝
1.2 深拷贝
1.3 区别总结
二、面试回答技巧
1. 定义克隆及其用途
2. 解释浅拷贝和深拷贝
3. 具体实现浅拷贝和深拷贝
浅拷贝示例：
深拷贝示例：
4. 举例说明
5. 总结
🎈边走、边悟🎈迟早会好
在Java中，使用克隆的原因与其他编程语言类似，主要包括以下几点：
避免修改原对象：在需要修改对象但又不希望改变原对象时，通过克隆可以操作副本而不影响原对象。节省时间和资源：创建一个新对象的代价较高时，克隆可以节省时间和资源。实现历史记录和回滚：保存对象的克隆可以实现历史记录和回滚功能。 一、如何在Java中实现对象克隆 在Java中，对象克隆主要通过实现 Cloneable 接口并覆盖clone() 方法来实现。Java中的克隆也有浅拷贝和深拷贝两种方式。
1.1 浅拷贝 浅拷贝创建一个新对象，但只复制对象的引用而不复制实际的对象数据。也就是说，浅拷贝的对象和原对象共享引用类型的成员变量。
实现浅拷贝的方式：
实现 Cloneable 接口。覆盖 clone() 方法。 class Person implements Cloneable { String name; int age; public Person(String name, int age) { this.name = name; this.age = age; } @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); // 调用 Object 类的 clone 方法 } @Override public String toString() { return &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-21T16:42:32+08:00">
    <meta property="article:modified_time" content="2024-07-21T16:42:32+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【轻松拿捏】java中为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝区别是什么？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc">java中为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝区别是什么？</p> 
<p id="%E4%B8%80%E3%80%81%E5%A6%82%E4%BD%95%E5%9C%A8Java%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E5%A6%82%E4%BD%95%E5%9C%A8Java%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86" rel="nofollow">一、如何在Java中实现对象克隆</a></p> 
<p id="1.1%20%E6%B5%85%E6%8B%B7%E8%B4%9D-toc" style="margin-left:80px;"><a href="#1.1%20%E6%B5%85%E6%8B%B7%E8%B4%9D" rel="nofollow">1.1 浅拷贝</a></p> 
<p id="1.2%20%E6%B7%B1%E6%8B%B7%E8%B4%9D-toc" style="margin-left:80px;"><a href="#1.2%20%E6%B7%B1%E6%8B%B7%E8%B4%9D" rel="nofollow">1.2 深拷贝</a></p> 
<p id="1.3%20%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93-toc" style="margin-left:80px;"><a href="#1.3%20%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93" rel="nofollow">1.3 区别总结</a></p> 
<p id="%E4%BA%8C%E3%80%81%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E6%8A%80%E5%B7%A7-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E6%8A%80%E5%B7%A7" rel="nofollow">二、面试回答技巧</a></p> 
<p id="1.%20%E5%AE%9A%E4%B9%89%E5%85%8B%E9%9A%86%E5%8F%8A%E5%85%B6%E7%94%A8%E9%80%94-toc" style="margin-left:80px;"><a href="#1.%20%E5%AE%9A%E4%B9%89%E5%85%8B%E9%9A%86%E5%8F%8A%E5%85%B6%E7%94%A8%E9%80%94" rel="nofollow">1. 定义克隆及其用途</a></p> 
<p id="2.%20%E8%A7%A3%E9%87%8A%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D-toc" style="margin-left:80px;"><a href="#2.%20%E8%A7%A3%E9%87%8A%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D" rel="nofollow">2. 解释浅拷贝和深拷贝</a></p> 
<p id="3.%20%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D-toc" style="margin-left:80px;"><a href="#3.%20%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D" rel="nofollow">3. 具体实现浅拷贝和深拷贝</a></p> 
<p id="%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%A4%BA%E4%BE%8B%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%A4%BA%E4%BE%8B%EF%BC%9A" rel="nofollow">浅拷贝示例：</a></p> 
<p id="%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%A4%BA%E4%BE%8B%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%A4%BA%E4%BE%8B%EF%BC%9A" rel="nofollow">深拷贝示例：</a></p> 
<p id="4.%20%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E-toc" style="margin-left:80px;"><a href="#4.%20%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E" rel="nofollow">4. 举例说明</a></p> 
<p id="5.%20%E6%80%BB%E7%BB%93-toc" style="margin-left:80px;"><a href="#5.%20%E6%80%BB%E7%BB%93" rel="nofollow">5. 总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:690px;"><tbody><tr><td> <p style="text-align:center;"><em><span style="color:#ff9900;"><strong>🎈边走、边悟🎈迟早会好</strong></span></em></p> </td></tr></tbody></table> 
<p>在Java中，使用克隆的原因与其他编程语言类似，主要包括以下几点：</p> 
<ol><li><strong>避免修改原对象</strong>：在需要修改对象但又不希望改变原对象时，通过克隆可以操作副本而不影响原对象。</li><li><strong>节省时间和资源</strong>：创建一个新对象的代价较高时，克隆可以节省时间和资源。</li><li><strong>实现历史记录和回滚</strong>：保存对象的克隆可以实现历史记录和回滚功能。</li></ol> 
<h3 id="%E4%B8%80%E3%80%81%E5%A6%82%E4%BD%95%E5%9C%A8Java%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86">一、如何在Java中实现对象克隆</h3> 
<p>        在Java中，对象克隆主要通过实现<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;"> </span><code><span style="background-color:#fbd4d0;">Cloneable</span></code><span style="background-color:#fbd4d0;"> </span></span>接口并覆盖<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">c</span><code><span style="background-color:#fbd4d0;">lone()</span></code></span> 方法来实现。Java中的克隆也有<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">浅拷贝</span></span>和<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">深拷贝</span></span>两种方式。</p> 
<h4 id="1.1%20%E6%B5%85%E6%8B%B7%E8%B4%9D">1.1 浅拷贝</h4> 
<p>        浅拷贝创建一个新对象，但只复制对象的引用而不复制实际的对象数据。也就是说，浅拷贝的对象和原对象共享引用类型的成员变量。</p> 
<p><strong>实现浅拷贝的方式：</strong></p> 
<ol><li>实现 <span style="color:#fe2c24;"><code><span style="background-color:#fbd4d0;">Cloneable</span></code><span style="background-color:#fbd4d0;"> </span></span>接口。</li><li>覆盖 <span style="color:#fe2c24;"><code><span style="background-color:#fbd4d0;">clone()</span></code></span> 方法。</li></ol> 
<pre><code class="language-java">class Person implements Cloneable {
    String name;
    int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone(); // 调用 Object 类的 clone 方法
    }

    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + '}';
    }
}

public class Main {
    public static void main(String[] args) {
        try {
            Person p1 = new Person("Alice", 30);
            Person p2 = (Person) p1.clone();
            p2.name = "Bob";

            System.out.println(p1); // Person{name='Alice', age=30}
            System.out.println(p2); // Person{name='Bob', age=30}
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre> 
<p>在这个例子中，<code>p1</code> 和 <code>p2</code> 是两个不同的对象，但它们的引用类型成员变量<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">共享同一个引用</span></span>。</p> 
<h4 id="1.2%20%E6%B7%B1%E6%8B%B7%E8%B4%9D">1.2 深拷贝</h4> 
<p>        深拷贝不仅复制对象本身，还递归复制对象内部所有引用的对象。因此，深拷贝的对象与原对象完全独立。</p> 
<p><strong>实现深拷贝的方式：</strong></p> 
<ol><li>手动复制所有嵌套对象。</li><li>如果对象较复杂，可以使用序列化和反序列化来实现深拷贝。</li></ol> 
<p><strong>手动深拷贝：</strong></p> 
<pre><code class="language-java">class Address implements Cloneable {
    String city;

    public Address(String city) {
        this.city = city;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }

    @Override
    public String toString() {
        return "Address{city='" + city + "'}";
    }
}

class Person implements Cloneable {
    String name;
    int age;
    Address address;

    public Person(String name, int age, Address address) {
        this.name = name;
        this.age = age;
        this.address = address;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        Person cloned = (Person) super.clone();
        cloned.address = (Address) address.clone(); // 深拷贝地址
        return cloned;
    }

    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + ", address=" + address + '}';
    }
}

public class Main {
    public static void main(String[] args) {
        try {
            Address address = new Address("New York");
            Person p1 = new Person("Alice", 30, address);
            Person p2 = (Person) p1.clone();
            p2.name = "Bob";
            p2.address.city = "Los Angeles";

            System.out.println(p1); // Person{name='Alice', age=30, address=Address{city='New York'}}
            System.out.println(p2); // Person{name='Bob', age=30, address=Address{city='Los Angeles'}}
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre> 
<p>在这个例子中，<span style="color:#fe2c24;"><code><span style="background-color:#fbd4d0;">p2</span></code><span style="background-color:#fbd4d0;"> 是 </span><code><span style="background-color:#fbd4d0;">p1</span></code><span style="background-color:#fbd4d0;"> 的深拷贝，修改 </span><code><span style="background-color:#fbd4d0;">p2</span></code><span style="background-color:#fbd4d0;"> 的地址不会影响 </span><code><span style="background-color:#fbd4d0;">p1</span></code><span style="background-color:#fbd4d0;"> 的地址</span></span>。</p> 
<h4 id="1.3%20%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93">1.3 区别总结</h4> 
<ul><li><strong>浅拷贝</strong>：只复制对象本身及其基本类型成员变量，<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">引用类型成员变量仍然指向原对象的引用</span></span>。</li><li><strong>深拷贝</strong>：递归复制对象及其所有层次的成员变量，<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">创建完全独立的新对象</span></span>。</li></ul> 
<p>        选择使用哪种拷贝方式取决于具体需求和对象的复杂性。在需要完全独立的副本时，使用深拷贝；在只需要复制表层结构时，使用浅拷贝。</p> 
<p></p> 
<h3 id="%E4%BA%8C%E3%80%81%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E6%8A%80%E5%B7%A7">二、面试回答技巧</h3> 
<p>        在面试中回答有关对象克隆的问题时，以下是一些技巧和结构化的回答方法，可以帮助你清晰、完整地展示你的知识和理解。</p> 
<h4 id="1.%20%E5%AE%9A%E4%B9%89%E5%85%8B%E9%9A%86%E5%8F%8A%E5%85%B6%E7%94%A8%E9%80%94">1. <strong>定义克隆及其用途</strong></h4> 
<p><strong>        示例回答：</strong> “对象克隆是创建对象副本的过程，主要用于在不影响原对象的情况下进行修改、节省资源、以及实现历史记录和回滚功能。例如，当创建一个新对象的成本较高时，克隆可以快速生成一个相同的对象。”</p> 
<h4 id="2.%20%E8%A7%A3%E9%87%8A%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D">2. <strong>解释浅拷贝和深拷贝</strong></h4> 
<p><strong>        示例回答：</strong> “在Java中，克隆分为浅拷贝和深拷贝。浅拷贝只复制对象的基本类型成员变量和引用类型成员变量的引用，而不复制实际对象的数据。深拷贝则递归复制所有层次的对象，确保新对象与原对象完全独立。”</p> 
<h4 id="3.%20%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D">3. <strong>具体实现浅拷贝和深拷贝</strong></h4> 
<p><strong>        示例回答：</strong> “浅拷贝通过实现 <span style="color:#fe2c24;"><code><span style="background-color:#fbd4d0;">Cloneable</span></code><span style="background-color:#fbd4d0;"> </span></span>接口并覆盖 <span style="color:#fe2c24;"><code><span style="background-color:#fbd4d0;">clone()</span></code><span style="background-color:#fbd4d0;"> </span></span>方法实现。调用 <span style="color:#fe2c24;"><code><span style="background-color:#fbd4d0;">super.clone()</span></code></span> 可以创建对象的浅拷贝。深拷贝需要手动复制所有嵌套对象，或者使用序列化和反序列化来实现递归复制。”</p> 
<h5 id="%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%A4%BA%E4%BE%8B%EF%BC%9A"><strong>浅拷贝示例：</strong></h5> 
<pre><code class="language-java">class Person implements Cloneable {
    String name;
    int age;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone(); // 浅拷贝
    }
}
</code></pre> 
<h5 id="%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%A4%BA%E4%BE%8B%EF%BC%9A"><strong>深拷贝示例：</strong></h5> 
<pre><code class="language-java">class Address implements Cloneable {
    String city;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone(); // 浅拷贝
    }
}

class Person implements Cloneable {
    String name;
    int age;
    Address address;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        Person cloned = (Person) super.clone();
        cloned.address = (Address) address.clone(); // 深拷贝
        return cloned;
    }
}
</code></pre> 
<h4 id="4.%20%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E">4. <strong>举例说明</strong></h4> 
<p><strong>        示例回答：</strong> “假设有一个 <span style="color:#fe2c24;"><code><span style="background-color:#fbd4d0;">Person</span></code></span> 类，它包含一个 <span style="color:#fe2c24;"><code><span style="background-color:#fbd4d0;">Address</span></code></span> 类的引用。使用浅拷贝，改变 <span style="color:#fe2c24;"><code><span style="background-color:#fbd4d0;">Address</span></code></span> 对象的属性会影响到原来的 <span style="color:#fe2c24;"><code><span style="background-color:#fbd4d0;">Person</span></code></span> 对象。使用深拷贝，每个<span style="color:#fe2c24;"><code><span style="background-color:#fbd4d0;">Person</span></code></span>对象都有独立的 <span style="color:#fe2c24;"><code><span style="background-color:#fbd4d0;">Address</span></code></span> 副本，修改一个对象不会影响另一个对象。”</p> 
<h4 id="5.%20%E6%80%BB%E7%BB%93">5. <strong>总结</strong></h4> 
<p><strong>        示例回答：</strong> “总结来说，浅拷贝适用于简单对象结构，开销较小，但存在引用共享的问题。深拷贝适用于复杂对象结构，保证对象的完全独立，但实现起来更复杂，开销也更大。”</p> 
<blockquote> 
 <p> 🌟感谢支持 <a href="https://blog.csdn.net/weixin_64296810?type=blog" title="听忆.-CSDN博客">听忆.-CSDN博客</a></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" height="1080" src="https://images2.imgbox.com/37/66/IulG5JT5_o.jpg" width="1200"></p> 
<p></p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:690px;"><tbody><tr><td style="text-align:center;"><em><strong><span style="color:#ff9900;">🎈众口难调🎈从心就好</span></strong></em></td></tr></tbody></table> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/615cda55fd930830dc4fee677bc1f228/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【云原生】Prometheus 服务自动发现使用详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b01820078f7ef4f0df88552915cc9827/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据结构：单调栈、单调队列</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>