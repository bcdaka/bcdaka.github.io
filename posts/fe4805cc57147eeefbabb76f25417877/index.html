<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringCloud-生产者和消费者 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/fe4805cc57147eeefbabb76f25417877/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="SpringCloud-生产者和消费者">
  <meta property="og:description" content="一、生产者和消费者的定义 在 Spring Cloud 中，术语 &#34;生产者&#34; 和 &#34;消费者&#34; 用于描述微服务架构中的两种基本角色。
角色定义生产者
Provider生产者是提供具体服务或功能的模块。它将业务逻辑封装成服务，供其他模块调用。生产者向服务注册中心注册自己提供的服务，使其他模块可以通过服务注册中心发现并调用这些服务。消费者
Consumer消费者是通过调用生产者提供的服务来完成特定功能的模块。消费者从服务注册中心获取生产者的信息，然后调用生产者的服务接口。消费者在运行时动态发现并连接到可用的生产者。 示例：一个在线商城系统中，订单服务可以被视为生产者，提供创建订单、查询订单等服务。购物车服务可以是一个消费者，它调用订单服务的创建订单服务来完成用户购物车中商品的下单。
简单在线商城购物流程服务结构图：
稍微复杂一点的在线商城系统的购物流程服务结构图：
二、生产者和消费者代码演示 1、创建父工程 在构建微服务项目时，首先需要创建一个父工程，以便统一管理依赖版本和项目属性。
我们来新建项目 SpringCloudTest。
父工程不需要太多引入，勾选 spring web 这一项即可。 删除多余内容：
pom.xml 新增 packaging 标签
2、创建服务注册中心 微服务架构中，服务注册中心是整个系统的核心，负责服务的注册与发现。使用 Spring Cloud 的Eureka 组件，可以轻松搭建一个高可用的服务注册中心。在创建 Eureka 注册中心时，需要在项目中引入相应的依赖，并通过注解标记该服务为 Eureka Server。
新建模块 euraka-server。
勾选 eureka server。 创建完成后，我们修改 eureka-server 的 pom.xml，使它的 &lt;parent&gt;&lt;/parent&gt; 标签里的内容对应父工程。
父工程：
eureka-server 的 pom.xml：
&lt;parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;SpringCloudTest&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; 同时，我们需要在父工程的 pom.xml 里添加子模块的依赖关系。 &lt;modules&gt; &lt;module&gt;eureka-server&lt;/module&gt; &lt;/modules&gt; 创建 eureka-server 的 application.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-02-06T23:19:04+08:00">
    <meta property="article:modified_time" content="2024-02-06T23:19:04+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringCloud-生产者和消费者</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、生产者和消费者的定义</h2> 
<p>在 Spring Cloud 中，术语 "生产者" 和 "消费者" 用于描述微服务架构中的两种基本角色。</p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="text-align:center;width:86px;"><strong>角色</strong></td><td style="text-align:center;width:602px;"><strong>定义</strong></td></tr><tr><td style="text-align:center;width:86px;">生产者<br> Provider</td><td style="width:602px;">生产者是提供具体服务或功能的模块。它将业务逻辑封装成服务，供其他模块调用。生产者向服务注册中心注册自己提供的服务，使其他模块可以通过服务注册中心发现并调用这些服务。</td></tr><tr><td style="text-align:center;width:86px;">消费者<br> Consumer</td><td style="width:602px;">消费者是通过调用生产者提供的服务来完成特定功能的模块。消费者从服务注册中心获取生产者的信息，然后调用生产者的服务接口。消费者在运行时动态发现并连接到可用的生产者。</td></tr></tbody></table> 
<p><strong>示例：</strong>一个在线商城系统中，订单服务可以被视为生产者，提供创建订单、查询订单等服务。购物车服务可以是一个消费者，它调用订单服务的创建订单服务来完成用户购物车中商品的下单。</p> 
<p>简单在线商城购物流程服务结构图：</p> 
<p><img alt="" class="left" height="249" src="https://images2.imgbox.com/b6/02/b0X99Eth_o.png" width="450"></p> 
<p>稍微复杂一点的在线商城系统的购物流程服务结构图：</p> 
<p><img alt="" class="left" height="356" src="https://images2.imgbox.com/fd/6e/ULwqGiPj_o.png" width="620"></p> 
<hr> 
<h2>二、生产者和消费者代码演示</h2> 
<h3>1、创建父工程</h3> 
<p>在构建微服务项目时，首先需要创建一个父工程，以便统一管理依赖版本和项目属性。</p> 
<p>我们来新建项目 SpringCloudTest。</p> 
<p><img alt="" class="left" height="598" src="https://images2.imgbox.com/bb/66/BCo2aUHL_o.png" width="666"></p> 
<p>父工程不需要太多引入，勾选 spring web 这一项即可。 </p> 
<p><img alt="" class="left" height="594" src="https://images2.imgbox.com/ff/9f/5KOfp3uq_o.png" width="666"></p> 
<p>删除多余内容：</p> 
<p><img alt="" class="left" height="602" src="https://images2.imgbox.com/81/b6/ohGbj0Ib_o.png" width="500"></p> 
<p>pom.xml 新增 packaging 标签</p> 
<p><img alt="" class="left" height="488" src="https://images2.imgbox.com/b1/2e/EOnPhfGW_o.png" width="666"></p> 
<hr> 
<h3>2、创建服务注册中心</h3> 
<p>微服务架构中，服务注册中心是整个系统的核心，负责服务的注册与发现。使用 Spring Cloud 的Eureka 组件，可以轻松搭建一个高可用的服务注册中心。在创建 Eureka 注册中心时，需要在项目中引入相应的依赖，并通过注解标记该服务为 Eureka Server。</p> 
<p>新建模块 euraka-server。</p> 
<p><img alt="" class="left" height="693" src="https://images2.imgbox.com/ad/82/CPxaeoZ7_o.png" width="666"></p> 
<p><img alt="" class="left" height="595" src="https://images2.imgbox.com/15/65/Sg6eexEj_o.png" width="666"></p> 
<p>勾选 eureka server。 </p> 
<p><img alt="" class="left" height="606" src="https://images2.imgbox.com/55/9e/FYeQJgvv_o.png" width="666"></p> 
<p>创建完成后，我们修改 eureka-server 的 pom.xml，使它的 &lt;parent&gt;&lt;/parent&gt; 标签里的内容对应父工程。</p> 
<p>父工程：</p> 
<p><img alt="" class="left" height="396" src="https://images2.imgbox.com/5a/cf/76cfOhht_o.png" width="666"></p> 
<p>eureka-server 的 pom.xml：</p> 
<pre><code class="language-XML">&lt;parent&gt;
    &lt;groupId&gt;com.example&lt;/groupId&gt;
    &lt;artifactId&gt;SpringCloudTest&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;relativePath/&gt;
&lt;/parent&gt;</code></pre> 
<p><img alt="" class="left" height="546" src="https://images2.imgbox.com/11/d9/Ix1PusdV_o.png" width="666"></p> 
<p>同时，我们需要在父工程的 pom.xml 里添加子模块的依赖关系。 </p> 
<pre><code class="language-XML">&lt;modules&gt;
    &lt;module&gt;eureka-server&lt;/module&gt;
&lt;/modules&gt;</code></pre> 
<p><img alt="" class="left" height="570" src="https://images2.imgbox.com/2c/55/5pEYQXRk_o.png" width="666"></p> 
<p>创建 eureka-server 的 application.properties 配置文件重命名为 application.yml。</p> 
<p><img alt="" class="left" height="585" src="https://images2.imgbox.com/7e/6f/To7n5Mpr_o.png" width="666"></p> 
<p>内容修改为： </p> 
<pre><code class="language-bash">#服务端口
server:
  port: 8081
#服务名称
spring:
  application:
    name: eureka-server
 
#eureka地址
eureka:
  client:
    service-url:
      defaultZone: http://127.0.0.1:8081/eureka/
    register-with-eureka: false
    fetch-registry: false
    </code></pre> 
<p><img alt="" class="left" height="337" src="https://images2.imgbox.com/4e/dc/TUW3cpdx_o.png" width="666"></p> 
<p>启动类上添加 @EnableEurekaServer 注解。 </p> 
<p><img alt="" class="left" height="374" src="https://images2.imgbox.com/af/58/8bgWUZ2o_o.png" width="666"></p> 
<p>测试启动 eurake 服务，选中 EurekaServerApplication 右键运行，启动 eurake-server 服务。确认控制台正常加载，在控制台上能够看到服务实例的信息，表示 Eureka 注册中心已成功启动。</p> 
<p><img alt="" class="left" height="183" src="https://images2.imgbox.com/ee/15/QFpTaNYt_o.png" width="666"></p> 
<p>访问我们设置的 eurake-server 服务的地址：localhost:8081，可以看到 Eureka 服务界面。</p> 
<p><img alt="" class="left" height="1137" src="https://images2.imgbox.com/e8/2a/ghLIIm8f_o.png" width="1200"></p> 
<hr> 
<h3>3、创建生产者</h3> 
<p>生产者是负责提供服务的模块，它将特定的业务逻辑封装成服务，供其他模块调用。在创建生产者时，需要定义服务接口，并使用 @RestController 或 @Service 等注解将业务逻辑发布为 RESTful API 或 RPC 服务。生产者将服务注册到 Eureka 注册中心，使消费者能够发现并调用这些服务。</p> 
<h4>① 创建生产者模块</h4> 
<p>父工程下创建模块 eureka-provider：</p> 
<p><img alt="" class="left" height="693" src="https://images2.imgbox.com/fe/52/wNXTv1Ig_o.png" width="666"></p> 
<p><img alt="" class="left" height="585" src="https://images2.imgbox.com/65/fc/tXdGHVcx_o.png" width="640"></p> 
<p>勾选 Eureka Discovery Client，用于注册到 eureka-server 服务注册中心。 </p> 
<p><img alt="" class="left" height="547" src="https://images2.imgbox.com/12/f4/Jh0tXlRq_o.png" width="600"></p> 
<p>类似于 eureka-server 服务注册中心的创建，我们需要在 pom.xml 里引入父类标签，可以参考上面eureka-server 服务注册中心创建时的写法，内容是一样的，都指向父工程。</p> 
<pre><code class="language-XML">&lt;parent&gt;
    &lt;groupId&gt;com.example&lt;/groupId&gt;
    &lt;artifactId&gt;SpringCloudTest&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;relativePath/&gt;
&lt;/parent&gt;</code></pre> 
<p><img alt="" class="left" height="466" src="https://images2.imgbox.com/a8/9f/jHS5QiPR_o.png" width="666"></p> 
<p>同理，为父工程增加新的子模块：eureka-provider：</p> 
<pre><code class="language-XML">&lt;modules&gt;
    &lt;module&gt;eureka-server&lt;/module&gt;
    &lt;module&gt;eureka-provider&lt;/module&gt;
&lt;/modules&gt;</code></pre> 
<p><img alt="" class="left" height="532" src="https://images2.imgbox.com/f7/ca/zycEiOwx_o.png" width="666"></p> 
<p>在主类上使用 @EnableEurekaClient 注解，注册该服务到 Eureka Server。</p> 
<p><img alt="" class="left" height="340" src="https://images2.imgbox.com/55/52/lR69Lo0B_o.png" width="666"></p> 
<hr> 
<h4 style="background-color:transparent;">② 添加生产者配置</h4> 
<p>将 eureka-provider 的 application.properties 配置文件重命名为 application.yml。</p> 
<p><img alt="" class="left" height="562" src="https://images2.imgbox.com/20/3d/GLkagnee_o.png" width="640"></p> 
<p>配置 eureka-provider 的相关属性，如服务端口、注册中心地址等。</p> 
<pre><code class="language-bash"># 服务器端口
server:
  port: 8082

# 配置发布服务地址
spring:
  application:
    name: eureka-provider

eureka:
  client:
    service-url:
      defaultZone: http://localhost:8081/eureka
</code></pre> 
<p><img alt="" class="left" height="354" src="https://images2.imgbox.com/ad/a2/ClMjIBNq_o.png" width="666"></p> 
<hr> 
<h4>③ 编写生产者代码 </h4> 
<p>生产者模块需要将特定的业务逻辑封装成服务，供其他模块调用。所以我们需要创建实体类并且写一些供我们调用的接口。</p> 
<p>这里是创建 eureka-provider 模块时勾选 Eureka Discovery Client 自带的代码，包含两个控制器接口类和一个实体类，我们直接拿来用就可以。</p> 
<p>实体类 User 如下：</p> 
<p><img alt="" class="left" height="379" src="https://images2.imgbox.com/c7/c6/6Rl7DWrz_o.png" width="666"></p> 
<p>控制器基类 BaseController： </p> 
<p><img alt="" class="left" height="436" src="https://images2.imgbox.com/e5/e8/UzGDtoEc_o.png" width="666"></p> 
<hr> 
<h4>④ 测试生产者服务可用</h4> 
<p>接着，我们运行应用，根据我们刚刚的配置，运行地址是 localhost:8082，我们看看访问这个地址能否显示 Hello World 的主页。如果可以访问，说明项目运行成功，我们再来访问 Eureka Server 的控制台，确保 eureka-provider 成功注册到服务注册中心。 </p> 
<p><img alt="" class="left" height="734" src="https://images2.imgbox.com/c9/b8/AiC3FLbp_o.png" width="1200"></p> 
<hr> 
<h3>4、创建消费者</h3> 
<p>消费者是通过调用生产者提供的服务来完成特定功能的模块。在创建消费者时，需要引入 Eureka 客户端依赖，以便消费者能够从服务注册中心发现并调用生产者提供的服务。通过使用 @LoadBalanced 注解配置 RestTemplate，可以实现基于服务名称的负载均衡。</p> 
<h4>① 创建消费者模块</h4> 
<p>父工程下创建模块 eureka-consumer：</p> 
<p><img alt="" class="left" height="514" src="https://images2.imgbox.com/22/39/vJPL4Gde_o.png" width="640"></p> 
<p><img alt="" class="left" height="545" src="https://images2.imgbox.com/2c/97/F9cX3jMF_o.png" width="600"></p> 
<p>勾选 Eureka Discovery Client，用于注册到 eureka-server 服务注册中心。  </p> 
<p><img alt="" class="left" height="555" src="https://images2.imgbox.com/e9/2c/2IpuRTpw_o.png" width="610"></p> 
<p>类似于 eureka-server 服务注册中心的创建，我们需要在 pom.xml 里引入父类标签，可以参考上面eureka-server 服务注册中心创建时的写法，内容是一样的，都指向父工程。</p> 
<pre><code class="language-XML">&lt;parent&gt;
    &lt;groupId&gt;com.example&lt;/groupId&gt;
    &lt;artifactId&gt;SpringCloudTest&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;relativePath/&gt;
&lt;/parent&gt;</code></pre> 
<p><img alt="" class="left" height="488" src="https://images2.imgbox.com/18/7f/5loq8Mcm_o.png" width="666"></p> 
<p>同理，为父工程增加新的子模块：eureka-consumer：</p> 
<pre><code class="language-XML">&lt;modules&gt;
    &lt;module&gt;eureka-server&lt;/module&gt;
    &lt;module&gt;eureka-provider&lt;/module&gt;
    &lt;module&gt;eureka-consumer&lt;/module&gt;
&lt;/modules&gt;</code></pre> 
<p><img alt="" class="left" height="405" src="https://images2.imgbox.com/f4/7e/thj9y4rU_o.png" width="666"></p> 
<p> 在主类上使用 @EnableEurekaClient 注解，注册该服务到 Eureka Server。</p> 
<p><img alt="" class="left" height="283" src="https://images2.imgbox.com/81/87/AaQd1gv9_o.png" width="666"></p> 
<hr> 
<h4>② 添加消费者配置</h4> 
<p>将 eureka-consumer 的 application.properties 配置文件重命名为 application.yml。</p> 
<p><img alt="" class="left" height="571" src="https://images2.imgbox.com/1a/37/jOhNDEPK_o.png" width="650"></p> 
<p>配置 eureka-consumer 的相关属性，如服务端口、注册中心地址等。 </p> 
<pre><code class="language-bash"># 服务器端口
server:
  port: 8083

# 配置发布服务地址
spring:
  application:
    name: eureka-consumer

eureka:
  client:
    service-url:
      defaultZone: http://localhost:8081/eureka
</code></pre> 
<p><img alt="" class="left" height="463" src="https://images2.imgbox.com/01/e0/hK2vuJiZ_o.png" width="666"></p> 
<hr> 
<h4>③ 编辑消费者代码 </h4> 
<p>使用 RestTemplate 或 Feign 等方式调用生产者提供的服务，确保服务的负载均衡。<br> 这里我们使用的是 RestTemplate。</p> 
<p>启动类里添加：</p> 
<pre><code class="language-java">@Bean   // 交给spring容器管理
@LoadBalanced  // 支持使用服务名称发现服务进行调用，且支持负载
public RestTemplate getRestTemplate() {
    return new RestTemplate();
}</code></pre> 
<p><img alt="" class="left" height="447" src="https://images2.imgbox.com/20/16/HBpJXEw9_o.png" width="666"></p> 
<p>创建调用生产者服务的接口类 UserController。</p> 
<p><img alt="" class="left" height="583" src="https://images2.imgbox.com/42/33/birsm2XR_o.png" width="666"></p> 
<p>UserController： </p> 
<pre><code class="language-java">package com.example.eurekaconsumer.demos.web;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

import java.util.List;

@RestController
public class UserController {

    @Autowired
    private RestTemplate restTemplate;

    @RequestMapping("/showUser")
    @ResponseBody
    public User showUser() {
        String baseUrl = "http://" + "eureka-provider" + "/user";
        User userInfo = restTemplate.getForObject(baseUrl, User.class);
        return userInfo;
    }

}</code></pre> 
<p>我们这里的接口调用地址是 /showUser，调用的是生产者服务的 /user 接口。</p> 
<hr> 
<h4>④ 测试消费者服务可用 </h4> 
<p>接着，我们运行应用，根据我们刚刚的配置，运行地址是 localhost:8083，我们看看访问这个地址能否显示 Hello World 的主页。如果可以访问，说明项目运行成功，我们再来访问 Eureka Server 的控制台，确保 eureka-consumer 成功注册到服务注册中心。 </p> 
<p><img alt="" class="left" height="996" src="https://images2.imgbox.com/6e/41/q5D8GLMJ_o.png" width="1200"></p> 
<hr> 
<h3>5、消费者调用生产者服务</h3> 
<p>生产者和消费者模块准备完成之后，我们就来演示消费者调用生产者服务的过程。</p> 
<p>首先，我们启动项目，按照 eureka-server、eureka-provier 、eureka-consumer 的顺序启动。</p> 
<p>然后，我们来直接调用生产者 eureka-provier 的用户服务接口 /user。访问地址：localhost:8082/user，可以看到成功返回给我们一个 User 对象。</p> 
<p><img alt="" class="left" height="226" src="https://images2.imgbox.com/1e/0f/nmXaG512_o.png" width="430"></p> 
<p>接着，我们来通过消费者 eureka-consumer 来调用生产者 eureka-provier 的用户服务接口，访问地址：localhost:8083/showUser，可以看到也是成功返回给我们一个 User 对象。这里的对象就是eureka-provier 的用户服务接口 /user 返回给我们的。</p> 
<p><img alt="" class="left" height="242" src="https://images2.imgbox.com/6b/0f/2lF0mqW1_o.png" width="451"></p> 
<p>以上就是消费者服务调用生产者服务的简单示例。</p> 
<hr> 
<h2>三、实现服务调用的负载均衡</h2> 
<blockquote> 
 <p>在上面代码的演示中，我们已经用到了负载均衡的措施，这一节，我就再系统描述一下 Spring Cloud 中基于 RestTemplate 实现负载均衡的具体步骤。</p> 
</blockquote> 
<p>负载均衡是一种将网络或计算负载分配到多个服务器或网络路径的技术，以实现资源的均匀利用和提高系统的可用性。在微服务架构中，负载均衡起到了关键的作用，确保请求能够被均匀分发到多个服务实例上，避免某个实例过载而影响系统性能。 </p> 
<p>在 Spring Cloud 中，RestTemplate 通过整合 Ribbon 负载均衡器，可以实现在服务消费者端的负载均衡。以下是使用 RestTemplate 进行负载均衡的基本用法：</p> 
<h3>1、引入Ribbon依赖</h3> 
<p>在消费者项目的 pom.xml 中引入 Spring Cloud Netflix Ribbon 依赖：</p> 
<pre><code class="language-XML">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre> 
<h3>2、创建RestTemplate</h3> 
<p>在消费者的配置类或者项目启动类中创建一个带有 @LoadBalanced 注解的 RestTemplate Bean，该注解启用了 Ribbon 的负载均衡功能：</p> 
<p>启动类里添加方法：</p> 
<pre><code class="language-java">@Bean   // 交给spring容器管理
@LoadBalanced  // 支持使用服务名称发现服务进行调用，且支持负载
public RestTemplate getRestTemplate() {
    return new RestTemplate();
}
</code></pre> 
<p>配置类例子：</p> 
<pre><code class="language-java">import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class AppConfig {

    @Bean
    @LoadBalanced
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
</code></pre> 
<h3>3. 使用RestTemplate进行服务调用</h3> 
<p>在消费者的服务类中使用 RestTemplate 进行服务调用。使用服务名称而不是硬编码的 URL，Ribbon 会根据服务名称自动选择可用的实例：</p> 
<pre><code class="language-java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

@Service
public class ConsumerService {

    private final RestTemplate restTemplate;

    @Autowired
    public ConsumerService(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    public String consumeService() {
        // 使用服务名称而不是具体的URL
        String serviceUrl = "http://producer-service/produce";
        return restTemplate.getForObject(serviceUrl, String.class);
    }
}
</code></pre> 
<p>上述代码中，http://producer-service 是服务提供者的服务名称，而不是具体的服务实例的URL。Ribbon 会根据负载均衡策略选择一个可用的服务实例进行调用。</p> 
<p>通过这种方式，RestTemplate 在消费者端实现了对服务提供者的负载均衡。你可以根据具体的业务需求选择不同的负载均衡策略，例如轮询、随机、权重等。</p> 
<hr> 
<h2>四、生产者和消费者知识总结</h2> 
<p><strong>生产者（Provider）：</strong></p> 
<p>生产者是提供具体服务或功能的模块，将业务逻辑封装成服务，供其他模块调用。</p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="text-align:center;width:114px;"><strong>要点</strong></td><td style="text-align:center;width:574px;"><strong>内容</strong></td></tr><tr><td style="text-align:center;width:114px;">服务注册</td><td style="width:574px;">生产者将自身注册到服务注册中心，使其他模块能够发现并调用这些服务。</td></tr><tr><td style="text-align:center;width:114px;">服务标识</td><td style="width:574px;">生产者有唯一的标识，通常是服务的名称，通过服务注册中心进行标识和发现。</td></tr><tr><td style="text-align:center;width:114px;">服务提供</td><td style="width:574px;">实现具体的服务接口，可以是RESTful API或RPC接口，对外提供服务功能。</td></tr><tr><td style="text-align:center;width:114px;">负载均衡</td><td style="width:574px;">通过服务注册中心和负载均衡器，使请求能够均匀分布到多个生产者实例，提高性能和可用性。</td></tr></tbody></table> 
<p></p> 
<p><strong>消费者（Consumer）：</strong></p> 
<p>消费者是通过调用生产者提供的服务来完成特定功能的模块，使用其他服务以满足业务需求。</p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="text-align:center;width:114px;"><strong>要点</strong></td><td style="text-align:center;width:574px;"><strong>内容</strong></td></tr><tr><td style="text-align:center;width:114px;">服务发现</td><td style="width:574px;">消费者通过服务注册中心获取生产者的实例信息，实现动态发现服务。</td></tr><tr><td style="text-align:center;width:114px;">负载均衡</td><td style="width:574px;">使用负载均衡器决定选择哪个生产者实例进行服务调用，确保请求分发均衡。</td></tr><tr><td style="text-align:center;width:114px;">服务调用</td><td style="width:574px;">通过 HTTP RESTful API 或 RPC 调用生产者的服务接口，完成特定的业务需求。</td></tr><tr><td style="text-align:center;width:114px;">动态感知</td><td style="width:574px;">消费者能够动态感知生产者实例的上线和下线，保持与服务注册中心的实时同步。</td></tr></tbody></table> 
<p></p> 
<p><strong>负载均衡与服务注册中心：</strong></p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="text-align:center;width:114px;"><strong>要点</strong></td><td style="text-align:center;width:574px;"><strong>内容</strong></td></tr><tr><td style="text-align:center;width:114px;">Ribbon<br> 负载均衡器</td><td style="width:574px;">作为客户端负载均衡器，通过配置策略决定选择哪个生产者实例进行服务调用。</td></tr><tr><td style="text-align:center;width:114px;">Eureka<br> 服务注册中心</td><td style="width:574px;">用于生产者注册和消费者服务发现，提供服务实例信息和状态。</td></tr><tr><td style="text-align:center;width:114px;">服务发现<br> 与注册</td><td style="width:574px;">生产者通过 Eureka 注册服务，消费者通过 Eureka 发现服务，实现解耦的服务调用。</td></tr><tr><td style="text-align:center;width:114px;">动态感知<br> 与适应性</td><td style="width:574px;">负载均衡器和服务注册中心能够动态感知实例变化，保持对系统变化的及时适应性。</td></tr></tbody></table> 
<p><span style="color:#4d4d4d;">以上知识点总结了生产者和消费者在微服务架构中的基本概念和操作，强调了服务注册中心和负载均衡在实现服务发现和调用过程中的关键作用。这些概念为搭建稳健、高性能的微服务系统提供了基础。</span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/85515c35a3f21fc2a4ec52ec0c39e9c0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">学生信息|基于Springboot的学生信息管理系统设计与实现(源码&#43;数据库&#43;文档)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6e630b93eef9560f72a4c4ef9c6827ef/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于TDSQL(MySQL)的简单知识分享</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>