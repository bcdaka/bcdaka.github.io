<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;--const成员及const取地址操作符重载 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/bd94cb866ea67a29b6a82eb9ca8a449d/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C&#43;&#43;--const成员及const取地址操作符重载">
  <meta property="og:description" content="前言 今天我们来了解一下const成员的基本使用,以及const取地址重载的运用
来开始今天的学习
const成员 1.基本定义, 将const修饰的“成员函数”称之为const成员函数，const修饰类成员函数，实际修饰该成员函数 隐含的*this指针，表明在该成员函数中不能对类的任何成员进行修改。
一般使用如下:
因为this是隐藏的,使用时const放在函数参数括号之后,表示const Date*this 的作用
2,使用场景 此时可以保证*this的成员不被被修改可以用在一些不修改数时的情景,但是如果是一些计算等值会变化得函数,就不能使用它,比如int operator&#43;=(const Date &amp;d)是一个错误用法
3,const的调用权限 现在有几个问题,如果在函数中同时存在const 成员函数,与非const成员函数的话下面情况,会怎麽样
1. const对象可以调用非const成员函数吗？
是不可以的,这里有权限放大的错误,如下cosnt 的对象相当于d2传过出的是const Date*this,
而printf函数是默认的Date*this函数,那么this由原来的只读不写变成了可读可写,权限放大,会出现错误 const Date d2(2024, 3, 1); d2.printf(); void printf() //Date类里的函数 { cout &lt;&lt; _year &lt;&lt; &#34; &#34; &lt;&lt; _month &lt;&lt; &#34; &#34; &lt;&lt; _day &lt;&lt; endl; } 那么怎么修改上面的错误,答案是void printf()const,将非const成员函数变成const成员函数,如此也说明了cosnt对象可以调用cosnt成员函数
2. 非const对象可以调用const成员函数吗？
是可以的,这里有权限缩小,如下cosnt 的对象相当于d2传过出的是Date*this,
而printf函数是默认的const Date*this函数,那么this由原来的可读不写变成了只读可写,权限缩小,在c&#43;&#43;中是允许的
Date d2(2024, 3, 1); d2.printf(); void printf()cosnt //Date类里的函数 { cout &lt;&lt; _year &lt;&lt; &#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-01T15:48:50+08:00">
    <meta property="article:modified_time" content="2024-05-01T15:48:50+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;--const成员及const取地址操作符重载</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>前言</h2> 
<blockquote> 
 <p>今天我们来了解一下<span style="color:#fe2c24;">const成员</span>的基本使用,以及<span style="color:#fe2c24;">const取地址重载</span>的运用</p> 
 <p>来开始今天的学习</p> 
</blockquote> 
<p><img alt="" height="1080" src="https://images2.imgbox.com/ce/e8/MVsYYIqA_o.png" width="1200"></p> 
<h2>const成员</h2> 
<h3>1.基本定义,</h3> 
<blockquote> 
 <p>将const修饰的“成员函数”称之为const成员函数，const修饰类成员函数，实际修饰该成员函数 隐含的<span style="color:#fe2c24;">*this指针</span>，表明在该成员函数中不能对类的任何成员进行修改。</p> 
 <p>一般使用如下:</p> 
 <p>因为this是隐藏的,使用时const放在函数参数括号之后,表示<span style="color:#fe2c24;">const Date*this</span> 的作用</p> 
</blockquote> 
<p></p> 
<p><img alt="" height="411" src="https://images2.imgbox.com/29/df/5lTy4nOv_o.png" width="874"></p> 
<h3>2,使用场景</h3> 
<blockquote> 
 <p></p> 
 <p>此时可以保证<span style="color:#fe2c24;">*this的成员不被被修改</span>可以用在一些不修改数时的情景,但是如果是一些计算等值会变化得函数,就不能使用它,比如<span style="color:#fe2c24;">int operator+=(const Date &amp;d)</span>是一个错误用法</p> 
</blockquote> 
<h3>3,const的调用权限</h3> 
<p>现在有几个问题,如果在函数中同时存在const  成员函数,与非const成员函数的话下面情况,会怎麽样</p> 
<p>1. const对象可以调用非const成员函数吗？</p> 
<blockquote> 
 <p>是不可以的,这里有<span style="color:#fe2c24;">权限放大</span>的错误,如下cosnt  的对象相当于d2传过出的是<span style="color:#fe2c24;">const Date*this</span>,</p> 
 <p>而printf函数是默认的<span style="color:#fe2c24;">Date*this</span>函数,那么this由原来的只读不写变成了可读可写,权限放大,会出现错误 </p> 
</blockquote> 
<pre><code>const Date d2(2024, 3, 1);
d2.printf();</code></pre> 
<pre><code>void printf() //Date类里的函数
{
	cout &lt;&lt; _year &lt;&lt; " " &lt;&lt; _month &lt;&lt; " " &lt;&lt; _day &lt;&lt; endl;

}</code></pre> 
<blockquote> 
 <p>那么怎么修改上面的错误,答案是<span style="color:#fe2c24;">void printf()const,</span>将非const成员函数变成const成员函数,如此也说明了cosnt对象可以调用cosnt成员函数</p> 
</blockquote> 
<p>2. 非const对象可以调用const成员函数吗？</p> 
<blockquote> 
 <p>是可以的,这里有<span style="color:#fe2c24;">权限缩小</span>,如下cosnt  的对象相当于d2传过出的是<span style="color:#fe2c24;">Date*this</span>,</p> 
 <p>而printf函数是默认的<span style="color:#fe2c24;">const Date*this</span>函数,那么this由原来的可读不写变成了只读可写,权限缩小,在c++中是允许的</p> 
</blockquote> 
<pre><code> Date d2(2024, 3, 1);
d2.printf();</code></pre> 
<pre><code>void printf()cosnt //Date类里的函数
{
	cout &lt;&lt; _year &lt;&lt; " " &lt;&lt; _month &lt;&lt; " " &lt;&lt; _day &lt;&lt; endl;

}</code></pre> 
<p>3. const成员函数内可以调用其它的非const对象吗吗？</p> 
<p>可以的,通过一个小例子来了解一下  <span style="color:#fe2c24;">bool Date::operator&lt;( const Date &amp;d) </span>下图是这样的现在运算符函数重载调用下面两个类的成员分别是<span style="color:#fe2c24;">一个cosnt成员,一个const成员   </span>  </p> 
<ul><li>如果是<span style="color:#fe2c24;">d1&lt;d2</span>是可以调用的,因为d1默认变成Date*this,权限平移,而d2由const Data*this变成const Date&amp;d,是权限平移,</li><li>而如果是<span style="color:#fe2c24;">d2&lt;d1</span>是不对的因为d2是const Date*this 变成Date*this  权限放大了,是会报错的</li></ul> 
<pre><code>    bool Date::operator&lt;( const Date &amp;d){}
	Date d1(2024,2,2);
	const Date d2(2024, 3, 1);
    d1&lt;d2//是可以的d1变成Date*this 权限平移
    d2&lt;d1 //d2变成Date*this 权限放大 d1缩小权限
	</code></pre> 
<blockquote> 
 <p>总结:一般我们正常使用函数时最好调用const 避免一些不必要的麻烦,除了一些要改变值的数值的一些特殊情况,<span style="color:#fe2c24;">int operator+=(const Date &amp;d)</span></p> 
</blockquote> 
<h3>4 取地址及const取地址操作符重载</h3> 
<p></p> 
<pre><code>class Date
{ 
public :
 Date* operator&amp;()
 {
 return this ;
 }
 const Date* operator&amp;()const
 {
 return this ;
 }
private :
 int _year ; // 年
 int _month ; // 月
 int _day ; // 日
};
</code></pre> 
<blockquote> 
 <p>这两个运算符一般不需要重载，使用编译器生成的默认取地址的重载即可，只有特殊情况，才需 要重载，比如想让别人获取到指定的内容,指定的特殊函数</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c6d6d9a0ea77e7abfc39a3e203bd120f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【智能助手体验】分享一款超好用的AI工具：Kimi</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5dc060e7458d4788a66cda817e13307c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">深入了解C语言中的结构体类型与内存对齐</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>