<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[C&#43;&#43;][STL源码剖析] 详解AVL树的实现 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/5988a493ee490b2f423afd645564647f/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="[C&#43;&#43;][STL源码剖析] 详解AVL树的实现">
  <meta property="og:description" content="目录
1.概念
2.实现
2.1 初始化
2.2 插入
2.2.1 旋转（重点）
左单旋
右单旋
双旋
2.❗ 双旋后，对平衡因子的处理
2.3 判断测试
完整代码：
拓展：删除
1.概念 二叉搜索树虽可以缩短查找的效率，但如果数据有序或接近有序二叉搜索树将退化为单支树，查找元素相当于在顺序表中搜索元素，效率低下。
因此，两位俄罗斯的数学家G.M.Adelson-Velskii 和E.M.Landis在1962年 发明了一种解决上述问题的方法：当向二叉搜索树中插入新结点后，如果能保证每个结点的左右 子树高度之差的绝对值不超过1(需要对树中的结点进行调整)，即可降低树的高度，从而减少平均搜索长度。
一棵AVL树或者是空树，或者是具有以下性质的二叉搜索树：
它的左右子树都是AVL树 左右子树高度之差(简称平衡因子)的绝对值不超过1(-1/0/1) 高度之差=右子树高度 - 左子树高度
AVL == 高度平衡二叉树搜索树
由于AVL树的自平衡特性，它适用于需要频繁插入和删除操作的场景，尤其是对于需要快速搜索和有序遍历的数据集合。
平衡为什么不是高度差相等，而是高度差不超过 1？
为了涵盖更多的情况，例如为节点个数为 4 如下，高度差 1 也相对平衡了
为什么 满二叉树和 AVL 树是同一个 level？
增删查改：高度次-&gt;O（logN）
最后一 h 层有 2^(h-1)个节点
满二叉树 2^h-1=N
AVL 树 2^h-X=N //最后一行还存在缺失
X 范围：[1, 2^(h-1)-1]
满二叉树和 AVL 树 在量级上都是约等于 log N 的
2.实现 2.1 初始化 AVL树的节点定义包括以下几个属性：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-25T11:29:18+08:00">
    <meta property="article:modified_time" content="2024-07-25T11:29:18+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[C&#43;&#43;][STL源码剖析] 详解AVL树的实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#1.%E6%A6%82%E5%BF%B5" rel="nofollow">1.概念</a></p> 
<p id="GUJoc-toc" style="margin-left:40px;"><a href="#GUJoc" rel="nofollow">2.实现</a></p> 
<p id="MsBPo-toc" style="margin-left:80px;"><a href="#MsBPo" rel="nofollow">2.1 初始化</a></p> 
<p id="XzT9M-toc" style="margin-left:80px;"><a href="#XzT9M" rel="nofollow">2.2 插入</a></p> 
<p id="SzxN4-toc" style="margin-left:80px;"><a href="#SzxN4" rel="nofollow">2.2.1 旋转（重点）</a></p> 
<p id="t6Eey-toc" style="margin-left:120px;"><a href="#t6Eey" rel="nofollow">左单旋</a></p> 
<p id="XoZBG-toc" style="margin-left:120px;"><a href="#XoZBG" rel="nofollow">右单旋</a></p> 
<p id="xIR2a-toc" style="margin-left:120px;"><a href="#xIR2a" rel="nofollow">双旋</a></p> 
<p id="oaH60-toc" style="margin-left:120px;"><a href="#oaH60" rel="nofollow">2.❗ 双旋后，对平衡因子的处理</a></p> 
<p id="Coyyq-toc" style="margin-left:80px;"><a href="#Coyyq" rel="nofollow">2.3 判断测试</a></p> 
<p id="pO44V-toc" style="margin-left:80px;"><a href="#pO44V" rel="nofollow">完整代码：</a></p> 
<p id="JiR9w-toc" style="margin-left:80px;"><a href="#JiR9w" rel="nofollow">拓展：删除</a></p> 
<hr id="hr-toc"> 
<h3 style="background-color:transparent;">1.概念</h3> 
<p>二叉搜索树虽可以缩短查找的效率，但<strong>如果数据有序或接近有序二叉搜索树将退化为单支树，查找元素相当于在顺序表中搜索元素，效率低下</strong>。</p> 
<p id="ud2bc1ef2">因此，两位俄罗斯的数学家G.M.Adelson-Velskii 和E.M.Landis在1962年 发明了一种解决上述问题的方法：当向二叉搜索树中插入新结点后，如果能保证每个结点的左右 子树<strong>高度之差的绝对值不超过</strong>1(需要对树中的结点进行调整)，即可降低树的高度，从而减少平均搜索长度。</p> 
<p id="u1682b7be">一棵AVL树或者是空树，或者是具有以下性质的二叉搜索树：</p> 
<ul><li id="u24ced5c5"><strong>它的左右子树都是AVL树 </strong></li><li id="u17e63e34"><span style="color:#4da8ee;"><strong>左右子树高度之差(简称平衡因子)的绝对值不超过1(-1/0/1)</strong></span></li></ul> 
<p id="u739cfebe"><span style="color:#1c7892;">高度之差=右子树高度 - 左子树高度</span></p> 
<p id="u13259c79"></p> 
<p class="img-center"><img alt="" height="374" id="u1ac0d70b" src="https://images2.imgbox.com/40/23/HNhz15HC_o.png" width="623"></p> 
<p id="u1323bfa1">AVL == 高度平衡二叉树搜索树</p> 
<p id="ud36f6b1d">由于AVL树的自平衡特性，它<strong>适用于需要频繁插入和删除操作的场景</strong>，尤其是对于需要快速搜索和有序遍历的数据集合。</p> 
<blockquote> 
 <p id="u9be22b79">平衡为什么不是高度差相等，而是高度差不超过 1？</p> 
</blockquote> 
<p id="ueee8b2bb">为了涵盖更多的情况，例如为节点个数为 4 如下，高度差 1 也相对平衡了</p> 
<p id="ud0121e50"></p> 
<p class="img-center"><img alt="" height="212" id="uc4b86e5d" src="https://images2.imgbox.com/8d/45/GKUSf97L_o.png" width="497"></p> 
<blockquote> 
 <p id="u350afe47">为什么 满二叉树和 AVL 树是同一个 level？</p> 
</blockquote> 
<p id="u9f651fc6">增删查改：高度次-&gt;O（logN）</p> 
<p id="ucdc8a1a2">最后一 h 层有 2^(h-1)个节点</p> 
<blockquote> 
 <p id="udb3d9821">满二叉树 2^h-1=N</p> 
 <p id="u3b8801f4">AVL 树 2^h-X=N //最后一行还存在缺失</p> 
 <p id="u6bbc9f3e">X 范围：[1, 2^(h-1)-1]</p> 
</blockquote> 
<p id="u3bfa87c3">满二叉树和 AVL 树 在量级上都是约等于 log N 的</p> 
<h3 id="GUJoc">2.实现</h3> 
<h4 id="MsBPo">2.1 初始化</h4> 
<p id="uc020377f">AVL树的节点定义包括以下几个属性：</p> 
<ul><li id="u67d40da0">值：每个节点存储的值，可以是任意类型，通常是一个关键字或数据。</li><li id="uf53769c9">左子节点指针：指向当前节点的左子节点的指针。左子节点的值应该小于或等于当前节点的值。</li><li id="uaf5dc333">右子节点指针：指向当前节点的右子节点的指针。右子节点的值应该大于当前节点的值。</li><li id="ucc006c50"><span style="color:#4da8ee;">父节点指针</span>：指向当前节点的父节点的指针。根节点的父节点指针为空。（为了便于后面更好的更新设计的）</li><li id="u75c19a39"><span style="color:#4da8ee;">平衡因子</span>：表示当前节点的左子树高度和右子树高度之差。平衡因子可以为-1、0或1。</li></ul> 
<p id="u3297cf9b">下面是一个示例代码来定义一个AVL树的节点结构：</p> 
<pre id="hd9Bi"><code>template&lt;class K, class V&gt;
struct AVLTreeNode
{
	pair&lt;K, V&gt; _kv;
	AVLTreeNode&lt;K, V&gt;* _left;
	AVLTreeNode&lt;K, V&gt;* _right;
	AVLTreeNode&lt;K, V&gt;* _parent;
	int _bf;

	AVLTreeNode(const pair&lt;K, V&gt;&amp; kv)
		:_kv(kv)
		,_left(nullptr)
		,_right(nullptr)
		,_parent(nullptr)
		,_bf(0) //balance factor
	{}
};</code></pre> 
<h4 id="XzT9M">2.2 插入</h4> 
<p id="ubc447356">AVL树就是在二叉搜索树的基础上引入了平衡因子，因此AVL树也可以看成是二叉搜索树。那么AVL树的插入过程可以分为两步：</p> 
<ol><li id="u4397c094"><strong>按照二叉搜索树的方式插入新节点</strong></li><li id="u644f91d0"><span style="color:#4da8ee;"><strong>调整节点的平衡因子</strong></span></li></ol> 
<pre id="Kn2dz"><code>template&lt;class K, class V&gt;
class AVLTree
{
	typedef AVLTreeNode&lt;K, V&gt; Node;
public:
	bool Insert(const pair&lt;K, V&gt;&amp; kv)
	{//
		if (_root == nullptr)
		{
			_root = new Node(kv);
			return true;
		}
      //搜索找到位置
		Node* cur = _root;
		while (cur)
		{
			if (cur-&gt;_kv.first &lt; kv.first)
			{
				parent = cur;
				cur = cur-&gt;_right;//小于就右移
			}
			else if (cur-&gt;_kv.first &gt; kv.first)
			{
				parent = cur;
				cur = cur-&gt;_left;
			}
			else
			{
				return false;
			}
		}//找到一个为空的位置了</code></pre> 
<p id="u6dcb0464">生成支点，判断插入</p> 
<pre id="DJ0bl"><code>cur = new Node(kv);
		if (parent-&gt;_kv.first &lt; kv.first)
		{
			parent-&gt;_right = cur;
		}
		else
		{
			parent-&gt;_left = cur;
		}
		cur-&gt;_parent = parent;//再指回去</code></pre> 
<p id="u0512423d">插入这部分代码倒是没问题，<span style="color:#4da8ee;">难的是新节点插入后，AVL树的平衡性可能会遭到破坏</span>，此时就需要更新平衡因子，并检测是否破坏了AVL树，破坏了AVL树就需要旋转调整再次变成AVL树。</p> 
<p id="u2352b5cf">如何根据这三种情况来实现插入和对高度的管理？</p> 
<p id="uad9d27d1">新增支点：<span style="color:#4da8ee;"><strong>右子树高度++，左子树高度--</strong></span></p> 
<p id="u9c17ed05">插入会对祖先产生影响，平衡因子为 0 了，就再不会对上面的祖先产生影响了，<span style="color:#4da8ee;">变 0 就平衡了</span></p> 
<p id="ueba9c013"></p> 
<p class="img-center"><img alt="" height="803" id="u6b47abc5" src="https://images2.imgbox.com/fc/b4/2fHMtAK9_o.jpg" width="1200"></p> 
<p id="u3bbf5522">对以上插入情况，分析可知</p> 
<p id="ud8a5b108"><span style="color:#fe2c24;">是否继续向上更新依旧<strong>：子树的高度是否变化</strong></span></p> 
<ol><li id="ua76a18d0">parent-&gt;<strong>_bf == 0</strong>，说明之前parent-&gt;_bf是1或者-1，说明之前parent一边高一边低，而这次的插入是把矮的那边填上了，parent所在子树高度不变，<strong>不需要往上继续更新</strong>。</li><li id="u57ba52bc">parent-&gt;<strong>_bf == 1 或者 -1</strong>，说明之前parent-&gt;_bf为0，两边一样高，现在插入使一边变得更高了，parent所在子树高度变了，<strong>继续往上更新</strong>。</li><li id="u323d18b6">parent-&gt;<strong>_bf == 2 或者 -2</strong>，说明之前parent-&gt;_bf是1或者-1，现在插入导致严重不平衡，违反规则，就地处理—&gt;<strong>旋转</strong>。</li></ol> 
<blockquote> 
 <p id="u08acf1ae">什么时候结束呢？</p> 
</blockquote> 
<p id="uc5edcb73">_bf==0 或者更新到了根节点的时候</p> 
<p id="ucb2c5c4b">实现平衡因子的更新</p> 
<pre id="vYLOU"><code>// ... 控制平衡
		// 更新平衡因子
		while (parent)
		{
			if (cur == parent-&gt;_left)
			{
				parent-&gt;_bf--;
			}
			else // if (cur == parent-&gt;_right)
			{
				parent-&gt;_bf++;
			}
        //判断处理
			if (parent-&gt;_bf == 0)
			{
				// 更新结束
				break;
			}
			else if (parent-&gt;_bf == 1 || parent-&gt;_bf == -1)
			{
				// 继续往上更新
				cur = parent;
				parent = parent-&gt;_parent;
                //回指父指针作用的体现，实现上移了
			}
			else if (parent-&gt;_bf == 2 || parent-&gt;_bf == -2)
			{
				// 子树不平衡了，需要旋转
				if (parent-&gt;_bf == 2 || cur-&gt;bf == 1)
				{
					RotateL(parent);
				}
				break;
			}
			else
			{
				assert(false);
			}
		}
		return true;
	}</code></pre> 
<p id="ua4b2e4b2">接下来我们来看看旋转的实现</p> 
<h4 id="SzxN4">2.2.1 旋转（重点）</h4> 
<h5 id="t6Eey" style="background-color:transparent;">左单旋</h5> 
<div class="csdn-video-box" data-report-view='{"spm":"3001.10261","extra":{"id":"Z0vMqyyP-1721878147409"}}'> 
 <iframe id="Z0vMqyyP-1721878147409" frameborder="0" src="https://live.csdn.net/v/embed/412268" allowfullscreen="true" data-mediaembed="csdn"></iframe> 
 <p>[C++] 详解AVL树左旋的实现~</p> 
</div> 
<p>  </p> 
<p class="img-center"><img alt="" height="259" id="ued40169d" src="https://images2.imgbox.com/66/b7/j7jWXrBs_o.png" width="972"></p> 
<p id="u890b2169">旋转的时候需要注意的问题：</p> 
<ol><li id="ubb0ebb0b"><span style="color:#4da8ee;">保持他是搜索树</span></li><li id="u9601bb77">变成<span style="color:#4da8ee;">平衡</span>树且降低这个子树的高度</li></ol> 
<p id="u550ddb05">核心操作：</p> 
<pre id="Fi0TZ"><code>parent-&gt;right=cur-&gt;left;
cur-&gt;left=parent;</code></pre> 
<p id="u70b697bb">如下情况都会用到左旋：</p> 
<p id="uc52e9268"></p> 
<p class="img-center"><img alt="" height="253" id="iE4lg" src="https://images2.imgbox.com/e7/1b/CM0QxJcb_o.png" width="766"></p> 
<p id="u0d63bd9d"></p> 
<p class="img-center"><img alt="" height="507" id="kWHLn" src="https://images2.imgbox.com/e1/cd/0BPrWEJh_o.png" width="769"></p> 
<p id="uf2ebeede">代码：</p> 
<pre id="Ak6Bg"><code>void RotateL(Node* parent)
{
    // 保存父节点的右子节点
    Node* cur = parent-&gt;_right;
    // 保存右子节点的左子节点
    Node* curleft = cur-&gt;_left;
    // 利用区间性，将子左给父右
    parent-&gt;_right = curleft;
    if (curleft)
    {
        // 将右子节点的左子节点作为父节点的右子节点
        curleft-&gt;_parent = parent;
    }

    // 将父节点作为右子节点的左子节点
    cur-&gt;_left = parent;
    // 保存父节点的父节点
    Node* ppnode = parent-&gt;_parent;

    // 将父节点的父节点指向右子节点
    parent-&gt;_parent = cur;

    // 判断原父节点是否为根节点
    if (parent == _root)
    {
        // 更新根节点为右子节点
        _root = cur;
        // 将新根节点的父指针置为空
        cur-&gt;_parent = nullptr;
    }
    else
    {
        // 判断原父节点是其父节点的左子节点还是右子节点
        if (ppnode-&gt;_left == parent)
        {
            // 更新父节点的左子节点为右子节点
            ppnode-&gt;_left = cur;
        }
        else
        {
            // 更新父节点的右子节点为右子节点
            ppnode-&gt;_right = cur;
        }

        // 更新右子节点的父指针为父节点的父节点
        cur-&gt;_parent = ppnode;
    }

    // 将父节点和右子节点的平衡因子都设置为0，表示树已经平衡
    parent-&gt;_bf = cur-&gt;_bf = 0;
}</code></pre> 
<h5 id="XoZBG">右单旋</h5> 
<p id="u57f0357c"></p> 
<p class="img-center"><img alt="" height="381" id="uc08916f0" src="https://images2.imgbox.com/d7/cb/rTcfD16R_o.png" width="833"></p> 
<p id="u700650f5">代码：</p> 
<pre id="QrzHO"><code>void RotateR(Node* parent)
{
    // 获取父节点的左子节点
    Node* cur = parent-&gt;_left;
    // 获取左子节点的右子节点
    Node* curright = cur-&gt;_right;

    // 将左子节点的右子节点作为父节点的左子节点
    parent-&gt;_left = curright;
    if (curright)
    {
        // 更新左子节点的右子节点的父指针
        curright-&gt;_parent = parent;
    }

    // 引入父父节点
    Node* ppnode = parent-&gt;_parent;

    // 将父节点作为左子节点的右子节点
    cur-&gt;_right = parent;
    // 更新父节点的父指针
    parent-&gt;_parent = cur;

    // 判断原父节点是否为根节点
    if (ppnode == nullptr)
    {
        // 更新根节点为左子节点
        _root = cur;
        // 将新根节点的父指针置为空
        cur-&gt;_parent = nullptr;
    }
    else
    {
        // 判断原父节点是其父节点的左子节点还是右子节点
        if (ppnode-&gt;_left == parent)
        {
            // 更新父节点的左子节点为左子节点
            ppnode-&gt;_left = cur;
        }
        else
        {
            // 更新父节点的右子节点为左子节点
            ppnode-&gt;_right = cur;
        }

        // 更新左子节点的父指针
        cur-&gt;_parent = ppnode;
    }

    // 将父节点和左子节点的平衡因子都设置为0，表示树已经平衡
    parent-&gt;_bf = cur-&gt;_bf = 0;
}</code></pre> 
<h5 id="xIR2a">双旋</h5> 
<p id="u7e780120">左右旋转：插入的两种情况，看的是折线情况</p> 
<blockquote> 
 <p id="u2c159306">直线：单旋 2 1 同号</p> 
 <p id="ue4ce0c55"><span style="color:#4da8ee;">折线</span>：双旋 2 -1</p> 
</blockquote> 
<p id="u5dd30a60"><strong>旋转判断</strong></p> 
<p id="u150795c7">根据 parent 和 cur 的平衡因子，实现对使用哪种旋转的判断</p> 
<pre id="ja1TE"><code>	else if (parent-&gt;_bf == 2 || parent-&gt;_bf == -2)
			{
				// 子树不平衡了，需要旋转
				if (parent-&gt;_bf == 2 &amp;&amp; cur-&gt;_bf == 1)
				{
					RotateL(parent);
				}
				else if (parent-&gt;_bf == -2 &amp;&amp; cur-&gt;_bf == -1)
				{
					RotateR(parent);
				}
                    //异号
				else if (parent-&gt;_bf == 2 &amp;&amp; cur-&gt;_bf == -1)
				{
					RotateRL(parent);
				}
				else if (parent-&gt;_bf == -2 &amp;&amp; cur-&gt;_bf == 1)
				{
					RotateLR(parent);
				}

				break;
			}
			else
			{
				assert(false);
			}
		}</code></pre> 
<p id="u88a1e984"></p> 
<p id="u9de4c4fd">1.</p> 
<p id="ufac221ff"></p> 
<p class="img-center"><img alt="" height="171" id="u5868c2ce" src="https://images2.imgbox.com/b4/0b/o2dEeGxS_o.png" width="626"></p> 
<p id="u9eec565f"></p> 
<p class="img-center"><img alt="" height="83" id="ua4c40857" src="https://images2.imgbox.com/dd/43/N0kSYJep_o.png" width="223"></p> 
<p id="u79138c32">双旋的结果本质：比 60 小 ，比 30 大的小插入 到 30 下面，找到一个区间中的点</p> 
<h5 id="oaH60">2.❗ 双旋后，对平衡因子的处理</h5> 
<p id="u17918563">3.h==0 60 本身就是插入的</p> 
<p id="ue4dbe8c7">三种情况，关心 60 的值是-1 0 1</p> 
<p id="ud4575e6d">不存在其他奇怪的情况，<strong>分别做了 60 的左右</strong></p> 
<p id="uc7fcad3b"></p> 
<p class="img-center"><img alt="" height="692" id="s7iUa" src="https://images2.imgbox.com/ad/49/WW9RhTT6_o.png" width="1200"></p> 
<p id="u99a4e49f">以 RL 为例实现代码：</p> 
<pre id="mkb3u"><code>void RotateRL(Node* parent)
	{
		Node* cur = parent-&gt;_right;
		Node* curleft = cur-&gt;_left;
		int bf = curleft-&gt;_bf;

		RotateR(parent-&gt;_right);
		RotateL(parent);
//举例思考填写
		if (bf == 0)
		{
			cur-&gt;_bf = 0;
			curleft-&gt;_bf = 0;
			parent-&gt;_bf = 0;
		}
		else if (bf == 1)
		{
			cur-&gt;_bf = 0;
			curleft-&gt;_bf = 0;
			parent-&gt;_bf = -1;
		}
		else if (bf == -1)
		{
			cur-&gt;_bf = 1;
			curleft-&gt;_bf = 0;
			parent-&gt;_bf = 0;
		}
		else
		{
			assert(false);
		}
	}</code></pre> 
<p id="u47c98681">LR 旋转：</p> 
<p id="uefd42d4d"><strong>平衡因子是根据</strong><strong> curright 初始情况</strong><strong>，经过旋转后的图</strong><strong>分析分类</strong><strong>后得带的</strong></p> 
<p id="ue451ee24"></p> 
<p class="img-center"><img alt="" height="607" id="u737d5b60" src="https://images2.imgbox.com/f7/c6/l4DVNqVl_o.png" width="971"></p> 
<p id="ub6083276">⭕具体而言，先左单旋再右单旋的操作步骤如下：</p> 
<blockquote> 
 <ul><li id="uee8bc075">首先获取节点C的左子节点A（subL）和节点A的右子节点D（subLR）；</li><li id="ubb796a15">然后对节点A进行左单旋（RotateL），此时节点C的左子节点应为节点D，节点D的右子节点应为节点A；</li><li id="u1ab75a3e">最后对节点C进行右单旋（RotateR），此时节点D成为新的子树头节点，节点C成为节点D的右子节点。</li></ul> 
</blockquote> 
<p id="u1adba94d">最后一部分使用了if语句判断旋转后各个节点的平衡因子，并进行相应的调整，以便使AVL树保持平衡。</p> 
<blockquote> 
 <ul><li id="ub328a036">如果节点D的平衡因子为1，说明节点D的左子树比右子树高，需要进行右旋操作，这一次旋转中节点C和节点A都向右移动了一位，而节点D的平衡因子变为0，节点A和节点C的平衡因子都变为-1；</li><li id="u01974f5e">如果节点D的平衡因子为-1，说明节点D的右子树比左子树高，需要进行左旋操作，这一次旋转中节点C和节点A都向左移动了一位，而节点D的平衡因子变为0，节点A和节点C的平衡因子都变为1；</li><li id="u083fe53d">如果节点D的平衡因子为0，说明节点D的左右子树高度相等，不需要进行旋转操作，各个节点的平衡因子均设置为0；</li><li id="u1dc59e32">如果节点D的平衡因子不是1、-1或者0，则说明AVL树已经失去了平衡，这是一个不合法的状态，应该立即报错退出程序。</li><li id="ub4032934">经过这两次旋转后，AVL树重新保持了平衡性和有序性。</li></ul> 
</blockquote> 
<pre id="MA5xS"><code>void RotateLR(Node* parent)
	{
		Node* cur = parent-&gt;_left;
		Node* curright = cur-&gt;_right;
		int bf = curright-&gt;_bf;

		RotateL(parent-&gt;_left);
		RotateR(parent);
//解耦合，旋转bf 重新定义
		if (bf == 0)
		{
			parent-&gt;_bf = 0;
			cur-&gt;_bf = 0;
			curright-&gt;_bf = 0;
		}
		else if (bf == -1)
		{
			parent-&gt;_bf = 1;
			cur-&gt;_bf = 0;
			curright-&gt;_bf = 0;
		}
		else if (bf == 1)
		{
			parent-&gt;_bf = 0;
			cur-&gt;_bf = -1;
			curright-&gt;_bf = 0;
		}
	}</code></pre> 
<h4 id="Coyyq">2.3 判断测试</h4> 
<blockquote> 
 <p id="uad07a068">test 发现不是根，父亲又是空，是为什么呢？</p> 
</blockquote> 
<p id="uc70ea9f4">树的结构出问题了，某次旋转出事了</p> 
<blockquote> 
 <p id="uc7783d55">发现错误就是我们的晋级关键时刻</p> 
</blockquote> 
<p id="ub636a445">我们可以根据AVL树的性质来测试</p> 
<p id="u359e5939">一棵AVL树或者是空树，或者是具有以下性质的二叉搜索树：</p> 
<ol><li id="u33e88d97"><strong>它的</strong><strong>左右子树都是AVL树</strong></li><li id="u4d76cccc"><strong>即<span style="color:#4da8ee;">左右子树</span></strong><span style="color:#4da8ee;"><strong>高度之差(简称平衡因子)的绝对值不超过1</strong><strong>(-1/0/1）</strong></span></li></ol> 
<p id="u8c75b3c8">求高度这有个对重载函数的巧妙使用:</p> 
<blockquote> 
 <p id="ud607a9e4">当传入的节点<code>root</code>是<code>nullptr</code>（空指针）时，说明到达了树的叶子节点的下一层，此时返回高度为0，因为空树的高度定义为0。</p> 
</blockquote> 
<pre id="Rogvn"><code>int Height()
	{
		return Height(_root);
	}

	int Height(Node* root)
	{
		if (root == nullptr)
			return 0;

		int leftHeight = Height(root-&gt;_left);
		int rightHeight = Height(root-&gt;_right);

		return leftHeight &gt; rightHeight ? leftHeight + 1 : rightHeight + 1;
	}</code></pre> 
<p id="u741c357a">对于平衡的测试：</p> 
<p id="u86db3fe1"><code>IsBalance(Node* root)</code> 是一个递归函数，其工作流程如下：</p> 
<blockquote> 
 <ol><li id="u9e714c43"><strong>基本情况</strong>：如果 <code>root</code> 是 <code>nullptr</code>，意味着到达了一个空节点，那么认为该子树是平衡的，返回 <code>true</code>。</li><li id="u6d6141ff"><strong>计算子树高度</strong>：计算当前节点的左子树和右子树的高度，分别存储在 <code>leftHight</code> 和 <code>rightHight</code> 变量中。</li><li id="uf754c504"><strong>检查平衡因子</strong>：<code>root-&gt;_bf</code> 表示当前节点的平衡因子，即右子树的高度减去左子树的高度。如果计算出的实际高度差与存储的<span style="color:#4da8ee;">平衡因子不匹配</span>，那么输出错误信息并返回 <code>false</code>。这一步是为了验证树的内部数据一致性。</li><li id="ucbdf80a1"><strong>检查子树平衡性</strong>：检查当前节点的左右子树高度差的绝对值是否小于2（即是否平衡）。如果是，<span style="color:#4da8ee;">则继续递归检查左右子树是否平衡</span>。如果所有的子树都平衡，那么整个树也是平衡的。</li></ol> 
</blockquote> 
<pre id="GqrOv"><code>bool IsBalance()
	{
		return IsBalance(_root);
	}

	bool IsBalance(Node* root)
	{
		if (root == nullptr)
			return true;

		int leftHight = Height(root-&gt;_left);
		int rightHight = Height(root-&gt;_right);

		if (rightHight - leftHight != root-&gt;_bf)
		{
			cout &lt;&lt; "平衡因子异常:" &lt;&lt;root-&gt;_kv.first&lt;&lt;"-&gt;"&lt;&lt; root-&gt;_bf &lt;&lt; endl;
			return false;
		}

		return abs(rightHight - leftHight) &lt; 2
			&amp;&amp; IsBalance(root-&gt;_left)
			&amp;&amp; IsBalance(root-&gt;_right);
	}

private:
	Node* _root = nullptr;

public:
	int _rotateCount = 0;
};</code></pre> 
<p id="u4cebb106">手动制作条件断点，一定要注意父亲回指的设定</p> 
<pre id="gC2Ac"><code>  // 更新父节点的父指针
    parent-&gt;_parent = cur;</code></pre> 
<p id="uf3e98f3b">对于这个纰漏的处理，来检验和调试这个问题</p> 
<p id="ue106eb30">测试：</p> 
<pre id="Wx6yC"><code>int main()
{
    AVLTree&lt;int, int&gt; tree;

    // 插入一些节点
    tree.Insert({10, 10});
    tree.Insert({20, 20});
    tree.Insert({30, 30});
    tree.Insert({40, 40});
    tree.Insert({50, 50});

    cout &lt;&lt; "树高度: " &lt;&lt; tree.Height() &lt;&lt; endl;
    cout &lt;&lt; "树是否平衡: " &lt;&lt; (tree.IsBalance() ? "是" : "否") &lt;&lt; endl;

    // 插入更多节点来触发旋转
    tree.Insert({25, 25});
    tree.Insert({5, 5});
    tree.Insert({15, 15});

    cout &lt;&lt; "树高度: " &lt;&lt; tree.Height() &lt;&lt; endl;
    cout &lt;&lt; "树是否平衡: " &lt;&lt; (tree.IsBalance() ? "是" : "否") &lt;&lt; endl;

    return 0;
}</code></pre> 
<p id="ucb8666f9"></p> 
<p class="img-center"><img alt="" height="196" id="u2650b5a8" src="https://images2.imgbox.com/8f/7a/8nxZa30b_o.png" width="637"></p> 
<p id="u91200f59">发现错误：</p> 
<p id="u83b2a7b0"></p> 
<p class="img-center"><img alt="" height="313" id="u77b6c486" src="https://images2.imgbox.com/ce/4b/STbbTxR5_o.png" width="1200"></p> 
<p id="u031d3e00"><strong>拼写错误修正</strong>：例如 <code><strong>rotateCount</strong></code> 应为 <code><strong>_rotateCount</strong></code>。parent 不要拼写掉 e。</p> 
<p id="u7ad68e93"></p> 
<p class="img-center"><img alt="" height="101" id="ucb0a63b6" src="https://images2.imgbox.com/f7/42/UTtAL6Ve_o.png" width="953"></p> 
<p id="u0ef2d9cd">目前还不知道是为什么，重写了一遍，就跑起来了</p> 
<h4 id="pO44V">完整代码：</h4> 
<pre id="seTIH"><code>#pragma once
#include&lt;iostream&gt;
#include&lt;assert.h&gt;
using namespace std;

template&lt;class K, class V&gt;
struct AVLTreeNode
{
    pair&lt;K, V&gt; _kv;
    AVLTreeNode&lt;K, V&gt;* _left;
    AVLTreeNode&lt;K, V&gt;* _right;
    AVLTreeNode&lt;K, V&gt;* _parent;
    int _bf; // balance factor

    AVLTreeNode(const pair&lt;K, V&gt;&amp; kv)
        : _kv(kv), _left(nullptr), _right(nullptr), _parent(nullptr), _bf(0)
    {}
};

template&lt;class K, class V&gt;
class AVLTree
{
    typedef AVLTreeNode&lt;K, V&gt; Node;
public:
    bool Insert(const pair&lt;K, V&gt;&amp; kv)
    {
        if (_root == nullptr)
        {
            _root = new Node(kv);
            return true;
        }

        Node* parent = nullptr;
        Node* cur = _root;
        while (cur)
        {
            if (cur-&gt;_kv.first &lt; kv.first)
            {
                parent = cur;
                cur = cur-&gt;_right;
            }
            else if (cur-&gt;_kv.first &gt; kv.first)
            {
                parent = cur;
                cur = cur-&gt;_left;
            }
            else
            {
                return false;
            }
        }

        cur = new Node(kv);
        if (parent-&gt;_kv.first &lt; kv.first)
        {
            parent-&gt;_right = cur;
        }
        else
        {
            parent-&gt;_left = cur;
        }
        cur-&gt;_parent = parent;

        // Update balance factor
        while (parent)
        {
            if (cur == parent-&gt;_left)
            {
                parent-&gt;_bf--;
            }
            else
            {
                parent-&gt;_bf++;
            }

            if (parent-&gt;_bf == 0)
                break;
            else if (parent-&gt;_bf == 1 || parent-&gt;_bf == -1)
            {
                cur = parent;
                parent = parent-&gt;_parent;
            }
            else if (parent-&gt;_bf == 2 || parent-&gt;_bf == -2)
            {
                if (parent-&gt;_bf == 2 &amp;&amp; cur-&gt;_bf == 1)
                    RotateL(parent);
                else if (parent-&gt;_bf == -2 &amp;&amp; cur-&gt;_bf == -1)
                    RotateR(parent);
                else if (parent-&gt;_bf == 2 &amp;&amp; cur-&gt;_bf == -1)
                    RotateRL(parent);
                else if (parent-&gt;_bf == -2 &amp;&amp; cur-&gt;_bf == 1)
                    RotateLR(parent);
                break;
            }
            else
            {
                assert(false);
            }
        }
        return true;
    }

    void RotateL(Node* parent)
    {
        ++_rotateCount;
        Node* cur = parent-&gt;_right;
        Node* curleft = cur-&gt;_left;

        parent-&gt;_right = curleft;
        if (curleft)
        {
            curleft-&gt;_parent = parent;
        }

        cur-&gt;_left = parent;
        Node* ppnode = parent-&gt;_parent;
        parent-&gt;_parent = cur;

        if (parent == _root)
        {
            _root = cur;
            cur-&gt;_parent = nullptr;
        }
        else
        {
            if (ppnode-&gt;_left == parent)
            {
                ppnode-&gt;_left = cur;
            }
            else
            {
                ppnode-&gt;_right = cur;
            }
            cur-&gt;_parent = ppnode;
        }

        parent-&gt;_bf = cur-&gt;_bf = 0;
    }

    void RotateR(Node* parent)
    {
        ++_rotateCount;
        Node* cur = parent-&gt;_left;
        Node* curright = cur-&gt;_right;

        parent-&gt;_left = curright;
        if (curright)
            curright-&gt;_parent = parent;

        cur-&gt;_right = parent;
        Node* ppnode = parent-&gt;_parent;
        parent-&gt;_parent = cur;

        if (ppnode == nullptr)
        {
            _root = cur;
            cur-&gt;_parent = nullptr;
        }
        else
        {
            if (ppnode-&gt;_left == parent)
            {
                ppnode-&gt;_left = cur;
            }
            else
            {
                ppnode-&gt;_right = cur;
            }
            cur-&gt;_parent = ppnode;
        }

        parent-&gt;_bf = cur-&gt;_bf = 0;
    }

    void RotateRL(Node* parent)
    {
        Node* cur = parent-&gt;_right;
        Node* curleft = cur-&gt;_left;
        int bf = curleft-&gt;_bf;

        RotateR(parent-&gt;_right);
        RotateL(parent);

        if (bf == 0)
        {
            cur-&gt;_bf = 0;
            curleft-&gt;_bf = 0;
            parent-&gt;_bf = 0;
        }
        else if (bf == 1)
        {
            cur-&gt;_bf = 0;
            curleft-&gt;_bf = 0;
            parent-&gt;_bf = -1;
        }
        else if (bf == -1)
        {
            cur-&gt;_bf = 1;
            curleft-&gt;_bf = 0;
            parent-&gt;_bf = 0;
        }
        else
        {
            assert(false);
        }
    }

    void RotateLR(Node* parent)
    {
        Node* cur = parent-&gt;_left;
        Node* curright = cur-&gt;_right;
        int bf = curright-&gt;_bf;

        RotateL(parent-&gt;_left);
        RotateR(parent);

        if (bf == 0)
        {
            parent-&gt;_bf = 0;
            cur-&gt;_bf = 0;
            curright-&gt;_bf = 0;
        }
        else if (bf == -1)
        {
            parent-&gt;_bf = 1;
            cur-&gt;_bf = 0;
            curright-&gt;_bf = 0;
        }
        else if (bf == 1)
        {
            parent-&gt;_bf = 0;
            cur-&gt;_bf = -1;
            curright-&gt;_bf = 0;
        }
        else
        {
            assert(false);
        }
    }

    int Height()
    {
        return Height(_root);
    }

    int Height(Node* root)
    {
        if (root == nullptr)
            return 0;
        int leftHeight = Height(root-&gt;_left);
        int rightHeight = Height(root-&gt;_right);
        return max(leftHeight, rightHeight) + 1;
    }

    bool IsBalance()
    {
        return IsBalance(_root);
    }

    bool IsBalance(Node* root)
    {
        if (root == nullptr)
            return true;

        int leftHeight = Height(root-&gt;_left);
        int rightHeight = Height(root-&gt;_right);

        if (rightHeight - leftHeight != root-&gt;_bf)
        {
            cout &lt;&lt; "平衡因子异常:" &lt;&lt; root-&gt;_kv.first &lt;&lt; "-&gt;" &lt;&lt; root-&gt;_bf &lt;&lt; endl;
            return false;
        }

        return abs(rightHeight - leftHeight) &lt; 2
            &amp;&amp; IsBalance(root-&gt;_left)
            &amp;&amp; IsBalance(root-&gt;_right);
    }

private:
    Node* _root = nullptr;

public:
    int _rotateCount = 0;
};</code></pre> 
<h4 id="JiR9w">拓展：删除</h4> 
<p id="uef1603ce">插入到 0，不用更改</p> 
<p id="u842599e0">删除到 0，还要更改</p> 
<p id="ubfd08c14">删除会更加的复杂，平衡因子的更新，旋转等等，将上面的思路总结和拓展一下，大家有兴趣可以看看如下的实现代码：</p> 
<pre id="aE3qo"><code>bool Erase(const pair&lt;T, V&gt;&amp; kv)
{
    if (_root == nullptr)
        return false;</code></pre> 
<p id="u6fe85680">首先，检查树是否为空。如果树为空，直接返回 <code>false</code>，表示删除失败。</p> 
<pre id="WS1vY"><code>    Node* parent = nullptr;
    Node* cur = _root;

    // 找到要删除的节点
    while (cur)
    {
        if (cur-&gt;_kv.first &lt; kv.first)
        {
            parent = cur;
            cur = cur-&gt;_right;
        }
        else if (cur-&gt;_kv.first &gt; kv.first)
        {
            parent = cur;
            cur = cur-&gt;_left;
        }
        else
        {
            break;
        }
    }

    if (cur == nullptr)
        return false;</code></pre> 
<p id="u21acae73">这部分代码用于在树中查找要删除的节点。通过比较当前节点 <code>cur</code> 的键值 <code>cur-&gt;_kv.first</code> 与要删除的键值 <code>kv.first</code>，决定向左子树还是右子树继续搜索。最终，<code>cur</code> 将指向要删除的节点，<code>parent</code> 是 <code>cur</code> 的父节点。如果找不到该键值，返回 <code>false</code>。</p> 
<pre id="nj9qK"><code>    // 处理删除节点的三种情况
    if (cur-&gt;_left == nullptr)
    {
        if (parent == nullptr)
        {
            _root = cur-&gt;_right;
            if (_root)
                _root-&gt;_parent = nullptr;
        }
        else
        {
            if (cur == parent-&gt;_left)
            {
                parent-&gt;_left = cur-&gt;_right;
                parent-&gt;_bf++;
            }
            else
            {
                parent-&gt;_right = cur-&gt;_right;
                parent-&gt;_bf--;
            }
            if (cur-&gt;_right)
                cur-&gt;_right-&gt;_parent = parent;
        }
    }
    else if (cur-&gt;_right == nullptr)
    {
        if (parent == nullptr)
        {
            _root = cur-&gt;_left;
            if (_root)
                _root-&gt;_parent = nullptr;
        }
        else
        {
            if (cur == parent-&gt;_left)
            {
                parent-&gt;_left = cur-&gt;_left;
                parent-&gt;_bf++;
            }
            else
            {
                parent-&gt;_right = cur-&gt;_left;
                parent-&gt;_bf--;
            }
            if (cur-&gt;_left)
                cur-&gt;_left-&gt;_parent = parent;
        }
    }
    else // 左右子树都不为空
    {
        Node* successorParent = cur;
        Node* successor = cur-&gt;_right;
        while (successor-&gt;_left)
        {
            successorParent = successor;
            successor = successor-&gt;_left;
        }
        cur-&gt;_kv = successor-&gt;_kv;
        if (successorParent-&gt;_left == successor)
        {
            successorParent-&gt;_left = successor-&gt;_right;
            successorParent-&gt;_bf++;
        }
        else
        {
            successorParent-&gt;_right = successor-&gt;_right;
            successorParent-&gt;_bf--;
        }
        if (successor-&gt;_right)
            successor-&gt;_right-&gt;_parent = successorParent;
        cur = successor;
        parent = successorParent;
    }
    delete cur;</code></pre> 
<p id="ucefe84fb">这一部分处理删除节点的三种情况：</p> 
<ol><li id="u25c2a4a6"><strong>左子树为空</strong>：直接用右子树替代删除节点。如果删除节点是根节点，直接更新根节点 <code>_root</code>。否则，更新父节点的左或右子树指针，并调整平衡因子。</li><li id="udb34a6dd"><strong>右子树为空</strong>：直接用左子树替代删除节点。如果删除节点是根节点，直接更新根节点 <code>_root</code>。否则，更新父节点的左或右子树指针，并调整平衡因子。</li><li id="u3d8be80a"><strong>左右子树都不为空</strong>：找到右子树中的最小节点（即中序后继节点），用这个节点替代当前节点。然后删除中序后继节点，并调整其父节点的指针和平衡因子。</li></ol> 
<pre id="bRe0S"><code>    // 更新平衡因子并处理旋转
    bool isLRUpdated = true;
    while (parent)
    {
        if (!isLRUpdated)
        {
            if (cur == parent-&gt;_left)
                parent-&gt;_bf++;
            else
                parent-&gt;_bf--;
        }
        isLRUpdated = false;

        if (parent-&gt;_bf == 1 || parent-&gt;_bf == -1)
            return true;
        else if (parent-&gt;_bf == 0)
        {
            cur = parent;
            parent = parent-&gt;_parent;
        }
        else if (parent-&gt;_bf == 2 || parent-&gt;_bf == -2)
        {
            Node* higherChild;
            int sign;
            if (parent-&gt;_bf &gt; 0)
            {
                sign = 1;
                higherChild = parent-&gt;_right;
            }
            else
            {
                sign = -1;
                higherChild = parent-&gt;_left;
            }

            if (higherChild-&gt;_bf == 0)
            {
                if (sign &gt; 0)
                {
                    RotateL(parent);
                    parent-&gt;_bf = 1;
                    higherChild-&gt;_bf = -1;
                }
                else
                {
                    RotateR(parent);
                    parent-&gt;_bf = -1;
                    higherChild-&gt;_bf = 1;
                }
                return true;
            }
            else if (higherChild-&gt;_bf == sign)
            {
                if (sign == 1)
                    RotateL(parent);
                else
                    RotateR(parent);
            }
            else
            {
                if (sign == 1)
                    RotateRL(parent);
                else
                    RotateLR(parent);
            }
            cur = parent;
            parent = cur-&gt;_parent;
        }
        else
        {
            assert(false);
        }
    }
    return true;
}</code></pre> 
<p id="ubc533366">这一部分用于在删除节点后更新平衡因子并处理旋转，以保持树的平衡：</p> 
<ol><li id="u75c8e0e3"><strong>平衡因子为 ±1</strong>：子树高度没有变化，直接返回。</li><li id="ua5ac4559"><strong>平衡因子为 0</strong>：子树高度减少，继续向上更新平衡因子。</li><li id="ufa190110"><strong>平衡因子为 ±2</strong>：子树严重不平衡，需要旋转。根据较高子树的平衡因子选择合适的旋转方式：</li></ol> 
<ul><li> 
  <ul><li id="ua2ea5264">如果较高子树的平衡因子为 0，进行单旋转。</li><li id="u1a4e5d6d">如果较高子树的平衡因子与父节点相同，进行单旋转。</li><li id="u58eaf48e">如果较高子树的平衡因子与父节点不同，进行双旋转。</li></ul></li></ul> 
<p id="u4f13a6bb">通过这些操作，就可以确保树在删除节点后仍然保持平衡啦</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4d8e07ba4d7fe39ef77fb31368245af8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">学Python该看什么书？10本Python好书推荐，10年程序员倾囊相授！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3a23086c723308339a0d976063da788e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据结构与算法--【数组2】力扣练习 || 双指针 / 移除元素 / 数组排序</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>