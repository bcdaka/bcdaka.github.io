<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构：链表详解 (c&#43;&#43;实现) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ebce29f665ec098035981b135f1fc591/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构：链表详解 (c&#43;&#43;实现)">
  <meta property="og:description" content="前言 对于数据结构的线性表，其元素在逻辑结构上都是序列关系，即数据元素之间有前驱和后继关系。
但在物理结构上有两种存储方式：
顺序存储结构：
使用此结构的线性表也叫 顺序表物理存储上是连续的，因此可以随机访问，时间复杂度为 O(1)
链式存储结构：
使用此结构的线性表也叫 链表物理存储上不连续，因此不支持随机访问
接下来要介绍的就是 链表。
链表分为 单向链表（单链表）与 双向链表（双链表），理解了单链表，双链表自然也明白了。
1. 什么是单链表 1.1 定义 链表由一系列的节点组成（链表中的每个元素都可称为节点），对于单链表而言，它的节点包含两部分：
数据域：存储当前节点的数据指针域：存储当前节点的下一个节点（后继节点）的地址 那么现在定义单链表 SingleList 的节点 Node：
1.2 创建 Node struct Node { int val;	// 数据域 Node* next;	// 指针域：指向的是 Node，所以类型为 Node* }; 这么定义的 Node 类只能接收数据类型为 int 的数据，对于其他类型的数据当前的类不能处理，因此为了代码的通用性，将 Node 定义为模版类：
template &lt;typename T&gt; struct Node { T val;	// 数据域 Node* next;	// 指针域 Node(T v, Node* n = nullptr) :val{ v }, next{ n } { } }; 为了方便初始化，Node 还增加了构造函数：一个节点肯定必须有数据域，但指针域可以为空（表示没有后继节点了）">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-12T23:24:36+08:00">
    <meta property="article:modified_time" content="2024-07-12T23:24:36+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构：链表详解 (c&#43;&#43;实现)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a><strong>前言</strong></h2> 
<p>对于数据结构的线性表，其元素在逻辑结构上都是序列关系，即数据元素之间有前驱和后继关系。<br> <img src="https://images2.imgbox.com/02/56/FONsiT5v_o.png" alt="在这里插入图片描述"></p> 
<p>但在物理结构上有两种存储方式：</p> 
<ul><li> <p><strong>顺序存储结构</strong>：</p> 
  <ul><li>使用此结构的线性表也叫 <strong>顺序表</strong></li><li>物理存储上是<strong>连续</strong>的，因此<strong>可以随机访问</strong>，时间复杂度为 O(1)<br> <img src="https://images2.imgbox.com/ed/ff/C69NjEMy_o.png" alt="在这里插入图片描述"></li></ul> </li><li> <p><strong>链式存储结构</strong>：</p> 
  <ul><li>使用此结构的线性表也叫 <strong>链表</strong></li><li>物理存储上<strong>不连续</strong>，因此<strong>不支持随机访问</strong><br> <img src="https://images2.imgbox.com/af/cf/XChHJ15Y_o.png" alt="在这里插入图片描述"></li></ul> </li></ul> 
<p>接下来要介绍的就是 <strong>链表</strong>。<br> 链表分为 单向链表（单链表）与 双向链表（双链表），理解了单链表，双链表自然也明白了。</p> 
<hr> 
<h2><a id="1__21"></a><strong>1. 什么是单链表</strong></h2> 
<h3><a id="11__22"></a><strong>1.1 定义</strong></h3> 
<blockquote> 
 <p>链表由一系列的节点组成（链表中的每个元素都可称为节点），对于单链表而言，它的节点包含两部分：</p> 
 <ul><li>数据域：存储当前节点的数据</li><li>指针域：存储当前节点的下一个节点（后继节点）的地址</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/09/bd/eIUicn3r_o.png" alt="在这里插入图片描述"></p> 
<p>那么现在定义单链表 SingleList 的节点 Node：</p> 
<h3><a id="12__Node_33"></a><strong>1.2 创建 Node</strong></h3> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> val<span class="token punctuation">;</span>		<span class="token comment">// 数据域</span>
	Node<span class="token operator">*</span> next<span class="token punctuation">;</span>		<span class="token comment">// 指针域：指向的是 Node，所以类型为 Node*</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>这么定义的 Node 类只能接收数据类型为 int 的数据，对于其他类型的数据当前的类不能处理，因此为了代码的通用性，将 Node 定义为模版类：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">Node</span>
<span class="token punctuation">{<!-- --></span>
    T val<span class="token punctuation">;</span>		<span class="token comment">// 数据域</span>
    Node<span class="token operator">*</span> next<span class="token punctuation">;</span>		<span class="token comment">// 指针域</span>
    <span class="token function">Node</span><span class="token punctuation">(</span>T v<span class="token punctuation">,</span> Node<span class="token operator">*</span> n <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token operator">:</span>val<span class="token punctuation">{<!-- --></span> v <span class="token punctuation">}</span><span class="token punctuation">,</span> next<span class="token punctuation">{<!-- --></span> n <span class="token punctuation">}</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>为了方便初始化，Node 还增加了构造函数：一个节点肯定必须有数据域，但指针域可以为空（表示没有后继节点了）</p> 
</blockquote> 
<p>那么我们可以如下创建节点：</p> 
<pre><code class="prism language-cpp">Node<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">node2</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 数据域为：2 (int)，指针域为空</span>
Node<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">node1</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>node2<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 数据域为：1，指针域为 node2 的地址</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/8c/e1/6pno8g4N_o.png" alt="在这里插入图片描述" width="600" height="100"></p> 
<h3><a id="13__SingleList_59"></a><strong>1.3 创建 SingleList</strong></h3> 
<p>从单链表的定义可以看出，单链表都会有：</p> 
<ul><li>头结点（head）：第一个节点</li><li>尾结点（rear）：最后一个节点<br> <img src="https://images2.imgbox.com/e4/67/0rmxaMre_o.png" alt="在这里插入图片描述"></li></ul> 
<p>对于 SingleList 来说，我们显然需要能够访问链表中的所有节点。<br> 对于一个节点来说，我们能得到两部分信息：</p> 
<ul><li>当前节点自身的值（数据域）</li><li>当前节点的下一个节点（指针域）</li></ul> 
<p>也就是说，我们只需要通过<strong>头结点</strong>，就可以访问该链表上的所有节点，并且<strong>不会越界</strong>。</p> 
<blockquote> 
 <p>当某一节点的后继节点为空时，说明当前节点是尾结点，不能在继续访问下一节点。</p> 
</blockquote> 
<p>因此你可以在 SingleList 类中保存头结点，但是这会有一个问题：<br> 如果当前单链表没有节点怎么办？</p> 
<blockquote> 
 <p>之前已经说明节点不能为空：一个节点肯定必须有数据域，但指针域可以为空。</p> 
</blockquote> 
<p>显然保存头结点不是一个好的方法，那么我们可以保存 <mark>头指针</mark>。</p> 
<blockquote> 
 <p><strong>头指针</strong>：指向头结点的指针</p> 
</blockquote> 
<p>此时就可以</p> 
<ul><li>通过 <strong>头指针</strong> 访问 <strong>头结点</strong>，进而访问所有节点。</li><li>当 <strong>头指针</strong> 为 <strong>nullptr</strong> 时，说明当前单链表没有节点。<br> <img src="https://images2.imgbox.com/19/09/baawKSTh_o.png" alt="在这里插入图片描述"></li></ul> 
<p>由于 Node 为模版类，因此 SingleList 也为模板类：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">SingleList</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">SingleList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>	   <span class="token comment">// 默认构造空单链表</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    Node<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> head <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>下面来实现一些单链表经常会用到的操作：</p> 
<hr> 
<h2><a id="2_SingleList__102"></a><strong>2 SingleList 的操作</strong></h2> 
<blockquote> 
 <p>接下来的操作会涉及到指针的相关操作，使用不当很容易导致 bug</p> 
</blockquote> 
<p>补充 SingleList 类：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">SingleList</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">SingleList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
    <span class="token comment">// 成员变量为指针，析构时需要释放内存</span>
    <span class="token operator">~</span><span class="token function">SingleList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	  

    <span class="token comment">// 返回节点数</span>
    <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    <span class="token comment">// 返回 i 位置的节点值</span>
    <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    <span class="token comment">// 头插法</span>
    <span class="token keyword">void</span> <span class="token function">push_front</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 尾插法</span>
    <span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 删除头结点</span>
    <span class="token keyword">void</span> <span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 删除尾结点</span>
    <span class="token keyword">void</span> <span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 在 i 位置插入</span>
    <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> T t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 删除 i 位置的节点</span>
    <span class="token keyword">void</span> <span class="token function">erase</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    Node<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> head <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<hr> 
<h3><a id="21_size_136"></a><strong>2.1 size()</strong></h3> 
<blockquote> 
 <p>作用：求链表的节点个数</p> 
</blockquote> 
<p>在此之前先来看如何遍历链表：</p> 
<pre><code class="prism language-cpp">head 为 类指针（<span class="token char">'Node&lt;...&gt;*'</span>），
可以通过 <span class="token char">'-&gt;'</span> 去访问类的成员
<span class="token char">'head-&gt;next'</span> <span class="token operator">&lt;=</span><span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token char">'(*head).next'</span> 
</code></pre> 
<p>对于下面的链表有：<br> <img src="https://images2.imgbox.com/23/6b/jnrmnplj_o.png" alt="在这里插入图片描述"><br> 换言之可以通过 head 访问所有节点，那么用一个临时变量 node 来拷贝一份 head，用 node 来遍历链表：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> node <span class="token operator">=</span> head<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>	<span class="token comment">// node == nullptr 说明 node 为尾结点的下一个节点（空）</span>
	cout <span class="token operator">&lt;&lt;</span> node<span class="token operator">-&gt;</span>val <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	node <span class="token operator">=</span> node<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>		<span class="token comment">// 将 node 后移一个节点</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>用上面的例子来分析此程序：</p> 
<ul><li> <p>首先拷贝 head</p> <pre><code class="prism language-cpp"><span class="token keyword">auto</span> node <span class="token operator">=</span> head<span class="token punctuation">;</span>
</code></pre> <p><img src="https://images2.imgbox.com/4f/5a/p6tQXDqh_o.png" alt="在这里插入图片描述"></p> </li><li> <p>因为 <strong>node != nullptr</strong>，故进入 while 循环</p> </li><li> <p>此时 node 指向第一个节点，<strong>node-&gt;val = 0</strong>，此时有<br> <img src="https://images2.imgbox.com/6b/c2/fjepOxDv_o.png" alt="在这里插入图片描述"></p> </li><li> <p><strong>node = node-&gt;next</strong><br> <img src="https://images2.imgbox.com/c3/31/wBWt2CFp_o.png" alt="在这里插入图片描述"></p> </li><li> <p>由于 <strong>node != nullptr</strong>，进入下一次循环</p> </li><li> <p>此时 node 指向第二个节点，<strong>node-&gt;val = 1</strong>，此时有<br> <img src="https://images2.imgbox.com/39/81/N0EPAvuX_o.png" alt="在这里插入图片描述"></p> </li><li> <p>执行 <strong>node = node-&gt;next</strong><br> <img src="https://images2.imgbox.com/42/c0/mN6o6H3O_o.png" alt="在这里插入图片描述"></p> </li><li> <p>此时 <strong>node == nullptr</strong>，退出循环</p> </li></ul> 
<p>因此可以 <strong>size()</strong> 函数实现如下：</p> 
<blockquote> 
 <p>下面的所有成员函数都是在类<strong>内部</strong>实现的</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> 
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">auto</span> node <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        res<span class="token operator">++</span><span class="token punctuation">;</span>
        node <span class="token operator">=</span> node<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>【注】为什么不直接用 head 进行遍历，而用一个临时指针？</strong></p> 
<p>如果用 head 进行遍历：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> node<span class="token operator">-&gt;</span>val <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	head <span class="token operator">=</span> head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>		
<span class="token punctuation">}</span>
</code></pre> 
<p>根据前面的分析，如果链表中有节点，采用此方法会造成最后 head 指向链表的尾结点的下一个节点（nullptr），那么之后 head 就无法用来遍历此链表了，即此链表 “丢失” 了。</p> 
<hr> 
<blockquote> 
 <p>在链表的插入与删除操作，需要特别注意先后顺序。</p> 
</blockquote> 
<h3><a id="22_push_frontT_t_203"></a><strong>2.2 push_front(T t)</strong></h3> 
<blockquote> 
 <p>作用：头插法，在链表的头部插入一个节点</p> 
</blockquote> 
<p>设待插入节点为 node<br> <img src="https://images2.imgbox.com/1d/89/uSWnuNO5_o.png" alt="在这里插入图片描述"></p> 
<ul><li> <p><strong>node-&gt;next = head</strong><br> <img src="https://images2.imgbox.com/9c/b6/CL2YbZKF_o.png" alt="在这里插入图片描述"></p> </li><li> <p><strong>head = node</strong></p> 
  <blockquote> 
   <p>新加入的节点现在成为头结点了</p> 
  </blockquote> <p><img src="https://images2.imgbox.com/86/44/VJeqYSBf_o.png" alt="在这里插入图片描述"></p> </li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">push_front</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    Node<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">Node</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 创建的是指针，需要 new 一块内存 </span>
    node<span class="token operator">-&gt;</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>
    head <span class="token operator">=</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>为了用户更易于理解此单链表，从用户视角来看：他关心的仅仅是数据域；指针域用户不需要关心，由类的设计者来管理。因此函数 push_front 的参数应该是节点的数据域（ <strong>push_front(T t)</strong> ），而不应该是节点 （ <strong>push_front(Node n)</strong> ），后面的几个函数也是如此。</p> 
</blockquote> 
<p><code>【易错】</code> <strong>node-&gt;next = head</strong> 与 <strong>head = node</strong> 的顺序不能颠倒。</p> 
<p>如果颠倒了，那么：<br> 初始状态：<br> <img src="https://images2.imgbox.com/63/c2/nSXaJICt_o.png" alt="在这里插入图片描述"></p> 
<ul><li> <p><strong>head = node</strong><br> <img src="https://images2.imgbox.com/3f/ef/JijmVDst_o.png" alt="在这里插入图片描述"></p> </li><li> <p><strong>node-&gt;next = head</strong></p> </li></ul> 
<p>显然结果不对</p> 
<blockquote> 
 <p><mark>不需要死记硬背，自己画图分析即可</mark></p> 
</blockquote> 
<hr> 
<h3><a id="23_push_backT_t_241"></a><strong>2.3 push_back(T t)</strong></h3> 
<blockquote> 
 <p>作用：尾插法，在尾结点后面插入一个节点</p> 
</blockquote> 
<p>只需要：将尾结点的 next 指向待插入节点即可<br> <img src="https://images2.imgbox.com/7e/a0/sdz8HzpX_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    Node<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">Node</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> rear <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>rear<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>		<span class="token comment">// 遍历找到尾结点</span>
        rear <span class="token operator">=</span> rear<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>	
    <span class="token punctuation">}</span>
    rear<span class="token operator">-&gt;</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>	<span class="token comment">// 将尾结点的 next 指向待插入节点</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<h3><a id="24_pop_front_260"></a><strong>2.4 pop_front()</strong></h3> 
<blockquote> 
 <p>作用：删除头结点</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/e1/b6/xtfMwvU4_o.png" alt="在这里插入图片描述"><br> 你可能直接如下实现：</p> 
<pre><code class="prism language-cpp"> <span class="token keyword">void</span> <span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
     head <span class="token operator">=</span> head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre> 
<p>但是这<mark>存在 <strong>内存泄露</strong> 问题：被删除的指针所指的内存没有被释放</mark>。</p> 
<pre><code class="prism language-cpp"> <span class="token keyword">void</span> <span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">auto</span> node <span class="token operator">=</span> head<span class="token punctuation">;</span>
     head <span class="token operator">=</span> head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
     <span class="token keyword">delete</span> node<span class="token punctuation">;</span>	<span class="token comment">// 释放旧头指针</span>
 <span class="token punctuation">}</span>
</code></pre> 
<p><code>【注】</code> 注意 <strong>delete node</strong> 的时机</p> 
<p>来看下面代码：</p> 
<pre><code class="prism language-cpp"> <span class="token keyword">void</span> <span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">auto</span> node <span class="token operator">=</span> head<span class="token punctuation">;</span>
     <span class="token keyword">delete</span> node<span class="token punctuation">;</span>	
     head <span class="token operator">=</span> head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre> 
<p>如果这样做，那么相当于</p> 
<pre><code class="prism language-cpp"> <span class="token keyword">void</span> <span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">delete</span> head<span class="token punctuation">;</span>	
     head <span class="token operator">=</span> head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre> 
<p>先 <strong>delete head</strong>，那么此时 head 所指的内存已经被释放了，此时 head 的值就是一个随机值，之后再使用 head 就是没有意义的，会导致未定义行为，产生逻辑错误甚至程序直接崩溃。</p> 
<blockquote> 
 <p>后面涉及到 delete 的函数也需要考虑此问题</p> 
</blockquote> 
<hr> 
<h3><a id="25_pop_back_304"></a><strong>2.5 pop_back()</strong></h3> 
<blockquote> 
 <p>作用：删除尾结点</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/f6/ab/3zkX0fOs_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">auto</span> rsecond <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>rsecond<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>   <span class="token comment">// 得到尾结点的前一个节点 </span>
        rsecond <span class="token operator">=</span> rsecond<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">delete</span> rsecond<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>	<span class="token comment">// 释放尾结点</span>
    rsecond<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>需要注意释放完尾结点后，需要将现在的尾结点的 next 指向 nullptr，否则它将指向一块未定义的内存（随机值）。</p> 
<hr> 
<blockquote> 
 <p>insert 与 erase 函数涉及到中间节点的插入与删除，因此下面只讲解方法，所有的代码在文章最后</p> 
</blockquote> 
<h3><a id="26__323"></a><strong>2.6 中间节点的插入</strong></h3> 
<p>【例】在位置 1 插入节点 node</p> 
<blockquote> 
 <ul><li>node1 代指图中值为 1 的节点，以此类推… …</li><li>默认头结点的下标为 0，那么插入前的位置 1 就是下面的 node2，node1 为待插入节点</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/97/99/IQZTdbp8_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>node1-&gt;next = node2</strong></li></ul> 
<p><img src="https://images2.imgbox.com/fa/06/P2C9HQdS_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>node0-&gt;next = node1</strong><br> <img src="https://images2.imgbox.com/5a/14/px5q9qYf_o.png" alt="在这里插入图片描述"></li></ul> 
<hr> 
<h3><a id="27__340"></a><strong>2.7 中间节点的删除</strong></h3> 
<p>【例】删除位置 1 的节点<br> 初始状态：</p> 
<p><img src="https://images2.imgbox.com/d2/85/WMC0A9m8_o.png" alt="在这里插入图片描述"><br> 你可以直接 <strong>node0-&gt;next = node2</strong>，逻辑上没有问题，但是代码上存在 <strong>内存泄漏</strong><br> <img src="https://images2.imgbox.com/67/50/gpgnvSEM_o.png" alt="在这里插入图片描述"><br> 因此在执行 <strong>node0-&gt;next = node2</strong> 前，需要保存被删除的节点，在后续以释放内存。</p> 
<hr> 
<h2><a id="3__350"></a><strong>3. 双向链表</strong></h2> 
<h3><a id="31__351"></a><strong>3.1 什么是双链表</strong></h3> 
<p>在单链表中，你会发现一个问题：单链表只能朝一个方向上（从头到尾）进行遍历，此外由于只存储了头指针，因此在尾结点的插入与删除的时间复杂度都是 O(n)。<br> 为了解决这些问题，双链表就此诞生：<br> 双链表在单链表的基础上增加了尾指针，节点增加了一个指针域（pre）用于指向当前节点的前驱节点。</p> 
<blockquote> 
 <ul><li>尾指针：指向尾结点的指针</li><li>前驱节点：某节点的前一个节点</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/6d/95/UYQdMngX_o.png" alt="在这里插入图片描述"></p> 
<p>因此你会发现：</p> 
<ul><li>头节点的前驱节点为空</li><li>尾节点的后继节点为空</li><li>其余节点的前驱、后继节点都不为空</li></ul> 
<p>由于增加了尾指针，因此在尾结点的插入与删除时间复杂度变为 O(1)，因为此时可以通过尾指针直接在尾结点进行操作。<br> 同时由于加入了 pre 指针，因此可以对链表进行双向遍历。</p> 
<hr> 
<blockquote> 
 <p>你理解了单链表的操作，双链表的操作也很容易理解，下面讲解较难的中间节点的插入与删除</p> 
</blockquote> 
<h3><a id="32__371"></a><strong>3.2 中间节点的插入</strong></h3> 
<p>【例】在位置 1 插入节点<br> <img src="https://images2.imgbox.com/ae/ef/RWxPxVzs_o.png" alt="在这里插入图片描述"><br> 看起来比较复杂，其实只需要从目标反推即可。<br> 我们的目标是：<br> <img src="https://images2.imgbox.com/ab/93/7fD1QsVx_o.png" alt="在这里插入图片描述"><br> 在之前的单链表中，你可以发现 <strong>对于节点的插入</strong>：</p> 
<blockquote> 
 <p>一般是 <mark>先给 待插入节点 的指针域进行赋值</mark>，否则可能会丢失某些节点。</p> 
</blockquote> 
<p>比如如果我们先执行 <strong>node0-&gt;next = node1</strong>，会导致 node2 丢失<br> <img src="https://images2.imgbox.com/1b/f7/RI2z5NDq_o.png" alt="在这里插入图片描述"><br> 因此需要先对待插入节点的指针域进行赋值</p> 
<blockquote> 
 <p>当然针对上面的操作，你可以在执行 <strong>node0-&gt;next = node1</strong> 之前，将 node2 进行保存，就不会丢失 node2。<br> 这也是可以的，但是比较浪费空间。</p> 
</blockquote> 
<ul><li><strong>node1-&gt;pre = node0</strong></li><li><strong>node1-&gt;next = node2</strong></li></ul> 
<p><img src="https://images2.imgbox.com/e6/bd/yzUJ2Bmj_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>node0-&gt;next = node1</strong></li><li><strong>node2-&gt;pre = node1</strong><br> <img src="https://images2.imgbox.com/5b/ac/UAlBvVW9_o.png" alt="在这里插入图片描述"></li></ul> 
<blockquote> 
 <p>上面的代码有的可以交换位置，有的不可以，所以还是那句话：没必要死记硬背，自己画图分析即可。（在这里重点分析是否是丢失对某节点的指针）</p> 
</blockquote> 
<hr> 
<h3><a id="33__400"></a><strong>3.3 中间节点的删除</strong></h3> 
<p>【例】删除位置 1 上的节点<br> <img src="https://images2.imgbox.com/b9/4e/S8gIDxds_o.png" alt="在这里插入图片描述"><br> 同理从目标反推：<br> <img src="https://images2.imgbox.com/20/b9/jj1cfNMd_o.png" alt="在这里插入图片描述"><br> 因此我们需要</p> 
<ul><li><strong>node0-&gt;next = node2</strong></li><li><strong>node2-&gt;pre = node0</strong></li></ul> 
<p>两者可以交换顺序。但这只是就逻辑层面上可以，在代码层面上还需要考虑 <strong>内存泄漏</strong>，node1 需要被释放。</p> 
<hr> 
<h2><a id="4__413"></a><strong>4. 循环链表</strong></h2> 
<p><strong>首尾相连</strong> 的链表。分为：</p> 
<ul><li> <p>单循环链表</p> 
  <ul><li><strong>rear-&gt;next = head</strong><br> <img src="https://images2.imgbox.com/40/8e/TuTxFk1R_o.png" alt="在这里插入图片描述"></li></ul> </li><li> <p>双循环链表</p> 
  <ul><li><strong>head-&gt;pre = rear</strong></li><li><strong>rear-&gt;next = head</strong></li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/3a/f0/Xn8xF7pS_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h2><a id="5_____427"></a><strong>5. 线性表 与 链表 的比较</strong></h2> 
<table><thead><tr><th></th><th>优点</th><th>缺点</th><th>使用场景</th></tr></thead><tbody><tr><td>顺序表</td><td>（1）程序设计简单；（2）能随机访问，时间复杂度为O(1)；（3）存储空间利用率高</td><td>（1）需事先知道表长；（2）插入元素需移动元素；（3）多次插入元素后可能会造成溢出</td><td>（1）事先确定表长；（2）很少在非尾部位置进行插入和删除；</td></tr><tr><td>链表</td><td>（1）存储空间动态分配，不需事先确定表长；（2）插入与删除只引起指针的变化；</td><td>（1）程序设计较为复杂；（2）不能随机访问，读取的时间复杂度为O(n)；（3）存在结构性开销；</td><td>（1）事先不确定表长；（2）需要经常进行插入与删除</td></tr></tbody></table> 
<p>【解释】</p> 
<ul><li>访问元素的时间复杂度 
  <ul><li>线性表：由于它的物理存储空间是连续的，所以元素的下标与实际的内存地址存在线性关系，可以直接计算得出，即可以随机访问，因此时间复杂度为 O(1)</li><li>链表：物理存储空间一般不连续，故不能随机访问，时间复杂度为 O(n)</li></ul> </li><li>不管是线性表还是链表，核心目的都是<mark>存储数据</mark>。 
  <ul><li> <p>线性表：它的元素就是所需要存储的数据，所以存储空间利用率高；</p> </li><li> <p>链表：它的元素除了所需要存储的数据，还存在指针域以保存额外的信息，但是这部分信息在用户层面上是没必要的。</p> 
    <blockquote> 
     <p>尽管底层设计需要维护指针，但是使用它的人只关心链表所存储的数据</p> 
    </blockquote> <p>故存在结构性开销，存储空间利用率较低。</p> </li></ul> </li></ul> 
<hr> 
<h2><a id="_445"></a><strong>最后</strong></h2> 
<p>单链表实现代码见：<a href="https://gitee.com/buliangrencpp/my_STL.git" rel="nofollow">SingleList</a></p> 
<blockquote> 
 <p>源码仅一个头文件，将其包含即可进行使用以及测试，如代码有 bug，敬请指正。</p> 
</blockquote> 
<p>本文参考教科书以及网上资料，并加入自己的一些理解。<br> 如有错误或者不足，欢迎指出。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ae90962065d49f9a0d0b2d57be26bdb6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【人工智能】-- 迁移学习</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/599857e9223baa3b046d7676564c91a1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【人工智能】-- 受限玻尔兹曼机</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>