<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>安卓lua解密——opcode修改后dump反编译 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/3531e26e763665125888dacdc29ffc1c/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="安卓lua解密——opcode修改后dump反编译">
  <meta property="og:description" content="随着近些年lua语言在安卓游戏大火，lua逆向已经越来越重要。早期游戏的lua源码放在安装包的assets目录，但随着对抗的升级，越来越多的游戏使用动态更新和扩展应用功能的方式，特别是在需要频繁更新脚本或配置的情况下。这种方法在游戏开发、插件系统、远程配置等场景中有较多应用。而且这种方法是网络上加载Lua代码，你在安装包,APK是得不到lua的代码的。遇到这种我们首先要确认是否是lua语言的应用：
打开apk\lib\arm64-v8a\目录，如果发现libxlua.so,libslua.so等等类似目录，那么有很大可能是lua。（lua又分luajit与普通lua，判断是不是luajit，将so文件放进IDA，字符串搜索luajit即可）
再使用IDA或者frida hook lual_loadbuffer获取字节码，使用unluac网址（unluac download | SourceForge.net）进行反编译。
java -jar unluac.jar 你的字节码文件&gt;存放文件
反编译成功一般不会有输出信息，但看到类似上面的情况大概有3种可能：
​1.文件头被改
​2.opcode修改
​3.文件头和opcode都被改
关于文件头：
0到3字节：1B 4C 75 61表示这是一个Lua字节码文件。
​第4字节：51：版本号，表示Lua 5.1。
第5字节：00：格式号，表示标准格式。01为非官方，魔改lua。
第6字节：01：endianness标识，表示大端格式。字节码文件需要指示其数据的字节顺序，以确保在不同平台和硬件架构上的正确解析。不同平台可能采用不同的字节序，比如大多数x86和x86-64架构采用小端序，而一些嵌入式系统和网络协议采用大端序。
第8字节到11字节：Lua整数大小，指令大小等。
关于opcode修改：liblua.so文件是lua源码文件编译的，lua源码的&#34;lua-5.1.5\src\lopcodes.h&#34;文件定义了opcode：
如果在编译的时候将opcode的顺序修改，比如OP_MOVE在OP_GETUPVAL前面，改为OP_GETUPVAL在OP_MOVE前面，再编译为so，这时再使用unluac反编译会报错。
解决办法有两个：
一：将正常的so文件与修改后的so文件，放进IDA反编译，搜索函数：luaV_execute找到case，进行对比，还原opcode的顺序。 还原opcode之后，修改unluac的源码的src/unluac/decompile/OpcodeMap.java文件：
再使用unluac反编译。
二：[原创]用 Lua 简单还原 OpCode 顺序-Android安全-看雪-安全社区|安全招聘|kanxue.com
大佬的办法，从应用内部运行lua脚本，获取字节码。再将同一个lua脚本运行在未被修改的环境。
​
使用python将两个字节码文件对比，将红色的部分使用python替换，然后使用unluac反编译.
反编译成功！">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-23T21:30:59+08:00">
    <meta property="article:modified_time" content="2024-06-23T21:30:59+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">安卓lua解密——opcode修改后dump反编译</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0;"><span style="color:#000000;">随着近些年lua语言在安卓游戏大火，lua逆向已经越来越重要。早期游戏的lua源码放在安装包的assets目录，但随着对抗的升级，越来越多的游戏使用动态更新和扩展应用功能的方式，特别是在需要频繁更新脚本或配置的情况下。这种方法在游戏开发、插件系统、远程配置等场景中有较多应用。而且这种方法是网络上加载Lua代码，你在安装包,APK是得不到lua的代码的。遇到这种我们首先要确认是否是lua语言的应用：</span></p> 
<p style="margin-left:0;"></p> 
<p class="img-center"><img alt="" height="621" src="https://images2.imgbox.com/df/30/ufK698ST_o.png" width="1200"></p> 
<p style="margin-left:0;"><span style="color:#000000;">打开apk\lib\arm64-v8a\目录，如果发现libxlua.so,libslua.so等等类似目录，那么有很大可能是lua。（lua又分<span style="background-color:#fefefe;">luajit与普通lua，判断是不是<span style="background-color:#fefefe;">luajit，将so文件放进IDA，字符串搜索<span style="background-color:#fefefe;">luajit即可</span></span></span>）</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">再使用IDA或者frida hook lual_loadbuffer获取字节码，使用unluac网址（<a href="https://sourceforge.net/projects/unluac/" rel="nofollow" title="unluac download | SourceForge.net">unluac download | SourceForge.net</a>）进行反编译。</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">java -jar unluac.jar 你的字节码文件&gt;存放文件</span></p> 
<p style="margin-left:0;"></p> 
<p class="img-center"><img alt="" height="176" src="https://images2.imgbox.com/b1/31/cSnFIfem_o.png" width="1200"></p> 
<p style="margin-left:0;"><span style="color:#000000;">反编译成功一般不会有输出信息，但看到类似上面的情况大概有3种可能：</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">    ​1.文件头被改</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">    ​2.opcode修改</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">    ​3.文件头和opcode都被改</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">关于文件头：</span></p> 
<p style="margin-left:0;"></p> 
<p class="img-center"><img alt="" height="147" src="https://images2.imgbox.com/d5/a9/zhWEh99N_o.png" width="856"></p> 
<p style="margin-left:0;"><span style="color:#000000;"><strong>0到3字节：1B 4C 75 61</strong>表示这是一个Lua字节码文件。</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">​<strong>第4字节：</strong><strong>51</strong>：版本号，表示Lua 5.1。</span></p> 
<p style="margin-left:0;"><span style="color:#000000;"><strong>第5字节：00</strong>：格式号，表示标准格式。01为非官方，魔改lua。</span></p> 
<p style="margin-left:0;"><span style="color:#000000;"><strong>第6字节：01</strong>：endianness标识，表示大端格式。字节码文件需要指示其数据的字节顺序，以确保在不同平台和硬件架构上的正确解析。不同平台可能采用不同的字节序，比如大多数x86和x86-64架构采用小端序，而一些嵌入式系统和网络协议采用大端序。</span></p> 
<p style="margin-left:0;"><span style="color:#000000;"><strong>第8字节到11字节：</strong>Lua整数大小，指令大小等。</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">关于opcode修改：liblua.so文件是lua源码文件编译的，lua源码的"lua-5.1.5\src\lopcodes.h"文件定义了opcode：</span></p> 
<p class="img-center"><img alt="" height="715" src="https://images2.imgbox.com/90/58/dC9jw06k_o.png" width="961"></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><span style="color:#000000;">如果在编译的时候将opcode的顺序修改，比如<span style="color:#4fc1ff;">OP_MOVE在</span><span style="color:#4fc1ff;">OP_GETUPVAL前面，改为<span style="color:#4fc1ff;">OP_GETUPVAL在<span style="color:#4fc1ff;">OP_MOVE前面，再编译为so，这时再使用unluac反编译会报错。</span></span></span></span></p> 
<p style="margin-left:0;"><span style="color:#000000;">解决办法有两个：</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">一：将正常的so文件与修改后的so文件，放进IDA反编译，搜索函数：luaV_execute找到case，进行对比，还原opcode的顺序。 </span></p> 
<p style="margin-left:0;"></p> 
<p class="img-center"><img alt="" height="466" src="https://images2.imgbox.com/a6/73/yo9mSaek_o.png" width="594"></p> 
<p style="margin-left:0;"><span style="color:#000000;"><span style="color:#4fc1ff;"><span style="color:#4fc1ff;"><span style="color:#4fc1ff;">还原opcode之后，修改unluac的源码的src/unluac/decompile/OpcodeMap.java文件：</span></span></span></span></p> 
<p style="margin-left:0;"></p> 
<p class="img-center"><img alt="" height="682" src="https://images2.imgbox.com/33/dc/mzvYF5FA_o.png" width="622"></p> 
<p style="margin-left:0;"><span style="color:#000000;"><span style="color:#4fc1ff;"><span style="color:#4fc1ff;"><span style="color:#4fc1ff;">再使用unluac反编译。</span></span></span></span></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><span style="color:#000000;"><span style="color:#4fc1ff;"><span style="color:#4fc1ff;"><span style="color:#4fc1ff;">二：<a href="https://bbs.kanxue.com/thread-250618.htm" rel="nofollow" title="[原创]用 Lua 简单还原 OpCode 顺序-Android安全-看雪-安全社区|安全招聘|kanxue.com">[原创]用 Lua 简单还原 OpCode 顺序-Android安全-看雪-安全社区|安全招聘|kanxue.com</a></span></span></span></span></p> 
<p style="margin-left:0;"><span style="color:#000000;"><span style="color:#4fc1ff;"><span style="color:#4fc1ff;">大佬的办法，从应用内部运行lua脚本，获取字节码。再将同一个lua脚本运行在未被修改的环境。</span></span></span></p> 
<p style="margin-left:0;"><span style="color:#000000;"><span style="color:#4fc1ff;"><span style="color:#4fc1ff;">​</span></span></span></p> 
<p class="img-center"><img alt="" height="139" src="https://images2.imgbox.com/b1/b9/8TZU9GHT_o.png" width="1200"></p> 
<p style="margin-left:0;"><span style="color:#000000;"><span style="color:#4fc1ff;"><span style="color:#4fc1ff;">使用python将两个字节码文件对比，将红色的部分使用python替换，然后使用unluac反编译.</span></span></span></p> 
<p style="margin-left:0;"></p> 
<p class="img-center"><img alt="" height="242" src="https://images2.imgbox.com/75/40/NmWW1jqe_o.png" width="1200"></p> 
<p style="margin-left:0;"><span style="color:#000000;"><span style="color:#4fc1ff;">反编译成功！</span></span></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/022067e82a7abbd3b85459775081436d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">allWebPlugin助力iWebOffice2015插件在高版本浏览器使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a5c053c6bd8a9e1aacaef914b3c3867a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">轻松上手MYSQL：MYSQL事务隔离级别的奇幻之旅</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>