<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C/排序算法】：堆排序和选择排序 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/946827ec1fc4f030767b912b691614bf/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C/排序算法】：堆排序和选择排序">
  <meta property="og:description" content="目录 1. 堆排序1.1排序思想1.2 代码实现 2. 选择排序2.1 排序思想：2.2 代码实现 3. 堆排序和选择排序的性能比较 1. 堆排序 堆排序是一种比较复杂的排序算法，因为它的流程比较多，理解起来不会像冒泡排序和选择排序那样直观。
1.1 堆的结构
要理解堆排序，首先要理解堆。堆的逻辑结构是一棵完全二叉树，物理结构是一个数组。 (如果不知道什么是二叉树，请前往我的主页查看)。所以堆是一个用数组表示的完全二叉树。如图：
1.2 堆的左右子树与下标的关系
现在的需求是要对数组元素进行排序，所以事实上我们还是通过数组的下标来操纵数组的元素。但是我们已经把数组想象成一棵完全二叉树了，怎么通过二叉树的左右子树来确定数组下标呢？有如下性质：
leftchild = parent * 2 &#43; 1rightchild = parent * 2 &#43; 2parent = (child - 1) /2 （child 是左孩子或右孩子）堆的右子树 = 左子树 &#43; 1 1.3 大堆和小堆的概念
大(顶)堆：是指所有父亲节点的值都大于等于孩子节点的值。大堆的堆顶是数组元素的最大值。小(顶)堆：是指所有父亲节点的值都小于等于孩子节点的值。小堆的堆顶是数组元素的最小值。 堆排序主要分三步：
（1）构建堆
（2）调整堆
（3）堆排序
首先需要明确一点，构建堆是在数组基础上构建的，换句话说就是将数组抽象成一个二叉堆，而不是凭空构建。
1.1排序思想 1.首先将待排序的数组构造一个大根堆，此时，整个数组的最大值就是堆结构的顶端。
2.将堆结构内顶端的数与堆的最后一个叶节点所在的数交换，此时，末尾的数为最大值，把它不看作堆里面的了，剩余待排序的个数为n - 1。
3.将剩余的n - 1个数再构造成大根堆，再将堆顶的数与n - 1位置的数交换，如此反复执行，最后就能得到有序数组了。
注意：排升序建大根堆，排降序建小根堆。(默认排升序)
原因：由于堆排序的本质是选数排序，是通过堆来选数的。如果排升序时建小堆，最小的数在堆顶已经被选出来了。那么在剩下的数中再去选数，但是这时剩下的数的父子结构关系都乱了，需要重新建堆才能选出下一个数，建堆的时间复杂度是0(N)，这样堆排序就没有效率优势了。
如何构造大堆 想要建大堆，首先要理解向下调整算法，前提是左右子树都是大堆，否则无法使用该算法(如果要建小堆，则使用向下调整算法的前提是左右子树都是小堆)。
算法思路：
从根节点开始，选出左右孩子中大的那一个，跟父亲比较，如果比父亲大就和父亲交换位置，然后再继续向下调，调到叶节点就终止。
举一个简单的例子解释：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-23T22:33:16+08:00">
    <meta property="article:modified_time" content="2024-06-23T22:33:16+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C/排序算法】：堆排序和选择排序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#1__1" rel="nofollow">1. 堆排序</a></li><li><ul><li><a href="#11_33" rel="nofollow">1.1排序思想</a></li><li><a href="#12__201" rel="nofollow">1.2 代码实现</a></li></ul> 
  </li><li><a href="#2__272" rel="nofollow">2. 选择排序</a></li><li><ul><li><a href="#21__275" rel="nofollow">2.1 排序思想：</a></li><li><a href="#22__292" rel="nofollow">2.2 代码实现</a></li></ul> 
  </li><li><a href="#3__392" rel="nofollow">3. 堆排序和选择排序的性能比较</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1__1"></a>1. 堆排序</h2> 
<p>堆排序是一种比较复杂的排序算法，因为它的流程比较多，理解起来不会像冒泡排序和选择排序那样直观。</p> 
<p><strong>1.1 堆的结构</strong><br> 要理解堆排序，首先要理解堆。<strong>堆的逻辑结构是一棵完全二叉树，物理结构是一个数组。</strong> <em>(如果不知道什么是二叉树，请前往我的主页查看)</em>。<strong>所以堆是一个用数组表示的完全二叉树</strong>。如图：<br> <img src="https://images2.imgbox.com/05/a4/Anbd4rbE_o.png" alt="在这里插入图片描述"></p> 
<p><strong>1.2 堆的左右子树与下标的关系</strong></p> 
<p>现在的需求是要对数组元素进行排序，所以事实上我们还是<strong>通过数组的下标来操纵数组的元素</strong>。但是我们已经把数组想象成一棵完全二叉树了，怎么通过二叉树的左右子树来确定数组下标呢？有如下性质：</p> 
<blockquote> 
 <ol><li><strong>leftchild = parent * 2 + 1</strong></li><li><strong>rightchild = parent * 2 + 2</strong></li><li><strong>parent = (child - 1) /2</strong> （<strong>child 是左孩子或右孩子</strong>）</li><li><strong>堆的右子树 = 左子树 + 1</strong></li></ol> 
</blockquote> 
<p><img src="https://images2.imgbox.com/b0/13/6ZuSsbZU_o.png" alt="![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/7b8d8d56960041629f715eaf16124b62.png"></p> 
<p><strong>1.3 大堆和小堆的概念</strong></p> 
<blockquote> 
 <ul><li><strong>大(顶)堆</strong>：<strong>是指所有父亲节点的值都大于等于孩子节点的值。大堆的堆顶是数组元素的最大值</strong>。</li><li><strong>小(顶)堆</strong>：<strong>是指所有父亲节点的值都小于等于孩子节点的值。小堆的堆顶是数组元素的最小值</strong>。</li></ul> 
</blockquote> 
<p><img src="https://images2.imgbox.com/d9/4b/4h8ix8yo_o.png" alt="![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/d1e27a901f584536bf9ccbdab885862c.png"></p> 
<p>堆排序主要分三步：<br> （1）构建堆<br> （2）调整堆<br> （3）堆排序</p> 
<p>首先需要明确一点，<strong>构建堆是在数组基础上构建的</strong>，<strong>换句话说就是将数组抽象成一个二叉堆</strong>，而不是凭空构建。</p> 
<h3><a id="11_33"></a>1.1排序思想</h3> 
<p>1.<strong>首先将待排序的数组构造一个大根堆，此时，整个数组的最大值就是堆结构的顶端。</strong><br> 2.<strong>将堆结构内顶端的数与堆的最后一个叶节点所在的数交换，此时，末尾的数为最大值，把它不看作堆里面的了，剩余待排序的个数为n - 1</strong>。<br> 3.<strong>将剩余的n - 1个数再构造成大根堆，再将堆顶的数与n - 1位置的数交换，如此反复执行，最后就能得到有序数组了</strong>。</p> 
<p>注意：<strong>排升序建大根堆，排降序建小根堆</strong>。(默认排升序)</p> 
<blockquote> 
 <p>原因：由于堆排序的本质是选数排序，是通过堆来选数的。如果排升序时建小堆，最小的数在堆顶已经被选出来了。那么在剩下的数中再去选数，<strong>但是这时剩下的数的父子结构关系都乱了，需要重新建堆才能选出下一个数</strong>，建堆的时间复杂度是0(N)，这样堆排序就没有效率优势了。</p> 
</blockquote> 
<ul><li><strong>如何构造大堆</strong></li></ul> 
<p>想要建大堆，首先要理解<strong>向下调整算法</strong>，<strong>前提是左右子树都是大堆</strong>，否则无法使用该算法(如果要建小堆，则使用向下调整算法的前提是左右子树都是小堆)。</p> 
<p><strong>算法思路：</strong><br> <strong>从根节点开始，选出左右孩子中大的那一个，跟父亲比较，如果比父亲大就和父亲交换位置，然后再继续向下调，调到叶节点就终止</strong>。</p> 
<p>举一个简单的例子解释：<br> <img src="https://images2.imgbox.com/fa/74/HqBEhq0p_o.png" alt="在这里插入图片描述"></p> 
<p><strong>向下调整算法代码实现如下：</strong></p> 
<p>注意：第一个if的判断条件中<em><strong>child + 1 &lt; sz</strong></em> 是为了避免左子树存在，而右子树不存在的情况，<strong>即计算右子树的下标时数组越界了</strong>。</p> 
<pre><code class="prism language-c">
<span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> p2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token operator">*</span>p1<span class="token punctuation">;</span>
	<span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span>
	<span class="token operator">*</span>p2 <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//sz是数组元素个数</span>
<span class="token keyword">void</span> <span class="token function">AdjustDown</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> sz<span class="token punctuation">,</span> <span class="token keyword">int</span> root<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> parent <span class="token operator">=</span> root<span class="token punctuation">;</span>
	<span class="token keyword">int</span> child <span class="token operator">=</span> parent <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//默认孩子是左孩子</span>

	<span class="token keyword">while</span> <span class="token punctuation">(</span>child <span class="token operator">&lt;</span>sz<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//选出左右孩子中较小的那一个</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>child <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> sz <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>child <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			child <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span> arr<span class="token punctuation">[</span>child<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			parent <span class="token operator">=</span> child<span class="token punctuation">;</span>
			child <span class="token operator">=</span> parent <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>但是我们知道一个任意的数组要满足这个前提是几乎不可能的，<strong>那么给定一个无序的序列，该如何利用向下调整算法构建成大堆呢</strong>？</p> 
<p><img src="https://images2.imgbox.com/5e/1d/TdgIN6HI_o.png" alt="![外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传](https://img-home.csdnimg.cn/images/20230724024159.png?origin_url=https%3A%2F%2Fimgblog.csdnimg.cn%2Fdirect%2Ff30892cf7e694bc7b83e0ceb633ff093.png&amp;pos_id=img-QHNSTLpS-1712537662852"></p> 
<p><img src="https://images2.imgbox.com/be/c7/QZ5DgjvS_o.jpg" alt="![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/ab42586bcbdf4619aea79712b94e028e.png"></p> 
<p>首先我们<strong>任意给定一个无序的数组</strong>，将其看做一个堆结构，一个没有规则的二叉树，将序列里的值按照从上往下，从左到右依次填充到二叉树中。</p> 
<p><img src="https://images2.imgbox.com/1e/39/ID3KcFvW_o.png" alt="![![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/cf9b819bb9d84fe598424cbdde03518e.png](https://img-blog.csdnimg.cn/direct/bd29ffbde1f64d5bae6b5699b5019323.png"></p> 
<p><strong>再经过分析，叶子节点不需要调，因为叶子节点没有左右子树，可以当成大堆。所以应该倒着从最后一个非叶子的子树开始调。</strong> 那么最后一个非叶子节点的下标如何计算呢？由上文可知，已知一个孩子的下标，计算其父亲的下标，用 <strong>parent = (child - 1) /2</strong>即可。如上图，9的下标是4，其父亲6的下标为(4 - 1) / 2 = 1符合。</p> 
<p>我们找到了最后一个非叶子节点，即元素值为6的节点，<strong>比较它的左右节点中最大的一个的值，是否比他大，如果大就交换位置</strong>。<br> 在这里5小于6,而9大于6，则交换6和9的位置；<br> <img src="https://images2.imgbox.com/07/8d/vrNXAthJ_o.png" alt="![![![![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/8e312a353c9440ab97dfcad6b9ea990f.png](https://img-blog.csdnimg.cn/direct/b3dbea45957044099882c5d8d450589c.png](https://img-blog.csdnimg.cn/direct/dc9da81f04524c15adf9c7be8e582c77.png](https://img-blog.csdnimg.cn/direct/4cddded9d25947fb9e033b29b88d2380.png"></p> 
<p><strong>找到下一个非叶子节点4，用它和它的左右子节点进行比较，4大于3，而4小于9，交换4和9位置；</strong></p> 
<p><img src="https://images2.imgbox.com/94/a4/gMJshFsS_o.png" alt="![![![![![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/05d07a38f0c041da8cd39f5749e02d9f.png](https://img-blog.csdnimg.cn/direct/1e9a2d3c835a44c0a39a0ada530bb67e.png](https://img-blog.csdnimg.cn/direct/4e54919fe8cf41b98e194561adc78b75.png](https://img-blog.csdnimg.cn/direct/90be6d87e5914f628ecdfdbd6f0d54a7.png](https://img-blog.csdnimg.cn/direct/ec6a93164ba94ecab4116dea5b1cd17f.png"></p> 
<p><strong>此时发现4小于5和6这两个子节点，我们需要进行调整，左右节点5和6中，6大于5且6大于父节点4，因此交换4和6的位置；</strong></p> 
<p><img src="https://images2.imgbox.com/c5/96/hrRWonC1_o.png" alt="![![![![![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/79250501036045fe8098c5f772f8d45e.png](https://img-blog.csdnimg.cn/direct/8a2b25d834a649cba8f3e2c638042a82.png](https://img-blog.csdnimg.cn/direct/35fd0e8347ee41999a2935620a7b986e.png](https://img-blog.csdnimg.cn/direct/1cfa3f7fabbc42559e8b7be672088a9f.png](https://img-blog.csdnimg.cn/direct/46cc04ce83864e74ac09deeae7b7d4b3.png"></p> 
<p><strong>此时我们就构造出来一个大根堆。代码实现如下：</strong></p> 
<p>注意：for循环中的<em><strong>sz - 1</strong></em>是指<strong>数组最后一个元素的下标</strong>，即<strong>最后一个叶子的位置</strong>；<em><strong>(sz - 1 - 1) / 2</strong></em>是指<strong>最后一个非叶子节点的位置</strong>。</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> sz<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//建堆</span>

	<span class="token comment">//但是，如果我们要排升序，就要建大堆</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>sz <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">AdjustDown</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//建好了大堆</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>通过上述操作建好了大堆，接下来进行排序</strong></p> 
<p><strong>首先将顶点元素9与末尾元素4交换位置，此时末尾数字为最大值。排除已经确定的最大元素，将剩下元素重新构建大根堆。</strong><br> <strong>第一次交换重构如图:</strong><br> <img src="https://images2.imgbox.com/2d/aa/IWafSogu_o.png" alt="![![![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/ab40c52232ac411fbce6bfa91cd27af7.png](https://img-blog.csdnimg.cn/direct/d4abc5f6fe914182ad1e196b0ea5a2dc.png](https://img-blog.csdnimg.cn/direct/f61699b41c2749a7b264470692a2579b.png"></p> 
<p><strong>此时元素9已经有序，末尾元素则为4(每调整一次，调整后的尾部元素在下次调整重构时都不能动)。</strong><br> <strong>第二次交换重构如图:</strong></p> 
<p><img src="https://images2.imgbox.com/1b/a3/o719oaB1_o.png" alt="![![![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/ad777bf274cb4e8f93ad8ce5ee657992.png](https://img-blog.csdnimg.cn/direct/fc48ceb896c542148b3d80593c3a6109.png](https://img-blog.csdnimg.cn/direct/7b82cf7dc86447ccb901241fca961074.png"></p> 
<p><strong>最终排序结果：</strong><br> <img src="https://images2.imgbox.com/b5/47/GxFvUhaI_o.png" alt="![![![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/58b6d443391c44308405685214acaba1.png](https://img-blog.csdnimg.cn/direct/d935b4cbddf24bce84bdff6b006698e0.png](https://img-blog.csdnimg.cn/direct/77288401207d4a6f8b146dc7febfd1b5.png"></p> 
<p><strong>排序代码实现如下：</strong></p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> sz<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//建堆</span>

	<span class="token comment">//但是，如果我们要排升序，就要建大堆</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>sz <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">AdjustDown</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//建好了大堆</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">int</span> end <span class="token operator">=</span> sz <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>end <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//把第一个最大的和最后一个交换，把它不看作堆里的</span>
		<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token comment">//再把前n-1个向下调整成升序，再选出次大的数</span>
		<span class="token function">AdjustDown</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> end<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//end是需要调整的个数，0是根参数，</span>
		                        <span class="token comment">//用的是数组第一个元素的下标</span>
		end<span class="token operator">--</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>由此，我们可以归纳出堆排序算法的步骤：</p> 
<p><strong>1.把无序数组构建成二叉堆。</strong></p> 
<p><strong>2.循环删除堆顶元素，移到集合尾部，调节堆产生新的堆顶。</strong></p> 
<p>当我们删除一个最大堆的堆顶（并不是完全删除，而是替换到最后面），经过自我调节，第二大的元素就会被交换上来，成为最大堆的新堆顶。</p> 
<p>正如上图所示，当我们删除值为9的堆顶节点，经过调节，值为6的新节点就会顶替上来；当我们删除值为6的堆顶节点，经过调节，值为5的新节点就会顶替上来…</p> 
<p>由于二叉堆的这个特性，我们每一次删除旧堆顶，调整后的新堆顶都是大小仅次于旧堆顶的节点。那么我们只要反复删除堆顶，反复调节二叉堆，所得到的集合就成为了一个有序集合。</p> 
<h3><a id="12__201"></a>1.2 代码实现</h3> 
<p><strong>堆排序的全过程完整代码实现如下：</strong></p> 
<pre><code class="prism language-c">
<span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> p2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token operator">*</span>p1<span class="token punctuation">;</span>
	<span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span>
	<span class="token operator">*</span>p2 <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//sz是数组元素个数</span>
<span class="token keyword">void</span> <span class="token function">AdjustDown</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> sz<span class="token punctuation">,</span> <span class="token keyword">int</span> root<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> parent <span class="token operator">=</span> root<span class="token punctuation">;</span>
	<span class="token keyword">int</span> child <span class="token operator">=</span> parent <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//默认孩子是左孩子</span>

	<span class="token keyword">while</span> <span class="token punctuation">(</span>child <span class="token operator">&lt;</span>sz<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//选出左右孩子中较大的那一个</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>child <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> sz <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>child <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			child <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span> arr<span class="token punctuation">[</span>child<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			parent <span class="token operator">=</span> child<span class="token punctuation">;</span>
			child <span class="token operator">=</span> parent <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> sz<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//建堆</span>

	<span class="token comment">//但是，如果我们要排升序，就要建大堆</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>sz <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">AdjustDown</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//建好了大堆</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">int</span> end <span class="token operator">=</span> sz <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>end <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//把第一个最大的和最后一个交换，把它不看作堆里的</span>
		<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token comment">//再把前n-1个向下调整成升序，再选出次大的数</span>
		<span class="token function">AdjustDown</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> end<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//end是需要调整的个数，0是根参数，</span>
		                        <span class="token comment">//用的是数组第一个元素的下标</span>
		end<span class="token operator">--</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>排序结果是：<br> <img src="https://images2.imgbox.com/0c/ff/j9DTUsFn_o.png" alt="![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/3cbb2bb1cd5b44e89cf8f904694f78d5.png"></p> 
<p><strong>1.5堆排序的时间复杂度：0(N*logN)，是不稳定的排序。</strong></p> 
<h2><a id="2__272"></a>2. 选择排序</h2> 
<p>选择排序是所有排序算法中最简单的，最容易理解的，同时也是效率极差的排序，几乎不用。</p> 
<h3><a id="21__275"></a>2.1 排序思想：</h3> 
<p><strong>遍历一个无序数组，一次选出最大值和最小值，再把这两个值分别放到最前和最后的位置；重复这个操作，选出次大值，次小值，分别放到数组的第二个位置和倒数第二个位置……</strong></p> 
<p><strong>图解如下：(默认排升序)</strong></p> 
<p><strong>begin ，end，maxi，mini存放的都是下标</strong>。<strong>让begin指向第一个元素，end指向最后一个元素</strong>，<strong>通过遍历数组，在begin和end区间内</strong>找到最大值8，下标maxi = 2，最小值-1，下标mini = 3</p> 
<p><img src="https://images2.imgbox.com/12/f6/BqqKt5hK_o.png" alt="![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/86defaa277ef4ce0adc4743ee9d4db67.png"></p> 
<p><strong>再让最大值和最小值分别与end，begin位置上的数交换，这样最小的就排在最前面，最大的就排在最后面了，再begin++，end–，在新区间内找到最大值和最小值</strong></p> 
<p><img src="https://images2.imgbox.com/c1/5f/wTHUHHJd_o.png" alt="![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/d66abd19a0454d00bb67c197ca8b29c9.png"></p> 
<p><strong>再次交换后，就得到了有序数组。</strong></p> 
<p><img src="https://images2.imgbox.com/fd/89/XBa7EbJn_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="22__292"></a>2.2 代码实现</h3> 
<p><strong>代码的实现如下：</strong></p> 
<pre><code class="prism language-c">
<span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> p2<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token operator">*</span>p1<span class="token punctuation">;</span>
	<span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span>
	<span class="token operator">*</span>p2 <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">SelectSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> sz<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> begin <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> end <span class="token operator">=</span> sz <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>

	<span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> end<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> maxi <span class="token operator">=</span> begin<span class="token punctuation">;</span>
		<span class="token keyword">int</span> mini <span class="token operator">=</span> end<span class="token punctuation">;</span>

		<span class="token comment">//循环找出当前数中的最大数和最小数的位置</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> begin<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>maxi<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				maxi <span class="token operator">=</span> i<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>mini<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				mini <span class="token operator">=</span> i<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		
		<span class="token comment">//让最大值和最小值分别与end，begin位置上的数交换</span>
		<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>mini<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>maxi<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		begin<span class="token operator">++</span><span class="token punctuation">;</span>
		end<span class="token operator">--</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><strong>2.3 代码的优化：</strong></p> 
<p><em><strong>但是上述代码有Bug！如果begin和maxi位置上要交换的数重叠，交换时就会发生混乱！图解如下：</strong></em></p> 
<p>maxi 和 end 位置上的数交换后，把最小值换走了，<strong>此时最大值放在了最小值的位置上</strong>，如果begin再和mini位置上的数交换，排序就会出错！</p> 
<p><img src="https://images2.imgbox.com/7f/c6/j7g1xBhQ_o.png" alt="![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/59f0d7825ba54ef48a330308375ba6b5.png"></p> 
<p><strong>代码优化如下：</strong></p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">SelectSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> sz<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> begin <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> end <span class="token operator">=</span> sz <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>

	<span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> end<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> maxi <span class="token operator">=</span> begin<span class="token punctuation">;</span>
		<span class="token keyword">int</span> mini <span class="token operator">=</span> end<span class="token punctuation">;</span>

		<span class="token comment">//循环找出当前数中的最大数和最小数</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> begin<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>maxi<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				maxi <span class="token operator">=</span> i<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>mini<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				mini <span class="token operator">=</span> i<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>mini<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">//如果begin和maxi位置上的数重叠，就要修正一下maxi的位置</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>begin <span class="token operator">==</span> maxi<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			maxi <span class="token operator">=</span> mini<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>maxi<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		begin<span class="token operator">++</span><span class="token punctuation">;</span>
		end<span class="token operator">--</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>排序结果如图：<br> <img src="https://images2.imgbox.com/33/47/L6nqEqjS_o.png" alt="在这里插入图片描述"></p> 
<p><strong>2.4 时间复杂度和稳定性</strong></p> 
<p>由于两个循环执行的次数大致都是N次(N为数组元素的个数)，所以<strong>选择排序的时间复杂度为0(N^2)，就算是最好的情况下，数组有序，时间复杂度也是0(N ^2),选择排序是不稳定的排序</strong>。</p> 
<h2><a id="3__392"></a>3. 堆排序和选择排序的性能比较</h2> 
<p><strong>clock()</strong> 函数<strong>是 &lt;time.h&gt; 头文件中的一个函数</strong>，用来返回程序启动到函数调用时之间的CPU时钟周期数。这个值通常用来帮助衡量程序或程序的某个部分的性能</p> 
<p><strong>我们可以用这个函数进一步对比两种排序占用的CPU时间</strong></p> 
<p>代码实现为：</p> 
<pre><code class="prism language-c"><span class="token comment">// 测试排序的性能对比</span>
<span class="token keyword">void</span> <span class="token function">TestOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">srand</span><span class="token punctuation">(</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">*</span> a1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">*</span> a2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">*</span> a3 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">*</span> a4 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">*</span> a5 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">*</span> a6 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		a1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		a3<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		a4<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">int</span> begin3 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">SelectSort</span><span class="token punctuation">(</span>a3<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> end3 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">int</span> begin4 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">HeapSort</span><span class="token punctuation">(</span>a4<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> end4 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"SelectSort:%d\n"</span><span class="token punctuation">,</span> end3 <span class="token operator">-</span> begin3<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"HeapSort:%d\n"</span><span class="token punctuation">,</span> end4 <span class="token operator">-</span> begin4<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token function">free</span><span class="token punctuation">(</span>a3<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>a4<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   <span class="token function">TestOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   
   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里<strong>随机生成十万个随机数</strong>，分别用希尔排序和直接插入排序来进行排序，测试两种算法的执行时间：</p> 
<p><img src="https://images2.imgbox.com/29/52/gg3Cbalm_o.png" alt="在这里插入图片描述"></p> 
<p><strong>由执行结果可知，堆排序的效率远远高于选择排序。选择排序真的很差！</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/35f419d547c5296ad8f628f0544c7176/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C/排序算法】：快速排序和归并排序的非递归实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/69d582fb6ef71275a57ec481bb06b90e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C/排序算法】：快速排序和冒泡排序</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>