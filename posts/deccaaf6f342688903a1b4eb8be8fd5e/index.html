<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;第四十二弹---C&#43;&#43;11新特性深度解析：让你的代码更现代、更高效(中) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/deccaaf6f342688903a1b4eb8be8fd5e/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C&#43;&#43;第四十二弹---C&#43;&#43;11新特性深度解析：让你的代码更现代、更高效(中)">
  <meta property="og:description" content="✨个人主页： 熬夜学编程的小林
💗系列专栏： 【C语言详解】 【数据结构详解】【C&#43;&#43;详解】
目录
1 右值引用和移动语义
1.1 左值引用和右值引用
1.2 左值引用与右值引用比较
1.3 右值引用使用场景和意义
1.4 右值引用引用左值及其一些更深入的使用场景分析
1.5 完美转发
1 右值引用和移动语义 1.1 左值引用和右值引用 传统的C&#43;&#43;语法中就有引用的语法，而C&#43;&#43;11中新增了的右值引用语法特性，所以从现在开始我们
之前学习的引用就叫做左值引用。无论左值引用还是右值引用，都是给对象取别名。
什么是左值？什么是左值引用？
左值是一个表示数据的表达式(如变量名或解引用的指针)，我们可以获取它的地址&#43;可以对它赋值，左值可以出现赋值符号的左边，右值不能出现在赋值符号左边。定义时const修饰符后的左值，不能给他赋值，但是可以取它的地址。左值引用就是给左值的引用，给左值取别名。
代码演示
int main() { // 左值是一个表达式，可以取地址 // 左值和右值，能否取地址 // 左值：能取地址 // 右值：不能取地址 int a = 10; int b = a; const int c = 10; int* p = &amp;a; vector&lt;int&gt; v(10, 1); v[1]; cout &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; &amp;b &lt;&lt; endl; cout &lt;&lt; &amp;c &lt;&lt; endl; cout &lt;&lt; &amp;(*p) &lt;&lt; endl; cout &lt;&lt; &amp;(v[1]) &lt;&lt; endl; return 0; } 测试结果 以上表达式均能够获取它的地址，因此均为左值。 什么是右值？什么是右值引用？">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-28T12:05:02+08:00">
    <meta property="article:modified_time" content="2024-08-28T12:05:02+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;第四十二弹---C&#43;&#43;11新特性深度解析：让你的代码更现代、更高效(中)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"> ✨<span style="color:#956fe7;">个人主页：</span><a href="https://blog.csdn.net/2201_75584283?spm=1011.2415.3001.5343" title=" 熬夜学编程的小林"> 熬夜学编程的小林</a></p> 
<p style="text-align:center;">💗<span style="color:#fe2c24;">系列专栏： </span><a href="https://blog.csdn.net/2201_75584283/category_12556736.html" title="【C语言详解】">【C语言详解】</a> <a href="https://blog.csdn.net/2201_75584283/category_12556751.html" title="【数据结构详解】">【数据结构详解】</a><a href="https://blog.csdn.net/2201_75584283/category_12577595.html?spm=1001.2014.3001.5482" title="【C++详解】">【C++详解】</a></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="1%20%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89-toc" style="margin-left:0px;"><a href="#1%20%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89" rel="nofollow">1 右值引用和移动语义</a></p> 
<p id="1.1%20%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8-toc" style="margin-left:40px;"><a href="#1.1%20%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8" rel="nofollow">1.1 左值引用和右值引用</a></p> 
<p id="1.2%20%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E6%AF%94%E8%BE%83-toc" style="margin-left:40px;"><a href="#1.2%20%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E6%AF%94%E8%BE%83" rel="nofollow">1.2 左值引用与右值引用比较</a></p> 
<p id="1.3%20%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E6%84%8F%E4%B9%89-toc" style="margin-left:40px;"><a href="#1.3%20%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E6%84%8F%E4%B9%89" rel="nofollow">1.3 右值引用使用场景和意义</a></p> 
<p id="1.4%20%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%BC%95%E7%94%A8%E5%B7%A6%E5%80%BC%E5%8F%8A%E5%85%B6%E4%B8%80%E4%BA%9B%E6%9B%B4%E6%B7%B1%E5%85%A5%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#1.4%20%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%BC%95%E7%94%A8%E5%B7%A6%E5%80%BC%E5%8F%8A%E5%85%B6%E4%B8%80%E4%BA%9B%E6%9B%B4%E6%B7%B1%E5%85%A5%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90" rel="nofollow">1.4 右值引用引用左值及其一些更深入的使用场景分析</a></p> 
<p id="1.5%20%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91-toc" style="margin-left:40px;"><a href="#1.5%20%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91" rel="nofollow">1.5 完美转发</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1%20%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89">1 右值引用和移动语义</h2> 
<h3 id="1.1%20%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><br> 1.1 左值引用和右值引用</h3> 
<p><br> 传统的C++语法中就有引用的语法，而C++11中新增了的右值引用语法特性，所以从现在开始我们<br> 之前学习的引用就叫做左值引用。<strong><span style="color:#0d0016;">无论左值引用还是右值引用，都是给对象取别名</span></strong>。<br>  </p> 
<p><span style="color:#fe2c24;">什么是左值？什么是左值引用？</span></p> 
<blockquote> 
 <p><strong><span style="color:#0d0016;">左值</span></strong>是一个<strong><span style="color:#fe2c24;">表示数据的表达式</span></strong>(如<span style="background-color:#38d8f0;">变量名或解引用的指针</span>)，我们<span style="background-color:#fbd4d0;">可以获取它的地址+可以对它赋值，左值可以出现赋值符号的左边</span>，<span style="background-color:#f9eda6;">右值不能出现在赋值符号左边</span>。定义时const修饰符后的左值，不能给他赋值，但是可以取它的地址。<strong><span style="color:#0d0016;">左值引用</span></strong>就是<strong><span style="color:#fe2c24;">给左值的引用，给左值取别名</span></strong>。</p> 
</blockquote> 
<p><span style="background-color:#f9eda6;">代码演示</span></p> 
<pre><code>int main()
{
	// 左值是一个表达式，可以取地址
	// 左值和右值，能否取地址
	// 左值：能取地址
	// 右值：不能取地址

	int a = 10;
	int b = a;
	const int c = 10;
	int* p = &amp;a;
	vector&lt;int&gt; v(10, 1);
	v[1];

	cout &lt;&lt; &amp;a &lt;&lt; endl;
	cout &lt;&lt; &amp;b &lt;&lt; endl;
	cout &lt;&lt; &amp;c &lt;&lt; endl;
	cout &lt;&lt; &amp;(*p) &lt;&lt; endl;
	cout &lt;&lt; &amp;(v[1]) &lt;&lt; endl;
	return 0;
}</code></pre> 
<p><span style="background-color:#f9eda6;">测试结果 </span></p> 
<p><img alt="" height="248" src="https://images2.imgbox.com/65/5b/ygryDCjE_o.png" width="642"></p> 
<blockquote> 
 <p>以上表达式均能够获取它的地址，因此均为左值。 </p> 
</blockquote> 
<p><span style="color:#fe2c24;">什么是右值？什么是右值引用？</span></p> 
<blockquote> 
 <p><strong><span style="color:#0d0016;">右值</span></strong>也是<strong><span style="color:#fe2c24;">一个表示数据的表达式</span></strong>，如：<span style="background-color:#38d8f0;">字面常量、表达式返回值，函数返回值(这个不能是左值引用返回)</span>等等，<span style="background-color:#fbd4d0;">右值可以出现在赋值符号的右边，但是不能出现出现在赋值符号的左边，右值不能取地址</span>。<strong><span style="color:#0d0016;">右值引用</span></strong>就是<strong><span style="color:#fe2c24;">对右值的引用，给右值取别名</span></strong>。</p> 
</blockquote> 
<p><span style="background-color:#f9eda6;">代码演示</span></p> 
<pre><code>int main()
{
    // 一下几个都是常见的右值
	// 10、string("1111")、to_string("1111")、x+y

	double x = 1.1;
	double y = 2.2;
    
    // 以下右值取地址会报错
	//cout &lt;&lt; &amp;10 &lt;&lt; endl;
	//cout &lt;&lt; &amp;(string("1111")) &lt;&lt; endl;
	//cout &lt;&lt; &amp;(to_string("1111")) &lt;&lt; endl;
	//cout &lt;&lt; &amp;(x + y) &lt;&lt; endl;
    
    // 以下几个都是对右值的右值引用
	double&amp;&amp; rref1 = x + y;
	string&amp;&amp; rref2 = string("11111");
	string&amp;&amp; rref3 = to_string(1111);
	int&amp;&amp; rref4 = 10;

	// 左值引用能否给右值取别名 ---不能，左值引用加const就能给右值取别名
	//string&amp; ref1 = string("11111");// 错误
	
	const string&amp; ref1 = string("11111");

	// 右值引用能否给左值取别名 ---不能，但是可以给move以后的左值取别名
	string s1("1111");
	string&amp;&amp; ref2 = move(s1);
	return 0;
}</code></pre> 
<p><span style="background-color:#f9eda6;">测试结果 </span></p> 
<p><img alt="" height="647" src="https://images2.imgbox.com/3e/11/nOXZ3XvG_o.png" width="1000"></p> 
<p><strong>右值引用，给值取别名</strong></p> 
<ul><li>纯右值(内置类型)</li><li>将亡值(自定义类型) </li></ul> 
<p>需要注意的是右值是不能取地址的，但是给右值取别名后，会导致右值被存储到特定位置，且可<br> 以取到该位置的地址，也就是说例如：不能取字面量10的地址，但是rr1引用后，可以对rr1取地<br> 址，也可以修改rr1。如果不想rr1被修改，可以用const int&amp;&amp; rr1 去引用，是不是感觉很神奇，<br> 这个了解一下实际中右值引用的使用场景并不在于此，这个特性也不重要。</p> 
<pre><code>int main()
{
    double x = 1.1, y = 2.2;
    int&amp;&amp; rr1 = 10;
    const double&amp;&amp; rr2 = x + y;
    rr1 = 20;
    rr2 = 5.5;  // 报错
    return 0;
}</code></pre> 
<p><span style="background-color:#f9eda6;">给rr2赋值结果 </span></p> 
<p><img alt="" height="30" src="https://images2.imgbox.com/69/f3/6E5sHeq3_o.png" width="330"></p> 
<p><span style="background-color:#f9eda6;">屏蔽rr2赋值结果</span></p> 
<p><img alt="" height="505" src="https://images2.imgbox.com/7c/b5/n2xnMwUO_o.png" width="1088"></p> 
<h3 id="1.2%20%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E6%AF%94%E8%BE%83">1.2 左值引用与右值引用比较</h3> 
<p><br> 左值引用总结：</p> 
<ul><li>1. 左值引用只能引用左值，不能引用右值。</li><li>2. 但是const左值引用既可引用左值，也可引用右值。</li></ul> 
<pre><code>int main()
{
   // 左值引用只能引用左值，不能引用右值。
   int a = 10;
   int&amp; ra1 = a;   // ra为a的别名
   //int&amp; ra2 = 10;   // 编译失败，因为10是右值
   // const左值引用既可引用左值，也可引用右值。
   const int&amp; ra3 = 10;
   const int&amp; ra4 = a;
   return 0;
}</code></pre> 
<p>右值引用总结：</p> 
<ul><li>1. 右值引用只能右值，不能引用左值。</li><li>2. 但是右值引用可以move以后的左值。</li></ul> 
<pre><code>int main()
{
    // 右值引用只能右值，不能引用左值。
    int&amp;&amp; r1 = 10;
    // error C2440: “初始化”: 无法从“int”转换为“int &amp;&amp;”
    // message : 无法将左值绑定到右值引用
    int a = 10;
    int&amp;&amp; r2 = a;
    // 右值引用可以引用move以后的左值
    int&amp;&amp; r3 = std::move(a);
    return 0;
}</code></pre> 
<h3 id="1.3%20%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E6%84%8F%E4%B9%89">1.3 右值引用使用场景和意义</h3> 
<p><br> 前面我们可以看到左值引用既可以引用左值和又可以引用右值，那为什么C++11还要提出右值引用呢？是不是化蛇添足呢？下面我们来看看左值引用的短板，右值引用是如何补齐这个短板的！</p> 
<p>我们通过自己实现的string类来验证！！！</p> 
<pre><code>namespace lin
{
	class string
	{
	public:
		typedef char* iterator;
		iterator begin()
		{
			return _str;
		}

		iterator end()
		{
			return _str + _size;
		}

		string(const char* str = "")
			:_size(strlen(str))
			, _capacity(_size)
		{
			cout &lt;&lt; "string(char* str) -- 构造" &lt;&lt; endl;

			_str = new char[_capacity + 1];
			strcpy(_str, str);
		}

		// s1.swap(s2)
		void swap(string&amp; s)
		{
			::swap(_str, s._str);
			::swap(_size, s._size);
			::swap(_capacity, s._capacity);
		}

		// 拷贝构造
		// 左值
		string(const string&amp; s)
			:_str(nullptr)
		{
			cout &lt;&lt; "string(const string&amp; s) -- 深拷贝" &lt;&lt; endl;

			_str = new char[s._capacity + 1];
			strcpy(_str, s._str);
			_size = s._size;
			_capacity = s._capacity;
		}

		// 赋值重载
		string&amp; operator=(const string&amp; s)
		{
			cout &lt;&lt; "string&amp; operator=(string s) -- 深拷贝" &lt;&lt; endl;
			char* tmp = new char[s._capacity + 1];
			strcpy(tmp, s._str);

			delete[] _str;
			_str = tmp;
			_size = s._size;
			_capacity = s._capacity;

			return *this;
		}

		~string()
		{
			delete[] _str;
			_str = nullptr;
		}

		char&amp; operator[](size_t pos)
		{
			assert(pos &lt; _size);
			return _str[pos];
		}

		void reserve(size_t n)
		{
			if (n &gt; _capacity)
			{
				char* tmp = new char[n + 1];
				strcpy(tmp, _str);
				delete[] _str;
				_str = tmp;

				_capacity = n;
			}
		}

		void push_back(char ch)
		{
			if (_size &gt;= _capacity)
			{
				size_t newcapacity = _capacity == 0 ? 4 : _capacity * 2;
				reserve(newcapacity);
			}

			_str[_size] = ch;
			++_size;
			_str[_size] = '\0';
		}

		//string operator+=(char ch)
		string&amp; operator+=(char ch)
		{
			push_back(ch);
			return *this;
		}

		const char* c_str() const
		{
			return _str;
		}
	private:
		char* _str;
		size_t _size;
		size_t _capacity; // 不包含最后做标识的\0
	};
	lin::string to_string(int value)
	{
		bool flag = true;
		if (value &lt; 0)
		{
			flag = false;
			value = 0 - value;
		}

		lin::string str;
		while (value &gt; 0)
		{
			int x = value % 10;
			value /= 10;
			str += ('0' + x);
		}
		if (flag == false)
		{
			str += '-';
		}
		std::reverse(str.begin(), str.end());

		return str;
	}
}</code></pre> 
<p><strong><span style="color:#0d0016;">左值引用的使用场景：</span></strong></p> 
<blockquote> 
 <p><span style="color:#fe2c24;">做参数和做返回值都可以提高效率。</span></p> 
</blockquote> 
<pre><code>void func1(lin::string s)
{}
void func2(const lin::string&amp; s)
{}
int main()
{
	lin::string s1("hello world");
	// func1和func2的调用我们可以看到左值引用做参数减少了拷贝，提高效率的使用场景和价值
	func1(s1);
	func2(s1);
	// string operator+=(char ch) 传值返回存在深拷贝
	// string&amp; operator+=(char ch) 传左值引用没有拷贝提高了效率
	s1 += '!';
	return 0;
}</code></pre> 
<p></p> 
<p><strong><span style="color:#0d0016;">左值引用的短板：</span></strong></p> 
<blockquote> 
 <p>但是当函数返回对象是一个局部变量，出了函数作用域就不存在了，就不能使用左值引用返回，只能传值返回。例如：lin::string to_string(int value)函数中可以看到，这里只能使用传值返回，传值返回会导致至少1次拷贝构造(如果是一些旧一点的编译器可能是两次拷贝构造)。</p> 
</blockquote> 
<p><span style="background-color:#f9eda6;">代码演示</span></p> 
<pre><code>int main()
{
	// 只调用了一次C字符串构造，编译器直接优化结果，VS2022环境
	lin::string ret = lin::to_string(1234);
	cout &lt;&lt; ret.c_str() &lt;&lt; endl;
	// 调用两次C字符串构造 + 赋值重载
	lin::string ret1;
	ret1 = lin::to_string(1478);

	return 0;
}</code></pre> 
<p><span style="background-color:#f9eda6;">测试结果 </span></p> 
<p><img alt="" height="472" src="https://images2.imgbox.com/30/7c/KNBM6k6Y_o.png" width="1132"></p> 
<p></p> 
<p><strong><span style="color:#0d0016;">右值引用和移动语义解决上述问题：</span></strong></p> 
<blockquote> 
 <p>在lin::string中增加<strong><span style="color:#0d0016;">移动构造</span></strong>，移动构造本质是<strong><span style="color:#fe2c24;">将参数右值的资源窃取过来</span></strong>，占位已有，那么就不用做深拷贝了，所以它叫做移动构造，就是窃取别人的资源来构造自己。</p> 
</blockquote> 
<pre><code>// 移动构造
// 右值(将亡值)
string(string&amp;&amp; s)
	:_str(nullptr)
{
	cout &lt;&lt; "string(string&amp;&amp; s) -- 移动构造" &lt;&lt; endl;
	swap(s);
}</code></pre> 
<p><strong><span style="color:#0d0016;">不仅仅有移动构造，还有移动赋值：</span></strong></p> 
<blockquote> 
 <p>在lin::string类中增加<strong><span style="color:#0d0016;">移动赋值函数</span></strong>，再去调用lin::to_string(1234)，不过这次是将<br> lin::to_string(1234)返回的右值对象赋值给ret1对象，这时调用的是移动构造。</p> 
</blockquote> 
<p><img alt="" height="285" src="https://images2.imgbox.com/69/6c/RjNkrpOI_o.png" width="1058"></p> 
<p></p> 
<h3 id="1.4%20%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%BC%95%E7%94%A8%E5%B7%A6%E5%80%BC%E5%8F%8A%E5%85%B6%E4%B8%80%E4%BA%9B%E6%9B%B4%E6%B7%B1%E5%85%A5%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90">1.4 右值引用引用左值及其一些更深入的使用场景分析</h3> 
<p><br> 按照语法，右值引用只能引用右值，但右值引用一定不能引用左值吗？因为：有些场景下，可能真的需要用右值去引用左值实现移动语义。<strong>当需要用右值引用引用一个左值时，可以通过move函数将左值转化为右值</strong>。C++11中，<span style="color:#0d0016;"><strong>std::move()</strong></span>函数位于 <strong><span style="color:#fe2c24;">#include&lt;utility&gt; </span></strong>头文件中，该函数名字具有迷惑性，它<strong>并不搬移任何东西，唯一的功能就是将一个左值强制转化为右值引用，然后实现移动语义。</strong></p> 
<p><span style="background-color:#f9eda6;">代码演示</span></p> 
<pre><code>int main()
{
	// 构造
	lin::string s1("111111111111111");
	// 赋值重载
	lin::string s2 = s1;
	// 移动构造
	lin::string s3 = move(s1);
	return 0;
}</code></pre> 
<p><span style="background-color:#f9eda6;">监视窗口 </span></p> 
<p><img alt="" height="757" src="https://images2.imgbox.com/24/71/hR6egH3W_o.png" width="1200"></p> 
<p><span style="background-color:#f9eda6;">测试结果 </span></p> 
<p><img alt="" height="297" src="https://images2.imgbox.com/51/55/xm0MaEX5_o.png" width="1002"></p> 
<blockquote> 
 <p><span style="color:#fe2c24;">注意：使用move()函数会将原来对象的数据转移走，请谨慎使用。 </span></p> 
</blockquote> 
<h3 id="1.5%20%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91">1.5 完美转发</h3> 
<p><strong>模板中的 &amp;&amp; 万能引用</strong></p> 
<p><span style="background-color:#f9eda6;">代码演示</span></p> 
<pre><code>// 模板中的&amp;&amp;不代表右值引用，而是万能引用，其既能接收左值又能接收右值。
// 模板的万能引用只是提供了能够接收同时接收左值引用和右值引用的能力，
void Fun(int&amp; x) { cout &lt;&lt; "左值引用" &lt;&lt; endl; }
void Fun(const int&amp; x) { cout &lt;&lt; "const 左值引用" &lt;&lt; endl; }

void Fun(int&amp;&amp; x) { cout &lt;&lt; "右值引用" &lt;&lt; endl; }
void Fun(const int&amp;&amp; x) { cout &lt;&lt; "const 右值引用" &lt;&lt; endl; }

// 实参传左值，就推成左值引用
// 实参传右值，就推成右值引用
template&lt;typename T&gt;
void PerfectForward(T&amp;&amp; t)
{
	Fun(t);// 直接使用参数传递，全部都是左值
}

// 实现传什么参数，调用对应的函数
int main()
{
	PerfectForward(10);           

	int a;
	PerfectForward(a);            
	PerfectForward(std::move(a)); 

	const int b = 8;
	PerfectForward(b);		      
	PerfectForward(std::move(b)); 
	return 0;
}</code></pre> 
<p><span style="background-color:#f9eda6;">测试结果 </span></p> 
<p><img alt="" height="449" src="https://images2.imgbox.com/2d/eb/Rkyf3q5N_o.png" width="851"></p> 
<blockquote> 
 <p>引用类型的唯一作用就是限制了接收的类型，后续使用中都退化成了左值，因此如果直接使用参数传递，得到的结果就是全部打印左值引用。 </p> 
</blockquote> 
<p> <strong><span style="color:#0d0016;">std::forward 完美转发在传参的过程中保留对象原生类型属性。</span></strong></p> 
<p><span style="color:#0d0016;"><span style="background-color:#f9eda6;">代码演示</span></span></p> 
<blockquote> 
 <p>将PerFectForward函数的函数体<strong><span style="color:#0d0016;">加上完美转发</span></strong>，则可以解决上面问题。</p> 
</blockquote> 
<pre><code>template&lt;typename T&gt;
void PerfectForward(T&amp;&amp; t)
{
	Fun(forward&lt;T&gt;(t));// 使用完美转发，传什么值调用什么函数
}
</code></pre> 
<p><span style="background-color:#f9eda6;">测试结果</span></p> 
<p><img alt="" height="443" src="https://images2.imgbox.com/5b/9a/O2XQ7F9b_o.png" width="874"></p> 
<blockquote> 
 <p><strong><span style="color:#0d0016;">使用完美转发可以达到传什么参数，调用什么函数。 </span></strong></p> 
</blockquote> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b6fc5a2f1f7f31b41bc5087ce54b0c1e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Leetcode面试经典150题-122.买卖股票的最佳时机II</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ebbd559a034ee5425ce38713ee7ecd38/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">STM32原理图一些引脚VDDA/VSSA/VBAT/OSC/NRST/BOOT</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>