<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构 —— 堆 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/c9e66762e891ccc210f09fc6c5d21d92/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构 —— 堆">
  <meta property="og:description" content="1.堆的概念及结构 堆是一种特殊的树形数据结构，称为“二叉堆”（binary heap）
看它的名字也可以看出堆与二叉树有关系：其实堆就是一种特殊的二叉树
堆的性质：
堆中某个结点的值总是不大于或不小于其父结点的值； 堆总是一棵完全二叉树 1.1大堆 大堆：
大堆的根节点是整个堆中最大的数每个父节点的值都大于或等于其孩子节点的值每个父节点的孩子之间并无直接的大小关系 1.2小堆 小堆：
小堆的根节点是整个堆中最小的数每个父节点的值都小于或等于其孩子节点的值每个父节点的孩子之间并无直接的大小关系 2.堆的实现 2.1使用数组结构实现的堆 由于堆是一个完全二叉树，所以堆通常使用数组来进行存储
使用数组的优点：
相较于双链表更加的节省内存空间相较于单链表可以更好的算父子关系，并找到想要找的父子 2.2堆向上调整算法 堆的向上调整（也称为堆化、堆的修复或堆的重新堆化）是堆数据结构维护其性质的关键操作之一
现在我们给出一个数组，逻辑上看做一颗完全二叉树。我们通过从最后一个叶子节点开始的向上调整算法可以把它调整成一个小堆 向下调整算法有一个前提：最后一个叶子之前是一个堆才能调整 int arr = [ 15, 18, 19, 25, 28, 34, 65, 49, 37, 10]
小堆演示向上调整算法演示过程
向上调整的过程 ：将新插入的值与它的父亲相比，如果小则向上调整，调整完成后与新的父亲去比较，直到其值 &gt;= 父亲的时候停止调整 void Swaps(HPDataType* a, HPDataType* b) { HPDataType temp; temp = *a; *a = *b; *b = temp; } //向上调整(小堆) //child是下标 void AdjustUp(HPDataType* a, int child) { assert(a); int parent = (child - 1) / 2;//算父亲节点的下标 //向下调整主要逻辑 while (child &gt; 0) //当调整至根节点时，已经调整至极限，不用在调整 { //当父亲节点 &gt; 孩子时，开始调整 if (a[parent] &gt; a[child]) { Swaps(&amp;a[child],&amp;a[parent]); //交换 child = parent; //走到新的位置为新一轮的向下调整做准备 parent = (child - 1) / 2; //算出新位置的父亲节点下标 } //当父亲节点 &lt; 孩子时,说明调整已经完毕，退出循环 else { break; } } } 2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-16T23:38:42+08:00">
    <meta property="article:modified_time" content="2024-06-16T23:38:42+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构 —— 堆</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1.堆的概念及结构</h2> 
<p>堆是一种特殊的树形数据结构，称为“二叉堆”（binary heap）</p> 
<p>看它的名字也可以看出堆与二叉树有关系：其实堆就是一种特殊的二叉树</p> 
<p>堆的性质：</p> 
<ul><li><span style="color:#777777;">堆中某个结点的值总是不大于或不小于其父结点的值； </span></li><li><span style="color:#777777;">堆总是一棵完全二叉树</span></li></ul> 
<h3>1.1大堆</h3> 
<p>大堆：</p> 
<ul><li>大堆的根节点是整个堆中最大的数</li><li>每个父节点的值都大于或等于其孩子节点的值</li><li>每个父节点的孩子之间并无直接的大小关系</li></ul> 
<p></p> 
<p class="img-center"><img alt="" height="270" src="https://images2.imgbox.com/2e/f4/ppFwqZMx_o.png" width="443"></p> 
<h3>1.2小堆 </h3> 
<p>小堆：</p> 
<ul><li> 小堆的根节点是整个堆中最小的数</li><li>每个父节点的值都小于或等于其孩子节点的值</li><li>每个父节点的孩子之间并无直接的大小关系</li></ul> 
<p class="img-center"><img alt="" height="265" src="https://images2.imgbox.com/19/f2/EAy6mCwg_o.png" width="435"></p> 
<h2> 2.堆的实现</h2> 
<h3>2.1使用数组结构实现的堆</h3> 
<p>由于堆是一个完全二叉树，所以堆通常使用数组来进行存储</p> 
<p>使用数组的优点：</p> 
<ul><li>相较于双链表更加的节省内存空间</li><li>相较于单链表可以更好的算父子关系，并找到想要找的父子</li></ul> 
<p class="img-center"><img alt="" height="367" src="https://images2.imgbox.com/ce/68/BUsg6WBH_o.png" width="766"></p> 
<p></p> 
<h3>2.2堆向上调整算法</h3> 
<p>堆的向上调整（也称为堆化、堆的修复或堆的重新堆化）是堆数据结构维护其性质的关键操作之一</p> 
<div> 
 <span style="color:#777777;">现在我们给出一个数组，逻辑上看做一颗完全二叉树。我们通过从最后一个叶子节点开始的向上调整算法可以把它调整成一个小堆</span> 
</div> 
<div> 
 <span style="color:#777777;">向下调整算法有一个前提：最后一个叶子之前是一个堆才能调整</span> 
</div> 
<div></div> 
<blockquote> 
 <p> int arr = [ 15, 18, 19, 25, 28, 34, 65, 49, 37, 10]</p> 
</blockquote> 
<p><em>小堆演示向上调整算法演示过程</em></p> 
<p><img alt="" height="484" src="https://images2.imgbox.com/b6/cd/YzDgCXqH_o.png" width="1200"></p> 
<p></p> 
<p class="img-center"><img alt="" height="595" src="https://images2.imgbox.com/97/2f/4MB2bCYv_o.png" width="1200"></p> 
<p>向上调整的过程 ：将新插入的值与它的父亲相比，如果小则向上调整，调整完成后与新的父亲去比较，直到其值 &gt;= 父亲的时候停止调整 </p> 
<pre><code>void Swaps(HPDataType* a, HPDataType* b) {
	HPDataType temp;

	temp = *a;
	*a = *b;
	*b = temp;
}

//向上调整(小堆)
//child是下标

void AdjustUp(HPDataType* a, int child) {
	assert(a);

	int parent = (child - 1) / 2;//算父亲节点的下标

    //向下调整主要逻辑
	while (child &gt; 0)     //当调整至根节点时，已经调整至极限，不用在调整
	{

        //当父亲节点 &gt; 孩子时，开始调整
		if (a[parent] &gt; a[child])     
		{

			Swaps(&amp;a[child],&amp;a[parent]);    //交换
			child = parent;                //走到新的位置为新一轮的向下调整做准备
			parent = (child - 1) / 2;     //算出新位置的父亲节点下标

		}

        //当父亲节点 &lt; 孩子时,说明调整已经完毕，退出循环
		else
		{
			break;
		}

	}
}</code></pre> 
<p></p> 
<h3>2.3堆向下调整算法</h3> 
<p>在堆排序或其他需要维护堆性质的场景中，当堆的某个节点不满足堆的性质（对于最大堆，父节点小于其子节点；对于最小堆，父节点大于其子节点）时，就需要通过向下调整来修复这个子树，使其重新成为堆</p> 
<div> 
 <span style="color:#777777;">现在我们给出一个数组，逻辑上看做一颗完全二叉树。我们通过从根结点开始的向下调整算法可以把它调整成一个小堆</span> 
</div> 
<div> 
 <span style="color:#777777;">向下调整算法有一个前提：左右子树必须是一个堆，才能调整</span> 
</div> 
<div></div> 
<blockquote> 
 <div>
   int array[] = {27,15,19,18,28,34,65,49,25,37}; 
 </div> 
</blockquote> 
<p></p> 
<p class="img-center"><img alt="" height="463" src="https://images2.imgbox.com/3f/56/8rt6CDUs_o.png" width="1067"></p> 
<h3> 2.4堆的插入</h3> 
<p><strong>堆的插入</strong>（HeapPush)：通常通过将新元素添加到堆的末尾，并通过<span style="color:#0d0016;"><strong>向上调整算法</strong></span>来维持堆的性质 <span style="color:#a5a5a5;">(由于插入前的堆肯定是一个标准的堆，所以我们在将数据插入后执行一次向上调整算法，即可完成堆的插入)</span></p> 
<h3>2.5堆的删除</h3> 
<p><strong>删除元素</strong>（HeapPop）：在最大堆或最小堆中，通常删除的是根节点（即最大或最小元素），并通过向<strong><span style="color:#0d0016;">下调整算法</span></strong>来维持堆的性质 <span style="color:#a5a5a5;">(由于删除前的堆肯定是一个标准的堆即左右子树肯定也是标准的堆，所以我们在将数据删除后执行一次向下调整算法，即可完成堆的删除)</span></p> 
<p><span style="color:#ffd900;"><em><strong>为什么要删除根节点？</strong></em></span></p> 
<ul><li>相较于删除别的位置的节点，每次删除的根节点都是堆中最大或最小的数（大堆为最大，小堆为最小）、</li><li>从根节点开始删除并调整堆结构，在实现上相对简便。只需删除后算法向下调整即可</li></ul> 
<h3>2.6堆的代码实现</h3> 
<h4><em>Heap.h</em></h4> 
<pre><code>#pragma once
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;

typedef int HPDataType;
typedef struct Heap
{
	HPDataType* _a;
	int _size;
	int _capacity;
}Heap;

//堆的初始化
void HeapInit(Heap* php);
// 堆的销毁
void HeapDestory(Heap* hp);
// 堆的插入
void HeapPush(Heap* hp, HPDataType x);
// 堆的删除
void HeapPop(Heap* hp);
// 取堆顶的数据
HPDataType HeapTop(Heap* hp);
// 堆的数据个数
int HeapSize(Heap* hp);
// 堆的判空
int HeapEmpty(Heap* hp);

//向上调整
void AdjustUp(HPDataType* a, int child);
//向下调整
void AdjustDown(HPDataType* a, int n, int parent);</code></pre> 
<p></p> 
<h4><em>Heap.c </em></h4> 
<pre><code>//堆的初始化
void HeapInit(Heap* hp) {
	assert(hp);

	hp-&gt;_a = NULL;
	hp-&gt;_capacity = hp-&gt;_size = 0;
}
// 堆的销毁
void HeapDestory(Heap* hp) {
	assert(hp);

	free(hp-&gt;_a);
	hp-&gt;_capacity = hp-&gt;_size = 0;
	
}
// 堆的插入
void HeapPush(Heap* hp, HPDataType x) {
	assert(hp);

	//扩容
	if (hp-&gt;_size == hp-&gt;_capacity)
	{
		int newcapacity = hp-&gt;_capacity == 0 ? 2 : hp-&gt;_capacity * 2;
		HPDataType* newa = (HPDataType*)realloc(hp-&gt;_a, newcapacity * sizeof(HPDataType));
		if (newa == NULL)
		{
			perror("realloc");
			return;
		}
		hp-&gt;_capacity = newcapacity;
		hp-&gt;_a = newa;
	}

	//插入数据
	hp-&gt;_a[hp-&gt;_size] = x;
	hp-&gt;_size++;

	//向上调整
	AdjustUp(hp-&gt;_a,hp-&gt;_size-1);

}
void Swaps(HPDataType* a, HPDataType* b) {
	HPDataType temp;

	temp = *a;
	*a = *b;
	*b = temp;
}
//向上调整(小堆)
//child是数组的下标
void AdjustUp(HPDataType* a, int child) {
	assert(a);

	int parent = (child - 1) / 2;

	while (child &gt; 0)
	{
		if (a[parent] &gt; a[child])
		{
			Swaps(&amp;a[child],&amp;a[parent]);
			child = parent;
			parent = (child - 1) / 2;
		}
		else
		{
			break;
		}

	}
}
// 堆的删除
void HeapPop(Heap* hp) {
	assert(hp);
	assert(hp-&gt;_size);

	//删除顶部数据  ，先与末尾的交换，在向下调整
	Swaps(&amp;hp-&gt;_a[0],&amp;hp-&gt;_a[hp-&gt;_size-1]);//让数组首元素，与尾元素交换位置
	hp-&gt;_size--;

	AdjustDown(hp-&gt;_a, hp-&gt;_size, 0);

}
//向下调整(小堆)
//n是数据数个数
void AdjustDown(HPDataType* a, int n, int parent) {
	assert(a);

	//假设法，默认两个孩子最小的是左孩子
	int child = parent * 2 + 1;

	//当没有左孩子的时候停止向下调整,拿新算的孩子位置去判断
	while (child &lt; n)
	{
		if (child + 1 &lt; n &amp;&amp; a[child + 1] &lt; a[child])//挑最小的孩子换，且要注意有没有右孩子
		{
			child += 1;
		}
		if (a[child] &lt; a[parent])//孩子比父亲小就往上换
		{
			Swaps(&amp;a[child], &amp;a[parent]);
			parent = child;//孩子变成父亲，与他的孩子比
			child = parent * 2 + 1;
		}
		else
		{
			break;
		}
	}


}
// 取堆顶的数据
HPDataType HeapTop(Heap* hp) {
	assert(hp);
	assert(hp-&gt;_size);

	return hp-&gt;_a[0];
}
// 堆的数据个数
int HeapSize(Heap* hp) {
	assert(hp);

	return hp-&gt;_size;
}
// 堆的判空
int HeapEmpty(Heap* hp) {

	return hp-&gt;_size == 0;
}</code></pre> 
<h2 style="background-color:transparent;">3堆的应用 — 堆排序 </h2> 
<p>堆排序，我们肯定是运用堆这个数据结构来完成我们的堆排序</p> 
<p>接下来我们将充分的了解堆排序的运作原理</p> 
<p>下面展示的是，用一个大堆如何排一个升序？</p> 
<blockquote> 
 <p><img alt="" height="406" src="https://images2.imgbox.com/e4/c2/yVvRFW9c_o.png" width="1200"></p> 
 <p><img alt="" height="340" src="https://images2.imgbox.com/69/1e/jCIVEYCw_o.png" width="1200"></p> 
 <p><img alt="" height="564" src="https://images2.imgbox.com/95/be/Tf80Zk2R_o.png" width="1200"></p> 
 <p><img alt="" height="383" src="https://images2.imgbox.com/82/0e/kPGrSuPm_o.png" width="1200"></p> 
</blockquote> 
<p>不难看出</p> 
<ul><li>在每次交换时，堆顶最小的数都会沉到当前堆底</li><li>小堆在经历过N（数据个数）轮后就会得到一个升序的数组</li><li>大堆在经历过N（数据个数）轮后就会得到一个降序的数组</li></ul> 
<hr> 
<p>知道了堆排序的运转过程之后还有一个问题：使用者不可能说给你一个堆结构让你排序，肯定给的是一串无序且不是堆的数组给你排，这时侯我们就要考虑<em><strong>如何建堆了</strong></em></p> 
<h3 style="background-color:transparent;">3.1建堆</h3> 
<p>难道说建堆要用到上面写的堆结构，一个一个的去push吗？</p> 
<p>其实不然，我们只需要使用<em><strong>向上调整算法</strong></em>或<strong><em>向下调整算法</em></strong>就可以完成建堆</p> 
<p></p> 
<p><em><strong>向上调整建堆法</strong></em></p> 
<blockquote> 
 <p><strong>1.构建过程</strong>：</p> 
 <ul><li>初始时，将数组的第一个元素视为堆的根节点（对于下标从0开始的数组，根节点的下标为0）</li><li>对于数组中剩余的元素（从下标1开始），将它们逐个视为“新插入”的元素，并执行向上调整操作</li><li>在向上调整过程中，对于当前元素，首先计算其父节点的下标（parent = (child - 1) / 2）。然后，比较当前元素与其父节点的值</li><li>如果当前元素的值大于其父节点的值（对于大根堆），则交换它们的位置。然后，将当前元素设置为新交换位置的父节点，并重复上述步骤，直到当前元素的值不大于其父节点的值或已经到达根节点</li><li>通过重复上述步骤，直到所有元素都被处理过，最终得到的数组将满足堆的性质</li></ul> 
 <p><strong>2.时间复杂度</strong>：</p> 
 <ul><li>向上调整建堆法的时间复杂度为O(N * logN)，其中N是数组中的元素数量</li></ul> 
 <pre><code>void Swaps(int* a, int* b) {
	int temp;

	temp = *a;
	*a = *b;
	*b = temp;
}

//向上调整(小堆)
void AdjustUp(int* a, int child) {
	assert(a);

	int parent = (child - 1) / 2;

	while (child &gt; 0)
	{
		if (a[parent] &gt; a[child])
		{
			Swaps(&amp;a[child], &amp;a[parent]);
			child = parent;
			parent = (child - 1) / 2;
		}
		else
		{
			break;
		}

	}
}

//堆排序
void HeapSort(int* a, int n) {

	//创建堆，向上调整建堆
	for (int i = 1; i &lt; n; i++) 
	{
		AdjustUp(a,i);
	}


}</code></pre> 
 <p></p> 
</blockquote> 
<p><em><strong>向下调整建堆法</strong></em></p> 
<blockquote> 
 <p>向下调整（Adjust Down）是指从给定的非叶子节点开始，通过与其子节点比较并交换位（如果需要）来确保堆的性质</p> 
 <p><strong>1.构建过程</strong></p> 
 <ol><li><strong>确定开始位置</strong>： 
   <ul><li>对于长度为n的数组，由于堆是完全二叉树，所以最后一个非叶子节点的下标为<code>(n-1-1)/2</code>（整数除法）</li><li>从这个下标开始，向前遍历所有非叶子节点</li></ul></li><li><strong>执行向下调整</strong></li><li><strong>遍历结束</strong>： 
   <ul><li>当所有非叶子节点都经过向下调整后，整个数组就形成了一个堆</li></ul></li></ol> 
 <p></p> 
 <p><strong>2.时间复杂度</strong></p> 
 <p>向下调整建堆法的时间复杂度为O(N)，其中N是数组中的元素数量</p> 
 <pre><code>void Swaps(int* a, int* b) {
	int temp;

	temp = *a;
	*a = *b;
	*b = temp;
}
//向上调整(小堆)
void AdjustUp(int* a, int child) {
	assert(a);

	int parent = (child - 1) / 2;

	while (child &gt; 0)
	{
		if (a[parent] &gt; a[child])
		{
			Swaps(&amp;a[child], &amp;a[parent]);
			child = parent;
			parent = (child - 1) / 2;
		}
		else
		{
			break;
		}

	}
}

//堆排序
void HeapSort(int* a, int n) {

	//创建堆，向下调整建堆
	int parent = (n - 1 - 1) / 2;    //找到最后一个非叶子节点

	for (parent; parent &gt;= 0; parent--)
	{
		AdjustDown(a, n, parent);
	}
	
	

}
</code></pre> 
 <p></p> 
</blockquote> 
<h3 style="background-color:transparent;"><span style="color:#777777;">3.2 </span><span style="color:#777777;"><strong>利用堆删除思想来进行排序</strong></span></h3> 
<pre><code>void Swaps(int* a, int* b) {
	int temp;

	temp = *a;
	*a = *b;
	*b = temp;
}

//向上调整(小堆)
void AdjustUp(int* a, int child) {
	assert(a);

	int parent = (child - 1) / 2;

	while (child &gt; 0)
	{
		if (a[parent] &gt; a[child])
		{
			Swaps(&amp;a[child], &amp;a[parent]);
			child = parent;
			parent = (child - 1) / 2;
		}
		else
		{
			break;
		}

	}
}

//向下调整(小堆)
void AdjustDown(int* a, int n, int parent) {
	assert(a);

	int child = parent * 2 + 1;

	while (child &lt; n)
	{
		if (child + 1 &lt; n &amp;&amp; a[child + 1] &lt; a[child])
		{
			child += 1;
		}
		if (a[child] &lt; a[parent])
		{
			Swaps(&amp;a[child], &amp;a[parent]);
			parent = child;
			child = parent * 2 + 1;
		}
		else
		{
			break;
		}
	}


}

//堆排序
void HeapSort(int* a, int n) {

	创建堆，向上调整建堆
	//for (int i = 1; i &lt; n; i++)
	//{
	//	AdjustUp(a, i);
	//}

	//创建堆，向下调整建堆
	int parent = (n - 1 - 1) / 2;

	for (parent; parent &gt;= 0; parent--)
	{
		AdjustDown(a, n, parent);
	}
	
	//小堆，可以排降序
	while (n)
	{
		Swaps(&amp;a[0], &amp;a[n - 1]);

		//交换完成把除了最后一个数据之外的数组看成一个新的堆,开始向下交换，形成新的小堆
		n--;
		AdjustDown(a, n, 0);

	}

}</code></pre> 
<h3 style="background-color:transparent;">3.3建堆的时间复杂度 </h3> 
<p><strong><em>树的高度</em></strong></p> 
<p></p> 
<div> 
 <span style="color:#777777;">因为堆是完全二叉树，而满二叉树也是完全二叉树，此处为了简化使用满二叉树来证明</span> 
 <span style="color:#777777;">(</span> 
 <span style="color:#777777;">时间复杂度本来看的 就是近似值，多几个结点不影响最终结果)</span> 
</div> 
<p><img alt="" height="582" src="https://images2.imgbox.com/f4/01/OdvWDgvw_o.png" width="1200"></p> 
<p> </p> 
<p><strong><em>向下建堆时间复杂度</em></strong></p> 
<p><img alt="" height="693" src="https://images2.imgbox.com/12/41/MBEijEf3_o.png" width="1152"></p> 
<p>向下建堆的时间复杂度 = O(N)</p> 
<p><strong><em>向上建堆时间复杂度</em></strong></p> 
<p><img alt="" height="785" src="https://images2.imgbox.com/7f/e2/d3BiQT3X_o.png" width="1200"></p> 
<p>向下建堆的时间复杂度 = O(N * logN)</p> 
<h2 style="background-color:transparent;">4堆的应用 — Top-K问题</h2> 
<div> 
 <span style="color:#777777;"><strong>TOP-K</strong></span> 
 <span style="color:#777777;"><strong>问题：即求数据结合中前</strong></span> 
 <span style="color:#777777;"><strong>K</strong></span> 
 <span style="color:#777777;"><strong>个最大的元素或者最小的元素，一般情况下数据量都比较大</strong></span> 
</div> 
<div></div> 
<div> 
 <span style="color:#777777;">比如：专业前</span> 
 <span style="color:#777777;">10</span> 
 <span style="color:#777777;">名、世界</span> 
 <span style="color:#777777;">500</span> 
 <span style="color:#777777;">强、富豪榜、游戏中前</span> 
 <span style="color:#777777;">100</span> 
 <span style="color:#777777;">的活跃玩家等</span> 
</div> 
<div></div> 
<div> 
 <span style="color:#777777;">对于</span> 
 <span style="color:#777777;">Top-K</span> 
 <span style="color:#777777;">问题，能想到的最简单直接的方式就是排序，但是：如果数据量非常大，排序就不太可取了</span> 
 <span style="color:#777777;">(</span> 
 <span style="color:#777777;">可能 数据都不能一下子全部加载到内存中)</span> 
 <span style="color:#777777;">。最佳的方式就是用堆来解决，基本思路如下： </span> 
</div> 
<div></div> 
<div> 
 <span style="color:#777777;">1. </span> 
 <span style="color:#777777;"><strong>用数据集合中前</strong></span> 
 <span style="color:#777777;"><strong>K</strong></span> 
 <span style="color:#777777;"><strong>个元素来建堆 </strong></span> 
</div> 
<ul><li><span style="color:#777777;">前</span><span style="color:#777777;">k</span><span style="color:#777777;">个最大的元素，则建小堆 </span></li><li><span style="color:#777777;">前</span><span style="color:#777777;">k</span><span style="color:#777777;">个最小的元素，则建大堆 </span></li></ul> 
<div> 
 <span style="color:#777777;">2. </span> 
 <span style="color:#777777;"><strong>用剩余的</strong></span> 
 <span style="color:#777777;"><strong>N-K</strong></span> 
 <span style="color:#777777;"><strong>个元素依次与堆顶元素来比较，不满足则替换堆顶元素 </strong></span> 
</div> 
<div></div> 
<div> 
 <span style="color:#777777;">将剩余</span> 
 <span style="color:#777777;">N-K</span> 
 <span style="color:#777777;">个元素依次与堆顶元素比完之后，堆中剩余的</span> 
 <span style="color:#777777;">K</span> 
 <span style="color:#777777;">个元素就是所求的前</span> 
 <span style="color:#777777;">K</span> 
 <span style="color:#777777;">个最小或者最大的元素。 </span> 
</div> 
<p></p> 
<p></p> 
<pre><code>void Swaps(int* a, int* b) {
	int temp;

	temp = *a;
	*a = *b;
	*b = temp;
}

//向下调整(小堆)大的下去
//n是数据数个数
void AdjustDown(HPDataType* a, int n, int parent) {
	assert(a);

	
	int child = parent * 2 + 1;

	
	while (child &lt; n)
	{
		if (child + 1 &lt; n &amp;&amp; a[child + 1] &lt; a[child])
		{
			child += 1;
		}
		if (a[child] &lt; a[parent])
		{
			Swaps(&amp;a[child], &amp;a[parent]);
			parent = child;
			child = parent * 2 + 1;
		}
		else
		{
			break;
		}
	}


}
void CreateNDate()
{
	// 造数据
	int n = 10000;
	srand((unsigned int)time(NULL));
	const char* file = "data.txt";
	FILE* fin = fopen(file, "w");
	if (fin == NULL)
	{
		perror("fopen error");
		return;
	}

	for (size_t i = 0; i &lt; n; ++i)
	{
		int x = rand() % 1000000;
		fprintf(fin, "%d\n", x);
	}

	fclose(fin);
}

void PrintTopK(int k) {

	//找出前K个最大的数

	//打开文件
	FILE* p = fopen("data.txt", "r");
	if (p == NULL)
	{
		perror("fopen error");
		return;
	}


	//构建一个小堆
	int x = 0;
	int arr[10] = { 0 };
	
	for (int i = k; i &lt; 10; i++)
	{
		fscanf(p,"%d", &amp;x);
		arr[i] = x;
	}

	//创建堆，向下调整建堆,F(N)
	int parent = (k - 1 - 1) / 2;

	for (parent; parent &gt;= 0; parent--)
	{
		AdjustDown(arr, k, parent);//这里的n数组的位置，里面的child会算出超过数组的位置，这样会停下来
	}

	//在将后面的数字依次对比小堆顶部，比它大就向下调整
	while (fscanf(p, "%d", &amp;x) &gt; 0)
	{
		if (arr[0] &lt; x)
		{
			arr[0] = x;
			AdjustDown(arr, k, 0);
		}
	}
	
	for (int i = 0; i &lt; k; i++)
	{
		printf("%d\n", arr[i]);
	}
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6c6906b1b10e3d4beee470cf9b5b22dd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Postman接口测试工具详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2939e02e2be94e6987e9a1de75e58ddb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Qt实现单例模式：Q_GLOBAL_STATIC和Q_GLOBAL_STATIC_WITH_ARGS</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>