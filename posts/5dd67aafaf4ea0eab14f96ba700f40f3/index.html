<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;高阶】：C&#43;&#43;11的深度解析下 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/5dd67aafaf4ea0eab14f96ba700f40f3/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;高阶】：C&#43;&#43;11的深度解析下">
  <meta property="og:description" content="✨ 彼方尚有荣光在，何须悲叹少年轻 🌏
📃个人主页：island1314
🔥个人专栏：C&#43;&#43;学习
🚀 欢迎关注：👍点赞 👂🏽留言 😍收藏 💞 💞 💞
🚀前言 若没有了解C&#43;&#43;11前面一部分知识的读者朋友们，可以看一下这篇文章：
【C&#43;&#43;高阶】：C&#43;&#43;11的深度解析上-CSDN博客
1、可变参数模板 1.1 概念 C&#43;&#43;11的新特性可变参数模板能够让您创建可以接受可变参数的函数模板和类模板，相比C&#43;&#43;98，类模版和函数模版中只能含固定数量的模版参数，可变模版参数无疑是一个巨大的改进。
可变模版参数参数类型可变参数个数可变打印参数包内容 下面就是一个基本可变参数的函数模板：
// Args是一个模板参数包，args是一个函数形参参数包 // 声明一个参数包Args...args，这个参数包中可以包含0到任意个模板参数。 //参数类型可变，参数个数可变 template &lt;class ...Args&gt; void ShowList(Args... args) {} //以前的模板写法，固定了参数个数，类型不确定 template &lt;class ...T&gt; void ShowList1(T... x) {} //对于Show调用 int main(){ ShowList(); ShowList(1); ShowList(1, &#34;xxxxx&#34;); } 其对sizeof的使用方法（不常见）
template &lt;class ...Args&gt; void ShowList(Args... args){ // 可变参数模版编译时解析 // 下面是运行获取和解析，所以不支持这样用 cout &lt;&lt; sizeof...(args) &lt;&lt; endl; for (size_t i = 0; i &lt; sizeof.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-01T16:29:27+08:00">
    <meta property="article:modified_time" content="2024-08-01T16:29:27+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;高阶】：C&#43;&#43;11的深度解析下</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" src="https://images2.imgbox.com/41/a8/6jta88Xv_o.jpg"></p> 
<p>✨                                      <strong><span style="color:#9c8ec1;">彼方尚有荣光在<strong>，何须悲叹少年轻</strong></span> </strong>     🌏</p> 
<p>📃<a href="https://so.csdn.net/so/search?q=%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5&amp;spm=1001.2101.3001.7020" title="个人主页">个人主页</a>：<a href="https://blog.csdn.net/island1314?spm=1011.2266.3001.5343" title="island1314">island1314</a></p> 
<p>🔥个人专栏：<a href="https://blog.csdn.net/island1314/category_12622912.html" title="C++学习">C++学习</a></p> 
<p>🚀 欢迎关注：👍点赞 👂🏽留言 😍收藏  💞 💞 💞</p> 
<h3 style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9a/4c/YMNkCjb6_o.gif"></h3> 
<hr> 
<h3>🚀前言</h3> 
<p>若没有了解C++11前面一部分知识的读者朋友们，可以看一下这篇文章：</p> 
<p><a href="https://blog.csdn.net/island1314/article/details/140804751?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22140804751%22%2C%22source%22%3A%22island1314%22%7D" title="【C++高阶】：C++11的深度解析上-CSDN博客">【C++高阶】：C++11的深度解析上-CSDN博客</a></p> 
<p></p> 
<h3 style="background-color:transparent;">1、可变参数模板</h3> 
<h4>1.1 概念</h4> 
<p>C++11的新特性可变参数模板能够让您创建可以接受可变参数的函数模板和类模板，相比C++98，类模版和函数模版中只能含固定数量的模版参数，可变模版参数无疑是一个巨大的改进。</p> 
<blockquote> 
 <ul><li>可变模版参数</li><li>参数类型可变</li><li>参数个数可变</li><li>打印参数包内容</li></ul> 
</blockquote> 
<p>下面就是一个基本可变参数的函数模板：</p> 
<pre><code class="language-cpp">// Args是一个模板参数包，args是一个函数形参参数包
// 声明一个参数包Args...args，这个参数包中可以包含0到任意个模板参数。
//参数类型可变，参数个数可变
template &lt;class ...Args&gt;
void ShowList(Args... args)
{}

//以前的模板写法，固定了参数个数，类型不确定
template &lt;class ...T&gt;
void ShowList1(T... x)
{}

//对于Show调用
int main(){
	ShowList();
	ShowList(1);
	ShowList(1, "xxxxx");
}</code></pre> 
<p><span style="color:#fe2c24;">其对sizeof的使用方法（不常见）</span></p> 
<pre><code class="language-cpp">template &lt;class ...Args&gt;
void ShowList(Args... args){
	// 可变参数模版编译时解析
	// 下面是运行获取和解析，所以不支持这样用
	cout &lt;&lt; sizeof...(args) &lt;&lt; endl;
	for (size_t i = 0; i &lt; sizeof...(args); i++){
		cout &lt;&lt; args[i] &lt;&lt; " ";//不支持这样打印参数包内容
	}
}</code></pre> 
<h4 style="background-color:transparent;">1.2 <strong>展开参数包的两种</strong>方式</h4> 
<h5 style="background-color:transparent;"><strong>递归函数方式展开参数包</strong></h5> 
<pre><code class="language-cpp">//用一个无参的来进行匹配
void Print() //当是0个参数包的时候，就匹配到该函数
{
	cout &lt;&lt; endl;
}

template &lt;class T, class ...Args&gt;
void Print(T&amp;&amp; x, Args&amp;&amp;... args) //三个参数包，先分析参数包类型
{
	cout &lt;&lt; x &lt;&lt; " "; //打印第一个参数
	Print(args...); //递归调用

//不能用这样来作0个参数包的截止
// 因为这里都是编译时推导的逻辑，而下面这个是运行时逻辑，在运行时判断，无法结束
	//if (sizeof...(args) == 0) return;
}

// 编译时递归推导解析参数
template &lt;class ...Args&gt;
void ShowList(Args&amp;&amp;... args){
	Print(args...);
}

int main(){
	ShowList();
	ShowList(1);
	ShowList(1, "xxxxx");
	ShowList(1, "xxxxx", 2.2);

	return 0;
}</code></pre> 
<p><strong>对于递归函数解包其实质分析：</strong></p> 
<h5 style="background-color:transparent;"><strong>逗号表达式展开参数包</strong></h5> 
<pre><code class="language-cpp">template &lt;class T&gt;
int PrintArg(T t){
	cout &lt;&lt; t &lt;&lt; " ";
	return 0;
}

template &lt;class ...Args&gt;
void ShowList(Args... args){
	int arr[] = { PrintArg(args)... };
	cout &lt;&lt; endl;
}
 
// 编译推演生成下面的函数
void ShowList(int x, char y, std::string z) //参数包换算之后就是这样的
{
	int arr[] = { PrintArg(x),PrintArg(y),PrintArg(z) }; //编译器通过解包生成的就是这个
	cout &lt;&lt; endl;
}

int main(){
	ShowList(1);
	ShowList(1, 'A');
	ShowList(1, 'A', std::string("sort"));

	return 0;
}</code></pre> 
<p>对于<strong>逗号表达式解包</strong>其实质分析：</p> 
<pre><code class="language-cpp">//之前去掉逗号表达式通过返回值去掉的
template &lt;class ...Args&gt;
void ShowList(Args... args){
	//int arr[] = { cout &lt;&lt; (args) &lt;&lt; " "... };  //这样编译通过不了
	//ostream arr[] = { cout &lt;&lt; (args) &lt;&lt; " "... }; //ostream不支持拷贝，也通过不了
	int arr[] = { (cout&lt;&lt;(args)&lt;&lt;" ", 0)...}; //加个逗号表达式，0作那个初始化

	cout &lt;&lt; endl;
}

void ShowList(int x, char y, std::string z) //相当于编译器生成了这个
{ //注意要有0
	int arr[] = { (cout&lt;&lt;(x)&lt;&lt;" ", 0), (cout &lt;&lt; (y) &lt;&lt; " ", 0), (cout &lt;&lt; (z) &lt;&lt; " ", 0) };

	cout &lt;&lt; endl;
}

int main(){
	ShowList(1, 'A', std::string("sort"));
	return 0;
}</code></pre> 
<h4></h4> 
<p></p> 
<h3 style="background-color:transparent;">2. lambda表达式</h3> 
<h4>2.1 概念</h4> 
<blockquote> 
 <p>     在C++98中，如果想要对一个数据集合中的元素进行排序，可以使用<strong>sort函数</strong>。如果待<strong>排序元素为自定义类型</strong>，需要用户使用<strong>仿函数定义排序时的比较规则</strong>。随着C++语法的发展，人们开始觉得上面的写法太复杂了，每次为了实现一个algorithm算法，都要重新去写一个类，如果每次比较的逻辑不一样，还要去实现多个类，特别是相同类的命名，这些都给编程者带来了极大的不便。因此，在C++11语法中出现了<strong>Lambda表达式</strong>。</p> 
</blockquote> 
<h4 style="background-color:transparent;">2.2 <strong>lambda表达式语法</strong></h4> 
<p><strong>lambda表达式书写格式：</strong>[capture-list] (parameters) mutable -&gt; return-type { statement}</p> 
<blockquote> 
 <ul><li><strong>[capture-list]：捕捉列表</strong>，该列表总是出现在lambda函数的开始位置，编译器根据[ ]判断接下来的函数是否为lambda函数，捕捉列表能够捕捉上下文中的变量供lambda函数使用。</li><li> <p><strong> (parameters)：</strong><strong>参数列表</strong>。与普通函数的参数列表一致，如果不需要参数传递，则可以<br> 连同()一起省略。</p> </li><li> <p><strong>mutable：</strong>默认情况下，lambda函数总是一个<strong>const函数</strong>，mutable可以<strong>取消其常量性</strong>。使用该修饰符时，<strong>参数列表不可省略(即使参数为空)</strong>。</p> </li><li> <p><strong>-&gt;returntype：返回值类型。</strong>用追踪返回类型形式声明函数的返回值类型，没有返回值时此部分可省略。返回值类型明确情况下，也可省略，由编译器对返回类型进行推导。</p> </li><li> <p><strong>{statement}：函数体</strong>。在该函数体内，除了可以使用其参数外，还可以使用所有捕获<br> 到的变量。</p> </li></ul> 
 <p>注意：<strong> 在lambda函数定义中，参数列表和返回值类型都是可选部分，而捕捉列表和函数体可以为空。因此C++11中最简单的lambda函数为：[]{}; 该lambda函数不能做任何事情</strong></p> 
</blockquote> 
<p><strong>捕获列表说明：</strong></p> 
<p>捕捉列表描述了上下文中那些数据可以被lambda使用，以及使用的方式传值还是传引用。</p> 
<ul><li>[var]：表示值传递方式捕捉变量var。</li><li>[=]：表示值传递方式捕获所有父作用域中的变量(包括成员函数中的this)。</li><li>[&amp;var]：表示引用传递捕捉变量var。</li><li>[&amp;]：表示引用传递捕捉所有父作用域中的变量(包括成员函数中的this)。</li><li>[this]：表示值传递方式捕捉当前的this指针。</li></ul> 
<p><strong>代码示例1：</strong></p> 
<pre><code class="language-cpp">// lambda 匿名函数的对象
int main(){
	auto add1 = [](int x, int y)-&gt;int {return x + y; };
	cout &lt;&lt; add1(1, 2) &lt;&lt; endl;

	auto func1 = []()-&gt;int{
		cout &lt;&lt; "hello bit" &lt;&lt; endl;
		cout &lt;&lt; "hello world" &lt;&lt; endl;
		return 0;
	};
	func1();

	// 返回值类型可自动推导类型，所以可以省略
	// 无参数可以省略
    // 返回值一般都不能省略
	auto func2 = []{
		cout &lt;&lt; "hello bit" &lt;&lt; endl;
		cout &lt;&lt; "hello world" &lt;&lt; endl;
		return 0;
	};
	cout &lt;&lt; func2() &lt;&lt; endl;

    //无返回值时可以省略返回值，但是建议最好还是有返回值
	auto func3 = []{
		cout &lt;&lt; "hello bit" &lt;&lt; endl;
		cout &lt;&lt; "hello world" &lt;&lt; endl;
	};
	func3();

	return 0;
}</code></pre> 
<p><strong>  代码示例2：</strong></p> 
<pre><code class="language-cpp">int main(){
	int a = 0, b = 1;

	auto swap1 = [](int&amp; x, int&amp; y){ //参数列表
		// 只能用当前lambda局部域和捕捉的对象
		int tmp = x;
		x = y;
		y = tmp;
	};
	swap1(a, b);

	// 传值捕捉本质是一种拷贝,并且const修饰了
	// mutable相当于去掉const属性，可以修改了
	// 但是修改了不会影响外面被捕捉的值，因为是一种拷贝
	auto swap2 = [a, b]()mutable{ //捕捉列表
		int tmp = a;
		a = b;
		b = tmp;
	};
	swap2();

	auto swap3 = [&amp;a, &amp;b](){ //这里 &amp; 是引用
		int tmp = a;
		a = b;
		b = tmp;
	};
	swap3();
     
    //...此处Goods的结构体构造三个参数分别为string _name，int _price，_evaluate
    vector&lt;Goods&gt; v = { { "苹果", 2.1, 5 }, { "香蕉", 3, 4 }, 
        { "橙子", 2.2,3 }, { "菠萝", 1.5, 4 } }; 
    //bool返回类型可以省略
    sort(v.begin(), v.end(), [](const Goods&amp; g1, const Goods&amp; g2)-&gt;bool
	{
		return g1._price &gt; g2._price;
	});
    
	return 0;
}</code></pre> 
<p><strong>注意：</strong></p> 
<blockquote> 
 <ul><li>父作用域指包含lambda函数的语句块</li><li>语法上捕捉列表可<strong>由多个捕捉项组成</strong>，并以<strong>逗号分割</strong>。比如：<strong>[=, &amp;a, &amp;b]</strong>：以<strong>引用传递</strong>的方式捕捉变量a和b，<strong>值传递</strong>方式捕捉其他所有变量 [&amp;，a,this]：<strong>值传递方式捕捉变量a和this，引用方式捕捉其他变量。</strong></li><li>捕捉列表<strong>不允许变量重复传递</strong>，否则就会<strong>导致编译错误</strong>。 比如：<strong>[=, a]</strong>： <strong>=</strong> 已经以值传递方式捕捉了所有变量，捕捉a重复。</li><li>在<strong>块作用域以外</strong>的lambda函数<strong>捕捉列表必须为空。</strong></li><li>在块作用域中的lambda函数<strong>仅能捕捉父作用域中局部变量</strong>，捕<strong>捉任何非此作用域或者非局部变量都会导致编译报错。</strong></li><li>lambda表达式之间<strong>不能相互赋值</strong>，即使看起来类型相同。</li></ul> 
 <p>总的来说，lambda表达式就是一个仿函数，底层被处理成为一个lambda_uuid的一个仿函数类。</p> 
</blockquote> 
<p>代码示例如下：</p> 
<pre><code class="language-cpp">int x = 0;
int main(){
	// 只能用当前lambda局部域和捕捉的对象和全局对象
	int a = 0, b = 1, c = 2, d = 3;
	// 所有值传值捕捉
	auto func1 = [=]{
		int ret = a + b + c + d + x;
		return ret;
	};
	func1();
	cout &lt;&lt; "auto func1 = [=]："&lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; " "  &lt;&lt; c &lt;&lt; " " &lt;&lt; d &lt;&lt; endl;

	// 所有值传引用捕捉
	auto func2 = [&amp;]{
		a++, b++, c++, d++;
		int ret = a + b + c + d;
		return ret;
	};
	func2();
	cout &lt;&lt;"auto func2 = [&amp;]："&lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; " " &lt;&lt; c &lt;&lt; " " &lt;&lt; d &lt;&lt; endl;

	// 混合捕捉
	auto func3 = [&amp;a, b]{
		a++;
		//b++; //由于b是传值捕捉，b就不能修改
		int ret = a + b;
		return ret;
	};
	func3();
	cout&lt;&lt;"auto func3 = [&amp;a, b]：" &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; " " &lt;&lt; c &lt;&lt; " " &lt;&lt; d &lt;&lt; endl;
	

	// 混合捕捉
	// 所有值以引用方式捕捉，d用传值捕捉
	auto func4 = [&amp;, d]{
		a++,b++,c++;
		//d++; //故d不能修改
		int ret = a + b + c + d;
	};
	func4();
	cout &lt;&lt; "auto func4 = [&amp;, d]：" &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; " "  &lt;&lt; c &lt;&lt; " " &lt;&lt; d &lt;&lt; endl;


	auto func5 = [=, &amp;d](){
		//a++, b++, c++; //a,b,c都不能修改
		d++; 
		int ret = a + b + c + d;
	};
	func5();
	cout &lt;&lt; "auto func5 = [=, &amp;d]()：" &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; " " &lt;&lt; c &lt;&lt; " " &lt;&lt; d &lt;&lt; endl;

	auto func6 = [=, &amp;d]() mutable {
		a++, b++, c++, d++; //都可以修改，但是只有d对外面的值有影响
		int ret = a + b + c + d;
	};
	func6();
	cout &lt;&lt; "auto func6 = [=, &amp;d]() mutable：" &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; " "&lt;&lt; c &lt;&lt; " " &lt;&lt; d &lt;&lt; endl;
	
	return 0;
}</code></pre> 
<p><img alt="" height="199" src="https://images2.imgbox.com/80/88/ENJo5v35_o.png" width="634"></p> 
<h4 style="background-color:transparent;">2.3 函数对象与lambda表达式</h4> 
<p>函数对象，又称为仿函数，即可以想函数一样使用的对象，就是在类中重载了operator()运算符的<br> 类对象。</p> 
<blockquote> 
 <p>      lambda表达式可以很好的代替仿函数使用，如果使用仿函数，阅读代码的人想要知道其中的逻辑还需要去对应的地方去找，而lambda表达式可以很好的避免这个问题，<strong>增强了代码的可读性：</strong></p> 
</blockquote> 
<pre><code class="language-cpp">class Rate{
public:
	Rate(double rate) : _rate(rate)
	{}

	double operator()(double money, int year){
		return money * _rate * year;
	}
private:
	double _rate;
};

//捕捉列表的对象是成员变量存在lambad类对象中
//捕捉的本质是构造函数的初始化列表

int main(){
	// 函数对象
	double rate = 0.015;
	Rate r1(rate);
	cout &lt;&lt; r1(10000, 2) &lt;&lt; endl;

	// lambda
	auto r2 = [rate](double monty, int year)-&gt;double{
		return monty * rate * year;
	};
	cout &lt;&lt; r2(10000, 2) &lt;&lt; endl;

	int x = 1, y = 2;
	auto r3 = [=](double monty, int year)-&gt;double{
		return monty * rate * year;
	};
	cout &lt;&lt; r3(10000, 2) &lt;&lt; endl;

	return 0;
}</code></pre> 
<p>从使用方式上来看，函数对象与lambda表达式完全一样。<br> 函数对象将rate作为其成员变量，在定义对象时给出初始值即可，lambda表达式通过捕获列表可<br> 以直接将该变量捕获到。</p> 
<p><img alt="" height="656" src="https://images2.imgbox.com/3c/bd/XNgJFu22_o.png" width="1200"></p> 
<p>实际在底层编译器对于lambda表达式的处理方式，完全就是按照函数对象的方式处理的，即：如<br> 果定义了一个lambda表达式，编译器会自动生成一个类，在该类中重载了operator()。</p> 
<p></p> 
<h3 style="background-color:transparent;">3、包装器</h3> 
<h4 style="background-color:transparent;">3.1 function</h4> 
<p>function包装器 也叫作适配器。C++中的function本质是一个类模板，也是一个包装器。</p> 
<blockquote> 
 <p>ret = func(x);</p> 
</blockquote> 
<p>上面func可能是什么呢？那么func可能是函数名？函数指针？函数对象(仿函数对象)？也有可能是lamber表达式对象？所以这些都是可调用的类型！如此丰富的类型，可能会导致模板的效率低下！</p> 
<p>举个例子：</p> 
<pre><code class="language-cpp">template&lt;class F, class T&gt;
T useF(F f, T x){
	static int count = 0;
	cout &lt;&lt; "count:" &lt;&lt; ++count &lt;&lt; endl;
	cout &lt;&lt; "count:" &lt;&lt; &amp;count &lt;&lt; endl;
	return f(x);
}
double f(double i){
	return i / 2;
}
struct Functor{
	double operator()(double d){
		return d / 3;
	}
};
int main(){
	// 函数名
	cout &lt;&lt; useF(f, 11.11) &lt;&lt; endl;
	// 函数对象
	cout &lt;&lt; useF(Functor(), 11.11) &lt;&lt; endl;
	// lamber表达式
	cout &lt;&lt; useF([](double d)-&gt;double { return d / 4; }, 11.11) &lt;&lt; endl;
	return 0;
}</code></pre> 
<p>通过上面的程序验证，我们会发现useF函数模板实例化了三份。<br> 但是包装器可以很好的解决上面的问题</p> 
<blockquote> 
 <p>std::function在头文件<strong>&lt;functional&gt;</strong><br> // 类模板原型如下<br><strong><span style="color:#956fe7;">template </span>&lt;<span style="color:#956fe7;">class</span><span style="color:#4da8ee;"> </span><span style="color:#38d8f0;">T</span>&gt; function;   // undefined<br><span style="color:#956fe7;">template</span> &lt;<span style="color:#956fe7;">class</span> Ret, <span style="color:#956fe7;">class</span>... Args&gt;<br><span style="color:#956fe7;">class</span><span style="color:#1a439c;"> </span><span style="color:#38d8f0;">function</span>&lt;Ret(Args...)&gt;;</strong></p> 
 <p><br> 模板参数说明：</p> 
 <ul><li><strong>Ret :</strong> 被调用函数的返回类型</li><li><strong>Args… </strong>：被调用函数的形参</li></ul> 
</blockquote> 
<p>使用方法如下：</p> 
<pre><code class="language-cpp">#include&lt;functional&gt;

int f(int a, int b){
	return a + b;
}

struct Functor{
public:
	int operator() (int a, int b){
		return a + b;
	}
};

class Plus{
public:
	static int plusi(int a, int b){
		return a + b;
	}
	double plusd(double a, double b){
		return a + b;
	}
};


int main(){
	// 包装可调用对象
	//function&lt;int(int)&gt; f1 = f; //类型不匹配会报错的
	function&lt;int(int, int)&gt; f1 = f; //实例化方式
	function&lt;int(int, int)&gt; f2 = Functor();
	function&lt;int(int, int)&gt; f3 = [](int a, int b) {return a + b; };

	cout &lt;&lt; f1(1, 1) &lt;&lt; endl;
	cout &lt;&lt; f2(1, 1) &lt;&lt; endl;
	cout &lt;&lt; f3(1, 1) &lt;&lt; endl;

	//由于成员函数的函数名受类域限制，因此下面我们需要指定函数名
	// 包装静态成员函数
	function&lt;int(int, int)&gt; f4 = &amp;Plus::plusi;
	cout &lt;&lt; f4(1, 1) &lt;&lt; endl;

	// 包装非静态成员函数
	//非静态的成员函数要取函数指针的时候，需要加个&amp;，静态可以不加
	//function&lt;double(double, double)&gt; f5 = &amp;Plus::plusd;  
	
	//由于上面编译通过，因为其还有一个隐含的this参数，下面有两种解决方案
	//方法一：传指针
	function&lt;double(Plus*, double, double)&gt; f5 = &amp;Plus::plusd;
	Plus pd;
	cout &lt;&lt; f5(&amp;pd, 1.1, 1.1) &lt;&lt; endl;

	//方法二：不传指针，只传对象
	function&lt;double(Plus, double, double)&gt; f6 = &amp;Plus::plusd;
	cout &lt;&lt; f6(pd, 1.1, 1.1) &lt;&lt; endl;
	cout &lt;&lt; f6(Plus(), 1.1, 1.1) &lt;&lt; endl;

	return 0;
}</code></pre> 
<p><span style="color:#be191c;">有了包装器，如何解决模板的效率低下，实例化多份的问题呢？</span></p> 
<pre><code class="language-cpp">template&lt;class F, class T&gt; 
T useF(F f, T x) {
	static int count = 0;
	cout &lt;&lt; "count:" &lt;&lt; ++count &lt;&lt; endl;
	cout &lt;&lt; "count:" &lt;&lt; &amp;count &lt;&lt; endl;
	return f(x);
}

double f(double i) {
	return i / 2;
}
struct Functor{
	double operator()(double d){
		return d / 3;
	}
};
int main(){
	// 函数名
	std::function&lt;double(double)&gt; func1 = f;
	cout &lt;&lt; useF(func1, 11.11) &lt;&lt; endl;
	// 函数对象
	std::function&lt;double(double)&gt; func2 = Functor();
	cout &lt;&lt; useF(func2, 11.11) &lt;&lt; endl;
	// lamber表达式
	std::function&lt;double(double)&gt; func3 = [](double d)-&gt;double{ return d / 4; };
	cout &lt;&lt; useF(func3, 11.11) &lt;&lt; endl;
	return 0;
}
 </code></pre> 
<p><span style="color:#fe2c24;">值得注意的是：对成员函数进行包装时，需要取地址</span></p> 
<p></p> 
<p><span style="color:#b95514;"><strong>包装器的一些其他使用场景：</strong></span></p> 
<p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/" rel="nofollow" title="逆波兰表达式求值">逆波兰表达式求值</a></p> 
<pre><code class="language-cpp">class Solution {
public:
    int evalRPN(vector&lt;string&gt;&amp; tokens) {
        stack&lt;int&gt; st;
        map&lt;string, function&lt;int(int, int)&gt;&gt;opFuncMap = {
            {"+", [](int x, int y){return x + y;}},
            {"-", [](int x, int y){return x - y;}},
            {"*", [](int x, int y){return x * y;}},
            {"/", [](int x, int y){return x / y;}}
        };
        // //方法一：
        // for(auto &amp;e : tokens){
        //     if(e == "+" || e == "-" || e == "*" || e == "/"){
        //         int r = st.top();st.pop();
        //         int l = st.top(); st.pop();
        //         switch(e[0]){
        //             case '+':
        //                 st.push(l + r);
        //                 break;
        //             case '-':
        //                 st.push(l - r);
        //                 break;
        //             case '*':
        //                 st.push(l * r);
        //                 break;
        //             case '/':
        //                 st.push(l / r);
        //                 break;
        //         }
        //     }
        //     else {
        //         st.push(stoi(e));
        //     }
        // }
        
        //方法二：
        for(auto &amp;e : tokens)
        {
            //if(e == "+" || e == "-" || e == "*" || e == "/")
            if(opFuncMap.count(e)) {  // == 1就是操作符
                int r = st.top();st.pop();
                int l = st.top();st.pop();
                int ret = opFuncMap[e](l,r);
                st.push(ret);
            }
            else{
                st.push(stoi(e));
            }
        }

        return st.top();
    }
};</code></pre> 
<h4 style="background-color:transparent;">3.2 bind</h4> 
<p style="background-color:transparent;"><img alt="" height="131" src="https://images2.imgbox.com/b8/fb/0DbGN8Xp_o.png" width="551"></p> 
<p></p> 
<blockquote> 
 <p>        bind是一个函数模板，它就像一个函数包装器(适配器)，接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。一般而言，我们用它可以把一个原本接收N个参数的函数fn，通过绑定一些参数，返回一个接收M个<strong>（M可以大于N，但这么做没什么意义）参数的新函数</strong>。同时，使用bind函数还可以实现参数顺序调整等操作。</p> 
</blockquote> 
<p><img alt="" height="137" src="https://images2.imgbox.com/ae/09/sm5cW4Pa_o.png" width="423"></p> 
<p><img alt="" height="127" src="https://images2.imgbox.com/12/21/btnE1WsW_o.png" width="558"></p> 
<blockquote> 
 <p>        可以将bind函数看作是一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。 调用bind的一般形式：auto newCallable =bind(callable,arg_list);其中，newCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable的参数。当我们调用newCallable时，newCallable会调用callable,并传给它arg_list中的参数。<br>         arg_list中的参数可能包含形如_n的名字，其中n是一个整数，这些参数是“占位符”，表示newCallable的参数，它们占据了传递给newCallable的参数的“位置”。数值n表示生成的可调用对象中参数的位置：_1为newCallable的第一个参数，_2为第二个参数，以此类推。</p> 
</blockquote> 
<p>使用如下：</p> 
<pre><code class="language-cpp">int Sub(int a, int b){return (a - b) * 10;}

int SubX(int a, int b, int c){return (a - b - c) * 10;}

//可以用命名空间展示出来
using placeholders::_1;
using placeholders::_2;
using placeholders::_3;

int main()
{
	//auto sub1 = bind(Sub,placeholders::_1,placeholders::_2);
	// bind 本质返回的一个仿函数对象
	// 调整参数顺序（不常用）
	// _1代表第一个实参
	// _2代表第二个实参

	auto sub1 = bind(Sub, _1, _2); //代表Sub(_1, _2)
	cout &lt;&lt; sub1(10, 5) &lt;&lt; endl;//10 相当于_1, 5相当于_2

	auto sub2 = bind(Sub, _2, _1); //代表Sub(_2, _1)
	cout &lt;&lt; sub2(10, 5) &lt;&lt; endl; //5 相当于_2, 10相当于_1

	//调整参数个数（常用）
	auto sub3 = bind(Sub, 10, _1); //代表Sub(100, _1)
	cout &lt;&lt; sub3(5) &lt;&lt; endl; //5 相当于_1

	auto sub4 = bind(Sub, _1, 10); //代表Sub(_1, 10)
	cout &lt;&lt; sub4(5) &lt;&lt; endl; //5 相当于_1

	// 分别绑死第123个参数
	auto sub5 = bind(SubX, 10, _1, _2);
	cout &lt;&lt; sub5(5, 1) &lt;&lt; endl;

	auto sub6 = bind(SubX, _1, 10, _2);
	cout &lt;&lt; sub6(5, 1) &lt;&lt; endl;

	auto sub7 = bind(SubX, _1, _2, 10);
	cout &lt;&lt; sub7(5, 1) &lt;&lt; endl;

	function&lt;double(Plus, double, double)&gt; f6 = &amp;Plus::plusd;
	Plus pd;
	cout &lt;&lt; f6(pd, 1.1, 1.1) &lt;&lt; endl;
	cout &lt;&lt; f6(Plus(), 1.1, 1.1) &lt;&lt; endl;

	// bind一般用于，绑死一些固定参数
	function&lt;double(double, double)&gt; f7 = bind(&amp;Plus::plusd, Plus(), _1, _2);
	cout &lt;&lt; f7(1.1, 1.1) &lt;&lt; endl;


	//auto func1 = [](double rate, double money, int year)-&gt;double {return monty * rate * year; }; //单利
	auto func1 = [](double rate, double money, int year)-&gt;double { //复利
		double ret = money;
		for (int i = 0; i &lt; year; i++)
		{
			ret += ret * rate;
		}

		return ret - money;
	};

	function&lt;double(double)&gt; func3_1_5 = bind(func1, 0.015, _1, 3);
	function&lt;double(double)&gt; func5_1_5 = bind(func1, 0.015, _1, 5);
	function&lt;double(double)&gt; func10_2_5 = bind(func1, 0.025, _1, 10);
	function&lt;double(double)&gt; func20_3_5 = bind(func1, 0.035, _1, 30);

	cout &lt;&lt; func3_1_5(1000000) &lt;&lt; endl;
	cout &lt;&lt; func5_1_5(1000000) &lt;&lt; endl;
	cout &lt;&lt; func10_2_5(1000000) &lt;&lt; endl;
	cout &lt;&lt; func20_3_5(1000000) &lt;&lt; endl;

	return 0;
}</code></pre> 
<p></p> 
<p></p> 
<p><strong>包装器的作用：</strong>统一可调用对象的类型，指明了参数和返回值类型</p> 
<p>不包装前可能存在很多问题：</p> 
<ul><li>函数指针太复杂，不方便理解。</li><li>仿函数类型是一个类名，没有指明参数和返回值，需要去operator()才能看出来。</li><li>lambda表达式在语法层看不到类型。</li></ul> 
<hr> 
<h4>📖总结</h4> 
<blockquote> 
 <p>以上就是C++11的全部内容啦</p> 
 <p><strong>本篇到此就结束，希望我的这篇博客可以给你提供有益的参考和启示，感谢大家支持！！！</strong></p> 
 <p><strong>祝大家天天顺心如意。</strong></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/bd/3e/TReRlLp6_o.gif"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f8b7b23d0e78429ede68c6f443e5733a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言 数组</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4bf2aa9f34c9f0cd036597e968d90b91/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">提前批测开三面，已OC！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>