<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】栈的实现 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/89c3ba114536ca382bcc57b8ef10c892/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】栈的实现">
  <meta property="og:description" content="你内心肯定有有着某种火焰，能把你和其他人区别开来。 --库切
目录 🚗一.栈的概念及结构
🚒二.栈的基本操作 🍗1.栈的初始化
🥩2.入栈
🍊3.栈顶的元素
🍒4.出栈
🍓5.判断栈是否为空
🍌6.栈中的元素个数
​🌶️7.销毁栈
🚙三.栈的全部代码
🍍1.Stack.h：
🥔2.Stack.c：
🍎3.test.c：
🚗一.栈的概念及结构 栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除操作，进行数据的插入和删除操作的一端称为栈顶。另一端称为栈底。栈中数据元素遵循后进先出LIFO(last in first out)。
栈最基本的两个操作就是压栈和出栈。
1.压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。
2.出栈：栈的删除操作叫做出栈，出数据也在栈顶。 通俗的理解其实就是我们之前学习的尾插和尾删，尾插对应的就是压栈，尾删对应的就是出栈。
但是对于尾插，尾删，我们学习了三种结构：顺序表(数组)，单链表，双链表。所以这里我们选用哪一种结构来实现栈呢？
对于单链表尾插，尾删，我们每次都需要遍历整个数组，来找到尾，再进行操作，时间复杂度是O(N)，所以我们不会使用单链表来实现栈，我们可以选择顺序表(数组)或者双链表来实现。
这里我们选择的是顺序表(数组)。
和之前一样,我们使用结构体来实现:
typedef int STDataType; typedef struct Stack { STDataType* a;//动态数组 STDataType top;//栈顶 int Capacity;//容量 }ST; 🚒二.栈的基本操作 🍗1.栈的初始化 对于栈的初始化，我们可以先使用malloc动态的给数组开辟几个空间，容量也栈初始化几个。
//初始化栈 void StackInit(ST* ps) { assert(ps); ps-&gt;a = (STDataType*)malloc(sizeof(STDataType) * 4);//动态的开辟空间 if (ps-&gt;a == NULL) { perror(&#34;malloc\n&#34;); return; } ps-&gt;top = 0; ps-&gt;Capacity = 4;//初始化容量为4 } 🥩2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-06T19:55:04+08:00">
    <meta property="article:modified_time" content="2024-06-06T19:55:04+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】栈的实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong><span style="color:#0d0016;">你内心肯定有有着某种火焰，能把你和其他人区别开来。                   --库切</span></strong><br><img alt="" height="366" src="https://images2.imgbox.com/6f/be/X3i2NYM0_o.jpg" width="550"><br><strong>目录</strong> </p> 
<p id="%F0%9F%9A%97%E4%B8%80.%E6%A0%88%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#%F0%9F%9A%97%E4%B8%80.%E6%A0%88%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84" rel="nofollow">🚗一.栈的概念及结构</a></p> 
<p id="%F0%9F%9A%92%E4%BA%8C.%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%C2%A0-toc" style="margin-left:0px;"><a href="#%F0%9F%9A%92%E4%BA%8C.%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%C2%A0" rel="nofollow">🚒二.栈的基本操作 </a></p> 
<p id="%F0%9F%8D%971.%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:80px;"><a href="#%F0%9F%8D%971.%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">🍗1.栈的初始化</a></p> 
<p id="%F0%9F%A5%A92.%E5%85%A5%E6%A0%88-toc" style="margin-left:80px;"><a href="#%F0%9F%A5%A92.%E5%85%A5%E6%A0%88" rel="nofollow">🥩2.入栈</a></p> 
<p id="%F0%9F%8D%8A3.%E6%A0%88%E9%A1%B6%E7%9A%84%E5%85%83%E7%B4%A0-toc" style="margin-left:80px;"><a href="#%F0%9F%8D%8A3.%E6%A0%88%E9%A1%B6%E7%9A%84%E5%85%83%E7%B4%A0" rel="nofollow">🍊3.栈顶的元素</a></p> 
<p id="%F0%9F%8D%924.%E5%87%BA%E6%A0%88-toc" style="margin-left:80px;"><a href="#%F0%9F%8D%924.%E5%87%BA%E6%A0%88" rel="nofollow">🍒4.出栈</a></p> 
<p id="%F0%9F%8D%935.%E5%88%A4%E6%96%AD%E6%A0%88%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA-toc" style="margin-left:80px;"><a href="#%F0%9F%8D%935.%E5%88%A4%E6%96%AD%E6%A0%88%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA" rel="nofollow">🍓5.判断栈是否为空</a></p> 
<p id="%F0%9F%8D%8C6.%E6%A0%88%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0-toc" style="margin-left:80px;"><a href="#%F0%9F%8D%8C6.%E6%A0%88%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0" rel="nofollow">🍌6.栈中的元素个数</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91%F0%9F%8C%B6%EF%B8%8F7.%E9%94%80%E6%AF%81%E6%A0%88-toc" style="margin-left:80px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91%F0%9F%8C%B6%EF%B8%8F7.%E9%94%80%E6%AF%81%E6%A0%88" rel="nofollow">​🌶️7.销毁栈</a></p> 
<p id="%F0%9F%9A%99%E4%B8%89.%E6%A0%88%E7%9A%84%E5%85%A8%E9%83%A8%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;"><a href="#%F0%9F%9A%99%E4%B8%89.%E6%A0%88%E7%9A%84%E5%85%A8%E9%83%A8%E4%BB%A3%E7%A0%81" rel="nofollow">🚙三.栈的全部代码</a></p> 
<p id="%F0%9F%8D%8D1.Stack.h%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%F0%9F%8D%8D1.Stack.h%EF%BC%9A" rel="nofollow">🍍1.Stack.h：</a></p> 
<p id="%F0%9F%A5%942.Stack.c%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%F0%9F%A5%942.Stack.c%EF%BC%9A" rel="nofollow">🥔2.Stack.c：</a></p> 
<p id="%F0%9F%8D%8E3.test.c%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%F0%9F%8D%8E3.test.c%EF%BC%9A" rel="nofollow">🍎3.test.c：</a></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%F0%9F%9A%97%E4%B8%80.%E6%A0%88%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%BB%93%E6%9E%84">🚗一.栈的概念及结构</h2> 
<p><strong>栈：</strong>一种特殊的线性表，其只允许在固定的一端进行插入和删除操作，进行数据的插入和删除操作的<strong>一端称为栈顶。另一端称为栈底。</strong>栈中数据元素<strong>遵循后进先出</strong>LIFO(last in first out)。<br><img alt="" height="266" src="https://images2.imgbox.com/60/17/aB3iz9AW_o.png" width="683"></p> 
<p>栈最基本的两个操作就是<strong>压栈和出栈。</strong><br><strong>1.压栈：</strong>栈的插入操作叫做进栈/压栈/入栈，<strong>入数据在栈顶。</strong><br><strong>2.出栈：</strong>栈的删除操作叫做出栈，<strong>出数据也在栈顶。</strong> <br> 通俗的理解其实就是我们之前学习的尾插和尾删，<strong>尾插对应的就是压栈，尾删对应的就是出栈。</strong><br> 但是对于尾插，尾删，我们学习了三种结构：顺序表(数组)，单链表，双链表。所以这里我们选用哪一种结构来实现栈呢？<br><br><strong>对于单链表尾插，尾删，我们每次都需要遍历整个数组</strong>，来找到尾，再进行操作，时间复杂度是O(N)，所以我们不会使用单链表来实现栈，我们可以<strong>选择顺序表(数组)或者双链表来实现。<br><span style="color:#fe2c24;">这里我们选择的是顺序表(数组)。</span></strong><br> 和之前一样,我们使用<strong>结构体来实现:</strong></p> 
<pre><code class="language-cpp">typedef int STDataType;
typedef struct Stack
{
	STDataType* a;//动态数组
	STDataType top;//栈顶
	int Capacity;//容量
}ST;</code></pre> 
<h2 id="%F0%9F%9A%92%E4%BA%8C.%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%C2%A0">🚒二.栈的基本操作 </h2> 
<h4 id="%F0%9F%8D%971.%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">🍗1.栈的初始化</h4> 
<p>对于栈的初始化，我们可以先使用<strong>malloc动态的给数组开辟</strong>几个空间，容量也栈初始化几个。</p> 
<pre><code class="language-cpp">//初始化栈
void StackInit(ST* ps)
{
	assert(ps);
	ps-&gt;a = (STDataType*)malloc(sizeof(STDataType) * 4);//动态的开辟空间
	if (ps-&gt;a == NULL)
	{
		perror("malloc\n");
		return;
	}
	ps-&gt;top = 0;
	ps-&gt;Capacity = 4;//初始化容量为4
}
</code></pre> 
<h4 id="%F0%9F%A5%A92.%E5%85%A5%E6%A0%88"><strong>🥩2.入栈</strong></h4> 
<p>入栈也就是尾插，这是我们之前学过的，这是非常简单的。但是还是有个小细节要注意，<strong>在入栈之前，我们需要判断一下，栈内的容量是否满了，满了就要增容。</strong></p> 
<pre><code class="language-cpp">// 入栈
void StackPush(ST* ps,STDataType x)
{
	assert(ps);
	//判断是否满了
	if (ps-&gt;top == ps-&gt;Capacity)
	{
		STDataType* temp = (STDataType*)realloc(ps-&gt;a, sizeof(STDataType) * ps-&gt;Capacity * 2);
		if (temp==NULL)
		{
			perror("realloc\n");
			return;
		}
			ps-&gt;Capacity *= 2;//每次增容尾上一次的二倍
			ps-&gt;a = temp;
	}
		ps-&gt;a[ps-&gt;top] = x;
		ps-&gt;top++;//栈内入一个数据，top就要往上面走一步
}</code></pre> 
<h4 id="%F0%9F%8D%8A3.%E6%A0%88%E9%A1%B6%E7%9A%84%E5%85%83%E7%B4%A0"><strong>🍊3.</strong>栈顶的元素</h4> 
<p>我们要打印栈顶的元素要怎么打印呢？当入栈已经结束了之后，我们先打印第一个栈顶的元素，然后再出栈一个，继续打印栈顶的元素，以此类推，直到栈为空。</p> 
<pre><code class="language-cpp">STDataType StackTop(ST* ps) 
{
	assert(ps);
	assert(ps-&gt;top &gt; 0);//这里要断言一下，如果栈为空，就不能打印了
	return ps-&gt;a[ps-&gt;top - 1];
}</code></pre> 
<h4 id="%F0%9F%8D%924.%E5%87%BA%E6%A0%88">🍒4.出栈</h4> 
<p>出栈也就是我们所说的尾删，数组的尾删<strong>只需要把top的位置往前挪一位</strong>就行了。</p> 
<pre><code class="language-cpp">void StackPop(ST* ps)
{
	assert(ps);
	assert(ps-&gt;top &gt; 0);
	ps-&gt;top--;
}</code></pre> 
<h4 id="%F0%9F%8D%935.%E5%88%A4%E6%96%AD%E6%A0%88%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA">🍓5.判断栈是否为空</h4> 
<p>为什么要判断栈为空呢？因为当我们进行出栈的时候，栈内的元素为依次减小，如果减小到0，就不能继续出栈了。</p> 
<pre><code class="language-cpp">//判断栈是否为空
bool StackEmpty(ST* ps)//这里我们使用bool来判断
{
	assert(ps);
	return ps-&gt;top == 0;//当ps-&gt;top为0的时候，式子成立，即返回真。反之，亦然。
}</code></pre> 
<p>我们就先往栈入 <strong>1  2  3  4</strong>四个数字，再依次出栈出来打印出来看看。</p> 
<pre><code class="language-cpp">int main()
{
	ST st;
	StackInit(&amp;st);
	StackPush(&amp;st, 1);
	StackPush(&amp;st, 2);
	StackPush(&amp;st, 3);
	StackPush(&amp;st, 4);
	while (!StackEmpty(&amp;st))
	{
		printf("%d ", StackTop(&amp;st));
		StackPop(&amp;st);
	}
	printf("\n");
	return 0;
}</code></pre> 
<p><img alt="" height="581" src="https://images2.imgbox.com/8b/ed/2Xc8OgIw_o.png" width="897"><br><strong>很明显这很符合栈的先入后出的特点。</strong></p> 
<h4 id="%F0%9F%8D%8C6.%E6%A0%88%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0">🍌6.栈中的元素个数</h4> 
<p>我们入了几个元素，top就是机，直接把top打印出来就是栈元素的个数了。</p> 
<pre><code class="language-cpp">int StackSize(ST* ps)
{
	assert(ps);
	return ps-&gt;top;
}</code></pre> 
<h4 id="%E2%80%8B%E7%BC%96%E8%BE%91%F0%9F%8C%B6%EF%B8%8F7.%E9%94%80%E6%AF%81%E6%A0%88"><img alt="" height="375" src="https://images2.imgbox.com/a4/8f/t8fz69h1_o.png" width="927"><br><br> 🌶️7.销毁栈</h4> 
<p>当我们退出程序的时候，把栈给销毁一下。</p> 
<pre><code class="language-cpp">//销毁栈
void StackDestroy(ST* ps)
{
	free(ps-&gt;a);
	ps-&gt;a = NULL;
	ps-&gt;Capacity = 0;
	ps-&gt;top = 0;
}
</code></pre> 
<h2 id="%F0%9F%9A%99%E4%B8%89.%E6%A0%88%E7%9A%84%E5%85%A8%E9%83%A8%E4%BB%A3%E7%A0%81">🚙三.栈的全部代码</h2> 
<h4 id="%F0%9F%8D%8D1.Stack.h%EF%BC%9A">🍍1.Stack.h：</h4> 
<pre><code class="language-cpp">#pragma once
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;stdbool.h&gt;
typedef int STDataType;
typedef struct Stack
{
	STDataType* a;//动态数组
	STDataType top;//栈顶
	int Capacity;//容量
}ST;

//初始化栈
void StackInit(ST* ps);

//入栈
void StackPush(ST* ps, STDataType x);

//出栈
void StackPop(ST* ps);

//栈元素的个数
int StackSize(ST* ps);

//判断栈是否为空
bool StackEmpty(ST* ps);

//栈顶的元素是多少
STDataType StackTop(ST* ps);

//销毁栈
void StackDestroy(ST* ps);

</code></pre> 
<h4 id="%F0%9F%A5%942.Stack.c%EF%BC%9A"><strong>🥔2.Stack.c：</strong><br>  </h4> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1
#include"Stack.h"
//初始化栈
void StackInit(ST* ps)
{
	assert(ps);
	ps-&gt;a = (STDataType*)malloc(sizeof(STDataType) * 4);
	if (ps-&gt;a == NULL)
	{
		perror("malloc\n");
		return;
	}
	ps-&gt;top = 0;
	ps-&gt;Capacity = 4;
}

// 入栈
void StackPush(ST* ps,STDataType x)
{
	assert(ps);
	//判断是否满了
	if (ps-&gt;top == ps-&gt;Capacity)
	{
		STDataType* temp = (STDataType*)realloc(ps-&gt;a, sizeof(STDataType) * ps-&gt;Capacity * 2);
		if (temp==NULL)
		{
			perror("realloc\n");
			return;
		}
			ps-&gt;Capacity *= 2;//每次增容尾上一次的二倍
			ps-&gt;a = temp;
	}
		ps-&gt;a[ps-&gt;top] = x;
		ps-&gt;top++;//栈内入一个数据，top就要往上面走一步
}

//出栈
void StackPop(ST* ps)
{
	assert(ps);
	assert(ps-&gt;top &gt; 0);
	ps-&gt;top--;
}

//栈元素的个数
int StackSize(ST* ps)
{
	assert(ps);
	return ps-&gt;top;
}

//判断栈是否为空
bool StackEmpty(ST* ps)
{
	assert(ps);
	return ps-&gt;top == 0;
}


//栈顶的元素是多少
STDataType StackTop(ST* ps) 
{
	assert(ps);
	assert(ps-&gt;top &gt; 0);
	return ps-&gt;a[ps-&gt;top - 1];
}


//销毁栈
void StackDestroy(ST* ps)
{
	free(ps-&gt;a);
	ps-&gt;a = NULL;
	ps-&gt;Capacity = 0;
	ps-&gt;top = 0;
}

//打印函数
void StackPrint(ST* ps)
{
	assert(ps);
	int i = 0;
	while (i &lt; ps-&gt;top)
	{
		printf("%d", ps-&gt;a[i]);
		i++;
	}
}
</code></pre> 
<h4 id="%F0%9F%8D%8E3.test.c%EF%BC%9A"><strong>🍎3.test.c：</strong></h4> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1
#include"Stack.h"
ST st;
void Stacktest1()
{
	StackInit(&amp;st);
	StackPush(&amp;st, 1);
	StackPush(&amp;st, 2);
	StackPush(&amp;st, 3);
	StackPush(&amp;st, 4);
	while (!StackEmpty(&amp;st))
	{
		printf("%d ", StackTop(&amp;st));
		StackPop(&amp;st);
	}
	printf("\n");
}

void Stacktest2()
{
	StackInit(&amp;st);
	StackPush(&amp;st, 1);
	StackPush(&amp;st, 2);
	StackPush(&amp;st, 3);
	StackPush(&amp;st, 4);
	printf("栈内元素的个数：\n");
    printf( "%d\n",StackSize(&amp;st));
	

}
int main()
{
	//Stacktest1();
	Stacktest2();
	return 0;
}</code></pre> 
<h2></h2> 
<p><br><br><br>  </p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/00121ba44346d7d211410b1746c6e8a1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">IP质量不够好，可以使用高质量的代理IP吗？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/83fb160ae67850545b2434e39dc10348/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">爬山算法详细介绍</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>