<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构-双链表(图解) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/9af9119ae3aef9a2f1ae83d8e4ef81ae/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构-双链表(图解)">
  <meta property="og:description" content="目录
双链表（Double-Linked List）的概念与基本特性
一、双链表的基本组成
二、双链表的主要特性
三、双链表的操作 代码展示
malloc开辟函数
解析
初始化
解析
头插
解析
尾插
解析
头删
解析
尾删
解析
pos之后插入
解析
pos删除
解析
打印
解析
全部代码展示
main.c
text.c
text.h
双链表（Double-Linked List）的概念与基本特性 双链表是一种常用且重要的线性数据结构，它在计算机科学和软件工程中扮演着不可或缺的角色。相较于单链表，双链表的每个节点包含两个指针，分别指向其前驱节点（previous node）和后继节点（next node），这一特性使得双链表在数据操作上具有更高的灵活性。
一、双链表的基本组成 双链表中的每一个元素称为节点（Node），每个节点通常包含三个部分：
数据域（Data Field）：用于存储实际数据，可以是任何类型的数据。前驱指针（Previous Pointer/Backward Pointer）：指向当前节点的前一个节点。后继指针（Next Pointer/Forward Pointer）：指向当前节点的下一个节点。 二、双链表的主要特性 双向遍历：由于每个节点都有前后两个指针，因此可以在列表中双向遍历，无需像单链表那样只能从头节点开始向前遍历。插入与删除的便捷性：在双链表中插入或删除一个节点时，只需改变相应节点的前后节点的指针指向即可，操作相对简单高效。 三、双链表的操作 常见的双链表操作包括创建、插入（包括头部插入、尾部插入和指定位置插入）、删除（包括头部删除、尾部删除和指定节点删除）、查找以及遍历等。
代码展示 malloc开辟函数 //内存开辟 listcode* inaugurate(LTDataType x) { listcode* list = (listcode*)malloc(sizeof(listcode)); if (list == NULL) { perror(&#34;malloc&#34;); exit(1); } //初始值 list-&gt;val = x; list-&gt;next = list-&gt;prev = NULL; return list; } 解析 listcode* inaugurate(LTDataType x)` 函数定义：`inaugurate`是一个函数，接收一个参数`x`，类型为`LTDataType`。这个函数返回一个指向`listcode`结构体类型的指针。 `listcode* list = (listcode*)malloc(sizeof(listcode));` - 动态内存分配：使用`malloc`函数动态地在堆内存中分配一块大小等于`listcode`结构体所占用空间的连续区域，并将其地址赋值给`listcode`类型的指针变量`list`。如果内存分配失败，`malloc`将返回NULL。 if (list == NULL) { perror(&#34;">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-20T21:28:50+08:00">
    <meta property="article:modified_time" content="2024-04-20T21:28:50+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构-双链表(图解)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E5%8F%8C%E9%93%BE%E8%A1%A8%EF%BC%88Double-Linked%20List%EF%BC%89%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7-toc" style="margin-left:0px;"><a href="#%E5%8F%8C%E9%93%BE%E8%A1%A8%EF%BC%88Double-Linked%20List%EF%BC%89%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7" rel="nofollow">双链表（Double-Linked List）的概念与基本特性</a></p> 
<p id="%E4%B8%80%E3%80%81%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90" rel="nofollow">一、双链表的基本组成</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7" rel="nofollow">二、双链表的主要特性</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C%C2%A0-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C%C2%A0" rel="nofollow">三、双链表的操作 </a></p> 
<p id="%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA-toc" style="margin-left:80px;"><a href="#%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA" rel="nofollow">代码展示</a></p> 
<p id="malloc%E5%BC%80%E8%BE%9F%E5%87%BD%E6%95%B0-toc" style="margin-left:120px;"><a href="#malloc%E5%BC%80%E8%BE%9F%E5%87%BD%E6%95%B0" rel="nofollow">malloc开辟函数</a></p> 
<p id="%E8%A7%A3%E6%9E%90-toc" style="margin-left:200px;"><a href="#%E8%A7%A3%E6%9E%90" rel="nofollow">解析</a></p> 
<p id="%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:160px;"><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">初始化</a></p> 
<p id="%E8%A7%A3%E6%9E%90-toc" style="margin-left:200px;"><a href="#%E8%A7%A3%E6%9E%90" rel="nofollow">解析</a></p> 
<p id="%E5%A4%B4%E6%8F%92-toc" style="margin-left:160px;"><a href="#%E5%A4%B4%E6%8F%92" rel="nofollow">头插</a></p> 
<p id="%E8%A7%A3%E6%9E%90-toc" style="margin-left:200px;"><a href="#%E8%A7%A3%E6%9E%90" rel="nofollow">解析</a></p> 
<p id="%E5%B0%BE%E6%8F%92-toc" style="margin-left:160px;"><a href="#%E5%B0%BE%E6%8F%92" rel="nofollow">尾插</a></p> 
<p id="%E8%A7%A3%E6%9E%90-toc" style="margin-left:200px;"><a href="#%E8%A7%A3%E6%9E%90" rel="nofollow">解析</a></p> 
<p id="%E5%A4%B4%E5%88%A0-toc" style="margin-left:160px;"><a href="#%E5%A4%B4%E5%88%A0" rel="nofollow">头删</a></p> 
<p id="%E8%A7%A3%E6%9E%90-toc" style="margin-left:200px;"><a href="#%E8%A7%A3%E6%9E%90" rel="nofollow">解析</a></p> 
<p id="%E5%B0%BE%E5%88%A0-toc" style="margin-left:160px;"><a href="#%E5%B0%BE%E5%88%A0" rel="nofollow">尾删</a></p> 
<p id="%E8%A7%A3%E6%9E%90-toc" style="margin-left:200px;"><a href="#%E8%A7%A3%E6%9E%90" rel="nofollow">解析</a></p> 
<p id="pos%E4%B9%8B%E5%90%8E%E6%8F%92%E5%85%A5-toc" style="margin-left:160px;"><a href="#pos%E4%B9%8B%E5%90%8E%E6%8F%92%E5%85%A5" rel="nofollow">pos之后插入</a></p> 
<p id="%E8%A7%A3%E6%9E%90-toc" style="margin-left:200px;"><a href="#%E8%A7%A3%E6%9E%90" rel="nofollow">解析</a></p> 
<p id="pos%E5%88%A0%E9%99%A4-toc" style="margin-left:160px;"><a href="#pos%E5%88%A0%E9%99%A4" rel="nofollow">pos删除</a></p> 
<p id="%E8%A7%A3%E6%9E%90-toc" style="margin-left:200px;"><a href="#%E8%A7%A3%E6%9E%90" rel="nofollow">解析</a></p> 
<p id="%E6%89%93%E5%8D%B0-toc" style="margin-left:160px;"><a href="#%E6%89%93%E5%8D%B0" rel="nofollow">打印</a></p> 
<p id="%E8%A7%A3%E6%9E%90-toc" style="margin-left:200px;"><a href="#%E8%A7%A3%E6%9E%90" rel="nofollow">解析</a></p> 
<p id="%E5%85%A8%E9%83%A8%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA-toc" style="margin-left:40px;"><a href="#%E5%85%A8%E9%83%A8%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA" rel="nofollow">全部代码展示</a></p> 
<p id="main.c-toc" style="margin-left:160px;"><a href="#main.c" rel="nofollow">main.c</a></p> 
<p id="text.c-toc" style="margin-left:160px;"><a href="#text.c" rel="nofollow">text.c</a></p> 
<p id="text.h-toc" style="margin-left:160px;"><a href="#text.h" rel="nofollow">text.h</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%8F%8C%E9%93%BE%E8%A1%A8%EF%BC%88Double-Linked%20List%EF%BC%89%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7" style="background-color:transparent;"><strong>双链表（Double-Linked List）的概念与基本特性</strong></h2> 
<p>双链表是一种常用且重要的线性数据结构，它在计算机科学和软件工程中扮演着不可或缺的角色。相较于单链表，双链表的每个节点包含两个指针，分别指向其前驱节点（previous node）和后继节点（next node），这一特性使得双链表在数据操作上具有更高的灵活性。</p> 
<h3 id="%E4%B8%80%E3%80%81%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90" style="background-color:transparent;"><strong>一、双链表的基本组成</strong></h3> 
<p>双链表中的每一个元素称为节点（Node），每个节点通常包含三个部分：</p> 
<blockquote> 
 <ol><li>数据域（Data Field）：用于存储实际数据，可以是任何类型的数据。</li><li>前驱指针（Previous Pointer/Backward Pointer）：指向当前节点的前一个节点。</li><li>后继指针（Next Pointer/Forward Pointer）：指向当前节点的下一个节点。</li></ol> 
</blockquote> 
<h3 id="%E4%BA%8C%E3%80%81%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7"><strong>二、双链表的主要特性</strong></h3> 
<ol><li>双向遍历：由于每个节点都有前后两个指针，因此可以在列表中双向遍历，无需像单链表那样只能从头节点开始向前遍历。</li><li>插入与删除的便捷性：在双链表中插入或删除一个节点时，只需改变相应节点的前后节点的指针指向即可，操作相对简单高效。</li></ol> 
<p><img alt="" height="146" src="https://images2.imgbox.com/dc/5f/NG8h5VoY_o.png" width="845"></p> 
<h3 id="%E4%B8%89%E3%80%81%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C%C2%A0"><strong>三、双链表的操作</strong> </h3> 
<p>常见的双链表操作包括创建、插入（包括头部插入、尾部插入和指定位置插入）、删除（包括头部删除、尾部删除和指定节点删除）、查找以及遍历等。</p> 
<h4 id="%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA">代码展示</h4> 
<h5 id="malloc%E5%BC%80%E8%BE%9F%E5%87%BD%E6%95%B0">malloc开辟函数</h5> 
<pre><code class="language-cpp">//内存开辟
listcode* inaugurate(LTDataType x) {
	listcode* list = (listcode*)malloc(sizeof(listcode));
	if (list == NULL)
	{
		perror("malloc");
		exit(1);
	}
	//初始值
	list-&gt;val = x;
	list-&gt;next = list-&gt;prev = NULL;

	return list;
}</code></pre> 
<h6 id="%E8%A7%A3%E6%9E%90">解析</h6> 
<pre><code class="language-cpp">listcode* inaugurate(LTDataType x)`
 函数定义：`inaugurate`是一个函数，接收一个参数`x`，类型为`LTDataType`。这个函数返回一个指向`listcode`结构体类型的指针。

`listcode* list = (listcode*)malloc(sizeof(listcode));`
- 动态内存分配：使用`malloc`函数动态地在堆内存中分配一块大小等于`listcode`结构体所占用空间的连续区域，并将其地址赋值给`listcode`类型的指针变量`list`。如果内存分配失败，`malloc`将返回NULL。

if (list == NULL)
{
    perror("malloc");
    exit(1);
}</code></pre> 
<ul><li>错误处理：检查<code>list</code>是否为空（即内存分配是否成功）。若<code>list</code>为NULL，则说明内存分配失败，调用<code>perror</code>输出错误信息（"malloc"），然后调用<code>exit(1)</code>终止程序执行。</li></ul> 
<pre><code class="language-cpp">list-&gt;val = x;</code></pre> 
<ul><li>初始化节点数据：将传入的参数<code>x</code>赋值给新创建节点的<code>val</code>字段，这里假设<code>val</code>是<code>listcode</code>结构体中用于存储数据的成员变量。</li></ul> 
<pre><code class="language-cpp">list-&gt;next = list-&gt;prev = NULL;</code></pre> 
<ul><li>初始化节点指针：将新创建节点的<code>next</code>和<code>prev</code>指针都初始化为NULL，表示这是链表中的一个独立节点，目前既没有前驱也没有后继节点。</li></ul> 
<p>最后，函数返回初始化后的节点指针<code>list</code>，这样就可以进一步将此节点添加到现有的双链表中或者其他相关操作。</p> 
<pre><code class="language-cpp">phead-&gt;next = phead;
phead-&gt;prev = phead;</code></pre> 
<hr> 
<h6 id="%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</h6> 
<pre><code class="language-cpp">//初始化
listcode* initialize() {
	listcode* phead = inaugurate(0);
	phead-&gt;next = phead;
	phead-&gt;prev = phead;
	return phead;
}</code></pre> 
<h6 style="background-color:transparent;">解析</h6> 
<pre><code class="language-cpp">`listcode* initialize()`
- 函数定义：`initialize`函数无参数，其功能是初始化一个循环双链表，并返回链表的头节点。


listcode* phead = inaugurate(0);</code></pre> 
<ul><li>创建头节点：调用上面解释的<code>inaugurate</code>函数初始化并创建一个新的<code>listcode</code>节点，并将一个默认值0赋给节点的<code>val</code>字段。并将新创建的节点指针赋值给<code>phead</code>。</li></ul> 
<pre><code class="language-cpp">phead-&gt;next = phead;
phead-&gt;prev = phead;</code></pre> 
<ul><li>构造循环结构：将头节点的<code>next</code>指针和<code>prev</code>指针都指向自己（即<code>phead</code>），从而形成一个循环结构。在这种情况下，尽管链表中只有一个节点，但它既是头节点也是尾节点，并形成了一个自引用的循环，这样在后续对链表进行操作时（例如插入或删除节点）可以简化边界条件的处理。</li></ul> 
<p>最后，函数返回初始化完成的头节点指针<code>phead</code>，标志着一个空的循环双链表已经创建完成。当向这个链表中添加新的节点时，新节点可以被插入到<code>phead</code>节点的前面或后面，同时维护循环双链表的特性。</p> 
<hr> 
<h6 id="%E5%A4%B4%E6%8F%92">头插</h6> 
<pre><code class="language-cpp">//头插
void List_Header(listcode* phead, LTDataType x) {
	assert(phead);
	//申请一个节点
	listcode* newnode = inaugurate(x);

	//先讲新节点的链接(prev  next)
	newnode-&gt;next = phead-&gt;next;
	newnode-&gt;prev = phead;
	//再讲其他与newnode链接
	phead-&gt;next-&gt;prev = newnode;
	phead-&gt;next = newnode;
}</code></pre> 
<h6 style="background-color:transparent;">解析</h6> 
<blockquote> 
 <p><span style="color:#be191c;"><strong><code>List_Header</code>函数用于在已知的循环双链表<code>phead</code>的头部插入一个新节点，新节点的数据值为<code>x</code>。具体步骤如下：</strong></span></p> 
 <ol><li> <p><span style="color:#be191c;"><strong>首先，通过调用<code>inaugurate(x)</code>函数创建一个新节点，并将其数据域设置为输入的值<code>x</code>，得到新节点的指针<code>newnode</code>。</strong></span></p> </li><li> <p><span style="color:#be191c;"><strong>接下来，设置新节点的指针。由于要将新节点插入到头节点之前成为新的头节点，因此将新节点<code>newnode</code>的<code>next</code>指针指向原头节点<code>phead</code>的下一个节点（即原本的头节点之后的第一个节点），将<code>newnode</code>的<code>prev</code>指针指向原头节点<code>phead</code>。</strong></span></p> </li><li> <p><span style="color:#be191c;"><strong>然后更新原链表节点的指针以适应新节点的插入。首先，原头节点的下一个节点（即<code>phead-&gt;next</code>）的<code>prev</code>指针应改为指向新节点<code>newnode</code>，这样就完成了新节点与原链表中第二个节点之间的连接。</strong></span></p> </li><li> <p><span style="color:#be191c;"><strong>最后，修改原头节点<code>phead</code>的<code>next</code>指针，使其指向新节点<code>newnode</code>，这样新节点就成为了整个循环双链表的新头节点。</strong></span></p> </li></ol> 
</blockquote> 
<p><img alt="" height="237" src="https://images2.imgbox.com/54/bc/K7ybr0cB_o.png" width="719"></p> 
<hr> 
<h6 id="%E5%B0%BE%E6%8F%92">尾插</h6> 
<pre><code class="language-cpp">//尾插
void List_Tail(listcode* phead, LTDataType x) {
	assert(phead);
	//申请节点
	listcode* newnode = inaugurate(x);
	//先讲新节点的链接(prev  next)
	newnode-&gt;prev = phead-&gt;prev;
	newnode-&gt;next = phead;
	//改变最后一个节点
	phead-&gt;prev-&gt;next = newnode;
	//改变头节点
	phead-&gt;prev = newnode;
}</code></pre> 
<h6>解析</h6> 
<blockquote> 
 <p><span style="color:#be191c;"><strong><code>List_Tail</code>函数用于在已知的循环双链表<code>phead</code>的尾部插入一个新节点，新节点的数据值为<code>x</code>。以下是详细的文字解析：</strong></span></p> 
 <ol><li> <p><span style="color:#be191c;"><strong>首先，通过调用<code>inaugurate(x)</code>函数创建一个新节点，并将其数据域设置为输入的值<code>x</code>，得到新节点的指针<code>newnode</code>。</strong></span></p> </li><li> <p><span style="color:#be191c;"><strong>设置新节点的指针以插入到尾部。由于这是一个循环链表，尾节点的<code>next</code>指向头节点，所以将新节点<code>newnode</code>的<code>prev</code>指针指向原头节点<code>phead</code>的前一个节点（即原本的尾节点），将<code>newnode</code>的<code>next</code>指针指向原头节点<code>phead</code>。</strong></span></p> </li><li> <p><span style="color:#be191c;"><strong>更新原链表尾节点的指针，使其<code>next</code>指针指向新节点<code>newnode</code>，这样新节点就被正确地链接到链表的末尾。</strong></span></p> </li><li> <p><span style="color:#be191c;"><strong>最后，调整原头节点<code>phead</code>的<code>prev</code>指针，使其指向新节点<code>newnode</code>，确保链表的循环特性仍然保持，即尾节点的<code>next</code>始终指向头节点。</strong></span></p> </li></ol> 
</blockquote> 
<p><img alt="" height="278" src="https://images2.imgbox.com/e5/bd/VQftks0a_o.png" width="988"></p> 
<hr> 
<h6 id="%E5%A4%B4%E5%88%A0">头删</h6> 
<pre><code class="language-cpp">void List_Header_del(listcode* phead) {
	assert(phead &amp;&amp; phead-&gt;next != phead);//phead-&gt;next != null代表我们的链表就只有哨兵

	//存储一下我们的第一个有效位
	listcode* tmp = phead-&gt;next;
	//改变第二个有效位(prev)
	tmp-&gt;next-&gt;prev = phead;
	//改变哨兵(next)
	phead-&gt;next = tmp-&gt;next;
	free(tmp);
	tmp = NULL;
}</code></pre> 
<h6>解析</h6> 
<blockquote> 
 <p><strong><span style="color:#be191c;"><code>List_Header_del</code>函数用于删除循环双链表<code>phead</code>头部的有效节点（非哨兵节点）。以下是详细的文字解析：</span></strong></p> 
 <ol><li> <p><strong><span style="color:#be191c;">首先，通过<code>assert</code>语句确认<code>phead</code>不为空并且<code>phead-&gt;next</code>不等于<code>phead</code>。这实际上是在验证链表中至少存在一个有效节点，因为<code>phead-&gt;next</code>等于<code>phead</code>仅在链表为空或者只包含一个哨兵节点时成立。</span></strong></p> </li><li> <p><strong><span style="color:#be191c;">定义一个临时指针<code>tmp</code>，用来保存待删除的头节点（第一个有效节点）的地址，即<code>tmp = phead-&gt;next</code>。</span></strong></p> </li><li> <p><strong><span style="color:#be191c;">更新待删除节点后面的节点（即第二个有效节点），使其<code>prev</code>指针指向原头节点<code>phead</code>，这样维持了链表的连贯性。</span></strong></p> </li><li> <p><strong><span style="color:#be191c;">修改原头节点<code>phead</code>的<code>next</code>指针，让它指向待删除节点（原头节点后的一个节点），这样新的头节点就变成了原来头节点的下一个节点。</span></strong></p> </li><li> <p><strong><span style="color:#be191c;">使用<code>free(tmp)</code>释放掉不再需要的原头节点的内存空间，防止内存泄漏。</span></strong></p> </li><li> <p><strong><span style="color:#be191c;">将临时指针<code>tmp</code>置为NULL，虽然在这个函数内部不是必须的，但在某些编程习惯中，为了清晰地表示<code>tmp</code>不再指向有效的内存区域，也会进行这样的操作。</span></strong></p> </li></ol> 
</blockquote> 
<p><img alt="" height="155" src="https://images2.imgbox.com/c2/85/Crv3TdhI_o.png" width="695"></p> 
<hr> 
<h6 id="%E5%B0%BE%E5%88%A0">尾删</h6> 
<pre><code class="language-cpp">//尾删
void List_Tail_del(listcode* phead) {
	assert(phead &amp;&amp; phead-&gt;next != phead);

	listcode* tmp = phead-&gt;prev;
	
	tmp-&gt;prev-&gt;next = phead;
	phead-&gt;prev = tmp-&gt;prev;

	free(tmp);
	tmp = NULL;
}</code></pre> 
<h6>解析</h6> 
<blockquote> 
 <p><span style="color:#be191c;"><strong><code>List_Tail_del</code>函数用于删除循环双链表<code>phead</code>尾部的有效节点（非哨兵节点）。以下是详细的文字解析：</strong></span></p> 
 <ol><li> <p><span style="color:#be191c;"><strong>首先，通过<code>assert</code>语句确认<code>phead</code>不为空并且<code>phead-&gt;next</code>不等于<code>phead</code>，确保链表中至少有一个有效节点存在。</strong></span></p> </li><li> <p><span style="color:#be191c;"><strong>定义一个临时指针<code>tmp</code>，指向当前尾节点，即<code>tmp = phead-&gt;prev</code>。</strong></span></p> </li><li> <p><span style="color:#be191c;"><strong>更新尾节点前一个节点（即倒数第二个节点），使其<code>next</code>指针指向原头节点<code>phead</code>，这样切断了原尾节点与链表的连接，并使新的尾节点成为原尾节点的前一个节点。</strong></span></p> </li><li> <p><span style="color:#be191c;"><strong>调整原头节点<code>phead</code>的<code>prev</code>指针，使其指向原尾节点的前一个节点（现在的新尾节点），保持链表的循环特性。</strong></span></p> </li><li> <p><span style="color:#be191c;"><strong>使用<code>free(tmp)</code>释放原尾节点的内存空间，避免内存泄漏。</strong></span></p> </li><li> <p><span style="color:#be191c;"><strong>将临时指针<code>tmp</code>置为NULL，同样是为了在某些编程风格中清晰地表示<code>tmp</code>不再指向有效的内存区域。</strong></span></p> </li></ol> 
</blockquote> 
<p><img alt="" height="239" src="https://images2.imgbox.com/7c/6a/ywmW4Zun_o.png" width="730"></p> 
<hr> 
<h6 id="pos%E4%B9%8B%E5%90%8E%E6%8F%92%E5%85%A5">pos之后插入</h6> 
<pre><code class="language-cpp">//pos之后插入
void Pos_tail_del(listcode* pos, LTDataType x) {
	assert(pos);
	listcode* newnode = inaugurate(x);

	//改变newnode指向
	newnode-&gt;next = pos-&gt;next;
	newnode-&gt;prev = pos;
	//改变pos指向
	pos-&gt;next-&gt;prev = newnode;//pos的下一个节点的prev
	pos-&gt;next = newnode;

}</code></pre> 
<h6>解析</h6> 
<blockquote> 
 <p><span style="color:#be191c;"><strong><code>Pos_tail_del</code>函数名称似乎有误，应该是<code>Pos_insert</code>，表示在某个特定位置<code>pos</code>之后插入新节点。以下是详细的文字解析：</strong></span></p> 
 <ol><li> <p><span style="color:#be191c;"><strong>首先，通过<code>assert</code>语句确认<code>pos</code>不为空，确保我们有一个合法的位置来插入新节点。</strong></span></p> </li><li> <p><span style="color:#be191c;"><strong>调用<code>inaugurate(x)</code>函数创建一个新节点，并将其数据域设置为输入的值<code>x</code>，得到新节点的指针<code>newnode</code>。</strong></span></p> </li><li> <p><span style="color:#be191c;"><strong>设置新节点的指针以便插入到<code>pos</code>节点之后。将新节点<code>newnode</code>的<code>next</code>指针指向<code>pos</code>节点的下一个节点，将<code>newnode</code>的<code>prev</code>指针指向<code>pos</code>节点。</strong></span></p> </li><li> <p><span style="color:#be191c;"><strong>更新原链表中<code>pos</code>节点的下一个节点，将其<code>prev</code>指针指向新节点<code>newnode</code>，建立新节点与<code>pos</code>节点后继节点间的连接。</strong></span></p> </li><li> <p><span style="color:#be191c;"><strong>最后，修改<code>pos</code>节点的<code>next</code>指针，使其指向新节点<code>newnode</code>，完成新节点在链表中的插入操作。</strong></span></p> </li></ol> 
</blockquote> 
<p><img alt="" height="247" src="https://images2.imgbox.com/33/28/LaxzebMu_o.png" width="694"></p> 
<p><img alt="" height="241" src="https://images2.imgbox.com/1a/79/hADysuF7_o.png" width="1025"></p> 
<hr> 
<h6 id="pos%E5%88%A0%E9%99%A4">pos删除</h6> 
<pre><code class="language-cpp">//pos删除
void Pos_del(listcode* pos) {
	assert(pos);

	pos-&gt;next-&gt;prev = pos-&gt;prev;
	pos-&gt;prev-&gt;next = pos-&gt;next;
	free(pos);
	pos = NULL;
}
</code></pre> 
<h6>解析</h6> 
<blockquote> 
 <p><span style="color:#be191c;"><strong><code>Pos_del</code>函数用于删除循环双链表中指定位置的节点<code>pos</code>。以下是详细的文字解析：</strong></span></p> 
 <ol><li> <p><span style="color:#be191c;"><strong>首先，通过<code>assert</code>语句确认<code>pos</code>不为空，确保我们试图删除的是一个存在的节点。</strong></span></p> </li><li> <p><span style="color:#be191c;"><strong>更新<code>pos</code>节点的后继节点，使其<code>prev</code>指针指向<code>pos</code>节点的前驱节点，这样就断开了<code>pos</code>节点与其后继节点之间的连接。</strong></span></p> </li><li> <p><span style="color:#be191c;"><strong>同样地，更新<code>pos</code>节点的前驱节点，使其<code>next</code>指针指向<code>pos</code>节点的后继节点，这样就完成了<code>pos</code>节点与其前驱节点之间的连接调整。</strong></span></p> </li><li> <p><span style="color:#be191c;"><strong>使用<code>free(pos)</code>释放<code>pos</code>指向的节点内存，防止内存泄漏。</strong></span></p> </li><li> <p><span style="color:#be191c;"><strong>将<code>pos</code>指针设为NULL，虽然在这段代码中并非必要操作，但在某些编程实践中，这样做有助于明确标识<code>pos</code>不再指向有效的内存地址，以免后续误用。</strong></span></p> </li></ol> 
</blockquote> 
<p></p> 
<p><img alt="" height="179" src="https://images2.imgbox.com/b7/c8/cyBastrQ_o.png" width="661"></p> 
<hr> 
<h6 id="%E6%89%93%E5%8D%B0">打印</h6> 
<pre><code class="language-cpp">
//打印
void List_print(listcode* phead) {
	assert(phead);
	listcode* pcur = phead-&gt;next;
	while (pcur != phead)
	{
		printf("%d-&gt;", pcur-&gt;val);
		pcur = pcur-&gt;next;
	}
	printf("\n");
}
</code></pre> 
<h6>解析</h6> 
<blockquote> 
 <p><strong><span style="color:#be191c;"><code>List_print</code>函数用于打印循环双链表中所有节点的数据值，以下是详细的文字解析：</span></strong></p> 
 <ol><li> <p><strong><span style="color:#be191c;">首先，通过<code>assert</code>语句确认<code>phead</code>不为空，确保链表存在。</span></strong></p> </li><li> <p><strong><span style="color:#be191c;">初始化一个指向当前节点的指针<code>pcur</code>，将其设置为头节点的下一个节点（因为头节点可能是哨兵节点，我们需要从第一个有效数据节点开始打印）。</span></strong></p> </li><li> <p><strong><span style="color:#be191c;">使用<code>while</code>循环遍历链表，直到再次回到头节点为止。在循环体内，每次迭代都会打印当前节点<code>pcur</code>的数据值，这里通过<code>printf("%d-&gt;", pcur-&gt;val);</code>实现。</span></strong></p> </li><li> <p><strong><span style="color:#be191c;">在每次循环迭代结束后，将<code>pcur</code>指针移动到下一个节点，即<code>pcur = pcur-&gt;next;</code>。</span></strong></p> </li><li> <p><strong><span style="color:#be191c;">当<code>pcur</code>再次指向头节点时，循环结束，此时所有的节点数据值已经按照顺序打印完毕。</span></strong></p> </li><li> <p><strong><span style="color:#be191c;">循环结束后，打印换行符<code>\n</code>，使得输出结果更易于阅读。</span></strong></p> </li></ol> 
</blockquote> 
<hr> 
<h3 id="%E5%85%A8%E9%83%A8%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA">全部代码展示</h3> 
<h6 id="main.c">main.c</h6> 
<pre><code class="language-cpp">
#define _CRT_SECURE_NO_WARNINGS 1
#include"text.h"

int main() {
	listcode* p = initialize();//初始化了一个哨兵位
	//listcode* p = NULL;//初始化了一个哨兵位
	//initialize(&amp;p);
	/*List_Header(p,1);
	List_print(p);
	List_Header(p,2);
	List_print(p);
	List_Header(p, 3);
	List_print(p);*/
	///*List_Header(p, 4);
	//List_print(p);
	//List_Tail(p, 10);
	//List_print(p);*/
	//List_Header_del(p);
	//List_print(p);
	//List_Header_del(p);
	//List_print(p);

	/*List_Tail(p, 1); 
	List_Tail(p, 2); */
	//List_Tail(p, 3);
	//List_print(p);
	List_Tail(p, 2);
	List_Tail(p, 2);
	List_Tail(p, 2);
	List_print(p);
	/*List_Tail_del(p);
	List_print(p);*/
	listcode* pos = find(p, 2);
	Pos_tail_del(pos, 10);
	List_print(p);
	Pos_del(pos);
	pos = NULL;
		List_print(p);
}</code></pre> 
<h6 id="text.c">text.c</h6> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1
#include"text.h"

//内存开辟
listcode* inaugurate(LTDataType x) {
	listcode* list = (listcode*)malloc(sizeof(listcode));
	if (list == NULL)
	{
		perror("malloc");
		exit(1);
	}
	//初始值
	list-&gt;val = x;
	list-&gt;next = list-&gt;prev = NULL;

	return list;
}



//初始化
listcode* initialize() {
	listcode* phead = inaugurate(0);
	phead-&gt;next = phead;
	phead-&gt;prev = phead;
	return phead;
}

//void initialize(listcode** phead) {
//
//	*phead = inaugurate(0);
//}

//头插
void List_Header(listcode* phead, LTDataType x) {
	assert(phead);
	//申请一个节点
	listcode* newnode = inaugurate(x);

	//先讲新节点的链接(prev  next)
	newnode-&gt;next = phead-&gt;next;
	newnode-&gt;prev = phead;
	//再讲其他与newnode链接
	phead-&gt;next-&gt;prev = newnode;
	phead-&gt;next = newnode;
}

//尾插
void List_Tail(listcode* phead, LTDataType x) {
	assert(phead);
	//申请节点
	listcode* newnode = inaugurate(x);
	//先讲新节点的链接(prev  next)
	newnode-&gt;prev = phead-&gt;prev;
	newnode-&gt;next = phead;
	//改变最后一个节点
	phead-&gt;prev-&gt;next = newnode;
	//改变头节点
	phead-&gt;prev = newnode;
}

//头删
void List_Header_del(listcode* phead) {
	assert(phead &amp;&amp; phead-&gt;next != phead);//phead-&gt;next != null代表我们的链表就只有哨兵

	//存储一下我们的第一个有效位
	listcode* tmp = phead-&gt;next;
	//改变第二个有效位(prev)
	tmp-&gt;next-&gt;prev = phead;
	//改变哨兵(next)
	phead-&gt;next = tmp-&gt;next;
	free(tmp);
	tmp = NULL;
}

//尾删
void List_Tail_del(listcode* phead) {
	assert(phead &amp;&amp; phead-&gt;next != phead);

	listcode* tmp = phead-&gt;prev;
	
	tmp-&gt;prev-&gt;next = phead;
	phead-&gt;prev = tmp-&gt;prev;

	free(tmp);
	tmp = NULL;
}

//查找函数
listcode* find(listcode* phead, LTDataType x) {

	listcode* pcur = phead-&gt;next;
	while (pcur != phead)
	{
		if (pcur-&gt;val == x) {//直接遍历比较
			return pcur;
		}
		pcur = pcur-&gt;next;
	}
	return NULL;
}

//pos之后插入
void Pos_tail_del(listcode* pos, LTDataType x) {
	assert(pos);
	listcode* newnode = inaugurate(x);

	//改变newnode指向
	newnode-&gt;next = pos-&gt;next;
	newnode-&gt;prev = pos;
	//改变pos指向
	pos-&gt;next-&gt;prev = newnode;//pos的下一个节点的prev
	pos-&gt;next = newnode;

}
//pos删除
void Pos_del(listcode* pos) {
	assert(pos);

	pos-&gt;next-&gt;prev = pos-&gt;prev;
	pos-&gt;prev-&gt;next = pos-&gt;next;
	free(pos);
	pos = NULL;
}

//打印
void List_print(listcode* phead) {
	assert(phead);
	listcode* pcur = phead-&gt;next;
	while (pcur != phead)
	{
		printf("%d-&gt;", pcur-&gt;val);
		pcur = pcur-&gt;next;
	}
	printf("\n");
}



void List_Destroyed(listcode* phead) {
	assert(phead);
	listcode* pcur = phead-&gt;next;
	
	while (pcur != phead) {
		listcode* tmp = pcur-&gt;next;
		free(pcur);
		pcur = tmp;
	}
	free(phead);
	phead = NULL;
}</code></pre> 
<h6 id="text.h">text.h</h6> 
<pre><code class="language-cpp">#pragma once
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
//#include&lt;vld.h&gt;

typedef int LTDataType;
//创建链表结构
typedef struct liatcode
{
	LTDataType val;//内容
	struct liatcode* next;//指向下一个元素
	struct liatcode* prev;//指向上一个元素
}listcode;



  
//初始化
listcode* initialize();
//头插
void List_Header(listcode* phead, LTDataType x);
//尾插
void List_Tail(listcode* phead, LTDataType x);
//头删
void List_Header_del(listcode* phead);
//尾删
void List_Tail_del(listcode* phead);
//pos之后插入
void Pos_tail_del(listcode* pos, LTDataType x);
//pos删除
void Pos_del(listcode* pos);
//打印
void List_print(listcode* phead);

//销毁
void List_Destroyed(listcode* phead);

listcode* find(listcode* phead, LTDataType x);</code></pre> 
<p>总结来说，双链表作为一种灵活、高效的线性数据结构，通过引入前驱和后继指针，极大地提升了数据操作的便利性和效率，是程序设计中不可或缺的一部分。在编写代码实现时，理解和掌握双链表的工作原理及其相关操作至关重要。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c2fda4944aa67c600ec049893be4289d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【JavaSE】Java中5种换行方式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0983437d40f06a1101bec6670bb9f1b5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Docker部署node.js并运行项目</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>