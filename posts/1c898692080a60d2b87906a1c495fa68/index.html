<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言：文件操作 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/1c898692080a60d2b87906a1c495fa68/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="C语言：文件操作">
  <meta property="og:description" content="目录
​
为什么使用文件
什么是文件？
程序文件
数据⽂件
文件名
二进制文件和文本文件
文件的打开和关闭
流和标准流、
流
标准流
文件指针
文件的打开和关闭
文件打开方式
文件的顺序读写
fputc函数示范（写字符）
fgetc函数示范（读字符）
（字符）stdin标准输入流和stdout标准输出流
fputs函数的示范（写字符串）
fgets函数示范（读字符串）
(字符串)stdin标准输入流和stdout标准输出流
fprintf(写整数，浮点数，字符，字符串)
fscanf(读整数，浮点数，字符，字符串)
（整数，浮点数，字符，字符串）stdin标准输入流和stdout标准输出流
对比一组函数：
fwrite函数
fread函数
文件的随机读写
fseek
从文件开头向后偏移
从光标位置偏移
文件末尾向前面偏移
ftell函数
rewind函数
⽂件读取结束的判定
拷贝字符串代码
文件缓冲区
为什么使用文件 如果没有⽂件，我们写的程序的数据是存储在电脑的内存中，如果程序退出，内存回收，数据就丢失了，等再次运⾏程序，是看不到上次程序的数据的，如果要将数据进⾏持久化的保存，我们可以使⽤⽂件，因为文件是存放在硬盘上的
什么是文件？ 磁盘上的⽂件和文件夹都是⽂件。
但是在程序设计中，我们⼀般谈的⽂件有两种：程序⽂件、数据⽂件（从⽂件功能的⻆度来分类
的）。
程序文件 程序⽂件包括源程序⽂件（后缀为.c）,
⽬标⽂件（windows环境后缀为.obj）,
可执⾏程序（windows环境后缀为.exe）。
程序文件
目标文件
可执行程序
数据⽂件 ⽂件的内容不⼀定是程序，⽽是程序运⾏时读写的数据，⽐如程序运⾏需要从中读取数据的⽂件，或者输出内容的⽂件。
本篇讨论的是数据⽂件。
在以前各章所处理数据的输⼊输出都是以终端为对象的，即从终端的键盘输⼊数据，运⾏结果显⽰到显⽰器上。
其实有时候我们会把信息输出到磁盘上，当需要的时候再从磁盘上把数据读取到内存中使⽤，这⾥处理的就是磁盘上⽂件。
文件名 ⼀个⽂件要有⼀个唯⼀的⽂件标识，以便⽤⼾识别和引⽤。
⽂件名包含3部分：⽂件路径&#43;⽂件主⼲名&#43;⽂件后缀
例如： c:\code\test.txt
为了⽅便起⻅，⽂件标识常被称为⽂件名。
二进制文件和文本文件 根据数据的组织形式，数据⽂件被称为⽂本⽂件或者⼆进制⽂件。
数据在内存中以⼆进制的形式存储，如果不加转换的输出到外存，就是⼆进制⽂件。
如果要求在外存上以ASCII码的形式存储，则需要在存储前转换。以ASCII字符的形式存储的⽂件就是⽂本⽂件。
⼀个数据在内存中是怎么存储的呢
字符⼀律以ASCII形式存储，数值型数据既可以⽤ASCII形式存储，也可以使⽤⼆进制形式存储。
如有整数10000，如果以ASCII码的形式输出到磁盘，则磁盘中占⽤5个字节（每个字符⼀个字节），⽽⼆进制形式输出，则在磁盘上只占4个字节（VS2019测试）。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-17T22:48:20+08:00">
    <meta property="article:modified_time" content="2024-06-17T22:48:20+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言：文件操作</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 id="%E2%80%8B%E7%BC%96%E8%BE%91" style="text-align:center;"><img alt="" height="520" src="https://images2.imgbox.com/ad/e9/7vXSiWIR_o.gif" width="781"></h4> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:80px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91" rel="nofollow">​</a></p> 
<p id="-toc" style="margin-left:80px;"></p> 
<p id="%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6" rel="nofollow">为什么使用文件</a></p> 
<p id="%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%87%E4%BB%B6%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%87%E4%BB%B6%EF%BC%9F" rel="nofollow">什么是文件？</a></p> 
<p id="%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6-toc" style="margin-left:120px;"><a href="#%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6" rel="nofollow">程序文件</a></p> 
<p id="%E6%95%B0%E6%8D%AE%E2%BD%82%E4%BB%B6-toc" style="margin-left:120px;"><a href="#%E6%95%B0%E6%8D%AE%E2%BD%82%E4%BB%B6" rel="nofollow">数据⽂件</a></p> 
<p id="%E6%96%87%E4%BB%B6%E5%90%8D-toc" style="margin-left:120px;"><a href="#%E6%96%87%E4%BB%B6%E5%90%8D" rel="nofollow">文件名</a></p> 
<p id="%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6" rel="nofollow">二进制文件和文本文件</a></p> 
<p id="%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%BC%80%E5%92%8C%E5%85%B3%E9%97%AD-toc" style="margin-left:80px;"><a href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%BC%80%E5%92%8C%E5%85%B3%E9%97%AD" rel="nofollow">文件的打开和关闭</a></p> 
<p id="%E6%B5%81%E5%92%8C%E6%A0%87%E5%87%86%E6%B5%81%E3%80%81-toc" style="margin-left:120px;"><a href="#%E6%B5%81%E5%92%8C%E6%A0%87%E5%87%86%E6%B5%81%E3%80%81" rel="nofollow">流和标准流、</a></p> 
<p id="%E6%B5%81-toc" style="margin-left:160px;"><a href="#%E6%B5%81" rel="nofollow">流</a></p> 
<p id="%E6%A0%87%E5%87%86%E6%B5%81-toc" style="margin-left:160px;"><a href="#%E6%A0%87%E5%87%86%E6%B5%81" rel="nofollow">标准流</a></p> 
<p id="%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88-toc" style="margin-left:120px;"><a href="#%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88" rel="nofollow">文件指针</a></p> 
<p id="%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%BC%80%E5%92%8C%E5%85%B3%E9%97%AD-toc" style="margin-left:80px;"><a href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%BC%80%E5%92%8C%E5%85%B3%E9%97%AD" rel="nofollow">文件的打开和关闭</a></p> 
<p id="%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F-toc" style="margin-left:120px;"><a href="#%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F" rel="nofollow">文件打开方式</a></p> 
<p id="%E6%96%87%E4%BB%B6%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%86%99-toc" style="margin-left:80px;"><a href="#%E6%96%87%E4%BB%B6%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%86%99" rel="nofollow">文件的顺序读写</a></p> 
<p id="fputc%E5%87%BD%E6%95%B0%E7%A4%BA%E8%8C%83%EF%BC%88%E5%86%99%E5%AD%97%E7%AC%A6%EF%BC%89-toc" style="margin-left:120px;"><a href="#fputc%E5%87%BD%E6%95%B0%E7%A4%BA%E8%8C%83%EF%BC%88%E5%86%99%E5%AD%97%E7%AC%A6%EF%BC%89" rel="nofollow">fputc函数示范（写字符）</a></p> 
<p id="fgetc%E5%87%BD%E6%95%B0%E7%A4%BA%E8%8C%83%EF%BC%88%E8%AF%BB%E5%AD%97%E7%AC%A6%EF%BC%89-toc" style="margin-left:120px;"><a href="#fgetc%E5%87%BD%E6%95%B0%E7%A4%BA%E8%8C%83%EF%BC%88%E8%AF%BB%E5%AD%97%E7%AC%A6%EF%BC%89" rel="nofollow">fgetc函数示范（读字符）</a></p> 
<p id="%EF%BC%88%E5%AD%97%E7%AC%A6%EF%BC%89stdin%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E6%B5%81%E5%92%8Cstdout%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81-toc" style="margin-left:120px;"><a href="#%EF%BC%88%E5%AD%97%E7%AC%A6%EF%BC%89stdin%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E6%B5%81%E5%92%8Cstdout%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81" rel="nofollow">（字符）stdin标准输入流和stdout标准输出流</a></p> 
<p id="fputs%E5%87%BD%E6%95%B0%E7%9A%84%E7%A4%BA%E8%8C%83%EF%BC%88%E5%86%99%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89-toc" style="margin-left:120px;"><a href="#fputs%E5%87%BD%E6%95%B0%E7%9A%84%E7%A4%BA%E8%8C%83%EF%BC%88%E5%86%99%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89" rel="nofollow">fputs函数的示范（写字符串）</a></p> 
<p id="fgets%E5%87%BD%E6%95%B0%E7%A4%BA%E8%8C%83%EF%BC%88%E8%AF%BB%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89-toc" style="margin-left:120px;"><a href="#fgets%E5%87%BD%E6%95%B0%E7%A4%BA%E8%8C%83%EF%BC%88%E8%AF%BB%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89" rel="nofollow">fgets函数示范（读字符串）</a></p> 
<p id="(%E5%AD%97%E7%AC%A6%E4%B8%B2)stdin%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E6%B5%81%E5%92%8Cstdout%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81-toc" style="margin-left:120px;"><a href="#%28%E5%AD%97%E7%AC%A6%E4%B8%B2%29stdin%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E6%B5%81%E5%92%8Cstdout%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81" rel="nofollow">(字符串)stdin标准输入流和stdout标准输出流</a></p> 
<p id="fprintf(%E5%86%99%E6%95%B4%E6%95%B0%EF%BC%8C%E6%B5%AE%E7%82%B9%E6%95%B0%EF%BC%8C%E5%AD%97%E7%AC%A6%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2)-toc" style="margin-left:120px;"><a href="#fprintf%28%E5%86%99%E6%95%B4%E6%95%B0%EF%BC%8C%E6%B5%AE%E7%82%B9%E6%95%B0%EF%BC%8C%E5%AD%97%E7%AC%A6%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%29" rel="nofollow">fprintf(写整数，浮点数，字符，字符串)</a></p> 
<p id="fscanf(%E8%AF%BB%E6%95%B4%E6%95%B0%EF%BC%8C%E6%B5%AE%E7%82%B9%E6%95%B0%EF%BC%8C%E5%AD%97%E7%AC%A6%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2)-toc" style="margin-left:120px;"><a href="#fscanf%28%E8%AF%BB%E6%95%B4%E6%95%B0%EF%BC%8C%E6%B5%AE%E7%82%B9%E6%95%B0%EF%BC%8C%E5%AD%97%E7%AC%A6%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%29" rel="nofollow">fscanf(读整数，浮点数，字符，字符串)</a></p> 
<p id="%EF%BC%88%E6%95%B4%E6%95%B0%EF%BC%8C%E6%B5%AE%E7%82%B9%E6%95%B0%EF%BC%8C%E5%AD%97%E7%AC%A6%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89stdin%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E6%B5%81%E5%92%8Cstdout%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81-toc" style="margin-left:120px;"><a href="#%EF%BC%88%E6%95%B4%E6%95%B0%EF%BC%8C%E6%B5%AE%E7%82%B9%E6%95%B0%EF%BC%8C%E5%AD%97%E7%AC%A6%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89stdin%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E6%B5%81%E5%92%8Cstdout%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81" rel="nofollow">（整数，浮点数，字符，字符串）stdin标准输入流和stdout标准输出流</a></p> 
<p id="%E5%AF%B9%E6%AF%94%E4%B8%80%E7%BB%84%E5%87%BD%E6%95%B0%EF%BC%9A-toc" style="margin-left:120px;"><a href="#%E5%AF%B9%E6%AF%94%E4%B8%80%E7%BB%84%E5%87%BD%E6%95%B0%EF%BC%9A" rel="nofollow">对比一组函数：</a></p> 
<p id="fwrite%E5%87%BD%E6%95%B0-toc" style="margin-left:120px;"><a href="#fwrite%E5%87%BD%E6%95%B0" rel="nofollow">fwrite函数</a></p> 
<p id="fread%E5%87%BD%E6%95%B0-toc" style="margin-left:120px;"><a href="#fread%E5%87%BD%E6%95%B0" rel="nofollow">fread函数</a></p> 
<p id="%E6%96%87%E4%BB%B6%E7%9A%84%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%86%99-toc" style="margin-left:80px;"><a href="#%E6%96%87%E4%BB%B6%E7%9A%84%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%86%99" rel="nofollow">文件的随机读写</a></p> 
<p id="fseek-toc" style="margin-left:120px;"><a href="#fseek" rel="nofollow">fseek</a></p> 
<p id="%E4%BB%8E%E6%96%87%E4%BB%B6%E5%BC%80%E5%A4%B4%E5%90%91%E5%90%8E%E5%81%8F%E7%A7%BB-toc" style="margin-left:160px;"><a href="#%E4%BB%8E%E6%96%87%E4%BB%B6%E5%BC%80%E5%A4%B4%E5%90%91%E5%90%8E%E5%81%8F%E7%A7%BB" rel="nofollow">从文件开头向后偏移</a></p> 
<p id="%E4%BB%8E%E5%85%89%E6%A0%87%E4%BD%8D%E7%BD%AE%E5%81%8F%E7%A7%BB-toc" style="margin-left:160px;"><a href="#%E4%BB%8E%E5%85%89%E6%A0%87%E4%BD%8D%E7%BD%AE%E5%81%8F%E7%A7%BB" rel="nofollow">从光标位置偏移</a></p> 
<p id="%E6%96%87%E4%BB%B6%E6%9C%AB%E5%B0%BE%E5%90%91%E5%89%8D%E9%9D%A2%E5%81%8F%E7%A7%BB-toc" style="margin-left:160px;"><a href="#%E6%96%87%E4%BB%B6%E6%9C%AB%E5%B0%BE%E5%90%91%E5%89%8D%E9%9D%A2%E5%81%8F%E7%A7%BB" rel="nofollow">文件末尾向前面偏移</a></p> 
<p id="ftell%E5%87%BD%E6%95%B0-toc" style="margin-left:120px;"><a href="#ftell%E5%87%BD%E6%95%B0" rel="nofollow">ftell函数</a></p> 
<p id="%C2%A0rewind%E5%87%BD%E6%95%B0-toc" style="margin-left:120px;"><a href="#%C2%A0rewind%E5%87%BD%E6%95%B0" rel="nofollow"> rewind函数</a></p> 
<p id="%E2%BD%82%E4%BB%B6%E8%AF%BB%E5%8F%96%E7%BB%93%E6%9D%9F%E7%9A%84%E5%88%A4%E5%AE%9A-toc" style="margin-left:80px;"><a href="#%E2%BD%82%E4%BB%B6%E8%AF%BB%E5%8F%96%E7%BB%93%E6%9D%9F%E7%9A%84%E5%88%A4%E5%AE%9A" rel="nofollow">⽂件读取结束的判定</a></p> 
<p id="%E6%8B%B7%E8%B4%9D%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#%E6%8B%B7%E8%B4%9D%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BB%A3%E7%A0%81" rel="nofollow">拷贝字符串代码</a></p> 
<p id="%E6%96%87%E4%BB%B6%E7%BC%93%E5%86%B2%E5%8C%BA-toc" style="margin-left:80px;"><a href="#%E6%96%87%E4%BB%B6%E7%BC%93%E5%86%B2%E5%8C%BA" rel="nofollow">文件缓冲区</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<h4 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6">为什么使用文件</h4> 
<p>如果没有⽂件，我们写的程序的数据是存储在电脑的内存中，如果程序退出，内存回收，数据就丢失了，等再次运⾏程序，是看不到上次程序的数据的，如果要将数据进⾏<strong>持久化的保存</strong>，我们可以使⽤⽂件，因为文件是存放在硬盘上的</p> 
<h4 id="%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%87%E4%BB%B6%EF%BC%9F"><strong>什么是文件？</strong></h4> 
<p>磁盘上的⽂件和文件夹都是⽂件。<br> 但是在程序设计中，我们⼀般谈的⽂件有两种：程序⽂件、数据⽂件（从⽂件功能的⻆度来分类<br> 的）。</p> 
<h5 id="%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6">程序文件</h5> 
<blockquote> 
 <p><span style="color:#fe2c24;">程序⽂件包括源程序⽂件（后缀为.c）,</span></p> 
 <p><span style="color:#fe2c24;">⽬标⽂件（windows环境后缀为.obj）,</span></p> 
 <p><span style="color:#fe2c24;">可执⾏程序（windows环境后缀为.exe）。</span></p> 
</blockquote> 
<p><span style="color:#0d0016;">程序文件</span></p> 
<p><img alt="" height="186" src="https://images2.imgbox.com/53/fd/jMqqbqZC_o.png" width="778"></p> 
<p>目标文件</p> 
<p><img alt="" height="223" src="https://images2.imgbox.com/9f/aa/w1JbQG6d_o.png" width="785"></p> 
<p>可执行程序</p> 
<p><img alt="" height="143" src="https://images2.imgbox.com/50/9d/yOq1e5KN_o.png" width="800"></p> 
<hr> 
<h5 id="%E6%95%B0%E6%8D%AE%E2%BD%82%E4%BB%B6">数据⽂件</h5> 
<p>⽂件的内容不⼀定是程序，⽽是程序运⾏时读写的数据，⽐如程序运⾏需要从中读取数据的⽂件，或者输出内容的⽂件。</p> 
<p>本篇讨论的是数据⽂件。</p> 
<p>在以前各章所处理数据的输⼊输出都是以终端为对象的，即从终端的键盘输⼊数据，运⾏结果显⽰到显⽰器上。</p> 
<p>其实有时候我们会把信息输出到磁盘上，当需要的时候再从磁盘上把数据读取到内存中使⽤，这⾥处理的就是磁盘上⽂件。</p> 
<p><img alt="" height="502" src="https://images2.imgbox.com/eb/39/bk6w8fgd_o.png" width="951"></p> 
<p><img alt="" height="508" src="https://images2.imgbox.com/bd/07/rBY4DLOT_o.png" width="981"></p> 
<hr> 
<h5 id="%E6%96%87%E4%BB%B6%E5%90%8D">文件名</h5> 
<p>⼀个⽂件要有⼀个唯⼀的⽂件标识，以便⽤⼾识别和引⽤。<br> ⽂件名包含3部分：⽂件路径+⽂件主⼲名+⽂件后缀<br> 例如： <strong>c:\code\test.txt</strong><br> 为了⽅便起⻅，⽂件标识常被称为⽂件名。</p> 
<p><img alt="" height="262" src="https://images2.imgbox.com/81/db/fe0jJqaK_o.png" width="629"></p> 
<hr> 
<h4 id="%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6">二进制文件和文本文件</h4> 
<p>根据数据的组织形式，数据⽂件被称为<strong>⽂本⽂件</strong>或者<strong>⼆进制⽂件</strong>。<br> 数据在内存中以⼆进制的形式存储，如果不加转换的输出到外存，就是<strong>⼆进制⽂件</strong>。<br> 如果要求在外存上以ASCII码的形式存储，则需要在存储前转换。以ASCII字符的形式存储的⽂件就是<strong>⽂本⽂件</strong>。</p> 
<p>⼀个数据在内存中是怎么存储的呢<br> 字符⼀律以ASCII形式存储，数值型数据既可以⽤ASCII形式存储，也可以使⽤⼆进制形式存储。<br> 如有整数10000，如果以ASCII码的形式输出到磁盘，则磁盘中占⽤5个字节（每个字符⼀个字节），⽽⼆进制形式输出，则在磁盘上只占4个字节（VS2019测试）。</p> 
<p><strong>⼆进制形式输出不一定占用字节小，比如给一个整数1，ASCII码形式输出占⽤1个字节，二进制的占⽤4个字节</strong></p> 
<p><img alt="" height="394" src="https://images2.imgbox.com/40/a8/96TFv1TF_o.png" width="1200"></p> 
<p>文本文件我们是可以看到的</p> 
<p><img alt="" height="287" src="https://images2.imgbox.com/c7/95/2zfzvlR2_o.png" width="657"></p> 
<hr> 
<p>二进制</p> 
<p>下面这个fwite（a的地址，多少字节，写多少次，写到关联的p）</p> 
<pre><code class="language-cpp">int main()
{
	int a = 10000;
	FILE* p = fopen("test.txt", "wb");//打开文件

	fwrite(&amp;a, 4, 1, p);//写入二进制

	fclose(p);//关闭文件
	p = NULL;
	return 0;
}</code></pre> 
<hr> 
<p>输出的东西我们都看不懂，因为存放的是二进制</p> 
<p><img alt="" height="287" src="https://images2.imgbox.com/fd/06/kD6MUFOE_o.png" width="657"></p> 
<hr> 
<p>我们可以用vs的二进制编辑器打开查看</p> 
<p><img alt="" height="128" src="https://images2.imgbox.com/ee/a3/dH83q4GQ_o.png" width="341"></p> 
<p>这个是小端存放的，所以是倒过来的</p> 
<p><img alt="" height="176" src="https://images2.imgbox.com/ac/a9/c1ZvHX7u_o.png" width="747"></p> 
<hr> 
<h4 id="%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%BC%80%E5%92%8C%E5%85%B3%E9%97%AD">文件的打开和关闭</h4> 
<h5 id="%E6%B5%81%E5%92%8C%E6%A0%87%E5%87%86%E6%B5%81%E3%80%81">流和标准流、</h5> 
<h6 id="%E6%B5%81">流</h6> 
<p>我们程序的数据需要输出到各种外部设备，也需要从外部设备获取数据，不同的外部设备的输⼊输出操作各不相同，为了⽅便程序员对各种设备进⾏⽅便的操作，我们抽象出了流的概念，我们可以把流想象成流淌着字符的河。C程序针对⽂件、画⾯、键盘等的数据输⼊输出操作都是通过流操作的。<br> ⼀般情况下，我们要想向流⾥写数据，或者从流中读取数据，都是要打开流，然后操作。</p> 
<p><img alt="" height="492" src="https://images2.imgbox.com/96/56/IQUddEDh_o.png" width="986"></p> 
<hr> 
<h6 id="%E6%A0%87%E5%87%86%E6%B5%81">标准流</h6> 
<p><strong>为什么我们从键盘上输入数据，向屏幕输出数据，并没有打开流呢？</strong></p> 
<p>那是因为C语⾔程序在启动的时候，默认打开了3个流：</p> 
<ul><li>stdin -- 标准输⼊流，在⼤多数的环境中从键盘输⼊，<span style="color:#fe2c24;"><strong>scanf</strong></span>函数就是从标准输⼊流中读取数据。</li><li>stdout -- 标准输出流，⼤多数的环境中输出⾄显⽰器界⾯，<span style="color:#fe2c24;"><strong>printf</strong></span>函数就是将信息输出到标准输出流中。</li><li>stderr -- 标准错误流，⼤多数环境中输出到显⽰器界⾯。</li></ul> 
<p>这是默认打开了这三个流，我们使⽤<strong>scanf</strong>、<strong>printf</strong>等函数就可以直接进⾏输⼊输出操作的。<br><strong>stdin、stdout、stderr</strong>三个流的类型是： FILE* ，通常称为⽂件指针。<br> C语⾔中，就是通过 FILE* 的⽂件指针来维护流的各种操作的。</p> 
<hr> 
<h5 id="%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88" style="background-color:transparent;">文件指针</h5> 
<p>缓冲⽂件系统中，关键的概念是“<strong>⽂件类型指针</strong>”，简称“<strong>⽂件指针</strong>”。</p> 
<p>每个被使⽤的⽂件都在内存中开辟了⼀个相应的⽂件信息区，⽤来存放⽂件的相关信息（如⽂件的名字，⽂件状态及⽂件当前的位置等）。这些信息是保存在⼀个结构体变量中的。该结构体类型是由系统声明的，取名FILE.</p> 
<p>例如，VS2013编译环境提供的 stdio.h 头⽂件中有以下的⽂件类型申明：</p> 
<pre><code class="language-cpp">struct _iobuf 
{
       char *_ptr;
       int _cnt;
       char *_base;
       int _flag;
       int _file;
       int _charbuf;
       int _bufsiz;
       char *_tmpfname;
};

typedef struct _iobuf FILE;</code></pre> 
<p></p> 
<p>不同的C编译器的FILE类型包含的内容不完全相同，但是⼤同⼩异。<br> 每当打开⼀个⽂件的时候，系统会根据⽂件的情况⾃动创建⼀个FILE结构的变量，并填充其中的信<br> 息，使⽤者不必关⼼细节。<br> ⼀般都是通过⼀个FILE的指针来维护这个FILE结构的变量，这样使⽤起来更加⽅便。</p> 
<p><img alt="" height="626" src="https://images2.imgbox.com/cc/24/2tCePKjy_o.png" width="1200"></p> 
<p>下⾯我们可以创建⼀个FILE*的指针变量:</p> 
<pre><code class="language-cpp">FILE* p;//文件指针变量</code></pre> 
<p>定义pf是⼀个指向FILE类型数据的指针变量。可以使pf指向某个⽂件的⽂件信息区（是⼀个结构体变量）。通过该⽂件信息区中的信息就能够访问该⽂件。也就是说，<strong>通过⽂件指针变量能够间接找到与它关联的⽂件</strong>。</p> 
<p>比如：</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/f8/be/Upn7KLek_o.png" width="1200"></p> 
<hr> 
<h4>文件的打开和关闭</h4> 
<p>打开文件就是打开流</p> 
<p>读写文件就是读写流</p> 
<p>关闭文件就是关闭流</p> 
<p><strong>我们只需要关注文件操作进行</strong>，流的操作是底层的操作我们不用关心</p> 
<p><img alt="" height="248" src="https://images2.imgbox.com/8b/e4/owMWoTHA_o.png" width="621"></p> 
<p>⽂件在读写之前应该先<strong>打开⽂件</strong>，在使⽤结束之后应该<strong>关闭⽂件</strong>。</p> 
<p>在编写程序的时候，在打开⽂件的同时，都会返回⼀个FILE*的指针变量指向该⽂件，也相当于建⽴了指针和⽂件的关系。</p> 
<p>ANSIC?规定使⽤ <strong>fopen </strong>函数来打开⽂件， <strong>fclose</strong> 来关闭⽂件。</p> 
<p><img alt="" height="176" src="https://images2.imgbox.com/f5/c8/1lwyAPcP_o.png" width="669"></p> 
<pre><code class="language-cpp">int main()
{
	//打开文件
	//打开文件成功，返回有效指针
	//打开失败，返回NULL
	//当然也可以用路径打开文件
	FILE* p = fopen("data.txt", "w");
	//判断是不是NULL
	if (p == NULL)
	{
		//是就报错
		perror("fopen");
		return 1;
	}
	//关闭文件
	fclose(p);
	//给p赋值NULL
	p = NULL;
	return 0;
}</code></pre> 
<hr> 
<h5 id="%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F">文件打开方式</h5> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:700px;"><tbody><tr><td>⽂件使⽤⽅式</td><td>含义</td><td>如果指定⽂件不存在</td></tr><tr><td>“r”（只读）</td><td>为了输⼊数据，打开⼀个已经存在的⽂本⽂件</td><td>出错</td></tr><tr><td>“w”（只写）</td><td>为了输出数据，打开⼀个⽂本⽂件</td><td>建⽴⼀个新的⽂件</td></tr><tr><td>“a”（追加）</td><td>向⽂本⽂件尾添加数据</td><td>建⽴⼀个新的⽂件</td></tr><tr><td>“rb”（只读）</td><td>为了输⼊数据，打开⼀个⼆进制⽂件</td><td>出错</td></tr><tr><td>“wb”（只写）</td><td>为了输出数据，打开⼀个⼆进制⽂件?</td><td>建⽴⼀个新的⽂件</td></tr><tr><td>“ab”（追加）</td><td>向⼀个⼆进制⽂件尾添加数据?</td><td>建⽴⼀个新的⽂件</td></tr><tr><td>“r+”（读写）</td><td>为了读和写，打开⼀个⽂本⽂件</td><td>出错</td></tr><tr><td>“w+”（读写）</td><td>为了读和写，建议⼀个新的⽂件</td><td>建⽴⼀个新的⽂件</td></tr><tr><td>“a+”（读写）</td><td>打开⼀个⽂件，在⽂件尾进⾏读写</td><td>建⽴⼀个新的⽂件</td></tr><tr><td>“rb+”（读写）</td><td>为了读和写打开⼀个⼆进制⽂件</td><td>出错</td></tr><tr><td>“wb+”（读写）</td><td>为了读和写，新建⼀个新的⼆进制⽂件</td><td>建⽴⼀个新的⽂件</td></tr><tr><td>“ab+”（读写）</td><td>打开⼀个⼆进制⽂件，在⽂件尾进⾏读和写</td><td>建⽴⼀个新的⽂件</td></tr></tbody></table> 
<hr> 
<h4 id="%E6%96%87%E4%BB%B6%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%86%99">文件的顺序读写</h4> 
<p>顺序读写函数介绍：</p> 
<p>前6个函数是读和写的都是文本信息，后面2个是二进制信息</p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>函数名</td><td>功能</td><td>适用于</td></tr><tr><td>fgetc</td><td>字符输⼊函数（<span style="color:#fe2c24;">读字符</span>）</td><td>所有输⼊流</td></tr><tr><td>fputc</td><td>字符输出函数（<span style="color:#fe2c24;">写字符</span>）</td><td>所有输出流</td></tr><tr><td>fgets</td><td>⽂本⾏输⼊函数（<span style="color:#fe2c24;">读字符串</span>）</td><td>所有输⼊流</td></tr><tr><td>fputs</td><td>⽂本⾏输出函数（<span style="color:#fe2c24;">写字符串</span>）</td><td>所有输出流</td></tr><tr><td>fscanf</td><td>格式化输⼊函数（<span style="color:#fe2c24;">可以读所有类型</span>）</td><td>所有输⼊流</td></tr><tr><td>fprintf</td><td>格式化输出函数</td><td>所有输出流</td></tr><tr><td>fread</td><td>二进制输入</td><td>文件</td></tr><tr><td>fwrite</td><td>二进制输出</td><td>文件</td></tr></tbody></table> 
<p>l</p> 
<p></p> 
<hr> 
<h5 id="fputc%E5%87%BD%E6%95%B0%E7%A4%BA%E8%8C%83%EF%BC%88%E5%86%99%E5%AD%97%E7%AC%A6%EF%BC%89">fputc函数示范（<span style="color:#fe2c24;"><strong>写字符</strong></span>）</h5> 
<p><img alt="" height="401" src="https://images2.imgbox.com/89/02/azWa2GYe_o.png" width="419"></p> 
<p>fputc是<span style="color:#fe2c24;">写字符的,</span><span style="color:#0d0016;">这个函数一次只能输出一个字符</span></p> 
<p><img alt="" height="526" src="https://images2.imgbox.com/4e/b0/wjvTYDFR_o.png" width="787"></p> 
<pre><code class="language-cpp">int main()
{
	//打开文件
	FILE* p = fopen("data.txt", "w");
	if (p == NULL)
	{
		perror("fopen");
		return 1;
	}
	//写入文件
	fputc('a', p);
	fputc('b', p);
	fputc('c', p);
	fputc('d', p);
	fputc('e', p);
	fputc('f', p);
	
	//关闭文件
	fclose(p);
	p = NULL;
	return 0;
}</code></pre> 
<p>fputc可以循环写入</p> 
<p><img alt="" height="541" src="https://images2.imgbox.com/84/ce/DaHPttOp_o.png" width="764"></p> 
<pre><code class="language-cpp">int main()
{
	//打开文件
	FILE* p = fopen("data.txt", "w");
	if (p == NULL)
	{
		perror("fopen");
		return 1;
	}
	//写入文件
	for (int i = 'a'; i &lt;= 'z'; i++)
	{
		fputc(i, p);
	}
	
	//关闭文件
	fclose(p);
	p = NULL;
	return 0;
}</code></pre> 
<hr> 
<h5 id="fgetc%E5%87%BD%E6%95%B0%E7%A4%BA%E8%8C%83%EF%BC%88%E8%AF%BB%E5%AD%97%E7%AC%A6%EF%BC%89">fgetc函数示范（<span style="color:#fe2c24;">读字符</span>）</h5> 
<p>读取正常的时候，返回读取到的字符的ASCII码值</p> 
<p>读取失败的时候，返回EOF</p> 
<p>EOF是一个文件的结束标志</p> 
<p><img alt="" height="381" src="https://images2.imgbox.com/dd/cd/z4Jv5pMY_o.png" width="740"></p> 
<p><span style="color:#fe2c24;">下面这个代码我们可以看到从文件里读取了5个字符。</span></p> 
<p><img alt="" height="627" src="https://images2.imgbox.com/87/2c/OFHN8Vvn_o.png" width="931"></p> 
<pre><code class="language-cpp">int main()
{
	//打开文件
	FILE* p = fopen("data.txt", "r");
	if (p == NULL)
	{
		perror("fopen");
		return 1;
	}
	//读文件
	int r = fgetc(p);
	printf("%c\n", r);

	r = fgetc(p);
	printf("%c\n", r);

	r = fgetc(p);
	printf("%c\n", r);

	r = fgetc(p);
	printf("%c\n", r);

	r = fgetc(p);
	printf("%c\n", r);
	//关闭文件
	fclose(p);
	p = NULL;
}</code></pre> 
<hr> 
<p>我们也可以用循环的方式进行读</p> 
<p><img alt="" height="582" src="https://images2.imgbox.com/90/41/vgSZNb1z_o.png" width="1031"></p> 
<pre><code class="language-cpp">int main()
{
	//打开文件
	FILE* p = fopen("data.txt", "r");
	if (p == NULL)
	{
		perror("fopen");
		return 1;
	}
	//读文件
	int r = 0;
	while ((r = fgetc(p)) != EOF)
	{
		printf("%c\n", r);
	}
	//关闭文件
	fclose(p);
	p = NULL;
}</code></pre> 
<hr> 
<h5 id="%EF%BC%88%E5%AD%97%E7%AC%A6%EF%BC%89stdin%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E6%B5%81%E5%92%8Cstdout%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81">（字符）stdin标准输入流和stdout标准输出流</h5> 
<ul><li>stdin -- 标准输⼊流，在⼤多数的环境中从键盘输⼊，<span style="color:#fe2c24;"><strong>scanf</strong></span>函数就是从标准输⼊流中读取数据。</li><li>stdout -- 标准输出流，⼤多数的环境中输出⾄显⽰器界⾯，<span style="color:#fe2c24;"><strong>printf</strong></span>函数就是将信息输出到标准输出流中。</li></ul> 
<p><img alt="" height="187" src="https://images2.imgbox.com/27/ea/SUaXNf0u_o.png" width="630"></p> 
<pre><code class="language-cpp">int main()
{
	int r = fgetc(stdin);//标准输入流（从键盘读）
	fputc(r, stdout);//标准输出流（写到屏幕上）

	return 0;
}</code></pre> 
<hr> 
<h5 id="fputs%E5%87%BD%E6%95%B0%E7%9A%84%E7%A4%BA%E8%8C%83%EF%BC%88%E5%86%99%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89">fputs函数的示范（写字符串）</h5> 
<p><span style="color:#fe2c24;">这个函数可以往文件里写字符串</span></p> 
<p><img alt="" height="493" src="https://images2.imgbox.com/38/db/kdQwxwbh_o.png" width="932"></p> 
<p><img alt="" height="416" src="https://images2.imgbox.com/4f/34/MrpIDeHI_o.png" width="718"></p> 
<pre><code class="language-cpp">int main()
{
	//打开文件
	FILE* p = fopen("data.txt", "w");
	if (p == NULL)
	{
		perror("fopen");
		return 1;
	}
	//写入文件
	fputs("您好小明，今天有空吗", p );

	//关闭文件
	fclose(p);
	p = NULL;
}</code></pre> 
<hr> 
<h5 id="fgets%E5%87%BD%E6%95%B0%E7%A4%BA%E8%8C%83%EF%BC%88%E8%AF%BB%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89">fgets函数示范（读字符串）</h5> 
<p>这个函数是从文件里，读取字符串出来</p> 
<p><img alt="" height="672" src="https://images2.imgbox.com/27/12/gClFp7qy_o.png" width="950"></p> 
<p><span style="color:#fe2c24;"><strong>下面这代码，我们要读取3个字符，我们可以看到实际上只读取了2个字符，编译器会在后面加个\0</strong></span></p> 
<p><img alt="" height="668" src="https://images2.imgbox.com/c2/10/efnIZpAN_o.png" width="1200"></p> 
<p>下面这个代码，没有读取到w，这是为什么呢，因为这个函数是文本行的读取，所以读取到\n会停下来，然后呢编译器在后面加\0</p> 
<p><img alt="" height="646" src="https://images2.imgbox.com/fb/7b/v7xhFCWw_o.png" width="1200"></p> 
<hr> 
<h5 id="(%E5%AD%97%E7%AC%A6%E4%B8%B2)stdin%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E6%B5%81%E5%92%8Cstdout%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81">(字符串)stdin标准输入流和stdout标准输出流</h5> 
<p><img alt="" height="246" src="https://images2.imgbox.com/57/f3/aXrJNT6H_o.png" width="681"></p> 
<pre><code class="language-cpp">int main()
{
	char arr[20] = { 0 };
	//从键盘读数据
	fgets(arr, 10, stdin);
	//写到屏幕上
	fputs(arr, stdout);
}</code></pre> 
<hr> 
<h5 id="fprintf(%E5%86%99%E6%95%B4%E6%95%B0%EF%BC%8C%E6%B5%AE%E7%82%B9%E6%95%B0%EF%BC%8C%E5%AD%97%E7%AC%A6%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2)">fprintf(写整数，浮点数，字符，字符串)</h5> 
<p><strong><span style="color:#fe2c24;">fprintf</span>和printf的写法是一样的只不过<span style="color:#fe2c24;">fprintf</span>是将数值写到文件里，所以第一个参数是流。</strong></p> 
<p>只要是printf能打印的，<span style="color:#fe2c24;">fprintf都能写到文件里</span></p> 
<p><img alt="" height="388" src="https://images2.imgbox.com/a8/c5/E0UZMxjm_o.png" width="999"></p> 
<p><img alt="" height="476" src="https://images2.imgbox.com/f2/30/YLoOpi9s_o.png" width="837"></p> 
<pre><code class="language-cpp">int main()
{
	char a[20] = "小明";
	int b = 18;
	float c = 75.5f;
	//打开文件
	FILE* p = fopen("data.txt", "w");
	if (p == NULL)
	{
		perror("fopen");
		return 1;
	}
	//写入文件
	fprintf(p ,"%s    %d    %f", a, b, c);
	//关闭文件
	fclose(p);
	p = NULL;
}</code></pre> 
<p><span style="color:#fe2c24;">下面这代码我们也可以用结构体的方式</span></p> 
<p><img alt="" height="578" src="https://images2.imgbox.com/50/bc/IkId1LnR_o.png" width="907"></p> 
<hr> 
<h5 id="fscanf(%E8%AF%BB%E6%95%B4%E6%95%B0%EF%BC%8C%E6%B5%AE%E7%82%B9%E6%95%B0%EF%BC%8C%E5%AD%97%E7%AC%A6%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2)">fscanf(读整数，浮点数，字符，字符串)</h5> 
<p><span style="color:#fe2c24;">fscanf</span>和scanf也是差不多一样的，scanf是读取键盘，<span style="color:#fe2c24;">fscanf</span>是读取文件数据</p> 
<p><img alt="" height="517" src="https://images2.imgbox.com/28/ce/kgBnqd74_o.png" width="965"></p> 
<p><span style="color:#fe2c24;"><strong>下面这个代码是读取文件的数据放到结构体变量里，然后进行打印结构体</strong></span></p> 
<p><img alt="" height="713" src="https://images2.imgbox.com/8d/15/6Wpw1hEo_o.png" width="1100"></p> 
<pre><code class="language-cpp">struct a
{
	char a[20];
	int b;
	float c;
};

int main()
{
	struct a arr = { 0 };
	//打开文件
	FILE* p = fopen("data.txt", "r");
	if (p == NULL)
	{
		perror("fopen");
		return 1;
	}
	//读文件
	fscanf(p , "%s %d %f", &amp;arr.a, &amp;arr.b, &amp;arr.c);


	//打印到屏幕上
	printf("%s   %d   %.2f", arr.a, arr.b, arr.c);

	//关闭文件
	fclose(p);
	p = NULL;
}</code></pre> 
<hr> 
<h5 id="%EF%BC%88%E6%95%B4%E6%95%B0%EF%BC%8C%E6%B5%AE%E7%82%B9%E6%95%B0%EF%BC%8C%E5%AD%97%E7%AC%A6%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89stdin%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E6%B5%81%E5%92%8Cstdout%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81">（整数，浮点数，字符，字符串）stdin标准输入流和stdout标准输出流</h5> 
<p><img alt="" height="484" src="https://images2.imgbox.com/db/cf/Yqb2mAXJ_o.png" width="1117"></p> 
<pre><code class="language-cpp">struct a
{
	char a[20];
	int b;
	float c;
};

int main()
{
	struct a arr = { 0 };
	//读取键盘
	fscanf(stdin, "%s %d %f", &amp;arr.a, &amp;arr.b, &amp;arr.c);
	//打印到屏幕上
	fprintf(stdout,"%s   %d   %.2f", arr.a, arr.b, arr.c);
}</code></pre> 
<hr> 
<h5 id="%E5%AF%B9%E6%AF%94%E4%B8%80%E7%BB%84%E5%87%BD%E6%95%B0%EF%BC%9A">对比一组函数：</h5> 
<blockquote> 
 <p>scanf / fscanf / sscanf<br> printf / fprintf / sprintf</p> 
</blockquote> 
<p><span style="color:#fe2c24;">scanf和printf   针对标准输入流/标准输出流的 格式化 输入/输出函数</span></p> 
<p><span style="color:#fe2c24;">fscanf和fprintf  针对所有输入流/所有输出流的 格式化 输入/输出函数</span></p> 
<p><strong><span style="color:#fe2c24;">sprintf：将格式化的数据转换成字符串。</span></strong></p> 
<p><strong><span style="color:#fe2c24;">sscanf:从字符串中提取格式化的数据。</span></strong></p> 
<hr> 
<p><span style="color:#fe2c24;"><strong>sprintf:其实是将格式化的数据写到字符串中（可以理解为将格式化的数据转换成字符串）</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>如果有很多数据需要整合成字符串就可以使用sprintf</strong></span></p> 
<p></p> 
<p><img alt="" height="447" src="https://images2.imgbox.com/03/38/8rSr8DlZ_o.png" width="885"></p> 
<pre><code class="language-cpp">struct a
{
	char a[20];
	int b;
	float c;
};

int main()
{
	char arr[99] = { 0 };
	struct a p = { "小虎",33,65.9};
	//将p里的数据转换成字符串，放到arr数组中
	sprintf(arr,"%s %d %.2f", p.a, p.b, p.c);
	printf("%s", arr);
	return 0;
}</code></pre> 
<hr> 
<p><strong><span style="color:#fe2c24;">sscanf：是从字符串中提取格式化的数据，可以理解为将字符串转换成格式化的数据</span></strong></p> 
<p><img alt="" height="543" src="https://images2.imgbox.com/b1/40/ecGqGnE6_o.png" width="888"></p> 
<pre><code class="language-cpp">struct a
{
	char a[20];
	int b;
	float c;
};

int main()
{
	char arr[99] = { 0 };
	struct a p = { "小虎",33,65.9 };
	//将p里的数据转换成字符串，放到arr数组中
	sprintf(arr, "%s %d %.2f", p.a, p.b, p.c);

	struct a kk = { 0 };

	//从字符串里读取格式化的数据，转换后，放到kk中
	sscanf(arr,"%s %d %f", kk.a, &amp;kk.b, &amp;kk.c);

	//打印
	printf("%s %d %.2f", kk.a, kk.b, kk.c);
	return 0;
}</code></pre> 
<hr> 
<h5 id="fwrite%E5%87%BD%E6%95%B0">fwrite函数</h5> 
<p>这个函数是以二进制形式写到文件里，</p> 
<p><span style="color:#fe2c24;">fwrite</span><span style="color:#fe2c24;">第一个参数是数据，第二个参数是类型的大小，第三个参数是要写多少，第四个参数是流（把数据写到文件里）。</span></p> 
<p><img alt="" height="724" src="https://images2.imgbox.com/a0/08/OzksVyGq_o.png" width="1034"></p> 
<p><span style="color:#fe2c24;">下面这代码我们可以看到以二进制文件写到文件里，二进制我们当然是看不懂的。</span></p> 
<p><img alt="" height="617" src="https://images2.imgbox.com/56/e5/oxrnLnsD_o.png" width="856"></p> 
<pre><code class="language-cpp">struct a
{
	char a[20];
	int b;
	float c;
};

int main()
{
	
	struct a ps = { "asdfyg",25,88.8f };
	//打开文件
	FILE* p = fopen("data.txt", "wb");
	if (p == NULL)
	{
		perror("fopen");
		return 1;
	}
	//写入二进制到文件
	fwrite(&amp;ps, sizeof(struct a), 1, p);

	//关闭文件
	fclose(p);
	p = NULL;
	return 0;
}
</code></pre> 
<hr> 
<h5 id="fread%E5%87%BD%E6%95%B0">fread函数</h5> 
<p>这个函数是读取二进制信息</p> 
<p><span style="color:#fe2c24;">fwrite</span><span style="color:#fe2c24;">第一个参数是读到的数据放的位置，第二个参数是类型的大小，第三个参数是要读多少，第四个参数是流（从流读取数据）。</span></p> 
<p><img alt="" height="721" src="https://images2.imgbox.com/19/84/G1LZHYtc_o.png" width="1106"></p> 
<p><span style="color:#fe2c24;">下面这代码我们可以看到，从二进制读取信息，打印在屏幕上</span></p> 
<p><img alt="" height="699" src="https://images2.imgbox.com/0a/3e/1n4EyeT8_o.png" width="1001"></p> 
<pre><code class="language-cpp">struct a
{
	char a[20];
	int b;
	float c;
};

int main()
{
	struct a ps = { 0 };
	//打开文件 
	FILE* p = fopen("data.txt", "rb");
	if (p == NULL)
	{
		perror("fopen");
		return 1;
	}
	//读取二进制文件
	fread(&amp;ps,sizeof(struct a), 1 , p );
	//打印
	printf("%s %d %f", ps.a, ps.b, ps.c);
	//关闭文件
	fclose(p);
	p = NULL;
}</code></pre> 
<hr> 
<h4 id="%E6%96%87%E4%BB%B6%E7%9A%84%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%86%99">文件的随机读写</h4> 
<p>顺序读写是一行一行的读写，随机读写是想读写那个就读写那个</p> 
<h5 id="fseek">fseek</h5> 
<p>fseek根据⽂件指针的位置和偏移量来定位⽂件指针（文件内容的光标）。</p> 
<p>第一个参数是流，第二个参数是偏移量，</p> 
<p>第三个参数定位文件指针：</p> 
<blockquote> 
 <p>SEEK_SET（是文件开头的位置）</p> 
 <p>SEEK_CUR（文件指针的当前位置（光标））</p> 
 <p>SEEK_END（文件末尾）</p> 
</blockquote> 
<p>作用是：</p> 
<blockquote> 
 <p><span style="color:#fe2c24;">用SEEK_SET从文件开头的位置偏移到后面</span></p> 
 <p><span style="color:#fe2c24;">用SEEK_CUR从光标的位置向后面偏移</span></p> 
 <p><span style="color:#fe2c24;">用SEEK_END文件末尾向前面偏移</span></p> 
 <p>向前面偏移用正数，向后偏移用负数</p> 
</blockquote> 
<p><img alt="" height="833" src="https://images2.imgbox.com/f1/e2/6LQLAsk4_o.png" width="1058"></p> 
<hr> 
<h6 id="%E4%BB%8E%E6%96%87%E4%BB%B6%E5%BC%80%E5%A4%B4%E5%90%91%E5%90%8E%E5%81%8F%E7%A7%BB">从文件开头向后偏移</h6> 
<p><span style="color:#fe2c24;">读取a和b后，定位文件指针，SEEK_SET从文件开头向后偏移了6，读取了后面的3个hhh</span></p> 
<p><img alt="" height="622" src="https://images2.imgbox.com/b1/0f/wPeHRCwe_o.png" width="1039"></p> 
<hr> 
<h6 id="%E4%BB%8E%E5%85%89%E6%A0%87%E4%BD%8D%E7%BD%AE%E5%81%8F%E7%A7%BB">从光标位置偏移</h6> 
<p><span style="color:#4da8ee;">当我们读取了a和b光标会在b的后面</span><span style="color:#fe2c24;">，定位文件指针，SEEK_CUR从光标的位置向后面偏移4个，读取了后面的3个hhh。</span></p> 
<p><img alt="" height="683" src="https://images2.imgbox.com/21/c7/3bv8A9cs_o.png" width="805"></p> 
<hr> 
<h6 id="%E6%96%87%E4%BB%B6%E6%9C%AB%E5%B0%BE%E5%90%91%E5%89%8D%E9%9D%A2%E5%81%8F%E7%A7%BB"><span style="color:#0d0016;">文件末尾向前面偏移</span></h6> 
<p><span style="color:#fe2c24;">SEEK_END从文件末尾向前面偏移了-6，读取了后面的3个d e f</span></p> 
<p><img alt="" height="627" src="https://images2.imgbox.com/0b/78/Jzk3iJCO_o.png" width="703"></p> 
<hr> 
<h5 id="ftell%E5%87%BD%E6%95%B0">ftell函数</h5> 
<p>ftell返回⽂件指针相对于起始位置的偏移量。</p> 
<p>ftell计算从起始位置到光标的偏移量。</p> 
<p><img alt="" height="645" src="https://images2.imgbox.com/25/f7/dDOEuV64_o.png" width="897"></p> 
<pre><code class="language-cpp">int main()
{
	//打开文件 
	FILE* p = fopen("data.txt", "r");
	if (p == NULL)
	{
		perror("fopen");
		return 1;
	}
	//读文件
	int r = 0;

	//定位文件指针
	fseek(p, -6, SEEK_END);

	r = fgetc(p);//d
	printf("%c\n", r);

	r = fgetc(p);//e
	printf("%c\n", r);

	r = fgetc(p);//f
	printf("%c\n", r);

	printf("%d\n", ftell(p));


	//关闭文件
	fclose(p);
	p = NULL;
}
</code></pre> 
<hr> 
<h5 id="%C2%A0rewind%E5%87%BD%E6%95%B0"> rewind函数</h5> 
<p>让⽂件指针的位置回到⽂件的起始位置</p> 
<p>就是让光标来到起始位置</p> 
<p><img alt="" height="608" src="https://images2.imgbox.com/94/1f/jZHYP6n9_o.png" width="844"></p> 
<pre><code class="language-cpp">int main()
{
	//打开文件 
	FILE* p = fopen("data.txt", "r");
	if (p == NULL)
	{
		perror("fopen");
		return 1;
	}
	//读文件
	int r = 0;

	r = fgetc(p);//a
	printf("%c\n", r);

	r = fgetc(p);//b
	printf("%c\n", r);

	r = fgetc(p);//c
	printf("%c\n", r);
	//将文件指针重新定位到文件的起始位置
	rewind(p);

	r = fgetc(p);//a
	printf("%c\n", r);

	r = fgetc(p);//b
	printf("%c\n", r);

	r = fgetc(p);//c
	printf("%c\n", r);


	//关闭文件
	fclose(p);
	p = NULL;
}
</code></pre> 
<hr> 
<h4 id="%E2%BD%82%E4%BB%B6%E8%AF%BB%E5%8F%96%E7%BB%93%E6%9D%9F%E7%9A%84%E5%88%A4%E5%AE%9A"><strong>⽂件读取结束的判定</strong></h4> 
<p><strong>被错误使⽤的 feof </strong></p> 
<blockquote> 
 <p><strong>牢记：在⽂件读取过程中，不能⽤feof函数的返回值直接来判断⽂件的是否结束。<br> feof 的作⽤是：当⽂件读取结束的时候，判断是读取结束的原因是否是：遇到⽂件尾结束。</strong></p> 
</blockquote> 
<p><strong>⽂本⽂件读取是否结束，判断返回值是否为 EOF （ fgetc ），或者 NULL （ fgets ）<br> 例如：</strong></p> 
<blockquote> 
 <p><strong>fgetc 判断是否为 EOF .<br> fgets 判断返回值是否为 NULL .</strong></p> 
</blockquote> 
<p><strong>⼆进制⽂件的读取结束判断，判断返回值是否⼩于实际要读的个数。<br> 例如：</strong></p> 
<blockquote> 
 <p><strong> fread判断返回值是否⼩于实际要读的个数。</strong></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>EOF也可以拿来文件的结束标志</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>feof函数不是用来判断文件是否结束的！！！</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>1</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>在读取文件的过程中，有可能读取文件结束</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>结束的原因：</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>1.遇到文件末尾</strong></span></p> 
 <p><span style="color:#fe2c24;"><strong>2.遇到错误了</strong></span></p> 
</blockquote> 
<hr> 
<p><strong>⽂本⽂件的例⼦：</strong></p> 
<p><strong>feof是在已经结束了，判断结束的原因是什么。</strong></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main(void)
{
	int c; // 注意：int，⾮char，要求处理EOF
	FILE* fp = fopen("test.txt", "r");
	if (!fp) {
		perror("File opening failed");
		return EXIT_FAILURE;
	}
	//fgetc 当读取失败的时候或者遇到⽂件结束的时候，都会返回EOF
	while ((c = fgetc(fp)) != EOF) // 标准C I/O读取⽂件循环
	{
		putchar(c);
	}
	//判断是什么原因结束的
	if (ferror(fp))
        //遇到错误了
		puts("I/O error when reading");
	else if (feof(fp))
        //遇到文件末尾
		puts("End of file reached successfully");
	fclose(fp);
}</code></pre> 
<hr> 
<p>⼆进制⽂件的例⼦：</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
enum { SIZE = 5 };
int main(void)
{
	double a[SIZE] = { 1.,2.,3.,4.,5. };
	FILE* fp = fopen("test.bin", "wb");
	fwrite(a, sizeof * a, SIZE, fp); // 写 double 的数组
	fclose(fp);
	double b[SIZE];
	fp = fopen("test.bin", "rb");
	size_t ret_code = fread(b, sizeof * b, SIZE, fp); // 读 double 的数组
	if (ret_code == SIZE) {
		puts("Array read successfully, contents: ");
		for (int n = 0; n &lt; SIZE; ++n)
			printf("%f ", b[n]);
		putchar('\n');
	}
	else { // error handling
		if (feof(fp))
			printf("Error reading test.bin: unexpected end of file\n");
		else if (ferror(fp)) {
			perror("Error reading test.bin");
		}
	}
	fclose(fp);
}</code></pre> 
<hr> 
<p>下面这代码我们可以看到只读取了一个字符，没有<span style="color:#0d0016;">遇到文件末尾，feof返回0</span></p> 
<p><img alt="" height="559" src="https://images2.imgbox.com/38/a9/AFKhuxMd_o.png" width="792"></p> 
<hr> 
<p>当我们读取完到<span style="color:#0d0016;">遇到文件末尾返回1</span></p> 
<p><img alt="" height="634" src="https://images2.imgbox.com/b3/7c/ufnOQBwD_o.png" width="871"></p> 
<hr> 
<h4 id="%E6%8B%B7%E8%B4%9D%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BB%A3%E7%A0%81">拷贝字符串代码</h4> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main()
{
	//打开文件
	FILE* p1 = fopen("data1.txt", "r");
	if (p1 == NULL)
	{
		perror("fopen");
		return 1;
	}
	FILE* p2 = fopen("data2.txt", "w");
	if (p2 == NULL)
	{
		perror("fopen");
		fclose(p1);
		p1 = NULL;
		return 1;
	}
	//复制
	int r = 0;
	while ((r = fgetc(p1)) != EOF)
	{
		fputc(r, p2);
	}

	fclose(p1);
	p1 == NULL;
	fclose(p2);
	p2 = NULL;
	return 0;
}</code></pre> 
<hr> 
<h4 id="%E6%96%87%E4%BB%B6%E7%BC%93%E5%86%B2%E5%8C%BA">文件缓冲区</h4> 
<blockquote> 
 <p>ANSIC 标准采⽤“缓冲⽂件系统”处理的数据⽂件的，所谓缓冲⽂件系统是指系统⾃动地在内存中为程序中每⼀个正在使⽤的⽂件开辟⼀块“⽂件缓冲区”。从内存向磁盘输出数据会先送到内存中的缓冲区，装满缓冲区后才⼀起送到磁盘上。如果从磁盘向计算机读⼊数据，则从磁盘⽂件中读取数据输⼊到内存缓冲区（充满缓冲区），然后再从缓冲区逐个地将数据送到程序数据区（程序变量等）。缓冲区的⼤⼩根据C编译系统决定的。</p> 
</blockquote> 
<p><img alt="" height="487" src="https://images2.imgbox.com/12/0c/nvs77kpd_o.png" width="927"></p> 
<p><span style="color:#fe2c24;"><strong>系统会在内存中开辟一块文件缓冲区，当我们把数据写到文件里（也就是硬盘），会先把数据放到输出缓冲区，放满了输出缓冲区，才⼀起送到硬盘上。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>输入缓冲区元素一样，读的数据，放满了输入缓冲区，然后再从缓冲区逐个地将数据送到程序数据区（程序变量等）。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>下面这有个代码</strong></span></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;
//VS2019 WIN11环境测试
int main()
{
FILE*pf = fopen("test.txt", "w");
fputs("abcdef", pf); //先将代码放在输出缓冲区
printf("睡眠10秒-已经写数据了，打开test.txt⽂件，发现⽂件没有内容\n");
Sleep(10000);
printf("刷新缓冲区\n");
fflush(pf); //刷新缓冲区时，才将输出缓冲区的数据写到⽂件（磁盘）
//注：fflush 在⾼版本的VS上不能使⽤了
printf("再睡眠10秒-此时，再次打开test.txt⽂件，⽂件有内容了\n");
Sleep(10000);
fclose(pf);
//注：fclose在关闭⽂件的时候，也会刷新缓冲区
pf = NULL;
return 0;
}</code></pre> 
<hr> 
<p>下面这代码我们可以看到，把字符串放到了输出缓冲区，但是还没有刷新缓冲区（也就是还没有放到硬盘）</p> 
<p><img alt="" height="613" src="https://images2.imgbox.com/d4/e3/BEuBBkrS_o.png" width="1200"></p> 
<hr> 
<p>下面代码，已经刷新缓冲区了（也就是放到硬盘了），我们可以看到，字符串已经放到文件（硬盘）里了</p> 
<p><img alt="" height="622" src="https://images2.imgbox.com/8c/b8/JY0Vb1Sm_o.png" width="1200"></p> 
<blockquote> 
 <p>这⾥可以得出⼀个结论：<br><span style="color:#fe2c24;">因为有缓冲区的存在，C语⾔在操作⽂件的时候，需要做刷新缓冲区或者在⽂件操作结束的时候关闭⽂件。如果不做，可能导致读写⽂件的问题。</span></p> 
</blockquote> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/953d874d9f10bcbff18325d99f70dcf3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Novartis诺华制药社招综合能力性格动机问卷入职测评笔试题库答案及包过助攻</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/481d5ac91b3406440488fd41e60a4b48/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">大学生毕设神器 | 二手房房源分析 二手房房源爬虫 基于Python的二手房可视化分析 基于大数据的二手房可视化分析 基于sklearn的二手房房价预测 基于随机森林的二手房房价预测</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>