<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>类和对象（下）C&#43;&#43; - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ca870a930da2404dc61b621c53eb30b9/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="类和对象（下）C&#43;&#43;">
  <meta property="og:description" content="1.初始化列表 1.为什么有初始化列表，它的作用？
-&gt;初始化列表，是构造函数初始化的另一种形式。
-&gt;在语法上面理解，初始化列表可以认定为是每个成员变量定义初始化的地方.
-&gt;引用成员变量，const成员变量，没有默认构造的类类型变量，他们三者必须要在自身定义时初始化。所以要将他们放在初始化列表的位置进行初始化，否则会编译报错。
2.使用形式
-&gt;以冒号作为开始标志，每个初始化以逗号作为分隔符号，每个“成员”变量后有个括号，用来放初始值或表达式。
3.C&#43;&#43;11支持成员变量声明的位置给缺省值，主要是用于，该成员变量没有在初始化列表初始化使用的。
4.尽量使用初始化列表，因为尽管你不走初始化列表，也会走初始化列表。因为假设该成员在声明时给了缺省值，那么初始化列表会调用他的缺省值进行初始化，如果没有给缺省值，对于类置类型的成员是否初始化取决于编译器，而自定义类型，会去调用它的默认构造，如果没有相应的默认构造，又没有初始化列表。就会编译报错。
5.初始化列表的顺序，其实是按照成员变量声明的顺序来进行的。跟成员变量在初始列表出现的先后顺序无关。
例如以下例子：
2.类型转换 1.C&#43;&#43;支持内置类型隐式类型转换为类类型对象，需要有相关类型作为构造函数的参数。
2.构造函数前面加explicit就不再支持隐式类型转换。
3.static成员 1.static修饰的成员变量，称为静态成员变量。！！！静态成员变量一定要在类外面进行初始化。
2.类静态成员变量属于所有的类对象，不属于某个具体的对象，不存在对象中，存在静态区。
3..类静态成员也是类的成员，受类域限制，也受访问限定符的限制（public protected，private）
4.static修饰成员函数，成为静态成员函数，静态成员函数没有this指针。
5.静态成员函数可以访问静态成员，不能访问非静态的，因为没有this指针。
6.非静态的成员函数可以任意的访问静态成员函数和静态成员。
7.突破类域可以访问静态成员 ，可以通过类名::静态成员或对象.静态成员来访问静态成员和静态成员函数
8.静态成员不能在声明时给缺省值，因为缺省值是给构造函数初始化列表使用的，而静态成员不属于某一对象，所以不走初始化列表，所以也就不能给缺省值。
例题：
设已经有A,B,C,D 4个类的定义，程序中A,B,C,D构造函数调⽤顺序为？（） 设已经有A,B,C,D 4个类的定义，程序中A,B,C,D析构函数调⽤顺序为？（） 答案选择：E，B
4.友元 5.内部类 1.什么是内部类？
-&gt;一个类的定义是在另一个类的内部，！！！内部类是一个独立的类，与定义在全局的相比，他只受到类域和访问限定符的限制，所以外部类定义的对象不包括内部类。
2.内部类默认是外部类的友元类。
3.内部类本质也是⼀种封装，当A类跟B类紧密关联，A类实现出来主要就是给B类使⽤，那么可以考虑把A类设计为B的内部类，如果放到private/protected位置，那么A类就是B类的专属内部类，其 他地⽅都⽤不了。 6.匿名对象 1.用类型定义出来的是对象叫做匿名对象，而类型名&#43;对象名定义出来的是有名对象。
2.匿名对象的生命周期只在当前那一行，一般临时定义一个对象当前用一下就可以定义临时对象。
7.对象拷贝时的编译器优化 1.现代编译器会为了尽可能提⾼程序的效率，在不影响正确性的情况下会尽可能减少⼀些传参和传参过程中可以省略的拷⻉。 2.如何优化C&#43;&#43;标准并没有严格规定，各个编译器会根据情况⾃⾏处理。当前主流的相对新⼀点的编译器对于连续⼀个表达式步骤中的连续拷⻉会进⾏合并优化，有些更新更&#34;激进&#34;的编译还会进⾏跨⾏跨表达式的合并优化。
今日份鸡汤：“如果没有天赋，那就一直重复！”
今天的学习就到此结束啦！谢谢大家支持！">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-06T17:59:22+08:00">
    <meta property="article:modified_time" content="2024-08-06T17:59:22+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">类和对象（下）C&#43;&#43;</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1.初始化列表</h2> 
<p><span style="color:#be191c;"><strong>1.为什么有初始化列表，它的作用？</strong></span></p> 
<p>-&gt;初始化列表，是构造函数初始化的另一种形式。</p> 
<p>-&gt;在语法上面理解，初始化列表可以认定为是每个成员变量定义初始化的地方.</p> 
<p>-&gt;引用成员变量，const成员变量，没有默认构造的类类型变量，他们三者必须要在自身定义时初始化。所以要将他们放在初始化列表的位置进行初始化，否则会编译报错。</p> 
<p><span style="color:#be191c;"><strong>2.使用形式</strong></span></p> 
<p>-&gt;以冒号作为开始标志，每个初始化以逗号作为分隔符号，每个“成员”变量后有个括号，用来放初始值或表达式。</p> 
<p class="img-center"><img alt="" height="1000" src="https://images2.imgbox.com/68/07/ZpO1KxkK_o.png" width="791"></p> 
<p>3.C++11支持成员变量声明的位置给缺省值，主要是用于，该成员变量没有在初始化列表初始化使用的。</p> 
<p>4.尽量使用初始化列表，因为尽管你不走初始化列表，也会走初始化列表。因为假设该成员在声明时给了缺省值，那么初始化列表会调用他的缺省值进行初始化，如果没有给缺省值，对于类置类型的成员是否初始化取决于编译器，而自定义类型，会去调用它的默认构造，如果没有相应的默认构造，又没有初始化列表。就会编译报错。</p> 
<p>5.初始化列表的顺序，其实是按照成员变量声明的顺序来进行的。跟成员变量在初始列表出现的先后顺序无关。</p> 
<p><span style="color:#1c7331;"><strong> 例如以下例子：</strong></span><img alt="" height="732" src="https://images2.imgbox.com/d6/4d/sPMCGBYv_o.png" width="1059"></p> 
<h2>2.类型转换</h2> 
<p>1.C++支持内置类型<strong><span style="color:#1c7331;">隐式类型转换为</span></strong>类类型对象，需要有相关类型作为构造函数的参数。</p> 
<p>2.构造函数前面加explicit就不再支持隐式类型转换。</p> 
<h2>3.static成员</h2> 
<p>1.static修饰的成员变量，称为静态成员变量。<strong><span style="color:#1c7331;">！！！静态成员变量一定要在类外面进行初始化。</span></strong></p> 
<p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/a8/ac/SSnk6cgq_o.png" width="297"></p> 
<p> 2.类静态成员变量属于所有的类对象，不属于某个具体的对象，不存在对象中，存在静态区。</p> 
<p>3..类静态成员也是类的成员，受类域限制，也受访问限定符的限制（public  protected，private）</p> 
<p>4.static修饰成员函数，成为静态成员函数，静态成员函数没有this指针。</p> 
<p>5.<strong>静态成员函数可以访问静态成员，不能访问非静态的</strong>，因为没有this指针。</p> 
<p>6<strong>.非静态的成员函数</strong>可以任意的访问<span style="color:#1c7331;"><strong>静态成员函数</strong></span>和<span style="color:#1c7331;"><strong>静态成员。</strong></span></p> 
<p>7.突破类域可以访问静态成员 ，可以通过<strong>类名::静态成员</strong>或<strong>对象.静态成员</strong>来访问静态成员和静态成员函数</p> 
<p>8.<span style="color:#1c7892;"><strong>静态成员不能在声明时给缺省值</strong></span>，因为缺省值是给构造函数初始化列表使用的，而静态成员不属于某一对象，所以不走初始化列表，所以也就不能给缺省值。</p> 
<p><strong>例题：</strong></p> 
<div> 
 <span style="color:#1f2329;">设已经有A,B,C,D 4个类的定义，程序中A,B,C,D构造函数调⽤顺序为？（） </span> 
</div> 
<div> 
 <span style="color:#1f2329;">设已经有A,B,C,D 4个类的定义，程序中A,B,C,D析构函数调⽤顺序为？（）</span> 
</div> 
<div></div> 
<div> 
 <p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/cc/52/7VJex3Fc_o.png" width="426"></p> 
</div> 
<p>答案选择：E，B</p> 
<h2><strong>4.</strong>友元 </h2> 
<p><img alt="" height="638" src="https://images2.imgbox.com/3c/4e/ODM9eATi_o.png" width="1177"></p> 
<p class="img-center"><img alt="" height="600" src="https://images2.imgbox.com/41/bf/ZMQQW8kI_o.png" width="401"></p> 
<h2>5.内部类</h2> 
<p> 1.什么是内部类？</p> 
<p>-&gt;一个类的定义是在另一个类的内部，！！！<span style="color:#1c7331;"><strong>内部类是一个独立的类</strong></span>，与定义在全局的相比，他只受到类域和访问限定符的限制，所以外部类定义的对象不包括内部类。</p> 
<p>2.<span style="color:#1c7331;"><strong>内部类默认是外部类的友元类。</strong></span></p> 
<p>3.<span style="color:#494949;">内部类本质也是⼀种封装，当A类跟B类紧密关联，A类实现出来主要就是给B类使⽤，那么可以考虑把A类设计为B的内部类，如果放到private/protected位置，那么A类就是B类的专属内部类，其 他地⽅都⽤不了。 </span></p> 
<h2>6.匿名对象</h2> 
<p>1.用类型定义出来的是对象叫做匿名对象，而类型名+对象名定义出来的是有名对象。</p> 
<p>2.匿名对象的生命周期只在当前那一行，一般临时定义一个对象当前用一下就可以定义临时对象。</p> 
<h2>7.对象拷贝时的编译器优化</h2> 
<p>1.<span style="color:#494949;">现代编译器会为了尽可能提⾼程序的效率，在不影响正确性的情况下会尽可能减少⼀些传参和传参过程中可以省略的拷⻉。 </span></p> 
<p><span style="color:#494949;">2.如何优化C++标准并没有严格规定，各个编译器会根据情况⾃⾏处理。当前主流的相对新⼀点的编译器对于连续⼀个表达式步骤中的连续拷⻉会进⾏合并优化，有些更新更"激进"的编译还会进⾏跨<strong>⾏</strong>跨表达式的合并优化。</span></p> 
<p><strong><span style="color:#1c7892;">今日份鸡汤：“如果没有天赋，那就一直重复！”</span></strong></p> 
<p><strong><span style="color:#1c7331;">今天的学习就到此结束啦！谢谢大家支持！</span></strong></p> 
<p style="text-align:center;"></p> 
<p style="text-align:center;"><span style="color:#494949;"><strong> </strong></span></p> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/49/c9/a7yiQYne_o.png" width="369"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6d1eb3e71a8ed19f40400dbf0db730ac/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">c语言11天笔记</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d587f796da79751585b80885f5da4e03/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【用Java学习数据结构系列】探索Java集合框架的无尽秘密pro</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>