<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】排序之插入排序和选择排序 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/581012db508e4e482730a6cca28467d2/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【数据结构】排序之插入排序和选择排序">
  <meta property="og:description" content="🔥博客主页：小王又困了
📚系列专栏：数据结构
🌟人之为学，不日近则日退
❤️感谢大家点赞👍收藏⭐评论✍️
目录
一、排序的概念及其分类
📒1.1排序的概念
📒1.2排序的分类
二、插入排序
📒2.1直接插入排序
🎀2.1.1直接插入排序的思想
🎀2.1.2排序步骤 🎀2.1.3代码实现 🎀2.1.4直接插入排序的特点
📒2.2希尔排序
🎀2.2.1希尔排序法的基本思想
🎀2.2.2排序步骤 🎀2.2.3代码实现 🎀2.2.4希尔排序的特点
三、选择排序
📒3.1直接选择排序
🎀3.1.1直接选择排序的思想
🎀3.1.2排序步骤 🎀3.1.3代码实现
🎀3.1.4直接选择排序的特点
📒3.2堆排序
🎀3.2.1堆排序的思想
🎀3.2.2排序步骤
🎀3.2.3代码实现
🎀3.2.4堆排序的特点
🗒️前言：
排序是我们数据结构学习中很重要的章节，我们在生活中买东西都会挑选更好的，点外卖会选评分高的等等，这些都需要用到排序。接下来我们将会学习常见的排序算法。
一、排序的概念及其分类 📒1.1排序的概念 排序：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。
稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次 序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排 序算法是稳定的；否则称为不稳定的。
内部排序：数据元素全部放在内存中的排序。
外部排序：数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。
📒1.2排序的分类 二、插入排序 📒2.1直接插入排序 🎀2.1.1直接插入排序的思想 把待排序的数据按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的数据插入完为止，得到一个新的有序序列 。 实际中我们玩扑克牌时，就用了插入排序的思想。
注意：数组中除了第一个元素（默认有序），其余所有元素都看作待插入数据。 🎀2.1.2排序步骤 将有序数据的最后一个元素的下标记为 end，则第一个待插入元素的下标为 end&#43;1，记作 tmp将 tmp 与有序数据从后向前依次比较如果 tmp &lt; a[end]，就将 a[end] 向后移动，end--，再去找下一位进行比较直到 tmp &gt; a[end] 或者 end &lt; 0，将 tmp 插入到 end&#43;1 的位置重复步骤，就可以实现排序 🎀2.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-10-02T10:50:58+08:00">
    <meta property="article:modified_time" content="2023-10-02T10:50:58+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】排序之插入排序和选择排序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/05/aa/c4tbgmOM_o.png"></p> 
<p style="text-align:center;">🔥<strong><span style="color:#38d8f0;">博客主页：</span><a class="link-info" href="https://blog.csdn.net/2301_76207836?spm=1010.2135.3001.5343" title="小王又困了"><span style="color:#956fe7;">小王又困了</span></a></strong></p> 
<p style="text-align:center;">📚<strong><span style="color:#ff9900;">系列专栏：</span><a class="link-info" href="https://blog.csdn.net/2301_76207836/category_12387278.html?spm=1001.2014.3001.5482" title="数据结构"><span style="color:#a2e043;">数据结构</span></a></strong></p> 
<p style="text-align:center;">🌟<span style="color:#fe2c24;"><strong>人之为学，不日近则日退</strong></span></p> 
<p style="text-align:center;"><strong>❤️</strong><span style="color:#9c8ec1;"><strong>感谢大家点赞👍收藏⭐评论</strong><strong>✍️</strong></span></p> 
<p></p> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E5%88%86%E7%B1%BB-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E5%88%86%E7%B1%BB" rel="nofollow">一、排序的概念及其分类</a></p> 
<p id="%F0%9F%93%921.1%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%F0%9F%93%921.1%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">📒1.1排序的概念</a></p> 
<p id="%F0%9F%93%921.2%E6%8E%92%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB-toc" style="margin-left:40px;"><a href="#%F0%9F%93%921.2%E6%8E%92%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB" rel="nofollow">📒1.2排序的分类</a></p> 
<p id="%E4%BA%8C%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" rel="nofollow">二、插入排序</a></p> 
<p id="%F0%9F%93%922.1%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#%F0%9F%93%922.1%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" rel="nofollow">📒2.1直接插入排序</a></p> 
<p id="%F0%9F%8E%802.1.1%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%9D%E6%83%B3-toc" style="margin-left:80px;"><a href="#%F0%9F%8E%802.1.1%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%9D%E6%83%B3" rel="nofollow">🎀2.1.1直接插入排序的思想</a></p> 
<p id="%F0%9F%8E%802.1.2%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A4%C2%A0-toc" style="margin-left:80px;"><a href="#%F0%9F%8E%802.1.2%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A4%C2%A0" rel="nofollow">🎀2.1.2排序步骤 </a></p> 
<p id="%F0%9F%8E%802.1.3%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%C2%A0-toc" style="margin-left:80px;"><a href="#%F0%9F%8E%802.1.3%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%C2%A0" rel="nofollow">🎀2.1.3代码实现 </a></p> 
<p id="%F0%9F%8E%802.1.4%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E7%89%B9%E7%82%B9-toc" style="margin-left:80px;"><a href="#%F0%9F%8E%802.1.4%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E7%89%B9%E7%82%B9" rel="nofollow">🎀2.1.4直接插入排序的特点</a></p> 
<p id="%F0%9F%93%922.2%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#%F0%9F%93%922.2%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" rel="nofollow">📒2.2希尔排序</a></p> 
<p id="%F0%9F%8E%802.2.1%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-toc" style="margin-left:80px;"><a href="#%F0%9F%8E%802.2.1%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3" rel="nofollow">🎀2.2.1希尔排序法的基本思想</a></p> 
<p id="%F0%9F%8E%802.2.2%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A4%C2%A0-toc" style="margin-left:80px;"><a href="#%F0%9F%8E%802.2.2%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A4%C2%A0" rel="nofollow">🎀2.2.2排序步骤 </a></p> 
<p id="%F0%9F%8E%802.2.3%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%C2%A0-toc" style="margin-left:80px;"><a href="#%F0%9F%8E%802.2.3%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%C2%A0" rel="nofollow">🎀2.2.3代码实现 </a></p> 
<p id="%F0%9F%8E%802.2.4%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E7%89%B9%E7%82%B9-toc" style="margin-left:80px;"><a href="#%F0%9F%8E%802.2.4%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E7%89%B9%E7%82%B9" rel="nofollow">🎀2.2.4希尔排序的特点</a></p> 
<p id="%E4%B8%89%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" rel="nofollow">三、选择排序</a></p> 
<p id="%F0%9F%93%923.1%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#%F0%9F%93%923.1%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" rel="nofollow">📒3.1直接选择排序</a></p> 
<p id="%F0%9F%8E%803.1.1%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%9D%E6%83%B3-toc" style="margin-left:80px;"><a href="#%F0%9F%8E%803.1.1%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%9D%E6%83%B3" rel="nofollow">🎀3.1.1直接选择排序的思想</a></p> 
<p id="%F0%9F%8E%803.1.2%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A4%C2%A0-toc" style="margin-left:80px;"><a href="#%F0%9F%8E%803.1.2%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A4%C2%A0" rel="nofollow">🎀3.1.2排序步骤 </a></p> 
<p id="%F0%9F%8E%803.1.3%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#%F0%9F%8E%803.1.3%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">🎀3.1.3代码实现</a></p> 
<p id="%F0%9F%8E%803.1.4%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E7%89%B9%E7%82%B9-toc" style="margin-left:80px;"><a href="#%F0%9F%8E%803.1.4%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E7%89%B9%E7%82%B9" rel="nofollow">🎀3.1.4直接选择排序的特点</a></p> 
<p id="%F0%9F%93%923.2%E5%A0%86%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#%F0%9F%93%923.2%E5%A0%86%E6%8E%92%E5%BA%8F" rel="nofollow">📒3.2堆排序</a></p> 
<p id="%F0%9F%8E%803.2.1%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%9D%E6%83%B3-toc" style="margin-left:80px;"><a href="#%F0%9F%8E%803.2.1%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%9D%E6%83%B3" rel="nofollow">🎀3.2.1堆排序的思想</a></p> 
<p id="%F0%9F%8E%803.2.2%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A4-toc" style="margin-left:80px;"><a href="#%F0%9F%8E%803.2.2%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A4" rel="nofollow">🎀3.2.2排序步骤</a></p> 
<p id="%F0%9F%8E%803.2.3%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#%F0%9F%8E%803.2.3%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">🎀3.2.3代码实现</a></p> 
<p id="%F0%9F%8E%803.2.4%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E7%89%B9%E7%82%B9-toc" style="margin-left:80px;"><a href="#%F0%9F%8E%803.2.4%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E7%89%B9%E7%82%B9" rel="nofollow">🎀3.2.4堆排序的特点</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p>🗒️前言：</p> 
<blockquote> 
 <p><span style="color:#38d8f0;"><strong>排序是我们数据结构学习中很重要的章节，我们在生活中买东西都会挑选更好的，点外卖会选评分高的等等，这些都需要用到排序。接下来我们将会学习常见的排序算法。</strong></span></p> 
</blockquote> 
<h2 id="%E4%B8%80%E3%80%81%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E5%88%86%E7%B1%BB"><span style="color:#e6b223;">一、排序的概念及其分类</span></h2> 
<h3 id="%F0%9F%93%921.1%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A6%82%E5%BF%B5">📒1.1排序的概念</h3> 
<blockquote> 
 <p><strong>排序：</strong>所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。</p> 
 <p><strong>稳定性：</strong>假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次 序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排 序算法是稳定的；否则称为不稳定的。</p> 
 <p><strong>内部排序</strong>：数据元素全部放在内存中的排序。</p> 
 <p><strong>外部排序：</strong>数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。</p> 
</blockquote> 
<h3 id="%F0%9F%93%921.2%E6%8E%92%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB">📒1.2排序的分类</h3> 
<p><img alt="" height="654" src="https://images2.imgbox.com/5b/71/QFmtc6NI_o.jpg" width="1054"></p> 
<h2 id="%E4%BA%8C%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span style="color:#e6b223;">二、插入排序</span></h2> 
<h3 id="%F0%9F%93%922.1%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">📒2.1直接插入排序</h3> 
<h4 id="%F0%9F%8E%802.1.1%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%9D%E6%83%B3">🎀2.1.1直接插入排序的思想</h4> 
<blockquote> 
 <p>把待排序的数据<strong>按其关键码值的大小逐个插入到一个已经排好序的有序序列中</strong>，直到所有的数据插入完为止，得到一个新的有序序列 。 实际中我们玩扑克牌时，就用了插入排序的思想。</p> 
 <p><img alt="" src="https://images2.imgbox.com/78/0f/iwnR7fBS_o.gif"></p> 
 <p><span style="color:#fe2c24;"><strong>注意：数组中除了第一个元素（默认有序），其余所有元素都看作待插入数据。 </strong></span></p> 
</blockquote> 
<h4 id="%F0%9F%8E%802.1.2%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A4%C2%A0">🎀2.1.2排序步骤 </h4> 
<ol><li>将有序数据的最后一个元素的下标记为 <span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">end</span></span>，则第一个待插入元素的下标为 <span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">end+1</span></span>，记作 tmp</li><li>将 tmp 与有序数据从后向前依次比较</li><li>如果 <span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">tmp &lt; a[end]</span></span>，就将 a[end] 向后移动，end--，再去找下一位进行比较</li><li>直到<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;"> tmp &gt; a[end] </span></span>或者 <span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">end &lt; 0</span></span>，将 tmp 插入到 end+1 的位置</li><li>重复步骤，就可以实现排序</li></ol> 
<h4 id="%F0%9F%8E%802.1.3%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%C2%A0">🎀2.1.3代码实现 </h4> 
<pre><code class="language-cpp">void InsertSort(int* a, int n)
{
    for (int i = 0; i &lt; n - 1; i++)
    {
        int end = i;
        int tmp = a[end + 1];
        while (end &gt;= 0)
        {
            if (tmp &lt; a[end])
            {
                a[end + 1] = a[end];
            }
            else
            {
                break;
            }
            --end;
        }
        a[end + 1] = tmp;
    }
}</code></pre> 
<p><img alt="" height="986" src="https://images2.imgbox.com/3f/ea/TOHHn96y_o.jpg" width="1200"></p> 
<h4 id="%F0%9F%8E%802.1.4%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E7%89%B9%E7%82%B9">🎀2.1.4直接插入排序的特点</h4> 
<blockquote> 
 <ol><li>元素集合越接近有序，直接插入排序算法的时间效率越高</li><li>时间复杂度：O(N^2)</li><li>空间复杂度：O(1)，它是一种稳定的排序算法</li><li>稳定性：稳定</li></ol> 
</blockquote> 
<h3 id="%F0%9F%93%922.2%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">📒2.2希尔排序</h3> 
<h4 id="%F0%9F%8E%802.2.1%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">🎀2.2.1希尔排序法的基本思想</h4> 
<blockquote> 
 <p>先选定一个整数，把待排序文件中所有记录分成个组，所有距离为3的数据分在同一组内，并对每一组内的数据进行排序。然后，重复上述分组和排序的工作。当距离=1时，所有数据在统一组内排好序。</p> 
 <p>希尔排序分为两步：</p> 
 <ol><li><span style="color:#0d0016;"><span style="background-color:#cbe0f1;">预排序</span></span></li><li><span style="color:#0d0016;"><span style="background-color:#cbe0f1;">直接插入排序</span></span></li></ol> 
 <p><span style="color:#a2e043;">当元素集合越接近有序，直接插入排序的效率很高，希尔排序就是通过预排序使元素集合接近有序，再进行直接插入排序，这样大大提高了效率。</span></p> 
 <p><img alt="" src="https://images2.imgbox.com/3e/f3/oCcLOc5N_o.gif"></p> 
</blockquote> 
<h4 id="%F0%9F%8E%802.2.2%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A4%C2%A0">🎀2.2.2排序步骤 </h4> 
<ol><li>选取一个合适的 <span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">gap </span></span>作为间距</li><li>将间距为 gap 的数据分为一组，分成 gap 组</li><li>每一组数据都进行直接插入排序，使数据接近有序</li><li>不断缩小间距，当 <span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">gap==1</span></span> 时，数据进行直接插入排序，实现排序</li></ol> 
<h4 id="%F0%9F%8E%802.2.3%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%C2%A0">🎀2.2.3代码实现 </h4> 
<pre><code class="language-cpp">void ShellSort(int* a, int n)
{
    int gap = n;
    while (gap &gt; 1)
    {
        gap = gap / 3 + 1;
        for (int i = 0; i &lt; n - gap; i++)
        {
            int end = i;
            int tmp = a[end + gap];
            while (end &gt;= 0)
            {
                if (tmp &lt; a[end])
                {
                    a[end + gap] = a[end];
                    end -= gap;
                }
                else
                {
                    break;
                }
            }
            a[end + gap] = tmp;
        }
    }
}</code></pre> 
<p><span style="background-color:#dad5e9;">将 i+=gap 改为 i++， 将分组排序，变为多组并排，减少了循环。</span></p> 
<p><span style="background-color:#dad5e9;"> gap = gap / 3 + 1 的目的是保证 gap 最后的值为1.</span></p> 
<h4 id="%F0%9F%8E%802.2.4%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E7%89%B9%E7%82%B9">🎀2.2.4希尔排序的特点</h4> 
<blockquote> 
 <ol><li>希尔排序是对直接插入排序的优化。</li><li><span style="background-color:#edf6e8;">当gap &gt; 1时都是预排序，目的是让数组更接近于有序。当gap == 1时，数组已经接近有序的了，这样就会很快。这样整体而言，可以达到优化的效果。</span></li><li>希尔排序的时间复杂度不好计算，因为gap的取值方法很多，导致很难去计算。</li><li>空间复杂度：O(1)</li><li>稳定性：不稳定</li></ol> 
</blockquote> 
<h2 id="%E4%B8%89%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span style="color:#e6b223;">三、选择排序</span></h2> 
<h3 id="%F0%9F%93%923.1%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">📒3.1直接选择排序</h3> 
<h4 id="%F0%9F%8E%803.1.1%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%9D%E6%83%B3">🎀3.1.1直接选择排序的思想</h4> 
<blockquote> 
 <p>每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完 。</p> 
 <p><img alt="" src="https://images2.imgbox.com/34/d0/RVVOG8Uq_o.gif"></p> 
</blockquote> 
<h4 id="%F0%9F%8E%803.1.2%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A4%C2%A0">🎀3.1.2排序步骤 </h4> 
<ol><li>先遍历一遍数组，找到最大的数和最小的数，记住它们的下标</li><li>将最小的数交换到数组的左边，最大的数交换到数组的右边</li><li><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">begin++</span></span>，<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">end--</span></span>，重复上述步骤，即可实现排序</li></ol> 
<h4 id="%F0%9F%8E%803.1.3%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">🎀3.1.3代码实现</h4> 
<pre><code class="language-cpp">void SelectSort(int* a, int n)
{
    int begin = 0, end = n - 1;
    while (begin &lt; end)
    {
        int min = begin, max = begin;
        for (int i = begin + 1; i &lt;= end; i++)
        {
            if (a[min] &gt; a[i])
            {
                min = i;
            }
            if (a[max] &lt; a[i])
            {
                max = i;
            }
        }
        Swap(&amp;a[min], &amp;a[begin]);
        if (max == begin)
        {
            max = min;
        }
        Swap(&amp;a[max], &amp;a[end]);
        begin++;
        end--;
    }
}</code></pre> 
<p><span style="background-color:#fff5e6;">我们要注意，当 a[max] 在数组元素的第一个，进行 Swap(&amp;a[min], &amp;a[begin]) 后，最大的元素的位置就发生了改变，要及时修改 max。</span></p> 
<h4 id="%F0%9F%8E%803.1.4%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E7%89%B9%E7%82%B9">🎀3.1.4直接选择排序的特点</h4> 
<blockquote> 
 <ol><li> 直接选择排序思考非常好理解，但是效率不是很好。实际中很少使用</li><li>时间复杂度：O(N^2)</li><li>空间复杂度：O(1)</li><li>稳定性：不稳定</li></ol> 
</blockquote> 
<h3 id="%F0%9F%93%923.2%E5%A0%86%E6%8E%92%E5%BA%8F">📒3.2堆排序</h3> 
<h4 id="%F0%9F%8E%803.2.1%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%9D%E6%83%B3">🎀3.2.1堆排序的思想</h4> 
<blockquote> 
 <p>堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。它是通过堆来进行选择数据。需要注意的是排升序要建大堆，排降序建小堆。</p> 
</blockquote> 
<h4 id="%F0%9F%8E%803.2.2%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A4">🎀3.2.2排序步骤</h4> 
<ol><li>将待排序的数据构造成一个大堆，当前堆的根节点（堆顶）就是该组数组中最大的元素；</li><li>将堆顶元素和最后一个元素交换，将剩下的节点重新构造成一个大堆；</li><li>重复步骤2，每次循环构建都能找到当前堆中的最大值，并通过交换的方式把它放到该大堆的尾部，直至所有元素全部有序</li></ol> 
<h4 id="%F0%9F%8E%803.2.3%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">🎀3.2.3代码实现</h4> 
<pre><code class="language-cpp">void HeapSort(int* a, int n)
{
	//第一步：建大堆
    for (int i = (n - 1 - 1) / 2; i &gt;= 0; i--)
    {
        AdjustDown(a, n, i);
    }

    //第二步：堆删除思想进行排序（依次选数，调堆）
    for (int i = n - 1; i &gt; 0; i--)
    {
        Swap(&amp;a[0], &amp;a[i]);
        AdjustDown(a, i , 0);
    }
}

​
void AdjustDown(HPDataType* a, int n, int parent)
{
    //默认左孩子是较小的
    int child = parent * 2 + 1;
    while (child &lt; n)
    {
        // 找出小的那个孩子
        if (child + 1 &lt; n &amp;&amp; a[child + 1] &lt; a[child])
        {
            ++child;
        }

        if (a[child] &lt; a[parent])
        {
            Swap(&amp;a[child], &amp;a[parent]);
            // 继续往下调整
            parent = child;
            child = parent * 2 + 1;
        }
        else
        {
            break;
        }
    }
}
</code></pre> 
<h4 id="%F0%9F%8E%803.2.4%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E7%89%B9%E7%82%B9">🎀3.2.4堆排序的特点</h4> 
<blockquote> 
 <ol><li>堆排序使用堆来选数，效率就高了很多。</li><li>时间复杂度：O(N*logN)</li><li>空间复杂度：O(1)</li><li>稳定性：不稳定</li></ol> 
</blockquote> 
<blockquote> 
 <p><span style="color:#ed7976;"> <strong>本次的内容到这里就结束啦。希望大家阅读完可以有所收获，同时也感谢各位读者三连支持。文章有问题可以在评论区留言，博主一定认真认真修改，以后写出更好的文章。你们的支持就是博主最大的动力。</strong></span></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5f850b81a1a2890d545dd74142a7ab45/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">javascript简易计算器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ec5b2e06ac7443d12023ed6da31da179/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">flutter开发实战-webview插件flutter_inappwebview使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>