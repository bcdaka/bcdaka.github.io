<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>贪心算法（greedy algorithm，又称贪婪算法）详解（附例题） - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/34b2cdae9beb9a5b6cbb85e1d30259e9/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="贪心算法（greedy algorithm，又称贪婪算法）详解（附例题）">
  <meta property="og:description" content="目录 基本思想一）概念二）找出全局最优解的要求三）求解时应考虑的问题四）基本步骤五）贪心策略选择六）实际应用 1.零钱找回问题2.背包问题3.哈夫曼编码4.单源路径中的Djikstra算法5.最小生成树Prim算法 基本思想 贪心算法（Greedy Algorithm）是一种在求解问题时，每一步都选择当前最优解，以期望最终得到全局最优解的算法思想。贪心算法的基本思想可以总结为“每一步都做出一个局部最优的选择，最终就能得到全局最优解”。 贪心算法通常包含以下关键步骤：
找到可选的子问题： 首先，将原问题拆分成一系列可选的子问题或决策。
找到局部最优解： 对每个子问题，找到一个局部最优解。这个局部最优解应该是一个贪心选择，即在当前状态下选择最优的方式。
合并子问题的解： 将各个子问题的局部最优解合并起来，得到原问题的解。
检查解的有效性： 最后，检查得到的解是否满足问题的约束和要求。如果满足，就认为得到了问题的解。
贪心算法适用于一些特定类型的问题，通常要求问题具有贪心选择性质（即每一步的选择都是最优的），以及最优子结构性质（即问题的最优解可以通过子问题的最优解推导得出）。然而，贪心算法不一定能够求解所有问题，有些问题可能需要更复杂的算法来解决。
经典的贪心算法问题有找零钱问题、活动选择问题、背包问题中的部分背包等。贪心算法在求解这些问题时，通常能够得到接近最优解的结果，但并不保证一定能够得到全局最优解。
总之，贪心算法是一种基于每一步的局部最优选择来求解问题的思想，适用于一些满足贪心选择性质和最优子结构性质的问题。
一）概念 贪心算法（Greedy Alogorithm）又叫登山算法，它的根本思想是逐步到达山顶，即逐步获得最优解，是解决最优化问题时的一种简单但是适用范围有限的策略。
贪心算法没有固定的框架，算法设计的关键是贪婪策略的选择。贪心策略要无后向性，也就是说某状态以后的过程不会影响以前的状态，只与当前状态有关。
贪心算法是对某些求解最优解问题的最简单、最迅速的技术。某些问题的最优解可以通过一系列的最优的选择即贪心选择来达到。但局部最优并不总能获得整体最优解，但通常能获得近似最优解。
在每一步贪心选择中，只考虑当前对自己最有利的选择，而不去考虑在后面看来这种选择是否合理。
二）找出全局最优解的要求 在遇见问题时如何确定是否可以使用贪心算法解决问题，那么决定一个贪心算法是否能找到全局最优解的条件是什么呢？其实就是以下两点：
最优子结构（optimal subproblem structure,和动态规划中的是一个概念）最优贪心选择属性（optimal greedy choice property） 三）求解时应考虑的问题 1.候选集合S
为了构造问题的解决方案，有一个候选集合C作为问题的可能解，问题的最终解均取自于候选集合C。
2.解集合S
随着贪心选择的进行，解集合不断扩展，直到构成一个满足问题的完整解。
3.解决函数solution
检查解集合是否构成问题的完整解。
4.选择函数select
即贪心策略，这是贪心算法的关键，它指出哪个候选对象有希望构成成问题的解。
5.可行函数feasible
检查解集合中加入一个候选对象是否可行，即解集合扩展后是否满足约束条件。
四）基本步骤 贪心算法使用基本步骤：
1.从问题的某个初始解出发
2.采用循环语句，当可以向求解目标前进一步时，就根据局部最优策略，得到一个部分解，缩小问题的范围或规模。
3.将所有的部分解综合起来，得到问题的最终解。
五）贪心策略选择 贪心算法的原理是通过局部最优来达到全局最优，采用的是逐步构造最优解的方法。在每个阶段，都做出一个看上去最优的，决策一旦做出，就不再更改。
要选出最优解可不是一件容易的事，要证明局部最优为全局最优，要进行数学证明，否则就不能说明为全局最优。
很多问题表面上看来用贪心算法可以找到最优解，实际上却把最优解给漏掉了。这就像现实生活中的“贪小便宜吃大亏”。所以我们在解决问题的时候，一定要谨慎使用贪心算法，一定要注意这个问题适不适合采用贪心算法。
贪心算法很多时候并不能达到全局最优，为什么我们还要使用它呢？
因为在很多大规模问题中，寻找最优解是一件相当费时耗力的事情，有时候付出大量人力物力财力后，回报并不与投入成正比。在这个时候选择相对最优的贪心算法就比较经济可行了。有的问题对最优的要求不是很高，在充分衡量付出和回报后，选择贪心算法未尝不是一种不错的选择呢。
六）实际应用 1.零钱找回问题 这个问题在我们的日常生活中就更加普遍了。假设1元、2元、5元、10元、20元、50元、100元的纸币分别有c0, c1, c2, c3, c4, c5, c6张。现在要用这些钱来支付K元，至少要用多少张纸币？用贪心算法的思想，很显然，每一步尽可能用面值大的纸币即可。在日常生活中我们自然而然也是这么做的。在程序中已经事先将Value按照从小到大的顺序排好。
下面展示一些 内联代码片。 #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; const int N=7; int Count[N]={3,0,2,1,0,3,5}; int Value[N]={1,2,5,10,20,50,100}; int solve(int money) { int num=0; for(int i=N-1;i&gt;=0;i--) { int c=min(money/Value[i],Count[i]); money=money-c*Value[i]; num&#43;=c; } if(money&gt;0) num=-1; return num; } int main() { int money; cin&gt;&gt;money; int res=solve(money); if(res!">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-08T10:36:27+08:00">
    <meta property="article:modified_time" content="2024-03-08T10:36:27+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">贪心算法（greedy algorithm，又称贪婪算法）详解（附例题）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <div class="toc"> 
 <h5>目录</h5> 
 <ul><li> 
   <ul><li><a href="#_1" rel="nofollow noopener noreferrer" target="_self">基本思想</a></li><li><a href="#_9" rel="nofollow noopener noreferrer" target="_self">一）概念</a></li><li><a href="#_9" rel="nofollow noopener noreferrer" target="_self">二）找出全局最优解的要求</a></li><li><a href="#_15" rel="nofollow noopener noreferrer" target="_self">三）求解时应考虑的问题</a></li><li><a href="#_26" rel="nofollow noopener noreferrer" target="_self">四）基本步骤</a></li><li><a href="#_31" rel="nofollow noopener noreferrer" target="_self">五）贪心策略选择</a></li><li><a href="#_41" rel="nofollow noopener noreferrer" target="_self">六）实际应用</a></li><li> 
     <ul><li><a href="#1_42" rel="nofollow noopener noreferrer" target="_self">1.零钱找回问题</a></li><li><a href="#2_75" rel="nofollow noopener noreferrer" target="_self">2.背包问题</a></li><li><a href="#3_112" rel="nofollow noopener noreferrer" target="_self">3.哈夫曼编码</a></li><li><a href="#4Djikstra_128" rel="nofollow noopener noreferrer" target="_self">4.单源路径中的Djikstra算法</a></li><li><a href="#5Prim_164" rel="nofollow noopener noreferrer" target="_self">5.最小生成树Prim算法</a></li></ul> </li></ul> </li></ul> 
</div> 
<p></p> 
<h4><a id="_1"></a>基本思想</h4> 贪心算法（Greedy Algorithm）是一种在求解问题时，每一步都选择当前最优解，以期望最终得到全局最优解的算法思想。贪心算法的基本思想可以总结为“每一步都做出一个局部最优的选择，最终就能得到全局最优解”。 
<p>贪心算法通常包含以下关键步骤：</p> 
<p>找到可选的子问题： 首先，将原问题拆分成一系列可选的子问题或决策。</p> 
<p>找到局部最优解： 对每个子问题，找到一个局部最优解。这个局部最优解应该是一个贪心选择，即在当前状态下选择最优的方式。</p> 
<p>合并子问题的解： 将各个子问题的局部最优解合并起来，得到原问题的解。</p> 
<p>检查解的有效性： 最后，检查得到的解是否满足问题的约束和要求。如果满足，就认为得到了问题的解。</p> 
<p>贪心算法适用于一些特定类型的问题，通常要求问题具有贪心选择性质（即每一步的选择都是最优的），以及<a href="https://so.csdn.net/so/search?q=%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84&amp;spm=1001.2101.3001.7020" target="_blank" class="hl hl-1" rel="noopener noreferrer">最优子结构</a>性质（即问题的最优解可以通过子问题的最优解推导得出）。然而，贪心算法不一定能够求解所有问题，有些问题可能需要更复杂的算法来解决。</p> 
<p>经典的贪心算法问题有找零钱问题、活动选择问题、背包问题中的部分背包等。贪心算法在求解这些问题时，通常能够得到接近最优解的结果，但并不保证一定能够得到全局最优解。</p> 
<p>总之，贪心算法是一种基于每一步的局部最优选择来求解问题的思想，适用于一些满足贪心选择性质和最优子结构性质的问题。</p> 
<div> 
 <div></div> 
</div> 
<h4><a id="_1"></a>一）概念</h4> 
<p>贪心算法（Greedy Alogorithm）又叫登山算法，它的根本思想是逐步到达山顶，即<strong>逐步获得最优解</strong>，是解决最优化问题时的一种简单但是适用范围有限的策略。</p> 
<p>贪心算法没有固定的框架，算法设计的关键是贪婪策略的选择。贪心策略要无后向性，也就是说某状态以后的过程不会影响以前的状态，只与当前状态有关。</p> 
<p>贪心算法是对某些求解最优解问题的最简单、最迅速的技术。某些问题的最优解可以通过一系列的最优的选择即贪心选择来达到。但<strong>局部最优并不总能获得整体最优解，但通常能获得近似最优解</strong>。</p> 
<p>在每一步贪心选择中，只考虑当前对自己最有利的选择，而不去考虑在后面看来这种选择是否合理。</p> 
<h4><a id="_9"></a>二）找出全局最优解的要求</h4> 
<p>在遇见问题时如何确定是否可以使用贪心算法解决问题，那么决定一个贪心算法是否能找到全局最优解的条件是什么呢？其实就是以下两点：</p> 
<ul><li>最优子结构（optimal subproblem structure,和动态规划中的是一个概念）</li><li>最优贪心选择属性（optimal greedy choice property）</li></ul> 
<h4><a id="_15"></a>三）求解时应考虑的问题</h4> 
<p><strong>1.候选集合S</strong><br> 为了构造问题的解决方案，有一个候选集合C作为问题的可能解，问题的最终解均取自于候选集合C。<br> <strong>2.解集合S</strong><br> 随着贪心选择的进行，解集合不断扩展，直到构成一个满足问题的完整解。<br> <strong>3.解决函数solution</strong><br> 检查解集合是否构成问题的完整解。<br> <strong>4.选择函数select</strong><br> 即贪心策略，这是贪心算法的关键，它指出哪个候选对象有希望构成成问题的解。<br> <strong>5.可行函数feasible</strong><br> 检查解集合中加入一个候选对象是否可行，即解集合扩展后是否满足约束条件。</p> 
<h4><a id="_26"></a>四）基本步骤</h4> 
<p>贪心算法使用基本步骤：<br> 1.从问题的某个初始解出发<br> 2.采用循环语句，当可以向求解目标前进一步时，就根据局部最优策略，得到一个部分解，缩小问题的范围或规模。<br> 3.将所有的部分解综合起来，得到问题的最终解。</p> 
<h4><a id="_31"></a>五）贪心策略选择</h4> 
<p>贪心算法的原理是通过局部最优来达到全局最优，采用的是逐步构造最优解的方法。在每个阶段，都做出一个看上去最优的，决策一旦做出，就不再更改。</p> 
<p>要选出最优解可不是一件容易的事，要证明局部最优为全局最优，要进行数学证明，否则就不能说明为全局最优。</p> 
<p>很多问题表面上看来用贪心算法可以找到最优解，实际上却把最优解给漏掉了。这就像现实生活中的“贪小便宜吃大亏”。所以我们在解决问题的时候，一定要谨慎使用贪心算法，<strong>一定要注意这个问题适不适合采用贪心算法</strong>。</p> 
<p><strong>贪心算法很多时候并不能达到全局最优，为什么我们还要使用它呢？</strong></p> 
<p>因为在很多大规模问题中，寻找最优解是一件相当费时耗力的事情，有时候付出大量人力物力财力后，回报并不与投入成正比。在这个时候选择相对最优的贪心算法就比较经济可行了。有的问题对最优的要求不是很高，在充分衡量付出和回报后，选择贪心算法未尝不是一种不错的选择呢。</p> 
<h4><a id="_41"></a>六）实际应用</h4> 
<h5><a id="1_42"></a>1.零钱找回问题</h5> 
<p>这个问题在我们的日常生活中就更加普遍了。假设1元、2元、5元、10元、20元、50元、100元的纸币分别有c0, c1, c2, c3, c4, c5, c6张。现在要用这些钱来支付K元，至少要用多少张纸币？用贪心算法的思想，很显然，每一步尽可能用面值大的纸币即可。在日常生活中我们自然而然也是这么做的。在程序中已经事先将Value按照从小到大的顺序排好。<br> 下面展示一些 <code>内联代码片</code>。 </p> 
<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=7; 
int Count[N]={3,0,2,1,0,3,5};
int Value[N]={1,2,5,10,20,50,100};
  
int solve(int money) 
{
	int num=0;
	for(int i=N-1;i&gt;=0;i--) 
	{
		int c=min(money/Value[i],Count[i]);
		money=money-c*Value[i];
		num+=c;
	}
	if(money&gt;0) num=-1;
	return num;
}
 
int main() 
{
	int money;
	cin&gt;&gt;money;
	int res=solve(money);
	if(res!=-1) cout&lt;&lt;res&lt;&lt;endl;
	else cout&lt;&lt;"NO"&lt;&lt;endl;
}

</code></pre> 
<h5><a id="2_75"></a>2.<a href="https://so.csdn.net/so/search?q=%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98&amp;spm=1001.2101.3001.7020" target="_blank" class="hl hl-1" rel="noopener noreferrer">背包问题</a></h5> 
<p>在 从零开始学动态规划中我们已经谈过三种最基本的背包问题：零一背包，部分背包，完全背包。很容易证明，背包问题不能使用贪心算法。然而我们考虑这样一种背包问题：在选择物品i装入背包时，可以选择物品的一部分，而不一定要全部装入背包。这时便可以使用贪心算法求解了。计算每种物品的单位重量价值作为贪心选择的依据指标，选择单位重量价值最高的物品，将尽可能多的该物品装入背包，依此策略一直地进行下去，直到背包装满为止。在零一背包问题中贪心选择之所以不能得到最优解原因是贪心选择无法保证最终能将背包装满，部分闲置的背包空间使每公斤背包空间的价值降低了。在程序中已经事先将单位重量价值按照从大到小的顺序排好。 </p> 
<pre><code>#include&lt;iostream&gt;   
using namespace std;   
const int N=4;  
void knapsack(float M,float v[],float w[],float x[]);  
  
int main()  
{  
    float M=50;
	//背包所能容纳的重量   
    float w[]={0,10,30,20,5};
	//每种物品的重量  
    float v[]={0,200,400,100,10};  
  	//每种物品的价值 
    float x[N+1]={0};  
    //记录结果的数组 
    knapsack(M,v,w,x);  
    cout&lt;&lt;"选择装下的物品比例："&lt;&lt;endl;  
    for(int i=1;i&lt;=N;i++) cout&lt;&lt;"["&lt;&lt;i&lt;&lt;"]:"&lt;&lt;x[i]&lt;&lt;endl;  
}  
  
void knapsack(float M,float v[],float w[],float x[])  
{  
    int i;  
    //物品整件被装下  
    for(i=1;i&lt;=N;i++)
    {  
        if(w[i]&gt;M) break;   
        x[i]=1;  
        M-=w[i];  
    }   
    //物品部分被装下  
    if(i&lt;=N) x[i]=M/w[i];   
} 

</code></pre> 
<h5><a id="2_75"></a>3.<a href="https://so.csdn.net/so/search?q=%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81&amp;spm=1001.2101.3001.7020" target="_blank" class="hl hl-1" rel="noopener noreferrer">哈夫曼编码</a></h5> 
<p>假设有一系列的字符，我们希望用一些二进制码来代替这些字符以进行数据压缩，使得压缩后的总比特数最小。哈夫曼编码正是这样一样压缩数据的方式。</p> 
<p><img src="https://images2.imgbox.com/17/7d/1PwWKnkf_o.jpg" alt="在这里插入图片描述"></p> 
<p>如果我们已知各字符在文本中的出现频率，考虑到为了让压缩后的数据更小，我们直觉是让出现频率高的字符用尽可能短的编码，而出现频率高的则可以用更长的编码。<br> <img src="https://images2.imgbox.com/ac/54/P9pFybUm_o.png" alt=""><br> 哈夫曼编码的解决方案是这样的：不断找到当前出现频率最小的两个结点（字符或频率），将它们结合，作为一个新生成的结点的左右子结点，并将新生成的结点继续放入比较，直到没有落单的字符。</p> 
<p>过程演示</p> 
<p><img src="https://images2.imgbox.com/73/8e/rP1j2PVh_o.png" alt=""></p> 
<p>该贪心算法针对这个问题得到的解是最优的。</p> 
<h5><a id="4Djikstra_128"></a>4.单源路径中的Djikstra算法</h5> 
<p>求A到其他节点的最短路径：<br> <img src="https://images2.imgbox.com/4b/00/muMIVsVp_o.jpg" alt="在这里插入图片描述"><br> 维护三个东西，从A到其他节点的路径长度队列Queue，数组visited用于记录已保存最短路径的节点，数组res用于记录节点A到其他节点的最短路径。<br> 开始时，Queue中只有A节点自己，三组数据如下：<br> Queue：[(A, 0)] 起始节点为A，A到A的距离为0<br> visited：[true, false,false,false,false] A节点是已经访问过的节点，是true，其他节点是false<br> res：[0，∞，∞，∞，∞] A到自己的距离是0，到其他节点的距离目前是∞</p> 
<p>将以A为起点的路径加入到Queue中，2和4是节点D和B的路径权重：<br> Queue：[(D, 2), (B, 4)]<br> visited：[true, false,false,false,false]<br> res：[0，∞，∞，∞，∞]<br> 在Queue中，路径最短的是D，取出D，更新三组数据：<br> Queue：[(B, 3), (C, 3), (E, 9)]</p> 
<p>因为A-D-B的路径权重为3小于A-B的路径权重4，所以更新一下B的路径权重。<br> visited:[true,false,false,true,false]<br> res: [0,∞, ∞,2,∞]</p> 
<p>取出B，更新三组数据：<br> Queue: [(C,3), (E, 9)]<br> visited: [true,true,false,true,false]<br> res: [0,3, ∞,2, ∞]</p> 
<p>取出C，更新三组数据：<br> Queue：[(E, 6)]<br> visited: [true,true,true,true,false]<br> res: [0,3, 3,2, ∞]</p> 
<p>取出E，更新三组数据：<br> Queue：[]<br> visited: [true,true,true,true,true]<br> res: [0,3, 3,2, 6]</p> 
<p>至此，Queue队列空，计算过程结束。</p> 
<h5><a id="5Prim_164"></a>5.最小生成树Prim算法</h5> 
<p>prim算法（读者可以将其读作“普里姆算法”）用来解决最小生成树问题，其基本思想是对图G(V,E)设置集合S，存放已被访问的顶点，然后每次从集合V-S中选择与集合S的最短距离最小的一个顶点（记为u），访问并加入集合S。之后，令顶点u为中介点，优化所有从u能到达的顶点v与集合S之间的最短距离。这样的操作执行n次（n为顶点个数），直到集合S已包含所有顶点。可以发现，prim算法的思想与最短路径中Dijkstra算法的思想几乎完全相同，只是在涉及最短距离时使用了集合S代替 Dijkstra算法中的起点s。</p> 
<p><img src="https://images2.imgbox.com/50/1d/Q8dhJn1P_o.png" alt="在这里插入图片描述"></p> 
<p>①将地图上的所有边都抹去，只有当访问一个顶点后オ把这个顶点顶点连接的边显现（这点和Dijkstra算法中相同）。</p> 
<p>②将已访问的顶点置于ー个巨型防护罩中。可以沿着这个防护罩连接的边去访问未到达的顶点</p> 
<p>③在地图中的顶点V(0≤i≤5)上记录顶点V与巨型防护罩之间的最短距离（即V与每个访问的顶点之间距离的最小值）。由于在①把所有边都抹去了，因此在初始状态下只在顶点V0上标记0，而其他顶点都标记无穷大（记为INF）。为了方便叙述，在下文中某几处出现的最短距离都是指从顶点V与当前巨型防护罩之间的最短距离。</p> 
<p>下面是行动策略：</p> 
<p>①由于要访问六个顶点，因此将②③步骤执行六次，每次访问一个顶点（如果是n个顶点，那么就执行n次）。</p> 
<p>②每次都从还未访问的顶点中选择与当前巨型防护罩最近的顶点（记为Vk(0≤k≤5)），使用“爆裂模式”的能力恢复这条最近的边（并成为最小生成树中的一条边），前往访问。</p> 
<p>③访问顶点Vk后，将Vk加入巨型防护罩中，开放地图上Vk连接的所有边，并査看以Vk作为巨型防护罩连接外界的接口的情况下，能否利用Vk刚开放的边使某些还未访问的顶点与巨型防护罩的最短距离变小。如果能，则将那个最短距离覆盖到地图对应的顶点上。</p> 
<p>另外，为了得到最小生成树的边权之和，需要在访问顶点之前设置一个初值为0的变量sum，并在攻打过程中将加入最小生成树中的边的边权累加起来。</p> 
<div> 
 <div></div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/49a4eeb8378244c3c4ca144a54e993e6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">吊炸天的 Kafka 图形化工具 Eagle，必须推荐给你！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9f16068a0671e06ffdf7ca32f02f9e9e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JavaScript 空数组的 every() 方法详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>