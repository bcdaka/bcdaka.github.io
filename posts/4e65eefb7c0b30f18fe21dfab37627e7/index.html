<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java中的类与对象 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/4e65eefb7c0b30f18fe21dfab37627e7/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java中的类与对象">
  <meta property="og:description" content="面向对象 设计对象并使用 类: 是共同特征的描述(设计图)
对象: 是真实存在的具体实例
Javabean类: 用来描述一类事物的类,在Javabean类里是不写main方法的
注意: 类名首字母要大写,见名知意,(驼峰模式)
注意: 在实际开发中,建议一个文件定义一个class类
代码:
package com.xiaonan.Demo01; public class GirlFriend { //属性 String name; int age; String gender; //行为 public void eat(){ System.out.println(&#34;在吃饭&#34;); } public void sleep(){ System.out.println(&#34;在睡觉&#34;); } } package com.xiaonan.Demo01; public class GirlFriendTest { public static void main(String[] args) { //创建一个女朋友对象 GirlFriend gf1 = new GirlFriend(); //赋值 gf1.age = 18; gf1.gender = &#34;女&#34;; gf1.name = &#34;小琪&#34;; //输出 System.out.println(gf1.age); System.out.println(gf1.gender); System.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-22T02:30:00+08:00">
    <meta property="article:modified_time" content="2024-03-22T02:30:00+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java中的类与对象</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="面向对象">面向对象</h2> 
<h3 id="设计对象并使用" style="background-color:transparent;">设计对象并使用</h3> 
<ul><li> <p>类: 是共同特征的描述(设计图)</p> </li><li> <p>对象: 是真实存在的具体实例</p> </li><li> <p>Javabean类: 用来描述一类事物的类,在Javabean类里是不写main方法的</p> 
  <ol><li> <p>注意: 类名首字母要大写,见名知意,(驼峰模式)</p> </li><li> <p>注意: 在实际开发中,建议一个文件定义一个class类</p> <p>代码:</p> <pre><code>package com.xiaonan.Demo01;

public class GirlFriend {
   //属性
   String name;
   int age;
   String gender;

   //行为
   public void eat(){
       System.out.println("在吃饭");
   }

   public void sleep(){
       System.out.println("在睡觉");
   }
}</code></pre> </li></ol></li></ul> 
<pre><code>package com.xiaonan.Demo01;

public class GirlFriendTest {
    public static void main(String[] args) {
        //创建一个女朋友对象
        GirlFriend gf1 = new GirlFriend();

        //赋值
        gf1.age = 18;
        gf1.gender = "女";
        gf1.name = "小琪";

        //输出
        System.out.println(gf1.age);
        System.out.println(gf1.gender);
        System.out.println(gf1.name);

        //调用方法
        gf1.eat();
        gf1.sleep();

        System.out.println("--------------------");
        //new第二个对象
        GirlFriend gf2 = new GirlFriend();
        //赋值
        gf2.age = 18;
        gf2.gender = "女";
        gf2.name = "小青";

        //输出
        System.out.println(gf2.age);
        System.out.println(gf2.gender);
        System.out.println(gf2.name);

        //调用方法
        gf1.eat();
        gf1.sleep();
    }
}</code></pre> 
<h3 id="封装" style="background-color:transparent;">封装</h3> 
<ul><li> <p>是面向对象三大特征 (封装 继承 多态)</p> </li><li> <p>对象代表什么,就得封装对应的数据,并提供数据对应的行为</p> <p>案例:</p> <p>人关门</p> <p>这个门是自己关的,人只是给门一个作用力</p> </li></ul> 
<h4 id="private关键字">private关键字</h4> 
<ul><li> <p>是一个权限修饰符</p> </li><li> <p>可以修饰成员(成员变量 和成员方法)</p> </li><li> <p>被private(私有的)修饰的成员只能在本类中才能访问</p> <p>例子:</p> </li></ul> 
<pre><code>package com.xiaonan.test;

public class Test {
    private int age; // private:私有的

    //set 赋值
    public void setAge(int a){
        if(a&gt;=10 &amp;&amp; a&lt;= 50){
            age = a;
        }else{
            System.out.println("非法数据");
        }
    }

    //get(获取)
    public int getAge(){
        return age;
    }
}</code></pre> 
<ul><li> <p>针对private修饰的成员变量,如果需要被其他的类使用,要提供相应的操作</p> </li><li> <p>提供"setXxx(参数)" 方法,用于给成员变量赋值,方法用public修饰</p> </li><li> <p>提供"getXxx()" 方法,用于获取成员变量的值,方法用public(公共的)修饰</p> </li></ul> 
<h3 id="就近原则和this关键字" style="background-color:transparent;">就近原则和this关键字</h3> 
<p>示例代码:</p> 
<pre><code>package com.xiaonan.test01;

public class GirlFriend {

    //成员变量
    private int age;

    public void method() {
        //局部变量 (方法变量)
        int age = 10;
        //System.out.println(age); //就近原则(谁离我近,我就用谁)
        System.out.println(this.age); //this关键字 这里的age是 成员变量的age
    }
}</code></pre> 
<pre><code>package com.xiaonan.test01;

public class GirlFriendTest {
    public static void main(String[] args) {
        //创建一个 GirlFriend对象
        //格式: 类名 对象名 = new 类名();
        //例子
        GirlFriend gf1 = new GirlFriend();
        gf1.method();
    }
}</code></pre> 
<h4 id="this关键字的作用">this关键字的作用</h4> 
<ul><li>区分成员变量和局部变量</li></ul> 
<h3 id="构造方法" style="background-color:transparent;">构造方法</h3> 
<p>在Java中，构造方法是用于创建对象并初始化对象的特殊方法。构造方法具有以下注意事项：</p> 
<ol><li> <p>构造方法的名称必须与类名完全相同，且没有返回类型（包括void），它们不能被显式地调用，而是在创建对象时自动调用。</p> </li><li> <p>如果在类中没有定义任何构造方法，Java编译器会自动生成一个默认的无参构造方法。如果在类中定义了构造方法，编译器将不会自动生成默认构造方法。</p> </li><li> <p>可以定义多个构造方法，它们可以具有不同的参数列表（参数个数、类型或顺序不同），这被称为方法的重载（overloading）。</p> </li><li> <p>构造方法可以有访问修饰符（如public、private、protected）来控制对构造方法的访问权限。一般情况下，构造方法应该使用public修饰符，以便其他类可以实例化对象。</p> </li><li> <p>在构造方法中可以使用关键字super调用父类的构造方法，以便在创建子类对象时初始化父类的成员变量。</p> </li><li> <p>构造方法可以使用this关键字调用同一个类中的其他构造方法，以便在构造方法之间进行重用。</p> </li><li> <p>构造方法可以抛出异常，但通常不建议在构造方法中抛出受检异常，而应该在构造方法中处理异常或使用非受检异常。</p> </li><li> <p>构造方法可以执行任意的初始化操作，例如初始化对象的成员变量、调用其他方法等。</p> </li></ol> 
<p>需要注意的是，构造方法的主要目的是在创建对象时进行初始化操作，因此应该避免在构造方法中执行过多的逻辑或复杂的计算。如果需要进行复杂的初始化操作，可以考虑使用静态工厂方法或其他设计模式来替代构造方法。</p> 
<h3 id="标准的javabean" style="background-color:transparent;">标准的JavaBean</h3> 
<ul><li> <p>类名要见名知意</p> </li><li> <p>成员变量使用private修饰</p> </li><li> <p>提供至少两个构造方法</p> 
  <ol><li> <p>无参构造方法</p> </li><li> <p>带全部参数的构造方法</p> </li></ol></li><li> <p>成员方法</p> 
  <ol><li> <p>提供每一个成员变量对应的setXxx()与getXxx()</p> </li><li> <p>如果还有其他的行为也要写上</p> </li></ol></li></ul> 
<h4 id="快捷键">快捷键</h4> 
<p>// alt + insert (快速生成JavaBean标准类的 构造无参与全部参数的方法 和set方法和get方法)</p> 
<h4 id="插件">插件</h4> 
<p>PTG 一秒生成标准的JavaBean</p> 
<h3 id="对象内存图" style="background-color:transparent;">对象内存图</h3> 
<h4 id="一个对象内存图">一个对象内存图</h4> 
<p>当在Java中创建一个对象时，它会在堆内存中分配一块连续的内存空间来存储对象的数据。下面是一个更详细的Java对象的内存图示例：</p> 
<ol><li> <p>Object Header：对象头是用于存储对象的元数据的部分。它通常包含以下信息：</p> 
  <ul><li>类型指针（Type Pointer）：指向对象所属的类的元数据。</li><li>哈希码（Hash Code）：对象的哈希码，用于支持对象的哈希表操作。</li><li>锁信息（Lock Information）：用于支持对象的同步和并发操作。</li></ul></li><li> <p>Instance Variables：实例变量，也称为成员变量或字段，是对象的数据部分。它们是在类中定义的变量，用于存储对象的状态和属性。每个实例变量占用一定的内存空间，具体大小取决于变量的类型和对齐要求。</p> </li></ol> 
<p>创建对象时，Java虚拟机会执行以下步骤：</p> 
<ol><li> <p>分配内存：Java虚拟机在堆内存中分配一块连续的内存空间来存储对象的数据。</p> </li><li> <p>初始化对象头：Java虚拟机会将对象头的字段初始化为默认值，如类型指针、哈希码和锁信息。</p> </li><li> <p>初始化实例变量：Java虚拟机会将实例变量的值初始化为默认值，如数值类型为0，布尔类型为false，引用类型为null。</p> </li><li> <p>执行构造方法：Java虚拟机会调用对象的构造方法来执行进一步的初始化操作，可以在构造方法中设置实例变量的具体值。</p> <p>注意：上述内存图和步骤是基于Java的传统对象模型，具体实现可能会因Java虚拟机的不同实现而有所不同。此外，Java还有其他的内存区域，如栈内存、方法区等，用于存储不同类型的数据和执行程序的其他操作。</p> <h4 id="两个引用指向同一个对象">两个引用指向同一个对象</h4> <p>在Java中，可以通过将两个引用变量指向同一个对象来实现这种情况。当两个引用指向同一个对象时，它们实际上引用了相同的内存地址，因此它们可以访问和修改相同的对象数据。</p> <p>下面是一个示例代码，演示了如何在Java中创建两个引用指向同一个对象：</p> <pre><code>public class Main {
 public static void main(String[] args) {
     // 创建一个对象
     MyClass obj = new MyClass();

     // 创建两个引用指向同一个对象
     MyClass ref1 = obj;
     MyClass ref2 = obj;

     // 修改对象的数据
     obj.setData("Hello, World!");

     // 通过两个引用访问和修改相同的对象数据
     System.out.println(ref1.getData());  // 输出: Hello, World!
     System.out.println(ref2.getData());  // 输出: Hello, World!
 }
}

class MyClass {
 private String data;

 public void setData(String data) {
     this.data = data;
 }

 public String getData() {
     return data;
 }
}</code></pre> <p>在上面的示例中，<code>ref1</code>和<code>ref2</code>是两个引用变量，它们都指向<code>obj</code>所引用的同一个<code>MyClass</code>对象。通过这两个引用变量，我们可以访问和修改相同的对象数据。</p> <p>需要注意的是，当一个对象没有任何引用指向它时，它将成为Java中的垃圾对象，并由垃圾收集器回收内存。因此，在使用多个引用指向同一个对象时，需要小心确保在不需要引用时及时将其置为<code>null</code>，以便垃圾收集器可以回收不再使用的对象。</p> <h3 id="基本数据类型与引用数据类型的区别" style="background-color:transparent;">基本数据类型与引用数据类型的区别</h3> </li><li> <p>存储方式：基本数据类型的值直接存储在变量中，而引用数据类型的变量存储的是对象的引用（内存地址）。</p> </li><li> <p>大小和默认值：基本数据类型具有固定的大小和默认值，而引用数据类型的大小取决于对象的大小，且默认值为null。</p> 
  <ul><li>基本数据类型的大小是固定的，不受具体平台的影响。例如，int类型始终占用4个字节。</li><li>引用数据类型的大小取决于所引用对象的大小。例如，一个引用变量可能指向一个很小的对象或一个很大的对象。</li><li>基本数据类型的默认值是根据其类型确定的。例如，int类型的默认值为0，boolean类型的默认值为false。</li><li>引用数据类型的默认值为null，表示该引用变量当前未指向任何对象。</li></ul></li><li> <p>传递方式：基本数据类型在方法参数传递时是按值传递的，而引用数据类型在方法参数传递时是按引用传递的。</p> 
  <ul><li>当将基本数据类型作为方法参数传递时，传递的是实际的值的副本。在方法内部对参数进行修改不会影响原始值。</li><li>当将引用数据类型作为方法参数传递时，传递的是引用的副本。在方法内部对参数进行修改会影响原始对象。</li></ul></li><li> <p>内存管理：基本数据类型的变量直接存储数据值，内存管理由编译器或解释器处理；而引用数据类型的变量存储对象的引用，对象的创建和销毁由开发人员手动管理或由垃圾回收器自动处理。</p> 
  <ul><li>基本数据类型的变量在栈上分配内存，其生命周期由程序控制。</li><li>引用数据类型的对象在堆上分配内存，其生命周期由开发人员手动管理或由Java的垃圾回收器自动处理。</li></ul><p>需要注意的是，Java中的基本数据类型包括boolean、byte、short、int、long、float、double和char，而其他所有的类型都属于引用数据类型，包括类、接口、数组和枚举等。</p> <h3 id="this关键字的内存原理" style="background-color:transparent;">this关键字的内存原理</h3> <h4 id="作用-用于区分局部变量和成员变量" style="background-color:transparent;">作用: 用于区分局部变量和成员变量</h4> <h4 id="this的本质-所在方法调用者的地址值" style="background-color:transparent;">this的本质: 所在方法调用者的地址值</h4> <p>在Java中，<code>this</code>关键字表示当前对象的引用。它可以在实例方法和构造方法中使用，用于引用当前正在执行方法的对象。</p> <p><code>this</code>关键字的内存原理如下：</p> </li><li> <p>当创建一个对象时，Java虚拟机会在堆上为该对象分配内存空间，并将对象的实例变量存储在该内存空间中。</p> </li><li> <p>当调用对象的实例方法时，Java虚拟机会将当前对象的引用作为隐藏参数传递给方法。这个隐藏参数就是<code>this</code>关键字所表示的当前对象的引用。</p> </li><li> <p>在方法内部，可以使用<code>this</code>关键字来访问当前对象的实例变量和实例方法。通过<code>this</code>关键字，可以明确地指定当前对象的成员，避免与局部变量或参数发生命名冲突。</p> </li><li> <p>当方法执行完毕后，<code>this</code>关键字的作用也就结束了。它不会占用额外的内存空间，而是在方法调用结束后被释放。</p> </li></ol> 
<p>需要注意的是，每个实例方法都有一个隐含的<code>this</code>参数，但它并不会显式地出现在方法的参数列表中。编译器会自动将<code>this</code>参数添加到方法的参数列表中，以便在方法内部使用。</p> 
<p>总结起来，<code>this</code>关键字在Java中用于引用当前对象，它并不占用额外的内存空间，而是作为方法的隐含参数传递给实例方法。通过<code>this</code>关键字，可以访问当前对象的实例变量和实例方法。</p> 
<h3 id="成员变量和局部变量的区别" style="background-color:transparent;">成员变量和局部变量的区别</h3> 
<p>在Java中，成员变量（也称为实例变量）和局部变量是两种不同类型的变量，它们有以下区别：</p> 
<ol><li> <p>作用域：成员变量定义在类中，可以在整个类中的各个方法中访问。而局部变量定义在方法、代码块或构造函数中，仅在其所在的作用域内有效。</p> </li><li> <p>生命周期：成员变量的生命周期与对象的生命周期相同，当对象创建时被初始化，直到对象被销毁。而局部变量的生命周期仅限于其所在的作用域，在离开作用域后，局部变量将被销毁。</p> </li><li> <p>默认值：成员变量会被赋予默认值，例如，整数类型的成员变量默认值为0，布尔类型的成员变量默认值为false。而局部变量没有默认值，必须在使用之前显式初始化。</p> </li><li> <p>访问修饰符：<strong>成员变量可以使用不同的访问修饰符（如public、private、protected）进行访问控制，以控制其可见性。而局部变量不能使用访问修饰符，它们的可见性仅限于其所在的作用域内。</strong></p> </li><li> <p>内存分配：成员变量在对象创建时分配内存空间，每个对象都有一份成员变量的拷贝。而局部变量在方法调用或代码块执行时分配内存空间，每次调用或执行都会创建一个新的局部变量。</p> </li></ol> 
<p>需要注意的是，成员变量和局部变量可以同名，但在同一作用域内，局部变量会覆盖同名的成员变量。如果需要访问成员变量，可以使用关键字"this"来引用当前对象的成员变量。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/68ba9b88a4fc818ff2b8814a4fab8c25/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决The following method did not exist:net.sf.jsqlparser.statement.select.SelectExpressionItem报错</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4bd71e0bf210acb62ddef99d3c6239c8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python 下载的9种方法，不愧是Alibaba技术官</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>