<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>颠仆流离学二叉树2 (Java篇) - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/82b0e218e3baf8f6e277fb91a9145bc5/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="颠仆流离学二叉树2 (Java篇)">
  <meta property="og:description" content="本篇会加入个人的所谓鱼式疯言
❤️❤️❤️鱼式疯言:❤️❤️❤️此疯言非彼疯言
而是理解过并总结出来通俗易懂的大白话,
小编会尽可能的在每个概念后插入鱼式疯言,帮助大家理解的.
🤭🤭🤭可能说的不是那么严谨.但小编初心是能让更多人能接受我们这个概念 ！！！
前言 在上篇中我们学习了 二叉树的基本概念 以及他们的特性结论，并运用到了 具体的题目 中去解决问题 。
而在本篇中，小编讲继续学习 二叉树 的基本操作, 主要围绕着我们 遍历二叉树 来讲解 ， 人狠话不多，下面让我们切入主题吧 💥 💥 💥
目录 二叉树的遍历初识
前序遍历
中序遍历
4.后序遍历
层序遍历
二叉树遍历的应用
一. 二叉树的遍历初识 学习二叉树的结构，最简单的方式就是遍历，所谓遍历 是指 沿着某条搜索路线，依次树中的某个节点均做一次访问， 访问节点所做的操作 依赖于要解决的各种实际问题。
遍历是二叉树是最重要的操作之一，是 二叉树上进行其他运算 的基础
1. 二叉树的遍历简介 在遍历二叉树时， 如果没有进行某种约定，每个人都按照自己的方式来遍历， 得到的结果就比较乱， 如果我们按照某个规则 来遍历， 则每个人对于遍历结果都是相同的 ， 如果 N 代表 根节点，L 代表左节点， R 代表 右节点， 那根据遍历的的节点有以下的遍历方式。
NLR： 前序遍历 (先序遍历) 根据 根——》 左 ——》 右 的顺序对二叉树进行遍历
LNR : ==中序遍历 ==： 根据 左——》 根——》 右 的顺序 对二叉树进行遍历">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-29T23:36:45+08:00">
    <meta property="article:modified_time" content="2024-05-29T23:36:45+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">颠仆流离学二叉树2 (Java篇)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>本篇会加入个人的所谓<code>鱼式疯言</code></p> 
<p>❤️❤️❤️<code>鱼式疯言</code>:❤️❤️❤️此疯言非彼疯言</p> 
<p>而是理解过并总结出来通俗易懂的<mark>大白话</mark>,</p> 
<p>小编会尽可能的在每个概念后插入<code>鱼式疯言</code>,帮助大家理解的.</p> 
<p>🤭🤭🤭可能说的不是那么<code>严谨</code>.但小编初心是能让更多人能接受我们这个<code>概念</code> ！！！</p> 
<p><img src="https://images2.imgbox.com/a9/12/P6j53L4v_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_20"></a>前言</h2> 
<p>在上篇中我们学习了 <code>二叉树的基本概念</code> 以及他们的特性结论，并运用到了 <mark>具体的题目</mark> 中去解决问题 。</p> 
<p>而在本篇中，小编讲继续学习 <code>二叉树</code> 的基本操作, 主要围绕着我们 <mark>遍历二叉树</mark> 来讲解 ， 人狠话不多，下面让我们切入主题吧 💥 💥 💥</p> 
<h2><a id="_26"></a>目录</h2> 
<ol><li> <p>二叉树的遍历初识</p> </li><li> <p>前序遍历</p> </li><li> <p>中序遍历</p> </li></ol> 
<p>4.后序遍历</p> 
<ol start="5"><li> <p>层序遍历</p> </li><li> <p>二叉树遍历的应用</p> </li></ol> 
<h2><a id="__42"></a>一. 二叉树的遍历初识</h2> 
<p>学习二叉树的结构，最简单的方式就是遍历，所谓<strong>遍历</strong> 是指 <mark>沿着某条搜索路线，依次树中的某个节点均做一次访问， 访问节点所做的操作</mark> 依赖于要解决的各种实际问题。</p> 
<p>遍历是二叉树是最重要的操作之一，是 <code>二叉树上进行其他运算</code> 的基础</p> 
<h3><a id="1__49"></a>1. 二叉树的遍历简介</h3> 
<p><img src="https://images2.imgbox.com/e4/10/l6b6f1PO_o.png" alt="在这里插入图片描述"></p> 
<p>在遍历二叉树时， 如果没有进行某种约定，每个人都按照自己的方式来遍历， 得到的结果就比较乱， 如果我们按照<mark>某个规则</mark> 来遍历， 则<em><strong>每个人对于遍历结果都是相同的</strong></em> ， 如果 N 代表 <code>根节点</code>，L 代表<code>左节点</code>， R 代表 <code>右节点</code>， 那根据遍历的的节点有以下的遍历方式。</p> 
<ul><li> <p>NLR： <mark>前序遍历</mark> (先序遍历) 根据 <code>根——》 左 ——》 右</code> 的顺序对二叉树进行<strong>遍历</strong></p> </li><li><li> <p>LNR : ==中序遍历 ==： 根据 <code>左——》 根——》 右</code> 的顺序 对二叉树进行<strong>遍历</strong></p> </li><li> <p>LRN <mark>后序遍历</mark> : 根据 <code>左——》 右 ——》 根</code> 的顺序对二叉树进行<strong>遍历</strong></p> </li></ul> 
<p>详细的遍历方式， 小编下面细讲哦 💖 💖 💖 💖</p> 
<p>在遍历二叉树之前， 我们先用一下代码简单的 <mark>构建一颗二叉树</mark></p> 
<pre><code class="prism language-java">

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBinaryTree</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> left<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> right<span class="token punctuation">;</span>

        <span class="token keyword">public</span>  <span class="token keyword">char</span> val<span class="token punctuation">;</span>


        <span class="token keyword">public</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">char</span> val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token class-name">TreeNode</span>  root<span class="token punctuation">;</span>

    <span class="token comment">// 构造二叉树</span>
    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">createBinaryTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        root<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token char">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">TreeNode</span> <span class="token class-name">B</span><span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token char">'B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">TreeNode</span> <span class="token class-name">D</span><span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token char">'D'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">TreeNode</span> <span class="token class-name">E</span><span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token char">'E'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">TreeNode</span> <span class="token class-name">H</span><span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token char">'H'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">TreeNode</span> <span class="token class-name">C</span><span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token char">'C'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">TreeNode</span> <span class="token class-name">F</span><span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token char">'F'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">TreeNode</span> <span class="token class-name">G</span><span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token char">'G'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        root<span class="token punctuation">.</span>left<span class="token operator">=</span><span class="token class-name">B</span><span class="token punctuation">;</span>
        <span class="token class-name">B</span><span class="token punctuation">.</span>left<span class="token operator">=</span><span class="token class-name">D</span><span class="token punctuation">;</span>
        <span class="token class-name">B</span><span class="token punctuation">.</span>right<span class="token operator">=</span><span class="token class-name">E</span><span class="token punctuation">;</span>
        <span class="token class-name">E</span><span class="token punctuation">.</span>right<span class="token operator">=</span><span class="token class-name">H</span><span class="token punctuation">;</span>
        root<span class="token punctuation">.</span>right<span class="token operator">=</span><span class="token class-name">C</span><span class="token punctuation">;</span>
        <span class="token class-name">C</span><span class="token punctuation">.</span>left<span class="token operator">=</span><span class="token class-name">F</span><span class="token punctuation">;</span>
        <span class="token class-name">C</span><span class="token punctuation">.</span>right<span class="token operator">=</span><span class="token class-name">G</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> root<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


<span class="token comment">// 前序遍历</span>
<span class="token keyword">void</span> <span class="token function">preOrder</span><span class="token punctuation">(</span><span class="token class-name">Node</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 中序遍历</span>
<span class="token keyword">void</span> <span class="token function">inOrder</span><span class="token punctuation">(</span><span class="token class-name">Node</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 后序遍历</span>
<span class="token keyword">void</span> <span class="token function">postOrder</span><span class="token punctuation">(</span><span class="token class-name">Node</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="__132"></a>二. 前序遍历</h2> 
<h3><a id="1__141"></a>1. 前序遍历的特点</h3> 
<p><img src="https://images2.imgbox.com/06/d8/LLq3alls_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>按照从<strong>左子树开始</strong>走，一直 <strong>往下递归</strong>，每一步所走的路径成为<strong>我们的根</strong>，先遍历完根之后。</p> 
</blockquote> 
<blockquote> 
 <p>按照根左右的顺序， 当我们<mark>走完每个根节点的左子树</mark> 时， 先往下<mark>递</mark>， 再往<code>回归</code> , <mark>左节点成为新的根</mark>， 会到最初的根节点之后，再向右子树进行 <code>先递后归</code> 的操作,</p> 
</blockquote> 
<h4><a id="_156"></a>动画演示</h4> 
<p><img src="https://images2.imgbox.com/c4/6a/vgcK9vQa_o.gif" alt="请添加图片描述"></p> 
<h3><a id="2__164"></a>2. 前序遍历的实现</h3> 
<p>因为前序遍历有 <code>递归 和 非递归</code> 的两种方式， 但 <code>遍历的原理和方向都是一致的</code></p> 
<p>在本篇文章中，。小编都会带着小伙伴们 一 一 实现 💥 💥 💥 💥</p> 
<p><img src="https://images2.imgbox.com/df/79/G1lYvzBW_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="1__183"></a>&lt;1&gt;. 前序遍历的递归实现</h4> 
<pre><code class="prism language-java">   <span class="token comment">// 前序遍历</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">FirstDisplay</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">FirstDisplay</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">FirstDisplay</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/46/cc/NB4aK5WM_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>这里的代码的递归思路就是完美的按照我们<strong>遍历方向</strong>来的， <code>先访问，后递归</code></p> 
</blockquote> 
<h4><a id="2__214"></a>&lt;2&gt;. 前序遍历的非递归实现</h4> 
<pre><code class="prism language-java">
  <span class="token comment">// 非递归的前序遍历</span>

    <span class="token keyword">public</span>  <span class="token keyword">void</span>  <span class="token class-name">FirstDisplayNo</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        <span class="token comment">// 先创建一个栈来存放树的每个节点</span>
        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> stack<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 先把艮节点创建一遍</span>
        <span class="token class-name">TreeNode</span> cur<span class="token operator">=</span>root<span class="token punctuation">;</span>

        <span class="token comment">/**
         * 外循环主要遍历 右边的节点
         * 用于出栈的数据
         * 并让节点向右移动
         */</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

            <span class="token comment">/**
             * 在这个内循环中
             * 当往左走就添加数据，一直到为 null 结束
             *  并进行打印
             */</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 先打印</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment">// 打印完就入栈</span>
                stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment">// 节点向左移动</span>
                cur<span class="token operator">=</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token comment">// 出栈存放数据</span>
            cur<span class="token operator">=</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 并向右走</span>
            cur<span class="token operator">=</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span>

            <span class="token comment">// 当再次循环时，如果左边还有节点就会继续存放</span>
        <span class="token punctuation">}</span>


        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
    
</code></pre> 
<p><img src="https://images2.imgbox.com/72/dc/4lQwsZ3g_o.png" alt="在这里插入图片描述"></p> 
<p>非递归的 实现步骤</p> 
<blockquote> 
 <ol><li>先定义一个栈 ， 来记录我们每次遍历过的 <code>根节点</code></li></ol> 
</blockquote> 
<blockquote> 
 <ol start="2"><li>先让根节点一直 <code>向左走</code> ，当遍历完我们的 <mark>左子树</mark> （也就是我们的 <code>root = null</code> 时候）， 并且入栈， 记录下来以便后面我们遍历 <code>右子树</code></li></ol> 
</blockquote> 
<blockquote> 
 <ol start="3"><li>然后<strong>出栈</strong>， 开始<code> 向右走</code> ， 遍历我们的 <code>右子树</code></li></ol> 
</blockquote> 
<blockquote> 
 <ol start="4"><li>当整个栈为 <code>null</code> 并且到达的这个节点 cur 也为 <code>null</code> ， 就意味着遍历完整个 <em><strong>二叉树所有的节点</strong></em></li></ol> 
</blockquote> 
<h3><a id="_293"></a>鱼式疯言</h3> 
<p>无论是 <code>递归</code>还是<code>非递归</code>的 <mark>前序遍历</mark> , 我们的<code> 前序遍历思路</code>就是</p> 
<blockquote> 
 <p><strong>先走根</strong> ， <mark>根走完走左</mark> ， <mark>左走完回到根</mark>， <code>再走右</code> ，<mark>一层一层的走</mark>， <code>一步一步的回</code> 。</p> 
</blockquote> 
<p><strong>细节处理</strong>：</p> 
<p>在代码上我们要注意的就是这个<mark>当节点为 null</mark> ，也就意味着我们要开始 <mark>回退</mark> 到 <code>上一个节点</code></p> 
<h2><a id="__311"></a>二. 中序遍历</h2> 
<p><img src="https://images2.imgbox.com/07/ea/DX9ydXPK_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="1__319"></a>1. 中序遍历的特点</h3> 
<p>我们知道 <mark>中序遍历</mark> ， 是以 <mark>左- 根-右的顺序</mark> 进行遍历</p> 
<blockquote> 
 <p>我们先从 走左边， 还是让每个左节点先成为<mark>新的根</mark>， 当这个新的根的 <code>左子树</code> 都走完之后， 才能真正<mark>访问</mark>我们当前 <strong>新的节点</strong>。</p> 
</blockquote> 
<blockquote> 
 <p>以此类推，我们新的节点访问结束后，就会进行回退到前一个<strong>旧的节点</strong>，继续访问，最终当整个 <strong>左子树走完</strong> ， 并且 <strong>访问完我们的根</strong> ， 就遍历我们的<code>右子树</code> ，最终回到我们整颗树的 <code>根节点</code></p> 
</blockquote> 
<h4><a id="_334"></a>动画演示</h4> 
<p><img src="https://images2.imgbox.com/ad/f4/1JxyhK6B_o.gif" alt="请添加图片描述"></p> 
<h3><a id="2_339"></a>2.中序遍历的实现</h3> 
<p><img src="https://images2.imgbox.com/5e/87/GaFrhmkp_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="1_347"></a>&lt;1&gt;.中序遍历的递归实现</h4> 
<pre><code class="prism language-java"><span class="token comment">// 中序遍历</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">middleDisplay</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">middleDisplay</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">middleDisplay</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/7d/73/3mDJCgLT_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>这里的代码的<strong>递归思路</strong>就是完美的按照我们<strong>遍历方向</strong>来的， <code>先递归，后访问</code> ，小编在这里就 <mark>不赘述</mark> 了</p> 
</blockquote> 
<h4><a id="2__380"></a>&lt;2&gt;. 中序遍历的非递归实现</h4> 
<pre><code class="prism language-java">
 <span class="token comment">// 非递归的中序遍历</span>
    <span class="token keyword">public</span>  <span class="token keyword">void</span>  middleDisplayNo <span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        <span class="token comment">// 创建一个栈用于回退节点</span>
        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> stack<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 先放根节点</span>
        <span class="token class-name">TreeNode</span> cur<span class="token operator">=</span>root<span class="token punctuation">;</span>

        <span class="token comment">/**
         * 外循环主要用于遍历 右边
         * 更是用于出栈的回退
         */</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

            <span class="token comment">/**
             * 内循环先遍历下去
             * 边遍历边存放
             */</span>

            <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

                stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
                cur<span class="token operator">=</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token comment">// 出栈最后一个无左节点的左子树</span>
            cur<span class="token operator">=</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 打印该节点</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 再往右走</span>
            cur<span class="token operator">=</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/46/7d/9NXBWgs4_o.png" alt="在这里插入图片描述"></p> 
<p><em><strong>非递归的实现步骤</strong></em>：</p> 
<p>我们先定义一个 <code>栈</code> ，用来存储走过的每个 <mark>左子树</mark>的节点</p> 
<ol><li> <p>先 <code>往左边</code> 的节点走，先<code>整个左子树</code> 的每个节点都入栈， 当 <mark>这个节点 为 null</mark> 就 <code>停止入栈</code></p> </li><li> <p>然后进行出栈， 出栈的时候，我们就可以对该节点进行打印（访问） ， 并且向 <code>右子树节点</code> 开始走</p> </li><li> <p>当整个栈为 <code>null</code> 并且 该节点也为 <mark>null</mark> ， 也就意味着遍历完二叉树 <code>所有的节点</code></p> </li></ol> 
<h3><a id="_454"></a>鱼式疯言</h3> 
<p>中序遍历的最核心的要点就是</p> 
<blockquote> 
 <p>无论是 <code>递归</code> 还是 <code>非递归</code> 的 <mark>中序遍历</mark>：</p> 
</blockquote> 
<blockquote> 
 <p>一定要先<code>走完每个左子树</code>， 当我们进行 <em><strong>回退</strong></em> 的时候。 才轮的到该 <mark>根节点去遍历</mark>， 最后才走 <code>右子树</code>的一种 <strong>顺序</strong>.</p> 
</blockquote> 
<h2><a id="__479"></a>三. 后序遍历</h2> 
<h3><a id="1__486"></a>1. 后序遍历的特点</h3> 
<p><img src="https://images2.imgbox.com/7b/37/Ixhj6Kzk_o.png" alt="在这里插入图片描述"></p> 
<p>后序遍历的顺序就是 ： <code>左-右-根</code> 的顺序，</p> 
<blockquote> 
 <p>还是先走左边的节点，让 <mark>左边的节点</mark> 成为 <strong>新的根</strong> ， 直到找到走完整个 <code>左子树</code> ，回退后继续走 <mark>右子树</mark>，当 <mark>右子树</mark>走完之后，回去的根节点就是我们要 <code>访问</code> 的</p> 
</blockquote> 
<h4><a id="_501"></a>动画演示</h4> 
<p><img src="https://images2.imgbox.com/1e/13/Z1BVTbuy_o.gif" alt="请添加图片描述"></p> 
<h3><a id="2__507"></a>2. 后序遍历的实现</h3> 
<p><img src="https://images2.imgbox.com/42/ed/qYV0G8AR_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="1__513"></a>&lt;1&gt;. 后序遍历的递归实现</h4> 
<pre><code class="prism language-java">   <span class="token comment">// 后序遍历</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lastDisplay</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token function">lastDisplay</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">lastDisplay</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/c3/45/tbcJw4k4_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>这里的代码的<strong>递归思路</strong>就是完美的按照我们<strong>遍历方向</strong>来的， <code>先递归，后访问</code> ，小编在这里就 <mark>不赘述</mark> 了</p> 
</blockquote> 
<h4><a id="2__545"></a>&lt;2&gt;. 后序遍历的非递归实现</h4> 
<pre><code class="prism language-java"> <span class="token comment">// 非递归的后序遍历</span>
    <span class="token keyword">public</span>  <span class="token keyword">void</span>  lastDisplayNo <span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> stack<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">TreeNode</span> cur<span class="token operator">=</span>root<span class="token punctuation">;</span>
        <span class="token class-name">TreeNode</span> flg<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

                stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
                cur<span class="token operator">=</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token class-name">TreeNode</span> top<span class="token operator">=</span>stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>top<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> flg<span class="token operator">==</span>top<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>top<span class="token punctuation">.</span>val<span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                flg<span class="token operator">=</span>top<span class="token punctuation">;</span>
                stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                cur<span class="token operator">=</span>top<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/b2/49/iaChyDOR_o.png" alt="在这里插入图片描述"></p> 
<p><strong>非递归的实现思路</strong>：</p> 
<p>我们先定义一个栈，用来存放节点， 而这里存放的节点有可能是 <code>左子树的节点</code>，也有可能是 <mark>右子树的节点</mark></p> 
<blockquote> 
 <ol><li>先向左走，让左子树的节点先入栈</li></ol> 
</blockquote> 
<blockquote> 
 <ol start="2"><li>然后 <strong>查看栈顶元素</strong>，如果栈顶元素的<code>右节点 </code>为 <mark>null</mark> ， 我们就 <code>打印（访问）</code> 该节点，</li></ol> 
</blockquote> 
<blockquote> 
 <ol start="3"><li>如果栈顶元素的 <code>右节点</code> 不为 <mark>null</mark> , 我们就 让 该节点 <strong>向右走</strong> , 并且入栈</li></ol> 
</blockquote> 
<blockquote> 
 <ol start="4"><li>以此循环往复，当 <code>栈为 null</code> 并且 <mark>节点 cur 也为 null</mark> ， 说明我们已经遍历完这个 二叉树<code>所有的节点</code></li></ol> 
</blockquote> 
<h3><a id="_612"></a>鱼式疯言</h3> 
<p>无论是 <strong>非递归还是递归实现</strong> 对二叉树的 <strong>后序遍历</strong></p> 
<ul><li class="task-list-item"> <p><input type="checkbox" class="task-list-item-checkbox" disabled> 小伙伴们只需要记住一点： <mark>后序遍历</mark> 一定是 <code>两边先走完</code> ,最后回到我们的根节点才 <code>访问</code> 的</p> </li><li class="task-list-item"> <p><input type="checkbox" class="task-list-item-checkbox" disabled> 小伙伴们一定要把每个节点都看出一颗<strong>独立的树</strong>。<mark>每个节点</mark> 都是一个 <code>独立的根节点</code> 来理解我们的 <code>三大遍历</code></p> </li></ul> 
<pre><code class="prism language-java"><span class="token class-name">TreeNode</span> flg <span class="token operator">=</span><span class="token keyword">null</span>


      <span class="token keyword">if</span> <span class="token punctuation">(</span>top<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> flg<span class="token operator">==</span>top<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>top<span class="token punctuation">.</span>val<span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                flg<span class="token operator">=</span>top<span class="token punctuation">;</span>
                stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> 
</code></pre> 
<p>细节处理： 我们需要用一个 <code>flg</code> 来记录上一个已经 <strong>访问过</strong> 的节点，判断 <strong>是否访问过</strong>， 防止再次让 <strong>top</strong> 向右走，继续入栈， 否则会进入 <mark>死循环</mark></p> 
<h2><a id="__638"></a>四. 层序遍历</h2> 
<p>谈及完前面的 <code>三大遍历</code>， 这些是我们 <code>操作二叉树的根本</code> ，但还有还要介绍一种 <mark>比较特殊的遍历</mark></p> 
<p><img src="https://images2.imgbox.com/b0/fe/A5TFTO74_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="1__648"></a>1. 层序遍历的特点</h3> 
<blockquote> 
 <p>二叉树 <code>层序遍历</code> 的方向是从 <mark>根节点</mark>，按照 <strong>从上而下，从左到右</strong> 的顺序进行遍历 <strong>二叉树的每一个节点</strong></p> 
</blockquote> 
<h4><a id="_656"></a>动画演示</h4> 
<p><img src="https://images2.imgbox.com/10/f7/IuDRDbwK_o.gif" alt="请添加图片描述"></p> 
<h3><a id="2__665"></a>2. 层序遍历的实现</h3> 
<pre><code class="prism language-java"><span class="token comment">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>

    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">S</span><span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token class-name">S</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>

        <span class="token function">creatOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">return</span> <span class="token class-name">S</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">creatOrder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        
        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">S</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">S</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">S</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">creatOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">creatOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


    
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/e2/c2/qOKkDgU2_o.png" alt="在这里插入图片描述"></p> 
<p>具体实现步骤：</p> 
<ol><li> <p>我们用一个 <code>二维数组（二维顺序表）</code> 来存储每一个节点，二叉树 <mark>每一层</mark>代表是二维数组的 <code>每一行</code>， 在这二叉树每一层的行中，<mark>从左往右的节点</mark> 代表二维数组的 <code>每一列</code></p> </li><li> <p>当二叉树从 <code>左子树</code> 开始递归， 意味着先存储 <mark>每一行</mark> 的 <code>二叉树的节点</code></p> </li><li> <p>当二叉树向 <code>右子树</code> 开始递归， 意味着存储 <mark>每一列</mark> 的 <code>二叉树的节点</code></p> </li><li> <p>最终当整个二叉树完全递归就意味着 <strong>全部的节点都存储</strong>在 这个二维数组 (二维顺序表) 中</p> </li></ol> 
<h3><a id="_750"></a>鱼式疯言</h3> 
<pre><code class="prism language-java">  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">S</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">S</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre> 
<p><strong>细节处理</strong></p> 
<blockquote> 
 <p>每新添加<code> 一行数据</code> ，需要 <code>扩容</code> ，就是需要再 <mark>实例化一个顺序表</mark> ，已有的行数就 <code>不需要了</code></p> 
</blockquote> 
<blockquote> 
 <p>小伙伴们有没有发现，二叉树的层序遍历，本质上和我们的 <mark>完全二叉树的定义</mark> 是一样的，都是满足 <code>自上而下，自左而右</code> 的特点</p> 
</blockquote> 
<h2><a id="__781"></a>六. 二叉树遍历的应用</h2> 
<p>学习完了 <strong>二叉树遍历</strong>，小伙伴们是时候 <code>牛刀小试</code> 一下了 💞 💞 💞</p> 
<h3><a id="1__787"></a>1. 习题一：</h3> 
<p>1.某完全二叉树按层次输出（同一层从左到右）的序列为 ABCDEFGH 。该完全二叉树的前序序列为()</p> 
<p>A: ABDHECFG</p> 
<p>B: ABCDEFGH</p> 
<p>C: HDBEAFCG</p> 
<p>D: HDEBFGCA</p> 
<h4><a id="_802"></a>题目解析</h4> 
<p>我们知道了二叉树的 <code>层序遍历</code> , 并且小伙伴们还有没有注意一个条件就是 <code>完全二叉树</code></p> 
<blockquote> 
 <p><strong>完全二叉树</strong>的特点就是 <code>自上而下</code> ， <code>自左而右</code> <mark>节点不间断</mark></p> 
</blockquote> 
<p>那么我们不妨画个<strong>草图</strong>吧</p> 
<p><img src="https://images2.imgbox.com/2d/92/klbIve6f_o.png" alt="在这里插入图片描述"></p> 
<p>画出草图，我们就很明显的知道了，答案选： <strong>A</strong></p> 
<h3><a id="2__823"></a>2. 习题二：</h3> 
<p>2.二叉树的先序遍历和中序遍历如下：先序遍历：EFHIGJK;中序遍历：HFIEJKG.则二叉树根结点为()</p> 
<p>A: E</p> 
<p>B: F</p> 
<p>C: G</p> 
<p>D: H</p> 
<h4><a id="_841"></a>题目解析：</h4> 
<p>此题题目就是 答案， 我们知道前序遍历， 是从 <code>根节点</code> 开始的 , 所以 <code>第一个访问出来的节点</code> 就是我们的 <mark>根节点</mark></p> 
<p>故：答案选：<strong>A</strong></p> 
<h3><a id="3__853"></a>3. 习题三：</h3> 
<p>3.设一课二叉树的中序遍历序列：badce，后序遍历序列：bdeca，则二叉树前序遍历序列为()</p> 
<p>A: adbce</p> 
<p>B: decab</p> 
<p>C: debac</p> 
<p>D: abcde</p> 
<p>题目解析：</p> 
<p>此题的精髓就在于，我们要根据 <mark>中序遍历 和 后序遍历</mark> ，<strong>画出草图</strong>， 根据草图得到我们的 <code>前序遍历</code></p> 
<p><img src="https://images2.imgbox.com/10/55/ohcAJCni_o.png" alt="在这里插入图片描述"><br> 画草图的方法：</p> 
<p>方法： 先根据后序遍历寻找 <strong>根节点</strong></p> 
<p>对于 <code>后序遍历</code> 来说：根节点是从右往左 ， 然后结合 <code>中序遍历的特点</code> 来确定 <strong>左右节点</strong> 的位置</p> 
<p>故此题答案选: D</p> 
<h3><a id="4__886"></a>4. 习题四：</h3> 
<p>4.某二叉树的后序遍历序列与中序遍历序列相同，均为 ABCDEF ，则按层次输出(同一层从左到右)的序列为()</p> 
<p>A: FEDCBA</p> 
<p>B: CBAFED</p> 
<p>C: DEFCBA</p> 
<p>D: ABCDEF</p> 
<h4><a id="__906"></a>题目解析 :</h4> 
<p>此题的精髓就在于，我们要根据 <mark>中序遍历 和 后序遍历</mark> ，<strong>画出草图</strong>， 根据草图得到我们的 <code>层序遍历</code></p> 
<p><img src="https://images2.imgbox.com/17/2b/Rb1dzM2i_o.png" alt="在这里插入图片描述"></p> 
<p>依照上一题的方法，我们成功画出草图，最终得到我们的层序遍历</p> 
<p>故答案选: <strong>A</strong></p> 
<h3><a id="_921"></a>鱼式疯言</h3> 
<p>独家秘方：</p> 
<blockquote> 
 <ol><li>对于我们已知 <code>前序和中序</code> 遍历，我们的方法就是根据 <mark>前序遍历从左往右</mark> 找根节点，然后结合 中序遍历 <code>画出草图</code></li></ol> 
</blockquote> 
<blockquote> 
 <ol start="2"><li>对于 我们已知的 <code>后序和中序</code> 遍历， 我们的方法是 根据 <mark>后序遍历 从右往左找根节点</mark> ， 然后结合中序遍历 <code>画出草图</code></li></ol> 
</blockquote> 
<p>对于上述题目来说， 画图是 <strong>根本</strong></p> 
<h2><a id="_933"></a>总结</h2> 
<ul><li class="task-list-item"> <p><input type="checkbox" class="task-list-item-checkbox" disabled> . 二叉树的遍历初识： 我们通过基本的概念知道了二叉树是通过一定 <code>规则和方向</code> 来遍历我们 每一个节点</p> </li><li class="task-list-item"> <p><input type="checkbox" class="task-list-item-checkbox" disabled> . 前序遍历 : 本源是 根-左-右的方向遍历</p> </li><li class="task-list-item"> <p><input type="checkbox" class="task-list-item-checkbox" disabled> . 中序遍历： 本源是 左-根-右的方向遍历</p> </li><li class="task-list-item"> <p><input type="checkbox" class="task-list-item-checkbox" disabled> .后序遍历 ： 本质上还是根据 左-右-根的方向遍历</p> </li><li class="task-list-item"> <p><input type="checkbox" class="task-list-item-checkbox" disabled> . 层序遍历： 遵循一个 自上而下， 自左而右 的顺序遍历</p> </li><li class="task-list-item"> <p><input type="checkbox" class="task-list-item-checkbox" disabled> . 二叉树遍历的应用 ： 我们主打一个对于这四种遍历的性质的理解和应用，来画图解题</p> </li></ul> 
<blockquote> 
 <p>如果觉得小编写的还不错的咱可支持 <strong>三连</strong> 下 (定有回访哦) , 不妥当的咱请评论区 <strong>指正</strong></p> 
</blockquote> 
<blockquote> 
 <p>希望我的文章能给各位宝子们带来哪怕一点点的收获就是 小编创作 的最大 <strong>动力</strong> 💖 💖 💖</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/f1/b8/AsN7CNpW_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4fc946b7fa7f38d1c0f4f5b250dbe7b3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">构造&#43;模拟，CF1148C. Crazy Diamond</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/484919febf58a7f98a30f9b7fead34af/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">拉格朗日插值法的推导</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>