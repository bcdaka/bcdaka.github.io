<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 创建事件(Event)、事件监听器(EventListener)、事件发布(publishEvent)详解和相关demo - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/72800970741213014c0aa2aada3ebc67/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java 创建事件(Event)、事件监听器(EventListener)、事件发布(publishEvent)详解和相关demo">
  <meta property="og:description" content="在Java中，你可以使用事件（Event）、事件监听器（EventListener）和事件发布（publishEvent）来实现事件驱动的编程模型。下面我将简要介绍一下它们的基本概念：
事件（Event）：事件是在软件应用程序中发生的某种事情，可以是用户交互、系统状态变化等。事件通常用一个类来表示，这个类包含了描述事件的相关信息。例如，如果你正在构建一个图形用户界面（GUI）应用程序，那么鼠标点击、键盘输入等就可以作为事件。
事件发布（publishEvent）：事件发布指的是在事件发生时通知所有注册的监听器，并调用相应的处理方法。事件发布者负责管理监听器的注册和通知。
事件监听器（EventListener）：事件监听器是一个接口，包含了处理特定类型事件的方法。当事件发生时，监听器会被通知并调用相应的处理方法。在Java中，通常需要自定义事件监听器来处理自定义的事件类型。
实现步骤 ： ApplicationEventPublisher 是 Spring Framework 中用于发布事件的接口。publishEvent 方法是其主要方法之一，用于发布事件给注册的监听器。当你调用 publishEvent 方法时，Spring 会将事件传递给所有注册的监听器，这些监听器可以在事件发生时执行特定的逻辑。
通常，你可以通过以下步骤来使用 ApplicationEventPublisher 的 publishEvent 方法：
实现一个事件类，通常是继承自 Spring 的 ApplicationEvent 类。在你的应用程序中注册一个或多个监听器，这些监听器会监听特定类型的事件。当某个条件被满足时，创建该事件的实例，并通过 ApplicationEventPublisher 的 publishEvent 方法发布该事件。 这样，所有注册的监听器都将收到该事件，并且可以执行相应的逻辑。
1、事件对象（Event） 事件对象是包含了事件相关信息的类，用于在事件源和事件监听器之间传递数据。必须继承ApplicationEvent。
package com.yan.project.event; import org.springframework.context.ApplicationEvent; /** * @description: 事件对象（Event） * * @create: 2024-05-16 15:27 **/ public class MyEvent extends ApplicationEvent { private EventVo eventVo; public MyEvent(Object source, EventVo eventVo) { super(source); this.eventVo = eventVo; } public EventVo getEventVo() { return eventVo; } } 小技巧： idea中可以点击如图小按钮，自动跳转至监听事件中。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-16T17:24:47+08:00">
    <meta property="article:modified_time" content="2024-05-16T17:24:47+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 创建事件(Event)、事件监听器(EventListener)、事件发布(publishEvent)详解和相关demo</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在Java中，你可以使用事件（Event）、事件监听器（EventListener）和事件发布（publishEvent）来实现事件驱动的编程模型。下面我将简要介绍一下它们的基本概念：</p> 
<ol><li> <p><strong>事件（Event）</strong>：事件是在软件应用程序中发生的某种事情，可以是用户交互、系统状态变化等。事件通常用一个类来表示，这个类包含了描述事件的相关信息。例如，如果你正在构建一个图形用户界面（GUI）应用程序，那么鼠标点击、键盘输入等就可以作为事件。</p> </li><li> <p><strong>事件发布（publishEvent）</strong>：事件发布指的是在事件发生时通知所有注册的监听器，并调用相应的处理方法。事件发布者负责管理监听器的注册和通知。</p> </li><li> <p><strong>事件监听器（EventListener）</strong>：事件监听器是一个接口，包含了处理特定类型事件的方法。当事件发生时，监听器会被通知并调用相应的处理方法。在Java中，通常需要自定义事件监听器来处理自定义的事件类型。</p> </li></ol> 
<p><img alt="" height="880" src="https://images2.imgbox.com/3c/21/sUGxtn7c_o.png" width="1200"></p> 
<p></p> 
<h2>实现步骤 ：</h2> 
<p><span style="color:#0d0016;"><strong><code>ApplicationEventPublisher</code> 是 Spring Framework 中用于发布事件的接口。<code>publishEvent</code> 方法是其主要方法之一，用于发布事件给注册的监听器。当你调用 <code>publishEvent</code> 方法时，Spring 会将事件传递给所有注册的监听器，这些监听器可以在事件发生时执行特定的逻辑。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>通常，你可以通过以下步骤来使用 <code>ApplicationEventPublisher</code> 的 <code>publishEvent</code> 方法：</strong></span></p> 
<blockquote> 
 <ol><li><span style="color:#0d0016;"><strong>实现一个事件类，通常是继承自 Spring 的 <code>ApplicationEvent</code> 类。</strong></span></li><li><span style="color:#0d0016;"><strong>在你的应用程序中注册一个或多个监听器，这些监听器会监听特定类型的事件。</strong></span></li><li><span style="color:#0d0016;"><strong>当某个条件被满足时，创建该事件的实例，并通过 <code>ApplicationEventPublisher</code> 的 <code>publishEvent</code> 方法发布该事件。</strong></span></li></ol> 
 <p><span style="color:#0d0016;"><strong>这样，所有注册的监听器都将收到该事件，并且可以执行相应的逻辑。</strong></span></p> 
</blockquote> 
<p></p> 
<h2> 1、事件对象（Event）</h2> 
<p>事件对象是包含了事件相关信息的类，用于在事件源和事件监听器之间传递数据。必须继承ApplicationEvent。</p> 
<pre><code class="language-java">package com.yan.project.event;

import org.springframework.context.ApplicationEvent;

/**
 * @description: 事件对象（Event）
 *
 * @create: 2024-05-16 15:27
 **/
public class MyEvent extends ApplicationEvent {


    private EventVo eventVo;

    public MyEvent(Object source, EventVo eventVo) {
        super(source);
        this.eventVo = eventVo;
    }

    public EventVo getEventVo() {
        return eventVo;
    }
}</code></pre> 
<p></p> 
<h3>小技巧：</h3> 
<p>idea中可以点击如图小按钮，自动跳转至监听事件中。</p> 
<p><img alt="" height="213" src="https://images2.imgbox.com/ef/f7/7q9lI1vE_o.png" width="1147"></p> 
<p></p> 
<h2><strong>2、事件发布（publishEvent）</strong></h2> 
<p>事件发布是指事件源对象发出事件的过程。使用<strong>ApplicationEventPublisher的publishEvent()</strong>方法。</p> 
<pre><code class="language-java">package com.xxx.project.event;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @create: 2024-03-21 23:36
 **/

@RestController
@RequestMapping("/testEvent")
public class testController {

    @Autowired
    private ApplicationEventPublisher applicationEventPublisher;


    @GetMapping("/test")
    public String testEvent() {
        EventVo eventVo = new EventVo();
        eventVo.setId("001");

        applicationEventPublisher.publishEvent(new MyEvent(null, eventVo));
        return null;

    }


}
</code></pre> 
<h3></h3> 
<h2>3、事件监听器（EventListener）</h2> 
<p>当相应的事件被发布时，这些方法会被触发执行，处理事件相关的逻辑。使用 <span style="color:#0d0016;"><strong>@EventListener</strong> </span>注解或者<strong> <span style="color:#0d0016;"><code>@TransactionalEventListener</code></span></strong></p> 
<pre><code class="language-java">package com.xxx.project.event;

import org.springframework.stereotype.Component;
import org.springframework.transaction.event.TransactionPhase;
import org.springframework.transaction.event.TransactionalEventListener;

/**
 * @create: 2024-05-16 16:47
 **/

@Component
public class EventListener {

    // 在Spring框架中，@TransactionalEventListener 注解允许你定义在事务的不同阶段处理事件。
    // phase = TransactionPhase.AFTER_COMMIT 指定了事件监听器应该在事务提交后执行。
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void processEvent(MyEvent myEvent){
        EventVo eventVo = myEvent.getEventVo();

        String id = eventVo.getId();

        //  处理其他业务
        // TODO:
    }
}
</code></pre> 
<p><span style="color:#0d0016;">在Spring框架中，<code>@TransactionalEventListener</code> 注解允许你定义在事务的不同阶段处理事件。<code>phase = TransactionPhase.AFTER_COMMIT</code> 指定了事件监听器应该在事务提交后执行。</span></p> 
<blockquote> 
 <p><span style="color:#0d0016;">一般的，事件发布或事件监听后处理逻辑应该都是异步不阻塞线程。可以在发布时间或者事件监听方法上面加上@Async注解</span></p> 
</blockquote> 
<p></p> 
<h2>总结</h2> 
<p>监听器的作用在于允许你对应用程序中发生的事件做出响应，并执行相应的逻辑。使用 Spring 的事件机制，你可以将应用程序分解成更小、更易于管理的部分，并允许这些部分之间以解耦的方式进行通信。</p> 
<p>具体来说，对于上述示例中的监听器，其作用包括：</p> 
<ol><li> <p><strong>解耦</strong>：通过将事件发布和处理逻辑分离，使得应用程序的不同部分之间解耦。事件发布者不需要知道谁在监听事件，而监听器也不需要直接调用事件发布者的方法。这种解耦可以使得代码更加模块化和可维护。</p> </li><li> <p><strong>扩展性</strong>：当你需要在应用程序的不同部分之间引入新的交互或逻辑时，可以轻松地添加新的事件和监听器，而不会影响现有的代码。这种扩展性使得你可以更容易地修改和扩展应用程序。</p> </li><li> <p><strong>异步处理</strong>：Spring 的事件机制支持异步处理事件，这意味着你可以在事件发生时选择立即执行监听器中的逻辑，或者将其放入队列中以便稍后执行。这在需要处理大量事件或执行长时间运行操作时特别有用，因为它可以提高应用程序的响应性能。</p> </li><li> <p><strong>通用性</strong>：通过定义自己的事件类型和监听器，你可以实现各种自定义的业务逻辑。这使得你可以根据应用程序的需求定义特定的事件，并编写特定的监听器来处理这些事件，从而实现更精细的控制和功能。</p> </li></ol> 
<p>总的来说，整个调用过程是一个松耦合的事件驱动模型。业务部分和事件监听器之间没有直接的依赖关系，监听器则通过事件类型感知并响应事件，实现了对象之间的解耦。这种模式使得系统更加灵活、可扩展，并能更容易地实现事件驱动的业务逻辑。使得代码更具可维护性、可扩展性和可重用性。</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6a97d0aed42c7306855f72d09e793056/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">初始Java篇（JavaSE基础语法）（8）认识String类（上）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/151ad9d4374aa2ca05d76702fd92eaf8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">alertmanager 配置钉钉告警以及模板（prometheus-webhook-dingtalk）基于 kube-prometheus</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>