<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 实现自定义注解 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/c4b5a767e6018ce3459c154b9b9797de/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="Java 实现自定义注解">
  <meta property="og:description" content="一、@interface 关键字 我们想定义一个自己的注解 需要使用 @interface 关键字来定义。
如定义一个叫 MyAnnotation 的注解：
public @interface MyAnnotation { } 二、元注解 光加上 @interface 关键字 还不够，我们还需要了解5大元注解
@Retention@Target@Documented@Inherited（JDK8 引入）@Repeatable（JDK8 引入） 1) @Retention 指定注解的生命周期 @Retention(RetentionPolicy.SOURCE) 其中Retention是一个枚举类:
RetentionPolicy.SOURCE : 注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃(.java文件)RetentionPolicy.CLASS :注解被保留到class文件，但jvm加载class文件时候被遗弃，这是默认的生命周期(.class文件)RetentionPolicy.RUNTIME: 注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在(内存中的字节码) 2) @Target指定注解可以修饰的元素类型
@Target(ElementType.Field) ElementType.ANNOTATION_TYPE - 标记的注解可以应用于注解类型。ElementType.CONSTRUCTOR - 标记的注解可以应用于构造函数。ElementType.FIELD - 标记的注解可以应用于字段或属性。ElementType.LOCAL_VARIABLE - 标记的注解可以应用于局部变量。ElementType.METHOD - 标记的注解可以应用于方法。ElementType.PACKAGE - 标记的注解可以应用于包声明。ElementType.PARAMETER - 标记的注解可以应用于方法的参数。ElementType.TYPE - 标记的注解可以应用于类的任何元素。 3）@Documented
指定注解会被JavaDoc工具提取成文档。默认情况下，JavaDoc是不包括文档的
4）@Inherited
表示该注解会被子类继承，注意，仅针对类，成员属性、方法并不受此注释的影响。
5）@Repeatable
表示注解可以重复使用，为了解决同一个注解不能重复在同一类/方法/属性上使用的问题。
其中最常用的就是 @Retention 跟 @Target。
三、简单实现 例如实现一个简单，在标记注解的地方打印一句日志。
定义一个 MyAnnotation 注解，并且定义一个属性 message 默认值是 ”aaa“。先将该注解加到字段上，看能不能获取到。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-11T10:24:15+08:00">
    <meta property="article:modified_time" content="2024-04-11T10:24:15+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 实现自定义注解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 id="%E4%B8%80%E3%80%81%40interface%20%E5%85%B3%E9%94%AE%E5%AD%97">一、@interface 关键字</h4> 
<p>我们想定义一个自己的注解 需要使用 @interface 关键字来定义。<br> 如定义一个叫 MyAnnotation 的注解：</p> 
<pre><code class="language-java">public @interface MyAnnotation { }</code></pre> 
<h4 id="%C2%A0%E4%BA%8C%E3%80%81%E5%85%83%E6%B3%A8%E8%A7%A3"> 二、元注解</h4> 
<p>  光加上 @interface 关键字 还不够，我们还需要了解5大元注解</p> 
<ul><li><code>@Retention</code></li><li><code>@Target</code></li><li><code>@Documented</code></li><li><code>@Inherited（JDK8 引入）</code></li><li><code>@Repeatable（JDK8 引入）</code></li></ul> 
<p><strong> 1)  @Retention 指定注解的生命周期    </strong></p> 
<pre><code class="language-java">@Retention(RetentionPolicy.SOURCE)</code></pre> 
<p>其中Retention是一个枚举类:</p> 
<ol><li><span style="color:#fe2c24;">RetentionPolicy.SOURCE : </span>注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃(.java文件)</li><li><span style="color:#fe2c24;">RetentionPolicy.CLASS :</span>注解被保留到class文件，但jvm加载class文件时候被遗弃，这是默认的生命周期(.class文件)</li><li><span style="color:#fe2c24;">RetentionPolicy.RUNTIME: </span>注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在(内存中的字节码)</li></ol> 
<p><strong>2) @Target指定注解可以修饰的元素类型</strong></p> 
<pre><code class="language-java">@Target(ElementType.Field)</code></pre> 
<ol><li><span style="color:#fe2c24;">ElementType.ANNOTATION_TYPE</span> - 标记的注解可以应用于注解类型。</li><li><span style="color:#fe2c24;">ElementType.CONSTRUCTOR</span> - 标记的注解可以应用于构造函数。</li><li><span style="color:#fe2c24;">ElementType.FIELD</span> - 标记的注解可以应用于字段或属性。</li><li><span style="color:#fe2c24;">ElementType.LOCAL_VARIABLE</span> - 标记的注解可以应用于局部变量。</li><li><span style="color:#fe2c24;">ElementType.METHOD </span>- 标记的注解可以应用于方法。</li><li><span style="color:#fe2c24;">ElementType.PACKAGE</span> - 标记的注解可以应用于包声明。</li><li><span style="color:#fe2c24;">ElementType.PARAMETER </span>- 标记的注解可以应用于方法的参数。</li><li><span style="color:#fe2c24;">ElementType.TYPE </span>- 标记的注解可以应用于类的任何元素。</li></ol> 
<p><strong> 3）@Documented</strong><br> 指定注解会被JavaDoc工具提取成文档。默认情况下，JavaDoc是不包括文档的</p> 
<p><strong> 4）@Inherited</strong><br> 表示该注解会被子类继承，注意，仅针对类，成员属性、方法并不受此注释的影响。</p> 
<p><strong> 5）@Repeatable</strong><br> 表示注解可以重复使用，为了解决同一个注解不能重复在同一类/方法/属性上使用的问题。</p> 
<p>        其中最常用的就是 <strong>@Retention 跟 @Target。</strong></p> 
<h4>三、简单实现</h4> 
<p>        例如实现一个简单，在标记注解的地方打印一句日志。<br>         定义一个 MyAnnotation 注解，并且定义一个属性 message 默认值是 ”aaa“。先将该注解加到字段上，看能不能获取到。</p> 
<pre><code class="language-java">//注解用于字段上
@Target(ElementType.FIELD)
//运行时使用
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {

    String message() default  "aaa";

}</code></pre> 
<p>        定义一个Student类用于测试： </p> 
<pre><code class="language-java">@Data
public class Student {

    @JSONField(ordinal =0)
    @MyAnnotation(message = "AAAAAAAAA")
    public String name;

    @MyAnnotation(message = "AAAAAAAAA")
    public Integer score;


}</code></pre> 
<p>  在字段上标注该注解，然后编写一个main方法获取该注解的属性：</p> 
<pre><code class="language-java">    public static void main(String[] args) {
        Class&lt;?&gt; studentClass = Student.class;
        Field[] fields = studentClass.getDeclaredFields();//获取所有的类成员变量字段
        for (Field field : fields) {
            String fieldName = field.getName(); //获取该类成员变量的名字
            System.out.println("成员变量名是：" + fieldName);
            Annotation[] annotations = field.getAnnotations(); //获取该类成员变量上所有声明周期是运行时的注解
            for (Annotation annotation : annotations) {
                Class&lt;? extends Annotation&gt; annotationType = annotation.annotationType();
                String annotationName = annotationType.getSimpleName();//注解的简短名称
                System.out.println(" 使用的注解是：" + annotationName);
                //判断该注解是不是 MyAnnotation 注解，是的话打印其 id 和 describe 属性
                if (annotationType.equals(MyAnnotation.class)) {
                    MyAnnotation myAnnotation = field.getAnnotation(MyAnnotation.class);
                    String message = myAnnotation.message();
                    System.out.println("    MyAnnotation注解中的message是：" + message);

                }
            }
            System.out.println();
        }
    }</code></pre> 
<p> 执行后打印的内容：<br><img alt="" height="276" src="https://images2.imgbox.com/60/59/BvmrrmsT_o.png" width="511"></p> 
<p>        以上就是一个注解的简单实现。</p> 
<p></p> 
<h4>四、使用切面执行自定义注解逻辑</h4> 
<p>        在开发中一般加上注解之后会自动执行一些逻辑，大部分实现的原理是使用切面来实现注解的逻辑的。</p> 
<p>       1) 首先将刚才的注解修改成放在方法上的：</p> 
<pre><code class="language-java">//注解用于方法
@Target(ElementType.METHOD)
//运行时使用
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {

    String message() default  "aaa";

}</code></pre> 
<p>        2) 定义一个切面类：</p> 
<pre><code class="language-java">@Component
@Aspect
@Slf4j
public class MyAnnotationAspect {


    /*
     * 这是一个切入点
     * */
    @Pointcut("@annotation(com.demo.aaa.annotation.MyAnnotation)")
    public void cutMethod(){

    }
    /**
     * 切点之前
     */
    @Before("cutMethod()")
    public void before(JoinPoint joinPoint) throws Throwable {
        log.info("============ before ==========");
    }

    /**
     * 切点之后
     */
    @After("cutMethod()")
    public void after() throws Throwable {
        log.info("============ after ==========");
    }

    /**
     * 切点返回内容后
     */
    @AfterReturning("cutMethod()")
    public void afterReturning() throws Throwable {
        log.info("============ afterReturning ==========");
    }

    /**
     * 切点抛出异常后
     */
    @AfterThrowing("cutMethod()")
    public void afterThrowing() throws Throwable {
        log.info("============ afterThrowing ==========");
    }


    @Around("cutMethod() &amp;&amp; @annotation(myAnnotation)")
    public Object around(ProceedingJoinPoint point, MyAnnotation myAnnotation) throws Throwable {

        log.info("============ around1 ==========");
        Object  obj= point.proceed(point.getArgs());
        log.info("============ around2 ==========");
        return obj;
    }


}
</code></pre> 
<p>在使用aop之前需要先引入一个依赖： </p> 
<pre><code class="language-XML">        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.8.13&lt;/version&gt;
        &lt;/dependency&gt;</code></pre> 
<p>   简单说一下各个注解代表什么含义：</p> 
<ul><li><strong>@Aspect:</strong>作用是把当前类标识为一个切面供容器读取 ，也就是加上这个注解，spring才知道你这是一个切面类，用于处理切点的逻辑的。</li><li><strong>@Pointcut:</strong>切入点，@Pointcut切点表达式非常丰富，可以将 方法(method)、类(class)、接口(interface)、包(package) 等作为切入点，非常灵活，常用的有@annotation、@within、execution等方式，上面的示例使用的是@annotation方式，意思就是说被Spring扫描到方法上带有@annotation中的注解 就会执行切面通知。</li><li><strong>@Before</strong>：该注解标注的方法在业务模块代码执行之前执行，其不能阻止业务模块的执行，除非抛出异常；</li><li><strong>@AfterReturning：</strong>该注解标注的方法在业务模块代码执行之后执行；</li><li><strong>@AfterThrowing：</strong>该注解标注的方法在业务模块抛出指定异常后执行；</li><li><strong>@After：</strong>该注解标注的方法在所有的 Advice 执行完成后执行，无论业务模块是否抛出异常，类似于 finally 的作用；</li><li><strong>@Around：</strong>该注解功能最为强大，其所标注的方法用于编写包裹业务模块执行的代码，通知的第一个参数必须是 ProceedingJoinPoint 类型。在通知体内，调用 ProceedingJoinPoint 的 proceed () 方法使得连接点方法执行如果不调用 proceed () 方法，连接点方法则不会执行。无论是调用前逻辑还是调用后逻辑，都可以在该方法中编写，甚至其可以根据一定的条件而阻断业务模块的调用；      如果切面中使用了@Around 注解，如果不调用 ProceedingJoinPoint 的 proceed () 方法的话，那么 @Before  和 @After 直接标注的方法也不会被触发。@Around 注解标注的方法，在 ProceedingJoinPoint 的 proceed () 方法 前的逻辑是比@Before的逻辑还要靠前， 在proceed () 方法之后的逻辑比 @After 的逻辑还要靠后。</li><li><strong>Joint Point：</strong>JointPoint是程序运行过程中可识别的点，这个点可以用来作为<a href="https://so.csdn.net/so/search?q=AOP&amp;spm=1001.2101.3001.7020" title="AOP">AOP</a>切入点。JointPoint对象则包含了和切入相关的很多信息。比如切入点的对象，方法，属性等。我们可以通过反射的方式获取这些点的状态和信息，用于追踪tracing和记录logging应用信息。</li></ul> 
<p> 3）将注解放入到接口方法中测试：</p> 
<pre><code class="language-java">    @GetMapping("/aaa")
    @MyAnnotation(message = "成功拉！！！！！！！！！！！！")
    public void test() {
        System.out.println("执行代码逻辑");
    }</code></pre> 
<p>   调用接口之后打印<br><img alt="" height="143" src="https://images2.imgbox.com/dd/5b/nvGC9uQz_o.png" width="1049"></p> 
<p></p> 
<p>上面就是自定义注解最简单的示例。</p> 
<p></p> 
<h4>五、切点表达式</h4> 
<p>        我们定义切点除了使用 @Pointcut() 之外，我们还有丰富的切点表达式可以定义切点。</p> 
<p><strong>        1）切点表达式简介   </strong>   <img alt="" height="322" src="https://images2.imgbox.com/6b/4e/PUiMZjD7_o.png" width="779"></p> 
<p><strong>        2）通配符合与逻辑运算符</strong></p> 
<p> @AspectJ 支持三种通配符：<br><img alt="" height="136" src="https://images2.imgbox.com/ad/e2/DHqHgDZt_o.png" width="782"></p> 
<p>逻辑运算符： 切点表达式由切点函数组成，切点函数之间还可以进行逻辑运算，组成复合切点。</p> 
<p><img alt="" height="138" src="https://images2.imgbox.com/fd/5a/0uNrhjrm_o.png" width="792"></p> 
<p><strong>        3）切点表达式：</strong></p> 
<p>     <strong>   1.arg()</strong> :匹配切入点方法的参数类型，匹配的上才是切点。<br>           <strong>语法：args(param-pattern)  </strong> param-pattern：参数类型的全路径。<br>         <strong>  注意：</strong>要先匹配到某些类，不然会报错，也就是不能单独用<br>           <strong>示例：</strong></p> 
<pre><code class="language-java">@Pointcut("args(java.lang.String)")  //这样就是错的，不能单独使用要匹配到某些类

@Pointcut("within(com.example.demo.service.impl.UserServiceImpl) &amp;&amp; args(java.lang.String,java.lang.String)") //要像这样使用 within 先匹配到某个具体的类，在使用args匹配到某个类型参数的方法</code></pre> 
<p><strong>       2.@args：</strong>匹配切入点方法上的参数的类上，参数的类必须要有指定的注解<br>           <strong>语法：@args(annotation-type)  </strong> annotation-type：注解类型的全路径<br><strong>          注意：</strong>也不能单独使用，必须先指定到类，而且匹配参数个数至少有一个且为第一个参数的类含有该注解才能匹配的上<br>           <strong>示例：</strong></p> 
<pre><code class="language-java">@Pointcut("within(com.demo.RedisTest) &amp;&amp; @args(com.demo.aaa.annotation.MyAnnotation)")</code></pre> 
<p>    <strong>    3.<code>within:</code></strong>匹配切入点的指定类的任意方法，不能匹配接口。<br>          <strong>语法：within(declaring-type)   </strong>参数为全路径的类名（可使用通配符），表示匹配当前表达式的所有类都将被当前方法环绕<br>          <strong>注意： </strong>这个是指定到具体的类<br>      <strong>    示例：</strong></p> 
<pre><code class="language-java">//within表达式的粒度为类，其参数为全路径的类名（可使用通配符），表示匹配当前表达式的所有类都将被当前方法环绕。如下是within表达式的语法：
@Pointcut(within(declaring-type-pattern))

//within表达式只能指定到类级别，如下示例表示匹配com.spring.service.BusinessObject中的所有方法：
@Pointcut(within(com.spring.service.BusinessObject))
      
//within表达式路径和类名都可以使用通配符进行匹配，比如如下表达式将匹配com.spring.service包下的所有类，不包括子包中的类：
@Pointcut(within(com.spring.service.*))

//如下表达式表示匹配com.spring.service包及子包下的所有类：
@Pointcut(within(com.spring.service..*))
</code></pre> 
<p><strong>        4.<code>@within:</code></strong>表示匹配带有指定注解的类。<br>        <strong>  语法：@within(annotation-type)   </strong>注解的全类名<br>         <strong> 注意：</strong>这个是指定到带有某个注解的类<br><strong>         示例：</strong></p> 
<pre><code class="language-java">//如下所示示例表示匹配使用com.spring.annotation.BusinessAspect注解标注的类：

@within(com.spring.annotation.BusinessAspect)</code></pre> 
<p><strong>        5.@annotation() :</strong>匹配带有指定注解的连接点<br>         <strong> 语法：</strong>@annotation(annotation-type)  annotation-type：注解类型的全路径<br>          示例：</p> 
<pre><code class="language-java">@Pointcut("@annotation(com.test.annotations.LogAuto)")</code></pre> 
<p><strong>         6.execution() </strong>用于匹配是连接点的执行方法<strong>,</strong>Spring 切面粒度最小是达到方法级别，而 execution 表达式可以用于明确指定方法返回类型，类名，方法名和参数名等与方法相关的配置，所以是使用最广泛的。<br>        <strong> 用法：</strong></p> 
<ul><li>modifiers-pattern：方法的可见性修饰符，如 public，protected，private；</li><li>ret-type-pattern：方法的返回值类型，如 int，void 等；</li><li>declaring-type-pattern：方法所在类的全路径名，如 com.spring.Aspect；</li><li>name-pattern：方法名，如 getOrderDetail()；</li><li>param-pattern：方法的参数类型，如 java.lang.String；</li><li>throws-pattern：方法抛出的异常类型，如 java.lang.Exception；</li></ul> 
<p><strong>        示例：</strong></p> 
<pre><code class="language-java">modifiers-pattern：方法的可见性修饰符，如 public，protected，private；
ret-type-pattern：方法的返回值类型，如 int，void 等；
declaring-type-pattern：方法所在类的全路径名，如 com.spring.Aspect；
name-pattern：方法名，如 getOrderDetail()；
param-pattern：方法的参数类型，如 java.lang.String；
throws-pattern：方法抛出的异常类型，如 java.lang.Exception；
示例：

// 匹配目标类的所有 public 方法，第一个 * 代表返回类型，第二个 * 代表方法名，..代表方法的参数
execution(public * *(..))

// 匹配目标类所有以 User 为后缀的方法。第一个 * 代表返回类型，*User 代表以 User 为后缀的方法
execution(* *User(..))

// 匹配 User 类里的所有方法
execution(* com.test.demo.User.*(..))

// 匹配 User 类及其子类的所有方法
execution(* com.test.demo.User+.*(..)) :

// 匹配 com.test 包下的所有类的所有方法
execution(* com.test.*.*(..))

// 匹配 com.test 包下及其子孙包下所有类的所有方法
execution(* com.test..*.*(..)) :

// 匹配 getOrderDetail 方法，且第一个参数类型是 Long，第二个参数类型是 String
execution(* getOrderDetail(Long, String))
</code></pre> 
<h4>六、切面中获取各个参数</h4> 
<p>示例：</p> 
<pre><code class="language-java">   @Around(value = "@annotation(basisLogAnnotation)")
    public Object demoAop(ProceedingJoinPoint proceedingJoinPoint, final BasisLogAnnotation basisLogAnnotation) throws Throwable {
 
        logger.debug("执行前：");
 
        Object object = proceedingJoinPoint.proceed();  //执行连接点方法，object：方法返回值
 
        logger.debug("执行后：");
 
 
        // 类名
        String className = proceedingJoinPoint.getTarget().getClass().getName();
        //方法名
        String methodName = proceedingJoinPoint.getSignature().getName();
        //参数（我这里是对象，具体根据个人的参数类型来强转）
        BasisUser basisUser = (BasisUser)proceedingJoinPoint.getArgs()[0];
        return object;
    }</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f8e441474c2cb90b6fe09bdff7dfea31/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">探索Spark-MovieLens：基于大数据的电影推荐系统实践</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/75cba2ee23ca1b7b4b73eb503c0f000c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">1.Flink1.19、Flink1.18源码编译及本地运行</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>