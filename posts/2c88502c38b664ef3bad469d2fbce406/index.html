<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构_查找 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/2c88502c38b664ef3bad469d2fbce406/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="数据结构_查找">
  <meta property="og:description" content="目录
1. 查找的基本概念
2. 顺序查找和折半查找
2.1 顺序查找
2.1.1 一般线性表的顺序查找
2.1.2 有序表的顺序查找
2.2 折半查找
2.3 分块查找
2.4 相关练习
3. 树型查找 3.1 二叉排序树
3.1.1 二叉排序树的定义
3.1.2 二叉排序树的查找
3.1.3 二叉排序树的插入
3.1.4 二叉排序树的构造
3.1.5 二叉排序树的删除
3.1.6 二叉排序树的查找效率分析
3.2 平衡二叉树
3.2.1 平衡二叉树的定义
3.2.2 平衡二叉树的插入
3.2.3 平衡二叉树的删除
3.2.4 平衡二叉树的查找
4. 红黑树
4.1 红黑树的定义
4.2 红黑树的插入
4.3 红黑树的删除
4.4 相关练习
5. B 树和 B&#43; 树
5.1 B 树及其基本操作
5.1.1 B 树的高度（磁盘存取次数）
5.1.2 B 树的查找
5.1.3 B 树的插入">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-05-18T22:05:30+08:00">
    <meta property="article:modified_time" content="2023-05-18T22:05:30+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构_查找</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" src="https://images2.imgbox.com/2a/bf/s6P3kfbu_o.gif"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%20%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#1.%20%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">1. 查找的基本概念</a></p> 
<p id="2.%20%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE-toc" style="margin-left:0px;"><a href="#2.%20%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE" rel="nofollow">2. 顺序查找和折半查找</a></p> 
<p id="2.1%20%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE-toc" style="margin-left:40px;"><a href="#2.1%20%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE" rel="nofollow">2.1 顺序查找</a></p> 
<p id="2.1.1%20%E4%B8%80%E8%88%AC%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE-toc" style="margin-left:80px;"><a href="#2.1.1%20%E4%B8%80%E8%88%AC%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE" rel="nofollow">2.1.1 一般线性表的顺序查找</a></p> 
<p id="2.1.2%20%E6%9C%89%E5%BA%8F%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE-toc" style="margin-left:80px;"><a href="#2.1.2%20%E6%9C%89%E5%BA%8F%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE" rel="nofollow">2.1.2 有序表的顺序查找</a></p> 
<p id="2.2%20%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE-toc" style="margin-left:40px;"><a href="#2.2%20%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE" rel="nofollow">2.2 折半查找</a></p> 
<p id="%C2%A02.3%20%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE-toc" style="margin-left:40px;"><a href="#%C2%A02.3%20%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE" rel="nofollow">2.3 分块查找</a></p> 
<p id="2.4%20%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0-toc" style="margin-left:40px;"><a href="#2.4%20%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0" rel="nofollow">2.4 相关练习</a></p> 
<p id="3.%20%E6%A0%91%E5%9E%8B%E6%9F%A5%E6%89%BE%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0-toc" style="margin-left:0px;"><a href="#3.%20%E6%A0%91%E5%9E%8B%E6%9F%A5%E6%89%BE%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0" rel="nofollow">3. 树型查找        </a></p> 
<p id="3.1%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91-toc" style="margin-left:40px;"><a href="#3.1%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91" rel="nofollow">3.1 二叉排序树</a></p> 
<p id="3.1.1%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:80px;"><a href="#3.1.1%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">3.1.1 二叉排序树的定义</a></p> 
<p id="3.1.2%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE-toc" style="margin-left:80px;"><a href="#3.1.2%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE" rel="nofollow">3.1.2 二叉排序树的查找</a></p> 
<p id="3.1.3%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5-toc" style="margin-left:80px;"><a href="#3.1.3%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5" rel="nofollow">3.1.3 二叉排序树的插入</a></p> 
<p id="3.1.4%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0-toc" style="margin-left:80px;"><a href="#3.1.4%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0" rel="nofollow">3.1.4 二叉排序树的构造</a></p> 
<p id="3.1.5%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4-toc" style="margin-left:80px;"><a href="#3.1.5%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4" rel="nofollow">3.1.5 二叉排序树的删除</a></p> 
<p id="3.1.6%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#3.1.6%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90" rel="nofollow">3.1.6 二叉排序树的查找效率分析</a></p> 
<p id="3.2%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:40px;"><a href="#3.2%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">3.2 平衡二叉树</a></p> 
<p id="3.2.1%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:80px;"><a href="#3.2.1%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">3.2.1 平衡二叉树的定义</a></p> 
<p id="3.2.2%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5-toc" style="margin-left:80px;"><a href="#3.2.2%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5" rel="nofollow">3.2.2 平衡二叉树的插入</a></p> 
<p id="3.2.3%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4-toc" style="margin-left:80px;"><a href="#3.2.3%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4" rel="nofollow">3.2.3 平衡二叉树的删除</a></p> 
<p id="3.2.4%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE-toc" style="margin-left:80px;"><a href="#3.2.4%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE" rel="nofollow">3.2.4 平衡二叉树的查找</a></p> 
<p id="4.%20%E7%BA%A2%E9%BB%91%E6%A0%91-toc" style="margin-left:0px;"><a href="#4.%20%E7%BA%A2%E9%BB%91%E6%A0%91" rel="nofollow">4. 红黑树</a></p> 
<p id="4.1%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#4.1%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">4.1 红黑树的定义</a></p> 
<p id="4.2%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5-toc" style="margin-left:40px;"><a href="#4.2%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5" rel="nofollow">4.2 红黑树的插入</a></p> 
<p id="4.3%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4-toc" style="margin-left:40px;"><a href="#4.3%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4" rel="nofollow">4.3 红黑树的删除</a></p> 
<p id="4.4%20%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0-toc" style="margin-left:40px;"><a href="#4.4%20%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0" rel="nofollow">4.4 相关练习</a></p> 
<p id="5.%20B%20%E6%A0%91%E5%92%8C%20B%2B%20%E6%A0%91-toc" style="margin-left:0px;"><a href="#5.%20B%20%E6%A0%91%E5%92%8C%20B%2B%20%E6%A0%91" rel="nofollow">5. B 树和 B+ 树</a></p> 
<p id="5.1%20B%20%E6%A0%91%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#5.1%20B%20%E6%A0%91%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C" rel="nofollow">5.1 B 树及其基本操作</a></p> 
<p id="5.1.1%20B%20%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6%EF%BC%88%E7%A3%81%E7%9B%98%E5%AD%98%E5%8F%96%E6%AC%A1%E6%95%B0%EF%BC%89-toc" style="margin-left:80px;"><a href="#5.1.1%20B%20%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6%EF%BC%88%E7%A3%81%E7%9B%98%E5%AD%98%E5%8F%96%E6%AC%A1%E6%95%B0%EF%BC%89" rel="nofollow">5.1.1 B 树的高度（磁盘存取次数）</a></p> 
<p id="5.1.2%20B%20%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE-toc" style="margin-left:80px;"><a href="#5.1.2%20B%20%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE" rel="nofollow">5.1.2 B 树的查找</a></p> 
<p id="5.1.3%20B%20%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5-toc" style="margin-left:80px;"><a href="#5.1.3%20B%20%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5" rel="nofollow">5.1.3 B 树的插入</a></p> 
<p id="5.1.4%20B%20%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4-toc" style="margin-left:80px;"><a href="#5.1.4%20B%20%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4" rel="nofollow">5.1.4 B 树的删除</a></p> 
<p id="5.2%20B%2B%20%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#5.2%20B%2B%20%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">5.2 B+ 树的基本概念</a></p> 
<p id="5.3%20%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0-toc" style="margin-left:40px;"><a href="#5.3%20%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0" rel="nofollow">5.3 相关练习</a></p> 
<p id="6.%20%E6%95%A3%E5%88%97%E8%A1%A8-toc" style="margin-left:0px;"><a href="#6.%20%E6%95%A3%E5%88%97%E8%A1%A8" rel="nofollow">6. 散列表</a></p> 
<p id="6.1%20%E6%95%A3%E5%88%97%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#6.1%20%E6%95%A3%E5%88%97%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">6.1 散列表的基本概念</a></p> 
<p id="6.2%20%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#6.2%20%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95" rel="nofollow">6.2 散列函数的构造方法</a></p> 
<p id="6.2.1%20%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E6%B3%95-toc" style="margin-left:80px;"><a href="#6.2.1%20%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E6%B3%95" rel="nofollow">6.2.1 直接定址法</a></p> 
<p id="6.2.2%20%E9%99%A4%E7%95%99%E4%BD%99%E6%95%B0%E6%B3%95-toc" style="margin-left:80px;"><a href="#6.2.2%20%E9%99%A4%E7%95%99%E4%BD%99%E6%95%B0%E6%B3%95" rel="nofollow">6.2.2 除留余数法</a></p> 
<p id="6.2.3%20%E6%95%B0%E5%AD%97%E5%88%86%E6%9E%90%E6%B3%95-toc" style="margin-left:80px;"><a href="#6.2.3%20%E6%95%B0%E5%AD%97%E5%88%86%E6%9E%90%E6%B3%95" rel="nofollow">6.2.3 数字分析法</a></p> 
<p id="6.2.4%20%E5%B9%B3%E6%96%B9%E5%8F%96%E4%B8%AD%E6%B3%95-toc" style="margin-left:80px;"><a href="#6.2.4%20%E5%B9%B3%E6%96%B9%E5%8F%96%E4%B8%AD%E6%B3%95" rel="nofollow">6.2.4 平方取中法</a></p> 
<p id="6.3%20%E5%A4%84%E7%90%86%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#6.3%20%E5%A4%84%E7%90%86%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95" rel="nofollow">6.3 处理冲突的方法</a></p> 
<p id="6.3.1%20%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%B3%95-toc" style="margin-left:80px;"><a href="#6.3.1%20%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%B3%95" rel="nofollow">6.3.1 开放定址法</a></p> 
<p id="6.3.2%20%E6%8B%89%E9%93%BE%E6%B3%95%EF%BC%88chaining%EF%BC%89-toc" style="margin-left:80px;"><a href="#6.3.2%20%E6%8B%89%E9%93%BE%E6%B3%95%EF%BC%88chaining%EF%BC%89" rel="nofollow">6.3.2 拉链法（chaining）</a></p> 
<p id="6.4%20%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#6.4%20%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90" rel="nofollow">6.4 散列查找及性能分析</a></p> 
<p id="6.5%20%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0-toc" style="margin-left:40px;"><a href="#6.5%20%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0" rel="nofollow">6.5 相关练习</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p class="img-center"><img alt="" height="450" src="https://images2.imgbox.com/c1/c0/eEOQHQqZ_o.png" width="598"></p> 
<h2 id="1.%20%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span style="color:#956fe7;"><strong>1. 查找的基本概念</strong></span></h2> 
<p><span style="color:#fe2c24;"><strong>查找</strong></span>：<span style="color:#0d0016;"><strong>在数据集合中寻找满足某种条件的数据元素的过程称为</strong></span><span style="color:#fe2c24;"><strong>查找</strong></span>。查找的结果一般分为两种：一是<span style="color:#fe2c24;"><strong>查找成功</strong></span>，<span style="color:#0d0016;"><strong>即在数据集合中找到了满足条件的数据元素</strong></span>；而是<span style="color:#fe2c24;"><strong>查找失败</strong></span>。</p> 
<p><span style="color:#fe2c24;"><strong>查找表(查找结构)</strong></span>：<span style="color:#0d0016;"><strong>用于查找的数据集合称为</strong></span><span style="color:#fe2c24;"><strong>查找表</strong></span>，它由同一类型的数据元素组成，可以是一个数组或链表等数据类型。对查找表经常进行的操作一般有4种：</p> 
<p>       <span style="color:#0d0016;"><strong> ①：查询某个特定的数据元素是否在查找表中；</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        ②：检索满足条件的某个特定的数据元素的各种属性；</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        ③：在查找表中插入一个数据元素；</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        ④：从查找表中删除某个数据元素；</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>静态查找表</strong></span>：<span style="color:#0d0016;"><strong>若一个查找表的操作只涉及上述操作的①和②，则无须动态地修改查找表，此类查找表称为</strong></span><span style="color:#fe2c24;"><strong>静态查找表</strong></span>。与此对应，<span style="color:#0d0016;"><strong>需要动态的插入或删除的查找表称为</strong></span><span style="color:#fe2c24;"><strong>动态查找表</strong></span>。适合<span style="color:#fe2c24;"><strong>静态查找表的的查找方法</strong></span>有<span style="color:#0d0016;"><strong>顺序查找、折半查找、散列查找</strong></span>等；适合<span style="color:#fe2c24;"><strong>动态查找表的查找方法</strong></span>有<span style="color:#0d0016;"><strong>二叉排序树的查找、散列查找</strong></span>等。二叉平衡树和B树都是二叉排序树的改进。</p> 
<p><span style="color:#fe2c24;"><strong>关键字</strong></span>：<span style="color:#0d0016;"><strong>数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的</strong></span>。例如，在由一个学生元素构成的数据集合中，学生元素中 “学号” 这一数据项的值唯一地标识一名学生。</p> 
<p><span style="color:#fe2c24;"><strong>平均查找长度</strong></span>：在查找过程中，<span style="color:#0d0016;"><strong>一次查找的长度是指需要比较的关键字次数</strong></span>，而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值，其数学定义为</p> 
<p class="img-center"><img alt="" height="100" src="https://images2.imgbox.com/43/ce/HGLzOSca_o.png" width="1200"></p> 
<p>        其中，n 是查找表的长度；<img alt="P_{i}" class="mathcode" src="https://images2.imgbox.com/1e/18/rDdpmLOV_o.png"> 是查找第 i 个数据元素的概率，一般认为每个数据元素的查找概率相等，即 <img alt="P_{i}" class="mathcode" src="https://images2.imgbox.com/e0/5e/cpT4B5Ii_o.png"> = 1/n；<img alt="C_{i}" class="mathcode" src="https://images2.imgbox.com/9c/37/kbg5OLHM_o.png"> 是找到第 i 个数据元素所需进行的比较次数。平均查找长度是衡量查找算法效率的最主要的指标。</p> 
<h2 id="2.%20%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span style="color:#956fe7;"><strong>2. 顺序查找和折半查找</strong></span></h2> 
<h3 id="2.1%20%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span style="color:#4da8ee;"><strong>2.1 顺序查找</strong></span></h3> 
<p>        <span style="color:#0d0016;"><strong>顺序查找</strong></span>又称为<span style="color:#0d0016;"><strong>线性查找</strong></span>，它对顺序表和链表都是适用的。对于顺序表，可通过数组下标递增来顺序扫描每个元素；对于链表，可通过 next 指针来依次扫描每个元素。<span style="color:#fe2c24;"><strong>顺序查找</strong></span><span style="color:#0d0016;"><strong>通常分为对一般的无序线性表的顺序查找和对按关键字有序的线性表的顺序查找</strong></span>。</p> 
<h4 id="2.1.1%20%E4%B8%80%E8%88%AC%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span style="color:#38d8f0;"><strong>2.1.1 一般线性表的顺序查找</strong></span></h4> 
<p>        作为一种最直观的查找方法，<span style="color:#0d0016;"><strong>其基本思想是从线性表的一端开始，逐个检查关键字是否满足给定的条件</strong></span>。若查找到某个元素的关键字满足给定的条件，则查找成功，返回该元素在线性表中的位置；若已经查找到表的另一端，但还没有查找到符合给定条件的元素，则返回查找失败的信息。</p> 
<pre><code>typedef struct  //查找表的数据结构
{
    ElemType *elem； //元素存储空间基址，建表时按实际长度分配，0号单元留空
    int TableLen；   //表的长度        
}SSTable；

int Search_Seq(SSTable ST，ElemType key)
{
    ST.elem[0]=key；  //哨兵
    for(i=ST.TableLen；ST.elem[i]！=key；--i)；   //从后往前找
    return i； //若表中不存在关键字为 key 的元素，将查找到 i 为 0 时退出 for 循环
}

//在上述的算法中，将ST.elem[0]=key称作哨兵。引入它的目的是使得 Search_Seq内循环不必判断数组是否越界，因为满足 i==0 时，循环一定会跳出。
这是因为初始化 ST.elem[0]=key ，当 i 减至 0 时，判断语句一定会成立。</code></pre> 
<p>       <span style="color:#0d0016;"><strong> 对于 n 个元素的表，给定值 key 与表中第 i 个元素相等，即定位第 i 个元素时，需进行 n-i+1 次关键字的比较（之所以是 n-i+1 次，是因为算法规定从后往前进行查找，n-i 表示减去前面已经扫描过的关键字，+1 表示数组下标），即 <img alt="C_{i}" class="mathcode" src="https://images2.imgbox.com/09/d0/VZzv3NZ1_o.png"> = n - i + 1。查找成功时，顺序查找的平均长度为</strong></span></p> 
<p class="img-center"><img alt="" height="100" src="https://images2.imgbox.com/62/b2/RkwA45et_o.png" width="699"></p> 
<p><span style="color:#0d0016;"><strong>        当每个元素的查找概率相等，即 <img alt="P_{i}" class="mathcode" src="https://images2.imgbox.com/db/f8/huFaQKIL_o.png"> =1 / n 时，有</strong></span></p> 
<p class="img-center"><img alt="" height="100" src="https://images2.imgbox.com/9b/8c/GHGfWLQX_o.png" width="1034"></p> 
<p>       <span style="color:#0d0016;"><strong> 查找不成功时，与表中各关键字的比较次数显然是 n+1 次，从而顺序查找不成功的平均查找长度为 <img alt="ASL_{Default}" class="mathcode" src="https://images2.imgbox.com/85/38/kGRI17js_o.png"> = n + 1 </strong></span></p> 
<p><span style="color:#0d0016;"><strong>        通常，查找表中记录的查找概率并不相同。若能预先得知每个记录的查找概率，则应先对记录的查找概率进行排序，使表中记录按查找概率由大至小重新排列。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        综上所述，顺序查找的</strong></span><span style="color:#fe2c24;"><strong>缺点</strong></span><span style="color:#0d0016;"><strong>是当 n 较大时，平均查找长度较大，效率低；</strong></span><span style="color:#fe2c24;"><strong>优点</strong></span><span style="color:#0d0016;"><strong>是对数据元素的存储没有要求，顺序存储或链式存储均可。对表中记录的有序性也没有要求，无论记录是否按关键字有序，均可应用。同时还需注意，对线性的链表只能进行顺序查找。</strong></span></p> 
<h4 id="2.1.2%20%E6%9C%89%E5%BA%8F%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span style="color:#38d8f0;"><strong>2.1.2 有序表的顺序查找</strong></span></h4> 
<p><span style="color:#0d0016;"><strong>        若在查找之前就已经知道表示关键字有序的，则查找失败时可以不用再比较到表的另一端就能返回查找失败的信息，从而降低顺序查找失败的平均查找长度。</strong></span></p> 
<p><span style="color:#1c7331;"><strong>        假设表L是按关键字从小到大排列的，查找的顺序是从前往后，待查找元素的关键字为 key，当查找到第 i 个元素时，发现第 i 个元素对应的关键字小于 key，但第 i+1 个元素对应的关键字大于 key ，这时就可返回查找失败的信息，因为第 i 个元素之后的元素的关键字均大于 key ，所以表中不存在关键字为 key 的元素。</strong></span></p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>用下图的</strong></span><span style="color:#fe2c24;"><strong>判定树</strong></span><span style="color:#0d0016;"><strong>来描述有序线性表的查找过程：</strong></span></p> 
 <p>      <span style="color:#0d0016;"><strong>  树中的</strong></span><span style="color:#fe2c24;"><strong>圆形结点</strong></span><span style="color:#0d0016;"><strong>表示有序线性表中存在的元素；树中的</strong></span><span style="color:#fe2c24;"><strong>矩形结点</strong></span><span style="color:#0d0016;"><strong>称为</strong></span><span style="color:#fe2c24;"><strong>失败结点</strong></span><span style="color:#0d0016;"><strong>（若有 n 个结点，则相应的有 n+1 个查找失败的结点</strong></span><span style="color:#0d0016;"><strong>），它描述的是那些不在表中的数据值的集合。若查找到失败结点，则说明查找不成功。</strong></span></p> 
 <p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/a2/44/19p6h8O1_o.png" width="831"></p> 
 <p>        <span style="color:#0d0016;"><strong>在有序线性表的顺序查找中，查找成功的平均查找长度和一般线性表的顺序查找一样。查找失败时，查找结点一定走到了某个失败结点。这些失败结点是我们虚构的空结点，实际上是不存在的，所以到达失败结点时所查找的长度等于它上面的一个圆形结点的所在层数。查找不成功的平均查找长度在相等查找概率的情形下为</strong></span></p> 
 <p class="img-center"><img alt="" height="100" src="https://images2.imgbox.com/e5/37/m3FMndOI_o.png" width="829"></p> 
 <p>      <span style="color:#0d0016;"><strong>  式中，<img alt="q_{j}" class="mathcode" src="https://images2.imgbox.com/d2/88/aunFZwyj_o.png"> 是到达第 j 个失败结点的概率，在相等查找概率的情形下，它为 1/(n+1)；<img alt="l_{j}" class="mathcode" src="https://images2.imgbox.com/ce/7f/IQKsjC2W_o.png"> 是第 j 个失败结点所在的层数。当 n = 6时，</strong></span><img alt="" height="46" src="https://images2.imgbox.com/37/6a/9pjlc0HD_o.png" width="398"></p> 
</blockquote> 
<h3 id="2.2%20%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span style="color:#4da8ee;"><strong>2.2 折半查找</strong></span></h3> 
<p><span style="color:#0d0016;"><strong>        </strong></span><span style="color:#fe2c24;"><strong>折半查找</strong></span><span style="color:#0d0016;"><strong>又称为</strong></span><span style="color:#fe2c24;"><strong>二分查找</strong></span><span style="color:#0d0016;"><strong>，它是适用于有序的顺序表。（相信下C语言的学习中，已经学习过用二分法查找数组中某个元素了）</strong></span></p> 
<p>        <span style="color:#fe2c24;"><strong>折半查找的基本思想</strong></span><span style="color:#1c7331;"><strong>：首先将给定值 key 与表中中间位置的元素进行比较，若相等，则查找成功，返回该元素的存储位置；若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分（例如，在查找表升序排列时，若给定值key大于中间元素，则所查找的元素只可能在后半部分</strong></span><span style="color:#1c7331;"><strong>）。然后在缩小的范围内继续进行同样的查找，如此重复，直到找到为止，或确定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息。</strong></span></p> 
<pre><code>int Binary_Search(SeqList L,ElemType key)
{
    int low=0,high=L.TableLen-1,mid;
    while(low&lt;=high)
    {
        mid=(low+high)/2;  //取中间位置
        if(L.elem[mid]==key)
        {
            return mid;   //恰好中间位置就是所要找的元素，返回中间位置对应的元素
        }    
        else if(L.elem[mid]&gt;key)
        {
            high=mid-1; //从前半部分继续查找
        }
        else
        {
            low=mid+1;  //从后部分继续查找
        }
    }
    return -1；  //查找失败，返回-1
}</code></pre> 
<pre><code>//接下来通过一个具体的二分查找来讲解二分查找具体的过程，我们分别查找11和32
int main()
{
	int arr[] = { 7, 10, 13, 16, 19, 29, 32, 33, 37, 41, 43 };//初始化数组，显然11不存在，32存在，我们规定：若找到，则返回对应数组的下角标；否则返回-1
	int sz = sizeof(arr) / sizeof(arr[0]);  //计算数组中所含元素的个数
	int i = 0;
	int k = 11;
	int l = 32;
	int left = 0; //对应二分查找，指向数组中第一个元素
	int right = sz - 1; //对应二分查找，指向数组最后一个元素，sz-1 是要以下标的方式进行表示
	while (left &lt;= right)
	{
		int mid = (left + right) / 2; //定义二分查找的中间值
		if (arr[mid] &gt; l) //中间值大于你要找的元素，意味着要找的元素位于前半部分
		{
			right = mid - 1; //修改右边界，缩小整体的范围
		}
		else if (arr[mid] &lt; l) //中间值小于你要找的元素，意味着要找的元素位于后半部分
		{
			left = mid + 1; //修改左边界，缩小整体的范围
		}
		else //否则意味着随着范围的缩小，找到了所要找的值
		{
			printf("找到了，下角标为%d ", mid); //打印下角标，结束
			break;
		}
	}
	if (left &gt; right)
	{
		return -1;
	}
	return 0;
}</code></pre> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>折半查找的过程可用下图所示的二叉树来描述，称为</strong></span><span style="color:#fe2c24;"><strong>判定树</strong></span></p> 
 <p>       <span style="color:#1c7331;"><strong> 树中，每个圆形结点表示一个记录，结点中的值为该记录的关键字值；树中最下面的叶结点都是方形的，它表示查找不成功的情况。从判定树可以看出，查找成功时的查找长度为从根结点到目的结点的路径上的结点数，查找不成功时的查找长度为从根结点到对应失败结点的父结点的路径上的结点数；每个结点值均大于其左孩子结点值，均小于其右孩子结点值。</strong></span></p> 
 <p><span style="color:#1c7331;"><strong>        若有序序列有 n 个元素，则对应的判定树有 n 个圆形的非叶结点和 n+1 个方形的叶结点。</strong></span></p> 
 <p><span style="color:#1c7331;"><strong>        显然，判定树是一个平衡二叉树（也就是任意结点的左孩子和右孩子的高度不超过1，或者是说平衡因子不超过1）。</strong></span></p> 
 <p class="img-center"><img alt="" height="450" src="https://images2.imgbox.com/e8/57/c5X2TEFW_o.png" width="1053"></p> 
</blockquote> 
<p><span style="color:#0d0016;"><strong>        由上述分析可知，用折半查找法查找到给定值的比较次数最多不会超过树的高度。在等概率查找时，查找成功的平均查找长度为</strong></span></p> 
<p class="img-center"><img alt="" height="100" src="https://images2.imgbox.com/12/fd/B7GMtbfx_o.png" width="1181"></p> 
<p><span style="color:#0d0016;"><strong>        式中，h 是树的高度，并且元素个数为 n 时树高为 h = <img alt="log_{2}" class="mathcode" src="https://images2.imgbox.com/b4/44/gX0O7cM2_o.png">(n+1) 。所以，折半查找的时间复杂度为 O( <img alt="log_{2}" class="mathcode" src="https://images2.imgbox.com/5d/5f/hyrDF6fV_o.png">n)，平均情况下比顺序查找的效率高。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        </strong></span><span style="color:#fe2c24;"><strong>因为折半查找需要方便的定位查找区域，所以它要求线性表必须具有随机存取的特性。因此，该查找法仅适合于顺序存储结构，不适合于链式存取结构，且要求元素按关键字有序排列。</strong></span></p> 
<h3 id="%C2%A02.3%20%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE"><span style="color:#4da8ee;"><strong>2.3 分块查找</strong></span></h3> 
<p>        <span style="color:#fe2c24;"><strong>分块查找</strong></span><span style="color:#0d0016;"><strong>又称为</strong></span><span style="color:#fe2c24;"><strong>索引顺序查找</strong></span>，它吸收了顺序查找和折半查找各自的优点，既有动态结构，又适于快速查找。</p> 
<p>       <span style="color:#fe2c24;"><strong> 分块查找的基本思想</strong></span><span style="color:#1c7331;"><strong>：将查找块分为若干字块。块内的元素可以无序，但块之间是有序的，即第一个块中的最大关键字小于第二个块中的所有记录的关键字，第二个块中的最大关键字小于第三个块中的所有记录的关键字，以此类推。再建立一个索引表，索引表中的每个元素含有各块的最大关键字和各块中的第一个元素的地址，索引表按关键字有序排列。</strong></span></p> 
<p><span style="color:#1c7331;"><strong>        </strong></span><span style="color:#fe2c24;"><strong>分块查找的过程分为两步</strong></span><span style="color:#1c7331;"><strong>：第一步在索引表中确定待查记录所在的块，可以顺序查找或折半查找索引表；第二步是在块中顺序查找。</strong></span></p> 
<p class="img-center"><img alt="" height="350" src="https://images2.imgbox.com/e5/33/LlHs7pL1_o.png" width="1185"></p> 
<p>        <strong><span style="color:#0d0016;">分块查找的平均查找长度为索引查找和块内查找的平均长度之和。设索引查找和块内查找的平均查找长度分别为 <img alt="L_{1}" class="mathcode" src="https://images2.imgbox.com/6f/9c/3NjfQymX_o.png">，<img alt="L_{s}" class="mathcode" src="https://images2.imgbox.com/56/05/BDfvLgC7_o.png">，则分块查找的平均查找长度为</span></strong></p> 
<p style="text-align:center;"><strong><span style="color:#0d0016;">ASL=<img alt="L_{1}" class="mathcode" src="https://images2.imgbox.com/b4/8b/uJZNxGjn_o.png"> + <img alt="L_{s}" class="mathcode" src="https://images2.imgbox.com/36/96/gDjAXbcw_o.png"></span></strong></p> 
<p><span style="color:#0d0016;"><strong>         将长度为 n 的查找表均匀的分为 b 块，每块有 s 个记录，在等概率情况下，若在块内和索引表中均采用顺序查找，则平均查找长度为</strong></span></p> 
<p class="img-center"><img alt="" height="100" src="https://images2.imgbox.com/19/c3/W4QjBpnP_o.png" width="799"></p> 
<h3 id="2.4%20%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0"><span style="color:#4da8ee;"><strong>2.4 相关练习</strong></span></h3> 
<p><span style="color:#0d0016;"><strong>1. 顺序查找适合于存储结构为 </strong></span><span style="color:#fe2c24;"><strong>顺序存储结构或链式存储结构</strong></span><span style="color:#0d0016;"><strong> 的线性表。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>2. 对长度为 n 的有序单链表，若查找每个元素的概率相等，则顺序查找表中任一元素的查找成功的平均查找长度为 </strong></span><span style="color:#fe2c24;"><strong>(n+1)/2</strong></span><span style="color:#0d0016;"><strong>。</strong></span></p> 
<p class="img-center"><img alt="" height="480" src="https://images2.imgbox.com/b6/a6/KPj4Bv5F_o.png" width="1200"></p> 
<p class="img-center"><img alt="" height="700" src="https://images2.imgbox.com/49/13/fCI6sju8_o.png" width="1200"></p> 
<p class="img-center"><img alt="" height="800" src="https://images2.imgbox.com/c2/e2/7zmaHpvt_o.png" width="1200"></p> 
<h2 id="3.%20%E6%A0%91%E5%9E%8B%E6%9F%A5%E6%89%BE%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0"><span style="color:#956fe7;"><strong>3. 树型查找        </strong></span></h2> 
<h3 id="3.1%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span style="color:#4da8ee;"><strong>3.1 二叉排序树</strong></span></h3> 
<h4 id="3.1.1%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span style="color:#38d8f0;"><strong>3.1.1 二叉排序树的定义</strong></span></h4> 
<p>        <span style="color:#0d0016;"><strong>二叉排序树</strong></span>也称为<span style="color:#0d0016;"><strong>二叉查找树</strong></span>，或者是一颗空树，又或者是具有以下特性的二叉树：</p> 
<p><span style="color:#0d0016;"><strong>        1. 若左子树非空，则左子树上所有结点的值均小于根结点的值。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        2. 若右子树非空，则右子树上所有结点的值均大于根结点的值。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        3. 左、右子树也分别是一棵二叉排序树。</strong></span></p> 
<p class="img-center"><img alt="" height="250" src="https://images2.imgbox.com/2f/f2/ijua53E1_o.png" width="278"></p> 
<p>        根据对二叉树的定义，<span style="color:#0d0016;"><strong>左子树结点值 &lt; 根结点值 &lt; 右子树结点值</strong></span>，所以<span style="color:#1c7331;"><strong>对二叉树进行中序遍历，可以得到一个递增的有序序列。</strong></span></p> 
<h4 id="3.1.2%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE"><span style="color:#38d8f0;"><strong>3.1.2 二叉排序树的查找</strong></span></h4> 
<p>        <span style="color:#fe2c24;"><strong>算法思想：</strong></span><span style="color:#0d0016;"><strong>二叉排序树的查找是从根结点开始，沿某个分支逐层向下比较的过程。若二叉排序树非空，先将给定值与根结点的关键字比较，若相等，则查找成功；若不等，如果小于根结点的关键字，则在根结点的左子树上查找，否则在根结点的右子树上查找。</strong></span></p> 
<pre><code>//二叉排序树的非递归查找算法

BSTNode *BST_Search(BiTree T,ElemType key)
{
    while(T!=NULL&amp;&amp;key!=T-&gt;data) //若树空或等于根结点值，则结束循环
    {
        if(key&lt;T-&gt;data)  //小于，则在左子树上查找
            T=T-&gt;lchild; 
        else
            T=T-&gt;rchild; //大于，则在右子树上查找
    }
 return T;
}</code></pre> 
<p>举个例子：上图二叉排序树中查找4；首先 4 和根结点进行比较，4&lt;6，去左子树查找，4和2进行比较，4&gt;2，去右子树进行查找，查找成功；</p> 
<h4 id="3.1.3%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span style="color:#38d8f0;"><strong>3.1.3 二叉排序树的插入</strong></span></h4> 
<p>        二叉排序树作为一种动态数表，其特点是树的结构通常不是一次生成的，而是在查找的过程中，当树中不存在关键字值等于给定值的结点时再进行插入的。</p> 
<p>        <span style="color:#0d0016;"><strong>插入结点的过程如下</strong></span>：若原二叉排序树为空，则直接插入结点；否则，若关键字 k 小于根结点值，则插入到左子树，若关键字 k 大于根结点值，则插入到右子树。插入的结点一定是一个新添加的叶结点，并且是查找失败时的查找路径上访问的最后一个结点的左孩子或右孩子。</p> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/d2/6e/DQbYTddl_o.png" width="1009"></p> 
<pre><code>//二叉排序树的插入操作算法如下：

int BST_Insert(BiTree &amp;T,KeyType k)
{
    if(T==NULL)  //原树为空，新插入的结点为根结点
    {
        T=(BiTree)malloc(sizeof(BSTNode));
        T-&gt;data=k;
        T-&gt;lchild=T-&gt;rchild=NULL;
        return 1;   //返回，插入成功
    }
    else if(k==T-&gt;data)  //树中存在相同关键字的结点，插入失败
    {
        return 0;
    }
    else if(k&lt;T-&gt;data)  //插入到T的左子树
    {
        return BST_Insert(T-&gt;lchild,k)
    }
    else //插入到T的右子树
    {
        return BST_Insert(T-&gt;rchild,k)
    }
}</code></pre> 
<h4 id="3.1.4%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0"><span style="color:#38d8f0;"><strong>3.1.4 二叉排序树的构造</strong></span></h4> 
<p><span style="color:#0d0016;"><strong>        从一颗空树出发，依次输入元素，将它们插入到二叉排序树中的合适位置</strong></span>。设查找的关键字序列为{45,24,53,45,12,24}</p> 
<p class="img-center"><img alt="" height="250" src="https://images2.imgbox.com/d5/fb/Xg0kyxxt_o.png" width="958"></p> 
<pre><code>//构造二叉排序树的算法

void Creat_BST(BisTree &amp;T, KeyType str[],int n)
{
    T=NULL; //初始化 T 为空树
    int i=0;
    while(i&lt;n)  //依次将每个关键字插入到二叉排序树中
    {
        BST_Insert(T，str[i]);
        i++;
    }        
}</code></pre> 
<h4 id="3.1.5%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4"><span style="color:#38d8f0;"><strong>3.1.5 二叉排序树的删除</strong></span></h4> 
<p><span style="color:#0d0016;"><strong>        在二叉排序树中删除一个结点时，不能把以该结点为根的子树上的结点都删除，必须先把被删除结点从存储二叉排序树的链表上摘下，将因删除结点而断开的二叉链表重新链接起来，同时确保二叉排序树的性质不会丢失。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>①：若被删除结点 z 是叶结点，则直接删除，不会破坏二叉排序树的性质。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>②：若结点 z 只有一个左子树或者右子树，则让 z 的子树成为 z 父结点的子树，代替 z 的位置。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>③：若结点 z 有左、右两棵子树，则令 z 的直接后继（或直接前驱）代替 z，然后从二叉排序树中删除这个直接前驱（或直接后继），转换成第一、第二种情况。</strong></span></p> 
<p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/e0/4d/w2qBKVQd_o.png" width="486"></p> 
<h4 id="3.1.6%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90"><span style="color:#38d8f0;"><strong>3.1.6 二叉排序树的查找效率分析</strong></span></h4> 
<p>        <span style="color:#0d0016;"><strong>二叉排序树的查找效率，主要取决于</strong></span><span style="color:#fe2c24;"><strong>树的高度</strong></span>。<span style="color:#0d0016;"><strong>若二叉排序树的左、右子树的高度之差的绝对值不超过 1，则这样的二叉排序树称为</strong></span><strong>平衡二叉树。</strong><span style="color:#0d0016;">它的平均查找长度为 O（log2n）。若一个二叉排序树是一个只有右 (左) 孩子的单支树，则其平均查找长度为 O(n)。</span></p> 
<p class="img-center"><img alt="" height="350" src="https://images2.imgbox.com/21/a1/hzOOcSn2_o.png" width="780"></p> 
<p>        在等概率的情况下，图7.8 a 的查找成功的平均查找长度为</p> 
<p style="text-align:center;"><strong>ASL=(1*1+2*2+3*4+4*3)/10=2.9</strong></p> 
<p>        图 b 查找成功的平均查找长度为</p> 
<p style="text-align:center;"><strong>ASL=(1+2+3+4+5+6+7+8+9+10)/10=5.5</strong></p> 
<p><strong>        当有序表是<span style="color:#fe2c24;">静态查找表</span>时，宜用<span style="color:#fe2c24;">顺序表作为其存储结构</span>，<span style="color:#fe2c24;">采用二分查找实现其查找操作</span>；</strong></p> 
<p><strong>        若有序表是<span style="color:#fe2c24;">动态查找表</span>，则应<span style="color:#fe2c24;">选择二叉排序树作为其逻辑结构</span>。</strong></p> 
<h3 id="3.2%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span style="color:#4da8ee;"><strong>3.2 平衡二叉树</strong></span></h3> 
<h4 id="3.2.1%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span style="color:#38d8f0;"><strong>3.2.1 平衡二叉树的定义</strong></span></h4> 
<p>        为避免树的高度增长过快，降低二叉排序树的性能，规定在插入和删除二叉树结点时，保证<span style="color:#0d0016;"><strong>任意结点的左、右子树高度差的绝对值不超过 1 ，将这样的二叉树称为</strong></span><span style="color:#fe2c24;"><strong>平衡二叉树（Balanced Binary Tree）</strong></span><span style="color:#0d0016;"><strong>，简称</strong></span><span style="color:#fe2c24;"><strong>平衡树</strong></span>。<span style="color:#0d0016;"><strong>定义结点左子树和右子树的高度差为该结点的</strong></span><span style="color:#fe2c24;"><strong>平衡因子</strong></span><span style="color:#0d0016;"><strong>，则平衡二叉树结点的平衡因子的值只能是 -1、0 或 1。</strong></span></p> 
<p>        平衡二叉树可定义为或者是一棵空树，或者是具有下列性质的二叉树：<span style="color:#0d0016;"><strong>它的左子树和右子树都是平衡二叉树，且左子树和右子树的高度差的绝对值不超过1。</strong></span><span style="color:#fe2c24;"><strong>结点中的值为该结点的平衡因子。</strong></span></p> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/6b/b4/pkvIO5tf_o.png" width="509"></p> 
<h4 id="3.2.2%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span style="color:#38d8f0;"><strong>3.2.2 平衡二叉树的插入</strong></span></h4> 
<p><span style="color:#0d0016;"><strong>二叉排序树保持平衡的基本思想如下：</strong></span></p> 
<p><span style="color:#0d0016;"><strong>     </strong></span><span style="color:#1c7331;"><strong>   每当在二叉排序树中插入（或删除）一个结点时，首先检查其插入路径上的结点是否因为此次操作而导致不平衡。若导致了不平衡，则先找到插入路径上离插入结点最近的平衡因子的绝对值大于 1 的结点A，再对 A 为根的子树，在保持二叉排序树特性的前提下，调整各结点的位置关系，使之重新达到平衡。</strong></span></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>注意：</strong></span><span style="color:#0d0016;"><strong>每次调整的对象都是最小不平衡子树，即以插入路径上离插入结点最近的平衡因子的绝对值大于 1 的结点作为根的子树。</strong></span></p> 
</blockquote> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/66/ec/ftyBSjAW_o.png" width="856"></p> 
<p>        平衡二叉树的插入过程的前半部分与二叉排序树相同，但在新结点插入后，若造成查找路径上的某个结点不再平衡，则需要做出相应的调整。归纳如下：</p> 
<p><span style="color:#1c7331;"><strong>LL 平衡旋转（右单旋转）：</strong></span></p> 
<p>        由于在结点 A 的左孩子 L 的左子树 L 上插入了新结点， A 的平衡因子由 1 增至 2，导致以 A 为根的子树失去了平衡，需要一次向右的旋转操作。将 A 的左孩子 B 向右上旋转代替 A 成为根结点，将 A 结点向右下旋转成为 B 的右子树的根结点，<span style="color:#fe2c24;"><strong>而 B 的原右子树则作为 A 结点的左子树</strong></span>。</p> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/a3/ff/bPu3ZGEo_o.png" width="956"></p> 
<blockquote> 
 <p><strong>这里解释一下：</strong></p> 
 <p><strong>        平衡因子由1变为2是因为原本只有A和B两个结点，在加入BL结点后，结点A的平衡因子由1变为2；</strong></p> 
 <p><strong>        注意理解上图中的  </strong><span style="color:#fe2c24;"><strong>而 B 的原右子树则作为 A 结点的左子树。</strong></span></p> 
</blockquote> 
<p><span style="color:#1c7331;"><strong>RR 平衡旋转（左单旋转）：</strong></span></p> 
<p>        由于在结点 A 的右孩子 R 的右子树 R 上插入了新结点， A 的平衡因子由 -1 减至 -2，导致以 A 为根的子树失去了平衡，需要一向左的旋转操作。将 A 的右孩子 B 向左上旋转代替 A 成为根结点，将 A 结点向左下旋转成为 B 的左子树的根结点，<span style="color:#fe2c24;"><strong>而 B 的原左子树则作为 A 结点的右子树</strong></span>。</p> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/d6/04/CpTFY7IK_o.png" width="948"></p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>注意</strong></span>：LR 和 RL 旋转时，新结点究竟是插入 C 的左子树还是插入 C 的右子树不影响旋转过程。</p> 
</blockquote> 
<p><span style="color:#1c7331;"><strong>LR 平衡旋转（先左后右双旋转）：</strong></span></p> 
<p>        由于在 A 的左孩子 L 的右子树 R 上插入新结点， A 的平衡因子由 1 增至 2，导致以 A 为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转。先将A结点的左孩子B的右子树的根结点C向左上旋转提升到B结点的位置，然后把该C结点向右上旋转提升到/结点的位置。</p> 
<p class="img-center"><img alt="" height="350" src="https://images2.imgbox.com/07/f6/Pnhsrw4D_o.png" width="979"></p> 
<p><span style="color:#1c7331;"><strong>RL 平衡旋转（先右后左旋转）：</strong></span></p> 
<p>        由于在 A 的右孩子(R)的左子树(L)上插入新结点，A 的平衡因子由 -1 减至 -2，导致以 A 为根的子树失去平衡，需要进行两次旋转操作，先右旋转后左旋转。先将 A 结点的右孩子 B 的左子树的根结点 C 向右上旋转提升到 B 结点的位置，然后把该C结点向左上旋转提升到 A 结点的位置。</p> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/68/68/bCbbY32D_o.png" width="842"></p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>下面通过一个例子具体来看序列生成二叉树的例子：</strong></span></p> 
 <p>       <span style="color:#0d0016;"><strong> 假设关键字序列为{15，3，7，10，9，8}</strong></span>，首先插入 7 后导致不平衡，最小不平衡子树的根为 15 ，插入位置为其左孩子的右子树，执行 LR 旋转，先左后右双旋转；插入 9 后导致不平衡，最小不平衡子树的根为 15 ，插入位置为其左孩子的左子树，故执行 LL 旋转，右单旋转；插入 8 后导致不平衡，最小不平衡子树的根为 7，插入位置为其右孩子的左子树，执行 RL 旋转，先右后左双旋转；</p> 
 <p class="img-center"><img alt="" height="450" src="https://images2.imgbox.com/5c/8b/FA4ZwEE0_o.png" width="909"></p> 
</blockquote> 
<h4 id="3.2.3%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4"><span style="color:#38d8f0;"><strong>3.2.3 平衡二叉树的删除</strong></span></h4> 
<p><span style="color:#0d0016;"><strong>        与平衡二叉树的插入操作类似，以删除结点 w 为例来说明平衡二叉树删除操作的步骤：</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        1. 用二叉排序树的方法对结点 w 执行删除操作。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        2. 从结点 w 开始，向上回溯，找到第一个不平衡的结点 z (即最小不平衡子树)；y 为结点 z 的高度最高的孩子结点；x 是结点 y 的高度最高的孩子结点。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        3. 然后对以 z 为根的子树进行平衡调整，其中 x、y 和 z 可能的位置如下：</strong></span></p> 
<ul><li><span style="color:#0d0016;"><strong>y是z的左孩子，x是y的左孩子（LL，右单旋转）;</strong></span></li><li><span style="color:#0d0016;"><strong>y是z的左孩子，x是y的右孩子（LR，先左后右双旋转）;</strong></span></li><li><span style="color:#0d0016;"><strong>y是z的右孩子，x是y的右孩子（RR，左单旋转）;</strong></span></li><li><span style="color:#0d0016;"><strong>y是z的右孩子，x是y的左孩子（RL，先右后左双旋转）。</strong></span></li></ul> 
<p>        这四种情况与插入操作的调整方式一样。不同之处在于，插入操作仅需要对以 z 为根的子树进行平衡调整；而删除操作就不一样，先对以 z 为根的子树进行平衡调整，如果调整后子树的高度减 1，则可能需要对 z 的祖先结点进行平衡调整，甚至回溯到根结点（导致树高减 1 ）</p> 
<p class="img-center"><img alt="" height="700" src="https://images2.imgbox.com/68/99/QNg9VaNB_o.png" width="1200"></p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>删除结点32：</strong></span></p> 
 <p>        由于结点32是叶子结点，所以直接删除即可，向上回溯到第一个不平衡结点44，即 z；</p> 
 <p>        z 的高度最高的孩子结点为 78，即 y；</p> 
 <p>        y 的高度最高的孩子结点为 50，即 x；</p> 
 <p>        满足 RL 情况，先右后左双旋转；</p> 
 <p class="img-center"><img alt="" height="350" src="https://images2.imgbox.com/ea/2d/APfggfvZ_o.png" width="998"></p> 
</blockquote> 
<h4 id="3.2.4%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE"><span style="color:#38d8f0;"><strong>3.2.4 平衡二叉树的查找</strong></span></h4> 
<p>        <span style="color:#0d0016;"><strong>在查找过程中，与给定值进行比较的关键字个数不超过树的深度</strong></span>。<strong><span style="color:#fe2c24;">假设以 <img alt="n_{h}" class="mathcode" src="https://images2.imgbox.com/77/12/7NcshpzC_o.png"> 表示深度为 h 的平衡树中含有的最少结点数</span></strong>。</p> 
<p>        <span style="color:#fe2c24;"><strong>显然，<img alt="n_{0}" class="mathcode" src="https://images2.imgbox.com/89/96/VN2JXiXt_o.png">=0，<img alt="n_{1}" class="mathcode" src="https://images2.imgbox.com/fa/32/nBRr6nt5_o.png">=1，<img alt="n_{2}" class="mathcode" src="https://images2.imgbox.com/f4/0b/X9ndcFZ8_o.png">=2……，并且有 <img alt="n_{h}" class="mathcode" src="https://images2.imgbox.com/87/8d/UF7aEwXT_o.png"> = <img alt="n_{h-1}" class="mathcode" src="https://images2.imgbox.com/2b/e2/FtuBIaak_o.png"> + <img alt="n_{h-2}" class="mathcode" src="https://images2.imgbox.com/09/b2/YvayxqcP_o.png"> +1。</strong></span></p> 
<p>        <span style="color:#0d0016;"><strong>含有 n 个结点的平衡二叉树的最大深度为 O(log2n)，平衡二叉树的平均查找长度为 O(log2n)；</strong></span></p> 
<p class="img-center"><img alt="" height="250" src="https://images2.imgbox.com/d4/13/wxiIcaJ7_o.png" width="855"></p> 
<h2 id="4.%20%E7%BA%A2%E9%BB%91%E6%A0%91"><span style="color:#956fe7;"><strong>4. 红黑树</strong></span></h2> 
<h3 id="4.1%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span style="color:#4da8ee;"><strong>4.1 红黑树的定义</strong></span></h3> 
<p>        为了保持 AVL 树的平衡性，插入和删除操作后，非常频繁地调整全树整体的拓扑结构，代价较大。为此在 AVL 树的平衡标准上进一步放宽条件，引入红黑树。</p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>为什么要发明红黑树？</strong></span></p> 
 <p>        平衡二叉树的插入/删除很容易破坏 “平衡” 特性，需要频繁调整树的形态。比如说：插入操作导致不平衡，则需要先计算平衡因子，找到最小不平衡子树，再进行LL/RR/LR/RL调整。</p> 
 <p>     <span style="color:#0d0016;"><strong>   而</strong></span><span style="color:#fe2c24;"><strong>红黑树的插入和删除</strong></span><span style="color:#0d0016;"><strong>很多时候不会破坏 “红黑” 特性，并不需要频繁的调整树的形态。即便需要调整，一般都可以在常数级时间内完成。</strong></span></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>一棵红黑树是满足如下红黑性质的二叉排序树：</strong></span></p> 
 <p><span style="color:#0d0016;"><strong>       </strong></span><span style="color:#1c7331;"><strong> ①：每个结点或是红色，或是黑色的。</strong></span></p> 
 <p><span style="color:#1c7331;"><strong>        ②：根结点是黑色的。</strong></span></p> 
 <p><span style="color:#1c7331;"><strong>        ③：叶结点（虚构的外部结点、NULL结点）都是黑色的。（注意：这里说的叶子结点不是最下面的结点，而是最下面的结点延伸出来的结点；比方说下图方框中表示的就是叶子结点）。</strong></span></p> 
 <p><span style="color:#1c7331;"><strong>        ④：不存在两个相邻的红结点（即红结点的父结点和孩子结点均是黑色的）。</strong></span></p> 
 <p><span style="color:#1c7331;"><strong>        ⑤：对每个结点，从该结点到任一叶结点的简单路径上，所含黑结点的数量相同。</strong></span></p> 
</blockquote> 
<p>        为了便于对红黑树的实现和理解，引入 n+1 个外部结点，保证红黑树的每个结点的左孩子和右孩子均非空。</p> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/29/34/dEhbZl0f_o.png" width="457"></p> 
<p>        <strong>从<span style="color:#fe2c24;">某一结点出发（不含该结点）</span>到达一个<span style="color:#fe2c24;">叶结点</span>的任一简单路径上的<span style="color:#fe2c24;">黑结点总数</span>称为<span style="color:#fe2c24;">该结点的黑高（记为 bh）</span>。<span style="color:#1c7331;">根结点的黑高称为红黑树的黑高。</span></strong></p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>结论一：从根到叶结点的最长路径不大于最短路径的两倍。</strong></span></p> 
 <p><span style="color:#0d0016;"><strong>结论二：有 n 个内部结点的红黑树的高度 h &lt;= 2log2(n+1)。</strong></span></p> 
</blockquote> 
<h3 id="4.2%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span style="color:#4da8ee;"><strong>4.2 红黑树的插入</strong></span></h3> 
<p>        红黑树插入新结点后需要进行调整（主要通过重新着色或旋转操作进行），以满足红黑树的性质。</p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>结论三：新插入红黑树中的结点初始着为红色。</strong></span></p> 
</blockquote> 
<p>        设结点 z 为新插入的结点。插入过程描述如下：</p> 
<p> <span style="color:#0d0016;"><strong>       1. 用二叉查找树插入法插入，并将结点 z 着为红色。若结点 z 的父结点是黑色的，无须做任何调整，此时就是一棵标准的红黑树。        </strong></span></p> 
<p><span style="color:#0d0016;"><strong>        2. 如果结点 z 是根结点，将 z 着为黑色（树的黑高增加 1），结束。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        3. 如果结点 z 不是根结点，并且 z 的父结点是红色的，</strong></span><span style="color:#fe2c24;"><strong>则分为下面三种情况</strong></span><span style="color:#0d0016;"><strong>，区别在于 z 的叔结点 y 的颜色不同，因为 z 的父结点是红色的，插入之前树是合法的，爷结点必然存在且为黑色。</strong></span></p> 
<blockquote> 
 <p><span style="color:#1c7331;"><strong>情况1：z 的叔结点（也就是父结点的兄弟结点）y 是黑色的，且 z 是一个右孩子。</strong></span></p> 
 <p><span style="color:#1c7331;"><strong>情况2：z 的叔结点 y 是黑色的，且 z 是一个左孩子。</strong></span></p> 
 <p><span style="color:#0d0016;">        每棵子树<img alt="T_{1}" class="mathcode" src="https://images2.imgbox.com/39/5f/o0dzFn7G_o.png">、<img alt="T_{2}" class="mathcode" src="https://images2.imgbox.com/3e/98/1VoVIVPX_o.png">、<img alt="T_{3}" class="mathcode" src="https://images2.imgbox.com/08/25/7IgXz1l2_o.png">和<img alt="T_{4}" class="mathcode" src="https://images2.imgbox.com/8e/60/2tZJ1Zvu_o.png"> 都有一个黑色根结点，且具有相同的黑高。</span></p> 
 <p><span style="color:#0d0016;">      </span><span style="color:#1c7331;"><strong>  情况1（LR，先左旋，再右旋）</strong></span><span style="color:#0d0016;">，</span>即z是爷结点的左孩子的右孩子。先做一次左旋将此情形转变为情况2 （变为情况2后再做一次右旋），左旋后z和父结点z.p交换位置。</p> 
 <p>        <span style="color:#1c7331;"><strong>情况2（LL，右单旋）</strong></span>，即z是爷结点的左孩子的左孩子。做一次右旋，并交换z的原父结点和原爷结点的颜色，就可以保持性质⑤，也不会改变树的黑高。这样，红黑树中也不再有连续两个红结点，结束。</p> 
 <p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/c1/a6/I7gtcUT8_o.png" width="1100"></p> 
 <p>        <span style="color:#1c7331;"><strong>若父结点是爷结点的右孩子，则还有两种对称的情况：RL（先右旋，再左旋）和 RR（右单旋）。</strong></span></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#1c7331;"><strong>情况3：如果 x 的叔结点 y 是红色。</strong></span></p> 
 <p><span style="color:#1c7331;"><strong>        情况3（z 是左孩子或右孩子无影响）</strong></span><span style="color:#0d0016;">，</span>z的父结点z.p和叔结点y都是红色的，因为爷结点z.p.p是黑色的，将z.p和y都着为黑色，将z.p.p着为红色，以在局部保持性质④和⑤。然后，把z.p.p作为新结点z来重复循环，指针z在树中上移两层。</p> 
 <p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/26/20/FA5nP71d_o.png" width="1049"></p> 
 <p>        <strong><span style="color:#1c7331;">若父结点是爷结点的右孩子，还存在两种对称的情况。</span></strong></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>下面举个例子，先后插入5，4，12：</strong></span></p> 
 <p>        插入5,为情况3,将5的父结点3和叔结点10着为黑色，将5的爷结点变为红色，此时因为7已是根，故着为黑色，树的黑高加1,结束。插入4,为情况1的对称情况（RL）,此时特别注意虚构黑色空叶结点的存在，先对5做右旋；转变为情况2的对称情况（RR）,交换3和4的颜色，再对3做左旋，结束。插入12,父结点是黑色的，无须任何调整，结束。</p> 
 <p class="img-center"><img alt="" height="600" src="https://images2.imgbox.com/2d/8a/xUhSh1br_o.png" width="1161"></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>囊括所有红黑树插入可能的例子：（细细品）</strong></span></p> 
 <p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/2f/9d/68zRlr1l_o.png" width="713"></p> 
 <p class="img-center"><img alt="" height="800" src="https://images2.imgbox.com/49/c0/xEbUs5u7_o.png" width="1200"></p> 
 <p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/49/14/54o63qMa_o.png" width="1200"></p> 
 <p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/41/19/OrKXExTq_o.png" width="1200"></p> 
 <p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/60/d6/N1cp9Y5l_o.png" width="1200"></p> 
 <p class="img-center"><img alt="" height="350" src="https://images2.imgbox.com/77/de/wwTgxlhL_o.png" width="581"></p> 
 <p class="img-center"><img alt="" height="700" src="https://images2.imgbox.com/24/f3/YwKKhU9h_o.png" width="1200"></p> 
 <p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/04/eb/ddtqPzzg_o.png" width="1200"></p> 
 <p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/d2/29/Am2YMfpo_o.png" width="920"></p> 
 <p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/ed/30/lJCShOMd_o.png" width="1200"></p> 
 <p class="img-center"><img alt="" height="450" src="https://images2.imgbox.com/33/0a/yMAiVuKP_o.png" width="1141"></p> 
 <p class="img-center"><img alt="" height="700" src="https://images2.imgbox.com/8c/d9/TQnKKNeT_o.png" width="1200"></p> 
 <p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/7e/cc/hwfsPaCi_o.png" width="1200"></p> 
 <p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/c3/90/RX7POhLK_o.png" width="1200"></p> 
 <p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/79/4d/Q9wyXyU0_o.png" width="1200"></p> 
 <p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/e4/43/DUPt4fK0_o.png" width="1200"></p> 
</blockquote> 
<h3 id="4.3%20%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4"><span style="color:#4da8ee;"><strong>4.3 红黑树的删除</strong></span></h3> 
<p><span style="color:#0d0016;"><strong>删除操作和插入操作进行对比：</strong></span></p> 
<p>        红黑树的插入操作容易导致连续的两个红结点，破坏性质④。<span style="color:#ad720d;"><strong>而删除操作容易造成子树黑高的变化（删除黑结点会导致根结点到叶结点间的黑结点数量减少），破坏性质⑤</strong></span>。</p> 
<p>        删除过程也是先执行二叉查找树的删除方法。若待删结点有两个孩子，不能直接删除，而要找到该结点的中序后继（或前驱）填补，即右子树中最小的结点，然后转换为删除该后继结点。由于后继结点至多只有一个孩子，这样就转换为待删结点是叶结点或仅有一个孩子的情况。</p> 
<p><span style="color:#0d0016;"><strong>最终，删除一个结点有以下两种情况：</strong></span></p> 
<ul><li>        待删结点没有孩子。</li><li>        待删结点只有右子树或左子树。</li></ul> 
<p><span style="color:#1c7331;"><strong>1. 如果待删结点只有右子树或左子树，如下：</strong></span></p> 
<p class="img-center"><img alt="" height="150" src="https://images2.imgbox.com/59/ea/E5mfL5BE_o.png" width="531"></p> 
<p><span style="color:#1c7331;"><strong>2. 如果待删结点没有孩子，若该结点是红色的，直接删除，无须做任何调整。</strong></span></p> 
<p><span style="color:#1c7331;"><strong>3. 如果待删结点没有孩子，并且该结点是黑色的。</strong></span><span style="color:#0d0016;">假设待删结点为y, x是用来替换y的结点（注意，当y是终端结点时，x是黑色的NULL结点）。删除y后将导致先前包含y的任何路径上的黑结点数量减1,因此y的任何祖先都不再满足性质⑤，简单的修正办法就是将替换y的结点x视为还有额外一重黑色，定义为<strong>双黑结点</strong>。也就是说，如果将任何包含结点x的路径上的黑结点数量加1,在此假设下，性质⑤得到满足，但破坏了性质①。于是，删除操作的任务就转化为将双黑结点恢复为普通结点。</span><span style="color:#fe2c24;"><strong>分以下四种情况：</strong></span></p> 
<blockquote> 
 <p><span style="color:#1c7331;"><strong>情况一：x 的兄弟结点 w 是红色的。</strong></span></p> 
 <p>        <span style="color:#1c7331;"><strong>情况1,</strong></span> W必须有黑色左右孩子和父结点。交换W和父结点x.p的颜色，然后对x.p做一次左旋，而不会破坏红黑树的任何规则。现在，X的新兄弟结点是旋转之前W的某个孩子结点，其颜色为黑色，这样，就将情况1转换为情况2、3或4处理。</p> 
 <p class="img-center"><img alt="" height="250" src="https://images2.imgbox.com/df/51/c1wWrhls_o.png" width="1062"></p> 
 <p><span style="color:#1c7331;"><strong>情况二：x 的兄弟结点 w 是黑色的， w 的左孩子是红色的，w 的右孩子是黑色的。</strong></span></p> 
 <p>        <span style="color:#1c7331;"><strong>情况2 （RL,先右旋，再左旋）</strong></span>，即红结点是其爷结点的右孩子的左孩子。交换w和其左孩子的颜色，然后对w做一次右旋，而不破坏红黑树的任何性质。现在，x的新兄弟结点w的右孩子是红色的，这样就将情况2转换为了情况3。</p> 
 <p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/e9/b5/wYaWGAr4_o.png" width="1034"></p> 
 <p><span style="color:#1c7331;"><strong>情况三： x 的兄弟结点 w 是黑色的，且 w 的右孩子是红色的。</strong></span></p> 
 <p>       <span style="color:#1c7331;"><strong> 情况3 （RR,左单旋）</strong></span>，即红结点是其爷结点的右孩子的右孩子。交换w和父结点x.p的颜色，把w的右孩子着为黑色，并对x的父结点x.p做一次左旋，将x变为单重黑色，此时不再破坏红黑树的任何性质，结束。</p> 
 <p class="img-center"><img alt="" height="250" src="https://images2.imgbox.com/39/4e/3vg5kb7h_o.png" width="1009"></p> 
 <p><span style="color:#1c7331;"><strong>情况四：x 的兄弟结点 w 是黑色的，且 w 的两个孩子结点都是黑色的。</strong></span></p> 
 <p>        <span style="color:#1c7331;"><strong>情况4中</strong></span>，因w也是黑色的，故可从x和w上去掉一重黑色，使得x只有一重黑色而w变为红色。为了补偿从x和w中去掉的一重黑色，把x的父结点x.p额外着一层黑色，以保持局部的黑高不变。通过将x.p作为新结点x来循环，x上升一层。如果是通过情况1进入情况4的，因为原来的x.p是红色的，将新结点x变为黑色，终止循环，结束。</p> 
 <p class="img-center"><img alt="" height="250" src="https://images2.imgbox.com/3e/76/scgQ1yZ0_o.png" width="958"></p> 
</blockquote> 
<p>        <span style="color:#fe2c24;"><strong>归纳总结：</strong></span><span style="color:#1c7331;"><strong>在情况4中</strong></span>，因x的兄弟结点w及左右孩子都是黑色，可以从x和w中各提取一重黑色（以让x变为普通黑结点），不会破坏性质④，并把调整任务向上“推”给它们的父结点x.p。<span style="color:#1c7331;"><strong>在情况1、2和3中</strong></span>，因为x的兄弟结点w或w左右孩子中有红结点，所以只能在x.p子树内用调整和重新着色的方式，且不能改变x原根结点的颜色（否则向上可能破坏性质④）。情况1虽然可能会转换为情况4,但因为新x的父结点x.p是红色的，所以执行一次情况4就会结束。情况1、2和3在各执行常数次的颜色改变和至多3次旋转后便终止，情况4是可能重复执行的唯一情况，每执行一次指针X上升一层，至多O（log2n）次。</p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>下面举个例子，依次删除结点5和15：</strong></span></p> 
 <p>        删除5,用虚构的黑色NULL结点替换，视为双黑NULL结点，为情况1,交换兄弟结点12和父结点8的颜色，对8做一次左旋；转变为情况4,从双黑NULL结点和10中各提取一重黑色（提取后，双黑NULL结点变为普通NULL结点，图中省略，10变为红色），因原父结点8</p> 
 <p>是红色，故将8变为黑色，结束。删除15,为情况2的对称情况（LR）,交换8和10的颜色，对8做左旋；转变为情况2的对称情况（LL）,交换10和12的颜色（两者颜色一样，无变化），将10的左孩子8着为黑色，对12做右旋，结束。</p> 
 <p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/61/3f/OJs1d84A_o.png" width="1056"></p> 
</blockquote> 
<h3 id="4.4%20%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0"><span style="color:#4da8ee;"><strong>4.4 相关练习</strong></span></h3> 
<p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/cf/f6/X6ksJHgQ_o.png" width="1200"></p> 
<p class="img-center"><img alt="" height="700" src="https://images2.imgbox.com/9c/1b/IqfPzdmY_o.png" width="1200"></p> 
<p><img alt="" height="608" src="https://images2.imgbox.com/8a/90/vMpiMNZ4_o.png" width="1200"></p> 
<p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/d8/e3/15LcAWw1_o.png" width="1200"></p> 
<p class="img-center"><img alt="" height="450" src="https://images2.imgbox.com/db/fc/7SJgQsRP_o.png" width="1200"></p> 
<h2 id="5.%20B%20%E6%A0%91%E5%92%8C%20B%2B%20%E6%A0%91"><span style="color:#956fe7;"><strong>5. B 树和 B+ 树</strong></span></h2> 
<h3 id="5.1%20B%20%E6%A0%91%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span style="color:#4da8ee;"><strong>5.1 B 树及其基本操作</strong></span></h3> 
<p> <span style="color:#0d0016;"><strong>       </strong></span><span style="color:#fe2c24;"><strong>B树</strong></span><span style="color:#0d0016;"><strong>，又称为</strong></span><span style="color:#fe2c24;"><strong>多路平衡查找树</strong></span>，<span style="color:#0d0016;"><strong>B树中所有结点的孩子个数的最大值称为 </strong></span><span style="color:#fe2c24;"><strong>B 树的阶</strong></span>，通常用 m 表示。一棵 m 阶 B树或为空树，或为满足如下特性的 <span style="color:#0d0016;"><strong>m 叉树</strong></span>：</p> 
<p>        <span style="color:#0d0016;"><strong>1. 树中每个结点至多有 m 棵子树，即至多含有 m-1 个关键字。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        2. 若根结点不是终端结点，则至少有两棵子树。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        3. 除根结点外的所有非叶结点至少有</strong></span><span style="color:#fe2c24;"><strong> m/2向上取值</strong></span><span style="color:#0d0016;"><strong> 棵子树，即至少含有 </strong></span><span style="color:#fe2c24;"><strong>m/2向上取值-1 </strong></span><span style="color:#0d0016;"><strong>个关键字。</strong></span></p> 
<p><span style="color:#0d0016;"><strong>        4. 所有非叶结点的结构如下：</strong></span></p> 
<p class="img-center"><img alt="" height="100" src="https://images2.imgbox.com/cc/e3/9L0ng1i3_o.png" width="1011"></p> 
<p>        其中，<img alt="k_{i}" class="mathcode" src="https://images2.imgbox.com/50/d0/WuB5JGdL_o.png"> 为结点的<span style="color:#0d0016;"><strong>关键字</strong></span>，满足 <img alt="k_{1}" class="mathcode" src="https://images2.imgbox.com/c0/ab/JwM0z0Xx_o.png">&lt;<img alt="k_{2}" class="mathcode" src="https://images2.imgbox.com/be/7f/avOc98ee_o.png">&lt;……<img alt="k_{n}" class="mathcode" src="https://images2.imgbox.com/02/66/EJfOilxg_o.png">；<img alt="p_{i}" class="mathcode" src="https://images2.imgbox.com/1e/f2/Wc63LHJ5_o.png"> 为指向子树根结点的指针，且指针 <img alt="p_{i-1}" class="mathcode" src="https://images2.imgbox.com/53/69/aAeidAdk_o.png"> 所指子树中所有结点的关键字均小于 <img alt="k_{i}" class="mathcode" src="https://images2.imgbox.com/bd/92/2V7DeYrr_o.png"> ，<img alt="p_{i}" class="mathcode" src="https://images2.imgbox.com/18/d2/uxNUVmYT_o.png"> 所指子树中所有结点的关键字均大于 <img alt="k_{i}" class="mathcode" src="https://images2.imgbox.com/61/b1/vbmDuV9E_o.png">，n 为结点中关键字的个数。</p> 
<p>       <span style="color:#0d0016;"><strong> 5. 所有的叶结点都出现在同一层次上，并且不带信息（可以认为这些结点不存在，指向这些结点的指针为空）。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>        B 树是所有结点的平衡因子均为 0 多路平衡查找树。</strong></span></p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>如下图所示为一个 </strong></span><span style="color:#fe2c24;"><strong>5 阶 B 树</strong></span><span style="color:#0d0016;"><strong>，按照 B 树的定义，5 阶 B 树中所有结点的最大孩子数 m=5。</strong></span></p> 
 <p class="img-center"><img alt="" height="350" src="https://images2.imgbox.com/fa/24/LocvxjqZ_o.png" width="904"></p> 
 <p><span style="color:#1c7331;"><strong>        1. 结点的孩子个数等于该结点中关键字个数加1。</strong></span></p> 
 <p><span style="color:#1c7331;"><strong>        2. </strong></span><span style="color:#1c7331;"><strong>如果根结点没有关键字就没有子树，此时B树为空；如果根结点有关键字，则其子树必然大于等于两棵，因为子树个数等于关键字个数加1。</strong></span></p> 
 <p><span style="color:#1c7331;"><strong>        3. </strong></span><span style="color:#1c7331;"><strong>除根结点外的所有非终端结点至少有|m/2] =「5/2| 向上取整= 3棵子树（即至少m/2 - 1 = 5/2 - 1=2个关键字），至多有5棵子树（即至多有4个关键字）。</strong></span></p> 
 <p><span style="color:#1c7331;"><strong>        4. 结点中关键字从左到右递增有序，关键字两侧均有指向子树的指针，左边指针所指子树的所有关键字均小于该关键字，右边指针所指子树的所有关键字均大于该关键字。或者看成下层结点关键字总是落在由上层结点关键字所划分的区间内，如第二层最左结点的关键字划分成了 3个区间：（负无穷,5）, （5, 11）, （11,正无穷）,该结点3个指针所指子树的关键字均落在这3个区间内。</strong></span></p> 
 <p><span style="color:#1c7331;"><strong>        5. 所有叶结点均在第 4 层，代表查找失败的位置。</strong></span></p> 
</blockquote> 
<h4 id="5.1.1%20B%20%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6%EF%BC%88%E7%A3%81%E7%9B%98%E5%AD%98%E5%8F%96%E6%AC%A1%E6%95%B0%EF%BC%89"><span style="color:#38d8f0;"><strong>5.1.1 B 树的高度（磁盘存取次数）</strong></span></h4> 
<p> <span style="color:#0d0016;"><strong>       B树中的大部分操作所需的磁盘存取次数与 B 树的高度成正比。</strong></span><span style="color:#1c7331;"><strong>B树的高度不包括最后的不带任何信息的叶结点所处的那一层</strong></span><span style="color:#0d0016;"><strong>。</strong></span></p> 
<blockquote> 
 <p>若 n <img alt="\geq" class="mathcode" src="https://images2.imgbox.com/4e/75/mruB0cFg_o.png">1，则对任意一棵包含<span style="color:#0d0016;"><strong> n 个关键字、高度为 h、阶数为 m的 B树</strong></span>：</p> 
 <p> <span style="color:#0d0016;"><strong>       高度的范围是：</strong></span></p> 
 <p style="text-align:center;"><span style="color:#1c7331;"><strong>logm(n+1) <img alt="\leq" class="mathcode" src="https://images2.imgbox.com/7c/8c/tKx1dFTF_o.png"> h <img alt="\leq" class="mathcode" src="https://images2.imgbox.com/e7/3c/84h2Ya3N_o.png"> log m/2向上取整为底的 ((n+1)/2)+1。</strong></span></p> 
 <p>例如：假设一棵 3 阶 B 树共有 8 个关键字，则其高度为 2 <img alt="\leq" class="mathcode" src="https://images2.imgbox.com/f4/16/Xkz0wiZL_o.png"> h <img alt="\leq" class="mathcode" src="https://images2.imgbox.com/86/3f/0p0Zt1iU_o.png"> 3.17.</p> 
</blockquote> 
<h4 id="5.1.2%20B%20%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE"><span style="color:#38d8f0;"><strong>5.1.2 B 树的查找</strong></span></h4> 
<p>        在 B 树上进行查找与二叉排序树很相似，只是每个结点都是多个关键字的有序表，<span style="color:#0d0016;"><strong>在每个结点上所做的不是两路分支决定，而是根据该结点的子树所做的多路分支决定。</strong></span></p> 
<p>        <span style="color:#0d0016;"><strong>B树的查找包含两个基本操作</strong></span>：<span style="color:#956fe7;"><strong>①在B树中找结点</strong></span>；<span style="color:#4da8ee;"><strong>②在结点内找关键字</strong></span>。由于B树常存储在磁盘上，因此<span style="color:#1c7331;"><strong>前一个查找操作是在磁盘上进行的，而后一个查找操作是在内存中进行的</strong></span>，即在找到目标结点后，先将结点信息读入内存，然后在结点内采用顺序查找法或折半查找法。</p> 
<p>        在B树上查找到某个结点后，先在有序表中进行查找，若找到则查找成功，否则按照对应的指针信息到所指的子树中去查找（例如，在下图中查找关键字42,首先从根结点开始，根结点只有一个关键字，且42 &gt;22,若存在，必在关键字22的右边子树上，右孩子结点有两个关键字，而36 则若存在，必在36和45中间的子树上，在该子结点中查到关键字42,查找成功）。查找到叶结点时（对应指针为空指针），则说明树中没有对应的关键字，查找失败。</p> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/12/65/NSWhTXpC_o.png" width="823"></p> 
<h4 id="5.1.3%20B%20%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span style="color:#38d8f0;"><strong>5.1.3 B 树的插入</strong></span></h4> 
<p>        与二叉查找树的插入操作相比，B树的插入操作要复杂得多。<span style="color:#0d0016;"><strong>在二叉查找树中，仅需查找到需插入的终端结点的位置。</strong></span>但是，<span style="color:#1c7331;"><strong>在B 树中找到插入的位置后，并不能简单地将其添加到终端结点中，因为此时可能会导致整棵树不再满足 B 树定义中的要求</strong></span>。将关键字 key 插入B树的过程如下∶</p> 
<blockquote> 
 <p>       <span style="color:#fe2c24;"><strong> 1. 定位</strong></span>。利用前述的B树查找算法，找出插入该关键字的最低层中的某个非叶结点（<span style="color:#0d0016;"><strong>在B树中查找key时，会找到表示查找失败的叶结点，这样就确定了最底层非叶结点的插入位置。</strong></span><span style="color:#1c7331;"><strong>注意：插入位置一定是最低层中的某个非叶结点</strong></span>）。</p> 
 <p>       <span style="color:#fe2c24;"><strong> 2. 插入</strong></span>。<span style="color:#0d0016;"><strong>在 B 树中，每个非失败结点的关键字个数都在区间</strong></span><span style="color:#fe2c24;"><strong> [(m/2向上取整-1)，m-1] </strong></span><span style="color:#0d0016;"><strong>内</strong></span>。插入后的结点关键字个数小于 m，可以直接插入；插入后检查被插入结点内关键字的个数，当插入后的结点关键字个数大于 m-1 时，必须对结点进行<span style="color:#0d0016;"><strong>分裂</strong></span>。</p> 
 <p><span style="color:#1c7331;"><strong>分裂的方法是：</strong></span></p> 
 <p>        取一个新结点，在插入key后的原结点，从中间位置（m/2 向上取整）将其中的关键字分为两部分，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置（m/2 向上取整）的结点插入原结点的父结点。若此时导致其父结点的关键字个数也超过了上限，则继续进行这种分裂操作，直至这个过程传到根结点为止，进而导致B树高度增1。</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#1c7331;"><strong>定义比较抽象，我们拿例子具体来看：</strong></span></p> 
 <p>        对于 m=3 的 B树，所有结点中最多有 m-1=2 个关键字，若某结点中已有两个关键字，则结点已满，比如说下图a 根结点的右孩子。插入一个关键字 60 后，结点内的关键字个数超过了 m-1，此时需要对结点进行分裂；</p> 
 <p class="img-center"><img alt="" height="230" src="https://images2.imgbox.com/38/dd/Rhh0HcfH_o.png" width="767"></p> 
</blockquote> 
<h4 id="5.1.4%20B%20%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4"><span style="color:#38d8f0;"><strong>5.1.4 B 树的删除</strong></span></h4> 
<p>        B 树的删除和插入面临这一个类似的问题。插入的时候，当结点中关键字的个数大于 m/2 时，需要对结点进行分裂；</p> 
<p>     <span style="color:#0d0016;"><strong>   同理，删除时，如果结点中关键字个数小于 m/2-1，会涉及合并的问题。</strong></span></p> 
<p>        当被删关键字 k 不在终端结点（最低层非叶结点）中时，可以用 k 的前驱（或后继）k' 来替代 k，然后在相应的结点中删除 k'，关键字 k 必定落在某个终端结点中，则转换成了被删关键字在终端结点中的情形。在图7.30 的 4 阶 B 树中，删除关键字 80，用其前驱 78 替代，然后在终端结点中删除 78 。因此只需讨论删除终端结点中关键字的情形。</p> 
<p class="img-center"><img alt="" height="250" src="https://images2.imgbox.com/30/3e/CDn9skWe_o.png" width="802"></p> 
<blockquote> 
 <p>   <span style="color:#0d0016;"><strong>     当被删除关键字在终端结点（最低层非叶结点）中时，有下列三种情况：</strong></span></p> 
 <p><span style="color:#1c7331;">  <strong>      1. 直接删除关键字。</strong></span><span style="color:#0d0016;">若被删除关键字所在结点的关键字个数 <strong><img alt="\geq" class="mathcode" src="https://images2.imgbox.com/b5/45/MR1FyAcV_o.png"> m/2 向上取整</strong>，表明删除该关键字后仍满足 B 树的定义，则直接删去该关键字。</span><span style="color:#1c7331;"><strong><img alt="\geq" class="mathcode" src="https://images2.imgbox.com/8a/a0/s6oNJ7Mi_o.png"></strong></span><span style="color:#fe2c24;"><strong> m/2</strong></span> <strong><span style="color:#fe2c24;">的意思是 原本的下限是 m/2 向上取整 -1 ，此时删除一个结点，正好抵达下限，仍满足 B 树的定义；</span></strong></p> 
 <p><span style="color:#1c7331;"><strong>        2. 兄弟够借。</strong></span>若被删除关键字所在结点删除前的关键字个数=「m/2]-1,且与此结点相邻的右（或左）兄弟结点的关键字个数则需要调整该结点、右（或左）兄弟结点及其双亲结点（父子换位法），以达到新的平衡。</p> 
 <p>        如下图，删除 4 阶 B树中的关键字65，右兄弟关键字个数 <img alt="\geq" class="mathcode" src="https://images2.imgbox.com/c0/74/WS66hQqa_o.png"> m/2 向上取整 = 2，将 71 取代原 65 的位置，将 74 调整到 71 的位置。</p> 
 <p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/67/5e/jvGLq1US_o.png" width="625"></p> 
 <p>   <span style="color:#1c7331;"><strong>     3. 兄弟不够借</strong></span>。若被删除关键字所在结点删除前的<span style="color:#0d0016;"><strong>关键字个数=「m/2]- 1,</strong></span>且此时与该结点相邻的左、右兄弟结点的关键字个数均=「m/2]- 1,则将关键字删除后与左（或右）兄弟结点及双亲结点中的关键字进行合并。</p> 
 <p>        如下图，删除 4 阶 B 树的关键字 5，它及其右兄弟结点的关键字个数 = m / 2 向上取整 -1 = 1，故在 5 删除后将 60 合并到 65 结点中。</p> 
 <p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/4d/a2/c1g65kSy_o.png" width="810"></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>注意</strong></span><span style="color:#0d0016;"><strong>：关键字的个数范围为</strong></span><span style="color:#1c7331;"><strong> m/2 向上取整-1 --------&gt; m/2 向上取整 </strong></span><span style="color:#0d0016;"><strong> ； 其中 m 为 B树的阶数。</strong></span></p> 
</blockquote> 
<p>  <span style="color:#0d0016;"><strong>      在合并过程中，双亲结点中的关键字个数会减 1</strong></span>。<span style="color:#1c7331;"><strong>若其双亲结点是根结点且关键字个数减少至 </strong></span><span style="color:#fe2c24;"><strong>0</strong></span><span style="color:#1c7331;"><strong>（根结点关键字个数为 1 时，有 2 棵子树），则直接将根结点删除，合并后的新结点成为根</strong></span>；<span style="color:#0d0016;"><strong>若双亲结点不是根结点，且关键字个数减少到 </strong></span><span style="color:#fe2c24;"><strong>m/2 向上取整 -2</strong></span><span style="color:#0d0016;"><strong> ，则又要与它自己的兄弟结点进行调整或合并操作，并重复上述操作，直至符合 B 树的要求为止。</strong></span></p> 
<h3 id="5.2%20B%2B%20%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span style="color:#4da8ee;"><strong>5.2 B+ 树的基本概念</strong></span></h3> 
<p><span style="color:#0d0016;"><strong>        B+ 树是应数据库所需而出现的一种 B 树的变形树。</strong></span></p> 
<blockquote> 
 <p><span style="color:#1c7331;"><strong>一棵 m 阶的 B+ 树需要满足：</strong></span></p> 
 <p>        1. 每个分支结点最多有 m 棵子树（孩子结点）。</p> 
 <p>        2. 非叶根结点至少有两棵子树，其他每个分支结点至少有 <span style="color:#0d0016;"><strong>m/2 向上取整 </strong></span>棵子树。</p> 
 <p>        3. 结点的子树个数和关键字个数相等。</p> 
 <p>        4. 所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小顺序排列，并且相邻叶结点按大小顺序相互链接起来。</p> 
 <p>        5. 所有分支结点（可视为索引的索引）中仅包含它的各个子结点（即下一级的索引块）中关键字的最大值及指向其子结点的指针。</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#1c7331;"><strong>m 阶的 B+ 树与 m 阶的 B 树的主要差异如下：</strong></span></p> 
 <p>        1. 在B+树中，具有n个关键字的结点只含有n棵子树，即每个关键字对应一棵子树;而在 B树中，具有n个关键字的结点含有n＋1棵子树。</p> 
 <p>       <span style="color:#fe2c24;"><strong> 2. </strong></span>在B+树中，每个结点（非根内部结点）的关键字个数 n 的范围是<span style="color:#0d0016;"><strong> m/2 向上取整---&gt;m</strong></span>；在 B 树中，每个结点（非根内部结点）的关键字个数 n 的范围是 <span style="color:#0d0016;"><strong>m/2 向上取整-1 --------&gt; m-1</strong></span>；</p> 
 <p>        3. 在B+树中，叶结点包含信息，所有非叶结点仅起索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。</p> 
 <p>        4. 在B+树中，叶结点包含了全部关键字，即在非叶结点中出现的关键字也会出现在叶结点中；而在B树中，叶结点（最外层内部结点）包含的关键字和其他结点包含的关键字是不重复的。</p> 
</blockquote> 
<p>        如下图是一棵 4 阶B+树。可以看出，分支结点的某个关键字是其子树中最大关键字的副本。<span style="color:#0d0016;"><strong>通常在B+树中有两个头指针</strong></span>：一个指向根结点，另一个指向关键字最小的叶结点。因此，可以对 B+ 树进行两种查找运算：一种是最小关键字开始的顺序查找，另一种是从根结点开始的多路查找。</p> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/64/57/Vmp6DAlY_o.png" width="780"></p> 
<h3 id="5.3%20%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0"><span style="color:#4da8ee;"><strong>5.3 相关练习</strong></span></h3> 
<p class="img-center"><img alt="" height="700" src="https://images2.imgbox.com/87/d0/SoRrueQJ_o.png" width="1200"></p> 
<p class="img-center"><img alt="" height="680" src="https://images2.imgbox.com/d3/8b/UodJLoZU_o.png" width="1200"></p> 
<p class="img-center"><img alt="" height="700" src="https://images2.imgbox.com/3d/93/fcpUh5QU_o.png" width="1200"></p> 
<p class="img-center"><img alt="" height="700" src="https://images2.imgbox.com/9d/7b/uerQHaNs_o.png" width="1200"></p> 
<h2 id="6.%20%E6%95%A3%E5%88%97%E8%A1%A8"><span style="color:#956fe7;"><strong>6. 散列表</strong></span></h2> 
<h3 id="6.1%20%E6%95%A3%E5%88%97%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span style="color:#4da8ee;"><strong>6.1 散列表的基本概念</strong></span></h3> 
<p>        在之前，我们已经学习了线性表和数表的查找，记录在表中的位置与记录的关键字之间不存在确定关系，因此，在这些表中查找记录时需进行一系列的关键字比较。这类查找方法建立在“比较”的基础上，查找的效率取决于比较的次数。</p> 
<p>        <span style="color:#fe2c24;"><strong>散列函数</strong></span><span style="color:#0d0016;"><strong>：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key)=Addr (这里的地址可以是数组下标、索引或内存地址等)。</strong>（在学习C语言的文件管理过程中，曾经有提及散列表的概念，这里我们引用当时的例子，深入理解散列表：</span><span style="color:#1c7331;"><strong>在C语言中，有一个关键字叫extern，我们都知道它是外部声明函数；也就是说采用模块式编程时，不需要在 .c 文件中都定义同一个变量；潇洒一点的说就是：我们在一个文件中定义该变量，其余文件使用到该变量时，直接extern外部声明即可，至于程序怎么找到这个变量，就是程序自己的事了；事实上，宏定义产生的变量都是存储在散列表中的，散列表中每个关键字对应确定的地址，extern外部声明时，会直接通过指针在散列表中找到外部声明的变量，这也是为什么可以在大量文件中迅速找到外部声明变量的原因；</strong></span><strong><span style="color:#fe2c24;">以上均是个人学习后的理解，如有问题，欢迎留言更正！</span></strong><span style="color:#0d0016;">）</span></p> 
<p>        <span style="color:#0d0016;"><strong>散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为</strong></span><span style="color:#fe2c24;"><strong>冲突</strong></span><span style="color:#0d0016;"><strong>，这些发生碰撞的不同关键字称为</strong></span><span style="color:#fe2c24;"><strong>同义词</strong></span><span style="color:#0d0016;"><strong>。</strong></span>一方面，设计得好的散列函数应尽量减少这样的冲突；另一方面，由于这样的冲突总是不可避免的，所以还要设计好处理冲突的方法</p> 
<p>        <span style="color:#fe2c24;"><strong>散列表（哈希表）</strong></span><span style="color:#0d0016;"><strong>：根据关键字而直接进行访问的数据结构</strong></span>。也就是说：<span style="color:#0d0016;"><strong>散列表建立了关键字和存储地址之间的一种直接映射关系</strong></span>。</p> 
<p>理想情况下，<span style="color:#0d0016;"><strong>对散列表进行查找的时间复杂度为0(1)</strong></span>,即与表中元素的个数无关。</p> 
<h3 id="6.2%20%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span style="color:#4da8ee;"><strong>6.2 散列函数的构造方法</strong></span></h3> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>在构造散列函数时，需要注意以下几点：</strong></span></p> 
 <p>        1. 散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。</p> 
 <p>        2. 散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间中，从而减少冲突的发生。</p> 
 <p>        3. 散列函数应尽量简单，能够在较短的时间内计算出任一关键字对应的散列地址。</p> 
</blockquote> 
<h4 id="6.2.1%20%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E6%B3%95"><span style="color:#38d8f0;"><strong>6.2.1 直接定址法</strong></span></h4> 
<p><span style="color:#0d0016;"><strong>直接取关键字的某个线性函数值为散列地址</strong></span>，散列函数为</p> 
<p style="text-align:center;"><span style="color:#0d0016;"><strong>H(key) = key 或 H(key) = a * key + b</strong></span></p> 
<p>式中，a和b是常数。这种方法计算最简单，且不会产生冲突。<span style="color:#fe2c24;"><strong>它适合关键字的分布基本连续的情况</strong></span>，若关键字分布不连续，空位较多，则会造成存储空间的浪费。</p> 
<h4 id="6.2.2%20%E9%99%A4%E7%95%99%E4%BD%99%E6%95%B0%E6%B3%95"><span style="color:#38d8f0;"><strong>6.2.2 除留余数法</strong></span></h4> 
<p>假定散列表表长为m，取一个不大于m但最接近或等于m的质数P，利用以下公式把关键字转换成散列地址。散列函数为</p> 
<p style="text-align:center;"><span style="color:#0d0016;"><strong>H(key) = key % p</strong></span></p> 
<p>除留余数法的关键是选好p，使得每个关键字通过该函数转换后等概率地映射到散列空间上的任一地址，从而尽可能减少冲突的可能性。</p> 
<h4 id="6.2.3%20%E6%95%B0%E5%AD%97%E5%88%86%E6%9E%90%E6%B3%95"><span style="color:#38d8f0;"><strong>6.2.3 数字分析法</strong></span></h4> 
<p>设关键字是r进制数（如十进制数），而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些，每种数码出现的机会均等;而在某些位上分布不均匀，只有某几种数码经常出现，此时应选取数码分布较为均匀的若干位作为散列地址。<span style="color:#0d0016;"><strong>这种方法适合于已知的关键字集合，若更换了关键字，则需要重新构造新的散列函数。</strong></span></p> 
<h4 id="6.2.4%20%E5%B9%B3%E6%96%B9%E5%8F%96%E4%B8%AD%E6%B3%95"><span style="color:#38d8f0;"><strong>6.2.4 平方取中法</strong></span></h4> 
<p>顾名思义，这种方法取关键字的平方值的中间几位作为散列地址。具体取多少位要视实际情况而定。这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀， 适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。</p> 
<blockquote> 
 <p>不同散列函数具有不同的性能；<span style="color:#fe2c24;"><strong>目标都是尽量降低产生冲突的可能性</strong></span>。</p> 
</blockquote> 
<h3 id="6.3%20%E5%A4%84%E7%90%86%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95"><span style="color:#4da8ee;"><strong>6.3 处理冲突的方法</strong></span></h3> 
<p>        <span style="color:#0d0016;"><strong>应该注意到，任何设计出来的散列函数都不可能绝对地避免冲突</strong></span>。为此，必须考虑在发生冲突时应该如何处理，<span style="color:#0d0016;"><strong>即为产生冲突的关键字寻找下一个"空"的 Hash 地址（也就是两个元素产生冲突，那么第二个就要去选择下一个空的 Hash 地址）</strong></span>。用 <img alt="H_{i}" class="mathcode" src="https://images2.imgbox.com/33/20/WKtIhFlf_o.png"> 表示处理冲突中第 i 次探测得到的散列地址，假设得到的另一个散列地址 <img alt="H_{1}" class="mathcode" src="https://images2.imgbox.com/38/8e/Bv1kGNHO_o.png">，仍然发生冲突，只得继续求下一个地址 <img alt="H_{2}" class="mathcode" src="https://images2.imgbox.com/0d/c7/Ffc2u1Vz_o.png">，以此类推，直到 <img alt="H_{k}" class="mathcode" src="https://images2.imgbox.com/29/91/sYyQYFOA_o.png"> 不发生冲突为止，则 <img alt="H_{k}" class="mathcode" src="https://images2.imgbox.com/db/71/QvIi6hGu_o.png"> 为关键字在表中的地址。</p> 
<h4 id="6.3.1%20%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%B3%95"><span style="color:#38d8f0;"><strong>6.3.1 开放定址法</strong></span></h4> 
<p>        所谓<span style="color:#fe2c24;"><strong>开放定址法是指</strong></span><span style="color:#0d0016;"><strong>可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放</strong></span>。其数学递推公式为</p> 
<p style="text-align:center;"><span style="color:#0d0016;"><strong><img alt="H_{i}" class="mathcode" src="https://images2.imgbox.com/91/c3/sQUuvbPG_o.png"> = (H(key)+<img alt="d_{i}" class="mathcode" src="https://images2.imgbox.com/18/97/gCv1H1Gf_o.png">)%m</strong></span></p> 
<p>式中，H(key)为散列函数；i = 0,1,2,3,4,5，……k；m 表示散列表表长；<span style="color:#fe2c24;"><strong><img alt="d_{i}" class="mathcode" src="https://images2.imgbox.com/55/ba/t6UKLFck_o.png"> 为增量序列</strong></span>；</p> 
<blockquote> 
 <p><span style="color:#1c7331;"><strong>1. 线性探测法：</strong></span></p> 
 <p>      <span style="color:#0d0016;"><strong>  当 <img alt="d_{i}" class="mathcode" src="https://images2.imgbox.com/11/fe/VcGqThxT_o.png"> = 0,1,2,…，m-1时，称为</strong></span><span style="color:#fe2c24;"><strong>线性探测法</strong></span>。这种方法的特点是：冲突发生时，顺序查看表中下一个单元(探测到表尾地址时，下一个探测地址是表首地址0),直到找出一个空闲单元(当表未填满时一定能找到一个空闲单元)或查遍全表。线性探测法可能使第 i个散列地址的同义词存入第 i+ 1个散列地址，这样本应存入第 i +1个散列地址的元素就争夺第 i + 2个散列地址的元素的地址……从而造成大量元素在相邻的散列地址上“聚集”(或堆积)起来,大大降低了查找效率；</p> 
 <p class="img-center"><img alt="" height="600" src="https://images2.imgbox.com/31/c1/JWrGw2vx_o.png" width="1200"></p> 
 <p><span style="color:#1c7331;"><strong>2. 平方探测法：</strong></span></p> 
 <p>      <span style="color:#0d0016;"><strong>  当a = <img alt="0^{2}" class="mathcode" src="https://images2.imgbox.com/81/de/XTISp0m9_o.png">，<img alt="1^{2}" class="mathcode" src="https://images2.imgbox.com/3b/d5/lcHMvj2b_o.png">，<img alt="-1^{2}" class="mathcode" src="https://images2.imgbox.com/33/42/fxUa3LSj_o.png">，<img alt="2^{2}" class="mathcode" src="https://images2.imgbox.com/12/4b/gqGpaosB_o.png">，<img alt="-2^{2}" class="mathcode" src="https://images2.imgbox.com/16/c4/4IMt00qR_o.png">……<img alt="k^{2}" class="mathcode" src="https://images2.imgbox.com/3d/bf/bRYskzx1_o.png">，<img alt="-k^{2}" class="mathcode" src="https://images2.imgbox.com/34/39/tiVahbQ1_o.png">时，称为</strong></span><span style="color:#fe2c24;"><strong>平方探测法</strong></span>，<span style="color:#0d0016;"><strong>其中散列表长度 m 必须是一个可以表示成 4k+3 的素数，又称</strong></span><span style="color:#fe2c24;"><strong>二次探测法</strong></span>。平方探测法是一种处理冲突的较好方法，可以避免出现“堆积”问题，它的缺点是不能探测到散列表上的所有单元，但至少能探测到一半单元。</p> 
 <p class="img-center"><img alt="" height="450" src="https://images2.imgbox.com/5d/6c/oBw88EFl_o.png" width="1200"></p> 
 <p><span style="color:#1c7331;"><strong>3. 双散列法：</strong></span></p> 
 <p>        <span style="color:#0d0016;"><strong>当 <img alt="d_{i}" class="mathcode" src="https://images2.imgbox.com/e8/50/qgCb7i2H_o.png"> = <img alt="Hash_{2}" class="mathcode" src="https://images2.imgbox.com/4a/f8/iGFfqkiR_o.png">(key)时，称为</strong></span><span style="color:#fe2c24;"><strong>双散列法</strong></span>。需要使用两个散列函数，当通过第一个散列函数H(key)得到的地址发生冲突时，则利用第二个散列函数<img alt="Hash_{2}" class="mathcode" src="https://images2.imgbox.com/b6/41/DHtSNe7u_o.png">(key)计算该关键字的地址增量。它的具体散列函数形式如下：</p> 
 <p style="text-align:center;"><span style="color:#0d0016;"><strong><img alt="H_{i}" class="mathcode" src="https://images2.imgbox.com/f5/e8/pS06GRsR_o.png"> = (H(key) + i * <img alt="Hash_{2}" class="mathcode" src="https://images2.imgbox.com/84/94/U77Jj9fU_o.png">(key)) % m</strong></span></p> 
 <p>初始探测位置<img alt="H_{0}" class="mathcode" src="https://images2.imgbox.com/15/00/iTbrDhMP_o.png"> = H(key) % m。i 是冲突的次数，初始为0。在再散列法中，最多经过 m-1 次探测就会遍历表中所有位置，回到 <img alt="H_{0}" class="mathcode" src="https://images2.imgbox.com/e5/c5/SpDk9RQC_o.png"> 位置。</p> 
 <p><strong><span style="color:#956fe7;">双散列法就是说：采用不只一个散列函数，一个散列函数无法解决冲突，就使用下一个散列函数，直到解决冲突为止；</span></strong></p> 
 <p><span style="color:#1c7331;"><strong>4. 伪随机序列法：</strong></span></p> 
 <p>        <span style="color:#0d0016;"><strong>当 <img alt="d_{i}" class="mathcode" src="https://images2.imgbox.com/3e/75/ffjDS8Cv_o.png"> = 伪随机数序列时，称为</strong></span><span style="color:#fe2c24;"><strong>伪随机序列法</strong></span><span style="color:#0d0016;"><strong>。 </strong></span></p> 
 <p><strong><span style="color:#956fe7;">伪随机序列法就是说：给定一个随机数，按照这个随机数在散列表中进行存储。</span></strong></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>注意：</strong></span></p> 
 <p>        在开放定址的情形下，不能随便物理删除表中的已有元素，因为若删除元素，则会截断其他具有相同散列地址的元素的查找地址。因此，要删除一个元素时，可给它做一个删除标记,进行逻辑删除。但这样做的副作用是：执行多次删除后，表面上看起来散列表很满，实际上有许多位置未利用，因此需要定期维护散列表，要把删除标记的元素物理删除。</p> 
</blockquote> 
<h4 id="6.3.2%20%E6%8B%89%E9%93%BE%E6%B3%95%EF%BC%88chaining%EF%BC%89"><span style="color:#38d8f0;"><strong>6.3.2 拉链法（chaining）</strong></span></h4> 
<p>        对于不同的关键字可能会通过散列函数映射到同一地址，为了避免非同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。假设散列地址为 i 的同义词链表的头指针存放在散列表的第 i 个单元中，因而查找、插入和删除操作主要在同义词链中进行。<span style="color:#0d0016;"><strong>拉链法适用于经常进行插入和删除的情况</strong></span>。</p> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/9d/d1/YNkUlimE_o.png" width="418"></p> 
<p>      <span style="color:#0d0016;"><strong>  例如上图</strong></span>：关键字序列为{19,14,23,01,68,20,84,27,55,11,10,79}；散列函数 H(key) = key % 13，用拉链法处理冲突，建立的表如上图；</p> 
<h3 id="6.4%20%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span style="color:#4da8ee;"><strong>6.4 散列查找及性能分析</strong></span></h3> 
<p>        散列表的查找过程与构造散列表的过程基本一致。对于一个给定的关键字key，根据散列函数可以计算出其散列地址，执行步骤如下：</p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>        初始化：Addr = Hash(key) ；</strong></span></p> 
 <p><span style="color:#0d0016;"><strong>        ①：检测查找表中地址为 Addr 的位置上是否有记录，若无记录，返回查找失败；若有记录，比较它与 key 的值，若相等，则返回查找成功的标志，否则执行步骤②。</strong></span></p> 
 <p><span style="color:#0d0016;"><strong>        ②：用给定的处理冲突方法计算 “下一散列地址” ，并把 Addr 置为此地址，转入步骤 ①。</strong></span></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>例如：</strong></span></p> 
 <p>        关键字序列{19, 14, 23, 01,68,20, 84, 27, 55, 11, 10, 79}按散列函数 H(key) = key % 13 和线性探测处理冲突构造所得的散列表 L如下：</p> 
 <p class="img-center"><img alt="" height="150" src="https://images2.imgbox.com/3b/3d/EgTc5LMc_o.png" width="1036"></p> 
 <p>  <span style="color:#0d0016;"><strong>      给定值 84 的查找过程</strong></span>：首先求得散列地址 H(84) = 6，因 L[6] 不空且 L[6] ≠ 84，则找第一次冲突处理后的地址 <img alt="H_{1}" class="mathcode" src="https://images2.imgbox.com/b5/f6/Cua5QBPE_o.png"> = (6+1) %16 = 7，而L[7]不空且 L[7] ≠ 84，则找第二次冲突处理后的地址 <img alt="H_{2}" class="mathcode" src="https://images2.imgbox.com/3d/4f/vKw2idui_o.png"> = (6+2) %16 = 8，L[8] 不空且 L[8] = 84，查找成功，返回记录在上表中的序号 8；</p> 
 <p>        <span style="color:#0d0016;"><strong>给定值 38 的查找过程</strong></span>：先求散列地址 H(38) = 12，L(12) 不空且 L[12] ≠ 38，则找下一地址 <img alt="H_{1}" class="mathcode" src="https://images2.imgbox.com/17/34/63JHVEMW_o.png"> = (12+1) % 16 = 13，由于 L[13] 是空记录，故表中不存在关键字为 38 的记录。</p> 
 <p>        查找各关键字的比较次数如下：</p> 
 <p class="img-center"><img alt="" height="150" src="https://images2.imgbox.com/bd/ee/IiubyzPW_o.png" width="908"></p> 
 <p><span style="color:#0d0016;"><strong>平均查找长度 ASL 为</strong></span></p> 
 <p style="text-align:center;"><span style="color:#0d0016;"><strong>ASL = (1*6+2+3*3+4+9)/12 = 2.5</strong></span></p> 
</blockquote> 
<p><span style="color:#1c7331;"><strong>从散列表的查找过程可见：</strong></span></p> 
<p>        1. 虽然散列表在关键字与记录的存储位置之间建立了直接映像，但由于"冲突"的产生， 使得散列表的查找过程仍然是一个给定值和关键字进行比较的过程。因此，<span style="color:#0d0016;"><strong>仍需要以平均查找长度作为衡量散列表的查找效率的度量</strong></span>。</p> 
<p>        2. 散列表的查找效率取决于三个因素：<span style="color:#0d0016;"><strong>散列函数、处理冲突的方法和装填因子</strong></span>。</p> 
<p><span style="color:#fe2c24;"><strong>装填因子</strong></span>：散列表的装填因子一般记为a ,定义为一个表的装满程度，即</p> 
<p class="img-center"><img alt="" height="100" src="https://images2.imgbox.com/3a/2e/sdG3N9xa_o.png" width="824"></p> 
<p>        <span style="color:#0d0016;"><strong>散列表的平均查找长度依赖于散列表的装填因子 a ，而不直接依赖于 n 或 m</strong></span> 。直观地看，a 越大，表示装填的记录越满，发生冲突的可能性越大，反之发生冲突的可能性越小。</p> 
<h3 id="6.5%20%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0"><span style="color:#4da8ee;"><strong>6.5 相关练习</strong></span></h3> 
<p class="img-center"><img alt="" height="700" src="https://images2.imgbox.com/ca/9b/ectc0MFL_o.png" width="1200"></p> 
<p><img alt="" height="768" src="https://images2.imgbox.com/b2/84/ENeUuCwj_o.png" width="1200"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/89e59de378e6449c1bc004ec3932de56/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Kafka的工作原理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ef8fce7832076240866c7ef5ab9b3245/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Midjourney的一些“咒语”【自用-1】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>