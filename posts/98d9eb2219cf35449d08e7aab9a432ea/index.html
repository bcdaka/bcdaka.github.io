<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;航海王：追寻罗杰的编程之路】智能指针 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/98d9eb2219cf35449d08e7aab9a432ea/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="【C&#43;&#43;航海王：追寻罗杰的编程之路】智能指针">
  <meta property="og:description" content="目录
1 -&gt; 为什么需要智能指针？
2 -&gt; 内存泄漏
2.1 -&gt;什么是内存泄漏，以及内存泄漏的危害
2.2 -&gt; 内存泄漏分类
2.3 -&gt; 如何避免内存泄漏
3 -&gt; 智能指针的使用及原理
3.1 -&gt; RAII
3.2 -&gt; 智能指针的原理
3.3 -&gt; std::auto_ptr
3.4 -&gt; std::unique_ptr
3.5 -&gt; std::shared_ptr
4 -&gt; C&#43;&#43;11和boost中智能指针的关系
1 -&gt; 为什么需要智能指针？ 先分析下面这段程序有没有什么内存方面的问题？
#define _CRT_SECURE_NO_WARNINGS 1 #include &lt;iostream&gt; using namespace std; int div() { int a, b; cin &gt;&gt; a &gt;&gt; b; if (b == 0) throw invalid_argument(&#34;除0错误&#34;); return a / b; } void Func() { // 1、如果p1这里new 抛异常会如何？ // 2、如果p2这里new 抛异常会如何？ // 3、如果div调用这里又会抛异常会如何？ int* p1 = new int; int* p2 = new int; cout &lt;&lt; div() &lt;&lt; endl; delete p1; delete p2; } int main() { try { Func(); } catch (exception&amp; e) { cout &lt;&lt; e.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-16T16:37:03+08:00">
    <meta property="article:modified_time" content="2024-07-16T16:37:03+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;航海王：追寻罗杰的编程之路】智能指针</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><span style="color:#e6b223;"><strong>目录</strong></span></p> 
<p id="1%20-%3E%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9F-toc" style="margin-left:0px;"><strong><a href="#1%20-%3E%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9F" rel="nofollow"><span style="color:#e6b223;">1 -&gt; 为什么需要智能指针？</span></a></strong></p> 
<p id="2%20-%3E%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F-toc" style="margin-left:0px;"><strong><a href="#2%20-%3E%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F" rel="nofollow"><span style="color:#e6b223;">2 -&gt; 内存泄漏</span></a></strong></p> 
<p id="2.1%20-%3E%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8D%B1%E5%AE%B3-toc" style="margin-left:40px;"><strong><a href="#2.1%20-%3E%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8D%B1%E5%AE%B3" rel="nofollow"><span style="color:#e6b223;">2.1 -&gt;什么是内存泄漏，以及内存泄漏的危害</span></a></strong></p> 
<p id="2.2%20-%3E%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E7%B1%BB-toc" style="margin-left:40px;"><strong><a href="#2.2%20-%3E%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E7%B1%BB" rel="nofollow"><span style="color:#e6b223;">2.2 -&gt; 内存泄漏分类</span></a></strong></p> 
<p id="2.3%20-%3E%20%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F-toc" style="margin-left:40px;"><strong><a href="#2.3%20-%3E%20%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F" rel="nofollow"><span style="color:#e6b223;">2.3 -&gt; 如何避免内存泄漏</span></a></strong></p> 
<p id="3%20-%3E%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86-toc" style="margin-left:0px;"><strong><a href="#3%20-%3E%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86" rel="nofollow"><span style="color:#e6b223;">3 -&gt; 智能指针的使用及原理</span></a></strong></p> 
<p id="3.1%20-%3E%20RAII-toc" style="margin-left:40px;"><strong><a href="#3.1%20-%3E%20RAII" rel="nofollow"><span style="color:#e6b223;">3.1 -&gt; RAII</span></a></strong></p> 
<p id="3.2%20-%3E%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><strong><a href="#3.2%20-%3E%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%8E%9F%E7%90%86" rel="nofollow"><span style="color:#e6b223;">3.2 -&gt; 智能指针的原理</span></a></strong></p> 
<p id="3.3%20-%3E%20std%3A%3Aauto_ptr-toc" style="margin-left:40px;"><strong><a href="#3.3%20-%3E%20std%3A%3Aauto_ptr" rel="nofollow"><span style="color:#e6b223;">3.3 -&gt; std::auto_ptr</span></a></strong></p> 
<p id="3.4%20-%3E%20std%3A%3Aunique_ptr-toc" style="margin-left:40px;"><strong><a href="#3.4%20-%3E%20std%3A%3Aunique_ptr" rel="nofollow"><span style="color:#e6b223;">3.4 -&gt; std::unique_ptr</span></a></strong></p> 
<p id="3.5%20-%3E%20std%3A%3Ashared_ptr-toc" style="margin-left:40px;"><strong><a href="#3.5%20-%3E%20std%3A%3Ashared_ptr" rel="nofollow"><span style="color:#e6b223;">3.5 -&gt; std::shared_ptr</span></a></strong></p> 
<p id="4%20-%3E%20C%2B%2B11%E5%92%8Cboost%E4%B8%AD%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB-toc" style="margin-left:0px;"><strong><a href="#4%20-%3E%20C%2B%2B11%E5%92%8Cboost%E4%B8%AD%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB" rel="nofollow"><span style="color:#e6b223;">4 -&gt; C++11和boost中智能指针的关系</span></a></strong></p> 
<hr id="hr-toc"> 
<p class="img-center"><img alt="" height="595" src="https://images2.imgbox.com/d6/7d/N66w2Woc_o.png" width="738"></p> 
<h2 id="1%20-%3E%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9F">1 -&gt; 为什么需要智能指针？</h2> 
<p><span style="color:#6eaad7;">先分析下面这段程序有没有什么<strong>内存方面</strong>的问题？</span></p> 
<pre><code class="hljs">#define _CRT_SECURE_NO_WARNINGS 1

#include &lt;iostream&gt;
using namespace std;

int div()
{
	int a, b;

	cin &gt;&gt; a &gt;&gt; b;
	if (b == 0)
		throw invalid_argument("除0错误");

	return a / b;
}
void Func()
{
	// 1、如果p1这里new 抛异常会如何？
	// 2、如果p2这里new 抛异常会如何？
	// 3、如果div调用这里又会抛异常会如何？
	int* p1 = new int;
	int* p2 = new int;

	cout &lt;&lt; div() &lt;&lt; endl;

	delete p1;
	delete p2;
}
int main()
{
	try
	{
		Func();
	}
	catch (exception&amp; e)
	{
		cout &lt;&lt; e.what() &lt;&lt; endl;
	}
	return 0;
}</code></pre> 
<h2 id="2%20-%3E%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">2 -&gt; 内存泄漏</h2> 
<h3 id="2.1%20-%3E%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8D%B1%E5%AE%B3">2.1 -&gt;什么是内存泄漏，以及内存泄漏的危害</h3> 
<p><span style="color:#6eaad7;">什么是内存泄漏：内存泄漏是指因为疏忽或者错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并不是指内存在物理上的消失，而是应用程序分配某段内存后，因为设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</span></p> 
<p><span style="color:#6eaad7;">内存泄漏的危害：长期运行的程序出现内存泄漏，影响很大，如操作系统、后台服务等等，出现内存泄漏会导致响应越来越慢，最终卡死。</span></p> 
<pre><code class="hljs">void MemoryLeaks()
{
	// 1.内存申请了忘记释放
	int* p1 = (int*)malloc(sizeof(int));
	int* p2 = new int;

	// 2.异常安全问题
	int* p3 = new int[10];

	Func(); // 这里Func函数抛异常导致 delete[] p3未执行，p3没被释放.

	delete[] p3;
}</code></pre> 
<h3 id="2.2%20-%3E%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E7%B1%BB">2.2 -&gt; 内存泄漏分类</h3> 
<p><span style="color:#6eaad7;"><strong>C/C++程序中一般关心两种方面的内存泄漏：</strong></span></p> 
<ul><li><span style="color:#ed7976;"><strong>堆内存泄漏(Heap Leak)</strong></span></li></ul> 
<p><span style="color:#6eaad7;">堆内存指的是程序执行中依据须要分配通过malloc/calloc/realloc/new等从堆中分配的一块内存，用完后必须通过调用相应的free或者delete删掉。假设程序的设计错误导致这部分内存没有被释放，那么以后这部分空间将无法再次被使用，就会产生Heap Leak。</span></p> 
<ul><li><span style="color:#ed7976;"><strong>系统资源泄漏</strong></span></li></ul> 
<p><span style="color:#6eaad7;">指程序使用系统分配的资源，比如套接字、文件描述符、管道等没有使用对应的函数释放掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定。 </span></p> 
<h3 id="2.3%20-%3E%20%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">2.3 -&gt; 如何避免内存泄漏</h3> 
<ol><li><span style="color:#6eaad7;">工程前期良好的设计规范，养成良好的编码规范，申请的内存空间记得释放。ps：这个是理想状态。但是如果碰上异常时，就算注意释放了，还是可能会出问题。需要下一条智能指针来管理才有保证。</span></li><li><span style="color:#6eaad7;">采用RAII思想或者智能指针来管理资源。</span></li><li><span style="color:#6eaad7;">有些公司内部规范使用内部实现的私有内存管理库。这套库自带内存泄漏检测的功能选项。</span></li><li><span style="color:#6eaad7;">出问题了使用内存泄漏工具检测。ps：不过很多工具都不靠谱，或者收费昂贵。</span></li></ol> 
<p><span style="color:#6eaad7;">总结：</span></p> 
<p><span style="color:#6eaad7;">内存泄漏非常常见，解决方案分为两种：</span></p> 
<ol><li><span style="color:#6eaad7;">事前预防型。如智能指针等；</span></li><li><span style="color:#6eaad7;">事后查错型。如泄漏检测工具。</span></li></ol> 
<h2 id="3%20-%3E%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86">3 -&gt; 智能指针的使用及原理</h2> 
<h3 id="3.1%20-%3E%20RAII">3.1 -&gt; RAII</h3> 
<p><span style="color:#6eaad7;">RAII(Resource Acquisition Is Initialization)是一种<strong>利用对象生命周期来控制程序资源</strong>(如内存、文件句柄、网络连接、互斥量等等)的简单技术。</span></p> 
<p><span style="color:#6eaad7;"><strong>在对象构造时获取资源</strong>，接着控制对资源的访问使之在对象的生命周期内始终保持有效，<strong>最后在对象析构的时候释放资源</strong>。借此，实际上把管理一份资源的责任托管给了一个对象。这种做法有两大好处：</span></p> 
<ul><li><span style="color:#6eaad7;">不需要显式地释放资源。</span></li><li><span style="color:#6eaad7;">采用这种方式，对象所需的资源在其生命周期内始终保持有效。</span></li></ul> 
<pre><code class="hljs">// 使用RAII思想设计的SmartPtr类
template&lt;class T&gt;
class SmartPtr {
public:
	SmartPtr(T* ptr = nullptr)
		: _ptr(ptr)
	{}
	~SmartPtr()
	{
		if (_ptr)
			delete _ptr;
	}

private:
	T* _ptr;
};

int div()
{
	int a, b;

	cin &gt;&gt; a &gt;&gt; b;
	if (b == 0)
		throw invalid_argument("除0错误");

	return a / b;
}
void Func()
{
	SmartPtr&lt;int&gt; sp1(new int);
	SmartPtr&lt;int&gt; sp2(new int);

	cout &lt;&lt; div() &lt;&lt; endl;
}

int main()
{
	try 
	{
		Func();
	}
	catch (const exception&amp; e)
	{
		cout &lt;&lt; e.what() &lt;&lt; endl;
	}
	return 0;
}</code></pre> 
<h3 id="3.2%20-%3E%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%8E%9F%E7%90%86">3.2 -&gt; 智能指针的原理</h3> 
<p><span style="color:#6eaad7;">上述的SmartPtr还不能将其称为智能指针，因为它还不具有指针的行为。指针可以解引用，也可以通过-&gt;去访问所指空间中的内容，因此：<strong>AutoPtr模板类中还需要将*、-&gt;重载下，才可以让其像指针一样去使用。</strong></span></p> 
<pre><code class="hljs">template&lt;class T&gt;
class SmartPtr {
public:
	SmartPtr(T* ptr = nullptr)
		: _ptr(ptr)
	{}
	~SmartPtr()
	{
		if (_ptr)
			delete _ptr;
	}

	T&amp; operator*() { return *_ptr; }
	T* operator-&gt;() { return _ptr; }

private:
	T* _ptr;
};

struct Date
{
	int _year;
	int _month;
	int _day;
};

int main()
{
	SmartPtr&lt;int&gt; sp1(new int);
	*sp1 = 10;

	cout &lt;&lt; *sp1 &lt;&lt; endl;

	SmartPtr&lt;Date&gt; sparray(new Date);

	// 需要注意的是这里应该是sparray.operator-&gt;()-&gt;_year = 2018;
	// 本来应该是sparray-&gt;-&gt;_year这里语法上为了可读性，省略了一个-&gt;
	sparray-&gt;_year = 2018;
	sparray-&gt;_month = 1;
	sparray-&gt;_day = 1;
}</code></pre> 
<p><strong><span style="color:#6eaad7;">总结一下智能指针的原理：</span></strong></p> 
<ol><li><strong><span style="color:#6eaad7;">RAII特性</span></strong></li><li><strong><span style="color:#6eaad7;">重载operator*和operator-&gt;，具有像指针一样的行为。</span></strong></li></ol> 
<h3 id="3.3%20-%3E%20std%3A%3Aauto_ptr">3.3 -&gt; std::auto_ptr</h3> 
<p class="img-center"><img alt="" height="741" src="https://images2.imgbox.com/4f/44/CfiU2QgQ_o.png" width="1200"></p> 
<p> <a class="link-info" href="https://cplusplus.com/reference/memory/auto_ptr/" rel="nofollow" title="std::auto_ptr文档介绍">std::auto_ptr文档介绍</a></p> 
<p><span style="color:#6eaad7;"><strong>C++98版本的库中就提供了auto_ptr的智能指针。下面演示auto_ptr的使用及问题。</strong></span></p> 
<p><span style="color:#6eaad7;"><strong>auto_ptr的实现原理：管理权转移的思想，下面简化模拟实现了一份fyd::auto_ptr来了解它的原理。 </strong></span> </p> 
<pre><code class="hljs">// C++98 管理权转移 auto_ptr
namespace fyd
{
	template&lt;class T&gt;
	class auto_ptr
	{
	public:
		auto_ptr(T* ptr)
			:_ptr(ptr)
		{}

		auto_ptr(auto_ptr&lt;T&gt;&amp; sp)
			:_ptr(sp._ptr)
		{
			// 管理权转移
			sp._ptr = nullptr;
		}

		auto_ptr&lt;T&gt;&amp; operator=(auto_ptr&lt;T&gt;&amp; ap)
		{
			// 检测是否为自己给自己赋值
			if (this != &amp;ap)
			{
				// 释放当前对象中资源
				if (_ptr)
					delete _ptr;

				// 转移ap中资源到当前对象中
				_ptr = ap._ptr;
				ap._ptr = NULL;
			}
			return *this;
		}

		~auto_ptr()
		{
			if (_ptr)
			{
				cout &lt;&lt; "delete:" &lt;&lt; _ptr &lt;&lt; endl;
				delete _ptr;
			}
		}

		// 像指针一样使用
		T&amp; operator*()
		{
			return *_ptr;
		}

		T* operator-&gt;()
		{
			return _ptr;
		}

	private:
		T* _ptr;
	};
}

//int main()
//{
// std::auto_ptr&lt;int&gt; sp1(new int);
// std::auto_ptr&lt;int&gt; sp2(sp1); // 管理权转移
//
// // sp1悬空
// *sp2 = 10;
// cout &lt;&lt; *sp2 &lt;&lt; endl;
// cout &lt;&lt; *sp1 &lt;&lt; endl;
// 
// return 0;
//}</code></pre> 
<p><strong><span style="color:#6eaad7;">结论：auto_ptr是一个失败的设计，很多公司明确要求不能使用auto_ptr。</span></strong></p> 
<h3 id="3.4%20-%3E%20std%3A%3Aunique_ptr">3.4 -&gt; std::unique_ptr</h3> 
<p class="img-center"><img alt="" height="1114" src="https://images2.imgbox.com/aa/3b/42jICzms_o.png" width="1200"></p> 
<p><a class="link-info" href="https://cplusplus.com/reference/memory/unique_ptr/" rel="nofollow" title="std::unique_ptr文档介绍">std::unique_ptr文档介绍</a> </p> 
<p><span style="color:#6eaad7;"><strong>C++11中开始提供更靠谱的unique_ptr。</strong></span></p> 
<p><span style="color:#6eaad7;"><strong>unique_ptr的实现原理：简单粗暴的防拷贝，下面简化实现了一份fyd::unique_ptr来了解它的原理。</strong></span></p> 
<pre><code class="hljs">// C++11库才更新智能指针实现
// C++11出来之前，boost搞除了更好用的scoped_ptr/shared_ptr/weak_ptr
// C++11将boost库中智能指针精华部分吸收了过来
// C++11-&gt;unique_ptr/shared_ptr/weak_ptr
// unique_ptr/scoped_ptr
// 原理：简单粗暴 -- 防拷贝
namespace fyd
{
	template&lt;class T&gt;
	class unique_ptr
	{
	public:
		unique_ptr(T* ptr)
			:_ptr(ptr)
		{}

		~unique_ptr()
		{
			if (_ptr)
			{
				cout &lt;&lt; "delete:" &lt;&lt; _ptr &lt;&lt; endl;
				delete _ptr;
			}
		}

		// 像指针一样使用
		T&amp; operator*()
		{
			return *_ptr;
		}

		T* operator-&gt;()
		{
			return _ptr;
		}

		unique_ptr(const unique_ptr&lt;T&gt;&amp;sp) = delete;
		unique_ptr&lt;T&gt;&amp; operator=(const unique_ptr&lt;T&gt;&amp;sp) = delete;

	private:
		T* _ptr;
	};
}

//int main()
//{
// fyd::unique_ptr&lt;int&gt; sp1(new int);
// fyd::unique_ptr&lt;int&gt; sp2(sp1);
//
// std::unique_ptr&lt;int&gt; sp1(new int);
// std::unique_ptr&lt;int&gt; sp2(sp1);
//
// return 0;
//}</code></pre> 
<h3 id="3.5%20-%3E%20std%3A%3Ashared_ptr">3.5 -&gt; std::shared_ptr</h3> 
<p class="img-center"><img alt="" height="1098" src="https://images2.imgbox.com/54/27/SXloUUxc_o.png" width="1200"></p> 
<p><a class="link-info" href="https://cplusplus.com/reference/memory/shared_ptr/" rel="nofollow" title="std::shared_ptr文档介绍">std::shared_ptr文档介绍</a></p> 
<p><span style="color:#6eaad7;"><strong>C++11中开始提供更靠谱的并且支持拷贝的shared_ptr。</strong></span></p> 
<p><span style="color:#6eaad7;"><strong>shared_ptr的原理：通过引用计数的方式来实现多个shared_ptr对象之间共享资源。</strong></span></p> 
<ol><li><span style="color:#6eaad7;">shared_ptr在其内部，<strong>给每个资源都维护一份计数，用来记录该份资源被几个对象共享。</strong></span></li><li><span style="color:#6eaad7;">在<strong>对象销毁时(也就是析构函数调用)</strong>，就说明自己不使用该资源了，对象的引用计数减一。</span></li><li><span style="color:#6eaad7;"><strong>如果引用计数是0</strong>，就说明自己是最后一个使用该资源的对象，<strong>必须释放该资源</strong>。</span></li><li><span style="color:#6eaad7;"><strong>如果不是0</strong>，就说明除了自己还有其他对象在使用该份资源，<strong>不能释放该资源</strong>，否则其他对象就成野指针了。</span></li></ol> 
<pre><code class="hljs">// 引用计数支持多个拷贝管理同一个资源，最后一个析构对象释放资源
namespace fyd
{
	template&lt;class T&gt;
	class shared_ptr
	{
	public:
		shared_ptr(T* ptr = nullptr)
			:_ptr(ptr)
			, _pRefCount(new int(1))
			, _pmtx(new mutex)
		{}
		shared_ptr(const shared_ptr&lt;T&gt;&amp; sp)
			:_ptr(sp._ptr)
			, _pRefCount(sp._pRefCount)
			, _pmtx(sp._pmtx)
		{
			AddRef();
		}

		void Release()
		{
			_pmtx-&gt;lock();
			bool flag = false;
			if (--(*_pRefCount) == 0 &amp;&amp; _ptr)
			{
				cout &lt;&lt; "delete:" &lt;&lt; _ptr &lt;&lt; endl;
				delete _ptr;
				delete _pRefCount;
				flag = true;
			}
			_pmtx-&gt;unlock();
			if (flag == true)
			{
				delete _pmtx;
			}
		}

		void AddRef()
		{
			_pmtx-&gt;lock();
			++(*_pRefCount);
			_pmtx-&gt;unlock();
		}

		shared_ptr&lt;T&gt;&amp; operator=(const shared_ptr&lt;T&gt;&amp; sp)
		{
			//if (this != &amp;sp)
			if (_ptr != sp._ptr)
			{
				Release();
				_ptr = sp._ptr;
				_pRefCount = sp._pRefCount;
				_pmtx = sp._pmtx;
				AddRef();
			}

			return *this;
		}

		int use_count()
		{
			return *_pRefCount;
		}

		~shared_ptr()
		{
			Release();
		}

		// 像指针一样使用
		T&amp; operator*()
		{
			return *_ptr;
		}

		T* operator-&gt;()
		{
			return _ptr;
		}

		T* get() const
		{
			return _ptr;
		}

	private:
		T* _ptr;
		int* _pRefCount;
		mutex* _pmtx;
	};

	// 简化版本的weak_ptr实现
	template&lt;class T&gt;
	class weak_ptr
	{
	public:
		weak_ptr()
			:_ptr(nullptr)
		{}
		weak_ptr(const shared_ptr&lt;T&gt;&amp; sp)
			:_ptr(sp.get())
		{}

		weak_ptr&lt;T&gt;&amp; operator=(const shared_ptr&lt;T&gt;&amp; sp)
		{
			_ptr = sp.get();
			return *this;
		}

		T&amp; operator*()
		{
			return *_ptr;
		}

		T* operator-&gt;()
		{
			return _ptr;
		}

	private:
		T* _ptr;
	};
}
// shared_ptr智能指针是线程安全的吗？
// 是的，引用计数的加减是加锁保护的。但是指向资源不是线程安全的
// 指向堆上资源的线程安全问题是访问的人处理的，智能指针不管，也管不了
// 引用计数的线程安全问题，是智能指针要处理的
//int main()
//{
// fyd::shared_ptr&lt;int&gt; sp1(new int);
// fyd::shared_ptr&lt;int&gt; sp2(sp1);
// fyd::shared_ptr&lt;int&gt; sp3(sp1);
//
// fyd::shared_ptr&lt;int&gt; sp4(new int);
// fyd::shared_ptr&lt;int&gt; sp5(sp4);
//
// sp1 = sp1;
// sp1 = sp2;
//
// sp1 = sp4;
// sp2 = sp4;
// sp3 = sp4;
//
// *sp1 = 2;
// *sp2 = 3;
//
// return 0;
//}</code></pre> 
<p><span style="color:#6eaad7;"><strong>std::shared_ptr的线程安全问题</strong></span></p> 
<p><span style="color:#6eaad7;">通过下面的程序可以测试shared_ptr的线程安全问题。需要注意的是shared_ptr的线程安全分为两个方面：</span></p> 
<ol><li><span style="color:#6eaad7;">智能指针对象中引用计数是多个智能指针对象共享的，两个线程中智能指针的引用计数同时++或--，引用计数原来是1，++了两次，可能还是2。这样引用计数就错乱了。会导致资源未释放或者程序崩溃的问题。所以只能指针中引用计数++、--是需要加锁的，也就是说引用计数的操作是线程安全的。</span></li><li><span style="color:#6eaad7;">智能指针管理的对象存放在堆上，两个线程中同时去访问，会导致线程安全问题。</span></li></ol> 
<pre><code class="hljs">// 1.演示引用计数线程安全问题，就把AddRefCount和SubRefCount中的锁去掉
// 2.演示可能不出现线程安全问题，因为线程安全问题是偶现性问题，main函数的n改大一些概率就变大了，就容易出现了。
// 3.下面代码我们使用SharedPtr演示，是为了方便演示引用计数的线程安全问题，
// 将代码中的SharedPtr换成shared_ptr进行测试，可以验证库的shared_ptr，发现结论是一样的。
namespace fyd
{
	template&lt;class T&gt;
	class shared_ptr
	{
	public:
		shared_ptr(T* ptr = nullptr)
			:_ptr(ptr)
			, _pRefCount(new int(1))
			, _pmtx(new mutex)
		{}
		shared_ptr(const shared_ptr&lt;T&gt;&amp; sp)
			:_ptr(sp._ptr)
			, _pRefCount(sp._pRefCount)
			, _pmtx(sp._pmtx)
		{
			AddRef();
		}

		void Release()
		{
			_pmtx-&gt;lock();
			bool flag = false;
			if (--(*_pRefCount) == 0 &amp;&amp; _ptr)
			{
				cout &lt;&lt; "delete:" &lt;&lt; _ptr &lt;&lt; endl;
				delete _ptr;
				delete _pRefCount;
				flag = true;
			}
			_pmtx-&gt;unlock();
			if (flag == true)
			{
				delete _pmtx;
			}
		}

		void AddRef()
		{
			_pmtx-&gt;lock();
			++(*_pRefCount);
			_pmtx-&gt;unlock();
		}

		shared_ptr&lt;T&gt;&amp; operator=(const shared_ptr&lt;T&gt;&amp; sp)
		{
			//if (this != &amp;sp)
			if (_ptr != sp._ptr)
			{
				Release();
				_ptr = sp._ptr;
				_pRefCount = sp._pRefCount;
				_pmtx = sp._pmtx;
				AddRef();
			}

			return *this;
		}

		int use_count()
		{
			return *_pRefCount;
		}

		~shared_ptr()
		{
			Release();
		}

		// 像指针一样使用
		T&amp; operator*()
		{
			return *_ptr;
		}

		T* operator-&gt;()
		{
			return _ptr;
		}

		T* get() const
		{
			return _ptr;
		}

	private:
		T* _ptr;
		int* _pRefCount;
		mutex* _pmtx;
	};

	// 简化版本的weak_ptr实现
	template&lt;class T&gt;
	class weak_ptr
	{
	public:
		weak_ptr()
			:_ptr(nullptr)
		{}
		weak_ptr(const shared_ptr&lt;T&gt;&amp; sp)
			:_ptr(sp.get())
		{}

		weak_ptr&lt;T&gt;&amp; operator=(const shared_ptr&lt;T&gt;&amp; sp)
		{
			_ptr = sp.get();
			return *this;
		}

		T&amp; operator*()
		{
			return *_ptr;
		}

		T* operator-&gt;()
		{
			return _ptr;
		}

	private:
		T* _ptr;
	};
}

struct Date
{
	int _year = 0;
	int _month = 0;
	int _day = 0;
};

void SharePtrFunc(fyd::shared_ptr&lt;Date&gt;&amp; sp, size_t n, mutex&amp; mtx)
{
	cout &lt;&lt; sp.get() &lt;&lt; endl;
	for (size_t i = 0; i &lt; n; ++i)
	{
		// 这里智能指针拷贝会++计数，智能指针析构会--计数，这里是线程安全的。
		fyd::shared_ptr&lt;Date&gt; copy(sp);
		// 这里智能指针访问管理的资源，不是线程安全的。
		// 所以我们看看这些值两个线程++了2n次，但是最终看到的结果，并一定是加了2n
		{
		unique_lock&lt;mutex&gt; lk(mtx);
		copy-&gt;_year++;
		copy-&gt;_month++;
		copy-&gt;_day++;
		}
	}
}

int main()
{
	fyd::shared_ptr&lt;Date&gt; p(new Date);

	cout &lt;&lt; p.get() &lt;&lt; endl;

	const size_t n = 100000;
	mutex mtx;

	thread t1(SharePtrFunc, std::ref(p), n, std::ref(mtx));
	thread t2(SharePtrFunc, std::ref(p), n, std::ref(mtx));

	t1.join();
	t2.join();

	cout &lt;&lt; p-&gt;_year &lt;&lt; endl;
	cout &lt;&lt; p-&gt;_month &lt;&lt; endl;
	cout &lt;&lt; p-&gt;_day &lt;&lt; endl;
	cout &lt;&lt; p.use_count() &lt;&lt; endl;

	return 0;
}</code></pre> 
<p><span style="color:#6eaad7;"><strong>std::shared_ptr的循环引用</strong></span></p> 
<pre><code class="hljs">struct ListNode
{
	int _data;

	shared_ptr&lt;ListNode&gt; _prev;
	shared_ptr&lt;ListNode&gt; _next;

	~ListNode() { cout &lt;&lt; "~ListNode()" &lt;&lt; endl; }
};

int main()
{
	shared_ptr&lt;ListNode&gt; node1(new ListNode);
	shared_ptr&lt;ListNode&gt; node2(new ListNode);

	cout &lt;&lt; node1.use_count() &lt;&lt; endl;
	cout &lt;&lt; node2.use_count() &lt;&lt; endl;

	node1-&gt;_next = node2;
	node2-&gt;_prev = node1;

	cout &lt;&lt; node1.use_count() &lt;&lt; endl;
	cout &lt;&lt; node2.use_count() &lt;&lt; endl;

	return 0;
}</code></pre> 
<p><span style="color:#6eaad7;"><strong>循环引用分析：</strong></span></p> 
<ol><li><span style="color:#6eaad7;">node1和node2两个智能指针对象指向两个节点，引用计数变成1，我们不需要手动delete。</span></li><li><span style="color:#6eaad7;">node1的_next指向node2，node2的_prev指向node1，引用计数变成2。</span></li><li><span style="color:#6eaad7;">node1和node2析构，引用计数减到1，但是_next还指向下一个节点，_prev还指向上一个节点。</span></li><li><span style="color:#6eaad7;">也就是说_next析构了，node2就释放了。</span></li><li><span style="color:#6eaad7;">也就是说_prev析构了，node1就释放了。</span></li><li><span style="color:#6eaad7;">但是_next属于node的成员，node1释放了，_next才会析构，而node1由_prev管理，_prev属于node2成员，所以这就叫循环引用，谁也不释放。</span></li></ol> 
<p class="img-center"><img alt="" height="715" src="https://images2.imgbox.com/59/2c/HCkQrhk5_o.png" width="1200"></p> 
<pre><code class="hljs">// 解决方案：在引用计数的场景下，把节点中的_prev和_next改成weak_ptr就可以了
// 原理就是，node1-&gt;_next = node2;和node2-&gt;_prev = node1;时
// weak_ptr的_next和_prev不会增加node1和node2的引用计数。
struct ListNode
{
	int _data;

	weak_ptr&lt;ListNode&gt; _prev;
	weak_ptr&lt;ListNode&gt; _next;

	~ListNode() { cout &lt;&lt; "~ListNode()" &lt;&lt; endl; }
};

int main()
{
	shared_ptr&lt;ListNode&gt; node1(new ListNode);
	shared_ptr&lt;ListNode&gt; node2(new ListNode);

	cout &lt;&lt; node1.use_count() &lt;&lt; endl;
	cout &lt;&lt; node2.use_count() &lt;&lt; endl;

	node1-&gt;_next = node2;
	node2-&gt;_prev = node1;

	cout &lt;&lt; node1.use_count() &lt;&lt; endl;
	cout &lt;&lt; node2.use_count() &lt;&lt; endl;

	return 0;
}</code></pre> 
<p><span style="color:#6eaad7;"><strong>如果不是new出来的对象如何通过智能指针管理呢？其实shared_ptr设计了一个删除器来解决这个问题。</strong></span></p> 
<pre><code class="hljs">// 仿函数的删除器
template&lt;class T&gt;
struct FreeFunc {
	void operator()(T* ptr)
	{
		cout &lt;&lt; "free:" &lt;&lt; ptr &lt;&lt; endl;
		free(ptr);
	}
};

template&lt;class T&gt;
struct DeleteArrayFunc {
	void operator()(T* ptr)
	{
		cout &lt;&lt; "delete[]" &lt;&lt; ptr &lt;&lt; endl;
		delete[] ptr;
	}
};

int main()
{
	FreeFunc&lt;int&gt; freeFunc;
	std::shared_ptr&lt;int&gt; sp1((int*)malloc(4), freeFunc);
	DeleteArrayFunc&lt;int&gt; deleteArrayFunc;
	std::shared_ptr&lt;int&gt; sp2((int*)malloc(4), deleteArrayFunc);

	std::shared_ptr&lt;int&gt; sp4(new int[10], [](int* p) {delete[] p; });
	std::shared_ptr&lt;FILE&gt; sp5(fopen("test.txt", "w"), [](FILE* p)
		{fclose(p); });

	return 0;
}</code></pre> 
<h2 id="4%20-%3E%20C%2B%2B11%E5%92%8Cboost%E4%B8%AD%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB">4 -&gt; C++11和boost中智能指针的关系</h2> 
<ol><li><span style="color:#6eaad7;">C++ 98中产生了第一个智能指针auto_ptr。</span></li><li><span style="color:#6eaad7;">C++ boost给出了更实用的scoped_ptr和shared_ptr和weak_ptr。</span></li><li><span style="color:#6eaad7;">C++ TR1，引入了shared_ptr等。不过值得注意的是TR1并不是标准版。</span></li><li><span style="color:#6eaad7;">C++11，引入了unique_ptr、shared_ptr和weak_ptr。需要注意的是unique_ptr对应boost的scoped_ptr。并且这些智能指针的实现原理是参考boost中的实现的。</span></li></ol> 
<hr> 
<p></p> 
<p></p> 
<p style="text-align:center;"><span style="color:#faa572;"><strong>感谢各位大佬支持！！！</strong></span></p> 
<p style="text-align:center;"><span style="color:#faa572;"><strong>互三啦！！！</strong></span></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e3b967b48570045b6c68d36b5316c1f7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">27.js实现鼠标拖拽</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5bea007557649ad82d5fafdfdcae66c6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mac如何查看cpu和显卡温度</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>