<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>QT之QTableWidget详细介绍 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/297292a01733f65bf6bcb71637dfb063/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="QT之QTableWidget详细介绍">
  <meta property="og:description" content="本文来自于学习QT时遇到QTableWidget类时进行总结的知识点，涵盖了QTableWidget主要函数。本人文笔有限，欢迎大家评论区讨论。
一、QTableWidget介绍 QTableWidget 类是 Qt 框架中的一个用于展示和编辑二维表格数据的控件。它是对 QTableView 和 QStandardItemModel 的进一步封装，提供了更为简便的接口来处理常见的表格操作需求。QTableWidget 特别适合于那些不需要使用复杂数据模型（如自定义模型与视图架构）的场景。
基本特性： 数据表示：QTableWidget 以行和列的形式组织数据，每个单元格由一个 QTableWidgetItem 对象表示，可以包含文本、图标或其他数据类型。简单易用：相比 QTableView，QTableWidget 提供了更多的直接操作方法，比如插入、删除行或列，以及直接访问和修改单元格内容。编辑功能：用户可以直接在表格中编辑单元格内容，支持文本编辑、复选框、按钮等多种编辑模式。表头管理：可以自定义行列表头，行列表头默认是不可编辑的，用于标识各列或行的数据含义。选择模式：支持多种选择模式，如单选、多选、行选或列选等。信号与槽：QTableWidget 支持Qt的信号与槽机制，可以轻松地响应用户交互，比如单元格点击、内容改变等事件。 常用操作： 初始化与填充数据：可以通过构造函数创建一个空的表格，然后使用 setItem() 方法来填充单元格数据。动态管理行列：使用 insertRow(), insertColumn() 添加行或列，removeRow(), removeColumn() 删除行或列。获取与设置单元格内容：通过 item(row, column) 获取指定单元格的 QTableWidgetItem 对象，进而获取或修改其内容。事件处理：连接单元格的信号（如 cellClicked(), itemChanged()）到槽函数以响应用户操作。 注意事项： 虽然 QTableWidget 使用方便，但如果应用需要处理大量数据或者高度定制的数据模型，推荐使用 QTableView 结合 QAbstractTableModel 或 QStandardItemModel。QTableWidget 内部维护了一个数据模型，因此当表格数据量巨大时，可能不如直接使用模型/视图架构高效。 总的来说，QTableWidget 是开发桌面应用程序时处理和展示表格数据的一个强大且易于使用的工具。
二、成员函数 1、QTableWidget::QTableWidget(int rows, int columns, QWidget *parent = nullptr) 这个构造函数是用于创建一个具有指定行数和列数的 QTableWidget 实例。它允许你在初始化表格时就设定好初始的行数和列数，从而立即准备好用于填充数据的结构。下面是这个构造函数的参数详细说明：
int rows: 指定表格初始化时的行数。这是一个非负整数，表示表格将拥有的行的数量。int columns: 指定表格初始化时的列数。同样，这是一个非负整数，表示表格的列的数量。QWidget *parent = nullptr: 这是一个可选参数，用于指定 QTableWidget 父组件。在Qt中，父组件负责管理其子组件的生命周期，包括内存管理和布局管理。如果未提供（即默认值 nullptr），则创建的 QTableWidget 是一个独立的顶级窗口部件。 示例代码：">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-28T10:51:37+08:00">
    <meta property="article:modified_time" content="2024-05-28T10:51:37+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">QT之QTableWidget详细介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>本文来自于学习QT时遇到QTableWidget类时进行总结的知识点，涵盖了QTableWidget主要函数。本人文笔有限，欢迎大家评论区讨论。</p> 
<h2>一、QTableWidget介绍</h2> 
<p>QTableWidget 类是 Qt 框架中的一个用于展示和编辑二维表格数据的控件。它是对 QTableView 和 QStandardItemModel 的进一步封装，提供了更为简便的接口来处理常见的表格操作需求。QTableWidget 特别适合于那些不需要使用复杂数据模型（如自定义模型与视图架构）的场景。</p> 
<h4>基本特性：</h4> 
<ol><li><strong>数据表示</strong>：QTableWidget 以行和列的形式组织数据，每个单元格由一个 QTableWidgetItem 对象表示，可以包含文本、图标或其他数据类型。</li><li><strong>简单易用</strong>：相比 QTableView，QTableWidget 提供了更多的直接操作方法，比如插入、删除行或列，以及直接访问和修改单元格内容。</li><li><strong>编辑功能</strong>：用户可以直接在表格中编辑单元格内容，支持文本编辑、复选框、按钮等多种编辑模式。</li><li><strong>表头管理</strong>：可以自定义行列表头，行列表头默认是不可编辑的，用于标识各列或行的数据含义。</li><li><strong>选择模式</strong>：支持多种选择模式，如单选、多选、行选或列选等。</li><li><strong>信号与槽</strong>：QTableWidget 支持Qt的信号与槽机制，可以轻松地响应用户交互，比如单元格点击、内容改变等事件。</li></ol> 
<h4>常用操作：</h4> 
<ul><li><strong>初始化与填充数据</strong>：可以通过构造函数创建一个空的表格，然后使用 <code>setItem()</code> 方法来填充单元格数据。</li><li><strong>动态管理行列</strong>：使用 <code>insertRow()</code>, <code>insertColumn()</code> 添加行或列，<code>removeRow()</code>, <code>removeColumn()</code> 删除行或列。</li><li><strong>获取与设置单元格内容</strong>：通过 <code>item(row, column)</code> 获取指定单元格的 QTableWidgetItem 对象，进而获取或修改其内容。</li><li><strong>事件处理</strong>：连接单元格的信号（如 <code>cellClicked()</code>, <code>itemChanged()</code>）到槽函数以响应用户操作。</li></ul> 
<h4>注意事项：</h4> 
<ul><li>虽然 QTableWidget 使用方便，但如果应用需要处理大量数据或者高度定制的数据模型，推荐使用 QTableView 结合 QAbstractTableModel 或 QStandardItemModel。</li><li>QTableWidget 内部维护了一个数据模型，因此当表格数据量巨大时，可能不如直接使用模型/视图架构高效。</li></ul> 
<p>总的来说，QTableWidget 是开发桌面应用程序时处理和展示表格数据的一个强大且易于使用的工具。</p> 
<p></p> 
<h2>二、成员函数</h2> 
<h3>1、QTableWidget::QTableWidget(int <em>rows</em>, int <em>columns</em>, <a href="https://doc.qt.io/qt-5/qwidget.html#QWidget" rel="nofollow" title="QWidget">QWidget</a> *<em>parent</em> = nullptr)</h3> 
<p>这个构造函数是用于创建一个具有指定行数和列数的 QTableWidget 实例。它允许你在初始化表格时就设定好初始的行数和列数，从而立即准备好用于填充数据的结构。下面是这个构造函数的参数详细说明：</p> 
<blockquote> 
 <ul><li><code>int rows</code>: 指定表格初始化时的行数。这是一个非负整数，表示表格将拥有的行的数量。</li><li><code>int columns</code>: 指定表格初始化时的列数。同样，这是一个非负整数，表示表格的列的数量。</li><li><code>QWidget *parent = nullptr</code>: 这是一个可选参数，用于指定 QTableWidget 父组件。在Qt中，父组件负责管理其子组件的生命周期，包括内存管理和布局管理。如果未提供（即默认值 nullptr），则创建的 QTableWidget 是一个独立的顶级窗口部件。</li></ul> 
</blockquote> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    // 创建一个 3 行 4 列的 QTableWidget
    QTableWidget table(3, 4);

    // 设置表格的标题
    table.setWindowTitle("简易表格");

    // 显示表格
    table.show();

    return a.exec();
}</code></pre> 
<p>这段代码实例化了一个具有3行4列的QTableWidget，并设置了窗口标题为"简易表格"，最后显示了这个表格。</p> 
<p></p> 
<h3>2、QTableWidget::QTableWidget(<a href="https://doc.qt.io/qt-5/qwidget.html#QWidget" rel="nofollow" title="QWidget">QWidget</a> *<em>parent</em> = nullptr)</h3> 
<p>这个构造函数用于创建一个没有预设行数和列数的 QTableWidget 实例。与带有行数和列数参数的构造函数不同，使用这个构造函数初始化的 QTableWidget 默认是没有行和列的，你可以后续根据需要动态添加行和列。下面是该构造函数的参数说明：</p> 
<blockquote> 
 <ul><li><code>QWidget *parent = nullptr</code>: 同样是一个可选参数，用于指定 QTableWidget 的父窗口部件。如果提供，该QTableWidget将成为父窗口部件的孩子，享受自动内存管理和布局管理的好处；如果不提供（默认值 nullptr），则 QTableWidget 成为一个独立的顶级窗口。</li></ul> 
</blockquote> 
<p>使用这个构造函数创建的 QTableWidget 实例在开始时是空的，之后你可以通过调用如 <code>setRowCount()</code>、<code>setColumnCount()</code> 或者 <code>insertRow()</code>、<code>insertColumn()</code> 等方法来动态调整表格的大小。</p> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    // 创建一个空的QTableWidget，没有预先设定行数和列数
    QTableWidget table;

    // 动态设置表格为3行4列
    table.setRowCount(3);
    table.setColumnCount(4);

    // 设置表格的标题
    table.setWindowTitle("动态创建的表格");

    // 显示表格
    table.show();

    return a.exec();
}</code></pre> 
<p>这段代码展示了如何使用无参数构造函数创建 QTableWidget，并通过调用 <code>setRowCount()</code> 和 <code>setColumnCount()</code> 来动态设置表格的大小。</p> 
<p></p> 
<h3>3、void QTableWidget::cellActivated(int <em>row</em>, int <em>column</em>)</h3> 
<p><code>void QTableWidget::cellActivated(int row, int column)</code> 是 QTableWidget 类的一个信号，当表格中的某个单元格被用户激活时，这个信号会被发射。通常，单元格被“激活”意味着用户通过鼠标点击或键盘导航聚焦到了该单元格，并且如果该单元格处于可编辑状态，这通常会触发编辑过程的开始。</p> 
<blockquote> 
 <ul><li><code>row</code>: 整型参数，表示被激活单元格所在的行索引。</li><li><code>column</code>: 整型参数，表示被激活单元格所在的列索引。</li></ul> 
</blockquote> 
<p>开发者可以连接这个信号到自定义的槽函数，以便在单元格被激活时执行特定的操作。例如，你可能想在用户激活某个单元格后显示该单元格的详细信息，或者记录用户的操作历史等。</p> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;

void handleCellActivation(int r, int c)
{
    qDebug() &lt;&lt; "单元格激活: 行=" &lt;&lt; r &lt;&lt; ", 列=" &lt;&lt; c;
    // 在这里添加你的处理逻辑
}

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget table(3, 3); // 创建一个3x3的表格

    // 连接 cellActivated 信号到槽函数
    QObject::connect(&amp;table, &amp;QTableWidget::cellActivated,
                     &amp;handleCellActivation);

    // 展示表格
    table.show();

    return a.exec();
}</code></pre> 
<p>在这个例子中，每当表格中的任何单元格被激活时，<code>handleCellActivation</code> 函数就会被调用，并打印出被激活单元格的行和列索引。</p> 
<h3>4、void QTableWidget::cellChanged(int <em>row</em>, int <em>column</em>)</h3> 
<p><code>void QTableWidget::cellChanged(int row, int column)</code> 是 QTableWidget 类的另一个信号，当表格中的某个单元格的内容发生改变后，这个信号会被发射。这意味着用户在编辑完一个单元格并失去焦点（比如通过点击其他地方或按回车键）后，该信号会被触发。</p> 
<blockquote> 
 <ul><li><code>row</code>: 整型参数，表示内容发生改变的单元格所在的行索引。</li><li><code>column</code>: 整型参数，表示内容发生改变的单元格所在的列索引。</li></ul> 
</blockquote> 
<p>开发者通常会利用这个信号来实现数据验证、自动更新相关计算、或保存更改到数据库等功能。通过连接这个信号到自定义的槽函数，可以在单元格内容变化时执行相应的处理逻辑。</p> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;

void handleCellChange(int r, int c)
{
    qDebug() &lt;&lt; "单元格内容改变: 行=" &lt;&lt; r &lt;&lt; ", 列=" &lt;&lt; c;
    // 在这里添加你的处理逻辑，比如验证输入数据的有效性或更新其他相关数据显示
}

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget table(3, 3); // 创建一个3x3的表格

    // 允许单元格编辑
    table.setEditTriggers(QAbstractItemView::DoubleClicked | QAbstractItemView::SelectedClicked);

    // 连接 cellChanged 信号到槽函数
    QObject::connect(&amp;table, &amp;QTableWidget::cellChanged,
                     &amp;handleCellChange);

    // 展示表格
    table.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，当用户双击或单击选中后编辑表格中的单元格，并在编辑完成后，<code>handleCellChange</code> 函数会被调用，打印出发生变化的单元格位置。你可以在这个函数里添加任何你需要的处理逻辑。</p> 
<p></p> 
<h3>5、void QTableWidget::cellClicked(int <em>row</em>, int <em>column</em>)</h3> 
<p><code>void QTableWidget::cellClicked(int row, int column)</code> 是 QTableWidget 类的一个信号，当用户在表格中单击某个单元格时，这个信号会被发射。这不涉及单元格的编辑状态，仅指示了用户点击行为的发生。</p> 
<blockquote> 
 <ul><li><code>row</code>: 整型参数，表示被点击单元格所在的行索引。</li><li><code>column</code>: 整型参数，表示被点击单元格所在的列索引。</li></ul> 
</blockquote> 
<p>通过连接这个信号到自定义的槽函数，你可以响应用户的点击动作，比如高亮显示被点击的单元格、显示该单元格的详细信息、或是执行其他特定的操作。</p> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;

void handleCellClick(int r, int c)
{
    qDebug() &lt;&lt; "单元格被点击: 行=" &lt;&lt; r &lt;&lt; ", 列=" &lt;&lt; c;
    // 在这里添加你的处理逻辑，比如改变单元格背景色以示高亮
}

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget table(3, 3); // 创建一个3x3的表格

    // 连接 cellClicked 信号到槽函数
    QObject::connect(&amp;table, &amp;QTableWidget::cellClicked,
                     &amp;handleCellClick);

    // 展示表格
    table.show();

    return a.exec();
}</code></pre> 
<p>在这个例子中，每当用户点击表格中的任意单元格，<code>handleCellClick</code> 函数就会被调用，并打印出被点击单元格的行和列索引。你可以根据实际需求在这个函数内添加相应的处理逻辑。</p> 
<p></p> 
<h3>6、void QTableWidget::cellDoubleClicked(int <em>row</em>, int <em>column</em>)</h3> 
<p><code>void QTableWidget::cellDoubleClicked(int row, int column)</code> 是 QTableWidget 类的信号，当用户在表格中的某个单元格上双击鼠标时触发。这个信号与 <code>cellClicked</code> 不同，它专用于响应双击事件。</p> 
<blockquote> 
 <ul><li><code>row</code>: 整型参数，表示被双击单元格所在的行索引。</li><li><code>column</code>: 整型参数，表示被双击单元格所在的列索引。</li></ul> 
</blockquote> 
<p>通过将此信号连接到自定义的槽函数，你可以实现一些针对双击行为的特殊处理，例如启动编辑模式、打开详细信息对话框或执行其他与双击相关的操作。</p> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;

void handleCellDoubleClick(int r, int c)
{
    qDebug() &lt;&lt; "单元格被双击: 行=" &lt;&lt; r &lt;&lt; ", 列=" &lt;&lt; c;
    // 在这里添加你的处理逻辑，比如开始编辑该单元格内容或显示更多信息
}

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget table(3, 3); // 创建一个3x3的表格

    // 连接 cellDoubleClicked 信号到槽函数
    QObject::connect(&amp;table, &amp;QTableWidget::cellDoubleClicked,
                     &amp;handleCellDoubleClick);

    // 展示表格
    table.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，当用户在表格的任意单元格上双击时，<code>handleCellDoubleClick</code> 函数会被调用，并输出双击的单元格位置。你可以根据需要在此函数内部实现相应的业务逻辑处理。</p> 
<p></p> 
<h3>7、void QTableWidget::cellEntered(int <em>row</em>, int <em>column</em>)</h3> 
<p><code>oid QTableWidget::cellEntered(int row, int column)</code> 是 QTableWidget 类的一个信号，当用户通过键盘导航或其它方式使焦点进入表格中的某个单元格时触发。与 <code>cellActivated</code> 不同，这个信号在单元格获得焦点但不一定被激活（比如开始编辑）时发出。</p> 
<blockquote> 
 <ul><li><code>row</code>: 整型参数，表示获得焦点的单元格所在的行索引。</li><li><code>column</code>: 整型参数，表示获得焦点的单元格所在的列索引。</li></ul> 
</blockquote> 
<p>开发者可以利用这个信号来实现诸如改变单元格样式、更新状态栏信息或执行其他与焦点变化相关的操作。</p> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;

void handleCellEnter(int r, int c)
{
    qDebug() &lt;&lt; "单元格获得焦点: 行=" &lt;&lt; r &lt;&lt; ", 列=" &lt;&lt; c;
    // 在这里添加你的处理逻辑，比如改变单元格背景色或更新提示信息
}

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget table(3, 3); // 创建一个3x3的表格

    // 连接 cellEntered 信号到槽函数
    QObject::connect(&amp;table, &amp;QTableWidget::cellEntered,
                     &amp;handleCellEnter);

    // 展示表格
    table.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，每当表格中的单元格因为键盘导航等原因获得焦点时，<code>handleCellEnter</code> 函数就会被执行，打印出获得焦点的单元格位置。你可以根据实际需求，在这个函数里添加相应的处理逻辑。</p> 
<p></p> 
<h3>8、void QTableWidget::cellPressed(int <em>row</em>, int <em>column</em>)</h3> 
<p><code>void QTableWidget::cellPressed(int row, int column)</code> 是 QTableWidget 类的一个信号，当用户按下鼠标按钮并且鼠标指针位于表格中的某个单元格上时触发。<span style="background-color:#a2e043;">这个信号与 </span><code><span style="background-color:#a2e043;">cellClicked</span></code><span style="background-color:#a2e043;"> 不同，它在鼠标按键被按下但尚未释放时发出，适用于需要即时响应鼠标按下的场景，而不等待点击事件完成（即鼠标按键被释放）。</span></p> 
<blockquote> 
 <ul><li><code>row</code>: 整型参数，表示鼠标按下时所在单元格的行索引。</li><li><code>column</code>: 整型参数，表示鼠标按下时所在单元格的列索引。</li></ul> 
</blockquote> 
<p>通过监听这个信号，开发者可以实现诸如即时反馈、开始拖拽操作或任何需要在鼠标按下瞬间响应的功能。</p> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;

void handleCellPress(int r, int c)
{
    qDebug() &lt;&lt; "单元格被按下: 行=" &lt;&lt; r &lt;&lt; ", 列=" &lt;&lt; c;
    // 在这里添加你的处理逻辑，比如开始拖拽操作或显示按下状态的视觉效果
}

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget table(3, 3); // 创建一个3x3的表格

    // 连接 cellPressed 信号到槽函数
    QObject::connect(&amp;table, &amp;QTableWidget::cellPressed,
                     &amp;handleCellPress);

    // 展示表格
    table.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，当用户在表格内的任何单元格上按下鼠标按钮时，<code>handleCellPress</code> 函数会被调用，并输出鼠标按下时的单元格坐标。你可以根据需要在此函数中实现具体的处理逻辑。</p> 
<p></p> 
<h3>9、void QTableWidget::clear()</h3> 
<p><code>void QTableWidget::clear()</code> 是 QTableWidget 类的一个成员函数，用于清空表格的所有内容。调用这个方法后，表格中的所有单元格（包括它们的内容、样式等）都将被移除，表格回到初始的空状态，行数和列数不会改变，只是每个单元格都变为空（没有任何数据或设置）。</p> 
<p>这个方法特别适用于需要重置表格内容，或者在展示新数据前清除旧数据的场景。需要注意的是，尽管这个操作会移除所有单元格项（QTableWidgetItem对象），但它不会改变表格的结构，即行数和列数保持不变，除非这些行或列是完全空的且表格的大小调整策略允许自动收缩。</p> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget table(3, 2); // 创建一个3行2列的表格
    // 假设之前已经填充了一些数据
    for(int i = 0; i &lt; table.rowCount(); ++i) {
        for(int j = 0; j &lt; table.columnCount(); ++j) {
            QTableWidgetItem *item = new QTableWidgetItem(QString("Cell %1,%2").arg(i).arg(j));
            table.setItem(i, j, item);
        }
    }

    // 清空表格
    table.clear();

    // 展示表格
    table.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，首先创建了一个含有数据的表格，然后通过调用 <code>clear()</code> 方法清空了所有单元格的内容，最后显示了这个已经被清空的表格。</p> 
<p></p> 
<h3>10、void QTableWidget::clearContents()</h3> 
<p><code>void QTableWidget::clearContents()</code> 是 QTableWidget 类的一个成员函数，它的作用是清空表格中的所有单元格内容，同时保留表格的结构（即行数和列数不变）。与 <code>clear()</code> 方法不同，<code>clearContents()</code> 不会删除行或列，它仅仅移除每个单元格中的数据和设置，使得所有单元格变为默认的空状态。</p> 
<p>调用 <code>clearContents()</code> 后，表格看起来就像刚创建时一样，没有任何数据，但表格的结构依然保留，包括用户之前设置的行数、列数、表头等。这对于需要快速清空数据但保持表格框架不变的场景非常有用。</p> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget table(3, 2); // 创建一个3行2列的表格
    // 假设之前已经填充了一些数据
    for(int i = 0; i &lt; table.rowCount(); ++i) {
        for(int j = 0; j &lt; table.columnCount(); ++j) {
            QTableWidgetItem *item = new QTableWidgetItem(QString("Cell %1,%2").arg(i).arg(j));
            table.setItem(i, j, item);
        }
    }

    // 清空表格内容，保留结构
    table.clearContents();

    // 展示表格
    table.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，先创建了一个填充了数据的表格，然后通过调用 <code>clearContents()</code> 方法仅清除了所有单元格的内容，而表格的行数和列数保持不变，最终展示的是一个结构完好但内容已被清空的表格。</p> 
<p></p> 
<h3>11、void QTableWidget::currentCellChanged (int <em>currentRow</em>, int <em>currentColumn</em>, int <em>previousRow</em>,  int <em>previousColumn</em>)</h3> 
<p><code>void QTableWidget::currentCellChanged(int currentRow, int currentColumn, int previousRow, int previousColumn)</code> 是 QTableWidget 类的一个信号，当表格当前选中或焦点所在的单元格发生变化时触发。这个信号提供了从哪个单元格转移到哪个单元格的详细信息，使得开发者可以对单元格焦点变化做出响应。</p> 
<blockquote> 
 <ul><li><code>currentRow</code>: 整型参数，表示当前选中或获得焦点的单元格所在的行索引。</li><li><code>currentColumn</code>: 整型参数，表示当前选中或获得焦点的单元格所在的列索引。</li><li><code>previousRow</code>: 整型参数，表示之前选中或拥有焦点的单元格所在的行索引。</li><li><code>previousColumn</code>: 整型参数，表示之前选中或拥有焦点的单元格所在的列索引。</li></ul> 
</blockquote> 
<p>这个信号非常适合用于跟踪用户的导航行为，比如在单元格切换时更新相关数据显示，或者根据当前选中单元格的状态执行特定操作。</p> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;

void handleCurrentCellChange(int currR, int currC, int prevR, int prevC)
{
    qDebug() &lt;&lt; "当前单元格改变: 从 (" &lt;&lt; prevR &lt;&lt; "," &lt;&lt; prevC &lt;&lt; ") 到 (" &lt;&lt; currR &lt;&lt; "," &lt;&lt; currC &lt;&lt; ")";
    // 在这里添加你的处理逻辑，比如更新界面元素以反映新的选中单元格内容
}

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget table(3, 3); // 创建一个3x3的表格

    // 连接 currentCellChanged 信号到槽函数
    QObject::connect(&amp;table, &amp;QTableWidget::currentCellChanged,
                     &amp;handleCurrentCellChange);

    // 展示表格
    table.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，当用户通过键盘或鼠标改变当前选中单元格时，<code>handleCurrentCellChange</code> 函数会被调用，显示出焦点从哪个单元格转移到了哪个单元格，你可以根据实际需求在这里添加相应的处理逻辑。</p> 
<p></p> 
<h3>12、void QTableWidget::currentItemChanged(<a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *<em>current</em>, <a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *<em>previous</em>)</h3> 
<p><code>void QTableWidget::currentItemChanged(QTableWidgetItem *current, QTableWidgetItem *previous)</code> 是 QTableWidget 类的一个信号，当表格中当前选中的项（<code>QTableWidgetItem</code>）发生变化时触发。这个信号提供了当前选中项和前一个选中项的指针，使得开发者能够获取这两个项的信息并作出相应处理。</p> 
<blockquote> 
 <ul><li><code>current</code>: 指向当前选中项（<code>QTableWidgetItem</code>）的指针，如果当前没有选中项，则为 nullptr。</li><li><code>previous</code>: 指向前一个选中项（<code>QTableWidgetItem</code>）的指针，如果之前没有选中项或这是首次选择，则为 nullptr。</li></ul> 
</blockquote> 
<p>这个信号常用于监控用户的选择变化，比如更新与选中项相关的数据显示，或者基于选中项的状态执行特定逻辑。</p> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;

void handleCurrentItemChange(QTableWidgetItem *currItem, QTableWidgetItem *prevItem)
{
    if (currItem) {
        qDebug() &lt;&lt; "当前选中项改变: 新项的文本为：" &lt;&lt; currItem-&gt;text();
    } else {
        qDebug() &lt;&lt; "当前没有选中项";
    }

    if (prevItem) {
        qDebug() &lt;&lt; "前一个选中项的文本为：" &lt;&lt; prevItem-&gt;text();
    } else {
        qDebug() &lt;&lt; "之前没有选中项";
    }

    // 在这里添加你的处理逻辑，比如根据当前选中项更新UI
}

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget table(3, 3); // 创建一个3x3的表格
    // 假设填充了数据...

    // 连接 currentItemChanged 信号到槽函数
    QObject::connect(&amp;table, &amp;QTableWidget::currentItemChanged,
                     &amp;handleCurrentItemChange);

    // 展示表格
    table.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，当用户更改所选单元格时，<code>handleCurrentItemChange</code> 函数会被调用，显示出当前选中项和前一个选中项的文本内容（如果存在的话），你可以根据需要添加相应的处理逻辑来响应这种变化。</p> 
<p></p> 
<h3>13、void QTableWidget::insertColumn(int <em>column</em>)</h3> 
<p><code>void QTableWidget::insertColumn(int column)</code> 是 QTableWidget 类的一个成员函数，用于在表格中指定的位置插入一个新的列。这会影响表格的所有行，即在每一行都会增加一个新的单元格。</p> 
<blockquote> 
 <ul><li><code>column</code>: 整型参数，表示要插入新列的位置索引。索引从0开始，如果提供的索引等于当前列数，则新列将被添加在末尾。</li></ul> 
</blockquote> 
<p>调用这个方法后，表格会在指定列的位置添加一列空白的单元格，每个单元格都可以通过 <code>setItem()</code> 方法单独设置内容或样式。此操作不会影响原有的数据，只是在视觉和逻辑结构上扩展了表格。</p> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget table(3, 2); // 创建一个3行2列的表格
    // 假设之前已经填充了一些数据...

    // 在索引为1的位置插入一列（即成为第二列）
    table.insertColumn(1);

    // 可以进一步设置新插入列的单元格内容，例如：
    for(int i = 0; i &lt; table.rowCount(); ++i) {
        QTableWidgetItem *newItem = new QTableWidgetItem("New Column");
        table.setItem(i, 1, newItem); // 注意索引1现在对应的是新插入的列
    }

    // 展示表格
    table.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，我们首先创建了一个3行2列的表格，然后在索引为1的位置插入了一列，使其变为3列的表格，并且为新插入列的每个单元格设置了默认文本“New Column”。这样，表格结构得到了动态扩展，并且新列内容也得到了初始化。</p> 
<p></p> 
<h3>14、void QTableWidget::insertRow(int <em>row</em>)</h3> 
<p><code>void QTableWidget::insertRow(int row)</code> 是 QTableWidget 类的一个成员函数，用于在表格指定的位置插入一个新的行。插入的新行会包含与现有列数相匹配的空白单元格。</p> 
<blockquote> 
 <ul><li><code>row</code>: 整型参数，表示要插入新行的位置索引。索引从0开始，如果提供的索引等于当前行数，则新行将被添加在末尾。</li></ul> 
</blockquote> 
<p>当调用这个方法时，表格会在指定的行位置增加一行，这一行中的每个单元格最初都是空的（默认情况下），可以通过 <code>setItem()</code> 方法来设置这些单元格的内容和样式。</p> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget table(2, 3); // 创建一个2行3列的表格
    // 假设之前已经填充了一些数据...

    // 在索引为1的位置插入一行（即成为第二行）
    table.insertRow(1);

    // 可以为新插入行的每个单元格设置内容，例如：
    for(int j = 0; j &lt; table.columnCount(); ++j) {
        QTableWidgetItem *newItem = new QTableWidgetItem("New Row");
        table.setItem(1, j, newItem); // 注意索引1现在对应的是新插入的行
    }

    // 展示表格
    table.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，我们首先创建了一个2行3列的表格，接着在索引为1的位置插入了一行，使其变为3行的表格，并且为新插入行的每个单元格设置了默认文本“New Row”。这样，不仅表格的行数得到了扩展，新行的内容也得到了初始化。</p> 
<p></p> 
<h3>15、void QTableWidget::itemActivated(<a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *<em>item</em>)</h3> 
<p><code>void QTableWidget::itemActivated(QTableWidgetItem *item)</code> 是 QTableWidget 类的一个信号，当表格中的某个单元格项（<code>QTableWidgetItem</code>）被激活时发射。通常，单元格项的激活意味着用户通过鼠标点击或键盘操作使该单元格成为焦点，并且如果该单元格是可编辑的，可能会开始编辑过程。</p> 
<blockquote> 
 <ul><li><code>item</code>: 指向被激活的 <code>QTableWidgetItem</code> 对象的指针，提供关于激活单元格的详细信息。</li></ul> 
</blockquote> 
<p>开发者可以通过连接这个信号到自定义的槽函数，来响应单元格项被激活的事件，比如开始编辑、显示详细信息弹窗或执行其他与激活项相关的逻辑。</p> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;

void handleItemActivation(QTableWidgetItem *activatedItem)
{
    if (activatedItem) {
        qDebug() &lt;&lt; "单元格项被激活: 文本=" &lt;&lt; activatedItem-&gt;text();
        // 在这里添加你的处理逻辑，比如开始编辑或展示更多信息
    }
}

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget table(3, 2); // 创建一个3行2列的表格
    // 假设之前已经填充了一些数据...

    // 连接 itemActivated 信号到槽函数
    QObject::connect(&amp;table, &amp;QTableWidget::itemActivated,
                     &amp;handleItemActivation);

    // 展示表格
    table.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，当用户激活表格中的任何一个单元格时，<code>handleItemActivation</code> 函数会被调用，并打印出被激活单元格项的文本内容。你可以根据需要在此函数内部添加具体的处理逻辑。</p> 
<p></p> 
<h3>16、void QTableWidget::itemChanged(<a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *<em>item</em>)</h3> 
<p><code>void QTableWidget::itemChanged(QTableWidgetItem *item)</code> 是 QTableWidget 类的一个信号，当表格中的某一个 <code>QTableWidgetItem</code> 对象的内容发生改变时被发射。这个信号允许开发者监视并响应单元格数据的任何改动，无论这些改动是用户直接编辑产生的还是通过程序设置的。</p> 
<blockquote> 
 <ul><li><code>item</code>: 指向已发生内容变化的 <code>QTableWidgetItem</code> 对象的指针，开发者可以通过这个指针获取并处理变化后的单元格内容或进行其他相关操作。</li></ul> 
</blockquote> 
<p>这个信号非常适合用于数据验证、自动更新相关联的数据、或者触发保存到数据库的操作等场景。</p> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;

void handleItemChange(QTableWidgetItem *changedItem)
{
    if (changedItem) {
        qDebug() &lt;&lt; "单元格内容改变: 文本=" &lt;&lt; changedItem-&gt;text();
        // 在这里添加你的处理逻辑，比如验证数据有效性或更新相关数据显示
    }
}

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget table(3, 2); // 创建一个3行2列的表格
    // 假设之前已经填充了一些数据，并且单元格允许编辑...

    // 连接 itemChanged 信号到槽函数
    QObject::connect(&amp;table, &amp;QTableWidget::itemChanged,
                     &amp;handleItemChange);

    // 展示表格
    table.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，当表格中任何单元格的内容发生变化后，<code>handleItemChange</code> 函数会被调用，并打印出变化后单元格的文本内容。你可以根据具体需求在这个函数中实现相应的逻辑处理，比如数据校验或数据同步操作。</p> 
<p></p> 
<h3>17、void QTableWidget::itemClicked(<a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *<em>item</em>)</h3> 
<p><code>void QTableWidget::itemClicked(QTableWidgetItem *item)</code> 是 QTableWidget 类的一个信号，当用户在表格中的某个单元格项（<code>QTableWidgetItem</code>）上单击鼠标时触发。这个信号允许你捕获并响应用户的单击行为，进而执行相应的操作，比如显示详细信息、执行单元格内容的编辑或者其他与单击相关的逻辑。</p> 
<blockquote> 
 <ul><li><code>item</code>: 指向被点击的 <code>QTableWidgetItem</code> 对象的指针，通过这个指针可以获得点击单元格的具体信息，包括行、列位置及单元格内容等。</li></ul> 
</blockquote> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;

void handleItemClick(QTableWidgetItem *clickedItem)
{
    if (clickedItem) {
        int row = clickedItem-&gt;row();
        int column = clickedItem-&gt;column();
        QString text = clickedItem-&gt;text();
        qDebug() &lt;&lt; "单元格被点击: 行=" &lt;&lt; row &lt;&lt; ", 列=" &lt;&lt; column &lt;&lt; ", 文本=" &lt;&lt; text;
        // 在这里添加你的处理逻辑，比如响应用户点击
    }
}

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget table(3, 2); // 创建一个3行2列的表格
    // 假设之前已经填充了一些数据...

    // 连接 itemClicked 信号到槽函数
    QObject::connect(&amp;table, &amp;QTableWidget::itemClicked,
                     &amp;handleItemClick);

    // 展示表格
    table.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，每当用户点击表格中的任意单元格，<code>handleItemClick</code> 函数就会被调用，并打印出被点击单元格的行、列索引及文本内容。你可以根据实际需求，在此函数内添加相应的处理逻辑。</p> 
<p></p> 
<h3>18、void QTableWidget::itemDoubleClicked(<a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *<em>item</em>)</h3> 
<p><code>void QTableWidget::itemDoubleClicked(QTableWidgetItem *item)</code> 是 QTableWidget 类的一个信号，当用户在表格中的某个单元格项（<code>QTableWidgetItem</code>）上双击鼠标时触发。这个信号对于实现诸如编辑单元格内容、显示详细信息对话框或者执行其他与双击相关的特定操作非常有用。</p> 
<blockquote> 
 <ul><li><code>item</code>: 指向被双击的 <code>QTableWidgetItem</code> 对象的指针，你可以通过这个指针获取双击单元格的详细信息，包括行号、列号及单元格内容。</li></ul> 
</blockquote> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;

void handleItemDoubleClick(QTableWidgetItem *doubleClickedItem)
{
    if (doubleClickedItem) {
        int row = doubleClickedItem-&gt;row();
        int column = doubleClickedItem-&gt;column();
        QString text = doubleClickedItem-&gt;text();
        qDebug() &lt;&lt; "单元格被双击: 行=" &lt;&lt; row &lt;&lt; ", 列=" &lt;&lt; column &lt;&lt; ", 文本=" &lt;&lt; text;
        // 在这里添加你的处理逻辑，比如开始编辑单元格内容或者显示更多信息
    }
}

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget table(3, 2); // 创建一个3行2列的表格
    // 假设之前已经填充了一些数据...

    // 连接 itemDoubleClicked 信号到槽函数
    QObject::connect(&amp;table, &amp;QTableWidget::itemDoubleClicked,
                     &amp;handleItemDoubleClick);

    // 展示表格
    table.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，当用户双击表格中的任意单元格，<code>handleItemDoubleClick</code> 函数就会被调用，并打印出双击单元格的行、列索引及文本内容。你可以根据实际应用场景，在此函数内部实现双击事件的处理逻辑，比如直接启动单元格的编辑模式或展示详细的单元格内容信息。</p> 
<p></p> 
<h3>19、void QTableWidget::itemEntered(<a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *<em>item</em>)</h3> 
<p><code>void QTableWidget::itemEntered(QTableWidgetItem *item)</code> 是 QTableWidget 类的一个信号，当用户通过键盘导航或其它方式使焦点进入表格中的某个单元格项（<code>QTableWidgetItem</code>）时触发。这个信号与鼠标点击或双击事件不同，它专注于焦点的变化，适用于那些需要响应焦点移动而非直接用户交互（如点击）的场景。</p> 
<blockquote> 
 <ul><li><code>item</code>: 指向获得焦点的 <code>QTableWidgetItem</code> 对象的指针，通过这个指针可以获取当前焦点所在单元格的详细信息。</li></ul> 
</blockquote> 
<p>这个信号可以用于实现诸如改变单元格的视觉效果以突出显示当前焦点位置、更新状态栏信息或者执行其他与焦点转移相关的逻辑。</p> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;

void handleItemFocusEnter(QTableWidgetItem *enteredItem)
{
    if (enteredItem) {
        int row = enteredItem-&gt;row();
        int column = enteredItem-&gt;column();
        QString text = enteredItem-&gt;text();
        qDebug() &lt;&lt; "焦点进入单元格: 行=" &lt;&lt; row &lt;&lt; ", 列=" &lt;&lt; column &lt;&lt; ", 文本=" &lt;&lt; text;
        // 在这里添加你的处理逻辑，比如改变单元格样式或更新状态信息
    }
}

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget table(3, 2); // 创建一个3行2列的表格
    // 假设之前已经填充了一些数据...

    // 连接 itemEntered 信号到槽函数
    QObject::connect(&amp;table, &amp;QTableWidget::itemEntered,
                     &amp;handleItemFocusEnter);

    // 展示表格
    table.show();

    return a.exec();
}</code></pre> 
<p>在上述示例中，当用户通过键盘导航使焦点进入表格的任一单元格时，<code>handleItemFocusEnter</code> 函数会被调用，并打印出获得焦点的单元格的行、列索引及文本内容。你可以根据需要，在此函数中实现焦点进入单元格时的特定处理逻辑，例如改变单元格的背景颜色以高亮显示当前焦点位置。</p> 
<p></p> 
<h3>20、void QTableWidget::itemPressed(<a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *<em>item</em>)</h3> 
<p><code>void QTableWidget::itemPressed(QTableWidgetItem *item)</code> 是 QTableWidget 类的一个信号，当用户按下鼠标按钮且鼠标指针位于表格中的某个单元格项（<code>QTableWidgetItem</code>）上时触发。这个信号在鼠标按键被按下但还未释放的瞬间发出，适合于需要即时响应鼠标按下事件的场景，例如开始拖拽操作或显示按下状态的视觉反馈。</p> 
<blockquote> 
 <ul><li><code>item</code>: 指向被鼠标按下的 <code>QTableWidgetItem</code> 对象的指针，通过这个指针可以获得按下事件发生时单元格的详细信息。</li></ul> 
</blockquote> 
<p>这个信号与 <code>itemClicked</code> 不同，后者是在鼠标按键被按下并释放后触发，通常用来响应点击事件。</p> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;

void handleItemPress(QTableWidgetItem *pressedItem)
{
    if (pressedItem) {
        int row = pressedItem-&gt;row();
        int column = pressedItem-&gt;column();
        QString text = pressedItem-&gt;text();
        qDebug() &lt;&lt; "单元格被按下: 行=" &lt;&lt; row &lt;&lt; ", 列=" &lt;&lt; column &lt;&lt; ", 文本=" &lt;&lt; text;
        // 在这里添加你的处理逻辑，比如开始拖拽操作或显示按下状态
    }
}

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget table(3, 2); // 创建一个3行2列的表格
    // 假设之前已经填充了一些数据...

    // 连接 itemPressed 信号到槽函数
    QObject::connect(&amp;table, &amp;QTableWidget::itemPressed,
                     &amp;handleItemPress);

    // 展示表格
    table.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，当用户在表格中的任意单元格上按下鼠标按钮，<code>handleItemPress</code> 函数会被调用，并打印出按下单元格的行、列索引及文本内容。你可以根据实际需求，在此函数中实现鼠标按下时的处理逻辑，例如开始单元格的拖动功能或显示按下视觉效果。</p> 
<p></p> 
<h3>21、void QTableWidget::itemSelectionChanged()</h3> 
<p>这个信号在项目的选中状态发生变化时发射，包括项目被选择或取消选择。</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QItemSelection&gt;

void handleSelectionChange(const QItemSelection &amp;selected, const QItemSelection &amp;deselected)
{
    qDebug() &lt;&lt; "选中项变化";
    // 在这里可以访问 selected 和 deselected 参数来分别处理被选中和被取消选中的项
}

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget table(3, 2); // 创建一个3行2列的表格
    // 假设之前已经填充了一些数据...

    // 连接 selectionChanged 信号到槽函数
    QObject::connect(&amp;table-&gt;selectionModel(), &amp;QItemSelectionModel::selectionChanged,
                     &amp;handleSelectionChange);

    // 展示表格
    table.show();

    return a.exec();
}</code></pre> 
<p></p> 
<h3>22、void QTableWidget::removeColumn(int <em>column</em>)</h3> 
<p><code>void QTableWidget::removeColumn(int column)</code> 是 QTableWidget 类的一个成员函数，用于从表格中移除指定索引的列。这会影响到表格的所有行，即该列上的所有单元格都将被移除。</p> 
<blockquote> 
 <ul><li><code>column</code>: 整型参数，表示要移除的列的索引。索引从0开始，如果提供的索引超出范围，则不会有任何操作执行。</li></ul> 
</blockquote> 
<p>调用这个方法后，指定的列及其包含的所有单元格会被永久性地从表格中移除，同时表格的列数会减少。如果有与移除列相关的数据或逻辑需要处理，应在调用此函数之前做好备份或清理工作。</p> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget table(3, 3); // 创建一个3行3列的表格
    // 假设之前已经填充了一些数据...

    // 移除索引为1的列（即第二列）
    table.removeColumn(1);

    // 展示表格
    table.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，我们创建了一个3行3列的表格，并随后移除了索引为1的列，这意味着表格会变为3行2列，原先第二列的所有单元格都被移除。注意，索引值是基于0的计数，所以索引1实际上是第二列。</p> 
<p></p> 
<h3>23、void QTableWidget::removeRow(int <em>row</em>)</h3> 
<p><code>void QTableWidget::removeRow(int row)</code> 是 QTableWidget 类的一个成员函数，用于从表格中删除指定行索引的整行。这个操作会移除该行上的所有单元格，并且表格的行数会相应减少。</p> 
<blockquote> 
 <ul><li><code>row</code>: 整型参数，表示要移除的行的索引。索引从0开始，如果提供的索引超出了表格当前的行范围，则该函数不做任何操作。</li></ul> 
</blockquote> 
<p>调用这个方法后，指定行上的所有单元格及其内容会被永久性地从表格中移除。在执行此操作之前，确保已经妥善处理了与这些单元格相关的任何数据或状态信息。</p> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget table(4, 2); // 创建一个4行2列的表格
    // 假设之前已经填充了一些数据...

    // 移除索引为2的行（即第三行）
    table.removeRow(2);

    // 展示表格
    table.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，我们首先创建了一个4行2列的表格，然后通过调用 <code>removeRow(2)</code> 方法移除了索引为2的行（即表格中的第三行），结果是表格变为3行2列，第三行被成功移除。请记住，行和列索引都是从0开始的。</p> 
<p></p> 
<h3>24、void QTableWidget::scrollToItem(const <a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *<em>item</em>, <a href="https://doc.qt.io/qt-5/qabstractitemview.html#ScrollHint-enum" rel="nofollow" title="QAbstractItemView::ScrollHint">QAbstractItemView::ScrollHint</a> <em>hint</em> = EnsureVisible)</h3> 
<p><code>oid QTableWidget::scrollToItem(const QTableWidgetItem *item, QAbstractItemView::ScrollHint hint = EnsureVisible)</code> 是 QTableWidget 类的一个成员函数，用于滚动表格视图，确保指定的单元格项（<code>QTableWidgetItem</code>）在视图中可见。这对于大表格中自动定位到特定项非常有用，尤其是当项不在当前可视区域时。</p> 
<blockquote> 
 <ul><li><code>item</code>: 指向希望滚动到其可视范围内的 <code>QTableWidgetItem</code> 对象的指针。这个单元格必须是属于调用该函数的 QTableWidget 的一部分。</li><li><code>hint</code>（默认值为 <code>QAbstractItemView::EnsureVisible</code>）: 一个枚举值，指定滚动行为的提示。可用的选项有： 
   <ul><li><code>QAbstractItemView::EnsureVisible</code>: 确保项是可见的，这是默认行为，可能只滚动最小的距离。</li><li><code>QAbstractItemView::PositionAtTop</code>: 尝试将项置于视图顶部。</li><li><code>QAbstractItemView::PositionAtBottom</code>: 尝试将项置于视图底部。</li><li><code>QAbstractItemView::PositionAtCenter</code>: 尝试将项置于视图中心。</li></ul></li></ul> 
</blockquote> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget table(10, 5); // 创建一个10行5列的大表格
    // 假设之前已经填充了一些数据...

    // 创建或获取一个需要滚动到的单元格项（假设这是第5行第3列的一个项）
    QTableWidgetItem *targetItem = new QTableWidgetItem("Target Item");
    table.setItem(4, 2, targetItem); // 注意行和列索引是从0开始的

    // 滚动表格确保目标项可见
    table.scrollToItem(targetItem);

    // 或者使用滚动提示滚动到特定位置，例如置于视图顶部
    // table.scrollToItem(targetItem, QAbstractItemView::PositionAtTop);

    // 展示表格
    table.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，我们创建了一个较大的表格，并通过 <code>scrollToItem</code> 方法确保新添加的单元格项在表格视图中可见。可以根据需要调整 <code>ScrollHint</code> 参数来改变滚动行为。</p> 
<p></p> 
<h3>25、QTableWidget::~QTableWidget()</h3> 
<p><code>QTableWidget::~QTableWidget()</code> 是 QTableWidget 类的析构函数。析构函数是在对象生命周期结束时（例如对象的作用域结束或者delete一个动态分配的对象时）自动调用的特殊成员函数，用于释放对象占用的资源，如内存和其他外部资源。</p> 
<p>当一个QTableWidget对象不再使用，即将被销毁时，其析构函数会自动被调用。在这个过程中，QTableWidget会清理所有与其关联的资源，包括但不限于：</p> 
<blockquote> 
 <ul><li>删除所有内部维护的单元格项（<code>QTableWidgetItem</code>对象）。</li><li>释放与表格视图相关的内存和资源。</li><li>断开所有与该对象相连的信号和槽，确保不会产生悬挂的指针。</li></ul> 
</blockquote> 
<p>开发人员通常不需要直接调用析构函数，也不需要在其内部添加自定义的清理代码。Qt框架和C++语言本身会确保析构函数的正确执行，自动完成必要的资源清理工作。编写代码时，重点应放在确保在不再需要对象时正确地删除或让其自然离开作用域，从而触发析构函数。</p> 
<p></p> 
<h3>26、<a href="https://doc.qt.io/qt-5/qwidget.html#QWidget" rel="nofollow" title="QWidget">QWidget</a> *QTableWidget::cellWidget(int <em>row</em>, int <em>column</em>) const</h3> 
<p><code>QWidget *QTableWidget::cellWidget(int row, int column) const</code> 是 QTableWidget 类的一个成员函数，用于获取放置在指定单元格（由行和列索引确定）中的自定义小部件（<code>QWidget</code>）。在QTableWidget中，除了可以使用<code>QTableWidgetItem</code>来显示文本或其他标准类型的数据外，还可以直接嵌入自定义的小部件，如按钮、复选框等，以实现更复杂的单元格内容。</p> 
<blockquote> 
 <ul><li><code>row</code>: 整型参数，表示单元格所在的行索引，索引从0开始。</li><li><code>column</code>: 整型参数，表示单元格所在的列索引，索引同样从0开始。</li></ul> 
</blockquote> 
<p>返回值是一个指向位于指定单元格的<code>QWidget</code>指针，如果没有小部件被设置在该单元格，则返回nullptr。</p> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QPushButton&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget table(3, 6); // 创建一个3行6列的表格

    // 在第一行第二列放置一个按钮作为示例
    QPushButton *button = new QPushButton("Click Me", &amp;table);
    table.setCellWidget(0, 1, button);

    // 获取并使用单元格中的小部件
    QWidget *widget = table.cellWidget(0, 1);
    if (widget) {
        QPushButton *exampleButton = qobject_cast&lt;QPushButton*&gt;(widget);
        if (exampleButton) {
            connect(exampleButton, &amp;QPushButton::clicked, [](){
                qDebug() &lt;&lt; "Button clicked!";
            });
        }
    }

    table.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，我们在表格的第一行第二列插入了一个按钮（<code>QPushButton</code>），然后通过调用<code>cellWidget</code>函数来获取这个单元格中的小部件，并将其转换为按钮类型，以便进一步设置点击事件处理。如果该单元格没有放置小部件，<code>cellWidget</code>将返回<code>nullptr</code>。</p> 
<p></p> 
<h3>27、void QTableWidget::closePersistentEditor(<a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *<em>item</em>)</h3> 
<p><code>void QTableWidget::closePersistentEditor(QTableWidgetItem *item)</code> 是 QTableWidget 类的一个成员函数，用于关闭与指定单元格项（<code>QTableWidgetItem</code>）关联的持久编辑器（如果有的话）。在QTableWidget中，当一个单元格被设置为可编辑，并且通过某种方式（如双击或调用<code>openPersistentEditor</code>方法）开启了编辑模式，那么这个单元格会显示一个编辑器（如lineEdit、comboBox等），允许用户修改单元格内容。调用<code>closePersistentEditor</code>则会关闭这个编辑器，通常在用户完成编辑或需要取消编辑时使用。</p> 
<blockquote> 
 <ul><li><code>item</code>: 指向需要关闭其编辑器的 <code>QTableWidgetItem</code> 对象的指针。</li></ul> 
</blockquote> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;

void finishEditing()
{
    // 假设 editingItem 是当前正在编辑的项
    // 这里需要根据实际情况获取 editingItem，比如从槽函数的参数或类的成员变量
    // 下面是一个示意过程
    QTableWidgetItem *editingItem = ...; // 获取正在编辑的项
    if(editingItem){
        // 关闭编辑器
        ui-&gt;tableWidget-&gt;closePersistentEditor(editingItem);
        // 可能还需要其他处理，比如保存编辑内容，验证等
    }
}

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget table(3, 2); // 创建一个3行2列的表格
    // 假设已经填充了数据，并且某些单元格被设置为可编辑

    // 连接一个槽到某个信号，以便在特定条件下关闭编辑器
    // 例如，当用户点击按钮或触发其他事件时
    // QPushButton *doneButton = new QPushButton("Done", this);
    // connect(doneButton, &amp;QPushButton::clicked, this, &amp;finishEditing);

    // 或者在其他适当的时机手动调用 closePersistentEditor
    QTableWidgetItem *editableItem = new QTableWidgetItem("Editable Content");
    table.setItem(1, 1, editableItem);
    table.openPersistentEditor(editableItem); // 打开编辑器
    // 假设条件满足，关闭编辑器
    // finishEditing();

    table.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，展示了如何使用<code>closePersistentEditor</code>来关闭一个已打开的单元格编辑器。请注意，实际应用中需要根据具体情境和逻辑来决定何时调用此函数。</p> 
<p></p> 
<h3>28、int QTableWidget::column(const <a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *<em>item</em>) const</h3> 
<p><code>int QTableWidget::column(const QTableWidgetItem *item) const</code> 是 QTableWidget 类的一个成员函数，用于获取指定单元格项（<code>QTableWidgetItem</code>）所在列的索引。这个函数对于需要根据单元格项获取其位置信息的场景非常有用，比如在处理单元格项的逻辑时，需要知道其所在的列以便执行相应的操作。</p> 
<blockquote> 
 <ul><li><code>item</code>: 指向你想查询其所在列的 <code>QTableWidgetItem</code> 对象的常量指针。这个单元格项必须是属于调用该函数的 QTableWidget 的。</li></ul> 
</blockquote> 
<p>返回值是 <code>item</code> 所在的列的索引，索引从0开始。如果提供的单元格项不属于该表格，则返回-1。</p> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget table(3, 7); // 创建一个3行7列的表格
    // 假设填充了数据...

    QTableWidgetItem *exampleItem = table.item(1, 3); // 假设这是表格中一个已知的项，位于第二行第四列
    if (exampleItem) {
        int columnIndexOfItem = table.column(exampleItem);
        qDebug() &lt;&lt; "指定单元格项位于列：" &lt;&lt; columnIndexOfItem; // 应输出为3，因为列索引从0开始
    } else {
        qDebug() &lt;&lt; "单元格项未找到";
    }

    table.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，我们首先创建了一个3行7列的表格，并通过 <code>table.item(row, column)</code> 方法获取了一个已知的单元格项，然后使用 <code>table.column(item)</code> 函数得到该单元格所在的列索引，并打印出来。如果单元格项不在表格中，函数将返回-1，但在这个示例中我们通过直接从表格获取项来确保它是存在的。</p> 
<p></p> 
<h3>29、int QTableWidget::columnCount() const</h3> 
<p><code>int QTableWidget::columnCount() const</code> 是 QTableWidget 类的一个成员函数，用于获取表格当前的列数。这个函数不带任何参数，返回的是表格的列数，从0开始计数，因此一个空表格的列数为0，至少有一列的表格列数至少为1。</p> 
<p>这个方法对于需要动态调整用户界面、计算布局或者基于列数做逻辑判断的场景非常有用。</p> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    int initialColumnCount = tableWidget.columnCount(); // 获取初始列数，通常是0
    qDebug() &lt;&lt; "初始列数：" &lt;&lt; initialColumnCount;

    tableWidget.setColumnCount(3); // 设置列数为3
    int newColumnCount = tableWidget.columnCount(); // 再次获取列数
    qDebug() &lt;&lt; "新的列数：" &lt;&lt; newColumnCount;

    // 进一步操作...
    
    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，首先创建了一个 <code>QTableWidget</code> 实例，并检查了其初始的列数，然后通过 <code>setColumnCount</code> 方法设置列数为3，并再次检查列数以确认设置是否生效。这种方式可以灵活地根据程序的需要动态调整表格结构。</p> 
<p></p> 
<h3>30、int QTableWidget::currentColumn() const</h3> 
<p><code>int QTableWidget::currentColumn() const</code> 是 QTableWidget 类的一个成员函数，用于获取当前选中单元格所在的列索引。这个方法返回的是当前选中项（如果有）所在的列的索引，索引从0开始计数。如果没有单元格被选中，该方法返回-1。</p> 
<p>这个函数对于需要知道用户当前操作或关注哪一列的数据特别有用，比如在实现某些联动操作或数据处理逻辑时。</p> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;

void handleCurrentCellChanged(int currentRow, int currentColumn, int previousRow, int previousColumn)
{
    qDebug() &lt;&lt; "当前列索引：" &lt;&lt; currentColumn;
}

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(3); // 设置行数
    tableWidget.setColumnCount(4); // 设置列数

    // 填充数据或进行其他初始化操作...

    // 连接信号以监视当前单元格变化
    QObject::connect(&amp;tableWidget, &amp;QTableWidget::currentCellChanged,
                 &amp;handleCurrentCellChanged);

    // 假设用户或程序通过某些操作改变了当前选中单元格
    // 当前选中单元格的信息会通过信号传递给handleCurrentCellChanged槽函数

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，我们创建了一个 <code>QTableWidget</code> 实例，并通过连接 <code>currentCellChanged</code> 信号到自定义槽函数 <code>handleCurrentCellChanged</code> 来监控当前单元格的变化，其中 <code>currentColumn</code> 参数即代表当前选中单元格的列索引。当用户通过点击或键盘导航改变当前选中单元格时，槽函数会被调用并打印出当前列索引。</p> 
<p></p> 
<h3>31、<a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *QTableWidget::currentItem() const</h3> 
<p><code>QTableWidgetItem *QTableWidget::currentItem() const</code> 是 QTableWidget 类的一个成员函数，用于获取当前选中项（如果存在）的指针。这个方法返回指向当前被用户选中或拥有键盘焦点的 <code>QTableWidgetItem</code> 对象。如果没有项被选中，则返回 nullptr（NULL）。</p> 
<p>这个函数对于需要直接访问和操作当前选中项的数据或属性非常有用，例如读取或修改其文本内容、图标、背景色等属性。</p> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;

void processSelectedItem(QTableWidgetItem *item)
{
    if(item){
        QString itemText = item-&gt;text();
        qDebug() &lt;&lt; "当前选中项的文本：" &lt;&lt; itemText;
        // 进一步处理或使用item
    } else {
        qDebug() &lt;&lt; "当前没有选中项";
    }
}

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(4); // 设置行数
    tableWidget.setColumnCount(3); // 设置列数

    // 填充数据或进行其他初始化操作...
    for(int row = 0; row &lt; tableWidget.rowCount(); ++row){
        for(int col = 0; col &lt; tableWidget.columnCount(); ++col){
            QTableWidgetItem *item = new QTableWidgetItem(QString("Row %0, Column %1").arg(row).arg(col));
            tableWidget.setItem(row, col, item);
        }
    }

    // 示例：直接获取并处理当前选中项
    QTableWidgetItem *current = tableWidget.currentItem();
    if(current) processSelectedItem(current);

    // 或者连接到某个信号处理选中项变化
    // 注意QTableWidget没有直接的currentItemChanged信号，但可以间接通过currentCellChanged等处理
    // tableWidget.cellChanged.connect(processSelectedItem); // 这里是示意，实际需根据需求处理逻辑

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，我们创建了一个 <code>QTableWidget</code> 并填充了数据，之后尝试获取并处理当前选中项（即使在创建后默认没有选中项）。通过 <code>currentItem()</code> 函数，我们可以直接与当前选中项交互，进行后续的逻辑处理。如果需要响应用户选择变化，通常会结合 <code>currentCellChanged</code> 或其他相关信号间接处理当前项的变更。</p> 
<p></p> 
<h3>32、int QTableWidget::currentRow() const</h3> 
<p><code>int QTableWidget::currentRow() const</code> 是 QTableWidget 类的一个成员函数，用于获取当前选中单元格所在的行索引。这个方法返回的是当前选中项（如果有）所在的行的索引，索引从0开始。如果没有单元格被选中，该方法返回-1。</p> 
<p>这个函数对于需要跟踪用户当前操作所在的行，比如进行数据处理、行间联动操作或更新相关信息时非常有用。</p> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;

void handleCurrentCellChanged(int currentRow, int currentColumn, int previousRow, int previousColumn)
{
    qDebug() &lt;&lt; "当前行索引：" &lt;&lt; currentRow;
}

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(5); // 设置行数
    tableWidget.setColumnCount(4); // 设置列数

    // 填充数据或进行其他初始化操作...

    // 连接信号以监视当前单元格变化
    QObject::connect(&amp;tableWidget, &amp;QTableWidget::currentCellChanged,
                 &amp;handleCurrentCellChanged);

    // 假设用户或程序通过某些操作改变了当前选中单元格
    // 当前选中单元格的信息会通过信号传递给handleCurrentCellChanged槽函数

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，我们创建了一个 <code>QTableWidget</code> 实例，并通过连接 <code>currentCellChanged</code> 信号到自定义槽函数 <code>handleCurrentCellChanged</code> 来监控当前单元格的变化，其中 <code>currentRow</code> 参数即代表当前选中单元格的行索引。当用户通过点击或键盘导航改变当前选中单元格时，槽函数会被调用并打印出行索引。</p> 
<p></p> 
<h3>33、void QTableWidget::dropEvent(<a href="https://doc.qt.io/qt-5/qdropevent.html" rel="nofollow" title="QDropEvent">QDropEvent</a> *<em>event</em>)</h3> 
<p><code>void QTableWidget::dropEvent(QDropEvent *event)</code> 是 QTableWidget 类的一个虚函数，用于处理拖放操作中的“放下”（drop）事件。当用户将拖动的数据释放（放下）到 QTableWidget 上的某个位置时，这个函数会被调用。通过重写这个方法，你可以控制如何处理拖放的数据，比如插入新项、更新已有项或执行其他自定义操作。</p> 
<blockquote> 
 <ul><li><code>event</code>: 指向 <code>QDropEvent</code> 对象的指针，包含了放下操作的所有信息，包括源数据、动作类型（移动、复制等）、鼠标位置等。</li></ul> 
</blockquote> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QMimeData&gt;
#include &lt;QDragEnterEvent&gt;
#include &lt;QDropEvent&gt;

class MyTableWidget : public QTableWidget
{
public:
    MyTableWidget(QWidget *parent = nullptr) : QTableWidget(parent){}
    
protected:
    void dragEnterEvent(QDragEnterEvent *event) override{
        if(event-&gt;mimeData()-&gt;hasText()){
            event-&gt;acceptProposedAction();
        } else {
            event-&gt;ignore();
        }
    }

    void dropEvent(QDropEvent *event) override{
        QString data = event-&gt;mimeData()-&gt;text();
        int row = rowAt(event-&gt;pos().y()); // 获取鼠标位置对应的行
        int col = columnAt(event-&gt;pos().x()); // 获取鼠标位置对应的列
        
        if(row &gt;= 0 &amp;&amp; col &gt;= 0){ // 确保位置有效
            QTableWidgetItem *newItem = new QTableWidgetItem(data);
            setItem(row, col, newItem); // 在对应位置插入新项
            event-&gt;acceptProposedAction();
        } else {
            event-&gt;ignore();
        }
    }
};

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    MyTableWidget tableWidget; // 使用自定义的MyTableWidget
    tableWidget.setRowCount(5);
    tableWidget.setColumnCount(8);
    
    // 其他初始化操作...
    
    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，我们创建了一个继承自 <code>QTableWidget</code> 的 <code>MyTableWidget</code> 类，并重写了 <code>dragEnterEvent</code> 和 <code>dropEvent</code> 方法来支持拖放操作。<code>dragEnterEvent</code> 确保只有包含文本的拖动操作被接受，而 <code>dropEvent</code> 处理实际的放下逻辑，将拖动的文本作为新项插入到表格的指定位置。这样，当用户将文本数据拖放到表格上时，程序会自动在对应位置创建一个新单元格并填入文本内容。</p> 
<p></p> 
<h3>34、bool QTableWidget::dropMimeData(int <em>row</em>, int <em>column</em>, const <a href="https://doc.qt.io/qt-5/qmimedata.html" rel="nofollow" title="QMimeData">QMimeData</a> *<em>data</em>, <a href="https://doc.qt.io/qt-5/qt.html#DropAction-enum" rel="nofollow" title="Qt::DropAction">Qt::DropAction</a> <em>action</em>)</h3> 
<p><code>ool QTableWidget::dropMimeData(int row, int column, const QMimeData *data, Qt::DropAction action)</code> 是 QTableWidget 类的一个虚拟保护成员函数，用于处理拖放操作中的数据放置。它允许子类自定义放置数据的具体行为，比如决定数据如何在表格中插入或处理。这个函数主要用于在拖放操作中实现自定义逻辑，比如在表格的特定行列位置插入数据。</p> 
<blockquote> 
 <ul><li><code>row</code>: 整型参数，表示放置数据的目标行索引。-1 表示根据 <code>data</code> 决定最佳位置。</li><li><code>column</code>: 整型参数，表示放置数据的目标列索引。-1 表示根据 <code>data</code> 决定最佳位置。</li><li><code>data</code>: 指向 <code>QMimeData</code> 对象的指针，包含了拖放的数据。这个数据可以是文本、图像、文件路径等多种类型，取决于拖放操作的上下文。</li><li><code>action</code>: <code>Qt::DropAction</code> 枚举值，指示拖放操作的类型，比如移动(<code>MoveAction</code>)或复制(<code>CopyAction</code>)。</li></ul> 
</blockquote> 
<p>返回值是布尔类型，表示是否成功处理了拖放数据。如果处理成功，返回 <code>true</code>；否则，返回 <code>false</code>。</p> 
<p><strong>重写此方法时，你应该考虑以下几点：</strong></p> 
<ol><li><strong>数据兼容性检查</strong>：检查 <code>data</code> 是否含有可以被表格理解并处理的数据格式。</li><li><strong>操作类型</strong>：根据 <code>action</code> 决定是移动、复制还是其他操作，并据此处理数据。</li><li><strong>位置确定</strong>：如果 <code>row</code> 和 <code>column</code> 都是 -1，你需要根据 <code>data</code> 和/或鼠标位置来确定插入的具体位置。</li><li><strong>实际插入或更新</strong>：根据需要创建 <code>QTableWidgetItem</code> 对象，并使用 <code>setItem()</code> 方法插入到表格中。</li></ol> 
<p><strong>示例代码概念</strong>（非完整代码，仅展示重写思路）：</p> 
<pre><code class="hljs">bool MyCustomTableWidget::dropMimeData(int row, int column, const QMimeData *data, Qt::DropAction action)
{
    if (!data-&gt;hasFormat("text/plain")) { // 示例：仅处理纯文本数据
        return false;
    }

    QString text = data-&gt;text();
    bool success = false;

    if (row == -1 || column == -1) { // 如果未指定确切位置
        // 可以根据逻辑决定插入位置，例如获取光标位置或自动检测
        QPoint pos = mapFromGlobal(QCursor::pos());
        row = rowAt(pos.y());
        column = columnAt(pos.x());
    }

    if (row &gt;= 0 &amp;&amp; column &gt;= 0) {
        QTableWidgetItem *newItem = new QTableWidgetItem(text);
        setItem(row, column, newItem);
        success = true;
    }

    return success;
}</code></pre> 
<p>请注意，上面的代码是一个简化的概念展示，实际应用中可能需要更细致的错误处理和逻辑判断，以及根据实际拖放需求调整数据处理方式。</p> 
<p></p> 
<h3>35、void QTableWidget::editItem(<a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *<em>item</em>)</h3> 
<p><code>void QTableWidget::editItem(QTableWidgetItem *item)</code> 是 QTableWidget 类的一个成员函数，用于启动对指定单元格项（<code>QTableWidgetItem</code>）的编辑过程。如果该单元格配置为可编辑并且尚未处于编辑状态，调用此函数将会使该单元格进入编辑模式，允许用户直接修改其内容。</p> 
<blockquote> 
 <ul><li><code>item</code>: 指向希望进入编辑模式的 <code>QTableWidgetItem</code> 对象的指针。这个单元格必须是属于调用该函数的 QTableWidget 实例的。</li></ul> 
</blockquote> 
<p>这个方法对于需要在特定时刻手动触发单元格编辑非常有用，例如响应用户界面上的按钮点击或程序逻辑中的特定条件触发。</p> 
<p>示例代码：</p> 
<pre><code class="hljs">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;

void startEditing()
{
    QTableWidgetItem *editableItem = ...; // 获取需要编辑的单元格项
    if(editableItem){
        ui-&gt;tableWidget-&gt;editItem(editableItem); // 触发编辑
    }
}

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(5); // 设置行数
    tableWidget.setColumnCount(9); // 设置列数

    // 假设填充数据，其中某些单元格被标记为可编辑
    QTableWidgetItem *editableItem = new QTableWidgetItem("Edit Me");
    editableItem-&gt;setFlags(Qt::ItemIsEnabled | Qt::ItemIsSelectable | Qt::ItemIsEditable); // 确保单元格可编辑
    tableWidget.setItem(1, 1, editableItem); // 举例放置在第二行第二列

    // 连接信号或按钮点击等操作以手动启动编辑
    // QPushButton *editButton = new QPushButton("Edit Cell", this);
    // connect(editButton, &amp;QPushButton::clicked, this, &amp;startEditing);

    // 或者直接调用以示例
    // startEditing();

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在上述示例中，我们创建了一个QTableWidget并设置了行列数，假设填充了数据，其中一些单元格被设置为可编辑。<code>startEditing</code>函数中通过<code>editItem</code>方法手动触发了指定单元格的编辑过程。虽然示例中使用注释掉了连接到按钮的逻辑，但在实际应用中，你可以根据需要，如响应按钮点击或特定条件来调用<code>editItem</code>方法，以开始编辑单元格内容。</p> 
<p></p> 
<h3>36、bool QTableWidget::event(<a href="https://doc.qt.io/qt-5/qevent.html" rel="nofollow" title="QEvent">QEvent</a> *<em>e</em>)</h3> 
<p><code>bool QTableWidget::event(QEvent *e)</code> 是 QTableWidget 类从其基类 QObject 继承而来的一个虚函数，用于处理所有类型的事件。这个函数是Qt事件处理机制的核心部分，允许类对接收到的任何事件进行自定义处理，不仅仅是标准的鼠标或键盘事件，还包括定时器、窗口状态变化等所有类型的事件。</p> 
<blockquote> 
 <ul><li><code>e</code>: 指向 <code>QEvent</code> 对象的指针，封装了发生的事件信息，包括事件类型、时间戳等。</li></ul> 
</blockquote> 
<p>返回值是布尔类型，表示事件是否被处理。如果返回 <code>true</code>，表示事件已被处理；如果返回 <code>false</code>，则事件可能会被传递给父类或其他事件处理器。</p> 
<p>重写 <code>event</code> 函数使得子类能够拦截和处理标准事件处理流程之外的事件，或在标准处理前后添加自定义逻辑。这对于实现复杂的用户界面行为或定制化交互非常有用。</p> 
<p><strong>示例代码概念</strong>：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QMouseEvent&gt; // 仅为示例，包含鼠标事件头文件

class CustomTableWidget : public QTableWidget
{
    Q_OBJECT
public:
    CustomTableWidget(QWidget *parent = nullptr) : QTableWidget(parent){}
    
protected:
    bool event(QEvent *e) override{
        if(e-&gt;type() == QEvent::MouseButtonPress){ // 处理鼠标点击事件为例
            QMouseEvent *me = static_cast&lt;QMouseEvent*&gt;(e);
            if(me-&gt;button() == Qt::LeftButton){
                qDebug() &lt;&lt; "左键点击了表格";
                // 在这里可以添加自定义处理逻辑
                return true; // 假设我们处理了这个事件，不再传播
            }
        }
        
        // 如果不是我们关心的事件，就交给基类处理
        return QTableWidget::event(e);
    }
};

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    
    CustomTableWidget tableWidget; // 使用自定义的表格
    tableWidget.show();
    
    return a.exec();
}</code></pre> 
<p>在这个示例中，我们创建了一个 <code>CustomTableWidget</code> 类，重写了 <code>event</code> 函数来捕捉并处理特定事件，比如在这里是鼠标左键点击事件。根据需要，可以在重写的函数内添加更多类型的事件处理逻辑，使得表格具有更加丰富的交互能力。未被处理的事件通过调用 <code>QTableWidget::event(e)</code> 传递给了基类，保证了标准事件处理的完整性。</p> 
<p></p> 
<h3>37、<a href="https://doc.qt.io/qt-5/qlist.html" rel="nofollow" title="QList">QList</a>&lt;<a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *&gt; QTableWidget::findItems(const <a href="https://doc.qt.io/qt-5/qstring.html" rel="nofollow" title="QString">QString</a> &amp;<em>text</em>, <a href="https://doc.qt.io/qt-5/qt.html#MatchFlag-enum" rel="nofollow" title="Qt::MatchFlags">Qt::MatchFlags</a> <em>flags</em>) const</h3> 
<p><code>QList&lt;QTableWidgetItem*&gt; QTableWidget::findItems(const QString &amp;text, Qt::MatchFlags flags) const</code> 是 QTableWidget 类的一个成员函数，用于在表格中查找包含指定文本的所有单元格项（<code>QTableWidgetItem</code>）。这个方法允许你根据文本内容搜索表格，并且可以控制匹配的模式（精确匹配、部分匹配等）。</p> 
<blockquote> 
 <ul><li><code>text</code>: 字符串参数，表示要搜索的文本内容。</li><li><code>flags</code>: <code>Qt::MatchFlags</code> 类型的枚举值，用于指定匹配规则。常见的标志有： 
   <ul><li><code>Qt::MatchExactly</code>: 完全匹配，只有完全相等的项才会被找到。</li><li><code>Qt::MatchContains</code>: 包含匹配，只要项包含文本即可。</li><li><code>Qt::MatchStartsWith</code>: 起始匹配，项的文本以指定文本开始。</li><li><code>Qt::MatchEndsWith</code>: 结尾匹配，项的文本以指定文本结束。</li><li>可以组合使用，如 <code>Qt::MatchContains | Qt::MatchCaseSensitive</code> 表示区分大小写的包含匹配。</li></ul></li></ul> 
</blockquote> 
<p>返回值是一个 <code>QList&lt;QTableWidgetItem*&gt;</code>，包含了所有匹配项的指针列表。如果没有找到匹配项，返回的列表为空。</p> 
<p>示例代码：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;
#include &lt;QDebug&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget(3, 2); // 创建一个3行2列的表格
    tableWidget.setItem(0, 0, new QTableWidgetItem("Apple"));
    tableWidget.setItem(1, 1, new QTableWidgetItem("Banana"));
    tableWidget.setItem(2, 0, new QTableWidgetItem("Cherry"));

    // 查找包含"an"的所有项，忽略大小写
    QList&lt;QTableWidgetItem*&gt; foundItems = tableWidget.findItems("an", Qt::MatchContains | Qt::MatchCaseInsensitive);

    foreach(QTableWidgetItem *item, foundItems){
        qDebug() &lt;&lt; "找到了项：" &lt;&lt; item-&gt;text() &lt;&lt; "在行" &lt;&lt; item-&gt;row() &lt;&lt; "列" &lt;&lt; item-&gt;column();
    }

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，我们创建了一个包含水果名称的简单表格，并使用 <code>findItems</code> 方法搜索包含文本 "an" 的单元格项，同时设置为不区分大小写。程序会输出找到的每个匹配项的文本及其位置。</p> 
<p></p> 
<h3>38、<a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *QTableWidget::horizontalHeaderItem(int <em>column</em>) const</h3> 
<p><code>QTableWidgetItem *QTableWidget::horizontalHeaderItem(int column) const</code> 是 QTableWidget 类的一个成员函数，用于获取水平表头（即表格最上方的一行）中指定列的表头项（<code>QTableWidgetItem</code>）。水平表头项通常用于显示列的标题或标签。</p> 
<blockquote> 
 <ul><li><code>column</code>: 整型参数，表示想要获取表头项的列索引，索引从0开始。</li></ul> 
</blockquote> 
<p>返回值是一个指向 <code>QTableWidgetItem</code> 对象的指针，该对象代表了指定列的水平表头项。如果没有为该列设置表头项，则返回 <code>nullptr</code>。</p> 
<p>这个方法对于自定义表头项的显示内容或样式非常有用，比如改变文字、图标或字体等。</p> 
<p>示例代码：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setColumnCount(3); // 设置列数

    // 设置水平表头项
    QTableWidgetItem *headerItem = new QTableWidgetItem("Column 1");
    tableWidget.setHorizontalHeaderItem(0, headerItem); // 设置第一列的表头项

    // 获取并修改水平表头项
    QTableWidgetItem *headerItemRetrieved = tableWidget.horizontalHeaderItem(0);
    if(headerItemRetrieved){
        headerItemRetrieved-&gt;setFont(QFont("Arial", 12, QFont::Bold)); // 修改字体样式
        // 可以进行其他属性修改
    }

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，我们创建了一个具有三列的 <code>QTableWidget</code>，设置了第一列的水平表头项为 "Column 1"，然后通过 <code>horizontalHeaderItem</code> 函数获取了该表头项，并修改了其字体样式。这样可以动态地调整表头的显示效果。</p> 
<p></p> 
<h3>39、<a href="https://doc.qt.io/qt-5/qmodelindex.html" rel="nofollow" title="QModelIndex">QModelIndex</a> QTableWidget::indexFromItem(const <a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *<em>item</em>) const</h3> 
<p><code>QModelIndex QTableWidget::indexFromItem(const QTableWidgetItem *item) const</code> 是 QTableWidget 类的一个成员函数，用于根据给定的 <code>QTableWidgetItem</code> 对象获取对应的 <code>QModelIndex</code>。<code>QModelIndex</code> 是模型视图框架中的一个关键类，用于唯一标识数据模型中的一个项，尤其是在与视图组件交互时非常重要。</p> 
<blockquote> 
 <ul><li><code>item</code>: 常量指针，指向需要获取其索引的 <code>QTableWidgetItem</code> 对象。这个单元格项必须是属于调用该函数的 <code>QTableWidget</code> 实例的。</li></ul> 
</blockquote> 
<p>返回值是一个 <code>QModelIndex</code>，它表示了在模型中的单元格项的位置。如果 <code>item</code> 为 <code>nullptr</code> 或不属于该 <code>QTableWidget</code>，返回的 <code>QModelIndex</code> 是无效的。</p> 
<p>这个方法在需要将 <code>QTableWidgetItem</code> 与基于模型视图框架的操作桥接时非常有用，比如通过索引来更新或访问单元格的数据显示。</p> 
<p>示例代码概念：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;
#include &lt;QDebug&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(3); // 设置行数
    tableWidget.setColumnCount(2); // 设置列数

    QTableWidgetItem *item = new QTableWidgetItem("Example Text");
    tableWidget.setItem(1, 0, item); // 放置单元格项在第二行第一列

    // 获取单元格项的QModelIndex
    QModelIndex index = tableWidget.indexFromItem(item);
    if(index.isValid()){ // 检查索引是否有效
        qDebug() &lt;&lt; "单元格项的QModelIndex: " &lt;&lt; index.row() &lt;&lt; ", " &lt;&lt; index.column();
    } else {
        qDebug() &lt;&lt; "无效的QModelIndex";
    }

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在上述示例中，我们创建了一个简单的 <code>QTableWidget</code> 并放置了一个单元格项，然后通过 <code>indexFromItem</code> 函数获取了该单元格的 <code>QModelIndex</code>，并检查其有效性，最后打印了索引的行和列信息。这样可以进一步利用 <code>QModelIndex</code> 来进行更深入的数据操作或视图交互。</p> 
<p></p> 
<h3>40、bool QTableWidget::isPersistentEditorOpen(<a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *<em>item</em>) const</h3> 
<p><code>bool QTableWidget::isPersistentEditorOpen(QTableWidgetItem *item) const</code> 是 QTableWidget 类的一个成员函数，用于检查指定的单元格项 (<code>QTableWidgetItem</code> 对象) 是否有一个持续打开的编辑器。在 QTableWidget 中，当你调用 <code>openPersistentEditor()</code> 方法为某个单元格项打开一个编辑器，并且这个编辑器保持打开状态直到显式关闭，此函数就能用来检测这种状态。</p> 
<blockquote> 
 <ul><li><code>item</code>: 常量指针，指向你想检查其编辑器状态的 <code>QTableWidgetItem</code> 对象。这个单元格项必须是属于调用该函数的 <code>QTableWidget</code> 实例的。</li></ul> 
</blockquote> 
<p>返回值是一个布尔值，如果给定的单元格项有一个持续打开的编辑器，则返回 <code>true</code>；否则返回 <code>false</code>。</p> 
<p>这个函数在需要根据单元格编辑状态做出相应UI或逻辑处理时非常有用，比如判断是否需要关闭或更新编辑器内容。</p> 
<p>示例代码概念：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;

void checkAndProcessEditorState()
{
    QTableWidgetItem *itemToCheck = ...; // 获取想要检查的QTableWidgetItem对象
    if(ui-&gt;tableWidget-&gt;isPersistentEditorOpen(itemToCheck)){
        qDebug() &lt;&lt; "编辑器对" &lt;&lt; itemToCheck-&gt;text() &lt;&lt; "是打开的";
        // 在这里可以添加处理打开编辑器时需要执行的代码
    } else {
        qDebug() &lt;&lt; "编辑器对" &lt;&lt; itemToCheck-&gt;text() &lt;&lt; "是关闭的";
        // 编辑器关闭时的处理逻辑
    }
}

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(3); // 设置行数
    tableWidget.setColumnCount(2); // 设置列数

    QTableWidgetItem *editableItem = new QTableWidgetItem("Editable Cell");
    tableWidget.setItem(1, 1, editableItem);
    tableWidget.openPersistentEditor(editableItem); // 打开一个持续的编辑器

    // 检查编辑器状态
    checkAndProcessEditorState();

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在上述示例中，我们创建了一个简单的 <code>QTableWidget</code> 并为其中的一个单元格打开了一个持续的编辑器，然后通过 <code>isPersistentEditorOpen()</code> 函数检查并处理了编辑器的状态。根据返回值的不同，可以执行不同的逻辑处理。</p> 
<p></p> 
<h3>41、<a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *QTableWidget::item(int <em>row</em>, int <em>column</em>) const</h3> 
<p><code>QTableWidgetItem *QTableWidget::item(int row, int column) const</code> 是 QTableWidget 类的一个成员函数，用于获取指定行和列位置上的单元格项（<code>QTableWidgetItem</code>）。这个方法允许你直接通过行列索引来访问表格中的单元格内容，对于读取或修改单元格数据非常方便。</p> 
<blockquote> 
 <ul><li><code>row</code>: 整型参数，表示单元格所在的行索引，索引从0开始。</li><li><code>column</code>: 整型参数，表示单元格所在的列索引，索引同样从0开始。</li></ul> 
</blockquote> 
<p>返回值是一个指向位于指定行列的 <code>QTableWidgetItem</code> 对象的指针。如果没有在该位置设置过项，则返回 <code>nullptr</code>。</p> 
<p>示例代码：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;
#include &lt;QDebug&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(3); // 设置行数
    tableWidget.setColumnCount(2); // 设置列数

    // 填充一些数据作为示例
    QTableWidgetItem *item1 = new QTableWidgetItem("Hello");
    tableWidget.setItem(0, 0, item1);

    QTableWidgetItem *retrievedItem = tableWidget.item(0, 0); // 获取第一行第一列的项
    if(retrievedItem){
        qDebug() &lt;&lt; "获取到的单元格内容：" &lt;&lt; retrievedItem-&gt;text();
    } else {
        qDebug() &lt;&lt; "该位置没有项";
    }

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在上述示例中，我们创建了一个具有3行2列的 <code>QTableWidget</code>，向第一行第一列设置了一个单元格项，然后使用 <code>item()</code> 函数获取该位置的项，并打印其内容。如果该位置没有设置项，日志会显示“该位置没有项”。</p> 
<p></p> 
<h3>42、<a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *QTableWidget::itemAt(const <a href="https://doc.qt.io/qt-5/qpoint.html" rel="nofollow" title="QPoint">QPoint</a> &amp;<em>point</em>) const</h3> 
<p><code>QTableWidgetItem *QTableWidget::itemAt(const QPoint &amp;point) const</code> 是 QTableWidget 类的一个成员函数，用于获取指定屏幕坐标点上单元格的 <code>QTableWidgetItem</code> 对象。这在处理鼠标事件或需要根据屏幕位置获取单元格信息的场景中非常有用。</p> 
<blockquote> 
 <ul><li><code>point</code>: <code>QPoint</code> 类型的参数，表示屏幕上的一个点，其坐标系基于 <code>QTableWidget</code> 的左上角。</li></ul> 
</blockquote> 
<p>返回值是一个指向位于指定屏幕坐标点上的 <code>QTableWidgetItem</code> 对象的指针，如果没有项位于该点上，则返回 <code>nullptr</code>。</p> 
<p>示例代码：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;
#include &lt;QMouseEvent&gt;

void mousePressEvent(QMouseEvent *event)
{
    QTableWidgetItem *itemAtMouse = ui-&gt;tableWidget-&gt;itemAt(event-&gt;pos());
    if(itemAtMouse){
        qDebug() &lt;&lt; "鼠标点击的单元格内容：" &lt;&lt; itemAtMouse-&gt;text();
        // 可以在此添加更多处理逻辑
    } else {
        qDebug() &lt;&lt; "鼠标点击位置无单元格";
    }
}

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(3); // 设置行数
    tableWidget.setColumnCount(2); // 设置列数

    // 填充一些数据
    for(int row = 0; row &lt; 3; ++row){
        for(int col = 0; col &lt; 2; ++col){
            QTableWidgetItem *item = new QTableWidgetItem(QString("Row %0, Col %1").arg(row).arg(col));
            tableWidget.setItem(row, col, item);
        }
    }

    // 连接鼠标点击事件
    QObject:</code></pre> 
<p>在上述示例中，我们创建了一个 <code>QTableWidget</code> 并填充了数据，然后通过连接鼠标按下事件到 <code>mousePressEvent</code> 槽函数，在槽函数中使用 <code>itemAt()</code> 方法获取鼠标点击位置上的单元格项，并打印其内容。如果点击位置没有单元格，则输出“鼠标点击位置无单元格”。</p> 
<p></p> 
<h3>43、<a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *QTableWidget::itemAt(int <em>ax</em>, int <em>ay</em>) const</h3> 
<p>与<a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *QTableWidget::itemFromIndex(const <a href="https://doc.qt.io/qt-5/qmodelindex.html" rel="nofollow" title="QModelIndex">QModelIndex</a> &amp;<em>index</em>) const功能一样。</p> 
<p></p> 
<h3>44、<a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *QTableWidget::itemFromIndex(const <a href="https://doc.qt.io/qt-5/qmodelindex.html" rel="nofollow" title="QModelIndex">QModelIndex</a> &amp;<em>index</em>) const</h3> 
<p><code>QTableWidgetItem *QTableWidget::itemFromIndex(const QModelIndex &amp;index) const</code> 是 QTableWidget 类的一个成员函数，用于根据给定的模型索引 (<code>QModelIndex</code>) 获取对应的 <code>QTableWidgetItem</code> 对象。这在使用模型视图框架集成或需要在模型索引和传统项之间转换的场景中很有用。</p> 
<blockquote> 
 <ul><li><code>index</code>: 常量引用，指向一个 <code>QModelIndex</code>，表示模型中的一个单元格位置。</li></ul> 
</blockquote> 
<p>返回值是一个指向位于指定模型索引位置的 <code>QTableWidgetItem</code> 对象的指针。如果模型索引无效或没有对应的项，则返回 <code>nullptr</code>。</p> 
<p>示例代码概念：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;
#include &lt;QDebug&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(3); // 设置行数
    tableWidget.setColumnCount(2); // 设置列数

    QTableWidgetItem *item = new QTableWidgetItem("Sample Item");
    tableWidget.setItem(1, 1, item); // 放置在第二行第二列

    // 获取对应于特定行列的QModelIndex
    QModelIndex modelIndex = tableWidget.model()-&gt;index(1, 1); // 第二行第二列的索引
    QTableWidgetItem *retrievedItem = tableWidget.itemFromIndex(modelIndex); // 通过索引获取QTableWidgetItem

    if(retrievedItem){
        qDebug() &lt;&lt; "通过索引获取的单元格内容：" &lt;&lt; retrievedItem-&gt;text();
    } else {
        qDebug() &lt;&lt; "无效索引或没有对应的项";
    }

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在上述示例中，我们首先创建了一个简单的 <code>QTableWidget</code> 并在其中放置了一个单元格项，然后通过模型索引定位到该单元格，并使用 <code>itemFromIndex()</code> 方法转换为 <code>QTableWidgetItem</code> 对象进行进一步操作。如果索引有效且对应有项，打印出单元格内容；否则提示无效或没有对应的项。</p> 
<p></p> 
<h3>45、const <a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *QTableWidget::itemPrototype() const</h3> 
<p><code>const QTableWidgetItem *QTableWidget::itemPrototype() const</code> 是 QTableWidget 类的一个成员函数，用于获取用于复制新单元格项的原型 <code>QTableWidgetItem</code> 对象。当 QTableWidget 需要为新单元格创建一个默认的 QTableWidgetItem 实例时，它会使用这个原型对象作为模板。如果之前没有设置过原型，则默认返回 nullptr。</p> 
<p>这个功能对于希望所有新创建的单元格项共享某些默认属性（如背景颜色、字体样式等）的场景非常有用。一旦设置了原型，通过 <code>setItem()</code> 或其他方式自动创建的项会继承原型的属性。</p> 
<p>示例代码：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;
#include &lt;QDebug&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(6); // 设置行数
    tableWidget.setColumnCount(3); // 设置列数

    // 创建一个带有默认属性的原型项
    QTableWidgetItem *prototypeItem = new QTableWidgetItem();
    prototypeItem-&gt;setBackground(Qt::yellow); // 例如，设置背景为黄色
    prototypeItem-&gt;setFont(QFont("Arial", 12)); // 设置字体
    tableWidget.setItemPrototype(prototypeItem); // 设置原型项

    // 验证原型是否设置成功
    const QTableWidgetItem *retrievedPrototype = tableWidget.itemPrototype();
    if(retrievedPrototype){
        qDebug() &lt;&lt; "原型项的字体:" &lt;&lt; retrievedPrototype-&gt;font().family();
        qDebug() &lt;&lt; "原型项的背景颜色:" &lt;&lt; retrievedPrototype-&gt;background().color().name();
    } else {
        qDebug() &lt;&lt; "没有设置原型项";
    }

    // 现在，手动或通过其他方式添加的新项将基于此原型
    // 例如，下面手动添加一个新项，它将自动采用原型的属性
    QTableWidgetItem *NewItem = new QTableWidgetItem("New Item");
    tableWidget.setItem(0, 0, NewItem);

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在上述示例中，我们首先创建了一个 <code>QTableWidgetItem</code> 作为原型，并设置了特定的背景颜色和字体，然后通过 <code>setItemPrototype()</code> 方法将其设置为 QTableWidget 的原型项。之后，我们验证了原型项是否设置成功，并展示了如何通过添加新项来观察这些默认属性的继承效果。</p> 
<p></p> 
<h3>46、<a href="https://doc.qt.io/qt-5/qmimedata.html" rel="nofollow" title="QMimeData">QMimeData</a> *QTableWidget::mimeData(const <a href="https://doc.qt.io/qt-5/qlist.html" rel="nofollow" title="QList">QList</a>&lt;<a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *&gt; <em>items</em>) const</h3> 
<p><code>QMimeData *QTableWidget::mimeData(const QList&lt;QTableWidgetItem *&gt; items) const</code> 是 QTableWidget 类的一个成员函数，用于将给定的一系列 <code>QTableWidgetItem</code> 对象转换为 <code>QMimeData</code> 格式。这个功能在拖放操作中非常关键，因为它允许你将表格中的项打包成 <code>QMimeData</code>，这样就可以在拖放过程中携带这些数据并在目标位置恢复或处理它们。</p> 
<blockquote> 
 <ul><li><code>items</code>: <code>QList&lt;QTableWidgetItem *&gt;</code> 类型的参数，表示想要包含进 <code>QMimeData</code> 的 <code>QTableWidgetItem</code> 对象列表。这些项将被序列化为数据，以便于在拖放操作中传输。</li></ul> 
</blockquote> 
<p>返回值是一个指向 <code>QMimeData</code> 对象的指针，包含了所选单元格项的数据。这个 <code>QMimeData</code> 对象可以被用作拖放操作的一部分，以携带数据到其他地方。</p> 
<p>示例代码概念：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;
#include &lt;QMimeData&gt;
#include &lt;QDebug&gt;

void startDrag()
{
    QList&lt;QTableWidgetItem*&gt; selectedItems = ui-&gt;tableWidget-&gt;selectedItems(); // 获取选中的项
    if(!selectedItems.isEmpty()){
        QMimeData *mimeData = ui-&gt;tableWidget-&gt;mimeData(selectedItems); // 将选中项转换为QMimeData
        if(mimeData){
            // 这里可以开始拖放操作，使用mimeData
            // 示例中省略了实际的拖放发起逻辑
            qDebug() &lt;&lt; "QMimeData包含的文本数据：" &lt;&lt; mimeData-&gt;text();
        }
    }
}

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(7); // 设置行数
    tableWidget.setColumnCount(5); // 设置列数

    // 填充一些数据并设置项可被选中
    for(int row = 0; row &lt; 7; ++row){
        for(int col = 0; col &lt; 5; ++col){
            QTableWidgetItem *item = new QTableWidgetItem(QString("Row %0, Col %1").arg(row).arg(col));
            tableWidget.setItem(row, col, item);
        }
    }

    // 假设一个情境触发开始拖放，如按钮点击
    // connect(someButton, &amp;QPushButton::clicked, &amp;startDrag);

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在上述示例中，尽管没有展示完整的拖放操作的实现，但通过 <code>mimeData(const QList&lt;QTableWidgetItem *&gt; items)</code> 方法展示了如何获取当前选中项的 <code>QMimeData</code>。这为拖放操作提供了必要的数据准备，以便在拖放目标处正确地解析和使用这些数据。</p> 
<p></p> 
<h3>47、<a href="https://doc.qt.io/qt-5/qstringlist.html" rel="nofollow" title="QStringList">QStringList</a> QTableWidget::mimeTypes() const</h3> 
<p><code>QStringList QTableWidget::mimeTypes() const</code> 是 QTableWidget 类的一个成员函数，用于获取此 QTableWidget 支持的 MIME 类型列表。在拖放操作中，MIME类型是非常重要的，因为它们定义了数据的格式，使得接收方可以了解如何正确地解析和处理拖放过来的数据。</p> 
<p>返回值是一个 <code>QStringList</code>，包含了字符串列表，每条字符串代表一种支持的 MIME 类型。对于 QTableWidget，默认情况下，通常会支持至少 <code>"application/x-qabstractitemmodeldatalist"</code> 类型，这是Qt内部用于传输模型项数据的标准MIME类型。</p> 
<p>了解这些 MIME 类型有助于开发者在实现自定义的拖放逻辑时，特别是在处理 <code>QMimeData</code> 的创建和解析时，确保数据是以 QTableWidget 支持的格式进行交换。</p> 
<p>示例代码概念：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QDebug&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例

    // 获取并打印QTableWidget支持的MIME类型
    QStringList supportedMimeTypes = tableWidget.mimeTypes();
    qDebug() &lt;&lt; "支持的MIME类型:";
    foreach(const QString &amp;mimeType, supportedMimeTypes){
        qDebug() &lt;&lt; mimeType;
    }

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，我们创建了一个简单的 <code>QTableWidget</code> 并打印了它支持的MIME类型列表。这对于调试或理解你的应用程序如何与 <code>QTableWidget</code> 交互，特别是在涉及拖放操作时，是非常有用的。</p> 
<p></p> 
<h3>48、void QTableWidget::openPersistentEditor(<a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *<em>item</em>)</h3> 
<p><code>void QTableWidget::openPersistentEditor(QTableWidgetItem *item)</code> 是 QTableWidget 类的一个成员函数，用于为指定的 <code>QTableWidgetItem</code> 打开一个持久的编辑器。这意味着编辑器一旦被打开，就会一直保持活动状态，直到显式关闭，而不是像临时编辑那样用户完成输入后立即关闭。这对于需要用户在完成编辑或确认更改之前一直查看和编辑单元格内容的场景非常有用。</p> 
<blockquote> 
 <ul><li><code>item</code>: 指向你想要为其开启持久编辑器的 <code>QTableWidgetItem</code> 对象的指针。这个单元格项必须是属于调用该函数的 <code>QTableWidget</code> 实例的。</li></ul> 
</blockquote> 
<p>调用此函数后，相应的单元格项会进入编辑模式，允许用户连续编辑其内容，且编辑器不会因失去焦点而自动关闭。这对于需要用户进行多次修改或仔细核对输入的场景特别便利。</p> 
<p>示例代码：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(1); // 设置行数
    tableWidget.setColumnCount(1); // 设置列数

    QTableWidgetItem *editableItem = new QTableWidgetItem("Click to edit"); // 创建一个可编辑项
    tableWidget.setItem(0, 0, editableItem); // 放置在表格中

    // 连接槽函数以在项被点击时打开持久编辑器
    QObject::connect(&amp;tableWidget, &amp;QTableWidget::cellClicked, [&amp;](int row, int column){
        QTableWidgetItem *item = tableWidget.item(row, column);
        if(item) tableWidget.openPersistentEditor(item);
    });

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在上述示例中，我们创建了一个单行单列的 <code>QTableWidget</code>，并在单元格中放入了一个可编辑的项。然后，我们连接了 <code>cellClicked</code> 信号到一个匿名槽函数，当单元格被点击时，这个槽函数会为被点击的项打开一个持久编辑器，允许用户连续编辑内容。</p> 
<p></p> 
<h3>49、void QTableWidget::removeCellWidget(int <em>row</em>, int <em>column</em>)</h3> 
<p>该函数引入自QT4.3版本当中，用于移出单元格当中的小组件。此处不作过多的介绍</p> 
<p></p> 
<h3>50、int QTableWidget::row(const <a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *<em>item</em>) const</h3> 
<p><code>int QTableWidget::row(const QTableWidgetItem *item) const</code> 是 QTableWidget 类的一个成员函数，用于获取指定单元格项 (<code>QTableWidgetItem</code> 对象) 所在的行索引。这个方法对于需要根据单元格项执行某些操作（比如获取其所在行的数据或更新相邻行的内容）时非常有用。</p> 
<blockquote> 
 <ul><li><code>item</code>: 常量指针，指向你想要查询其所在行的 <code>QTableWidgetItem</code> 对象。这个单元格项必须是属于调用该函数的 <code>QTableWidget</code> 实例的。</li></ul> 
</blockquote> 
<p>返回值是一个整数，表示 <code>item</code> 所在的行索引。如果 <code>item</code> 不属于该 <code>QTableWidget</code> 或为 <code>nullptr</code>，则返回值通常是 -1。</p> 
<p>示例代码：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;
#include &lt;QDebug&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(3); // 设置行数
    tableWidget.setColumnCount(2); // 设置列数

    QTableWidgetItem *item = new QTableWidgetItem("Example Item");
    tableWidget.setItem(1, 0, item); // 将项放在第二行第一列

    int rowOfItem = tableWidget.row(item); // 获取该单元格项所在的行索引
    if(rowOfItem != -1){
        qDebug() &lt;&lt; "单元格项位于第" &lt;&lt; rowOfItem &lt;&lt; "行";
    } else {
        qDebug() &lt;&lt; "未找到该单元格项或其不属于此QTableWidget";
    }

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在上述示例中，我们创建了一个 <code>QTableWidget</code>，向其第二行第一列放置了一个单元格项，然后使用 <code>row()</code> 函数获取并打印出这个单元格项所在的行索引。如果单元格项有效且属于表格，将会输出其行号；否则，输出提示信息表明未找到或不归属。</p> 
<p></p> 
<h3>51、int QTableWidget::rowCount() const</h3> 
<p><code>int QTableWidget::rowCount() const</code> 是 QTableWidget 类的一个成员函数，用于获取表格的行数，即表格中当前存在的行的数量。这个方法对于需要动态管理表格内容，比如在添加、删除行或根据行数进行循环遍历时，非常有用。</p> 
<p>返回值是一个整数，表示表格当前的行数量。如果表格为空，返回值将是0。</p> 
<p>示例代码概念：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QDebug&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(5); // 初始化设置5行
    tableWidget.setColumnCount(2); // 设置列数

    // 输出当前行数
    qDebug() &lt;&lt; "当前表格的行数：" &lt;&lt; tableWidget.rowCount();

    // 动态添加行后再输出行数
    tableWidget.setRowCount(tableWidget.rowCount() + 3); // 添加3行
    qDebug() &lt;&lt; "添加行后，当前表格的行数：" &lt;&lt; tableWidget.rowCount();

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，我们首先创建了一个初始有5行2列的 <code>QTableWidget</code>，然后输出其初始行数。接着，通过增加行数后再输出更新后的行数，演示了如何使用 <code>rowCount()</code> 方法来获取和管理表格的行信息。</p> 
<p></p> 
<h3>52、<a href="https://doc.qt.io/qt-5/qlist.html" rel="nofollow" title="QList">QList</a>&lt;<a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *&gt; QTableWidget::selectedItems() const</h3> 
<p><code>QList&lt;QTableWidgetItem*&gt; QTableWidget::selectedItems() const</code> 是 QTableWidget 类的一个成员函数，用于获取当前表格中所有被选中的单元格项（<code>QTableWidgetItem</code> 对象）的列表。这个方法对于需要处理用户批量操作选定的单元格，比如复制、剪切、删除或进行其他自定义操作时非常有用。</p> 
<p>返回值是一个 <code>QList&lt;QTableWidgetItem*&gt;</code> 类型的指针列表，包含了所有被选中的 <code>QTableWidgetItem</code> 对象。如果没有项被选中，返回的列表将为空。</p> 
<p>示例代码概念：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;
#include &lt;QDebug&gt;

void handleSelection()
{
    QList&lt;QTableWidgetItem*&gt; selectedItemsList = ui-&gt;tableWidget-&gt;selectedItems();
    foreach(QTableWidgetItem *item, selectedItemsList){
        qDebug() &lt;&lt; "选中的单元格内容：" &lt;&lt; item-&gt;text();
        // 在这里可以对每个选中项执行操作，比如复制、删除等
    }
}

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(5); // 设置行数
    tableWidget.setColumnCount(8); // 设置列数

    // 填充一些数据
    for(int row = 0; row &lt; 5; ++row){
        for(int col = 0; col &lt; 8; ++col){
            QTableWidgetItem *item = new QTableWidgetItem(QString("Row %0, Col %1").arg(row).arg(col));
            tableWidget.setItem(row, col, item);
        }
    }

    // 连接信号以处理选中项的变化，示例中直接调用了处理函数
    // 实际应用中可能根据需求，如按钮点击等触发handleSelection()

    handleSelection(); // 示例调用，直接查看初始是否有默认选中项

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在上述示例中，我们创建了一个 <code>QTableWidget</code> 并填充了一些数据，然后定义了一个 <code>handleSelection</code> 函数来处理选中的单元格。这个函数通过调用 <code>selectedItems()</code> 获取所有被选中的项，并遍历它们，打印每个项的内容。在实际应用中，可以根据业务逻辑在适当的时候调用 <code>handleSelection</code> 或者通过信号槽机制连接选中状态改变时自动处理。</p> 
<p></p> 
<h3>53、<a href="https://doc.qt.io/qt-5/qlist.html" rel="nofollow" title="QList">QList</a>&lt;<a href="https://doc.qt.io/qt-5/qtablewidgetselectionrange.html" rel="nofollow" title="QTableWidgetSelectionRange">QTableWidgetSelectionRange</a>&gt; QTableWidget::selectedRanges() const</h3> 
<p><code>QList&lt;QTableWidgetSelectionRange&gt; QTableWidget::selectedRanges() const</code> 是 QTableWidget 类的一个成员函数，用于获取当前表格中所有被选中区域的列表。每个选中区域由 <code>QTableWidgetSelectionRange</code> 类表示，它封装了一块连续的选中单元格范围，包括起始行、起始列、结束行和结束列。这个方法对于需要批量处理多个连续选中区域的操作（如复制、清除、格式化等）非常有用。</p> 
<p>返回值是一个 <code>QList&lt;QTableWidgetSelectionRange&gt;</code> 类型的列表，包含了所有被选中的区域。如果没有任何区域被选中，返回的列表将为空。</p> 
<p>示例代码概念：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QDebug&gt;

void printSelectedRanges()
{
    QList&lt;QTableWidgetSelectionRange&gt; selectedRanges = ui-&gt;tableWidget-&gt;selectedRanges();
    foreach(const QTableWidgetSelectionRange &amp;range, selectedRanges){
        qDebug() &lt;&lt; "选中区域: 起始行" &lt;&lt; range.topRow() &lt;&lt; ", 起始列" &lt;&lt; range.leftColumn()
                 &lt;&lt; "至结束行" &lt;&lt; range.bottomRow() &lt;&lt; ", 结束列" &lt;&lt; range.rightColumn();
        // 在这里可以对每个选中范围执行操作，比如复制、格式化等
    }
}

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(10); // 设置行数
    tableWidget.setColumnCount(4); // 设置列数

    // 填充一些数据（实际应用中可能根据需要填充）
    
    // 为了演示，可以手动选中一些区域，或者通过代码模拟选中情况

    // 示例调用，查看选中区域
    printSelectedRanges();

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在上述示例中，我们创建了一个 <code>QTableWidget</code> 并设置了行列数，然后定义了一个 <code>printSelectedRanges</code> 函数来打印所有被选中的区域信息。这个函数通过调用 <code>selectedRanges()</code> 获取所有选中范围，并遍历它们，打印每个范围的边界信息。实际使用中，可以结合用户交互或特定逻辑来适时调用这个处理函数。</p> 
<p></p> 
<h3>54、void QTableWidget::setCellWidget(int <em>row</em>, int <em>column</em>, <a href="https://doc.qt.io/qt-5/qwidget.html#QWidget" rel="nofollow" title="QWidget">QWidget</a> *<em>widget</em>)</h3> 
<p><code>void QTableWidget::setCellWidget(int row, int column, QWidget *widget)</code> 是 QTableWidget 类的一个成员函数，用于在指定的单元格（由行和列索引确定）中放置一个自定义的 QWidget 对象。这使得你能够在表格的单元格中嵌入复杂或自定义的界面元素，比如按钮、复选框、标签等，而不仅仅局限于文本。</p> 
<blockquote> 
 <ul><li><code>row</code>: 整型参数，表示目标单元格的行索引，索引从0开始。</li><li><code>column</code>: 整型参数，表示目标单元格的列索引，索引同样从0开始。</li><li><code>widget</code>: 指向 <code>QWidget</code> 的指针，即你想要放置在指定单元格中的小部件。</li></ul> 
</blockquote> 
<p>调用此函数后，指定位置上的任何现有的单元格项（<code>QTableWidgetItem</code>）都会被移除，并由新的 <code>widget</code> 替换。这个小部件将占据整个单元格的空间，并且如果小部件的大小策略允许，它还可以调整大小以适应单元格。</p> 
<p>示例代码：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QPushButton&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(3); // 设置3行
    tableWidget.setColumnCount(2); // 设置2列

    // 创建一个按钮并设置为第一个单元格的控件
    QPushButton *button = new QPushButton("Click me!");
    tableWidget.setCellWidget(0, 0, button); // 放置在第一行第一列

    // 显示表格
    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，我们创建了一个包含3行2列的 <code>QTableWidget</code>，并在第一个单元格中放置了一个按钮。运行程序后，你将在表格的第一个单元格看到一个可交互的按钮。</p> 
<p></p> 
<h3>55、void QTableWidget::setColumnCount(int <em>columns</em>)</h3> 
<p><code>void QTableWidget::setColumnCount(int columns)</code> 是 QTableWidget 类的一个成员函数，用于设置表格的列数。这个方法允许你在运行时动态地调整表格的结构，增加或减少列的数量，这对于响应用户需求或适应不同数据集大小的展示非常有用。</p> 
<blockquote> 
 <ul><li><code>columns</code>: 整型参数，表示新的列数。必须是非负数。如果设置为0或负数，实际列数将被设置为0，意味着清空表格的列结构。</li></ul> 
</blockquote> 
<p>调用此函数后，表格的列数将被修改为指定的数目。如果新的列数小于当前列数，超出的新列将被移除；如果新的列数大于当前列数，则会添加额外的空白列。注意，这个操作不会保留或调整超出新列数目的原有单元格中的数据或小部件，对于减少列数的情况，超出部分的数据会丢失。</p> 
<p>示例代码：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(5); // 设置初始行数为5
    tableWidget.setColumnCount(3); // 初始设置3列

    // 动态调整列数为5列
    tableWidget.setColumnCount(5);

    // 显示表格
    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，我们创建了一个初始有5行3列的 <code>QTableWidget</code>，随后通过调用 <code>setColumnCount(5)</code> 方法将列数增加到了5列。这展示了如何在程序运行时动态调整表格的列数。</p> 
<p></p> 
<h3>56、void QTableWidget::setCurrentCell(int <em>row</em>, int <em>column</em>)</h3> 
<p><code>oid QTableWidget::setCurrentCell(int row, int column)</code> 是 QTableWidget 类的一个成员函数，用于设置当前激活或选中的单元格。此函数可以帮助你程序性地控制表格中哪个单元格获得焦点或被视为当前交互的目标，这对于导航、高亮显示或预填充表单等功能特别有用。</p> 
<blockquote> 
 <ul><li><code>row</code>: 整型参数，表示想要设置为当前行的行索引，索引从0开始。</li><li><code>column</code>: 整型参数，表示想要设置为当前列的列索引，索引同样从0开始。</li></ul> 
</blockquote> 
<p>需要注意的是，从 Qt 5.12 开始，<code>setCurrentCell(int row, int column)</code> 方法已被标记为过时，推荐使用 <code>setCurrentCell(int row, int column, QItemSelectionModel::SelectionFlags command)</code> 方法，后者提供了更多的灵活性，比如可以选择是否清除其他选择、添加到当前选择等操作。</p> 
<p>示例代码（使用了旧版的 <code>setCurrentCell</code> 方法，但请考虑使用新推荐的版本）:</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(4); // 设置4行
    tableWidget.setColumnCount(3); // 设置3列

    // 设置第二行第二列（索引为1, 1）为当前单元格
    tableWidget.setCurrentCell(1, 1);

    // 显示表格
    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，我们创建了一个 <code>QTableWidget</code> 并设置了行数和列数，然后使用 <code>setCurrentCell(1, 1)</code> 方法将第二行第二列设置为当前单元格。虽然示例使用了旧版方法，但实际开发中应遵循 Qt 文档推荐，使用 <code>setCurrentCell(int row, int column, QItemSelectionModel::SelectionFlags command)</code> 以获取更多控制选项。</p> 
<p></p> 
<h3>57、void QTableWidget::setCurrentCell(int <em>row</em>, int <em>column</em>, <a href="https://doc.qt.io/qt-5/qitemselectionmodel.html#SelectionFlag-enum" rel="nofollow" title="QItemSelectionModel::SelectionFlags">QItemSelectionModel::SelectionFlags</a> <em>command</em>)</h3> 
<p><code>oid QTableWidget::setCurrentCell(int row, int column, QItemSelectionModel::SelectionFlags command)</code> 是 QTableWidget 类的一个成员函数，用于设置当前激活的单元格，并提供了控制选中行为的额外灵活性。此方法允许你不仅指定要激活的单元格位置，还能控制选中该单元格时的交互模式，比如是否替换当前选中项、添加到已有选中项等。</p> 
<blockquote> 
 <ul><li><code>row</code>: 整型参数，表示想要设置为当前行的行索引，索引从0开始。</li><li><code>column</code>: 整型参数，表示想要设置为当前列的列索引，索引同样从0开始。</li><li><code>command</code>: <code>QItemSelectionModel::SelectionFlags</code> 类型的枚举值，决定了选中单元格时的行为。常用的选择标志包括： 
   <ul><li><code>QItemSelectionModel::NoUpdate</code>：不更新选择模型。</li><li><code>QItemSelectionModel::ClearAndSelect</code>：清除所有先前的选中项，仅选中指定的单元格。</li><li><code>QItemSelectionModel::SelectCurrent</code>：如果单元格已经是当前项，则不执行任何操作。</li><li><code>QItemSelectionModel::Rows|QItemSelectionModel::Columns</code>：同时选中指定行和列中的所有单元格。</li><li>其他组合，根据需要调整选中行为。</li></ul></li></ul> 
</blockquote> 
<p>使用此方法可以更细致地控制用户界面的交互体验，特别是当涉及到复杂的多选或特定的单元格操作时。</p> 
<p>示例代码：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QItemSelectionModel&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(4); // 设置4行
    tableWidget.setColumnCount(3); // 设置3列

    // 使用 ClearAndSelect 标志，确保只有指定的单元格被选中
    tableWidget.setCurrentCell(1, 1, QItemSelectionModel::ClearAndSelect);

    // 显示表格
    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，我们创建了一个 <code>QTableWidget</code> 并设置了行数和列数，然后使用 <code>setCurrentCell(1, 1, QItemSelectionModel::ClearAndSelect)</code> 方法将第二行第二列设置为当前单元格，并清除了其他所有选中项，确保只有指定的单元格被选中。这样，你可以精确控制选中行为，提升用户体验。</p> 
<p></p> 
<h3>58、void QTableWidget::setCurrentItem(<a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *<em>item</em>)</h3> 
<p><code>void QTableWidget::setCurrentItem(QTableWidgetItem *item)</code> 是 QTableWidget 类的一个成员函数，用于设置当前激活或选中的单元格项。通过传递一个 <code>QTableWidgetItem</code> 指针，可以直接指定哪个单元格成为当前操作的焦点所在，这对于程序控制表格的导航、响应用户操作或高亮显示特定项时非常有用。</p> 
<blockquote> 
 <ul><li><code>item</code>: 指向想要设置为当前项的 <code>QTableWidgetItem</code> 对象的指针。这个单元格项必须是属于调用该函数的 <code>QTableWidget</code> 实例的。</li></ul> 
</blockquote> 
<p>调用此函数后，指定的单元格项会变为当前选中状态，如果之前有其他项被选中，它们的选中状态可能会根据当前的选中策略发生变化（例如，可能被取消选中或保留在多选集合中）。</p> 
<p>示例代码：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(9); // 设置9行
    tableWidget.setColumnCount(3); // 设置3列

    // 假设我们想设置中间位置的项为当前项
    QTableWidgetItem *middleItem = new QTableWidgetItem("Middle Item");
    tableWidget.setItem(4, 1, middleItem); // 放置在第五行第二列

    // 设置中间项为当前项
    tableWidget.setCurrentItem(middleItem);

    // 显示表格
    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在上述示例中，我们创建了一个 <code>QTableWidget</code> 并填充了一些数据，然后通过 <code>setCurrentItem(middleItem)</code> 方法将我们预先设定好的项设置为当前项。这能够帮助快速定位或突出显示表格中的特定内容。</p> 
<p></p> 
<h3>59、void QTableWidget::setCurrentItem(<a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *<em>item</em>, <a href="https://doc.qt.io/qt-5/qitemselectionmodel.html#SelectionFlag-enum" rel="nofollow" title="QItemSelectionModel::SelectionFlags">QItemSelectionModel::SelectionFlags</a> <em>command</em>)</h3> 
<p><code>void QTableWidget::setCurrentItem(QTableWidgetItem *item, QItemSelectionModel::SelectionFlags command)</code> 是 QTableWidget 类的一个成员函数，用于设置当前激活的单元格项，并允许你指定选中该项时的具体行为。这提供了比基础的 <code>setCurrentItem(QTableWidgetItem *item)</code> 更多的控制选项。</p> 
<blockquote> 
 <ul><li><code>item</code>: 指向你想要设置为当前项的 <code>QTableWidgetItem</code> 对象的指针。该单元格项必须属于调用该函数的 <code>QTableWidget</code> 实例。</li><li><code>command</code>: <code>QItemSelectionModel::SelectionFlags</code> 枚举类型的标志，用于定义选中项时的行为模式，如是否清除其他选中项、添加到当前选中项、仅当已经是当前项时不执行操作等。这为控制选中逻辑提供了灵活性。</li></ul> 
</blockquote> 
<p>示例代码：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;
#include &lt;QItemSelectionModel&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(5); // 设置5行
    tableWidget.setColumnCount(3); // 设置3列

    // 创建一个项并放置在表格中
    QTableWidgetItem *specialItem = new QTableWidgetItem("Special Item");
    tableWidget.setItem(2, 1, specialItem); // 放置在第三行第二列

    // 设置特殊项为当前项，并使用 ClearAndSelect 标志清除其他选中项
    tableWidget.setCurrentItem(specialItem, QItemSelectionModel::ClearAndSelect);

    // 显示表格
    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，我们创建了一个 <code>QTableWidget</code> 并添加了一个特殊的单元格项。通过调用 <code>setCurrentItem(specialItem, QItemSelectionModel::ClearAndSelect)</code>，我们将特殊项设置为当前项，并且清除了所有其他可能的选中项，确保只有这个特殊项被单独选中。这展示了如何通过 <code>command</code> 参数精细控制选中行为。</p> 
<p></p> 
<h3>60、void QTableWidget::setHorizontalHeaderItem(int <em>column</em>, <a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *<em>item</em>)</h3> 
<p><code>void QTableWidget::setHorizontalHeaderItem(int column, QTableWidgetItem *item)</code> 是 QTableWidget 类的一个成员函数，用于设置水平方向表头（即列标题）在指定列上的单元格项。这允许你自定义列标题的文本、图标或其他属性，以增强表格的可读性和功能性。</p> 
<ul><li><code>column</code>: 整型参数，表示要设置表头项的列索引，索引从0开始。</li><li><code>item</code>: 指向 <code>QTableWidgetItem</code> 的指针，表示你想要设置为指定列标题的项。这个单元格项可以被用来存储列标题的文本、图标、工具提示信息等。</li></ul> 
<p>当你调用这个函数时，指定列的原有表头项（如果存在）会被新的 <code>item</code> 替换。如果你传入 <code>nullptr</code>，则该列的表头项会被移除。</p> 
<p>示例代码：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(5); // 设置5行
    tableWidget.setColumnCount(3); // 设置3列

    // 自定义列标题
    QTableWidgetItem *headerItem1 = new QTableWidgetItem("Name");
    QTableWidgetItem *headerItem2 = new QTableWidgetItem("Age");
    QTableWidgetItem *headerItem3 = new QTableWidgetItem("Occupation");

    // 设置列标题
    tableWidget.setHorizontalHeaderItem(0, headerItem1);
    tableWidget.setHorizontalHeaderItem(1, headerItem2);
    tableWidget.setHorizontalHeaderItem(2, headerItem3);

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，我们创建了一个 <code>QTableWidget</code> 并设置了行数和列数，然后分别为三列创建了自定义的表头项，并通过 <code>setHorizontalHeaderItem()</code> 方法将它们分别设置为各列的标题。这使得表格的列标题更加有意义，便于用户理解。</p> 
<p></p> 
<h3>61、void QTableWidget::setHorizontalHeaderLabels(const <a href="https://doc.qt.io/qt-5/qstringlist.html" rel="nofollow" title="QStringList">QStringList</a> &amp;<em>labels</em>)</h3> 
<p><code>void QTableWidget::setHorizontalHeaderLabels(const QStringList &amp;labels)</code> 是 QTableWidget 类的一个成员函数，用于批量设置表格水平方向（列）的所有表头标签。这个方法简化了为每一列设置单独标题的过程，特别适用于初始化时一次性定义所有列标题的场景。</p> 
<blockquote> 
 <ul><li><code>labels</code>: 类型为 <code>QStringList</code> 的参数，包含了一系列字符串，每个字符串将作为表格一列的表头标签。列表的长度应当与表格的列数相匹配；如果列表长度小于表格的列数，则多余的列将没有标签；如果列表长度大于列数，则多出的标签将被忽略。</li></ul> 
</blockquote> 
<p>示例代码：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QStringList&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(5); // 设置5行
    tableWidget.setColumnCount(3); // 设置3列

    // 定义列标题列表
    QStringList headerLabels;
    headerLabels &lt;&lt; "ID" &lt;&lt; "Name" &lt;&lt; "Country";

    // 设置所有水平表头标签
    tableWidget.setHorizontalHeaderLabels(headerLabels);

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在上述示例中，我们创建了一个 <code>QTableWidget</code> 并设置了行数和列数，然后定义了一个字符串列表 <code>headerLabels</code> 包含了三列的标题，最后通过 <code>setHorizontalHeaderLabels(headerLabels)</code> 一次性设置所有列的表头标签。这种方式简洁高效，适合快速初始化表头信息。</p> 
<p></p> 
<h3>62、void QTableWidget::setItem(int <em>row</em>, int <em>column</em>, <a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *<em>item</em>)</h3> 
<p><code>void QTableWidget::setItem(int row, int column, QTableWidgetItem *item)</code> 是 QTableWidget 类的一个成员函数，用于在指定的行和列位置插入或替换一个 <code>QTableWidgetItem</code> 对象。此方法允许你动态地向表格中添加内容或更新现有单元格的属性，比如文本、图标、工具提示等。</p> 
<ul><li><code>row</code>: 整型参数，表示单元格所在的行索引，索引从0开始。</li><li><code>column</code>: 整型参数，表示单元格所在的列索引，索引同样从0开始。</li><li><code>item</code>: 指向 <code>QTableWidgetItem</code> 的指针，表示你想要放置在指定位置的单元格项。这个单元格项包含了你想要显示的信息，如文本、图标、状态标志等。</li></ul> 
<p>如果在指定位置已经有项存在，调用此函数会用新的 <code>item</code> 替换原有项。如果 <code>item</code> 为 <code>nullptr</code>，则相当于从表格中移除该位置的项。</p> 
<p>示例代码：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(3); // 设置3行
    tableWidget.setColumnCount(2); // 设置2列

    // 创建并设置单元格项
    QTableWidgetItem *item = new QTableWidgetItem("Hello, World!");
    tableWidget.setItem(1, 0, item); // 放置在第二行第一列

    // 显示表格
    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，我们创建了一个 <code>QTableWidget</code> 并设置了行数和列数，然后创建了一个单元格项并使用 <code>setItem(1, 0, item)</code> 将其设置在第二行第一列，展示了如何使用此方法向表格中添加内容。</p> 
<p></p> 
<h3>63、void QTableWidget::setItemPrototype(const <a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *<em>item</em>)</h3> 
<p><code>void QTableWidget::setItemPrototype(const QTableWidgetItem *item)</code> 是 QTableWidget 类的一个成员函数，用于设置用于复制新创建的单元格项的原型。当你在 QTableWidget 中添加新项时，如果没有明确指定项的属性（如文本、图标等），新项将基于这个原型进行初始化。这样可以确保新添加的项具有一致的外观和默认设置，减少了重复配置的工作量。</p> 
<blockquote> 
 <ul><li><code>item</code>: 常量指针，指向一个 <code>QTableWidgetItem</code> 对象，作为新创建单元格项的原型。这个原型项的所有属性，如文本、图标、背景色、字体等，都将成为新项的默认设置。</li></ul> 
</blockquote> 
<p>一旦设置了原型，通过 <code>setItem()</code> 或其他方式自动创建的项将继承原型的属性，除非在创建时明确覆盖这些属性。如果未设置原型，新创建的项将使用默认的构造参数。</p> 
<p>示例代码：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(3); // 设置3行
    tableWidget.setColumnCount(2); // 设置2列

    // 创建一个原型单元格项
    QTableWidgetItem *prototypeItem = new QTableWidgetItem();
    prototypeItem-&gt;setBackground(Qt::lightGray); // 设置背景色为浅灰色
    prototypeItem-&gt;setFont(QFont("Arial", 10)); // 设置字体为Arial，字号10

    // 设置原型项
    tableWidget.setItemPrototype(prototypeItem);

    // 添加新项到表格，新项将继承原型的属性
    for(int row = 0; row &lt; 3; ++row){
        for(int col = 0; col &lt; 2; ++col){
            QTableWidgetItem *newItem = new QTableWidgetItem(QString("Item at (%0, %1)").arg(row).arg(col));
            tableWidget.setItem(row, col, newItem);
        }
    }

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在上述示例中，我们创建了一个原型单元格项并设置了背景色和字体，然后通过 <code>setItemPrototype(prototypeItem)</code> 将其设为 QTableWidget 的原型。之后，无论何时通过 <code>setItem()</code> 添加新项，这些项都将自动采用原型的背景色和字体设置，除非显式地为新项指定了不同的属性。</p> 
<p></p> 
<h3>64、void QTableWidget::setRangeSelected(const <a href="https://doc.qt.io/qt-5/qtablewidgetselectionrange.html" rel="nofollow" title="QTableWidgetSelectionRange">QTableWidgetSelectionRange</a> &amp;<em>range</em>, bool <em>select</em>)</h3> 
<p><code>void QTableWidget::setRangeSelected(const QTableWidgetSelectionRange &amp;range, bool select)</code> 是 QTableWidget 类的一个成员函数，用于在表格中选择或取消选择一个连续的单元格范围。这个方法对于需要对表格中的特定区域进行批量选择操作时非常有用，比如在实现批量编辑或高亮显示数据时。</p> 
<blockquote> 
 <ul><li><code>range</code>: 类型为 <code>QTableWidgetSelectionRange</code> 的参数，定义了要选择或取消选择的单元格范围。它包含了起始行号、起始列号、结束行号和结束列号，定义了一个矩形区域。</li><li><code>select</code>: 布尔型参数，指示是否应该选择指定范围内的单元格。如果为 <code>true</code>，则范围内所有单元格被选中；如果为 <code>false</code>，则取消这些单元格的选中状态。</li></ul> 
</blockquote> 
<p>示例代码：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetSelectionRange&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(5); // 设置5行
    tableWidget.setColumnCount(4); // 设置4列

    // 假设我们要选择第二行到第四行，第二列到第三列的范围
    QTableWidgetSelectionRange selectionRange(1, 1, 3, 2); // 注意：行、列索引从0开始

    // 选择这个范围内的单元格
    tableWidget.setRangeSelected(selectionRange, true);

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p></p> 
<h3>65、void QTableWidget::setRowCount(int <em>rows</em>)</h3> 
<p><code>void QTableWidget::setRowCount(int rows)</code> 是 QTableWidget 类的一个成员函数，用于设置表格的行数。这个方法允许你动态地改变表格的大小，无论是增加行数以容纳更多数据还是减少行数以适应数据变化，这对于构建灵活的用户界面非常有用。</p> 
<blockquote> 
 <ul><li><code>rows</code>: 整型参数，表示新的行数。必须是非负数。如果设置的行数小于当前行数，多余的行将被移除；如果设置的行数大于当前行数，则会添加新的空行。</li></ul> 
</blockquote> 
<p>调用此函数后，QTableWidget的行数将被修改为指定的数目，同时保持现有的列数不变。如果减少行数导致某些单元格项不再有效，这些项会被自动删除。增加行数时，新行默认为空白单元格，可以通过 <code>setItem()</code> 方法进一步填充内容。</p> 
<p>示例代码：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setColumnCount(3); // 先设置列数为3

    // 初始设置行数为5
    tableWidget.setRowCount(5);

    // 假设我们根据数据变化需要动态调整行数，增加到10行
    tableWidget.setRowCount(10);

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，我们首先创建了一个 <code>QTableWidget</code> 并设置了列数，然后通过 <code>setRowCount()</code> 方法先设置行数为5，之后根据假设的需要调整为10行。这样展示了如何根据程序运行时的需求动态调整表格的大小。</p> 
<p></p> 
<h3>66、void QTableWidget::setVerticalHeaderItem(int <em>row</em>, <a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *<em>item</em>)</h3> 
<p><code>void QTableWidget::setVerticalHeaderItem(int row, QTableWidgetItem *item)</code> 是 QTableWidget 类的一个成员函数，用于设置垂直方向表头（即行标题）在指定行上的单元格项。这个方法允许你自定义行标题的文本、图标等属性，从而增强表格的可读性和专业性。</p> 
<blockquote> 
 <ul><li><code>row</code>: 整型参数，表示要设置表头项的行索引，索引从0开始。</li><li><code>item</code>: 指向 <code>QTableWidgetItem</code> 的指针，表示你想要设置为指定行标题的项。通过这个单元格项，你可以控制行标题的显示文本、图标、工具提示等特性。</li></ul> 
</blockquote> 
<p>调用此函数后，指定行的垂直表头项将被替换为提供的 <code>item</code>。如果传入 <code>nullptr</code>，则该行的垂直表头项会被移除。</p> 
<p>示例代码：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(5); // 设置5行
    tableWidget.setColumnCount(3); // 设置3列

    // 创建并设置垂直表头项
    QTableWidgetItem *headerItem1 = new QTableWidgetItem("Category 1");
    QTableWidgetItem *headerItem2 = new QTableWidgetItem("Category 2");
    QTableWidgetItem *headerItem3 = new QTableWidgetItem("Category 3");
    QTableWidgetItem *headerItem4 = new QTableWidgetItem("Category 4");
    QTableWidgetItem *headerItem5 = new QTableWidgetItem("Category 5");

    // 分别设置每一行的垂直表头
    tableWidget.setVerticalHeaderItem(0, headerItem1);
    tableWidget.setVerticalHeaderItem(1, headerItem2);
    tableWidget.setVerticalHeaderItem(2, headerItem3);
    tableWidget.setVerticalHeaderItem(3, headerItem4);
    tableWidget.setVerticalHeaderItem(4, headerItem5);

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，我们创建了一个 <code>QTableWidget</code> 并设置了行数和列数，然后为每一行创建并设置了自定义的垂直表头项。这使得表格的行标题更具描述性，提高了用户体验。</p> 
<p></p> 
<h3>67、void QTableWidget::setVerticalHeaderLabels(const <a href="https://doc.qt.io/qt-5/qstringlist.html" rel="nofollow" title="QStringList">QStringList</a> &amp;<em>labels</em>)</h3> 
<p><code>void QTableWidget::setVerticalHeaderLabels(const QStringList &amp;labels)</code> 是 QTableWidget 类的一个成员函数，用于设置表格垂直方向（行标题）的所有标签。这个方法允许你一次性为表格的每一行设置标题，简化了逐个设置行标题的过程，尤其适合初始化时快速定义整个表格的行标签。</p> 
<blockquote> 
 <ul><li><code>labels</code>: 类型为 <code>QStringList</code> 的参数，包含了一系列字符串，每个字符串将作为表格一行的垂直表头标签。列表的长度应当与表格的行数相匹配；如果列表长度小于表格的行数，则多余的行将没有标签；如果列表长度大于行数，则多出的标签将被忽略。</li></ul> 
</blockquote> 
<p>示例代码：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QStringList&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(3); // 设置3行
    tableWidget.setColumnCount(6); // 设置6列

    // 定义行标题列表
    QStringList headerLabels;
    headerLabels &lt;&lt; "Row 1" &lt;&lt; "Row 2" &lt;&lt; "Row 3";

    // 设置所有垂直表头标签
    tableWidget.setVerticalHeaderLabels(headerLabels);

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，我们创建了一个 <code>QTableWidget</code> 并设置了行数和列数，然后定义了一个字符串列表 <code>headerLabels</code> 包含了三行的垂直标题，通过 <code>setVerticalHeaderLabels(headerLabels)</code> 一次性设置所有行的标签。这种方法简单快捷，便于初始化时统一配置行标题信息。</p> 
<p></p> 
<h3>68、void QTableWidget::sortItems(int <em>column</em>, <a href="https://doc.qt.io/qt-5/qt.html#SortOrder-enum" rel="nofollow" title="Qt::SortOrder">Qt::SortOrder</a> <em>order</em> = Qt::AscendingOrder)</h3> 
<p><code>void QTableWidget::sortItems(int column, Qt::SortOrder order = Qt::AscendingOrder)</code> 是 QTableWidget 类的一个成员函数，用于对表格中的项按指定列进行排序。这个功能对于展示可排序的数据视图非常有用，用户可以按照某一列的值对整个表格内容进行升序或降序排列。</p> 
<blockquote> 
 <ul><li><code>column</code>: 整型参数，表示依据哪一列进行排序，列索引从0开始。</li><li><code>order</code>: 类型为 <code>Qt::SortOrder</code> 的参数，默认值为 <code>Qt::AscendingOrder</code>，表示升序排列。如果你想按降序排列，可以指定为 <code>Qt::DescendingOrder</code>。</li></ul> 
</blockquote> 
<p>请注意，这个方法只适用于表格中的文本数据，并且对于含有小部件的单元格可能无法正常排序。此外，它不直接支持自定义的排序逻辑，如果需要更复杂的排序规则（如根据数据的非文本属性排序），可能需要自定义排序算法或使用模型/视图架构（如 <code>QTableView</code> 配合 <code>QSortFilterProxyModel</code>）。</p> 
<p>示例代码：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(5); // 设置5行
    tableWidget.setColumnCount(2); // 设置2列

    // 填充数据
    tableWidget.setItem(0, 0, new QTableWidgetItem("Apple"));
    tableWidget.setItem(0, 1, new QTableWidgetItem("Red"));
    tableWidget.setItem(1, 0, new QTableWidgetItem("Banana"));
    tableWidget.setItem(1, 1, new QTableWidgetItem("Yellow"));
    tableWidget.setItem(2, 0, new QTableWidgetItem("Cherry"));
    tableWidget.setItem(2, 1, new QTableWidgetItem("Red"));
    tableWidget.setItem(3, 0, new QTableWidgetItem("Grape"));
    tableWidget.setItem(3, 1, new QTableWidgetItem("Purple"));
    tableWidget.setItem(4, 0, new QTableWidgetItem("Orange"));
    tableWidget.setItem(4, 1, new QTableWidgetItem("Orange"));

    // 按第一列升序排序
    tableWidget.sortItems(0, Qt::AscendingOrder);

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，我们创建了一个 <code>QTableWidget</code> 并填充了一些数据，然后使用 <code>sortItems(0, Qt::AscendingOrder)</code> 按第一列的文本内容进行了升序排序。这样，表格中的行将根据第一列的字母顺序重新排列。</p> 
<p></p> 
<h3>69、<a href="https://doc.qt.io/qt-5/qt.html#DropAction-enum" rel="nofollow" title="Qt::DropActions">Qt::DropActions</a> QTableWidget::supportedDropActions() const</h3> 
<p></p> 
<p><code>Qt::DropActions QTableWidget::supportedDropActions() const</code> 是 QTableWidget 类的一个成员函数，用于查询该表格支持的拖放操作类型。拖放操作是用户界面中常见的交互方式之一，允许用户通过鼠标将数据（如文本、文件、控件等）从一个位置拖动到另一个位置并“放下”，从而实现数据的传输或操作。</p> 
<blockquote> 
 <p><code>Qt::DropActions</code> 是一个枚举类型，定义了多种拖放操作，包括：</p> 
 <ul><li><code>Qt::CopyAction</code>：复制操作，拖动的数据会被复制到目标位置。</li><li><code>Qt::MoveAction</code>：移动操作，数据从源位置移动到目标位置，源位置的数据会被移除。</li><li><code>Qt::LinkAction</code>：链接操作，创建数据的链接或引用，而不直接复制或移动数据。</li><li><code>Qt::IgnoreAction</code>：忽略操作，不支持拖放。</li></ul> 
</blockquote> 
<p><code>supportedDropActions()</code> 函数返回一个 <code>Qt::DropActions</code> 类型的值，它是所支持操作的组合，即可以是上述操作的任意组合或无操作。</p> 
<p>示例代码概念：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QDragEnterEvent&gt;
#include &lt;QDebug&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例

    // 打印当前支持的拖放操作
    qDebug() &lt;&lt; "Supported drop actions: " &lt;&lt; tableWidget.supportedDropActions();

    // 可以在这里自定义拖放行为，例如通过重写dragEnterEvent等事件处理器
    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>请注意，虽然 <code>QTableWidget</code> 默认支持基本的拖放操作，但通常需要通过重写如 <code>dragEnterEvent</code>、<code>dropEvent</code> 等事件处理器来自定义具体的拖放逻辑，以实现数据的接收、处理及显示。上述示例中，只是展示了如何查询默认支持的拖放动作，实际应用中可能需要根据需求调整这些行为。</p> 
<p></p> 
<h3>70、<a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *QTableWidget::takeHorizontalHeaderItem(int <em>column</em>)</h3> 
<p><code>QTableWidgetItem *QTableWidget::takeHorizontalHeaderItem(int column)</code> 是 QTableWidget 类的一个成员函数，用于从表格的水平表头（即列标题）中移除并返回指定列的 <code>QTableWidgetItem</code> 对象。这个方法允许你动态地移除和获取列标题项，以便于进行修改或删除列标题内容，而不仅仅是隐藏它。</p> 
<ul><li><code>column</code>: 整型参数，表示要移除表头项的列索引，索引从0开始。</li></ul> 
<p>返回值是被移除的 <code>QTableWidgetItem</code> 指针，如果成功移除则非空；如果列索引无效或该列没有设置表头项，则返回 <code>nullptr</code>。</p> 
<p>示例代码：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;
#include &lt;QDebug&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(5); // 设置5行
    tableWidget.setColumnCount(3); // 设置3列

    // 设置列标题
    tableWidget.setHorizontalHeaderItem(0, new QTableWidgetItem("Column 1"));
    tableWidget.setHorizontalHeaderItem(1, new QTableWidgetItem("Column 2"));
    tableWidget.setHorizontalHeaderItem(2, new QTableWidgetItem("Column 3"));

    // 移除第二列的表头项并打印其内容
    QTableWidgetItem *removedItem = tableWidget.takeHorizontalHeaderItem(1);
    if(removedItem){
        qDebug() &lt;&lt; "移除的列标题内容：" &lt;&lt; removedItem-&gt;text();
        // 注意: 通常情况下，此处应负责删除或管理好 removedItem 的内存，以免内存泄漏。
        delete removedItem;
    } else {
        qDebug() &lt;&lt; "没有移除任何列标题";
    }

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，我们首先创建了一个 <code>QTableWidget</code> 并设置了行数和列数，接着设置了每列的标题。然后，我们使用 <code>takeHorizontalHeaderItem(1)</code> 方法尝试移除第二列的表头项，并打印其内容。如果成功移除，还需注意手动管理好返回的 <code>QTableWidgetItem</code> 指针的生命周期，避免内存泄漏。</p> 
<p></p> 
<h3>71、<a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *QTableWidget::takeItem(int <em>row</em>, int <em>column</em>)</h3> 
<p><code>QTableWidgetItem *QTableWidget::takeItem(int row, int column)</code> 是 QTableWidget 类的一个成员函数，用于从表格中移除指定行和列交叉处的单元格项，并返回该 <code>QTableWidgetItem</code> 对象的指针。此方法允许你临时或永久地从表格中移除某个单元格的内容，同时保留对该项的访问以便于后续使用或修改。</p> 
<blockquote> 
 <ul><li><code>row</code>: 整型参数，表示要移除单元格项的行索引，索引从0开始。</li><li><code>column</code>: 整型参数，表示要移除单元格项的列索引，索引同样从0开始。</li></ul> 
</blockquote> 
<p>返回值是被移除的 <code>QTableWidgetItem</code> 指针，如果移除成功则非空；如果指定的行和列位置没有项，则返回 <code>nullptr</code>。</p> 
<p>示例代码：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;
#include &lt;QDebug&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(7); // 设置7行
    tableWidget.setColumnCount(5); // 设置5列

    // 填充一些数据作为示例
    for(int row = 0; row &lt; 7; ++row)
        for(int col = 0; col &lt; 5; ++col)
            tableWidget.setItem(row, col, new QTableWidgetItem(QString("Cell: %0,%1").arg(row)));

    // 尝试移除第三行第二列的单元格项并检查结果
    QTableWidgetItem *removedItem = tableWidget.takeItem(2, 1); // 第三行第二列
    if(removedItem){
        qDebug() &lt;&lt; "移除的单元格内容：" &lt;&lt; removedItem-&gt;text();
        // 注意: 通常情况下，此处应负责删除或管理好 removedItem 的内存，以免内存泄漏。
        delete removedItem;
    } else {
        qDebug() &lt;&lt; "没有移除任何单元格";
    }

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，我们首先创建了一个 <code>QTableWidget</code> 并设置了行数和列数，接着填充了一些示例数据。然后，我们使用 <code>takeItem(2, 1)</code> 方法尝试移除第三行第二列的单元格项，并打印其内容。如果成功移除，同样需要注意手动管理好返回的 <code>QTableWidgetItem</code> 指针的生命周期，避免内存泄漏。</p> 
<p></p> 
<h3>72、<a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *QTableWidget::takeVerticalHeaderItem(int <em>row</em>)</h3> 
<p><code>QTableWidgetItem *QTableWidget::takeVerticalHeaderItem(int row)</code> 是 QTableWidget 类的一个成员函数，用于从表格的垂直表头（即行标题）中移除指定行的 <code>QTableWidgetItem</code> 对象，并返回该对象的指针。此方法允许你动态地移除特定行的标题项，以便于修改或彻底移除行标题内容，而不仅仅是隐藏它。</p> 
<blockquote> 
 <ul><li><code>row</code>: 整型参数，表示要移除表头项的行索引，索引从0开始。</li></ul> 
</blockquote> 
<p>返回值是被移除的 <code>QTableWidgetItem</code> 指针，如果移除成功则非空；如果行索引无效或该行没有设置垂直表头项，则返回 <code>nullptr</code>。</p> 
<p>示例代码：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;
#include &lt;QDebug&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(5); // 设置5行
    tableWidget.setColumnCount(3); // 设置3列

    // 设置行标题
    for(int i = 0; i &lt; 5; ++i)
        tableWidget.setVerticalHeaderItem(i, new QTableWidgetItem(QString("Row %0").arg(i)));

    // 移除第三行的垂直表头项并打印其内容
    QTableWidgetItem *removedItem = tableWidget.takeVerticalHeaderItem(2); // 第三行
    if(removedItem){
        qDebug() &lt;&lt; "移除的行标题内容：" &lt;&lt; removedItem-&gt;text();
        // 注意: 通常情况下，此处应负责删除或管理好 removedItem 的内存，以免内存泄漏。
        delete removedItem;
    } else {
        qDebug() &lt;&lt; "没有移除任何行标题";
    }

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在这个示例中，我们首先创建了一个 <code>QTableWidget</code> 并设置了行数和列数，接着设置了每行的标题。然后，我们使用 <code>takeVerticalHeaderItem(2)</code> 方法尝试移除第三行的垂直表头项，并打印其内容。如果成功移除，还需注意手动管理好返回的 <code>QTableWidgetItem</code> 指针的生命周期，避免内存泄漏。</p> 
<p></p> 
<h3>73、<a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *QTableWidget::verticalHeaderItem(int <em>row</em>) const</h3> 
<p><code>QTableWidgetItem *QTableWidget::verticalHeaderItem(int row) const</code> 是 QTableWidget 类的一个成员函数，用于获取指定行的垂直表头（行标题）项的指针。这个方法允许你访问和操作特定行的标题项，以便于获取或修改其内容，比如文本、图标等属性。</p> 
<blockquote> 
 <ul><li><code>row</code>: 整型参数，表示要获取表头项的行索引，索引从0开始。</li></ul> 
</blockquote> 
<p>返回值是一个指向 <code>QTableWidgetItem</code> 的指针，如果指定行有设置表头项则非空；如果没有设置或索引无效，则返回 <code>nullptr</code>。</p> 
<p>示例代码：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;
#include &lt;QDebug&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(5); // 设置5行
    tableWidget.setColumnCount(3); // 设置3列

    // 设置一些行标题作为示例
    for(int i = 0; i &lt; 5; ++i)
        tableWidget.setVerticalHeaderItem(i, new QTableWidgetItem(QString("Row %0").arg(i)));

    // 获取第三行的垂直表头项并打印其内容
    QTableWidgetItem *headerItem = tableWidget.verticalHeaderItem(2); // 获取第三行的表头项
    if(headerItem){
        qDebug() &lt;&lt; "第三行的行标题内容：" &lt;&lt; headerItem-&gt;text();
    } else {
        qDebug() &lt;&lt; "没有找到指定行的行标题";
    }

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在此示例中，我们首先创建了一个 <code>QTableWidget</code> 并设置了行数和列数，接着为每行设置了标题。然后，我们使用 <code>verticalHeaderItem(2)</code> 方法获取第三行的垂直表头项，并打印其内容。通过这种方式，你可以访问并根据需要操作特定行的标题项。</p> 
<p></p> 
<h3>74、int QTableWidget::visualColumn(int <em>logicalColumn</em>) const</h3> 
<p><code>int QTableWidget::visualColumn(int logicalColumn) const</code> 是 QTableWidget 类的一个成员函数，用于获取给定逻辑列索引对应的视觉列索引。在 QTableWidget 中，逻辑索引指的是表格的实际列顺序，而视觉索引则考虑了列的隐藏情况。如果某列被隐藏，那么视觉索引会跳过这些隐藏的列，直接映射到可视列的索引上。</p> 
<blockquote> 
 <ul><li><code>logicalColumn</code>: 整型参数，表示逻辑上的列索引，索引从0开始。</li></ul> 
</blockquote> 
<p>返回值是整型，表示逻辑列在当前视觉布局中的索引。如果逻辑列被隐藏，则返回值可能不对应于任何实际的视觉列，或者如果表格没有列被隐藏，逻辑列索引和视觉列索引将会相同。</p> 
<p>请注意，这个方法对于需要基于当前视图而非表格结构本身进行操作的情景非常有用，比如当需要根据用户看到的列来高亮或操作表格时。</p> 
<p>示例代码概念：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QDebug&gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QTableWidget tableWidget; // 创建一个QTableWidget实例
    tableWidget.setRowCount(5); // 设置5行
    tableWidget.setColumnCount(5); // 设置5列

    // 假设我们隐藏了第二列
    tableWidget.setColumnHidden(1, true);

    // 获取逻辑上第三列的视觉索引，由于第二列被隐藏，逻辑索引2在视觉上将是1
    int visualColIndex = tableWidget.visualColumn(2);
    qDebug() &lt;&lt; "逻辑索引为2的列在视觉上的索引是：" &lt;&lt; visualColIndex;

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在上面的示例中，尽管我们请求的是逻辑索引为2（第三列）的视觉索引，但由于第二列被隐藏，视觉上第三列实际上变成了索引为1的列。因此，<code>visualColumn(2)</code> 返回的结果会是1。</p> 
<p></p> 
<h3>75、<a href="https://doc.qt.io/qt-5/qrect.html" rel="nofollow" title="QRect">QRect</a> QTableWidget::visualItemRect(const <a href="https://doc.qt.io/qt-5/qtablewidgetitem.html" rel="nofollow" title="QTableWidgetItem">QTableWidgetItem</a> *<em>item</em>) const</h3> 
<p><code>QRect QTableWidget::visualItemRect(const QTableWidgetItem *item) const</code> 是 QTableWidget 类的一个成员函数，用于获取指定单元格项在视图中的矩形区域（坐标）。这个方法考虑了滚动条的位置、隐藏列、隐藏行等因素，返回的是在屏幕上实际可见的矩形区域，而不是表格模型中的绝对位置。</p> 
<blockquote> 
 <ul><li><code>item</code>: 常量指针，指向你想查询其视觉位置的 <code>QTableWidgetItem</code> 对象。这个单元格项必须是属于调用该函数的 QTableWidget 实例。</li></ul> 
</blockquote> 
<p>返回值是一个 <code>QRect</code> 对象，表示单元格项在视图中的矩形区域，坐标相对于 QTableWidget 的可视区域。这可以用于高亮显示、绘制覆盖或进行其他与特定单元格位置相关的用户界面操作。</p> 
<p>示例代码概念：</p> 
<pre><code class="language-cpp">#include &lt;QApplication&gt;
#include &lt;QTableWidget&gt;
#include &lt;QTableWidgetItem&gt;
#include &lt;QPainter&gt;
#include &lt;QPaintEvent&gt;

class CustomTableWidget : public QTableWidget {
public:
    CustomTableWidget(QWidget *parent = nullptr) : QTableWidget(parent) {}

protected:
    void paintEvent(QPaintEvent *event) override {
        QTableWidget::paintEvent(event);

        // 假设我们有一个想要高亮显示的项
        QTableWidgetItem *itemToHighlight = item(1, 1); // 示例：第二行第二列的项
        if(itemToHighlight) {
            QRect rect = visualItemRect(itemToHighlight); // 获取该项的视觉矩形区域
            QPainter painter(this);
            painter.setPen(Qt::red);
            painter.drawRect(rect.adjusted(0, 0, 0, -1, -1)); // 调整矩形边缘以完美贴合单元格
        }
    }
};

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    CustomTableWidget tableWidget; // 使用自定义的QTableWidget
    tableWidget.setRowCount(5);
    tableWidget.setColumnCount(5);

    // 填充一些项作为示例
    for(int row = 0; row &lt; 5; ++row)
        for(int col = 0; col &lt; 5; ++col)
            tableWidget.setItem(row, col, new QTableWidgetItem(QString("Cell: %0,%1").arg(row)));

    tableWidget.show();

    return a.exec();
}</code></pre> 
<p>在上述示例中，我们创建了一个继承自 <code>QTableWidget</code> 的 <code>CustomTableWidget</code> 类，并在 <code>paintEvent</code> 处理函数中使用 <code>visualItemRect(item)</code> 获取了一个特定单元格项在视图中的矩形区域，然后用红色画出了该矩形以示例高亮显示。这展示了如何利用 <code>visualItemRect</code> 来获取并操作单元格的视觉位置信息。</p> 
<p></p> 
<h3>76、int QTableWidget::visualRow(int <em>logicalRow</em>) const</h3> 
<p><code>int QTableWidget::visualRow(int logicalRow) const</code> 是 QTableWidget 类的一个成员函数，用于获取逻辑行号对应的可视行号。在QTableWidget中，逻辑行是指表格模型中的行索引，而可视行则是考虑到表格当前的排序、过滤及隐藏行之后，在视图中实际显示的行位置。</p> 
<blockquote> 
 <ul><li><code>logicalRow</code>: 一个整数，表示想要查询其可视位置的逻辑行号。</li></ul> 
</blockquote> 
<p>返回值是一个整数，表示逻辑行在视图中的位置（可视行号）。如果该逻辑行被隐藏，则此函数可能返回-1，具体行为可能会依据Qt版本和设置有所不同。</p> 
<p>这个方法对于需要根据数据模型中的行位置来执行与视图相关的操作非常有用，例如高亮显示某一行时，确保使用的是当前视图中正确的行位置。</p> 
<p>请注意，如果表格没有进行任何排序、过滤或隐藏行的操作，逻辑行号通常会与可视行号相同。但在进行了上述操作后，两者可能会有差异。</p> 
<p>示例用法：</p> 
<pre><code class="language-cpp">QTableWidget *table = ...; // 假设table已经被正确初始化并填充了数据
int logicalRowIndex = 3; // 假设我们对逻辑上第4行（索引3）的可视位置感兴趣
int visualRowIndex = table-&gt;visualRow(logicalRowIndex);

if (visualRowIndex != -1) {
    // 可视行号有效，可以据此进行操作，比如高亮显示该行
    QTableWidgetItem *item = table-&gt;item(visualRowIndex, 0); // 假设我们要访问第一列的项
    if (item) {
        // 对item进行操作...
    }
} else {
    // 逻辑行被隐藏，不执行任何操作或处理隐藏情况
}</code></pre> 
<p>这段代码演示了如何使用 <code>visualRow()</code> 函数获取逻辑行在视图中的位置，并基于这个位置执行进一步的操作。</p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/046bf19901562d075b275e4ae970be21/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">香橙派Orange AI Pro 初体验</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7c121dcaabfa3cb016cd94763529c9c1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Apifox 更新｜编排模式、Markdown 编辑器升级、自动申请 SSL 证书、用户反馈问题优化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>