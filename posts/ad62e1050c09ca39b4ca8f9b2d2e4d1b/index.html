<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>web安全-前端层面 - 编程大咖</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://bcdaka.github.io/posts/ad62e1050c09ca39b4ca8f9b2d2e4d1b/">
  <meta property="og:site_name" content="编程大咖">
  <meta property="og:title" content="web安全-前端层面">
  <meta property="og:description" content="参考资料引荐
https://blog.csdn.net/hack0919/article/details/130929154 XSS 简介 跨站脚本攻击(Cross-Site Scripting, 简称XSS)当用户将恶意代码注入网页时，其他用户在浏览网页时就会受到影响攻击主要方向主要用于盗取cookie凭据，钓鱼攻击，流量指向等 攻击类型 反射型xss 反射型xss又叫非持久型xss (一般具有一次性),交互的数据一般不会被存在数据库里面也就是一次性
攻击者可以将恶意的XSS代码包含在URL漏洞，然后发送给用户，诱导用户自己点开(一次性)
是通过URL参数直接注入，一般是使用alert来探测站点是否防御，直接攻击的使用src来引入自己的脚本
// 例如 http://localhost:1521/?from=&lt;script&gt;alert(1)&lt;/script&gt;bing DOM型xss DOM的全称为Document Object Model，即文档对象模型，DOM通常用于代表在HTML、XHTML和XML中的对象。使用DOM可以允许程序和脚本动态地访问和更新文档的内容、结构和样式。DOM型xss不基于后端，是修改属性，插入内容 document.write… 等改变前端DOM改变结构后，造成攻击 存储型xss 攻击脚本将永久储存到目标服务器的数据库或文件中，因此每次访问网页时都会触发xss漏洞，所有人访问时都会造成攻击漏洞一般存在于留言板，微博，论坛，博客等 // 例如在留言板提交的时候输入 &lt;script&gt;alert(&#39;hello&#39;)&lt;/script&gt; 防御方案 客户端传递给服务器的时候，需要校验先过滤一下，转义一下服务端入库存储在做一次过滤直接在输出的时候过滤 服务端返回转义 服务端解析返回的时候，把返回的数据进行encodeURIComponent 客户端转义 页面提交、回显均做处理
HTML处理 HTML节点 转义掉&lt;&lt;和&gt;&gt; 即转义掉&lt;&gt;即可，转义的时机有两种，一种是写入数据库的时候进行转义，另一种实在解析的时候进行转义。 var escapeHtml = function(str){ str = str.replace(/&gt;/g, &#39;&amp;lt;&#39;); str = str.replace(/&gt;/g, &#39;&amp;gt;&#39;); return str; } escapeHtml(content); HTML属性 转义”&amp;quto; 即转义掉双引号，&#39;转义掉单引号，(另一个要注意的是实际上html的属性可以不包括引号，因此严格的说我们还需要对空格进行转义，但是这样会导致渲染的时候空格数不对，因此我们不转义空格，然后再写html属性的时候全部带上引号)这样属性就不会被提前关闭了 var escapeHtmlProperty = function(str){ str = str.replace(/&#34;/g, &#39;&amp;quto;&#39;); str = str.replace(/&#39;/g, &#39;&amp;#39;&#39;); str = str.">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-11T19:20:40+08:00">
    <meta property="article:modified_time" content="2024-06-11T19:20:40+08:00">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程大咖" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程大咖</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">web安全-前端层面</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>参考资料引荐</p> 
<ul><li>https://blog.csdn.net/hack0919/article/details/130929154</li></ul> 
<h2><a id="XSS_4"></a>XSS</h2> 
<h3><a id="_6"></a>简介</h3> 
<ul><li>跨站脚本攻击(Cross-Site Scripting, 简称XSS)</li><li>当用户将恶意代码注入网页时，其他用户在浏览网页时就会受到影响</li><li>攻击主要方向主要用于盗取cookie凭据，钓鱼攻击，流量指向等</li></ul> 
<h3><a id="_12"></a>攻击类型</h3> 
<h4><a id="xss_14"></a>反射型xss</h4> 
<ul><li> <p>反射型xss又叫非持久型xss (一般具有一次性),交互的数据一般不会被存在数据库里面也就是一次性</p> </li><li> <p>攻击者可以将恶意的XSS代码包含在URL漏洞，然后发送给用户，诱导用户自己点开(一次性)</p> </li><li> <p>是通过URL参数直接注入，一般是使用alert来探测站点是否防御，直接攻击的使用src来引入自己的脚本</p> <pre><code class="prism language-js"><span class="token comment">// 例如</span>
<span class="token literal-property property">http</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">:</span><span class="token number">1521</span><span class="token operator">/</span><span class="token operator">?</span>from<span class="token operator">=</span><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>bing
</code></pre> </li></ul> 
<h4><a id="DOMxss_27"></a>DOM型xss</h4> 
<ul><li>DOM的全称为Document Object Model，即文档对象模型，DOM通常用于代表在HTML、XHTML和XML中的对象。使用DOM可以允许程序和脚本动态地访问和更新文档的内容、结构和样式。</li><li>DOM型xss不基于后端，是修改属性，插入内容 document.write… 等改变前端DOM</li><li>改变结构后，造成攻击</li></ul> 
<h4><a id="xss_33"></a>存储型xss</h4> 
<ul><li>攻击脚本将永久储存到目标服务器的数据库或文件中，因此每次访问网页时都会触发xss漏洞，所有人访问时都会造成攻击</li><li>漏洞一般存在于留言板，微博，论坛，博客等</li></ul> 
<pre><code class="prism language-js"><span class="token comment">// 例如在留言板提交的时候输入</span>
<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre> 
<h3><a id="_45"></a>防御方案</h3> 
<ul><li>客户端传递给服务器的时候，需要校验先过滤一下，转义一下</li><li>服务端入库存储在做一次过滤</li><li>直接在输出的时候过滤</li></ul> 
<h4><a id="_51"></a>服务端返回转义</h4> 
<ul><li>服务端解析返回的时候，把返回的数据进行encodeURIComponent</li></ul> 
<h4><a id="_55"></a>客户端转义</h4> 
<blockquote> 
 <p>页面提交、回显均做处理</p> 
</blockquote> 
<h5><a id="HTML_59"></a>HTML处理</h5> 
<h6><a id="HTML_61"></a>HTML节点</h6> 
<ul><li>转义掉&lt;&lt;和&gt;&gt; 即转义掉&lt;&gt;即可，转义的时机有两种，一种是写入数据库的时候进行转义，另一种实在解析的时候进行转义。</li></ul> 
<pre><code class="prism language-js"><span class="token keyword">var</span> <span class="token function-variable function">escapeHtml</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">&gt;</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token string">'&amp;lt;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">&gt;</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token string">'&amp;gt;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> str<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token function">escapeHtml</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h6><a id="HTML_75"></a>HTML属性</h6> 
<ul><li>转义”&amp;quto; 即转义掉双引号，'转义掉单引号，(另一个要注意的是实际上html的属性可以不包括引号，因此严格的说我们还需要对空格进行转义，但是这样会导致渲染的时候空格数不对，因此我们不转义空格，然后再写html属性的时候全部带上引号)这样属性就不会被提前关闭了</li></ul> 
<pre><code class="prism language-js"><span class="token keyword">var</span> <span class="token function-variable function">escapeHtmlProperty</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">"</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token string">'&amp;quto;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">'</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token string">'&amp;#39;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex"> </span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token string">'&amp;#32;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> str<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">escapeHtml</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="JavaScript_91"></a>JavaScript处理</h5> 
<blockquote> 
 <p>防御方法就是 JavaScriptEncode</p> 
</blockquote> 
<h6><a id="jsonpjs_95"></a>jsonp或js处理</h6> 
<ul><li> <p>callback 做<strong>长度限制</strong>，这个比较 low，一般对函数名限制在 50 个字符内。</p> </li><li> <p><strong>检测 callback 里面的字符</strong>。一般 callback 里面都是字母和数字，别的符号都不能有。函数名只允许 <code>[</code>, <code>]</code>, <code>a-zA-Z0123456789_</code>, <code>$</code>, <code>.</code>，防止一般的 XSS，utf-7 XSS等攻击。 JSONP 中可以通过意外截断 JSON 数据或者在页面中玩转引号来造成 XSS 攻击。</p> </li><li> <p>需要用 \ 对特殊字符进行转义。保险的方法其实很简单，就是对数据做一次JSON.stringify即可</p> <pre><code class="prism language-js"><span class="token keyword">var</span> <span class="token function-variable function">escapeForJs</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
 <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>str<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">''</span><span class="token punctuation">;</span>
 str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\\</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span><span class="token string">'\\\\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">"</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span><span class="token string">'\\"'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ul> 
<h6><a id="_111"></a>防脚本劫持处理</h6> 
<ul><li>通过判断是否是用户真实操作，而不是脚本处理页面操作</li><li><code>Event.isTrusted</code>属性返回一个布尔值，表示该事件是否由真实的用户行为产生。比如，用户点击链接会产生一个<code>click</code>事件，该事件是用户产生的；<code>Event</code>构造函数生成的事件，则是脚本产生的。</li></ul> 
<h5><a id="CSS_116"></a>CSS处理</h5> 
<ul><li>在 CSS 中或者 style 标签中的攻击花样特别多，要解决 CSS 的攻击问题，一方面要严格控制用户将变量输入 style 标签内，另一方面不要引用未知的 CSS 文件，如果一定有用户改变 CSS 变量这种需求的话，可以使用 OWASP ESAPI 中的 encodeForCSS() 函数。</li><li>除了阿拉伯数字和字母，对其他所有的字符进行编码，只要该字符的ASCII码小于256。编码后输出的格式为 \HH (以 \ 开头，HH则是指该字符对应的十六进制数字)</li></ul> 
<h5><a id="URL_121"></a>URL处理</h5> 
<ul><li>在 URL 中的输出直接使用 encodeURIComponent即可，需要转义变量的部分。</li></ul> 
<h5><a id="_125"></a>富文本处理</h5> 
<ul><li> <p>首先例行进行输入检查，保证用户输入的是完整的 HTML 代码，而不是有拼接的代码</p> </li><li> <p>通过 htmlParser 解析出 HTML 代码的标签、属性、事件</p> </li><li> <p>富文本的事件肯定要被禁止，因为富文本并不需要事件这种东西，另外一些危险的标签也需要禁止，例如： ，</p></li></ul> 
<h5><a id="_138"></a>安全头处理</h5> 
<h6><a id="HTTPonly_Cookie_140"></a>HTTP-only Cookie</h6> 
<ul><li>加密结合Cookie中HttpOnly属性</li></ul> 
<h5><a id="_144"></a>验证码提交处理</h5> 
<ul><li>防止脚本冒充用户提交危险操作</li></ul> 
<h2><a id="CSRF_148"></a>CSRF</h2> 
<ul><li>https://blog.csdn.net/dzqxwzoe/article/details/131796613</li></ul> 
<h3><a id="_152"></a>简介</h3> 
<p>CSRF (Cross-site request forgery，跨站请求伪造)也被称为One Click Attack或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本(XSS)，但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装成受信任用户请求受信任的网站。</p> 
<p>简单的说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己以前认证过的站点并运行一些操作（如发邮件，发消息，甚至财产操作（如转账和购买商品））。因为浏览器之前认证过，所以被访问的站点会觉得这是真正的用户操作而去运行。</p> 
<h3><a id="_159"></a>防御方案</h3> 
<h4><a id="_161"></a>验证码</h4> 
<ul><li> <p>CSRF攻击的过程，往往是在用户不知情的情况下构造了网络请求。而验证码，则强制用户必须与应用进行交互，才能完成最终请求。因此在通常情况下，验证码能够很好地遏制CSRF攻击。</p> </li><li> <p>但是验证码并非万能。很多时候，出于用户体验考虑，网站不能给所有的操作都加上验证码。因此，验证码只能作为防御CSRF的一种辅助手段，而不能作为最主要的解决方案。</p> </li></ul> 
<h4><a id="Referer_169"></a>验证请求头的Referer</h4> 
<ul><li>不靠谱，referer可以伪造</li></ul> 
<h4><a id="token_173"></a>验证请求参数或请求头的token</h4> 
<ul><li>将 token 设置在 Cookie 中，在提交 POST 请求的时候提交 Cookie，并通过 header 或者 body 带上 Cookie 中的 token，服务端进行对比校验。</li></ul> 
<h2><a id="Cookie_179"></a>Cookie</h2> 
<h3><a id="_181"></a>跨站携带</h3> 
<ul><li>cookie信息可以被跨站携带，对于核心cookie的SameSite设置为Strict或Lax来避免</li></ul> 
<h3><a id="_185"></a>被获取</h3> 
<ul><li>将重要的cookie信息设置为HttpOnly来避免</li></ul> 
<h2><a id="websocketCSWSH_191"></a>websocket劫持漏洞(CSWSH)</h2> 
<p>参考资料</p> 
<ul><li>https://blog.csdn.net/god_zzZ/article/details/128779903</li></ul> 
<p>websocket是通过ws:// 和wss:// 通信协议，其中ws可以认为是http的切换，wss是https的切换，是加密的传输协议</p> 
<p>websocket与http的是没有任何关系的，websocket是持久化的协议，而http是非持久的</p> 
<p>WebSocket 提供了全双工沟通，俗称 Web 的 TCP 连接，但 TCP 通常处理字节流（跟消息无关），而 WebSocket 基于 TCP 实现了消息流</p> 
<p>WebSocket 也类似于 TCP 一样进行握手连接，跟 TCP 不同的是，WebSocket 是基于 HTTP 协议进行的握手</p> 
<p>优点：</p> 
<ul><li>支持双向通信，实时性比较强</li><li>更好的二进制支持</li><li>较少的开销。创建连接后，数据交换时候不用携带所有的数据头部信息</li><li>支持拓展</li></ul> 
<p>缺点：</p> 
<ul><li>缺少认证机制</li><li>存在跨站点劫持漏洞</li></ul> 
<h3><a id="_219"></a>防御方案</h3> 
<h4><a id="Origin_221"></a>服务器端检测Origin</h4> 
<ul><li>在服务器端的代码中增加 Origin 检查，如果客户端发来的 Origin 信息来自不同域，建议服务器端拒绝这个请求，发回 403 错误响应拒绝连接</li></ul> 
<h4><a id="WebSocket__225"></a>WebSocket 令牌机制</h4> 
<ul><li> <p>具体实现流程如下：</p> 
  <blockquote> 
   <p>服务器端为每个 WebSocket 客户端生成唯一的一次性 Token；</p> 
   <p>客户端将 Token 作为 WebSocket 连接 URL 的参数（譬如 ws://echo.websocket.org/?token＝randomOneTimeToken），发送到服务器端进行 WebSocket 握手连接；</p> 
   <p>服务器端验证 Token 是否正确，一旦正确则将这个 Token 标示为废弃不再重用，同时确认 WebSocket 握手连接成功；如果 Token 验证失败或者身份认证失败，则返回 403 错误。</p> 
  </blockquote> </li></ul> 
<h4><a id="_235"></a>握手信息加密</h4> 
<ul><li>对重要的websocket信息进行握手加密</li></ul> 
<h2><a id="CORS_241"></a>CORS漏洞</h2> 
<ul><li>因为需要配置CORS响应头来告知浏览器是否允许该请求，所以如果配置不当，就可能导致攻击者通过恶意网站或代码执行跨域请求，从而<strong>获取或篡改用户的敏感数据</strong></li></ul> 
<h3><a id="_245"></a>防御方案</h3> 
<ul><li> <p>限制<code>Access-Control-Allow-Origin</code>的值为可信源，尽可能设置白名单，不能为<code>*</code>，也不能为<code>null</code></p> </li><li> <p>避免<code>Access-Control-Allow-Credentials</code>的值为<code>True</code></p> </li><li> <p>设置<code>Access-Control-Allow-Methods</code>（允许的 HTTP 方法）、<code>Access-Control-Allow-Headers</code>（允许的请求头）</p> </li></ul> 
<h2><a id="_255"></a>传输安全</h2> 
<ul><li>HTTPS证书加密</li></ul> 
<h2><a id="CSP_260"></a>CSP漏洞</h2> 
<ul><li>CSP即content security policy(内容安全策略)，通过设置策略指令来规定资源的加载来源，简单地说就是CSP可以规定页面能从哪些域（站点）加载资源，这里的资源包括js脚本、图片和音频等等</li><li>用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置。CSP 大大增强了网页的安全性。攻击者即使发现了漏洞，也没法注入脚本，除非还控制了一台列入了白名单的可信主机。</li></ul> 
<p>参考资料</p> 
<ul><li>https://www.cnblogs.com/goloving/p/11186176.html</li><li>https://www.jianshu.com/p/887610be21f7</li></ul> 
<p><strong>CSP 指令说明</strong>：<br> default-src : 定义针对所有类型（js/image/css/font/ajax/iframe/多媒体等）资源的默认加载策略，如果某类型资源没有单独定义策略，就使用默认的。<br> script-src : 定义针对 JavaScript 的加载策略。<br> style-src : 定义针对样式的加载策略。<br> worker-src：worker脚本。<br> img-src : 定义针对图片的加载策略。<br> font-src : 定义针对字体的加载策略。<br> media-src : 定义针对多媒体的加载策略，例如:音频标签和视频标签。<br> object-src : 定义针对插件的加载策略，例如：、、。<br> child-src : 定义针对框架的加载策略，例如： ,。<br> connect-src : 定义针对 Ajax/WebSocket 等请求的加载策略。不允许的情况下，浏览器会模拟一个状态为400的响应。<br> sandbox : 定义针对 sandbox 的限制，相当于 的sandbox属性。<br> report-uri : 告诉浏览器如果请求的资源不被策略允许时，往哪个地址提交日志信息。<br> form-action : 定义针对提交的 form 到特定来源的加载策略。<br> referrer : 定义针对 referrer 的加载策略。<br> reflected-xss : 定义针对 XSS 过滤器使用策略。</p> 
<h3><a id="_291"></a>防御方案</h3> 
<h4><a id="CSP_headers_293"></a>设置CSP headers</h4> 
<p>在服务器端，为响应添加以下CSP头部：</p> 
<ul><li> <p>Content-Security-Policy：定义允许加载资源的来源，从而限制恶意脚本的来源。例如：Content-Security-Policy: default-src ‘self’; script-src ‘self’; img-src ‘self’ data:; style-src ‘self’</p> </li><li> <p>Content-Security-Script-Source-List：指定允许脚本加载的来源，仅允许来自可信来源的脚本。例如：Content-Security-Script-Source-List: https://example.com</p> </li></ul> 
<h4><a id="_302"></a>限制脚本执行</h4> 
<ul><li> <p>在HTML中使用<code>sandbox</code>属性，限制脚本在页面上的执行范围。</p> <pre><code class="prism language-js"><span class="token operator">&lt;</span>iframe src<span class="token operator">=</span><span class="token string">"https://example.com"</span> sandbox<span class="token operator">=</span><span class="token string">"allow-scripts allow-same-origin allow-forms"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>iframe<span class="token operator">&gt;</span>
</code></pre> </li></ul> 
<h4><a id="CSP_310"></a>启用CSP报告</h4> 
<ul><li> <p>启用CSP报告功能，以便在检测到违规行为时收到通知。</p> <pre><code class="prism language-js">navigator<span class="token punctuation">.</span>serviceWorker<span class="token punctuation">.</span>ready<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">registration</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  registration<span class="token punctuation">.</span>active<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>data<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'violation-report'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'CSP violation:'</span><span class="token punctuation">,</span> event<span class="token punctuation">.</span>data<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> </li></ul> 
<h4><a id="CSP_324"></a>定期审查和更新CSP策略</h4> 
<ul><li>随着网络环境的变化，定期审查和更新CSP策略，确保其持续有效。</li></ul> 
<h2><a id="JavaScript_328"></a>JavaScript原型链污染漏洞</h2> 
<ul><li>在JavaScript中，对象是通过原型链来继承属性和方法的。每个对象都有一个指向其原型的链接，当我们试图访问一个对象的属性或方法时，如果对象本身没有这个属性或方法，JavaScript会沿着原型链向上查找，直到找到该属性或方法或者抵达原型链的顶端（通常是<code>Object.prototype</code>）。</li><li>原型链污染是指攻击者通过修改对象的原型链，使其包含恶意代码或不受信任的属性和方法。这样一来，当其他代码使用该对象时，可能会意外地调用到恶意代码或者使用不受信任的属性和方法，从而导致安全漏洞。</li></ul> 
<h3><a id="_335"></a>原型链污染原理</h3> 
<p>在 JavaScript 中，每个对象都有一个原型对象，当访问一个对象的属性时，JavaScript 会沿着该对象的原型链向上查找，直到找到该属性或者到达原型链的顶端为止。原型链污染是指攻击者通过修改对象的原型链来实现对代码的攻击。</p> 
<p>下面是一个简单的示例，演示了原型链污染的基本原理：</p> 
<pre><code class="prism language-javascript">javascript复制代码<span class="token comment">// 定义一个基础对象，包含一个 getName 方法</span>
<span class="token keyword">const</span> baseObj <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function-variable function">getName</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token string">'I am a base object'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 定义一个恶意对象，通过原型链污染修改了 getName 方法</span>
<span class="token keyword">const</span> maliciousObj <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function-variable function">getName</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token string">'I am a malicious object'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
maliciousObj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> baseObj<span class="token punctuation">;</span> <span class="token comment">// 修改原型对象为 baseObj</span>

<span class="token comment">// 创建一个普通的对象，并访问 getName 方法</span>
<span class="token keyword">const</span> normalObj <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>normalObj<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：Uncaught TypeError: normalObj.getName is not a function</span>

<span class="token comment">// 修改 normalObj 对象的原型为 maliciousObj</span>
Object<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span>normalObj<span class="token punctuation">,</span> maliciousObj<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 此时再次访问 getName 方法，输出被污染的内容</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>normalObj<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出：I am a malicious object</span>
</code></pre> 
<ul><li> <p>在上面的示例中，定义了一个基础对象 <code>baseObj</code>，它包含一个 <code>getName</code> 方法，该方法返回一个固定的字符串。接下来，定义了一个恶意对象 <code>maliciousObj</code>，该对象同样包含一个 <code>getName</code> 方法，但它返回的字符串不同，并且将 <code>__proto__</code> 属性设置为 <code>base</code></p> </li><li> <p><code>Obj</code> 对象，从而使 <code>maliciousObj</code> 对象的原型指向了 <code>baseObj</code>。接下来，创建了一个普通的对象 <code>normalObj</code>，该对象在原型链上并没有定义 <code>getName</code> 方法。然后，使用 <code>Object.setPrototypeOf</code> 方法将 <code>normalObj</code> 的原型设置为 <code>maliciousObj</code>，从而在 <code>normalObj</code> 对象上成功实现了原型链污染。最后，调用 <code>normalObj.getName()</code> 方法时，JavaScript 沿着 <code>normalObj</code> 对象的原型链查找到了 <code>maliciousObj</code> 对象，并返回了被污染的 <code>getName</code> 方法的内容。</p> </li></ul> 
<h3><a id="_372"></a>防御方案</h3> 
<h4><a id="_374"></a>输入验证</h4> 
<ul><li>在接收用户输入之前，始终进行有效性验证，确保用户提供的数据符合预期的格式和内容。</li></ul> 
<h4><a id="JSONparse_378"></a>JSON.parse安全解析</h4> 
<ul><li> <p>如果需要解析JSON数据，请使用 <code>JSON.parse</code> 的第二个参数将属性名转换为字符串，避免原型链污染。</p> <pre><code class="prism language-js"><span class="token keyword">const</span> userInput <span class="token operator">=</span> <span class="token string">'{"__proto__": {"debug": true}}'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> userConfig <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>userInput<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">===</span> <span class="token string">'__proto__'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 或者抛出错误</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> </li></ul> 
<h4><a id="ObjectdefineProperty_392"></a>Object.defineProperty设置</h4> 
<ul><li>在设置对象的属性时，可以使用 <code>Object.defineProperty</code> 来定义只读或不可枚举的属性，防止原型链被污染。</li></ul> 
<pre><code class="prism language-js"><span class="token keyword">const</span> config <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
  <span class="token literal-property property">debug</span><span class="token operator">:</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token keyword">const</span> userInput <span class="token operator">=</span> <span class="token string">'{"__proto__": {"debug": true}}'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> userConfig <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>userInput<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token comment">// 合并用户配置和默认配置</span>
<span class="token keyword">const</span> mergedConfig <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">,</span> config<span class="token punctuation">)</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>userConfig<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">key</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>mergedConfig<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">value</span><span class="token operator">:</span> userConfig<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token literal-property property">enumerable</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">// 阻止属性被枚举</span>
    <span class="token literal-property property">writable</span><span class="token operator">:</span> <span class="token boolean">false</span> <span class="token comment">// 阻止属性被修改</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="Objectfreeze_415"></a>使用Object.freeze()冻结对象</h4> 
<ul><li>使用<code>Object.freeze()</code>可以冻结一个对象，使其无法添加、删除属性，已有属性的值也无法修改。这使得即使攻击者能够修改到对象的原型，也无法通过修改冻结对象的原型来造成污染。</li></ul> 
<pre><code class="prism language-js"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"SAFe"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="Map_424"></a>使用Map代替普通对象</h4> 
<ul><li>在某些情况下，可以使用Map而不是普通的JavaScript对象来储存键值对。与普通对象不同，Map不会受到原型污染的影响，因为它们不是通过原型链查找值。</li></ul> 
<pre><code class="prism language-js"><span class="token keyword">const</span> safeMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
safeMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">,</span> <span class="token string">'value'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 安全地设置键值对</span>
</code></pre> 
<h3><a id="Objectcreate_433"></a>使用Object.create</h3> 
<ul><li>使用这个方法就可以更好的防御原型链污染攻击了，因为Object.create(null)使得创建的新对象没有任何的原型链，是null的，不具备任何的继承关系，当你接受一个客户端的参数并且打算merge的话，可以使用此方法后去merge，这样的对象是比较安全的，客户端没办法通过原型链来污染攻击(因为压根就没原型链通往其他的对象)</li></ul> 
<h2><a id="_437"></a>文件上传漏洞</h2> 
<h3><a id="_439"></a>客户端</h3> 
<ul><li>校验文件类型及后缀格式</li></ul> 
<h3><a id="_443"></a>服务端</h3> 
<ul><li>检查后缀及MIME</li><li>检查内容及文件头</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8abddce0a78e7f6960cfbbaa0a468cb5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C/C&#43;&#43;】用C语言写一个数据仓库，存储和修改数据</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9991f281b4f26c0538972e0524a85f51/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">macOS Sequoia 开发者测试版下载和安装教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程大咖.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>